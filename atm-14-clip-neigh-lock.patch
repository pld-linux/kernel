>thursday.  the box is still up and oops-free this morning.  so, we
>definately have an smp problem here...

its a start!

>now, how in the world do we go about tracking something like this down?

try the following patch.  the neighbour code in clip seems a bit 
non-standard -- there might be other lossage

Index: net/atm/clip.c
===================================================================
RCS file: /afs/cmf/project/cvsroot/linux/net/atm/clip.c,v
retrieving revision 1.8
diff -u -r1.8 clip.c
--- net/atm/clip.c	7 Mar 2003 18:54:44 -0000	1.8
+++ net/atm/clip.c	10 Mar 2003 12:33:43 -0000
@@ -121,13 +121,15 @@
 	/*DPRINTK("idle_timer_check\n");*/
 	write_lock(&clip_tbl.lock);
 	for (i = 0; i <= NEIGH_HASHMASK; i++) {
-		struct neighbour **np;
+		struct neighbour *n, **np;
 
-		for (np = &clip_tbl.hash_buckets[i]; *np;) {
-			struct neighbour *n = *np;
+		np = &clip_tbl.hash_buckets[i];
+		while ((n = *np) != NULL) {
 			struct atmarp_entry *entry = NEIGH2ENTRY(n);
 			struct clip_vcc *clip_vcc;
 
+			write_lock(&n->lock);
+
 			for (clip_vcc = entry->vccs; clip_vcc;
 			    clip_vcc = clip_vcc->next)
 				if (clip_vcc->idle_timeout &&
@@ -139,8 +141,10 @@
 					atm_async_release_vcc(clip_vcc->vcc,
 					    -ETIMEDOUT);
 				}
+
 			if (entry->vccs ||
 			    time_before(jiffies, entry->expires)) {
+				write_unlock(&n->lock);
 				np = &n->next;
 				continue;
 			}
@@ -152,12 +156,14 @@
 				while ((skb = skb_dequeue(&n->arp_queue)) !=
 				     NULL) 
 					dev_kfree_skb(skb);
+				write_unlock(&n->lock);
 				np = &n->next;
 				continue;
 			}
 			*np = n->next;
 			DPRINTK("expired neigh %p\n",n);
 			n->dead = 1;
+			write_unlock(&n->lock);
 			neigh_release(n);
 		}
 	}


-------------------------------------------------------
This sf.net email is sponsored by:ThinkGeek
Welcome to geek heaven.
http://thinkgeek.com/sf
_______________________________________________
Linux-atm-general mailing list
Linux-atm-general@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/linux-atm-general
