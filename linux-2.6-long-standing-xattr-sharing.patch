Subject: [FIX] Long-standing xattr sharing bug
From: Andreas Gruenbacher <agruen@suse.de>

When looking for identical xattr blocks to share, we were not comparing
the name_index fields. This could lead to false sharing when two xattr
blocks ended up with identical attribute names and values, and the only
dif. was in name_index. Specifically this could trigger with default acls.
Because acls are cached, the bug was hidden until the next reload
of the affected inode.

  $ mkdir -m 700 a b
  $ setfacl -m u:bin:rwx a
	< acl of a goes in the mbcache

  $ setfacl -dm u:bin:rwx b
	< acl of b differs only in name_index, so a's acl is reused

  $ getfacl b
	< shows the result from the inode cache

  < empty inode cache (remount, etc.)

  $ getfacl b
	< shows an access acl instead of a default acl.

Signed-off-by: Andreas Gruenbacher <agruen@suse.de>

--- linux-2.6.10/fs/ext2/xattr.c	2005-02-13 23:54:04.850076824 +0100
+++ linux-2.6.10/fs/ext2/xattr.c.orig	2005-02-13 18:47:20.000000000 +0100
@@ -856,6 +856,7 @@
 		if (IS_LAST_ENTRY(entry2))
 			return 1;
 		if (entry1->e_hash != entry2->e_hash ||
+		    entry1->e_name_index != entry2->e_name_index ||
 		    entry1->e_name_len != entry2->e_name_len ||
 		    entry1->e_value_size != entry2->e_value_size ||
 		    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))
--- linux-2.6.10/fs/ext3/xattr.c	2005-02-13 23:54:07.528669616 +0100
+++ linux-2.6.10/fs/ext3/xattr.c.orig	2005-02-13 18:47:20.000000000 +0100
@@ -914,6 +914,7 @@
 		if (IS_LAST_ENTRY(entry2))
 			return 1;
 		if (entry1->e_hash != entry2->e_hash ||
+		    entry1->e_name_index != entry2->e_name_index ||
 		    entry1->e_name_len != entry2->e_name_len ||
 		    entry1->e_value_size != entry2->e_value_size ||
 		    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))
