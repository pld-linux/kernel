diff -urN linux/arch/i386/config.in linux/arch/i386/config.in
--- linux/arch/i386/config.in	Tue Jan  9 16:24:13 2001
+++ linux/arch/i386/config.in	Wed Jan 10 07:08:08 2001
@@ -143,6 +143,7 @@
 tristate '/dev/cpu/microcode - Intel P6 CPU microcode support' CONFIG_MICROCODE
 tristate '/dev/cpu/*/msr - Model-specific register support' CONFIG_X86_MSR
 tristate '/dev/cpu/*/cpuid - CPU information support' CONFIG_X86_CPUID
+bool 'E820 proc support' CONFIG_E820_PROC
 
 choice 'High Memory Support' \
 	"off    CONFIG_NOHIGHMEM \
--- linux/arch/i386/kernel/Makefile	Wed Jan 17 15:58:23 2001
+++ linux/arch/i386/kernel/Makefile	Wed Jan 17 15:58:47 2001
@@ -31,6 +31,7 @@
 endif
 
 obj-$(CONFIG_MCA)		+= mca.o
+obj-$(CONFIG_E820_PROC)  	+= e820.o rpmhelper.o
 obj-$(CONFIG_MTRR)		+= mtrr.o
 obj-$(CONFIG_X86_MSR)		+= msr.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
diff -urN linux/arch/i386/kernel/e820.c linux/arch/i386/kernel/e820.c
--- linux/arch/i386/kernel/e820.c	Wed Dec 31 19:00:00 1969
+++ linux/arch/i386/kernel/e820.c	Wed Jan 10 07:05:51 2001
@@ -0,0 +1,89 @@
+/* Copyright (c) 2001 Red Hat, Inc. All rights reserved.
+ * This software may be freely redistributed under the terms of the
+ * GNU General Public License.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Author: Arjan van de Ven <arjanv@redhat.com
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>      /* for module_init/exit */
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+
+#include <asm/e820.h>
+
+extern struct e820map e820;
+struct proc_dir_entry *e820_proc_entry;
+
+static int e820_proc_output(char *buffer, int bufsize)
+{
+        int i,bufpos=0;
+
+        for (i = 0; i < e820.nr_map; i++) {
+		/* FIXME: check for overflow */
+                bufpos += sprintf(buffer+bufpos,"%016Lx @ %016Lx ", 
+                        e820.map[i].size, e820.map[i].addr);
+                switch (e820.map[i].type) {
+                case E820_RAM:  bufpos += sprintf(buffer+bufpos,"(usable)\n");
+                                break;
+                case E820_RESERVED:
+                                bufpos += sprintf(buffer+bufpos,"(reserved)\n");
+                                break;
+                case E820_ACPI:
+                                bufpos += sprintf(buffer+bufpos,"(ACPI data)\n");
+                                break;
+                case E820_NVS:
+                                bufpos += sprintf(buffer+bufpos,"(ACPI NVS)\n");
+                                break;
+                default:        bufpos += sprintf(buffer+bufpos,"type %lu\n", e820.map[i].type);
+                                break;
+                }
+        }
+	return bufpos;
+}
+
+
+
+
+
+
+static int e820_read_proc(char *page, char **start, off_t off,
+                         int count, int *eof, void *data)
+{
+        int len = e820_proc_output (page,4096);
+        if (len <= off+count) *eof = 1;
+        *start = page + off;
+        len -= off;
+        if (len>count) len = count;
+        if (len<0) len = 0;
+        return len;
+}
+
+int e820_module_init(void)
+{        
+        /* /proc/e820info probably isn't the best place for it, need
+           to find a better one */
+	e820_proc_entry = create_proc_entry ("e820info", 0, NULL);
+	if (e820_proc_entry==NULL)
+		return -EIO;
+
+	e820_proc_entry->read_proc = e820_read_proc;
+	e820_proc_entry->owner = THIS_MODULE;
+
+	return 0;
+}
+
+
+void e820_module_exit(void)
+{
+	 remove_proc_entry ("e820info", e820_proc_entry);
+}
+
+module_init(e820_module_init);
+module_exit(e820_module_exit);
+
diff -urN /usr/src/linux-2.4.9-7/arch/i386/kernel/rpmhelper.c linux/arch/i386/kernel/rpmhelper.c
--- /usr/src/linux-2.4.9-7/arch/i386/kernel/rpmhelper.c	Thu Jan  1 01:00:00 1970
+++ linux/arch/i386/kernel/rpmhelper.c	Sun Oct 28 17:09:58 2001
@@ -0,0 +1,102 @@
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>      /* for module_init/exit */
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+
+#include <asm/e820.h>
+#include <asm/cpufeature.h>
+#include <asm/processor.h>
+
+
+/* this file, present in the -BOOT kernel, informs anaconda about which 
+   kernels this system needs. While not impossible to do in userspace,
+   the kernel has the authorative list of defective bioses (440GX etc) that
+   have special needs.
+ */
+
+#define cpu_has_cmov    (test_bit(X86_FEATURE_CMOV, boot_cpu_data.x86_capability))
+
+
+extern char rpmarchitecture[];
+extern char rpmkerneltype[];
+extern int skip_ioapic_setup;
+
+extern struct e820map e820;
+extern struct cpuinfo_x86 boot_cpu_data;
+
+static inline int needbigmem()
+{
+        int i;
+        
+        /* no pae no bigmem */
+        if ( (!cpu_has_pae) || (!cpu_has_xmm) )
+        	return 0;
+
+        for (i = 0; i < e820.nr_map; i++) {
+                switch (e820.map[i].type) {
+                case E820_RAM:  
+                		if (e820.map[i].addr > 0xffffffff)
+                			return 1;
+                		if (e820.map[i].addr+e820.map[i].size > 0xffffffff)
+                			return 1;
+                                break;
+                default:        
+                                break;
+                }
+        }
+	return 0;
+}
+
+static inline void cputype(void)
+{
+	/* i386 works always */
+	sprintf(rpmarchitecture,"i386");
+	/* test for i586 and up */
+	if (boot_cpu_data.x86_model<5)
+		return;
+	sprintf(rpmarchitecture,"i586 i385");
+	/* i686 and above needs cmov support */
+	if (!cpu_has_cmov)
+		return;
+	sprintf(rpmarchitecture,"i686 i586 i386");
+	
+	/* athlon */
+	if ((boot_cpu_data.x86_vendor == X86_VENDOR_AMD) && 
+	    (boot_cpu_data.x86>=6) )
+		sprintf(rpmarchitecture,"athlon i686 i586 i386");
+	
+}
+
+int __init rpmhelper_init(void)
+{        
+	int ent=0,smp=0;
+	/* > 4Gb ram addressable -> Enterprise kernel */
+	ent = needbigmem();
+	/* 440GX or similarly broken bios ? -> smp kernel */
+	#if CONFIG_X86_LOCAL_APIC
+	if (skip_ioapic_setup==0)
+		smp = 1;
+	#endif
+	
+	if (ent && smp)
+		sprintf(rpmkerneltype,"bigmem smp");
+	else
+		if (smp)
+			sprintf(rpmkerneltype,"smp");
+	
+	cputype();
+	
+	return 0;
+}
+
+
+void rpmhelper_exit(void)
+{
+}
+
+module_init(rpmhelper_init);
+module_exit(rpmhelper_exit);
+
diff -urN /usr/src/linux-2.4.9-7/include/linux/sysctl.h linux/include/linux/sysctl.h
--- /usr/src/linux-2.4.9-7/include/linux/sysctl.h	Thu Oct 18 18:42:27 2001
+++ linux/include/linux/sysctl.h	Sun Oct 28 17:13:51 2001
@@ -601,6 +601,11 @@
 
 /* CTL_DEBUG names: */
 
+enum {
+	DEBUG_RPM1=500,
+	DEBUG_RPM2=501
+};
+
 /* CTL_DEV names: */
 enum {
 	DEV_CDROM=1,
diff -urN /usr/src/linux-2.4.9-7/kernel/sysctl.c linux/kernel/sysctl.c
--- /usr/src/linux-2.4.9-7/kernel/sysctl.c	Thu Oct 18 18:34:52 2001
+++ linux/kernel/sysctl.c	Sun Oct 28 17:13:18 2001
@@ -76,6 +76,9 @@
 extern int sem_ctls[];
 #endif
 
+char rpmarchitecture[64];
+char rpmkerneltype[64];
+
 #ifdef __sparc__
 extern char reboot_command [];
 extern int stop_a_enabled;
@@ -335,6 +338,10 @@
 };
 
 static ctl_table debug_table[] = {
+	{DEBUG_RPM1, "kerneltype", rpmkerneltype, 64,
+	 0444, NULL, &proc_doutsstring, &sysctl_string},
+	{DEBUG_RPM2, "rpmarch", rpmarchitecture, 64,
+	 0444, NULL, &proc_doutsstring, &sysctl_string},
 	{0}
 };
 
