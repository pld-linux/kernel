--- linux-2.6.27/arch/sparc/include/asm/spinlock_64.h~	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.27/arch/sparc/include/asm/spinlock_64.h	2007-04-10 01:05:35.426190250 +0200
@@ -105,7 +105,7 @@
 
 /* Multi-reader locks, these are much saner than the 32-bit Sparc ones... */
 
-static void inline __read_lock(raw_rwlock_t *lock)
+static inline void __read_lock(raw_rwlock_t *lock)
 {
 	unsigned long tmp1, tmp2;
 
@@ -130,7 +130,7 @@
 	: "memory");
 }
 
-static int inline __read_trylock(raw_rwlock_t *lock)
+static inline int __read_trylock(raw_rwlock_t *lock)
 {
 	int tmp1, tmp2;
 
@@ -152,7 +152,7 @@
 	return tmp1;
 }
 
-static void inline __read_unlock(raw_rwlock_t *lock)
+static inline void __read_unlock(raw_rwlock_t *lock)
 {
 	unsigned long tmp1, tmp2;
 
@@ -169,7 +169,7 @@
 	: "memory");
 }
 
-static void inline __write_lock(raw_rwlock_t *lock)
+static inline void __write_lock(raw_rwlock_t *lock)
 {
 	unsigned long mask, tmp1, tmp2;
 
@@ -196,7 +196,7 @@
 	: "memory");
 }
 
-static void inline __write_unlock(raw_rwlock_t *lock)
+static inline void __write_unlock(raw_rwlock_t *lock)
 {
 	__asm__ __volatile__(
 "	membar		#LoadStore | #StoreStore\n"
@@ -206,7 +206,7 @@
 	: "memory");
 }
 
-static int inline __write_trylock(raw_rwlock_t *lock)
+static inline int __write_trylock(raw_rwlock_t *lock)
 {
 	unsigned long mask, tmp1, tmp2, result;
 
--- linux-2.6.20/arch/powerpc/kernel/prom_init.c~	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20/arch/powerpc/kernel/prom_init.c	2007-04-10 01:59:33.712570500 +0200
@@ -429,14 +429,14 @@
 	}
 }
 
-static int inline prom_getprop(phandle node, const char *pname,
+static inline int prom_getprop(phandle node, const char *pname,
 			       void *value, size_t valuelen)
 {
 	return call_prom("getprop", 4, 1, node, ADDR(pname),
 			 (u32)(unsigned long) value, (u32) valuelen);
 }
 
-static int inline prom_getproplen(phandle node, const char *pname)
+static inline int prom_getproplen(phandle node, const char *pname)
 {
 	return call_prom("getproplen", 2, 1, node, ADDR(pname));
 }
--- linux-2.6.24-rc8/fs/ocfs2/dir.c.org	2008-01-23 08:32:50.134566450 +0100
+++ linux-2.6.24-rc8/fs/ocfs2/dir.c	2008-01-23 08:32:57.441604337 +0100
@@ -126,7 +126,7 @@
 /*
  * Returns 0 if not found, -1 on failure, and 1 on success
  */
-static int inline ocfs2_search_dirblock(struct buffer_head *bh,
+static inline int ocfs2_search_dirblock(struct buffer_head *bh,
 					struct inode *dir,
 					const char *name, int namelen,
 					unsigned long offset,
--- linux-2.6.20/drivers/media/video/cx88/cx88.h~	2007-04-10 01:58:14.000000000 +0200
+++ linux-2.6.20/drivers/media/video/cx88/cx88.h	2007-04-10 02:17:05.442299500 +0200
@@ -89,13 +89,13 @@
 /* ----------------------------------------------------------- */
 /* tv norms                                                    */
 
-static unsigned int inline norm_maxw(v4l2_std_id norm)
+static inline unsigned int norm_maxw(v4l2_std_id norm)
 {
 	return (norm & (V4L2_STD_MN & ~V4L2_STD_PAL_Nc)) ? 720 : 768;
 }
 
 
-static unsigned int inline norm_maxh(v4l2_std_id norm)
+static inline unsigned int norm_maxh(v4l2_std_id norm)
 {
 	return (norm & V4L2_STD_625_50) ? 576 : 480;
 }
--- linux-2.6.20/drivers/isdn/hardware/eicon/platform.h~	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20/drivers/isdn/hardware/eicon/platform.h	2007-04-10 02:20:13.490051750 +0200
@@ -219,7 +219,7 @@
 /*
 **  I/O Port utilities
 */
-int diva_os_register_io_port (void *adapter, int register, unsigned long port,
+int diva_os_register_io_port (void *adapter, register int, unsigned long port,
 				unsigned long length, const char* name, int id);
 /*
 **  I/O port access abstraction
@@ -287,13 +287,13 @@
 **  atomic operation, fake because we use threads
 */
 typedef int diva_os_atomic_t;
-static diva_os_atomic_t __inline__
+static __inline__ diva_os_atomic_t
 diva_os_atomic_increment(diva_os_atomic_t* pv)
 {
   *pv += 1;
   return (*pv);
 }
-static diva_os_atomic_t __inline__
+static __inline__ diva_os_atomic_t
 diva_os_atomic_decrement(diva_os_atomic_t* pv)
 {
   *pv -= 1;
