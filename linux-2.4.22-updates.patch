From ak@suse.de Mon Oct  6 01:11:13 2003
Date: 03 Oct 2003 10:24:23 +0200
From: Andi Kleen <ak@suse.de>
To: Sylvain Pasche <sylvain_pasche@yahoo.fr>
Cc: linux-kernel@vger.kernel.org
Subject: Re: 2.4.22 ACPI power off via sysrq not working

Sylvain Pasche <sylvain_pasche@yahoo.fr> writes:

> Hi, 
> 
> If I want to halt the system using sys-rq - o key, I get an oops instead
> of a power down.
> Inside pm.c:159, there is:
> 	
> 	if (in_interrupt())
> 		BUG();
> 
> But if we look at the trace, we are in the interrupt of the keyboard
> handler.
> One fix would be to comment out the BUG line, but there's certainly "a
> better way to do it".

Use this patch.

diff -u linux/drivers/acpi/system.c-o linux/drivers/acpi/system.c
--- linux/drivers/acpi/system.c-o	2003-09-07 16:20:44.000000000 +0200
+++ linux/drivers/acpi/system.c	2003-09-08 21:04:46.000000000 +0200
@@ -1192,11 +1192,21 @@
 
 #if defined(CONFIG_MAGIC_SYSRQ) && defined(CONFIG_PM)
 
+static int po_cb_active; 
+
+static void acpi_po_tramp(void *x)
+{ 
+	acpi_power_off();	
+} 
+
 /* Simple wrapper calling power down function. */
 static void acpi_sysrq_power_off(int key, struct pt_regs *pt_regs,
 	struct kbd_struct *kbd, struct tty_struct *tty)
-{
-	acpi_power_off();
+{	
+	static struct tq_struct tq = { .routine = acpi_po_tramp };
+	if (po_cb_active++)
+		return;
+	schedule_task(&tq); 
 }
 
 struct sysrq_key_op sysrq_acpi_poweroff_op = {


-Andi


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
From zzz@anda.ru Tue Oct  7 09:07:20 2003
Date: Fri, 3 Oct 2003 00:50:16 +0600
From: Denis Zaitsev <zzz@anda.ru>
To: linux-scsi@vger.kernel.org
Cc: linux-kernel@vger.kernel.org, gibbs@scsiguy.com, dledford@redhat.com,
     marcelo@conectiva.com.br
Subject: [PATCH][TRIVIAL] (2.4.22) Allow aic7xxx_osm.c to be compiled
    without CONFIG_PCI

This is the trivial #ifdef patch for CONFIG_PCI/EISA.  In my case it
allows the Adaptec SCSI driver (the "new" one) to be compiled for
non-PCI (EISA) system.  Else there are an <undefined symbol> errors.
The 2.6 branch needs the same patch, as I understand.

Please, apply it.  (I don't know who is the maintainer for now!)


--- linux-2.4.22.orig/drivers/scsi/aic7xxx/aic7xxx_osm.c	Mon Aug 25 05:44:42 2003
+++ linux-2.4.22/drivers/scsi/aic7xxx/aic7xxx_osm.c	Mon Oct  6 01:05:04 2003
@@ -1552,6 +1552,7 @@
 
 	/* Still equal.  Sort by BIOS address, ioport, or bus/slot/func. */
 	switch (rvalue) {
+#ifdef CONFIG_PCI
 	case AHC_PCI:
 	{
 		char primary_channel;
@@ -1584,6 +1585,8 @@
 			value = 1;
 		break;
 	}
+#endif
+#ifdef CONFIG_EISA
 	case AHC_EISA:
 		if ((rahc->flags & AHC_BIOS_ENABLED) != 0) {
 			value = rahc->platform_data->bios_address
@@ -1593,6 +1596,7 @@
 			      - lahc->bsh.ioport; 
 		}
 		break;
+#endif
 	default:
 		panic("ahc_softc_sort: invalid bus type");
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
[PATCH] Compile fix for ACPI in 2.4.22/x86-64

Marcelo unfortunately added an last minute ACPI update that changed
ACPI interfaces and broke x86-64 compilation. I didn't catch it in
time, so 2.4.22 does not compile out of the box for AMD64.

This patch fixes it.
You'll have to apply it when compiling 2.4.22 for x86-64

-Andi

All diffs for ChangeSet 1.1074

diff -Nru a/arch/x86_64/kernel/io_apic.c b/arch/x86_64/kernel/io_apic.c

--- a/arch/x86_64/kernel/io_apic.c	Tue Jun 24 13:45:14 2003
+++ b/arch/x86_64/kernel/io_apic.c	Fri Aug 22 03:38:16 2003
@@ -1762,7 +1762,7 @@
 }
 
 
-int io_apic_set_pci_routing (int ioapic, int pin, int irq)
+int io_apic_set_pci_routing (int ioapic, int pin, int irq, int edge_level ,int active_high_low)
 {
 	struct IO_APIC_route_entry entry;
 	unsigned long flags;
@@ -1785,18 +1785,21 @@
 	entry.dest_mode = INT_DELIVERY_MODE;
 	entry.dest.logical.logical_dest = TARGET_CPUS;
 	entry.mask = 1;					 /* Disabled (masked) */
-	entry.trigger = 1;				   /* Level sensitive */
-	entry.polarity = 1;					/* Low active */
+	entry.trigger = edge_level;	
+	entry.polarity = active_high_low;
 
 	add_pin_to_irq(irq, ioapic, pin);
 
 	entry.vector = assign_irq_vector(irq);
 
 	printk(KERN_DEBUG "IOAPIC[%d]: Set PCI routing entry (%d-%d -> 0x%x -> "
-		"IRQ %d)\n", ioapic, 
-		mp_ioapics[ioapic].mpc_apicid, pin, entry.vector, irq);
+		"IRQ %d) Mode:%i Active:%i\n", ioapic, 
+		mp_ioapics[ioapic].mpc_apicid, pin, entry.vector, irq, edge_level, active_high_low);
 
-	irq_desc[irq].handler = &ioapic_level_irq_type;
+	if (edge_level)
+		irq_desc[irq].handler = &ioapic_level_irq_type;
+	else
+		irq_desc[irq].handler = &ioapic_edge_irq_type;
 
 	set_intr_gate(entry.vector, interrupt[irq]);
 
diff -Nru a/arch/x86_64/kernel/mpparse.c b/arch/x86_64/kernel/mpparse.c

--- a/arch/x86_64/kernel/mpparse.c	Tue Jun 24 14:01:06 2003
+++ b/arch/x86_64/kernel/mpparse.c	Fri Aug 22 03:29:25 2003
@@ -923,7 +923,7 @@
 
 	ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
 
-	io_apic_set_pci_routing(ioapic, ioapic_pin, irq);
+	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 1, 1);
 }
 
 #endif /*CONFIG_ACPI_HT_ONLY*/
@@ -939,6 +939,8 @@
 	int			ioapic_pin = 0;
 	int			irq = 0;
 	int			idx, bit = 0;
+	int			edge_level = 0;
+	int			active_high_low = 0;
 
 	/*
 	 * Parsing through the PCI Interrupt Routing Table (PRT) and program
@@ -949,11 +951,14 @@
 
 		/* Need to get irq for dynamic entry */
 		if (entry->link.handle) {
-			irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index);
+			irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index, &edge_level, &active_high_low);
 			if (!irq)
 				continue;
-		} else
+		} else {
+			edge_level = 1;
+			active_high_low = 1;
 			irq = entry->link.index;
+		}
 
 		irq = entry->link.index;
 		ioapic = mp_find_ioapic(irq);
@@ -983,7 +988,7 @@
 
 		mp_ioapic_routing[ioapic].pin_programmed[idx] |= (1<<bit);
 
-		vector = io_apic_set_pci_routing(ioapic, ioapic_pin, irq);
+		vector = io_apic_set_pci_routing(ioapic, ioapic_pin, irq, edge_level, active_high_low);
 		if (vector)
 			entry->irq = irq;
 
diff -Nru a/include/asm-x86_64/io_apic.h b/include/asm-x86_64/io_apic.h

--- a/include/asm-x86_64/io_apic.h	Sat Aug  9 13:32:28 2003
+++ b/include/asm-x86_64/io_apic.h	Fri Aug 22 03:29:25 2003
@@ -148,6 +148,6 @@
 extern int io_apic_get_unique_id (int ioapic, int apic_id);
 extern int io_apic_get_version (int ioapic);
 extern int io_apic_get_redir_entries (int ioapic);
-extern int io_apic_set_pci_routing (int ioapic, int pin, int irq);
+extern int io_apic_set_pci_routing (int ioapic, int pin, int irq, int, int);
 
 #endif

<http://www.bitkeeper.com>

ChangeSet@1.1065.1.36  03-08-25 13:58:04-03:00  willy@ods.org
all diffs

[PATCH] Fix amd67x_pm.c crash with no chipsets / CONFIG_HOTPLUG

amd76x_pm.c will crash if no chipsets are found and CONFIG_HOTPLUG is
turned on.  This patch makes it return with a failure instead.

<patch@1.1065.1.36??nav=index.html|ChangeSet@-3d|cset@1.1065.1.36>

diff -Nru a/drivers/char/amd76x_pm.c b/drivers/char/amd76x_pm.c

--- a/drivers/char/amd76x_pm.c	Mon Aug 25 09:51:20 2003
+++ b/drivers/char/amd76x_pm.c	Mon Aug 25 04:22:01 2003
@@ -577,16 +577,18 @@
 	int found;
 
 	/* Find northbridge */
-	found = pci_module_init(&amd_nb_driver);
-	if (found < 0) {
+	found = pci_register_driver(&amd_nb_driver);
+	if (found <= 0) {
 		printk(KERN_ERR "amd76x_pm: Could not find northbridge\n");
+		pci_unregister_driver(&amd_nb_driver);
 		return 1;
 	}
 
 	/* Find southbridge */
-	found = pci_module_init(&amd_sb_driver);
-	if (found < 0) {
+	found = pci_register_driver(&amd_sb_driver);
+	if (found <= 0) {
 		printk(KERN_ERR "amd76x_pm: Could not find southbridge\n");
+		pci_unregister_driver(&amd_sb_driver);
 		pci_unregister_driver(&amd_nb_driver);
 		return 1;
 	}
@@ -620,6 +622,8 @@
 #ifndef AMD76X_NTH
 	if (!amd76x_pm_cfg.curr_idle) {
 		printk(KERN_ERR "amd76x_pm: Idle function not changed\n");
+		pci_unregister_driver(&amd_nb_driver);
+		pci_unregister_driver(&amd_sb_driver);
 		return 1;
 	}
 

<http://www.bitkeeper.com>

From chas@cmf.nrl.navy.mil Sat Aug 30 01:03:00 2003
Date: Thu, 28 Aug 2003 16:03:23 -0400
From: chas williams <chas@cmf.nrl.navy.mil>
To: Krzysztof Sierota <krzysiek@mediaone.pl>
Cc: linux-kernel@vger.kernel.org, linux-atm@vger.rutgers.edu
Subject: Re: 2.4.22 oops in ATM 2.4.21 works fine 

>the 2.4.22 kernel is oopsing at start scripts, machine stays alive, but A=
>TM=20
>does not work. 2.4.21 works just fine.

try this patch:

--- linux-2.4.22/net/atm/common.c.000	Tue Aug 26 10:40:30 2003
+++ linux-2.4.22/net/atm/common.c	Tue Aug 26 13:12:35 2003
@@ -672,7 +672,8 @@
 			}
 			if (try_atm_clip_ops()) {
 				ret_val = atm_clip_ops->clip_create(arg);
-				__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+				if (atm_clip_ops->owner)
+					__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 			} else
 				ret_val = -ENOSYS;
 			goto done;
@@ -687,7 +688,8 @@
 #endif
 			if (try_atm_clip_ops()) {
 				error = atm_clip_ops->atm_init_atmarp(vcc);
-				__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+				if (atm_clip_ops->owner)
+					__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 				if (!error)
 					sock->state = SS_CONNECTED;
 				ret_val = error;
@@ -701,7 +703,8 @@
 			}
 			if (try_atm_clip_ops()) {
 				ret_val = atm_clip_ops->clip_mkip(vcc, arg);
-				__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+				if (atm_clip_ops->owner)
+					__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 			} else
 				ret_val = -ENOSYS;
 			goto done;
@@ -712,7 +715,8 @@
 			}
 			if (try_atm_clip_ops()) {
 				ret_val = atm_clip_ops->clip_setentry(vcc, arg);
-				__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+				if (atm_clip_ops->owner)
+					__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 			} else
 				ret_val = -ENOSYS;
 			goto done;
@@ -723,7 +727,8 @@
 			}
 			if (try_atm_clip_ops()) {
 				ret_val = atm_clip_ops->clip_encap(vcc, arg);
-				__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+				if (atm_clip_ops->owner)
+					__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 			} else
 				ret_val = -ENOSYS;
 			goto done;
--- linux-2.4.22/net/atm/proc.c.000	Tue Aug 26 13:30:23 2003
+++ linux-2.4.22/net/atm/proc.c	Tue Aug 26 13:31:58 2003
@@ -358,7 +358,7 @@
 				spin_unlock_irqrestore(&dev->lock, flags);
 				spin_unlock(&atm_dev_lock);
 #if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
-				if (clip_info)
+				if (clip_info && atm_clip_ops->owner)
 					__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 #endif
 				return strlen(buf);
@@ -367,8 +367,8 @@
 	}
 	spin_unlock(&atm_dev_lock);
 #if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
-	if (clip_info)
-		__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+	if (clip_info && atm_clip_ops->owner)
+			__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 #endif
 	return 0;
 }
@@ -458,7 +458,8 @@
 				if (--count) continue;
 				atmarp_info(n->dev,entry,NULL,buf);
 				read_unlock_bh(&clip_tbl_hook->lock);
-				__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+				if (atm_clip_ops->owner)
+					__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 				return strlen(buf);
 			}
 			for (vcc = entry->vccs; vcc;
@@ -466,12 +467,14 @@
 				if (--count) continue;
 				atmarp_info(n->dev,entry,vcc,buf);
 				read_unlock_bh(&clip_tbl_hook->lock);
-				__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+				if (atm_clip_ops->owner)
+					__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 				return strlen(buf);
 			}
 		}
 	read_unlock_bh(&clip_tbl_hook->lock);
-	__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
+	if (atm_clip_ops->owner)
+		__MOD_DEC_USE_COUNT(atm_clip_ops->owner);
 	return 0;
 }
 #endif
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
From linux-kernel@vger.kernel.org Wed Aug 27 15:59:09 2003
Date: Wed, 27 Aug 2003 14:07:03 +0000
From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
To: bk-commits-24@vger.kernel.org
Subject: Fix possible IRQ handling SMP race: Kudos to TeJun Huh

ChangeSet 1.1084, 2003/08/27 11:07:03-03:00, marcelo@logos.cnet

	  Fix possible IRQ handling SMP race: Kudos to TeJun Huh


# This patch includes the following deltas:
#	           ChangeSet	1.1083  -> 1.1084 
#	include/asm-i386/hardirq.h	1.4     -> 1.5    
#

 hardirq.h |    2 ++
 1 files changed, 2 insertions(+)


diff -Nru a/include/asm-i386/hardirq.h b/include/asm-i386/hardirq.h
--- a/include/asm-i386/hardirq.h	Wed Aug 27 08:02:39 2003
+++ b/include/asm-i386/hardirq.h	Wed Aug 27 08:02:39 2003
@@ -67,6 +67,8 @@
 {
 	++local_irq_count(cpu);
 
+	smp_mb();
+
 	while (test_bit(0,&global_irq_lock)) {
 		cpu_relax();
 	}
-
To unsubscribe from this list: send the line "unsubscribe bk-commits-24" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
[PATCH] Fix initrd with netboot

From "Martin Persson"

we've encountered a problem when trying to netboot 2.4.21 and above. After
/linuxrc has been executed and the kernel tries to remount the root, it
panics with the all too well known message "Unable to mount root fs on ...".

The kernel bugs out in mount_block_root in the file init/do_mounts.c, to be
more precise in the for-loop. What happens is that it tries to mount the
file system as type ext2 (which happens to be first in the list in our
case), but instead of returning -EINVAL it returns -EBUSY, the loop exits
instead of trying the next (correct) fs-type and the kernel panics.

In -wolk for some time and maybe others.

All diffs for ChangeSet 1.1065.1.42

diff -Nru a/init/do_mounts.c b/init/do_mounts.c

--- a/init/do_mounts.c	Mon Jul 21 13:13:12 2003
+++ b/init/do_mounts.c	Thu Jul 10 06:46:36 2003
@@ -360,6 +360,7 @@
 				flags |= MS_RDONLY;
 				goto retry;
 			case -EINVAL:
+		        case -EBUSY:
 				continue;
 		}
 	        /*

<http://www.bitkeeper.com>

pcwd.c: fix oops on unload

From Arkadiusz Miskiewicz <arekm@pld-linux.org>

  This patch is from Alan Cox and fixes problems when pcwd driver is loaded
  while there is no pcwd hardware installed.
  No idea why it was not feeded to you.
  Problem is described here
  http://www.ussg.iu.edu/hypermail/linux/kernel/0308.1/0178.html and tracked
  down in private conversation with Cox.


<patch@1.1065.1.38??nav=index.html|ChangeSet@-3d|cset@1.1065.1.38>

diff -Nru a/drivers/char/pcwd.c b/drivers/char/pcwd.c

--- a/drivers/char/pcwd.c	Sun Sep 29 12:29:59 2002
+++ b/drivers/char/pcwd.c	Mon Aug 25 10:20:56 2003
@@ -933,8 +933,7 @@
 
 	release_region (pcwd_info.io_addr, pcwd_info.card_info->io_size);
 
-	if (pcwd_info.flags & PCWD_PCI_REG)
-		pci_unregister_driver (&pcwd_driver);
+	pci_unregister_driver (&pcwd_driver);
 
 	return;
 }

<http://www.bitkeeper.com>

From greg@kroah.com Tue Sep 16 23:06:43 2003
Date: Fri, 5 Sep 2003 08:24:36 -0700
From: Greg KH <greg@kroah.com>
To: Ingo Oeser <ingo@oeser-vu.de>
Cc: linux-kernel@vger.kernel.org
Subject: Re: [OOPS] 2.4.22, USB visor module crashing on HotSync.

On Fri, Sep 05, 2003 at 01:30:22PM +0200, Ingo Oeser wrote:
> Hi Greg,
> 
> there seems to be a problem with the visor module and usb_serial.
> 
> Please look at __serial_close() and usb_disconnect() calling it
> in line 1406 vs. line 1408. I would suggest removing 1408 or
> folding it into __serial_close().
> 
> Formal Bug-Reporting follows:
> 
> [1.] One line summary of the problem:
> 
>       USB visor module and usb_serial crashing on HotSync in usb_disconnect
> 
> [2.] Full description of the problem/report:
> 
>       usb_disconnect calls __serial_close() which sets the tty = NULL
>       and afterwards trys to set tty->private_data = NULL
>       which will crash

Nice, someone else reported this yesterday for the ftdi_sio driver.

Can you test the patch below and let me know if this fixes it?

thanks,

greg k-h


--- a/drivers/usb/serial/usbserial.c	Sat Aug 30 23:27:18 2003
+++ b/drivers/usb/serial/usbserial.c	Thu Sep  4 13:48:45 2003
@@ -556,7 +556,10 @@
 		else
 			generic_close(port, filp);
 		port->open_count = 0;
-		port->tty = NULL;
+		if (port->tty) {
+			port->tty->driver_data = NULL;
+			port->tty = NULL;
+		}
 	}
 
 	if (port->serial->type->owner)
@@ -1401,12 +1404,9 @@
 		for (i = 0; i < serial->num_ports; ++i) {
 			port = &serial->port[i];
 			down (&port->sem);
-			if (port->tty != NULL) {
-				while (port->open_count > 0) {
+			if (port->tty != NULL)
+				while (port->open_count > 0)
 					__serial_close(port, NULL);
-				}
-				port->tty->driver_data = NULL;
-			}
 			up (&port->sem);
 		}
 
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
