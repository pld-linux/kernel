P: Dlaczego nie dzia³a mi modu³ lirc_serial?
O: W j±dro PLD-Linux jest na sta³e wkompilowany modu³ obs³uguj±cy port
   szeregowy, aby umo¿liwiæ pe³ne monitorowanie i obs³ugê maszyn
   nie posiadaj±cych monitora, lub klawiatury. Je¶li chcesz u¿ywaæ modu³u
   lirc_serial, musisz zwolniæ port szeregowy na rzecz modu³u lirc_serial
   poprzez wydanie komendy:

   setserial /dev/ttySx uart none

P: Jak namierzyæ ¼ród³o oops-a?
O: Trzeba tylko poczytaæ i poszukaæ ;-)

   We¼my na warsztat prosty przyk³ad - ³adny oopsik otrzymany po za³adowaniu
   modu³u specjalnie przygotowanego na potrzeby tego punktu FAQ-a :)

   kernel: Unable to handle kernel paging request at virtual address 66666666

   [1]                                                               ^^^ evil oops :>

   kernel:  printing eip:
   kernel: c01b6f3e
   kernel: *pde = 00131313
   kernel: *pte = 0c55b70f
   kernel: Oops: 0000 [#1]
   kernel: Modules linked in: oops videodev agpgart nvidia ipt_unclean ipt_state
                              ipt_REJECT iptable_nat ip_conntrack iptable_mangle
                              iptable_filter ip_tables vmmon snd_seq_oss
                              snd_seq_midi_event snd_seq snd_pcm_oss snd_mixer_oss
                              snd_ens1371 snd_rawmidi snd_seq_device snd_ac97_codec
                              snd_pcm snd_page_alloc gameport snd_rtctimer snd_timer
                              snd soundcore usbhid uhci_hcd usbcore via_rhine mii
                              crc32 capability commoncap processor via686a w83781d
                              i2c_sensor i2c_isa i2c_core msr cpuid ide_disk ext3
                              mbcache jbd via82cxxx ide_core
   kernel: CPU:    0
   kernel: EIP:    0060:[strcspn+94/96]    Tainted: P      VLI
   kernel: EFLAGS: 00010097   (2.6.10)
   kernel: EIP is at vsnprintf+0x30e/0x4f0

   [2]               ^^^^^^^^^^^^^^^ jak widaæ w tym miejscu siê wykrzaczy³o jajo.
                                     szybki grep i ju¿ wiemy, ¿e winna funkcja
                                     znajduje siê w pliku lib/vsprintf.c.

   kernel: eax: 66666666   ebx: 0000000a   ecx: 66666666   edx: fffffffe
   kernel: esi: c03bfde3   edi: 00000000   ebp: c46d3f38   esp: c46d3efc
   kernel: ds: 007b   es: 007b   ss: 0068
   kernel: Process insmod (pid: 26344, threadinfo=c46d2000 task=c33f2140)
   kernel: Stack: c46d3f0c c014fa0a c4245da0 00000001 c46d3f9c c0134526 d0a51000 0000000f
   kernel:        ffffffff ffffffff ffffffff c03c01df 00000400 00000246 c02d9660 c46d3f54
   kernel:        c01b7147 c03bfde0 00000400 d0a53038 c46d3f98 c03bfde0 c46d3f78 c011dda2
   kernel: Call Trace:
   kernel:  [show_stack+127/160] show_stack+0x7f/0xa0
   kernel:  [show_registers+342/464] show_registers+0x156/0x1d0
   kernel:  [die+200/336] die+0xc8/0x150
   kernel:  [do_page_fault+1088/1799] do_page_fault+0x440/0x707
   kernel:  [error_code+45/56] error_code+0x2d/0x38
   kernel:  [simple_strtol+39/64] vscnprintf+0x27/0x40
   kernel:  [vprintk+66/320] vprintk+0x42/0x140
   kernel:  [printk+24/32] printk+0x18/0x20
   kernel:  [pg0+275193884/1069667328] km_init_module+0x1c/0x20 [oops]
   kernel:  [sys_init_module+308/448] sys_init_module+0x134/0x1c0
   kernel:  [sysenter_past_esp+82/113] sysenter_past_esp+0x52/0x71
   kernel: Code: fd ff ff 83 cf 40 bb 10 00 00 00 eb 88 8b 45 14 8b 55 e8 83 45 14 04 8b
                 08 b8 6c 45 2b c0 81 f9 ff 0f 00 00 0f 46 c8 89 c8 eb 06 <80> 38 00 74 07

   [3]                                                                    <^^>^^^^^^^
                                                           ta instrukcja wygenerowa³a b³±d.

                 40 4a 83 fa ff 75 f4 29 c8 83 e7 10 89 c3 0f 85

   Aby dotrzeæ do ¼róde³ musimy odtworzyæ binaria i namierzyæ instrukcjê.
   Rozpakowujemy wiêc ¼rod³a u¿ywanego j±dra i kompilujemy ten element,
   w którym wyst±pi³ oops.

   # cd tmp/kernel/ && cp /usr/src/linux/config-up .config
   # make arch/i386/
   (...)
   # make lib/vsprintf.o EXTRA_CFLAGS="-g -Wa,-a,-ad -fverbose-asm" > vsprintf.S

   Nastêpnie ustalamy adres instrukcji z warunku vsnprintf+0x30e.
   Analizuj±c plik vsprintf.S odnajdujemy adres metody vsnprintf...

   256:lib/vsprintf.c **** int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
   257:lib/vsprintf.c **** {
   955                            .loc 1 257 0
   956 05c0 55                    pushl   %ebp    #

   i dodajemy offset z oopsa otrzymuj±c finalnie 0x5c0+0x30e = 0x8ce.
   Udajemy siê pod wskazany adres i analizujemy kod...

   1459                           .loc 1 377 0
   1460 08bc B8000000             movl    $.LC2, %eax     #, tmp236
   1460      00
   1461 08c1 81F9FF0F             cmpl    $4095, %ecx     #, s
   1461      0000
   1462 08c7 0F46C8               cmovbe  %eax, %ecx      # s,, tmp236, s
   1463                   .LBB25:
   1464                   .LBB26:
   1465                           .loc 3 354 0
   1466                   #APP
   1467 08ca 89C8                 movl %ecx,%eax  # s,
   1468 08cc EB06                 jmp 2f
   1469 08ce 803800       1:      cmpb $0,(%eax)  #

             ^^^^^^ Widzimy, ¿e instrukcja pod tym adresem pokrywa siê ze wskazaniem [3].
                    Wygl±da wiêc na to, i¿ nasze ¶ledztwo przebiega prawid³owo.
                    Je¶li powy¿sza instrukcja `cmpb imm, mem` wygenrowa³a b³±d, to znaczy
                    to mniej wiêcej tyle, ¿e adres zawarty w rejestrze %eax by³ b³êdny.

   1470 08d1 7407                 je 3f
   1471 08d3 40                   incl %eax       #
   1472 08d4 4A           2:      decl %edx       # d0
   1473 08d5 83FAFF               cmpl $-1,%edx   # d0
   1474 08d8 75F4                 jne 1b
   1475 08da 29C8         3:      subl %ecx,%eax  # s,
   1476                   #NO_APP
   1477                   .LBE26:
   1478                   .LBE25:
   1479                           .loc 1 381 0

   Spogl±daj±c na dyrektywê .loc 3 354 ...
                                 ^ ^^^ numer wiersza
                                 ^ identyfikator pliku

   i informacje od kompilatora...

   41                            .file 1 "lib/vsprintf.c"
   1451                          .file 3 "include/asm/string.h"

   dochodzimy do wniosku, ¿e wskazany mnemonik to element funkcji strnlen wo³anej
   z vsnprintf przy wy¶wietlaniu ³añcucha tekstowego (formatka %s).

   374:lib/vsprintf.c ****       case 's':
   375:lib/vsprintf.c ****                  s = va_arg(args, char *);
   376:lib/vsprintf.c ****                  if ((unsigned long)s < PAGE_SIZE)
   377:lib/vsprintf.c ****                        s = "<NULL>";
   378:lib/vsprintf.c ****
   379:lib/vsprintf.c ****                  len = strnlen(s, precision);
   380:lib/vsprintf.c ****
   381:lib/vsprintf.c ****                  if (!(flags & LEFT)) {

   Spójrzmy ponownie na ¶lad wywo³añ i odszukajmy przyczynê...

   kernel: Call Trace:
   kernel:  [show_stack+127/160] show_stack+0x7f/0xa0
   kernel:  [show_registers+342/464] show_registers+0x156/0x1d0
   kernel:  [die+200/336] die+0xc8/0x150
   kernel:  [do_page_fault+1088/1799] do_page_fault+0x440/0x707
   kernel:  [error_code+45/56] error_code+0x2d/0x38
   kernel:  [simple_strtol+39/64] vscnprintf+0x27/0x40
   kernel:  [vprintk+66/320] vprintk+0x42/0x140
   kernel:  [printk+24/32] printk+0x18/0x20
   kernel:  [pg0+275193884/1069667328] km_init_module+0x1c/0x20 [oops]
   kernel:  [sys_init_module+308/448] sys_init_module+0x134/0x1c0
   kernel:  [sysenter_past_esp+82/113] sysenter_past_esp+0x52/0x71

   Wszystko wskazuje na to, i¿ b³êdny parametr przywêdrowa³ do v*printf()
   z printk(), której wywo³anie znajduje siê w km_init_module().
   Zajrzyjmy wiêc do ¼róde³ modu³u oops.c...

   (...)
   static int km_init_module(void)
   {
       printk(KERN_DEBUG "%s init\n", 1.4);
       return 0;
   }
   (...)

   No i mamy ¼ród³o b³êdu - przekazanie liczby typu double zamiast
   wska¼nika do ³añcucha tekstowego.
