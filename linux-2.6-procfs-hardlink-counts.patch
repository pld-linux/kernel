The pid directories in /proc/ currently return the wrong hardlink count - 3, 
when there are actually 4 : ".", "..", "fd", and "task".

This is easy to notice using find(1):
	cd /proc/<pid>
	find

In the output, you'll see a message similar to:
find: WARNING: Hard link count is wrong for .: this may be a bug in your 
filesystem driver.  Automatically turning on find's -noleaf option.  Earlier 
results may have failed to include directories that should have been searched.

I also noticed that CONFIG_SECURITY can add a 5th: attr, and performed a 
similar fix on the task directories too.

The current logic assumes that a /proc/<PID>/task directory should have a 
hardlink count of 3, probably counting ".", "..", and a directory for a single 
child task.

It's fairly obvious that this doesn't work out correctly when a PID has more 
than one child task, which is quite often the case.

Signed-off-by: Daniel Drake <dsd@gentoo.org>

--- a/fs/proc/base.c	2005-04-01 14:06:43.000000000 +0100
+++ b/fs/proc/base.c	2005-04-01 14:35:39.000000000 +0100
@@ -1367,6 +1367,8 @@ static struct file_operations proc_tgid_
 static struct inode_operations proc_tgid_attr_inode_operations;
 #endif
 
+static int get_tid_list(int index, unsigned int *tids, struct inode *dir);
+
 /* SMP-safe */
 static struct dentry *proc_pident_lookup(struct inode *dir, 
 					 struct dentry *dentry,
@@ -1406,7 +1408,7 @@ static struct dentry *proc_pident_lookup
 	 */
 	switch(p->type) {
 		case PROC_TGID_TASK:
-			inode->i_nlink = 3;
+			inode->i_nlink = 2 + get_tid_list(2, NULL, dir);
 			inode->i_op = &proc_task_inode_operations;
 			inode->i_fop = &proc_task_operations;
 			break;
@@ -1762,8 +1764,12 @@ struct dentry *proc_pid_lookup(struct in
 #endif
 	inode->i_op = &proc_tgid_base_inode_operations;
 	inode->i_fop = &proc_tgid_base_operations;
-	inode->i_nlink = 3;
 	inode->i_flags|=S_IMMUTABLE;
+#ifdef CONFIG_SECURITY
+	inode->i_nlink = 5;
+#else
+	inode->i_nlink = 4;
+#endif
 
 	dentry->d_op = &pid_base_dentry_operations;
 
@@ -1817,8 +1823,12 @@ static struct dentry *proc_task_lookup(s
 	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
 	inode->i_op = &proc_tid_base_inode_operations;
 	inode->i_fop = &proc_tid_base_operations;
-	inode->i_nlink = 3;
 	inode->i_flags|=S_IMMUTABLE;
+#ifdef CONFIG_SECURITY
+	inode->i_nlink = 4;
+#else
+	inode->i_nlink = 3;
+#endif
 
 	dentry->d_op = &pid_base_dentry_operations;
 
@@ -1912,7 +1922,8 @@ static int get_tid_list(int index, unsig
 
 		if (--index >= 0)
 			continue;
-		tids[nr_tids] = tid;
+		if (tids != NULL)
+			tids[nr_tids] = tid;
 		nr_tids++;
 		if (nr_tids >= PROC_MAXPIDS)
 			break;
@@ -2012,6 +2023,7 @@ static int proc_task_readdir(struct file
 	}
 
 	nr_tids = get_tid_list(pos, tid_array, inode);
+	inode->i_nlink = pos + nr_tids;
 
 	for (i = 0; i < nr_tids; i++) {
 		unsigned long j = PROC_NUMBUF;
