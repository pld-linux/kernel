diff -urN linux-2.4.20-uml/arch/um/include/2_5compat.h linux-2.4.20-uml-o1/arch/um/include/2_5compat.h
--- linux-2.4.20-uml/arch/um/include/2_5compat.h	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/include/2_5compat.h	Sat Mar 15 20:46:24 2003
@@ -10,7 +10,6 @@
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 
-#define mk_kdev(maj, min) MKDEV(maj, min)
 #define INIT_CONSOLE(dev_name, write_proc, device_proc, setup_proc, f) { \
 	name :		dev_name, \
 	write :		write_proc, \
@@ -32,12 +31,9 @@
 #define IS_WRITE(req) ((req)->cmd == WRITE)
 #define IS_READ(req) ((req)->cmd == READ)
 
-#define CPU(task) ((task)->processor)
+#define CPU(task) ((task)->cpu)
 
-#define yield() do { current->policy |= SCHED_YIELD; schedule(); } while(0)
-
-#define SET_PRI(task) \
-	do { (task)->nice = 20; (task)->counter = -100; } while(0);
+#define SET_PRI(task) do { } while(0)
 
 #else
 
diff -urN linux-2.4.20-uml/arch/um/include/user_util.h linux-2.4.20-uml-o1/arch/um/include/user_util.h
--- linux-2.4.20-uml/arch/um/include/user_util.h	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/include/user_util.h	Sat Mar 15 19:58:20 2003
@@ -89,6 +89,7 @@
 extern int arch_handle_signal(int sig, union uml_pt_regs *regs);
 extern int arch_fixup(unsigned long address, void *sc_ptr);
 extern int can_do_skas(void);
+extern void forward_pending_sigio(int target);
 
 #endif
 
diff -urN linux-2.4.20-uml/arch/um/kernel/irq.c linux-2.4.20-uml-o1/arch/um/kernel/irq.c
--- linux-2.4.20-uml/arch/um/kernel/irq.c	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/irq.c	Sat Mar 15 20:30:22 2003
@@ -151,10 +151,12 @@
 
 	status = 1;	/* Force the "do bottom halves" bit */
 
-	if (!(action->flags & SA_INTERRUPT))
-		__sti();
-
 	do {
+		if (!(action->flags & SA_INTERRUPT))
+			__sti();
+		else
+			__cli();
+
 		status |= action->flags;
 		action->handler(irq, action->dev_id, regs);
 		action = action->next;
diff -urN linux-2.4.20-uml/arch/um/kernel/process.c linux-2.4.20-uml-o1/arch/um/kernel/process.c
--- linux-2.4.20-uml/arch/um/kernel/process.c	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/process.c	Sat Mar 15 19:59:12 2003
@@ -275,6 +275,16 @@
 #endif
 }
 
+void forward_pending_sigio(int target)
+{
+	sigset_t sigs;
+
+	if(sigpending(&sigs)) 
+		panic("forward_pending_sigio : sigpending failed");
+	if(sigismember(&sigs, SIGIO))
+		kill(target, SIGIO);
+}
+
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
  * Emacs will notice this stuff at the end of the file and automatically
diff -urN linux-2.4.20-uml/arch/um/kernel/skas/process_kern.c linux-2.4.20-uml-o1/arch/um/kernel/skas/process_kern.c
--- linux-2.4.20-uml/arch/um/kernel/skas/process_kern.c	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/skas/process_kern.c	Sat Mar 15 20:03:07 2003
@@ -47,7 +47,7 @@
 	return(current->thread.prev_sched);
 }
 
-extern void schedule_tail(struct task_struct *prev);
+asmlinkage void schedule_tail(task_t *prev);
 
 void new_thread_handler(int sig)
 {
@@ -60,8 +60,10 @@
 	thread_wait(&current->thread.mode.skas.switch_buf, 
 		    current->thread.mode.skas.fork_buf);
 
+#ifdef CONFIG_SMP
 	if(current->thread.prev_sched != NULL)
 		schedule_tail(current->thread.prev_sched);
+#endif
 	current->thread.prev_sched = NULL;
 
 	n = run_kernel_thread(fn, arg, &current->thread.exec_buf);
@@ -91,8 +93,10 @@
 		    current->thread.mode.skas.fork_buf);
   	
 	force_flush_all();
+#ifdef CONFIG_SMP
 	if(current->thread.prev_sched != NULL)
 		schedule_tail(current->thread.prev_sched);
+#endif
 	current->thread.prev_sched = NULL;
 	unblock_signals();
 
diff -urN linux-2.4.20-uml/arch/um/kernel/sys_call_table.c linux-2.4.20-uml-o1/arch/um/kernel/sys_call_table.c
--- linux-2.4.20-uml/arch/um/kernel/sys_call_table.c	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/sys_call_table.c	Sat Mar 15 19:41:51 2003
@@ -153,6 +153,7 @@
 extern syscall_handler_t sys_sched_getparam;
 extern syscall_handler_t sys_sched_setscheduler;
 extern syscall_handler_t sys_sched_getscheduler;
+extern syscall_handler_t sys_sched_yield;
 extern syscall_handler_t sys_sched_get_priority_max;
 extern syscall_handler_t sys_sched_get_priority_min;
 extern syscall_handler_t sys_sched_rr_get_interval;
@@ -261,7 +262,7 @@
 
 	/* declared differently in kern_util.h */
 	[ __NR_execve ] = (syscall_handler_t *) sys_execve,
-	[ __NR_chdir ] = sys_chdir,
+	[ __NR_chdir ] = (syscall_handler_t *) sys_chdir,
 	[ __NR_time ] = um_time,
 	[ __NR_mknod ] = sys_mknod,
 	[ __NR_chmod ] = sys_chmod,
@@ -306,15 +307,15 @@
 	[ __NR_umount2 ] = sys_umount,
 	[ __NR_lock ] = sys_ni_syscall,
 	[ __NR_ioctl ] = sys_ioctl,
-	[ __NR_fcntl ] = sys_fcntl,
+	[ __NR_fcntl ] = (syscall_handler_t *) sys_fcntl,
 	[ __NR_mpx ] = sys_ni_syscall,
 	[ __NR_setpgid ] = sys_setpgid,
 	[ __NR_ulimit ] = sys_ni_syscall,
 	[ __NR_oldolduname ] = sys_olduname,
 	[ __NR_umask ] = sys_umask,
-	[ __NR_chroot ] = sys_chroot,
+	[ __NR_chroot ] = (syscall_handler_t *) sys_chroot,
 	[ __NR_ustat ] = sys_ustat,
-	[ __NR_dup2 ] = sys_dup2,
+	[ __NR_dup2 ] = (syscall_handler_t *) sys_dup2,
 	[ __NR_getppid ] = sys_getppid,
 	[ __NR_getpgrp ] = sys_getpgrp,
 	[ __NR_setsid ] = (syscall_handler_t *) sys_setsid,
diff -urN linux-2.4.20-uml/arch/um/kernel/tt/process_kern.c linux-2.4.20-uml-o1/arch/um/kernel/tt/process_kern.c
--- linux-2.4.20-uml/arch/um/kernel/tt/process_kern.c	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/tt/process_kern.c	Sat Mar 15 20:06:05 2003
@@ -29,10 +29,6 @@
 	unsigned long flags;
 	int err, vtalrm, alrm, prof, cpu;
 	char c;
-	/* jailing and SMP are incompatible, so this doesn't need to be 
-	 * made per-cpu 
-	 */
-	static int reading;
 
 	from = prev;
 	to = next;
@@ -51,15 +47,15 @@
 	alrm = change_sig(SIGALRM, 0);
 	prof = change_sig(SIGPROF, 0);
 
+	forward_pending_sigio(to->thread.extern_pid);
+
 	c = 0;
 	set_current(to);
 
-	reading = 0;
 	err = os_write_file(to->thread.mode.tt.switch_pipe[1], &c, sizeof(c));
 	if(err != sizeof(c))
 		panic("write of switch_pipe failed, errno = %d", -err);
 
-	reading = 1;
 	if(from->state == TASK_ZOMBIE)
 		os_kill_process(os_getpid(), 0);
 
@@ -67,24 +63,6 @@
 	if(err != sizeof(c))
 		panic("read of switch_pipe failed, errno = %d", -err);
 
-	/* This works around a nasty race with 'jail'.  If we are switching
-	 * between two threads of a threaded app and the incoming process 
-	 * runs before the outgoing process reaches the read, and it makes
-	 * it all the way out to userspace, then it will have write-protected 
-	 * the outgoing process stack.  Then, when the outgoing process 
-	 * returns from the write, it will segfault because it can no longer
-	 * write its own stack.  So, in order to avoid that, the incoming 
-	 * thread sits in a loop yielding until 'reading' is set.  This 
-	 * isn't entirely safe, since there may be a reschedule from a timer
-	 * happening between setting 'reading' and sleeping in read.  But,
-	 * it should get a whole quantum in which to reach the read and sleep,
-	 * which should be enough.
-	 */
-
-	if(jail){
-		while(!reading) sched_yield();
-	}
-
 	change_sig(SIGVTALRM, vtalrm);
 	change_sig(SIGALRM, alrm);
 	change_sig(SIGPROF, prof);
@@ -108,7 +86,7 @@
 	close(current->thread.mode.tt.switch_pipe[1]);
 }
 
-extern void schedule_tail(struct task_struct *prev);
+asmlinkage void schedule_tail(task_t *prev);
 
 static void new_thread_handler(int sig)
 {
@@ -126,8 +104,10 @@
 	set_cmdline("(kernel thread)");
 	force_flush_all();
 
+#ifdef CONFIG_SMP
 	if(current->thread.prev_sched != NULL)
 		schedule_tail(current->thread.prev_sched);
+#endif
 	current->thread.prev_sched = NULL;
 
 	change_sig(SIGUSR1, 1);
@@ -169,8 +149,10 @@
 			       1, 0, 1);
 	task_protections((unsigned long) current);
 
+#ifdef CONFIG_SMP
 	if(current->thread.prev_sched != NULL)
 		schedule_tail(current->thread.prev_sched);
+#endif
 	current->thread.prev_sched = NULL;
 
 	free_page(current->thread.temp_stack);
diff -urN linux-2.4.20-uml/include/asm-um/cache.h linux-2.4.20-uml-o1/include/asm-um/cache.h
--- linux-2.4.20-uml/include/asm-um/cache.h	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/include/asm-um/cache.h	Sat Mar 15 20:23:30 2003
@@ -1,6 +1,7 @@
 #ifndef __UM_CACHE_H
 #define __UM_CACHE_H
 
-#define        L1_CACHE_BYTES  32
+#define L1_CACHE_SHIFT  (5)
+#define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
 
 #endif
diff -urN linux-2.4.20-uml/include/asm-um/fixmap.h linux-2.4.20-uml-o1/include/asm-um/fixmap.h
--- linux-2.4.20-uml/include/asm-um/fixmap.h	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/include/asm-um/fixmap.h	Sat Mar 15 20:44:39 2003
@@ -2,7 +2,9 @@
 #define __UM_FIXMAP_H
 
 #include <linux/config.h>
+#ifdef CONFIG_HIGHMEM
 #include <asm/kmap_types.h>
+#endif
 
 /*
  * Here we define all the compile-time 'special' virtual
diff -urN linux-2.4.20-uml/include/asm-um/page.h linux-2.4.20-uml-o1/include/asm-um/page.h
--- linux-2.4.20-uml/include/asm-um/page.h	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/include/asm-um/page.h	Sat Mar 15 19:47:48 2003
@@ -50,4 +50,7 @@
 extern struct page *arch_validate(struct page *page, int mask, int order);
 #define HAVE_ARCH_VALIDATE
 
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
 #endif
diff -urN linux-2.4.20-uml/include/asm-um/smp.h linux-2.4.20-uml-o1/include/asm-um/smp.h
--- linux-2.4.20-uml/include/asm-um/smp.h	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/include/asm-um/smp.h	Sat Mar 15 19:50:18 2003
@@ -6,7 +6,7 @@
 #include "linux/config.h"
 #include "asm/current.h"
 
-#define smp_processor_id() (current->processor)
+#define smp_processor_id() (current->cpu)
 #define cpu_logical_map(n) (n)
 #define cpu_number_map(n) (n)
 #define PROC_CHANGE_PENALTY	15 /* Pick a number, any number */
