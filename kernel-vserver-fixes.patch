--- linux-3.3/fs/proc/base.c~	2012-03-19 21:44:42.000000000 +0100
+++ linux-3.3/fs/proc/base.c	2012-03-21 12:25:28.051092423 +0100
@@ -568,6 +568,8 @@
 				 struct task_struct *task,
 				 int hide_pid_min)
 {
+	if (vx_check(0, VS_WATCH_P))
+		return true;
 	if (pid->hide_pid < hide_pid_min)
 		return true;
 	if (in_group_p(pid->pid_gid))
--- linux-4.1.3-vs2.3.8.2/kernel/signal.c	2015-09-20 20:06:03.000000000 +0200
+++ testing41/kernel/signal.c	2015-12-05 13:01:00.599373873 +0100
@@ -1369,8 +1369,14 @@
 	for (;;) {
 		rcu_read_lock();
 		p = pid_task(pid, PIDTYPE_PID);
-		if (p && vx_check(vx_task_xid(p), VS_IDENT))
-			error = group_send_sig_info(sig, info, p);
+		if (p) {
+			if (vx_check(vx_task_xid(p), VS_IDENT))
+				error = group_send_sig_info(sig, info, p);
+			else {
+				rcu_read_unlock();
+				return -ESRCH;
+			}
+		}
 		rcu_read_unlock();
 		if (likely(!p || error != -ESRCH))
 			return error;
--- linux-4.1.3-vs2.3.8.2/kernel/exit.c	2015-09-20 20:06:03.000000000 +0200
+++ testing41/kernel/exit.c	2016-01-27 20:50:37.170221605 +0100
@@ -580,8 +580,11 @@ static void forget_original_parent(struc
 
 	reaper = find_new_reaper(father, reaper);
 	list_for_each_entry(p, &father->children, sibling) {
+		struct task_struct *this_reaper = reaper;
+		if (p == reaper)
+			this_reaper = task_active_pid_ns(reaper)->child_reaper;
 		for_each_thread(p, t) {
-			t->real_parent = reaper;
+			t->real_parent = this_reaper;
 			BUG_ON((!t->ptrace) != (t->parent == father));
 			if (likely(!t->ptrace))
 				t->parent = t->real_parent;
@@ -593,7 +596,7 @@ static void forget_original_parent(struc
 		 * If this is a threaded reparent there is no need to
 		 * notify anyone anything has happened.
 		 */
-		if (!same_thread_group(reaper, father))
+		if (!same_thread_group(this_reaper, father))
 			reparent_leader(father, p, dead);
 	}
 	list_splice_tail_init(&father->children, &reaper->children);
diff -Nurp linux-4.1.3-vs2.3.8.2.fakeinit04/kernel/exit.c linux-4.1.3-vs2.3.8.2.fakeinit05/kernel/exit.c
--- linux-4.1.3-vs2.3.8.2.fakeinit04/kernel/exit.c	2016-01-29 23:56:25.077386945 +0100
+++ linux-4.1.3-vs2.3.8.2.fakeinit05/kernel/exit.c	2016-01-30 00:12:30.693073246 +0100
@@ -579,8 +579,10 @@ static void forget_original_parent(struc
 		return;
 
 	reaper = find_new_reaper(father, reaper);
-	list_for_each_entry(p, &father->children, sibling) {
-		struct task_struct *this_reaper = reaper;
+	for (p = list_first_entry(&father->children, struct task_struct, sibling);
+	     &p->sibling != &father->children;
+	     ) {
+		struct task_struct *next, *this_reaper = reaper;
 		if (p == reaper)
 			this_reaper = task_active_pid_ns(reaper)->child_reaper;
 		for_each_thread(p, t) {
@@ -598,8 +600,11 @@ static void forget_original_parent(struc
 		 */
 		if (!same_thread_group(this_reaper, father))
 			reparent_leader(father, p, dead);
+		next = list_next_entry(p, sibling);
+		list_add(&p->sibling, &this_reaper->children);
+		p = next;
 	}
-	list_splice_tail_init(&father->children, &reaper->children);
+	INIT_LIST_HEAD(&father->children);
 }
 
 /*
