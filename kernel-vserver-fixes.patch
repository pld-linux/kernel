--- linux-3.3/fs/proc/base.c~	2012-03-19 21:44:42.000000000 +0100
+++ linux-3.3/fs/proc/base.c	2012-03-21 12:25:28.051092423 +0100
@@ -568,6 +568,8 @@
 				 struct task_struct *task,
 				 int hide_pid_min)
 {
+	if (vx_check(0, VS_WATCH_P))
+		return true;
 	if (pid->hide_pid < hide_pid_min)
 		return true;
 	if (in_group_p(pid->pid_gid))

diff -NurpP --minimal linux-4.9.78-vs2.3.9.6/kernel/sched/loadavg.c linux-4.9.78-vs2.3.9.6.1/kernel/sched/loadavg.c
--- linux-4.9.78-vs2.3.9.6/kernel/sched/loadavg.c	2018-01-10 02:47:50.000000000 +0000
+++ linux-4.9.78-vs2.3.9.6.1/kernel/sched/loadavg.c	2018-01-26 12:19:45.000000000 +0000
@@ -73,9 +73,16 @@ EXPORT_SYMBOL(avenrun); /* should be rem
  */
 void get_avenrun(unsigned long *loads, unsigned long offset, int shift)
 {
-	loads[0] = (avenrun[0] + offset) << shift;
-	loads[1] = (avenrun[1] + offset) << shift;
-	loads[2] = (avenrun[2] + offset) << shift;
+	if (vx_flags(VXF_VIRT_LOAD, 0)) {
+		struct vx_info *vxi = current_vx_info();
+		loads[0] = (vxi->cvirt.load[0] + offset) << shift;
+		loads[1] = (vxi->cvirt.load[1] + offset) << shift;
+		loads[2] = (vxi->cvirt.load[2] + offset) << shift;
+	} else {
+		loads[0] = (avenrun[0] + offset) << shift;
+		loads[1] = (avenrun[1] + offset) << shift;
+		loads[2] = (avenrun[2] + offset) << shift;
+	}
 }
 
 long calc_load_fold_active(struct rq *this_rq, long adjust)
