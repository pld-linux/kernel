#
#   Handle two threads both trying to expand their stack simultaneously.
#   So re-check the need for expand after getting the lock.
#
#   Noticed by Paul Starzetz.
#
diff -Nru a/mm/mmap.c b/mm/mmap.c
--- a/mm/mmap.c 2005-01-15 04:36:26 -08:00
+++ b/mm/mmap.c 2005-01-15 04:36:26 -08:00
@@ -1457,7 +1457,7 @@
  */
 int expand_stack(struct vm_area_struct * vma, unsigned long address)
 {
-	unsigned long grow;
+	long grow;
 	int retval = -ENOMEM;
 
 #ifdef CONFIG_PAX_RANDEXEC
@@ -1487,6 +1487,11 @@
 	address &= PAGE_MASK;
 	grow = (address - vma->vm_end) >> PAGE_SHIFT;
 
+	/* Someone beat us to it */
+	if (grow <= 0) {
+		anon_vma_unlock(vma);
+		return 0;
+	}
 	/* Overcommit.. */
 #ifdef CONFIG_PAX_RANDEXEC
 	if (vma->vm_flags & VM_MIRROR) {
@@ -1537,6 +1542,14 @@
 	}
 #endif
 
+	if ((vma->vm_flags & VM_LOCKED) && !capable(CAP_IPC_LOCK) &&
+			((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) >
+			current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur) {
+		anon_vma_unlock(vma);
+		vm_unacct_memory(grow);
+		return -ENOMEM;
+	}
+
 	vma->vm_end = address;
 	vma->vm_mm->total_vm += grow;
 	if (vma->vm_flags & VM_LOCKED)
@@ -1611,6 +1624,11 @@
 	address &= PAGE_MASK;
 	grow = (vma->vm_start - address) >> PAGE_SHIFT;
 
+	/* Someone beat us to it */
+	if (grow <= 0) {
+		anon_vma_unlock(vma);
+		return 0;
+	}
 	/* Overcommit.. */
 #if defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_RANDEXEC)
 	if (vma->vm_flags & VM_MIRROR) {
@@ -1662,6 +1680,14 @@
 	}
 #endif
 
+	if ((vma->vm_flags & VM_LOCKED) && !capable(CAP_IPC_LOCK) &&
+			((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) >
+			current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur) {
+		anon_vma_unlock(vma);
+		vm_unacct_memory(grow);
+		return -ENOMEM;
+	}
+
 	vma->vm_start = address;
 	vma->vm_pgoff -= grow;
 	vma->vm_mm->total_vm += grow;
