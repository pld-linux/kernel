diff -urNp linux-2.4.20/arch/i386/kernel/mtrr.c linux-2.4.20.SUSE/arch/i386/kernel/mtrr.c
--- linux-2.4.20/arch/i386/kernel/mtrr.c	2004-07-23 15:42:58.445148077 +0200
+++ linux-2.4.20.SUSE/arch/i386/kernel/mtrr.c	2004-07-23 15:43:48.534805792 +0200
@@ -1648,11 +1648,16 @@ static int mtrr_file_del (unsigned long 
 static ssize_t mtrr_read (struct file *file, char *buf, size_t len,
 			  loff_t *ppos)
 {
-    if (*ppos >= ascii_buf_bytes) return 0;
-    if (*ppos + len > ascii_buf_bytes) len = ascii_buf_bytes - *ppos;
-    if ( copy_to_user (buf, ascii_buffer + *ppos, len) ) return -EFAULT;
-    *ppos += len;
-    return len;
+	loff_t pos = *ppos;
+	if (pos < 0 || pos >= ascii_buf_bytes)
+		return 0;
+	if (len > ascii_buf_bytes - pos)
+		len = ascii_buf_bytes - pos;
+	if (copy_to_user(buf, ascii_buffer + pos, len))
+		return -EFAULT;
+	*ppos = pos + len;
+
+	return len;
 }   /*  End Function mtrr_read  */
 
 static ssize_t mtrr_write (struct file *file, const char *buf, size_t len,
diff -urNp linux-2.4.20/arch/ppc/kernel/ppc_htab.c linux-2.4.20.SUSE/arch/ppc/kernel/ppc_htab.c
--- linux-2.4.20/arch/ppc/kernel/ppc_htab.c	2001-11-03 02:43:54.000000000 +0100
+++ linux-2.4.20.SUSE/arch/ppc/kernel/ppc_htab.c	2004-07-23 15:43:48.535805805 +0200
@@ -115,6 +115,7 @@ static ssize_t ppc_htab_read(struct file
 			     size_t count, loff_t *ppos)
 {
 	unsigned long mmcr0 = 0, pmc1 = 0, pmc2 = 0;
+	loff_t pos = *ppos;
 	int n = 0;
 #ifdef CONFIG_PPC_STD_MMU
 	int valid;
@@ -216,14 +217,14 @@ return_string:
 		      "Non-error misses: %lu\n"
 		      "Error misses\t: %lu\n",
 		      pte_misses, pte_errors);
-	if (*ppos >= strlen(buffer))
+	if (pos != (unsigned)pos || pos >= strlen(buffer))
 		return 0;
-	if (n > strlen(buffer) - *ppos)
-		n = strlen(buffer) - *ppos;
+	if (n > strlen(buffer) - pos)
+		n = strlen(buffer) - pos;
 	if (n > count)
 		n = count;
-	copy_to_user(buf, buffer + *ppos, n);
-	*ppos += n;
+	copy_to_user(buf, buffer + pos, n);
+	*ppos = pos + n;
 	return n;
 }
 
diff -urNp linux-2.4.20/arch/ppc/platforms/proc_rtas.c linux-2.4.20.SUSE/arch/ppc/platforms/proc_rtas.c
--- linux-2.4.20/arch/ppc/platforms/proc_rtas.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20.SUSE/arch/ppc/platforms/proc_rtas.c	2004-07-23 15:43:48.536805818 +0200
@@ -264,18 +264,19 @@ static ssize_t ppc_rtas_poweron_read(str
 		size_t count, loff_t *ppos)
 {
 	int n;
+	loff_t pos = *ppos;
 	if (power_on_time == 0)
 		n = sprintf(buf, "Power on time not set\n");
 	else
 		n = sprintf(buf, "%lu\n", power_on_time);
 
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -301,15 +302,16 @@ static ssize_t ppc_rtas_progress_read(st
 		size_t count, loff_t *ppos)
 {
 	int n = 0;
+	loff_t pos = *ppos;
 	if (progress_led != NULL)
 		n = sprintf (buf, "%s\n", progress_led);
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -345,6 +347,7 @@ static ssize_t ppc_rtas_clock_read(struc
 {
 	unsigned int year, mon, day, hour, min, sec;
 	unsigned long *ret = kmalloc(4*8, GFP_KERNEL);
+	loff_t pos = *ppos;
 	int n, error;
 
 	error = call_rtas("get-time-of-day", 0, 8, ret);
@@ -361,13 +364,13 @@ static ssize_t ppc_rtas_clock_read(struc
 	}
 	kfree(ret);
 
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -732,16 +735,16 @@ static ssize_t ppc_rtas_tone_freq_write(
 static ssize_t ppc_rtas_tone_freq_read(struct file * file, char * buf,
 		size_t count, loff_t *ppos)
 {
-	int n;
-	n = sprintf(buf, "%lu\n", rtas_tone_frequency);
+	int n = sprintf(buf, "%lu\n", rtas_tone_frequency);
+	loff_t pos = *ppos;
 
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 /* ****************************************************************** */
@@ -773,15 +776,16 @@ static ssize_t ppc_rtas_tone_volume_writ
 static ssize_t ppc_rtas_tone_volume_read(struct file * file, char * buf,
 		size_t count, loff_t *ppos)
 {
-	int n;
-	n = sprintf(buf, "%lu\n", rtas_tone_volume);
+	int n = sprintf(buf, "%lu\n", rtas_tone_volume);
+	loff_t pos = *ppos;
 
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
+
 	return n;
 }
--- linux-2.4.20/arch/ppc64/kernel/proc_pmc.c.orig	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20/arch/ppc64/kernel/proc_pmc.c	2004-08-12 13:13:27.000000000 +0200
@@ -412,8 +412,9 @@
 	}
 	pnt = (char *)(perfmon_base.profile_buffer) + p - sizeof(unsigned int);
 	copy_to_user(buf,(void *)pnt,count);
+	p += count;
 	read += count;
-	*ppos += read;
+	*ppos = p;
 	return read;
 }
 
@@ -421,20 +422,18 @@
 			    size_t count, loff_t *ppos)
 {
 	unsigned long p = *ppos;
-	ssize_t read;
 	char * pnt;
 	unsigned int sample_step = 4;
 
 	if (p >= (perfmon_base.trace_length)) return 0;
 	if (count > (perfmon_base.trace_length) - p)
 		count = (perfmon_base.trace_length) - p;
-	read = 0;
 
 	pnt = (char *)(perfmon_base.trace_buffer) + p; //  - sizeof(unsigned int);
 	copy_to_user(buf,(void *)pnt,count);
-	read += count;
-	*ppos += read;
-	return read;
+	p += count;
+	*ppos = p;
+	return count;
 }
 
 static ssize_t write_trace(struct file * file, const char * buf,
diff -urNp linux-2.4.20/arch/ppc64/kernel/rtas-proc.c linux-2.4.20.SUSE/arch/ppc64/kernel/rtas-proc.c
--- linux-2.4.20/arch/ppc64/kernel/rtas-proc.c	2004-07-23 15:42:55.575110388 +0200
+++ linux-2.4.20.SUSE/arch/ppc64/kernel/rtas-proc.c	2004-07-23 15:43:53.413869853 +0200
@@ -344,6 +344,7 @@ static ssize_t ppc_rtas_clock_read(struc
 	unsigned int year, mon, day, hour, min, sec;
 	unsigned long *ret = kmalloc(4*8, GFP_KERNEL);
 	int n, error;
+	loff_t pos = *ppos;
 
 	error = rtas_call(rtas_token("get-time-of-day"), 0, 8, ret);
 	
@@ -613,6 +614,7 @@ int ppc_rtas_process_sensor(struct indiv
 int check_location (char *c, int idx, char * buf)
 {
 	int n = 0;
+	loff_t pos = *ppos;
 
 	switch (*(c+idx)) {
 		case LOC_PLANAR:
diff -urNp linux-2.4.20/arch/s390/kernel/debug.c linux-2.4.20.SUSE/arch/s390/kernel/debug.c
--- linux-2.4.20/arch/s390/kernel/debug.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20.SUSE/arch/s390/kernel/debug.c	2004-07-23 15:43:53.415869879 +0200
@@ -448,7 +448,7 @@ static ssize_t debug_output(struct file 
 
 	p_info = ((file_private_info_t *) file->private_data);
 	if (*offset != p_info->offset) 
-		return -EPIPE;
+		return -ESPIPE;
 	if(p_info->act_area >= p_info->debug_info_snap->nr_areas)
 		return 0;
 
@@ -470,8 +470,8 @@ static ssize_t debug_output(struct file 
 				goto out;
 	}
 out:
-	p_info->offset           = *offset + count;
-	p_info->act_entry_offset = size;	
+	p_info->offset           += count;
+	p_info->act_entry_offset = size;
 	*offset = p_info->offset;
 	return count;
 }
@@ -1056,7 +1056,7 @@ static int debug_input_level_fn(debug_in
 		       input_buf[0]);
 	}
       out:
-	*offset += in_buf_size;
+	*offset = in_buf_size;
 	return rc;		/* number of input characters */
 }
 
@@ -1123,7 +1123,7 @@ static int debug_input_flush_fn(debug_in
         printk(KERN_INFO "debug: area `%c` is not valid\n", input_buf[0]);
 
       out:
-        *offset += in_buf_size;
+        *offset = in_buf_size;
         return rc;              /* number of input characters */
 }
 
diff -urNp linux-2.4.20/arch/s390x/kernel/debug.c linux-2.4.20.SUSE/arch/s390x/kernel/debug.c
--- linux-2.4.20/arch/s390x/kernel/debug.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20.SUSE/arch/s390x/kernel/debug.c	2004-07-23 15:43:53.416869892 +0200
@@ -470,7 +470,7 @@ static ssize_t debug_output(struct file 
 				goto out;
 	}
 out:
-	p_info->offset           = *offset + count;
+	p_info->offset           += count;
 	p_info->act_entry_offset = size;	
 	*offset = p_info->offset;
 	return count;
@@ -1056,7 +1056,7 @@ static int debug_input_level_fn(debug_in
 		       input_buf[0]);
 	}
       out:
-	*offset += in_buf_size;
+	*offset = in_buf_size;
 	return rc;		/* number of input characters */
 }
 
@@ -1123,7 +1123,7 @@ static int debug_input_flush_fn(debug_in
         printk(KERN_INFO "debug: area `%c` is not valid\n", input_buf[0]);
 
       out:
-        *offset += in_buf_size;
+        *offset = in_buf_size;
         return rc;              /* number of input characters */
 }
 
diff -urNp linux-2.4.20/arch/x86_64/kernel/mtrr.c linux-2.4.20.SUSE/arch/x86_64/kernel/mtrr.c
--- linux-2.4.20/arch/x86_64/kernel/mtrr.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20.SUSE/arch/x86_64/kernel/mtrr.c	2004-07-23 15:43:53.417869905 +0200
@@ -919,16 +919,19 @@ static int mtrr_file_del (u64 base, u32 
 static ssize_t mtrr_read (struct file *file, char *buf, size_t len,
 		loff_t * ppos)
 {
-	if (*ppos >= ascii_buf_bytes)
+	loff_t n = *ppos;
+	unsigned pos = n;
+
+	if (pos != n || pos >= ascii_buf_bytes)
 		return 0;
 
-	if (*ppos + len > ascii_buf_bytes)
-		len = ascii_buf_bytes - *ppos;
+	if (len > ascii_buf_bytes - pos)
+		len = ascii_buf_bytes - pos;
 
-	if (copy_to_user (buf, ascii_buffer + *ppos, len))
+	if (copy_to_user (buf, ascii_buffer + pos, len))
 		return -EFAULT;
 
-	*ppos += len;
+	*ppos = pos + len;
 	return len;
 }
 
diff -urNp linux-2.4.20/drivers/block/rd.c linux-2.4.20.SUSE/drivers/block/rd.c
--- linux-2.4.20/drivers/block/rd.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/block/rd.c	2004-07-23 15:43:53.418869919 +0200
@@ -320,14 +320,19 @@ out:
 static ssize_t initrd_read(struct file *file, char *buf,
 			   size_t count, loff_t *ppos)
 {
-	int left;
+	loff_t n = *ppos;
+	unsigned pos = n;
+	unsigned left = initrd_end - initrd_start;
 
-	left = initrd_end - initrd_start - *ppos;
+	if (pos != n || pos >= left)
+		return 0;
+
+	left -= pos;
 	if (count > left) count = left;
 	if (count == 0) return 0;
-	if (copy_to_user(buf, (char *)initrd_start + *ppos, count))
+	if (copy_to_user(buf, (char *)initrd_start + pos, count))
 		return -EFAULT;
-	*ppos += count;
+	*ppos = pos + count;
 	return count;
 }
 
diff -urNp linux-2.4.20/drivers/char/i8k.c linux-2.4.20.SUSE/drivers/char/i8k.c
--- linux-2.4.20/drivers/char/i8k.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/char/i8k.c	2004-07-23 15:43:53.419869932 +0200
@@ -493,6 +493,7 @@ static int i8k_get_info(char *buffer, ch
 
 static ssize_t i8k_read(struct file *f, char *buffer, size_t len, loff_t *fpos)
 {
+    loff_t pos = *fpos;
     int n;
     char info[128];
 
@@ -501,19 +502,19 @@ static ssize_t i8k_read(struct file *f, 
 	return n;
     }
 
-    if (*fpos >= n) {
+    if (pos != (unsigned)pos || pos >= n) {
 	return 0;
     }
 
-    if ((*fpos + len) >= n) {
-	len = n - *fpos;
+    if (len >= n - pos) {
+	len = n - pos;
     }
 
     if (copy_to_user(buffer, info, len) != 0) {
 	return -EFAULT;
     }
 
-    *fpos += len;
+    *fpos = pos + len;
     return len;
 }
 
diff -urNp linux-2.4.20/drivers/char/istallion.c linux-2.4.20.SUSE/drivers/char/istallion.c
--- linux-2.4.20/drivers/char/istallion.c	2004-07-23 15:43:12.662334769 +0200
+++ linux-2.4.20.SUSE/drivers/char/istallion.c	2004-07-23 15:43:53.424869997 +0200
@@ -4867,6 +4867,7 @@ static ssize_t stli_memread(struct file 
 	void		*memptr;
 	stlibrd_t	*brdp;
 	int		brdnr, size, n;
+	loff_t		pos = *offp;
 
 #if DEBUG
 	printk(KERN_DEBUG "stli_memread(fp=%x,buf=%x,count=%x,offp=%x)\n",
@@ -4881,25 +4882,26 @@ static ssize_t stli_memread(struct file 
 		return(-ENODEV);
 	if (brdp->state == 0)
 		return(-ENODEV);
-	if (fp->f_pos >= brdp->memsize)
+	if (pos != (unsigned)pos || pos >= brdp->memsize)
 		return(0);
 
-	size = MIN(count, (brdp->memsize - fp->f_pos));
+	size = MIN(count, (brdp->memsize - pos));
 
 	save_flags(flags);
 	cli();
 	EBRDENABLE(brdp);
 	while (size > 0) {
-		memptr = (void *) EBRDGETMEMPTR(brdp, fp->f_pos);
-		n = MIN(size, (brdp->pagesize - (((unsigned long) fp->f_pos) % brdp->pagesize)));
+		memptr = (void *) EBRDGETMEMPTR(brdp, pos);
+		n = MIN(size, (brdp->pagesize - (((unsigned long) pos) % brdp->pagesize)));
 		if (copy_to_user(buf, memptr, n)) {
 			count = -EFAULT;
 			goto out;
 		}
-		fp->f_pos += n;
+		pos += n;
 		buf += n;
 		size -= n;
 	}
+	*offp = pos;
 out:
 	EBRDDISABLE(brdp);
 	restore_flags(flags);
@@ -4922,6 +4924,7 @@ static ssize_t stli_memwrite(struct file
 	stlibrd_t	*brdp;
 	char		*chbuf;
 	int		brdnr, size, n;
+	loff_t		pos = *offp;
 
 #if DEBUG
 	printk(KERN_DEBUG "stli_memwrite(fp=%x,buf=%x,count=%x,offp=%x)\n",
@@ -4936,26 +4939,27 @@ static ssize_t stli_memwrite(struct file
 		return(-ENODEV);
 	if (brdp->state == 0)
 		return(-ENODEV);
-	if (fp->f_pos >= brdp->memsize)
+	if (pos != (unsigned)pos || pos >= brdp->memsize)
 		return(0);
 
 	chbuf = (char *) buf;
-	size = MIN(count, (brdp->memsize - fp->f_pos));
+	size = MIN(count, (brdp->memsize - pos));
 
 	save_flags(flags);
 	cli();
 	EBRDENABLE(brdp);
 	while (size > 0) {
-		memptr = (void *) EBRDGETMEMPTR(brdp, fp->f_pos);
-		n = MIN(size, (brdp->pagesize - (((unsigned long) fp->f_pos) % brdp->pagesize)));
+		memptr = (void *) EBRDGETMEMPTR(brdp, pos);
+		n = MIN(size, (brdp->pagesize - (((unsigned long) pos) % brdp->pagesize)));
 		if (copy_from_user(memptr, chbuf, n)) {
 			count = -EFAULT;
 			goto out;
 		}
-		fp->f_pos += n;
+		pos += n;
 		chbuf += n;
 		size -= n;
 	}
+	*offp = pos;
 out:
 	EBRDDISABLE(brdp);
 	restore_flags(flags);
diff -urNp linux-2.4.20/drivers/char/mem.c linux-2.4.20.SUSE/drivers/char/mem.c
--- linux-2.4.20/drivers/char/mem.c	2004-07-23 15:43:06.901259118 +0200
+++ linux-2.4.20.SUSE/drivers/char/mem.c	2004-07-23 15:43:53.425870010 +0200
@@ -69,7 +69,7 @@ static ssize_t do_write_mem(struct file 
 	if (copy_from_user(p, buf, count))
 		return -EFAULT;
 	written += count;
-	*ppos += written;
+	*ppos = realp + written;
 	return written;
 }
 
@@ -110,7 +110,7 @@ static ssize_t read_mem(struct file * fi
 	if (copy_to_user(buf, __va(p), count))
 		return -EFAULT;
 	read += count;
-	*ppos += read;
+	*ppos = p + read;
 	return read;
 }
 
diff -urNp linux-2.4.20/drivers/char/nvram.c linux-2.4.20.SUSE/drivers/char/nvram.c
--- linux-2.4.20/drivers/char/nvram.c	2004-07-23 15:42:55.924114971 +0200
+++ linux-2.4.20.SUSE/drivers/char/nvram.c	2004-07-23 15:43:53.426870024 +0200
@@ -252,9 +252,13 @@ static ssize_t
 nvram_read(struct file *file, char *buf, size_t count, loff_t *ppos)
 {
 	unsigned char contents[NVRAM_BYTES];
-	unsigned i = *ppos;
+	loff_t n = *ppos;
+	unsigned i = n;
 	unsigned char *tmp;
 
+	if (i != n || i >= NVRAM_BYTES)
+		return 0;
+
 	spin_lock_irq(&rtc_lock);
 
 	if (!__nvram_check_checksum())
@@ -281,10 +285,14 @@ static ssize_t
 nvram_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
 {
 	unsigned char contents[NVRAM_BYTES];
-	unsigned i = *ppos;
+	loff_t n = *ppos;
+	unsigned i = n;
 	unsigned char *tmp;
 	int len;
 
+	if (i != n || i >= NVRAM_BYTES)
+		return 0;
+
 	len = (NVRAM_BYTES - i) < count ? (NVRAM_BYTES - i) : count;
 	if (copy_from_user(contents, buf, len))
 		return -EFAULT;
diff -urNp linux-2.4.20/drivers/char/raw.c linux-2.4.20.SUSE/drivers/char/raw.c
--- linux-2.4.20/drivers/char/raw.c	2004-07-23 15:43:04.417226500 +0200
+++ linux-2.4.20.SUSE/drivers/char/raw.c	2004-07-23 15:43:53.427870037 +0200
@@ -310,6 +310,7 @@ ssize_t	rw_raw_dev(int rw, struct file *
 	int		minor;
 	kdev_t		dev;
 	unsigned long	limit;
+	loff_t		off = *offp;
 
 	int		sector_size, sector_bits, sector_mask;
 	int		max_sectors;
@@ -339,12 +340,12 @@ ssize_t	rw_raw_dev(int rw, struct file *
 		 MAJOR(dev), MINOR(dev), limit);
 	
 	err = -EINVAL;
-	if ((*offp & sector_mask) || (size & sector_mask))
+	if ((off & sector_mask) || (size & sector_mask))
 		goto out_free;
 	err = 0;
 	if (size)
 		err = -ENXIO;
-	if ((*offp >> sector_bits) >= limit)
+	if ((off >> sector_bits) >= limit)
 		goto out_free;
 
 	/*
@@ -354,7 +355,7 @@ ssize_t	rw_raw_dev(int rw, struct file *
 	 */
 
 	transferred = 0;
-	blocknr = *offp >> sector_bits;
+	blocknr = off >> sector_bits;
 	while (size > 0) {
 		blocks = size >> sector_bits;
 		if (blocks > max_sectors)
@@ -391,7 +392,7 @@ ssize_t	rw_raw_dev(int rw, struct file *
 	}
 	
 	if (transferred) {
-		*offp += transferred;
+		*offp = off + transferred;
 		err = transferred;
 	}
 
diff -urNp linux-2.4.20/drivers/char/tpqic02.c linux-2.4.20.SUSE/drivers/char/tpqic02.c
--- linux-2.4.20/drivers/char/tpqic02.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/char/tpqic02.c	2004-07-23 15:44:12.362118630 +0200
@@ -1818,6 +1818,7 @@ static ssize_t qic02_tape_read(struct fi
 	kdev_t dev = filp->f_dentry->d_inode->i_rdev;
 	unsigned short flags = filp->f_flags;
 	unsigned long bytes_todo, bytes_done, total_bytes_done = 0;
+	loff_t pos = *ppos;
 	int stat;
 
 	if (status_zombie == YES) {
@@ -1830,7 +1831,7 @@ static ssize_t qic02_tape_read(struct fi
 		printk(TPQIC02_NAME
 		       ": request READ, minor=%x, buf=%p, count=%lx"
 		       ", pos=%lx, flags=%x\n", MINOR(dev), buf,
-		       (long) count, (unsigned long) filp->f_pos, flags);
+		       (long) count, (unsigned long) pos, flags);
 
 	if (count % TAPE_BLKSIZE) {	/* Only allow mod 512 bytes at a time. */
 		tpqputs(TPQD_BLKSZ, "Wrong block size");
@@ -1898,6 +1899,7 @@ static ssize_t qic02_tape_read(struct fi
 
 	/*****************************/
 		if (bytes_todo == 0) {
+			*ppos = pos;
 			return total_bytes_done;
 		}
 
@@ -1966,7 +1968,7 @@ static ssize_t qic02_tape_read(struct fi
 		if (bytes_done > 0) {
 			status_bytes_rd = YES;
 			buf += bytes_done;
-			*ppos += bytes_done;
+			pos += bytes_done;
 			total_bytes_done += bytes_done;
 			count -= bytes_done;
 		}
diff -urNp linux-2.4.20/drivers/char/vc_screen.c linux-2.4.20.SUSE/drivers/char/vc_screen.c
--- linux-2.4.20/drivers/char/vc_screen.c	2001-09-17 06:22:40.000000000 +0200
+++ linux-2.4.20.SUSE/drivers/char/vc_screen.c	2004-07-23 15:43:53.428870050 +0200
@@ -64,12 +64,25 @@ vcs_size(struct inode *inode)
 	return size;
 }
 
+/* We share this temporary buffer with the console write code
+ * so that we can easily avoid touching user space while holding the
+ * console spinlock.
+ */
+extern char con_buf[PAGE_SIZE];
+#define CON_BUF_SIZE	PAGE_SIZE
+extern struct semaphore con_buf_sem;
+
 static loff_t vcs_lseek(struct file *file, loff_t offset, int orig)
 {
-	int size = vcs_size(file->f_dentry->d_inode);
+	int size;
+
+	down(&con_buf_sem);
+
+	size = vcs_size(file->f_dentry->d_inode);
 
 	switch (orig) {
 		default:
+			up(&con_buf_sem);
 			return -EINVAL;
 		case 2:
 			offset += size;
@@ -79,26 +92,22 @@ static loff_t vcs_lseek(struct file *fil
 		case 0:
 			break;
 	}
-	if (offset < 0 || offset > size)
+	if (offset < 0 || offset > size) {
+		up(&con_buf_sem);
 		return -EINVAL;
+	}
 	file->f_pos = offset;
+	up (&con_buf_sem);
 	return file->f_pos;
 }
 
-/* We share this temporary buffer with the console write code
- * so that we can easily avoid touching user space while holding the
- * console spinlock.
- */
-extern char con_buf[PAGE_SIZE];
-#define CON_BUF_SIZE	PAGE_SIZE
-extern struct semaphore con_buf_sem;
-
 static ssize_t
 vcs_read(struct file *file, char *buf, size_t count, loff_t *ppos)
 {
 	struct inode *inode = file->f_dentry->d_inode;
 	unsigned int currcons = MINOR(inode->i_rdev);
-	long pos = *ppos;
+	loff_t n;
+	unsigned pos;
 	long viewed, attr, read;
 	int col, maxcol;
 	unsigned short *org = NULL;
@@ -106,6 +115,9 @@ vcs_read(struct file *file, char *buf, s
 
 	down(&con_buf_sem);
 
+	n = *ppos; 
+	pos = n;
+
 	/* Select the proper current console and verify
 	 * sanity of the situation under the console lock.
 	 */
@@ -124,11 +136,10 @@ vcs_read(struct file *file, char *buf, s
 	if (!vc_cons_allocated(currcons))
 		goto unlock_out;
 
-	ret = -EINVAL;
-	if (pos < 0)
-		goto unlock_out;
 	read = 0;
 	ret = 0;
+	if (pos != n)
+		goto unlock_out;
 	while (count) {
 		char *con_buf0, *con_buf_start;
 		long this_round, size;
@@ -244,16 +255,15 @@ vcs_read(struct file *file, char *buf, s
 		acquire_console_sem();
 
 		if (ret) {
-			read += (orig_count - ret);
 			ret = -EFAULT;
-			break;
+			goto unlock_out;
 		}
 		buf += orig_count;
 		pos += orig_count;
 		read += orig_count;
 		count -= orig_count;
 	}
-	*ppos += read;
+	*ppos = pos;
 	if (read)
 		ret = read;
 unlock_out:
@@ -267,7 +277,8 @@ vcs_write(struct file *file, const char 
 {
 	struct inode *inode = file->f_dentry->d_inode;
 	unsigned int currcons = MINOR(inode->i_rdev);
-	long pos = *ppos;
+	loff_t n;
+	unsigned pos;
 	long viewed, attr, size, written;
 	char *con_buf0;
 	int col, maxcol;
@@ -276,6 +287,9 @@ vcs_write(struct file *file, const char 
 
 	down(&con_buf_sem);
 
+	n = *ppos;
+	pos = n;
+
 	/* Select the proper current console and verify
 	 * sanity of the situation under the console lock.
 	 */
@@ -297,7 +311,7 @@ vcs_write(struct file *file, const char 
 
 	size = vcs_size(inode);
 	ret = -EINVAL;
-	if (pos < 0 || pos > size)
+	if (pos != n || pos > size)
 		goto unlock_out;
 	if (count > size - pos)
 		count = size - pos;
@@ -435,7 +449,7 @@ vcs_write(struct file *file, const char 
 		if (org0)
 			update_region(currcons, (unsigned long)(org0), org-org0);
 	}
-	*ppos += written;
+	*ppos = pos;
 	ret = written;
 
 unlock_out:
diff -urNp linux-2.4.20/drivers/gsc/eisa_eeprom.c linux-2.4.20.SUSE/drivers/gsc/eisa_eeprom.c
--- linux-2.4.20/drivers/gsc/eisa_eeprom.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/gsc/eisa_eeprom.c	2004-07-23 15:43:53.429870063 +0200
@@ -34,24 +34,30 @@ static ssize_t eisa_eeprom_read(struct f
 	unsigned char *tmp;
 	ssize_t ret;
 	int i;
+	loff_t n = *ppos;
+	unsigned pos = n;
 	
-	if (*ppos >= HPEE_MAX_LENGTH)
+	if (n != (unsigned) pos || pos >= HPEE_MAX_LENGTH)
 		return 0;
 	
-	count = *ppos + count < HPEE_MAX_LENGTH ? count : HPEE_MAX_LENGTH - *ppos;
+	if (count > HPEE_MAX_LENGTH - pos)
+		count = HPEE_MAX_LENGTH - pos;
+
 	tmp = kmalloc(count, GFP_KERNEL);
 	if (tmp) {
 		for (i = 0; i < count; i++)
-			tmp[i] = gsc_readb(eeprom_addr+(*ppos)++);
+			tmp[i] = gsc_readb(eeprom_addr+(pos)++);
 
 		if (copy_to_user (buf, tmp, count))
 			ret = -EFAULT;
-		else
+		else {
 			ret = count;
+			*ppos = pos;
+		}
 		kfree (tmp);
 	} else
 		ret = -ENOMEM;
-	
+
 	return ret;
 }
 
diff -urNp linux-2.4.20/drivers/hotplug/pci_hotplug_core.c linux-2.4.20.SUSE/drivers/hotplug/pci_hotplug_core.c
--- linux-2.4.20/drivers/hotplug/pci_hotplug_core.c	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/hotplug/pci_hotplug_core.c	2004-07-23 15:43:53.430870076 +0200
@@ -604,7 +604,7 @@ static ssize_t power_read_file (struct f
 		retval = -EFAULT;
 		goto exit;
 	}
-	*offset += len;
+	*offset = len;
 	retval = len;
 
 exit:
@@ -715,7 +715,7 @@ static ssize_t attention_read_file (stru
 		retval = -EFAULT;
 		goto exit;
 	}
-	*offset += len;
+	*offset = len;
 	retval = len;
 
 exit:
@@ -780,14 +780,15 @@ static ssize_t latch_read_file (struct f
 	int retval;
 	int len;
 	u8 value;
+	loff_t off = *offset;
 
-	dbg("count = %d, offset = %lld\n", count, *offset);
+	dbg("count = %d, offset = %lld\n", count, off);
 
-	if (*offset < 0)
+	if (off < 0)
 		return -EINVAL;
 	if (count <= 0)
 		return 0;
-	if (*offset != 0)
+	if (off != 0)
 		return 0;
 
 	if (slot == NULL) {
@@ -808,7 +809,7 @@ static ssize_t latch_read_file (struct f
 		retval = -EFAULT;
 		goto exit;
 	}
-	*offset += len;
+	*offset = off + len;
 	retval = len;
 
 exit:
@@ -823,14 +824,15 @@ static ssize_t presence_read_file (struc
 	int retval;
 	int len;
 	u8 value;
+	loff_t off = *offset;
 
 	dbg("count = %d, offset = %lld\n", count, *offset);
 
-	if (*offset < 0)
+	if (off < 0)
 		return -EINVAL;
 	if (count <= 0)
 		return 0;
-	if (*offset != 0)
+	if (off != 0)
 		return 0;
 
 	if (slot == NULL) {
@@ -851,7 +853,7 @@ static ssize_t presence_read_file (struc
 		retval = -EFAULT;
 		goto exit;
 	}
-	*offset += len;
+	*offset = off + len;
 	retval = len;
 
 exit:
@@ -869,14 +871,15 @@ static ssize_t max_bus_speed_read_file (
 	int retval;
 	int len = 0;
 	enum pci_bus_speed value;
+	loff_t off = *offset;
 	
-	dbg ("count = %d, offset = %lld\n", count, *offset);
+	dbg ("count = %d, offset = %lld\n", count, off);
 
-	if (*offset < 0)
+	if (off < 0)
 		return -EINVAL;
 	if (count <= 0)
 		return 0;
-	if (*offset != 0)
+	if (off != 0)
 		return 0;
 
 	if (slot == NULL) {
@@ -903,7 +906,7 @@ static ssize_t max_bus_speed_read_file (
 		retval = -EFAULT;
 		goto exit;
 	}
-	*offset += len;
+	*offset  = off + len;
 	retval = len;
 
 exit:
@@ -919,14 +922,15 @@ static ssize_t cur_bus_speed_read_file (
 	int retval;
 	int len = 0;
 	enum pci_bus_speed value;
+	loff_t off = *offset;
 
-	dbg ("count = %d, offset = %lld\n", count, *offset);
+	dbg ("count = %d, offset = %lld\n", count, off);
 
-	if (*offset < 0)
+	if (off < 0)
 		return -EINVAL;
 	if (count <= 0)
 		return 0;
-	if (*offset != 0)
+	if (off != 0)
 		return 0;
 
 	if (slot == NULL) {
@@ -953,7 +957,7 @@ static ssize_t cur_bus_speed_read_file (
 		retval = -EFAULT;
 		goto exit;
 	}
-	*offset += len;
+	*offset = off + len;
 	retval = len;
 
 exit:
--- linux-2.4.20/drivers/ieee1394/pcilynx.c.orig	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.20/drivers/ieee1394/pcilynx.c	2004-08-12 13:30:49.000000000 +0200
@@ -891,20 +891,15 @@
         ssize_t retval;
         void *membase;
 
-	if (*offset != off)	/* Check for EOF before we trust wrap */
+	if (!count)
 		return 0;
-	
-	/* FIXME: Signed wrap is undefined in C - wants fixing up */
-	if (off + count > off)
-		return 0;
-		
-        if ((off + count) > PCILYNX_MAX_MEMORY + 1) {
-                count = PCILYNX_MAX_MEMORY + 1 - off;
-        }
-        if (count == 0) {
-                return 0;
-        }
+	if (off < 0)
+		return -EINVAL;
+	if (off > PCILYNX_MAX_MEMORY)
+		return -ENOSPC;
 
+	if (count > PCILYNX_MAX_MEMORY + 1 - off)
+		count = PCILYNX_MAX_MEMORY + 1 - off;
 
         switch (md->type) {
         case rom:
@@ -925,6 +920,7 @@
 
         if (count < mem_mindma) {
                 memcpy_fromio(md->lynx->mem_dma_buffer, membase+off, count);
+		off += count;
                 goto out;
         }
 
@@ -955,6 +951,7 @@
         if (bcount) {
                 memcpy_fromio(md->lynx->mem_dma_buffer + count - bcount,
                               membase+off, bcount);
+		off += bcount;
         }
 
  out:
@@ -962,7 +959,7 @@
         up(&md->lynx->mem_dma_mutex);
 
         if (retval < 0) return retval;
-        *offset += count;
+        *offset = off;
         return count;
 }
 
@@ -972,24 +969,32 @@
 {
         struct memdata *md = (struct memdata *)file->private_data;
 
-        if (((*offset) + count) > PCILYNX_MAX_MEMORY+1) {
-                count = PCILYNX_MAX_MEMORY+1 - *offset;
-        }
-        if (count == 0 || *offset > PCILYNX_MAX_MEMORY) {
-                return -ENOSPC;
-        }
+	loff_t off = *offset;
+  
+	if (!count)
+		return 0;
+	if (off < 0)
+		return -EINVAL;
+	if (off > PCILYNX_MAX_MEMORY)
+		return -ENOSPC;
+ 
+	if (count > PCILYNX_MAX_MEMORY + 1 - off)
+		count = PCILYNX_MAX_MEMORY + 1 - off;
 
         /* FIXME: dereferencing pointers to PCI mem doesn't work everywhere */
         switch (md->type) {
         case aux:
-                copy_from_user(md->lynx->aux_port+(*offset), buffer, count);
+		if (copy_from_user(md->lynx->aux_port+off, buffer, count))
+			return -EFAULT;
                 break;
         case ram:
-                copy_from_user(md->lynx->local_ram+(*offset), buffer, count);
+		if (copy_from_user(md->lynx->local_ram+off, buffer, count))
+			return -EFAULT;
                 break;
         case rom:
                 /* the ROM may be writeable */
-                copy_from_user(md->lynx->local_rom+(*offset), buffer, count);
+		if (copy_from_user(md->lynx->local_rom+off, buffer, count))
+			return -EFAULT;
                 break;
         }
 
diff -urNp linux-2.4.20/drivers/isdn/divert/divert_procfs.c linux-2.4.20.SUSE/drivers/isdn/divert/divert_procfs.c
--- linux-2.4.20/drivers/isdn/divert/divert_procfs.c	2001-12-21 18:41:54.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/isdn/divert/divert_procfs.c	2004-07-23 15:43:53.434870129 +0200
@@ -80,6 +80,7 @@ static ssize_t
 isdn_divert_read(struct file *file, char *buf, size_t count, loff_t * off)
 {
 	struct divert_info *inf;
+	loff_t pos = *off;
 	int len;
 
 	if (!*((struct divert_info **) file->private_data)) {
@@ -95,7 +96,7 @@ isdn_divert_read(struct file *file, char
 	if ((len = strlen(inf->info_start)) <= count) {
 		if (copy_to_user(buf, inf->info_start, len))
 			return -EFAULT;
-		file->f_pos += len;
+		*off = pos + len;
 		return (len);
 	}
 	return (0);
diff -urNp linux-2.4.20/drivers/isdn/hysdn/hysdn_procconf.c linux-2.4.20.SUSE/drivers/isdn/hysdn/hysdn_procconf.c
--- linux-2.4.20/drivers/isdn/hysdn/hysdn_procconf.c	2001-12-21 18:41:54.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/isdn/hysdn/hysdn_procconf.c	2004-07-23 15:43:53.435870142 +0200
@@ -212,29 +212,27 @@ hysdn_conf_write(struct file *file, cons
 static ssize_t
 hysdn_conf_read(struct file *file, char *buf, size_t count, loff_t * off)
 {
+	loff_t pos = *off;
 	char *cp;
 	int i;
 
 	if (off != &file->f_pos)	/* fs error check */
 		return -ESPIPE;
 
-	if (file->f_mode & FMODE_READ) {
-		if (!(cp = file->private_data))
-			return (-EFAULT);	/* should never happen */
-		i = strlen(cp);	/* get total string length */
-		if (*off < i) {
-			/* still bytes to transfer */
-			cp += *off;	/* point to desired data offset */
-			i -= *off;	/* remaining length */
-			if (i > count)
-				i = count;	/* limit length to transfer */
-			if (copy_to_user(buf, cp, i))
-				return (-EFAULT);	/* copy error */
-			*off += i;	/* adjust offset */
-		} else
-			return (0);
+	if (!(cp = file->private_data))
+		return (-EFAULT);	/* should never happen */
+	i = strlen(cp);	/* get total string length */
+	if (pos == (unsigned)pos && pos < i) {
+		/* still bytes to transfer */
+		cp += pos;	/* point to desired data offset */
+		i -= pos;	/* remaining length */
+		if (i > count)
+			i = count;	/* limit length to transfer */
+		if (copy_to_user(buf, cp, i))
+			return (-EFAULT);	/* copy error */
+		*off = pos + i;	/* adjust offset */
 	} else
-		return (-EPERM);	/* no permission to read */
+		return (0);
 
 	return (i);
 }				/* hysdn_conf_read */
diff -urNp linux-2.4.20/drivers/isdn/hysdn/hysdn_proclog.c linux-2.4.20.SUSE/drivers/isdn/hysdn/hysdn_proclog.c
--- linux-2.4.20/drivers/isdn/hysdn/hysdn_proclog.c	2001-12-21 18:41:54.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/isdn/hysdn/hysdn_proclog.c	2004-07-23 15:43:53.436870155 +0200
@@ -210,6 +210,7 @@ hysdn_log_read(struct file *file, char *
 	word ino;
 	struct procdata *pd = NULL;
 	hysdn_card *card;
+	loff_t pos = *off;
 
 	if (!*((struct log_data **) file->private_data)) {
 		if (file->f_flags & O_NONBLOCK)
@@ -238,7 +239,7 @@ hysdn_log_read(struct file *file, char *
 	if ((len = strlen(inf->log_start)) <= count) {
 		if (copy_to_user(buf, inf->log_start, len))
 			return -EFAULT;
-		file->f_pos += len;
+		*off = pos + len;
 		return (len);
 	}
 	return (0);
diff -urNp linux-2.4.20/drivers/isdn/isdn_common.c linux-2.4.20.SUSE/drivers/isdn/isdn_common.c
--- linux-2.4.20/drivers/isdn/isdn_common.c	2004-07-23 15:43:12.559333416 +0200
+++ linux-2.4.20.SUSE/drivers/isdn/isdn_common.c	2004-07-23 15:43:53.438870181 +0200
@@ -976,10 +976,14 @@ isdn_read(struct file *file, char *buf, 
 	int chidx;
 	int retval;
 	char *p;
+	loff_t pos = *off;
 
 	if (off != &file->f_pos)
 		return -ESPIPE;
 
+	if (pos != (unsigned) pos)
+		return -EINVAL;
+
 	lock_kernel();
 	if (minor == ISDN_MINOR_STATUS) {
 		if (!file->private_data) {
@@ -996,7 +1000,7 @@ isdn_read(struct file *file, char *buf, 
 				retval = -EFAULT;
 				goto out;
 			}
-			*off += len;
+			*off = pos + len;
 			retval = len;
 			goto out;
 		}
@@ -1027,7 +1031,7 @@ isdn_read(struct file *file, char *buf, 
 		cli();
 		len = isdn_readbchan(drvidx, chidx, p, 0, count,
 				     &dev->drv[drvidx]->rcv_waitq[chidx]);
-		*off += len;
+		*off = pos + len;
 		restore_flags(flags);
 		if (copy_to_user(buf,p,len)) 
 			len = -EFAULT;
@@ -1064,7 +1068,7 @@ isdn_read(struct file *file, char *buf, 
 		else
 			dev->drv[drvidx]->stavail = 0;
 		restore_flags(flags);
-		*off += len;
+		*off = pos + len;
 		retval = len;
 		goto out;
 	}
diff -urNp linux-2.4.20/drivers/mtd/mtdchar.c linux-2.4.20.SUSE/drivers/mtd/mtdchar.c
--- linux-2.4.20/drivers/mtd/mtdchar.c	2004-07-23 15:42:56.719125411 +0200
+++ linux-2.4.20.SUSE/drivers/mtd/mtdchar.c	2004-07-23 15:43:53.439870194 +0200
@@ -125,11 +125,15 @@ static ssize_t mtd_read(struct file *fil
 	int ret=0;
 	int len;
 	char *kbuf;
+	loff_t pos = *ppos;
 	
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
 
-	if (*ppos + count > mtd->size)
-		count = mtd->size - *ppos;
+	if (pos < 0 || pos >= mtd->size)
+		return 0;
+
+	if (count > mtd->size - pos)
+		count = mtd->size - pos;
 
 	if (!count)
 		return 0;
@@ -146,9 +150,9 @@ static ssize_t mtd_read(struct file *fil
 		if (!kbuf)
 			return -ENOMEM;
 		
-		ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
+		ret = MTD_READ(mtd, pos, len, &retlen, kbuf);
 		if (!ret) {
-			*ppos += retlen;
+			pos += retlen;
 			if (copy_to_user(buf, kbuf, retlen)) {
 			        kfree(kbuf);
 				return -EFAULT;
@@ -167,6 +171,8 @@ static ssize_t mtd_read(struct file *fil
 		kfree(kbuf);
 	}
 	
+	*ppos = pos;
+	
 	return total_retlen;
 } /* mtd_read */
 
@@ -176,17 +182,18 @@ static ssize_t mtd_write(struct file *fi
 	char *kbuf;
 	size_t retlen;
 	size_t total_retlen=0;
+	unsigned long pos = *ppos;
 	int ret=0;
 	int len;
 
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
 	
-	if (*ppos == mtd->size)
+	if (pos < 0 || pos >= mtd->size)
 		return -ENOSPC;
-	
-	if (*ppos + count > mtd->size)
-		count = mtd->size - *ppos;
 
+	if (count > mtd->size - pos)
+		count = mtd->size - pos;
+	
 	if (!count)
 		return 0;
 
@@ -207,9 +214,9 @@ static ssize_t mtd_write(struct file *fi
 			return -EFAULT;
 		}
 		
-	        ret = (*(mtd->write))(mtd, *ppos, len, &retlen, kbuf);
+	        ret = (*(mtd->write))(mtd, pos, len, &retlen, kbuf);
 		if (!ret) {
-			*ppos += retlen;
+			pos += retlen;
 			total_retlen += retlen;
 			count -= retlen;
 			buf += retlen;
@@ -221,6 +228,7 @@ static ssize_t mtd_write(struct file *fi
 		
 		kfree(kbuf);
 	}
+	*ppos = pos;
 
 	return total_retlen;
 } /* mtd_write */
--- linux-2.4.20/drivers/pci/proc.c.orig	2004-08-12 12:39:56.000000000 +0200
+++ linux-2.4.20/drivers/pci/proc.c	2004-08-12 13:40:54.000000000 +0200
@@ -47,7 +47,8 @@
 	const struct inode *ino = file->f_dentry->d_inode;
 	const struct proc_dir_entry *dp = ino->u.generic_ip;
 	struct pci_dev *dev = dp->data;
-	unsigned int pos = *ppos;
+	loff_t n = *ppos;
+	unsigned pos = n;
 	unsigned int cnt, size;
 
 	/*
@@ -63,7 +64,7 @@
 	else
 		size = 64;
 
-	if (pos >= size)
+	if (pos != n || pos >= size)
 		return 0;
 	if (nbytes >= size)
 		nbytes = size;
@@ -129,10 +130,11 @@
 	const struct inode *ino = file->f_dentry->d_inode;
 	const struct proc_dir_entry *dp = ino->u.generic_ip;
 	struct pci_dev *dev = dp->data;
-	int pos = *ppos;
+	loff_t n = *ppos;
+	unsigned pos = n;
 	int cnt;
 
-	if (pos >= PCI_CFG_SPACE_SIZE)
+	if (pos != n || pos >= PCI_CFG_SPACE_SIZE)
 		return 0;
 	if (nbytes >= PCI_CFG_SPACE_SIZE)
 		nbytes = PCI_CFG_SPACE_SIZE;
diff -urNp linux-2.4.20/drivers/pnp/isapnp_proc.c linux-2.4.20.SUSE/drivers/pnp/isapnp_proc.c
--- linux-2.4.20/drivers/pnp/isapnp_proc.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/pnp/isapnp_proc.c	2004-07-23 15:43:53.441870221 +0200
@@ -102,6 +102,7 @@ static ssize_t isapnp_info_entry_read(st
 				      size_t count, loff_t * offset)
 {
 	isapnp_info_buffer_t *buf;
+	loff_t pos = *offset;
 	long size = 0, size1;
 	int mode;
 
@@ -111,15 +112,15 @@ static ssize_t isapnp_info_entry_read(st
 	buf = (isapnp_info_buffer_t *) file->private_data;
 	if (!buf)
 		return -EIO;
-	if (file->f_pos >= buf->size)
+	if (pos != (unsigned) pos || pos >= buf->size)
 		return 0;
 	size = buf->size < count ? buf->size : count;
-	size1 = buf->size - file->f_pos;
+	size1 = buf->size - pos;
 	if (size1 < size)
 		size = size1;
-	if (copy_to_user(buffer, buf->buffer + file->f_pos, size))
+	if (copy_to_user(buffer, buf->buffer + pos, size))
 		return -EFAULT;
-	file->f_pos += size;
+	*offset = pos + size;
 	return size;
 }
 
@@ -128,6 +129,7 @@ static ssize_t isapnp_info_entry_write(s
 {
 	isapnp_info_buffer_t *buf;
 	long size = 0, size1;
+	loff_t pos = *offset;
 	int mode;
 
 	mode = file->f_flags & O_ACCMODE;
@@ -136,19 +138,19 @@ static ssize_t isapnp_info_entry_write(s
 	buf = (isapnp_info_buffer_t *) file->private_data;
 	if (!buf)
 		return -EIO;
-	if (file->f_pos < 0)
+	if (pos < 0)
 		return -EINVAL;
-	if (file->f_pos >= buf->len)
+	if (pos >= buf->len)
 		return -ENOMEM;
 	size = buf->len < count ? buf->len : count;
-	size1 = buf->len - file->f_pos;
+	size1 = buf->len - pos;
 	if (size1 < size)
 		size = size1;
-	if (copy_from_user(buf->buffer + file->f_pos, buffer, size))
+	if (copy_from_user(buf->buffer + pos, buffer, size))
 		return -EFAULT;
-	if (buf->size < file->f_pos + size)
-		buf->size = file->f_pos + size;
-	file->f_pos += size;
+	if (buf->size < pos + size)
+		buf->size = pos + size;
+	*offset = pos + size;
 	return size;
 }
 
@@ -240,14 +242,15 @@ static ssize_t isapnp_proc_bus_read(stru
 	struct inode *ino = file->f_dentry->d_inode;
 	struct proc_dir_entry *dp = ino->u.generic_ip;
 	struct pci_dev *dev = dp->data;
-	int pos = *ppos;
+	loff_t n = *ppos;
+	unsigned pos = n;
 	int cnt, size = 256;
 
-	if (pos >= size)
+	if (pos != n || pos >= size)
 		return 0;
 	if (nbytes >= size)
 		nbytes = size;
-	if (pos + nbytes > size)
+	if (nbytes > size - pos)
 		nbytes = size - pos;
 	cnt = nbytes;
 
diff -urNp linux-2.4.20/drivers/s390/block/dasd.c linux-2.4.20.SUSE/drivers/s390/block/dasd.c
--- linux-2.4.20/drivers/s390/block/dasd.c	2004-07-23 15:42:57.028129469 +0200
+++ linux-2.4.20.SUSE/drivers/s390/block/dasd.c	2004-07-23 15:43:53.446870286 +0200
@@ -3780,15 +3780,17 @@ dasd_generic_read (struct file *file, ch
 		   loff_t * offset)
 {
 	loff_t len;
+	loff_t n = *offset;
+	unsigned pos = n;
 	tempinfo_t *p_info = (tempinfo_t *) file->private_data;
 
-	if (*offset >= p_info->len) {
+	if (n != pos || pos >= p_info->len) {
 		return 0;	/* EOF */
 	} else {
-		len = MIN (user_len, (p_info->len - *offset));
-		if (copy_to_user (user_buf, &(p_info->data[*offset]), len))
+		len = MIN (user_len, (p_info->len - pos));
+		if (copy_to_user (user_buf, &(p_info->data[pos]), len))
 			return -EFAULT;
-		(*offset) += len;
+		*offset = pos + len;
 		return len;	/* number of bytes "read" */
 	}
 }
diff -urNp linux-2.4.20/drivers/s390/net/ctcmain.c linux-2.4.20.SUSE/drivers/s390/net/ctcmain.c
--- linux-2.4.20/drivers/s390/net/ctcmain.c	2002-02-25 20:38:03.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/s390/net/ctcmain.c	2004-07-23 15:43:53.453870378 +0200
@@ -2754,6 +2754,7 @@ static int ctc_ctrl_open(struct inode *i
 	file->private_data = kmalloc(CTRL_BUFSIZE, GFP_KERNEL);
 	if (file->private_data == NULL)
 		return -ENOMEM;
+	*(char *)file->private_data = '\0';
 	MOD_INC_USE_COUNT;
 	return 0;
 }
@@ -2819,6 +2820,7 @@ static ssize_t ctc_ctrl_read(struct file
 	ctc_priv *privptr;
 	ssize_t ret = 0;
 	char *p = sbuf;
+	loff_t pos = *off;
 	int l;
 
 	if (!(dev = find_netdev_by_ino(ino)))
@@ -2828,19 +2830,19 @@ static ssize_t ctc_ctrl_read(struct file
 
 	privptr = (ctc_priv *)dev->priv;
 
-	if (file->f_pos == 0)
+	if (!*sbuf || pos == 0)
 		sprintf(sbuf, "%d\n", privptr->channel[READ]->max_bufsize);
 
 	l = strlen(sbuf);
 	p = sbuf;
-	if (file->f_pos < l) {
-		p += file->f_pos;
+	if (pos == (unsigned)pos && pos < l) {
+		p += pos;
 		l = strlen(p);
 		ret = (count > l) ? l : count;
 		if (copy_to_user(buf, p, ret))
 			return -EFAULT;
+		*off = pos + ret;
 	}
-	file->f_pos += ret;
 	return ret;
 }
 
@@ -2890,6 +2892,8 @@ static ssize_t ctc_stat_read(struct file
 	ctc_priv *privptr;
 	ssize_t ret = 0;
 	char *p = sbuf;
+	loff_t pos = *off;
+	loff_t pos = *off;
 	int l;
 
 	if (!(dev = find_netdev_by_ino(ino)))
@@ -2899,7 +2903,7 @@ static ssize_t ctc_stat_read(struct file
 
 	privptr = (ctc_priv *)dev->priv;
 
-	if (file->f_pos == 0) {
+	if (!*sbus || pos == 0) {
 		p += sprintf(p, "Device FSM state: %s\n",
 			     fsm_getstate_str(privptr->fsm));
 		p += sprintf(p, "RX channel FSM state: %s\n",
@@ -2921,14 +2925,14 @@ static ssize_t ctc_stat_read(struct file
 	}
 	l = strlen(sbuf);
 	p = sbuf;
-	if (file->f_pos < l) {
-		p += file->f_pos;
+	if (pos == (unsigned)pos && pos < l) {
+		p += pos;
 		l = strlen(p);
 		ret = (count > l) ? l : count;
 		if (copy_to_user(buf, p, ret))
 			return -EFAULT;
+		*off = pos + ret;
 	}
-	file->f_pos += ret;
 	return ret;
 }
 
diff -urNp linux-2.4.20/drivers/s390/net/netiucv.c linux-2.4.20.SUSE/drivers/s390/net/netiucv.c
--- linux-2.4.20/drivers/s390/net/netiucv.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/s390/net/netiucv.c	2004-07-23 15:43:53.455870404 +0200
@@ -1332,6 +1332,7 @@ netiucv_buffer_open(struct inode *inode,
 	file->private_data = kmalloc(CTRL_BUFSIZE, GFP_KERNEL);
 	if (file->private_data == NULL)
 		return -ENOMEM;
+	*(char *)file->private_data = '\0';
 	MOD_INC_USE_COUNT;
 	return 0;
 }
@@ -1397,6 +1398,7 @@ netiucv_buffer_read(struct file *file, c
 	netiucv_priv *privptr;
 	ssize_t ret = 0;
 	char *p = sbuf;
+	loff_t pos = *ppos;
 	int l;
 
 	if (!(dev = find_netdev_by_ino(ino)))
@@ -1406,19 +1408,20 @@ netiucv_buffer_read(struct file *file, c
 
 	privptr = (netiucv_priv *)dev->priv;
 
-	if (file->f_pos == 0)
+	if (!*sbuf || pos == 0)
 		sprintf(sbuf, "%d\n", privptr->conn->max_buffsize);
 
 	l = strlen(sbuf);
 	p = sbuf;
-	if (file->f_pos < l) {
-		p += file->f_pos;
+	if (pos == (unsigned)pos && pos < l) {
+		p += pos;
 		l = strlen(p);
 		ret = (count > l) ? l : count;
 		if (copy_to_user(buf, p, ret))
 			return -EFAULT;
 	}
-	file->f_pos += ret;
+	pos += ret;
+	*ppos = pos;
 	return ret;
 }
 
@@ -1428,6 +1431,7 @@ netiucv_user_open(struct inode *inode, s
 	file->private_data = kmalloc(CTRL_BUFSIZE, GFP_KERNEL);
 	if (file->private_data == NULL)
 		return -ENOMEM;
+	*(char *)file->private_data = '\0';
 	MOD_INC_USE_COUNT;
 	return 0;
 }
@@ -1492,6 +1496,7 @@ netiucv_user_read(struct file *file, cha
 	netiucv_priv *privptr;
 	ssize_t ret = 0;
 	char *p = sbuf;
+	loff_t pos = *ppos;
 	int l;
 
 	if (!(dev = find_netdev_by_ino(ino)))
@@ -1502,20 +1507,20 @@ netiucv_user_read(struct file *file, cha
 	privptr = (netiucv_priv *)dev->priv;
 
 
-	if (file->f_pos == 0)
+	if (!*sbuf || pos == 0)
 		sprintf(sbuf, "%s\n",
 			netiucv_printname(privptr->conn->userid));
 
 	l = strlen(sbuf);
 	p = sbuf;
-	if (file->f_pos < l) {
-		p += file->f_pos;
+	if (pos == (unsigned)pos && pos < l) {
+		p += pos;
 		l = strlen(p);
 		ret = (count > l) ? l : count;
 		if (copy_to_user(buf, p, ret))
 			return -EFAULT;
+		*ppos = pos + ret;
 	}
-	file->f_pos += ret;
 	return ret;
 }
 
@@ -1527,6 +1532,7 @@ netiucv_stat_open(struct inode *inode, s
 	file->private_data = kmalloc(STATS_BUFSIZE, GFP_KERNEL);
 	if (file->private_data == NULL)
 		return -ENOMEM;
+	*(char *)file->private_data = '\0';
 	MOD_INC_USE_COUNT;
 	return 0;
 }
@@ -1562,6 +1568,7 @@ static ssize_t
 netiucv_stat_read(struct file *file, char *buf, size_t count, loff_t *off)
 {
 	unsigned int ino = ((struct inode *)file->f_dentry->d_inode)->i_ino;
+	loff_t pos = *ppos;
 	char *sbuf = (char *)file->private_data;
 	net_device *dev;
 	netiucv_priv *privptr;
@@ -1576,7 +1583,7 @@ netiucv_stat_read(struct file *file, cha
 
 	privptr = (netiucv_priv *)dev->priv;
 
-	if (file->f_pos == 0) {
+	if (!*sbuf || pos == 0) {
 		p += sprintf(p, "Device FSM state: %s\n",
 			     fsm_getstate_str(privptr->fsm));
 		p += sprintf(p, "Connection FSM state: %s\n",
@@ -1596,14 +1603,14 @@ netiucv_stat_read(struct file *file, cha
 	}
 	l = strlen(sbuf);
 	p = sbuf;
-	if (file->f_pos < l) {
-		p += file->f_pos;
+	if (pos == (unsigned)pos && pos < l) {
+		p += pos;
 		l = strlen(p);
 		ret = (count > l) ? l : count;
 		if (copy_to_user(buf, p, ret))
 			return -EFAULT;
+		*ppos = pos + ret;
 	}
-	file->f_pos += ret;
 	return ret;
 }
 
diff -urNp linux-2.4.20/drivers/s390/s390io.c linux-2.4.20.SUSE/drivers/s390/s390io.c
--- linux-2.4.20/drivers/s390/s390io.c	2004-07-23 15:42:57.040129626 +0200
+++ linux-2.4.20.SUSE/drivers/s390/s390io.c	2004-07-23 15:43:53.463870509 +0200
@@ -8127,14 +8127,15 @@ cio_device_entry_read (struct file *file
 {
 	loff_t len;
 	tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+	loff_t pos = *offset;
 
-	if (*offset >= p_info->len) {
+	if (pos < 0 || pos >= p_info->len) {
 		return 0;
 	} else {
-		len = MIN (user_len, (p_info->len - *offset));
-		if (copy_to_user (user_buf, &(p_info->data[*offset]), len))
+		len = MIN (user_len, (p_info->len - pos));
+		if (copy_to_user (user_buf, &(p_info->data[pos]), len))
 			return -EFAULT;
-		(*offset) += len;
+		*offset = pos + len;
 		return len;
 	}
 }
@@ -8591,14 +8592,16 @@ cio_ignore_proc_read (struct file *file,
 {
 	loff_t len;
 	tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+	loff_t n = *offset;
+	unsigned long pos = n;
 
-	if (*offset >= p_info->len) {
+	if (pos != n || pos >= p_info->len) {
 		return 0;
 	} else {
-		len = MIN (user_len, (p_info->len - *offset));
-		if (copy_to_user (user_buf, &(p_info->data[*offset]), len))
+		len = MIN (user_len, (p_info->len - pos));
+		if (copy_to_user (user_buf, &(p_info->data[pos]), len))
 			return -EFAULT;
-		(*offset) += len;
+		*offset = pos + len;
 		return len;
 	}
 }
@@ -8834,14 +8837,16 @@ cio_chpids_proc_read( struct file *file,
 {
      loff_t len;
      tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+     loff_t n = *offset;
+     unsigned long pos = n;
      
-     if ( *offset>=p_info->len) {
+     if ( n != pos || pos >= p_info->len) {
 	  return 0;
      } else {
-	  len = MIN(user_len, (p_info->len - *offset));
-	  if (copy_to_user( user_buf, &(p_info->data[*offset]), len))
+	  len = MIN(user_len, (p_info->len - pos));
+	  if (copy_to_user( user_buf, &(p_info->data[pos]), len))
 	       return -EFAULT; 
-	  (* offset) += len;
+	  *offset = pos + len;
 	  return len;
      }
 }
diff -urNp linux-2.4.20/drivers/sbus/char/flash.c linux-2.4.20.SUSE/drivers/sbus/char/flash.c
--- linux-2.4.20/drivers/sbus/char/flash.c	2001-10-11 08:42:47.000000000 +0200
+++ linux-2.4.20.SUSE/drivers/sbus/char/flash.c	2004-07-23 15:43:53.465870536 +0200
@@ -105,9 +105,14 @@ static ssize_t
 flash_read(struct file * file, char * buf,
 	   size_t count, loff_t *ppos)
 {
-	unsigned long p = file->f_pos;
+	loff_t p = *ppos;
 	int i;
 	
+	if (p < 0)
+		return -EINVAL;
+	if (p > flash.read_size)
+		return 0;
+
 	if (count > flash.read_size - p)
 		count = flash.read_size - p;
 
@@ -118,7 +123,7 @@ flash_read(struct file * file, char * bu
 		buf++;
 	}
 
-	file->f_pos += count;
+	*ppos = p + count;
 	return count;
 }
 
diff -urNp linux-2.4.20/drivers/scsi/osst.c linux-2.4.20.SUSE/drivers/scsi/osst.c
--- linux-2.4.20/drivers/scsi/osst.c	2004-07-23 15:43:12.845337172 +0200
+++ linux-2.4.20.SUSE/drivers/scsi/osst.c	2004-07-23 15:43:53.471870614 +0200
@@ -3087,6 +3087,7 @@ static ssize_t osst_write(struct file * 
 	ST_mode * STm;
 	ST_partstat * STps;
 	int dev = TAPE_NR(inode->i_rdev);
+	loff_t pos = *ppos;
 
 	STp = os_scsi_tapes[dev];
 
@@ -3304,7 +3305,7 @@ if (SRpnt) printk(KERN_ERR "osst%d:A: No
 		if (i == (-ENOSPC)) {
 			transfer = STp->buffer->writing;	/* FIXME -- check this logic */
 			if (transfer <= do_count) {
-				filp->f_pos += do_count - transfer;
+				pos += do_count - transfer;
 				count -= do_count - transfer;
 				if (STps->drv_block >= 0) {
 					STps->drv_block += (do_count - transfer) / STp->block_size;
@@ -3342,7 +3343,7 @@ if (SRpnt) printk(KERN_ERR "osst%d:A: No
 			goto out;
 		}
 
-		filp->f_pos += do_count;
+		pos += do_count;
 		b_point += do_count;
 		count -= do_count;
 		if (STps->drv_block >= 0) {
@@ -3364,7 +3365,7 @@ if (SRpnt) printk(KERN_ERR "osst%d:A: No
 		if (STps->drv_block >= 0) {
 			STps->drv_block += blks;
 		}
-		filp->f_pos += count;
+		pos += count;
 		count = 0;
 	}
 
@@ -3394,6 +3395,7 @@ if (SRpnt) printk(KERN_ERR "osst%d:A: No
 	retval = total;
 
 out:
+	*ppos = pos;
 	if (SRpnt != NULL) scsi_release_request(SRpnt);
 
 	up(&STp->lock);
@@ -3414,6 +3416,7 @@ static ssize_t osst_read(struct file * f
 	ST_partstat * STps;
 	Scsi_Request *SRpnt = NULL;
 	int dev = TAPE_NR(inode->i_rdev);
+	loff_t pos = *ppos;
 
 	STp = os_scsi_tapes[dev];
 
@@ -3539,7 +3542,7 @@ static ssize_t osst_read(struct file * f
 			}
 			STp->logical_blk_num += transfer / STp->block_size;
 			STps->drv_block      += transfer / STp->block_size;
-			filp->f_pos          += transfer;
+			pos                  += transfer;
 			buf                  += transfer;
 			total                += transfer;
 		}
@@ -3578,6 +3581,7 @@ static ssize_t osst_read(struct file * f
 	retval = total;
 
 out:
+	*ppos = pos;
 	if (SRpnt != NULL) scsi_release_request(SRpnt);
 
 	up(&STp->lock);
diff -urNp linux-2.4.20/drivers/scsi/st.c linux-2.4.20.SUSE/drivers/scsi/st.c
--- linux-2.4.20/drivers/scsi/st.c	2004-07-23 15:43:12.856337316 +0200
+++ linux-2.4.20.SUSE/drivers/scsi/st.c	2004-07-23 15:53:00.886052384 +0200
@@ -1207,6 +1207,7 @@ static ssize_t
 	ST_mode *STm;
 	ST_partstat *STps;
 	int dev = TAPE_NR(inode->i_rdev);
+	loff_t pos = *ppos;
 
 	read_lock(&st_dev_arr_lock);
 	STp = scsi_tapes[dev];
@@ -1436,7 +1437,7 @@ static ssize_t
 				if (STp->block_size != 0)
 					transfer *= STp->block_size;
 				if (transfer <= do_count) {
-					filp->f_pos += do_count - transfer;
+					pos += do_count - transfer;
 					count -= do_count - transfer;
 					if (STps->drv_block >= 0) {
 						if (STp->block_size == 0 &&
@@ -1473,7 +1474,7 @@ static ssize_t
 				retval = total - count;
 			goto out;
 		}
-		filp->f_pos += do_count;
+		pos += do_count;
 		b_point += do_count;
 		count -= do_count;
 		if (STps->drv_block >= 0) {
@@ -1492,7 +1493,7 @@ static ssize_t
 			retval = i;
 			goto out;
 		}
-		filp->f_pos += count;
+		pos += count;
 		count = 0;
 	}
 
@@ -1539,6 +1540,7 @@ static ssize_t
 	retval = total;
 
  out:
+	*ppos = pos;
 	if (SRpnt != NULL)
 		scsi_release_request(SRpnt);
 	up(&STp->lock);
@@ -1731,6 +1733,7 @@ static ssize_t
 	ST_mode *STm;
 	ST_partstat *STps;
 	int dev = TAPE_NR(inode->i_rdev);
+	loff_t pos = *ppos;
 
 	read_lock(&st_dev_arr_lock);
 	STp = scsi_tapes[dev];
@@ -1875,7 +1878,7 @@ static ssize_t
 				retval = i;
 				goto out;
 			}
-			filp->f_pos += transfer;
+			pos += transfer;
 			buf += transfer;
 			total += transfer;
 		}
@@ -1905,6 +1908,7 @@ static ssize_t
 	retval = total;
 
  out:
+	*ppos = pos;
 	if (SRpnt != NULL) {
 		scsi_release_request(SRpnt);
 		SRpnt = NULL;
diff -urNp linux-2.4.20/drivers/usb/brlvger.c linux-2.4.20.SUSE/drivers/usb/brlvger.c
--- linux-2.4.20/drivers/usb/brlvger.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/usb/brlvger.c	2004-07-23 15:43:53.477870693 +0200
@@ -596,6 +596,9 @@ brlvger_write(struct file *file, const c
 
 	off = *pos;
 
+	if (off < 0)
+		return -EINVAL;
+
 	if(off > priv->plength)
 		return -ESPIPE;;
 
diff -urNp linux-2.4.20/drivers/usb/devio.c linux-2.4.20.SUSE/drivers/usb/devio.c
--- linux-2.4.20/drivers/usb/devio.c	2004-07-23 15:42:57.363133868 +0200
+++ linux-2.4.20.SUSE/drivers/usb/devio.c	2004-07-23 15:43:53.478870706 +0200
@@ -80,7 +80,7 @@ static ssize_t usbdev_read(struct file *
 	struct dev_state *ps = (struct dev_state *)file->private_data;
 	ssize_t ret = 0;
 	unsigned len;
-	loff_t pos;
+	loff_t pos, last;
 	int i;
 
 	pos = *ppos;
@@ -102,37 +102,38 @@ static ssize_t usbdev_read(struct file *
 			goto err;
 		}
 
-		*ppos += len;
+		pos += len;
 		buf += len;
 		nbytes -= len;
 		ret += len;
 	}
 
-	pos = sizeof(struct usb_device_descriptor);
+	last = sizeof(struct usb_device_descriptor);
 	for (i = 0; nbytes && i < ps->dev->descriptor.bNumConfigurations; i++) {
 		struct usb_config_descriptor *config =
 			(struct usb_config_descriptor *)ps->dev->rawdescriptors[i];
 		unsigned int length = le16_to_cpu(config->wTotalLength);
 
-		if (*ppos < pos + length) {
-			len = length - (*ppos - pos);
+		if (pos < last + length) {
+			len = length - (pos - last);
 			if (len > nbytes)
 				len = nbytes;
 
 			if (copy_to_user(buf,
-			    ps->dev->rawdescriptors[i] + (*ppos - pos), len)) {
+			    ps->dev->rawdescriptors[i] + (pos - last), len)) {
 				ret = -EFAULT;
 				goto err;
 			}
 
-			*ppos += len;
+			pos += len;
 			buf += len;
 			nbytes -= len;
 			ret += len;
 		}
 
-		pos += length;
+		last += length;
 	}
+	*ppos = pos;
 
 err:
 	up_read(&ps->devsem);
diff -urNp linux-2.4.20/drivers/usb/drivers.c linux-2.4.20.SUSE/drivers/usb/drivers.c
--- linux-2.4.20/drivers/usb/drivers.c	2000-04-27 00:22:55.000000000 +0200
+++ linux-2.4.20.SUSE/drivers/usb/drivers.c	2004-07-23 15:43:53.478870706 +0200
@@ -52,9 +52,10 @@ static ssize_t usb_driver_read(struct fi
 	struct list_head *tmp = usb_driver_list.next;
 	char *page, *start, *end;
 	ssize_t ret = 0;
-	unsigned int pos, len;
+	loff_t n = *ppos;
+	unsigned int pos = n, len;
 
-	if (*ppos < 0)
+	if (pos != n)
 		return -EINVAL;
 	if (nbytes <= 0)
 		return 0;
@@ -64,7 +65,6 @@ static ssize_t usb_driver_read(struct fi
                 return -ENOMEM;
 	start = page;
 	end = page + (PAGE_SIZE - 100);
-	pos = *ppos;
 	for (; tmp != &usb_driver_list; tmp = tmp->next) {
 		struct usb_driver *driver = list_entry(tmp, struct usb_driver, driver_list);
 		int minor = driver->fops ? driver->minor : -1;
@@ -88,7 +88,7 @@ static ssize_t usb_driver_read(struct fi
 		if (copy_to_user(buf, page + pos, len))
 			ret = -EFAULT;
 		else
-			*ppos += len;
+			*ppos = pos + len;
 	}
 	free_page((unsigned long)page);
 	return ret;
diff -urNp linux-2.4.20/drivers/usb/uhci-debug.h linux-2.4.20.SUSE/drivers/usb/uhci-debug.h
--- linux-2.4.20/drivers/usb/uhci-debug.h	2001-11-22 20:49:54.000000000 +0100
+++ linux-2.4.20.SUSE/drivers/usb/uhci-debug.h	2004-07-23 15:54:27.438186943 +0200
@@ -530,16 +530,14 @@ static ssize_t uhci_proc_read(struct fil
 			loff_t *ppos)
 {
 	struct uhci_proc *up = file->private_data;
-	unsigned int pos;
+	loff_t n = *ppos;
+	unsigned int pos = n;
 	unsigned int size;
 
-	pos = *ppos;
 	size = up->size;
-	if (pos >= size)
+	if (pos != n || pos >= size)
 		return 0;
-	if (nbytes >= size)
-		nbytes = size;
-	if (pos + nbytes > size)
+	if (nbytes > size - pos)
 		nbytes = size - pos;
 
 	if (!access_ok(VERIFY_WRITE, buf, nbytes))
@@ -547,7 +545,7 @@ static ssize_t uhci_proc_read(struct fil
 
 	copy_to_user(buf, up->data + pos, nbytes);
 
-	*ppos += nbytes;
+	*ppos = pos + nbytes;
 
 	return nbytes;
 }
diff -urNp linux-2.4.20/drivers/video/fbmem.c linux-2.4.20.SUSE/drivers/video/fbmem.c
--- linux-2.4.20/drivers/video/fbmem.c	2004-07-23 15:43:09.735296333 +0200
+++ linux-2.4.20.SUSE/drivers/video/fbmem.c	2004-07-23 15:44:12.339118328 +0200
@@ -390,7 +390,7 @@ static int fbmem_read_proc(char *buf, ch
 static ssize_t
 fb_read(struct file *file, char *buf, size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	loff_t p = *ppos;
 	struct inode *inode = file->f_dentry->d_inode;
 	int fbidx = GET_FB_IDX(inode->i_rdev);
 	struct fb_info *info = registered_fb[fbidx];
@@ -401,11 +401,11 @@ fb_read(struct file *file, char *buf, si
 		return -ENODEV;
 
 	fb->fb_get_fix(&fix,PROC_CONSOLE(info), info);
+	if (p < 0)
+		return -EINVAL;
 	if (p >= fix.smem_len)
 	    return 0;
-	if (count >= fix.smem_len)
-	    count = fix.smem_len;
-	if (count + p > fix.smem_len)
+	if (count > fix.smem_len - p)
 		count = fix.smem_len - p;
 	if (count) {
 	    char *base_addr;
@@ -414,7 +414,7 @@ fb_read(struct file *file, char *buf, si
 	    count -= copy_to_user(buf, base_addr+p, count);
 	    if (!count)
 		return -EFAULT;
-	    *ppos += count;
+	    *ppos = p + count;
 	}
 	return count;
 }
@@ -422,7 +422,7 @@ fb_read(struct file *file, char *buf, si
 static ssize_t
 fb_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	loff_t p = *ppos;
 	struct inode *inode = file->f_dentry->d_inode;
 	int fbidx = GET_FB_IDX(inode->i_rdev);
 	struct fb_info *info = registered_fb[fbidx];
@@ -434,12 +434,12 @@ fb_write(struct file *file, const char *
 		return -ENODEV;
 
 	fb->fb_get_fix(&fix, PROC_CONSOLE(info), info);
+	if (p < 0)
+		return -EINVAL;
 	if (p > fix.smem_len)
 	    return -ENOSPC;
-	if (count >= fix.smem_len)
-	    count = fix.smem_len;
 	err = 0;
-	if (count + p > fix.smem_len) {
+	if (count > fix.smem_len - p) {
 	    count = fix.smem_len - p;
 	    err = -ENOSPC;
 	}
@@ -448,7 +448,7 @@ fb_write(struct file *file, const char *
 
 	    base_addr = info->disp->screen_base;
 	    count -= copy_from_user(base_addr+p, buf, count);
-	    *ppos += count;
+	    *ppos = p + count;
 	    err = -EFAULT;
 	}
 	if (count)
diff -urNp linux-2.4.20/fs/devfs/base.c linux-2.4.20.SUSE/fs/devfs/base.c
--- linux-2.4.20/fs/devfs/base.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20.SUSE/fs/devfs/base.c	2004-07-23 15:44:12.343118380 +0200
@@ -3312,7 +3312,7 @@ static ssize_t devfsd_read (struct file 
 {
     int done = FALSE;
     int ival;
-    loff_t pos, devname_offset, tlen, rpos;
+    loff_t pos, devname_offset, tlen, rpos, old_pos;
     devfs_handle_t de;
     struct devfsd_buf_entry *entry;
     struct fs_info *fs_info = file->f_dentry->d_inode->i_sb->u.generic_sbp;
@@ -3363,8 +3363,8 @@ static ssize_t devfsd_read (struct file 
     info->namelen = DEVFS_PATHLEN - pos - 1;
     if (info->mode == 0) info->mode = de->mode;
     devname_offset = info->devname - (char *) info;
-    rpos = *ppos;
-    if (rpos < devname_offset)
+    old_pos = rpos = *ppos;
+    if (rpos >= 0 && rpos < devname_offset)
     {
 	/*  Copy parts of the header  */
 	tlen = devname_offset - rpos;
@@ -3390,7 +3390,7 @@ static ssize_t devfsd_read (struct file 
 	}
 	rpos += tlen;
     }
-    tlen = rpos - *ppos;
+    tlen = rpos - old_pos;
     if (done)
     {
 	devfs_handle_t parent;
@@ -3504,16 +3504,17 @@ static ssize_t stat_read (struct file *f
 			  loff_t *ppos)
 {
     ssize_t num;
+    loff_t n = *ppos;
     char txt[80];
 
     num = sprintf (txt, "Number of entries: %u  number of bytes: %u\n",
 		   stat_num_entries, stat_num_bytes) + 1;
     /*  Can't seek (pread) on this device  */
     if (ppos != &file->f_pos) return -ESPIPE;
-    if (*ppos >= num) return 0;
-    if (*ppos + len > num) len = num - *ppos;
-    if ( copy_to_user (buf, txt + *ppos, len) ) return -EFAULT;
-    *ppos += len;
+    if (n != (unsigned)n || n >= num) return 0;
+    if (len > num - n) len = num - n;
+    if ( copy_to_user (buf, txt + n, len) ) return -EFAULT;
+    *ppos = n + len;
     return len;
 }   /*  End Function stat_read  */
 #endif
diff -urNp linux-2.4.20/fs/hfs/file.c linux-2.4.20.SUSE/fs/hfs/file.c
--- linux-2.4.20/fs/hfs/file.c	2002-02-25 20:38:08.000000000 +0100
+++ linux-2.4.20.SUSE/fs/hfs/file.c	2004-07-23 15:44:12.344118394 +0200
@@ -150,7 +150,7 @@ static hfs_rwret_t hfs_file_read(struct 
 		return -EINVAL;
 	}
 	pos = *ppos;
-	if (pos >= HFS_FORK_MAX) {
+	if (pos < 0 || pos >= HFS_FORK_MAX) {
 		return 0;
 	}
 	size = inode->i_size;
@@ -167,7 +167,7 @@ static hfs_rwret_t hfs_file_read(struct 
 	}
 	if ((read = hfs_do_read(inode, HFS_I(inode)->fork, pos,
 				buf, left, filp->f_reada != 0)) > 0) {
-	        *ppos += read;
+	        *ppos = pos + read;
 		filp->f_reada = 1;
 	}
 
@@ -197,7 +197,7 @@ static hfs_rwret_t hfs_file_write(struct
 
 	pos = (filp->f_flags & O_APPEND) ? inode->i_size : *ppos;
 
-	if (pos >= HFS_FORK_MAX) {
+	if (pos < 0 || pos >= HFS_FORK_MAX) {
 		return 0;
 	}
 	if (count > HFS_FORK_MAX) {
@@ -207,8 +207,8 @@ static hfs_rwret_t hfs_file_write(struct
 	        pos += written;
 
 	*ppos = pos;
-	if (*ppos > inode->i_size) {
-	        inode->i_size = *ppos;
+	if (pos > inode->i_size) {
+	        inode->i_size = pos;
 		mark_inode_dirty(inode);
 	}
 
diff -urNp linux-2.4.20/fs/hfs/file_cap.c linux-2.4.20.SUSE/fs/hfs/file_cap.c
--- linux-2.4.20/fs/hfs/file_cap.c	2001-09-10 16:31:25.000000000 +0200
+++ linux-2.4.20.SUSE/fs/hfs/file_cap.c	2004-07-23 15:44:12.345118407 +0200
@@ -191,7 +191,7 @@ static hfs_rwret_t cap_info_write(struct
 				  hfs_rwarg_t count, loff_t *ppos)
 {
         struct inode *inode = filp->f_dentry->d_inode;
-	hfs_u32 pos;
+	hfs_u32 pos, end;
 
 	if (!S_ISREG(inode->i_mode)) {
 		hfs_warn("hfs_file_write: mode = %07o\n", inode->i_mode);
@@ -207,14 +207,14 @@ static hfs_rwret_t cap_info_write(struct
 		return 0;
 	}
 
-	*ppos += count;
-	if (*ppos > HFS_FORK_MAX) {
-		*ppos = HFS_FORK_MAX;
+	end = pos + count;
+	if (end > HFS_FORK_MAX) {
+		end = HFS_FORK_MAX;
 		count = HFS_FORK_MAX - pos;
 	}
 
-	if (*ppos > inode->i_size)
-	        inode->i_size = *ppos;
+	if (end > inode->i_size)
+	        inode->i_size = end;
 
 	/* Only deal with the part we store in memory */
 	if (pos < sizeof(struct hfs_cap_info)) {
@@ -272,6 +272,7 @@ static hfs_rwret_t cap_info_write(struct
 		}
 	}
 
+	*ppos = end;
 	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 	mark_inode_dirty(inode);
 	return count;
diff -urNp linux-2.4.20/fs/hfs/file_hdr.c linux-2.4.20.SUSE/fs/hfs/file_hdr.c
--- linux-2.4.20/fs/hfs/file_hdr.c	2001-08-12 19:56:56.000000000 +0200
+++ linux-2.4.20.SUSE/fs/hfs/file_hdr.c	2004-07-23 15:44:12.346118420 +0200
@@ -384,7 +384,7 @@ static hfs_rwret_t hdr_read(struct file 
 	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
 	const struct hfs_hdr_layout *layout;
 	off_t start, length, offset;
-	off_t pos = *ppos;
+	loff_t pos = *ppos;
 	int left, lcv, read = 0;
 
 	if (!S_ISREG(inode->i_mode)) {
@@ -399,7 +399,7 @@ static hfs_rwret_t hdr_read(struct file 
 	}
 
 	/* Adjust count to fit within the bounds of the file */
-	if ((pos >= inode->i_size) || (count <= 0)) {
+	if (pos != (unsigned)pos || pos >= inode->i_size || count <= 0) {
 		return 0;
 	} else if (count > inode->i_size - pos) {
 		count = inode->i_size - pos;
@@ -646,7 +646,7 @@ static hfs_rwret_t hdr_write(struct file
 		hfs_warn("hfs_hdr_write: mode = %07o\n", inode->i_mode);
 		return -EINVAL;
 	}
-	if (count <= 0) {
+	if (count <= 0 || pos != (unsigned)pos) {
 		return 0;
 	}
 
diff -urNp linux-2.4.20/fs/openpromfs/inode.c linux-2.4.20.SUSE/fs/openpromfs/inode.c
--- linux-2.4.20/fs/openpromfs/inode.c	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.20.SUSE/fs/openpromfs/inode.c	2004-07-23 15:44:12.347118433 +0200
@@ -69,17 +69,18 @@ static ssize_t nodenum_read(struct file 
 			    size_t count, loff_t *ppos)
 {
 	struct inode *inode = file->f_dentry->d_inode;
+	loff_t pos = *ppos;
 	char buffer[10];
 	
 	if (count < 0 || !inode->u.generic_ip)
 		return -EINVAL;
 	sprintf (buffer, "%8.8x\n", (u32)(long)(inode->u.generic_ip));
-	if (file->f_pos >= 9)
+	if (pos != (unsigned)pos || pos >= 9)
 		return 0;
-	if (count > 9 - file->f_pos)
-		count = 9 - file->f_pos;
-	copy_to_user(buf, buffer + file->f_pos, count);
-	file->f_pos += count;
+	if (count > 9 - pos)
+		count = 9 - pos;
+	copy_to_user(buf, buffer + pos, count);
+	*ppos = pos + count;
 	return count;
 }
 
@@ -87,6 +88,7 @@ static ssize_t property_read(struct file
 			     size_t count, loff_t *ppos)
 {
 	struct inode *inode = filp->f_dentry->d_inode;
+	loff_t pos = *ppos;
 	int i, j, k;
 	u32 node;
 	char *p, *s;
@@ -94,7 +96,7 @@ static ssize_t property_read(struct file
 	openprom_property *op;
 	char buffer[64];
 	
-	if (filp->f_pos >= 0xffffff)
+	if (pos < 0 || pos >= 0xffffff)
 		return -EINVAL;
 	if (!filp->private_data) {
 		node = nodes[(u16)((long)inode->u.generic_ip)].node;
@@ -180,7 +182,7 @@ static ssize_t property_read(struct file
 	} else {
 		i = (op->len << 1) + 1;
 	}
-	k = filp->f_pos;
+	k = pos;
 	if (k >= i) return 0;
 	if (count > i - k) count = i - k;
 	if (op->flag & OPP_STRING) {
@@ -196,16 +198,16 @@ static ssize_t property_read(struct file
 			j = count;
 
 		if (j >= 0) {
-			copy_to_user(buf + k - filp->f_pos,
+			copy_to_user(buf + k - pos,
 				     op->value + k - 1, j);
 			count -= j;
 			k += j;
 		}
 
 		if (count)
-			__put_user('\'', &buf [k++ - filp->f_pos]);
+			__put_user('\'', &buf [k++ - pos]);
 		if (count > 1)
-			__put_user('\n', &buf [k++ - filp->f_pos]);
+			__put_user('\n', &buf [k++ - pos]);
 
 	} else if (op->flag & OPP_STRINGLIST) {
 		char *tmp;
@@ -273,47 +275,48 @@ static ssize_t property_read(struct file
 
 		if ((k < i - 1) && (k & 1)) {
 			sprintf (buffer, "%02x", *(op->value + (k >> 1)));
-			__put_user(buffer[1], &buf[k++ - filp->f_pos]);
+			__put_user(buffer[1], &buf[k++ - pos]);
 			count--;
 		}
 
 		for (; (count > 1) && (k < i - 1); k += 2) {
 			sprintf (buffer, "%02x", *(op->value + (k >> 1)));
-			copy_to_user (buf + k - filp->f_pos, buffer, 2);
+			copy_to_user (buf + k - pos, buffer, 2);
 			count -= 2;
 		}
 
 		if (count && (k < i - 1)) {
 			sprintf (buffer, "%02x", *(op->value + (k >> 1)));
-			__put_user(buffer[0], &buf[k++ - filp->f_pos]);
+			__put_user(buffer[0], &buf[k++ - pos]);
 			count--;
 		}
 
 		if (count)
-			__put_user('\n', &buf [k++ - filp->f_pos]);
+			__put_user('\n', &buf [k++ - pos]);
 	}
-	count = k - filp->f_pos;
-	filp->f_pos = k;
+	count = k - pos;
+	*ppos = k;
 	return count;
 }
 
 static ssize_t property_write(struct file *filp, const char *buf,
 			      size_t count, loff_t *ppos)
 {
+	loff_t pos = *ppos;
 	int i, j, k;
 	char *p;
 	u32 *q;
 	void *b;
 	openprom_property *op;
 	
-	if (filp->f_pos >= 0xffffff)
+	if (pos < 0 || pos >= 0xffffff)
 		return -EINVAL;
 	if (!filp->private_data) {
 		i = property_read (filp, NULL, 0, 0);
 		if (i)
 			return i;
 	}
-	k = filp->f_pos;
+	k = pos;
 	op = (openprom_property *)filp->private_data;
 	if (!(op->flag & OPP_STRING)) {
 		u32 *first, *last;
@@ -433,7 +436,8 @@ static ssize_t property_write(struct fil
 				op->len = i;
 		} else
 			op->len = i;
-		filp->f_pos += count;
+		pos += count;
+		*ppos = pos;
 	}
 write_try_string:
 	if (!(op->flag & OPP_BINARY)) {
@@ -450,7 +454,8 @@ write_try_string:
 				op->flag |= OPP_QUOTED;
 				buf++;
 				count--;
-				filp->f_pos++;
+				pos++;
+				*ppos = pos;
 				if (!count) {
 					op->flag |= OPP_STRING;
 					return 1;
@@ -459,9 +464,9 @@ write_try_string:
 				op->flag |= OPP_NOTQUOTED;
 		}
 		op->flag |= OPP_STRING;
-		if (op->alloclen <= count + filp->f_pos) {
+		if (op->alloclen <= count + pos) {
 			b = kmalloc (sizeof (openprom_property)
-				     + 2 * (count + filp->f_pos), GFP_KERNEL);
+				     + 2 * (count + pos), GFP_KERNEL);
 			if (!b)
 				return -ENOMEM;
 			memcpy (b, filp->private_data,
@@ -469,14 +474,14 @@ write_try_string:
 				+ strlen (op->name) + op->alloclen);
 			memset (((char *)b) + sizeof (openprom_property)
 				+ strlen (op->name) + op->alloclen, 
-				0, 2*(count - filp->f_pos) - op->alloclen);
+				0, 2*(count - pos) - op->alloclen);
 			op = (openprom_property *)b;
-			op->alloclen = 2*(count + filp->f_pos);
+			op->alloclen = 2*(count + pos);
 			b = filp->private_data;
 			filp->private_data = (void *)op;
 			kfree (b);
 		}
-		p = op->value + filp->f_pos - ((op->flag & OPP_QUOTED) ? 1 : 0);
+		p = op->value + pos - ((op->flag & OPP_QUOTED) ? 1 : 0);
 		copy_from_user (p, buf, count);
 		op->flag |= OPP_DIRTY;
 		for (i = 0; i < count; i++, p++)
@@ -486,17 +491,19 @@ write_try_string:
 			}
 		if (i < count) {
 			op->len = p - op->value;
-			filp->f_pos += i + 1;
+			pos += i + 1;
+			*ppos = pos;
 			if ((p > op->value) && (op->flag & OPP_QUOTED)
 			    && (*(p - 1) == '\''))
 				op->len--;
 		} else {
 			if (p - op->value > op->len)
 				op->len = p - op->value;
-			filp->f_pos += count;
+			pos += count;
+			*ppos = pos;
 		}
 	}
-	return filp->f_pos - k;
+	return pos - k;
 }
 
 int property_release (struct inode *inode, struct file *filp)
diff -urNp linux-2.4.20/fs/proc/base.c linux-2.4.20.SUSE/fs/proc/base.c
--- linux-2.4.20/fs/proc/base.c	2004-07-23 15:43:04.768231109 +0200
+++ linux-2.4.20.SUSE/fs/proc/base.c	2004-07-23 15:44:12.349118459 +0200
@@ -337,6 +337,7 @@ static ssize_t proc_info_read(struct fil
 	ssize_t length;
 	ssize_t end;
 	struct task_struct *task = inode->u.proc_i.task;
+	loff_t pos = *ppos;
 
 	if (count > PROC_BLOCK_SIZE)
 		count = PROC_BLOCK_SIZE;
@@ -350,14 +351,14 @@ static ssize_t proc_info_read(struct fil
 		return length;
 	}
 	/* Static 4kB (or whatever) block capacity */
-	if (*ppos >= length) {
+	if (pos < 0 || pos >= length) {
 		free_page(page);
 		return 0;
 	}
-	if (count + *ppos > length)
-		count = length - *ppos;
-	end = count + *ppos;
-	copy_to_user(buf, (char *) page + *ppos, count);
+	if (count > length - pos)
+		count = length - pos;
+	end = count + pos;
+	copy_to_user(buf, (char *) page + pos, count);
 	*ppos = end;
 	free_page(page);
 	return count;
diff -urNp linux-2.4.20/fs/proc/generic.c linux-2.4.20.SUSE/fs/proc/generic.c
--- linux-2.4.20/fs/proc/generic.c	2004-07-23 15:43:04.441226815 +0200
+++ linux-2.4.20.SUSE/fs/proc/generic.c	2004-07-23 15:44:12.349118459 +0200
@@ -56,6 +56,7 @@ proc_file_read(struct file * file, char 
 	ssize_t	n, count;
 	char	*start;
 	struct proc_dir_entry * dp;
+	loff_t pos = *ppos;
 
 	dp = (struct proc_dir_entry *) inode->u.generic_ip;
 	if (!(page = (char*) __get_free_page(GFP_KERNEL)))
@@ -64,6 +65,8 @@ proc_file_read(struct file * file, char 
 	while ((nbytes > 0) && !eof)
 	{
 		count = MIN(PROC_BLOCK_SIZE, nbytes);
+		if ((unsigned)pos > INT_MAX)
+			break;
 
 		start = NULL;
 		if (dp->get_info) {
@@ -71,11 +74,11 @@ proc_file_read(struct file * file, char 
 			 * Handle backwards compatibility with the old net
 			 * routines.
 			 */
-			n = dp->get_info(page, &start, *ppos, count);
+			n = dp->get_info(page, &start, pos, count);
 			if (n < count)
 				eof = 1;
 		} else if (dp->read_proc) {
-			n = dp->read_proc(page, &start, *ppos,
+			n = dp->read_proc(page, &start, pos,
 					  count, &eof, dp->data);
 		} else
 			break;
@@ -84,8 +87,8 @@ proc_file_read(struct file * file, char 
 			/*
 			 * For proc files that are less than 4k
 			 */
-			start = page + *ppos;
-			n -= *ppos;
+			start = page + pos;
+			n -= pos;
 			if (n <= 0)
 				break;
 			if (n > count)
@@ -113,7 +116,8 @@ proc_file_read(struct file * file, char 
 			break;
 		}
 
-		*ppos += start < page ? (long)start : n; /* Move down the file */
+		pos += start < page ? (long)start : n; /* Move down the file */
+		*ppos = pos;
 		nbytes -= n;
 		buf += n;
 		retval += n;
diff -urNp linux-2.4.20/fs/proc/kcore.c linux-2.4.20.SUSE/fs/proc/kcore.c
--- linux-2.4.20/fs/proc/kcore.c	2004-07-23 15:43:13.113340691 +0200
+++ linux-2.4.20.SUSE/fs/proc/kcore.c	2004-07-23 15:44:12.350118472 +0200
@@ -96,8 +96,9 @@ static ssize_t read_kcore(struct file *f
 		if (copy_to_user(buf, (void *) (PAGE_OFFSET+p-PAGE_SIZE), count))
 			return -EFAULT;
 		read += count;
+		p += count;
 	}
-	*ppos += read;
+	*ppos = p;
 	return read;
 }
 #else /* CONFIG_KCORE_AOUT */
diff -urNp linux-2.4.20/fs/proc/proc_misc.c linux-2.4.20.SUSE/fs/proc/proc_misc.c
--- linux-2.4.20/fs/proc/proc_misc.c	2004-07-23 15:43:06.432252960 +0200
+++ linux-2.4.20.SUSE/fs/proc/proc_misc.c	2004-07-23 15:44:12.351118485 +0200
@@ -598,12 +598,13 @@ static int memory_read_proc(char *page, 
 static ssize_t read_profile(struct file *file, char *buf,
 			    size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	loff_t n = *ppos;
+	unsigned p = n;
 	ssize_t read;
 	char * pnt;
 	unsigned int sample_step = 1 << prof_shift;
 
-	if (p >= (prof_len+1)*sizeof(unsigned int))
+	if (p != n || p >= (prof_len+1)*sizeof(unsigned int))
 		return 0;
 	if (count > (prof_len+1)*sizeof(unsigned int) - p)
 		count = (prof_len+1)*sizeof(unsigned int) - p;
@@ -616,7 +617,7 @@ static ssize_t read_profile(struct file 
 	pnt = (char *)prof_buffer + p - sizeof(unsigned int);
 	copy_to_user(buf,(void *)pnt,count);
 	read += count;
-	*ppos += read;
+	*ppos = n + read;
 	return read;
 }
 
diff -urNp linux-2.4.20/fs/udf/file.c linux-2.4.20.SUSE/fs/udf/file.c
--- linux-2.4.20/fs/udf/file.c	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20.SUSE/fs/udf/file.c	2004-07-23 15:44:12.352118499 +0200
@@ -155,7 +155,8 @@ static ssize_t udf_file_write(struct fil
 {
 	ssize_t retval;
 	struct inode *inode = file->f_dentry->d_inode;
-	int err, pos;
+	int err;
+	loff_t pos;
 
 	if (UDF_I_ALLOCTYPE(inode) == ICBTAG_FLAG_AD_IN_ICB)
 	{
@@ -164,8 +165,11 @@ static ssize_t udf_file_write(struct fil
 		else
 			pos = *ppos;
 
-		if (inode->i_sb->s_blocksize < (udf_file_entry_alloc_offset(inode) +
-			pos + count))
+		if (pos < 0 || pos + count < pos)
+			return 0;
+
+		if (inode->i_sb->s_blocksize - udf_file_entry_alloc_offset(inode) <
+			pos + count)
 		{
 			udf_expand_file_adinicb(inode, pos + count, &err);
 			if (UDF_I_ALLOCTYPE(inode) == ICBTAG_FLAG_AD_IN_ICB)
--- linux-2.4.20/mm/shmem.c.orig	2004-08-12 12:40:01.000000000 +0200
+++ linux-2.4.20/mm/shmem.c	2004-08-12 13:52:01.000000000 +0200
@@ -921,14 +921,17 @@
 	struct inode *inode = filp->f_dentry->d_inode;
 	struct address_space *mapping = inode->i_mapping;
 	unsigned long index, offset;
-	int nr = 1;
+	loff_t pos = *ppos;
 
-	index = *ppos >> PAGE_CACHE_SHIFT;
-	offset = *ppos & ~PAGE_CACHE_MASK;
+	if (unlikely(pos < 0))
+		return;
 
-	while (nr && desc->count) {
+	index = pos >> PAGE_CACHE_SHIFT;
+	offset = pos & ~PAGE_CACHE_MASK;
+
+	for (;;) {
 		struct page *page;
-		unsigned long end_index, nr;
+		unsigned long end_index, nr, ret;
 
 		end_index = inode->i_size >> PAGE_CACHE_SHIFT;
 		if (index > end_index)
@@ -958,12 +961,14 @@
 		 * "pos" here (the actor routine has to update the user buffer
 		 * pointers and the remaining count).
 		 */
-		nr = file_read_actor(desc, page, offset, nr);
-		offset += nr;
+		ret = file_read_actor(desc, page, offset, nr);
+		offset += ret;
 		index += offset >> PAGE_CACHE_SHIFT;
 		offset &= ~PAGE_CACHE_MASK;
 	
 		page_cache_release(page);
+		if (ret != nr || !desc->count)
+			break;
 	}
 
 	*ppos = ((loff_t) index << PAGE_CACHE_SHIFT) + offset;
diff -urNp linux-2.4.20/net/8021q/vlanproc.c linux-2.4.20.SUSE/net/8021q/vlanproc.c
--- linux-2.4.20/net/8021q/vlanproc.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20.SUSE/net/8021q/vlanproc.c	2004-07-23 15:56:18.890647540 +0200
@@ -232,7 +232,9 @@ static ssize_t vlan_proc_read(struct fil
 	struct inode *inode = file->f_dentry->d_inode;
 	struct proc_dir_entry *dent;
 	char *page;
-	int pos, offs, len;
+	int pos, len;
+	loff_t n = *ppos;
+	unsigned offs = n;
 
 	if (count <= 0)
 		return 0;
@@ -249,13 +251,12 @@ static ssize_t vlan_proc_read(struct fil
 		return -ENOBUFS;
 
 	pos = dent->get_info(page, dent->data, 0, 0);
-	offs = file->f_pos;
-	if (offs < pos) {
+	if (offs == n && offs < pos) {
 		len = min_t(int, pos - offs, count);
 		if (copy_to_user(buf, (page + offs), len))
 			return -EFAULT;
 
-		file->f_pos += len;
+		*ppos = offs + len;
 	} else {
 		len = 0;
 	}
diff -urNp linux-2.4.20/net/atm/br2684.c linux-2.4.20.SUSE/net/atm/br2684.c
--- linux-2.4.20/net/atm/br2684.c	2002-08-03 02:39:46.000000000 +0200
+++ linux-2.4.20.SUSE/net/atm/br2684.c	2004-07-23 15:44:12.356118551 +0200
@@ -729,6 +729,7 @@ static ssize_t br2684_proc_read(struct f
 	unsigned long page;
 	int len = 0, x, left;
+	loff_t n = *pos;
 	page = get_free_page(GFP_KERNEL);
 	if (!page)
 		return -ENOMEM;
 	left = PAGE_SIZE - 256;
@@ -736,7 +737,7 @@ static ssize_t br2684_proc_read(struct f
 		left = count;
 	read_lock(&devs_lock);
 	for (;;) {
-		x = br2684_proc_engine(*pos, &((char *) page)[len]);
+		x = br2684_proc_engine(n, &((char *) page)[len]);
 		if (x == 0)
 			break;
 		if (x > left)
@@ -751,11 +752,12 @@ static ssize_t br2684_proc_read(struct f
 		}
 		len += x;
 		left -= x;
-		(*pos)++;
+		n++;
 		if (left < 256)
 			break;
 	}
 	read_unlock(&devs_lock);
+	*pos = n;
 	if (len > 0 && copy_to_user(buf, (char *) page, len))
 		len = -EFAULT;
 	free_page(page);
diff -urNp linux-2.4.20/net/atm/mpoa_proc.c linux-2.4.20.SUSE/net/atm/mpoa_proc.c
--- linux-2.4.20/net/atm/mpoa_proc.c	2001-07-04 20:50:38.000000000 +0200
+++ linux-2.4.20.SUSE/net/atm/mpoa_proc.c	2004-07-23 15:44:12.357118564 +0200
@@ -109,6 +109,7 @@ static ssize_t proc_mpc_read(struct file
 	eg_cache_entry *eg_entry;
 	struct timeval now;
 	unsigned char ip_string[16];
+	loff_t n = *pos;
 	if(count == 0)
 	        return 0;
 	page = get_free_page(GFP_KERNEL);
@@ -150,14 +151,14 @@ static ssize_t proc_mpc_read(struct file
 		mpc = mpc->next;
 	}
 
-	if (*pos >= length) length = 0;
+	if (n != (unsigned)n || n >= length) length = 0;
 	else {
-	  if ((count + *pos) > length) count = length - *pos;
+	  if (count > length - n) count = length - n;
 	  if (copy_to_user(buff, (char *)page , count)) {
  		  free_page(page);
 		  return -EFAULT;
           }
-	  *pos += count;
+	  *pos = n + count;
 	}
 
  	free_page(page);
diff -urNp linux-2.4.20/net/wanrouter/wanproc.c linux-2.4.20.SUSE/net/wanrouter/wanproc.c
--- linux-2.4.20/net/wanrouter/wanproc.c	2001-09-10 16:58:35.000000000 +0200
+++ linux-2.4.20.SUSE/net/wanrouter/wanproc.c	2004-07-23 15:44:12.359118590 +0200
@@ -243,7 +243,9 @@ typedef struct wan_stat_entry
 		struct inode *inode = file->f_dentry->d_inode;
 		struct proc_dir_entry* dent;
 		char* page;
-		int pos, offs, len;
+		int pos, len;
+		loff_t n = *ppos;
+		unsigned offs = n;
 
 		if (count <= 0)
 			return 0;
@@ -257,14 +259,13 @@ typedef struct wan_stat_entry
 			return -ENOBUFS;
 			
 		pos = dent->get_info(page, dent->data, 0, 0);
-		offs = file->f_pos;
-		if (offs < pos) {
+		if (offs == n && offs < pos) {
 			len = min_t(unsigned int, pos - offs, count);
 			if (copy_to_user(buf, (page + offs), len)) {
 				kfree(page);
 				return -EFAULT;
 			}
-			file->f_pos += len;
+			*ppos = offs + len;
 		}
 		else
 			len = 0;
