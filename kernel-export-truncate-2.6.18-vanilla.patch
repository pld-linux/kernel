 include/linux/mm.h |    2 ++
 mm/truncate.c      |    4 ++--
 2 files changed, 4 insertions(+), 2 deletions(-)

Index: linux-2.6/include/linux/mm.h
===================================================================
--- linux-2.6.orig/include/linux/mm.h	2006-07-06 23:41:48.000000000 +0800
+++ linux-2.6/include/linux/mm.h	2006-07-15 12:55:07.000000000 +0800
@@ -529,6 +529,8 @@ static __always_inline void *lowmem_page
 {
 	return __va(page_to_pfn(page) << PAGE_SHIFT);
 }
+/* truncate.c */
+extern void truncate_complete_page(struct address_space *mapping,struct page *);
 
 #if defined(CONFIG_HIGHMEM) && !defined(WANT_PAGE_VIRTUAL)
 #define HASHED_PAGE_VIRTUAL
Index: linux-2.6/mm/truncate.c
===================================================================
--- linux-2.6.orig/mm/truncate.c	2006-06-24 14:22:39.000000000 +0800
+++ linux-2.6/mm/truncate.c	2006-07-15 12:55:07.000000000 +0800
@@ -33,7 +33,7 @@ static inline void truncate_partial_page
  * its lock, b) when a concurrent invalidate_inode_pages got there first and
  * c) when tmpfs swizzles a page between a tmpfs inode and swapper_space.
  */
-static void
+void
 truncate_complete_page(struct address_space *mapping, struct page *page)
 {
 	if (page->mapping != mapping)
@@ -48,7 +48,7 @@ truncate_complete_page(struct address_sp
 	remove_from_page_cache(page);
 	page_cache_release(page);	/* pagecache ref */
 }
-
+EXPORT_SYMBOL_GPL(truncate_complete_page);
 /*
  * This is for invalidate_inode_pages().  That function can be called at
  * any time, and is not supposed to throw away dirty pages.  But pages can
