diff -urN linux-2.4.22/Documentation/Configure.help linux-2.4.22-ide/Documentation/Configure.help
--- linux-2.4.22/Documentation/Configure.help	Sun Sep 21 01:48:11 2003
+++ linux-2.4.22-ide/Documentation/Configure.help	Sun Sep 21 01:50:17 2003
@@ -1170,6 +1170,15 @@
   Say Y here if you have an IDE controller which uses any of these
   chipsets: CMD643, CMD646 and CMD648.
 
+Compaq Triflex IDE support
+CONFIG_BLK_DEV_TRIFLEX
+  Say Y here if you have a Compaq Triflex IDE controller, such
+  as those commonly found on Compaq Pentium-Pro systems
+
+  If you want to compile it as a module, say M here and read
+  <file:Documentation/modules.txt>.  The module will be called
+  triflex.o.
+
 CY82C693 chipset support
 CONFIG_BLK_DEV_CY82C693
   This driver adds detection and support for the CY82C693 chipset
@@ -1239,11 +1248,26 @@
   This is a driver for the OPTi 82C621 EIDE controller.
   Please read the comments at the top of <file:drivers/ide/pci/opti621.c>.
 
+National SCx200 chipset support
+CONFIG_BLK_DEV_SC1200
+  This driver adds support for the built in IDE on the National
+  SCx200 series of embedded x86 "Geode" systems
+
+  If you want to compile it as a module, say M here and read
+  <file:Documentation/modules.txt>.  The module will be called
+  sc1200.o.
+
 ServerWorks OSB4/CSB5 chipset support
 CONFIG_BLK_DEV_SVWKS
   This driver adds PIO/(U)DMA support for the ServerWorks OSB4/CSB5
   chipsets.
 
+SGI IOC4 chipset support
+CONFIG_BLK_DEV_SGIIOC4
+  This driver adds PIO & MultiMode DMA-2 support for the SGI IOC4
+  chipset.  Please say Y here, if you have an Altix System from
+  Silicon Graphics Inc.
+
 Intel PIIXn chipsets support
 CONFIG_BLK_DEV_PIIX
   This driver adds PIO mode setting and tuning for all PIIX IDE
@@ -1270,20 +1294,23 @@
 
   If unsure, say N.
 
-PROMISE PDC20246/PDC20262/PDC20265/PDC20267/PDC20268 support
+PROMISE PDC20246/PDC20262/PDC20265/PDC20267 support
 CONFIG_BLK_DEV_PDC202XX_OLD
-  Promise Ultra33 or PDC20246
-  Promise Ultra66 or PDC20262
-  Promise Ultra100 or PDC20265/PDC20267/PDC20268
+  Promise Ultra 33 [PDC20246]
+  Promise Ultra 66 [PDC20262]
+  Promise FastTrak 66 [PDC20263]
+  Promise MB Ultra 100 [PDC20265]
+  Promise Ultra 100 [PDC20267]
 
   This driver adds up to 4 more EIDE devices sharing a single
-  interrupt. This add-on card is a bootable PCI UDMA controller. Since
+  interrupt. This device is a bootable PCI UDMA controller. Since
   multiple cards can be installed and there are BIOS ROM problems that
-  happen if the BIOS revisions of all installed cards (three-max) do
+  happen if the BIOS revisions of all installed cards (max of three) do
   not match, the driver attempts to do dynamic tuning of the chipset
-  at boot-time for max-speed.  Ultra33 BIOS 1.25 or newer is required
+  at boot-time for max speed.  Ultra33 BIOS 1.25 or newer is required
   for more than one card. This card may require that you say Y to
-  "Special UDMA Feature".
+  "Special UDMA Feature" to force UDMA mode for connected UDMA capable
+  disk drives.
 
   If you say Y here, you need to say Y to "Use DMA by default when
   available" as well.
@@ -1293,7 +1320,30 @@
 
   If unsure, say N.
 
-Special UDMA Feature
+PROMISE PDC202{68|69|70|71|75|76|77} support
+CONFIG_BLK_DEV_PDC202XX_NEW
+  Promise Ultra 100 TX2 [PDC20268]
+  Promise Ultra 133 PTX2 [PDC20269]
+  Promise FastTrak LP/TX2/TX4 [PDC20270]
+  Promise FastTrak TX2000 [PDC20271]
+  Promise MB Ultra 133 [PDC20275]
+  Promise MB FastTrak 133 [PDC20276]
+  Promise FastTrak 133 [PDC20277]
+
+  This driver adds up to 4 more EIDE devices sharing a single
+  interrupt. This device is a bootable PCI UDMA controller. Since
+  multiple cards can be installed and there are BIOS ROM problems that
+  happen if the BIOS revisions of all installed cards (max of five) do
+  not match, the driver attempts to do dynamic tuning of the chipset
+  at boot-time for max speed.  Ultra33 BIOS 1.25 or newer is required
+  for more than one card. 
+
+  If you say Y here, you need to say Y to "Use DMA by default when
+  available" as well.
+
+  If unsure, say N.
+
+Override-Enable UDMA for Promise Controllers
 CONFIG_PDC202XX_BURST
   This option causes the pdc202xx driver to enable UDMA modes on the
   PDC202xx even when the PDC202xx BIOS has not done so.
@@ -1303,14 +1353,24 @@
   used successfully on a PDC20265/Ultra100, allowing use of UDMA modes
   when the PDC20265 BIOS has been disabled (for faster boot up).
 
-  Please read the comments at the top of
-  <file:drivers/ide/pci/pdc202xx_old.c>.
-
   If unsure, say N.
 
-Special FastTrak Feature
+Use FastTrak RAID capable device as plain IDE controller
 CONFIG_PDC202XX_FORCE
-  For FastTrak enable overriding BIOS.
+  Setting this option causes the kernel to use your Promise IDE disk
+  controller as an ordinary IDE controller, rather than as a FastTrak
+  RAID controller. RAID is a system for using multiple physical disks
+  as one virtual disk.
+
+  You need to say Y here if you have a PDC20276 IDE interface but either
+  you do not have a RAID disk array, or you wish to use the Linux
+  internal RAID software (/dev/mdX).
+
+  You need to say N here if you wish to use your Promise controller to
+  control a FastTrak RAID disk array, and you you must also say Y to
+  CONFIG_BLK_DEV_ATARAID_PDC.
+
+  If unsure, say Y.
 
 SiS5513 chipset support
 CONFIG_BLK_DEV_SIS5513
diff -urN linux-2.4.22/drivers/ide/Config.in linux-2.4.22-ide/drivers/ide/Config.in
--- linux-2.4.22/drivers/ide/Config.in	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/Config.in	Sun Sep 21 01:50:18 2003
@@ -27,8 +27,6 @@
 
    comment 'IDE chipset support/bugfixes'
    if [ "$CONFIG_BLK_DEV_IDE" != "n" ]; then
-      dep_bool '  CMD640 chipset bugfix/support' CONFIG_BLK_DEV_CMD640 $CONFIG_X86
-      dep_bool '    CMD640 enhanced support' CONFIG_BLK_DEV_CMD640_ENHANCED $CONFIG_BLK_DEV_CMD640
       dep_bool '  ISA-PNP EIDE support' CONFIG_BLK_DEV_ISAPNP $CONFIG_ISAPNP
       if [ "$CONFIG_PCI" = "y" ]; then
 	 bool '  PCI IDE chipset support' CONFIG_BLK_DEV_IDEPCI
@@ -49,6 +47,8 @@
 	    dep_mbool    '      ALI M15x3 WDC support (DANGEROUS)' CONFIG_WDC_ALI15X3 $CONFIG_BLK_DEV_ALI15X3
 	    dep_tristate '    AMD and nVidia IDE support' CONFIG_BLK_DEV_AMD74XX $CONFIG_BLK_DEV_IDEDMA_PCI
 	    dep_mbool    '      AMD Viper ATA-66 Override' CONFIG_AMD74XX_OVERRIDE $CONFIG_BLK_DEV_AMD74XX
+	    dep_tristate '    CMD640 chipset bugfix/support' CONFIG_BLK_DEV_CMD640 $CONFIG_X86
+	    dep_mbool    '      CMD640 enhanced support' CONFIG_BLK_DEV_CMD640_ENHANCED $CONFIG_BLK_DEV_CMD640
 	    dep_tristate '    CMD64{3|6|8|9} chipset support' CONFIG_BLK_DEV_CMD64X $CONFIG_BLK_DEV_IDEDMA_PCI
 	    dep_tristate '    Compaq Triflex IDE support' CONFIG_BLK_DEV_TRIFLEX $CONFIG_BLK_DEV_IDEDMA_PCI
 	    dep_tristate '    CY82C693 chipset support' CONFIG_BLK_DEV_CY82C693 $CONFIG_BLK_DEV_IDEDMA_PCI
@@ -71,6 +71,9 @@
 	    dep_tristate '    RZ1000 chipset bugfix/support' CONFIG_BLK_DEV_RZ1000 $CONFIG_X86
 	    dep_tristate '    SCx200 chipset support' CONFIG_BLK_DEV_SC1200 $CONFIG_BLK_DEV_IDEDMA_PCI
 	    dep_tristate '    ServerWorks OSB4/CSB5/CSB6 chipsets support' CONFIG_BLK_DEV_SVWKS $CONFIG_BLK_DEV_IDEDMA_PCI
+	    if [ "$CONFIG_IA64" = "y" ]; then
+	        dep_tristate '    SGI IOC4 chipset support' CONFIG_BLK_DEV_SGIIOC4 $CONFIG_BLK_DEV_IDEDMA_PCI
+	    fi
 	    dep_tristate '    Silicon Image chipset support' CONFIG_BLK_DEV_SIIMAGE $CONFIG_BLK_DEV_IDEDMA_PCI
 	    dep_tristate '    SiS5513 chipset support' CONFIG_BLK_DEV_SIS5513 $CONFIG_BLK_DEV_IDEDMA_PCI $CONFIG_X86
 	    dep_tristate '    SLC90E66 chipset support' CONFIG_BLK_DEV_SLC90E66 $CONFIG_BLK_DEV_IDEDMA_PCI
diff -urN linux-2.4.22/drivers/ide/Makefile linux-2.4.22-ide/drivers/ide/Makefile
--- linux-2.4.22/drivers/ide/Makefile	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/Makefile	Sun Sep 21 01:50:18 2003
@@ -48,8 +48,6 @@
 
 obj-$(CONFIG_BLK_DEV_IDE)		+= ide-core.o
 
-obj-$(CONFIG_BLK_DEV_IDE_SIBYTE)	+= ide-sibyte.o
-
 ifeq ($(CONFIG_BLK_DEV_IDE),y)
   obj-y		+= legacy/idedriver-legacy.o
   obj-y		+= ppc/idedriver-ppc.o
diff -urN linux-2.4.22/drivers/ide/ide-cd.c linux-2.4.22-ide/drivers/ide/ide-cd.c
--- linux-2.4.22/drivers/ide/ide-cd.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/ide-cd.c	Sun Sep 21 01:50:18 2003
@@ -2231,7 +2231,7 @@
 	minor = (drive->select.b.unit) << PARTN_BITS;
 	dev = MKDEV(HWIF(drive)->major, minor);
 	stat = cdrom_get_last_written(dev, &toc->capacity);
-	if (stat)
+	if (stat || toc->capacity == 0)
 		stat = cdrom_read_capacity(drive, &toc->capacity, sense);
 	if (stat)
 		toc->capacity = 0x1fffff;
@@ -3262,7 +3262,7 @@
 		}
 		if (ide_register_subdriver(drive, 
 				&ide_cdrom_driver, IDE_SUBDRIVER_VERSION)) {
-			printk("%s: Failed to register the driver with "
+			printk("ide-cd: %s: Failed to register the driver with "
 				"ide.c\n", drive->name);
 			kfree(info);
 			continue;
diff -urN linux-2.4.22/drivers/ide/ide-default.c linux-2.4.22-ide/drivers/ide/ide-default.c
--- linux-2.4.22/drivers/ide/ide-default.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/ide-default.c	Sun Sep 21 01:50:18 2003
@@ -40,6 +40,21 @@
 {
 }
 
+static int idedefault_open(struct inode *inode, struct file *filp, ide_drive_t *drive)
+{
+	MOD_INC_USE_COUNT;
+	if(filp->f_flags & O_NDELAY)
+		return 0;
+	MOD_DEC_USE_COUNT;
+	drive->usage--;
+	return -ENXIO;
+}
+
+static void idedefault_release(struct inode *inode, struct file *filp, ide_drive_t *drive)
+{
+	MOD_DEC_USE_COUNT;
+}
+
 int idedefault_init (void);
 int idedefault_attach(ide_drive_t *drive);
 
@@ -56,6 +71,8 @@
 	supports_dsc_overlap:	0,
 	init:			idedefault_init,
 	attach:			idedefault_attach,
+	open:			idedefault_open,
+	release:		idedefault_release
 };
 
 static ide_module_t idedefault_module = {
diff -urN linux-2.4.22/drivers/ide/ide-disk.c linux-2.4.22-ide/drivers/ide/ide-disk.c
--- linux-2.4.22/drivers/ide/ide-disk.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/ide-disk.c	Sun Sep 21 01:50:18 2003
@@ -1,5 +1,5 @@
 /*
- *  linux/drivers/ide/ide-disk.c	Version 1.18	Mar 05, 2003
+ *  linux/drivers/ide/ide-disk.c	Version 1.18	Aug 16, 2003
  *
  *  Copyright (C) 1994-1998  Linus Torvalds & authors (see below)
  *  Copyright (C) 1998-2002  Linux ATA Developemt
@@ -41,9 +41,10 @@
  * Version 1.16		added suspend-resume-checkpower
  * Version 1.17		do flush on standy, do flush on ATA < ATA6
  *			fix wcache setup.
+ * Version 1.18		LBA48 clamping fixes
  */
 
-#define IDEDISK_VERSION	"1.17"
+#define IDEDISK_VERSION	"1.18"
 
 #undef REALLY_SLOW_IO		/* most systems can safely undef this */
 
@@ -561,11 +561,7 @@
 
 static task_ioreg_t get_command (ide_drive_t *drive, int cmd)
 {
-	int lba48bit = (drive->id->cfs_enable_2 & 0x0400) ? 1 : 0;
-
-#if 1
-	lba48bit = (drive->addressing == 1) ? 1 : 0;
-#endif
+	int lba48bit = (drive->addressing == 1) ? 1 : 0;
 
 	if ((cmd == READ) && (drive->using_dma))
 		return (lba48bit) ? WIN_READDMA_EXT : WIN_READDMA;
@@ -1196,7 +1197,7 @@
 		drive->bios_cyl		= drive->cyl;
 		drive->capacity48	= capacity_2;
 		drive->capacity		= (unsigned long) capacity_2;
-		return;
+		goto check_capacity48;
 	/* Determine capacity, and use LBA if the drive properly supports it */
 	} else if ((id->capability & 2) && lba_capacity_is_ok(id)) {
 		capacity = id->lba_capacity;
@@ -1221,12 +1222,19 @@
 	}
 
 	drive->capacity = capacity;
-
-	if ((id->command_set_2 & 0x0400) && (id->cfs_enable_2 & 0x0400)) {
-		drive->capacity48 = id->lba_capacity_2;
-		drive->head = 255;
-		drive->sect = 63;
-		drive->cyl = (unsigned long)(drive->capacity48) / (drive->head * drive->sect);
+	
+check_capacity48:
+	/* FIXME: most controllers that dont do LBA48 DMA do it PIO so we
+	   ought to handle PIO fallbacks */	   
+	if (drive->addressing == 0 && drive->capacity48 > (1ULL)<<28) {
+		printk(KERN_WARNING "%s: LBA48 large I/O not supported, capacity limited to 137Gb.\n",
+			drive->name);
+		drive->capacity48 = (1ULL)<<28;
 	}
+	/* If we don't need LBA48 and the controller LBA48 is PIO only -  don't use it */
+	if (HWIF(drive)->lba48_pio && drive->addressing == 1 && drive->capacity48 <= (1ULL)<<28) {
+		printk(KERN_INFO "%s: LBA48 DMA not supported, using LBA28 commands.\n");
+		drive->addressing = 0;
+	}
 }
 
diff -urN linux-2.4.22/drivers/ide/ide-dma.c linux-2.4.22-ide/drivers/ide/ide-dma.c
--- linux-2.4.22/drivers/ide/ide-dma.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/ide-dma.c	Sun Sep 21 01:50:18 2003
@@ -1,5 +1,5 @@
 /*
- *  linux/drivers/ide/ide-dma.c		Version 4.13	May 21, 2003
+ *  linux/drivers/ide/ide-dma.c		Version 4.15	Sep 14, 2003
  *
  *  Copyright (c) 1999-2000	Andre Hedrick <andre@linux-ide.org>
  *  May be copied or modified under the terms of the GNU General Public License
@@ -660,11 +660,15 @@
  *	__ide_dma_check		-	check DMA setup
  *	@drive: drive to check
  *
- *	Don't use - due for extermination
+ *	Default check for IDE DMA being allowed. We block DMA
+ *	if we can't configure it or if the interface lacks DMA
+ *	for lba48 devices.
  */
  
 int __ide_dma_check (ide_drive_t *drive)
 {
+	if(drive->capacity48 > (1ULL)<<28 && HWIF(drive)->lba48_pio)
+		return 1;
 	return config_drive_for_dma(drive);
 }
 
@@ -683,6 +683,16 @@
 	unsigned int count	= 0;
 	u8 dma_stat = 0, lba48	= (drive->addressing == 1) ? 1 : 0;
 	task_ioreg_t command	= WIN_NOP;
+	
+	/* If we are only PIO LBA48 capable use LBA28 for DMA.
+	
+	   For now the other layers of the kernel ensure we wont
+	   need to do a size check and fall back to PIO
+	   
+	 */
+	 
+	if(hwif->lba48_pio)
+		lba48 = 0;
 
 	if (!(count = ide_build_dmatable(drive, rq, PCI_DMA_FROMDEVICE)))
 		/* try PIO instead of DMA */
@@ -730,6 +740,16 @@
 	u8 dma_stat = 0, lba48	= (drive->addressing == 1) ? 1 : 0;
 	task_ioreg_t command	= WIN_NOP;
 
+	/* If we are only PIO LBA48 capable use LBA28 for DMA.
+	
+	   For now the other layers of the kernel ensure we wont
+	   need to do a size check and fall back to PIO
+	   
+	 */
+	 
+	if(hwif->lba48_pio)
+		lba48 = 0;
+
 	if (!(count = ide_build_dmatable(drive, rq, PCI_DMA_TODEVICE)))
 		/* try PIO instead of DMA */
 		return 1;
diff -urN linux-2.4.22/drivers/ide/ide-geometry.c linux-2.4.22-ide/drivers/ide/ide-geometry.c
--- linux-2.4.22/drivers/ide/ide-geometry.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/ide-geometry.c	Sun Sep 21 01:50:18 2003
@@ -83,7 +83,6 @@
 }
 
 
-extern ide_drive_t * get_info_ptr(kdev_t);
 extern unsigned long current_capacity (ide_drive_t *);
 
 /*
@@ -156,7 +155,7 @@
 	int transl = 1;		/* try translation */
 	int ret = 0;
 
-	drive = get_info_ptr(i_rdev);
+	drive = ide_info_ptr(i_rdev, 0);
 	if (!drive)
 		return 0;
 
diff -urN linux-2.4.22/drivers/ide/ide-io.c linux-2.4.22-ide/drivers/ide/ide-io.c
--- linux-2.4.22/drivers/ide/ide-io.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/ide-io.c	Sun Sep 21 01:50:18 2003
@@ -56,38 +56,6 @@
 
 #include "ide_modes.h"
 
-#if (DISK_RECOVERY_TIME > 0)
-
-Error So the User Has To Fix the Compilation And Stop Hacking Port 0x43
-Does anyone ever use this anyway ??
-
-/*
- * For really screwy hardware (hey, at least it *can* be used with Linux)
- * we can enforce a minimum delay time between successive operations.
- */
-static unsigned long read_timer (ide_hwif_t *hwif)
-{
-	unsigned long t, flags;
-	int i;
-	
-	/* FIXME this is completely unsafe! */
-	local_irq_save(flags);
-	t = jiffies * 11932;
-	outb_p(0, 0x43);
-	i = inb_p(0x40);
-	i |= inb_p(0x40) << 8;
-	local_irq_restore(flags);
-	return (t - i);
-}
-#endif /* DISK_RECOVERY_TIME */
-
-static inline void set_recovery_timer (ide_hwif_t *hwif)
-{
-#if (DISK_RECOVERY_TIME > 0)
-	hwif->last_time = read_timer(hwif);
-#endif /* DISK_RECOVERY_TIME */
-}
-
 /*
  *	ide_end_request		-	complete an IDE I/O
  *	@drive: IDE device for the I/O
@@ -237,6 +205,7 @@
  *	by read a sector's worth of data from the drive.  Of course,
  *	this may not help if the drive is *waiting* for data from *us*.
  */
+
 void try_to_flush_leftover_data (ide_drive_t *drive)
 {
 	int i = (drive->mult_count ? drive->mult_count : 1) * SECTOR_WORDS;
@@ -573,9 +542,9 @@
 EXPORT_SYMBOL(execute_drive_cmd);
 
 /**
- *	start_request	-	start of I/O and command issuing for IDE
+ *	ide_start_request	-	start of I/O and command issuing for IDE
  *
- *	start_request() initiates handling of a new I/O request. It
+ *	ide_start_request() initiates handling of a new I/O request. It
  *	accepts commands and I/O (read/write) requests. It also does
  *	the final remapping for weird stuff like EZDrive. Once 
  *	device mapper can work sector level the EZDrive stuff can go away
@@ -583,7 +552,7 @@
  *	FIXME: this function needs a rename
  */
  
-ide_startstop_t start_request (ide_drive_t *drive, struct request *rq)
+static ide_startstop_t ide_start_request (ide_drive_t *drive, struct request *rq)
 {
 	ide_startstop_t startstop;
 	unsigned long block, blockend;
@@ -591,12 +560,12 @@
 	ide_hwif_t *hwif = HWIF(drive);
 
 #ifdef DEBUG
-	printk("%s: start_request: current=0x%08lx\n",
+	printk("%s: ide_start_request: current=0x%08lx\n",
 		hwif->name, (unsigned long) rq);
 #endif
 
 	/* bail early if we've exceeded max_failures */
-	if (drive->max_failures && (drive->failures > drive->max_failures)) {
+	if (!drive->present || (drive->max_failures && (drive->failures > drive->max_failures))) {
 		goto kill_rq;
 	}
 
@@ -636,10 +605,6 @@
 	if (block == 0 && drive->remap_0_to_1 == 1)
 		block = 1;  /* redirect MBR access to EZ-Drive partn table */
 
-#if (DISK_RECOVERY_TIME > 0)
-	while ((read_timer() - hwif->last_time) < DISK_RECOVERY_TIME);
-#endif
-
 	SELECT_DRIVE(drive);
 	if (ide_wait_stat(&startstop, drive, drive->ready_stat, BUSY_STAT|DRQ_STAT, WAIT_READY)) {
 		printk(KERN_ERR "%s: drive not ready for command\n", drive->name);
@@ -663,16 +628,6 @@
 	return ide_stopped;
 }
 
-EXPORT_SYMBOL(start_request);
-
-int restart_request (ide_drive_t *drive, struct request *rq)
-{
-	(void) start_request(drive, rq);
-	return 0;
-}
-
-EXPORT_SYMBOL(restart_request);
-
 /**
  *	ide_stall_queue		-	pause an IDE device
  *	@drive: drive to stall
@@ -865,7 +820,7 @@
 		spin_unlock(&io_request_lock);
 		local_irq_enable();
 			/* allow other IRQs while we start this request */
-		startstop = start_request(drive, rq);
+		startstop = ide_start_request(drive, rq);
 		spin_lock_irq(&io_request_lock);
 		if (hwif->irq != masked_irq)
 			enable_irq(hwif->irq);
@@ -1043,7 +998,6 @@
 					startstop = DRIVER(drive)->error(drive, "irq timeout", hwif->INB(IDE_STATUS_REG));
 				}
 			}
-			set_recovery_timer(hwif);
 			drive->service_time = jiffies - drive->service_start;
 			spin_lock_irq(&io_request_lock);
 			enable_irq(hwif->irq);
@@ -1236,7 +1190,6 @@
 	 * same irq as is currently being serviced here, and Linux
 	 * won't allow another of the same (on any CPU) until we return.
 	 */
-	set_recovery_timer(HWIF(drive));
 	drive->service_time = jiffies - drive->service_start;
 	if (startstop == ide_stopped) {
 		if (hwgroup->handler == NULL) {	/* paranoia */
@@ -1256,7 +1209,7 @@
  * get_info_ptr() returns the (ide_drive_t *) for a given device number.
  * It returns NULL if the given device number does not match any present drives.
  */
-ide_drive_t *get_info_ptr (kdev_t i_rdev)
+ide_drive_t *ide_info_ptr (kdev_t i_rdev, int force)
 {
 	int		major = MAJOR(i_rdev);
 	unsigned int	h;
@@ -1267,7 +1220,7 @@
 			unsigned unit = DEVICE_NR(i_rdev);
 			if (unit < MAX_DRIVES) {
 				ide_drive_t *drive = &hwif->drives[unit];
-				if (drive->present)
+				if (drive->present || force)
 					return drive;
 			}
 			break;
@@ -1276,7 +1229,7 @@
 	return NULL;
 }
 
-EXPORT_SYMBOL(get_info_ptr);
+EXPORT_SYMBOL(ide_info_ptr);
 
 /**
  *	ide_init_drive_cmd	-	initialize a drive command request
diff -urN linux-2.4.22/drivers/ide/ide-iops.c linux-2.4.22-ide/drivers/ide/ide-iops.c
--- linux-2.4.22/drivers/ide/ide-iops.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/ide-iops.c	Sun Sep 21 01:50:18 2003
@@ -741,6 +741,10 @@
 
 int ide_ata66_check (ide_drive_t *drive, ide_task_t *args)
 {
+	/* SATA has no cable restrictions */
+	if (HWIF(drive)->sata)
+		return 0;
+		
 	if ((args->tfRegister[IDE_COMMAND_OFFSET] == WIN_SETFEATURES) &&
 	    (args->tfRegister[IDE_SECTOR_OFFSET] > XFER_UDMA_2) &&
 	    (args->tfRegister[IDE_FEATURE_OFFSET] == SETFEATURES_XFER)) {
diff -urN linux-2.4.22/drivers/ide/ide-probe.c linux-2.4.22-ide/drivers/ide/ide-probe.c
--- linux-2.4.22/drivers/ide/ide-probe.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/ide-probe.c	Sun Sep 21 01:51:18 2003
@@ -56,572 +56,6 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
-/**
- *	generic_id		-	add a generic drive id
- *	@drive:	drive to make an ID block for
- *	
- *	Add a fake id field to the drive we are passed. This allows
- *	use to skip a ton of NULL checks (which people always miss) 
- *	and make drive properties unconditional outside of this file
- */
- 
-static void generic_id(ide_drive_t *drive)
-{
-	drive->id->cyls = drive->cyl;
-	drive->id->heads = drive->head;
-	drive->id->sectors = drive->sect;
-	drive->id->cur_cyls = drive->cyl;
-	drive->id->cur_heads = drive->head;
-	drive->id->cur_sectors = drive->sect;
-}
-		
-/**
- *	drive_is_flashcard	-	check for compact flash
- *	@drive: drive to check
- *
- *	CompactFlash cards and their brethern pretend to be removable
- *	hard disks, except:
- * 		(1) they never have a slave unit, and
- *		(2) they don't have doorlock mechanisms.
- *	This test catches them, and is invoked elsewhere when setting
- *	appropriate config bits.
- *
- *	FIXME: This treatment is probably applicable for *all* PCMCIA (PC CARD)
- *	devices, so in linux 2.3.x we should change this to just treat all
- *	PCMCIA  drives this way, and get rid of the model-name tests below
- *	(too big of an interface change for 2.4.x).
- *	At that time, we might also consider parameterizing the timeouts and
- *	retries, since these are MUCH faster than mechanical drives. -M.Lord
- */
- 
-static inline int drive_is_flashcard (ide_drive_t *drive)
-{
-	struct hd_driveid *id = drive->id;
-
-	if (drive->removable && id != NULL) {
-		if (id->config == 0x848a) return 1;	/* CompactFlash */
-		if (!strncmp(id->model, "KODAK ATA_FLASH", 15)	/* Kodak */
-		 || !strncmp(id->model, "Hitachi CV", 10)	/* Hitachi */
-		 || !strncmp(id->model, "SunDisk SDCFB", 13)	/* SunDisk */
-		 || !strncmp(id->model, "HAGIWARA HPC", 12)	/* Hagiwara */
-		 || !strncmp(id->model, "LEXAR ATA_FLASH", 15)	/* Lexar */
-		 || !strncmp(id->model, "ATA_FLASH", 9))	/* Simple Tech */
-		{
-			return 1;	/* yes, it is a flash memory card */
-		}
-	}
-	return 0;	/* no, it is not a flash memory card */
-}
-
-/**
- *	do_identify	-	identify a drive
- *	@drive: drive to identify 
- *	@cmd: command used
- *
- *	Called when we have issued a drive identify command to
- *	read and parse the results. This function is run with
- *	interrupts disabled. 
- */
- 
-static inline void do_identify (ide_drive_t *drive, u8 cmd)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	int bswap = 1;
-	struct hd_driveid *id;
-
-	/* called with interrupts disabled! */
-	id = drive->id;
-	/* read 512 bytes of id info */
-	hwif->ata_input_data(drive, id, SECTOR_WORDS);
-	drive->id_read = 1;
-	local_irq_enable();
-	
-	ide_fix_driveid(id);
-
-	if (!drive->forced_lun)
-		drive->last_lun = id->last_lun & 0x7;
-
-#if defined (CONFIG_SCSI_EATA_DMA) || defined (CONFIG_SCSI_EATA_PIO) || defined (CONFIG_SCSI_EATA)
-	/*
-	 * EATA SCSI controllers do a hardware ATA emulation:
-	 * Ignore them if there is a driver for them available.
-	 */
-	if ((id->model[0] == 'P' && id->model[1] == 'M') ||
-	    (id->model[0] == 'S' && id->model[1] == 'K')) {
-		printk("%s: EATA SCSI HBA %.10s\n", drive->name, id->model);
-		goto err_misc;
-	}
-#endif /* CONFIG_SCSI_EATA_DMA || CONFIG_SCSI_EATA_PIO */
-
-	/*
-	 *  WIN_IDENTIFY returns little-endian info,
-	 *  WIN_PIDENTIFY *usually* returns little-endian info.
-	 */
-	if (cmd == WIN_PIDENTIFY) {
-		if ((id->model[0] == 'N' && id->model[1] == 'E') /* NEC */
-		 || (id->model[0] == 'F' && id->model[1] == 'X') /* Mitsumi */
-		 || (id->model[0] == 'P' && id->model[1] == 'i'))/* Pioneer */
-			/* Vertos drives may still be weird */
-			bswap ^= 1;	
-	}
-	ide_fixstring(id->model,     sizeof(id->model),     bswap);
-	ide_fixstring(id->fw_rev,    sizeof(id->fw_rev),    bswap);
-	ide_fixstring(id->serial_no, sizeof(id->serial_no), bswap);
-
-	if (strstr(id->model, "E X A B Y T E N E S T"))
-		goto err_misc;
-
-	/* we depend on this a lot! */
-	id->model[sizeof(id->model)-1] = '\0';
-	printk("%s: %s, ", drive->name, id->model);
-	drive->present = 1;
-	drive->dead = 0;
-
-	/*
-	 * Check for an ATAPI device
-	 */
-	if (cmd == WIN_PIDENTIFY) {
-		u8 type = (id->config >> 8) & 0x1f;
-		printk("ATAPI ");
-#ifdef CONFIG_BLK_DEV_PDC4030
-		if (hwif->channel == 1 && hwif->chipset == ide_pdc4030) {
-			printk(" -- not supported on 2nd Promise port\n");
-			goto err_misc;
-		}
-#endif /* CONFIG_BLK_DEV_PDC4030 */
-		switch (type) {
-			case ide_floppy:
-				if (!strstr(id->model, "CD-ROM")) {
-					if (!strstr(id->model, "oppy") &&
-					    !strstr(id->model, "poyp") &&
-					    !strstr(id->model, "ZIP"))
-						printk("cdrom or floppy?, assuming ");
-					if (drive->media != ide_cdrom) {
-						printk ("FLOPPY");
-						drive->removable = 1;
-						break;
-					}
-				}
-				/* Early cdrom models used zero */
-				type = ide_cdrom;
-			case ide_cdrom:
-				drive->removable = 1;
-#ifdef CONFIG_PPC
-				/* kludge for Apple PowerBook internal zip */
-				if (!strstr(id->model, "CD-ROM") &&
-				    strstr(id->model, "ZIP")) {
-					printk ("FLOPPY");
-					type = ide_floppy;
-					break;
-				}
-#endif
-				printk ("CD/DVD-ROM");
-				break;
-			case ide_tape:
-				printk ("TAPE");
-				break;
-			case ide_optical:
-				printk ("OPTICAL");
-				drive->removable = 1;
-				break;
-			default:
-				printk("UNKNOWN (type %d)", type);
-				break;
-		}
-		printk (" drive\n");
-		drive->media = type;
-		return;
-	}
-
-	/*
-	 * Not an ATAPI device: looks like a "regular" hard disk
-	 */
-	if (id->config & (1<<7))
-		drive->removable = 1;
-		
-	/*
-	 * Prevent long system lockup probing later for non-existant
-	 * slave drive if the hwif is actually a flash memory card of
-	 * some variety:
-	 */
-	drive->is_flash = 0;
-	if (drive_is_flashcard(drive)) {
-#if 0
-		/* The new IDE adapter widgets don't follow this heuristic
-		   so we must nowdays just bite the bullet and take the
-		   probe hit */	
-		ide_drive_t *mate = &hwif->drives[1^drive->select.b.unit];		
-		if (!mate->ata_flash) {
-			mate->present = 0;
-			mate->noprobe = 1;
-		}
-#endif		
-		drive->is_flash = 1;
-	}
-	drive->media = ide_disk;
-	printk("%s DISK drive\n", (drive->is_flash) ? "CFA" : "ATA" );
-	QUIRK_LIST(drive);
-	return;
-
-err_misc:
-	kfree(id);
-	drive->present = 0;
-	return;
-}
-
-/**
- *	actual_try_to_identify	-	send ata/atapi identify
- *	@drive: drive to identify
- *	@cmd: comamnd to use
- *
- *	try_to_identify() sends an ATA(PI) IDENTIFY request to a drive
- *	and waits for a response.  It also monitors irqs while this is
- *	happening, in hope of automatically determining which one is
- *	being used by the interface.
- *
- *	Returns:	0  device was identified
- *			1  device timed-out (no response to identify request)
- *			2  device aborted the command (refused to identify itself)
- */
-
-static int actual_try_to_identify (ide_drive_t *drive, u8 cmd)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	int rc;
-	ide_ioreg_t hd_status;
-	unsigned long timeout;
-	u8 s = 0, a = 0;
-
-	if (IDE_CONTROL_REG) {
-		/* take a deep breath */
-		ide_delay_50ms();
-		a = hwif->INB(IDE_ALTSTATUS_REG);
-		s = hwif->INB(IDE_STATUS_REG);
-		if ((a ^ s) & ~INDEX_STAT) {
-			printk(KERN_INFO "%s: probing with STATUS(0x%02x) instead of "
-				"ALTSTATUS(0x%02x)\n", drive->name, s, a);
-			/* ancient Seagate drives, broken interfaces */
-			hd_status = IDE_STATUS_REG;
-		} else {
-			/* use non-intrusive polling */
-			hd_status = IDE_ALTSTATUS_REG;
-		}
-	} else {
-		ide_delay_50ms();
-		hd_status = IDE_STATUS_REG;
-	}
-
-	/* set features register for atapi
-	 * identify command to be sure of reply
-	 */
-	if ((cmd == WIN_PIDENTIFY))
-		/* disable dma & overlap */
-		hwif->OUTB(0, IDE_FEATURE_REG);
-
-	if (hwif->identify != NULL) {
-		if (hwif->identify(drive))
-			return 1;
-	} else {
-		/* ask drive for ID */
-		hwif->OUTB(cmd, IDE_COMMAND_REG);
-	}
-	timeout = ((cmd == WIN_IDENTIFY) ? WAIT_WORSTCASE : WAIT_PIDENTIFY) / 2;
-	timeout += jiffies;
-	do {
-		if (time_after(jiffies, timeout)) {
-			/* drive timed-out */
-			return 1;
-		}
-		/* give drive a breather */
-		ide_delay_50ms();
-	} while ((hwif->INB(hd_status)) & BUSY_STAT);
-
-	/* wait for IRQ and DRQ_STAT */
-	ide_delay_50ms();
-	if (OK_STAT((hwif->INB(IDE_STATUS_REG)), DRQ_STAT, BAD_R_STAT)) {
-		unsigned long flags;
-
-		/* local CPU only; some systems need this */
-		local_irq_save(flags);
-		/* drive returned ID */
-		do_identify(drive, cmd);
-		/* drive responded with ID */
-		rc = 0;
-		/* clear drive IRQ */
-		(void) hwif->INB(IDE_STATUS_REG);
-		local_irq_restore(flags);
-	} else {
-		/* drive refused ID */
-		rc = 2;
-	}
-	return rc;
-}
-
-/**
- *	try_to_identify	-	try to identify a drive
- *	@drive: drive to probe
- *	@cmd: comamnd to use
- *
- *	Issue the identify command and then do IRQ probing to
- *	complete the identification when needed by finding the
- *	IRQ the drive is attached to
- */
- 
-static int try_to_identify (ide_drive_t *drive, u8 cmd)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	int retval;
-	int autoprobe = 0;
-	unsigned long cookie = 0;
-
-	if (IDE_CONTROL_REG && !hwif->irq) {
-		autoprobe = 1;
-		cookie = probe_irq_on();
-		/* enable device irq */
-		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
-	}
-
-	retval = actual_try_to_identify(drive, cmd);
-
-	if (autoprobe) {
-		int irq;
-		/* mask device irq */
-		hwif->OUTB(drive->ctl|2, IDE_CONTROL_REG);
-		/* clear drive IRQ */
-		(void) hwif->INB(IDE_STATUS_REG);
-		udelay(5);
-		irq = probe_irq_off(cookie);
-		if (!hwif->irq) {
-			if (irq > 0) {
-				hwif->irq = irq;
-			} else {
-				/* Mmmm.. multiple IRQs..
-				 * don't know which was ours
-				 */
-				printk("%s: IRQ probe failed (0x%lx)\n",
-					drive->name, cookie);
-#ifdef CONFIG_BLK_DEV_CMD640
-#ifdef CMD640_DUMP_REGS
-				if (hwif->chipset == ide_cmd640) {
-					printk("%s: Hmmm.. probably a driver "
-						"problem.\n", drive->name);
-					CMD640_DUMP_REGS;
-				}
-#endif /* CMD640_DUMP_REGS */
-#endif /* CONFIG_BLK_DEV_CMD640 */
-			}
-		}
-	}
-	return retval;
-}
-
-
-/**
- *	do_probe		-	probe an IDE device
- *	@drive: drive to probe
- *	@cmd: command to use
- *
- *	do_probe() has the difficult job of finding a drive if it exists,
- *	without getting hung up if it doesn't exist, without trampling on
- *	ethernet cards, and without leaving any IRQs dangling to haunt us later.
- *
- *	If a drive is "known" to exist (from CMOS or kernel parameters),
- *	but does not respond right away, the probe will "hang in there"
- *	for the maximum wait time (about 30 seconds), otherwise it will
- *	exit much more quickly.
- *
- * Returns:	0  device was identified
- *		1  device timed-out (no response to identify request)
- *		2  device aborted the command (refused to identify itself)
- *		3  bad status from device (possible for ATAPI drives)
- *		4  probe was not attempted because failure was obvious
- */
-
-static int do_probe (ide_drive_t *drive, u8 cmd)
-{
-	int rc;
-	ide_hwif_t *hwif = HWIF(drive);
-
-	if (drive->present) {
-		/* avoid waiting for inappropriate probes */
-		if ((drive->media != ide_disk) && (cmd == WIN_IDENTIFY))
-			return 4;
-	}
-#ifdef DEBUG
-	printk("probing for %s: present=%d, media=%d, probetype=%s\n",
-		drive->name, drive->present, drive->media,
-		(cmd == WIN_IDENTIFY) ? "ATA" : "ATAPI");
-#endif
-
-	/* needed for some systems
-	 * (e.g. crw9624 as drive0 with disk as slave)
-	 */
-	ide_delay_50ms();
-	SELECT_DRIVE(drive);
-	ide_delay_50ms();
-	if (hwif->INB(IDE_SELECT_REG) != drive->select.all && !drive->present) {
-		if (drive->select.b.unit != 0) {
-			/* exit with drive0 selected */
-			SELECT_DRIVE(&hwif->drives[0]);
-			/* allow BUSY_STAT to assert & clear */
-			ide_delay_50ms();
-		}
-		/* no i/f present: mmm.. this should be a 4 -ml */
-		return 3;
-	}
-
-	if (OK_STAT((hwif->INB(IDE_STATUS_REG)), READY_STAT, BUSY_STAT) ||
-	    drive->present || cmd == WIN_PIDENTIFY) {
-		/* send cmd and wait */
-		if ((rc = try_to_identify(drive, cmd))) {
-			/* failed: try again */
-			rc = try_to_identify(drive,cmd);
-		}
-		if (hwif->INB(IDE_STATUS_REG) == (BUSY_STAT|READY_STAT))
-			return 4;
-
-		if ((rc == 1 && cmd == WIN_PIDENTIFY) &&
-			((drive->autotune == IDE_TUNE_DEFAULT) ||
-			(drive->autotune == IDE_TUNE_AUTO))) {
-			unsigned long timeout;
-			printk("%s: no response (status = 0x%02x), "
-				"resetting drive\n", drive->name,
-				hwif->INB(IDE_STATUS_REG));
-			ide_delay_50ms();
-			hwif->OUTB(drive->select.all, IDE_SELECT_REG);
-			ide_delay_50ms();
-			hwif->OUTB(WIN_SRST, IDE_COMMAND_REG);
-			timeout = jiffies;
-			while (((hwif->INB(IDE_STATUS_REG)) & BUSY_STAT) &&
-			       time_before(jiffies, timeout + WAIT_WORSTCASE))
-				ide_delay_50ms();
-			rc = try_to_identify(drive, cmd);
-		}
-		if (rc == 1)
-			printk("%s: no response (status = 0x%02x)\n",
-				drive->name, hwif->INB(IDE_STATUS_REG));
-		/* ensure drive irq is clear */
-		(void) hwif->INB(IDE_STATUS_REG);
-	} else {
-		/* not present or maybe ATAPI */
-		rc = 3;
-	}
-	if (drive->select.b.unit != 0) {
-		/* exit with drive0 selected */
-		SELECT_DRIVE(&hwif->drives[0]);
-		ide_delay_50ms();
-		/* ensure drive irq is clear */
-		(void) hwif->INB(IDE_STATUS_REG);
-	}
-	return rc;
-}
-
-/*
- *
- */
-static void enable_nest (ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	unsigned long timeout;
-
-	printk("%s: enabling %s -- ", hwif->name, drive->id->model);
-	SELECT_DRIVE(drive);
-	ide_delay_50ms();
-	hwif->OUTB(EXABYTE_ENABLE_NEST, IDE_COMMAND_REG);
-	timeout = jiffies + WAIT_WORSTCASE;
-	do {
-		if (time_after(jiffies, timeout)) {
-			printk("failed (timeout)\n");
-			return;
-		}
-		ide_delay_50ms();
-	} while ((hwif->INB(IDE_STATUS_REG)) & BUSY_STAT);
-
-	ide_delay_50ms();
-
-	if (!OK_STAT((hwif->INB(IDE_STATUS_REG)), 0, BAD_STAT)) {
-		printk("failed (status = 0x%02x)\n", hwif->INB(IDE_STATUS_REG));
-	} else {
-		printk("success\n");
-	}
-
-	/* if !(success||timed-out) */
-	if (do_probe(drive, WIN_IDENTIFY) >= 2) {
-		/* look for ATAPI device */
-		(void) do_probe(drive, WIN_PIDENTIFY);
-	}
-}
-
-/**
- *	probe_for_drives	-	upper level drive probe
- *	@drive: drive to probe for
- *
- *	probe_for_drive() tests for existence of a given drive using do_probe()
- *	and presents things to the user as needed.
- *
- *	Returns:	0  no device was found
- *			1  device was found (note: drive->present might
- *			   still be 0)
- */
- 
-static inline u8 probe_for_drive (ide_drive_t *drive)
-{
-	/*
-	 *	In order to keep things simple we have an id
-	 *	block for all drives at all times. If the device
-	 *	is pre ATA or refuses ATA/ATAPI identify we
-	 *	will add faked data to this.
-	 *
-	 *	Also note that 0 everywhere means "can't do X"
-	 */
-	 
-	drive->id = kmalloc(SECTOR_WORDS *4, GFP_KERNEL);
-	drive->id_read = 0;
-	if(drive->id == NULL)
-	{
-		printk(KERN_ERR "ide: out of memory for id data.\n");
-		return 0;
-	}
-	memset(drive->id, 0, SECTOR_WORDS * 4);
-	strcpy(drive->id->model, "UNKNOWN");
-	
-	/* skip probing? */
-	if (!drive->noprobe)
-	{
-		/* if !(success||timed-out) */
-		if (do_probe(drive, WIN_IDENTIFY) >= 2) {
-			/* look for ATAPI device */
-			(void) do_probe(drive, WIN_PIDENTIFY);
-		}
-		if (strstr(drive->id->model, "E X A B Y T E N E S T"))
-			enable_nest(drive);
-		if (!drive->present)
-			/* drive not found */
-			return 0;
-	
-		/* identification failed? */
-		if (!drive->id_read) {
-			if (drive->media == ide_disk) {
-				printk(KERN_INFO "%s: non-IDE drive, CHS=%d/%d/%d\n",
-					drive->name, drive->cyl,
-					drive->head, drive->sect);
-			} else if (drive->media == ide_cdrom) {
-				printk(KERN_INFO "%s: ATAPI cdrom (?)\n", drive->name);
-			} else {
-				/* nuke it */
-				printk(KERN_WARNING "%s: Unknown device on bus refused identification. Ignoring.\n", drive->name);
-				drive->present = 0;
-			}
-		}
-		/* drive was found */
-	}
-	if(!drive->present)
-		return 0;
-	/* The drive wasn't being helpful. Add generic info only */
-	if(!drive->id_read)
-		generic_id(drive);
-	return drive->present;
-}
 
 #define hwif_check_region(addr, num) \
 	((hwif->mmio) ? check_mem_region((addr),(num)) : check_region((addr),(num)))
@@ -687,72 +121,6 @@
 
 //EXPORT_SYMBOL(hwif_register);
 
-/* Enable code below on all archs later, for now, I want it on PPC
- */
-#ifdef CONFIG_PPC
-/*
- * This function waits for the hwif to report a non-busy status
- * see comments in probe_hwif()
- */
-static int wait_not_busy(ide_hwif_t *hwif, unsigned long timeout)
-{
-	u8 stat = 0;
-	
-	while(timeout--) {
-		/* Turn this into a schedule() sleep once I'm sure
-		 * about locking issues (2.5 work ?)
-		 */
-		mdelay(1);
-		stat = hwif->INB(hwif->io_ports[IDE_STATUS_OFFSET]);
-		if ((stat & BUSY_STAT) == 0)
-			break;
-		/* Assume a value of 0xff means nothing is connected to
-		 * the interface and it doesn't implement the pull-down
-		 * resistor on D7
-		 */
-		if (stat == 0xff)
-			break;
-	}
-	return ((stat & BUSY_STAT) == 0) ? 0 : -EBUSY;
-}
-
-static int wait_hwif_ready(ide_hwif_t *hwif)
-{
-	int rc;
-
-	printk(KERN_INFO "Probing IDE interface %s...\n", hwif->name);
-
-	/* Let HW settle down a bit from whatever init state we
-	 * come from */
-	mdelay(2);
-
-	/* Wait for BSY bit to go away, spec timeout is 30 seconds,
-	 * I know of at least one disk who takes 31 seconds, I use 35
-	 * here to be safe
-	 */
-	rc = wait_not_busy(hwif, 35000);
-	if (rc)
-		return rc;
-
-	/* Now make sure both master & slave are ready */
-	SELECT_DRIVE(&hwif->drives[0]);
-	hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
-	mdelay(2);
-	rc = wait_not_busy(hwif, 10000);
-	if (rc)
-		return rc;
-	SELECT_DRIVE(&hwif->drives[1]);
-	hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
-	mdelay(2);
-	rc = wait_not_busy(hwif, 10000);
-
-	/* Exit function with master reselected (let's be sane) */
-	SELECT_DRIVE(&hwif->drives[0]);
-	
-	return rc;
-}
-#endif /* CONFIG_PPC */
-
 /*
  * This routine only knows how to look for drive units 0 and 1
  * on an interface, so any setting of MAX_DRIVES > 2 won't work here.
@@ -879,7 +879,7 @@
 	 *  
 	 *  BenH.
 	 */
-	if (wait_hwif_ready(hwif))
+	if (ide_wait_hwif_ready(hwif))
 		printk(KERN_WARNING "%s: Wait for ready failed before probe !\n", hwif->name);
 #endif /* CONFIG_PPC */
 
@@ -834,7 +202,7 @@
 		ide_drive_t *drive = &hwif->drives[unit];
 		drive->dn = ((hwif->channel ? 2 : 0) + unit);
 		hwif->drives[unit].dn = ((hwif->channel ? 2 : 0) + unit);
-		(void) probe_for_drive(drive);
+		(void) ide_probe_for_drive(drive);
 		if (drive->present && !hwif->present) {
 			hwif->present = 1;
 			if (hwif->chipset != ide_4drives ||
@@ -844,20 +212,8 @@
 			}
 		}
 	}
-	if (hwif->io_ports[IDE_CONTROL_OFFSET] && hwif->reset) {
-		unsigned long timeout = jiffies + WAIT_WORSTCASE;
-		u8 stat;
-
-		printk(KERN_WARNING "%s: reset\n", hwif->name);
-		hwif->OUTB(12, hwif->io_ports[IDE_CONTROL_OFFSET]);
-		udelay(10);
-		hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
-		do {
-			ide_delay_50ms();
-			stat = hwif->INB(hwif->io_ports[IDE_STATUS_OFFSET]);
-		} while ((stat & BUSY_STAT) && time_after(timeout, jiffies));
-
-	}
+	
+	ide_probe_reset(hwif);
 	local_irq_restore(flags);
 	/*
 	 * Use cached IRQ number. It might be (and is...) changed by probe
@@ -865,45 +221,9 @@
 	 */
 	if (irqd)
 		enable_irq(irqd);
+		
+	ide_tune_drives(hwif);
 
-	for (unit = 0; unit < MAX_DRIVES; ++unit) {
-		ide_drive_t *drive = &hwif->drives[unit];
-		int enable_dma = 1;
-
-		if (drive->present) {
-			if (hwif->tuneproc != NULL && 
-				drive->autotune == IDE_TUNE_AUTO)
-				/* auto-tune PIO mode */
-				hwif->tuneproc(drive, 255);
-
-#ifdef CONFIG_IDEDMA_ONLYDISK
-			if (drive->media != ide_disk)
-				enable_dma = 0;
-#endif
-			/*
-			 * MAJOR HACK BARF :-/
-			 *
-			 * FIXME: chipsets own this cruft!
-			 */
-			/*
-			 * Move here to prevent module loading clashing.
-			 */
-	//		drive->autodma = hwif->autodma;
-			if ((hwif->ide_dma_check) &&
-				((drive->autotune == IDE_TUNE_DEFAULT) ||
-				(drive->autotune == IDE_TUNE_AUTO))) {
-				/*
-				 * Force DMAing for the beginning of the check.
-				 * Some chipsets appear to do interesting
-				 * things, if not checked and cleared.
-				 *   PARANOIA!!!
-				 */
-				hwif->ide_dma_off_quietly(drive);
-				if (enable_dma)
-					hwif->ide_dma_check(drive);
-			}
-		}
-	}
 }
 
 EXPORT_SYMBOL(probe_hwif);
@@ -1334,13 +654,6 @@
 }
 
 EXPORT_SYMBOL(export_ide_init_queue);
-
-u8 export_probe_for_drive (ide_drive_t *drive)
-{
-	return probe_for_drive(drive);
-}
-
-EXPORT_SYMBOL(export_probe_for_drive);
 
 #ifndef HWIF_PROBE_CLASSIC_METHOD
 int probe_hwif_init (ide_hwif_t *hwif)
--- linux.vanilla/drivers/ide/ide-tape.c	2003-06-14 00:11:30.000000000 +0100
+++ linux.22-ac4/drivers/ide/ide-tape.c	2003-09-17 17:22:56.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/ide/ide-tape.c		Version 1.17b	Dec, 2002
+ * linux/drivers/ide/ide-tape.c		Version 1.17c	Sep, 2003
  *
  * Copyright (C) 1995 - 1999 Gadi Oxman <gadio@netvision.net.il>
  *
@@ -313,6 +313,9 @@
  *			Cosmetic fixes to miscellaneous debugging output messages.
  *			Set the minimum /proc/ide/hd?/settings values for "pipeline",
  *			 "pipeline_min", and "pipeline_max" to 1.
+ * Ver 1.17c Sep 2003	Stuart Hayes <stuart_hayes@dell.com>
+ *			Initialized "feature" in idetape_issue_packet_command
+ *			 (this was causing lockups on certain systems)
  *
  * Here are some words from the first releases of hd.c, which are quoted
  * in ide.c and apply here as well:
@@ -422,7 +425,7 @@
  *		sharing a (fast) ATA-2 disk with any (slow) new ATAPI device.
  */
 
-#define IDETAPE_VERSION "1.17b-ac1"
+#define IDETAPE_VERSION "1.17c"
 
 #include <linux/config.h>
 #include <linux/module.h>
@@ -2367,6 +2370,8 @@
 	atapi_feature_t feature;
 	atapi_bcount_t bcount;
 
+	feature.all = 0;
+
 #if IDETAPE_DEBUG_BUGS
 	if (tape->pc->c[0] == IDETAPE_REQUEST_SENSE_CMD &&
 	    pc->c[0] == IDETAPE_REQUEST_SENSE_CMD) {
diff -urN linux-2.4.22/drivers/ide/ide-sibyte.c linux-2.4.22-ide/drivers/ide/ide-sibyte.c
--- linux-2.4.22/drivers/ide/ide-sibyte.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/ide-sibyte.c	Thu Jan  1 01:00:00 1970
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2001, 2002, 2003 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-/*  Derived loosely from ide-pmac.c, so:
- *  
- *  Copyright (C) 1998 Paul Mackerras.
- *  Copyright (C) 1995-1998 Mark Lord
- */
-#include <linux/kernel.h>
-#include <linux/ide.h>
-
-#include <asm/sibyte/board.h>
-
-#define SIBYTE_IDE_BASE        (IO_SPACE_BASE + IDE_PHYS - mips_io_port_base)
-#define SIBYTE_IDE_REG(pcaddr) (SIBYTE_IDE_BASE + ((pcaddr) << 5))
-
-extern void sibyte_set_ideops(ide_hwif_t *hwif);
-
-void __init sibyte_ide_probe(void)
-{
-	int i;
-	ide_hwif_t *hwif = NULL;
-
-	/* 
-	 * Find the first untaken slot in hwifs.  Also set the io ops
-	 * to the non-swapping SiByte versions.  XXXKW It would be
-	 * nice to find a safe place to do this outside of
-	 * ide-sibyte.c so PCI-IDE would work without the SiByte
-	 * driver.
-	 */
-	for (i = 0; i < MAX_HWIFS; i++) {
-		sibyte_set_ideops(&ide_hwifs[i]);
-		if (!ide_hwifs[i].io_ports[IDE_DATA_OFFSET] && (hwif == NULL)) {
-			hwif = &ide_hwifs[i];
-		}
-	}
-	if (hwif == NULL) {
-		printk("No space for SiByte onboard IDE driver in ide_hwifs[].  Not enabled.\n");
-		return;
-	}
-
-	/*
-	 * Set up our stuff; we're a little odd because our io_ports
-	 * aren't in the usual place, and byte-swapping isn't
-	 * necessary.
-	 */
-	hwif->hw.io_ports[IDE_DATA_OFFSET]    = SIBYTE_IDE_REG(0x1f0);
-	hwif->hw.io_ports[IDE_ERROR_OFFSET]   = SIBYTE_IDE_REG(0x1f1);
-	hwif->hw.io_ports[IDE_NSECTOR_OFFSET] = SIBYTE_IDE_REG(0x1f2);
-	hwif->hw.io_ports[IDE_SECTOR_OFFSET]  = SIBYTE_IDE_REG(0x1f3);
-	hwif->hw.io_ports[IDE_LCYL_OFFSET]    = SIBYTE_IDE_REG(0x1f4);
-	hwif->hw.io_ports[IDE_HCYL_OFFSET]    = SIBYTE_IDE_REG(0x1f5);
-	hwif->hw.io_ports[IDE_SELECT_OFFSET]  = SIBYTE_IDE_REG(0x1f6);
-	hwif->hw.io_ports[IDE_STATUS_OFFSET]  = SIBYTE_IDE_REG(0x1f7);
-	hwif->hw.io_ports[IDE_CONTROL_OFFSET] = SIBYTE_IDE_REG(0x3f6);
-	hwif->hw.irq                          = K_INT_GB_IDE;
-	hwif->irq                             = hwif->hw.irq;
-	hwif->noprobe                         = 0;
-	hwif->hw.ack_intr                     = NULL;
-	hwif->mmio                            = 2;
-
-	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
-	printk("SiByte onboard IDE configured as device %i\n", hwif-ide_hwifs);
-}
diff -urN linux-2.4.22/drivers/ide/ide.c linux-2.4.22-ide/drivers/ide/ide.c
--- linux-2.4.22/drivers/ide/ide.c	Sun Sep 21 01:48:36 2003
+++ linux-2.4.22-ide/drivers/ide/ide.c	Sun Sep 21 01:51:17 2003
@@ -1,5 +1,5 @@
 /*
- *  linux/drivers/ide/ide.c		Version 7.00beta3	Apr 22 2003
+ *  linux/drivers/ide/ide.c		Version 7.00beta4	Sep 14 2003
  *
  *  Copyright (C) 1994-1998  Linus Torvalds & authors (see below)
  */
@@ -121,8 +121,8 @@
  *
  */
 
-#define	REVISION	"Revision: 7.00beta4-2.4"
-#define	VERSION		"Id: ide.c 7.00b4 20030520"
+#define	REVISION	"Revision: 7.00beta5-2.4"
+#define	VERSION		"Id: ide.c 7.00b4 20030914"
 
 #undef REALLY_SLOW_IO		/* most systems can safely undef this */
 
@@ -248,6 +248,8 @@
 	hwif->ultra_mask = 0x80;	/* disable all ultra */
 	hwif->mwdma_mask = 0x80;	/* disable all mwdma */
 	hwif->swdma_mask = 0x80;	/* disable all swdma */
+	hwif->sata = 0;			/* assume PATA */
+	hwif->lba48_pio = 0;		/* Default to old behaviour */
 
 	default_hwif_iops(hwif);
 	default_hwif_transport(hwif);
@@ -458,7 +460,7 @@
 	unsigned int p, major, minor;
 	unsigned long flags;
 
-	if ((drive = get_info_ptr(i_rdev)) == NULL)
+	if ((drive = ide_info_ptr(i_rdev, 0)) == NULL)
 		return -ENODEV;
 	major = MAJOR(i_rdev);
 	minor = drive->select.b.unit << PARTN_BITS;
@@ -547,30 +549,48 @@
 static int ide_open (struct inode * inode, struct file * filp)
 {
 	ide_drive_t *drive;
+	int force = 1/*FIXME 0*/;
+	
+	if(capable(CAP_SYS_ADMIN) && (filp->f_flags & O_NDELAY))
+		force = 1;
 
-	if ((drive = get_info_ptr(inode->i_rdev)) == NULL)
+	if ((drive = ide_info_ptr(inode->i_rdev, force)) == NULL)
 		return -ENXIO;
-	if (drive->driver == &idedefault_driver)
-		ide_driver_module(1);
-	if (drive->driver == &idedefault_driver) {
-		if (drive->media == ide_disk)
-			(void) request_module("ide-disk");
-		if (drive->scsi)
-			(void) request_module("ide-scsi");
-		if (drive->media == ide_cdrom)
-			(void) request_module("ide-cd");
-		if (drive->media == ide_tape)
-			(void) request_module("ide-tape");
-		if (drive->media == ide_floppy)
-			(void) request_module("ide-floppy");
-	}
-	
-	/* The locking here isnt enough, but this is hard to fix
-	   in the 2.4 cases */
-	while (drive->busy)
-		sleep_on(&drive->wqueue);
+	
+	/*
+	 *	If the device is present make sure that we attach any
+	 *	needed driver
+	 */	
+
+	if (drive->present)
+	{
+		if (drive->driver == &idedefault_driver)
+			ide_driver_module(1);
+		if (drive->driver == &idedefault_driver) {
+			if (drive->media == ide_disk)
+				(void) request_module("ide-disk");
+			if (drive->scsi)
+				(void) request_module("ide-scsi");
+			if (drive->media == ide_cdrom)
+				(void) request_module("ide-cd");
+			if (drive->media == ide_tape)
+				(void) request_module("ide-tape");
+			if (drive->media == ide_floppy)
+				(void) request_module("ide-floppy");
+		}
+	
+		/* The locking here isnt enough, but this is hard to fix
+		   in the 2.4 cases */
+		while (drive->busy)
+			sleep_on(&drive->wqueue);
+	}
+	
+	/*
+	 *	Now do the actual open
+	 */
+	 
 	drive->usage++;
-	if (!drive->dead)
+	if (!drive->dead || force)
 		return DRIVER(drive)->open(inode, filp, drive);
 	printk(KERN_WARNING "%s: driver not present\n", drive->name);
 	drive->usage--;
@@ -585,7 +605,7 @@
 {
 	ide_drive_t *drive;
 
-	if ((drive = get_info_ptr(inode->i_rdev)) != NULL) {
+	if ((drive = ide_info_ptr(inode->i_rdev, 1)) != NULL) {
 		drive->usage--;
 		DRIVER(drive)->release(inode, file, drive);
 	}
@@ -636,6 +656,877 @@
 
 extern void init_hwif_data(unsigned int index);
 
+/*
+ * This function waits for the hwif to report a non-busy status
+ * see comments in probe_hwif()
+ */
+static int wait_not_busy(ide_hwif_t *hwif, unsigned long timeout)
+{
+	u8 stat = 0;
+	
+	while(timeout--) {
+		/* Turn this into a schedule() sleep once I'm sure
+		 * about locking issues (2.5 work ?)
+		 */
+		mdelay(1);
+		stat = hwif->INB(hwif->io_ports[IDE_STATUS_OFFSET]);
+		if ((stat & BUSY_STAT) == 0)
+			break;
+		/* Assume a value of 0xff means nothing is connected to
+		 * the interface and it doesn't implement the pull-down
+		 * resistor on D7
+		 */
+		if (stat == 0xff)
+			break;
+	}
+	return ((stat & BUSY_STAT) == 0) ? 0 : -EBUSY;
+}
+
+int ide_wait_hwif_ready(ide_hwif_t *hwif)
+{
+	int rc;
+
+	printk(KERN_INFO "Probing IDE interface %s...\n", hwif->name);
+
+	/* Let HW settle down a bit from whatever init state we
+	 * come from */
+	mdelay(2);
+
+	/* Wait for BSY bit to go away, spec timeout is 30 seconds,
+	 * I know of at least one disk who takes 31 seconds, I use 35
+	 * here to be safe
+	 */
+	rc = wait_not_busy(hwif, 35000);
+	if (rc)
+		return rc;
+
+	/* Now make sure both master & slave are ready */
+	SELECT_DRIVE(&hwif->drives[0]);
+	hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
+	mdelay(2);
+	rc = wait_not_busy(hwif, 10000);
+	if (rc)
+		return rc;
+	SELECT_DRIVE(&hwif->drives[1]);
+	hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
+	mdelay(2);
+	rc = wait_not_busy(hwif, 10000);
+
+	/* Exit function with master reselected (let's be sane) */
+	SELECT_DRIVE(&hwif->drives[0]);
+	
+	return rc;
+}
+
+void ide_probe_reset(ide_hwif_t *hwif)
+{
+	if (hwif->io_ports[IDE_CONTROL_OFFSET] && hwif->reset) {
+		unsigned long timeout = jiffies + WAIT_WORSTCASE;
+		u8 stat;
+
+		printk(KERN_WARNING "%s: reset\n", hwif->name);
+		hwif->OUTB(12, hwif->io_ports[IDE_CONTROL_OFFSET]);
+		udelay(10);
+		hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
+		do {
+			ide_delay_50ms();
+			stat = hwif->INB(hwif->io_ports[IDE_STATUS_OFFSET]);
+		} while ((stat & BUSY_STAT) && time_after(timeout, jiffies));
+	}
+}
+
+EXPORT_SYMBOL(ide_probe_reset);
+
+void ide_tune_drives(ide_hwif_t *hwif)
+{
+	int unit;
+	
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		ide_drive_t *drive = &hwif->drives[unit];
+		int enable_dma = 1;
+
+		if (drive->present) {
+			if (hwif->tuneproc != NULL && 
+				drive->autotune == IDE_TUNE_AUTO)
+				/* auto-tune PIO mode */
+				hwif->tuneproc(drive, 255);
+
+#ifdef CONFIG_IDEDMA_ONLYDISK
+			if (drive->media != ide_disk)
+				enable_dma = 0;
+#endif
+			/*
+			 * MAJOR HACK BARF :-/
+			 *
+			 * FIXME: chipsets own this cruft!
+			 */
+			/*
+			 * Move here to prevent module loading clashing.
+			 */
+	//		drive->autodma = hwif->autodma;
+			if ((hwif->ide_dma_check) &&
+				((drive->autotune == IDE_TUNE_DEFAULT) ||
+				(drive->autotune == IDE_TUNE_AUTO))) {
+				/*
+				 * Force DMAing for the beginning of the check.
+				 * Some chipsets appear to do interesting
+				 * things, if not checked and cleared.
+				 *   PARANOIA!!!
+				 */
+				hwif->ide_dma_off_quietly(drive);
+				if (enable_dma)
+					hwif->ide_dma_check(drive);
+			}
+		}
+	}
+}
+
+EXPORT_SYMBOL(ide_tune_drives);
+
+/**
+ *	ide_prepare_tristate	-	prepare interface for warm unplug
+ *	@drive: drive on this hwif we are using
+ *
+ *	Prepares a drive for shutdown after a bus tristate. The
+ *	drives must be quiescent and the only user the calling ioctl
+ */
+ 
+static int ide_prepare_tristate(ide_drive_t *our_drive)
+{
+	ide_drive_t *drive;
+	int unit;
+	unsigned long flags;
+	int minor;
+	int p;
+	int i;
+	ide_hwif_t *hwif = HWIF(our_drive);
+		
+	if(our_drive->busy)
+		printk("HUH? We are busy.\n");
+		
+	if (!hwif->present)
+		BUG();
+	spin_lock_irqsave(&io_request_lock, flags);
+	
+	/* Abort if anything is busy */
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		drive = &hwif->drives[unit];
+		if (!drive->present)
+			continue;
+		if (drive == our_drive && drive->usage != 1)
+			goto abort;
+		if (drive != our_drive && drive->usage)
+			goto abort;
+		if (drive->busy)
+			goto abort;
+	}
+	/* Commit to shutdown sequence */
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		drive = &hwif->drives[unit];
+		if (!drive->present)
+			continue;
+		if (drive != our_drive && DRIVER(drive)->shutdown(drive))
+			goto abort;
+	}
+	/* We hold the lock here.. which is important as we need to play
+	   with usage counts beyond the scenes */
+	   
+	our_drive->usage--;
+	i = DRIVER(our_drive)->shutdown(our_drive);
+	if(i)
+		goto abort_fix;
+	/* Drive shutdown sequence done */
+	/* Prevent new opens ?? */
+	spin_unlock_irqrestore(&io_request_lock, flags);
+	/*
+	 * Flush kernel side caches, and dump the /proc files
+	 */
+	spin_unlock_irqrestore(&io_request_lock, flags);
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		drive = &hwif->drives[unit];
+		if (!drive->present)
+			continue;
+		DRIVER(drive)->cleanup(drive);
+		minor = drive->select.b.unit << PARTN_BITS;
+		for (p = 0; p < (1<<PARTN_BITS); ++p) {
+			if (drive->part[p].nr_sects > 0) {
+				kdev_t devp = MKDEV(hwif->major, minor+p);
+				invalidate_device(devp, 0);
+			}
+		}
+#ifdef CONFIG_PROC_FS
+		destroy_proc_ide_drives(hwif);
+#endif
+	}
+	spin_lock_irqsave(&io_request_lock, flags);
+	our_drive->usage++;
+	for (i = 0; i < MAX_DRIVES; ++i) {
+		drive = &hwif->drives[i];
+		if (drive->de) {
+			devfs_unregister(drive->de);
+			drive->de = NULL;
+		}
+		if (!drive->present)
+			continue;
+		drive->driver = &idedefault_driver;
+		setup_driver_defaults(drive);
+		auto_remove_settings(drive);
+		if (drive->id != NULL) {
+			kfree(drive->id);
+			drive->id = NULL;
+		}
+		drive->present = 0;
+		/* Safe to clear now */
+		drive->dead = 0;
+	}
+	spin_unlock_irqrestore(&io_request_lock, flags);
+	return 0;
+
+abort_fix:
+	our_drive->usage++;
+abort:
+	spin_unlock_irqrestore(&io_request_lock, flags);
+	return -EBUSY;
+}
+
+
+/**
+ *	drive_is_flashcard	-	check for compact flash
+ *	@drive: drive to check
+ *
+ *	CompactFlash cards and their brethern pretend to be removable
+ *	hard disks, except:
+ * 		(1) they never have a slave unit, and
+ *		(2) they don't have doorlock mechanisms.
+ *	This test catches them, and is invoked elsewhere when setting
+ *	appropriate config bits.
+ *
+ *	FIXME: This treatment is probably applicable for *all* PCMCIA (PC CARD)
+ *	devices, so in linux 2.3.x we should change this to just treat all
+ *	PCMCIA  drives this way, and get rid of the model-name tests below
+ *	(too big of an interface change for 2.4.x).
+ *	At that time, we might also consider parameterizing the timeouts and
+ *	retries, since these are MUCH faster than mechanical drives. -M.Lord
+ */
+ 
+static inline int drive_is_flashcard (ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+
+	if (drive->removable && id != NULL) {
+		if (id->config == 0x848a) return 1;	/* CompactFlash */
+		if (!strncmp(id->model, "KODAK ATA_FLASH", 15)	/* Kodak */
+		 || !strncmp(id->model, "Hitachi CV", 10)	/* Hitachi */
+		 || !strncmp(id->model, "SunDisk SDCFB", 13)	/* SunDisk */
+		 || !strncmp(id->model, "HAGIWARA HPC", 12)	/* Hagiwara */
+		 || !strncmp(id->model, "LEXAR ATA_FLASH", 15)	/* Lexar */
+		 || !strncmp(id->model, "ATA_FLASH", 9))	/* Simple Tech */
+		{
+			return 1;	/* yes, it is a flash memory card */
+		}
+	}
+	return 0;	/* no, it is not a flash memory card */
+}
+
+/**
+ *	do_identify	-	identify a drive
+ *	@drive: drive to identify 
+ *	@cmd: command used
+ *
+ *	Called when we have issued a drive identify command to
+ *	read and parse the results. This function is run with
+ *	interrupts disabled. 
+ */
+ 
+static inline void do_identify (ide_drive_t *drive, u8 cmd)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int bswap = 1;
+	struct hd_driveid *id;
+
+	/* called with interrupts disabled! */
+	id = drive->id;
+	/* read 512 bytes of id info */
+	hwif->ata_input_data(drive, id, SECTOR_WORDS);
+	drive->id_read = 1;
+	local_irq_enable();
+	
+	ide_fix_driveid(id);
+
+	if (!drive->forced_lun)
+		drive->last_lun = id->last_lun & 0x7;
+
+#if defined (CONFIG_SCSI_EATA_DMA) || defined (CONFIG_SCSI_EATA_PIO) || defined (CONFIG_SCSI_EATA)
+	/*
+	 * EATA SCSI controllers do a hardware ATA emulation:
+	 * Ignore them if there is a driver for them available.
+	 */
+	if ((id->model[0] == 'P' && id->model[1] == 'M') ||
+	    (id->model[0] == 'S' && id->model[1] == 'K')) {
+		printk("%s: EATA SCSI HBA %.10s\n", drive->name, id->model);
+		goto err_misc;
+	}
+#endif /* CONFIG_SCSI_EATA_DMA || CONFIG_SCSI_EATA_PIO */
+
+	/*
+	 *  WIN_IDENTIFY returns little-endian info,
+	 *  WIN_PIDENTIFY *usually* returns little-endian info.
+	 */
+	if (cmd == WIN_PIDENTIFY) {
+		if ((id->model[0] == 'N' && id->model[1] == 'E') /* NEC */
+		 || (id->model[0] == 'F' && id->model[1] == 'X') /* Mitsumi */
+		 || (id->model[0] == 'P' && id->model[1] == 'i'))/* Pioneer */
+			/* Vertos drives may still be weird */
+			bswap ^= 1;	
+	}
+	ide_fixstring(id->model,     sizeof(id->model),     bswap);
+	ide_fixstring(id->fw_rev,    sizeof(id->fw_rev),    bswap);
+	ide_fixstring(id->serial_no, sizeof(id->serial_no), bswap);
+
+	if (strstr(id->model, "E X A B Y T E N E S T"))
+		goto err_misc;
+
+	/* we depend on this a lot! */
+	id->model[sizeof(id->model)-1] = '\0';
+	printk("%s: %s, ", drive->name, id->model);
+	drive->present = 1;
+	drive->dead = 0;
+
+	/*
+	 * Check for an ATAPI device
+	 */
+	if (cmd == WIN_PIDENTIFY) {
+		u8 type = (id->config >> 8) & 0x1f;
+		printk("ATAPI ");
+#ifdef CONFIG_BLK_DEV_PDC4030
+		if (hwif->channel == 1 && hwif->chipset == ide_pdc4030) {
+			printk(" -- not supported on 2nd Promise port\n");
+			goto err_misc;
+		}
+#endif /* CONFIG_BLK_DEV_PDC4030 */
+		switch (type) {
+			case ide_floppy:
+				if (!strstr(id->model, "CD-ROM")) {
+					if (!strstr(id->model, "oppy") &&
+					    !strstr(id->model, "poyp") &&
+					    !strstr(id->model, "ZIP"))
+						printk("cdrom or floppy?, assuming ");
+					if (drive->media != ide_cdrom) {
+						printk ("FLOPPY");
+						drive->removable = 1;
+						break;
+					}
+				}
+				/* Early cdrom models used zero */
+				type = ide_cdrom;
+			case ide_cdrom:
+				drive->removable = 1;
+#ifdef CONFIG_PPC
+				/* kludge for Apple PowerBook internal zip */
+				if (!strstr(id->model, "CD-ROM") &&
+				    strstr(id->model, "ZIP")) {
+					printk ("FLOPPY");
+					type = ide_floppy;
+					break;
+				}
+#endif
+				printk ("CD/DVD-ROM");
+				break;
+			case ide_tape:
+				printk ("TAPE");
+				break;
+			case ide_optical:
+				printk ("OPTICAL");
+				drive->removable = 1;
+				break;
+			default:
+				printk("UNKNOWN (type %d)", type);
+				break;
+		}
+		printk (" drive\n");
+		drive->media = type;
+		return;
+	}
+
+	/*
+	 * Not an ATAPI device: looks like a "regular" hard disk
+	 */
+	if (id->config & (1<<7))
+		drive->removable = 1;
+		
+	/*
+	 * Prevent long system lockup probing later for non-existant
+	 * slave drive if the hwif is actually a flash memory card of
+	 * some variety:
+	 */
+	drive->is_flash = 0;
+	if (drive_is_flashcard(drive)) {
+#if 0
+		/* The new IDE adapter widgets don't follow this heuristic
+		   so we must nowdays just bite the bullet and take the
+		   probe hit */	
+		ide_drive_t *mate = &hwif->drives[1^drive->select.b.unit];		
+		if (!mate->ata_flash) {
+			mate->present = 0;
+			mate->noprobe = 1;
+		}
+#endif		
+		drive->is_flash = 1;
+	}
+	drive->media = ide_disk;
+	printk("%s DISK drive\n", (drive->is_flash) ? "CFA" : "ATA" );
+	QUIRK_LIST(drive);
+	return;
+
+err_misc:
+	kfree(id);
+	drive->present = 0;
+	return;
+}
+
+/**
+ *	actual_try_to_identify	-	send ata/atapi identify
+ *	@drive: drive to identify
+ *	@cmd: comamnd to use
+ *
+ *	try_to_identify() sends an ATA(PI) IDENTIFY request to a drive
+ *	and waits for a response.  It also monitors irqs while this is
+ *	happening, in hope of automatically determining which one is
+ *	being used by the interface.
+ *
+ *	Returns:	0  device was identified
+ *			1  device timed-out (no response to identify request)
+ *			2  device aborted the command (refused to identify itself)
+ */
+
+static int actual_try_to_identify (ide_drive_t *drive, u8 cmd)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int rc;
+	ide_ioreg_t hd_status;
+	unsigned long timeout;
+	u8 s = 0, a = 0;
+
+	if (IDE_CONTROL_REG) {
+		/* take a deep breath */
+		ide_delay_50ms();
+		a = hwif->INB(IDE_ALTSTATUS_REG);
+		s = hwif->INB(IDE_STATUS_REG);
+		if ((a ^ s) & ~INDEX_STAT) {
+			printk(KERN_INFO "%s: probing with STATUS(0x%02x) instead of "
+				"ALTSTATUS(0x%02x)\n", drive->name, s, a);
+			/* ancient Seagate drives, broken interfaces */
+			hd_status = IDE_STATUS_REG;
+		} else {
+			/* use non-intrusive polling */
+			hd_status = IDE_ALTSTATUS_REG;
+		}
+	} else {
+		ide_delay_50ms();
+		hd_status = IDE_STATUS_REG;
+	}
+
+	/* set features register for atapi
+	 * identify command to be sure of reply
+	 */
+	if ((cmd == WIN_PIDENTIFY))
+		/* disable dma & overlap */
+		hwif->OUTB(0, IDE_FEATURE_REG);
+
+	if (hwif->identify != NULL) {
+		if (hwif->identify(drive))
+			return 1;
+	} else {
+		/* ask drive for ID */
+		hwif->OUTB(cmd, IDE_COMMAND_REG);
+	}
+	timeout = ((cmd == WIN_IDENTIFY) ? WAIT_WORSTCASE : WAIT_PIDENTIFY) / 2;
+	timeout += jiffies;
+	do {
+		if (time_after(jiffies, timeout)) {
+			/* drive timed-out */
+			return 1;
+		}
+		/* give drive a breather */
+		ide_delay_50ms();
+	} while ((hwif->INB(hd_status)) & BUSY_STAT);
+
+	/* wait for IRQ and DRQ_STAT */
+	ide_delay_50ms();
+	if (OK_STAT((hwif->INB(IDE_STATUS_REG)), DRQ_STAT, BAD_R_STAT)) {
+		unsigned long flags;
+
+		/* local CPU only; some systems need this */
+		local_irq_save(flags);
+		/* drive returned ID */
+		do_identify(drive, cmd);
+		/* drive responded with ID */
+		rc = 0;
+		/* clear drive IRQ */
+		(void) hwif->INB(IDE_STATUS_REG);
+		local_irq_restore(flags);
+	} else {
+		/* drive refused ID */
+		rc = 2;
+	}
+	return rc;
+}
+
+/**
+ *	try_to_identify	-	try to identify a drive
+ *	@drive: drive to probe
+ *	@cmd: comamnd to use
+ *
+ *	Issue the identify command and then do IRQ probing to
+ *	complete the identification when needed by finding the
+ *	IRQ the drive is attached to
+ */
+ 
+static int try_to_identify (ide_drive_t *drive, u8 cmd)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int retval;
+	int autoprobe = 0;
+	unsigned long cookie = 0;
+
+	if (IDE_CONTROL_REG && !hwif->irq) {
+		autoprobe = 1;
+		cookie = probe_irq_on();
+		/* enable device irq */
+		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
+	}
+
+	retval = actual_try_to_identify(drive, cmd);
+
+	if (autoprobe) {
+		int irq;
+		/* mask device irq */
+		hwif->OUTB(drive->ctl|2, IDE_CONTROL_REG);
+		/* clear drive IRQ */
+		(void) hwif->INB(IDE_STATUS_REG);
+		udelay(5);
+		irq = probe_irq_off(cookie);
+		if (!hwif->irq) {
+			if (irq > 0) {
+				hwif->irq = irq;
+			} else {
+				/* Mmmm.. multiple IRQs..
+				 * don't know which was ours
+				 */
+				printk("%s: IRQ probe failed (0x%lx)\n",
+					drive->name, cookie);
+#ifdef CONFIG_BLK_DEV_CMD640
+#ifdef CMD640_DUMP_REGS
+				if (hwif->chipset == ide_cmd640) {
+					printk("%s: Hmmm.. probably a driver "
+						"problem.\n", drive->name);
+					CMD640_DUMP_REGS;
+				}
+#endif /* CMD640_DUMP_REGS */
+#endif /* CONFIG_BLK_DEV_CMD640 */
+			}
+		}
+	}
+	return retval;
+}
+
+/**
+ *	generic_id		-	add a generic drive id
+ *	@drive:	drive to make an ID block for
+ *	
+ *	Add a fake id field to the drive we are passed. This allows
+ *	use to skip a ton of NULL checks (which people always miss) 
+ *	and make drive properties unconditional outside of this file
+ */
+ 
+static void generic_id(ide_drive_t *drive)
+{
+	drive->id->cyls = drive->cyl;
+	drive->id->heads = drive->head;
+	drive->id->sectors = drive->sect;
+	drive->id->cur_cyls = drive->cyl;
+	drive->id->cur_heads = drive->head;
+	drive->id->cur_sectors = drive->sect;
+}
+
+/**
+ *	do_probe		-	probe an IDE device
+ *	@drive: drive to probe
+ *	@cmd: command to use
+ *
+ *	do_probe() has the difficult job of finding a drive if it exists,
+ *	without getting hung up if it doesn't exist, without trampling on
+ *	ethernet cards, and without leaving any IRQs dangling to haunt us later.
+ *
+ *	If a drive is "known" to exist (from CMOS or kernel parameters),
+ *	but does not respond right away, the probe will "hang in there"
+ *	for the maximum wait time (about 30 seconds), otherwise it will
+ *	exit much more quickly.
+ *
+ * Returns:	0  device was identified
+ *		1  device timed-out (no response to identify request)
+ *		2  device aborted the command (refused to identify itself)
+ *		3  bad status from device (possible for ATAPI drives)
+ *		4  probe was not attempted because failure was obvious
+ */
+
+static int do_probe (ide_drive_t *drive, u8 cmd)
+{
+	int rc;
+	ide_hwif_t *hwif = HWIF(drive);
+
+	if (drive->present) {
+		/* avoid waiting for inappropriate probes */
+		if ((drive->media != ide_disk) && (cmd == WIN_IDENTIFY))
+			return 4;
+	}
+#ifdef DEBUG
+	printk("probing for %s: present=%d, media=%d, probetype=%s\n",
+		drive->name, drive->present, drive->media,
+		(cmd == WIN_IDENTIFY) ? "ATA" : "ATAPI");
+#endif
+
+	/* needed for some systems
+	 * (e.g. crw9624 as drive0 with disk as slave)
+	 */
+	ide_delay_50ms();
+	SELECT_DRIVE(drive);
+	ide_delay_50ms();
+	if (hwif->INB(IDE_SELECT_REG) != drive->select.all && !drive->present) {
+		if (drive->select.b.unit != 0) {
+			/* exit with drive0 selected */
+			SELECT_DRIVE(&hwif->drives[0]);
+			/* allow BUSY_STAT to assert & clear */
+			ide_delay_50ms();
+		}
+		/* no i/f present: mmm.. this should be a 4 -ml */
+		return 3;
+	}
+
+	if (OK_STAT((hwif->INB(IDE_STATUS_REG)), READY_STAT, BUSY_STAT) ||
+	    drive->present || cmd == WIN_PIDENTIFY) {
+		/* send cmd and wait */
+		if ((rc = try_to_identify(drive, cmd))) {
+			/* failed: try again */
+			rc = try_to_identify(drive,cmd);
+		}
+		if (hwif->INB(IDE_STATUS_REG) == (BUSY_STAT|READY_STAT))
+			return 4;
+
+		if ((rc == 1 && cmd == WIN_PIDENTIFY) &&
+			((drive->autotune == IDE_TUNE_DEFAULT) ||
+			(drive->autotune == IDE_TUNE_AUTO))) {
+			unsigned long timeout;
+			printk("%s: no response (status = 0x%02x), "
+				"resetting drive\n", drive->name,
+				hwif->INB(IDE_STATUS_REG));
+			ide_delay_50ms();
+			hwif->OUTB(drive->select.all, IDE_SELECT_REG);
+			ide_delay_50ms();
+			hwif->OUTB(WIN_SRST, IDE_COMMAND_REG);
+			timeout = jiffies;
+			while (((hwif->INB(IDE_STATUS_REG)) & BUSY_STAT) &&
+			       time_before(jiffies, timeout + WAIT_WORSTCASE))
+				ide_delay_50ms();
+			rc = try_to_identify(drive, cmd);
+		}
+		if (rc == 1)
+			printk("%s: no response (status = 0x%02x)\n",
+				drive->name, hwif->INB(IDE_STATUS_REG));
+		/* ensure drive irq is clear */
+		(void) hwif->INB(IDE_STATUS_REG);
+	} else {
+		/* not present or maybe ATAPI */
+		rc = 3;
+	}
+	if (drive->select.b.unit != 0) {
+		/* exit with drive0 selected */
+		SELECT_DRIVE(&hwif->drives[0]);
+		ide_delay_50ms();
+		/* ensure drive irq is clear */
+		(void) hwif->INB(IDE_STATUS_REG);
+	}
+	return rc;
+}
+
+/*
+ *
+ */
+static void enable_nest (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	unsigned long timeout;
+
+	printk("%s: enabling %s -- ", hwif->name, drive->id->model);
+	SELECT_DRIVE(drive);
+	ide_delay_50ms();
+	hwif->OUTB(EXABYTE_ENABLE_NEST, IDE_COMMAND_REG);
+	timeout = jiffies + WAIT_WORSTCASE;
+	do {
+		if (time_after(jiffies, timeout)) {
+			printk("failed (timeout)\n");
+			return;
+		}
+		ide_delay_50ms();
+	} while ((hwif->INB(IDE_STATUS_REG)) & BUSY_STAT);
+
+	ide_delay_50ms();
+
+	if (!OK_STAT((hwif->INB(IDE_STATUS_REG)), 0, BAD_STAT)) {
+		printk("failed (status = 0x%02x)\n", hwif->INB(IDE_STATUS_REG));
+	} else {
+		printk("success\n");
+	}
+
+	/* if !(success||timed-out) */
+	if (do_probe(drive, WIN_IDENTIFY) >= 2) {
+		/* look for ATAPI device */
+		(void) do_probe(drive, WIN_PIDENTIFY);
+	}
+}
+
+/**
+ *	ide_probe_for_drive	-	upper level drive probe
+ *	@drive: drive to probe for
+ *
+ *	probe_for_drive() tests for existence of a given drive using do_probe()
+ *	and presents things to the user as needed.
+ *
+ *	Returns:	0  no device was found
+ *			1  device was found (note: drive->present might
+ *			   still be 0)
+ */
+ 
+u8 ide_probe_for_drive (ide_drive_t *drive)
+{
+	/*
+	 *	In order to keep things simple we have an id
+	 *	block for all drives at all times. If the device
+	 *	is pre ATA or refuses ATA/ATAPI identify we
+	 *	will add faked data to this.
+	 *
+	 *	Also note that 0 everywhere means "can't do X"
+	 */
+	 
+	drive->id = kmalloc(SECTOR_WORDS *4, GFP_KERNEL);
+	drive->id_read = 0;
+	if(drive->id == NULL)
+	{
+		printk(KERN_ERR "ide: out of memory for id data.\n");
+		return 0;
+	}
+	memset(drive->id, 0, SECTOR_WORDS * 4);
+	strcpy(drive->id->model, "UNKNOWN");
+	
+	/* skip probing? */
+	if (!drive->noprobe)
+	{
+		/* if !(success||timed-out) */
+		if (do_probe(drive, WIN_IDENTIFY) >= 2) {
+			/* look for ATAPI device */
+			(void) do_probe(drive, WIN_PIDENTIFY);
+		}
+		if (strstr(drive->id->model, "E X A B Y T E N E S T"))
+			enable_nest(drive);
+		if (!drive->present)
+			/* drive not found */
+			return 0;
+	
+		/* identification failed? */
+		if (!drive->id_read) {
+			if (drive->media == ide_disk) {
+				printk(KERN_INFO "%s: non-IDE drive, CHS=%d/%d/%d\n",
+					drive->name, drive->cyl,
+					drive->head, drive->sect);
+			} else if (drive->media == ide_cdrom) {
+				printk(KERN_INFO "%s: ATAPI cdrom (?)\n", drive->name);
+			} else {
+				/* nuke it */
+				printk(KERN_WARNING "%s: Unknown device on bus refused identification. Ignoring.\n", drive->name);
+				drive->present = 0;
+			}
+		}
+		/* drive was found */
+	}
+	if(!drive->present)
+		return 0;
+	/* The drive wasn't being helpful. Add generic info only */
+	if(!drive->id_read)
+		generic_id(drive);
+	return drive->present;
+}
+
+EXPORT_SYMBOL(ide_probe_for_drive);
+
+/**
+ *	ide_resume_hwif		-	return a hwif to active mode
+ *	@hwif: interface to resume
+ *	
+ *	Restore a dead interface from tristate back to normality. At this
+ *	point the hardware driver busproc has reconnected the bus, but
+ *	nothing else has happened
+ */
+ 
+static int ide_resume_hwif(ide_drive_t *our_drive)
+{
+	ide_hwif_t *hwif = HWIF(our_drive);
+	int err = ide_wait_hwif_ready(hwif);
+	int irqd;
+	int present = 0;
+	int unit;
+		
+	if(err)
+	{
+		printk(KERN_ERR "%s: drives not ready.\n", our_drive->name);
+		return err;
+	}
+		
+	/* The drives are now taking commands */
+	
+	irqd = hwif->irq;
+	if(irqd)
+		disable_irq(irqd);
+		
+	/* Identify and probe the drives */
+	
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		ide_drive_t *drive = &hwif->drives[unit];
+		drive->dn = ((hwif->channel ? 2 : 0) + unit);
+		drive->usage = 0;
+		drive->busy = 0;
+		hwif->drives[unit].dn = ((hwif->channel ? 2 : 0) + unit);
+		(void) ide_probe_for_drive(drive);
+		if (drive->present)
+			present = 1;
+	}
+	ide_probe_reset(hwif);
+	if(irqd)
+		enable_irq(irqd);
+	
+	if(present)
+		printk(KERN_INFO "ide: drives found on hot-added interface.\n");
+			
+	/*
+	 *	Set up the drive modes (Even if we didnt swap drives
+	 *	we may have lost settings when we disconnected the bus)
+	 */
+	 
+	ide_tune_drives(hwif);
+	if(present)
+		hwif->present = 1;
+		
+	/*
+	 *	Reattach the devices to drivers
+	 */
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		ide_drive_t *drive = &hwif->drives[unit];
+		if(drive->present && !drive->dead)
+			ide_attach_drive(drive);
+	}
+	our_drive->usage++;
+	return 0;
+}
+
 int ide_unregister (unsigned int index)
 {
 	struct gendisk *gd;
@@ -798,7 +1688,7 @@
 	hwif->swdma_mask		= old_hwif.swdma_mask;
 
 	hwif->chipset			= old_hwif.chipset;
-	hwif->hold                      = old_hwif.hold;
+	hwif->hold			= old_hwif.hold;
 
 #ifdef CONFIG_BLK_DEV_IDEPCI
 	hwif->pci_dev			= old_hwif.pci_dev;
@@ -1534,11 +2424,22 @@
 	struct request rq;
 	kdev_t dev;
 	ide_settings_t *setting;
-
+	int force = 0;
+	
 	if (!inode || !(dev = inode->i_rdev))
 		return -EINVAL;
+		
+	switch(cmd)
+	{
+		case HDIO_GET_BUSSTATE:
+		case HDIO_SET_BUSSTATE:
+		case HDIO_SCAN_HWIF:
+		case HDIO_UNREGISTER_HWIF:
+			force = 1;
+	}
+	
 	major = MAJOR(dev); minor = MINOR(dev);
-	if ((drive = get_info_ptr(inode->i_rdev)) == NULL)
+	if ((drive = ide_info_ptr(inode->i_rdev, force)) == NULL)
 		return -ENODEV;
 
 	down(&ide_setting_sem);
@@ -1739,11 +2640,42 @@
 			return 0;
 
 		case HDIO_SET_BUSSTATE:
+		{
+			ide_hwif_t *hwif =  HWIF(drive);
+			
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;
-			if (HWIF(drive)->busproc)
+#ifdef OLD_STUFF
+			if (hwif->busproc)
 				return HWIF(drive)->busproc(drive, (int)arg);
 			return -EOPNOTSUPP;
+#else
+			if(hwif->bus_state == arg)
+				return 0;
+				
+			if(hwif->bus_state == BUSSTATE_ON)
+			{
+				/* "drive" may vanish beyond here */
+				if((err = ide_prepare_tristate(drive)) != 0)
+					return err;
+				hwif->bus_state = arg;
+			}
+			if (hwif->busproc)
+			{
+				err = hwif->busproc(drive, (int)arg);
+				if(err)
+					return err;
+			}
+			if(arg != BUSSTATE_OFF)
+			{
+				err = ide_resume_hwif(drive);
+				hwif->bus_state = arg;
+				if(err)
+					return err;
+			}
+			return 0;
+#endif			
+		}				
 
 		default:
 			return DRIVER(drive)->ioctl(drive, inode, file, cmd, arg);
@@ -1755,7 +2687,7 @@
 {
 	ide_drive_t *drive;
 
-	if ((drive = get_info_ptr(i_rdev)) == NULL)
+	if ((drive = ide_info_ptr(i_rdev, 0)) == NULL)
 		return -ENODEV;
 	return DRIVER(drive)->media_change(drive);
 }
diff -urN linux-2.4.22/drivers/ide/legacy/Makefile linux-2.4.22-ide/drivers/ide/legacy/Makefile
--- linux-2.4.22/drivers/ide/legacy/Makefile	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/legacy/Makefile	Sun Sep 21 01:50:18 2003
@@ -17,7 +17,10 @@
 obj-$(CONFIG_BLK_DEV_MAC_IDE)		+= macide.o
 obj-$(CONFIG_BLK_DEV_Q40IDE)		+= q40ide.o
 
+obj-$(CONFIG_BLK_DEV_IDE_SIBYTE)	+= sibyte.o
+
 obj-$(CONFIG_BLK_DEV_IDECS)		+= ide-cs.o
+
 
 # Last of all
 obj-$(CONFIG_BLK_DEV_HD)		+= hd.o
diff -urN linux-2.4.22/drivers/ide/legacy/qd65xx.c linux-2.4.22-ide/drivers/ide/legacy/qd65xx.c
--- linux-2.4.22/drivers/ide/legacy/qd65xx.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/legacy/qd65xx.c	Sun Sep 21 01:50:18 2003
@@ -269,7 +269,7 @@
 	int recovery_time = 415; /* worst case values from the dos driver */
 
 	if (drive->id && !qd_find_disk_type(drive, &active_time, &recovery_time)) {
-		pio = ide_get_best_pio_mode(drive, pio, 255, &d);
+		pio = ide_get_best_pio_mode(drive, 255, pio, &d);
 		pio = IDE_MIN(pio,4);
 
 		switch (pio) {
diff -urN linux-2.4.22/drivers/ide/legacy/sibyte.c linux-2.4.22-ide/drivers/ide/legacy/sibyte.c
--- linux-2.4.22/drivers/ide/legacy/sibyte.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/drivers/ide/legacy/sibyte.c	Sun Sep 21 01:50:18 2003
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2001, 2002, 2003 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*  Derived loosely from ide-pmac.c, so:
+ *  
+ *  Copyright (C) 1998 Paul Mackerras.
+ *  Copyright (C) 1995-1998 Mark Lord
+ */
+#include <linux/kernel.h>
+#include <linux/ide.h>
+
+#include <asm/sibyte/board.h>
+
+#define SIBYTE_IDE_BASE        (IO_SPACE_BASE + IDE_PHYS - mips_io_port_base)
+#define SIBYTE_IDE_REG(pcaddr) (SIBYTE_IDE_BASE + ((pcaddr) << 5))
+
+extern void sibyte_set_ideops(ide_hwif_t *hwif);
+
+void __init sibyte_ide_probe(void)
+{
+	int i;
+	ide_hwif_t *hwif = NULL;
+
+	/* 
+	 * Find the first untaken slot in hwifs.  Also set the io ops
+	 * to the non-swapping SiByte versions.  XXXKW It would be
+	 * nice to find a safe place to do this outside of
+	 * ide-sibyte.c so PCI-IDE would work without the SiByte
+	 * driver.
+	 */
+	for (i = 0; i < MAX_HWIFS; i++) {
+		sibyte_set_ideops(&ide_hwifs[i]);
+		if (!ide_hwifs[i].io_ports[IDE_DATA_OFFSET] && (hwif == NULL)) {
+			hwif = &ide_hwifs[i];
+		}
+	}
+	if (hwif == NULL) {
+		printk("No space for SiByte onboard IDE driver in ide_hwifs[].  Not enabled.\n");
+		return;
+	}
+
+	/*
+	 * Set up our stuff; we're a little odd because our io_ports
+	 * aren't in the usual place, and byte-swapping isn't
+	 * necessary.
+	 */
+	hwif->hw.io_ports[IDE_DATA_OFFSET]    = SIBYTE_IDE_REG(0x1f0);
+	hwif->hw.io_ports[IDE_ERROR_OFFSET]   = SIBYTE_IDE_REG(0x1f1);
+	hwif->hw.io_ports[IDE_NSECTOR_OFFSET] = SIBYTE_IDE_REG(0x1f2);
+	hwif->hw.io_ports[IDE_SECTOR_OFFSET]  = SIBYTE_IDE_REG(0x1f3);
+	hwif->hw.io_ports[IDE_LCYL_OFFSET]    = SIBYTE_IDE_REG(0x1f4);
+	hwif->hw.io_ports[IDE_HCYL_OFFSET]    = SIBYTE_IDE_REG(0x1f5);
+	hwif->hw.io_ports[IDE_SELECT_OFFSET]  = SIBYTE_IDE_REG(0x1f6);
+	hwif->hw.io_ports[IDE_STATUS_OFFSET]  = SIBYTE_IDE_REG(0x1f7);
+	hwif->hw.io_ports[IDE_CONTROL_OFFSET] = SIBYTE_IDE_REG(0x3f6);
+	hwif->hw.irq                          = K_INT_GB_IDE;
+	hwif->irq                             = hwif->hw.irq;
+	hwif->noprobe                         = 0;
+	hwif->hw.ack_intr                     = NULL;
+	hwif->mmio                            = 2;
+
+	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
+	printk(KERN_INFO "SiByte onboard IDE configured as device %i\n", hwif-ide_hwifs);
+}
diff -urN linux-2.4.22/drivers/ide/pci/Makefile linux-2.4.22-ide/drivers/ide/pci/Makefile
--- linux-2.4.22/drivers/ide/pci/Makefile	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/Makefile	Sun Sep 21 01:50:18 2003
@@ -25,6 +25,7 @@
 obj-$(CONFIG_BLK_DEV_RZ1000)		+= rz1000.o
 obj-$(CONFIG_BLK_DEV_SVWKS)		+= serverworks.o
 obj-$(CONFIG_BLK_DEV_SC1200)		+= sc1200.o
+obj-$(CONFIG_BLK_DEV_SGIIOC4)		+= sgiioc4.o
 obj-$(CONFIG_BLK_DEV_SIIMAGE)		+= siimage.o
 obj-$(CONFIG_BLK_DEV_SIS5513)		+= sis5513.o
 obj-$(CONFIG_BLK_DEV_SL82C105)		+= sl82c105.o
diff -urN linux-2.4.22/drivers/ide/pci/adma100.c linux-2.4.22-ide/drivers/ide/pci/adma100.c
--- linux-2.4.22/drivers/ide/pci/adma100.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/adma100.c	Sun Sep 21 01:50:18 2003
@@ -76,5 +76,7 @@
 MODULE_DESCRIPTION("Basic PIO support for ADMA100 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, adma100_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
 
diff -urN linux-2.4.22/drivers/ide/pci/aec62xx.c linux-2.4.22-ide/drivers/ide/pci/aec62xx.c
--- linux-2.4.22/drivers/ide/pci/aec62xx.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/aec62xx.c	Sun Sep 21 01:50:18 2003
@@ -565,4 +565,6 @@
 MODULE_DESCRIPTION("PCI driver module for ARTOP AEC62xx IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, aec62xx_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/alim15x3.c linux-2.4.22-ide/drivers/ide/pci/alim15x3.c
--- linux-2.4.22/drivers/ide/pci/alim15x3.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/pci/alim15x3.c	Sun Sep 21 01:50:18 2003
@@ -579,6 +579,22 @@
 }
 
 /**
+ *	ali15x3_dma_check	-	check if DMA can be used
+ *	@drive: drive to enable DMA on
+ *
+ *	Check if we can move this device into DMA. config_drive_for_dma
+ *	does most of the work, we must check the lba48_pio flag however
+ *
+ */
+ 
+static int ali15x3_dma_check(ide_drive_t *drive)
+{
+	if(drive->capacity48 > (1ULL)<<28 && HWIF(drive)->lba48_pio)
+		return 1;
+	return ali15x3_config_drive_for_dma(drive);
+}
+
+/**
  *	init_chipset_ali15x3	-	Initialise an ALi IDE controller
  *	@dev: PCI device
  *	@name: Name of the controller
@@ -759,8 +775,11 @@
 	hwif->tuneproc = &ali15x3_tune_drive;
 	hwif->speedproc = &ali15x3_tune_chipset;
 
-	/* Don't use LBA48 on ALi devices before rev 0xC5 */
-	hwif->addressing = (m5229_revision <= 0xC4) ? 1 : 0;
+	/* Don't use LBA48 DMA on ALi devices before rev 0xC5.
+	   PIO is fine */
+	   
+	hwif->addressing = 0;
+	hwif->lba48_pio = (m5229_revision <= 0xC4) ? 1 : 0;
 
 	if (!hwif->dma_base) {
 		hwif->drives[0].autotune = 1;
@@ -779,7 +798,7 @@
                 /*
                  * M1543C or newer for DMAing
                  */
-                hwif->ide_dma_check = &ali15x3_config_drive_for_dma;
+                hwif->ide_dma_check = &ali15x3_dma_check;
                 hwif->ide_dma_write = &ali15x3_dma_write;
 		if (!noautodma)
 			hwif->autodma = 1;
@@ -914,5 +933,7 @@
 MODULE_AUTHOR("Michael Aubry, Andrzej Krzysztofowicz, CJ, Andre Hedrick, Alan Cox");
 MODULE_DESCRIPTION("PCI driver module for ALi 15x3 IDE");
 MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, alim15x3_pci_tbl);
 
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/amd74xx.c linux-2.4.22-ide/drivers/ide/pci/amd74xx.c
--- linux-2.4.22/drivers/ide/pci/amd74xx.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/amd74xx.c	Sun Sep 21 01:50:18 2003
@@ -40,6 +40,7 @@
 #define AMD_UDMA_33		0x01
 #define AMD_UDMA_66		0x02
 #define AMD_UDMA_100		0x03
+#define AMD_UDMA_133		0x04
 #define AMD_CHECK_SWDMA		0x08
 #define AMD_BAD_SWDMA		0x10
 #define AMD_BAD_FIFO		0x20
@@ -60,7 +61,13 @@
 	{ PCI_DEVICE_ID_AMD_OPUS_7441, 0x00, 0x40, AMD_UDMA_100 },			/* AMD-768 Opus */
 	{ PCI_DEVICE_ID_AMD_8111_IDE,  0x00, 0x40, AMD_UDMA_100 },			/* AMD-8111 */
         { PCI_DEVICE_ID_NVIDIA_NFORCE_IDE, 0x00, 0x50, AMD_UDMA_100 },                  /* nVidia nForce */
-        { PCI_DEVICE_ID_NVIDIA_NFORCE2_IDE, 0x00, 0x50, AMD_UDMA_100 },                  /* nVidia nForce */
+        { PCI_DEVICE_ID_NVIDIA_NFORCE2_IDE, 0x00, 0x50, AMD_UDMA_133 },                 /* nVidia nForce2 */
+        { PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE, 0x00, 0x50, AMD_UDMA_133 },                /* nVidia nForce2s */
+        { PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA, 0x00, 0x50, AMD_UDMA_133 },               /* nVidia nForce2s SATA */
+        { PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE, 0x00, 0x50, AMD_UDMA_133 },                 /* NVIDIA nForce3 */
+        { PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE, 0x00, 0x50, AMD_UDMA_133 },                /* NVIDIA nForce3s */
+        { PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA, 0x00, 0x50, AMD_UDMA_133 },               /* NVIDIA nForce3s SATA */
+        { PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA2, 0x00, 0x50, AMD_UDMA_133 },              /* NVIDIA nForce3s SATA2 */
 
 	{ 0 }
 };
@@ -70,9 +77,9 @@
 static unsigned int amd_80w;
 static unsigned int amd_clock;
 
-static unsigned char amd_cyc2udma[] = { 6, 6, 5, 4, 0, 1, 1, 2, 2, 3, 3 };
-static unsigned char amd_udma2cyc[] = { 4, 6, 8, 10, 3, 2, 1, 1 };
-static char *amd_dma[] = { "MWDMA16", "UDMA33", "UDMA66", "UDMA100" };
+static unsigned char amd_cyc2udma[] = { 6, 6, 5, 4, 0, 1, 1, 2, 2, 3, 3, 7 };
+static unsigned char amd_udma2cyc[] = { 4, 6, 8, 10, 3, 2, 1, 0 };
+static char *amd_dma[] = { "MWDMA16", "UDMA33", "UDMA66", "UDMA100", "UDMA133" };
 
 /*
  * AMD /proc entry.
@@ -154,6 +161,11 @@
 			cycle[i] = 666666 / amd_clock;
 			continue;
 		}
+		if (den[i] && uen[i] && udma[i] == 0) {
+			speed[i] = amd_clock * 4;
+			cycle[i] = 500000 / amd_clock;
+			continue;
+		}
 
 		speed[i] = 4 * amd_clock / ((den[i] && uen[i]) ? udma[i] : (active[i] + recover[i]) * 2);
 		cycle[i] = 1000000 * ((den[i] && uen[i]) ? udma[i] : (active[i] + recover[i]) * 2) / amd_clock / 2;
@@ -200,6 +212,7 @@
 		case AMD_UDMA_33:  t = timing->udma ? (0xc0 | (FIT(timing->udma, 2, 5) - 2)) : 0x03; break;
 		case AMD_UDMA_66:  t = timing->udma ? (0xc0 | amd_cyc2udma[FIT(timing->udma, 2, 10)]) : 0x03; break;
 		case AMD_UDMA_100: t = timing->udma ? (0xc0 | amd_cyc2udma[FIT(timing->udma, 1, 10)]) : 0x03; break;
+		case AMD_UDMA_133: t = timing->udma ? (0xc0 | amd_cyc2udma[FIT(timing->udma, 1, 11)]) : 0x03; break;
 		default: return;
 	}
 
@@ -233,7 +246,12 @@
 		ide_timing_merge(&p, &t, &t, IDE_TIMING_8BIT);
 	}
 
+	/*
+	 * AMD / nForce UDMA timing register should really be programmed 
+	 * based on UDMA mode not UDMA cycle time...
+	 */
 	if (speed == XFER_UDMA_5 && amd_clock <= 33333) t.udma = 1;
+	if (speed == XFER_UDMA_6 && amd_clock <= 33333) t.udma = 11;
 
 	amd_set_speed(HWIF(drive)->pci_dev, drive->dn, &t);
 
@@ -276,7 +294,8 @@
 		XFER_PIO | XFER_EPIO | XFER_MWDMA | XFER_UDMA |
 		((amd_config->flags & AMD_BAD_SWDMA) ? 0 : XFER_SWDMA) |
 		(w80 && (amd_config->flags & AMD_UDMA) >= AMD_UDMA_66 ? XFER_UDMA_66 : 0) |
-		(w80 && (amd_config->flags & AMD_UDMA) >= AMD_UDMA_100 ? XFER_UDMA_100 : 0));
+		(w80 && (amd_config->flags & AMD_UDMA) >= AMD_UDMA_100 ? XFER_UDMA_100 : 0) |
+		(w80 && (amd_config->flags & AMD_UDMA) >= AMD_UDMA_133 ? XFER_UDMA_133 : 0));
 
 	amd_set_drive(drive, speed);
 
@@ -312,6 +331,7 @@
 
 	switch (amd_config->flags & AMD_UDMA) {
 
+		case AMD_UDMA_133:
 		case AMD_UDMA_100:
 			pci_read_config_byte(dev, AMD_CABLE_DETECT, &t);
 			pci_read_config_dword(dev, AMD_UDMA_TIMING, &u);
@@ -318,7 +318,7 @@
 			amd_80w = ((t & 0x3) ? 1 : 0) | ((t & 0xc) ? 2 : 0);
 			for (i = 24; i >= 0; i -= 8)
 				if (((u >> i) & 4) && !(amd_80w & (1 << (1 - (i >> 4))))) {
-					printk(KERN_WARNING "AMD_IDE: Bios didn't set cable bits corectly. Enabling workaround.\n");
+					printk(KERN_WARNING "AMD_IDE: Bios didn't set cable bits correctly. Enabling workaround.\n");
 					amd_80w |= (1 << (1 - (i >> 4)));
 				}
 			break;
@@ -454,6 +474,12 @@
 	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_IDE, 	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4},
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5},
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 6},
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 7},
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 8},
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 9},
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 10},
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 11},
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 12},
 	{ 0, },
 };
 
@@ -479,5 +479,7 @@
 MODULE_AUTHOR("Vojtech Pavlik");
 MODULE_DESCRIPTION("AMD PCI IDE driver");
 MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, amd74xx_pci_tbl);
 
 EXPORT_NO_SYMBOLS;
--- linux.vanilla/drivers/ide/pci/amd74xx.h	2003-06-14 00:11:31.000000000 +0100
+++ linux.22-ac4/drivers/ide/pci/amd74xx.h	2003-09-20 17:04:40.000000000 +0100
@@ -124,6 +124,90 @@
 		.bootable	= ON_BOARD,
 		.extra		= 0,
 	},
+	{	/* 7 */
+		.vendor		= PCI_VENDOR_ID_NVIDIA,
+		.device		= PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE,
+		.name		= "NFORCE2",
+		.init_chipset	= init_chipset_amd74xx,
+		.init_iops	= NULL,
+		.init_hwif	= init_hwif_amd74xx,
+		.init_dma	= init_dma_amd74xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x01,0x01}},
+		.bootable	= ON_BOARD,
+		.extra		= 0,
+	},
+	{	/* 8 */
+		.vendor		= PCI_VENDOR_ID_NVIDIA,
+		.device		= PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA,
+		.name		= "NFORCE2",
+		.init_chipset	= init_chipset_amd74xx,
+		.init_iops	= NULL,
+		.init_hwif	= init_hwif_amd74xx,
+		.init_dma	= init_dma_amd74xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x01,0x01}},
+		.bootable	= ON_BOARD,
+		.extra		= 0,
+	},
+	{	/* 9 */
+		.vendor		= PCI_VENDOR_ID_NVIDIA,
+		.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE,
+		.name		= "NFORCE3",
+		.init_chipset	= init_chipset_amd74xx,
+		.init_iops	= NULL,
+		.init_hwif	= init_hwif_amd74xx,
+		.init_dma	= init_dma_amd74xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x01,0x01}},
+		.bootable	= ON_BOARD,
+		.extra		= 0,
+	},
+	{	/* 10 */
+		.vendor		= PCI_VENDOR_ID_NVIDIA,
+		.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE,
+		.name		= "NFORCE3",
+		.init_chipset	= init_chipset_amd74xx,
+		.init_iops	= NULL,
+		.init_hwif	= init_hwif_amd74xx,
+		.init_dma	= init_dma_amd74xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x01,0x01}},
+		.bootable	= ON_BOARD,
+		.extra		= 0,
+	},
+	{	/* 11 */
+		.vendor		= PCI_VENDOR_ID_NVIDIA,
+		.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA,
+		.name		= "NFORCE3",
+		.init_chipset	= init_chipset_amd74xx,
+		.init_iops	= NULL,
+		.init_hwif	= init_hwif_amd74xx,
+		.init_dma	= init_dma_amd74xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x01,0x01}},
+		.bootable	= ON_BOARD,
+		.extra		= 0,
+	},
+	{	/* 12 */
+		.vendor		= PCI_VENDOR_ID_NVIDIA,
+		.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA2,
+		.name		= "NFORCE3",
+		.init_chipset	= init_chipset_amd74xx,
+		.init_iops	= NULL,
+		.init_hwif	= init_hwif_amd74xx,
+		.init_dma	= init_dma_amd74xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x01,0x01}},
+		.bootable	= ON_BOARD,
+		.extra		= 0,
+	},
 	{
 		.vendor		= 0,
 		.device		= 0,
diff -urN linux-2.4.22/drivers/ide/pci/cmd64x.c linux-2.4.22-ide/drivers/ide/pci/cmd64x.c
--- linux-2.4.22/drivers/ide/pci/cmd64x.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/cmd64x.c	Sun Sep 21 01:50:18 2003
@@ -794,5 +794,7 @@
 MODULE_DESCRIPTION("PCI driver module for CMD64x IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, cmd64x_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
 
diff -urN linux-2.4.22/drivers/ide/pci/cs5530.c linux-2.4.22-ide/drivers/ide/pci/cs5530.c
--- linux-2.4.22/drivers/ide/pci/cs5530.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/cs5530.c	Sun Sep 21 01:50:18 2003
@@ -460,4 +460,6 @@
 MODULE_DESCRIPTION("PCI driver module for Cyrix/NS 5530 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, cs5530_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/cy82c693.c linux-2.4.22-ide/drivers/ide/pci/cy82c693.c
--- linux-2.4.22/drivers/ide/pci/cy82c693.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/cy82c693.c	Sun Sep 21 01:50:18 2003
@@ -465,4 +465,6 @@
 MODULE_DESCRIPTION("PCI driver module for the Cypress CY82C693 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, cy82c693_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/generic.c linux-2.4.22-ide/drivers/ide/pci/generic.c
--- linux-2.4.22/drivers/ide/pci/generic.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/pci/generic.c	Sun Sep 21 01:50:18 2003
@@ -167,4 +167,6 @@
 MODULE_DESCRIPTION("PCI driver module for generic PCI IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, generic_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/hpt34x.c linux-2.4.22-ide/drivers/ide/pci/hpt34x.c
--- linux-2.4.22/drivers/ide/pci/hpt34x.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/hpt34x.c	Sun Sep 21 01:50:18 2003
@@ -367,4 +367,6 @@
 MODULE_DESCRIPTION("PCI driver module for Highpoint 34x IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, hpt34x_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/hpt366.c linux-2.4.22-ide/drivers/ide/pci/hpt366.c
--- linux-2.4.22/drivers/ide/pci/hpt366.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/pci/hpt366.c	Sun Sep 21 01:50:18 2003
@@ -465,7 +465,7 @@
 
 static void hpt3xx_tune_drive (ide_drive_t *drive, u8 pio)
 {
-	pio = ide_get_best_pio_mode(drive, pio, 5, NULL);
+	pio = ide_get_best_pio_mode(drive, 255, pio, NULL);
 	(void) hpt3xx_tune_chipset(drive, (XFER_PIO_0 + pio));
 }
 
@@ -713,7 +713,7 @@
 	
 	/* Reconnect channels to bus */
 	outb(0x00, hwif->dma_base+0x73);
-	outb(0x00, hwif->dma_base+0x79);
+	outb(0x00, hwif->dma_base+0x77);
 }
 
 /**
@@ -1343,7 +1343,7 @@
 	u8 pin1 = 0, pin2 = 0;
 	unsigned int class_rev;
 	static char *chipset_names[] = {"HPT366", "HPT366",  "HPT368",
-				 "HPT370", "HPT370A", "HPT372"};
+				 "HPT370", "HPT370A", "HPT372", "HPT372N"};
 
 	if (PCI_FUNC(dev->devfn) & 1)
 		return;
@@ -1351,16 +1351,11 @@
 	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class_rev);
 	class_rev &= 0xff;
 
-	/* New ident 372N reports revision 1. We could do the 
-	   io port based type identification instead perhaps (DID, RID) */
-	   
-	if(d->device == PCI_DEVICE_ID_TTI_HPT372N)
-		class_rev = 5;
-		
-	if(class_rev < 6)
+	if(class_rev <= 6)
 		d->name = chipset_names[class_rev];
 
 	switch(class_rev) {
+		case 6:
 		case 5:
 		case 4:
 		case 3: ide_setup_pci_device(dev, d);
@@ -1443,5 +1438,7 @@
 MODULE_AUTHOR("Andre Hedrick");
 MODULE_DESCRIPTION("PCI driver module for Highpoint HPT366 IDE");
 MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, hpt366_pci_tbl);
 
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/it8172.c linux-2.4.22-ide/drivers/ide/pci/it8172.c
--- linux-2.4.22/drivers/ide/pci/it8172.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/it8172.c	Sun Sep 21 01:50:18 2003
@@ -331,4 +331,6 @@
 MODULE_DESCRIPTION("PCI driver module for ITE 8172 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, it8172_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/ns87415.c linux-2.4.22-ide/drivers/ide/pci/ns87415.c
--- linux-2.4.22/drivers/ide/pci/ns87415.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/ns87415.c	Sun Sep 21 01:50:18 2003
@@ -264,4 +264,6 @@
 MODULE_DESCRIPTION("PCI driver module for NS87415 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, ns87415_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/opti621.c linux-2.4.22-ide/drivers/ide/pci/opti621.c
--- linux-2.4.22/drivers/ide/pci/opti621.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/opti621.c	Sun Sep 21 01:50:18 2003
@@ -400,4 +400,6 @@
 MODULE_DESCRIPTION("PCI driver module for Opti621 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, opti621_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/pdc202xx_new.c linux-2.4.22-ide/drivers/ide/pci/pdc202xx_new.c
--- linux-2.4.22/drivers/ide/pci/pdc202xx_new.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/pdc202xx_new.c	Sun Sep 21 01:50:18 2003
@@ -677,4 +677,6 @@
 MODULE_DESCRIPTION("PCI driver module for Promise PDC20268 and higher");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, pdc202new_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/pdc202xx_old.c linux-2.4.22-ide/drivers/ide/pci/pdc202xx_old.c
--- linux-2.4.22/drivers/ide/pci/pdc202xx_old.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/pci/pdc202xx_old.c	Sun Sep 21 01:50:18 2003
@@ -697,9 +697,6 @@
 	hwif->tuneproc  = &config_chipset_for_pio;
 	hwif->quirkproc = &pdc202xx_quirkproc;
 
-	if (hwif->pci_dev->device == PCI_DEVICE_ID_PROMISE_20265)
-		hwif->addressing = (hwif->channel) ? 0 : 1;
-
 	if (hwif->pci_dev->device != PCI_DEVICE_ID_PROMISE_20246) {
 		hwif->busproc   = &pdc202xx_tristate;
 		hwif->resetproc = &pdc202xx_reset;
@@ -879,5 +876,7 @@
 MODULE_AUTHOR("Andre Hedrick, Frank Tiernan");
 MODULE_DESCRIPTION("PCI driver module for older Promise IDE");
 MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, pdc202xx_pci_tbl);
 
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/piix.c linux-2.4.22-ide/drivers/ide/pci/piix.c
--- linux-2.4.22/drivers/ide/pci/piix.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/piix.c	Sun Sep 21 01:50:18 2003
@@ -153,6 +153,7 @@
 			case PCI_DEVICE_ID_INTEL_82801DB_11:
 			case PCI_DEVICE_ID_INTEL_82801EB_11:
 			case PCI_DEVICE_ID_INTEL_82801E_11:
+			case PCI_DEVICE_ID_INTEL_ESB_2:
 				p += sprintf(p, "PIIX4 Ultra 100 ");
 				break;
 			case PCI_DEVICE_ID_INTEL_82372FB_1:
@@ -290,6 +291,7 @@
 		case PCI_DEVICE_ID_INTEL_82801DB_10:
 		case PCI_DEVICE_ID_INTEL_82801DB_11:
 		case PCI_DEVICE_ID_INTEL_82801EB_11:
+		case PCI_DEVICE_ID_INTEL_ESB_2:
 			mode = 3;
 			break;
 		/* UDMA 66 capable */
@@ -599,6 +601,65 @@
 }
 
 /**
+ *	ich3_busproc		-	bus isolation ioctl
+ *	@drive: drive to isolate/restore
+ *	@state: bus state to set
+ *
+ *	Used by the ICH3 to handle bus isolation. We have to do
+ *	a little bit of fixing to keep the hardware happy.
+ */
+ 
+static int ich3_busproc (ide_drive_t * drive, int state)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u32 sig_mode;
+	int shift;
+	int bits;
+	
+	if(hwif->channel == 0)
+		shift = 17;
+	else
+		shift = 19;
+		
+	switch (state) {
+		case BUSSTATE_ON:
+			bits = 0x00;
+			hwif->drives[0].failures = 0;
+			hwif->drives[1].failures = 0;
+			break;
+		case BUSSTATE_OFF:
+			bits = 0x01;
+			break;
+		case BUSSTATE_TRISTATE:
+			bits = 0x10;
+			break;
+		default:
+			return -EINVAL;
+	}
+	
+	if(bits)
+	{
+		int port = hwif->channel == 0 ? 0x40 : 0x42;
+		u16 reg;
+		hwif->drives[0].failures = hwif->drives[0].max_failures + 1;
+		hwif->drives[1].failures = hwif->drives[1].max_failures + 1;
+		/* Turn off IORDY checking to avoid hangs */
+		pci_read_config_word(hwif->pci_dev, port, &reg);
+		reg&=~(1<<5)|(1<<1);
+		pci_write_config_word(hwif->pci_dev, port, reg);
+	}
+	/* Todo: Check locking */
+	pci_read_config_dword(hwif->pci_dev, 0x54, &sig_mode);
+	sig_mode&=~(3<<shift);
+	sig_mode|=(bits<<shift);
+	pci_write_config_dword(hwif->pci_dev, 0x54, sig_mode);
+
+	hwif->bus_state = state;
+	return 0;
+}
+
+
+/**
  *	init_chipset_piix	-	set up the PIIX chipset
  *	@dev: PCI device to set up
  *	@name: Name of the device
@@ -621,6 +682,7 @@
 		case PCI_DEVICE_ID_INTEL_82801DB_11:
 		case PCI_DEVICE_ID_INTEL_82801EB_11:
 		case PCI_DEVICE_ID_INTEL_82801E_11:
+		case PCI_DEVICE_ID_INTEL_ESB_2:
 		{
 			unsigned int extra = 0;
 			pci_read_config_dword(dev, 0x54, &extra);
@@ -693,6 +755,10 @@
 		case PCI_DEVICE_ID_INTEL_82801AB_1:
 			hwif->ultra_mask = 0x07;
 			break;
+		case PCI_DEVICE_ID_INTEL_82801CA_10:
+		case PCI_DEVICE_ID_INTEL_82801CA_11:
+			hwif->busproc = ich3_busproc;
+			/* fall through */
 		default:
 			pci_read_config_byte(hwif->pci_dev, 0x54, &reg54h);
 			pci_read_config_byte(hwif->pci_dev, 0x55, &reg55h);
@@ -811,7 +877,10 @@
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801EB_11,PCI_ANY_ID, PCI_ANY_ID, 0, 0, 15},
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801E_11, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 16},
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_10,PCI_ANY_ID, PCI_ANY_ID, 0, 0, 17},
+#if 0 /* SATA is covered by ata_piix scsi driver */
  	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801EB_1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 18},
+#endif
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ESB_2,     PCI_ANY_ID, PCI_ANY_ID, 0, 0, 19},
 	{ 0, },
 };
 
@@ -838,5 +907,7 @@
 MODULE_AUTHOR("Andre Hedrick, Andrzej Krzysztofowicz");
 MODULE_DESCRIPTION("PCI driver module for Intel PIIX IDE");
 MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, piix_pci_tbl);
 
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/piix.h linux-2.4.22-ide/drivers/ide/pci/piix.h
--- linux-2.4.22/drivers/ide/pci/piix.h	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/piix.h	Sun Sep 21 01:50:18 2003
@@ -305,6 +305,20 @@
 		.enablebits	= {{0x41,0x80,0x80}, {0x43,0x80,0x80}},
 		.bootable	= ON_BOARD,
 		.extra		= 0,
+	},{	/* 19 */
+		.vendor		= PCI_VENDOR_ID_INTEL,
+		.device		= PCI_DEVICE_ID_INTEL_ESB_2,
+		.name		= "ESB",
+		.init_setup	= init_setup_piix,
+		.init_chipset	= init_chipset_piix,
+		.init_iops	= NULL,
+		.init_hwif	= init_hwif_piix,
+		.init_dma	= init_dma_piix,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x41,0x80,0x80}, {0x43,0x80,0x80}},
+		.bootable	= ON_BOARD,
+		.extra		= 0,
 	},{
 		.vendor		= 0,
 		.device		= 0,
diff -urN linux-2.4.22/drivers/ide/pci/rz1000.c linux-2.4.22-ide/drivers/ide/pci/rz1000.c
--- linux-2.4.22/drivers/ide/pci/rz1000.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/rz1000.c	Sun Sep 21 01:50:18 2003
@@ -95,5 +95,7 @@
 MODULE_DESCRIPTION("PCI driver module for RZ1000 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, rz1000_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
 
diff -urN linux-2.4.22/drivers/ide/pci/sc1200.c linux-2.4.22-ide/drivers/ide/pci/sc1200.c
--- linux-2.4.22/drivers/ide/pci/sc1200.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/sc1200.c	Sun Sep 21 01:50:18 2003
@@ -595,4 +595,6 @@
 MODULE_DESCRIPTION("PCI driver module for NS SC1200 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, sc1200_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/serverworks.c linux-2.4.22-ide/drivers/ide/pci/serverworks.c
--- linux-2.4.22/drivers/ide/pci/serverworks.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/serverworks.c	Sun Sep 21 01:50:18 2003
@@ -834,4 +834,6 @@
 MODULE_DESCRIPTION("PCI driver module for Serverworks OSB4/CSB5/CSB6 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, svwks_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/sgiioc4.c linux-2.4.22-ide/drivers/ide/pci/sgiioc4.c
--- linux-2.4.22/drivers/ide/pci/sgiioc4.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/drivers/ide/pci/sgiioc4.c	Sun Sep 21 01:50:18 2003
@@ -0,0 +1,924 @@
+/*
+ * Copyright (c) 2003 Silicon Graphics, Inc.  All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Further, this software is distributed without any warranty that it is
+ * free of the rightful claim of any third person regarding infringement
+ * or the like.  Any license provided herein, whether implied or
+ * otherwise, applies only to this software file.  Patent licenses, if
+ * any, provided herein do not apply to combinations of this program with
+ * other software, or any other product whatsoever.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
+ * Mountain View, CA  94043, or:
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
+ * http://oss.sgi.com/projects/GenInfo/NoticeExplan
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/hdreg.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/blkdev.h>
+#include "sgiioc4.h"
+
+extern int dma_timer_expiry(ide_drive_t * drive);
+
+#ifdef CONFIG_PROC_FS
+static u8 sgiioc4_proc = 0;
+#endif /* CONFIG_PROC_FS */
+
+static int n_sgiioc4_devs = 0;
+
+#define SGIIOC4_HD_SUPPORT 0
+
+static inline void
+xide_delay(long ticks)
+{
+	if (!ticks)
+		return;
+
+	current->state = TASK_UNINTERRUPTIBLE;
+	schedule_timeout(ticks);
+}
+
+static void __init
+sgiioc4_ide_setup_pci_device(struct pci_dev *dev, const char *name)
+{
+	unsigned long base = 0, ctl = 0, dma_base = 0, irqport = 0;
+	ide_hwif_t *hwif = NULL;
+	int h = 0;
+
+	/*  Get the CmdBlk and CtrlBlk Base Registers */
+	base = pci_resource_start(dev, 0) + IOC4_CMD_OFFSET;
+	ctl = pci_resource_start(dev, 0) + IOC4_CTRL_OFFSET;
+	irqport = pci_resource_start(dev, 0) + IOC4_INTR_OFFSET;
+	dma_base = pci_resource_start(dev, 0) + IOC4_DMA_OFFSET;
+
+	for (h = 0; h < MAX_HWIFS; ++h) {
+		hwif = &ide_hwifs[h];
+		/* Find an empty HWIF */
+		if (hwif->chipset == ide_unknown)
+			break;
+	}
+
+	if (hwif->io_ports[IDE_DATA_OFFSET] != base) {
+		/* Initialize the IO registers */
+		sgiioc4_init_hwif_ports(&hwif->hw, base, ctl, irqport);
+		memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof (hwif->io_ports));
+		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
+	}
+
+	hwif->chipset = ide_pci;
+	hwif->pci_dev = dev;
+	hwif->channel = 0;	/* Single Channel chip */
+	hwif->hw.ack_intr = &sgiioc4_checkirq;	/* MultiFunction Chip */
+
+	/* Initializing chipset IRQ Registers */
+	hwif->OUTL(0x03, irqport + IOC4_INTR_SET * 4);
+
+	(void) ide_init_sgiioc4(hwif);
+
+	if (dma_base)
+		ide_dma_sgiioc4(hwif, dma_base);
+	else
+		printk(KERN_INFO "%s: %s Bus-Master DMA disabled \n", hwif->name, name);
+}
+
+static unsigned int __init
+pci_init_sgiioc4(struct pci_dev *dev, const char *name)
+{
+	extern pciio_endian_t snia_pciio_endian_set(struct pci_dev *pci_dev,
+						    pciio_endian_t device_end,
+						    pciio_endian_t desired_end);
+
+	if (pci_enable_device(dev)) {
+		printk(KERN_INFO "Failed to enable device %s at slot %s \n",name,dev->slot_name);
+		return 1;
+	}
+	pci_set_master(dev);
+#if defined(CONFIG_IA64_SGI_SN2) || defined(CONFIG_IA64_GENERIC)
+	/* Enable Byte Swapping in the PIC */
+	snia_pciio_endian_set(dev, PCIDMA_ENDIAN_LITTLE, PCIDMA_ENDIAN_BIG);
+#endif
+
+#ifdef CONFIG_PROC_FS
+	sgiioc4_devs[n_sgiioc4_devs++] = dev;
+	if (!sgiioc4_proc) {
+		sgiioc4_proc = 1;
+		ide_pci_register_host_proc(&sgiioc4_procs[0]);
+	}
+#endif
+	sgiioc4_ide_setup_pci_device(dev, name);
+	return 0;
+}
+
+static void
+sgiioc4_init_hwif_ports(hw_regs_t * hw, ide_ioreg_t data_port,
+			ide_ioreg_t ctrl_port, ide_ioreg_t irq_port)
+{
+	ide_ioreg_t reg = data_port;
+	int i;
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+		hw->io_ports[i] = reg + i * 4;	/* Registers are word (32 bit) aligned */
+
+	if (ctrl_port)
+		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+
+	if (irq_port)
+		hw->io_ports[IDE_IRQ_OFFSET] = irq_port;
+}
+
+static void
+sgiioc4_resetproc(ide_drive_t * drive)
+{
+	sgiioc4_ide_dma_end(drive);
+	sgiioc4_clearirq(drive);
+}
+
+static void
+sgiioc4_maskproc(ide_drive_t * drive, int mask)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	hwif->OUTB(mask ? (drive->ctl | 2) : (drive->ctl & ~2), IDE_CONTROL_REG);
+}
+
+static void __init
+ide_init_sgiioc4(ide_hwif_t * hwif)
+{
+	hwif->autodma = 1;
+	hwif->index = 0;	/* Channel 0 */
+	hwif->channel = 0;
+	hwif->atapi_dma = 1;
+	hwif->ultra_mask = 0x0;	/* Disable Ultra DMA */
+	hwif->mwdma_mask = 0x2;	/* Multimode-2 DMA  */
+	hwif->swdma_mask = 0x2;
+	hwif->identify = NULL;
+	hwif->tuneproc = NULL;	/* Sets timing for PIO mode */
+	hwif->speedproc = NULL;	/* Sets timing for DMA &/or PIO modes */
+	hwif->selectproc = NULL;	/* Use the default selection routine to select drive */
+	hwif->reset_poll = NULL;	/* No HBA specific reset_poll needed */
+	hwif->pre_reset = NULL;	/* No HBA specific pre_set needed */
+	hwif->resetproc = &sgiioc4_resetproc;	/* Reset the IOC4 DMA engine, clear interrupts etc */
+	hwif->intrproc = NULL;	/* Enable or Disable interrupt from drive */
+	hwif->maskproc = &sgiioc4_maskproc;	/* Mask on/off NIEN register */
+	hwif->quirkproc = NULL;
+	hwif->busproc = NULL;
+
+	hwif->ide_dma_read = &sgiioc4_ide_dma_read;
+	hwif->ide_dma_write = &sgiioc4_ide_dma_write;
+	hwif->ide_dma_begin = &sgiioc4_ide_dma_begin;
+	hwif->ide_dma_end = &sgiioc4_ide_dma_end;
+	hwif->ide_dma_check = &sgiioc4_ide_dma_check;
+	hwif->ide_dma_on = &sgiioc4_ide_dma_on;
+	hwif->ide_dma_off = &sgiioc4_ide_dma_off;
+	hwif->ide_dma_off_quietly = &sgiioc4_ide_dma_off_quietly;
+	hwif->ide_dma_test_irq = &sgiioc4_ide_dma_test_irq;
+	hwif->ide_dma_host_on = &sgiioc4_ide_dma_host_on;
+	hwif->ide_dma_host_off = &sgiioc4_ide_dma_host_off;
+	hwif->ide_dma_bad_drive = &__ide_dma_bad_drive;
+	hwif->ide_dma_good_drive = &__ide_dma_good_drive;
+	hwif->ide_dma_count = &sgiioc4_ide_dma_count;
+	hwif->ide_dma_verbose = &sgiioc4_ide_dma_verbose;
+	hwif->ide_dma_retune = &__ide_dma_retune;
+	hwif->ide_dma_lostirq = &sgiioc4_ide_dma_lostirq;
+	hwif->ide_dma_timeout = &sgiioc4_ide_dma_timeout;
+	hwif->INB = &sgiioc4_INB;
+}
+
+static int
+sgiioc4_ide_dma_read(ide_drive_t * drive)
+{
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int count = 0;
+#if SGIIOC4_HD_SUPPORT
+	task_ioreg_t command = WIN_NOP;
+	u8 lba48 = (drive->addressing == 1) ? 1 : 0;
+#endif /* SGIIOC4_HD_SUPPORT */
+
+	if (!(count = sgiioc4_build_dma_table(drive, rq, PCI_DMA_FROMDEVICE))) {
+		/* try PIO instead of DMA */
+		return 1;
+	}
+	/* Writes FROM the IOC4 TO Main Memory */
+	sgiioc4_configure_for_dma(IOC4_DMA_WRITE, drive);
+
+#if SGIIOC4_HD_SUPPORT
+	if (drive->media != ide_disk)	/* Command will be issued by the cdrom.c layer */
+		return 0;
+
+	/* Hard Disks not supported on IOC4 as yet (05/22/2003) ... this code will be useful when Disks are supported */
+	command = (lba48) ? WIN_READDMA_EXT : WIN_READDMA;
+	if (rq->cmd == IDE_DRIVE_TASKFILE) {
+		ide_task_t *args = rq->special;
+		command = args->tfRegister[IDE_COMMAND_OFFSET];
+	}
+
+	/* issue cmd to drive */
+	ide_execute_command(drive, command, &ide_dma_intr, 2 * WAIT_CMD,
+			    dma_timer_expiry);
+	return HWIF(drive)->ide_dma_count(drive);
+#else /* SGIIOC4_HD_SUPPORT */
+	return 0;
+#endif /* SGIIOC4_HD_SUPPORT */
+}
+
+static int
+sgiioc4_ide_dma_write(ide_drive_t * drive)
+{
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int count = 0;
+#if SGIIOC4_HD_SUPPORT
+	task_ioreg_t command = WIN_NOP;
+	u8 lba48 = (drive->addressing == 1) ? 1 : 0;
+#endif /* SGIIOC4_HD_SUPPORT */
+
+	if (!(count = sgiioc4_build_dma_table(drive, rq, PCI_DMA_TODEVICE))) {
+		/* try PIO instead of DMA */
+		return 1;
+	}
+
+	sgiioc4_configure_for_dma(IOC4_DMA_READ, drive);
+	/* Writes TO the IOC4 FROM Main Memory */
+
+#if SGIIOC4_HD_SUPPORT
+	if (drive->media != ide_disk)	/* Command will be issued by the cdrom.c layer */
+		return 0;
+
+	/* Hard Disks not supported on IOC4 as yet (05/22/2003) ... this code will be useful when Disks are supported */
+	command = (lba48) ? WIN_READDMA_EXT : WIN_READDMA;
+	if (rq->cmd == IDE_DRIVE_TASKFILE) {
+		ide_task_t *args = rq->special;
+		command = args->tfRegister[IDE_COMMAND_OFFSET];
+	}
+
+	/* issue cmd to drive */
+	ide_execute_command(drive, command, &ide_dma_intr, 2 * WAIT_CMD,
+			    dma_timer_expiry);
+	return HWIF(drive)->ide_dma_count(drive);
+#else /* SGIIOC4_HD_SUPPORT */
+	return 0;
+#endif /* SGIIOC4_HD_SUPPORT */
+}
+
+static int
+sgiioc4_ide_dma_begin(ide_drive_t * drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	unsigned int reg = hwif->INL(hwif->dma_base + IOC4_DMA_CTRL * 4);
+	unsigned int temp_reg = reg | IOC4_S_DMA_START;
+
+	hwif->OUTL(temp_reg, hwif->dma_base + IOC4_DMA_CTRL * 4);
+
+	return 0;
+}
+
+/* Stops the IOC4 DMA Engine */
+static int
+sgiioc4_ide_dma_end(ide_drive_t * drive)
+{
+	u32 ioc4_dma, bc_dev, bc_mem, num, valid = 0, cnt = 0;
+	ide_hwif_t *hwif = HWIF(drive);
+	uint64_t dma_base = hwif->dma_base;
+	int dma_stat = 0, count;
+	unsigned long *ending_dma = (unsigned long *) hwif->dma_base2;
+
+	hwif->OUTL(IOC4_S_DMA_STOP, dma_base + IOC4_DMA_CTRL * 4);
+
+	count = 0;
+	do {
+		xide_delay(count);
+		ioc4_dma = hwif->INL(dma_base + IOC4_DMA_CTRL * 4);
+		count += 10;
+	} while ((ioc4_dma & IOC4_S_DMA_STOP) && (count < 100));
+
+	if (ioc4_dma & IOC4_S_DMA_STOP) {
+		printk(KERN_ERR "sgiioc4_stopdma(%s): IOC4 DMA STOP bit is still 1 : ioc4_dma_reg 0x%x\n", drive->name, ioc4_dma);
+		dma_stat = 1;
+	}
+
+	if (ending_dma) {
+		do {
+			for (num = 0; num < 16; num++) {
+				if (ending_dma[num] & (~0ul)) {
+					valid = 1;
+					break;
+				}
+			}
+			xide_delay(cnt);
+		} while ((cnt++ < 100) && (!valid));
+	}
+
+	if (!valid)
+		printk(KERN_INFO "sgiioc4_ide_dma_end(%s) : Stale DMA Data in Memory\n", drive->name);
+
+	bc_dev = hwif->INL(dma_base + IOC4_BC_DEV * 4);
+	bc_mem = hwif->INL(dma_base + IOC4_BC_MEM * 4);
+
+	if ((bc_dev & 0x01FF) || (bc_mem & 0x1FF)) {
+		if (bc_dev > bc_mem + 8) {
+			printk(KERN_ERR "sgiioc4_ide_dma_end(%s) : WARNING!!! byte_count_at_dev %d != byte_count_at_mem %d\n",
+			       drive->name, bc_dev, bc_mem);
+		}
+	}
+
+	drive->waiting_for_dma = 0;
+	ide_destroy_dmatable(drive);
+
+	return dma_stat;
+}
+
+static int
+sgiioc4_ide_dma_check(ide_drive_t * drive)
+{
+	if (ide_config_drive_speed(drive,XFER_MW_DMA_2)!=0) {
+		printk(KERN_INFO "Couldnot set %s in Multimode-2 DMA mode | Drive %s using PIO instead\n",
+				drive->name, drive->name);
+		drive->using_dma = 0;
+	} else
+		drive->using_dma = 1;
+
+	return 0;
+}
+
+static int
+sgiioc4_ide_dma_on(ide_drive_t * drive)
+{
+	drive->using_dma = 1;
+
+	return HWIF(drive)->ide_dma_host_on(drive);
+}
+
+static int
+sgiioc4_ide_dma_off(ide_drive_t * drive)
+{
+	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
+
+	return HWIF(drive)->ide_dma_off_quietly(drive);
+}
+
+static int
+sgiioc4_ide_dma_off_quietly(ide_drive_t * drive)
+{
+	drive->using_dma = 0;
+
+	return HWIF(drive)->ide_dma_host_off(drive);
+}
+
+/* returns 1 if dma irq issued, 0 otherwise */
+static int
+sgiioc4_ide_dma_test_irq(ide_drive_t * drive)
+{
+	return sgiioc4_checkirq(HWIF(drive));
+}
+
+static int
+sgiioc4_ide_dma_host_on(ide_drive_t * drive)
+{
+	if (drive->using_dma)
+		return 0;
+
+	return 1;
+}
+
+static int
+sgiioc4_ide_dma_host_off(ide_drive_t * drive)
+{
+	sgiioc4_clearirq(drive);
+
+	return 0;
+}
+
+static int
+sgiioc4_ide_dma_count(ide_drive_t * drive)
+{
+	return HWIF(drive)->ide_dma_begin(drive);
+}
+
+static int
+sgiioc4_ide_dma_verbose(ide_drive_t * drive)
+{
+	if (drive->using_dma == 1)
+		printk(", UDMA(16)");
+	else
+		printk(", PIO");
+
+	return 1;
+}
+
+static int
+sgiioc4_ide_dma_lostirq(ide_drive_t * drive)
+{
+	HWIF(drive)->resetproc(drive);
+
+	return __ide_dma_lostirq(drive);
+}
+
+static int
+sgiioc4_ide_dma_timeout(ide_drive_t * drive)
+{
+	printk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
+	if (HWIF(drive)->ide_dma_test_irq(drive))
+		return 0;
+
+	return HWIF(drive)->ide_dma_end(drive);
+}
+
+static u8
+sgiioc4_INB(unsigned long port)
+{
+	u8 reg = (u8) inb(port);
+
+	if ((port & 0xFFF) == 0x11C) {	/* Status register of IOC4 */
+		if (reg & 0x51) {	/* Not busy...check for interrupt */
+			unsigned long other_ir = port - 0x110;
+			unsigned int intr_reg = (u32) inl(other_ir);
+
+			if (intr_reg & 0x03) {
+				/* Clear the Interrupt, Error bits on the IOC4 */
+				outl(0x03, other_ir);
+				intr_reg = (u32) inl(other_ir);
+			}
+		}
+	}
+
+	return reg;
+}
+
+/* Creates a dma map for the scatter-gather list entries */
+static void __init
+ide_dma_sgiioc4(ide_hwif_t * hwif, unsigned long dma_base)
+{
+	int num_ports = sizeof (ioc4_dma_regs_t);
+
+	printk(KERN_INFO "%s: BM-DMA at 0x%04lx-0x%04lx\n", hwif->name, dma_base, dma_base + num_ports - 1);
+
+	if (!request_region(dma_base, num_ports, hwif->name)) {
+		printk(KERN_ERR "ide_dma_sgiioc4(%s) -- Error, Port Addresses 0x%p to 0x%p ALREADY in use\n",
+		       hwif->name, (void *)dma_base, (void *)dma_base + num_ports - 1);
+		return;
+	}
+
+	hwif->dma_base = dma_base;
+	hwif->dmatable_cpu = pci_alloc_consistent(hwif->pci_dev,
+						  IOC4_PRD_ENTRIES * IOC4_PRD_BYTES,	/* 1 Page */
+						  &hwif->dmatable_dma);
+
+	if (!hwif->dmatable_cpu)
+		goto dma_alloc_failure;
+
+	hwif->sg_table = kmalloc(sizeof (struct scatterlist) * IOC4_PRD_ENTRIES, GFP_KERNEL);
+
+	if (!hwif->sg_table) {
+		pci_free_consistent(hwif->pci_dev, IOC4_PRD_ENTRIES * IOC4_PRD_BYTES, hwif->dmatable_cpu, hwif->dmatable_dma);
+		goto dma_alloc_failure;
+	}
+
+	hwif->dma_base2 = (unsigned long) pci_alloc_consistent(hwif->pci_dev, IOC4_IDE_CACHELINE_SIZE,
+							       (dma_addr_t*)&(hwif->dma_status));
+
+	if (!hwif->dma_base2) {
+		pci_free_consistent(hwif->pci_dev, IOC4_PRD_ENTRIES * IOC4_PRD_BYTES, hwif->dmatable_cpu, hwif->dmatable_dma);
+		kfree(hwif->sg_table);
+		goto dma_alloc_failure;
+	}
+
+	return;
+
+ dma_alloc_failure:
+	printk(KERN_INFO "ide_dma_sgiioc4() -- Error! Unable to allocate DMA Maps for drive %s\n", hwif->name);
+	printk(KERN_INFO "Changing from DMA to PIO mode for Drive %s \n", hwif->name);
+
+	/* Disable DMA because we couldnot allocate any DMA maps */
+	hwif->autodma = 0;
+	hwif->atapi_dma = 0;
+}
+
+/* Initializes the IOC4 DMA Engine */
+static void
+sgiioc4_configure_for_dma(int dma_direction, ide_drive_t * drive)
+{
+	u32 ioc4_dma;
+	int count;
+	ide_hwif_t *hwif = HWIF(drive);
+	uint64_t dma_base = hwif->dma_base;
+	uint32_t dma_addr, ending_dma_addr;
+
+	ioc4_dma = hwif->INL(dma_base + IOC4_DMA_CTRL * 4);
+
+	if (ioc4_dma & IOC4_S_DMA_ACTIVE) {
+		printk(KERN_WARNING "sgiioc4_configure_for_dma(%s):Warning!! IOC4 DMA from previous transfer was still active\n",
+			drive->name);
+		hwif->OUTL(IOC4_S_DMA_STOP, dma_base + IOC4_DMA_CTRL * 4);
+		count = 0;
+		do {
+			xide_delay(count);
+			ioc4_dma = hwif->INL(dma_base + IOC4_DMA_CTRL * 4);
+			count += 10;
+		} while ((ioc4_dma & IOC4_S_DMA_STOP) && (count < 100));
+
+		if (ioc4_dma & IOC4_S_DMA_STOP)
+			printk(KERN_ERR "sgiioc4_configure_for__dma(%s) : IOC4 Dma STOP bit is still 1\n", drive->name);
+	}
+
+	ioc4_dma = hwif->INL(dma_base + IOC4_DMA_CTRL * 4);
+	if (ioc4_dma & IOC4_S_DMA_ERROR) {
+		printk(KERN_WARNING "sgiioc4_configure_for__dma(%s) : Warning!! - DMA Error during Previous transfer | status 0x%x \n",
+		       drive->name, ioc4_dma);
+		hwif->OUTL(IOC4_S_DMA_STOP, dma_base + IOC4_DMA_CTRL * 4);
+		count = 0;
+		do {
+			ioc4_dma = hwif->INL(dma_base + IOC4_DMA_CTRL * 4);
+			xide_delay(count);
+			count += 10;
+		} while ((ioc4_dma & IOC4_S_DMA_STOP) && (count < 100));
+
+		if (ioc4_dma & IOC4_S_DMA_STOP)
+			printk(KERN_ERR "sgiioc4_configure_for__dma(%s) : IOC4 DMA STOP bit is still 1\n", drive->name);
+	}
+
+	/* Address of the Scatter Gather List */
+	dma_addr = cpu_to_le32(hwif->dmatable_dma);
+	hwif->OUTL(dma_addr, dma_base + IOC4_DMA_PTR_L * 4);
+
+	/* Address of the Ending DMA */
+	memset((unsigned int *) hwif->dma_base2, 0,IOC4_IDE_CACHELINE_SIZE);
+	ending_dma_addr = cpu_to_le32(hwif->dma_status);
+	hwif->OUTL(ending_dma_addr,dma_base + IOC4_DMA_END_ADDR * 4);
+
+	hwif->OUTL(dma_direction, dma_base + IOC4_DMA_CTRL * 4);
+	drive->waiting_for_dma = 1;
+}
+
+/* IOC4 Scatter Gather list Format 						*/
+/* 128 Bit entries to support 64 bit addresses in the future			*/
+/* The Scatter Gather list Entry should be in the BIG-ENDIAN Format		*/
+/* ---------------------------------------------------------------------------	*/
+/* | Upper 32 bits - Zero 		| 	Lower 32 bits- address	     |	*/
+/* ---------------------------------------------------------------------------	*/
+/* | Upper 32 bits - Zero		|EOL|	 16 Bit Data Length	     |	*/
+/* ---------------------------------------------------------------------------	*/
+
+/* Creates the scatter gather list, DMA Table */
+static unsigned int
+sgiioc4_build_dma_table(ide_drive_t * drive, struct request *rq, int ddir)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	unsigned int *table = hwif->dmatable_cpu;
+	unsigned int count = 0, i = 1;
+	struct scatterlist *sg;
+
+	if (rq->cmd == IDE_DRIVE_TASKFILE)
+		hwif->sg_nents = i = sgiioc4_ide_raw_build_sglist(hwif, rq);
+	else
+		hwif->sg_nents = i = sgiioc4_ide_build_sglist(hwif, rq, ddir);
+
+	if (!i)
+		return 0;	/* sglist of length Zero */
+
+	sg = hwif->sg_table;
+	while (i && sg_dma_len(sg)) {
+		dma_addr_t cur_addr;
+		int cur_len;
+		cur_addr = sg_dma_address(sg);
+		cur_len = sg_dma_len(sg);
+
+		while (cur_len) {
+			if (count++ >= IOC4_PRD_ENTRIES) {
+				printk(KERN_WARNING "%s: DMA table too small\n", drive->name);
+				goto use_pio_instead;
+			} else {
+				uint32_t xcount, bcount = 0x10000 - (cur_addr & 0xffff);
+
+				if (bcount > cur_len)
+					bcount = cur_len;
+
+				/* put the addr, length in the IOC4 dma-table format */
+				*table = 0x0;
+				table++;
+				*table = cpu_to_be32(cur_addr);
+				table++;
+				*table = 0x0;
+				table++;
+
+				xcount = bcount & 0xffff;
+				*table = cpu_to_be32(xcount);
+				table++;
+
+				cur_addr += bcount;
+				cur_len -= bcount;
+			}
+		}
+
+		sg++;
+		i--;
+	}
+
+	if (count) {
+		table--;
+		*table |= cpu_to_be32(0x80000000);
+		return count;
+	}
+
+      use_pio_instead:
+	pci_unmap_sg(hwif->pci_dev, hwif->sg_table, hwif->sg_nents, hwif->sg_dma_direction);
+	hwif->sg_dma_active = 0;
+
+	return 0;		/* revert to PIO for this request */
+}
+
+static int
+sgiioc4_checkirq(ide_hwif_t * hwif)
+{
+	uint8_t intr_reg = hwif->INL(hwif->io_ports[IDE_IRQ_OFFSET] + IOC4_INTR_REG * 4);
+
+	if (intr_reg & 0x03)
+		return 1;
+
+	return 0;
+}
+
+static int
+sgiioc4_clearirq(ide_drive_t * drive)
+{
+	u32 intr_reg;
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_ioreg_t other_ir = hwif->io_ports[IDE_IRQ_OFFSET] + (IOC4_INTR_REG << 2);
+
+	/* Code to check for PCI error conditions */
+	intr_reg = hwif->INL(other_ir);
+	if (intr_reg & 0x03) {
+		/* Valid IOC4-IDE interrupt */
+		u8 stat = hwif->INB(IDE_STATUS_REG);
+		int count = 0;
+		do {
+			xide_delay(count);
+			stat = hwif->INB(IDE_STATUS_REG);	/* Removes Interrupt from IDE Device */
+		} while ((stat & 0x80) && (count++ < 1024));
+
+		if (intr_reg & 0x02) {
+			/* Error when transferring DMA data on PCI bus */
+			uint32_t pci_err_addr_low, pci_err_addr_high, pci_stat_cmd_reg;
+
+			pci_err_addr_low = hwif->INL(hwif->io_ports[IDE_IRQ_OFFSET]);
+			pci_err_addr_high = hwif->INL(hwif->io_ports[IDE_IRQ_OFFSET] + 4);
+			pci_read_config_dword(hwif->pci_dev, PCI_COMMAND, &pci_stat_cmd_reg);
+			printk(KERN_ERR "sgiioc4_clearirq(%s) : PCI Bus Error when doing DMA : status-cmd reg is 0x%x \n", drive->name, pci_stat_cmd_reg);
+			printk(KERN_ERR "sgiioc4_clearirq(%s) : PCI Error Address is 0x%x%x \n", drive->name, pci_err_addr_high, pci_err_addr_low);
+			/* Clear the PCI Error indicator */
+			pci_write_config_dword(hwif->pci_dev, PCI_COMMAND, 0x00000146);
+		}
+
+		hwif->OUTL(0x03, other_ir);	/* Clear the Interrupt, Error bits on the IOC4 */
+
+		intr_reg = hwif->INL(other_ir);
+	}
+
+	return intr_reg;
+}
+
+/**
+ * 	"Copied from drivers/ide/ide-dma.c"
+ *	sgiioc4_ide_build_sglist - map IDE scatter gather for DMA I/O
+ *	@hwif: the interface to build the DMA table for
+ *	@rq: the request holding the sg list
+ *	@ddir: data direction
+ *
+ *	Perform the PCI mapping magic neccessary to access the source
+ *	or target buffers of a request via PCI DMA. The lower layers
+ *	of the kernel provide the neccessary cache management so that
+ *	we can operate in a portable fashion.
+ *
+ *	This code is identical to ide_build_sglist in ide-dma.c
+ *	however that it not exported and even if it were would create
+ *	dependancy problems for modular drivers.
+ */
+static int
+sgiioc4_ide_build_sglist(ide_hwif_t * hwif, struct request *rq, int ddir)
+{
+	struct buffer_head *bh;
+	struct scatterlist *sg = hwif->sg_table;
+	unsigned long lastdataend = ~0UL;
+	int nents = 0;
+
+	if (hwif->sg_dma_active)
+		BUG();
+
+	bh = rq->bh;
+	do {
+		int contig = 0;
+
+		if (bh->b_page) {
+			if (bh_phys(bh) == lastdataend)
+				contig = 1;
+		} else {
+			if ((unsigned long) bh->b_data == lastdataend)
+				contig = 1;
+		}
+
+		if (contig) {
+			sg[nents - 1].length += bh->b_size;
+			lastdataend += bh->b_size;
+			continue;
+		}
+
+		if (nents >= PRD_ENTRIES)
+			return 0;
+
+		memset(&sg[nents], 0, sizeof (*sg));
+
+		if (bh->b_page) {
+			sg[nents].page = bh->b_page;
+			sg[nents].offset = bh_offset(bh);
+			lastdataend = bh_phys(bh) + bh->b_size;
+		} else {
+			if ((unsigned long) bh->b_data < PAGE_SIZE)
+				BUG();
+
+			sg[nents].address = bh->b_data;
+			lastdataend = (unsigned long) bh->b_data + bh->b_size;
+		}
+
+		sg[nents].length = bh->b_size;
+		nents++;
+	} while ((bh = bh->b_reqnext) != NULL);
+
+	if (nents == 0)
+		BUG();
+
+	hwif->sg_dma_direction = ddir;
+	return pci_map_sg(hwif->pci_dev, sg, nents, ddir);
+}
+
+/**
+ * 	Copied from drivers/ide/ide-dma.c
+ *	sgiioc4_ide_raw_build_sglist	-	map IDE scatter gather for DMA
+ *	@hwif: the interface to build the DMA table for
+ *	@rq: the request holding the sg list
+ *
+ *	Perform the PCI mapping magic neccessary to access the source or
+ *	target buffers of a taskfile request via PCI DMA. The lower layers
+ *	of the  kernel provide the neccessary cache management so that we can
+ *	operate in a portable fashion
+ *
+ *	This code is identical to ide_raw_build_sglist in ide-dma.c
+ *	however that it not exported and even if it were would create
+ *	dependancy problems for modular drivers.
+ */
+static int
+sgiioc4_ide_raw_build_sglist(ide_hwif_t * hwif, struct request *rq)
+{
+	struct scatterlist *sg = hwif->sg_table;
+	int nents = 0;
+	ide_task_t *args = rq->special;
+	u8 *virt_addr = rq->buffer;
+	int sector_count = rq->nr_sectors;
+
+	if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
+		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
+	else
+		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
+#if 1
+	if (sector_count > 128) {
+		memset(&sg[nents], 0, sizeof (*sg));
+		sg[nents].address = virt_addr;
+		sg[nents].length = 128 * SECTOR_SIZE;
+		nents++;
+		virt_addr = virt_addr + (128 * SECTOR_SIZE);
+		sector_count -= 128;
+	}
+	memset(&sg[nents], 0, sizeof (*sg));
+	sg[nents].address = virt_addr;
+	sg[nents].length = sector_count * SECTOR_SIZE;
+	nents++;
+#else
+	while (sector_count > 128) {
+		memset(&sg[nents], 0, sizeof (*sg));
+		sg[nents].address = virt_addr;
+		sg[nents].length = 128 * SECTOR_SIZE;
+		nents++;
+		virt_addr = virt_addr + (128 * SECTOR_SIZE);
+		sector_count -= 128;
+	};
+	memset(&sg[nents], 0, sizeof (*sg));
+	sg[nents].address = virt_addr;
+	sg[nents].length = sector_count * SECTOR_SIZE;
+	nents++;
+#endif
+	return pci_map_sg(hwif->pci_dev, sg, nents, hwif->sg_dma_direction);
+}
+
+#ifdef CONFIG_PROC_FS
+
+static int
+sgiioc4_get_info(char *buffer, char **addr, off_t offset, int count)
+{
+	char *p = buffer;
+	unsigned int class_rev;
+	int i = 0;
+
+	while (i < n_sgiioc4_devs) {
+		pci_read_config_dword(sgiioc4_devs[i], PCI_CLASS_REVISION,
+				      &class_rev);
+		class_rev &= 0xff;
+
+		if (sgiioc4_devs[i]->device == PCI_DEVICE_ID_SGI_IOC4) {
+			p += sprintf(p, "\n	SGI IOC4 Chipset rev %d. ", class_rev);
+			p += sprintf(p, "\n	Chipset has 1 IDE channel and supports 2 devices on that channel.");
+			p += sprintf(p, "\n	Chipset supports DMA in MultiMode-2 data transfer protocol.\n");
+			/* Do we need more info. here? */
+		}
+		i++;
+	}
+
+	return p - buffer;
+}
+
+#endif /* CONFIG_PROC_FS */
+
+static int __devinit
+sgiioc4_init_one(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	unsigned int class_rev;
+	ide_pci_device_t *d = &sgiioc4_chipsets[id->driver_data];
+	if (dev->device != d->device) {
+		printk(KERN_ERR "Error in sgiioc4_init_one(dev 0x%p | id 0x%p )\n", (void *) dev, (void *) id);
+		BUG();
+	}
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class_rev);
+	class_rev &= 0xff;
+
+	if (class_rev < IOC4_SUPPORTED_FIRMWARE_REV) {
+		printk(KERN_INFO "Disabling the IOC4 IDE Part due to unsupported Firmware Rev (%d). \n",class_rev);
+		printk(KERN_INFO "Please upgrade to Firmware Rev 46 or higher \n");
+		return 0;
+	}
+
+	printk(KERN_INFO "%s: IDE controller at PCI slot %s\n", d->name, dev->slot_name);
+
+	if (pci_init_sgiioc4(dev, d->name))
+		return 0;
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static struct pci_device_id sgiioc4_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_SGI, PCI_DEVICE_ID_SGI_IOC4, PCI_ANY_ID, PCI_ANY_ID, 0x0b4000, 0xFFFFFF, 0 },
+	{ 0 }
+};
+
+static struct pci_driver driver = {
+	.name = "SGI-IOC4 IDE",
+	.id_table = sgiioc4_pci_tbl,
+	.probe = sgiioc4_init_one,
+};
+
+static int
+sgiioc4_ide_init(void)
+{
+	return ide_pci_register_driver(&driver);
+}
+
+static void
+sgiioc4_ide_exit(void)
+{
+	ide_pci_unregister_driver(&driver);
+}
+
+module_init(sgiioc4_ide_init);
+module_exit(sgiioc4_ide_exit);
+
+MODULE_AUTHOR("Aniket Malatpure - Silicon Graphics Inc. (SGI)");
+MODULE_DESCRIPTION("PCI driver module for SGI IOC4 Base-IO Card");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, sgiioc4_pci_tbl);
+
+EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/sgiioc4.h linux-2.4.22-ide/drivers/ide/pci/sgiioc4.h
--- linux-2.4.22/drivers/ide/pci/sgiioc4.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/drivers/ide/pci/sgiioc4.h	Sun Sep 21 01:50:18 2003
@@ -0,0 +1,177 @@
+/*
+ * Copyright (c) 2003 Silicon Graphics, Inc.  All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Further, this software is distributed without any warranty that it is
+ * free of the rightful claim of any third person regarding infringement
+ * or the like.  Any license provided herein, whether implied or
+ * otherwise, applies only to this software file.  Patent licenses, if
+ * any, provided herein do not apply to combinations of this program with
+ * other software, or any other product whatsoever.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
+ * Mountain View, CA  94043, or:
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
+ * http://oss.sgi.com/projects/GenInfo/NoticeExplan
+ */
+
+#ifndef SGIIOC4_H
+#define SGIIOC4_H
+
+#define IDE_ARCH_ACK_INTR	1
+#include <linux/ide.h>
+
+/* IOC4 Specific Definitions */
+#define IOC4_CMD_OFFSET		0x100
+#define IOC4_CTRL_OFFSET	0x120
+#define IOC4_DMA_OFFSET		0x140
+#define IOC4_INTR_OFFSET	0x0
+
+#define IOC4_TIMING		0x00
+#define IOC4_DMA_PTR_L		0x01
+#define IOC4_DMA_PTR_H		0x02
+#define IOC4_DMA_ADDR_L		0x03
+#define IOC4_DMA_ADDR_H		0x04
+#define IOC4_BC_DEV		0x05
+#define IOC4_BC_MEM		0x06
+#define	IOC4_DMA_CTRL		0x07
+#define	IOC4_DMA_END_ADDR	0x08
+
+/* Bits in the IOC4 Control/Status Register */
+#define	IOC4_S_DMA_START	0x01
+#define	IOC4_S_DMA_STOP		0x02
+#define	IOC4_S_DMA_DIR		0x04
+#define	IOC4_S_DMA_ACTIVE	0x08
+#define	IOC4_S_DMA_ERROR	0x10
+#define	IOC4_ATA_MEMERR		0x02
+
+/* Read/Write Directions */
+#define	IOC4_DMA_WRITE		0x04
+#define	IOC4_DMA_READ		0x00
+
+/* Interrupt Register Offsets */
+#define IOC4_INTR_REG		0x03
+#define	IOC4_INTR_SET		0x05
+#define	IOC4_INTR_CLEAR		0x07
+
+#define IOC4_IDE_CACHELINE_SIZE	128
+#define IOC4_SUPPORTED_FIRMWARE_REV 46
+
+
+/* Weeds out non-IDE interrupts to the IOC4 */
+#define ide_ack_intr(hwif)      ((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
+
+#define SGIIOC4_MAX_DEVS	32
+
+#if  defined(CONFIG_PROC_FS)
+#include <linux/stat.h>
+#include <linux/proc_fs.h>
+
+static u8 sgiioc4_proc;
+
+static struct pci_dev *sgiioc4_devs[SGIIOC4_MAX_DEVS];
+static int sgiioc4_get_info(char *, char **, off_t, int);
+
+static ide_pci_host_proc_t sgiioc4_procs[] __initdata = {
+	{
+		.name = "sgiioc4",
+		.set = 1,
+		.get_info = sgiioc4_get_info,
+		.parent = NULL,
+	}
+};
+#endif
+
+typedef volatile struct {
+	u32 timing_reg0;
+	u32 timing_reg1;
+	u32 low_mem_ptr;
+	u32 high_mem_ptr;
+	u32 low_mem_addr;
+	u32 high_mem_addr;
+	u32 dev_byte_count;
+	u32 mem_byte_count;
+	u32 status;
+} ioc4_dma_regs_t;
+
+/* Each Physical Region Descriptor Entry size is 16 bytes (2 * 64 bits) */
+/* IOC4 has only 1 IDE channel */
+#define IOC4_PRD_BYTES       16
+#define IOC4_PRD_ENTRIES     (PAGE_SIZE /IOC4_PRD_BYTES)
+
+typedef enum pciio_endian_e {
+	PCIDMA_ENDIAN_BIG,
+	PCIDMA_ENDIAN_LITTLE
+} pciio_endian_t;
+
+static void sgiioc4_init_hwif_ports(hw_regs_t * hw, ide_ioreg_t data_port, 
+				    ide_ioreg_t ctrl_port, ide_ioreg_t irq_port);
+static void sgiioc4_ide_setup_pci_device(struct pci_dev *dev, const char *name);
+static void sgiioc4_resetproc(ide_drive_t * drive);
+static void sgiioc4_maskproc(ide_drive_t * drive, int mask);
+static void sgiioc4_configure_for_dma(int dma_direction, ide_drive_t * drive);
+static void __init ide_init_sgiioc4(ide_hwif_t * hwif);
+static void __init ide_dma_sgiioc4(ide_hwif_t * hwif, unsigned long dma_base);
+static int sgiioc4_checkirq(ide_hwif_t * hwif);
+static int sgiioc4_clearirq(ide_drive_t * drive);
+static int sgiioc4_get_info(char *buffer, char **addr, off_t offset, int count);
+static int sgiioc4_ide_dma_read(ide_drive_t * drive);
+static int sgiioc4_ide_dma_write(ide_drive_t * drive);
+static int sgiioc4_ide_dma_begin(ide_drive_t * drive);
+static int sgiioc4_ide_dma_end(ide_drive_t * drive);
+static int sgiioc4_ide_dma_check(ide_drive_t * drive);
+static int sgiioc4_ide_dma_on(ide_drive_t * drive);
+static int sgiioc4_ide_dma_off(ide_drive_t * drive);
+static int sgiioc4_ide_dma_off_quietly(ide_drive_t * drive);
+static int sgiioc4_ide_dma_test_irq(ide_drive_t * drive);
+static int sgiioc4_ide_dma_host_on(ide_drive_t * drive);
+static int sgiioc4_ide_dma_host_off(ide_drive_t * drive);
+static int sgiioc4_ide_dma_count(ide_drive_t * drive);
+static int sgiioc4_ide_dma_verbose(ide_drive_t * drive);
+static int sgiioc4_ide_dma_lostirq(ide_drive_t * drive);
+static int sgiioc4_ide_dma_timeout(ide_drive_t * drive);
+static int sgiioc4_ide_build_sglist(ide_hwif_t * hwif, struct request *rq,
+				    int ddir);
+static int sgiioc4_ide_raw_build_sglist(ide_hwif_t * hwif, struct request *rq);
+
+static u8 sgiioc4_INB(unsigned long port);
+static inline void xide_delay(long ticks);
+extern int (*sgiioc4_display_info) (char *, char **, off_t, int);	/* ide-proc.c */
+static unsigned int sgiioc4_build_dma_table(ide_drive_t * drive, struct request *rq,
+					    int ddir);
+static unsigned int __init pci_init_sgiioc4(struct pci_dev *dev, const char *name);
+
+static ide_pci_device_t sgiioc4_chipsets[] __devinitdata = {
+	{		
+		/* Channel 0 */
+		.vendor = PCI_VENDOR_ID_SGI,
+		.device = PCI_DEVICE_ID_SGI_IOC4,
+		.name = "SGIIOC4",
+		.init_chipset = pci_init_sgiioc4,
+		.init_iops = NULL,
+		.init_hwif = ide_init_sgiioc4,
+		.init_dma = ide_dma_sgiioc4,
+		.channels = 1,
+		.autodma = AUTODMA,
+		.enablebits = { { 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00 } },
+		.bootable = ON_BOARD,
+		.extra = 0,
+	}
+};
+
+#endif
diff -urN linux-2.4.22/drivers/ide/pci/siimage.c linux-2.4.22-ide/drivers/ide/pci/siimage.c
--- linux-2.4.22/drivers/ide/pci/siimage.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/pci/siimage.c	Sun Sep 21 01:50:18 2003
@@ -1113,7 +1113,10 @@
 	hwif->pre_reset = &siimage_pre_reset;
 
 	if(is_sata(hwif))
+	{
 		hwif->busproc   = &siimage_busproc;
+		hwif->sata = 1;
+	}
 
 	if (!hwif->dma_base) {
 		hwif->drives[0].autotune = 1;
@@ -1215,5 +1218,7 @@
 MODULE_AUTHOR("Andre Hedrick, Alan Cox");
 MODULE_DESCRIPTION("PCI driver module for SiI IDE");
 MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, siimage_pci_tbl);
 
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/sis5513.c linux-2.4.22-ide/drivers/ide/pci/sis5513.c
--- linux-2.4.22/drivers/ide/pci/sis5513.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/pci/sis5513.c	Sun Sep 21 01:50:18 2003
@@ -989,6 +989,8 @@
 MODULE_DESCRIPTION("PCI driver module for SIS IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, sis5513_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
 
 /*
diff -urN linux-2.4.22/drivers/ide/pci/sl82c105.c linux-2.4.22-ide/drivers/ide/pci/sl82c105.c
--- linux-2.4.22/drivers/ide/pci/sl82c105.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/sl82c105.c	Sun Sep 21 01:50:18 2003
@@ -536,4 +536,6 @@
 MODULE_DESCRIPTION("PCI driver module for W82C105 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, sl82c105_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/slc90e66.c linux-2.4.22-ide/drivers/ide/pci/slc90e66.c
--- linux-2.4.22/drivers/ide/pci/slc90e66.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/slc90e66.c	Sun Sep 21 01:50:18 2003
@@ -409,4 +409,6 @@
 MODULE_DESCRIPTION("PCI driver module for SLC90E66 IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, slc90e66_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/triflex.c linux-2.4.22-ide/drivers/ide/pci/triflex.c
--- linux-2.4.22/drivers/ide/pci/triflex.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/triflex.c	Sun Sep 21 01:50:18 2003
@@ -253,4 +253,6 @@
 MODULE_DESCRIPTION("PCI driver module for Compaq Triflex IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, triflex_pci_tbl);
 
+EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/trm290.c linux-2.4.22-ide/drivers/ide/pci/trm290.c
--- linux-2.4.22/drivers/ide/pci/trm290.c	Fri Jun 13 16:51:33 2003
+++ linux-2.4.22-ide/drivers/ide/pci/trm290.c	Sun Sep 21 01:50:18 2003
@@ -309,7 +309,10 @@
 	u8 reg = 0;
 	struct pci_dev *dev = hwif->pci_dev;
 
-	hwif->addressing = 1;
+	/* LBA48 is only supported for PIO */
+	hwif->addressing = 0;
+	hwif->lba48_pio = 1;
+	
 	hwif->chipset = ide_trm290;
 	cfgbase = pci_resource_start(dev, 4);
 	if ((dev->class & 5) && cfgbase) {
@@ -448,5 +451,7 @@
 MODULE_AUTHOR("Mark Lord");
 MODULE_DESCRIPTION("PCI driver module for Tekram TRM290 IDE");
 MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, trm290_pci_tbl);
 
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/pci/via82cxxx.c linux-2.4.22-ide/drivers/ide/pci/via82cxxx.c
--- linux-2.4.22/drivers/ide/pci/via82cxxx.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/pci/via82cxxx.c	Sun Sep 21 01:50:18 2003
@@ -667,4 +667,6 @@
 MODULE_DESCRIPTION("PCI driver module for VIA IDE");
 MODULE_LICENSE("GPL");
 
+MODULE_DEVICE_TABLE(pci, via_pci_tbl);
+
 EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.22/drivers/ide/raid/hptraid.c linux-2.4.22-ide/drivers/ide/raid/hptraid.c
--- linux-2.4.22/drivers/ide/raid/hptraid.c	Mon Aug 25 13:44:41 2003
+++ linux-2.4.22-ide/drivers/ide/raid/hptraid.c	Sun Sep 21 01:50:18 2003
@@ -18,7 +18,11 @@
    Based on work done by Sren Schmidt for FreeBSD
 
    Changelog:
-   15.06.2003 wweissmann@gmx.at
+   19.08.2003 v0.03 wweissmann@gmx.at
+   	* register the raid volume only if all disks are available
+	* print a warning that raid-(0+)1 failover is not supported
+
+   15.06.2003 v0.02 wweissmann@gmx.at
    	* correct values of raid-1 superbock
 	* re-add check for availability of all disks
 	* fix offset bug in raid-1 (introduced in raid 0+1 implementation)
@@ -584,7 +588,7 @@
 	ide_drive_t *ideinfo;
 	
 	dev = MKDEV(major,minor);
-	ideinfo = get_info_ptr (dev);
+	ideinfo = ide_info_ptr (dev, 0);
 	if (ideinfo==NULL)
 		return 0;
 	
@@ -814,10 +818,6 @@
 			break;
 	}
 
-	/* Initialize the gendisk structure */
-	
-	ataraid_register_disk(device,raid[device].sectors);
-
 	/* Verify that we have all disks */
 
 	count=count_disks(raid+device);
@@ -844,7 +844,17 @@
 					return -ENODEV;
 				}
 			}
+			printk(KERN_WARNING "ataraid%i: raid-0+1 disk failover is not implemented!\n",
+					device);
 		}
+		else if (type == HPT_T_RAID_1) {
+			printk(KERN_WARNING "ataraid%i: raid-1 disk failover is not implemented!\n",
+					device);
+		}	
+		/* Initialize the gendisk structure */
+	
+		ataraid_register_disk(device,raid[device].sectors);
+
 		return 0;
 	}
 	
@@ -856,7 +866,7 @@
  	int retval=-ENODEV;
 	int device,i,count=0;
   	
-	printk(KERN_INFO "Highpoint HPT370 Softwareraid driver for linux version 0.02\n");
+	printk(KERN_INFO "Highpoint HPT370 Softwareraid driver for linux version 0.03\n");
 
 	for(i=0; oplist[i].op; i++) {
 		do
diff -urN linux-2.4.22/drivers/ide/raid/pdcraid.c linux-2.4.22-ide/drivers/ide/raid/pdcraid.c
--- linux-2.4.22/drivers/ide/raid/pdcraid.c	Fri Jun 13 16:51:34 2003
+++ linux-2.4.22-ide/drivers/ide/raid/pdcraid.c	Sun Sep 21 01:50:18 2003
@@ -350,7 +350,7 @@
 	ide_drive_t *ideinfo;
 	
 	dev = MKDEV(major,minor);
-	ideinfo = get_info_ptr (dev);
+	ideinfo = ide_info_ptr (dev, 0);
 	if (ideinfo==NULL)
 		return 0;
 	
diff -urN linux-2.4.22/drivers/ide/raid/silraid.c linux-2.4.22-ide/drivers/ide/raid/silraid.c
--- linux-2.4.22/drivers/ide/raid/silraid.c	Fri Jun 13 16:51:34 2003
+++ linux-2.4.22-ide/drivers/ide/raid/silraid.c	Sun Sep 21 01:50:18 2003
@@ -253,7 +253,7 @@
 	ide_drive_t *ideinfo;
 	
 	dev = MKDEV(major,minor);
-	ideinfo = get_info_ptr (dev);
+	ideinfo = ide_info_ptr (dev, 0);
 	if (ideinfo==NULL)
 		return 0;
 	
diff -urN linux-2.4.22/drivers/scsi/Config.in linux-2.4.22-ide/drivers/scsi/Config.in
--- linux-2.4.22/drivers/scsi/Config.in	Sun Sep 21 01:48:15 2003
+++ linux-2.4.22-ide/drivers/scsi/Config.in	Sun Sep 21 01:50:18 2003
@@ -68,6 +68,11 @@
 dep_tristate 'AM53/79C974 PCI SCSI support' CONFIG_SCSI_AM53C974 $CONFIG_SCSI $CONFIG_PCI
 dep_tristate 'AMI MegaRAID support' CONFIG_SCSI_MEGARAID $CONFIG_SCSI
 
+dep_tristate 'SATA support' CONFIG_SCSI_ATA $CONFIG_SCSI
+#dep_tristate '  Parallel ATA support' CONFIG_SCSI_ATA_PATA $CONFIG_SCSI_ATA
+dep_tristate '  Intel PIIX/ICH support' CONFIG_SCSI_ATA_PIIX $CONFIG_SCSI_ATA $CONFIG_PCI
+dep_tristate '  VIA SATA support' CONFIG_SCSI_SATA_VIA $CONFIG_SCSI_ATA $CONFIG_PCI
+
 dep_tristate 'BusLogic SCSI support' CONFIG_SCSI_BUSLOGIC $CONFIG_SCSI
 if [ "$CONFIG_SCSI_BUSLOGIC" != "n" ]; then
    bool '  Omit FlashPoint support' CONFIG_SCSI_OMIT_FLASHPOINT
diff -urN linux-2.4.22/drivers/scsi/Makefile linux-2.4.22-ide/drivers/scsi/Makefile
--- linux-2.4.22/drivers/scsi/Makefile	Sun Sep 21 01:48:15 2003
+++ linux-2.4.22-ide/drivers/scsi/Makefile	Sun Sep 21 01:50:18 2003
@@ -21,7 +21,7 @@
 
 O_TARGET := scsidrv.o
 
-export-objs	:= scsi_syms.o 53c700.o
+export-objs	:= scsi_syms.o 53c700.o libata-core.o
 mod-subdirs	:= pcmcia ../acorn/scsi
 
 
@@ -136,6 +136,8 @@
 obj-$(CONFIG_SCSI_CPQFCTS)	+= cpqfc.o
 obj-$(CONFIG_SCSI_LASI700)	+= lasi700.o 53c700.o
 obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
+obj-$(CONFIG_SCSI_ATA_PIIX)	+= ata_piix.o libata.o
+obj-$(CONFIG_SCSI_SATA_VIA)	+= sata_via.o libata.o
 
 subdir-$(CONFIG_ARCH_ACORN)	+= ../acorn/scsi
 obj-$(CONFIG_ARCH_ACORN)	+= ../acorn/scsi/acorn-scsi.o
@@ -147,7 +149,7 @@
 obj-$(CONFIG_CHR_DEV_SG)	+= sg.o
 
 list-multi	:= scsi_mod.o sd_mod.o sr_mod.o initio.o a100u2w.o cpqfc.o \
-			zalon7xx_mod.o
+			zalon7xx_mod.o libata.o
 scsi_mod-objs	:= scsi.o hosts.o scsi_ioctl.o constants.o \
 			scsicam.o scsi_proc.o scsi_error.o \
 			scsi_obsolete.o scsi_queue.o scsi_lib.o \
@@ -160,6 +162,7 @@
 zalon7xx_mod-objs := zalon7xx.o ncr53c8xx.o
 cpqfc-objs	:= cpqfcTSinit.o cpqfcTScontrol.o cpqfcTSi2c.o \
 		   cpqfcTSworker.o cpqfcTStrigger.o
+libata-objs	:= libata-core.o libata-scsi.o
 
 include $(TOPDIR)/Rules.make
 
@@ -184,6 +187,9 @@
 
 cpqfc.o: $(cpqfc-objs)
 	$(LD) -r -o $@ $(cpqfc-objs)
+
+libata.o: $(libata-objs)
+	$(LD) -r -o $@ $(libata-objs)
 
 53c8xx_d.h: 53c7,8xx.scr script_asm.pl
 	ln -sf 53c7,8xx.scr fake8.c
diff -urN linux-2.4.22/drivers/scsi/ata_piix.c linux-2.4.22-ide/drivers/scsi/ata_piix.c
--- linux-2.4.22/drivers/scsi/ata_piix.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/drivers/scsi/ata_piix.c	Sun Sep 21 01:50:18 2003
@@ -0,0 +1,647 @@
+/*
+
+    ata_piix.c - Intel PATA/SATA controllers
+
+
+	Copyright 2003 Red Hat Inc
+	Copyright 2003 Jeff Garzik
+
+
+	Copyright header from piix.c:
+
+    Copyright (C) 1998-1999 Andrzej Krzysztofowicz, Author and Maintainer
+    Copyright (C) 1998-2000 Andre Hedrick <andre@linux-ide.org>
+    Copyright (C) 2003 Red Hat Inc <alan@redhat.com>
+
+    May be copied or modified under the terms of the GNU General Public License
+
+	TODO:
+	* check traditional port enable/disable bits in pata port_probe
+
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include "scsi.h"
+#include "hosts.h"
+#include <linux/ata.h>
+
+#define DRV_NAME	"ata_piix"
+#define DRV_VERSION	"0.94"
+
+enum {
+	PIIX_IOCFG		= 0x54, /* IDE I/O configuration register */
+	ICH5_PCS		= 0x92,	/* port control and status */
+
+	PIIX_FLAG_COMBINED	= (1 << 30), /* combined mode possible */
+
+	PIIX_COMB_PRI		= (1 << 0), /* combined mode, PATA primary */
+	PIIX_COMB_SEC		= (1 << 1), /* combined mode, PATA secondary */
+
+	PIIX_80C_PRI		= (1 << 5) | (1 << 4),
+	PIIX_80C_SEC		= (1 << 7) | (1 << 6),
+
+	ich5_pata		= 0,
+	ich5_sata		= 1,
+	piix4_pata		= 2,
+};
+
+static int piix_init_one (struct pci_dev *pdev,
+				    const struct pci_device_id *ent);
+
+static void piix_pata_phy_probe(struct ata_port *ap);
+static void piix_pata_port_probe(struct ata_port *ap);
+
+static void piix_sata_phy_probe(struct ata_port *ap);
+static void piix_sata_port_probe(struct ata_port *ap);
+static void piix_sata_port_disable(struct ata_port *ap);
+static void piix_set_piomode (struct ata_port *ap, struct ata_device *adev,
+			      unsigned int pio);
+static void piix_set_udmamode (struct ata_port *ap, struct ata_device *adev,
+			       unsigned int udma);
+
+static unsigned int in_module_init = 1;
+
+static struct pci_device_id piix_pci_tbl[] = {
+#ifdef CONFIG_SCSI_ATA_PATA
+	{ 0x8086, 0x7111, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix4_pata },
+	{ 0x8086, 0x24db, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_pata },
+	{ 0x8086, 0x25a2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_pata },
+#endif
+
+	{ 0x8086, 0x24d1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },
+	{ 0x8086, 0x24df, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },
+	{ 0x8086, 0x25a3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },
+	{ 0x8086, 0x25b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },
+
+	{ }	/* terminate list */
+};
+
+static struct pci_driver piix_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= piix_pci_tbl,
+	.probe			= piix_init_one,
+	.remove			= ata_pci_remove_one,
+};
+
+static Scsi_Host_Template piix_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.detect			= ata_scsi_detect,
+	.release		= ata_scsi_release,
+	.queuecommand		= ata_scsi_queuecmd,
+	.eh_strategy_handler	= ata_scsi_error,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= ATA_MAX_PRD,
+	.max_sectors		= ATA_MAX_SECTORS,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.use_new_eh_code	= ATA_SHT_NEW_EH_CODE,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME,
+};
+
+static struct ata_host_info piix_pata_ops = {
+	.port_probe		= piix_pata_port_probe,
+	.port_disable		= ata_port_disable,
+	.set_piomode		= piix_set_piomode,
+	.set_udmamode		= piix_set_udmamode,
+
+	.tf_load		= ata_tf_load_pio,
+	.tf_read		= ata_tf_read_pio,
+
+	.phy_probe		= piix_pata_phy_probe,
+
+	.bmdma_start		= ata_bmdma_start_pio,
+};
+
+static struct ata_host_info piix_sata_ops = {
+	.port_probe		= piix_sata_port_probe,
+	.port_disable		= piix_sata_port_disable,
+	.set_piomode		= piix_set_piomode,
+	.set_udmamode		= piix_set_udmamode,
+
+	.tf_load		= ata_tf_load_pio,
+	.tf_read		= ata_tf_read_pio,
+
+	.phy_probe		= piix_sata_phy_probe,
+
+	.bmdma_start		= ata_bmdma_start_pio,
+};
+
+static struct ata_board ata_board_tbl[] = {
+	/* ich5_pata */
+	{
+		.sht		= &piix_sht,
+		.host_flags	= ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST,
+		.pio_mask	= 0x03,	/* pio3-4 */
+		.udma_mask	= ATA_UDMA_MASK_40C, /* FIXME: cbl det */
+		.host_info	= &piix_pata_ops,
+	},
+
+	/* ich5_sata */
+	{
+		.sht		= &piix_sht,
+		.host_flags	= ATA_FLAG_SATA | PIIX_FLAG_COMBINED |
+				  ATA_FLAG_SRST,
+		.pio_mask	= 0x03,	/* pio3-4 */
+		.udma_mask	= 0x7f,	/* udma0-6 ; FIXME */
+		.host_info	= &piix_sata_ops,
+	},
+
+	/* piix4_pata */
+	{
+		.sht		= &piix_sht,
+		.host_flags	= ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST,
+		.pio_mask	= 0x03, /* pio3-4 */
+		.udma_mask	= ATA_UDMA_MASK_40C, /* FIXME: cbl det */
+		.host_info	= &piix_pata_ops,
+	},
+};
+
+static struct pci_bits piix_enable_bits[] = {
+	/* port 0 */
+	{
+		.reg		= 0x41,
+		.width		= 1,
+		.mask		= 0x80,
+		.val		= 0x80,
+	},
+
+	/* port 1 */
+	{
+		.reg		= 0x43,
+		.width		= 1,
+		.mask		= 0x80,
+		.val		= 0x80,
+	},
+};
+
+MODULE_AUTHOR("Andre Hedrick, Alan Cox, Andrzej Krzysztofowicz, Jeff Garzik");
+MODULE_DESCRIPTION("SCSI low-level driver for Intel PIIX/ICH ATA controllers");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, piix_pci_tbl);
+
+/**
+ *	piix_pata_cbl_detect - Probe host controller cable detect info
+ *	@ap: Port for which cable detect info is desired
+ *
+ *	Read 80c cable indicator from SATA PCI device's PCI config
+ *	register.  This register is normally set by firmware (BIOS).
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+static void piix_pata_cbl_detect(struct ata_port *ap)
+{
+	struct pci_dev *pdev = ap->host_set->pdev;
+	u8 tmp, mask;
+
+	/* no 80c support in host controller? */
+	if ((ap->udma_mask & ~ATA_UDMA_MASK_40C) == 0)
+		goto cbl40;
+
+	/* check BIOS cable detect results */
+	mask = ap->port_no == 0 ? PIIX_80C_PRI : PIIX_80C_SEC;
+	pci_read_config_byte(pdev, PIIX_IOCFG, &tmp);
+	if ((tmp & mask) == 0)
+		goto cbl40;
+
+	ap->cbl = ATA_CBL_PATA80;
+	return;
+
+cbl40:
+	ap->cbl = ATA_CBL_PATA40;
+	ap->udma_mask &= ATA_UDMA_MASK_40C;
+}
+
+/**
+ *	piix_pata_port_probe - Probe specified port on PATA host controller
+ *	@ap: Port to probe
+ *
+ *	Probe PATA phy.
+ *
+ *	NOTES:
+ *	This is routine is going away.  Getting absorbed into
+ *	piix_pata_phy_probe.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+static void piix_pata_port_probe(struct ata_port *ap)
+{
+	if (!pci_test_config_bits(ap->host_set->pdev,
+				  &piix_enable_bits[ap->port_no])) {
+		ata_port_disable(ap);
+		printk(KERN_INFO "ata%u: port disabled. ignoring.\n", ap->id);
+		return;
+	}
+
+	ata_port_probe(ap);
+}
+
+/**
+ *	piix_pata_phy_probe - Probe specified port on PATA host controller
+ *	@ap: Port to probe
+ *
+ *	Perform all duties necessary to set up bus for read/write
+ *	transactions.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+static void piix_pata_phy_probe(struct ata_port *ap)
+{
+	/* FIXME: check port enable PCI config bits */
+
+	piix_pata_cbl_detect(ap);
+
+	/* TODO: set timings here */
+}
+
+/**
+ *	piix_pcs_probe - Probe SATA port configuration and status register
+ *	@ap: Port to probe
+ *	@have_port: (output) Non-zero if SATA port is enabled
+ *	@have_device: (output) Non-zero if SATA phy indicates device present
+ *
+ *	Reads SATA PCI device's PCI config register Port Configuration
+ *	and Status (PCS) to determine port and device availability.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+static void piix_pcs_probe (struct ata_port *ap, unsigned int *have_port,
+			    unsigned int *have_device)
+{
+	struct pci_dev *pdev = ap->host_set->pdev;
+	u16 pcs;
+
+	pci_read_config_word(pdev, ICH5_PCS, &pcs);
+
+	/* is SATA port enabled? */
+	if (pcs & (1 << ap->port_no)) {
+		*have_port = 1;
+
+		if (pcs & (1 << (ap->port_no + 4)))
+			*have_device = 1;
+	}
+}
+
+/**
+ *	piix_pcs_disable - Disable SATA port
+ *	@ap: Port to disable
+ *
+ *	Disable SATA phy for specified port.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+static void piix_pcs_disable (struct ata_port *ap)
+{
+	struct pci_dev *pdev = ap->host_set->pdev;
+	u16 pcs;
+
+	pci_read_config_word(pdev, ICH5_PCS, &pcs);
+
+	if (pcs & (1 << ap->port_no)) {
+		pcs &= ~(1 << ap->port_no);
+		pci_write_config_word(pdev, ICH5_PCS, pcs);
+	}
+}
+
+/**
+ *	piix_sata_port_probe - Probe specified port on SATA host controller
+ *	@ap: Port to probe
+ *
+ *	Probe SATA phy.
+ *
+ *	NOTES:
+ *	This is routine is going away.  Getting absorbed into
+ *	piix_sata_phy_probe.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+static void piix_sata_port_probe(struct ata_port *ap)
+{
+	unsigned int have_port = 0, have_dev = 0;
+
+	if (!pci_test_config_bits(ap->host_set->pdev,
+				  &piix_enable_bits[ap->port_no])) {
+		ata_port_disable(ap);
+		printk(KERN_INFO "ata%u: port disabled. ignoring.\n", ap->id);
+		return;
+	}
+
+	piix_pcs_probe(ap, &have_port, &have_dev);
+
+	/* if port not enabled, exit */
+	if (!have_port) {
+		ata_port_disable(ap);
+		printk(KERN_INFO "ata%u: SATA port disabled. ignoring.\n",
+		       ap->id);
+		return;
+	}
+
+	/* if port enabled but no device, disable port and exit */
+	if (!have_dev) {
+		piix_sata_port_disable(ap);
+		printk(KERN_INFO "ata%u: SATA port has no device. disabling.\n",
+		       ap->id);
+		return;
+	}
+
+	ata_port_probe(ap);
+}
+
+/**
+ *	piix_sata_port_disable - Disable SATA port
+ *	@ap: Port to disable.
+ *
+ *	Disable SATA port.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+static void piix_sata_port_disable(struct ata_port *ap)
+{
+	ata_port_disable(ap);
+	piix_pcs_disable(ap);
+}
+
+/**
+ *	piix_sata_phy_probe - Probe specified port on SATA host controller
+ *	@ap: Port to probe
+ *
+ *	Probe SATA port.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+static void piix_sata_phy_probe(struct ata_port *ap)
+{
+	/* FIXME: check port enable PCI config bits */
+
+	ap->cbl = ATA_CBL_SATA;
+
+	/* FIXME: call piix_pcs_probe */
+}
+
+/**
+ *	piix_set_piomode - Initialize host controller PATA PIO timings
+ *	@ap: Port whose timings we are configuring
+ *	@adev: um
+ *	@pio: PIO mode, 0 - 4
+ *
+ *	Set PIO mode for device, in host controller PCI config space.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+static void piix_set_piomode (struct ata_port *ap, struct ata_device *adev,
+			      unsigned int pio)
+{
+	struct pci_dev *dev	= ap->host_set->pdev;
+	unsigned int is_slave	= (adev->flags & ATA_DFLAG_MASTER) ? 0 : 1;
+	unsigned int master_port= ap->port_no ? 0x42 : 0x40;
+	unsigned int slave_port	= 0x44;
+	u16 master_data;
+	u8 slave_data;
+
+	static const	 /* ISP  RTC */
+	u8 timings[][2]	= { { 0, 0 },
+			    { 0, 0 },
+			    { 1, 0 },
+			    { 2, 1 },
+			    { 2, 3 }, };
+
+	pci_read_config_word(dev, master_port, &master_data);
+	if (is_slave) {
+		master_data |= 0x4000;
+		/* enable PPE, IE and TIME */
+		master_data |= 0x0070;
+		pci_read_config_byte(dev, slave_port, &slave_data);
+		slave_data &= (ap->port_no ? 0x0f : 0xf0);
+		slave_data |=
+			(timings[pio][0] << 2) |
+			(timings[pio][1] << (ap->port_no ? 4 : 0));
+	} else {
+		master_data &= 0xccf8;
+		/* enable PPE, IE and TIME */
+		master_data |= 0x0007;
+		master_data |=
+			(timings[pio][0] << 12) |
+			(timings[pio][1] << 8);
+	}
+	pci_write_config_word(dev, master_port, master_data);
+	if (is_slave)
+		pci_write_config_byte(dev, slave_port, slave_data);
+}
+
+/**
+ *	piix_set_udmamode - Initialize host controller PATA PIO timings
+ *	@ap: Port whose timings we are configuring
+ *	@adev: um
+ *	@udma: udma mode, 0 - 6
+ *
+ *	Set UDMA mode for device, in host controller PCI config space.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+static void piix_set_udmamode (struct ata_port *ap, struct ata_device *adev,
+			      unsigned int udma)
+{
+	struct pci_dev *dev	= ap->host_set->pdev;
+	u8 maslave		= ap->port_no ? 0x42 : 0x40;
+	u8 speed		= udma;
+	unsigned int drive_dn	= (ap->port_no ? 2 : 0) + adev->devno;
+	int a_speed		= 3 << (drive_dn * 4);
+	int u_flag		= 1 << drive_dn;
+	int v_flag		= 0x01 << drive_dn;
+	int w_flag		= 0x10 << drive_dn;
+	int u_speed		= 0;
+	int			sitre;
+	u16			reg4042, reg44, reg48, reg4a, reg54;
+	u8			reg55;
+
+	pci_read_config_word(dev, maslave, &reg4042);
+	DPRINTK("reg4042 = 0x%04x\n", reg4042);
+	sitre = (reg4042 & 0x4000) ? 1 : 0;
+	pci_read_config_word(dev, 0x44, &reg44);
+	pci_read_config_word(dev, 0x48, &reg48);
+	pci_read_config_word(dev, 0x4a, &reg4a);
+	pci_read_config_word(dev, 0x54, &reg54);
+	pci_read_config_byte(dev, 0x55, &reg55);
+
+	switch(speed) {
+		case XFER_UDMA_4:
+		case XFER_UDMA_2:	u_speed = 2 << (drive_dn * 4); break;
+		case XFER_UDMA_6:
+		case XFER_UDMA_5:
+		case XFER_UDMA_3:
+		case XFER_UDMA_1:	u_speed = 1 << (drive_dn * 4); break;
+		case XFER_UDMA_0:	u_speed = 0 << (drive_dn * 4); break;
+		default:
+			BUG();
+			return;
+	}
+
+	if (!(reg48 & u_flag))
+		pci_write_config_word(dev, 0x48, reg48|u_flag);
+	if (speed == XFER_UDMA_5) {
+		pci_write_config_byte(dev, 0x55, (u8) reg55|w_flag);
+	} else {
+		pci_write_config_byte(dev, 0x55, (u8) reg55 & ~w_flag);
+	}
+	if (!(reg4a & u_speed)) {
+		pci_write_config_word(dev, 0x4a, reg4a & ~a_speed);
+		pci_write_config_word(dev, 0x4a, reg4a|u_speed);
+	}
+	if (speed > XFER_UDMA_2) {
+		if (!(reg54 & v_flag)) {
+			pci_write_config_word(dev, 0x54, reg54|v_flag);
+		}
+	} else {
+		pci_write_config_word(dev, 0x54, reg54 & ~v_flag);
+	}
+}
+
+/**
+ *	piix_probe_combined - Determine if PATA and SATA are combined
+ *	@pdev: PCI device to examine
+ *	@mask: (output) zero, %PIIX_COMB_PRI or %PIIX_COMB_SEC
+ *
+ *	Determine if BIOS has secretly stuffed a PATA port into our
+ *	otherwise-beautiful SATA PCI device.
+ *
+ *	LOCKING:
+ *	Inherited from PCI layer (may sleep).
+ */
+static void piix_probe_combined (struct pci_dev *pdev, unsigned int *mask)
+{
+	u8 tmp;
+
+	pci_read_config_byte(pdev, 0x90, &tmp); /* combined mode reg */
+	tmp &= 0x6; 	/* interesting bits 2:1, PATA primary/secondary */
+
+	/* backwards from what one might expect */
+	if (tmp == 0x4)	/* bits 10x */
+		*mask |= PIIX_COMB_SEC;
+	if (tmp == 0x6)	/* bits 11x */
+		*mask |= PIIX_COMB_PRI;
+}
+
+/**
+ *	piix_init_one - Register PIIX ATA PCI device with kernel services
+ *	@pdev: PCI device to register
+ *	@ent: Entry in piix_pci_tbl matching with @pdev
+ *
+ *	Called from kernel PCI layer.  We probe for combined mode (sigh),
+ *	and then hand over control to libata, for it to do the rest.
+ *
+ *	LOCKING:
+ *	Inherited from PCI layer (may sleep).
+ *
+ *	RETURNS:
+ *	Zero on success, or -ERRNO value.
+ */
+
+static int piix_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	static int printed_version;
+	struct ata_board *boards[2];
+	unsigned int combined = 0, n_boards = 1;
+	unsigned int pata_comb = 0, sata_comb = 0;
+
+	if (!printed_version++)
+		printk(KERN_DEBUG DRV_NAME " version " DRV_VERSION "\n");
+
+	/* no hotplugging support (FIXME) */
+	if (!in_module_init)
+		return -ENODEV;
+
+	boards[0] = &ata_board_tbl[ent->driver_data];
+	boards[1] = NULL;
+	if (boards[0]->host_flags & PIIX_FLAG_COMBINED)
+		piix_probe_combined(pdev, &combined);
+
+	if (combined & PIIX_COMB_PRI)
+		sata_comb = 1;
+	else if (combined & PIIX_COMB_SEC)
+		pata_comb = 1;
+
+	if (pata_comb || sata_comb) {
+		boards[sata_comb] = &ata_board_tbl[ent->driver_data];
+		boards[sata_comb]->host_flags |= ATA_FLAG_SLAVE_POSS; /* sigh */
+		boards[pata_comb] = &ata_board_tbl[ich5_pata]; /*ich5-specific*/
+		n_boards++;
+
+		printk(KERN_WARNING DRV_NAME ": combined mode detected\n");
+	}
+
+	return ata_pci_init_one(pdev, boards, n_boards);
+}
+
+/**
+ *	piix_init -
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static int __init piix_init(void)
+{
+	int rc;
+
+	DPRINTK("pci_module_init\n");
+	rc = pci_module_init(&piix_pci_driver);
+	if (rc)
+		return rc;
+
+	in_module_init = 0;
+
+	DPRINTK("scsi_register_host\n");
+	rc = scsi_register_module(MODULE_SCSI_HA, &piix_sht);
+	if (rc) {
+		rc = -ENODEV;
+		goto err_out;
+	}
+
+	DPRINTK("done\n");
+	return 0;
+
+err_out:
+	pci_unregister_driver(&piix_pci_driver);
+	return rc;
+}
+
+/**
+ *	piix_exit -
+ *
+ *	LOCKING:
+ *
+ */
+
+static void __exit piix_exit(void)
+{
+	scsi_unregister_module(MODULE_SCSI_HA, &piix_sht);
+	pci_unregister_driver(&piix_pci_driver);
+}
+
+module_init(piix_init);
+module_exit(piix_exit);
+
diff -urN linux-2.4.22/drivers/scsi/ide-scsi.c linux-2.4.22-ide/drivers/scsi/ide-scsi.c
--- linux-2.4.22/drivers/scsi/ide-scsi.c	Mon Aug 25 13:44:42 2003
+++ linux-2.4.22-ide/drivers/scsi/ide-scsi.c	Sun Sep 21 01:50:18 2003
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/scsi/ide-scsi.c	Version 0.93    June 10, 2002
+ * linux/drivers/scsi/ide-scsi.c	Version 0.94    Sept 09, 2003
  *
  * Copyright (C) 1996 - 1999 Gadi Oxman <gadio@netvision.net.il>
  * Copyright (C) 2001 - 2002 Andre Hedrick <andre@linux-ide.org>
@@ -35,9 +35,12 @@
  * Ver 0.92  Mar 21 02   Include DevFs support
  *                        Borsenkow Andrej <Andrej.Borsenkow@mow.siemens.ru>
  * Ver 0.93  Jun 10 02   Fix "off by one" error in transforms
+ * Ver 0.94  Sep 09 03   Added transform for reading ATAPI tape drive block
+ *                        limits (ATAPI tapes report block limits in mode
+ *                        page 0x2A, not by "read block limits" command)
  */
 
-#define IDESCSI_VERSION "0.93"
+#define IDESCSI_VERSION "0.94"
 
 #include <linux/module.h>
 #include <linux/config.h>
@@ -234,6 +237,25 @@
 			pc->buffer_size += 4;
 		}
 	}
+	if (drive->media == ide_tape) {
+		if (sc[0] == READ_BLOCK_LIMITS) {	/* IDE tapes have blk lmts in mode page 0x2a */
+			if (!scsi_buf)
+				return;
+			/* buffer size should be 6 for READ_BLOCK_LIMITS    */
+			/* we need 12 bytes (4 for header + 8 for mode page */
+			if ((atapi_buf = kmalloc(12, GFP_ATOMIC)) == NULL)
+				return;
+			memset(atapi_buf, 0, 12);
+			memset (c, 0, 12);
+			c[0] = MODE_SENSE;
+			c[1] = 8;  	/* no block descriptors     */
+			c[2] = 0x2A;	/* mode page 0x2A           */
+			c[4] = 12;	/* buffer length 12 decimal */
+			pc->buffer = atapi_buf;
+			pc->request_transfer = 12;
+			pc->buffer_size = 12;
+		}
+	}
 }
 
 static inline void idescsi_transform_pc2 (ide_drive_t *drive, idescsi_pc_t *pc)
@@ -262,7 +284,19 @@
 			/* response data format */
 			scsi_buf[3] = (scsi_buf[3] & 0xf0) | 2;
 		}
+	}	
+	if (drive->media == ide_tape) {
+		if (sc[0] == READ_BLOCK_LIMITS) {
+			memset(scsi_buf, 0, pc->scsi_cmd->request_bufflen);
+			/* granularity of 9 (always 9 for ide tapes) */
+			scsi_buf[0] = 9;
+			/* block length of 1024 bytes supported? */
+			scsi_buf[2] = (atapi_buf[11] & 0x04) ? 4 : 2;
+			/* block length of 512 bytes supported?  */
+			scsi_buf[4] = (atapi_buf[11] & 0x02) ? 2 : 4;
+		}
 	}
+
 	if (atapi_buf && atapi_buf != scsi_buf)
 		kfree(atapi_buf);
 }
@@ -573,6 +573,8 @@
 	/* Request to transfer the entire buffer at once */
 	bcount.all = IDE_MIN(pc->request_transfer, 63 * 1024);
 
+	feature.all = 0;
+	
 	if (drive->using_dma && rq->bh) {
 		if (test_bit(PC_WRITING, &pc->flags))
 			feature.b.dma = !HWIF(drive)->ide_dma_write(drive);
diff -urN linux-2.4.22/drivers/scsi/libata-core.c linux-2.4.22-ide/drivers/scsi/libata-core.c
--- linux-2.4.22/drivers/scsi/libata-core.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/drivers/scsi/libata-core.c	Sun Sep 21 01:50:18 2003
@@ -0,0 +1,3128 @@
+/*
+   libata-core.c - helper library for ATA
+
+   Copyright 2003 Red Hat, Inc.  All rights reserved.
+   Copyright 2003 Jeff Garzik
+
+   The contents of this file are subject to the Open
+   Software License version 1.1 that can be found at
+   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+   by reference.
+
+   Alternatively, the contents of this file may be used under the terms
+   of the GNU General Public License version 2 (the "GPL") as distributed
+   in the kernel source COPYING file, in which case the provisions of
+   the GPL are applicable instead of the above.  If you wish to allow
+   the use of your version of this file only under the terms of the
+   GPL and not to allow others to use your version of this file under
+   the OSL, indicate your decision by deleting the provisions above and
+   replace them with the notice and other provisions required by the GPL.
+   If you do not delete the provisions above, a recipient may use your
+   version of this file under either the OSL or the GPL.
+
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/highmem.h>
+#include <linux/spinlock.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/blk.h>
+#include <scsi/scsi.h>
+#include "scsi.h"
+#include "hosts.h"
+#include <linux/ata.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+
+#include "libata.h"
+
+static void ata_qc_complete(struct ata_queued_cmd *qc, u8 drv_stat,
+			    unsigned int done_late);
+static void atapi_cdb_send(struct ata_port *ap);
+static unsigned int ata_busy_sleep (struct ata_port *ap,
+				    unsigned long tmout_pat,
+			    	    unsigned long tmout);
+static u8 __ata_dev_select (struct ata_port *ap, unsigned int device);
+static void ata_qc_push (struct ata_queued_cmd *qc, unsigned int append);
+static void ata_dma_complete(struct ata_port *ap, u8 host_stat,
+			     unsigned int done_late);
+
+static unsigned int ata_unique_id = 1;
+static LIST_HEAD(ata_probe_list);
+static spinlock_t ata_module_lock = SPIN_LOCK_UNLOCKED;
+
+MODULE_AUTHOR("Jeff Garzik");
+MODULE_DESCRIPTION("Library module for ATA devices");
+MODULE_LICENSE("GPL");
+
+static const char * thr_state_name[] = {
+	"THR_UNKNOWN",
+	"THR_CHECKPORT",
+	"THR_BUS_RESET",
+	"THR_AWAIT_DEATH",
+	"THR_IDENTIFY",
+	"THR_CONFIG_TIMINGS",
+	"THR_CONFIG_DMA",
+	"THR_PROBE_FAILED",
+	"THR_IDLE",
+	"THR_PROBE_SUCCESS",
+	"THR_PROBE_START",
+	"THR_CONFIG_FORCE_PIO",
+	"THR_PIO_POLL",
+	"THR_PIO_TMOUT",
+	"THR_PIO",
+	"THR_PIO_LAST",
+	"THR_PIO_LAST_POLL",
+	"THR_PIO_ERR",
+	"THR_PACKET",
+};
+
+/**
+ *	ata_thr_state_name - convert thread state enum to string
+ *	@thr_state: thread state to be converted to string
+ *
+ *	Converts the specified thread state id to a constant C string.
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	RETURNS:
+ *	The THR_xxx-prefixed string naming the specified thread
+ *	state id, or the string "<invalid THR_xxx state>".
+ */
+
+static const char *ata_thr_state_name(unsigned int thr_state)
+{
+	if (thr_state < ARRAY_SIZE(thr_state_name))
+		return thr_state_name[thr_state];
+	return "<invalid THR_xxx state>";
+}
+
+/**
+ *	msleep - sleep for a number of milliseconds
+ *	@msecs: number of milliseconds to sleep
+ *
+ *	Issues schedule_timeout call for the specified number
+ *	of milliseconds.
+ *
+ *	LOCKING:
+ *	None.
+ */
+
+static void msleep(unsigned long msecs)
+{
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(msecs_to_jiffies(msecs));
+}
+
+/**
+ *	ata_tf_load_pio - send taskfile registers to host controller
+ *	@ioaddr: set of IO ports to which output is sent
+ *	@tf: ATA taskfile register set
+ *
+ *	Outputs ATA taskfile to standard ATA host controller using PIO.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
+void ata_tf_load_pio(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	unsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;
+
+	outb(tf->ctl, ioaddr->ctl_addr);
+
+	if (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {
+		outb(tf->hob_feature, ioaddr->cmd_addr + ATA_REG_FEATURE);
+		outb(tf->hob_nsect, ioaddr->cmd_addr + ATA_REG_NSECT);
+		outb(tf->hob_lbal, ioaddr->cmd_addr + ATA_REG_LBAL);
+		outb(tf->hob_lbam, ioaddr->cmd_addr + ATA_REG_LBAM);
+		outb(tf->hob_lbah, ioaddr->cmd_addr + ATA_REG_LBAH);
+		VPRINTK("hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",
+			tf->hob_feature,
+			tf->hob_nsect,
+			tf->hob_lbal,
+			tf->hob_lbam,
+			tf->hob_lbah);
+	}
+
+	if (is_addr) {
+		outb(tf->feature, ioaddr->cmd_addr + ATA_REG_FEATURE);
+		outb(tf->nsect, ioaddr->cmd_addr + ATA_REG_NSECT);
+		outb(tf->lbal, ioaddr->cmd_addr + ATA_REG_LBAL);
+		outb(tf->lbam, ioaddr->cmd_addr + ATA_REG_LBAM);
+		outb(tf->lbah, ioaddr->cmd_addr + ATA_REG_LBAH);
+		VPRINTK("feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X\n",
+			tf->feature,
+			tf->nsect,
+			tf->lbal,
+			tf->lbam,
+			tf->lbah);
+	}
+
+	if (tf->flags & ATA_TFLAG_DEVICE) {
+		outb(tf->device, ioaddr->cmd_addr + ATA_REG_DEVICE);
+		VPRINTK("device 0x%X\n", tf->device);
+	}
+
+	ata_wait_idle(ap);
+}
+
+/**
+ *	ata_tf_load_mmio - send taskfile registers to host controller
+ *	@ioaddr: set of IO ports to which output is sent
+ *	@tf: ATA taskfile register set
+ *
+ *	Outputs ATA taskfile to standard ATA host controller using MMIO.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
+void ata_tf_load_mmio(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	void *mmio = (void *) ap->ioaddr.cmd_addr;
+	unsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;
+
+	writeb(tf->ctl, ap->ioaddr.ctl_addr);
+
+	if (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {
+		writeb(tf->hob_feature, mmio + ATA_REG_FEATURE);
+		writeb(tf->hob_nsect, mmio + ATA_REG_NSECT);
+		writeb(tf->hob_lbal, mmio + ATA_REG_LBAL);
+		writeb(tf->hob_lbam, mmio + ATA_REG_LBAM);
+		writeb(tf->hob_lbah, mmio + ATA_REG_LBAH);
+		VPRINTK("hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",
+			tf->hob_feature,
+			tf->hob_nsect,
+			tf->hob_lbal,
+			tf->hob_lbam,
+			tf->hob_lbah);
+	}
+
+	if (is_addr) {
+		writeb(tf->feature, mmio + ATA_REG_FEATURE);
+		writeb(tf->nsect, mmio + ATA_REG_NSECT);
+		writeb(tf->lbal, mmio + ATA_REG_LBAL);
+		writeb(tf->lbam, mmio + ATA_REG_LBAM);
+		writeb(tf->lbah, mmio + ATA_REG_LBAH);
+		VPRINTK("feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X\n",
+			tf->feature,
+			tf->nsect,
+			tf->lbal,
+			tf->lbam,
+			tf->lbah);
+	}
+
+	if (tf->flags & ATA_TFLAG_DEVICE) {
+		writeb(tf->device, mmio + ATA_REG_DEVICE);
+		VPRINTK("device 0x%X\n", tf->device);
+	}
+
+	ata_wait_idle(ap);
+}
+
+/**
+ *	__ata_exec - issue ATA command to host controller
+ *	@ap: port to which command is being issued
+ *	@tf: ATA taskfile register set
+ *
+ *	Issues PIO write to ATA command register, with proper
+ *	synchronization with interrupt handler / other threads.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+static inline void __ata_exec(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	DPRINTK("ata%u: cmd 0x%X\n", ap->id, tf->command);
+
+	if (ap->flags & ATA_FLAG_MMIO) {
+		void *mmio = (void *) ap->ioaddr.cmd_addr;
+		writeb(tf->command, mmio + ATA_REG_CMD);
+	} else
+		outb(tf->command, ap->ioaddr.cmd_addr + ATA_REG_CMD);
+	ata_pause(ap);
+}
+
+/**
+ *	ata_exec - issue ATA command to host controller
+ *	@ap: port to which command is being issued
+ *	@tf: ATA taskfile register set
+ *
+ *	Issues PIO write to ATA command register, with proper
+ *	synchronization with interrupt handler / other threads.
+ *
+ *	LOCKING:
+ *	Obtains host_set lock.
+ */
+
+static inline void ata_exec(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	unsigned long flags;
+
+	DPRINTK("ata%u: cmd 0x%X\n", ap->id, tf->command);
+	spin_lock_irqsave(&ap->host_set->lock, flags);
+	__ata_exec(ap, tf);
+	spin_unlock_irqrestore(&ap->host_set->lock, flags);
+}
+
+/**
+ *	ata_tf_to_host - issue ATA taskfile to host controller
+ *	@ap: port to which command is being issued
+ *	@tf: ATA taskfile register set
+ *
+ *	Issues ATA taskfile register set to ATA host controller,
+ *	via PIO, with proper synchronization with interrupt handler and
+ *	other threads.
+ *
+ *	LOCKING:
+ *	Obtains host_set lock.
+ */
+
+static void ata_tf_to_host(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	init_MUTEX_LOCKED(&ap->sem);
+
+	ap->ops->tf_load(ap, tf);
+
+	ata_exec(ap, tf);
+}
+
+/**
+ *	ata_tf_to_host_nolock - issue ATA taskfile to host controller
+ *	@ap: port to which command is being issued
+ *	@tf: ATA taskfile register set
+ *
+ *	Issues ATA taskfile register set to ATA host controller,
+ *	via PIO, with proper synchronization with interrupt handler and
+ *	other threads.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+void ata_tf_to_host_nolock(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	init_MUTEX_LOCKED(&ap->sem);
+
+	ap->ops->tf_load(ap, tf);
+
+	__ata_exec(ap, tf);
+}
+
+/**
+ *	ata_tf_read_pio - input device's ATA taskfile shadow registers
+ *	@ioaddr: set of IO ports from which input is read
+ *	@tf: ATA taskfile register set for storing input
+ *
+ *	Reads ATA taskfile registers for currently-selected device
+ *	into @tf via PIO.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
+void ata_tf_read_pio(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+
+	tf->nsect = inb(ioaddr->cmd_addr + ATA_REG_NSECT);
+	tf->lbal = inb(ioaddr->cmd_addr + ATA_REG_LBAL);
+	tf->lbam = inb(ioaddr->cmd_addr + ATA_REG_LBAM);
+	tf->lbah = inb(ioaddr->cmd_addr + ATA_REG_LBAH);
+	tf->device = inb(ioaddr->cmd_addr + ATA_REG_DEVICE);
+
+	if (tf->flags & ATA_TFLAG_LBA48) {
+		outb(tf->ctl | ATA_HOB, ioaddr->ctl_addr);
+		tf->hob_feature = inb(ioaddr->cmd_addr + ATA_REG_FEATURE);
+		tf->hob_nsect = inb(ioaddr->cmd_addr + ATA_REG_NSECT);
+		tf->hob_lbal = inb(ioaddr->cmd_addr + ATA_REG_LBAL);
+		tf->hob_lbam = inb(ioaddr->cmd_addr + ATA_REG_LBAM);
+		tf->hob_lbah = inb(ioaddr->cmd_addr + ATA_REG_LBAH);
+	}
+}
+
+/**
+ *	ata_tf_read_mmio - input device's ATA taskfile shadow registers
+ *	@ioaddr: set of IO ports from which input is read
+ *	@tf: ATA taskfile register set for storing input
+ *
+ *	Reads ATA taskfile registers for currently-selected device
+ *	into @tf via MMIO.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
+void ata_tf_read_mmio(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	void *mmio = (void *) ap->ioaddr.cmd_addr;
+
+	tf->nsect = readb(mmio + ATA_REG_NSECT);
+	tf->lbal = readb(mmio + ATA_REG_LBAL);
+	tf->lbam = readb(mmio + ATA_REG_LBAM);
+	tf->lbah = readb(mmio + ATA_REG_LBAH);
+	tf->device = readb(mmio + ATA_REG_DEVICE);
+
+	if (tf->flags & ATA_TFLAG_LBA48) {
+		writeb(tf->ctl | ATA_HOB, ap->ioaddr.ctl_addr);
+		tf->hob_feature = readb(mmio + ATA_REG_FEATURE);
+		tf->hob_nsect = readb(mmio + ATA_REG_NSECT);
+		tf->hob_lbal = readb(mmio + ATA_REG_LBAL);
+		tf->hob_lbam = readb(mmio + ATA_REG_LBAM);
+		tf->hob_lbah = readb(mmio + ATA_REG_LBAH);
+	}
+}
+
+static const char * udma_str[] = {
+	"UDMA/16",
+	"UDMA/25",
+	"UDMA/33",
+	"UDMA/44",
+	"UDMA/66",
+	"UDMA/100",
+	"UDMA/133",
+	"UDMA7",
+};
+
+/**
+ *	ata_udma_string - convert UDMA bit offset to string
+ *	@udma_mask: mask of bits supported; only highest bit counts.
+ *
+ *	Determine string which represents the highest speed
+ *	(highest bit in @udma_mask).
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	RETURNS:
+ *	Constant C string representing highest speed listed in
+ *	@udma_mask, or the constant C string "<n/a>".
+ */
+
+static const char *ata_udma_string(unsigned int udma_mask)
+{
+	unsigned int i;
+
+	for (i = 7; i >= 0; i--) {
+		if (udma_mask & (1 << i))
+			return udma_str[i];
+	}
+
+	return "<n/a>";
+}
+
+/**
+ *	ata_pio_devchk -
+ *	@ap:
+ *	@device:
+ *
+ *	LOCKING:
+ *
+ */
+
+static unsigned int ata_pio_devchk(struct ata_port *ap,
+				   unsigned int device)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	u8 nsect, lbal;
+
+	__ata_dev_select(ap, device);
+
+	outb(0x55, ioaddr->cmd_addr + ATA_REG_NSECT);
+	outb(0xaa, ioaddr->cmd_addr + ATA_REG_LBAL);
+
+	outb(0xaa, ioaddr->cmd_addr + ATA_REG_NSECT);
+	outb(0x55, ioaddr->cmd_addr + ATA_REG_LBAL);
+
+	outb(0x55, ioaddr->cmd_addr + ATA_REG_NSECT);
+	outb(0xaa, ioaddr->cmd_addr + ATA_REG_LBAL);
+
+	nsect = inb(ioaddr->cmd_addr + ATA_REG_NSECT);
+	lbal = inb(ioaddr->cmd_addr + ATA_REG_LBAL);
+
+	if ((nsect == 0x55) && (lbal == 0xaa))
+		return 1;	/* we found a device */
+
+	return 0;		/* nothing found */
+}
+
+/**
+ *	ata_mmio_devchk -
+ *	@ap:
+ *	@device:
+ *
+ *	LOCKING:
+ *
+ */
+
+static unsigned int ata_mmio_devchk(struct ata_port *ap,
+				    unsigned int device)
+{
+	void *mmio = (void *) ap->ioaddr.cmd_addr;
+	u8 nsect, lbal;
+
+	__ata_dev_select(ap, device);
+
+	writeb(0x55, mmio + ATA_REG_NSECT);
+	writeb(0xaa, mmio + ATA_REG_LBAL);
+
+	writeb(0xaa, mmio + ATA_REG_NSECT);
+	writeb(0x55, mmio + ATA_REG_LBAL);
+
+	writeb(0x55, mmio + ATA_REG_NSECT);
+	writeb(0xaa, mmio + ATA_REG_LBAL);
+
+	nsect = readb(mmio + ATA_REG_NSECT);
+	lbal = readb(mmio + ATA_REG_LBAL);
+
+	if ((nsect == 0x55) && (lbal == 0xaa))
+		return 1;	/* we found a device */
+
+	return 0;		/* nothing found */
+}
+
+/**
+ *	ata_dev_devchk -
+ *	@ap:
+ *	@device:
+ *
+ *	LOCKING:
+ *
+ */
+
+static unsigned int ata_dev_devchk(struct ata_port *ap,
+				    unsigned int device)
+{
+	if (ap->flags & ATA_FLAG_MMIO)
+		return ata_mmio_devchk(ap, device);
+	return ata_pio_devchk(ap, device);
+}
+
+/**
+ *	ata_dev_classify - determine device type based on ATA-spec signature
+ *	@tf: ATA taskfile register set for device to be identified
+ *
+ *	Determine from taskfile register contents whether a device is
+ *	ATA or ATAPI, as per "Signature and persistence" section
+ *	of ATA/PI spec (volume 1, sect 5.14).
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	RETURNS:
+ *	Device type, %ATA_DEV_ATA, %ATA_DEV_ATAPI, or %ATA_DEV_UNKNOWN
+ *	the event of failure.
+ */
+
+static unsigned int ata_dev_classify(struct ata_taskfile *tf)
+{
+	/* Apple's open source Darwin code hints that some devices only
+	 * put a proper signature into the LBA mid/high registers,
+	 * So, we only check those.  It's sufficient for uniqueness.
+	 */
+
+	if (((tf->lbam == 0) && (tf->lbah == 0)) ||
+	    ((tf->lbam == 0x3c) && (tf->lbah == 0xc3))) {
+		DPRINTK("found ATA device by sig\n");
+		return ATA_DEV_ATA;
+	}
+
+	if (((tf->lbam == 0x14) && (tf->lbah == 0xeb)) ||
+	    ((tf->lbam == 0x69) && (tf->lbah == 0x96))) {
+		DPRINTK("found ATAPI device by sig\n");
+		return ATA_DEV_ATAPI;
+	}
+
+	DPRINTK("unknown device\n");
+	return ATA_DEV_UNKNOWN;
+}
+
+/**
+ *	ata_dev_try_classify -
+ *	@ap:
+ *	@device:
+ *
+ *	LOCKING:
+ *
+ */
+
+static u8 ata_dev_try_classify(struct ata_port *ap, unsigned int device,
+			       unsigned int maybe_have_dev)
+{
+	struct ata_device *dev = &ap->device[device];
+	struct ata_taskfile tf;
+	unsigned int class;
+	u8 err;
+
+	__ata_dev_select(ap, device);
+
+	memset(&tf, 0, sizeof(tf));
+
+	err = ata_chk_err(ap);
+	ap->ops->tf_read(ap, &tf);
+
+	dev->class = ATA_DEV_NONE;
+
+	/* see if device passed diags */
+	if (err == 1)
+		/* do nothing */ ;
+	else if ((device == 0) && (err == 0x81))
+		/* do nothing */ ;
+	else
+		return err;
+
+	/* determine if device if ATA or ATAPI */
+	class = ata_dev_classify(&tf);
+	if (class == ATA_DEV_UNKNOWN)
+		return err;
+	if ((class == ATA_DEV_ATA) && (ata_chk_status(ap) == 0))
+		return err;
+
+	dev->class = class;
+
+	return err;
+}
+
+/**
+ *	ata_dev_id_string -
+ *	@dev:
+ *	@s:
+ *	@ofs:
+ *	@len:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+unsigned int ata_dev_id_string(struct ata_device *dev, unsigned char *s,
+			       unsigned int ofs, unsigned int len)
+{
+	unsigned int c, ret = 0;
+
+	while (len > 0) {
+		c = dev->id[ofs] >> 8;
+		*s = c;
+		s++;
+
+		ret = c = dev->id[ofs] & 0xff;
+		*s = c;
+		s++;
+
+		ofs++;
+		len -= 2;
+	}
+
+	return ret;
+}
+
+/**
+ *	ata_dev_parse_strings -
+ *	@dev:
+ *
+ *	LOCKING:
+ */
+
+static void ata_dev_parse_strings(struct ata_device *dev)
+{
+	assert (dev->class == ATA_DEV_ATA);
+	memcpy(dev->vendor, "ATA     ", 8);
+
+	ata_dev_id_string(dev, dev->product, ATA_ID_PROD_OFS,
+			  sizeof(dev->product));
+}
+
+/**
+ *	__ata_dev_select -
+ *	@ap:
+ *	@device:
+ *
+ *	LOCKING:
+ *
+ */
+
+static u8 __ata_dev_select (struct ata_port *ap, unsigned int device)
+{
+	u8 tmp;
+
+	if (device == 0)
+		tmp = ATA_DEVICE_OBS;
+	else
+		tmp = ATA_DEVICE_OBS | ATA_DEV1;
+
+	if (ap->flags & ATA_FLAG_MMIO) {
+		void *mmio = (void *) ap->ioaddr.cmd_addr;
+		writeb(tmp, mmio + ATA_REG_DEVICE);
+	} else {
+		outb(tmp, ap->ioaddr.cmd_addr + ATA_REG_DEVICE);
+	}
+	ata_pause(ap);		/* needed; also flushes, for mmio */
+
+	return tmp;
+}
+
+/**
+ *	ata_dev_select -
+ *	@ap:
+ *	@device:
+ *	@wait:
+ *	@can_sleep:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+void ata_dev_select(struct ata_port *ap, unsigned int device,
+			   unsigned int wait, unsigned int can_sleep)
+{
+	VPRINTK("ENTER, ata%u: device %u, wait %u\n",
+		ap->id, device, wait);
+
+	if (wait)
+		ata_wait_idle(ap);
+
+	ap->devsel = __ata_dev_select(ap, device);
+
+	if (wait) {
+		if (can_sleep && ap->device[device].class == ATA_DEV_ATAPI)
+			msleep(150);
+		ata_wait_idle(ap);
+	}
+}
+
+/**
+ *	ata_dump_id -
+ *	@dev:
+ *
+ *	LOCKING:
+ */
+
+static inline void ata_dump_id(struct ata_device *dev)
+{
+	DPRINTK("49==0x%04x  "
+		"53==0x%04x  "
+		"63==0x%04x  "
+		"64==0x%04x  "
+		"75==0x%04x  \n",
+		dev->id[49],
+		dev->id[53],
+		dev->id[63],
+		dev->id[64],
+		dev->id[75]);
+	DPRINTK("80==0x%04x  "
+		"81==0x%04x  "
+		"82==0x%04x  "
+		"83==0x%04x  "
+		"84==0x%04x  \n",
+		dev->id[80],
+		dev->id[81],
+		dev->id[82],
+		dev->id[83],
+		dev->id[84]);
+	DPRINTK("88==0x%04x  "
+		"93==0x%04x\n",
+		dev->id[88],
+		dev->id[93]);
+}
+
+/**
+ *	ata_dev_identify - obtain IDENTIFY x DEVICE page
+ *	@ap: port on which device we wish to probe resides
+ *	@device: device bus address, starting at zero
+ *
+ *	Following bus reset, we issue the IDENTIFY [PACKET] DEVICE
+ *	command, and read back the 512-byte device information page.
+ *	The device information page is fed to us via the standard
+ *	PIO-IN protocol, but we hand-code it here. (TODO: investigate
+ *	using standard PIO-IN paths)
+ *
+ *	After reading the device information page, we use several
+ *	bits of information from it to initialize data structures
+ *	that will be used during the lifetime of the ata_device.
+ *	Other data from the info page is used to disqualify certain
+ *	older ATA devices we do not wish to support.
+ *
+ *	LOCKING:
+ *	Inherited from caller.  Some functions called by this function
+ *	obtain the host_set lock.
+ */
+
+static void ata_dev_identify(struct ata_port *ap, unsigned int device)
+{
+	struct ata_device *dev = &ap->device[device];
+	unsigned int i;
+	u16 tmp, udma_modes;
+	u8 status;
+	struct ata_taskfile tf;
+#if 0
+	unsigned int use_software_reset = ap->flags & ATA_FLAG_SRST;
+#else
+	unsigned int use_software_reset = 0;
+#endif
+
+	if (!ata_dev_present(dev)) {
+		DPRINTK("ENTER/EXIT (host %u, dev %u) -- nodev\n",
+			ap->id, device);
+		return;
+	}
+
+	DPRINTK("ENTER, host %u, dev %u\n", ap->id, device);
+
+	assert (dev->class == ATA_DEV_ATA || dev->class == ATA_DEV_ATAPI ||
+		dev->class == ATA_DEV_NONE);
+
+	ata_dev_select(ap, device, 1, 1); /* select device 0/1 */
+
+retry:
+	ata_tf_init(ap, &tf);
+	tf.ctl |= ATA_NIEN;
+	tf.protocol = ATA_PROT_PIO_READ;
+
+	if (dev->class == ATA_DEV_ATA) {
+		tf.command = ATA_CMD_ID_ATA;
+		DPRINTK("do ATA identify\n");
+	} else {
+		tf.command = ATA_CMD_ID_ATAPI;
+		DPRINTK("do ATAPI identify\n");
+	}
+
+	ata_tf_to_host(ap, &tf);
+
+	/* crazy ATAPI devices... */
+	if (dev->class == ATA_DEV_ATAPI)
+		msleep(150);
+
+	if (ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT))
+		goto err_out;
+
+	status = ata_chk_status(ap);
+	if (status & ATA_ERR) {
+		/*
+		 * arg!  ATA software reset (SRST) correctly places the
+		 * the signatures in the taskfile registers... but kills
+		 * one of my test devices.  EDD works for all test cases,
+		 * but seems to return the ATA signature for some ATAPI
+		 * devices.  Until the reason for this is found and fixed,
+		 * we fix up the mess here.  If IDENTIFY DEVICE returns
+		 * command aborted (as ATAPI devices do), then we
+		 * issue an IDENTIFY PACKET DEVICE.
+		 */
+		if ((!use_software_reset) && (tf.command == ATA_CMD_ID_ATA)) {
+			u8 err = ata_chk_err(ap);
+			if (err & ATA_ABORTED) {
+				dev->class = ATA_DEV_ATAPI;
+				goto retry;
+			}
+		}
+		goto err_out;
+	}
+
+	/* make sure we have BSY=0, DRQ=1 */
+	if ((status & ATA_DRQ) == 0) {
+		printk(KERN_WARNING "ata%u: dev %u (ATA%s?) not returning id page (0x%x)\n",
+		       ap->id, device,
+		       dev->class == ATA_DEV_ATA ? "" : "PI",
+		       status);
+		goto err_out;
+	}
+
+	/* read IDENTIFY [X] DEVICE page */
+	if (ap->flags & ATA_FLAG_MMIO) {
+		void *mmio = (void *) ap->ioaddr.cmd_addr;
+		for (i = 0; i < ATA_ID_WORDS; i++)
+			dev->id[i] = readw(mmio + ATA_REG_DATA);
+	} else
+		for (i = 0; i < ATA_ID_WORDS; i++)
+			dev->id[i] = inw(ap->ioaddr.cmd_addr + ATA_REG_DATA);
+
+	/* wait for host_idle */
+	status = ata_wait_idle(ap);
+	if (status & (ATA_BUSY | ATA_DRQ)) {
+		printk(KERN_WARNING "ata%u: dev %u (ATA%s?) error after id page (0x%x)\n",
+		       ap->id, device,
+		       dev->class == ATA_DEV_ATA ? "" : "PI",
+		       status);
+		goto err_out;
+	}
+
+	ata_irq_on(ap);	/* re-enable interrupts */
+
+	/* print device capabilities */
+	printk(KERN_DEBUG "ata%u: dev %u cfg "
+	       "49:%04x 82:%04x 83:%04x 84:%04x 85:%04x 86:%04x 87:%04x 88:%04x\n",
+	       ap->id, device, dev->id[49],
+	       dev->id[82], dev->id[83], dev->id[84],
+	       dev->id[85], dev->id[86], dev->id[87],
+	       dev->id[88]);
+
+	/*
+	 * common ATA, ATAPI feature tests
+	 */
+
+	/* we require LBA and DMA support (bits 8 & 9 of word 49) */
+	if (!ata_id_has_dma(dev) || !ata_id_has_lba(dev)) {
+		printk(KERN_DEBUG "ata%u: no dma/lba\n", ap->id);
+		goto err_out_nosup;
+	}
+
+	/* we require UDMA support */
+	udma_modes =
+	tmp = dev->id[ATA_ID_UDMA_MODES];
+	if ((tmp & 0xff) == 0) {
+		printk(KERN_DEBUG "ata%u: no udma\n", ap->id);
+		goto err_out_nosup;
+	}
+
+	ata_dump_id(dev);
+
+	/* ATA-specific feature tests */
+	if (dev->class == ATA_DEV_ATA) {
+		if (!ata_id_is_ata(dev))	/* sanity check */
+			goto err_out_nosup;
+
+		tmp = dev->id[ATA_ID_MAJOR_VER];
+		for (i = 14; i >= 1; i--)
+			if (tmp & (1 << i))
+				break;
+
+		/* we require at least ATA-3 */
+		if (i < 3) {
+			printk(KERN_DEBUG "ata%u: no ATA-3\n", ap->id);
+			goto err_out_nosup;
+		}
+
+		if (ata_id_has_lba48(dev)) {
+			dev->flags |= ATA_DFLAG_LBA48;
+			dev->n_sectors = ata_id_u64(dev, 100);
+		} else {
+			dev->n_sectors = ata_id_u32(dev, 60);
+		}
+
+		ata_dev_parse_strings(dev);
+
+		ap->host->max_cmd_len = 16;
+
+		/* print device info to dmesg */
+		printk(KERN_INFO "ata%u: dev %u ATA, max %s, %Lu sectors%s\n",
+		       ap->id, device,
+		       ata_udma_string(udma_modes),
+		       dev->n_sectors,
+		       dev->flags & ATA_DFLAG_LBA48 ? " (lba48)" : "");
+	}
+
+	/* ATAPI-specific feature tests */
+	else {
+		if (ata_id_is_ata(dev))		/* sanity check */
+			goto err_out_nosup;
+
+		/* see if 16-byte commands supported */
+		tmp = dev->id[0] & 0x3;
+		if (tmp == 1)
+			ap->host->max_cmd_len = 16;
+
+		/* print device info to dmesg */
+		printk(KERN_INFO "ata%u: dev %u ATAPI, max %s\n",
+		       ap->id, device,
+		       ata_udma_string(udma_modes));
+	}
+
+	DPRINTK("EXIT, drv_stat = 0x%x\n", ata_chk_status(ap));
+	return;
+
+err_out_nosup:
+	printk(KERN_WARNING "ata%u: dev %u not supported, ignoring\n",
+	       ap->id, device);
+err_out:
+	ata_irq_on(ap);	/* re-enable interrupts */
+	dev->class++;	/* converts ATA_DEV_xxx into ATA_DEV_xxx_UNSUP */
+	DPRINTK("EXIT, err\n");
+}
+
+/**
+ *	ata_port_probe -
+ *	@ap:
+ *
+ *	LOCKING:
+ */
+
+void ata_port_probe(struct ata_port *ap)
+{
+	ap->flags &= ~ATA_FLAG_PORT_DISABLED;
+}
+
+/**
+ *	ata_port_disable -
+ *	@ap:
+ *
+ *	LOCKING:
+ */
+
+void ata_port_disable(struct ata_port *ap)
+{
+	ap->device[0].class = ATA_DEV_NONE;
+	ap->device[1].class = ATA_DEV_NONE;
+	ap->flags |= ATA_FLAG_PORT_DISABLED;
+}
+
+/**
+ *	ata_busy_sleep - sleep until BSY clears, or timeout
+ *	@ap: port containing status register to be polled
+ *	@tmout_pat: impatience timeout
+ *	@tmout: overall timeout
+ *
+ *	LOCKING:
+ *
+ */
+
+static unsigned int ata_busy_sleep (struct ata_port *ap,
+				    unsigned long tmout_pat,
+			    	    unsigned long tmout)
+{
+	unsigned long timer_start, timeout;
+	u8 status;
+
+	status = ata_busy_wait(ap, ATA_BUSY, 300);
+	timer_start = jiffies;
+	timeout = timer_start + tmout_pat;
+	while ((status & ATA_BUSY) && (time_before(jiffies, timeout))) {
+		msleep(50);
+		status = ata_busy_wait(ap, ATA_BUSY, 3);
+	}
+
+	if (status & ATA_BUSY)
+		printk(KERN_WARNING "ata%u is slow to respond, "
+		       "please be patient\n", ap->id);
+
+	timeout = timer_start + tmout;
+	while ((status & ATA_BUSY) && (time_before(jiffies, timeout))) {
+		msleep(50);
+		status = ata_chk_status(ap);
+	}
+
+	if (status & ATA_BUSY) {
+		printk(KERN_ERR "ata%u failed to respond (%lu secs)\n",
+		       ap->id, tmout / HZ);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void ata_bus_post_reset(struct ata_port *ap, unsigned int devmask)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	unsigned int dev0 = devmask & (1 << 0);
+	unsigned int dev1 = devmask & (1 << 1);
+	unsigned long timeout;
+
+	/* if device 0 was found in ata_dev_devchk, wait for its
+	 * BSY bit to clear
+	 */
+	if (dev0)
+		ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
+
+	/* if device 1 was found in ata_dev_devchk, wait for
+	 * register access, then wait for BSY to clear
+	 */
+	timeout = jiffies + ATA_TMOUT_BOOT;
+	while (dev1) {
+		u8 nsect, lbal;
+
+		__ata_dev_select(ap, 1);
+		if (ap->flags & ATA_FLAG_MMIO) {
+			void *mmio = (void *) ioaddr->cmd_addr;
+			nsect = readb(mmio + ATA_REG_NSECT);
+			lbal = readb(mmio + ATA_REG_LBAL);
+		} else {
+			nsect = inb(ioaddr->cmd_addr + ATA_REG_NSECT);
+			lbal = inb(ioaddr->cmd_addr + ATA_REG_LBAL);
+		}
+		if ((nsect == 1) && (lbal == 1))
+			break;
+		if (time_after(jiffies, timeout)) {
+			dev1 = 0;
+			break;
+		}
+		msleep(50);	/* give drive a breather */
+	}
+	if (dev1)
+		ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
+
+	/* is all this really necessary? */
+	__ata_dev_select(ap, 0);
+	if (dev1)
+		__ata_dev_select(ap, 1);
+	if (dev0)
+		__ata_dev_select(ap, 0);
+}
+
+/**
+ *	ata_bus_edd -
+ *	@ap:
+ *
+ *	LOCKING:
+ *
+ */
+
+static unsigned int ata_bus_edd(struct ata_port *ap)
+{
+	struct ata_taskfile tf;
+
+	/* set up execute-device-diag (bus reset) taskfile */
+	/* also, take interrupts to a known state (disabled) */
+	DPRINTK("execute-device-diag\n");
+	ata_tf_init(ap, &tf);
+	tf.ctl |= ATA_NIEN;
+	tf.command = ATA_CMD_EDD;
+	tf.protocol = ATA_PROT_NODATA;
+
+	/* do bus reset */
+	ata_tf_to_host(ap, &tf);
+
+	/* spec says at least 2ms.  but who knows with those
+	 * crazy ATAPI devices...
+	 */
+	msleep(150);
+
+	return ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
+}
+
+static unsigned int ata_bus_softreset(struct ata_port *ap,
+				      unsigned int devmask)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+
+	printk(KERN_DEBUG "ata%u: bus reset via SRST\n", ap->id);
+
+	/* software reset.  causes dev0 to be selected */
+	if (ap->flags & ATA_FLAG_MMIO) {
+		writeb(ap->ctl, ioaddr->ctl_addr);
+		udelay(10);	/* FIXME: flush */
+		writeb(ap->ctl | ATA_SRST, ioaddr->ctl_addr);
+		udelay(10);	/* FIXME: flush */
+		writeb(ap->ctl, ioaddr->ctl_addr);
+	} else {
+		outb(ap->ctl, ioaddr->ctl_addr);
+		udelay(10);
+		outb(ap->ctl | ATA_SRST, ioaddr->ctl_addr);
+		udelay(10);
+		outb(ap->ctl, ioaddr->ctl_addr);
+	}
+
+	/* spec mandates ">= 2ms" before checking status.
+	 * We wait 150ms, because that was the magic delay used for
+	 * ATAPI devices in Hale Landis's ATADRVR, for the period of time
+	 * between when the ATA command register is written, and then
+	 * status is checked.  Because waiting for "a while" before
+	 * checking status is fine, post SRST, we perform this magic
+	 * delay here as well.
+	 */
+	msleep(150);
+
+	ata_bus_post_reset(ap, devmask);
+
+	return 0;
+}
+
+/**
+ *	ata_bus_reset - reset host port and associated ATA channel
+ *	@ap: port to reset
+ *
+ *	This is typically the first time we actually start issuing
+ *	commands to the ATA channel.  We wait for BSY to clear, then
+ *	issue EXECUTE DEVICE DIAGNOSTIC command, polling for its
+ *	result.  Determine what devices, if any, are on the channel
+ *	by looking at the device 0/1 error register.  Look at the signature
+ *	stored in each device's taskfile registers, to determine if
+ *	the device is ATA or ATAPI.
+ *
+ *	LOCKING:
+ *	Inherited from caller.  Some functions called by this function
+ *	obtain the host_set lock.
+ *
+ *	SIDE EFFECTS:
+ *	Sets ATA_FLAG_PORT_DISABLED if bus reset fails.
+ */
+
+static void ata_bus_reset(struct ata_port *ap)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	unsigned int slave_possible = ap->flags & ATA_FLAG_SLAVE_POSS;
+	u8 err;
+	unsigned int dev0, dev1 = 0, rc, devmask = 0;
+	unsigned int use_software_reset = ap->flags & ATA_FLAG_SRST;
+
+	DPRINTK("ENTER, host %u, port %u\n", ap->id, ap->port_no);
+
+	/* set up device control */
+	if (ap->flags & ATA_FLAG_MMIO)
+		writeb(ap->ctl, ioaddr->ctl_addr);
+	else
+		outb(ap->ctl, ioaddr->ctl_addr);
+
+	/* determine if device 0/1 are present */
+	dev0 = ata_dev_devchk(ap, 0);
+	if (slave_possible)
+		dev1 = ata_dev_devchk(ap, 1);
+
+	if (dev0)
+		devmask |= (1 << 0);
+	if (dev1)
+		devmask |= (1 << 1);
+
+	/* select device 0 again */
+	__ata_dev_select(ap, 0);
+
+	/* issue bus reset */
+	if (use_software_reset)
+		rc = ata_bus_softreset(ap, devmask);
+	else
+		rc = ata_bus_edd(ap);
+
+	if (rc)
+		goto err_out;
+
+	/*
+	 * determine by signature whether we have ATA or ATAPI devices
+	 */
+	err = ata_dev_try_classify(ap, 0, dev0);
+	if ((slave_possible) && (err != 0x81))
+		ata_dev_try_classify(ap, 1, dev1);
+
+	/* re-enable interrupts */
+	ata_irq_on(ap);
+
+	/* is double-select really necessary? */
+	if (ap->device[1].class != ATA_DEV_NONE)
+		__ata_dev_select(ap, 1);
+	if (ap->device[0].class != ATA_DEV_NONE)
+		__ata_dev_select(ap, 0);
+
+	/* if no devices were detected, disable this port */
+	if ((ap->device[0].class == ATA_DEV_NONE) &&
+	    (ap->device[1].class == ATA_DEV_NONE))
+		goto err_out;
+
+	DPRINTK("EXIT\n");
+	return;
+
+err_out:
+	printk(KERN_ERR "ata%u: disabling port\n", ap->id);
+	ap->ops->port_disable(ap);
+
+	DPRINTK("EXIT\n");
+}
+
+/**
+ *	ata_host_set_pio -
+ *	@ap:
+ *
+ *	LOCKING:
+ */
+
+static void ata_host_set_pio(struct ata_port *ap)
+{
+	struct ata_device *master, *slave;
+	unsigned int pio, i;
+	u16 mask;
+
+	master = &ap->device[0];
+	slave = &ap->device[1];
+
+	assert (ata_dev_present(master) || ata_dev_present(slave));
+
+	mask = ap->pio_mask;
+	if (ata_dev_present(master))
+		mask &= (master->id[ATA_ID_PIO_MODES] & 0x03);
+	if (ata_dev_present(slave))
+		mask &= (slave->id[ATA_ID_PIO_MODES] & 0x03);
+
+	/* require pio mode 3 or 4 support for host and all devices */
+	if (mask == 0) {
+		printk(KERN_WARNING "ata%u: no PIO3/4 support, ignoring\n",
+		       ap->id);
+		goto err_out;
+	}
+
+	pio = (mask & ATA_ID_PIO4) ? 4 : 3;
+	for (i = 0; i < ATA_MAX_DEVICES; i++)
+		if (ata_dev_present(&ap->device[i])) {
+			ap->device[i].pio_mode = (pio == 3) ?
+				XFER_PIO_3 : XFER_PIO_4;
+			ap->ops->set_piomode(ap, &ap->device[i], pio);
+		}
+
+	return;
+
+err_out:
+	ap->ops->port_disable(ap);
+}
+
+/**
+ *	ata_host_set_udma -
+ *	@ap:
+ *
+ *	LOCKING:
+ */
+
+static void ata_host_set_udma(struct ata_port *ap)
+{
+	struct ata_device *master, *slave;
+	u16 mask;
+	unsigned int i, j;
+	int udma_mode = -1;
+
+	master = &ap->device[0];
+	slave = &ap->device[1];
+
+	assert (ata_dev_present(master) || ata_dev_present(slave));
+	assert ((ap->flags & ATA_FLAG_PORT_DISABLED) == 0);
+
+	DPRINTK("udma masks: host 0x%X, master 0x%X, slave 0x%X\n",
+		ap->udma_mask,
+		(!ata_dev_present(master)) ? 0xff :
+			(master->id[ATA_ID_UDMA_MODES] & 0xff),
+		(!ata_dev_present(slave)) ? 0xff :
+			(slave->id[ATA_ID_UDMA_MODES] & 0xff));
+
+	mask = ap->udma_mask;
+	if (ata_dev_present(master))
+		mask &= (master->id[ATA_ID_UDMA_MODES] & 0xff);
+	if (ata_dev_present(slave))
+		mask &= (slave->id[ATA_ID_UDMA_MODES] & 0xff);
+
+	i = XFER_UDMA_7;
+	while (i >= XFER_UDMA_0) {
+		j = i - XFER_UDMA_0;
+		DPRINTK("mask 0x%X i 0x%X j %u\n", mask, i, j);
+		if (mask & (1 << j)) {
+			udma_mode = i;
+			break;
+		}
+
+		i--;
+	}
+
+	/* require udma for host and all attached devices */
+	if (udma_mode < 0) {
+		printk(KERN_WARNING "ata%u: no UltraDMA support, ignoring\n",
+		       ap->id);
+		goto err_out;
+	}
+
+	for (i = 0; i < ATA_MAX_DEVICES; i++)
+		if (ata_dev_present(&ap->device[i])) {
+			ap->device[i].udma_mode = udma_mode;
+			ap->ops->set_udmamode(ap, &ap->device[i], udma_mode);
+		}
+
+	return;
+
+err_out:
+	ap->ops->port_disable(ap);
+}
+
+/**
+ *	ata_dev_set_xfermode -
+ *	@ap:
+ *	@dev:
+ *
+ *	LOCKING:
+ */
+
+static void ata_dev_set_xfermode(struct ata_port *ap, struct ata_device *dev)
+{
+	struct ata_taskfile tf;
+
+	/* set up set-features taskfile */
+	DPRINTK("set features - xfer mode\n");
+	ata_tf_init(ap, &tf);
+	tf.ctl |= ATA_NIEN;
+	tf.command = ATA_CMD_SET_FEATURES;
+	tf.feature = SETFEATURES_XFER;
+	tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
+	tf.protocol = ATA_PROT_NODATA;
+	if (dev->flags & ATA_DFLAG_PIO)
+		tf.nsect = dev->pio_mode;
+	else
+		tf.nsect = dev->udma_mode;
+
+	/* do bus reset */
+	ata_tf_to_host(ap, &tf);
+
+	/* crazy ATAPI devices... */
+	if (dev->class == ATA_DEV_ATAPI)
+		msleep(150);
+
+	ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
+
+	ata_irq_on(ap);	/* re-enable interrupts */
+
+	ata_wait_idle(ap);
+
+	DPRINTK("EXIT\n");
+}
+
+/**
+ *	ata_dev_set_udma -
+ *	@ap:
+ *	@device:
+ *
+ *	LOCKING:
+ */
+
+static void ata_dev_set_udma(struct ata_port *ap, unsigned int device)
+{
+	struct ata_device *dev = &ap->device[device];
+
+	if (!ata_dev_present(dev) || (ap->flags & ATA_FLAG_PORT_DISABLED))
+		return;
+
+	ata_dev_set_xfermode(ap, dev);
+
+	assert((dev->udma_mode >= XFER_UDMA_0) &&
+	       (dev->udma_mode <= XFER_UDMA_7));
+	printk(KERN_INFO "ata%u: dev %u configured for %s\n",
+	       ap->id, device,
+	       udma_str[dev->udma_mode - XFER_UDMA_0]);
+}
+
+/**
+ *	ata_dev_set_pio -
+ *	@ap:
+ *	@device:
+ *
+ *	LOCKING:
+ */
+
+static void ata_dev_set_pio(struct ata_port *ap, unsigned int device)
+{
+	struct ata_device *dev = &ap->device[device];
+
+	if (!ata_dev_present(dev) || (ap->flags & ATA_FLAG_PORT_DISABLED))
+		return;
+
+	/* force PIO mode */
+	dev->flags |= ATA_DFLAG_PIO;
+
+	ata_dev_set_xfermode(ap, dev);
+
+	assert((dev->pio_mode >= XFER_PIO_3) &&
+	       (dev->pio_mode <= XFER_PIO_4));
+	printk(KERN_INFO "ata%u: dev %u configured for PIO%c\n",
+	       ap->id, device,
+	       dev->pio_mode == 3 ? '3' : '4');
+}
+
+/**
+ *	ata_sg_clean -
+ *	@qc:
+ *
+ *	LOCKING:
+ */
+
+static void ata_sg_clean(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	Scsi_Cmnd *cmd = qc->scsicmd;
+	struct scatterlist *sg;
+	int dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+
+	assert(dir == SCSI_DATA_READ || dir == SCSI_DATA_WRITE);
+	assert(qc->flags & ATA_QCFLAG_SG);
+
+	if (cmd->use_sg) {
+		sg = (struct scatterlist *)qc->scsicmd->request_buffer;
+	} else {
+		sg = &qc->sgent;
+		assert(qc->n_elem == 1);
+	}
+
+	DPRINTK("unmapping %u sg elements\n", qc->n_elem);
+
+	if (cmd->use_sg)
+		pci_unmap_sg(ap->host_set->pdev, sg, qc->n_elem, dir);
+	else
+		pci_unmap_single(ap->host_set->pdev, sg[0].dma_address,
+				 sg[0].length, dir);
+
+	qc->flags &= ~ATA_QCFLAG_SG;
+}
+
+/**
+ *	ata_sg_setup_one -
+ *	@qc:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ *
+ *	RETURNS:
+ *
+ */
+
+static int ata_sg_setup_one(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	Scsi_Cmnd *cmd = qc->scsicmd;
+	int dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+	struct scatterlist *sg = &qc->sgent;
+	unsigned int have_sg = (qc->flags & ATA_QCFLAG_SG);
+
+	qc->n_elem = 1;
+	sg->address = cmd->request_buffer;
+	sg->page = virt_to_page(cmd->request_buffer);
+	sg->offset = (unsigned long) cmd->request_buffer & ~PAGE_MASK;
+	sg->length = cmd->request_bufflen;
+
+	if (!have_sg)
+		return 0;
+
+	sg->dma_address = pci_map_single(ap->host_set->pdev,
+					 cmd->request_buffer,
+					 cmd->request_bufflen, dir);
+
+	DPRINTK("mapped buffer of %d bytes for %s\n", cmd->request_bufflen,
+		qc->flags & ATA_QCFLAG_WRITE ? "write" : "read");
+
+	ap->prd[0].addr = cpu_to_le32(sg->dma_address);
+	ap->prd[0].flags_len = cpu_to_le32(sg->length | ATA_PRD_EOT);
+	VPRINTK("PRD[0] = (0x%X, 0x%X)\n",
+		ap->prd[0].addr, ap->prd[0].flags_len);
+
+	return 0;
+}
+
+/**
+ *	ata_sg_setup -
+ *	@qc:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ *
+ *	RETURNS:
+ *
+ */
+
+static int ata_sg_setup(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	Scsi_Cmnd *cmd = qc->scsicmd;
+	struct scatterlist *sg;
+	int n_elem;
+	unsigned int i;
+	unsigned int have_sg = (qc->flags & ATA_QCFLAG_SG);
+
+	VPRINTK("ENTER, ata%u, use_sg %d\n", ap->id, cmd->use_sg);
+	assert(cmd->use_sg > 0);
+
+	sg = (struct scatterlist *)cmd->request_buffer;
+	if (have_sg) {
+		int dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+		n_elem = pci_map_sg(ap->host_set->pdev, sg, cmd->use_sg, dir);
+		if (n_elem < 1)
+			return -1;
+		DPRINTK("%d sg elements mapped\n", n_elem);
+	} else {
+		n_elem = cmd->use_sg;
+	}
+	qc->n_elem = n_elem;
+
+
+#ifndef ATA_DEBUG
+	if (!have_sg)
+		return 0;
+#endif
+
+	for (i = 0; i < n_elem; i++) {
+		ap->prd[i].addr = cpu_to_le32(sg[i].dma_address);
+		ap->prd[i].flags_len = cpu_to_le32(sg[i].length);
+		VPRINTK("PRD[%u] = (0x%X, 0x%X)\n",
+			i, ap->prd[i].addr, ap->prd[i].flags_len);
+	}
+	ap->prd[n_elem - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);
+
+#ifdef ATA_DEBUG
+	i = n_elem - 1;
+	VPRINTK("PRD[%u] = (0x%X, 0x%X)\n",
+		i, ap->prd[i].addr, ap->prd[i].flags_len);
+
+	for (i = n_elem; i < ATA_MAX_PRD; i++) {
+		ap->prd[i].addr = 0;
+		ap->prd[i].flags_len = cpu_to_le32(ATA_PRD_EOT);
+	}
+#endif
+
+	return 0;
+}
+
+/**
+ *	ata_pio_poll -
+ *	@ap:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static unsigned long ata_pio_poll(struct ata_port *ap)
+{
+	u8 status;
+	unsigned int poll_state = THR_UNKNOWN;
+	unsigned int reg_state = THR_UNKNOWN;
+	const unsigned int tmout_state = THR_PIO_TMOUT;
+
+	switch (ap->thr_state) {
+	case THR_PIO:
+	case THR_PIO_POLL:
+		poll_state = THR_PIO_POLL;
+		reg_state = THR_PIO;
+		break;
+	case THR_PIO_LAST:
+	case THR_PIO_LAST_POLL:
+		poll_state = THR_PIO_LAST_POLL;
+		reg_state = THR_PIO_LAST;
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	status = ata_chk_status(ap);
+	if (status & ATA_BUSY) {
+		if (time_after(jiffies, ap->thr_timeout)) {
+			ap->thr_state = tmout_state;
+			return 0;
+		}
+		ap->thr_state = poll_state;
+		if (current->need_resched)
+			return 0;
+		return ATA_SHORT_PAUSE;
+	}
+
+	ap->thr_state = reg_state;
+	return 0;
+}
+
+/**
+ *	ata_pio_start -
+ *	@qc:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+static void ata_pio_start (struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+
+	assert((qc->tf.protocol == ATA_PROT_PIO_READ) ||
+	       (qc->tf.protocol == ATA_PROT_PIO_WRITE));
+
+	qc->flags |= ATA_QCFLAG_POLL;
+	qc->tf.ctl |= ATA_NIEN;	/* disable interrupts */
+	ata_tf_to_host_nolock(ap, &qc->tf);
+	ata_thread_wake(ap, THR_PIO);
+}
+
+/**
+ *	ata_pio_complete -
+ *	@ap:
+ *
+ *	LOCKING:
+ */
+
+static void ata_pio_complete (struct ata_port *ap)
+{
+	struct ata_queued_cmd *qc;
+	unsigned long flags;
+	u8 drv_stat;
+
+	/*
+	 * This is purely hueristic.  This is a fast path.
+	 * Sometimes when we enter, BSY will be cleared in
+	 * a chk-status or two.  If not, the drive is probably seeking
+	 * or something.  Snooze for a couple msecs, then
+	 * chk-status again.  If still busy, fall back to
+	 * THR_PIO_POLL state.
+	 */
+	drv_stat = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 10);
+	if (drv_stat & (ATA_BUSY | ATA_DRQ)) {
+		msleep(2);
+		drv_stat = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 10);
+		if (drv_stat & (ATA_BUSY | ATA_DRQ)) {
+			ap->thr_state = THR_PIO_LAST_POLL;
+			ap->thr_timeout = jiffies + ATA_TMOUT_PIO;
+			return;
+		}
+	}
+
+	drv_stat = ata_wait_idle(ap);
+	if (drv_stat & (ATA_BUSY | ATA_DRQ)) {
+		ap->thr_state = THR_PIO_ERR;
+		return;
+	}
+
+	qc = ata_qc_from_tag(ap, ap->active_tag);
+	assert(qc != NULL);
+
+	spin_lock_irqsave(&ap->host_set->lock, flags);
+	ap->thr_state = THR_IDLE;
+	spin_unlock_irqrestore(&ap->host_set->lock, flags);
+
+	ata_irq_on(ap);
+
+	ata_qc_complete(qc, drv_stat, 0);
+}
+
+/**
+ *	ata_pio_sector -
+ *	@ap:
+ *
+ *	LOCKING:
+ */
+
+static void ata_pio_sector(struct ata_port *ap)
+{
+	struct ata_queued_cmd *qc;
+	struct scatterlist *sg;
+	Scsi_Cmnd *cmd;
+	unsigned char *buf;
+	u8 status;
+
+	/*
+	 * This is purely hueristic.  This is a fast path.
+	 * Sometimes when we enter, BSY will be cleared in
+	 * a chk-status or two.  If not, the drive is probably seeking
+	 * or something.  Snooze for a couple msecs, then
+	 * chk-status again.  If still busy, fall back to
+	 * THR_PIO_POLL state.
+	 */
+	status = ata_busy_wait(ap, ATA_BUSY, 5);
+	if (status & ATA_BUSY) {
+		msleep(2);
+		status = ata_busy_wait(ap, ATA_BUSY, 10);
+		if (status & ATA_BUSY) {
+			ap->thr_state = THR_PIO_POLL;
+			ap->thr_timeout = jiffies + ATA_TMOUT_PIO;
+			return;
+		}
+	}
+
+	/* handle BSY=0, DRQ=0 as error */
+	if ((status & ATA_DRQ) == 0) {
+		ap->thr_state = THR_PIO_ERR;
+		return;
+	}
+
+	qc = ata_qc_from_tag(ap, ap->active_tag);
+	assert(qc != NULL);
+
+	cmd = qc->scsicmd;
+	if (cmd->use_sg)
+		sg = (struct scatterlist *)cmd->request_buffer;
+	else
+		sg = &qc->sgent;
+	if (qc->cursect == (qc->nsect - 1))
+		ap->thr_state = THR_PIO_LAST;
+
+	buf = kmap(sg[qc->cursg].page) +
+	      sg[qc->cursg].offset + (qc->cursg_ofs * ATA_SECT_SIZE);
+
+	qc->cursect++;
+	qc->cursg_ofs++;
+
+	if (cmd->use_sg)
+		if ((qc->cursg_ofs * ATA_SECT_SIZE) == sg[qc->cursg].length) {
+			qc->cursg++;
+			qc->cursg_ofs = 0;
+		}
+
+	DPRINTK("data %s, drv_stat 0x%X\n",
+		qc->flags & ATA_QCFLAG_WRITE ? "write" : "read",
+		status);
+
+	/* do the actual data transfer */
+	/* FIXME: mmio-ize */
+	if (qc->flags & ATA_QCFLAG_WRITE)
+		outsl(ap->ioaddr.cmd_addr + ATA_REG_DATA, buf, ATA_SECT_DWORDS);
+	else
+		insl(ap->ioaddr.cmd_addr + ATA_REG_DATA, buf, ATA_SECT_DWORDS);
+
+	kunmap(sg[qc->cursg].page);
+}
+
+/**
+ *	ata_eng_schedule - run an iteration of the pio/dma/whatever engine
+ *	@ap: port on which activity will occur
+ *	@eng: instance of engine
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+static void ata_eng_schedule (struct ata_port *ap, struct ata_engine *eng)
+{
+	/* FIXME */
+}
+
+/**
+ *	ata_eng_timeout - Handle timeout of queued command
+ *	@ap: Port on which timed-out command is active
+ *
+ *	Some part of the kernel (currently, only the SCSI layer)
+ *	has noticed that the active command on port @ap has not
+ *	completed after a specified length of time.  Handle this
+ *	condition by disabling DMA (if necessary) and completing
+ *	transactions, with error if necessary.
+ *
+ *	This also handles the case of the "lost interrupt", where
+ *	for some reason (possibly hardware bug, possibly driver bug)
+ *	an interrupt was not delivered to the driver, even though the
+ *	transaction completed successfully.
+ *
+ *	LOCKING:
+ *	Inherited from SCSI layer (none, can sleep)
+ */
+
+void ata_eng_timeout(struct ata_port *ap)
+{
+	u8 host_stat, drv_stat;
+	struct ata_queued_cmd *qc;
+
+	DPRINTK("ENTER\n");
+
+	qc = ata_qc_from_tag(ap, ap->active_tag);
+	if (!qc) {
+		printk(KERN_ERR "ata%u: BUG: timeout without command\n",
+		       ap->id);
+		goto out;
+	}
+
+	switch (qc->tf.protocol) {
+	case ATA_PROT_DMA_READ:
+	case ATA_PROT_DMA_WRITE:
+		if (ap->flags & ATA_FLAG_MMIO) {
+			void *mmio = (void *) ap->ioaddr.bmdma_addr;
+			host_stat = readb(mmio + ATA_DMA_STATUS);
+		} else
+			host_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+
+		printk(KERN_ERR "ata%u: DMA timeout, stat 0x%x\n",
+		       ap->id, host_stat);
+
+		ata_dma_complete(ap, host_stat, 1);
+		break;
+
+	case ATA_PROT_NODATA:
+		drv_stat = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
+
+		printk(KERN_ERR "ata%u: command 0x%x timeout, stat 0x%x\n",
+		       ap->id, qc->tf.command, drv_stat);
+
+		ata_qc_complete(qc, drv_stat, 1);
+		break;
+
+	default:
+		drv_stat = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
+
+		printk(KERN_ERR "ata%u: unknown timeout, cmd 0x%x stat 0x%x\n",
+		       ap->id, qc->tf.command, drv_stat);
+
+		ata_qc_complete(qc, drv_stat, 1);
+		break;
+	}
+
+out:
+	DPRINTK("EXIT\n");
+}
+
+/**
+ *	ata_qc_new -
+ *	@ap:
+ *	@dev:
+ *
+ *	LOCKING:
+ */
+
+static struct ata_queued_cmd *ata_qc_new(struct ata_port *ap)
+{
+	struct ata_queued_cmd *qc = NULL;
+	unsigned int i;
+
+	for (i = 0; i < ATA_MAX_QUEUE; i++)
+		if (!test_and_set_bit(i, &ap->qactive)) {
+			qc = ata_qc_from_tag(ap, i);
+			break;
+		}
+
+	if (qc)
+		qc->tag = i;
+
+	return qc;
+}
+
+/**
+ *	ata_qc_new_init -
+ *	@ap:
+ *	@cmd:
+ *	@done:
+ *
+ *	LOCKING:
+ */
+
+struct ata_queued_cmd *ata_qc_new_init(struct ata_port *ap,
+				      struct ata_device *dev,
+	      			      Scsi_Cmnd *cmd,
+				      void (*done)(Scsi_Cmnd *))
+{
+	struct ata_queued_cmd *qc;
+
+	qc = ata_qc_new(ap);
+	if (!qc) {
+		cmd->result = (DID_OK << 16) | (QUEUE_FULL << 1);
+		done(cmd);
+	} else {
+		qc->flags = 0;
+		qc->scsicmd = cmd;
+		qc->scsidone = done;
+		qc->ap = ap;
+		qc->dev = dev;
+		INIT_LIST_HEAD(&qc->node);
+		init_MUTEX_LOCKED(&qc->sem);
+
+		ata_tf_init(ap, &qc->tf);
+
+		if (likely((dev->flags & ATA_DFLAG_PIO) == 0))
+			qc->flags |= ATA_QCFLAG_DMA;
+		if (dev->flags & ATA_DFLAG_LBA48)
+			qc->tf.flags |= ATA_TFLAG_LBA48;
+	}
+
+	return qc;
+}
+
+/**
+ *	ata_qc_complete -
+ *	@qc:
+ *	@drv_stat:
+ *	@done_late:
+ *
+ *	LOCKING:
+ *
+ */
+
+static void ata_qc_complete(struct ata_queued_cmd *qc,
+			    u8 drv_stat, unsigned int done_late)
+{
+	struct ata_port *ap = qc->ap;
+	Scsi_Cmnd *cmd = qc->scsicmd;
+	unsigned int tag, do_clear = 0;
+
+	assert(qc != NULL);	/* ata_qc_from_tag _might_ return NULL */
+	assert(qc->flags & ATA_QCFLAG_ACTIVE);
+
+	if (likely(qc->flags & ATA_QCFLAG_SG))
+		ata_sg_clean(qc);
+
+	if (cmd) {
+		if (unlikely(drv_stat & (ATA_ERR | ATA_BUSY | ATA_DRQ))) {
+			if (qc->flags & ATA_QCFLAG_ATAPI)
+				cmd->result = SAM_STAT_CHECK_CONDITION;
+			else
+				ata_to_sense_error(qc);
+		} else {
+			if (done_late)
+				cmd->done_late = 1;
+			cmd->result = SAM_STAT_GOOD;
+		}
+
+		qc->scsidone(cmd);
+	}
+
+	qc->flags &= ~ATA_QCFLAG_ACTIVE;
+	tag = qc->tag;
+	if (likely(ata_tag_valid(tag))) {
+		if (tag == ap->active_tag)
+			ap->active_tag = ATA_TAG_POISON;
+		qc->tag = ATA_TAG_POISON;
+		do_clear = 1;
+	}
+
+	up(&qc->sem);
+
+	if (likely(do_clear))
+		clear_bit(tag, &ap->qactive);
+}
+
+/**
+ *	ata_qc_push -
+ *	@qc:
+ *	@append:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+static void ata_qc_push (struct ata_queued_cmd *qc, unsigned int append)
+{
+	struct ata_port *ap = qc->ap;
+	struct ata_engine *eng = &ap->eng;
+
+	if (likely(append))
+		list_add_tail(&qc->node, &eng->q);
+	else
+		list_add(&qc->node, &eng->q);
+
+	if (!test_and_set_bit(ATA_EFLG_ACTIVE, &eng->flags))
+		ata_eng_schedule(ap, eng);
+}
+
+/**
+ *	ata_qc_issue -
+ *	@qc:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+int ata_qc_issue(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	Scsi_Cmnd *cmd = qc->scsicmd;
+	unsigned int dma = qc->flags & ATA_QCFLAG_DMA;
+
+	ata_dev_select(ap, qc->dev->devno, 1, 0);
+
+	/* set up SG table */
+	if (cmd->use_sg) {
+		if (ata_sg_setup(qc))
+			goto err_out;
+	} else {
+		if (ata_sg_setup_one(qc))
+			goto err_out;
+	}
+
+	qc->ap->active_tag = qc->tag;
+	qc->flags |= ATA_QCFLAG_ACTIVE;
+
+	if (likely(dma)) {
+		ap->ops->tf_load(ap, &qc->tf);	/* load tf registers */
+		ap->ops->bmdma_start(qc);	/* initiate bmdma */
+	} else
+		/* load tf registers, initiate polling pio */
+		ata_pio_start(qc);
+
+	return 0;
+
+err_out:
+	return -1;
+}
+
+/**
+ *	ata_bmdma_start_mmio -
+ *	@qc:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+void ata_bmdma_start_mmio (struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	unsigned int rw = (qc->flags & ATA_QCFLAG_WRITE);
+	u8 host_stat, dmactl;
+	void *mmio = (void *) ap->ioaddr.bmdma_addr;
+
+	/* load PRD table addr. */
+	writel(ap->prd_dma, mmio + ATA_DMA_TABLE_OFS);
+
+	/* specify data direction */
+	/* FIXME: redundant to later start-dma command? */
+	writeb(rw ? 0 : ATA_DMA_WR, mmio + ATA_DMA_CMD);
+
+	/* clear interrupt, error bits */
+	host_stat = readb(mmio + ATA_DMA_STATUS);
+	writeb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR, mmio + ATA_DMA_STATUS);
+
+	/* issue r/w command */
+	__ata_exec(ap, &qc->tf);
+
+	/* start host DMA transaction */
+	dmactl = readb(mmio + ATA_DMA_CMD);
+	writeb(dmactl | ATA_DMA_START, mmio + ATA_DMA_CMD);
+
+	/* Strictly, one may wish to issue a readb() here, to
+	 * flush the mmio write.  However, control also passes
+	 * to the hardware at this point, and it will interrupt
+	 * us when we are to resume control.  So, in effect,
+	 * we don't care when the mmio write flushes.
+	 * Further, a read of the DMA status register _immediately_
+	 * following the write may not be what certain flaky hardware
+	 * is expected, so I think it is best to not add a readb()
+	 * without first all the MMIO ATA cards/mobos.
+	 * Or maybe I'm just being paranoid.
+	 */
+}
+
+/**
+ *	ata_bmdma_start_pio -
+ *	@qc:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+void ata_bmdma_start_pio (struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	unsigned int rw = (qc->flags & ATA_QCFLAG_WRITE);
+	u8 host_stat, dmactl;
+
+	/* load PRD table addr. */
+	outl(ap->prd_dma, ap->ioaddr.bmdma_addr + ATA_DMA_TABLE_OFS);
+
+	/* specify data direction */
+	/* FIXME: redundant to later start-dma command? */
+	outb(rw ? 0 : ATA_DMA_WR, ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+
+	/* clear interrupt, error bits */
+	host_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	outb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+	     ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+
+	/* issue r/w command */
+	__ata_exec(ap, &qc->tf);
+
+	/* start host DMA transaction */
+	dmactl = inb(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+	outb(dmactl | ATA_DMA_START,
+	     ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+}
+
+/**
+ *	ata_dma_complete -
+ *	@ap:
+ *	@host_stat:
+ *	@done_late:
+ *
+ *	LOCKING:
+ */
+
+static void ata_dma_complete(struct ata_port *ap, u8 host_stat,
+			     unsigned int done_late)
+{
+	VPRINTK("ENTER\n");
+
+	if (ap->flags & ATA_FLAG_MMIO) {
+		void *mmio = (void *) ap->ioaddr.bmdma_addr;
+
+		/* clear start/stop bit */
+		writeb(0, mmio + ATA_DMA_CMD);
+
+		/* ack intr, err bits */
+		writeb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+		       mmio + ATA_DMA_STATUS);
+	} else {
+		/* clear start/stop bit */
+		outb(0, ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+
+		/* ack intr, err bits */
+		outb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+		     ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	}
+
+
+	/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */
+	ata_altstatus(ap);		/* dummy read */
+
+	DPRINTK("host %u, host_stat==0x%X, drv_stat==0x%X\n",
+		ap->id, (u32) host_stat, (u32) ata_chk_status(ap));
+
+	/* get drive status; clear intr; complete txn */
+	ata_qc_complete(ata_qc_from_tag(ap, ap->active_tag),
+			ata_wait_idle(ap), done_late);
+}
+
+/**
+ *	ata_host_intr - Handle host interrupt for given (port, task)
+ *	@ap: Port on which interrupt arrived (possibly...)
+ *	@qc: Taskfile currently active in engine
+ *
+ *	Handle host interrupt for given queued command.  Currently,
+ *	only DMA interrupts are handled.  All other commands are
+ *	handled via polling with interrupts disabled (nIEN bit).
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ *
+ *	RETURNS:
+ *	One if interrupt was handled, zero if not (shared irq).
+ */
+
+static inline unsigned int ata_host_intr (struct ata_port *ap,
+					  struct ata_queued_cmd *qc)
+{
+	u8 status, host_stat;
+	unsigned int handled = 0;
+
+	switch (qc->tf.protocol) {
+	case ATA_PROT_DMA_READ:
+	case ATA_PROT_DMA_WRITE:
+		if (ap->flags & ATA_FLAG_MMIO) {
+			void *mmio = (void *) ap->ioaddr.bmdma_addr;
+			host_stat = readb(mmio + ATA_DMA_STATUS);
+		} else
+			host_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+		VPRINTK("BUS_DMA (host_stat 0x%X)\n", host_stat);
+
+		if (!(host_stat & ATA_DMA_INTR)) {
+			ap->stats.idle_irq++;
+			break;
+		}
+
+		ata_dma_complete(ap, host_stat, 0);
+		handled = 1;
+		break;
+
+	case ATA_PROT_NODATA:	/* command completion, but no data xfer */
+		status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
+		DPRINTK("BUS_NODATA (drv_stat 0x%X)\n", status);
+		ata_qc_complete(qc, status, 0);
+		handled = 1;
+		break;
+
+	default:
+		ap->stats.idle_irq++;
+
+#ifdef ATA_IRQ_TRAP
+		if ((ap->stats.idle_irq % 1000) == 0) {
+			handled = 1;
+			ata_irq_ack(ap, 0); /* debug trap */
+			printk(KERN_WARNING "ata%d: irq trap\n", ap->id);
+		}
+#endif
+		break;
+	}
+
+	return handled;
+}
+
+/**
+ *	ata_interrupt -
+ *	@irq:
+ *	@dev_instance:
+ *	@regs:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static irqreturn_t ata_interrupt (int irq, void *dev_instance,
+				  struct pt_regs *regs)
+{
+	struct ata_host_set *host_set = dev_instance;
+	unsigned int i;
+	unsigned int handled = 0;
+	unsigned long flags;
+
+	/* TODO: make _irqsave conditional on x86 PCI IDE legacy mode */
+	spin_lock_irqsave(&host_set->lock, flags);
+
+	for (i = 0; i < host_set->n_hosts; i++) {
+		struct ata_port *ap;
+
+		ap = host_set->hosts[i];
+		if (ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+			struct ata_queued_cmd *qc;
+
+			qc = ata_qc_from_tag(ap, ap->active_tag);
+			if (qc && ((qc->flags & ATA_QCFLAG_POLL) == 0))
+				handled += ata_host_intr(ap, qc);
+		}
+	}
+
+	spin_unlock_irqrestore(&host_set->lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+/**
+ *	ata_thread_wake -
+ *	@ap:
+ *	@thr_state:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+void ata_thread_wake(struct ata_port *ap, unsigned int thr_state)
+{
+	assert(ap->thr_state == THR_IDLE);
+	ap->thr_state = thr_state;
+	up(&ap->thr_sem);
+}
+
+/**
+ *	ata_thread_timer -
+ *	@opaque:
+ *
+ *	LOCKING:
+ */
+
+static void ata_thread_timer(unsigned long opaque)
+{
+	struct ata_port *ap = (struct ata_port *) opaque;
+
+	up(&ap->thr_sem);
+}
+
+/**
+ *	ata_thread_iter -
+ *	@ap:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static unsigned long ata_thread_iter(struct ata_port *ap)
+{
+	long timeout = 0;
+
+	DPRINTK("ata%u: thr_state %s\n",
+		ap->id, ata_thr_state_name(ap->thr_state));
+
+	switch (ap->thr_state) {
+	case THR_UNKNOWN:
+		ap->thr_state = THR_CHECKPORT;
+		break;
+
+	case THR_PROBE_START:
+		down(&ap->sem);
+		ap->thr_state = THR_CHECKPORT;
+		break;
+
+	case THR_CHECKPORT:
+		ap->ops->port_probe(ap);
+		if (ap->flags & ATA_FLAG_PORT_DISABLED)
+			ap->thr_state = THR_PROBE_FAILED;
+		else
+			ap->thr_state = THR_BUS_RESET;
+		break;
+
+	case THR_BUS_RESET:
+		ata_bus_reset(ap);
+		if (ap->flags & ATA_FLAG_PORT_DISABLED)
+			ap->thr_state = THR_PROBE_FAILED;
+		else
+			ap->thr_state = THR_IDENTIFY;
+		break;
+
+	case THR_IDENTIFY:
+		ata_dev_identify(ap, 0);
+		ata_dev_identify(ap, 1);
+
+		if (!ata_dev_present(&ap->device[0]) &&
+		    !ata_dev_present(&ap->device[1])) {
+			ap->ops->port_disable(ap);
+			ap->thr_state = THR_PROBE_FAILED;
+		} else
+			ap->thr_state = THR_CONFIG_TIMINGS;
+		break;
+
+	case THR_CONFIG_TIMINGS:
+		ata_host_set_pio(ap);
+		if ((ap->flags & ATA_FLAG_PORT_DISABLED) == 0)
+			ata_host_set_udma(ap);
+
+		if (ap->flags & ATA_FLAG_PORT_DISABLED)
+			ap->thr_state = THR_PROBE_FAILED;
+		else
+#ifdef ATA_FORCE_PIO
+			ap->thr_state = THR_CONFIG_FORCE_PIO;
+#else
+			ap->thr_state = THR_CONFIG_DMA;
+#endif
+		break;
+
+	case THR_CONFIG_FORCE_PIO:
+		ata_dev_set_pio(ap, 0);
+		ata_dev_set_pio(ap, 1);
+
+		if (ap->flags & ATA_FLAG_PORT_DISABLED)
+			ap->thr_state = THR_PROBE_FAILED;
+		else
+			ap->thr_state = THR_PROBE_SUCCESS;
+		break;
+
+	case THR_CONFIG_DMA:
+		ata_dev_set_udma(ap, 0);
+		ata_dev_set_udma(ap, 1);
+
+		if (ap->flags & ATA_FLAG_PORT_DISABLED)
+			ap->thr_state = THR_PROBE_FAILED;
+		else
+			ap->thr_state = THR_PROBE_SUCCESS;
+		break;
+
+	case THR_PROBE_SUCCESS:
+		up(&ap->probe_sem);
+		ap->thr_state = THR_IDLE;
+		break;
+
+	case THR_PROBE_FAILED:
+		up(&ap->probe_sem);
+		ap->thr_state = THR_AWAIT_DEATH;
+		break;
+
+	case THR_AWAIT_DEATH:
+		timeout = -1;
+		break;
+
+	case THR_IDLE:
+		timeout = 30 * HZ;
+		break;
+
+	case THR_PIO:
+		ata_pio_sector(ap);
+		break;
+
+	case THR_PIO_LAST:
+		ata_pio_complete(ap);
+		break;
+
+	case THR_PIO_POLL:
+	case THR_PIO_LAST_POLL:
+		timeout = ata_pio_poll(ap);
+		break;
+
+	case THR_PIO_TMOUT:
+		printk(KERN_ERR "ata%d: FIXME: THR_PIO_TMOUT\n", /* FIXME */
+		       ap->id);
+		timeout = 11 * HZ;
+		break;
+
+	case THR_PIO_ERR:
+		printk(KERN_ERR "ata%d: FIXME: THR_PIO_ERR\n", /* FIXME */
+		       ap->id);
+		timeout = 11 * HZ;
+		break;
+
+	case THR_PACKET:
+		atapi_cdb_send(ap);
+		break;
+
+	default:
+		printk(KERN_DEBUG "ata%u: unknown thr state %s\n",
+		       ap->id, ata_thr_state_name(ap->thr_state));
+		break;
+	}
+
+	DPRINTK("ata%u: new thr_state %s, returning %ld\n",
+		ap->id, ata_thr_state_name(ap->thr_state), timeout);
+	return timeout;
+}
+
+/**
+ *	ata_thread -
+ *	@data:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static int ata_thread (void *data)
+{
+        struct ata_port *ap = data;
+	long timeout;
+
+	daemonize ();
+	reparent_to_init();
+	spin_lock_irq(&current->sigmask_lock);
+	sigemptyset(&current->blocked);
+	recalc_sigpending(current);
+	spin_unlock_irq(&current->sigmask_lock);
+
+	sprintf(current->comm, "katad-%u", ap->id);
+
+        while (1) {
+		cond_resched();
+
+		timeout = ata_thread_iter(ap);
+
+                if (signal_pending (current)) {
+                        spin_lock_irq(&current->sigmask_lock);
+                        flush_signals(current);
+                        spin_unlock_irq(&current->sigmask_lock);
+                }
+
+                if ((timeout < 0) || (ap->time_to_die))
+                        break;
+
+ 		/* note sleeping for full timeout not guaranteed (that's ok) */
+		if (timeout) {
+			mod_timer(&ap->thr_timer, jiffies + timeout);
+			down_interruptible(&ap->thr_sem);
+
+                	if (signal_pending (current)) {
+                        	spin_lock_irq(&current->sigmask_lock);
+                        	flush_signals(current);
+                        	spin_unlock_irq(&current->sigmask_lock);
+                	}
+
+                	if (ap->time_to_die)
+                        	break;
+		}
+        }
+
+	printk(KERN_DEBUG "ata%u: thread exiting\n", ap->id);
+	ap->thr_pid = -1;
+        complete_and_exit (&ap->thr_exited, 0);
+}
+
+/**
+ *	ata_thread_kill - kill per-port kernel thread
+ *	@ap: port those thread is to be killed
+ *
+ *	LOCKING:
+ *
+ */
+
+static int ata_thread_kill(struct ata_port *ap)
+{
+	int ret = 0;
+
+	if (ap->thr_pid >= 0) {
+		ap->time_to_die = 1;
+		wmb();
+		ret = kill_proc(ap->thr_pid, SIGTERM, 1);
+		if (ret)
+			printk(KERN_ERR "ata%d: unable to kill kernel thread\n",
+			       ap->id);
+		else
+			wait_for_completion(&ap->thr_exited);
+	}
+
+	return ret;
+}
+
+/**
+ *	atapi_cdb_send - Write CDB bytes to hardware
+ *	@ap: Port to which ATAPI device is attached.
+ *
+ *	When device has indicated its readiness to accept
+ *	a CDB, this function is called.  Send the CDB.
+ *	If DMA is to be performed, exit immediately.
+ *	Otherwise, we are in polling mode, so poll
+ *	status under operation succeeds or fails.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep)
+ */
+
+static void atapi_cdb_send(struct ata_port *ap)
+{
+	struct ata_queued_cmd *qc;
+	u8 status;
+
+	qc = ata_qc_from_tag(ap, ap->active_tag);
+	assert(qc != NULL);
+	assert(qc->flags & ATA_QCFLAG_ACTIVE);
+
+	/* sleep-wait for BSY to clear */
+	DPRINTK("busy wait\n");
+	if (ata_busy_sleep(ap, ATA_TMOUT_CDB_QUICK, ATA_TMOUT_CDB))
+		goto err_out;
+
+	/* make sure DRQ is set */
+	status = ata_chk_status(ap);
+	if ((status & ATA_DRQ) == 0)
+		goto err_out;
+
+	/* send SCSI cdb */
+	/* FIXME: mmio-ize */
+	DPRINTK("send cdb\n");
+	outsl(ap->ioaddr.cmd_addr + ATA_REG_DATA,
+	      qc->scsicmd->cmnd, ap->host->max_cmd_len / 4);
+
+	/* if we are DMA'ing, irq handler takes over from here */
+	if (qc->tf.feature == ATAPI_PKT_DMA)
+		goto out;
+
+	/* sleep-wait for BSY to clear */
+	DPRINTK("busy wait 2\n");
+	if (ata_busy_sleep(ap, ATA_TMOUT_CDB_QUICK, ATA_TMOUT_CDB))
+		goto err_out;
+
+	/* wait for BSY,DRQ to clear */
+	status = ata_wait_idle(ap);
+	if (status & (ATA_BUSY | ATA_DRQ))
+		goto err_out;
+
+	/* transaction completed, indicate such to scsi stack */
+	ata_qc_complete(qc, status, 0);
+	ata_irq_on(ap);
+
+out:
+	ap->thr_state = THR_IDLE;
+	return;
+
+err_out:
+	ata_qc_complete(qc, ATA_ERR, 0);
+	goto out;
+}
+
+/**
+ *	ata_host_remove -
+ *	@ap:
+ *	@do_unregister:
+ *
+ *	LOCKING:
+ */
+
+static void ata_host_remove(struct ata_port *ap, unsigned int do_unregister)
+{
+	struct Scsi_Host *sh = ap->host;
+
+	DPRINTK("ENTER\n");
+
+	if (do_unregister)
+		scsi_unregister(sh);
+
+	pci_free_consistent(ap->host_set->pdev, ATA_PRD_TBL_SZ, ap->prd, ap->prd_dma);
+}
+
+/**
+ *	ata_host_init -
+ *	@host:
+ *	@ent:
+ *	@port_no:
+ *
+ *	LOCKING:
+ *
+ */
+
+static void ata_host_init(struct ata_port *ap, struct Scsi_Host *host,
+			  struct ata_host_set *host_set,
+			  struct ata_probe_ent *ent, unsigned int port_no)
+{
+	unsigned int i;
+
+	host->max_id = 16;
+	host->max_lun = 1;
+	host->max_channel = 1;
+	host->unique_id = ata_unique_id++;
+	host->max_cmd_len = 12;
+	host->pci_dev = ent->pdev;
+
+	ap->flags = ATA_FLAG_PORT_DISABLED;
+	ap->id = host->unique_id;
+	ap->host = host;
+	ap->ctl = ATA_DEVCTL_OBS;
+	ap->host_set = host_set;
+	ap->port_no = port_no;
+	ap->pio_mask = ent->pio_mask;
+	ap->udma_mask = ent->udma_mask;
+	ap->flags |= ent->host_flags;
+	ap->ops = ent->host_info;
+	ap->thr_state = THR_PROBE_START;
+	ap->cbl = ATA_CBL_NONE;
+	ap->device[0].flags = ATA_DFLAG_MASTER;
+	ap->active_tag = ATA_TAG_POISON;
+
+	/* ata_engine init */
+	ap->eng.flags = 0;
+	INIT_LIST_HEAD(&ap->eng.q);
+
+	for (i = 0; i < ATA_MAX_DEVICES; i++)
+		ap->device[i].devno = i;
+
+	init_completion(&ap->thr_exited);
+	init_MUTEX_LOCKED(&ap->probe_sem);
+	init_MUTEX_LOCKED(&ap->sem);
+	init_MUTEX_LOCKED(&ap->thr_sem);
+
+	init_timer(&ap->thr_timer);
+	ap->thr_timer.function = ata_thread_timer;
+	ap->thr_timer.data = (unsigned long) ap;
+
+#ifdef ATA_IRQ_TRAP
+	ap->stats.unhandled_irq = 1;
+	ap->stats.idle_irq = 1;
+#endif
+
+	memcpy(&ap->ioaddr, &ent->port[port_no], sizeof(struct ata_ioports));
+}
+
+/**
+ *	ata_host_add -
+ *	@ent:
+ *	@host_set:
+ *	@port_no:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static struct ata_port * ata_host_add(struct ata_probe_ent *ent,
+				      struct ata_host_set *host_set,
+				      unsigned int port_no)
+{
+	struct pci_dev *pdev = ent->pdev;
+	struct Scsi_Host *host;
+	struct ata_port *ap;
+
+	DPRINTK("ENTER\n");
+	host = scsi_register(ent->sht, sizeof(struct ata_port));
+	if (!host)
+		return NULL;
+
+	ap = (struct ata_port *) &host->hostdata[0];
+
+	ata_host_init(ap, host, host_set, ent, port_no);
+
+	ap->prd = pci_alloc_consistent(pdev, ATA_PRD_TBL_SZ, &ap->prd_dma);
+	if (!ap->prd)
+		goto err_out;
+	DPRINTK("prd alloc, virt %p, dma %x\n", ap->prd, ap->prd_dma);
+
+	ap->thr_pid = kernel_thread(ata_thread, ap, CLONE_FS | CLONE_FILES);
+	if (ap->thr_pid < 0) {
+		printk(KERN_ERR "ata%d: unable to start kernel thread\n",
+		       ap->id);
+		goto err_out_free;
+	}
+
+	return ap;
+
+err_out_free:
+	pci_free_consistent(ap->host_set->pdev, ATA_PRD_TBL_SZ, ap->prd, ap->prd_dma);
+err_out:
+	scsi_unregister(host);
+	return NULL;
+}
+
+/**
+ *	ata_device_add -
+ *	@ent:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static int ata_device_add(struct ata_probe_ent *ent)
+{
+	unsigned int count = 0, i;
+	struct pci_dev *pdev = ent->pdev;
+	struct ata_host_set *host_set;
+
+	DPRINTK("ENTER\n");
+	/* alloc a container for our list of ATA ports (buses) */
+	host_set = kmalloc(sizeof(struct ata_host_set) +
+			   (ent->n_ports * sizeof(void *)), GFP_KERNEL);
+	if (!host_set)
+		return 0;
+	memset(host_set, 0, sizeof(struct ata_host_set) + (ent->n_ports * sizeof(void *)));
+	spin_lock_init(&host_set->lock);
+
+	host_set->pdev = pdev;
+	host_set->n_hosts = ent->n_ports;
+	host_set->irq = ent->irq;
+
+	/* register each port bound to this device */
+	for (i = 0; i < ent->n_ports; i++) {
+		struct ata_port *ap;
+
+		ap = ata_host_add(ent, host_set, i);
+		if (!ap)
+			goto err_out;
+
+		host_set->hosts[i] = ap;
+
+		/* print per-port info to dmesg */
+		printk(KERN_INFO "ata%u: %cATA max %s cmd 0x%lX ctl 0x%lX "
+				 "bmdma 0x%lX irq %lu\n",
+			ap->id,
+			ap->flags & ATA_FLAG_SATA ? 'S' : 'P',
+			ata_udma_string(ent->udma_mask),
+	       		ap->ioaddr.cmd_addr,
+	       		ap->ioaddr.ctl_addr,
+	       		ap->ioaddr.bmdma_addr,
+	       		ent->irq);
+
+		count++;
+	}
+
+	if (!count) {
+		kfree(host_set);
+		return 0;
+	}
+
+	/* obtain irq, that is shared between channels */
+	if (request_irq(ent->irq, ata_interrupt, ent->irq_flags,
+			DRV_NAME, host_set))
+		goto err_out;
+
+	/* perform each probe synchronously */
+	DPRINTK("probe begin\n");
+	for (i = 0; i < count; i++) {
+		struct ata_port *ap;
+
+		ap = host_set->hosts[i];
+
+		DPRINTK("ata%u: probe begin\n", ap->id);
+		up(&ap->sem);		/* start probe */
+
+		DPRINTK("ata%u: probe-wait begin\n", ap->id);
+		down(&ap->probe_sem);	/* wait for end */
+
+		DPRINTK("ata%u: probe-wait end\n", ap->id);
+	}
+
+	pci_set_drvdata(pdev, host_set);
+
+	VPRINTK("EXIT, returning %u\n", ent->n_ports);
+	return ent->n_ports; /* success */
+
+err_out:
+	for (i = 0; i < count; i++) {
+		ata_host_remove(host_set->hosts[i], 1);
+	}
+	kfree(host_set);
+	VPRINTK("EXIT, returning 0\n");
+	return 0;
+}
+
+/**
+ *	ata_scsi_detect -
+ *	@sht:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+int ata_scsi_detect(Scsi_Host_Template *sht)
+{
+	struct list_head *node;
+	struct ata_probe_ent *ent;
+	int count = 0;
+
+	VPRINTK("ENTER\n");
+
+	sht->use_new_eh_code = 1;	/* IORL hack, part deux */
+
+	spin_lock(&ata_module_lock);
+	while (!list_empty(&ata_probe_list)) {
+		node = ata_probe_list.next;
+		ent = list_entry(node, struct ata_probe_ent, node);
+		list_del(node);
+
+		spin_unlock(&ata_module_lock);
+
+		count += ata_device_add(ent);
+		kfree(ent);
+
+		spin_lock(&ata_module_lock);
+	}
+	spin_unlock(&ata_module_lock);
+
+	VPRINTK("EXIT, returning %d\n", count);
+	return count;
+}
+
+/**
+ *	ata_scsi_release - SCSI layer callback hook for host unload
+ *	@host: libata host to be unloaded
+ *
+ *	Performs all duties necessary to shut down a libata port:
+ *	Kill port kthread, disable port, and release resources.
+ *
+ *	LOCKING:
+ *	Inherited from SCSI layer.
+ *
+ *	RETURNS:
+ *	One.
+ */
+
+int ata_scsi_release(struct Scsi_Host *host)
+{
+	struct ata_port *ap = (struct ata_port *) &host->hostdata[0];
+
+	DPRINTK("ENTER\n");
+
+	ata_thread_kill(ap);	/* FIXME: check return val */
+
+	ap->ops->port_disable(ap);
+	ata_host_remove(ap, 0);
+
+	DPRINTK("EXIT\n");
+	return 1;
+}
+
+/**
+ *	ata_pci_init_one -
+ *	@pdev:
+ *	@boards:
+ *	@n_boards:
+ *
+ *	LOCKING:
+ *	Inherited from PCI layer (may sleep).
+ *
+ *	RETURNS:
+ *
+ */
+
+int ata_pci_init_one (struct pci_dev *pdev, struct ata_board **boards,
+		      unsigned int n_boards)
+{
+	struct ata_probe_ent *probe_ent, *probe_ent2 = NULL;
+	struct ata_board *board1, *board2;
+	u8 tmp8, mask;
+	unsigned int legacy_mode = 0;
+	int rc;
+
+	DPRINTK("ENTER\n");
+
+	board1 = boards[0];
+	if (n_boards > 1)
+		board2 = boards[1];
+	else
+		board2 = board1;
+
+	if ((board1->host_flags & ATA_FLAG_NO_LEGACY) == 0) {
+		/* TODO: support transitioning to native mode? */
+		pci_read_config_byte(pdev, PCI_CLASS_PROG, &tmp8);
+		mask = (1 << 2) | (1 << 0);
+		if ((tmp8 & mask) != mask)
+			legacy_mode = 1;
+	}
+
+	/* FIXME... */
+	if ((!legacy_mode) && (n_boards > 1)) {
+		printk(KERN_ERR "ata: BUG: native mode, n_boards > 1\n");
+		return -EINVAL;
+	}
+
+	rc = pci_enable_device(pdev);
+	if (rc)
+		return rc;
+
+	rc = pci_request_regions(pdev, DRV_NAME);
+	if (rc)
+		goto err_out;
+
+	rc = pci_set_dma_mask(pdev, ATA_DMA_MASK);
+	if (rc)
+		goto err_out_regions;
+
+	probe_ent = kmalloc(sizeof(*probe_ent), GFP_KERNEL);
+	if (!probe_ent) {
+		rc = -ENOMEM;
+		goto err_out_regions;
+	}
+
+	memset(probe_ent, 0, sizeof(*probe_ent));
+	probe_ent->pdev = pdev;
+	INIT_LIST_HEAD(&probe_ent->node);
+
+	if (legacy_mode) {
+		probe_ent2 = kmalloc(sizeof(*probe_ent), GFP_KERNEL);
+		if (!probe_ent2) {
+			rc = -ENOMEM;
+			goto err_out_free_ent;
+		}
+
+		memset(probe_ent2, 0, sizeof(*probe_ent));
+		probe_ent2->pdev = pdev;
+		INIT_LIST_HEAD(&probe_ent2->node);
+	}
+
+	probe_ent->port[0].bmdma_addr = pci_resource_start(pdev, 4);
+	probe_ent->sht = board1->sht;
+	probe_ent->host_flags = board1->host_flags;
+	probe_ent->pio_mask = board1->pio_mask;
+	probe_ent->udma_mask = board1->udma_mask;
+	probe_ent->host_info = board1->host_info;
+
+	if (legacy_mode) {
+		probe_ent->port[0].cmd_addr = 0x1f0;
+		probe_ent->port[0].ctl_addr = 0x3f6;
+		probe_ent->n_ports = 1;
+		probe_ent->irq = 14;
+
+		probe_ent2->port[0].cmd_addr = 0x170;
+		probe_ent2->port[0].ctl_addr = 0x376;
+		probe_ent2->port[0].bmdma_addr = pci_resource_start(pdev, 4)+8;
+		probe_ent2->n_ports = 1;
+		probe_ent2->irq = 15;
+
+		probe_ent2->sht = board2->sht;
+		probe_ent2->host_flags = board2->host_flags;
+		probe_ent2->pio_mask = board2->pio_mask;
+		probe_ent2->udma_mask = board2->udma_mask;
+		probe_ent2->host_info = board2->host_info;
+	} else {
+		probe_ent->port[0].cmd_addr = pci_resource_start(pdev, 0);
+		probe_ent->port[0].ctl_addr =
+			pci_resource_start(pdev, 1) | ATA_PCI_CTL_OFS;
+
+		probe_ent->port[1].cmd_addr = pci_resource_start(pdev, 2);
+		probe_ent->port[1].ctl_addr =
+			pci_resource_start(pdev, 3) | ATA_PCI_CTL_OFS;
+		probe_ent->port[1].bmdma_addr = pci_resource_start(pdev, 4) + 8;
+
+		probe_ent->n_ports = 2;
+		probe_ent->irq = pdev->irq;
+		probe_ent->irq_flags = SA_SHIRQ;
+	}
+
+	pci_set_master(pdev);
+
+	spin_lock(&ata_module_lock);
+	list_add_tail(&probe_ent->node, &ata_probe_list);
+	if (legacy_mode)
+		list_add_tail(&probe_ent2->node, &ata_probe_list);
+	spin_unlock(&ata_module_lock);
+
+	return 0;
+
+err_out_free_ent:
+	kfree(probe_ent);
+err_out_regions:
+	pci_release_regions(pdev);
+err_out:
+	pci_disable_device(pdev);
+	return rc;
+}
+
+/**
+ *	ata_pci_remove_one - PCI layer callback for device removal
+ *	@pdev: PCI device that was removed
+ *
+ *	PCI layer indicates to libata via this hook that
+ *	hot-unplug or module unload event has occured.
+ *	Handle this by unregistering all objects associated
+ *	with this PCI device.  Free those objects.  Then finally
+ *	release PCI resources and disable device.
+ *
+ *	LOCKING:
+ *	Inherited from PCI layer (may sleep).
+ */
+
+void ata_pci_remove_one (struct pci_dev *pdev)
+{
+	struct ata_host_set *host_set = pci_get_drvdata(pdev);
+	struct ata_port *ap;
+	Scsi_Host_Template *sht;
+	int rc;
+
+	/* FIXME: this unregisters all hosts attached to the
+	 * Scsi_Host_Template given.  We _might_ have multiple
+	 * templates (though we don't ATM), so this is ok... for now.
+	 */
+	ap = host_set->hosts[0];
+	sht = ap->host->hostt;
+	rc = scsi_unregister_module(MODULE_SCSI_HA, sht);
+	/* FIXME: handle 'rc' failure? */
+
+	free_irq(host_set->irq, host_set);
+	kfree(host_set);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+}
+
+/* move to PCI subsystem */
+int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits)
+{
+	unsigned long tmp = 0;
+
+	switch (bits->width) {
+	case 1: {
+		u8 tmp8 = 0;
+		pci_read_config_byte(pdev, bits->reg, &tmp8);
+		tmp = tmp8;
+		break;
+	}
+	case 2: {
+		u16 tmp16 = 0;
+		pci_read_config_word(pdev, bits->reg, &tmp16);
+		tmp = tmp16;
+		break;
+	}
+	case 4: {
+		u32 tmp32 = 0;
+		pci_read_config_dword(pdev, bits->reg, &tmp32);
+		tmp = tmp32;
+		break;
+	}
+
+	default:
+		return -EINVAL;
+	}
+
+	tmp &= bits->mask;
+
+	return (tmp == bits->val) ? 1 : 0;
+}
+
+/**
+ *	ata_init -
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static int __init ata_init(void)
+{
+	printk(KERN_DEBUG "libata version " DRV_VERSION " loaded.\n");
+	return 0;
+}
+
+module_init(ata_init);
+
+EXPORT_SYMBOL(pci_test_config_bits);
+EXPORT_SYMBOL(ata_tf_load_pio);
+EXPORT_SYMBOL(ata_tf_load_mmio);
+EXPORT_SYMBOL(ata_tf_read_pio);
+EXPORT_SYMBOL(ata_tf_read_mmio);
+EXPORT_SYMBOL(ata_bmdma_start_pio);
+EXPORT_SYMBOL(ata_bmdma_start_mmio);
+EXPORT_SYMBOL(ata_port_probe);
+EXPORT_SYMBOL(ata_port_disable);
+EXPORT_SYMBOL(ata_pci_init_one);
+EXPORT_SYMBOL(ata_pci_remove_one);
+EXPORT_SYMBOL(ata_scsi_detect);
+EXPORT_SYMBOL(ata_scsi_release);
+EXPORT_SYMBOL(ata_scsi_queuecmd);
+EXPORT_SYMBOL(ata_scsi_error);
+
diff -urN linux-2.4.22/drivers/scsi/libata-scsi.c linux-2.4.22-ide/drivers/scsi/libata-scsi.c
--- linux-2.4.22/drivers/scsi/libata-scsi.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/drivers/scsi/libata-scsi.c	Sun Sep 21 01:50:18 2003
@@ -0,0 +1,1074 @@
+/*
+   libata-scsi.c - helper library for ATA
+
+   Copyright 2003 Red Hat, Inc.  All rights reserved.
+   Copyright 2003 Jeff Garzik
+
+   The contents of this file are subject to the Open
+   Software License version 1.1 that can be found at
+   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+   by reference.
+
+   Alternatively, the contents of this file may be used under the terms
+   of the GNU General Public License version 2 (the "GPL") as distributed
+   in the kernel source COPYING file, in which case the provisions of
+   the GPL are applicable instead of the above.  If you wish to allow
+   the use of your version of this file only under the terms of the
+   GPL and not to allow others to use your version of this file under
+   the OSL, indicate your decision by deleting the provisions above and
+   replace them with the notice and other provisions required by the GPL.
+   If you do not delete the provisions above, a recipient may use your
+   version of this file under either the OSL or the GPL.
+
+ */
+
+#include <linux/kernel.h>
+#include <linux/blk.h>
+#include <linux/blkdev.h>
+#include <linux/spinlock.h>
+#include <scsi/scsi.h>
+#include "scsi.h"
+#include "hosts.h"
+#include <linux/ata.h>
+
+#include "libata.h"
+
+/**
+ *	ata_to_sense_error -
+ *	@qc:
+ *	@cmd:
+ *
+ *	LOCKING:
+ */
+
+void ata_to_sense_error(struct ata_queued_cmd *qc)
+{
+	Scsi_Cmnd *cmd = qc->scsicmd;
+
+	cmd->result = SAM_STAT_CHECK_CONDITION;
+
+	cmd->sense_buffer[0] = 0x70;
+	cmd->sense_buffer[2] = MEDIUM_ERROR;
+	cmd->sense_buffer[7] = 14 - 8;	/* addnl. sense len. FIXME: correct? */
+
+	/* additional-sense-code[-qualifier] */
+	if ((qc->flags & ATA_QCFLAG_WRITE) == 0) {
+		cmd->sense_buffer[12] = 0x11; /* "unrecovered read error" */
+		cmd->sense_buffer[13] = 0x04;
+	} else {
+		cmd->sense_buffer[12] = 0x0C; /* "write error -             */
+		cmd->sense_buffer[13] = 0x02; /*  auto-reallocation failed" */
+	}
+}
+
+/**
+ *	ata_scsi_error - SCSI layer error handler callback
+ *	@host: SCSI host on which error occurred
+ *
+ *	Handles SCSI-layer-thrown error events.
+ *
+ *	LOCKING:
+ *	Inherited from SCSI layer (none, can sleep)
+ *
+ *	RETURNS:
+ *	Zero.
+ */
+
+int ata_scsi_error(struct Scsi_Host *host)
+{
+	struct ata_port *ap;
+
+	DPRINTK("ENTER\n");
+
+	ap = (struct ata_port *) &host->hostdata[0];
+	ata_eng_timeout(ap);
+
+	DPRINTK("EXIT\n");
+	return 0;
+}
+
+/**
+ *	ata_scsi_rw_xlat -
+ *	@qc:
+ *	@scsicmd:
+ *	@cmd_size:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ *
+ *	RETURNS:
+ *
+ */
+
+static unsigned int ata_scsi_rw_xlat(struct ata_queued_cmd *qc, u8 *scsicmd,
+				   unsigned int cmd_size)
+{
+	struct ata_taskfile *tf = &qc->tf;
+	unsigned int lba48 = tf->flags & ATA_TFLAG_LBA48;
+	unsigned int dma = qc->flags & ATA_QCFLAG_DMA;
+
+	qc->cursect = qc->cursg = qc->cursg_ofs = 0;
+	tf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
+	tf->hob_nsect = 0;
+	tf->hob_lbal = 0;
+	tf->hob_lbam = 0;
+	tf->hob_lbah = 0;
+
+	if (scsicmd[0] == READ_10 || scsicmd[0] == READ_6 ||
+	    scsicmd[0] == READ_16) {
+		if (likely(dma)) {
+			if (lba48)
+				tf->command = ATA_CMD_READ_EXT;
+			else
+				tf->command = ATA_CMD_READ;
+			tf->protocol = ATA_PROT_DMA_READ;
+		} else {
+			if (lba48)
+				tf->command = ATA_CMD_PIO_READ_EXT;
+			else
+				tf->command = ATA_CMD_PIO_READ;
+			tf->protocol = ATA_PROT_PIO_READ;
+		}
+		qc->flags &= ~ATA_QCFLAG_WRITE;
+		VPRINTK("reading\n");
+	} else {
+		if (likely(dma)) {
+			if (lba48)
+				tf->command = ATA_CMD_WRITE_EXT;
+			else
+				tf->command = ATA_CMD_WRITE;
+			tf->protocol = ATA_PROT_DMA_WRITE;
+		} else {
+			if (lba48)
+				tf->command = ATA_CMD_PIO_WRITE_EXT;
+			else
+				tf->command = ATA_CMD_PIO_WRITE;
+			tf->protocol = ATA_PROT_PIO_WRITE;
+		}
+		qc->flags |= ATA_QCFLAG_WRITE;
+		VPRINTK("writing\n");
+	}
+
+	if (cmd_size == 10) {
+		if (lba48) {
+			tf->hob_nsect = scsicmd[7];
+			tf->hob_lbal = scsicmd[2];
+
+			qc->nsect = ((unsigned int)scsicmd[7] << 8) |
+					scsicmd[8];
+		} else {
+			/* if we don't support LBA48 addressing, the request
+			 * -may- be too large. */
+			if ((scsicmd[2] & 0xf0) || scsicmd[7])
+				return 1;
+
+			/* stores LBA27:24 in lower 4 bits of device reg */
+			tf->device |= scsicmd[2];
+
+			qc->nsect = scsicmd[8];
+		}
+		tf->device |= ATA_LBA;
+
+		tf->nsect = scsicmd[8];
+		tf->lbal = scsicmd[5];
+		tf->lbam = scsicmd[4];
+		tf->lbah = scsicmd[3];
+
+		VPRINTK("ten-byte command\n");
+		return 0;
+	}
+
+	if (cmd_size == 6) {
+		qc->nsect = tf->nsect = scsicmd[4];
+		tf->lbal = scsicmd[3];
+		tf->lbam = scsicmd[2];
+		tf->lbah = scsicmd[1] & 0x1f; /* mask out reserved bits */
+
+		VPRINTK("six-byte command\n");
+		return 0;
+	}
+
+	if (cmd_size == 16) {
+		/* rule out impossible LBAs and sector counts */
+		if (scsicmd[2] || scsicmd[3] || scsicmd[10] || scsicmd[11])
+			return 1;
+
+		if (lba48) {
+			tf->hob_nsect = scsicmd[12];
+			tf->hob_lbal = scsicmd[6];
+			tf->hob_lbam = scsicmd[5];
+			tf->hob_lbah = scsicmd[4];
+
+			qc->nsect = ((unsigned int)scsicmd[12] << 8) |
+					scsicmd[13];
+		} else {
+			/* once again, filter out impossible non-zero values */
+			if (scsicmd[4] || scsicmd[5] || scsicmd[12] ||
+			    (scsicmd[6] & 0xf0))
+				return 1;
+
+			/* stores LBA27:24 in lower 4 bits of device reg */
+			tf->device |= scsicmd[2];
+
+			qc->nsect = scsicmd[13];
+		}
+		tf->device |= ATA_LBA;
+
+		tf->nsect = scsicmd[13];
+		tf->lbal = scsicmd[9];
+		tf->lbam = scsicmd[8];
+		tf->lbah = scsicmd[7];
+
+		VPRINTK("sixteen-byte command\n");
+		return 0;
+	}
+
+	DPRINTK("no-byte command\n");
+	return 1;
+}
+
+/**
+ *	ata_scsi_rw_queue -
+ *	@ap:
+ *	@dev:
+ *	@cmd:
+ *	@done:
+ *	@cmd_size:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+void ata_scsi_rw_queue(struct ata_port *ap, struct ata_device *dev,
+		      Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *),
+		      unsigned int cmd_size)
+{
+	struct ata_queued_cmd *qc;
+	u8 *scsicmd = cmd->cmnd;
+
+	VPRINTK("ENTER\n");
+
+	if (unlikely(cmd->request_bufflen < 1)) {
+		printk(KERN_WARNING "ata%u(%u): empty request buffer\n",
+		       ap->id, dev->devno);
+		goto err_out;
+	}
+
+	qc = ata_qc_new_init(ap, dev, cmd, done);
+	if (!qc)
+		return;
+
+	qc->flags |= ATA_QCFLAG_SG;	/* data is present; dma-map it */
+
+	if (ata_scsi_rw_xlat(qc, scsicmd, cmd_size))
+		goto err_out;
+
+	/* select device, send command to hardware */
+	if (ata_qc_issue(qc))
+		goto err_out;
+
+	VPRINTK("EXIT\n");
+	return;
+
+err_out:
+	ata_bad_cdb(cmd, done);
+	DPRINTK("EXIT - badcmd\n");
+}
+
+/**
+ *	ata_scsi_rbuf_get - Map response buffer.
+ *	@cmd: SCSI command containing buffer to be mapped.
+ *	@buf_out: Pointer to mapped area.
+ *
+ *	Maps buffer contained within SCSI command @cmd.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ *	FIXME: kmap inside spin_lock_irqsave ok?
+ *
+ *	RETURNS:
+ *	Length of response buffer.
+ */
+
+static unsigned int ata_scsi_rbuf_get(Scsi_Cmnd *cmd, u8 **buf_out)
+{
+	u8 *buf;
+	unsigned int buflen;
+
+	if (cmd->use_sg) {
+		struct scatterlist *sg;
+
+		sg = (struct scatterlist *) cmd->request_buffer;
+		buf = kmap(sg->page) + sg->offset;
+		buflen = sg->length;
+	} else {
+		buf = cmd->request_buffer;
+		buflen = cmd->request_bufflen;
+	}
+
+	memset(buf, 0, buflen);
+	*buf_out = buf;
+	return buflen;
+}
+
+/**
+ *	ata_scsi_rbuf_put - Unmap response buffer.
+ *	@cmd: SCSI command containing buffer to be unmapped.
+ *
+ *	Unmaps response buffer contained within @cmd.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+static inline void ata_scsi_rbuf_put(Scsi_Cmnd *cmd)
+{
+	if (cmd->use_sg) {
+		struct scatterlist *sg;
+
+		sg = (struct scatterlist *) cmd->request_buffer;
+		kunmap(sg->page);
+	}
+}
+
+/**
+ *	ata_scsi_rbuf_fill - wrapper for SCSI command simulators
+ *	@args: Port / device / SCSI command of interest.
+ *	@actor: Callback hook for desired SCSI command simulator
+ *
+ *	Takes care of the hard work of simulating a SCSI command...
+ *	Mapping the response buffer, calling the command's handler,
+ *	and handling the handler's return value.  This return value
+ *	indicates whether the handler wishes the SCSI command to be
+ *	completed successfully, or not.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+void ata_scsi_rbuf_fill(struct ata_scsi_args *args,
+		        unsigned int (*actor) (struct ata_scsi_args *args,
+			     		   u8 *rbuf, unsigned int buflen))
+{
+	u8 *rbuf;
+	unsigned int buflen, rc;
+	Scsi_Cmnd *cmd = args->cmd;
+
+	buflen = ata_scsi_rbuf_get(cmd, &rbuf);
+	rc = actor(args, rbuf, buflen);
+	ata_scsi_rbuf_put(cmd);
+
+	if (rc)
+		ata_bad_cdb(cmd, args->done);
+	else {
+		cmd->result = SAM_STAT_GOOD;
+		args->done(cmd);
+	}
+}
+
+/**
+ *	ata_scsiop_inq_std - Simulate INQUIRY command
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	Returns standard device identification data associated
+ *	with non-EVPD INQUIRY command output.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf,
+			       unsigned int buflen)
+{
+	const u8 hdr[] = {
+		TYPE_DISK,
+		0,
+		0x5,	/* claim SPC-3 version compatibility */
+		2,
+		96 - 4
+	};
+
+	VPRINTK("ENTER\n");
+
+	memcpy(rbuf, hdr, sizeof(hdr));
+
+	if (buflen > 36) {
+		memcpy(&rbuf[8], args->dev->vendor, 8);
+		memcpy(&rbuf[16], args->dev->product, 16);
+		memcpy(&rbuf[32], DRV_VERSION, 4);
+	}
+
+	if (buflen > 63) {
+		const u8 versions[] = {
+			0x60,	/* SAM-3 (no version claimed) */
+
+			0x03,
+			0x20,	/* SBC-2 (no version claimed) */
+
+			0x02,
+			0x60	/* SPC-3 (no version claimed) */
+		};
+
+		memcpy(rbuf + 59, versions, sizeof(versions));
+	}
+
+	return 0;
+}
+
+/**
+ *	ata_scsiop_inq_00 - Simulate INQUIRY EVPD page 0, list of pages
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	Returns list of inquiry EVPD pages available.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_inq_00(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen)
+{
+	const u8 pages[] = {
+		0x00,	/* page 0x00, this page */
+		0x80,	/* page 0x80, unit serial no page */
+		0x83	/* page 0x83, device ident page */
+	};
+	rbuf[3] = sizeof(pages);	/* number of supported EVPD pages */
+
+	if (buflen > 6)
+		memcpy(rbuf + 4, pages, sizeof(pages));
+
+	return 0;
+}
+
+/**
+ *	ata_scsiop_inq_80 - Simulate INQUIRY EVPD page 80, device serial number
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	Returns ATA device serial number.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_inq_80(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen)
+{
+	const u8 hdr[] = {
+		0,
+		0x80,			/* this page code */
+		0,
+		ATA_SERNO_LEN,		/* page len */
+	};
+	memcpy(rbuf, hdr, sizeof(hdr));
+
+	if (buflen > (ATA_SERNO_LEN + 4))
+		ata_dev_id_string(args->dev, (unsigned char *) &rbuf[4],
+				  ATA_ID_SERNO_OFS, ATA_SERNO_LEN);
+
+	return 0;
+}
+
+static const char *inq_83_str = "Linux ATA-SCSI simulator";
+
+/**
+ *	ata_scsiop_inq_83 - Simulate INQUIRY EVPD page 83, device identity
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	Returns device identification.  Currently hardcoded to
+ *	return "Linux ATA-SCSI simulator".
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_inq_83(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen)
+{
+	rbuf[1] = 0x83;			/* this page code */
+	rbuf[3] = 4 + strlen(inq_83_str);	/* page len */
+
+	/* our one and only identification descriptor (vendor-specific) */
+	if (buflen > (strlen(inq_83_str) + 4 + 4)) {
+		rbuf[4 + 0] = 2;	/* code set: ASCII */
+		rbuf[4 + 3] = strlen(inq_83_str);
+		memcpy(rbuf + 4 + 4, inq_83_str, strlen(inq_83_str));
+	}
+
+	return 0;
+}
+
+/**
+ *	ata_scsiop_noop -
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	No operation.  Simply returns success to caller, to indicate
+ *	that the caller should successfully complete this SCSI command.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_noop(struct ata_scsi_args *args, u8 *rbuf,
+			    unsigned int buflen)
+{
+	VPRINTK("ENTER\n");
+	return 0;
+}
+
+/**
+ *	ata_scsiop_sync_cache - Simulate SYNCHRONIZE CACHE command
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	Initiates flush of device's cache.
+ *
+ *	TODO:
+ *	Actually do this :)
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_sync_cache(struct ata_scsi_args *args, u8 *rbuf,
+				  unsigned int buflen)
+{
+	VPRINTK("ENTER\n");
+
+	/* FIXME */
+	return 1;
+}
+
+/**
+ *	ata_msense_push - Push data onto MODE SENSE data output buffer
+ *	@ptr_io: (input/output) Location to store more output data
+ *	@last: End of output data buffer
+ *	@buf: Pointer to BLOB being added to output buffer
+ *	@buflen: Length of BLOB
+ *
+ *	Store MODE SENSE data on an output buffer.
+ *
+ *	LOCKING:
+ *	None.
+ */
+
+static void ata_msense_push(u8 **ptr_io, const u8 *last,
+			    const u8 *buf, unsigned int buflen)
+{
+	u8 *ptr = *ptr_io;
+
+	if ((ptr + buflen - 1) > last)
+		return;
+
+	memcpy(ptr, buf, buflen);
+
+	ptr += buflen;
+
+	*ptr_io = ptr;
+}
+
+/**
+ *	ata_msense_caching - Simulate MODE SENSE caching info page
+ *	@dev:
+ *	@ptr_io:
+ *	@last:
+ *
+ *	Generate a caching info page, which conditionally indicates
+ *	write caching to the SCSI layer, depending on device
+ *	capabilities.
+ *
+ *	LOCKING:
+ *	None.
+ */
+
+static unsigned int ata_msense_caching(struct ata_device *dev, u8 **ptr_io,
+				       const u8 *last)
+{
+	u8 page[7] = { 0xf, 0, 0x10, 0, 0x8, 0xa, 0 };
+	if (dev->flags & ATA_DFLAG_WCACHE)
+		page[6] = 0x4;
+
+	ata_msense_push(ptr_io, last, page, sizeof(page));
+	return sizeof(page);
+}
+
+/**
+ *	ata_msense_ctl_mode - Simulate MODE SENSE control mode page
+ *	@dev:
+ *	@ptr_io:
+ *	@last:
+ *
+ *	Generate a generic MODE SENSE control mode page.
+ *
+ *	LOCKING:
+ *	None.
+ */
+
+static unsigned int ata_msense_ctl_mode(u8 **ptr_io, const u8 *last)
+{
+	const u8 page[] = {0xa, 0xa, 2, 0, 0, 0, 0, 0, 0xff, 0xff, 0, 30};
+
+	ata_msense_push(ptr_io, last, page, sizeof(page));
+	return sizeof(page);
+}
+
+/**
+ *	ata_scsiop_mode_sense - Simulate MODE SENSE 6, 10 commands
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	Simulate MODE SENSE commands.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_mode_sense(struct ata_scsi_args *args, u8 *rbuf,
+				  unsigned int buflen)
+{
+	u8 *scsicmd = args->cmd->cmnd, *p, *last;
+	struct ata_device *dev = args->dev;
+	unsigned int page_control, six_byte, output_len;
+
+	VPRINTK("ENTER\n");
+
+	six_byte = (scsicmd[0] == MODE_SENSE);
+
+	/* we only support saved and current values (which we treat
+	 * in the same manner)
+	 */
+	page_control = scsicmd[2] >> 6;
+	if ((page_control != 0) && (page_control != 3))
+		return 1;
+
+	if (six_byte)
+		output_len = 4;
+	else
+		output_len = 8;
+
+	p = rbuf + output_len;
+	last = rbuf + buflen - 1;
+
+	switch(scsicmd[2] & 0x3f) {
+	case 0x08:		/* caching */
+		output_len += ata_msense_caching(dev, &p, last);
+		break;
+
+	case 0x0a: {		/* control mode */
+		output_len += ata_msense_ctl_mode(&p, last);
+		break;
+		}
+
+	case 0x3f:		/* all pages */
+		output_len += ata_msense_caching(dev, &p, last);
+		output_len += ata_msense_ctl_mode(&p, last);
+		break;
+
+	default:		/* invalid page code */
+		return 1;
+	}
+
+	if (six_byte) {
+		output_len--;
+		rbuf[0] = output_len;
+	} else {
+		output_len -= 2;
+		rbuf[0] = output_len >> 8;
+		rbuf[1] = output_len;
+	}
+
+	return 0;
+}
+
+/**
+ *	ata_scsiop_read_cap - Simulate READ CAPACITY[ 16] commands
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	Simulate READ CAPACITY commands.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf,
+			        unsigned int buflen)
+{
+	u64 n_sectors = args->dev->n_sectors;
+	u32 tmp;
+
+	VPRINTK("ENTER\n");
+
+	n_sectors--;		/* one off */
+
+	tmp = n_sectors;	/* note: truncates, if lba48 */
+	if (args->cmd->cmnd[0] == READ_CAPACITY) {
+		rbuf[0] = tmp >> (8 * 3);
+		rbuf[1] = tmp >> (8 * 2);
+		rbuf[2] = tmp >> (8 * 1);
+		rbuf[3] = tmp;
+
+		tmp = ATA_SECT_SIZE;
+		rbuf[6] = tmp >> 8;
+		rbuf[7] = tmp;
+
+	} else {
+		rbuf[2] = n_sectors >> (8 * 7);
+		rbuf[3] = n_sectors >> (8 * 6);
+		rbuf[4] = n_sectors >> (8 * 5);
+		rbuf[5] = n_sectors >> (8 * 4);
+		rbuf[6] = tmp >> (8 * 3);
+		rbuf[7] = tmp >> (8 * 2);
+		rbuf[8] = tmp >> (8 * 1);
+		rbuf[9] = tmp;
+
+		tmp = ATA_SECT_SIZE;
+		rbuf[12] = tmp >> 8;
+		rbuf[13] = tmp;
+	}
+
+	return 0;
+}
+
+/**
+ *	ata_scsiop_report_luns - Simulate REPORT LUNS command
+ *	@args: Port / device / SCSI command of interest.
+ *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.
+ *	@buflen: Response buffer length.
+ *
+ *	Simulate REPORT LUNS command.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+unsigned int ata_scsiop_report_luns(struct ata_scsi_args *args, u8 *rbuf,
+				   unsigned int buflen)
+{
+	VPRINTK("ENTER\n");
+	rbuf[3] = 8;	/* just one lun, LUN 0, size 8 bytes */
+
+	return 0;
+}
+
+/**
+ *	ata_scsi_badcmd -
+ *	@cmd:
+ *	@done:
+ *	@asc:
+ *	@ascq:
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+void ata_scsi_badcmd(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *), u8 asc, u8 ascq)
+{
+	DPRINTK("ENTER\n");
+	cmd->result = SAM_STAT_CHECK_CONDITION;
+
+	cmd->sense_buffer[0] = 0x70;
+	cmd->sense_buffer[2] = ILLEGAL_REQUEST;
+	cmd->sense_buffer[7] = 14 - 8;	/* addnl. sense len. FIXME: correct? */
+	cmd->sense_buffer[12] = asc;
+	cmd->sense_buffer[13] = ascq;
+
+	done(cmd);
+}
+
+/**
+ *	atapi_scsi_queuecmd - Send CDB to ATAPI device
+ *	@ap: Port to which ATAPI device is attached.
+ *	@dev: Target device for CDB.
+ *	@cmd: SCSI command being sent to device.
+ *	@done: SCSI command completion function.
+ *
+ *	Sends CDB to ATAPI device.  If the Linux SCSI layer sends a
+ *	non-data command, then this function handles the command
+ *	directly, via polling.  Otherwise, the bmdma engine is started.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+
+static void atapi_scsi_queuecmd(struct ata_port *ap, struct ata_device *dev,
+			       Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+{
+	struct ata_queued_cmd *qc;
+	u8 *scsicmd = cmd->cmnd, status;
+	unsigned int doing_dma = 0;
+
+	VPRINTK("ENTER, drv_stat = 0x%x\n", ata_chk_status(ap));
+
+	if (cmd->sc_data_direction == SCSI_DATA_UNKNOWN) {
+		DPRINTK("unknown data, scsicmd 0x%x\n", scsicmd[0]);
+		ata_bad_cdb(cmd, done);
+		return;
+	}
+
+	switch(scsicmd[0]) {
+	case READ_6:
+	case WRITE_6:
+	case MODE_SELECT:
+	case MODE_SENSE:
+		DPRINTK("read6/write6/modesel/modesense trap\n");
+		ata_bad_scsiop(cmd, done);
+		return;
+
+	default:
+		/* do nothing */
+		break;
+	}
+
+	qc = ata_qc_new_init(ap, dev, cmd, done);
+	if (!qc) {
+		printk(KERN_ERR "ata%u: command queue empty\n", ap->id);
+		return;
+	}
+
+	qc->flags |= ATA_QCFLAG_ATAPI;
+
+	qc->tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
+	if (cmd->sc_data_direction == SCSI_DATA_WRITE) {
+		qc->flags |= ATA_QCFLAG_WRITE;
+		DPRINTK("direction: write\n");
+	}
+
+	qc->tf.command = ATA_CMD_PACKET;
+
+	/* set up SG table */
+	if (cmd->sc_data_direction == SCSI_DATA_NONE) {
+		ap->active_tag = qc->tag;
+		qc->flags |= ATA_QCFLAG_ACTIVE | ATA_QCFLAG_POLL;
+		qc->tf.protocol = ATA_PROT_ATAPI;
+
+		ata_dev_select(ap, dev->devno, 1, 0);
+
+		DPRINTK("direction: none\n");
+		qc->tf.ctl |= ATA_NIEN;	/* disable interrupts */
+		ata_tf_to_host_nolock(ap, &qc->tf);
+	} else {
+		qc->flags |= ATA_QCFLAG_SG; /* data is present; dma-map it */
+		qc->tf.feature = ATAPI_PKT_DMA;
+		qc->tf.protocol = ATA_PROT_ATAPI_DMA;
+
+		doing_dma = 1;
+
+		/* select device, send command to hardware */
+		if (ata_qc_issue(qc))
+			goto err_out;
+	}
+
+	status = ata_busy_wait(ap, ATA_BUSY, 1000);
+	if (status & ATA_BUSY) {
+		ata_thread_wake(ap, THR_PACKET);
+		return;
+	}
+	if ((status & ATA_DRQ) == 0)
+		goto err_out;
+
+	/* FIXME: mmio-ize */
+	DPRINTK("writing cdb\n");
+	outsl(ap->ioaddr.cmd_addr + ATA_REG_DATA,
+	      scsicmd, ap->host->max_cmd_len / 4);
+
+	if (!doing_dma)
+		ata_thread_wake(ap, THR_PACKET);
+
+	VPRINTK("EXIT\n");
+	return;
+
+err_out:
+	if (!doing_dma)
+		ata_irq_on(ap);	/* re-enable interrupts */
+	ata_bad_cdb(cmd, done);
+	DPRINTK("EXIT - badcmd\n");
+}
+
+/**
+ *	ata_scsi_queuecmd - Issue SCSI cdb to libata-managed device
+ *	@cmd: SCSI command to be sent
+ *	@done: Completion function, called when command is complete
+ *
+ *	In some cases, this function translates SCSI commands into
+ *	ATA taskfiles, and queues the taskfiles to be sent to
+ *	hardware.  In other cases, this function simulates a
+ *	SCSI device by evaluating and responding to certain
+ *	SCSI commands.  This creates the overall effect of
+ *	ATA and ATAPI devices appearing as SCSI devices.
+ *
+ *	LOCKING:
+ *	Releases scsi-layer-held lock, and obtains host_set lock.
+ *
+ *	RETURNS:
+ *	Zero.
+ */
+
+int ata_scsi_queuecmd(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+{
+	u8 *scsicmd = cmd->cmnd;
+	struct ata_port *ap;
+	struct ata_device *dev;
+	struct ata_scsi_args args;
+	const unsigned int atapi_support =
+#ifdef CONFIG_SCSI_ATA_ATAPI
+					   1;
+#else
+					   0;
+#endif
+
+	/* Note: spin_lock_irqsave is held by caller... */
+	spin_unlock(&io_request_lock);
+
+	ap = (struct ata_port *) &cmd->host->hostdata[0];
+
+	DPRINTK("CDB (%u:%d,%d,%d) %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+		ap->id,
+		cmd->channel, cmd->target, cmd->lun,
+		scsicmd[0], scsicmd[1], scsicmd[2], scsicmd[3],
+		scsicmd[4], scsicmd[5], scsicmd[6], scsicmd[7],
+		scsicmd[8]);
+
+	/* skip commands not addressed to targets we care about */
+	if ((cmd->channel != 0) || (cmd->lun != 0) ||
+	    (cmd->target >= ATA_MAX_DEVICES)) {
+		cmd->result = (DID_BAD_TARGET << 16); /* FIXME: correct? */
+		done(cmd);
+		goto out;
+	}
+
+	spin_lock(&ap->host_set->lock);
+
+	dev = &ap->device[cmd->target];
+
+	if (!ata_dev_present(dev)) {
+		DPRINTK("no device\n");
+		cmd->result = (DID_BAD_TARGET << 16); /* FIXME: correct? */
+		done(cmd);
+		goto out_unlock;
+	}
+
+	if (dev->class == ATA_DEV_ATAPI) {
+		if (atapi_support)
+			atapi_scsi_queuecmd(ap, dev, cmd, done);
+		else {
+			cmd->result = (DID_BAD_TARGET << 16); /* correct? */
+			done(cmd);
+		}
+		goto out_unlock;
+	}
+
+	/* fast path */
+	switch(scsicmd[0]) {
+		case READ_6:
+		case WRITE_6:
+			ata_scsi_rw_queue(ap, dev, cmd, done, 6);
+			goto out_unlock;
+
+		case READ_10:
+		case WRITE_10:
+			ata_scsi_rw_queue(ap, dev, cmd, done, 10);
+			goto out_unlock;
+
+		case READ_16:
+		case WRITE_16:
+			ata_scsi_rw_queue(ap, dev, cmd, done, 16);
+			goto out_unlock;
+
+		default:
+			/* do nothing */
+			break;
+	}
+
+	/*
+	 * slow path
+	 */
+
+	args.ap = ap;
+	args.dev = dev;
+	args.cmd = cmd;
+	args.done = done;
+
+	switch(scsicmd[0]) {
+		case TEST_UNIT_READY:		/* FIXME: correct? */
+		case FORMAT_UNIT:		/* FIXME: correct? */
+		case SEND_DIAGNOSTIC:		/* FIXME: correct? */
+			ata_scsi_rbuf_fill(&args, ata_scsiop_noop);
+			break;
+
+		case INQUIRY:
+			if (scsicmd[1] & 2)	           /* is CmdDt set?  */
+				ata_bad_cdb(cmd, done);
+			else if ((scsicmd[1] & 1) == 0)    /* is EVPD clear? */
+				ata_scsi_rbuf_fill(&args, ata_scsiop_inq_std);
+			else if (scsicmd[2] == 0x00)
+				ata_scsi_rbuf_fill(&args, ata_scsiop_inq_00);
+			else if (scsicmd[2] == 0x80)
+				ata_scsi_rbuf_fill(&args, ata_scsiop_inq_80);
+			else if (scsicmd[2] == 0x83)
+				ata_scsi_rbuf_fill(&args, ata_scsiop_inq_83);
+			else
+				ata_bad_cdb(cmd, done);
+			break;
+
+		case MODE_SENSE:
+		case MODE_SENSE_10:
+			ata_scsi_rbuf_fill(&args, ata_scsiop_mode_sense);
+			break;
+
+		case MODE_SELECT:	/* unconditionally return */
+		case MODE_SELECT_10:	/* bad-field-in-cdb */
+			ata_bad_cdb(cmd, done);
+			break;
+
+		case SYNCHRONIZE_CACHE:
+			if ((dev->flags & ATA_DFLAG_WCACHE) == 0)
+				ata_bad_scsiop(cmd, done);
+			else
+				ata_scsi_rbuf_fill(&args, ata_scsiop_sync_cache);
+			break;
+
+		case READ_CAPACITY:
+			ata_scsi_rbuf_fill(&args, ata_scsiop_read_cap);
+			break;
+
+		case SERVICE_ACTION_IN:
+			if ((scsicmd[1] & 0x1f) == SAI_READ_CAPACITY_16)
+				ata_scsi_rbuf_fill(&args, ata_scsiop_read_cap);
+			else
+				ata_bad_cdb(cmd, done);
+			break;
+
+		case REPORT_LUNS:
+			ata_scsi_rbuf_fill(&args, ata_scsiop_report_luns);
+			break;
+
+		/* mandantory commands we haven't implemented yet */
+		case REQUEST_SENSE:
+
+		/* all other commands */
+		default:
+			ata_bad_scsiop(cmd, done);
+			break;
+	}
+
+out_unlock:
+	spin_unlock(&ap->host_set->lock);
+out:
+	spin_lock(&io_request_lock);
+	return 0;
+}
+
diff -urN linux-2.4.22/drivers/scsi/libata.h linux-2.4.22-ide/drivers/scsi/libata.h
--- linux-2.4.22/drivers/scsi/libata.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/drivers/scsi/libata.h	Sun Sep 21 01:50:18 2003
@@ -0,0 +1,97 @@
+/*
+   libata.h - helper library for ATA
+
+   Copyright 2003 Red Hat, Inc.  All rights reserved.
+   Copyright 2003 Jeff Garzik
+
+   The contents of this file are subject to the Open
+   Software License version 1.1 that can be found at
+   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+   by reference.
+
+   Alternatively, the contents of this file may be used under the terms
+   of the GNU General Public License version 2 (the "GPL") as distributed
+   in the kernel source COPYING file, in which case the provisions of
+   the GPL are applicable instead of the above.  If you wish to allow
+   the use of your version of this file only under the terms of the
+   GPL and not to allow others to use your version of this file under
+   the OSL, indicate your decision by deleting the provisions above and
+   replace them with the notice and other provisions required by the GPL.
+   If you do not delete the provisions above, a recipient may use your
+   version of this file under either the OSL or the GPL.
+
+ */
+
+#ifndef __LIBATA_H__
+#define __LIBATA_H__
+
+#define DRV_NAME	"libata"
+#define DRV_VERSION	"0.71"	/* must be exactly four chars */
+
+struct ata_scsi_args {
+	struct ata_port		*ap;
+	struct ata_device	*dev;
+	Scsi_Cmnd		*cmd;
+	void			(*done)(Scsi_Cmnd *);
+};
+
+
+/* libata-core.c */
+extern unsigned int ata_dev_id_string(struct ata_device *dev, unsigned char *s,
+                               unsigned int ofs, unsigned int len);
+extern void ata_eng_timeout(struct ata_port *ap);
+extern struct ata_queued_cmd *ata_qc_new_init(struct ata_port *ap,
+				      struct ata_device *dev,
+	      			      Scsi_Cmnd *cmd,
+				      void (*done)(Scsi_Cmnd *));
+extern int ata_qc_issue(struct ata_queued_cmd *qc);
+extern void ata_dev_select(struct ata_port *ap, unsigned int device,
+                           unsigned int wait, unsigned int can_sleep);
+extern void ata_tf_to_host_nolock(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_thread_wake(struct ata_port *ap, unsigned int thr_state);
+
+
+/* libata-scsi.c */
+extern void ata_to_sense_error(struct ata_queued_cmd *qc);
+extern void ata_scsi_rw_queue(struct ata_port *ap, struct ata_device *dev,
+		      Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *),
+		      unsigned int cmd_size);
+extern int ata_scsi_error(struct Scsi_Host *host);
+extern unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf,
+			       unsigned int buflen);
+
+extern unsigned int ata_scsiop_inq_00(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen);
+
+extern unsigned int ata_scsiop_inq_80(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen);
+extern unsigned int ata_scsiop_inq_83(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen);
+extern unsigned int ata_scsiop_noop(struct ata_scsi_args *args, u8 *rbuf,
+			    unsigned int buflen);
+extern unsigned int ata_scsiop_sync_cache(struct ata_scsi_args *args, u8 *rbuf,
+				  unsigned int buflen);
+extern unsigned int ata_scsiop_mode_sense(struct ata_scsi_args *args, u8 *rbuf,
+				  unsigned int buflen);
+extern unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf,
+			        unsigned int buflen);
+extern unsigned int ata_scsiop_report_luns(struct ata_scsi_args *args, u8 *rbuf,
+				   unsigned int buflen);
+extern void ata_scsi_badcmd(Scsi_Cmnd *cmd,
+			    void (*done)(Scsi_Cmnd *),
+			    u8 asc, u8 ascq);
+extern void ata_scsi_rbuf_fill(struct ata_scsi_args *args, 
+                        unsigned int (*actor) (struct ata_scsi_args *args,
+                                           u8 *rbuf, unsigned int buflen));
+
+static inline void ata_bad_scsiop(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+{
+	ata_scsi_badcmd(cmd, done, 0x20, 0x00);
+}
+
+static inline void ata_bad_cdb(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+{
+	ata_scsi_badcmd(cmd, done, 0x24, 0x00);
+}
+
+#endif /* __LIBATA_H__ */
diff -urN linux-2.4.22/drivers/scsi/sata_via.c linux-2.4.22-ide/drivers/scsi/sata_via.c
--- linux-2.4.22/drivers/scsi/sata_via.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/drivers/scsi/sata_via.c	Sun Sep 21 01:50:18 2003
@@ -0,0 +1,254 @@
+/*
+   sata_via.c - VIA Serial ATA controllers
+
+   Copyright 2003 Red Hat, Inc.  All rights reserved.
+   Copyright 2003 Jeff Garzik
+
+   The contents of this file are subject to the Open
+   Software License version 1.1 that can be found at
+   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+   by reference.
+
+   Alternatively, the contents of this file may be used under the terms
+   of the GNU General Public License version 2 (the "GPL") as distributed
+   in the kernel source COPYING file, in which case the provisions of
+   the GPL are applicable instead of the above.  If you wish to allow
+   the use of your version of this file only under the terms of the
+   GPL and not to allow others to use your version of this file under
+   the OSL, indicate your decision by deleting the provisions above and
+   replace them with the notice and other provisions required by the GPL.
+   If you do not delete the provisions above, a recipient may use your
+   version of this file under either the OSL or the GPL.
+
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include "scsi.h"
+#include "hosts.h"
+#include <linux/ata.h>
+
+#define DRV_NAME	"sata_via"
+#define DRV_VERSION	"0.10"
+
+enum {
+	via_sata		= 0,
+};
+
+static int svia_init_one (struct pci_dev *pdev, const struct pci_device_id *ent);
+static void svia_port_probe(struct ata_port *ap);
+static void svia_port_disable(struct ata_port *ap);
+static void svia_set_piomode (struct ata_port *ap, struct ata_device *adev,
+			      unsigned int pio);
+static void svia_set_udmamode (struct ata_port *ap, struct ata_device *adev,
+			       unsigned int udma);
+
+static unsigned int in_module_init = 1;
+
+static struct pci_device_id svia_pci_tbl[] = {
+	{ 0x1106, 0x3149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, via_sata },
+
+	{ }	/* terminate list */
+};
+
+struct pci_driver svia_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= svia_pci_tbl,
+	.probe			= svia_init_one,
+	.remove			= ata_pci_remove_one,
+};
+
+static Scsi_Host_Template svia_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.detect			= ata_scsi_detect,
+	.release		= ata_scsi_release,
+	.queuecommand		= ata_scsi_queuecmd,
+	.eh_strategy_handler	= ata_scsi_error,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= ATA_MAX_PRD,
+	.max_sectors		= ATA_MAX_SECTORS,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.use_new_eh_code	= ATA_SHT_NEW_EH_CODE,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME,
+};
+
+struct ata_host_info svia_sata_ops = {
+	.port_probe		= svia_port_probe,
+	.port_disable		= svia_port_disable,
+	.set_piomode		= svia_set_piomode,
+	.set_udmamode		= svia_set_udmamode,
+
+	.tf_load		= ata_tf_load_pio,
+	.tf_read		= ata_tf_read_pio,
+
+	.bmdma_start            = ata_bmdma_start_pio,
+};
+
+struct ata_board svia_board_tbl[] = {
+	/* via_sata */
+	{
+		.sht		= &svia_sht,
+		.host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY
+				  | ATA_FLAG_SRST,
+		.pio_mask	= 0x03,	/* pio3-4 */
+		.udma_mask	= 0x7f,	/* udma0-6 ; FIXME */
+		.host_info	= &svia_sata_ops,
+	},
+};
+
+MODULE_AUTHOR("Jeff Garzik");
+MODULE_DESCRIPTION("SCSI low-level driver for VIA SATA controllers");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, svia_pci_tbl);
+
+/**
+ *	svia_port_probe -
+ *	@ap:
+ *
+ *	LOCKING:
+ *
+ */
+
+static void svia_port_probe(struct ata_port *ap)
+{
+	/* FIXME */
+
+	ata_port_probe(ap);
+}
+
+/**
+ *	svia_port_disable - 
+ *	@ap:
+ *
+ *	LOCKING:
+ *
+ */
+
+static void svia_port_disable(struct ata_port *ap)
+{
+	ata_port_disable(ap);
+
+	/* FIXME */
+}
+
+/**
+ *	svia_set_piomode - 
+ *	@ap:
+ *	@adev:
+ *	@pio:
+ *
+ *	LOCKING:
+ *
+ */
+
+static void svia_set_piomode (struct ata_port *ap, struct ata_device *adev,
+			      unsigned int pio)
+{
+	/* FIXME: needed? */
+}
+
+/**
+ *	svia_set_udmamode - 
+ *	@ap:
+ *	@adev:
+ *	@udma:
+ *
+ *	LOCKING:
+ *
+ */
+
+static void svia_set_udmamode (struct ata_port *ap, struct ata_device *adev,
+			      unsigned int udma)
+{
+	/* FIXME: needed? */
+}
+
+/**
+ *	svia_init_one - 
+ *	@pdev:
+ *	@ent:
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static int svia_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	static int printed_version;
+	struct ata_board *boards[1];
+	unsigned int n_boards = 1;
+
+	if (!printed_version++)
+		printk(KERN_DEBUG DRV_NAME " version " DRV_VERSION "\n");
+
+	/* no hotplugging support (FIXME) */
+	if (!in_module_init)
+		return -ENODEV;
+
+	boards[0] = &svia_board_tbl[ent->driver_data];
+
+	return ata_pci_init_one(pdev, boards, n_boards);
+}
+
+/**
+ *	svia_init - 
+ *
+ *	LOCKING:
+ *
+ *	RETURNS:
+ *
+ */
+
+static int __init svia_init(void)
+{
+	int rc;
+
+	DPRINTK("pci_module_init\n");
+	rc = pci_module_init(&svia_pci_driver);
+	if (rc)
+		return rc;
+
+	in_module_init = 0;
+
+	DPRINTK("scsi_register_host\n");
+	rc = scsi_register_module(MODULE_SCSI_HA, &svia_sht);
+	if (rc) {
+		rc = -ENODEV;
+		goto err_out;
+	}
+
+	DPRINTK("done\n");
+	return 0;
+
+err_out:
+	pci_unregister_driver(&svia_pci_driver);
+	return rc;
+}
+
+/**
+ *	svia_exit - 
+ *
+ *	LOCKING:
+ *
+ */
+
+static void __exit svia_exit(void)
+{
+	scsi_unregister_module(MODULE_SCSI_HA, &svia_sht);
+	pci_unregister_driver(&svia_pci_driver);
+}
+
+module_init(svia_init);
+module_exit(svia_exit);
+
diff -urN linux-2.4.22/include/linux/ata.h linux-2.4.22-ide/include/linux/ata.h
--- linux-2.4.22/include/linux/ata.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.22-ide/include/linux/ata.h	Sun Sep 21 01:50:19 2003
@@ -0,0 +1,649 @@
+/*
+   Copyright 2003 Red Hat, Inc.  All rights reserved.
+   Copyright 2003 Jeff Garzik
+
+   The contents of this file are subject to the Open
+   Software License version 1.1 that can be found at
+   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+   by reference.
+
+   Alternatively, the contents of this file may be used under the terms
+   of the GNU General Public License version 2 (the "GPL") as distributed
+   in the kernel source COPYING file, in which case the provisions of
+   the GPL are applicable instead of the above.  If you wish to allow
+   the use of your version of this file only under the terms of the
+   GPL and not to allow others to use your version of this file under
+   the OSL, indicate your decision by deleting the provisions above and
+   replace them with the notice and other provisions required by the GPL.
+   If you do not delete the provisions above, a recipient may use your
+   version of this file under either the OSL or the GPL.
+
+ */
+
+#ifndef __LINUX_ATA_H__
+#define __LINUX_ATA_H__
+
+#include <linux/delay.h>
+#include <asm/io.h>
+
+/*
+ * compile-time options
+ */
+#undef ATA_FORCE_PIO		/* do not configure or use DMA */
+#undef ATA_DEBUG		/* debugging output */
+#undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
+#undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
+#undef ATA_NDEBUG		/* define to disable quick runtime checks */
+
+
+/* note: prints function name for you */
+#ifdef ATA_DEBUG
+#define DPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+#ifdef ATA_VERBOSE_DEBUG
+#define VPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+#else
+#define VPRINTK(fmt, args...)
+#endif	/* ATA_VERBOSE_DEBUG */
+#else
+#define DPRINTK(fmt, args...)
+#define VPRINTK(fmt, args...)
+#endif	/* ATA_DEBUG */
+
+#ifdef ATA_NDEBUG
+#define assert(expr)
+#else
+#define assert(expr) \
+        if(unlikely(!(expr))) {                                   \
+        printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d\n", \
+        #expr,__FILE__,__FUNCTION__,__LINE__);          \
+        }
+#endif
+
+/* defines only for the constants which don't work well as enums */
+#define ATA_TAG_POISON		0xfafbfcfdU
+#define ATA_DMA_BOUNDARY	0xffffUL
+#define ATA_DMA_MASK		0xffffffffULL
+
+enum {
+	/* various global constants */
+	ATA_MAX_PORTS		= 2,
+	ATA_MAX_DEVICES		= 2,	/* per bus/port */
+	ATA_DEF_QUEUE		= 1,
+	ATA_MAX_QUEUE		= 1,
+	ATA_MAX_PRD		= 256,	/* we could make these 256/256 */
+	ATA_MAX_SECTORS		= 200,	/* FIXME */
+	ATA_MAX_BUS		= 2,
+	ATA_SECT_SIZE		= 512,
+	ATA_SECT_SIZE_MASK	= (ATA_SECT_SIZE - 1),
+	ATA_SECT_DWORDS		= ATA_SECT_SIZE / sizeof(u32),
+	ATA_ID_WORDS		= 256,
+	ATA_ID_PROD_OFS		= 27,
+	ATA_ID_SERNO_OFS	= 10,
+	ATA_ID_MAJOR_VER	= 80,
+	ATA_ID_PIO_MODES	= 64,
+	ATA_ID_UDMA_MODES	= 88,
+	ATA_ID_PIO4		= (1 << 1),
+	ATA_DEF_BUSY_WAIT	= 10000,
+	ATA_PCI_CTL_OFS		= 2,
+	ATA_SHORT_PAUSE		= (HZ >> 6) + 1,
+	ATA_SERNO_LEN		= 20,
+	ATA_UDMA_MASK_40C	= 0x07,	/* udma0-2 */
+
+	ATA_SHT_EMULATED	= 1,
+	ATA_SHT_NEW_EH_CODE	= 1,
+	ATA_SHT_CMD_PER_LUN	= 1,
+	ATA_SHT_THIS_ID		= -1,
+	ATA_SHT_USE_CLUSTERING	= 0,	/* FIXME: which is best, 0 or 1?  */
+
+	/* DMA-related */
+	ATA_PRD_SZ		= 8,
+	ATA_PRD_TBL_SZ		= (ATA_MAX_PRD * ATA_PRD_SZ),
+	ATA_PRD_EOT		= (1 << 31),	/* end-of-table flag */
+
+	ATA_DMA_TABLE_OFS	= 4,
+	ATA_DMA_STATUS		= 2,
+	ATA_DMA_CMD		= 0,
+	ATA_DMA_WR		= (1 << 3),
+	ATA_DMA_START		= (1 << 0),
+	ATA_DMA_INTR		= (1 << 2),
+	ATA_DMA_ERR		= (1 << 1),
+	ATA_DMA_ACTIVE		= (1 << 0),
+
+	/* bits in ATA command block registers */
+	ATA_HOB			= (1 << 7),	/* LBA48 selector */
+	ATA_NIEN		= (1 << 1),	/* disable-irq flag */
+	ATA_LBA			= (1 << 6),	/* LBA28 selector */
+	ATA_DEV1		= (1 << 4),	/* Select Device 1 (slave) */
+	ATA_BUSY		= (1 << 7),	/* BSY status bit */
+	ATA_DEVICE_OBS		= (1 << 7) | (1 << 5), /* obs bits in dev reg */
+	ATA_DEVCTL_OBS		= (1 << 3),	/* obsolete bit in devctl reg */
+	ATA_DRQ			= (1 << 3),	/* data request i/o */
+	ATA_ERR			= (1 << 0),	/* have an error */
+	ATA_SRST		= (1 << 2),	/* software reset */
+	ATA_ABORTED		= (1 << 2),	/* command aborted */
+
+	/* ATA command block registers */
+	ATA_REG_DATA		= 0x00,
+	ATA_REG_ERR		= 0x01,
+	ATA_REG_NSECT		= 0x02,
+	ATA_REG_LBAL		= 0x03,
+	ATA_REG_LBAM		= 0x04,
+	ATA_REG_LBAH		= 0x05,
+	ATA_REG_DEVICE		= 0x06,
+	ATA_REG_STATUS		= 0x07,
+
+	ATA_REG_FEATURE		= ATA_REG_ERR, /* and their aliases */
+	ATA_REG_CMD		= ATA_REG_STATUS,
+	ATA_REG_BYTEL		= ATA_REG_LBAM,
+	ATA_REG_BYTEH		= ATA_REG_LBAH,
+	ATA_REG_DEVSEL		= ATA_REG_DEVICE,
+	ATA_REG_IRQ		= ATA_REG_NSECT,
+
+	/* struct ata_device stuff */
+	ATA_DFLAG_LBA48		= (1 << 0), /* device supports LBA48 */
+	ATA_DFLAG_PIO		= (1 << 1), /* device currently in PIO mode */
+	ATA_DFLAG_MASTER	= (1 << 2), /* is device 0? */
+	ATA_DFLAG_WCACHE	= (1 << 3), /* has write cache we can
+					     * (hopefully) flush? */
+
+	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
+	ATA_DEV_ATA		= 1,	/* ATA device */
+	ATA_DEV_ATA_UNSUP	= 2,	/* ATA device (unsupported) */
+	ATA_DEV_ATAPI		= 3,	/* ATAPI device */
+	ATA_DEV_ATAPI_UNSUP	= 4,	/* ATAPI device (unsupported) */
+	ATA_DEV_NONE		= 5,	/* no device */
+
+	/* struct ata_port flags */
+	ATA_FLAG_SLAVE_POSS	= (1 << 1), /* host supports slave dev */
+					    /* (doesn't imply presence) */
+	ATA_FLAG_PORT_DISABLED	= (1 << 2), /* port is disabled, ignore it */
+	ATA_FLAG_SATA		= (1 << 3),
+	ATA_FLAG_NO_LEGACY	= (1 << 4), /* no legacy mode check */
+	ATA_FLAG_SRST		= (1 << 5), /* use ATA SRST, not E.D.D. */
+	ATA_FLAG_MMIO		= (1 << 6), /* use MMIO, not PIO */
+
+	/* struct ata_taskfile flags */
+	ATA_TFLAG_LBA48		= (1 << 0),
+	ATA_TFLAG_ISADDR	= (1 << 1), /* enable r/w to nsect/lba regs */
+	ATA_TFLAG_DEVICE	= (1 << 2), /* enable r/w to device reg */
+
+	ATA_QCFLAG_WRITE	= (1 << 0), /* read==0, write==1 */
+	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
+	ATA_QCFLAG_DMA		= (1 << 2), /* data delivered via DMA */
+	ATA_QCFLAG_ATAPI	= (1 << 3), /* is ATAPI packet command? */
+	ATA_QCFLAG_SG		= (1 << 4), /* have s/g table? */
+	ATA_QCFLAG_POLL		= (1 << 5), /* polling, no interrupts */
+
+	/* struct ata_engine atomic flags (use test_bit, etc.) */
+	ATA_EFLG_ACTIVE		= 0,	/* engine is active */
+
+	/* ATA taskfile protocols */
+	ATA_PROT_UNKNOWN	= 0,
+	ATA_PROT_NODATA		= 1,
+	ATA_PROT_PIO_READ	= 2,
+	ATA_PROT_PIO_WRITE	= 3,
+	ATA_PROT_DMA_READ	= 4,
+	ATA_PROT_DMA_WRITE	= 5,
+	ATA_PROT_ATAPI		= 6,
+	ATA_PROT_ATAPI_DMA	= 7,
+
+	/* ATA device commands */
+	ATA_CMD_EDD		= 0x90,	/* execute device diagnostic */
+	ATA_CMD_ID_ATA		= 0xEC,
+	ATA_CMD_ID_ATAPI	= 0xA1,
+	ATA_CMD_READ		= 0xC8,
+	ATA_CMD_READ_EXT	= 0x25,
+	ATA_CMD_WRITE		= 0xCA,
+	ATA_CMD_WRITE_EXT	= 0x35,
+	ATA_CMD_PIO_READ	= 0x20,
+	ATA_CMD_PIO_READ_EXT	= 0x24,
+	ATA_CMD_PIO_WRITE	= 0x30,
+	ATA_CMD_PIO_WRITE_EXT	= 0x34,
+	ATA_CMD_SET_FEATURES	= 0xEF,
+	ATA_CMD_PACKET		= 0xA0,
+
+	/* various lengths of time */
+	ATA_TMOUT_EDD		= 5 * HZ,	/* hueristic */
+	ATA_TMOUT_PIO		= 30 * HZ,
+	ATA_TMOUT_BOOT		= 30 * HZ,	/* hueristic */
+	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* hueristic */
+	ATA_TMOUT_CDB		= 30 * HZ,
+	ATA_TMOUT_CDB_QUICK	= 5 * HZ,
+
+	/* ATA bus states */
+	BUS_UNKNOWN		= 0,
+	BUS_DMA			= 1,
+	BUS_IDLE		= 2,
+	BUS_NOINTR		= 3,
+	BUS_NODATA		= 4,
+	BUS_TIMER		= 5,
+	BUS_PIO			= 6,
+	BUS_EDD			= 7,
+	BUS_IDENTIFY		= 8,
+	BUS_PACKET		= 9,
+
+	/* thread states */
+	THR_UNKNOWN		= 0,
+	THR_CHECKPORT		= 1,
+	THR_BUS_RESET		= 2,
+	THR_AWAIT_DEATH		= 3,
+	THR_IDENTIFY		= 4,
+	THR_CONFIG_TIMINGS	= 5,
+	THR_CONFIG_DMA		= 6,
+	THR_PROBE_FAILED	= 7,
+	THR_IDLE		= 8,
+	THR_PROBE_SUCCESS	= 9,
+	THR_PROBE_START		= 10,
+	THR_CONFIG_FORCE_PIO	= 11,
+	THR_PIO_POLL		= 12,
+	THR_PIO_TMOUT		= 13,
+	THR_PIO			= 14,
+	THR_PIO_LAST		= 15,
+	THR_PIO_LAST_POLL	= 16,
+	THR_PIO_ERR		= 17,
+	THR_PACKET		= 18,
+
+	/* SATA port states */
+	PORT_UNKNOWN		= 0,
+	PORT_ENABLED		= 1,
+	PORT_DISABLED		= 2,
+
+	/* SETFEATURES stuff */
+	SETFEATURES_XFER	= 0x03,
+	XFER_UDMA_7		= 0x47,
+	XFER_UDMA_6		= 0x46,
+	XFER_UDMA_5		= 0x45,
+	XFER_UDMA_4		= 0x44,
+	XFER_UDMA_3		= 0x43,
+	XFER_UDMA_2		= 0x42,
+	XFER_UDMA_1		= 0x41,
+	XFER_UDMA_0		= 0x40,
+	XFER_PIO_4		= 0x0C,
+	XFER_PIO_3		= 0x0B,
+
+	/* ATAPI stuff */
+	ATAPI_PKT_DMA		= (1 << 0),
+
+	/* cable types */
+	ATA_CBL_NONE		= 0,
+	ATA_CBL_PATA40		= 1,
+	ATA_CBL_PATA80		= 2,
+	ATA_CBL_PATA_UNK	= 3,
+	ATA_CBL_SATA		= 4,
+
+	/* ata_qc_cb_t flags - note uses above ATA_QCFLAG_xxx namespace,
+	 * but not numberspace
+	 */
+	ATA_QCFLAG_TIMEOUT	= (1 << 0),
+};
+
+/* forward declarations */
+struct ata_host_info;
+struct ata_port;
+struct ata_queued_cmd;
+
+/* typedefs */
+typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc, unsigned int flags);
+
+/* core structures */
+struct ata_prd {
+	u32			addr;
+	u32			flags_len;
+} __attribute__((packed));
+
+struct ata_ioports {
+	unsigned long		cmd_addr;
+	unsigned long		ctl_addr;
+	unsigned long		bmdma_addr;
+};
+
+struct ata_probe_ent {
+	struct list_head	node;
+	struct pci_dev		*pdev;
+	struct ata_host_info	*host_info;
+	Scsi_Host_Template	*sht;
+	struct ata_ioports	port[ATA_MAX_PORTS];
+	unsigned int		n_ports;
+	unsigned int		pio_mask;
+	unsigned int		udma_mask;
+	unsigned int		legacy_mode;
+	unsigned long		irq;
+	unsigned int		irq_flags;
+	unsigned long		host_flags;
+};
+
+struct ata_host_set {
+	spinlock_t		lock;
+	struct pci_dev		*pdev;
+	unsigned long		irq;
+	unsigned int		n_hosts;
+	struct ata_port *	hosts[0];
+};
+
+struct ata_taskfile {
+	unsigned long		flags;		/* ATA_TFLAG_xxx */
+	u8			protocol;	/* ATA_PROT_xxx */
+
+	u8			ctl;		/* control reg */
+
+	u8			hob_feature;	/* additional data */
+	u8			hob_nsect;	/* to support LBA48 */
+	u8			hob_lbal;
+	u8			hob_lbam;
+	u8			hob_lbah;
+
+	u8			feature;
+	u8			nsect;
+	u8			lbal;
+	u8			lbam;
+	u8			lbah;
+
+	u8			device;
+
+	u8			command;	/* IO operation */
+};
+
+struct ata_queued_cmd {
+	struct ata_port		*ap;
+	struct ata_device	*dev;
+
+	Scsi_Cmnd		*scsicmd;
+	void			(*scsidone)(Scsi_Cmnd *);
+
+	struct list_head	node;
+	unsigned long		flags;		/* ATA_QCFLAG_xxx */
+	unsigned int		tag;
+	unsigned int		n_elem;
+	unsigned int		nsect;
+	unsigned int		cursect;
+	unsigned int		cursg;
+	unsigned int		cursg_ofs;
+	struct ata_taskfile	tf;
+	struct scatterlist	sgent;
+	ata_qc_cb_t		callback;
+
+	struct semaphore	sem;
+};
+
+struct ata_host_stats {
+	unsigned long		unhandled_irq;
+	unsigned long		idle_irq;
+	unsigned long		rw_reqbuf;
+};
+
+struct ata_device {
+	u64			n_sectors;	/* size of device, if ATA */
+	unsigned long		flags;		/* ATA_DFLAG_xxx */
+	unsigned int		class;		/* ATA_DEV_xxx */
+	unsigned int		devno;		/* 0 or 1 */
+	u16			id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
+	unsigned int		pio_mode;
+	unsigned int		udma_mode;
+
+	unsigned char		vendor[8];	/* space-padded, not ASCIIZ */
+	unsigned char		product[16];
+};
+
+struct ata_engine {
+	unsigned long		flags;
+	struct list_head	q;
+};
+
+struct ata_port {
+	struct Scsi_Host	*host;	/* our co-allocated scsi host */
+	struct ata_host_info	*ops;
+	unsigned long		flags;	/* ATA_FLAG_xxx */
+	unsigned int		id;	/* unique id req'd by scsi midlyr */
+	unsigned int		port_no; /* unique port #; from zero */
+
+	struct ata_prd		*prd;	 /* our SG list */
+	dma_addr_t		prd_dma; /* and its DMA mapping */
+
+	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
+
+	u8			ctl;	/* cache of ATA control register */
+	u8			devsel;	/* cache of Device Select reg */
+	unsigned int		bus_state;
+	unsigned int		port_state;
+	unsigned int		pio_mask;
+	unsigned int		udma_mask;
+	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
+
+	struct ata_engine	eng;
+
+	struct ata_device	device[ATA_MAX_DEVICES];
+
+	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
+	unsigned long		qactive;
+	unsigned int		active_tag;
+
+	struct ata_host_stats	stats;
+	struct ata_host_set	*host_set;
+
+	struct semaphore	sem;
+	struct semaphore	probe_sem;
+
+	unsigned int		thr_state;
+	int			time_to_die;
+	pid_t			thr_pid;
+	struct completion	thr_exited;
+	struct semaphore	thr_sem;
+	struct timer_list	thr_timer;
+	unsigned long		thr_timeout;
+};
+
+struct ata_host_info {
+	void (*port_probe) (struct ata_port *);
+	void (*port_disable) (struct ata_port *);
+
+	void (*set_piomode) (struct ata_port *, struct ata_device *,
+			     unsigned int);
+	void (*set_udmamode) (struct ata_port *, struct ata_device *,
+			     unsigned int);
+
+	void (*tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
+	void (*tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
+
+	void (*phy_probe) (struct ata_port *ap);
+
+	void (*bmdma_start) (struct ata_queued_cmd *qc);
+};
+
+struct ata_board {
+	Scsi_Host_Template	*sht;
+	unsigned long		host_flags;
+	unsigned long		pio_mask;
+	unsigned long		udma_mask;
+	struct ata_host_info	*host_info;
+};
+
+struct pci_bits {
+	unsigned long		mask;
+	unsigned long		val;
+	unsigned int		reg;	/* PCI config register to read */
+	unsigned int		width;	/* 1 (8 bit), 2 (16 bit), 4 (32 bit) */
+};
+
+#define ata_id_is_ata(dev)	(((dev)->id[0] & (1 << 15)) == 0)
+#define ata_id_has_lba48(dev)	((dev)->id[83] & (1 << 10))
+#define ata_id_has_lba(dev)	((dev)->id[49] & (1 << 8))
+#define ata_id_has_dma(dev)	((dev)->id[49] & (1 << 9))
+#define ata_id_u32(dev,n)	\
+	(((u32) (dev)->id[(n) + 1] << 16) | ((u32) (dev)->id[(n)]))
+#define ata_id_u64(dev,n)	\
+	( ((u64) dev->id[(n) + 3] << 48) |	\
+	  ((u64) dev->id[(n) + 2] << 32) |	\
+	  ((u64) dev->id[(n) + 1] << 16) |	\
+	  ((u64) dev->id[(n) + 0]) )
+
+extern void ata_port_probe(struct ata_port *);
+extern void ata_port_disable(struct ata_port *);
+extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_board **boards,
+			     unsigned int n_boards);
+extern void ata_pci_remove_one (struct pci_dev *pdev);
+extern int ata_scsi_detect(Scsi_Host_Template *sht);
+extern int ata_scsi_release(struct Scsi_Host *host);
+extern int ata_scsi_queuecmd(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *));
+extern int ata_scsi_error(struct Scsi_Host *host);
+extern void ata_tf_load_pio(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_tf_load_mmio(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_tf_read_pio(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_tf_read_mmio(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_bmdma_start_mmio (struct ata_queued_cmd *qc);
+extern void ata_bmdma_start_pio (struct ata_queued_cmd *qc);
+extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);
+
+static inline unsigned long msecs_to_jiffies(unsigned long msecs)
+{
+	return ((HZ * msecs + 999) / 1000);
+}
+
+static inline unsigned int ata_tag_valid(unsigned int tag)
+{
+	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
+}
+
+static inline unsigned int ata_dev_present(struct ata_device *dev)
+{
+	return ((dev->class == ATA_DEV_ATA) ||
+		(dev->class == ATA_DEV_ATAPI));
+}
+
+static inline u8 ata_chk_err(struct ata_port *ap)
+{
+	if (ap->flags & ATA_FLAG_MMIO) {
+		void *mmio = (void *) ap->ioaddr.cmd_addr;
+		return readb(mmio + ATA_REG_ERR);
+	}
+	return inb(ap->ioaddr.cmd_addr + ATA_REG_ERR);
+}
+
+static inline u8 ata_chk_status(struct ata_port *ap)
+{
+	if (ap->flags & ATA_FLAG_MMIO) {
+		void *mmio = (void *) ap->ioaddr.cmd_addr;
+		return readb(mmio + ATA_REG_STATUS);
+	}
+	return inb(ap->ioaddr.cmd_addr + ATA_REG_STATUS);
+}
+
+static inline u8 ata_altstatus(struct ata_port *ap)
+{
+	if (ap->flags & ATA_FLAG_MMIO)
+		return readb(ap->ioaddr.ctl_addr);
+	return inb(ap->ioaddr.ctl_addr);
+}
+
+static inline void ata_pause(struct ata_port *ap)
+{
+	ata_altstatus(ap);
+	ndelay(400);
+}
+
+static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
+			       unsigned int max)
+{
+	u8 status;
+
+	do {
+		udelay(10);
+		status = ata_chk_status(ap);
+		max--;
+	} while ((status & bits) && (max > 0));
+
+	return status;
+}
+
+static inline u8 ata_wait_idle(struct ata_port *ap)
+{
+	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
+
+	if (status & (ATA_BUSY | ATA_DRQ)) {
+		unsigned long l = ap->ioaddr.cmd_addr + ATA_REG_STATUS;
+		printk(KERN_WARNING
+		       "ATA: abnormal status 0x%X on port 0x%lX\n",
+		       status, l);
+	}
+
+	return status;
+}
+
+static inline struct ata_queued_cmd *ata_qc_from_tag (struct ata_port *ap,
+						      unsigned int tag)
+{
+	if (likely(ata_tag_valid(tag)))
+		return &ap->qcmd[tag];
+	return NULL;
+}
+
+static inline void ata_tf_init(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	memset(tf, 0, sizeof(*tf));
+
+	tf->ctl = ap->ctl;
+	tf->device = ap->devsel;
+}
+
+static inline u8 ata_irq_on(struct ata_port *ap)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+
+	ap->ctl &= ~ATA_NIEN;
+
+	if (ap->flags & ATA_FLAG_MMIO)
+		writeb(ap->ctl, ioaddr->ctl_addr);
+	else
+		outb(ap->ctl, ioaddr->ctl_addr);
+
+	return ata_wait_idle(ap);
+}
+
+static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
+{
+	unsigned int bits = chk_drq ? ATA_BUSY | ATA_DRQ : ATA_BUSY;
+	u8 host_stat, post_stat, status;
+
+	status = ata_busy_wait(ap, bits, 1000);
+	if (status & bits)
+		DPRINTK("abnormal status 0x%X\n", status);
+
+	/* get controller status; clear intr, err bits */
+	if (ap->flags & ATA_FLAG_MMIO) {
+		void *mmio = (void *) ap->ioaddr.bmdma_addr;
+		host_stat = readb(mmio + ATA_DMA_STATUS);
+		writeb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+		       mmio + ATA_DMA_STATUS);
+
+		post_stat = readb(mmio + ATA_DMA_STATUS);
+	} else {
+		host_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+		outb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+		     ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+
+		post_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	}
+
+	VPRINTK("irq ack: host_stat 0x%X, new host_stat 0x%X, drv_stat 0x%X\n",
+		host_stat, post_stat, status);
+
+	return status;
+}
+
+/*
+ * 2.5 compat.
+ */
+
+typedef void irqreturn_t;
+#define IRQ_RETVAL(x)	/* nothing */
+
+#define REPORT_LUNS		0xa0
+#define READ_16			0x88
+#define WRITE_16		0x8a
+#define SERVICE_ACTION_IN	0x9e
+/* values for service action in */
+#define SAI_READ_CAPACITY_16	0x10
+
+#define SAM_STAT_GOOD		0x00
+#define SAM_STAT_CHECK_CONDITION 0x02
+
+#endif /* __LINUX_ATA_H__ */
diff -urN linux-2.4.22/include/linux/ide.h linux-2.4.22-ide/include/linux/ide.h
--- linux-2.4.22/include/linux/ide.h	Mon Aug 25 13:44:44 2003
+++ linux-2.4.22-ide/include/linux/ide.h	Sun Sep 21 01:50:19 2003
@@ -268,7 +268,7 @@
  * Timeouts for various operations:
  */
 #define WAIT_DRQ	(5*HZ/100)	/* 50msec - spec allows up to 20ms */
-#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
+#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE) || defined(CONFIG_ACPI)
 #define WAIT_READY	(5*HZ)		/* 5sec - some laptops are very slow */
 #else
 #define WAIT_READY	(3*HZ/100)	/* 30msec - should be instantaneous */
@@ -1003,6 +1003,8 @@
 	unsigned	udma_four  : 1;	/* 1=ATA-66 capable, 0=default */
 	unsigned	highmem    : 1;	/* can do full 32-bit dma */
 	unsigned	no_dsc     : 1;	/* 0 default, 1 dsc_overlap disabled */
+	unsigned	sata	   : 1; /* 0 PATA, 1 SATA */
+	unsigned	lba48_pio  : 1;	/* 1 LBA48 PIO only */
 
 	void		*hwif_data;	/* extra hwif data */
 } ide_hwif_t;
@@ -1331,9 +1333,10 @@
 extern int ide_xlate_1024(kdev_t, int, int, const char *);
 
 /*
- * Convert kdev_t structure into ide_drive_t * one.
+ * Convert kdev_t structure into ide_drive_t * one. If force is set the
+ * non present drives can be opened.
  */
-extern ide_drive_t *get_info_ptr(kdev_t i_rdev);
+extern ide_drive_t *ide_info_ptr(kdev_t i_rdev, int force);
 
 /*
  * Return the current idea about the total capacity of this drive.
@@ -1349,12 +1352,6 @@
 extern ide_startstop_t ide_do_reset(ide_drive_t *);
 
 /*
- * Re-Start an operation for an IDE interface.
- * The caller should return immediately after invoking this.
- */
-extern int restart_request(ide_drive_t *, struct request *);
-
-/*
  * This function is intended to be used prior to invoking ide_do_drive_cmd().
  */
 extern void ide_init_drive_cmd(struct request *);
@@ -1721,6 +1718,12 @@
 #endif
 
 extern void hwif_unregister(ide_hwif_t *);
+
+extern void ide_probe_reset(ide_hwif_t *);
+extern void ide_tune_drives(ide_hwif_t *);
+extern int ide_wait_hwif_ready(ide_hwif_t *);
+extern u8 ide_probe_for_drive(ide_drive_t *);
+
 
 extern void export_ide_init_queue(ide_drive_t *);
 extern u8 export_probe_for_drive(ide_drive_t *);
diff -urN linux-2.4.22/include/linux/pci_ids.h linux-2.4.22-ide/include/linux/pci_ids.h
--- linux-2.4.22/include/linux/pci_ids.h	Sun Sep 21 01:48:20 2003
+++ linux-2.4.22-ide/include/linux/pci_ids.h	Sun Sep 21 01:50:19 2003
@@ -841,6 +841,7 @@
 
 #define PCI_VENDOR_ID_SGI		0x10a9
 #define PCI_DEVICE_ID_SGI_IOC3		0x0003
+#define PCI_DEVICE_ID_SGI_IOC4		0x100a
 
 #define PCI_VENDOR_ID_ACC		0x10aa
 #define PCI_DEVICE_ID_ACC_2056		0x0000
@@ -965,7 +965,13 @@
 #define PCI_DEVICE_ID_NVIDIA_VTNT2		0x002C
 #define PCI_DEVICE_ID_NVIDIA_UVTNT2		0x002D
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2_IDE	0x0065
+#define PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE	0x0085
+#define PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA	0x008e
 #define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE	0x00d5
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA	0x00e3
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE	0x00e5
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA2	0x00ee
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE_SDR	0x0100
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR	0x0101
 #define PCI_DEVICE_ID_NVIDIA_QUADRO		0x0103
@@ -1082,6 +1083,7 @@
 #define PCI_DEVICE_ID_VIA_8233C_0	0x3109
 #define PCI_DEVICE_ID_VIA_8361		0x3112
 #define PCI_DEVICE_ID_VIA_8375		0x3116
+#define PCI_DEVICE_ID_VIA_CLE266	0x3123
 #define PCI_DEVICE_ID_VIA_8233A		0x3147
 #define PCI_DEVICE_ID_VIA_P4M266	0x3148
 #define PCI_DEVICE_ID_VIA_8237_SATA	0x3149
