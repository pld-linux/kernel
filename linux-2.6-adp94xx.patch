diff -uNr linux-2.6.16.old/drivers/scsi/Kconfig linux-2.6.16/drivers/scsi/Kconfig
--- linux-2.6.16.old/drivers/scsi/Kconfig	2010-03-14 22:19:41.097357377 +0000
+++ linux-2.6.16/drivers/scsi/Kconfig	2010-03-14 22:20:03.548872170 +0000
@@ -381,6 +381,7 @@
 	depends on SCSI && PCI
 
 source "drivers/scsi/aic7xxx/Kconfig.aic7xxx"
+source "drivers/scsi/adp94xx/Kconfig"
 
 config SCSI_AIC7XXX_OLD
 	tristate "Adaptec AIC7xxx support (old driver)"
diff -uNr linux-2.6.16.old/drivers/scsi/Makefile linux-2.6.16/drivers/scsi/Makefile
--- linux-2.6.16.old/drivers/scsi/Makefile	2010-03-14 22:07:50.800694000 +0000
+++ linux-2.6.16/drivers/scsi/Makefile	2010-03-14 22:13:22.225541458 +0000
@@ -66,6 +66,7 @@
 obj-$(CONFIG_SCSI_AIC7XXX)	+= aic7xxx/
 obj-$(CONFIG_SCSI_AIC79XX)	+= aic7xxx/
 obj-$(CONFIG_SCSI_AACRAID)	+= aacraid/
+obj-$(CONFIG_SCSI_ADP94XX)	+= adp94xx/
 obj-$(CONFIG_SCSI_AIC7XXX_OLD)	+= aic7xxx_old.o
 obj-$(CONFIG_SCSI_IPS)		+= ips.o
 obj-$(CONFIG_SCSI_FD_MCS)	+= fd_mcs.o
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/How_To_Compile_SCSI_Drivers.txt linux-2.6.16/drivers/scsi/adp94xx/How_To_Compile_SCSI_Drivers.txt
--- linux-2.6.16.old/drivers/scsi/adp94xx/How_To_Compile_SCSI_Drivers.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/How_To_Compile_SCSI_Drivers.txt	2007-04-05 23:35:00.000000000 +0000
@@ -0,0 +1,110 @@
+How To Compile SCSI Drivers
+===========================
+$Id$
+
+Assumptions
+-----------
+
+Kernel tree root is at /usr/src/linux and the current
+working directory is the kernel tree root, "cwd" or . for
+short.
+
+You should probably read the /usr/src/linux/README file.
+
+
+The kernel has to be configured
+-------------------------------
+
+Make sure that your kernel is configured.  If you do not
+have .config file in your kernel root, then your kernel is
+not configured.  If you have that file but you're unsure if
+your kernel is configured, then run "make oldconfig".
+
+You need a configuration file in order to configure the
+kernel.  You get one by manually configuring the kernel
+("make menuconfig") or by copying a provided one from your
+vendor/distributor or by getting the one currently used by
+your running kenrel.
+
+The latter two choices work as follows: copy the config file
+of your desire from configs/ directory to . and rename it
+".config".  Then run "make oldconfig".  Or you can copy
+/proc/config.gz (if present, not all kernels support this)
+to . and then unzip it using gunzip(1) and then rename it to
+".config".  Then run "make oldconfig".
+
+2.4.x
+-----
+
+Make the driver directory present in the kernel tree:
+
+cd drivers/scsi/
+mkdir adp94xx
+lndir <driver source directory> adp94xx
+
+Alternatively you can just copy the whole directory
+("cp -a") into "drivers/scsi/", just as long as it is called
+"adp94xx".  Or you can create a symlink to the actual
+directory from drivers/scsi/ as long as the pointing symlink
+is called "adp94xx".
+
+Edit the "Makefile" to include the fact that we're building
+that driver.  In the beginning after a bunch of lines
+starting with "subdir-$(..." add this line:
+
+subdir-$(CONFIG_SCSI_ADP94XX)   += adp94xx
+
+Further down after the "ifeq" statement regarding
+"aic7xxx/aic79xxx" add this statement:
+
+ifeq ($(CONFIG_SCSI_ADP94XX),y)
+  obj-$(CONFIG_SCSI_ADP94XX)    += adp94xx/adp94xx.o
+endif
+
+Edit the "Config.in" file to include this line:
+
+source drivers/scsi/adp94xx/Config.in
+
+after "source drivers/scsi/aic7xxx/Config.in" line.
+
+Then,
+
+cd ../../
+make oldconfig
+
+You will be asked only one question regarding the "new"
+driver which has just been added, which whould be the
+"adp94xx" driver.  Answer 'm' for module.  If you answer
+'n', stop reading here.  If you answer 'y', the driver will
+be built into the kernel.
+
+Then you're ready to build it.
+
+make SUBDIRS=drivers/scsi/adp94xx modules
+
+The driver will be "drivers/scsi/adp94xx/adp94xx.o".
+
+To insert it into the kernel, do, as root:
+
+insmod drivers/scsi/adp94xx/adp94xx.o
+
+You may want to give options.  See the readme.txt file in
+this directory.
+
+
+2.6.x
+-----
+
+cd <driver source directory>
+mv Makefile Makefile.2_4
+mv Makefile.2_6 Makefile
+make -C /usr/src/linux M=`pwd`
+
+The driver will be "adp94xx.ko".
+
+To insert it into the kernel, do:
+
+insmod adp94xx.ko
+
+You may want to give options.  See the readme.txt file in
+this directory.
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/Kconfig linux-2.6.16/drivers/scsi/adp94xx/Kconfig
--- linux-2.6.16.old/drivers/scsi/adp94xx/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/Kconfig	2007-04-05 23:35:00.000000000 +0000
@@ -0,0 +1,11 @@
+#
+# adp94xx 2.5.x kernel configuration file.
+#
+# $Id$
+#
+config SCSI_ADP94XX
+	tristate "Adaptec AIC94xx SAS/SATA support"
+	depends on PCI && SCSI
+	help
+	This driver supports all of Adaptec's 3Gb/s PCI-X
+	based SAS/SATA controllers.
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/Makefile linux-2.6.16/drivers/scsi/adp94xx/Makefile
--- linux-2.6.16.old/drivers/scsi/adp94xx/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/Makefile	2007-04-05 23:35:00.000000000 +0000
@@ -0,0 +1,28 @@
+#
+# Makefile for the Linux adp94xx SAS driver.
+#
+# $Id$
+#
+
+EXTRA_CFLAGS += -Idrivers/scsi -UASD_DEBUG -DSEQUENCER_UPDATE -DSATA_SKIP_FIX -DCONCURRENT_SUPPORT -UNO_SES_SUPPORT -UEXTENDED_SCB
+
+ifeq ($(CONFIG_SCSI_ADP94XX),)
+	CONFIG_SCSI_ADP94XX=m
+endif
+
+obj-$(CONFIG_SCSI_ADP94XX)	+= adp94xx.o
+
+# OSM and HWI Specific Files
+adp94xx-y			+= adp94xx_osm.o	\
+				   adp94xx_hwi.o	\
+				   adp94xx_seq.o	\
+				   adp94xx_discover.o
+
+# IOCTL Specific File
+adp94xx-y			+= adp94xx_ioctl.o
+
+# SATA Specific File
+adp94xx-y			+= adp94xx_sata.o
+
+
+
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_discover.c linux-2.6.16/drivers/scsi/adp94xx/adp94xx_discover.c
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_discover.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_discover.c	2007-04-05 23:37:42.000000000 +0000
@@ -0,0 +1,8138 @@
+#define NO_VPD_WORKAROUND
+#define SMP_OVERRUN_WORKAROUND
+#define SMP_UNDERRUN_WORKAROUND
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ *
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Adapted by : Robert Tarte  <robt@PacificCodeWorks.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+/*
+ * The source in this file is adapted from: SASDiscoverSimulation.cpp,
+ * from the SAS-1.1 draft, sas1r07.pdf, project T10/1601-D,
+ * ISO/IEC 14776-151:200x.
+ */
+/*
+ * This is an implementation of the initiator based expander discovery
+ * and configuration.  Structure names used are equivalent to those
+ * referenced in the SAS document.
+ * Basic assumptions:
+ *
+ * 1. Change primitives will initiate a rediscovery/configuration sequence.
+ * 2. Table locations for SASAddresses are deterministic for a specific
+ * topology only, when the topology changes, the location of a SASAddress
+ * in an ASIC table cannot be assumed.
+ * 3. A complete discovery level occurs before the configuration of the
+ * level begins, multiple passes are required as the levels of expanders
+ * encountered between the initiator and the end devices is increased.
+ * 4. Configuration of a single expander occurs before proceeding to
+ * subsequent expanders attached.
+ * 5. The Attached structure is filled in following OOB and is available
+ * from the initialization routines.
+ *
+ * $Id$
+ * 
+ */
+#define DISCOVER_DEBUG	0
+
+#include "adp94xx_osm.h"
+#include "adp94xx_inline.h"
+#include "adp94xx_sata.h"
+#if KDB_ENABLE
+#include "linux/kdb.h"
+#endif
+
+/*
+ * this defines the type of algorithm used for discover
+ */
+#if 0
+int DiscoverAlgorithm = SAS_SIMPLE_LEVEL_DESCENT;
+#else
+int DiscoverAlgorithm = SAS_UNIQUE_LEVEL_DESCENT;
+#endif
+
+#define ROUTE_ENTRY(expander, i, j) \
+	(expander->RouteTable + \
+		((expander->num_phys * (i) * SAS_ADDR_LEN) + \
+		(j) * SAS_ADDR_LEN))
+
+#define DUMP_EXPANDER(s, expander) \
+	asd_dump_expander((uint8_t *)__FUNCTION__, __LINE__, (s), expander)
+
+#define NEW_STATE(new_state)	new_state(sm_contextp, new_state)
+
+struct state_machine asd_DiscoverySM = {
+	asd_DiscoverySM_Initialize,
+	asd_DiscoverySM_StateMachine,
+	asd_DiscoverySM_Finish,
+	asd_DiscoverySM_Abort,
+	ASD_STATE_DISCOVER_START
+};
+
+struct state_machine asd_DiscoverExpanderSM = {
+	asd_DiscoverExpanderSM_Initialize,
+	asd_DiscoverExpanderSM_StateMachine,
+	asd_DiscoverExpanderSM_Finish,
+	asd_DiscoverExpanderSM_Abort,
+	ASD_STATE_REPORT_AND_DISCOVER_START
+};
+
+struct state_machine asd_DiscoverFindBoundarySM = {
+	asd_DiscoverFindBoundarySM_Initialize,
+	asd_DiscoverFindBoundarySM_StateMachine,
+	asd_DiscoverFindBoundarySM_Finish,
+	asd_DiscoverFindBoundarySM_Abort,
+	ASD_STATE_FIND_BOUNDARY_START
+};
+
+struct state_machine asd_DiscoverConfigSetSM = {
+	asd_DiscoverConfigSetSM_Initialize,
+	asd_DiscoverConfigSetSM_StateMachine,
+	asd_DiscoverConfigSetSM_Finish,
+	asd_DiscoverConfigSetSM_Abort,
+	ASD_STATE_CONFIG_SET_START
+};
+
+struct state_machine asd_ConfigureExpanderSM = {
+	asd_ConfigureExpanderSM_Initialize,
+	asd_ConfigureExpanderSM_StateMachine,
+	asd_ConfigureExpanderSM_Finish,
+	asd_ConfigureExpanderSM_Abort,
+	ASD_STATE_CONFIG_EXPANDER_START
+};
+
+struct state_machine asd_ConfigureATA_SM = {
+	asd_ConfigureATA_SM_Initialize,
+	asd_ConfigureATA_SM_StateMachine,
+	asd_ConfigureATA_SM_Finish,
+	asd_ConfigureATA_SM_Abort,
+	ASD_STATE_CONFIGURE_ATA_START
+};
+
+struct state_machine asd_InitSATA_SM = {
+	asd_InitSATA_SM_Initialize,
+	asd_InitSATA_SM_StateMachine,
+	asd_InitSATA_SM_Finish,
+	asd_InitSATA_SM_Abort,
+	ASD_STATE_INIT_SATA_START
+};
+
+struct state_machine asd_SATA_SpinHoldSM = {
+	asd_SATA_SpinHoldSM_Initialize,
+	asd_SATA_SpinHoldSM_StateMachine,
+	asd_SATA_SpinHoldSM_Finish,
+	asd_SATA_SpinHoldSM_Abort,
+	ASD_STATE_SATA_SPINHOLD_START
+};
+
+struct state_machine asd_InitSAS_SM = {
+	asd_InitSAS_SM_Initialize,
+	asd_InitSAS_SM_StateMachine,
+	asd_InitSAS_SM_Finish,
+	asd_InitSAS_SM_Abort,
+	ASD_STATE_INIT_SAS_START
+};
+
+struct state_machine asd_InitSMP_SM = {
+	asd_InitSMP_SM_Initialize,
+	asd_InitSMP_SM_StateMachine,
+	asd_InitSMP_SM_Finish,
+	asd_InitSMP_SM_Abort,
+	ASD_STATE_INIT_SMP_START
+};
+
+extern void
+asd_scb_internal_done(struct asd_softc *asd, struct scb *scb,
+		struct asd_done_list *dl);
+extern void asd_run_device_queues(struct asd_softc *asd);
+struct asd_target *asd_discover_get_target(struct state_machine_context
+					*sm_contextp,
+					uint8_t * dest_sas_address,
+					struct list_head *old_discover_listp,
+					struct list_head *found_listp,
+					unsigned conn_rate,
+					TRANSPORT_TYPE transport_type);
+
+struct asd_DiscoverySM_Context;
+
+static void asd_invalidate_targets(struct asd_softc *asd,
+					struct asd_port *port);
+static void asd_validate_targets_hotplug(struct asd_softc *asd,
+					struct asd_port *port,
+					struct asd_DiscoverySM_Context *ctx);
+static void asd_validate_targets_init(struct asd_softc *asd);
+static void asd_apply_conn_mask(struct asd_softc *asd,
+				struct list_head *discover_list);
+static int asd_discovery_queue_cmd(struct asd_softc *asd,
+				struct scb *scb, struct asd_target *targ,
+				struct asd_device *dev);
+
+#if DISCOVER_DEBUG
+static void asd_dump_tree(struct asd_softc *asd, struct asd_port *port);
+#else
+static void asd_dump_tree(struct asd_softc *asd, struct asd_port *port)
+{
+}
+#endif
+
+void asd_print_conn_rate(unsigned conn_rate, char *s)
+{
+	switch (conn_rate) {
+	case SAS_RATE_30GBPS:
+		printk(" 3.0-GBPS");
+		break;
+	case SAS_RATE_15GBPS:
+		printk(" 1.5-GBPS");
+		break;
+	default:
+		printk(" \?\?-GBPS");
+		break;
+	}
+	printk("%s", s);
+}
+
+void asd_print_state(unsigned state, char *s)
+{
+	switch (state) {
+	case ASD_STATE_DISCOVER_START:
+		printk("ASD_STATE_DISCOVER_START");
+		break;
+
+	case ASD_STATE_DISCOVER_ATTACHED:
+		printk("ASD_STATE_DISCOVER_ATTACHED");
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY:
+		printk("ASD_STATE_FIND_BOUNDARY");
+		break;
+
+	case ASD_STATE_CONFIG_BOUNDARY_SET:
+		printk("ASD_STATE_CONFIG_BOUNDARY_SET");
+		break;
+
+	case ASD_STATE_CONFIG_ATTACHED_SET:
+		printk("ASD_STATE_CONFIG_ATTACHED_SET");
+		break;
+
+	case ASD_STATE_FINISHED:
+		printk("ASD_STATE_FINISHED");
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD:
+		printk("ASD_STATE_SATA_SPINHOLD");
+		break;
+
+	case ASD_STATE_INIT_SATA:
+		printk("ASD_STATE_INIT_SATA");
+		break;
+
+	case ASD_STATE_INIT_SAS:
+		printk("ASD_STATE_INIT_SAS");
+		break;
+
+	case ASD_STATE_INIT_SMP:
+		printk("ASD_STATE_INIT_SMP");
+		break;
+
+	case ASD_STATE_FAILED:
+		printk("ASD_STATE_FAILED");
+		break;
+
+	case ASD_STATE_REPORT_AND_DISCOVER_START:
+		printk("ASD_STATE_REPORT_AND_DISCOVER_START");
+		break;
+
+	case ASD_STATE_ISSUE_REPORT_GENERAL:
+		printk("ASD_STATE_ISSUE_REPORT_GENERAL");
+		break;
+
+	case ASD_STATE_ISSUE_DISCOVER_LOOP:
+		printk("ASD_STATE_ISSUE_DISCOVER_LOOP");
+		break;
+
+	case ASD_STATE_REPORT_AND_DISCOVER_FINISHED:
+		printk("ASD_STATE_REPORT_AND_DISCOVER_FINISHED");
+		break;
+
+	case ASD_STATE_REPORT_AND_DISCOVER_FAILED:
+		printk("ASD_STATE_REPORT_AND_DISCOVER_FAILED");
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY_START:
+		printk("ASD_STATE_FIND_BOUNDARY_START");
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY_LOOP:
+		printk("ASD_STATE_FIND_BOUNDARY_LOOP");
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY_FINISHED:
+		printk("ASD_STATE_FIND_BOUNDARY_FINISHED");
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY_FAILED:
+		printk("ASD_STATE_FIND_BOUNDARY_FAILED");
+		break;
+
+	case ASD_STATE_CONFIG_SET_START:
+		printk("ASD_STATE_CONFIG_SET_START");
+		break;
+
+	case ASD_STATE_CONFIG_SET_ISSUE_DISCOVER:
+		printk("ASD_STATE_CONFIG_SET_ISSUE_DISCOVER");
+		break;
+
+	case ASD_STATE_CONFIG_SET_CONFIGURE_EXPANDER:
+		printk("ASD_STATE_CONFIG_SET_CONFIGURE_EXPANDER");
+		break;
+
+	case ASD_STATE_CONFIG_SET_FINISHED:
+		printk("ASD_STATE_CONFIG_SET_FINISHED");
+		break;
+
+	case ASD_STATE_CONFIG_SET_FAILED:
+		printk("ASD_STATE_CONFIG_SET_FAILED");
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_START:
+		printk("ASD_STATE_CONFIG_EXPANDER_START");
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_ROUTE:
+		printk("ASD_STATE_CONFIG_EXPANDER_ROUTE");
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_ROUTE_LOOP:
+		printk("ASD_STATE_CONFIG_EXPANDER_ROUTE_LOOP");
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_FINISHED:
+		printk("ASD_STATE_CONFIG_EXPANDER_FINISHED");
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_FAILED:
+		printk("ASD_STATE_CONFIG_EXPANDER_FAILED");
+		break;
+
+	case ASD_STATE_INIT_SATA_START:
+		printk("ASD_STATE_INIT_SATA_START");
+		break;
+
+	case ASD_STATE_INIT_SATA_REPORT_PHY:
+		printk("ASD_STATE_INIT_SATA_REPORT_PHY");
+		break;
+
+	case ASD_STATE_INIT_SATA_IDENTIFY:
+		printk("ASD_STATE_INIT_SATA_IDENTIFY");
+		break;
+
+	case ASD_STATE_INIT_SATA_CONFIGURE_FEATURES:
+		printk("ASD_STATE_INIT_SATA_CONFIGURE_FEATURES");
+		break;
+
+	case ASD_STATE_INIT_SATA_FINISHED:
+		printk("ASD_STATE_INIT_SATA_FINISHED");
+		break;
+
+	case ASD_STATE_INIT_SATA_FAILED:
+		printk("ASD_STATE_INIT_SATA_FAILED");
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_START:
+		printk("ASD_STATE_SATA_SPINHOLD_START");
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_PHY_CONTROL:
+		printk("ASD_STATE_SATA_SPINHOLD_PHY_CONTROL");
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_DISCOVER:
+		printk("ASD_STATE_SATA_SPINHOLD_DISCOVER");
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_FINISHED:
+		printk("ASD_STATE_SATA_SPINHOLD_FINISHED");
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_FAILED:
+		printk("ASD_STATE_SATA_SPINHOLD_FAILED");
+		break;
+
+	case ASD_STATE_INIT_SAS_START:
+		printk("ASD_STATE_INIT_SAS_START");
+		break;
+
+	case ASD_STATE_INIT_SAS_INQUIRY:
+		printk("ASD_STATE_INIT_SAS_INQUIRY");
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_DEVICE_ID:
+		printk("ASD_STATE_INIT_SAS_GET_DEVICE_ID");
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_SERIAL_NUMBER:
+		printk("ASD_STATE_INIT_SAS_GET_SERIAL_NUMBER");
+		break;
+
+	case ASD_STATE_INIT_SAS_ISSUE_REPORT_LUNS:
+		printk("ASD_STATE_INIT_SAS_ISSUE_REPORT_LUNS");
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_PORT_CONTROL:
+		printk("ASD_STATE_INIT_SAS_GET_PORT_CONTROL");
+		break;
+
+	case ASD_STATE_INIT_SAS_FINISHED:
+		printk("ASD_STATE_INIT_SAS_FINISHED");
+		break;
+
+	case ASD_STATE_INIT_SAS_FAILED:
+		printk("ASD_STATE_INIT_SAS_FAILED");
+		break;
+
+	case ASD_STATE_INIT_SMP_START:
+		printk("ASD_STATE_INIT_SMP_START");
+		break;
+
+	case ASD_STATE_INIT_SMP_REPORT_MANUFACTURER_INFO:
+		printk("ASD_STATE_INIT_SMP_REPORT_MANUFACTURER_INFO");
+		break;
+
+	case ASD_STATE_INIT_SMP_FINISHED:
+		printk("ASD_STATE_INIT_SMP_FINISHED");
+		break;
+
+	case ASD_STATE_INIT_SMP_FAILED:
+		printk("ASD_STATE_INIT_SMP_FAILED");
+		break;
+
+	case ASD_STATE_CONFIGURE_ATA_START:
+		printk("ASD_STATE_CONFIGURE_ATA_START");
+		break;
+
+	case ASD_STATE_CONFIGURE_ATA_FEATURES:
+		printk("ASD_STATE_CONFIGURE_ATA_FEATURES");
+		break;
+
+	case ASD_STATE_CONFIGURE_ATA_FINISHED:
+		printk("ASD_STATE_CONFIGURE_ATA_FINISHED");
+		break;
+
+	case ASD_STATE_CONFIGURE_ATA_FAILED:
+		printk("ASD_STATE_CONFIGURE_ATA_FAILED");
+		break;
+
+	default:
+		printk("[0x%04x]", state);
+		break;
+	}
+
+	printk("%s", s);
+}
+
+void SM_new_state(struct state_machine_context *sm_contextp, unsigned new_state)
+{
+	struct state_information *state_infop;
+
+	SETUP_STATE(sm_contextp);
+
+	//printk("[%d]===== ", sm_contextp->state_stack_top);
+	//asd_print_state(state_infop->current_state, " -> ");
+	//asd_print_state(new_state, "\n");
+
+	if ((new_state & state_infop->state_machine_p->first_state) !=
+		state_infop->state_machine_p->first_state) {
+
+		printk("illegal state 0x%x\n", new_state);
+		printk("[%d]===== ", sm_contextp->state_stack_top);
+		asd_print_state(state_infop->current_state, " -> ");
+		asd_print_state(new_state, "\n");
+	}
+
+	state_infop->current_state = new_state;
+}
+
+DISCOVER_RESULTS
+asd_run_state_machine(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	DISCOVER_RESULTS results;
+
+	SETUP_STATE(sm_contextp);
+
+	results = state_infop->state_machine_p->state_machine(sm_contextp);
+#ifdef ASD_DEBUG
+//JD
+	asd_print_state(state_infop->current_state, " from asd_run_state_machine\n");
+//JD
+	printk("results = 0x%x\n", results);
+#endif
+	while (results != DISCOVER_OK) {
+
+		state_infop =
+			&sm_contextp->state_stack[sm_contextp->state_stack_top];
+
+#ifdef ASD_DEBUG
+		if (results == DISCOVER_FAILED) {
+			printk("State Machine Failure: ");
+			asd_print_state(state_infop->current_state, "\n");
+		}
+#endif
+
+		if ((results == DISCOVER_FINISHED) ||
+			(results == DISCOVER_FAILED)) {
+
+			state_infop->state_machine_p->finish(sm_contextp,
+								results);
+
+			if (sm_contextp->state_stack_top == 0) {
+
+				//printk("nothing on stack\n");
+
+				return DISCOVER_OK;
+			}
+
+			POP_STATE(sm_contextp);
+		}
+
+		results = state_infop->state_machine_p->
+			state_machine(sm_contextp);
+	}
+
+	return results;
+}
+
+#define ASD_PUSH_STATE_MACHINE(sm_contextp, state_machine_p, arg)	\
+	asd_push_state_machine(sm_contextp, #state_machine_p,		\
+	state_machine_p, arg)
+
+DISCOVER_RESULTS
+asd_push_state_machine(struct state_machine_context * sm_contextp,
+			char *s,
+			struct state_machine * state_machine_p, void *arg)
+{
+	struct state_information *state_infop;
+	DISCOVER_RESULTS results;
+
+#if 0
+	printk("\n\n%s:=====================================================\n",
+		__FUNCTION__);
+	printk("%s: %s ============================\n", __FUNCTION__, s);
+	printk("%s:=====================================================\n\n\n",
+		__FUNCTION__);
+#endif
+	sm_contextp->state_stack_top++;
+	SETUP_STATE(sm_contextp);
+
+	state_infop->current_state = state_machine_p->first_state;
+	state_infop->stack_top = 0;
+	state_infop->state_machine_p = state_machine_p;
+
+	results = state_machine_p->initialize(sm_contextp, arg);
+
+	if (results != DISCOVER_CONTINUE) {
+
+		state_infop->state_machine_p->finish(sm_contextp, results);
+
+		if (sm_contextp->state_stack_top == 0) {
+
+			//printk("nothing on stack\n");
+
+			return results;
+		}
+
+		POP_STATE(sm_contextp);
+	}
+
+	return results;
+}
+
+void asd_abort_state_machine(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+
+	SETUP_STATE(sm_contextp);
+
+	while (sm_contextp->state_stack_top != -1) {
+
+		state_infop =
+			&sm_contextp->state_stack[sm_contextp->state_stack_top];
+
+		state_infop->state_machine_p->abort(sm_contextp);
+
+		POP_STATE(sm_contextp);
+	}
+}
+
+void
+asd_dump_expander(char *function,
+		unsigned line, char *string, struct asd_target *expander)
+{
+	unsigned i;
+	struct Discover *discover;
+
+	printk("||||||||||| - %s  - %s:%d:\n", string, function, line);
+	printk("||||||||||| - %0llx - ",
+		*((uint64_t *) expander->ddb_profile.sas_addr));
+
+	if (expander->management_type == ASD_DEVICE_END) {
+		printk("\n");
+		return;
+	}
+
+	printk("num_phys %d\n", expander->num_phys);
+
+	for (i = 0; i < expander->num_phys; i++) {
+
+		discover = &(expander->Phy[i].Result);
+
+		printk("||||||||||| - phy %d attached to %0llx\n", i,
+		       *((uint64_t *) discover->AttachedSASAddress));
+	}
+}
+
+void asd_dump_expander_list(char *s, struct list_head *discover_listp)
+{
+	struct asd_target *target;
+	struct asd_target *parent;
+
+	printk("----- %s\n", s);
+
+	list_for_each_entry(target, discover_listp, all_domain_targets) {
+
+		DUMP_EXPANDER("target:", target);
+
+		printk(" %0llx", *((uint64_t *) target->ddb_profile.sas_addr));
+
+		asd_print_conn_rate(target->ddb_profile.conn_rate, "\n");
+
+		for (parent = target->parent; parent != NULL;
+		     parent = parent->parent) {
+
+			printk("\t:%0llx\n",
+			       *((uint64_t *) parent->ddb_profile.sas_addr));
+		}
+	}
+	printk("-----\n");
+}
+
+void
+asd_discover_wakeup_state_machine(struct state_machine_context *sm_contextp)
+{
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+
+	discover_contextp->port->events |= ASD_DISCOVERY_EVENT;
+
+	asd_wakeup_sem(&discover_contextp->asd->platform_data->discovery_sem);
+}
+
+
+static void
+asd_discovery_ehandler_done(struct asd_softc *asd, struct scb *scb)
+{
+//	unsigned long flags;
+	struct state_machine_context *sm_contextp;
+	struct discover_context *discover_contextp;
+
+	asd_log(ASD_DBG_ERROR, "asd_ssp_abort_scb_done ehandler is done.\n");
+
+	sm_contextp = (struct state_machine_context *)scb->io_ctx;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+	discover_contextp->resid_len = 0;
+	discover_contextp->openStatus = OPEN_REJECT_BAD_DESTINATION;
+	sm_contextp->wakeup_state_machine(sm_contextp);
+	asd->platform_data->flags &= ~ASD_SCB_UP_EH_SEM;
+}
+
+void
+asd_discovery_timeout(
+u_long		val
+)
+{
+	struct scb			*scb;
+	struct state_machine_context	*sm_contextp;
+	struct discover_context 	*discover_contextp;
+	u_long			 flags;
+	scb = (struct scb *)val;
+#ifdef ASD_DEBUG
+	printk("%s:%d: scb 0x%x, scb->flags 0x%x, scb->post 0x%x timeout!!!\n", __FUNCTION__, __LINE__, scb,scb->flags,scb->post);
+	printk("scb->io_ctx is 0x%x.\n", scb->io_ctx);
+#endif
+	sm_contextp = (struct state_machine_context *)scb->io_ctx;
+	if(sm_contextp==NULL)
+	{
+		printk( "scb->io_ctx is NULL.\n");
+		return;
+	}
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+#ifdef ASD_DEBUG
+	printk( "sm_contextp->state_handle is 0x%x.\n", sm_contextp->state_handle);
+#endif
+	if(discover_contextp==NULL)
+	{
+		printk( "sm_contextp->state_handle is NULL.\n");
+		return;
+	}
+//JD
+#ifdef DEBUG_DDB
+#ifdef ASD_DEBUG
+#ifdef CONCURRENT_SUPPORT
+		{
+			u_long	lseqs_to_dump;
+			u_int	lseq_id;
+			int		indx;
+
+			for(indx=0;indx< discover_contextp->asd->ddb_bitmap_size; indx++)
+			{
+				lseq_id = 0;
+				lseqs_to_dump = discover_contextp->asd->free_ddb_bitmap[indx];
+
+				while (lseqs_to_dump != 0) { 
+					for ( ; lseq_id < (8 * sizeof(u_long)); lseq_id++) {
+						if (lseqs_to_dump & (1UL << lseq_id)) {
+							lseqs_to_dump &= ~(1UL << lseq_id);
+							break;
+						} 
+					}
+		/* Dump out specific LSEQ Registers state. */
+					asd_hwi_dump_ssp_smp_ddb_site(discover_contextp->asd, lseq_id + (indx * 8 * sizeof(ulong)));
+				}
+			}
+		}
+		asd_hwi_dump_seq_state(discover_contextp->asd, discover_contextp->asd->hw_profile.enabled_phys);
+#endif
+#endif
+#endif
+		asd_lock(discover_contextp->asd, &flags);
+//	ASD_LOCK_ASSERT(discover_contextp->asd);
+/* the following will try to do a linkreset and wait for another 4 sec.
+it is a workaround for Vitesse VSC7160 Phy0&SES device problem
+*/
+	if(discover_contextp->retry_count==0)
+	{
+		struct asd_target	*target;
+
+		target = scb->platform_data->targ;
+		if(target != NULL)
+		{
+/* workaround for Vitesse vsc7160 issue, vitesse 50001cXXXd
+*/
+			if( (target->ddb_profile.sas_addr[0]==0x50) &&
+				(target->ddb_profile.sas_addr[1]==0x00) &&
+				(target->ddb_profile.sas_addr[2]==0x1c) )
+			{
+					struct asd_phy		*phy;
+					struct asd_port		*port;
+
+					port = scb->platform_data->targ->src_port;
+/* behind Expander
+*/
+					if ( (port->management_type != ASD_DEVICE_END) && (target->parent != NULL) )
+					{
+/* the virtual SES device, last phy
+*/
+						if((target->ddb_profile.sas_addr[7]&0x0f)>=target->parent->num_phys)
+						{
+							list_for_each_entry(phy, &port->phys_attached, links)
+							{
+								asd_unlock(discover_contextp->asd, &flags);
+								if (asd_hwi_enable_phy(discover_contextp->asd, phy) != 0) {
+			/*
+			 * TODO: This shouldn't happen.
+			 *       Need more thought on how to proceed.
+			 */
+									asd_log(ASD_DBG_ERROR, "Failed to enable phy %d.\n", phy->id);
+								}
+								asd_lock(discover_contextp->asd, &flags);
+							}
+							discover_contextp->retry_count++;
+							asd_setup_scb_timer(scb, (4 * HZ), asd_discovery_timeout);
+							asd_unlock(discover_contextp->asd, &flags);
+							return;
+						}
+					}
+			}
+		}
+	}
+
+	scb->flags |= SCB_TIMEDOUT;
+	scb->eh_post = asd_discovery_ehandler_done;
+	scb->eh_state = SCB_EH_ABORT_REQ;
+	list_add_tail(&scb->timedout_links, 
+		&discover_contextp->asd->timedout_scbs);
+	discover_contextp->asd->platform_data->flags |= ASD_SCB_UP_EH_SEM;
+	asd_unlock(discover_contextp->asd, &flags);
+	asd_wakeup_sem(&discover_contextp->asd->platform_data->ehandler_sem);
+}
+
+static void
+asd_discovery_request_timeout(
+u_long		val
+)
+{
+	struct scb		*scb;
+	void			(*timeout_func)(u_long);
+
+	scb = (struct scb *)val;
+
+	timeout_func = scb->post_stack[scb->post_stack_depth-1].timeout_func;
+
+	while (timeout_func == NULL)
+	{
+#ifdef ASD_DEBUG
+		printk( "scb 0x%x, scb->post_stack_depth 0x%x, &scb->post_stack[0] =0x%x &scb->post_stack[1] =0x%x Found one NULL! ... that's OK, check the next!\n",scb,scb->post_stack_depth, &scb->post_stack[0], &scb->post_stack[1]);
+#endif
+		if (scb->post_stack_depth == 0) {
+			panic("post_stack underflow - scb = %p\n", scb);
+			return;
+		}
+		scb->post_stack_depth--;
+
+		scb->io_ctx = scb->post_stack[scb->post_stack_depth-1].io_ctx;
+		scb->post = scb->post_stack[scb->post_stack_depth-1].post;
+		timeout_func = 
+			scb->post_stack[scb->post_stack_depth-1].timeout_func;
+#ifdef ASD_DEBUG
+		printk( "Next post= 0x%x, io_ctx= 0x%x, timeout_func= 0x%x\n",scb->post_stack[scb->post_stack_depth-1].post,scb->post_stack[scb->post_stack_depth-1].io_ctx,scb->post_stack[scb->post_stack_depth-1].timeout_func); 
+#endif
+	}
+
+#ifdef ASD_DEBUG
+	printk( "Execute timeout routine (0x%x)\n", timeout_func);
+#endif
+
+	(*timeout_func)(val);
+}
+
+DISCOVER_RESULTS
+asd_ssp_request(struct state_machine_context *sm_contextp,
+		struct asd_target *target,
+		uint8_t * command,
+		unsigned command_len,
+		dma_addr_t buf_busaddr, unsigned buffer_len, unsigned direction)
+{
+	struct asd_ssp_task_hscb *ssp_hscb;
+	unsigned long flags;
+	struct scb *scb;
+	struct sg_element *sg;
+	int error;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+
+	asd_lock(discover_contextp->asd, &flags);
+	asd_hwi_hash(target->ddb_profile.sas_addr, target->ddb_profile.hashed_sas_addr);
+
+	/*
+	 * Get an scb to use.
+	 */
+	if ((scb = asd_hwi_get_scb(discover_contextp->asd, 1)) == NULL) {
+		// TODO - fix this
+
+		asd_unlock(discover_contextp->asd, &flags);
+
+		return DISCOVER_FAILED;
+	}
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "scb 0x%x created\n", scb);
+#endif
+
+	scb->flags |= SCB_INTERNAL;
+
+	scb->platform_data->targ = target;
+
+	scb->platform_data->dev = NULL;
+
+	list_add_tail(&scb->owner_links,
+		      &discover_contextp->asd->platform_data->pending_os_scbs);
+
+	ssp_hscb = &scb->hscb->ssp_task;
+
+	ssp_hscb->header.opcode = SCB_INITIATE_SSP_TASK;
+
+	asd_build_sas_header(target, ssp_hscb);
+
+	ssp_hscb->protocol_conn_rate |= PROTOCOL_TYPE_SSP;
+
+	ssp_hscb->data_dir_flags |= direction;
+
+	ssp_hscb->xfer_len = asd_htole32(buffer_len);
+
+	memcpy(ssp_hscb->cdb, command, command_len);
+
+	memset(&ssp_hscb->cdb[command_len], 0,
+		SCB_EMBEDDED_CDB_SIZE - command_len);
+
+	sg = scb->sg_list;
+
+	scb->platform_data->buf_busaddr = buf_busaddr;
+
+	error = asd_sg_setup(sg, buf_busaddr, buffer_len, /*last */ 1);
+
+	if (error != 0) {
+		return DISCOVER_FAILED;
+	}
+
+	memcpy(ssp_hscb->sg_elements, scb->sg_list, sizeof(*sg));
+
+	scb->sg_count = 1;
+
+	asd_push_post_stack_timeout(discover_contextp->asd, scb,
+		(void *)sm_contextp, asd_ssp_request_done,
+			asd_discovery_timeout);
+
+	scb->flags |= SCB_ACTIVE;
+
+//JD TEST wait 4 seconds
+	asd_setup_scb_timer(scb, (4 * HZ), asd_discovery_request_timeout);
+
+	asd_hwi_post_scb(discover_contextp->asd, scb);
+
+	asd_unlock(discover_contextp->asd, &flags);
+
+	return DISCOVER_OK;
+}
+
+void
+asd_ssp_request_done(struct asd_softc *asd,
+		     struct scb *scb, struct asd_done_list *done_listp)
+{
+	struct state_machine_context *sm_contextp;
+	struct discover_context *discover_contextp;
+#ifdef ASD_DEBUG
+	printk("%s:%d scb=0x%x dl=0x%x\n", __FUNCTION__, __LINE__, scb,done_listp->opcode);
+#endif
+//JD TEST
+	del_timer_sync(&scb->platform_data->timeout);
+
+	sm_contextp = (struct state_machine_context *)scb->io_ctx;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+
+	asd_scb_internal_done(asd, scb, done_listp);
+
+	discover_contextp->resid_len = 0;
+
+	/*
+	 * TODO: need better return value here
+	 */
+	switch (done_listp->opcode) {
+	case TASK_COMP_WO_ERR:
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		break;
+
+	case TASK_COMP_W_UNDERRUN:
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		discover_contextp->resid_len =
+		    asd_le32toh(done_listp->stat_blk.data.res_len);
+		break;
+
+	case TASK_F_W_OPEN_REJECT:
+		printk("%s:%d: reject abandon_open %x reason %x\n",
+			__FUNCTION__, __LINE__,
+			done_listp->stat_blk.open_reject.abandon_open,
+			done_listp->stat_blk.open_reject.reason);
+		break;
+
+	case SSP_TASK_COMP_W_RESP:
+		{
+			union edb 		*edb;
+			struct scb 		*escb;
+			u_int			 edb_index;
+			edb = asd_hwi_get_edb_from_dl(asd, scb, done_listp, &escb, &edb_index);
+			if (edb != NULL) {
+				asd_hwi_free_edb(asd, escb, edb_index);
+			}
+		}
+
+	default:
+		/*
+		 * TODO: need better return value here
+		 */
+		discover_contextp->openStatus = OPEN_REJECT_BAD_DESTINATION;
+		break;
+	}
+	sm_contextp->wakeup_state_machine(sm_contextp);
+}
+
+DISCOVER_RESULTS
+asd_smp_request(struct state_machine_context *sm_contextp,
+		struct asd_target *target,
+		unsigned request_length, unsigned response_length)
+{
+	struct asd_smp_task_hscb *smp_hscb;
+	unsigned long flags;
+	struct scb *scb;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+
+	asd_lock(discover_contextp->asd, &flags);
+
+	/*
+	 * Get an scb to use.
+	 */
+	if ((scb = asd_hwi_get_scb(discover_contextp->asd, 1)) == NULL) {
+		// TODO - fix this
+
+		asd_unlock(discover_contextp->asd, &flags);
+
+		return DISCOVER_FAILED;
+	}
+
+	scb->flags |= SCB_INTERNAL;
+	scb->platform_data->dev = NULL;
+	scb->platform_data->targ = target;
+
+	list_add_tail(&scb->owner_links,
+		      &discover_contextp->asd->platform_data->pending_os_scbs);
+
+	smp_hscb = &scb->hscb->smp_task;
+
+	smp_hscb->header.opcode = SCB_INITIATE_SMP_TASK;
+	smp_hscb->protocol_conn_rate = target->ddb_profile.conn_rate;
+
+	smp_hscb->smp_req_busaddr = discover_contextp->SMPRequestBusAddr;
+	smp_hscb->smp_req_size = request_length;
+
+	smp_hscb->smp_req_ds = 0;
+	smp_hscb->sister_scb = 0xffff;
+	smp_hscb->conn_handle = target->ddb_profile.conn_handle;
+
+	smp_hscb->smp_resp_busaddr = discover_contextp->SMPResponseBusAddr;
+	smp_hscb->smp_resp_size = response_length;
+
+	smp_hscb->smp_resp_ds = 0;
+
+	asd_push_post_stack_timeout(discover_contextp->asd, scb,
+		(void *)sm_contextp, asd_smp_request_done,
+			asd_discovery_timeout);
+
+	scb->flags |= SCB_ACTIVE;
+
+//JD TEST
+	asd_setup_scb_timer(scb, (4 * HZ), asd_discovery_request_timeout);
+
+	asd_hwi_post_scb(discover_contextp->asd, scb);
+
+	asd_unlock(discover_contextp->asd, &flags);
+
+	return DISCOVER_OK;
+}
+
+void
+asd_smp_request_done(struct asd_softc *asd,
+		     struct scb *scb, struct asd_done_list *done_listp)
+{
+	struct state_machine_context *sm_contextp;
+	struct discover_context *discover_contextp;
+
+//JD TEST
+	del_timer_sync(&scb->platform_data->timeout);
+
+	sm_contextp = (struct state_machine_context *)scb->io_ctx;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+
+	asd_scb_internal_done(asd, scb, done_listp);
+
+#if 0
+	if (done_listp->opcode != TASK_COMP_WO_ERR) {
+		printk("%s:%d: opcode = 0x%x\n", __FUNCTION__, __LINE__,
+		       done_listp->opcode);
+	}
+#endif
+	discover_contextp->resid_len = 0;
+
+	/*
+	 * TODO: need better return value here
+	 */
+	switch (done_listp->opcode) {
+	case TASK_COMP_WO_ERR:
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		break;
+#ifdef SMP_UNDERRUN_WORKAROUND
+	case TASK_COMP_W_UNDERRUN:
+		//printk("Ignoring UNDERRUN condition on SMP request\n");
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		discover_contextp->resid_len =
+		    asd_le32toh(done_listp->stat_blk.data.res_len);
+		break;
+#endif
+#ifdef SMP_OVERRUN_WORKAROUND
+	case TASK_COMP_W_OVERRUN:
+		/*
+		 * This wasn't fixed in B0, so it will be investigated more.
+		 */
+		//printk("Ignoring OVERRUN condition on SMP request - ");
+		//printk("should be fixed in B0\n");
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		break;
+#endif
+	case TASK_F_W_SMPRSP_TO:
+	case TASK_F_W_SMP_XMTRCV_ERR:
+		discover_contextp->openStatus = OPEN_REJECT_BAD_DESTINATION;
+		break;
+	case TASK_ABORTED_BY_ITNL_EXP:
+		switch (done_listp->stat_blk.itnl_exp.reason) {
+		case TASK_F_W_PHY_DOWN:
+		case TASK_F_W_BREAK_RCVD:
+		case TASK_F_W_OPEN_TO:
+			discover_contextp->openStatus =
+			    OPEN_REJECT_BAD_DESTINATION;
+			break;
+
+		case TASK_F_W_OPEN_REJECT:
+			discover_contextp->openStatus =
+			    OPEN_REJECT_BAD_DESTINATION;
+#if 0
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RATE_NOT_SUPPORTED;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_NO_DESTINATION;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_PATHWAY_BLOCKED;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_PROTOCOL_NOT_SUPPORTED;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RESERVE_ABANDON;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RESERVE_CONTINUE;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RESERVE_INITIALIZE;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RESERVE_STOP;
+			discover_contextp->openStatus = OPEN_REJECT_RETRY;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_STP_RESOURCES_BUSY;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_WRONG_DESTINATION;
+#endif
+			break;
+		}
+		break;
+	case TASK_CLEARED:
+		/* Aborted command. Status needs to be changed .... */
+		break;
+	default:
+		discover_contextp->openStatus = OPEN_REJECT_BAD_DESTINATION;
+		break;
+	}
+
+	sm_contextp->wakeup_state_machine(sm_contextp);
+}
+
+DISCOVER_RESULTS
+asd_sata_identify_request(struct state_machine_context *sm_contextp,
+			  struct asd_target *target)
+{
+	unsigned long flags;
+	struct scb *scb;
+	struct discover_context *discover_contextp;
+	struct asd_target *old_target;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+	asd_lock(discover_contextp->asd, &flags);
+
+	/*
+	 * Get an scb to use.
+	 */
+	if ((scb = asd_hwi_get_scb(discover_contextp->asd, 1)) == NULL) {
+		// TODO - fix this
+
+		asd_unlock(discover_contextp->asd, &flags);
+
+		return DISCOVER_FAILED;
+	}
+
+	scb->flags |= SCB_INTERNAL;
+	scb->platform_data->dev = NULL;
+
+	asd_push_post_stack_timeout(discover_contextp->asd, scb,
+		(void *)sm_contextp, asd_sata_identify_request_done,
+		asd_discovery_timeout);
+
+	list_add_tail(&scb->owner_links,
+		      &discover_contextp->asd->platform_data->pending_os_scbs);
+
+	if (asd_sata_identify_build(discover_contextp->asd, target, scb) != 0) {
+
+		asd_hwi_free_scb(discover_contextp->asd, scb);
+
+		asd_unlock(discover_contextp->asd, &flags);
+
+		return DISCOVER_FAILED;
+	}
+
+	scb->flags |= SCB_ACTIVE;
+
+	/*
+	 * We want to use the flow control of the device queue if possible.
+	 * Look through the old/new discover list for this target.
+	 * If target exists, see if device exists.
+	 */
+	old_target = asd_find_target(discover_contextp->asd->old_discover_listp,
+				     target->ddb_profile.sas_addr);
+
+	if (old_target == NULL) {
+		old_target =
+		    asd_find_target(discover_contextp->asd->discover_listp,
+				    target->ddb_profile.sas_addr);
+	}
+
+	/*
+	 * sata devices should have only one lun, check lun 0.
+	 */
+	if (old_target != NULL) {
+
+		if (old_target->devices[0] != NULL) {
+
+			scb->platform_data->dev = target->devices[0];
+
+			asd_unlock(discover_contextp->asd, &flags);
+
+			if ((asd_discovery_queue_cmd(discover_contextp->asd,
+						     scb, old_target,
+						     old_target->devices[0]))) {
+
+				asd_hwi_free_scb(discover_contextp->asd, scb);
+
+				return DISCOVER_FAILED;
+			}
+
+			return DISCOVER_OK;
+		}
+	}
+
+	scb->flags |= SCB_ACTIVE;
+
+//JD TEST
+	asd_setup_scb_timer(scb, (4 * HZ), asd_discovery_request_timeout);
+//JD
+#ifdef DEBUG_DDB
+#ifdef ASD_DEBUG
+#ifdef CONCURRENT_SUPPORT
+		{
+			u_long	lseqs_to_dump;
+			u_int	lseq_id;
+			int		indx;
+
+			for(indx=0;indx< discover_contextp->asd->ddb_bitmap_size; indx++)
+			{
+				lseq_id = 0;
+				lseqs_to_dump = discover_contextp->asd->free_ddb_bitmap[indx];
+
+				while (lseqs_to_dump != 0) { 
+					for ( ; lseq_id < (8 * sizeof(u_long)); lseq_id++) {
+						if (lseqs_to_dump & (1UL << lseq_id)) {
+							lseqs_to_dump &= ~(1UL << lseq_id);
+							break;
+						} 
+					}
+		/* Dump out specific LSEQ Registers state. */
+					asd_hwi_dump_ssp_smp_ddb_site(discover_contextp->asd, lseq_id + (indx * 8 * sizeof(ulong)));
+				}
+			}
+		}
+#endif
+#endif
+#endif
+	asd_hwi_post_scb(discover_contextp->asd, scb);
+
+	asd_unlock(discover_contextp->asd, &flags);
+
+	return DISCOVER_OK;
+}
+
+static int
+asd_discovery_queue_cmd(struct asd_softc *asd,
+			struct scb *scb, struct asd_target *targ,
+			struct asd_device *dev)
+{
+	u_long				flags;
+	struct asd_port			*port;
+
+	asd_lock(asd, &flags);
+
+	port = dev->target->src_port;
+
+	dev->openings--;
+	dev->active++;
+	dev->commands_issued++;
+	list_add_tail(&scb->owner_links, &asd->platform_data->pending_os_scbs);
+
+	scb->flags |= SCB_ACTIVE;
+
+//JD TEST
+	asd_setup_scb_timer(scb, (4 * HZ), asd_discovery_request_timeout);
+
+	asd_hwi_post_scb(asd, scb);
+
+	asd_unlock(asd, &flags);
+
+	return 0;
+}
+
+void
+asd_sata_identify_request_done(struct asd_softc *asd,
+			       struct scb *scb,
+			       struct asd_done_list *done_listp)
+{
+	struct state_machine_context *sm_contextp;
+	struct discover_context *discover_contextp;
+
+//JD TEST
+	del_timer_sync(&scb->platform_data->timeout);
+
+	sm_contextp = (struct state_machine_context *)scb->io_ctx;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+
+	/*
+	 * If this is not NULL, scb was sent via device queue.
+	 */
+	if (scb->platform_data->dev) {
+		scb->platform_data->dev->active--;
+		scb->platform_data->dev->openings++;
+		scb->platform_data->dev->commands_issued--;
+	}
+
+	asd_scb_internal_done(asd, scb, done_listp);
+
+	discover_contextp->resid_len = 0;
+
+	/*
+	 * TODO: need better return value here
+	 */
+	switch (done_listp->opcode) {
+	case TASK_COMP_WO_ERR:
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		break;
+
+	case TASK_COMP_W_UNDERRUN:
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		discover_contextp->resid_len =
+		    asd_le32toh(done_listp->stat_blk.data.res_len);
+		break;
+
+	case TASK_ABORTED_BY_ITNL_EXP:
+		switch (done_listp->stat_blk.itnl_exp.reason) {
+		case TASK_F_W_PHY_DOWN:
+		case TASK_F_W_BREAK_RCVD:
+		case TASK_F_W_OPEN_TO:
+			discover_contextp->openStatus =
+			    OPEN_REJECT_BAD_DESTINATION;
+			break;
+
+		case TASK_F_W_OPEN_REJECT:
+			discover_contextp->openStatus =
+			    OPEN_REJECT_BAD_DESTINATION;
+#if 0
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RATE_NOT_SUPPORTED;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_NO_DESTINATION;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_PATHWAY_BLOCKED;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_PROTOCOL_NOT_SUPPORTED;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RESERVE_ABANDON;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RESERVE_CONTINUE;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RESERVE_INITIALIZE;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_RESERVE_STOP;
+			discover_contextp->openStatus = OPEN_REJECT_RETRY;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_STP_RESOURCES_BUSY;
+			discover_contextp->openStatus =
+			    OPEN_REJECT_WRONG_DESTINATION;
+#endif
+			break;
+		}
+		break;
+	case TASK_CLEARED:
+		/* Aborted command. Status needs to be changed .... */
+		break;
+	default:
+		discover_contextp->openStatus = OPEN_REJECT_BAD_DESTINATION;
+		break;
+	}
+
+	sm_contextp->wakeup_state_machine(sm_contextp);
+}
+
+DISCOVER_RESULTS
+asd_sata_configure_features(struct state_machine_context *sm_contextp,
+			    struct asd_target *target,
+			    uint8_t feature, uint8_t sector_count)
+{
+	unsigned long flags;
+	struct scb *scb;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+
+	asd_lock(discover_contextp->asd, &flags);
+
+	/*
+	 * Get an scb to use.
+	 */
+	if ((scb = asd_hwi_get_scb(discover_contextp->asd, 1)) == NULL) {
+		// TODO - fix this
+
+		asd_unlock(discover_contextp->asd, &flags);
+
+		return DISCOVER_FAILED;
+	}
+
+	scb->flags |= SCB_INTERNAL;
+	scb->platform_data->dev = NULL;
+	scb->platform_data->targ = target;
+
+	asd_push_post_stack_timeout(discover_contextp->asd, scb,
+		(void *)sm_contextp, asd_sata_configure_features_done,
+		asd_discovery_timeout);
+
+	list_add_tail(&scb->owner_links,
+		      &discover_contextp->asd->platform_data->pending_os_scbs);
+
+	if (asd_sata_set_features_build(discover_contextp->asd, target, scb,
+					feature, sector_count) != 0) {
+
+		asd_hwi_free_scb(discover_contextp->asd, scb);
+
+		asd_unlock(discover_contextp->asd, &flags);
+
+		return DISCOVER_FAILED;
+	}
+
+	scb->flags |= SCB_ACTIVE;
+
+//JD TEST
+	asd_setup_scb_timer(scb, (4 * HZ), asd_discovery_request_timeout);
+
+	asd_hwi_post_scb(discover_contextp->asd, scb);
+
+	asd_unlock(discover_contextp->asd, &flags);
+
+	return DISCOVER_OK;
+}
+
+void
+asd_sata_configure_features_done(struct asd_softc *asd,
+				 struct scb *scb,
+				 struct asd_done_list *done_listp)
+{
+	struct state_machine_context *sm_contextp;
+	struct discover_context *discover_contextp;
+
+//JD TEST
+	del_timer_sync(&scb->platform_data->timeout);
+
+	sm_contextp = (struct state_machine_context *)scb->io_ctx;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+
+	asd_scb_internal_done(asd, scb, done_listp);
+
+	discover_contextp->resid_len = 0;
+
+	/*
+	 * TODO: need better return value here
+	 */
+	switch (done_listp->opcode) {
+	case TASK_COMP_WO_ERR:
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		break;
+
+	case TASK_COMP_W_UNDERRUN:
+		discover_contextp->openStatus = OPEN_ACCEPT;
+		discover_contextp->resid_len =
+		    asd_le32toh(done_listp->stat_blk.data.res_len);
+		break;
+
+	case TASK_ABORTED_BY_ITNL_EXP:
+		switch (done_listp->stat_blk.itnl_exp.reason) {
+		case TASK_F_W_PHY_DOWN:
+		case TASK_F_W_BREAK_RCVD:
+		case TASK_F_W_OPEN_TO:
+			discover_contextp->openStatus =
+				OPEN_REJECT_BAD_DESTINATION;
+			break;
+
+		case TASK_F_W_OPEN_REJECT:
+			discover_contextp->openStatus = 
+				OPEN_REJECT_BAD_DESTINATION;
+			break;
+		}
+		break;
+	default:
+		discover_contextp->openStatus = OPEN_REJECT_BAD_DESTINATION;
+		break;
+	}
+
+	sm_contextp->wakeup_state_machine(sm_contextp);
+}
+
+struct asd_target *asd_discover_get_target(struct state_machine_context
+					   *sm_contextp,
+					   uint8_t * dest_sas_address,
+					   struct list_head *old_discover_listp,
+					   struct list_head *found_listp,
+					   unsigned conn_rate,
+					   TRANSPORT_TYPE transport_type)
+{
+	struct asd_target *target;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+		sm_contextp->state_handle;
+	target = asd_find_target(old_discover_listp, dest_sas_address);
+
+	if (target != NULL) {
+		/*
+		 * This target was previously found.
+		 */
+		target->flags |= ASD_TARG_RESEEN;
+
+		target->ddb_profile.conn_rate = conn_rate;
+
+		asd_hwi_build_ddb_site(discover_contextp->asd, target);
+
+		/*
+		 * First, take this target off of the general chain of all
+		 * targets in the domain.
+		 */
+		list_del_init(&target->all_domain_targets);
+
+		return target;
+	}
+
+	/*
+	 * See if we haven't already talked to this device during the current
+	 * discovery process.
+	 */
+	target = asd_find_target(found_listp, dest_sas_address);
+
+	if (target != NULL) {
+		/*
+		 * First, take this target off of the general chain of all
+		 * targets in the domain.
+		 */
+		list_del_init(&target->all_domain_targets);
+
+		return target;
+	}
+
+	target = asd_alloc_target(discover_contextp->asd,
+				  discover_contextp->port);
+
+	/*
+	 * make sure we only do this if the allocation is successful
+	 */
+	if (target == NULL) {
+		return NULL;
+	}
+
+	target->domain = discover_contextp->asd->platform_data->
+		domains[discover_contextp->port->id];
+
+	target->ddb_profile.conn_rate = conn_rate;
+
+	target->ddb_profile.itnl_const = ITNL_TIMEOUT_CONST;
+#ifdef SEQUENCER_UPDATE
+	if (transport_type == ASD_TRANSPORT_ATA) {
+		target->ddb_profile.itnl_const = 1;
+	}
+#endif
+
+	target->parent = NULL;
+
+	/*
+	 * Set to 1 for SSP, STP, and SMP device ports. 0 for all SATA direct
+	 * attached ports.  Every device that is initialized by this routine
+	 * is not a SATA direct attach.
+	 */
+	target->ddb_profile.open_affl = OPEN_AFFILIATION;
+
+	memcpy(target->ddb_profile.sas_addr, dest_sas_address, SAS_ADDR_LEN);
+	target->transport_type = transport_type;
+	if (transport_type == ASD_TRANSPORT_STP) {
+		//TODO: get SUPPORTS_AFFILIATION out of SMP request
+		target->ddb_profile.open_affl |=
+//		    (STP_AFFILIATION | SUPPORTS_AFFILIATION);
+		    SUPPORTS_AFFILIATION;
+	}
+#ifdef SEQUENCER_UPDATE
+#ifdef CONCURRENT_SUPPORT
+	else if (transport_type != ASD_TRANSPORT_ATA) {
+// not STP, nor ATA
+		target->ddb_profile.open_affl |= CONCURRENT_CONNECTION_SUPPORT;
+	}
+#endif
+#endif
+
+	asd_hwi_hash(target->ddb_profile.sas_addr,
+		     target->ddb_profile.hashed_sas_addr);
+
+	// TODO: - we need to allocate this from LRU DDB list
+	// (doesn't exist yet)
+	asd_hwi_setup_ddb_site(discover_contextp->asd, target);
+	return target;
+}
+
+DISCOVER_RESULTS
+asd_find_subtractive_phy(struct state_machine_context * sm_contextp,
+			 struct asd_target * expander,
+			 uint8_t * subtractiveSASAddress,
+			 uint8_t * attachedPhyIdentifier,
+			 unsigned *conn_rate, uint8_t * phyIdentifier)
+{
+	struct Discover *discover;
+	DISCOVER_RESULTS result;
+	uint8_t phyCount;
+	unsigned foundSubtractive;
+
+	SAS_ZERO(subtractiveSASAddress);
+	*attachedPhyIdentifier = 0;
+
+	foundSubtractive = 0;
+
+	/*
+	 * walk through all the phys of this expander
+	 */
+	for (phyCount = 0; phyCount < expander->num_phys; phyCount++) {
+
+		/*
+		 * this is just a pointer helper
+		 */
+		discover = &(expander->Phy[phyCount].Result);
+
+		/*
+		 * look for phys with edge or fanout devices attached...
+		 */
+		if ((discover->RoutingAttribute != SUBTRACTIVE) ||
+		    ((discover->AttachedDeviceType !=
+		      EDGE_EXPANDER_DEVICE) &&
+		     (discover->AttachedDeviceType !=
+		      FANOUT_EXPANDER_DEVICE))) {
+
+			continue;
+		}
+
+		/*
+		 * make sure all the subtractive phys point to
+		 * the same address when we are connected to an
+		 * expander device
+		 */
+		if (SAS_ISZERO(subtractiveSASAddress)) {
+
+			SASCPY(subtractiveSASAddress,
+			       discover->AttachedSASAddress);
+
+			*attachedPhyIdentifier =
+			    discover->AttachedPhyIdentifier;
+
+			result = DISCOVER_OK;
+
+			*conn_rate = discover->NegotiatedPhysicalLinkRate;
+
+			*phyIdentifier = phyCount;
+
+			foundSubtractive = 1;
+		} else if (!SAS_ISEQUAL(subtractiveSASAddress,
+					discover->AttachedSASAddress)) {
+
+			/*
+			 * the addresses don't match... 
+			 * problem...
+			 */
+			asd_log(ASD_DBG_ERROR, "\n"
+				"topology error, diverging "
+				"subtractive phys"
+				", '%0llx' != '%0llx' \n",
+				*((uint64_t *) subtractiveSASAddress),
+				*((uint64_t *) discover->AttachedSASAddress));
+
+			return DISCOVER_FAILED;
+		}
+	}
+
+	if (foundSubtractive == 0) {
+		return DISCOVER_FINISHED;
+	}
+
+	return DISCOVER_OK;
+}
+
+/*
+ * find the table structure associated with a specific SAS address
+ */
+struct asd_target *asd_find_target(struct list_head *target_list,
+				   uint8_t * SASAddress)
+{
+	struct asd_target *target;
+
+	/*
+	 * walk the list of expanders, when we find the one that matches, stop
+	 */
+	list_for_each_entry(target, target_list, all_domain_targets) {
+		/*
+		 * do the SASAdresses match
+		 */
+		if (SAS_ISEQUAL(target->ddb_profile.sas_addr, SASAddress)) {
+			return target;
+		}
+	}
+	return NULL;
+}
+
+/*
+ * find the table structure associated with a specific target identity.
+ */
+struct asd_target *asd_find_target_ident(struct list_head *target_list,
+					 struct asd_target *check_target)
+{
+	struct asd_target *target;
+
+	/*
+	 * walk the list of expanders, when we find the one that matches, stop
+	 */
+	list_for_each_entry(target, target_list, all_domain_targets) {
+
+		/*
+		 * Make sure we don't match ourselves.
+		 */
+		if (check_target == target) {
+			continue;
+		}
+
+		/*
+		 * It can't possibly be a match if the transport types don't
+		 * match.
+		 */
+		if (check_target->transport_type != target->transport_type) {
+			continue;
+		}
+
+		switch (target->transport_type) {
+		case ASD_TRANSPORT_SSP:
+			if (target->scsi_cmdset.ident_len !=
+			    check_target->scsi_cmdset.ident_len) {
+
+				continue;
+			}
+
+			if ((check_target->scsi_cmdset.ident == NULL) ||
+			    (target->scsi_cmdset.ident == NULL)) {
+				continue;
+			}
+
+			if (memcmp(target->scsi_cmdset.ident,
+				   check_target->scsi_cmdset.ident,
+				   target->scsi_cmdset.ident_len) == 0) {
+
+				return target;
+			}
+			break;
+
+		case ASD_TRANSPORT_STP:
+			if (SAS_ISEQUAL(target->ddb_profile.sas_addr,
+					check_target->ddb_profile.sas_addr)) {
+
+				return target;
+			}
+			break;
+
+		default:
+			continue;
+		}
+
+	}
+
+	return NULL;
+}
+
+struct asd_target *asd_find_multipath(struct asd_softc *asd,
+				      struct asd_target *target)
+{
+	struct asd_port *port;
+	unsigned port_id;
+	struct asd_target *multipath_target;
+
+	/*
+	 * Check to make sure that this same device hasn't been exposed to the
+	 * OS on a different port.
+	 */
+	for (port_id = 0; port_id < asd->hw_profile.max_ports; port_id++) {
+
+		port = asd->port_list[port_id];
+
+		multipath_target = asd_find_target_ident(&port->targets,
+							 target);
+
+		if (multipath_target != NULL) {
+			return multipath_target;
+		}
+	}
+	return NULL;
+}
+
+/*
+ * 
+ * this routine searches the subtractive phys for the upstream expander address
+ *
+ */
+static int
+asd_upstream_expander(struct asd_target *expander,
+		      uint8_t * SASAddress, uint8_t * PhyIdentifier)
+{
+	struct Discover *discover;
+	uint8_t phyCount;
+	int found;
+
+	found = 0;
+
+	/*
+	 * walk through all the phys of this expander, searching for
+	 * subtractive phys return the SASAddress and PhyIdentifier for the
+	 * first subtractive phy encountered, they should all be the same if
+	 * they have anything attached
+	 */
+	for (phyCount = 0; phyCount < expander->num_phys; phyCount++) {
+		/*
+		 * this is just a pointer helper
+		 */
+		discover = &(expander->Phy[phyCount].Result);
+
+		/*
+		 * look for phys with edge or fanout devices attached...
+		 */
+		if ((discover->RoutingAttribute == SUBTRACTIVE) &&
+		    ((discover->AttachedDeviceType == EDGE_EXPANDER_DEVICE) ||
+		     (discover->AttachedDeviceType ==
+		      FANOUT_EXPANDER_DEVICE))) {
+
+			SASCPY(SASAddress, discover->AttachedSASAddress);
+
+			*PhyIdentifier = discover->AttachedPhyIdentifier;
+
+			found = 1;
+
+			break;
+		}
+	}
+	return found;
+}
+
+/*
+ * this routine determines whether a SAS address is directly attached to
+ * an expander
+ */
+static int
+asd_direct_attached(struct asd_target *expander, uint8_t * SASAddress)
+{
+	int direct;
+	uint8_t phyCount;
+
+	direct = 0;
+
+	for (phyCount = 0; phyCount < expander->num_phys; phyCount++) {
+
+		/*
+		 * did we find the address attached locally
+		 */
+		if (*((uint64_t *) SASAddress) ==
+		    *((uint64_t *) expander->Phy[phyCount].
+		      Result.AttachedSASAddress)) {
+
+			direct = 1;
+			break;
+		}
+	}
+	return direct;
+}
+
+/*
+ * this routine determines whether the SAS address, can be optimized out
+ * of the route table.
+ *
+ * expander:	the expander whose route table we are configuring.
+ *
+ * discover:	the response to the discovery request for the device attached
+ *		to the phy of the expander that we are trying to configure
+ *		into "expander's" route table.
+ */
+static int
+asd_qualified_address(struct asd_target *expander,
+		      uint8_t PhyIdentifier,
+		      struct Discover *discover, uint8_t * DisableRouteEntry)
+{
+	int qualified;
+	uint16_t routeIndex;
+	uint8_t *sas_address;
+
+	qualified = 1;
+
+	if (DiscoverAlgorithm != SAS_UNIQUE_LEVEL_DESCENT) {
+		return qualified;
+	}
+
+	/*
+	 * leave in any entries that are direct routing attribute,
+	 * assumes that they are slots that will be filled by end
+	 * devices, if it is not direct, then filter out any empty
+	 * connections, connections that match the expander we are
+	 * configuring and connections that are truly direct attached
+	 */
+	if (!SAS_ISZERO(discover->AttachedSASAddress) &&
+	    !SAS_ISEQUAL(discover->AttachedSASAddress,
+			 expander->ddb_profile.sas_addr) &&
+	    (!asd_direct_attached(expander, discover->AttachedSASAddress))) {
+
+		if (discover->RoutingAttribute == DIRECT) {
+			/*
+			 * if this is a phy that is has a direct
+			 * routing attribute then, have it consume an
+			 * entry, it may be filled in at any time
+			 */
+		} else {
+			for (routeIndex = 0; routeIndex <
+			     expander->num_route_indexes; routeIndex++) {
+
+				sas_address = ROUTE_ENTRY(expander,
+							  PhyIdentifier,
+							  routeIndex);
+
+				if (SAS_ISEQUAL(sas_address,
+						discover->AttachedSASAddress)) {
+
+					qualified = 0;
+
+					break;
+				}
+			}
+		}
+	} else if (SAS_ISZERO(discover->AttachedSASAddress)) {
+		/*
+		 * if a 0 address, then assume it is an
+		 * empty slot that can be filled at any time, 
+		 * this keeps things positionally stable for most
+		 * reasonable topologies
+		 */
+		*DisableRouteEntry = DISABLED;
+	} else {
+		qualified = 0;
+	}
+
+	return qualified;
+}
+
+void
+asd_add_child(struct asd_port *port,
+	      struct asd_target *parent, struct asd_target *child)
+{
+	/*
+	 * Check to make sure that this particular target hasn't already been
+	 * put in the tree, or that it isn't the top of the tree.
+	 */
+	if ((port->tree_root == child) || (child->parent != NULL)) {
+		return;
+	}
+
+	child->parent = parent;
+
+	if (child->parent != NULL) {
+		list_add_tail(&child->siblings, &parent->children);
+	}
+}
+
+#define DUMP_LIST(a)		dump_list(__FUNCTION__, __LINE__, #a, a);
+void
+dump_list(char *function, unsigned line, char *s, struct list_head *target_list)
+{
+	struct asd_target *target;
+
+	printk("%s:%d: dumping list %s\n", function, line, s);
+	/*
+	 * walk the list of expanders, when we find the one that matches, stop
+	 */
+	list_for_each_entry(target, target_list, all_domain_targets) {
+		printk("%s:%d: %llx\n", __FUNCTION__, __LINE__,
+		       *((uint64_t *) target->ddb_profile.sas_addr));
+	}
+
+}
+
+DISCOVER_RESULTS
+asd_configure_device(struct state_machine_context *sm_contextp,
+		     struct asd_target *parentExpander,
+		     struct Discover *discover,
+		     struct list_head *discover_listp,
+		     struct list_head *found_listp,
+		     struct list_head *old_discover_listp, unsigned conn_rate)
+{
+	struct asd_target *target;
+	COMMAND_SET_TYPE command_set_type;
+	DEVICE_PROTOCOL_TYPE device_protocol_type;
+	MANAGEMENT_TYPE management_type;
+	TRANSPORT_TYPE transport_type;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	/* LT: ignore pure initiators, virtual phys are ok */
+	if (!discover->TargetBits) {
+		asd_dprint("Ignoring pure initiators %llx\n",
+			   be64_to_cpu(*(u64 *) discover->AttachedSASAddress));
+		return DISCOVER_OK;
+	}
+
+	switch (conn_rate) {
+	case RATE_UNKNOWN:
+	case PHY_DISABLED:
+	case PHY_FAILED:
+		return DISCOVER_FAILED;
+
+	case SPINUP_HOLD_OOB:
+		printk("found SPINUP_HOLD\n");
+		break;
+	case GBPS_1_5:
+	case GBPS_3_0:
+		/*
+		 * Nothing special to do.
+		 */
+		break;
+	}
+
+	/*
+	 * This routine is only called for end devices.
+	 */
+	ASSERT((discover->TargetBits & SMP_TGT_PORT) == 0);
+
+	if (discover->TargetBits & SSP_TGT_PORT) {
+
+		command_set_type = ASD_COMMAND_SET_SCSI;
+		device_protocol_type = ASD_DEVICE_PROTOCOL_SCSI;
+		transport_type = ASD_TRANSPORT_SSP;
+		management_type = ASD_DEVICE_END;
+
+	} else if (discover->TargetBits & STP_TGT_PORT) {
+		/* 
+		 * We don't know the command set yet (could be ATAPI or ATA)
+		 * We won't know until IDENTIFY / PIDENTIFY.
+		 */
+		command_set_type = ASD_COMMAND_SET_UNKNOWN;
+		device_protocol_type = ASD_DEVICE_PROTOCOL_ATA;
+		transport_type = ASD_TRANSPORT_STP;
+		management_type = ASD_DEVICE_END;
+
+	} else if (discover->TargetBits & SATA_TGT_PORT) {
+		/* 
+		 * We don't know the command set yet (could be ATAPI or ATA)
+		 * We won't know until IDENTIFY / PIDENTIFY.
+		 */
+		/* 
+		 * An "attached SATA host" which is "outside of the
+		 * scope of this standard" 
+		 * T10/1562-D Rev 5 - 10.4.3.5 pg. 340 - 7/9/2003
+		 */
+		command_set_type = ASD_COMMAND_SET_UNKNOWN;
+		device_protocol_type = ASD_DEVICE_PROTOCOL_ATA;
+		transport_type = ASD_TRANSPORT_STP;
+		management_type = ASD_DEVICE_END;
+
+	} else {
+		command_set_type = ASD_COMMAND_SET_UNKNOWN;
+		device_protocol_type = ASD_DEVICE_PROTOCOL_UNKNOWN;
+		transport_type = ASD_TRANSPORT_UNKNOWN;
+		management_type = ASD_DEVICE_UNKNOWN;
+	}
+
+	target = asd_discover_get_target(sm_contextp,
+					 discover->AttachedSASAddress,
+					 old_discover_listp,
+					 found_listp, conn_rate,
+					 transport_type);
+
+	if (target == NULL) {
+
+		printk("couldn't allocate target\n");
+
+		return DISCOVER_FAILED;
+	}
+
+	target->command_set_type = command_set_type;
+	target->device_protocol_type = device_protocol_type;
+	target->management_type = management_type;
+	target->transport_type = transport_type;
+
+	/*
+	 * Add the device to the tree.
+	 */
+	asd_add_child(discover_contextp->port, parentExpander, target);
+
+	list_add_tail(&target->all_domain_targets, discover_listp);
+
+	return DISCOVER_OK;
+}
+
+void
+asd_destroy_discover_list(struct asd_softc *asd,
+			  struct list_head *discover_list)
+{
+	struct asd_target *target;
+	struct asd_target *tmp_target;
+
+	list_for_each_entry_safe(target, tmp_target, discover_list,
+				 all_domain_targets) {
+
+		list_del_init(&target->all_domain_targets);
+
+		asd_free_ddb(asd, target->ddb_profile.conn_handle);
+
+		asd_free_target(asd, target);
+	}
+}
+
+/* -------------------------------------------------------------------------- */
+
+DISCOVER_RESULTS
+asd_issue_discover_request(struct state_machine_context *sm_contextp,
+			   struct asd_target *expander, unsigned phyIndex)
+{
+	DISCOVER_RESULTS results;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	memset(discover_contextp->SMPRequestFrame, 0,
+	       sizeof(struct SMPRequest));
+
+	discover_contextp->SMPRequestFrame->SMPFrameType = SMP_REQUEST_FRAME;
+	discover_contextp->SMPRequestFrame->Function = DISCOVER;
+	discover_contextp->SMPRequestFrame->Request.Discover.PhyIdentifier =
+	    phyIndex;
+
+	/*
+	 * get the discover information for each phy
+	 */
+	results = asd_smp_request(sm_contextp, expander,
+				  sizeof(struct SMPRequestPhyInput),
+				  sizeof(struct SMPResponseDiscover));
+
+	return results;
+}
+
+DISCOVER_RESULTS
+asd_issue_discover_request_post(struct state_machine_context * sm_contextp,
+				struct asd_target * expander, unsigned phyIndex)
+{
+	struct Discover *discover;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	if ((discover_contextp->openStatus != OPEN_ACCEPT) ||
+	    (discover_contextp->SMPResponseFrame->FunctionResult !=
+	     SMP_FUNCTION_ACCEPTED)) {
+
+		/*
+		 * if we had a problem on this  link, then don't 
+		 * bother to  do anything else, production code,
+		 * should be more robust...
+		 */
+		// asd_log(ASD_DBG_ERROR, "\n"
+		printk("discover error, %02Xh at %0llx\n",
+		       discover_contextp->SMPResponseFrame->FunctionResult,
+		       *((uint64_t *) expander->ddb_profile.sas_addr));
+
+		return DISCOVER_FAILED;
+	}
+
+	discover = &(expander->Phy[phyIndex].Result);
+
+	/*
+	 * copy the result into the topology table
+	 */
+	memcpy((void *)&(expander->Phy[phyIndex]),
+	       (void *)&discover_contextp->SMPResponseFrame->Response.Discover,
+	       sizeof(struct SMPResponseDiscover));
+
+	return DISCOVER_OK;
+}
+
+/* -------------------------------------------------------------------------- */
+/*
+ * this function gets the report general and discover information for
+ * a specific expander.  The discover process should begin at the subtractive
+ * boundary and progress downstream.
+ *
+ * If the dest_sas_address is an expander, the expander structure is returned
+ * in retExpander.
+ */
+DISCOVER_RESULTS
+asd_issue_report_general(struct state_machine_context * sm_contextp,
+			 uint8_t * dest_sas_address,
+			 uint8_t conn_rate,
+			 uint8_t attachedDeviceType,
+			 struct list_head * old_discover_listp,
+			 struct list_head * found_listp,
+			 struct asd_target ** retExpander)
+{
+	struct asd_target *expander;
+	DISCOVER_RESULTS results;
+	COMMAND_SET_TYPE command_set_type;
+	DEVICE_PROTOCOL_TYPE device_protocol_type;
+	TRANSPORT_TYPE transport_type;
+	MANAGEMENT_TYPE management_type;
+	struct discover_context *discover_contextp;
+
+	asd_dprint("Sending REPORT GENERAL\n");
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	expander = NULL;
+
+	memset(discover_contextp->SMPRequestFrame, 0,
+	       sizeof(struct SMPRequest));
+
+	discover_contextp->SMPRequestFrame->SMPFrameType = SMP_REQUEST_FRAME;
+	discover_contextp->SMPRequestFrame->Function = REPORT_GENERAL;
+
+	switch (attachedDeviceType) {
+	case EDGE_EXPANDER_DEVICE:
+		command_set_type = ASD_COMMAND_SET_SMP;
+		device_protocol_type = ASD_DEVICE_PROTOCOL_SMP;
+		transport_type = ASD_TRANSPORT_SMP;
+		management_type = ASD_DEVICE_EDGE_EXPANDER;
+		break;
+
+	case FANOUT_EXPANDER_DEVICE:
+		management_type = ASD_DEVICE_FANOUT_EXPANDER;
+		device_protocol_type = ASD_DEVICE_PROTOCOL_SMP;
+		command_set_type = ASD_COMMAND_SET_SMP;
+		transport_type = ASD_TRANSPORT_SMP;
+		break;
+
+	default:
+		/*
+		 * This should never happen.
+		 */
+		return DISCOVER_FAILED;
+	}
+
+	expander = asd_discover_get_target(sm_contextp, dest_sas_address,
+					   old_discover_listp, found_listp,
+					   conn_rate, transport_type);
+
+	/*
+	 * make sure we only do this if the allocation is successful
+	 */
+	if (expander == NULL) {
+		return DISCOVER_FAILED;
+	}
+
+	expander->command_set_type = command_set_type;
+	expander->device_protocol_type = device_protocol_type;
+	expander->transport_type = transport_type;
+	expander->management_type = management_type;
+
+	/*
+	 * get the report general information for the expander
+	 */
+	results = asd_smp_request(sm_contextp, expander,
+				  sizeof(struct SMPRequestGeneralInput),
+				  sizeof(struct SMPResponseReportGeneral));
+
+	*retExpander = expander;
+
+	return results;
+}
+
+DISCOVER_RESULTS
+asd_issue_report_general_post(struct state_machine_context * sm_contextp,
+			      struct asd_target * expander)
+{
+	uint8_t phyCount;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	phyCount = 0;
+
+	asd_dprint("----------\n");
+	asd_dprint("REPORT GENERAL came back\n");
+
+	/*
+	 * the assumptions we made were exceeded, need to bump limits...
+	 */
+	if ((discover_contextp->openStatus != OPEN_ACCEPT) ||
+	    (discover_contextp->SMPResponseFrame->FunctionResult !=
+	     SMP_FUNCTION_ACCEPTED)) {
+		/*
+		 * if we had a problem getting report general for this expander,
+		 * something is wrong, can't go any further down this path...
+		 * production code, should be more robust...
+		 */
+		asd_log(ASD_DBG_ERROR, "\n"
+			"report general error, open %02Xh result %02Xh at "
+			"0x%0llx\n",
+			discover_contextp->openStatus,
+			discover_contextp->SMPResponseFrame->FunctionResult,
+			*((uint64_t *) expander->ddb_profile.sas_addr));
+
+		asd_free_ddb(discover_contextp->asd,
+			     expander->ddb_profile.conn_handle);
+
+		asd_free_target(discover_contextp->asd, expander);
+
+		return DISCOVER_FAILED;
+	}
+
+	if (discover_contextp->SMPResponseFrame->Response.
+	    ReportGeneral.NumberOfPhys > MAXIMUM_EXPANDER_PHYS) {
+
+		asd_log(ASD_DBG_ERROR, "\n"
+			"report general error"
+			", NumberOfPhys %d exceeded limit %d on %0llx\n",
+			discover_contextp->SMPResponseFrame->
+			Response.ReportGeneral.NumberOfPhys,
+			MAXIMUM_EXPANDER_PHYS,
+			*((uint64_t *) expander->ddb_profile.sas_addr));
+
+		asd_free_ddb(discover_contextp->asd,
+			     expander->ddb_profile.conn_handle);
+
+		asd_free_target(discover_contextp->asd, expander);
+
+		return DISCOVER_FAILED;
+	}
+
+	expander->num_phys = discover_contextp->SMPResponseFrame->
+		Response.ReportGeneral.NumberOfPhys;
+
+	expander->num_route_indexes =
+		asd_be16toh(discover_contextp->SMPResponseFrame->Response.
+			ReportGeneral.ExpanderRouteIndexes);
+
+	expander->configurable_route_table =
+		discover_contextp->SMPResponseFrame->Response.ReportGeneral.
+		ConfigurableRouteTable;
+
+	if (expander->Phy != NULL) {
+		asd_free_mem(expander->Phy);
+	}
+
+	expander->Phy = (struct SMPResponseDiscover *)
+	    asd_alloc_mem(sizeof(struct SMPResponseDiscover) *
+			  expander->num_phys, GFP_KERNEL);
+
+	if (expander->Phy == NULL) {
+
+		printk("unable to allocate memory\n");
+
+		asd_free_ddb(discover_contextp->asd,
+			     expander->ddb_profile.conn_handle);
+
+		asd_free_target(discover_contextp->asd, expander);
+
+		return DISCOVER_FAILED;
+	}
+
+	if (expander->num_route_indexes != 0) {
+
+		if (expander->RouteTable != NULL) {
+			asd_free_mem(expander->RouteTable);
+		}
+
+		expander->RouteTable =
+		    (uint8_t *) asd_alloc_mem(SAS_ADDR_LEN *
+					      expander->num_phys *
+					      expander->num_route_indexes,
+					      GFP_KERNEL);
+
+		if (expander->route_indexes != NULL) {
+			asd_free_mem(expander->route_indexes);
+		}
+
+		expander->route_indexes =
+		    asd_alloc_mem(expander->num_route_indexes
+				  * sizeof(uint16_t), GFP_KERNEL);
+
+		memset(expander->route_indexes, 0,
+		       expander->num_route_indexes * sizeof(uint16_t));
+	}
+
+	return DISCOVER_OK;
+}
+
+/* -------------------------------------------------------------------------- */
+
+DISCOVER_RESULTS
+asd_issue_report_manufacturer_info(struct state_machine_context *
+				   sm_contextp, struct asd_target * expander)
+{
+	DISCOVER_RESULTS results;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	memset(discover_contextp->SMPRequestFrame, 0,
+	       sizeof(struct SMPRequest));
+
+	discover_contextp->SMPRequestFrame->SMPFrameType = SMP_REQUEST_FRAME;
+	discover_contextp->SMPRequestFrame->Function =
+	    REPORT_MANUFACTURER_INFORMATION;
+
+	results = asd_smp_request(sm_contextp, expander,
+				  sizeof(struct SMPRequestGeneralInput),
+				  sizeof(struct
+					 SMPResponseReportManufacturerInfo));
+
+	return results;
+}
+
+DISCOVER_RESULTS
+asd_issue_report_manufacturer_info_post(struct state_machine_context *
+					sm_contextp,
+					struct asd_target * expander)
+{
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	/*
+	 * the assumptions we made were exceeded, need to bump limits...
+	 */
+	if ((discover_contextp->openStatus != OPEN_ACCEPT) ||
+	    (discover_contextp->SMPResponseFrame->FunctionResult !=
+	     SMP_FUNCTION_ACCEPTED)) {
+		/*
+		 * if we had a problem getting report general for this expander,
+		 * something is wrong, can't go any further down this path...
+		 * production code, should be more robust...
+		 */
+		asd_log(ASD_DBG_ERROR, "\n"
+			"get manufacturer information error, "
+			"open %02Xh result %02Xh at "
+			"0x%0llx\n",
+			discover_contextp->openStatus,
+			discover_contextp->SMPResponseFrame->FunctionResult,
+			*((uint64_t *) expander->ddb_profile.sas_addr));
+
+		asd_free_ddb(discover_contextp->asd,
+			     expander->ddb_profile.conn_handle);
+
+		asd_free_target(discover_contextp->asd, expander);
+
+		return DISCOVER_FAILED;
+	}
+
+	memcpy(&expander->smp_cmdset.manufacturer_info,
+	       &discover_contextp->SMPResponseFrame->
+	       Response.ReportManufacturerInfo,
+	       sizeof(struct SMPResponseReportManufacturerInfo));
+
+#if 0
+	printk("%8.8s|%16.16s|%4.4s\n",
+	       expander->smp_cmdset.manufacturer_info.VendorIdentification,
+	       expander->smp_cmdset.manufacturer_info.ProductIdentification,
+	       expander->smp_cmdset.manufacturer_info.ProductRevisionLevel);
+#endif
+
+	return DISCOVER_OK;
+}
+
+/* -------------------------------------------------------------------------- */
+
+DISCOVER_RESULTS
+asd_issue_route_config(struct state_machine_context * sm_contextp,
+		       struct asd_target * expander,
+		       unsigned phyIndex,
+		       uint8_t disableRouteEntry, uint8_t * attachedSASAddress)
+{
+	uint16_t index;
+	DISCOVER_RESULTS results;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	index = expander->route_indexes[phyIndex];
+
+	memset(discover_contextp->SMPRequestFrame, 0,
+	       sizeof(struct SMPRequest));
+
+	discover_contextp->SMPRequestFrame->SMPFrameType = SMP_REQUEST_FRAME;
+	discover_contextp->SMPRequestFrame->Function =
+	    CONFIGURE_ROUTE_INFORMATION;
+
+	discover_contextp->SMPRequestFrame->Request.
+	    ConfigureRouteInformation.ExpanderRouteIndex = asd_htobe16(index);
+
+	discover_contextp->SMPRequestFrame->Request.
+	    ConfigureRouteInformation.PhyIdentifier = phyIndex;
+
+	discover_contextp->SMPRequestFrame->Request.
+	    ConfigureRouteInformation.Configure.DisableRouteEntry =
+	    disableRouteEntry;
+
+	SASCPY(discover_contextp->SMPRequestFrame->Request.
+	       ConfigureRouteInformation.Configure.RoutedSASAddress,
+	       attachedSASAddress);
+
+	/*
+	 * configure the route indexes for the
+	 * expander with the attached address
+	 * information
+	 */
+	results = asd_smp_request(sm_contextp, expander,
+				  sizeof(struct
+					 SMPRequestConfigureRouteInformation),
+				  sizeof(struct
+					 SMPResponseConfigureRouteInformation));
+
+	return results;
+}
+
+DISCOVER_RESULTS
+asd_issue_route_config_post(struct state_machine_context * sm_contextp,
+			    struct asd_target * expander, unsigned phyIndex)
+{
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	/*
+	 * the assumptions we made were exceeded, need to bump limits...
+	 */
+	if ((discover_contextp->openStatus != OPEN_ACCEPT) ||
+	    (discover_contextp->SMPResponseFrame->FunctionResult !=
+	     SMP_FUNCTION_ACCEPTED)) {
+		/*
+		 * if we had a problem getting report general for this expander,
+		 * something is wrong, can't go any further down this path...
+		 * production code, should be more robust...
+		 */
+		asd_log(ASD_DBG_ERROR, "\n"
+			"route config error, open %02Xh result %02Xh at "
+			"0x%0llx\n",
+			discover_contextp->openStatus,
+			discover_contextp->SMPResponseFrame->FunctionResult,
+			*((uint64_t *) expander->ddb_profile.sas_addr));
+
+		return DISCOVER_FAILED;
+	}
+
+	return DISCOVER_OK;
+}
+
+/* -------------------------------------------------------------------------- */
+
+DISCOVER_RESULTS
+asd_issue_report_phy_sata(struct state_machine_context * sm_contextp,
+			  struct asd_target * expander, unsigned phyIndex)
+{
+	DISCOVER_RESULTS results;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	memset(discover_contextp->SMPRequestFrame, 0,
+	       sizeof(struct SMPRequest));
+
+	discover_contextp->SMPRequestFrame->SMPFrameType = SMP_REQUEST_FRAME;
+	discover_contextp->SMPRequestFrame->Function = REPORT_PHY_SATA;
+
+	discover_contextp->SMPRequestFrame->Request.
+	    ReportPhySATA.PhyIdentifier = phyIndex;
+
+	results = asd_smp_request(sm_contextp, expander,
+				  sizeof(struct SMPRequestPhyInput),
+				  sizeof(struct SMPResponseReportPhySATA));
+
+	return results;
+}
+
+DISCOVER_RESULTS
+asd_issue_report_phy_sata_post(struct state_machine_context * sm_contextp,
+			       struct asd_target * expander)
+{
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	/*
+	 * the assumptions we made were exceeded, need to bump limits...
+	 */
+	if ((discover_contextp->openStatus != OPEN_ACCEPT) ||
+	    (discover_contextp->SMPResponseFrame->FunctionResult !=
+	     SMP_FUNCTION_ACCEPTED)) {
+		/*
+		 * if we had a problem getting report general for this expander,
+		 * something is wrong, can't go any further down this path...
+		 * production code, should be more robust...
+		 */
+		asd_log(ASD_DBG_ERROR, "\n"
+			"report phy SATA error, open %02Xh result %02Xh at "
+			"0x%0llx\n",
+			discover_contextp->openStatus,
+			discover_contextp->SMPResponseFrame->FunctionResult,
+			*((uint64_t *) expander->ddb_profile.sas_addr));
+
+		return DISCOVER_FAILED;
+	}
+
+	return DISCOVER_OK;
+}
+
+COMMAND_SET_TYPE asd_sata_get_type(struct adp_dev_to_host_fis * fis)
+{
+	if ((fis->sector_count == 1) && (fis->lba0 == 1) &&
+	    (fis->lba1 == 0x14) && (fis->lba2 == 0xeb)) {
+
+		return ASD_COMMAND_SET_ATAPI;
+	}
+
+	return ASD_COMMAND_SET_ATA;
+}
+
+void
+asd_init_sata_direct_attached(struct state_machine_context *sm_contextp,
+			      struct asd_target *target)
+{
+	struct asd_phy *phy;
+	struct adp_dev_to_host_fis *fis;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	phy = list_entry(target->src_port->phys_attached.next,
+			 struct asd_phy, links);
+
+	fis = (struct adp_dev_to_host_fis *)
+	    &phy->bytes_dmaed_rcvd.initial_fis_rcvd.fis[0];
+
+	target->command_set_type = asd_sata_get_type(fis);
+
+	memcpy((void *)&target->device_protocol.
+	       ata_device_protocol.initial_fis[0],
+	       (void *)fis, sizeof(struct adp_dev_to_host_fis));
+
+	target->ddb_profile.sata_status = fis->status;
+
+	asd_hwi_update_sata(discover_contextp->asd, target);
+}
+
+/* -------------------------------------------------------------------------- */
+
+DISCOVER_RESULTS
+asd_issue_phy_control(struct state_machine_context *sm_contextp,
+		      struct asd_target *expander,
+		      unsigned phyIndex, unsigned operation)
+{
+	DISCOVER_RESULTS results;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	memset(discover_contextp->SMPRequestFrame, 0,
+	       sizeof(struct SMPRequest));
+
+	discover_contextp->SMPRequestFrame->SMPFrameType = SMP_REQUEST_FRAME;
+
+	discover_contextp->SMPRequestFrame->Function = PHY_CONTROL;
+
+	discover_contextp->SMPRequestFrame->Request.PhyControl.
+	    PhyIdentifier = phyIndex;
+
+	discover_contextp->SMPRequestFrame->Request.PhyControl.
+	    PhyOperation = operation;
+
+	/*
+	 * get the discover information for each phy
+	 */
+	results = asd_smp_request(sm_contextp, expander,
+				  sizeof(struct SMPRequestPhyControl),
+				  sizeof(struct SMPResponsePhyControl));
+
+	return results;
+}
+
+DISCOVER_RESULTS
+asd_issue_phy_control_post(struct state_machine_context * sm_contextp,
+			   struct asd_target * expander)
+{
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	if ((discover_contextp->openStatus != OPEN_ACCEPT) ||
+	    (discover_contextp->SMPResponseFrame->FunctionResult !=
+	     SMP_FUNCTION_ACCEPTED)) {
+		/*
+		 * if we had a problem on this  link, then don't 
+		 * bother to  do anything else, production code,
+		 * should be more robust...
+		 */
+		asd_log(ASD_DBG_ERROR, "\n"
+			"phy control error, %02Xh at %0llx\n",
+			discover_contextp->SMPResponseFrame->FunctionResult,
+			*((uint64_t *) expander->ddb_profile.sas_addr));
+
+		return DISCOVER_FAILED;
+	}
+
+	return DISCOVER_OK;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Standard inquiry command
+ */
+static uint8_t inquiry_cmd[] = {
+	INQUIRY, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+/*
+ * Device ID
+ */
+static uint8_t inquiry_dev_id_cmd[] = {
+	INQUIRY, 0x01, 0x83, 0x00, 0x00, 0x00
+};
+
+/*
+ * Unit Serial Number
+ */
+static uint8_t inquiry_USN_cmd[] = {
+	INQUIRY, 0x01, 0x80, 0x00, 0x00, 0x00
+};
+
+#define MAX_INQUIRY_LEN(a)	(((a) > 255) ? 255 : (a))
+
+DISCOVER_RESULTS
+asd_issue_inquiry(struct state_machine_context *sm_contextp,
+		  struct asd_target *target,
+		  uint8_t * command, unsigned command_len)
+{
+	struct discover_context *discover_contextp;
+	unsigned xfer_len;
+	DISCOVER_RESULTS results;
+	uint8_t icmd[SCB_EMBEDDED_CDB_SIZE];
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	xfer_len = MAX_INQUIRY_LEN(discover_contextp->sas_info_len);
+
+	memcpy(icmd, command, command_len);
+
+	*((uint16_t *) & icmd[3]) = asd_htobe16(xfer_len);
+
+	asd_hwi_hash(target->ddb_profile.sas_addr, target->ddb_profile.hashed_sas_addr);
+
+	asd_dprint("issuing INQUIRY to %llx\n",
+		be64_to_cpu(*((uint64_t *)target->ddb_profile.sas_addr)));
+	asd_log(ASD_DBG_INFO, "hash addr is 0x%x\n", *(uint32_t *)target->ddb_profile.hashed_sas_addr);
+
+	/* IBM-ESXS/VSC7160 rev 0.07 barfs unless we sleep here a bit.
+	 */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(HZ / 10);
+
+	results = asd_ssp_request(sm_contextp, target, icmd, command_len,
+				  discover_contextp->SASInfoBusAddr, xfer_len,
+				  DATA_DIR_INBOUND);
+
+	return results;
+}
+
+/* -------------------------------------------------------------------------- */
+
+uint8_t report_luns_cmd[] = {
+	REPORT_LUNS, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+DISCOVER_RESULTS
+asd_issue_report_luns(struct state_machine_context * sm_contextp,
+		      struct asd_target * target)
+{
+	struct discover_context *discover_contextp;
+	DISCOVER_RESULTS results;
+	uint8_t rl_cmd[SCB_EMBEDDED_CDB_SIZE];
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	memcpy(rl_cmd, report_luns_cmd, sizeof(report_luns_cmd));
+
+	*((uint32_t *) & rl_cmd[6]) =
+	    asd_htobe32(discover_contextp->sas_info_len);
+
+	results = asd_ssp_request(sm_contextp, target,
+				  rl_cmd, sizeof(report_luns_cmd),
+				  discover_contextp->SASInfoBusAddr,
+				  discover_contextp->sas_info_len,
+				  DATA_DIR_INBOUND);
+
+	return results;
+}
+
+/* -------------------------------------------------------------------------- */
+
+#define CONTROL_MODE_PAGE_SIZE		0x08
+
+uint8_t mode_sense_port_control_cmd[] = {
+	MODE_SENSE, 0x00, 0x19, 0x00, 0x00, 0x00
+};
+
+DISCOVER_RESULTS
+asd_issue_get_port_control(struct state_machine_context * sm_contextp,
+			   struct asd_target * target)
+{
+	struct discover_context *discover_contextp;
+	DISCOVER_RESULTS results;
+	uint8_t pc_cmd[SCB_EMBEDDED_CDB_SIZE];
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	memcpy(pc_cmd, mode_sense_port_control_cmd,
+	       sizeof(mode_sense_port_control_cmd));
+
+	pc_cmd[4] = CONTROL_MODE_PAGE_SIZE;
+
+	results = asd_ssp_request(sm_contextp, target,
+				  pc_cmd, sizeof(mode_sense_port_control_cmd),
+				  discover_contextp->SASInfoBusAddr,
+				  CONTROL_MODE_PAGE_SIZE, DATA_DIR_INBOUND);
+
+	return results;
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_InitSMP_SM_Context {
+	struct list_head *discover_listp;
+	struct asd_target *currentTarget;
+};
+
+ASD_DISCOVERY_STATES
+asd_state_init_smp_start(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSMP_SM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		asd_log(ASD_DBG_INFO, "%s:%d - %llx %d\n",
+			__FUNCTION__, __LINE__,
+			*((uint64_t *) ctx->currentTarget->
+			  ddb_profile.sas_addr),
+			ctx->currentTarget->ddb_profile.conn_rate);
+
+		if (ctx->currentTarget->command_set_type == ASD_COMMAND_SET_SMP) {
+
+			return ASD_STATE_INIT_SMP_REPORT_MANUFACTURER_INFO;
+		}
+	}
+	return ASD_STATE_INIT_SMP_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_state_init_smp_report_manufacturer_info(struct state_machine_context *
+					    sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSMP_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_report_manufacturer_info(sm_contextp,
+						     ctx->currentTarget);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_smp_report_manufacturer_info_post(struct
+						 state_machine_context *
+						 sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSMP_SM_Context *ctx;
+	struct discover_context *discover_contextp;
+	DISCOVER_RESULTS results;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_report_manufacturer_info_post(sm_contextp,
+							  ctx->currentTarget);
+
+	if (results != DISCOVER_OK) {
+		printk("could not get manufactur_info from device\n");
+	}
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if (ctx->currentTarget->command_set_type == ASD_COMMAND_SET_SMP) {
+
+			return ASD_STATE_INIT_SMP_REPORT_MANUFACTURER_INFO;
+		}
+	}
+
+	return ASD_STATE_INIT_SMP_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_InitSMP_SM_Initialize(struct state_machine_context * sm_contextp,
+			  void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_InitSMP_SM_Context *ctx;
+	struct asd_InitSMP_SM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_InitSMP_SM_Arguments *)init_args;
+
+	ctx->discover_listp = args->discover_listp;
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_InitSMP_SM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSMP_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_INIT_SMP_START:
+		new_state = asd_state_init_smp_start(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SMP_REPORT_MANUFACTURER_INFO:
+		new_state =
+		    asd_state_init_smp_report_manufacturer_info_post
+		    (sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_INIT_SMP_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+
+	case ASD_STATE_INIT_SMP_REPORT_MANUFACTURER_INFO:
+		results =
+		    asd_state_init_smp_report_manufacturer_info(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SMP_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_InitSMP_SM_Finish(struct state_machine_context *sm_contextp,
+		      DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_InitSMP_SM_Arguments *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	RETURN_STACK(results);
+}
+
+void asd_InitSMP_SM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSMP_SM_Arguments *ctx;
+	ASD_DISCOVERY_STATES current_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+#if 0
+	switch (current_state) {
+	}
+#endif
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_InitSAS_SM_Context {
+
+	struct list_head *discover_listp;
+	struct asd_target *currentTarget;
+	unsigned phyIndex;
+};
+
+ASD_DISCOVERY_STATES
+asd_state_init_sas_start(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	discover_contextp->retry_count=0;
+
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		asd_log(ASD_DBG_INFO, "%s:%d - %llx %d\n",
+			__FUNCTION__, __LINE__,
+			*((uint64_t *) ctx->currentTarget->
+			  ddb_profile.sas_addr),
+			ctx->currentTarget->ddb_profile.conn_rate);
+
+		if (ctx->currentTarget->command_set_type ==
+		    ASD_COMMAND_SET_SCSI) {
+
+			return ASD_STATE_INIT_SAS_INQUIRY;
+		}
+	}
+	return ASD_STATE_INIT_SAS_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_state_init_sas_inquiry(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_inquiry(sm_contextp, ctx->currentTarget,
+				    inquiry_cmd, sizeof(inquiry_cmd));
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_sas_inquiry_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	unsigned inquiry_response_len;
+	struct discover_context *discover_contextp;
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	if (discover_contextp->openStatus != OPEN_ACCEPT) {
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "Inquiry failed retry_count=0x%x\n",discover_contextp->retry_count);
+#endif
+		if(discover_contextp->retry_count<MAX_SAS_INQUIRY_RETRY)
+		{
+			discover_contextp->retry_count++;
+			return ASD_STATE_INIT_SAS_INQUIRY;
+		}
+		else
+		{
+			ctx->currentTarget->command_set_type = ASD_COMMAND_SET_BAD;
+		}
+
+	} else {
+
+		inquiry_response_len =
+		    MAX_INQUIRY_LEN(discover_contextp->sas_info_len) -
+		    discover_contextp->resid_len;
+
+		ctx->currentTarget->scsi_cmdset.inquiry = (uint8_t *)
+		    asd_alloc_mem(inquiry_response_len, GFP_KERNEL);
+
+		if (ctx->currentTarget->scsi_cmdset.inquiry != NULL) {
+
+			memcpy(ctx->currentTarget->scsi_cmdset.inquiry,
+			       &discover_contextp->SASInfoFrame[0],
+			       inquiry_response_len);
+
+#if 0
+			printk("%8.8s | ",
+			       &ctx->currentTarget->scsi_cmdset.inquiry[8]);
+			printk("%16.16s | ",
+			       &ctx->currentTarget->scsi_cmdset.inquiry[16]);
+			printk("%4.4s\n",
+			       &ctx->currentTarget->scsi_cmdset.inquiry[32]);
+#endif
+		}
+	}
+	discover_contextp->retry_count=0;
+
+	return ASD_STATE_INIT_SAS_GET_DEVICE_ID;
+}
+
+DISCOVER_RESULTS
+asd_state_init_get_device_id(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_inquiry(sm_contextp, ctx->currentTarget,
+				    inquiry_dev_id_cmd,
+				    sizeof(inquiry_dev_id_cmd));
+
+	return results;
+}
+
+#define ASSOCIATION_SCSI_LOGICAL_UNIT		0
+#define ASSOCIATION_SCSI_TARGET_PORT		1
+#define ASSOCIATION_SCSI_TARGET_DEVICE		2
+
+#define PIV_VALID				0x80
+#define VPD_SAS_PROTOCOL			6
+
+ASD_DISCOVERY_STATES
+asd_state_init_get_device_id_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	uint8_t *vpd_page_header;
+	uint8_t *vpd_pagep;
+	unsigned page_length;
+	unsigned identifier_type;
+	unsigned offset;
+	unsigned association;
+	unsigned code_set;
+	unsigned protocol;
+	unsigned length;
+	struct discover_context *discover_contextp;
+	unsigned inquiry_response_len;
+	unsigned piv_valid;
+#if 0
+	unsigned i;
+#endif
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	if (discover_contextp->openStatus != OPEN_ACCEPT) {
+		return ASD_STATE_INIT_SAS_GET_SERIAL_NUMBER;
+	}
+
+	vpd_page_header = &discover_contextp->SASInfoFrame[0];
+
+	inquiry_response_len =
+	    MAX_INQUIRY_LEN(discover_contextp->sas_info_len) -
+	    discover_contextp->resid_len;
+
+	page_length = MIN(asd_be16toh(*((uint16_t *) & vpd_page_header[2])) + 4,
+			  inquiry_response_len);
+
+#if 0
+	for (i = 0; i < page_length; i++) {
+		printk("%02x ", vpd_page_header[i]);
+
+		if (((i + 1) % 16) == 0) {
+			printk("\n");
+		}
+	}
+#endif
+
+	vpd_pagep = &vpd_page_header[4];
+
+	for (offset = vpd_pagep - vpd_page_header; offset < page_length;
+	     vpd_pagep = vpd_pagep + length,
+	     offset = vpd_pagep - vpd_page_header) {
+
+		length = vpd_pagep[3] + 4;
+		if ((offset + length) > page_length) {
+			break;
+		}
+
+		identifier_type = vpd_pagep[1] & 0xf;
+
+#if 0
+		switch (identifier_type & 0xf) {
+		case IDENTIFIER_TYPE_VENDOR_SPECIFIC:
+			printk("IDENTIFIER_TYPE_VENDOR_SPECIFIC\n");
+			break;
+		case IDENTIFIER_TYPE_T10:
+			printk("IDENTIFIER_TYPE_T10\n");
+			break;
+		case IDENTIFIER_TYPE_EIU_64:
+			printk("IDENTIFIER_TYPE_EIU_64\n");
+			break;
+		case IDENTIFIER_TYPE_NAA:
+			printk("IDENTIFIER_TYPE_NAA\n");
+			break;
+		case IDENTIFIER_TYPE_RELATIVE_TARGET_PORT:
+			printk("IDENTIFIER_TYPE_RELATIVE_TARGET_PORT\n");
+			break;
+		case IDENTIFIER_TYPE_TARGET_PORT_GROUP:
+			printk("IDENTIFIER_TYPE_TARGET_PORT_GROUP\n");
+			break;
+		case IDENTIFIER_TYPE_LOGICAL_UNIT_GROUP:
+			printk("IDENTIFIER_TYPE_LOGICAL_UNIT_GROUP\n");
+			break;
+		case IDENTIFIER_TYPE_MD5_LOGICAL_UNIT:
+			printk("IDENTIFIER_TYPE_MD5_LOGICAL_UNIT\n");
+			break;
+		case IDENTIFIER_TYPE_SCSI_NAME_STRING:
+			printk("IDENTIFIER_TYPE_SCSI_NAME_STRING\n");
+			break;
+		default:
+			printk("UNKNOWN\n");
+			break;
+		}
+#endif
+		if ((identifier_type & 0xf) != IDENTIFIER_TYPE_NAA) {
+
+			continue;
+		}
+
+		protocol = (vpd_pagep[0] & 0xf0) >> 4;
+		piv_valid = vpd_pagep[1] & PIV_VALID;
+		code_set = vpd_pagep[0] & 0xf;
+		association = (vpd_pagep[1] & 0x30) >> 4;
+
+#if 0
+		printk("Association %d | ", association);
+		printk("Code Set %d | ", code_set);
+		printk("PIV Valid %d | ", piv_valid);
+		printk("Protocol %d\n", protocol);
+#endif
+
+		ctx->currentTarget->scsi_cmdset.ident_len = length - 4;
+
+		switch (association) {
+		case ASSOCIATION_SCSI_LOGICAL_UNIT:
+			// seagate
+			if (vpd_pagep[1] & PIV_VALID) {
+				continue;
+			}
+			break;
+
+		case ASSOCIATION_SCSI_TARGET_PORT:
+		case ASSOCIATION_SCSI_TARGET_DEVICE:
+			// fujitsu
+			if (((piv_valid & PIV_VALID) != PIV_VALID) ||
+			    (protocol != VPD_SAS_PROTOCOL)) {
+				continue;
+			}
+			break;
+		default:
+			continue;
+
+		}
+
+		ctx->currentTarget->scsi_cmdset.ident = (uint8_t *)
+		    asd_alloc_mem(ctx->currentTarget->scsi_cmdset.ident_len,
+				  GFP_KERNEL);
+
+		if (ctx->currentTarget->scsi_cmdset.ident != NULL) {
+
+			memcpy(ctx->currentTarget->scsi_cmdset.ident,
+			       &vpd_pagep[4],
+			       ctx->currentTarget->scsi_cmdset.ident_len);
+			break;
+		}
+	}
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if (ctx->currentTarget->command_set_type ==
+		    ASD_COMMAND_SET_SCSI) {
+
+			return ASD_STATE_INIT_SAS_INQUIRY;
+		}
+	}
+
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		asd_log(ASD_DBG_INFO, "%s:%d - %llx %d\n",
+			__FUNCTION__, __LINE__,
+			*((uint64_t *) ctx->currentTarget->
+			  ddb_profile.sas_addr),
+			ctx->currentTarget->ddb_profile.conn_rate);
+
+		if (ctx->currentTarget->command_set_type ==
+		    ASD_COMMAND_SET_SCSI) {
+			return ASD_STATE_INIT_SAS_ISSUE_REPORT_LUNS;
+		}
+	}
+	return ASD_STATE_INIT_SAS_FINISHED;
+}
+
+static const char *asd_vpd_warning = "\
+Warning: INQUIRY VPD Page 80h/83h commmand can not finish. This device may\
+not support INQUIRY VPD Page 83h commmand which is required by the SAS \
+spec. In addition, this device may not support the optional INQUIRY VPD \
+Page 80h. Devices that do not support either of these commands may \
+experience file corruption and data loss.  Please upgrade your firmware.";
+
+DISCOVER_RESULTS
+asd_state_init_get_serial_number(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_inquiry(sm_contextp, ctx->currentTarget,
+				    inquiry_USN_cmd, sizeof(inquiry_USN_cmd));
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_get_serial_number_post(struct state_machine_context *
+				      sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	uint8_t *vpd_pagep;
+	unsigned page_length;
+	unsigned i;
+	unsigned serial_number_len;
+	struct discover_context *discover_contextp;
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	if (discover_contextp->openStatus != OPEN_ACCEPT) {
+
+		printk("%s\n", asd_vpd_warning);
+
+#ifdef NO_VPD_WORKAROUND
+		//TODO: free the ident field when the target is destroyed
+
+		ctx->currentTarget->scsi_cmdset.ident_len = sizeof(uint64_t);
+
+		ctx->currentTarget->scsi_cmdset.ident = (uint8_t *)
+		    asd_alloc_mem(sizeof(uint64_t), GFP_KERNEL);
+
+		if (ctx->currentTarget->scsi_cmdset.ident != NULL) {
+
+			*(uint64_t *) ctx->currentTarget->scsi_cmdset.ident =
+			    asd_be64toh(*((uint64_t *) ctx->currentTarget->
+					  ddb_profile.sas_addr)) & ~0xfL;
+
+			printk("Setting ident to %llx\n",
+			       *((uint64_t *) ctx->currentTarget->
+				 scsi_cmdset.ident));
+		}
+#endif
+	} else {
+		vpd_pagep = &discover_contextp->SASInfoFrame[0];
+
+		page_length = vpd_pagep[3];
+
+		for (i = 0; i < (page_length + 3); i++) {
+			printk("%02x ", vpd_pagep[i]);
+
+			if (((i + 1) % 16) == 0) {
+				printk("\n");
+			}
+		}
+
+		serial_number_len = discover_contextp->SASInfoFrame[3];
+
+		if (serial_number_len > discover_contextp->sas_info_len) {
+			serial_number_len = discover_contextp->sas_info_len;
+		}
+
+		ctx->currentTarget->scsi_cmdset.ident_len = serial_number_len;
+
+		ctx->currentTarget->scsi_cmdset.ident = (uint8_t *)
+		    asd_alloc_mem(ctx->currentTarget->scsi_cmdset.ident_len,
+				  GFP_KERNEL);
+
+		if (ctx->currentTarget->scsi_cmdset.ident != NULL) {
+			memcpy(ctx->currentTarget->scsi_cmdset.ident,
+			       &discover_contextp->SASInfoFrame[4],
+			       ctx->currentTarget->scsi_cmdset.ident_len);
+		}
+
+		printk("serial number is %s\n",
+		       ctx->currentTarget->scsi_cmdset.ident);
+	}
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if (ctx->currentTarget->command_set_type ==
+		    ASD_COMMAND_SET_SCSI) {
+
+			return ASD_STATE_INIT_SAS_INQUIRY;
+		}
+	}
+
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		asd_log(ASD_DBG_INFO, "%s:%d - %llx %d\n",
+			__FUNCTION__, __LINE__,
+			*((uint64_t *) ctx->currentTarget->
+			  ddb_profile.sas_addr),
+			ctx->currentTarget->ddb_profile.conn_rate);
+
+		if (ctx->currentTarget->command_set_type ==
+		    ASD_COMMAND_SET_SCSI) {
+
+			return ASD_STATE_INIT_SAS_ISSUE_REPORT_LUNS;
+		}
+	}
+
+	return ASD_STATE_INIT_SAS_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_state_init_sas_issue_report_luns(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+	if(ctx->currentTarget->command_set_type == ASD_COMMAND_SET_SCSI)
+	{
+		u8 *inquiry;
+		inquiry = ctx->currentTarget->scsi_cmdset.inquiry;
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "ctx->currentTarget->ddb_profile.sas_addr=%llx, ctx->currentTarget->transport_type=0x%x, ctx->currentTarget->command_set_type 0x%x\n",
+		*((uint64_t *) ctx->currentTarget->ddb_profile.sas_addr),
+		ctx->currentTarget->transport_type,
+		ctx->currentTarget->command_set_type);
+#endif
+
+		if (inquiry != NULL) 
+		{
+#ifdef ASD_DEBUG
+			asd_log(ASD_DBG_INFO, "inquiry[0]=0x%x\n", inquiry[0]);
+#endif
+			if( ((inquiry[0] & 0xe0) == 0x60)||((inquiry[0] & 0x1f) == TYPE_ENCLOSURE) )
+			{
+				struct discover_context *discover_contextp;
+				discover_contextp = (struct discover_context *) sm_contextp->state_handle;
+				discover_contextp->openStatus = OPEN_REJECT_BAD_DESTINATION;
+				sm_contextp->wakeup_state_machine(sm_contextp);
+
+				return DISCOVER_OK;
+			}
+		}
+	}
+	results = asd_issue_report_luns(sm_contextp, ctx->currentTarget);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_sas_issue_report_lun_post(struct state_machine_context *
+					 sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	unsigned i;
+	unsigned num_luns;
+	uint64_t *ReportLunsFrame;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	if (discover_contextp->openStatus != OPEN_ACCEPT) {
+
+		ctx->currentTarget->scsi_cmdset.num_luns = 1;
+
+		ctx->currentTarget->scsi_cmdset.luns = (uint64_t *)
+		    asd_alloc_mem(sizeof(uint64_t), GFP_KERNEL);
+
+		memset(&ctx->currentTarget->scsi_cmdset.luns[0], 0,
+		       sizeof(uint64_t));
+
+		asd_dprint(KERN_NOTICE "adp94xx: REPORT LUNS failed\n");
+
+		/*
+		 * Report LUNS failed.
+		 */
+	} else {
+		ReportLunsFrame = (uint64_t *) discover_contextp->SASInfoFrame;
+
+		num_luns = asd_be32toh(ReportLunsFrame[0]) / sizeof(uint64_t);
+
+		if (num_luns > ASD_MAX_LUNS) {
+			num_luns = ASD_MAX_LUNS;
+		}
+		// printk("%s: found %d luns\n", __FUNCTION__, num_luns);
+
+		ctx->currentTarget->scsi_cmdset.num_luns = num_luns;
+
+		ctx->currentTarget->scsi_cmdset.luns = (uint64_t *)
+		    asd_alloc_mem(sizeof(uint64_t) * num_luns, GFP_KERNEL);
+
+		if (ctx->currentTarget->scsi_cmdset.luns != NULL) {
+			for (i = 0; i < num_luns; i++) {
+				/*
+				 * The SASInfoFrame includes the length
+				 * of the list as the first element.
+				 */
+				ctx->currentTarget->scsi_cmdset.luns[i] =
+				    asd_be64toh(ReportLunsFrame[i + 1]);
+			}
+		} else {
+			ctx->currentTarget->scsi_cmdset.num_luns = 0;
+		}
+	}
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if (ctx->currentTarget->command_set_type ==
+		    ASD_COMMAND_SET_SCSI) {
+
+			return ASD_STATE_INIT_SAS_ISSUE_REPORT_LUNS;
+		}
+	}
+
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		asd_log(ASD_DBG_INFO, "%s:%d - %llx %d\n",
+			__FUNCTION__, __LINE__,
+			*((uint64_t *) ctx->currentTarget->
+			  ddb_profile.sas_addr),
+			ctx->currentTarget->ddb_profile.conn_rate);
+
+		if (ctx->currentTarget->command_set_type ==
+		    ASD_COMMAND_SET_SCSI) {
+
+			return ASD_STATE_INIT_SAS_GET_PORT_CONTROL;
+		}
+	}
+
+	return ASD_STATE_INIT_SAS_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_state_init_sas_get_port_control(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_get_port_control(sm_contextp, ctx->currentTarget);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_sas_get_port_control_post(struct state_machine_context *
+					 sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	uint8_t *port_control_page;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	if (discover_contextp->openStatus != OPEN_ACCEPT) {
+
+		//printk("Port Control failed\n");
+		/*
+		 * Report LUNS failed.
+		 */
+	} else {
+		port_control_page = (uint8_t *) discover_contextp->SASInfoFrame;
+
+#if 0
+		printk("page = 0x%x length = 0x%x protocol = 0x%x\n",
+		       port_control_page[0],
+		       port_control_page[1], port_control_page[2]);
+
+		printk("I_T Nexus Loss Time = %d\n",
+		       asd_be16toh(*((uint16_t *) & port_control_page[4])));
+#endif
+	}
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if (ctx->currentTarget->command_set_type ==
+		    ASD_COMMAND_SET_SCSI) {
+
+			return ASD_STATE_INIT_SAS_GET_PORT_CONTROL;
+		}
+	}
+
+	return ASD_STATE_INIT_SAS_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_InitSAS_SM_Initialize(struct state_machine_context * sm_contextp,
+			  void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	struct asd_InitSAS_SM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_InitSAS_SM_Arguments *)init_args;
+
+	/*
+	 * go through the configure cycle progressively
+	 * ascending to each expander starting at "newExpander"
+	 */
+	ctx->discover_listp = args->discover_listp;
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_InitSAS_SM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_INIT_SAS_START:
+		new_state = asd_state_init_sas_start(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_INQUIRY:
+		new_state = asd_state_init_sas_inquiry_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_DEVICE_ID:
+		new_state = asd_state_init_get_device_id_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_SERIAL_NUMBER:
+		new_state = asd_state_init_get_serial_number_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_ISSUE_REPORT_LUNS:
+		new_state =
+		    asd_state_init_sas_issue_report_lun_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_PORT_CONTROL:
+		new_state =
+		    asd_state_init_sas_get_port_control_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_INIT_SAS_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+
+	case ASD_STATE_INIT_SAS_INQUIRY:
+		results = asd_state_init_sas_inquiry(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_DEVICE_ID:
+		results = asd_state_init_get_device_id(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_SERIAL_NUMBER:
+		results = asd_state_init_get_serial_number(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_ISSUE_REPORT_LUNS:
+		results = asd_state_init_sas_issue_report_luns(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_GET_PORT_CONTROL:
+		results = asd_state_init_sas_get_port_control(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_InitSAS_SM_Finish(struct state_machine_context *sm_contextp,
+		      DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Arguments *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	RETURN_STACK(results);
+}
+
+void asd_InitSAS_SM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSAS_SM_Arguments *ctx;
+	ASD_DISCOVERY_STATES current_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+#if 0
+	switch (current_state) {
+	}
+#endif
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_SATA_SpinHoldSM_Context {
+	struct discover_context *discover_contextp;
+	struct list_head *discover_listp;
+	struct asd_target *currentTarget;
+	unsigned phyIndex;
+};
+
+ASD_DISCOVERY_STATES
+asd_state_sata_spinhold_start(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		asd_log(ASD_DBG_INFO, "%s:%d - %llx %d\n",
+			__FUNCTION__, __LINE__,
+			*((uint64_t *) ctx->currentTarget->
+			  ddb_profile.sas_addr),
+			ctx->currentTarget->ddb_profile.conn_rate);
+
+		if ((ctx->currentTarget->transport_type ==
+		     ASD_TRANSPORT_STP) &&
+		    (ctx->currentTarget->ddb_profile.conn_rate ==
+		     SPINUP_HOLD_OOB)) {
+
+			return ASD_STATE_SATA_SPINHOLD_PHY_CONTROL;
+		}
+	}
+	return ASD_STATE_SATA_SPINHOLD_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_sata_spinhold_get_next_target(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if ((ctx->currentTarget->transport_type ==
+		     ASD_TRANSPORT_STP) &&
+		    (ctx->currentTarget->ddb_profile.conn_rate ==
+		     SPINUP_HOLD_OOB)) {
+
+			return DISCOVER_OK;
+		}
+	}
+
+	return DISCOVER_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_state_sata_spinhold_phy_control(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_target *parent;
+	unsigned i;
+	struct Discover *discover;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	parent = ctx->currentTarget->parent;
+
+	/*
+	 * Find the phy number of this device in the parent.
+	 */
+	for (i = 0; i < parent->num_phys; i++) {
+
+		discover = &(parent->Phy[i].Result);
+
+		if (SAS_ISEQUAL(ctx->currentTarget->ddb_profile.sas_addr,
+				discover->AttachedSASAddress)) {
+
+			break;
+		}
+	}
+
+	if (i == parent->num_phys) {
+
+		results = asd_sata_spinhold_get_next_target(sm_contextp);
+
+		return results;
+	}
+
+	results = asd_issue_phy_control(sm_contextp, parent, i, LINK_RESET);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_sata_spinhold_phy_control_post(struct state_machine_context *
+					 sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_target *parent;
+	struct Discover *discover;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_phy_control_post(sm_contextp,
+					     ctx->currentTarget->parent);
+
+	if (results != DISCOVER_OK) {
+
+		results = asd_sata_spinhold_get_next_target(sm_contextp);
+
+		if (results != DISCOVER_FINISHED) {
+			return ASD_STATE_SATA_SPINHOLD_PHY_CONTROL;
+		}
+
+		return ASD_STATE_SATA_SPINHOLD_FINISHED;
+	}
+
+	parent = ctx->currentTarget->parent;
+
+	/*
+	 * Find the phy number of the first matching device in the parent.
+	 */
+	for (ctx->phyIndex = 0; ctx->phyIndex < parent->num_phys;
+	     ctx->phyIndex++) {
+
+		discover = &(parent->Phy[ctx->phyIndex].Result);
+
+		if (SAS_ISEQUAL(ctx->currentTarget->ddb_profile.sas_addr,
+				discover->AttachedSASAddress)) {
+
+			return ASD_STATE_SATA_SPINHOLD_DISCOVER;
+		}
+	}
+
+	printk("Didn't find target!\n");
+
+	results = asd_sata_spinhold_get_next_target(sm_contextp);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_SATA_SPINHOLD_PHY_CONTROL;
+	}
+
+	return ASD_STATE_SATA_SPINHOLD_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_state_sata_spinhold_discover(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_target *parent;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	parent = ctx->currentTarget->parent;
+
+	results = asd_issue_discover_request(sm_contextp,
+					     parent, ctx->phyIndex);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_sata_spinhold_discover_post(struct state_machine_context *
+				      sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_target *parent;
+	struct Discover *discover;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	parent = ctx->currentTarget->parent;
+
+	results = asd_issue_discover_request_post(sm_contextp,
+						  parent, ctx->phyIndex);
+
+	if (results != DISCOVER_OK) {
+		printk("discover request failed\n");
+	}
+
+	parent = ctx->currentTarget->parent;
+
+	discover = &(parent->Phy[ctx->phyIndex].Result);
+
+	ctx->currentTarget->ddb_profile.conn_rate =
+	    discover->NegotiatedPhysicalLinkRate;
+
+	asd_hwi_setup_ddb_site(discover_contextp->asd, ctx->currentTarget);
+	ctx->phyIndex++;
+
+	/*
+	 * Find the phy number of this device in the parent.
+	 */
+	for (; ctx->phyIndex < parent->num_phys; ctx->phyIndex++) {
+
+		discover = &(parent->Phy[ctx->phyIndex].Result);
+
+		if (SAS_ISEQUAL(ctx->currentTarget->ddb_profile.sas_addr,
+				discover->AttachedSASAddress)) {
+
+			return ASD_STATE_SATA_SPINHOLD_DISCOVER;
+		}
+	}
+
+	results = asd_sata_spinhold_get_next_target(sm_contextp);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_SATA_SPINHOLD_PHY_CONTROL;
+	}
+
+	return ASD_STATE_SATA_SPINHOLD_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_SATA_SpinHoldSM_Initialize(struct state_machine_context * sm_contextp,
+			       void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Context *ctx;
+	struct asd_SATA_SpinHoldSM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_SATA_SpinHoldSM_Arguments *)init_args;
+
+	/*
+	 * go through the configure cycle progressively
+	 * ascending to each expander starting at "newExpander"
+	 */
+	ctx->discover_listp = args->discover_listp;
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_SATA_SpinHoldSM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_SATA_SPINHOLD_START:
+		new_state = asd_state_sata_spinhold_start(sm_contextp);
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_PHY_CONTROL:
+		new_state =
+		    asd_state_sata_spinhold_phy_control_post(sm_contextp);
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_DISCOVER:
+		new_state = asd_state_sata_spinhold_discover_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_SATA_SPINHOLD_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+	case ASD_STATE_SATA_SPINHOLD_PHY_CONTROL:
+		results = asd_state_sata_spinhold_phy_control(sm_contextp);
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_DISCOVER:
+		results = asd_state_sata_spinhold_discover(sm_contextp);
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_SATA_SpinHoldSM_Finish(struct state_machine_context *sm_contextp,
+			   DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Arguments *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	RETURN_STACK(results);
+}
+
+void asd_SATA_SpinHoldSM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_SATA_SpinHoldSM_Arguments *ctx;
+	ASD_DISCOVERY_STATES current_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_SATA_SPINHOLD_PHY_CONTROL:
+		/*
+		 * TODO: we need to abort the outstanding Phy Control request.
+		 */
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD_DISCOVER:
+		/*
+		 * TODO: we need to abort the outstanding Discover request.
+		 */
+		break;
+	default:
+		break;
+	}
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_ConfigureATA_SM_Context {
+	struct asd_target *target;
+	uint8_t next_feature;
+	uint8_t sector_count;
+};
+
+ASD_DISCOVERY_STATES
+asd_state_configure_ata_start(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureATA_SM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	ctx->next_feature = asd_get_feature_to_enable(ctx->target,
+						      &ctx->sector_count);
+
+	if (ctx->next_feature == 0) {
+		return ASD_STATE_CONFIGURE_ATA_FINISHED;
+	}
+
+	if (ctx->target->transport_type != ASD_TRANSPORT_ATA) {
+		return ASD_STATE_CONFIGURE_ATA_FINISHED;
+	}
+
+	return ASD_STATE_CONFIGURE_ATA_FEATURES;
+}
+
+DISCOVER_RESULTS
+asd_state_configure_ata_features(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureATA_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_sata_configure_features(sm_contextp, ctx->target,
+					      ctx->next_feature,
+					      ctx->sector_count);
+
+	return results;
+}
+
+uint8_t
+asd_get_feature_to_enable(struct asd_target * target, uint8_t * sector_count)
+{
+	unsigned features_enabled;
+	unsigned features_state;
+	unsigned *dma_mode_level;
+
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_ATA:
+		features_enabled = target->ata_cmdset.features_enabled;
+		features_state = target->ata_cmdset.features_state;
+		dma_mode_level = &target->ata_cmdset.dma_mode_level;
+		break;
+
+	case ASD_COMMAND_SET_ATAPI:
+		features_enabled = target->atapi_cmdset.features_enabled;
+		features_state = target->ata_cmdset.features_state;
+		dma_mode_level = &target->atapi_cmdset.dma_mode_level;
+		break;
+
+	default:
+		return 0;
+	}
+
+	*sector_count = 0;
+
+	if (features_enabled & WRITE_CACHE_FEATURE_ENABLED) {
+		if ((features_state & SATA_USES_WRITE_CACHE) == 0) {
+			return SETFEATURES_EN_WCACHE;
+		}
+	} else {
+		if (features_state & SATA_USES_WRITE_CACHE) {
+			return SETFEATURES_DIS_WCACHE;
+		}
+	}
+
+	if (features_enabled & READ_AHEAD_FEATURE_ENABLED) {
+		if ((features_state & SATA_USES_READ_AHEAD) == 0) {
+			return SETFEATURES_EN_RLA;
+		}
+	} else {
+		if (features_state & SATA_USES_READ_AHEAD) {
+			return SETFEATURES_DIS_RLA;
+		}
+	}
+
+ 	if (features_state & SATA_USES_UDMA) {
+		if (features_enabled & NEEDS_XFER_SETFEATURES) {
+			*sector_count = *dma_mode_level;
+
+			return SETFEATURES_XFER;
+		}
+	}
+
+	return 0;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_configure_ata_features_post(struct state_machine_context *
+				      sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureATA_SM_Context *ctx;
+	unsigned *features_state;
+	struct discover_context *discover_contextp;
+	unsigned *features_enabled;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	if (discover_contextp->openStatus != OPEN_ACCEPT) {
+
+		printk("configure failed\n");
+
+		//TODO: we can't give up, but we need to notify the user
+
+	} else {
+		switch (ctx->target->command_set_type) {
+		case ASD_COMMAND_SET_ATA:
+			features_state =
+			    &ctx->target->ata_cmdset.features_state;
+			features_enabled =
+			    &ctx->target->ata_cmdset.features_enabled;
+			break;
+
+		case ASD_COMMAND_SET_ATAPI:
+			features_state =
+			    &ctx->target->ata_cmdset.features_state;
+			features_enabled =
+			    &ctx->target->ata_cmdset.features_enabled;
+			break;
+
+		default:
+			return ASD_STATE_CONFIGURE_ATA_FINISHED;
+		}
+
+		switch (ctx->next_feature) {
+		case SETFEATURES_EN_WCACHE:
+			*features_state |= SATA_USES_WRITE_CACHE;
+			break;
+
+		case SETFEATURES_EN_RLA:
+			*features_state |= SATA_USES_READ_AHEAD;
+			break;
+
+		case SETFEATURES_DIS_WCACHE:
+			*features_state &= ~SATA_USES_WRITE_CACHE;
+			break;
+
+		case SETFEATURES_DIS_RLA:
+			*features_state &= ~SATA_USES_READ_AHEAD;
+			break;
+
+		case SETFEATURES_XFER:
+ 			*features_enabled &= ~NEEDS_XFER_SETFEATURES;
+			break;
+		}
+	}
+
+	ctx->next_feature = asd_get_feature_to_enable(ctx->target,
+						      &ctx->sector_count);
+
+	if (ctx->next_feature != 0) {
+		return ASD_STATE_CONFIGURE_ATA_FEATURES;
+	}
+
+	return ASD_STATE_CONFIGURE_ATA_FINISHED;
+}
+
+/*
+ * The ConfigureATA state machine operates on a signle target so that it can
+ * be performed on an individual device to reconfigure that device after reset.
+ *
+ * This state machine does not need a discovery context (discover_contextp).
+ */
+DISCOVER_RESULTS
+asd_ConfigureATA_SM_Initialize(struct state_machine_context * sm_contextp,
+			       void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureATA_SM_Context *ctx;
+	struct asd_ConfigureATA_SM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_ConfigureATA_SM_Arguments *)init_args;
+
+	ctx->target = args->target;
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_ConfigureATA_SM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureATA_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_CONFIGURE_ATA_START:
+		new_state = asd_state_configure_ata_start(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIGURE_ATA_FEATURES:
+		new_state = asd_state_configure_ata_features_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_CONFIGURE_ATA_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+	case ASD_STATE_CONFIGURE_ATA_FEATURES:
+		results = asd_state_configure_ata_features(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIGURE_ATA_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_ConfigureATA_SM_Finish(struct state_machine_context *sm_contextp,
+			   DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureATA_SM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	RETURN_STACK(results);
+}
+
+void asd_ConfigureATA_SM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureATA_SM_Context *ctx;
+	ASD_DISCOVERY_STATES current_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_CONFIGURE_ATA_FEATURES:
+		break;
+
+	default:
+		break;
+	}
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_InitSATA_SM_Context {
+	struct discover_context *discover_contextp;
+	struct list_head *discover_listp;
+	struct asd_target *currentTarget;
+};
+
+ASD_DISCOVERY_STATES
+asd_state_init_sata_start(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	/*
+	 * Are there any devices that need a report phy?
+	 */
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		if (ctx->currentTarget->transport_type == ASD_TRANSPORT_STP) {
+
+			return ASD_STATE_INIT_SATA_REPORT_PHY;
+
+		} else if (ctx->currentTarget->transport_type ==
+			   ASD_TRANSPORT_ATA) {
+
+			asd_init_sata_direct_attached(sm_contextp,
+						      ctx->currentTarget);
+
+			continue;
+		}
+	}
+
+	/*
+	 * If not, are there any devices that need a SATA identify or configure
+	 * features?
+	 */
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		if (ctx->currentTarget->device_protocol_type ==
+		    ASD_DEVICE_PROTOCOL_ATA) {
+
+			return ASD_STATE_INIT_SATA_IDENTIFY;
+		}
+	}
+
+	return ASD_STATE_INIT_SATA_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_state_init_sata_report_phy(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_target *parent;
+	unsigned i;
+	struct Discover *discover;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	parent = ctx->currentTarget->parent;
+
+	for (i = 0; i < parent->num_phys; i++) {
+
+		discover = &(parent->Phy[i].Result);
+
+		if (SAS_ISEQUAL(ctx->currentTarget->ddb_profile.sas_addr,
+				discover->AttachedSASAddress)) {
+
+			break;
+		}
+	}
+
+	if (i == parent->num_phys) {
+
+		results = DISCOVER_FAILED;
+
+		return results;
+	}
+
+	results = asd_issue_report_phy_sata(sm_contextp, parent, i);
+
+	return results;
+}
+
+#define NUM_FIS_DWORDS \
+		(sizeof(struct adp_dev_to_host_fis) / sizeof(unsigned))
+
+ASD_DISCOVERY_STATES
+asd_init_sata_report_phy_next_target(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if (ctx->currentTarget->transport_type == ASD_TRANSPORT_STP) {
+
+			return ASD_STATE_INIT_SATA_REPORT_PHY;
+
+		} else if (ctx->currentTarget->transport_type ==
+			   ASD_TRANSPORT_ATA) {
+
+			asd_init_sata_direct_attached(sm_contextp,
+						      ctx->currentTarget);
+		}
+	}
+
+	/*
+	 * If there are no more STP devices to phy control, check to see if
+	 * there are any devices that need IDENTIFY / PIDENTIFY.
+	 */
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		if (ctx->currentTarget->device_protocol_type ==
+		    ASD_DEVICE_PROTOCOL_ATA) {
+
+			return ASD_STATE_INIT_SATA_IDENTIFY;
+		}
+	}
+
+	return ASD_STATE_INIT_SATA_FINISHED;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_sata_report_phy_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+	unsigned i;
+	struct adp_dev_to_host_fis *fis;
+	ASD_DISCOVERY_STATES new_state;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	results = asd_issue_report_phy_sata_post(sm_contextp,
+						 ctx->currentTarget->parent);
+
+	if (results != DISCOVER_OK) {
+
+		new_state = asd_init_sata_report_phy_next_target(sm_contextp);
+
+		return new_state;
+	}
+
+	fis = (struct adp_dev_to_host_fis *)&discover_contextp->
+	    SMPResponseFrame->Response.ReportPhySATA.FIS;
+
+	if (fis->error == FIS_DEVICE_TO_HOST) {
+
+		for (i = 0; i < NUM_FIS_DWORDS; i++) {
+
+			*((unsigned *)fis + i) =
+			    asd_htobe32(*((unsigned *)fis + i));
+		}
+	}
+
+	ctx->currentTarget->command_set_type = asd_sata_get_type(fis);
+
+	memcpy((void *)&ctx->currentTarget->
+	       device_protocol.ata_device_protocol.initial_fis[0],
+	       (void *)fis, sizeof(struct adp_dev_to_host_fis));
+
+	ctx->currentTarget->ddb_profile.sata_status = fis->status;
+
+	asd_hwi_update_sata(discover_contextp->asd, ctx->currentTarget);
+
+	new_state = asd_init_sata_report_phy_next_target(sm_contextp);
+
+	return new_state;
+}
+
+DISCOVER_RESULTS
+asd_state_init_sata_identify(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_sata_identify_request(sm_contextp, ctx->currentTarget);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_init_sata_identify_next_target(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if (ctx->currentTarget->device_protocol_type ==
+		    ASD_DEVICE_PROTOCOL_ATA) {
+
+			return ASD_STATE_INIT_SATA_IDENTIFY;
+		}
+	}
+
+	/*
+	 * If there are no more ATA devices to identify, then check to see
+	 * if any device need to be configured.
+	 */
+	list_for_each_entry(ctx->currentTarget, ctx->discover_listp,
+			    all_domain_targets) {
+
+		if (ctx->currentTarget->device_protocol_type ==
+		    ASD_DEVICE_PROTOCOL_ATA) {
+
+			return ASD_STATE_INIT_SATA_CONFIGURE_FEATURES;
+		}
+	}
+
+	return ASD_STATE_INIT_SATA_FINISHED;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_sata_identify_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	ASD_DISCOVERY_STATES new_state;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	if (discover_contextp->openStatus != OPEN_ACCEPT) {
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "Identify failed retry_count=0x%x\n",discover_contextp->retry_count);
+#endif
+		if(discover_contextp->retry_count<MAX_SAS_INQUIRY_RETRY)
+		{
+			discover_contextp->retry_count++;
+			return ASD_STATE_INIT_SATA_IDENTIFY;
+		}
+		else
+		{
+			ctx->currentTarget->command_set_type = ASD_COMMAND_SET_BAD;
+		}
+		//TODO: we can't give up, but we need to notify the user
+	} else {
+		/*
+		 * Pre-compute the features that this drive supports so
+		 * that we don't have to hunt them down in the hd_driveid
+		 * structure.
+		 */
+		asd_sata_compute_support(discover_contextp->asd,
+					 ctx->currentTarget);
+	}
+
+	new_state = asd_init_sata_identify_next_target(sm_contextp);
+
+	return new_state;
+}
+
+DISCOVER_RESULTS
+asd_state_init_sata_configure_features(struct state_machine_context *
+				       sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_ConfigureATA_SM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.target = ctx->currentTarget;
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "ctx->currentTarget->ddb_profile.sas_addr=%llx, ctx->currentTarget->transport_type=0x%x, ctx->currentTarget->command_set_type 0x%x\n",
+		*((uint64_t *) ctx->currentTarget->ddb_profile.sas_addr),
+		ctx->currentTarget->transport_type,
+		ctx->currentTarget->command_set_type);
+#endif
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp,
+					 &asd_ConfigureATA_SM, (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_init_sata_configure_features_next_target(struct state_machine_context *
+					     sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	while (ctx->currentTarget->all_domain_targets.next
+	       != ctx->discover_listp) {
+
+		ctx->currentTarget =
+		    list_entry(ctx->currentTarget->all_domain_targets.next,
+			       struct asd_target, all_domain_targets);
+
+		if (ctx->currentTarget->device_protocol_type ==
+		    ASD_DEVICE_PROTOCOL_ATA) {
+
+			return ASD_STATE_INIT_SATA_CONFIGURE_FEATURES;
+		}
+	}
+
+	return ASD_STATE_INIT_SATA_FINISHED;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_sata_configure_features_post(struct state_machine_context *
+					    sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	ASD_DISCOVERY_STATES new_state;
+	struct discover_context *discover_contextp;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	if (discover_contextp->openStatus != OPEN_ACCEPT) {
+
+		printk("configure failed\n");
+
+		//TODO: we can't give up, but we need to notify the user
+	}
+
+	new_state = asd_init_sata_configure_features_next_target(sm_contextp);
+
+	return new_state;
+}
+
+DISCOVER_RESULTS
+asd_InitSATA_SM_Initialize(struct state_machine_context * sm_contextp,
+			   void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	struct asd_InitSATA_SM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_InitSATA_SM_Arguments *)init_args;
+
+	/*
+	 * go through the configure cycle progressively
+	 * ascending to each expander starting at "newExpander"
+	 */
+	ctx->discover_listp = args->discover_listp;
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_InitSATA_SM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_INIT_SATA_START:
+		new_state = asd_state_init_sata_start(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SATA_REPORT_PHY:
+		new_state = asd_state_init_sata_report_phy_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SATA_IDENTIFY:
+		new_state = asd_state_init_sata_identify_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SATA_CONFIGURE_FEATURES:
+		new_state =
+		    asd_state_init_sata_configure_features_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_INIT_SATA_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+	case ASD_STATE_INIT_SATA_REPORT_PHY:
+		results = asd_state_init_sata_report_phy(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SATA_IDENTIFY:
+		results = asd_state_init_sata_identify(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SATA_CONFIGURE_FEATURES:
+		results = asd_state_init_sata_configure_features(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SATA_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_InitSATA_SM_Finish(struct state_machine_context *sm_contextp,
+		       DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	struct discover_context *discover_contextp;
+	struct asd_phy *phy;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	if (results == DISCOVER_FAILED) {
+		phy = list_entry(discover_contextp->port->phys_attached.next,
+				 struct asd_phy, links);
+
+		printk("Phy%d: %s - discovery error\n", phy->id, __FUNCTION__);
+	}
+
+	RETURN_STACK(results);
+}
+
+void asd_InitSATA_SM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_InitSATA_SM_Context *ctx;
+	ASD_DISCOVERY_STATES current_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_INIT_SATA_REPORT_PHY:
+		/*
+		 * TODO: Abort Report Phy request.
+		 */
+		break;
+
+	case ASD_STATE_INIT_SATA_IDENTIFY:
+		/*
+		 * TODO: Abort Identify request.
+		 */
+		break;
+
+	default:
+		break;
+	}
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_ConfigureExpanderSM_Context {
+	struct discover_context *discover_contextp;
+	struct list_head *discover_listp;
+	struct asd_target *newExpander;
+	struct asd_target *currentExpander;
+	struct asd_target *configureExpander;
+	uint8_t upstreamSASAddress[SAS_ADDR_LEN];
+	uint8_t upstreamPhyIdentifier;
+	unsigned phyIndex;
+	unsigned routeIndex;
+	uint32_t slowest_link;
+};
+
+DISCOVER_RESULTS
+asd_state_config_expander_route(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureExpanderSM_Context *ctx;
+	uint8_t disableRouteEntry;
+	struct Discover *discover;
+	DISCOVER_RESULTS results;
+	uint8_t *attached_sas_addr;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	for (; 1; ctx->currentExpander = ctx->configureExpander) {
+
+		if (ctx->currentExpander->management_flags & DEVICE_SET_ROOT) {
+			/*
+			 * This is the edge of the device set, we are done.
+			 */
+			return DISCOVER_FINISHED;
+		}
+		/*
+		 * move upstream from here to find the expander table to 
+		 * configure with information from "attachedExpander"
+		 */
+		if (!asd_upstream_expander(ctx->currentExpander,
+					   ctx->upstreamSASAddress,
+					   &ctx->upstreamPhyIdentifier)) {
+
+			return DISCOVER_FINISHED;
+		}
+
+		if (SAS_ISZERO(ctx->upstreamSASAddress)) {
+			return DISCOVER_FINISHED;
+		}
+
+		/*
+		 * get the expander associated with the upstream address
+		 */
+		ctx->configureExpander = asd_find_target(ctx->discover_listp,
+							 ctx->
+							 upstreamSASAddress);
+
+		if (ctx->configureExpander == NULL) {
+			/*
+			 * If we don't have the upstream expander, something
+			 * is wrong.  This should never happen.
+			 */
+			return DISCOVER_FAILED;
+		}
+
+		/*
+		 * if we found an upstream expander, then program its route
+		 * table.
+		 */
+		for (ctx->phyIndex = 0; ctx->phyIndex <
+		     ctx->configureExpander->num_phys; ctx->phyIndex++) {
+
+			attached_sas_addr =
+			    ctx->configureExpander->
+			    Phy[ctx->phyIndex].Result.AttachedSASAddress;
+
+			if (SAS_ISEQUAL(attached_sas_addr,
+					ctx->currentExpander->ddb_profile.
+					sas_addr)) {
+
+				break;
+			}
+		}
+
+		if (ctx->phyIndex == ctx->configureExpander->num_phys) {
+
+			continue;
+		}
+
+		/*
+		 * assume the route entry is enabled
+		 */
+		disableRouteEntry = ENABLED;
+
+		discover = NULL;
+
+		for (ctx->routeIndex = 0;
+		     ctx->routeIndex < ctx->newExpander->num_phys;
+		     ctx->routeIndex++) {
+
+			discover = &(ctx->newExpander->
+				     Phy[ctx->routeIndex].Result);
+
+			/*
+			 * check to see if the address needs to be configured
+			 * in the route table, this decision is based on the
+			 * optimization flag
+			 */
+			if (asd_qualified_address(ctx->configureExpander,
+						  ctx->phyIndex, discover,
+						  &disableRouteEntry)) {
+
+				break;
+			}
+		}
+
+		if (ctx->routeIndex == ctx->newExpander->num_phys) {
+
+			continue;
+		}
+
+		results = asd_issue_route_config(sm_contextp,
+						 ctx->configureExpander,
+						 ctx->phyIndex,
+						 disableRouteEntry,
+						 discover->AttachedSASAddress);
+
+		return results;
+	}
+}
+
+ASD_DISCOVERY_STATES
+asd_state_config_expander_route_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureExpanderSM_Context *ctx;
+	struct Discover *discover;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_route_config_post(sm_contextp,
+					      ctx->configureExpander,
+					      ctx->phyIndex);
+
+	if (results == DISCOVER_OK) {
+
+		discover = &(ctx->newExpander->Phy[ctx->routeIndex].Result);
+
+		ctx->routeIndex++;
+
+		/*
+		 * add the address to the internal copy of the
+		 * route table, if successfully configured
+		 */
+		SASCPY(ROUTE_ENTRY(ctx->configureExpander, ctx->phyIndex,
+				   ctx->configureExpander->
+				   route_indexes[ctx->phyIndex]),
+		       discover->AttachedSASAddress);
+
+		ctx->configureExpander->route_indexes[ctx->phyIndex]++;
+
+		return ASD_STATE_CONFIG_EXPANDER_ROUTE_LOOP;
+	}
+
+	return ASD_STATE_CONFIG_EXPANDER_FAILED;
+}
+
+DISCOVER_RESULTS
+asd_state_config_expander_route_loop(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureExpanderSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	uint8_t disableRouteEntry;
+	struct Discover *discover;
+	uint8_t *attached_sas_addr;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	while (1) {
+		/*
+		 * assume the route entry is enabled
+		 */
+		disableRouteEntry = ENABLED;
+
+		for (; ctx->routeIndex < ctx->newExpander->num_phys;
+		     ctx->routeIndex++) {
+
+			discover = &(ctx->newExpander->
+				     Phy[ctx->routeIndex].Result);
+
+			/*
+			 * check to see if the address needs to be configured
+			 * in the route table, this decision is based on the
+			 * optimization flag
+			 */
+			if (asd_qualified_address(ctx->configureExpander,
+						  ctx->phyIndex, discover,
+						  &disableRouteEntry)) {
+
+				results = asd_issue_route_config(sm_contextp,
+								 ctx->
+								 configureExpander,
+								 ctx->phyIndex,
+								 disableRouteEntry,
+								 discover->
+								 AttachedSASAddress);
+
+				return results;
+			}
+		}
+
+		ctx->phyIndex++;
+
+		/*
+		 * if we found an upstream expander, then program its route
+		 * table.
+		 */
+		for (; ctx->phyIndex <
+		     ctx->configureExpander->num_phys; ctx->phyIndex++) {
+
+			attached_sas_addr = ctx->configureExpander->
+			    Phy[ctx->phyIndex].Result.AttachedSASAddress;
+
+			if (SAS_ISEQUAL(attached_sas_addr,
+					ctx->currentExpander->ddb_profile.
+					sas_addr)) {
+
+				break;
+			}
+		}
+
+		if (ctx->phyIndex == ctx->configureExpander->num_phys) {
+
+			break;
+		}
+
+		ctx->routeIndex = 0;
+	}
+
+	ctx->phyIndex = 0;
+
+	ctx->currentExpander = ctx->configureExpander;
+
+	results = asd_state_config_expander_route(sm_contextp);
+
+	return results;
+}
+
+DISCOVER_RESULTS
+asd_ConfigureExpanderSM_Initialize(struct state_machine_context *
+				   sm_contextp, void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureExpanderSM_Context *ctx;
+	struct asd_ConfigureExpanderSM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_ConfigureExpanderSM_Arguments *)init_args;
+
+	/*
+	 * go through the configure cycle progressively
+	 * ascending to each expander starting at "newExpander"
+	 */
+	ctx->discover_listp = args->discover_listp;
+	ctx->newExpander = args->newExpander;
+	ctx->currentExpander = ctx->newExpander;
+	ctx->slowest_link = 0;
+	SAS_ZERO(ctx->upstreamSASAddress);
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_ConfigureExpanderSM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureExpanderSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_CONFIG_EXPANDER_START:
+		new_state = ASD_STATE_CONFIG_EXPANDER_ROUTE;
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_ROUTE:
+		new_state = asd_state_config_expander_route_post(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_ROUTE_LOOP:
+		new_state = asd_state_config_expander_route_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_CONFIG_EXPANDER_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+	case ASD_STATE_CONFIG_EXPANDER_ROUTE:
+		results = asd_state_config_expander_route(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_ROUTE_LOOP:
+		results = asd_state_config_expander_route_loop(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_ConfigureExpanderSM_Finish(struct state_machine_context *sm_contextp,
+			       DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureExpanderSM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	RETURN_STACK(results);
+}
+
+void asd_ConfigureExpanderSM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_ConfigureExpanderSM_Context *ctx;
+	ASD_DISCOVERY_STATES current_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_CONFIG_EXPANDER_ROUTE:
+		break;
+
+	case ASD_STATE_CONFIG_EXPANDER_ROUTE_LOOP:
+		break;
+
+	default:
+		break;
+	}
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_DiscoverConfigSetSM_Context {
+	struct discover_context *discover_contextp;
+	struct list_head *discover_listp;
+	struct asd_target *currentExpander;
+	struct asd_target *newExpander;
+	unsigned phyIndex;
+	struct list_head *found_listp;
+	struct list_head *old_discover_listp;
+};
+
+DISCOVER_RESULTS asd_state_config_set_issue_discover(struct state_machine_context
+						     *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverConfigSetSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct Discover *currentDiscover;
+	unsigned conn_rate;
+	unsigned found_expander;
+	struct asd_DiscoverExpanderSM_Arguments args;
+	struct asd_target *target;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	currentDiscover = NULL;
+
+	while (1) {
+		for (; ctx->phyIndex !=
+		     ctx->currentExpander->num_phys; ctx->phyIndex++) {
+
+			/*
+			 * this is just a pointer helper
+			 */
+			currentDiscover = &(ctx->currentExpander->
+					    Phy[ctx->phyIndex].Result);
+
+			if (SAS_ISZERO(currentDiscover->AttachedSASAddress)) {
+				continue;
+			}
+
+			/*
+			 * Vitesse:
+			 */
+			if (((currentDiscover->TargetBits &
+			      SMP_TGT_PORT) != 0) &&
+			    (currentDiscover->AttachedDeviceType ==
+			     END_DEVICE)) {
+
+				printk("%s:%d: expander %llx reports %llx as "
+				       "an END_DEVICE, but SMP_TGT_PORT is "
+				       "set in TargetBits\n",
+				       __FUNCTION__, __LINE__,
+				       *((uint64_t *) ctx->currentExpander->
+					 ddb_profile.sas_addr),
+				       *((uint64_t *) currentDiscover->
+					 AttachedSASAddress));
+
+				printk("%s:%d: Assuming expander\n",
+				       __FUNCTION__, __LINE__);
+
+				currentDiscover->AttachedDeviceType =
+				    EDGE_EXPANDER_DEVICE;
+			}
+
+			/*
+			 * look for phys with edge or fanout devices attached...
+			 */
+			switch (currentDiscover->AttachedDeviceType) {
+			case EDGE_EXPANDER_DEVICE:
+				break;
+
+			case FANOUT_EXPANDER_DEVICE:
+				break;
+
+			case END_DEVICE:
+				conn_rate = ctx->currentExpander->
+				    ddb_profile.conn_rate;
+
+				if (conn_rate > currentDiscover->
+				    NegotiatedPhysicalLinkRate) {
+
+					conn_rate = currentDiscover->
+					    NegotiatedPhysicalLinkRate;
+				}
+
+				results = asd_configure_device(sm_contextp,
+							       ctx->
+							       currentExpander,
+							       currentDiscover,
+							       ctx->
+							       discover_listp,
+							       ctx->found_listp,
+							       ctx->
+							       old_discover_listp,
+							       conn_rate);
+
+				continue;
+
+			case NO_DEVICE:
+			default:
+				continue;
+			}
+
+			if (currentDiscover->RoutingAttribute != TABLE) {
+				continue;
+			}
+
+			/*
+			 * check to see if we already have the address
+			 * information in our expander list
+			 */
+			target = asd_find_target(ctx->discover_listp,
+						 currentDiscover->
+						 AttachedSASAddress);
+
+			if (target != NULL) {
+				continue;
+			}
+
+			args.sas_addr = currentDiscover->AttachedSASAddress;
+			args.upstreamExpander = ctx->currentExpander;
+			args.attachedDeviceType =
+			    currentDiscover->AttachedDeviceType;
+			args.old_discover_listp = ctx->old_discover_listp;
+			args.found_listp = ctx->found_listp;
+			args.conn_rate =
+			    currentDiscover->NegotiatedPhysicalLinkRate;
+
+			/*
+			 * if we did not have the expander in our list, then get
+			 * the information
+			 */
+			results = ASD_PUSH_STATE_MACHINE(sm_contextp,
+							 &asd_DiscoverExpanderSM,
+							 (void *)&args);
+
+			return results;
+		}
+
+		if (ctx->phyIndex == ctx->currentExpander->num_phys) {
+
+			found_expander = 0;
+
+			while (ctx->currentExpander->all_domain_targets.next
+			       != ctx->discover_listp) {
+
+				ctx->currentExpander =
+				    list_entry(ctx->currentExpander->
+					       all_domain_targets.next,
+					       struct asd_target,
+					       all_domain_targets);
+
+				if ((ctx->currentExpander->management_type ==
+				     ASD_DEVICE_EDGE_EXPANDER) ||
+				    (ctx->currentExpander->management_type ==
+				     ASD_DEVICE_FANOUT_EXPANDER)) {
+
+					found_expander = 1;
+
+					break;
+				}
+			}
+
+			if (found_expander == 0) {
+				return DISCOVER_FINISHED;
+			}
+
+			ctx->phyIndex = 0;
+		}
+	}
+}
+
+ASD_DISCOVERY_STATES
+asd_state_config_set_issue_discover_post(struct state_machine_context *
+					 sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverConfigSetSM_Context *ctx;
+	struct asd_target *expander;
+	DISCOVER_RESULTS results;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	/*
+	 * The new expander is returned on the stack
+	 */
+	POP_STACK(results);
+	POP_STACK(expander);
+
+	ctx->phyIndex++;
+
+	if (results != DISCOVER_FINISHED) {
+		/*
+		 * For some reason we couldn't talk to this expander
+		 */
+		printk("Discover of expander 0x%0llx failed\n",
+		       *((uint64_t *) expander->ddb_profile.sas_addr));
+
+		return ASD_STATE_CONFIG_SET_ISSUE_DISCOVER;
+	}
+
+	ctx->newExpander = expander;
+
+	/*
+	 * Add the new expander to the tree.
+	 */
+	asd_add_child(discover_contextp->port, ctx->currentExpander,
+		      ctx->newExpander);
+
+	list_add_tail(&ctx->newExpander->all_domain_targets,
+		      ctx->discover_listp);
+
+	if (expander->configurable_route_table == 0) {
+		return ASD_STATE_CONFIG_SET_ISSUE_DISCOVER;
+	}
+
+	return ASD_STATE_CONFIG_SET_CONFIGURE_EXPANDER;
+}
+
+DISCOVER_RESULTS
+asd_state_config_set_configure_expander(struct state_machine_context *
+					sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverConfigSetSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_ConfigureExpanderSM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.discover_listp = ctx->discover_listp;
+	args.newExpander = ctx->newExpander;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp,
+					 &asd_ConfigureExpanderSM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_config_set_configure_expander_post(struct state_machine_context *
+					     sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverConfigSetSM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_CONFIG_SET_FAILED;
+	}
+
+	return ASD_STATE_CONFIG_SET_ISSUE_DISCOVER;
+}
+
+DISCOVER_RESULTS
+asd_DiscoverConfigSetSM_Initialize(struct state_machine_context *
+				   sm_contextp, void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverConfigSetSM_Context *ctx;
+	struct asd_DiscoverConfigSetSM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_DiscoverConfigSetSM_Arguments *)init_args;
+
+	ctx->currentExpander = args->currentExpander;
+	ctx->discover_listp = args->discover_listp;
+	ctx->found_listp = args->found_listp;
+	ctx->old_discover_listp = args->old_discover_listp;
+	ctx->phyIndex = 0;
+	ctx->newExpander = NULL;
+
+	list_del_init(&ctx->currentExpander->all_domain_targets);
+
+	list_add_tail(&ctx->currentExpander->all_domain_targets,
+		      ctx->discover_listp);
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_DiscoverConfigSetSM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverConfigSetSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_CONFIG_SET_START:
+		new_state = ASD_STATE_CONFIG_SET_ISSUE_DISCOVER;
+		break;
+
+	case ASD_STATE_CONFIG_SET_ISSUE_DISCOVER:
+		new_state =
+		    asd_state_config_set_issue_discover_post(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_SET_CONFIGURE_EXPANDER:
+		new_state =
+		    asd_state_config_set_configure_expander_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_CONFIG_SET_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+	case ASD_STATE_CONFIG_SET_ISSUE_DISCOVER:
+		results = asd_state_config_set_issue_discover(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_SET_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	case ASD_STATE_CONFIG_SET_CONFIGURE_EXPANDER:
+		results = asd_state_config_set_configure_expander(sm_contextp);
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_DiscoverConfigSetSM_Finish(struct state_machine_context *sm_contextp,
+			       DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverConfigSetSM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	RETURN_STACK(results);
+
+}
+
+void asd_DiscoverConfigSetSM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverConfigSetSM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_DiscoverFindBoundarySM_Context {
+	struct discover_context *discover_contextp;
+	struct asd_target *expander;
+	uint8_t upstreamSASAddress[SAS_ADDR_LEN];
+	uint8_t attachedPhyIdentifier;
+	uint8_t phyIdentifier;
+	struct asd_target *attachedRootExpander;
+	struct list_head *found_listp;
+	struct list_head *old_discover_listp;
+	unsigned conn_rate;
+};
+
+ASD_DISCOVERY_STATES
+asd_state_find_boundary_start(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverFindBoundarySM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_find_subtractive_phy(sm_contextp, ctx->expander,
+					   ctx->upstreamSASAddress,
+					   &ctx->attachedPhyIdentifier,
+					   &ctx->conn_rate,
+					   &ctx->phyIdentifier);
+
+	if ((results == DISCOVER_FINISHED) ||
+	    SAS_ISZERO(ctx->upstreamSASAddress)) {
+
+		ctx->expander->management_flags |= DEVICE_SET_ROOT;
+
+		return ASD_STATE_FIND_BOUNDARY_FINISHED;
+	}
+
+	return ASD_STATE_FIND_BOUNDARY_LOOP;
+}
+
+DISCOVER_RESULTS
+asd_state_find_boundary_loop(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverFindBoundarySM_Context *ctx;
+	struct asd_DiscoverExpanderSM_Arguments args;
+	DISCOVER_RESULTS results;
+	struct Discover *discover;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	/*
+	 * if we have a subtractive address then go upstream
+	 * to see if it is part of the edge expander device set
+	 */
+
+	discover = &(ctx->expander->Phy[ctx->phyIdentifier].Result);
+
+	args.sas_addr = ctx->upstreamSASAddress;
+	args.upstreamExpander = ctx->expander;
+	args.attachedDeviceType = discover->AttachedDeviceType;
+	args.old_discover_listp = ctx->old_discover_listp;
+	args.found_listp = ctx->found_listp;
+	args.conn_rate = ctx->conn_rate;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp, &asd_DiscoverExpanderSM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_find_boundary_loop_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverFindBoundarySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_target *upstreamExpander;
+	struct Discover *discover;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	/*
+	 * The new expander is returned on the stack
+	 */
+	POP_STACK(results);
+	POP_STACK(upstreamExpander);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_FIND_BOUNDARY_FAILED;
+	}
+
+	/*
+	 * Add the new expander to the tree.
+	 */
+	asd_add_child(discover_contextp->port, ctx->expander, upstreamExpander);
+
+	list_add_tail(&upstreamExpander->all_domain_targets, ctx->found_listp);
+
+	results = asd_find_subtractive_phy(sm_contextp, upstreamExpander,
+					   ctx->upstreamSASAddress,
+					   &ctx->attachedPhyIdentifier,
+					   &ctx->conn_rate,
+					   &ctx->phyIdentifier);
+
+	if (results == DISCOVER_FINISHED) {
+
+		ctx->expander = upstreamExpander;
+
+		ctx->expander->management_flags |= DEVICE_SET_ROOT;
+
+		return ASD_STATE_FIND_BOUNDARY_FINISHED;
+	}
+
+	/*
+	 * initialize the subtractive address, a zero value is not valid
+	 */
+	if (results == DISCOVER_FAILED) {
+		/*
+		 * to get here, we had to see more than one subtractive
+		 * phy that connect to different SAS addresses, this is
+		 * a topology error do cleanup on any memory allocated
+		 * if necessary
+		 */
+
+		// TODO: fix this
+		// TODO: what do we want to return here???
+
+		return ASD_STATE_FIND_BOUNDARY_FAILED;
+	}
+
+	/*
+	 * if no error, then decide if we need to go upstream or stop
+	 */
+	if (SAS_ISZERO(ctx->upstreamSASAddress)) {
+
+		ctx->expander = upstreamExpander;
+
+		return ASD_STATE_FIND_BOUNDARY_FINISHED;
+	}
+
+	/*
+	 * this is just a pointer helper
+	 */
+	discover = &(upstreamExpander->Phy[ctx->phyIdentifier].Result);
+
+	/*
+	 * check to see if the upstream expander is connected to the 
+	 * subtractive port of the previous expander, if we are then we 
+	 * have two expander device sets connected together, stop here 
+	 * and save the target pointer of next expander in device set.
+	 */
+	if (SAS_ISEQUAL(discover->AttachedSASAddress,
+			upstreamExpander->parent->ddb_profile.sas_addr)) {
+
+		ctx->attachedRootExpander = upstreamExpander;
+
+		ctx->expander->management_flags |= DEVICE_SET_ROOT;
+		ctx->attachedRootExpander->management_flags |= DEVICE_SET_ROOT;
+
+		return ASD_STATE_FIND_BOUNDARY_FINISHED;
+	}
+
+	/*
+	 * Movin' on up.
+	 */
+	ctx->expander = upstreamExpander;
+
+	return ASD_STATE_FIND_BOUNDARY_LOOP;
+}
+
+DISCOVER_RESULTS
+asd_DiscoverFindBoundarySM_Initialize(struct state_machine_context *
+				      sm_contextp, void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverFindBoundarySM_Context *ctx;
+	struct asd_DiscoverFindBoundarySM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_DiscoverFindBoundarySM_Arguments *)init_args;
+
+	ctx->expander = args->expander;
+	ctx->found_listp = args->found_listp;
+	ctx->old_discover_listp = args->old_discover_listp;
+
+	SAS_ZERO(ctx->upstreamSASAddress);
+	ctx->attachedPhyIdentifier = 0;
+	ctx->attachedRootExpander = NULL;
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_DiscoverFindBoundarySM_StateMachine(struct state_machine_context *
+					sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverFindBoundarySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_FIND_BOUNDARY_START:
+		new_state = asd_state_find_boundary_start(sm_contextp);
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY_LOOP:
+		new_state = asd_state_find_boundary_loop_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_FIND_BOUNDARY_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+	case ASD_STATE_FIND_BOUNDARY_LOOP:
+		results = asd_state_find_boundary_loop(sm_contextp);
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_DiscoverFindBoundarySM_Finish(struct state_machine_context *sm_contextp,
+				  DISCOVER_RESULTS results)
+{
+
+	struct state_information *state_infop;
+	struct asd_DiscoverFindBoundarySM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	RETURN_STACK(ctx->attachedRootExpander);
+	RETURN_STACK(ctx->expander);
+	RETURN_STACK(results);
+}
+
+void
+asd_DiscoverFindBoundarySM_Abort(struct state_machine_context *sm_contextp)
+{
+
+	struct state_information *state_infop;
+	struct asd_DiscoverFindBoundarySM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_DiscoverExpanderSM_Context {
+	struct discover_context *discover_contextp;
+	struct asd_target *expander;
+	unsigned phyIndex;
+	uint8_t *sas_addr;
+	unsigned attachedDeviceType;
+	struct list_head *old_discover_listp;
+	struct list_head *found_listp;
+	struct asd_target *upstreamExpander;
+	unsigned conn_rate;
+};
+
+DISCOVER_RESULTS
+asd_state_issue_report_general(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverExpanderSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	unsigned conn_rate;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	/*
+	 * Get the connection rate from the upstream expander.  The upstream
+	 * expander is different than the "parent" expander with is based on
+	 * the topology of the device set.
+	 */
+	if (ctx->upstreamExpander == NULL) {
+		conn_rate = discover_contextp->port->conn_rate;
+	} else {
+		conn_rate = ctx->upstreamExpander->ddb_profile.conn_rate;
+	}
+
+	if (conn_rate > ctx->conn_rate) {
+		conn_rate = ctx->conn_rate;
+	}
+
+	results = asd_issue_report_general(sm_contextp,
+					   ctx->sas_addr,
+					   conn_rate, ctx->attachedDeviceType,
+					   ctx->old_discover_listp,
+					   ctx->found_listp, &ctx->expander);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_issue_report_general_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverExpanderSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+
+	results = asd_issue_report_general_post(sm_contextp, ctx->expander);
+
+	if (results != DISCOVER_OK) {
+
+		printk("%s:%d: Report General Failed\n", __FUNCTION__,
+		       __LINE__);
+		return ASD_STATE_REPORT_AND_DISCOVER_FAILED;
+	}
+
+	return ASD_STATE_ISSUE_DISCOVER_LOOP;
+}
+
+DISCOVER_RESULTS
+asd_state_issue_discover_loop(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverExpanderSM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_discover_request(sm_contextp,
+					     ctx->expander, ctx->phyIndex);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_issue_discover_loop_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverExpanderSM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	results = asd_issue_discover_request_post(sm_contextp,
+						  ctx->expander, ctx->phyIndex);
+
+	if (results != DISCOVER_OK) {
+		printk("%s:%d: Discover Request Failed\n", __FUNCTION__,
+		       __LINE__);
+
+		return ASD_STATE_REPORT_AND_DISCOVER_FAILED;
+	}
+
+	ctx->phyIndex++;
+
+	if (ctx->phyIndex == ctx->expander->num_phys) {
+		return ASD_STATE_REPORT_AND_DISCOVER_FINISHED;
+	}
+
+	return ASD_STATE_ISSUE_DISCOVER_LOOP;
+}
+
+DISCOVER_RESULTS
+asd_DiscoverExpanderSM_Initialize(struct state_machine_context *
+				  sm_contextp, void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverExpanderSM_Context *ctx;
+	struct asd_DiscoverExpanderSM_Arguments *args;
+
+	NEW_CONTEXT(ctx);
+
+	args = (struct asd_DiscoverExpanderSM_Arguments *)init_args;
+
+	ctx->sas_addr = args->sas_addr;
+	ctx->upstreamExpander = args->upstreamExpander;
+	ctx->attachedDeviceType = args->attachedDeviceType;
+	ctx->old_discover_listp = args->old_discover_listp;
+	ctx->found_listp = args->found_listp;
+	ctx->conn_rate = args->conn_rate;
+	ctx->phyIndex = 0;
+	ctx->expander = NULL;
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_DiscoverExpanderSM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverExpanderSM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_REPORT_AND_DISCOVER_START:
+		new_state = ASD_STATE_ISSUE_REPORT_GENERAL;
+		break;
+
+	case ASD_STATE_ISSUE_REPORT_GENERAL:
+		new_state = asd_state_issue_report_general_post(sm_contextp);
+		break;
+
+	case ASD_STATE_ISSUE_DISCOVER_LOOP:
+		new_state = asd_state_issue_discover_loop_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_REPORT_AND_DISCOVER_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+	case ASD_STATE_ISSUE_REPORT_GENERAL:
+		results = asd_state_issue_report_general(sm_contextp);
+		break;
+
+	case ASD_STATE_ISSUE_DISCOVER_LOOP:
+		results = asd_state_issue_discover_loop(sm_contextp);
+		break;
+
+	case ASD_STATE_REPORT_AND_DISCOVER_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+void
+asd_DiscoverExpanderSM_Finish(struct state_machine_context *sm_contextp,
+			      DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverExpanderSM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	RETURN_STACK(ctx->expander);
+	RETURN_STACK(results);
+}
+
+void asd_DiscoverExpanderSM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverExpanderSM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_DiscoverySM_Context {
+	struct discover_context *discover_contextp;
+
+	/*
+	 * The expander that is directly attached to this initiator/port
+	 */
+	struct asd_target *connectedExpander;
+
+	/*
+	 * The expander that is at the root of this device set
+	 */
+	struct asd_target *thisDeviceSet;
+
+	/*
+	 * The expander that is at the root of the attached device set (if any).
+	 * The attached device set is the the device set on the the other side
+	 * of a subtractive-subtractive boundary.
+	 */
+	struct asd_target *attachedDeviceSet;
+
+	/*
+	 * The list that we discovered from thisDeviceSet.
+	 */
+	struct list_head discover_list;
+
+	/*
+	 * The list that we discovered from attachedDeviceSet.
+	 */
+	struct list_head attached_device_list;
+
+	/*
+	 * During the process of discovering expanders, we may find a
+	 * device or expander that we don't know where to put at the moment.
+	 */
+	struct list_head found_list;
+
+	/*
+	 * The list from the previous discovery.  If there is anything left
+	 * on this list at the end of discovery, the device is no longer
+	 * present.
+	 */
+	struct list_head old_discover_list;
+};
+
+ASD_DISCOVERY_STATES
+asd_state_discover_start(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	struct asd_target *target;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	/*
+	 * Invalidate all the targets, if any, found so far.  
+	 */
+	asd_invalidate_targets(discover_contextp->asd, discover_contextp->port);
+
+	/*
+	 * Move our list of formerly discovered targets to the "old discover
+	 * list".  We will use this list later to figure out which devices have
+	 * been removed.
+	 */
+	list_move_all(&ctx->old_discover_list,
+		      &discover_contextp->port->targets);
+
+	/*
+	 * MDT. Saving pointers for easy access.
+	 */
+	discover_contextp->asd->old_discover_listp = &ctx->old_discover_list;
+	discover_contextp->asd->discover_listp = &ctx->discover_list;
+
+	if (discover_contextp->port->tree_root == NULL) {
+		return ASD_STATE_FINISHED;
+	}
+
+	/*
+	 * check to see if an expander is attached
+	 */
+	if ((discover_contextp->port->management_type !=
+	     ASD_DEVICE_EDGE_EXPANDER) &&
+	    (discover_contextp->port->management_type !=
+	     ASD_DEVICE_FANOUT_EXPANDER)) {
+
+		target = asd_find_target(&ctx->old_discover_list,
+					 discover_contextp->port->tree_root->
+					 ddb_profile.sas_addr);
+
+		if (target != NULL) {
+			/*
+			 * This target was previously found.
+			 */
+			target->flags |= ASD_TARG_RESEEN;
+
+			/*
+			 * Take this target off of the old discover list.
+			 */
+			list_del_init(&target->all_domain_targets);
+		}
+
+		list_add_tail(&discover_contextp->port->tree_root->
+			      all_domain_targets, &ctx->discover_list);
+
+		/*
+		 * There isn't an expander to discover, so move on to the
+		 * initialization stage of the state machine.
+		 */
+		return ASD_STATE_SATA_SPINHOLD;
+	}
+
+	/*
+	 * walk the list of targets, and re-initialize the tree links.
+	 */
+	list_for_each_entry(target, &ctx->old_discover_list, all_domain_targets) {
+
+		target->parent = NULL;
+		INIT_LIST_HEAD(&target->children);
+		INIT_LIST_HEAD(&target->siblings);
+		INIT_LIST_HEAD(&target->multipath);
+
+		if ((target->management_type != ASD_DEVICE_EDGE_EXPANDER) &&
+		    (target->management_type != ASD_DEVICE_FANOUT_EXPANDER)) {
+
+			continue;
+		}
+
+		if (target->num_route_indexes == 0) {
+			continue;
+		}
+
+		if (target->RouteTable != NULL) {
+			memset(target->RouteTable, 0,
+			       SAS_ADDR_LEN * target->num_phys *
+			       target->num_route_indexes);
+		}
+
+		if (target->route_indexes != NULL) {
+			memset(target->route_indexes, 0,
+			       target->num_route_indexes * sizeof(uint16_t));
+		}
+	}
+
+	/*
+	 * Put our newly discovered, directly attached target in the found
+	 * list.
+	 */
+	list_del_init(&discover_contextp->port->tree_root->all_domain_targets);
+
+	list_add_tail(&discover_contextp->port->tree_root->all_domain_targets,
+		      &ctx->found_list);
+
+	return ASD_STATE_DISCOVER_ATTACHED;
+}
+
+DISCOVER_RESULTS
+asd_state_discover_attached(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_DiscoverExpanderSM_Arguments args;
+	uint8_t device_type;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	switch (discover_contextp->port->management_type) {
+	case ASD_DEVICE_EDGE_EXPANDER:
+		device_type = EDGE_EXPANDER_DEVICE;
+		break;
+
+	case ASD_DEVICE_FANOUT_EXPANDER:
+		device_type = FANOUT_EXPANDER_DEVICE;
+		break;
+
+	default:
+		/*
+		 * If this isn't some kind of expander, then we shouldn't
+		 * be here.
+		 */
+		results = DISCOVER_FAILED;
+		return results;
+	}
+
+	/*
+	 * There is no upstream expander from this expander, because it is
+	 * the closest device to the initiator.
+	 */
+	args.sas_addr = discover_contextp->port->attached_sas_addr;
+	args.upstreamExpander = NULL;
+	args.attachedDeviceType = device_type;
+	args.old_discover_listp = &ctx->old_discover_list;
+	args.found_listp = &ctx->found_list;
+	args.conn_rate = discover_contextp->port->conn_rate;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp, &asd_DiscoverExpanderSM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_discover_attached_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_target *new_expander;
+	struct discover_context *discover_contextp;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	/*
+	 * The new expander is returned on the stack
+	 */
+	POP_STACK(results);
+	POP_STACK(new_expander);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_FAILED;
+	}
+
+	ctx->connectedExpander = new_expander;
+
+	list_add_tail(&new_expander->all_domain_targets, &ctx->found_list);
+
+	return ASD_STATE_FIND_BOUNDARY;
+}
+
+DISCOVER_RESULTS
+asd_state_find_boundary(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_DiscoverFindBoundarySM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.expander = ctx->connectedExpander;
+	args.found_listp = &ctx->found_list;
+	args.old_discover_listp = &ctx->old_discover_list;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp,
+					 &asd_DiscoverFindBoundarySM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_find_boundary_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_target *expander;
+	struct asd_target *attachedRootExpander;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+	POP_STACK(expander);
+	POP_STACK(attachedRootExpander);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_FAILED;
+	}
+
+	ctx->thisDeviceSet = expander;
+	ctx->attachedDeviceSet = attachedRootExpander;
+
+	return ASD_STATE_CONFIG_BOUNDARY_SET;
+}
+
+DISCOVER_RESULTS
+asd_state_config_boundary_set(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_DiscoverConfigSetSM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.discover_listp = &ctx->discover_list;
+	args.found_listp = &ctx->found_list;
+	args.old_discover_listp = &ctx->old_discover_list;
+	args.currentExpander = ctx->thisDeviceSet;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp, &asd_DiscoverConfigSetSM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_config_boundary_set_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_FAILED;
+	}
+
+	if (ctx->attachedDeviceSet == NULL) {
+		return ASD_STATE_SATA_SPINHOLD;
+	}
+
+	return ASD_STATE_CONFIG_ATTACHED_SET;
+}
+
+DISCOVER_RESULTS
+asd_state_config_attached_set(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_DiscoverConfigSetSM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.discover_listp = &ctx->attached_device_list;
+	args.found_listp = &ctx->found_list;
+	args.old_discover_listp = &ctx->old_discover_list;
+	args.currentExpander = ctx->attachedDeviceSet;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp, &asd_DiscoverConfigSetSM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_config_attached_set_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_FAILED;
+	}
+
+	/*
+	 * put the domains together
+	 */
+	list_splice(&ctx->attached_device_list, ctx->discover_list.prev);
+
+	return ASD_STATE_SATA_SPINHOLD;
+}
+
+DISCOVER_RESULTS
+asd_state_sata_spinhold(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_SATA_SpinHoldSM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.discover_listp = &ctx->discover_list;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp, &asd_SATA_SpinHoldSM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_sata_spinhold_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_FAILED;
+	}
+
+	return ASD_STATE_INIT_SATA;
+}
+
+DISCOVER_RESULTS asd_state_init_sata(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_InitSATA_SM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.discover_listp = &ctx->discover_list;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp, &asd_InitSATA_SM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_sata_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+
+	if (results != DISCOVER_FINISHED) {
+		//TODO: we can't give up, but we need to notify the user
+	}
+
+	return ASD_STATE_INIT_SAS;
+}
+
+DISCOVER_RESULTS asd_state_init_sas(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_InitSAS_SM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.discover_listp = &ctx->discover_list;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp, &asd_InitSAS_SM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_sas_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_FAILED;
+	}
+
+	return ASD_STATE_INIT_SMP;
+}
+
+DISCOVER_RESULTS asd_state_init_smp(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	struct asd_InitSMP_SM_Arguments args;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	args.discover_listp = &ctx->discover_list;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp, &asd_InitSMP_SM,
+					 (void *)&args);
+
+	return results;
+}
+
+ASD_DISCOVERY_STATES
+asd_state_init_smp_post(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	POP_STACK(results);
+
+	if (results != DISCOVER_FINISHED) {
+		return ASD_STATE_FAILED;
+	}
+
+	return ASD_STATE_FINISHED;
+}
+
+DISCOVER_RESULTS
+asd_DiscoverySM_Initialize(struct state_machine_context * sm_contextp,
+			   void *init_args)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	struct discover_context *discover_contextp;
+
+	NEW_CONTEXT(ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	discover_contextp->retry_count=0;
+	ctx->connectedExpander = NULL;
+	ctx->thisDeviceSet = NULL;
+	ctx->attachedDeviceSet = NULL;
+
+	INIT_LIST_HEAD(&ctx->discover_list);
+	INIT_LIST_HEAD(&ctx->attached_device_list);
+	INIT_LIST_HEAD(&ctx->found_list);
+	INIT_LIST_HEAD(&ctx->old_discover_list);
+
+	return DISCOVER_CONTINUE;
+}
+
+DISCOVER_RESULTS
+asd_DiscoverySM_StateMachine(struct state_machine_context * sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	DISCOVER_RESULTS results;
+	ASD_DISCOVERY_STATES current_state;
+	ASD_DISCOVERY_STATES new_state;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	current_state = GET_CURRENT_STATE();
+
+	switch (current_state) {
+	case ASD_STATE_DISCOVER_START:
+		new_state = asd_state_discover_start(sm_contextp);
+		break;
+
+	case ASD_STATE_DISCOVER_ATTACHED:
+		new_state = asd_state_discover_attached_post(sm_contextp);
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY:
+		new_state = asd_state_find_boundary_post(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_BOUNDARY_SET:
+		new_state = asd_state_config_boundary_set_post(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_ATTACHED_SET:
+		new_state = asd_state_config_attached_set_post(sm_contextp);
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD:
+		new_state = asd_state_sata_spinhold_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SATA:
+		new_state = asd_state_init_sata_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS:
+		new_state = asd_state_init_sas_post(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SMP:
+		new_state = asd_state_init_smp_post(sm_contextp);
+		break;
+
+	default:
+		new_state = ASD_STATE_FAILED;
+		break;
+	}
+
+	SM_new_state(sm_contextp, new_state);
+
+	switch (new_state) {
+	case ASD_STATE_DISCOVER_ATTACHED:
+		results = asd_state_discover_attached(sm_contextp);
+		break;
+
+	case ASD_STATE_FIND_BOUNDARY:
+		results = asd_state_find_boundary(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_BOUNDARY_SET:
+		results = asd_state_config_boundary_set(sm_contextp);
+		break;
+
+	case ASD_STATE_CONFIG_ATTACHED_SET:
+		results = asd_state_config_attached_set(sm_contextp);
+		break;
+
+	case ASD_STATE_SATA_SPINHOLD:
+		results = asd_state_sata_spinhold(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SATA:
+		results = asd_state_init_sata(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SAS:
+		results = asd_state_init_sas(sm_contextp);
+		break;
+
+	case ASD_STATE_INIT_SMP:
+		results = asd_state_init_smp(sm_contextp);
+		break;
+
+	case ASD_STATE_FINISHED:
+		results = DISCOVER_FINISHED;
+		break;
+
+	default:
+		results = DISCOVER_FAILED;
+		break;
+	}
+
+	return results;
+}
+
+/* ---------- SES stuff for IBM ---------- */
+
+/* Since this may be compiled for a 2.4 kernel which does not have
+ * completion variables, we have to use wait queues explicitly.
+ */
+static void asd_ssp_task_done(struct asd_softc *asd, struct scb *scb,
+			      struct asd_done_list *dl)
+{
+	wait_queue_head_t *wqh;
+
+	wqh = (wait_queue_head_t *)scb->io_ctx;
+
+	// RST - might not need this
+//JD	list_del(&scb->owner_links);
+
+	scb->dl = dl;
+
+	wake_up(wqh);
+}
+
+static int asd_send_ssp_task(struct asd_target *target, u8 * cmd, int cmd_len,
+			       dma_addr_t dma_handle, unsigned xfer_len,
+			       unsigned direction)
+{
+	static DECLARE_WAIT_QUEUE_HEAD(wqh);
+	DECLARE_WAITQUEUE(wait, current);
+
+	struct asd_softc *asd = target->softc;
+	struct asd_ssp_task_hscb *ssp_hscb;
+	unsigned long flags;
+	struct scb *scb;
+	struct sg_element *sg;
+
+	int err = 0;
+
+	asd_lock(asd, &flags);
+
+	scb = asd_hwi_get_scb(asd, 0);
+	if (!scb) {
+		asd_unlock(asd, &flags);
+		return -ENOMEM;
+	}
+	scb->flags |= SCB_INTERNAL;
+	scb->platform_data->targ = target;
+	scb->platform_data->dev = NULL;
+	INIT_LIST_HEAD(&scb->owner_links);
+	ssp_hscb = &scb->hscb->ssp_task;
+	ssp_hscb->header.opcode = SCB_INITIATE_SSP_TASK;
+	asd_build_sas_header(target, ssp_hscb);
+	ssp_hscb->protocol_conn_rate |= PROTOCOL_TYPE_SSP;
+	ssp_hscb->data_dir_flags |= direction;
+	ssp_hscb->xfer_len = asd_htole32(xfer_len);
+	memset(ssp_hscb->cdb, 0, sizeof(ssp_hscb->cdb));
+	memcpy(ssp_hscb->cdb, cmd, cmd_len);
+	sg = scb->sg_list;
+	scb->platform_data->buf_busaddr = dma_handle;
+	asd_sg_setup(sg, dma_handle, xfer_len, /*last */ 1);
+	memcpy(ssp_hscb->sg_elements, scb->sg_list, sizeof(*sg));
+	scb->sg_count = 1;
+	asd_push_post_stack(asd, scb, (void *)&wqh, asd_ssp_task_done);
+	scb->flags |= SCB_ACTIVE;
+	scb->dl = NULL;
+
+	add_wait_queue(&wqh, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	asd_hwi_post_scb(asd, scb);
+
+	asd_unlock(asd, &flags);
+
+	schedule_timeout(2 * HZ);	/* wait the task to come back or 2 seconds */
+
+	remove_wait_queue(&wqh, &wait);
+
+	if (!scb->dl) {
+		asd_dprint("%s: no dl! something went terribly wrong!\n",
+			   __FUNCTION__);
+		err = -101;	/* What? */
+		asd_hwi_free_scb(asd, scb);
+		goto out;
+	} else {
+		err = -102;
+		/* Ok process the status of the task */
+		switch (scb->dl->opcode) {
+		case TASK_COMP_WO_ERR:
+			err = 0;
+			break;
+		case TASK_COMP_W_UNDERRUN:
+			asd_dprint("task comp w underrun\n");
+			break;
+		case TASK_COMP_W_OVERRUN:
+			asd_dprint("task comp w overrun\n");
+			break;
+		case SSP_TASK_COMP_W_RESP:
+			asd_dprint("task comp w resp\n");
+			{
+				union edb 		*edb;
+				struct scb 		*escb;
+				u_int			edb_index;
+				struct asd_done_list	*done_listp;
+				done_listp=scb->dl;
+				edb = asd_hwi_get_edb_from_dl(asd, scb, done_listp, &escb, &edb_index);
+				if (edb != NULL) {
+					asd_hwi_free_edb(asd, escb, edb_index);
+				}
+			}
+			break;
+		default:
+			asd_dprint("task comp w status 0x%02x\n",
+				   scb->dl->opcode);
+			break;
+		}
+	}
+
+	asd_lock(asd, &flags);
+	asd_scb_internal_done(asd, scb, scb->dl);
+	asd_unlock(asd, &flags);
+      out:
+	return err;
+}
+
+static int asd_get_ses_page(struct asd_target *ses_device, int ses_page,
+			    u8 * buf, unsigned buf_len, dma_addr_t dma_handle)
+{
+	static u8 recv_diag[6] = {
+		0x1c, 0x01, 0x00, 0x00, 0x00, 0x00
+	};
+	int err;
+
+	memset(buf, 0, buf_len);
+	recv_diag[2] = ses_page;	/* page code */
+	recv_diag[3] = (buf_len & 0xFF00) >> 8;
+	recv_diag[4] = (buf_len & 0x00FF);
+	err = asd_send_ssp_task(ses_device, recv_diag, 6, dma_handle,
+				buf_len, DATA_DIR_INBOUND);
+	if (err)
+		asd_dprint("couldn't get SES page: error: 0x%x\n", err);
+
+	return err;
+}
+
+/* return negative on error, or the page length */
+static int asd_read_ses_page(struct asd_target *ses_device, int page_code,
+			     u8 * page, dma_addr_t dma_handle,
+			     unsigned max_buffer_len)
+{
+	int i;
+	int err;
+	int alloc_len;
+
+	err = asd_get_ses_page(ses_device, page_code, page, 4, dma_handle);
+	if (err) {
+		asd_dprint("couldn't get ses page 0x%x\n", page_code);
+		goto out;
+	}
+
+	asd_dprint("%02x: %02x %02x %02x %02x\n", 0,
+		   page[0], page[1], page[2], page[3]);
+
+	alloc_len = (page[2] << 8) | page[3];
+	alloc_len += 4;
+	asd_dprint("ses sends %d bytes for page 0x%x\n", alloc_len, page_code);
+	err = -ENOMEM;
+	if (alloc_len <= 4) {
+		asd_dprint("page 0x%x too small: %d bytes\n", page_code,
+			   alloc_len);
+		goto out;
+	} else if (alloc_len > max_buffer_len) {
+		asd_dprint("page 0x%x too big: %d bytes\n", page_code,
+			   alloc_len);
+		goto out;
+	}
+	err = asd_get_ses_page(ses_device, page_code, page, alloc_len,
+			       dma_handle);
+	if (err) {
+		asd_dprint("couldn't get ses page 0x%x\n", page_code);
+		goto out;
+	}
+	asd_dprint("page 0x%x:\n", page_code);
+	for (i = 0; i < alloc_len; i += 4)
+		asd_dprint("%02x: %02x %02x %02x %02x\n", i,
+			   page[i], page[i + 1], page[i + 2], page[i + 3]);
+	err = alloc_len;
+      out:
+	return err;
+}
+
+struct ses_order {
+	int ord;		/* element order - 1 from SES pages */
+	int slot;		/* SLOT %03d from page 7 */
+	u8 sas_addr[SAS_ADDR_LEN];	/* device sas address from page 0xA */
+};
+
+static struct ses_order *asd_parse_page_7(const u8 * page, const int len,
+					  int *num)
+{
+	struct ses_order *order = NULL;
+	int el_desc, el;
+	int total = 0, i;
+
+	if (len < 0xC)
+		goto out;
+	/* skip the overall descriptor */
+	el_desc = ((page[0xA] << 8) | page[0xB]) + 0xC;
+	if (el_desc >= len)
+		goto out;
+	/* Count the elements */
+	el = el_desc;		/* points to first el desc */
+	do {
+		int size = (page[el + 2] << 8) | page[el + 3];
+		if (!size)
+			break;
+		el += 4 + size;
+		total++;
+	} while (el < len);
+	asd_dprint("total elements: %d\n", total);
+	order = kmalloc(sizeof(struct ses_order) * total, GFP_KERNEL);
+	if (!order)
+		goto out;
+	el = el_desc;
+	for (i = 0; i < total; i++) {
+		order[i].ord = i;
+		sscanf(page + el + 9, "%d", &order[i].slot);
+		el += 4 + ((page[el + 2] << 8) | page[el + 3]);
+	}
+	*num = total;
+      out:
+	return order;
+}
+
+static int asd_parse_page_Ah(const u8 * page, const int len,
+			     struct ses_order *order, const int num_els)
+{
+	int err = 0;
+	int el;
+	int index;
+
+	if (len < 0xC)
+		goto out;
+
+	index = 0;
+	for (el = 0x8; el < len; el += 2 + page[el + 1]) {
+		u8 proto = page[el];
+
+		if (proto != 0x6)
+			continue;
+		if (index >= num_els)
+			break;
+		memcpy(order[index].sas_addr, page + el + 0x10, SAS_ADDR_LEN);
+
+		index++;	/* count only SAS devices */
+	}
+      out:return err;
+}
+
+static void asd_do_actual_reorder(struct asd_target *root_target,
+				  struct asd_target *ses_device,
+				  const struct ses_order *order,
+				  const int num_els)
+{
+	struct asd_target *dev;
+
+	list_for_each_entry(dev, &root_target->children, siblings) {
+		int i;
+
+		for (i = 0; i < num_els; i++) {
+			if (order[i].sas_addr[0] == 0)
+				continue;
+			if (memcmp(dev->ddb_profile.sas_addr,
+				   order[i].sas_addr, SAS_ADDR_LEN) == 0) {
+				dev->target_id = order[i].slot;
+				asd_dprint("%p->target_id=%d, sas_addr:%llx\n",
+					   dev, dev->target_id,
+					   be64_to_cpu(*(u64 *) dev->
+						       ddb_profile.sas_addr));
+				break;
+			}
+		}
+	}
+}
+static int asd_do_device_reorder(struct asd_target *root_target,
+				 struct asd_target *ses_device)
+{
+	int len = 0, num_els, i;
+	struct asd_softc *asd = ses_device->softc;
+	struct pci_dev *pcidev = asd_dev_to_pdev(asd->dev);
+	dma_addr_t dma_handle;
+	u8 *page = pci_alloc_consistent(pcidev, PAGE_SIZE, &dma_handle);
+	struct ses_order *order;
+
+	/* read and interpret page 7 */
+	len = asd_read_ses_page(ses_device, 7, page, dma_handle, PAGE_SIZE);
+	if (len <= 0)
+		goto out;
+	order = asd_parse_page_7(page, len, &num_els);
+	for (i = 0; i < num_els; i++)
+		asd_dprint("ord:%d, slot:%d\n", order[i].ord, order[i].slot);
+
+	/* read and interpret page Ah */
+	len = asd_read_ses_page(ses_device, 0xA, page, dma_handle, PAGE_SIZE);
+	if (len <= 0) {
+		asd_dprint("reading page Ah error:%d\n", len);
+		goto out_order;
+	}
+	i = asd_parse_page_Ah(page, len, order, num_els);
+	if (i) {
+		asd_dprint("couldn't parse page Ah, error:%d\n", i);
+		goto out_order;
+	}
+	for (i = 0; i < num_els; i++)
+		asd_dprint("ord:%d, slot:%d, sas addr:%llx\n",
+			   order[i].ord, order[i].slot,
+			   be64_to_cpu(*(u64 *) order[i].sas_addr));
+
+	asd_do_actual_reorder(root_target, ses_device, order, num_els);
+
+      out_order:
+	kfree(order);
+      out:
+	pci_free_consistent(pcidev, PAGE_SIZE, page, dma_handle);
+	return len;
+}
+
+static void asd_examine_ses(struct asd_softc *asd, struct asd_port *port)
+{
+	struct asd_target *root_target;
+	struct asd_target *target;
+	u8 *inquiry;
+
+	root_target = port->tree_root;
+
+	if (root_target == NULL) {
+		return;
+	}
+
+	/* We ignore SES devices which are "target roots":
+	 * Since we only care about the ordering of targets
+	 * "managed" by SES devices -- meaning on the same "level"
+	 * as the SES device, or at least this is how it's for IBM. */
+
+	list_for_each_entry(target, &root_target->children, siblings) {
+
+		if (target->command_set_type != ASD_COMMAND_SET_SCSI) {
+			continue;
+		}
+
+		inquiry = target->scsi_cmdset.inquiry;
+
+		if (inquiry == NULL) {
+			continue;
+		} else if ((inquiry[0] & 0x1f) == TYPE_ENCLOSURE
+			   && strncmp(inquiry + 8, "IBM-ESXS", 8) == 0
+			   && strncmp(inquiry + 16, "VSC7160", 7) == 0) {
+			asd_do_device_reorder(root_target, target);
+			break;
+		} else if ((inquiry[0] & 0x1f) == TYPE_ENCLOSURE
+			   && strncmp(inquiry + 8, "ADAPTEC", 7) == 0
+			   && strncmp(inquiry + 16, "SANbloc", 7) == 0) {
+			asd_dprint("Adaptec SANbloc!!!\n");
+			asd_do_device_reorder(root_target, target);
+			break;
+		}
+	}
+}
+
+/* ---------- end SES stuff ---------- */
+
+void
+asd_DiscoverySM_Finish(struct state_machine_context *sm_contextp,
+		       DISCOVER_RESULTS results)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+	struct discover_context *discover_contextp;
+	unsigned long flags;
+	struct asd_phy *phy;
+	uint8_t conn_mask;
+	unsigned num_discovery;
+
+	if(results == DISCOVER_FAILED) return;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+
+	discover_contextp = (struct discover_context *)
+	    sm_contextp->state_handle;
+	discover_contextp->retry_count=0;
+	/*
+	 * We don't necessarily update the mask when we start discovery.  Set
+	 * it to the right value.
+	 */
+	conn_mask = 0;
+
+	list_for_each_entry(phy, &discover_contextp->port->phys_attached, 
+		links) {
+
+		conn_mask |= (1 << phy->id);
+	};
+
+	discover_contextp->port->conn_mask = conn_mask;
+
+	asd_apply_conn_mask(discover_contextp->asd, &ctx->discover_list);
+	if (discover_contextp->asd->platform_data->flags & ASD_DISCOVERY_INIT) {
+
+		// TODO: this is not MP safe, even with the lock.
+
+		asd_lock(discover_contextp->asd, &flags);
+
+		discover_contextp->asd->num_discovery--;
+
+		num_discovery = discover_contextp->asd->num_discovery;
+
+		asd_unlock(discover_contextp->asd, &flags);
+
+		INIT_LIST_HEAD(&discover_contextp->port->targets_to_validate);
+
+		list_move_all(&discover_contextp->port->targets_to_validate,
+			      &ctx->discover_list);
+#ifndef NO_SES_SUPPORT
+		asd_examine_ses(discover_contextp->asd,
+				discover_contextp->port);
+#endif
+		if (num_discovery == 0)
+			asd_validate_targets_init(discover_contextp->asd);
+	} else {
+		/*
+		 * Hot Plug.
+		 */
+		/*
+		 * Validate any new targets that have been hot-plugged or 
+		 * hot-removed.
+		 */
+#ifndef NO_SES_SUPPORT
+		asd_examine_ses(discover_contextp->asd,
+				discover_contextp->port);
+#endif
+		asd_validate_targets_hotplug(discover_contextp->asd,
+					     discover_contextp->port, ctx);
+
+		list_move_all(&discover_contextp->port->targets,
+			      &ctx->discover_list);
+	}
+
+	discover_contextp->port->events &= ~ASD_DISCOVERY_PROCESS;
+
+	asd_wakeup_sem(&discover_contextp->asd->platform_data->discovery_sem);
+#ifdef ASD_DEBUG
+	asd_dump_tree(discover_contextp->asd, discover_contextp->port);
+#endif
+	asd_dprint("%s: --- EXIT\n", __FUNCTION__);
+}
+
+void asd_DiscoverySM_Abort(struct state_machine_context *sm_contextp)
+{
+	struct state_information *state_infop;
+	struct asd_DiscoverySM_Context *ctx;
+
+	GET_STATE_CONTEXT(sm_contextp, ctx);
+}
+
+/* -------------------------------------------------------------------------- */
+
+DISCOVER_RESULTS
+asd_do_discovery(struct asd_softc *asd, struct asd_port *port)
+{
+	DISCOVER_RESULTS results;
+
+	port->dc.sm_context.state_stack_top = -1;
+
+	port->dc.asd = asd;
+	port->dc.port = port;
+
+	port->dc.sm_context.state_handle = (void *)&port->dc;
+	port->dc.sm_context.wakeup_state_machine =
+	    asd_discover_wakeup_state_machine;
+
+	results = ASD_PUSH_STATE_MACHINE(&port->dc.sm_context,
+		&asd_DiscoverySM, NULL);
+
+	if (results == DISCOVER_CONTINUE) {
+		results = asd_run_state_machine(&port->dc.sm_context);
+	}
+
+	return results;
+}
+
+void asd_abort_discovery(struct asd_softc *asd, struct asd_port *port)
+{
+	asd_abort_state_machine(&port->dc.sm_context);
+}
+
+static void
+asd_invalidate_targets(struct asd_softc *asd, struct asd_port *port)
+{
+	struct asd_target *target;
+
+	list_for_each_entry(target, &port->targets, all_domain_targets) {
+		target->flags &= ~ASD_TARG_ONLINE;
+	}
+}
+
+static void
+asd_apply_conn_mask(struct asd_softc *asd, struct list_head *discover_list)
+{
+	struct asd_target *target;
+
+	if (list_empty(discover_list)) {
+		return;
+	}
+
+	list_for_each_entry(target, discover_list, all_domain_targets) {
+		asd_hwi_build_ddb_site(asd, target);
+	}
+}
+
+int asd_map_multipath(struct asd_softc *asd, struct asd_target *target)
+{
+	int ret;
+	struct asd_target *multipath_target;
+	struct asd_device *dev;
+	unsigned i;
+
+	/*
+	 * Check to make sure that this same device hasn't been exposed to the
+	 * OS on a different port.
+	 */
+	multipath_target = asd_find_multipath(asd, target);
+
+	if (multipath_target != NULL) {
+		list_add_tail(&target->multipath, &multipath_target->multipath);
+
+		return 1;
+	}
+
+	ret = asd_map_target(asd, target);
+
+	if (ret != 0) {
+		return ret;
+	}
+
+	target->flags |= ASD_TARG_MAPPED;
+
+	/*
+	 * At this point in time, we know how many luns this device has,
+	 * create the device structures for each LUN.
+	 */
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_SCSI:
+		for (i = 0; i < target->scsi_cmdset.num_luns; i++) {
+			dev = asd_alloc_device(asd, target,
+					       target->src_port->id,
+					       target->target_id, i);
+
+			memcpy(dev->saslun, &target->scsi_cmdset.luns[i],
+			       SAS_LUN_LEN);
+		}
+		break;
+
+	case ASD_COMMAND_SET_ATA:
+	case ASD_COMMAND_SET_ATAPI:
+		dev = asd_alloc_device(asd, target,
+				       target->src_port->id, target->target_id,
+				       0);
+
+		memset(dev->saslun, 0, SAS_LUN_LEN);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+
+}
+
+void asd_mark_duplicates(struct asd_softc *asd, struct list_head *discover_list)
+{
+	struct asd_target *target;
+	struct asd_target *tmp_target;
+	struct asd_target *check_target;
+	struct list_head map_list;
+	unsigned found_mapped;
+
+	INIT_LIST_HEAD(&map_list);
+
+	/*
+	 * Walk down the discovery list looking for duplicate devices.  If we
+	 * find a duplicate device, chain it to the mutipath list of the primary
+	 * target.  Put all of the unique devices in a list to mapped.
+	 */
+	while (!list_empty(discover_list)) {
+
+		target = list_entry(discover_list->next,
+				    struct asd_target, all_domain_targets);
+
+		list_del_init(&target->all_domain_targets);
+
+		/*
+		 * We only care about presenting end devices to the OS.
+		 */
+		if (target->management_type != ASD_DEVICE_END) {
+
+			list_add_tail(&target->all_domain_targets, &map_list);
+
+			continue;
+		}
+
+		switch (target->transport_type) {
+		case ASD_TRANSPORT_ATA:
+			list_add_tail(&target->all_domain_targets, &map_list);
+
+			continue;
+
+		case ASD_TRANSPORT_STP:
+		case ASD_TRANSPORT_SSP:
+			break;
+
+		default:
+			list_add_tail(&target->all_domain_targets, &map_list);
+			continue;
+		}
+
+		found_mapped = 0;
+
+		/*
+		 * Walk through the list marking each target that matches this
+		 * target as a duplicate.
+		 */
+		list_for_each_entry_safe(check_target, tmp_target,
+					 discover_list, all_domain_targets) {
+
+			/*
+			 * If they are not the same type of device, then
+			 * they can not be duplicates.
+			 */
+			if (target->transport_type !=
+			    check_target->transport_type) {
+
+				continue;
+			}
+
+			switch (target->transport_type) {
+			case ASD_TRANSPORT_SSP:
+				/*
+				 * If the lengths of the identification values
+				 * don't match, then the values themselves
+				 * can't match.
+				 */
+				if (target->scsi_cmdset.ident_len !=
+				    check_target->scsi_cmdset.ident_len) {
+
+					continue;
+				}
+
+				if ((check_target->scsi_cmdset.ident == NULL) ||
+				    (target->scsi_cmdset.ident == NULL)) {
+					continue;
+				}
+
+				if (memcmp(target->scsi_cmdset.ident,
+					   check_target->scsi_cmdset.ident,
+					   target->scsi_cmdset.ident_len) !=
+				    0) {
+
+					continue;
+				}
+				break;
+
+			case ASD_TRANSPORT_STP:
+				if (!SAS_ISEQUAL(target->ddb_profile.sas_addr,
+						 check_target->ddb_profile.
+						 sas_addr)) {
+
+					continue;
+				}
+
+				break;
+
+			default:
+				continue;
+			}
+
+			/*
+			 * We have found a duplicate device.
+			 */
+			list_del_init(&check_target->all_domain_targets);
+
+			if (check_target->flags & ASD_TARG_MAPPED) {
+				/*
+				 * This is a device that has not been
+				 * discovered before that matches a device
+				 * that has already been discovered and is
+				 * exposed to the OS.
+				 */
+				list_add_tail(&target->multipath,
+					      &check_target->multipath);
+
+				list_add_tail(&check_target->all_domain_targets,
+					      &map_list);
+
+				found_mapped = 1;
+
+				continue;
+			}
+
+			/*
+			 * This device is a multipath, so we will not map it.
+			 */
+			list_add_tail(&check_target->multipath,
+				      &target->multipath);
+		}
+
+		if (found_mapped == 0) {
+			/*
+			 * We didn't find another matching target, so we
+			 * will add this target to our list of devices to be
+			 * mapped.
+			 */
+			list_add_tail(&target->all_domain_targets, &map_list);
+		}
+	}
+
+	/*
+	 * Walk down the list of targets to be mapped, and map them.
+	 */
+	list_for_each_entry_safe(target, tmp_target, &map_list,
+				 all_domain_targets) {
+
+		/*
+		 * Only present end devices that didn't fail discovery
+		 * to the OS.
+		 */
+		if ((target->management_type != ASD_DEVICE_END) || 
+		    (target->command_set_type == ASD_COMMAND_SET_BAD)) {
+			continue;
+		}
+
+		if (target->flags & ASD_TARG_MAPPED) {
+			continue;
+		}
+
+		target->flags |= ASD_TARG_NEEDS_MAP;
+
+	}
+
+	list_move_all(discover_list, &map_list);
+}
+
+void
+asd_remap_device(struct asd_softc *asd,
+		 struct asd_target *target, struct asd_target *multipath_target)
+{
+	unsigned i;
+	struct asd_domain *dm;
+
+	if ((target->flags & ASD_TARG_MAPPED) == 0) {
+		return;
+	}
+
+	multipath_target->flags |= ASD_TARG_MAPPED;
+
+	target->flags &= ~ASD_TARG_MAPPED;
+
+	dm = target->domain;
+
+	if (multipath_target->target_id != ASD_MAX_TARGET_IDS) {
+		/* The target ID was assigned in the discover code,
+		 * possibly via querying an SES device.
+		 */
+		if (dm->targets[multipath_target->target_id] == NULL) {
+			dm->targets[multipath_target->target_id] =
+			    multipath_target;
+		} else if (dm->targets[multipath_target->target_id]
+			   != multipath_target) {
+			asd_dprint("oops: target with id %d already exists\n",
+				   multipath_target->target_id);
+			return;
+		}
+	} else {
+#ifndef NO_SES_SUPPORT
+		for (i = 128; i < ASD_MAX_TARGET_IDS; i++) {
+#else
+		for (i = 0; i < (ASD_MAX_TARGET_IDS - 128); i++) {
+#endif
+			if (dm->targets[i] != target)
+				continue;
+			dm->targets[i] = multipath_target;
+			multipath_target->target_id = i;
+			break;
+		}
+	}
+
+	multipath_target->domain = dm;
+	multipath_target->refcount = target->refcount;
+
+	target->domain = NULL;
+
+	for (i = 0; i < ASD_MAX_LUNS; i++) {
+
+		if (target->devices[i] == NULL) {
+			continue;
+		}
+
+		multipath_target->devices[i] = target->devices[i];
+		multipath_target->devices[i]->target = multipath_target;
+#ifdef MULTIPATH_IO
+		multipath_target->devices[i]->current_target = multipath_target;
+#endif
+	}
+}
+
+/*
+ * At this point, all targets are either on their port->target list or on
+ * the context discover_list.  There can be more than one discovery going on
+ * simulataneously, but each one will call asd_validate_targets when it 
+ * completes.
+ */
+static void asd_validate_targets_init(struct asd_softc *asd)
+{
+	struct asd_target *target;
+	struct asd_target *tmp_target;
+	struct asd_port *port;
+	unsigned port_id;
+	struct list_head map_list;
+#ifdef OCM_REMAP
+	unsigned i;
+	struct asd_phy *phy;
+	struct asd_unit_element_format *punit_elm;
+	struct asd_uid_lu_naa_wwn *punit_id_lun;
+	struct asd_uid_lu_sata_model_num *punit_id_dir_sata;
+#endif
+
+	INIT_LIST_HEAD(&map_list);
+
+	/*
+	 * This code has been turned off in favor of using labels or UUIDS to
+	 * determine drive to filesystem mapping.
+	 */
+#ifdef OCM_REMAP
+	/*
+	 * Do one pass through the OCM structure that was passed by the BIOS.
+	 * The devices will go at the head of the "map_list".  Since these
+	 * devices are going on the list first, they will also be the exported
+	 * targets if we find duplicates later.
+	 */
+	for (i = 0; i < asd->num_unit_elements; i++) {
+
+		punit_elm = &asd->unit_elements[i];
+
+		switch (punit_elm->type) {
+		case UNELEM_LU_SATA_MOD_SERIAL_NUM:
+			punit_id_dir_sata = (struct asd_uid_lu_sata_model_num *)
+			    punit_elm->id;
+
+#if 0
+			printk("%s:%d: UNIT_ELEMENT_DIRECT_ATTACHED_SATA "
+			       "phy ID %d\n", __FUNCTION__, __LINE__,
+			       punit_id_dir_sata->phy_id);
+#endif
+
+			port = NULL;
+			phy = NULL;
+
+			for (port_id = 0; port_id < asd->hw_profile.max_ports;
+			     port_id++) {
+
+				port = asd->port_list[port_id];
+
+				list_for_each_entry(phy,
+						    &port->phys_attached,
+						    links) {
+
+					if (phy->id ==
+					    punit_id_dir_sata->phy_id) {
+						break;
+					}
+				}
+			}
+			if (port_id != asd->hw_profile.max_ports) {
+				if (list_empty(&port->targets_to_validate)) {
+					target =
+					    list_entry(port->
+						       targets_to_validate.next,
+						       struct asd_target,
+						       all_domain_targets);
+
+					target->flags |= ASD_TARG_ONLINE;
+
+					list_del_init(&target->
+						      all_domain_targets);
+
+					list_add_tail(&target->
+						      all_domain_targets,
+						      &map_list);
+
+					target->flags |= ASD_TARG_MAP_BOOT;
+				} else {
+					printk("Warning: no devices on target "
+					       "list for phy %d\n", phy->id);
+				}
+			} else {
+				printk("Warning: could not find direct phy ID "
+				       "matching %d\n",
+				       punit_id_dir_sata->phy_id);
+			}
+			break;
+		case UNELEM_LU_NAA_WWN:
+			punit_id_lun = (struct asd_uid_lu_naa_wwn *)
+			    punit_elm->id;
+
+#if 0
+			printk("%s:%d: UNIT_ELEMENT_LOGICAL_UNIT %llx\n",
+			       __FUNCTION__, __LINE__,
+			       asd_be64toh(*((uint64_t *) punit_id_lun->
+					     sas_address)));
+#endif
+
+			target = NULL;
+
+			for (port_id = 0; port_id < asd->hw_profile.max_ports;
+			     port_id++) {
+
+				port = asd->port_list[port_id];
+
+				target =
+				    asd_find_target(&port->targets_to_validate,
+						    punit_id_lun->sas_address);
+
+				if (target != NULL) {
+					break;
+				}
+			}
+
+			if (target != NULL) {
+				target->flags |= ASD_TARG_ONLINE;
+
+				list_del_init(&target->all_domain_targets);
+
+				list_add_tail(&target->all_domain_targets,
+					      &map_list);
+
+				target->flags |= ASD_TARG_MAP_BOOT;
+			} else {
+				printk("Warning: Couldn't find "
+				       "UNIT_ELEMENT_LOGICAL_UNIT %llx\n",
+				       asd_be64toh(*((uint64_t *) punit_id_lun->
+						     sas_address)));
+			}
+
+			break;
+		case UNELEM_VOLUME_SET_DDF_GUID:
+			printk("%s:%d: UNIT_ELEMENT_VOLUME_SET\n",
+			       __FUNCTION__, __LINE__);
+			break;
+
+		case UNELEM_LU_SGPIO:
+			printk("%s:%d: UNELEM_LU_SGPIO\n",
+			       __FUNCTION__, __LINE__);
+			break;
+
+		case UNELEM_LU_SAS_TOPOLOGY:
+			printk("%s:%d: UNELEM_LU_SAS_TOPOLOGY\n",
+			       __FUNCTION__, __LINE__);
+			break;
+		}
+
+	}
+#endif
+
+	/*
+	 * Now go through the devices that are left and put them on our list
+	 * of potential devices to be exported to the OS.
+	 */
+	for (port_id = 0; port_id < asd->hw_profile.max_ports; port_id++) {
+
+		port = asd->port_list[port_id];
+
+		list_for_each_entry_safe(target, tmp_target,
+					 &port->targets_to_validate,
+					 all_domain_targets) {
+
+			target->flags |= ASD_TARG_ONLINE;
+
+			if (target->management_type == ASD_DEVICE_END) {
+				target->flags |= ASD_TARG_NEEDS_MAP;
+			}
+//JD
+			else
+			{
+				asd_log(ASD_DBG_INFO, "port_id (0x%x) target->management_type (0x%x) is not end_device\n",port_id,target->management_type);
+			}
+			list_del_init(&target->all_domain_targets);
+
+			list_add_tail(&target->all_domain_targets, &map_list);
+		}
+	}
+
+	asd_mark_duplicates(asd, &map_list);
+
+	list_for_each_entry_safe(target, tmp_target,
+				 &map_list, all_domain_targets) {
+
+		list_del_init(&target->all_domain_targets);
+
+		if ((target->flags & ASD_TARG_NEEDS_MAP) != 0) {
+
+			target->flags &= ~ASD_TARG_NEEDS_MAP;
+
+			if (asd_map_multipath(asd, target) != 0) {
+				// TODO: fix potential leak
+
+				continue;
+			}
+		}
+
+		list_add_tail(&target->all_domain_targets,
+			      &target->src_port->targets);
+	}
+
+	return;
+}
+
+static void
+asd_validate_targets_hotplug(struct asd_softc *asd,
+			     struct asd_port *port,
+			     struct asd_DiscoverySM_Context *ctx)
+{
+	struct asd_target *target;
+	struct asd_target *tmp_target;
+	struct asd_target *multipath_target;
+
+	INIT_LIST_HEAD(&port->targets_to_validate);
+
+	/*
+	 * Go through the old discover list and see if any devices that 
+	 * have been removed.  If this is our first time through the discovery
+	 * process, then there will be nothing on the old_discover_list.  The
+	 * old_discover_list has all of the devices that were seen in a
+	 * previous discover, but are no longer present.
+	 */
+	list_for_each_entry_safe(target, tmp_target,
+				 &ctx->old_discover_list, all_domain_targets) {
+
+		list_del_init(&target->all_domain_targets);
+
+		list_add_tail(&target->validate_links,
+			      &port->targets_to_validate);
+
+		/* 
+		 * The target was previously seen and now has gone missing.
+		 */
+		target->flags |= ASD_TARG_HOT_REMOVED;
+
+		multipath_target = asd_find_target_ident(&ctx->discover_list,
+							 target);
+
+		if (multipath_target != NULL) {
+
+			/*
+			 * If there were multiple paths to the same device,
+			 * then don't report this device as removed;
+			 */
+			asd_remap_device(asd, target, multipath_target);
+
+			continue;
+		}
+
+		multipath_target = asd_find_multipath(asd, target);
+
+		if (multipath_target != NULL) {
+
+			/*
+			 * If there were multiple paths to the same device,
+			 * then don't report this device as removed;
+			 */
+			asd_remap_device(asd, target, multipath_target);
+		}
+
+		if (!list_empty(&target->multipath)) {
+			multipath_target = list_entry(target->multipath.next,
+						      struct asd_target,
+						      multipath);
+
+			asd_remap_device(asd, target, multipath_target);
+
+			/*
+			 * This device wasn't in the target list because it
+			 * was a multipath.  Add it to the list.
+			 */
+			list_add_tail(&multipath_target->all_domain_targets,
+				      &multipath_target->src_port->targets);
+
+			target->flags &= ~ASD_TARG_MAPPED;
+		}
+	}
+
+	asd_mark_duplicates(asd, &ctx->discover_list);
+
+	list_for_each_entry_safe(target, tmp_target, &ctx->discover_list,
+				 all_domain_targets) {
+
+		if (((target->flags & ASD_TARG_ONLINE) == 0) &&
+		    (target->flags & ASD_TARG_RESEEN)) {
+
+			/*
+			 * Previously seen target.
+			 * Set target state to ONLINE.
+			 */
+			target->flags &= ~ASD_TARG_RESEEN;
+			target->flags |= ASD_TARG_ONLINE;
+
+			continue;
+		}
+
+		if ((target->flags & ASD_TARG_NEEDS_MAP) == 0) {
+			/*
+			 * If the device is not an end device, then
+			 * ASD_TARG_NEEDS_MAP will never be set.
+			 */
+			continue;
+		}
+
+		target->flags &= ~ASD_TARG_NEEDS_MAP;
+
+		if (asd_map_multipath(asd, target) == 0) {
+			/*
+			 * New target found.
+			 */
+			target->flags |= ASD_TARG_HOT_ADDED;
+
+			list_add_tail(&target->validate_links,
+				      &port->targets_to_validate);
+		} else {
+			/*
+			 * The target was not mapped.  It might have been
+			 * already mapped, so don't include it in our list
+			 * of new targets.
+			 */
+			list_del_init(&target->all_domain_targets);
+		}
+	}
+
+	INIT_LIST_HEAD(&ctx->old_discover_list);
+
+	/*
+	 * Set the flag that targets validation is required.
+	 */
+	port->events |= ASD_VALIDATION_REQ;
+}
+
+/* -------------------------------------------------------------------------- */
+
+#if DISCOVER_DEBUG
+void asd_debug_indent(unsigned indent)
+{
+	unsigned i;
+
+	for (i = 0; i < indent; i++) {
+		asd_print("|  ");
+	}
+}
+static void
+asd_dump_tree_internal(struct asd_softc *asd,
+		       struct asd_port *port,
+		       struct asd_target *target,
+		       unsigned indent, unsigned phy_num)
+{
+	struct Discover *discover;
+	struct asd_target *child_target;
+	unsigned i;
+
+	asd_debug_indent(indent);
+
+	asd_print("+ Phy %d:", phy_num);
+
+	asd_print(" Addr: %0llx - ",
+		  asd_be64toh(*((uint64_t *) target->ddb_profile.sas_addr)));
+
+	asd_print_conn_rate(target->ddb_profile.conn_rate, "|");
+
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_SCSI:
+		asd_print("SCSI|");
+		break;
+	case ASD_COMMAND_SET_ATA:
+		asd_print("ATA|");
+		break;
+	case ASD_COMMAND_SET_ATAPI:
+		asd_print("ATAPI|");
+		break;
+	case ASD_COMMAND_SET_SMP:
+		asd_print("SMP|");
+		break;
+	default:
+		asd_print("Unknown (%u)|", (unsigned)target->command_set_type);
+		break;
+	}
+	switch (target->device_protocol_type) {
+	case ASD_DEVICE_PROTOCOL_SCSI:
+		asd_print("SCSI|");
+		break;
+	case ASD_DEVICE_PROTOCOL_ATA:
+		asd_print("ATA|");
+		break;
+	case ASD_DEVICE_PROTOCOL_SMP:
+		asd_print("SMP|");
+		break;
+	default:
+		asd_print("Unknown (%u)|",
+			  (unsigned)target->device_protocol_type);
+		break;
+	}
+
+	switch (target->transport_type) {
+	case ASD_TRANSPORT_SSP:
+		asd_print("SSP|");
+		break;
+	case ASD_TRANSPORT_SMP:
+		asd_print("SMP|");
+		break;
+	case ASD_TRANSPORT_STP:
+		asd_print("STP|");
+		break;
+	case ASD_TRANSPORT_ATA:
+		asd_print("ATA|");
+		break;
+	default:
+		asd_print("Unknown (%u)|", (unsigned)target->transport_type);
+		break;
+	}
+
+	switch (target->management_type) {
+	case ASD_DEVICE_END:
+		asd_print("END_DEVICE");
+		break;
+	case ASD_DEVICE_FANOUT_EXPANDER:
+		asd_print("FANOUT_DEVICE");
+		break;
+	case ASD_DEVICE_EDGE_EXPANDER:
+		asd_print("EXPANDER_DEVICE");
+		break;
+	default:
+		asd_print("Unknown (%u)", (unsigned)target->management_type);
+		break;
+	}
+
+	asd_print("\n");
+
+	if (target->transport_type != ASD_TRANSPORT_SMP) {
+		return;
+	}
+
+	asd_debug_indent(indent);
+
+	asd_print("| Number of Phys: %d\n", target->num_phys);
+
+	discover = NULL;
+
+	indent++;
+
+	list_for_each_entry(child_target, &target->children, siblings) {
+
+		for (i = 0; i < target->num_phys; i++) {
+
+			discover = &(target->Phy[i].Result);
+
+			if (SAS_ISEQUAL(child_target->ddb_profile.sas_addr,
+					discover->AttachedSASAddress)) {
+				break;
+			}
+		}
+
+		if (i == target->num_phys) {
+			continue;
+		}
+
+		asd_dump_tree_internal(asd, port, child_target, indent, i);
+	}
+}
+
+static void asd_dump_tree(struct asd_softc *asd, struct asd_port *port)
+{
+	struct asd_target *target;
+	struct state_information *state_infop;
+
+	SETUP_STATE(&port->dc.sm_context);
+
+	if (!list_empty(&port->targets)) {
+
+		target = port->tree_root;
+
+		asd_dump_tree_internal(asd, port, target, 1, 0);
+	}
+}
+
+#if KDB_ENABLE
+extern struct list_head asd_hbas;
+
+void asd_dump_sas_state(void)
+{
+	unsigned i;
+	struct asd_softc *asd;
+
+	printk("%s:%d --\n", __FUNCTION__, __LINE__);
+
+	list_for_each_entry(asd, &asd_hbas, link) {
+		for (i = 0; i < asd->hw_profile.max_ports; i++) {
+			if (asd->port_list[i] != NULL) {
+				asd_dump_tree(asd, asd->port_list[i]);
+			}
+		}
+	}
+}
+
+void asd_kdb_init(void)
+{
+	kdb_register("sas", (void *)asd_dump_sas_state, "",
+		     "Dumps the SAS state", 0);
+}
+
+void asd_kdb_exit(void)
+{
+	kdb_unregister("sas");
+}
+#endif /* KDB_ENABLE */
+#endif /* DISCOVER_DEBUG */
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_discover.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_discover.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_discover.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_discover.h	2007-04-05 23:37:45.000000000 +0000
@@ -0,0 +1,1341 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux. 
+ *
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Modified by : Robert Tarte  <robt@PacificCodeWorks.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * This code is adapted from: SASDiscoverSimulation.h
+ *
+ * $Id$
+ * 
+ */
+#ifndef ADP94XX_DISCOVER_H
+#define ADP94XX_DISCOVER_H
+
+// state machine stack
+// push a new state machine stack
+// always operate the top state machine until it completes
+// pop state machine and call post routine
+
+typedef enum {
+	DISCOVER_OK,
+	DISCOVER_FAILED,
+	DISCOVER_CONTINUE,
+	DISCOVER_FINISHED
+} DISCOVER_RESULTS;
+
+#define STATE_STACK_SIZE	(20 * sizeof(unsigned long))
+#define STATE_MACHINE_DEPTH	5
+
+struct state_information {
+	uint32_t		current_state;
+	struct state_machine	*state_machine_p;
+	uint8_t			stack[STATE_STACK_SIZE];
+	int32_t	 		stack_top;
+};
+
+struct state_machine_context;
+typedef void			(*StateMachineWakeupFunction)(
+					struct state_machine_context *);
+
+struct state_machine_context {
+	int8_t				state_stack_top;
+	struct state_information	state_stack[STATE_MACHINE_DEPTH];
+	void 				*state_handle;
+	StateMachineWakeupFunction	wakeup_state_machine;
+};
+
+typedef DISCOVER_RESULTS	(*DiscoveryFunction)(
+					struct state_machine_context *);
+
+typedef DISCOVER_RESULTS	(*VDiscoveryFunction)(
+					struct state_machine_context *,
+					void *);
+
+typedef void			(*DiscoveryFinishFunction)(
+					struct state_machine_context *,
+					DISCOVER_RESULTS);
+
+typedef void			(*DiscoveryAbortFunction)(
+					struct state_machine_context *);
+
+struct state_machine {
+	VDiscoveryFunction	initialize;
+	DiscoveryFunction	state_machine;
+	DiscoveryFinishFunction	finish;
+	DiscoveryAbortFunction	abort;
+	unsigned		first_state;
+};
+
+#define SASCPY(dest, src)	*((uint64_t *)dest) = *((uint64_t *)src)
+#define SAS_ISEQUAL(sas1, sas2)	(*((uint64_t *)sas1) == *((uint64_t *)sas2))
+#define SAS_ISZERO(sas)		(*((uint64_t *)sas) == 0)
+#define SAS_ZERO(sas)		*((uint64_t *)sas) = 0
+
+#define SETUP_STATE(sm_contextp)					    \
+	state_infop = &(sm_contextp)->state_stack[			    \
+		(sm_contextp)->state_stack_top];
+
+#define GET_STATE_CONTEXT(sm_contextp, context)				    \
+	SETUP_STATE(sm_contextp);					    \
+	context = (typeof(context))&state_infop->stack[0];
+
+#define NEW_CONTEXT(context)						    \
+	state_infop = &sm_contextp->state_stack[sm_contextp->state_stack_top]; \
+	context = (typeof(context))&state_infop->stack[0];		    \
+	state_infop->stack_top += sizeof(*context);			    \
+	if (state_infop->stack_top >= STATE_STACK_SIZE)	{		    \
+		printk("state stack overrun\n");			    \
+	}								    \
+
+#define PUSH_STACK(var) {						    \
+	*((typeof(var) *)&state_infop->stack[state_infop->stack_top]) = var;\
+	state_infop->stack_top += sizeof(var);				    \
+	if (state_infop->stack_top >= STATE_STACK_SIZE)	{		    \
+		printk("state stack overrun\n");			    \
+	}								    \
+}
+
+#define PUSH_STACK_ARRAY(var) {						    \
+	memcpy((void *)&state_infop->stack[state_infop->stack_top], 	    \
+		(void *)var, sizeof(var));				    \
+	state_infop->stack_top += sizeof(var);				    \
+	if (state_infop->stack_top >= STATE_STACK_SIZE)	{		    \
+		printk("state stack overrun\n");			    \
+	}								    \
+}
+
+#define POP_STACK(var) {						    \
+	state_infop->stack_top -= sizeof(var);				    \
+	if (state_infop->stack_top < 0)	{				    \
+		printk("state stack underrun\n");			    \
+	}								    \
+	var = *((typeof(var) *)&state_infop->stack[state_infop->stack_top]);\
+}
+
+#define POP_STACK_ARRAY(var) {						    \
+	state_infop->stack_top -= sizeof(var);				    \
+	if (state_infop->stack_top < 0)	{				    \
+		printk("state stack underrun\n");			    \
+	}								    \
+	memcpy((void *)var, (void *)&state_infop->stack[		    \
+		state_infop->stack_top], sizeof(var));			    \
+}
+
+#define PUT_STACK(var)							    \
+	*((typeof(var) *)&state_infop->stack[var##_addr]) = var;
+	
+#define PUT_STACK_ARRAY(var)						    \
+	memcpy((void *)&state_infop->stack[var##_addr], (void *)var,	    \
+		sizeof(var))
+
+#define VAR_REF(var)							    \
+	(typeof(var) *)&state_infop->stack[var##_addr]
+	
+
+#define RETURN_STACK(var) {						    \
+	struct state_information	*prev_state_infop;		    \
+	prev_state_infop = &sm_contextp->state_stack[			    \
+		sm_contextp->state_stack_top - 1];			    \
+	*((typeof(var) *)&prev_state_infop->stack[			    \
+		prev_state_infop->stack_top]) =	var;			    \
+	prev_state_infop->stack_top += sizeof(var);			    \
+	if (prev_state_infop->stack_top >= STATE_STACK_SIZE)	{	    \
+		printk("state stack overrun\n");			    \
+	}								    \
+}
+
+#define POP_STATE(sm_contextp)						    \
+	sm_contextp->state_stack_top--;					    \
+	state_infop = &sm_contextp->state_stack[sm_contextp->state_stack_top];
+
+#define GET_CURRENT_STATE()		state_infop->current_state
+
+
+
+typedef enum {
+	// Overall discovery state machine
+	ASD_STATE_DISCOVER_START = 0x100,
+	ASD_STATE_DISCOVER_ATTACHED,
+	ASD_STATE_FIND_BOUNDARY,
+	ASD_STATE_CONFIG_BOUNDARY_SET,
+	ASD_STATE_CONFIG_ATTACHED_SET,
+	ASD_STATE_SATA_SPINHOLD,
+	ASD_STATE_INIT_SATA,
+	ASD_STATE_INIT_SAS,
+	ASD_STATE_INIT_SMP,
+	ASD_STATE_FINISHED,
+	ASD_STATE_FAILED,
+
+	// General Report and Discover state machine 
+	ASD_STATE_REPORT_AND_DISCOVER_START = 0x200,
+	ASD_STATE_ISSUE_REPORT_GENERAL,
+	ASD_STATE_ISSUE_DISCOVER_LOOP,
+	ASD_STATE_REPORT_AND_DISCOVER_FINISHED,
+	ASD_STATE_REPORT_AND_DISCOVER_FAILED,
+
+	// Find Boundary state machine
+	ASD_STATE_FIND_BOUNDARY_START = 0x300,
+	ASD_STATE_FIND_BOUNDARY_LOOP,
+	ASD_STATE_FIND_BOUNDARY_FINISHED,
+	ASD_STATE_FIND_BOUNDARY_FAILED,
+
+	// Configure Set state machine
+	ASD_STATE_CONFIG_SET_START = 0x400,
+	ASD_STATE_CONFIG_SET_ISSUE_DISCOVER,
+	ASD_STATE_CONFIG_SET_CONFIGURE_EXPANDER,
+	ASD_STATE_CONFIG_SET_FINISHED,
+	ASD_STATE_CONFIG_SET_FAILED,
+
+	// Configure Expander state machine
+	ASD_STATE_CONFIG_EXPANDER_START = 0x500,
+	ASD_STATE_CONFIG_EXPANDER_ROUTE,
+	ASD_STATE_CONFIG_EXPANDER_ROUTE_LOOP,
+	ASD_STATE_CONFIG_EXPANDER_FINISHED,
+	ASD_STATE_CONFIG_EXPANDER_FAILED,
+
+	// SATA initialization state machine
+	ASD_STATE_INIT_SATA_START = 0x600,
+	ASD_STATE_INIT_SATA_REPORT_PHY,
+	ASD_STATE_INIT_SATA_IDENTIFY,
+	ASD_STATE_INIT_SATA_CONFIGURE_FEATURES,
+	ASD_STATE_INIT_SATA_FINISHED,
+	ASD_STATE_INIT_SATA_FAILED,
+
+	// SATA release spinhold state machine
+	ASD_STATE_SATA_SPINHOLD_START = 0x700,
+	ASD_STATE_SATA_SPINHOLD_PHY_CONTROL,
+	ASD_STATE_SATA_SPINHOLD_DISCOVER,
+	ASD_STATE_SATA_SPINHOLD_FINISHED,
+	ASD_STATE_SATA_SPINHOLD_FAILED,
+
+	// SAS initialization state machine
+	ASD_STATE_INIT_SAS_START = 0x800,
+	ASD_STATE_INIT_SAS_INQUIRY,
+	ASD_STATE_INIT_SAS_GET_DEVICE_ID,
+	ASD_STATE_INIT_SAS_GET_SERIAL_NUMBER,
+	ASD_STATE_INIT_SAS_ISSUE_REPORT_LUNS,
+	ASD_STATE_INIT_SAS_GET_PORT_CONTROL,
+	ASD_STATE_INIT_SAS_FINISHED,
+	ASD_STATE_INIT_SAS_FAILED,
+
+	// SMP initialization state machine
+	ASD_STATE_INIT_SMP_START = 0x900,
+	ASD_STATE_INIT_SMP_REPORT_MANUFACTURER_INFO,
+	ASD_STATE_INIT_SMP_FINISHED,
+	ASD_STATE_INIT_SMP_FAILED,
+
+	// Configure ATA devices
+	ASD_STATE_CONFIGURE_ATA_START = 0xA00,
+	ASD_STATE_CONFIGURE_ATA_FEATURES,
+	ASD_STATE_CONFIGURE_ATA_FINISHED,
+	ASD_STATE_CONFIGURE_ATA_FAILED
+
+} ASD_DISCOVERY_STATES;
+
+
+#if 0
+--------------------------
+// Level 1
+
+// Level 2
+typedef enum {
+	ASD_STATE_DISCOVER_ATTACHED_START,
+	ASD_STATE_DISCOVER_ATTACHED_DISCOVER,
+	ASD_STATE_DISCOVER_ATTACHED_DISCOVER_LOOP
+	ASD_STATE_DISCOVER_ATTACHED_FINISHED
+};
+
+// Level 2
+typdef enum {
+	ASD_STATE_FIND_BOUNDARY_START,
+	ASD_STATE_FIND_BOUNDARY_REPORT_GENERAL,
+	ASD_STATE_FIND_BOUNDARY_DISCOVER,
+	ASD_STATE_FIND_BOUNDARY_DISCOVER_LOOP,
+	ASD_STATE_FIND_BOUNDARY_FINISHED
+};
+
+// Level 2
+typedef enum {
+	ASD_STATE_CONFIG_BOUNDARY_SET_START,
+	ASD_STATE_DISCOVERY_DISCOVER_AND_CONFIG_BOUNDARY_SET,
+	ASD_STATE_DISCOVERY_CONFIG_DISCOVER,
+	ASD_STATE_DISCOVERY_CONFIG_DISCOVER_LOOP,
+	ASD_STATE_DISCOVERY_CONFIG_EXPANDER_PHY,
+	ASD_STATE_DISCOVERY_CONFIG_ROUTE_LOOP,
+	ASD_STATE_DISCOVERY_CONFIG_ROUTE_INDEX_LOOP,
+	ASD_STATE_DISCOVERY_CONFIG_EXPANDER_LOOP,
+	ASD_STATE_DISCOVERY_DISCOVER_AND_CONFIG_LOOP,
+	ASD_STATE_DISCOVERY_FINISHED,
+	ASD_STATE_DISCOVERY_FAILED
+} ASD_DISCOVERY_STATES;
+--------------------------
+#endif
+
+/*
+ * assume the maximum number of phys in an expander device is 128
+ */
+#define MAXIMUM_EXPANDER_PHYS			128
+
+/*
+ * assume the maximum number of indexes per phy is 128
+ */
+#define MAXIMUM_EXPANDER_INDEXES		128
+
+/*
+ * limit to 8 initiators for this example
+ */
+#define MAXIMUM_INITIATORS			8
+
+/*
+ * retry on SAS INQUIRY during discovery 
+*/
+#define MAX_SAS_INQUIRY_RETRY		2
+/*
+ * defines for address frame types
+ */
+#define ADDRESS_IDENTIFY_FRAME			0x00
+#define ADDRESS_OPEN_FRAME			0x01
+
+/*
+ * defines for SMP frame types
+ */
+#define SMP_REQUEST_FRAME			0x40
+#define SMP_RESPONSE_FRAME			0x41
+
+/*
+ * defines for SMP request functions
+ */
+#define REPORT_GENERAL				0x00
+#define REPORT_MANUFACTURER_INFORMATION		0x01
+#define DISCOVER				0x10
+#define REPORT_PHY_ERROR_LOG			0x11
+#define REPORT_PHY_SATA				0x12
+#define REPORT_ROUTE_INFORMATION		0x13
+#define CONFIGURE_ROUTE_INFORMATION		0x90
+#define PHY_CONTROL				0x91
+
+/*
+ * defines for the protocol bits
+ */
+#define SATA					0x01
+#define SMP					0x02
+#define STP					0x04
+#define SSP					0x08
+
+/*
+ * defines for open responses, arbitrary values, not defined in the spec
+ */
+#define OPEN_ACCEPT				0
+#define OPEN_REJECT_BAD_DESTINATION		1
+#define OPEN_REJECT_RATE_NOT_SUPPORTED		2
+#define OPEN_REJECT_NO_DESTINATION		3
+#define OPEN_REJECT_PATHWAY_BLOCKED		4
+#define OPEN_REJECT_PROTOCOL_NOT_SUPPORTED	5
+#define OPEN_REJECT_RESERVE_ABANDON		6
+#define OPEN_REJECT_RESERVE_CONTINUE		7
+#define OPEN_REJECT_RESERVE_INITIALIZE		8
+#define OPEN_REJECT_RESERVE_STOP		9
+#define OPEN_REJECT_RETRY			10
+#define OPEN_REJECT_STP_RESOURCES_BUSY		11
+#define OPEN_REJECT_WRONG_DESTINATION		12
+
+/*
+ * defines for INQUIRY VPD Page Device Identification (0x83)
+ */
+#define IDENTIFIER_TYPE_VENDOR_SPECIFIC		0x00
+#define IDENTIFIER_TYPE_T10			0x01
+#define IDENTIFIER_TYPE_EIU_64			0x02
+#define IDENTIFIER_TYPE_NAA			0x03
+#define IDENTIFIER_TYPE_RELATIVE_TARGET_PORT	0x04
+#define IDENTIFIER_TYPE_TARGET_PORT_GROUP	0x05
+#define IDENTIFIER_TYPE_LOGICAL_UNIT_GROUP	0x06
+#define IDENTIFIER_TYPE_MD5_LOGICAL_UNIT	0x07
+#define IDENTIFIER_TYPE_SCSI_NAME_STRING	0x08
+
+
+/*
+ * definitions for discovery algorithm use
+ */
+enum
+{
+	SAS_SIMPLE_LEVEL_DESCENT = 0,
+	SAS_UNIQUE_LEVEL_DESCENT
+};
+
+/*
+ * definitions for SMP function results
+ */
+enum SMPFunctionResult
+{
+	SMP_FUNCTION_ACCEPTED = 0,
+	SMP_UNKNOWN_FUNCTION,
+	SMP_FUNCTION_FAILED,
+	SMP_INVALID_REQUEST_FRAME_LENGTH,
+	SMP_PHY_DOES_NOT_EXIST = 0x10,
+	SMP_INDEX_DOES_NOT_EXIST,
+	SMP_PHY_DOES_NOT_SUPPORT_SATA,
+	SMP_UNKNOWN_PHY_OPERATION
+};
+
+/*
+ * DeviceTypes
+ */
+enum DeviceTypes
+{
+	NO_DEVICE = 0,
+	END_DEVICE,
+	EDGE_EXPANDER_DEVICE,
+	FANOUT_EXPANDER_DEVICE
+};
+
+/*
+ * RoutingAttribute
+ */
+enum RoutingAttribute
+{
+	DIRECT = 0,
+	SUBTRACTIVE,
+	TABLE
+};
+
+/*
+ * RouteFlag
+ */
+enum DisableRouteEntry
+{
+	ENABLED = 0,
+	DISABLED
+};
+
+/*
+ * PhyLinkRate(s)
+ */
+typedef enum
+{
+	RATE_UNKNOWN = 0,
+	PHY_DISABLED,
+	PHY_FAILED,
+	SPINUP_HOLD_OOB,
+	GBPS_1_5 = 8,
+	GBPS_3_0
+} PhysicalLinkRate;
+
+/*
+ * PhyOperation
+ */
+typedef enum
+{
+	SAS_NOP = 0,
+	LINK_RESET,
+	HARD_RESET,
+	DISABLE,
+	CLEAR_ERROR_LOG = 5,
+	CLEAR_AFFILIATION,
+	TRANSMIT_SATA_PORT_SELECTION
+} PhyOperation;
+
+/*
+ * the structures assume a char bitfield is valid, this is compiler
+ * dependent defines would be more portable, but less descriptive
+ * the Identify frame is exchanged following OOB, for this
+ * code it contains the identity information for the attached device
+ * and the initiator application client
+ */
+struct Identify
+{
+	// byte 0
+	uint8_t AddressFrame:4;	// ADDRESS_IDENTIFY_FRAME
+	uint8_t DeviceType:3;	// END_DEVICE
+				//
+
+	uint8_t RestrictedByte0Bit7:1;
+
+	// byte 1
+	uint8_t RestrictedByte1;
+
+	// byte 2
+	union
+	{
+		struct
+		{
+			uint8_t RestrictedByte2Bit0:1;
+			uint8_t SMPInitiator:1;
+			uint8_t STPInitiator:1;
+			uint8_t SSPInitiator:1;
+			uint8_t ReservedByte2Bit4_7:4;
+		};
+		uint8_t InitiatorBits;
+	};
+
+	// byte 3
+	union
+	{
+		struct
+		{
+			uint8_t RestrictedByte3Bit0:1;
+			uint8_t SMPTarget:1;
+			uint8_t STPTarget:1;
+			uint8_t SSPTarget:1;
+			uint8_t ReservedByte3Bit4_7:4;
+		};
+		uint8_t TargetBits;
+	};
+
+	// byte 4-11
+	uint8_t RestrictedByte4_11[8];
+
+	// byte 12-19
+	uint8_t SASAddress[8];
+
+	// byte 20
+	uint8_t PhyIdentifier;
+
+	// byte 21-23
+	uint8_t RestrictedByte20_23[3];
+
+	// byte 24-27
+	uint8_t ReservedByte24_27[4];
+
+	// byte 28-31
+	uint32_t CRC;
+} __packed;
+
+/*
+ * the Open address frame is used to send open requests
+ */
+struct OpenAddress
+{
+	// byte 0
+	uint8_t AddressFrame:4;		// ADDRESS_OPEN_FRAME
+	uint8_t Protocol:3;		// SMP
+					// STP
+					// SSP
+	uint8_t Initiator:1;
+
+	// byte 1
+	uint8_t ConnectionRate:4;		// GBPS_1_5
+
+	// GBPS_3_0
+	uint8_t Features:4;
+
+	// byte 2-3
+	uint16_t InitiatorConnectionTag;
+
+	// byte 4-11
+	uint8_t DestinationSASAddress[8];
+
+	// byte 12-19
+	uint8_t SourceSASAddress[8];
+
+	// byte 20
+	uint8_t CompatibleFeatures;
+
+	// byte 21
+	uint8_t PathwayBlockedCount;
+
+	// byte 22-23
+	uint16_t ArbitrationWaitTime;
+
+	// byte 24-27
+	uint8_t MoreCompatibleFeatures[4];
+
+	// byte 28-31
+	uint32_t CRC[4];
+} __packed;
+
+/*
+ * request specific bytes for a general input function
+ */
+struct SMPRequestGeneralInput
+{
+	// byte 4-7
+	uint32_t CRC;
+} __packed;
+
+/*
+ * request specific bytes for a phy input function
+ */
+struct SMPRequestPhyInput
+{
+	// byte 4-7
+	uint8_t IgnoredByte4_7[4];
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9
+	uint8_t PhyIdentifier;
+
+	// byte 10
+	uint8_t IgnoredByte10;
+
+	// byte 11
+	uint8_t ReservedByte11;
+
+	// byte 12-15
+	uint32_t CRC;
+} __packed;
+
+/*
+ * the ConfigureRouteInformation structure is used to provide the
+ * expander route entry for the expander route table, it is intended
+ * to be referenced by the SMPRequestConfigureRouteInformation struct
+ */
+struct ConfigureRouteInformation
+{
+	// byte 12
+	uint8_t IgnoredByte12Bit0_6:7;
+	uint8_t DisableRouteEntry:1;	// if a routing error is detected
+					// then the route is disabled by
+					// setting this bit
+
+	// byte 13-15
+	uint8_t IgnoredByte13_15[3];
+
+	// byte 16-23
+	uint8_t RoutedSASAddress[8];	// identical to the AttachedSASAddress
+					// found through discovery
+
+	// byte 24-35
+	uint8_t IgnoredByte24_35[12];
+
+	// byte 36-39
+	uint8_t ReservedByte36_39[4];
+} __packed;
+
+/*
+ * request specific bytes for SMP ConfigureRouteInformation function
+ */
+struct SMPRequestConfigureRouteInformation
+{
+	// byte 4-5
+	uint8_t ReservedByte4_5[2];
+
+	// byte 6-7
+	uint16_t ExpanderRouteIndex;
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9
+	uint8_t PhyIdentifier;
+
+	// byte 10-11
+	uint8_t ReservedByte10_11[2];
+
+	// byte 12-39
+	struct ConfigureRouteInformation Configure;
+
+	// byte 40-43
+	uint32_t CRC;
+} __packed;
+
+/*
+ * the PhyControlInformation structure is used to provide the
+ * expander phy control values, it is intended
+ * to be referenced by the SMPRequestPhyControl struct
+ */
+struct PhyControlInformation
+{
+	// byte 12-31
+	uint8_t IgnoredByte12_31[20];
+
+	// byte 32
+	uint8_t IgnoredByte32Bit0_3:4;
+	uint8_t ProgrammedMinimumPhysicalLinkRate:4;
+
+	// byte 33
+	uint8_t IgnoredByte33Bit0_3:4;
+	uint8_t ProgrammedMaximumPhysicalLinkRate:4;
+
+	// byte 34-35
+	uint8_t IgnoredByte34_35[2];
+
+	// byte 36
+	uint8_t PartialPathwayTimeoutValue:4;
+	uint8_t ReservedByte36Bit4_7:4;
+
+	// byte 37-39
+	uint8_t ReservedByte37_39[3];
+} __packed;
+
+/*
+ * request specific bytes for SMP Phy Control function
+ */
+struct SMPRequestPhyControl
+{
+	// byte 4-7
+	uint8_t IgnoredByte4_7[4];
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9
+	uint8_t PhyIdentifier;
+
+	// byte 10
+	uint8_t PhyOperation;
+
+	// byte 11
+	uint8_t UpdatePartialPathwayTimeoutValue:1;
+	uint8_t ReservedByte11Bit1_7:7;
+
+	// byte 12-39
+	struct PhyControlInformation Control;
+
+	// byte 40-43
+	uint32_t CRC;
+} __packed;
+
+/*
+ * generic structure referencing an SMP Request, must be initialized
+ * before being used
+ */
+struct SMPRequest
+{
+	// byte 0
+	uint8_t SMPFrameType;		// always SMP_REQUEST_FRAME
+
+	// byte 1
+	uint8_t Function;			// REPORT_GENERAL
+					// REPORT_MANUFACTURER_INFORMATION
+					// DISCOVER
+					// REPORT_PHY_ERROR_LOG
+					// REPORT_PHY_SATA
+					// REPORT_ROUTE_INFORMATION
+					// CONFIGURE_ROUTE_INFORMATION
+					// PHY_CONTROL
+
+	// byte 2-3
+	uint8_t ReservedByte2_3[2];
+
+	// byte 4-n
+	union
+	{
+		struct SMPRequestGeneralInput ReportGeneral;
+		struct SMPRequestGeneralInput ReportManufacturerInfo;
+		struct SMPRequestPhyInput Discover;
+		struct SMPRequestPhyInput ReportPhyErrorLog;
+		struct SMPRequestPhyInput ReportPhySATA;
+		struct SMPRequestPhyInput ReportRouteInformation;
+		struct SMPRequestConfigureRouteInformation ConfigureRouteInformation;
+		struct SMPRequestPhyControl PhyControl;
+	} Request;
+} __packed;
+
+/*
+ * request specific bytes for SMP Report General response, intended to be
+ * referenced by SMPResponse
+ */
+struct SMPResponseReportGeneral
+{
+	// byte 4-5
+	uint16_t ExpanderChangeCount;
+
+	// byte 6-7
+	uint16_t ExpanderRouteIndexes;
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9
+	uint8_t NumberOfPhys;
+
+	// byte 10
+	uint8_t ConfigurableRouteTable:1;
+	uint8_t Configuring:1;
+	uint8_t ReservedByte10Bit2_7:6;
+
+	// byte 11
+	uint8_t ReservedByte11;
+
+	// byte 12-15
+	uint32_t CRC;
+} __packed;
+
+/*
+ * request specific bytes for SMP Report Manufacturer Information response,
+ * intended to be referenced by SMPResponse
+ */
+struct SMPResponseReportManufacturerInfo
+{
+	// byte 4-7
+	uint8_t IgnoredByte4_7[4];
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9-10
+	uint8_t IgnoredByte9_10[2];
+
+	// byte 11
+	uint8_t ReservedByte11;
+
+	// byte 12-19
+	uint8_t VendorIdentification[8];
+
+	// byte 20-35
+	uint8_t ProductIdentification[16];
+
+	// byte 36-39
+	uint8_t ProductRevisionLevel[4];
+
+	// byte 40-59
+	uint8_t VendorSpecific[20];
+
+	// byte 60-63
+	uint32_t CRC;
+} __packed;
+
+/*
+ * the Discover structure is used to retrieve expander port information
+ * it is intended to be referenced by the SMPResponseDiscover structure
+ */
+struct Discover
+{
+	// byte 12
+	uint8_t ReservedByte12Bit0_3:4;
+	uint8_t AttachedDeviceType:3;
+	uint8_t IgnoredByte12Bit7:1;
+
+	// byte 13
+	uint8_t NegotiatedPhysicalLinkRate:4;
+	uint8_t ReservedByte13Bit4_7:4;
+
+	// byte 14
+	union
+	{
+		struct
+		{
+			uint8_t AttachedSATAHost:1;
+			uint8_t AttachedSMPInitiator:1;
+			uint8_t AttachedSTPInitiator:1;
+			uint8_t AttachedSSPInitiator:1;
+			uint8_t ReservedByte14Bit4_7:4;
+		};
+		uint8_t InitiatorBits;
+	};
+
+	// byte 15
+	union
+	{
+		struct
+		{
+			uint8_t AttachedSATADevice:1;
+			uint8_t AttachedSMPTarget:1;
+			uint8_t AttachedSTPTarget:1;
+			uint8_t AttachedSSPTarget:1;
+			uint8_t ReservedByte15Bit4_7:4;
+		};
+		uint8_t TargetBits;
+	};
+
+	// byte 16-23
+	uint8_t SASAddress[8];
+
+	// byte 24-31
+	uint8_t AttachedSASAddress[8];
+
+	// byte 32
+	uint8_t AttachedPhyIdentifier;
+
+	// byte 33-39
+	uint8_t ReservedByte33_39[7];
+
+	// byte 40
+	uint8_t HardwareMinimumPhysicalLinkRate:4;
+	uint8_t ProgrammedMinimumPhysicalLinkRate:4;
+
+	// byte 41
+	uint8_t HardwareMaximumPhysicalLinkRate:4;
+	uint8_t ProgrammedMaximumPhysicalLinkRate:4;
+
+	// byte 42
+	uint8_t PhyChangeCount;
+
+	// byte 43
+	uint8_t PartialPathwayTimeoutValue:4;
+	uint8_t IgnoredByte36Bit4_6:3;
+	uint8_t VirtualPhy:1;
+
+	// byte 44
+	uint8_t RoutingAttribute:4;
+	uint8_t ReservedByte44Bit4_7:4;
+
+	// byte 45-49
+	uint8_t ReservedByte45_49[5];
+
+	// byte 50-51
+	uint8_t VendorSpecific[2];
+
+	// byte 52-55
+	uint32_t CRC;
+} __packed;
+
+/*
+ * response specific bytes for SMP Discover, intended to be referenced by
+ * SMPResponse
+ */
+struct SMPResponseDiscover
+{
+	// byte 4-7
+	uint8_t IgnoredByte4_7[4];
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9
+	uint8_t PhyIdentifier;
+
+	// byte 10
+	uint8_t IgnoredByte10;
+
+	// byte 11
+	uint8_t ReservedByte11;
+
+	// byte 12-55
+	struct Discover Result;
+} __packed;
+
+/*
+ * response specific bytes for SMP Report Phy Error Log, intended to be
+ * referenced by SMPResponse
+ */
+struct SMPResponseReportPhyErrorLog
+{
+	// byte 4-7
+	uint8_t IgnoredByte4_7[4];
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9
+	uint8_t PhyIdentifier;
+
+	// byte 10
+	uint8_t IgnoredByte10;
+
+	// byte 11
+	uint8_t ReservedByte11;
+
+	// byte 12-15
+	uint32_t InvalidDuint16_tCount;
+
+	// byte 16-19
+	uint32_t DisparityErrorCount;
+
+	// byte 20-23
+	uint32_t LossOfDuint16_tSynchronizationCount;
+
+	// byte 24-27
+	uint32_t PhyResetProblemCount;
+
+	// byte 28-31
+	uint32_t CRC;
+} __packed;
+
+/*
+ * this structure describes the Register Device to Host FIS defined in the
+ * SATA specification
+ */
+struct RegisterDeviceToHostFIS
+{
+	// byte 24
+	uint8_t FISType;
+
+	// byte 25
+	uint8_t ReservedByte25Bit0_5:6;
+	uint8_t Interrupt:1;
+	uint8_t ReservedByte25Bit7:1;
+
+	// byte 26
+	uint8_t Status;
+
+	// byte 27
+	uint8_t Error;
+
+	// byte 28
+	uint8_t SectorNumber;
+
+	// byte 29
+	uint8_t CylLow;
+
+	// byte 30
+	uint8_t CylHigh;
+
+	// byte 31
+	uint8_t DevHead;
+
+	// byte 32
+	uint8_t SectorNumberExp;
+
+	// byte 33
+	uint8_t CylLowExp;
+
+	// byte 34
+	uint8_t CylHighExp;
+
+	// byte 35
+	uint8_t ReservedByte35;
+
+	// byte 36
+	uint8_t SectorCount;
+
+	// byte 37
+	uint8_t SectorCountExp;
+
+	// byte 38-43
+	uint8_t ReservedByte38_43[6];
+} __packed;
+
+/*
+ * response specific bytes for SMP Report Phy SATA, intended to be
+ * referenced by SMPResponse
+ */
+struct SMPResponseReportPhySATA
+{
+	// byte 4-7
+	uint8_t IgnoredByte4_7[4];
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9
+	uint8_t PhyIdentifier;
+
+	// byte 10
+	uint8_t IgnoredByte10;
+
+	// byte 11
+	uint8_t AffilationValid:1;
+	uint8_t AffilationsSupported:1;
+	uint8_t ReservedByte11Bit2_7:6;
+
+	// byte 12-15
+	uint8_t ReservedByte12_15[4];
+
+	// byte 16-32
+	uint8_t STPSASAddress[8];
+
+	// byte 24-43
+	struct RegisterDeviceToHostFIS FIS;
+
+	// byte 44-47
+	uint8_t ReservedByte44_47[4];
+
+	// byte 48-55
+	uint8_t AffiliatedSTPInitiatorSASAddress[8];
+
+	// byte 56-59
+	uint32_t CRC;
+} __packed;
+
+struct ReportRouteInformation
+{
+	// byte 12
+	uint8_t IgnoredByte12Bit0_6:7;
+	uint8_t ExpanderRouteEntryDisabled:1;
+
+	// byte 13-15
+	uint8_t IgnoredByte13_15[3];
+
+	// byte 16-23
+	uint8_t RoutedSASAddress[8];
+
+	// byte 24-35
+	uint8_t IgnoredByte24_35[12];
+
+	// byte 36-39
+	uint8_t ReservedByte36_39[4];
+} __packed;
+
+/*
+ * response specific bytes for SMP Report Route Information, intended to be
+ * referenced by SMPResponse
+ */
+struct SMPResponseReportRouteInformation
+{
+	// byte 4-5
+	uint8_t IgnoredByte4_5[4];
+
+	// byte 6-7
+	uint16_t ExpanderRouteIndex;
+
+	// byte 8
+	uint8_t ReservedByte8;
+
+	// byte 9
+	uint8_t PhyIdentifier;
+
+	// byte 10
+	uint8_t IgnoredByte10;
+
+	// byte 11
+	uint8_t ReservedByte11;
+
+	// byte 12-39
+	struct ReportRouteInformation Result;
+
+	// byte 40-43
+	uint32_t CRC;
+} __packed;
+
+/*
+ * response specific bytes for SMP Configure Route Information,
+ * intended to be referenced by SMPResponse
+ */
+struct SMPResponseConfigureRouteInformation
+{
+	// byte 4-7
+	uint32_t CRC;
+} __packed;
+
+/*
+ * response specific bytes for SMP Phy Control,
+ * intended to be referenced by SMPResponse
+ */
+struct SMPResponsePhyControl
+{
+	// byte 4-7
+	uint32_t CRC;
+} __packed;
+
+/*
+ * generic structure referencing an SMP Response, must be initialized
+ * before being used
+ */
+struct SMPResponse
+{
+	// byte 0
+	uint8_t SMPFrameType;		// always 41h for SMP responses
+
+	// byte 1
+	uint8_t Function;
+
+	// byte 2
+	uint8_t FunctionResult;
+
+	// byte 3
+	uint8_t ReservedByte3;
+
+	// byte 4-n
+	union
+	{
+		struct SMPResponseReportGeneral ReportGeneral;
+		struct SMPResponseReportManufacturerInfo
+			ReportManufacturerInfo;
+		struct SMPResponseDiscover Discover;
+		struct SMPResponseReportPhyErrorLog ReportPhyErrorLog;
+		struct SMPResponseReportPhySATA ReportPhySATA;
+		struct SMPResponseReportRouteInformation ReportRouteInformation;
+		struct SMPResponseConfigureRouteInformation ConfigureRouteInformation;
+		struct SMPResponsePhyControl PhyControl;
+	} Response;
+} __packed;
+
+DISCOVER_RESULTS
+asd_smp_request(
+struct state_machine_context	*sm_contextp,
+struct asd_target		*target,
+unsigned			request_length,
+unsigned			response_length
+);
+
+void
+asd_destroy_discover_list(
+struct asd_softc	*asd,
+struct list_head	*discover_list
+);
+
+/* -------------------------------------------------------------------------- */
+
+struct asd_InitSMP_SM_Arguments {
+	struct list_head		*discover_listp;
+};
+
+struct asd_InitSAS_SM_Arguments {
+	struct list_head		*discover_listp;
+};
+
+struct asd_SATA_SpinHoldSM_Arguments {
+	struct list_head		*discover_listp;
+};
+
+struct asd_InitSATA_SM_Arguments {
+	struct list_head		*discover_listp;
+};
+
+struct asd_ConfigureATA_SM_Arguments {
+	struct asd_target		*target;
+};
+
+struct asd_ConfigureExpanderSM_Arguments {
+	struct list_head		*discover_listp;
+	struct asd_target		*newExpander;
+};
+
+struct asd_DiscoverConfigSetSM_Arguments {
+	struct list_head		*discover_listp;
+	struct list_head		*found_listp;
+	struct list_head		*old_discover_listp;
+	struct asd_target		*currentExpander;
+};
+
+struct asd_DiscoverFindBoundarySM_Arguments {
+	struct asd_target		*expander;
+	struct list_head		*found_listp;
+	struct list_head		*old_discover_listp;
+};
+
+struct asd_DiscoverExpanderSM_Arguments {
+	uint8_t				*sas_addr;
+	struct asd_target		*upstreamExpander;
+	unsigned			attachedDeviceType;
+	struct list_head		*old_discover_listp;
+	struct list_head		*found_listp;
+	unsigned			conn_rate;
+};
+
+extern struct state_machine asd_DiscoverySM;
+extern struct state_machine asd_DiscoverExpanderSM;
+extern struct state_machine asd_DiscoverFindBoundarySM;
+extern struct state_machine asd_DiscoverConfigSetSM;
+extern struct state_machine asd_ConfigureExpanderSM;
+extern struct state_machine asd_ConfigureATA_SM;
+extern struct state_machine asd_InitSATA_SM;
+extern struct state_machine asd_SATA_SpinHoldSM;
+extern struct state_machine asd_InitSAS_M;
+extern struct state_machine asd_InitSMP_M;
+
+DISCOVER_RESULTS
+asd_push_state_machine(
+struct state_machine_context	*sm_contextp,
+char				*s,
+struct state_machine		*state_machine_p,
+void				*arg
+);
+
+#define ASD_PUSH_STATE_MACHINE(sm_contextp, state_machine_p, arg)	\
+	asd_push_state_machine(sm_contextp, #state_machine_p,		\
+	state_machine_p, arg)
+
+
+#define STATE_MACHINE_DECLARATION(name) \
+DISCOVER_RESULTS		\
+name##_Initialize(		\
+struct state_machine_context *,	\
+void *				\
+);				\
+				\
+DISCOVER_RESULTS		\
+name##_StateMachine(		\
+struct state_machine_context *	\
+);				\
+				\
+void				\
+name##_Finish(			\
+struct state_machine_context *,	\
+DISCOVER_RESULTS		\
+);				\
+				\
+void				\
+name##_Abort(			\
+struct state_machine_context *	\
+);
+
+STATE_MACHINE_DECLARATION(asd_DiscoverySM);
+STATE_MACHINE_DECLARATION(asd_DiscoverExpanderSM);
+STATE_MACHINE_DECLARATION(asd_DiscoverFindBoundarySM);
+STATE_MACHINE_DECLARATION(asd_DiscoverConfigSetSM);
+STATE_MACHINE_DECLARATION(asd_ConfigureExpanderSM);
+STATE_MACHINE_DECLARATION(asd_InitSATA_SM);
+STATE_MACHINE_DECLARATION(asd_ConfigureATA_SM);
+STATE_MACHINE_DECLARATION(asd_SATA_SpinHoldSM);
+STATE_MACHINE_DECLARATION(asd_InitSAS_SM);
+STATE_MACHINE_DECLARATION(asd_InitSMP_SM);
+
+struct asd_target *
+asd_find_target(
+struct list_head	*discover_list,
+uint8_t			*SASAddress
+);
+
+DISCOVER_RESULTS
+asd_state_init_sata(
+struct state_machine_context	*sm_contextp
+);
+
+ASD_DISCOVERY_STATES
+asd_state_init_sata_post(
+struct state_machine_context	*sm_contextp
+);
+
+uint8_t
+asd_get_feature_to_enable(
+struct asd_target	*target,
+uint8_t			*sector_count
+);
+
+void
+asd_sata_identify_request_done(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+void
+asd_smp_request_done(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+void
+asd_ssp_request_done(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+void
+asd_sata_configure_features_done(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+#endif /* ADP94XX_DISCOVER_H */
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_hwi.c linux-2.6.16/drivers/scsi/adp94xx/adp94xx_hwi.c
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_hwi.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_hwi.c	2007-04-05 23:37:43.000000000 +0000
@@ -0,0 +1,6701 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ *
+ * Written by : David Chaw <david_chaw@adaptec.com>
+ * Modified by : Naveen Chandrasekaran <naveen_chandrasekaran@adaptec.com>
+ * 
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+
+#include "adp94xx_osm.h"
+#include "adp94xx_inline.h"
+#if KDB_ENABLE
+#include "linux/kdb.h"
+#endif
+
+/* Local functions' prototypes */
+static u_int	asd_sglist_allocsize(struct asd_softc *asd);
+static int	asd_hwi_init_scbdata(struct asd_softc *asd);
+static int	asd_hwi_reset_hw(struct asd_softc *asd);
+static void	asd_hwi_exit_hw(struct asd_softc *asd);
+static void	asd_hwi_setup_sw_bar(struct asd_softc *asd);
+static int	asd_hwi_init_phys(struct asd_softc *asd);
+static int	asd_hwi_init_ports(struct asd_softc *asd); 
+static void	asd_hwi_alloc_scbs(struct asd_softc *asd);
+static int	asd_hwi_init_sequencers(struct asd_softc *asd);
+static void	asd_hwi_process_dl(struct asd_softc *asd);
+static void	asd_hwi_build_id_frame(struct asd_phy *phy);
+static void	asd_hwi_build_smp_phy_req(struct asd_port *port, int req_type, 
+					  int phy_id, int ctx);
+
+/* SCB completion post routines. */
+static void	asd_hwi_process_phy_comp(struct asd_softc *asd, 
+					 struct scb *scb,
+					 struct control_phy_sb *cntrl_phy);
+static void	asd_hwi_process_edb(struct asd_softc *asd, 
+				    struct asd_done_list *dl_entry);
+static void	asd_hwi_process_prim_event(struct asd_softc *asd,
+					   struct asd_phy *phy,
+					   u_int reg_addr, u_int reg_content);
+static void	asd_hwi_process_phy_event(struct asd_softc *asd, 
+					  struct asd_phy *phy, u_int oob_status,
+					  u_int oob_mode);
+static void asd_hwi_process_timer_event(struct asd_softc *asd,
+					  struct asd_phy *phy, uint8_t	error);
+static void	asd_hwi_handle_link_rst_err(struct asd_softc *asd,
+					    struct asd_phy *phy);
+static void	asd_hwi_process_req_task(struct asd_softc *asd,
+					 uint8_t req_type, uint16_t index);
+
+/* Error Handling routines. */
+static void	asd_scb_eh_timeout(u_long arg);
+static void	asd_hwi_abort_scb(struct asd_softc *asd, 
+				  struct scb *scb_to_abort, struct scb *scb);
+static void	asd_hwi_reset_lu(struct asd_softc *asd, 
+				 struct scb *scb_to_reset, struct scb *scb);
+static void	asd_hwi_reset_device(struct asd_softc *asd, 
+				     struct scb *scb_to_reset, struct scb *scb);
+static void	asd_hwi_resume_sendq(struct asd_softc *asd, 
+				     struct scb *scb_to_reset, struct scb *scb);
+static void asd_hwi_resume_sendq_done(struct asd_softc *asd, struct scb *scb,
+			  struct asd_done_list *dl);
+static void	asd_hwi_reset_end_device(struct asd_softc *asd,
+					 struct scb *scb);
+static void	asd_hwi_reset_exp_device(struct asd_softc *asd,
+					 struct scb *scb);
+static void	asd_hwi_report_phy_err_log(struct asd_softc *asd,
+					   struct scb *scb);
+static void	asd_hwi_dump_phy_err_log(struct asd_port *port,
+					 struct scb *scb);
+static void	asd_hwi_reset_port(struct asd_softc *asd, 
+				   struct scb *scb_to_reset, struct scb *scb);
+
+static asd_scb_post_t	asd_hwi_abort_scb_done;
+static asd_scb_post_t	asd_hwi_reset_lu_done;
+static asd_scb_post_t	asd_hwi_reset_device_done;
+static asd_scb_post_t	asd_hwi_reset_end_device_done;
+static asd_scb_post_t	asd_hwi_reset_exp_device_done;
+static asd_scb_post_t	asd_hwi_reset_port_done;
+static asd_scb_eh_post_t asd_hwi_req_task_done;
+
+/* Function prototypes for NVRAM access utilites. */
+#if NVRAM_SUPPORT
+
+static int	asd_hwi_poll_nvram(struct asd_softc *asd);
+static int	asd_hwi_chk_write_status(struct asd_softc *asd, 
+					uint32_t sector_addr, 
+					uint8_t erase_flag); 
+static int	asd_hwi_reset_nvram(struct asd_softc *asd);
+int	asd_hwi_search_nv_cookie(struct asd_softc *asd, 
+			uint32_t *addr,
+			struct asd_flash_dir_layout *pflash_dir_buf);
+
+static int	asd_hwi_erase_nv_sector(struct asd_softc *asd, 
+					uint32_t  sector_addr);
+static int 	asd_hwi_verify_nv_checksum(struct asd_softc *asd, 
+					   u_int segment_id,
+					   uint8_t *segment_ptr, 
+					   u_int bytes_to_read);
+static int	asd_hwi_get_nv_config(struct asd_softc *asd);
+
+static int	asd_hwi_search_nv_id(struct asd_softc *asd, 
+				     u_int setting_id, 
+				     void *dest, u_int *src_offset, 
+				     u_int bytes_to_read);
+static int 	asd_hwi_get_nv_phy_settings(struct asd_softc *asd);
+static int 	asd_hwi_map_lrate_from_sas(u_int sas_link_rate, 
+					   u_int *asd_link_rate);
+static int 	asd_hwi_get_nv_manuf_seg(struct asd_softc *asd, void *dest, 
+					 uint32_t bytes_to_read,
+					 uint32_t *src_offset,
+					 uint16_t signature); 
+static void	asd_hwi_get_nv_phy_params(struct asd_softc *asd);
+
+static int asd_hwi_check_flash(struct asd_softc *asd); 
+
+#endif /* NVRAM_SUPPORT */
+
+/* OCM access routines */
+static int 	asd_hwi_get_ocm_info(struct asd_softc *asd);
+static int 	asd_hwi_get_ocm_entry(struct asd_softc *asd, 
+				      uint32_t entry_type,
+				      struct asd_ocm_entry_format *pocm_de, 
+				      uint32_t *src_offset);
+static int 	asd_hwi_read_ocm_seg(struct asd_softc *asd, void *dest,
+				     uint32_t src_offset, u_int bytes_to_read,
+				     u_int *bytes_read);
+static int 	asd_hwi_set_speed_mask(u_int asd_link_rate, 
+				       uint8_t *asd_speed_mask);
+
+#if SAS_COMSTOCK_SUPPORT
+static void	asd_hwi_get_rtl_ver(struct asd_softc *asd);
+#endif
+
+#ifdef ASD_TEST
+static void 	asd_hwi_dump_phy(struct asd_phy *phy);
+static void 	asd_hwi_dump_phy_id_addr(struct asd_phy *phy);
+#endif
+
+/*
+ * Function:
+ *	asd_sglist_allocsize
+ *
+ * Description:
+ * 	Calculate the optimum S/G List allocation size.  S/G elements used
+ *	for a given transaction must be physically contiguous.  Assume the
+ *	OS will allocate full pages to us, so it doesn't make sense to request
+ *	less than a page.
+ */
+static u_int
+asd_sglist_allocsize(struct asd_softc *asd)
+{
+	uint32_t sg_list_increment;
+	uint32_t sg_list_size;
+	uint32_t max_list_size;
+	uint32_t best_list_size;
+
+	/* Start out with the minimum required for ASD_NSEG. */
+	sg_list_increment = asd_sglist_size(asd);
+	sg_list_size = sg_list_increment;
+
+	/* Get us as close as possible to a page in size. */
+	while ((sg_list_size + sg_list_increment) <= PAGE_SIZE)
+		sg_list_size += sg_list_increment;
+
+	/*
+	 * Try to reduce the amount of wastage by allocating
+	 * multiple pages.
+	 */
+	best_list_size = sg_list_size;
+	max_list_size = roundup(sg_list_increment, PAGE_SIZE);
+	if (max_list_size < 4 * PAGE_SIZE)
+		max_list_size = 4 * PAGE_SIZE;
+	if (max_list_size > (ASD_MAX_ALLOCATED_SCBS * sg_list_increment))
+		max_list_size = (ASD_MAX_ALLOCATED_SCBS * sg_list_increment);
+	while ((sg_list_size + sg_list_increment) <= max_list_size
+	   &&  (sg_list_size % PAGE_SIZE) != 0) {
+		uint32_t new_mod;
+		uint32_t best_mod;
+
+		sg_list_size += sg_list_increment;
+		new_mod = sg_list_size % PAGE_SIZE;
+		best_mod = best_list_size % PAGE_SIZE;
+		if (new_mod > best_mod || new_mod == 0) {
+			best_list_size = sg_list_size;
+		}
+	}
+	return (best_list_size);
+}
+
+static int
+asd_hwi_init_scbdata(struct asd_softc *asd)
+{
+	struct scb	*scb;
+	u_int		 scb_cnt;
+	int		 loop_cnt;
+	asd->scbindex = asd_alloc_mem(
+				asd->hw_profile.max_scbs * sizeof(struct scb *),
+				GFP_ATOMIC);
+	if (asd->scbindex == NULL)
+		return (-ENOMEM);
+	
+	memset(asd->scbindex, 0x0, 
+	       asd->hw_profile.max_scbs * sizeof(struct scb *));
+	asd->init_level++;
+
+	asd->qinfifo = asd_alloc_mem(
+			   asd->hw_profile.max_scbs * sizeof(*asd->qinfifo),
+			   GFP_ATOMIC);
+
+	if (asd->qinfifo == NULL) {
+		asd_free_mem(asd->scbindex);
+		return (-ENOMEM);
+	}
+
+	asd->init_level++;
+	/*
+	 * Create our DMA tags.  These tags define the kinds of device
+	 * accessible memory allocations and memory mappings we will
+	 * need to perform during normal operation.
+	 */
+	/* DMA tag for our hardware scb structures */
+	if (asd_dma_tag_create(asd, 1, PAGE_SIZE, GFP_ATOMIC, 
+			       &asd->hscb_dmat) != 0) {
+		asd_hwi_exit_hw(asd);
+		goto error_exit;
+	}
+	asd->init_level++;
+
+	/* DMA tag for our S/G structures. */
+	if (asd_dma_tag_create(asd, 8, asd_sglist_allocsize(asd),
+			       GFP_ATOMIC, &asd->sg_dmat) != 0) {
+		asd_hwi_exit_hw(asd);
+		goto error_exit;
+	}
+	asd->init_level++;
+
+	/* Perform initial SCB allocation */
+	asd_hwi_alloc_scbs(asd);
+
+	if (asd->numscbs == 0) {
+		asd_print("%s: Unable to allocate initial scbs\n", 
+			  asd_name(asd));
+		asd_hwi_exit_hw(asd);
+		goto error_exit;
+	}
+	/* 
+	 * Make sure we are able to allocate more than the reserved 
+	 * SCB requirements.
+	 */
+	loop_cnt = 0;
+	while (asd->numscbs < ASD_RSVD_SCBS) {
+		/* 
+		 * Allocate SCB until we have more than the reserved SCBs
+		 * requirement.
+		 */
+		asd_hwi_alloc_scbs(asd);
+		if (++loop_cnt > 4)
+			break;
+	}
+
+	if (asd->numscbs < ASD_RSVD_SCBS) {
+		asd_log(ASD_DBG_ERROR, "Failed to allocate reserved pool of "
+			"SCBs.\n");
+		asd_hwi_exit_hw(asd);
+		goto error_exit;
+	}
+
+	scb_cnt = 0;
+	/* Save certain amount of SCBs as reserved. */
+	while (!list_empty(&asd->free_scbs)) {
+		scb = list_entry(asd->free_scbs.next, struct scb, hwi_links);
+		list_del(&scb->hwi_links);
+		list_add_tail(&scb->hwi_links, &asd->rsvd_scbs);
+		if (++scb_cnt > ASD_RSVD_SCBS)
+			break;
+	}
+#ifdef EXTENDED_SCB
+	{
+/* allocate memory for extended scb*/
+/* reserved 128 byte more for 128 bytes alignment*/
+		if (asd_alloc_dma_mem(asd, SCB_SIZE * (ASD_EXTENDED_SCB_NUMBER+1),
+			(void **)&asd->ext_scb_map.vaddr,
+			&asd->ext_scb_map.busaddr,
+			&asd->ext_scb_dmat,
+			&asd->ext_scb_map) != 0) {
+			asd_hwi_exit_hw(asd);
+			goto error_exit;
+		}
+#ifdef ASD_DEBUG
+		asd_print("EXTENDED_SCB is allocated\n");
+#endif
+
+	}
+#endif
+	return (0); 
+
+error_exit:
+	return (-ENOMEM);
+}
+
+/* 
+ * Function:
+ *	asd_alloc_softc()
+ *
+ * Description:
+ *	Allocate a softc structure and setup necessary fields.
+ */
+struct asd_softc *
+asd_alloc_softc(asd_dev_t dev)
+{
+	struct asd_softc	*asd;
+	
+	asd = asd_alloc_mem(sizeof(*asd), GFP_KERNEL);
+	if (asd == NULL) {
+		asd_log(ASD_DBG_ERROR, "Unable to alloc softc.\n");
+		return (NULL);
+	}
+	
+	memset(asd, 0x0, sizeof(*asd));
+	INIT_LIST_HEAD(&asd->rsvd_scbs);
+	INIT_LIST_HEAD(&asd->free_scbs);
+	INIT_LIST_HEAD(&asd->pending_scbs);
+	INIT_LIST_HEAD(&asd->timedout_scbs);
+	INIT_LIST_HEAD(&asd->empty_scbs);
+	INIT_LIST_HEAD(&asd->hscb_maps);
+	INIT_LIST_HEAD(&asd->sg_maps);
+	asd->dev = dev;
+
+	if (asd_platform_alloc(asd) != 0) {
+		asd_free_softc(asd);
+		asd = NULL;
+	}
+	return (asd);
+}
+
+/* 
+ * Function:
+ *	asd_free_softc()
+ *
+ * Description:
+ *	Free the host structure and any memory allocated for its member fields.
+ *	Also perform cleanup for module unloading purpose.
+ */
+void
+asd_free_softc(struct asd_softc *asd)
+{
+	asd_platform_free(asd);
+
+	/* Free any internal data structures */
+	asd_hwi_exit_hw(asd);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0) && \
+    LINUX_VERSION_CODE  < KERNEL_VERSION(2,5,0)
+	if (asd->dev != NULL)
+		asd->dev->driver = NULL;
+#endif
+
+	asd_free_mem(asd);			
+}
+
+void
+asd_intr_enable(struct asd_softc *asd, int enable)
+{
+	asd_write_dword(asd, CHIMINTEN, enable ? SET_CHIMINTEN : 0);
+}
+
+static int
+asd_hwi_reset_hw(struct asd_softc *asd)
+{
+	u_int i;
+
+#define ASD_RESET_DELAY	10
+#define ASD_RESET_LOOP_COUNT (1 * 1000000 / ASD_RESET_DELAY)
+	for (i = 0 ; i < 4 ; i++) {
+		asd_write_dword(asd, COMBIST, HARDRST);
+	}
+	for (i = 0; i < ASD_RESET_LOOP_COUNT; i++) {
+		asd_delay(ASD_RESET_DELAY);
+		if (asd_read_dword(asd, CHIMINT) & HARDRSTDET)
+			break;
+	}
+	if (i >= ASD_RESET_LOOP_COUNT) {
+		asd_log(ASD_DBG_ERROR, "Chip reset failed.\n");
+		return (-EIO);
+	}
+
+	return (0);
+} 
+
+#ifdef ASD_DEBUG
+typedef struct pcic_regs {
+	uint8_t		name[32];
+	uint16_t	offset;
+} pcic_regs_t;
+
+static pcic_regs_t	PCICREG[] =
+{
+	{"DEVICE-VENDOR"     ,0x00},
+	{"COMMAND-STATUS"    ,0x04},
+	{"DEVREV-CLASS"      ,0x08},
+	{"SUB_VENDOR-ID"     ,0x2c},
+	{"XBAR"	             ,0x30},
+	{"PCIX_CAP-CMD"      ,0x42},
+	{"PCIX_STATUS"       ,0x44},
+	{"MBAR1"             ,0x6c},
+	{"MBAR0-WA"          ,0x70},
+	{"MBAR0-WB"          ,0x74},
+	{"MBAR0-WC"          ,0x78},
+	{"MBARKEY"           ,0x7c},
+	{"HREX_CTL"          ,0x80},
+	{"HREX_STATUS"       ,0x84},
+	{"RBI_CTL"           ,0x88},
+	{"RBI_STATUS"        ,0x8c},
+	{"CF_ADR_L"          ,0x90},
+	{"CF_ADR_H"          ,0x94},
+	{"DF_ADR_L"          ,0x98},
+	{"DF_ADR_H"          ,0x9c},
+	{"HSTPCIX_CTL"       ,0xa0},
+	{"HSTPCIX_STATUS"    ,0xa4},
+	{"FLSH_BAR"          ,0xb8},
+	{"", 0 }	/* Last entry should be NULL. */
+}; 
+
+void DumpPCI(struct asd_softc *asd)
+{
+	uint32_t regvalue;
+	uint32_t i;
+	i=0;
+	asd_print("**PCI REG DUMP********************\n");
+	while(PCICREG[i].name[0]!=0)
+	{
+		regvalue = asd_pcic_read_dword(asd, PCICREG[i].offset);
+		asd_print(" %s (0x%x) : 0x%x\n", PCICREG[i].name, PCICREG[i].offset, regvalue);
+		i++;
+	}
+	asd_print("**********************************\n");
+}
+#endif
+
+/* 
+ * Function:
+ *	asd_hwi_init_hw()
+ *
+ * Description:
+ *      Perform controller specific initialization.
+ */
+int
+asd_hwi_init_hw(struct asd_softc  *asd)
+{
+	union hardware_scb 	*hscb;
+	struct scb		*scb;
+	uint8_t			*next_vaddr;
+	dma_addr_t	 	 next_baddr;
+	dma_addr_t	 	 edb_baddr;
+	size_t		 	 driver_data_size;
+	size_t		 	 dl_size;
+	uint8_t		 	 enabled_phys;
+	u_int		 	 num_edbs;
+	u_int		 	 num_escbs;
+	u_int		 	 i;
+	int		 	 error;
+	u_long			 flags;
+
+	/* Setup the Sliding Window BAR. */
+	asd_hwi_setup_sw_bar(asd);
+#if SAS_COMSTOCK_SUPPORT
+	/* 
+	 * Retrieve the RTL number. The RTL Number will be used to decide which
+	 * sequencer version to use.
+	 */  
+	asd_hwi_get_rtl_ver(asd);
+
+	/* No support for COMSTOCK RTL less than version 14. */
+	if (asd->hw_profile.rev_id < COMSTOCK_LATEST_RTL)
+		return (-ENODEV);
+#endif
+
+	/* Allocate SCB data */
+	if (asd_hwi_init_scbdata(asd) != 0)
+		return (-ENOMEM);
+	
+	/*
+	 * DMA tag for our done_list, empty buffers, empty hardware SCBs,
+	 * and sentinel hardware SCB.  These are data host memory structures
+	 * the controller must be able to access.
+	 *
+	 * The number of elements in our done list must be a powerof2
+	 * greater than or equal to 4 that is large enough to guarantee
+	 * it cannot overflow.  Since each done list entry is associated
+	 * with either an empty data buffer or an SCB, add the counts for
+	 * these two objects together and roundup to the next power of 2.
+	 * To ensure our sequencers don't stall, we need two empty buffers
+	 * per sequencer (1 sequencer per-phy plus central seq).  We round
+	 * this up to a multiple of the number of EDBs that we can fit in
+	 * a single empty SCB.
+	 */
+	num_edbs = roundup(2 * (asd->hw_profile.max_phys + 1),
+			   ASD_MAX_EDBS_PER_SCB);
+	/*
+	 * At minimum, allocate 2 empty SCBs so that the sequencers
+	 * always have empty buffers while we are trying to queue more.
+	 */
+	num_edbs = MAX(num_edbs, 2 * ASD_MAX_EDBS_PER_SCB);
+	num_escbs = num_edbs / ASD_MAX_EDBS_PER_SCB;
+	dl_size = asd->hw_profile.max_scbs + num_edbs;
+	dl_size = roundup_pow2(dl_size);
+	asd->dl_wrap_mask = dl_size - 1;
+	dl_size *= sizeof(*asd->done_list);
+
+	driver_data_size = dl_size + (ASD_SCB_SIZE) /* for sentinel */ + 
+			 + (num_escbs * ASD_SCB_SIZE)
+			 + (num_edbs * sizeof(union edb));
+
+	if (asd_dma_tag_create(asd, 8, driver_data_size, GFP_ATOMIC,
+			       &asd->shared_data_dmat) != 0) {
+		asd_hwi_exit_hw(asd);
+		return (-ENOMEM);
+	}
+
+	asd->init_level++;
+
+	/* Allocation of driver data */
+	if (asd_dmamem_alloc(asd, asd->shared_data_dmat,
+			     (void **)&asd->shared_data_map.vaddr, GFP_ATOMIC,
+			     &asd->shared_data_map.dmamap,
+			     &asd->shared_data_map.busaddr) != 0) {
+		asd_hwi_exit_hw(asd);
+		return (-ENOMEM);
+	}
+
+	asd->init_level++;
+
+	/*
+	 * Distribute the memory.
+	 */
+	memset(asd->shared_data_map.vaddr, 0, driver_data_size);
+	asd->done_list = (struct asd_done_list *)asd->shared_data_map.vaddr;
+	asd->dl_valid = ASD_QDONE_PASS_DEF;
+	next_vaddr = asd->shared_data_map.vaddr + dl_size;
+	next_baddr = asd->shared_data_map.busaddr + dl_size;
+
+	/*
+	 * We need one SCB to serve as the "next SCB".  Since the
+	 * tag identifier in this SCB will never be used, there is
+	 * no point in using a valid HSCB tag from an SCB pulled from
+	 * the standard free pool.  So, we allocate this "sentinel"
+	 * specially from the DMA safe memory chunk.
+	 */
+	asd->next_queued_hscb = (union hardware_scb *)next_vaddr;
+	asd->next_queued_hscb_map = &asd->shared_data_map;
+	asd->next_queued_hscb_busaddr = asd_htole64(next_baddr);
+	next_vaddr += ASD_SCB_SIZE;
+	next_baddr += ASD_SCB_SIZE;
+
+	/*
+	 * Since Empty SCBs do not require scatter gather lists
+	 * we also allocate them outside of asd_alloc_scbs().
+	 */
+	hscb = asd->next_queued_hscb + 1;
+	edb_baddr = next_baddr + (num_escbs * ASD_SCB_SIZE);
+	for (i = 0; i < num_escbs; i++, hscb++, next_baddr += ASD_SCB_SIZE) {
+		int j;
+
+		/*
+		 * Allocate ESCBs.
+		 */
+		scb = asd_alloc_mem(sizeof(*scb), GFP_ATOMIC);
+		if (scb == NULL) {
+			error = -ENOMEM;
+			goto exit;
+		}
+		memset(scb, 0, sizeof(*scb));
+		INIT_LIST_HEAD(&scb->hwi_links);
+		INIT_LIST_HEAD(&scb->owner_links);
+		scb->hscb = hscb;
+		scb->hscb_busaddr = asd_htole64(next_baddr);
+		scb->softc = asd;
+		scb->hscb_map = &asd->shared_data_map;
+		hscb->header.index = asd_htole16(asd->numscbs);
+		hscb->header.opcode = SCB_EMPTY_BUFFER;
+		asd->scbindex[asd->numscbs++] = scb;
+		hscb->empty_scb.num_valid_elems = ASD_MAX_EDBS_PER_SCB;
+		for (j = 0; j < ASD_MAX_EDBS_PER_SCB; j++) {
+			hscb->empty_scb.buf_elem[j].busaddr =
+			    asd_htole64(edb_baddr);
+			hscb->empty_scb.buf_elem[j].buffer_size =
+			    asd_htole32(sizeof(union edb));
+			hscb->empty_scb.buf_elem[j].elem_valid_ds =
+			    ELEM_BUFFER_VALID;
+			edb_baddr += sizeof(union edb);
+		}
+		list_add(&scb->hwi_links, &asd->empty_scbs);
+	}
+
+	asd->init_level++;
+
+	/* Allocate Free DDB bitmap. */
+	asd->ddb_bitmap_size = roundup(asd->hw_profile.max_ddbs, BITS_PER_LONG);
+	asd->ddb_bitmap_size /= BITS_PER_LONG;
+	asd->free_ddb_bitmap = asd_alloc_mem((asd->ddb_bitmap_size *
+					      sizeof(u_long)), GFP_ATOMIC);
+	if (asd->free_ddb_bitmap == NULL)
+		return (-ENOMEM);
+	memset(asd->free_ddb_bitmap, 0, sizeof(u_long) * asd->ddb_bitmap_size);
+
+	/*
+	 * DDB site 0 and 1 are reserved for the firmware for internal use.
+	 */
+	asd->free_ddb_bitmap[0] |= (u_long)(3UL<<0);
+//JD
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "asd->free_ddb_bitmap ptr 0x%x\n",asd->free_ddb_bitmap);
+	asd_print("%llx %llx\n",(u64)asd->free_ddb_bitmap[0], (u64)asd->free_ddb_bitmap[1]);
+#endif
+	asd->init_level++;
+
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "After initial BAR Setting\n");
+	DumpPCI(asd);
+#endif
+	/* Retrieve OCM information */
+	if (asd_hwi_get_ocm_info(asd)) {
+		asd_log(ASD_DBG_ERROR, "Failed to retrieve OCM info.\n");
+		/* TBD: return -1; ? */
+	}
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "After asd_hwi_get_ocm_info\n");
+	DumpPCI(asd);
+#endif
+#if NVRAM_SUPPORT
+	/* 
+	 * Retrieves controller NVRAM setting. 
+	 */
+	error = asd_hwi_get_nv_config(asd);
+	if (error != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to retrieve NVRAM config.\n");
+	}
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "After asd_hwi_get_nv_config\n");
+	DumpPCI(asd);
+#endif
+#endif
+
+	/* Initialize the phy and port to default settings. */
+	error = asd_hwi_init_phys(asd);
+	if (error != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to init the phys.\n");
+		asd_hwi_exit_hw(asd);
+		goto exit;
+	}
+
+	error = asd_hwi_init_ports(asd);
+	if (error != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to init the ports.\n");
+		asd_hwi_exit_hw(asd);
+		goto exit;
+	}
+
+	if (asd_hwi_reset_hw(asd) != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to perform Chip reset.\n");
+		asd_hwi_exit_hw(asd);
+		goto exit;
+	}
+
+	asd_write_dword(asd, CHIMINT, PORRSTDET|HARDRSTDET);
+
+	/*
+	 * Reset the producer and consumer index to reflect
+	 * no outstanding SCBs.
+	 */
+	asd->qinfifonext = (asd_read_dword(asd, SCBPRO) & SCBCONS_MASK) >> 16;
+	asd_write_dword(asd, SCBPRO, asd->qinfifonext);
+
+	asd->qinfifonext = asd_read_word(asd, SCBPRO+2);
+
+	/* Disable the Host interrupts. */
+	asd_write_dword(asd, CHIMINTEN, RST_CHIMINTEN);
+
+	/* Initialize and setup the CSEQ and LSEQ. */
+	error = asd_hwi_init_sequencers(asd);
+	if (error != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to init the SEQ.\n"); 
+		goto exit;
+	}		
+	
+	/* CSEQ should be ready to run. Start the CSEQ. */
+	error = asd_hwi_start_cseq(asd);
+	if (error != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to start the CSEQ.\n"); 
+		goto exit;
+	}		
+
+	/* Start the LSEQ(s). */
+	i = 0;
+	enabled_phys = asd->hw_profile.enabled_phys;
+	while (enabled_phys != 0) {
+		for ( ; i < asd->hw_profile.max_phys; i++) {
+			if (enabled_phys & (1U << i)) {
+				enabled_phys &= ~(1U << i);
+				break;
+			}
+		}
+		
+		error = asd_hwi_start_lseq(asd, i);
+		if (error != 0) {
+			asd_log(ASD_DBG_ERROR,
+				"Failed to start LSEQ %d.\n", i);
+			goto exit;
+		}		
+	}
+
+	asd_lock(asd, &flags);
+
+	/*
+	 * Post all of our empty scbs to the central sequencer.
+	 */
+	list_for_each_entry(scb, &asd->empty_scbs, hwi_links) {
+		asd_hwi_post_scb(asd, scb);
+	}
+
+	asd_unlock(asd, &flags);
+
+	/* Enabled all the phys. */
+	i = 0;
+	enabled_phys = asd->hw_profile.enabled_phys;
+	while (enabled_phys != 0) { 
+		for ( ; i < asd->hw_profile.max_phys; i++) {
+			if (enabled_phys & (1 << i)) {
+				enabled_phys &= ~(1 << i);
+				break;
+			} 
+		}
+	
+		error = asd_hwi_enable_phy(asd, asd->phy_list[i]);
+		if (error != 0) {
+			/*
+			 * TODO: This shouldn't happen.
+			 *       Need more thought on how to proceed.
+			 */
+			asd_log(ASD_DBG_ERROR, "Failed to enable phy %d.\n", i);
+			break;
+		}
+	}
+exit:
+#ifdef ASD_DEBUG
+	asd->debug_flag=0;
+#endif
+	return (error);         
+}
+
+#if SAS_COMSTOCK_SUPPORT
+/*
+ * Function:
+ *	asd_hwi_get_rtl_ver()
+ *
+ * Description:
+ * 	Retrive the COMSTOCK rtl version.
+ */ 	  	 
+static void
+asd_hwi_get_rtl_ver(struct asd_softc *asd)
+{
+	uint32_t	exsi_base_addr;
+	uint32_t	reg_addr;
+	uint8_t		reg_data;
+
+	exsi_base_addr = EXSI_REG_BASE_ADR + XREGADDR;
+	reg_addr = asd_hwi_swb_read_dword(asd, exsi_base_addr);
+	asd_hwi_swb_write_dword(asd, exsi_base_addr, (uint32_t)
+				(reg_addr & ~(XRADDRINCEN | XREGADD_MASK)));
+	reg_data = asd_hwi_swb_read_byte(asd, EXSI_REG_BASE_ADR + XREGDATAR);
+	asd_hwi_swb_write_dword(asd, exsi_base_addr, reg_addr);
+	
+	asd->hw_profile.rev_id = reg_data;
+}
+#endif /* SAS_COMSTOCK_SUPPORT */
+
+/* 
+ * Function:
+ *	asd_hwi_exit_hw()
+ *
+ * Description:
+ *      Perform controller specific cleanup.
+ */
+static void
+asd_hwi_exit_hw(struct asd_softc *asd)
+{
+	struct scb	*scb;
+	struct map_node	*map;
+	struct asd_phy	*phy;
+	struct asd_port	*port;
+	u_int		 i;
+
+	/*
+	 * Reset the chip so that the sequencers do not
+	 * attempt to DMA data into buffers we are about
+	 * to remove or issue further interrupts.
+	 */
+	/* TBRV: This seems to fail all the time. */
+	//asd_hwi_reset_hw(asd);
+
+	/* Clean up the phy structures */
+	for (i = 0; i <	asd->hw_profile.max_phys; i++) {
+		if (asd->phy_list[i] != NULL) {
+			phy = asd->phy_list[i];
+			/* Free the ID ADDR Frame buffer. */
+			asd_free_dma_mem(asd, phy->id_addr_dmat,
+					 &phy->id_addr_map);
+			asd_free_mem(asd->phy_list[i]);
+		}
+	}
+
+	/* Clean up the port structures */
+	for (i = 0; i < asd->hw_profile.max_ports; i++) {
+		if (asd->port_list[i] != NULL) {
+			port = asd->port_list[i];
+
+			/*
+			 * Free SMP Request Frame buffer.
+			 */
+			asd_free_dma_mem(asd, 
+				port->dc.smp_req_dmat,
+				&port->dc.smp_req_map);
+
+			/*
+			 * Free SMP Response Frame buffer.
+			 */
+			asd_free_dma_mem(asd, 
+				port->dc.smp_resp_dmat,
+				&port->dc.smp_resp_map);
+
+			asd_free_mem(asd->port_list[i]);
+		}
+	}
+
+	/* Free up the SCBs */
+	while (!list_empty(&asd->pending_scbs)) {
+		scb = list_entry(asd->pending_scbs.next, struct scb, hwi_links);
+asd_log(ASD_DBG_INFO, "freeing pending scb 0x%x scb->hwi_links 0x%p",scb, &scb->hwi_links);
+		list_del(&scb->hwi_links);
+		asd_free_scb_platform_data(asd, scb->platform_data);
+        	asd_free_mem(scb);
+	}
+
+	while (!list_empty(&asd->rsvd_scbs)) {
+		scb = list_entry(asd->rsvd_scbs.next, struct scb, hwi_links);
+		list_del(&scb->hwi_links);
+		asd_free_scb_platform_data(asd, scb->platform_data);
+        	asd_free_mem(scb);
+	}
+
+	while (!list_empty(&asd->free_scbs)) {
+		scb = list_entry(asd->free_scbs.next, struct scb, hwi_links);
+		list_del(&scb->hwi_links);
+		asd_free_scb_platform_data(asd, scb->platform_data);
+        	asd_free_mem(scb);
+	}
+	while (!list_empty(&asd->empty_scbs)) {
+		/*
+		 * Empties have no OSM data.
+		 */
+		scb = list_entry(asd->empty_scbs.next, struct scb, hwi_links);
+		list_del(&scb->hwi_links);
+        	asd_free_mem(scb);
+	}
+
+	/* Free up DMA safe memory shared with the controller */
+	while (!list_empty(&asd->hscb_maps)) {
+		map = list_entry(asd->hscb_maps.next, struct map_node, links);
+		list_del(&map->links);
+		asd_dmamem_free(asd, asd->hscb_dmat, map->vaddr, map->dmamap);
+		asd_free_mem(map);
+	}
+	while (!list_empty(&asd->sg_maps)) {
+		map = list_entry(asd->sg_maps.next, struct map_node, links);
+		list_del(&map->links);
+		asd_dmamem_free(asd, asd->sg_dmat, map->vaddr, map->dmamap);
+		asd_free_mem(map);
+	}
+
+	switch (asd->init_level) {
+	default:
+	case 7:
+		asd_free_mem(asd->free_ddb_bitmap);
+		/* FALLTHROUGH */
+	case 6:
+		asd_dmamem_free(asd, asd->shared_data_dmat,
+				asd->shared_data_map.vaddr,
+				asd->shared_data_map.dmamap);
+		/* FALLTHROUGH */
+	case 5:
+		asd_dma_tag_destroy(asd, asd->shared_data_dmat);
+		/* FALLTHROUGH */
+	case 4:
+#ifdef EXTENDED_SCB
+	{
+/* free memory for extended scb*/
+		asd_free_dma_mem(asd, asd->ext_scb_dmat, &asd->ext_scb_map);
+#ifdef ASD_DEBUG
+		asd_print("EXTENDED_SCB is freed\n");
+#endif
+	}
+#endif
+		asd_dma_tag_destroy(asd, asd->sg_dmat);
+		/* FALLTHROUGH */
+	case 3:
+		asd_dma_tag_destroy(asd, asd->hscb_dmat);
+		/* FALLTHROUGH */
+	case 2:
+		asd_free_mem(asd->qinfifo);
+		/* FALLTHROUGH */
+	case 1:
+		asd_free_mem(asd->scbindex);
+		/* FALLTHROUGH */
+	case 0:
+		break;
+	}
+}
+
+/* 
+ * Function:
+ *	asd_hwi_setup_sw_bar()
+ *
+ * Description:
+ *      Setup the location of internal space where the Sliding Window will
+ *	point to.
+ */
+static void
+asd_hwi_setup_sw_bar(struct asd_softc *asd)
+{
+	/* Setup Sliding Window A and B to point to CHIM_REG_BASE_ADR. */
+	asd_write_dword(asd, PCIC_BASEA, CHIM_REG_BASE_ADR);
+	asd_write_dword(asd, PCIC_BASEB, CHIM_REG_BASE_ADR);
+	
+	asd->io_handle[0]->swb_base = (uint32_t) CHIM_REG_BASE_ADR;        
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_phys()
+ *
+ * Description:
+ *      Alllocate phy structures and intialize them to default settings. 
+ */
+static int
+asd_hwi_init_phys(struct asd_softc *asd)
+{
+	struct asd_phy	*phy;
+	u_int		 phy_id;
+
+        for (phy_id = 0; phy_id < asd->hw_profile.max_phys; phy_id++) {
+        	phy = asd_alloc_mem(sizeof(*phy), GFP_KERNEL);
+                if (phy == NULL) {
+                	asd_log(ASD_DBG_ERROR," Alloc Phy failed.\n");
+                        return (-ENOMEM);
+		}
+                
+		memset(phy, 0x0, sizeof(*phy));
+		
+		/* Fill in the default settings. */
+		phy->id = phy_id;
+		phy->max_link_rate = SAS_30GBPS_RATE;
+		phy->min_link_rate = SAS_15GBPS_RATE;       
+                /*
+                 * Set the phy attributes to support SSP, SMP and STP 
+                 * initiator mode. Target mode is not supported.
+                 */
+		phy->attr = (ASD_SSP_INITIATOR | ASD_SMP_INITIATOR | 
+			     ASD_STP_INITIATOR);
+		
+		/* 
+		 * By default, use the adapter WWN as the SAS address for 
+		 * the phy. 
+		 */
+                memcpy(phy->sas_addr, asd->hw_profile.wwn, SAS_ADDR_LEN);
+
+		/* Allocate buffer for IDENTIFY ADDRESS frame. */
+		if (asd_dma_tag_create(asd, 8, sizeof(struct sas_id_addr),
+				       GFP_ATOMIC, &phy->id_addr_dmat) != 0)
+			return (-ENOMEM);
+
+		if (asd_dmamem_alloc(asd, phy->id_addr_dmat, 
+				    (void **) &phy->id_addr_map.vaddr,
+				    GFP_ATOMIC,
+				    &phy->id_addr_map.dmamap,
+				    &phy->id_addr_map.busaddr) != 0) {
+			asd_dma_tag_destroy(asd, phy->id_addr_dmat);
+			return (-ENOMEM);
+		}
+
+		INIT_LIST_HEAD(&phy->pending_scbs);
+		phy->state = ASD_PHY_UNUSED;
+		phy->src_port = NULL;
+                phy->softc = (void *) asd;
+		INIT_LIST_HEAD(&phy->links);
+		phy->pat_gen = 0;
+		asd->phy_list[phy_id] = phy;
+	}
+	
+	asd_hwi_get_nv_phy_settings(asd);
+	asd_hwi_get_nv_phy_params(asd);
+
+	return (0);	
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_ports()
+ *
+ * Description:
+ *      Alllocate port structures and intialize them to default settings. 
+ */
+static int
+asd_hwi_init_ports(struct asd_softc *asd)
+{
+	struct asd_port	*port;
+	u_char		i;
+
+	for (i = 0; i < asd->hw_profile.max_ports; i++) {
+       		port = asd_alloc_mem(sizeof(*port), GFP_ATOMIC);
+		if (port == NULL) {
+			asd_log(ASD_DBG_ERROR," Alloc Port failed.\n");
+			return (-ENOMEM);
+		}			
+	
+		memset(port, 0x0, sizeof(*port));
+		INIT_LIST_HEAD(&port->phys_attached);
+		INIT_LIST_HEAD(&port->targets);
+		INIT_LIST_HEAD(&port->targets_to_validate);
+
+		if (asd_alloc_dma_mem(asd, sizeof(struct SMPRequest),
+			(void **)&port->dc.SMPRequestFrame,
+			&port->dc.SMPRequestBusAddr,
+			&port->dc.smp_req_dmat,
+			&port->dc.smp_req_map) != 0) {
+
+			return (-ENOMEM);
+		}
+
+		if (asd_alloc_dma_mem(asd, sizeof(struct SMPResponse),
+			(void **)&port->dc.SMPResponseFrame,
+			&port->dc.SMPResponseBusAddr,
+			&port->dc.smp_resp_dmat,
+			&port->dc.smp_resp_map) != 0) {
+
+			/*
+			 * If we get get the response, free the request.
+			 */
+			asd_free_dma_mem(asd, 
+				port->dc.smp_req_dmat,
+				&port->dc.smp_req_map);
+
+			return (-ENOMEM);
+		}
+
+		/*
+		 * The SASInfoFrame includes the length of the list as the 
+		 * first element.
+		 */
+		port->dc.sas_info_len = MAX(
+			(ASD_MAX_LUNS + 1) * sizeof(uint64_t),
+			PRODUCT_SERIAL_NUMBER_LEN);
+
+		if (asd_alloc_dma_mem(asd,
+			port->dc.sas_info_len,
+			(void **)&port->dc.SASInfoFrame,
+			&port->dc.SASInfoBusAddr,
+			&port->dc.sas_info_dmat,
+			&port->dc.sas_info_map) != 0) {
+
+			/*
+			 * If we get get the report luns ...
+			 */
+			asd_free_dma_mem(asd, 
+				port->dc.smp_req_dmat,
+				&port->dc.smp_req_map);
+
+			asd_free_dma_mem(asd, 
+				port->dc.smp_resp_dmat,
+				&port->dc.smp_resp_map);
+
+			return (-ENOMEM);
+		}
+
+		/* Fill in default settings. */
+		port->attr = (ASD_SSP_INITIATOR | ASD_SMP_INITIATOR |
+			      ASD_STP_INITIATOR);
+		port->softc = (void *) asd;
+		port->state = ASD_PORT_UNUSED;
+		port->events = ASD_IDLE;
+		port->link_type = ASD_LINK_UNKNOWN;
+		port->management_type = ASD_DEVICE_NONE;
+		port->id = i;
+		asd->port_list[i] = port;
+	}
+
+	return (0);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_alloc_scbs()
+ *
+ * Description:
+ *      Allocate SCB buffers. 
+ */
+static void
+asd_hwi_alloc_scbs(struct asd_softc *asd)
+{
+	struct scb 		*next_scb;
+	union hardware_scb 	*hscb;
+	struct map_node 	*hscb_map;
+	struct map_node 	*sg_map;
+	uint8_t			*segs;
+	dma_addr_t	 	 hscb_busaddr;
+	dma_addr_t	 	 sg_busaddr;
+	int		 	 newcount;
+	int		 	 i;
+
+	if (asd->numscbs >= asd->hw_profile.max_scbs)
+		/* Can't allocate any more */
+		return;
+
+	if (asd->scbs_left != 0) {
+		int offset;
+
+		offset = (PAGE_SIZE / sizeof(*hscb)) - asd->scbs_left;
+		hscb_map = list_entry(asd->hscb_maps.next,
+				      struct map_node, links);
+		hscb = &((union hardware_scb *)hscb_map->vaddr)[offset];
+		hscb_busaddr = hscb_map->busaddr + (offset * sizeof(*hscb));
+	} else {
+		hscb_map = asd_alloc_mem(sizeof(*hscb_map), GFP_ATOMIC);
+
+		if (hscb_map == NULL)
+			return;
+
+		/* Allocate the next batch of hardware SCBs */
+		if (asd_dmamem_alloc(asd, asd->hscb_dmat,
+				     (void **) &hscb_map->vaddr, GFP_ATOMIC,
+				     &hscb_map->dmamap,
+				     &hscb_map->busaddr) != 0) {
+			asd_free_mem(hscb_map);
+			return;
+		}
+
+		list_add(&hscb_map->links, &asd->hscb_maps);
+		hscb = (union hardware_scb *)hscb_map->vaddr;
+		hscb_busaddr = hscb_map->busaddr;
+		asd->scbs_left = PAGE_SIZE / sizeof(*hscb);
+
+		asd_log(ASD_DBG_RUNTIME, "Mapped SCB data. %d SCBs left. "
+			"Total SCBs %d.\n", 
+			asd->scbs_left, asd->numscbs);
+	}
+
+	if (asd->sgs_left != 0) {
+		int offset;
+
+		offset = ((asd_sglist_allocsize(asd) / asd_sglist_size(asd))
+		     		- asd->sgs_left) * asd_sglist_size(asd);
+		sg_map = list_entry(asd->sg_maps.next,
+				    struct map_node, links);
+		segs = sg_map->vaddr + offset;
+		sg_busaddr = sg_map->busaddr + offset;
+	} else {
+		sg_map = asd_alloc_mem(sizeof(*sg_map), GFP_ATOMIC);
+
+		if (sg_map == NULL)
+			return;
+
+		/* Allocate the next batch of S/G lists */
+		if (asd_dmamem_alloc(asd, asd->sg_dmat,
+				     (void **) &sg_map->vaddr, GFP_ATOMIC,
+				     &sg_map->dmamap, &sg_map->busaddr) != 0) {
+			asd_free_mem(sg_map);
+			return;
+		}
+
+		list_add(&sg_map->links, &asd->sg_maps);
+		segs = sg_map->vaddr;
+		sg_busaddr = sg_map->busaddr;
+		asd->sgs_left =
+			asd_sglist_allocsize(asd) / asd_sglist_size(asd);
+	}
+
+	newcount = MIN(asd->scbs_left, asd->sgs_left);
+	newcount = MIN(newcount, (asd->hw_profile.max_scbs - asd->numscbs));
+
+	for (i = 0; i < newcount; i++) {
+		struct asd_scb_platform_data *pdata;
+
+		next_scb = (struct scb *) asd_alloc_mem(sizeof(*next_scb),
+							GFP_ATOMIC);
+		if (next_scb == NULL)
+			break;
+
+		memset(next_scb, 0, sizeof(*next_scb));
+		INIT_LIST_HEAD(&next_scb->hwi_links);
+		INIT_LIST_HEAD(&next_scb->owner_links);
+
+		pdata = asd_alloc_scb_platform_data(asd);
+		if (pdata == NULL) {
+			asd_free_mem(next_scb);
+			break;
+		}
+		next_scb->platform_data = pdata;
+		init_timer(&next_scb->platform_data->timeout);
+		next_scb->hscb_map = hscb_map;
+		next_scb->sg_map = sg_map;
+		next_scb->sg_list = (struct sg_element *)segs;
+		memset(hscb, 0, sizeof(*hscb));
+		next_scb->hscb = hscb;
+
+		next_scb->hscb_busaddr = asd_htole64(hscb_busaddr);
+		next_scb->sg_list_busaddr = sg_busaddr;
+		next_scb->softc = asd;
+		next_scb->flags = SCB_FLAG_NONE;
+		next_scb->eh_state = SCB_EH_NONE;
+		next_scb->hscb->header.index = asd_htole16(asd->numscbs);
+		asd->scbindex[asd_htole16(asd->numscbs)] = next_scb;
+		
+		/* Add the scb to the free list. */
+		asd_hwi_free_scb(asd, next_scb);
+		hscb++;
+		hscb_busaddr += sizeof(*hscb);
+		segs += asd_sglist_size(asd);
+		sg_busaddr += asd_sglist_size(asd);
+		asd->numscbs++;
+		asd->scbs_left--;
+		asd->sgs_left--;
+	}
+}
+
+/*
+ * Function:
+ *	asd_alloc_ddb
+ *
+ * Description:
+ *      Allocate a DDB site on the controller.
+ *	Returns ASD_INVALID_DDB_INDEX on failure.
+ *	Returns DDB index on success.
+ */
+uint16_t
+asd_alloc_ddb(struct asd_softc *asd)
+{
+	u_int i;
+	u_int bit_index;
+	for (i = 0; i < asd->ddb_bitmap_size; i++) {
+		if (asd->free_ddb_bitmap[i] != ~0UL)
+			break;
+	}
+	if (i >= asd->ddb_bitmap_size)
+		return (ASD_INVALID_DDB_INDEX);
+
+	bit_index = ffz(asd->free_ddb_bitmap[i]);
+	asd->free_ddb_bitmap[i] |= (u_long)(1UL << bit_index);
+	return ((i * BITS_PER_LONG) + bit_index);
+}
+
+/*
+ * Function:
+ *	asd_free_ddb
+ *
+ * Description:
+ *      Mark the DDB site at "ddb_index" as free.
+ */
+void
+asd_free_ddb(struct asd_softc *asd, uint16_t ddb_index)
+{
+	u_int word_offset;
+	u_int bit_offset;
+
+	word_offset = ddb_index / BITS_PER_LONG;
+	bit_offset = ddb_index & (BITS_PER_LONG - 1);
+	asd->free_ddb_bitmap[word_offset] &= (u_long)(~(1UL << bit_offset));
+}
+
+/*
+ * Function:
+ *	asd_hwi_setup_ddb_site()
+ *  
+ * Description:
+ *	Alloc and DDB site and setup the DDB site for the controller.
+ */
+int
+asd_hwi_setup_ddb_site(struct asd_softc *asd, struct asd_target *target)
+{
+	uint16_t	ddb_index;
+
+	/* Allocate a free DDB site. */
+	ddb_index = asd_alloc_ddb(asd);
+	if (ddb_index == ASD_INVALID_DDB_INDEX)
+		return (-1);
+	
+	target->ddb_profile.conn_handle = ddb_index;	
+	
+	asd_hwi_build_ddb_site(asd, target);
+
+	return (0);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_sequencers()
+ *
+ * Description:
+ *      Initialize the Central and Link Sequencers. 
+ */
+static int
+asd_hwi_init_sequencers(struct asd_softc *asd)
+{
+	/* Pause the CSEQ. */
+	if (asd_hwi_pause_cseq(asd) != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to pause the CSEQ.\n");
+		return (-1);	
+	}
+	
+	/* Pause all the LSEQs. */
+	if (asd_hwi_pause_lseq(asd, asd->hw_profile.enabled_phys) != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to pause the LSEQs.\n");
+		return (-1);		
+	}
+	/* Download the sequencers. */
+	if (asd_hwi_download_seqs(asd) != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to setup the SEQs.\n");
+		return (-1);
+	}
+
+	/*
+	 * Zero out all of the ddb_sites
+	 */
+	asd_hwi_init_ddb_sites(asd);
+
+	/* 
+	 * Initialiaze the DDB site 0 and 1used internally by the
+	 * sequencer.
+	 */
+	asd_hwi_init_internal_ddb(asd);
+
+	/* Setup and initialize the CSEQ and LSEQ(s). */
+	asd_hwi_setup_seqs(asd);
+	
+	return (0);			
+}
+
+/* 
+ * Function:
+ *	asd_hwi_get_scb()
+ *
+ * Description:
+ *      Get a free SCB Desc from the free list if any.
+ */
+struct scb *
+asd_hwi_get_scb(struct asd_softc *asd, int rsvd_pool)
+{
+	struct scb	*scb;
+
+	ASD_LOCK_ASSERT(asd);
+
+	if (rsvd_pool == 1) {
+		/* Get an SCB from the reserved pool. */
+		if (list_empty(&asd->rsvd_scbs)) {
+			/*
+		 	 * We shouldn't be running out reserved SCBs.
+		 	 */
+			asd_log(ASD_DBG_ERROR, "Running out reserved SCBs.\n");
+			return (NULL);
+		}
+		scb = list_entry(asd->rsvd_scbs.next, struct scb, hwi_links);
+		scb->flags |= SCB_RESERVED;
+#ifdef ASD_DEBUG
+		printk("reserved scb 0x%x is allocated\n", scb);
+#endif
+	} else {
+		/* Get an SCB from the free pool. */
+		if (list_empty(&asd->free_scbs)) {
+			asd_hwi_alloc_scbs(asd);
+			if (list_empty(&asd->free_scbs)) {
+#if 0
+				asd_log(ASD_DBG_ERROR, 
+					"Failed to get a free SCB.\n");
+#endif
+				return (NULL);
+			}
+		}
+		scb = list_entry(asd->free_scbs.next, struct scb, hwi_links);
+	}
+	list_del(&scb->hwi_links);
+	scb->post_stack_depth = 0;
+
+	return (scb);
+}
+
+/*
+ * Function:
+ *	asd_hwi_enable_phy()
+ *
+ * Description:
+ *	Enable the requested phy.
+ */
+int
+asd_hwi_enable_phy(struct asd_softc *asd, struct asd_phy *phy)
+{
+	struct scb		*scb;
+	uint8_t			phy_id;
+	u_long		 	flags;
+
+	phy_id = phy->id;
+
+#if SAS_COMSTOCK_SUPPORT
+	/*
+ 	 * For COMSTOCK:
+	 * 	1. We need to setup OOB signal detection limits.
+	 */
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_BFLTR), 0x40);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_INIT_MIN), 0x06);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_INIT_MAX), 0x13);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_INIT_NEG), 0x13);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_SAS_MIN), 0x13);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_SAS_MAX), 0x36);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_SAS_NEG), 0x36);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_WAKE_MIN), 0x02);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_WAKE_MAX), 0x06);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_WAKE_NEG), 0x06);
+	asd_hwi_swb_write_word(asd, LmSEQ_OOB_REG(phy_id, OOB_IDLE_MAX), 
+			       0x0080);
+	asd_hwi_swb_write_word(asd, LmSEQ_OOB_REG(phy_id, OOB_BURST_MAX), 
+			       0x0080);
+	/*
+ 	 *	2. Put the OOB in slow clock mode. That corrects most of the 
+	 *	   other timer parameters including the signal transmit values
+	 * 	   for 37.5 MHZ.
+	 */
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, OOB_MODE), SLOW_CLK);
+
+#endif /* SAS_COMSTOCK_SUPPORT */
+				
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, INT_ENABLE_2), 0x0);
+
+
+#if !SAS_COMSTOCK_SUPPORT
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, HOT_PLUG_DELAY),
+			       HOTPLUG_DEFAULT_DELAY);
+
+	/*
+	 * Set the PHY SETTINGS values based on the manufacturing 
+	 * programmed values that we obtained from the NVRAM.
+	 */
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_0),
+			       phy->phy_ctl0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_1),
+			       phy->phy_ctl1);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_2),
+			       phy->phy_ctl2);
+	asd_hwi_swb_write_byte(asd, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_3),
+			       phy->phy_ctl3);
+#endif
+
+#ifndef SEQUENCER_UPDATE
+	/* Initialize COMINIT_TIMER timeout. */
+	asd_hwi_swb_write_dword(asd, LmSEQ_COMINIT_TIMEOUT(phy_id),
+				SAS_DEFAULT_COMINIT_TIMEOUT);
+#endif
+
+	/* Build Identify Frame address. */
+	asd_hwi_build_id_frame(phy);
+
+	/* Fill in bus address for Identify Frame buffer. */
+	asd_hwi_set_hw_addr(asd, LmSEQ_TX_ID_ADDR_FRAME(phy_id),
+			    phy->id_addr_map.busaddr);
+
+	asd_hwi_control_activity_leds(asd, phy->id, ENABLE_PHY);
+
+	asd_lock(asd, &flags);
+
+	scb = asd_hwi_get_scb(asd, 0);
+	if (scb == NULL) {
+		asd_log(ASD_DBG_ERROR, "Failed to get a free SCB.\n");
+		return (-1);
+	}
+
+	/* Store the phy pointer. */
+	scb->io_ctx = (void *) phy;
+	scb->flags |= SCB_INTERNAL;
+
+	/* Build CONTROL PHY SCB. */
+	asd_hwi_build_control_phy(scb, phy, ENABLE_PHY);
+
+	list_add_tail(&scb->owner_links, &phy->pending_scbs);
+
+	asd_hwi_post_scb(asd, scb);
+
+	asd_unlock(asd, &flags);
+
+	return (0);	
+}
+
+void
+asd_hwi_release_sata_spinup_hold(
+struct asd_softc	*asd,
+struct asd_phy		*phy
+)
+{
+	struct scb		*scb;
+	uint8_t			phy_id;
+	u_long		 	flags;
+
+	phy_id = phy->id;
+				
+	asd_lock(asd, &flags);
+
+	scb = asd_hwi_get_scb(asd, 0);
+	if (scb == NULL) {
+		asd_log(ASD_DBG_ERROR, "Failed to get a free SCB.\n");
+		return;
+	}
+
+	/* Store the phy pointer. */
+	scb->io_ctx = (void *) phy;
+	scb->flags |= SCB_INTERNAL;
+
+	/* Build CONTROL PHY SCB. */
+	asd_hwi_build_control_phy(scb, phy, RELEASE_SPINUP_HOLD);
+
+	list_add_tail(&scb->owner_links, &phy->pending_scbs);
+
+	asd_hwi_post_scb(asd, scb);
+
+	asd_unlock(asd, &flags);
+
+	return;
+}
+
+void
+asd_hwi_process_devint(struct asd_softc *asd)
+{
+	uint32_t		dchstatus;
+	unsigned		link_num;
+	uint16_t		break_addr;
+	uint32_t		intval;
+	struct asd_step_data	*step_datap;
+
+	dchstatus = asd_hwi_swb_read_dword(asd,
+		(DCH_SAS_REG_BASE_ADR + DCHSTATUS));
+
+	asd_dprint("DCHSTATUS = 0x%x\n", dchstatus);
+
+	step_datap = NULL;
+
+	if (dchstatus & LSEQINT_MASK) {
+		for (link_num = 0 ; link_num < ASD_MAX_PHYS ; link_num++) {
+			if ((dchstatus & (1 << link_num)) == 0)  {
+				continue;
+			}
+
+			intval = asd_hwi_swb_read_dword(asd,
+				LmARP2INT(link_num));
+
+			asd_dprint("intval = 0x%x\n", intval);
+
+#ifdef SEQUENCER_UPDATE
+			if (intval & ARP2BREAK0) {
+				break_addr = (asd_hwi_swb_read_dword(asd,
+					LmARP2BREAKADR01(link_num)) &
+					BREAKADR0_MASK) * 4;
+
+#ifdef ASD_DEBUG
+				printk("LSEQ %d Break @ 0x%x\n",
+					link_num, break_addr);
+#endif
+				step_datap = asd_hwi_alloc_step(asd);
+
+				asd_hwi_lseq_init_step(step_datap,
+					link_num);
+
+				asd_hwi_start_step_timer(step_datap);
+
+				asd_hwi_swb_write_dword(asd,
+					LmARP2INT(link_num),
+					ARP2BREAK0);
+			}
+			else if (intval & ARP2BREAK1) {
+				break_addr = (asd_hwi_swb_read_dword(asd,
+					LmARP2BREAKADR01(link_num)) &
+					BREAKADR1_MASK) * 4;
+
+#ifdef ASD_DEBUG
+				printk("LSEQ %d Break @ 0x%x\n",
+					link_num, break_addr);
+#endif
+				step_datap = asd_hwi_alloc_step(asd);
+
+				asd_hwi_lseq_init_step(step_datap,
+					link_num);
+
+				asd_hwi_start_step_timer(step_datap);
+
+				asd_hwi_swb_write_dword(asd,
+					LmARP2INT(link_num),
+					ARP2BREAK1);
+			}
+			else if (intval & ARP2BREAK2) {
+				break_addr = (asd_hwi_swb_read_dword(asd,
+					LmARP2BREAKADR23(link_num)) &
+					BREAKADR2_MASK) * 4;
+
+#ifdef ASD_DEBUG
+				printk("LSEQ %d Break @ 0x%x\n",
+					link_num, break_addr);
+#endif
+				step_datap = asd_hwi_alloc_step(asd);
+
+				asd_hwi_lseq_init_step(step_datap,
+					link_num);
+
+				asd_hwi_start_step_timer(step_datap);
+
+				asd_hwi_swb_write_dword(asd,
+					LmARP2INT(link_num),
+					ARP2BREAK2);
+			}
+			else if (intval & ARP2BREAK3) {
+				break_addr = (asd_hwi_swb_read_dword(asd,
+					LmARP2BREAKADR23(link_num)) &
+					BREAKADR3_MASK) * 4;
+
+#ifdef ASD_DEBUG
+				printk("LSEQ %d Break @ 0x%x\n",
+					link_num, break_addr);
+#endif
+				step_datap = asd_hwi_alloc_step(asd);
+
+				asd_hwi_lseq_init_step(step_datap,
+					link_num);
+
+				asd_hwi_start_step_timer(step_datap);
+
+				asd_hwi_swb_write_dword(asd,
+					LmARP2INT(link_num),
+					ARP2BREAK3);
+			}
+#endif
+			if (intval & ARP2CIOPERR) {
+#ifdef ASD_DEBUG
+//				asd_hwi_dump_seq_state(asd, 0xff);
+//#else
+				asd_print("Fatal: ARP2CIOPERR\n");
+#endif
+			}
+
+			asd_hwi_swb_write_dword(asd,
+				LmARP2INT(link_num), intval);
+		}
+
+		if (step_datap == NULL) {
+			asd_hwi_unpause_lseq(asd, link_num);
+		}
+	} else if (dchstatus & CSEQINT) {
+		intval = asd_hwi_swb_read_dword(asd, CARP2INT);
+
+		asd_dprint("intval = 0x%x\n", intval);
+
+#ifdef SEQUENCER_UPDATE
+		if (intval & ARP2BREAK0) {
+			break_addr = (asd_hwi_swb_read_dword(asd,
+				CARP2BREAKADR01) & BREAKADR0_MASK) * 4;
+#ifdef ASD_DEBUG
+			printk("CSEQ Break @ 0x%x\n", break_addr);
+#endif
+			step_datap = asd_hwi_alloc_step(asd);
+
+			if (asd_hwi_cseq_init_step(step_datap) != 0) {
+				asd_hwi_start_step_timer(step_datap);
+			} else {
+				asd_hwi_free_step(step_datap);
+			}
+
+			asd_hwi_swb_write_dword(asd, CARP2INT, ARP2BREAK0);
+		}
+#endif
+
+		if (intval & ARP2CIOPERR) {
+#ifdef ASD_DEBUG
+//			asd_hwi_dump_seq_state(asd, 0xff);
+//#else
+			asd_print("Fatal: ARP2CIOPERR\n");
+#endif
+		}
+
+		asd_hwi_swb_write_dword(asd, CARP2INT, intval);
+	}
+}
+//JD
+#ifdef ASD_DEBUG
+
+typedef struct state_name {
+	uint8_t		name[16];
+	uint32_t	status;
+} state_name_t;
+
+static state_name_t	CHIMINT_STATUS[] =
+{
+	{"EXT_INT0",		0x00000800},
+	{"EXT_INT1",		0x00000400},
+	{"PORRSTDET",		0x00000200},
+	{"HARDRSTDET",		0x00000100},
+	{"DLAVAILQ",		0x00000080},	/* ro */
+	{"HOSTERR",			0x00000040},
+	{"INITERR",			0x00000020},
+	{"DEVINT",			0x00000010},
+	{"COMINT",			0x00000008},
+	{"DEVTIMER2",		0x00000004},
+	{"DEVTIMER1",		0x00000002},
+	{"DLAVAIL",			0x00000001},
+   {"", 0 }	/* Last entry should be NULL. */
+};
+	
+/* 
+ * Function:
+ *	dump_CHIMINT()
+ *
+ * Description:
+ *      Display CHIMINT Status (from IRQ).
+ */
+void dump_CHIMINT(uint32_t intstate)
+{
+	int i;
+
+	asd_log(ASD_DBG_INFO, "asd_process_irq: CHIMINT is (0x%x):\n",intstate);
+	for(i=0;CHIMINT_STATUS[i].status!=0;i++)
+	{
+		if(intstate & CHIMINT_STATUS[i].status) asd_log(ASD_DBG_INFO, "- %s\n",CHIMINT_STATUS[i].name);
+	}
+}
+#endif //ASD_DEBUG
+
+/* 
+ * Function:
+ *	asd_hwi_process_irq()
+ *
+ * Description:
+ *      Process any interrupts pending for our controller.
+ */
+int
+asd_hwi_process_irq(struct asd_softc *asd)
+{
+	struct asd_done_list	*dl_entry;
+	int			irq_processed;
+	uint32_t		intstat;
+
+	ASD_LOCK_ASSERT(asd);
+
+	/*
+	 * Check if any DL entries need to be processed.  If so,
+	 * bypass a costly read of our interrupt status register
+	 * and assume that the done list entries are the cause of
+	 * our interrupt.
+	 */
+	dl_entry = &asd->done_list[asd->dl_next];
+	if ((dl_entry->toggle & ASD_DL_TOGGLE_MASK) == asd->dl_valid)
+		intstat = DLAVAIL;
+	else
+		intstat = asd_read_dword(asd, CHIMINT);
+	if (intstat & DLAVAIL) {
+		asd_write_dword(asd, CHIMINT, DLAVAIL); 
+		/*
+		 * Ensure that the chip sees that we've cleared
+		 * this interrupt before we walk the done_list.
+		 * Otherwise, we may, due to posted bus writes,
+		 * clear the interrupt after we finish the scan,
+		 * and after the sequencer has added new entries
+		 * and asserted the interrupt again.
+		 *
+		 * NOTE: This extra read, and in fact the clearing
+		 *       of the command complete interrupt, will
+		 *       not be needed on systems using MSI.
+		 */
+		asd_flush_device_writes(asd);
+
+		asd_hwi_process_dl(asd);	
+
+		irq_processed = 1;
+	} else if ((intstat & CHIMINT_MASK) != 0) {
+		if ((intstat & DEVINT) != 0) {
+//#ifdef ASD_DEBUG
+			printk("DEVINT intstat 0x%x\n", intstat);
+//#endif
+			asd_hwi_process_devint(asd);
+			//asd_hwi_dump_seq_state(asd, 0xff);
+			asd_write_dword(asd, CHIMINT, DEVINT); 
+
+			irq_processed = 1;
+		} else {
+//#ifdef ASD_DEBUG
+			printk("unknown interrupt 0x%x\n", intstat);
+//#endif
+			asd_write_dword(asd, CHIMINT, intstat); 
+#ifdef ASD_DEBUG
+			dump_CHIMINT(intstat);
+			asd_hwi_dump_seq_state(asd, 0xff);
+#endif
+		}
+
+		irq_processed = 1;
+	} else {
+		irq_processed = 0;
+	}
+	
+	return (irq_processed);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_process_dl()
+ *
+ * Description:
+ *      Process posted Done List entries.
+ */
+static void
+asd_hwi_process_dl(struct asd_softc *asd)
+{
+	struct asd_done_list 	*dl_entry;
+	struct scb		*scb;
+
+	/*
+	 * Look for entries in the done list that have completed.
+	 * The valid_tag completion field indicates the validity
+	 * of the entry - the valid value toggles each time through
+	 * the queue.
+	 */
+	if ((asd->flags & ASD_RUNNING_DONE_LIST) != 0)
+		panic("asd_hwi_process_dl recursion");
+
+	asd->flags |= ASD_RUNNING_DONE_LIST;
+
+	for (;;) {
+		dl_entry = &asd->done_list[asd->dl_next];
+
+		if ((dl_entry->toggle & ASD_DL_TOGGLE_MASK) != asd->dl_valid)
+			break;
+
+		scb = asd->scbindex[dl_entry->index];
+//JD
+#ifdef ASD_DEBUG
+#if 0
+		if(asd->debug_flag==1)
+		{
+// 		asd_log(ASD_DBG_INFO, "asd_hwi_process_dl: dumping SCSI cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x , opcode 0x%x.\n", 
+// 			scb->io_ctx->scsi_cmd.cmnd[2],
+// 			scb->io_ctx->scsi_cmd.cmnd[3],
+// 			scb->io_ctx->scsi_cmd.cmnd[4],
+// 			scb->io_ctx->scsi_cmd.cmnd[5],
+// 			scb->io_ctx->scsi_cmd.cmnd[7],
+// 			scb->io_ctx->scsi_cmd.cmnd[8],
+// 			scb->io_ctx->scsi_cmd.cmnd[0]);
+//
+//		asd_log(ASD_DBG_INFO, "scb ptr=%p dl_next=%d  dl ptr=%p op=%x index = %x\n", scb,asd->dl_next,dl_entry,
+//			dl_entry->opcode,dl_entry->index);
+		asd_log(ASD_DBG_INFO, "scb ptr=%p opcode=%x index=%x\n", scb,dl_entry->opcode,dl_entry->index);
+
+
+
+		}
+#endif
+#endif
+		if ((scb->flags & SCB_PENDING) != 0) {
+			list_del(&scb->hwi_links);
+			scb->flags &= ~SCB_PENDING;
+		}
+
+		/* Process DL Entry. */
+		switch (dl_entry->opcode) {
+		case TASK_COMP_WO_ERR:
+		case TASK_COMP_W_UNDERRUN:
+		case TASK_COMP_W_OVERRUN:
+		case TASK_F_W_OPEN_REJECT:
+		case TASK_INT_W_BRK_RCVD:
+		case TASK_INT_W_PROT_ERR:
+		case SSP_TASK_COMP_W_RESP:
+		case TASK_INT_W_PHY_DOWN:
+		case LINK_ADMIN_TASK_COMP_W_RESP:
+		case CSMI_TASK_COMP_WO_ERR:
+		case ATA_TASK_COMP_W_RESP:
+		case TASK_INT_W_NAK_RCVD:
+		case RESUME_COMPLETE:
+		case TASK_INT_W_ACKNAK_TO:
+		case TASK_F_W_SMPRSP_TO:
+		case TASK_F_W_SMP_XMTRCV_ERR:
+		case TASK_F_W_NAK_RCVD:
+		case TASK_ABORTED_BY_ITNL_EXP:
+		case ATA_TASK_COMP_W_R_ERR_RCVD:
+		case TMF_F_W_TC_NOT_FOUND:
+		case TASK_ABORTED_ON_REQUEST:
+		case TMF_F_W_TAG_NOT_FOUND:
+		case TMF_F_W_TAG_ALREADY_FREE:
+		case TMF_F_W_TASK_ALREADY_DONE:
+		case TMF_F_W_CONN_HNDL_NOT_FOUND:
+		case TASK_CLEARED:
+		case TASK_UA_W_SYNCS_RCVD:
+		case TASK_UNACKED_W_BREAK_RCVD:
+		case TASK_UNACKED_W_ACKNAK_TIMEOUT:
+			asd_pop_post_stack(asd, scb, dl_entry);
+			break;
+			
+		case CONTROL_PHY_TASK_COMP:
+		{
+			struct control_phy_sb	*cntrl_phy;
+			
+			cntrl_phy = &dl_entry->stat_blk.control_phy;
+	
+			if (cntrl_phy->sb_opcode == PHY_RESET_COMPLETED) {
+				asd_hwi_process_phy_comp(asd, scb, cntrl_phy);
+			} else {
+				asd_log(ASD_DBG_RUNTIME, "Invalid status "
+					"block upcode.\n");
+			}
+
+			/* 
+			 * Post routine needs to be called if the 
+			 * CONTROL PHY is issued as result of error recovery
+			 * process or from CSMI.
+			 */
+			if ((scb->flags & SCB_RECOVERY) != 0)
+				asd_pop_post_stack(asd, scb, dl_entry);
+
+			break;
+		}
+
+		default:
+			/* 
+			 * Making default case for EDB received and
+			 * and non supported DL opcode. 
+			 */
+			if ((dl_entry->opcode >= 0xC1) && 
+			    (dl_entry->opcode <= 0xC7)) 
+				asd_hwi_process_edb(asd, dl_entry);
+			else
+				asd_log(ASD_DBG_RUNTIME, 
+					"Received unsupported "
+					"DL entry (opcode = 0x%x).\n",
+				  	 dl_entry->opcode);
+		      	
+			break;
+
+		}
+
+		asd->dl_next = (asd->dl_next + 1) & asd->dl_wrap_mask;
+		if (asd->dl_next == 0)
+			asd->dl_valid ^= ASD_DL_TOGGLE_MASK;
+	}
+//JD
+#ifdef ASD_DEBUG
+// 	asd->debug_flag=0;
+#endif
+	asd->flags &= ~ASD_RUNNING_DONE_LIST;
+} 
+
+/*
+ * Function:
+ * 	asd_hwi_process_phy_comp()
+ * 
+ * Description:
+ * 	Process phy reset completion.
+ */
+static void
+asd_hwi_process_phy_comp(struct asd_softc *asd, struct scb *scb,
+			 struct control_phy_sb *cntrl_phy)
+{
+	struct asd_phy			*phy;
+	struct asd_control_phy_hscb 	*cntrlphy_scb;
+
+	cntrlphy_scb = &scb->hscb->control_phy;
+	phy = (struct asd_phy *) scb->io_ctx;
+
+	switch (cntrlphy_scb->sub_func) {
+	case DISABLE_PHY:
+	{
+		asd->hw_profile.enabled_phys &= ~(1 << phy->id);
+		phy->state = ASD_PHY_OFFLINE;
+
+		/*
+		 * Check if this phy is attached to a target.
+	       	 */	 
+		if (phy->src_port != NULL) {
+			/*
+			 * DC: Currently, we treat this similar to loss of 
+			 *     signal scenario.
+			 *     Need to examine the behavior once the phy is
+			 *     is disabled !!
+			 *     Prior to disabling the phy that has target
+			 *     connected, we need to abort all outstanding
+			 *     IO to the affected target ports.
+		         */	 
+			phy->attr = (ASD_SSP_INITIATOR | ASD_SMP_INITIATOR | 
+			     	     ASD_STP_INITIATOR);
+			phy->src_port->events |= ASD_LOSS_OF_SIGNAL;
+			asd_wakeup_sem(&asd->platform_data->discovery_sem);
+		}
+		
+		list_del(&scb->owner_links);	
+		asd_hwi_free_scb(asd, scb);
+
+		break;
+	}
+	
+	case ENABLE_PHY:
+		/* Check the OOB status from the link reset sequence. */
+		if (cntrl_phy->oob_status & CURRENT_OOB_DONE) {
+			if ((asd->hw_profile.enabled_phys & 
+				(1 << phy->id)) == 0)
+				asd->hw_profile.enabled_phys |= (1 << phy->id);
+
+			/* There is a device attached. */
+			if (cntrl_phy->oob_status & CURRENT_DEVICE_PRESENT) {
+				phy->attr |= ASD_DEVICE_PRESENT;
+
+				if (cntrl_phy->oob_status & CURRENT_SPINUP_HOLD)
+					phy->attr |= ASD_SATA_SPINUP_HOLD;
+
+				phy->state = ASD_PHY_WAITING_FOR_ID_ADDR;
+			} else {
+				phy->state = ASD_PHY_ONLINE;
+			}
+
+			/* Get the negotiated connection rate. */
+			if (cntrl_phy->oob_mode & PHY_SPEED_30)
+				phy->conn_rate = SAS_30GBPS_RATE;
+			else if (cntrl_phy->oob_mode & PHY_SPEED_15)
+				phy->conn_rate = SAS_15GBPS_RATE;
+			
+			/* Get the transport mode. */
+			if (cntrl_phy->oob_mode & SAS_MODE)
+				phy->attr |= ASD_SAS_MODE;
+			else if (cntrl_phy->oob_mode & SATA_MODE)
+				phy->attr |= ASD_SATA_MODE;
+		} else if (cntrl_phy->oob_status & CURRENT_SPINUP_HOLD) {
+			/*	
+			 * SATA target attached that has not been transmitted
+			 * COMWAKE (spun-up).
+			 */
+			asd_log(ASD_DBG_RUNTIME, "CURRENT SPINUP HOLD.\n");
+		
+			phy->attr |= ASD_SATA_SPINUP_HOLD;
+			phy->state = ASD_PHY_WAITING_FOR_ID_ADDR;
+
+		} else if (cntrl_phy->oob_status & CURRENT_ERR_MASK) {
+			asd_log(ASD_DBG_ERROR, "OOB ERROR.\n");
+			
+			phy->state = ASD_PHY_OFFLINE;
+		} else {
+			/* 
+			 * This should be the case when no device is
+			 * connected.
+			 */
+			phy->state = ASD_PHY_ONLINE;
+		}
+
+#ifdef ASD_TEST
+		asd_hwi_dump_phy(phy);
+#endif
+		if ((scb->flags & SCB_RECOVERY) == 0) {
+			list_del(&scb->owner_links);	
+			asd_hwi_free_scb(asd, scb);
+			asd_wakeup_sem(&asd->platform_data->discovery_sem);
+		} else {
+			if (phy->state == ASD_PHY_OFFLINE)
+				scb->eh_status = SCB_EH_FAILED;	
+			else
+				scb->eh_status = SCB_EH_SUCCEED;
+		}
+		break;
+
+	case RELEASE_SPINUP_HOLD:
+		/* To be implemented */
+		asd_log(ASD_DBG_RUNTIME,
+			"CONTROL PHY : RELEASE SPINUP HOLD.\n");
+		break;
+	
+	case PHY_NO_OP:
+		asd_log(ASD_DBG_RUNTIME, "CONTROL PHY : PHY NO OP.\n");
+
+		if ((scb->flags & SCB_RECOVERY) != 0) {
+			/*
+		 	 * PHY NO OP control completion. The phy no op was 
+			 * issued after HARD RESET completion.
+		 	 */
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_SUCCEED;
+		}
+		break;
+
+	case EXECUTE_HARD_RESET:
+		asd_log(ASD_DBG_RUNTIME,"CONTROL PHY : EXECUTE HARD RESET.\n");
+
+		if ((scb->flags & SCB_RECOVERY) != 0) {
+			/* 
+	    	 	 * Upon HARD RESET completion, we need to issue 
+			 * PHY NO OP control to enable the hot-plug timer 
+			 * which was disabled prior to issuing HARD RESET.
+		 	 */
+			scb->eh_state = SCB_EH_PHY_NO_OP_REQ;
+			scb->eh_status = SCB_EH_SUCCEED;
+		}
+		break;
+
+	default:
+		asd_log(ASD_DBG_RUNTIME,
+			"CONTROL PHY : INVALID SUBFUNC OPCODE.\n");
+		break;
+	}
+
+	return;
+}
+
+#ifdef ASD_TEST
+static void
+asd_hwi_dump_phy(struct asd_phy  *phy)
+{
+	u_char	i;
+	struct asd_port	*port;
+
+	port = phy->src_port;
+	
+	asd_print("Phy Id = 0x%x.\n", phy->id);
+	asd_print("Phy attr = 0x%x.\n", phy->attr);
+	asd_print("Phy state = 0x%x.\n", phy->state);
+	asd_print("Phy conn_rate = 0x%x.\n", phy->conn_rate);
+	asd_print("Phy src port = %p.\n", phy->src_port);
+	for (i = 0; i < 8; i++)
+		asd_print("Phy %d SAS ADDR[%d]=0x%x.\n", phy->id, i,
+				phy->sas_addr[i]);
+}
+#endif
+
+union edb *
+asd_hwi_indexes_to_edb(struct asd_softc *asd, struct scb **pscb,
+		       u_int escb_index, u_int edb_index)
+{
+	struct scb 		*scb;
+	struct asd_empty_hscb 	*escb;
+	struct empty_buf_elem 	*ebe;
+
+	if (escb_index > asd->hw_profile.max_scbs)
+		return (NULL);
+	scb = asd->scbindex[escb_index];
+	if (scb == NULL)
+		return (NULL);
+	escb = &scb->hscb->empty_scb;
+	ebe = &escb->buf_elem[edb_index];
+	if (ELEM_BUFFER_VALID_FIELD(ebe) != ELEM_BUFFER_VALID)
+		return (NULL);
+	*pscb = scb;
+	return (asd_hwi_get_edb_vaddr(asd, asd_le64toh(ebe->busaddr)));
+}
+
+/*
+ * Function:
+ * 	asd_hwi_process_edb()
+ *
+ * Description:
+ *	Process Empty Data Buffer that was posted by the sequencer.
+ */
+static void
+asd_hwi_process_edb(struct asd_softc *asd, struct asd_done_list *dl_entry)
+{
+	struct edb_rcvd_sb	*edbr;
+	union  edb		*edb;
+	struct scb		*scb;
+	struct asd_phy		*phy;
+	u_char			 phy_id;
+	u_char			 elem_id;
+
+	edbr = &dl_entry->stat_blk.edb_rcvd;
+	elem_id = (dl_entry->opcode & EDB_OPCODE_MASK) - 1;
+	phy_id = edbr->sb_opcode & EDB_OPCODE_MASK;
+	phy = asd->phy_list[phy_id];
+	edbr->sb_opcode &= ~EDB_OPCODE_MASK;	
+	
+	edb = asd_hwi_indexes_to_edb(asd, &scb,
+				     asd_le16toh(dl_entry->index),
+				     elem_id);
+
+	switch (edbr->sb_opcode) {
+	case BYTES_DMAED:
+	{
+		struct bytes_dmaed_subblk	*bytes_dmaed;
+		u_int				 bytes_rcvd;
+
+		bytes_dmaed = &edbr->edb_subblk.bytes_dmaed;
+		bytes_rcvd = asd_le16toh(bytes_dmaed->edb_len) & 
+			     BYTES_DMAED_LEN_MASK;
+
+		if (bytes_rcvd > sizeof(union sas_bytes_dmaed))
+			bytes_rcvd = sizeof(union sas_bytes_dmaed);
+
+		memcpy(&phy->bytes_dmaed_rcvd.id_addr_rcvd, edb, bytes_rcvd);
+		phy->events |= ASD_ID_ADDR_RCVD;
+		phy->state = ASD_PHY_WAITING_FOR_ID_ADDR;
+		asd_wakeup_sem(&asd->platform_data->discovery_sem);
+
+#ifdef ASD_TEST
+		asd_hwi_dump_phy_id_addr(phy);
+#endif
+
+		break;
+	}
+
+	case PRIMITIVE_RCVD:
+	{
+		struct primitive_rcvd_subblk	*prim_rcvd;
+
+		prim_rcvd = &edbr->edb_subblk.prim_rcvd;
+		asd_log(ASD_DBG_RUNTIME,
+			"EDB: PRIMITIVE RCVD. Addr = 0x%x, Cont = 0x%x\n", 
+			 prim_rcvd->reg_addr, prim_rcvd->reg_content);
+		/*
+		 * Only process primitive for phy(s) that already associated
+		 * with port.
+		 */
+		if (phy->src_port != NULL)
+			asd_hwi_process_prim_event(asd, phy,
+						   prim_rcvd->reg_addr,
+						   prim_rcvd->reg_content);
+		break;
+	}
+	
+	case PHY_EVENT:
+	{
+		struct phy_event_subblk *phy_event;
+
+		phy_event = &edbr->edb_subblk.phy_event;
+		asd_log(ASD_DBG_RUNTIME,
+			"EDB: PHY_EVENT. Stat 0x%x, Mode 0x%x, Sigs = 0x%x\n",
+			phy_event->oob_status, phy_event->oob_mode,
+			phy_event->oob_signals);
+
+		phy_event->oob_status &= CURRENT_PHY_MASK;
+		asd_hwi_process_phy_event(asd, phy, 
+					  phy_event->oob_status,
+					  phy_event->oob_mode);
+		break;
+	}
+	
+	case LINK_RESET_ERR:
+	{
+		struct link_reset_err_subblk	*link_rst;
+
+		link_rst = &edbr->edb_subblk.link_reset_err;
+
+		asd_log(ASD_DBG_RUNTIME, "EDB: LINK RESET ERRORS. \n");
+		asd_log(ASD_DBG_RUNTIME, "Timedout waiting %s from Phy %d.\n",
+			((link_rst->error == RCV_FIS_TIMER_EXP) ?
+			 "Initial Device-to-Host Register FIS"  :
+			 "IDENTITY Address Frame"), 
+			phy_id);
+
+		asd_hwi_handle_link_rst_err(asd, phy);
+
+		break;
+
+	}
+
+	case TIMER_EVENT:
+	{
+		struct timer_event_subblk *timer_event;
+
+		timer_event = &edbr->edb_subblk.timer_event; 
+
+		asd_log(ASD_DBG_RUNTIME, "EDB: TIMER EVENT. Error = 0x%x \n", 
+			timer_event->error);
+
+		asd_hwi_process_timer_event(asd, phy, timer_event->error); 
+
+		break;
+	}
+	
+	case REQ_TASK_ABORT:
+	{
+		struct req_task_abort_subblk	*req_task_abort;
+			
+		asd_log(ASD_DBG_RUNTIME, "EDB: REQUEST TASK ABORT. \n");
+
+		req_task_abort = &edbr->edb_subblk.req_task_abort; 
+
+		asd_log(ASD_DBG_RUNTIME, "Req TC to Abort = 0x%x, "
+			"Reason = 0x%x.\n", req_task_abort->task_tc_to_abort,
+			req_task_abort->reason);
+
+		asd_hwi_process_req_task(asd, edbr->sb_opcode,
+					 req_task_abort->task_tc_to_abort);
+		break;
+	}
+		
+	case REQ_DEVICE_RESET:
+	{
+		struct req_dev_reset_subblk	*req_dev_reset;
+
+		asd_log(ASD_DBG_RUNTIME, "EDB: REQUEST DEVICE RESET. \n");
+
+		req_dev_reset = &edbr->edb_subblk.req_dev_reset; 
+
+		asd_log(ASD_DBG_RUNTIME, "Req TC to Reset = 0x%x, "
+			"Reason = 0x%x.\n", req_dev_reset->task_tc_to_abort,
+			req_dev_reset->reason);
+
+		asd_hwi_process_req_task(asd, edbr->sb_opcode,
+					 req_dev_reset->task_tc_to_abort);
+		break;
+	}
+
+	default:
+		asd_log(ASD_DBG_RUNTIME, "Invalid EDB opcode.\n");
+		break;
+	}
+		
+	asd_hwi_free_edb(asd, scb, (elem_id));
+}
+
+/*
+ * Function:
+ * 	asd_hwi_process_prim_event()
+ * 
+ * Description:
+ *	Process any recevied primitives that are not handled by the 
+ *	firmware (eg. BROADCAST, HARD_RESET, etc.)
+ */
+static void
+asd_hwi_process_prim_event(struct asd_softc *asd, struct asd_phy *phy,
+			   u_int reg_addr, u_int reg_content)
+{
+	uint32_t	reg_val;
+
+	reg_val = 0;
+	if (reg_addr == LmPRMSTAT0BYTE1) {
+		/* 
+		 * First byte of Primitive Status register is intended for
+		 * BROADCAST primitives.
+		 */
+		reg_val = (reg_content << 8) & 0xFF00;
+		switch (reg_val) {
+		case LmBROADCH:
+		case LmBROADRVCH0:
+		case LmBROADRVCH1:
+			asd_log(ASD_DBG_RUNTIME, "BROADCAST PRIMITIVE "
+				"received.\n");
+			/* 
+			 * Set the event that discovery is needed and
+			 * wakeup discovery thread.  
+			 */ 
+			if(phy->src_port->events & ASD_DISCOVERY_PROCESS)
+				phy->src_port->events |= ASD_DISCOVERY_RETRY;
+			else
+				phy->src_port->events = ASD_DISCOVERY_REQ;
+			asd_wakeup_sem(&asd->platform_data->discovery_sem);
+			phy->brdcst_rcvd_cnt++;
+			break;
+
+		default:
+			asd_log(ASD_DBG_ERROR, "Unsupported BROADCAST "
+				"primitive.\n");
+			break;
+		}
+	} else if (reg_addr == LmPRMSTAT1BYTE0) {
+		reg_val = reg_content & 0xFF;
+		if (reg_val == LmHARDRST) {
+			asd_log(ASD_DBG_RUNTIME, "HARD_RESET primitive "
+				"received.\n");
+		}
+	} else if (reg_addr == LmPRMSTAT0BYTE3) {
+		reg_val = (reg_content << 24) & 0xFF000000;
+		if (reg_val == LmUNKNOWNP) {
+			asd_log(ASD_DBG_RUNTIME, "Undefined primitive "
+				"received.\n");
+		}
+	} else {
+		asd_log(ASD_DBG_ERROR, "Unsupported PRIMITIVE STATUS REG.\n");
+	}
+}
+
+/*
+ * Function:
+ * 	asd_hwi_process_phy_event()
+ * 
+ * Description:
+ *	Process received async. phy events.
+ */
+static void
+asd_hwi_process_phy_event(struct asd_softc *asd, struct asd_phy *phy, 
+			  u_int oob_status, u_int oob_mode)
+{
+	switch (oob_status) {
+	case DEVICE_REMOVED:
+		/*
+		 * We received a phy event that notified us that the 
+		 * signal is lost with the direct attached device to 
+		 * this phy. The device has been hot removed.
+		 */	 
+		asd_log(ASD_DBG_RUNTIME, 
+			"PHY_EVENT (%d) - DEVICE HOT REMOVED.\n", phy->id);
+		phy->state = ASD_PHY_ONLINE;
+		phy->attr = (ASD_SSP_INITIATOR | ASD_SMP_INITIATOR | 
+			     ASD_STP_INITIATOR);
+
+		if (phy->src_port != NULL)
+			phy->src_port->events |= ASD_LOSS_OF_SIGNAL;
+
+		asd_wakeup_sem(&asd->platform_data->discovery_sem);
+		break;
+
+	case DEVICE_ADDED_W_CNT:
+	case DEVICE_ADDED_WO_CNT:
+		asd_log(ASD_DBG_RUNTIME,
+			"PHY_EVENT (%d) - DEVICE HOT ADDED.\n", phy->id);
+
+		/* There is a device attached. */
+		if (oob_status & CURRENT_DEVICE_PRESENT) {
+			phy->attr |= ASD_DEVICE_PRESENT;
+
+			if (oob_status & CURRENT_SPINUP_HOLD)
+				phy->attr |= ASD_SATA_SPINUP_HOLD;
+
+			phy->state = ASD_PHY_WAITING_FOR_ID_ADDR;
+		}
+
+		/* Get the negotiated connection rate. */
+		if (oob_mode & PHY_SPEED_30) {
+			phy->conn_rate = SAS_30GBPS_RATE;
+		} else if (oob_mode & PHY_SPEED_15) {
+			phy->conn_rate = SAS_15GBPS_RATE;
+		}
+			
+		/* Get the transport mode. */
+		if (oob_mode & SAS_MODE) {
+			phy->attr |= ASD_SAS_MODE;
+		} else if (oob_mode & SATA_MODE) {
+			phy->attr |= ASD_SATA_MODE;
+		}
+
+		break;
+	
+	case CURRENT_OOB1_ERROR:
+	case CURRENT_OOB2_ERROR:
+		asd_print("PHY_EVENT (%d) - OOB ERROR.\n", phy->id);
+		break;
+	
+	default:
+		asd_log(ASD_DBG_ERROR,
+			"PHY_EVENT (%d) - UNKNOWN EVENT 0x%x.\n", phy->id,
+			oob_status);
+		break;
+	}
+}
+
+/*
+ * Function:
+ * 	asd_hwi_process_timer_event()
+ * 
+ * Description:
+ *	Process received async. timer events.
+ */
+static void
+asd_hwi_process_timer_event(struct asd_softc *asd, struct asd_phy *phy, uint8_t	error)
+{
+	switch (error) {
+	case DWS_RESET_TO_EXP:
+		/*
+		 * We received a DWS timer event that the direct attached device may be lost,
+		 * let's remove the device and restart a discovery.
+		 */	 
+		asd_log(ASD_DBG_RUNTIME, 
+			"TIMER_EVENT (%d) - DWS_RESET_TO_EXP.\n", phy->id);
+		phy->state = ASD_PHY_ONLINE;
+		phy->attr = (ASD_SSP_INITIATOR | ASD_SMP_INITIATOR | 
+			     ASD_STP_INITIATOR);
+
+		if (phy->src_port != NULL)
+			phy->src_port->events |= ASD_LOSS_OF_SIGNAL;
+
+		asd_wakeup_sem(&asd->platform_data->discovery_sem);
+		break;
+
+	default:
+		asd_log(ASD_DBG_ERROR,
+			"TIMER_EVENT (%d) - UNKNOWN EVENT 0x%x.\n", phy->id,
+			error);
+		break;
+	}
+}
+
+#ifdef ASD_TEST
+static void
+asd_hwi_dump_phy_id_addr(struct asd_phy  *phy)
+{
+	u_char	i;
+
+	asd_print("ID ADDRESS FRAME RECEIVED.\n");
+	asd_print("Addr Frame Type = 0x%x.\n", 
+			phy->bytes_dmaed_rcvd.id_addr_rcvd.addr_frame_type);
+	asd_print("Init Port Type = 0x%x.\n", 
+			phy->bytes_dmaed_rcvd.id_addr_rcvd.init_port_type);
+	asd_print("Tgt Port Type = 0x%x.\n", 
+			phy->bytes_dmaed_rcvd.id_addr_rcvd.tgt_port_type);
+	asd_print("Phy ID = 0x%x.\n", 
+			phy->bytes_dmaed_rcvd.id_addr_rcvd.phy_id);
+	for (i = 0; i < 8; i++)
+		asd_print("TGT Sas Addr[%d] = 0x%x.\n",
+			i, phy->bytes_dmaed_rcvd.id_addr_rcvd.sas_addr[i]);
+}
+#endif 
+
+/*
+ * Function:
+ * 	asd_hwi_handle_link_rst_err()
+ * 
+ * Description:
+ *	Handle Link Reset Error event as a result of timedout while
+ *	waiting for Identity Frame Address or Initial Device-to-Host
+ *	Register FIS from direct-attached device.
+ */
+static void
+asd_hwi_handle_link_rst_err(struct asd_softc *asd, struct asd_phy *phy)
+{
+	struct scb	*scb;
+
+	/*
+	 * We are skipping OOB register initialization as it was done
+	 * the first time we enable the phy.
+	 * Should we redo this initialization again??
+	 */
+
+	/*
+	 * We want to retry the link reset sequence up to a certain
+	 * amount of time to retry establishing connection with the device.
+	 */
+	if (phy->link_rst_cnt > MAX_LINK_RESET_RETRY) {
+		/* 
+		 * We have tried link reset a few times, the device still
+	 	 * failed to return the ID Frame Addr or Device-to-Host
+		 * Register FIS.
+		 * End the discovery process for this phy.
+		 */
+		phy->state = ASD_PHY_ONLINE;
+		phy->attr = (ASD_SSP_INITIATOR | ASD_SMP_INITIATOR | 
+			     ASD_STP_INITIATOR);
+		asd_wakeup_sem(&asd->platform_data->discovery_sem);
+	}
+
+	if ((scb = asd_hwi_get_scb(asd, 0)) == NULL) {
+		asd_log(ASD_DBG_ERROR, "Out of SCB resources.\n");
+
+		return;
+	}
+
+	scb->io_ctx = (void *) phy;
+	scb->flags |= SCB_INTERNAL;
+
+	asd_hwi_build_control_phy(scb, phy, ENABLE_PHY);
+
+	list_add_tail(&scb->owner_links, &phy->pending_scbs);
+	phy->link_rst_cnt++;
+	asd_hwi_post_scb(asd, scb);
+}
+
+/*
+ * Function:
+ * 	asd_hwi_process_req_task()
+ * 
+ * Description:
+ *	Process the requested task recevied from the sequencer.
+ */
+static void
+asd_hwi_process_req_task(struct asd_softc *asd, uint8_t req_type,
+			 uint16_t index)
+{
+	struct scb	*scb;
+	int		 found;
+
+	if ((req_type != REQ_TASK_ABORT) && (req_type != REQ_DEVICE_RESET)) {
+		asd_log(ASD_DBG_ERROR, "Unsupported REQ TASK 0x%x.\n",
+			req_type);
+		return;
+	}
+
+	found = 0;
+	list_for_each_entry(scb, &asd->platform_data->pending_os_scbs,
+			    owner_links) {
+		if (SCB_GET_INDEX(scb) == index) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (found == 0) {
+		asd_log(ASD_DBG_ERROR, "REQ TASK with invalid TC.\n");
+#ifdef DEBUG_DDB
+#ifdef ASD_DEBUG
+		{
+			u_long	lseqs_to_dump;
+			u_int	lseq_id;
+			int		indx;
+
+			for(indx=0;indx< asd->ddb_bitmap_size; indx++)
+			{
+				lseqs_to_dump = asd->free_ddb_bitmap[indx];
+				lseq_id = 0;
+
+				while (lseqs_to_dump != 0) { 
+					for ( ; lseq_id < (8 * sizeof(u_long)); lseq_id++) {
+						if (lseqs_to_dump & (1UL << lseq_id)) {
+							lseqs_to_dump &= ~(1UL << lseq_id);
+							break;
+						} 
+					}
+		/* Dump out specific LSEQ Registers state. */
+					asd_hwi_dump_ssp_smp_ddb_site(asd, lseq_id + (indx * 8 * sizeof(ulong)));
+				}
+			}
+		}
+		asd_hwi_dump_seq_state(asd, asd->hw_profile.enabled_phys);
+#endif
+#endif
+		return;
+	}
+
+	if (req_type == REQ_TASK_ABORT)
+		scb->eh_state = SCB_EH_ABORT_REQ;
+	else
+		scb->eh_state = SCB_EH_DEV_RESET_REQ;
+
+	scb->flags |= SCB_TIMEDOUT;
+	scb->eh_post = asd_hwi_req_task_done;
+	list_add_tail(&scb->timedout_links, &asd->timedout_scbs);
+	asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+}
+
+static void
+asd_hwi_req_task_done(struct asd_softc *asd, struct scb *scb)
+{
+	asd_log(ASD_DBG_ERROR, "Req Task completed.\n");
+}
+
+/*************** Helper Functions to build a specific SCB type. ***************/
+
+/*
+ * Function:
+ * 	asd_hwi_build_id_frame()
+ *
+ * Description:
+ *	Build an Identify Frame address.
+ */
+static void
+asd_hwi_build_id_frame(struct asd_phy *phy)
+{
+	struct sas_id_addr	*id_addr;
+	u_char			 i;
+
+	id_addr = (struct sas_id_addr *) phy->id_addr_map.vaddr;
+	memset(id_addr, 0x0, sizeof(*id_addr));
+
+	/* Set the device type to end-device. */
+	id_addr->addr_frame_type |= SAS_END_DEVICE;	
+
+	for (i = 0; i < SAS_ADDR_LEN; i++) 
+		id_addr->sas_addr[i] = phy->sas_addr[i]; 
+	
+	/* Set the Initiator Port attributes. */
+	id_addr->init_port_type = (SSP_INIT_PORT | STP_INIT_PORT | 
+				   SMP_INIT_PORT);
+	id_addr->phy_id = phy->id;
+}
+
+/* 
+ * Function:
+ *	asd_hwi_build_control_phy()
+ *
+ * Description:
+ *      Build a CONTROL PHY SCB.
+ *	CONTROL PHY SCB is used to control the operation of a phy, such as
+ *	enable or disable phy, execute hard reset, release spinup hold and
+ *	control ATA device.
+ */
+void
+asd_hwi_build_control_phy(struct scb *scb, struct asd_phy *phy, 
+			  uint8_t sub_func)
+{
+	struct asd_control_phy_hscb 	*cntrlphy_hscb;
+	uint8_t 			 phy_id;
+	uint8_t				 speed_mask;
+
+	speed_mask = 0;
+	phy_id = phy->id;
+	cntrlphy_hscb = &scb->hscb->control_phy;
+
+	cntrlphy_hscb->header.opcode = SCB_CONTROL_PHY;
+	cntrlphy_hscb->phy_id = phy_id;
+	cntrlphy_hscb->sub_func = sub_func;
+
+	if ((cntrlphy_hscb->sub_func == ENABLE_PHY) || 
+	    (cntrlphy_hscb->sub_func == EXECUTE_HARD_RESET) ||
+	    (cntrlphy_hscb->sub_func == PHY_NO_OP)) {
+		cntrlphy_hscb->func_mask = FUNCTION_MASK_DEFAULT;
+
+		/* 
+		 * Hot Plug timer needs to be disabled while performing
+		 * Hard Reset.
+		 */
+		if (cntrlphy_hscb->sub_func == EXECUTE_HARD_RESET)
+			cntrlphy_hscb->func_mask |= HOT_PLUG_DIS;
+
+		/* mask all speeds */
+		speed_mask = (SAS_SPEED_60_DIS | SAS_SPEED_30_DIS |
+			      SAS_SPEED_15_DIS | SATA_SPEED_30_DIS |
+			      SATA_SPEED_15_DIS);
+
+		/* enable required speed */	
+		asd_hwi_set_speed_mask(phy->max_link_rate, &speed_mask); 
+		asd_hwi_set_speed_mask(phy->min_link_rate, &speed_mask);
+
+		/* Razor should enable 1.5 Gbs and disable 3 Gbs for SATA */
+		speed_mask &= ~SATA_SPEED_15_DIS;
+		speed_mask |= SATA_SPEED_30_DIS;
+
+#if SAS_COMSTOCK_SUPPORT
+		/* COMSTOCK only support 1.5 Gbits/s data transfer. */
+		speed_mask &= ~SATA_SPEED_15_DIS;
+		cntrlphy_hscb->speed_mask = speed_mask | (SATA_SPEED_30_DIS | 
+					    SAS_SPEED_60_DIS |
+					    SAS_SPEED_30_DIS);	 
+#else
+		cntrlphy_hscb->speed_mask = speed_mask;
+#endif
+		/* Set to Hot plug time delay to 100 ms. */
+		cntrlphy_hscb->hot_plug_delay = HOTPLUG_DEFAULT_DELAY;
+		cntrlphy_hscb->port_type = (SSP_INITIATOR_PORT | 
+					    STP_INITIATOR_PORT |
+					    SMP_INITIATOR_PORT);
+	} else {
+		cntrlphy_hscb->func_mask = 0;
+		cntrlphy_hscb->speed_mask = 0;
+		cntrlphy_hscb->hot_plug_delay = 0;
+		cntrlphy_hscb->port_type = 0;
+	}
+
+#ifdef SEQUENCER_UPDATE
+	cntrlphy_hscb->device_present_timer_ovrd_enable = 0;
+	cntrlphy_hscb->device_present_timeout_const_override = 0;
+#else
+	cntrlphy_hscb->ovrd_cominit_timer = 0;
+	cntrlphy_hscb->cominit_timer_const_ovrd = 0;
+#endif
+	memset(&cntrlphy_hscb->res1[0], 0x0, 111);
+	cntrlphy_hscb->conn_handle = 0xFFFF;
+}
+
+/* 
+ * Function:
+ *	asd_hwi_build_abort_task()
+ *
+ * Description:
+ *      Build an ABORT TASK SCB.
+ *	ABORT TASK scb is used to abort an SCB previously sent to the 
+ *	firmware.
+ */
+void
+asd_hwi_build_abort_task(struct scb *scb, struct scb *scb_to_abort)
+{
+	struct asd_abort_task_hscb	*abort_hscb;
+	struct asd_target		*targ;
+
+	targ = scb_to_abort->platform_data->targ;
+	abort_hscb = &scb->hscb->abort_task;
+	abort_hscb->header.opcode = SCB_ABORT_TASK;
+
+	memset(&abort_hscb->protocol_conn_rate, 0x0,
+	       offsetof(struct asd_abort_task_hscb, res3) -
+	       offsetof(struct asd_abort_task_hscb, protocol_conn_rate));
+	/* 
+	 * The conn_rate is only valid when aborting an SCB with SSP protocol.
+	 */
+	if (targ->transport_type == ASD_TRANSPORT_SSP)
+		abort_hscb->protocol_conn_rate = targ->ddb_profile.conn_rate;
+
+	if ((SCB_GET_OPCODE(scb_to_abort) == SCB_INITIATE_SSP_TASK) ||
+	    (SCB_GET_OPCODE(scb_to_abort) == SCB_INITIATE_LONG_SSP_TASK)) 
+		abort_hscb->protocol_conn_rate |= PROTOCOL_TYPE_SSP;
+	else if ((SCB_GET_OPCODE(scb_to_abort) == SCB_INITIATE_ATA_TASK) ||
+		 (SCB_GET_OPCODE(scb_to_abort) == SCB_INITIATE_ATAPI_TASK))
+		abort_hscb->protocol_conn_rate |= PROTOCOL_TYPE_STP;
+	else
+		abort_hscb->protocol_conn_rate |= PROTOCOL_TYPE_SMP;
+	/*
+	 * Build SSP Frame Header and SSP Task IU, these fields only valid
+         * when aborting an SCB with SSP protocol.
+	 */
+	if (targ->transport_type == ASD_TRANSPORT_SSP) {
+		/* SSP Frame Header. */
+		abort_hscb->sas_header.frame_type = TASK_FRAME;
+		memcpy(abort_hscb->sas_header.hashed_dest_sasaddr,
+		       targ->ddb_profile.hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+		memcpy(abort_hscb->sas_header.hashed_src_sasaddr,
+		       targ->src_port->hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+		abort_hscb->sas_header.target_port_xfer_tag = 0xFFFF;
+		abort_hscb->sas_header.data_offset = 0;
+
+		/* SSP Task IU. */
+		if (scb_to_abort->platform_data->dev != NULL) {
+			/*
+			 * We could be aborting task for SMP target or
+		         * target during discovery and there is no device
+			 * associated with that target.
+			 */	 
+			memcpy(abort_hscb->task_iu.lun,
+			       scb_to_abort->platform_data->dev->saslun,
+			       SAS_LUN_LEN);
+		}
+
+		abort_hscb->task_iu.tmf = ABORT_TASK_TMF;
+		/*
+		 * Setting tag_to_manage to 0xFFFF will indicate the sequencer
+	         * to use conn_handle, lun, and tc_to_abort to determine the
+		 * I_T_L_Q nexus of the task to be aborted.
+		 */	 
+		abort_hscb->task_iu.tag_to_manage = 0xFFFF;
+	}
+
+	abort_hscb->sister_scb = 0xFFFF;
+	abort_hscb->conn_handle = targ->ddb_profile.conn_handle;
+
+	/* 
+	 * For Aborting SSP Task, we need to suspend the data transmission
+	 * of the task to be aborted.
+	 */
+	if (SCB_GET_OPCODE(scb_to_abort) == SCB_INITIATE_SSP_TASK) {
+		abort_hscb->suspend_data = SUSPEND_DATA;
+		scb->eh_state |= SCB_EH_SUSPEND_SENDQ;
+	}
+
+	abort_hscb->retry_cnt = TASK_RETRY_CNT;
+
+	/* Set the TC to be aborted. */
+	abort_hscb->tc_to_abort = asd_htole16(SCB_GET_INDEX(scb_to_abort));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_build_query_task()
+ *
+ * Description:
+ *      Build an QUERY TASK SCB.
+ *	QUERY TASK scb is used to issue an SSP Task IU for a Query Task
+ *	Task Management Function.
+ */
+void
+asd_hwi_build_query_task(struct scb *scb, struct scb *scb_to_query)
+{
+	struct asd_query_ssp_task_hscb	*query_hscb;
+	struct asd_target		*targ;
+
+	targ = scb_to_query->platform_data->targ;
+	query_hscb = &scb->hscb->query_ssp_task;
+	query_hscb->header.opcode = SCB_QUERY_SSP_TASK;
+
+	memset(&query_hscb->protocol_conn_rate, 0x0,
+	       offsetof(struct asd_query_ssp_task_hscb, res3) -
+	       offsetof(struct asd_query_ssp_task_hscb, protocol_conn_rate));
+		
+	query_hscb->protocol_conn_rate = (targ->ddb_profile.conn_rate |
+					  PROTOCOL_TYPE_SSP);
+	/* SSP Frame Header. */
+	query_hscb->sas_header.frame_type = TASK_FRAME;
+	memcpy(query_hscb->sas_header.hashed_dest_sasaddr,
+	       targ->ddb_profile.hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+	memcpy(query_hscb->sas_header.hashed_src_sasaddr,
+	       targ->src_port->hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+	query_hscb->sas_header.target_port_xfer_tag = 0xFFFF;
+	query_hscb->sas_header.data_offset = 0;
+
+	/* SSP Task IU. */
+	query_hscb->task_iu.tmf = QUERY_TASK_TMF;
+	/*
+	 * Setting tag_to_manage to 0xFFFF will indicate the sequencer
+         * to use conn_handle, lun, and tc_to_query to determine the
+	 * I_T_L_Q nexus of the task to be queried.
+	 */	 
+	query_hscb->task_iu.tag_to_manage = 0xFFFF;
+
+	query_hscb->sister_scb = 0xFFFF;
+	query_hscb->conn_handle = targ->ddb_profile.conn_handle;
+	query_hscb->retry_cnt = TASK_RETRY_CNT;
+	/* Set the TC to be queried. */
+	query_hscb->tc_to_query = asd_htole16(SCB_GET_INDEX(scb_to_query));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_build_clear_nexus()
+ *
+ * Description:
+ *      Build a CLEAR NEXUS SCB.
+ *	CLEAR NEXUS SCB is used to request the firmware that a set of pending
+ *	transactions pending for a specified nexus be return to the driver
+ *	and free the associated SCBs to the free list.
+ */
+void
+asd_hwi_build_clear_nexus(struct scb *scb, u_int nexus_ind, u_int parm,
+			  u_int context)
+{
+	struct asd_clear_nexus_hscb	*clr_nxs_hscb;
+	struct asd_target		*targ;
+
+#define RESUME_SENDQ_REQ					\
+do {								\
+	if (context == SCB_EH_RESUME_SENDQ) 			\
+		clr_nxs_hscb->queue_ind = (uint8_t) RESUME_TX;	\
+} while (0)
+	
+	clr_nxs_hscb = &scb->hscb->clear_nexus;
+	clr_nxs_hscb->header.opcode = SCB_CLEAR_NEXUS;
+	targ = scb->platform_data->targ;
+	
+	memset(&clr_nxs_hscb->nexus_ind, 0x0, 
+	       offsetof(struct asd_clear_nexus_hscb, res8) - 
+	       offsetof(struct asd_clear_nexus_hscb, nexus_ind));
+	
+	clr_nxs_hscb->nexus_ind = nexus_ind;
+	switch (nexus_ind) {
+	case CLR_NXS_I_OR_T:
+		/* Clear Nexus intended for I or T. */
+		clr_nxs_hscb->conn_mask_to_clr = targ->src_port->conn_mask;
+		break;
+
+	case CLR_NXS_I_T_L:
+		/* Clear Nexus intended for I_T_L. */
+		if (scb->platform_data->dev != NULL) {
+			memcpy(clr_nxs_hscb->lun_to_clr,
+			       scb->platform_data->dev->saslun,
+			       SAS_LUN_LEN);
+		}
+		/* Fallthrough */
+	case CLR_NXS_IT_OR_TI:
+		/* Clear Nexus intended for I_T or T_I. */
+		clr_nxs_hscb->conn_handle_to_clr = 
+					targ->ddb_profile.conn_handle;
+		clr_nxs_hscb->queue_ind = (uint8_t) parm;
+		RESUME_SENDQ_REQ;
+
+		break;
+		
+	case CLR_NXS_I_T_L_Q_TAG:
+		/* Clear Nexus intended for I_T_L_Q (by tag). */
+		clr_nxs_hscb->tag_to_clr = (uint16_t) parm;
+		clr_nxs_hscb->conn_handle_to_clr = 
+					targ->ddb_profile.conn_handle;
+		if (scb->platform_data->dev != NULL) {
+			memcpy(clr_nxs_hscb->lun_to_clr,
+			       scb->platform_data->dev->saslun,
+			       SAS_LUN_LEN);
+		}
+		RESUME_SENDQ_REQ;
+		break;
+
+	case CLR_NXS_I_T_L_Q_TC:
+		/* Clear Nexus intended for I_T_L_Q (by TC). */
+		clr_nxs_hscb->tc_to_clr = (uint16_t) parm;
+		clr_nxs_hscb->conn_handle_to_clr = 
+					targ->ddb_profile.conn_handle;
+		if (scb->platform_data->dev != NULL) {
+			memcpy(clr_nxs_hscb->lun_to_clr,
+			       scb->platform_data->dev->saslun,
+			       SAS_LUN_LEN);
+		}
+		RESUME_SENDQ_REQ;
+		break;
+		
+	case CLR_NXS_I_T_L_Q_STAG:
+		/* Clear Nexus intended for I_T_L_Q (by SATA tag). */
+		clr_nxs_hscb->conn_handle_to_clr = 
+					targ->ddb_profile.conn_handle;
+		/* 
+		 * Bits 4-0 of the tag_to_clr contain the SATA tag to be
+		 * cleared. Bits 15-5 shall be set to zero.
+		 */
+		clr_nxs_hscb->tag_to_clr = ((uint16_t) parm && 0x001F);
+		RESUME_SENDQ_REQ;
+		break;
+
+	case CLR_NXS_ADAPTER:
+		/* Clear Nexus for Adapter. */
+	default:
+		/* Unsupported Clear Nexus function. */
+		break;	
+	}
+
+	clr_nxs_hscb->nexus_ctx = (uint16_t) context;
+}
+
+/* 
+ * Function:
+ *	asd_hwi_build_ssp_tmf()
+ *
+ * Description:
+ *      Build a SSP TMF SCB.
+ *	SSP TMF SCB is used to issue an SSP Task information unit for a
+ *	LOGICAL UNIT RESET, ABORT TASK SET, CLEAR TASK SET, or CLEAR ACA
+ *	task management function.
+ */
+void
+asd_hwi_build_ssp_tmf(struct scb *scb, struct asd_target *targ, 
+		      uint8_t *lun, u_int tmf_opcode)
+{
+	struct asd_ssp_tmf_hscb	*tmf_hscb;
+
+	tmf_hscb = &scb->hscb->ssp_tmf;
+	tmf_hscb->header.opcode = SCB_INITIATE_SSP_TMF;
+
+	memset(&tmf_hscb->protocol_conn_rate, 0x0,
+	       offsetof(struct asd_ssp_tmf_hscb, res3) -
+	       offsetof(struct asd_ssp_tmf_hscb, protocol_conn_rate));
+
+	tmf_hscb->protocol_conn_rate = (targ->ddb_profile.conn_rate | 
+					PROTOCOL_TYPE_SSP);
+	/* SSP Frame Header. */
+	tmf_hscb->sas_header.frame_type = TASK_FRAME;
+	memcpy(tmf_hscb->sas_header.hashed_dest_sasaddr,
+	       targ->ddb_profile.hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+	memcpy(tmf_hscb->sas_header.hashed_src_sasaddr,
+	       targ->src_port->hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+	tmf_hscb->sas_header.target_port_xfer_tag = 0xFFFF;
+	tmf_hscb->sas_header.data_offset = 0;
+	
+	/* SSP Task IU. */
+	memcpy(tmf_hscb->task_iu.lun, lun, SAS_LUN_LEN);
+	tmf_hscb->task_iu.tmf = tmf_opcode;
+
+	tmf_hscb->sister_scb = 0xFFFF;
+	tmf_hscb->conn_handle = targ->ddb_profile.conn_handle;
+	
+	/* Suspend data transmission to the target. */
+	scb->eh_state |= SCB_EH_SUSPEND_SENDQ;
+	tmf_hscb->suspend_data = SUSPEND_DATA;
+	tmf_hscb->retry_cnt = TASK_RETRY_CNT;
+}
+ 
+/*
+ * Function:
+ * 	asd_hwi_build_smp_phy_req()
+ *
+ * Description:
+ *	Build a SMP PHY related request.
+ */ 
+static void
+asd_hwi_build_smp_phy_req(struct asd_port *port, int req_type,
+			  int phy_id, int ctx)
+{
+	struct SMPRequest	*smp_req;
+
+	smp_req = port->dc.SMPRequestFrame;
+	memset(smp_req, 0, sizeof(*smp_req));
+
+	smp_req->SMPFrameType = SMP_REQUEST_FRAME;
+
+	switch (req_type) {
+	case PHY_CONTROL:
+		smp_req->Function = PHY_CONTROL;
+		smp_req->Request.PhyControl.PhyIdentifier = phy_id;
+		smp_req->Request.PhyControl.PhyOperation = ctx;
+		break;
+
+	case REPORT_PHY_ERROR_LOG:
+		smp_req->Function = REPORT_PHY_ERROR_LOG;
+		smp_req->Request.ReportPhyErrorLog.PhyIdentifier = phy_id;
+		break;
+
+	default:
+		panic("Unknown SMP PHY request type.\n"); 
+		break;
+	}
+
+	/*
+	 * DC: Currently, we are not changing the programmed min/max 
+         *     physical link rate for LINK RESET or HARD RESET.
+	 *     We might need to change the link rate if CMSI application
+	 *     required..
+	 */
+}
+
+/*
+ * Function:
+ *	asd_hwi_build_smp_task()
+ *
+ * Description:
+ *	Build a SMP TASK SCB.
+ *	SMP TASK SCB is used to send an SMP TASK to an expander.
+ */ 
+void
+asd_hwi_build_smp_task(struct scb *scb, struct asd_target *targ,
+		       uint64_t req_bus_addr, u_int req_len, 
+		       uint64_t resp_bus_addr, u_int resp_len)
+{
+	struct asd_smp_task_hscb	*smp_hscb;
+
+	smp_hscb = &scb->hscb->smp_task;
+	smp_hscb->header.opcode = SCB_INITIATE_SMP_TASK;
+
+	memset(&smp_hscb->protocol_conn_rate, 0x0,
+	       offsetof(struct asd_smp_task_hscb, res5) -
+	       offsetof(struct asd_ssp_tmf_hscb, protocol_conn_rate));
+
+	smp_hscb->protocol_conn_rate = (targ->ddb_profile.conn_rate |
+					PROTOCOL_TYPE_SMP);
+	smp_hscb->smp_req_busaddr = req_bus_addr;
+	smp_hscb->smp_req_size = req_len;
+	smp_hscb->smp_req_ds = 0;
+	smp_hscb->sister_scb = 0xffff;
+	smp_hscb->conn_handle = targ->ddb_profile.conn_handle;
+	smp_hscb->smp_resp_busaddr = resp_bus_addr;
+	smp_hscb->smp_resp_size = resp_len;
+	smp_hscb->smp_resp_ds = 0;
+}
+
+/*
+ * Function:
+ *	asd_hwi_build_ssp_task()
+ *
+ * Description:
+ *	Build a SSP TASK SCB.
+ *	SSP TASK SCB is used to send an SSP TASK to an expander.
+ */ 
+void
+asd_hwi_build_ssp_task(struct scb *scb, struct asd_target *targ,
+		       uint8_t *saslun, uint8_t *cdb, uint32_t cdb_len,
+		       uint8_t addl_cdb_len, uint32_t data_len)
+{
+	struct asd_ssp_task_hscb *ssp_hscb;
+
+	ssp_hscb = &scb->hscb->ssp_task;
+	ssp_hscb->header.opcode = SCB_INITIATE_SSP_TASK;
+	ssp_hscb->protocol_conn_rate = targ->ddb_profile.conn_rate 
+					| PROTOCOL_TYPE_SSP;
+	ssp_hscb->xfer_len = asd_htole32(data_len);
+	ssp_hscb->sas_header.frame_type = OPEN_ADDR_FRAME;
+	
+	memcpy(ssp_hscb->sas_header.hashed_dest_sasaddr,
+	       targ->ddb_profile.hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+
+	ssp_hscb->sas_header.res = 0;
+
+	memcpy(ssp_hscb->sas_header.hashed_src_sasaddr,
+	       targ->src_port->hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+
+	memset(ssp_hscb->sas_header.res1, 0,
+	       offsetof(struct asd_sas_header, target_port_xfer_tag) - 
+	       offsetof(struct asd_sas_header, res1));
+
+	ssp_hscb->sas_header.target_port_xfer_tag = 0xFFFF;
+	ssp_hscb->sas_header.data_offset = 0;
+
+	/* SSP Command IU */
+	memset(ssp_hscb->lun, 0,
+	       offsetof(struct asd_ssp_task_hscb, cdb) -
+	       offsetof(struct asd_ssp_task_hscb, lun));
+	memcpy(ssp_hscb->lun, saslun, 8);
+	memcpy(ssp_hscb->cdb, cdb, cdb_len);
+	
+	memset(&ssp_hscb->cdb[cdb_len], 0,
+	      SCB_EMBEDDED_CDB_SIZE - cdb_len);
+
+	ssp_hscb->addl_cdb_len = addl_cdb_len;
+	ssp_hscb->sister_scb = 0xFFFF;
+	ssp_hscb->conn_handle = targ->ddb_profile.conn_handle;
+	ssp_hscb->retry_cnt = TASK_RETRY_CNT;
+	memset(&ssp_hscb->LAST_SSP_HSCB_FIELD, 0,
+	       offsetof(struct asd_ssp_task_hscb, sg_elements) - 
+	       offsetof(struct asd_ssp_task_hscb, LAST_SSP_HSCB_FIELD));
+
+	return;
+}
+
+/*
+ * Function:
+ *	asd_hwi_build_stp_task()
+ *
+ * Description:
+ *	Build a STP TASK SCB.
+ *	STP TASK SCB is used to send an ATA TASK to an expander.
+ */ 
+void 
+asd_hwi_build_stp_task(struct scb *scb, struct asd_target *targ,
+		       uint32_t data_len)
+{
+	struct asd_ata_task_hscb *ata_hscb;
+
+	ata_hscb = &scb->hscb->ata_task;
+	ata_hscb->header.opcode = SCB_INITIATE_ATA_TASK;
+	ata_hscb->protocol_conn_rate =
+		PROTOCOL_TYPE_SATA | targ->ddb_profile.conn_rate;
+	ata_hscb->xfer_len = asd_htole32(data_len);
+	ata_hscb->data_offset = 0;
+	ata_hscb->sister_scb = 0xffff;
+	ata_hscb->conn_handle = targ->ddb_profile.conn_handle;
+	ata_hscb->retry_cnt = TASK_RETRY_CNT;
+	ata_hscb->affiliation_policy = 0;
+
+	ata_hscb->ata_flags = 0;
+#ifdef SEQUENCER_UPDATE
+	ata_hscb->ata_flags |= UNTAGGED;
+#else
+#ifdef TAGGED_QUEUING
+	// RST - add support for SATA II queueing
+	ata_hscb->ata_flags |= LEGACY_QUEUING;
+#else
+	ata_hscb->ata_flags |= UNTAGGED;
+#endif
+#endif
+	return;
+}
+
+/*
+ * Function:
+ * 	asd_hwi_hash()
+ *
+ * Desctiption:
+ * 	Convert a 64-bit SAS address into a 24-bit Hash address.
+ * 	This is based on the hash implementation from the SAS 1.1 draft.
+ */
+void
+asd_hwi_hash(uint8_t *sas_addr, uint8_t *hashed_addr)
+{
+	const uint32_t 	distance_9_poly = 0x01DB2777;
+	uint32_t 	upperbits;
+	uint32_t 	lowerbits;
+	uint32_t 	msb;
+	uint32_t 	moving_one;
+	uint32_t 	leading_bit;
+	uint32_t 	regg;
+	int	 	i;
+
+	upperbits = scsi_4btoul(sas_addr);
+	lowerbits = scsi_4btoul(sas_addr + 4);
+	msb = 0x01000000;
+	regg = 0;
+	moving_one = 0x80000000;
+	for (i = 31; i >= 0; i--) {
+		leading_bit = 0;
+		if (moving_one & upperbits)
+			leading_bit = msb;
+		regg <<= 1;
+		regg ^= leading_bit;
+		if (regg & msb)
+			regg ^= distance_9_poly;
+		moving_one >>= 1;
+	}
+	moving_one = 0x80000000;
+	for (i = 31; i >= 0; i--) {
+		leading_bit = 0;
+		if (moving_one & lowerbits)
+			leading_bit = msb;
+		regg <<= 1;
+		regg ^= leading_bit;
+		if (regg & msb)
+			regg ^= distance_9_poly;
+
+		moving_one >>= 1;
+	}
+	scsi_ulto3b(regg, hashed_addr);
+}
+
+/*************************** Error Handling routines **************************/
+
+void
+asd_recover_cmds(struct asd_softc *asd)
+{
+	struct scb	*scb;
+	struct scb	*free_scb;
+	struct scb	*safe_scb;
+	u_long		 flags;
+		Scsi_Cmnd 		*cmd;
+		struct asd_device *dev;
+
+	if (list_empty(&asd->timedout_scbs)) {
+		asd_log(ASD_DBG_ERROR, "Timed-out scbs already completed.\n");
+		goto exit;
+	}
+	list_for_each_entry_safe(scb, safe_scb, &asd->timedout_scbs,
+				 timedout_links) {
+		asd_lock(asd, &flags);
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_ERROR, "asd_recover_cmds: Curr State: 0x%x Status: 0x%x.\n",
+		scb->eh_state, scb->eh_status);
+#endif
+
+
+		/* 
+		 * Error recovery is in progress for this scb.
+		 * Proceed to next one.
+		 */
+		if ((scb->eh_state & SCB_EH_IN_PROGRESS) != 0) {
+			asd_unlock(asd, &flags);
+			continue;
+		}
+		/*
+		 * Error recovery is completed for this scb.
+	         */
+		if (scb->eh_state == SCB_EH_DONE) {
+			asd_unlock(asd, &flags);
+			goto done;
+		}
+		/*
+		 * Only allowed one Error Recovery ongoing for a particular
+		 * target.
+		 */
+		if ((scb->platform_data->targ->flags &
+					ASD_TARG_IN_RECOVERY) != 0) {
+			asd_unlock(asd, &flags);
+			continue;
+		}
+		/* 
+		 * Acquire a free SCB from reserved pool to be used
+		 * for error recovery purpose.
+		 */
+		if ((free_scb = asd_hwi_get_scb(asd, 1)) == NULL) {
+			asd_log(ASD_DBG_ERROR, "Failed to get free SCB "
+				"for error recovery.\n");
+			asd_unlock(asd, &flags);
+			continue;
+		}
+		/* Mark this target to be in recovery mode. */
+		scb->platform_data->targ->flags |= ASD_TARG_IN_RECOVERY;
+
+		/* Freeze the target's queue. */
+		asd_freeze_targetq(asd, scb->platform_data->targ);
+
+		/* Initialiaze the state. */
+		scb->eh_state |= SCB_EH_IN_PROGRESS;
+		free_scb->eh_state = SCB_EH_INITIATED;
+		free_scb->eh_status = SCB_EH_SUCCEED;
+		switch (scb->eh_state & SCB_EH_LEVEL_MASK) {
+		case SCB_EH_ABORT_REQ:
+			asd_log(ASD_DBG_ERROR, "ABORT ER REQ.\n");
+			asd_hwi_abort_scb(asd, scb, free_scb);
+			break;
+
+		case SCB_EH_LU_RESET_REQ:
+			asd_log(ASD_DBG_ERROR, "LU RESET ER REQ.\n");
+			asd_hwi_reset_lu(asd, scb, free_scb);
+			break;
+		
+		case SCB_EH_DEV_RESET_REQ:
+			asd_log(ASD_DBG_ERROR, "DEV RESET ER REQ.\n");
+			asd_hwi_reset_device(asd, scb, free_scb);
+			break;
+			
+		case SCB_EH_PORT_RESET_REQ:
+			asd_log(ASD_DBG_ERROR, "PORT RESET ER REQ.\n");
+			asd_hwi_reset_port(asd, scb, free_scb);
+			break;
+		case SCB_EH_RESUME_SENDQ:
+			{
+		    struct asd_port		*port;
+			asd_log(ASD_DBG_ERROR, "RESUME SENDQ REQ.\n");
+			asd_unlock(asd, &flags);
+			port = SCB_GET_SRC_PORT(scb);
+
+			asd_delay(2000000);   //wait 2 sec for Broadcast event
+		    asd_lock(asd, &flags);
+
+			asd_hwi_resume_sendq(asd, scb, free_scb);
+			break;
+			}
+			
+		default:
+			asd_log(ASD_DBG_ERROR, "Unknown Error Recovery "
+				"Level scb 0x%x.\n",scb);
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			break;
+		}
+		asd_unlock(asd, &flags);
+
+done:
+		if (scb->eh_state == SCB_EH_DONE) {
+			/*
+			 * Error recovery is done for this scb,
+		         * Clean up and free the scb.
+			 */	 
+			asd_lock(asd, &flags);
+
+			list_del(&scb->timedout_links);
+			scb->platform_data->targ->flags &= 
+						~ASD_TARG_IN_RECOVERY;
+			/* Unfreeze the target's queue. */
+			asd_unfreeze_targetq(asd, scb->platform_data->targ);
+ 				scb->eh_status =SCB_EH_SUCCEED;
+ 			scb->eh_post(asd, scb);
+
+			if(scb->flags & SCB_ABORT_DONE)
+			{
+				scb->eh_status =SCB_EH_SUCCEED;
+			}
+			else
+			{
+				scb->eh_status =SCB_EH_FAILED;
+			}
+			if (scb->eh_status != SCB_EH_FAILED) {
+				struct asd_device *dev;
+				/* 
+				 * Schedule a timer to run the device
+				 * queue if the device is not frozen and
+				 * not in the process of being removed.
+				 */
+				dev = scb->platform_data->dev;
+				if ((dev != NULL) && (dev->qfrozen == 0) &&
+				    (dev->flags & ASD_DEV_TIMER_ACTIVE) == 0 &&
+				    (dev->target->flags &
+				     ASD_TARG_HOT_REMOVED) == 0) {
+
+
+					asd_setup_dev_timer(
+						dev, HZ,
+						asd_timed_run_dev_queue);
+				}
+				/*
+			 	 * Only free the scb if the error recovery is
+			 	 * successful.
+			 	 */
+
+
+
+				scb->flags &= ~(SCB_TIMEDOUT+SCB_ABORT_DONE);
+				asd_hwi_free_scb(asd, scb);
+			} // if (scb->eh_status != SCB_EH_FAILED) 
+//JDTEST
+			else
+			{
+				//cleaning up failed recovery scb 
+				asd_log(ASD_DBG_ERROR, "scb 0x%x SCB_EH_FAILED flags 0x%x\n",scb, scb->flags);
+				dev = scb->platform_data->dev;
+				if ((dev != NULL) && (dev->qfrozen == 0) &&
+				    (dev->flags & ASD_DEV_TIMER_ACTIVE) == 0 &&
+				    (dev->target->flags &
+				     ASD_TARG_HOT_REMOVED) == 0) {
+
+
+					asd_setup_dev_timer(
+						dev, HZ,
+						asd_timed_run_dev_queue);
+				}
+				if(scb->flags & SCB_PENDING)
+				{
+
+					list_del(&scb->hwi_links);
+				}
+
+
+				if(scb->flags & SCB_INTERNAL)
+				{
+					list_del(&scb->owner_links);
+					asd_hwi_free_scb(asd, scb);
+				}
+				else
+				{
+					asd_log(ASD_DBG_INFO,"free scb from pending queue\n");
+					list_del(&scb->owner_links);
+
+					cmd = &acmd_scsi_cmd(scb->io_ctx);
+					dev = scb->platform_data->dev;
+					dev->active--;
+					dev->openings++;
+					if ((scb->flags & SCB_DEV_QFRZN) != 0) {
+						scb->flags &= ~SCB_DEV_QFRZN;
+						dev->qfrozen--;
+					}
+
+					asd_unmap_scb(asd, scb);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+					asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+					asd_cmd_set_offline_status(cmd);
+#endif
+					cmd->scsi_done(cmd);
+					asd_hwi_free_scb(asd, scb);
+				} //if(scb->flags & SCB_INTERNAL)
+			} //if (scb->eh_status != SCB_EH_FAILED)
+			asd_unlock(asd, &flags);
+		} //if (scb->eh_state == SCB_EH_DONE)
+	}//list_for_each_entry_safe(scb, safe_scb, &asd->timedout_scbs,
+exit:
+	return;
+}
+
+static void
+asd_scb_eh_timeout(u_long arg)
+{
+	struct asd_softc 	*asd;
+	struct scb		*scb;
+	struct scb		*err_scb;
+	u_long		 	 flags;
+	
+	scb = (struct scb *) arg;
+	err_scb = (struct scb *) scb->post_stack[0].io_ctx;
+	asd = scb->softc;
+	asd_lock(asd, &flags);
+
+	scb->eh_state = SCB_EH_TIMEDOUT;
+	err_scb->eh_state &= ~SCB_EH_IN_PROGRESS;
+	/* 
+	 * Error recovery SCB timed out.
+	 * If this error recovery requested by the OS, we need to mark the
+	 * error recovery failed and make an attempt to perform the next
+	 * level error recovery if possible.
+	 */ 
+#ifdef ASD_DEBUG	
+//JD
+	asd_log(ASD_DBG_INFO, "asd_scb_eh_timeout: err_scb->eh_state 0x%x\n",err_scb->eh_state);
+#endif
+	switch (err_scb->eh_state) {
+	case SCB_EH_ABORT_REQ:
+		err_scb->eh_state = SCB_EH_LU_RESET_REQ;
+		break;
+		
+	case SCB_EH_LU_RESET_REQ:
+		err_scb->eh_state = SCB_EH_DEV_RESET_REQ;
+		break;
+
+	case SCB_EH_DEV_RESET_REQ:
+		err_scb->eh_state = SCB_EH_PORT_RESET_REQ;
+		break;
+
+	case SCB_EH_PORT_RESET_REQ:
+		{
+
+			// scb timeout during reset port
+			struct asd_port		*port;
+			struct asd_target	*targ;
+			port = SCB_GET_SRC_PORT(err_scb);
+			
+			/* Unfreeze all the targets. */
+			list_for_each_entry(targ, &port->targets, all_domain_targets) {
+				targ->qfrozen--;
+				asd_log(ASD_DBG_INFO,"clear freezen in timeout ptr=%p num=%d\n",targ,targ->qfrozen); 
+			}
+		}
+
+
+
+	default:
+		/* 
+		 * Currently, our biggest hammer now is PORT RESET.
+		 * We might perform ADAPTER RESET later on.
+		 */ 
+		err_scb->eh_state = SCB_EH_DONE;
+		break;
+	}
+
+	err_scb->eh_status = SCB_EH_FAILED;
+	err_scb->platform_data->targ->flags &= ~ASD_TARG_IN_RECOVERY;
+	asd_unlock(asd, &flags);
+	asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+}
+
+int
+asd_hwi_check_cmd_pending(struct asd_softc *asd, struct scb *scb, 
+		       	  struct asd_done_list *dl)
+{
+	struct scb *abort_scb;
+
+	while (!list_empty(&asd->timedout_scbs)) {
+		abort_scb = list_entry(asd->timedout_scbs.next, 
+				       struct scb, timedout_links);
+		if (((struct asd_abort_task_hscb *)
+		      &scb->hscb->abort_task)->tc_to_abort == 
+		      asd_htole16(SCB_GET_INDEX(abort_scb))) {
+			return (1);
+		}
+	}
+
+	return (0);
+}
+
+/*
+ * Function: 
+ *	asd_hwi_abort_scb()
+ *
+ * Description:
+ *	This routine will issue an ABORT_TASK to abort the requested scb.
+ *	ONLY SCB with protocol SSP, SMP and STP can be issued ABORT_TASK TMF.
+ */
+static void
+asd_hwi_abort_scb(struct asd_softc *asd, struct scb *scb_to_abort,
+		  struct scb *scb)
+{
+	ASD_LOCK_ASSERT(asd);
+
+	asd_log(ASD_DBG_ERROR, "Curr State: 0x%x Status: 0x%x.\n",
+		scb->eh_state, scb->eh_status);
+
+	/*
+	 * DC: We probably need to search the scb_to_abort in the 
+	 *     target/device queue as initial step for internal requested
+	 *     command.
+	 */ 
+	switch (scb->eh_state) {
+	case SCB_EH_INITIATED:
+	{
+		/* 
+		 * Validate the opcode of scb to be aborted. 
+		 * Only scb with specific opcode can be aborted.
+		 */
+		if ((SCB_GET_OPCODE(scb_to_abort) != SCB_INITIATE_SSP_TASK) &&
+	    	    (SCB_GET_OPCODE(scb_to_abort) != SCB_INITIATE_SMP_TASK) &&
+	    	    (SCB_GET_OPCODE(scb_to_abort) != 
+		     				SCB_INITIATE_LONG_SSP_TASK) &&
+	    	    (SCB_GET_OPCODE(scb_to_abort) != SCB_INITIATE_ATA_TASK) &&
+	    	    (SCB_GET_OPCODE(scb_to_abort) != SCB_INITIATE_ATAPI_TASK)) {
+			asd_log(ASD_DBG_ERROR, "Requested to abort unsupported "
+				"SCB request.\n");
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			/* 
+			 * Recursively call this function again upon changing
+		 	 * the state.
+			 */
+			asd_hwi_abort_scb(asd, scb_to_abort, scb);
+			break;
+		}
+
+		scb->platform_data->targ = scb_to_abort->platform_data->targ;
+		scb->platform_data->dev = scb_to_abort->platform_data->dev;
+		scb->eh_state = SCB_EH_ABORT_REQ;
+		asd_hwi_abort_scb(asd, (struct scb *) scb_to_abort, scb);
+		break;
+	}
+
+	case SCB_EH_ABORT_REQ:
+		/* Build the ABORT_TASK SCB. */
+		asd_hwi_build_abort_task(scb, scb_to_abort);
+
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+//JD
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "Prepare to abort scb index(TC): 0x%x, TAG(0x%x) cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x\n",
+			SCB_GET_INDEX(scb_to_abort), SCB_GET_SSP_TAG(scb_to_abort), 
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[2],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[3],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[4],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[5],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[7],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[8]);
+#endif
+		asd_push_post_stack(asd, scb, (void *) scb_to_abort,
+				    asd_hwi_abort_scb_done);
+		/* Post the ABORT_TASK SCB. */
+		asd_hwi_post_scb(asd, scb);
+		break;
+
+	case SCB_EH_CLR_NXS_REQ:
+		/* 
+		 * The Clear Nexus SCB has been prepared in the abort
+		 * post routine. All we need is to post it to the firmware.
+		 */
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_push_post_stack(asd, scb, (void *) scb_to_abort,
+				    asd_hwi_abort_scb_done);
+		asd_hwi_post_scb(asd, scb);
+		break;
+	
+	case SCB_EH_RESUME_SENDQ:
+		/*
+		 * We are here because the ABORT TMF failed.
+	         * We need to resume the data transmission of the task
+		 * that was going to be aborted.
+		 */	 
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_hwi_build_clear_nexus(scb, CLR_NXS_I_T_L_Q_TC,
+					  SCB_GET_INDEX(scb_to_abort),
+					  SCB_EH_RESUME_SENDQ);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_push_post_stack(asd, scb, (void *) scb_to_abort,
+				    asd_hwi_abort_scb_done);
+		asd_hwi_post_scb(asd, scb);
+		break;
+
+	case SCB_EH_DONE:
+		scb_to_abort->eh_state = scb->eh_state;
+		scb_to_abort->eh_status = scb->eh_status;
+
+		if ((scb_to_abort->eh_state == SCB_EH_DONE) && 
+		    (scb_to_abort->eh_status == SCB_EH_FAILED)) {
+			/*
+		 	 * Failed to perform abort error recovery for the
+		 	 * failed command, we shall procced with the next 
+			 * level of error recovery (Logical Unit Reset).
+			 * We need to change the scb eh_state to 
+			 * SCB_EH_LU_RESET_REQ. 
+		 	 */
+//JD
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "asd_hwi_abort_scb failed to perform scb index(TC): 0x%x, TAG(0x%x), cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x, going to reset all.\n",
+			SCB_GET_INDEX(scb_to_abort), SCB_GET_SSP_TAG(scb_to_abort), 
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[2],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[3],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[4],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[5],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[7],
+			scb_to_abort->io_ctx->scsi_cmd.cmnd[8]);
+
+#ifdef DEBUG_DDB
+		{
+			u_long	lseqs_to_dump;
+			u_int	lseq_id;
+			int		indx;
+
+			for(indx=0;indx< asd->ddb_bitmap_size; indx++)
+			{
+				lseq_id = 0;
+				lseqs_to_dump = asd->free_ddb_bitmap[indx];
+
+				while (lseqs_to_dump != 0) { 
+					for ( ; lseq_id < (8 * sizeof(u_long)); lseq_id++) {
+						if (lseqs_to_dump & (1UL << lseq_id)) {
+							lseqs_to_dump &= ~(1UL << lseq_id);
+							break;
+						} 
+					}
+		/* Dump out specific LSEQ Registers state. */
+					asd_hwi_dump_ssp_smp_ddb_site(asd, lseq_id + (indx * 8 * sizeof(ulong)));
+				}
+			}
+		}
+		asd_hwi_dump_seq_state(asd, asd->hw_profile.enabled_phys);
+#endif
+#endif
+			scb_to_abort->eh_state = SCB_EH_LU_RESET_REQ;
+			scb_to_abort->platform_data->targ->flags &= 
+							~ASD_TARG_IN_RECOVERY;
+		}
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+
+	default:
+		asd_log(ASD_DBG_ERROR, "Invalid EH State 0x%x.\n",
+			scb->eh_state);
+
+		scb_to_abort->eh_state = SCB_EH_DONE;
+		scb_to_abort->eh_status = SCB_EH_FAILED;
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+	}
+}
+
+static void
+asd_hwi_abort_scb_done(struct asd_softc *asd, struct scb *scb, 
+		       struct asd_done_list *dl)
+{
+	struct scb		*scb_to_abort;
+//JD
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "asd_hwi_abort_scb_done: scb index(TC): 0x%x, TAG(0x%x), cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x is done\n",
+			SCB_GET_INDEX(scb), SCB_GET_SSP_TAG(scb), 
+			scb->io_ctx->scsi_cmd.cmnd[2],
+			scb->io_ctx->scsi_cmd.cmnd[3],
+			scb->io_ctx->scsi_cmd.cmnd[4],
+			scb->io_ctx->scsi_cmd.cmnd[5],
+			scb->io_ctx->scsi_cmd.cmnd[7],
+			scb->io_ctx->scsi_cmd.cmnd[8]);
+	asd_log(ASD_DBG_INFO, "asd_hwi_abort_scb_done: scb ptr=%p scb_abort ptr=%p\n",scb,scb->io_ctx);
+#endif
+
+	/*
+       	 * There is a possibility that this post routine is called after
+	 * the SCB timedout. So, only delete the timer if the SCB hasn't
+	 * timedout.
+	 */
+	if (scb->eh_state != SCB_EH_TIMEDOUT)
+		del_timer_sync(&scb->platform_data->timeout);
+
+	/*
+	 * This post routine is shared by ABORT_TASK and CLEAR_NEXUS
+         * issued by this abort handler code.
+ 	 * Hence, the DL opcodes also apply to both SCB task.
+	 */	 
+	switch (dl->opcode) {
+	case TASK_COMP_WO_ERR:
+	case TMF_F_W_TAG_NOT_FOUND:
+	case TMF_F_W_CONN_HNDL_NOT_FOUND:
+	case TMF_F_W_TASK_ALREADY_DONE:
+	case TMF_F_W_TAG_ALREADY_FREE:
+	case TMF_F_W_TC_NOT_FOUND:
+		/*
+		 * For SMP or STP target, firmware will only try to abort
+		 * the task if it is still in its execution queue.
+		 * If the task to be aborted couldn't be found, mostly like it
+		 * has been issued to the target.
+		 * We should try next level error recovery.
+		 */
+
+		scb_to_abort=(struct scb *)scb->io_ctx;
+		asd_log(ASD_DBG_INFO, "protocol type=%x flags=%x \n",
+			  scb->platform_data->targ->device_protocol_type,scb_to_abort->flags);
+		if (scb->platform_data->targ->device_protocol_type
+					!= ASD_DEVICE_PROTOCOL_SCSI) {
+			if(!(scb_to_abort->flags & SCB_ABORT_DONE))
+			{
+				scb->eh_state = SCB_EH_DONE;
+				scb->eh_status = SCB_EH_FAILED;
+				break;
+			}
+		}
+
+		/* Fall thru */
+	case TASK_ABORTED_BY_ITNL_EXP:
+		/* Indicate that Abort succeeded. */
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_SUCCEED;
+		break;
+
+	case TASK_F_W_NAK_RCVD:
+		/* 
+		 * Indicate that Abort failed.
+		 * If this is a failure in issuing ABORT TMF, we need to 
+		 * resume the data transmission of the task that was
+		 * going to be aborted.
+		 */
+		if ((scb->eh_state & SCB_EH_SUSPEND_SENDQ) != 0)
+			scb->eh_state = SCB_EH_RESUME_SENDQ;
+		else
+			scb->eh_state = SCB_EH_DONE;
+		
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+
+	case SSP_TASK_COMP_W_RESP:
+	{
+		union edb 		*edb;
+		struct scb 		*escb;
+		struct ssp_resp_edb  	*redb;
+		struct ssp_resp_iu	*riu;
+		u_int			 edb_index;
+		
+		edb = asd_hwi_get_edb_from_dl(asd, scb, dl, &escb, &edb_index);
+		if (edb == NULL) {
+			asd_log(ASD_DBG_ERROR, "Invalid EDB recv for SSP "
+				"comp w/response.\n");
+			scb->eh_state = SCB_EH_RESUME_SENDQ;
+			scb->eh_status = SCB_EH_SUCCEED;
+			break;
+		}
+
+		/*
+		 * Search if the aborted command still pending on the firmware
+	         * queue. If so, we need to send CLEAR_NEXUS to have the 
+		 * command freed and returned to us.
+		 */	 
+		if (!asd_hwi_check_cmd_pending(asd, scb, dl)) {
+			asd_log(ASD_DBG_RUNTIME, "Aborted cmd has been "
+				"completed.\n");
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_SUCCEED;
+			asd_hwi_free_edb(asd, escb, edb_index);
+			break;
+		}
+
+		redb = &edb->ssp_resp;
+		riu = &redb->resp_frame.riu;
+		if (SSP_RIU_DATAPRES(riu) == SSP_RIU_DATAPRES_RESP) {
+			uint8_t	resp_code;
+
+			resp_code = ((struct resp_data_iu *)
+						&riu->data[0])->resp_code;
+
+			/* Handle the SSP TMF response code. */
+			asd_hwi_map_tmf_resp(scb, resp_code);
+			
+			if (scb->eh_state == SCB_EH_CLR_NXS_REQ) {
+				asd_log(ASD_DBG_ERROR,
+					"Tag to Clear=0x%x.\n",
+					asd_be16toh(redb->tag_to_clear));
+				/* 
+				 * Upon receving TMF_COMPLETE, we need to send
+				 * CLEAR_NEXUS SCB for tag_to_clear.
+				 */
+				asd_hwi_build_clear_nexus(scb, 
+							  CLR_NXS_I_T_L_Q_TAG,
+							  redb->tag_to_clear,
+							  /*ctx*/0);
+			}
+		} else {
+			/* 
+			 * Response Data not available. Protocol error.
+			 * Indicate that Abort failed. 
+			 */
+			scb->eh_state = SCB_EH_RESUME_SENDQ;
+			scb->eh_status = SCB_EH_FAILED;
+		}
+		
+		asd_hwi_free_edb(asd, escb, edb_index);
+		break;
+	}
+
+	case TASK_F_W_OPEN_REJECT:
+		scb->eh_state = SCB_EH_RESUME_SENDQ;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+
+	case RESUME_COMPLETE:
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+
+	case TASK_CLEARED:
+		/* 
+	 	 * Previous error recovery SCB that timed-out and
+	 	 * was aborted.
+	 	 * All we need to do here is just free the scb.
+	 	 */ 
+		asd_hwi_free_scb(asd, scb);
+		return;
+
+	default:
+		asd_log(ASD_DBG_ERROR, "DL opcode not handled.\n");
+		scb->eh_state = SCB_EH_RESUME_SENDQ;
+		scb->eh_status = SCB_EH_FAILED;
+		break;		
+	}
+
+	asd_hwi_abort_scb(asd, (struct scb *) scb->io_ctx, scb);
+}
+
+/*
+ * Function:
+ *	asd_hwi_reset_lu()
+ *	
+ * Description:
+ *	Issue a Logical Unit Reset to the end device.
+ *	LU Reset can only be done for SSP end device.
+ */
+static void
+asd_hwi_reset_lu(struct asd_softc *asd, struct scb *scb_to_reset,
+		 struct scb *scb)
+{
+	ASD_LOCK_ASSERT(asd);
+
+	asd_log(ASD_DBG_ERROR, "Curr State: 0x%x Status: 0x%x.\n",
+		scb->eh_state, scb->eh_status);
+
+	switch (scb->eh_state) {
+	case SCB_EH_INITIATED:
+	{
+		struct asd_target	*targ;
+		struct asd_device	*dev;
+		
+		targ = scb_to_reset->platform_data->targ;
+		dev = scb_to_reset->platform_data->dev;
+		if ((targ == NULL) || (dev == NULL)) {
+			/* This shouldn't happen. */
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			asd_hwi_reset_lu(asd, scb_to_reset, scb);
+			break;
+		}
+
+		/*
+   		 * Only SSP end device can be issued a LU reset.
+		 */
+		if (targ->device_protocol_type != ASD_DEVICE_PROTOCOL_SCSI) {
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			asd_hwi_reset_lu(asd, (struct scb *) scb_to_reset, scb);
+			break;
+		}
+
+		scb->platform_data->targ = targ;
+		scb->platform_data->dev = dev;
+		scb->eh_state = SCB_EH_LU_RESET_REQ;
+		asd_hwi_reset_lu(asd, (struct scb *) scb_to_reset, scb);	
+		break;
+	}
+
+	case SCB_EH_LU_RESET_REQ:
+		/* Build LUR Task Management Function. */
+		asd_hwi_build_ssp_tmf(scb, scb->platform_data->targ,
+				      scb->platform_data->dev->saslun,	
+				      LOGICAL_UNIT_RESET_TMF);
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+				    asd_hwi_reset_lu_done);
+		asd_hwi_post_scb(asd, scb);
+		break;
+
+	case SCB_EH_CLR_NXS_REQ:
+		asd_hwi_build_clear_nexus(scb, CLR_NXS_I_T_L,
+					  (RESUME_TX | NOT_IN_Q | SEND_Q),
+					  /*ctx*/0);
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+				    asd_hwi_reset_lu_done);
+		asd_hwi_post_scb(asd, scb);
+		break;
+
+	case SCB_EH_RESUME_SENDQ:
+		/*
+		 * If we failed to perform LU Reset, we need to resume
+		 * the firmware send queue for the I_T_L.
+		 */
+		asd_hwi_build_clear_nexus(scb, CLR_NXS_I_T_L,
+					  RESUME_TX, /*ctx*/0);
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+				    asd_hwi_reset_lu_done);
+		asd_hwi_post_scb(asd, scb);
+		break;
+
+	case SCB_EH_DONE:
+	{
+		scb_to_reset->eh_state = scb->eh_state;
+		scb_to_reset->eh_status = scb->eh_status;
+
+		if ((scb_to_reset->eh_state == SCB_EH_DONE) &&
+		    (scb_to_reset->eh_status == SCB_EH_FAILED)) {
+			/*
+		 	 * Failed to perform LU Reset or LU Reset is not
+		 	 * supported then we shall procced with 
+			 * the next level of error recovery (Device Port Reset).
+			 * We need to change the scb eh_state to 
+			 * SCB_EH_DEV_RESET_REQ.
+		 	 */
+			scb_to_reset->eh_state = SCB_EH_DEV_RESET_REQ;
+			scb_to_reset->platform_data->targ->flags &= 
+							~ASD_TARG_IN_RECOVERY;
+		}
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+	}
+
+	default:
+		asd_log(ASD_DBG_ERROR, "Invalid EH State 0x%x.\n",
+			scb->eh_state);
+		scb_to_reset->eh_state = SCB_EH_DONE;
+		scb_to_reset->eh_status = SCB_EH_FAILED;
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+	}
+}
+
+static void
+asd_hwi_reset_lu_done(struct asd_softc *asd, struct scb *scb,
+		     struct asd_done_list *dl)
+{
+	asd_log(ASD_DBG_ERROR, "DL Opcode = 0x%x.\n", dl->opcode);
+
+	/*
+       	 * There is a possibility that this post routine is called after
+	 * the SCB timedout. So, only delete the timer if the SCB hasn't
+	 * timedout.
+	 */
+	if (scb->eh_state != SCB_EH_TIMEDOUT)
+		del_timer_sync(&scb->platform_data->timeout);
+
+	switch (dl->opcode) {
+	case TASK_COMP_WO_ERR:
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_SUCCEED;
+		break;
+
+	case TMF_F_W_TC_NOT_FOUND:
+	case TMF_F_W_TAG_NOT_FOUND:
+	case TMF_F_W_CONN_HNDL_NOT_FOUND:
+	case TASK_F_W_NAK_RCVD:
+		if ((scb->eh_state & SCB_EH_SUSPEND_SENDQ) != 0)
+			scb->eh_state = SCB_EH_RESUME_SENDQ;
+		else
+			scb->eh_state = SCB_EH_DONE;
+		
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+
+	case SSP_TASK_COMP_W_RESP:
+	{	
+		union edb 		*edb;
+		struct scb 		*escb;
+		struct ssp_resp_edb  	*redb;
+		struct ssp_resp_iu	*riu;
+		u_int			 edb_index;
+
+		edb = asd_hwi_get_edb_from_dl(asd, scb, dl, &escb, &edb_index);
+		if (edb == NULL) {
+			asd_log(ASD_DBG_ERROR, "Invalid EDB recv for SSP "
+				"comp w/response.\n");
+			scb->eh_state = SCB_EH_RESUME_SENDQ;
+			scb->eh_status = SCB_EH_FAILED;
+			break;
+		}
+		
+		redb = &edb->ssp_resp;
+		riu = &redb->resp_frame.riu;
+		if (SSP_RIU_DATAPRES(riu) == SSP_RIU_DATAPRES_RESP) {
+			uint8_t	resp_code;
+
+			resp_code = ((struct resp_data_iu *)
+						&riu->data[0])->resp_code;
+
+			/* Handle the SSP TMF response code. */
+			asd_hwi_map_tmf_resp(scb, resp_code);
+		} else {
+			/* 
+			 * Response Data not available. Protocol error.
+			 * Indicate that LUR failed.
+			 */
+			scb->eh_state = SCB_EH_RESUME_SENDQ;
+			scb->eh_status = SCB_EH_FAILED;
+		}
+
+		asd_hwi_free_edb(asd, escb, edb_index);
+		break;
+	}
+
+	case TASK_F_W_OPEN_REJECT:
+		scb->eh_state = SCB_EH_RESUME_SENDQ;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+
+	case RESUME_COMPLETE:
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+
+	case TASK_CLEARED:
+		/* 
+		 * Previous error recovery SCB that timed-out and
+		 * was aborted.
+		 * All we need to do here is just free the scb.
+		 */ 
+		asd_hwi_free_scb(asd, scb);
+		return;
+	
+	default:
+		asd_log(ASD_DBG_ERROR, "DL Opcode not handled.\n");
+		scb->eh_state = SCB_EH_RESUME_SENDQ;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+	}
+
+	asd_hwi_reset_lu(asd, (struct scb *) scb->io_ctx, scb);
+}
+
+void
+asd_hwi_map_tmf_resp(struct scb *scb, u_int resp_code)
+{
+	/* 
+	 * Handle TMF Response upon completion of issuing 
+	 * Task Management Function to the target..
+	 * Based on the response code, we will move to certain
+	 * error recovery state.
+	 */
+	switch (resp_code) {
+	case TMF_COMPLETE:
+		scb->eh_state = SCB_EH_CLR_NXS_REQ;
+		scb->eh_status = SCB_EH_SUCCEED;
+		break;
+
+	case INVALID_FRAME:
+	case TMF_FAILED:
+	case TMF_SUCCEEDED:
+	case TMF_NOT_SUPPORTED:
+	case INVALID_LUN:
+	default:
+		/* We treat all this as a failure case. */
+		scb->eh_state = SCB_EH_RESUME_SENDQ;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+	}
+}
+
+/*
+ * Function:
+ *	asd_hwi_reset_device()
+ *	
+ * Description:
+ *	Issue a device reset to the failing device.
+ */
+static void
+asd_hwi_reset_device(struct asd_softc *asd, struct scb *scb_to_reset,
+		     struct scb *scb)
+{
+	ASD_LOCK_ASSERT(asd);
+
+	asd_log(ASD_DBG_ERROR, "Curr State: 0x%x Status: 0x%x.\n",
+		scb->eh_state, scb->eh_status);
+	asd_log(ASD_DBG_ERROR, "scb_to_reset = %p \n",scb_to_reset);
+
+	switch (scb->eh_state) {
+	case SCB_EH_INITIATED:
+	{
+		struct asd_target	*targ;
+		struct asd_device	*dev;
+
+		targ = scb_to_reset->platform_data->targ;
+		dev = scb_to_reset->platform_data->dev;
+		if ((targ == NULL) || (dev == NULL)) {
+			/* This shouldn't happen. */
+
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			asd_hwi_reset_device(asd, scb_to_reset, scb);
+			break;
+		}
+
+		/*
+	 	 * DC: Currently we are not handling error recovery for
+		 *     expander.
+		 *     Logic for that will be added later on.
+         	 */ 
+		if ((targ->device_protocol_type != ASD_DEVICE_PROTOCOL_SCSI) &&
+		    (targ->device_protocol_type != ASD_DEVICE_PROTOCOL_ATA)) {
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			asd_hwi_reset_device(asd, scb_to_reset, scb);
+			break;
+		}
+		
+		scb->platform_data->targ = targ;
+		scb->platform_data->dev = dev;
+
+		/* 
+		 * Saving final post routine and the scb_to_reset in
+		 * the first post stack slot. We need to access the
+		 * scb_to_reset during the device reset process.
+		 */
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+			    asd_hwi_reset_device_done);
+		
+		if (SCB_GET_SRC_PORT(scb_to_reset)->management_type == 
+							ASD_DEVICE_END) {
+			/* We or'ed it to remember its previous state. */
+
+				scb->eh_state  = SCB_EH_CLR_NXS_REQ;
+		} else {
+			/*
+			 * For device attached behind expander,
+		         * prior to device reset, we will try to
+			 * obtain the error report log of the phy
+			 * that the device is connected to.
+			 */
+			scb->eh_state = SCB_EH_PHY_REPORT_REQ;
+		}
+		asd_hwi_reset_device(asd, scb_to_reset, scb);	
+		break;
+	}
+
+	case SCB_EH_DEV_RESET_REQ:
+	{
+		struct asd_target	*targ;
+		struct asd_port		*port;
+
+		targ = scb->platform_data->targ;
+		port = SCB_GET_SRC_PORT(scb);
+		/*
+	 	 * Perform a specific device reset for device that is 
+		 * direct-attached or expander-attached.
+	 	 */
+		if (port->management_type == ASD_DEVICE_END) {
+			/* Device is directly attached to the initiator. */
+			asd_hwi_reset_end_device(asd, scb);
+		} else {
+			/* Device is attached behind expander. */
+			asd_hwi_reset_exp_device(asd, scb);
+		}
+	    	break;
+	}
+
+	case SCB_EH_PHY_NO_OP_REQ:
+	{
+		struct asd_phy	*phy;
+
+		phy = (struct asd_phy *) scb->io_ctx;
+		/*
+		 * Upon completion of HARD RESET, we need to initialize
+		 * OOB registers to enable hot-plug timer.
+		 * PHY NO OP currently only applied for direct-attached
+		 * device.
+		 */
+		asd_hwi_build_control_phy(scb, phy, PHY_NO_OP);
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_push_post_stack(asd, scb, scb->io_ctx,
+				    asd_hwi_reset_end_device_done);
+		asd_hwi_post_scb(asd, scb);
+		break;
+	}
+
+	case SCB_EH_PHY_REPORT_REQ:
+		/*
+		 * Obtain the report error log of the phy that the failing
+		 * device is connected to.
+		 * Ideally, we want to traverse the route and obtain the
+		 * error report log of each phy that has pathway to the
+		 * device.
+		 */
+		asd_hwi_report_phy_err_log(asd, scb);
+		break;
+
+	case SCB_EH_CLR_NXS_REQ:
+		/*
+	 	 * Prior to performing Link Reset or Hard Reset to the 
+		 * target, we need to clear the firmware's execution queue
+		 * and suspend the data transimission to the target.
+	 	 */
+		asd_hwi_build_clear_nexus(scb, CLR_NXS_IT_OR_TI,
+					 (SUSPEND_TX | EXEC_Q),
+					  /*ctx*/0);
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+					asd_hwi_reset_device_done);
+
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_hwi_post_scb(asd, scb);
+		break;
+		case SCB_EH_RESUME_SENDQ:
+		scb_to_reset->eh_state = SCB_EH_RESUME_SENDQ;
+		scb_to_reset->eh_status =SCB_EH_SUCCEED;
+		scb_to_reset->platform_data->targ->flags &= 
+							~ASD_TARG_IN_RECOVERY;
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+
+	case SCB_EH_DONE:
+		scb_to_reset->eh_state = scb->eh_state;
+		scb_to_reset->eh_status = scb->eh_status;
+		if(!(scb_to_reset->flags & SCB_ABORT_DONE))
+		{
+			// scb not retutn from sequencer then set status to fail state
+			scb_to_reset->eh_status = SCB_EH_FAILED;
+		}
+
+		if ((scb_to_reset->eh_state == SCB_EH_DONE) &&
+		    (scb_to_reset->eh_status == SCB_EH_FAILED)) {
+			/*
+		 	 * Failed to perform DEVICE RESET,
+			 * we shall procced with the next level of 
+			 * error recovery (Port Reset).
+			 * We need to change the scb eh_state to 
+			 * SCB_EH_PORT_RESET_REQ.
+		 	 */
+			scb_to_reset->eh_state = SCB_EH_PORT_RESET_REQ;
+			scb_to_reset->platform_data->targ->flags &= 
+							~ASD_TARG_IN_RECOVERY;
+		}
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+
+	default:
+		asd_log(ASD_DBG_ERROR, "Invalid EH State 0x%x.\n",
+			scb->eh_state);
+
+		scb_to_reset->eh_state = SCB_EH_DONE;
+		scb_to_reset->eh_status = SCB_EH_FAILED;
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+	}
+}
+
+/*
+ * Function:
+ *	asd_hwi_reset_device()
+ *	
+ * Description:
+ *	Issue a device reset to the failing device.
+ */
+static void
+asd_hwi_resume_sendq(struct asd_softc *asd, struct scb *scb_to_reset,
+		     struct scb *scb)
+{
+	ASD_LOCK_ASSERT(asd);
+
+	asd_log(ASD_DBG_ERROR, "Curr State: 0x%x Status: 0x%x.\n",
+		scb->eh_state, scb->eh_status);
+	asd_log(ASD_DBG_ERROR, "scb_to_reset = %p \n",scb_to_reset);
+
+	switch (scb->eh_state) {
+	case SCB_EH_INITIATED:
+	{
+		struct asd_target	*targ;
+		struct asd_device	*dev;
+
+		targ = scb_to_reset->platform_data->targ;
+		dev = scb_to_reset->platform_data->dev;
+		if ((targ == NULL) || (dev == NULL)) {
+			/* This shouldn't happen. */
+
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			asd_hwi_resume_sendq(asd, scb_to_reset, scb);
+			break;
+		}
+
+		/*
+	 	 * DC: Currently we are not handling error recovery for
+		 *     expander.
+		 *     Logic for that will be added later on.
+         	 */ 
+		if ((targ->device_protocol_type != ASD_DEVICE_PROTOCOL_SCSI) &&
+		    (targ->device_protocol_type != ASD_DEVICE_PROTOCOL_ATA)) {
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			asd_hwi_resume_sendq(asd, scb_to_reset, scb);
+			break;
+		}
+		
+		scb->platform_data->targ = targ;
+		scb->platform_data->dev = dev;
+
+		/* 
+		 * Saving final post routine and the scb_to_reset in
+		 * the first post stack slot. We need to access the
+		 * scb_to_reset during the device reset process.
+		 */
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+			    asd_hwi_reset_device_done);
+		
+		scb->eh_state = SCB_EH_RESUME_SENDQ;
+		asd_hwi_resume_sendq(asd, scb_to_reset, scb);	
+		break;
+	}
+
+		case SCB_EH_RESUME_SENDQ:
+	{
+
+	
+		/* 
+		 * Upon completion of Device Reset, we need to issue
+		 * CLEAR NEXUS to the firmware to free up the SCB
+		     * resume data transmission.
+		 * Also, we will be using the first post stack
+		 * we save at the beginning.
+		 */
+		asd_hwi_build_clear_nexus(scb, CLR_NXS_IT_OR_TI,
+					 (RESUME_TX|SEND_Q|NOT_IN_Q),
+					  /*ctx*/0);
+
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+					asd_hwi_resume_sendq_done);
+
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_hwi_post_scb(asd, scb);
+		break;
+	}
+	
+	case SCB_EH_DONE:
+		scb_to_reset->eh_state = scb->eh_state;
+		scb_to_reset->eh_status = scb->eh_status;
+
+
+		if ((scb_to_reset->eh_state == SCB_EH_DONE) &&
+		    (scb_to_reset->eh_status == SCB_EH_FAILED)) {
+			/*
+		 	 * Failed to perform DEVICE RESET,
+			 * we shall procced with the next level of 
+			 * error recovery (Port Reset).
+			 * We need to change the scb eh_state to 
+			 * SCB_EH_PORT_RESET_REQ.
+		 	 */
+			scb_to_reset->eh_state = SCB_EH_PORT_RESET_REQ;
+			scb_to_reset->platform_data->targ->flags &= 
+						~ASD_TARG_IN_RECOVERY;
+		}
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+
+	default:
+		asd_log(ASD_DBG_ERROR, "Invalid EH State 0x%x.\n",
+			scb->eh_state);
+
+		scb_to_reset->eh_state = SCB_EH_DONE;
+		scb_to_reset->eh_status = SCB_EH_FAILED;
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+	}
+}
+static void
+asd_hwi_resume_sendq_done(struct asd_softc *asd, struct scb *scb,
+			  struct asd_done_list *dl)
+{
+	asd_log(ASD_DBG_ERROR, "DL Opcode = 0x%x.\n", dl->opcode);
+
+	/*
+       	 * There is a possibility that this post routine is called after
+	 * the SCB timedout. So, only delete the timer if the SCB hasn't
+	 * timedout.
+	 */
+	if (scb->eh_state != SCB_EH_TIMEDOUT)
+		del_timer_sync(&scb->platform_data->timeout);
+
+	switch (dl->opcode) {
+	case TASK_COMP_WO_ERR:
+	{	
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_SUCCEED;
+		break;
+	}
+
+	case TMF_F_W_TC_NOT_FOUND:
+	case TMF_F_W_TAG_NOT_FOUND:
+	case TMF_F_W_CONN_HNDL_NOT_FOUND:
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+
+	case TASK_CLEARED:
+		/* 
+		 * Previous error recovery SCB that timed-out and
+		 * was aborted.
+		 * All we need to do here is just free the scb.
+		 */ 
+		asd_log(ASD_DBG_ERROR, "task clear free scb=%p \n", scb);
+		asd_hwi_free_scb(asd, scb);
+		return;
+
+	default:
+		asd_log(ASD_DBG_ERROR, "Unhandled DL opcode.\n");
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+	}
+
+	asd_hwi_resume_sendq(asd, (struct scb *) scb->io_ctx, scb);
+}
+static void
+asd_hwi_reset_device_done(struct asd_softc *asd, struct scb *scb,
+			  struct asd_done_list *dl)
+{
+	asd_log(ASD_DBG_ERROR, "DL Opcode = 0x%x.\n", dl->opcode);
+
+	/*
+       	 * There is a possibility that this post routine is called after
+	 * the SCB timedout. So, only delete the timer if the SCB hasn't
+	 * timedout.
+	 */
+	if (scb->eh_state != SCB_EH_TIMEDOUT)
+		del_timer_sync(&scb->platform_data->timeout);
+
+	switch (dl->opcode) {
+	case TASK_COMP_WO_ERR:
+	{	
+			if(scb->eh_state==SCB_EH_CLR_NXS_REQ)
+			{
+			struct asd_port	*port;
+		
+			port = SCB_GET_SRC_PORT(scb);
+			if (port->management_type == ASD_DEVICE_END) {
+				/*
+		 	 	 * For direct-attached SSP target, we need to
+				 * check if it is attached on a wide port. 
+				 * If so, we need to issue a HARD RESET on 
+				 * one of the phys and LINK RESET on the 
+				 * remaining phys.
+			 	 * For direct-attached SATA/SATAPI target,
+				 * LINK RESET can be done for all the phys
+				 * belong to the port.
+				 * Get which phy(s) that need to be reset.
+		 	 	 */
+				port->reset_mask = port->conn_mask;
+			}
+			scb->eh_state = SCB_EH_DEV_RESET_REQ;
+		} else {
+			scb->eh_state = SCB_EH_DONE;
+		}
+		scb->eh_status = SCB_EH_SUCCEED;
+		break;
+	}
+
+	case TMF_F_W_TC_NOT_FOUND:
+	case TMF_F_W_TAG_NOT_FOUND:
+	case TMF_F_W_CONN_HNDL_NOT_FOUND:
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+
+	case TASK_CLEARED:
+		/* 
+		 * Previous error recovery SCB that timed-out and
+		 * was aborted.
+		 * All we need to do here is just free the scb.
+		 */ 
+		asd_log(ASD_DBG_ERROR, "task clear free scb=%p \n", scb);
+		asd_hwi_free_scb(asd, scb);
+		return;
+
+	default:
+		asd_log(ASD_DBG_ERROR, "Unhandled DL opcode.\n");
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+	}
+
+	asd_hwi_reset_device(asd, (struct scb *) scb->io_ctx, scb);
+}
+
+/*
+ * Function:
+ *	asd_hwi_reset_end_device()
+ *	
+ * Description:
+ *	For direct-attached SATA/SATAPI target, device reset is achieved by 
+ *	issuing a Link Reset sequence (OOB).
+ *	For direct-attached SSP target, device reset is achieved by issuing
+ *	a Hard Reset.
+ */
+static void
+asd_hwi_reset_end_device(struct asd_softc *asd, struct scb *scb)
+{
+	struct asd_target	*targ;
+	struct asd_port		*port;
+	struct asd_phy		*phy;
+	int			 found;
+
+	targ = scb->platform_data->targ;
+	port = SCB_GET_SRC_PORT(scb);
+	found = 0;
+	/*
+	 * Find the associated phy that need to be reset.
+	 */
+	list_for_each_entry(phy, &port->phys_attached, links) {
+		if ((port->reset_mask & (1 << phy->id)) != 0) {
+			found = 1;
+			break;
+		}
+	}
+	if (found != 1) {
+		/* This shouldn't happen. */
+		asd_log(ASD_DBG_ERROR,"No PHY to reset, PR Mask: 0x%x "
+			"PC Mask: 0x%x.\n", port->reset_mask, port->conn_mask);
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		asd_hwi_reset_device(asd,
+				    (struct scb *) scb->post_stack[0].io_ctx,
+				     scb);
+		return;
+	}
+
+	if (targ->transport_type == ASD_TRANSPORT_SSP) {
+		/* 
+	 	 * For SSP wide port target, we need to perform a
+	 	 * HARD RESET only on one of the phys and LINK RESET
+		 * on the remaining phys.
+	 	 */
+		asd_hwi_build_control_phy(scb, phy,
+					 ((port->reset_mask == port->conn_mask)
+					  ? EXECUTE_HARD_RESET : ENABLE_PHY));
+	} else {
+		/* 
+	 	 * For SATA direct-attached end device, 
+	 	 * device port reset is done by re-Enabling the phy
+	 	 * and hence initiating OOB sequence.
+	 	 */
+		asd_hwi_build_control_phy(scb, phy, ENABLE_PHY); 	
+	}
+		
+	port->reset_mask &= ~(1 << phy->id);
+	scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+	asd_setup_scb_timer(scb, (8 * HZ), asd_scb_eh_timeout);
+	asd_push_post_stack(asd, scb, (void *) phy,
+			    asd_hwi_reset_end_device_done);
+	asd_hwi_post_scb(asd, scb);
+}
+
+static void
+asd_hwi_reset_end_device_done(struct asd_softc *asd, struct scb *scb, 
+			      struct asd_done_list *dl)
+{
+	asd_log(ASD_DBG_ERROR, "DL Opcode = 0x%x.\n", dl->opcode);
+
+	/*
+       	 * There is a possibility that this post routine is called after
+	 * the SCB timedout. So, only delete the timer if the SCB hasn't
+	 * timedout.
+	 */
+	if (scb->eh_state != SCB_EH_TIMEDOUT)
+		del_timer_sync(&scb->platform_data->timeout);
+
+	if (scb->eh_status == SCB_EH_SUCCEED) {
+		if (scb->eh_state != SCB_EH_PHY_NO_OP_REQ) {
+			/* Check if any remaining phys need to be reset. */
+			scb->eh_state =
+				((SCB_GET_SRC_PORT(scb)->reset_mask == 0) ?
+				  SCB_EH_CLR_NXS_REQ : SCB_EH_DEV_RESET_REQ);
+		}
+	} else {
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+	}
+		
+	asd_hwi_reset_device(asd, (struct scb *) scb->post_stack[0].io_ctx,
+			     scb);
+}
+
+void dumpsmp(uint8_t	*smp_req)
+{
+	uint32_t index;
+	if(smp_req==NULL) return;
+
+	asd_print("\nsmp_req: 0x%x", *smp_req );
+
+	for( index = 0; index < sizeof(struct SMPRequest); index++)
+	{
+		if(!(index % 16))
+		{
+			asd_print("   \n");
+		}
+
+		asd_print("%02x ", smp_req[index] );
+	}
+}
+
+static void
+asd_hwi_report_phy_err_log(struct asd_softc *asd, struct scb *scb)
+{
+	struct asd_port		*port;
+	struct asd_target	*exp_targ;
+	struct asd_target	*targ;
+	struct Discover		*disc;
+	int			 phy_id;
+
+	targ = scb->platform_data->targ;
+	/* Expander that the target is attached to. */
+	exp_targ = targ->parent;
+	port = SCB_GET_SRC_PORT(scb);
+
+	if (exp_targ == NULL) {
+		/* This shouldn't happen. */
+		asd_log(ASD_DBG_ERROR, "Parent Expander shouldn't be NULL.\n");
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		asd_hwi_reset_device(asd,
+				    (struct scb *) scb->post_stack[0].io_ctx,
+				     scb);
+		return;
+	}
+	/*
+	 * Find the expander phy id that the target is attached to. 
+	 */
+	for (phy_id = 0; phy_id < exp_targ->num_phys; phy_id++) {
+		disc = &(exp_targ->Phy[phy_id].Result);
+
+		if (SAS_ISEQUAL(targ->ddb_profile.sas_addr,
+				disc->AttachedSASAddress))
+			break;
+	}
+
+	if (phy_id == exp_targ->num_phys) {
+		/* This shouldn't happen. */
+		asd_log(ASD_DBG_ERROR, "Corrupted target, inv. phy id.\n");
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		asd_hwi_reset_device(asd,
+				    (struct scb *) scb->post_stack[0].io_ctx,
+				     scb);
+		return;
+	}
+
+	/* Build a REPORT PHY ERROR LOG SMP request. */
+	asd_hwi_build_smp_phy_req(port, REPORT_PHY_ERROR_LOG, phy_id, 0);
+
+	/* Build a SMP TASK. */
+	asd_hwi_build_smp_task(scb, exp_targ,
+			       port->dc.SMPRequestBusAddr,
+			       sizeof(struct SMPRequestPhyInput),
+			       port->dc.SMPResponseBusAddr,
+			       sizeof(struct SMPResponseReportPhyErrorLog));
+
+	scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+	asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+#ifdef ASD_DEBUG
+	dumpsmp((uint8_t *)port->dc.SMPRequestFrame);	
+#endif	
+	asd_push_post_stack(asd, scb, (void *) port,
+			    asd_hwi_reset_exp_device_done);
+	asd_hwi_post_scb(asd, scb);
+}
+
+/*
+ * Function:
+ *	asd_hwi_reset_exp_device()
+ *	
+ * Description:
+ * 	For device that is attached behind an expander device, device reset
+ *	is achieved by issuing SMP PHY CONTROL with a phy operation of:
+ *	- HARD RESET for SSP and STP device port.
+ *	- LINK RESET for SATA/SATAPI device port.
+ */
+static void
+asd_hwi_reset_exp_device(struct asd_softc *asd, struct scb *scb)
+{
+	struct asd_target	*exp_targ;
+	struct asd_target	*targ;
+	struct asd_port		*port;
+	struct Discover		*disc;
+	int			 phy_id;
+
+	port = SCB_GET_SRC_PORT(scb);
+	targ = scb->platform_data->targ;
+	/* Expander that the target is attached to. */
+	exp_targ = targ->parent;
+	if (exp_targ == NULL) {
+		/* This shouldn't happen. */
+		asd_log(ASD_DBG_ERROR, "Parent Expander shouldn't be NULL.\n");
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		asd_hwi_reset_device(asd,
+				    (struct scb *) scb->post_stack[0].io_ctx,
+				     scb);
+		return;
+	}
+
+	/*
+	 * Find the expander phy id that the target is attached to. 
+	 */
+	for (phy_id = 0; phy_id < exp_targ->num_phys; phy_id++) {
+		disc = &(exp_targ->Phy[phy_id].Result);
+
+		if (SAS_ISEQUAL(targ->ddb_profile.sas_addr,
+				disc->AttachedSASAddress))
+			break;
+	}
+
+	if (phy_id == exp_targ->num_phys) {
+		/* This shouldn't happen. */
+		asd_log(ASD_DBG_ERROR, "Corrupted target, inv. phy id.\n");
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		asd_hwi_reset_device(asd,
+				    (struct scb *) scb->post_stack[0].io_ctx,
+				     scb);
+		return;
+	}
+
+	/* 
+	 * For SSP/STP target port, CONTROL PHY-HARD RESET will be issued.
+	 * For SATA/SATAPI target port, CONTROL PHY-LINK RESET will be issued.
+	 */
+	asd_hwi_build_smp_phy_req(
+		port, PHY_CONTROL, phy_id,
+		((targ->transport_type == ASD_TRANSPORT_ATA
+		 || targ->transport_type ==ASD_TRANSPORT_STP) ? LINK_RESET :
+		 					       HARD_RESET));
+
+	/* Build a SMP REQUEST. */
+	asd_hwi_build_smp_task(scb, exp_targ,
+			       port->dc.SMPRequestBusAddr,
+			       sizeof(struct SMPRequestPhyControl),
+			       port->dc.SMPResponseBusAddr,
+			       sizeof(struct SMPResponsePhyControl));
+
+	scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+	asd_setup_scb_timer(scb, (8 * HZ), asd_scb_eh_timeout);
+
+#ifdef ASD_DEBUG
+	dumpsmp((uint8_t *)port->dc.SMPRequestFrame);	
+#endif	
+	asd_push_post_stack(asd, scb, (void *) port,
+			    asd_hwi_reset_exp_device_done);
+	asd_hwi_post_scb(asd, scb);
+}
+
+static void
+asd_hwi_reset_exp_device_done(struct asd_softc *asd, struct scb *scb, 
+			      struct asd_done_list *dl)
+{
+	asd_log(ASD_DBG_ERROR, "DL Opcode = 0x%x.\n", dl->opcode);
+	/*
+       	 * There is a possibility that this post routine is called after
+	 * the SCB timedout. So, only delete the timer if the SCB hasn't
+	 * timedout.
+	 */
+	if (scb->eh_state != SCB_EH_TIMEDOUT)
+		del_timer_sync(&scb->platform_data->timeout);
+
+	switch (dl->opcode) {
+	case TASK_COMP_WO_ERR:
+	{	
+		struct asd_port	*port;
+
+		port = (struct asd_port *) scb->io_ctx;
+		/* Check the SMP Response function result. */
+		if (port->dc.SMPResponseFrame->FunctionResult ==
+			SMP_FUNCTION_ACCEPTED) {
+			if (scb->eh_state == SCB_EH_PHY_REPORT_REQ) {
+				asd_hwi_dump_phy_err_log(port, scb);
+				// do the first time clear nexus after PHY report error
+				scb->eh_state = SCB_EH_CLR_NXS_REQ;
+			} else {
+				scb->eh_state = SCB_EH_RESUME_SENDQ;
+
+			}
+			scb->eh_status = SCB_EH_SUCCEED;
+		} else {
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+		}
+		break;
+	}
+
+	case TASK_CLEARED:
+		/* 
+		 * Previous error recovery SCB that timed-out and
+		 * was aborted.
+		 * All we need to do here is just free the scb.
+		 */ 
+		asd_hwi_free_scb(asd, scb);
+		return;
+
+	case TASK_F_W_SMPRSP_TO:
+	case TASK_F_W_SMP_XMTRCV_ERR:
+	default:
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+		break;
+	}
+
+	asd_hwi_reset_device(asd, (struct scb *) scb->post_stack[0].io_ctx,
+			     scb);
+}
+
+static void
+asd_hwi_dump_phy_err_log(struct asd_port *port, struct scb *scb)
+{
+	struct SMPResponseReportPhyErrorLog 	*report_phy_log;
+	struct asd_target			*targ;
+	struct asd_device			*dev;
+
+	report_phy_log = (struct SMPResponseReportPhyErrorLog *)
+				&(port->dc.SMPResponseFrame->Response);
+	targ = scb->platform_data->targ;
+	dev = scb->platform_data->dev;
+
+	asd_print("REPORT PHY ERROR LOG\n");
+	asd_print("---------------------\n");
+	asd_print("Phy #%d of Expander 0x%llx.\n",
+		  report_phy_log->PhyIdentifier, asd_be64toh(
+		  *((uint64_t *) targ->parent->ddb_profile.sas_addr)));
+	asd_print("Attached device:\n"); 
+	asd_print("Scsi %d Ch %d Tgt %d Lun %d, SAS Addr: 0x%llx.\n",
+		  targ->softc->platform_data->scsi_host->host_no,
+		  dev->ch, dev->id, dev->lun, asd_be64toh(
+		  *((uint64_t *) targ->ddb_profile.sas_addr)));
+	asd_print("\nPHY ERROR COUNTS\n");
+	asd_print("----------------\n");
+	asd_print("Invalid Dword Count: %d.\n",
+		  report_phy_log->InvalidDuint16_tCount);
+	asd_print("Disparity Error Count: %d.\n",
+		  report_phy_log->DisparityErrorCount);
+	asd_print("Loss of Dword Synchronization Count: %d.\n",
+		  report_phy_log->LossOfDuint16_tSynchronizationCount);
+	asd_print("Phy Reset Problem Count: %d.\n",
+		  report_phy_log->PhyResetProblemCount);
+}
+
+/*
+ * Function:
+ *	asd_hwi_reset_port()
+ *	
+ * Description:
+ *	Issue a HARD/LINK RESET to the failing port.
+ */
+static void
+asd_hwi_reset_port(struct asd_softc *asd, struct scb *scb_to_reset,
+		   struct scb *scb)
+{
+	ASD_LOCK_ASSERT(asd);
+
+	asd_log(ASD_DBG_ERROR, "Curr State: 0x%x Status: 0x%x.\n",
+		scb->eh_state, scb->eh_status);
+	asd_log(ASD_DBG_ERROR, "reset port scb=%p scb_to_reset = %p\n",scb,scb_to_reset);
+
+	switch (scb->eh_state) {
+	case SCB_EH_INITIATED:
+	{
+		struct asd_port		*port;
+		struct asd_target	*targ;
+		
+		port = SCB_GET_SRC_PORT(scb_to_reset);
+		if (port == NULL) {
+			asd_log(ASD_DBG_ERROR," Invalid port to reset.\n");
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_state = SCB_EH_FAILED;
+			asd_hwi_reset_port(asd, scb_to_reset, scb);
+			break;
+		}
+		/* 
+		 * Freeze all the targets' queue attached to the port that
+		 * we are about to reset.
+		 */
+		list_for_each_entry(targ, &port->targets, all_domain_targets) {
+	
+			targ->qfrozen++;
+		}
+
+		/* 
+		 * Saving final post routine and the scb_to_reset in
+		 * the first post stack slot. We need to access the
+		 * scb_to_reset during the device reset process.
+		 */
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+				    asd_hwi_reset_port_done);
+		
+		/* Bitmask of the phys to perform reset. */
+		port->reset_mask = port->conn_mask;
+		scb->platform_data->targ = scb_to_reset->platform_data->targ;
+		scb->platform_data->dev = scb_to_reset->platform_data->dev;
+		scb->eh_state = SCB_EH_CLR_NXS_REQ;
+		asd_hwi_reset_port(asd, scb_to_reset, scb);
+		break;
+	}
+	
+	case SCB_EH_CLR_NXS_REQ:
+		asd_hwi_build_clear_nexus(scb, CLR_NXS_I_OR_T,
+				  	  /*parm*/0, /*ctx*/0);
+		asd_push_post_stack(asd, scb, (void *) scb_to_reset,
+				    asd_hwi_reset_port_done);
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_hwi_post_scb(asd, scb);
+		break;
+
+	case SCB_EH_PORT_RESET_REQ:
+	{
+		struct asd_port	*port;
+		struct asd_phy	*phy;
+		int		 found;
+
+		found = 0;
+		port = SCB_GET_SRC_PORT(scb_to_reset);
+		list_for_each_entry(phy, &port->phys_attached, links) {
+			if ((port->reset_mask & (1 << phy->id)) != 0) {
+				found = 1;
+				break;
+			}
+		}
+		if (found != 1) {
+			/* This shouldn't happen. */
+			asd_log(ASD_DBG_ERROR,"No PHY to reset, PR Mask: 0x%x "
+				"PC Mask: 0x%x.\n",
+				port->reset_mask, port->conn_mask);
+			scb->eh_state = SCB_EH_DONE;
+			scb->eh_status = SCB_EH_FAILED;
+			asd_hwi_reset_port(asd, scb_to_reset, scb);
+			break;
+		}
+		/* 
+	 	 * For SSP initiator wide port, we need to perform a
+		 * HARD RESET only on one of the phys and LINK RESET on
+		 * the remaining phys.
+	 	 */
+		asd_hwi_build_control_phy(scb, phy,
+					 ((port->reset_mask == port->conn_mask)
+					  ? EXECUTE_HARD_RESET : ENABLE_PHY));
+
+		port->reset_mask &= ~(1 << phy->id);
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (8 * HZ), asd_scb_eh_timeout);
+		asd_push_post_stack(asd, scb, (void *) phy,
+				    asd_hwi_reset_port_done);
+		asd_hwi_post_scb(asd, scb);
+		break;
+	}
+
+	case SCB_EH_PHY_NO_OP_REQ:
+	{
+		struct asd_phy	*phy;
+
+		phy = (struct asd_phy *) scb->io_ctx;
+		/*
+		 * Upon completion of HARD RESET, we need to initialize
+		 * OOB registers to enable hot-plug timer.
+		 */
+		asd_hwi_build_control_phy(scb, phy, PHY_NO_OP);
+		scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+		asd_setup_scb_timer(scb, (4 * HZ), asd_scb_eh_timeout);
+		asd_push_post_stack(asd, scb, scb->io_ctx,
+				    asd_hwi_reset_port_done);
+		asd_hwi_post_scb(asd, scb);
+		break;
+	}
+
+	case SCB_EH_DONE:
+	{
+		struct asd_port		*port;
+		struct asd_target	*targ;
+
+		port = SCB_GET_SRC_PORT(scb_to_reset);
+		
+		/* Unfreeze all the targets. */
+		list_for_each_entry(targ, &port->targets, all_domain_targets) {
+			targ->qfrozen--;
+			asd_log(ASD_DBG_INFO,"clear freezen ptr=%p num=%d\n",targ,targ->qfrozen);
+		}
+		scb_to_reset->eh_state = scb->eh_state;
+		scb_to_reset->eh_status = scb->eh_status;
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+	}
+
+	default:
+		asd_log(ASD_DBG_ERROR, "Invalid State.\n");
+		scb_to_reset->eh_state = SCB_EH_DONE;
+		scb_to_reset->eh_status = SCB_EH_FAILED;
+		asd_hwi_free_scb(asd, scb);
+		asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		break;
+	}
+}
+
+static void
+asd_hwi_reset_port_done(struct asd_softc *asd, struct scb *scb, 
+			struct asd_done_list *dl)
+{
+	asd_log(ASD_DBG_ERROR, "DL Opcode = 0x%x.\n", dl->opcode);
+
+	/*
+       	 * There is a possibility that this post routine is called after
+	 * the SCB timedout. So, only delete the timer if the SCB hasn't
+	 * timedout.
+	 */
+	if (scb->eh_state != SCB_EH_TIMEDOUT)
+		del_timer_sync(&scb->platform_data->timeout);
+
+	/* CLR NXS completion. */
+	if (dl->opcode == TASK_COMP_WO_ERR) {
+		scb->eh_state = SCB_EH_PORT_RESET_REQ;
+	} else if (scb->eh_status == SCB_EH_SUCCEED) {
+		if (scb->eh_state != SCB_EH_PHY_NO_OP_REQ) {
+			/* Check if any remaining phys need to be reset. */
+			scb->eh_state =
+				((SCB_GET_SRC_PORT(scb)->reset_mask == 0) ?
+				  SCB_EH_DONE : SCB_EH_PORT_RESET_REQ);
+		}
+	} else {
+		scb->eh_state = SCB_EH_DONE;
+		scb->eh_status = SCB_EH_FAILED;
+	}
+		
+	asd_hwi_reset_port(asd,
+			  (struct scb *) scb->post_stack[0].io_ctx,
+			   scb);
+}
+
+/*************************** NVRAM access utilities ***************************/
+
+#if NVRAM_SUPPORT
+
+
+/*
+ * Function:
+ *	asd_hwi_poll_nvram()
+ *
+ * Description:
+ *	This routine will poll for the NVRAM to be ready to accept new
+ *	command.
+ */
+static int
+asd_hwi_poll_nvram(struct asd_softc *asd)
+{
+	uint8_t	nv_data;
+	uint8_t	toggle_data;
+	int loop_cnt;
+
+	loop_cnt = 5000;
+
+	while (loop_cnt) {
+		nv_data = asd_hwi_swb_read_byte(asd, 
+						asd->hw_profile.nv_flash_bar);
+
+		toggle_data = (nv_data ^ asd_hwi_swb_read_byte(asd,
+						asd->hw_profile.nv_flash_bar));
+
+		if (toggle_data == 0) {
+			return (0);
+		} else {
+	  		if (((toggle_data == 0x04) && ((loop_cnt - 1) == 0)) ||
+			   ((toggle_data & 0x40) && (toggle_data & 0x20))) {
+				return (-1);
+			}
+		}
+	
+		loop_cnt--;
+		asd_delay(ASD_DELAY_COUNT);
+	}
+	return (-1);
+}
+
+static int
+asd_hwi_chk_write_status(struct asd_softc *asd, uint32_t sector_addr, 
+			uint8_t erase_flag) 
+{
+	uint32_t read_addr;
+	uint32_t loop_cnt;
+	uint8_t	nv_data1, nv_data2;
+	uint8_t	toggle_bit1/*, toggle_bit2*/;
+
+	/* 
+	 * Read from DQ2 requires sector address 
+	 * while it's dont care for DQ6 
+	 */
+	/* read_addr = asd->hw_profile.nv_flash_bar + sector_addr;*/
+	read_addr = asd->hw_profile.nv_flash_bar;
+	loop_cnt = 50000;
+
+	while (loop_cnt) {
+		nv_data1 = asd_hwi_swb_read_byte(asd, read_addr); 
+		nv_data2 = asd_hwi_swb_read_byte(asd, read_addr); 
+
+		toggle_bit1 = ((nv_data1 & FLASH_STATUS_BIT_MASK_DQ6)
+				 ^ (nv_data2 & FLASH_STATUS_BIT_MASK_DQ6));
+		/* toggle_bit2 = ((nv_data1 & FLASH_STATUS_BIT_MASK_DQ2) 
+				^ (nv_data2 & FLASH_STATUS_BIT_MASK_DQ2));*/
+
+		if (toggle_bit1 == 0) {
+			return (0);
+		} else {
+			if (nv_data2 & FLASH_STATUS_BIT_MASK_DQ5) {
+				nv_data1 = asd_hwi_swb_read_byte(asd, 
+								read_addr); 
+				nv_data2 = asd_hwi_swb_read_byte(asd,
+								read_addr); 
+				toggle_bit1 = 
+				((nv_data1 & FLASH_STATUS_BIT_MASK_DQ6) 
+				^ (nv_data2 & FLASH_STATUS_BIT_MASK_DQ6));
+				/*
+				toggle_bit2 = 
+				   ((nv_data1 & FLASH_STATUS_BIT_MASK_DQ2) 
+				   ^ (nv_data2 & FLASH_STATUS_BIT_MASK_DQ2));
+				*/
+				if (toggle_bit1 == 0) {
+					return 0;
+				}
+			}
+		}
+		loop_cnt--;
+	
+		/* 
+		 * ERASE is a sector-by-sector operation and requires
+		 * more time to finish while WRITE is byte-byte-byte
+		 * operation and takes lesser time to finish. 
+		 *
+		 * For some strange reason a reduced ERASE delay gives different
+		 * behaviour across different spirit boards. Hence we set
+		 * a optimum balance of 50mus for ERASE which works well
+		 * across all boards.
+		 */ 
+		if (erase_flag) {
+			asd_delay(FLASH_STATUS_ERASE_DELAY_COUNT);
+		} else {
+			asd_delay(FLASH_STATUS_WRITE_DELAY_COUNT);
+		}
+	}
+	return (-1);
+}
+/*
+ * Function:
+ *	asd_hwi_reset_nvram()
+ *
+ * Description:
+ *	Reset the NVRAM section.
+ */
+static int
+asd_hwi_reset_nvram(struct asd_softc *asd)
+{
+	/* Poll till NVRAM is ready for new command. */
+	if (asd_hwi_poll_nvram(asd) != 0)
+		return (-1);
+
+	asd_hwi_swb_write_byte(asd, asd->hw_profile.nv_flash_bar, NVRAM_RESET);
+
+	/* Poll if the command is successfully written. */
+	if (asd_hwi_poll_nvram(asd) != 0)
+		return (-1);	
+
+	return (0);
+}
+
+/*
+ * Function:
+ * 	asd_hwi_search_nv_cookie()
+ *
+ * Description:
+ *	Search the cookie in NVRAM.
+ *	If found, return the address offset of the cookie.
+ */
+int
+asd_hwi_search_nv_cookie(struct asd_softc *asd, uint32_t *addr,
+			struct asd_flash_dir_layout *pflash_dir_buf)
+{
+	struct asd_flash_dir_layout flash_dir;
+	uint8_t		 cookie_to_find[32]="*** ADAPTEC FLASH DIRECTORY *** ";
+	void		*dest_buf;
+	uint32_t	 nv_addr;
+	int		 cookie_found;
+	u_int		 bytes_read;
+
+	memset(&flash_dir, 0x0, sizeof(flash_dir));
+	dest_buf = &flash_dir;
+	cookie_found = 0;
+	nv_addr = 0;
+	while (nv_addr < NVRAM_MAX_BASE_ADR) {
+		if (asd_hwi_read_nv_segment(asd, NVRAM_NO_SEGMENT_ID,
+					    dest_buf, nv_addr,
+					    sizeof(flash_dir), 
+					    &bytes_read)
+					    != 0)
+			return (-1);
+
+		if (memcmp(flash_dir.cookie,
+			   &cookie_to_find[0],
+			   NVRAM_COOKIE_SIZE) == 0) {
+			cookie_found = 1;
+			if (pflash_dir_buf != NULL) {
+				memcpy(pflash_dir_buf, &flash_dir, 
+					sizeof(flash_dir));
+			}
+			break;
+		}
+
+		nv_addr += NVRAM_NEXT_ENTRY_OFFSET;
+	}
+	if (cookie_found == 0) {
+		return (-1);
+	}
+	
+	*addr = nv_addr;
+	asd->hw_profile.nv_cookie_addr = nv_addr;
+	asd->hw_profile.nv_cookie_found = 1;
+
+	return (0);
+}
+
+/*
+ * Function:
+ * 	asd_hwi_search_nv_segment()
+ *
+ * Description:
+ *	Search the requested NVRAM segment.
+ *	If exists, the segment offset, attributes, pad_size and image_size
+ *	will be returned.
+ */
+int
+asd_hwi_search_nv_segment(struct asd_softc *asd, u_int segment_id,
+			  uint32_t *offset, uint32_t *pad_size,
+			  uint32_t *image_size, uint32_t *attr)
+{
+	struct asd_flash_dir_layout 	flash_dir;
+	struct asd_fd_entry_layout 	fd_entry;
+	uint32_t			nv_addr;
+	int				segment_found;
+	u_int				bytes_read;
+	u_int				i;
+
+	/*
+	 * Check if we have NVRAM base addr for the FLASH directory layout.
+	 */
+	if (asd->hw_profile.nv_cookie_found != 1) {
+		if (asd_hwi_search_nv_cookie(asd, &nv_addr,
+					&flash_dir) != 0) {
+			asd_log(ASD_DBG_ERROR, "Failed to search NVRAM "
+				"cookie.\n");
+			return (-1);
+		}
+	} else {
+	    nv_addr = asd->hw_profile.nv_cookie_addr;
+	}
+		    
+	nv_addr += NVRAM_FIRST_DIR_ENTRY;
+	memset(&fd_entry, 0x0, sizeof(struct asd_fd_entry_layout));
+	segment_found = 0;
+
+	for (i = 0; i < NVRAM_MAX_ENTRIES; i++) {
+		if (asd_hwi_read_nv_segment(asd, NVRAM_NO_SEGMENT_ID,
+					&fd_entry, nv_addr,
+					sizeof(struct asd_fd_entry_layout),
+					&bytes_read) != 0) {
+			return (-1);
+		}
+
+		if ((fd_entry.attr & FD_ENTRYTYPE_CODE) == segment_id) {
+			segment_found = 1;
+			break;
+		}
+
+		nv_addr += sizeof(struct asd_fd_entry_layout);
+	}
+
+	if (segment_found == 0) {
+		return (-1);
+	}
+
+	*offset = fd_entry.offset;
+	*pad_size = fd_entry.pad_size;
+	*attr = ((fd_entry.attr & FD_SEGMENT_ATTR) ? 1 : 0);
+
+	if ((segment_id != NVRAM_CTRL_A_SETTING) &&
+		(segment_id != NVRAM_MANUF_TYPE)) {
+		*image_size = fd_entry.image_size;
+	} else {
+		*image_size = NVRAM_INVALID_SIZE;
+	}
+
+	return (0);
+}
+
+/*
+ * Function:
+ *	asd_hwi_read_nv_segment()
+ *
+ * Description:
+ *	Retrieves data from an NVRAM segment.
+ */
+int
+asd_hwi_read_nv_segment(struct asd_softc *asd, uint32_t segment_id, void *dest,
+			uint32_t src_offset, uint32_t bytes_to_read,
+			uint32_t *bytes_read)
+{
+    	uint8_t		*dest_buf;
+    	uint32_t	 nv_offset;
+	uint32_t	 pad_size, image_size, attr;
+	uint32_t	 i;
+
+	/* Reset the NVRAM. */
+	if (asd_hwi_reset_nvram(asd) != 0)
+		return (-1);
+
+	nv_offset = 0;
+	if (segment_id != NVRAM_NO_SEGMENT_ID) {
+		if (asd_hwi_search_nv_segment(asd, segment_id, &nv_offset,
+					      &pad_size, &image_size,
+					      &attr) != 0) {
+			return (-1);
+		}
+	}
+	nv_offset = asd->hw_profile.nv_flash_bar + nv_offset + src_offset;
+
+	dest_buf = (uint8_t *) dest;
+	*bytes_read = 0;
+
+	if (asd_hwi_reset_nvram(asd) != 0)
+		return (-1);
+
+	for (i = 0; i < bytes_to_read; i++) {
+		*(dest_buf + i) = asd_hwi_swb_read_byte(asd, (nv_offset + i));
+		if (asd_hwi_poll_nvram(asd) != 0) {
+			return (-1);
+		}
+	}
+	*bytes_read = i;
+
+	return (0); 
+}
+
+/*
+ * Function:
+ *	asd_hwi_write_nv_segment()
+ *
+ * Description:
+ *	Writes data to an NVRAM segment.
+ */
+int
+asd_hwi_write_nv_segment(struct asd_softc *asd, void *src, uint32_t segment_id, 
+			uint32_t dest_offset, uint32_t bytes_to_write)
+{
+    	uint8_t	*src_buf;
+	uint32_t nv_offset, nv_flash_bar, i;
+	uint32_t pad_size, image_size, attr;
+
+	nv_flash_bar = asd->hw_profile.nv_flash_bar;
+	src_buf = NULL;
+	nv_offset = 0;
+	attr = 0;
+	pad_size = 0;
+	image_size = 0;
+
+	if (asd_hwi_reset_nvram(asd) != 0) {
+		return (-1);
+	}
+	if (segment_id != NVRAM_NO_SEGMENT_ID) {
+		if (asd_hwi_search_nv_segment(asd, segment_id, &nv_offset, 
+				&pad_size, &image_size, &attr) != 0) {
+			return (-1);
+		}
+		if ((bytes_to_write > pad_size) || (dest_offset != 0)) {
+			return (-1);
+		}
+	}
+
+	nv_offset += dest_offset;
+	if (segment_id == NVRAM_NO_SEGMENT_ID 
+	   || attr == NVRAM_SEGMENT_ATTR_ERASEWRITE) {
+		if (asd_hwi_erase_nv_sector(asd, nv_offset) != 0) {
+			printk("<1>adp94xx: Erase failed at offset:0x%x\n",
+				nv_offset);
+			return (-1);
+		}
+	}
+
+	if (asd_hwi_reset_nvram(asd) != 0) {
+		return (-1);
+	}
+	src_buf = (uint8_t *)src;
+	for (i = 0; i < bytes_to_write; i++) {
+		/* Setup program command sequence */
+		switch (asd->hw_profile.flash_method) {
+		case FLASH_METHOD_A:
+		{
+			asd_hwi_swb_write_byte(asd, 
+					(nv_flash_bar + 0xAAA), 0xAA);
+			asd_hwi_swb_write_byte(asd, 
+					(nv_flash_bar + 0x555), 0x55);
+			asd_hwi_swb_write_byte(asd, 
+					(nv_flash_bar + 0xAAA), 0xA0);
+			asd_hwi_swb_write_byte(asd, 
+					(nv_flash_bar + nv_offset + i),
+					(*(src_buf + i)));
+			break;
+		}
+		case FLASH_METHOD_B:
+		{
+			asd_hwi_swb_write_byte(asd, 
+					(nv_flash_bar + 0x555), 0xAA);
+			asd_hwi_swb_write_byte(asd, 
+					(nv_flash_bar + 0x2AA), 0x55);
+			asd_hwi_swb_write_byte(asd, 
+					(nv_flash_bar + 0x555), 0xA0);
+			asd_hwi_swb_write_byte(asd, 
+					(nv_flash_bar + nv_offset + i),
+					(*(src_buf + i)));
+			break;
+		}
+		default:
+			break;
+		}
+		if (asd_hwi_chk_write_status(asd, (nv_offset + i), 
+			0 /* WRITE operation */) != 0) {
+			printk("<1>adp94xx: Write failed at offset:0x%x\n",
+				nv_flash_bar + nv_offset + i);
+			return -1;
+		}
+	}
+
+	if (asd_hwi_reset_nvram(asd) != 0) {
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * Function:
+ *	asd_hwi_erase_nv_sector()
+ *
+ * Description:
+ *	Erase the requested NVRAM sector.
+ */
+static int
+asd_hwi_erase_nv_sector(struct asd_softc *asd, uint32_t sector_addr) 
+{
+	uint32_t nv_flash_bar;
+	
+	nv_flash_bar = asd->hw_profile.nv_flash_bar; 
+	if (asd_hwi_poll_nvram(asd) != 0) {
+		return (-1);
+	}
+	/*
+	 * Erasing an NVRAM sector needs to be done in six consecutive
+	 * write cyles.
+	 */
+	switch (asd->hw_profile.flash_method) {
+
+	case FLASH_METHOD_A:
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0xAAA), 0xAA);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x555), 0x55);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0xAAA), 0x80);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0xAAA), 0xAA);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x555), 0x55);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + sector_addr), 0x30);
+		break;
+
+	case FLASH_METHOD_B:
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x555), 0xAA);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x2AA), 0x55);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x555), 0x80);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x555), 0xAA);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x2AA), 0x55);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + sector_addr), 0x30);
+		break;
+
+	default:
+		break;
+	}
+
+	if (asd_hwi_chk_write_status(asd, sector_addr, 
+				1 /* ERASE operation */) != 0) {
+		return (-1);
+	}
+
+	return (0);
+}
+
+/*
+ * Function:
+ * 	asd_hwi_verify_nv_checksum()
+ *	
+ * Description:
+ *	Verify if the checksum for particular NV segment is correct.
+ */		 	  
+static int
+asd_hwi_verify_nv_checksum(struct asd_softc *asd, u_int segment_id,
+			   uint8_t *segment_ptr, u_int bytes_to_read)
+{
+	uint32_t		offset;
+	u_int			pad_size;
+	u_int			image_size;
+	u_int			attr;
+	u_int			bytes_read;
+	int			checksum_bytes;
+	uint16_t		sum;
+	uint16_t		*seg_ptr;
+	u_short			i;
+	
+	if (asd_hwi_search_nv_segment(asd, segment_id, &offset, &pad_size,
+				      &image_size, &attr) != 0) {
+		asd_log(ASD_DBG_ERROR, "Requested segment not found in "
+			"the NVRAM.\n");
+		return (-1);
+	}
+
+	memset(segment_ptr, 0x0, bytes_to_read);
+	if (asd_hwi_read_nv_segment(asd, NVRAM_NO_SEGMENT_ID, segment_ptr,
+				    offset, bytes_to_read, &bytes_read) != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to read NVRAM segment %d.\n",
+			NVRAM_NO_SEGMENT_ID);
+		return (-1);
+	}
+
+	if (asd_hwi_reset_nvram(asd) != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to reset NVRAM.\n");
+		return (-1);
+	}
+
+	seg_ptr = (uint16_t *) segment_ptr;
+	/*
+	 * checksum_bytes is equivalent to the size of the layout.
+         * The size of layout is available at the offset of 8.
+	 */	 
+	checksum_bytes = (*(seg_ptr + 4) / 2);
+	offset += asd->hw_profile.nv_flash_bar;
+	sum = 0;
+	
+	for (i = 0; i < checksum_bytes; i++)
+		sum += asd_hwi_swb_read_word(asd, (offset + (i*2)));
+
+	if (sum != 0) {
+		asd_log(ASD_DBG_ERROR, "Checksum verification failed.\n");
+		return (-1);
+	}
+
+	return (0);
+}
+
+/*
+ * Function:
+ * 	asd_hwi_get_nv_config() 
+ *
+ * Description:
+ *	Retrieves NVRAM configuration for the controller.
+ */	   
+static int
+asd_hwi_get_nv_config(struct asd_softc  *asd)
+{
+	struct asd_manuf_base_seg_layout manuf_layout;
+	struct asd_pci_layout	pci_layout;
+	uint32_t		offset;
+	u_int			bytes_read;
+
+	if (asd_hwi_check_flash(asd) < 0) 
+		return -1;
+
+	asd->hw_profile.nv_exist = 0;
+	/* Verify if the controller NVRAM has CTRL_A_SETTING type. */
+	if (asd_hwi_verify_nv_checksum(asd, NVRAM_CTRL_A_SETTING,
+				       (uint8_t *) &pci_layout,
+				       sizeof(struct asd_pci_layout)) != 0) {
+		/* 
+		 * CTRL_A type verification failed, verify if the controller  
+		 * has NVRAM CTRL_A_DEFAULT type.
+		 */  
+		if (asd_hwi_verify_nv_checksum(asd, NVRAM_CTRL_A_DEFAULT,
+					       (uint8_t *) &pci_layout, 
+					       sizeof(struct asd_pci_layout))
+					       != 0)
+			return (-1);
+
+		asd->hw_profile.nv_segment_type = NVRAM_CTRL_A_DEFAULT;
+	} else {
+		asd->hw_profile.nv_segment_type = NVRAM_CTRL_A_SETTING;
+		asd->hw_profile.nv_exist = 1;
+	}
+
+	offset = 0;
+	memset(&manuf_layout, 0x0, sizeof (struct asd_manuf_base_seg_layout));
+
+	/* Retrieves Controller Manufacturing NVRAM setting. */
+	if (asd_hwi_read_nv_segment(asd, NVRAM_MANUF_TYPE, &manuf_layout,
+			    offset, sizeof(struct asd_manuf_base_seg_layout),
+			    &bytes_read) != 0) {
+		return (-1);
+	}
+
+	memcpy(asd->hw_profile.wwn, manuf_layout.base_sas_addr, 
+	       ASD_MAX_WWN_LEN);
+
+	return (0);
+}	
+
+/*
+ * Function:
+ * 	asd_hwi_search_nv_id()
+ *
+ * Description:
+ * 	Search for the requested NV setting ID. If successful copy contents
+ * 	to the destination buffer and set appropriate value in offset.
+ */
+static int
+asd_hwi_search_nv_id(struct asd_softc  *asd, u_int setting_id, void *dest,
+		     u_int  *src_offset, u_int bytes_to_read)
+{
+	struct asd_settings_layout *psettings;
+	uint32_t offset;
+	int bytes_read;
+
+	offset = 0;
+	bytes_read = 0;
+	psettings = (struct asd_settings_layout *)dest;
+	while (1) {
+		
+        	if (asd_hwi_read_nv_segment(asd, 
+				    asd->hw_profile.nv_segment_type, 
+				    psettings,
+				    offset, 
+				    bytes_to_read,
+				    &bytes_read) != 0) {
+			return (-1);
+		}
+
+		if (psettings->id == setting_id) {
+            		break;
+        	} else {
+			
+            		if (psettings->next_ptr == 0)
+				return -1;
+			offset = (uint32_t)offset + psettings->next_ptr;
+		}
+	}
+	*src_offset = offset;
+	return (0);
+}
+
+static int
+asd_hwi_get_nv_phy_settings(struct asd_softc *asd)
+{
+	struct asd_phy_settings_layout phy_settings;
+	struct asd_phy_settings_entry_layout *phy_entry;
+	uint32_t		offset;
+	uint32_t		bytes_to_read;
+	struct asd_phy		*phy;
+	u_int			bytes_read;
+	u_int		 	phy_id;
+	u_char		 	settings_found;
+
+	if (asd->hw_profile.nv_exist != 1)
+		return -1;
+	/*
+	 * NVRAM setting exists, retrieve Phys user settings, such 
+	 * as SAS address, connection rate, and attributes.
+	 */  
+	
+	offset = 0;
+	settings_found = 0;
+	if (asd_hwi_search_nv_id(asd, NVRAM_PHY_SETTINGS_ID, 
+			&phy_settings, &offset, sizeof(phy_settings))) {
+		return -1;
+	}
+
+	bytes_to_read = phy_settings.num_phys * sizeof(*phy_entry);
+	if ((phy_entry = asd_alloc_mem(bytes_to_read, GFP_ATOMIC)) 
+	   == NULL) {
+		return (-1);
+	}
+
+	if (asd_hwi_read_nv_segment(asd, 
+		    asd->hw_profile.nv_segment_type, 
+		    phy_entry,
+		    offset + sizeof(phy_settings),
+		    bytes_to_read,
+		    &bytes_read) != 0) {
+		asd_free_mem(phy_entry);
+		return (-1);
+	} else {
+		settings_found = 1;
+	}
+
+	if (settings_found == 1) {
+		asd->hw_profile.max_phys = phy_settings.num_phys;
+		for (phy_id = 0; 
+		     phy_id < asd->hw_profile.max_phys; 
+		     phy_id++) {
+			
+			if ((phy = asd->phy_list[phy_id]) == NULL)
+				continue;
+			
+			memcpy(phy->sas_addr, 
+			       phy_entry[phy_id].sas_addr,
+			       SAS_ADDR_LEN);
+			/* 
+			 * if an invalid link rate is specified,
+			 * the existing default value is used. 
+			 */
+			asd_hwi_map_lrate_from_sas(
+				(phy_entry[phy_id].link_rate 
+				 & PHY_MIN_LINK_RATE_MASK),
+				&phy->min_link_rate);
+
+			asd_hwi_map_lrate_from_sas(
+				((phy_entry[phy_id].link_rate
+				 & PHY_MAX_LINK_RATE_MASK) >> 4),
+				&phy->max_link_rate);
+			/* TBD: crc */
+		}
+	}
+	
+	asd_free_mem(phy_entry);
+	return 0;
+}
+
+static void
+asd_hwi_get_nv_phy_params(struct asd_softc *asd)
+{
+	struct asd_manuf_base_seg_layout   manuf_layout;	
+	struct asd_manuf_phy_param_layout  phy_param;
+	struct asd_phy_desc_format	  *pphy_desc;
+	struct asd_phy			  *phy;
+	uint32_t 	 		   offset;
+	uint32_t	 		   bytes_to_read;
+	uint32_t 	 		   bytes_read;
+	u_int 		 		   phy_id;
+	
+	/* Set the phy parms to the default value. */
+	for (phy_id = 0; phy_id < asd->hw_profile.max_phys; phy_id++) {
+		if ((phy = asd->phy_list[phy_id]) == NULL)
+			continue;
+
+		phy->phy_state = PHY_STATE_DEFAULT;
+		phy->phy_ctl0 = PHY_CTL0_DEFAULT;
+		phy->phy_ctl1 = PHY_CTL1_DEFAULT;
+		phy->phy_ctl2 = PHY_CTL2_DEFAULT;
+		phy->phy_ctl3 = PHY_CTL3_DEFAULT;
+	}
+
+	if (asd_hwi_verify_nv_checksum(asd, NVRAM_MANUF_TYPE,
+				       (uint8_t *) &manuf_layout,
+				       sizeof(struct asd_manuf_base_seg_layout))
+				       != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed verifying checksum for "
+			"NVRAM MANUFACTURING LAYOUT.\n");
+		goto exit;
+	}
+
+	offset = 0;
+	memset(&phy_param, 0x0, sizeof(phy_param));
+
+	if (asd_hwi_get_nv_manuf_seg(asd, &phy_param,
+				     sizeof(phy_param), &offset,
+				     NVRAM_MNF_PHY_PARAM_SIGN) != 0)
+		goto exit;
+
+	if (phy_param.num_phy_desc > asd->hw_profile.max_phys)
+		phy_param.num_phy_desc = asd->hw_profile.max_phys;
+	
+	bytes_to_read = phy_param.num_phy_desc * phy_param.phy_desc_size;
+	if ((pphy_desc = asd_alloc_mem(bytes_to_read, GFP_ATOMIC)) == NULL)
+		goto exit;
+
+	offset += sizeof(phy_param);
+	if (asd_hwi_read_nv_segment(asd, NVRAM_MANUF_TYPE, pphy_desc, offset,
+				    bytes_to_read, &bytes_read) != 0) {
+		asd_free_mem(pphy_desc);
+		goto exit;
+	}
+
+	for (phy_id = 0; phy_id < asd->hw_profile.max_phys; phy_id++) {
+		if ((phy = asd->phy_list[phy_id]) == NULL)
+			continue;
+
+		phy->phy_state = (pphy_desc[phy_id].state & PHY_STATE_MASK);
+		phy->phy_ctl0 &= ~PHY_CTL0_MASK;
+		phy->phy_ctl0 |= (pphy_desc[phy_id].ctl0 & PHY_CTL0_MASK);
+		phy->phy_ctl1 = pphy_desc[phy_id].ctl1;
+		phy->phy_ctl2 = pphy_desc[phy_id].ctl2;
+		phy->phy_ctl3 = pphy_desc[phy_id].ctl3;
+
+		if (phy->phy_state == NVRAM_PHY_HIDDEN) {
+			asd->hw_profile.enabled_phys &= ~(1 << phy_id);
+		}
+	}
+
+	asd_free_mem(pphy_desc);
+exit:	
+	return;
+}
+
+/*
+ * Function:
+ *	asd_hwi_get_nv_conn_info
+ *
+ * Description:
+ * 	This routine reads the Connector Map information from Flash (NVRAM)
+ * 	and allocates memory and populates the parameters 'pconn' 
+ * 	and 'pnoded' with the read information. 
+ *
+ * 	At the end of this routine if everything goes fine the data structure 
+ * 	layout pointed to by 'pconn' and 'pnoded' will be:
+ *
+ * 	'pconn' ->
+ * 	|-----------|--------------|--------------|--------
+ * 	| Connector | Connector    | Connector    | ...
+ * 	| Map 	    | Descriptor 0 | Descriptor 1 | 
+ * 	|-----------|--------------|--------------|--------
+ * 	
+ * 	'pnoded' ->
+ * 	|--------|--------|--------|---  --|-------|--------|--------|----
+ * 	| Node   | Phy    | Phy    |...    | Node  | Phy    | Phy    | ...
+ * 	| Desc 0 | Desc 0 | Desc 1 |       | Desc 1| Desc 0 | Desc 1 |
+ * 	|--------|--------|--------|---  --|-------|--------|--------|----
+ *
+ * 	'pconn_size' will hold the size of data pointed to by 'pconn' 
+ * 	'pnoded_size' will hold the size of data pointed to by 'pnoded'. 
+ * 	
+ */
+int
+asd_hwi_get_nv_conn_info(struct asd_softc *asd,
+			 uint8_t **pconn,
+			 uint32_t *pconn_size,
+			 uint8_t **pnoded,
+			 uint32_t *pnoded_size)
+{
+	struct asd_manuf_base_seg_layout   manuf_layout;	
+	struct asd_conn_map_format conn_map;
+	struct asd_node_desc_format node_desc;
+	//struct asd_conn_desc_format *pconn_desc;
+	uint8_t *pconn_buf; 
+	uint8_t *pnode_buf; 
+	uint32_t offset, cur_offset;
+	uint32_t bytes_to_read, bytes_read;
+	uint32_t bytes_count, tot_count;
+	uint32_t node_num;
+	
+	if (pconn == NULL || pnoded == NULL || pconn_size == NULL 
+	   || pnoded_size == NULL) {
+		return -1;
+	}
+
+	if (asd_hwi_verify_nv_checksum(asd, NVRAM_MANUF_TYPE,
+				       (uint8_t *) &manuf_layout,
+				       sizeof(manuf_layout))
+				       != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed verifying checksum for "
+			"NVRAM MANUFACTURING LAYOUT.\n");
+		return -1;
+	}
+
+	/* 
+	 * Determine the memory size to be allocated by reading
+	 * the connector_map first
+	 */
+	offset = 0;
+	memset(&conn_map, 0x0, sizeof(conn_map));
+	if (asd_hwi_get_nv_manuf_seg(asd, &conn_map, 
+				sizeof(conn_map), &offset,
+				NVRAM_MNF_CONN_MAP) != 0){
+		return (-1);
+	}
+	
+	bytes_to_read = sizeof(conn_map) 
+			+ conn_map.num_conn_desc * conn_map.conn_desc_size;
+	
+	/* 
+	 * Now read connector_map and associated connector_decriptor entries
+	 */
+	*pconn_size = bytes_to_read;
+	if ((pconn_buf = asd_alloc_mem(bytes_to_read, GFP_ATOMIC)) 
+	   == NULL) {
+		return (-1);
+	}
+	memset(pconn_buf, 0, bytes_to_read);
+	if (asd_hwi_read_nv_segment(asd, NVRAM_MANUF_TYPE,
+				pconn_buf, offset,
+				bytes_to_read,
+				&bytes_read) != 0) {
+		asd_free_mem(pconn_buf);
+		return (-1);
+	}
+
+	/* bypass all read connector_map & connector_descriptor entries */
+	offset += (bytes_read + 1);
+	
+	/* no field in connector map yet */
+	bytes_to_read = sizeof(node_desc); 
+
+	/* 
+	 * Determine memory to be allocated for reading node descriptors
+	 * and their associated phy descriptor entries
+	 */
+	bytes_count = 0;
+	tot_count = 0;
+	cur_offset = offset;
+	for (node_num = 0; node_num < conn_map.num_node_desc; node_num++) {
+		if (asd_hwi_read_nv_segment(asd, NVRAM_MANUF_TYPE,
+					&node_desc, cur_offset,
+					bytes_to_read,
+					&bytes_read) != 0) {
+			asd_free_mem(pconn_buf);
+			return (-1);
+		}
+		bytes_count = (sizeof(node_desc) 
+				+ (node_desc.num_phy_desc 
+				   * node_desc.phy_desc_size));
+		cur_offset += bytes_count;
+		tot_count += bytes_count;
+	}
+	bytes_to_read = tot_count;
+	
+	/* 
+	 * Now read node descriptors and their 
+	 * associated phy descriptor entries
+	 */
+	if ((pnode_buf = asd_alloc_mem(bytes_to_read, GFP_ATOMIC)) 
+	   == NULL) {
+		asd_free_mem(pconn_buf);
+		return (-1);
+	}
+	if (asd_hwi_read_nv_segment(asd, NVRAM_MANUF_TYPE,
+				pnode_buf, offset,
+				bytes_to_read,
+				&bytes_read) != 0) {
+		asd_free_mem(pconn_buf);
+		asd_free_mem(pnode_buf);
+		return (-1);
+	}
+
+	/* Caller has to free the resources */
+	*pconn = pconn_buf;
+	*pnoded = pnode_buf;
+	*pnoded_size = tot_count;
+
+	return 0;
+}
+
+static int
+asd_hwi_get_nv_manuf_seg(struct asd_softc *asd, void *dest, 
+			 uint32_t bytes_to_read, uint32_t *src_offset,
+			 uint16_t signature) 
+{
+	struct asd_manuf_base_seg_layout manuf_layout;
+	uint32_t 			 offset;
+	uint32_t 			 bytes_read;
+	int				 segments_size;
+	int				 segment_off;
+	int 				 err;
+	
+	memset(&manuf_layout, 0x0, sizeof(manuf_layout));
+	err = -1;
+	offset = 0;
+
+	/* Retrieve Manufacturing Base segment */
+	if (asd_hwi_read_nv_segment(asd, NVRAM_MANUF_TYPE, &manuf_layout,
+				    offset, sizeof(manuf_layout), 
+				    &bytes_read) != 0) {
+		return err;
+	}
+
+	/* Retrieve Manufacturing segment specified by signature */
+	offset = manuf_layout.seg_sign.next_seg_ptr;
+	segments_size = manuf_layout.sector_size - sizeof(manuf_layout); 
+	segment_off = offset;
+
+	while (1) {
+		if (asd_hwi_read_nv_segment(asd, NVRAM_MANUF_TYPE,
+					    dest, offset, bytes_to_read,
+					    &bytes_read) != 0) {
+			return (-1);
+		}
+
+		if (((struct asd_manuf_seg_sign *) dest)->signature ==
+			signature) {
+			*src_offset = offset;
+			err = 0;
+			break;
+		}
+		
+		/*
+		 * If next_seg_ptr is 0 then it indicates the last segment.
+		 */
+		if (((struct asd_manuf_seg_sign *) dest)->next_seg_ptr == 0)
+			break;
+
+		offset = ((struct asd_manuf_seg_sign *) dest)->next_seg_ptr;
+	}
+
+	return err;
+}
+
+static int
+asd_hwi_map_lrate_from_sas(u_int sas_link_rate, 
+		u_int *asd_link_rate)
+{
+	switch (sas_link_rate) {
+	case SAS_RATE_30GBPS:
+		*asd_link_rate = SAS_30GBPS_RATE; 
+		break;
+	case SAS_RATE_15GBPS:
+		*asd_link_rate = SAS_15GBPS_RATE;
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+static int
+asd_hwi_set_speed_mask(u_int asd_link_rate, 
+				  uint8_t *asd_speed_mask)
+{
+	switch (asd_link_rate) {
+	case SAS_60GBPS_RATE:
+		*asd_speed_mask &= ~SAS_SPEED_60_DIS; 
+		break;
+	case SAS_15GBPS_RATE:
+		*asd_speed_mask &= ~SAS_SPEED_15_DIS; 
+		break;
+	case SAS_30GBPS_RATE:
+	default:
+		*asd_speed_mask &= ~SAS_SPEED_30_DIS; 
+		break;
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+*  OCM directory default
+***************************************************************************/
+static struct asd_ocm_dir_format OCMDirInit =
+{
+   OCM_DIR_SIGN,		    /* signature                     */
+   0,                               /* reserve byte                  */
+   0,                               /* reserve byte                  */
+   0,                               /* Major Version No.             */
+   0,                               /* Minor Version No.             */
+   0,                               /* reserve byte                  */
+   0x05,                            /* no. of directory entries      */
+};
+
+/***************************************************************************
+*  OCM directory Entries default
+***************************************************************************/
+static struct asd_ocm_entry_format OCMDirEntriesInit[5] =
+{
+   {
+      (uint8_t)(OCM_DE_ADDC2C_RES0), /* Entry type  */
+      {
+        128,                             /* Offset 0                      */
+        0,                               /* Offset 1                      */
+        0,                               /* Offset 2                      */
+      },
+      0,                               /* reserve byte                  */
+      {
+        0,                               /* size 0                        */
+        4,                               /* size 1                        */
+        0                                /* size 2                        */
+      }
+   },
+   {
+      (uint8_t)(OCM_DE_ADDC2C_RES1), /* Entry type  */
+      {
+        128,                             /* Offset 0                      */
+        4,                               /* Offset 1                      */
+        0,                               /* Offset 2                      */
+      },
+      0,                               /* reserve byte                  */
+      {
+        0,                               /* size 0                        */
+        4,                               /* size 1                        */
+        0                                /* size 2                        */
+      }
+   },
+   {
+      (uint8_t)(OCM_DE_ADDC2C_RES2), /* Entry type  */
+      {
+        128,                             /* Offset 0                      */
+        8,                               /* Offset 1                      */
+        0,                               /* Offset 2                      */
+      },
+      0,                               /* reserve byte                  */
+      {
+        0,                               /* size 0                        */
+        4,                               /* size 1                        */
+        0                                /* size 2                        */
+      }
+   },
+   {
+      (uint8_t)(OCM_DE_ADDC2C_RES3), /* Entry type  */
+      {
+        128,                             /* Offset 0                      */
+        12,                              /* Offset 1                      */
+        0,                               /* Offset 2                      */
+      },
+      0,                               /* reserve byte                  */
+      {
+        0,                               /* size 0                        */
+        4,                               /* size 1                        */
+        0                                /* size 2                        */
+      }
+   },
+   {
+      (uint8_t)(OCM_DE_WIN_DRVR), /* Entry type  */
+      {
+        128,                             /* Offset 0                      */
+        16,                              /* Offset 1                      */
+        0,                               /* Offset 2                      */
+      },
+      0,                               /* reserve byte                  */
+      {
+        128,                             /* size 0 (125824 % 256)         */
+        235,                             /* size 1 (125824 / 256)         */
+        1                                /* size 2 (125824 /(256 * 256))  */
+      }
+   }
+};
+
+static int
+asd_hwi_initialize_ocm_dir (struct asd_softc  *asd)
+{
+	uint8_t *pOCMData;
+	uint8_t i;
+
+   /* load the OCM directory format from OCMDirInit data */
+	pOCMData = (uint8_t *) &OCMDirInit;
+	for (i = 0; i < sizeof(struct asd_ocm_dir_format); i++)
+	{
+		asd_hwi_swb_write_byte(asd, OCM_BASE_ADDR + i, pOCMData[i]);
+	}
+
+   /* load the OCM directory format from OCMDirInit data */
+	pOCMData = (uint8_t *) &OCMDirEntriesInit[0];
+	for (i = 0; i < (sizeof(struct asd_ocm_entry_format) * 5); i++)
+	{
+		asd_hwi_swb_write_byte(asd, OCM_BASE_ADDR + (i + sizeof(struct asd_ocm_dir_format)), pOCMData[i]);
+	}
+	return 0;
+}
+
+static int
+asd_hwi_check_ocm_access (struct asd_softc  *asd)
+{
+
+	uint32_t exsi_base_addr;
+	uint32_t reg_contents;
+	uint32_t	 i;
+	uint32_t intrptStatus;
+
+	/* check if OCM has been initialized by BIOS */	
+	exsi_base_addr = EXSI_REG_BASE_ADR + EXSICNFGR;
+	reg_contents = asd_hwi_swb_read_dword(asd, exsi_base_addr);
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "Current EXSICNFGR is 0x%x\n",reg_contents);
+#endif
+	if (!(reg_contents & OCMINITIALIZED)) {
+		intrptStatus = asd_pcic_read_dword(asd,PCIC_INTRPT_STAT);
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "OCM is not initialized by BIOS, reinitialize it and ignore it, current IntrptStatus is 0x%x\n",intrptStatus);
+#endif
+      /* Initialize OCM to avoid future OCM access to get parity error */
+         /* clear internal error register */
+		asd_pcic_write_dword(asd,  PCIC_INTRPT_STAT, intrptStatus);
+		for (i = 0; i < OCM_MAX_SIZE; i += 4)
+		{
+			asd_hwi_swb_write_dword(asd, OCM_BASE_ADDR + i, 0);
+		}
+		asd_hwi_initialize_ocm_dir(asd);
+		return -1;
+	}
+	return 0;
+}
+
+static int
+asd_hwi_get_ocm_info(struct asd_softc  *asd)
+{
+	struct asd_ocm_entry_format ocm_de;
+	struct asd_bios_chim_format *pbios_chim;
+	uint32_t offset, bytes_read, bytes_to_read;
+
+	if(asd_hwi_check_ocm_access(asd) != 0) {
+		return -1;
+	}
+
+	if (asd_hwi_get_ocm_entry(asd, OCM_DE_BIOS_CHIM, 
+				  &ocm_de, &offset) != 0) {
+		return -1;
+	}
+
+	bytes_to_read = OCM_DE_OFFSET_SIZE_CONV(ocm_de.size);
+	if ((pbios_chim = asd_alloc_mem(bytes_to_read, GFP_ATOMIC)) 
+	   == NULL) {
+		return (-1);
+	}
+	if (asd_hwi_read_ocm_seg(asd, pbios_chim, 
+		OCM_DE_OFFSET_SIZE_CONV(ocm_de.offset), 
+		bytes_to_read, 
+		&bytes_read) != 0) {
+		asd_free_mem(pbios_chim);
+		return -1;
+	}
+	if (pbios_chim->signature == OCM_BC_BIOS_SIGN) {
+		if (pbios_chim->bios_present 
+		   & OCM_BC_BIOS_PRSNT_MASK) {
+			asd->hw_profile.bios_maj_ver = 
+					pbios_chim->bios_maj_ver;
+			asd->hw_profile.bios_min_ver = 
+					pbios_chim->bios_min_ver;
+			asd->hw_profile.bios_bld_num = 
+					pbios_chim->bios_bld_num;
+		}
+	}
+
+	asd->unit_elements = asd_alloc_mem(pbios_chim->num_elements * 
+		sizeof(struct asd_unit_element_format), GFP_ATOMIC);
+
+	if (asd->unit_elements == NULL) {
+		asd_free_mem(pbios_chim);
+		return 0;
+	}
+
+	asd->num_unit_elements = pbios_chim->num_elements;
+
+	memcpy(asd->unit_elements, &pbios_chim->unit_elm[0],
+		pbios_chim->num_elements * 
+			sizeof(struct asd_unit_element_format));
+
+	asd_free_mem(pbios_chim);
+
+	return 0;
+}
+
+static int
+asd_hwi_get_ocm_entry(struct asd_softc  *asd, 
+				 uint32_t entry_type, 
+				 struct asd_ocm_entry_format *pocm_de, 
+				 uint32_t *src_offset)
+{
+	struct asd_ocm_dir_format ocm_dir;
+	uint32_t offset, entry_no;
+	u_int bytes_read;
+	int err;
+
+	memset(&ocm_dir, 0x0, sizeof (ocm_dir));
+	memset(pocm_de, 0x0, sizeof (*pocm_de));
+	offset = 0;
+	err = -1;
+	
+	if (asd_hwi_read_ocm_seg(asd, &ocm_dir, offset, 
+		sizeof(ocm_dir), &bytes_read)) {
+		return -1;
+	}
+
+	if ((ocm_dir.signature != OCM_DIR_SIGN) 
+	   /*|| ((ocm_dir.num_entries & OCM_NUM_ENTRIES_MASK) == 0)*/) {
+		return -1;
+	}
+
+	offset = sizeof(ocm_dir);
+	for (entry_no = 0; 
+	     entry_no < (ocm_dir.num_entries & OCM_NUM_ENTRIES_MASK); 
+	     entry_no++, offset += sizeof(*pocm_de)) {
+		if (asd_hwi_read_ocm_seg(asd, pocm_de, offset, 
+			sizeof(*pocm_de), &bytes_read)) {
+			return -1;
+		}
+		if (pocm_de->type == entry_type) {
+			err = 0;
+			break;
+		}
+	}
+	*src_offset = offset;
+	return err;
+}
+
+static int
+asd_hwi_read_ocm_seg(struct asd_softc *asd, void *dest,
+			uint32_t src_offset, u_int bytes_to_read,
+			u_int *bytes_read)
+{
+    	uint8_t		*dest_buf;
+    	uint32_t	 nv_offset;
+	uint32_t	 i;
+	
+	nv_offset = 0;
+	nv_offset = OCM_BASE_ADDR + nv_offset + src_offset;
+	
+	dest_buf = (uint8_t *) dest;
+	*bytes_read = 0;
+	
+	for (i = 0; i < bytes_to_read; i++) {
+		*(dest_buf+i) = asd_hwi_swb_read_byte(asd, (nv_offset + i));
+	}
+	*bytes_read = i - 1;
+
+	return (0); 
+}
+
+static int asd_hwi_check_flash(struct asd_softc *asd) 
+{
+	uint32_t nv_flash_bar;
+	uint32_t exsi_base_addr;
+	uint32_t reg_contents;
+	uint8_t manuf_id;
+	uint8_t dev_id_boot_blk;
+	uint8_t sec_prot;
+
+	/* get Flash memory base address */
+	asd->hw_profile.nv_flash_bar = 
+				asd_pcic_read_dword(asd, PCIC_FLASH_MBAR);
+	nv_flash_bar = asd->hw_profile.nv_flash_bar; 
+
+	/* check presence of flash */	
+	exsi_base_addr = EXSI_REG_BASE_ADR + EXSICNFGR;
+	reg_contents = asd_hwi_swb_read_dword(asd, exsi_base_addr);
+	if (!(reg_contents & FLASHEX)) {
+		asd->hw_profile.flash_present = FALSE;
+		return -1;
+	}
+	asd->hw_profile.flash_present = TRUE;
+	
+	/* Determine flash info */
+	if (asd_hwi_reset_nvram(asd) != 0) {
+		return (-1);
+	}
+
+	asd->hw_profile.flash_method = FLASH_METHOD_UNKNOWN;
+	asd->hw_profile.flash_manuf_id = FLASH_MANUF_ID_UNKNOWN;
+	asd->hw_profile.flash_dev_id = FLASH_DEV_ID_UNKNOWN;
+
+	/*
+	 * The strategy is to try to read the flash ID using "Method A" first.
+	 * If that fails, we will try "Method B"
+	 */
+	/* Issue Unlock sequence for AM29LV800D */
+ 	asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0xAAA), 0xAA);
+ 	asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x555), 0x55);
+
+	/* Issue the erase command */
+	asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0xAAA), 0x90);
+
+	manuf_id = asd_hwi_swb_read_byte(asd, nv_flash_bar);
+	dev_id_boot_blk = asd_hwi_swb_read_byte(asd, nv_flash_bar + 1);
+	sec_prot = asd_hwi_swb_read_byte(asd, nv_flash_bar + 2);
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "Flash MethodA manuf_id(0x%x) dev_id_boot_blk(0x%x) sec_prot(0x%x)\n",manuf_id,dev_id_boot_blk,sec_prot);
+#endif
+	if (asd_hwi_reset_nvram(asd) != 0) {
+		return (-1);
+	}
+
+	switch (manuf_id) {
+
+	case FLASH_MANUF_ID_AMD:
+
+		switch (sec_prot) {
+
+	   	case FLASH_DEV_ID_AM29LV800DT:
+	   	case FLASH_DEV_ID_AM29LV640MT:
+			asd->hw_profile.flash_method = FLASH_METHOD_A;
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case FLASH_MANUF_ID_ST:
+
+		switch (sec_prot) {
+
+	   	case FLASH_DEV_ID_STM29W800DT:
+			asd->hw_profile.flash_method = FLASH_METHOD_A;
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case FLASH_MANUF_ID_FUJITSU:
+
+		switch (sec_prot) {
+
+		case FLASH_DEV_ID_MBM29LV800TE:
+			asd->hw_profile.flash_method = FLASH_METHOD_A;
+			break;
+
+		}
+		break;
+
+	case FLASH_MANUF_ID_MACRONIX:
+
+		switch (sec_prot) {
+
+		case FLASH_DEV_ID_MX29LV800BT:
+			asd->hw_profile.flash_method = FLASH_METHOD_A;
+			break;
+		}
+		break;
+	}
+
+	if (asd->hw_profile.flash_method == FLASH_METHOD_UNKNOWN) {
+
+		if (asd_hwi_reset_nvram(asd) != 0) {
+			return (-1);
+		}
+
+		/* Issue Unlock sequence for AM29LV008BT */
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x555), 0xAA);
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x2AA), 0x55);
+
+		asd_hwi_swb_write_byte(asd, (nv_flash_bar + 0x555), 0x90);
+
+		manuf_id = asd_hwi_swb_read_byte(asd, nv_flash_bar);
+		dev_id_boot_blk = asd_hwi_swb_read_byte(asd, nv_flash_bar + 1);
+		sec_prot = asd_hwi_swb_read_byte(asd, nv_flash_bar + 2);
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "Flash MethodB manuf_id(0x%x) dev_id_boot_blk(0x%x) sec_prot(0x%x)\n",manuf_id,dev_id_boot_blk,sec_prot);
+#endif
+
+		if (asd_hwi_reset_nvram(asd) != 0) {
+			return (-1);
+		}
+
+		switch (manuf_id) {
+		case FLASH_MANUF_ID_AMD:
+
+			switch (dev_id_boot_blk) {
+
+		    	case FLASH_DEV_ID_AM29LV008BT:
+				asd->hw_profile.flash_method = FLASH_METHOD_B;
+				break;
+			default:
+				break;
+			}
+			break;
+
+		case FLASH_MANUF_ID_FUJITSU:
+
+			switch (dev_id_boot_blk) {
+
+			case FLASH_DEV_ID_MBM29LV008TA:
+				asd->hw_profile.flash_method = FLASH_METHOD_B;
+				break;
+
+			}
+			break;
+
+		default:
+			return -1;
+		}
+	}
+
+	switch (asd->hw_profile.flash_method)
+	{
+	case FLASH_METHOD_A:
+		return 0;
+
+	case FLASH_METHOD_B:
+		break;
+
+	default:
+		return -1;
+	}
+
+	asd->hw_profile.flash_manuf_id = manuf_id;
+	asd->hw_profile.flash_dev_id = dev_id_boot_blk;
+	asd->hw_profile.flash_wr_prot = sec_prot;
+	return 0;
+}
+#endif /* NVRAM_SUPPORT */
+
+int
+asd_hwi_control_activity_leds(struct asd_softc *asd, uint8_t phy_id, 
+			      uint32_t asd_phy_ctl_func)
+{
+	uint32_t	exsi_base_addr;
+	uint32_t	reg_contents;
+	uint32_t	reg_data;
+	
+//JD we support B0,B1...
+//	if (asd->hw_profile.rev_id != AIC9410_DEV_REV_B0) 
+//		return -EINVAL;
+
+	if (phy_id >= ASD_MAX_XDEVLED_BITS)
+		return -EINVAL;
+
+	reg_data = 0;
+
+	/* set the bit map corresponding to phy_id */
+	reg_data = (1 << phy_id);
+
+	/* Enable/Disable activity LED for the PHY */
+	exsi_base_addr = EXSI_REG_BASE_ADR + GPIOOER;
+	reg_contents = asd_hwi_swb_read_dword(asd, exsi_base_addr);
+
+	if (asd_phy_ctl_func == DISABLE_PHY) {
+		reg_contents &= ~reg_data;
+	} else {
+		if (asd_phy_ctl_func == ENABLE_PHY
+		   || asd_phy_ctl_func == ENABLE_PHY_NO_SAS_OOB
+		   || asd_phy_ctl_func == ENABLE_PHY_NO_SATA_OOB ) {
+			reg_contents |= reg_data;
+		}
+	}
+	asd_hwi_swb_write_dword(asd, exsi_base_addr, reg_contents);
+	
+	/* Set activity source to external/internal */
+	exsi_base_addr = EXSI_REG_BASE_ADR + GPIOCNFGR;
+	reg_contents = asd_hwi_swb_read_dword(asd, exsi_base_addr);
+
+	if (asd_phy_ctl_func == DISABLE_PHY) {
+		reg_contents &= ~reg_data;
+	} else {
+		if (asd_phy_ctl_func == ENABLE_PHY
+		   || asd_phy_ctl_func == ENABLE_PHY_NO_SAS_OOB
+		   || asd_phy_ctl_func == ENABLE_PHY_NO_SATA_OOB ) {
+			reg_contents |= reg_data;
+		}
+	}
+	asd_hwi_swb_write_dword(asd, exsi_base_addr, reg_contents);
+
+	return 0;
+}
+
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_hwi.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_hwi.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_hwi.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_hwi.h	2007-04-05 23:37:45.000000000 +0000
@@ -0,0 +1,1349 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ *
+ * Written by : David Chaw <david_chaw@adaptec.com>
+ * Modified by : Naveen Chandrasekaran <naveen_chandrasekaran@adaptec.com>
+ * 
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+
+#ifndef ADP94XX_HWI_H
+#define ADP94XX_HWI_H
+
+#include "adp94xx_sas.h"
+#include "adp94xx_reg.h"
+
+struct asd_softc;
+struct asd_platform_data;
+struct asd_target;
+struct asd_device;
+struct asd_conn_desc_format;
+struct asd_nd_phydesc_format;
+
+/* CHIP Revision ID */
+#define AIC9410_DEV_REV_A0	0
+#define AIC9410_DEV_REV_A1	1
+#define AIC9410_DEV_REV_B0	8
+#define AIC9410_DEV_REV_B1	9
+
+#define COMSTOCK_LATEST_RTL	26
+
+/* Controller profile */
+#define ASD_MAX_WWN_LEN		SAS_ADDR_LEN	/* World Wide Name size */
+
+#if SAS_COMSTOCK_SUPPORT
+#define ASD_MAX_PHYS		1		/* Max supported phys */
+#define ASD_MAX_PORTS		ASD_MAX_PHYS	/* Max supported ports */
+#else
+#define ASD_MAX_PHYS		8		/* Max supported phys */
+#define ASD_MAX_PORTS		ASD_MAX_PHYS	/* Max supported ports */
+#endif
+
+#define ASD_MAX_SCB_SITES	512		/*
+						 * Max supported built-in
+						 * SCB sites
+						 */
+#ifdef EXTENDED_SCB
+#define ASD_EXTENDED_SCB_NUMBER 512
+#endif
+#define ASD_RSVD_SCBS		11		/* Reserved SCBs */
+#define ASD_MAX_EDBS_PER_SCB	7		/* 
+						 * Max number of Empty
+						 * data buffers that can
+						 * be queued in a single SCB.
+						 */
+#define ASD_MAX_EDBS		21		/* 
+						 * Max number of Empty
+						 * data buffers.
+						 */
+
+/*
+ * There is a workaround fix required by the sequencer to skip
+ * using the free scb sites that ended with FF.
+ */ 
+static inline u_int
+asd_calc_free_scb_sites(u_int max_scbs)
+{
+	uint16_t	site_no;
+	u_int		usable_scb_sites;
+
+	usable_scb_sites = max_scbs;
+	for (site_no = 0; site_no < max_scbs; site_no++) {
+		if ((site_no & 0xF0FF) == 0x00FF)
+			usable_scb_sites--;
+#ifdef SATA_SKIP_FIX
+		if ((site_no & 0xF0FF) <= 0x001F)
+			usable_scb_sites--;
+#endif
+	}
+	return (usable_scb_sites);
+}
+
+#define ASD_USABLE_SCB_SITES	asd_calc_free_scb_sites(ASD_MAX_SCB_SITES)
+
+#ifndef EXTENDED_SCB
+#define ASD_MAX_ALLOCATED_SCBS	\
+	(ASD_USABLE_SCB_SITES - (ASD_MAX_EDBS/ASD_MAX_EDBS_PER_SCB))
+#else
+#define ASD_MAX_ALLOCATED_SCBS	\
+	(ASD_USABLE_SCB_SITES + ASD_EXTENDED_SCB_NUMBER - (ASD_MAX_EDBS/ASD_MAX_EDBS_PER_SCB))
+#endif
+
+#define ASD_MAX_USABLE_SCBS	ASD_USABLE_SCB_SITES
+
+/*
+ * Since an SES device may give device IDs to devices to be presented
+ * to the OS, we give "free" devices IDs which start at 128, and SES
+ * devices give device IDs which start at 0.
+ */
+#define ASD_MAX_TARGET_IDS      256
+#define ASD_MAX_DEVICES		128		/* Max supported devices */
+#define ASD_MAX_EXPANDERS	16		/* Max supported expanders */
+#define ASD_MAX_TARGETS		(ASD_MAX_DEVICES - ASD_MAX_EXPANDERS)
+#define ASD_MAX_DDBS		128		/* Max number of HW DDB sites */
+#define ASD_MIN_DLS		4		/* Minimum DL amount allowed */
+#define ASD_MAX_DLS		16384		/* Maximum DL amount allowed */
+#define ASD_SCB_SIZE		sizeof(union hardware_scb)
+#define ASD_DDB_SIZE		sizeof(struct asd_ddb)
+#define ASD_DL_SIZE		sizeof(struct asd_done_list)
+
+#define ASD_QDONE_PASS_DEF	1
+		 
+/* Controller Delay */
+#define ASD_DELAY_COUNT		5		/* Set to 5 microseconds */
+#define ASD_REG_TIMEOUT_VAL	2000
+#define ASD_REG_TIMEOUT_TICK	((ASD_REG_TIMEOUT_VAL * 1000) / ASD_DELAY_COUNT)
+ 
+/* Controller functionality */
+#define ASD_PIO_DOWNLOAD_SEQS	1		/* 
+						 * Download the SEQS code using
+						 * PIO mode.
+						 */		
+#define ASD_DMA_DOWNLOAD_SEQS	0		/*
+						 * Download the SEQS code using
+						 * Overlay DMA mode.
+						 */
+
+/* Tunable constant. */
+#define SAS_NOTIFY_TIMER_TIMEOUT_CONST	500	/* 
+						 * The default value 500 (in 
+						 * msecs) for time interval for
+						 * transmission interval between
+						 * successive NOTIFY 
+						 * (ENABLE_SPINUP) primitive.
+						 */
+
+/* Available activity LED bits in GPIOx registers */
+#define ASD_MAX_XDEVLED_BITS		8
+
+typedef enum {
+	SCB_EH_NONE 		= 0x0000,
+	SCB_EH_INITIATED	= 0x0001,
+	SCB_EH_IN_PROGRESS	= 0x0002,
+	SCB_EH_TIMEDOUT		= 0x0004,
+	SCB_EH_DONE		= 0x0008,
+	SCB_EH_ABORT_REQ	= 0x0010,
+	SCB_EH_LU_RESET_REQ	= 0x0020,
+	SCB_EH_DEV_RESET_REQ	= 0x0040,
+	SCB_EH_PORT_RESET_REQ	= 0x0080,
+	SCB_EH_CLR_NXS_REQ	= 0x0100,
+	SCB_EH_SUSPEND_SENDQ	= 0x0200,
+	SCB_EH_RESUME_SENDQ	= 0x0400,
+	SCB_EH_PHY_NO_OP_REQ	= 0x0800,
+	SCB_EH_PHY_REPORT_REQ	= 0x1000
+} scb_eh_state;
+
+#define SCB_EH_LEVEL_MASK	0x0FF0
+
+typedef enum {
+	SCB_EH_SUCCEED,
+	SCB_EH_FAILED
+} scb_eh_status;
+typedef enum {
+	SCB_FLAG_NONE		= 0x00,
+	SCB_ACTIVE		= 0x01,
+	SCB_DEV_QFRZN		= 0x02,
+	SCB_TIMEDOUT		= 0x04,
+	SCB_PENDING		= 0x08,
+	SCB_INTERNAL		= 0x10,
+	SCB_RECOVERY		= 0x20,
+	SCB_RESERVED		= 0x40,
+	SCB_ABORT_DONE		= 0x80
+} scb_flag;
+
+/* Data structures used to manage CSMI commands */
+struct asd_ctl_mgmt {
+	wait_queue_head_t	waitq;
+	struct semaphore 	sem;
+	struct timer_list 	timer;
+	u_long 			busy;
+	int 			err;
+};
+
+struct asd_ctl_internal_data {
+	struct asd_ctl_mgmt mgmt; 
+};
+
+typedef void asd_scb_post_t(struct asd_softc *, struct scb *,
+			    struct asd_done_list *);
+typedef void asd_scb_eh_post_t(struct asd_softc *, struct scb *);
+
+#define SCB_POST_STACK_DEPTH	5
+
+struct asd_scb_post_stack {
+	/*
+	 * Completion callback.
+	 */
+	asd_scb_post_t		*post;
+
+	/*
+	 * OS per I/O context structure.
+	 */
+	asd_io_ctx_t		 io_ctx;
+
+	/*
+	 * Timeout function for SCB (used internally)
+	 */
+	void			(*timeout_func)(u_long);
+};
+
+/*
+ * SCB buffer descriptor.  Contains HWI layer information
+ * pertaining to SCB data DMAed to and from the controller.
+ */
+struct scb {
+	/*
+	 * Links for chaining SCBs onto the pending, or free list.
+	 */
+	struct list_head	 hwi_links;
+	/*
+	 * Links for use by the owner (e.g. originator) of the SCB.
+	 */
+	struct list_head	 owner_links;
+	/*
+	 * Links for chaining SCBs onto the timedout SCB list.
+	 */
+	struct list_head	 timedout_links;
+	/*
+	 * Completion callback.
+	 */
+	asd_scb_post_t		*post;
+	/*
+	 * OS per I/O context structure.
+	 */
+	asd_io_ctx_t		 io_ctx;
+	/*
+	 * OSM specific, per-context data.
+	 */
+	struct asd_scb_platform_data *platform_data;
+	/*
+	 * Per-context, hardware specific, data that is
+	 * actually DMA'ed to the controller.
+	 */
+	union hardware_scb	*hscb;
+	struct map_node		*hscb_map;
+	dma_addr_t		 hscb_busaddr;
+	/*
+	 * Index to the Device Descriptor Block representing
+	 * the device to which this transaction is targeted.
+	 */
+	uint16_t		 conn_handle;
+	/*
+	 * Scatter/Gather list data structures.
+	 */
+	struct map_node		*sg_map;
+	struct sg_element	*sg_list;
+	dma_addr_t		 sg_list_busaddr;
+	u_int			 sg_count;
+	/*
+	 * Pointer back to our per-controller instance.
+	 * Used only in timer callbacks where the SCB
+	 * is the saved argument to the timer callback.
+	 */
+	struct asd_softc	*softc;
+	/*
+	 * Misc Flags.
+	 */
+	scb_flag		 flags;
+	/*
+	 * Error Recovery state and status info.
+	 */ 
+	scb_eh_state     	 eh_state;
+	scb_eh_status     	 eh_status;
+	asd_scb_eh_post_t	*eh_post;
+
+	uint32_t			post_stack_depth;
+	struct asd_scb_post_stack	post_stack[SCB_POST_STACK_DEPTH];
+
+	/* The following are used for DIY sent SCBs. */
+	u32 status;
+	struct asd_done_list *dl;
+};
+
+#define	SCB_GET_INDEX(SCB)	(asd_le16toh((SCB)->hscb->header.index))
+#define SCB_GET_OPCODE(SCB)	((SCB)->hscb->header.opcode)
+#define SCB_GET_SRC_PORT(SCB)	((SCB)->platform_data->targ->src_port)
+//JD
+#define	SCB_GET_SSP_TAG(SCB)	(asd_le16toh((SCB)->hscb->ssp_task.sas_header.tag))
+
+/* Common attributes for Phy and Port. */
+typedef enum {
+	ASD_SSP_INITIATOR	= 0x01,
+	ASD_SMP_INITIATOR 	= 0x02,
+	ASD_STP_INITIATOR 	= 0x04,
+	ASD_SATA_SPINUP_HOLD 	= 0x08,
+	ASD_SAS_MODE      	= 0x10,
+	ASD_SATA_MODE     	= 0x20,
+	ASD_DEVICE_PRESENT 	= 0x40 
+} asd_attrib;
+
+typedef enum {
+	ASD_IDLE	  	= 0x00,
+	ASD_RESP_PENDING  	= 0x01,
+	ASD_ID_ADDR_RCVD  	= 0x02,
+	ASD_DISCOVERY_REQ 	= 0x04,
+	ASD_DISCOVERY_PROCESS 	= 0x08,
+	ASD_DISCOVERY_EVENT 	= 0x10,
+	ASD_VALIDATION_REQ	= 0x20,
+	ASD_LOSS_OF_SIGNAL	= 0X40,
+	ASD_DISCOVERY_RETRY	= 0X80
+} asd_event;
+
+/*
+ * Port structure.
+ * It is used to reference a SCSI or SATA initiator port for the adapter.
+ */
+typedef enum {
+	ASD_PORT_UNUSED,
+	ASD_PORT_ONLINE,
+	ASD_PORT_OFFLINE
+} asd_port_state;
+
+struct discover_context {
+	struct asd_softc	*asd;
+	struct asd_port		*port;
+	uint8_t			 openStatus;
+	unsigned		 resid_len;
+//JD
+	unsigned		 retry_count;
+
+	/*
+	 * -------------------------------------
+	 * DMA-able memory used for SMP request
+	 */
+	struct SMPRequest	*SMPRequestFrame;
+	dma_addr_t		 SMPRequestBusAddr;
+	bus_dma_tag_t		 smp_req_dmat;
+	struct map_node		 smp_req_map;
+
+	/*
+	 * -------------------------------------
+	 * DMA-able memory used for SMP response
+	 */
+	struct SMPResponse	*SMPResponseFrame;
+	dma_addr_t		 SMPResponseBusAddr;
+	bus_dma_tag_t		 smp_resp_dmat;
+	struct map_node		 smp_resp_map;
+
+	/*
+	 * -------------------------------------
+	 * DMA-able memory used for Report LUNS and Unit Serial Number
+	 */
+	uint8_t			*SASInfoFrame;
+	dma_addr_t		 SASInfoBusAddr;
+	unsigned		 sas_info_len;
+	bus_dma_tag_t		 sas_info_dmat;
+	struct map_node		 sas_info_map;
+
+	/*
+	 * For state machine
+	 * -------------------------------------
+	 */
+	struct state_machine_context	sm_context;
+	struct timer_list		request_timer;
+};
+
+struct asd_port {
+	struct list_head	 phys_attached;
+	struct list_head	 targets;
+	struct list_head	 targets_to_validate;
+	void			*softc;
+	uint8_t			 sas_addr[SAS_ADDR_LEN];
+	uint8_t			 hashed_sas_addr[HASHED_SAS_ADDR_LEN];
+	uint8_t			 attached_sas_addr[SAS_ADDR_LEN];
+	u_char			 num_phys;
+	uint8_t			 conn_rate;
+	/* 
+	 * Bit field indicating which phy id belongs to this port.
+	 */  
+	uint8_t			 conn_mask;
+	uint8_t			 reset_mask;
+	u_char			 id;
+	asd_port_state		 state;
+	asd_attrib		 attr;
+	asd_event		 events;
+	LINK_TYPE		 link_type;
+	MANAGEMENT_TYPE		 management_type;
+	struct discover_context	 dc;
+	struct asd_target	*tree_root;
+};
+
+/*
+ * Phy structure.
+ * It is used to reference a service delivery subsystem for the adapter.
+ */
+typedef enum {
+	ASD_PHY_UNUSED,
+	ASD_PHY_WAITING_FOR_ID_ADDR,
+	ASD_PHY_ONLINE,
+	ASD_PHY_OFFLINE,
+	ASD_PHY_CONNECTED
+} asd_phy_state;
+
+#define PRODUCT_SERIAL_NUMBER_LEN	64
+
+struct asd_phy {
+	struct list_head	 pending_scbs;
+	struct list_head	 links;
+	void			*softc;
+    	struct asd_port		*src_port;
+	uint8_t			 sas_addr[SAS_ADDR_LEN];
+	u_int			 max_link_rate;
+	u_int			 min_link_rate;
+	u_int			 conn_rate;
+	uint8_t			 id;
+	asd_phy_state 		 state;
+	asd_attrib		 attr;
+	asd_event		 events;
+
+	/* Phy Error information. */
+	uint8_t			 brdcst_rcvd_cnt;
+
+	/* Phy control register info */
+	uint8_t			 phy_state;
+	uint8_t			 phy_ctl0;
+	uint8_t			 phy_ctl1;
+	uint8_t			 phy_ctl2;
+	uint8_t			 phy_ctl3;
+
+	/* Identify Address frame buffer. */
+	bus_dma_tag_t		 id_addr_dmat;
+	struct map_node		 id_addr_map;
+	union sas_bytes_dmaed	 bytes_dmaed_rcvd;
+
+	u_int			 link_rst_cnt;
+#define MAX_LINK_RESET_RETRY	 2
+
+	/* TBD: Temp var, should remove after checking with HW */
+	uint8_t			 pat_gen;
+};
+
+#define PHY_GET_ID_SAS_ADDR(PHY)	\
+	((PHY)->bytes_dmaed_rcvd.id_addr_rcvd.sas_addr)
+
+typedef enum {
+	ASD_IO_SPACE,
+	ASD_MEMORY_SPACE
+} asd_mem_space_type;
+
+struct asd_io_handle {
+	union {
+		uint8_t		*membase;
+		unsigned long	 iobase;
+	} baseaddr;
+	uint32_t		 bar_base; 
+	uint32_t		 length;
+	uint32_t		 swb_base;
+	uint8_t			 index;		/* BAR index */
+	asd_mem_space_type	 type;
+};
+
+struct asd_host_profile {
+	uint16_t		max_cmds_per_lun;
+	uint16_t		can_queue;
+	uint8_t			initiator_id;
+	uint8_t			max_luns;
+	unsigned int		max_scsi_ids;
+	uint8_t			max_channels;
+	uint8_t			irq;
+	uint8_t			unit;
+	uint8_t			dma64_addr;
+	dma_addr_t		dma_mask;
+	char			*name;
+};
+
+/*
+ * Controller specific information.
+ */
+struct asd_hw_profile {
+	/* HW info. */
+	uint8_t			wwn[ASD_MAX_WWN_LEN];
+	uint8_t			max_ports;
+	uint8_t			ports_allocated;
+	uint8_t			max_phys;
+	uint8_t			enabled_phys;
+	int			rev_id;
+	/* Target info. */
+	uint16_t		max_devices;
+	uint16_t		max_targets;
+	uint8_t			max_expanders;
+	/* Runtime info. */
+	uint16_t		max_scbs;
+	uint16_t		max_ddbs;
+	/* Queue info. */
+	uint16_t		scbpro_cnt;	
+	/* NVRAM info */
+	uint8_t			flash_present;
+	uint32_t		flash_method;
+	uint16_t		flash_manuf_id;
+	uint16_t		flash_dev_id;
+	uint32_t		flash_wr_prot;
+	u_char			nv_exist;
+	uint32_t		nv_cookie_addr;
+	u_int			nv_cookie_found;
+	uint32_t		nv_segment_type;
+	uint32_t		nv_flash_bar;
+	uint32_t		bios_bld_num;
+	uint8_t			bios_maj_ver;
+	uint8_t			bios_min_ver;
+
+	int   addr_range;
+	int   port_name_base;
+	int   dev_name_base;
+	int   sata_name_base;
+};
+
+typedef enum {
+	ASD_SCB_RESOURCE_SHORTAGE	= 0x01,
+	ASD_RUNNING_DONE_LIST		= 0x02,
+	ASD_WAITING_FOR_RESOURCE	= 0x04
+} asd_softc_flags;
+
+struct asd_softc {
+	/*
+	 * The next hardware SCB already known to the sequencer.
+	 */
+	union hardware_scb	*next_queued_hscb;
+	struct map_node		*next_queued_hscb_map;
+	uint64_t		 next_queued_hscb_busaddr;
+	/*
+	 * Pool of SCBs available to execute new commands.
+	 */
+	struct list_head	 free_scbs;
+	/*
+	 * Pool of reserved SCBS to be used for error recovery.
+         */	 
+	struct list_head	 rsvd_scbs;
+	/*
+	 * SCBs that have been sent to the controller
+	 */
+	struct list_head	 pending_scbs;
+	/*
+	 * Mapping from 16bit scb index to SCB.
+	 */
+	struct scb		**scbindex;
+	/*
+	 * Platform specific data.
+	 */
+	struct asd_platform_data *platform_data;
+	/* 
+	 * Command Queues info
+	 */
+	struct asd_done_list	*done_list;
+	uint16_t		 dl_next;
+	uint16_t		 dl_valid;
+	uint16_t		 dl_wrap_mask;
+	uint16_t		 qinfifonext;
+	uint16_t		*qinfifo;
+#define	ASD_QIN_WRAP(asd) ((asd)->qinfifonext & (asd->hw_profile.max_scbs - 1))
+
+	/*
+	 * Free Device Descriptor Block bitmap.
+	 */
+	u_long			*free_ddb_bitmap;
+	u_int			 ddb_bitmap_size;
+#define ASD_INVALID_DDB_INDEX 0xFFFF
+
+	/*
+	 * Misc controller state flags.
+	 */
+	asd_softc_flags		 flags;
+	/*
+	 * SCBs whose timeout routine has been called.
+	 */
+	struct list_head	 timedout_scbs;
+	/*
+	 * SCBs that have been sent to the controller
+	 */
+	struct list_head	 empty_scbs;
+	/*
+	 * "Bus" addresses of our data structures.
+	 */
+	bus_dma_tag_t	 	 shared_data_dmat;
+	struct map_node	 	 shared_data_map;
+	
+	/* dmat for our hardware SCB array */
+	bus_dma_tag_t	 	 hscb_dmat;
+	/* dmat for our sg segments */
+	bus_dma_tag_t	 	 sg_dmat;
+	struct list_head 	 hscb_maps;
+	struct list_head 	 sg_maps;
+	/* Unallocated scbs in head map_node */
+	int		 	 scbs_left;
+	/* Unallocated sgs in head map_node */
+	int			 sgs_left;	
+	/* Allocated edbs */
+	int		 	 edbs;	
+	uint16_t	 	 numscbs;
+	/*
+	 * Platform specific device information.
+	 */
+	asd_dev_t		 dev;
+	/*
+	 * Used to chain all controller instances
+	 * managed by this driver.
+	 */
+	struct list_head	 link;
+	struct list_head	*old_discover_listp;
+	struct list_head	*discover_listp;
+	struct asd_port		*port_list[ASD_MAX_PORTS];
+	struct asd_phy		*phy_list[ASD_MAX_PHYS];
+	struct asd_host_profile  profile;
+	struct asd_hw_profile	 hw_profile;
+	const struct pci_device_id *pci_entry;
+	struct asd_io_handle	**io_handle;
+	struct asd_ctl_internal_data asd_ctl_internal;
+	uint32_t		 asd_hba_index;
+	uint8_t			 io_handle_cnt;
+	uint8_t			 init_level;
+
+	unsigned		 num_discovery;
+	unsigned		 num_unit_elements;
+	struct asd_unit_element_format	*unit_elements;
+#ifdef ASD_DEBUG
+	unsigned		 debug_flag;
+#endif
+#ifdef EXTENDED_SCB
+	struct map_node		ext_scb_map;
+	bus_dma_tag_t		ext_scb_dmat;
+#endif
+};
+
+
+/* Scatter/Gather list Handling */
+#define	asd_sglist_size(asd) (ASD_NSEG * sizeof(struct sg_element))
+
+
+/*
+ * Hardware Interface functions prototypes.
+ */
+void		asd_intr_enable(struct asd_softc *asd, int enable);
+int		asd_hwi_init_hw(struct asd_softc *asd);
+int		asd_hwi_process_irq(struct asd_softc *asd);
+struct asd_softc * asd_alloc_softc(asd_dev_t dev);
+void		asd_free_softc(struct asd_softc *asd);
+
+/* 
+ * Device Descriptor Block resource management. 
+ */
+uint16_t	asd_alloc_ddb(struct asd_softc *asd);
+void		asd_free_ddb(struct asd_softc *asd, uint16_t ddb_index);
+int		asd_hwi_setup_ddb_site(struct asd_softc *asd,
+				       struct asd_target *target);
+
+/* 
+ * Function prototypes for interfacing with Sequencers. 
+ */
+int		asd_hwi_pause_cseq(struct asd_softc *asd);
+int		asd_hwi_pause_lseq(struct asd_softc *asd, uint8_t lseq_mask);
+int		asd_hwi_unpause_cseq(struct asd_softc *asd);
+int		asd_hwi_unpause_lseq(struct asd_softc *asd, uint8_t lseq_mask);
+int		asd_hwi_download_seqs(struct asd_softc *asd);
+void		asd_hwi_setup_seqs(struct asd_softc *asd);
+int		asd_hwi_start_cseq(struct asd_softc *asd);
+int		asd_hwi_start_lseq(struct asd_softc *asd, uint8_t link_num);
+struct scb *	asd_hwi_get_scb(struct asd_softc *asd, int rsvd_pool);
+void		asd_hwi_post_scb(struct asd_softc *asd, struct scb *scb);
+union edb *	asd_hwi_indexes_to_edb(struct asd_softc *asd, struct scb **pscb,
+				       u_int escb_index, u_int edb_index);
+void		asd_hwi_free_edb(struct asd_softc  *asd,
+				 struct scb *scb, int edb_index);
+void		asd_hwi_init_internal_ddb(struct asd_softc *asd);
+void		asd_hwi_init_ddb_sites(struct asd_softc *asd);
+void		asd_hwi_build_ddb_site(struct asd_softc  *asd, 
+				      struct asd_target *target);
+void		asd_hwi_update_sata(struct asd_softc *asd, 
+				      struct asd_target *target);
+void		asd_hwi_update_conn_mask(struct asd_softc *asd,
+					 struct asd_target *target);
+int		asd_hwi_enable_phy(struct asd_softc *asd, struct asd_phy *phy);
+void		asd_hwi_release_sata_spinup_hold(struct asd_softc *asd,
+						 struct asd_phy *phy);
+
+/*
+ * Error handling function prototypes.
+ */
+int		asd_hwi_post_eh_scb(struct asd_softc *asd, struct scb *scb);
+void		asd_hwi_build_ssp_tmf(struct scb *scb, struct asd_target *targ,
+				      uint8_t *lun, u_int tmf_opcode);
+void		asd_hwi_build_clear_nexus(struct scb *scb, u_int nexus_ind,
+					  u_int parm, u_int context);
+void		asd_hwi_build_abort_task(struct scb *scb,
+					 struct scb *scb_to_abort);
+void		asd_hwi_build_query_task(struct scb *scb, 
+					 struct scb *scb_to_query);
+void		asd_hwi_build_control_phy(struct scb *scb, struct asd_phy *phy, 
+					  uint8_t sub_func);
+void		asd_hwi_map_tmf_resp(struct scb *scb, u_int resp_code);
+
+/* SCB build routines */
+void 		asd_hwi_build_smp_task(struct scb *scb, struct asd_target *targ,
+				       uint64_t req_bus_addr, u_int req_len,
+				       uint64_t resp_bus_addr, u_int resp_len);
+void 		asd_hwi_build_ssp_task(struct scb *scb, struct asd_target *targ,
+					uint8_t *saslun, uint8_t *cdb,
+					uint32_t cdb_len, uint8_t addl_cdb_len,
+				       	uint32_t data_len);
+void 		asd_hwi_build_stp_task(struct scb *scb, struct asd_target *targ,
+				       uint32_t data_len);
+
+int 		asd_hwi_get_nv_conn_info(struct asd_softc *asd, uint8_t **pconn,
+					 uint32_t *pconn_size, uint8_t **pnoded,
+					 uint32_t *pnoded_size);
+
+int 		asd_hwi_control_activity_leds(struct asd_softc *asd,
+					      uint8_t phy_id,
+					      uint32_t asd_phy_ctl_func);
+
+int		asd_hwi_search_nv_segment(struct asd_softc *asd, 
+					  u_int segment_id, uint32_t *offset,
+					  uint32_t *pad_size, 
+					  uint32_t *image_size, 
+					  uint32_t *attr);
+int 		asd_hwi_write_nv_segment(struct asd_softc *asd,
+					void *src, u_int segment_id, 
+					uint32_t dest_offset, 
+					uint32_t bytes_to_write);
+
+int asd_hwi_read_nv_segment(struct asd_softc *asd, uint32_t segment_id, 
+					void *dest, uint32_t src_offset, 
+					uint32_t bytes_to_read,
+					uint32_t *bytes_read);
+
+ 
+/* Debug function prototypes. */
+#ifdef ASD_DEBUG
+void	asd_hwi_dump_seq_state(struct asd_softc *asd, uint8_t lseq_mask);
+#ifdef SEQUENCER_UPDATE
+void	asd_hwi_dump_sata_stp_ddb_site(struct asd_softc *asd, u_int site_no);
+void	asd_hwi_dump_ssp_smp_ddb_site(struct asd_softc *asd, u_int site_no);
+#else
+void	asd_hwi_dump_ddb_site(struct asd_softc *asd, u_int site_no);
+#endif
+#endif
+void asd_hwi_dump_ddb_site_raw(struct asd_softc *asd, uint16_t site_no);
+void asd_hwi_dump_ddb_sites_raw(struct asd_softc *asd);
+void asd_hwi_dump_scb_site_raw(struct asd_softc *asd, uint16_t site_no);
+void asd_hwi_dump_scb_sites_raw(struct asd_softc *asd);
+
+#ifdef SEQUENCER_UPDATE
+struct asd_step_data {
+	struct asd_softc	*asd;
+	struct timer_list	single_step_timer;
+	unsigned		instruction_count;
+	unsigned		lseq_trace;
+	unsigned		stepping;
+	unsigned		link_num;
+};
+
+struct asd_step_data	*asd_hwi_alloc_step(struct asd_softc *asd);
+void			asd_hwi_free_step(struct asd_step_data *step_datap);
+int			asd_hwi_cseq_init_step(
+				struct asd_step_data *step_datap);
+int			asd_hwi_lseq_init_step(
+				struct asd_step_data *step_datap,
+				unsigned link_num);
+void			asd_hwi_start_step_timer(
+				struct asd_step_data *step_datap);
+#endif
+
+void asd_hwi_set_ddbptr(struct asd_softc *asd, uint16_t val);
+void asd_hwi_set_cseq_breakpoint(struct asd_softc *asd, uint16_t addr);
+#if 0
+void asd_hwi_set_lseq_breakpoint(struct asd_softc *asd, int phy_id,
+	uint16_t addr);
+#else
+void asd_hwi_set_lseq_breakpoint(struct asd_softc *asd, int phy_id, 
+	uint32_t breakid, uint16_t addr);
+#endif
+
+#if ASD_PIO_DOWNLOAD_SEQS
+/* PIO Mode */
+int		asd_hwi_pio_load_seqs(struct asd_softc *asd, uint8_t *code,
+				      uint32_t code_size, uint8_t lseq_mask);
+				      
+#define ASD_HWI_DOWNLOAD_SEQS(asd, code, code_size, lseq_mask)		\
+		asd_hwi_pio_load_seqs(asd, (uint8_t *) code,		\
+				     (uint32_t) code_size, (uint8_t) lseq_mask)	
+#else 
+/* Overlay DMA Mode */
+int		asd_hwi_dma_load_seqs(struct asd_softc *asd, uint8_t *code,
+				      uint32_t code_size, uint8_t lseq_mask);
+
+#define ASD_HWI_DOWNLOAD_SEQS(asd, code, code_size, lseq_mask)		\
+		asd_hwi_dma_load_seqs(asd, (uint8_t *) code,		\
+				     (uint32_t) code_size, (uint8_t) lseq_mask)
+
+#endif /* ASD_DMA_DOWNLOAD_SEQS */
+
+
+/********** External Memory (NVRAM, SEEPROM, etc) strucutres layout ***********/
+
+#define NVRAM_SUPPORT			1
+
+#if NVRAM_SUPPORT
+
+#define NVRAM_RESET			0xF0
+#define NVRAM_NO_SEGMENT_ID		0xFF
+#define NVRAM_INVALID_SIZE		0xFFFFFFFF
+#define NVRAM_COOKIE_SIZE		0x20
+#define NVRAM_FIRST_DIR_ENTRY		0x90
+#define NVRAM_NEXT_ENTRY_OFFSET		0x2000
+#define NVRAM_MAX_ENTRIES		0x20
+#define NVRAM_SEGMENT_ATTR_ERASEWRITE	1
+
+/* NVRAM Entry Type Values. */
+#define NVRAM_FLASH_DIR			0x00000000
+#define NVRAM_BIOS_CORE			0x00000020
+#define NVRAM_BIOS_UTILS		0x00000040
+#define NVRAM_BIOS_CHIM			0x00000060
+#define NVRAM_CTRL_A_SETTING		0x000000E0
+#define NVRAM_CTRL_A_DEFAULT		0x00000100
+#define NVRAM_MANUF_TYPE		0x00000120
+
+
+#define SAS_ADDR_WWID_MASK		0xF0
+
+/* OCM directory entry format */
+struct asd_ocm_entry_format {
+	uint8_t		type;
+#define OCM_DE_OCM_DIR			0x00
+#define OCM_DE_WIN_DRVR			0x01
+#define OCM_DE_BIOS_CHIM		0x02
+#define OCM_DE_RAID_ENGN		0x03
+#define OCM_DE_BIOS_INTL		0x04
+#define OCM_DE_BIOS_CHIM_OSM		0x05
+#define OCM_DE_BIOS_CHIM_DYNAMIC	0x06
+#define OCM_DE_ADDC2C_RES0		0x07
+#define OCM_DE_ADDC2C_RES1		0x08
+#define OCM_DE_ADDC2C_RES2		0x09
+#define OCM_DE_ADDC2C_RES3		0x0A
+
+	uint8_t		offset[3];
+/* retrieves offset/size from the 3 byte array */
+#define OCM_DE_OFFSET_SIZE_CONV(x) ((x[2] << 16) | (x[1] << 8) | x[0])
+
+	uint8_t		res1;
+	uint8_t		size[3];
+} __packed;
+
+/* OCM directory format */
+struct asd_ocm_dir_format {
+	/* 'O'n-chip memory 'D'irectory */
+	uint16_t	signature;	
+
+#define OCM_DIR_SIGN 0x4F4D
+	
+#if 0
+	uint16_t	res1;
+#else
+	uint8_t		res1a;
+	uint8_t		res1b;
+#endif
+	uint8_t		maj_ver;
+	uint8_t		min_ver;
+	uint8_t		res2;
+	uint8_t		num_entries;
+#define OCM_NUM_ENTRIES_MASK	0x0f
+
+	//struct asd_ocm_entry_format entry[1];
+} __packed;
+
+#if 0
+//TBD: check and remove
+struct asd_unit_id_direct_attached_sata {
+	uint8_t		phy_id;
+	uint8_t		res[15];
+} __packed;
+
+struct asd_unit_id_logical_unit {
+	uint8_t		sas_address[SAS_ADDR_LEN];
+	uint8_t		lun[8];
+} __packed;
+
+struct asd_unit_id_volume_set {
+	uint8_t		volume_set_uid[8];
+	uint8_t		res[8];
+} __packed;
+
+/* unit element */
+struct asd_unit_element_format {
+	uint8_t		id[16];
+#define UNIT_ELEMENT_DIRECT_ATTACHED_SATA	0x00
+#define UNIT_ELEMENT_LOGICAL_UNIT		0x01
+#define UNIT_ELEMENT_VOLUME_SET			0x02
+	uint8_t		type;
+	uint8_t		res1;
+	uint8_t		dos_drv_num;
+	uint8_t		removable;
+	uint32_t	res2;
+} __packed;
+#endif
+
+struct asd_uid_lu_naa_wwn {
+	uint8_t		naa;
+	/* length specified by unit_id_len */
+} __packed;
+
+struct asd_uid_lu_sata_model_num {
+	uint32_t	id; /* "ata." */
+#define UNITID_SATA_ID 0x6174612E
+
+	uint8_t		model[40];
+	uint8_t		serial[20];
+	uint32_t	null_data;
+	/* length specified by unit_id_len */
+} __packed;
+
+
+struct asd_uid_vol_set {
+#define UNITID_VOLUME_SET_UID_LEN	24
+	uint8_t		vol_set_uid[UNITID_VOLUME_SET_UID_LEN];
+	/* length specified by unit_id_len */
+} __packed;
+
+struct asd_uid_lu_sgpio {
+	uint8_t		conn_idx;
+	uint8_t		box_id;
+	uint8_t		bay_id;
+	uint32_t	res1[5];
+	uint8_t		lun[8];
+	/* length specified by unit_id_len */
+} __packed;
+
+struct asd_uid_lu_sas_topology {
+	uint8_t		exp_dev_name[8];
+	uint8_t		lun[8];
+	uint8_t		phy_id;
+	/* length specified by unit_id_len */
+} __packed;
+
+/* unit element */
+struct asd_unit_element_format {
+	uint8_t		id;
+#define UNITELEM_LU_NAA_WWN		0x00
+#define UNITELEM_LU_SATA_MOD_SERIAL_NUM	0x01
+#define UNITELEM_VOLUME_SET_DDF_GUID	0x02
+#define UNITELEM_LU_SGPIO		0x03
+#define UNITELEM_LU_SAS_TOPOLOGY	0x04
+
+	uint8_t		dos_drv_num;
+	uint8_t		removable_unit;
+#define UNITELEM_REMOVABLE_UNIT_MASK 	0x01
+
+	uint32_t	res1;
+	uint8_t		unit_id_len;
+	uint8_t		res2[8];
+} __packed;
+
+/* BIOS CHIM section */
+struct asd_bios_chim_format {
+	uint32_t	signature;	/* 'BIOS' or 'ASPI' */
+#define OCM_BC_BIOS_SIGN 0x42494F53
+#define OCM_BC_ASPI_SIGN 0x41535049
+
+	uint8_t		maj_ver;	/* 0x01 */
+	uint8_t		min_ver;	/* 0x00 */
+	uint8_t		bios_maj_ver;
+	uint8_t		bios_min_ver;
+	uint32_t	bios_bld_num;
+	uint8_t		bios_present;
+#define OCM_BC_BBS_MASK		0x04
+#define OCM_BC_BIOS_INSLD_MASK	0x02
+#define OCM_BC_BIOS_PRSNT_MASK	0x01
+	
+	uint8_t		pci_slot_num;
+	uint16_t	num_elements;
+	uint16_t	size_unit_elem;
+	uint8_t		res1[14];	
+	struct asd_unit_element_format unit_elm[1];
+} __packed;
+
+/* 
+ * These macros take a 8 byte base SAS address and get/set 
+ * it's constituent elements. 
+ */
+
+/* Default: 0x5 */
+#define ASD_BSAR_GET_NAA(x) 	((x[0] >> 4) & 0x0f)
+
+/* Default: 0x0000D1 - 3 byte IEEE Id assigned to Adaptec */
+#define ASD_BSAR_GET_IEEE_ID(x) \
+(((x[0] & 0x0f) << 20) | (x[1] << 12) | (x[2] << 4) | ((x[3] >> 4) & 0x0f)) 
+
+/* get the 4 byte Razor serial number */
+#define ASD_BSAR_GET_SN(x) \
+(((x[3] & 0x0f) << 28) | (x[4] << 20) | (x[5] << 12) \
+| (x[6] << 4) | (((x[7] >> 5) & 0x07) << 1)) 
+
+/*Default: 00000b - configurable using Ctrl-A */
+#define ASD_BSAR_GET_LSB(x) 	(x[7] & 0x1f)
+#define ASD_BSAR_SET_LSB(x, y) 	(x[7] = ((x[7] & 0x1f) & (y & 0x1f)))
+
+struct asd_manuf_seg_sign {
+	uint16_t	signature;
+#define NVRAM_MNF_BASE_SEG_SIGN	 0x4D53	/* 'M'anufacturing 'S'egment */
+#define NVRAM_MNF_PHY_PARAM_SIGN 0x4D50	/* 'M'anufacturing 'P'hy Parameters */
+#define NVRAM_MNF_CONN_MAP	 0x434D	/* 'C'onnector 'M'ap */
+
+	uint16_t	next_seg_ptr;
+} __packed;
+
+/* Manufacturing Base Segment Layout. */
+struct asd_manuf_base_seg_layout {
+	struct asd_manuf_seg_sign seg_sign;
+	uint8_t		major_ver;	/* 0x00 */
+	uint8_t		minor_ver;	/* 0x00 */
+	uint16_t	checksum;
+	uint16_t	sector_size;
+	uint8_t		res1[6];
+	uint8_t		base_sas_addr[8];
+	uint8_t		pcba_sn[12];
+} __packed;
+
+/* Phy Descriptor sub structure */
+struct asd_phy_desc_format {
+	uint8_t		state;
+#define NVRAM_PHY_ENABLEABLE		0x00
+#define NVRAM_PHY_REPORTED		0x01
+#define NVRAM_PHY_HIDDEN		0x02
+#define PHY_STATE_MASK			0x0F
+#define PHY_STATE_DEFAULT		NVRAM_PHY_ENABLEABLE
+
+	uint8_t		phy_id;
+	uint16_t	res1;
+	uint8_t		ctl0;
+#define PHY_CTL0_DEFAULT		0xF6
+#define PHY_CTL0_MASK			0x1C
+	
+	uint8_t		ctl1;
+#define PHY_CTL1_DEFAULT		0x10
+
+	uint8_t		ctl2;
+#define PHY_CTL2_DEFAULT		0x43
+
+	uint8_t		ctl3;
+#define PHY_CTL3_DEFAULT		0x83
+
+} __packed;
+
+/* Manufacturing Phy Parameters Layout */
+struct asd_manuf_phy_param_layout {
+	struct asd_manuf_seg_sign seg_sign;
+	uint8_t		major_ver;	/* 0x00 */
+	uint8_t		minor_ver;	/* 0x02 */
+	uint8_t		num_phy_desc;	/* 0x08 */
+	uint8_t		phy_desc_size;	/* 0x08 */
+	uint8_t		res1[3];
+	uint8_t		usage_model_id;
+	uint8_t		res2[4];
+} __packed;
+
+
+/* Phy Descriptor Unattached Layout */
+struct asd_pd_ua_format {
+	uint16_t	res1;
+	uint8_t		rel_phy_id;
+	/* size is specified by the node_desc format */
+} __packed;
+
+/* Phy Descriptor connector attached Layout */
+struct asd_pd_ca_format {
+	uint8_t		idx;
+	uint8_t		lane;
+	uint8_t		rel_phy_id;
+	/* size is specified by the node_desc format */
+} __packed;
+
+/* Phy Descriptor node attached Layout */
+struct asd_pd_na_format {
+	uint8_t		idx;
+	uint8_t		att_phy_id;
+	uint8_t		rel_phy_id;
+	/* size is specified by the node_desc format */
+} __packed;
+
+/* Node descriptor's Phy descriptor entries */
+struct asd_nd_phydesc_format {
+	uint8_t		type;
+#define NV_PD_UATTACH		0x00
+#define NV_PD_CONATTACH		0x01
+#define NV_PD_NODEATTACH	0x02
+
+	union {
+		struct asd_pd_ua_format uatt;
+		struct asd_pd_ca_format catt;
+		struct asd_pd_na_format natt;
+	}att_type;
+} __packed;
+
+/* Node Descriptor Layout */
+struct asd_node_desc_format {
+	uint8_t		type;
+#define NV_NODET_IOP		0x00
+#define NV_NODET_IOCTLR		0x01
+#define NV_NODET_EXPANDER	0x02
+#define NV_NODET_PORT_MUL	0x03
+#define NV_NODET_PORT_MUX	0x04
+#define NV_NODET_PORT_MDI2C_BUS	0x05
+
+	uint8_t		num_phy_desc;
+	uint8_t		phy_desc_size;
+	uint8_t		res1;
+
+#define NV_NODED_INST_NAME_SIZE 16
+	uint8_t		inst_name[NV_NODED_INST_NAME_SIZE];
+} __packed;
+
+/* SideBand Descriptor Layout */
+struct asd_sb_desc_format {
+	uint8_t		type;
+#define NV_SBT_UNKNOWN		0x00
+#define NV_SBT_SGPIO		0x01
+#define NV_SBT_ADPTI2C		0x80
+#define NV_SBT_VEN_UNQ01	0x81
+#define NV_SBT_VEN_UNQ7F	0xFF
+
+	uint8_t		node_desc_idx;
+	uint8_t		conn_desc_idx;
+	uint8_t		res1;
+	/* size is specified by the conn_desc format */
+} __packed;
+
+/* Connector Descriptor Layout */
+struct asd_conn_desc_format {
+	uint8_t		type;
+#define NV_CONNT_UNKNOWN	0x00
+#define NV_CONNT_SFF8470	0x08
+#define NV_CONNT_SFF8482	0x09
+#define NV_CONNT_SFF8484	0x0A
+#define NV_CONNT_PCIX_D0	0x80
+#define NV_CONNT_SAS_D0		0x81
+#define NV_CONNT_VEN_UNQ02	0x82
+#define NV_CONNT_VEN_UNQ7F	0xFF
+
+	uint8_t		location;
+#define NV_CONNL_UNKNOWN	0x00
+#define NV_CONNL_INTERNAL	0x01
+#define NV_CONNL_EXTERNAL	0x02
+#define NV_CONNL_B2B		0x03
+
+	uint8_t		num_sb_desc;
+	uint8_t		sb_desc_size;
+	uint32_t	res1;
+
+#define NV_CONND_INST_NAME_SIZE 16
+	uint8_t		inst_name[NV_CONND_INST_NAME_SIZE];
+} __packed;
+
+/* Connector Map Layout */
+struct asd_conn_map_format {
+	struct asd_manuf_seg_sign seg_sign;
+	uint8_t		major_ver;	/* 0x00 */
+	uint8_t		minor_ver;	/* 0x00 */
+	uint16_t	size;
+	uint8_t		num_conn_desc;
+	uint8_t		conn_desc_size;
+	uint8_t		num_node_desc;
+	uint8_t		usage_model_id;
+	uint32_t	res1;
+} __packed;
+
+struct asd_settings_layout {
+	uint8_t		id;
+#define NVRAM_PHY_SETTINGS_ID   	0x68
+#define NVRAM_BOOT_UNIT_SETTINGS_ID 	0x42
+#define NVRAM_BOOTLUN_SETTINGS_ID 	0x4c
+
+	uint8_t		res;
+	uint16_t	next_ptr;
+} __packed;
+
+
+/*
+ * The size of Flash directory structure must be 64 bytes for backward
+ * compatibility.
+ */
+struct asd_fd_entry_layout {
+	uint32_t	attr;
+#define FD_ENTRYTYPE_CODE	0x3FFFFFFF
+#define FD_SEGMENT_ATTR		0x40000000
+
+	uint32_t	offset;
+	uint32_t	pad_size;
+	uint32_t	image_size;
+	uint32_t	checksum;
+	uint8_t		res[12];
+	uint8_t		ver_data[32];
+} __packed;
+
+struct asd_flash_dir_layout {
+	
+	uint8_t		cookie[32];	/* "*** ADAPTEC FLASH DIRECTORY *** " */
+	uint32_t	rev;		/* 0x00000002 */
+	uint32_t	wchk_sum;
+	uint32_t	wchk_sum_antidote;
+	uint32_t	build_num;
+	uint8_t		build_id[32];
+	uint8_t		ver_data[32];
+	uint32_t	ae_mask;
+	uint32_t	v_mask;
+	uint32_t	oc_mask;
+	uint8_t		res1[20];
+	//struct asd_fd_entry_layout entry[1];
+} __packed;
+
+struct asd_phy_settings_entry_layout {
+	uint8_t		sas_addr[SAS_ADDR_LEN];
+	uint8_t		link_rate;		/*
+						 * bits 0-3: minimum link rate
+						 * bits 4-7: maximum link rate
+						 */
+#define PHY_MIN_LINK_RATE_15	0x08
+#define PHY_MIN_LINK_RATE_30	0x09
+#define PHY_MIN_LINK_RATE_MASK	0x0F
+
+#define PHY_MAX_LINK_RATE_15	0x80
+#define PHY_MAX_LINK_RATE_30	0x90
+#define PHY_MAX_LINK_RATE_MASK	0xF0
+
+	uint8_t		attr;			/*
+						 * bit 0: disable CRC checking
+						 * bit 1: SATA spinup hold
+						 */
+	uint8_t		res1[6];
+} __packed;
+    
+struct asd_phy_settings_layout {
+	struct asd_settings_layout settings;
+	uint8_t		num_phys;
+	uint8_t		res2[3];
+	//struct asd_phy_settings_entry_layout entry[1];
+} __packed;
+
+struct asd_boot_lu_layout {
+	uint8_t		serial_no[4];		/* Adapter serial number */
+	/* Boot device's SAS address */
+	uint8_t		dev_port_sas_addr[SAS_ADDR_LEN];
+	uint8_t		lun[8];			/* Boot device LUN */
+	uint8_t		phy_id;			/*
+						 * Phy ID of the attached boot
+						 * device (direct attached
+						 * SATA only).
+						 */
+	uint8_t		res1;
+	uint16_t	attr;
+	uint8_t		conn_rate;		/*
+						 * bit   0: force connection
+						 * bit 4-7: connection rate
+						 */
+#define BOOT_FORCE_CONN 	0x01
+#define BOOT_CONN_RATE_15	0x80
+#define BOOT_CONN_RATE_30	0x90
+#define BOOT_CONN_RATE_MASK	0xF0
+
+	uint8_t		res2[7];
+} __packed;
+    
+struct asd_pci_layout {
+	uint8_t		id;
+	uint8_t		res;
+	uint16_t	next_ptr;
+	uint8_t		major_ver;
+	uint8_t		minor_ver;
+	uint16_t	checksum;
+	uint16_t	image_size;
+} __packed;
+
+/************************ Flash part related macros ***********************/
+
+enum {
+	FLASH_METHOD_UNKNOWN,
+	FLASH_METHOD_A,
+	FLASH_METHOD_B
+};
+
+#define FLASH_MANUF_ID_AMD		0x01
+#define FLASH_MANUF_ID_ST		0x20
+#define FLASH_MANUF_ID_FUJITSU		0x04
+#define FLASH_MANUF_ID_MACRONIX		0xC2
+#define FLASH_MANUF_ID_UNKNOWN		0xFF
+
+#define FLASH_DEV_ID_AM29LV008BT	0x3E
+#define FLASH_DEV_ID_AM29LV800DT	0xDA
+#define FLASH_DEV_ID_STM29W800DT	0xD7
+#define FLASH_DEV_ID_MBM29LV800TE	0xDA
+#define FLASH_DEV_ID_MBM29LV008TA	0x3E
+#define FLASH_DEV_ID_AM29LV640MT	0x7E
+#define FLASH_DEV_ID_MX29LV800BT	0xDA
+#define FLASH_DEV_ID_UNKNOWN		0xFF
+
+/* status bit mask values */
+#define FLASH_STATUS_BIT_MASK_DQ6	0x40
+#define FLASH_STATUS_BIT_MASK_DQ5	0x20
+#define FLASH_STATUS_BIT_MASK_DQ2	0x04
+
+/* minimum value in micro seconds needed for checking status */
+#define FLASH_STATUS_ERASE_DELAY_COUNT	50
+#define FLASH_STATUS_WRITE_DELAY_COUNT	25
+
+#endif /* NVRAM_SUPPORT */
+
+#endif /* ADP94XX_HWI_H */
+
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_inline.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_inline.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_inline.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_inline.h	2007-04-05 23:37:45.000000000 +0000
@@ -0,0 +1,1150 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ *
+ * Written by : David Chaw  <david_chaw@adaptec.com>
+ *
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */
+
+#ifndef ADP94XX_INLINE_H
+#define ADP94XX_INLINE_H
+
+
+/******************************* Locking routines *****************************/
+
+static inline void 	asd_lock_init(struct asd_softc *asd);
+static inline void 	asd_lock(struct asd_softc *asd, u_long *flags);
+static inline void 	asd_unlock(struct asd_softc *asd, u_long *flags);
+
+/* Locking routines during midlayer entry points */
+static inline void 	asd_sml_lock(struct asd_softc *asd);
+static inline void 	asd_sml_unlock(struct asd_softc *asd);
+
+/* Locking routine during list manipulation */
+extern spinlock_t asd_list_spinlock;
+static inline void 	asd_list_lockinit(void);
+static inline void 	asd_list_lock(u_long *flags);
+static inline void 	asd_list_unlock(u_long *flags);
+
+static inline void
+asd_lock_init(struct asd_softc  *asd)
+{
+	spin_lock_init(&asd->platform_data->spinlock);
+}
+
+static inline void
+asd_lock(struct asd_softc *asd, u_long *flags)
+{
+#if 0
+if(asd->debug_flag ==1)
+{
+	asd_log(ASD_DBG_INFO, "asd lock\n");
+}
+#endif
+	spin_lock_irqsave(&asd->platform_data->spinlock, *flags);
+}
+
+static inline void
+asd_unlock(struct asd_softc *asd, u_long *flags)
+{
+#if 0
+if(asd->debug_flag ==1)
+{
+	asd_log(ASD_DBG_INFO, "asd Unlock\n");
+}
+#endif
+	spin_unlock_irqrestore(&asd->platform_data->spinlock, *flags);
+}
+
+#ifdef CONFIG_SMP
+#define ASD_LOCK_ASSERT(asd) \
+	ASSERT(spin_is_locked(&asd->platform_data->spinlock))
+#else
+#define ASD_LOCK_ASSERT(asd)
+#endif
+
+static inline void 
+asd_sml_lock(struct asd_softc *asd)
+{
+#if (SCSI_ML_HAS_HOST_LOCK == 0)
+	spin_unlock(&io_request_lock);
+	spin_lock(&asd->platform_data->spinlock);
+#endif
+}
+
+static inline void 
+asd_sml_unlock(struct asd_softc *asd)
+{
+#if (SCSI_ML_HAS_HOST_LOCK == 0)
+	spin_unlock(&asd->platform_data->spinlock);
+	spin_lock(&io_request_lock);
+#endif
+}
+
+#if (SCSI_ML_HAS_HOST_LOCK == 0)
+#define ASD_SML_LOCK_ASSERT(asd)  {\
+	ASSERT(!spin_is_locked(&asd->platform_data->spinlock)); \
+	ASSERT(spin_is_locked(&io_request_lock)) }
+#else
+#define ASD_SML_LOCK_ASSERT(asd)
+#endif
+
+static inline void 
+asd_list_lockinit(void)
+{
+	spin_lock_init(&asd_list_spinlock);
+}
+
+static inline void 
+asd_list_lock(u_long *flags)
+{
+	spin_lock_irqsave(&asd_list_spinlock, *flags);
+}
+
+static inline void 
+asd_list_unlock(u_long *flags)
+{
+	spin_unlock_irqrestore(&asd_list_spinlock, *flags);
+}
+
+
+/* Delay routine for microseconds interval */
+static inline void asd_delay(long usecs);
+
+static inline void
+asd_delay(long usecs)
+{
+	/* 
+	 * Delay max up to 2 milliseconds at a time. 
+	 */
+	/*touch_nmi_watchdog();*/
+	if (usecs > 1000)
+		mdelay((usecs/1000));
+	else
+		udelay(usecs);
+}
+
+static inline char *asd_name(struct asd_softc  *asd);
+	
+static inline char *
+asd_name(struct asd_softc  *asd)
+{
+	return (asd->profile.name);
+}
+
+/************************* Large Disk Handling ********************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static inline int asd_sector_div(u_long capacity, int heads, int sectors);
+
+static inline int
+asd_sector_div(u_long capacity, int heads, int sectors)
+{
+	return (capacity / (heads * sectors));
+}
+#else
+static inline int asd_sector_div(sector_t capacity, int heads, int sectors);
+
+static inline int
+asd_sector_div(sector_t capacity, int heads, int sectors)
+{
+	sector_div(capacity, (heads * sectors));
+	return (int)capacity;
+}
+#endif
+
+/************************ Memory space  access routines ***********************/
+
+static inline uint8_t  	asd_read_byte(struct asd_softc *asd, u_long offset);
+static inline uint16_t 	asd_read_word(struct asd_softc *asd, u_long offset);
+static inline uint32_t 	asd_read_dword(struct asd_softc *asd, u_long offset);
+static inline void 	asd_write_byte(struct asd_softc *asd, u_long offset, 
+				       uint8_t val);
+static inline void 	asd_write_word(struct asd_softc *asd, u_long offset, 
+				       uint16_t val);
+static inline void 	asd_write_dword(struct asd_softc *asd, u_long offset, 
+					uint32_t val);
+static inline void 	asd_readstr_byte(struct asd_softc *asd, u_long offset,
+	       				 uint8_t *buffer, u_long count);
+static inline void 	asd_readstr_word(struct asd_softc *asd, u_long offset,
+					 uint16_t *buffer, u_long count);
+static inline void 	asd_readstr_dword(struct asd_softc *asd, u_long offset,
+					  uint32_t *buffer, u_long count);
+static inline void 	asd_writestr_byte(struct asd_softc *asd, u_long offset,
+					  uint8_t *buffer, u_long count);
+static inline void 	asd_writestr_word(struct asd_softc *asd, u_long offset,
+					  uint16_t *buffer, u_long count);
+static inline void 	asd_writestr_dword(struct asd_softc *asd, u_long offset,					   uint32_t *buffer, u_long count);
+
+static inline uint8_t
+asd_read_byte(struct asd_softc *asd, u_long offset)
+{
+	uint8_t		val;
+	
+	if (asd->io_handle[0]->type == ASD_IO_SPACE)
+		val = inb(asd->io_handle[0]->baseaddr.iobase + 
+			 (offset & 0xFF));
+	else
+		val = readb(asd->io_handle[0]->baseaddr.membase + offset);
+	mb();
+	return val;
+}
+
+static inline uint16_t
+asd_read_word(struct asd_softc *asd, u_long offset)
+{
+	uint16_t	val;
+	
+	if (asd->io_handle[0]->type == ASD_IO_SPACE)
+		val = inw(asd->io_handle[0]->baseaddr.iobase + 
+			 (offset & 0xFF));
+	else
+		val = readw(asd->io_handle[0]->baseaddr.membase + offset);	
+	mb();	
+	return val;
+}
+
+static inline uint32_t
+asd_read_dword(struct asd_softc *asd, u_long offset)
+{
+	uint32_t	val;
+	
+	if (asd->io_handle[0]->type == ASD_IO_SPACE)
+		val = inl(asd->io_handle[0]->baseaddr.iobase + 
+			 (offset & 0xFF));
+	else
+		val = readl(asd->io_handle[0]->baseaddr.membase + offset);
+	mb();
+	return val;
+}
+
+static inline void
+asd_write_byte(struct asd_softc *asd, u_long offset, uint8_t val)
+{
+	if (asd->io_handle[0]->type == ASD_IO_SPACE)
+		outb(val, asd->io_handle[0]->baseaddr.iobase + 
+		    (offset & 0xFF));
+	else
+		writeb(val, asd->io_handle[0]->baseaddr.membase + offset);
+	mb();
+}
+	
+static inline void
+asd_write_word(struct asd_softc *asd, u_long offset, uint16_t val)
+{
+	if (asd->io_handle[0]->type == ASD_IO_SPACE)
+		outw(val, asd->io_handle[0]->baseaddr.iobase + 
+		    (offset & 0xFF));
+	else
+		writew(val, asd->io_handle[0]->baseaddr.membase + offset);
+	mb();
+}
+
+static inline void
+asd_write_dword(struct asd_softc *asd, u_long offset, uint32_t val)
+{
+	if (asd->io_handle[0]->type == ASD_IO_SPACE)
+		outl(val, asd->io_handle[0]->baseaddr.iobase + 
+		    (offset & 0xFF));
+	else
+		writel(val, asd->io_handle[0]->baseaddr.membase + offset);
+	mb();
+}
+
+static inline void
+asd_readstr_byte(struct asd_softc *asd, u_long offset, uint8_t *buffer,
+		 u_long	count)
+{ 	
+	u_long	i;
+	
+	for (i = 0; i < count; i++)
+		*buffer++ = asd_read_byte(asd, offset);
+}
+
+static inline void
+asd_readstr_word(struct asd_softc *asd, u_long offset, uint16_t *buffer,
+		 u_long	count)
+{ 	
+	u_long	i;
+	
+	for (i = 0; i < count; i++)
+		*buffer++ = asd_read_word(asd, offset);
+}
+
+static inline void
+asd_readstr_dword(struct asd_softc *asd, u_long	offset, uint32_t *buffer,
+		  u_long count)
+{ 	
+	u_long	i;
+	
+	for (i = 0; i < count; i++)
+		*buffer++ = asd_read_dword(asd, offset);
+}
+
+static inline void
+asd_writestr_byte(struct asd_softc *asd, u_long offset, uint8_t	*buffer,
+		  u_long count)
+{ 	
+	u_long	i;
+	
+	for (i = 0; i < count; i++)
+		asd_write_byte(asd, offset, *buffer++);
+}
+
+static inline void
+asd_writestr_word(struct asd_softc *asd, u_long	offset, uint16_t *buffer,
+		  u_long count)
+{ 	
+	u_long	i;
+	
+	for (i = 0; i < count; i++)
+		asd_write_word(asd, offset, *buffer++);
+}
+
+static inline void
+asd_writestr_dword(struct asd_softc *asd, u_long offset, uint32_t *buffer,
+		   u_long count)
+{ 	
+	u_long	i;
+	
+	for (i = 0; i < count; i++)
+		asd_write_dword(asd, offset, *buffer++);
+}
+
+
+/******************* PCI Config Space (PCIC) access routines ******************/
+
+static inline uint8_t	asd_pcic_read_byte(struct asd_softc *asd, int reg);
+static inline uint16_t 	asd_pcic_read_word(struct asd_softc *asd, int reg);   
+static inline uint32_t 	asd_pcic_read_dword(struct asd_softc *asd, int reg);
+static inline void 	asd_pcic_write_byte(struct asd_softc *asd, int reg, 
+					    uint8_t val);
+static inline void 	asd_pcic_write_word(struct asd_softc *asd, int reg, 
+					    uint16_t val);
+static inline void 	asd_pcic_write_dword(struct asd_softc *asd, int reg, 
+					     uint32_t val);
+static inline void 	asd_flush_device_writes(struct asd_softc *asd);
+					
+static inline uint8_t
+asd_pcic_read_byte(struct asd_softc *asd, int reg)
+{
+	struct pci_dev	*dev;
+	uint8_t		val;
+	
+	dev = asd_dev_to_pdev(asd->dev);
+	pci_read_config_byte(dev, reg, &val);
+	
+	return (val);
+}
+
+static inline uint16_t
+asd_pcic_read_word(struct asd_softc *asd, int reg)
+{
+	struct pci_dev	*dev;
+	uint16_t	val;
+	
+	dev = asd_dev_to_pdev(asd->dev);	
+	pci_read_config_word(dev, reg, &val);
+	
+	return (val);
+}
+
+static inline uint32_t
+asd_pcic_read_dword(struct asd_softc *asd, int reg)
+{
+	struct pci_dev	*dev;
+	uint32_t	val;
+	
+	dev = asd_dev_to_pdev(asd->dev);
+	pci_read_config_dword(dev, reg, &val);
+	
+	return (val);
+}
+
+static inline void
+asd_pcic_write_byte(struct asd_softc *asd, int reg, uint8_t val)
+{
+	struct pci_dev	*dev;
+	
+	dev = asd_dev_to_pdev(asd->dev);
+	pci_write_config_byte(dev, reg, val);
+}	
+ 
+static inline void
+asd_pcic_write_word(struct asd_softc *asd, int reg, uint16_t val)
+{
+	struct pci_dev	*dev;
+	
+	dev = asd_dev_to_pdev(asd->dev);
+	pci_write_config_word(dev, reg, val);
+}
+
+static inline void
+asd_pcic_write_dword(struct asd_softc *asd, int reg, uint32_t val)
+{
+	struct pci_dev	*dev;
+	
+	dev = asd_dev_to_pdev(asd->dev);
+	pci_write_config_dword(dev, reg, val);
+}
+
+static inline void
+asd_flush_device_writes(struct asd_softc *asd)
+{
+	/*
+	 * Reading the interrupt status register
+	 * is always safe, but is this enough to
+	 * flush writes on *all* the architectures
+	 * we may support?
+	 */
+	asd_read_dword(asd, CHIMINT);
+}
+
+
+/**************** Sliding Windows memory read/write utilities *****************/
+
+static inline uint32_t	asd_hwi_adjust_sw_b(struct asd_softc *asd, 
+					    uint32_t reg);
+static inline uint32_t	asd_hwi_adjust_sw_c(struct asd_softc *asd, 
+					    uint32_t reg);
+static inline uint8_t	asd_hwi_swb_read_byte(struct asd_softc *asd, 
+					      uint32_t reg);
+static inline uint16_t	asd_hwi_swb_read_word(struct asd_softc *asd, 
+					      uint32_t reg);
+static inline uint32_t	asd_hwi_swb_read_dword(struct asd_softc *asd, 
+					       uint32_t reg);
+static inline void	asd_hwi_swb_write_byte(struct asd_softc *asd, 
+					       uint32_t reg, uint8_t val);
+static inline void	asd_hwi_swb_write_word(struct asd_softc *asd, 
+					       uint32_t reg, uint16_t val);
+static inline void	asd_hwi_swb_write_dword(struct asd_softc *asd, 
+						uint32_t reg, uint32_t val);
+static inline uint8_t	asd_hwi_swc_read_byte(struct asd_softc *asd, 
+					      uint32_t reg);
+static inline uint16_t	asd_hwi_swc_read_word(struct asd_softc *asd, 
+					      uint32_t reg);
+static inline uint32_t	asd_hwi_swc_read_dword(struct asd_softc *asd, 
+					       uint32_t reg);
+static inline void	asd_hwi_swc_write_byte(struct asd_softc *asd, 
+					       uint32_t reg, uint8_t val);
+static inline void	asd_hwi_swc_write_word(struct asd_softc *asd, 
+					       uint32_t reg, uint16_t val);
+static inline void	asd_hwi_swc_write_dword(struct asd_softc *asd, 
+						uint32_t reg, uint32_t val);
+static inline void 	asd_hwi_set_hw_addr(struct asd_softc *asd, 
+					    uint32_t base_addr, 
+					    dma_addr_t bus_addr);
+
+/* 
+ * Function:
+ *	asd_hwi_adjust_sw_b()
+ *
+ * Description:
+ *      Setup the Sliding Window B to proper base in order to be able to 
+ *	access to the desired register.
+ */
+static inline uint32_t
+asd_hwi_adjust_sw_b(struct asd_softc *asd, uint32_t reg)
+{
+	uint32_t	new_swb_base;
+	uint32_t	new_reg_offset;
+	
+	if (asd->io_handle[0]->type == ASD_IO_SPACE) {
+		/* IO Mapped. */
+		new_swb_base = (uint32_t) (reg & ~BASEB_IOMAP_MASK);
+		new_reg_offset = (uint32_t) (reg & BASEB_IOMAP_MASK);
+	} else {
+		/* LT, 2005/10/24: This is the proper way to do it. */
+		new_swb_base = reg & ~((asd->io_handle[0]->length - 0x80) - 1);
+		new_reg_offset = reg - new_swb_base;
+#if 0		
+		/*To be reviewed...*/ 
+
+		/* Memory Mapped. */
+		uint32_t	mbar0_mask;
+		uint32_t	offset;
+
+		offset = (uint32_t) (reg - asd->io_handle[0]->swb_base);
+		mbar0_mask = asd->io_handle[0]->length - 1;
+
+		/* 
+		* Check if the register to be accessed is already accessible 
+		* with the current window B and avoid reprogramming the 
+		* window. 
+	        *
+		* The boundaries of window B in a memory mapped space are:
+		* lower bound: 
+		*	io_handle[0]->swb_base (e.g. 0xBF80_0000h,current value)
+		*	mbar0_mask (e.g., 0003_FFFFh)
+		*	BASEB_START (e.g. 0000_0080h) or BF83_FF7Fh for example.
+		*
+		* The following check assumes that the largest access to
+		* reg will be an 8 byte access.
+		*/
+         
+		if ((reg >= (uint32_t) asd->io_handle[0]->swb_base) &&
+			((reg + 7) <= (uint32_t) (asd->io_handle[0]->swb_base 
+				+ mbar0_mask - BASEB_START))) {
+			/* 
+			* The window B is already positioned to allow the 
+			* register to be accessed. The offset to the register 
+			* is the difference between the register to be accessed 
+			* and the current value of the base address register
+			*/
+			new_swb_base = (uint32_t) asd->io_handle[0]->swb_base;
+			new_reg_offset = offset;
+		} else {
+			/*
+			* The window B base address register must be changed to 
+			* position window B to a location where the register 
+			* can be accessed.
+			*/
+			new_swb_base = (uint32_t) (reg & ~BASEB_IOMAP_MASK);
+			new_reg_offset = (uint32_t) (reg & BASEB_IOMAP_MASK);
+		}
+#endif		
+#if 0
+		/* 
+		* The following code is not working correctly with a reg 
+		* value of 0xBF83FF80. The resulting base of 0xBF80_0000 and 
+		* the resulting offset of 0x003F_FF80, appear correct, but 
+		* the calling routines always add BASEB_START to the offset. 
+		* This results in an invalid write acess.
+		*/
+      
+		uint32_t	mbar0_mask;
+		uint32_t	offset;
+		
+		offset = (uint32_t) (reg - asd->io_handle[0]->swb_base);
+		mbar0_mask = asd->io_handle[0]->length - 1;
+		if (offset & ~mbar0_mask) {
+			/*
+			 * The register needs to be accessed is out of the 
+			 * current sliding window B range.
+			 */
+			new_swb_base = (uint32_t) (reg & ~mbar0_mask);
+			new_reg_offset = (uint32_t) (reg & mbar0_mask);
+		} else {
+			/*
+			 * The register needs to be accessed is in the 
+			 * current sliding window B range.
+			 */
+			 new_swb_base = asd->io_handle[0]->swb_base;
+			 new_reg_offset = offset;
+		}
+#endif
+	}
+	/*
+	 * Adjust the SW B Base if the the new base is different from the old
+	 * one.
+	 */
+	if (new_swb_base != asd->io_handle[0]->swb_base) {
+#ifdef ASD_DEBUG
+//use debug_flag to check the first 10 setting (12 to 2)
+#if 0
+		if(asd->debug_flag>2)
+		{
+			asd_log(ASD_DBG_INFO, "asd->io_handle[0]->swb_base=0x%x, asd->io_handle[0]->length=0x%x \n",
+				asd->io_handle[0]->swb_base, asd->io_handle[0]->length);
+			asd_log(ASD_DBG_INFO, "reg=0x%x, new_swb_base=0x%x, new_reg_offset=0x%x \n",
+				reg, new_swb_base, new_reg_offset);
+			asd->debug_flag--;
+		}
+#endif
+#endif
+		asd_write_dword(asd, PCIC_BASEB, new_swb_base);
+		asd->io_handle[0]->swb_base = new_swb_base;
+	}
+	
+	return (new_reg_offset);
+} 
+
+/* 
+ * Function:
+ *	asd_hwi_adjust_sw_c()
+ *
+ * Description:
+ *      Setup the Sliding Window C to proper base in order to be able to 
+ *	access to the desired register.
+ */
+static inline uint32_t   
+asd_hwi_adjust_sw_c(struct asd_softc *asd, uint32_t reg)
+{
+	uint32_t	new_swc_base;
+	uint32_t	new_reg_offset;
+
+	new_swc_base = (uint32_t) (reg & ~BASEC_MASK);
+	new_reg_offset = (uint32_t) (reg & BASEC_MASK);
+	
+	asd_write_dword(asd, PCIC_BASEC, new_swc_base);
+	return (new_reg_offset);
+}
+
+static inline uint8_t
+asd_hwi_swb_read_byte(struct asd_softc *asd, uint32_t reg)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_b(asd, reg);
+	return ((uint8_t) asd_read_byte(asd, (reg_offset + BASEB_START)));
+}
+
+static inline uint16_t
+asd_hwi_swb_read_word(struct asd_softc *asd, uint32_t reg)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_b(asd, reg);
+	return ((uint16_t) asd_read_word(asd, (reg_offset + BASEB_START)));
+}
+
+static inline uint32_t
+asd_hwi_swb_read_dword(struct asd_softc *asd, uint32_t reg)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_b(asd, reg);
+	return ((uint32_t) asd_read_dword(asd, (reg_offset + BASEB_START)));
+}
+
+static inline void
+asd_hwi_swb_write_byte(struct asd_softc *asd, uint32_t reg, uint8_t val)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_b(asd, reg);
+	asd_write_byte(asd, (reg_offset + BASEB_START), val);
+}
+
+static inline void
+asd_hwi_swb_write_word(struct asd_softc *asd, uint32_t reg, uint16_t val)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_b(asd, reg);
+	asd_write_word(asd, (reg_offset + BASEB_START), val);
+}
+
+static inline void
+asd_hwi_swb_write_dword(struct asd_softc  *asd, uint32_t reg, uint32_t val)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_b(asd, reg);
+	asd_write_dword(asd, (reg_offset + BASEB_START), val);
+}
+
+static inline uint8_t
+asd_hwi_swc_read_byte(struct asd_softc *asd, uint32_t reg)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_c(asd, reg);
+	return ((uint8_t) asd_read_byte(asd, (reg_offset + BASEC_START)));
+} 
+
+static inline uint16_t
+asd_hwi_swc_read_word(struct asd_softc *asd, uint32_t reg)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_c(asd, reg);
+	return ((uint16_t) asd_read_word(asd, (reg_offset + BASEC_START)));
+}
+
+static inline uint32_t
+asd_hwi_swc_read_dword(struct asd_softc *asd, uint32_t reg)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_c(asd, reg);
+	return ((uint32_t) asd_read_dword(asd, (reg_offset + BASEC_START)));
+}
+
+static inline void
+asd_hwi_swc_write_byte(struct asd_softc *asd, uint32_t reg, uint8_t val)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_c(asd, reg);	
+	asd_write_byte(asd, (reg_offset + BASEC_START), val);
+}
+
+static inline void
+asd_hwi_swc_write_word(struct asd_softc *asd, uint32_t reg, uint16_t val)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_c(asd, reg);	
+	asd_write_word(asd, (reg_offset + BASEC_START), val);
+}
+
+static inline void
+asd_hwi_swc_write_dword(struct asd_softc *asd, uint32_t reg, uint32_t val)
+{
+	uint32_t	reg_offset;
+	
+	reg_offset = asd_hwi_adjust_sw_c(asd, reg);	
+	asd_write_dword(asd, (reg_offset + BASEC_START), val);
+}
+
+static inline void
+asd_hwi_set_hw_addr(struct asd_softc *asd, uint32_t base_addr,
+		    dma_addr_t bus_addr)
+{
+	asd_hwi_swb_write_dword(asd, base_addr,
+				asd_htole32(ASD_GET_PADR(bus_addr)));
+	asd_hwi_swb_write_dword(asd, base_addr + 4,
+				asd_htole32(ASD_GET_PUADR(bus_addr)));
+}
+
+
+/************************** Scatter/Gather entry setup ************************/
+
+static inline int	asd_sg_setup(struct sg_element *sg, dma_addr_t addr,
+				     uint32_t len, int last);
+
+static inline int
+asd_sg_setup(struct sg_element *sg, dma_addr_t addr, uint32_t len, int last)
+{
+	sg->bus_address = asd_htole64(addr);
+	sg->length = asd_htole32(len);
+	memset(sg->res_1, 0, sizeof(*sg) - offsetof(struct sg_element, res_1));
+	if (last)
+		sg->flags |= SG_EOL;
+	return (0);
+}
+
+
+/********************* Host Queue management routines ************************/ 
+
+static inline struct asd_device *
+			asd_next_device_to_run(struct asd_softc *asd);
+static inline void	asd_schedule_runq(struct asd_softc *asd);
+static inline void	asd_schedule_unblock(struct asd_softc *asd);
+static inline void	asd_freeze_hostq(struct asd_softc *asd);
+static inline void	asd_release_hostq(struct asd_softc *asd);
+static inline void	asd_release_hostq_locked(struct asd_softc *asd);
+static inline void	asd_freeze_targetq(struct asd_softc *asd,
+					   struct asd_target *targ);
+static inline void	asd_unfreeze_targetq(struct asd_softc *asd,
+					     struct asd_target *targ);
+static inline void	asd_setup_dev_timer(struct asd_device *dev,
+					    u_long timeout,
+					    void (*func)(u_long));
+static inline void	asd_setup_dev_dpc_task(struct asd_device *dev,
+					       void (*func)(void *));
+					
+
+static inline struct asd_device *
+asd_next_device_to_run(struct asd_softc *asd)
+{
+	struct	asd_device	*dev;
+
+	ASD_LOCK_ASSERT(asd);
+
+	if (asd->platform_data->qfrozen != 0) {
+		return (NULL);
+	}
+
+	list_for_each_entry(dev, &asd->platform_data->device_runq, links) {
+
+		if ((dev->target->src_port->events & 
+			ASD_DISCOVERY_PROCESS) != 0)
+			continue;
+
+		return dev;
+	}
+
+	return NULL;
+}
+
+
+/*
+ * Must be called with our lock held.
+ */
+static inline void
+asd_schedule_runq(struct asd_softc *asd)
+{
+	ASD_LOCK_ASSERT(asd);
+
+	tasklet_schedule(&asd->platform_data->runq_tasklet);
+}
+
+static inline void
+asd_schedule_unblock(struct asd_softc *asd)
+{
+	tasklet_schedule(&asd->platform_data->unblock_tasklet);
+}
+
+static inline void
+asd_freeze_hostq(struct asd_softc *asd)
+{
+	asd->platform_data->qfrozen++;
+	if (asd->platform_data->qfrozen == 1)
+		scsi_block_requests(asd->platform_data->scsi_host);
+}
+
+static inline void
+asd_release_hostq(struct asd_softc *asd)
+{
+	u_long flags;
+
+	asd_lock(asd, &flags);
+	asd_release_hostq_locked(asd);
+	asd_unlock(asd, &flags);
+}
+
+static inline void
+asd_release_hostq_locked(struct asd_softc *asd)
+{
+	if (asd->platform_data->qfrozen > 0)
+		asd->platform_data->qfrozen--;
+
+	if (asd->platform_data->qfrozen == 0) {
+		asd_schedule_unblock(asd);
+		asd_schedule_runq(asd);
+	}
+}
+
+static inline void
+asd_freeze_targetq(struct asd_softc *asd, struct asd_target *targ)
+{
+	if(targ->qfrozen==0)
+	{
+		targ->qfrozen++;
+	}
+}
+
+static inline void
+asd_unfreeze_targetq(struct asd_softc *asd, struct asd_target *targ)
+{
+	if (targ->qfrozen > 0)
+		targ->qfrozen--;
+}
+
+static inline void
+asd_setup_dev_timer(struct asd_device *dev, u_long timeout,
+		    void (*func)(u_long))
+{
+	dev->flags |= ASD_DEV_TIMER_ACTIVE;
+	init_timer(&dev->timer);
+	dev->timer.expires = jiffies + timeout;
+	dev->timer.data = (u_long) dev;
+	dev->timer.function = func;
+	add_timer(&dev->timer);
+}
+
+static inline void
+asd_setup_dev_dpc_task(struct asd_device *dev, void (*func)(void *))
+{
+	dev->flags |= ASD_DEV_DPC_ACTIVE;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,41)
+	dev->taskq.routine = func;
+	dev->taskq.data = (void *) dev;
+	schedule_task(&dev->taskq);
+#else
+	INIT_WORK(&dev->workq, func, (void *) dev);
+	schedule_work(&dev->workq);
+#endif
+}
+
+/**************************** Semaphores Handling *****************************/
+
+static inline void	asd_sleep_sem(struct semaphore *sem);
+static inline void	asd_wakeup_sem(struct semaphore *sem);
+
+static inline void
+asd_sleep_sem(struct semaphore *sem)
+{
+	down(sem);
+}
+
+static inline void
+asd_wakeup_sem(struct semaphore *sem)
+{
+	up(sem);
+}
+
+/****************************** SCB/EDB Handling ******************************/
+
+static inline void 	asd_platform_scb_free(struct asd_softc *asd, 
+					      struct scb *scb);
+static inline void 	asd_hwi_free_scb(struct asd_softc *asd,
+					 struct scb *scb);
+static inline void 	*asd_hwi_sdata_bus_to_virt(struct asd_softc *asd, 
+						   uint64_t baddr);
+static inline union edb *asd_hwi_get_edb_vaddr(struct asd_softc *asd, 
+						uint64_t baddr);
+static inline union edb *asd_hwi_get_edb_from_dl(struct asd_softc *asd,
+						 struct scb *scb,
+						 struct asd_done_list *dl,
+						 struct scb **pescb,
+						 u_int *pedb_index);
+static inline void	asd_setup_scb_timer(struct scb *scb, u_long timeout,
+					    void (*func)(u_long));
+static inline void	asd_cmd_set_retry_status(Scsi_Cmnd *cmd);
+static inline void	asd_cmd_set_offline_status(Scsi_Cmnd *cmd);
+
+static inline void
+asd_platform_scb_free(struct asd_softc *asd, struct scb *scb)
+{
+	if ((asd->flags & ASD_SCB_RESOURCE_SHORTAGE) != 0) {
+		asd->flags &= ~ASD_SCB_RESOURCE_SHORTAGE;
+		if ((asd->flags & ASD_WAITING_FOR_RESOURCE) != 0) {
+			asd->flags &= ~ASD_WAITING_FOR_RESOURCE;
+			wake_up(&asd->platform_data->waitq);
+		}
+		asd_release_hostq_locked(asd);
+	}
+}
+
+static inline void
+asd_hwi_free_scb(struct asd_softc *asd, struct scb *scb)
+{
+//JD
+	scb->io_ctx=NULL;
+	scb->post_stack_depth=0;
+	if ((scb->flags & SCB_RESERVED) != 0) {
+#ifdef ASD_DEBUG
+		printk("Free reserved scb 0x%x flags 0x%x\n",scb, scb->flags);
+#endif
+
+        	list_add(&scb->hwi_links, &asd->rsvd_scbs);
+	} else {
+      	list_add(&scb->hwi_links, &asd->free_scbs);
+		/* Notify the OSM that a resource is now available. */
+		asd_platform_scb_free(asd, scb);
+	}
+
+	/* 
+	 * Clean up the SCB's flags for the next user.
+	 */
+	scb->flags = SCB_FLAG_NONE;
+}
+
+static inline void *
+asd_hwi_sdata_bus_to_virt(struct asd_softc *asd, uint64_t baddr)
+{
+	uint8_t		*vaddr;
+	uint64_t	vaddr_offset;
+
+	vaddr_offset = baddr - asd->shared_data_map.busaddr;
+	vaddr = asd->shared_data_map.vaddr + vaddr_offset;
+	return (vaddr);
+}
+
+static inline union edb *
+asd_hwi_get_edb_vaddr(struct asd_softc *asd, uint64_t baddr)
+{
+	return ((union edb *)asd_hwi_sdata_bus_to_virt(asd, baddr));
+}
+
+static inline union edb * 
+asd_hwi_get_edb_from_dl(struct asd_softc *asd, struct scb *scb, 
+	   		struct asd_done_list *dl, struct scb **pescb, 
+			u_int *pedb_index)
+{
+	union edb 		*edb;
+	struct response_sb   	*rsp;
+	struct scb 		*escb;
+	u_int  			 escb_index;
+	u_int			 edb_index;
+
+	edb = NULL;
+	rsp = &dl->stat_blk.response;
+	escb_index = asd_le16toh(rsp->empty_scb_tc);
+	edb_index = RSP_EDB_ELEM(rsp) - 1;
+
+	edb = asd_hwi_indexes_to_edb(asd, &escb, escb_index, edb_index);
+
+	*pescb = escb;
+	*pedb_index = edb_index;
+
+	return edb;
+}
+
+static inline void
+asd_setup_scb_timer(struct scb *scb, u_long timeout, void (*func)(u_long))
+{
+	init_timer(&scb->platform_data->timeout);
+	scb->platform_data->timeout.expires = jiffies + timeout;
+	scb->platform_data->timeout.data = (u_long) scb;
+	scb->platform_data->timeout.function = func;
+	add_timer(&scb->platform_data->timeout);
+}
+
+static inline void
+asd_cmd_set_retry_status(Scsi_Cmnd *cmd)
+{
+	/*
+	 * If we want the request requeued, make sure there
+	 * are sufficent retries.  In the old scsi error code,
+	 * we used to be able to specify a result code that
+	 * bypassed the retry count.  Now we must use this
+	 * hack.  We also "fake" a check condition with
+	 * a sense code of ABORTED COMMAND.  This seems to
+	 * evoke a retry even if this command is being sent
+	 * via the eh thread.  Ick!  Ick!  Ick!
+	 */
+	if (cmd->retries > 0)
+		cmd->retries--;
+
+	asd_cmd_set_scsi_status(cmd, SCSI_STATUS_CHECK_COND);
+	asd_cmd_set_host_status(cmd, DID_OK);
+	asd_cmd_set_driver_status(cmd, DRIVER_SENSE);
+	memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+	cmd->sense_buffer[0] = SSD_ERRCODE_VALID
+			     | SSD_CURRENT_ERROR;
+	cmd->sense_buffer[2] = SSD_KEY_ABORTED_COMMAND;
+} 
+
+static inline void
+asd_cmd_set_offline_status(Scsi_Cmnd *cmd)
+{
+	asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+	asd_cmd_set_driver_status(cmd, DRIVER_SENSE);
+	memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+	cmd->sense_buffer[0] = SSD_ERRCODE_VALID
+			     | SSD_CURRENT_ERROR;
+	cmd->sense_buffer[2] = SSD_KEY_NOT_READY;
+}
+
+static inline void
+asd_build_sas_header(
+struct asd_target 		*targ,
+struct asd_ssp_task_hscb	*ssp_hscb
+)
+{
+	ssp_hscb->protocol_conn_rate = targ->ddb_profile.conn_rate;
+	ssp_hscb->sas_header.frame_type = OPEN_ADDR_FRAME;
+	memcpy(ssp_hscb->sas_header.hashed_dest_sasaddr,
+	       targ->ddb_profile.hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+	ssp_hscb->sas_header.res = 0;
+	memcpy(ssp_hscb->sas_header.hashed_src_sasaddr,
+	       targ->src_port->hashed_sas_addr, HASHED_SAS_ADDR_LEN);
+	memset(ssp_hscb->sas_header.res1, 0,
+	       offsetof(struct asd_sas_header, target_port_xfer_tag) - 
+	       offsetof(struct asd_sas_header, res1));
+	ssp_hscb->sas_header.target_port_xfer_tag = 0xFFFF;
+	ssp_hscb->sas_header.data_offset = 0;
+	ssp_hscb->conn_handle = targ->ddb_profile.conn_handle;
+	ssp_hscb->sister_scb = 0xFFFF;
+	ssp_hscb->retry_cnt = TASK_RETRY_CNT;
+
+	/*
+	 * SSP Command IU.
+	 */
+	memset(ssp_hscb->lun, 0,
+	       offsetof(struct asd_ssp_task_hscb, cdb) -
+	       offsetof(struct asd_ssp_task_hscb, lun));
+
+	memset(&ssp_hscb->data_dir_flags, 0, 
+	       offsetof(struct asd_ssp_task_hscb, sg_elements) - 
+	       offsetof(struct asd_ssp_task_hscb, data_dir_flags));
+
+	ssp_hscb->data_dir_flags = 0;
+}
+
+static inline void
+asd_push_post_stack_timeout(
+struct asd_softc	*asd,
+struct scb		*scb,
+asd_io_ctx_t		io_ctx,
+asd_scb_post_t		*post,
+void			(*timeout_func)(u_long)
+)
+{
+	if (scb->post_stack_depth == SCB_POST_STACK_DEPTH) {
+		panic("post_stack overflow\n");
+	}
+
+	scb->post_stack[scb->post_stack_depth].io_ctx = io_ctx;
+	scb->post_stack[scb->post_stack_depth].post = post;
+	scb->post_stack[scb->post_stack_depth].timeout_func = timeout_func;
+
+	scb->io_ctx = io_ctx;
+	scb->post = post;
+
+	scb->post_stack_depth++;
+}
+
+static inline void
+asd_push_post_stack(
+struct asd_softc	*asd,
+struct scb		*scb,
+asd_io_ctx_t		io_ctx,
+asd_scb_post_t		*post
+)
+{
+	asd_push_post_stack_timeout(asd, scb, io_ctx, post, NULL);
+}
+
+static inline void
+asd_pop_post_stack(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	if (scb->post_stack_depth == 0) {
+//JD		panic("post_stack underflow - opcode 0x%x done_list=%p "
+//			"scb = %p\n", done_listp->opcode, done_listp, scb);
+			asd_log(ASD_DBG_ERROR, "Post overflow scb ptr=%p\n",scb);
+		return;
+	}
+
+	scb->post_stack_depth--;
+
+	scb->io_ctx = scb->post_stack[scb->post_stack_depth].io_ctx;
+	scb->post = scb->post_stack[scb->post_stack_depth].post;
+
+	scb->post(asd, scb, done_listp);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
+#define SCSI_DATA_READ  DMA_FROM_DEVICE
+#define SCSI_DATA_WRITE DMA_TO_DEVICE
+#define SCSI_DATA_UNKNOWN DMA_BIDIRECTIONAL
+#define SCSI_DATA_NONE  DMA_NONE
+#define scsi_to_pci_dma_dir(_a) (_a)
+#endif
+
+
+#endif /* ADP94XX_INLINE_H */
+
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_ioctl.c linux-2.6.16/drivers/scsi/adp94xx/adp94xx_ioctl.c
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_ioctl.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_ioctl.c	2007-04-05 23:37:43.000000000 +0000
@@ -0,0 +1,1079 @@
+/*
+ * Adaptec ADP94xx SAS HBA driver for Linux - IOCTL interface for Linux.
+ *
+ * Written by : Naveen Chandrasekaran <naveen_chandrasekaran@adaptec.com>
+ * Modifications and cleanups: Luben Tuikov <luben_tuikov@adaptec.com>
+ * 
+ * Copyright (c) 2004-05 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ *
+ */	
+
+#include "adp94xx_osm.h"
+#include "adp94xx_inline.h"
+#include "adp94xx_ioctl.h"
+
+#ifdef __x86_64__
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 0)	
+#include <linux/ioctl32.h>
+#include <linux/syscalls.h>
+#else
+#include <asm/ioctl32.h>
+#endif
+#endif
+
+/* IOCTL control device name */
+#define ASD_CTL_DEV_NAME	"asdctl"
+static int asd_ctl_major;
+
+/* protos for char device entry points */
+static int asd_ctl_open(struct inode *inode, struct file *file);
+static int asd_ctl_close(struct inode *inode, struct file *file);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+static int asd_ctl_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg);
+#else
+static long asd_unlocked_ctl_ioctl(struct file *file,
+			unsigned int cmd, unsigned long arg);
+static long asd_compat_ioctl(struct file *file,
+			unsigned int cmd, unsigned long arg);
+#endif
+
+/* protos for ioctl handlers */
+static int asd_ctl_get_cntlr_config(unsigned long arg);
+
+/* protos for Adaptec NVRAM access ioctl handlers */
+static int asd_ctl_sas_get_adpt_cntlr_conf(unsigned long arg);
+static int asd_ctl_sas_get_nv_seg_prop(unsigned long arg);
+static int asd_ctl_sas_write_nv_seg(unsigned long arg);
+static int asd_ctl_sas_read_nv_seg(unsigned long arg);
+
+/* protos for helper - work horse routines for ioctl handlers */
+static int asd_ctl_write_to_nvram(struct asd_softc *asd,
+	struct ASD_SAS_WRITE_NV_SEGMENT_BUFFER *pasd_write_nv_buf,
+	uint8_t *psource_buffer);
+
+static int asd_ctl_read_from_nvram(struct asd_softc *asd,
+	struct ASD_SAS_READ_NV_SEGMENT_BUFFER *pasd_read_nv_buf,
+	uint8_t *pdest_buffer);
+
+static uint32_t asd_ctl_write_to_flash (struct asd_softc *asd, 
+			uint8_t *src_img_addr, uint32_t segment_id, 
+			uint32_t src_img_offset, uint32_t src_img_size);
+
+/* protos for extern routines */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+#ifdef __x86_64__
+extern int register_ioctl32_conversion(unsigned int cmd, 
+	int (*handler)(unsigned int, unsigned int, unsigned long,
+	struct file *));
+
+extern int unregister_ioctl32_conversion(unsigned int cmd); 
+#endif
+#endif
+
+extern int asd_hwi_search_nv_cookie(struct asd_softc *asd, 
+			uint32_t *addr,
+			struct asd_flash_dir_layout *pflash_dir_buf);
+
+/* fops table */
+static struct file_operations asd_ctl_fops = {
+	.owner		= THIS_MODULE,
+	.open		= asd_ctl_open,
+	.release	= asd_ctl_close,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	.ioctl		= asd_ctl_ioctl
+#else
+	.unlocked_ioctl = asd_unlocked_ctl_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = asd_compat_ioctl
+#endif
+#endif
+};
+
+/* macros */
+#define asd_valloc_mem(size)		vmalloc(size)
+#define asd_vfree_mem(ptr)		vfree(ptr)
+#define ASD_CTL_TIMEOUT(pioctl_header) 	\
+((pioctl_header->Timeout == 0? ASD_ADAPTEC_TIMEOUT: \
+				pioctl_header->Timeout) * HZ) 
+
+/* represents busy bit number */
+#define ASD_CTL_INTERNAL_BUSY_BIT_NR 0
+
+/* inline routines */
+/*
+ * Function:
+ * 	asd_ctl_check_buf_len()
+ *
+ * Description:
+ * 	This routine validates the buffer length specified in the CSMI
+ * 	IOCTL header with the actual size of the buffer needed for the 
+ * 	corresponding IOCTL.
+ */
+static inline int asd_ctl_check_buf_len(unsigned long arg, int buffer_length)
+{
+	struct IOCTL_HEADER ioctl_header;
+	int err;
+	
+	if ((err = copy_from_user(&ioctl_header, (void *)arg, 
+				 sizeof(ioctl_header)))) {
+		return -EFAULT;
+	}
+
+	if (ioctl_header.Length < buffer_length) {
+		ioctl_header.ReturnCode = ASD_SAS_STATUS_INVALID_PARAMETER;
+		if ((err = copy_to_user((void *)arg, &ioctl_header, 
+					sizeof(ioctl_header)))) {
+			return -EFAULT;
+		}
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static inline int asd_ctl_copy_to_user(void *dest, void *src, uint32_t length, 
+			uint32_t status)
+{
+	struct IOCTL_HEADER *pioctl_header;
+	int err;
+
+	pioctl_header = (struct IOCTL_HEADER *)src;
+	pioctl_header->ReturnCode = status;
+	if ((err = copy_to_user(dest, src, length))) {
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static inline int asd_ctl_map_nv_segid_from_ext(uint32_t ext_segid, 
+			uint32_t *asd_segid)
+{
+	switch (ext_segid) {
+	case ASD_SAS_SEGMENT_ID_CTRL_A_USER_SETTINGS0:
+		*asd_segid = NVRAM_CTRL_A_SETTING;
+		break;
+	case ASD_SAS_SEGMENT_ID_MANUFACTURING_SECTOR0: 
+		*asd_segid = NVRAM_MANUF_TYPE;
+		break;
+	case ASD_SAS_SEGMENT_ID_FLASH_DIRECTORY0:/*TBD*/
+	case ASD_SAS_SEGMENT_ID_FLASH0:
+	case ASD_SAS_SEGMENT_ID_SEEPROM0:
+	case ASD_SAS_SEGMENT_ID_COMPATIBILITY_SECTOR0:
+		*asd_segid = NVRAM_NO_SEGMENT_ID;
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+static inline int asd_ctl_map_seg_attr_to_ext(uint16_t asd_seg_attr, 
+			uint16_t *ext_seg_attr)
+{
+	switch (asd_seg_attr) {
+	case 0:
+		*ext_seg_attr = ASD_SAS_SEGMENT_ATTRIBUTE_READONLY;
+		break;	
+	case 1:
+		*ext_seg_attr = ASD_SAS_SEGMENT_ATTRIBUTE_ERASEWRITE;
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+/* registration routines */
+int asd_register_ioctl_dev(void)
+{
+	int err;
+	
+	err = 0;
+	asd_ctl_major = 0;
+
+	/* 
+	 * Register the IOCTL control device and request 
+	 * for a dynamic major number 
+	 */
+	if (!(asd_ctl_major = register_chrdev(0, ASD_CTL_DEV_NAME, 
+						&asd_ctl_fops))) {
+		return -ENODEV;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+#ifdef __x86_64__
+	/* 
+	 * This ioctl handler module is compatible between 64 and 32 bit
+	 * environments, hence register the default handler as 32bit 
+	 * ioctl conversion handler.
+	 */
+	err |= register_ioctl32_conversion(ASD_CC_SAS_GET_CNTLR_CONFIG, 
+							(void *)sys_ioctl);
+	err |= register_ioctl32_conversion(ASD_CC_SAS_GET_ADPT_CNTLR_CONFIG,
+							(void *)sys_ioctl);
+	err |= register_ioctl32_conversion(
+				ASD_CC_SAS_GET_NV_SEGMENT_PROPERTIES,
+							(void *)sys_ioctl);
+	err |= register_ioctl32_conversion(ASD_CC_SAS_WRITE_NV_SEGMENT,
+							(void *)sys_ioctl);
+	err |= register_ioctl32_conversion(ASD_CC_SAS_READ_NV_SEGMENT,
+							(void *)sys_ioctl);
+#endif /* #ifdef __x86_64__ */
+#endif
+	return err;
+}
+
+int asd_unregister_ioctl_dev(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+#ifdef __x86_64__
+	unregister_ioctl32_conversion(ASD_CC_SAS_GET_CNTLR_CONFIG);
+	unregister_ioctl32_conversion(ASD_CC_SAS_GET_ADPT_CNTLR_CONFIG);
+	unregister_ioctl32_conversion(ASD_CC_SAS_GET_NV_SEGMENT_PROPERTIES);
+	unregister_ioctl32_conversion(ASD_CC_SAS_WRITE_NV_SEGMENT);
+	unregister_ioctl32_conversion(ASD_CC_SAS_READ_NV_SEGMENT);
+#endif /* #ifdef __x86_64__ */
+#endif
+
+	return unregister_chrdev(asd_ctl_major, ASD_CTL_DEV_NAME);
+}
+
+/* init routine */
+int asd_ctl_init_internal_data(struct asd_softc *asd)
+{
+	struct asd_ctl_mgmt *pasd_ctl_mgmt;
+	
+	pasd_ctl_mgmt = &asd->asd_ctl_internal.mgmt;
+	
+	/* Initialize waitq */
+	init_waitqueue_head(&pasd_ctl_mgmt->waitq);
+	
+	/* Initialize busy flags */
+	pasd_ctl_mgmt->busy = 0;
+	
+	/* Initialize semaphore */
+	init_MUTEX(&pasd_ctl_mgmt->sem);
+	
+	/* Initialize timers */
+	init_timer(&pasd_ctl_mgmt->timer);
+
+	/* Initialize err flag */
+	pasd_ctl_mgmt->err = SCB_EH_FAILED;
+	
+	return 0;
+}
+
+/* entry points */
+static int asd_ctl_open(struct inode *inode, struct file *file)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)	
+	MOD_INC_USE_COUNT;
+#endif	
+	return 0;
+}
+
+static int asd_ctl_close(struct inode *inode, struct file *file)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)	
+	MOD_DEC_USE_COUNT;
+#endif	
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+static int asd_ctl_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+#else
+static long asd_unlocked_ctl_ioctl(struct file *file,
+			unsigned int cmd, unsigned long arg)
+#endif
+{
+	struct IOCTL_HEADER ioctl_header;
+	int asd_user_buf_len;
+	int hba, max_hba;
+	int err;
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		return -EACCES;
+	}
+	
+	asd_user_buf_len = sizeof(ioctl_header);
+	if ((err = copy_from_user(&ioctl_header, (void *)arg, 
+				asd_user_buf_len))) {
+		return -EFAULT;
+	}
+
+	hba = ioctl_header.IOControllerNumber;
+
+	max_hba = asd_get_number_of_hbas_present();
+
+	if (hba < 0 || hba >= max_hba) {
+		asd_ctl_copy_to_user((void *)arg, 
+				     &ioctl_header, 
+				     asd_user_buf_len,
+				     ASD_SAS_STATUS_INVALID_PARAMETER);
+		return -ENODEV;
+	}
+
+	switch (cmd) {
+	case ASD_CC_SAS_GET_CNTLR_CONFIG:
+		err = asd_ctl_get_cntlr_config(arg);
+		break;
+	case ASD_CC_SAS_GET_ADPT_CNTLR_CONFIG:
+		err = asd_ctl_sas_get_adpt_cntlr_conf(arg);
+		break;
+	case ASD_CC_SAS_GET_NV_SEGMENT_PROPERTIES:
+		err = asd_ctl_sas_get_nv_seg_prop(arg);
+		break;
+	case ASD_CC_SAS_WRITE_NV_SEGMENT:
+		err = asd_ctl_sas_write_nv_seg(arg);
+		break;
+	case ASD_CC_SAS_READ_NV_SEGMENT:
+		err = asd_ctl_sas_read_nv_seg(arg);
+		break;
+	/* Unsupported/Unknown IOCTLs */
+	default:
+		asd_ctl_copy_to_user((void *)arg, 
+				     &ioctl_header, 
+				     asd_user_buf_len,
+				     ASD_SAS_STATUS_BAD_CNTL_CODE);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
+#ifdef CONFIG_COMPAT
+static long asd_compat_ioctl(struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	return asd_unlocked_ctl_ioctl(file, cmd, arg);
+}
+#endif
+#endif
+
+
+/* ioctl handler routines */
+static int asd_ctl_get_cntlr_config(unsigned long arg)
+{
+	struct ASD_SAS_CNTLR_CONFIG_BUFFER asd_cntlr_conf_buf;
+	struct ASD_SAS_CNTLR_CONFIG *pasd_sas_cntlr_config;
+	union ASD_SAS_IO_BUS_ADDRESS *pasd_sas_io_bus_address;
+	struct ASD_SAS_PCI_BUS_ADDRESS *pasd_sas_pci_bus_address;
+	struct IOCTL_HEADER *pioctl_header;
+	struct asd_softc *asd;
+	int asd_user_buf_len;
+	int retcode;
+	int err;
+	
+	asd_user_buf_len = sizeof(asd_cntlr_conf_buf);
+	if ((err = asd_ctl_check_buf_len(arg, asd_user_buf_len))) {
+		return -EINVAL;
+	}
+	
+	if ((err = copy_from_user(&asd_cntlr_conf_buf, (void *)arg, 
+				  asd_user_buf_len))) {
+		return -EFAULT;
+	}
+	
+	pioctl_header = &asd_cntlr_conf_buf.IoctlHeader;
+	
+	asd = asd_get_softc_by_hba_index(pioctl_header->IOControllerNumber);
+	if (asd == NULL) {
+		/* Requested controller not found */
+		retcode = ASD_SAS_STATUS_INVALID_PARAMETER;
+		err = -ENODEV;
+		goto done;
+	}
+		
+	retcode = ASD_SAS_STATUS_SUCCESS;
+	err = 0;
+	pasd_sas_cntlr_config = &asd_cntlr_conf_buf.Configuration;
+	pasd_sas_io_bus_address = &pasd_sas_cntlr_config->BusAddress;
+	pasd_sas_pci_bus_address = &pasd_sas_io_bus_address->PciAddress;
+
+	pasd_sas_cntlr_config->uBaseIoAddress = 
+				asd_pcic_read_dword(asd, PCI_BASE_ADDRESS_0);
+	pasd_sas_cntlr_config->BaseMemoryAddress.uLowPart =
+				asd_pcic_read_dword(asd, PCI_BASE_ADDRESS_2);
+	pasd_sas_cntlr_config->BaseMemoryAddress.uHighPart =
+				asd_pcic_read_dword(asd, PCI_BASE_ADDRESS_3);
+
+	pasd_sas_cntlr_config->uBoardID =
+				(asd_pci_dev(asd)->device << 16) |
+				asd_pci_dev(asd)->vendor;
+
+	pasd_sas_cntlr_config->usSlotNumber = 
+				PCI_SLOT(asd_pci_dev(asd)->devfn);
+	pasd_sas_cntlr_config->bControllerClass = ASD_SAS_CNTLR_CLASS_HBA;
+	pasd_sas_cntlr_config->bIoBusType = ASD_SAS_BUS_TYPE_PCI;
+	pasd_sas_pci_bus_address->bBusNumber = asd_pci_dev(asd)->bus->number;
+	pasd_sas_pci_bus_address->bDeviceNumber =
+				PCI_SLOT(asd_pci_dev(asd)->devfn);
+	pasd_sas_pci_bus_address->bFunctionNumber =
+				PCI_FUNC(asd_pci_dev(asd)->devfn);
+	
+	sprintf(pasd_sas_cntlr_config->szSerialNumber,"%01x%06x%08x%x", 
+			ASD_BSAR_GET_NAA(asd->hw_profile.wwn), 
+			ASD_BSAR_GET_IEEE_ID(asd->hw_profile.wwn),
+			ASD_BSAR_GET_SN(asd->hw_profile.wwn),
+			ASD_BSAR_GET_LSB(asd->hw_profile.wwn));
+
+	pasd_sas_cntlr_config->usMajorRevision = 0;
+	pasd_sas_cntlr_config->usMinorRevision = 0;
+	pasd_sas_cntlr_config->usBuildRevision = 0;
+	pasd_sas_cntlr_config->usReleaseRevision = 0;
+	pasd_sas_cntlr_config->usBIOSMajorRevision = 
+				asd->hw_profile.bios_maj_ver; 
+	pasd_sas_cntlr_config->usBIOSMinorRevision = 
+				asd->hw_profile.bios_min_ver; 
+	pasd_sas_cntlr_config->usBIOSBuildRevision = 
+				asd->hw_profile.bios_bld_num & 0xffff; 
+	pasd_sas_cntlr_config->usBIOSReleaseRevision = 
+				asd->hw_profile.bios_bld_num >> 16; 
+	
+	pasd_sas_cntlr_config->uControllerFlags = ASD_SAS_CNTLR_SAS_HBA;
+					   //|ASD_SAS_CNTLR_SATA_HBA;//TBD
+	pasd_sas_cntlr_config->usRromMajorRevision = 0;
+	pasd_sas_cntlr_config->usRromMinorRevision = 0;
+	pasd_sas_cntlr_config->usRromBuildRevision = 0;
+	pasd_sas_cntlr_config->usRromReleaseRevision = 0;
+	pasd_sas_cntlr_config->usRromBIOSMajorRevision = 0;
+	pasd_sas_cntlr_config->usRromBIOSMinorRevision = 0;
+	pasd_sas_cntlr_config->usRromBIOSBuildRevision = 0;
+	pasd_sas_cntlr_config->usRromBIOSReleaseRevision = 0;
+
+done:
+	/* return status */	
+	asd_ctl_copy_to_user((void *)arg, &asd_cntlr_conf_buf, 
+			     asd_user_buf_len, retcode);
+	return err;
+}	
+
+/* Adaptec extension IOCTL handler routines */
+static int asd_ctl_sas_get_adpt_cntlr_conf(unsigned long arg)
+{
+	struct ASD_SAS_GET_ADPT_CNTLR_CONFIG_BUFFER asd_adpt_cntlr_conf_buf;
+	struct ASD_SAS_GET_ADPT_CNTLR_CONFIG *pasd_sas_adpt_cntlr_config;
+	struct IOCTL_HEADER *pioctl_header;
+	struct asd_softc *asd;
+	u_long flags;
+	int asd_user_buf_len;
+	int retcode;
+	int err;
+	
+	asd_user_buf_len = sizeof(asd_adpt_cntlr_conf_buf);
+	if ((err = asd_ctl_check_buf_len(arg, asd_user_buf_len))) {
+		return -EINVAL;
+	}
+	
+	if ((err = copy_from_user(&asd_adpt_cntlr_conf_buf, 
+				  (void *)arg, 
+				  asd_user_buf_len))) {
+		return -EFAULT;
+	}
+	
+	pioctl_header = &asd_adpt_cntlr_conf_buf.IoctlHeader;
+	
+	asd = asd_get_softc_by_hba_index(pioctl_header->IOControllerNumber);
+	if (asd == NULL) {
+		/* Requested controller not found */
+		retcode = ASD_SAS_STATUS_INVALID_PARAMETER;
+		err = -ENODEV;
+		goto done;
+	}
+
+	pasd_sas_adpt_cntlr_config = &asd_adpt_cntlr_conf_buf.Configuration;
+
+	asd_lock(asd, &flags);
+	pasd_sas_adpt_cntlr_config->usPCIVendorID = asd_pci_dev(asd)->vendor;
+	pasd_sas_adpt_cntlr_config->usPCIDeviceID = asd_pci_dev(asd)->device;
+	pasd_sas_adpt_cntlr_config->usPCISubsystemVendorID =  
+					asd_pci_dev(asd)->subsystem_vendor;
+	pasd_sas_adpt_cntlr_config->usPCISubsystemID = 
+					asd_pci_dev(asd)->subsystem_device;
+		
+	if (asd->hw_profile.flash_present) {
+		pasd_sas_adpt_cntlr_config->usFlashManufacturerID =
+					asd->hw_profile.flash_manuf_id;
+		pasd_sas_adpt_cntlr_config->usFlashDeviceID = 
+					asd->hw_profile.flash_dev_id;
+		if (asd->hw_profile.flash_wr_prot) {
+			pasd_sas_adpt_cntlr_config->uControllerFlags 
+				= ASD_ADPT_CNTLR_FLASH_READONLY;
+		}
+		retcode = ASD_SAS_STATUS_SUCCESS;
+	} else {
+		pasd_sas_adpt_cntlr_config->usFlashManufacturerID 
+				= ASD_SAS_APDT_INVALID_FLASH_MANUFACTURER_ID; 
+		pasd_sas_adpt_cntlr_config->usFlashDeviceID 
+				= ASD_SAS_ADPT_INVALID_FLASH_DEVICE_ID; 
+		pasd_sas_adpt_cntlr_config->uControllerFlags 
+				= ASD_ADPT_CNTLR_FLASH_NOT_PRESENT; 
+		retcode = ASD_SAS_STATUS_FAILED;
+	}
+	asd_unlock(asd, &flags);
+done:
+	/* return status */	
+	asd_ctl_copy_to_user((void *)arg, &asd_adpt_cntlr_conf_buf, 
+			     asd_user_buf_len, retcode);
+	return err;
+}
+
+static int asd_ctl_sas_get_nv_seg_prop(unsigned long arg)
+{
+	struct ASD_SAS_NV_SEGMENT_PROPERTIES_BUFFER asd_nvseg_prop_buf;
+	struct ASD_SAS_NV_SEGMENT_PROPERTIES *pasd_nvseg_prop;
+	struct IOCTL_HEADER *pioctl_header;
+	struct asd_softc *asd;
+	u_long flags;
+	uint32_t seg_offset, nv_offset;
+	uint32_t pad_size, image_size, attr, bytes_read;
+	int asd_user_buf_len;
+	int err;
+	int retcode; 
+	
+	asd_user_buf_len = sizeof(asd_nvseg_prop_buf);
+	if ((err = asd_ctl_check_buf_len(arg, asd_user_buf_len))) {
+		return -EINVAL;
+	}
+	
+	if ((err = copy_from_user(&asd_nvseg_prop_buf, 
+				  (void *)arg, 
+				  asd_user_buf_len))) {
+		return -EFAULT;
+	}
+	
+	pioctl_header = &asd_nvseg_prop_buf.IoctlHeader;
+	
+	asd = asd_get_softc_by_hba_index(pioctl_header->IOControllerNumber);
+	if (asd == NULL) {
+		/* Requested controller not found */
+		retcode = ASD_SAS_STATUS_INVALID_PARAMETER; 
+		err = -ENODEV;
+		goto done;
+	}
+	
+	err = 0;
+	retcode = ASD_SAS_STATUS_SUCCESS;
+	pasd_nvseg_prop = &asd_nvseg_prop_buf.Information;
+	asd_lock(asd, &flags);
+	
+	switch (pasd_nvseg_prop->uSegmentID) {
+	case ASD_SAS_SEGMENT_ID_MANUFACTURING_SECTOR0:
+	{
+		struct asd_manuf_base_seg_layout manuf_layout;
+		
+		if ((err = asd_hwi_search_nv_segment(asd, NVRAM_MANUF_TYPE,
+				&nv_offset, &pad_size, &image_size, 
+				&attr)) != 0) {
+			err = -1;
+			break;
+		}
+		asd_ctl_map_seg_attr_to_ext(attr, 
+			&pasd_nvseg_prop->usSegmentAttributes); 
+		
+		seg_offset = 0;
+		memset(&manuf_layout, 0x0, sizeof(manuf_layout));
+		
+		/* Read Manufacturing base segment */
+		if (asd_hwi_read_nv_segment(asd, NVRAM_MANUF_TYPE, 
+				&manuf_layout, seg_offset, 
+				sizeof(manuf_layout), &bytes_read) != 0) {
+			err = -1;
+			break;
+		}
+		image_size = manuf_layout.sector_size;
+		pad_size = image_size;
+		break;
+	}
+	case ASD_SAS_SEGMENT_ID_CTRL_A_USER_SETTINGS0:
+	{
+		struct asd_pci_layout pci_layout;
+
+		if ((err = asd_hwi_search_nv_segment(asd, NVRAM_CTRL_A_SETTING,
+				&nv_offset, &pad_size, &image_size, 
+				&attr)) != 0) {
+			err = -1;
+			break;
+		}
+		asd_ctl_map_seg_attr_to_ext(attr, 
+			&pasd_nvseg_prop->usSegmentAttributes); 
+		
+		seg_offset = 0;
+		memset(&pci_layout, 0x0, sizeof(pci_layout));
+		
+		/* Read Ctrl-A first segment */
+		if (asd_hwi_read_nv_segment(asd, NVRAM_CTRL_A_SETTING, 
+				&pci_layout, seg_offset, sizeof(pci_layout),
+				&bytes_read) != 0) {
+			err = -1;
+			break;
+		}
+		image_size = pci_layout.image_size;
+		pad_size = image_size;
+		break;
+	}
+	case ASD_SAS_SEGMENT_ID_FLASH_DIRECTORY0:
+	{
+		struct asd_flash_dir_layout flash_dir;
+		uint32_t nv_addr, active_entries;
+		int i;
+		if (asd_hwi_search_nv_cookie(asd, &nv_addr, &flash_dir) != 0) {
+			err = -1;
+			break;
+		}
+		seg_offset = 0;
+		active_entries = 0;
+		for (i = 0; i < NVRAM_MAX_ENTRIES; i++) {
+			if (flash_dir.ae_mask & (1 << i)) {
+				active_entries++;
+			}
+		}
+		image_size = sizeof(flash_dir) +
+			     (active_entries * 
+			     sizeof(struct asd_fd_entry_layout));
+		pad_size = sizeof(flash_dir) + 
+			   (NVRAM_MAX_ENTRIES * 
+			   sizeof(struct asd_fd_entry_layout));
+		break;
+	}
+	case ASD_SAS_SEGMENT_ID_FLASH0:
+	case ASD_SAS_SEGMENT_ID_SEEPROM0:
+	case ASD_SAS_SEGMENT_ID_COMPATIBILITY_SECTOR0:
+	{
+		pad_size = ASD_SAS_SEGMENT_SIZE_INVALID;
+		image_size = ASD_SAS_SEGMENT_IMAGE_SIZE_INVALID;
+		pasd_nvseg_prop->usSegmentAttributes = 0;
+		break;
+	}
+	default:
+		err = -1;
+		break;
+	}
+	asd_unlock(asd, &flags);
+
+	if (err) {
+		pasd_nvseg_prop->uStatus = ASD_SAS_NV_FAILURE;
+		retcode = ASD_SAS_STATUS_FAILED;
+	} else {
+		pasd_nvseg_prop->uSegmentSize = pad_size;
+		pasd_nvseg_prop->uSegmentImageSize = image_size;
+		pasd_nvseg_prop->uStatus = ASD_SAS_NV_SUCCESS;
+		retcode = ASD_SAS_STATUS_SUCCESS;
+	}
+done:
+	/* return status */	
+	asd_ctl_copy_to_user((void *)arg, &asd_nvseg_prop_buf, 
+			     asd_user_buf_len, retcode);
+	return err;
+}
+
+static int asd_ctl_sas_write_nv_seg(unsigned long arg)
+{
+	struct ASD_SAS_WRITE_NV_SEGMENT_BUFFER *pasd_write_nv_buf;
+	struct ASD_SAS_WRITE_NV_SEGMENT *pasd_write_nv_seg;
+	struct IOCTL_HEADER *pioctl_header;
+	struct asd_ctl_mgmt *pasd_ctl_mgmt;
+	struct asd_softc *asd;
+	uint8_t *psource_buffer;
+	int asd_user_buf_len;
+	int retcode;
+	int err;
+	
+	/* 
+	 * Leave the data buffer at the end of the struct as the
+	 * data buffer will be allocated separately
+	 */
+	asd_user_buf_len = offsetof(struct ASD_SAS_WRITE_NV_SEGMENT_BUFFER, 
+				     bSourceBuffer) ;
+	
+	if ((pasd_write_nv_buf = asd_alloc_mem(asd_user_buf_len,
+					       GFP_ATOMIC)) == NULL) {
+		return -ENOMEM;
+	}
+
+	if ((err = copy_from_user(pasd_write_nv_buf, (void *)arg, 
+				  asd_user_buf_len))) {
+		asd_free_mem(pasd_write_nv_buf);
+		return -EFAULT;
+	}
+	
+	pioctl_header = &pasd_write_nv_buf->IoctlHeader;
+	pasd_write_nv_seg = 
+		&pasd_write_nv_buf->Information;
+
+	if ((err = asd_ctl_check_buf_len(arg, 
+			  asd_user_buf_len
+			  + pasd_write_nv_seg->uBufferLength))) {
+		asd_free_mem(pasd_write_nv_buf);
+		return -EINVAL;
+	}
+	
+	asd = asd_get_softc_by_hba_index(pioctl_header->IOControllerNumber);
+	
+	if (asd == NULL) {
+		/* Requested controller not found */
+		retcode = ASD_SAS_STATUS_INVALID_PARAMETER;
+		err = -ENODEV;
+		goto done;
+	}
+
+	if (!asd->hw_profile.flash_present) {
+		retcode = ASD_SAS_STATUS_FAILED;
+		err = -EINVAL;
+		goto done;
+	}
+	
+	err = 0;
+	retcode = ASD_SAS_STATUS_SUCCESS; 
+	psource_buffer = NULL;	
+	pasd_ctl_mgmt = &asd->asd_ctl_internal.mgmt;
+
+	if ((psource_buffer = (uint8_t *)asd_valloc_mem(
+				pasd_write_nv_seg->uBufferLength)) == NULL) {
+		retcode = ASD_SAS_STATUS_FAILED;
+		err = -ENOMEM;
+		goto done;
+	}
+	memset(psource_buffer, 0, pasd_write_nv_seg->uBufferLength);
+
+	if ((err = copy_from_user(psource_buffer,
+			 (void *)arg + asd_user_buf_len,
+			 pasd_write_nv_seg->uBufferLength))) {
+		asd_vfree_mem(psource_buffer);
+		retcode = ASD_SAS_STATUS_FAILED;
+		err = -EFAULT;
+		goto done;
+	}
+	
+	down_interruptible(&pasd_ctl_mgmt->sem);
+	err = asd_ctl_write_to_nvram(asd, pasd_write_nv_buf, 
+				     psource_buffer);
+	up(&pasd_ctl_mgmt->sem);
+
+	asd_vfree_mem(psource_buffer);
+
+	retcode = err ? ASD_SAS_STATUS_FAILED : ASD_SAS_STATUS_SUCCESS; 
+done:
+	asd_ctl_copy_to_user((void *)arg, pasd_write_nv_buf, 
+			     asd_user_buf_len, retcode);
+	asd_free_mem(pasd_write_nv_buf);
+	return err;
+}
+
+static int asd_ctl_sas_read_nv_seg(unsigned long arg)
+{
+	struct ASD_SAS_READ_NV_SEGMENT_BUFFER *pasd_read_nv_buf;
+	struct ASD_SAS_READ_NV_SEGMENT *pasd_read_nv_seg;
+	struct IOCTL_HEADER *pioctl_header;
+	struct asd_ctl_mgmt *pasd_ctl_mgmt;
+	struct asd_softc *asd;
+	uint8_t *pdest_buffer;
+	int asd_user_buf_len;
+	int retcode;
+	int err;
+	
+	/* 
+	 * Leave the data buffer at the end of the struct as the
+	 * data buffer will be allocated separately
+	 */
+	asd_user_buf_len = offsetof(struct ASD_SAS_READ_NV_SEGMENT_BUFFER, 
+				     bDestinationBuffer) ;
+	
+	if ((pasd_read_nv_buf = asd_alloc_mem(asd_user_buf_len,
+					      GFP_ATOMIC)) == NULL) {
+		return -ENOMEM;
+	}
+
+	if ((err = copy_from_user(pasd_read_nv_buf, (void *)arg, 
+				  asd_user_buf_len)) != 0) {
+		asd_free_mem(pasd_read_nv_buf);
+		return -EFAULT;
+	}
+	
+	pioctl_header = &pasd_read_nv_buf->IoctlHeader;
+	pasd_read_nv_seg = &pasd_read_nv_buf->Information;
+
+	if ((err = asd_ctl_check_buf_len(arg, 
+			  asd_user_buf_len
+			  + pasd_read_nv_seg->uBytesToRead))) {
+		asd_free_mem(pasd_read_nv_buf);
+		return -EINVAL;
+	}
+	
+	asd = asd_get_softc_by_hba_index(pioctl_header->IOControllerNumber);
+	
+	if (asd == NULL) {
+		/* Requested controller not found */
+		retcode = ASD_SAS_STATUS_INVALID_PARAMETER;
+		err = -ENODEV;
+		goto done;
+	}
+	
+	if (!asd->hw_profile.flash_present) {
+		retcode = ASD_SAS_STATUS_FAILED;
+		err = -EINVAL;
+		goto done;
+	}
+	
+	err = 0;
+	retcode = ASD_SAS_STATUS_SUCCESS; 
+	pdest_buffer = NULL;
+	pasd_ctl_mgmt = &asd->asd_ctl_internal.mgmt;
+	
+	if ((pdest_buffer = (uint8_t *)asd_valloc_mem(
+				pasd_read_nv_seg->uBytesToRead)) == NULL) {
+		retcode = ASD_SAS_STATUS_FAILED;
+		err = -ENOMEM;
+		goto done;
+	}
+	memset(pdest_buffer, 0, pasd_read_nv_seg->uBytesToRead);
+	
+	down_interruptible(&pasd_ctl_mgmt->sem);
+	err = asd_ctl_read_from_nvram(asd, pasd_read_nv_buf, 
+				      pdest_buffer);
+	up(&pasd_ctl_mgmt->sem);
+
+	if (err) {
+		retcode = ASD_SAS_STATUS_FAILED; 
+	} else {
+		retcode = ASD_SAS_STATUS_SUCCESS; 
+		if ((err = copy_to_user((void *)arg + asd_user_buf_len,
+					pdest_buffer,
+					pasd_read_nv_seg->uBytesRead))) {
+			retcode = ASD_SAS_STATUS_FAILED; 
+		}
+	}
+
+	asd_vfree_mem(pdest_buffer);
+done:
+	asd_ctl_copy_to_user((void *)arg, pasd_read_nv_buf, 
+			     asd_user_buf_len, retcode);
+	asd_free_mem(pasd_read_nv_buf);
+	return err;
+}
+
+/* helper routines */
+static int asd_ctl_write_to_nvram(struct asd_softc *asd,
+	struct ASD_SAS_WRITE_NV_SEGMENT_BUFFER *pasd_write_nv_buf,
+	uint8_t *psource_buffer)
+{
+	struct ASD_SAS_WRITE_NV_SEGMENT *pasd_write_nv_seg;
+	struct IOCTL_HEADER *pioctl_header;
+	struct asd_ctl_mgmt *pasd_ctl_mgmt;
+	uint32_t nv_segment_id, nv_offset;
+	uint32_t pad_size, image_size, attr;
+	u_long flags;
+	int retcode;
+	int err;
+	
+	pioctl_header = &pasd_write_nv_buf->IoctlHeader;
+	pasd_write_nv_seg = &pasd_write_nv_buf->Information;
+	pasd_ctl_mgmt = &asd->asd_ctl_internal.mgmt;
+	
+	if (test_and_set_bit(ASD_CTL_INTERNAL_BUSY_BIT_NR, 
+			     &pasd_ctl_mgmt->busy)) { 
+		return -EBUSY;
+	}
+	asd_lock(asd, &flags);
+	err = 0;
+	retcode = ASD_SAS_STATUS_SUCCESS;
+	switch (pasd_write_nv_seg->uSegmentID) {
+	case ASD_SAS_SEGMENT_ID_MANUFACTURING_SECTOR0:
+	{
+		asd_ctl_map_nv_segid_from_ext(pasd_write_nv_seg->uSegmentID,
+					      &nv_segment_id);
+		if ((err = asd_hwi_search_nv_segment(asd, nv_segment_id, 
+				&nv_offset, &pad_size, &image_size, 
+				&attr)) != 0) {
+			err = -1;
+			pasd_write_nv_seg->uStatus = ASD_SAS_NV_FAILURE;
+			break;
+		}
+		err = asd_ctl_write_to_flash(asd, psource_buffer, 
+			nv_segment_id,
+			pasd_write_nv_seg->uDestinationOffset, 
+			pasd_write_nv_seg->uBufferLength);
+		break;
+	}
+	case ASD_SAS_SEGMENT_ID_FLASH0:
+	{
+		err = asd_ctl_write_to_flash(asd, psource_buffer, 
+			NVRAM_NO_SEGMENT_ID,
+			pasd_write_nv_seg->uDestinationOffset, 
+			pasd_write_nv_seg->uBufferLength);
+		break;
+	}
+	case ASD_SAS_SEGMENT_ID_SEEPROM0:
+	case ASD_SAS_SEGMENT_ID_FLASH_DIRECTORY0:
+	case ASD_SAS_SEGMENT_ID_CTRL_A_USER_SETTINGS0:
+	case ASD_SAS_SEGMENT_ID_COMPATIBILITY_SECTOR0:
+	default:
+		pasd_write_nv_seg->uStatus = ASD_SAS_NV_FAILURE;
+		err = -EINVAL;
+		break;
+	}
+
+	asd_unlock(asd, &flags);
+
+	/* return */
+	clear_bit(ASD_CTL_INTERNAL_BUSY_BIT_NR, &pasd_ctl_mgmt->busy);
+	return err;
+}
+
+static int asd_ctl_read_from_nvram(struct asd_softc *asd,
+	struct ASD_SAS_READ_NV_SEGMENT_BUFFER *pasd_read_nv_buf,
+	uint8_t *pdest_buffer)
+{
+	struct ASD_SAS_READ_NV_SEGMENT *pasd_read_nv_seg;
+	struct IOCTL_HEADER *pioctl_header;
+	struct asd_ctl_mgmt *pasd_ctl_mgmt;
+	uint32_t nv_segment_id;
+	u_long flags;
+	int retcode;
+	int err;
+	
+	pioctl_header = &pasd_read_nv_buf->IoctlHeader;
+	pasd_read_nv_seg = &pasd_read_nv_buf->Information;
+	pasd_ctl_mgmt = &asd->asd_ctl_internal.mgmt;
+	
+	if (test_and_set_bit(ASD_CTL_INTERNAL_BUSY_BIT_NR, 
+			     &pasd_ctl_mgmt->busy)) { 
+		return -EBUSY;
+	}
+	err = 0;
+	retcode = ASD_SAS_STATUS_SUCCESS;
+	
+	asd_lock(asd, &flags);
+	switch (pasd_read_nv_seg->uSegmentID) {
+	case ASD_SAS_SEGMENT_ID_CTRL_A_USER_SETTINGS0:
+	case ASD_SAS_SEGMENT_ID_MANUFACTURING_SECTOR0:
+	{
+		asd_ctl_map_nv_segid_from_ext(
+			pasd_read_nv_seg->uSegmentID,
+			&nv_segment_id);
+
+		if (asd_hwi_read_nv_segment(asd, 
+				nv_segment_id,
+				(void *)pdest_buffer,
+				pasd_read_nv_seg->uSourceOffset, 
+				pasd_read_nv_seg->uBytesToRead, 
+				&pasd_read_nv_seg->uBytesRead
+				) != 0) {
+			pasd_read_nv_seg->uStatus = ASD_SAS_NV_FAILURE;
+			err = -EINVAL;
+			break;
+		}
+		pasd_read_nv_seg->uStatus = ASD_SAS_NV_SUCCESS;
+		break;
+	}
+	case ASD_SAS_SEGMENT_ID_FLASH_DIRECTORY0:
+	{
+		struct asd_flash_dir_layout flash_dir;
+		uint32_t nv_addr;
+
+		if (asd_hwi_search_nv_cookie(asd, &nv_addr, &flash_dir) != 0) {
+			err = -1;
+			break;
+		}
+		nv_addr += /*NVRAM_FIRST_DIR_ENTRY +*/
+			pasd_read_nv_seg->uSourceOffset;
+
+		if (asd_hwi_read_nv_segment(asd, NVRAM_NO_SEGMENT_ID,
+				(void *)pdest_buffer, nv_addr,
+				pasd_read_nv_seg->uBytesToRead, 
+				&pasd_read_nv_seg->uBytesRead
+				) != 0) {
+			err = -1;
+			break;
+		}
+		break;
+	}	
+	case ASD_SAS_SEGMENT_ID_FLASH0:
+	{
+		if (asd_hwi_read_nv_segment(asd, 
+				NVRAM_NO_SEGMENT_ID,
+				(void *)pdest_buffer,
+				pasd_read_nv_seg->uSourceOffset, 
+				pasd_read_nv_seg->uBytesToRead, 
+				&pasd_read_nv_seg->uBytesRead
+				) != 0) {
+			pasd_read_nv_seg->uStatus = ASD_SAS_NV_FAILURE;
+			err = -EINVAL;
+			break;
+		}
+		pasd_read_nv_seg->uStatus = ASD_SAS_NV_SUCCESS;
+		break;
+	}
+	case ASD_SAS_SEGMENT_ID_SEEPROM0:
+	case ASD_SAS_SEGMENT_ID_COMPATIBILITY_SECTOR0:/*TBD*/
+	default:
+		pasd_read_nv_seg->uStatus = ASD_SAS_NV_FAILURE;
+		err = -EINVAL;
+		break;
+	}
+	asd_unlock(asd, &flags);
+
+	/* return */
+	clear_bit(ASD_CTL_INTERNAL_BUSY_BIT_NR, &pasd_ctl_mgmt->busy);
+	return err;
+}
+
+static uint32_t asd_ctl_write_to_flash(struct asd_softc *asd, 
+			uint8_t *src_img_addr, uint32_t segment_id, 
+			uint32_t dest_nv_offset, uint32_t src_img_size)
+{
+	uint32_t flash_addr;
+
+	flash_addr = 0;
+
+	/* Need to unlock MBAR key register */
+	flash_addr = asd_pcic_read_dword(asd, PCIC_MBAR_KEY);
+	if (flash_addr != 0) {
+		/* currently locked, need to unlock */
+		asd_pcic_write_dword(asd, PCIC_MBAR_KEY, flash_addr);
+	}
+	if (asd_hwi_write_nv_segment(asd, 
+			(void *)src_img_addr, segment_id, 
+			dest_nv_offset, src_img_size) != 0) {
+		return -EINVAL;
+	}
+	return 0;
+}
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_ioctl.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_ioctl.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_ioctl.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_ioctl.h	2007-04-05 23:37:45.000000000 +0000
@@ -0,0 +1,277 @@
+/*
+ * Adaptec ADP94xx SAS HBA driver for Linux - IOCTL data structures 
+ *
+ * Written by : Naveen Chandrasekaran <naveen_chandrasekaran@adaptec.com>
+ * 
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+
+#ifndef _ASD_IOCTL_H_
+#define _ASD_IOCTL_H_
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/* Data Direction */
+#define ASD_SAS_DATA_READ			0
+#define ASD_SAS_DATA_WRITE			1
+
+/* Status Codes */
+#define ASD_SAS_STATUS_SUCCESS			0
+#define ASD_SAS_STATUS_FAILED			1
+#define ASD_SAS_STATUS_BAD_CNTL_CODE		2
+#define ASD_SAS_STATUS_INVALID_PARAMETER	3
+
+/* I/O Bus Types
+ * ISA and EISA bus types are not supported: (bIoBusType)
+ */
+#define ASD_SAS_BUS_TYPE_PCI 			3
+#define ASD_SAS_BUS_TYPE_PCMCIA 		4
+
+/* Controller Class: (bControllerClass) */
+#define ASD_SAS_CNTLR_CLASS_HBA 		5
+
+/* Controller Flag bits: (uControllerFlags) */
+#define ASD_SAS_CNTLR_SAS_HBA 			0x00000001
+#define ASD_SAS_CNTLR_SAS_RAID			0x00000002
+#define ASD_SAS_CNTLR_SATA_HBA			0x00000004
+#define ASD_SAS_CNTLR_SATA_RAID			0x00000008
+
+/* for firmware download */
+#define ASD_SAS_CNTLR_FWD_SUPPORT		0x00010000
+#define ASD_SAS_CNTLR_FWD_ONLINE 		0x00020000
+#define ASD_SAS_CNTLR_FWD_SRESET 		0x00040000
+#define ASD_SAS_CNTLR_FWD_HRESET 		0x00080000
+#define ASD_SAS_CNTLR_FWD_RROM			0x00100000
+
+/* IOCTL Header */
+struct IOCTL_HEADER {
+	__u32 IOControllerNumber;
+	__u32 Length;
+	__u32 ReturnCode;
+	__u32 Timeout;
+	__u16 Direction;
+}__attribute__ ((packed));
+
+/*************************************************************************/
+/* OS INDEPENDENT CODE                                                   */
+/*************************************************************************/
+
+/* * * * * * * * * Adaptec Vendor Unique Class IOCTL Constants * * * * * * * */
+
+/* Timeout value default of 60 seconds: IoctlHeader.Timeout */
+#define ASD_ADAPTEC_TIMEOUT      60
+
+/* Controller flags: uControllerFlags */
+#define ASD_ADPT_CNTLR_FLASH_NOT_PRESENT          0x00000001
+#define ASD_ADPT_CNTLR_FLASH_READONLY             0x00000002
+
+/* Invalid value for usFlashManufacturerID */
+#define ASD_SAS_APDT_INVALID_FLASH_MANUFACTURER_ID   0xFFFF
+
+/* Invalid value for usFlashDeviceID */
+#define ASD_SAS_ADPT_INVALID_FLASH_DEVICE_ID         0xFFFF
+
+/* Segment identifiers: uSegmentID */
+#define ASD_SAS_SEGMENT_ID_FLASH_DIRECTORY0       0x80000000
+#define ASD_SAS_SEGMENT_ID_CTRL_A_USER_SETTINGS0  0x800000E0
+#define ASD_SAS_SEGMENT_ID_MANUFACTURING_SECTOR0  0x80000120
+#define ASD_SAS_SEGMENT_ID_COMPATIBILITY_SECTOR0  0x80000140
+
+#define ASD_SAS_SEGMENT_ID_FLASH0                 0x90000000
+#define ASD_SAS_SEGMENT_ID_SEEPROM0               0xA0000000
+
+/* NVRAM status: (uStatus) */
+#define ASD_SAS_NV_SUCCESS                  0
+#define ASD_SAS_NV_FAILURE                  1
+#define ASD_SAS_NV_INVALID_SEGMENT_ID       3
+#define ASD_SAS_NV_INVALID_REQUEST          4
+#define ASD_SAS_NV_WRITE_NOT_SUPPORTED      5
+#define ASD_SAS_NV_NO_NVRAM                 6
+
+/* NVRAM segment attributes: (usSegmentAttributes) */
+#define ASD_SAS_SEGMENT_ATTRIBUTE_ERASEWRITE   0x0001
+#define ASD_SAS_SEGMENT_ATTRIBUTE_READONLY     0x0002
+
+/* Invalid value for uSegmentSize */
+#define ASD_SAS_SEGMENT_SIZE_INVALID        0xFFFFFFFF
+
+/* Invalid value for uSegmentImageSize */
+#define ASD_SAS_SEGMENT_IMAGE_SIZE_INVALID  0xFFFFFFFF
+
+#define SLOT_NUMBER_UNKNOWN	0xFFFF
+/*************************************************************************/
+/* DATA STRUCTURES                                                       */
+/*************************************************************************/
+
+/* * * * * * * * * * Adaptec Vendor Unique Class Structures * * * * * * * * * */
+
+/* ASD_CC_SAS_CNTLR_CONFIGURATION */
+struct ASD_SAS_PCI_BUS_ADDRESS {
+	__u8 bBusNumber;
+	__u8 bDeviceNumber;
+	__u8 bFunctionNumber;
+	__u8 bReserved;
+}__attribute__ ((packed));
+
+union ASD_SAS_IO_BUS_ADDRESS {
+	struct ASD_SAS_PCI_BUS_ADDRESS PciAddress;
+	__u8 bReserved[32];
+}__attribute__ ((packed));
+
+struct ASD_SAS_CNTLR_CONFIG {
+	__u32 uBaseIoAddress;
+	struct {
+		__u32 uLowPart;
+		__u32 uHighPart;
+	} BaseMemoryAddress;
+	__u32 uBoardID;
+	__u16 usSlotNumber;
+	__u8 bControllerClass;
+	__u8 bIoBusType;
+	union ASD_SAS_IO_BUS_ADDRESS BusAddress;
+	__u8 szSerialNumber[81];
+	__u16 usMajorRevision;
+	__u16 usMinorRevision;
+	__u16 usBuildRevision;
+	__u16 usReleaseRevision;
+	__u16 usBIOSMajorRevision;
+	__u16 usBIOSMinorRevision;
+	__u16 usBIOSBuildRevision;
+	__u16 usBIOSReleaseRevision;
+	__u32 uControllerFlags;
+	__u16 usRromMajorRevision;
+	__u16 usRromMinorRevision;
+	__u16 usRromBuildRevision;
+	__u16 usRromReleaseRevision;
+	__u16 usRromBIOSMajorRevision;
+	__u16 usRromBIOSMinorRevision;
+	__u16 usRromBIOSBuildRevision;
+	__u16 usRromBIOSReleaseRevision;
+	__u8 bReserved[7];
+}__attribute__ ((packed));
+
+struct ASD_SAS_CNTLR_CONFIG_BUFFER {
+	struct IOCTL_HEADER IoctlHeader;
+	struct ASD_SAS_CNTLR_CONFIG Configuration;
+}__attribute__ ((packed));
+
+/* ASD_CC_SAS_GET_ADPT_CNTLR_CONFIG */
+struct ASD_SAS_GET_ADPT_CNTLR_CONFIG {
+	__u16 usPCIVendorID;
+	__u16 usPCIDeviceID;
+	__u16 usPCISubsystemVendorID;
+	__u16 usPCISubsystemID;
+	__u32 uControllerFlags;
+	__u16 usFlashManufacturerID;
+	__u16 usFlashDeviceID;
+}__attribute__ ((packed));
+
+struct ASD_SAS_GET_ADPT_CNTLR_CONFIG_BUFFER {
+	struct IOCTL_HEADER IoctlHeader;
+	struct ASD_SAS_GET_ADPT_CNTLR_CONFIG Configuration;
+}__attribute__ ((packed));
+
+/* ASD_CC_SAS_GET_NV_SEGMENT_PROPERTIES */
+struct ASD_SAS_NV_SEGMENT_PROPERTIES {
+	__u32 uStatus;
+	__u32 uSegmentID;
+	__u16 usSegmentAttributes;
+	__u32 uSegmentSize;
+	__u32 uSegmentImageSize;
+}__attribute__ ((packed));
+
+struct ASD_SAS_NV_SEGMENT_PROPERTIES_BUFFER {
+	struct IOCTL_HEADER IoctlHeader;
+	struct ASD_SAS_NV_SEGMENT_PROPERTIES Information;
+}__attribute__ ((packed));
+
+/* ASD_CC_SAS_WRITE_NV_SEGMENT */
+struct ASD_SAS_WRITE_NV_SEGMENT {
+	__u32 uStatus;
+	__u32 uSegmentID;
+	__u32 uDestinationOffset;
+	__u32 uBufferLength;
+}__attribute__ ((packed));
+
+struct ASD_SAS_WRITE_NV_SEGMENT_BUFFER {
+	struct IOCTL_HEADER IoctlHeader;
+	struct ASD_SAS_WRITE_NV_SEGMENT Information;
+	__u8 bSourceBuffer[1];
+}__attribute__ ((packed));
+
+/* ASD_CC_SAS_READ_NV_SEGMENT */
+struct ASD_SAS_READ_NV_SEGMENT {
+	__u32 uStatus;
+	__u32 uSegmentID;
+	__u32 uSourceOffset;
+	__u32 uBytesToRead;
+	__u32 uBytesRead;
+}__attribute__ ((packed));
+
+struct ASD_SAS_READ_NV_SEGMENT_BUFFER {
+	struct IOCTL_HEADER IoctlHeader;
+	struct ASD_SAS_READ_NV_SEGMENT Information;
+	__u8 bDestinationBuffer[1];
+}__attribute__ ((packed));
+
+#define ASD_ADAPTEC_MAGIC 'E'
+
+/* Control Codes */
+#define ASD_CC_SAS_GET_CNTLR_CONFIG		\
+	_IOWR(ASD_ADAPTEC_MAGIC, 0x10,		\
+	      struct ASD_SAS_CNTLR_CONFIG_BUFFER) 
+
+#define ASD_CC_SAS_GET_ADPT_CNTLR_CONFIG	\
+	_IOWR(ASD_ADAPTEC_MAGIC, 0x11,		\
+	      struct ASD_SAS_GET_ADPT_CNTLR_CONFIG_BUFFER) 
+
+#define ASD_CC_SAS_GET_NV_SEGMENT_PROPERTIES	\
+	_IOWR(ASD_ADAPTEC_MAGIC, 0x12, 		\
+	      struct ASD_SAS_NV_SEGMENT_PROPERTIES_BUFFER)
+
+#define ASD_CC_SAS_WRITE_NV_SEGMENT 		\
+	_IOWR(ASD_ADAPTEC_MAGIC, 0x13, 		\
+	      struct ASD_SAS_WRITE_NV_SEGMENT_BUFFER) 
+
+#define ASD_CC_SAS_READ_NV_SEGMENT 		\
+	_IOWR(ASD_ADAPTEC_MAGIC, 0x14, 		\
+	      struct ASD_SAS_READ_NV_SEGMENT_BUFFER) 
+
+#endif /* _ASD_IOCTL_H_ */
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_osm.c linux-2.6.16/drivers/scsi/adp94xx/adp94xx_osm.c
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_osm.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_osm.c	2007-04-20 14:33:29.000000000 +0000
@@ -0,0 +1,6297 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ *
+ * Written by: David Chaw <david_chaw@adaptec.com>
+ * Modified by: Naveen Chandrasekaran <naveen_chandrasekaran@adaptec.com>
+ * Modifications and cleanups: Luben Tuikov <luben_tuikov@adaptec.com>
+ *
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+#if KDB_ENABLE
+#include "linux/kdb.h"
+#endif
+#include "adp94xx_osm.h"
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include "linux/buffer_head.h"
+#endif
+#include "adp94xx_inline.h"
+#include "adp94xx_sata.h"
+#include "adp94xx_hwi.h"
+
+/* Global variables */
+LIST_HEAD(asd_hbas);
+static Scsi_Host_Template 	asd_sht;
+static asd_init_status_t	asd_init_stat;
+static int			asd_init_result;
+spinlock_t 			asd_list_spinlock;
+
+#ifdef ASD_EH_SIMULATION
+static u_long			cmd_cnt = 0;
+#endif
+
+#ifdef ASD_DEBUG
+//JD
+u_int				debug_mask = ASD_DBG_INIT | ASD_DBG_INFO | ASD_DBG_RUNTIME | ASD_DBG_ISR | ASD_DBG_ERROR;
+#else
+u_int				debug_mask = 0x0;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/* For dynamic sglist size calculation. */
+u_int asd_nseg;
+#endif
+
+#ifdef MODULE
+static char *adp94xx = NULL;
+
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("Dual BSD/GPL");
+#endif
+#ifdef MODULE_VERSION
+MODULE_VERSION(ASD_DRIVER_VERSION);
+#endif
+MODULE_AUTHOR("Maintainer: David Chaw <david_chaw@adaptec.com>");
+MODULE_DESCRIPTION("Adaptec Linux SAS/SATA Family Driver");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	module_param(adp94xx, charp, S_IRUGO|S_IWUSR);
+#else
+	MODULE_PARM(adp94xx, "s");
+#endif
+MODULE_PARM_DESC(adp94xx,
+"period delimited, options string.\n"
+"	cmd_per_lun:<int>	Queue depth for all attached targets that\n"
+"				support tag queueing\n"
+"	attach_HostRAID:<int>	Attach to controllers in HostRAID mode\n"
+"			(default is 0, false; 1 will enable this feature).\n"
+"\n"
+"	Sample module configuration line:\n"
+"		Set the Queue Depth of all targets to 32.\n"
+"\n"
+"	options adp94xx 'adp94xx=cmd_per_lun:32'"
+"\n"
+"	Sample module configuration line:\n"
+"		Disable this driver.\n"
+"\n"
+"	options adp94xx 'adp94xx=disable'");
+#endif /* MODULE */
+
+/* By default we do not attach to HostRAID enabled controllers.
+ * You can turn this on by passing
+ *     adp94xx=attach_HostRAID:1
+ * to the driver (kernel command line, module parameter line).
+ */
+static int asd_attach_HostRAID = 0;
+
+/* Module entry points */
+static int __init	asd_init(void);
+static void 		asd_exit(void);
+static int 		adp94xx_setup(char *s);
+static void		asd_setup_qtag_info(char *c);
+static void		asd_setup_debug_info(char *c);
+
+/* Initialization */
+static void 		asd_size_nseg(void);
+
+/* Midlayer entry points */
+static int		asd_detect(Scsi_Host_Template *);
+static const char      *asd_info(struct Scsi_Host *);
+static int 		asd_queue(Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
+irqreturn_t		asd_isr(int, void *, struct pt_regs *);
+static int		asd_abort(Scsi_Cmnd *);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int		asd_proc_info(struct Scsi_Host *, char *, char **,
+				      off_t, int, int);
+static int		asd_slave_alloc(Scsi_Device *);
+static int		asd_slave_configure(Scsi_Device *);
+static void		asd_slave_destroy(Scsi_Device *);
+static int		asd_initiate_bus_scan(struct asd_softc *asd);
+#else
+static int		asd_release(struct Scsi_Host *);
+static int		asd_proc_info(char *, char **, off_t, int, int, int);
+static void		asd_select_queue_depth(struct Scsi_Host *, 
+					       Scsi_Device *);
+#endif
+
+/* Device Queue Depth Handling. */
+#define ASD_DEF_TCQ_PER_DEVICE	32
+#define ASD_MAX_TCQ_PER_DEVICE	64
+#define ASD_MIN_TCQ_PER_DEVICE	1
+
+#ifdef CONFIG_ADP94XX_TCQ_PER_DEVICE
+#define ASD_TCQ_PER_DEVICE	CONFIG_ADP94XX_TCQ_PER_DEVICE
+#else
+#define ASD_TCQ_PER_DEVICE	ASD_DEF_TCQ_PER_DEVICE
+#endif
+
+u_int	cmd_per_lun = ASD_TCQ_PER_DEVICE;
+
+typedef enum {
+	ASD_QUEUE_NONE,
+	ASD_QUEUE_BASIC,
+	ASD_QUEUE_TAGGED
+} asd_queue_alg;
+
+static void	asd_set_device_queue_depth(struct asd_softc *asd,
+					   struct asd_device *dev);
+static u_int	asd_get_user_tagdepth(struct asd_softc *asd,
+				      struct asd_device *dev);
+static void	asd_set_tags(struct asd_softc *asd, struct asd_device *dev,
+			     asd_queue_alg alg);
+static void 	asd_print_path(struct asd_softc *asd, struct asd_device *dev);
+
+/* Device Queue Handling. */
+static struct asd_domain *
+		asd_alloc_domain(struct asd_softc *asd, u_int channel_mapping);
+static void	asd_free_domain(struct asd_softc *asd, struct asd_domain *dm);
+static void	asd_dev_timed_unfreeze(u_long arg);
+static void	asd_init_dev_itnl_exp(struct asd_softc *asd,
+				      struct asd_target *targ, u_int lun);
+void		asd_dev_intl_times_out(u_long arg);
+
+static asd_scb_post_t	asd_scb_done;
+static void	asd_handle_sas_status(struct asd_softc *asd,
+				      struct asd_device *dev, struct scb *scb,
+				      struct ssp_resp_edb *edb, u_int edb_len);
+static ASD_COMMAND_BUILD_STATUS	
+		asd_build_sas_scb(struct asd_softc *asd, struct scb *scb,
+				  union asd_cmd *acmd);
+static void	asd_runq_tasklet(unsigned long data);
+static void	asd_unblock_tasklet(unsigned long data);
+static void	asd_flush_device_queue(struct asd_softc *asd,
+				       struct asd_device *dev);
+static inline void
+		asd_check_device_queue(struct asd_softc *asd,
+				       struct asd_device *dev);
+inline void 	asd_run_device_queues(struct asd_softc *asd);
+
+/* Discovery and Device async. event thread. */
+static int	asd_discovery_thread(void *data);
+static void	asd_kill_discovery_thread(struct asd_softc *asd);
+static int	asd_check_phy_events(struct asd_softc *asd, u_int phy_id);
+static int	asd_check_port_events(struct asd_softc *asd, u_int port_id);
+static void	asd_process_id_addr_evt(struct asd_softc *asd, 
+					struct asd_phy *phy);
+static int	asd_initiate_port_discovery(struct asd_softc *asd, 
+				            struct asd_port *port);
+static void	asd_handle_loss_of_signal(struct asd_softc *asd, 
+					  struct asd_port *port);
+static void 	asd_setup_port_data(struct asd_softc *asd,
+				    struct asd_port *port, struct asd_phy *phy);
+static int	asd_setup_target_data(struct asd_softc *asd,
+				      struct asd_phy *phy,
+				      struct asd_target *targ);
+static void	asd_configure_port_targets(struct asd_softc *asd, 
+					   struct asd_port *port);
+static void	asd_configure_target(struct asd_softc *asd,
+				     struct asd_target *targ);
+static void	asd_destroy_target(struct asd_softc *asd,
+				   struct asd_target *targ);
+static void	asd_clear_device_io(struct asd_softc *asd,
+				    struct asd_device *dev);
+static asd_scb_post_t	asd_clear_device_io_done;
+
+/* Error Recovery thread. */
+static int	asd_ehandler_thread(void *data);
+static void	asd_kill_ehandler_thread(struct asd_softc *asd);
+static asd_scb_eh_post_t asd_ehandler_done;
+
+#ifdef ASD_EH_SIMULATION
+static void	asd_eh_simul_done(struct asd_softc *asd, struct scb *scb);
+static int	asd_eh_simul_thread(void *data);
+static void	asd_kill_eh_simul_thread(struct asd_softc *asd);
+#endif
+
+/* PCI entry points */
+static int	asd_pci_dev_probe(struct pci_dev *pdev,
+			 	  const struct pci_device_id *id);
+static void	asd_pci_dev_remove(struct pci_dev *pdev);
+
+/*
+ * PCI Device specific initialization routine.
+ */
+typedef int (asd_pdev_setup_t)	(struct asd_softc *);
+
+struct asd_pci_driver_data {
+	/* Controller Description. */
+	char		  *description;
+
+	/* Controller Specific Setup Routine. */
+	asd_pdev_setup_t  *setup;
+};
+
+static asd_pdev_setup_t asd_aic9410_setup;
+static asd_pdev_setup_t asd_aic9405_setup;
+
+/* Supported PCI Vendor & Device ID */
+#ifndef PCI_VENDOR_ID_ADAPTEC2
+#define PCI_VENDOR_ID_ADAPTEC2	0x9005
+#endif
+#define PCI_CLASS_DEFAULT	0
+#define PCI_CLASS_MASK_DEFAULT	0
+
+static const struct asd_pci_driver_data asd_aic9405_drv_data = {
+	"Adaptec AIC-9405W SAS/SATA Host Adapter",
+	asd_aic9405_setup
+};
+
+static const struct asd_pci_driver_data  asd_aic9410_drv_data = {
+	"Adaptec AIC-9410 SAS/SATA Host Adapter",
+	asd_aic9410_setup
+};
+
+#ifdef ASD_FOR_FUTURE_USE
+static const struct asd_pci_driver_data  asd_comstock_drv_data = {
+	"Adaptec COMSTOCK SAS/SATA Controller",
+	asd_comstock_setup
+};
+#endif
+
+static struct pci_device_id  asd_pci_ids_table[] = {
+	{
+		PCI_VENDOR_ID_ADAPTEC2, 0x0410, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_DEFAULT, PCI_CLASS_MASK_DEFAULT,
+		(unsigned long) &asd_aic9410_drv_data
+	},
+	{
+		PCI_VENDOR_ID_ADAPTEC2, 0x0412, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_DEFAULT, PCI_CLASS_MASK_DEFAULT,
+		(unsigned long) &asd_aic9410_drv_data
+	},
+	{
+		PCI_VENDOR_ID_ADAPTEC2, 0x041E, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_DEFAULT, PCI_CLASS_MASK_DEFAULT,
+		(unsigned long) &asd_aic9410_drv_data
+	},
+	{
+		PCI_VENDOR_ID_ADAPTEC2, 0x041F, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_DEFAULT, PCI_CLASS_MASK_DEFAULT,
+		(unsigned long) &asd_aic9410_drv_data
+	},
+	{
+		PCI_VENDOR_ID_ADAPTEC2, 0x0430, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_DEFAULT, PCI_CLASS_MASK_DEFAULT,
+		(unsigned long) &asd_aic9405_drv_data
+	},
+	{
+		PCI_VENDOR_ID_ADAPTEC2, 0x0432, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_DEFAULT, PCI_CLASS_MASK_DEFAULT,
+		(unsigned long) &asd_aic9405_drv_data
+	},
+	{
+		PCI_VENDOR_ID_ADAPTEC2, 0x043E, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_DEFAULT, PCI_CLASS_MASK_DEFAULT,
+		(unsigned long) &asd_aic9405_drv_data
+	},
+	{
+		PCI_VENDOR_ID_ADAPTEC2, 0x043F, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_DEFAULT, PCI_CLASS_MASK_DEFAULT,
+		(unsigned long) &asd_aic9405_drv_data
+	},
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, asd_pci_ids_table);
+
+struct pci_driver  adp94xx_pci_driver = {
+	.name		= ASD_DRIVER_NAME,
+	.probe		= asd_pci_dev_probe,
+	.remove 	= asd_pci_dev_remove,
+	.id_table	= asd_pci_ids_table
+};
+
+/* Local functions */
+static struct asd_softc	*asd_get_softc(struct asd_softc *asd);
+static int		asd_get_unit(void);
+static int		asd_register_host(struct asd_softc *asd);
+static void             __asd_unregister_host(struct asd_softc *asd);
+static int		asd_init_hw(struct asd_softc *asd);
+static int		asd_map_io_handle(struct asd_softc *asd);
+static int		asd_mem_mapped_io_handle(struct asd_softc *asd);
+static int		asd_io_mapped_io_handle(struct asd_softc *asd);
+
+/********************************* Inlines ************************************/
+
+static inline void	asd_init_tasklets(struct asd_softc *asd);
+static inline void	asd_kill_tasklets(struct asd_softc *asd);
+
+static inline void
+asd_init_tasklets(struct asd_softc *asd)
+{
+	tasklet_init(&asd->platform_data->runq_tasklet, asd_runq_tasklet,
+		     (unsigned long) asd);
+	tasklet_init(&asd->platform_data->unblock_tasklet, asd_unblock_tasklet,
+		     (unsigned long) asd);
+}
+
+static inline void
+asd_kill_tasklets(struct asd_softc *asd)
+{
+	tasklet_kill(&asd->platform_data->runq_tasklet);
+	tasklet_kill(&asd->platform_data->unblock_tasklet);
+}	
+
+struct asd_device *
+asd_get_device(struct asd_softc *asd, u_int ch, u_int id, u_int lun, int alloc)
+{
+	struct asd_domain	*dm;
+	struct asd_target	*targ;
+	struct asd_device	*dev;
+
+	ASD_LOCK_ASSERT(asd);
+
+	/*
+	 * Domain and target structures are allocated by our
+	 * discovery process.  Fail if our mapping attempt
+	 * finds either of these path components missing.
+	 */
+	if ((ch >= asd->platform_data->num_domains) || 
+	    ((dm = asd->platform_data->domains[ch]) == NULL)) {
+		return (NULL);
+	}
+
+	if ((id >= ASD_MAX_TARGET_IDS) || 
+	    ((targ = dm->targets[id]) == NULL)) {
+		return (NULL);
+	}
+
+	if (lun >= ASD_MAX_LUNS) {
+		return (NULL);
+	}
+
+	dev = targ->devices[lun];
+
+	return (dev);
+}
+
+void
+asd_unmap_scb(struct asd_softc *asd, struct scb *scb)
+{
+	Scsi_Cmnd *cmd;
+	int direction;
+
+	cmd = &acmd_scsi_cmd(scb->io_ctx);
+	direction = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+
+	if (cmd->use_sg != 0) {
+		struct scatterlist *sg;
+
+		sg = (struct scatterlist *)cmd->request_buffer;
+		asd_unmap_sg(asd, sg, cmd->use_sg, direction);
+	} else if (cmd->request_bufflen != 0) {
+		asd_unmap_single(asd,
+				 scb->platform_data->buf_busaddr,
+				 cmd->request_bufflen, direction);
+	}
+}
+
+static inline void
+asd_check_device_queue(struct asd_softc *asd, struct asd_device *dev)
+{
+	ASD_LOCK_ASSERT(asd);
+
+	if ((dev->flags & ASD_DEV_FREEZE_TIL_EMPTY) != 0 && dev->active == 0) {
+		dev->flags &= ~ASD_DEV_FREEZE_TIL_EMPTY;
+		dev->qfrozen--;
+	}
+
+	if (list_empty(&dev->busyq) || dev->openings == 0 || 
+	    dev->qfrozen != 0 || dev->target->qfrozen != 0)
+		return;
+
+	if ((dev->target->src_port->events & ASD_DISCOVERY_PROCESS) != 0)
+		return;
+
+	asd_flush_device_queue(asd, dev);
+}
+
+inline void
+asd_run_device_queues(struct asd_softc *asd)
+{
+	struct asd_device *dev;
+
+	while ((dev = asd_next_device_to_run(asd)) != NULL) {
+		list_del(&dev->links);
+		dev->flags &= ~ASD_DEV_ON_RUN_LIST;
+		asd_check_device_queue(asd, dev);
+	}
+}
+
+static inline void asd_target_addref(struct asd_target *targ);
+static inline void asd_target_release(struct asd_softc *asd,
+				      struct asd_target *targ);
+static inline void asd_domain_addref(struct asd_domain *dm);
+static inline void asd_domain_release(struct asd_softc *asd,
+				      struct asd_target *targ);
+
+static inline void
+asd_target_addref(struct asd_target *targ)
+{
+	targ->refcount++;
+}
+
+static inline void
+asd_target_release(struct asd_softc *asd, struct asd_target *targ)
+{
+	targ->refcount--;
+	if (targ->refcount == 0) {
+		asd_free_target(asd, targ);
+	}
+}
+
+static inline void
+asd_domain_addref(struct asd_domain *dm)
+{
+	dm->refcount++;
+}
+
+static inline void
+asd_domain_release(struct asd_softc *asd, struct asd_target *targ)
+{
+	targ->domain->refcount--;
+
+	targ->domain->targets[targ->target_id] = NULL;
+
+	if (targ->domain->refcount == 0) {
+		asd_free_domain(asd, targ->domain);
+	}
+}
+
+/******************************************************************************/
+
+/* 
+ * Function:
+ *	asd_get_softc()
+ *
+ * Description:
+ *	Search if the requested host is in our HBA list. 
+ */
+static struct asd_softc	*
+asd_get_softc(struct asd_softc *asd) 
+{
+	struct asd_softc	*entry;
+	unsigned long		 flags;
+	
+	asd_list_lock(&flags);
+	list_for_each_entry(entry, &asd_hbas, link) {
+		if (entry == asd) {
+			asd_list_unlock(&flags);
+			return (asd);
+		}
+	}
+	asd_list_unlock(&flags);
+		
+	return (NULL);
+}
+
+/* 
+ * Function:
+ *	asd_get_softc_by_hba_index()
+ *
+ * Description:
+ *	Search and return the host corresponding to the user requested 
+ *	hba_index from our HBA list. 
+ */
+struct asd_softc *
+asd_get_softc_by_hba_index(uint32_t hba_index)
+{
+	struct asd_softc	*entry;
+	unsigned long		 flags;
+	
+	asd_list_lock(&flags);
+	list_for_each_entry(entry, &asd_hbas, link) {
+		if (entry->asd_hba_index == hba_index) {
+			asd_list_unlock(&flags);
+			return (entry);
+		}
+	}
+	asd_list_unlock(&flags);
+		
+	return (NULL);
+}
+
+/* 
+ * Function:
+ *	asd_get_number_of_hbas_present()
+ *
+ * Description:
+ *	Return the total number of SAS HBAs present
+ */
+int 
+asd_get_number_of_hbas_present(void)
+{
+	struct asd_softc	*entry;
+	unsigned long		 flags;
+	int hba_count;
+	
+	hba_count = 0;
+	asd_list_lock(&flags);
+	list_for_each_entry(entry, &asd_hbas, link) {
+		hba_count++;
+	}
+	asd_list_unlock(&flags);
+		
+	return hba_count;
+}
+
+/*
+ * Function:
+ * 	asd_get_unit()
+ *
+ * Description:
+ *	Find the smallest available unit number to use for a new device.
+ * 	Avoid using a static count to handle the "repeated hot-(un)plug"
+ * 	scenario.
+ */
+static int
+asd_get_unit(void)
+{
+	struct asd_softc	*asd;
+	unsigned long		 flags;
+	int			 unit;
+
+	unit = 0;
+	asd_list_lock(&flags);
+retry:
+	list_for_each_entry(asd, &asd_hbas, link) {
+		if (asd->profile.unit == unit) {
+			unit++;
+			goto retry;
+		}
+	}
+	asd_list_unlock(&flags);
+	return (unit);
+}
+
+static void
+asd_print_path(struct asd_softc *asd, struct asd_device *dev)
+{
+	if (dev != NULL)
+		asd_print("(scsi%d: Ch %d Id %d Lun %d): ",
+			  asd->platform_data->scsi_host->host_no,
+			  dev->ch, dev->id, dev->lun);
+}
+
+static void
+asd_setup_qtag_info(char *c)
+{
+	u_int	tags;
+
+	tags = simple_strtoul(c + 1, NULL, 0) & (~0);
+
+	if ((tags > ASD_MAX_TCQ_PER_DEVICE) || (tags < ASD_MIN_TCQ_PER_DEVICE))
+		/* Set the Queue Depth to default (32). */
+		tags = ASD_DEF_TCQ_PER_DEVICE;
+
+	asd_print("Setting User Option (cmd_per_lun) : %d\n\n", tags);
+
+	if ((cmd_per_lun > ASD_MAX_TCQ_PER_DEVICE) ||
+	    (cmd_per_lun < ASD_MIN_TCQ_PER_DEVICE))
+		/* Set the Queue Depth to default (32). */
+		cmd_per_lun = ASD_DEF_TCQ_PER_DEVICE;
+	else
+		cmd_per_lun = tags;
+}
+
+static void
+asd_setup_debug_info(char *c)
+{
+	u_int 	dbg_mask;
+
+	dbg_mask = simple_strtoul(c + 1, NULL, 0) & 0xFF;
+	asd_print("Setting the Debug Mask : 0x%x\n\n", dbg_mask);
+}
+
+/*
+ * Function:
+ *	adp94xx_setup()
+ *
+ * Description:
+ * 	Handle Linux boot parameters. This routine allows for assigning a value
+ * 	to a parameter with a ':' between the parameter and the value.
+ * 	ie. adp94xx=cmd_per_lun:32
+ */
+static int
+adp94xx_setup(char *s)
+{
+	char   *p;
+	char   *end;
+	int	i, n;
+
+	static struct {
+		const char 	*name;
+		uint32_t 	*flag;
+	} options[] = {
+		{ "cmd_per_lun", NULL },
+		{ "attach_HostRAID", &asd_attach_HostRAID },
+	};
+
+	end = strchr(s, '\0');
+	n = 0;  
+
+	while ((p = strsep(&s, ",.")) != NULL) {
+		if (*p == '\0')
+			continue;
+		for (i = 0; i < NUM_ELEMENTS(options); i++) {
+
+			n = strlen(options[i].name);
+			if (strncmp(options[i].name, p, n) == 0)
+				break;
+		}
+		if (i == NUM_ELEMENTS(options))
+			continue;
+
+		if (strncmp(p, "cmd_per_lun", n) == 0) {
+			asd_setup_qtag_info(p + n);
+		} else if (strncmp(p, "debug_mask", n) == 0) {
+			asd_setup_debug_info(p + n);
+		} else if (p[n] == ':') {
+			*(options[i].flag) = simple_strtoul(p + n + 1, NULL,0);
+		} else {
+			*(options[i].flag) ^= 0xFFFFFFFF;
+		}
+	}
+	return (1);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+__setup("adp94xx=", adp94xx_setup);
+#endif
+
+#ifdef ASD_DEBUG
+struct timer_list	debug_timer;
+#endif
+
+/* 
+ * Function:
+ *	asd_init()
+ *
+ * Description:
+ *	This is the entry point which will be called during module loading. 
+ */
+static int __init
+asd_init(void)
+{
+#if KDB_ENABLE
+	KDB_ENTER();
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	asd_detect(&asd_sht);
+#else
+	scsi_register_module(MODULE_SCSI_HA, &asd_sht);
+#endif
+	if (asd_init_result != 0) {
+		asd_log(ASD_DBG_INIT, "Module init failed !\n");
+		asd_exit();
+		return (asd_init_result);
+	}
+
+	/* Register the IOCTL char device. */
+	if (asd_register_ioctl_dev() != 0) {
+		asd_log(ASD_DBG_INIT, "Failed to register IOCTL "
+			"dev.\n");
+		asd_exit();
+		asd_init_result = -1;
+	} else {
+		asd_init_stat.asd_ioctl_registered = 1;
+	}
+
+	return (asd_init_result);
+}
+
+/* 
+ * Function:
+ *	asd_exit()
+ *
+ * Description:
+ *	This is the entry point which will be called during module unloading. 
+ */
+static void
+asd_exit(void)
+{
+	struct asd_softc  *asd;
+
+	asd_log(ASD_DBG_INIT, "Unloading module ...\n");
+
+	list_for_each_entry(asd, &asd_hbas, link) {
+		asd_kill_discovery_thread(asd);
+
+		asd_kill_ehandler_thread(asd);
+#ifdef ASD_EH_SIMULATION		
+		asd_kill_eh_simul_thread(asd);
+#endif
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	
+	scsi_unregister_module(MODULE_SCSI_HA, &asd_sht);
+#endif
+	if (asd_init_stat.asd_pci_registered == 1)
+		pci_unregister_driver(&adp94xx_pci_driver); 
+
+	if (asd_init_stat.asd_ioctl_registered == 1)
+		asd_unregister_ioctl_dev();
+	
+}
+
+static int asd_aic9405_setup(struct asd_softc *asd)
+{
+//JD
+#ifdef ASD_DEBUG
+	asd->debug_flag=0;
+#endif
+	/*
+	 * max_cmds_per_lun will be throttled once we know the attached 
+	 * device is DASD.
+	 */
+	asd->profile.max_cmds_per_lun = 2;
+	asd->profile.can_queue = ASD_MAX_QUEUE;
+	asd->profile.initiator_id = 255;
+	asd->profile.max_luns = ASD_MAX_LUNS;
+	asd->profile.max_scsi_ids = ASD_MAX_TARGET_IDS;
+	asd->profile.max_channels = ASD_MAX_PORTS / 2;
+	/*
+	 * For now, we assumed that the controller can support 64-bit
+	 * addressing. 
+	 */
+	asd->profile.dma64_addr = 1;
+	asd->profile.name = ASD_DRIVER_NAME;
+		
+	/* Controller specific profile. */
+	asd->hw_profile.max_devices = ASD_MAX_DEVICES;
+	asd->hw_profile.max_targets = ASD_MAX_TARGETS;
+	asd->hw_profile.max_ports = ASD_MAX_PORTS / 2;
+	asd->hw_profile.max_phys = ASD_MAX_PHYS;
+	/*
+	 * enabled_phys could be used as a bitmap for the user to specified 
+	 * which phys to be enabled.
+	 */ 
+	asd->hw_profile.enabled_phys = 0xF0;
+#ifndef EXTENDED_SCB
+	asd->hw_profile.max_scbs = ASD_MAX_USABLE_SCBS;
+#else
+	asd->hw_profile.max_scbs = ASD_MAX_USABLE_SCBS + ASD_EXTENDED_SCB_NUMBER;
+#endif
+	asd->hw_profile.max_ddbs = ASD_MAX_DDBS;	 
+	asd->hw_profile.rev_id = asd_pcic_read_byte(asd, PCIC_DEVREV_ID);
+
+	/* LT: shamelessly stolen from aic94xx driver */
+	asd->hw_profile.addr_range = 4;
+	asd->hw_profile.port_name_base = 0;
+	asd->hw_profile.dev_name_base = 4;
+	asd->hw_profile.sata_name_base = 8;
+
+	/* 
+	 * Default World Wide Name set for the Controller.
+	 */
+	asd->hw_profile.wwn[0] = 0x50;
+	asd->hw_profile.wwn[1] = 0x00;
+	asd->hw_profile.wwn[2] = 0x0d;
+	asd->hw_profile.wwn[3] = 0x1f;
+	asd->hw_profile.wwn[4] = 0xed;
+	asd->hw_profile.wwn[5] = 0xcb;
+	asd->hw_profile.wwn[6] = 0xa9;
+	asd->hw_profile.wwn[7] = 0x89;
+	return (0);
+}
+
+/* 
+ * Function:
+ *	asd_aic9410_setup()
+ *
+ * Description:
+ *	Setup host profile initialization for the AIC9410 controller. 
+ */
+static int
+asd_aic9410_setup(struct asd_softc *asd)
+{
+	/*
+	 * max_cmds_per_lun will be throttled once we know the attached 
+	 * device is DASD.
+	 */
+	asd->profile.max_cmds_per_lun = 2;
+	asd->profile.can_queue = ASD_MAX_QUEUE;
+	asd->profile.initiator_id = 255;
+	asd->profile.max_luns = ASD_MAX_LUNS;
+	asd->profile.max_scsi_ids = ASD_MAX_TARGET_IDS;
+	asd->profile.max_channels = ASD_MAX_PORTS;
+	/*
+	 * For now, we assumed that the controller can support 64-bit
+	 * addressing. 
+	 */
+	asd->profile.dma64_addr = 1;
+	asd->profile.name = ASD_DRIVER_NAME;
+		
+	/* Controller specific profile. */
+	asd->hw_profile.max_devices = ASD_MAX_DEVICES;
+	asd->hw_profile.max_targets = ASD_MAX_TARGETS;
+	asd->hw_profile.max_ports = ASD_MAX_PORTS;
+	asd->hw_profile.max_phys = ASD_MAX_PHYS;
+	/*
+	 * enabled_phys could be used as a bitmap for the user to specified 
+	 * which phys to be enabled.
+	 */ 
+	asd->hw_profile.enabled_phys = 0xFF;
+#ifndef EXTENDED_SCB
+	asd->hw_profile.max_scbs = ASD_MAX_USABLE_SCBS;
+#else
+	asd->hw_profile.max_scbs = ASD_MAX_USABLE_SCBS + ASD_EXTENDED_SCB_NUMBER;
+#endif
+	asd->hw_profile.max_ddbs = ASD_MAX_DDBS;	 
+	asd->hw_profile.rev_id = asd_pcic_read_byte(asd, PCIC_DEVREV_ID);
+
+	/* LT: shamelessly stolen from aic94xx driver */
+	asd->hw_profile.addr_range = 8;
+	asd->hw_profile.port_name_base = 0;
+	asd->hw_profile.dev_name_base = 8;
+	asd->hw_profile.sata_name_base = 16;
+
+	/* 
+	 * Default World Wide Name set for the Controller.
+	 */
+	asd->hw_profile.wwn[0] = 0x50;
+	asd->hw_profile.wwn[1] = 0x00;
+	asd->hw_profile.wwn[2] = 0x0d;
+	asd->hw_profile.wwn[3] = 0x1f;
+	asd->hw_profile.wwn[4] = 0xed;
+	asd->hw_profile.wwn[5] = 0xcb;
+	asd->hw_profile.wwn[6] = 0xa9;
+	asd->hw_profile.wwn[7] = 0x89;
+	return (0);
+}
+
+/*
+ * Function:
+ *	asd_size_nseg()
+ *
+ * Description:
+ *
+ * In pre-2.5.X...
+ * The midlayer allocates an S/G array dynamically when a command is issued
+ * using SCSI malloc.  This array, which is in an OS dependent format that
+ * must later be copied to our private S/G list, is sized to house just the
+ * number of segments needed for the current transfer.  Since the code that
+ * sizes the SCSI malloc pool does not take into consideration fragmentation
+ * of the pool, executing transactions numbering just a fraction of our
+ * concurrent transaction limit with list lengths aproaching AHC_NSEG will
+ * quickly depleat the SCSI malloc pool of usable space.  Unfortunately, the
+ * mid-layer does not properly handle this scsi malloc failures for the S/G
+ * array and the result can be a lockup of the I/O subsystem.  We try to size
+ * our S/G list so that it satisfies our drivers allocation requirements in
+ * addition to avoiding fragmentation of the SCSI malloc pool.
+ */
+static void
+asd_size_nseg(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	u_int cur_size;
+	u_int best_size;
+
+	/*
+	 * The SCSI allocator rounds to the nearest 512 bytes
+	 * and cannot allocate across a page boundary.  Our algorithm
+	 * is to start at 1K of scsi malloc space per-command and
+	 * loop through all factors of the PAGE_SIZE and pick the best.
+	 */
+	best_size = 0;
+	for (cur_size = 1024; cur_size <= PAGE_SIZE; cur_size *= 2) {
+		u_int nseg;
+
+		nseg = cur_size / sizeof(struct scatterlist);
+		if (nseg < ASD_LINUX_MIN_NSEG)
+			continue;
+
+		if (best_size == 0) {
+			best_size = cur_size;
+			asd_nseg = nseg;
+		} else {
+			u_int best_rem;
+			u_int cur_rem;
+
+			/*
+			 * Compare the traits of the current "best_size"
+			 * with the current size to determine if the
+			 * current size is a better size.
+			 */
+			best_rem = best_size % sizeof(struct scatterlist);
+			cur_rem = cur_size % sizeof(struct scatterlist);
+			if (cur_rem < best_rem) {
+				best_size = cur_size;
+				asd_nseg = nseg;
+			}
+		}
+	}
+#endif
+}
+
+/* 
+ * Function:
+ *	asd_detect()
+ *
+ * Description:
+ *	This routine shall detect any supported controller. 
+ */
+static int
+asd_detect(Scsi_Host_Template *sht)
+{
+	struct asd_softc	*asd;
+	int			 error;
+	uint8_t 		 hba_cnt;
+
+	asd_print("Loading AIC-94xx Linux SAS/SATA Family Driver, Rev: "
+		  "%d.%d.%d-%d\n\n", 
+		  ASD_MAJOR_VERSION, ASD_MINOR_VERSION, 
+		  ASD_BUILD_VERSION, ASD_RELEASE_VERSION);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	/*
+	 * Release the lock that was held by the midlayer prior to calling us.
+	 */
+	spin_unlock_irq(&io_request_lock);
+#endif
+	hba_cnt = 0;
+	asd_init_stat.asd_init_state = 1;
+
+#ifdef MODULE
+	/*
+	 * Parse the command line parameters if we have received any.
+	 */
+	if (adp94xx) {
+		adp94xx_setup(adp94xx);
+	}
+#endif
+
+	asd_list_lockinit();
+	/*
+	 * Determine an appropriate size for our SG lists.
+	 */
+	asd_size_nseg();
+
+	/* Register our PCI entry points and id table. */
+	error = pci_module_init(&adp94xx_pci_driver);
+	if (error != 0) {	
+		asd_init_result = error;
+		goto exit;
+	} else {
+		asd_init_stat.asd_pci_registered = 1;
+		asd_init_result = error;
+	}
+
+	/* For every controller found, register it with the midlayer. */
+	list_for_each_entry(asd, &asd_hbas, link) {
+		error = asd_register_host(asd);
+		if (error != 0) {
+			asd_init_result = error;
+			goto exit;
+		}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		error = asd_initiate_bus_scan(asd);
+		if (error != 0) {
+			struct pci_dev *pci_dev = asd_pci_dev(asd);
+			asd_print("%s: couldn't initiate bus scan for "
+				  "PCI device %x:%x.%x (%x:%x)\n",
+				  asd_name(asd),
+				  pci_dev->bus->number,
+				  PCI_SLOT(pci_dev->devfn),
+				  PCI_FUNC(pci_dev->devfn),
+				  pci_dev->vendor,
+				  pci_dev->device);
+			__asd_unregister_host(asd);
+			continue;
+		}
+#endif
+		asd->asd_hba_index = hba_cnt++;
+
+		asd_ctl_init_internal_data(asd);
+	}
+
+	asd_init_stat.asd_init_state = 0;
+
+exit:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	/* Acquire the lock before returning to midlayer. */
+	spin_lock_irq(&io_request_lock);
+#endif
+	asd_print("AIC-94xx controller(s) attached = %d.\n\n", hba_cnt);
+
+	return (hba_cnt);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/* 
+ * Function:
+ *	asd_release()
+ *
+ * Description:
+ *	Free the Scsi_Host structure during unloading module. 
+ */
+static int
+asd_release(struct Scsi_Host *scsi_host)
+{
+	struct asd_softc	*asd;
+	unsigned long		 flags;
+
+	if (scsi_host != NULL) {
+		asd = *((struct asd_softc **) scsi_host->hostdata);
+		
+		if (asd_get_softc(asd) != NULL) {
+			asd_list_lock(&flags);
+			list_del(&asd->link);
+			asd_list_unlock(&flags);
+			asd_free_softc(asd);
+		}
+	}
+
+	return (0);
+}
+#endif
+
+/* 
+ * Function:
+ *	asd_register_host()
+ *
+ * Description:
+ *	Register our controller with the scsi midlayer. 
+ */
+static int		
+asd_register_host(struct asd_softc *asd)
+{
+	struct Scsi_Host	*scsi_host;
+	u_long			 flags;
+	
+	asd_sht.name = ((struct asd_pci_driver_data *) 
+			(asd->pci_entry->driver_data))->description;	
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	scsi_host = scsi_host_alloc(&asd_sht, sizeof(struct asd_softc *));
+#else
+	scsi_host = scsi_register(&asd_sht, sizeof(struct asd_softc *));
+#endif 
+	if (scsi_host == NULL)
+		return (-ENOMEM);
+	
+	*((struct asd_softc **) scsi_host->hostdata) = asd;
+	
+	asd_lock(asd, &flags);
+
+	/* Fill in host related fields. */
+	asd->platform_data->scsi_host = scsi_host;
+	scsi_host->can_queue = asd->profile.can_queue;
+	scsi_host->cmd_per_lun = asd->profile.max_cmds_per_lun;
+	scsi_host->sg_tablesize	= ASD_NSEG;
+	scsi_host->max_channel = asd->profile.max_channels;
+	scsi_host->max_id = asd->profile.max_scsi_ids;
+	scsi_host->max_lun = asd->profile.max_luns;
+	scsi_host->this_id = asd->profile.initiator_id;
+	scsi_host->unique_id = asd->profile.unit = asd_get_unit();
+	scsi_host->irq = asd->profile.irq;	
+	asd_assign_host_lock(asd);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4) && \
+    LINUX_VERSION_CODE  < KERNEL_VERSION(2,5,0)	
+	scsi_set_pci_device(scsi_host, asd->dev);
+#endif	
+	asd_unlock(asd, &flags);
+
+	/*
+	 * Create a discovery thread and block the OS
+	 * discovery of targets until our first discovery
+	 * pass has completed.
+	 */
+	asd_freeze_hostq(asd);
+	asd->platform_data->flags |= ASD_DISCOVERY_INIT;
+
+	asd->platform_data->discovery_pid = kernel_thread(
+						asd_discovery_thread, 
+						asd, 0);
+	if (asd->platform_data->discovery_pid < 0) {
+		asd_print("%s: Failed to create discovery thread, error=%d\n",
+			  asd_name(asd), asd->platform_data->discovery_pid);
+		return (-asd->platform_data->discovery_pid);
+	}
+
+	asd->platform_data->ehandler_pid = kernel_thread(
+						asd_ehandler_thread, 
+						asd, 0);
+	if (asd->platform_data->ehandler_pid < 0) {
+		asd_print("%s: Failed to create error handler thread, "
+			  "error=%d\n",
+			  asd_name(asd), asd->platform_data->ehandler_pid);
+		return (-asd->platform_data->ehandler_pid);
+	}
+
+#ifdef ASD_EH_SIMULATION		
+	asd->platform_data->eh_simul_pid = kernel_thread(
+						asd_eh_simul_thread, 
+						asd, 0);
+	if (asd->platform_data->eh_simul_pid < 0) {
+		asd_print("%s: Failed to create eh_simul thread, error=%d\n",
+			  asd_name(asd), asd->platform_data->eh_simul_pid);
+		return (-asd->platform_data->eh_simul_pid);
+	}
+#endif
+
+	return (0);
+}
+
+/*
+ * Function:
+ * __asd_unregister_host()
+ *
+ * Description:
+ * Revert what asd_register_host() did.  This function is to be used
+ * from asd_detect().
+ */
+static void __asd_unregister_host(struct asd_softc *asd)
+{
+#ifdef ASD_EH_SIMULATION
+	/* shutdown the simulation thread */
+	asd->platform_data->flags |= ASD_EH_SIMUL_SHUTDOWN;
+	up(&asd->platform_data->eh_simul_sem);
+#endif /* ASD_EH_SIMULATION */
+
+	/* shutdown the eh and discovery thread */
+	asd->platform_data->flags |=
+		(ASD_RECOVERY_SHUTDOWN | ASD_DISCOVERY_SHUTDOWN);
+	up(&asd->platform_data->ehandler_sem);
+	up(&asd->platform_data->discovery_sem);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	scsi_remove_host(asd->platform_data->scsi_host);
+	scsi_host_put(asd->platform_data->scsi_host);
+#else
+	scsi_unregister(asd->platform_data->scsi_host);
+#endif 
+}
+
+/***************************** Queue Handling ********************************/
+
+struct asd_device *
+asd_alloc_device(struct asd_softc *asd, struct asd_target *targ,
+		 u_int ch, u_int id, u_int lun)
+{
+	struct asd_device *dev;
+
+	dev = asd_alloc_mem(sizeof(*dev), GFP_ATOMIC);
+	if (dev == NULL)
+		return (NULL);
+
+	memset(dev, 0, sizeof(*dev));
+	init_timer(&dev->timer);
+	INIT_LIST_HEAD(&dev->busyq);
+	dev->flags = ASD_DEV_UNCONFIGURED;
+	dev->ch = ch;
+	dev->id = id;
+	dev->lun = lun;
+	memcpy(dev->saslun, &lun, sizeof(u_int)/*8*/);//TBD
+	dev->target = targ;
+#ifdef MULTIPATH_IO
+	dev->current_target = targ;
+#endif
+
+	/*
+	 * We start out life using untagged
+	 * transactions of which we allow one.
+	 */
+	dev->openings = 1;
+
+	/*
+	 * Set maxtags to 0.  This will be changed if we
+	 * later determine that we are dealing with
+	 * a tagged queuing capable device.
+	 */
+	dev->maxtags = 0;
+	
+	targ->devices[lun] = dev;
+	asd_target_addref(targ);
+
+	return (dev);
+}
+
+void
+asd_free_device(struct asd_softc *asd, struct asd_device *dev)
+{
+	struct asd_target *targ;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,41)
+	/*
+	 * Ensure no scheduled workqueue entry is running for
+	 * this device prior freeing the device.
+	 */
+	if ((dev->flags & ASD_DEV_DPC_ACTIVE) != 0)
+		flush_scheduled_work();
+#endif	
+	targ = dev->target;
+	targ->devices[dev->lun] = NULL;
+	asd_free_mem(dev);
+	asd_target_release(asd, targ);
+	targ->flags &= ~ASD_TARG_MAPPED;
+}
+
+struct asd_target *
+asd_alloc_target(struct asd_softc *asd, struct asd_port *src_port)
+{
+	struct asd_target *targ;
+
+	targ = asd_alloc_mem(sizeof(*targ), GFP_ATOMIC);
+	if (targ == NULL)
+		return (NULL);
+	memset(targ, 0, sizeof(*targ));
+
+	/*
+	 * By default, we are not mapped into
+	 * the OS topology view.
+	 */
+	targ->domain = NULL;
+	targ->target_id = ASD_MAX_TARGET_IDS;
+
+	/*
+	 * Targets stay around until some event drops
+	 * the sentinel reference count on the object.
+	 */
+	targ->refcount = 0;
+
+	targ->softc = asd;
+	targ->flags |= ASD_TARG_FLAGS_NONE;
+	targ->src_port = src_port;
+	INIT_LIST_HEAD(&targ->children);
+	INIT_LIST_HEAD(&targ->siblings);
+	INIT_LIST_HEAD(&targ->all_domain_targets);
+	INIT_LIST_HEAD(&targ->validate_links);
+	INIT_LIST_HEAD(&targ->multipath);
+	init_timer(&targ->timer);
+	return (targ);
+}
+
+void
+asd_free_target(struct asd_softc *asd, struct asd_target *targ)
+{
+	list_del(&targ->children);
+	list_del(&targ->siblings);
+	list_del(&targ->multipath);
+	list_del(&targ->all_domain_targets);
+
+	if (targ->domain != NULL) {
+		asd_domain_release(asd, targ);
+		targ->domain = NULL;
+	}
+
+	if (targ->Phy != NULL) {
+		asd_free_mem(targ->Phy);
+	}
+
+	if (targ->RouteTable != NULL) {
+		asd_free_mem(targ->RouteTable);
+	}
+
+	asd_free_mem(targ);
+}
+
+static struct asd_domain *
+asd_alloc_domain(struct asd_softc *asd, u_int channel_mapping)
+{
+	struct asd_domain *dm;
+
+	dm = asd_alloc_mem(sizeof(*dm), GFP_ATOMIC);
+	if (dm == NULL)
+		return (NULL);
+
+	memset(dm, 0, sizeof(*dm));
+	asd->platform_data->domains[channel_mapping] = dm;
+	dm->channel_mapping = channel_mapping;
+
+	dm->refcount = 0;
+
+	return (dm);
+}
+
+static void
+asd_free_domain(struct asd_softc *asd, struct asd_domain *dm)
+{
+	u_int i;
+
+	for (i = 0; i < ASD_MAX_TARGET_IDS; i++) {
+		if (dm->targets[i] != NULL) {
+			asd_print("%s: Freeing non-empty domain %p!\n",
+				  asd_name(asd), dm);
+			break;
+		}
+	}
+	asd->platform_data->domains[dm->channel_mapping] = NULL;
+	asd_free_mem(dm);
+}
+
+static void
+asd_flush_device_queue(struct asd_softc *asd, struct asd_device *dev)
+{
+	union asd_cmd 		*acmd;
+	struct scsi_cmnd 	*cmd;
+	struct scb 		*scb;
+	struct asd_port		*port;
+	ASD_COMMAND_BUILD_STATUS build_status;
+
+	ASD_LOCK_ASSERT(asd);
+
+	if ((dev->flags & ASD_DEV_ON_RUN_LIST) != 0)
+		panic("asd_flush_device_queue: running device on run list");
+
+	while (!list_empty(&dev->busyq) && (dev->openings > 0) && 
+	       (dev->qfrozen == 0) && (dev->target->qfrozen == 0)) {
+
+		if (asd->platform_data->qfrozen != 0) {
+			/*
+			 * Schedule us to run later.  The only reason we are not
+			 * running is because the whole controller Q is frozen.
+			 */
+			list_add_tail(&dev->links,
+				      &asd->platform_data->device_runq);
+			dev->flags |= ASD_DEV_ON_RUN_LIST;
+			return;
+		}
+
+		port = dev->target->src_port;
+		if (((port->events & ASD_DISCOVERY_PROCESS) != 0) && 
+		    ((port->events & ASD_DISCOVERY_REQ) != 0)) {
+			/*
+			 * Discovery is requested / on-going for the port
+			 * that the device is currently attached to.
+			 * Prevent any new IOs going to the device until
+			 * the discovery is done and configuration is
+			 * validated.
+			 */
+			list_add_tail(&dev->links,
+				      &asd->platform_data->device_runq);
+			dev->flags |= ASD_DEV_ON_RUN_LIST;
+			return;
+		}
+
+		acmd = list_entry(dev->busyq.next, union asd_cmd, acmd_links);
+		list_del(&acmd->acmd_links);
+		cmd = &acmd_scsi_cmd(acmd);
+
+		/*
+		 * The target is in the process of being destroyed as
+		 * it had been hot-removed. Return the IO back to the
+		 * scsi layer.
+		 */
+		if (dev->target->flags & ASD_TARG_HOT_REMOVED) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+			asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+			asd_cmd_set_offline_status(cmd);
+#endif
+			cmd->scsi_done(cmd);
+			continue;
+		}
+
+		if (cmd->sc_magic != ASD_CSMI_COMMAND) {
+			/*
+			 * Get an scb to use.
+			 */
+			if ((scb = asd_hwi_get_scb(asd, 0)) == NULL) {
+				list_add_tail(&acmd->acmd_links, &dev->busyq);
+				list_add_tail(&dev->links,
+					      &asd->platform_data->device_runq);
+				dev->flags |= ASD_DEV_ON_RUN_LIST;
+				asd->flags |= ASD_SCB_RESOURCE_SHORTAGE;
+				asd->platform_data->qfrozen++;
+				return;
+			}
+
+			scb->platform_data->dev = dev;
+			scb->platform_data->targ = dev->target;
+			cmd->host_scribble = (char *)scb;
+			/*
+			 * SCB build handlers return zero status to indicate
+			 * that the SCB should be queued to the controller.
+			 * Any other status indicates that the OS's cmd
+			 * structure should be completed and that the build
+			 * handler has updated its status accordingly.
+			 */
+			switch (dev->target->command_set_type) {
+			case ASD_COMMAND_SET_SCSI:
+				build_status = asd_build_sas_scb(
+					asd, scb, acmd);
+				break;
+
+			case ASD_COMMAND_SET_ATA:
+				build_status = asd_build_ata_scb(
+					asd, scb, acmd);
+
+				break;
+
+			case ASD_COMMAND_SET_ATAPI:
+				build_status = asd_build_atapi_scb(
+					asd, scb, acmd);
+				break;
+
+			default:
+				build_status = ASD_COMMAND_BUILD_FAILED;
+				asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+
+				/*
+				 * Fall through to complete and free the scb.
+				 */
+				break;
+			}
+
+			if (build_status != ASD_COMMAND_BUILD_OK) {
+				/*
+				 * Two cases here:
+				 * 1) The command has been emulated, and it
+				 *    is ASD_COMMAND_BUILD_FINISHED
+				 * 2) The command was malformed and it is
+				 *    ASD_COMMAND_BUILD_FAILED.
+				 */
+				asd_hwi_free_scb(asd, scb);
+				cmd->scsi_done(cmd);
+				continue;
+			}
+		} else {
+			/* command generated by CSMI */
+			scb = (struct scb *)cmd->host_scribble;
+		}
+
+		dev->openings--;
+		dev->active++;
+		dev->commands_issued++;
+		list_add_tail(&scb->owner_links,
+			      &asd->platform_data->pending_os_scbs);
+		scb->flags |= SCB_ACTIVE;
+		asd_hwi_post_scb(asd, scb);
+
+#ifdef ASD_EH_SIMULATION
+		if (asd_cmd_get_host_status(cmd) == 0x88) {
+			scb->flags |= SCB_TIMEDOUT;
+			scb->eh_state = SCB_EH_DEV_RESET_REQ;
+			scb->eh_post = asd_eh_simul_done;
+			list_add_tail(&scb->timedout_links, 
+				      &asd->timedout_scbs);
+			asd_print("Adding scb(%d) to timedout queue for "
+				  "error recv. simulation.\n",
+				  SCB_GET_INDEX(scb));
+			asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+		}
+#endif /* ASD_EH_SIMULATION */
+		if (cmd->sc_magic == ASD_CSMI_COMMAND)
+			asd_free_mem(cmd);
+	}
+
+}
+
+#ifdef ASD_EH_SIMULATION
+static void
+asd_eh_simul_done(struct asd_softc *asd, struct scb *scb)
+{
+	asd_print("EH SIMULATION DONE.\n");
+}
+
+static int
+asd_eh_simul_thread(void *data)
+{
+	struct asd_softc	*asd;
+	struct scb		*scb;
+	u_long			 flags;	
+
+	asd = (struct asd_softc *) data;
+
+	lock_kernel();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,60)
+	/*
+	 * Don't care about any signals.
+	 */
+	siginitsetinv(&current->blocked, 0);
+	daemonize();
+	sprintf(current->comm, "asd_eh_simul_%d", asd->profile.unit);
+#else
+	daemonize("asd_eh_simul_%d", asd->profile.unit);
+	current->flags |= PF_FREEZE;	
+#endif
+	unlock_kernel();
+
+	while (1) {
+sleep:
+		down_interruptible(&asd->platform_data->eh_simul_sem);
+
+		/* Check to see if we've been signaled to exit. */
+		asd_lock(asd, &flags);
+		if ((asd->platform_data->flags & ASD_EH_SIMUL_SHUTDOWN) != 0) {
+			asd_unlock(asd, &flags);
+			break;
+		}
+
+		asd_unlock(asd, &flags);
+		
+		if (!list_empty(&asd->timedout_scbs)) {
+			scb = list_entry(asd->timedout_scbs.next, struct scb, 
+				 timedout_links);
+			if (scb == NULL) {
+				asd_print("Timedout queue is empty.\n");
+				goto sleep;
+			}
+
+			asd_lock(asd, &flags);
+
+			list_del(&scb->timedout_links);
+			scb->flags &= ~SCB_TIMEDOUT;
+		
+			asd_unlock(asd, &flags);
+		}
+	}
+
+	return (0);
+}
+#endif /* ASD_EH_SIMULATION */
+
+static void
+asd_dev_timed_unfreeze(u_long arg)
+{
+	struct asd_softc	*asd;
+	struct asd_device	*dev;
+	u_long			 flags;
+
+	dev = (struct asd_device *) arg;
+	asd = dev->target->softc;
+	
+	asd_lock(asd, &flags);
+	/*
+	 * Release our hold on the device.
+	 */
+	dev->flags &= ~ASD_DEV_TIMER_ACTIVE;
+	dev->active--;
+
+	if (dev->qfrozen > 0)
+		dev->qfrozen--;
+
+	if ((dev->qfrozen == 0) && (dev->target->qfrozen == 0) &&
+	    ((dev->flags & ASD_DEV_ON_RUN_LIST) == 0))
+		asd_flush_device_queue(asd, dev);
+	
+	if ((dev->flags & ASD_DEV_UNCONFIGURED) != 0 &&
+	     list_empty(&dev->busyq) && dev->active == 0) {
+		asd_free_device(asd, dev);
+	}
+	asd_unlock(asd, &flags);
+}
+
+void
+asd_timed_run_dev_queue(u_long arg)
+{
+	struct asd_softc	*asd;
+	struct asd_device	*dev;
+	u_long			 flags;
+
+	dev = (struct asd_device *) arg;
+	asd = dev->target->softc;
+	
+	asd_lock(asd, &flags);
+
+	dev->flags &= ~ASD_DEV_TIMER_ACTIVE;
+
+	if ((dev->qfrozen == 0) && (dev->target->qfrozen == 0) &&
+	    ((dev->target->flags & ASD_TARG_HOT_REMOVED) == 0) &&
+	    ((dev->flags & ASD_DEV_ON_RUN_LIST) == 0)) {
+
+		asd_flush_device_queue(asd, dev);
+	} else {
+		asd_log(ASD_DBG_ERROR, "DEV QF: %d TARG QF: %d "
+			"DEV FL: 0x%x TARG FL: 0x%x. ptarget=%p\n",
+			dev->qfrozen, dev->target->qfrozen,
+			dev->flags, dev->target->flags,dev->target);
+	}
+
+	asd_unlock(asd, &flags);
+}
+	
+static void
+asd_scb_done(struct asd_softc *asd, struct scb *scb, struct asd_done_list *dl)
+{
+	Scsi_Cmnd 		*cmd;
+	struct asd_device *dev;
+
+	if ((scb->flags & SCB_ACTIVE) == 0) {
+		asd_print("SCB %d done'd twice\n", SCB_GET_INDEX(scb));
+		panic("Stopping for safety");
+	}
+
+	list_del(&scb->owner_links);
+
+	cmd = &acmd_scsi_cmd(scb->io_ctx);
+	dev = scb->platform_data->dev;
+	dev->active--;
+	dev->openings++;
+	if ((scb->flags & SCB_DEV_QFRZN) != 0) {
+		scb->flags &= ~SCB_DEV_QFRZN;
+		dev->qfrozen--;
+	}
+
+	asd_unmap_scb(asd, scb);
+
+	/*
+	 * Guard against stale sense data.
+	 * The Linux mid-layer assumes that sense
+	 * was retrieved anytime the first byte of
+	 * the sense buffer looks "sane".
+	 */
+	cmd->sense_buffer[0] = 0;
+	cmd->resid = 0;
+//JD
+#ifdef ASD_DEBUG
+	if( (dl->opcode != TASK_COMP_WO_ERR) && (dl->opcode != TASK_COMP_W_UNDERRUN) ) 
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+		asd_log(ASD_DBG_INFO, "asd_scb_done with error cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x abort:%d) dl->opcode 0x%x\n",
+#else
+		asd_log(ASD_DBG_INFO, "asd_scb_done with error cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x) dl->opcode 0x%x\n",
+#endif
+			cmd->cmnd[2],
+			cmd->cmnd[3],
+			cmd->cmnd[4],
+			cmd->cmnd[5],
+			cmd->cmnd[7],
+			cmd->cmnd[8],
+		  cmd->tag,
+		  cmd->pid,
+		  cmd->resid,
+		  cmd->timeout_per_command,
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+		  cmd->abort_reason,
+#endif
+		  dl->opcode);
+#endif
+	switch (dl->opcode) {
+	case TASK_COMP_W_UNDERRUN:
+		cmd->resid = asd_le32toh(dl->stat_blk.data.res_len);
+		/* FALLTHROUGH */
+	case TASK_COMP_WO_ERR:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		break;
+	
+	case SSP_TASK_COMP_W_RESP:
+	{
+		union edb 		*edb;
+		struct response_sb   	*rsp;
+		struct ssp_resp_edb  	*redb;
+		struct scb 		*escb;
+		u_int  			 escb_index;
+		u_int			 edb_index;
+
+		rsp = &dl->stat_blk.response;
+		escb_index = asd_le16toh(rsp->empty_scb_tc);
+		edb_index = RSP_EDB_ELEM(rsp) - 1;
+		edb = asd_hwi_indexes_to_edb(asd, &escb, escb_index, edb_index);
+		if (edb == NULL) {
+			asd_print("Invalid EDB recv for SSP comp w/response.\n"
+				  "Returning generic error to OS.\n");
+			asd_cmd_set_host_status(cmd, DID_ERROR);
+			break;
+		}
+		redb = &edb->ssp_resp;
+		cmd->resid = asd_le32toh(redb->res_len);
+		asd_handle_sas_status(asd, dev, scb, redb, RSP_EDB_BUFLEN(rsp));
+		asd_hwi_free_edb(asd, escb, edb_index);
+		break;
+	}
+	case TASK_ABORTED_ON_REQUEST:
+		asd_cmd_set_host_status(cmd, DID_ABORT);
+		break;
+	
+	case TASK_CLEARED:
+	{
+		struct task_cleared_sb	*task_clr;
+
+		task_clr = &dl->stat_blk.task_cleared;
+
+		asd_log(ASD_DBG_ERROR," Task Cleared for Tag: 0x%x, "
+			"TC: 0x%x.\n",
+			task_clr->tag_of_cleared_task, SCB_GET_INDEX(scb));
+
+		/*
+		 * Pending command at the firmware's queues aborted upon
+		 * request. If the device is offline then failed the IO.
+		 * Otherwise, have the command retried again.
+	         */
+		if (task_clr->clr_nxs_ctx == ASD_TARG_HOT_REMOVED) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+			asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+			asd_cmd_set_offline_status(cmd);
+#endif
+		} else
+			asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+
+		break;
+	}
+
+	case TASK_INT_W_BRK_RCVD:
+		asd_log(ASD_DBG_ERROR, "TASK INT. WITH BREAK RECEIVED.\n");
+		asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+		break;
+
+	case TASK_ABORTED_BY_ITNL_EXP:
+	{
+		struct itnl_exp_sb	*itnl_exp;
+
+		itnl_exp = &dl->stat_blk.itnl_exp;
+
+		asd_log(ASD_DBG_ERROR, "ITNL EXP for SCB 0x%x Reason = 0x%x.\n",
+			SCB_GET_INDEX(scb), itnl_exp->reason);
+		
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+		asd_cmd_set_offline_status(cmd);
+#endif
+		break;
+	}
+
+	case TASK_F_W_NAK_RCVD:
+	{
+		asd_log(ASD_DBG_ERROR, "TASK FAILED WITH NAK RECEIVED.\n");
+		asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+		break;
+	}
+
+	default:
+		asd_log(ASD_DBG_ERROR, "UNHANDLED TASK.\n");
+		asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+		break;
+	}
+
+	if ((dev->target->flags & ASD_TARG_HOT_REMOVED) != 0) {
+		/*
+	 	 * If the target had been removed and all active IOs on 
+		 * the device have been completed, schedule the device to
+		 * be destroyed.
+	 	 */
+		if (list_empty(&dev->busyq) && (dev->active == 0) &&
+		   ((dev->flags & ASD_DEV_DESTROY_WAS_ACTIVE) != 0)) {
+			/*
+			 * Schedule a deferred process task to destroy
+		         * the device.
+			 */	 
+			asd_setup_dev_dpc_task(dev, asd_destroy_device);
+		}
+	} else {
+		if ((dev->flags & ASD_DEV_ON_RUN_LIST) == 0) {
+			list_add_tail(&dev->links,
+				      &asd->platform_data->device_runq);
+			dev->flags |= ASD_DEV_ON_RUN_LIST;
+		}
+	}
+
+	/*
+	 * Only free the scb if it hasn't timedout.
+	 * For SCB that has timedout, error recovery has invoked and
+	 * the timedout SCB will be freed in the error recovery path.
+	 */
+	if ((scb->flags & SCB_TIMEDOUT) == 0)
+		asd_hwi_free_scb(asd, scb);
+//JDTEST
+	else
+	{
+		asd_log(ASD_DBG_ERROR, "scb 0x%x SCB_TIMEDOUT(0x%x)\n",scb,scb->flags);
+		scb->flags |= SCB_ABORT_DONE;
+	}
+
+	
+	cmd->scsi_done(cmd);
+}
+
+void
+asd_scb_internal_done(struct asd_softc *asd, struct scb *scb,
+		      struct asd_done_list *dl)
+{
+	if ((scb->flags & SCB_ACTIVE) == 0) {
+		asd_print("SCB %d done'd twice\n", SCB_GET_INDEX(scb));
+		panic("Stopping for safety");
+	}
+	list_del(&scb->owner_links);
+
+	/*
+	 * In this case, "internal" means that the scb does not have
+	 * a Scsi_Cmnd associated with it.
+	 */
+	if ((scb->flags & SCB_INTERNAL) == 0) {
+		asd_unmap_scb(asd, scb);
+	}
+
+	switch (dl->opcode) {
+	case TASK_COMP_W_UNDERRUN:
+		/* FALLTHROUGH */
+	case TASK_COMP_WO_ERR:
+		break;
+	case SSP_TASK_COMP_W_RESP:
+	{
+		union	edb *edb;
+		struct	response_sb   *rsp;
+		struct	ssp_resp_edb  *redb;
+		struct	scb *escb;
+		u_int	escb_index;
+		u_int	edb_index;
+
+		rsp = &dl->stat_blk.response;
+		escb_index = asd_le16toh(rsp->empty_scb_tc);
+		edb_index = RSP_EDB_ELEM(rsp) - 1;
+		edb = asd_hwi_indexes_to_edb(asd, &escb, escb_index, edb_index);
+		if (edb == NULL) {
+			asd_print("Invalid EDB recv for SSP comp w/response.\n"
+				  "Returning generic error to OS.\n");
+			break;
+		}
+		redb = &edb->ssp_resp;
+		asd_hwi_free_edb(asd, escb, edb_index);
+	}
+	default:
+		break;
+	}
+
+	/*
+	 * Only free the scb if it hasn't timedout.
+	 * For SCB that has timedout, error recovery has invoked and
+	 * the timedout SCB will be freed in the error recovery path.
+	 */
+	if ((scb->flags & SCB_TIMEDOUT) == 0)
+		asd_hwi_free_scb(asd, scb);
+//JDTEST
+	else
+	{
+		scb->flags |= SCB_ABORT_DONE;
+		asd_log(ASD_DBG_ERROR, "scb 0x%x SCB_TIMEDOUT(0x%x)\n",scb,scb->flags);
+	}
+}
+
+static void
+asd_handle_sas_status(struct asd_softc *asd, struct asd_device *dev,
+		      struct scb *scb, struct ssp_resp_edb *edb, u_int edb_len)
+{
+	struct ssp_resp_iu 	*riu;
+	Scsi_Cmnd 		*cmd;
+
+	cmd = &acmd_scsi_cmd(scb->io_ctx);
+	riu = &edb->resp_frame.riu;
+	if (edb_len < offsetof(struct ssp_resp_edb, resp_frame.riu.res_2)) {
+		asd_print("Insufficient data recv for SSP comp w/response.\n"
+			  "Returning generic error to OS.\n");
+		asd_cmd_set_host_status(cmd, DID_ERROR);
+		return;
+	}
+
+	switch (SSP_RIU_DATAPRES(riu)) {
+	case SSP_RIU_DATAPRES_RESP:
+	{
+		uint8_t	resp_code;
+
+		resp_code = ((struct resp_data_iu *) &riu->data[0])->resp_code;
+
+		asd_print("Unhandled RESPONSE data (resp code: 0x%x).\n"
+			  "Returning generic error to OS.\n",
+			  resp_code);
+		asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+		return;
+	}
+
+	case SSP_RIU_DATAPRES_SENSE:
+	{
+		uint32_t sense_len;
+
+		/* Copy sense data. */
+		if (edb_len < offsetof(struct ssp_resp_edb,
+				       resp_frame.riu.sense_len)) {
+			asd_print("Insufficient data recv for sense len.\n"
+				  "Returning generic error to OS.\n");
+			asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+			return;
+		}
+		sense_len = edb_len - offsetof(struct ssp_resp_edb,
+					       resp_frame.riu.data);
+		sense_len = MIN(sense_len, scsi_4btoul(riu->sense_len));
+		if (sense_len <= 0) {
+			asd_print("Insufficient data recv for sense data.\n"
+				  "Returning generic error to OS.\n");
+			asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+			return;
+		}
+		sense_len = MIN(sizeof(cmd->sense_buffer), sense_len);
+		memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+		memcpy(cmd->sense_buffer, riu->data, sense_len);
+		asd_cmd_set_driver_status(cmd, DRIVER_SENSE);
+
+		/*
+		 * Power on reset or bus reset occurred, let's have the 
+		 * command retried again.
+		 */ 
+		if ((cmd->sense_buffer[2] == UNIT_ATTENTION) && 
+		    (cmd->sense_buffer[12] == 0x29)) {
+			asd_cmd_set_host_status(cmd, DID_ERROR);
+			break;
+		}
+	}
+		/* FALLTHROUGH*/
+	case SSP_RIU_DATAPRES_NONE:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		asd_cmd_set_scsi_status(cmd, riu->status);
+		break;
+
+	default:
+		asd_log(ASD_DBG_ERROR, "Unknown response frame format.\n"
+			"Returning generic error to OS.\n");
+		asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+		return;
+	}
+
+	/*
+	 * We don't currently trust the mid-layer to
+	 * properly deal with queue full or busy.  So,
+	 * when one occurs, we tell the mid-layer to
+	 * unconditionally requeue the command to us
+	 * so that we can retry it ourselves.  We also
+	 * implement our own throttling mechanism so
+	 * we don't clobber the device with too many
+	 * commands.
+	 */
+	switch (riu->status) {
+	case SCSI_STATUS_OK:
+	case SCSI_STATUS_CHECK_COND:
+	case SCSI_STATUS_COND_MET:
+	case SCSI_STATUS_INTERMED:
+	case SCSI_STATUS_INTERMED_COND_MET:
+	case SCSI_STATUS_RESERV_CONFLICT:
+	case SCSI_STATUS_CMD_TERMINATED:
+	case SCSI_STATUS_ACA_ACTIVE:
+	case SCSI_STATUS_TASK_ABORTED:
+		break;
+
+	case SCSI_STATUS_QUEUE_FULL:
+	{
+		/*
+		 * Note that dev->active may not be 100% accurate
+		 * since it counts commands in the outgoing SCB queue
+		 * that have yet to be seen by the end device.  In
+		 * practice, this doesn't matter since we will not queue
+		 * additional commands until we receive a successful
+		 * completion.  If we have not dropped the count to
+		 * the device's queue depth yet, we will see additional
+		 * queue fulls as the outgoing SCB queue drains, resulting
+		 * in further drops of the queue depth.
+		 */
+		asd_print_path(asd, dev);
+		asd_print("Queue Full!\n");
+		
+		dev->tag_success_count = 0;
+		if (dev->active != 0) {
+			/*
+			 * Drop our opening count to the number
+			 * of commands currently outstanding.
+			 */
+			dev->openings = 0;
+			asd_print_path(asd, dev);
+			asd_print("Dropping tag count to %d\n", dev->active);
+			if (dev->active == dev->tags_on_last_queuefull) {
+				dev->last_queuefull_same_count++;
+				/*
+				 * If we repeatedly see a queue full
+				 * at the same queue depth, this
+				 * device has a fixed number of tag
+				 * slots.  Lock in this tag depth
+				 * so we stop seeing queue fulls from
+				 * this device.
+				 */
+				if (dev->last_queuefull_same_count == 
+				    ASD_LOCK_TAGS_COUNT) {
+					dev->maxtags = dev->active;
+					asd_print_path(asd, dev);
+					asd_print("Locking tag count at %d\n",
+						  dev->active);
+				}
+			} else {
+				dev->tags_on_last_queuefull = dev->active;
+				dev->last_queuefull_same_count = 0;
+			}
+			
+			asd_set_tags(asd, dev,
+				    (dev->flags & ASD_DEV_Q_BASIC) ?
+				    ASD_QUEUE_BASIC : ASD_QUEUE_TAGGED);
+
+			asd_cmd_set_retry_status(cmd);
+			break;
+		}
+		/*
+		 * Drop down to a single opening, and treat this
+		 * as if the target returned BUSY SCSI status.
+		 */
+		dev->openings = 1;
+		asd_cmd_set_scsi_status(cmd, SCSI_STATUS_BUSY);
+		/* FALLTHROUGH */
+	}
+	case SCSI_STATUS_BUSY:
+		asd_log(ASD_DBG_ERROR, "REVISITED: SCSI_STATUS_BUSY");
+
+		/*
+		 * Set a short timer to defer sending commands for
+		 * a bit since Linux will not delay in this case.
+		 */
+		if ((dev->flags & ASD_DEV_TIMER_ACTIVE) != 0) {
+			asd_print("%s:%c:%d: Device Timer still active during "
+				  "busy processing\n", asd_name(asd),
+				  dev->target->domain->channel_mapping,
+				  dev->target->target_id);
+			break;
+		}
+		dev->qfrozen++;
+		/*
+		 * Keep the active count non-zero during
+		 * the lifetime of the timer.  This
+		 * guarantees that the device will not
+		 * be freed before our timer executes.
+		 */
+		dev->active++;
+		dev->flags |= ASD_DEV_TIMER_ACTIVE;
+		init_timer(&dev->timer);
+		dev->timer.data = (u_long) dev;
+		dev->timer.expires = jiffies + (HZ/2);
+		dev->timer.function = asd_dev_timed_unfreeze;
+		add_timer(&dev->timer);
+		break;
+	default:
+		/*
+		 * Unknown scsi status returned by the target.
+		 *  Have the command retried.
+		 */ 
+		asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+		break;
+	}
+}
+
+ASD_COMMAND_BUILD_STATUS
+asd_setup_data(struct asd_softc *asd, struct scb *scb, Scsi_Cmnd *cmd)
+{
+	struct asd_ssp_task_hscb *ssp_hscb;
+	struct sg_element 	 *sg;
+	int			  dir;
+	int			  error;
+
+	/*
+	 * All SSP, STP, and SATA SCBs have their direction
+	 * flags and SG/elements in the same place, so using
+	 * any of their definitions here is safe.
+	 */
+	ssp_hscb = &scb->hscb->ssp_task;
+	scb->sg_count = 0;
+	error = 0;
+
+	if (cmd->use_sg != 0) {
+		struct	scatterlist *cur_seg;
+		u_int	nseg;
+
+		cur_seg = (struct scatterlist *)cmd->request_buffer;
+		dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+		nseg = asd_map_sg(asd, cur_seg, cmd->use_sg, dir);
+		scb->sg_count = nseg;
+		if (nseg > ASD_NSEG) {
+			asd_unmap_sg(asd, cur_seg, nseg, dir);
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+		for (sg = scb->sg_list; nseg > 0; nseg--, cur_seg++, sg++) {
+			dma_addr_t addr;
+			uint32_t len;
+
+			addr = sg_dma_address(cur_seg);
+			len = sg_dma_len(cur_seg);
+			error = asd_sg_setup(sg, addr, len, /*last*/nseg == 1);
+			if (error != 0)
+				break;
+		}
+		if (error != 0) {
+			asd_unmap_sg(asd, cur_seg, scb->sg_count, dir);
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+	} else if (cmd->request_bufflen != 0) {
+		dma_addr_t addr;
+
+		sg = scb->sg_list;
+		dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+		addr = asd_map_single(asd,
+				      cmd->request_buffer,
+				      cmd->request_bufflen, dir);
+		scb->platform_data->buf_busaddr = addr;
+		error = asd_sg_setup(sg, addr, cmd->request_bufflen, /*last*/1);
+		if (error != 0) {
+			asd_unmap_single(asd, addr, cmd->request_bufflen, dir);
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+		scb->sg_count = 1;
+	} else {
+		scb->sg_count = 0;
+		dir = PCI_DMA_NONE;
+	}
+
+	if (scb->sg_count != 0) {
+		size_t sg_copy_size;
+
+		sg_copy_size = scb->sg_count * sizeof(*sg);
+		if (scb->sg_count > 3)
+			sg_copy_size = 2 * sizeof(*sg);
+		memcpy(ssp_hscb->sg_elements, scb->sg_list, sg_copy_size);
+		if (scb->sg_count > 3) {
+			/*
+			 * Setup SG sub-list.
+			 */
+			sg = &ssp_hscb->sg_elements[1];
+			sg->next_sg_offset = 2 * sizeof(*sg);
+			sg->flags |= SG_EOS;
+			sg++;
+			sg->bus_address = asd_htole64(scb->sg_list_busaddr);
+			memset(&sg->length, 0,
+			       sizeof(*sg)-offsetof(struct sg_element, length));
+		}
+	}
+
+	switch (dir) {
+	case PCI_DMA_BIDIRECTIONAL:
+		ssp_hscb->data_dir_flags |= DATA_DIR_UNSPECIFIED;
+		break;
+	case PCI_DMA_TODEVICE:
+		ssp_hscb->data_dir_flags |= DATA_DIR_OUTBOUND;
+		break;
+	case PCI_DMA_FROMDEVICE:
+		ssp_hscb->data_dir_flags |= DATA_DIR_INBOUND;
+		break;
+	case PCI_DMA_NONE:
+		ssp_hscb->data_dir_flags |= DATA_DIR_NO_XFER;
+		break;
+	}
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+static ASD_COMMAND_BUILD_STATUS
+asd_build_sas_scb(struct asd_softc *asd, struct scb *scb, union asd_cmd *acmd)
+{
+	struct asd_ssp_task_hscb	*ssp_hscb;
+	struct asd_target 		*targ;
+	Scsi_Cmnd 			*cmd;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) 
+	int				 msg_bytes;
+	uint8_t 			 tag_msgs[2];
+#endif
+
+	asd_push_post_stack(asd, scb, acmd, asd_scb_done);
+
+	cmd = &acmd_scsi_cmd(acmd);
+#ifdef MULTIPATH_IO
+	targ = scb->platform_data->dev->current_target;
+
+	scb->platform_data->dev->current_target = list_entry(
+		scb->platform_data->dev->current_target->multipath.next,
+		struct asd_target, multipath);
+#else
+	targ = scb->platform_data->dev->target;
+#endif
+	ssp_hscb = &scb->hscb->ssp_task;
+
+	ssp_hscb->header.opcode = SCB_INITIATE_SSP_TASK;
+
+	/*
+	 * Build the SAS frame header.
+	 */
+	asd_build_sas_header(targ, ssp_hscb);
+
+	ssp_hscb->protocol_conn_rate |= PROTOCOL_TYPE_SSP;
+	ssp_hscb->xfer_len = asd_htole32(cmd->request_bufflen);
+
+	/*
+	 * Hnadle for multi-lun devices. 
+	 */
+	memcpy(ssp_hscb->lun, scb->platform_data->dev->saslun, SAS_LUN_LEN);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) 
+	msg_bytes = scsi_populate_tag_msg(cmd, tag_msgs);
+	if (msg_bytes && tag_msgs[0] != MSG_SIMPLE_TAG)
+		ssp_hscb->task_attr |= tag_msgs[0] & 0x3;
+#endif
+	memcpy(ssp_hscb->cdb, cmd->cmnd, cmd->cmd_len);
+	memset(&ssp_hscb->cdb[cmd->cmd_len], 0,
+	       SCB_EMBEDDED_CDB_SIZE - cmd->cmd_len);
+
+	return (asd_setup_data(asd, scb, cmd));
+}
+
+/*
+ * This routine is called from a tasklet, so we must re-acquire
+ * our lock prior when accessing data-structures that need protection.
+ */
+static void
+asd_runq_tasklet(unsigned long data) {
+	struct asd_softc	*asd;
+	struct asd_device 	*dev;
+	u_long			 flags;
+
+	asd = (struct asd_softc *) data;
+	asd_lock(asd, &flags);
+	while ((dev = asd_next_device_to_run(asd)) != NULL) {
+		list_del(&dev->links);
+		dev->flags &= ~ASD_DEV_ON_RUN_LIST;
+		asd_check_device_queue(asd, dev);
+		/* Yeild to our interrupt handler */
+		asd_unlock(asd, &flags);
+		asd_lock(asd, &flags);
+	}
+	asd_unlock(asd, &flags);
+}
+
+static void
+asd_unblock_tasklet(unsigned long data)
+{
+	struct asd_softc *asd;
+
+	asd = (struct asd_softc *) data;
+	scsi_unblock_requests(asd->platform_data->scsi_host);
+}
+
+/*
+ * Function:
+ * 	asd_discovery_thread()
+ *
+ * Description:
+ *	Thread to handle device discovery, topology changes and async. event
+ *	from attached device(s).
+ */	   	  
+static int
+asd_discovery_thread(void *data)
+{
+	struct asd_softc	*asd;
+	u_long			 flags;
+	u_char			 id;
+
+	asd = (struct asd_softc *) data;
+
+	lock_kernel();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,60)
+	/*
+	 * Don't care about any signals.
+	 */
+	siginitsetinv(&current->blocked, 0);
+	daemonize();
+	sprintf(current->comm, "asd_disc_%d", asd->profile.unit);
+#else
+	daemonize("asd_disc_%d", asd->profile.unit);
+	current->flags |= PF_FREEZE;	
+#endif
+	unlock_kernel();
+	
+	while (1) {
+		int 	pending;
+
+		/*
+		 * Use down_interruptible() rather than down() to
+		 * avoid inclusion in the load average.
+		 */
+		down_interruptible(&asd->platform_data->discovery_sem);
+
+		/* Check to see if we've been signaled to exit. */
+		asd_lock(asd, &flags);
+		if ((asd->platform_data->flags & ASD_DISCOVERY_SHUTDOWN) != 0) {
+			asd_unlock(asd, &flags);
+			break;
+		}
+		asd_unlock(asd, &flags);
+
+		/*
+		 * For now, only handle ID ADDR RCVD event.
+		 */
+		pending = 0;
+		for (id = 0; id < asd->hw_profile.max_phys; id++)
+			pending += asd_check_phy_events(asd, id);
+
+		for (id = 0; id < asd->hw_profile.max_ports; id++)
+			pending += asd_check_port_events(asd, id);
+
+		if (pending == 0) {
+			asd_lock(asd, &flags);
+			asd->platform_data->flags &= ~ASD_DISCOVERY_INIT;
+			asd_unlock(asd, &flags);
+			asd_release_hostq(asd);
+		}
+	}
+
+	up(&asd->platform_data->discovery_ending_sem);
+
+	return (0);
+}
+
+/*
+ * Function:
+ * 	asd_kill_discovery_thread()
+ * 
+ * Description:
+ * 	Kill the discovery thread.
+ */
+static void
+asd_kill_discovery_thread(struct asd_softc *asd)
+{
+	u_long	flags;
+
+	asd_lock(asd, &flags);
+
+	if (asd->platform_data->discovery_pid != 0) {
+		asd->platform_data->flags |= ASD_DISCOVERY_SHUTDOWN;
+		asd_unlock(asd, &flags);
+
+		up(&asd->platform_data->discovery_sem);
+
+		/*
+		 * Wait for the discovery thread to exit before continuing
+		 * with the unloading processes.
+		 */
+		down_interruptible(&asd->platform_data->discovery_ending_sem);
+
+		asd->platform_data->discovery_pid = 0;
+	} else {
+		asd_unlock(asd, &flags);
+	}
+}
+
+#ifdef ASD_EH_SIMULATION
+/*
+ * Function:
+ * 	asd_kill_eh_simul_thread()
+ * 
+ * Description:
+ * 	Kill the EH Simulation thread.
+ */ 	   	  
+static void
+asd_kill_eh_simul_thread(struct asd_softc  *asd)
+{
+	u_long	flags;
+
+	asd_lock(asd, &flags);
+
+	if (asd->platform_data->eh_simul_pid != 0) {
+		asd->platform_data->flags |= ASD_EH_SIMUL_SHUTDOWN;
+		asd_unlock(asd, &flags);
+		up(&asd->platform_data->eh_simul_sem);
+		down_interruptible(&asd->platform_data->ehandler_ending_sem);
+		asd->platform_data->eh_simul_pid = 0;
+	} else {
+		asd_unlock(asd, &flags);
+	}
+}
+#endif /* ASD_EH_SIMULATION */
+
+/*
+ * Function:
+ *	asd_check_phy_events()
+ *	
+ * Description:
+ *	Check if any phy events that needs to be handled.
+ */
+static int
+asd_check_phy_events(struct asd_softc *asd, u_int phy_id)
+{
+	struct	asd_phy	*phy;
+	u_long		 flags;
+
+	phy = asd->phy_list[phy_id];
+
+	asd_lock(asd, &flags);
+
+	if ((phy->state != ASD_PHY_WAITING_FOR_ID_ADDR) &&
+	    (list_empty(&phy->pending_scbs))) {
+		asd_unlock(asd, &flags);
+		return 0;
+	}
+
+	if ((phy->state == ASD_PHY_WAITING_FOR_ID_ADDR) &&
+	    ((phy->attr & ASD_SATA_SPINUP_HOLD) != 0) &&
+	    (list_empty(&phy->pending_scbs))) {
+
+		asd_hwi_release_sata_spinup_hold(asd, phy);
+
+		return 1;
+	}
+
+	/* Handle ID Address Frame that has been received. */
+	if ((phy->events & ASD_ID_ADDR_RCVD) != 0) {
+		asd_process_id_addr_evt(asd, phy);
+		phy->events &= ~ASD_ID_ADDR_RCVD;
+		phy->state = ASD_PHY_CONNECTED;
+	}
+
+	asd_unlock(asd, &flags);
+
+	return 1;
+}
+
+/*
+ * Function:
+ *	asd_check_port_events()
+ *
+ * Description:
+ *	Check if any port events that need to be handled.
+ */
+static int
+asd_check_port_events(struct asd_softc *asd, u_int port_id)
+{
+	struct asd_port	*port;
+
+	port = asd->port_list[port_id];
+//JD
+#ifdef ASD_DEBUG
+	if(port->events != 0)
+		asd_log(ASD_DBG_INFO, "asd_check_port_events:port(0x%x)->events=0x%x\n",port_id,port->events);
+#endif
+	if ((port->events & ASD_DISCOVERY_PROCESS) != 0) {
+		if ((port->events & ASD_DISCOVERY_EVENT) != 0) {
+			port->events &= ~ASD_DISCOVERY_EVENT;
+
+			asd_run_state_machine(&port->dc.sm_context);
+		}
+
+		if ((port->events & ASD_DISCOVERY_PROCESS) != 0) {
+			return 1;
+		}
+	}
+//JD wait until previous discovery is finished to re-start a new one
+	else
+	{
+		if (((port->events & ASD_DISCOVERY_REQ) != 0) || 
+			((port->events & ASD_DISCOVERY_RETRY) != 0)) {
+			if (asd_initiate_port_discovery(asd, port) == 0) {
+				port->events |= ASD_DISCOVERY_PROCESS;
+			/* 
+			 * Only clear the event if it is handled successfully. 
+			 */
+				if ((port->events & ASD_VALIDATION_REQ) != 0) {
+				/*
+				 * Validate any targets if needed.
+				 */
+					if (!list_empty(&port->targets_to_validate))
+						asd_configure_port_targets(asd, port);
+
+					port->events &= ~ASD_VALIDATION_REQ;
+				}
+
+				port->events &= ~(ASD_DISCOVERY_REQ | 
+					ASD_DISCOVERY_RETRY | ASD_VALIDATION_REQ);
+
+				asd_do_discovery(asd, port);
+			}
+		}
+	}
+
+	if ((port->events & ASD_LOSS_OF_SIGNAL) != 0) {
+		asd_handle_loss_of_signal(asd, port);
+		port->events &= ~ASD_LOSS_OF_SIGNAL;
+	}
+
+	if ((port->events & ASD_VALIDATION_REQ) != 0) {
+		/*
+		 * Validate any targets if needed.
+		 */
+		if (!list_empty(&port->targets_to_validate))
+			asd_configure_port_targets(asd, port);
+
+		port->events &= ~ASD_VALIDATION_REQ;
+	}
+
+	return (0);
+}
+
+/*
+ * Function:
+ *	asd_configure_port_targets
+ *
+ * Description:
+ *	Configure any new targets that have been added.
+ *	Clean up targets that have been removed.
+ */
+static void
+asd_configure_port_targets(struct asd_softc *asd, struct asd_port *port)
+{
+	struct asd_target	*targ;
+	struct asd_target	*tmp_targ;
+	struct list_head	 validate_list;
+	u_long			 flags;
+//JD
+#ifdef ASD_DEBUG
+	struct asd_phy *phy;
+#endif
+	INIT_LIST_HEAD(&validate_list);
+
+	/*
+	 * TODO:
+	 * Access to the validate_list itself is protected, but we still need
+	 * to make sure that the individual target's validate_links are
+	 * protected.
+	 */
+	asd_list_lock(&flags);
+
+	list_move_all(&validate_list, &port->targets_to_validate);
+
+	asd_list_unlock(&flags);
+
+	/* 
+	 * We might be calling a routine that destroys the target, so use 
+	 * the safe version of list traversal.
+	 */
+	list_for_each_entry_safe(targ, tmp_targ, &validate_list,
+				 validate_links) {
+
+		list_del(&targ->validate_links);
+//JD
+#ifdef ASD_DEBUG
+	phy = list_entry(port->phys_attached.next, struct asd_phy, links);
+
+	asd_log(ASD_DBG_INFO, "asd_configure_port_targets:port(0x%x) targ->flags(0x%x) port->phys_attached->id(0x%x)\n",port->id,targ->flags,phy->id);
+#endif
+		if (targ->flags & ASD_TARG_HOT_ADDED) {
+			targ->flags &= ~ASD_TARG_HOT_ADDED;
+
+			/*
+			 * We only need to configure the target if it is
+			 * a SAS or SATA END-DEVICE.
+		      	 */	 
+			if (targ->management_type == ASD_DEVICE_END) {
+				asd_configure_target(asd, targ);
+			} else {
+				targ->flags |= ASD_TARG_ONLINE;
+			}
+
+		} else if (targ->flags & ASD_TARG_HOT_REMOVED) {
+			if (targ->flags & ASD_TARG_MAPPED) {
+				/*
+				 * Tell the OS that the device is gone.
+				 */
+				asd_destroy_target(asd, targ);
+			} else {
+				/*
+				 * This target is not exported to the OS,
+				 * so we aren't going to report this device as
+				 * missing.
+				 */
+				asd_free_target(asd, targ);
+			}
+		} else {
+			asd_log(ASD_DBG_ERROR, "Invalid Target Flags.\n");
+		}
+	}
+}
+
+/*
+ * Function:
+ *	asd_configure_target()
+ *
+ * Description:
+ *	Configure target that was HOT-ADDED. 
+ */ 
+static void
+asd_configure_target(struct asd_softc *asd, struct asd_target *targ)
+{
+	u_int	ch;
+	u_int	id;
+	u_int	lun;
+
+	ch = targ->src_port->id;
+	id = targ->target_id;
+	/* TODO : Currently the lun is set 0. This needs to be fixed. */
+	lun = 0;
+
+	/* Report the new target found to the user or OS. */
+	asd_print("New device attached at "
+		  "Host: scsi%d Channel: %d Id: %d Lun: %d\n",
+		  asd->platform_data->scsi_host->host_no, ch, id, lun);
+	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+	/*
+	 * For 2.6 kernel, notify the scsi layer that a new had been
+	 * device added.
+	 */
+	scsi_add_device(asd->platform_data->scsi_host, ch, id, lun);
+#else
+	if (proc_scsi != NULL)
+	{
+		struct proc_dir_entry	*entry;
+		char			 buffer[80];
+		mm_segment_t		 orig_addr_limit;
+
+		for (entry = proc_scsi->subdir; entry; entry = entry->next) {
+			if ((entry->low_ino == 0) || (entry->namelen != 4) ||
+				(memcmp ("scsi", entry->name, 4) != 0)) {
+				continue;
+			}
+			if (entry->write_proc == NULL)
+				continue;
+
+			sprintf(buffer,"scsi add-single-device %d %d %d %d\n",
+				asd->platform_data->scsi_host->host_no, ch, id, lun);
+
+			orig_addr_limit = current->addr_limit;
+			current->addr_limit = KERNEL_DS;
+			entry->write_proc(NULL, buffer, strlen(buffer), NULL);
+			current->addr_limit = orig_addr_limit;
+		}
+	}
+#endif
+	targ->flags |= (ASD_TARG_ONLINE | ASD_TARG_MAPPED);
+}
+
+/*
+ * Function:
+ *	asd_destroy_target()
+ *
+ * Description:
+ *	Destroy target that was HOT-REMOVED.
+ */ 
+static void
+asd_destroy_target(struct asd_softc *asd, struct asd_target *targ)
+{
+	u_long		flags;
+	unsigned	num_luns;
+	unsigned	i;
+
+	/*
+	 * For an end-device, we need to free the device and report 
+	 * the change to the user or scsi layer.
+	 */
+	if (targ->management_type != ASD_DEVICE_END) {
+		asd_lock(asd, &flags);
+		/* Free the DDB site used by this target. */
+		asd_free_ddb(asd, targ->ddb_profile.conn_handle);
+		/*
+		 * For non end-device, nothing much need to be done.
+		 * All we need to do is free up the target.
+		 */
+		asd_free_target(asd, targ);
+		asd_unlock(asd, &flags);
+		return;
+	}
+
+	switch (targ->command_set_type) {
+	case ASD_COMMAND_SET_SCSI:
+		num_luns = targ->scsi_cmdset.num_luns;
+		break;
+
+	case ASD_COMMAND_SET_ATA:
+	case ASD_COMMAND_SET_ATAPI:
+	case ASD_COMMAND_SET_BAD:
+		num_luns = 1;
+		break;
+
+	default:
+		return;
+	}
+
+	for (i = 0 ; i < num_luns ; i++)
+		asd_init_dev_itnl_exp(asd, targ, i);
+}
+
+static void
+asd_init_dev_itnl_exp(struct asd_softc *asd, struct asd_target *targ,
+		      u_int lun)
+{
+	struct asd_device *dev;
+	u_long		   itnl_timeout;
+	u_long		   flags;
+
+	asd_lock(asd, &flags);
+
+	dev = targ->devices[lun];
+	if (dev == NULL)
+		panic("Dev is corrupted.\n");
+
+	itnl_timeout = ((targ->ddb_profile.itnl_const/1000) + 2) * HZ;
+
+	asd_setup_dev_timer(dev, itnl_timeout, asd_dev_intl_times_out);
+
+	asd_unlock(asd, &flags);
+}
+
+void
+asd_dev_intl_times_out(u_long arg)
+{
+	struct asd_softc 	*asd;
+	struct asd_device	*dev;
+	u_long			 flags;
+
+	dev = (struct asd_device *) arg;
+	asd = dev->target->softc;
+
+	asd_lock(asd, &flags);
+	dev->flags &= ~ASD_DEV_TIMER_ACTIVE;
+
+	/*
+	 * It seems that aftet ITNL timer expired, there are still 
+	 * outstanding IO(s) pending with the firmware.
+	 */
+	if (dev->active > 0) {
+		/*
+		 * Request the firmware to abort all IO(s) pending on
+		 * its queue.
+		 */
+		asd_log(ASD_DBG_ERROR, "ITNL expired, DEV is still ACTIVE.\n");
+
+		dev->flags |= ASD_DEV_DESTROY_WAS_ACTIVE;
+		asd_clear_device_io(asd, dev);
+	} else {
+		/*
+		 * No more active IO(s). Schedule a deferred process to
+		 * destroy the device.
+		 */
+		asd_setup_dev_dpc_task(dev, asd_destroy_device);
+	}
+
+	asd_unlock(asd, &flags);
+}
+
+static void
+asd_clear_device_io(struct asd_softc *asd, struct asd_device *dev)
+{
+	struct scb	*scb;
+	
+	/*
+	 * Send a request to the firmware to abort all IOs pending on its
+	 * queue that are intended for the target.
+	 */	 
+	if ((scb = asd_hwi_get_scb(asd, 1)) == NULL) {
+		asd_log(ASD_DBG_ERROR, "Failed to get free SCB "
+			"for CLEARING firmware queue.\n");
+		return;
+ 	}
+
+	scb->platform_data->dev = dev;
+	scb->platform_data->targ = dev->target;
+
+	asd_hwi_build_clear_nexus(scb, CLR_NXS_I_T_L,
+				 (NOT_IN_Q | SEND_Q | EXEC_Q),
+				  ASD_TARG_HOT_REMOVED);
+				
+	scb->flags |= (SCB_INTERNAL | SCB_ACTIVE | SCB_RECOVERY);
+	asd_push_post_stack(asd, scb, (void *) dev, asd_clear_device_io_done);
+	asd_hwi_post_scb(asd, scb);
+}
+
+static void
+asd_clear_device_io_done(struct asd_softc *asd, struct scb *scb,
+			 struct asd_done_list *dl)
+{
+	asd_log(ASD_DBG_ERROR, "DL Opcode = 0x%x.\n", dl->opcode);
+
+	asd_hwi_free_scb(asd, scb);
+}
+
+void
+asd_destroy_device(void *arg)
+{
+	struct asd_softc	*asd;
+	struct asd_device	*dev;
+	struct scsi_cmnd	*cmd;
+	union asd_cmd		*acmd;
+	u_long	 		 flags;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,0)
+	uint8_t			ch;
+	uint8_t			id;
+	uint8_t			lun;
+#endif
+
+	dev = (struct asd_device *) arg;
+	asd = dev->target->softc;
+
+	asd_lock(asd, &flags);
+	
+	dev->flags &= ~ASD_DEV_DPC_ACTIVE;
+	/*
+	 * Prior to free up the device, make sure no IOs are
+	 * pending on the device queue.
+	 * Return all pending IOs to the scsi layer.
+	 */
+	while (!list_empty(&dev->busyq)) {
+		acmd = list_entry(dev->busyq.next, 
+				  union asd_cmd, acmd_links);
+		list_del(&acmd->acmd_links);
+		cmd = &acmd_scsi_cmd(acmd);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+		asd_cmd_set_offline_status(cmd);
+#endif
+		cmd->scsi_done(cmd);
+	}
+
+	/* 
+	 * If the device has been exposed to the scsi layer, 
+	 * we need to notify the scsi layer that the device has
+	 * been removed and free up the the device.
+	 */
+	asd_print("Device attached at ");
+	asd_print("Host: scsi%d Channel: %d Id: %d Lun: %d "
+		  "has been removed.\n",
+		  asd->platform_data->scsi_host->host_no, dev->ch,
+		  dev->target->target_id, dev->lun);
+
+	if ((dev->flags & ASD_DEV_UNCONFIGURED) != 0) {
+		/*
+		 * The device has not been exposed to the scsi 
+		 * layer yet, all we need to do is free up the device.
+		 */
+		asd_free_device(asd, dev);
+		asd_unlock(asd, &flags);
+		return;
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,6)
+	if ((dev->flags & ASD_DEV_DESTROY_WAS_ACTIVE) == 0)
+		scsi_device_set_state(dev->scsi_device, SDEV_OFFLINE);
+#endif	
+	/*
+	 * For 2.6 kernel, notify the scsi layer that
+	 * a device had been removed. Ends up in asd_slave_destroy().
+	 */
+	asd_unlock(asd, &flags);
+
+	scsi_remove_device(dev->scsi_device);
+#else
+
+#if 0
+	/*
+	 * This code hase been removed because it prevents hot remove from
+	 * working.  Orginally, it was intended to force the sd layer to 
+	 * stop sending requests to the adp94xx driver.
+	 */
+	if ((dev->flags & ASD_DEV_DESTROY_WAS_ACTIVE) == 0)
+		dev->scsi_device->online = 0;
+#endif
+	ch=dev->ch;
+	id=dev->id;
+	lun=dev->lun;
+
+	if (dev->target->refcount == 1) {
+		/*
+		 * Last device attached on this target.
+		 * Free the target's DDB site.
+		 */
+		asd_free_ddb(asd, dev->target->ddb_profile.conn_handle);
+	}
+		
+	/* 
+	 * The device is no longer active.
+	 * It is safe to free up the device.
+	 */
+	asd_free_device(asd, dev);
+
+	asd_unlock(asd, &flags);
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "going to send /proc/scsi/scsi\n");
+#endif
+	if (proc_scsi != NULL)
+	{
+		struct proc_dir_entry	*entry;
+		char			 buffer[80];
+		mm_segment_t		 orig_addr_limit;
+
+		for (entry = proc_scsi->subdir; entry; entry = entry->next) {
+			if ((entry->low_ino == 0) || (entry->namelen != 4) ||
+				(memcmp ("scsi", entry->name, 4) != 0)) {
+				continue;
+			}
+			if (entry->write_proc == NULL)
+				continue;
+
+			sprintf(buffer,"scsi remove-single-device %d %d %d %d\n",
+				asd->platform_data->scsi_host->host_no,ch,id,lun);
+			orig_addr_limit = current->addr_limit;
+			current->addr_limit = KERNEL_DS;
+			entry->write_proc(NULL, buffer, strlen(buffer), NULL);
+			current->addr_limit = orig_addr_limit;
+		}
+	}
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "sent to /proc/scsi/scsi\n");
+#endif
+#endif
+}
+
+static void
+asd_handle_loss_of_signal(struct asd_softc *asd, struct asd_port *port)
+{
+	struct asd_target	*targ;
+	struct asd_target	*multipath_target;
+	struct asd_phy		*phy;
+	struct asd_phy		*tmp_phy;
+	u_long			 flags;
+	int			 num_phy_online;
+
+	phy = NULL;
+	num_phy_online = 0;
+
+	asd_lock(asd, &flags);
+
+	/*
+	 * We have lost signal from the port to the attached device.
+       	 * If the port is a narrow port, we need to have all the attached
+	 * targets validated.
+	 * If the port is a wide port, we need to check if there is other 
+	 * link is still connected to the attached device. 
+	 */	 
+	if (port->num_phys > 1) {
+		/* 
+		 * Wide port. We can still functional if other links still
+		 * up and attached to the end device;
+		 */
+		list_for_each_entry_safe(phy, tmp_phy,
+					 &port->phys_attached, links) {
+
+			if (phy->state == ASD_PHY_CONNECTED) {
+				num_phy_online++;
+				continue;
+			}
+			/* 
+			 * We need to disassociate the phy that no longer
+			 * belongs to this wide port.
+			 */
+			if ((phy->state == ASD_PHY_ONLINE)  || 
+			    (phy->state == ASD_PHY_OFFLINE)) {
+				list_del_init(&phy->links);
+				phy->src_port = NULL;
+				port->num_phys--;
+				port->conn_mask &= ~(1 << phy->id);
+			}
+		}
+	}
+
+	if (num_phy_online == 0) {
+		/* 
+		 * Links are down from the port to the attached device. 
+		 * All targets attached to the port need to be validated.
+		 */
+		while (!list_empty(&port->targets)) {
+			targ = list_entry(port->targets.next,
+					  struct asd_target,
+					  all_domain_targets);
+
+			/*
+			 * If this is a multipath target, then move the device
+			 * mapping before removing the device.
+			 */
+			if (!list_empty(&targ->multipath)) {
+
+				multipath_target = list_entry(
+					targ->multipath.next,
+					struct asd_target, multipath);
+
+				asd_remap_device(asd, targ, multipath_target);
+
+				/*
+				 * This device wasn't in the target list
+				 * because it was a multipath.  Add it to the
+				 * list.
+				 */
+				list_add_tail(
+					&multipath_target->all_domain_targets,
+					&multipath_target->src_port->targets);
+
+				targ->flags &= ~ASD_TARG_MAPPED;
+			}
+
+			list_del_init(&targ->all_domain_targets);
+			list_del_init(&targ->children);
+			list_del_init(&targ->siblings);
+			list_del_init(&targ->multipath);
+			targ->flags |= ASD_TARG_HOT_REMOVED;
+			list_add_tail(&targ->validate_links,
+				      &port->targets_to_validate);
+		}
+		INIT_LIST_HEAD(&port->targets);
+		port->events |= ASD_VALIDATION_REQ;
+		/*
+		 * We need to disassociate all the attached phys from this
+		 * port.
+		 */
+		while (!list_empty(&port->phys_attached)) {
+			phy = list_entry(port->phys_attached.next,
+					 struct asd_phy, links);
+			list_del_init(&phy->links);
+			phy->src_port = NULL;
+			port->num_phys--;
+			port->conn_mask = 0;
+			port->state = ASD_PORT_UNUSED;
+		}
+	}
+
+	asd_unlock(asd, &flags);
+}
+
+/* 
+ * parse thro' list of all devices discovered and retireve target by 
+ * sas address.
+ */
+struct asd_target * 
+asd_get_sas_target_from_sasaddr(struct asd_softc *asd, struct asd_port *port, 
+				uint8_t *sasaddr)
+{
+	struct asd_target 	*target;
+	u_long			 flags;
+	
+	if ((asd == NULL) || (port == NULL) || (sasaddr == NULL)) {
+		return NULL;
+	}
+
+	asd_lock(asd, &flags);
+	list_for_each_entry(target, &port->targets, all_domain_targets) {
+		if (memcmp(target->ddb_profile.sas_addr, 
+			   sasaddr, 
+			   SAS_ADDR_LEN) == 0) {
+			asd_unlock(asd, &flags);
+			return target;
+		}
+	}	
+	asd_unlock(asd, &flags);
+
+	return NULL;
+}
+
+/* parse thro' devices exported to os and retrieve target by SAS address */
+struct asd_target * 
+asd_get_os_target_from_sasaddr(struct asd_softc *asd, struct asd_domain *dm,
+			       uint8_t *sasaddr)
+{
+	struct asd_target 	*target;
+	int 			 i;
+	u_long 			 flags;
+	
+	if ((asd == NULL) || (dm == NULL))
+		return NULL;
+	
+	asd_lock(asd, &flags);
+	for (i = 0; i < ASD_MAX_TARGET_IDS; i++) {
+		if ((target = dm->targets[i]) != NULL) {
+			if (memcmp(target->ddb_profile.sas_addr, 
+			   	   sasaddr, 
+			   	   SAS_ADDR_LEN) == 0) {
+				asd_unlock(asd, &flags);
+				return target;
+			}
+		}
+	}
+	asd_unlock(asd, &flags);
+	return NULL;
+}
+
+/* parse thro' devices exported to os and retrieve target by port 
+ * This routine will have to be discarded soon.
+ * */
+struct asd_target * 
+asd_get_os_target_from_port(struct asd_softc *asd, struct asd_port *port, 
+			    struct asd_domain *dm)
+{
+	int i;
+	u_long flags;
+	
+	if ((asd == NULL) || (dm == NULL) || (port == NULL))
+		return NULL;
+	
+	asd_lock(asd, &flags);
+	for (i = 0; i < ASD_MAX_TARGET_IDS; i++) {
+		if ((dm->targets[i] != NULL) 
+		   && (dm->targets[i]->src_port == port)) {
+			asd_unlock(asd, &flags);
+			return dm->targets[i];
+		}
+	}
+	asd_unlock(asd, &flags);
+
+	return NULL;
+}
+
+struct asd_device *
+asd_get_device_from_lun(struct asd_softc *asd, struct asd_target *targ, 
+			uint8_t *saslun)
+{
+	int 	k;
+	u_long 	flags;
+	
+	if ((asd == NULL) || (targ == NULL)) 
+		return NULL;
+
+	if ((targ->transport_type == ASD_TRANSPORT_STP) || 
+	    (targ->transport_type == ASD_TRANSPORT_ATA)) {
+		return targ->devices[0];
+	}
+
+	if (saslun == NULL)
+		return NULL;
+
+	asd_list_lock(&flags);
+	for (k = 0; k < ASD_MAX_LUNS; k++) {
+		if (targ->devices[k]) {
+			if (memcmp(&targ->devices[k]->saslun, 
+			    saslun, 8) == 0) {
+				asd_list_unlock(&flags);
+				return targ->devices[k];
+			}
+		}
+	}
+	asd_list_unlock(&flags);
+
+	return NULL;
+}
+
+int 
+asd_get_os_platform_map_from_sasaddr(struct asd_softc *asd, 
+				     struct asd_port *port, 
+				     uint8_t *sasaddr, uint8_t *saslun, 
+				     uint8_t *host, uint8_t *bus, 
+				     uint8_t *target, uint8_t *lun)
+{
+	Scsi_Device 		*scsi_device;
+	struct asd_domain	*dm;
+	struct asd_target	*targ;
+	struct asd_device	*dev;
+	struct Scsi_Host 	*scsi_host;
+	
+	dm = asd->platform_data->domains[port->id];
+	if (dm == NULL)
+		return 0;
+	
+	if ((targ = 
+		asd_get_os_target_from_sasaddr(asd, dm, sasaddr)) == NULL)
+		return -ENODEV;
+
+	if ((dev = asd_get_device_from_lun(asd, targ, saslun)) == NULL)	
+		return -ENODEV;
+
+	scsi_device = dev->scsi_device;
+	scsi_host = asd->platform_data->scsi_host;
+
+	*host = scsi_host->host_no;
+	*target = scsi_device->id;
+	*bus = scsi_device->channel;
+	*lun = scsi_device->lun;
+
+	return 0;
+}
+
+struct asd_port *
+asd_get_sas_addr_from_platform_map(struct asd_softc *asd, 
+				   uint8_t host, uint8_t bus, uint8_t target, 
+				   uint8_t lun, uint8_t *sasaddr,
+				   uint8_t *saslun)
+{
+	struct asd_domain	*dm;
+	struct asd_target	*targ;
+	struct asd_device	*dev;
+	struct Scsi_Host 	*scsi_host;
+	struct asd_port		*port;
+	u_long 			 flags;
+
+	asd_lock(asd, &flags);
+
+	port = NULL;
+	scsi_host = asd->platform_data->scsi_host;
+	if ((scsi_host == NULL) || 
+	   ((host != 0xFF) && (host != scsi_host->host_no)))
+		goto exit;
+
+	if ((bus >= asd->platform_data->num_domains) ||
+	    ((dm = asd->platform_data->domains[bus]) == NULL))
+		goto exit;
+
+	if ((target >= ASD_MAX_TARGET_IDS) ||
+	    ((targ = dm->targets[target]) == NULL))
+		goto exit;
+
+	if (lun >= ASD_MAX_LUNS)
+		goto exit;
+
+	if ((dev = targ->devices[lun]) == NULL)
+		goto exit;
+
+	/* Get LUN address. */
+	memcpy(saslun, dev->saslun, SAS_LUN_LEN);
+	/* Get SAS address. */
+	memcpy(sasaddr, targ->ddb_profile.sas_addr, SAS_ADDR_LEN);
+
+	port = targ->src_port;
+
+exit:	
+	asd_unlock(asd, &flags);
+	return (port);
+}
+
+struct scb *
+asd_find_pending_scb_by_qtag(struct asd_softc *asd, uint32_t qtag)
+{
+	struct scb 		*list_scb;
+	struct scb 		*scb;
+	struct scsi_cmnd 	*cmd;
+	union asd_cmd 		*acmd;
+	u_long 			flags;
+	
+	list_scb = NULL;
+	scb = NULL;
+	cmd = NULL;
+	acmd = NULL;
+
+	asd_list_lock(&flags);
+	list_for_each_entry(list_scb, &asd->platform_data->pending_os_scbs,
+			    owner_links) {
+		acmd = list_scb->io_ctx;
+		cmd = &acmd_scsi_cmd(acmd);
+		if (cmd->tag == qtag) {
+			scb = list_scb;
+			break;
+		}
+	}
+	asd_list_unlock(&flags);
+	return scb;
+}
+
+#define GET_LEAST_PHY_ID(port, kid) {\
+	struct asd_phy	*list_phy; \
+	kid = asd->hw_profile.max_phys; \
+	list_for_each_entry(list_phy, &port->phys_attached, links) { \
+		if(list_phy->id < kid) kid = list_phy->id; \
+	} \
+}
+
+/*
+ * Function:
+ * 	get_port_by_least_phy()
+ *
+ * Description:
+ * 	sort and get the port with smallest phy id
+ */
+struct asd_port	*get_port_by_least_phy(struct asd_softc *asd, int portid)
+{
+	int phyidN,phyidN1;
+	struct asd_port *portN;
+	struct asd_port *portN1;
+
+	if(portid>=asd->hw_profile.max_ports) return NULL;
+	portN = asd->port_list[portid];
+	portN1 = get_port_by_least_phy(asd, portid+1);
+	if( (portN->state == ASD_PORT_UNUSED) ||
+	    (portN->num_phys == 0) ) return portN1;
+	if( portN1 == NULL ) return portN;
+
+	GET_LEAST_PHY_ID(portN, phyidN);
+	GET_LEAST_PHY_ID(portN1, phyidN1);
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "port[%d](%d)->phy(%d) vs port(%d)->phy(%d)\n",portid,portN->id,phyidN,portN1->id,phyidN1);
+#endif
+	if( phyidN1 < phyidN )
+	{
+		struct asd_domain	*dm;
+		struct asd_target	*target;
+		int i;
+
+		asd->port_list[portid]=portN1;
+		asd->port_list[portN1->id]=portN;
+		portN->id = portN1->id;
+		portN1->id = portid;
+
+		dm = asd->platform_data->domains[portN->id];
+		asd->platform_data->domains[portN->id]=asd->platform_data->domains[portN1->id];
+		asd->platform_data->domains[portN1->id]=dm;
+
+		list_for_each_entry(target, &portN->targets, all_domain_targets) {
+			if(target!=NULL)
+			{
+				struct asd_device *devicechain;
+#ifdef ASD_DEBUG
+				asd_log(ASD_DBG_INFO, "target %p: \n",target);
+#endif
+				for(i=0;i<ASD_MAX_LUNS;i++)
+				{
+					devicechain=target->devices[i];
+					if(devicechain!=NULL)
+					{
+#ifdef ASD_DEBUG
+						asd_log(ASD_DBG_INFO, "target->devices[%d]->ch was %d, now %d\n",i,devicechain->ch,portN->id);
+#endif
+						devicechain->ch = portN->id;
+					}
+				}
+			}
+		}
+		list_for_each_entry(target, &portN1->targets, all_domain_targets) {
+			if(target!=NULL)
+			{
+				struct asd_device *devicechain;
+#ifdef ASD_DEBUG
+				asd_log(ASD_DBG_INFO, "target %p: \n",target);
+#endif
+				for(i=0;i<ASD_MAX_LUNS;i++)
+				{
+					devicechain=target->devices[i];
+					if(devicechain!=NULL)
+					{
+#ifdef ASD_DEBUG
+						asd_log(ASD_DBG_INFO, "target->devices[%d]->ch was %d, now %d\n",i,devicechain->ch,portN1->id);
+#endif
+						devicechain->ch = portN1->id;
+					}
+				}
+			}
+		}
+
+#ifdef ASD_DEBUG
+		if(dm != NULL)
+		{
+			for(i=0;i<ASD_MAX_TARGET_IDS;i++)
+			{
+				if(dm->targets[i] !=NULL)
+					asd_log(ASD_DBG_INFO, "target %d: %p: \n",i,dm->targets[i]);
+			}
+		}
+#endif
+		portN1 = get_port_by_least_phy(asd, portid+1);
+	}
+	return asd->port_list[portid];
+}
+
+/*
+ * Function:
+ * 	asd_process_id_addr_evt()
+ *
+ * Description:
+ * 	Process Identify Address frame received by the phy. 
+ * 	If the phy has no src port, associate the phy with a port.
+ *	Otherwise, validate if the phy still belongs to the same src port.
+ *	Trigger discovery as needed.
+ */
+static void
+asd_process_id_addr_evt(struct asd_softc *asd, struct asd_phy *phy)
+{
+	struct asd_port	*port;
+	struct asd_phy	*list_phy;
+	int		 wide_port;
+	int		 prev_attached_phy;
+	int		 port_no;
+	struct asd_port	*dummyport;
+
+	ASD_LOCK_ASSERT(asd);
+	port = NULL;
+	prev_attached_phy = 0;
+	wide_port = 0;
+//JD
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "id_addr from phy 0x%x\n",phy->id);
+#endif
+	/*
+	 * Check existing ports whether the current phy attached to the
+         * port has the same ID ADDR as this new phy.
+	 * If so, this phy shall be associated to the port and aggregate
+	 * as a wide port if it a different phy.
+	 * Else, if it is the same phy then it must be after enable-phy.
+	 */
+	for (port_no = 0; port_no < asd->hw_profile.max_ports; port_no++) {
+		port = asd->port_list[port_no];
+//JD
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "asd_process_id_addr_evt: port(0x%x)->state(0x%x)\n", port->id,port->state );
+#endif
+
+		if (port->state != ASD_PORT_ONLINE) {
+			continue;
+		}
+
+		if (port->link_type != ASD_LINK_SAS) {
+			/*
+			 * For SATA link, check if the phy is the same as
+		         * the one currently attached to the port.
+			 */
+			list_phy = list_entry(port->phys_attached.next,
+					      struct asd_phy, links);
+			if (list_phy->id == phy->id)
+				prev_attached_phy = 1;
+
+			continue;
+		}
+//JD
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "asd_process_id_addr_evt: port_id(0x%x) port->attached_sas_addr %02x%02x%02x%02x%02x%02x%02x%02x\n", port->id,
+			port->attached_sas_addr[0],
+			port->attached_sas_addr[1],
+			port->attached_sas_addr[2],
+			port->attached_sas_addr[3],
+			port->attached_sas_addr[4],
+			port->attached_sas_addr[5],
+			port->attached_sas_addr[6],
+			port->attached_sas_addr[7]		);
+#endif
+		list_for_each_entry(list_phy, &port->phys_attached, links) {
+			/*
+			 * Check the id_addr that we just got in.
+			 */
+			if (memcmp(PHY_GET_ID_SAS_ADDR(list_phy),
+	       			   PHY_GET_ID_SAS_ADDR(phy), 
+				   SAS_ADDR_LEN) != 0) {
+
+				continue;
+			}
+			/*
+			 * Check the sas address that assigned by the BIOS
+			 */
+			if (memcmp(list_phy->sas_addr, phy->sas_addr, 
+				   SAS_ADDR_LEN) != 0) {
+				continue;
+			}
+			/*
+			 * Check if this is the same phy that was previously
+			 * attached to this port.
+			 * The new phy can only become a wide port if it isn't
+			 * previously attached to this port.
+		         */	 
+			if (list_phy->id == phy->id)
+				prev_attached_phy = 1;
+			else
+				wide_port = 1;
+			
+			break;
+		}
+
+		if ((wide_port == 1) || (prev_attached_phy == 1))
+			break;
+	}
+
+	if (prev_attached_phy == 0) {
+	/*
+	 * If the phy is already on a list, take it off.
+	 */
+		if (!list_empty(&phy->links))
+		{
+			list_del_init(&phy->links);
+			phy->src_port->num_phys--;
+			phy->src_port->conn_mask &= ~(1 << phy->id);
+			phy->src_port = NULL;
+		}
+	}
+//JD
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "asd_process_id_addr_evt: prev_attached_phy=0x%x \n",prev_attached_phy);
+#endif
+
+	if ((wide_port == 0) && (prev_attached_phy == 0)) {
+		/*
+		 * The phy is not associated with any port. 
+		 * Create a new port for this phy.
+		 */
+		for (port_no = 0; port_no < asd->hw_profile.max_ports; 
+		     port_no++) {
+			port = asd->port_list[port_no];
+			
+			if ((port->state == ASD_PORT_UNUSED) && 
+			    (port->num_phys == 0))
+				break;
+		}
+//JD
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "asd_process_id_addr_evt: assigned port data port_id(0x%x) port->attached_sas_addr %02x%02x%02x%02x%02x%02x%02x%02x\n", port->id,
+			port->attached_sas_addr[0],
+			port->attached_sas_addr[1],
+			port->attached_sas_addr[2],
+			port->attached_sas_addr[3],
+			port->attached_sas_addr[4],
+			port->attached_sas_addr[5],
+			port->attached_sas_addr[6],
+			port->attached_sas_addr[7]		);
+#endif
+		memcpy(port->sas_addr, phy->sas_addr, SAS_ADDR_LEN);
+		/* 
+		 * Generate SAS hashed address to be used as the port 
+		 * SAS address. 
+		 */
+		asd_hwi_hash(port->sas_addr, port->hashed_sas_addr);
+
+		/* 
+		 * During enable phy, we have determined whether we have a 
+		 * direct attached SATA device.
+		 */  
+		if (phy->attr & ASD_SATA_MODE) {
+			/*
+			 * TODO: More things to do for SATA II device which 
+			 *	 supports tag queueing. Need to setup sister
+			 *	 ddb, other additional SATA information. Need
+			 *	 to add SATA specific fields in target DDB
+			 *	 profile.
+			 */
+			port->link_type = ASD_LINK_SATA;
+			port->management_type = ASD_DEVICE_END;
+
+		} else if (phy->bytes_dmaed_rcvd.id_addr_rcvd.addr_frame_type & 
+			SAS_END_DEVICE) {
+			/*
+			 * Direct Attached SAS device.
+			 */
+			port->link_type = ASD_LINK_SAS;
+			port->management_type = ASD_DEVICE_END;
+
+		} else if (phy->bytes_dmaed_rcvd.id_addr_rcvd.addr_frame_type & 
+			SAS_EDGE_EXP_DEVICE) {
+			/*
+			 * Edge Expander device.
+			 */
+			port->link_type = ASD_LINK_SAS;
+			port->management_type = ASD_DEVICE_EDGE_EXPANDER;
+		} else {
+			/*
+			 * Fanout Expander device
+			 */
+			if (phy->bytes_dmaed_rcvd.id_addr_rcvd.addr_frame_type & 
+				SAS_FANOUT_EXP_DEVICE) {
+
+				port->link_type = ASD_LINK_SAS;
+				port->management_type =
+					ASD_DEVICE_FANOUT_EXPANDER;
+			}
+		}
+
+		port->state = ASD_PORT_ONLINE;
+	}
+
+	phy->src_port = port;
+
+	if (prev_attached_phy == 0) {
+//JD
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "asd_process_id_addr_evt: port_id(0x%x) phy_id(0x%x)\n", port->id, phy->id);
+#endif
+		list_add_tail(&phy->links, &port->phys_attached);
+		port->num_phys++;
+	}
+	asd_setup_port_data(asd, port, phy);
+//JD not really need the port, but just sort it...
+	if(asd->platform_data->flags & ASD_DISCOVERY_INIT)
+		dummyport = get_port_by_least_phy(asd, 0);
+//JD
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "asd_process_id_addr_evt: after asd_setup_port_data port_id(0x%x) phy_id(0x%x)\n", port->id, phy->id);
+
+
+//JD
+	asd_log(ASD_DBG_INFO, "asd_process_id_addr_evt: port->events(0x%x)\n",port->events);
+#endif
+
+	/*
+	 * Check to see if the port already has discovery running on it.
+	 */
+	if (((port->events & ASD_DISCOVERY_REQ) == 0) &&
+	    ((port->events & ASD_DISCOVERY_PROCESS) == 0)) {
+		/*
+		 * The port does not have a discovery running on it.
+		 */
+		port->events |= ASD_DISCOVERY_REQ;
+
+		port->conn_mask |= (1 << phy->id);
+
+		asd->num_discovery++;
+
+	} else {
+		/*
+		 * We should only get here if this is a wide port.  We will not
+		 * mark this phy in the connection mask yet, the discovery
+		 * thread will do that when it is finished.
+		 */
+//JD		ASSERT(wide_port == 1);
+	}
+}
+
+/*
+ * Function:
+ *	asd_setup_port_data()
+ *
+ * Description:
+ *	Setup port settings based on the phy info.
+ */
+static void 
+asd_setup_port_data(struct asd_softc *asd, struct asd_port *port,
+		    struct asd_phy *phy)
+{
+	u_int	lowest_rate;
+
+	/* 
+	 * If this port was previously disabled, change the port state to 
+	 * ONLINE.   
+	 */
+	if (port->state != ASD_PORT_ONLINE)
+		port->state = ASD_PORT_ONLINE;
+
+	port->attr = phy->attr;	
+
+	/* 
+	 * Get the negotiated connection rate.
+	 *
+	 * Notice the two different definitions of connection rate.
+	 * SAS_RATE_XXX is used on the OPEN ADDRESS FRAME.
+	 * For wide port configuration, we need to use lowest link rate of 
+	 * all attached phys as the port connection rate.
+	 */
+	lowest_rate = phy->conn_rate;
+	if (port->num_phys > 1) {
+		struct asd_phy	*list_phy;
+
+		/* Wide port configuration. */
+		list_for_each_entry(list_phy, &port->phys_attached, links) {
+
+			if (list_phy->conn_rate < lowest_rate)
+				lowest_rate = phy->conn_rate;
+		}
+	}
+
+	port->conn_rate = ((lowest_rate == SAS_30GBPS_RATE) ? SAS_RATE_30GBPS :
+							      SAS_RATE_15GBPS);
+	{
+		u8 phy_is_up;
+		u8 conn_mask;
+		u8 mask;
+		int i;
+
+		/* Setup the hardware DDB 0 location. */
+		asd_hwi_set_ddbptr(asd, 0);
+
+
+		conn_mask = port->conn_mask | (1<<phy->id);
+
+		mask = conn_mask;
+		/* turn on port_map_by_links */
+		for (i = 0; mask != 0; i++, mask >>= 1)
+			if (mask & 01) {
+				asd_hwi_set_ddbsite_byte(asd,
+							 offsetof(struct asd_int_ddb, port_map_by_links)+i,
+							 conn_mask);
+			}
+
+		/* turn on port_map_by_ports */
+		asd_hwi_set_ddbsite_byte(asd,
+					 offsetof(struct asd_int_ddb, port_map_by_ports)+port->id,
+					 conn_mask);
+
+		/* turn on phy is up */
+		phy_is_up = asd_hwi_get_ddbsite_byte(asd, offsetof(struct asd_int_ddb, phy_is_up));
+		phy_is_up |= (1<<phy->id);
+		asd_hwi_set_ddbsite_byte(asd, offsetof(struct asd_int_ddb, phy_is_up), phy_is_up);
+	}
+}
+
+/*
+ * Function:
+ * 	asd_initiate_port_discovery()
+ * 
+ * Description:
+ *	Check any events such as phy events, id_addr frame or dynamic 
+ *	configuration changes that required discovery.
+ */	   	  
+static int
+asd_initiate_port_discovery(struct asd_softc *asd, struct asd_port *port)
+{
+	struct asd_phy		*phy;
+	struct asd_target 	*targ;
+	struct asd_target	*multipath_target;
+	uint64_t		 sas_addr;
+	u_long			 flags;
+
+	// TODO: fix locking - lists should be locked
+
+	if (list_empty(&port->phys_attached)) {
+		asd_log(ASD_DBG_ERROR, "Corrupted port, no phy(s) attached "
+			"to it.\n");
+		return (-1);
+	}
+
+	phy = list_entry(port->phys_attached.next, struct asd_phy, links);
+//JD
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "asd_initiate_port_discovery: phy->id(0x%x)\n",phy->id);
+	asd_log(ASD_DBG_INFO, "asd->free_ddb_bitmap ptr 0x%x\n",asd->free_ddb_bitmap);
+	asd_print("%llx %llx\n",(u64)asd->free_ddb_bitmap[0], (u64)asd->free_ddb_bitmap[1]);
+#endif
+	if ((port->link_type == ASD_LINK_SATA) &&
+	    (port->management_type = ASD_DEVICE_END)) {
+		/*
+	 	 * For direct-attached SATA end-device, generate the SAS addr
+        	 * internally.
+	 	*/
+		sas_addr = asd_htobe64(asd_be64toh(*((uint64_t *)
+						     asd->hw_profile.wwn))
+				       + asd->hw_profile.sata_name_base
+				       + phy->id);
+	} else {
+		sas_addr = (*(uint64_t *) PHY_GET_ID_SAS_ADDR(phy));
+	}
+
+	/*
+	 * Look up this target to see if it already exists.
+	 */
+	targ = asd_find_target(&port->targets, (uint8_t *) &sas_addr);
+	if (targ != NULL) {
+		list_del_init(&targ->all_domain_targets);
+		list_del_init(&targ->children);
+		list_del_init(&targ->siblings);
+
+		while (!list_empty(&targ->multipath)) {
+			multipath_target = list_entry(targ->multipath.next,
+					  struct asd_target, multipath);
+
+			list_del_init(&multipath_target->multipath);
+
+			list_add_tail(&multipath_target->multipath,
+				&port->targets);
+		}
+
+		list_add_tail(&targ->all_domain_targets, &port->targets);
+	} else {
+		targ = asd_alloc_target(asd, port);
+	}
+
+	if (targ == NULL) {
+		/* 
+		 * TODO: Return for now.
+		 *  	 Probably, we should return and put
+		 *  	 the discovery thread back to sleep
+		 *  	 and restart at some point later on. 
+		 */
+		asd_log(ASD_DBG_ERROR, "Failed to allocate a target !!\n");
+		return (-1);
+	}
+
+	asd_lock(asd, &flags);
+//JD
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "asd_initiate_port_discovery: before setup_target_data port_id(0x%x) port->attached_sas_addr %02x%02x%02x%02x%02x%02x%02x%02x\n", port->id,
+			port->attached_sas_addr[0],
+			port->attached_sas_addr[1],
+			port->attached_sas_addr[2],
+			port->attached_sas_addr[3],
+			port->attached_sas_addr[4],
+			port->attached_sas_addr[5],
+			port->attached_sas_addr[6],
+			port->attached_sas_addr[7]		);
+#endif
+	if (asd_setup_target_data(asd, phy, targ) != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to setup target data !!\n");
+		return (-1);
+	}
+
+     	memcpy(port->attached_sas_addr, targ->ddb_profile.sas_addr,
+	       SAS_ADDR_LEN);
+//JD
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "asd_initiate_port_discovery: port_id(0x%x) port->attached_sas_addr %02x%02x%02x%02x%02x%02x%02x%02x\n", port->id,
+			port->attached_sas_addr[0],
+			port->attached_sas_addr[1],
+			port->attached_sas_addr[2],
+			port->attached_sas_addr[3],
+			port->attached_sas_addr[4],
+			port->attached_sas_addr[5],
+			port->attached_sas_addr[6],
+			port->attached_sas_addr[7]		);
+#endif
+	switch (port->link_type)
+	{
+	case ASD_LINK_SAS:
+		targ->management_type = port->management_type;
+
+		switch (port->management_type)
+		{
+		case ASD_DEVICE_END:
+			/*
+			 * It can't be an STP type because it is directly
+			 * attached to the initiator.
+			 */
+			targ->command_set_type = ASD_COMMAND_SET_SCSI;
+			targ->device_protocol_type = ASD_DEVICE_PROTOCOL_SCSI;
+			targ->transport_type = ASD_TRANSPORT_SSP;
+			break;
+
+		case ASD_DEVICE_EDGE_EXPANDER:
+			targ->command_set_type = ASD_COMMAND_SET_SMP;
+			targ->device_protocol_type = ASD_DEVICE_PROTOCOL_SMP;
+			targ->transport_type = ASD_TRANSPORT_SMP;
+			break;
+
+		case ASD_DEVICE_FANOUT_EXPANDER:
+			targ->command_set_type = ASD_COMMAND_SET_SMP;
+			targ->device_protocol_type = ASD_DEVICE_PROTOCOL_SMP;
+			targ->transport_type = ASD_TRANSPORT_SMP;
+			break;
+
+		case ASD_DEVICE_NONE:
+		case ASD_DEVICE_UNKNOWN:
+			targ->command_set_type = ASD_COMMAND_SET_UNKNOWN;
+			targ->device_protocol_type = 
+				ASD_DEVICE_PROTOCOL_UNKNOWN;
+			targ->transport_type = ASD_TRANSPORT_UNKNOWN;
+			break;
+		}
+		break;
+
+	case ASD_LINK_SATA:
+		targ->command_set_type = ASD_COMMAND_SET_UNKNOWN;
+		targ->device_protocol_type = ASD_DEVICE_PROTOCOL_ATA;
+		targ->transport_type = ASD_TRANSPORT_ATA;
+		targ->management_type = ASD_DEVICE_END;
+		break;
+
+	default:
+		targ->command_set_type = ASD_COMMAND_SET_UNKNOWN;
+		targ->device_protocol_type = ASD_DEVICE_PROTOCOL_UNKNOWN;
+		targ->transport_type = ASD_TRANSPORT_UNKNOWN;
+		targ->management_type = ASD_DEVICE_NONE;
+		break;
+	}
+
+	port->tree_root = targ;
+
+	asd_unlock(asd, &flags);
+
+	return (0);
+}	
+
+/*
+ * Function:
+ * 	asd_setup_target_data()
+ * 
+ * Description:
+ *	Setup target info based on the Identify Address frame received.
+ * 	Also, setup a hardware ddb site for this target.
+ */
+static int
+asd_setup_target_data(struct asd_softc *asd, struct asd_phy *phy,
+		      struct asd_target *targ)
+{
+	uint64_t	sas_addr;
+
+	ASD_LOCK_ASSERT(asd);
+
+	/* Set the sister ddb to invalid for now. */
+	targ->ddb_profile.sister_ddb = ASD_INVALID_DDB_INDEX;
+
+	targ->ddb_profile.conn_rate = phy->src_port->conn_rate;
+
+	/* Set a default ITNL timer, applicable for SAS device only. */
+	targ->ddb_profile.itnl_const = ITNL_TIMEOUT_CONST;
+		
+	/* Setup target protocol. */
+	if (phy->bytes_dmaed_rcvd.id_addr_rcvd.tgt_port_type & SSP_TGT_PORT) {
+
+		targ->transport_type = ASD_TRANSPORT_SSP;
+		targ->command_set_type = ASD_COMMAND_SET_SCSI;
+
+	} else if (phy->bytes_dmaed_rcvd.id_addr_rcvd.tgt_port_type & 
+		SMP_TGT_PORT) {
+
+		targ->transport_type = ASD_TRANSPORT_SMP;
+		targ->command_set_type = ASD_COMMAND_SET_SMP;
+
+	} else if (phy->bytes_dmaed_rcvd.id_addr_rcvd.tgt_port_type & 
+		STP_TGT_PORT) {
+		/* 
+		 * We don't know the command set yet (could be ATAPI or ATA)
+		 * We won't know until IDENTIFY / PIDENTIFY.
+		 */
+		targ->transport_type = ASD_TRANSPORT_STP;
+	} else {
+		/* 
+		 * We don't know the command set yet (could be ATAPI or ATA)
+		 * We won't know until IDENTIFY / PIDENTIFY.
+		 */
+		targ->transport_type = ASD_TRANSPORT_ATA;
+		targ->ddb_profile.itnl_const = 1;
+	}
+
+	if (targ->transport_type == ASD_TRANSPORT_ATA) {
+
+		sas_addr =  asd_htobe64(asd_be64toh(*((uint64_t *)
+			asd->hw_profile.wwn)) + 0x10 + phy->id);
+
+		/*
+		 * Setup the SAS Address for this target based on the
+		 * generated SAS Address.
+		 */
+		memcpy(targ->ddb_profile.sas_addr, &sas_addr, SAS_ADDR_LEN);
+	} else {
+		/*
+		 * Setup the SAS Address for this target based on the Identify
+		 * Frame received for this phy.
+		 */
+		memcpy(targ->ddb_profile.sas_addr, PHY_GET_ID_SAS_ADDR(phy),
+		       SAS_ADDR_LEN);
+//JD
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "asd_setup_target_data: targ->ddb_profile.sas_addr(xxxx%02x%02x%02x)\n",
+			targ->ddb_profile.sas_addr[5],
+			targ->ddb_profile.sas_addr[6],
+			targ->ddb_profile.sas_addr[7]);
+#endif
+	}
+
+	asd_hwi_hash(targ->ddb_profile.sas_addr, 
+		     targ->ddb_profile.hashed_sas_addr);
+		
+	/* 
+	 * Based on the target port type, enable the OPEN bit so that 
+	 * OPEN address will be issued when opening an connection.
+	 */
+	if ((phy->bytes_dmaed_rcvd.id_addr_rcvd.tgt_port_type & SSP_TGT_PORT) ||
+		(phy->bytes_dmaed_rcvd.id_addr_rcvd.tgt_port_type & 
+			SMP_TGT_PORT) ||
+		(phy->bytes_dmaed_rcvd.id_addr_rcvd.tgt_port_type & 
+			STP_TGT_PORT)) {
+
+		targ->ddb_profile.open_affl = OPEN_AFFILIATION;
+		if(phy->bytes_dmaed_rcvd.id_addr_rcvd.tgt_port_type & 
+			STP_TGT_PORT)
+		{
+			targ->ddb_profile.open_affl |=
+//		    (STP_AFFILIATION | SUPPORTS_AFFILIATION);
+		    SUPPORTS_AFFILIATION;
+		}
+#ifdef SEQUENCER_UPDATE
+#ifdef CONCURRENT_SUPPORT
+		else 
+		{
+			targ->ddb_profile.open_affl |= CONCURRENT_CONNECTION_SUPPORT;
+		}
+#endif
+#endif
+
+		/*
+		 * TODO: More to be done for STP in the case affiliation is
+		 *	 supported.
+	 	 */	    
+	} else {
+		/* 
+		 * For direct attached SATA device and SATA Port Multi, 
+		 * OPEN Address frame and afflitiation policy are not 
+		 * supported.
+		 */   
+		targ->ddb_profile.open_affl = 0;
+	}
+
+	/* Setup a hardware DDB site for this target. */
+	if (asd_hwi_setup_ddb_site(asd, targ) != 0) {
+		/* 
+		 * Failed to setup ddb site due to no free site.
+		 * TODO: More handling needed here once ddb site recycling 
+		 *	 algorithm is implemented.
+		 *	 For now, just return failure.	 
+		 */
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * Function:
+ * 	asd_map_target()
+ *
+ * Description:
+ *	Mapped the target to the domain.
+ */
+int
+asd_map_target(struct asd_softc *asd, struct asd_target *targ)
+{
+	struct asd_domain	*dm;
+	struct asd_port		*port;
+	u_int			 i;
+	unsigned		 channel;
+
+	port = targ->src_port;
+
+	/*
+	 * Map the target to the domain.
+	 */
+	if (targ->flags & ASD_TARG_MAP_BOOT) {
+		targ->flags &= ~ASD_TARG_MAP_BOOT;
+		channel = 0;
+	} else {
+		channel = port->id;
+	}
+
+	dm = asd->platform_data->domains[channel];
+
+	if (dm == NULL) {
+		dm = asd_alloc_domain(asd, channel);
+		if (dm == NULL)
+			return -1;
+	}
+
+	if (targ->target_id != ASD_MAX_TARGET_IDS) {
+		asd_dprint("target %llx already has ID\n",
+			   be64_to_cpu(*(u64 *)targ->ddb_profile.sas_addr));
+		/* The target ID was assigned in the discover code,
+		 * possibly via querying an SES device.
+		 */
+		if (dm->targets[targ->target_id] == NULL) {
+			dm->targets[targ->target_id] = targ;
+			targ->domain = dm;
+		} else if (dm->targets[targ->target_id] != targ) {
+			asd_dprint("Ooops: target with id %d already exists!\n",
+				   targ->target_id);
+			return -1;
+		}
+	} else {
+		asd_dprint("target %llx doesn't have ID\n",
+			   be64_to_cpu(*(u64 *)targ->ddb_profile.sas_addr));
+		/* Normal case: no SES device claimed to know the order
+		 * of this device.
+		 */
+#ifndef NO_SES_SUPPORT 
+		for (i = 128; i < ASD_MAX_TARGET_IDS; i++) {
+#else
+		for (i = 0; i < (ASD_MAX_TARGET_IDS - 128); i++) {
+#endif
+			if (dm->targets[i] == NULL) {
+				dm->targets[i] = targ;
+				targ->target_id = i;
+				targ->domain = dm;
+				break;
+			}
+		}
+		if (i == ASD_MAX_TARGET_IDS)
+			return -1;
+	}
+
+	/* Increment domain ref count for new target mapped. */
+	asd_domain_addref(dm);
+
+	return (0);
+}
+
+#ifdef ASD_DEBUG
+void
+asd_init_debug_timeout(
+u_long		val
+)
+{
+	struct asd_softc		*asd;
+
+	asd = (struct asd_softc	*)val;
+
+	asd_hwi_dump_seq_state(asd, asd->hw_profile.enabled_phys);
+}
+#endif
+
+
+/***************************** PCI Entry Points *******************************/
+/* 
+ * Function:
+ *	asd_pci_dev_probe()
+ *
+ * Description:
+ *	This routine will be called when OS finds a controller that matches
+ *	and entry in our supported PCI ID table.  It will perform hardware
+ *	initialization and bring our device to the online state. 
+ */
+static int
+asd_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct asd_softc		*asd;
+	struct asd_pci_driver_data	*drv_data;
+	asd_dev_t			 dev;
+	unsigned long			 flags;
+	int				 error;
+
+	asd_print("Probing Adaptec AIC-94xx Controller(s)...\n");
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	if (asd_init_stat.asd_init_state != 1) {
+		asd_print("%s: Ignoring PCI device found after initialization. "
+			  "\n", ASD_DRIVER_NAME);
+		return (-ENODEV);
+	}
+#endif
+
+	/* Sanity checking to make sure the same device is not probed twice. */
+	asd_list_lock(&flags);
+	list_for_each_entry(asd, &asd_hbas, link) {
+		struct pci_dev *probed_pdev;
+
+		probed_pdev = asd_pci_dev(asd);
+		if ((probed_pdev->bus->number == pdev->bus->number) && 
+		    (probed_pdev->devfn == pdev->devfn)) {
+			/* A Duplicate PCI Device found. Ignore it. */
+			asd_print("%s: Ignoring duplicate PCI device.\n", 
+			  	  ASD_DRIVER_NAME);
+			asd_list_unlock(&flags);
+			return (-ENODEV);
+		}
+	}
+	asd_list_unlock(&flags);
+
+	drv_data = (struct asd_pci_driver_data *) (id->driver_data);
+	if (drv_data == NULL) {
+		asd_log(ASD_DBG_ERROR, "PCI Driver Data not found.\n");
+		return (-ENODEV);
+	}
+
+	if (pdev->class == (PCI_CLASS_STORAGE_RAID << 8)
+	    && !asd_attach_HostRAID)
+		return -ENODEV;
+
+	if (pci_enable_device(pdev) != 0)
+		return (-ENODEV);	
+	
+	pci_set_master(pdev);
+		
+	dev = asd_pdev_to_dev(pdev);
+	/* Allocate a softc structure for the current PCI Device found. */
+	asd = asd_alloc_softc(dev);
+	if (asd == NULL)
+		return (-ENOMEM);
+
+#ifdef ASD_DEBUG
+	init_timer(&debug_timer);
+	debug_timer.expires = jiffies + 20 * HZ;
+	debug_timer.data = (u_long) asd;
+	debug_timer.function = asd_init_debug_timeout;
+	//add_timer(&debug_timer);
+#endif
+	
+	asd->pci_entry = id;
+	/*
+	 * Perform profile setup for the specific controller.
+	 * Always success.
+	 */
+	error = drv_data->setup(asd);
+	
+	asd->platform_data->domains = asd_alloc_mem(
+					    (asd->hw_profile.max_ports *
+					    sizeof(struct asd_domain)),
+					    GFP_ATOMIC);
+
+	if (asd->platform_data->domains == NULL) {
+		asd_free_softc(asd);
+		return (-ENOMEM);
+	}
+	memset(asd->platform_data->domains, 0x0, (asd->hw_profile.max_ports *
+						  sizeof(struct asd_domain)));
+
+	/*
+	 * Setup PCI consistent dma transfer mask to 32-bit and below 
+	 * 4GB boundary.
+	 */
+	if (asd_set_consistent_dma_mask(asd, 0xFFFFFFFF) != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to set PCI consistent "
+			"dma mask.\n");
+		asd_free_softc(asd);
+		return (-ENODEV);
+	}	
+	
+	/*
+	 * Setup the dma transfer mask to 64-bit only the following conditions
+	 * are met:
+	 *    (a) the system is running on 64-bit or 'PAE' mode.
+	 *    (b) the controller can do DMA transfer above 4GB boundary.
+	 *    (c) dma address can be above 4GB boundary.
+	 * Otherwise set the dma transfer mask to 32-bit.
+	 */
+	 if ((asd->profile.dma64_addr == 1)	&& 
+	     (ASD_DMA_64BIT_SUPPORT == 1)) {
+		uint64_t    mask;
+		
+		mask = 0xFFFFFFFFFFFFFFFFULL;
+	 	if (asd_set_dma_mask(asd, mask) != 0) {
+			/* 
+			 * Failed to set dma mask to 64-bit, throttle down
+			 * to 32-bit instead.
+			 */
+			 mask = 0xFFFFFFFFULL;
+			 if (asd_set_dma_mask(asd, mask) != 0) {
+			 	/* If this also failed, we need to exit. */
+				asd_log(ASD_DBG_ERROR, "Failed to set DMA "
+					"mask. \n");
+				asd_free_softc(asd);
+				return (-ENODEV);
+			}	 
+	 	}
+		asd->profile.dma_mask = (dma_addr_t) mask;		
+	 } else {
+	 	if (asd_set_dma_mask(asd, 0xFFFFFFFF) != 0) {
+			asd_log(ASD_DBG_ERROR, "Failed to set DMA "
+					"mask. \n");
+			asd_free_softc(asd);
+			return (-ENODEV);
+		}
+		asd->profile.dma_mask = 0xFFFFFFFF;
+	}
+
+	/* 
+	 * TBD: Review locking. This is a single threaded operation and 
+	 * 2.6.x kernel on a SMP machine complains about a potential 
+	 * deadlock due to irqs being disabled. 
+	 */
+	/*asd_lock(asd, &flags);*/
+	/* Initialize the controller. */
+	if (asd_init_hw(asd) != 0) {
+		//asd_unlock(asd, &flags);
+		asd_log(ASD_DBG_ERROR, "Failed to initialize the HW.\n");
+		asd_free_softc(asd);
+		return (-ENODEV);
+	} 	
+	pci_set_drvdata(pdev, asd);
+	/*asd_unlock(asd, &flags);*/
+	
+	asd_list_lock(&flags);
+	list_add_tail(&asd->link, &asd_hbas);
+	asd_list_unlock(&flags);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	/* The controller is hot-plugged, register it with the SCSI midlayer. */
+	if (asd_init_stat.asd_init_state == 0) {
+		error = asd_register_host(asd);
+		if (error != 0) {
+			asd_log(ASD_DBG_ERROR, "Failed to register host.\n");
+			asd_list_lock(&flags);
+			list_del(&asd->link);
+			asd_list_unlock(&flags);
+			asd_free_softc(asd);
+		}
+	}
+#endif
+	if (!error)
+		/* Enable the Host interrupt. */
+		asd_intr_enable(asd, 1);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	/* 
+	 * For the controller that is hot-plugged, we need to request the 
+	 * midlayer to perform bus scan.
+	 */
+	if (asd_init_stat.asd_init_state == 0) {
+		error = asd_initiate_bus_scan(asd);
+		if (error != 0) {
+			asd_log(ASD_DBG_ERROR, "Failed in performing "
+				"bus scan.\n");
+			asd_list_lock(&flags);
+			list_del(&asd->link);
+			asd_list_unlock(&flags);
+			asd_free_softc(asd);
+		}
+	}	
+#endif
+
+	return (error);
+}
+
+/* 
+ * Function:
+ *	asd_pci_dev_remove()
+ *
+ * Description:
+ *	This routine is called when the controller is removed or during 
+ *	module unloading. 
+ */
+static void
+asd_pci_dev_remove(struct pci_dev *pdev)
+{
+	struct asd_softc	*asd;
+	unsigned long		 flags;
+	
+	asd = (struct asd_softc *) pci_get_drvdata(pdev);
+	
+	if (asd_get_softc(asd) != NULL) {
+		asd_list_lock(&flags);	
+		list_del(&asd->link);
+		asd_list_unlock(&flags);
+		asd_free_softc(asd);
+	}
+}
+
+int
+asd_platform_alloc(struct asd_softc *asd)
+{
+	asd->platform_data = asd_alloc_mem(sizeof(struct asd_platform_data),
+					   GFP_ATOMIC);
+	if (asd->platform_data == NULL)
+		return (-ENOMEM);
+	memset(asd->platform_data, 0, sizeof(struct asd_platform_data));
+
+	asd_lock_init(asd);
+	INIT_LIST_HEAD(&asd->platform_data->pending_os_scbs);
+	INIT_LIST_HEAD(&asd->platform_data->device_runq);
+	INIT_LIST_HEAD(&asd->platform_data->completeq);
+	INIT_LIST_HEAD(&asd->platform_data->lru_ddb_q);
+	init_MUTEX_LOCKED(&asd->platform_data->discovery_sem);
+	init_MUTEX_LOCKED(&asd->platform_data->discovery_ending_sem);
+	init_MUTEX_LOCKED(&asd->platform_data->ehandler_sem);
+	init_MUTEX_LOCKED(&asd->platform_data->ehandler_ending_sem);
+	init_MUTEX_LOCKED(&asd->platform_data->eh_sem);
+	init_MUTEX_LOCKED(&asd->platform_data->wait_sem);
+	init_waitqueue_head(&asd->platform_data->waitq);
+
+	asd_init_tasklets(asd);
+
+#ifdef ASD_EH_SIMULATION
+	init_MUTEX_LOCKED(&asd->platform_data->eh_simul_sem);
+#endif	
+	
+	asd->platform_data->num_domains = ASD_MAX_PORTS;
+
+	return (0);
+}
+
+void
+asd_platform_free(struct asd_softc *asd)
+{
+	struct asd_io_handle	*io_handle;
+	struct asd_domain	*dm;
+	struct asd_target	*targ;
+	struct asd_device	*dev;
+	u_int			 i;
+	u_int			 j;
+	u_int			 k;
+
+	/* Kill any threads that we created. */
+	asd_kill_discovery_thread(asd);
+	asd_kill_ehandler_thread(asd);
+#ifdef ASD_EH_SIMULATION	
+	asd_kill_eh_simul_thread(asd);
+#endif
+
+	asd_kill_tasklets(asd);
+
+	/* Deregister the Scsi Host with the OS. */
+	if (asd->platform_data->scsi_host) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+		scsi_remove_host(asd->platform_data->scsi_host);
+		scsi_host_put(asd->platform_data->scsi_host);
+#else
+		scsi_unregister(asd->platform_data->scsi_host);
+#endif
+	}
+	
+	/* Free up any allocated linux domains, targets and devices. */
+	for (i = 0; i < asd->hw_profile.max_phys; i++) {
+		dm = asd->platform_data->domains[i];	
+		if (dm == NULL)
+			continue;
+
+		for (j = 0; j < ASD_MAX_TARGET_IDS; j++) {
+			targ = dm->targets[j];
+			if (targ == NULL) 
+				continue;
+
+			for (k = 0; k < ASD_MAX_LUNS; k++) {
+				dev = targ->devices[k];
+				if (dev == NULL)
+					continue;
+
+				asd_free_device(asd, dev);
+			}
+			/* 
+			 * For target with no devices allocated previously,
+			 * we need to free target explicitly.
+			 */
+			if (dm->targets[j] != NULL)
+				asd_free_mem(dm->targets[j]);
+		}
+		/* 
+		 * For domain with no targets allocated previously,
+		 * we need to free domain explicitly.
+		 */
+		if (asd->platform_data->domains[i] != NULL)
+			asd_free_mem(asd->platform_data->domains[i]);
+	}
+
+	/*
+	 * Disable chip interrupts if we have successfully mapped
+	 * the controller.  We do this *before* unregistering
+	 * our interrupt handler so that stray interrupts from
+	 * our controller do not hang the machine.
+	 */
+	if (asd->io_handle_cnt != 0)
+		asd_intr_enable(asd, 0);
+
+	/* Unregister the interrupt handler. */
+	if (asd_init_stat.asd_irq_registered == 1)
+		free_irq(asd_pci_dev(asd)->irq, asd);
+
+	/* Lock PCIC_MBAR_KEY. */
+	asd_pcic_write_dword(asd, PCIC_MBAR_KEY, 0xFFFFFFFF);	
+
+	/* Free the IO Handle(s). */
+	for ( ; asd->io_handle_cnt != 0; ) {
+		io_handle = asd->io_handle[(--asd->io_handle_cnt)];
+		if (io_handle->type == ASD_MEMORY_SPACE) {
+			release_mem_region(io_handle->bar_base, 
+					   io_handle->length);
+		} else {
+			release_region(io_handle->bar_base, io_handle->length);
+		}	
+		asd_free_mem(io_handle);
+	}
+}
+
+/* 
+ * Function:
+ *	asd_init_hw()
+ *
+ * Description:
+ *	This routine will call the hwi layer to initialize the controller.
+ *	Allocate any required memory, private data structures (such as scb, 
+ *	edb, dl, etc) for the controller.
+ */
+static int
+asd_init_hw(struct asd_softc *asd)
+{
+	uint32_t	mbar_key;
+	uint32_t	cmd_stat_reg;
+	int 		error;
+
+	/* TODO: Revisit */
+	//ASD_LOCK_ASSERT(asd);
+
+	/* Only support for Rev. B0 chip. */
+//JD we support B0,B1...
+//	if (asd->hw_profile.rev_id != AIC9410_DEV_REV_B0) {
+//		asd_print("Only AIC-9410 Rev. B0 is supported !\n");
+//		error = -ENODEV;
+//		goto exit;
+//	}
+		
+	/*
+	 * Check if the PCIC_MBAR_KEY is not unlocked without permission.
+	 * Value 0x0 means it has been unlocked.
+	 */
+	mbar_key = asd_pcic_read_dword(asd, PCIC_MBAR_KEY);
+       	if (mbar_key == 0x0)
+		asd_log(ASD_DBG_INFO, "MBAR_KEY has been unlocked !!\n");
+	
+	/* Map the IO handle. */
+	error = asd_map_io_handle(asd);
+	if (error != 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to map IO Handle.\n");
+		goto exit;
+	}		
+
+	/* Check if bus master is enabled. Enabled it if it is not. */
+	cmd_stat_reg = asd_pcic_read_dword(asd, PCIC_COMMAND);
+	if (!(cmd_stat_reg & MST_EN)) {
+		cmd_stat_reg |= MST_EN;
+		asd_pcic_write_dword(asd, PCIC_COMMAND, cmd_stat_reg);	
+	}
+	
+	/*
+	 * Now, unlock the PCIC_MBAR_KEY for write access to MBAR.
+	 * Read the value from the register and write it back to the register
+	 * to unlcok MBAR.
+	 */
+	mbar_key = asd_pcic_read_dword(asd, PCIC_MBAR_KEY);	
+	if (mbar_key != 0x0)
+		asd_pcic_write_dword(asd, PCIC_MBAR_KEY, mbar_key);
+	
+	/*
+	 * AIC9410 CHIP Rev. A1 has the issue where the data transfer hangs
+	 * on the host write DMA. The workaround for this issue is to disable
+	 * PCIX Rewind feature.
+	 */ 
+	if (asd->hw_profile.rev_id == AIC9410_DEV_REV_A1) {
+		asd_pcic_write_dword(asd,  PCIC_HSTPCIX_CNTRL, 
+				    (asd_pcic_read_dword(asd, 
+							 PCIC_HSTPCIX_CNTRL) | 
+							 REWIND_DIS));
+	}
+//JD fixing DDTS 92647/92648... ABORT issues when PCI read memory timed out and command completed
+//  but driver doesn't see in DL.
+	asd_pcic_write_dword(asd,  PCIC_HSTPCIX_CNTRL, 
+				    (asd_pcic_read_dword(asd, 
+							 PCIC_HSTPCIX_CNTRL) | 
+							 SC_TMR_DIS));
+	error = asd_hwi_init_hw(asd);
+	if (error != 0) {
+		asd_log(ASD_DBG_ERROR, "Init HW failed.\n");
+		goto exit;
+	}
+	
+	/* Register the interrupt handler with the OS. */
+	error = request_irq(asd_pci_dev(asd)->irq, asd_isr, SA_SHIRQ,
+			    ASD_DRIVER_NAME, asd);
+	if (error != 0)
+	     asd_log(ASD_DBG_ERROR, "Failed to register IRQ handler.\n"); 
+
+	asd_init_stat.asd_irq_registered = 1;
+exit:
+	return (error);
+}
+
+/* 
+ * Function:
+ *	asd_map_io_handle()
+ *
+ * Description:
+ *	Map the IO handles for the register access.
+ */
+static int
+asd_map_io_handle(struct asd_softc *asd)
+{
+	uint32_t	cmd_stat_reg;
+	int		error;
+
+	asd->io_handle = asd_alloc_mem((sizeof(struct asd_io_handle) * 
+					ASD_MAX_IO_HANDLES), GFP_KERNEL);
+	if (asd->io_handle == NULL)
+		return (-ENOMEM);
+						
+	cmd_stat_reg = asd_pcic_read_dword(asd, PCIC_COMMAND);
+	
+	/* Whenever possible, map the IO handles using Memory Mapped. */
+	if (cmd_stat_reg & MEM_EN) {
+		error = asd_mem_mapped_io_handle(asd);
+		if (error == 0)
+			goto exit;
+		/*
+		 * We will fall back to IO Mapped if we failed to map using
+		 * Memory Mapped.
+		 */
+	}	
+	
+	if (cmd_stat_reg & IO_EN)
+		error = asd_io_mapped_io_handle(asd);	
+	else
+		error = -ENOMEM;
+exit:
+	return (error);	
+}
+
+/*
+ * asd_mem_mapped_io_handle()
+ *
+ * Description:
+ *	Map the IO Handle using Memory Mapped.
+ */
+static int
+asd_mem_mapped_io_handle(struct asd_softc *asd)
+{
+	struct asd_io_handle	*io_handle;
+	int			 error;
+	uint32_t		 base_addr;
+	uint32_t		 base_page;
+	uint32_t		 base_offset;
+	uint32_t		 bar_type;
+	uint32_t		 bar_len;
+	uint8_t			 index;
+#if 0
+	uint32_t		scb_pro;	
+#endif
+
+#define ASD_FREE_PREV_IO_HANDLE(asd)					    \
+do {									    \
+	for ( ; asd->io_handle_cnt != 0; ) {				    \
+		io_handle = asd->io_handle[(--asd->io_handle_cnt)];	    \
+		release_mem_region(io_handle->bar_base, io_handle->length); \
+		asd_free_mem(io_handle);				    \
+	}								    \
+} while (0)
+
+	/*
+	 * TBRV: MBAR0 and MBAR1 of the controller are both 64-bit. 
+	 *	 Linux PCI isn't aware of 64-bit BAR.
+	 *	 For now, it is fine we just map the first 32-bit, as the upper
+	 *	 32-bit are set to 0.
+	 */	
+	for (index = 0; index < 3; index = index+2) {
+		/*
+		 * Acquire the base addr, length of the region to be mapped.
+		 */
+		base_addr = pci_resource_start(asd_dev_to_pdev(asd->dev), 
+					       index);
+		bar_type = pci_resource_flags(asd_dev_to_pdev(asd->dev), 
+					      index);
+		
+		if (index == PCIC_MBAR0_OFFSET) {
+			uint32_t	mbar0_mask;
+			
+			/* 
+		 	 * For MBAR0, we need to figure out the size of 
+			 * the region to be mapped.  The configured size
+			 * of the bar is 8K * 2^N, where N is the number of
+			 * bits set in the MBAR0 size mask.
+		 	 */
+
+			mbar0_mask = asd_pcic_read_dword(asd, PCIC_MBAR0_MASK);
+			mbar0_mask = PCIC_MBAR0_SIZE(mbar0_mask);
+			bar_len = 0x2000;
+			while (mbar0_mask != 0) {
+				mbar0_mask >>= 1;
+				bar_len <<= 1;
+			}
+		} else {
+			/* For MBAR1, we will map 128K. */
+			bar_len = 0x20000;
+		}
+		
+		/*
+		 * Sanity checking.
+		 * TBRV: Shoud we allow to proceed if we failed to map MBAR1 ?
+		 */
+		if ((base_addr == 0) || (bar_len == 0)) { 
+			asd_log(ASD_DBG_ERROR, "Failed in getting "
+				"PCI resources.\n");
+			ASD_FREE_PREV_IO_HANDLE(asd);
+			error = -ENOMEM;
+			goto exit;
+		}
+			
+		io_handle = asd_alloc_mem(sizeof(*io_handle), GFP_KERNEL);
+		if (io_handle == NULL) {
+			asd_log(ASD_DBG_ERROR, "Out of memory resources.\n");
+			ASD_FREE_PREV_IO_HANDLE(asd);
+			error = -ENOMEM;
+			goto exit;		
+		}
+		memset(io_handle, 0x0, sizeof(*io_handle));
+		io_handle->bar_base = base_addr;	
+		io_handle->length = bar_len;
+		io_handle->index = index;
+		io_handle->type = ASD_MEMORY_SPACE;
+			
+		if (request_mem_region(base_addr, bar_len,
+				       ASD_DRIVER_NAME) == 0) {
+			asd_log(ASD_DBG_ERROR, "Failed to request region for "
+				"idx = %d, addr = 0x%x, len = 0x%x.\n",
+				index, base_addr, bar_len);
+			asd_free_mem(io_handle);		
+			ASD_FREE_PREV_IO_HANDLE(asd); 
+			error = -ENOMEM;
+			goto exit;
+		}
+		base_page = base_addr & PAGE_MASK;
+		base_offset = base_addr - base_page;
+		/*
+		 * Request the MBAR to be remapped in the non-cached region.
+		 */
+		io_handle->baseaddr.membase = ioremap_nocache(base_page,
+							      (bar_len +
+							       base_offset));
+		if (io_handle->baseaddr.membase == NULL) {
+			asd_log(ASD_DBG_ERROR, "Failed to perform ioremap "
+				"for addr = 0x%x, len = 0x%x.\n",
+				base_page, (bar_len + base_offset));
+			release_mem_region(base_addr, bar_len);
+			asd_free_mem(io_handle);
+			ASD_FREE_PREV_IO_HANDLE(asd);
+			error = -ENOMEM;
+			goto exit;
+		}	
+
+		asd->io_handle[asd->io_handle_cnt] = io_handle;		
+		asd->io_handle_cnt++;
+	}
+
+	/*
+	 * Do a simple test that the region is properly mapped.
+	 * We are going to read SCBPRO register, and check the upper 16-bits
+	 * value which represent read-only SCBCONS. 
+	 * Write any random value to SCBCONS shouldn't take any effect. 
+	 */
+#if 0
+	/* XXX At this point, we do not know if the central sequencer is
+	 *     running or not, so touching the producer index is *not*
+	 *     safe.  We should either map our sliding window before this
+	 *     test so we can pause the CSEQ or come up with a different
+	 *     register to use for this test.
+	 */
+	scb_pro = asd_read_dword(asd, SCBPRO);
+	scb_pro++;
+	scb_pro &= SCBPRO_MASK;
+	asd_write_dword(asd, SCBPRO, scb_pro);
+	if (asd_read_dword(asd, SCBPRO) == scb_pro) {
+		/* 
+		 * If both values matched, that means the SCBCONS got changed.
+		 */
+		asd_log(ASD_DBG_ERROR, "Failed in testing register mapping.\n");
+		ASD_FREE_PREV_IO_HANDLE(asd);
+		error = -ENOMEM;
+		goto exit; 
+	}	
+#endif
+	/* Reaching here means we succeed in mapping the region. */
+	error = 0;
+exit:
+	return (error);
+}
+
+/*
+ * asd_io_mapped_io_handle()
+ *
+ * Description:
+ *	Map the IO Handle using IO Mapped.
+ */
+static int
+asd_io_mapped_io_handle(struct asd_softc *asd)
+{
+	struct asd_io_handle	*io_handle;
+	int			 error;
+	uint32_t		 base_addr;
+	uint32_t		 bar_type;
+	uint32_t		 bar_len;
+	uint8_t			 index;
+
+	/*
+	 * TBRV: IOBAR of the controller is 64-bit. 
+	 *	 Linux PCI doesn't aware of 64-bit BAR.
+	 *	 For now, it is fine we just map the first 32-bit, as the upper
+	 *	 32-bit is set to 0.
+	 */
+	index = PCIC_IOBAR_OFFSET;
+			
+	/* Acquire the base addr, length of the region to be mapped. */
+	base_addr = pci_resource_start(asd_dev_to_pdev(asd->dev), index);
+	bar_type = pci_resource_flags(asd_dev_to_pdev(asd->dev), index);
+	bar_len = pci_resource_len(asd_dev_to_pdev(asd->dev), index);
+	
+	if ((base_addr == 0) || (bar_len == 0)) { 
+		asd_log(ASD_DBG_ERROR, "Failed in getting PCI resources.\n");
+	       	error = -ENOMEM;
+	       	goto exit;
+       	}
+
+       	io_handle = asd_alloc_mem(sizeof(*io_handle), GFP_KERNEL);
+       	if (io_handle == NULL) {
+       		asd_log(ASD_DBG_ERROR, "Out of memory resources.\n");
+       		error = -ENOMEM;
+       		goto exit;		
+       	}
+	memset(io_handle, 0x0, sizeof(*io_handle));	
+	io_handle->baseaddr.iobase = base_addr;		
+       	io_handle->length = bar_len;
+       	io_handle->index = index;
+       	io_handle->type = ASD_IO_SPACE;
+
+ 	if (request_region(base_addr, bar_len, ASD_DRIVER_NAME) == 0) {
+		asd_log(ASD_DBG_ERROR, "Failed to request region for "
+			"idx = %d, addr = 0x%x, len = 0x%x.\n",
+			index, base_addr, bar_len);
+		asd_free_mem(io_handle);	 
+		error = -ENOMEM;
+		goto exit;
+       	}	 
+	
+	/* Reaching here means we succeed in mapping the region. */
+	asd->io_handle[asd->io_handle_cnt] = io_handle;
+	asd->io_handle_cnt++;	 	 
+	error = 0;
+exit:
+	return (error);	
+}
+
+/*
+ * asd_isr()
+ *
+ * Description:
+ *	This is the interrupt handler. Check if we have any interrupt pending.
+ *	If there is, process it. Otherwise, just return.
+ */
+irqreturn_t
+asd_isr(int  irq, void  *dev_id, struct pt_regs  *regs)
+{
+	struct asd_softc	*asd;
+	unsigned long		 flags;
+	int			 irq_retval;
+
+	asd = (struct asd_softc *) dev_id;
+#if 0
+ if(asd->debug_flag ==1)
+ {
+ 	asd_log(ASD_DBG_INFO, "ISR\n");
+ }
+#endif
+
+	asd_lock(asd, &flags);
+
+	irq_retval = asd_hwi_process_irq(asd);
+
+	if (asd_next_device_to_run(asd) != NULL)
+		asd_schedule_runq(asd);
+
+	asd_unlock(asd, &flags);
+	
+	return IRQ_RETVAL(irq_retval);
+}
+
+/*
+ * asd_queue()
+ *
+ * Description:
+ *	Execute the requested IO.
+ */
+static int
+asd_queue(Scsi_Cmnd  *cmd, void (*scsi_done)(Scsi_Cmnd *))
+{
+	struct asd_softc	*asd;
+	struct asd_device	*dev;
+
+	asd = *((struct asd_softc **) cmd->device->host->hostdata);
+#ifdef CHECK_CMD
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+	cmd->abort_reason=jiffies / HZ;
+#endif
+#if 1
+	if(asd->debug_flag ==1)
+	{
+		asd_log(ASD_DBG_INFO, "asd_queue\n");
+	}
+#endif
+//JD
+	if(cmd->cmnd[0]==0x0)
+	{
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+	asd_log(ASD_DBG_INFO, "asd_queue for SCSI cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x abort:%d), opcode 0x%x.\n", 
+#else
+	asd_log(ASD_DBG_INFO, "asd_queue for SCSI cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x), opcode 0x%x.\n", 
+#endif
+			cmd->cmnd[2],
+			cmd->cmnd[3],
+			cmd->cmnd[4],
+			cmd->cmnd[5],
+			cmd->cmnd[7],
+			cmd->cmnd[8],
+		  cmd->tag,
+		  cmd->pid,
+		  cmd->resid,
+		  cmd->timeout_per_command,
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+		  cmd->abort_reason,
+#endif
+		  cmd->cmnd[0]);
+	}
+#endif
+	/*
+	 * Save the callback on completion function.
+	 */
+	cmd->scsi_done = scsi_done;
+	asd_sml_lock(asd);
+
+	/*
+	 * Close the race of a command that was in the process of
+	 * being queued to us just as our controller was frozen.
+	 */
+	if (asd->platform_data->qfrozen != 0) {
+
+		asd_sml_unlock(asd);
+		asd_cmd_set_retry_status(cmd);
+		cmd->scsi_done(cmd);
+		return (0);
+	}
+
+	dev = asd_get_device(asd, cmd->device->channel, cmd->device->id,
+			     cmd->device->lun, /*alloc*/1);
+	if (dev == NULL) {
+		asd_sml_unlock(asd);
+		
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+		asd_cmd_set_offline_status(cmd);
+#endif
+		cmd->scsi_done(cmd);
+		return (0);
+	} else if (((dev->flags & ASD_DEV_UNCONFIGURED) != 0) && 
+		   (cmd->device->type != -1)) {
+		/*
+		 * Configure devices that have already successfully
+		 * completed an inquiry. This handles the case of
+		 * devices being destroyed due to transient selection
+		 * timeouts.
+		 */
+		dev->flags &= ~ASD_DEV_UNCONFIGURED;
+	 	dev->scsi_device = cmd->device;
+		asd_set_device_queue_depth(asd, dev);
+	} else {
+		/*
+		 * The target is in the process of being destroyed as
+		 * it had been hot-removed. Return the IO back to the
+		 * scsi layer.
+		 */
+		if (dev->target->flags & ASD_TARG_HOT_REMOVED) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+			asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+			asd_cmd_set_offline_status(cmd);
+#endif
+			cmd->scsi_done(cmd);
+			return (0);
+		}
+	}
+
+	/*
+	 * DC: Need extra storage for SSP_LONG tasks to hold the CDB.
+	 *     For now, just limit the CDB to what we can embed in the SCB.
+ 	 */
+	if (cmd->cmd_len > SCB_EMBEDDED_CDB_SIZE) {
+		asd_cmd_set_host_status(cmd, DID_BAD_TARGET);
+		asd_sml_unlock(asd);
+		cmd->scsi_done(cmd);
+		asd_print("%s: asd94xx_queue -"
+			  "CDB length of %d exceeds max!\n",
+			  asd_name(asd), cmd->cmd_len);
+		return (0);
+	}
+
+#ifdef ASD_EH_SIMULATION	
+	++cmd_cnt;
+	if ((cmd_cnt != 0) && ((cmd_cnt % 888) == 0x0)) {
+		asd_print("Setting up cmd %p for eh simulation.\n", cmd);
+		asd_cmd_set_host_status(cmd, 0x88);
+	} else {
+		asd_cmd_set_host_status(cmd, CMD_REQ_INPROG);
+	}
+#else
+	/*
+	 * Workaround for some kernel versions, when the cmd is retried but
+         * the cmd->result is not clear.
+	 */
+	cmd->result = 0;
+	asd_cmd_set_host_status(cmd, CMD_REQ_INPROG);
+#endif /* ASD_EH_SIMULATION */ 	
+
+	list_add_tail(&((union asd_cmd *)cmd)->acmd_links, &dev->busyq);
+	if ((dev->flags & ASD_DEV_ON_RUN_LIST) == 0) {
+		list_add_tail(&dev->links, &asd->platform_data->device_runq);
+		dev->flags |= ASD_DEV_ON_RUN_LIST;
+		asd_run_device_queues(asd);
+	}
+
+	asd_sml_unlock(asd);
+	return (0);
+} 
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/*
+ * asd_select_queue_depth()
+ *
+ * Description:
+ *	Adjust the queue depth for each device attached to our controller.
+ */
+static void
+asd_select_queue_depth(struct Scsi_Host *host, Scsi_Device *scsi_devs)
+{
+	struct asd_softc	*asd;
+	Scsi_Device 		*device;
+	Scsi_Device 		*ldev;
+	u_long			 flags;
+
+	asd = *((struct asd_softc **)host->hostdata);
+	asd_lock(asd, &flags);
+	for (device = scsi_devs; device != NULL; device = device->next) {
+		/*
+		 * Watch out for duplicate devices.  This works around
+		 * some quirks in how the SCSI scanning code does its
+		 * device management.
+		 */
+		for (ldev = scsi_devs; ldev != device; ldev = ldev->next) {
+			if (ldev->host == device->host
+			 && ldev->channel == device->channel
+			 && ldev->id == device->id
+			 && ldev->lun == device->lun)
+				break;
+		}
+		/* Skip duplicate. */
+		if (ldev != device)
+			continue;
+
+		if (device->host == host) {
+			struct asd_device *dev;
+
+			/*
+			 * Since Linux has attached to the device, configure
+			 * it so we don't free and allocate the device
+			 * structure on every command.
+			 */
+			dev = asd_get_device(asd, device->channel,
+					     device->id, device->lun,
+					     /*alloc*/1);
+			if (dev != NULL) {
+				dev->flags &= ~ASD_DEV_UNCONFIGURED;
+				dev->scsi_device = device;
+				asd_set_device_queue_depth(asd, dev);
+				device->queue_depth = dev->openings + 
+						      dev->active;
+				if ((dev->flags & (ASD_DEV_Q_BASIC | 
+						   ASD_DEV_Q_TAGGED)) == 0) {
+					/*
+					 * We allow the OS to queue 2 untagged
+					 * transactions to us at any time even
+					 * though we can only execute them
+					 * serially on the controller/device.
+					 * This should remove some latency.
+					 */
+					device->queue_depth = 2;
+				}
+			}
+		}
+	}
+	asd_unlock(asd, &flags);
+}
+
+#else
+
+static int
+asd_slave_alloc(Scsi_Device *scsi_devs)
+{
+	struct asd_softc *asd;
+
+	asd = *((struct asd_softc **) scsi_devs->host->hostdata);
+	asd_log(ASD_DBG_RUNTIME_B, "%s: Slave Alloc %d %d %d\n", asd_name(asd),
+		scsi_devs->channel, scsi_devs->id, scsi_devs->lun);
+
+	return (0);	
+}
+	
+static int
+asd_slave_configure(Scsi_Device *scsi_devs)
+{
+	struct asd_softc 	*asd;
+	struct asd_device	*dev;
+	u_long			 flags;	
+
+	asd = *((struct asd_softc **) scsi_devs->host->hostdata);
+	asd_log(ASD_DBG_RUNTIME_B, "%s: Slave Configure %d %d %d\n", asd_name(asd),
+		scsi_devs->channel, scsi_devs->id, scsi_devs->lun);
+
+	asd_lock(asd, &flags);
+	/*
+	 * Since Linux has attached to the device, configure it so we don't 
+	 * free and allocate the device structure on every command.
+	 */
+	dev = asd_get_device(asd, scsi_devs->channel, scsi_devs->id, 
+			     scsi_devs->lun, /*alloc*/1);
+	if (dev != NULL) {
+		dev->flags &= ~ASD_DEV_UNCONFIGURED;
+		dev->flags |= ASD_DEV_SLAVE_CONFIGURED;
+		dev->scsi_device = scsi_devs;
+		asd_set_device_queue_depth(asd, dev);
+	}
+	asd_unlock(asd, &flags);
+
+	return (0);
+}
+
+static void
+asd_slave_destroy(Scsi_Device *scsi_devs)
+{
+	struct asd_softc 	*asd;
+	struct asd_device 	*dev;
+	u_long			 flags;	
+
+	asd = *((struct asd_softc **) scsi_devs->host->hostdata);
+	asd_log(ASD_DBG_RUNTIME_B, "%s: Slave Destroy %d %d %d\n", asd_name(asd),
+		scsi_devs->channel, scsi_devs->id, scsi_devs->lun);
+
+	asd_lock(asd, &flags);
+
+	dev = asd_get_device(asd, scsi_devs->channel, scsi_devs->id, 
+			     scsi_devs->lun, /*alloc*/0);
+
+	if (dev == NULL) {
+		asd_unlock(asd, &flags);
+		return;
+	}
+
+	if ((dev->flags & ASD_DEV_SLAVE_CONFIGURED) != 0) {
+		if ((list_empty(&dev->busyq)) && (dev->active == 0) &&
+		   ((dev->flags & ASD_DEV_TIMER_ACTIVE) == 0)) {
+			if (dev->target->refcount == 1) {
+				if( dev->target->flags & ASD_TARG_HOT_REMOVED) {
+					asd_free_ddb(
+						asd,
+						dev->target->ddb_profile.conn_handle);
+					/* Free the allocated device. */
+					asd_free_device(asd, dev);
+				} else {
+					dev->flags |= ASD_DEV_UNCONFIGURED;
+					dev->flags &= ~ASD_DEV_SLAVE_CONFIGURED;
+					dev->scsi_device = NULL;
+				}
+			}
+		}
+	}
+
+	asd_unlock(asd, &flags);
+}
+
+static int
+asd_initiate_bus_scan(struct asd_softc *asd)
+{
+	int	error;
+
+	error = scsi_add_host(asd->platform_data->scsi_host, asd->dev);
+	if (error != 0)	
+		return (error);
+		
+	scsi_scan_host(asd->platform_data->scsi_host);
+	return (0);
+}
+
+#endif
+
+/*
+ * Function:
+ *	asd_get_user_tagdepth()
+ *	
+ * Description:
+ *	Return the user specified device queue depth.
+ * 	If none specified, return a default queue depth.
+ */
+static u_int
+asd_get_user_tagdepth(struct asd_softc *asd, struct asd_device *dev)
+{
+	u_int	usertags;
+	
+	/*
+	 * Sanity Check to make sure the Queue Depth within supported range.
+	 */
+	if ((cmd_per_lun > ASD_MAX_TCQ_PER_DEVICE) ||
+	    (cmd_per_lun < ASD_MIN_TCQ_PER_DEVICE))
+		/* Set the Queue Depth to default (32). */
+		cmd_per_lun = ASD_DEF_TCQ_PER_DEVICE;
+	/*
+	 * No queuing support yet for SATA II devices.
+ 	 */
+	if ((dev->target->command_set_type == ASD_COMMAND_SET_ATA) ||
+	    (dev->target->command_set_type == ASD_COMMAND_SET_ATAPI))
+		usertags = 0;
+	else
+		usertags = cmd_per_lun;
+	
+	return (usertags);
+}
+
+/*
+ * Function:
+ *	asd_set_device_queue_depth()
+ *
+ * Description: 	  
+ * 	Determines the queue depth for a given device.
+ */
+static void
+asd_set_device_queue_depth(struct asd_softc *asd, struct asd_device *dev)
+{
+	u_int	tags;
+
+	ASD_LOCK_ASSERT(asd);
+
+	tags = asd_get_user_tagdepth(asd, dev);
+	if (tags != 0 && dev->scsi_device != NULL && 
+	    dev->scsi_device->tagged_supported != 0) {
+		asd_set_tags(asd, dev, ASD_QUEUE_TAGGED);
+
+		asd_print("%s:%d:%d:%d: Tagged Queuing enabled.  Depth %d\n",
+			  asd_name(asd),
+			  dev->target->domain->channel_mapping,
+			  dev->target->target_id, dev->lun,
+			  dev->openings + dev->active);
+	} else {
+		asd_set_tags(asd, dev, ASD_QUEUE_NONE);
+	}
+}
+
+/*
+ * Function:
+ *	asd_set_tags()
+ *
+ * Description: 	  
+ * 	Set the device queue depth.
+ */
+static void
+asd_set_tags(struct asd_softc *asd, struct asd_device *dev, asd_queue_alg alg)
+{
+	int was_queuing;
+	int now_queuing;
+
+	was_queuing = dev->flags & (ASD_DEV_Q_BASIC|ASD_DEV_Q_TAGGED);
+	switch (alg) {
+	default:
+	case ASD_QUEUE_NONE:
+		now_queuing = 0;
+		break; 
+	case ASD_QUEUE_BASIC:
+		now_queuing = ASD_DEV_Q_BASIC;
+		break;
+	case ASD_QUEUE_TAGGED:
+		now_queuing = ASD_DEV_Q_TAGGED;
+		break;
+	}
+
+	dev->flags &= ~(ASD_DEV_Q_BASIC|ASD_DEV_Q_TAGGED);
+	if (now_queuing) {
+		u_int usertags;
+
+		usertags = asd_get_user_tagdepth(asd, dev);
+		if (!was_queuing) {
+			/*
+			 * Start out agressively and allow our
+			 * dynamic queue depth algorithm to take
+			 * care of the rest.
+			 */
+			dev->maxtags = usertags;
+			dev->openings = dev->maxtags - dev->active;
+		}
+		if (dev->maxtags == 0)
+			/*
+			 * Queueing is disabled by the user.
+			 */
+			dev->openings = 1;
+		else if (alg == ASD_QUEUE_TAGGED)
+			dev->flags |= ASD_DEV_Q_TAGGED;
+		else
+			dev->flags |= ASD_DEV_Q_BASIC;
+	} else {
+		/* We can only have one opening. */
+		dev->maxtags = 0;
+		dev->openings =  1 - dev->active;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	if (dev->scsi_device != NULL) {
+		switch ((dev->flags & (ASD_DEV_Q_BASIC|ASD_DEV_Q_TAGGED))) {
+		case ASD_DEV_Q_BASIC:
+			scsi_adjust_queue_depth(dev->scsi_device,
+						MSG_SIMPLE_TAG,
+						dev->maxtags);
+			break;
+		case ASD_DEV_Q_TAGGED:
+			scsi_adjust_queue_depth(dev->scsi_device,
+						MSG_ORDERED_TAG,
+						dev->maxtags);
+			break;
+		default:
+			/*
+			 * We allow the OS to queue 2 untagged transactions to
+			 * us at any time even though we can only execute them
+			 * serially on the controller/device.  This should
+			 * remove some latency.
+			 */
+			scsi_adjust_queue_depth(dev->scsi_device,
+						/* NON-TAGGED */ 0,
+						/* Queue Depth */ 2);
+			break;
+		}
+	}
+#endif
+}
+
+		       
+/*
+ * asd_info()
+ *
+ * Description:
+ *	Return an info regarding the driver to the OS.
+ */
+static const char *
+asd_info(struct Scsi_Host  *scsi_host)
+{
+	struct asd_softc	*asd;
+	const char		*info;
+	
+	info = "";
+	asd = *((struct asd_softc **) scsi_host->hostdata);
+		
+	if (asd_get_softc(asd) != NULL) {
+		info = ((struct asd_pci_driver_data *) 
+				(asd->pci_entry->driver_data))->description;
+	}
+
+	return (info);
+}
+
+
+/**************************** OS Error Handling *******************************/
+
+/*
+ * Function:
+ *	asd_ehandler_thread()
+ *
+ * Description:
+ *	Thread to handle error recovery.
+ */ 
+static int
+asd_ehandler_thread(void *data)
+{
+	struct asd_softc	*asd;
+	u_long			 flags;	
+
+	asd = (struct asd_softc *) data;
+
+	lock_kernel();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,60)
+	/*
+	 * Don't care about any signals.
+	 */
+	siginitsetinv(&current->blocked, 0);
+	daemonize();
+	sprintf(current->comm, "asd_eh_%d", asd->profile.unit);
+#else
+	daemonize("asd_eh_%d", asd->profile.unit);
+	current->flags |= PF_FREEZE;	
+#endif
+	unlock_kernel();
+
+	while (1) {
+		/*
+		 * Use down_interruptible() rather than down() to
+		 * avoid this thread to be counted in the load average as
+		 * a running process.
+		 */
+		down_interruptible(&asd->platform_data->ehandler_sem);
+
+		/* Check to see if we've been signaled to exit. */
+		asd_lock(asd, &flags);
+		if ((asd->platform_data->flags & ASD_RECOVERY_SHUTDOWN) != 0) {
+			asd_unlock(asd, &flags);
+			break;
+		}
+		/* 
+		 * Check if any timedout commands that required 
+		 * error handling. 
+		 */
+		if (list_empty(&asd->timedout_scbs)) {
+			asd_unlock(asd, &flags);
+			continue;
+		}
+		asd_unlock(asd, &flags);
+
+		asd_recover_cmds(asd);
+	}
+
+	up(&asd->platform_data->ehandler_ending_sem);
+
+	return (0);
+}
+
+/*
+ * Function:
+ * 	asd_kill_ehandler_thread()
+ * 
+ * Description:
+ * 	Kill the error handling thread.
+ */
+static void
+asd_kill_ehandler_thread(struct asd_softc *asd)
+{
+	u_long	flags;
+
+	asd_lock(asd, &flags);
+
+	if (asd->platform_data->ehandler_pid != 0) {
+		asd->platform_data->flags |= ASD_RECOVERY_SHUTDOWN;
+		asd_unlock(asd, &flags);
+		up(&asd->platform_data->ehandler_sem);
+		asd->platform_data->ehandler_pid = 0;
+	} else {
+		asd_unlock(asd, &flags);
+	}
+}
+
+static void
+asd_ehandler_done(struct asd_softc *asd, struct scb *scb)
+{
+	scb->platform_data->flags &= ~ASD_SCB_UP_EH_SEM;
+	asd_wakeup_sem(&asd->platform_data->eh_sem);
+}
+
+/*
+ * asd_abort()
+ *
+ * Description:
+ *	Perform abort for the requested command.
+ */
+static int
+asd_abort(Scsi_Cmnd *cmd)
+{
+	struct asd_softc	*asd;
+	struct asd_device	*dev;
+	struct scb		*scb_to_abort;
+	union asd_cmd 		*acmd;
+	union asd_cmd 		*list_acmd;
+	int			 retval;
+	int			 found;
+	unsigned long		 flags;
+
+#ifdef ASD_DEBUG
+	asd_log(ASD_DBG_INFO, "(scsi%d: Ch %d Id %d Lun %d): ",
+		  cmd->device->host->host_no,
+		  cmd->device->channel, cmd->device->id, cmd->device->lun);
+//JD
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+	asd_log(ASD_DBG_INFO, "Abort requested for SCSI cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x abort:%d vs current:%d), opcode 0x%x.\n", 
+#else	
+	asd_log(ASD_DBG_INFO, "Abort requested for SCSI cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x vs current:%d), opcode 0x%x.\n", 
+#endif
+			cmd->cmnd[2],
+			cmd->cmnd[3],
+			cmd->cmnd[4],
+			cmd->cmnd[5],
+			cmd->cmnd[7],
+			cmd->cmnd[8],
+		  cmd->tag,
+		  cmd->pid,
+		  cmd->resid,
+		  cmd->timeout_per_command,
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+		  cmd->abort_reason,
+#endif
+		  (jiffies / HZ),
+		  cmd->cmnd[0]);
+#endif
+	asd = *(struct asd_softc **) cmd->device->host->hostdata;
+	acmd = (union asd_cmd *) cmd;
+	found = 0;
+	retval = SUCCESS;
+
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,16)
+ 		asd_lock(asd, &flags);
+#else
+		asd_sml_lock(asd);
+#endif
+
+	/* See if any existing device owns this command. */
+	dev = asd_get_device(asd, cmd->device->channel,
+			     cmd->device->id, cmd->device->lun, 0);
+	if (dev == NULL) {
+		/*
+		 * No device exists that owns this command. 
+		 * Return abort successful for the requested command.
+		 */
+		asd_print("(scsi%d: Ch %d Id %d Lun %d): ",
+			  cmd->device->host->host_no, cmd->device->channel, 
+			  cmd->device->id, cmd->device->lun);
+		asd_print("Is not an active device.\n");
+		retval = SUCCESS;
+		goto exit;
+	}
+
+#ifdef ASD_DEBUG	
+	{
+		struct asd_target *t = NULL;
+#ifdef MULTIPATH_IO
+		t = dev->current_target;
+#else
+		t = dev->target;
+#endif
+		if (!t)
+			t = dev->target;
+		asd_print("t->ddb_profile.conn_handle=0x%x\n", t->ddb_profile.conn_handle);
+/* 		asd_hwi_dump_seq_state(asd, t->src_port->conn_mask); */
+/* 		asd_hwi_dump_ddb_site(asd, t->ddb_profile.conn_handle); */
+	}
+#endif /* ASD_DEBUG */
+
+	/*
+	 * Check if the cmd is still in the device queue.
+	 */ 
+	list_for_each_entry(list_acmd, &dev->busyq, acmd_links) {
+//JD
+#ifdef ASD_DEBUG
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+		asd_log(ASD_DBG_INFO, "Checking busy queue cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x, abort:0x%x).\n",
+#else
+		asd_log(ASD_DBG_INFO, "Checking busy queue cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x).\n",
+#endif
+			list_acmd->scsi_cmd.cmnd[2],
+			list_acmd->scsi_cmd.cmnd[3],
+			list_acmd->scsi_cmd.cmnd[4],
+			list_acmd->scsi_cmd.cmnd[5],
+			list_acmd->scsi_cmd.cmnd[7],
+			list_acmd->scsi_cmd.cmnd[8],
+			list_acmd->scsi_cmd.tag,
+			list_acmd->scsi_cmd.pid,
+			list_acmd->scsi_cmd.resid,
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+			list_acmd->scsi_cmd.timeout_per_command,
+			list_acmd->scsi_cmd.abort_reason);
+#else
+			list_acmd->scsi_cmd.timeout_per_command);
+#endif
+#endif
+		if (list_acmd == acmd) {
+			/* Found it. */
+			found = 1;
+			break;
+		}
+	}
+	if (found == 1) {
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "Cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x found on device queue.\n", 
+			cmd->cmnd[2],
+			cmd->cmnd[3],
+			cmd->cmnd[4],
+			cmd->cmnd[5],
+			cmd->cmnd[7],
+			cmd->cmnd[8]);
+		asd_print_path(asd, dev);
+		asd_print("Cmd %p found on device queue.\n", cmd);
+#endif
+		list_del(&list_acmd->acmd_links);
+		asd_cmd_set_host_status(cmd, DID_ABORT);
+		cmd->scsi_done(cmd);
+		retval = SUCCESS;
+		goto exit;
+	}
+
+	/*
+	 * Check if the cmd has been submitted to the device.
+	 */
+	list_for_each_entry(scb_to_abort, &asd->platform_data->pending_os_scbs,
+			    owner_links) {
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "Checking pending_os_scbs scb_to_abort->io_ctx %p TC 0x%x.\n", scb_to_abort->io_ctx, SCB_GET_INDEX(scb_to_abort));
+		asd_log(ASD_DBG_INFO, "scb_to_abort=%p\n", scb_to_abort);
+
+#endif
+
+		if (scb_to_abort->io_ctx == acmd) {
+			/* Found it. */
+
+			found = 1;
+			break;
+		}
+	}
+	if (found != 1) {
+		/*
+		 * Looks like we are trying to abort command that has
+		 * been completed.
+		 */
+#ifdef ASD_DEBUG
+		asd_log(ASD_DBG_INFO, "Cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x not found , opcode 0x%x.\n", 			
+			cmd->cmnd[2],
+			cmd->cmnd[3],
+			cmd->cmnd[4],
+			cmd->cmnd[5],
+			cmd->cmnd[7],
+			cmd->cmnd[8],
+			cmd->cmnd[0]);
+#endif
+		asd_print_path(asd, dev);
+		asd_print("Cmd %p not found.\n", cmd);
+		retval = SUCCESS;
+		goto exit;
+	}
+//JD
+#ifdef ASD_DEBUG
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+	asd_log(ASD_DBG_INFO, "Remove this command and put it into timeout SCSI cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x abort:%d), opcode 0x%x.\n", 
+#else
+	asd_log(ASD_DBG_INFO, "Remove this command and put it into timeout SCSI cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x), opcode 0x%x.\n", 
+#endif
+			cmd->cmnd[2],
+			cmd->cmnd[3],
+			cmd->cmnd[4],
+			cmd->cmnd[5],
+			cmd->cmnd[7],
+			cmd->cmnd[8],
+		cmd->tag,
+		cmd->pid,
+		cmd->resid,
+		cmd->timeout_per_command,
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+		cmd->abort_reason,
+#endif
+		cmd->cmnd[0]);
+#endif
+#if 0
+	asd_log(ASD_DBG_INFO, "aborted cmd sas address=%02x%02x%02x%02x%02x%02x%02x%02x\n",
+		dev->target->ddb_profile.sas_addr[0],
+		dev->target->ddb_profile.sas_addr[1],
+		dev->target->ddb_profile.sas_addr[2],
+		dev->target->ddb_profile.sas_addr[3],
+		dev->target->ddb_profile.sas_addr[4],
+		dev->target->ddb_profile.sas_addr[5],
+		dev->target->ddb_profile.sas_addr[6],
+		dev->target->ddb_profile.sas_addr[7]);
+#endif
+#if 0
+	    asd_hwi_pause_cseq(asd);
+	    asd_hwi_pause_lseq(asd, asd->hw_profile.enabled_phys);
+		asd_hwi_dump_ddb_sites_new(asd);
+		asd_hwi_dump_scb_sites_new(asd);
+		asd_hwi_dump_seq_state(asd, asd->hw_profile.enabled_phys);
+		asd_hwi_unpause_cseq(asd);
+	    asd_hwi_unpause_lseq(asd, asd->hw_profile.enabled_phys);
+#endif
+	/*
+	 * Set the level of error recovery for the error handler thread
+         * to perform.
+	 */
+	scb_to_abort->eh_state = SCB_EH_ABORT_REQ;
+	scb_to_abort->eh_post = asd_ehandler_done;
+	/*
+	 * Mark this SCB as timedout and add it to the timeout queue.
+	 */	 
+	scb_to_abort->flags |= SCB_TIMEDOUT;
+	list_add_tail(&scb_to_abort->timedout_links, &asd->timedout_scbs);
+	
+	asd_wakeup_sem(&asd->platform_data->ehandler_sem);
+	asd->platform_data->flags |= ASD_SCB_UP_EH_SEM;
+
+	/* Release the host's lock prior putting the process to sleep. */
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,16)
+		// it lock by abort rtn, just go to unlock it
+		asd_unlock(asd, &flags);
+#else
+		/* Release the host's lock prior putting the process to sleep. */
+		spin_unlock_irq(&asd->platform_data->spinlock);
+#endif
+	
+	asd_sleep_sem(&asd->platform_data->eh_sem);
+ 	if (scb_to_abort->eh_status == SCB_EH_SUCCEED)
+ 		retval = SUCCESS;
+ 	else
+ 		retval = FAILED;
+
+	/* Acquire the host's lock. */
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,16)
+		asd_lock(asd, &flags);
+#else
+		spin_lock_irq(&asd->platform_data->spinlock);
+#endif
+	
+exit:
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,16)
+		// it lock by abort rtn, just go to unlock it
+		asd_unlock(asd, &flags);
+#else
+		asd_sml_unlock(asd);
+#endif
+	return (retval);
+}
+
+/******************************** Bus DMA *************************************/
+
+int
+asd_dma_tag_create(struct asd_softc *asd, uint32_t alignment, uint32_t maxsize,
+		   int flags, bus_dma_tag_t *ret_tag)
+{
+	bus_dma_tag_t dmat;
+
+	dmat = asd_alloc_mem(sizeof(*dmat), flags);
+	if (dmat == NULL)
+		return (-ENOMEM);
+
+	dmat->alignment = alignment;
+	dmat->maxsize = maxsize;
+	*ret_tag = dmat;
+	return (0);
+}
+
+void
+asd_dma_tag_destroy(struct asd_softc *asd, bus_dma_tag_t dmat)
+{
+	asd_free_mem(dmat);
+}
+
+int
+asd_dmamem_alloc(struct asd_softc *asd, bus_dma_tag_t dmat, void** vaddr,
+		 int flags, bus_dmamap_t *mapp, dma_addr_t *baddr)
+{
+	bus_dmamap_t map;
+
+	map = asd_alloc_mem(sizeof(*map), flags);
+	if (map == NULL)
+		return (-ENOMEM);
+
+	*vaddr = asd_alloc_coherent(asd, dmat->maxsize, &map->bus_addr);
+	if (*vaddr == NULL) {
+		asd_free_mem(map);
+		return (-ENOMEM);
+	}
+	*mapp = map;
+	*baddr = map->bus_addr;
+	return(0);
+}
+
+void
+asd_dmamem_free(struct asd_softc *asd, bus_dma_tag_t dmat, void *vaddr,
+		bus_dmamap_t map)
+{
+	asd_free_coherent(asd, dmat->maxsize, vaddr, map->bus_addr);
+}
+
+void
+asd_dmamap_destroy(struct asd_softc *asd, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	asd_free_mem(map);
+}
+
+int
+asd_alloc_dma_mem(struct asd_softc *asd, unsigned length, void **vaddr,
+		  dma_addr_t *bus_addr, bus_dma_tag_t *buf_dmat,
+		  struct map_node *buf_map)
+{
+	if (asd_dma_tag_create(asd, 4, length, GFP_ATOMIC, buf_dmat) != 0)
+		return (-ENOMEM);
+
+	if (asd_dmamem_alloc(asd, *buf_dmat, (void **) &buf_map->vaddr,
+			     GFP_ATOMIC, &buf_map->dmamap,
+			     &buf_map->busaddr) != 0) {
+		asd_dma_tag_destroy(asd, *buf_dmat);
+		return (-ENOMEM);
+	}
+
+	*vaddr = (void *) buf_map->vaddr;
+	*bus_addr = buf_map->busaddr;
+	memset(*vaddr, 0, length);
+
+	return 0;
+}
+
+void
+asd_free_dma_mem(struct asd_softc *asd, bus_dma_tag_t buf_dmat,
+		 struct map_node *buf_map)
+{
+	asd_dmamem_free(asd, buf_dmat, buf_map->vaddr, buf_map->dmamap);
+	asd_dmamap_destroy(asd, buf_dmat, buf_map->dmamap);
+	asd_dma_tag_destroy(asd, buf_dmat);
+}
+
+/*************************** Platform Data Routines ***************************/
+
+struct asd_scb_platform_data *
+asd_alloc_scb_platform_data(struct asd_softc *asd)
+{
+	struct asd_scb_platform_data *pdata;
+	
+	pdata = (struct asd_scb_platform_data *) asd_alloc_mem(sizeof(*pdata),
+							       GFP_ATOMIC);
+	return (pdata);
+}
+
+void
+asd_free_scb_platform_data(struct asd_softc *asd,
+			   struct asd_scb_platform_data *pdata)
+{
+	asd_free_mem(pdata);
+}
+
+
+/**************************** Proc Filesystem support *************************/
+
+typedef struct proc_info_str {
+	char	*buf;
+	int	len;
+	off_t	off;
+	int	pos;
+} proc_info_str_t;
+
+static void	copy_mem_info(proc_info_str_t *info_str, char *data, int len);
+static int	copy_info(proc_info_str_t *info_str, char *fmt, ...);
+
+static void
+copy_mem_info(proc_info_str_t *info_str, char *data, int len)
+{
+	if (info_str->pos + len > info_str->off + info_str->len)
+		len = info_str->off + info_str->len - info_str->pos;
+
+	if (info_str->pos + len < info_str->off) {
+		info_str->pos += len;
+		return;
+	}
+
+	if (info_str->pos < info_str->off) {
+		off_t partial;
+
+		partial = info_str->off - info_str->pos;
+		data += partial;
+		info_str->pos += partial;
+		len  -= partial;
+	}
+
+	if (len > 0) {
+		memcpy(info_str->buf, data, len);
+		info_str->pos += len;
+		info_str->buf += len;
+	}
+}
+
+static int
+copy_info(proc_info_str_t *info_str, char *fmt, ...)
+{
+	va_list	args;
+	char 	buf[256];
+	int 	len;
+
+	va_start(args, fmt);
+	len = vsprintf(buf, fmt, args);
+	va_end(args);
+
+	copy_mem_info(info_str, buf, len);
+	return (len);
+}
+
+void
+asd_dump_indent(
+proc_info_str_t	*info_str,
+unsigned	indent
+)
+{
+	unsigned		i;
+
+	for (i = 0 ; i < indent ; i++) {
+		copy_info(info_str, "   ");
+	}
+}
+
+void
+asd_dump_conn_rate(
+proc_info_str_t	*info_str,
+unsigned	conn_rate
+)
+{
+	switch (conn_rate) {
+	case SAS_RATE_30GBPS:
+		copy_info(info_str, "3000 Mb/s");
+		break;
+	case SAS_RATE_15GBPS:
+		copy_info(info_str, "1500 MB/s");
+		break;
+	default:
+		copy_info(info_str, "\?\? MB/s");
+		break;
+	}
+}
+
+static void
+asd_dump_target_info(struct asd_softc *asd, proc_info_str_t *info_str,
+	struct asd_port *port, struct asd_target *targ, unsigned indent)
+{
+	unsigned		i;
+	struct Discover		*discover;
+	struct asd_target	*child_target;
+	struct hd_driveid	*hd_driveidp;
+
+	asd_dump_indent(info_str, indent);
+
+#if 0	
+	copy_info(info_str, "  SAS Address: %0llx\n", asd_be64toh(
+		*((uint64_t *)targ->ddb_profile.sas_addr)));
+#endif
+	
+	copy_info(info_str, "  Connected to ");
+	switch (targ->transport_type) {
+	case ASD_TRANSPORT_SSP:
+		copy_info(info_str, "SAS End Device. ");	
+		copy_info(info_str, "SAS Address: %0llx\n", asd_be64toh(
+			  *((uint64_t *)targ->ddb_profile.sas_addr)));
+
+		asd_dump_indent(info_str, indent);
+		if (targ->scsi_cmdset.inquiry != NULL) {
+			copy_info(info_str,
+				"  Vendor: %8.8s Product: %16.16s "
+				"Revision: %4.4s\n",
+				&targ->scsi_cmdset.inquiry[8],
+				&targ->scsi_cmdset.inquiry[16],
+				&targ->scsi_cmdset.inquiry[32]);
+		}
+		break;
+
+	case ASD_TRANSPORT_STP:
+	case ASD_TRANSPORT_ATA:
+		hd_driveidp = &targ->ata_cmdset.adp_hd_driveid;
+		copy_info(info_str, "SATA End Device. ");
+		copy_info(info_str, "Mapped SAS Address: %0llx\n", asd_be64toh(
+			  *((uint64_t *)targ->ddb_profile.sas_addr)));
+		asd_dump_indent(info_str, indent);
+		copy_info(info_str,
+			"  Vendor: %8.8s Product: %16.16s "
+			"Revision: %4.4s\n",
+			hd_driveidp->model,
+			hd_driveidp->model + 8,
+			hd_driveidp->fw_rev);
+		break;
+
+	case ASD_TRANSPORT_SMP:
+		switch (targ->management_type)
+		{
+		case ASD_DEVICE_EDGE_EXPANDER:
+			copy_info(info_str, "Edge Expander Device. ");
+			copy_info(info_str, "SAS Address: %0llx\n", asd_be64toh(
+				  *((uint64_t *)targ->ddb_profile.sas_addr)));
+			break;
+
+		case ASD_DEVICE_FANOUT_EXPANDER:
+			copy_info(info_str, "Fanout Expander Device. ");
+			copy_info(info_str, "SAS Address: %0llx\n", asd_be64toh(
+				  *((uint64_t *)targ->ddb_profile.sas_addr)));
+			break;
+
+		default:
+			copy_info(info_str, "Unknown Device.");
+			break;
+		}
+
+		asd_dump_indent(info_str, indent);
+		copy_info(info_str,
+			"  Vendor: %8.8s Product: %16.16s Revision: %4.4s - ",
+			targ->smp_cmdset.manufacturer_info.VendorIdentification,
+			targ->smp_cmdset.manufacturer_info.
+				ProductIdentification,
+			targ->smp_cmdset.manufacturer_info.	
+				ProductRevisionLevel);
+		break;
+
+	default:
+		copy_info(info_str, "Unknown Device.");
+		break;
+	}
+
+	if (targ->management_type == ASD_DEVICE_END) {
+		asd_dump_indent(info_str, indent);
+		copy_info(info_str,
+			  "  Host: %d, Channel: %d, Id: %d, LUN: %d\n",
+			  asd->platform_data->scsi_host->host_no,
+			  targ->src_port->id,
+			  targ->target_id,
+			  0);
+		return;
+	}
+
+	copy_info(info_str, "Total Phys: %d\n", targ->num_phys);
+
+	asd_dump_indent(info_str, indent);
+
+	copy_info(info_str, "  Routing: ");
+
+	discover = NULL;
+
+	for (i = 0 ; i < targ->num_phys ; i++) {
+
+		discover = &(targ->Phy[i].Result);
+
+		switch (discover->RoutingAttribute) {
+		case DIRECT:
+			copy_info(info_str, "%d:D", i);
+			break;
+		case SUBTRACTIVE:
+			copy_info(info_str, "%d:S", i);
+			break;
+		case TABLE:
+			copy_info(info_str, "%d:T", i);
+			break;
+		default:
+			copy_info(info_str, "%d:?", i);
+			break;
+		}
+
+		if (i != (targ->num_phys - 1)) {
+			copy_info(info_str, "|");
+		}
+	}
+
+	copy_info(info_str, "\n");
+
+	indent++;
+
+	list_for_each_entry(child_target, &targ->children, siblings) {
+
+		for (i = 0 ; i < targ->num_phys ; i++) {
+
+			discover = &(targ->Phy[i].Result);
+
+			if (SAS_ISEQUAL(child_target->ddb_profile.sas_addr,
+				discover->AttachedSASAddress)) {
+				break;
+			}
+		}
+
+		if (i == targ->num_phys) {
+			continue;
+		}
+
+		asd_dump_indent(info_str, indent);
+
+		copy_info(info_str, "+ Phy %d ", i);
+		copy_info(info_str, "link rate negotiated: ");
+
+		asd_dump_conn_rate(info_str,
+			discover->NegotiatedPhysicalLinkRate);
+
+		copy_info(info_str, " max: ");
+
+		asd_dump_conn_rate(info_str,
+			discover->HardwareMaximumPhysicalLinkRate);
+
+		copy_info(info_str, " min: ");
+
+		asd_dump_conn_rate(info_str,
+			discover->HardwareMinimumPhysicalLinkRate);
+
+		copy_info(info_str, "\n");
+
+		asd_dump_target_info(asd, info_str, port, child_target, 
+			indent);
+	}
+}
+	
+static void
+asd_dump_port_info(struct asd_softc *asd, proc_info_str_t *info_str, 
+		   int port_id)
+{
+	struct asd_port		*port;
+	struct asd_phy		*phy;
+
+	port = asd->port_list[port_id];
+	
+	copy_info(info_str, "Port %d Settings\n", port_id);
+	if (!list_empty(&port->phys_attached)) {
+		/* Dump out info for every phy connected to this port. */
+		list_for_each_entry(phy, &port->phys_attached, links) {
+			asd_dump_indent(info_str, 1);
+			copy_info(info_str, "+ Phy %d link rate "
+				  "negotiated: %d Mb/s "
+				  "max: %d Mb/s min %d Mb/s\n", 
+				  phy->id, (phy->conn_rate / 100000), 
+				  (phy->max_link_rate / 100000),
+				  (phy->min_link_rate / 100000));
+			asd_dump_indent(info_str, 1);
+			copy_info(info_str, "  Phy SAS Address: %0llx\n", 
+				  asd_be64toh(*((uint64_t *)
+					      phy->sas_addr)));
+		}
+
+		if (port->tree_root != NULL) {
+
+			asd_dump_target_info(asd, info_str, port, 
+				port->tree_root, 1);
+		}
+		else {
+			copy_info(info_str, "\n");
+		}
+	} else {
+		copy_info(info_str, "\n");
+	}
+	
+	copy_info(info_str, "\n");
+}
+
+/*
+ * asd_proc_info()
+ *
+ * Description:
+ *	Entry point for read and write operations to our driver node in the 
+ *	procfs filesystem.
+ */
+static int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+asd_proc_info(char *proc_buffer, char **proc_start, off_t proc_offset,
+	     int proc_length, int proc_hostno, int proc_out)
+#else
+asd_proc_info(struct Scsi_Host *scsi_host, char *proc_buffer, char **proc_start,
+	     off_t proc_offset, int proc_length, int proc_out)
+#endif
+{
+	struct asd_softc  	*asd;
+	proc_info_str_t		 info_str;
+	int			 retval;
+	int			 len;
+	int			 i;
+	
+	retval = -ENOSYS;
+	len = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	list_for_each_entry(asd, &asd_hbas, link) {
+		if (asd->platform_data->scsi_host->host_no == proc_hostno)
+			break;
+	}
+#else
+	asd = asd_get_softc(*(struct asd_softc **) scsi_host->hostdata);
+#endif
+	if (asd == NULL)
+		goto exit;
+	
+	if (proc_out) {
+		/* 
+		 * No support for write yet.
+		 */
+		retval = len;
+	      	goto exit;
+     	}
+
+	*proc_start = proc_buffer;
+
+	info_str.buf = proc_buffer;
+	info_str.len = proc_length;
+	info_str.off = proc_offset;	
+	info_str.pos = 0;	
+
+	copy_info(&info_str, "\nAdaptec Linux SAS/SATA Family Driver\n");
+	copy_info(&info_str, "Rev: %d.%d.%d-%d\n", 
+		  ASD_MAJOR_VERSION, ASD_MINOR_VERSION, 
+		  ASD_BUILD_VERSION, ASD_RELEASE_VERSION);
+	copy_info(&info_str, "Controller WWN: %0llx\n",
+		  asd_be64toh(*((uint64_t *) asd->hw_profile.wwn)));
+	copy_info(&info_str, "\n");
+	
+	for (i = 0; i < asd->hw_profile.max_ports; i++)
+		asd_dump_port_info(asd, &info_str, i);		
+		
+	copy_info(&info_str, "\n");
+
+	retval = info_str.pos > info_str.off ? info_str.pos - info_str.off : 0;
+exit:
+	return (retval);
+}
+
+static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+asd_bios_param(struct scsi_device *sdev, struct block_device *bdev,
+	       sector_t capacity, int geom[])
+{
+	unsigned char		*res;
+#else
+asd_bios_param(Disk *disk, kdev_t dev, int geom[])
+{
+	struct block_device	*bdev;
+	u_long			capacity = disk->capacity;
+#endif
+	struct buffer_head	*bh;
+	int			ret;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	if (bdev == NULL) {
+		return -1;
+	}
+
+	res = kmalloc(66, GFP_KERNEL);
+
+	if (res == NULL) {
+		return -1;
+	}
+
+	bh = __bread(bdev, 0, block_size(bdev));
+#else
+	bh = bread(MKDEV(MAJOR(dev), MINOR(dev)&~0xf), 0, block_size(dev));
+#endif
+
+	if (bh == NULL) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+		kfree(res);
+#endif
+		return -1;
+	}
+
+	/*
+	 * try to infer mapping from partition table
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	memcpy(res, bh->b_data + 0x1be, 66);
+
+	ret = scsi_partsize(res, (unsigned long)capacity,
+		(unsigned int *)geom + 2, (unsigned int *)geom + 0,
+		(unsigned int *)geom + 1);
+#else
+	ret = scsi_partsize(bh, (unsigned long)capacity,
+		(unsigned int *)geom + 2, (unsigned int *)geom + 0,
+		(unsigned int *)geom + 1);
+#endif
+
+	brelse(bh);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	kfree(res);
+#endif
+
+	if ((ret == 0) && (geom[0] <= 255) && (geom[1] <= 63)) {
+		/*
+		 * The partition table had the right answer.
+		 */
+		return 0;
+	}
+
+	/*
+	 * if something went wrong, then apparently we have to return
+	 * a geometry with more than 1024 cylinders
+	 */
+	geom[0] = 64; // heads
+	geom[1] = 32; // sectors
+	geom[2] = asd_sector_div(capacity, geom[0], geom[1]);
+
+	if (geom[2] >= 1024) {
+		geom[0] = 255;
+		geom[1] = 63;
+		geom[2] = asd_sector_div(capacity, geom[0], geom[1]);
+	}
+
+	if (capacity > 65535*63*255) {
+		geom[2] = 65535;
+	} else {
+		geom[2] = (unsigned long)capacity / (geom[0] * geom[1]);
+	}
+
+#if 0
+	geom[0] = 64; // heads
+	geom[1] = 32; // sectors
+	geom[2] = asd_sector_div(capacity, geom[0], geom[1]);
+#endif
+
+	return 0;
+}
+
+/*************************** ASD Scsi Host Template ***************************/
+
+static Scsi_Host_Template asd_sht = {
+	.module			= THIS_MODULE,
+	.name			= ASD_DRIVER_NAME,
+	.proc_info		= asd_proc_info,
+	.proc_name		= ASD_DRIVER_NAME,
+	.info			= asd_info,
+	.queuecommand		= asd_queue,
+	.eh_abort_handler	= asd_abort,
+	.can_queue		= 2,
+	.this_id		= -1,
+	.max_sectors		= ASD_MAX_SECTORS,
+	.cmd_per_lun		= 2,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.bios_param             = asd_bios_param,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	.slave_alloc		= asd_slave_alloc,
+	.slave_configure	= asd_slave_configure,
+	.slave_destroy		= asd_slave_destroy,
+#else
+	.detect			= asd_detect,
+	.release		= asd_release,
+	.select_queue_depths	= asd_select_queue_depth,
+	.use_new_eh_code	= 1,
+#endif		
+};
+
+
+module_init(asd_init);
+module_exit(asd_exit);
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_osm.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_osm.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_osm.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_osm.h	2007-04-20 14:21:17.000000000 +0000
@@ -0,0 +1,1435 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux. 
+ *
+ * Written by : David Chaw <david_chaw@adaptec.com>
+ * 
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+
+#ifndef ADP94XX_OSM_H
+#define ADP94XX_OSM_H
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/smp_lock.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/config.h>
+#include <linux/slab.h>
+#include <linux/nmi.h>
+#include <linux/hdreg.h>
+#include <asm/uaccess.h>
+#include <linux/ioctl.h>
+#include <linux/init.h>
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(x,y,z)	(((x)<<16) + ((y)<<8) + (z))
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <linux/blk.h>
+#include "sd.h"
+#include "hosts.h"
+#include "scsi.h"
+#else
+#include <linux/moduleparam.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_driver.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#include <scsi/scsi_request.h>
+#endif
+#include <scsi/scsi.h>
+#include <scsi/scsi_eh.h>
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsicam.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+#include "scsi_priv.h"
+#endif
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+typedef struct scsi_cmnd Scsi_Cmnd;
+typedef struct scsi_device Scsi_Device;
+typedef struct scsi_request Scsi_Request;
+typedef struct scsi_host_template Scsi_Host_Template;
+#endif
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef SCSI_DATA_READ
+#define SCSI_DATA_READ  DMA_FROM_DEVICE
+#define SCSI_DATA_WRITE DMA_TO_DEVICE
+#define SCSI_DATA_UNKNOWN DMA_BIDIRECTIONAL
+#define SCSI_DATA_NONE  DMA_NONE
+#define scsi_to_pci_dma_dir(_a) (_a)
+#endif
+#include <linux/blkdev.h>
+
+#define __packed __attribute__ ((packed))
+
+/* Driver name */
+#define ASD_DRIVER_NAME		"adp94xx"
+#define ASD_DRIVER_DESCRIPTION	"Adaptec Linux SAS/SATA Family Driver"
+#define ASD_MAJOR_VERSION 	1
+#define ASD_MINOR_VERSION 	0
+#ifdef SEQUENCER_UPDATE
+#define ASD_BUILD_VERSION 	8
+#define ASD_RELEASE_VERSION 	12
+#define ASD_DRIVER_VERSION	"1.0.8-12"
+#else
+#define ASD_BUILD_VERSION 	7
+#define ASD_RELEASE_VERSION 	5
+#define ASD_DRIVER_VERSION	"1.0.7"
+#endif
+
+/* For now, let's limit ourselves on kernel 2.4, 2.6 and greater */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#error "This driver only support kernel 2.4 or greater"
+#endif
+
+/************************* Forward Declarations *******************************/
+struct asd_softc;
+struct asd_port;
+struct scb;
+struct asd_scb_platform_data; 
+struct asd_domain;
+struct asd_done_list;
+
+/********************* Definitions Required by the Core ***********************/
+/*
+ * Number of SG segments we require.  So long as the S/G segments for
+ * a particular transaction are allocated in a physically contiguous
+ * manner, the number of S/G segments is unrestricted.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/*
+ * We dynamically adjust the number of segments in pre-2.5 kernels to
+ * avoid fragmentation issues in the SCSI mid-layer's private memory
+ * allocator.  See adp94xx_osm.c asd_size_nseg() for details.
+ */
+extern u_int asd_nseg;
+#define	ASD_NSEG 		asd_nseg
+#define	ASD_LINUX_MIN_NSEG 	64
+#else
+#define	ASD_NSEG 		128
+#endif
+
+/* Constants definition */
+#define ASD_MAX_QUEUE		ASD_MAX_ALLOCATED_SCBS
+
+/*
+ * DC: Does MAX_SECTORS 255 works for some SATA drives ?
+ *     Preferable set it to 255 for better performance in 2.6 kernel.
+ *     In 2.4 kernel, it seems that block layer always limited to 64 sectors.
+ */ 
+//#define ASD_MAX_SECTORS	8192
+#define ASD_MAX_SECTORS		128
+#define ASD_MAX_IO_HANDLES	6
+
+/* Device mapping definition */
+/*
+ * XXX This should really be limited by SAS/SAM.  With
+ *     the use of hash tables in the domain and target
+ *     structures as well as DDB site recycling, we
+ *     should have no limit.
+ */
+#define ASD_MAX_LUNS		128
+#define SAS_LUN_LEN		8
+
+/********************************** Misc Macros *******************************/
+#ifndef roundup
+#define	roundup(x, y)   	((((x)+((y)-1))/(y))*(y))
+#endif
+
+static inline uint32_t
+roundup_pow2(uint32_t val)
+{
+	val--;
+	val |= val >> 1;
+	val |= val >> 2;
+	val |= val >> 4;
+	val |= val >> 8;
+	val |= val >> 16;
+	return (val + 1);
+}
+
+#ifndef powerof2
+#define	powerof2(x)	((((x)-1)&(x))==0)
+#endif
+
+#ifndef MAX
+#define MAX(a,b) 	(((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef MIN
+#define MIN(a,b) 	(((a) < (b)) ? (a) : (b))
+#endif
+
+#define NUM_ELEMENTS(array) (sizeof(array) / sizeof(*array))
+
+/******************************* Byte Order ***********************************/
+#define asd_htobe16(x)		cpu_to_be16(x)
+#define asd_htobe32(x)		cpu_to_be32(x)
+#define asd_htobe64(x)		cpu_to_be64(x)
+#define asd_htole16(x)		cpu_to_le16(x)
+#define asd_htole32(x)		cpu_to_le32(x)
+#define asd_htole64(x)		cpu_to_le64(x)
+
+#define asd_be16toh(x)		be16_to_cpu(x)
+#define asd_be32toh(x)		be32_to_cpu(x)
+#define asd_be64toh(x)		be64_to_cpu(x)
+#define asd_le16toh(x)		le16_to_cpu(x)
+#define asd_le32toh(x)		le32_to_cpu(x)
+#define asd_le64toh(x)		le64_to_cpu(x)
+
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+
+#ifndef BYTE_ORDER
+#if defined(__BIG_ENDIAN)
+#define BYTE_ORDER BIG_ENDIAN
+#endif
+#if defined(__LITTLE_ENDIAN)
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+#endif /* BYTE_ORDER */
+
+/***************************** Bus Space/DMA **********************************/
+
+struct asd_dma_tag
+{
+	uint32_t	alignment;
+	uint32_t	maxsize;
+};
+typedef struct asd_dma_tag *bus_dma_tag_t;
+
+struct asd_dmamap
+{
+	dma_addr_t	bus_addr;
+};
+typedef struct asd_dmamap * bus_dmamap_t;
+
+/*
+ * Data structure used to track a slab of DMA
+ * safe memory.
+ */
+struct map_node {
+	bus_dmamap_t	 dmamap;
+	dma_addr_t	 busaddr;
+	uint8_t		*vaddr;
+	struct list_head links;
+};
+
+int	asd_dma_tag_create(struct asd_softc *, uint32_t /*alignment*/,
+			   uint32_t /*maxsize*/, int /*flags*/,
+			   bus_dma_tag_t * /*dma_tagp*/);
+void	asd_dma_tag_destroy(struct asd_softc *, bus_dma_tag_t /*tag*/);
+int	asd_dmamem_alloc(struct asd_softc *, bus_dma_tag_t /*dmat*/,
+			 void** /*vaddr*/, int /*flags*/,
+			 bus_dmamap_t * /*mapp*/, dma_addr_t * /*baddr*/);
+void	asd_dmamem_free(struct asd_softc *, bus_dma_tag_t /*dmat*/,
+			void* /*vaddr*/, bus_dmamap_t /*map*/);
+void	asd_dmamap_destroy(struct asd_softc *, bus_dma_tag_t /*tag*/,
+			   bus_dmamap_t /*map*/);
+int	asd_alloc_dma_mem(struct asd_softc *, unsigned, void **,
+			  dma_addr_t *, bus_dma_tag_t *, struct map_node *);
+void	asd_free_dma_mem(struct asd_softc *, bus_dma_tag_t, struct map_node *);
+
+/* IOCTL registration wrappers */
+int 	asd_register_ioctl_dev(void);
+int 	asd_unregister_ioctl_dev(void);
+int 	asd_ctl_init_internal_data(struct asd_softc *asd);
+struct asd_softc * asd_get_softc_by_hba_index(uint32_t hba_index);
+int 	asd_get_number_of_hbas_present(void);
+struct asd_target * 
+	asd_get_os_target_from_port(struct asd_softc *asd,
+				    struct asd_port *port,
+				    struct asd_domain *dm);
+struct asd_device *
+	asd_get_device_from_lun(struct asd_softc *asd, 
+				struct asd_target *targ, uint8_t *saslun);
+int 	asd_get_os_platform_map_from_sasaddr(struct asd_softc *asd, 
+					     struct asd_port *port,
+					     uint8_t *sasaddr, uint8_t *saslun, 
+					     uint8_t *host, uint8_t *bus, 
+					     uint8_t *target, uint8_t *lun);
+struct asd_port *
+	asd_get_sas_addr_from_platform_map(struct asd_softc *asd, 
+					   uint8_t host, uint8_t bus, 
+					   uint8_t target, uint8_t lun, 
+					   uint8_t *sasaddr, uint8_t *saslun);
+struct asd_target * 
+	asd_get_sas_target_from_sasaddr(struct asd_softc *asd, 
+					struct asd_port *port, 
+					uint8_t *sasaddr);
+struct asd_target * 
+	asd_get_os_target_from_sasaddr(struct asd_softc *asd, 
+			 	       struct asd_domain *dm, 
+				       uint8_t *sasddr);
+struct scb *
+	asd_find_pending_scb_by_qtag(struct asd_softc *asd, uint32_t qtag);
+
+int	asd_hwi_check_cmd_pending(struct asd_softc *asd, struct scb *scb, 
+		       		  struct asd_done_list *dl);
+
+/* indicates that the scsi_cmnd is generated by CSMI */
+#define ASD_CSMI_COMMAND 0xfaceface
+
+#if (BITS_PER_LONG > 32) || \
+    (defined CONFIG_HIGHMEM64G && defined CONFIG_HIGHIO)
+	#define ASD_DMA_64BIT_SUPPORT		1
+#else
+	#define	ASD_DMA_64BIT_SUPPORT		0
+#endif 
+
+/*************************** Linux DMA Wrappers *******************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define	asd_alloc_coherent(asd, size, bus_addr_ptr) \
+	dma_alloc_coherent(asd->dev, size, bus_addr_ptr, /*flag*/0)
+
+#define	asd_free_coherent(asd, size, vaddr, bus_addr) \
+	dma_free_coherent(asd->dev, size, vaddr, bus_addr)
+
+#define	asd_map_single(asd, buf, size, direction) \
+	dma_map_single(asd->dev, buf, size, direction)
+
+#define	asd_unmap_single(asd, busaddr, size, direction) \
+	dma_unmap_single(asd->dev, busaddr, size, direction)
+
+#define	asd_map_sg(asd, sg_list, num_sg, direction) \
+	dma_map_sg(asd->dev, sg_list, num_sg, direction)
+
+#define	asd_unmap_sg(asd, sg_list, num_sg, direction) \
+	dma_unmap_sg(asd->dev, sg_list, num_sg, direction)
+
+#else /* LINUX_VERSION_CODE > KERNEL_VERSION(2,4,0) */
+
+#define	asd_alloc_coherent(asd, size, bus_addr_ptr) \
+	pci_alloc_consistent(asd->dev, size, bus_addr_ptr)
+
+#define	asd_free_coherent(asd, size, vaddr, bus_addr) \
+	pci_free_consistent(asd->dev, size, vaddr, bus_addr)
+
+#define	asd_map_single(asd, buf, size, direction) \
+	pci_map_single(asd->dev, buf, size, direction)
+
+#define	asd_unmap_single(asd, busaddr, size, direction) \
+	pci_unmap_single(asd->dev, busaddr, size, direction)
+
+#define	asd_map_sg(asd, sg_list, num_sg, direction) \
+	pci_map_sg(asd->dev, sg_list, num_sg, direction)
+
+#define	asd_unmap_sg(asd, sg_list, num_sg, direction) \
+	pci_unmap_sg(asd->dev, sg_list, num_sg, direction)
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,4,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+
+#define asd_set_dma_mask(asd, mask) dma_set_mask(asd->dev, mask)
+#define asd_set_consistent_dma_mask(asd, mask) \
+	pci_set_consistent_dma_mask(asd_dev_to_pdev(asd->dev), mask)
+
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
+
+/*
+ * Device softc is NULL for EISA devices.
+ */
+#define asd_set_dma_mask(asd, mask) 			\
+	((asd)->dev == NULL ? 0 : pci_set_dma_mask(asd->dev, mask))
+
+/* Always successfull in 2.4.X kernels */
+#define asd_set_consistent_dma_mask(asd, mask) (0)
+
+#else
+/*
+ * Device softc is NULL for EISA devices.
+ * Always "return" 0 for success.
+ */
+#define asd_set_dma_mask(asd, mask)			\
+    (((asd)->dev == NULL)				\
+     ? 0						\
+     : (((asd)->dev->dma_mask = mask) && 0))
+
+/* Always successfull in 2.4.X kernels */
+#define asd_set_consistent_dma_mask(asd, mask) (0)
+
+#endif
+
+/* Forward compatibility */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+typedef struct device	*asd_dev_t;
+#else
+typedef struct pci_dev	*asd_dev_t;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define	asd_dev_to_pdev(dev)		to_pci_dev(dev)
+#define	asd_pdev_to_dev(pdev)		(&pdev->dev)
+#else
+#define	asd_dev_to_pdev(dev)		(dev)
+#define	asd_pdev_to_dev(pdev)		(pdev)
+#endif
+
+#define	asd_pci_dev(asd)		asd_dev_to_pdev((asd)->dev)
+
+#define ASD_GET_PADR(addr)		((uint32_t) (addr))
+#if (BITS_PER_LONG > 32)
+#define ASD_GET_PUADR(addr)		((uint32_t) ((addr) >> 32))
+#else
+#define ASD_GET_PUADR(addr)		((uint32_t) (0))
+#endif
+
+typedef enum {
+	ASD_SCB_UP_EH_SEM	= 0x01,
+	ASD_TIMEOUT_ACTIVE	= 0x02,
+	ASD_RELEASE_SIMQ	= 0x04,
+} asd_scb_flags;
+
+/**************************** Front End Queues ********************************/
+/*
+ * Data structure used to cast the Linux struct scsi_cmnd to something
+ * that allows us to use the queue macros.  The linux structure has
+ * plenty of space to hold the links fields as required by the queue
+ * macros, but the queue macors require them to have the correct type.
+ */
+struct asd_cmd_internal {
+	/* Area owned by the Linux scsi layer. */
+	uint8_t	private[offsetof(struct scsi_cmnd, SCp.Status)];
+	struct list_head		links;
+	uint32_t			end;
+};
+
+union asd_cmd {
+	struct asd_cmd_internal	icmd;
+	struct scsi_cmnd	scsi_cmd;
+};
+
+#define acmd_icmd(cmd)		((cmd)->icmd)
+#define acmd_scsi_cmd(cmd) 	((cmd)->scsi_cmd)
+#define acmd_links 		icmd.links
+
+/************************** Razor Architecture Layers ************************/
+/*
+ * The following typedefs define the protocols for each layer of the Razor
+ * architecture.
+ */
+
+/*
+ * The Command Set layer consists of everything having to do with the type
+ * of command that is sent to the target.
+ */
+typedef enum {
+	ASD_COMMAND_SET_UNKNOWN,
+	ASD_COMMAND_SET_SCSI,
+	ASD_COMMAND_SET_ATA,
+	ASD_COMMAND_SET_ATAPI,
+	ASD_COMMAND_SET_SMP,
+	ASD_COMMAND_SET_BAD
+} COMMAND_SET_TYPE;
+
+/*
+ * The Device Protocol layer are things that are specific to a device, 
+ * regardless of which command set is used.  For example, a device using
+ * ASD_DEVICE_PROTOCOL_ATA might use the command set ASD_COMMAND_SET_ATA or
+ * ASD_COMMAND_SET_ATAPI.
+ */
+typedef enum {
+	ASD_DEVICE_PROTOCOL_UNKNOWN,
+	ASD_DEVICE_PROTOCOL_SCSI,
+	ASD_DEVICE_PROTOCOL_ATA,
+	ASD_DEVICE_PROTOCOL_SMP
+} DEVICE_PROTOCOL_TYPE;
+
+/*
+ * The transport layer can be thought of as the frame which is used to send
+ * to a device of type DEVICE_PROTOCOL that supports the COMMAND_SET_TYPE
+ * command set.
+ */
+typedef enum {
+	ASD_TRANSPORT_UNKNOWN,
+	ASD_TRANSPORT_SSP,
+	ASD_TRANSPORT_SMP,
+	ASD_TRANSPORT_STP,
+	ASD_TRANSPORT_ATA
+} TRANSPORT_TYPE;
+
+/* 
+ * The management layer deals with issues of routing.
+ */
+typedef enum {
+	ASD_DEVICE_NONE,
+	ASD_DEVICE_FANOUT_EXPANDER,
+	ASD_DEVICE_EDGE_EXPANDER,
+	ASD_DEVICE_END,
+	ASD_DEVICE_UNKNOWN
+} MANAGEMENT_TYPE;
+
+/*
+ * The link layer refers to the link that is connected to the initiator.
+ */
+typedef enum {
+	ASD_LINK_UNKNOWN,
+	ASD_LINK_SAS,
+	ASD_LINK_SATA,
+	ASD_LINK_GPIO,
+	ASD_LINK_I2C
+} LINK_TYPE;
+
+typedef union asd_cmd *asd_io_ctx_t;
+
+/* Discovery include file */
+#include "adp94xx_discover.h"
+
+/* HWI include file */
+#include "adp94xx_hwi.h"
+
+/*************************** Device Data Structures ***************************/
+/*
+ * A per probed device structure used to deal with some error recovery
+ * scenarios that the Linux mid-layer code just doesn't know how to
+ * handle.  The structure allocated for a device only becomes persistent
+ * after a successfully completed inquiry command to the target when
+ * that inquiry data indicates a lun is present.
+ */
+typedef enum {
+	ASD_DEV_UNCONFIGURED	 = 0x0001,
+	ASD_DEV_FREEZE_TIL_EMPTY = 0x0002, /* Freeze until active is empty */
+	ASD_DEV_TIMER_ACTIVE	 = 0x0004, /* Our timer is active */
+	ASD_DEV_ON_RUN_LIST	 = 0x0008, /* Queued to be run later */
+	ASD_DEV_Q_BASIC		 = 0x0010, /* Allow basic device queuing */
+	ASD_DEV_Q_TAGGED	 = 0x0020, /* Allow full SCSI2 cmd queueing */
+	ASD_DEV_SLAVE_CONFIGURED = 0x0040, /* Device has been configured. */
+	ASD_DEV_DESTROY_WAS_ACTIVE = 0x0080, /* Device has active IO(s) when
+						the ITNL timer expired. */
+	ASD_DEV_DPC_ACTIVE	= 0x0100   /* There is an active DPC task,*/
+} asd_dev_flags;
+
+struct asd_target;
+struct asd_device {
+	struct list_head 	 links;
+	struct list_head	 busyq;
+	/*
+	 * The number of transactions currently queued to the device.
+	 */
+	int			 active;
+	/*
+	 * The currently allowed number of transactions that can be queued to
+	 * the device.  Must be signed for conversion from tagged to untagged
+	 * mode where the device may have more than one outstanding active 
+	 * transaction.
+	 */
+	int			 openings;
+	/*
+	 * A positive count indicates that this device's queue is halted.
+	 */
+	u_int			 qfrozen;
+	/*
+	 * Cumulative command counter.
+	 */
+	u_long			 commands_issued;
+	/*
+	 * The number of tagged transactions when running at our current 
+	 * opening level that have been successfully received by this 
+	 * device since the last QUEUE FULL.
+	 */
+	u_int			 tag_success_count;
+#define ASD_TAG_SUCCESS_INTERVAL 50
+
+	asd_dev_flags		 flags;
+	/*
+	 * Per device timer and task.
+	 */
+	struct timer_list	 timer;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,41)	
+	struct tq_struct	 taskq;
+#else
+	struct work_struct	 workq;
+#endif	
+	/*
+	 * The high limit for the tags variable.
+	 */
+	u_int			 maxtags;
+	/*
+	 * The computed number of tags outstanding
+	 * at the time of the last QUEUE FULL event.
+	 */
+	u_int			 tags_on_last_queuefull;
+	/*
+	 * How many times we have seen a queue full with the same 
+	 * number of tags.  This is used to stop our adaptive queue depth 
+	 * algorithm on devices with a fixed number of tags.
+	 */
+	u_int			 last_queuefull_same_count;
+#define ASD_LOCK_TAGS_COUNT 50
+
+	/* 
+	 * Device mapping path for the OS.
+	 * This is a duplicate of info in scsi_device and
+	 * should be discarded soon.
+	 */
+	u_int			 ch;
+	u_int			 id;
+	u_int			 lun;
+	uint8_t			 saslun[SAS_LUN_LEN];
+	Scsi_Device	       	*scsi_device;
+	struct asd_target	*target;
+#ifdef MULTIPATH_IO
+	struct asd_target	*current_target;
+#endif
+};
+
+typedef enum {
+	ASD_TARG_FLAGS_NONE		= 0x0000,
+	ASD_TARG_IN_RECOVERY		= 0x0001,
+	ASD_TARG_ONLINE			= 0x0002,
+	ASD_TARG_RESEEN			= 0x0004,
+	ASD_TARG_HOT_REMOVED		= 0x0008,
+	ASD_TARG_HOT_ADDED		= 0x0010,
+	ASD_TARG_NEEDS_MAP		= 0x0020,
+	ASD_TARG_MAPPED			= 0x0040,
+	ASD_TARG_MAP_BOOT		= 0x0080
+} asd_targ_flags;
+
+/* 
+ * Contains pertinent fields needed to generete a hardware DDB.
+ */  
+struct asd_ddb_data {
+	uint8_t			sas_addr[SAS_ADDR_LEN];
+	uint8_t			hashed_sas_addr[HASHED_SAS_ADDR_LEN];
+	uint8_t			conn_rate;
+	uint16_t		itnl_const;
+	/* Index to DDB entry. */
+	uint16_t		conn_handle;
+	uint16_t		sister_ddb;
+	/*
+	 * Indicates whether the device port protocol is SSP, STP, SMP, 
+	 * SATA direct attched or SATA Port Multi. This will be used when
+	 * setting value for OPEN field.
+	 */   
+	uint8_t			attr;
+	/*
+	 * OPEN bit will be set if the device port is connected by
+	 * SSP, STP or SMP. In addition for STP, SUPPORT AFFILIATION and 
+	 * STP AFFLIATION policy need to be set. 
+	 * Otherwise, for SATA direct attached or SATA Port Multi, OPEN bit
+ 	 * shall not be set.  
+	 */  
+	uint8_t			open_affl; 	
+	/*
+	 * Initial FIS status.
+	 */
+	uint8_t			sata_status;
+};
+
+#define FIS_LENGTH		20
+
+/*
+ * Defines for the features_state member
+ */
+#define SATA_USES_DMA			0x0001
+#define SATA_USES_48BIT			0x0002
+#define SATA_USES_QUEUEING		0x0004
+#define SATA_USES_WRITE_FUA		0x0008
+#define SATA_USES_REMOVABLE		0x0010
+#define SATA_USES_WRITE_BUFFER		0x0020
+#define SATA_USES_READ_BUFFER		0x0040
+#define SATA_USES_WRITE_CACHE		0x0080
+#define SATA_USES_READ_AHEAD		0x0100
+#define SATA_USES_SMART			0x0200
+#define SATA_USES_UDMA			0x0400
+
+/*
+ * Defines for the features_enabled member (to store capability)
+ */
+#define WRITE_CACHE_FEATURE_ENABLED	0x0001
+#define READ_AHEAD_FEATURE_ENABLED	0x0002
+#define SMART_FEATURE_ENABLED		0x0004
+#define NEEDS_XFER_SETFEATURES		0x0008
+
+int
+asd_sata_identify_build(
+struct asd_softc	*asd,
+struct asd_target	*target,
+struct scb		*scb
+);
+
+// ----------------------------------------------------------------------------
+
+/*
+ * For devices supporting the SCSI command set
+ */
+struct asd_scsi_command_set {
+	unsigned			num_luns;
+	uint32_t			flags;
+	uint64_t			*luns;
+	uint8_t				*ident;
+	unsigned			ident_len;
+	uint8_t				*inquiry;
+};
+
+struct asd_smp_command_set {
+	struct SMPResponseReportManufacturerInfo
+					manufacturer_info;
+};
+
+/*
+ * For devices supporting the ATA command set
+ */
+struct asd_ata_command_set {
+	/*
+	 * There are a few differences in the structures for the data that
+	 * is returned by IDENTIFY and PACKET IDENTIFY.  We are using the
+	 * same structure for both ATA and ATAPI.
+	 */
+	struct hd_driveid		adp_hd_driveid;
+
+	/*
+	 * These members are in the command set structure because they are
+	 * deriviced by, or control features and functions specified in the
+	 * adp_hd_driveid struture.
+	 */
+	unsigned			features_state;
+	unsigned			features_enabled;
+	unsigned			dma_mode_level;
+};
+
+/*
+ * For devices supporting the ATAPI command set
+ */
+struct asd_atapi_command_set {
+	/*
+	 * There are a few differences in the structures for the data that
+	 * is returned by IDENTIFY and PACKET IDENTIFY.  We are using the
+	 * same structure for both ATA and ATAPI.
+	 */
+	struct hd_driveid		adp_hd_driveid;
+
+	/*
+	 * These members are in the command set structure because they are
+	 * deriviced by, or control features and functions specified in the
+	 * adp_hd_driveid struture.
+	 */
+	unsigned			features_state;
+	unsigned			features_enabled;
+	unsigned			dma_mode_level;
+};
+
+/*
+ * These are members that are specific to a specific type of command set.
+ */
+union asd_command_set {
+	struct asd_scsi_command_set	scsi_command_set;
+	struct asd_ata_command_set	ata_command_set;
+	struct asd_atapi_command_set	atapi_command_set;
+	struct asd_smp_command_set	smp_command_set;
+};
+
+#define ata_cmdset	command_set.ata_command_set
+#define scsi_cmdset	command_set.scsi_command_set
+#define atapi_cmdset	command_set.atapi_command_set
+#define smp_cmdset	command_set.smp_command_set
+
+
+// ----------------------------------------------------------------------------
+
+struct asd_ata_device_protocol {
+	uint8_t				initial_fis[FIS_LENGTH];
+};
+
+union asd_device_protocol {
+	struct asd_ata_device_protocol	ata_device_protocol;
+};
+
+/*
+ * Defines for the menagement_flags member
+ */
+#define DEVICE_SET_ROOT		0x0001
+
+struct asd_target {
+	/*
+	 * A positive count indicates that this
+	 * target's queue is halted.
+	 */
+	u_int			  qfrozen;
+
+	/*
+	 * XXX Use hash table for sparse 8byte lun support???
+	 */
+	struct asd_device	 *devices[ASD_MAX_LUNS];
+	u_int			  target_id;
+	int			  refcount;
+	struct asd_softc	 *softc;
+	asd_targ_flags	  	  flags;
+	struct asd_domain	 *domain;
+
+	/*
+	 * Per target timer.
+	 */
+	struct timer_list	  timer;
+
+	/*
+	 * Command Set Layer (SCSI, ATAPI, ATA, SMP)
+	 * --------------------------------------------------------
+	 */
+	COMMAND_SET_TYPE		command_set_type;
+	union asd_command_set		command_set;
+
+	/*
+	 * Device Protocol Layer (SCSI, ATA, SMP)
+	 * --------------------------------------------------------
+	 */
+	DEVICE_PROTOCOL_TYPE		device_protocol_type;
+	union asd_device_protocol	device_protocol;
+
+	/*
+	 * Transport Layer (SSP, SMP, STP, FIS)
+	 * --------------------------------------------------------
+	 */
+	TRANSPORT_TYPE			transport_type;
+
+	/*
+	 * Management Layer (DIRECT, EXPANDER, FANOUT)
+	 * --------------------------------------------------------
+	 */
+	MANAGEMENT_TYPE			management_type;
+	unsigned			num_phys;
+	unsigned			num_route_indexes;
+	unsigned			configurable_route_table;
+	uint16_t			*route_indexes;
+	struct SMPResponseDiscover	*Phy;
+	uint8_t				*RouteTable;
+	uint32_t			management_flags;
+
+	/*
+	 * Our parent SAS device (e.g. expander)
+	 * in this SAS domain.
+	 */
+	struct asd_target	 	*parent;
+	/*
+	 * Our children SAS devices (if not end device)
+	 * in this SAS domain.
+	 */
+	struct list_head	  	children;
+	/*
+	 * List of targets that are connected to a parent 
+	 * expander (children)
+	 */
+	struct list_head	  	siblings;
+	/*
+	 * List links for chaining together all targets
+	 * in this SAS domain on to the port object.
+	 */
+	struct list_head	  	all_domain_targets;
+	/*
+	 * List links of targets that need to be validated
+	 * because they have been hot-added or hot-removed.
+	 */
+	struct list_head	  	validate_links;   
+	/*
+	 * List links of target structures that map to the
+	 * same physical sevice.
+	 */
+	struct list_head	  	multipath;   
+
+	/*
+	 * Link Layer (SAS, SATA, GPIO, I2C)
+	 * --------------------------------------------------------
+	 */
+	LINK_TYPE			link_type;
+	struct asd_ddb_data	  	ddb_profile;
+
+	/*
+	 * Controller port used to route to
+	 * this device.
+	 */
+	struct asd_port		 	*src_port;
+};
+
+struct asd_domain {
+	/*
+	 * XXX Use Hash table to support
+	 * large/sparse target configurations.
+	 */
+	struct asd_target 	*targets[ASD_MAX_TARGET_IDS];
+	u_int			 channel_mapping;
+	u_int			 refcount;
+};
+
+typedef enum {
+	ASD_DISCOVERY_ACTIVE	= 0x01,
+	ASD_DISCOVERY_INIT	= 0x02,
+	ASD_DISCOVERY_SHUTDOWN	= 0x04,
+	ASD_RECOVERY_SHUTDOWN	= 0x08,
+#ifdef ASD_EH_SIMULATION
+	ASD_EH_SIMUL_SHUTDOWN	= 0x10
+#endif		
+} asd_platform_flags;
+
+struct asd_scb_platform_data {
+	struct asd_target 	*targ;
+	struct asd_device	*dev;
+	asd_scb_flags	 	 flags;
+	dma_addr_t		 buf_busaddr;
+	/*
+	 * Timeout timer tick, used to timeout internal cmd that is 
+         * sent to the sequencer or target.
+	 */	 
+	struct timer_list	 timeout;	 
+};
+
+struct asd_platform_data {
+	spinlock_t		  spinlock;
+	struct Scsi_Host	 *scsi_host;
+
+	/*
+	 * Channel to Domain Mapping.
+	 */
+	struct asd_domain	**domains;
+	u_int			  num_domains;
+
+	/*
+	 * Queued device I/O scheduling support.
+	 */
+	struct list_head	  pending_os_scbs;
+	struct list_head 	  device_runq;
+	struct tasklet_struct	  runq_tasklet;
+	struct tasklet_struct	  unblock_tasklet;
+	u_int			  qfrozen;
+
+	/*
+	 * Completion Ordering Queue.
+	 */
+	struct list_head 	  completeq;
+
+	/*
+	 * LRU target DDB ageing queue.  Used to
+	 * select candidates for DDB recycling.
+	 * LFU would be a better scheme and could
+	 * be achieved in O(logN) using a heap
+	 * queue, but keep this simple for now.
+	 */
+	struct list_head 	  lru_ddb_q;
+
+	/*
+	 * Discovery Thread Support.
+	 */
+	pid_t			  discovery_pid;
+	struct semaphore	  discovery_sem;
+	struct semaphore	  discovery_ending_sem;
+
+	/*
+	 * Error Recovery Thread Support.
+	 */
+	pid_t			  ehandler_pid;
+	struct semaphore	  ehandler_sem;
+	struct semaphore	  ehandler_ending_sem;
+
+#ifdef ASD_EH_SIMULATION
+	/*
+	 * EH Recovery Simulation thread.
+         */
+	pid_t			  eh_simul_pid;
+	struct semaphore	  eh_simul_sem;
+#endif
+	
+	/*
+	 * Wait Queue.
+         */	
+	wait_queue_head_t	  waitq;
+
+	/*
+	 * Mid-layer error recovery entry point semaphore.
+	 */
+	struct semaphore	  eh_sem;
+	struct semaphore	  wait_sem;
+
+	asd_platform_flags  	  flags;
+};
+
+/*
+ * Internal data structures.
+ */
+typedef struct asd_init_status {
+	uint8_t		asd_notifier_enabled;
+	uint8_t		asd_pci_registered;
+	uint8_t		asd_irq_registered;
+	uint8_t		asd_ioctl_registered;
+	uint8_t		asd_init_state;
+} asd_init_status_t;
+
+
+/* SMP Locking mechanism routines */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) || defined(SCSI_HAS_HOST_LOCK))
+#define	SCSI_ML_HAS_HOST_LOCK	1
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define asd_assign_host_lock(asd)				\
+	scsi_assign_lock((asd)->platform_data->scsi_host,	\
+			 &(asd)->platform_data->spinlock)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,21)		\
+		&& defined(ASD_RED_HAT_LINUX_KERNEL)
+#define asd_assign_host_lock(asd)				\
+do {								\
+	(asd)->platform_data->scsi_host->host_lock =		\
+	    &(asd)->platform_data->spinlock;			\
+} while (0)
+#else
+#define asd_assign_host_lock(asd)				\
+do {								\
+	(asd)->platform_data->scsi_host->lock =			\
+	    &(asd)->platform_data->spinlock;			\
+} while (0)
+#endif
+#else	/* !SCSI_ML_HAS_HOST_LOCK */
+#define	SCSI_ML_HAS_HOST_LOCK	0
+#define asd_assign_host_lock(asd)
+#endif	/* !SCSI_ML_HAS_HOST_LOCK */
+
+/* OS utility wrappers */
+#define asd_alloc_mem(size, flags)	kmalloc(size, flags)
+#define asd_free_mem(ptr)		kfree(ptr)
+ 
+/* Debug Logging macro */
+
+#define ASD_DBG_INIT		0x01
+#define ASD_DBG_INFO		0x02
+#define ASD_DBG_RUNTIME_B	0x04
+#define ASD_DBG_RUNTIME		0x10
+#define ASD_DBG_ISR		0x20
+#define ASD_DBG_ERROR		0x40
+
+
+/* Debug mask to control the Debug Level printout. */
+extern u_int	debug_mask;
+
+#ifdef ASD_DEBUG
+
+#define asd_dprint(fmt, ...) printk(KERN_NOTICE fmt, ## __VA_ARGS__)
+
+#define asd_log(debug_level, fmt, args...)			\
+do {								\
+	if ((debug_level & debug_mask) != 0) {			\
+		printk("%s(%d) : ", __FUNCTION__, __LINE__);	\
+		printk(fmt, ##args);				\
+	}							\
+} while (0)
+
+/* For initial debugging purpose only. */
+#define IN	0
+#define OUT	1
+#define LINE	2
+
+#define ASD_DBG_FUNC(x)							\
+do {									\
+	if (x == IN) {							\
+		printk("+++ Entering Function: %s:%d.\n", __FUNCTION__, \
+			__LINE__);					\
+	} else if (x == OUT) {						\
+		printk("--- Exiting Function: %s:%d.\n", __FUNCTION__,  \
+			__LINE__);					\
+	} else {							\
+		printk("*** %s (%d).\n", __FUNCTION__, __LINE__);	\
+	}								\
+} while (0)
+
+#if KDB_ENABLE
+#define ASSERT(expression)						\
+	if (!(expression)) {						\
+		printk("assertion failed: %s, file: %s, line: %d\n",	\
+			#expression, __FILE__, __LINE__);		\
+		KDB_ENTER();						\
+	}
+#else /* KDB_ENABLE */
+#define ASSERT(expression)						\
+	if (!(expression)) {						\
+		panic("assertion failed: %s, file: %s, line: %d\n",	\
+			#expression, __FILE__, __LINE__);		\
+	}
+#endif /* KDB_ENABLE */
+
+#else /* ASD_DEBUG */
+
+#define asd_dprint(fmt, ...) 
+
+#define asd_log(debug_level, fmt, args...)	/**/
+#define ASD_DBG_FUNC(x)				/**/
+
+#define ASSERT(expression)
+
+#endif /* ASD_DEBUG */ 
+
+#define asd_print(fmt, args...)		printk(fmt, ##args)
+
+#define ASD_DUMP_REG(reg)		/**/
+
+#ifndef IRQ_RETVAL
+typedef void	irqreturn_t;
+#define IRQ_RETVAL(x)	/**/
+#endif
+
+/*
+ * SCSI Status Byte
+ */
+#define	SCSI_STATUS_OK			0x00
+#define	SCSI_STATUS_CHECK_COND		0x02
+#define	SCSI_STATUS_COND_MET		0x04
+#define	SCSI_STATUS_BUSY		0x08
+#define SCSI_STATUS_INTERMED		0x10
+#define SCSI_STATUS_INTERMED_COND_MET	0x14
+#define SCSI_STATUS_RESERV_CONFLICT	0x18
+#define SCSI_STATUS_CMD_TERMINATED	0x22	/* Obsolete in SAM-2 */
+#define SCSI_STATUS_QUEUE_FULL		0x28
+#define SCSI_STATUS_ACA_ACTIVE		0x30
+#define SCSI_STATUS_TASK_ABORTED	0x40
+
+struct scsi_sense_data
+{
+	uint8_t error_code;
+#define	SSD_ERRCODE			0x7F
+#define		SSD_CURRENT_ERROR	0x70
+#define		SSD_DEFERRED_ERROR	0x71
+#define	SSD_ERRCODE_VALID	0x80	
+	uint8_t segment;
+	uint8_t flags;
+#define	SSD_KEY				0x0F
+#define		SSD_KEY_NO_SENSE	0x00
+#define		SSD_KEY_RECOVERED_ERROR	0x01
+#define		SSD_KEY_NOT_READY	0x02
+#define		SSD_KEY_MEDIUM_ERROR	0x03
+#define		SSD_KEY_HARDWARE_ERROR	0x04
+#define		SSD_KEY_ILLEGAL_REQUEST	0x05
+#define		SSD_KEY_UNIT_ATTENTION	0x06
+#define		SSD_KEY_DATA_PROTECT	0x07
+#define		SSD_KEY_BLANK_CHECK	0x08
+#define		SSD_KEY_Vendor_Specific	0x09
+#define		SSD_KEY_COPY_ABORTED	0x0a
+#define		SSD_KEY_ABORTED_COMMAND	0x0b		
+#define		SSD_KEY_EQUAL		0x0c
+#define		SSD_KEY_VOLUME_OVERFLOW	0x0d
+#define		SSD_KEY_MISCOMPARE	0x0e
+#define		SSD_KEY_RESERVED	0x0f			
+#define	SSD_ILI		0x20
+#define	SSD_EOM		0x40
+#define	SSD_FILEMARK	0x80
+	uint8_t info[4];
+	uint8_t extra_len;
+	uint8_t cmd_spec_info[4];
+	uint8_t add_sense_code;
+	uint8_t add_sense_code_qual;
+	uint8_t fru;
+	uint8_t sense_key_spec[3];
+#define	SSD_SCS_VALID		0x80
+#define SSD_FIELDPTR_CMD	0x40
+#define SSD_BITPTR_VALID	0x08
+#define SSD_BITPTR_VALUE	0x07
+#define SSD_MIN_SIZE 18
+	uint8_t extra_bytes[14];
+#define SSD_FULL_SIZE sizeof(struct scsi_sense_data)
+};
+
+static inline void	scsi_ulto2b(uint32_t val, uint8_t *bytes);
+static inline void	scsi_ulto3b(uint32_t val, uint8_t *bytes);
+static inline void	scsi_ulto4b(uint32_t val, uint8_t *bytes);
+static inline uint32_t	scsi_2btoul(uint8_t *bytes);
+static inline uint32_t	scsi_3btoul(uint8_t *bytes);
+static inline int32_t	scsi_3btol(uint8_t *bytes);
+static inline uint32_t 	scsi_4btoul(uint8_t *bytes);
+
+static inline void
+scsi_ulto2b(uint32_t val, uint8_t *bytes)
+{
+	bytes[0] = (val >> 8) & 0xff;
+	bytes[1] = val & 0xff;
+}
+
+static inline void
+scsi_ulto3b(uint32_t val, uint8_t *bytes)
+{
+	bytes[0] = (val >> 16) & 0xff;
+	bytes[1] = (val >> 8) & 0xff;
+	bytes[2] = val & 0xff;
+}
+
+static inline void
+scsi_ulto4b(uint32_t val, uint8_t *bytes)
+{
+	bytes[0] = (val >> 24) & 0xff;
+	bytes[1] = (val >> 16) & 0xff;
+	bytes[2] = (val >> 8) & 0xff;
+	bytes[3] = val & 0xff;
+}
+
+static inline uint32_t
+scsi_2btoul(uint8_t *bytes)
+{
+	uint32_t rv;
+
+	rv = (bytes[0] << 8) |
+	     bytes[1];
+	return (rv);
+}
+
+static inline uint32_t
+scsi_3btoul(uint8_t *bytes)
+{
+	uint32_t rv;
+
+	rv = (bytes[0] << 16) |
+	     (bytes[1] << 8) |
+	     bytes[2];
+	return (rv);
+}
+
+static inline int32_t 
+scsi_3btol(uint8_t *bytes)
+{
+	uint32_t rc = scsi_3btoul(bytes);
+ 
+	if (rc & 0x00800000)
+		rc |= 0xff000000;
+
+	return (int32_t) rc;
+}
+
+static inline uint32_t
+scsi_4btoul(uint8_t *bytes)
+{
+	uint32_t rv;
+
+	rv = (bytes[0] << 24) |
+	     (bytes[1] << 16) |
+	     (bytes[2] << 8) |
+	     bytes[3];
+	return (rv);
+}
+
+/*********************** Transaction Access Wrappers **************************/
+static inline void	asd_cmd_set_host_status(Scsi_Cmnd *cmd, u_int);
+static inline void 	asd_cmd_set_scsi_status(Scsi_Cmnd *cmd, u_int);
+static inline uint32_t 	asd_cmd_get_host_status(Scsi_Cmnd *cmd);
+static inline uint32_t 	asd_cmd_get_scsi_status(Scsi_Cmnd *cmd);
+static inline void 	asd_freeze_scb(struct scb *scb);
+static inline void 	asd_unfreeze_scb(struct scb *scb);
+
+#define CMD_DRIVER_STATUS_MASK	0xFF000000
+#define CMD_DRIVER_STATUS_SHIFT	24
+#define CMD_HOST_STATUS_MASK	0x00FF0000
+#define CMD_HOST_STATUS_SHIFT	16
+#define CMD_MSG_STATUS_MASK	0x0000FF00
+#define CMD_MSG_STATUS_SHIFT	8
+#define CMD_SCSI_STATUS_MASK	0x000000FF
+#define CMD_SCSI_STATUS_SHIFT	0
+#define CMD_REQ_INPROG		0xFF
+
+static inline
+void asd_cmd_set_driver_status(Scsi_Cmnd *cmd, u_int status)
+{
+	cmd->result &= ~CMD_DRIVER_STATUS_MASK;
+	cmd->result |= status << CMD_DRIVER_STATUS_SHIFT;
+}
+
+static inline
+void asd_cmd_set_host_status(Scsi_Cmnd *cmd, u_int status)
+{
+	cmd->result &= ~CMD_HOST_STATUS_MASK;
+	cmd->result |= status << CMD_HOST_STATUS_SHIFT;
+}
+
+static inline
+void asd_cmd_set_scsi_status(Scsi_Cmnd *cmd, u_int status)
+{
+	cmd->result &= ~CMD_SCSI_STATUS_MASK;
+	cmd->result |= status;
+}
+
+static inline
+uint32_t asd_cmd_get_host_status(Scsi_Cmnd *cmd)
+{
+	return ((cmd->result & CMD_HOST_STATUS_MASK) >> CMD_HOST_STATUS_SHIFT);
+}
+
+static inline
+uint32_t asd_cmd_get_scsi_status(Scsi_Cmnd *cmd)
+{
+	return ((cmd->result & CMD_SCSI_STATUS_MASK) >> CMD_SCSI_STATUS_SHIFT);
+}
+
+static inline void
+asd_freeze_scb(struct scb *scb)
+{
+	if ((scb->flags & SCB_DEV_QFRZN) == 0) {
+		scb->flags |= SCB_DEV_QFRZN;
+		scb->platform_data->dev->qfrozen++;
+        }
+}
+
+static inline void
+asd_unfreeze_scb(struct scb *scb)
+{
+	if ((scb->flags & SCB_DEV_QFRZN) != 0) {
+		scb->flags &= ~SCB_DEV_QFRZN;
+		scb->platform_data->dev->qfrozen--;
+        }
+}
+
+// TODO - where is right spot for these???
+typedef enum {
+	ASD_COMMAND_BUILD_OK,
+	ASD_COMMAND_BUILD_FAILED,
+	ASD_COMMAND_BUILD_FINISHED
+} ASD_COMMAND_BUILD_STATUS;
+
+ASD_COMMAND_BUILD_STATUS 
+	asd_setup_data(struct asd_softc *asd, struct scb *scb, Scsi_Cmnd *cmd);
+
+DISCOVER_RESULTS
+	asd_do_discovery(struct asd_softc *asd, struct asd_port *port);
+
+DISCOVER_RESULTS
+	asd_run_state_machine(struct state_machine_context *sm_contextp);
+
+int	asd_platform_alloc(struct asd_softc *asd);
+void	asd_platform_free(struct asd_softc *asd);
+
+struct asd_scb_platform_data *
+	asd_alloc_scb_platform_data(struct asd_softc *asd);
+void	asd_free_scb_platform_data(struct asd_softc *asd,
+				   struct asd_scb_platform_data *pdata);
+void	asd_unmap_scb(struct asd_softc *asd, struct scb *scb);
+void	asd_recover_cmds(struct asd_softc *asd);
+void	asd_hwi_release_sata_spinup_hold(struct asd_softc *asd,
+					 struct asd_phy	*phy);
+
+struct asd_target *
+	asd_alloc_target(struct asd_softc *asd, struct asd_port *src_port);
+void	asd_free_target(struct asd_softc *asd, struct asd_target *targ);
+int	asd_map_target(struct asd_softc *asd, struct asd_target *targ);
+
+struct asd_device *
+	asd_alloc_device(struct asd_softc *asd, struct asd_target *targ, 
+			 u_int ch, u_int id, u_int lun);
+void	asd_free_device(struct asd_softc *asd, struct asd_device *dev);
+struct asd_device *
+	asd_get_device(struct asd_softc *asd, u_int ch, u_int id,
+		       u_int lun, int alloc);
+void	asd_remap_device(struct asd_softc *asd, struct asd_target *target,
+			 struct asd_target *multipath_target);
+void	asd_timed_run_dev_queue(u_long arg);
+void	asd_destroy_device(void *arg);
+
+#ifndef list_for_each_entry_safe
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against 
+ *                              removal of list entry
+ * @pos:	the type * to use as a loop counter.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		n = list_entry(pos->member.next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+#endif
+
+#ifndef list_for_each_entry
+/**
+ * list_for_each_entry	-	iterate over list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		     prefetch(pos->member.next);			\
+	     &pos->member != (head); 					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
+		     prefetch(pos->member.next))
+
+#endif
+
+#define list_move_all(to_list, from_list)				\
+	if (!list_empty(from_list)) {					\
+		(to_list)->next = (from_list)->next;			\
+		(to_list)->prev = (from_list)->prev;			\
+		(from_list)->next->prev = to_list;			\
+		(from_list)->prev->next = to_list;			\
+		INIT_LIST_HEAD(from_list);				\
+	} else {							\
+		INIT_LIST_HEAD(to_list);				\
+	}
+
+#define list_copy(to_list, from_list)					\
+do {									\
+	(to_list)->next = (from_list)->next;				\
+	(to_list)->prev = (from_list)->prev;				\
+} while (0)
+
+void asd_hwi_set_ddbsite_byte(struct asd_softc *asd,
+			      uint16_t site_offset, uint8_t val);
+void asd_hwi_set_ddbsite_word(struct asd_softc *asd,
+			      uint16_t site_offset, uint16_t val);
+void asd_hwi_set_ddbsite_dword(struct asd_softc *asd,
+			       uint16_t site_offset, uint32_t val);
+uint8_t asd_hwi_get_ddbsite_byte(struct asd_softc *asd, 
+				 uint16_t site_offset);
+uint16_t asd_hwi_get_ddbsite_word(struct asd_softc *asd, 
+				  uint16_t site_offset);
+uint32_t asd_hwi_get_ddbsite_dword(struct asd_softc *asd, 
+				   uint16_t site_offset);
+
+#endif /* ADP94XX_OSM_H */ 
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_reg.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_reg.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_reg.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_reg.h	2007-04-05 23:37:45.000000000 +0000
@@ -0,0 +1,2628 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ * Hardware registers defintions.
+ *
+ * Written by : David Chaw <david_chaw@adaptec.com>
+ *   
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+
+#ifndef ADP94XX_REG_H
+#define ADP94XX_REG_H
+
+/* 
+ * Temporarily definition for which sequencer to use. 
+ * Enabled all three versions, during runtime driver will decide which code
+ * to load based on the controller attached. 
+ */
+#define SAS_SEQUENCER_A1	1		/*
+						 * SAS Sequencer for A1 board
+						 * and COMSTOCK (RTL #14).
+						 */
+#define SAS_SEQUENCER_B0	1		/*
+						 * SAS Sequencer for B0 board
+						 * or latest COMSTOCK RTL.
+						 */
+#define SAS_COMSTOCK_SUPPORT	0		/* 
+						 * Specific workaround logic
+						 * for COMSTOCK support.
+						 */
+#define SAS_ENABLE_NOTIFY	1		/*
+						 * Issue NOTIFY (ENABLE SPINUP)
+						 * primitive to the drive.
+						 */
+
+/*
+ * Common definitions.
+ */
+#define SCB_SIZE		128		/* Max SCB size */
+#define DDB_SIZE		64		/* Max DDB size */
+#define CSCRMEM_SIZE		1024		/* CSEQ Scratch Memory size */
+#define LSCRMEM_SIZE		512		/* LSEQ Scratch Memory size */
+#define CSEQ_MODE_PAGE_SIZE	0x200		/* CSEQ mode page size */
+#define LmSEQ_MODE_PAGE_SIZE	0x200		/* LmSEQ mode page size */
+#define LmSEQ_HOST_REG_SIZE   	0x4000		/* LmSEQ Host Register size */
+
+ 
+/********************** COM_SAS registers definition **************************/
+
+/* 
+ * CHIM Registers, Address Range : (0x00-0xFF) 
+ */
+#define CHIM_REG_BASE_ADR		0xB8000000 
+
+#define COMBIST		0x00
+
+/* bits 31:24 */
+#define		L7BLKRST		0x80000000     
+#define		L6BLKRST		0x40000000     
+#define		L5BLKRST		0x20000000     
+#define		L4BLKRST		0x10000000     
+#define		L3BLKRST		0x08000000    
+#define		L2BLKRST		0x04000000    
+#define		L1BLKRST		0x02000000     
+#define		L0BLKRST		0x01000000     
+#define		LmBLKRST		0xFF000000 
+#define LmBLKRST_COMBIST(phyid)		(1 << (24 + phyid))
+
+#define		OCMBLKRST		0x00400000
+#define		CTXMEMBLKRST		0x00200000     
+#define		CSEQBLKRST		0x00100000     
+#define		EXSIBLKRST		0x00040000     
+#define		DPIBLKRST		0x00020000     
+#define		DFIFBLKRST		0x00010000     
+#define		HARDRST			0x00000200     
+#define		COMBLKRST		0x00000100     
+#define		FRCDFPERR		0x00000080     
+#define		FRCCIOPERR		0x00000020 
+#define		FRCBISTERR		0x00000010     
+#define		COMBISTEN		0x00000004
+#define		COMBISTDONE		0x00000002	/* ro */
+#define 	COMBISTFAIL		0x00000001	/* ro */
+
+#define COMSTAT		0x04
+
+#define		REQMBXREAD		0x00000040
+#define 	RSPMBXAVAIL		0x00000020
+#define 	CSBUFPERR		0x00000008
+#define		OVLYERR			0x00000004
+#define 	CSERR			0x00000002
+#define		OVLYDMADONE		0x00000001
+
+#define		COMSTAT_MASK		(REQMBXREAD | RSPMBXAVAIL | \
+					 CSBUFPERR | OVLYERR | CSERR |\
+					 OVLYDMADONE)
+					 
+#define COMSTATEN	0x08
+
+#define		EN_REQMBXREAD		0x00000040
+#define		EN_RSPMBXAVAIL		0x00000020
+#define		EN_CSBUFPERR		0x00000008
+#define		EN_OVLYERR		0x00000004
+#define		EN_CSERR		0x00000002
+#define		EN_OVLYDONE		0x00000001 
+
+#define SCBPRO		0x0C
+
+#define		SCBCONS_MASK		0xFFFF0000
+#define		SCBPRO_MASK		0x0000FFFF
+
+#define CHIMREQMBX	0x10	
+
+#define CHIMRSPMBX	0x14
+
+#define CHIMINT		0x18
+
+#define		EXT_INT0		0x00000800
+#define		EXT_INT1		0x00000400
+#define		PORRSTDET		0x00000200
+#define		HARDRSTDET		0x00000100
+#define		DLAVAILQ		0x00000080	/* ro */
+#define		HOSTERR			0x00000040
+#define		INITERR			0x00000020
+#define		DEVINT			0x00000010
+#define		COMINT			0x00000008
+#define		DEVTIMER2		0x00000004
+#define		DEVTIMER1		0x00000002
+#define		DLAVAIL			0x00000001
+
+#define		CHIMINT_MASK		(HOSTERR | INITERR | DEVINT | COMINT |\
+					 DEVTIMER2 | DEVTIMER1 | DLAVAIL)
+					 
+#define 	DEVEXCEPT_MASK		(HOSTERR | INITERR | DEVINT | COMINT)
+
+#define CHIMINTEN	0x1C
+
+#define		RST_EN_EXT_INT1		0x01000000
+#define		RST_EN_EXT_INT0		0x00800000
+#define		RST_EN_HOSTERR		0x00400000    
+#define		RST_EN_INITERR		0x00200000
+#define		RST_EN_DEVINT		0x00100000
+#define		RST_EN_COMINT		0x00080000
+#define		RST_EN_DEVTIMER2	0x00040000
+#define		RST_EN_DEVTIMER1	0x00020000
+#define		RST_EN_DLAVAIL		0x00010000
+#define		SET_EN_EXT_INT1		0x00000100
+#define		SET_EN_EXT_INT0		0x00000080
+#define		SET_EN_HOSTERR		0x00000040
+#define		SET_EN_INITERR		0x00000020
+#define		SET_EN_DEVINT		0x00000010
+#define		SET_EN_COMINT		0x00000008
+#define		SET_EN_DEVTIMER2	0x00000004
+#define		SET_EN_DEVTIMER1	0x00000002
+#define		SET_EN_DLAVAIL		0x00000001
+
+#define		RST_CHIMINTEN		(RST_EN_HOSTERR | RST_EN_INITERR | \
+					 RST_EN_DEVINT | RST_EN_COMINT | \
+					 RST_EN_DEVTIMER2 | RST_EN_DEVTIMER1 |\
+					 RST_EN_DLAVAIL)
+					 
+#define		SET_CHIMINTEN		(SET_EN_HOSTERR | SET_EN_INITERR |\
+					 SET_EN_DEVINT | SET_EN_COMINT |\
+					 SET_EN_DLAVAIL)
+					 
+#define OVLYDMACTL	0x20
+
+#define		OVLYADR_MASK		0x07FF0000
+#define		OVLYLSEQ_MASK		0x0000FF00
+#define		OVLYCSEQ		0x00000080
+#define		OVLYHALTERR		0x00000040
+#define		PIOCMODE		0x00000020
+#define		RESETOVLYDMA		0x00000008	/* wo */
+#define		STARTOVLYDMA		0x00000004
+#define		STOPOVLYDMA		0x00000002	/* wo */
+#define		OVLYDMAACT		0x00000001	/* ro */ 
+
+#define OVLYDMACNT	0x24
+
+#define		OVLYDOMAIN1		0x20000000	/* ro */
+#define		OVLYDOMAIN0		0x10000000
+#define		OVLYBUFADR_MASK		0x007F0000
+#define		OVLYDMACNT_MASK		0x00003FFF
+
+#define OVLYDMAADR0	0x28
+
+#define OVLYDMAADR1	0x2C
+
+#define DMAERR		0x30
+
+#define		OVLYERRSTAT_MASK	0x0000FF00	/* ro */
+#define		CSERRSTAT_MASK		0x000000FF	/* ro */
+
+#define SPIODATA	0x34
+
+/* 0x38 - 0x3C are reserved  */
+
+#define T1CNTRLR	0x40
+
+#define		T1DONE			0x00010000	/* ro */
+#define		TIMER64			0x00000400
+#define		T1ENABLE		0x00000200
+#define		T1RELOAD		0x00000100
+#define		T1PRESCALER_MASK	0x00000003
+
+#define	T1CMPR		0x44
+
+#define T1CNTR		0x48
+
+#define T2CNTRLR	0x4C
+
+#define		T2DONE			0x00010000	/* ro */
+#define		T2ENABLE		0x00000200
+#define		T2RELOAD		0x00000100
+#define		T2PRESCALER_MASK	0x00000003
+
+#define	T2CMPR		0x50
+
+#define T2CNTR		0x54
+
+/* 0x58h - 0xFCh are reserved */
+
+/* 
+ * DCH_SAS Registers, Address Range : (0x800-0xFFF) 
+ */
+#define DCH_SAS_REG_BASE_ADR		0xB8000000
+
+#define CMDCTXBASE	0x800
+
+#define DEVCTXBASE	0x808
+
+#define CTXDOMAIN	0x810
+
+#define		DEVCTXDOMAIN1		0x00000008	/* ro */
+#define		DEVCTXDOMAIN0		0x00000004
+#define		CMDCTXDOMAIN1		0x00000002	/* ro */
+#define		CMDCTXDOMAIN0		0x00000001
+
+#define DCHCTL		0x814
+
+#define		OCMBISTREPAIR		0x00080000
+#define		OCMBISTEN		0x00040000     
+#define		OCMBISTDN		0x00020000	/* ro */
+#define		OCMBISTFAIL		0x00010000	/* ro */   
+#define		DDBBISTEN		0x00004000  
+#define		DDBBISTDN		0x00002000	/* ro */ 
+#define		DDBBISTFAIL		0x00001000	/* ro */
+#define		SCBBISTEN		0x00000400     
+#define		SCBBISTDN		0x00000200	/* ro */    
+#define		SCBBISTFAIL		0x00000100	/* ro */
+   
+#define		MEMSEL_MASK		0x000000E0  
+#define		MEMSEL_CCM_LSEQ		0x00000000   
+#define		MEMSEL_CCM_IOP		0x00000020   
+#define		MEMSEL_CCM_SASCTL	0x00000040   
+#define		MEMSEL_DCM_LSEQ		0x00000060  
+#define		MEMSEL_DCM_IOP		0x00000080 
+#define		MEMSEL_OCM		0x000000A0
+
+#define		FRCERR			0x00000010 
+#define		AUTORLS			0x00000001
+
+#define DCHREVISION	0x818
+
+#define		CTXMEMSIZE_MASK		0x80000000	/* ro */
+#define		CTXMEMSIZE_64K		0x80000000	
+#define		CTXMEMSIZE_32K		0x00000000	
+
+#define		DCHREVISION_MASK	0x000000FF
+
+#define DCHSTATUS	0x81C
+
+#define		EN_CFIFTOERR		0x00020000   
+#define		CFIFTOERR		0x00000200  
+#define		CSEQINT			0x00000100	/* ro */ 
+#define		LSEQ7INT		0x00000080	/* ro */
+#define		LSEQ6INT		0x00000040	/* ro */   
+#define		LSEQ5INT		0x00000020	/* ro */  
+#define		LSEQ4INT		0x00000010	/* ro */ 
+#define		LSEQ3INT		0x00000008	/* ro */
+#define		LSEQ2INT		0x00000004	/* ro */  
+#define		LSEQ1INT		0x00000002	/* ro */ 
+#define		LSEQ0INT		0x00000001	/* ro */
+
+#define		LSEQINT_MASK		(LSEQ7INT | LSEQ6INT | LSEQ5INT |\
+					 LSEQ4INT | LSEQ3INT | LSEQ2INT	|\
+					 LSEQ1INT | LSEQ0INT)
+			
+/* 0x820h - 0xFFCh are reserved */
+
+/* 
+ * ARP2 External Processor Registers, Address Range : (0x00-0x1F) 
+ */
+#define ARP2CTL		0x00
+
+#define		FRCSCRPERR		0x00040000     
+#define		FRCARP2PERR		0x00020000    
+#define		FRCARP2ILLOPC		0x00010000   
+#define		ENWAITTO		0x00008000  
+#define		PERRORDIS		0x00004000 
+#define		FAILDIS			0x00002000
+#define		CIOPERRDIS		0x00001000    
+#define		BREAKEN3		0x00000800    
+#define		BREAKEN2		0x00000400   
+#define		BREAKEN1		0x00000200  
+#define		BREAKEN0		0x00000100 
+#define		EPAUSE			0x00000008
+#define		PAUSED			0x00000004	/* ro */
+#define		STEP			0x00000002
+#define		ARP2RESET		0x00000001	/* wo */
+
+#define ARP2INT		0x04
+
+#define		HALTCODE_MASK		0x00FF0000	/* ro */   
+#define		ARP2WAITTO		0x00000100     
+#define		ARP2HALTC		0x00000080    
+#define		ARP2ILLOPC		0x00000040   
+#define		ARP2PERR		0x00000020  
+#define		ARP2CIOPERR		0x00000010 
+#define		ARP2BREAK3		0x00000008
+#define		ARP2BREAK2		0x00000004    
+#define		ARP2BREAK1		0x00000002   
+#define		ARP2BREAK0		0x00000001  
+
+#define ARP2INTEN	0x08
+
+#define		EN_ARP2WAITTO		0x00000100    
+#define		EN_ARP2HALTC		0x00000080   
+#define		EN_ARP2ILLOPC		0x00000040  
+#define		EN_ARP2PERR		0x00000020 
+#define		EN_ARP2CIOPERR		0x00000010
+#define		EN_ARP2BREAK3		0x00000008   
+#define		EN_ARP2BREAK2		0x00000004  
+#define		EN_ARP2BREAK1		0x00000002 
+#define		EN_ARP2BREAK0		0x00000001
+
+#define ARP2BREAKADR01	0x0C
+
+#define		BREAKADR1_MASK		0x0FFF0000
+#define		BREAKADR0_MASK		0x00000FFF
+
+#define ARP2BREAKADR23	0x10
+
+#define		BREAKADR3_MASK		0x0FFF0000
+#define		BREAKADR2_MASK		0x00000FFF
+
+/* 0x14h - 0x1Ch are reserved */
+
+/* 
+ * ARP2 Registers, Address Range : (0x00-0x1F)
+ * The definitions have the same address offset for CSEQ and LmSEQ 
+ * CIO Bus Registers.
+ */
+#define MODEPTR		0x00
+
+#define		DSTMODE			0xF0
+#define		SRCMODE			0x0F
+
+#define ALTMODE		0x01
+
+#define		ALTDMODE		0xF0
+#define		ALTSMODE		0x0F
+
+#define ATOMICXCHG	0x02
+
+#define FLAG		0x04
+
+#define		INTCODE_MASK		0xF0
+#define		ALTMODEV2		0x04
+#define		CARRY_INT		0x02
+#define		CARRY			0x01
+
+#define ARP2INTCTL	0x05
+
+#define 	PAUSEDIS		0x80
+#define		RSTINTCTL		0x40
+#define		POPALTMODE		0x08
+#define		ALTMODEV		0x04
+#define		INTMASK			0x02
+#define		IRET			0x01
+
+#define STACK		0x06
+
+#define FUNCTION1	0x07
+
+#define PRGMCNT		0x08
+
+#define ACCUM		0x0A
+
+#define SINDEX		0x0C
+
+#define DINDEX		0x0E
+
+#define ALLONES		0x10
+
+#define ALLZEROS	0x11
+
+#define SINDIR		0x12
+
+#define DINDIR		0x13
+
+#define JUMLDIR		0x14
+
+#define ARP2HALTCODE	0x15
+
+#define CURRADDR	0x16
+
+#define LASTADDR	0x18
+
+#define NXTLADDR	0x1A
+
+#define DBGPORTPTR	0x1C
+
+#define DBGPORT		0x1D
+
+/*
+ * CIO Registers.
+ * The definitions have the same address offset for CSEQ and LmSEQ 
+ * CIO Bus Registers.
+ */ 
+#define MnSCBPTR      	0x20
+
+#define MnDDBPTR      	0x22
+
+#define SCRATCHPAGE	0x24
+
+#define MnSCRATCHPAGE	0x25
+
+#define SCRATCHPAGESV	0x26
+
+#define MnSCRATCHPAGESV	0x27
+
+#define MnDMAERRS	0x46
+
+#define MnSGDMAERRS	0x47
+
+#define MnSGBUF		0x53
+
+#define MnSGDMASTAT	0x5b
+
+#define MnDDMACTL	0x5c	/* RAXOR.rspec.fm rev 1.5 is wrong */
+
+#define MnDDMASTAT	0x5d	/* RAXOR.rspec.fm rev 1.5 is wrong */
+
+#define MnDDMAMODE	0x5e	/* RAXOR.rspec.fm rev 1.5 is wrong */
+
+#define MnDMAENG	0x60
+
+#define MnPIPECTL	0x61
+
+#define MnSGBADR	0x65
+
+#define MnSCB_SITE	0x100
+
+#define MnDDB_SITE	0x180
+
+/*
+ * The common definitions below have the same address offset for both 
+ * CSEQ and LmSEQ.
+ */
+#define BISTCTL0	0x4C	
+
+#define BISTCTL1	0x50
+
+#define MAPPEDSCR	0x800 
+  
+/* 
+ * CSEQ Host Register, Address Range : (0x000-0xFFC)
+ */
+#define CSEQ_HOST_REG_BASE_ADR		0xB8001000
+
+#define CARP2CTL			(CSEQ_HOST_REG_BASE_ADR	+ ARP2CTL)
+
+#define CARP2INT			(CSEQ_HOST_REG_BASE_ADR	+ ARP2INT)
+
+#define CARP2INTEN			(CSEQ_HOST_REG_BASE_ADR	+ ARP2INTEN)
+
+#define CARP2BREAKADR01			(CSEQ_HOST_REG_BASE_ADR+ARP2BREAKADR01)
+
+#define CARP2BREAKADR23			(CSEQ_HOST_REG_BASE_ADR+ARP2BREAKADR23)
+
+#define CBISTCTL			(CSEQ_HOST_REG_BASE_ADR	+ BISTCTL1)
+
+#define		CSEQRAMBISTEN		0x00000040		
+#define		CSEQRAMBISTDN		0x00000020	/* ro */	
+#define		CSEQRAMBISTFAIL		0x00000010	/* ro */
+#define		CSEQSCRBISTEN		0x00000004
+#define		CSEQSCRBISTDN		0x00000002	/* ro */
+#define		CSEQSCRBISTFAIL		0x00000001	/* ro */
+
+#define CMAPPEDSCR			(CSEQ_HOST_REG_BASE_ADR	+ MAPPEDSCR) 
+#define CMAPPEDSCR_LEN			0x400
+#define LmMAPPEDSCR_LEN			0x200
+
+/* 
+ * CSEQ CIO Bus Registers, Address Range : (0x0000-0x1FFC)
+ * 16 modes, each mode is 512 bytes.
+ * Unless specified, the register should valid for all modes.
+ */
+#define CSEQ_CIO_REG_BASE_ADR		0xB8002000
+
+#define CSEQm_CIO_REG(Mode, Reg) \
+		(CSEQ_CIO_REG_BASE_ADR  + \
+		((uint32_t) (Mode) * CSEQ_MODE_PAGE_SIZE) + (uint32_t) (Reg))
+
+#define CMODEPTR	(CSEQ_CIO_REG_BASE_ADR + MODEPTR)
+
+#define CALTMODE	(CSEQ_CIO_REG_BASE_ADR + ALTMODE)
+
+#define CATOMICXCHG	(CSEQ_CIO_REG_BASE_ADR + ATOMICXCHG)
+
+#define CFLAG		(CSEQ_CIO_REG_BASE_ADR + FLAG)
+
+#define CARP2INTCTL	(CSEQ_CIO_REG_BASE_ADR + ARP2INTCTL)
+
+#define CSTACK		(CSEQ_CIO_REG_BASE_ADR + STACK)
+
+#define CFUNCTION1	(CSEQ_CIO_REG_BASE_ADR + FUNCTION1)
+
+#define CPRGMCNT	(CSEQ_CIO_REG_BASE_ADR + PRGMCNT)
+
+#define CACCUM		(CSEQ_CIO_REG_BASE_ADR + ACCUM)
+
+#define CSINDEX		(CSEQ_CIO_REG_BASE_ADR + SINDEX)
+
+#define CDINDEX		(CSEQ_CIO_REG_BASE_ADR + DINDEX)
+
+#define CALLONES	(CSEQ_CIO_REG_BASE_ADR + ALLONES)
+
+#define CALLZEROS	(CSEQ_CIO_REG_BASE_ADR + ALLZEROS)
+
+#define CSINDIR		(CSEQ_CIO_REG_BASE_ADR + SINDIR)
+
+#define CDINDIR		(CSEQ_CIO_REG_BASE_ADR + DINDIR)
+
+#define CJUMLDIR	(CSEQ_CIO_REG_BASE_ADR + JUMLDIR)
+
+#define CARP2HALTCODE	(CSEQ_CIO_REG_BASE_ADR + ARP2HALTCODE)
+
+#define CCURRADDR	(CSEQ_CIO_REG_BASE_ADR + CURRADDR)
+
+#define CLASTADDR	(CSEQ_CIO_REG_BASE_ADR + LASTADDR)
+
+#define CNXTLADDR	(CSEQ_CIO_REG_BASE_ADR + NXTLADDR)
+
+#define CDBGPORTPTR	(CSEQ_CIO_REG_BASE_ADR + DBGPORTPTR)
+
+#define CDBGPORT	(CSEQ_CIO_REG_BASE_ADR + DBGPORT)
+
+#define CSCRATCHPAGE	(CSEQ_CIO_REG_BASE_ADR + SCRATCHPAGE)
+	
+#define CMnSCRATCHPAGE(Mode)		CSEQm_CIO_REG(Mode, MnSCRATCHPAGE)	
+
+#define CLINKCON	(CSEQ_CIO_REG_BASE_ADR + 0x28)
+
+#define	CCIOAACESS	(CSEQ_CIO_REG_BASE_ADR + 0x2C)
+	
+/* mode 0-7 */	
+#define CMnREQMBX(Mode)			CSEQm_CIO_REG(Mode, 0x30)
+
+/* mode 8 */
+#define CSEQCON				CSEQm_CIO_REG(8, 0x30)
+
+/* mode 0-7 */ 
+#define CMnRSPMBX(Mode)			CSEQm_CIO_REG(Mode, 0x34)
+
+/* mode 8 */
+#define CSEQCOMCTL			CSEQm_CIO_REG(8, 0x34)
+
+/* mode 8 */
+#define CSEQCOMSTAT			CSEQm_CIO_REG(8, 0x35)
+
+/* mode 8 */
+#define CSEQCOMINTEN			CSEQm_CIO_REG(8, 0x36)
+
+/* mode 8 */
+#define CSEQCOMDMACTL			CSEQm_CIO_REG(8, 0x37)
+
+#define		CSHALTERR		0x10		
+#define		RESETCSDMA		0x08		/* wo */
+#define		STARTCSDMA		0x04
+#define		STOPCSDMA		0x02		/* wo */
+#define		CSDMAACT		0x01		/* ro */
+	
+/* mode 0-7 */
+#define CMnINT(Mode)			CSEQm_CIO_REG(Mode, 0x38)
+
+#define		CMnREQMBXE		0x02
+#define		CMnRSPMBXF		0x01
+#define		CMnINT_MASK		0x00000003
+
+/* mode 8 */
+#define CSEQREQMBX			CSEQm_CIO_REG(8, 0x38)
+
+/* mode 0-7 */
+#define CMnINTEN(Mode)			CSEQm_CIO_REG(Mode, 0x3C)
+	
+#define		EN_CMnRSPMBXF		0x01
+
+/* mode 8 */
+#define CSEQRSPMBX			CSEQm_CIO_REG(8, 0x3C)
+
+/* mode 8 */
+#define CSDMAADR			CSEQm_CIO_REG(8, 0x40)
+
+/* mode 8 */
+#define CSDMACNT			CSEQm_CIO_REG(8, 0x48)
+
+/* mode 8 */
+#define CSEQDLCTL			CSEQm_CIO_REG(8, 0x4D)
+
+#define		DONELISTEND		0x10
+#define 	DONELISTSIZE_MASK	0x0F
+#define		DONELISTSIZE_8ELEM	0x01
+#define		DONELISTSIZE_16ELEM	0x02
+#define		DONELISTSIZE_32ELEM	0x03
+#define		DONELISTSIZE_64ELEM	0x04
+#define		DONELISTSIZE_128ELEM	0x05
+#define		DONELISTSIZE_256ELEM	0x06
+#define		DONELISTSIZE_512ELEM	0x07
+#define		DONELISTSIZE_1024ELEM	0x08
+#define		DONELISTSIZE_2048ELEM	0x09
+#define		DONELISTSIZE_4096ELEM	0x0A
+#define		DONELISTSIZE_8192ELEM	0x0B
+#define		DONELISTSIZE_16384ELEM	0x0C
+
+/* mode 8 */
+#define CSEQDLOFFS			CSEQm_CIO_REG(8, 0x4E)
+
+/* mode 11 */
+#define CM11INTVEC0			CSEQm_CIO_REG(11, 0x50)
+
+/* mode 11 */
+#define CM11INTVEC1			CSEQm_CIO_REG(11, 0x52)
+
+/* mode 11 */
+#define CM11INTVEC2			CSEQm_CIO_REG(11, 0x54)
+
+#define	CCONMSK	  			(CSEQ_CIO_REG_BASE_ADR + 0x60)
+
+#define	CCONEXIST			(CSEQ_CIO_REG_BASE_ADR + 0x61)
+
+#define	CCONMODE			(CSEQ_CIO_REG_BASE_ADR + 0x62)
+
+#define CTIMERCALC			(CSEQ_CIO_REG_BASE_ADR + 0x64)
+
+#define CINTDIS				(CSEQ_CIO_REG_BASE_ADR + 0x68)
+
+/* mode 8 */
+#define CSBUFFER			CSEQm_CIO_REG(11, 0x6C)
+
+#define	CSCRATCH			(CSEQ_CIO_REG_BASE_ADR + 0x1C0)
+
+/* mode 0-8 */
+#define CMnSCRATCH(Mode)		CSEQm_CIO_REG(Mode, 0x1E0)
+
+/* 
+ * CSEQ Mapped Instruction RAM Page, Address Range : (0x0000-0x1FFC)
+ */
+#define CSEQ_RAM_REG_BASE_ADR		0xB8004000
+
+/*
+ * The common definitions below have the same address offset for all the Link
+ * sequencers.
+ */
+#define MODECTL		0x40
+
+#define DBGMODE		0x44
+
+#define CONTROL		0x48
+#define LEDTIMER		0x00010000
+#define LEDTIMERS_10us		0x00000000
+#define LEDTIMERS_1ms		0x00000800
+#define LEDTIMERS_100ms		0x00001000
+#define LEDMODE_TXRX		0x00000000
+#define LEDMODE_CONNECTED	0x00000200
+#define LEDPOL			0x00000100
+
+#define LSEQRAM		0x1000
+  
+/* 
+ * LmSEQ Host Registers, Address Range : (0x0000-0x3FFC)
+ */
+#define LSEQ0_HOST_REG_BASE_ADR		0xB8020000
+#define LSEQ1_HOST_REG_BASE_ADR		0xB8024000
+#define LSEQ2_HOST_REG_BASE_ADR		0xB8028000
+#define LSEQ3_HOST_REG_BASE_ADR		0xB802C000
+#define LSEQ4_HOST_REG_BASE_ADR		0xB8030000
+#define LSEQ5_HOST_REG_BASE_ADR		0xB8034000
+#define LSEQ6_HOST_REG_BASE_ADR		0xB8038000
+#define LSEQ7_HOST_REG_BASE_ADR		0xB803C000
+
+#define LmARP2CTL(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) + \
+					ARP2CTL)
+
+#define LmARP2INT(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) + \
+					ARP2INT)
+
+#define LmARP2INTEN(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					ARP2INTEN)
+
+#define LmDBGMODE(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					DBGMODE)
+
+#define LmCONTROL(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					CONTROL)
+
+#define LmARP2BREAKADR01(LinkNum)	(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					ARP2BREAKADR01)
+					
+#define LmARP2BREAKADR23(LinkNum)	(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					ARP2BREAKADR23)	
+				
+#define LmMODECTL(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					MODECTL)
+
+#define		LmAUTODISCI		0x08000000                     
+#define		LmDSBLBITLT		0x04000000  
+#define		LmDSBLANTT		0x02000000  
+#define		LmDSBLCRTT		0x01000000 
+#define		LmDSBLCONT		0x00000100
+#define		LmPRIMODE		0x00000080   
+#define		LmDSBLHOLD		0x00000040  
+#define		LmDISACK		0x00000020 
+#define		LmBLIND48		0x00000010
+#define		LmRCVMODE_MASK		0x0000000C   
+#define		LmRCVMODE_PLD		0x00000000  
+#define		LmRCVMODE_HPC		0x00000004 
+					
+#define LmDBGMODE(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					DBGMODE)
+
+#define		LmFRCPERR		0x80000000  
+#define		LmMEMSEL_MASK		0x30000000 
+#define		LmFRCRBPERR		0x00000000
+#define		LmFRCTBPERR		0x10000000   
+#define		LmFRCSGBPERR		0x20000000   
+#define		LmFRCARBPERR		0x30000000  
+#define		LmRCVIDW		0x00080000 
+#define		LmINVDWERR		0x00040000
+#define		LmRCVDISP		0x00004000
+#define		LmDISPERR		0x00002000
+#define		LmDSBLDSCR		0x00000800
+#define		LmDSBLSCR		0x00000400
+#define		LmFRCNAK		0x00000200
+#define		LmFRCROFS		0x00000100
+#define		LmFRCCRC		0x00000080  
+#define		LmFRMTYPE_MASK		0x00000070 
+#define		LmSG_DATA		0x00000000
+#define		LmSG_COMMAND		0x00000010   
+#define		LmSG_TASK		0x00000020  
+#define		LmSG_TGTXFER		0x00000030 
+#define		LmSG_RESPONSE		0x00000040
+#define		LmSG_IDENADDR		0x00000050  
+#define		LmSG_OPENADDR		0x00000060  
+#define		LmDISCRCGEN		0x00000008 
+#define		LmDISCRCCHK		0x00000004
+#define		LmSSXMTFRM		0x00000002  
+#define		LmSSRCVFRM		0x00000001
+
+#define LmCONTROL(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					CONTROL)
+					 
+#define		LmSTEPXMTFRM		0x00000002
+#define		LmSTEPRCVFRM		0x00000001
+
+#define LmBISTCTL0(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					BISTCTL0)
+
+#define		ARBBISTEN		0x40000000 
+#define		ARBBISTDN		0x20000000	/* ro */
+#define		ARBBISTFAIL		0x10000000	/* ro */  
+#define		TBBISTEN		0x00000400   
+#define		TBBISTDN		0x00000200	/* ro */  
+#define		TBBISTFAIL		0x00000100	/* ro */ 
+#define		RBBISTEN		0x00000040
+#define		RBBISTDN		0x00000020	/* ro */   
+#define		RBBISTFAIL		0x00000010	/* ro */  
+#define		SGBISTEN		0x00000004 
+#define		SGBISTDN		0x00000002	/* ro */
+#define		SGBISTFAIL		0x00000001	/* ro */
+
+#define LmBISTCTL1(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	\
+					(LinkNum*LmSEQ_HOST_REG_SIZE) +	\
+					BISTCTL1)
+
+#define		LmRAMPAGE1		0x00000200   
+#define		LmRAMPAGE0		0x00000100  
+#define		LmIMEMBISTEN		0x00000040 
+#define		LmIMEMBISTDN		0x00000020	/* ro */
+#define		LmIMEMBISTFAIL		0x00000010	/* ro */  
+#define		LmSCRBISTEN		0x00000004 
+#define		LmSCRBISTDN		0x00000002	/* ro */ 
+#define		LmSCRBISTFAIL		0x00000001	/* ro */
+#define		LmRAMPAGE		(LmRAMPAGE1 + LmRAMPAGE0)
+#define		LmRAMPAGE_LSHIFT	0x8
+
+#define LmSCRATCH(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	  \
+					(LinkNum * LmSEQ_HOST_REG_SIZE) + \
+					MAPPEDSCR)
+
+#define LmSEQRAM(LinkNum)		(LSEQ0_HOST_REG_BASE_ADR +	  \
+					(LinkNum * LmSEQ_HOST_REG_SIZE) + \
+					LSEQRAM)
+
+/* 
+ * LmSEQ CIO Bus Register, Address Range : (0x0000-0xFFC)
+ * 8 modes, each mode is 512 bytes.
+ * Unless specified, the register should valid for all modes.
+ */
+#define LmSEQ_CIOBUS_REG_BASE		0x2000
+
+#define  LmSEQ_PHY_BASE(Mode, LinkNum) \
+		(LSEQ0_HOST_REG_BASE_ADR + \
+		(LmSEQ_HOST_REG_SIZE * (uint32_t) (LinkNum)) + \
+		LmSEQ_CIOBUS_REG_BASE + \
+		((uint32_t) (Mode) * LmSEQ_MODE_PAGE_SIZE))
+
+#define  LmSEQ_PHY_REG(Mode, LinkNum, Reg) \
+		(LSEQ0_HOST_REG_BASE_ADR + \
+		(LmSEQ_HOST_REG_SIZE * (uint32_t) (LinkNum)) + \
+		LmSEQ_CIOBUS_REG_BASE + \
+		((uint32_t) (Mode) * LmSEQ_MODE_PAGE_SIZE) + (uint32_t) (Reg))
+
+#define LmMODEPTR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, MODEPTR)
+
+#define LmALTMODE(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, ALTMODE)
+
+#define LmATOMICXCHG(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, ATOMICXCHG)
+
+#define LmFLAG(LinkNum)			LmSEQ_PHY_REG(0, LinkNum, FLAG)
+
+#define LmARP2INTCTL(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, ARP2INTCTL)
+
+#define LmSTACK(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, STACK)
+
+#define LmFUNCTION1(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, FUNCTION1)
+
+#define LmPRGMCNT(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, PRGMCNT)
+
+#define LmACCUM(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, ACCUM)
+
+#define LmSINDEX(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, SINDEX)
+
+#define LmDINDEX(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, DINDEX)
+
+#define LmALLONES(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, ALLONES)
+
+#define LmALLZEROS(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, ALLZEROS)
+
+#define LmSINDIR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, SINDIR)
+
+#define LmDINDIR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, DINDIR)
+
+#define LmJUMLDIR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, JUMLDIR)
+
+#define LmARP2HALTCODE(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, ARP2HALTCODE)
+
+#define LmCURRADDR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, CURRADDR)
+
+#define LmLASTADDR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, LASTADDR)
+
+#define LmNXTLADDR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, NXTLADDR)
+
+#define LmDBGPORTPTR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, DBGPORTPTR)
+
+#define LmDBGPORT(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, DBGPORT)
+	
+#define LmSCRATCHPAGE(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, SCRATCHPAGE)
+
+#define LmMnSCRATCHPAGE(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 	\
+						      MnSCRATCHPAGE)	
+
+#define LmTIMERCALC(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x28)
+
+#define LmREQMBX(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x30)
+
+#define LmRSPMBX(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x34)
+
+#define LmMnINT(LinkNum, Mode)		LmSEQ_PHY_REG(Mode, LinkNum, 0x38)
+
+#define		LmACKREQ		0x08000000   
+#define		LmNAKREQ		0x04000000   
+#define		LmMnXMTERR		0x02000000   
+#define		LmM5OOBSVC		0x01000000   
+#define		LmHWTINT		0x00800000   
+#define		LmMnCTXDONE		0x00100000   
+#define		LmM2REQMBXF		0x00080000   
+#define		LmM2RSPMBXE		0x00040000   
+#define		LmMnDMAERR		0x00020000   
+#define		LmRCVPRIM		0x00010000   
+#define		LmRCVERR		0x00008000   
+#define		LmADDRRCV		0x00004000   
+#define		LmMnHDRMISS		0x00002000   
+#define		LmMnWAITSCB		0x00001000   
+#define		LmMnRLSSCB		0x00000800   
+#define		LmMnSAVECTX		0x00000400  
+#define		LmMnFETCHSG		0x00000200 
+#define		LmMnLOADCTX		0x00000100
+#define		LmMnCFGICL		0x00000080   
+#define		LmMnCFGSATA		0x00000040  
+#define		LmMnCFGEXPSATA		0x00000020 
+#define		LmMnCFGCMPLT		0x00000010   
+#define		LmMnCFGRBUF		0x00000008 
+#define		LmMnSAVETTR		0x00000004
+#define		LmMnCFGRDAT		0x00000002 
+#define		LmMnCFGHDR		0x00000001  
+
+#define		LmM0INTMASK		0xFFFFFFFF
+#define		LmM1INTMASK		0xFFFFFFFF
+#define		LmM2INTMASK		0xFFFFFFFF
+#define		LmM5INTMASK		0xFFFFFFFF
+
+#define LmMnINTEN(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x3C)
+
+#define		EN_LmACKREQ		0x08000000   
+#define		EN_LmNAKREQ		0x04000000   
+#define		EN_LmMnXMTERR		0x02000000   
+#define		EN_LmM5OOBSVC		0x01000000   
+#define		EN_LmHWTINT		0x00800000   
+#define		EN_LmMnCTXDONE		0x00100000   
+#define		EN_LmM2REQMBXF		0x00080000   
+#define		EN_LmM2RSPMBXE		0x00040000   
+#define		EN_LmMnDMAERR		0x00020000   
+#define		EN_LmRCVPRIM		0x00010000   
+#define		EN_LmRCVERR		0x00008000   
+#define		EN_LmADDRRCV		0x00004000   
+#define		EN_LmMnHDRMISS		0x00002000   
+#define		EN_LmMnWAITSCB		0x00001000   
+#define		EN_LmMnRLSSCB		0x00000800   
+#define		EN_LmMnSAVECTX		0x00000400  
+#define		EN_LmMnFETCHSG		0x00000200 
+#define		EN_LmMnLOADCTX		0x00000100
+#define		EN_LmMnCFGICL		0x00000080   
+#define		EN_LmMnCFGSATA		0x00000040  
+#define		EN_LmMnCFGEXPSATA	0x00000020 
+#define		EN_LmMnCFGCMPLT		0x00000010   
+#define		EN_LmMnCFGRBUF		0x00000008 
+#define		EN_LmMnSAVETTR		0x00000004
+#define		EN_LmMnCFGRDAT		0x00000002 
+#define		EN_LmMnCFGHDR		0x00000001 
+
+#define		LmM0INTEN_MASK		(EN_LmMnCFGCMPLT | EN_LmMnCFGRBUF | \
+					 EN_LmMnSAVETTR | EN_LmMnCFGRDAT | \
+					 EN_LmMnCFGHDR | EN_LmRCVERR | \
+					 EN_LmADDRRCV | EN_LmMnHDRMISS | \
+					 EN_LmMnRLSSCB | EN_LmMnSAVECTX | \
+					 EN_LmMnFETCHSG | EN_LmMnLOADCTX | \
+					 EN_LmHWTINT | EN_LmMnCTXDONE | \
+					 EN_LmRCVPRIM | EN_LmMnCFGSATA | \
+					 EN_LmMnCFGEXPSATA | EN_LmMnDMAERR)
+
+#define		LmM1INTEN_MASK		(EN_LmMnCFGCMPLT | EN_LmADDRRCV | \
+					 EN_LmMnRLSSCB | EN_LmMnSAVECTX | \
+					 EN_LmMnFETCHSG | EN_LmMnLOADCTX | \
+					 EN_LmMnXMTERR | EN_LmHWTINT | \
+					 EN_LmMnCTXDONE | EN_LmRCVPRIM | \
+					 EN_LmRCVERR | EN_LmMnDMAERR)
+
+#define		LmM2INTEN_MASK		(EN_LmADDRRCV | EN_LmHWTINT | \
+					 EN_LmM2REQMBXF | EN_LmRCVPRIM | \
+					 EN_LmRCVERR)
+
+#define		LmM5INTEN_MASK		(EN_LmADDRRCV | EN_LmM5OOBSVC | \
+					 EN_LmHWTINT | EN_LmRCVPRIM | \
+					 EN_LmRCVERR)
+
+#define LmXMTPRIMD(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x40)
+
+#define LmXMTPRIMCS(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x44)
+
+#define LmCONSTAT(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x45)
+
+#define LmMnDMAERRS(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x46)
+
+#define LmMnSGDMAERRS(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x47)
+
+#define LmM0EXPHDRP(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x48)
+
+#define LmM1SASALIGN(LinkNum)		LmSEQ_PHY_REG(1, LinkNum, 0x48)
+#define SAS_ALIGN_DEFAULT		0xFF
+
+#define LmM0MSKHDRP(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x49)
+
+#define LmM1STPALIGN(LinkNum)		LmSEQ_PHY_REG(1, LinkNum, 0x49)
+#define STP_ALIGN_DEFAULT		0x1F
+
+#define LmM0RCVHDRP(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x4A)
+
+#define LmM1XMTHDRP(LinkNum)		LmSEQ_PHY_REG(1, LinkNum, 0x4A)
+
+#define LmM0ICLADR(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x4B)
+
+#define LmM1ALIGNMODE(LinkNum)		LmSEQ_PHY_REG(1, LinkNum, 0x4B)
+
+#define		LmDISALIGN		0x20
+#define		LmROTSTPALIGN		0x10
+#define		LmSTPALIGN		0x08
+#define		LmROTNOTIFY		0x04
+#define		LmDUALALIGN		0x02
+#define		LmROTALIGN		0x01
+
+#define LmM0EXPRCVNT(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x4C)
+
+#define LmM1XMTCNT(LinkNum)		LmSEQ_PHY_REG(1, LinkNum, 0x4C)
+
+#define LmMnBUFSTAT(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x4E)     
+
+#define		LmMnBUFPERR		0x01
+
+/* mode 0-1 */		
+#define LmMnXFRLVL(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x59)
+
+#define		LmMnXFRLVL_128		0x05
+#define		LmMnXFRLVL_256		0x04
+#define		LmMnXFRLVL_512		0x03
+#define		LmMnXFRLVL_1024		0x02
+#define		LmMnXFRLVL_1536		0x01
+#define		LmMnXFRLVL_2048		0x00
+
+ /* mode 0-1 */
+#define LmMnSGDMACTL(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x5A)
+
+#define 	LmMnRESETSG		0x04
+#define 	LmMnSTOPSG		0x02
+#define 	LmMnSTARTSG		0x01
+
+/* mode 0-1 */
+#define LmMnSGDMASTAT(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x5B)
+
+/* mode 0-1 */
+#define LmMnDDMACTL(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x5C)
+
+#define 	LmMnFLUSH		0x40		/* wo */		
+#define 	LmMnRLSRTRY		0x20		/* wo */
+#define 	LmMnDISCARD		0x10		/* wo */
+#define 	LmMnRESETDAT		0x08		/* wo */
+#define 	LmMnSUSDAT		0x04		/* wo */
+#define 	LmMnSTOPDAT		0x02		/* wo */
+#define 	LmMnSTARTDAT		0x01		/* wo */
+
+/* mode 0-1 */
+#define LmMnDDMASTAT(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x5D)
+
+#define		LmMnDPEMPTY		0x80
+#define		LmMnFLUSHING		0x40
+#define		LmMnDDMAREQ		0x20
+#define		LmMnHDMAREQ		0x10
+#define		LmMnDATFREE		0x08
+#define		LmMnDATSUS		0x04
+#define		LmMnDATACT		0x02
+#define		LmMnDATEN		0x01
+
+/* mode 0-1 */
+#define LmMnDDMAMODE(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x5E)
+
+#define 	LmMnDMATYPE_NORMAL		0x0000
+#define 	LmMnDMATYPE_HOST_ONLY_TX	0x0001
+#define 	LmMnDMATYPE_DEVICE_ONLY_TX	0x0002
+#define 	LmMnDMATYPE_INVALID		0x0003
+#define 	LmMnDMATYPE_MASK	0x0003
+
+#define 	LmMnDMAWRAP		0x0004
+#define 	LmMnBITBUCKET		0x0008
+#define 	LmMnDISHDR		0x0010
+#define 	LmMnSTPCRC		0x0020
+#define 	LmXTEST			0x0040
+#define 	LmMnDISCRC		0x0080
+#define 	LmMnENINTLK		0x0100
+#define 	LmMnADDRFRM		0x0400
+#define 	LmMnENXMTCRC		0x0800
+
+/* mode 0-1 */
+#define LmMnXFRCNT(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x70)
+
+/* mode 0-1 */
+#define LmMnDPSEL(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x7B)
+#define 	LmMnDPSEL_MASK		0x07
+#define 	LmMnEOLPRE		0x40
+#define 	LmMnEOSPRE		0x80
+
+/* Registers used in conjunction with LmMnDPSEL and LmMnDPACC registers */
+/* Receive Mode n = 0 */
+#define LmMnHRADDR			0x00
+#define LmMnHBYTECNT			0x01
+#define LmMnHREWIND			0x02
+#define LmMnDWADDR			0x03
+#define LmMnDSPACECNT			0x04
+#define LmMnDFRMSIZE			0x05
+
+/* Registers used in conjunction with LmMnDPSEL and LmMnDPACC registers */
+/* Transmit Mode n = 1 */
+#define LmMnHWADDR			0x00
+#define LmMnHSPACECNT			0x01
+/* #define LmMnHREWIND			0x02 */
+#define LmMnDRADDR			0x03
+#define LmMnDBYTECNT			0x04
+/* #define LmMnDFRMSIZE			0x05 */
+
+/* mode 0-1 */
+#define LmMnDPACC(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x78)
+#define 	LmMnDPACC_MASK		0x00FFFFFF
+
+/* mode 0-1 */
+#define LmMnHOLDLVL(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x7D)
+#ifdef SEQUENCER_UPDATE
+#define		LmMnHOLD_INIT_VALUE	0x50
+#else
+#define		LmMnHOLD_INIT_VALUE	0x28
+#endif
+
+#define LmPRMSTAT0(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x80)
+#define LmPRMSTAT0BYTE0			0x80
+#define LmPRMSTAT0BYTE1			0x81
+#define LmPRMSTAT0BYTE2			0x82
+#define LmPRMSTAT0BYTE3			0x83
+
+#define		LmUNKNOWNP		0x20000000  
+#define		LmBREAK			0x10000000  
+#define		LmDONE			0x08000000 
+#define		LmOPENACPT		0x04000000
+#define		LmOPENRJCT		0x02000000  
+#define		LmOPENRTRY		0x01000000   
+#define		LmCLOSERV1		0x00800000  
+#define		LmCLOSERV0		0x00400000   
+#define		LmCLOSENORM		0x00200000   
+#define		LmCLOSECLAF		0x00100000  
+#define		LmNOTIFYRV2		0x00080000   
+#define		LmNOTIFYRV1		0x00040000  
+#define		LmNOTIFYNORM		0x00020000   
+#define		LmNOTIFYSPIN		0x00010000  
+#define		LmBROADRV4		0x00008000   
+#define		LmBROADRV3		0x00004000  
+#define		LmBROADRV2		0x00002000
+#define		LmBROADRV1		0x00001000  
+#define		LmBROADRV0		0x00000800 
+#define		LmBROADRVCH1		0x00000400
+#define		LmBROADRVCH0		0x00000200   
+#define		LmBROADCH		0x00000100  
+#define		LmAIPRVWP		0x00000080 
+#define		LmAIPWP			0x00000040
+#define		LmAIPWD			0x00000020  
+#define		LmAIPWC			0x00000010 
+#define		LmAIPRV2		0x00000008 
+#define		LmAIPRV1		0x00000004  
+#define		LmAIPRV0		0x00000002 
+#define		LmAIPNRML		0x00000001	
+
+#define		LmBROADCAST_MASK	(LmBROADCH | LmBROADRVCH0 | \
+					 LmBROADRVCH1)
+                            
+#define		LmPRMSTAT0CLR_MASK	0xFFFFFFFF
+
+#define LmPRMSTAT1(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0x84)
+#define LmPRMSTAT1BYTE0			0x84
+#define LmPRMSTAT1BYTE1			0x85
+#define LmPRMSTAT1BYTE2			0x86
+#define LmPRMSTAT1BYTE3			0x87
+
+#define		LmBREAK_DET		0x04000000
+#define		LmCLOSE_DET		0x02000000
+#define		LmDONE_DET		0x01000000	
+#define		LmXRDY			0x00040000   
+#define 	LmSYNCSRST		0x00020000   
+#define 	LmSYNC			0x00010000   
+#define 	LmXHOLD			0x00008000   
+#define 	LmRRDY			0x00004000   
+#define 	LmHOLD			0x00002000   
+#define 	LmROK			0x00001000   
+#define 	LmRIP			0x00000800  
+#define 	LmCRBLK			0x00000400 
+#define 	LmACK			0x00000200
+#define 	LmNAK			0x00000100   
+#define 	LmHARDRST		0x00000080  
+#define 	LmERROR			0x00000040 
+#define 	LmRERR			0x00000020
+#define 	LmPMREQP		0x00000010   
+#define 	LmPMREQS		0x00000008  
+#define 	LmPMACK			0x00000004 
+#define 	LmPMNAK			0x00000002
+#define 	LmDMAT			0x00000001
+
+#define		LmPRMSTAT1CLR_MASK	0xFFFFFFFF
+
+/* mode 1 */
+#define	LmMnSATAFS(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x7E)
+#define	LmMnXMTSIZE(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0x93)
+
+/* mode 0 */
+#define LmMnFRMERR(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0xB0)
+
+#define		LmACRCERR		0x00000800   
+#define		LmPHYOVRN		0x00000400  
+#define		LmOBOVRN		0x00000200   
+#define 	LmMnZERODATA		0x00000100  
+#define		LmSATAINTLK		0x00000080   
+#define		LmMnCRCERR		0x00000020  
+#define		LmRRDYOVRN		0x00000010 
+#define		LmMISSSOAF		0x00000008   
+#define		LmMISSSOF		0x00000004  
+#define		LmMISSEOAF		0x00000002 
+#define		LmMISSEOF		0x00000001
+#define 	LmMnFRMERR_INIT		0xFFFFFFFF
+
+#define LmFRMERREN(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0xB4)
+
+#define 	EN_LmACRCERR		0x00000800
+#define 	EN_LmPHYOVRN		0x00000400
+#define 	EN_LmOBOVRN		0x00000200 
+#define 	EN_LmMnZERODATA		0x00000100 
+#define 	EN_LmSATAINTLK		0x00000080
+#define 	EN_LmFRMBAD		0x00000040
+#define 	EN_LmMnCRCERR		0x00000020
+#define 	EN_LmRRDYOVRN		0x00000010
+#define 	EN_LmMISSSOAF		0x00000008
+#define 	EN_LmMISSSOF		0x00000004
+#define 	EN_LmMISSEOAF		0x00000002 
+#define 	EN_LmMISSEOF		0x00000001  
+
+#define 	LmFRMERREN_MASK  	(EN_LmSATAINTLK | EN_LmMnCRCERR | \
+					 EN_LmRRDYOVRN | EN_LmMISSSOF | \
+					 EN_LmMISSEOAF | EN_LmMISSEOF | \
+					 EN_LmACRCERR | LmPHYOVRN | \
+					 EN_LmOBOVRN | EN_LmMnZERODATA | \
+					 EN_LmFRMBAD)
+
+#define LmHWTSTATEN(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0xC5)
+                                 
+#define		EN_LmDONETO		0x80  
+#define		EN_LmINVDISP		0x40 
+#define		EN_LmINVDW		0x20     
+#define		EN_LmDWSEVENT		0x08    
+#define		EN_LmCRTTTO		0x04    
+#define		EN_LmANTTTO		0x02     
+#define		EN_LmBITLTTO		0x01
+
+#define		LmHWTSTATEN_MASK	(EN_LmINVDISP | EN_LmINVDW | \
+					 EN_LmDWSEVENT | EN_LmCRTTTO | \
+					 EN_LmANTTTO | EN_LmDONETO | \
+					 EN_LmBITLTTO)
+
+#define LmHWTSTAT(LinkNum) 		LmSEQ_PHY_REG(0, LinkNum, 0xC7)
+        
+#define		LmDONETO		0x80 
+#define		LmINVDISP		0x40   
+#define		LmINVDW			0x20  
+#define		LmDWSEVENT		0x08 
+#define		LmCRTTTO		0x04
+#define		LmANTTTO		0x02
+#define		LmBITLTTO		0x01
+
+#define		LmHWTSTAT_MASK		0xFF
+
+#define LmMnDATABUFADR(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0xC8)
+#define		LmDATABUFADR_MASK	0x0FFF
+
+#define LmMnDATABUF(LinkNum, Mode)	LmSEQ_PHY_REG(Mode, LinkNum, 0xCA)
+
+#define	LmPRMSTAT0EN(LinkNum)		LmSEQ_PHY_REG(0, LinkNum, 0xE0)        
+
+#define 	EN_LmUNKNOWNP 		0x20000000  
+#define 	EN_LmBREAK		0x10000000   
+#define 	EN_LmDONE		0x08000000  
+#define 	EN_LmOPENACPT		0x04000000 
+#define 	EN_LmOPENRJCT		0x02000000  
+#define 	EN_LmOPENRTRY		0x01000000 
+#define 	EN_LmCLOSERV1		0x00800000
+#define 	EN_LmCLOSERV0		0x00400000   
+#define 	EN_LmCLOSENORM		0x00200000  
+#define 	EN_LmCLOSECLAF		0x00100000 
+#define 	EN_LmNOTIFYRV2		0x00080000   
+#define 	EN_LmNOTIFYRV1		0x00040000  
+#define 	EN_LmNOTIFYRV0		0x00020000 
+#define 	EN_LmNOTIFYSPIN		0x00010000
+#define 	EN_LmBROADRV4		0x00008000   
+#define 	EN_LmBROADRV3		0x00004000  
+#define 	EN_LmBROADRV2		0x00002000 
+#define 	EN_LmBROADRV1		0x00001000   
+#define 	EN_LmBROADRV0		0x00000800  
+#define 	EN_LmBROADRVCH1		0x00000400 
+#define 	EN_LmBROADRVCH0		0x00000200  
+#define 	EN_LmBROADCH		0x00000100   
+#define 	EN_LmAIPRVWP		0x00000080  
+#define 	EN_LmAIPWP		0x00000040   
+#define 	EN_LmAIPWD		0x00000020   
+#define 	EN_LmAIPWC		0x00000010  
+#define 	EN_LmAIPRV2		0x00000008  
+#define 	EN_LmAIPRV1		0x00000004   
+#define 	EN_LmAIPRV0		0x00000002  
+#define 	EN_LmAIPNRML		0x00000001 
+
+#ifdef SEQUENCER_UPDATE
+#define		LmPRMSTAT0EN_MASK	(EN_LmBREAK | \
+					 EN_LmDONE | EN_LmOPENACPT | \
+					 EN_LmOPENRJCT | EN_LmOPENRTRY | \
+					 EN_LmCLOSERV1 | EN_LmCLOSERV0 | \
+					 EN_LmCLOSENORM | EN_LmCLOSECLAF | \
+					 EN_LmBROADRV4 | EN_LmBROADRV3 | \
+					 EN_LmBROADRV2 | EN_LmBROADRV1 | \
+					 EN_LmBROADRV0 | EN_LmBROADRVCH1 | \
+					 EN_LmBROADRVCH0 | EN_LmBROADCH | \
+					 EN_LmAIPRVWP | EN_LmAIPWP | \
+					 EN_LmAIPWD | EN_LmAIPWC | \
+					 EN_LmAIPRV2 | EN_LmAIPRV1 | \
+					 EN_LmAIPRV0 | EN_LmAIPNRML)
+#else
+#define		LmPRMSTAT0EN_MASK	(EN_LmUNKNOWNP | EN_LmBREAK | \
+					 EN_LmDONE | EN_LmOPENACPT | \
+					 EN_LmOPENRJCT | EN_LmOPENRTRY | \
+					 EN_LmCLOSERV1 | EN_LmCLOSERV0 | \
+					 EN_LmCLOSENORM | EN_LmCLOSECLAF | \
+					 EN_LmBROADRV4 | EN_LmBROADRV3 | \
+					 EN_LmBROADRV2 | EN_LmBROADRV1 | \
+					 EN_LmBROADRV0 | EN_LmBROADRVCH1 | \
+					 EN_LmBROADRVCH0 | EN_LmBROADCH | \
+					 EN_LmAIPRVWP | EN_LmAIPWP | \
+					 EN_LmAIPWD | EN_LmAIPWC | \
+					 EN_LmAIPRV2 | EN_LmAIPRV1 | \
+					 EN_LmAIPRV0 | EN_LmAIPNRML)
+#endif
+
+#define LmPRMSTAT1EN(LinkNum) 		LmSEQ_PHY_REG(0, LinkNum, 0xE4)        
+
+#define		EN_LmXRDY		0x00040000   
+#define		EN_LmSYNCSRST		0x00020000  
+#define		EN_LmSYNC		0x00010000 
+#define 	EN_LmXHOLD		0x00008000
+#define 	EN_LmRRDY		0x00004000   
+#define 	EN_LmHOLD		0x00002000  
+#define 	EN_LmROK		0x00001000 
+#define 	EN_LmRIP		0x00000800
+#define 	EN_LmCRBLK		0x00000400   
+#define 	EN_LmACK		0x00000200  
+#define 	EN_LmNAK		0x00000100 
+#define 	EN_LmHARDRST		0x00000080
+#define 	EN_LmERROR		0x00000040   
+#define 	EN_LmRERR		0x00000020  
+#define 	EN_LmPMREQP		0x00000010 
+#define 	EN_LmPMREQS		0x00000008
+#define 	EN_LmPMACK		0x00000004   
+#define 	EN_LmPMNAK		0x00000002  
+#define 	EN_LmDMAT		0x00000001 
+
+#ifdef SEQUENCER_UPDATE
+#define LmPRMSTAT1EN_MASK		(EN_LmHARDRST | \
+					 EN_LmSYNCSRST | \
+					 EN_LmPMREQP | EN_LmPMREQS | \
+					 EN_LmPMACK | EN_LmPMNAK)
+#else
+#define LmPRMSTAT1EN_MASK		(EN_LmHARDRST | \
+					 EN_LmDMAT | EN_LmSYNCSRST | \
+					 EN_LmPMREQP | EN_LmPMREQS | \
+					 EN_LmPMACK | EN_LmPMNAK)
+#endif
+
+#define LmSMSTATE(LinkNum) 		LmSEQ_PHY_REG(0, LinkNum, 0xE8)        
+
+#define LmSMSTATEBRK(LinkNum) 		LmSEQ_PHY_REG(0, LinkNum, 0xEC)        
+
+#define LmSMDBGCTL(LinkNum) 		LmSEQ_PHY_REG(0, LinkNum, 0xF0)        
+
+
+/* 
+ * LmSEQ CIO Bus Mode 3 Register.
+ * Mode 3: Configuration and Setup, IOP Context SCB.	 
+ */
+#define LmM3SATATIMER(LinkNum) 		LmSEQ_PHY_REG(3, LinkNum, 0x48)
+ 
+#define LmM3INTVEC0(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0x90)
+
+#define LmM3INTVEC1(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0x92)
+
+#define LmM3INTVEC2(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0x94)
+
+#define LmM3INTVEC3(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0x96)
+
+#define LmM3INTVEC4(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0x98)
+
+#define LmM3INTVEC5(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0x9A)
+
+#define LmM3INTVEC6(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0x9C)
+
+#define LmM3INTVEC7(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0x9E)
+                          
+#define LmM3INTVEC8(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0xA4)
+
+#define LmM3INTVEC9(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0xA6)
+
+#define LmM3INTVEC10(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0xB0)
+
+#define LmM3FRMGAP(LinkNum)		LmSEQ_PHY_REG(3, LinkNum, 0xB4)
+
+#define LmBITL_TIMER(LinkNum) 		LmSEQ_PHY_REG(0, LinkNum, 0xA2)
+
+#define LmWWN(LinkNum) 			LmSEQ_PHY_REG(0, LinkNum, 0xA8)
+
+
+/* 
+ * LmSEQ CIO Bus Mode 5 Registers.
+ * Mode 5: Phy/OOB Control and Status.	 
+ */
+#define LmSEQ_OOB_REG(phy_id, reg)	LmSEQ_PHY_REG(5, (phy_id), (reg))
+
+#define OOB_BFLTR	0x100
+
+#define		BFLTR_THR_MASK		0xF0       
+#define		BFLTR_TC_MASK		0x0F
+
+#define OOB_INIT_MIN	0x102
+
+#define OOB_INIT_MAX	0x104
+
+#define OOB_INIT_NEG	0x106
+
+#define	OOB_SAS_MIN	0x108
+
+#define OOB_SAS_MAX	0x10A
+
+#define OOB_SAS_NEG	0x10C
+
+#define OOB_WAKE_MIN	0x10E
+
+#define OOB_WAKE_MAX	0x110
+
+#define OOB_WAKE_NEG	0x112
+
+#define OOB_IDLE_MAX	0x114
+
+#define OOB_BURST_MAX	0x116
+
+#define OOB_DATA_KBITS	0x126
+
+#define OOB_ALIGN_0_DATA	0x12C
+
+#define OOB_ALIGN_1_DATA	0x130
+
+#define D10_2_DATA_k		0x00
+#define SYNC_DATA_k		0x02
+#define ALIGN_1_DATA_k		0x04
+#define ALIGN_0_DATA_k		0x08
+#define BURST_DATA_k		0x10
+
+#define OOB_PHY_RESET_COUNT	0x13C
+
+#define OOB_SIG_GEN	0x140
+
+#define		START_OOB		0x80
+#define		START_DWS		0x40
+#define		ALIGN_CNT3		0x30
+#define 	ALIGN_CNT2		0x20
+#define 	ALIGN_CNT1		0x10
+#define 	ALIGN_CNT4		0x00
+#define		STOP_DWS		0x08
+#define		SEND_COMSAS		0x04
+#define		SEND_COMINIT		0x02
+#define		SEND_COMWAKE		0x01
+
+#define OOB_XMIT	0x141
+
+#define		TX_ENABLE		0x80
+#define		XMIT_OOB_BURST		0x10
+#define		XMIT_D10_2		0x08
+#define		XMIT_SYNC		0x04
+#define		XMIT_ALIGN_1		0x02
+#define		XMIT_ALIGN_0		0x01
+
+#define FUNCTION_MASK	0x142
+
+#define		SAS_MODE_DIS		0x80
+#define		SATA_MODE_DIS		0x40
+#define		SPINUP_HOLD_DIS		0x20
+#define		HOT_PLUG_DIS		0x10
+#define		SATA_PS_DIS		0x08
+#define		FUNCTION_MASK_DEFAULT	(SPINUP_HOLD_DIS | SATA_PS_DIS)
+
+#define OOB_MODE	0x143
+
+#define		SAS_MODE		0x80
+#define		SATA_MODE		0x40
+#define		SLOW_CLK		0x20
+#define		FORCE_XMIT_15		0x08
+#define		PHY_SPEED_60		0x04
+#define		PHY_SPEED_30		0x02
+#define		PHY_SPEED_15		0x01
+
+#define	CURRENT_STATUS	0x144
+
+#define		CURRENT_OOB_DONE	0x80
+#define		CURRENT_LOSS_OF_SIGNAL	0x40
+#define		CURRENT_SPINUP_HOLD	0x20
+#define		CURRENT_HOT_PLUG_CNCT	0x10
+#define		CURRENT_GTO_TIMEOUT	0x08
+#define		CURRENT_OOB_TIMEOUT	0x04
+#define		CURRENT_DEVICE_PRESENT	0x02
+#define		CURRENT_OOB_ERROR	0x01
+
+#define 	CURRENT_OOB1_ERROR	(CURRENT_HOT_PLUG_CNCT | \
+					 CURRENT_GTO_TIMEOUT)
+
+#define 	CURRENT_OOB2_ERROR	(CURRENT_HOT_PLUG_CNCT | \
+					 CURRENT_OOB_ERROR)
+
+#define		DEVICE_ADDED_W_CNT	(CURRENT_OOB_DONE | \
+					 CURRENT_HOT_PLUG_CNCT | \
+					 CURRENT_DEVICE_PRESENT)
+					 
+#define		DEVICE_ADDED_WO_CNT	(CURRENT_OOB_DONE | \
+					 CURRENT_DEVICE_PRESENT)
+					 
+#define 	DEVICE_REMOVED		CURRENT_LOSS_OF_SIGNAL
+
+#define		CURRENT_PHY_MASK	(CURRENT_OOB_DONE | \
+					 CURRENT_LOSS_OF_SIGNAL | \
+					 CURRENT_SPINUP_HOLD | \
+					 CURRENT_HOT_PLUG_CNCT | \
+					 CURRENT_GTO_TIMEOUT | \
+					 CURRENT_DEVICE_PRESENT | \
+					 CURRENT_OOB_ERROR )
+					
+#define		CURRENT_ERR_MASK	(CURRENT_LOSS_OF_SIGNAL | \
+					 CURRENT_GTO_TIMEOUT | \
+					 CURRENT_OOB_TIMEOUT | \
+					 CURRENT_OOB_ERROR )
+					 
+#define SPEED_MASK	0x145
+
+#define		SATA_SPEED_30_DIS	0x10   
+#define		SATA_SPEED_15_DIS	0x08 
+#define		SAS_SPEED_60_DIS	0x04
+#define		SAS_SPEED_30_DIS	0x02
+#define		SAS_SPEED_15_DIS	0x01
+#define		SAS_SPEED_MASK_DEFAULT	0x00
+
+#define OOB_TIMER_ENABLE	0x14D
+
+#define		HOT_PLUG_EN		0x80
+#define		RCD_EN			0x40  
+#define 	COMTIMER_EN		0x20  
+#define		SNTT_EN			0x10 
+#define		SNLT_EN			0x04 
+#define		SNWT_EN			0x02 
+#define		ALIGN_EN		0x01 
+
+#define OOB_STATUS		0x14E
+
+#define		OOB_DONE		0x80
+#define		LOSS_OF_SIGNAL		0x40		/* ro */		
+#define		SPINUP_HOLD		0x20
+#define		HOT_PLUG_CNCT		0x10		/* ro */
+#define		GTO_TIMEOUT		0x08		/* ro */
+#define		OOB_TIMEOUT		0x04		/* ro */		
+#define		DEVICE_PRESENT		0x02		/* ro */
+#define		OOB_ERROR		0x01		/* ro */
+
+#define		OOB_STATUS_ERROR_MASK	(LOSS_OF_SIGNAL | GTO_TIMEOUT | \
+					 OOB_TIMEOUT | OOB_ERROR)
+				
+#define OOB_STATUS_CLEAR	0x14F
+
+#define		OOB_DONE_CLR		0x80
+#define		LOSS_OF_SIGNAL_CLR 	0x40	
+#define		SPINUP_HOLD_CLR		0x20
+#define		HOT_PLUG_CNCT_CLR     	0x10
+#define		GTO_TIMEOUT_CLR		0x08
+#define		OOB_TIMEOUT_CLR		0x04		
+#define		OOB_ERROR_CLR		0x01
+
+#define HOT_PLUG_DELAY		0x150
+
+#define	HOTPLUG_DEFAULT_DELAY		20
+
+
+#define INT_ENABLE_2		0x15A
+
+#define		OOB_DONE_EN		0x80
+#define		LOSS_OF_SIGNAL_EN	0x40	
+#define		SPINUP_HOLD_EN		0x20
+#define		HOT_PLUG_CNCT_EN	0x10
+#define		GTO_TIMEOUT_EN		0x08
+#define		OOB_TIMEOUT_EN		0x04
+#define		DEVICE_PRESENT_EN	0x02
+#define		OOB_ERROR_EN		0x01
+
+#define PHY_CONTROL_0		0x160
+
+#define		PHY_LOWPWREN_TX		0x80
+#define		PHY_LOWPWREN_RX		0x40
+#define		SPARE_REG_160_B5	0x20
+#define		OFFSET_CANCEL_RX	0x10
+
+/* bits 3:2 */
+#define		PHY_RXCOMCENTER_60V	0x00
+#define		PHY_RXCOMCENTER_70V	0x04
+#define		PHY_RXCOMCENTER_80V	0x08
+#define		PHY_RXCOMCENTER_90V	0x0C
+#define 	PHY_RXCOMCENTER_MASK	0x0C
+
+#define		PHY_RESET		0x02
+#define		SAS_DEFAULT_SEL		0x01
+ 
+#define PHY_CONTROL_1		0x161
+
+/* bits 2:0 */
+#define		SATA_PHY_DETLEVEL_50mv	0x00
+#define		SATA_PHY_DETLEVEL_75mv	0x01
+#define		SATA_PHY_DETLEVEL_100mv	0x02
+#define		SATA_PHY_DETLEVEL_125mv	0x03
+#define		SATA_PHY_DETLEVEL_150mv	0x04
+#define		SATA_PHY_DETLEVEL_175mv	0x05
+#define		SATA_PHY_DETLEVEL_200mv	0x06
+#define		SATA_PHY_DETLEVEL_225mv	0x07
+#define		SATA_PHY_DETLEVEL_MASK	0x07
+
+/* bits 5:3 */
+#define		SAS_PHY_DETLEVEL_50mv	0x00
+#define		SAS_PHY_DETLEVEL_75mv	0x08
+#define		SAS_PHY_DETLEVEL_100mv	0x10
+#define		SAS_PHY_DETLEVEL_125mv	0x11
+#define		SAS_PHY_DETLEVEL_150mv	0x20
+#define		SAS_PHY_DETLEVEL_175mv	0x21
+#define		SAS_PHY_DETLEVEL_200mv	0x30
+#define		SAS_PHY_DETLEVEL_225mv	0x31
+#define		SAS_PHY_DETLEVEL_MASK	0x38
+
+#define PHY_CONTROL_2		0x162
+
+/* bits 7:5 */
+#define 	SATA_PHY_DRV_400mv	0x00
+#define 	SATA_PHY_DRV_450mv	0x20
+#define 	SATA_PHY_DRV_500mv	0x40
+#define 	SATA_PHY_DRV_550mv	0x60
+#define 	SATA_PHY_DRV_600mv	0x80
+#define 	SATA_PHY_DRV_650mv	0xA0
+#define 	SATA_PHY_DRV_725mv	0xC0
+#define 	SATA_PHY_DRV_800mv	0xE0
+#define		SATA_PHY_DRV_MASK	0xE0
+
+/* bits 4:3 */
+#define 	SATA_PREEMP_0		0x00
+#define 	SATA_PREEMP_1		0x08
+#define 	SATA_PREEMP_2		0x10
+#define 	SATA_PREEMP_3		0x18
+#define 	SATA_PREEMP_MASK	0x18
+
+#define 	SATA_CMSH1P5		0x04
+
+/* bits 1:0 */
+#define 	SATA_SLEW_0		0x00
+#define 	SATA_SLEW_1		0x01
+#define 	SATA_SLEW_2		0x02
+#define 	SATA_SLEW_3		0x03
+#define 	SATA_SLEW_MASK		0x03
+
+#define PHY_CONTROL_3		0x163
+
+/* bits 7:5 */
+#define 	SAS_PHY_DRV_400mv	0x00
+#define 	SAS_PHY_DRV_450mv	0x20
+#define 	SAS_PHY_DRV_500mv	0x40
+#define 	SAS_PHY_DRV_550mv	0x60
+#define 	SAS_PHY_DRV_600mv	0x80
+#define 	SAS_PHY_DRV_650mv	0xA0
+#define 	SAS_PHY_DRV_725mv	0xC0
+#define 	SAS_PHY_DRV_800mv	0xE0
+#define		SAS_PHY_DRV_MASK	0xE0
+
+/* bits 4:3 */
+#define 	SAS_PREEMP_0		0x00
+#define 	SAS_PREEMP_1		0x08
+#define 	SAS_PREEMP_2		0x10
+#define 	SAS_PREEMP_3		0x18
+#define 	SAS_PREEMP_MASK		0x18
+
+#define 	SAS_CMSH1P5		0x04
+
+/* bits 1:0 */
+#define 	SAS_SLEW_0		0x00
+#define 	SAS_SLEW_1		0x01
+#define 	SAS_SLEW_2		0x02
+#define 	SAS_SLEW_3		0x03
+#define 	SAS_SLEW_MASK		0x03
+
+#define PHY_CONTROL_4		0x168
+
+#define		PHY_DONE_CAL_TX		0x80
+#define		PHY_DONE_CAL_RX		0x40
+#define		RX_TERM_LOAD_DIS	0x20
+#define		TX_TERM_LOAD_DIS	0x10
+#define		AUTO_TERM_CAL_DIS	0x08
+#define		PHY_SIGDET_FLTR_EN	0x04
+#define		OSC_FREQ		0x02
+#define		PHY_START_CAL		0x01
+
+/* 
+ * HST_PCIX2 Registers, Addresss Range: (0x00-0xFC)
+ */
+#define PCIX_REG_BASE_ADR		0xB8040000
+
+#define PCIC_VENDOR_ID	0x00
+
+#define PCIC_DEVICE_ID	0x02
+
+#define PCIC_COMMAND	0x04
+
+#define		INT_DIS			0x0400
+#define		FBB_EN			0x0200		/* ro */
+#define		SERR_EN			0x0100
+#define		STEP_EN			0x0080		/* ro */
+#define		PERR_EN			0x0040
+#define		VGA_EN			0x0020		/* ro */
+#define		MWI_EN			0x0010
+#define		SPC_EN			0x0008
+#define		MST_EN			0x0004
+#define		MEM_EN			0x0002
+#define		IO_EN			0x0001
+
+#define	PCIC_STATUS	0x06
+
+#define		PERR_DET		0x8000
+#define		SERR_GEN		0x4000
+#define		MABT_DET		0x2000
+#define		TABT_DET		0x1000
+#define		TABT_GEN		0x0800
+#define		DPERR_DET		0x0100
+#define		CAP_LIST		0x0010
+#define		INT_STAT		0x0008
+
+#define	PCIC_DEVREV_ID	0x08
+
+#define	PCIC_CLASS_CODE	0x09
+
+#define	PCIC_CACHELINE_SIZE	0x0C
+				
+#define	PCIC_MBAR0	0x10
+
+#define 	PCIC_MBAR0_OFFSET	0
+
+#define	PCIC_MBAR1	0x18
+
+#define 	PCIC_MBAR1_OFFSET	2
+
+#define	PCIC_IOBAR	0x20
+
+#define 	PCIC_IOBAR_OFFSET	4
+
+#define	PCIC_SUBVENDOR_ID	0x2C
+
+#define PCIC_SUBSYTEM_ID	0x2E
+
+#define PCIC_PM_CSR		0x5C
+
+#define		PWR_STATE_D0		0			
+#define		PWR_STATE_D1		1	/* not supported */
+#define		PWR_STATE_D2		2 	/* not supported */
+#define		PWR_STATE_D3		3
+			
+#define PCIC_BASE1	0x6C	/* internal use only */
+
+#define		BASE1_RSVD		0xFFFFFFF8
+
+#define PCIC_BASEA	0x70	/* internal use only */
+
+#define		BASEA_RSVD		0xFFFFFFC0
+#define 	BASEA_START		0x0
+
+#define PCIC_BASEB	0x74	/* internal use only */
+
+#define		BASEB_RSVD		0xFFFFFF80
+#define		BASEB_IOMAP_MASK	0x7F
+#define 	BASEB_START		0x80
+
+#define PCIC_BASEC	0x78	/* internal use only */
+
+#define		BASEC_RSVD		0xFFFFFFFC
+#define 	BASEC_MASK		0x03
+#define 	BASEC_START		0x58
+
+#define PCIC_MBAR_KEY	0x7C	/* internal use only */
+
+#define 	MBAR_KEY_MASK		0xFFFFFFFF
+
+#define PCIC_HSTPCIX_CNTRL	0xA0
+
+#define 	REWIND_DIS		0x00000800
+#define		SC_TMR_DIS		0x04000000
+
+#define PCIC_MBAR0_MASK	0xA8
+#define		PCIC_MBAR0_SIZE_MASK 	0x1FFFE000
+#define		PCIC_MBAR0_SIZE_SHIFT 	13
+#define		PCIC_MBAR0_SIZE(val)	\
+		    (((val) & PCIC_MBAR0_SIZE_MASK) >> PCIC_MBAR0_SIZE_SHIFT)
+
+#define PCIC_FLASH_MBAR	0xB8
+
+#define PCIC_INTRPT_STAT 0xD4
+
+#define PCIC_TP_CTRL	0xFC
+
+/* 
+ * EXSI Registers, Addresss Range: (0x00-0xFC)
+ */
+#define EXSI_REG_BASE_ADR		0xB8042800
+
+#define	EXSICNFGR	0x00     
+#define     OCMINITIALIZED	0x80000000     /* OCM Initialized             */
+
+#define		ASIEN			0x00400000  
+#define		HCMODE			0x00200000 
+#define		PCIDEF			0x00100000    
+#define		COMSTOCK		0x00080000   
+#define		SEEPROMEND		0x00040000  
+#define		MSTTIMEN		0x00020000 
+#define		XREGEX			0x00000200
+#define		NVRAMW			0x00000100     
+#define		NVRAMEX			0x00000080    
+#define		SRAMW			0x00000040   
+#define		SRAMEX			0x00000020  
+#define		FLASHW			0x00000010 
+#define		FLASHEX			0x00000008
+#define		SEEPROMCFG		0x00000004     
+#define		SEEPROMTYP		0x00000002    
+#define		SEEPROMEX		0x00000001   
+
+
+#define EXSICNTRLR	0x04
+                                      
+#define		MODINT_EN		0x00000001     
+
+
+#define PMSTATR		0x10     
+                                       
+#define		FLASHRST		0x00000002  
+#define		FLASHRDY		0x00000001 
+
+
+#define FLCNFGR		0x14     
+                                       
+#define		FLWEH_MASK		0x30000000  
+#define		FLWESU_MASK		0x0C000000 
+#define		FLWEPW_MASK		0x03F00000
+#define		FLOEH_MASK		0x000C0000     
+#define 	FLOESU_MASK		0x00030000    
+#define 	FLOEPW_MASK		0x0000FC00   
+#define 	FLCSH_MASK		0x00000300  
+#define 	FLCSSU_MASK		0x000000C0 
+#define 	FLCSPW_MASK		0x0000003F
+
+#define SRCNFGR		0x18     
+                                       
+#define		SRWEH_MASK		0x30000000  
+#define		SRWESU_MASK		0x0C000000 
+#define		SRWEPW_MASK		0x03F00000
+
+#define		SROEH_MASK		0x000C0000     
+#define 	SROESU_MASK		0x00030000    
+#define 	SROEPW_MASK		0x0000FC00   
+#define		SRCSH_MASK		0x00000300  
+#define		SRCSSU_MASK		0x000000C0 
+#define		SRCSPW_MASK		0x0000003F
+
+#define NVCNFGR		0x1C     
+                                   
+#define 	NVWEH_MASK		0x30000000    
+#define 	NVWESU_MASK		0x0C000000   
+#define 	NVWEPW_MASK		0x03F00000  
+#define 	NVOEH_MASK		0x000C0000    
+#define 	NVOESU_MASK		0x00030000   
+#define 	NVOEPW_MASK		0x0000FC00  
+#define 	NVCSH_MASK		0x00000300   
+#define 	NVCSSU_MASK		0x000000C0  
+#define 	NVCSPW_MASK		0x0000003F 
+
+#define XRCNFGR		0x20     
+                                    
+#define 	XRWEH_MASK		0x30000000     
+#define 	XRWESU_MASK		0x0C000000    
+#define 	XRWEPW_MASK		0x03F00000   
+#define 	XROEH_MASK		0x000C0000  
+#define 	XROESU_MASK		0x00030000 
+#define 	XROEPW_MASK		0x0000FC00
+#define 	XRCSH_MASK		0x00000300    
+#define 	XRCSSU_MASK		0x000000C0   
+#define		XRCSPW_MASK		0x0000003F  
+
+#define XREGADDR	0x24     
+                                     
+#define 	XRADDRINCEN		0x80000000    
+#define 	XREGADD_MASK		0x007FFFFF   
+
+
+#define XREGDATAR	0x28     
+                                      
+#define		XREGDATA_MASK 		0x0000FFFF    
+
+#define GPIOOER		0x40     
+                                       
+#define GPIOODENR	0x44     
+                                      
+#define GPIOINVR	0x48     
+
+#define GPIODATAOR	0x4C     
+
+#define GPIODATAIR	0x50     
+
+#define GPIOCNFGR	0x54     
+
+#define		GPIO_EXTSRC		0x00000001    
+
+#define SCNTRLR		0xA0     
+    
+#define 	SXFERDONE		0x00000100 
+#define 	SXFERCNT_MASK		0x000000E0
+#define 	SCMDTYP_MASK		0x0000001C     
+#define 	SXFERSTART		0x00000002    
+#define 	SXFEREN			0x00000001
+
+#define	SRATER		0xA4
+
+#define	SADDRR		0xA8
+
+#define 	SADDR_MASK		0x0000FFFF
+
+#define SDATAOR		0xAC
+
+#define	SDATAOR0	0xAC
+#define SDATAOR1	0xAD
+#define SDATAOR2	0xAE
+#define SDATAOR3	0xAF
+
+#define SDATAIR		0xB0
+
+#define SDATAIR0	0xB0
+#define SDATAIR1	0xB1
+#define SDATAIR2	0xB2
+#define SDATAIR3	0xB3
+
+/* 
+ * NVRAM Registers, Address Range: (0x00000 - 0x3FFFF).
+ */
+#define NVRAM_REG_BASE_ADR		0xBF800000
+
+#define NVRAM_MAX_BASE_ADR		0x003FFFFF
+
+/* OCM base address */
+#define OCM_BASE_ADDR			0xA0000000
+#define OCM_MAX_SIZE			0x20000
+
+/* 
+ * Sequencers (Central and Link) Scratch RAM page definitions.
+ */ 
+
+/*
+ * Central Management Sequencer scratch RAM is 1024 bytes. 
+ * This scratch memory is divided into mode dependent and mode
+ * independent scratch with this memory further subdivided into
+ * pages of size 32 bytes. There are 5 pages (160 bytes) of
+ * mode independent scratch and 3 pages of dependent scratch 
+ * memory for modes 0-7 (768 bytes). Mode 8 pages 0-2 dependent
+ * scratch overlap with pages 0-2 of mode independent scratch memory.
+ *
+ * The host accesses this scratch in a different manner from the 
+ * central sequencer. The sequencer has to use CSEQ registers
+ * CSCRPAGE and CMnSCRPAGE to access the scratch memory. A flat
+ * mapping of the scratch memory is avaliable for software
+ * convenience and to prevent corruption while the sequencer is
+ * running. This memory is mapped onto addresses 800h - FFFh. 
+ *  
+ * These addresses are mapped as follows:
+ *
+ *        800h-83Fh   Mode Dependent Scratch Mode 0 Pages 0-1
+ *        840h-87Fh   Mode Dependent Scratch Mode 1 Pages 0-1
+ *        880h-8BFh   Mode Dependent Scratch Mode 2 Pages 0-1
+ *        8C0h-8FFh   Mode Dependent Scratch Mode 3 Pages 0-1
+ *        900h-93Fh   Mode Dependent Scratch Mode 4 Pages 0-1
+ *        940h-97Fh   Mode Dependent Scratch Mode 5 Pages 0-1
+ *        980h-9BFh   Mode Dependent Scratch Mode 6 Pages 0-1
+ *        9C0h-9FFh   Mode Dependent Scratch Mode 7 Pages 0-1
+ *        A00h-A5Fh   Mode Dependent Scratch Mode 8 Pages 0-2
+ *        A00h-A5Fh   Mode Independent Scratch Pages 0-2
+ *        A80h-AFFh   Mode Independent Scratch Pages 4-7
+ *        B00h-B1Fh   Mode Dependent Scratch Mode 0 Page 2
+ *        B20h-B3Fh   Mode Dependent Scratch Mode 1 Page 2
+ *        B40h-B5Fh   Mode Dependent Scratch Mode 2 Page 2
+ *        B60h-B7Fh   Mode Dependent Scratch Mode 3 Page 2
+ *        B80h-B9Fh   Mode Dependent Scratch Mode 4 Page 2
+ *        BA0h-BBFh   Mode Dependent Scratch Mode 5 Page 2
+ *        BC0h-BDFh   Mode Dependent Scratch Mode 6 Page 2
+ *        BE0h-BFFh   Mode Dependent Scratch Mode 7 Page 2
+ */
+
+/* General defines */
+#define CSEQ_PAGE_SIZE			32  /* Scratch page size (in bytes) */
+  
+/* All defines start with offsets from 0x800 (CMAPPEDSCR) */
+/* Mode Dependent Scratch page 0 Modes 0-7 definitions. */
+#define CSEQ_LRM_SAVE_SINDEX		(CMAPPEDSCR + 0x0000) 
+#define CSEQ_LRM_SAVE_SCBPTR		(CMAPPEDSCR + 0x0002) 
+#define CSEQ_Q_LINK_HEAD		(CMAPPEDSCR + 0x0004)
+#define CSEQ_Q_LINK_TAIL		(CMAPPEDSCR + 0x0006)
+#ifdef SEQUENCER_UPDATE
+#define CSEQ_LRM_SAVE_SCRPAGE		(CMAPPEDSCR + 0x0008)
+#endif
+
+/* Mode Dependent Scratch page 0 Mode 8 defines */
+#define CSEQ_RET_ADDR			(CMAPPEDSCR + 0x0200) 
+#define CSEQ_RET_SCBPTR			(CMAPPEDSCR + 0x0202)
+#define CSEQ_SAVE_SCBPTR		(CMAPPEDSCR + 0x0204)
+#define CSEQ_EMPTY_TRANS_CTX		(CMAPPEDSCR + 0x0206)
+#define CSEQ_RESP_LEN			(CMAPPEDSCR + 0x0208)
+#define CSEQ_TMF_SCBPTR			(CMAPPEDSCR + 0x020A)
+#define CSEQ_GLOBAL_PREV_SCB		(CMAPPEDSCR + 0x020C)
+#ifdef SEQUENCER_UPDATE
+#define CSEQ_GLOBAL_HEAD		(CMAPPEDSCR + 0x020E)
+#define CSEQ_CLEAR_LU_HEAD		(CMAPPEDSCR + 0x0210)
+#define CSEQ_TMF_OPCODE			(CMAPPEDSCR + 0x0212)
+#define CSEQ_SCRATCH_FLAGS		(CMAPPEDSCR + 0x0213)
+#define CSEQ_HSS_SITE			(CMAPPEDSCR + 0x021A)
+#else
+#define CSEQ_GLOBAL_HEAD		(CMAPPEDSCR + 0x020E)
+#define CSEQ_TMF_OPCODE			(CMAPPEDSCR + 0x0210)
+#define CSEQ_CLEAR_LU_HEAD		(CMAPPEDSCR + 0x0212)
+#endif
+#define CSEQ_FIRST_INV_SCB_SITE		(CMAPPEDSCR + 0x021C)
+#define CSEQ_FIRST_INV_DDB_SITE		(CMAPPEDSCR + 0x021E)
+ 
+/* Mode Dependent Scratch page 1 Mode 8 defines */
+#define CSEQ_LUN_TO_CLEAR		(CMAPPEDSCR + 0x0220)
+#ifndef SEQUENCER_UPDATE
+#define CSEQ_LUN_TO_CHECK		(CMAPPEDSCR + 0x0228)
+#endif
+
+/* Mode Dependent Scratch page 2 Mode 8 defines */
+#define CSEQ_Q_NEW_POINTER		(CMAPPEDSCR + 0x0240)
+#define CSEQ_Q_DONE_BASE		(CMAPPEDSCR + 0x0248)
+#define CSEQ_Q_DONE_POINTER		(CMAPPEDSCR + 0x0250) 
+#define CSEQ_Q_DONE_PASS		(CMAPPEDSCR + 0x0254) 
+
+/* Mode Independent Scratch page 4 defines. */
+#define CSEQ_Q_EXE_HEAD			(CMAPPEDSCR + 0x0280)
+#define CSEQ_Q_EXE_TAIL			(CMAPPEDSCR + 0x0282)
+#define CSEQ_Q_DONE_HEAD		(CMAPPEDSCR + 0x0284)
+#define CSEQ_Q_DONE_TAIL		(CMAPPEDSCR + 0x0286)
+#define CSEQ_Q_SEND_HEAD		(CMAPPEDSCR + 0x0288)
+#define CSEQ_Q_SEND_TAIL		(CMAPPEDSCR + 0x028A)
+#define CSEQ_Q_DMA2CHIM_HEAD		(CMAPPEDSCR + 0x028C)
+#define CSEQ_Q_DMA2CHIM_TAIL		(CMAPPEDSCR + 0x028E) 
+#define CSEQ_Q_COPY_HEAD		(CMAPPEDSCR + 0x0290)
+#define CSEQ_Q_COPY_TAIL		(CMAPPEDSCR + 0x0292)
+#define CSEQ_REG0			(CMAPPEDSCR + 0x0294)
+#define CSEQ_REG1			(CMAPPEDSCR + 0x0296)
+#define CSEQ_REG2			(CMAPPEDSCR + 0x0298)
+#define CSEQ_REG3			(CMAPPEDSCR + 0x029A)
+#define CSEQ_LINK_CTL_Q_MAP		(CMAPPEDSCR + 0x029C)
+#ifdef SEQUENCER_UPDATE
+#define CSEQ_MAX_CSEQ_MODE		(CMAPPEDSCR + 0x029D)
+#else
+#define CSEQ_SCRATCH_FLAGS		(CMAPPEDSCR + 0x029F)
+#endif
+
+/* Mode Independent Scratch page 5 defines. */
+#ifdef SEQUENCER_UPDATE
+#define CSEQ_EST_NEXUS_REQ_QUEUE	(CMAPPEDSCR + 0x02A0)
+#define CSEQ_EST_NEXUS_REQ_COUNT	(CMAPPEDSCR + 0x02A8)
+#define CSEQ_EST_NEXUS_HEAD		(CMAPPEDSCR + 0x02B0)
+#define CSEQ_EST_NEXUS_TAIL		(CMAPPEDSCR + 0x02B2)
+#define CSEQ_NEED_EST_NEXUS_SCB		(CMAPPEDSCR + 0x02B4)
+#define CSEQ_EST_NEXUS_REQ_HEAD		(CMAPPEDSCR + 0x02B6)
+#define CSEQ_EST_NEXUS_REQ_TAIL		(CMAPPEDSCR + 0x02B7)
+#define CSEQ_EST_NEXUS_SCB_OFFSET	(CMAPPEDSCR + 0x02B8)
+#else
+#define CSEQ_FREE_SCB_MASK		(CMAPPEDSCR + 0x02B5) 
+#define CSEQ_BUILTIN_FREE_SCB_HEAD	(CMAPPEDSCR + 0x02B6) 
+#define CSEQ_BUILTIN_FREE_SCB_TAIL	(CMAPPEDSCR + 0x02B8) 
+#define CSEQ_EXTNDED_FREE_SCB_HEAD	(CMAPPEDSCR + 0x02BA) 
+#define CSEQ_EXTNDED_FREE_SCB_TAIL	(CMAPPEDSCR + 0x02BC) 
+#endif
+
+/* Mode Independent Scratch page 6 defines. */
+#define CSEQ_INT_ROUT_RET_ADDR0		(CMAPPEDSCR + 0x02C0)
+#define CSEQ_INT_ROUT_RET_ADDR1		(CMAPPEDSCR + 0x02C2)
+#define CSEQ_INT_ROUT_SCBPTR		(CMAPPEDSCR + 0x02C4)
+#define CSEQ_INT_ROUT_MODE		(CMAPPEDSCR + 0x02C6)
+#define CSEQ_ISR_SCRATCH_FLAGS		(CMAPPEDSCR + 0x02C7)
+#define CSEQ_ISR_SAVE_SINDEX		(CMAPPEDSCR + 0x02C8)
+#define CSEQ_ISR_SAVE_DINDEX		(CMAPPEDSCR + 0x02CA)
+#ifndef SEQUENCER_UPDATE
+#define CSEQ_SLS_SAVE_ACCUM		(CMAPPEDSCR + 0x02CC)
+#define CSEQ_SLS_SAVE_SINDEX		(CMAPPEDSCR + 0x02CE)
+#endif
+#ifdef SEQUENCER_UPDATE
+#define CSEQ_Q_MONIRTT_HEAD		(CMAPPEDSCR + 0x02D0)
+#define CSEQ_Q_MONIRTT_TAIL		(CMAPPEDSCR + 0x02D2)
+#define CSEQ_FREE_SCB_MASK		(CMAPPEDSCR + 0x02D5) 
+#define CSEQ_BUILTIN_FREE_SCB_HEAD	(CMAPPEDSCR + 0x02D6) 
+#define CSEQ_BUILTIN_FREE_SCB_TAIL	(CMAPPEDSCR + 0x02D8) 
+#define CSEQ_EXTNDED_FREE_SCB_HEAD	(CMAPPEDSCR + 0x02DA) 
+#define CSEQ_EXTNDED_FREE_SCB_TAIL	(CMAPPEDSCR + 0x02DC) 
+#endif
+
+/* Mode Independent Scratch page 7 defines. */
+#define CSEQ_EMPTY_REQ_QUEUE		(CMAPPEDSCR + 0x02E0)
+#define CSEQ_EMPTY_REQ_COUNT		(CMAPPEDSCR + 0x02E8)
+#define CSEQ_Q_EMPTY_HEAD		(CMAPPEDSCR + 0x02F0)
+#define CSEQ_Q_EMPTY_TAIL		(CMAPPEDSCR + 0x02F2)
+#define CSEQ_NEED_EMPTY_SCB		(CMAPPEDSCR + 0x02F4)
+#define CSEQ_EMPTY_REQ_HEAD		(CMAPPEDSCR + 0x02F6)
+#define CSEQ_EMPTY_REQ_TAIL		(CMAPPEDSCR + 0x02F7)
+#define CSEQ_EMPTY_SCB_OFFSET		(CMAPPEDSCR + 0x02F8)
+#define CSEQ_PRIMITIVE_DATA		(CMAPPEDSCR + 0x02FA)
+#define CSEQ_TIMEOUT_CONSTANT		(CMAPPEDSCR + 0x02FC)
+
+
+/* Sequencer label public defines */
+#if SAS_SEQUENCER_A1
+/* 
+ * CSEQ A1 Interrupt Vector addresses based on Sequencer Alpha_6f.
+ */
+#define CSEQ_INT_VEC0A1			0x0004
+#define CSEQ_INT_VEC1A1			0x0010
+#define CSEQ_INT_VEC2A1			0x0014
+
+#endif /* SAS_SEQUENCER_A1 */
+
+#if SAS_SEQUENCER_B0
+/* 
+ * CSEQ B0 Interrupt Vector addresses based on Sequencer Alpha_6f.
+ */
+#ifdef SEQUENCER_UPDATE
+#define CSEQ_INT_VEC0B0			0x08D4
+#define CSEQ_INT_VEC1B0			0x00E8
+#define CSEQ_INT_VEC2B0			0x00EC
+#else
+#define CSEQ_INT_VEC0B0			0x0004
+#define CSEQ_INT_VEC1B0			0x000C
+#define CSEQ_INT_VEC2B0			0x0010
+#endif
+
+#endif /* SAS_SEQUENCER_B0 */
+
+#define CSEQ_IDLE_LOOP_ENTRY		0x0000
+#define CSEQ_SEQUENCER_PROGRAM		0x0000
+
+
+/***************************************************************************
+* Link m Sequencer scratch RAM is 512 bytes. 
+* This scratch memory is divided into mode dependent and mode
+* independent scratch with this memory further subdivided into
+* pages of size 32 bytes. There are 4 pages (128 bytes) of
+* mode independent scratch and 4 pages of dependent scratch 
+* memory for modes 0-2 (384 bytes).
+*
+* The host accesses this scratch in a different manner from the 
+* link sequencer. The sequencer has to use LSEQ registers
+* LmSCRPAGE and LmMnSCRPAGE to access the scratch memory. A flat
+* mapping of the scratch memory is avaliable for software
+* convenience and to prevent corruption while the sequencer is
+* running. This memory is mapped onto addresses 800h - 9FFh. 
+*  
+* These addresses are mapped as follows:
+*
+*        800h-85Fh   Mode Dependent Scratch Mode 0 Pages 0-2
+*        860h-87Fh   Mode Dependent Scratch Mode 0 Page 3
+*                    Mode Dependent Scratch Mode 5 Page 0 
+*        880h-8DFh   Mode Dependent Scratch Mode 1 Pages 0-2
+*        8E0h-8FFh   Mode Dependent Scratch Mode 1 Page 3
+*                    Mode Dependent Scratch Mode 5 Page 1 
+*        900h-95Fh   Mode Dependent Scratch Mode 2 Pages 0-2
+*        960h-97Fh   Mode Dependent Scratch Mode 2 Page 3
+*                    Mode Dependent Scratch Mode 5 Page 2 
+*        980h-9DFh   Mode Independent Scratch Pages 0-3
+*        9E0h-9FFh   Mode Independent Scratch Page 3
+*                    Mode Dependent Scratch Mode 5 Page 3 
+*
+****************************************************************************/
+/* General defines */
+#define LSEQ_MODE_SCRATCH_SIZE		128 /* Size of scratch RAM per mode */
+#define LSEQ_PAGE_SIZE			32  /* Scratch page size (in bytes) */  
+#define LSEQ_MODE5_PAGE0_OFFSET 	0x60
+ 
+/* Common Mode Dependent Scratch page 0 defines for modes 0,1,2, and 5 */
+/* Indexed using LSEQ_MODE_SCRATCH_SIZE * mode, for modes 0,1,2. */
+#define LmSEQ_RET_ADDR(LinkNum)		(LmSCRATCH(LinkNum) + 0x0000) 
+#define LmSEQ_REG0_MODE(LinkNum)	(LmSCRATCH(LinkNum) + 0x0002)
+#define LmSEQ_MODE_FLAGS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0004)
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_RET_ADDR2(LinkNum)	(LmSCRATCH(LinkNum) + 0x0006)
+#define LmSEQ_RET_ADDR1(LinkNum)	(LmSCRATCH(LinkNum) + 0x0008)
+#endif
+
+/* Mode flag defines (byte 0) */
+#define		SAS_SAVECTX_OCCURRED		0x80      
+#define		SAS_OOBSVC_OCCURRED		0x40     
+#define		SAS_OOB_DEVICE_PRESENT		0x20    
+#define		SAS_CFGHDR_OCCURRED		0x10   
+#define		SAS_RCV_INTS_ARE_DISABLED	0x08  
+#define		SAS_OOB_HOT_PLUG_CNCT		0x04 
+#define		SAS_AWAIT_OPEN_CONNECTION	0x02
+#define		SAS_CFGCMPLT_OCCURRED		0x01
+
+/* Mode flag defines (byte 1) */
+#define		SAS_RLSSCB_OCCURRED		0x80      
+#define		SAS_FORCED_HEADER_MISS		0x40      
+
+#define LmSEQ_RET_ADDR_SAVE(LinkNum)	(LmSCRATCH(LinkNum) + 0x0006)
+#define LmSEQ_RET_ADDR_SAVE2(LinkNum)	(LmSCRATCH(LinkNum) + 0x0008)
+#define LmSEQ_OPCODE_TO_CSEQ(LinkNum)	(LmSCRATCH(LinkNum) + 0x000B)
+#define LmSEQ_DATA_TO_CSEQ(LinkNum)	(LmSCRATCH(LinkNum) + 0x000C)
+
+/* Mode Dependent Scratch page 0 defines for mode 0 (non-common) */
+/* Absolute offsets */
+#define LmSEQ_FIRST_INV_DDB_SITE(LinkNum)	(LmSCRATCH(LinkNum) + 0x000E)
+#define LmSEQ_EMPTY_TRANS_CTX(LinkNum)		(LmSCRATCH(LinkNum) + 0x0010)
+#define LmSEQ_RESP_LEN(LinkNum)			(LmSCRATCH(LinkNum) + 0x0012)
+#define LmSEQ_FIRST_INV_SCB_SITE(LinkNum)	(LmSCRATCH(LinkNum) + 0x0014) 
+#define LmSEQ_INTEN_SAVE(LinkNum)		(LmSCRATCH(LinkNum) + 0x0016)
+#define LmSEQ_LNK_RST_FRM_LEN(LinkNum)		(LmSCRATCH(LinkNum) + 0x001A)
+#define LmSEQ_LNK_RST_PROTOCOL(LinkNum)		(LmSCRATCH(LinkNum) + 0x001B)
+#define LmSEQ_RESP_STATUS(LinkNum)		(LmSCRATCH(LinkNum) + 0x001C)
+#define LmSEQ_LAST_LOADED_SGE(LinkNum)		(LmSCRATCH(LinkNum) + 0x001D)
+#define LmSEQ_SAVE_SCBPTR(LinkNum)		(LmSCRATCH(LinkNum) + 0x001E)
+
+/* Mode Dependent Scratch page 0 defines for mode 1 (non-common) */
+/* Absolute offsets */
+#define LmSEQ_Q_XMIT_HEAD(LinkNum)		(LmSCRATCH(LinkNum) + 0x008E)
+#define LmSEQ_M1_EMPTY_TRANS_CTX(LinkNum)	(LmSCRATCH(LinkNum) + 0x0090)
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_INITIATOR_CONNECTION_TAG(LinkNum)	(LmSCRATCH(LinkNum) + 0x0092)
+#define LmSEQ_FAILED_OPEN_STATUS(LinkNum)	(LmSCRATCH(LinkNum) + 0x009A)
+#endif
+#define LmSEQ_XMIT_REQUEST_TYPE(LinkNum)	(LmSCRATCH(LinkNum) + 0x009B)
+#define LmSEQ_M1_RESP_STATUS(LinkNum)		(LmSCRATCH(LinkNum) + 0x009C)
+#define LmSEQ_M1_LAST_LOADED_SGE(LinkNum)	(LmSCRATCH(LinkNum) + 0x009D)
+#define LmSEQ_M1_SAVE_SCBPTR(LinkNum)		(LmSCRATCH(LinkNum) + 0x009E)
+
+/* Mode Dependent Scratch page 0 defines for mode 2 (non-common) */
+#define LmSEQ_PORT_COUNTER(LinkNum)		(LmSCRATCH(LinkNum) + 0x010E)
+#define LmSEQ_PM_TABLE_PTR(LinkNum)		(LmSCRATCH(LinkNum) + 0x0110)
+#define LmSEQ_SATA_INTERLOCK_TMR_SAVE(LinkNum)	(LmSCRATCH(LinkNum) + 0x0112)
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_IP_BITL(LinkNum)				(LmSCRATCH(LinkNum) + 0x0114)
+#define LmSEQ_COPY_SMP_CONN_TAG(LinkNum)		(LmSCRATCH(LinkNum) + 0x0116)
+#define LmSEQ_P0M2_OFFS1AH(LinkNum)		(LmSCRATCH(LinkNum) + 0x011A)
+#endif
+
+/* Mode Dependent Scratch page 0 defines for modes 4 & 5 (non-common) */
+/* Absolute offsets */
+#define LmSEQ_SAVED_OOB_STATUS(LinkNum)		(LmSCRATCH(LinkNum) + 0x006E)
+#define LmSEQ_SAVED_OOB_MODE(LinkNum)		(LmSCRATCH(LinkNum) + 0x006F)
+#define LmSEQ_Q_LINK_HEAD(LinkNum)		(LmSCRATCH(LinkNum) + 0x0070)
+#define LmSEQ_LNK_RST_ERR(LinkNum)		(LmSCRATCH(LinkNum) + 0x0072)
+#define LmSEQ_SAVED_OOB_SIGNALS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0073)
+#define LmSEQ_SAS_RESET_MODE(LinkNum)		(LmSCRATCH(LinkNum) + 0x0074)
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_LINK_RESET_RETRY_COUNT(LinkNum)	(LmSCRATCH(LinkNum) + 0x0075)
+#define LmSEQ_NUM_LINK_RESET_RETRIES(LinkNum)	(LmSCRATCH(LinkNum) + 0x0076)
+#define LmSEQ_OOB_INT_ENABLES(LinkNum)		(LmSCRATCH(LinkNum) + 0x0078)
+#define LmSEQ_NOTIFY_TIMER_DOWN_COUNT(LinkNum)	(LmSCRATCH(LinkNum) + 0x007A)
+#define LmSEQ_NOTIFY_TIMER_TIMEOUT(LinkNum)	(LmSCRATCH(LinkNum) + 0x007C)
+#define LmSEQ_NOTIFY_TIMER_INITIAL_COUNT(LinkNum) (LmSCRATCH(LinkNum) + 0x007E)
+
+#else
+#define LmSEQ_SAVE_COMINIT_TIMER(LinkNum)	(LmSCRATCH(LinkNum) + 0x007C)
+#endif
+
+/* Mode Dependent Scratch page 1 defines for modes 0,and 1 */
+/* Indexed using LSEQ_MODE_SCRATCH_SIZE * mode. */
+#define LmSEQ_SG0_LIST_PTR_ADDR(LinkNum)	(LmSCRATCH(LinkNum) + 0x0020)
+#define LmSEQ_SG0_LIST_DS(LinkNum)		(LmSCRATCH(LinkNum) + 0x002F)
+#define LmSEQ_SG1_LIST_PTR_ADDR(LinkNum)	(LmSCRATCH(LinkNum) + 0x0030)
+#define LmSEQ_SG1_LIST_DS(LinkNum)		(LmSCRATCH(LinkNum) + 0x003F)
+
+/* Mode Dependent Scratch page 1 defines for mode 2 */
+/* Absolute offsets */
+#define LmSEQ_INVALID_DWORD_CNT(LinkNum)	(LmSCRATCH(LinkNum) + 0x0120)
+#define LmSEQ_DISPARITY_ERROR_CNT(LinkNum) 	(LmSCRATCH(LinkNum) + 0x0124)
+#define LmSEQ_LOSS_OF_SYNC_CNT(LinkNum)		(LmSCRATCH(LinkNum) + 0x0128)
+
+#ifdef SEQUENCER_UPDATE
+/* Mode Dependent Scratch page 1 defines for mode 5 */
+#define LmSEQ_FRAME_TYPE_MASK(LinkNum)		(LmSCRATCH(LinkNum) + 0x00E0)
+#define LmSEQ_HASH_DEST_ADDR_MASK(LinkNum)	(LmSCRATCH(LinkNum) + 0x00E1)
+#define LmSEQ_HASHED_SRC_ADDR_MASK_PRINT(LinkNum) (LmSCRATCH(LinkNum) + 0x00E4)
+#define LmSEQ_HASH_SRC_ADDR_MASK(LinkNum)	(LmSCRATCH(LinkNum) + 0x00E5)
+#define LmSEQ_RETRANS_MASK(LinkNum)		(LmSCRATCH(LinkNum) + 0x00EA)
+#define LmSEQ_NUM_FILL_BYTES_MASK(LinkNum)	(LmSCRATCH(LinkNum) + 0x00EB)
+#define LmSEQ_TAG_MASK(LinkNum)			(LmSCRATCH(LinkNum) + 0x00F0)
+#define LmSEQ_TAG_PORT_TRANSFER_MASK(LinkNum)	(LmSCRATCH(LinkNum) + 0x00F2)
+#define LmSEQ_DATA_OFFSET_MASK(LinkNum)		(LmSCRATCH(LinkNum) + 0x00F4)
+#endif
+
+/* Mode Dependent Scratch page 2 defines for mode 0 */
+/* Absolute offsets */
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_SMP_RCV_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0040)
+#define LmSEQ_DEVICE_BITS(LinkNum)		(LmSCRATCH(LinkNum) + 0x005B)
+#define LmSEQ_SDB_DDB(LinkNum)			(LmSCRATCH(LinkNum) + 0x005C)
+#define LmSEQ_SDB_NUM_TAGS(LinkNum)		(LmSCRATCH(LinkNum) + 0x005E)
+#define LmSEQ_SDB_CURR_TAG(LinkNum)		(LmSCRATCH(LinkNum) + 0x005F)
+#else
+#define LmSEQ_ATTACHED_SAS_ADDR(LinkNum)	(LmSCRATCH(LinkNum) + 0x0040)
+#define LmSEQ_INITR_SAS_ADDR(LinkNum)		(LmSCRATCH(LinkNum) + 0x0048)
+#define LmSEQ_SMP_RCV_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0050)
+#define LmSEQ_M0_LAST_LOADED_SGE(LinkNum)	(LmSCRATCH(LinkNum) + 0x0054)
+#define LmSEQ_SDB_TAG(LinkNum)			(LmSCRATCH(LinkNum) + 0x005B)
+#define LmSEQ_SDB_MASK(LinkNum)			(LmSCRATCH(LinkNum) + 0x005C)
+#define LmSEQ_DEVICE_BITS(LinkNum)		(LmSCRATCH(LinkNum) + 0x005D)
+#define LmSEQ_SDB_DDB(LinkNum)			(LmSCRATCH(LinkNum) + 0x005E)
+#endif
+
+/* Mode Dependent Scratch page 2 defines for mode 1 */
+/* Absolute offsets */
+/* byte 0 bits 1-0 are domain select. */
+#define LmSEQ_TX_ID_ADDR_FRAME(LinkNum)		(LmSCRATCH(LinkNum) + 0x00C0)	
+#define LmSEQ_OPEN_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x00C8) 
+#define LmSEQ_SRST_AS_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x00CC)  
+#define LmSEQ_M1P2_LAST_LOADED_SGE(LinkNum)	(LmSCRATCH(LinkNum) + 0x00D4)
+
+/* Mode Dependent Scratch page 2 defines for mode 2 */
+/* Absolute offsets */
+#define LmSEQ_STP_SHUTDOWN_TIMER_TERM_TS(LinkNum) (LmSCRATCH(LinkNum) + 0x0140)
+#define LmSEQ_CLOSE_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0144) 
+#define LmSEQ_BREAK_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0148) 
+#define LmSEQ_DWS_RESET_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x014C) 
+#define LmSEQ_SATA_INTERLOCK_TIMER_TERM_TS(LinkNum) \
+						(LmSCRATCH(LinkNum) + 0x0150) 
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_MCTL_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0154)
+#endif
+#define LmSEQ_DOWN_TIMER_DOWN_CNT(LinkNum)	(LmSCRATCH(LinkNum) + 0x015F) 
+
+/* Mode Dependent Scratch page 2 defines for mode 5 */
+#define LmSEQ_COMINIT_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0160)
+#define LmSEQ_RCV_ID_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0164)
+#define LmSEQ_RCV_FIS_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0168)
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_DEV_PRES_TIMER_TERM_TS(LinkNum)	(LmSCRATCH(LinkNum) + 0x016C)
+#endif
+
+                                                  
+
+/* Mode Dependent Scratch page 3 defines for modes 0 and 1 */
+/* None defined */
+
+/* Mode Dependent Scratch page 3 defines for modes 2 and 5 */
+/* None defined */
+
+/* Mode Independent Scratch page 0 defines. */
+#define LmSEQ_Q_TGTXFR_HEAD(LinkNum)	(LmSCRATCH(LinkNum) + 0x0180)
+#define LmSEQ_Q_TGTXFR_TAIL(LinkNum)	(LmSCRATCH(LinkNum) + 0x0182)
+#define LmSEQ_LINK_NUMBER(LinkNum)	(LmSCRATCH(LinkNum) + 0x0186)
+#define LmSEQ_SCRATCH_FLAGS(LinkNum)	(LmSCRATCH(LinkNum) + 0x0187)
+/*
+ * Currently only bit 0, SAS_DWSAQD, is used.
+ */
+#define		SAS_DWSAQD			0x01  /*
+						       * DWSSTATUS: DWSAQD
+						       * bit las read in ISR.
+						       */		
+#define		SAS_NOTIFY_SPINUP_ENABLED	0x10     
+
+#define  LmSEQ_CONNECTION_STATE(LinkNum) (LmSCRATCH(LinkNum) + 0x0188)
+/* Connection states (byte 0) */
+#define		SAS_WE_OPENED_CS		0x01     
+#define		SAS_DEVICE_OPENED_CS		0x02
+#define		SAS_WE_SENT_DONE_CS		0x04     
+#define		SAS_DEVICE_SENT_DONE_CS		0x08
+#define		SAS_WE_SENT_CLOSE_CS		0x10     
+#define		SAS_DEVICE_SENT_CLOSE_CS	0x20     
+#define		SAS_WE_SENT_BREAK_CS		0x40    
+#define		SAS_DEVICE_SENT_BREAK_CS	0x80   
+/* Connection states (byte 1) */
+#define		SAS_OPN_TIMEOUT_OR_OPN_RJCT_CS	0x01  
+#define		SAS_AIP_RECEIVED_CS		0x02    
+#define		SAS_CREDIT_TIMEOUT_OCCURRED_CS	0x04
+#define		SAS_ACKNAK_TIMEOUT_OCCURRED_CS	0x08 
+#define		SAS_SMPRSP_TIMEOUT_OCCURRED_CS	0x10 
+#define		SAS_DONE_TIMEOUT_OCCURRED_CS	0x20 
+/* Connection states (byte 2) */
+#define		SAS_SMP_RESPONSE_RECEIVED_CS	0x01    
+#define		SAS_INTLK_TIMEOUT_OCCURRED_CS	0x02 
+#define		SAS_DEVICE_SENT_DMAT_CS		0x04     
+#define		SAS_DEVICE_SENT_SYNCSRST_CS	0x08    
+#define		SAS_CLEARING_AFFILIATION_CS	0x20   
+#define		SAS_RXTASK_ACTIVE_CS		0x40  
+#define		SAS_TXTASK_ACTIVE_CS		0x80 
+/* Connection states (byte 3) */
+#define		SAS_PHY_LOSS_OF_SIGNAL_CS	0x01     
+#define		SAS_DWS_TIMER_EXPIRED_CS	0x02     
+#define		SAS_LINK_RESET_NOT_COMPLETE_CS	0x04 
+#define		SAS_PHY_DISABLED_CS		0x08   
+#define		SAS_LINK_CTL_TASK_ACTIVE_CS	0x10  
+#define		SAS_PHY_EVENT_TASK_ACTIVE_CS	0x20
+#define		SAS_DEVICE_SENT_ID_FRAME_CS	0x40     
+#define		SAS_DEVICE_SENT_REG_FIS_CS	0x40    
+#define		SAS_DEVICE_SENT_HARD_RESET_CS	0x80 
+#define  	SAS_PHY_IS_DOWN_FLAGS		(SAS_PHY_LOSS_OF_SIGNAL_CS | \
+						 SAS_DWS_TIMER_EXPIRED_CS | \
+                                              SAS_LINK_RESET_NOT_COMPLETE_CS | \
+						 SAS_PHY_DISABLED_CS)
+
+#define		SAS_LINK_CTL_PHY_EVENT_FLAGS	(SAS_LINK_CTL_TASK_ACTIVE_CS | \
+						SAS_PHY_EVENT_TASK_ACTIVE_CS | \
+						SAS_DEVICE_SENT_ID_FRAME_CS | \
+						SAS_DEVICE_SENT_HARD_RESET_CS)
+
+#define LmSEQ_CONCTL(LinkNum)		(LmSCRATCH(LinkNum) + 0x018C)
+#define LmSEQ_CONSTAT(LinkNum)		(LmSCRATCH(LinkNum) + 0x018E) 
+#define LmSEQ_CONNECTION_MODES(LinkNum)	(LmSCRATCH(LinkNum) + 0x018F) 
+#define LmSEQ_REG1_ISR(LinkNum)		(LmSCRATCH(LinkNum) + 0x0192)
+#define LmSEQ_REG2_ISR(LinkNum)		(LmSCRATCH(LinkNum) + 0x0194)
+#define LmSEQ_REG3_ISR(LinkNum)		(LmSCRATCH(LinkNum) + 0x0196)
+#define LmSEQ_REG0_ISR(LinkNum)		(LmSCRATCH(LinkNum) + 0x0198)
+
+/* Mode Independent Scratch page 1 defines. */
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_EST_NEXUS_SCB_PTR0(LinkNum)     (LmSCRATCH(LinkNum) + 0x01A0)
+#define LmSEQ_EST_NEXUS_SCB_PTR1(LinkNum)     (LmSCRATCH(LinkNum) + 0x01A2)
+#define LmSEQ_EST_NEXUS_SCB_PTR2(LinkNum)     (LmSCRATCH(LinkNum) + 0x01A4)
+#define LmSEQ_EST_NEXUS_SCB_PTR3(LinkNum)     (LmSCRATCH(LinkNum) + 0x01A6)
+#define LmSEQ_EST_NEXUS_SCB_OPCD0(LinkNum)    (LmSCRATCH(LinkNum) + 0x01A8)
+#define LmSEQ_EST_NEXUS_SCB_OPCD1(LinkNum)    (LmSCRATCH(LinkNum) + 0x01A9)
+#define LmSEQ_EST_NEXUS_SCB_OPCD2(LinkNum)    (LmSCRATCH(LinkNum) + 0x01AA)
+#define LmSEQ_EST_NEXUS_SCB_OPCD3(LinkNum)    (LmSCRATCH(LinkNum) + 0x01AB)
+#define LmSEQ_EST_NEXUS_SCB_HEAD(LinkNum)     (LmSCRATCH(LinkNum) + 0x01AC)
+#define LmSEQ_EST_NEXUS_SCB_TAIL(LinkNum)     (LmSCRATCH(LinkNum) + 0x01AD)
+#define LmSEQ_EST_NEXUS_BUFS_AVAIL(LinkNum)   (LmSCRATCH(LinkNum) + 0x01AE)
+#define LmSEQ_TIMEOUT_CONST(LinkNum)   	      (LmSCRATCH(LinkNum) + 0x01B8)
+#define LmSEQ_ISR_SAVE_SINDEX(LinkNum)	      (LmSCRATCH(LinkNum) + 0x01BC)
+#define LmSEQ_ISR_SAVE_DINDEX(LinkNum)	      (LmSCRATCH(LinkNum) + 0x01BE)
+#else
+#define LmSEQ_FRAME_TYPE_MASK(LinkNum)	      (LmSCRATCH(LinkNum) + 0x01A0)
+#define LmSEQ_HASHED_DEST_ADDR_MASK(LinkNum)  (LmSCRATCH(LinkNum) + 0x01A1)
+#define LmSEQ_HASHED_SRC_ADDR_MASK(LinkNum)   (LmSCRATCH(LinkNum) + 0x01A5)
+#define LmSEQ_RETRANSMIT_MASK(LinkNum)	      (LmSCRATCH(LinkNum) + 0x01AA)
+#define LmSEQ_NUM_FILL_BYTES_MASK(LinkNum)    (LmSCRATCH(LinkNum) + 0x01AB)
+#define LmSEQ_TAG_MASK(LinkNum)		      (LmSCRATCH(LinkNum) + 0x01B0)
+#define LmSEQ_TARGET_PORT_XFER_TAG(LinkNum)   (LmSCRATCH(LinkNum) + 0x01B2)
+#define LmSEQ_DATA_OFFSET(LinkNum)	      (LmSCRATCH(LinkNum) + 0x01B4)
+#define LmSEQ_ISR_SAVE_SINDEX(LinkNum)	      (LmSCRATCH(LinkNum) + 0x01BC)
+#define LmSEQ_ISR_SAVE_DINDEX(LinkNum)	      (LmSCRATCH(LinkNum) + 0x01BE)
+#endif
+
+
+/* Mode Independent Scratch page 2 defines. */
+#define LmSEQ_EMPTY_SCB_PTR0(LinkNum)	(LmSCRATCH(LinkNum) + 0x01C0)
+#define LmSEQ_EMPTY_SCB_PTR1(LinkNum)	(LmSCRATCH(LinkNum) + 0x01C2)
+#define LmSEQ_EMPTY_SCB_PTR2(LinkNum)	(LmSCRATCH(LinkNum) + 0x01C4)
+#define LmSEQ_EMPTY_SCB_PTR3(LinkNum)	(LmSCRATCH(LinkNum) + 0x01C6)
+#define LmSEQ_EMPTY_SCB_OPCD0(LinkNum)	(LmSCRATCH(LinkNum) + 0x01C8)
+#define LmSEQ_EMPTY_SCB_OPCD1(LinkNum)	(LmSCRATCH(LinkNum) + 0x01C9)
+#define LmSEQ_EMPTY_SCB_OPCD2(LinkNum)	(LmSCRATCH(LinkNum) + 0x01CA)
+#define LmSEQ_EMPTY_SCB_OPCD3(LinkNum)	(LmSCRATCH(LinkNum) + 0x01CB)
+#define LmSEQ_EMPTY_SCB_HEAD(LinkNum)	(LmSCRATCH(LinkNum) + 0x01CC)
+#define LmSEQ_EMPTY_SCB_TAIL(LinkNum)	(LmSCRATCH(LinkNum) + 0x01CD)
+#define LmSEQ_EMPTY_BUFS_AVAIL(LinkNum)	(LmSCRATCH(LinkNum) + 0x01CE)
+#define LmSEQ_ATA_SCR_REGS(LinkNum)	(LmSCRATCH(LinkNum) + 0x01D4)
+
+/* 
+ * The current sequencer implementation is to have 1ms timer to come to a 
+ * routine to check if the value inside scratch location 
+ * LSEQ_NOTIFY_TIMER_DOWN_CNT is equal to 0.  
+ * Only If the value in LSEQ_NOTIFY_TIMER_DOWN_CNT is equal to 0, sequencer 
+ * sends NOTIFY (ENABLE SPINUP) out.
+ * The initial value of LSEQ_NOTIFY_TIMER_DOWN_CNT is from CHIM's initialization
+ * value.  After the first NOTIFY (ENABLE SPINUP) sending out, the value
+ * contained in LSEQ_NOTIFY_TIMER_TIMEOUT scratch location is copied to scratch
+ * location LSEQ_NOTIFY_TIMER_DOWN_CNT and used as the constant period between 
+ * each following NOTIFY (ENABLE SPINUP) sending out.
+ * With this implementation, the actual period is the value set in 
+ * scratch ram + 1.  
+ */
+
+/* Set NOTIFY Timer Down Counter to value 0 gets 1msec for the first   */
+/* NOTIFY (ENABLE SPINUP) sending to the drives.                       */
+#define SAS_DEFAULT_NOTIFY_TIMER_DOWN_CNT      	0x0
+#define SAS_DEFAULT_STP_SHUTDOWN_TIMER_TIMEOUT	0x00000032  /* 50 usecs */
+#define SAS_DEFAULT_SRST_ASSERT_TIMEOUT		0x00000005  /* 5 usecs */
+#define SAS_DEFAULT_RCV_FIS_TIMEOUT		0x01D905C0  /* 31 secs */
+#define	SAS_DEFAULT_ONE_MILLISEC_TIMEOUT	0x000003E8  /* 1 msecs */
+
+/*
+ * We are currently seeing an erratic issue with SEAGATE FW:B83C that it takes
+ * much longer to show up during link reset sequence.
+ * Setting 1 secs for the COMMINIT TIMEOUT seems to help.
+ * This is just a temporary workaround. Default value is 10 msesc.
+ */
+//#define SAS_DEFAULT_COMINIT_TIMEOUT		0x00002710  /* 10 msecs */
+#define SAS_DEFAULT_COMINIT_TIMEOUT		0x000F4240  /* 1 secs */
+#define SAS_DEFAULT_SMP_RCV_TIMEOUT		0x000F4240  /* 1 secs */
+
+/* Mode Independent Scratch page 3 defines. */
+#define LmSEQ_DEV_PRES_TMR_TOUT_CONST(LinkNum)	(LmSCRATCH(LinkNum) + 0x01E0)
+#define LmSEQ_NOTIFY_TIMER_DOWN_CNT(LinkNum)	(LmSCRATCH(LinkNum) + 0x01E2)
+#define LmSEQ_SATA_INTERLOCK_TIMEOUT(LinkNum)	(LmSCRATCH(LinkNum) + 0x01E4)
+#ifndef SEQUENCER_UPDATE
+#define LmSEQ_STP_SHUTDOWN_TIMEOUT(LinkNum)	(LmSCRATCH(LinkNum) + 0x01E8)
+#endif
+#define LmSEQ_SRST_ASSERT_TIMEOUT(LinkNum)	(LmSCRATCH(LinkNum) + 0x01EC)
+#define LmSEQ_RCV_FIS_TIMEOUT(LinkNum)		(LmSCRATCH(LinkNum) + 0x01F0)
+#define LmSEQ_ONE_MILLISEC_TIMEOUT(LinkNum)	(LmSCRATCH(LinkNum) + 0x01F4)
+#ifdef SEQUENCER_UPDATE
+#define LmSEQ_TEN_MILLISEC_TIMEOUT(LinkNum)	(LmSCRATCH(LinkNum) + 0x01F8)
+#else
+#define LmSEQ_COMINIT_TIMEOUT(LinkNum)		(LmSCRATCH(LinkNum) + 0x01F8)
+#endif
+#define LmSEQ_SMP_RCV_TIMEOUT(LinkNum)		(LmSCRATCH(LinkNum) + 0x01FC)
+
+/* Sequencer label public defines */
+#if SAS_SEQUENCER_A1
+/* 
+ * LSEQ A1 Interrupt Vector addresses based on Sequencer Alpha_7f.
+ */
+#define LSEQ_INT_VEC0A1			0x001C
+#define LSEQ_INT_VEC1A1			0x0028
+#define LSEQ_INT_VEC2A1			0x0034
+#define LSEQ_INT_VEC3A1			0x0040 
+#define LSEQ_INT_VEC4A1			0x004C
+#define LSEQ_INT_VEC5A1			0x0058
+#define LSEQ_INT_VEC6A1			0x0064
+#define LSEQ_INT_VEC7A1			0x0070
+#define LSEQ_INT_VEC8A1			0x007C
+#define LSEQ_INT_VEC9A1			0x0088
+#define LSEQ_INT_VEC10A1		0x0094
+#endif /* SAS_SEQUENCER_A1 */
+
+#if SAS_SEQUENCER_B0
+/*
+ * LSEQ B0 Interrupt Vector addresses based on Sequencer Alpha_7f.
+ */
+#ifdef SEQUENCER_UPDATE
+/* Link sequencer interrrupt vector defines for Razor */
+#define	LSEQ_INT_VEC0B0			0x011C
+#define	LSEQ_INT_VEC1B0			0x16D8
+#define	LSEQ_INT_VEC2B0			0x0360
+#define	LSEQ_INT_VEC3B0			0x0390
+#define	LSEQ_INT_VEC4B0			0x16C0
+#define	LSEQ_INT_VEC5B0			0x27D4
+#define	LSEQ_INT_VEC6B0			0x28E4
+#define	LSEQ_INT_VEC7B0			0x0114
+#define	LSEQ_INT_VEC8B0			0x1630
+#define	LSEQ_INT_VEC9B0			0x1940
+#define	LSEQ_INT_VEC10B0		0x004C
+#else
+#define LSEQ_INT_VEC0B0			0x001C
+#define LSEQ_INT_VEC1B0			0x0024
+#define LSEQ_INT_VEC2B0			0x002C
+#define LSEQ_INT_VEC3B0			0x0034 
+#define LSEQ_INT_VEC4B0			0x003C
+#define LSEQ_INT_VEC5B0			0x0044
+#define LSEQ_INT_VEC6B0			0x004C
+#define LSEQ_INT_VEC7B0			0x0054
+#define LSEQ_INT_VEC8B0			0x005C
+#define LSEQ_INT_VEC9B0			0x0064
+#define LSEQ_INT_VEC10B0		0x006C
+#endif
+
+#endif /* SAS_SEQUENCER_B0 */
+
+#define LSEQ_IDLE_LOOP_ENTRY		0x0000    
+#define LSEQ_SEQUENCER_PROGRAM		0x0000
+
+#define SAS_S_ACTIVE_SCB		0x00FC
+
+#define SAS_S_Q_NEW_POINTER		0x0100
+#define SAS_S_PASS_TO_DRIVER		0x0115
+#define SAS_S_Q_EXE_HEAD		0x011C
+#define SAS_S_Q_EXE_TAIL		0x011E 
+#define SAS_S_Q_EXETARG_TAIL		0x0120 
+#define SAS_S_Q_DONE_POINTER		0x0110
+
+/* If enabled, set this to the interval between transmission
+ * of NOTIFY (ENABLE SPINUP). In units of 200 us.
+ */
+#define ASD_NOTIFY_TIMEOUT        2500
+
+/* Initial delay after OOB, before we transmit NOTIFY (ENABLE SPINUP).
+ * If 0, transmit immediately. In milliseconds.
+ */
+#define ASD_NOTIFY_DOWN_COUNT     0
+
+
+
+#endif /* ADP94XX_REG_H */
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_sas.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_sas.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_sas.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_sas.h	2007-04-05 23:37:45.000000000 +0000
@@ -0,0 +1,1325 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ * Serial Attached SCSI (SAS) definitions.
+ *
+ * Written by : David Chaw <david_chaw@adaptec.com>
+ *   
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+
+#ifndef ADP94XX_SAS_H
+#define ADP94XX_SAS_H
+
+
+/* 
+ * Connection Rate.
+ */
+#define SAS_60GBPS_RATE			600000000	
+#define SAS_30GBPS_RATE			300000000
+#define SAS_15GBPS_RATE			150000000
+#define SAS_INVALID_RATE		0xFFFFFFFF
+
+/* Connection Rate to be used in OPEN address frame. */
+#define SAS_RATE_30GBPS			0x09
+#define SAS_RATE_15GBPS			0x08
+
+#define SAS_ADDR_LEN			8
+#define HASHED_SAS_ADDR_LEN		3
+
+/*
+ * SAS SCB site common definitions.
+ */
+#define SCB_SITE_Q_NEXT			0x0
+#define SCB_SITE_FLAGS			0x49
+
+/*
+ * SG Element Format (16 bytes).
+ */
+struct sg_element {
+	uint64_t 	bus_address;
+	/*
+	 * length and next_sg_offset
+	 * are unused for link_element
+	 * S/G entries.  These entries
+	 * just serve as a pointer to
+	 * the next S/G sublist to process.
+	 */
+	uint32_t 	length;
+	uint8_t	 	res_1[2];
+	uint8_t	 	next_sg_offset;
+#define SG_NEXT_OFFSET	0x20
+	uint8_t	 	flags;
+#define	SG_EOS		0x80
+#define	SG_EOL		0x40
+#define	SG_NO_DATA	(SG_EOS|SG_EOL)
+#define	SG_DS_MASK	0x30
+#define	SG_DS_ONCHIP	0x10
+#define	SG_DS_OFFCHIP	0x00
+} __packed;
+
+
+/* 
+ * Protocol type definitions.
+ */
+#define PROTOCOL_TYPE_SSP	(1U << 4)
+#define PROTOCOL_TYPE_SATA	(1U << 5)
+#define PROTOCOL_TYPE_SMP	(0U << 6)
+#define PROTOCOL_TYPE_STP	PROTOCOL_TYPE_SATA
+#define PROTOCOL_TYPE_MASK	0x70
+
+/*
+ * Data Direction definitions.
+ */
+#define DATA_DIR_NO_XFER	(0U << 1)
+#define DATA_DIR_INBOUND	(1U << 0)	
+#define DATA_DIR_OUTBOUND	(1U << 1)
+#define DATA_DIR_UNSPECIFIED	(3U << 0)	
+
+/*
+ * Task Management Functions.
+ */
+#define ABORT_TASK_TMF		0x01
+#define ABORT_TASK_SET_TMF	0x02
+#define CLEAR_TASK_SET_TMF	0x04
+#define LOGICAL_UNIT_RESET_TMF	0x08
+#define CLEAR_ACA_TMF		0x40
+#define QUERY_TASK_TMF		0x80
+
+/*
+ * NOTE: Unless specified, all fields should be filled with Little Endian 
+ *	 format.
+ */
+ 
+/* SCB Common Header (11 bytes) */
+struct hscb_header {
+	uint64_t 		next_hscb_busaddr;
+	uint16_t 		index;
+	uint8_t	 		opcode;
+} __packed;
+
+/* SAS Frame Header (24 bytes) - All fields are in "wire" format (Big Endian) */
+struct asd_sas_header {
+	uint8_t	 		frame_type;
+#define ID_ADDR_FRAME		0x00
+#define OPEN_ADDR_FRAME		0x01
+#define XFER_RDY_FRAME		0x05
+#define COMMAND_FRAME		0x06
+#define RESPONSE_FRAME		0x07
+#define TASK_FRAME		0x16
+	
+	uint8_t  		hashed_dest_sasaddr[HASHED_SAS_ADDR_LEN];
+	uint8_t  		res;
+	uint8_t  		hashed_src_sasaddr[HASHED_SAS_ADDR_LEN];
+	uint8_t	 		res1[2];
+	uint8_t	 		retransmit;
+	uint8_t	 		num_fill_bytes;
+	uint8_t	 		res2[4];
+	uint16_t 		tag;
+	uint16_t 		target_port_xfer_tag;
+	uint32_t 		data_offset;
+} __packed;
+
+/* SAS SSP Task Information Unit (28 bytes) */
+struct asd_ssp_task_iu {
+	uint8_t			lun[8];
+	uint16_t		res1;
+	uint8_t			tmf;
+	uint8_t			res2;
+	uint16_t		tag_to_manage;
+	uint8_t			res3[14];
+} __packed;
+
+/* SAS SSP Response Information Unit (24 byts + response data + sense data) */
+struct resp_data_iu {
+	uint8_t			res[3];
+	uint8_t			resp_code;
+#define TMF_COMPLETE		0x00
+#define INVALID_FRAME		0x02
+#define TMF_NOT_SUPPORTED	0x04
+#define TMF_FAILED		0x05
+#define TMF_SUCCEEDED		0x08
+#define INVALID_LUN		0x09
+} __packed;
+
+struct ssp_resp_iu {
+	uint8_t			res_1[10];
+	uint8_t			datapres;
+#define	SSP_RIU_DATAPRES_MASK		0x3
+#define		SSP_RIU_DATAPRES_NONE	0x0
+#define		SSP_RIU_DATAPRES_RESP	0x1
+#define		SSP_RIU_DATAPRES_SENSE	0x2
+#define	SSP_RIU_DATAPRES(riu)		\
+	((riu)->datapres & SSP_RIU_DATAPRES_MASK)
+
+	uint8_t			status;
+	uint8_t			res_2[4];
+	uint8_t			sense_len[4];
+	uint8_t			response_len[4];
+	uint8_t			data[0]; /* Place Holder */
+};
+
+struct ssp_resp_frame {
+	struct asd_sas_header		sas_header;
+	struct ssp_resp_iu		riu;
+} __packed;
+#define	SSP_RIU_DATA_OFFSET(riu)		\
+	(offsetof(struct asd_ssp_response_iu, data))
+#define	SSP_RIU_RESPONSE_CODE(riu) (scsi_4btoul((riu)->data) & 0xFF)
+
+/* Retry count used by sequencer for SSP, ATA, and ATAPI task. */
+#define TASK_RETRY_CNT		3
+
+/* Suspend data transmission, valid for ABORT TASK and INITIATE SSP TMF. */
+#define SUSPEND_DATA				(1U << 2)
+#define OVERRIDE_I_T_NEXUS_LOSS_TIMER		(1U << 3)
+
+/*
+ * SCB Opcode field
+ */
+#define SCB_INITIATE_SSP_TASK		0x00 
+#define SCB_INITIATE_LONG_SSP_TASK	0x01
+#ifdef SEQUENCER_UPDATE
+#define SCB_INITIATE_BIDIR_SSP_TASK	0x02
+#endif
+#define SCB_ABORT_TASK			0x03
+#define SCB_INITIATE_SSP_TMF		0x04
+#ifdef SEQUENCER_UPDATE
+#define SCB_SSP_TARG_GET_DATA		0x05
+#define SCB_SSP_TARG_GET_DATA_SND_GOOD	0x06
+#define SCB_SSP_TARG_SND_RESP		0x07
+#define SCB_QUERY_SSP_TASK		0x08
+#endif
+#define SCB_INITIATE_ATA_TASK		0x09
+#define SCB_INITIATE_ATAPI_TASK		0x0A
+#define SCB_CONTROL_ATA_DEVICE		0x0B
+#define SCB_INITIATE_SMP_TASK		0x0C
+#ifdef SEQUENCER_UPDATE
+#define SCB_SMP_TARG_SND_RESP		0x0F
+#define SCB_SSP_TARG_SND_DATA		0x40
+#define SCB_SSP_TARG_SND_DATA_SND_GOOD	0x41
+#endif
+#define SCB_CONTROL_PHY			0x80
+#ifdef SEQUENCER_UPDATE
+#define SCB_SEND_PRIMITIVE		0x81
+#endif
+#define SCB_LINK_ADMIN_TASK		0x82
+#define SCB_EMPTY_BUFFER		0xC0
+#ifdef SEQUENCER_UPDATE
+#define SCB_ESTABLISH_ICL_TARG_WINDOW	0xC1
+#endif
+#define SCB_COPY_MEMORY			0xC3
+#define SCB_CLEAR_NEXUS			0xC4
+#ifndef SEQUENCER_UPDATE
+#define SCB_DELIVER_FREE_INIT_PORT_DDBS	0xC5
+#endif
+#ifdef SEQUENCER_UPDATE
+#define SCB_INIT_DDB_ADMIN_TASK		0xC6
+#endif
+#define SCB_ESTABLISH_NEXUS_EMPTY_SCB	0xD0
+
+/* 
+ * Initiate SSP TASK to a SAS target. 
+ */
+/* SCB_INITIATE_SSP_TASK */
+#define SCB_EMBEDDED_CDB_SIZE	16
+struct asd_ssp_task_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint32_t 		xfer_len;
+	struct asd_sas_header	sas_header;
+	uint8_t	 		lun[8];
+	uint8_t	 		res1;
+	uint8_t	 		task_attr;
+	uint8_t	 		task_mgmt_func;
+	uint8_t	 		addl_cdb_len;
+	uint8_t			cdb[SCB_EMBEDDED_CDB_SIZE];
+	uint16_t 		sister_scb;
+	uint16_t 		conn_handle;
+	uint8_t	 		data_dir_flags;
+	uint8_t			res2;
+	uint8_t			retry_cnt;
+	uint8_t	 		res3[5];
+	
+	/* Embedded SG Elements (0-2).  Each SG Element is 16 bytes. */
+	struct sg_element	sg_elements[3];
+} __packed;
+
+#define LAST_SSP_HSCB_FIELD	res3[0]
+
+/*
+ * Initiate Long SSP Task to a SAS target.
+ */
+/* SCB_INITIATE_LONG_SSP_TASK */
+struct asd_ssp_long_task_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint32_t 		xfer_len;
+	struct asd_sas_header	sas_header;
+	uint8_t	 		lun[8];
+	uint8_t	 		res1;
+	uint8_t	 		task_attr;
+	uint8_t	 		res2;
+	uint8_t			addl_cdb_len;
+	uint64_t		long_cdb_busaddr;
+	uint32_t		long_cdb_size;
+	uint8_t			res3[3];
+	uint8_t			long_cdb_ds;
+	uint16_t 		sister_scb;
+	uint16_t 		conn_handle;
+	uint8_t	 		data_dir_flags;
+	uint8_t	 		res4;
+	uint8_t			retry_cnt;
+	uint8_t	 		res5[5];
+	struct sg_element	sg_elements[3];
+} __packed;
+
+/* 
+ * Initiate Abort for an SCB previously sent to CSEQ.
+ * This SCB_ABORT_TASK shall be used only to abort an SCB with an opcode of
+ * 	- SCB_INITIATE_SSP_TASK
+ * 	- SCB_INITIATE_LONG_SSP_TASK
+ * 	- SCB_INITIATE_BIDIR_SSP_TASK
+ * 	- SCB_INITIATE_SMP_TASK
+ * 	- SCB_INITIATE_ATA_TASK
+ * 	- SCB_INITIATE_ATAPI_TASK
+ */
+/* SCB_ABORT_TASK */
+struct asd_abort_task_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint32_t 		res1;
+	struct asd_sas_header	sas_header;
+
+	/*
+ 	 * SSP Task IU field shall ony be valid when aborting an SCB with 
+	 * PROTOCOL field of SSP.
+	 */
+	struct asd_ssp_task_iu	task_iu;
+	uint16_t 		sister_scb;
+	uint16_t 		conn_handle;
+	uint8_t	 		suspend_data;
+	uint8_t			res2;
+	uint8_t			retry_cnt;
+	uint8_t	 		res3[5];
+	uint16_t		tc_to_abort;
+#ifdef SEQUENCER_UPDATE
+	uint16_t		i_t_nexus_timer_constant_override;
+	uint8_t			res4[44];
+#else
+	uint8_t			res4[46];
+#endif
+} __packed;
+
+/*
+ * Initiate an SSP TASK information unit for a LOGICAL UNIT RESET, 
+ * ABORT TASK SET, CLEAR TASK SET, or CLEAR ACA task management function.
+ */
+/* SCB_INITIATE_SSP_TMF */
+struct asd_ssp_tmf_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint32_t 		res1;
+	struct asd_sas_header	sas_header;
+	struct asd_ssp_task_iu	task_iu;
+	uint16_t 		sister_scb;
+	uint16_t 		conn_handle;
+	uint8_t			suspend_data;
+	uint8_t			res2;
+	uint8_t			retry_cnt;
+	uint8_t			res3[5];
+#ifdef SEQUENCER_UPDATE
+	uint8_t			res4[2];
+	uint16_t		i_t_nexus_timer_constant_override;
+	uint8_t			res5[44];
+#else
+	uint8_t			res4[48];
+#endif
+} __packed;
+
+/*
+ * Initiate Query SSP Task.
+ */
+#define SCB_QUERY_SSP_TASK		0x08
+struct asd_query_ssp_task_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint32_t 		res1;
+	struct asd_sas_header	sas_header;
+	struct asd_ssp_task_iu	task_iu;
+	uint16_t 		sister_scb;
+	uint16_t 		conn_handle;
+#ifdef SEQUENCER_UPDATE
+	uint8_t			override_i_t_nexus;
+	uint8_t 		res2;
+#else
+	uint16_t 		res2;
+#endif
+	uint8_t			retry_cnt;
+	uint8_t	 		res3[5];
+	uint16_t		tc_to_query;
+#ifdef SEQUENCER_UPDATE
+	uint16_t		i_t_nexus_timer_constant_override;
+	uint8_t			res4[44];
+#else
+	uint8_t			res4[46];
+#endif
+} __packed;
+
+/*
+ * Initiate ATA Task to a SATA target.
+ */
+/* SCB_INITIATE_ATA_TASK */
+struct asd_ata_task_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint32_t		xfer_len;
+	uint8_t			host_to_dev_reg_fis[20];
+	uint32_t 		data_offset;
+	uint8_t			res1[16];
+	uint8_t			res2[12];
+	uint16_t		sister_scb;
+	uint16_t 		conn_handle;
+	uint8_t			ata_flags;
+#define CSMI_TASK		(1U << 6)
+#define DMA_XFER_MODE		(1U << 4)
+#define UNTAGGED		(0U << 3)
+#ifdef SEQUENCER_UPDATE
+#define NATIVE_QUEUING		(1U << 3)
+#else
+#define LEGACY_QUEUING		(1U << 3)
+#define NATIVE_QUEUING		(3U << 2)
+#endif
+
+	uint8_t			res3;
+	uint8_t			retry_cnt;
+	uint8_t			res4;
+#define STP_AFFILIATION_POLICY	0x20
+#define SET_AFFILIATION_POLICY	0x10
+#ifdef SEQUENCER_UPDATE
+#define RETURN_PARTIAL_SG_LIST	0x02
+#endif
+	uint8_t			affiliation_policy;	/*
+							 * Bit 4 is Set 
+							 * Affiliation Policy
+							 * and Bit 5 is STP
+							 * Affiliation Policy.
+							 */
+	uint8_t			res5[3];
+	struct sg_element	sg_elements[3]; 
+} __packed;
+
+/*
+ * Initiate ATAPI Task to an ATAPI target.
+ */
+/* SCB_INITIATE_ATAPI_TASK */
+struct asd_atapi_task_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint32_t		xfer_len;
+	uint8_t			host_to_dev_reg_fis[20];/* Packet Command */
+	uint32_t 		data_offset;
+	uint8_t			atapi_packet[SCB_EMBEDDED_CDB_SIZE];
+	uint8_t			res1[12];
+	uint16_t		sister_scb;
+	uint16_t 		conn_handle;
+	uint8_t			ata_flags;		/* 
+							 * ATA flags definition 
+							 * is similar to 
+							 * INITIATE_ATA_TASK
+							 * except bits 2 and 3
+							 * (QUEUEING TYPE) 
+							 * should be set 0 
+							 * (UNTAGGED).
+							 */ 
+	uint8_t			res2;
+	uint8_t			retry_cnt;
+	uint8_t			res3;
+	uint8_t			affiliation_policy;	/*
+							 * Bit 4 is Set 
+							 * Affiliation Policy
+							 * and Bit 5 is STP
+							 * Affiliation Policy.
+							 */
+	uint8_t			res4[3];
+	struct sg_element	sg_elements[3]; 
+} __packed;
+ 
+/*
+ * Initiate an ATA device control function (e.g. software reset).
+ */
+/* SCB_CONTROL_ATA_DEVICE */
+struct asd_control_ata_dev_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint8_t			res1[4];
+	uint8_t			host_to_dev_reg_fis[20];
+	uint8_t			res2[32];
+	uint16_t		sister_scb;
+	uint16_t 		conn_handle;
+	uint8_t			ata_flags;		/* Must be set to 0. */
+	uint8_t			res3[55];	
+} __packed;
+
+/*
+ * Initiate an SMP task to an expander.
+ */
+/* SCB_INITIATE_SMP_TASK */
+struct asd_smp_task_hscb {
+	struct hscb_header	header;
+	uint8_t	 		protocol_conn_rate;
+	uint8_t			res1[40];
+	uint64_t		smp_req_busaddr;
+	uint32_t		smp_req_size;
+	uint8_t			res2[3];
+	uint8_t			smp_req_ds;
+	uint16_t		sister_scb;
+	uint16_t 		conn_handle;
+	uint8_t			res3[8];
+	uint64_t		smp_resp_busaddr;
+	uint32_t		smp_resp_size;
+	uint8_t			res4[3];
+	uint8_t			smp_resp_ds;
+	uint8_t			res5[32];
+} __packed;
+
+/*
+ * Control the operation of a PHY.
+ */
+/* SCB_CONTROL_PHY */
+struct asd_control_phy_hscb {
+	struct hscb_header	header;
+	uint8_t			phy_id;
+	uint8_t			sub_func;
+#define DISABLE_PHY		0x00
+#define ENABLE_PHY		0x01
+#define RELEASE_SPINUP_HOLD	0x02
+#define ENABLE_PHY_NO_SAS_OOB	0x03
+#define ENABLE_PHY_NO_SATA_OOB	0x04
+#define PHY_NO_OP		0x05
+#define EXECUTE_HARD_RESET	0x81			
+	
+	/*
+	 * OOB FUNCTION_MASK, SPEED_MASK, and HOT_PLUG_DELAY only valid for 
+	 * sub-functions ENABLE_PHY and EXECUTE_HARD_RESET.
+	 */
+	uint8_t			func_mask;
+	uint8_t			speed_mask;
+	uint8_t			hot_plug_delay;
+	uint8_t			port_type;
+#define SSP_INITIATOR_PORT	(1U << 7)	
+#define STP_INITIATOR_PORT	(1U << 6)
+#define SMP_INITIATOR_PORT	(1U << 5)
+	
+#ifdef SEQUENCER_UPDATE
+#define DEVICE_PRESENT_TIMER_OVERIDE_ENABLE	0x01
+#define DISABLE_PHY_IF_OOB_FAILS		0x02
+	uint8_t			device_present_timer_ovrd_enable;
+	uint32_t		device_present_timeout_const_override;
+	uint8_t			link_reset_retries;
+	uint8_t			res1[47];
+#else
+	uint8_t			ovrd_cominit_timer;
+	uint32_t		cominit_timer_const_ovrd;
+	uint8_t			res1[48];
+#endif
+	uint16_t		conn_handle;
+	uint8_t			res2[56];
+} __packed;
+
+/*
+ * Initiate an administrative task to the particular link.
+ */
+/* SCB_LINK_ADMIN_TASK */
+struct asd_link_admin_hscb {
+	struct hscb_header	header;
+	uint8_t			phy_id;
+	uint8_t			sub_func;
+#define GET_LINK_ERR_CNT	0x00
+#define RESET_LINK_ERR_CNT	0x01
+#define EN_NOTIFY_SPINUP_INTS	0x02
+
+	uint8_t			res1[57];
+	uint16_t		conn_handle;
+	uint8_t			res[56];
+} __packed;
+
+/* 
+ * Empty Buffer Element format (16 bytes). 
+ */
+struct empty_buf_elem {
+	uint64_t		busaddr;
+	uint32_t		buffer_size;
+	uint8_t			res[3];
+	uint8_t			elem_valid_ds;
+#define ELEM_BUFFER_VALID_MASK	0xC0
+#define ELEM_BUFFER_VALID	0x00
+#define ELEM_BUFFER_INVALID	0xC0
+#define ELEM_BUFFER_VALID_FIELD(ebe)	\
+	((ebe)->elem_valid_ds & ELEM_BUFFER_VALID_MASK)
+} __packed;
+
+/* 
+ * Provide Empty Data Buffers for Sequencer.
+ */
+/* SCB_EMPTY_BUFFER */
+struct asd_empty_hscb {
+	struct hscb_header	header;
+	uint8_t			num_valid_elems;
+	uint8_t			res1[4];
+	struct empty_buf_elem	buf_elem[7];	
+} __packed;
+
+
+/*
+ * Initiate a copy between two bus addresses using on-chip DMA engine.
+ */
+/* SCB_COPY_MEMORY */
+struct asd_copy_mem_hscb {
+	struct hscb_header	header;
+	uint8_t			res1;
+	uint16_t		xfer_len;
+	uint8_t			res2[2];
+	uint64_t		src_bus_addr;
+	uint8_t			src_sg_flags;
+	uint8_t			res3[45];
+	uint16_t		conn_handle;
+	uint8_t			res4[8];
+	uint64_t		dst_bus_addr;
+	uint8_t			dst_sg_flags;
+} __packed;
+
+/*
+ * Initiate a request that a set of transactions pending for a specified nexus
+ * be retun to driver via DL entries and the SCB sites (and tag number) be 
+ * returned to the free list of SCBs.
+ */
+/* SCB_CLEAR_NEXUS */
+struct asd_clear_nexus_hscb {
+	struct hscb_header	header;
+	uint8_t			nexus_ind;
+#define CLR_NXS_ADAPTER		0
+#define CLR_NXS_I_OR_T		1
+#define CLR_NXS_IT_OR_TI	2
+#define CLR_NXS_I_T_L		3
+#define CLR_NXS_I_T_L_Q_TAG	4
+#define CLR_NXS_I_T_L_Q_TC	5
+#define CLR_NXS_I_T_L_Q_STAG	6
+#ifdef SEQUENCER_UPDATE
+#define CLR_NXS_T_L		7
+#define CLR_NXS_L		8
+#endif
+
+	uint8_t			res1[4];
+	uint8_t			queue_ind;
+#define NOT_IN_Q		(1U << 0)
+#define EXEC_Q			(1U << 1)
+#define SEND_Q			(1U << 2)
+#define RESUME_TX		(1U << 6)
+#define SUSPEND_TX		(1U << 7)
+
+	uint8_t			res2[3];
+	uint8_t			conn_mask_to_clr;
+	uint8_t			res3[3];
+	uint8_t			res4[16];
+	uint8_t			lun_to_clr[8];
+	uint8_t			res5[4];
+	uint16_t		tag_to_clr;
+	uint8_t			res6[16];
+	uint16_t		conn_handle_to_clr;
+	uint8_t			res7[8];
+	uint16_t		tc_to_clr;
+	uint16_t		nexus_ctx;
+	uint8_t			res8[44];
+} __packed;
+
+/*
+ * SAS SCB data strucutes.
+ */ 
+union hardware_scb {
+	struct hscb_header		header;
+	struct asd_ssp_task_hscb 	ssp_task;
+	struct asd_ssp_long_task_hscb	long_ssp_task;
+	struct asd_abort_task_hscb 	abort_task;
+	struct asd_ssp_tmf_hscb 	ssp_tmf;
+	struct asd_query_ssp_task_hscb	query_ssp_task;
+	struct asd_ata_task_hscb	ata_task; 
+	struct asd_atapi_task_hscb	atapi_task; 
+	struct asd_control_ata_dev_hscb	control_ata_dev; 
+	struct asd_smp_task_hscb	smp_task; 
+	struct asd_control_phy_hscb	control_phy;
+	struct asd_link_admin_hscb 	link_admin;
+	struct asd_empty_hscb		empty_scb; 
+	struct asd_copy_mem_hscb 	copy_mem;
+	struct asd_clear_nexus_hscb	clear_nexus;
+	uint8_t				bytes[128];
+} __packed;
+
+
+/* 
+ * Done List Opcode definitions. 
+ * TASK_COMPLETE (TASK_COMP) :	Indicates status was received and acknowledged.
+ * TASK_FAILED (TASK_F)      : 	Indicates an error occured prior to receving an
+ *			       	an acknowledgement for the command.
+ * TASK_UNACKED (TASK_UA)    : 	Indicates the command was transmitted to the 
+ *			       	target, but an ACK (R_OK) or NAK (R_ERR) was not
+ *			       	received.
+ * TASK_INTERRUPTED (TASK_INT):	Indicates an error occured after the command was
+ *				acknowledged.
+ * TASK_COMPLETE_WITH_RESPONSE: Indicates status was received and acknowledged 
+ * (TASK_COMP_W_RESP) 		with response.
+ */
+#define TASK_COMP_WO_ERR		0x00
+#define TASK_COMP_W_UNDERRUN		0x01
+#define TASK_COMP_W_OVERRUN		0x02
+#define TASK_F_W_OPEN_REJECT		0x04
+#define TASK_INT_W_BRK_RCVD		0x05
+#define TASK_INT_W_PROT_ERR		0x06
+#define SSP_TASK_COMP_W_RESP		0x07
+#define TASK_INT_W_PHY_DOWN		0x08
+#define LINK_ADMIN_TASK_COMP_W_RESP	0x0A
+#define CSMI_TASK_COMP_WO_ERR		0x0B
+#define ATA_TASK_COMP_W_RESP		0x0C
+#ifdef SEQUENCER_UPDATE
+#define TASK_UNACKED_W_PHY_DOWN		0x0D
+#define TASK_UNACKED_W_BREAK_RCVD	0x0E
+#define TASK_INT_W_SATA_TO		0x0F
+#endif
+#define TASK_INT_W_NAK_RCVD		0x10
+#define CONTROL_PHY_TASK_COMP		0x11
+#define RESUME_COMPLETE			0x13
+#define TASK_INT_W_ACKNAK_TO		0x14
+#define TASK_F_W_SMPRSP_TO		0x15
+#define TASK_F_W_SMP_XMTRCV_ERR		0x16
+#ifdef SEQUENCER_UPDATE
+#define TASK_COMPLETE_W_PARTIAL_SGLIST	0x17
+#define TASK_UNACKED_W_ACKNAK_TIMEOUT	0x18
+#define TASK_UNACKED_W_SATA_TO		0x19
+#endif
+#define TASK_F_W_NAK_RCVD		0x1A
+#define TASK_ABORTED_BY_ITNL_EXP	0x1B
+#define ATA_TASK_COMP_W_R_ERR_RCVD	0x1C
+#define TMF_F_W_TC_NOT_FOUND		0x1D
+#define TASK_ABORTED_ON_REQUEST		0x1E
+#define TMF_F_W_TAG_NOT_FOUND		0x1F
+#define TMF_F_W_TAG_ALREADY_FREE	0x20
+#define TMF_F_W_TASK_ALREADY_DONE	0x21
+#define TMF_F_W_CONN_HNDL_NOT_FOUND	0x22
+#define TASK_CLEARED			0x23
+#ifdef SEQUENCER_UPDATE
+#define TASK_INT_W_SYNCS_RCVD		0x24
+#endif
+#define TASK_UA_W_SYNCS_RCVD		0x25
+#ifdef SEQUENCER_UPDATE
+#define TASK_F_W_IRTT_TIMEOUT		0x26
+#define TASK_F_W_NON_EXISTENT_SMP_CONN	0x27
+#define TASK_F_W_IU_TOO_SHORT		0x28
+#define TASK_F_W_DATA_OFFSET_ERR	0x29
+#define TASK_F_W_INVALID_CONN_HANDLE	0x2A
+#define TASK_F_W_ALREADY_REQ_N_PENDING	0x2B
+#endif
+#define EMPTY_BUFFER_RCVD		0xC0	/* or'ed with EDB element. */	
+#ifdef SEQUENCER_UPDATE
+#define EST_NEXUS_EMPTY_BUFFER_RCVD	0xD0	/* or'ed with EDB element */
+#endif
+
+
+/*
+ * Status block format.
+ */
+
+/* Generic status block format. */
+struct generic_sb {
+	uint32_t		res;
+} __packed;
+
+/* Task Complete Without Error format. */
+struct no_error_sb {
+	uint16_t		cons_idx;		/* SCB consumer index.*/
+	uint16_t		res;
+} __packed;
+ 
+/* Task Complete With Data UNDERRUN format. */
+struct data_underrun_sb {
+	uint32_t		res_len;		/* Residual length. */
+} __packed;
+
+/* Task Complete With Response format. */
+struct response_sb {
+	uint16_t		empty_scb_tc;
+	uint8_t			empty_buf_len;
+	uint8_t			empty_buf_elem;		/*
+							 * The first 3 bits 
+							 * represents msb of 
+							 * empty_buf_len.
+							 */
+#define EDB_ELEM_MASK		0x70
+#define EDB_ELEM_SHIFT		4
+#define RSP_EDB_ELEM(rsp)	\
+	(((rsp)->empty_buf_elem & EDB_ELEM_MASK) >> EDB_ELEM_SHIFT)
+#define EDB_BUF_LEN_MSB_MASK	0x7
+#define EDB_BUF_LEN_MSB_SHIFT	8
+#define RSP_EDB_BUFLEN(rsp)	\
+    ((rsp)->empty_buf_len	\
+   | (((rsp)->empty_buf_elem & EDB_BUF_LEN_MSB_MASK) << EDB_BUF_LEN_MSB_SHIFT))
+} __packed;
+
+/* Task Failed with Open Reject. */
+struct open_reject_sb {
+	uint8_t			res1;
+	uint8_t			abandon_open;
+	uint8_t			reason;
+	uint8_t			res2;
+} __packed;
+
+/* SSP Response Empty Buffer format. */
+struct ssp_resp_edb {
+	uint32_t		res_len;
+
+	/* 
+	 * TAG_TO_CLEAR field shall valid only for an SCB with an
+	 * ABORT TASK SCB, which indicates the value of the 
+	 * TAG OF TASK TO BE MANAGED field for the ABORT TASK 
+	 * information unit.
+	 */ 
+	uint16_t		tag_to_clear;
+	uint16_t		rcvd_frame_len;
+	uint8_t			res[8];
+	struct ssp_resp_frame	resp_frame;
+} __packed;
+
+/* Get Link Error Counters Empty Buffer format. */
+struct link_err_cnt_edb {
+	uint32_t		inv_dword_cnt;
+	uint32_t		disparity_err_cnt;
+	uint32_t		loss_of_sync_cnt;
+	uint32_t		phy_reset_cnt;
+} __packed;
+
+/* ATA Response Empty Buffer format. */
+struct ata_resp_edb {
+	uint32_t		residual_len;
+	uint16_t		res1;
+	uint16_t		rcvd_frame_len;
+	uint8_t			res2[8];
+	uint8_t			ending_fis[24];
+	uint32_t		sstatus;
+	uint32_t		serror;
+	uint32_t		scontrol;
+	uint32_t		sactive;
+} __packed;
+
+/*
+ * We purposely *do not* pack this union so that an array
+ * of edbs is aligned on an efficient machine boundary.
+ * Our only requirement is that the fields within an edb
+ * be left unpadded.
+ */
+union edb {
+	struct ssp_resp_edb	ssp_resp;
+	struct ata_resp_edb	ata_resp;
+	struct link_err_cnt_edb	link_err_cnt;
+	uint8_t			bytes[1068];
+};
+
+/* Control PHY Task Complete format. */
+struct control_phy_sb {
+	uint8_t			sb_opcode;
+#define PHY_RESET_COMPLETED	0x00
+
+	/* The fields below are only used for PHY_RESET_COMPLETED. */ 
+	uint8_t			oob_status;
+	uint8_t			oob_mode;
+	uint8_t			oob_signals;
+};
+
+/* I_T Nexus Loss Expired format. */
+/* Status Sub-Block format. */
+struct open_timeout_ssb {
+	uint8_t			break_timeout;
+	uint16_t		res;
+} __packed;
+
+struct open_reject_ssb {
+	uint8_t			abandon_retry_open;
+	uint8_t			open_reject_reason;	
+	uint8_t			res;
+} __packed;
+
+struct itnl_exp_sb {
+	uint8_t			reason;
+#define TASK_F_W_OPEN_TO	0x03
+#define TASK_F_W_OPEN_REJECT	0x04
+#define TASK_F_W_PHY_DOWN	0x09
+#define TASK_F_W_BREAK_RCVD	0x0E
+
+	union {
+		struct open_timeout_ssb	open_timeout;
+		struct open_reject_ssb	open_reject;
+	} stat_subblk; 
+};
+
+#define ABANDON_OPEN_MASK	0x02
+#define RETRY_OPEN_MASK		0x01
+
+/* Abandon Open Reject Reason field. */
+#define BAD_DESTINATION		0x00
+#define CONN_RATE_NOT_SUPPORTED	0x01
+#define PROTOCOL_NOT_SUPPORTED	0x02
+#define RSVD_ABANDON_0		0x03
+#define RSVD_ABANDON_1		0x04
+#define RSVD_ABANDON_2		0x05
+#define RSVD_ABANDON_3		0x06
+#define WRONG_DESTINATION	0x07
+#define STP_RESOURCE_BUSY	0x08
+
+/* Retry Open Reject Reason field. */
+#define NO_DESTINATION		0x00
+#define PATHWAY_BLOCKED		0x10
+#define RSVD_CONTINUE_0		0x20
+#define RSVD_CONTINUE_1		0x30
+#define RSVD_INITIALIZE_0	0x40
+#define RSVD_INITIALIZE_1	0x50
+#define RSVD_STOP_0		0x60
+#define RSVD_STOP_1		0x70
+#define RETRY			0x80
+
+/* Task Cleared format. */
+struct task_cleared_sb {
+	uint16_t		tag_of_cleared_task;
+	uint16_t		clr_nxs_ctx;
+} __packed;
+
+
+/* Empty Data Buffer Received format. */
+struct bytes_dmaed_subblk {
+	uint8_t			protocol;	/* 
+						 * MSB represent Initiator or 
+						 * Target.
+						 */
+#define INIT_TGT_MASK		0x80
+#define PROTOCOL_MASK		0x70
+	
+	uint16_t		edb_len;	/*
+						 * The msb 5 bits are ignored.
+						 */
+#define BYTES_DMAED_LEN_MASK	0x07FF	
+} __packed;
+
+struct primitive_rcvd_subblk {
+	uint8_t			reg_addr;
+	uint8_t			reg_content;
+	uint8_t			res;
+} __packed;
+
+struct phy_event_subblk {
+	uint8_t			oob_status;
+	uint8_t			oob_mode;
+	uint8_t			oob_signals;
+} __packed;
+
+struct link_reset_err_subblk {
+	uint8_t			error;
+#define RCVD_ID_TIMER_EXP	0x00		/* 
+						 * Timed out waiting for 
+						 * IDENTIFY Address frame
+						 * from attached device.
+						 */
+#ifdef SEQUENCER_UPDATE
+#define LOSS_OF_SIGNAL_ERR	0x01		/*
+						 * Loss of signal detected
+						 * following a completed
+						 * PHY reset
+						 */
+#define LOSS_OF_DWS_ERR		0x02		/*
+						 * Loss of dword sync detected
+						 * following a completed
+						 * PHY reset
+						 */
+#endif
+#define RCV_FIS_TIMER_EXP	0x03		/*
+						 * Timed out waiting for initial
+						 * Device-to-Host Register FIS
+						 * from attached device.
+						 */
+	uint16_t		res;
+} __packed;
+
+struct timer_event_subblk {
+	uint8_t			error;
+#define DWS_RESET_TO_EXP	0x00		/* 
+						 * DWS reset timer timeout
+						 * expired.
+						 */ 
+	uint16_t		res;
+} __packed;
+
+/*
+ * Common reasons shared by REQ TASK ABORT and REQ DEVICE RESET.
+ */ 
+#define TASK_UA_W_PHY_DOWN	0x0D
+
+struct req_task_abort_subblk {
+	uint16_t		task_tc_to_abort;
+	uint8_t			reason;
+#define TASK_UA_W_BRK_RCVD	0x0E
+#define TASK_UA_W_ACKNAK_TO	0x18
+} __packed;
+
+struct req_dev_reset_subblk {
+	uint16_t		task_tc_to_abort;
+	uint8_t			reason;
+#define	TASK_INT_W_SATA_TO	0x0F
+#define TASK_UA_W_SATA_TO	0x19
+#define TASK_INT_W_SYNCS_RCVD	0x24
+
+} __packed;
+
+struct edb_rcvd_sb {
+	uint8_t			sb_opcode;
+	/* The opcode defintions below can be or'ed with Receiving Phy ID. */
+#define BYTES_DMAED		0x00		/* 00h - 07h */	
+#define PRIMITIVE_RCVD		0x08		/* 08h - 0Fh */
+#define PHY_EVENT		0x10		/* 10h - 17h */
+#define LINK_RESET_ERR		0x18		/* 18h - 1Fh */
+#define TIMER_EVENT		0x20		/* 20h - 27h */
+#ifdef SEQUENCER_UPDATE
+/* Removed .... */
+#else
+#define ESTABLISH_CONN		0x28		/* 28h - 2Fh */
+#endif
+#define REQ_TASK_ABORT		0xF0	
+#define REQ_DEVICE_RESET	0xF1
+#ifdef SEQUENCER_UPDATE
+#define SIGNAL_NCQ_ERROR	0xF2
+#define CLEAR_NCQ_ERROR		0xF3
+#endif
+#define EDB_OPCODE_MASK		0x07
+
+	union {
+		struct bytes_dmaed_subblk 	bytes_dmaed;
+		struct primitive_rcvd_subblk 	prim_rcvd;
+		struct phy_event_subblk 	phy_event;
+		struct link_reset_err_subblk 	link_reset_err;
+		struct timer_event_subblk 	timer_event;
+		struct req_task_abort_subblk 	req_task_abort;	
+		struct req_dev_reset_subblk	req_dev_reset;
+	} edb_subblk;	
+} __packed;
+
+/* Done List format. */
+struct asd_done_list {
+	uint16_t		index;
+	uint8_t			opcode;
+	union {
+		struct generic_sb	generic;
+		struct no_error_sb	no_error;
+		struct data_underrun_sb data;
+		struct open_reject_sb	open_reject;
+		struct response_sb	response;
+		struct control_phy_sb	control_phy;
+		struct itnl_exp_sb	itnl_exp;
+		struct task_cleared_sb	task_cleared;
+		struct task_cleared_sb	resume_complete;
+		struct edb_rcvd_sb 	edb_rcvd;
+	} stat_blk;
+	uint8_t			toggle;	
+#define	ASD_DL_TOGGLE_MASK 0x1
+} __packed;
+
+struct asd_int_ddb {
+#ifdef SEQUENCER_UPDATE
+	uint16_t	q_free_ddb_head;
+	uint16_t	q_free_ddb_tail;
+	uint16_t	q_free_ddb_cnt;
+	uint16_t	q_used_ddb_head;
+	uint16_t	q_used_ddb_tail;
+#else
+	uint8_t		res1[10];
+#endif
+	uint16_t	shared_mem_lock;
+#ifdef SEQUENCER_UPDATE
+	uint16_t	smp_conn_tag;
+	uint16_t	est_nexus_buf_cnt;
+	uint16_t	est_nexus_buf_thresh;
+	uint8_t		res2[4];
+	uint8_t		settable_max_contents;
+	uint8_t		res3[23];
+#else
+	uint8_t		res2[34];
+#endif
+	uint8_t		conn_not_active;
+	uint8_t		phy_is_up;
+	uint8_t		port_map_by_ports[8];
+	uint8_t		port_map_by_links[8];
+} __packed;
+
+/*
+ * Used in the ddb_type field.
+ */
+#define UNUSED_DDB		0xFF
+#define TARGET_PORT_DDB		0xFE
+#define INITIATOR_PORT_DDB	0xFD
+#define PM_PORT_DDB		0xFC
+
+/*
+ * Used in the addr_fr_port field
+ */
+#define INITIATOR_PORT_MODE	0x80
+#define OPEN_ADDR_FRAME		0x01
+
+#ifdef SEQUENCER_UPDATE
+struct asd_ssp_smp_ddb {
+#else
+struct asd_ddb {
+#endif
+	uint8_t		addr_fr_port;
+	
+	uint8_t		conn_rate;
+	uint16_t	init_conn_tag;
+	uint8_t		dest_sas_addr[8];
+	uint16_t	send_q_head;
+	uint8_t		sqsuspended;
+	uint8_t		ddb_type;
+
+	uint16_t	res1;
+	uint16_t	awt_default;
+	uint8_t		comp_features;
+	uint8_t		pathway_blk_cnt;
+	uint16_t	arb_wait_time;
+	uint32_t	more_comp_features;
+	uint8_t		conn_mask;
+	uint8_t		open_affl;
+
+#define OPEN_AFFILIATION	0x01
+#ifdef SEQUENCER_UPDATE
+#define CONCURRENT_CONNECTION_SUPPORT	0x04
+#else
+#define STP_AFFILIATION		0x20
+#define SUPPORTS_AFFILIATION	0x40
+#define SATA_MULTIPORT		0x80
+#endif
+
+#ifdef SEQUENCER_UPDATE
+	uint16_t	res2;
+#else
+	uint8_t		res2;
+	uint8_t		stp_close;
+#endif
+#define CLOSE_STP_NO_TX		0x00
+#define CLOSE_STP_BTW_CMDS	0x01
+#define CLOSE_STP_NEVER		0x10
+
+	uint16_t	exec_q_tail;
+	uint16_t	send_q_tail;
+	uint16_t	sister_ddb;
+#ifdef SEQUENCER_UPDATE
+	uint8_t		res3[2];
+	uint8_t		max_concurrent_connections;
+	uint8_t		concurrent_connections;
+	uint8_t		tunable_number_contexts;
+	uint8_t		res4;
+#else
+	uint16_t	ata_cmd_scb_ptr;
+	uint32_t	sata_tag_mask;
+#endif
+	uint16_t	active_task_cnt;
+#ifdef SEQUENCER_UPDATE
+	uint8_t		res5[9];
+#else
+	uint16_t	res3;
+	uint32_t	sata_sactive;
+	uint8_t		no_of_sata_tags;
+	uint8_t		sata_stat;
+	uint8_t		sata_ending_stat;
+#endif
+	uint8_t		itnl_reason;
+#ifdef SEQUENCER_UPDATE
+	uint8_t		res6[2];
+#else
+	uint16_t	ncq_data_scb_ptr;
+#endif
+	uint16_t	itnl_const;
+#define ITNL_TIMEOUT_CONST	0x7D0		/* 2 seconds */	
+
+	uint32_t	itnl_timestamp;
+} __packed;
+
+#ifdef SEQUENCER_UPDATE
+struct asd_sata_stp_ddb {
+	uint8_t		addr_fr_port;
+	
+	uint8_t		conn_rate;
+	uint16_t	init_conn_tag;
+	uint8_t		dest_sas_addr[8];
+	uint16_t	send_q_head;
+	uint8_t		sqsuspended;
+	uint8_t		ddb_type;
+
+	uint16_t	res1;
+	uint16_t	awt_default;
+	uint8_t		comp_features;
+	uint8_t		pathway_blk_cnt;
+	uint16_t	arb_wait_time;
+	uint32_t	more_comp_features;
+	uint8_t		conn_mask;
+	uint8_t		open_affl;
+
+#define STP_AFFILIATION		0x20
+#define SUPPORTS_AFFILIATION	0x40
+#define SATA_MULTIPORT		0x80
+
+	uint8_t		res2;
+	uint8_t		stp_close;
+#define CLOSE_STP_NO_TX		0x00
+#define CLOSE_STP_BTW_CMDS	0x01
+#ifndef SEQUENCER_UPDATE
+#define CLOSE_STP_NEVER		0x10
+#endif
+
+	uint16_t	exec_q_tail;
+	uint16_t	send_q_tail;
+	uint16_t	sister_ddb;
+	uint16_t	ata_cmd_scb_ptr;
+	uint32_t	sata_tag_mask;
+	uint16_t	active_task_cnt;
+	uint8_t		res3[2];
+	uint32_t	sata_sactive;
+	uint8_t		no_of_sata_tags;
+	uint8_t		sata_stat;
+	uint8_t		sata_ending_stat;
+	uint8_t		itnl_reason;
+	uint16_t	ncq_data_scb_ptr;
+	uint16_t	itnl_const;
+	uint32_t	itnl_timestamp;
+} __packed;
+#endif
+
+struct asd_port_multi_ddb {
+	uint8_t		res1[29];
+	uint8_t		multi_pm_port;
+#define SATA_PORT_MULTI_DDB	(1U << 1)
+#define PM_PORT_SHIFT		4
+#define PM_PORT_MASK		0xF0
+
+	uint8_t		res2;
+	uint8_t		res3[5];
+	uint16_t	sister_ddb;
+	uint16_t	ata_cmd_scb_ptr;
+	uint32_t	sata_tag_alloc_mask;
+	uint16_t	active_task_cnt;
+	uint16_t	parent_ddb;
+	uint32_t	sata_sactive_reg;
+	uint8_t		sata_tags;
+	uint8_t		sata_stat_reg;
+	uint8_t		sata_end_stat_reg;
+	uint8_t		res4[9];
+} __packed;
+
+#ifndef SEQUENCER_UPDATE
+struct asd_port_multi_table_ddb {
+	uint16_t	ddb_ptr0;
+	uint16_t	ddb_ptr1;
+	uint16_t	ddb_ptr2;
+	uint16_t	ddb_ptr3;
+	uint16_t	ddb_ptr4;
+	uint16_t	ddb_ptr5;
+	uint16_t	ddb_ptr6;
+	uint16_t	ddb_ptr7;
+	uint16_t	ddb_ptr8;
+	uint16_t	ddb_ptr9;
+	uint16_t	ddb_ptr10;
+	uint16_t	ddb_ptr11;
+	uint16_t	ddb_ptr12;
+	uint16_t	ddb_ptr13;
+	uint16_t	ddb_ptr14;
+	uint16_t	ddb_ptr15;
+	uint8_t		res[32];
+} __packed;
+#endif
+
+/*
+ * Transport specific (SAS and SATA) data structures.
+ */
+struct sas_id_addr {
+	uint8_t		addr_frame_type;	/*
+						 * Bits 0-3: Address Frame Type
+						 * 	4-6: Device Type
+						 * 	  7: Restricted  
+						 */
+#define SAS_END_DEVICE		(1U << 4)
+#define SAS_EDGE_EXP_DEVICE	(1U << 5)	
+#define SAS_FANOUT_EXP_DEVICE	(1U << 6) 
+#define SAS_DEVICE_MASK		0x70
+
+	uint8_t		restricted1;
+	uint8_t		init_port_type;		
+#define SMP_INIT_PORT		(1U << 1)
+#define STP_INIT_PORT		(1U << 2)
+#define SSP_INIT_PORT		(1U << 3)
+#define INIT_PORT_MASK		0x0E
+	
+	uint8_t		tgt_port_type;
+#define SATA_TGT_PORT		(1U << 0)
+#define SMP_TGT_PORT		(1U << 1)
+#define STP_TGT_PORT		(1U << 2)
+#define SSP_TGT_PORT		(1U << 3)
+#define TGT_PORT_MASK		0x0E
+	
+	uint8_t		restricted2[8];
+	uint8_t		sas_addr[8];
+	uint8_t		phy_id;
+	uint8_t		res[7];
+	uint8_t		crc[4];
+} __packed; 
+
+struct sas_initial_fis {
+	uint8_t		fis[20];
+};
+
+union sas_bytes_dmaed {
+	struct sas_id_addr	id_addr_rcvd;
+	struct sas_initial_fis	initial_fis_rcvd;
+};
+
+void	asd_hwi_hash(uint8_t *sas_addr, uint8_t *hashed_addr);
+
+#define ASD_MAX_DATA_PAT_GEN_SIZE_TX 	1024
+#define ASD_MAX_DATA_PAT_GEN_SIZE_RX 	2176
+
+#endif /* ADP94XX_SAS_H */
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_sata.c linux-2.6.16/drivers/scsi/adp94xx/adp94xx_sata.c
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_sata.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_sata.c	2007-04-05 23:37:43.000000000 +0000
@@ -0,0 +1,3950 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ *
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Written by : Robert Tarte  <robt@PacificCodeWorks.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+#include "adp94xx_osm.h"
+#include "adp94xx_inline.h"
+#include "adp94xx_sata.h"
+#include "adp94xx_discover.h"
+
+#if KDB_ENABLE
+#include "linux/kdb.h"
+#endif
+
+// RST:
+// - What if the device doesn't support LBA???
+// - What if the number of outstanding (tagged) requests exceeds the
+//   number of Empty SCBs
+// - figure out tagged queueing modes
+// - overlap == disconnect???
+
+static void	asd_sata_linux_scb_done(struct asd_softc *asd, struct scb *scb,
+			struct asd_done_list *dl);
+
+
+ASD_COMMAND_BUILD_STATUS
+asd_build_ata_scb(
+struct asd_softc	*asd,
+struct scb		*scb,
+union asd_cmd		*acmd
+)
+{
+	ASD_COMMAND_BUILD_STATUS	ret;
+	struct asd_ata_task_hscb	*ata_hscb;
+	struct asd_target		*target;
+	struct scsi_cmnd		*cmd;
+	struct asd_device		*dev;
+
+	dev = scb->platform_data->dev;
+
+	cmd =  &acmd->scsi_cmd;
+
+	/*
+	 * Guard against stale sense data.  The Linux mid-layer assumes that
+	 * sense was retrieved anytime the first byte of the sense buffer
+	 * looks "sane".
+	 */
+	cmd->sense_buffer[0] = 0;
+	cmd->resid = 0;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	target = dev->target;
+
+	ata_hscb->header.opcode = SCB_INITIATE_ATA_TASK;
+	ata_hscb->protocol_conn_rate =
+		PROTOCOL_TYPE_SATA | target->ddb_profile.conn_rate;
+	ata_hscb->xfer_len = asd_htole32(cmd->request_bufflen);
+
+	ata_hscb->data_offset = 0;
+	ata_hscb->sister_scb = 0xffff;
+	ata_hscb->conn_handle = target->ddb_profile.conn_handle;
+	ata_hscb->retry_cnt = TASK_RETRY_CNT;
+	ata_hscb->affiliation_policy = 0;
+
+#ifdef TAGGED_QUEUING
+	// RST - add support for SATA II queueing
+	ata_hscb->ata_flags = LEGACY_QUEUING;
+#else
+	ata_hscb->ata_flags = UNTAGGED;
+#endif
+	/*
+	 * Guard against stale sense data.  The Linux mid-layer assumes that 
+	 * sense was retrieved anytime the first byte of the sense buffer 
+	 * looks "sane".
+	 */
+	cmd->sense_buffer[0] = 0;
+	cmd->resid = 0;
+
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_linux_scb_done);
+
+	switch (cmd->cmnd[0]) {
+	case FORMAT_UNIT:
+		ret = asd_sata_format_unit_build(asd, dev, scb, cmd);
+
+		/*
+		 * We will hand build the scb, no need to call asd_setup_data.
+		 */
+		return ret;
+
+	case INQUIRY:
+		ret = asd_sata_inquiry_build(asd, dev, scb, cmd);
+		break;
+	case LOG_SENSE:
+		ret = asd_sata_log_sense_build(asd, dev, scb, cmd);
+		break;
+	case MODE_SELECT:
+	case MODE_SELECT_10:
+		ret = asd_sata_mode_select_build(asd, dev, scb, cmd);
+		break;
+	case MODE_SENSE:
+	case MODE_SENSE_10:
+		ret = asd_sata_mode_sense_build(asd, dev, scb, cmd);
+		break;
+	case READ_6:
+	case READ_10:
+	case READ_12:
+		ret = asd_sata_read_build(asd, dev, scb, cmd);
+		break;
+	case WRITE_BUFFER:
+		ret = asd_sata_write_buffer_build(asd, dev, scb, cmd);
+		break;
+	case READ_BUFFER:
+		ret = asd_sata_read_buffer_build(asd, dev, scb, cmd);
+		break;
+	case READ_CAPACITY:
+		ret = asd_sata_read_capacity_build(asd, dev, scb, cmd);
+		break;
+	case REPORT_LUNS:
+		ret = asd_sata_report_luns_build(asd, dev, scb, cmd);
+		break;
+	case REQUEST_SENSE:
+		ret = asd_sata_request_sense_build(asd, dev, scb, cmd);
+		break;
+	case REZERO_UNIT:
+		ret = asd_sata_rezero_unit_build(asd, dev, scb, cmd);
+		break;
+	case SEEK_6:
+	case SEEK_10:
+		ret = asd_sata_seek_build(asd, dev, scb, cmd);
+		break;
+	case SEND_DIAGNOSTIC:
+		ret = asd_sata_send_diagnostic_build(asd, dev, scb, cmd);
+		break;
+	case START_STOP:
+		ret = asd_sata_start_stop_build(asd, dev, scb, cmd);
+		break;
+	case SYNCHRONIZE_CACHE:
+		ret = asd_sata_synchronize_cache_build(asd, dev, scb, cmd);
+		break;
+	case TEST_UNIT_READY:
+		ret = asd_sata_test_unit_ready_build(asd, dev, scb, cmd);
+		break;
+#ifdef T10_04_136
+	case VERIFY:
+		ret = asd_sata_verify_build(asd, dev, scb, cmd);
+		break;
+#endif
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_12:
+		ret = asd_sata_write_build(asd, dev, scb, cmd);
+		break;
+#ifdef T10_04_136
+	case WRITE_VERIFY:
+		ret = asd_sata_write_verify_build(asd, dev, scb, cmd);
+		break;
+#endif
+	default:
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+	
+	if (ret != ASD_COMMAND_BUILD_OK) {
+		return ret;
+	}
+
+	ret = asd_setup_data(asd, scb, cmd);
+
+	return ret;
+}
+
+/* -------------------------------------------------------------------------- */
+
+ASD_COMMAND_BUILD_STATUS
+asd_build_atapi_scb(
+struct asd_softc	*asd,
+struct scb		*scb,
+union asd_cmd		*acmd
+)
+{
+	ASD_COMMAND_BUILD_STATUS	ret;
+	struct asd_atapi_task_hscb	*atapi_hscb;
+	struct hd_driveid		*hd_driveidp;
+	struct asd_target		*target;
+	struct scsi_cmnd		*cmd;
+	struct asd_device		*dev;
+
+	dev = scb->platform_data->dev;
+
+	cmd =  &acmd->scsi_cmd;
+
+	/*
+	 * Guard against stale sense data. The Linux mid-layer assumes that 
+	 * sense was retrieved anytime the first byte of the sense buffer 
+	 * looks "sane".
+	 */
+	cmd->sense_buffer[0] = 0;
+	cmd->resid = 0;
+
+	atapi_hscb = &scb->hscb->atapi_task;
+
+	target = dev->target;
+
+	atapi_hscb->header.opcode = SCB_INITIATE_ATAPI_TASK;
+	atapi_hscb->protocol_conn_rate =
+		PROTOCOL_TYPE_SATA | target->ddb_profile.conn_rate;
+	atapi_hscb->xfer_len = asd_htole32(cmd->request_bufflen);
+
+	atapi_hscb->data_offset = 0;
+	atapi_hscb->sister_scb = 0xffff;
+	atapi_hscb->conn_handle = target->ddb_profile.conn_handle;
+	atapi_hscb->retry_cnt = TASK_RETRY_CNT;
+	atapi_hscb->affiliation_policy = 0;
+
+	hd_driveidp = &dev->target->atapi_cmdset.adp_hd_driveid;
+
+#ifdef TAGGED_QUEUING
+	// RST - add support for SATA II queueing
+	atapi_hscb->ata_flags = LEGACY_QUEUING;
+#else
+	atapi_hscb->ata_flags = UNTAGGED;
+#endif
+
+	memcpy(atapi_hscb->atapi_packet, cmd->cmnd, MAX_COMMAND_SIZE);
+
+	// issue a PACKET command 6.24 of the ATA/ATAPI spec
+	asd_sata_setup_fis((struct asd_ata_task_hscb *)atapi_hscb,
+		WIN_PACKETCMD);
+
+	switch (cmd->sc_data_direction)
+	{
+	case SCSI_DATA_READ:
+		atapi_hscb->ata_flags |= DATA_DIR_INBOUND;
+		break;
+
+	case SCSI_DATA_WRITE:
+		atapi_hscb->ata_flags |= DATA_DIR_OUTBOUND;
+		break;
+
+	case SCSI_DATA_NONE:
+		atapi_hscb->ata_flags |= DATA_DIR_NO_XFER;
+		break;
+
+	case SCSI_DATA_UNKNOWN:
+		atapi_hscb->ata_flags |= DATA_DIR_UNSPECIFIED;
+		break;
+	}
+
+	if ((cmd->sc_data_direction != SCSI_DATA_NONE)) {
+		SET_NO_IO_MODE(atapi_hscb);
+	}
+	else if (target->atapi_cmdset.features_state & SATA_USES_DMA) {
+		ASD_H2D_FIS(atapi_hscb)->features = PACKET_DMA_BIT;
+
+		if (hd_driveidp->dma_1word & DMADIR_BIT_NEEDED) {
+			if (cmd->sc_data_direction == SCSI_DATA_READ) {
+				ASD_H2D_FIS(atapi_hscb)->features |= 
+					DMADIR_BIT_DEV_TO_HOST;
+			} else {
+				ASD_H2D_FIS(atapi_hscb)->features &= 
+					~DMADIR_BIT_DEV_TO_HOST;
+			}
+		}
+
+		SET_DMA_MODE(atapi_hscb);
+	} else {
+		SET_PIO_MODE(atapi_hscb);
+	}
+
+	ASD_H2D_FIS(atapi_hscb)->byte_count_lo = cmd->request_bufflen & 0xff;
+	ASD_H2D_FIS(atapi_hscb)->byte_count_hi = 
+		(cmd->request_bufflen >> 8) & 0xff;
+
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_linux_scb_done);
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_atapi_post);
+
+	ret = asd_setup_data(asd, scb, cmd);
+
+	return ret;
+}
+
+void
+asd_sata_atapi_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	struct scsi_cmnd	*cmd;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_set_check_condition(cmd,
+			(ASD_D2H_FIS(ata_resp_edbp)->error & 0xf0) >> 4, 0, 0);
+		asd_hwi_free_edb(asd, escb, edb_index);
+
+
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	default:
+		/*
+		 * The response will be handled by the routine that we are
+		 * "popping" to.
+		 */
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	}
+
+	asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+static void
+asd_sata_linux_scb_done(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*dl
+)
+{
+	Scsi_Cmnd 		*cmd;
+	struct asd_device	*dev;
+
+	if ((scb->flags & SCB_ACTIVE) == 0) {
+		asd_print("SCB %d done'd twice\n", SCB_GET_INDEX(scb));
+		panic("Stopping for safety");
+	}
+
+	list_del(&scb->owner_links);
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+	dev = scb->platform_data->dev;
+	dev->active--;
+	dev->openings++;
+	if ((scb->flags & SCB_DEV_QFRZN) != 0) {
+		scb->flags &= ~SCB_DEV_QFRZN;
+		dev->qfrozen--;
+	}
+
+	asd_unmap_scb(asd, scb);
+
+	if (dl != NULL) {
+#if 0
+	if( (dl->opcode != TASK_COMP_WO_ERR) && (dl->opcode != TASK_COMP_W_UNDERRUN) ) 
+	{
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+		asd_log(ASD_DBG_INFO, "asd_scb_done with error cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x abort:%d) dl->opcode 0x%x\n",
+#else
+		asd_log(ASD_DBG_INFO, "asd_scb_done with error cmd LBA 0x%02x%02x%02x%02x - 0x%02x%02x (tag:0x%x, pid:0x%x, res_count:0x%x, timeout:0x%x) dl->opcode 0x%x\n",
+#endif
+			cmd->cmnd[2],
+			cmd->cmnd[3],
+			cmd->cmnd[4],
+			cmd->cmnd[5],
+			cmd->cmnd[7],
+			cmd->cmnd[8],
+		  cmd->tag,
+		  cmd->pid,
+		  cmd->resid,
+		  cmd->timeout_per_command,
+#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,13)
+		  cmd->abort_reason,
+#endif
+		  dl->opcode);
+
+		}
+#endif
+
+		switch (dl->opcode) {
+		case TASK_COMP_W_UNDERRUN:
+			cmd->resid = asd_le32toh(dl->stat_blk.data.res_len);
+			asd_cmd_set_host_status(cmd, DID_OK);
+			break;
+
+		case TASK_ABORTED_ON_REQUEST:
+			asd_cmd_set_host_status(cmd, DID_ABORT);
+			break;
+
+		case TASK_CLEARED:
+		{
+			struct task_cleared_sb	*task_clr;
+
+			task_clr = &dl->stat_blk.task_cleared;
+
+			asd_log(ASD_DBG_ERROR," Task Cleared for Tag: 0x%x, "
+				"TC: 0x%x.\n",
+				task_clr->tag_of_cleared_task,
+				SCB_GET_INDEX(scb));
+
+			/*
+		 	 * Pending command at the firmware's queues aborted
+			 * upon request. If the device is offline then failed
+			 * the IO.
+		 	 * Otherwise, have the command retried again.
+	         	 */
+			if (task_clr->clr_nxs_ctx == ASD_TARG_HOT_REMOVED) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+				asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+				asd_cmd_set_offline_status(cmd);
+#endif
+			} else
+				asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+
+			break;
+		}
+
+		case TASK_INT_W_BRK_RCVD:
+			asd_log(ASD_DBG_ERROR,
+				"TASK INT. WITH BREAK RECEIVED.\n");
+			asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+			break;
+
+		case TASK_ABORTED_BY_ITNL_EXP:
+		{
+			struct itnl_exp_sb	*itnl_exp;
+
+			itnl_exp = &dl->stat_blk.itnl_exp;
+
+			asd_log(ASD_DBG_ERROR,
+				"ITNL EXP for SCB 0x%x Reason = 0x%x.\n",
+				SCB_GET_INDEX(scb), itnl_exp->reason);
+		
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+			asd_cmd_set_host_status(cmd, DID_NO_CONNECT);
+#else
+			asd_cmd_set_offline_status(cmd);
+#endif
+			break;
+		}
+	
+		default:
+			//asd_cmd_set_host_status(cmd, DID_SOFT_ERROR);
+			break;
+		}
+	}
+
+	if ((dev->target->flags & ASD_TARG_HOT_REMOVED) != 0) {
+		/*
+	 	 * If the target had been removed and all active IOs on 
+		 * the device have been completed, schedule the device to
+		 * be destroyed.
+	 	 */
+		if (list_empty(&dev->busyq) && (dev->active == 0) &&
+		   ((dev->flags & ASD_DEV_DESTROY_WAS_ACTIVE) != 0)) {
+			/*
+			 * Schedule a deferred process task to destroy
+		         * the device.
+			 */	 
+			asd_setup_dev_dpc_task(dev, asd_destroy_device);
+		}
+	} else {
+		if ((dev->flags & ASD_DEV_ON_RUN_LIST) == 0) {
+			list_add_tail(&dev->links,
+				      &asd->platform_data->device_runq);
+			dev->flags |= ASD_DEV_ON_RUN_LIST;
+		}
+	}
+
+	/*
+	 * Only free the scb if it hasn't timedout.
+	 * For SCB that has timedout, error recovery has invoked and
+	 * the timedout SCB will be freed in the error recovery path.
+	 */
+	if ((scb->flags & SCB_TIMEDOUT) == 0)
+		asd_hwi_free_scb(asd, scb);
+//JDTEST
+	else
+	{
+		asd_log(ASD_DBG_ERROR, "scb 0x%x SCB_TIMEDOUT(0x%x)\n",scb,scb->flags);
+		scb->flags |= SCB_ABORT_DONE;
+	}
+
+	cmd->scsi_done(cmd);
+}
+
+/* -------------------------------------------------------------------------- */
+
+INLINE
+void
+asd_sata_setup_fis(
+struct asd_ata_task_hscb	*ata_hscb,
+uint8_t				command
+)
+{
+	memset(&ASD_H2D_FIS(ata_hscb)->features, 0,
+		FIS_LENGTH - FIS_OFFSET(features));
+
+	ASD_H2D_FIS(ata_hscb)->fis_type = FIS_HOST_TO_DEVICE;
+	ASD_H2D_FIS(ata_hscb)->cmd_devcontrol = FIS_COMMAND;
+	ASD_H2D_FIS(ata_hscb)->command = command;
+}
+
+void
+asd_sata_compute_support(
+struct asd_softc	*asd,
+struct asd_target	*target
+)
+{
+	struct hd_driveid	*hd_driveidp;
+	unsigned		*features_state;
+	unsigned		*features_enabled;
+	unsigned		dma_mode_bits;
+	unsigned		*dma_mode_level;
+
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_ATA:
+		hd_driveidp = &target->ata_cmdset.adp_hd_driveid;
+		features_state = &target->ata_cmdset.features_state;
+		features_enabled = &target->ata_cmdset.features_enabled;
+		dma_mode_level = &target->ata_cmdset.dma_mode_level;
+		break;
+
+	case ASD_COMMAND_SET_ATAPI:
+		hd_driveidp = &target->atapi_cmdset.adp_hd_driveid;
+		features_state = &target->atapi_cmdset.features_state;
+		features_enabled = &target->atapi_cmdset.features_enabled;
+		dma_mode_level = &target->atapi_cmdset.dma_mode_level;
+		break;
+
+	default:
+		return;
+	}
+
+	*features_state = (hd_driveidp->cfs_enable_2 & IDENT_48BIT_SUPPORT) ?
+			SATA_USES_48BIT : 0;
+
+#ifdef TAGGED_QUEUING
+	*features_state |= (hd_driveidp->cfs_enable_2 & IDENT_QUEUED_SUPPORT) ?
+			SATA_USES_QUEUEING : 0;
+#endif
+
+	*features_state |= (hd_driveidp->capability & IDENT_DMA_SUPPORT) ?
+			SATA_USES_DMA : 0;
+
+	*features_state |= (hd_driveidp->cfsse & IDENT_WRITE_FUA_SUPPORT) ?
+			SATA_USES_WRITE_FUA : 0;
+
+	*features_state |= (hd_driveidp->config & ATA_REMOVABLE) ? 	
+		SATA_USES_REMOVABLE : 0;
+
+	if ((hd_driveidp->command_set_1 & ATA_WRITE_BUFFER_CAPABLE) &&
+	    (hd_driveidp->cfs_enable_1 & ATA_WRITE_BUFFER_ENABLED)) {
+		*features_state |= SATA_USES_WRITE_BUFFER;
+	}
+
+	if ((hd_driveidp->command_set_1 & ATA_READ_BUFFER_CAPABLE) &&
+	    (hd_driveidp->cfs_enable_1 & ATA_READ_BUFFER_ENABLED)) {
+		*features_state |= SATA_USES_READ_BUFFER;
+	}
+
+	if ((hd_driveidp->command_set_1 & ATA_SMART_CAPABLE) &&
+	    (hd_driveidp->cfs_enable_1 & ATA_SMART_ENABLED)) {
+		*features_state |= SATA_USES_SMART;
+	}
+
+	if ((hd_driveidp->command_set_1 & ATA_WRITE_CACHE_CAPABLE) &&
+	    (hd_driveidp->cfs_enable_1 & ATA_WRITE_CACHE_ENABLED)) {
+		*features_state |= SATA_USES_WRITE_CACHE;
+	}
+
+	if ((hd_driveidp->command_set_1 & ATA_LOOK_AHEAD_CAPABLE) &&
+	    (hd_driveidp->cfs_enable_1 & ATA_LOOK_AHEAD_ENABLED)) {
+		*features_state |= SATA_USES_READ_AHEAD;
+	}
+
+	*features_enabled = 0;
+
+	/*
+	 * features_enabled represents the desired state of the feature.
+	 */
+	*features_enabled = 
+		(hd_driveidp->command_set_1 & ATA_WRITE_CACHE_CAPABLE) ?
+		WRITE_CACHE_FEATURE_ENABLED : 0;
+
+	*features_enabled |=
+		(hd_driveidp->command_set_1 & ATA_LOOK_AHEAD_CAPABLE) ?
+		READ_AHEAD_FEATURE_ENABLED : 0;
+
+	*features_enabled |=
+		(hd_driveidp->command_set_1 & ATA_SMART_CAPABLE) ?
+		SMART_FEATURE_ENABLED : 0;
+
+	*dma_mode_level = 0;
+
+	if (hd_driveidp->field_valid & ATA_DMA_ULTRA_VALID) {
+
+		dma_mode_bits = hd_driveidp->dma_ultra & DMA_ULTRA_MODE_MASK;
+
+		if (dma_mode_bits != 0) {
+			*features_state |= SATA_USES_UDMA;
+ 			*features_enabled |= NEEDS_XFER_SETFEATURES;
+
+			dma_mode_bits = dma_mode_bits >> 1;
+
+			while (dma_mode_bits != 0) {
+				dma_mode_bits = dma_mode_bits >> 1;
+				*dma_mode_level = *dma_mode_level + 1;
+			}
+
+			*dma_mode_level |= UDMA_XFER_MODE;
+		}
+	}
+
+#if 0
+	... next check byte (field_valid) 53 to see if words 70:64 are valid
+	... word 64 - eide_pio_modes
+#endif
+}
+
+INLINE
+void
+asd_sata_setup_lba_ext(
+struct asd_ata_task_hscb	*ata_hscb,
+uint32_t			lba,
+unsigned			sectors
+)
+{
+	ASD_H2D_FIS(ata_hscb)->lba0 = lba & 0xff;
+	ASD_H2D_FIS(ata_hscb)->lba1 = (lba >> 8) & 0xff;
+	ASD_H2D_FIS(ata_hscb)->lba2 = (lba >> 16) & 0xff;
+	ASD_H2D_FIS(ata_hscb)->lba3 = (lba >> 24);
+
+	ASD_H2D_FIS(ata_hscb)->sector_count = sectors & 0xff;
+	ASD_H2D_FIS(ata_hscb)->sector_count_exp = sectors >> 8;
+
+	/*
+	 * Section 3.1.39 of ATA-ATAPI-7 says:
+	 * In a serial implementation, the device ignores the DEV bit.
+	 */
+	ASD_H2D_FIS(ata_hscb)->dev_head = LBA_MODE;
+}
+
+INLINE
+void
+asd_sata_setup_lba(
+struct asd_ata_task_hscb	*ata_hscb,
+uint32_t			lba,
+unsigned			sectors
+)
+{
+	ASD_H2D_FIS(ata_hscb)->lba0 = lba & 0xff;
+	ASD_H2D_FIS(ata_hscb)->lba1 = (lba >> 8) & 0xff;
+	ASD_H2D_FIS(ata_hscb)->lba2 = (lba >> 16) & 0xff;
+
+	ASD_H2D_FIS(ata_hscb)->sector_count = sectors & 0xff;
+	ASD_H2D_FIS(ata_hscb)->dev_head = LBA_MODE | ((lba >> 24) & 0x0f);
+}
+
+void
+asd_sata_set_check_condition(
+struct scsi_cmnd	*cmd,
+unsigned		sense_key,
+unsigned		additional_sense,
+unsigned		additional_sense_qualifier
+)
+{
+	u_char		sense_data[SENSE_DATA_SIZE];
+
+	memset(sense_data, 0, SENSE_DATA_SIZE);
+
+	asd_cmd_set_driver_status(cmd, DRIVER_SENSE);
+	asd_cmd_set_host_status(cmd, DID_OK);
+	asd_cmd_set_scsi_status(cmd, CHECK_CONDITION << 1);
+
+	sense_data[0] = 0x70;
+	sense_data[2] = sense_key;
+	sense_data[7] = SENSE_DATA_SIZE - 7;
+
+	sense_data[12] = additional_sense;
+	sense_data[13] = additional_sense_qualifier;
+
+	memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+	memcpy(cmd->sense_buffer, sense_data, sizeof(cmd->sense_buffer));
+
+	// RST - we need to save away the sense data
+}
+
+void
+asd_sata_check_registers(
+struct ata_resp_edb	*ata_resp_edbp,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	/*
+	 * Check the interface state registers.
+	 */
+#if 0
+	if ((ata_resp_edbp->sstatus & SSTATUS_IPM_DET_MASK) !=
+		(SSTATUS_DET_COM_ESTABLISHED | SSTATUS_IPM_ACTIVE)) {
+		printk("sstatus = 0x%x\n", ata_resp_edbp->sstatus);
+
+		asd_sata_set_check_condition(cmd, NOT_READY,
+			LOGICAL_UNIT_ASC, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if ((ata_resp_edbp->sstatus & SSTATUS_SPD_MASK) == 0) {
+		printk("sstatus = 0x%x\n", ata_resp_edbp->sstatus);
+
+		asd_sata_set_check_condition(cmd, NOT_READY,
+			LOGICAL_UNIT_ASC, 0);
+
+		return;
+	}
+#endif
+
+	if (ata_resp_edbp->serror != 0) {
+		asd_print("serror = 0x%x\n", ata_resp_edbp->serror);
+
+		// RST - make this better
+		asd_sata_set_check_condition(cmd, NOT_READY,
+			LOGICAL_UNIT_ASC, 0);
+
+		return;
+	}
+
+	if ((ASD_D2H_FIS(ata_resp_edbp)->status) & (ERR_STAT | WRERR_STAT)) {
+		asd_print("status = 0x%x\n",
+			ASD_D2H_FIS(ata_resp_edbp)->status);
+
+		asd_sata_completion_status(cmd, ata_resp_edbp);
+
+		return;
+	}
+
+	return;
+}
+
+void
+asd_sata_completion_status(
+struct scsi_cmnd	*cmd,
+struct ata_resp_edb	*ata_resp_edbp
+)
+{
+	if ((ASD_D2H_FIS(ata_resp_edbp)->error) & NM_ERR) {
+		/*
+		 * no medium
+		 */
+		asd_sata_set_check_condition(cmd, MEDIUM_ERROR,
+			MEDIUM_NOT_PRESENT, 0);
+
+		return;
+	}
+
+	if ((ASD_D2H_FIS(ata_resp_edbp)->error) & ABRT_ERR) {
+		/*
+		 * command aborted
+		 */
+		asd_sata_set_check_condition(cmd, ABORTED_COMMAND,
+			IO_PROCESS_TERMINATED_ASC, IO_PROCESS_TERMINATED_ASCQ);
+
+		return;
+	}
+
+	if ((ASD_D2H_FIS(ata_resp_edbp)->error) & MCR_ERR) {
+		/*
+		 * medium change request
+		 */
+		asd_sata_set_check_condition(cmd, UNIT_ATTENTION,
+			OPERATOR_ASC, MEDIUM_REMOVAL_REQUEST);
+
+		return;
+	}
+
+	if ((ASD_D2H_FIS(ata_resp_edbp)->error) & ID_ERR) {
+		/*
+		 * address out of bounds
+		 */
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return;
+	}
+
+	if ((ASD_D2H_FIS(ata_resp_edbp)->error) & MC_ERR) {
+		/*
+		 * medium changed
+		 */
+		asd_sata_set_check_condition(cmd, UNIT_ATTENTION,
+			MEDIUM_CHANGED, 0);
+
+		return;
+	}
+
+	if ((ASD_D2H_FIS(ata_resp_edbp)->error) & UNC_ERR) {
+		/*
+		 * uncorrectable ECC error
+		 */
+		asd_sata_set_check_condition(cmd, MEDIUM_ERROR,
+			LOGICAL_UNIT_ASC, 0);
+
+		return;
+	}
+
+	if ((ASD_D2H_FIS(ata_resp_edbp)->error) & ICRC_ERR) {
+		/*
+		 * CRC error
+		 */
+		asd_sata_set_check_condition(cmd, MEDIUM_ERROR,
+			LOGICAL_UNIT_ASC, COMMUNICATION_CRC_ERROR);
+
+		return;
+	}
+
+	asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+	return;
+}
+INLINE
+struct ata_resp_edb *
+asd_sata_get_edb(
+struct asd_softc	*asd,
+struct asd_done_list	*done_listp,
+struct scb **pescb, 
+u_int *pedb_index
+)
+{
+	struct response_sb	*responsep;
+	unsigned		buflen;
+	struct scb		*escb;
+	u_int			escb_index;
+	u_int			edb_index;
+	struct ata_resp_edb	*ata_resp_edbp;
+	union edb		*edbp;
+
+	responsep = &done_listp->stat_blk.response;
+
+	buflen = (responsep->empty_buf_elem & EDB_ELEM_MASK) << 4 | 
+		responsep->empty_buf_len;
+
+	if (buflen == sizeof(struct ata_resp_edb)) {
+		asd_print("buflen is %d - should be %u\n",
+			buflen, (unsigned)sizeof(struct ata_resp_edb));
+	}
+
+	escb_index = asd_le16toh(responsep->empty_scb_tc);
+
+	edb_index = RSP_EDB_ELEM(responsep) - 1;
+
+	edbp = asd_hwi_indexes_to_edb(asd, &escb, escb_index, edb_index);
+
+	ata_resp_edbp = &edbp->ata_resp;
+	*pescb = escb;
+	*pedb_index = edb_index;
+
+	return ata_resp_edbp;
+}
+
+/*
+ * This routine will only get called when a command that was issued by the
+ * state machine has completed.
+ */
+void
+asd_sata_mode_select_wakeup_state_machine(
+struct state_machine_context	*sm_contextp
+)
+{
+	DISCOVER_RESULTS	results;
+	struct asd_softc	*asd;
+	struct scb		*scb;
+	struct asd_device 	*dev;
+	struct asd_target	*target;
+	struct scsi_cmnd	*cmd;
+
+	results = asd_run_state_machine(sm_contextp);
+
+	if (results == DISCOVER_OK) {
+		/*
+		 * The state machine is still running.  We will get called
+		 * again.
+		 */
+		return;
+	}
+
+	scb = (struct scb *)sm_contextp->state_handle;
+
+	dev = scb->platform_data->dev;
+
+	target = dev->target;
+
+	asd = (struct asd_softc *)target->softc;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	if (results == DISCOVER_FINISHED) {
+		asd_cmd_set_host_status(cmd, DID_OK);
+	} else {
+		asd_cmd_set_host_status(cmd, DID_ERROR);
+	}
+
+	asd_pop_post_stack(asd, scb, NULL);
+}
+
+
+int
+asd_sata_identify_build(
+struct asd_softc	*asd,
+struct asd_target	*target,
+struct scb		*scb
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	int				dir;
+	int				error;
+	dma_addr_t			addr;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	ata_hscb->header.opcode = SCB_INITIATE_ATA_TASK;
+	ata_hscb->protocol_conn_rate = 
+		PROTOCOL_TYPE_SATA | target->ddb_profile.conn_rate;
+	ata_hscb->xfer_len = asd_htole32(sizeof(struct hd_driveid));
+
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_ATAPI:
+		asd_sata_setup_fis(ata_hscb, WIN_PIDENTIFY);
+		break;
+	case ASD_COMMAND_SET_ATA:
+		asd_sata_setup_fis(ata_hscb, WIN_IDENTIFY);
+		break;
+	default:
+		return 1;
+	}
+
+	ata_hscb->data_offset = 0;
+	ata_hscb->sister_scb = 0xffff;
+	ata_hscb->conn_handle = target->ddb_profile.conn_handle;
+	ata_hscb->retry_cnt = TASK_RETRY_CNT;
+
+	ata_hscb->ata_flags = UNTAGGED | DATA_DIR_INBOUND;
+	SET_PIO_MODE(ata_hscb);
+	ata_hscb->affiliation_policy = 0;
+
+	dir = scsi_to_pci_dma_dir(SCSI_DATA_READ);
+
+	addr = asd_map_single(asd, 
+		&target->ata_cmdset.adp_hd_driveid,
+		sizeof(struct hd_driveid), dir);
+
+	scb->platform_data->buf_busaddr = addr;
+
+	error = asd_sg_setup(scb->sg_list, addr, sizeof(struct hd_driveid),
+		1);
+
+	if (error != 0) {
+		asd_unmap_single(asd, addr, sizeof(struct hd_driveid), dir);
+
+		return 1;
+	}
+
+	scb->sg_count = 1;
+
+	memcpy(ata_hscb->sg_elements, scb->sg_list, sizeof(struct sg_element));
+
+	asd_push_post_stack(asd, scb, (void *)target, asd_sata_identify_post);
+
+	return 0;
+}
+
+/* shamelessly stolen from ide-iops.c */
+static void
+asd_sata_ide_fixstring(
+u8 *s,
+const int bytecount,
+const int byteswap
+)
+{
+	u8 *p = s, *end = &s[bytecount & ~1]; /* bytecount must be even */
+
+	if (byteswap) {
+		/* convert from big-endian to host byte order */
+		for (p = end ; p != s;) {
+			unsigned short *pp = (unsigned short *) (p -= 2);
+			*pp = ntohs(*pp);
+		}
+	}
+	/* strip leading blanks */
+	while (s != end && *s == ' ')
+		++s;
+	/* compress internal blanks and strip trailing blanks */
+	while (s != end && *s) {
+		if (*s++ != ' ' || (s != end && *s && *s != ' '))
+			*p++ = *(s-1);
+	}
+	/* wipe out trailing garbage */
+	while (p != end)
+		*p++ = '\0';
+}
+
+void
+asd_sata_identify_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	// RST - declare this on the stack for now
+	struct scsi_cmnd	cmd;
+	struct asd_target	*target;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	target = (struct asd_target *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, &cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		break;
+
+	default:
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	}
+
+	asd_sata_ide_fixstring((u8 *)&target->ata_cmdset.adp_hd_driveid.model,
+		sizeof(target->ata_cmdset.adp_hd_driveid.model), 1);
+
+	asd_sata_ide_fixstring((u8 *)&target->ata_cmdset.adp_hd_driveid.fw_rev,
+		sizeof(target->ata_cmdset.adp_hd_driveid.fw_rev), 1);
+
+	asd_sata_ide_fixstring((u8 *)&target->ata_cmdset.adp_hd_driveid.serial_no,
+		sizeof(target->ata_cmdset.adp_hd_driveid.serial_no), 1);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+
+	up(&asd->platform_data->discovery_sem);
+}
+
+int
+asd_sata_set_features_build(
+struct asd_softc	*asd,
+struct asd_target	*target,
+struct scb		*scb,
+uint8_t			feature,
+uint8_t			sector_count
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	ata_hscb->header.opcode = SCB_INITIATE_ATA_TASK;
+	ata_hscb->protocol_conn_rate = 
+		PROTOCOL_TYPE_SATA | target->ddb_profile.conn_rate;
+	ata_hscb->xfer_len = asd_htole32(sizeof(struct hd_driveid));
+
+	asd_sata_setup_fis(ata_hscb, WIN_SETFEATURES);
+
+	ASD_H2D_FIS(ata_hscb)->features = feature;
+	ASD_H2D_FIS(ata_hscb)->sector_count = sector_count;
+
+	ata_hscb->data_offset = 0;
+	ata_hscb->sister_scb = 0xffff;
+	ata_hscb->conn_handle = target->ddb_profile.conn_handle;
+	ata_hscb->retry_cnt = TASK_RETRY_CNT;
+	ata_hscb->affiliation_policy = 0;
+
+	ata_hscb->ata_flags = UNTAGGED | DATA_DIR_NO_XFER;
+	SET_NO_IO_MODE(ata_hscb);
+
+	scb->sg_count = 0;
+
+	memcpy(ata_hscb->sg_elements, scb->sg_list, sizeof(struct sg_element));
+
+	asd_push_post_stack(asd, scb, (void *)target, asd_sata_configure_post);
+
+	return 0;
+}
+
+void
+asd_sata_configure_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	// RST - declare this on the stack for now
+	struct scsi_cmnd	cmd;
+	struct asd_target	*target;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	target = (struct asd_target *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, &cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		break;
+
+	default:
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	}
+
+	asd_pop_post_stack(asd, scb, done_listp);
+
+	up(&asd->platform_data->discovery_sem);
+}
+
+/* -------------------------------------------------------------------------- */
+
+/* -----------------------------------
+ * FORMAT_UNIT: (emulated)
+ *
+ */
+ASD_COMMAND_BUILD_STATUS
+asd_sata_format_unit_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	struct scsi_cmnd		*write_cmd;
+	int			  	dir;
+	int			  	error;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	write_cmd = asd_alloc_mem(sizeof(struct scsi_cmnd), GFP_KERNEL);
+
+	if (write_cmd == NULL) {
+		asd_sata_format_unit_free_memory(asd, write_cmd);
+
+		asd_sata_set_check_condition(cmd, HARDWARE_ERROR,
+			RESOURCE_FAILURE, MEMORY_OUT_OF_SPACE);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	/*
+	 * Since this is an internal command, we can initialize these fields
+	 * to whatever we want.
+	 */
+	write_cmd->host_scribble = (unsigned char *)cmd;
+	write_cmd->sc_request = NULL;
+	write_cmd->request_buffer = NULL;
+
+	if (asd_sata_write_build(asd, dev, scb, write_cmd) != 
+		ASD_COMMAND_BUILD_OK) {
+
+		asd_sata_format_unit_free_memory(asd, write_cmd);
+
+		asd_sata_set_check_condition(cmd, HARDWARE_ERROR,
+			FORMAT_FAILED, FORMAT_COMMAND_FAILED);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	/*
+	 * We have to do this after sata_write_build, because it will initialize
+	 * scb->post also.
+	 */
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_format_unit_post);
+
+	write_cmd->use_sg = 0;
+
+	write_cmd->request_bufflen = FORMAT_WRITE_BUFFER_LEN;
+
+	write_cmd->sc_request = (Scsi_Request *)
+		asd_alloc_mem(sizeof(struct map_node), GFP_KERNEL);
+
+	if (write_cmd->sc_request == NULL) {
+
+		asd_sata_format_unit_free_memory(asd, write_cmd);
+
+		asd_sata_set_check_condition(cmd, HARDWARE_ERROR,
+			RESOURCE_FAILURE, MEMORY_OUT_OF_SPACE);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if (asd_alloc_dma_mem(asd, FORMAT_WRITE_BUFFER_LEN,
+		&write_cmd->request_buffer,
+		&scb->platform_data->buf_busaddr,
+		(bus_dma_tag_t *)&write_cmd->device,
+		(struct map_node *)write_cmd->sc_request) != 0) {
+
+		asd_sata_format_unit_free_memory(asd, write_cmd);
+
+		asd_sata_set_check_condition(cmd, HARDWARE_ERROR,
+			RESOURCE_FAILURE, MEMORY_OUT_OF_SPACE);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	memset(write_cmd->request_buffer, 0, FORMAT_WRITE_BUFFER_LEN);
+
+	write_cmd->sc_data_direction = SCSI_DATA_WRITE;
+
+	scb->sg_count = 1;
+
+	dir = scsi_to_pci_dma_dir(write_cmd->sc_data_direction);
+
+	error = asd_sg_setup(scb->sg_list, scb->platform_data->buf_busaddr,
+		FORMAT_WRITE_BUFFER_LEN, 1);
+
+	if (error != 0) {
+		asd_sata_format_unit_free_memory(asd, write_cmd);
+
+		asd_sata_set_check_condition(cmd, HARDWARE_ERROR,
+			RESOURCE_FAILURE, MEMORY_OUT_OF_SPACE);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	memcpy(ata_hscb->sg_elements, scb->sg_list,
+		scb->sg_count * sizeof(struct sg_element));
+
+	ata_hscb->ata_flags |= DATA_DIR_OUTBOUND;
+
+	write_cmd->cmnd[0] = WRITE_10;
+	write_cmd->cmnd[1] = 0;
+
+	// lba
+	write_cmd->cmnd[2] = 0;
+	write_cmd->cmnd[3] = 0;
+	write_cmd->cmnd[4] = 0;
+	write_cmd->cmnd[5] = 0;
+
+	// length
+	write_cmd->cmnd[7] = (FORMAT_SECTORS >> 8) & 0xff;
+	write_cmd->cmnd[8] = FORMAT_SECTORS & 0xff;
+	write_cmd->cmnd[9] = 0;
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+void
+asd_sata_format_unit_free_memory(
+struct asd_softc	*asd,
+struct scsi_cmnd	*write_cmd
+)
+{
+	if (write_cmd == NULL) {
+		return;
+	}
+
+	if (write_cmd->sc_request != NULL) {
+		asd_free_mem(write_cmd->sc_request);
+	}
+
+	if (write_cmd->request_buffer != NULL) {
+		asd_free_dma_mem(asd, (bus_dma_tag_t)write_cmd->device,
+			(struct map_node *)write_cmd->sc_request);
+	}
+
+	if (write_cmd->sc_request != NULL) {
+		asd_free_mem(write_cmd->sc_request);
+	}
+
+	asd_free_mem(write_cmd);
+}
+
+void
+asd_sata_format_unit_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	struct scsi_cmnd	*write_cmd;
+	struct asd_device 	*dev;
+	uint32_t		lba;
+	struct hd_driveid	*hd_driveidp;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	write_cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+
+		asd_sata_check_registers(ata_resp_edbp, scb, write_cmd);
+
+		asd_sata_format_unit_free_memory(asd, write_cmd);
+
+		scb->io_ctx = (asd_io_ctx_t)write_cmd->host_scribble;
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		break;
+
+	default:
+		asd_sata_set_check_condition(write_cmd, ILLEGAL_REQUEST,
+			FORMAT_FAILED, FORMAT_COMMAND_FAILED);
+
+		asd_sata_format_unit_free_memory(asd, write_cmd);
+
+		scb->io_ctx = (asd_io_ctx_t)write_cmd->host_scribble;
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	}
+
+	dev = scb->platform_data->dev;
+
+	hd_driveidp = &dev->target->ata_cmdset.adp_hd_driveid;
+
+	lba = (write_cmd->cmnd[2] << 24) | (write_cmd->cmnd[3] << 16) |
+		(write_cmd->cmnd[4] << 8) | write_cmd->cmnd[5];
+
+	if (lba == (hd_driveidp->lba_capacity_2 - 1)) {
+		/*
+		 * We have finished formatting the drive.
+		 */
+		asd_cmd_set_host_status(write_cmd, DID_OK);
+
+		asd_sata_format_unit_free_memory(asd, write_cmd);
+		scb->io_ctx = (asd_io_ctx_t)write_cmd->host_scribble;
+		asd_pop_post_stack(asd, scb, done_listp);
+
+		return;
+	}
+
+	lba = lba + FORMAT_SECTORS;
+
+	// lba
+	write_cmd->cmnd[2] = (lba >> 24) & 0xff;
+	write_cmd->cmnd[3] = (lba >> 16) & 0xff;
+	write_cmd->cmnd[4] = (lba >> 8) & 0xff;
+	write_cmd->cmnd[5] = lba & 0xff;
+
+	list_add_tail(&((union asd_cmd *)write_cmd)->acmd_links, &dev->busyq);
+
+	if ((dev->flags & ASD_DEV_ON_RUN_LIST) == 0) {
+
+		list_add_tail(&dev->links, &asd->platform_data->device_runq);
+
+		dev->flags |= ASD_DEV_ON_RUN_LIST;
+
+		/*
+		 * We don't need to run the device queues at this point because
+		 * asd_isr (which ulimately called this routine) will call
+		 * asd_next_device_to_run() / asd_schedule_runq() which
+		 * will schedule the runq tasklet.
+		 */
+	}
+}
+void *asd_sata_setup_data(struct asd_softc *asd, struct scb *scb, Scsi_Cmnd *cmd)
+{
+	int				dir;
+	void 			*buf_ptr;
+	struct			scatterlist *cur_seg;
+	u_int			nseg;
+
+
+	if (cmd->use_sg != 0) {
+
+		cur_seg = (struct scatterlist *)cmd->request_buffer;
+		dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+		nseg = asd_map_sg(asd, cur_seg, cmd->use_sg, dir);
+		if (nseg > ASD_NSEG) {
+			asd_unmap_sg(asd, cur_seg, nseg, dir);
+			return NULL;
+		}
+		scb->sg_count = nseg;
+		buf_ptr = (void *)(page_address(cur_seg->page) + 
+							cur_seg->offset);
+		return buf_ptr;
+
+	} 
+	else
+	{
+		return (void *) cmd->request_buffer;
+	}
+
+}
+void
+asd_sata_unmap_data(struct asd_softc *asd, struct scb *scb, Scsi_Cmnd *cmd)
+{
+	int direction;
+	struct scatterlist *sg;
+
+	direction = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+
+	if (cmd->use_sg != 0) {
+
+		sg = (struct scatterlist *)cmd->request_buffer;
+		asd_unmap_sg(asd, sg, scb->sg_count, direction);
+	} 
+}
+/* -----------------------------------
+ * INQUIRY: (emulated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_inquiry_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	struct hd_driveid		*hd_driveidp;
+	u_char				inquiry_data[INQUIRY_RESPONSE_SIZE];
+	u_char	*cmd_buf_ptr;
+	ASD_COMMAND_BUILD_STATUS	ret;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	hd_driveidp = &dev->target->ata_cmdset.adp_hd_driveid;
+
+	if (cmd->cmnd[1] & CMD_DT) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if (cmd->cmnd[1] & LUN_FIELD) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if (cmd->cmnd[1] & EVPD) {
+		ret =  asd_sata_inquiry_evd_build(asd, dev, scb, cmd,
+			inquiry_data);
+
+		return ret;
+	}
+
+	if (cmd->cmnd[2] != 0x00) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	// RST - 
+	// A good strategy for this might be to issue the 
+	// WIN_IDENTIFY &  WIN_PIDENTIFY
+	// ... we might want to set affiliation bits in the ata_hscb
+	// ... before we send them out
+
+	memset(inquiry_data, 0, INQUIRY_RESPONSE_SIZE);
+
+	inquiry_data[0] = TYPE_DISK;
+	inquiry_data[1] = (dev->target->ata_cmdset.features_state & 
+		SATA_USES_REMOVABLE) ?  SCSI_REMOVABLE : 0;
+	inquiry_data[2] = SCSI_3;
+	inquiry_data[3] = SCSI_3_RESPONSE_DATA_FORMAT;
+	inquiry_data[4] = INQUIRY_RESPONSE_SIZE - 4;
+	inquiry_data[5] = 0; // PROTECT | 3PC | ALUA | ACC | SCCS
+
+	inquiry_data[6] = 0; // ADDR16 | MCHNGR | MULTIP | ENCSERV | BQUE
+
+#ifdef TAGGED_QUEUING
+	// LINKED | SUNC | WBUS16
+	inquiry_data[7] = (target->ata_cmdset.features_state & SATA_USES_QUEUEING) ?
+		CMD_QUEUE_BIT : 0;
+#else
+	inquiry_data[7] = 0; // CMD_QUEUE_BIT | LINKED | SUNC | WBUS16
+#endif
+
+	memcpy(&inquiry_data[8], hd_driveidp->model, 8);
+	memcpy(&inquiry_data[16], hd_driveidp->model + 8, 16);
+	memcpy(&inquiry_data[32], hd_driveidp->fw_rev, 4);
+
+	inquiry_data[56] = 0;	// IUS | QAS | CLOCKING
+
+	cmd_buf_ptr=(u_char*) asd_sata_setup_data(asd, scb, cmd);
+	memcpy(cmd_buf_ptr, inquiry_data, cmd->request_bufflen);
+	asd_sata_unmap_data(asd, scb, cmd);
+
+
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_inquiry_evd_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd,
+u_char			*inquiry_data
+)
+{
+	struct hd_driveid		*hd_driveidp;
+	u_char *cmd_buf_ptr;
+
+	hd_driveidp = &dev->target->ata_cmdset.adp_hd_driveid;
+
+	memset(inquiry_data, 0, INQUIRY_RESPONSE_SIZE);
+
+	switch (cmd->cmnd[2]) {
+	case SUPPORTED_VPD:
+		inquiry_data[0] = TYPE_DISK;
+		inquiry_data[1] = SUPPORTED_VPD;
+		inquiry_data[3] = 2;
+		inquiry_data[4] = SUPPORTED_VPD;
+		inquiry_data[5] = UNIT_SERIAL_VPD;
+		break;
+
+	case UNIT_SERIAL_VPD:
+		inquiry_data[0] = TYPE_DISK;
+		inquiry_data[1] = UNIT_SERIAL_VPD;
+		inquiry_data[3] = ATA_PRODUCT_SERIAL_LENGTH;
+		memcpy(&inquiry_data[4], hd_driveidp->serial_no,
+			ATA_PRODUCT_SERIAL_LENGTH);
+		break;
+
+	default:
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+
+	cmd_buf_ptr=(u_char*) asd_sata_setup_data(asd, scb, cmd);
+	memcpy(cmd_buf_ptr, inquiry_data, cmd->request_bufflen);
+	asd_sata_unmap_data(asd, scb, cmd);
+
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+/* -----------------------------------
+ * LOG_SENSE: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_log_sense_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	unsigned			page_control;
+	struct hd_driveid		*hd_driveidp;
+
+	hd_driveidp = &dev->target->ata_cmdset.adp_hd_driveid;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	if ((cmd->cmnd[2] & PAGE_CODE_MASK) != SMART_DATA) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if ((hd_driveidp->command_set_1 & ATA_SMART_CAPABLE) == 0) {
+
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	/*
+	 * "Smart"
+	 */
+	asd_sata_setup_fis(ata_hscb, WIN_SMART);
+
+	ASD_H2D_FIS(ata_hscb)->features = SMART_READ_DATA;
+	ASD_H2D_FIS(ata_hscb)->lba1 =  0x4f;
+	ASD_H2D_FIS(ata_hscb)->lba2 =  0xc2;
+
+	page_control = cmd->cmnd[2] & ~PAGE_CODE_MASK;
+
+	switch (page_control) {
+	case PAGE_CONTROL_CUMULATIVE:
+	case PAGE_CONTROL_CURRENT:
+		break;
+	default:
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	ata_hscb->ata_flags |= DATA_DIR_INBOUND;
+	SET_PIO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_log_sense_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_log_sense_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	struct scsi_cmnd	*cmd;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	default:
+		break;
+	}
+
+	asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+/* -----------------------------------
+ * MODE_SELECT: (emulated / translated)
+ * MODE_SELECT_10: (emulated / translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_mode_select_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	unsigned			parameter_list_length;
+	unsigned			len;
+	unsigned			page_len;
+	uint8_t				*bufptr;
+	unsigned			command_translated;
+	unsigned			buf_offset;
+	ASD_COMMAND_BUILD_STATUS	ret;
+	uint8_t				page_code;
+	uint8_t				*cmd_buf_ptr;
+
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	if ((cmd->cmnd[1] & SP_BIT) || ((cmd->cmnd[1] & PF_BIT) != 0)) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+	}
+	cmd_buf_ptr=(uint8_t*) asd_sata_setup_data(asd, scb, cmd);
+
+	command_translated = 0;
+	parameter_list_length = 0;
+	page_len = 0;
+
+	switch (cmd->cmnd[0]) {
+	case MODE_SELECT:
+		parameter_list_length = cmd->cmnd[4];
+		break;
+	case MODE_SELECT_10:
+		parameter_list_length = asd_be32toh(
+			*((uint16_t *)&cmd->cmnd[7]));
+		break;
+	}
+
+	len = MIN(parameter_list_length, cmd->request_bufflen);
+
+	for (buf_offset = 0 ; buf_offset < len ; 
+		buf_offset = buf_offset + page_len ) {
+
+		bufptr = cmd_buf_ptr + buf_offset;
+
+		page_code = *bufptr;
+
+		switch (page_code) {
+		case READ_WRITE_ERROR_RECOVERY_MODE_PAGE:
+			page_len = READ_WRITE_ERROR_RECOVERY_MODE_PAGE_LEN;
+			break;
+
+		case CACHING_MODE_PAGE:
+			page_len = CACHING_MODE_PAGE_LEN;
+			break;
+
+		case CONTROL_MODE_PAGE:
+			page_len = CONTROL_MODE_PAGE_LEN;
+			break;
+
+		case INFORMATIONAL_EXCEPTION_CONTROL_PAGE:
+			page_len = INFORMATIONAL_EXCEPTION_CONTROL_PAGE_LEN;
+			break;
+		}
+
+		if ((page_len + buf_offset) > len) {
+			/*
+			 * We will fail any Page Select commands that span
+			 * over the end of our request.
+			 */
+			break;
+		}
+
+
+		switch (page_code) {
+		case READ_WRITE_ERROR_RECOVERY_MODE_PAGE:
+			ret = asd_sata_read_write_error_recovery_mode_select(
+				asd, dev, scb, bufptr);
+			break;
+
+		case CACHING_MODE_PAGE:
+			ret = asd_sata_caching_mode_select(asd, dev, scb,
+				bufptr);
+			break;
+
+		case CONTROL_MODE_PAGE:
+			ret = asd_sata_control_mode_select(asd, dev, scb,
+				bufptr);
+			break;
+
+		case INFORMATIONAL_EXCEPTION_CONTROL_PAGE:
+			ret = asd_sata_informational_exception_control_select(
+				asd, dev, scb, bufptr);
+			break;
+		default:
+			ret = ASD_COMMAND_BUILD_FAILED;
+			break;
+		}
+
+		switch (ret) {
+		case ASD_COMMAND_BUILD_OK:
+			/*
+			 * This command is being translated, so we have to
+			 * wait for it to finish.
+			 */
+			command_translated = 1;
+			break;
+
+		case ASD_COMMAND_BUILD_FINISHED:
+			/*
+			 * The command was emulated.
+			 */
+			break;
+
+		case ASD_COMMAND_BUILD_FAILED:
+		default:
+	asd_sata_unmap_data(asd, scb, cmd);
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+	}
+	asd_sata_unmap_data(asd, scb, cmd);
+	if (command_translated != 0) {
+		/*
+		 * This command is being translated, so we have to
+		 * wait for it to finish.
+		 */
+		return ASD_COMMAND_BUILD_OK;
+	}
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_read_write_error_recovery_mode_select(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+uint8_t			*bufptr
+)
+{
+	if (bufptr[1] != (READ_WRITE_ERROR_RECOVERY_MODE_PAGE_LEN - 2)) {
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	/*
+	 * T10/04-136r0: Everything about this mode select is ignored for now.
+	 */
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_caching_mode_select(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+uint8_t			*bufptr
+)
+{
+	struct asd_target			*target;
+	unsigned				state_changed;
+	unsigned				*features_enabled;
+	unsigned				*features_state;
+	DISCOVER_RESULTS			results;
+	struct asd_ConfigureATA_SM_Arguments	args;
+	struct state_machine_context		*sm_contextp;
+
+	if (bufptr[1] != (CACHING_MODE_PAGE_LEN - 2)) {
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	target = dev->target;
+
+	state_changed = 0;
+
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_ATA:
+		features_enabled = &target->ata_cmdset.features_enabled;
+		features_state = &target->ata_cmdset.features_state;
+		break;
+
+	case ASD_COMMAND_SET_ATAPI:
+		features_enabled = &target->atapi_cmdset.features_enabled;
+		features_state = &target->ata_cmdset.features_state;
+		break;
+
+	default:
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if (bufptr[12] & SCSI_DRA) {
+		if ((*features_state & SATA_USES_READ_AHEAD) == 0) {
+			state_changed = 1;
+			*features_state |= SATA_USES_READ_AHEAD;
+		}
+	} else {
+		if (*features_state & SATA_USES_READ_AHEAD) {
+			state_changed = 1;
+			*features_state &= ~SATA_USES_READ_AHEAD;
+		}
+	}
+
+	if (bufptr[2] & SCSI_WCE) {
+ 		if ((*features_state & SATA_USES_WRITE_CACHE) == 0) {
+ 			state_changed = 1;
+ 			*features_state |= SATA_USES_WRITE_CACHE;
+ 		}
+	} else {
+		if (*features_state & SATA_USES_WRITE_CACHE) {
+			state_changed = 1;
+			*features_state &= ~SATA_USES_WRITE_CACHE;
+		}
+	}
+
+	if (state_changed == 0) {
+		/*
+		 * We didn't change anything, so we are done.
+		 */
+		return ASD_COMMAND_BUILD_FINISHED;
+	}
+
+	sm_contextp = asd_alloc_mem(sizeof(struct state_machine_context),
+		GFP_KERNEL);
+
+	memset(sm_contextp, 0, sizeof(struct state_machine_context));
+
+	sm_contextp->state_handle = (void *)scb;
+
+	sm_contextp->wakeup_state_machine = 
+		asd_sata_mode_select_wakeup_state_machine;
+
+	args.target = target;
+
+	results = ASD_PUSH_STATE_MACHINE(sm_contextp,
+		&asd_ConfigureATA_SM, (void *)&args);
+
+	switch (results) {
+	case DISCOVER_FINISHED:
+		return ASD_COMMAND_BUILD_FINISHED;
+		break;
+
+	case DISCOVER_FAILED:
+	default:
+		return ASD_COMMAND_BUILD_FAILED;
+		break;
+
+	case DISCOVER_OK:
+		break;
+	}
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_control_mode_select(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+uint8_t			*bufptr
+)
+{
+	if (bufptr[1] != (CONTROL_MODE_PAGE_LEN - 2)) {
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	/*
+	 * T10/04-136r0 doesn't support this command, and Linux libata does
+	 * not support select, so we will do nothing.
+	 */
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_informational_exception_control_select(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+uint8_t			*bufptr
+)
+{
+	unsigned			*features_enabled;
+	unsigned			*features_state;
+	struct asd_target		*target;
+
+	if (bufptr[1] != (INFORMATIONAL_EXCEPTION_CONTROL_PAGE_LEN - 2)) {
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	target = dev->target;
+
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_ATA:
+		features_enabled = &target->ata_cmdset.features_enabled;
+		features_state = &target->ata_cmdset.features_state;
+		break;
+
+	case ASD_COMMAND_SET_ATAPI:
+		features_enabled = &target->atapi_cmdset.features_enabled;
+		features_state = &target->ata_cmdset.features_state;
+		break;
+
+	default:
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	/*
+	 * Sense we only support polling and we are translating, there is
+	 * nothing more to do.
+	 */
+	if (bufptr[2] & SCSI_DEXCPT) {
+		*features_state &= ~SATA_USES_SMART;
+	} else {
+		*features_state |= SATA_USES_SMART;
+	}
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+/* -----------------------------------
+ * MODE_SENSE: (emulated)
+ * MODE_SENSE_10: (emulated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_mode_sense_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	unsigned			page_code;
+	unsigned			page_control;
+	unsigned			subpage_code;
+	unsigned			allocation_length;
+	unsigned			long_lba_accepted;
+	uint8_t				*buffer;
+	uint8_t				*bufptr;
+	unsigned			transfer_length;
+	unsigned			len;
+	struct hd_driveid		*hd_driveidp;
+	u_char				*cmd_buf_ptr;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	if (cmd->cmnd[1] & DBD_BIT) {
+		/*
+		 * We don't support disabling block discriptors.
+		 */
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	page_control = cmd->cmnd[2] & PAGE_CONTROL_MASK;
+
+ 	if (page_control == PAGE_CONTROL_DEFAULT ||  page_control == PAGE_CONTROL_SAVED ) {
+		/*
+		 * We only support the current values.
+		 */
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	subpage_code = cmd->cmnd[3];
+
+	long_lba_accepted = 0;
+	transfer_length = 0;
+	allocation_length = 0;
+
+	/*
+	 * the first thing we need is a mode_parameter_header
+	 * this depends on whether we are using 6 byte or 10 byte CDBs
+	 */
+	switch (cmd->cmnd[0]) {
+	case MODE_SENSE:
+		transfer_length = MODE_PARAMETER_HEADER_LENGTH_6;
+		allocation_length = cmd->cmnd[4];
+		break;
+	case MODE_SENSE_10:
+		transfer_length = MODE_PARAMETER_HEADER_LENGTH_10;
+		long_lba_accepted = cmd->cmnd[1] & LLBA_MASK;
+		allocation_length = (cmd->cmnd[7] << 8) | cmd->cmnd[8];
+		break;
+	}
+
+	if (long_lba_accepted) {
+		transfer_length += BLOCK_DESCRIPTOR_LENGTH_8;
+	}
+	else {
+		transfer_length += BLOCK_DESCRIPTOR_LENGTH_16;
+	}
+
+	page_code = cmd->cmnd[2] & PAGE_CODE_MASK;
+
+	switch (page_code) {
+	case READ_WRITE_ERROR_RECOVERY_MODE_PAGE:
+		transfer_length += READ_WRITE_ERROR_RECOVERY_MODE_PAGE_LEN;
+		break;
+
+	case CACHING_MODE_PAGE:
+		transfer_length += CACHING_MODE_PAGE_LEN;
+		break;
+
+	case CONTROL_MODE_PAGE:
+		transfer_length += CONTROL_MODE_PAGE_LEN;
+		break;
+
+	case INFORMATIONAL_EXCEPTION_CONTROL_PAGE:
+		transfer_length += INFORMATIONAL_EXCEPTION_CONTROL_PAGE_LEN;
+		break;
+
+	case RETURN_ALL_PAGES:
+		transfer_length += 
+			READ_WRITE_ERROR_RECOVERY_MODE_PAGE_LEN + 
+			CACHING_MODE_PAGE_LEN + 
+			CONTROL_MODE_PAGE_LEN + 
+			INFORMATIONAL_EXCEPTION_CONTROL_PAGE_LEN;
+		break;
+	default:
+		/*
+		 * We don't support disabling block discriptors.
+		 */
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	len = MIN(transfer_length, cmd->request_bufflen);
+	len = MIN(len, allocation_length);
+
+	/*
+	 * We can't transfer more than the size of the buffer.
+	 */
+	cmd->request_bufflen = len;
+
+	/*
+	 * MODE_SENSE (6 byte) only supports 256 bytes of data length.  This
+	 * length doesn't include
+	 */
+	if (cmd->cmnd[0] == MODE_SENSE) {
+		/*
+		 * The length doesn't include the length field itself, so we
+		 * can have 256 bytes even though the length field only holds
+		 * 0-255.
+		 */
+		if (len > 256) {
+			len = 256;
+		}
+	}
+
+	/*
+	 * Allocate the whole length that we are going to fill in, fill the
+	 * buffer up, and then transfer back what was requested.
+	 */
+	buffer = (uint8_t *)asd_alloc_mem(transfer_length, GFP_ATOMIC);
+
+	if (buffer == NULL) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			RESOURCE_FAILURE, MEMORY_OUT_OF_SPACE);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	memset(buffer, 0, transfer_length);
+
+	bufptr = buffer;
+
+	/*
+	 * SPC-3 says that the medium type should be 0.
+	 *
+	 * MODE_SENSE:    bufptr[1] == 0
+	 * MODE_SENSE_10: bufptr[2] == 0
+	 */
+	/*
+	 * 3.10.2 and 3.11.2 of T10/04-136r0 says that DPO is ignored and that
+	 * FUA is only supported for NCQ (Native Command Queuing) drives.  We
+	 * are not supporting NCQ in this release, so the answer to DPOFUA will
+	 * be 0 for now.
+	 *
+	 * MODE_SENSE:    bufptr[2] == 0
+	 * MODE_SENSE_10: bufptr[3] == 0
+	 */
+
+	/*
+	 * Now we can fill in the response.  Start with the mode parameter 
+	 * header.
+	 */
+	switch (cmd->cmnd[0]) {
+	case MODE_SENSE:
+		bufptr[0] = len - 1;
+		bufptr[3] = 8; // only one block descriptor
+		bufptr += MODE_PARAMETER_HEADER_LENGTH_6;
+		break;
+
+	case MODE_SENSE_10:
+		bufptr[0] = ((len - 2) >> 8) & 0xff;
+		bufptr[1] = (len - 2) & 0xff;
+		bufptr[6] = 0;
+		if (long_lba_accepted) {
+			bufptr[7] = 16; // only one block descriptor
+		} else {
+			bufptr[7] = 8; // only one block descriptor
+		}
+		bufptr += MODE_PARAMETER_HEADER_LENGTH_10;
+		break;
+	}
+
+	hd_driveidp = &dev->target->ata_cmdset.adp_hd_driveid;
+
+	if (long_lba_accepted) {
+		*((uint64_t *)&bufptr[0]) =
+			ATA2SCSI_8(*((uint64_t *)&hd_driveidp->lba_capacity_2));
+
+		bufptr[8] = 0;	// density code: T10/04-136r0 - 3.21.2.1.3
+
+		*((uint32_t *)&bufptr[12]) = ATA2SCSI_4(ATA_BLOCK_SIZE);
+
+		bufptr += BLOCK_DESCRIPTOR_LENGTH_16;
+	} else {
+		*((uint32_t *)&bufptr[0]) =
+			ATA2SCSI_4(*((uint64_t *)&hd_driveidp->lba_capacity_2));
+
+		bufptr[4] = 0;	// density code: T10/04-136r0 - 3.21.2.1.3
+
+		bufptr[5] = (ATA_BLOCK_SIZE >> 16) & 0xff;
+		bufptr[6] = (ATA_BLOCK_SIZE >> 8) & 0xff;
+		bufptr[7] = ATA_BLOCK_SIZE & 0xff;
+
+		bufptr += BLOCK_DESCRIPTOR_LENGTH_8;
+	}
+
+	switch (page_code) {
+	case READ_WRITE_ERROR_RECOVERY_MODE_PAGE:
+		bufptr = asd_sata_read_write_error_recovery_sense(asd,
+			dev, bufptr);
+		break;
+
+	case CACHING_MODE_PAGE:
+ 		bufptr = asd_sata_caching_sense(asd, dev, bufptr,page_control);
+		break;
+
+	case CONTROL_MODE_PAGE:
+		bufptr = asd_sata_control_sense(asd, dev, bufptr);
+		break;
+
+	case INFORMATIONAL_EXCEPTION_CONTROL_PAGE:
+		bufptr = asd_sata_informational_exception_control_sense(asd,
+			dev, bufptr,page_control);
+		break;
+
+	case RETURN_ALL_PAGES:
+		bufptr = asd_sata_read_write_error_recovery_sense(asd,
+			dev, bufptr);
+
+ 		bufptr = asd_sata_caching_sense(asd, dev, bufptr,page_control);
+
+		bufptr = asd_sata_control_sense(asd, dev, bufptr);
+
+		bufptr = asd_sata_informational_exception_control_sense(asd,
+			dev, bufptr,page_control);
+
+		break;
+	}
+
+	cmd_buf_ptr=(u_char *) asd_sata_setup_data(asd, scb, cmd);
+	memcpy(cmd_buf_ptr, buffer, len);
+
+
+
+	asd_sata_unmap_data(asd, scb, cmd);
+
+	asd_free_mem(buffer);
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+uint8_t *
+asd_sata_read_write_error_recovery_sense(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+uint8_t			*bufptr
+)
+{
+	bufptr[0] = READ_WRITE_ERROR_RECOVERY_MODE_PAGE;	// PS == 0
+
+	bufptr[1] = READ_WRITE_ERROR_RECOVERY_MODE_PAGE_LEN - 2;
+	bufptr[2] = 0xc0;	// DCR == 0,  DTE == 0, PER == 0, ERR == 0
+				// RC == 0, TB == 0, ARRE == 1, AWRE == 1
+
+	bufptr[3] = 0x00;	// READ_RETRY_COUNT == 0
+	bufptr[8] = 0x00;	// WRITE_RETRY_COUNT == 0
+
+	bufptr[10] = 0x00;	// RECOVERY_TIME_LIMIT == 0
+	bufptr[11] = 0x00;
+
+	return bufptr + bufptr[1] + 2;
+}
+
+uint8_t *
+asd_sata_caching_sense(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+uint8_t			*bufptr,
+unsigned			page_control
+)
+{
+	struct hd_driveid		*hd_driveidp;
+	unsigned			features_state;
+	unsigned			features_enabled;
+	struct asd_target		*target;
+
+	target = dev->target;
+
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_ATA:
+		hd_driveidp = &target->ata_cmdset.adp_hd_driveid;
+		features_state = target->ata_cmdset.features_state;
+		features_enabled = target->ata_cmdset.features_enabled;
+		break;
+
+	case ASD_COMMAND_SET_ATAPI:
+		hd_driveidp = &target->atapi_cmdset.adp_hd_driveid;
+		features_state = target->atapi_cmdset.features_state;
+		features_enabled = target->ata_cmdset.features_enabled;
+		break;
+
+	default:
+		return bufptr + CACHING_MODE_PAGE_LEN;
+	}
+
+	bufptr[0] = CACHING_MODE_PAGE;	// PS == 0
+	bufptr[1] = CACHING_MODE_PAGE_LEN - 2;
+
+	bufptr[2] = 0;
+
+	if(page_control == PAGE_CONTROL_CURRENT)
+	{
+		if (features_state & SATA_USES_WRITE_CACHE) {
+			/* 
+			 * RCD == 0, MF == 0, SIZE == 0, DISC == 0,
+			 * CAP == 0, ABPF == 0, IC == 0
+			 */
+			/*
+			 * After drive reset, we should re-issue IDENTIFY.
+			 */
+			bufptr[2] |= SCSI_WCE;
+		} else {
+			bufptr[2] &= ~SCSI_WCE;
+		}
+	} else
+	{
+		if(features_enabled & WRITE_CACHE_FEATURE_ENABLED)
+		{
+			bufptr[2] |= SCSI_WCE;
+		}
+		else
+		{
+			bufptr[2] &= ~SCSI_WCE;
+		}
+	}
+
+	bufptr[3] = 0;  // DEMAND_READ_RETENTION_PROPERTY == 0
+			// WRITE_RETENTION_PROPERTY == 0
+
+	bufptr[4] = 0;	// DISABLE_PRE_FETCH_TRANSFER_LENGTH == 0
+	bufptr[5] = 0;
+
+	bufptr[6] = 0;	// MINIMUM_PRE_FETCH == 0
+	bufptr[7] = 0;
+
+	bufptr[8] = 0;	// MAXIMUM_PRE_FETCH == 0
+	bufptr[9] = 0;
+
+	bufptr[10] = 0;	// MAXIMUM_PRE_FETCH_CEILING == 0
+	bufptr[11] = 0;
+
+	bufptr[12] = 0;
+
+	if(page_control == PAGE_CONTROL_CURRENT)
+	{
+ 		if ((features_state & SATA_USES_READ_AHEAD) == 0) {
+			/*
+			 * NV_DIS == 0, FSW == 0, LBCSS == 0, FSW == 0
+			 */
+			/*
+			 * After drive reset, we should re-issue IDENTIFY.
+			 */
+			bufptr[12] |= SCSI_DRA;
+		} else {
+			bufptr[12] &= ~SCSI_DRA;
+		}
+	} else
+	{
+
+		if ((features_enabled & READ_AHEAD_FEATURE_ENABLED) == 0)
+		{
+			bufptr[12] |= SCSI_DRA;
+		}
+		else
+		{
+			bufptr[12] &= ~SCSI_DRA;
+		}
+	}
+
+	bufptr[13] = 0;	// NUMBER_OF_CACHE_SEGMENTS == 0
+
+	bufptr[14] = 0;	// CACHE_SEGMENT_SIZE == 0
+	bufptr[15] = 0;
+
+	bufptr[17] = 0;	// NON_CACHE_SEGMENT_SIZE == 0
+	bufptr[18] = 0;
+	bufptr[19] = 0;
+
+	return bufptr + bufptr[1] + 2;
+}
+
+uint8_t *
+asd_sata_control_sense(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+uint8_t			*bufptr
+)
+{
+	bufptr[0] = CONTROL_MODE_PAGE;
+	bufptr[1] = CONTROL_MODE_PAGE_LEN - 2;
+	bufptr[2] = 2;		// RLEC == 0, GLTSD == 0, D_SENSE == 0, TST == 0
+	bufptr[3] = 0;		// QERR == 0, QUEUE_ALGORITHM_MODIFIER == 0
+	bufptr[4] = 0;		// SWP == 0, UA_INTLCK_CTRL == 0, 
+				// RAC == 0, TAS== 0
+	bufptr[5] = 0;		// AUTOLOAD_MODE == 0, APTG_OWN == 0
+
+	bufptr[8] = 0xff;
+	bufptr[9] = 0xff;
+	bufptr[10] = 0;
+	bufptr[11] = 30;
+
+	return bufptr + bufptr[1] + 2;
+}
+
+uint8_t *
+asd_sata_informational_exception_control_sense(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+uint8_t			*bufptr,
+unsigned			page_control
+)
+{
+	struct hd_driveid		*hd_driveidp;
+	unsigned			features_state;
+	unsigned			features_enabled;
+	struct asd_target		*target;
+
+	target = dev->target;
+
+	switch (target->command_set_type) {
+	case ASD_COMMAND_SET_ATA:
+		hd_driveidp = &target->ata_cmdset.adp_hd_driveid;
+		features_state = target->ata_cmdset.features_state;
+		features_enabled = target->ata_cmdset.features_enabled;
+		break;
+
+	case ASD_COMMAND_SET_ATAPI:
+		hd_driveidp = &target->atapi_cmdset.adp_hd_driveid;
+		features_state = target->atapi_cmdset.features_state;
+		features_enabled = target->ata_cmdset.features_enabled;
+		break;
+
+	default:
+		return bufptr + INFORMATIONAL_EXCEPTION_CONTROL_PAGE_LEN;
+	}
+
+	bufptr[0] = INFORMATIONAL_EXCEPTION_CONTROL_PAGE;	// PS == 0
+	bufptr[1] = INFORMATIONAL_EXCEPTION_CONTROL_PAGE_LEN - 2;
+
+	if(page_control ==PAGE_CONTROL_CURRENT)
+	{
+		
+		if ((features_state & SATA_USES_SMART) == 0) {
+			/*
+			 * LOGERR == 0, TEST == 0, EWASC == 0, EBF == 0, PERF == 0
+			 */
+			bufptr[2] |= SCSI_DEXCPT;		// disabled
+		}
+	}
+	else
+	{
+		if (features_enabled & SMART_FEATURE_ENABLED)
+		{
+
+			/*
+			 * LOGERR == 0, TEST == 0, EWASC == 0, EBF == 0, PERF == 0
+			 */
+			bufptr[2] |= SCSI_DEXCPT;		// enabled
+		}
+
+	}
+
+	bufptr[3] = 0x06;	// MRIE - report on request
+
+	bufptr[4] = 0;	// INTERVAL_TIMER == 0
+	bufptr[5] = 0;
+	bufptr[6] = 0;
+	bufptr[7] = 0;
+
+	bufptr[8] = 0;	// REPORT_COUNT == 0
+	bufptr[9] = 0;
+	bufptr[10] = 0;
+	bufptr[11] = 0;
+
+	return bufptr + bufptr[1] + 2;
+}
+
+/* -----------------------------------
+ * READ_6: (translated)
+ * READ_10: (translated)
+ * READ_12: (translated)
+ */
+
+// RST - we need a tag somehow
+ASD_COMMAND_BUILD_STATUS
+asd_sata_read_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	uint32_t			lba;
+	unsigned			sectors;
+	unsigned			fis_command;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	switch (cmd->cmnd[0]) {
+	case READ_6:
+		lba = (cmd->cmnd[2] << 8) | cmd->cmnd[3];
+		sectors = cmd->cmnd[4];
+
+		break;
+
+	case READ_10:
+		if (cmd->cmnd[9] != 0) {
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+		}
+
+		lba = (cmd->cmnd[2] << 24) | (cmd->cmnd[3] << 16) |
+			(cmd->cmnd[4] << 8) | cmd->cmnd[5];
+		sectors = (cmd->cmnd[7] << 8) | cmd->cmnd[8];
+
+		break;
+
+	case READ_12:
+		if (cmd->cmnd[11] != 0) {
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+		}
+
+		lba = (cmd->cmnd[2] << 24) | (cmd->cmnd[3] << 16) |
+			(cmd->cmnd[4] << 8) | cmd->cmnd[5];
+		sectors = (cmd->cmnd[6] << 24) | (cmd->cmnd[7] << 16) |
+			(cmd->cmnd[8] << 8) | cmd->cmnd[9];
+
+		break;
+
+	default:
+		lba = 0;
+		sectors = 0;
+		break;
+	}
+
+	switch (cmd->cmnd[0]) {
+	case READ_10:
+	case READ_12:
+		if (cmd->cmnd[1] & 0x01) {
+			/*
+			 * Obsolete field that we will fail.
+			 */
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+
+		if (sectors == 0) {
+			asd_cmd_set_host_status(cmd, DID_OK);
+
+			return ASD_COMMAND_BUILD_FINISHED;
+		}
+	}
+
+	fis_command = 0;
+
+	// RST - what about FUA??
+
+	switch (dev->target->ata_cmdset.features_state & 
+		(SATA_USES_DMA | SATA_USES_48BIT | SATA_USES_QUEUEING)) {
+	case 0:
+		fis_command = WIN_READ;
+		break;
+	case SATA_USES_DMA:
+		fis_command = WIN_READDMA;
+		break;
+	case SATA_USES_48BIT:
+		fis_command = WIN_READ_EXT;
+		break;
+	case SATA_USES_QUEUEING:
+		// Doesn't exist;
+		break;
+	case SATA_USES_DMA | SATA_USES_48BIT:
+		fis_command = WIN_READDMA_EXT;
+		break;
+	case SATA_USES_DMA | SATA_USES_QUEUEING:
+		// RST - sector and feature are swapped for this command
+		fis_command = WIN_READDMA_QUEUED;
+		break;
+	case SATA_USES_48BIT | SATA_USES_QUEUEING:
+		// Doesn't exist
+		break;
+	case SATA_USES_DMA | SATA_USES_48BIT | SATA_USES_QUEUEING:
+		// RST - sector and feature are swapped for this command
+		fis_command = WIN_READDMA_QUEUED_EXT;
+		break;
+	default:
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	asd_sata_setup_fis(ata_hscb, fis_command);
+
+	if (dev->target->ata_cmdset.features_state & SATA_USES_DMA) {
+		SET_DMA_MODE(ata_hscb);
+	} else {
+		SET_PIO_MODE(ata_hscb);
+	}
+
+	if (dev->target->ata_cmdset.features_state & SATA_USES_48BIT) {
+
+		asd_sata_setup_lba_ext(ata_hscb, lba, sectors);
+
+	} else {
+		if (lba >= RW_DMA_LBA_SIZE) {
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+
+		if (sectors > RW_DMA_MAX_SECTORS) {
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+
+		if (sectors == RW_DMA_MAX_SECTORS) {
+			sectors = 0;
+		}
+
+		asd_sata_setup_lba(ata_hscb, lba, sectors);
+	}
+
+	ata_hscb->ata_flags |= DATA_DIR_INBOUND;
+
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_read_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_read_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb		*ata_resp_edbp;
+	struct scsi_cmnd		*cmd;
+#if 0
+	unsigned			sectors;
+	uint32_t			lba;
+	struct asd_ata_task_hscb	*ata_hscb;
+	unsigned			remain;
+#endif
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+#if 0
+	ata_hscb = &scb->hscb->ata_task;
+#endif
+
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		break;
+
+	default:
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_COMMAND_OPERATION, 0);
+
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	}
+
+#if 0
+	if (remain > 0) {
+
+		sectors = remain / RW_DMA_MAX_SECTORS ;
+
+		if (sectors >= RW_DMA_MAX_SECTORS) {
+			scb->transfer_length = RW_DMA_MAX_SECTORS *
+				ATA_BLOCK_SIZE;
+
+			sectors = 0;
+		} else {
+
+			scb->transfer_length = remain;
+		}
+
+
+		lba = (ASD_H2D_FIS(ata_hscb)->lba2  << 16) |
+			(ASD_H2D_FIS(ata_hscb)->lba1 << 8) |
+			(ASD_H2D_FIS(ata_hscb)->lba0);
+
+		lba = lba + sectors;
+
+		printk("%s:%d: finishing request lba 0x%x sectors 0x%x\n",
+			__FUNCTION__, __LINE__,
+			lba, sectors);
+
+		asd_sata_setup_lba(ata_hscb, lba, sectors);
+
+		asd_hwi_post_scb(asd, scb);
+
+		return;
+	}
+#endif
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+/* -----------------------------------
+ * WRITE_BUFFER: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_write_buffer_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	unsigned			buffer_offset;
+	unsigned			len;
+	unsigned			allocation_length;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	if ((dev->target->ata_cmdset.features_state & 
+		SATA_USES_WRITE_BUFFER) == 0) {
+
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if ((cmd->cmnd[1] & BUFFER_MODE_MASK) != DATA_ONLY_MODE) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	/*
+	 * Only support Buffer ID of 0
+	 */
+	if (cmd->cmnd[2] != 0) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	buffer_offset = 
+		(cmd->cmnd[3] << 16) | (cmd->cmnd[4] << 8) | cmd->cmnd[5];
+
+	if (buffer_offset >= ATA_BUFFER_SIZE) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	allocation_length = 
+		(cmd->cmnd[6] << 16) | (cmd->cmnd[7] << 8) | cmd->cmnd[8];
+
+	len = MIN(ATA_BUFFER_SIZE - buffer_offset, cmd->request_bufflen);
+	len = MIN(len, allocation_length);
+
+	/*
+	 * We can't transfer more than the size of the buffer.
+	 */
+	cmd->request_bufflen = len;
+
+	asd_sata_setup_fis(ata_hscb, WIN_WRITE_BUFFER);
+
+	ata_hscb->ata_flags |= DATA_DIR_OUTBOUND;
+	SET_PIO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_write_buffer_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_write_buffer_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	struct scsi_cmnd	*cmd;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	default:
+		break;
+	}
+
+	asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+/* -----------------------------------
+ * READ_BUFFER: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_read_buffer_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	uint8_t				*read_buffer_descriptor;
+	unsigned			buffer_offset;
+	unsigned			allocation_length;
+	unsigned			len;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	if ((dev->target->ata_cmdset.features_state & 
+		SATA_USES_READ_BUFFER) == 0) {
+
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if (cmd->cmnd[2] != 0) {
+		/*
+		 * We are only supporting 1 buffer ID (== 0).
+		 */
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	allocation_length = 0;
+
+	if ((cmd->cmnd[1] & BUFFER_MODE_MASK) == DESCRIPTOR_MODE) {
+
+		if (cmd->request_bufflen < READ_BUFFER_DESCRIPTOR_LENGTH) {
+
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+
+	read_buffer_descriptor = (uint8_t *)asd_sata_setup_data(asd, scb, cmd);
+ 		memset(read_buffer_descriptor, 0, 
+			READ_BUFFER_DESCRIPTOR_LENGTH);
+	asd_sata_unmap_data(asd, scb, cmd);
+
+
+
+		/*
+		 * ATA only supports ATA_BUFFER_SIZE byte buffer writes.
+		 */
+		read_buffer_descriptor[0] = 0;
+		read_buffer_descriptor[1] = (ATA_BUFFER_SIZE >> 16) & 0xff;
+		read_buffer_descriptor[2] = (ATA_BUFFER_SIZE >> 8) & 0xff;
+		read_buffer_descriptor[3] = ATA_BUFFER_SIZE & 0xff;
+
+		asd_cmd_set_host_status(cmd, DID_OK);
+
+		return ASD_COMMAND_BUILD_FINISHED;
+	}
+
+	if ((cmd->cmnd[1] & BUFFER_MODE_MASK) != DATA_ONLY_MODE) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	buffer_offset = 
+		(cmd->cmnd[3] << 16) | (cmd->cmnd[4] << 8) | cmd->cmnd[5];
+
+	if (buffer_offset >= ATA_BUFFER_SIZE) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	len = MIN(ATA_BUFFER_SIZE - buffer_offset, cmd->request_bufflen);
+	len = MIN(len, allocation_length);
+
+	/*
+	 * We can't transfer more than the size of the buffer.
+	 */
+	cmd->request_bufflen = len;
+
+	asd_sata_setup_fis(ata_hscb, WIN_READ_BUFFER);
+
+	ata_hscb->ata_flags |= DATA_DIR_INBOUND;
+	SET_PIO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_read_buffer_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_read_buffer_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	struct scsi_cmnd	*cmd;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	default:
+		break;
+	}
+
+	asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+/* -----------------------------------
+ * READ_CAPACITY: (emulated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_read_capacity_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	struct hd_driveid		*hd_driveidp;
+	u_char				*read_capacity_data;
+	uint64_t			lba_capacity;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	hd_driveidp = &dev->target->ata_cmdset.adp_hd_driveid;
+
+	if (cmd->request_bufflen < READ_CAPACITY_DATA_LEN) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	read_capacity_data = (u_char *)asd_sata_setup_data(asd, scb, cmd);
+
+	lba_capacity = *((uint64_t *)&hd_driveidp->lba_capacity_2);
+
+	if (dev->target->ata_cmdset.features_state & SATA_USES_48BIT) {
+
+		lba_capacity = *((uint64_t *)&hd_driveidp->lba_capacity_2);
+	}
+
+	/*
+	 * Ignore the Logical Block Address field and the PMI bit
+	 */
+	if (lba_capacity == 0) {
+		lba_capacity = *((uint32_t *)&hd_driveidp->lba_capacity);
+	}
+
+	if (lba_capacity == 0) {
+		lba_capacity = hd_driveidp->cyls * hd_driveidp->heads *
+			hd_driveidp->sectors;
+	}
+
+	*((uint32_t *)&read_capacity_data[0]) = ATA2SCSI_4(lba_capacity - 1);
+
+	*((uint32_t *)&read_capacity_data[4]) = ATA2SCSI_4(ATA_BLOCK_SIZE);
+ 	asd_sata_unmap_data(asd, scb, cmd);
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+/* -----------------------------------
+ * REPORT_LUNS: (emulated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_report_luns_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	u_char		report_luns_data[REPORT_LUNS_SIZE];
+	unsigned	len;
+	u_char		*cmd_buf_ptr;
+
+	memset(report_luns_data, 0, REPORT_LUNS_SIZE);
+
+	*((uint32_t *)&report_luns_data[0]) = asd_htobe32(8);
+
+	len = MIN(cmd->request_bufflen, REPORT_LUNS_SIZE);
+
+	cmd_buf_ptr = (u_char *)asd_sata_setup_data(asd, scb, cmd);
+	memcpy(cmd_buf_ptr, &report_luns_data[0], len);
+	asd_sata_unmap_data(asd, scb, cmd);
+
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+/* -----------------------------------
+ * REQUEST_SENSE: (emulated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_request_sense_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+/* -----------------------------------
+ * REZERO_UNIT: (emulated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_rezero_unit_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+/* -----------------------------------
+ * SEEK_6: (emulated)
+ * SEEK_10: (emulated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_seek_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	switch (cmd->cmnd[0]) {
+	case SEEK_6:
+	case SEEK_10:
+		break;
+	}
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	return ASD_COMMAND_BUILD_FINISHED;
+}
+
+/* -----------------------------------
+ * SEND_DIAGNOSTIC: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_send_diagnostic_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	/*
+	 * "Execute Device Diagnostic"
+	 */
+	asd_sata_setup_fis(ata_hscb, WIN_DIAGNOSE);
+
+	ata_hscb->ata_flags |= DATA_DIR_NO_XFER;
+	SET_NO_IO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)cmd,
+		asd_sata_send_diagnostic_post);
+
+	if ((cmd->cmnd[1] & SELFTEST) == 0) {
+
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if ((cmd->cmnd[1] & SELFTEST_CODE_MASK) != 0) {
+
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_COMMAND_OPERATION, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_send_diagnostic_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp=NULL;
+	struct scsi_cmnd	*cmd;
+	COMMAND_SET_TYPE	command_set_type;
+	struct asd_device	*dev;
+	unsigned		error;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	dev = scb->platform_data->dev;
+
+	switch (done_listp->opcode) {
+	case TASK_COMP_WO_ERR:
+		break;
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	default:
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_COMMAND_OPERATION, 0);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	}
+
+	if(ata_resp_edbp !=NULL)
+	{
+		command_set_type = asd_sata_get_type(ASD_D2H_FIS(ata_resp_edbp));
+	}
+	else
+	{
+		command_set_type=ASD_COMMAND_SET_UNKNOWN;
+	}
+
+	if (command_set_type != dev->target->command_set_type) {
+		/*
+		 * Signatures don't match.
+		 */
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_COMMAND_OPERATION, 0);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	}
+
+	asd_pop_post_stack(asd, scb, done_listp);
+
+	error = ASD_D2H_FIS(ata_resp_edbp)->error;
+	
+	if (error == 0x01) {
+		/*
+		 * device 0 passed
+		 */
+		asd_cmd_set_host_status(cmd, DID_OK);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	}
+
+	if ((error == 0x00) || (error > 0x02)) {
+		/*
+		 * The device failed internal tests.
+		 */
+		asd_sata_set_check_condition(cmd, HARDWARE_ERROR,
+			LOGICAL_UNIT_FAILURE, FAILED_SELF_TEST);
+
+		asd_pop_post_stack(asd, scb, done_listp);
+
+		return;
+	}
+
+	asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+/* -----------------------------------
+ * START_STOP: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_start_stop_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	if (cmd->cmnd[4] & START_STOP_LOEJ) {
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	if (cmd->cmnd[4] & START_STOP_START) {
+		asd_sata_setup_fis(ata_hscb, WIN_IDLEIMMEDIATE);
+	} else {
+		/*
+		 * "Standby Immediate"
+		 */
+		asd_sata_setup_fis(ata_hscb, WIN_STANDBYNOW1);
+	}
+
+	ata_hscb->ata_flags |= DATA_DIR_NO_XFER;
+	SET_NO_IO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)cmd, asd_sata_start_stop_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_start_stop_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	struct scsi_cmnd	*cmd;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	default:
+		break;
+	}
+
+	asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+/* -----------------------------------
+ * SYNCHRONIZE_CACHE: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_synchronize_cache_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	asd_sata_setup_fis(ata_hscb, WIN_FLUSH_CACHE);
+
+	ata_hscb->ata_flags |= DATA_DIR_NO_XFER;
+	SET_NO_IO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)cmd,
+		asd_sata_synchronize_cache_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_synchronize_cache_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb	*ata_resp_edbp;
+	struct scsi_cmnd	*cmd;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	default:
+		break;
+	}
+
+	asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_COMMAND_OPERATION, 0);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+/* -----------------------------------
+ * TEST_UNIT_READY: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_test_unit_ready_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	struct hd_driveid		*hd_driveidp;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	hd_driveidp = &dev->target->ata_cmdset.adp_hd_driveid;
+
+	if ((hd_driveidp->command_set_1 & POWER_MANAGEMENT_SUPPORTED) == 0) {
+
+		asd_cmd_set_host_status(cmd, DID_OK);
+
+		return ASD_COMMAND_BUILD_FINISHED;
+	}
+
+	asd_sata_setup_fis(ata_hscb, WIN_CHECKPOWERMODE1);
+
+	ata_hscb->ata_flags |= DATA_DIR_NO_XFER;
+	SET_NO_IO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)cmd,
+		asd_sata_test_unit_ready_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+
+void
+asd_sata_test_unit_ready_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb		*ata_resp_edbp;
+	struct scsi_cmnd		*cmd;
+	struct asd_ata_task_hscb	*ata_hscb;
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+	switch (done_listp->opcode) {
+	case TASK_COMP_WO_ERR:
+		break;
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	default:
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_COMMAND_OPERATION, 0);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+	}
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	switch (ASD_H2D_FIS(ata_hscb)->sector_count) {
+#if 0
+	// RST - this doesn't seem to work
+	case ATA_STANDBY_MODE:
+		asd_sata_set_check_condition(cmd, NOT_READY,
+			LOGICAL_UNIT_NOT_READY, NOTIFY_REQUIRED);
+		break;
+#endif
+
+	default:
+	case ATA_IDLE_MODE:
+	case ATA_ACTIVE:
+		asd_cmd_set_host_status(cmd, DID_OK);
+		break;
+	}
+
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+
+#ifdef T10_04_136
+/* -----------------------------------
+ * VERIFY: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_verify_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	if (target->ata_cmdset.features_state & SATA_USES_48BIT) {
+		asd_sata_setup_fis(ata_hscb, WIN_VERIFY_EXT);
+	} else {
+		asd_sata_setup_fis(ata_hscb, WIN_VERIFY);
+	}
+
+	ata_hscb->ata_flags |= DATA_DIR_NO_XFER;
+	SET_NO_IO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)acmd,
+		asd_sata_verify_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_verify_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	// RST - fill this in
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+#endif
+
+
+/* -----------------------------------
+ * WRITE_6: (translated)
+ * WRITE_10: (translated)
+ * WRITE_12: (translated)
+ */
+
+// RST - we need a tag somehow
+ASD_COMMAND_BUILD_STATUS
+asd_sata_write_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	uint32_t			lba;
+	unsigned			sectors;
+	unsigned			fis_command;
+	unsigned			fua_bit;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	switch (cmd->cmnd[0]) {
+	case WRITE_6:
+		lba = (cmd->cmnd[2] << 8) | cmd->cmnd[3];
+		sectors = cmd->cmnd[4];
+
+		break;
+
+	case WRITE_10:
+		lba = (cmd->cmnd[2] << 24) | (cmd->cmnd[3] << 16) |
+			(cmd->cmnd[4] << 8) | cmd->cmnd[5];
+		sectors = (cmd->cmnd[7] << 8) | cmd->cmnd[8];
+
+		break;
+
+	case WRITE_12:
+		lba = (cmd->cmnd[2] << 24) | (cmd->cmnd[3] << 16) |
+			(cmd->cmnd[4] << 8) | cmd->cmnd[5];
+		sectors = (cmd->cmnd[6] << 24) | (cmd->cmnd[7] << 16) |
+			(cmd->cmnd[8] << 8) | cmd->cmnd[9];
+
+		break;
+	default:
+		lba = 0;
+		sectors = 0;
+	}
+
+	fua_bit = 0;
+
+	switch (cmd->cmnd[0]) {
+	case WRITE_10:
+	case WRITE_12:
+		if (cmd->cmnd[1] & 0x01) {
+			/*
+			 * Obsolete field that we will fail.
+			 */
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+
+		if (sectors == 0) {
+			asd_cmd_set_host_status(cmd, DID_OK);
+
+			return ASD_COMMAND_BUILD_FINISHED;
+		}
+
+		if ((dev->target->ata_cmdset.features_state & 
+			SATA_USES_WRITE_FUA) != 0) {
+
+			fua_bit = cmd->cmnd[1] & SCSI_WRITE_FUA_BIT;
+		}
+		break;
+	}
+
+	fis_command = 0;
+
+	switch (dev->target->ata_cmdset.features_state & 
+		(SATA_USES_DMA | SATA_USES_48BIT | SATA_USES_QUEUEING)) {
+	case 0:
+		fis_command = WIN_WRITE;
+		break;
+	case SATA_USES_DMA:
+		fis_command = WIN_WRITEDMA;
+		break;
+	case SATA_USES_48BIT:
+		fis_command = WIN_WRITE_EXT;
+		break;
+	case SATA_USES_QUEUEING:
+		// Doesn't exist;
+		break;
+	case SATA_USES_DMA | SATA_USES_48BIT:
+		if (fua_bit) {
+			fis_command = WIN_WRITE_DMA_FUA_EXT;
+		} else {
+			fis_command = WIN_WRITEDMA_EXT;
+		}
+		break;
+	case SATA_USES_DMA | SATA_USES_QUEUEING:
+		fis_command = WIN_WRITEDMA_QUEUED;
+		break;
+	case SATA_USES_48BIT | SATA_USES_QUEUEING:
+		// Doesn't exist
+		break;
+	case SATA_USES_DMA | SATA_USES_48BIT | SATA_USES_QUEUEING:
+		if (fua_bit) {
+			fis_command = WIN_WRITE_DMA_QUEUED_FUA_EXT;
+		} else {
+			fis_command = WIN_WRITEDMA_QUEUED_EXT;
+		}
+		break;
+	default:
+		fis_command = 0;
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+			INVALID_FIELD_IN_CDB, 0);
+		return ASD_COMMAND_BUILD_FAILED;
+	}
+
+	asd_sata_setup_fis(ata_hscb, fis_command);
+
+	if (dev->target->ata_cmdset.features_state & SATA_USES_DMA) {
+		SET_DMA_MODE(ata_hscb);
+	} else {
+		SET_PIO_MODE(ata_hscb);
+	}
+
+	if (dev->target->ata_cmdset.features_state & SATA_USES_48BIT) {
+
+		asd_sata_setup_lba_ext(ata_hscb, lba, sectors);
+
+	} else {
+		if (lba >= RW_DMA_LBA_SIZE) {
+
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+
+		if (sectors > RW_DMA_MAX_SECTORS) {
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+
+		if (sectors == RW_DMA_MAX_SECTORS) {
+			sectors = 0;
+		}
+
+		asd_sata_setup_lba(ata_hscb, lba, sectors);
+	}
+
+	ata_hscb->ata_flags |= DATA_DIR_OUTBOUND;
+
+	asd_push_post_stack(asd, scb, (void *)cmd,
+		asd_sata_write_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_write_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	struct ata_resp_edb		*ata_resp_edbp;
+	struct scsi_cmnd		*cmd;
+#if 0
+	uint32_t			lba;
+	struct asd_ata_task_hscb	*ata_hscb;
+	unsigned			sectors;
+#endif
+	u_int			 edb_index;
+	struct scb 		 *escb;
+
+	cmd = (struct scsi_cmnd *)scb->io_ctx;
+
+#if 0
+	ata_hscb = &scb->hscb->ata_task;
+#endif
+
+	switch (done_listp->opcode) {
+	case ATA_TASK_COMP_W_RESP:
+		ata_resp_edbp = asd_sata_get_edb(asd, done_listp,&escb, &edb_index);
+		asd_sata_check_registers(ata_resp_edbp, scb, cmd);
+		asd_hwi_free_edb(asd, escb, edb_index);
+		asd_pop_post_stack(asd, scb, done_listp);
+		return;
+
+	case TASK_COMP_WO_ERR:
+		break;
+
+	default:
+		asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_COMMAND_OPERATION, 0);
+
+		asd_pop_post_stack(asd, scb, done_listp);
+
+		return;
+	}
+
+#if 0
+	if (scb->sectors_remaining != 0) {
+
+		sectors = scb->sectors_remaining;
+
+		if (sectors >= RW_DMA_MAX_SECTORS) {
+			scb->sectors_remaining = 
+				scb->sectors_remaining - RW_DMA_MAX_SECTORS;
+
+			sectors = 0;
+		} else {
+
+			scb->sectors_remaining = 0;
+		}
+
+		lba = (ASD_H2D_FIS(ata_hscb)->lba2  << 16) |
+			(ASD_H2D_FIS(ata_hscb)->lba1 << 8) |
+			(ASD_H2D_FIS(ata_hscb)->lba0);
+
+		lba = lba + sectors;
+
+		printk("%s:%d: finishing request lba 0x%x sectors 0x%x "
+			"remaining 0x%x\n",
+			__FUNCTION__, __LINE__,
+			lba, sectors, scb->sectors_remaining);
+
+		asd_sata_setup_lba(ata_hscb, lba, sectors);
+
+		ret = asd_setup_data(asd, scb, cmd);
+
+		asd_hwi_post_scb(asd, scb);
+
+
+		return;
+	}
+#endif
+
+	asd_cmd_set_host_status(cmd, DID_OK);
+
+	asd_pop_post_stack(asd, scb, done_listp);
+
+	return;
+}
+
+#ifdef T10_04_136
+/* -----------------------------------
+ * WRITE_VERIFY: (translated)
+ */
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_write_verify_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+)
+{
+	struct asd_ata_task_hscb	*ata_hscb;
+	uint32_t			lba;
+	unsigned			sectors;
+
+	ata_hscb = &scb->hscb->ata_task;
+
+	lba = (cmd->cmnd[2] << 24) | (cmd->cmnd[3] << 16) |
+		(cmd->cmnd[4] << 8) | cmd->cmnd[5];
+
+	sectors = (cmd->cmnd[7] << 8) | cmd->cmnd[8];
+
+	// RST - this should be a WRITE with FUA followed by a read verify.
+	// ... we will want to set affiliation bits in the ata_hscb
+
+	if (target->ata_cmdset.features_state & SATA_USES_48BIT) {
+		/*
+		 * Read Verify Sectors
+		 */
+		asd_sata_setup_fis(ata_hscb, WIN_VERIFY_EXT);
+	} else {
+		if (sectors > RW_DMA_MAX_SECTORS) {
+			asd_sata_set_check_condition(cmd, ILLEGAL_REQUEST,
+				INVALID_FIELD_IN_CDB, 0);
+
+			return ASD_COMMAND_BUILD_FAILED;
+		}
+
+		if (sectors == RW_DMA_MAX_SECTORS) {
+			sectors = 0;
+		}
+
+		asd_sata_setup_fis(ata_hscb, WIN_VERIFY);
+	}
+
+	ata_hscb->ata_flags |= DATA_DIR_NO_XFER;
+	SET_NO_IO_MODE(ata_hscb);
+
+	asd_push_post_stack(asd, scb, (void *)acmd,
+		asd_sata_write_verify_post);
+
+	return ASD_COMMAND_BUILD_OK;
+}
+
+void
+asd_sata_write_verify_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+)
+{
+	asd_pop_post_stack(asd, scb, done_listp);
+}
+#endif
+
+#if 0
+void
+asd_print_hex(
+unsigned char	*s,
+unsigned	len
+)
+{
+	unsigned	i;
+	unsigned	count;
+
+	while (len != 0) {
+		count = (len > 16) ? 16 : len;
+
+		for (i = 0 ; i < count ; i++) {
+			printk("%02x ", *(s + i));
+		}
+
+		for ( ; i < 16 ; i++) {
+			printk("   ");
+		}
+
+		for (i = 0 ; i < count ; i++) {
+			if (((*(s + i) >= 'a') && (*(s + i) <= 'z')) ||
+			    ((*(s + i) >= 'A') && (*(s + i) <= 'Z')) ||
+			    ((*(s + i) >= '0') && (*(s + i) <= '9'))) {
+				printk("%c", *(s + i));
+			} else {
+				printk(".");
+			}
+		}
+
+		printk("\n");
+
+		len = len - count;
+
+		s = s + count;
+	}
+}
+#endif
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_sata.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_sata.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_sata.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_sata.h	2007-04-05 23:37:45.000000000 +0000
@@ -0,0 +1,771 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ *
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Written by : Robert Tarte  <robt@PacificCodeWorks.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+
+#ifdef ASD_DEBUG
+#define INLINE
+#else
+#define INLINE	inline
+#endif
+
+#ifndef ADP94XX_SATA_H
+#define ADP94XX_SATA_H
+#define	FIS_HOST_TO_DEVICE	0x27
+#define	FIS_DEVICE_TO_HOST	0x34
+#define FIS_COMMAND		0x80
+
+#define ASD_H2D_FIS(ata_hscb)	\
+	((struct adp_host_to_dev_fis *)&ata_hscb->host_to_dev_reg_fis[0])
+
+#define ASD_D2H_FIS(ata_resp_edb)	\
+	((struct adp_dev_to_host_fis *)&ata_resp_edb->ending_fis[0])
+
+#define FIS_OFFSET(x)	((unsigned)(&((struct adp_host_to_dev_fis *)0)->x))
+
+#define ATA2SCSI_2(x)	((((x) & 0x00ff) << 8) | (((x) & 0xff00) >> 8))
+#define ATA2SCSI_4(x)	((((x) & 0x000000ff) << 24) | \
+			 (((x) & 0x0000ff00) << 8) | \
+			 (((x) & 0x00ff0000) >> 8) | \
+			 (((x) & 0xff000000) >> 24))
+#define ATA2SCSI_8(x)	((((x) & 0x00000000000000ffLL) << 56) | \
+			 (((x) & 0x000000000000ff00LL) << 40) | \
+			 (((x) & 0x0000000000ff0000LL) << 24) | \
+			 (((x) & 0x00000000ff000000LL) << 8) | \
+			 (((x) & 0x000000ff00000000LL) >> 8) | \
+			 (((x) & 0x0000ff0000000000LL) >> 24) | \
+			 (((x) & 0x00ff000000000000LL) >> 40) | \
+			 (((x) & 0xff00000000000000LL) >> 56))
+
+// for the SStatus register
+#define SSTATUS_IPM_DET_MASK		0x00000f0f
+#define SSTATUS_SPD_MASK		0x000000f0
+
+#define SSTATUS_DET_COM_ESTABLISHED	0x00000003
+#define SSTATUS_SPD_NOT_ESTABLISHED	0x00000000
+#define SSTATUS_IPM_ACTIVE		0x00000100
+
+// for the ATA Identify command
+#define IDENT_48BIT_SUPPORT		0x0400
+#define IDENT_QUEUED_SUPPORT		0x0002
+#define IDENT_DMA_SUPPORT		0x01
+#define POWER_MANAGEMENT_SUPPORTED	0x0008
+#define IDENT_WRITE_FUA_SUPPORT		0x0080
+
+#define ATA_READ_BUFFER_CAPABLE		0x2000
+#define ATA_WRITE_BUFFER_CAPABLE	0x1000
+#define ATA_LOOK_AHEAD_CAPABLE		0x0040
+#define ATA_WRITE_CACHE_CAPABLE		0x0020
+#define ATA_SMART_CAPABLE		0x0001
+
+#define ATA_READ_BUFFER_ENABLED		0x2000
+#define ATA_WRITE_BUFFER_ENABLED	0x1000
+#define ATA_LOOK_AHEAD_ENABLED		0x0040
+#define ATA_WRITE_CACHE_ENABLED		0x0020
+#define ATA_SMART_ENABLED		0x0001
+
+
+#define ATA_SMART_ENABLED		0x0001
+
+#define RW_DMA_LBA_SIZE			(1 << 28)
+#define RW_DMA_MAX_SECTORS		(1 << 8)
+
+#define ATA_DMA_ULTRA_VALID		0x0004
+#define ATA_PIO_MODES_VALID		0x0002
+#define DMA_ULTRA_MODE_MASK		0x007f
+
+#define UDMA_XFER_MODE		0x40
+
+
+// for the ATA Check Power Mode command
+#define ATA_STANDBY_MODE		0x00
+#define ATA_IDLE_MODE			0x80
+#define ATA_ACTIVE			0xff
+
+// for the INQUIRY command
+#define ATA_REMOVABLE			0x0080
+#define SCSI_REMOVABLE			0x0008
+#define SCSI_3_RESPONSE_DATA_FORMAT	0x02
+#define CMD_QUEUE_BIT			0x02
+#define	CMD_DT				0x02
+#define LUN_FIELD			0xE0
+#define EVPD				0x01
+#define SUPPORTED_VPD			0x00
+#define UNIT_SERIAL_VPD			0x80
+#define ATA_PRODUCT_SERIAL_LENGTH	20
+#define INQUIRY_RESPONSE_SIZE		58
+
+// for the READ_CAPACITY command
+#define READ_CAPACITY_DATA_LEN		8
+#define ATA_BLOCK_SIZE			512
+
+// for the REQUEST_SENSE command
+#define SENSE_DATA_SIZE				18
+#define INVALID_FIELD_IN_CDB			0x24
+#define INVALID_COMMAND_OPERATION		0x20
+#define LOGICAL_UNIT_NOT_READY			0x04
+#define INITIALIZING_COMMAND_REQUIRED		0x02
+#define NOTIFY_REQUIRED				0x11
+#define MEDIUM_NOT_PRESENT			0x3a
+#define IO_PROCESS_TERMINATED_ASC		0x00
+#define IO_PROCESS_TERMINATED_ASCQ		0x06
+#define LOGICAL_UNIT_ASC			0x08
+#define COMMUNICATION_CRC_ERROR			0x03
+#define OPERATOR_ASC				0x5a
+#define MEDIUM_REMOVAL_REQUEST			0x01
+#define MEDIUM_CHANGED				0x28
+#define LOGICAL_UNIT_FAILURE			0x3e
+#define FAILED_SELF_TEST			0x03
+#define FORMAT_FAILED				0x31
+#define FORMAT_COMMAND_FAILED			0x01
+
+#define RESOURCE_FAILURE		0x55
+#define MEMORY_OUT_OF_SPACE		0x06
+
+#define NM_ERR		TRK0_ERR
+#define UNC_ERR		ECC_ERR
+
+// for the START_STOP command byte 4
+#define START_STOP_LOEJ			0x02
+#define START_STOP_START		0x01
+
+// for LOG_SENSE command byte 2
+#define SMART_DATA			0x31
+#define PAGE_CODE_MASK			0x3f
+#define PAGE_CONTROL_CURRENT		0x00
+#define PAGE_CONTROL_CUMULATIVE		0x40
+#define SMART_READ_DATA			0xd0
+
+#define SET_NO_IO_MODE(ata_hscb)
+#define SET_PIO_MODE(ata_hscb)
+#define SET_DMA_MODE(ata_hscb)	{ (ata_hscb)->ata_flags |= DMA_XFER_MODE; }
+
+// for PACKET Command
+#define DMADIR_BIT_NEEDED		0x8000
+#define DMADIR_BIT_DEV_TO_HOST		0x4
+#define PACKET_DMA_BIT			0x1
+
+// for WRITE_BUFFER command
+#define DATA_ONLY_MODE			0x02
+#define DESCRIPTOR_MODE			0x03
+#define BUFFER_MODE_MASK		0x1f
+#define READ_BUFFER_DESCRIPTOR_LENGTH	0x04
+#define ATA_BUFFER_SIZE			512
+
+// no Linux ATA command
+#define WIN_WRITE_DMA_FUA_EXT		0x3d
+#define WIN_WRITE_DMA_QUEUED_FUA_EXT	0x3e
+#define SCSI_WRITE_FUA_BIT		0x08
+
+// for MODE_SELECT command
+#define SP_BIT				0x01
+#define PF_BIT				0x10
+
+// for MODE_SENSE command
+#define DBD_BIT				0x08
+#define PAGE_CODE_MASK			0x3f
+#define PAGE_CONTROL_MASK		0xc0
+#define LLBA_MASK			0x10
+#define PAGE_CONTROL_CURRENT		0x00
+#define PAGE_CONTROL_CHANGEABLE		0x40
+#define PAGE_CONTROL_DEFAULT		0x80
+#define PAGE_CONTROL_SAVED			0xC0
+
+
+// pages for MODE_SENSE & MODE_SELECT
+#define MODE_PARAMETER_HEADER_LENGTH_10		8
+#define MODE_PARAMETER_HEADER_LENGTH_6		4
+#define BLOCK_DESCRIPTOR_LENGTH_8		8
+#define BLOCK_DESCRIPTOR_LENGTH_16		16
+
+#define READ_WRITE_ERROR_RECOVERY_MODE_PAGE	0x01
+#define DISCONNECT_RECONNECT_PAGE		0x02
+#define FORMAT_DEVICE_PAGE			0x03
+#define RIGID_DISK_GEOMETRY_PAGE		0x04
+#define CACHING_MODE_PAGE			0x08
+#define CONTROL_MODE_PAGE			0x0a
+#define INFORMATIONAL_EXCEPTION_CONTROL_PAGE	0x1c
+#define RETURN_ALL_PAGES			0x3f
+
+#define READ_WRITE_ERROR_RECOVERY_MODE_PAGE_LEN		0x0c
+#define CACHING_MODE_PAGE_LEN				0x14
+#define CONTROL_MODE_PAGE_LEN				0x0c
+#define INFORMATIONAL_EXCEPTION_CONTROL_PAGE_LEN	0x0c
+
+#define SCSI_DRA	0x20
+#define SCSI_WCE	0x04
+#define SCSI_DEXCPT	0x08
+
+// for FORMAT_UNIT command
+#define FORMAT_WRITE_BUFFER_LEN		4096
+#define FORMAT_BLOCK_SIZE		512
+#define FORMAT_SECTORS \
+	(FORMAT_WRITE_BUFFER_LEN / FORMAT_BLOCK_SIZE)
+
+
+
+// for SEND_DIAGNOSTIC
+#define SELFTEST			0x04
+#define SELFTEST_CODE_MASK		0xe0
+
+#ifndef REPORT_LUNS
+#define REPORT_LUNS			0xa0
+#endif
+#define REPORT_LUNS_SIZE		16
+
+#ifndef ASSERT
+#ifdef ASD_DEBUG
+#define ASSERT(x) \
+	if (!(x)) \
+	{ \
+		printk("Assertion failed: %s:%d\n", __FUNCTION__, __LINE__); \
+	}
+#else
+#define ASSERT(x)
+#endif
+#endif
+
+#ifndef WIN_READ_EXT
+#define WIN_READ_EXT			0x24 /* 48-Bit */
+#define WIN_READDMA_EXT			0x25 /* 48-Bit */
+#define WIN_READDMA_QUEUED_EXT		0x26 /* 48-Bit */
+#define WIN_FLUSH_CACHE			0xE7
+#define WIN_VERIFY_EXT			0x42 /* 48-Bit */
+#define WIN_WRITE_EXT			0x34 /* 48-Bit */
+#define WIN_WRITEDMA_EXT		0x35 /* 48-Bit */
+#define WIN_WRITEDMA_QUEUED_EXT		0x36 /* 48-Bit */
+#define lba_capacity_2			words94_125[6]
+#endif
+
+
+#define LBA_MODE	0x40
+
+struct adp_host_to_dev_fis {
+	uint8_t		fis_type;
+	uint8_t		cmd_devcontrol;
+	uint8_t		command;
+	uint8_t		features;
+
+	uint8_t		sector_number;
+	uint8_t		cyl_lo;
+	uint8_t		cyl_hi;
+	uint8_t		dev_head;
+
+	uint8_t		sector_number_exp;
+	uint8_t		cyl_lo_exp;
+	uint8_t		cyl_hi_exp;
+	uint8_t		features_exp;
+
+	uint8_t		sector_count;
+	uint8_t		sector_count_exp;
+	uint8_t		res1;
+	uint8_t		control;
+
+	uint8_t		res2;
+	uint8_t		res3;
+	uint8_t		res4;
+	uint8_t		res5;
+} __packed;
+
+
+#define	lba0		sector_number
+#define lba1		cyl_lo
+#define lba2		cyl_hi
+#define lba3		sector_number_exp
+#define byte_count_lo	cyl_lo
+#define byte_count_hi	cyl_hi
+
+struct adp_dev_to_host_fis {
+	uint8_t		fis_type;
+	uint8_t		interrupt;
+	uint8_t		status;
+	uint8_t		error;
+
+	uint8_t		sector_number;
+	uint8_t		cyl_lo;
+	uint8_t		cyl_hi;
+	uint8_t		dev_head;
+
+	uint8_t		sector_number_exp;
+	uint8_t		cyl_lo_exp;
+	uint8_t		cyl_hi_exp;
+	uint8_t		res1;
+
+	uint8_t		sector_count;
+	uint8_t		sector_count_exp;
+	uint8_t		res2;
+	uint8_t		res3;
+
+	uint8_t		res4;
+	uint8_t		res5;
+	uint8_t		res6;
+	uint8_t		res7;
+} __packed;
+
+/* -------------------------------------------------------------------------- */
+
+ASD_COMMAND_BUILD_STATUS
+asd_build_ata_scb(
+struct asd_softc	*asd,
+struct scb		*scb,
+union asd_cmd		*acmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_build_atapi_scb(
+struct asd_softc	*asd,
+struct scb		*scb,
+union asd_cmd		*acmd
+);
+
+INLINE
+void
+asd_sata_setup_fis(
+struct asd_ata_task_hscb	*ata_hscb,
+uint8_t				command
+);
+
+void
+asd_sata_compute_support(
+struct asd_softc	*asd,
+struct asd_target	*target
+);
+
+INLINE
+void
+asd_sata_setup_lba_ext(
+struct asd_ata_task_hscb	*ata_hscb,
+unsigned			lba,
+unsigned			sectors
+);
+
+INLINE
+void
+asd_sata_setup_lba(
+struct asd_ata_task_hscb	*ata_hscb,
+unsigned			lba,
+unsigned			sectors
+);
+
+void
+asd_sata_set_check_condition(
+struct scsi_cmnd	*cmd,
+unsigned		sense_key,
+unsigned		additional_sense,
+unsigned		additional_sense_qualifier
+);
+
+void
+asd_sata_check_registers(
+struct ata_resp_edb	*ata_resp_edbp,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_completion_status(
+struct scsi_cmnd	*cmd,
+struct ata_resp_edb	*ata_resp_edbp
+);
+INLINE
+struct ata_resp_edb *
+asd_sata_get_edb(
+struct asd_softc	*asd,
+struct asd_done_list	*done_listp,
+struct scb **pescb, 
+u_int *pedb_index
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_format_unit_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_format_unit_free_memory(
+struct asd_softc	*asd,
+struct scsi_cmnd	*write_cmd
+);
+
+void
+asd_sata_format_unit_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_inquiry_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_inquiry_evd_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd,
+u_char			*inquiry_data
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_log_sense_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_log_sense_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_mode_select_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_mode_sense_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_read_build(
+struct asd_softc	*asd,
+struct asd_device	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_read_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_write_buffer_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_write_buffer_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_read_buffer_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_read_buffer_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_read_capacity_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_report_luns_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_request_sense_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_rezero_unit_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_seek_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_send_diagnostic_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_send_diagnostic_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_start_stop_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_start_stop_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_synchronize_cache_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_synchronize_cache_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_test_unit_ready_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_test_unit_ready_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_verify_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_verify_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_write_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_write_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_write_verify_build(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+struct scsi_cmnd	*cmd
+);
+
+void
+asd_sata_write_verify_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+void
+asd_sata_identify_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+void
+asd_sata_configure_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+void
+asd_sata_atapi_post(
+struct asd_softc	*asd,
+struct scb		*scb,
+struct asd_done_list	*done_listp
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_read_write_error_recovery_mode_select(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+uint8_t			*bufptr
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_caching_mode_select(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+uint8_t			*bufptr
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_control_mode_select(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+uint8_t			*bufptr
+);
+
+ASD_COMMAND_BUILD_STATUS
+asd_sata_informational_exception_control_select(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+struct scb		*scb,
+uint8_t			*bufptr
+);
+
+int
+asd_sata_set_features_build(
+struct asd_softc	*asd,
+struct asd_target	*target,
+struct scb		*scb,
+uint8_t			feature,
+uint8_t			sector_count
+);
+
+uint8_t *
+asd_sata_informational_exception_control_sense(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+uint8_t			*bufptr,
+unsigned			page_control
+);
+
+uint8_t *
+asd_sata_control_sense(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+uint8_t			*bufptr
+);
+
+uint8_t *
+asd_sata_caching_sense(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+uint8_t			*bufptr,
+unsigned			page_control
+);
+
+uint8_t *
+asd_sata_read_write_error_recovery_sense(
+struct asd_softc	*asd,
+struct asd_device 	*dev,
+uint8_t			*bufptr
+);
+
+COMMAND_SET_TYPE asd_sata_get_type(struct adp_dev_to_host_fis *fis);
+
+#endif /* ADP94XX_SATA_H */ 
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_seq.c linux-2.6.16/drivers/scsi/adp94xx/adp94xx_seq.c
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_seq.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_seq.c	2007-04-05 23:37:43.000000000 +0000
@@ -0,0 +1,4591 @@
+/*
+ * Adaptec ADP94xx SAS HBA device driver for Linux.
+ * Functions for interfacing with Sequencers.
+ *
+ * Written by : David Chaw <david_chaw@adaptec.com>
+ *   
+ * Copyright (c) 2004 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ * 
+ */	
+
+#include "adp94xx_osm.h"
+#include "adp94xx_inline.h"
+#include "adp94xx_seq.h"
+#if KDB_ENABLE
+#include "linux/kdb.h"
+#endif
+
+/*
+ * Wrappers for which particular version of sequencer code and interrupt
+ * vectors  to use.
+ */
+#define ASD_USE_A1_CODE(softc)		\
+	(softc->hw_profile.rev_id == AIC9410_DEV_REV_A1 ? 1: 0)
+
+#define ASD_SEQ_VER(seq, ver)	(seq##ver)
+
+#define ASD_INT_VEC(vec, ver)	(vec##ver)
+	
+#ifdef ASD_DEBUG
+/*
+ * Registers dump state definitions (for debug purpose).
+ */
+static void	asd_hwi_dump_cseq_state(struct asd_softc *asd);
+static void	asd_hwi_dump_lseq_state(struct asd_softc *asd, u_int lseq_id);
+
+typedef struct lseq_cio_reqs {
+	uint8_t		name[24];
+	uint16_t	offset;
+	uint16_t	width;
+	uint16_t	mode;
+} lseq_cio_regs_t;
+
+#define MD(x)	(1 << x)
+
+static lseq_cio_regs_t	LSEQmCIOREGS[] =
+{
+   {"LmMODEPTR"     ,0x00, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmALTMODE"     ,0x01, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmFLAG"        ,0x04, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmARP2INTCTL"  ,0x05, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmPRGMCNT"     ,0x08,16, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmARP2HALTCODE",0x15, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmCURRADDR"    ,0x16,16, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmLASTADDR"    ,0x18,16, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmNXTLADDR"    ,0x1A,16, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnSCBPTR"    ,0x20,16, MD(0)|MD(1)|MD(2)|MD(3)},
+   {"LmMnDDBPTR"    ,0x22,16, MD(0)|MD(1)|MD(2)|MD(3)},
+   {"LmREQMBX"      ,0x30,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmRSPMBX"      ,0x34,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnINT"       ,0x38,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnINTEN"     ,0x3C,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmXMTPRIMD"    ,0x40,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmXMTPRIMCS"   ,0x44, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmCONSTAT"     ,0x45, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnDMAERRS"   ,0x46, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnSGDMAERRS" ,0x47, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnSASALIGN"  ,0x48, 8, MD(1)},
+   {"LmMnSTPALIGN"  ,0x49, 8, MD(1)},
+   {"LmALIGNMODE"   ,0x4B, 8, MD(1)},
+   {"LmMnEXPRCVCNT" ,0x4C,32, MD(0)},
+   {"LmMnXMTCNT"    ,0x4C,32, MD(1)},
+   {"LmMnCURRTAG"   ,0x54,16, MD(0)},
+   {"LmMnPREVTAG"   ,0x56,16, MD(0)},
+   {"LmMnACKOFS"    ,0x58, 8, MD(1)},
+   {"LmMnXFRLVL"    ,0x59, 8, MD(0)|MD(1)},
+   {"LmMnSGDMACTL"  ,0x5A, 8, MD(0)|MD(1)},
+   {"LmMnSGDMASTAT" ,0x5B, 8, MD(0)|MD(1)},
+   {"LmMnDDMACTL"   ,0x5C, 8, MD(0)|MD(1)},
+   {"LmMnDDMASTAT"  ,0x5D, 8, MD(0)|MD(1)},
+   {"LmMnDDMAMODE"  ,0x5E,16, MD(0)|MD(1)},
+   {"LmMnPIPECTL"   ,0x61, 8, MD(0)|MD(1)},
+   {"LmMnACTSCB"    ,0x62,16, MD(0)|MD(1)},
+   {"LmMnSGBHADR"   ,0x64, 8, MD(0)|MD(1)},
+   {"LmMnSGBADR"    ,0x65, 8, MD(0)|MD(1)},
+   {"LmMnSGDCNT"    ,0x66, 8, MD(0)|MD(1)},
+   {"LmMnSGDMADR"   ,0x68,32, MD(0)|MD(1)},
+   {"LmMnSGDMADR"   ,0x6C,32, MD(0)|MD(1)},
+   {"LmMnXFRCNT"    ,0x70,32, MD(0)|MD(1)},
+   {"LmMnXMTCRC"    ,0x74,32, MD(1)},
+   {"LmCURRTAG"     ,0x74,16, MD(0)},
+   {"LmPREVTAG"     ,0x76,16, MD(0)},
+   {"LmDPSEL"       ,0x7B, 8, MD(0)|MD(1)},
+   {"LmDPTHSTAT"    ,0x7C, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnHOLDLVL"   ,0x7D, 8, MD(0)},
+   {"LmMnSATAFS"    ,0x7E, 8, MD(1)},
+   {"LmMnCMPLTSTAT" ,0x7F, 8, MD(0)|MD(1)},
+   {"LmPRMSTAT0"    ,0x80,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmPRMSTAT1"    ,0x84,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmGPRMINT"     ,0x88, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnCURRSCB"   ,0x8A,16, MD(0)},
+   {"LmPRMICODE"    ,0x8C,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnRCVCNT"    ,0x90,16, MD(0)},
+   {"LmMnBUFSTAT"   ,0x92,16, MD(0)},
+   {"LmMnXMTHDRSIZE",0x92, 8, MD(1)},
+   {"LmMnXMTSIZE"   ,0x93, 8, MD(1)},
+   {"LmMnTGTXFRCNT" ,0x94,32, MD(0)},
+   {"LmMnEXPROFS"   ,0x98,32, MD(0)},
+   {"LmMnXMTROFS"   ,0x98,32, MD(1)},
+   {"LmMnRCVROFS"   ,0x9C,32, MD(0)},
+   {"LmCONCTL"      ,0xA0,16, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmBITLTIMER"   ,0xA2,16, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmWWNLOW"      ,0xA8,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmWWNHIGH"     ,0xAC,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnFRMERR"    ,0xB0,32, MD(0)},
+   {"LmMnFRMERREN"  ,0xB4,32, MD(0)},
+   {"LmAWTIMER"     ,0xB8,16, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmAWTCTL"      ,0xBA, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnHDRCMPS"   ,0xC0,32, MD(0)},
+   {"LmMnXMTSTAT"   ,0xC4, 8, MD(1)},
+   {"LmHWTSTATEN"   ,0xC5, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnRRDYRC"    ,0xC6, 8, MD(0)},
+   {"LmMnRRDYTC"    ,0xC6, 8, MD(1)},
+   {"LmHWTSTAT"     ,0xC7, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnDATABUFADR",0xC8,16, MD(0)|MD(1)},
+   {"LmDWSSTATUS"   ,0xCB, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmMnACTSTAT"   ,0xCE,16, MD(0)|MD(1)},
+   {"LmMnREQSCB"    ,0xD2,16, MD(0)|MD(1)},
+   {"LmXXXPRIM"     ,0xD4,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmRCVASTAT"    ,0xD9, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmINTDIS1"     ,0xDA, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmPSTORESEL"   ,0xDB, 8, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmPSTORE"      ,0xDC,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmPRIMSTAT0EN" ,0xE0,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmPRIMSTAT1EN" ,0xE4,32, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"LmDONETCTL"    ,0xF2,16, MD(0)|MD(1)|MD(2)|MD(3)|MD(4)|MD(5)|MD(6)|MD(7)},
+   {"", 0, 0, 0 }	/* Last entry should be NULL. */
+}; 
+
+static lseq_cio_regs_t	LSEQmOOBREGS[] =
+{
+   {"OOB_BFLTR"        ,0x100, 8, MD(5)},
+   {"OOB_INIT_MIN"     ,0x102,16, MD(5)},
+   {"OOB_INIT_MAX"     ,0x104,16, MD(5)},
+   {"OOB_INIT_NEG"     ,0x106,16, MD(5)},
+   {"OOB_SAS_MIN"      ,0x108,16, MD(5)},
+   {"OOB_SAS_MAX"      ,0x10A,16, MD(5)},
+   {"OOB_SAS_NEG"      ,0x10C,16, MD(5)},
+   {"OOB_WAKE_MIN"     ,0x10E,16, MD(5)},
+   {"OOB_WAKE_MAX"     ,0x110,16, MD(5)},
+   {"OOB_WAKE_NEG"     ,0x112,16, MD(5)},
+   {"OOB_IDLE_MAX"     ,0x114,16, MD(5)},
+   {"OOB_BURST_MAX"    ,0x116,16, MD(5)},
+   {"OOB_XMIT_BURST"   ,0x118, 8, MD(5)},
+   {"OOB_SEND_PAIRS"   ,0x119, 8, MD(5)},
+   {"OOB_INIT_IDLE"    ,0x11A, 8, MD(5)},
+   {"OOB_INIT_NEGO"    ,0x11C, 8, MD(5)},
+   {"OOB_SAS_IDLE"     ,0x11E, 8, MD(5)},
+   {"OOB_SAS_NEGO"     ,0x120, 8, MD(5)},
+   {"OOB_WAKE_IDLE"    ,0x122, 8, MD(5)},
+   {"OOB_WAKE_NEGO"    ,0x124, 8, MD(5)},
+   {"OOB_DATA_KBITS"   ,0x126, 8, MD(5)},
+   {"OOB_BURST_DATA"   ,0x128,32, MD(5)},
+   {"OOB_ALIGN_0_DATA" ,0x12C,32, MD(5)},
+   {"OOB_ALIGN_1_DATA" ,0x130,32, MD(5)},
+   {"OOB_SYNC_DATA"    ,0x134,32, MD(5)},
+   {"OOB_D10_2_DATA"   ,0x138,32, MD(5)},
+   {"OOB_PHY_RST_CNT"  ,0x13C,32, MD(5)},
+   {"OOB_SIG_GEN"      ,0x140, 8, MD(5)},
+   {"OOB_XMIT"         ,0x141, 8, MD(5)},
+   {"FUNCTION_MAKS"    ,0x142, 8, MD(5)},
+   {"OOB_MODE"         ,0x143, 8, MD(5)},
+   {"CURRENT_STATUS"   ,0x144, 8, MD(5)},
+   {"SPEED_MASK"       ,0x145, 8, MD(5)},
+   {"PRIM_COUNT"       ,0x146, 8, MD(5)},
+   {"OOB_SIGNALS"      ,0x148, 8, MD(5)},
+   {"OOB_DATA_DET"     ,0x149, 8, MD(5)},
+   {"OOB_TIME_OUT"     ,0x14C, 8, MD(5)},
+   {"OOB_TIMER_ENABLE" ,0x14D, 8, MD(5)},
+   {"OOB_STATUS"       ,0x14E, 8, MD(5)},
+   {"HOT_PLUG_DELAY"   ,0x150, 8, MD(5)},
+   {"RCD_DELAY"        ,0x151, 8, MD(5)},
+   {"COMSAS_TIMER"     ,0x152, 8, MD(5)},
+   {"SNTT_DELAY"       ,0x153, 8, MD(5)},
+   {"SPD_CHNG_DELAY"   ,0x154, 8, MD(5)},
+   {"SNLT_DELAY"       ,0x155, 8, MD(5)},
+   {"SNWT_DELAY"       ,0x156, 8, MD(5)},
+   {"ALIGN_DELAY"      ,0x157, 8, MD(5)},
+   {"INT_ENABLE_0"     ,0x158, 8, MD(5)},
+   {"INT_ENABLE_1"     ,0x159, 8, MD(5)},
+   {"INT_ENABLE_2"     ,0x15A, 8, MD(5)},
+   {"INT_ENABLE_3"     ,0x15B, 8, MD(5)},
+   {"OOB_TEST_REG"     ,0x15C, 8, MD(5)},
+   {"PHY_CONTROL_0"    ,0x160, 8, MD(5)},
+   {"PHY_CONTROL_1"    ,0x161, 8, MD(5)},
+   {"PHY_CONTROL_2"    ,0x162, 8, MD(5)},
+   {"PHY_CONTROL_3"    ,0x163, 8, MD(5)},
+   {"PHY_OOB_CAL_TX"   ,0x164, 8, MD(5)},
+   {"PHY_OOB_CAL_RX"   ,0x165, 8, MD(5)},
+   {"OOB_PHY_CAL_TX"   ,0x166, 8, MD(5)},
+   {"OOB_PHY_CAL_RX"   ,0x167, 8, MD(5)},
+   {"PHY_CONTROL_4"    ,0x168, 8, MD(5)},
+   {"PHY_TEST"         ,0x169, 8, MD(5)},
+   {"PHY_PWR_CTL"      ,0x16A, 8, MD(5)},
+   {"PHY_PWR_DELAY"    ,0x16B, 8, MD(5)},
+   {"OOB_SM_CON"       ,0x16C, 8, MD(5)},
+   {"ADDR_TRAP_1"      ,0x16D, 8, MD(5)},
+   {"ADDR_NEXT_1"      ,0x16E, 8, MD(5)},
+   {"NEXT_ST_1"        ,0x16F, 8, MD(5)},
+   {"OOB_SM_STATE"     ,0x170, 8, MD(5)},
+   {"ADDR_TRAP_2"      ,0x171, 8, MD(5)},
+   {"ADDR_NEXT_2"      ,0x172, 8, MD(5)},
+   {"NEXT_ST_2"        ,0x173, 8, MD(5)},
+   {"", 0, 0, 0 }	/* Last entry should be NULL. */
+};
+#endif /* ASD_DEBUG */
+
+/* Local functions' prototypes */
+static int	asd_hwi_verify_seqs(struct asd_softc *asd, uint8_t *code, 
+				    uint32_t code_size, uint8_t lseq_mask);
+static void	asd_hwi_init_cseq_scratch(struct asd_softc *asd);
+static void	asd_hwi_init_cseq_mip(struct asd_softc *asd);
+static void	asd_hwi_init_cseq_mdp(struct asd_softc *asd);
+static void	asd_hwi_init_cseq_cio(struct asd_softc *asd);
+static void 	asd_hwi_post_init_cseq(struct asd_softc *asd);
+static void	asd_hwi_init_scb_sites(struct asd_softc *asd);
+static void	asd_hwi_init_lseq_scratch(struct asd_softc *asd);
+static void	asd_hwi_init_lseq_mip(struct asd_softc *asd, u_int link_num);
+static void	asd_hwi_init_lseq_mdp(struct asd_softc *asd, u_int link_num);
+static void	asd_hwi_init_lseq_cio(struct asd_softc *asd, u_int link_num);
+static inline void
+		asd_swap_with_next_hscb(struct asd_softc *asd, struct scb *scb);
+      
+
+/* Sequencer misc. utilities. */
+static inline void asd_hwi_set_scbptr(struct asd_softc *asd, uint16_t val);
+static inline void asd_hwi_set_scbsite_byte(struct asd_softc *asd,
+					    uint16_t site_offset, uint8_t val);
+static inline void asd_hwi_set_scbsite_word(struct asd_softc *asd,
+					    uint16_t site_offset, uint16_t val);
+static inline void asd_hwi_set_scbsite_dword(struct asd_softc *asd,
+					    uint16_t site_offset, uint32_t val);
+static inline uint8_t asd_hwi_get_scbsite_byte(struct asd_softc *asd, 
+					       uint16_t site_offset);
+static inline uint16_t asd_hwi_get_scbsite_word(struct asd_softc *asd, 
+					        uint16_t site_offset);
+static inline uint32_t asd_hwi_get_scbsite_dword(struct asd_softc *asd, 
+						 uint16_t site_offset);
+
+/* 
+ * Function:
+ *	asd_hwi_set_scbptr()
+ *
+ * Description:
+ *      Program the SCBPTR. 
+ *	SCBPTR is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+static inline void
+asd_hwi_set_scbptr(struct asd_softc *asd, uint16_t val)
+{
+	asd_hwi_swb_write_word(asd, CSEQm_CIO_REG(15, MnSCBPTR), val);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_set_ddbptr()
+ *
+ * Description:
+ *      Program the DDBPTR. 
+ *	DDBPTR is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+//static inline void
+void
+asd_hwi_set_ddbptr(struct asd_softc *asd, uint16_t val)
+{
+	asd_hwi_swb_write_word(asd, CSEQm_CIO_REG(15, MnDDBPTR), val);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_set_scbsite_byte()
+ *
+ * Description:
+ *      Write an 8-bits value to the SCBSITE starting from the site_offset. 
+ *	SCBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+static inline void
+asd_hwi_set_scbsite_byte(struct asd_softc *asd, uint16_t site_offset, 
+			 uint8_t val)
+{
+	asd_hwi_swb_write_byte(asd,
+			       CSEQm_CIO_REG(15, (MnSCB_SITE + site_offset)),
+			       val);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_set_scbsite_word()
+ *
+ * Description:
+ *      Write a 16-bits value to the SCBSITE starting from the site_offset. 
+ *	SCBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+static inline void
+asd_hwi_set_scbsite_word(struct asd_softc *asd, uint16_t site_offset, 
+			 uint16_t val)
+{
+	asd_hwi_swb_write_word(asd,
+			       CSEQm_CIO_REG(15, (MnSCB_SITE + site_offset)),
+			       val);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_set_scbsite_dword()
+ *
+ * Description:
+ *      Write a 32-bits value to the SCBSITE starting from the site_offset. 
+ *	SCBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+static inline void
+asd_hwi_set_scbsite_dword(struct asd_softc *asd, uint16_t site_offset, 
+			  uint32_t val)
+{
+	asd_hwi_swb_write_dword(asd,
+				CSEQm_CIO_REG(15, (MnSCB_SITE + site_offset)),
+				val);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_get_scbsite_byte()
+ *
+ * Description:
+ *      Read an 8-bits value from the SCBSITE starting from the site_offset. 
+ *	SCBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+static inline uint8_t
+asd_hwi_get_scbsite_byte(struct asd_softc *asd, uint16_t site_offset)
+{
+	return ((uint8_t) asd_hwi_swb_read_byte(
+				asd,
+				CSEQm_CIO_REG(15, (MnSCB_SITE + site_offset))));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_get_scbsite_word()
+ *
+ * Description:
+ *      Read a 16-bits value from the SCBSITE starting from the site_offset. 
+ *	SCBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+static inline uint16_t
+asd_hwi_get_scbsite_word(struct asd_softc *asd, uint16_t site_offset)
+{
+	return ((uint16_t) asd_hwi_swb_read_word(
+				asd,
+				CSEQm_CIO_REG(15, (MnSCB_SITE + site_offset))));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_get_scbsite_dword()
+ *
+ * Description:
+ *      Read a 32-bits value from the SCBSITE starting from the site_offset. 
+ *	SCBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+static inline uint32_t
+asd_hwi_get_scbsite_dword(struct asd_softc *asd, uint16_t site_offset)
+{
+	return ((uint32_t) asd_hwi_swb_read_dword(
+				asd,
+				CSEQm_CIO_REG(15, (MnSCB_SITE + site_offset))));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_set_ddbsite_byte()
+ *
+ * Description:
+ *      Write an 8-bits value to the DDBSITE starting from the site_offset. 
+ *	DDBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+void asd_hwi_set_ddbsite_byte(struct asd_softc *asd, uint16_t site_offset, 
+			      uint8_t val)
+{
+	asd_hwi_swb_write_byte(asd,
+			       CSEQm_CIO_REG(15, (MnDDB_SITE + site_offset)),
+			       val);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_set_ddbsite_word()
+ *
+ * Description:
+ *      Write a 16-bits value to the DDBSITE starting from the site_offset. 
+ *	DDBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+void asd_hwi_set_ddbsite_word(struct asd_softc *asd, uint16_t site_offset, 
+			      uint16_t val)
+{
+	asd_hwi_swb_write_word(asd,
+			       CSEQm_CIO_REG(15, (MnDDB_SITE + site_offset)),
+			       val);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_set_ddbsite_dword()
+ *
+ * Description:
+ *      Write a 32-bits value to the DDBSITE starting from the site_offset. 
+ *	DDBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+void asd_hwi_set_ddbsite_dword(struct asd_softc *asd, uint16_t site_offset, 
+			       uint32_t val)
+{
+	asd_hwi_swb_write_dword(asd,
+				CSEQm_CIO_REG(15, (MnDDB_SITE + site_offset)),
+				val);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_get_ddbsite_byte()
+ *
+ * Description:
+ *      Read an 8-bits value from the DDBSITE starting from the site_offset. 
+ *	DDBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+uint8_t asd_hwi_get_ddbsite_byte(struct asd_softc *asd, uint16_t site_offset)
+{
+	return ((uint8_t) asd_hwi_swb_read_byte(
+				asd,
+			      	CSEQm_CIO_REG(15, (MnDDB_SITE + site_offset))));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_get_ddbsite_word()
+ *
+ * Description:
+ *      Read a 16-bits value from the DDBSITE starting from the site_offset. 
+ *	DDBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+uint16_t asd_hwi_get_ddbsite_word(struct asd_softc *asd, uint16_t site_offset)
+{
+	return ((uint16_t) asd_hwi_swb_read_word(
+				asd,
+			      	CSEQm_CIO_REG(15, (MnDDB_SITE + site_offset))));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_get_ddbsite_dword()
+ *
+ * Description:
+ *      Read a 32-bits value from the DDBSITE starting from the site_offset. 
+ *	DDBSITE is in Mode 15 of CSEQ CIO Bus Registers. 
+ */
+uint32_t asd_hwi_get_ddbsite_dword(struct asd_softc *asd, uint16_t site_offset)
+{
+	return ((uint32_t) asd_hwi_swb_read_dword(
+				asd,
+			      	CSEQm_CIO_REG(15, (MnDDB_SITE + site_offset))));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_pause_cseq()
+ *
+ * Description:
+ *      Pause the Central Sequencer. 
+ */
+int
+asd_hwi_pause_cseq(struct asd_softc *asd)
+{
+	uint32_t	arp2ctl_reg;
+	uint32_t	arp2ctl;
+	uint32_t	timer_tick;
+
+	timer_tick = ASD_REG_TIMEOUT_TICK;
+	arp2ctl_reg = (uint32_t) CARP2CTL;
+	arp2ctl = asd_hwi_swb_read_dword(asd, arp2ctl_reg);
+	
+	/* Check if the CSEQ is paused. */
+	if (!(arp2ctl & PAUSED)) {
+		/* CSEQ is running. Pause it. */
+		asd_hwi_swb_write_dword(asd, arp2ctl_reg, (arp2ctl | EPAUSE));
+		/* Verify that the CSEQ is paused. */
+		do { 
+			arp2ctl = asd_hwi_swb_read_dword(asd, arp2ctl_reg);
+			if (!(arp2ctl & PAUSED)) {
+				timer_tick--;		
+				asd_delay(ASD_DELAY_COUNT);	
+			} else
+				break;
+		} while (timer_tick != 0);					
+	}		 		
+	if (timer_tick == 0) {
+		asd_log(ASD_DBG_ERROR, "Timeout expired when pausing CSEQ.\n");
+		ASD_DUMP_REG(CARP2CTL);
+		return (-1);
+	}
+
+	return (0);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_unpause_cseq()
+ *
+ * Description:
+ *      Unpause the Central Sequencer. 
+ */
+int
+asd_hwi_unpause_cseq(struct asd_softc *asd)
+{
+	uint32_t	arp2ctl;
+	uint32_t	timer_tick;
+
+	timer_tick = ASD_REG_TIMEOUT_TICK;
+	arp2ctl = asd_hwi_swb_read_dword(asd, CARP2CTL);
+
+	/* Check if the CSEQ is paused. */
+	if (arp2ctl & PAUSED) {
+		/* CSEQ is currently paused. Unpause it. */
+		asd_hwi_swb_write_dword(asd, CARP2CTL, (arp2ctl & ~EPAUSE));
+		/* Verify that the CSEQ is unpaused. */
+		do { 
+			arp2ctl = asd_hwi_swb_read_dword(asd, CARP2CTL);
+			if (arp2ctl & PAUSED) {
+				timer_tick--;		
+				asd_delay(ASD_DELAY_COUNT);	
+			} else
+				break;
+		} while (timer_tick != 0);	
+	}
+	if (timer_tick == 0) {
+		asd_log(ASD_DBG_ERROR, "Timeout expired when unpausing "
+					"CSEQ.\n");
+		ASD_DUMP_REG(CARP2CTL);
+		return (-1);
+	}
+
+	return (0);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_pause_lseq()
+ *
+ * Description:
+ *      Pause the requested Link Sequencer(s). 
+ */
+int	
+asd_hwi_pause_lseq(struct asd_softc *asd, uint8_t lseq_mask)
+{
+	uint32_t	arp2ctl;
+	uint32_t	timer_tick;
+	uint8_t		temp_lseq_mask;	
+	uint8_t		phy_id;
+
+	phy_id = 0;
+	temp_lseq_mask = lseq_mask;
+	timer_tick = ASD_REG_TIMEOUT_TICK;	
+	while (temp_lseq_mask) {
+		do {
+			if (temp_lseq_mask & (1 << phy_id))  
+				break;
+			else 
+				phy_id++;		
+		} while (phy_id < asd->hw_profile.max_phys);
+		
+		arp2ctl = asd_hwi_swb_read_dword(asd, LmARP2CTL(phy_id));
+		
+		/* Check if the LSEQ is paused. */
+		if (!(arp2ctl & PAUSED)) {
+			/*
+		 	 * LSEQ is running. Pause it.
+		 	 */
+			asd_hwi_swb_write_dword(asd, LmARP2CTL(phy_id), 
+						(arp2ctl | EPAUSE));
+			/* Verify that the LSEQ is paused. */
+			do { 
+				arp2ctl = asd_hwi_swb_read_dword(asd, 
+							LmARP2CTL(phy_id));
+				if (!(arp2ctl & PAUSED)) {
+					timer_tick--;		
+					asd_delay(ASD_DELAY_COUNT);	
+				} else
+					break;
+			} while (timer_tick != 0);				
+		}
+		if (timer_tick == 0) {
+			asd_log(ASD_DBG_ERROR, "Timeout expired when pausing "
+				"LSEQ %d.\n", phy_id);
+			return (-1);
+		} 	
+		temp_lseq_mask &= (~(1 << phy_id));		
+		phy_id++;
+	}
+
+	return (0);						 
+}
+
+/* 
+ * Function:
+ *	asd_hwi_unpause_lseq()
+ *
+ * Description:
+ *      Unpause the requested Link Sequencer(s). 
+ */
+int
+asd_hwi_unpause_lseq(struct asd_softc *asd, uint8_t lseq_mask)
+{
+	uint32_t	arp2ctl;
+	uint32_t	timer_tick;
+	uint8_t		temp_lseq_mask;	
+	uint8_t		phy_id;
+	
+	phy_id = 0;
+	temp_lseq_mask = lseq_mask;
+	timer_tick = ASD_REG_TIMEOUT_TICK;	
+	while (temp_lseq_mask) {
+		do {
+			if (temp_lseq_mask & (1 << phy_id))  
+				break;
+			else 
+				phy_id++;		
+		} while (phy_id < asd->hw_profile.max_phys);
+		
+		arp2ctl = asd_hwi_swb_read_dword(asd, LmARP2CTL(phy_id));	
+
+		/* Check if the LSEQ is paused. */
+		if (arp2ctl & PAUSED) {
+			/* Unpause the LSEQ. */
+			asd_hwi_swb_write_dword(asd, LmARP2CTL(phy_id), 
+					       (arp2ctl & ~EPAUSE));
+			do { 
+				arp2ctl = asd_hwi_swb_read_dword(asd, 
+							LmARP2CTL(phy_id));
+				if (arp2ctl & PAUSED) {
+					timer_tick--;		
+					asd_delay(ASD_DELAY_COUNT);	
+				} else
+					break;
+			} while (timer_tick != 0);	
+
+		}
+		if (timer_tick == 0) {
+			asd_log(ASD_DBG_ERROR, "Timeout expired when unpausing "
+					"LSEQ %d.\n", phy_id);
+			return (-1);
+		}
+		temp_lseq_mask &= (~(1 << phy_id));		
+		phy_id++;
+	}
+
+	return (0);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_download_seqs()
+ *
+ * Description:
+ *      Setup the Central and Link Sequencers.
+ *	Download the sequencers microcode.  
+ */
+int	
+asd_hwi_download_seqs(struct asd_softc *asd)
+{
+	int 	error;
+
+#define ASD_SET_SEQ_VER(asd, seq)	\
+	(ASD_USE_A1_CODE(asd) == 1 ? ASD_SEQ_VER(seq, a1) :		\
+	 ASD_SEQ_VER(seq, b0))
+
+#define ASD_SEQ_SIZE(asd, seq)		\
+	(ASD_USE_A1_CODE(asd) == 1 ? sizeof(ASD_SEQ_VER(seq, a1)) :	\
+	 sizeof(ASD_SEQ_VER(seq, b0)))
+
+	/* Download the Central Sequencer code. */
+	error = ASD_HWI_DOWNLOAD_SEQS(asd, ASD_SET_SEQ_VER(asd, Cs), 
+				      ASD_SEQ_SIZE(asd, Cs),
+				      0);
+	if (error != 0) {
+		asd_log(ASD_DBG_ERROR, "CSEQ download failed.\n");
+		goto exit;
+	}
+	
+	/* 
+	 * Download the Link Sequencers code. All of the Link Sequencers 
+	 * microcode can be downloaded at the same time.
+	 */
+	error = ASD_HWI_DOWNLOAD_SEQS(asd, ASD_SET_SEQ_VER(asd, Ls), 
+				      ASD_SEQ_SIZE(asd, Ls),
+				      asd->hw_profile.enabled_phys); 
+	if (error != 0) {
+		uint8_t		i;
+		
+		/*
+		 * If we failed to load the LSEQ all at a time. 
+		 * Try to load them one at a time.
+		 */		 
+		for (i = 0; i < asd->hw_profile.max_phys; i++) {
+			error = ASD_HWI_DOWNLOAD_SEQS(
+					asd,
+					ASD_SET_SEQ_VER(asd, Ls),
+					ASD_SEQ_SIZE(asd, Ls),
+				      	(1 << i));
+			if (error != 0)
+				break;
+
+			asd->phy_list[i]->state = ASD_PHY_OFFLINE;
+		}
+		if (error) {
+			asd_log(ASD_DBG_ERROR, "LSEQs download failed.\n");
+			goto exit;
+		}
+	}
+
+exit:
+	return (error);		  
+}
+
+#if ASD_DMA_DOWNLOAD_SEQS
+/* 
+ * Function:
+ *	asd_hwi_dma_load_seqs()
+ *
+ * Description:
+ *	Download the sequencers using Host Overlay DMA mode.  
+ */
+int
+asd_hwi_dma_load_seqs(struct asd_softc *asd, uint8_t *code,
+		      uint32_t code_size, uint8_t lseq_mask)
+{
+	struct map_node	 buf_map;	
+	bus_dma_tag_t	 buf_dmat;
+	uint32_t	 buf_size;
+	uint32_t	 comstaten_val;
+	uint32_t	 instr_size;
+	uint32_t	 timer_tick;
+	uint16_t	 ovlyaddr;
+	uint16_t	 ovlydmactl_lo;
+	uint16_t	 ovlydmactl_hi;	
+	uint8_t		*instr;	
+	uint8_t		 nseg;
+	u_int		 i;
+	int		 error;
+	
+	error = 0;
+	if (code_size % 4) {
+		/*
+		 * For PIO mode, sequencer code size must be multiple of dword.
+		 */
+		asd_log(ASD_DBG_ERROR, "SEQ code size (%d) not multiple of "
+			"dword. \n", code_size);
+		return (-1);	
+	}
+	
+	/* Save the Interrupt Mask register value. */
+	comstaten_val = asd_read_dword(asd, COMSTATEN);
+	/* 
+	 * Disable Device Communication Status interrupt and clear any 
+	 * pending interrupts.
+	 */
+	asd_write_dword(asd, COMSTATEN, 0x0);
+	asd_write_dword(asd, COMSTAT, COMSTAT_MASK);
+		
+	/* Disable CHIM interrupt and clear any pending interrupts. */
+	asd_write_dword(asd, CHIMINTEN, RST_CHIMINTEN);
+	asd_write_dword(asd, CHIMINT, CHIMINT_MASK);
+	
+	/* 
+	 * Check the limit of HW DMA transfer size.
+	 * Limit the Overlay DMA transter size to code_size at a time.
+	 */ 
+	if ((asd->hw_profile.max_scbs * ASD_SCB_SIZE) >= code_size)
+		buf_size = code_size;
+	else
+		buf_size = (asd->hw_profile.max_scbs * ASD_SCB_SIZE);	
+
+	/* Allocate a dma tag for buffer to dma-ing the instruction codes. */
+	if (asd_dma_tag_create(asd, 4, buf_size, GFP_ATOMIC, &buf_dmat) != 0)
+		return (-ENOMEM);
+
+	if (asd_dmamem_alloc(asd, buf_dmat, (void **) &buf_map.vaddr,
+			     GFP_ATOMIC, &buf_map.dmamap,
+			     &buf_map.busaddr) != 0) {
+		asd_dma_tag_destroy(asd, buf_dmat);
+		return (-ENOMEM);
+	}
+
+	instr = (uint8_t *) buf_map.vaddr;
+	
+	/* Calculate number of DMA segments needed to transfer the code. */
+	nseg = (code_size + buf_size - 1) / buf_size;
+	instr_size = buf_size;
+	ovlydmactl_lo = ovlydmactl_hi = 0;
+	ovlyaddr = 0;
+	
+	asd_log(ASD_DBG_INFO, "Downloading %s (Overlay DMA Mode) ...\n", 
+		(lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+	
+	for (i = 0; i < nseg; ) {
+		memcpy(instr, &code[ovlyaddr], instr_size);
+		
+		/* Program the DMA download size. */
+		asd_write_dword(asd, OVLYDMACNT, instr_size);
+		/* 
+		 * Program the 64-bit DMA address, OVLYDMAADDR register is 
+		 * 64-bit. 
+		 */
+		asd_write_dword(asd, OVLYDMAADR0, 
+				ASD_GET_PADR(buf_map.busaddr));
+		asd_write_dword(asd, OVLYDMAADR1,
+				ASD_GET_PUADR(buf_map.busaddr));
+		
+		/* lseq_mask tells us which sequencer(s) the code is for. */
+		if (lseq_mask == 0)
+			ovlydmactl_lo = (uint16_t) OVLYCSEQ;
+		else
+			ovlydmactl_lo = (uint16_t) (((uint16_t)lseq_mask) << 8);
+		/* 
+		 * Program the OVLYADR. It increments for each dword 
+		 * instruction overlaid. 
+		 */
+		ovlydmactl_hi = (ovlyaddr / 4);
+		/*
+		 * Reset the Overlay DMA counter and buffer pointers to zero.
+		 * Also, enabled the Overlay DMA engine.
+		 */
+	       ovlydmactl_lo |= (RESETOVLYDMA | STARTOVLYDMA | OVLYHALTERR);
+		/* 
+		 * Start the DMA. We need to set the higher two bytes of 
+		 * OVLYDMACTL register before programming the lower two bytes 
+		 * as the lowest byte of OVLYDMACTL register contains 
+		 * STARTOVLYDMA bit which once is written, will start the DMA.
+		 */
+		asd_write_word(asd, (OVLYDMACTL+2), ovlydmactl_hi);
+		asd_write_word(asd, OVLYDMACTL, ovlydmactl_lo);		
+			       
+	       	timer_tick = ASD_REG_TIMEOUT_TICK;
+		do {
+			/*
+			 * Check if the Overlay DMA is still active. 
+			 * It will get reset once the transfer is done.
+			 */
+			if (asd_read_dword(asd, OVLYDMACTL) & OVLYDMAACT) {
+				timer_tick--;		
+				asd_delay(ASD_DELAY_COUNT);
+			} else
+				break;
+		} while (timer_tick != 0);
+		
+		/*
+		 * Check if the DMA transfer has completed successfully.
+		 */
+		if ((timer_tick != 0) && 
+		    (asd_read_dword(asd, COMSTAT) & OVLYDMADONE) &&
+		    (!(asd_read_dword(asd, COMSTAT) & OVLYERR)) &&
+		    (!(asd_read_dword(asd, CHIMINT) & DEVEXCEPT_MASK))) {
+			/* DMA transfer completed successfully. */
+			ovlyaddr += instr_size;
+			/*
+			 * Sanity check when we doing the last segment, 
+			 * make sure that we only transfer the remaing code
+			 * size.
+			 */ 
+			if (++i == (nseg - 1))
+				instr_size = code_size - (i * instr_size);
+		} else {
+			/* DMA transfer failed. */
+			asd_log(ASD_DBG_ERROR, "%s download failed.\n",
+				(lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+			error = -1;
+			goto exit;
+		}
+	} 
+
+	/* Restore the Interrupt Mask. */
+	asd_write_dword(asd, COMSTATEN, comstaten_val);	
+
+	/* Verify that the sequencer is downloaded properly. */
+	asd_log(ASD_DBG_INFO, "Verifying %s ...\n", 
+		(lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+	if (asd_hwi_verify_seqs(asd, code, code_size, lseq_mask) != 0) {
+		asd_log(ASD_DBG_ERROR, "%s verify failed.\n",
+			(lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+		error = -1;
+		goto exit;
+	}
+	asd_log(ASD_DBG_INFO, "%s verified successfully.\n", 
+		(lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+
+exit:
+	asd_free_dma_mem(asd, buf_dmat, &buf_map);
+	
+	return (error);
+}
+
+#else
+
+/* 
+ * Function:
+ *	asd_hwi_pio_load_seqs()
+ *
+ * Description:
+ *	Download the sequencers using PIO mode.  
+ */
+int
+asd_hwi_pio_load_seqs(struct asd_softc *asd, uint8_t*code,
+		      uint32_t code_size, uint8_t lseq_mask)
+{
+	uint32_t	reg_val;
+	uint32_t	instr;
+	uint32_t	i;
+	
+	if (code_size % 4) {
+		/*
+		 * For PIO mode, sequencer code size must be multiple of dword.
+		 */
+		asd_log(ASD_DBG_ERROR, "SEQ code size (%d) not multiple of "
+			"dword. \n", code_size);	
+		return (-1);
+	}
+	/* Set to PIO Mode */
+	reg_val = PIOCMODE;
+		
+	/* lseq_mask tells us which sequencer(s) the code is for. */
+	if (lseq_mask != 0)
+		reg_val |= (uint32_t) (((uint16_t) lseq_mask) << 8);
+	else
+		reg_val |= OVLYCSEQ;
+
+	/*
+	 * Progam the sequencer RAM address, which sequencer(s) to load and the
+	 * download mode.
+	 */	
+	/* Program the download size. */
+	asd_write_dword(asd, OVLYDMACNT, code_size);
+	asd_write_dword(asd, OVLYDMACTL, reg_val); 	
+	
+	asd_log(ASD_DBG_INFO, "Downloading %s (PIO Mode) ...\n", 
+		(lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+	/* Download the instr 4 bytes a time. */
+	for (i = 0; i < (code_size/4); i++) {
+		instr = *(uint32_t *) &code[i*4];
+		/* The sequencer is little-endian. */
+		instr = asd_htole32(instr);
+		asd_write_dword(asd, SPIODATA, instr);	
+	}
+	
+	/*
+	 * TBRV : Check Device Exception Error ??
+	 */
+	 
+	/* Clear the PIO mode bit and enabled Overlay Halt Error. */
+	reg_val = (reg_val & ~PIOCMODE) | OVLYHALTERR;
+	asd_write_dword(asd, OVLYDMACTL, reg_val);
+	
+	/* Verify that the sequencer is downloaded properly. */
+	asd_log(ASD_DBG_INFO,
+		"Verifying %s ...\n", (lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+	if (asd_hwi_verify_seqs(asd, code, code_size, lseq_mask) != 0) {
+		asd_log(ASD_DBG_ERROR, "%s verify failed.\n",
+			(lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+		return (-1);
+	}
+	asd_log(ASD_DBG_INFO, "%s verified successfully.\n", 
+		(lseq_mask == 0 ? "CSEQ" : "LSEQ"));
+
+	return (0);
+}
+
+#endif
+
+/* 
+ * Function:
+ *	asd_hwi_verify_seqs()
+ *
+ * Description:
+ *	Verify the downloaded sequencer.  
+ */
+static int
+asd_hwi_verify_seqs(struct asd_softc *asd, uint8_t *code, 
+		    uint32_t code_size, uint8_t lseq_mask)
+{
+	int		error;
+	uint32_t	base_addr;
+	uint32_t	page_offset;
+	uint32_t	instr;
+	uint32_t	i;
+	uint8_t		temp_lseq_mask;	
+	uint8_t		phy_id;
+
+	error = 0;
+	phy_id = 0;
+	temp_lseq_mask = lseq_mask;	
+	do {	
+		if (temp_lseq_mask == 0) {
+			/* Get CSEQ Instruction RAM base addr. */
+			base_addr = CSEQ_RAM_REG_BASE_ADR;
+		} else {
+			for ( ; phy_id < asd->hw_profile.max_phys; phy_id++) {
+				if (temp_lseq_mask & (1 << phy_id)) {
+					temp_lseq_mask &= ~(1 << phy_id);
+					break;
+				}
+			}
+			
+			/* Get the LmSEQ Instruction RAM base addr. */
+			base_addr = (uint32_t) LmSEQRAM(phy_id);;
+			/*
+			 * Set the LmSEQ Instruction Memory Page to 0.
+			 * LmSEQRAM is mapped 4KB in internal memory space.
+			 */
+			asd_hwi_swb_write_dword(asd, LmBISTCTL1(phy_id), 0);
+		}	
+		
+		page_offset = 0;
+		for (i = 0; i < (code_size/4); i++) {
+			if ((base_addr != CSEQ_RAM_REG_BASE_ADR) && (i > 0) &&
+			    ((i % 1024) == 0)) {
+				/*
+			 	 * For LSEQ, we need to adjust the LmSEQ 
+				 * Instruction Memory page to the next 4KB page
+				 * once we past the page boundary.
+				 */
+				asd_hwi_swb_write_dword(asd, 
+							LmBISTCTL1(phy_id), 
+							((i / 1024) <<
+							 LmRAMPAGE_LSHIFT));
+				page_offset = 0;		 
+			}				  
+		
+			/* 
+		 	 * Compare dword at a time since Instruction RAM page is
+		 	 * dword accessible read only.
+		 	 */ 
+			instr = asd_htole32(*(uint32_t *)&code[i*4]);
+			if (instr != asd_hwi_swb_read_dword(asd, 
+					base_addr + page_offset)) {
+				/* Code doesn't match. */
+				error = -1;
+				break;
+			}
+			page_offset += 4;
+		}
+		/* Done verifing the sequencer(s). */
+		if (temp_lseq_mask == 0)
+			break;
+	} while (error == 0);
+
+	return (error);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_setup_seqs()
+ *
+ * Description:
+ *	Setup and initialize Central and Link sequencers.  
+ */
+void
+asd_hwi_setup_seqs(struct asd_softc *asd)
+{
+	int 		link_num;
+	uint8_t		enabled_phys;
+
+#define ASD_SET_INT_VEC(asd, vec)	\
+	(ASD_USE_A1_CODE(asd) == 1 ? ASD_INT_VEC(vec, A1) :	\
+	 ASD_INT_VEC(vec, B0))
+
+	/* Initialize CSEQ Scratch RAM registers. */
+	asd_hwi_init_cseq_scratch(asd);
+	
+	/* Initialize LmSEQ Scratch RAM registers. */
+	asd_hwi_init_lseq_scratch(asd);
+
+	/* Initialize SCB sites. */
+	asd_hwi_init_scb_sites(asd);
+
+	/* Initialize CSEQ CIO registers. */
+	asd_hwi_init_cseq_cio(asd);
+		
+	/* Initialize LmSEQ CIO registers. */
+	link_num = 0;
+	enabled_phys = asd->hw_profile.enabled_phys;
+
+	while (enabled_phys != 0) { 
+		for ( ; link_num < asd->hw_profile.max_phys; link_num++) {
+			if (enabled_phys & (1 << link_num)) {
+				enabled_phys &= ~(1 << link_num);
+				break;
+			} 
+		}
+		
+		asd_hwi_init_lseq_cio(asd, link_num);
+	}
+
+	asd_hwi_post_init_cseq(asd);
+
+	//asd_hwi_dump_seq_raw(asd);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_cseq_init_scratch()
+ *
+ * Description:
+ *	Setup and initialize Central sequencers. Initialiaze the mode 
+ *	independent and dependent scratch page to the default settings.
+ */
+static void
+asd_hwi_init_cseq_scratch(struct asd_softc *asd)
+{
+	unsigned	i;
+
+	/* Reset SCBPRO count register. */
+	asd_write_dword(asd, SCBPRO, asd->qinfifonext);
+
+	/*
+	 * Clear out memory
+	 */
+	for (i = 0 ; i < CMAPPEDSCR_LEN ; i+=4)
+		asd_hwi_swb_write_dword(asd, CMAPPEDSCR + i, 0x0000);
+
+	/* Initialize CSEQ Mode Independent Page. */
+	asd_hwi_init_cseq_mip(asd);
+	/* Initialize CSEQ Mode Dependent Page. */
+	asd_hwi_init_cseq_mdp(asd);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_cseq_mip()
+ *
+ * Description:
+ *	Initialize CSEQ Mode Independent Pages 4-7.	 
+ */
+static void
+asd_hwi_init_cseq_mip(struct asd_softc *asd)
+{
+	uint8_t		free_scb_mask;
+	u_int		i;
+#ifdef SEQUENCER_UPDATE
+	uint8_t		val;
+	unsigned	num_bits;
+#endif
+	
+	/*
+	 * -------------------------------------
+	 * CSEQ Mode Independent , page 4 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_word(asd, CSEQ_Q_EXE_HEAD, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_EXE_TAIL, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_DONE_HEAD, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_DONE_TAIL, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_SEND_HEAD, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_SEND_TAIL, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_DMA2CHIM_HEAD, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_DMA2CHIM_TAIL, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_COPY_HEAD, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_COPY_TAIL, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_REG0, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_REG1, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_REG2, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_REG3, 0x0);
+	asd_hwi_swb_write_byte(asd, CSEQ_LINK_CTL_Q_MAP, 0x0);
+#ifdef SEQUENCER_UPDATE
+	val = asd_hwi_swb_read_byte(asd, CCONEXIST);
+
+	for (i = 0, num_bits = 0 ; i < 8 ; i++) {
+		if ((val & (1 << i)) != 0) {
+			num_bits++;
+		}
+	}
+
+	asd_hwi_swb_write_byte(asd, CSEQ_MAX_CSEQ_MODE, 
+		(num_bits << 4) | num_bits);
+#else
+	asd_hwi_swb_write_byte(asd, CSEQ_SCRATCH_FLAGS, 0x0);
+#endif
+
+	/*
+	 * -------------------------------------
+	 * CSEQ Mode Independent , page 5 setup.
+	 * -------------------------------------
+	 */
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_dword(asd, CSEQ_EST_NEXUS_REQ_QUEUE, 0);
+	asd_hwi_swb_write_dword(asd, CSEQ_EST_NEXUS_REQ_QUEUE + 4, 0);
+	asd_hwi_swb_write_dword(asd, CSEQ_EST_NEXUS_REQ_COUNT, 0);
+	asd_hwi_swb_write_dword(asd, CSEQ_EST_NEXUS_REQ_COUNT + 4, 0);
+	asd_hwi_swb_write_word(asd, CSEQ_EST_NEXUS_HEAD, 0xffff);
+	asd_hwi_swb_write_word(asd, CSEQ_EST_NEXUS_TAIL, 0xffff);
+	asd_hwi_swb_write_word(asd, CSEQ_NEED_EST_NEXUS_SCB, 0);
+	asd_hwi_swb_write_byte(asd, CSEQ_EST_NEXUS_REQ_HEAD, 0);
+	asd_hwi_swb_write_byte(asd, CSEQ_EST_NEXUS_REQ_TAIL, 0);
+	asd_hwi_swb_write_byte(asd, CSEQ_EST_NEXUS_SCB_OFFSET, 0);
+#else
+	/* Calculate the free scb mask. */
+	free_scb_mask = (uint8_t) ((~(((asd->hw_profile.max_scbs * 
+					ASD_SCB_SIZE) / 128) - 1)) >> 8);
+
+	asd_hwi_swb_write_byte(asd, CSEQ_FREE_SCB_MASK, free_scb_mask);
+			       		       
+	/* 
+	 * Fill BUILTIN_FREE_SCB_HEAD with the first scb no. and 
+	 * BUILTIN_FREE_SCB_TAIL with the last scb no.
+	 */
+	asd_hwi_swb_write_word(asd, CSEQ_BUILTIN_FREE_SCB_HEAD, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_BUILTIN_FREE_SCB_TAIL,
+			      ((((ASD_MAX_SCB_SITES-1) & 0xFF) == 0xFF) ?
+			      (ASD_MAX_SCB_SITES-2) : (ASD_MAX_SCB_SITES-1))); 
+		
+	/* Extended SCB sites are not being used now. */
+	asd_hwi_swb_write_word(asd, CSEQ_EXTNDED_FREE_SCB_HEAD, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_EXTNDED_FREE_SCB_TAIL, 0xFFFF);
+#endif
+
+	/*
+	 * -------------------------------------
+	 * CSEQ Mode Independent , page 6 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_word(asd, CSEQ_INT_ROUT_RET_ADDR0, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_INT_ROUT_RET_ADDR1, 0x0);	
+	asd_hwi_swb_write_word(asd, CSEQ_INT_ROUT_SCBPTR, 0x0);
+	asd_hwi_swb_write_byte(asd, CSEQ_INT_ROUT_MODE, 0x0);
+	asd_hwi_swb_write_byte(asd, CSEQ_ISR_SCRATCH_FLAGS, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_ISR_SAVE_SINDEX, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_ISR_SAVE_DINDEX, 0x0);
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_swb_write_word(asd, CSEQ_SLS_SAVE_ACCUM, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_SLS_SAVE_SINDEX, 0x0);
+#endif
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_word(asd, CSEQ_Q_MONIRTT_HEAD, 0xffff);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_MONIRTT_TAIL, 0xffff);
+
+	/* Calculate the free scb mask. */
+#ifdef EXTENDED_SCB
+   free_scb_mask = (uint8_t) ((~((( (asd->hw_profile.max_scbs - ASD_EXTENDED_SCB_NUMBER) * 
+					ASD_SCB_SIZE) / 128) - 1)) >> 8);
+#else
+   free_scb_mask = (uint8_t) ((~(((asd->hw_profile.max_scbs * 
+					ASD_SCB_SIZE) / 128) - 1)) >> 8);
+#endif
+	asd_hwi_swb_write_byte(asd, CSEQ_FREE_SCB_MASK, free_scb_mask);
+			       		       
+	/* 
+	 * Fill BUILTIN_FREE_SCB_HEAD with the first scb no. and 
+	 * BUILTIN_FREE_SCB_TAIL with the last scb no.
+	 */
+	/*
+	 * We have to skip 0x00 - 0x1f
+	 */
+#ifdef SATA_SKIP_FIX
+	asd_hwi_swb_write_word(asd, CSEQ_BUILTIN_FREE_SCB_HEAD, 0x20);
+#else
+	asd_hwi_swb_write_word(asd, CSEQ_BUILTIN_FREE_SCB_HEAD, 0x0);
+#endif
+	asd_hwi_swb_write_word(asd, CSEQ_BUILTIN_FREE_SCB_TAIL,
+			      ((((ASD_MAX_SCB_SITES-1) & 0xFF) == 0xFF) ?
+			      (ASD_MAX_SCB_SITES-2) : (ASD_MAX_SCB_SITES-1))); 
+
+#ifndef EXTENDED_SCB		
+	/* Extended SCB sites are not being used now. */
+	asd_hwi_swb_write_word(asd, CSEQ_EXTNDED_FREE_SCB_HEAD, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_EXTNDED_FREE_SCB_TAIL, 0xFFFF);
+#else //EXTENDED_SCB
+	/* Extended SCB sites are not being used now. */
+
+#ifdef SATA_SKIP_FIX
+	asd_hwi_swb_write_word(asd, CSEQ_EXTNDED_FREE_SCB_HEAD, (uint16_t)ASD_MAX_SCB_SITES + 0x20);
+#else //!SATA_SKIP_FIX
+	asd_hwi_swb_write_word(asd, CSEQ_EXTNDED_FREE_SCB_HEAD, (uint16_t)ASD_MAX_SCB_SITES );
+#endif //ifdef SATA_SKIP_FIX
+
+	asd_hwi_swb_write_word(asd, CSEQ_EXTNDED_FREE_SCB_TAIL, (uint16_t)(asd->hw_profile.max_scbs - 1));
+#endif //ifndef EXTENDED_SCB
+
+#endif 
+	
+	/*
+	 * -------------------------------------
+	 * CSEQ Mode Independent , page 7 setup.
+	 * -------------------------------------
+	 */
+	for (i = 0; i < 8; i = i+4) {
+		asd_hwi_swb_write_dword(asd,
+				       (CSEQ_EMPTY_REQ_QUEUE + i),
+					0x0);
+		asd_hwi_swb_write_dword(asd,
+				       (CSEQ_EMPTY_REQ_COUNT + i),
+					0x0);	
+	}
+	/* Initialize Q_EMPTY_HEAD and Q_EMPTY_TAIL. */
+	asd_hwi_swb_write_word(asd, CSEQ_Q_EMPTY_HEAD, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_Q_EMPTY_TAIL, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_NEED_EMPTY_SCB, 0x0);
+	asd_hwi_swb_write_byte(asd, CSEQ_EMPTY_REQ_HEAD, 0x0);
+	asd_hwi_swb_write_byte(asd, CSEQ_EMPTY_REQ_TAIL, 0x0);
+	asd_hwi_swb_write_byte(asd, CSEQ_EMPTY_SCB_OFFSET, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_PRIMITIVE_DATA, 0x0);
+	asd_hwi_swb_write_dword(asd, CSEQ_TIMEOUT_CONSTANT, 0x0);
+
+#ifdef EXTENDED_SCB
+//Todo 128 byte alignment
+	{
+		uint64_t dmabusaddr;
+		dmabusaddr = (asd->ext_scb_map.busaddr + ASD_SCB_SIZE - 1)&(uint64_t)(-1 * ASD_SCB_SIZE);
+#ifdef ASD_DEBUG
+		asd_print("Extended SCB busaddr:0x%Lx, dmabusaddr:0x%Lx\n", asd->ext_scb_map.busaddr, dmabusaddr);
+#endif
+		asd_hwi_swb_write_dword(asd, (CMAPPEDSCR + CMDCTXBASE), ASD_GET_PADR(dmabusaddr));
+		asd_hwi_swb_write_dword(asd, (CMAPPEDSCR + CMDCTXBASE + 4), ASD_GET_PUADR(dmabusaddr));
+	//	CTXDOMAIN ?
+	}
+#endif
+	
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_cseq_mdp()
+ *
+ * Description:
+ *	Initialize CSEQ Mode Dependent Pages.	 
+ */
+static void	
+asd_hwi_init_cseq_mdp(struct asd_softc *asd)
+{
+	u_int	i;
+	u_int	mode_offset; 
+
+	mode_offset = CSEQ_PAGE_SIZE * 2;
+	
+	/* CSEQ Mode Dependent 0-7, page 0 setup. */
+	for (i = 0; i < 8; i++) {
+		asd_hwi_swb_write_word(asd, ((i * mode_offset) + 
+				       CSEQ_LRM_SAVE_SINDEX), 0x0);
+		asd_hwi_swb_write_word(asd, ((i * mode_offset) + 
+				       CSEQ_LRM_SAVE_SCBPTR), 0x0);
+		asd_hwi_swb_write_word(asd, ((i * mode_offset) + 
+				       CSEQ_Q_LINK_HEAD), 0xFFFF);
+		asd_hwi_swb_write_word(asd, ((i * mode_offset) +
+				       CSEQ_Q_LINK_TAIL), 0xFFFF);
+	}
+	
+	/* CSEQ Mode Dependent 0-7, page 1 and 2 shall be ignored. */
+
+	/* CSEQ Mode Dependent 8, page 0 setup. */
+	asd_hwi_swb_write_word(asd, CSEQ_RET_ADDR, 0xFFFF);
+	asd_hwi_swb_write_word(asd, CSEQ_RET_SCBPTR, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_SAVE_SCBPTR, 0x0);
+	//asd_hwi_swb_write_word(asd, CSEQ_EMPTY_TRANS_CTX, 0x0);
+	asd_hwi_swb_write_dword(asd, CSEQ_EMPTY_TRANS_CTX, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_RESP_LEN, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_TMF_SCBPTR, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_GLOBAL_PREV_SCB, 0x0);
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_word(asd, CSEQ_CLEAR_LU_HEAD, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_TMF_OPCODE, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_SCRATCH_FLAGS, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_HSS_SITE, 0x0);
+#else
+	asd_hwi_swb_write_word(asd, CSEQ_GLOBAL_HEAD, 0x0);
+	asd_hwi_swb_write_byte(asd, CSEQ_TMF_OPCODE, 0x0);
+	asd_hwi_swb_write_word(asd, CSEQ_CLEAR_LU_HEAD, 0x0);
+#endif
+	asd_hwi_swb_write_word(asd, CSEQ_FIRST_INV_SCB_SITE,
+			       ASD_MAX_SCB_SITES);
+	asd_hwi_swb_write_word(asd, CSEQ_FIRST_INV_DDB_SITE, ASD_MAX_DDBS);
+
+	/* CSEQ Mode Dependent 8, page 1 setup. */
+	asd_hwi_swb_write_dword(asd, CSEQ_LUN_TO_CLEAR, 0x0);
+	asd_hwi_swb_write_dword(asd, (CSEQ_LUN_TO_CLEAR + 4), 0x0);
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_swb_write_dword(asd, CSEQ_LUN_TO_CHECK, 0x0);
+	asd_hwi_swb_write_dword(asd, (CSEQ_LUN_TO_CHECK + 4), 0x0);
+#endif
+
+	/* CSEQ Mode Dependent 8, page 2 setup. */
+	/* Advertise the first SCB site address to the sequencer. */
+	asd_hwi_set_hw_addr(asd, CSEQ_Q_NEW_POINTER,
+			    asd->next_queued_hscb_busaddr);
+
+	/* Advertise the first Done List address to the sequencer.*/
+	asd_hwi_set_hw_addr(asd, CSEQ_Q_DONE_BASE,
+			    asd->shared_data_map.busaddr);
+
+	/* 
+	 * Initialize the Q_DONE_POINTER with the least significant bytes of 
+	 * the first Done List address.
+	 */
+	asd_hwi_swb_write_dword(asd, CSEQ_Q_DONE_POINTER,
+				ASD_GET_PADR(asd->shared_data_map.busaddr));
+
+	asd_hwi_swb_write_byte(asd, CSEQ_Q_DONE_PASS, ASD_QDONE_PASS_DEF);
+	
+	/* CSEQ Mode Dependent 8, page 3 shall be ignored. */
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_cseq_cio()
+ *
+ * Description:
+ *	Initialize CSEQ CIO Registers.	 
+ */
+static void
+asd_hwi_init_cseq_cio(struct asd_softc *asd)
+{
+	uint8_t		dl_bits;
+	u_int		i;
+	
+	/* Enabled ARP2HALTC (ARP2 Halted from Halt Code Write). */
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_byte(asd, CARP2INTEN, 
+		EN_ARP2HALTC | EN_ARP2ILLOPC | EN_ARP2PERR | EN_ARP2CIOPERR);
+
+	asd_hwi_swb_write_dword(asd, CARP2BREAKADR01, 0x0fff0fff);
+	asd_hwi_swb_write_dword(asd, CARP2BREAKADR23, 0x0fff0fff);
+#else
+	asd_hwi_swb_write_byte(asd, CARP2INTEN, EN_ARP2HALTC);
+#endif
+
+	/* Initialize CSEQ Scratch Page to 0x04. */
+	asd_hwi_swb_write_byte(asd, CSCRATCHPAGE, 0x04);
+	
+	/* Initialize CSEQ Mode[0-8] Dependent registers. */	
+	for (i = 0; i < 9; i++) 
+		/* Initialize Scratch Page to 0. */
+		asd_hwi_swb_write_byte(asd, CMnSCRATCHPAGE(i), 0x0);
+	
+	/* 
+	 * CSEQCOMINTEN, CSEQDLCTL, and CSEQDLOFFS are in Mode 8.
+	 */
+	asd_hwi_swb_write_byte(asd, CSEQCOMINTEN, 0x0);
+	
+	/*
+	 * Get the DONELISTSIZE bits by calculate number of DL entry 
+	 * available and set the value to the DoneList Control register.
+	 */
+	dl_bits = ffs(asd->dl_wrap_mask + 1);
+	
+	/* Minimum amount of done lists is 4. Reduce dl_bits by 3. */
+	dl_bits -= 3;
+	asd_hwi_swb_write_byte(asd, CSEQDLCTL, 
+		((asd_hwi_swb_read_byte(asd, CSEQDLCTL) & 
+		 ~DONELISTSIZE_MASK) | dl_bits));
+	
+	asd_hwi_swb_write_byte(asd, CSEQDLOFFS, 0);
+	asd_hwi_swb_write_byte(asd, (CSEQDLOFFS+1), 0);
+
+	/* Reset the Producer mailbox. */
+	asd_write_dword(asd, SCBPRO, 0x0);				
+
+	/* Intialize CSEQ Mode 11 Interrupt Vectors. */
+	asd_hwi_swb_write_word(asd, CM11INTVEC0, 
+			      ((ASD_SET_INT_VEC(asd, CSEQ_INT_VEC0)) / 4));
+	asd_hwi_swb_write_word(asd, CM11INTVEC1,
+			      ((ASD_SET_INT_VEC(asd, CSEQ_INT_VEC1)) / 4));
+	asd_hwi_swb_write_word(asd, CM11INTVEC2,
+			      ((ASD_SET_INT_VEC(asd, CSEQ_INT_VEC2)) / 4));
+
+	/* Reset the ARP2 Program Count. */
+	asd_hwi_swb_write_word(asd, CPRGMCNT, (CSEQ_IDLE_LOOP_ENTRY / 4));
+
+	for (i = 0; i < 8; i++) {
+		/* Intialize Mode n Link m Interrupt Enable. */
+		asd_hwi_swb_write_dword(asd, CMnINTEN(i), EN_CMnRSPMBXF);
+		/* Initialize Mode n Request Mailbox. */
+		asd_hwi_swb_write_dword(asd, CMnREQMBX(i), 0x0);	
+	}
+
+	/* Reset the Consumer mailbox. */
+	asd_hwi_swb_write_dword(asd, CSEQCON, 0x0);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_scb_sites()
+ *
+ * Description:
+ *	Initialize HW SCB sites.	 
+ */
+static void
+asd_hwi_init_scb_sites(struct asd_softc *asd)
+{
+	uint16_t	site_no;
+	uint16_t	next_site_no;
+	u_int		i;
+
+#ifndef EXTENDED_SCB
+	for (site_no = 0; site_no < ASD_MAX_SCB_SITES; site_no++) {
+#else
+	for (site_no = 0; site_no < (ASD_MAX_SCB_SITES + ASD_EXTENDED_SCB_NUMBER); site_no++) {
+#endif
+		/* 
+		 * Adjust to the SCB site that we want to access in command
+		 * context memory.
+		 */	 
+		asd_hwi_set_scbptr(asd, site_no);
+
+		/* Initialize all fields in the SCB site to 0. */
+		for (i = 0; i < ASD_SCB_SIZE; i += 4)
+			asd_hwi_set_scbsite_dword(asd, i, 0x0);
+		/* Initialize SCB Site Opcode field to invalid. */
+		asd_hwi_set_scbsite_byte(asd,offsetof(struct hscb_header, opcode),
+				       0xFF);
+
+		/* Initialize SCB Site Flags field to mean a response
+		 * frame has been received.  This means inadvertent
+		 * frames received to be dropped. */
+		asd_hwi_set_scbsite_byte(asd,0x49, 0x01);
+
+
+		/*
+		 * Workaround needed by SEQ to fix a SATA issue is to skip
+	      	 * including scb sites that ended with FFh in the sequencer
+		 * free list.
+		 */
+		if ((site_no & 0xF0FF) == 0x00FF)
+			continue;
+#ifdef SATA_SKIP_FIX
+		/*
+		 * Another work around. Skip the first 32 SCBs in each
+		 * group of 256.
+		 */
+		if ((site_no & 0xF0FF) <= 0x001F)
+			continue;
+#endif
+		
+		/*
+		 * For every SCB site, we need to initialize the following 
+		 * fields: Q_NEXT, SCB_OPCODE, SCB_FLAGS, and SG Element Flag.
+		 */
+
+		next_site_no = ((((site_no+1) & 0xF0FF) == 0x00FF) ?
+				  (site_no+2) : (site_no+1));
+#ifdef SATA_SKIP_FIX
+		if ((next_site_no & 0xF0FF) == 0x0000)
+			next_site_no = next_site_no + 0x20;
+#endif
+		/* 
+	 	 * Set the Q_NEXT of last usable SCB site to 0xFFFF.
+	 	 */
+#ifndef EXTENDED_SCB
+		if (next_site_no >= ASD_MAX_SCB_SITES)
+#else
+		if ( (next_site_no >= (ASD_MAX_SCB_SITES + ASD_EXTENDED_SCB_NUMBER)) ||
+			 (site_no == (ASD_MAX_SCB_SITES-1)) )
+#endif
+			next_site_no = 0xFFFF;
+
+		/* Initialize SCB Site Opcode field. */
+		asd_hwi_set_scbsite_byte(asd, 
+					 offsetof(struct hscb_header, opcode),
+					 0xFF);	
+
+		/* Initialize SCB Site Flags field. */
+		asd_hwi_set_scbsite_byte(asd, SCB_SITE_FLAGS, 0x01);	
+
+		/* 
+		 * Set the first SG Element flag to no data transfer.
+		 * Also set Domain Select to OffChip memory. 
+		 */
+		asd_hwi_set_scbsite_byte(asd, 
+			offsetof(struct asd_ssp_task_hscb,
+				sg_elements[0].flags), SG_NO_DATA);
+
+		/* 
+		 * Initialize Q_NEXT field to point to the next SCB site.
+		 */
+		asd_hwi_set_scbsite_word(asd, SCB_SITE_Q_NEXT, next_site_no);
+	}
+}
+
+/* 
+ * Function:
+ *	asd_hwi_post_init_cseq()
+ *
+ * Description:
+ * 	Clear CSEQ Mode n Interrupt status and Response mailbox.
+ */
+static void
+asd_hwi_post_init_cseq(struct asd_softc *asd)
+{
+	u_int		i;
+
+	for (i = 0; i < 8; i++) {
+		asd_hwi_swb_write_dword(asd, CMnINT(i), 0xFFFFFFFF);	
+		asd_hwi_swb_read_dword(asd, CMnRSPMBX(i));
+	}
+	
+	/* Reset the External Interrupt Control. */
+	asd_hwi_swb_write_byte(asd, CARP2INTCTL, RSTINTCTL); 
+}
+
+/* 
+ * Function:
+ *	asd_hwi_lseq_init_scratch()
+ *
+ * Description:
+ *	Setup and initialize Link sequencers. Initialiaze the mode 
+ *	independent and dependent scratch page to the default settings.
+ */
+static void
+asd_hwi_init_lseq_scratch(struct asd_softc *asd)
+{
+	unsigned	i;
+	uint8_t		enabled_phys;
+	u_int		link_num;
+	
+	link_num = 0;
+	enabled_phys = asd->hw_profile.enabled_phys;
+	do {
+		for ( ; link_num < asd->hw_profile.max_phys; link_num++) {
+			if (enabled_phys & (1 << link_num)) {
+				enabled_phys &= ~(1 << link_num);
+				break;
+			} 
+		}
+
+		/*
+		 * Clear out memory
+		 */
+		for (i = 0 ; i < LmMAPPEDSCR_LEN ; i+=4)
+			asd_hwi_swb_write_dword(asd, LmSCRATCH(link_num) + i,
+				0x0000);
+		
+		/* Initialize LmSEQ Mode Independent Page. */
+		asd_hwi_init_lseq_mip(asd, link_num); 
+
+		/* Initialize LmSEQ Mode Dependent Page. */
+		asd_hwi_init_lseq_mdp(asd, link_num);
+
+	} while (enabled_phys != 0); 
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_lseq_mip()
+ *
+ * Description:
+ *	Initialize LSEQ Mode Independent Pages 0-3.	 
+ */
+static void
+asd_hwi_init_lseq_mip(struct asd_softc *asd, u_int link_num)
+{
+	u_int	i;
+	
+	/* ------------------------------------- */
+	/* LSEQ Mode Independent , page 0 setup. */
+	/* ------------------------------------- */
+	asd_hwi_swb_write_word(asd, LmSEQ_Q_TGTXFR_HEAD(link_num), 0xFFFF);
+	asd_hwi_swb_write_word(asd, LmSEQ_Q_TGTXFR_TAIL(link_num), 0xFFFF);
+	asd_hwi_swb_write_byte(asd, LmSEQ_LINK_NUMBER(link_num),
+			      (uint8_t) link_num);
+
+#if SAS_ENABLE_NOTIFY
+	/*
+	 * TBRV: For Seagate Gen 1.5 drive, we need to issue NOTIFY primitive 
+	 * 	 before we issue the first IO to the drive.
+	 *	 Need to investigate how other drives (such as Hitachi, Maxtor)
+	 *	 behave. This might be set to default case if all other drives
+	 *	 also required NOTIFY primitive to be sent.
+	 */
+	asd_hwi_swb_write_byte(asd, LmSEQ_SCRATCH_FLAGS(link_num), 
+			       SAS_NOTIFY_SPINUP_ENABLED);
+#else
+	asd_hwi_swb_write_byte(asd, LmSEQ_SCRATCH_FLAGS(link_num), 0x0);
+#endif
+
+	asd_hwi_swb_write_dword(asd, LmSEQ_CONNECTION_STATE(link_num), 
+				0x08000000);
+	asd_hwi_swb_write_word(asd, LmSEQ_CONCTL(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_CONSTAT(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_CONNECTION_MODES(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_REG1_ISR(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_REG2_ISR(link_num), 0x0);		
+	asd_hwi_swb_write_word(asd, LmSEQ_REG3_ISR(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_REG0_ISR(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, (LmSEQ_REG0_ISR(link_num) + 4), 0x0);
+	
+	/* ------------------------------------- */
+	/* LSEQ Mode Independent , page 1 setup. */
+	/* ------------------------------------- */
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_word(asd, LmSEQ_EST_NEXUS_SCB_PTR0(link_num), 0xFFFF);
+	asd_hwi_swb_write_word(asd, LmSEQ_EST_NEXUS_SCB_PTR1(link_num), 0xFFFF);
+	asd_hwi_swb_write_word(asd, LmSEQ_EST_NEXUS_SCB_PTR2(link_num), 0xFFFF);
+	asd_hwi_swb_write_word(asd, LmSEQ_EST_NEXUS_SCB_PTR3(link_num), 0xFFFF);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EST_NEXUS_SCB_OPCD0(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EST_NEXUS_SCB_OPCD1(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EST_NEXUS_SCB_OPCD2(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EST_NEXUS_SCB_OPCD3(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EST_NEXUS_SCB_HEAD(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EST_NEXUS_SCB_TAIL(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EST_NEXUS_BUFS_AVAIL(link_num), 0x0);
+#else
+	asd_hwi_swb_write_byte(asd, LmSEQ_FRAME_TYPE_MASK(link_num), 0xFF);
+	/* Hashed Destination Address (3 bytes). */	
+	for (i = 0; i < 3; i++)
+		asd_hwi_swb_write_byte(asd, 
+				      (LmSEQ_HASHED_DEST_ADDR_MASK(link_num)+i),
+				       0xFF);
+	/* Reserved field (1 byte). */
+	asd_hwi_swb_write_byte(asd, (LmSCRATCH(link_num) + 0x01A4), 0x0);
+	
+	/* Hashed Source Address (3 bytes). */
+	for (i = 0; i < 3; i++)
+		asd_hwi_swb_write_byte(asd, 
+				      (LmSEQ_HASHED_SRC_ADDR_MASK(link_num)+i),
+				       0xFF);	
+	/* Reserved fields (2 bytes). */
+	asd_hwi_swb_write_word(asd, (LmSCRATCH(link_num) + 0x01A8), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_RETRANSMIT_MASK(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_NUM_FILL_BYTES_MASK(link_num), 0x0);
+	/* Reserved field (4 bytes). */
+	asd_hwi_swb_write_dword(asd, (LmSCRATCH(link_num) + 0x01AC), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_TAG_MASK(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_TARGET_PORT_XFER_TAG(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_DATA_OFFSET(link_num), 0xFFFFFFFF);
+#endif
+	asd_hwi_swb_write_word(asd, LmSEQ_ISR_SAVE_SINDEX(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_ISR_SAVE_DINDEX(link_num), 0x0);	
+	
+	/* ------------------------------------- */
+	/* LSEQ Mode Independent , page 2 setup. */
+	/* ------------------------------------- */
+	asd_hwi_swb_write_word(asd, LmSEQ_EMPTY_SCB_PTR0(link_num), 0xFFFF);
+	asd_hwi_swb_write_word(asd, LmSEQ_EMPTY_SCB_PTR1(link_num), 0xFFFF);
+	asd_hwi_swb_write_word(asd, LmSEQ_EMPTY_SCB_PTR2(link_num), 0xFFFF);
+	asd_hwi_swb_write_word(asd, LmSEQ_EMPTY_SCB_PTR3(link_num), 0xFFFF);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EMPTY_SCB_OPCD0(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EMPTY_SCB_OPCD1(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EMPTY_SCB_OPCD2(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EMPTY_SCB_OPCD3(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EMPTY_SCB_HEAD(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EMPTY_SCB_TAIL(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_EMPTY_BUFS_AVAIL(link_num), 0x0);
+
+	for (i = 0; i < 12; i += 4)
+		asd_hwi_swb_write_dword(asd, (LmSEQ_ATA_SCR_REGS(link_num) + i),
+			       		0x0);	
+	 
+	/* ------------------------------------- */
+	/* LSEQ Mode Independent , page 3 setup. */
+	/* ------------------------------------- */
+	/* 
+	 * Set the desired interval between transmissions of the NOTIFY
+	 * (ENABLE SPINUP) primitive to 500 msecs.
+	 */ 
+	asd_hwi_swb_write_word(asd, LmSEQ_DEV_PRES_TMR_TOUT_CONST(link_num),
+			      (SAS_NOTIFY_TIMER_TIMEOUT_CONST - 1));
+	/* No delay for the first NOTIFY to be sent to the attached target. */
+	asd_hwi_swb_write_word(asd, LmSEQ_NOTIFY_TIMER_DOWN_CNT(link_num),
+			       SAS_DEFAULT_NOTIFY_TIMER_DOWN_CNT);
+	/* Reserved fields (4 bytes). */
+	asd_hwi_swb_write_dword(asd, LmSEQ_SATA_INTERLOCK_TIMEOUT(link_num),
+				0x0);
+	/* Initialize STP shutdown timeout to 50 usecs. */
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_swb_write_dword(asd, LmSEQ_STP_SHUTDOWN_TIMEOUT(link_num),
+				SAS_DEFAULT_STP_SHUTDOWN_TIMER_TIMEOUT);
+#endif
+	asd_hwi_swb_write_dword(asd, LmSEQ_SRST_ASSERT_TIMEOUT(link_num),
+				SAS_DEFAULT_SRST_ASSERT_TIMEOUT);
+	asd_hwi_swb_write_dword(asd, LmSEQ_RCV_FIS_TIMEOUT(link_num),
+				SAS_DEFAULT_RCV_FIS_TIMEOUT);
+	asd_hwi_swb_write_dword(asd, LmSEQ_ONE_MILLISEC_TIMEOUT(link_num),
+				SAS_DEFAULT_ONE_MILLISEC_TIMEOUT);
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_dword(asd, LmSEQ_TEN_MILLISEC_TIMEOUT(link_num),
+				SAS_DEFAULT_COMINIT_TIMEOUT);
+#else
+	asd_hwi_swb_write_dword(asd, LmSEQ_COMINIT_TIMEOUT(link_num),
+				SAS_DEFAULT_COMINIT_TIMEOUT);
+#endif
+	asd_hwi_swb_write_dword(asd, LmSEQ_SMP_RCV_TIMEOUT(link_num),
+				SAS_DEFAULT_SMP_RCV_TIMEOUT);			
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_lseq_mdp()
+ *
+ * Description:
+ *	Initialize LSEQ Mode Dependent Pages.	 
+ */
+static void
+asd_hwi_init_lseq_mdp(struct asd_softc *asd, u_int link_num)
+{
+	u_int		i, j;
+	uint32_t	mode_offset;
+	
+	/*
+	 * -------------------------------------
+	 * Mode 0,1,2 and 4/5 have common field on page 0 for the first 
+	 * 14 bytes.
+	 * -------------------------------------
+	 */
+	for (i = 0; i < 3; i++) {
+		mode_offset = i * LSEQ_MODE_SCRATCH_SIZE; 
+#ifdef SEQUENCER_UPDATE
+		if (i == 2)
+			asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR(link_num) + 
+					       mode_offset), 0x400); //R_LSEQ_MODE2_TASK(0x1000) >> 2
+		else
+#endif
+		asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR(link_num) + 
+				       mode_offset), 0xFFFF);
+		asd_hwi_swb_write_word(asd, (LmSEQ_REG0_MODE(link_num) +
+				       mode_offset), 0x0);
+		asd_hwi_swb_write_word(asd, (LmSEQ_MODE_FLAGS(link_num) +
+				       mode_offset), 0x0);
+#ifdef SEQUENCER_UPDATE
+		asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR2(link_num) +
+				       mode_offset), 0xFFFF);
+		asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR1(link_num) +
+				       mode_offset), 0xFFFF);
+#endif
+		asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR_SAVE(link_num) +
+				       mode_offset), 0x0);
+		asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR_SAVE2(link_num) +
+				       mode_offset), 0x0);
+		asd_hwi_swb_write_byte(asd, (LmSEQ_OPCODE_TO_CSEQ(link_num) +
+				       mode_offset), 0x0);
+		asd_hwi_swb_write_word(asd, (LmSEQ_DATA_TO_CSEQ(link_num) +
+				       mode_offset), 0x0);
+	}
+	/*
+	 * -------------------------------------
+	 *  Mode 5 page 0 overlaps the same scratch page with Mode 0 page 3.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR(link_num) +
+			       LSEQ_MODE5_PAGE0_OFFSET), 0xFFFF);
+	asd_hwi_swb_write_word(asd, (LmSEQ_REG0_MODE(link_num) + 
+			       LSEQ_MODE5_PAGE0_OFFSET), 0x0);
+	asd_hwi_swb_write_word(asd, (LmSEQ_MODE_FLAGS(link_num) + 
+			       LSEQ_MODE5_PAGE0_OFFSET), 0x0);
+	asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR_SAVE(link_num) + 
+			       LSEQ_MODE5_PAGE0_OFFSET), 0x0);
+	asd_hwi_swb_write_word(asd, (LmSEQ_RET_ADDR_SAVE2(link_num) + 
+			       LSEQ_MODE5_PAGE0_OFFSET), 0x0);
+	asd_hwi_swb_write_byte(asd, (LmSEQ_OPCODE_TO_CSEQ(link_num) + 
+			       LSEQ_MODE5_PAGE0_OFFSET), 0x0);
+	asd_hwi_swb_write_word(asd, (LmSEQ_DATA_TO_CSEQ(link_num) + 
+			       LSEQ_MODE5_PAGE0_OFFSET), 0x0);
+	
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 0, page 0 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_word(asd, LmSEQ_FIRST_INV_DDB_SITE(link_num),
+			       ASD_MAX_DDBS);
+	asd_hwi_swb_write_word(asd, LmSEQ_EMPTY_TRANS_CTX(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_RESP_LEN(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_FIRST_INV_SCB_SITE(link_num), 
+			       ASD_MAX_SCB_SITES);
+	asd_hwi_swb_write_dword(asd, LmSEQ_INTEN_SAVE(link_num), 
+				(uint32_t) LmM0INTEN_MASK);
+	asd_hwi_swb_write_byte(asd, LmSEQ_LNK_RST_FRM_LEN(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_LNK_RST_PROTOCOL(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_RESP_STATUS(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_LAST_LOADED_SGE(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_SAVE_SCBPTR(link_num), 0x0);
+		
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 1, page 0 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_word(asd, LmSEQ_Q_XMIT_HEAD(link_num), 0xFFFF);
+	//asd_hwi_swb_write_word(asd, LmSEQ_M1_EMPTY_TRANS_CTX(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_M1_EMPTY_TRANS_CTX(link_num), 0x0);
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_byte(asd, LmSEQ_FAILED_OPEN_STATUS(link_num), 0x0);
+#endif
+	asd_hwi_swb_write_byte(asd, LmSEQ_XMIT_REQUEST_TYPE(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_M1_RESP_STATUS(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_M1_LAST_LOADED_SGE(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_M1_SAVE_SCBPTR(link_num), 0x0);
+	
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 2, page 0 setup
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_word(asd, LmSEQ_PORT_COUNTER(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_PM_TABLE_PTR(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_SATA_INTERLOCK_TMR_SAVE(link_num),
+			       0x0);
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_word(asd, LmSEQ_COPY_SMP_CONN_TAG(link_num),0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_P0M2_OFFS1AH(link_num),0x0);
+#endif
+	
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 4 and 5, page 0 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_byte(asd, LmSEQ_SAVED_OOB_STATUS(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_SAVED_OOB_MODE(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_Q_LINK_HEAD(link_num), 0xFFFF);
+	asd_hwi_swb_write_byte(asd, LmSEQ_LNK_RST_ERR(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_SAVED_OOB_SIGNALS(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_SAS_RESET_MODE(link_num), 0x0);
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_swb_write_dword(asd, LmSEQ_SAVE_COMINIT_TIMER(link_num), 0x0);
+#endif
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_byte(asd, LmSEQ_LINK_RESET_RETRY_COUNT(link_num), 0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_NUM_LINK_RESET_RETRIES(link_num), 0);
+	asd_hwi_swb_write_word(asd, LmSEQ_OOB_INT_ENABLES(link_num), 0);
+	/*
+	 * Set the desired interval between transmissions of the NOTIFY
+	 * (ENABLE SPINUP) primitive.  Must be initilized to val - 1.
+	 */
+	asd_hwi_swb_write_word(asd, LmSEQ_NOTIFY_TIMER_TIMEOUT(link_num),
+			   ASD_NOTIFY_TIMEOUT - 1);
+	/* No delay for the first NOTIFY to be sent to the attached target. */
+	asd_hwi_swb_write_word(asd, LmSEQ_NOTIFY_TIMER_DOWN_COUNT(link_num),
+			   ASD_NOTIFY_DOWN_COUNT);
+	asd_hwi_swb_write_word(asd, LmSEQ_NOTIFY_TIMER_INITIAL_COUNT(link_num),
+			   ASD_NOTIFY_DOWN_COUNT);
+#endif
+
+	
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 0 and 1, page 1 setup.
+	 * -------------------------------------
+	 */
+	for (i = 0; i < 2; i++)	{
+		/* Start from Page 1 of Mode 0 and 1. */
+		mode_offset = LSEQ_PAGE_SIZE + (i*LSEQ_MODE_SCRATCH_SIZE);
+		/* All the fields of page 1 can be intialized to 0. */
+		for (j = 0; j < LSEQ_PAGE_SIZE; j += 4) {
+			asd_hwi_swb_write_dword(asd, 
+					       (LmSCRATCH(link_num) +
+						mode_offset + j), 0x0);
+		}
+	}
+
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 2, page 1 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_dword(asd, LmSEQ_INVALID_DWORD_CNT(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_DISPARITY_ERROR_CNT(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_LOSS_OF_SYNC_CNT(link_num), 0x0);
+			
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 4 and 5, page 1 shall be ignored.
+	 * -------------------------------------
+	 */
+	
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 0, page 2 setup.
+	 * -------------------------------------
+	 */
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_swb_write_dword(asd, LmSEQ_ATTACHED_SAS_ADDR(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, (LmSEQ_ATTACHED_SAS_ADDR(link_num)+4),
+				0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_INITR_SAS_ADDR(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, (LmSEQ_INITR_SAS_ADDR(link_num)+4), 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_SMP_RCV_TIMER_TERM_TS(link_num),
+				0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_M0_LAST_LOADED_SGE(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_SDB_TAG(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_SDB_MASK(link_num), 0x0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_DEVICE_BITS(link_num), 0x0);
+	asd_hwi_swb_write_word(asd, LmSEQ_SDB_DDB(link_num), 0x0);
+#else
+	asd_hwi_swb_write_dword(asd, LmSEQ_SMP_RCV_TIMER_TERM_TS(link_num), 0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_DEVICE_BITS(link_num), 0);
+	asd_hwi_swb_write_word(asd, LmSEQ_SDB_DDB(link_num), 0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_SDB_NUM_TAGS(link_num), 0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_SDB_CURR_TAG(link_num), 0);
+
+
+#endif
+	
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 1, page 2 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_dword(asd, LmSEQ_TX_ID_ADDR_FRAME(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_TX_ID_ADDR_FRAME(link_num)+4, 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_OPEN_TIMER_TERM_TS(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_SRST_AS_TIMER_TERM_TS(link_num),
+				0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_M1P2_LAST_LOADED_SGE(link_num), 0x0);
+
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 2, page 2 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_dword(asd, LmSEQ_STP_SHUTDOWN_TIMER_TERM_TS(link_num),
+				0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_CLOSE_TIMER_TERM_TS(link_num), 0x0);	
+	asd_hwi_swb_write_dword(asd, LmSEQ_BREAK_TIMER_TERM_TS(link_num), 0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_DWS_RESET_TIMER_TERM_TS(link_num),
+				0x0);
+	asd_hwi_swb_write_dword(asd,
+				LmSEQ_SATA_INTERLOCK_TIMER_TERM_TS(link_num),
+				0x0);
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_dword(asd,
+				LmSEQ_MCTL_TIMER_TERM_TS(link_num),
+				0x0);
+#endif
+	asd_hwi_swb_write_byte(asd, LmSEQ_DOWN_TIMER_DOWN_CNT(link_num), 0x0);
+
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 4 and 5, page 2 setup.
+	 * -------------------------------------
+	 */
+	asd_hwi_swb_write_dword(asd, LmSEQ_COMINIT_TIMER_TERM_TS(link_num),
+				0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_RCV_ID_TIMER_TERM_TS(link_num),
+				0x0);
+	asd_hwi_swb_write_dword(asd, LmSEQ_RCV_FIS_TIMER_TERM_TS(link_num),
+				0x0);
+#ifdef SEQUENCER_UPDATE
+		asd_hwi_swb_write_dword(asd, LmSEQ_DEV_PRES_TIMER_TERM_TS(link_num),	0);
+#endif
+
+#ifdef SEQUENCER_UPDATE
+	/*
+	 * -------------------------------------
+	 * LSEQ Mode Dependent 4 and 5, page 1 setup.
+	 * -------------------------------------
+	 */
+	for (i = 0; i < LSEQ_PAGE_SIZE; i+=4)
+		asd_hwi_swb_write_dword(asd, LmSEQ_FRAME_TYPE_MASK(link_num)+i, 0);
+	asd_hwi_swb_write_byte(asd, LmSEQ_FRAME_TYPE_MASK(link_num),
+				0xff);
+	asd_hwi_swb_write_word(asd, LmSEQ_HASH_DEST_ADDR_MASK(link_num),
+				0xffff);
+	asd_hwi_swb_write_byte(asd, (LmSEQ_HASH_DEST_ADDR_MASK(link_num) + 2),
+				0xff);
+	asd_hwi_swb_write_word(asd, LmSEQ_HASH_SRC_ADDR_MASK(link_num),
+				0xffff);
+	asd_hwi_swb_write_byte(asd, (LmSEQ_HASH_SRC_ADDR_MASK(link_num) + 2),
+				0xff);
+	asd_hwi_swb_write_byte(asd, LmSEQ_RETRANS_MASK(link_num),
+				0x00);
+	asd_hwi_swb_write_byte(asd, LmSEQ_NUM_FILL_BYTES_MASK(link_num),
+				0x00);
+	asd_hwi_swb_write_word(asd, LmSEQ_NUM_FILL_BYTES_MASK(link_num),
+				0x0000);
+	asd_hwi_swb_write_word(asd, LmSEQ_TAG_PORT_TRANSFER_MASK(link_num),
+				0x0000);
+	asd_hwi_swb_write_dword(asd, LmSEQ_DATA_OFFSET_MASK(link_num),
+				0xffffffff);
+#endif
+
+}
+
+/* 
+ * Function:
+ *	asd_hwi_init_lseq_cio()
+ *
+ * Description:
+ *	Initialize LmSEQ CIO Registers.	 
+ */
+static void
+asd_hwi_init_lseq_cio(struct asd_softc *asd, u_int link_num)
+{
+	struct asd_phy	*phy;
+	uint32_t	 reqmbx_val;
+	u_int		 i;
+	
+	/* Enabled ARP2HALTC (ARP2 Halted from Halt Code Write). */
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_swb_write_dword(asd, LmARP2INTEN(link_num), 
+		EN_ARP2HALTC | EN_ARP2ILLOPC | EN_ARP2PERR | EN_ARP2CIOPERR);
+		//EN_ARP2HALTC);
+
+	asd_hwi_swb_write_dword(asd, LmARP2BREAKADR01(link_num), 0x0fff0fff);
+	asd_hwi_swb_write_dword(asd, LmARP2BREAKADR23(link_num), 0x0fff0fff);
+#ifdef ASD_DEBUG
+	//asd_hwi_set_lseq_breakpoint(asd, link_num, 0x14E4);
+//	asd_hwi_set_lseq_breakpoint(asd, link_num, EN_ARP2BREAK0, 0xBEC);
+//	asd_hwi_set_lseq_breakpoint(asd, link_num, EN_ARP2BREAK1, 0xD1C);
+//	asd_hwi_set_lseq_breakpoint(asd, link_num, EN_ARP2BREAK2, 0xD08);
+//	asd_hwi_set_lseq_breakpoint(asd, link_num, EN_ARP2BREAK3, 0xCF8);
+#endif
+#else
+	asd_hwi_swb_write_dword(asd, LmARP2INTEN(link_num), EN_ARP2HALTC);
+#endif
+ 
+	asd_hwi_swb_write_byte(asd, LmSCRATCHPAGE(link_num), 0x0);
+	
+	/* Initialize Mode 0,1, and 2 SCRATCHPAGE to 0. */
+	for (i = 0; i < 3; i++)
+		asd_hwi_swb_write_byte(asd, LmMnSCRATCHPAGE(link_num, i), 0x0);
+
+	/* Initialize Mode 5 SCRATCHPAGE to 0. */
+	asd_hwi_swb_write_byte(asd, LmMnSCRATCHPAGE(link_num, 5), 0x0);
+	
+	asd_hwi_swb_write_dword(asd, LmRSPMBX(link_num), 0x0);
+	/* 
+	 * Initialize Mode 0,1,2 and 5 Interrupt Enable and 
+	 * Interrupt registers. 
+	 */
+	asd_hwi_swb_write_dword(asd, LmMnINTEN(link_num, 0), LmM0INTEN_MASK);
+	asd_hwi_swb_write_dword(asd, LmMnINT(link_num, 0), LmM0INTMASK);
+	/* Mode 1 */
+	asd_hwi_swb_write_dword(asd, LmMnINTEN(link_num, 1), LmM1INTEN_MASK);
+	asd_hwi_swb_write_dword(asd, LmMnINT(link_num, 1), LmM1INTMASK);
+	/* Mode 2 */
+	asd_hwi_swb_write_dword(asd, LmMnINTEN(link_num, 2), LmM2INTEN_MASK);
+	asd_hwi_swb_write_dword(asd, LmMnINT(link_num, 2), LmM2INTMASK);
+	/* Mode 5 */
+	asd_hwi_swb_write_dword(asd, LmMnINTEN(link_num, 5), LmM5INTEN_MASK);
+	asd_hwi_swb_write_dword(asd, LmMnINT(link_num, 5), LmM5INTMASK);	
+			
+	/* Enabled HW Timer status. */
+	asd_hwi_swb_write_byte(asd, LmHWTSTATEN(link_num), LmHWTSTATEN_MASK);
+	
+	/* Enabled Primitive Status 0 and 1. */
+	asd_hwi_swb_write_dword(asd, LmPRMSTAT0EN(link_num), 
+				LmPRMSTAT0EN_MASK);
+	asd_hwi_swb_write_dword(asd, LmPRMSTAT1EN(link_num),
+				LmPRMSTAT1EN_MASK);
+				
+	/* Enabled Frame Error. */ 
+	asd_hwi_swb_write_dword(asd, LmFRMERREN(link_num), LmFRMERREN_MASK);
+	/* Initialize SATA Hold level to 0x28. */
+	asd_hwi_swb_write_byte(asd, LmMnHOLDLVL(link_num, 0), 
+			       LmMnHOLD_INIT_VALUE);
+	
+	/* Initialize Mode 0 Transfer Level to 512. */
+	asd_hwi_swb_write_byte(asd,  LmMnXFRLVL(link_num, 0), LmMnXFRLVL_512);
+	/* Initialize Mode 1 Transfer Level to 256. */
+	asd_hwi_swb_write_byte(asd, LmMnXFRLVL(link_num, 1), LmMnXFRLVL_256);
+	
+	/* Initialize Program Count to 0. */
+	asd_hwi_swb_write_word(asd, LmPRGMCNT(link_num), 
+			      (LSEQ_IDLE_LOOP_ENTRY / 4));
+
+	/* Enabled Blind SG Move. */
+	asd_hwi_swb_write_dword(asd, LmMODECTL(link_num), LmBLIND48);
+	
+	reqmbx_val = asd_hwi_swb_read_dword(asd, LmREQMBX(link_num));
+	
+	/* Clear Primitive Status 0 and 1. */
+	asd_hwi_swb_write_dword(asd, LmPRMSTAT0(link_num), LmPRMSTAT0CLR_MASK);
+	asd_hwi_swb_write_dword(asd, LmPRMSTAT1(link_num), LmPRMSTAT1CLR_MASK);	
+	
+	/* Clear HW Timer status. */
+	asd_hwi_swb_write_byte(asd, LmHWTSTAT(link_num), LmHWTSTAT_MASK);
+	
+	/* Clear DMA Errors for Mode 0 and 1. */ 
+	asd_hwi_swb_write_byte(asd, LmMnDMAERRS(link_num, 0), 0xFF);
+	asd_hwi_swb_write_byte(asd, LmMnDMAERRS(link_num, 1), 0xFF);
+	
+	/* Clear SG DMA Errors for Mode 0 and 1. */ 
+	asd_hwi_swb_write_byte(asd, LmMnSGDMAERRS(link_num, 0), 0xFF);
+	asd_hwi_swb_write_byte(asd, LmMnSGDMAERRS(link_num, 1), 0xFF);
+	
+	/* Clear Mode 0 Buffer Parity Error. */		       
+	asd_hwi_swb_write_byte(asd, LmMnBUFSTAT(link_num, 0), LmMnBUFPERR);
+	
+	/* Clear Mode 0 Frame Error register. */
+	asd_hwi_swb_write_dword(asd, LmMnFRMERR(link_num, 0), LmMnFRMERR_INIT);
+			       	
+	/* Reset LSEQ Interrupt Controller. */
+	asd_hwi_swb_write_byte(asd, LmARP2INTCTL(link_num), RSTINTCTL);
+	
+	/*
+	 * Chip Rev. A1 can only payload up to 512 bytes in the DATA
+         * frame. Chip Rev. B0 can have up to 1024 bytes.
+	 * The value is in dwords.
+	 */
+	if (asd->hw_profile.rev_id != AIC9410_DEV_REV_A1) {
+		/* Set the Transmit Size to 1024 bytes, 0 = 256 Dwords. */
+		asd_hwi_swb_write_byte(asd, LmMnXMTSIZE(link_num, 1), 0x0);
+	} else {
+#ifdef SEQUENCER_UPDATE
+		asd_hwi_swb_write_byte(asd, LmMnXMTSIZE(link_num, 1), 0x40);
+#else
+		/* Set the Transmit Size to 512 bytes. */
+		asd_hwi_swb_write_byte(asd, LmMnXMTSIZE(link_num, 1), 0x80);
+#endif
+	}
+		
+	/* Enable SATA Port Multiplier. */
+	asd_hwi_swb_write_byte(asd, LmMnSATAFS(link_num, 1), 0x80);
+
+	/* Set the Phy SAS for the LmSEQ WWN. */
+	phy = asd->phy_list[link_num];
+	for (i = 0; i < SAS_ADDR_LEN; i++) 
+		asd_hwi_swb_write_byte(asd, (LmWWN(link_num) + i),
+				       phy->sas_addr[i]);
+
+//#ifdef SEQUENCER_UPDATE
+//	asd_hwi_swb_write_word(asd, LmBITL_TIMER(link_num), 1);
+//#else
+	/* Set the Bus Inactivity Time Limit Timer to 900 ms. */
+	asd_hwi_swb_write_word(asd, LmBITL_TIMER(link_num), 9);
+//#endif
+
+	/* Initialize Interrupt Vector[0-10] address in Mode 3. */
+	asd_hwi_swb_write_word(asd, LmM3INTVEC0(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC0)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC1(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC1)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC2(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC2)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC3(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC3)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC4(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC4)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC5(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC5)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC6(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC6)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC7(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC7)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC8(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC8)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC9(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC9)) / 4));
+	asd_hwi_swb_write_word(asd, LmM3INTVEC10(link_num), 
+			      ((ASD_SET_INT_VEC(asd, LSEQ_INT_VEC10)) / 4));
+
+	/* 
+	 * Program the Link LED control, applicable only for 
+	 * Chip Rev. B or later.
+	 */
+	if (asd->hw_profile.rev_id != AIC9410_DEV_REV_A1) {
+		asd_hwi_swb_write_dword(asd, LmCONTROL(link_num),
+					(LEDTIMER | LEDMODE_TXRX | 
+					 LEDTIMERS_100ms));
+	}
+
+	/* Set the Align Rate for SAS and STP mode. */
+	asd_hwi_swb_write_byte(asd, LmM1SASALIGN(link_num), SAS_ALIGN_DEFAULT);
+	asd_hwi_swb_write_byte(asd, LmM1STPALIGN(link_num), STP_ALIGN_DEFAULT);
+}
+
+/* 
+ * Function:
+ *	asd_hwi_start_cseq()
+ *
+ * Description:
+ *	Start the Central Sequencer.	 
+ */
+int
+asd_hwi_start_cseq(struct asd_softc *asd)
+{
+	/* Reset the ARP2 instruction to location zero. */
+	asd_hwi_swb_write_word(asd, (uint32_t) CPRGMCNT, 
+			      (CSEQ_IDLE_LOOP_ENTRY / 4));
+
+	/* Unpause the CSEQ  */
+	return (asd_hwi_unpause_cseq(asd));
+}
+
+/* 
+ * Function:
+ *	asd_hwi_start_lseq()
+ *
+ * Description:
+ *	Start the Link Sequencer (LmSEQ).	 
+ */
+int
+asd_hwi_start_lseq(struct asd_softc  *asd, uint8_t  link_num)
+{
+	/* Reset the ARP2 instruction to location zero. */
+	asd_hwi_swb_write_word(asd, (uint32_t) LmPRGMCNT(link_num), 
+			      (LSEQ_IDLE_LOOP_ENTRY / 4));
+
+	/* Unpause the LmSEQ  */
+	return (asd_hwi_unpause_lseq(asd, (1U << link_num)));
+}
+
+/* 
+ * Function:
+ *	asd_swap_with_next_hscb()
+ *
+ * Description:
+ *	Swap the hscb pointed to by scb with the next
+ *	hscb the central sequencer is expecting to process.
+ */
+static inline void
+asd_swap_with_next_hscb(struct asd_softc *asd, struct scb *scb)
+{
+	union hardware_scb 	*q_hscb;
+	struct map_node 	*q_hscb_map;
+	uint64_t 		 saved_hscb_busaddr;
+
+	/*
+	 * Our queuing method is a bit tricky.  The card
+	 * knows in advance which HSCB (by address) to download,
+	 * and we can't disappoint it.  To achieve this, the next
+	 * HSCB to download is saved off in asd->next_queued_hscb.
+	 * When we are called to queue "an arbitrary scb",
+	 * we copy the contents of the incoming HSCB to the one
+	 * the sequencer knows about, swap HSCB pointers and
+	 * finally assign the SCB to the tag indexed location
+	 * in the scb_array.  This makes sure that we can still
+	 * locate the correct SCB by SCB_TAG.
+	 */
+	q_hscb = asd->next_queued_hscb;
+	q_hscb_map = asd->next_queued_hscb_map;
+	memcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));
+	q_hscb->header.next_hscb_busaddr = scb->hscb_busaddr;
+
+	/* Now swap HSCB pointers. */
+	asd->next_queued_hscb = scb->hscb;
+	asd->next_queued_hscb_map = scb->hscb_map;
+	scb->hscb = q_hscb;
+	scb->hscb_map = q_hscb_map;
+	saved_hscb_busaddr = asd->next_queued_hscb_busaddr;
+	asd->next_queued_hscb_busaddr = scb->hscb_busaddr;
+	scb->hscb_busaddr = saved_hscb_busaddr;
+
+	/* Now define the mapping from tag to SCB in the scbindex */
+	asd->scbindex[SCB_GET_INDEX(scb)] = scb;
+}
+
+#ifdef SEQUENCER_UPDATE
+int
+asd_hwi_cseq_init_step(struct asd_step_data *step_datap)
+{
+	uint32_t		arp2ctl;
+
+	step_datap->lseq_trace = 0;
+
+	asd_hwi_pause_cseq(step_datap->asd);
+
+	arp2ctl = asd_hwi_swb_read_dword(step_datap->asd, CARP2CTL);
+
+	if (arp2ctl & STEP) {
+		printk("CSEQ already stepping\n");
+		return 0;
+	}
+
+	asd_hwi_swb_write_dword(step_datap->asd, CARP2CTL, arp2ctl | STEP);
+
+	asd_hwi_unpause_cseq(step_datap->asd);
+
+	return 1;
+}
+
+static void
+asd_hwi_cseq_resume(struct asd_step_data *step_datap)
+{
+	uint32_t		arp2ctl;
+
+	step_datap->stepping = 0;
+
+	arp2ctl = asd_hwi_swb_read_dword(step_datap->asd, CARP2CTL);
+
+	asd_hwi_swb_write_dword(step_datap->asd, CARP2CTL, (arp2ctl & ~STEP));
+
+	asd_hwi_unpause_cseq(step_datap->asd);
+}
+
+int
+asd_hwi_lseq_init_step(struct asd_step_data *step_datap,
+	unsigned link_num)
+{
+	uint32_t		arp2ctl;
+
+	step_datap->lseq_trace = 1;
+	step_datap->link_num = link_num;
+
+	asd_hwi_pause_lseq(step_datap->asd, 1<<link_num);
+
+	arp2ctl = asd_hwi_swb_read_dword(step_datap->asd, LmARP2CTL(link_num));
+
+	if (arp2ctl & STEP) {
+		printk("LSEQ(%d) already stepping\n", link_num);
+		return 0;
+	}
+
+	asd_hwi_swb_write_dword(step_datap->asd, LmARP2CTL(link_num),
+		arp2ctl | STEP);
+
+	asd_hwi_unpause_lseq(step_datap->asd, 1<<link_num);
+
+	return 1;
+}
+
+static void
+asd_hwi_lseq_resume(struct asd_step_data *step_datap)
+{
+	uint32_t		arp2ctl;
+
+	step_datap->stepping = 0;
+
+	arp2ctl = asd_hwi_swb_read_dword(step_datap->asd,
+		LmARP2CTL(step_datap->link_num));
+
+	asd_hwi_swb_write_dword(step_datap->asd,
+		LmARP2CTL(step_datap->link_num), (arp2ctl & ~STEP));
+
+	asd_hwi_unpause_lseq(step_datap->asd, 1 << step_datap->link_num);
+}
+
+void
+asd_hwi_ss_debug_timeout(
+u_long		val
+)
+{
+	unsigned		addr;
+	struct asd_step_data	*step_datap;
+
+	step_datap = (struct asd_step_data *)val;
+
+	if (step_datap->instruction_count == 300)
+	{
+		asd_print("-----------------------\n");
+
+		if (step_datap->lseq_trace == 0)
+		{
+			asd_hwi_cseq_resume(step_datap);
+		}
+		else
+		{
+			asd_hwi_lseq_resume(step_datap);
+		}
+
+		return;
+	}
+
+	if (step_datap->lseq_trace == 0)
+	{
+		addr = asd_hwi_swb_read_word(step_datap->asd, CLASTADDR) * 4;
+
+		asd_print("   CSEQ:%20s[0x%x]:0x%04x\n",
+			"ARP2_LASTADDR", LASTADDR, addr);
+
+		asd_hwi_unpause_cseq(step_datap->asd);
+	}
+	else
+	{
+		addr = asd_hwi_swb_read_word(step_datap->asd,
+			LmLASTADDR(step_datap->link_num)) * 4;
+
+		asd_print("   LSEQ:%20s[0x%x]:0x%04x\n", "ARP2_LASTADDR",
+			LASTADDR, addr);
+
+		asd_hwi_unpause_lseq(step_datap->asd, 1<<step_datap->link_num);
+	}
+
+	step_datap->instruction_count++;
+	step_datap->single_step_timer.expires = jiffies + 1;
+	step_datap->single_step_timer.data = (u_long) step_datap;
+	step_datap->single_step_timer.function = asd_hwi_ss_debug_timeout;
+
+	add_timer(&step_datap->single_step_timer);
+}
+
+struct asd_step_data *
+asd_hwi_alloc_step(struct asd_softc *asd)
+{
+	struct asd_step_data	*step_datap;
+
+	step_datap = (struct asd_step_data *)asd_alloc_mem(
+		sizeof(struct asd_step_data), GFP_ATOMIC);
+
+	step_datap->asd = asd;
+	step_datap->stepping = 1;
+
+	init_timer(&step_datap->single_step_timer);
+	step_datap->single_step_timer.expires = jiffies + 1;
+	step_datap->single_step_timer.data = (u_long) step_datap;
+	step_datap->single_step_timer.function = asd_hwi_ss_debug_timeout;
+	step_datap->instruction_count = 0;
+
+	return step_datap;
+}
+
+void
+asd_hwi_free_step(struct asd_step_data	*step_datap)
+{
+	asd_free_mem(step_datap);
+}
+
+void
+asd_hwi_start_step_timer(struct asd_step_data *step_datap)
+{
+
+	asd_print("starting single step\n");
+
+	step_datap->stepping = 1;
+
+	add_timer(&step_datap->single_step_timer);
+}
+#endif
+
+/* 
+ * Function:
+ *	asd_hwi_post_scb()
+ *
+ * Description:
+ *	Post the SCB to the central sequencer.	 
+ */
+void
+asd_hwi_post_scb(struct asd_softc *asd, struct scb *scb)
+{
+	ASD_LOCK_ASSERT(asd);
+
+	asd_swap_with_next_hscb(asd, scb);
+
+	/*
+	 * Keep a history of SCBs we've downloaded in the qinfifo.
+	 */
+	asd->qinfifo[ASD_QIN_WRAP(asd)] = SCB_GET_INDEX(scb);
+	asd->qinfifonext++;
+
+	if (scb->hscb->header.opcode != SCB_EMPTY_BUFFER) {
+		list_add_tail(&scb->hwi_links, &asd->pending_scbs);
+		scb->flags |= SCB_PENDING;
+	}
+
+
+	/* Tell the adapter about the newly queued SCB */
+	asd_write_dword(asd, SCBPRO, asd->qinfifonext);				
+}
+
+/* 
+ * Function:
+ *	asd_hwi_free_edb()
+ *
+ * Description:
+ *	Release an edb for eventual requeuing to the central sequencer.
+ */
+void
+asd_hwi_free_edb(struct asd_softc *asd, struct scb *scb, int edb_index)
+{
+	struct asd_empty_hscb 	*escb;
+	struct empty_buf_elem	*ebe;
+	u_int 		 	 i;
+
+	escb = &scb->hscb->empty_scb;
+	ebe = &escb->buf_elem[edb_index];
+	if (ELEM_BUFFER_VALID_FIELD(ebe) == ELEM_BUFFER_VALID) {
+		ebe->elem_valid_ds = ELEM_BUFFER_INVALID;
+		escb->num_valid_elems--;
+		if (escb->num_valid_elems != 0)
+			return;
+
+		/*
+		 * Now that all buffers have been used,
+		 * we can recycle the empty scb by reinitializing
+		 * it and requeuing it to the sequencer.
+		 */
+		escb->num_valid_elems = ASD_MAX_EDBS_PER_SCB;
+		ebe = &escb->buf_elem[0];
+		for (i = 0; i < ASD_MAX_EDBS_PER_SCB; i++, ebe++)
+			ebe->elem_valid_ds = ELEM_BUFFER_VALID;
+
+		asd_log(ASD_DBG_RUNTIME, 
+			"Requeuing escb %d.\n", SCB_GET_INDEX(scb));
+		
+		asd_hwi_post_scb(asd, scb);
+	}
+}
+
+#ifndef SEQUENCER_UPDATE
+#define asd_ssp_smp_ddb		asd_ddb
+#define asd_sata_stp_ddb	asd_ddb
+#endif
+
+void
+asd_hwi_init_ddb_sites(struct asd_softc *asd)
+{
+	unsigned	i;
+	unsigned	ddb_site;
+
+	for (ddb_site = 0 ; ddb_site < asd->hw_profile.max_ddbs ; ddb_site++)
+	{
+		/* Setup the hardware DDB 0 location. */
+		asd_hwi_set_ddbptr(asd, ddb_site);
+
+		for (i = 0; i < sizeof(struct asd_ssp_smp_ddb); i += 4)
+			asd_hwi_set_ddbsite_dword(asd, i, 0x0);
+	}
+}
+
+/*
+ * Function:
+ *	asd_hwi_init_internal_ddb()
+ * 
+ * Description:
+ *	Initialize DDB site 0 and 1 which are used internally by the sequencer.
+ */
+void
+asd_hwi_init_internal_ddb(struct asd_softc *asd)
+{
+	int		i;
+#ifdef SEQUENCER_UPDATE
+	unsigned	num_phys;
+#endif
+
+	/* Setup the hardware DDB 0 location. */
+	asd_hwi_set_ddbptr(asd, 0);
+
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, q_free_ddb_head), 0xffff);
+
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, q_free_ddb_tail), 0xffff);
+
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, q_free_ddb_cnt), 0x0000);
+
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, q_used_ddb_head), 0xffff);
+
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, q_used_ddb_tail), 0xffff);
+#else
+	for (i = 0; i < 10; i = i+2) {
+		asd_hwi_set_ddbsite_word(asd, 
+					(offsetof(struct asd_int_ddb, res1)+i),
+					 0x0);
+	}
+#endif
+
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, shared_mem_lock), 0x0000);
+
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, smp_conn_tag), 0x0000);
+
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, est_nexus_buf_cnt),
+		 	0x0000);
+
+
+	for (i = 0, num_phys = 0 ; i < 8; i++) {
+		if (((1<<i) & asd->hw_profile.enabled_phys) != 0) {
+			num_phys++;
+		}
+
+	}
+
+	asd_hwi_set_ddbsite_word(asd,
+		 offsetof(struct asd_int_ddb, est_nexus_buf_thresh),
+		 num_phys * 2);
+
+	for (i = 0; i < 24; i = i+2) {
+		asd_hwi_set_ddbsite_word(asd, 
+					(offsetof(struct asd_int_ddb, res2)+i),
+					 0x0);
+	}
+#else
+	for (i = 0; i < 34; i = i+2) {
+		asd_hwi_set_ddbsite_word(asd, 
+					(offsetof(struct asd_int_ddb, res2)+i),
+					 0x0);
+	}
+#endif
+
+	asd_hwi_set_ddbsite_byte(asd,
+				 offsetof(struct asd_int_ddb, conn_not_active),
+				 0xFF);
+	asd_hwi_set_ddbsite_byte(asd,
+				 offsetof(struct asd_int_ddb, phy_is_up),
+				 0x0);
+	
+	for (i = 0; i < 8; i = i+4) {
+		asd_hwi_set_ddbsite_dword(asd,
+					 (offsetof(struct asd_int_ddb, 
+						   port_map_by_ports) + i),
+					  0x0);
+		asd_hwi_set_ddbsite_dword(asd,
+					 (offsetof(struct asd_int_ddb, 
+						   port_map_by_links) + i),
+					  0x0);
+	}
+
+	/* Setup the hardware DDB 1 location. */
+	asd_hwi_set_ddbptr(asd, 1);
+
+	for (i = 0; i < sizeof(struct asd_ssp_smp_ddb); i += 4)
+		asd_hwi_set_ddbsite_dword(asd, i, 0x0);
+}
+
+void
+#ifdef SEQUENCER_UPDATE
+asd_hwi_build_ssp_smp_ddb_site(struct asd_softc *asd, struct asd_target *target)
+#else
+asd_hwi_build_ddb_site(struct asd_softc *asd, struct asd_target *target)
+#endif
+{
+	u_int	i;
+
+	/* Setup the hardware DDB location. */	
+	asd_hwi_set_ddbptr(asd, target->ddb_profile.conn_handle);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, addr_fr_port),
+			 (INITIATOR_PORT_MODE | OPEN_ADDR_FRAME));
+	
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, conn_rate), 
+			 target->ddb_profile.conn_rate);
+
+	/* Could this field be set to 0xFFFF after first time initialization. */
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, init_conn_tag), 0xFFFF);
+
+	for (i = 0; i < SAS_ADDR_LEN; i++) {
+		asd_hwi_set_ddbsite_byte(asd, offsetof(struct asd_ssp_smp_ddb,
+						       dest_sas_addr[i]),
+					 target->ddb_profile.sas_addr[i]);
+	}
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, send_q_head), 0xFFFF);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, sqsuspended), 0x0);
+	/* 
+	 * This needs to be changed once we support Port Multipier as
+	 * Port Multipier has seperate DDB.
+	 */
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, ddb_type), TARGET_PORT_DDB);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, res1), 0x0);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, awt_default), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, comp_features), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, pathway_blk_cnt), 0x0);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, arb_wait_time), 0x0);
+
+	asd_hwi_set_ddbsite_dword(asd,
+		offsetof(struct asd_ssp_smp_ddb, more_comp_features), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, conn_mask),
+			 target->src_port->conn_mask);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, open_affl),
+				 target->ddb_profile.open_affl);
+	
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, res2), 0x0);
+#else
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, res2), 0x0);
+#endif
+	
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, stp_close), CLOSE_STP_NO_TX);
+#endif
+	
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, exec_q_tail), 0xFFFF);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, send_q_tail), 0xFFFF);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, sister_ddb),
+			 target->ddb_profile.sister_ddb);
+
+#ifdef SEQUENCER_UPDATE
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, max_concurrent_connections),
+			0x00);
+#ifdef CONCURRENT_SUPPORT
+	if(target->ddb_profile.open_affl & CONCURRENT_CONNECTION_SUPPORT)
+	{	
+		uint8_t linkwidth;
+		uint8_t num_conn;
+		linkwidth = target->src_port->conn_mask;
+		num_conn = 0;
+		while(linkwidth != 0)
+		{
+			if(linkwidth & 0x80) num_conn++;
+			linkwidth <<=1;
+		}
+		if(num_conn > 4) num_conn = 4;
+		asd_hwi_set_ddbsite_byte(asd,
+			offsetof(struct asd_ssp_smp_ddb, max_concurrent_connections),
+			num_conn);
+	}
+#endif
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, concurrent_connections), 0x00);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, tunable_number_contexts),
+			0x00);
+#else
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, ata_cmd_scb_ptr), 0xFFFF);
+
+	asd_hwi_set_ddbsite_dword(asd,
+		offsetof(struct asd_ssp_smp_ddb, sata_tag_mask), 0x0);
+#endif
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, active_task_cnt), 0x0);
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_set_ddbsite_dword(asd,
+		offsetof(struct asd_ssp_smp_ddb, sata_sactive), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, no_of_sata_tags), 0x0);
+	/*
+	 * Need to update this field based on the info from Host register FIS
+	 * after OOB.
+	 */     
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, sata_stat), 0x50);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, sata_ending_stat), 0x0);
+#endif
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, itnl_reason), 0x0);
+
+#ifndef SEQUENCER_UPDATE
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_ssp_smp_ddb, ncq_data_scb_ptr), 0xFFFF);
+#endif
+	/*
+	 * We ensure that we don't program zero value as ITNL timeout value.
+	 * As zero value is treated by the firmware as infinite value.
+       	 */
+	asd_hwi_set_ddbsite_word(asd, offsetof(struct asd_ssp_smp_ddb,
+		itnl_const),
+			((target->ddb_profile.itnl_const != 0) ?
+			  target->ddb_profile.itnl_const : 1));
+
+	asd_hwi_set_ddbsite_dword(asd,
+		offsetof(struct asd_ssp_smp_ddb, itnl_timestamp), 0x0);
+}
+
+#ifdef SEQUENCER_UPDATE
+void
+asd_hwi_build_sata_stp_ddb_site(struct asd_softc *asd,
+	struct asd_target *target)
+{
+	u_int	i;
+
+	/* Setup the hardware DDB location. */	
+	asd_hwi_set_ddbptr(asd, target->ddb_profile.conn_handle);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, addr_fr_port),
+			 (INITIATOR_PORT_MODE | OPEN_ADDR_FRAME));
+	
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, conn_rate), 
+			 target->ddb_profile.conn_rate);
+
+	/* Could this field be set to 0xFFFF after first time initialization. */
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, init_conn_tag), 0xFFFF);
+
+	for (i = 0; i < SAS_ADDR_LEN; i++) {
+		asd_hwi_set_ddbsite_byte(asd, offsetof(struct asd_sata_stp_ddb,
+						       dest_sas_addr[i]),
+					 target->ddb_profile.sas_addr[i]);
+	}
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, send_q_head), 0xFFFF);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, sqsuspended), 0x0);
+	/* 
+	 * This needs to be changed once we support Port Multipier as
+	 * Port Multipier has seperate DDB.
+	 */
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, ddb_type), TARGET_PORT_DDB);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, res1), 0x0);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, awt_default), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, comp_features), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, pathway_blk_cnt), 0x0);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, arb_wait_time), 0x0);
+
+	asd_hwi_set_ddbsite_dword(asd,
+		offsetof(struct asd_sata_stp_ddb, more_comp_features), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, conn_mask),
+			 target->src_port->conn_mask);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, open_affl),
+			 target->ddb_profile.open_affl);
+	
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, res2), 0x0);
+	
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, stp_close), CLOSE_STP_NO_TX);
+	
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, exec_q_tail), 0xFFFF);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, send_q_tail), 0xFFFF);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, sister_ddb),
+			 target->ddb_profile.sister_ddb);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, ata_cmd_scb_ptr), 0xFFFF);
+
+	asd_hwi_set_ddbsite_dword(asd,
+		offsetof(struct asd_sata_stp_ddb, sata_tag_mask), 0x0);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, active_task_cnt), 0x0);
+
+	asd_hwi_set_ddbsite_dword(asd,
+		offsetof(struct asd_sata_stp_ddb, sata_sactive), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, no_of_sata_tags), 0x0);
+
+	/*
+	 * Need to update this field based on the info from Host register FIS
+	 * after OOB.
+	 */     
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, sata_stat), 0x50);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, sata_ending_stat), 0x0);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, itnl_reason), 0x0);
+
+	asd_hwi_set_ddbsite_word(asd,
+		offsetof(struct asd_sata_stp_ddb, ncq_data_scb_ptr), 0xFFFF);
+	/*
+	 * We ensure that we don't program zero value as ITNL timeout value.
+	 * As zero value is treated by the firmware as infinite value.
+       	 */
+	asd_hwi_set_ddbsite_word(asd, offsetof(struct asd_sata_stp_ddb,
+		itnl_const),
+			((target->ddb_profile.itnl_const != 0) ?
+			  target->ddb_profile.itnl_const : 1));
+
+	asd_hwi_set_ddbsite_dword(asd,
+		offsetof(struct asd_sata_stp_ddb, itnl_timestamp), 0x0);
+}
+
+/*
+ * Function:
+ *	asd_hwi_build_ddb_site()
+ *
+ * Description:
+ * 	Initialiaze and setup the hardware DDB site based on target
+ *	DDB profile.
+ */	 	  
+void
+asd_hwi_build_ddb_site(struct asd_softc *asd, struct asd_target *target)
+{
+	if ((target->transport_type == ASD_TRANSPORT_SSP) ||
+		(target->transport_type == ASD_TRANSPORT_SMP)) {
+
+		asd_hwi_build_ssp_smp_ddb_site(asd, target);
+
+		return;
+	}
+
+	asd_hwi_build_sata_stp_ddb_site(asd, target);
+}
+#endif
+
+
+void
+asd_hwi_update_sata(struct asd_softc *asd, struct asd_target *target)
+{
+	/* Setup the hardware DDB location. */	
+	asd_hwi_set_ddbptr(asd, target->ddb_profile.conn_handle);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, sata_stat),
+			target->ddb_profile.sata_status);
+}
+
+void
+#ifdef SEQUENCER_UPDATE
+asd_hwi_update_ssp_smp_conn_mask(struct asd_softc *asd,
+	struct asd_target *target)
+#else
+asd_hwi_update_conn_mask(struct asd_softc *asd, struct asd_target *target)
+#endif
+{
+	/* Setup the hardware DDB location. */	
+	asd_hwi_set_ddbptr(asd, target->ddb_profile.conn_handle);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_ssp_smp_ddb, conn_mask),
+			 target->src_port->conn_mask);
+}
+
+#ifdef SEQUENCER_UPDATE
+void
+asd_hwi_update_sata_stp_conn_mask(struct asd_softc *asd,
+	struct asd_target *target)
+{
+	/* Setup the hardware DDB location. */	
+	asd_hwi_set_ddbptr(asd, target->ddb_profile.conn_handle);
+
+	asd_hwi_set_ddbsite_byte(asd,
+		offsetof(struct asd_sata_stp_ddb, conn_mask),
+			 target->src_port->conn_mask);
+}
+#endif
+
+
+/********************* REGISTERS DUMP STATE routines **************************/
+
+#ifdef ASD_DEBUG
+
+void
+asd_hwi_dump_seq_state(struct asd_softc *asd, uint8_t lseq_mask)
+{
+	uint8_t	lseqs_to_dump;
+	u_int	lseq_id;
+
+	/* Dump out CSEQ Registers state. */
+	asd_hwi_dump_cseq_state(asd);
+
+	if (lseq_mask == 0x0)
+		return;
+
+	lseq_id = 0;
+	lseqs_to_dump = lseq_mask;
+
+	while (lseqs_to_dump != 0) { 
+		for ( ; lseq_id < asd->hw_profile.max_phys; lseq_id++) {
+			if (lseqs_to_dump & (1 << lseq_id)) {
+				lseqs_to_dump &= ~(1 << lseq_id);
+				break;
+			} 
+		}
+		/* Dump out specific LSEQ Registers state. */
+		asd_hwi_dump_lseq_state(asd, lseq_id);
+	}
+#if KDB_ENABLE
+	KDB_ENTER();
+#endif
+}
+	
+static void
+asd_hwi_dump_cseq_state(struct asd_softc *asd)
+{
+	unsigned	i;
+
+	asd_print("\nCSEQ DUMP STATE\n");
+	asd_print("===============\n");
+
+	asd_print("\nIOP REGISTERS\n");
+	asd_print("*************\n");
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "ARP2CTL", ARP2CTL,
+		  asd_hwi_swb_read_dword(asd, CARP2CTL));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "ARP2INT", ARP2INT,
+		  asd_hwi_swb_read_dword(asd, CARP2INT));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "ARP2INTEN", ARP2INTEN,
+		  asd_hwi_swb_read_dword(asd, CARP2INTEN));
+
+	asd_print("\nSCRATCH MEMORY\n");
+	asd_print("**************\n");
+
+	asd_print("\nPage 2 - Mode 8\n");
+	asd_print("---------------\n");
+
+	asd_print("   %20s[0x%x]:0x%08x", "Q_NEW_POINTER", 0x240,
+		  asd_hwi_swb_read_dword(asd, CSEQ_Q_NEW_POINTER+4));
+	asd_print("%08x\n", asd_hwi_swb_read_dword(asd, CSEQ_Q_NEW_POINTER));
+
+	asd_print("   %20s[0x%x]:0x%08x", "Q_DONE_BASE", 0x248,
+		  asd_hwi_swb_read_dword(asd, CSEQ_Q_DONE_BASE+4));
+	asd_print("%08x\n", asd_hwi_swb_read_dword(asd, CSEQ_Q_DONE_BASE));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "Q_DONE_POINTER", 0x250,
+		  asd_hwi_swb_read_dword(asd, CSEQ_Q_DONE_POINTER));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "Q_DONE_PASS", 0x254,
+		  asd_hwi_swb_read_dword(asd, CSEQ_Q_DONE_PASS));
+
+	asd_print("\nMode Independent Page 4\n");
+	asd_print("-----------------------\n");
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_EXE_HEAD", 0x280,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_EXE_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_EXE_TAIL", 0x282,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_EXE_TAIL));
+
+#ifndef SEQUENCER_UPDATE
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_DONE_HEAD", 0x284,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_DONE_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_DONE_TAIL", 0x286,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_DONE_TAIL));
+#endif
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_SEND_HEAD", 0x288,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_SEND_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_SEND_TAIL", 0x28A,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_SEND_TAIL));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_DMA2CHIM_HEAD", 0x28C,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_DMA2CHIM_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_DMA2CHIM_TAIL", 0x28E,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_DMA2CHIM_TAIL));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_COPY_HEAD", 0x290,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_COPY_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_COPY_TAIL", 0x292,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_COPY_TAIL));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "LINK_CTL_Q_MAP", 0x29C,
+		  asd_hwi_swb_read_byte(asd, CSEQ_LINK_CTL_Q_MAP));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "SCRATCH_FLAGS", 0x29F,
+		  asd_hwi_swb_read_byte(asd, CSEQ_SCRATCH_FLAGS));
+
+	asd_print("\nMode Independent Page 5\n");
+	asd_print("-----------------------\n");
+
+#ifndef SEQUENCER_UPDATE
+	asd_print("   %20s[0x%x]:0x%02x\n", "FREE_SCB_MASK", 0x2B5,
+		  asd_hwi_swb_read_byte(asd, CSEQ_FREE_SCB_MASK));
+
+	asd_print("   %24s[0x%x]:0x%04x\n", "BUILTIN_FREE_SCB_HEAD", 0x2D6,
+		  asd_hwi_swb_read_word(asd, CSEQ_BUILTIN_FREE_SCB_HEAD));
+
+	asd_print("   %24s[0x%x]:0x%04x\n", "BUILTIN_FREE_SCB_TAIL", 0x2B8,
+		  asd_hwi_swb_read_word(asd, CSEQ_BUILTIN_FREE_SCB_TAIL));
+
+#else
+
+	asd_print("\nMode Independent Page 6\n");
+	asd_print("-----------------------\n");
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "FREE_SCB_MASK", 0x2D5,
+		  asd_hwi_swb_read_byte(asd, CSEQ_FREE_SCB_MASK));
+
+	asd_print("   %24s[0x%x]:0x%04x\n", "BUILTIN_FREE_SCB_HEAD", 0x2D6,
+		  asd_hwi_swb_read_word(asd, CSEQ_BUILTIN_FREE_SCB_HEAD));
+
+	asd_print("   %24s[0x%x]:0x%04x\n", "BUILTIN_FREE_SCB_TAIL", 0x2D8,
+		  asd_hwi_swb_read_word(asd, CSEQ_BUILTIN_FREE_SCB_TAIL));
+#ifdef EXTENDED_SCB
+	asd_print("   %24s[0x%x]:0x%04x\n", "EXTENDED_FREE_SCB_HEAD", 0x2DA,
+		  asd_hwi_swb_read_word(asd, CSEQ_EXTNDED_FREE_SCB_HEAD));
+
+	asd_print("   %24s[0x%x]:0x%04x\n", "EXTENDED_FREE_SCB_TAIL", 0x2DC,
+		  asd_hwi_swb_read_word(asd, CSEQ_EXTNDED_FREE_SCB_TAIL));
+#endif
+#endif
+
+	asd_print("\nMode Independent Page 7\n");
+	asd_print("-----------------------\n");
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_EMPTY_HEAD", 0x2F0,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_EMPTY_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "Q_EMPTY_TAIL", 0x2F2,
+		  asd_hwi_swb_read_word(asd, CSEQ_Q_EMPTY_TAIL));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "NEED_EMPTY_SCB", 0x2F4,
+		  asd_hwi_swb_read_word(asd, CSEQ_NEED_EMPTY_SCB));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "EMPTY_REQ_HEAD", 0x2F6,
+		  asd_hwi_swb_read_byte(asd, CSEQ_EMPTY_REQ_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "EMPTY_REQ_TAIL", 0x2F7,
+		  asd_hwi_swb_read_byte(asd, CSEQ_EMPTY_REQ_TAIL));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "EMPTY_SCB_OFFSET", 0x2F8,
+		  asd_hwi_swb_read_byte(asd, CSEQ_EMPTY_SCB_OFFSET));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "PRIMITIVE_DATA", 0x2FA,
+		  asd_hwi_swb_read_word(asd, CSEQ_PRIMITIVE_DATA));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "TIMEOUT_CONST", 0x2FC,
+		  asd_hwi_swb_read_dword(asd, CSEQ_TIMEOUT_CONSTANT));
+
+	asd_print("\nPage 0 - Mode 8\n");
+	asd_print("---------------\n");
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "RET_ADDR", 0x200,
+		  asd_hwi_swb_read_word(asd, CSEQ_RET_ADDR));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "RET_SCBPTR", 0x202,
+		  asd_hwi_swb_read_word(asd, CSEQ_RET_SCBPTR));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "SAVE_SCBPTR", 0x204,
+		  asd_hwi_swb_read_word(asd, CSEQ_SAVE_SCBPTR));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "EMPTY_TC", 0x206,
+		  asd_hwi_swb_read_word(asd, CSEQ_EMPTY_TRANS_CTX));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "RESP_LEN", 0x208,
+		  asd_hwi_swb_read_word(asd, CSEQ_RESP_LEN));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "TMF_SCBPTR", 0x20A,
+		  asd_hwi_swb_read_word(asd, CSEQ_TMF_SCBPTR));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "GLOBAL_PREV_SCB", 0x20C,
+		  asd_hwi_swb_read_word(asd, CSEQ_GLOBAL_PREV_SCB));
+
+#ifdef SEQUENCER_UPDATE
+	asd_print("   %20s[0x%x]:0x%04x\n", "CLEAR_LU_HEAD", 0x0210,
+		  asd_hwi_swb_read_word(asd, CSEQ_CLEAR_LU_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "TMF_OPCODE", 0x0212,
+		  asd_hwi_swb_read_byte(asd, CSEQ_TMF_OPCODE));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "SCRATCH_FLAGS", 0x0213,
+		  asd_hwi_swb_read_word(asd, CSEQ_SCRATCH_FLAGS));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "HSS_SITE", 0x021A,
+		  asd_hwi_swb_read_word(asd, CSEQ_HSS_SITE));
+#else
+	asd_print("   %20s[0x%x]:0x%04x\n", "GLOBAL_HEAD", 0x20E,
+		  asd_hwi_swb_read_word(asd, CSEQ_GLOBAL_HEAD));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "TMF_OPCODE", 0x210,
+		  asd_hwi_swb_read_byte(asd, CSEQ_TMF_OPCODE));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "CLEAR_LU_HEAD", 0x212,
+		  asd_hwi_swb_read_word(asd, CSEQ_CLEAR_LU_HEAD));
+#endif
+	asd_print("   %20s[0x%x]:0x%04x\n", "FIRST_INV_SCB_SITE", 0x21C,
+		  asd_hwi_swb_read_word(asd, CSEQ_FIRST_INV_SCB_SITE));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "FIRST_INV_DDB_SITE", 0x21E,
+		  asd_hwi_swb_read_word(asd, CSEQ_FIRST_INV_DDB_SITE));
+
+	asd_print("\nCIO REGISTERS\n");
+	asd_print("*************\n");
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "ARP2_MODEPTR", MODEPTR,
+		  asd_hwi_swb_read_byte(asd, CMODEPTR));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "ARP2_ALTMODE", ALTMODE,
+		  asd_hwi_swb_read_byte(asd, CALTMODE));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "ARP2_FLAG", FLAG,
+		  asd_hwi_swb_read_byte(asd, CFLAG));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "ARP2_INTCTL", ARP2INTCTL,
+		  asd_hwi_swb_read_byte(asd, CARP2INTCTL));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "ARP2_PRGMCNT", PRGMCNT,
+		  asd_hwi_swb_read_word(asd, CPRGMCNT));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "ARP2_HALTCODE", ARP2HALTCODE,
+		  asd_hwi_swb_read_byte(asd, CARP2HALTCODE));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "ARP2_CURRADDR", CURRADDR,
+		  asd_hwi_swb_read_word(asd, CCURRADDR));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "ARP2_LASTADDR", LASTADDR,
+		  asd_hwi_swb_read_word(asd, CLASTADDR));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "ARP2_NXTLADDR", NXTLADDR,
+		  asd_hwi_swb_read_word(asd, CNXTLADDR));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "CLINKCON", 0x28,
+		  asd_hwi_swb_read_dword(asd, CLINKCON));
+		  	
+	asd_print("   %20s[0x%x]:0x%02x\n", "CCONMSK", 0x60,
+		  asd_hwi_swb_read_byte(asd, CCONMSK));
+	
+	asd_print("   %20s[0x%x]:0x%02x\n", "CCONEXIST", 0x61,
+		  asd_hwi_swb_read_byte(asd, CCONEXIST));
+	
+	asd_print("   %20s[0x%x]:0x%04x\n", "CCONMODE", 0x62,
+		  asd_hwi_swb_read_word(asd, CCONMODE));
+
+	for (i = 0 ; i < 16 ; i++) {
+		asd_print("   Mode%d:%20s[0x%x]:0x%08x\n", i,
+			"MnSCBPTR", MnSCBPTR,
+			asd_hwi_swb_read_word(asd, CSEQm_CIO_REG(i, MnSCBPTR)));
+		asd_print("   Mode%d:%20s[0x%x]:0x%08x\n", i,
+			"MnDDBPTR", MnDDBPTR,
+			asd_hwi_swb_read_word(asd, CSEQm_CIO_REG(i, MnDDBPTR)));
+	}
+
+}
+
+//
+// Support function to dump a scb site from the hardware
+//
+void DumpScbSite(struct asd_softc *asd, u_int lseq_id, uint16_t scb)
+{
+	uint32_t	lseqBaseAddr; 
+	uint8_t		regValue8; 
+	uint16_t	originalScb;
+	uint32_t	index;
+	uint8_t		scbSite[128];
+	struct scb	*scbptr;
+	struct sg_element 	 *sg;
+
+
+//JD
+   /* Go to mode 3 register space  */
+
+	if(scb==0xffff) return;
+
+	lseqBaseAddr = LmSEQ_PHY_BASE(3, lseq_id);
+
+   /* Save the original SCB */
+	originalScb = asd_hwi_swb_read_word(asd, (lseqBaseAddr + 0x20));
+
+	asd_hwi_swb_write_word(asd, (lseqBaseAddr + 0x20), scb);
+	asd_print("\nSCB: 0x%04x", scb );
+
+	for( index = 0; index < 128; index++)
+	{
+		if(!(index % 16))
+		{
+			asd_print("   \n");
+		}
+
+		regValue8 = asd_hwi_swb_read_byte(asd,(lseqBaseAddr + 0x100 + index));
+
+		scbSite[index] = regValue8;
+
+		asd_print("%02x ", regValue8 );
+	}
+
+	asd_print("   \nSCB Fields:\n");
+	asd_print("      scb_index : 0x%02x%02x\n", scbSite[9], scbSite[8]);
+	asd_print("      ssp_tag : 0x%02x%02x\n", scbSite[32], scbSite[33]);
+	asd_print("      scb_flags2 : 0x%02x\n", scbSite[72]);
+	asd_print("      scb_flags  : 0x%02x\n", scbSite[73]);
+	asd_print("      retry_count : 0x%02x\n", scbSite[74]);
+	asd_print("      active_path_cnt : 0x%02x\n", scbSite[75]);
+	asd_print("      scb_flags3 : 0x%02x\n", scbSite[76]);
+	asd_print("      scb_tgtcfrcnt : 0x%02x%02x%02x%02x\n", 
+                                  scbSite[67],
+                                  scbSite[66],
+                                  scbSite[65],
+                                  scbSite[64]);
+
+	asd_print("      ata_int_vec : 0x%02x%02x\n", scbSite[57],scbSite[56]);
+	asd_print("      ata_state : 0x%02x%02x\n", scbSite[59],scbSite[58]);
+	asd_print("      ata_hdr_mask : 0x%02x%02x\n", scbSite[79],scbSite[78]);
+   /* restore the original SCB */
+	asd_hwi_swb_write_word(asd, (lseqBaseAddr + 0x20), originalScb);
+
+	asd_print("\n");
+	originalScb=*((uint16_t *)&scbSite[8]);
+	if(originalScb == 0xffff) return;
+	scbptr=asd->scbindex[originalScb];
+	if(scbptr !=NULL)
+	{
+		asd_print("   \nStruct SCB 0x%x:\n",originalScb);
+		asd_print("      sg_count : 0x%x\n", scbptr->sg_count);
+		asd_print("      buf_busaddr : 0x%Lx\n", scbptr->platform_data->buf_busaddr);
+
+
+		for (index=0, sg = scbptr->sg_list; index<scbptr->sg_count ; index++, sg++) {
+			asd_print("      sg# : 0x%x (%p)\n", index, sg);
+			asd_print("       address : 0x%Lx\n", sg->bus_address);
+			asd_print("       length  : 0x%x\n", sg->length);
+			asd_print("       flags   : 0x%x\n", sg->flags);
+			asd_print("       next_sg_offset  : 0x%x\n\n", sg->next_sg_offset);
+		}
+		for (index=0; index<3 ; index++) {
+			struct asd_ssp_task_hscb *ssp_hscb;
+			ssp_hscb=&scbptr->hscb->ssp_task;
+			sg = &ssp_hscb->sg_elements[index];
+			asd_print("      HSCB->sg# : 0x%x\n", index);
+			asd_print("       address : 0x%Lx\n", sg->bus_address);
+			asd_print("       length  : 0x%x\n", sg->length);
+			asd_print("       flags   : 0x%x\n", sg->flags);
+			asd_print("       next_sg_offset  : 0x%x\n\n", sg->next_sg_offset);
+		}
+	}
+
+   return;
+}
+
+static void
+asd_hwi_dump_lseq_state(struct asd_softc *asd, u_int lseq_id)
+{
+	uint32_t lseq_cio_addr;
+	uint32_t mode_offset;
+	uint16_t saved_reg16;
+	uint16_t sm_idx;
+	int	 idx;
+	int	 mode;
+
+	asd_print("\nLSEQ %d DUMP STATE\n", lseq_id);
+	asd_print("=================\n");
+
+	asd_print("\nIOP REGISTERS\n");
+	asd_print("*************\n");
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "ARP2CTL", ARP2CTL,
+		  asd_hwi_swb_read_dword(asd, LmARP2CTL(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "ARP2INT", ARP2INT,
+		  asd_hwi_swb_read_dword(asd, LmARP2INT(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "ARP2INTEN", ARP2INTEN,
+		  asd_hwi_swb_read_dword(asd, LmARP2INTEN(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "ARP2BREAKADR01", ARP2BREAKADR01,
+		asd_hwi_swb_read_dword(asd, LmARP2BREAKADR01(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "ARP2BREAKADR23", ARP2BREAKADR23,
+		asd_hwi_swb_read_dword(asd, LmARP2BREAKADR23(lseq_id)));
+
+	asd_print("\nSCRATCH MEMORY\n");
+	asd_print("**************\n");
+
+	asd_print("\nMode Independent\n");
+	asd_print("----------------\n");
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "SCRATCH_FLAGS", 0x187,
+		  asd_hwi_swb_read_byte(asd, LmSEQ_SCRATCH_FLAGS(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "CONNECTION_STATE", 0x188,
+		  asd_hwi_swb_read_dword(asd, LmSEQ_CONNECTION_STATE(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "CONCTL", 0x18C,
+		  asd_hwi_swb_read_word(asd, LmSEQ_CONCTL(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "CONSTAT", 0x18E,
+		  asd_hwi_swb_read_byte(asd, LmSEQ_CONSTAT(lseq_id)));
+
+	for (mode = 0; mode < 3; mode++) {
+		asd_print("\nCommon Page 0 - Mode %d\n", mode);
+		asd_print("-----------------------\n");
+
+		/* Adjust the mode page. */
+		mode_offset = mode * LSEQ_MODE_SCRATCH_SIZE;
+		
+		asd_print("   %20s[0x%x]:0x%04x\n", "RET_ADDR", 0x0,
+			  asd_hwi_swb_read_word(asd, (LmSEQ_RET_ADDR(lseq_id) +
+						mode_offset)));
+
+		asd_print("   %20s[0x%x]:0x%04x\n", "RET_ADDR_SAVE", 0x6,
+			  asd_hwi_swb_read_word(asd,
+				  	       (LmSEQ_RET_ADDR_SAVE(lseq_id) +
+						mode_offset)));
+
+		asd_print("   %20s[0x%x]:0x%04x\n", "RET_ADDR_SAVE2", 0x8,
+			  asd_hwi_swb_read_word(asd,
+				  	       (LmSEQ_RET_ADDR_SAVE2(lseq_id) +
+						mode_offset)));
+
+		asd_print("   %20s[0x%x]:0x%04x\n", "MODE_FLAGS", 0x4,
+			  asd_hwi_swb_read_word(asd,
+				  	       (LmSEQ_MODE_FLAGS(lseq_id) +
+						mode_offset)));
+
+		asd_print("   %20s[0x%x]:0x%04x\n", "REG0_MODE", 0x2,
+			  asd_hwi_swb_read_word(asd,
+				  	       (LmSEQ_REG0_MODE(lseq_id) +
+						mode_offset)));
+
+		asd_print("   %20s[0x%x]:0x%04x\n", "DATA_TO_CSEQ", 0xC,
+			  asd_hwi_swb_read_word(asd,
+				  	       (LmSEQ_DATA_TO_CSEQ(lseq_id) +
+						mode_offset)));
+
+		asd_print("   %20s[0x%x]:0x%02x\n", "OPCODE_TO_CSEQ", 0xB,
+			  asd_hwi_swb_read_byte(asd,
+				  	       (LmSEQ_OPCODE_TO_CSEQ(lseq_id) +
+						mode_offset)));
+	}
+
+	asd_print("\nPage 0 - Mode 5\n");
+	asd_print("----------------\n");
+
+	mode_offset = LSEQ_MODE5_PAGE0_OFFSET;
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "RET_ADDR", 0x0,
+		  asd_hwi_swb_read_word(asd, (LmSEQ_RET_ADDR(lseq_id) +
+				  	mode_offset)));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "RET_ADDR_SAVE", 0x6,
+		  asd_hwi_swb_read_word(asd, (LmSEQ_RET_ADDR_SAVE(lseq_id) +
+					mode_offset)));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "RET_ADDR_SAVE2", 0x8,
+		  asd_hwi_swb_read_word(asd, (LmSEQ_RET_ADDR_SAVE2(lseq_id) +
+					mode_offset)));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "MODE_FLAGS", 0x4,
+		  asd_hwi_swb_read_word(asd, (LmSEQ_MODE_FLAGS(lseq_id) +
+					mode_offset)));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "REG0_MODE", 0x2,
+		  asd_hwi_swb_read_word(asd, (LmSEQ_REG0_MODE(lseq_id) +
+					mode_offset)));
+
+	asd_print("   %20s[0x%x]:0x%04x\n", "DATA_TO_CSEQ", 0xC,
+		  asd_hwi_swb_read_word(asd, (LmSEQ_DATA_TO_CSEQ(lseq_id) +
+					mode_offset)));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "OPCODE_TO_CSEQ", 0xB,
+		  asd_hwi_swb_read_byte(asd, (LmSEQ_OPCODE_TO_CSEQ(lseq_id) +
+					mode_offset)));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "SAVED_OOB_STATUS", 0x6E,
+		  asd_hwi_swb_read_byte(asd, LmSEQ_SAVED_OOB_STATUS(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "SAVED_OOB_MODE", 0x6F,
+		  asd_hwi_swb_read_byte(asd, LmSEQ_SAVED_OOB_MODE(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%02x\n", "SAVED_OOB_SIGNALS", 0x73,
+		  asd_hwi_swb_read_byte(asd, LmSEQ_SAVED_OOB_SIGNALS(lseq_id)));
+
+	asd_print("\nPage 1 - Mode 2\n");
+	asd_print("----------------\n");
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "INVALID_DWORD_COUNT", 0x120,
+		  asd_hwi_swb_read_dword(asd,LmSEQ_INVALID_DWORD_CNT(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "DISPARITY_ERROR_COUNT", 0x124,
+		  asd_hwi_swb_read_dword(asd,
+			  		 LmSEQ_DISPARITY_ERROR_CNT(lseq_id)));
+
+	asd_print("   %20s[0x%x]:0x%08x\n", "LOSS_OF_SYNC_COUNT", 0x128,
+		  asd_hwi_swb_read_dword(asd,
+			  		 LmSEQ_LOSS_OF_SYNC_CNT(lseq_id)));
+
+	asd_print("\nCIO REGISTERS\n");
+	asd_print("*************\n");
+
+	for (mode = 0; mode < 2; mode++) {
+		uint16_t scb;
+		scb=0xffff;
+		asd_print("\nMode %d\n", mode);
+		asd_print("------\n");
+
+		idx = 0;
+		lseq_cio_addr = LmSEQ_PHY_BASE(mode, lseq_id);
+		
+		while (LSEQmCIOREGS[idx].width != 0) {
+			/* 
+			 * Check if we are in the right mode to dump the
+			 * contents of the registers.
+			 */
+			if ((LSEQmCIOREGS[idx].mode & (1 << mode)) != 0) {
+				switch(LSEQmCIOREGS[idx].width) {
+               			case 8:
+					asd_print("%20s[0x%x]: 0x%02x\n",
+						  LSEQmCIOREGS[idx].name,
+						  LSEQmCIOREGS[idx].offset,
+						 (asd_hwi_swb_read_byte(asd,
+						 (lseq_cio_addr +
+						  LSEQmCIOREGS[idx].offset))));
+//JD
+					if(LSEQmCIOREGS[idx].offset == 0x65) //"LmMnSGBADR"
+					{
+						uint8_t savedRegValue8;
+						uint8_t regValue8;
+						int nIndex;
+
+						savedRegValue8 = asd_hwi_swb_read_byte(asd,(lseq_cio_addr + 0x65));
+
+         /* Set up to display SG Buffer */
+						regValue8 = 0;
+						asd_hwi_swb_write_byte(asd, (lseq_cio_addr + 0x65), regValue8);
+						asd_print("\n  SG Buffer:");
+						for (nIndex = 0; nIndex < 128; nIndex++)
+						{
+            /* Display the buffer in SG element format: 16 bytes a line */
+							if ((nIndex % 16) == 0)
+							{
+								asd_print("\n%18s[%04d-%04d]: 0x", "bytes", nIndex, nIndex+15 );
+							}
+            /* We need to read a byte at a time from the SG Buffer */
+
+            /* register and displays it. */
+							regValue8 = asd_hwi_swb_read_byte(asd,(lseq_cio_addr + 0x53));//LmMnSGBUF
+							asd_print("%02x", regValue8);
+						}
+         /* Restore SG Buffer value */
+						asd_hwi_swb_write_byte(asd, (lseq_cio_addr + 0x65), savedRegValue8);
+						asd_print("\n\n");
+					}
+
+					if(LSEQmCIOREGS[idx].offset == 0x61) //"LmMnPIPECTL"
+					{
+						uint8_t regValue8;
+						int i;
+
+						regValue8 = asd_hwi_swb_read_byte(asd,(lseq_cio_addr + 0x61));
+ 
+      /* Set up to display ACTIVE Device element */
+//	LPIPECTL	equ 07h	;	Pipeline control mode:
+						regValue8 = (regValue8 & 0xf8);
+//	ACTDNONDESTRUCT	equ 02h	;	    Active device-side non-destructive
+
+						regValue8 |= 0x02;
+						asd_hwi_swb_write_byte(asd, (lseq_cio_addr + 0x61), regValue8);
+
+						asd_print("\n  ACTIVE Device DMA:");
+
+						for (i = 0; i <= 15; i++)
+						{
+							if (i == 0)
+							{
+								asd_print("\n     Address bytes[0-7]:");
+							}
+							else if (i == 8)
+							{
+								asd_print("\n       Count bytes[0-4]:");
+							}
+							else if (i == 12)
+							{
+								asd_print("\n       Flags bytes[0-4]:");
+							}
+
+         /* Read LmMnDMAENG - 0x60 */
+
+							asd_print("%02x", asd_hwi_swb_read_byte(asd,
+								(lseq_cio_addr + 0x60)) ); //MnDMAENG
+						}
+						asd_print("\n");
+
+
+      /* Set up to display NEXT Device element */
+
+						regValue8 = (regValue8 & 0xf8);
+//NXTDNONDESTRUCT	equ 03h
+						regValue8 |= 0x03;
+						asd_hwi_swb_write_byte(asd, (lseq_cio_addr + 0x61), regValue8);
+						asd_print("\n  NEXT Device DMA:");
+
+						for (i = 0; i <= 15; i++)
+						{
+							if (i == 0)
+							{
+								asd_print("\n     Address bytes[0-7]:");
+							}
+							else if (i == 8)
+							{
+								asd_print("\n       Count bytes[0-4]:");
+							}
+							else if (i == 12)
+							{
+								asd_print("\n       Flags bytes[0-4]:");
+							}
+
+         /* Read LmMnDMAENG - 0x60 */
+							asd_print("%02x", asd_hwi_swb_read_byte(asd,
+								(lseq_cio_addr + 0x60)) ); //MnDMAENG
+						}
+						asd_print("\n");
+
+ 
+
+      /* Set up to display ACTIVE Host element */
+						regValue8 = (regValue8 & 0xf8);
+//	ACTHNONDESTRUCT	equ 05h	;	    Active host-side non-destructive
+						regValue8 |= 0x05;
+						asd_hwi_swb_write_byte(asd, (lseq_cio_addr + 0x61), regValue8);
+
+						asd_print("\n  ACTIVE Host DMA:");
+						for (i = 0; i <= 15; i++)
+						{
+							if (i == 0)
+							{
+								asd_print("\n     Address bytes[0-7]:");
+							}
+							else if (i == 8)
+							{
+								asd_print("\n       Count bytes[0-4]:");
+							}
+							else if (i == 12)
+							{
+								asd_print("\n       Flags bytes[0-4]:");
+							}
+
+         /* Read LmMnDMAENG - 0x60 */
+							asd_print("%02x", asd_hwi_swb_read_byte(asd,
+								(lseq_cio_addr + 0x60)) ); //MnDMAENG
+
+						}
+						asd_print("\n");
+
+ 
+
+      /* Set up to display NEXT Host element */
+
+						regValue8 = (regValue8 & 0xf8);
+//	NXTHNONDESTRUCT	equ 06h	;	    Next host-side non-destructive
+
+						regValue8 |= 0x06;
+						asd_hwi_swb_write_byte(asd, (lseq_cio_addr + 0x61), regValue8);
+
+						asd_print("\n  NEXT Host DMA:");
+
+						for (i = 0; i <= 15; i++)
+						{
+							if (i == 0)
+							{
+								asd_print("\n     Address bytes[0-7]:");
+							}
+							else if (i == 8)
+							{
+								asd_print("\n       Count bytes[0-4]:");
+							}
+							else if (i == 12)
+							{
+								asd_print("\n       Flags bytes[0-4]:");
+							}
+
+         /* Read LmMnDMAENG - 0x60 */
+							asd_print("%02x", asd_hwi_swb_read_byte(asd,
+								(lseq_cio_addr + 0x60)) ); //MnDMAENG
+						}
+						asd_print("\n\n");
+					}
+ 
+                  			break;
+				case 16:
+					asd_print("%20s[0x%x]: 0x%04x\n",
+						  LSEQmCIOREGS[idx].name,
+						  LSEQmCIOREGS[idx].offset,
+						 (asd_hwi_swb_read_word(asd,
+						 (lseq_cio_addr +
+						  LSEQmCIOREGS[idx].offset))));
+//JD
+					if(LSEQmCIOREGS[idx].offset == 0x20) //"LmMnSCBPTR"
+					{
+						scb=asd_hwi_swb_read_word(asd,
+						 (lseq_cio_addr + 0x20));
+					}
+                  			break;
+				case 32:
+					asd_print("%20s[0x%x]: 0x%08x\n",
+						  LSEQmCIOREGS[idx].name,
+						  LSEQmCIOREGS[idx].offset,
+						 (asd_hwi_swb_read_dword(asd,
+						 (lseq_cio_addr +
+						  LSEQmCIOREGS[idx].offset))));
+					break;
+				}
+			}
+			idx++;
+		}
+		if(scb !=0xffff) DumpScbSite(asd, lseq_id, scb);
+	}
+
+	asd_print("\nCIO REGISTERS\n");
+	asd_print("*************\n");
+
+	asd_print("\nMode 5\n");
+	asd_print("------\n");
+
+	lseq_cio_addr = LmSEQ_PHY_BASE(5, lseq_id);
+	idx = 0;
+
+	while (LSEQmOOBREGS[idx].width != 0) {
+		switch(LSEQmOOBREGS[idx].width) {
+               	case 8:
+			asd_print("%20s[0x%x]: 0x%02x\n",
+				  LSEQmOOBREGS[idx].name,
+				  LSEQmOOBREGS[idx].offset,
+				 (asd_hwi_swb_read_byte(
+						asd, (lseq_cio_addr +
+						LSEQmOOBREGS[idx].offset))));
+                  	break;
+		case 16:
+			asd_print("%20s[0x%x]: 0x%04x\n",
+				  LSEQmOOBREGS[idx].name,
+				  LSEQmOOBREGS[idx].offset,
+				 (asd_hwi_swb_read_word(
+						asd, (lseq_cio_addr +
+						LSEQmOOBREGS[idx].offset))));
+                  	break;
+		case 32:
+			asd_print("%20s[0x%x]: 0x%08x\n",
+				  LSEQmOOBREGS[idx].name,
+				  LSEQmOOBREGS[idx].offset,
+				 (asd_hwi_swb_read_dword(
+						asd, (lseq_cio_addr +
+						LSEQmOOBREGS[idx].offset))));
+			break;
+		}
+		idx++;
+	}
+
+	asd_print("\nLSEQ %d STATE MACHINES.\n", lseq_id);
+	asd_print("**********************\n");
+
+	saved_reg16 = asd_hwi_swb_read_word(asd, LmSMDBGCTL(lseq_id));
+
+	for (sm_idx = 0; sm_idx < 32; sm_idx++) {
+		asd_hwi_swb_write_word(asd, LmSMDBGCTL(lseq_id), sm_idx);
+
+		asd_print("   %20s[0x%x]:0x%08x\n", "SMSTATE", sm_idx,
+			  asd_hwi_swb_read_dword(asd, LmSMSTATE(lseq_id)));
+
+		asd_print("   %20s[0x%x]:0x%08x\n", "SMSTATEBRK", sm_idx,
+			  asd_hwi_swb_read_dword(asd, LmSMSTATEBRK(lseq_id)));
+	}
+
+	asd_hwi_swb_write_word(asd, LmSMDBGCTL(lseq_id), saved_reg16);
+}
+
+
+/**
+ * asd_dump_ddb_site -- dump a CSEQ DDB site
+ * @asd_ha: pointer to host adapter structure
+ * @site_no: site number of interest
+ */
+void asd_hwi_dump_ddb_site_raw(struct asd_softc *asd, uint16_t site_no)
+{
+	uint16_t	index;
+
+	if (site_no >= asd->hw_profile.max_ddbs)
+		return;
+
+	for (index = 0; index < 0x80 ; index+=16) {
+		asd_log(ASD_DBG_INFO,"%02x : %02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x\n",\
+                           index,\
+                           asd_hwi_get_ddbsite_byte(asd,index),\
+                           asd_hwi_get_ddbsite_byte(asd,index+1),\
+                           asd_hwi_get_ddbsite_byte(asd,index+2),\
+                           asd_hwi_get_ddbsite_byte(asd,index+3),\
+                           asd_hwi_get_ddbsite_byte(asd,index+4),\
+                           asd_hwi_get_ddbsite_byte(asd,index+5),\
+                           asd_hwi_get_ddbsite_byte(asd,index+6),\
+                           asd_hwi_get_ddbsite_byte(asd,index+7),\
+                           asd_hwi_get_ddbsite_byte(asd,index+8),\
+                           asd_hwi_get_ddbsite_byte(asd,index+9),\
+                           asd_hwi_get_ddbsite_byte(asd,index+10),\
+                           asd_hwi_get_ddbsite_byte(asd,index+11),\
+                           asd_hwi_get_ddbsite_byte(asd,index+12),\
+                           asd_hwi_get_ddbsite_byte(asd,index+13),\
+                           asd_hwi_get_ddbsite_byte(asd,index+14),\
+                           asd_hwi_get_ddbsite_byte(asd,index+15));
+	}
+}
+void asd_hwi_dump_ddb_sites_raw(struct asd_softc *asd)
+{
+	uint16_t site_no;
+	u8	opcode;
+	for (site_no = 1; site_no < asd->hw_profile.max_ddbs; site_no++) {
+		/* We are only interested in DDB sites currently used.
+                 * Re-use opcode to store the connection rate.
+		 */
+		/* Setup the hardware DDB site. */
+		asd_hwi_set_ddbptr(asd, site_no);
+
+		opcode=asd_hwi_get_ddbsite_byte(asd,0x0f);
+//		if ((opcode & 0x0F) == 0)
+//			continue;
+		asd_log(ASD_DBG_INFO,"DDB: %x\n",site_no);
+
+		asd_hwi_dump_ddb_site_raw(asd, site_no);
+	}
+}
+void asd_hwi_dump_scb_site_raw(struct asd_softc *asd, uint16_t site_no)
+{
+
+	uint16_t	index;
+
+	for (index = 0; index < ASD_SCB_SIZE; index+=16) {
+		asd_log(ASD_DBG_INFO,"%02x : %02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x\n",\
+                           index,\
+                           asd_hwi_get_scbsite_byte(asd,index),\
+                           asd_hwi_get_scbsite_byte(asd, index+1),\
+                           asd_hwi_get_scbsite_byte(asd, index+2),\
+                           asd_hwi_get_scbsite_byte(asd, index+3),\
+                           asd_hwi_get_scbsite_byte(asd, index+4),\
+                           asd_hwi_get_scbsite_byte(asd, index+5),\
+                           asd_hwi_get_scbsite_byte(asd, index+6),\
+                           asd_hwi_get_scbsite_byte(asd, index+7),\
+                           asd_hwi_get_scbsite_byte(asd, index+8),\
+                           asd_hwi_get_scbsite_byte(asd, index+9),\
+                           asd_hwi_get_scbsite_byte(asd, index+10),\
+                           asd_hwi_get_scbsite_byte(asd, index+11),\
+                           asd_hwi_get_scbsite_byte(asd, index+12),\
+                           asd_hwi_get_scbsite_byte(asd, index+13),\
+                           asd_hwi_get_scbsite_byte(asd, index+14),\
+                           asd_hwi_get_scbsite_byte(asd, index+15));
+	}
+}
+/* 
+ * Function:
+ *	asd_hwi_init_scb_sites()
+ *
+ * Description:
+ *	Initialize HW SCB sites.	 
+ */
+void asd_hwi_dump_scb_sites_raw(struct asd_softc *asd)
+{
+	uint16_t	site_no;
+	u8	opcode;
+
+#ifndef EXTENDED_SCB
+	for (site_no = 0; site_no < ASD_MAX_SCB_SITES; site_no++) {
+#else
+	for (site_no = 0; site_no < (ASD_MAX_SCB_SITES + ASD_EXTENDED_SCB_NUMBER); site_no++) {
+#endif
+		/* 
+		 * Adjust to the SCB site that we want to access in command
+		 * context memory.
+		 */	 
+		asd_hwi_set_scbptr(asd, site_no);
+		/* We are only interested in SCB sites currently used.
+		 */
+		opcode = asd_hwi_get_scbsite_byte(asd,10);
+		if (opcode == 0xFF)
+			continue;
+
+		asd_log(ASD_DBG_INFO,"\nSCB: 0x%x\n", site_no);
+		asd_hwi_dump_scb_site_raw(asd, site_no);
+	}
+
+
+}
+
+void
+#ifdef SEQUENCER_UPDATE
+asd_hwi_dump_ssp_smp_ddb_site(struct asd_softc *asd, u_int site_no)
+#else
+asd_hwi_dump_ddb_site(struct asd_softc *asd, u_int site_no)
+#endif
+{
+	int i;
+	uint16_t scb;
+	if (site_no >= ASD_MAX_DDBS)
+		return;
+
+	/* Setup the hardware DDB site. */
+	asd_hwi_set_ddbptr(asd, site_no);
+
+	asd_print("\nDDB: 0x%x\n", site_no);
+	asd_print("---------\n\n");
+	asd_print("dest_sas_addr: 0x");
+	for(i=0;i<8;i++)
+	{
+		asd_print("%02x",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, dest_sas_addr)+i)); 
+	}
+	asd_print("\n RAW DATA:");
+	for(i=0;i<60;i++)
+	{
+		if( !(i % 16) )
+			asd_print("\n");
+		asd_print("%02x ",
+		  asd_hwi_get_ddbsite_byte(asd,i)); 
+	}
+	asd_print("\n");
+	asd_print("SendQ Target Head: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, send_q_head))); 
+	asd_print("SendQ Suspended: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, sqsuspended)));
+	asd_print("DDB Type: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, ddb_type)));
+	asd_print("AWT Default: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, awt_default)));
+	asd_print("Pathway Blocked Count: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, pathway_blk_cnt)));
+	asd_print("Conn Mask: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, conn_mask)));
+	asd_print("DDB Flags: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, open_affl)));
+	asd_print("ExecQ Target Tail: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, exec_q_tail)));
+	asd_print("SendQ Target Tail: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, send_q_tail)));
+#ifdef SEQUENCER_UPDATE
+	asd_print("Max Number of Concurrent Connections: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, max_concurrent_connections)));
+	asd_print("Current Number of Concurrent Connections: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, concurrent_connections)));
+	asd_print("Tunable Number of Contexts: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, tunable_number_contexts)));
+#endif
+	asd_print("Active Task Count: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, active_task_cnt)));
+	asd_print("ITNL Reason: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, itnl_reason)));
+	asd_print("INTL Timeout Const: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, itnl_const)));
+	scb = asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_sata_stp_ddb, ata_cmd_scb_ptr));
+	if((scb!=0xffff)&&(scb!=0))
+	{
+		uint8_t conn_mask;
+		u_int	lseq_id;
+		conn_mask = asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_ssp_smp_ddb, conn_mask));
+		lseq_id=0;
+		for ( ; lseq_id < 8; lseq_id++) {
+			if (conn_mask & (1 << lseq_id)) {
+				conn_mask &= ~(1 << lseq_id);
+				break;
+			} 
+		}
+		/* Dump out specific scb Registers state. */
+		DumpScbSite(asd, lseq_id, scb);
+	}
+}
+
+#ifdef SEQUENCER_UPDATE
+void
+asd_hwi_dump_sata_stp_ddb_site(struct asd_softc *asd, u_int site_no)
+{
+	if (site_no >= ASD_MAX_DDBS)
+		return;
+
+	/* Setup the hardware DDB site. */
+	asd_hwi_set_ddbptr(asd, site_no);
+
+	asd_print("\nDDB: 0x%x\n", site_no);
+	asd_print("---------\n\n");
+
+	asd_print("SendQ Target Head: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_sata_stp_ddb, send_q_head)));
+	asd_print("SendQ Suspended: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_sata_stp_ddb, sqsuspended)));
+	asd_print("DDB Type: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_sata_stp_ddb, ddb_type)));
+	asd_print("AWT Default: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_sata_stp_ddb, awt_default)));
+	asd_print("Pathway Blocked Count: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_sata_stp_ddb, pathway_blk_cnt)));
+	asd_print("Conn Mask: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_sata_stp_ddb, conn_mask)));
+	asd_print("Open Reject Status: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_sata_stp_ddb, stp_close)));
+	asd_print("ExecQ Target Tail: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_sata_stp_ddb, exec_q_tail)));
+	asd_print("SendQ Target Tail: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_sata_stp_ddb, send_q_tail)));
+	asd_print("Active Task Count: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_sata_stp_ddb, active_task_cnt)));
+	asd_print("ITNL Reason: 0x%02x.\n",
+		  asd_hwi_get_ddbsite_byte(asd,
+		  	offsetof(struct asd_sata_stp_ddb, itnl_reason)));
+	asd_print("INTL Timeout Const: 0x%04x.\n",
+		  asd_hwi_get_ddbsite_word(asd,
+		  	offsetof(struct asd_sata_stp_ddb, itnl_const)));
+}
+#endif
+
+/*
+ * Template to hold setting breakpoint for ARP2 codes.
+ */
+void
+asd_hwi_set_cseq_breakpoint(struct asd_softc *asd, uint16_t addr)
+{
+	uint32_t	inten;
+
+	asd_hwi_swb_write_dword(asd, CARP2BREAKADR01, addr >> 2);
+
+	asd_hwi_swb_write_dword(asd, CARP2INT, 0xF);
+
+	asd_hwi_swb_write_dword(asd, CARP2CTL, 
+		asd_hwi_swb_read_dword(asd, CARP2CTL) | BREAKEN0);
+
+	inten = asd_hwi_swb_read_dword(asd, CARP2INTEN);
+
+	asd_hwi_swb_write_dword(asd, CARP2INTEN, inten | EN_ARP2BREAK0);
+}
+#if 0
+void
+asd_hwi_set_lseq_breakpoint(struct asd_softc *asd, int phy_id, uint16_t addr)
+{
+	uint32_t	inten;
+
+	asd_hwi_swb_write_dword(asd, LmARP2BREAKADR01(phy_id), addr >> 2);
+
+	asd_hwi_swb_write_dword(asd, LmARP2INT(phy_id), 0xF);
+
+	asd_hwi_swb_write_dword(asd, LmARP2CTL(phy_id), 
+		asd_hwi_swb_read_dword(asd, LmARP2CTL(phy_id)) | BREAKEN0);
+
+	inten = asd_hwi_swb_read_dword(asd, LmARP2INTEN(phy_id));
+
+	asd_hwi_swb_write_dword(asd, LmARP2INTEN(phy_id),
+		inten | EN_ARP2BREAK0);
+}
+#else
+void
+asd_hwi_set_lseq_breakpoint(struct asd_softc *asd, int phy_id, uint32_t breakid, uint16_t addr)
+{
+	uint32_t	inten;
+	uint32_t	brkadr;
+
+	switch(breakid)
+	{
+	case EN_ARP2BREAK1:
+		brkadr = asd_hwi_swb_read_dword(asd, LmARP2BREAKADR01(phy_id)) & (~BREAKADR1_MASK);
+		brkadr |= ((addr >> 2) << 16);
+		asd_hwi_swb_write_dword(asd, LmARP2BREAKADR01(phy_id), brkadr);
+		break;
+	case EN_ARP2BREAK2:
+		brkadr = asd_hwi_swb_read_dword(asd, LmARP2BREAKADR23(phy_id)) & (~BREAKADR2_MASK);
+		brkadr |= (addr >> 2);
+		asd_hwi_swb_write_dword(asd, LmARP2BREAKADR23(phy_id), brkadr);
+		break;
+	case EN_ARP2BREAK3:
+		brkadr = asd_hwi_swb_read_dword(asd, LmARP2BREAKADR23(phy_id)) & (~BREAKADR3_MASK);
+		brkadr |= ((addr >> 2) << 16);
+		asd_hwi_swb_write_dword(asd, LmARP2BREAKADR23(phy_id), brkadr);
+		break;
+	case EN_ARP2BREAK0:
+	default:
+		brkadr = asd_hwi_swb_read_dword(asd, LmARP2BREAKADR01(phy_id)) & (~BREAKADR0_MASK);
+		brkadr |= (addr >> 2);
+		asd_hwi_swb_write_dword(asd, LmARP2BREAKADR01(phy_id), brkadr);
+		break;
+	}
+
+	asd_hwi_swb_write_dword(asd, LmARP2INT(phy_id), 0xF);
+
+	asd_hwi_swb_write_dword(asd, LmARP2CTL(phy_id), 
+		asd_hwi_swb_read_dword(asd, LmARP2CTL(phy_id)) | (breakid<<8));
+
+	inten = asd_hwi_swb_read_dword(asd, LmARP2INTEN(phy_id));
+
+	asd_hwi_swb_write_dword(asd, LmARP2INTEN(phy_id),
+		inten | breakid);
+}
+#endif
+#define DUMP_MEMSIZE		1024
+
+void
+asd_hwi_read_mem(struct asd_softc *asd, uint8_t *memory,
+	unsigned addr, unsigned len)
+{
+	unsigned	i;
+
+	for (i = 0 ; i < (len / sizeof(unsigned)) ; i+=sizeof(unsigned))
+	{
+		*((unsigned *)memory + i) = asd_hwi_swb_read_dword(
+			asd, addr + i);
+	}
+}
+
+#define ISPRINT(c) (((c) >= ' ') && ((c) <= '~'))
+
+void
+asd_printhex(
+unsigned char	*s,
+unsigned	addr,
+unsigned	len,
+unsigned	chunks
+)
+{
+	unsigned	i;
+	unsigned	count;
+	unsigned	num;
+	char		*format_string;
+	char		*blank_string;
+
+	i = 0;
+
+	for (count = 0 ; count < len ; count = count + num, s = s + num,
+		addr = addr + num)
+	{
+		num = ((len - count) > 16) ? 16 : (len - count);
+
+		asd_print("0x%08x: ", addr);
+
+		switch (chunks)
+		{
+		case 1:
+			blank_string = "   ";
+			for (i = 0 ; i < num ; i += chunks)
+			{
+				asd_print("%02x ", *((unsigned char *)(s + i)));
+			}
+			break;
+		case 2:
+			blank_string = "     ";
+			for (i = 0 ; i < num ; i += chunks)
+			{
+				asd_print("%04x ",
+					*((unsigned short *)(s + i)));
+			}
+			break;
+		case 4:
+			blank_string = "         ";
+			for (i = 0 ; i < num ; i += chunks)
+			{
+				asd_print("%08x ", *((unsigned *)(s + i)));
+			}
+			break;
+		}
+
+
+		while (i != num)
+		{
+			asd_print(blank_string);
+			i++;
+		}
+
+		for (i = 0 ; i < num ; i++)
+		{
+			if (ISPRINT(*(s + i)))
+			{
+				asd_print("%c", *(s + i));
+			}
+			else
+			{
+				asd_print(".");
+			}
+		}
+
+		asd_print("\n");
+	}
+}
+
+void
+asd_hwi_dump_seq_raw(struct asd_softc *asd)
+{
+	uint8_t		*memory;
+	unsigned	index;
+	unsigned	size;
+
+	memory = (uint8_t *)asd_alloc_mem(DUMP_MEMSIZE, GFP_KERNEL);
+
+	index = 0;
+	
+	size = 0x40;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 0 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 1 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 2 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 3 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 4 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 5 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 6 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 7 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x60;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 8 Pages 0-2\n");
+	printk("CSEQ: Mode Independent Scratch Pages 0-2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x60;
+	printk("\nCSEQ: Mode Independent Scratch Pages 0-2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	index += 0x20; // skipping hole
+
+	size = 0x80;
+	printk("\nCSEQ: Mode Independent Scratch Pages 4-7\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 0 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 1 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 2 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 3 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 4 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 5 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 6 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nCSEQ: Mode Dependent Scratch Mode 7 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, CMAPPEDSCR + index, size);
+	asd_printhex(memory, CMAPPEDSCR + index, size, 2);
+	index += size;
+
+	printk("\n-----------------------------------------------------\n\n");
+
+	index = 0;
+	
+	size = 0x40;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 0 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 1 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 2 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 3 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 4 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 5 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 6 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x40;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 7 Pages 0-1\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x60;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 8 Pages 0-2\n");
+	printk("LSEQ: Mode Independent Scratch Pages 0-2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x60;
+	printk("\nLSEQ: Mode Independent Scratch Pages 0-2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	index += 0x20; // skipping hole
+
+	size = 0x80;
+	printk("\nLSEQ: Mode Independent Scratch Pages 4-7\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 0 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 1 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 2 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 3 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 4 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 5 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 6 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+
+	size = 0x20;
+	printk("\nLSEQ: Mode Dependent Scratch Mode 7 Pages 2\n");
+	asd_hwi_read_mem(asd, memory, LmSCRATCH(0) + index, size);
+	asd_printhex(memory, LmSCRATCH(0) + index, size, 2);
+	index += size;
+	asd_free_mem(memory);
+}
+
+#endif /* ASD_DEBUG */
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_seq.h linux-2.6.16/drivers/scsi/adp94xx/adp94xx_seq.h
--- linux-2.6.16.old/drivers/scsi/adp94xx/adp94xx_seq.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/adp94xx_seq.h	2007-04-05 23:37:45.000000000 +0000
@@ -0,0 +1,4257 @@
+/* 
+ * Central and Link Sequencer Code for AIC-94xx 
+ * Version: V17
+ */
+#if SAS_SEQUENCER_A1 
+
+uint8_t Csa1[] = {
+0x00,0x0C,0x32,0xC0,0x05,0x00,0x0C,0x38,0x00,0x0C,0xBC,0xC3,0x01,0x11,0x2A,0x80,
+0x02,0x11,0x2A,0x80,0x01,0x05,0x0A,0x84,0x06,0x11,0x48,0x80,0x01,0x00,0x8C,0xB3,
+0x02,0x20,0x88,0xB3,0x02,0x06,0x80,0xB3,0x02,0x06,0x84,0x33,0x01,0xC7,0x8F,0x03,
+0x04,0x11,0x48,0x00,0x88,0x11,0x00,0x80,0x00,0x0C,0x66,0x40,0xFE,0xC7,0x8F,0x8B,
+0x01,0xC6,0x01,0xB0,0x02,0xC4,0x41,0xB0,0x02,0xC2,0x0D,0x30,0x02,0xC0,0x0D,0xB0,
+0x07,0x11,0x48,0x84,0x80,0xE1,0xC3,0x03,0x00,0x0C,0x32,0xC0,0x02,0x06,0xC0,0x33,
+0x02,0x20,0xC4,0x33,0x88,0x11,0x00,0x80,0x06,0x11,0x48,0x80,0x01,0xC7,0x1F,0xE8,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0x07,0x11,0x48,0x00,0x00,0x00,0x14,0x38,
+0x8A,0xD4,0x47,0x28,0xFF,0xD1,0x47,0x70,0x00,0x0C,0xA8,0x5A,0x04,0x11,0x48,0x00,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0xFF,0xC1,0x51,0x70,0x00,0x0C,0xFC,0xDA,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0xFF,0xC9,0x59,0x70,0x00,0x0C,0x04,0xDB,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0xFF,0xDC,0x63,0x78,0x00,0x0C,0x88,0x5B,
+0x88,0x11,0x00,0x80,0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0x80,0xE1,0x6D,0x68,
+0x02,0xE2,0x41,0x30,0x02,0xE0,0x0D,0xB4,0x01,0x35,0xA0,0x69,0xFF,0xCD,0xF3,0x60,
+0xFF,0xC5,0x77,0xE0,0xFF,0xD1,0x59,0x61,0x00,0x0C,0x32,0xC0,0x80,0x00,0x1C,0x38,
+0x02,0xC4,0x41,0xB0,0x02,0x08,0x27,0xB0,0x01,0x0A,0x15,0xB0,0xC0,0x0A,0x9C,0xE0,
+0x00,0x04,0x27,0x00,0x44,0x04,0x19,0xA8,0x01,0x11,0x1A,0x80,0x01,0x12,0x08,0x32,
+0x01,0x0C,0x18,0x18,0x04,0x12,0x26,0xB0,0x01,0x0C,0x19,0x1A,0x01,0x0C,0x15,0xB0,
+0x00,0x0B,0x97,0xE0,0xB1,0x00,0x9A,0xA8,0x00,0x0C,0xAA,0x40,0xFF,0x04,0xB5,0x68,
+0x02,0x00,0x41,0x30,0x00,0x0C,0xB4,0x40,0x01,0x4D,0x15,0xB0,0x01,0x0A,0x26,0xB0,
+0x04,0x3C,0xB1,0x33,0xFF,0x0A,0xA8,0xE8,0x02,0x30,0xB0,0xB3,0x00,0x00,0xB4,0x3B,
+0x04,0xD8,0x27,0x30,0x02,0x00,0xA9,0x33,0x02,0x0E,0x0C,0xB0,0xB1,0x00,0xAA,0xA8,
+0x02,0x06,0x1C,0xB0,0x02,0xD4,0x41,0x30,0x02,0x11,0x4A,0x80,0x01,0xF4,0x27,0xB0,
+0x00,0x11,0x4A,0x88,0x01,0x4E,0x22,0x30,0xFF,0x21,0xC2,0xF0,0xFF,0x0E,0xC2,0xF8,
+0x10,0x4D,0x7A,0xF8,0x02,0x20,0x88,0xB3,0xFF,0x21,0xC8,0x60,0xFF,0xFF,0x8C,0xBB,
+0x02,0x11,0x4A,0x80,0x04,0xF0,0x81,0x30,0x04,0xEC,0x89,0x30,0x03,0xE8,0x15,0x88,
+0x44,0x0A,0x14,0xA8,0x00,0x11,0x4A,0x88,0x80,0x0E,0x90,0x98,0xFF,0x0A,0x96,0x08,
+0x1C,0x11,0x6E,0x80,0x00,0x0C,0x2E,0x58,0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,
+0x04,0x11,0x68,0x80,0x02,0x11,0x4A,0x80,0x04,0x40,0xE0,0x33,0x10,0x4D,0xEE,0x78,
+0x04,0xE8,0xE1,0x33,0xFC,0xF0,0xE1,0x0B,0x01,0xF4,0xE9,0x93,0x00,0x11,0x4A,0x88,
+0x00,0x0C,0x2A,0xC0,0x07,0x11,0x48,0x00,0xFF,0xD1,0x33,0x70,0xB1,0x00,0x80,0x28,
+0xFF,0x0E,0xF4,0x68,0x04,0x11,0x48,0x00,0x02,0x20,0xC8,0x33,0x80,0x00,0x1C,0x38,
+0x02,0xCC,0x41,0x30,0x0C,0x4D,0x0B,0x71,0x0B,0x4D,0x0B,0xF1,0x0A,0x4D,0x1D,0xF1,
+0x1C,0x11,0x2A,0x80,0x04,0x0C,0x27,0x30,0x00,0x00,0x26,0xB8,0x14,0x00,0x26,0xB8,
+0x08,0x11,0x26,0xB0,0x14,0x10,0x27,0x30,0x0C,0x28,0x27,0xB0,0x02,0x46,0x45,0x30,
+0x04,0xB0,0x27,0xB0,0x00,0x0C,0x1E,0xC1,0x10,0x10,0x27,0xB0,0x02,0xE4,0x41,0x30,
+0x44,0x0C,0x18,0xA8,0x01,0x11,0x1A,0x80,0x01,0x0C,0xD2,0x33,0x80,0xFF,0x14,0xB8,
+0x83,0x0E,0x14,0xA8,0xB1,0x00,0x5E,0xA9,0x00,0x11,0xD0,0x8B,0x80,0xE8,0xD1,0x2B,
+0x08,0x12,0x80,0xB0,0x01,0x0A,0x90,0x30,0x07,0x0C,0x18,0x18,0x30,0x12,0x14,0x08,
+0xFF,0x0A,0x96,0x08,0x1C,0x11,0x6E,0x80,0x02,0x08,0xCD,0x33,0x00,0x0C,0x0E,0x5C,
+0x02,0xCC,0x41,0x30,0x02,0xE6,0x79,0xB2,0x02,0xE8,0x7D,0xB2,0x00,0x0C,0x2E,0x58,
+0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,0xFF,0xFF,0xB0,0xBB,0x01,0x11,0x1A,0x80,
+0xCC,0x11,0x22,0x5E,0x00,0x0C,0x28,0x5E,0xFF,0xCD,0xF3,0x60,0x00,0x0C,0x2A,0xC0,
+0x02,0xD0,0x41,0xB0,0x02,0x0C,0x19,0xB0,0x80,0x00,0x14,0xB8,0xB1,0x00,0x64,0xAF,
+0x80,0x0B,0x66,0xE9,0x80,0x00,0xFC,0x3A,0x00,0x0C,0x68,0x41,0x02,0x0C,0xFD,0x32,
+0x08,0x10,0x81,0xB0,0x08,0x18,0x97,0x80,0x01,0x7E,0x91,0xB0,0x1C,0x11,0x6E,0x80,
+0x00,0x0C,0x2E,0x58,0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,0x08,0x40,0x20,0xB2,
+0x08,0x50,0x81,0x30,0xFF,0x58,0x97,0x08,0x01,0x7E,0x91,0xB0,0x1C,0x11,0x6E,0x80,
+0x00,0x0C,0x2E,0x58,0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,0x08,0x40,0xA0,0x32,
+0x02,0x7E,0x15,0xB0,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,
+0x83,0x0C,0x19,0x2A,0x02,0x0C,0x15,0xB0,0x89,0x10,0x5A,0x29,0xFF,0xFF,0xB0,0xBB,
+0x01,0x11,0x1A,0x80,0xD0,0x11,0x22,0xDE,0x00,0x11,0x2A,0xDE,0x00,0x0C,0x2A,0xC0,
+0x01,0x11,0x6A,0x00,0x02,0x11,0x4A,0x80,0x08,0xE0,0x81,0xB0,0x00,0x11,0x4A,0x88,
+0x80,0x11,0x90,0x00,0x03,0x40,0x14,0x88,0xFC,0x40,0x80,0x08,0x44,0x0A,0x14,0xA8,
+0x08,0x0A,0x96,0x00,0x1C,0x11,0x6E,0x80,0x01,0x00,0x14,0xB8,0x83,0x30,0x60,0x28,
+0x05,0x11,0x48,0x80,0xD6,0x01,0x18,0x38,0xFF,0xD7,0xC3,0x61,0xDA,0x01,0x18,0x38,
+0xFF,0xDB,0xE1,0xF1,0x02,0x0C,0x1C,0xB0,0x02,0x12,0x40,0xB0,0x02,0x00,0x27,0x30,
+0xFF,0x0A,0xE3,0xE1,0xFF,0x0C,0x18,0x98,0xFF,0x12,0xD0,0xE1,0xFF,0xFF,0x26,0xB8,
+0x04,0x11,0x48,0x00,0x00,0x0C,0x2E,0x58,0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,
+0x80,0x80,0x00,0x32,0x80,0xE1,0xC3,0x03,0x00,0x0C,0xE4,0xD9,0x00,0x0C,0x2A,0xC0,
+0x14,0x11,0x2A,0x00,0x1F,0x11,0x2A,0x80,0x02,0x11,0x4A,0x80,0x08,0x00,0xC1,0xB3,
+0x00,0x11,0x4A,0x88,0xC0,0x0A,0x15,0x88,0xFF,0x0A,0x06,0x7A,0x40,0x0A,0x40,0xF2,
+0x80,0x0A,0x5E,0xF2,0x01,0x0A,0x15,0xB0,0xC0,0x0A,0x7E,0xF2,0xC1,0x0A,0x04,0xF2,
+0xC2,0x0A,0x04,0xF2,0xC3,0x0A,0xA6,0xF2,0xC4,0x0A,0x02,0xF2,0xC5,0x0A,0x68,0xF5,
+0x00,0x0C,0x04,0x42,0xA1,0x00,0x82,0x2B,0x15,0x11,0x2A,0x80,0x03,0x0A,0x31,0x72,
+0x04,0x0A,0x33,0x72,0xB1,0x00,0xB6,0xA9,0xB1,0x00,0xBE,0xA8,0x00,0x0C,0x28,0xCE,
+0x02,0x46,0x45,0x30,0x02,0x9D,0x1B,0x7A,0x4C,0x9D,0x15,0x28,0x00,0x11,0x23,0x82,
+0x02,0xAE,0x45,0x30,0x01,0x00,0x14,0xB8,0x83,0xAC,0x59,0x2B,0x02,0xA0,0xAD,0xB3,
+0x02,0x20,0x40,0x33,0xFF,0xFF,0x04,0x3A,0xFF,0xD7,0x2F,0x72,0x02,0x20,0xA8,0x33,
+0x02,0xD6,0x41,0xB0,0x02,0xD4,0x05,0xB2,0x02,0xD4,0x41,0xB4,0xC1,0x11,0x20,0x46,
+0xA1,0x00,0x48,0x2B,0x04,0x48,0x0B,0x7A,0xB1,0x00,0x8C,0xAF,0x00,0x0C,0x2A,0x4E,
+0x02,0x20,0x0C,0xB0,0xB1,0x00,0x9E,0xAF,0x02,0x06,0x40,0xB0,0x00,0x0C,0x0A,0xC2,
+0xB1,0x00,0xB6,0xA9,0xB1,0x00,0xBE,0xA8,0x00,0x04,0x18,0xB8,0xB1,0x00,0x80,0xA9,
+0xFF,0xFF,0x08,0x3A,0xB1,0x00,0x78,0x2F,0x02,0xA2,0xAD,0x33,0x02,0x20,0x44,0xB3,
+0xFF,0xD7,0x59,0xF2,0x02,0x20,0xA8,0x33,0x02,0xD6,0x41,0xB0,0x02,0xD4,0x09,0x36,
+0xFF,0x8E,0x5D,0x6A,0xC9,0x11,0x20,0xC6,0x02,0x20,0x18,0x37,0x02,0x20,0x0C,0xB0,
+0x44,0x0B,0x15,0xA8,0x00,0x0B,0x01,0x80,0x02,0x06,0x40,0xB0,0xFF,0xFF,0x00,0xBA,
+0xFF,0xE5,0x73,0x62,0xFF,0xE7,0x75,0xE2,0x02,0x20,0xC8,0x33,0x02,0x20,0xCC,0xB3,
+0xA1,0x00,0xA4,0xA8,0xFF,0xE7,0x7D,0xF2,0x02,0xE6,0xA9,0xB3,0x02,0x20,0xCC,0xB3,
+0x02,0xD4,0x41,0x30,0x02,0xE6,0x01,0x36,0x1B,0x11,0x2A,0x00,0x07,0x11,0x48,0x00,
+0x00,0x11,0x08,0x0A,0x00,0x11,0x0A,0x8A,0x00,0x11,0x18,0x8A,0xFF,0xFF,0x04,0x3A,
+0xFF,0xFF,0x00,0xBA,0xFF,0xD1,0x95,0x62,0x02,0x20,0xA0,0xB3,0x02,0x20,0xA4,0x33,
+0x01,0x11,0xB0,0x83,0x00,0x0C,0x9C,0xC2,0x02,0x20,0x14,0xB0,0x02,0xD2,0x41,0x30,
+0x02,0x0A,0x04,0x32,0x02,0x0A,0xA4,0xB3,0x06,0x11,0x48,0x80,0x01,0xC7,0x15,0x30,
+0x04,0x11,0x48,0x00,0x01,0x0A,0x2E,0xEE,0x00,0x0C,0xEC,0x42,0xD1,0x11,0x20,0xC6,
+0xC0,0x01,0x18,0xB8,0x01,0xD6,0x15,0x30,0x00,0x0C,0x18,0x98,0x01,0x12,0x00,0x30,
+0xC8,0x01,0x18,0x38,0x0F,0x00,0x14,0x08,0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,
+0xFF,0x12,0xFA,0x7A,0xFF,0x0C,0x18,0x98,0x02,0x0C,0x0C,0x30,0x02,0x0E,0x0C,0xB0,
+0xB1,0x00,0x80,0x28,0xFF,0x0E,0xCA,0xFA,0xFF,0xD1,0xC1,0xE2,0x04,0x06,0x22,0x30,
+0x00,0x0C,0xF6,0xC2,0x01,0x0C,0xC0,0x33,0x02,0x06,0x1C,0xB0,0x02,0x06,0x18,0x30,
+0xFF,0xFF,0x14,0x38,0x83,0xD4,0xA9,0x2B,0xFF,0x12,0x26,0x18,0x01,0xD6,0xAD,0x1B,
+0x07,0xD6,0xAD,0x8B,0xFF,0x0C,0x18,0x98,0xFF,0x12,0xE8,0x7A,0xC0,0x01,0x1C,0x38,
+0x01,0xD7,0x15,0xB0,0x00,0x0E,0x1C,0x98,0x01,0x00,0x26,0xB0,0x07,0x0E,0xAE,0x8B,
+0x04,0x11,0x48,0x00,0x00,0xE0,0x27,0xDE,0x02,0x05,0x0A,0x00,0x07,0x11,0x48,0x00,
+0x00,0x00,0x14,0x38,0x8A,0xD4,0xF7,0x2A,0xFF,0xD1,0xA9,0x62,0x04,0x11,0x48,0x00,
+0x88,0x11,0x00,0x04,0x25,0x11,0x2A,0x80,0xC0,0x11,0x0C,0x5B,0x00,0x0C,0x2E,0xCE,
+0x00,0x11,0x26,0xDE,0x88,0x11,0x00,0x04,0xC8,0x11,0x0C,0xDB,0x00,0x0C,0x2E,0xCE,
+0x01,0x11,0x26,0x5E,0x88,0x11,0x00,0x04,0xFF,0xFF,0xB0,0xBB,0x01,0x11,0x1A,0x80,
+0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x18,0x02,0x0C,0x0C,0x30,0xB1,0x00,0x78,0x2F,
+0x01,0x9D,0x29,0x7B,0x20,0x0B,0x2B,0xFB,0x02,0x9E,0x2B,0xFB,0x04,0x4C,0x2B,0x6B,
+0x04,0x49,0x2B,0x6B,0x20,0x9D,0x53,0x6B,0xB1,0x00,0x38,0xAF,0x00,0x0C,0x52,0x4B,
+0x40,0x9E,0x53,0x6B,0x01,0x9C,0x15,0xB0,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,
+0x00,0xAF,0x15,0x88,0x02,0x06,0x44,0x30,0xFF,0x0A,0x40,0xEB,0xB1,0x00,0x18,0x2A,
+0x00,0x0C,0x52,0x4B,0xB1,0x00,0x1C,0xAA,0x09,0x11,0x6E,0x03,0x00,0x0C,0x5A,0x43,
+0x09,0xB7,0x45,0x63,0xB1,0x00,0x22,0x2A,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,
+0x00,0xAE,0xC1,0x08,0x02,0x06,0x44,0x30,0x02,0x62,0x14,0xB0,0x01,0x0B,0x52,0xEB,
+0xFF,0x0A,0x6C,0xE3,0xBA,0x01,0x1C,0xB8,0xBF,0x01,0x18,0x38,0xB0,0x00,0xF0,0x2D,
+0x00,0x0C,0x64,0x4B,0x02,0x06,0x18,0x30,0xFF,0x01,0x6B,0x73,0x02,0x20,0xB0,0x33,
+0x02,0x00,0x41,0x30,0x00,0x0C,0x14,0x43,0x02,0x06,0x18,0x30,0xB1,0x00,0x28,0x2A,
+0xFF,0x21,0x14,0xE3,0x01,0x10,0x22,0x1C,0x02,0x06,0x18,0x30,0x02,0x20,0xA8,0x33,
+0x01,0x0A,0x00,0x30,0x02,0xD4,0x41,0x30,0x00,0x0C,0x22,0x5E,0x04,0x4C,0x87,0xFB,
+0xFF,0x03,0x87,0x73,0x02,0x20,0xA8,0x33,0x02,0x02,0x41,0xB0,0x01,0x0C,0x18,0x18,
+0x00,0x0C,0x20,0xDE,0x02,0xD4,0x41,0x30,0xFF,0xFF,0x04,0x3A,0x01,0x11,0x22,0x9C,
+0x00,0x11,0x00,0x08,0x03,0x11,0x14,0x80,0x28,0x00,0x18,0x38,0xFF,0xE5,0xB1,0xF3,
+0x02,0xE4,0x41,0x30,0xFF,0xFF,0xC8,0xBB,0x01,0x00,0x0E,0xB0,0xFF,0x07,0x14,0x90,
+0x00,0xDC,0xB9,0x0B,0x06,0x11,0x48,0x80,0x02,0x0A,0x98,0xB3,0x02,0x0C,0x9C,0x33,
+0x04,0x11,0x48,0x00,0x06,0x11,0x26,0xDE,0x06,0x11,0x48,0x80,0x02,0xCC,0x15,0xB0,
+0x02,0xCE,0x19,0x30,0x04,0x11,0x48,0x00,0x02,0x05,0x0A,0x00,0xFF,0xDC,0x2F,0xFE,
+0x11,0x00,0x00,0x98,0x88,0x00,0x2E,0x76,0x02,0x0A,0x14,0x28,0x44,0x00,0x8E,0xE3,
+0x01,0x0C,0x18,0x18,0x00,0x0C,0x8E,0x43,0x02,0x34,0xA8,0x33,0x02,0x36,0x40,0xB0,
+0xF8,0xD4,0x15,0x08,0xC0,0x0A,0xF6,0x73,0xED,0xFF,0x14,0x38,0x83,0xD4,0x15,0xA8,
+0x80,0x0B,0xF4,0x7B,0xE7,0x01,0x14,0xB8,0x83,0xD4,0x0D,0x2C,0x00,0x0C,0xD2,0xC4,
+0x00,0x0C,0xD6,0x44,0x00,0x0C,0xE0,0x44,0x00,0x0C,0xF6,0xC4,0x00,0x0C,0x1E,0xC4,
+0x00,0x0C,0x7C,0x44,0x00,0x0C,0x2C,0xC5,0x00,0x0C,0x36,0xC4,0x00,0x0C,0xAC,0xC4,
+0x00,0x0C,0x18,0xC4,0x00,0x0C,0x78,0xC4,0x00,0x0C,0xDA,0x44,0x00,0x0C,0xDA,0x44,
+0x00,0x0C,0x0C,0x45,0x00,0x0C,0xA2,0x44,0x00,0x0C,0x1E,0x45,0x00,0x0C,0x28,0x45,
+0x00,0x0C,0x30,0x45,0x00,0x0C,0x28,0x46,0x16,0x11,0x2A,0x80,0x07,0xD4,0x0F,0xFC,
+0x01,0x05,0xAD,0xB3,0x07,0xD4,0x0B,0x8A,0x44,0x05,0x1D,0xA8,0x01,0x11,0x1E,0x00,
+0x00,0x11,0x26,0x88,0xFF,0x04,0x0B,0x7C,0x44,0xD6,0x1D,0x28,0x01,0x11,0x1E,0x00,
+0x01,0x05,0x27,0xB4,0x01,0x05,0x09,0xB2,0xC5,0x11,0x20,0xC6,0x01,0x0C,0x19,0x1A,
+0x01,0x0C,0x15,0xB0,0x00,0x0B,0x2F,0xE6,0xB1,0x00,0x9A,0xA8,0xA1,0x00,0xAA,0x28,
+0xFF,0xFF,0x04,0x3A,0x00,0x0C,0xA2,0x5C,0xA1,0x00,0x9A,0xA9,0x00,0x0C,0xA2,0x5C,
+0x02,0x02,0xAD,0x33,0xFF,0xFF,0x04,0x3A,0x02,0x20,0x0C,0xB0,0xB1,0x00,0x78,0x2F,
+0x02,0xD6,0x41,0xB0,0xFF,0x21,0x30,0x64,0xFF,0xFF,0x40,0xBB,0x00,0x0C,0x32,0x44,
+0xC1,0x11,0x20,0x5E,0x02,0x06,0x40,0xB0,0xA1,0x00,0x9A,0xA9,0x02,0x06,0xB1,0x33,
+0xFF,0xFF,0x0C,0xBA,0x04,0x4C,0x47,0xEC,0x80,0x48,0x43,0xEC,0x00,0x0C,0x44,0xDA,
+0x00,0x0C,0x72,0xC4,0xB1,0x00,0xC4,0xA9,0x00,0x0C,0x72,0xC4,0xB1,0x00,0x78,0x2F,
+0xFF,0xA1,0x4F,0x64,0xC1,0x11,0x20,0x5E,0x00,0x0C,0x72,0xC4,0x02,0x20,0xA8,0x33,
+0xC0,0x01,0x18,0xB8,0xB1,0x00,0x00,0xAB,0xFF,0x21,0x58,0xE4,0x23,0x11,0x2A,0x80,
+0x02,0x20,0x14,0xB0,0xFF,0xD7,0x63,0xF4,0x02,0xD6,0x41,0xB0,0x02,0xD4,0x01,0x32,
+0x00,0x0C,0x64,0x44,0x02,0xD4,0x81,0x33,0x02,0x0A,0x40,0xB0,0x02,0x00,0xAD,0xB3,
+0x02,0xD4,0x41,0x30,0x02,0x0A,0x04,0x32,0x02,0xD6,0x01,0xB2,0xFF,0xD7,0x73,0xE4,
+0x02,0x20,0x84,0xB3,0x02,0xD8,0x41,0x30,0xFF,0x21,0x36,0x64,0xFF,0x11,0x22,0x8C,
+0x00,0x0C,0x94,0x5C,0xA1,0x00,0x9A,0xA9,0x00,0x0C,0x94,0x5C,0x02,0x04,0xAD,0x33,
+0xFF,0xFF,0x08,0x3A,0x02,0x20,0x0C,0xB0,0xB1,0x00,0x78,0x2F,0x02,0xD6,0x41,0xB0,
+0xFF,0x21,0x8E,0x64,0xFF,0xFF,0x44,0x3B,0x00,0x0C,0x90,0xC4,0xC9,0x11,0x20,0xDE,
+0x02,0x06,0x40,0xB0,0xA1,0x00,0x9A,0xA9,0x80,0x48,0xA1,0xEC,0xFF,0x4D,0xA3,0xEC,
+0x04,0x49,0xA3,0x7C,0x02,0x20,0xB0,0x33,0x00,0x0C,0x48,0xDA,0x02,0xD8,0x41,0xB4,
+0xA1,0x00,0xC4,0x29,0xB1,0x00,0xC4,0xA9,0x20,0x48,0x19,0x6D,0x80,0x48,0x2F,0x6E,
+0x01,0x49,0x2F,0x7E,0xA1,0x00,0x00,0x28,0x07,0x11,0x48,0x00,0x02,0x20,0xB4,0xB3,
+0x84,0x80,0x14,0xB8,0x88,0xDA,0xB7,0xAC,0x00,0x0C,0x08,0xDE,0xFF,0xD1,0xBD,0x64,
+0x00,0x0C,0x0C,0x58,0xFF,0xD1,0xB9,0x74,0xB1,0x00,0x80,0x28,0xFF,0x0E,0xB6,0xEC,
+0x44,0x0C,0x1C,0x28,0x02,0x0E,0x1C,0x18,0x01,0x11,0x1E,0xA0,0x0F,0x00,0x14,0x08,
+0x08,0x0A,0x26,0x80,0x02,0xDA,0x27,0xB0,0x04,0x11,0x48,0x00,0x01,0x0C,0xA8,0xB3,
+0x00,0x0C,0xF8,0xC3,0xC0,0x11,0x24,0x5E,0xA1,0x00,0x9A,0xA9,0xC8,0x11,0x24,0xDE,
+0xA1,0x00,0x9A,0xA9,0xB1,0x00,0x34,0x2B,0x00,0x0C,0x2E,0xCE,0xA1,0x00,0x00,0x28,
+0x02,0x20,0x0C,0xB0,0xB1,0x00,0xD4,0x29,0x00,0x0C,0xF0,0x54,0x00,0x4D,0x11,0x5D,
+0x02,0x02,0x41,0xB0,0xFF,0x21,0xF0,0x64,0xFF,0xFF,0x40,0xBB,0x00,0x0C,0xF2,0x44,
+0xC1,0x11,0x20,0x5E,0x02,0x06,0x40,0xB0,0xA1,0x00,0x9A,0xA9,0x02,0x20,0x0C,0xB0,
+0xB1,0x00,0xD4,0x29,0x00,0x0C,0x06,0xD5,0x00,0x4D,0x11,0x5D,0x02,0x04,0x41,0xB0,
+0xFF,0x21,0x06,0xE5,0xFF,0xFF,0x44,0x3B,0x00,0x0C,0x08,0xC5,0xC9,0x11,0x20,0xDE,
+0x02,0x06,0x40,0xB0,0xA1,0x00,0x9A,0xA9,0xB1,0x00,0x78,0x2F,0x01,0x4D,0x19,0xB0,
+0xB1,0x00,0xC4,0xA9,0x20,0x48,0x19,0x6D,0x80,0x48,0x2F,0x6E,0xA1,0x00,0x96,0xAA,
+0xFF,0x45,0x1D,0x65,0x1B,0x11,0x16,0xC5,0x23,0x11,0x16,0x45,0x02,0x00,0xC9,0x33,
+0x00,0x0C,0x28,0x5D,0xFF,0xE5,0x27,0x65,0xFF,0xFF,0xCC,0xBF,0xA1,0x00,0xA4,0xA8,
+0x0A,0x4D,0x29,0x66,0xCD,0x11,0x20,0x46,0x02,0x20,0xC8,0x33,0xA1,0x00,0xA4,0xA8,
+0x07,0x11,0x48,0x00,0x02,0x38,0x40,0x7D,0xFF,0xD1,0x41,0x75,0xB1,0x00,0x80,0x28,
+0xFF,0x0E,0x34,0x6D,0x01,0x0C,0x60,0x30,0x02,0x20,0x64,0x30,0x00,0x0C,0x64,0xC5,
+0x01,0x00,0x14,0xB8,0x83,0xD4,0xA9,0x2B,0xC8,0x01,0x18,0x38,0x0F,0x00,0x14,0x08,
+0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,0x01,0x12,0x14,0x30,0xFF,0x0A,0x5E,0xED,
+0x01,0x11,0x26,0x80,0xC0,0x01,0x1C,0x38,0x01,0xD7,0x15,0xB0,0x00,0x0E,0x1C,0x98,
+0x01,0x00,0x26,0xB0,0x07,0x0E,0xAE,0x8B,0x00,0x0C,0x64,0xC5,0x01,0x0A,0x14,0x18,
+0x00,0x0C,0x66,0xCD,0x01,0x0A,0x26,0xB0,0x04,0x11,0x48,0x84,0x24,0x11,0x2A,0x00,
+0x00,0x00,0x44,0x38,0x00,0x0C,0x94,0xDD,0x01,0x0B,0x15,0x30,0x10,0x01,0x18,0x38,
+0x02,0x12,0x44,0x30,0x02,0x22,0xA8,0xB3,0xFF,0xFF,0x5C,0x3B,0x00,0x00,0x44,0x38,
+0xFF,0x81,0x7F,0x65,0x02,0xD4,0x01,0xB3,0x00,0x0C,0x84,0x45,0x02,0x82,0x45,0xB0,
+0x02,0xD4,0x5D,0xB3,0x00,0x00,0x44,0x38,0x02,0xD4,0x05,0x33,0xFF,0x0A,0x14,0x98,
+0xFF,0x0A,0x70,0xED,0x01,0x0B,0x15,0x30,0x00,0x11,0x16,0x88,0x83,0x84,0x09,0x2B,
+0x00,0x0C,0xB4,0x5D,0x00,0x11,0x2A,0xC6,0x02,0x8A,0x15,0x30,0xFF,0x0A,0x94,0xED,
+0xFF,0x11,0x04,0x00,0x01,0x0B,0x06,0xB0,0xE0,0x8A,0xA1,0x2D,0xFF,0x11,0x22,0x8C,
+0x02,0x8A,0x15,0x33,0x00,0x0C,0x94,0xC5,0x02,0x8A,0x15,0x30,0xFF,0x0B,0xA4,0x6D,
+0x01,0x0A,0x04,0xB0,0xFF,0x11,0x06,0x80,0xE0,0x8A,0xB1,0xAD,0xFF,0x11,0x22,0x8C,
+0x02,0x8A,0x15,0x33,0x00,0x0C,0xA4,0xC5,0x02,0x8A,0x15,0x30,0x00,0x11,0x04,0x88,
+0x01,0x0B,0x06,0xB0,0xE0,0x8A,0xBF,0x2D,0xFF,0x11,0x22,0x8C,0x02,0x8A,0x15,0x33,
+0x00,0x0C,0xB4,0x45,0x02,0x8A,0x15,0x30,0x01,0x0A,0x04,0xB0,0x00,0x11,0x06,0x08,
+0xE0,0x8A,0xCD,0x2D,0xFF,0x11,0x22,0x8C,0x02,0x8A,0x15,0x33,0x00,0x0C,0xC2,0xC5,
+0x02,0x12,0x14,0x30,0x8B,0x10,0x30,0x2E,0x00,0x0C,0xDA,0xDD,0x04,0x64,0x26,0x30,
+0x01,0x10,0x22,0x1C,0x07,0x11,0x48,0x00,0x04,0x11,0xB8,0x33,0x02,0x0A,0xBA,0xB3,
+0x00,0x0C,0xE8,0x5D,0x00,0x0C,0xE8,0x5D,0x04,0xDC,0xC9,0xB0,0x04,0x11,0x48,0x84,
+0x02,0xDC,0x15,0x30,0x83,0xDC,0xB9,0x2B,0x02,0xDE,0x15,0xB0,0x84,0xDE,0xBD,0x2F,
+0x11,0x12,0x22,0xA8,0x00,0x0C,0x2E,0xD6,0x02,0x0C,0x0C,0x30,0x02,0x0E,0x18,0xB0,
+0x02,0x12,0x14,0x30,0x00,0x0C,0xDA,0xDD,0x02,0x06,0x18,0x30,0xFC,0x0C,0x18,0x98,
+0x04,0x12,0xC8,0xB0,0xFF,0x11,0x22,0x20,0x11,0x67,0x22,0xAC,0x11,0x12,0x22,0x2C,
+0xB1,0x00,0x4E,0x29,0x0F,0x00,0x18,0x08,0x00,0x11,0x02,0x88,0x01,0x00,0x0E,0xB0,
+0x00,0x07,0x1A,0xFE,0x02,0x38,0x12,0xFE,0x02,0x00,0x60,0xB8,0x01,0x0C,0x64,0xB0,
+0x00,0x11,0x66,0x08,0x11,0x00,0x00,0x98,0x88,0x00,0x0E,0x66,0x01,0x01,0x22,0x34,
+0xA1,0x00,0x2C,0xA8,0xA1,0x00,0x46,0xA8,0xA1,0x00,0x60,0x28,0xA1,0x00,0x6C,0x28,
+0xA1,0x00,0xC4,0x2A,0xA1,0x00,0xBE,0xAA,0xA1,0x00,0x7A,0x29,0xFF,0x11,0x22,0x8C,
+0x01,0x11,0x22,0x9C,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0xFF,0x4B,0xD3,0x69,0x01,0x4C,0x1B,0xF8,0xFF,0x4D,0x1F,0xE8,0x03,0x48,0x1F,0x78,
+0x40,0x49,0x15,0xE8,0x80,0x48,0x11,0x78,0xFF,0xFE,0x18,0xB8,0x00,0x0C,0x9E,0x41,
+0x04,0x0C,0x79,0x32,0x01,0x11,0x1C,0x40,0x20,0x49,0x1B,0xF8,0x04,0x11,0x78,0xB2,
+0x02,0x11,0x1C,0x40,0x00,0x11,0x1C,0xC0,0x00,0x0C,0x8C,0x59,0x80,0x4C,0xC5,0x7A,
+0x21,0x1F,0x27,0xE8,0x40,0x48,0xC5,0xFA,0x0B,0x11,0x28,0xC0,0x0C,0x11,0x28,0x40,
+0x00,0x0C,0x8C,0x59,0xCD,0x11,0x2C,0x40,0x01,0x11,0x1A,0x80,0xFF,0xFF,0x00,0xBA,
+0xFF,0x12,0x3A,0xE0,0x01,0x11,0x1E,0x00,0xFE,0x0C,0x1C,0x98,0x02,0x20,0x26,0x30,
+0x02,0x20,0x26,0xB4,0x02,0x0C,0x1C,0xB0,0x02,0x20,0x14,0xB0,0x02,0x12,0x40,0xB0,
+0x02,0x0A,0x00,0xB2,0x02,0x0A,0x26,0xB0,0x02,0x0A,0x40,0x34,0x02,0x0C,0x1C,0xB0,
+0xFF,0xD9,0x51,0xE0,0x02,0x00,0x27,0x30,0xFF,0x01,0xD3,0x61,0xFF,0xFF,0x26,0x3C,
+0x02,0x20,0xA8,0x33,0x02,0x00,0xAD,0xB3,0x02,0xD8,0x41,0x30,0x02,0xD6,0x01,0xB2,
+0x02,0xD4,0x41,0x30,0xFF,0x01,0xD3,0x61,0x02,0x0C,0x1C,0x98,0x02,0xD8,0x27,0xB4,
+0x01,0x11,0x1A,0x80,0x02,0x0C,0x1C,0xB0,0x02,0x12,0x00,0xB2,0x02,0x20,0x26,0x30,
+0xFF,0x01,0xD3,0x61,0x02,0x20,0x26,0xB4,0x02,0x0C,0xC0,0x33,0x02,0x20,0xC4,0x33,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0x02,0x38,0x7A,0xE8,0xFD,0x05,0x0A,0x88,
+0x00,0x0C,0x72,0x40,0x01,0xE0,0x61,0x30,0x02,0xE2,0x65,0x30,0xFD,0x05,0x0A,0x0C,
+0x02,0xD0,0x41,0xB0,0x44,0xD8,0x19,0x28,0x0F,0x0C,0x18,0x98,0x01,0x11,0x1A,0x20,
+0xC0,0x12,0x1C,0x88,0xC0,0xD8,0x19,0x00,0x01,0xD8,0xB1,0x1B,0x07,0xD8,0xD3,0xE9,
+0x02,0x02,0xA1,0x33,0xFF,0xFF,0x04,0x3A,0xFF,0xD1,0x99,0xE0,0xFF,0xFF,0xA4,0xBB,
+0x01,0x11,0xB0,0x07,0x07,0x11,0x48,0x00,0x02,0xD0,0x15,0x30,0x88,0x20,0xA2,0xA8,
+0x00,0x0C,0x90,0x58,0x04,0x11,0x48,0x84,0x01,0x00,0x0E,0xB0,0x01,0x07,0x14,0xB0,
+0x00,0xDC,0xB9,0x07,0xFF,0x11,0x14,0x02,0xFF,0xFF,0x10,0x3A,0xFF,0xFF,0x8C,0x3A,
+0x05,0x11,0x48,0x80,0x01,0xD5,0x15,0x30,0x00,0x21,0xB8,0x68,0xD7,0x11,0xBA,0xC0,
+0xDB,0x11,0xBA,0xC0,0x00,0x0C,0x2C,0xD8,0x04,0x11,0x48,0x84,0xC0,0x0A,0x15,0x88,
+0x40,0x0A,0x04,0xF1,0x01,0x0A,0x15,0xB0,0x00,0x11,0x16,0x88,0xF1,0xFF,0x18,0xB8,
+0x83,0x0C,0x18,0x28,0x80,0x0D,0xCE,0xE8,0xA0,0x00,0x04,0xAA,0x69,0x04,0x18,0xB8,
+0x83,0x0C,0x0C,0xAC,0x00,0x0C,0xFE,0xC0,0x00,0x0C,0xFE,0xC0,0x00,0x0C,0xFE,0xC0,
+0x00,0x0C,0xF2,0xC0,0x00,0x0C,0xFE,0xC0,0x00,0x0C,0x04,0x41,0x00,0x0C,0x04,0x41,
+0x00,0x0C,0x04,0x41,0x00,0x0C,0xF2,0xC0,0x00,0x0C,0x0A,0xC1,0x00,0x0C,0x0A,0xC1,
+0x00,0x0C,0x3E,0x41,0x00,0x0C,0x3E,0x41,0xA0,0x00,0x04,0xAA,0xA0,0x00,0x04,0xAA,
+0x00,0x0C,0x3E,0x41,0xFF,0xFF,0x14,0x38,0x88,0x34,0xFB,0xA8,0x00,0x0C,0xFC,0x5E,
+0x00,0x0C,0xD2,0x49,0x00,0x0C,0xCE,0xDE,0x00,0x0C,0xD2,0x49,0x01,0x21,0x40,0x32,
+0x01,0x20,0x42,0x32,0x00,0x0C,0x3E,0x41,0x01,0x21,0x44,0xB2,0x01,0x20,0x46,0xB2,
+0x00,0x0C,0x3E,0x41,0x08,0x48,0x3F,0xF9,0x02,0x46,0x45,0x30,0x00,0x11,0xA8,0x8B,
+0x01,0x11,0xAC,0x03,0xA8,0x01,0x18,0x38,0x01,0x12,0xB0,0xB3,0x01,0xD6,0x15,0x30,
+0x00,0xD8,0x29,0x69,0x01,0xD6,0xAD,0x2B,0x01,0xD4,0xA9,0x1B,0x01,0xB4,0x15,0xB0,
+0x00,0xD4,0x25,0xE1,0x18,0x11,0x2A,0x00,0x01,0xD6,0x17,0x61,0x00,0x0C,0x14,0xC1,
+0x02,0x0C,0x1C,0xB0,0xFF,0x0E,0x1C,0x98,0x00,0xD8,0x27,0x10,0x01,0xD4,0x15,0xB0,
+0x00,0x0A,0x14,0x98,0x80,0x01,0x1C,0xB8,0x00,0x0E,0x1C,0x98,0x02,0xA4,0x45,0x30,
+0x02,0x20,0x26,0x30,0x33,0xD4,0x15,0x28,0x00,0x1C,0x39,0x82,0x01,0x11,0x22,0x9C,
+0x02,0x06,0x40,0xB0,0x00,0x0C,0x8C,0x59,0x01,0x10,0x22,0x1C,0x00,0x00,0x14,0x38,
+0x88,0x12,0x46,0x2B,0x88,0x12,0x46,0x2B,0x01,0x11,0x22,0x9C,0x02,0x22,0x0C,0x30,
+0x00,0x00,0x44,0x38,0xB8,0x01,0x18,0xB8,0x0F,0x00,0x14,0x08,0x00,0x0C,0x18,0x98,
+0x01,0x12,0x14,0x30,0x02,0x06,0x44,0x30,0xFF,0x11,0x22,0x8C,0x02,0x0C,0x0C,0x30,
+0x08,0x0C,0x18,0x18,0x02,0x12,0x1C,0xB0,0x02,0x0A,0x0C,0x30,0x82,0x10,0x14,0x28,
+0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,0x83,0x0E,0x1C,0x28,0x02,0x06,0x14,0x30,
+0x80,0x0F,0x76,0x79,0xFE,0x0C,0x18,0x18,0x02,0x12,0x14,0x30,0x02,0x06,0x18,0x30,
+0xFF,0x11,0x22,0x8C,0x01,0x0C,0x1A,0xB0,0x00,0x11,0x80,0x41,0x00,0x11,0x1A,0x88,
+0x02,0x48,0x15,0xB0,0x80,0x0C,0x04,0xA8,0xE1,0x48,0x89,0xA9,0xFF,0x11,0x22,0x8C,
+0x02,0x48,0x91,0x32,0x00,0x0C,0x80,0x41,0x02,0x4C,0x15,0x30,0x01,0x0A,0x04,0x80,
+0x01,0x0C,0x06,0x30,0xE1,0x4C,0x97,0x29,0xFF,0x11,0x22,0x8C,0x02,0x4C,0x99,0x32,
+0x00,0x0C,0x8C,0x41,0x10,0x49,0xD3,0xF9,0xFF,0xEF,0x18,0xB8,0x02,0x48,0x15,0xB0,
+0x81,0x0C,0x04,0x28,0xE1,0x48,0xA7,0xA9,0xFF,0x11,0x22,0x8C,0x02,0x48,0x91,0x32,
+0x00,0x0C,0x9E,0x41,0x02,0x4C,0x15,0x30,0x81,0x0C,0x04,0x28,0xE1,0x4C,0xB3,0x29,
+0xFF,0x11,0x22,0x8C,0x02,0x4C,0x99,0x32,0x00,0x0C,0xAA,0xC1,0x02,0x4A,0x15,0x30,
+0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x98,0xE1,0x4A,0xC1,0x29,0xFF,0x11,0x22,0x8C,
+0x02,0x4A,0x95,0x32,0x00,0x0C,0xB6,0x41,0x02,0x4A,0x15,0x30,0x01,0x0A,0x04,0xB0,
+0xFF,0x0B,0x06,0x18,0xE1,0x4A,0xCF,0xA9,0xFF,0x11,0x22,0x8C,0x02,0x4A,0x95,0x32,
+0x00,0x0C,0xC4,0x41,0xFF,0x11,0x22,0x8C,0x00,0x0C,0x78,0xDF,0x03,0x4D,0x0B,0x72,
+0x09,0x4D,0x0B,0x72,0x12,0x4D,0x0B,0x72,0x04,0x4D,0xF1,0x61,0x26,0x4E,0xE5,0x61,
+0x00,0x11,0x9C,0x8A,0x00,0x0C,0x06,0xC2,0x04,0x9F,0xF3,0x69,0x4C,0x9F,0x15,0xA8,
+0x01,0x0A,0xEE,0x71,0x02,0x0A,0xEE,0x71,0x08,0x0A,0xF0,0xE1,0x00,0x0C,0x26,0x5A,
+0x01,0x10,0x22,0x1C,0xF0,0x9F,0x15,0x88,0xFF,0x0A,0x0A,0x7A,0x10,0x0A,0x10,0xF2,
+0x20,0x0A,0x06,0x72,0x30,0x0A,0x06,0xF2,0x40,0x0A,0x0A,0x72,0x50,0x0A,0x0A,0xF2,
+0x60,0x0A,0x10,0x72,0x70,0x0A,0x10,0xF2,0x80,0x0A,0x06,0x72,0x00,0x0C,0x22,0xDA,
+0x00,0x0C,0x12,0xC2,0x00,0x0C,0x18,0xDA,0x00,0x0C,0x10,0xCA,0x00,0x0C,0x1C,0x5A,
+0x01,0x4D,0x6F,0x33,0xFE,0x00,0x18,0xB8,0x00,0x0C,0xAA,0xD9,0x01,0x11,0x22,0x9C,
+0xBF,0x01,0x18,0x38,0xA0,0x00,0x06,0xAE,0xBA,0x01,0x18,0x38,0xBC,0x01,0x1C,0xB8,
+0xA0,0x00,0xD0,0x2D,0x03,0x9F,0x3F,0x0B,0x00,0x11,0x6E,0x8B,0x04,0x11,0x78,0xB7,
+0x02,0x0C,0x0C,0x30,0x02,0xD8,0x0D,0xB0,0x00,0x0C,0x46,0xD8,0x1B,0x11,0x14,0x80,
+0x00,0x0C,0x70,0x5A,0xC0,0x0C,0x36,0xF2,0xC0,0x11,0x42,0xC2,0xFF,0x8E,0x41,0x7A,
+0x02,0x8C,0x41,0xB0,0xFF,0x21,0x4E,0xF2,0xFF,0xFF,0x18,0x3B,0xC8,0x11,0x4A,0xC2,
+0xC8,0x11,0x42,0x42,0x00,0x0C,0x00,0x5B,0xFF,0x21,0x4E,0xF2,0x02,0xD6,0xB1,0xB3,
+0x00,0x0C,0x46,0xD8,0x1B,0x11,0x14,0x80,0x00,0x0C,0x70,0x5A,0x00,0x00,0x40,0xB8,
+0xFF,0xFF,0xD4,0x3B,0x00,0x0C,0x40,0xDE,0x00,0x0C,0x5C,0x52,0x00,0x0C,0x7E,0xDF,
+0x00,0x0C,0x5C,0x52,0x1B,0x11,0x6C,0xDC,0x00,0x0C,0x1A,0x5F,0x00,0x0C,0x52,0xD2,
+0x00,0x0C,0x64,0xDE,0x02,0x06,0xB0,0xB3,0x02,0x06,0x18,0x30,0xFF,0xD9,0x6D,0xF2,
+0x02,0xD8,0x41,0x30,0x02,0x00,0x41,0xB4,0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x9C,
+0x02,0x0C,0x0C,0x30,0x00,0x0C,0x8C,0x5A,0x02,0x0A,0x0C,0x30,0x00,0x0A,0x96,0xDA,
+0x02,0x06,0x14,0x30,0x02,0xD4,0x19,0xB0,0x02,0x12,0x0C,0x30,0x02,0xD4,0x1D,0x30,
+0xFF,0xFF,0x26,0xB8,0x02,0x06,0x40,0xB0,0xFF,0x21,0x74,0x62,0x02,0x06,0x18,0x30,
+0x02,0xDA,0x1D,0xB0,0xFF,0xFF,0x26,0x3C,0xC0,0x0C,0x92,0xE2,0x02,0x01,0xA8,0xBB,
+0xA0,0x01,0xB4,0x3F,0x04,0x01,0xA8,0xBB,0xA2,0x01,0xB4,0xBF,0x04,0x0C,0xA0,0x72,
+0x1B,0x0C,0xAA,0x62,0x01,0xB7,0x15,0xB0,0x01,0x0A,0x78,0xB2,0x04,0x0A,0xA4,0x62,
+0x00,0x0C,0xF6,0xDA,0x00,0x0C,0xBE,0xC2,0x03,0x0A,0xBE,0x62,0x01,0x9E,0x7B,0x8A,
+0x00,0x0C,0xBE,0xC2,0x23,0x0C,0xAE,0xF2,0x13,0x0C,0xBE,0xE2,0x02,0x20,0x78,0x32,
+0x88,0x11,0x02,0x00,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x02,0x52,0x15,0x30,
+0x02,0x06,0x40,0xB0,0x01,0x01,0x22,0xB0,0x02,0x0A,0x7C,0x32,0x00,0x0C,0x34,0xDB,
+0x00,0x0C,0xD2,0x49,0x00,0x0C,0x8C,0x59,0x00,0x0C,0x44,0x5E,0x00,0x0C,0xF4,0xD2,
+0x00,0x0C,0x78,0xDF,0xFF,0xFF,0x14,0x38,0x83,0xAC,0x59,0x2B,0x20,0x48,0xF3,0xFA,
+0xFF,0x45,0xF3,0x72,0x02,0x20,0x0C,0xB0,0x02,0x44,0x41,0x30,0xFF,0xFF,0x14,0x38,
+0x83,0x4A,0x95,0x2A,0x02,0x20,0x14,0xB0,0x02,0x06,0x40,0xB0,0x02,0x20,0x0C,0xB0,
+0x02,0x0A,0x0C,0x30,0x00,0x0C,0x12,0x5B,0xC5,0x11,0x2C,0xD8,0x88,0x11,0x02,0x00,
+0x02,0x06,0x40,0xB0,0x00,0x0C,0xA0,0xDC,0x01,0x01,0x22,0xB0,0x02,0x06,0x40,0xB0,
+0xFF,0x11,0x22,0x8C,0x00,0x0C,0x12,0x5B,0xC5,0x11,0x2C,0xC0,0x0C,0x9F,0x7B,0x8A,
+0x2E,0x3D,0x7B,0xAA,0x04,0x9F,0xFF,0x6A,0x4C,0x9F,0x7D,0x2E,0xF0,0x9F,0x7D,0x0E,
+0xFF,0xFF,0xAC,0x3B,0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x18,0xFF,0x21,0xD2,0xF1,
+0x00,0x0C,0x7E,0xDF,0x00,0x0C,0xD2,0x49,0x02,0x20,0xAC,0xB3,0x02,0x00,0x41,0x30,
+0x00,0x0C,0x06,0x43,0x09,0x0A,0x17,0x73,0x0A,0x0A,0xD3,0xE1,0x08,0x48,0xD3,0x79,
+0xF8,0x1C,0x17,0x08,0x3D,0x0B,0x16,0x28,0x02,0x46,0x45,0x30,0xA8,0x01,0x18,0x38,
+0x3D,0x0B,0x14,0xA8,0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,0x44,0x0B,0x0E,0xA8,
+0x01,0x07,0x14,0xB0,0x00,0x12,0x32,0xEB,0xFF,0x0C,0x18,0x98,0x00,0x12,0x26,0x00,
+0x00,0x0C,0x78,0xC7,0x1A,0x11,0x2A,0x80,0x02,0x48,0x15,0xB0,0x01,0x0B,0x46,0xEB,
+0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x80,0xE1,0x48,0x41,0xAB,0x01,0x11,0x22,0x9C,
+0x02,0x48,0x91,0x32,0x00,0x0C,0x34,0xC3,0x01,0x11,0x22,0x9C,0x01,0x10,0x22,0x1C,
+0x02,0x20,0xD4,0xB3,0x01,0x0A,0xE1,0x33,0x10,0x0B,0x57,0x7B,0xFF,0xFF,0x14,0x38,
+0x8A,0x34,0x57,0x2B,0x00,0x0C,0x78,0x5D,0x00,0x0C,0xC4,0xCA,0x00,0x0C,0x78,0xDF,
+0xC0,0x11,0x8A,0xDD,0x00,0x0C,0x62,0x53,0x1E,0x11,0xBE,0xDA,0x02,0xEA,0x41,0xB0,
+0x00,0x11,0xBE,0xC2,0xFF,0x8E,0x6D,0x7B,0x02,0x8C,0x41,0xB0,0xFF,0x21,0x70,0xF3,
+0x00,0x0C,0xFE,0xDD,0x00,0x0C,0x6E,0xC3,0xC8,0x11,0x8A,0x5D,0x00,0x0C,0x78,0xCB,
+0x02,0xEA,0x41,0xB0,0x00,0x0C,0xFC,0x5E,0x00,0x0C,0xC4,0xCA,0x02,0x0A,0x40,0xB0,
+0x10,0x0B,0x81,0xFB,0x80,0x11,0x7E,0x59,0x02,0xEA,0x41,0xB0,0xA0,0x00,0x0A,0x2A,
+0x1D,0x11,0xBE,0xC2,0x02,0x20,0xD4,0xB3,0x01,0x0A,0xE1,0x33,0x01,0x0B,0x15,0x30,
+0xFF,0x0A,0x98,0x7B,0x01,0x0A,0x9A,0xF3,0x02,0x0A,0xB0,0x73,0x03,0x0A,0xE2,0x73,
+0x04,0x0A,0x1C,0xF4,0x05,0x0A,0x26,0x74,0x06,0x0A,0x22,0xF4,0xA0,0x00,0x04,0xAA,
+0xFF,0x11,0x28,0x02,0xC0,0x11,0xC0,0xDC,0xC8,0x11,0xC0,0x5C,0x00,0x00,0x40,0xB8,
+0x00,0x0C,0x40,0xDE,0x00,0x0C,0xAA,0xD3,0x00,0x0C,0x2E,0x5E,0x00,0x0C,0xAA,0xD3,
+0x23,0x11,0x6C,0x5C,0x00,0x0C,0x1A,0x5F,0x00,0x0C,0xA0,0xD3,0x00,0x0C,0x9C,0xC4,
+0x00,0x0C,0x8C,0x5F,0x00,0x0C,0xBE,0x4A,0x02,0x10,0xBB,0xFB,0xC0,0x11,0xEA,0x5C,
+0x02,0xEA,0x41,0xB0,0x04,0x10,0xC1,0x7B,0x00,0x0C,0xDC,0x5C,0x02,0xEA,0x41,0xB0,
+0x01,0x10,0xD5,0x7B,0x00,0x00,0x40,0xB8,0x00,0x0C,0x40,0xDE,0x00,0x0C,0xCE,0x53,
+0x00,0x0C,0x7E,0xDF,0x00,0x0C,0xCE,0x53,0x23,0x11,0x6C,0x5C,0x00,0x0C,0x1A,0x5F,
+0x00,0x0C,0xC4,0x53,0x02,0xEA,0x41,0xB0,0x80,0x10,0xDB,0xFB,0x00,0x0C,0x9E,0x5F,
+0x02,0xEA,0x41,0xB0,0x40,0x10,0xE1,0xFB,0x00,0x0C,0xAE,0x5F,0x02,0xEA,0x41,0xB0,
+0x00,0x0C,0x9C,0xC4,0x02,0x46,0x45,0x30,0x01,0x11,0x4A,0x80,0x08,0x28,0xC1,0xB3,
+0x00,0x11,0x4A,0x88,0x02,0x10,0xF1,0x7B,0xC0,0x11,0x02,0xDD,0x02,0xEA,0x41,0xB0,
+0x04,0x10,0xF7,0x7B,0x00,0x0C,0xF8,0x5C,0x02,0xEA,0x41,0xB0,0x01,0x10,0x0F,0x7C,
+0x00,0x00,0x40,0xB8,0x00,0x0C,0x40,0xDE,0x00,0x0C,0x08,0xD4,0x00,0x0C,0x7E,0xDF,
+0x00,0x0C,0x08,0xD4,0x00,0x0C,0x5C,0x5D,0x00,0x0C,0x08,0xD4,0x23,0x11,0x6C,0x5C,
+0x00,0x0C,0x1A,0x5F,0x00,0x0C,0xFA,0xD3,0x02,0xEA,0x41,0xB0,0x80,0x10,0x15,0xFC,
+0x00,0x0C,0x9E,0x5F,0x02,0xEA,0x41,0xB0,0x40,0x10,0x1B,0x7C,0x00,0x0C,0xAE,0x5F,
+0x02,0xEA,0x41,0xB0,0x00,0x0C,0x9C,0xC4,0x00,0x0C,0x78,0x5D,0x00,0x0C,0xC4,0xCA,
+0x00,0x0C,0x26,0x44,0x00,0x0C,0x74,0x5D,0x00,0x0C,0xC4,0xCA,0x00,0x0C,0x78,0xDF,
+0xC0,0x11,0x8A,0xDD,0x00,0x0C,0x62,0xCC,0xFF,0x8E,0x37,0xFC,0x02,0x8C,0x41,0xB0,
+0xFF,0x21,0x3A,0xF4,0x00,0x0C,0xFE,0xDD,0x00,0x0C,0x38,0x44,0xC8,0x11,0x8A,0x5D,
+0x00,0x0C,0x42,0x4C,0x02,0xEA,0x41,0xB0,0x00,0x0C,0xFC,0x5E,0x00,0x0C,0xC4,0xCA,
+0x02,0x0A,0x40,0xB0,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x01,0x10,0x15,0x30,
+0x02,0x06,0x40,0xB0,0x40,0x0A,0x68,0x7C,0xFF,0x4D,0x5D,0x6C,0x7F,0xFF,0x18,0xB8,
+0x00,0x0C,0x9E,0x59,0x40,0x01,0x18,0x38,0x00,0x0C,0x46,0x59,0x00,0x0C,0x5E,0xD4,
+0xB0,0x00,0x40,0x2A,0x00,0x0C,0x5E,0x44,0x00,0x4D,0xBF,0x5A,0x02,0xEA,0x41,0xB0,
+0x13,0x11,0x96,0x42,0x23,0x11,0x96,0x5A,0x02,0xEA,0x41,0xB0,0x00,0x11,0xBE,0xC2,
+0x23,0x11,0x6C,0x5C,0x00,0x0C,0x9C,0xC4,0x9A,0x07,0x0C,0xB8,0x00,0x0C,0x24,0xDF,
+0x02,0x0C,0x0C,0x30,0x80,0x11,0x7E,0x59,0x02,0x06,0x18,0x30,0xFF,0x4B,0x97,0xFA,
+0x20,0x48,0x8D,0xFC,0xFF,0x45,0x8D,0x74,0x02,0x20,0x0C,0xB0,0x02,0x44,0x41,0x30,
+0xFF,0xFF,0x14,0x38,0x83,0x4A,0x95,0x2A,0x02,0x4A,0x15,0x30,0x89,0x10,0x8A,0xAC,
+0x00,0x11,0xBE,0xDA,0x02,0x06,0x40,0xB0,0x02,0xEA,0x89,0xB2,0x20,0x11,0x7E,0x59,
+0xFF,0xEB,0xD3,0x71,0x02,0x20,0xA8,0x33,0x02,0xEA,0x41,0xB0,0x01,0x00,0x14,0xB8,
+0x83,0x4A,0x95,0x2A,0x02,0xD4,0x41,0xB4,0x02,0xEA,0x41,0xB0,0x40,0x10,0xBF,0x74,
+0x02,0x4A,0x15,0x30,0x89,0x10,0xD2,0x29,0x01,0x0B,0x15,0x30,0xFF,0x0A,0xB6,0xFC,
+0x01,0x0A,0xB6,0xF4,0x02,0x0A,0xBA,0xF4,0x03,0x0A,0xBA,0x74,0x04,0x0A,0xBA,0xF4,
+0x05,0x0A,0xBA,0x74,0x06,0x0A,0xBA,0x74,0xA0,0x00,0x04,0xAA,0x00,0x0C,0x4C,0xDE,
+0x00,0x11,0xBE,0xC2,0x00,0x0C,0x60,0x5E,0x00,0x11,0xBE,0xC2,0x13,0x11,0x96,0x42,
+0x01,0x11,0x1A,0x80,0xFF,0xFF,0xB0,0xBB,0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x18,
+0xFF,0x21,0xD2,0xF1,0x00,0x0C,0x2E,0x5E,0x00,0x0C,0xD8,0x54,0x00,0x0C,0x46,0xD8,
+0x23,0x11,0x14,0x00,0x00,0x0C,0x70,0x5A,0xFF,0xD9,0xC5,0x74,0x02,0xD8,0x41,0x30,
+0x02,0x00,0x41,0x30,0x00,0x0C,0xC8,0x44,0xFF,0x8E,0xE9,0xFC,0x02,0x8C,0x41,0xB0,
+0xFF,0x21,0xD2,0xF1,0xFF,0xFF,0x18,0x3B,0xFF,0xFF,0x44,0x3B,0xC8,0x11,0xF4,0xC4,
+0xC8,0x11,0xEA,0xC4,0x01,0x11,0x1A,0x80,0x00,0x0C,0x00,0x5B,0xFF,0x21,0xD2,0xF1,
+0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x46,0xD8,0x23,0x11,0x14,0x00,0x00,0x0C,0x70,0x42,
+0xFF,0x8E,0x01,0x7D,0x02,0x8C,0x41,0xB0,0xFF,0x21,0xD2,0xF1,0xC8,0x11,0x0C,0xC5,
+0xC8,0x11,0x02,0x45,0x01,0x11,0x1A,0x80,0x00,0x0C,0x00,0x5B,0xFF,0x21,0xD2,0xF1,
+0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x46,0xD8,0x02,0x0C,0x0C,0x30,0x02,0x20,0xE4,0xB3,
+0x00,0x0C,0x8C,0x5A,0xFF,0xFF,0xB0,0xBB,0x00,0x0C,0x5C,0x5D,0x00,0x0C,0x44,0xD5,
+0xFF,0xD9,0x23,0xE5,0x02,0xD4,0x19,0xB0,0x02,0x12,0xE4,0x33,0xFF,0xF3,0x33,0x75,
+0x00,0x0C,0x36,0x45,0x02,0x20,0x0C,0xB0,0x02,0xD4,0x19,0xB0,0x02,0x12,0xAC,0x33,
+0x02,0xD8,0x41,0x30,0x02,0xD4,0x1D,0x30,0x02,0xD6,0x27,0xB0,0x02,0x06,0x40,0xB0,
+0xFF,0xD7,0x37,0x65,0x02,0xDA,0x1D,0xB0,0x02,0xD8,0x27,0x30,0x02,0xD4,0x19,0xB0,
+0x02,0x12,0x0C,0x30,0x02,0xD4,0x1D,0x30,0xFF,0xFF,0x26,0xB8,0x23,0x11,0x96,0x5A,
+0x02,0x06,0x40,0xB0,0x00,0x0C,0x4A,0xC5,0x02,0x20,0xB0,0x33,0x02,0xD4,0x19,0xB0,
+0x02,0x12,0x40,0xB0,0xFF,0x21,0x14,0xE5,0x02,0x06,0x18,0x30,0xC8,0x0C,0x52,0xE5,
+0xFF,0x8E,0x5B,0xED,0xFF,0xF3,0xD3,0x71,0x02,0xF2,0x41,0xB0,0x01,0x0C,0x18,0x18,
+0x00,0x0C,0x2C,0xC0,0x02,0xF2,0x19,0xB7,0x01,0x11,0x4A,0x80,0x08,0x28,0xD1,0x33,
+0xE0,0x01,0x18,0x38,0x01,0x12,0x14,0x30,0x07,0x0C,0x18,0x18,0x00,0x12,0x70,0x65,
+0xF8,0x0C,0x18,0x18,0xE8,0x0C,0x62,0x65,0x00,0x11,0x4A,0x88,0x01,0x10,0x22,0x1C,
+0x00,0x11,0x4A,0x88,0x01,0x11,0x22,0x9C,0x00,0x0C,0xB8,0x5E,0x00,0x0C,0x7A,0xC5,
+0x00,0x0C,0xCE,0xDE,0x00,0x0C,0xD2,0x49,0x01,0x34,0x17,0xB0,0x01,0x35,0x15,0xB0,
+0x02,0x0A,0x40,0xB0,0x02,0x08,0x15,0x30,0x02,0xEA,0x41,0xB0,0x02,0x0A,0xA0,0xB2,
+0x01,0x11,0x22,0x9C,0x01,0x11,0x1A,0x80,0x02,0x0C,0xDC,0xB3,0x00,0x0C,0x00,0x5B,
+0x02,0xD6,0xD9,0x33,0x00,0x0C,0x8C,0x5A,0xFF,0xFF,0xB0,0xBB,0xFF,0x21,0x44,0x73,
+0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x02,0x50,0x15,0xB0,0x02,0x06,0x40,0xB0,
+0x8A,0x08,0xAB,0x2D,0x02,0x20,0xB0,0x33,0x02,0xD4,0x19,0xB0,0x02,0x12,0x40,0xB0,
+0x00,0x0C,0x96,0x45,0xC4,0xF0,0xAF,0xF5,0x04,0x4C,0x45,0xEB,0xFF,0xD9,0xC7,0x75,
+0x02,0x20,0x0C,0xB0,0x02,0xD4,0x19,0xB0,0x02,0x12,0xAC,0x33,0x02,0xD8,0x41,0x30,
+0x02,0xD4,0x1D,0x30,0x02,0xD6,0x27,0xB0,0x02,0x06,0x40,0xB0,0xFF,0xD7,0xF9,0xE5,
+0x02,0xDA,0x1D,0xB0,0x02,0xD8,0x27,0x30,0x00,0x0C,0xF8,0xC5,0x02,0xD4,0x19,0xB0,
+0x02,0x12,0x14,0x30,0xFF,0x0B,0xF0,0xF5,0xFF,0xED,0xD9,0xF5,0x02,0x20,0x0C,0xB0,
+0x02,0xEC,0x41,0xB0,0x02,0x0A,0x00,0xB2,0x02,0x06,0x40,0xB0,0x00,0x0C,0xDC,0xC5,
+0x02,0xEE,0x1D,0x30,0x02,0x0A,0x26,0xB0,0xFF,0x01,0xE5,0xE5,0x02,0xEE,0x1D,0x30,
+0x02,0x0E,0x1C,0x18,0x02,0x0A,0x26,0xB0,0x02,0x20,0x0C,0xB0,0x02,0x00,0xAD,0xB3,
+0x02,0x0A,0x40,0xB0,0x02,0xD6,0x01,0xB2,0x02,0x06,0x40,0xB0,0x00,0x0C,0xF8,0xC5,
+0x02,0xDA,0x1D,0xB0,0xFF,0xFF,0x26,0xB8,0x02,0xEC,0xB1,0xB3,0x00,0xEE,0x47,0x58,
+0xC8,0xEE,0xFD,0xE5,0x00,0x0C,0xC4,0x59,0x01,0x10,0x22,0x1C,0xFF,0xFF,0xB0,0xBB,
+0xFF,0x21,0x44,0x73,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x02,0x50,0x15,0xB0,
+0x02,0x06,0x40,0xB0,0x8A,0x08,0x13,0x2E,0x02,0x20,0xB0,0x33,0x02,0x04,0x41,0xB0,
+0x00,0x0C,0x00,0x46,0xFF,0xD9,0x25,0x76,0x02,0x20,0x0C,0xB0,0x02,0x04,0xAD,0x33,
+0x02,0xD8,0x41,0x30,0x02,0xD6,0x09,0x32,0x02,0x06,0x40,0xB0,0xFF,0xD7,0x2B,0xE6,
+0x02,0xD8,0x45,0xB3,0x00,0x0C,0x2A,0xC6,0x02,0x04,0x19,0x33,0xFF,0x05,0x2B,0xE6,
+0xFF,0xFF,0x44,0x3B,0x00,0x0C,0xC4,0x59,0x01,0x10,0x22,0x1C,0x00,0x0C,0x78,0xDF,
+0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x00,0x0C,0x3A,0x5E,0x02,0x06,0x40,0xB0,
+0xFF,0x11,0x22,0x8C,0x01,0x14,0x15,0xB0,0x00,0x9C,0x45,0x7B,0x01,0x10,0x22,0x1C,
+0x01,0x49,0x45,0xEB,0xFF,0x0A,0x45,0xF3,0xC0,0x0A,0x15,0x88,0x80,0x0A,0x44,0xF3,
+0xC0,0x0A,0x44,0x73,0x01,0x10,0x22,0x1C,0x02,0x00,0x44,0xB8,0xFE,0x8F,0x57,0x66,
+0x00,0x0C,0x3A,0x5E,0x00,0x0C,0x56,0xD6,0x00,0x0C,0x64,0xDE,0x01,0x00,0x14,0xB8,
+0x83,0x22,0x44,0x28,0x02,0xFE,0x15,0x30,0x88,0x22,0x4E,0xAE,0xFF,0x11,0x22,0x8C,
+0x02,0xAC,0x15,0xB0,0x89,0x10,0xD2,0x29,0x80,0x9D,0x7F,0x7E,0x02,0x22,0x0C,0x30,
+0x02,0xA4,0x45,0x30,0x00,0x11,0xB4,0x0B,0x80,0x01,0x18,0x38,0x02,0x22,0x0C,0x30,
+0x02,0x12,0x44,0x30,0xFF,0x23,0x76,0x76,0x00,0x0C,0x7E,0x5E,0x02,0x06,0x44,0x30,
+0x01,0xDA,0xB5,0x1B,0x10,0xDA,0x6F,0xE6,0x02,0x06,0x44,0x30,0x00,0x11,0x3C,0x0B,
+0x04,0x10,0x40,0x33,0xFF,0xFF,0x4C,0xBB,0x04,0x11,0x60,0x33,0x00,0x11,0x6A,0x0B,
+0x00,0x11,0x6C,0x0B,0x03,0x9F,0x3F,0x0B,0x00,0x11,0x6E,0x8B,0x00,0x0C,0x22,0xDA,
+0xFF,0xB4,0xD3,0xF9,0x04,0x11,0x50,0x33,0x3D,0xB4,0x15,0xA8,0xA8,0x01,0x1C,0xB8,
+0x00,0x11,0x16,0x88,0xFF,0x0A,0xA4,0x7E,0xFF,0x11,0x26,0x00,0x08,0x0B,0x16,0x18,
+0xFF,0x0A,0x14,0x98,0x00,0x0C,0x9A,0x46,0xFF,0x0B,0x14,0x90,0x01,0x0A,0x14,0x18,
+0x00,0xB4,0x15,0x18,0xFF,0x0A,0xB0,0x7E,0x44,0x0A,0x0E,0x28,0xFF,0x07,0x26,0x98,
+0x02,0x22,0x14,0x30,0x01,0xA4,0x45,0x30,0x40,0x10,0x00,0xB3,0x02,0x0A,0x44,0xB4,
+0x02,0x20,0x0C,0xB0,0x02,0x46,0x45,0x30,0x02,0xA4,0x45,0x30,0x01,0x35,0x15,0xB0,
+0x00,0x0A,0x14,0x98,0x80,0x01,0x18,0x38,0x00,0x0C,0x18,0x98,0x02,0x12,0x40,0xB0,
+0xFF,0xFF,0x14,0x38,0x8A,0x20,0xF0,0xAE,0x00,0x0C,0xE2,0x46,0x02,0x20,0x0C,0xB0,
+0x01,0x35,0x15,0xB0,0x01,0x34,0x17,0xB0,0x02,0x0A,0x40,0xB0,0x02,0x20,0x18,0xB0,
+0x02,0xFC,0x15,0xB0,0x00,0x0C,0x64,0x5F,0x80,0x0B,0xF0,0xFE,0xFF,0x20,0xE2,0x66,
+0xF0,0x21,0xF0,0xFE,0xFF,0x0A,0xF3,0x76,0x01,0x49,0xF5,0x6E,0x02,0x20,0x14,0xB0,
+0x02,0x06,0x40,0xB0,0x01,0x0A,0x6A,0xB2,0x01,0x0B,0x68,0xB2,0x01,0x11,0x22,0x9C,
+0x1F,0x11,0xF6,0xC6,0x20,0x11,0xF6,0xC6,0x21,0x11,0xF6,0x46,0x02,0x06,0x40,0xB0,
+0x00,0x0C,0x8C,0x59,0x01,0x10,0x22,0x1C,0x02,0x50,0xA9,0x33,0x02,0x20,0x0C,0xB0,
+0x00,0x00,0x40,0xB8,0x02,0x08,0x15,0x30,0x8A,0xD4,0x11,0xAF,0x00,0x0C,0x1A,0x5F,
+0x00,0x0C,0x02,0xD7,0x02,0x06,0x40,0xB0,0x1D,0x11,0x8C,0x59,0x01,0x10,0x22,0x1C,
+0x02,0x20,0x14,0xB0,0x02,0x06,0x40,0xB0,0x01,0x0B,0x68,0xB2,0x01,0x0A,0x6A,0xB2,
+0x01,0x11,0x22,0x9C,0x01,0x00,0x14,0xB8,0x83,0x20,0x40,0x28,0x02,0xFC,0x15,0xB0,
+0x88,0x20,0x44,0x2B,0x01,0x10,0x22,0x1C,0x02,0x48,0x15,0xB0,0x02,0x0B,0x24,0xEF,
+0x01,0x0A,0x04,0xB0,0x02,0x0B,0x06,0x80,0xE1,0x48,0x31,0xAF,0xFF,0x11,0x22,0x8C,
+0x02,0x48,0x91,0x32,0x00,0x0C,0x24,0xC7,0xFF,0xFD,0x18,0xB8,0x00,0x0C,0x9E,0x41,
+0x80,0x9D,0x5B,0xFF,0x02,0x22,0xA8,0xB3,0x02,0xA4,0x45,0x30,0x00,0x11,0xB4,0x0B,
+0x02,0x22,0xAC,0x33,0x80,0x01,0x18,0x38,0x11,0xDA,0x15,0xA8,0x00,0x0C,0x18,0x98,
+0x02,0x12,0x44,0x30,0xFF,0x23,0x50,0x77,0x00,0x0C,0x5A,0xDF,0x00,0x0C,0x58,0xCF,
+0x02,0xD6,0x45,0x30,0x01,0xDA,0xB5,0x1B,0x10,0xDA,0x41,0x67,0x01,0x11,0x22,0x18,
+0x02,0xD4,0x45,0x34,0x08,0x9E,0x61,0xFF,0xB0,0x01,0x18,0x38,0x00,0x0C,0x46,0x41,
+0xFF,0xA7,0x47,0x63,0x01,0x11,0x22,0x9C,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,
+0x84,0x11,0x14,0xA8,0x02,0x0A,0x0C,0x30,0xFF,0xFF,0x14,0x38,0x84,0x11,0x1C,0x28,
+0x02,0x06,0x14,0x30,0x83,0x0C,0x22,0x28,0x00,0x00,0x14,0x38,0x84,0x0E,0x14,0xAC,
+0x02,0x46,0x45,0x30,0x02,0x9D,0xD3,0xF9,0x02,0xAE,0x45,0xB4,0x02,0x22,0x14,0x30,
+0x00,0x0C,0x78,0xDF,0x88,0x22,0x88,0x2F,0x01,0x10,0x22,0x98,0x02,0x0A,0x44,0xB4,
+0x01,0x11,0x22,0x18,0x02,0x0A,0x44,0xB4,0x02,0x46,0x45,0x30,0xFE,0xFF,0x14,0xB8,
+0x8B,0x22,0x9A,0x2F,0x02,0x22,0x18,0x30,0x02,0xFE,0x15,0x30,0xB1,0x00,0x64,0xAF,
+0x80,0x0B,0x44,0x6B,0x22,0x11,0x18,0x80,0x01,0x10,0x22,0x1C,0x01,0x8E,0x1D,0x1B,
+0x01,0x8E,0xD3,0x61,0xC8,0x01,0x18,0x38,0x00,0x0C,0x00,0x5B,0xFF,0x21,0xAC,0xF7,
+0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x46,0xD8,0x02,0x20,0x18,0x37,0xFF,0x8E,0x1D,0x9B,
+0xFF,0x8E,0xD3,0x69,0xFF,0x8D,0xD3,0x71,0x02,0x8C,0x41,0xB0,0xFF,0xFF,0x18,0x3B,
+0xC9,0x11,0x2C,0xC0,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+};
+
+uint8_t Lsa1[] = {
+0x22,0x11,0x00,0x80,0x00,0x04,0xC0,0xBB,0x33,0x11,0x00,0x80,0x00,0x00,0x44,0x38,
+0xFD,0x05,0x0A,0x88,0x00,0x11,0x00,0x08,0x00,0x0C,0xC2,0xC0,0x55,0x00,0x0C,0x38,
+0x00,0x0C,0xD4,0x40,0x55,0x00,0x0C,0x38,0x00,0x0C,0xB8,0xC1,0x55,0x00,0x0C,0x38,
+0x00,0x0C,0xBE,0xC1,0x55,0x00,0x0C,0x38,0x00,0x0C,0xD8,0xC1,0x55,0x00,0x0C,0x38,
+0xA1,0x00,0x5A,0x2B,0x55,0x00,0x0C,0x38,0xA2,0x00,0xCE,0xAB,0x55,0x00,0x0C,0x38,
+0xA2,0x00,0x38,0x2C,0x55,0x00,0x0C,0x38,0x00,0x0C,0xA4,0xC0,0x55,0x00,0x0C,0x38,
+0xA1,0x00,0x12,0x2B,0x55,0x00,0x0C,0x38,0xA1,0x00,0x74,0xAC,0x55,0x00,0x0C,0x38,
+0x02,0x3C,0x14,0x30,0x81,0x38,0xB0,0xAB,0x02,0x3E,0x14,0xB0,0x81,0x3A,0xB4,0xAB,
+0x01,0xDA,0x65,0xF8,0x10,0x83,0x14,0x08,0x00,0xE3,0x14,0x88,0xFF,0x0A,0x56,0xF8,
+0x40,0xD9,0x95,0xF8,0x40,0x11,0x72,0x00,0xB1,0x00,0xCA,0x2A,0x40,0xC8,0x53,0xF8,
+0x80,0xC8,0x91,0x03,0x10,0x11,0x06,0x81,0x01,0x11,0x74,0x84,0xFF,0x80,0x14,0x88,
+0x00,0xE0,0x14,0x88,0xFF,0x0A,0x94,0x78,0x40,0xD9,0x95,0xF8,0xC0,0xD9,0x14,0x88,
+0xC0,0x0A,0x94,0xF0,0x00,0x0C,0xB2,0x45,0x55,0x11,0x02,0x00,0x01,0x3B,0x14,0xB0,
+0x00,0x3F,0x14,0x08,0x01,0x0A,0x9C,0xE8,0x01,0x01,0x22,0xB0,0x40,0xD9,0xB3,0xED,
+0x80,0xD9,0x6B,0x6A,0x3B,0x00,0x18,0xB8,0x00,0x0C,0x1C,0x47,0x00,0x0C,0x80,0xC0,
+0x00,0x0C,0x86,0xC0,0x00,0x0C,0x8C,0xC0,0xFF,0x11,0x22,0x20,0x00,0x0C,0x92,0xC0,
+0x20,0xD9,0x4B,0xE9,0x02,0xDA,0x97,0xE8,0xFF,0x11,0x22,0x8C,0x02,0xDB,0xA3,0xE8,
+0x02,0xDA,0x97,0xE8,0xFF,0x11,0x22,0x8C,0x08,0xDA,0x99,0x68,0x80,0xDA,0x9B,0xE8,
+0xFF,0x11,0x22,0x8C,0x00,0x0C,0xA4,0xC0,0xA1,0x00,0x1A,0xAD,0xA2,0x00,0x30,0x2E,
+0xA1,0x00,0x80,0xAE,0xA1,0x00,0x60,0xAF,0x01,0x01,0x22,0xB0,0x55,0x11,0x00,0x80,
+0xA2,0x00,0x00,0x28,0x02,0x11,0x76,0x04,0xF0,0x04,0x14,0x88,0x4C,0x0A,0x14,0x28,
+0xFF,0x0A,0x2A,0x18,0x01,0x05,0x0A,0x84,0x80,0xE1,0xC3,0x03,0xFD,0x05,0x0A,0x88,
+0x5A,0x00,0x18,0x38,0x00,0x0C,0x1C,0x47,0x00,0x0C,0xC0,0x40,0x00,0x0C,0xC0,0x40,
+0x00,0x0C,0xBE,0x40,0xFF,0x11,0x22,0x20,0x00,0x0C,0x08,0xC0,0x11,0x00,0x00,0x98,
+0x11,0x00,0x00,0x98,0x80,0xE1,0xAF,0xE8,0x02,0xE0,0x0D,0xB4,0x02,0x06,0xC0,0x33,
+0x02,0x06,0xCC,0x33,0x02,0xE0,0x0D,0xB4,0x02,0x06,0xC0,0x33,0x02,0xE0,0x0D,0xB4,
+0xFD,0x05,0x0A,0x88,0x02,0xE6,0x0D,0xB4,0x10,0x45,0x00,0xE9,0x20,0xCE,0x0D,0x69,
+0x02,0x54,0x40,0x30,0xB1,0x00,0xC2,0xAC,0x00,0x0C,0x44,0x49,0x00,0x00,0x90,0x38,
+0x18,0x10,0xA1,0xB0,0x01,0x11,0x48,0x00,0x18,0xC0,0xA3,0xB0,0x00,0x11,0x48,0x08,
+0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,0x01,0x0A,0xFC,0xF0,0x00,0x11,0x92,0x88,
+0x00,0x11,0xA2,0x88,0x0B,0x11,0x92,0x80,0x00,0x11,0xA2,0x88,0x05,0x0A,0xFC,0x70,
+0x14,0x11,0x92,0x00,0x04,0x11,0xA2,0xB0,0x02,0x8A,0xC4,0x30,0x80,0x11,0x90,0x84,
+0x30,0xCB,0x0D,0x79,0x00,0x00,0x90,0x38,0x34,0x00,0xA0,0xB8,0xFF,0x00,0xA2,0xB8,
+0xB2,0x00,0xF4,0xAC,0x80,0x11,0x90,0x84,0xB2,0x00,0x02,0x2D,0x00,0x0C,0x44,0x49,
+0xB1,0x00,0xC2,0xAC,0x00,0x0C,0x44,0x49,0x80,0x49,0x45,0x69,0xB2,0x00,0xE4,0x2C,
+0x03,0x3A,0x49,0xE1,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,0x46,0x0A,0x26,0xF1,
+0x39,0x0A,0x34,0x71,0x34,0x0A,0x3E,0xF1,0x80,0x11,0x90,0x84,0x1B,0x48,0x15,0x88,
+0x13,0x0A,0x48,0xE1,0x02,0x11,0x26,0xDF,0xB2,0x00,0xB6,0xAC,0x04,0x0C,0x81,0xB2,
+0xB2,0x00,0xA2,0x2D,0x00,0x0C,0x40,0x41,0x1B,0x48,0x15,0x88,0x13,0x0A,0x48,0xE1,
+0x01,0x11,0x26,0xDF,0xB2,0x00,0xBC,0xAC,0x00,0x0C,0x40,0x41,0xB2,0x00,0x9E,0xAC,
+0xB2,0x00,0xE4,0x2C,0x80,0x11,0x90,0x84,0x40,0xE5,0xCB,0x03,0xB2,0x00,0xC2,0x2D,
+0x80,0x11,0x90,0x84,0x20,0x11,0x72,0x00,0x40,0xE5,0x6B,0x69,0xFF,0xC0,0x6A,0xE9,
+0xFF,0xC1,0x6A,0x69,0x0F,0xC2,0x6A,0x69,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,
+0x01,0x0A,0x60,0x71,0x05,0x0A,0x68,0xE1,0xB1,0x00,0x5C,0x2C,0x00,0x0C,0x68,0x41,
+0xB6,0x00,0x0C,0xB8,0x20,0x49,0x67,0x69,0xA1,0x00,0x82,0x2B,0xA1,0x00,0x76,0xAB,
+0x80,0x11,0x22,0x5F,0x18,0x11,0xB8,0x80,0xBF,0xE5,0xCB,0x8B,0xFF,0xFF,0xC4,0x3C,
+0x00,0x0C,0xCC,0x58,0x02,0x05,0x0A,0x00,0x0F,0xCB,0x99,0x69,0x80,0x49,0xB3,0x69,
+0x20,0x48,0xA7,0xE9,0x80,0xC8,0x9F,0xE9,0x80,0xCE,0x83,0xF9,0x08,0xC8,0xA7,0x69,
+0x00,0x0C,0x92,0x41,0x20,0xC8,0xA7,0x69,0x80,0xCE,0x93,0xE9,0x02,0xCA,0xA1,0xE9,
+0x08,0xCA,0xB3,0xE9,0x02,0x86,0xA2,0x69,0x40,0x4C,0x93,0x79,0x02,0x93,0x92,0x79,
+0x02,0x7F,0xA6,0x79,0x80,0xE5,0xA7,0x69,0x80,0xE4,0xAB,0xE9,0x00,0x0C,0xAE,0xC0,
+0x08,0x11,0x86,0x5D,0x08,0x11,0xB8,0x00,0x00,0x0C,0xB4,0xC1,0x05,0x11,0xA4,0x41,
+0x0F,0x11,0xA4,0x41,0x24,0x11,0xA4,0x41,0x00,0x0C,0x86,0xDD,0xFD,0x05,0x0A,0x88,
+0x00,0x0C,0x56,0xDF,0x80,0x4C,0xB5,0xF9,0xB1,0x00,0xBC,0xA9,0x0C,0x11,0x3A,0xDF,
+0x00,0x0C,0x64,0x42,0x06,0x11,0x86,0xDD,0xB1,0x00,0xBC,0xA9,0x00,0x0C,0x64,0x42,
+0x01,0x48,0xBD,0xF9,0xA1,0x00,0x64,0xAB,0xA1,0x00,0x82,0x2B,0x28,0x00,0x14,0x38,
+0x88,0x90,0xD0,0xA9,0x02,0x48,0xD1,0xF9,0xB1,0x00,0x42,0x2C,0x80,0x49,0xD3,0x69,
+0x12,0x11,0x94,0x00,0x02,0x52,0x44,0x32,0xB1,0x00,0x5E,0xAC,0x00,0x0C,0xD4,0xC1,
+0x80,0x11,0x22,0x5F,0xB1,0x00,0x5C,0x2C,0x18,0x11,0xB8,0x80,0xFF,0xFF,0xC4,0x3C,
+0xF7,0x00,0x0C,0xB8,0x00,0x11,0x94,0x88,0x01,0x52,0xB0,0x33,0x40,0xCE,0xE5,0x69,
+0x07,0xD8,0xF3,0x71,0x00,0x0C,0xEC,0x41,0x41,0xD8,0xE9,0xE1,0xA1,0x00,0x5A,0x2E,
+0x08,0xCA,0x95,0x03,0xB1,0x00,0xC6,0x2A,0x18,0x11,0xB8,0x04,0x40,0xCE,0x37,0x6F,
+0xFF,0xFF,0xC4,0x3C,0x80,0x7F,0xF6,0xE9,0x07,0x11,0xFA,0x41,0x03,0x01,0xC0,0xBB,
+0x40,0xCA,0x95,0x87,0x01,0x0C,0xF8,0xB3,0xB2,0x00,0xB6,0x2E,0x00,0x0C,0xEC,0xC9,
+0xB1,0x00,0x9A,0x2C,0x06,0x01,0xC0,0xBB,0x40,0xCA,0x95,0x87,0x0C,0x11,0x3A,0xDF,
+0x18,0x11,0xB8,0x80,0x00,0x0C,0x64,0x42,0x02,0x48,0x15,0xB0,0x01,0x0B,0x5C,0xEA,
+0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x80,0xE0,0x48,0x19,0x2A,0x00,0x0C,0x1C,0x42,
+0x02,0x48,0x91,0x32,0x00,0x0C,0x0C,0xC2,0x04,0x0C,0x49,0x31,0x03,0x0A,0x23,0xE2,
+0x02,0x34,0x15,0x30,0x02,0x0A,0x48,0xB1,0xFC,0xFF,0x14,0x38,0x83,0x90,0x48,0xA9,
+0x08,0x11,0x48,0xB1,0x30,0xCE,0x35,0xFA,0x02,0x11,0x48,0x00,0x0C,0xD4,0x4D,0x31,
+0x04,0xB0,0x4D,0x31,0x00,0x11,0x48,0x08,0x02,0x20,0xFC,0xB3,0xB1,0x00,0x10,0xAA,
+0x44,0x0A,0xE6,0x2B,0x0C,0x00,0x14,0x38,0x30,0xCE,0x41,0xFA,0x14,0x0A,0x14,0x98,
+0x83,0x90,0x14,0x28,0xB1,0x00,0x44,0x2A,0x00,0x11,0xE4,0x0B,0x80,0xF2,0xE5,0x2B,
+0x20,0x11,0xB8,0x00,0xB1,0x00,0x60,0x2A,0x02,0x08,0xE1,0xB3,0xC0,0x11,0x3A,0xDF,
+0x02,0xFE,0x41,0xB0,0x00,0xFC,0x77,0xDF,0x02,0xF0,0x79,0x32,0x02,0xF2,0x7D,0x32,
+0xB1,0x00,0x8E,0x2C,0x00,0x0C,0x5E,0x42,0x18,0x11,0xB8,0x80,0x7F,0xFF,0x18,0xB8,
+0xB2,0x00,0x6A,0xAE,0x0E,0x11,0x3A,0x5F,0xB1,0x00,0xA4,0xAC,0xBF,0xCA,0x95,0x8B,
+0x00,0x0C,0xF2,0x44,0x00,0x11,0x00,0x08,0x02,0xB4,0x14,0x30,0x81,0xB0,0x14,0x28,
+0x80,0x0A,0x86,0xEA,0x20,0x0A,0xAA,0x6A,0x10,0x0A,0xB0,0xEA,0x04,0x0A,0xB2,0x6A,
+0x02,0x0A,0xB4,0x6A,0x01,0x0A,0xB6,0xEA,0x08,0x0B,0xB8,0xEA,0x04,0x0B,0xBA,0x6A,
+0x02,0x0B,0xBC,0x6A,0x01,0x0B,0xC0,0xEA,0x48,0xF0,0x60,0x3D,0x23,0x11,0x02,0x80,
+0x02,0x48,0xE4,0x33,0x33,0x11,0x00,0x80,0x00,0x00,0x90,0x38,0x22,0x11,0x00,0x80,
+0x03,0x11,0x48,0x80,0xC4,0x01,0x18,0x38,0xB2,0x00,0xC8,0x2D,0x00,0x11,0x48,0x08,
+0x00,0x0C,0x9E,0xCA,0xB2,0x00,0xB6,0x2D,0x00,0x0C,0xA6,0xC2,0x18,0x11,0x18,0x80,
+0xB1,0x00,0xDC,0xAA,0xC4,0x01,0x1C,0xB8,0xF0,0x11,0x6C,0xDF,0x01,0x01,0x22,0xB0,
+0x80,0x11,0x60,0x05,0x00,0x0C,0xDC,0x5A,0x20,0x11,0x3C,0x5F,0x20,0x11,0x60,0x05,
+0x10,0x11,0x60,0x05,0x04,0x11,0x60,0x05,0x02,0x11,0x60,0x05,0x01,0x11,0x60,0x05,
+0x08,0x11,0x62,0x85,0x04,0x11,0x62,0x85,0x00,0x0C,0xDC,0x5A,0x02,0x11,0x62,0x85,
+0x02,0x90,0x14,0x30,0x8B,0x10,0xD0,0x2A,0x03,0x0A,0xE0,0x39,0xFF,0x11,0x22,0x20,
+0x10,0x00,0xD0,0xB9,0x00,0x00,0xD4,0xB9,0x01,0x11,0x62,0x01,0x00,0x00,0xE0,0xBD,
+0x02,0x54,0x40,0x30,0xB1,0x00,0xC2,0xAC,0x00,0x0C,0xDA,0xCA,0xB1,0x00,0xF8,0xAC,
+0xB1,0x00,0x88,0xAB,0x01,0x11,0x62,0x85,0x80,0xCE,0xE9,0x6A,0x08,0xCA,0x95,0x03,
+0x40,0xCE,0xE5,0x6A,0xA1,0x00,0x82,0x2B,0x18,0x11,0xB8,0x80,0xA1,0x00,0xC6,0xAA,
+0x10,0x11,0xB8,0x84,0x08,0x11,0xB8,0x00,0x00,0x00,0x90,0xB9,0x01,0x0A,0x15,0xB0,
+0x00,0x11,0x16,0x88,0xF1,0xFF,0x18,0xB8,0x83,0x0C,0x18,0x28,0x80,0x0D,0x1A,0x7B,
+0x7E,0x01,0x18,0xB8,0x83,0x0C,0x0C,0xAC,0x00,0x0C,0x1C,0xC3,0x00,0x0C,0x24,0x43,
+0x00,0x0C,0x34,0xC3,0x00,0x0C,0x3A,0x43,0x00,0x0C,0x3A,0x43,0x00,0x0C,0x1A,0xC3,
+0x00,0x0C,0x1A,0xC3,0x00,0x0C,0x1A,0xC3,0x00,0x0C,0x3A,0x43,0xA2,0x00,0x9C,0x2B,
+0xA2,0x00,0x80,0xAB,0xA2,0x00,0x9C,0x2B,0x00,0x0C,0x42,0x43,0x00,0x0C,0x1A,0xC3,
+0x00,0x0C,0x1A,0xC3,0x15,0x11,0x2A,0x80,0x06,0x11,0x94,0x81,0x33,0x11,0x95,0x31,
+0x34,0x11,0x28,0x5F,0x00,0x0C,0x36,0x43,0x06,0x11,0x94,0x81,0x23,0x11,0x95,0xB1,
+0x24,0x00,0x14,0x38,0x83,0x3C,0x99,0x28,0x04,0x11,0x30,0x5F,0x00,0x11,0x30,0xDF,
+0x10,0x34,0xC1,0x30,0x00,0x0C,0x36,0x43,0x00,0x0C,0x1A,0xC3,0x40,0x11,0x24,0x5F,
+0x00,0x0C,0x3E,0xC3,0x34,0x10,0x95,0x31,0x34,0x11,0x28,0x5F,0x10,0x01,0xBC,0xB8,
+0x00,0x0C,0x48,0x43,0x10,0x00,0xBC,0x38,0x04,0x3C,0x99,0x30,0x10,0x34,0xC1,0x30,
+0x02,0x05,0x0A,0x00,0x01,0x4C,0x4F,0xEB,0x00,0x11,0x76,0x5F,0xFD,0x05,0x0A,0x88,
+0x20,0x13,0x08,0x39,0x05,0x11,0xB8,0x80,0x02,0xE4,0xAD,0x6E,0x40,0xCE,0x67,0xEB,
+0x30,0xCE,0x67,0xFB,0x08,0x4C,0x67,0xEB,0x0B,0x0A,0x61,0xE3,0x04,0x1F,0x67,0x7B,
+0x00,0x0C,0xCC,0x58,0x88,0xB5,0xAF,0xE8,0x80,0xB5,0x6B,0x03,0xB1,0x00,0x0A,0xAD,
+0x00,0x0C,0xCC,0x58,0x0F,0xCB,0xE5,0x6B,0x80,0xC8,0xE7,0x6B,0x40,0xCE,0xD3,0xEB,
+0x30,0xCE,0x91,0x6B,0x04,0xC9,0xE3,0x6B,0x08,0xC9,0xE9,0x6B,0x01,0x85,0xF8,0xEB,
+0x04,0x85,0x88,0xFB,0xFF,0xC6,0x88,0x6B,0x02,0x11,0x68,0x5D,0x00,0x0C,0x7A,0xDD,
+0x02,0x85,0x8A,0xEB,0x04,0x11,0x0A,0x81,0x04,0xC9,0x93,0x03,0x00,0x0C,0xE2,0x43,
+0x08,0x5D,0xAE,0x78,0x10,0x11,0x24,0x5F,0x02,0x11,0x0A,0x81,0x00,0x0C,0xBC,0xC3,
+0x20,0xC8,0xA5,0x6B,0x02,0xCA,0xEB,0xEB,0x02,0x86,0xFC,0x6B,0x08,0x5D,0xAE,0x78,
+0x20,0x84,0xF8,0x6B,0x10,0x85,0xAE,0x78,0x10,0x11,0x0A,0x81,0x0B,0x0A,0xBD,0x63,
+0x01,0x3A,0xBD,0x63,0xA2,0x00,0x62,0xAD,0x02,0x11,0x68,0x5D,0x00,0x0C,0x7A,0xDD,
+0x20,0x84,0xB0,0x6B,0x10,0x85,0xB6,0x7B,0x10,0x11,0x0A,0x81,0x00,0x0C,0xDC,0xC3,
+0x04,0xC4,0xF8,0x7B,0x20,0x11,0x08,0x01,0x00,0x0C,0xB8,0x43,0x08,0x11,0x68,0x5D,
+0xB2,0x00,0xBA,0x2D,0x00,0x11,0x14,0xC4,0xFF,0x03,0xDD,0x73,0x7F,0x0B,0x15,0x88,
+0x02,0x02,0x41,0xB0,0x7F,0x0B,0xC5,0x0B,0x02,0xEE,0x41,0x30,0x00,0xE2,0xDD,0xE3,
+0x30,0xCE,0xDD,0xEB,0x02,0x02,0xDD,0xB3,0x09,0x11,0xFA,0xDC,0x02,0xEE,0x41,0x30,
+0x00,0x0C,0xEA,0x42,0x08,0x5D,0xAE,0x78,0x00,0x11,0x02,0x88,0xDC,0x01,0x1C,0xB8,
+0xF0,0x11,0x6C,0xDF,0x01,0x01,0x22,0xB0,0x08,0x4C,0xE1,0x6B,0x04,0x11,0x14,0x44,
+0x09,0x11,0x14,0xC4,0x00,0x11,0x0C,0xC4,0x0D,0x11,0xEC,0x43,0x0E,0x11,0xEC,0x43,
+0x18,0x11,0xEC,0xC3,0x19,0x11,0xEC,0x43,0x80,0xCE,0xF1,0x7B,0x16,0x10,0x09,0xF4,
+0x00,0x0C,0x86,0xDD,0x30,0xCE,0xF7,0xFB,0xB2,0x00,0xBA,0x2D,0x02,0x11,0x0C,0x44,
+0x20,0x01,0x08,0x39,0x1A,0x11,0xFE,0x43,0x25,0x11,0xFE,0x43,0x30,0xCE,0x09,0xFC,
+0xB2,0x00,0xBC,0x2D,0xB2,0x00,0xE4,0xAE,0xFF,0x4A,0xEB,0x6A,0xB2,0x00,0xBE,0xAD,
+0x00,0x0C,0x76,0x5F,0x02,0x11,0x0C,0x44,0x01,0x0C,0xD6,0xB3,0x08,0x11,0x68,0x5D,
+0x01,0xEB,0x19,0xB0,0x20,0xE5,0xCB,0x03,0x00,0x0C,0xFA,0xDC,0x00,0x0C,0xD6,0x44,
+0x02,0x20,0x14,0x31,0x02,0x20,0xA4,0xB1,0x00,0x0C,0xCC,0x58,0x10,0x39,0xAE,0x68,
+0x02,0x20,0xC4,0x30,0x80,0x49,0x95,0xEC,0xC0,0x5F,0x15,0x88,0xC0,0x0A,0x90,0xF4,
+0xA0,0x48,0x97,0x6C,0x00,0x11,0x94,0x88,0x10,0x0B,0x35,0x7C,0x18,0x10,0xA5,0x30,
+0x18,0x11,0x24,0x01,0x00,0x0C,0x38,0x44,0x52,0x11,0x74,0x5F,0x04,0x11,0x24,0x81,
+0xB1,0x00,0x8E,0x2C,0x08,0x11,0xB8,0x00,0x01,0xC0,0x23,0xB0,0xFF,0x11,0x22,0x20,
+0xB1,0x00,0x9C,0xAB,0x02,0xE4,0xAD,0x6E,0xB1,0x00,0x0A,0xAD,0x00,0x0C,0xCC,0x58,
+0x02,0x05,0x0A,0x00,0x0F,0xCB,0xB9,0xEC,0x80,0xC8,0xBB,0xEC,0x80,0x49,0x95,0xEC,
+0x20,0x48,0xC7,0xEC,0x30,0xCE,0x7B,0x6C,0xFF,0x58,0x58,0xEC,0x40,0xC9,0xB5,0xEC,
+0x04,0xC9,0xB5,0xEC,0x08,0xC9,0xBD,0x6C,0x01,0x85,0xC2,0x6C,0x04,0x85,0x74,0x7C,
+0xFF,0xC6,0x74,0xEC,0x80,0xE4,0x97,0xEC,0x02,0x11,0x68,0x5D,0x04,0x7F,0x6E,0x6C,
+0x04,0x11,0x0A,0x81,0x04,0xC9,0x93,0x03,0x00,0x0C,0xB4,0xC4,0x01,0x11,0xB8,0x00,
+0x00,0x0C,0xCC,0x58,0x00,0x0C,0x82,0xC4,0xFF,0x58,0xAE,0x68,0x02,0x11,0x0A,0x81,
+0x00,0x0C,0x82,0xC4,0xB2,0x00,0x8A,0x2D,0x20,0xC8,0x89,0x6C,0x02,0xCA,0xBF,0xEC,
+0x02,0x86,0xC0,0xEC,0x80,0xE5,0x8D,0xEC,0x80,0xE4,0x97,0xEC,0x00,0x0C,0xAE,0xC0,
+0x00,0x0C,0x3E,0x5F,0x00,0x0C,0xB2,0xC4,0x00,0x0C,0x56,0xDF,0x00,0x0C,0x96,0xC4,
+0x20,0x11,0x22,0x5F,0x00,0x0C,0x96,0xC4,0x06,0x11,0x86,0xDD,0x30,0xCE,0x9D,0x7C,
+0xB2,0x00,0x8A,0x2D,0x00,0x0C,0xB2,0xC4,0xFF,0x05,0xB3,0x74,0x7F,0x0B,0x15,0x88,
+0x02,0x04,0x41,0xB0,0x7F,0x0B,0xC5,0x0B,0x02,0xEE,0x41,0x30,0x00,0xE2,0xB3,0xE4,
+0x02,0x04,0xDD,0xB3,0x0A,0x11,0xFA,0xDC,0x00,0x00,0xC8,0xBB,0x02,0xEE,0x41,0x30,
+0x00,0x0C,0x18,0xC4,0x05,0x11,0xCE,0x44,0x00,0x0C,0x3E,0x5F,0x01,0x11,0xCE,0xC4,
+0x08,0x11,0xC8,0xC4,0x05,0x11,0xC8,0x44,0x14,0x11,0xC8,0x44,0x0F,0x11,0xC8,0x44,
+0x24,0x11,0xC8,0x44,0x03,0x11,0x0A,0x01,0x10,0x11,0xC8,0xC4,0x00,0x0C,0xCA,0xC4,
+0x00,0x0C,0x86,0xDD,0x00,0x0C,0x3E,0x5F,0x03,0x11,0xCE,0x44,0x30,0xCE,0xD5,0x7C,
+0x40,0x9E,0xD5,0xFC,0xB2,0x00,0xBA,0x2D,0x00,0x0C,0xFA,0xDC,0xB1,0x00,0x8E,0x2C,
+0xFF,0xFF,0xDC,0xBB,0x20,0xE5,0xE7,0xEC,0xFF,0x8E,0xE7,0xEC,0xFF,0xC1,0xE7,0x74,
+0x00,0x0C,0x0C,0x5D,0xFF,0xEF,0xE7,0x74,0x02,0xE0,0x0D,0xB4,0x02,0x05,0x0A,0x00,
+0x7F,0xCA,0x95,0x8B,0x04,0xE4,0xEF,0x7C,0xB1,0x00,0xE4,0x29,0x02,0x86,0xF2,0xFC,
+0x00,0x11,0xB0,0x88,0x02,0x11,0x0C,0x81,0x02,0xE6,0xCC,0x01,0x00,0x00,0xC8,0xBB,
+0x00,0x0C,0xAC,0x40,0x02,0x06,0xD0,0xB3,0x02,0x0C,0x0C,0x30,0x10,0x11,0x22,0x5F,
+0x02,0x06,0x18,0x30,0x00,0x0C,0x3A,0xDF,0x00,0x0C,0xCC,0x58,0x10,0x49,0xAF,0x68,
+0xFF,0xFF,0xC4,0xB8,0x02,0xE8,0x0D,0x34,0x11,0x11,0x02,0x00,0x02,0x05,0x0A,0x00,
+0x02,0xC0,0x41,0x30,0x02,0x20,0xDC,0x33,0x04,0x4C,0x43,0xED,0x80,0x48,0x29,0xFD,
+0xB2,0x00,0xD4,0xAE,0x02,0xEE,0x15,0xB0,0x88,0x20,0x20,0xAD,0xFF,0xFF,0xDC,0xBB,
+0x02,0x06,0x41,0x30,0xFF,0x21,0x38,0xF5,0xFF,0xEF,0x13,0x75,0x00,0x0C,0x16,0xC5,
+0x02,0x06,0x09,0xB2,0xFF,0xFF,0x0C,0xBA,0x04,0x11,0x22,0x5F,0x02,0x04,0x41,0xB0,
+0xFF,0x21,0x38,0xF5,0x04,0x4C,0x17,0xFD,0x02,0x20,0x80,0x33,0x00,0x0C,0x3A,0x45,
+0x00,0x0C,0x5C,0x5D,0xFF,0xEF,0x57,0x75,0x01,0x11,0xF6,0x03,0x0C,0x02,0xC0,0xBB,
+0x00,0x0C,0x4E,0x45,0x00,0x11,0xF6,0x0B,0x75,0x01,0xC0,0x3B,0x02,0x06,0x81,0x33,
+0xFF,0xFF,0x0C,0xBA,0xFF,0xC1,0x4F,0xE5,0xFF,0xFF,0x84,0x3B,0x02,0xEE,0x41,0x30,
+0x02,0x46,0x45,0x30,0x00,0x00,0xC8,0xBB,0x80,0xCA,0x95,0x03,0x01,0x01,0x22,0xB0,
+0xFD,0x05,0x0A,0x0C,0x02,0xC0,0x41,0x30,0x04,0x10,0x80,0xB7,0xFF,0xC1,0x37,0xF7,
+0x02,0x06,0xD0,0xB3,0x00,0x0C,0x5A,0x5D,0x07,0x11,0x3A,0x5F,0x02,0xE8,0x0D,0x34,
+0x01,0x0C,0xB8,0x30,0x02,0x06,0xD0,0xB3,0x00,0x0C,0x70,0xDD,0x02,0xE8,0x0D,0x34,
+0x01,0x0C,0xD8,0x33,0xB0,0x00,0xC6,0x28,0x01,0xEC,0xB9,0x30,0x20,0x5D,0xAE,0xE8,
+0xA0,0x00,0xD2,0xA8,0x00,0x0C,0xC6,0x58,0x05,0x11,0xF6,0x80,0x02,0x78,0x14,0x30,
+0x00,0x7A,0x14,0x00,0x89,0x10,0xAE,0x28,0x00,0x0C,0xD2,0x40,0x80,0xCE,0x8B,0xFD,
+0x80,0x48,0x37,0xEF,0x00,0x0C,0x76,0x5F,0x80,0x11,0x24,0x5F,0x80,0xCE,0x95,0x6D,
+0x40,0x9E,0x37,0x6F,0x40,0x9E,0x3D,0x03,0x02,0x06,0xD0,0xB3,0x02,0x20,0xFC,0xB3,
+0x02,0x08,0xE1,0xB3,0x01,0x4D,0xF9,0x33,0xB1,0x00,0x10,0xAA,0x02,0x0C,0x1C,0x98,
+0x80,0xCE,0xA7,0x7D,0xF0,0x11,0x26,0x00,0x00,0x0C,0xA8,0xC5,0xF1,0x11,0x26,0x80,
+0x02,0xF0,0x27,0x30,0x01,0xFC,0x27,0x30,0x00,0x0A,0x3A,0xDF,0x02,0xFE,0x41,0xB0,
+0x02,0xE8,0x0D,0x34,0xC0,0xD9,0xB0,0x0B,0x40,0xD8,0xC3,0xF5,0xC0,0xD8,0xC3,0x75,
+0xFF,0xD8,0xBD,0xFD,0x40,0x11,0x72,0x84,0x30,0xCB,0xBB,0x7D,0x40,0xCB,0x97,0x03,
+0xBF,0x3D,0x7A,0x0C,0x01,0xCD,0xBB,0x6D,0x30,0xCB,0xBB,0xED,0xDD,0x02,0x0C,0xB8,
+0x20,0xD9,0x7E,0x6E,0x00,0x11,0xB2,0x89,0xF0,0xD8,0x14,0x08,0x10,0x0A,0xD4,0xF5,
+0x20,0x0A,0xD8,0xF5,0x00,0x0C,0x7C,0xC6,0x80,0xCF,0xDB,0xED,0x00,0x0C,0x7C,0xC6,
+0x40,0xCF,0x7D,0x7E,0x0F,0xD8,0x14,0x08,0x08,0x0A,0xE4,0xF5,0x09,0x0A,0x80,0x66,
+0x55,0x11,0x00,0x80,0x01,0x43,0x81,0x6E,0x02,0xC8,0x91,0x03,0x01,0xC8,0x23,0x7E,
+0x11,0x11,0x00,0x80,0x02,0xC9,0x05,0xEE,0x01,0x96,0x17,0x30,0x01,0x97,0x15,0x30,
+0x16,0x11,0xB2,0x81,0x01,0xD8,0x1A,0xB0,0x01,0xD8,0x18,0x30,0x8A,0x0C,0xFE,0xAD,
+0xB2,0x00,0xF0,0xAD,0x80,0x0F,0x86,0x6E,0x00,0x0C,0x04,0xC6,0xA8,0x00,0x18,0xB8,
+0x00,0x0C,0x88,0x5E,0xFF,0x0A,0x86,0x7E,0xB1,0x00,0x04,0x2D,0x84,0x01,0x18,0xB8,
+0x00,0x0C,0x88,0x5E,0x01,0x0A,0x24,0x66,0x00,0x11,0xB2,0x89,0xF0,0xD8,0xB0,0x8B,
+0x80,0xD8,0xA5,0x8B,0x70,0xD8,0xB1,0x8B,0x70,0x0B,0x15,0x88,0x00,0xD8,0x25,0x66,
+0x80,0x80,0x1F,0x7E,0xFF,0xD2,0x25,0xEE,0x00,0x0C,0x20,0xC6,0x80,0xD2,0x25,0xE6,
+0x20,0xD8,0x25,0x76,0x80,0xC9,0x93,0x03,0x00,0x11,0xB2,0x89,0xF0,0xD8,0x14,0x08,
+0x80,0x0A,0xB0,0x0B,0x30,0x0A,0x14,0x08,0x80,0xD8,0x31,0x6E,0x80,0x0A,0x14,0x00,
+0x01,0xD8,0x38,0x6E,0x55,0x11,0x00,0x80,0x01,0x43,0x39,0x6E,0x08,0x0A,0x14,0x00,
+0x00,0x11,0x00,0x08,0x01,0x0A,0xA4,0xB3,0x01,0xD8,0x46,0xB0,0x01,0xD8,0x44,0x30,
+0xFE,0xFF,0x14,0xB8,0x8B,0x22,0x7C,0x2E,0x02,0x22,0x18,0x30,0x02,0xEE,0x15,0xB0,
+0xB2,0x00,0xF0,0xAD,0x80,0x0F,0x7C,0xFE,0xFE,0x8F,0x51,0xF6,0xFD,0x8F,0x7D,0xE6,
+0x84,0x01,0x18,0xB8,0x00,0x0C,0x88,0x5E,0x01,0x0A,0x7C,0xE6,0x20,0xD2,0x5F,0x7E,
+0x20,0x9E,0x7B,0x6E,0x40,0x9D,0x5F,0xFE,0x02,0x9E,0x7D,0xFE,0x00,0x11,0x7E,0x0B,
+0x08,0xD2,0x41,0x09,0x01,0xD2,0x15,0xB0,0xB1,0x00,0x2A,0xA9,0x34,0x11,0x70,0xDF,
+0xB1,0x00,0x02,0x2B,0xB1,0x00,0x4A,0xA9,0xFE,0xC8,0x91,0x8B,0xB1,0x00,0xE4,0x29,
+0x80,0xCA,0x75,0x6E,0xA2,0x00,0xDC,0xAD,0xB1,0x00,0x9A,0x2C,0x8A,0x03,0xC0,0xBB,
+0x40,0xCA,0x95,0x87,0x4F,0x11,0x82,0xC6,0x44,0x11,0x82,0x46,0x51,0x11,0x82,0xC6,
+0x41,0x11,0x82,0x46,0x7F,0xC9,0x93,0x8B,0x00,0x0C,0x70,0x5F,0xFD,0xC8,0x91,0x0F,
+0x0C,0x11,0xB2,0x01,0x01,0x12,0x14,0x30,0x00,0xD8,0x94,0x66,0x1F,0xD9,0x14,0x08,
+0x14,0x0A,0x8A,0x66,0x01,0x11,0x14,0x84,0xFF,0xD9,0xB2,0x99,0xFF,0x0C,0x18,0x98,
+0xFF,0x12,0x14,0x10,0xFF,0x11,0x16,0x00,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,
+0x01,0xD8,0xB0,0xB3,0x00,0x11,0xB2,0x0B,0x83,0xD8,0x15,0xA8,0x80,0x0B,0xAA,0x6E,
+0x02,0x11,0x14,0x84,0x00,0x11,0x14,0x8C,0x00,0x0C,0xCC,0x58,0x02,0x05,0x0A,0x00,
+0x0F,0xCB,0xCF,0xEE,0x80,0xC8,0xD1,0x6E,0x01,0xC9,0xF3,0xEE,0x80,0xC9,0xC1,0x6E,
+0x02,0xC8,0xC9,0x6E,0xEB,0x11,0x38,0x5F,0x00,0x0C,0xAE,0x50,0x03,0x11,0xD2,0x46,
+0xFD,0x05,0x0A,0x88,0xFD,0xE4,0xC9,0x8B,0xFF,0xFB,0x57,0xFB,0x00,0x0C,0x44,0xC4,
+0xFD,0x05,0x0A,0x88,0xFD,0x9E,0x3D,0x8B,0x00,0xFB,0x0D,0xC4,0x09,0x11,0xD2,0x46,
+0x12,0x11,0xD2,0x46,0x00,0x0C,0x76,0x5F,0xFD,0x05,0x0A,0x88,0xB1,0x00,0x04,0x2D,
+0xB1,0x00,0xC6,0x2A,0x22,0x11,0x02,0x00,0xE8,0x11,0x6E,0x5F,0x01,0x01,0x22,0xB0,
+0xB1,0x00,0x02,0x2B,0x00,0x0C,0xF2,0x4E,0x00,0x0C,0xCC,0x58,0x80,0xC8,0xF3,0x6E,
+0x22,0x11,0x02,0x00,0xEB,0x11,0x38,0x5F,0x01,0x01,0x22,0xB0,0x00,0x0C,0xAE,0x50,
+0x01,0x9E,0x3D,0x03,0xF7,0xA0,0x40,0x89,0xFD,0x9E,0x3D,0x8B,0x00,0x00,0x90,0x3B,
+0xC0,0xCA,0x95,0x0B,0x02,0x05,0x0A,0x00,0x40,0x3D,0x7A,0x00,0xFF,0xE0,0xC0,0x81,
+0xB2,0x00,0x0A,0xAE,0xFD,0x05,0x0A,0x88,0x04,0xE4,0xC9,0x03,0x02,0xFB,0x0D,0x44,
+0x00,0x0C,0xCC,0x58,0x0F,0xCB,0xCF,0xEE,0x02,0x7C,0xAE,0x78,0x02,0xE4,0xC9,0x03,
+0xFF,0xFB,0xEB,0xFA,0x00,0x0C,0x18,0xC4,0x00,0x0C,0xCC,0x58,0x80,0xCA,0xAF,0xE8,
+0xB2,0x00,0xDC,0x2D,0x00,0x0C,0x64,0x42,0x0F,0x00,0x14,0x08,0x00,0x11,0x16,0x88,
+0x83,0x0C,0x0C,0xAC,0xA2,0x00,0x52,0xAE,0xA2,0x00,0x56,0x2E,0xA2,0x00,0x7C,0xAE,
+0x01,0x0C,0x98,0xB0,0x03,0x11,0x9A,0xB0,0x01,0x0C,0x14,0x30,0x04,0x11,0x30,0x47,
+0x01,0x0C,0xF6,0x30,0x01,0x0A,0xF0,0x30,0x02,0x11,0xF2,0x34,0xFF,0x11,0x22,0x8C,
+0xA1,0x00,0x82,0xAA,0xA1,0x00,0xD2,0xA9,0xA2,0x00,0x50,0x2D,0x20,0xE5,0xCB,0x03,
+0x80,0xE4,0x37,0xEF,0x08,0x5D,0x36,0xEF,0x02,0x11,0xB8,0x00,0x02,0x06,0xD0,0xB3,
+0x02,0x11,0x70,0x5D,0x02,0xE8,0x0D,0xB0,0x05,0x11,0xB8,0x80,0x80,0x11,0xB8,0x00,
+0x00,0x0C,0xC6,0x58,0x80,0xE4,0xAF,0x78,0xA0,0x00,0xD2,0xA8,0x80,0xE4,0x37,0xEF,
+0x08,0x5D,0x36,0xEF,0x80,0xE5,0x5F,0xEF,0xC0,0x11,0x64,0x5F,0xB0,0x00,0xC6,0x28,
+0x80,0xE4,0xAF,0x78,0xA0,0x00,0xD2,0xA8,0xFF,0x00,0x6A,0xEF,0x00,0x11,0x86,0x09,
+0x40,0x11,0x90,0x00,0x01,0x0C,0xB8,0xB4,0xA1,0x00,0x72,0xAA,0xA1,0x00,0x70,0x2A,
+0xA1,0x00,0xD0,0x2A,0x01,0x11,0x22,0x9C,0xA2,0x00,0xC6,0x2B,0x01,0x05,0x0C,0x30,
+0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,0x02,0x4C,0x15,0x30,0x01,0x0A,0x04,0x80,
+0x01,0x0C,0x06,0x30,0xE0,0x4C,0x87,0x2F,0x00,0x0C,0x8A,0x47,0x02,0x4C,0x99,0x32,
+0x00,0x0C,0x7C,0x47,0x01,0x06,0x0A,0x30,0x01,0x06,0x22,0x30,0xFF,0x11,0x22,0x8C,
+0x02,0x48,0x15,0xB0,0x02,0x0B,0x90,0xEF,0x01,0x0A,0x04,0xB0,0x02,0x0B,0x06,0x80,
+0xE0,0x48,0x9D,0x2F,0xFF,0x11,0x22,0x8C,0x02,0x48,0x91,0x32,0x00,0x0C,0x90,0xC7,
+0xFF,0xFD,0x18,0xB8,0xA2,0x00,0x6A,0x2E,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x0C,0x0C,0x40,0xFD,0x05,0x0A,0x88,0x00,0x04,0xC0,0xBB,0x00,0x0C,0x56,0x40,
+0x00,0x04,0xC0,0xBB,0x00,0x0C,0xFC,0xC4,0x02,0x05,0x0A,0x00,0xEF,0x11,0x82,0x5A,
+0x00,0x0C,0x2A,0x50,0xEF,0x11,0xA4,0xDA,0x02,0xCB,0x97,0x03,0x30,0xCB,0x2B,0xE8,
+0xFD,0x05,0x0A,0x88,0x00,0x0C,0x10,0x5A,0x02,0x0C,0x1C,0x98,0x20,0xC6,0x27,0x00,
+0x00,0x11,0x26,0x88,0x00,0x0A,0xD2,0xD9,0x02,0x05,0x0A,0x00,0x00,0x0C,0x32,0x5F,
+0x22,0x11,0x00,0x80,0x02,0x05,0x0A,0x00,0x10,0xE4,0x41,0x78,0x02,0xCA,0x3D,0x68,
+0x05,0x86,0x40,0xF8,0x18,0x11,0x08,0x81,0x05,0x86,0x40,0xF8,0x08,0x11,0x88,0x00,
+0x18,0xE4,0xC8,0x81,0x00,0x0C,0x3E,0xC0,0xFD,0xCA,0x95,0x8B,0xEF,0xE4,0xC9,0x8B,
+0x30,0x45,0x02,0xF8,0xF3,0x11,0x9E,0x5A,0x00,0x0C,0x02,0x50,0xC4,0x01,0x1C,0xB8,
+0xF3,0x11,0x84,0xDA,0x00,0x0C,0x50,0xD0,0xB2,0x00,0xB6,0x2D,0x00,0x0C,0x52,0xC0,
+0x08,0x44,0x02,0x68,0xF3,0x11,0xA4,0x5A,0x00,0x0C,0x02,0xC0,0x02,0x05,0x0A,0x00,
+0x04,0x04,0x0C,0x38,0x01,0xCD,0x29,0xF9,0x80,0xCA,0xF7,0xEC,0x0F,0xCB,0xC7,0x68,
+0x10,0x45,0x1A,0x69,0x40,0xC8,0xB5,0xE8,0x80,0xC8,0xA9,0x68,0x10,0xC8,0xA1,0xE8,
+0x40,0xCE,0xD3,0xE8,0x20,0xCE,0xD9,0xE8,0x04,0xC8,0x8F,0xE8,0x04,0xC9,0x75,0xF8,
+0x59,0x11,0xCE,0x5A,0x08,0x11,0x8A,0x40,0x08,0xC9,0x7B,0x78,0x58,0x11,0xCE,0xDA,
+0x04,0x11,0x8A,0x40,0xFF,0x8E,0x87,0x68,0xFF,0xC1,0x23,0x61,0x40,0x83,0xF6,0xEC,
+0x01,0xC8,0x87,0x68,0x08,0xC8,0x87,0x68,0x40,0xC9,0xF7,0x7C,0x5A,0x11,0xCE,0x5A,
+0x00,0x11,0x8A,0xC0,0xB1,0x00,0xBE,0x2F,0x01,0x0C,0xE4,0x81,0x08,0xC8,0x95,0x68,
+0x20,0xC9,0xF7,0x7C,0x00,0x0C,0xAC,0x40,0x02,0x11,0xE4,0x81,0xB1,0x00,0xBE,0x2F,
+0x00,0x0C,0x54,0x59,0x00,0x0C,0xB0,0x5A,0x20,0xC8,0xC9,0x68,0xE4,0x11,0x70,0x42,
+0x20,0xC8,0xC9,0x68,0xE7,0x11,0x82,0xDA,0x00,0x0C,0xF6,0x54,0x00,0x0C,0xAC,0x40,
+0x40,0x39,0xAC,0x78,0x40,0x11,0x72,0x00,0x00,0x0C,0x54,0x59,0x00,0x0C,0xC6,0xDA,
+0x80,0xC8,0xBD,0x68,0xE8,0x11,0x70,0x42,0x80,0xC8,0xBD,0x68,0xEB,0x11,0x82,0xDA,
+0x00,0x0C,0xF6,0x54,0x01,0x9E,0x3D,0x03,0x03,0xC8,0x91,0x0B,0xF0,0x08,0x04,0xB9,
+0x03,0x11,0x0E,0x81,0xBF,0xC9,0x93,0x8B,0x00,0x0C,0xC8,0xC0,0x00,0x0C,0x54,0x59,
+0x40,0xCA,0xF7,0xEC,0x02,0x06,0x22,0x30,0xB0,0x00,0x5E,0xAD,0x00,0x0C,0x76,0x59,
+0x00,0x0C,0x08,0xC0,0x40,0xCA,0xF7,0xEC,0x10,0xC9,0xAD,0x68,0x00,0x0C,0x98,0xC0,
+0x80,0x83,0x00,0xE9,0x02,0xCA,0x13,0xE9,0x02,0xA1,0x0E,0x69,0x20,0xC8,0x0B,0x69,
+0xFF,0xC1,0x17,0xE1,0x02,0x9F,0xF7,0xEC,0x01,0x9F,0xED,0x78,0xB2,0x00,0x90,0xAD,
+0x00,0x0C,0xF6,0x4C,0x00,0x0C,0x0A,0xC1,0xE3,0x11,0x9E,0xDA,0x00,0x0C,0xF6,0xC8,
+0x80,0x11,0x0E,0x01,0xC8,0x01,0x1C,0xB8,0xE0,0x11,0x72,0x42,0x80,0x87,0x00,0x69,
+0x13,0x00,0xE0,0xB9,0xFF,0x11,0x22,0x20,0xFF,0xE8,0x00,0xE9,0x04,0x86,0x04,0xF9,
+0xFD,0xA1,0x42,0x89,0xE3,0x11,0xA4,0xC2,0xC8,0x01,0x1C,0xB8,0xE3,0x11,0x84,0x5A,
+0x00,0x0C,0xF6,0x54,0xE3,0x11,0xA4,0xDA,0x02,0xA1,0x42,0x01,0x04,0xA1,0xF6,0x7C,
+0x00,0x0C,0x98,0xC0,0xB2,0x00,0x72,0xAD,0x00,0x0C,0xAC,0x40,0xE3,0x11,0xA4,0xDA,
+0x00,0x0C,0x22,0xC1,0xB2,0x00,0x90,0xAD,0x00,0x0C,0xC6,0xD0,0x02,0xCA,0x25,0xE9,
+0xFF,0xC1,0xF7,0xF4,0xA0,0x00,0x0C,0xAD,0xB2,0x00,0x72,0xAD,0x00,0x0C,0xC6,0x40,
+0xA0,0x00,0x5E,0x2D,0x30,0x0A,0x18,0x08,0xFF,0x0C,0x34,0xF9,0x20,0x0C,0x36,0x71,
+0x30,0x0C,0x3C,0xF1,0x20,0x11,0x40,0xC1,0x10,0x11,0x40,0xC1,0x08,0x11,0x4E,0x59,
+0x20,0x9E,0x3D,0x03,0x00,0x0C,0x3E,0x41,0x00,0x11,0x4E,0xD9,0x40,0x11,0x40,0xC1,
+0x00,0x11,0x02,0x88,0x01,0x0C,0x8C,0x31,0x01,0x01,0x22,0xB0,0x01,0x0A,0x40,0x31,
+0x01,0x0A,0xF6,0xFC,0x02,0xA0,0x98,0xB3,0x01,0x45,0x9C,0x37,0x11,0x11,0x02,0x00,
+0x01,0x0C,0x96,0x30,0x01,0x01,0x22,0x34,0x01,0xA1,0xF6,0x7C,0x10,0x45,0xF6,0xEC,
+0x20,0x45,0x5E,0x69,0x00,0x0C,0x62,0x59,0x01,0x11,0x4E,0x41,0x0A,0x11,0x4E,0xD9,
+0x1F,0x11,0x6A,0x59,0x08,0xA0,0x14,0x88,0x02,0x0A,0x14,0x00,0x00,0x11,0x16,0x88,
+0x02,0x0A,0x40,0xB5,0x11,0x11,0x02,0x00,0x01,0x0C,0x90,0x30,0x01,0x01,0x22,0x34,
+0xFF,0x11,0x6A,0xD9,0xF7,0xA0,0x40,0x89,0x01,0x11,0x4E,0x41,0x02,0x05,0x0A,0x00,
+0x20,0xCA,0x7D,0xF9,0xFD,0x9E,0x3D,0x8B,0xDF,0x9E,0x3D,0x8B,0x03,0x11,0x90,0xB3,
+0x10,0x45,0x88,0xE9,0x00,0x00,0x98,0xBB,0x00,0x11,0x9C,0x0B,0x00,0x0C,0x94,0x41,
+0x00,0x11,0x02,0x88,0xF7,0x5E,0xBC,0x88,0x40,0x11,0x90,0x00,0x00,0x11,0x86,0x09,
+0x01,0x01,0x22,0xB0,0xFE,0xCD,0x9B,0x8B,0x40,0x3D,0x7A,0x00,0xFF,0xE0,0xC0,0x81,
+0xB2,0x00,0x16,0x2E,0x00,0x0C,0xE4,0xD9,0xFD,0x05,0x0A,0x0C,0xFD,0x4D,0x9B,0x8A,
+0x00,0x0C,0xAC,0xD9,0x55,0x11,0x02,0x00,0x92,0x11,0xAC,0x82,0x02,0x4D,0x9B,0x02,
+0x02,0x5B,0xB7,0x02,0x01,0x01,0x22,0x34,0x10,0xC7,0xF7,0xFC,0x10,0x45,0xF6,0xEC,
+0x20,0xCE,0xF7,0x6C,0x02,0xFE,0x15,0x30,0x83,0x10,0xFC,0xAB,0x89,0x10,0xF6,0x2C,
+0x02,0xFC,0xFD,0xB3,0x30,0x11,0xD0,0x42,0x02,0x06,0xD0,0xB3,0xB0,0x00,0xCC,0x28,
+0x80,0x5D,0xFC,0x7C,0xFF,0x4D,0xC9,0xE9,0x0E,0x11,0xD2,0x59,0x02,0xE8,0x0D,0x34,
+0x0D,0x11,0xD2,0x59,0x30,0xCE,0xD1,0xF9,0x40,0x9E,0xD1,0x79,0xB2,0x00,0xBA,0x2D,
+0x02,0xE8,0x0D,0x34,0x01,0x0C,0xD6,0xB3,0x02,0x20,0xD8,0xB3,0xB0,0x00,0xC6,0x28,
+0x02,0x05,0x0A,0x00,0x04,0x3A,0xFC,0xFC,0x01,0xEB,0x69,0x30,0x00,0x11,0x6A,0x08,
+0x02,0xEC,0x6D,0x30,0xA0,0x00,0xD0,0x28,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,
+0x44,0xC6,0x0F,0xA8,0x01,0x07,0x1C,0x30,0x02,0xAE,0x19,0x30,0xFF,0x0E,0x14,0x90,
+0xFF,0x0E,0x16,0x10,0x81,0x0C,0x04,0x28,0x01,0x0E,0x14,0xB0,0x0F,0xCB,0xFB,0xE9,
+0x00,0x03,0x06,0x80,0xFF,0xC8,0x05,0x6A,0xFF,0xC9,0x05,0xEA,0xFF,0xCA,0x05,0xEA,
+0xF0,0xCB,0x05,0x6A,0x00,0x02,0x04,0x80,0x02,0x0C,0x14,0x30,0xE1,0xAE,0x0D,0x2A,
+0x02,0x06,0x44,0x30,0xFF,0x11,0x22,0x8C,0x02,0xAE,0x5D,0x33,0x00,0x0C,0xEC,0x41,
+0xB0,0x00,0xC6,0x28,0x02,0x05,0x0A,0x00,0x04,0x3A,0xFC,0xFC,0x11,0x00,0x68,0xB8,
+0x00,0x00,0x6C,0x38,0xFD,0x05,0x0A,0x88,0xB0,0x00,0xCC,0x28,0x02,0x11,0x48,0x00,
+0xFF,0xCE,0x27,0x6A,0x00,0x11,0x48,0x08,0x00,0x0C,0xFC,0xC4,0xC8,0xCC,0x19,0x98,
+0x01,0x11,0x1A,0x80,0x01,0x12,0x16,0xB0,0x11,0xCC,0x15,0x28,0x03,0x0C,0x98,0x8B,
+0xFF,0xCE,0x9D,0x9B,0xC0,0x0A,0x18,0x98,0x02,0x0C,0x1C,0xB0,0x02,0x12,0x40,0xB0,
+0xFF,0xFF,0x26,0xB8,0x00,0x11,0x48,0x08,0x01,0x0B,0x14,0xB0,0x44,0x0A,0x18,0xA8,
+0x02,0x0C,0x1C,0xB0,0xA0,0x00,0xD2,0xA8,0x02,0x0C,0x0C,0x30,0x08,0x0C,0x18,0x18,
+0x02,0x12,0x1C,0xB0,0x02,0x0A,0x0C,0x30,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,
+0x84,0x11,0x14,0xA8,0x83,0x0E,0x1C,0x28,0x02,0x06,0x14,0x30,0x80,0x0F,0x5C,0xFA,
+0xFE,0x0C,0x18,0x18,0x02,0x12,0x14,0x30,0x02,0x06,0x18,0x30,0xFF,0x11,0x22,0x8C,
+0x08,0x0C,0x1C,0x98,0x01,0x0D,0x1E,0xB0,0x02,0x0A,0x26,0xB0,0x00,0x00,0x26,0xB8,
+0x10,0x12,0xC0,0x30,0xF0,0x0C,0x18,0x98,0x20,0x00,0xBC,0x38,0x49,0x11,0xB8,0x84,
+0xD4,0x01,0x1C,0x38,0x01,0x0E,0x1A,0x30,0x01,0x0C,0x1C,0xB0,0x01,0x0D,0x18,0xB0,
+0x03,0x11,0x48,0x80,0x00,0x0C,0xAC,0xDA,0x04,0x12,0x50,0x30,0x04,0x28,0x26,0xB0,
+0x00,0x00,0x48,0xBC,0xD4,0x01,0x1C,0x38,0x03,0x11,0x48,0x80,0x00,0x0C,0xAC,0xDA,
+0x11,0x12,0x22,0xA8,0x00,0x0C,0x9C,0x52,0x02,0x0C,0x0C,0x30,0x02,0x0E,0x18,0xB0,
+0x04,0x12,0x50,0x30,0x02,0x06,0x18,0x30,0xFC,0x0C,0x18,0x98,0x04,0x12,0x50,0x30,
+0xFF,0x11,0x22,0x20,0x11,0x2B,0x22,0xA8,0x00,0x00,0x48,0xBC,0x00,0x0C,0xAC,0xDA,
+0x11,0x12,0x22,0xA8,0x00,0x11,0x4A,0x0C,0x00,0x0C,0xAC,0xDA,0x02,0x0C,0x1C,0xB0,
+0x00,0x11,0x26,0x88,0x00,0x11,0x4A,0x0C,0x02,0x11,0x4A,0x80,0x01,0x11,0x1A,0x04,
+0x10,0x30,0x14,0xB8,0x00,0x0C,0xB2,0xDC,0x20,0xCE,0xC1,0xFA,0x20,0x9D,0xC1,0xFA,
+0xB2,0x00,0x90,0xAD,0x00,0x0C,0xC0,0x4A,0x20,0xCA,0x95,0x03,0x28,0x11,0xC2,0x42,
+0x29,0x11,0xC2,0xC2,0x00,0x0C,0xD4,0xDA,0x00,0x0C,0x70,0x41,0x40,0xC0,0x14,0xB8,
+0x00,0x0C,0xB2,0xDC,0x1C,0x11,0xD8,0x5A,0x00,0x0C,0x70,0x41,0x04,0xC8,0x91,0x03,
+0x01,0x0C,0x14,0x30,0x10,0x11,0xE4,0x42,0x01,0x0C,0x14,0x30,0x30,0x11,0xE4,0xC2,
+0x01,0x0C,0x14,0x30,0x60,0x11,0xE4,0xC2,0x01,0x0C,0x14,0x30,0x20,0x11,0xE4,0x42,
+0x01,0x0C,0x14,0x30,0x24,0x11,0xE4,0xC2,0x01,0x05,0x16,0xB0,0x02,0x05,0x0A,0x00,
+0x02,0xCA,0xEF,0xEA,0xF0,0x44,0xF0,0xEA,0x08,0x44,0xF4,0x7A,0x08,0x11,0x88,0x00,
+0x00,0x0C,0x02,0xDB,0x00,0x0C,0x00,0xCB,0x01,0x0A,0xB6,0x31,0x04,0xDC,0x80,0x30,
+0x30,0xCE,0xFD,0x7A,0x02,0x0C,0xFE,0xC2,0x01,0x0C,0x18,0x00,0x01,0x0C,0x88,0x30,
+0x01,0x0B,0x0A,0x34,0x08,0x44,0xF0,0xFC,0x0B,0xCB,0x0F,0x6B,0x55,0x11,0x02,0x00,
+0x40,0x4E,0x1B,0x88,0x01,0x01,0x22,0xB0,0xFF,0x0D,0x02,0xFB,0x08,0x11,0x88,0x00,
+0x01,0x10,0x22,0x1C,0x01,0x39,0x18,0xEB,0x02,0x39,0x32,0x6B,0xFF,0x11,0x22,0x8C,
+0xFF,0x65,0x22,0xFB,0xBF,0xE4,0xC9,0x8B,0x0F,0x53,0xC0,0xB0,0x01,0x53,0xFA,0x33,
+0x00,0x0C,0x2A,0xC3,0x80,0x5B,0x2E,0xFB,0x40,0xE4,0x2F,0x6B,0x40,0xE4,0xC9,0x03,
+0x0F,0x11,0xC0,0xB0,0x01,0xFD,0xC1,0x30,0x01,0x11,0x72,0x84,0x10,0x53,0xC0,0x30,
+0x01,0x11,0x72,0x84,0x04,0x67,0x14,0x08,0x80,0x5B,0x3C,0x6B,0x08,0x68,0xB0,0x33,
+0x30,0x67,0xA4,0x0B,0x00,0x0C,0x46,0xC3,0x08,0x53,0xB0,0xB3,0x07,0x53,0x22,0x30,
+0x30,0x53,0xA4,0x8B,0x08,0xD8,0xD1,0x30,0x00,0xD2,0xCF,0x80,0xFF,0x67,0xCE,0x08,
+0x80,0x11,0xCC,0x00,0x05,0x11,0xB4,0x80,0x01,0x11,0x4A,0x80,0x22,0x0A,0x1C,0x28,
+0xE0,0x0E,0x1C,0x18,0x01,0x11,0x1E,0xA0,0x08,0xD8,0x27,0x30,0x07,0x11,0x26,0xB0,
+0x01,0xD2,0x27,0xB4,0x40,0x11,0xFE,0xDC,0x00,0x0C,0xDA,0xDB,0xFF,0x00,0xF6,0xEC,
+0x30,0xCE,0xF7,0x7C,0x40,0x11,0x90,0x84,0x08,0x49,0x77,0x6B,0x40,0x49,0x75,0xEB,
+0x80,0x48,0x77,0xEB,0xB2,0x00,0xB6,0x2E,0x00,0x0C,0x76,0x4B,0x00,0x0C,0x9C,0x5B,
+0xB8,0x00,0xC0,0x3B,0x40,0xCA,0x95,0x87,0x20,0x11,0xFE,0xDC,0x00,0x0C,0x98,0xDB,
+0x80,0x4C,0xF7,0xFC,0xB2,0x00,0xB6,0x2E,0x00,0x0C,0xF6,0x4C,0xD6,0x00,0xC0,0xBB,
+0x40,0xCA,0x95,0x87,0x00,0x0C,0x98,0xDB,0x80,0x11,0xFE,0xDC,0x80,0xCE,0x8D,0xFB,
+0x80,0x48,0xF7,0xEC,0x00,0x0C,0x8E,0x43,0x40,0x9E,0xF7,0x6C,0x00,0x0C,0x9A,0xDC,
+0x80,0xE1,0xF7,0x7C,0xB2,0x00,0xB6,0x2E,0x00,0x0C,0xA4,0xCC,0x00,0x0C,0x70,0xC3,
+0x00,0x0C,0xF8,0x5C,0x18,0x11,0xB8,0x04,0x04,0x40,0x99,0xB0,0x04,0x0C,0xE1,0x30,
+0x04,0x24,0x31,0x31,0x20,0x10,0xBC,0xB8,0x11,0x00,0xAE,0xF3,0x20,0x0B,0xB3,0x7B,
+0xF0,0x04,0x14,0x88,0x60,0x0A,0xB2,0x73,0x20,0x11,0xB4,0xC3,0x01,0xCD,0xB3,0xEB,
+0x05,0x11,0xB4,0x43,0x00,0x11,0xB4,0x43,0x01,0x05,0x14,0x30,0x82,0x05,0x0A,0x80,
+0x30,0x50,0xC1,0x30,0x01,0x0C,0xB8,0x30,0x01,0x0A,0x0A,0x30,0x40,0xE4,0xC9,0x03,
+0x20,0x0C,0xC4,0xE3,0x02,0xC3,0x86,0x01,0x40,0x61,0xF6,0xEC,0x5F,0x01,0x18,0xB8,
+0x80,0x5F,0xCD,0x6B,0x6F,0x01,0x18,0xB8,0x04,0x12,0x1C,0x08,0x22,0x0E,0x1C,0xA8,
+0xE0,0x0E,0x1C,0x18,0x01,0x11,0x1E,0xA0,0x01,0x11,0x4A,0x80,0x10,0x12,0x26,0xB0,
+0x00,0x11,0x4A,0x0C,0x40,0x61,0xE0,0x7B,0x30,0x60,0xA0,0x32,0x00,0x0C,0xF2,0xC3,
+0x20,0x60,0xA0,0xB2,0x80,0x6F,0xDF,0x02,0x04,0x6F,0x19,0x08,0x22,0x0C,0x18,0xA8,
+0xE0,0x0C,0x18,0x18,0x01,0x11,0x1A,0x20,0x01,0x11,0x4A,0x80,0x10,0x12,0xE0,0x32,
+0x00,0x11,0x4A,0x88,0x11,0x00,0x0C,0xF4,0x30,0xCE,0x0D,0x7C,0x0C,0x3F,0x03,0x7C,
+0x01,0x7F,0x02,0xFC,0x0C,0x3F,0xB1,0x0B,0x2E,0xD8,0xB1,0xAB,0x03,0x11,0xB2,0xB3,
+0x04,0xD8,0xE1,0x30,0x03,0x3F,0x0D,0xFC,0x01,0x93,0x0C,0xFC,0x03,0x3F,0xB1,0x0B,
+0x03,0x11,0xB2,0xB3,0x04,0xD8,0x99,0x30,0x04,0x70,0x18,0x32,0x04,0x98,0x48,0x32,
+0x04,0x4C,0x80,0xB2,0x11,0x00,0x2C,0x74,0x08,0x5E,0x18,0x7C,0x00,0x0C,0x1A,0x44,
+0x01,0x7F,0x1E,0x7C,0x20,0x11,0xFE,0xDC,0x00,0x0C,0xF8,0x5C,0xFF,0xFF,0xC4,0xB8,
+0x00,0x0C,0x98,0x5C,0x01,0x93,0x14,0x30,0x48,0x11,0xB8,0x80,0x30,0xCE,0x41,0xFC,
+0x02,0x0A,0x40,0x7C,0x00,0x0C,0x3E,0x44,0x01,0x7F,0x14,0xB0,0x08,0x11,0xB8,0x00,
+0x04,0x0A,0x38,0xEC,0x40,0x49,0x41,0x7C,0x80,0x11,0xFE,0xDC,0x00,0x0C,0x40,0x44,
+0xFF,0xFB,0x18,0xB8,0xB2,0x00,0x6A,0xAE,0x30,0xCE,0x41,0xFC,0xB2,0x00,0xC4,0xAC,
+0x80,0xE4,0xC9,0x87,0x80,0xCE,0x4D,0x7C,0x40,0x48,0x4D,0xFC,0xBF,0xFF,0x18,0xB8,
+0xB2,0x00,0x6A,0xAE,0x00,0x0C,0x52,0x44,0x40,0x01,0x18,0x38,0xB2,0x00,0xC8,0x2D,
+0x00,0x0C,0x5A,0x4C,0x94,0x00,0x18,0xB8,0xB2,0x00,0xC8,0x2D,0x00,0x0C,0x5A,0x54,
+0x04,0x94,0x80,0x36,0x80,0x11,0xFE,0xC4,0x04,0x10,0x80,0xB2,0xB2,0x00,0xB6,0x2E,
+0x00,0x0C,0xF6,0x4C,0xFF,0xFF,0x0C,0xBA,0xFF,0xC1,0x6B,0x64,0x02,0x20,0x80,0x33,
+0x02,0x20,0x84,0x37,0x02,0x20,0xB0,0x33,0x02,0xC2,0x41,0xB0,0x02,0xD8,0x0D,0x32,
+0x02,0xD8,0x85,0xB3,0x02,0xD8,0x41,0xB4,0x08,0x39,0x82,0x6C,0x04,0x39,0x7C,0xEC,
+0x10,0x3A,0x7C,0xEC,0xFF,0x11,0x22,0x8C,0x00,0x0C,0xDA,0xDB,0x04,0x11,0x72,0x00,
+0x10,0x11,0x74,0x84,0xFF,0xFF,0x14,0x38,0x8A,0x62,0x8C,0xAC,0xC0,0x11,0x18,0x80,
+0xB0,0x00,0x64,0x2F,0x80,0xE5,0xCB,0x03,0x08,0x11,0x72,0x84,0xB0,0x00,0xC6,0x28,
+0x0F,0x00,0x14,0x08,0x01,0x0A,0x14,0x18,0x00,0x7C,0xFC,0xFC,0xA0,0x00,0xD2,0xA8,
+0x80,0xE1,0xF7,0xEC,0x08,0xE4,0xF7,0xEC,0x04,0x3C,0xEC,0xB3,0x00,0x11,0x78,0x08,
+0x5F,0x3D,0x7A,0x08,0x08,0xE4,0xC9,0x87,0x02,0x05,0x0A,0x00,0x08,0xE4,0xF7,0x7C,
+0x40,0x3D,0x14,0x08,0xBF,0xF7,0xEF,0x8B,0x00,0xF7,0xEF,0x83,0x04,0xF6,0x79,0xB0,
+0xF7,0xE4,0xC9,0x0F,0x02,0x05,0x0A,0x00,0x00,0xC8,0x91,0x83,0x01,0x0B,0x14,0xB0,
+0x00,0xC8,0x17,0x88,0x00,0x0B,0xC0,0xE4,0xBF,0x3D,0x7A,0x88,0x00,0x11,0xC0,0x89,
+0xA2,0x00,0xF4,0xAE,0x00,0x0C,0xD8,0xDC,0x00,0x0C,0xF6,0x4C,0xC0,0xC8,0xF3,0x6C,
+0x80,0xCE,0xD3,0xFC,0x08,0xC8,0xF3,0xEC,0x80,0xCC,0xD7,0xFC,0x10,0x48,0xF3,0xFC,
+0x01,0x11,0x22,0x9C,0x60,0xCE,0xD7,0xFC,0x20,0xC8,0xF3,0xEC,0x01,0x11,0x22,0x9C,
+0x02,0x20,0x18,0xB0,0x02,0xF4,0x15,0x30,0xB2,0x00,0xF0,0xAD,0x80,0x0F,0xF2,0x7C,
+0xFF,0x20,0xE4,0xE4,0xF0,0x21,0xF2,0xFC,0xFF,0x0A,0xF3,0xF4,0xC0,0x0A,0x15,0x88,
+0x80,0x0A,0xF2,0xF4,0xC0,0x0A,0xF2,0x74,0x01,0x49,0xF3,0xEC,0x20,0x48,0xF3,0x6C,
+0x01,0x11,0x22,0x9C,0x01,0x10,0x22,0x1C,0xA0,0x00,0x76,0xAF,0xFF,0x11,0x22,0x8C,
+0x08,0x5E,0xBC,0x00,0x08,0x11,0xFE,0xC4,0xA0,0x00,0xAE,0x28,0xA2,0x00,0x52,0xAE,
+0xFE,0xBA,0x74,0x89,0x02,0x92,0x71,0x31,0xFE,0xBA,0x74,0x89,0x02,0xB8,0x2C,0x37,
+0x80,0xC9,0x93,0x03,0x04,0x5D,0xF6,0x7C,0xFF,0xFB,0x15,0x6D,0x30,0xCE,0x13,0x6D,
+0x02,0x20,0xC4,0x30,0x49,0x11,0xB8,0x84,0x01,0x11,0xB8,0x84,0xA2,0x00,0x50,0x2D,
+0xA0,0x00,0x28,0x2F,0x9D,0x06,0x0C,0xB8,0x02,0xE0,0x14,0xB0,0x81,0x80,0xB0,0xAB,
+0x02,0xE2,0x14,0x30,0x81,0x82,0xB4,0xAB,0x02,0xE4,0x14,0x30,0x81,0x84,0xB8,0xAB,
+0x02,0xE6,0x14,0xB0,0x81,0x86,0xBC,0xAB,0x01,0x88,0x3C,0xED,0x10,0x88,0xDA,0x6D,
+0x08,0x88,0xE8,0xED,0x04,0x88,0x04,0x6E,0x02,0x88,0x10,0x6E,0x20,0xDB,0x1F,0x6E,
+0x02,0x06,0x22,0x30,0x01,0x11,0x74,0x84,0x04,0xDB,0x4B,0xED,0x03,0xDB,0x7D,0x6D,
+0xFF,0xD8,0xB1,0x6D,0x08,0xDB,0xBD,0xED,0xF0,0xDA,0xC3,0xED,0x10,0xDB,0xD1,0xED,
+0x00,0x0C,0x2E,0x45,0x01,0xCD,0x7B,0x6D,0x11,0x11,0x00,0x80,0x01,0xC8,0x55,0x6D,
+0x00,0x11,0x8C,0x09,0x00,0x0C,0x7A,0xC5,0x70,0x0B,0x15,0x88,0x80,0x80,0xB1,0x0B,
+0x00,0xD8,0x15,0x00,0x08,0xA0,0xB0,0x0B,0x00,0xD8,0x15,0x00,0x01,0x0A,0x14,0x00,
+0x00,0x0C,0x2A,0x59,0x00,0x0C,0x08,0xDD,0x00,0x0C,0x00,0x5D,0x00,0x11,0x2A,0x8B,
+0x00,0x11,0x7E,0x0B,0xB2,0x00,0xD2,0xAD,0x40,0xCE,0x7B,0xFD,0x01,0x11,0x00,0x00,
+0x02,0x20,0x40,0x30,0x00,0x11,0x00,0x08,0xF3,0x11,0xA4,0x5A,0x15,0x07,0xC0,0x3B,
+0x40,0xCA,0x95,0x03,0x04,0x11,0x06,0x05,0x01,0xCD,0xAB,0xED,0xF7,0xA0,0x40,0x89,
+0x11,0x11,0x00,0x80,0xFE,0xC8,0x91,0x8B,0x01,0xC9,0x93,0x03,0x01,0x83,0x90,0x6D,
+0x00,0x0C,0x00,0x5D,0x44,0x8C,0x14,0x28,0x08,0x0A,0x3E,0x83,0x00,0x0C,0xA8,0xC5,
+0x00,0x0C,0x04,0xDD,0xF0,0x8C,0x14,0x88,0x04,0x0A,0x3E,0x83,0x80,0x0A,0xA6,0xF5,
+0x10,0x0A,0x9E,0x75,0x70,0x0A,0x9E,0x75,0x60,0x0A,0xA8,0x65,0x01,0x95,0x2B,0x1B,
+0x00,0x0C,0xA8,0x55,0xFF,0x11,0x2A,0x03,0x00,0x0C,0xA8,0xC5,0x26,0x11,0x9C,0x82,
+0x04,0x11,0xF4,0xDC,0xBF,0x3D,0x7A,0x88,0x00,0x11,0xC0,0x89,0x03,0x11,0x06,0x85,
+0x01,0xCD,0xBB,0x6D,0x11,0x11,0x00,0x80,0x02,0xC8,0xB9,0xED,0x02,0xC9,0x93,0x03,
+0xE8,0x11,0x70,0x5A,0xFF,0x11,0x00,0x85,0x80,0xCE,0xC1,0x7D,0x08,0xC8,0x91,0x03,
+0x08,0x11,0x06,0x05,0x60,0xCE,0xCB,0x6D,0x80,0xCE,0xCF,0xFD,0x0C,0xC8,0xB1,0x8B,
+0x0C,0xD8,0xCF,0xE5,0x20,0x30,0x14,0xB8,0x00,0x0C,0xB2,0xDC,0xF0,0x11,0x04,0x05,
+0x10,0x45,0xD8,0x6D,0x03,0xC8,0xD9,0xFD,0x80,0xC0,0x14,0xB8,0x00,0x0C,0xB2,0xDC,
+0x10,0x11,0x06,0x05,0x1E,0xDC,0x31,0xFD,0x18,0xDC,0xE7,0x7D,0x87,0x11,0xE0,0x5A,
+0x22,0x11,0x00,0x80,0x10,0xE4,0xC9,0x03,0xE7,0xE4,0xC8,0x09,0x1E,0x11,0x08,0x05,
+0x80,0xDC,0xF1,0xED,0x01,0xDC,0xFB,0xED,0x02,0xDE,0xFF,0xED,0x00,0x0C,0x32,0xC5,
+0x01,0xCD,0xF9,0x6D,0x30,0xCB,0xF9,0x7D,0x80,0xCB,0xF9,0x6D,0x80,0xCB,0x97,0x03,
+0x80,0x11,0x08,0x85,0x04,0xCA,0x95,0x03,0x01,0x11,0x08,0x85,0xFD,0xE6,0xCC,0x89,
+0x00,0x11,0x00,0x08,0x00,0x0C,0x8E,0x43,0xFF,0xD9,0x35,0x7D,0x81,0x11,0xB0,0x03,
+0xFF,0x81,0xB2,0x0B,0xFF,0x11,0x02,0x81,0x01,0xA1,0xF6,0xEC,0x00,0x0C,0x24,0x46,
+0x0E,0xDA,0x17,0x6E,0x01,0xDA,0x37,0x7D,0xFE,0xE2,0xC4,0x89,0x82,0x11,0xB0,0x03,
+0x0F,0x82,0xB2,0x0B,0x0F,0x11,0x04,0x81,0x00,0x0C,0x24,0x46,0x83,0x11,0xB0,0x83,
+0x20,0x83,0xB2,0x0B,0x20,0x11,0x06,0x81,0x04,0x3A,0x24,0x7E,0x08,0x00,0x68,0x38,
+0x02,0xD8,0x6D,0x34,0xB0,0x00,0xCC,0x28,0x02,0x05,0x0A,0x00,0x01,0xCA,0x51,0x6E,
+0x0F,0xCB,0x47,0xEE,0x08,0xCA,0x4B,0xEE,0x80,0xC8,0x49,0xEE,0x20,0xC8,0x4B,0x6E,
+0xF3,0x11,0x9E,0x5A,0x00,0x0C,0xFC,0x54,0xDC,0x01,0x1C,0xB8,0xF3,0x11,0x84,0xDA,
+0x00,0x0C,0xFC,0x54,0x10,0xC9,0x93,0x03,0x15,0x11,0x4C,0x46,0x08,0x11,0x4C,0x46,
+0x05,0x11,0x4C,0xC6,0x16,0x11,0x4C,0x46,0x00,0x0C,0xF4,0x5C,0x12,0x11,0x56,0x46,
+0x00,0x0C,0x8E,0xDC,0xB2,0x00,0xD4,0xAE,0x0B,0x11,0x56,0xC6,0x00,0x0C,0xD2,0xD9,
+0xA0,0x00,0x64,0xAA,0x01,0xCA,0x7F,0x6E,0xB2,0x00,0xC4,0x2E,0x02,0x58,0x19,0x30,
+0xFC,0xFF,0x14,0x38,0x83,0x90,0x14,0x28,0x8A,0x0C,0x74,0x2E,0xB2,0x00,0xF0,0xAD,
+0x80,0x0F,0x72,0xEE,0x04,0x0C,0x78,0xB2,0xFC,0xFF,0x14,0x38,0x83,0x90,0xB0,0x2A,
+0x00,0x0C,0x76,0xC6,0x20,0x11,0xFE,0xDC,0x40,0x11,0xFE,0xDC,0x10,0x50,0xC1,0xB0,
+0x20,0x00,0xBC,0x38,0x69,0x11,0xB8,0x80,0x01,0xCA,0x95,0x87,0x18,0x11,0xB8,0x04,
+0x01,0x30,0x14,0x30,0xFF,0x0A,0x90,0xFE,0x01,0x0A,0x90,0xF6,0x06,0x0A,0x1E,0xF7,
+0x02,0x0A,0x2C,0xF7,0xF8,0x0A,0x14,0x88,0xC0,0x0A,0x08,0x77,0x16,0x11,0x2A,0x80,
+0x00,0x0C,0x48,0xDF,0x11,0x11,0x00,0x80,0x01,0xD8,0xF7,0xB3,0x02,0xDA,0x41,0xB0,
+0x02,0x20,0xDC,0x33,0x02,0x46,0x45,0x30,0x20,0x0B,0xB9,0x7E,0x40,0x9E,0xA3,0xFE,
+0x00,0x0C,0x58,0x5F,0x01,0x9D,0xB7,0x6E,0x01,0x80,0x90,0x3B,0x80,0xCA,0x95,0x03,
+0x01,0xCD,0x9B,0x03,0x01,0x45,0x9C,0xB3,0x00,0x0C,0xE4,0xD9,0xB2,0x00,0xD2,0xAD,
+0x01,0xFB,0xB5,0xF6,0x75,0x01,0xC0,0xBF,0x0C,0x02,0xC0,0x3F,0x02,0x9E,0x3D,0x03,
+0x70,0x0B,0xB1,0x0B,0xFF,0xD8,0xC1,0x7E,0x80,0x80,0xC7,0xEE,0x00,0x0C,0xCA,0x46,
+0x01,0x7C,0xC0,0xFE,0xFF,0xFF,0xE4,0x3B,0x00,0x0C,0xCA,0x46,0x01,0x23,0xE4,0xB3,
+0x01,0x22,0xE6,0xB3,0x08,0x11,0xB8,0x00,0x00,0x00,0x90,0xB9,0x8F,0x80,0x15,0x88,
+0x00,0xD8,0x95,0x01,0x0F,0x0B,0xB1,0x8B,0x55,0x11,0x00,0x80,0x01,0x43,0xDB,0xFE,
+0x08,0x11,0xB0,0x83,0x11,0x11,0x00,0x80,0xF0,0x81,0x15,0x88,0x00,0xD8,0x95,0x01,
+0x02,0xF2,0x95,0x31,0x08,0x84,0x95,0xB1,0x08,0xA8,0x94,0xB1,0x08,0x94,0x95,0x31,
+0x01,0xD8,0xF3,0xEE,0x55,0x11,0x00,0x80,0x01,0x43,0xF1,0xEE,0x08,0x11,0x40,0x01,
+0x11,0x11,0x00,0x80,0x10,0x04,0xBC,0xB8,0x1C,0x11,0x18,0xDD,0x01,0xC8,0x91,0x03,
+0x02,0x96,0x71,0xB1,0x01,0xBA,0x74,0x01,0xFE,0x9E,0x3D,0x8B,0xE8,0x11,0x70,0x5A,
+0x49,0x11,0xB8,0x00,0x00,0x0C,0xE4,0xD9,0x84,0x03,0xC0,0x3B,0x80,0xCA,0x95,0x87,
+0x02,0x11,0x48,0x00,0x04,0xCE,0x1D,0xF7,0xC8,0xCD,0x1D,0x98,0x01,0x11,0x1E,0x00,
+0x01,0x30,0x26,0xB0,0x11,0xCD,0x15,0xA8,0x03,0x0E,0x9A,0x8B,0x01,0xCE,0x9D,0x1B,
+0xC0,0x0A,0x1C,0x18,0x02,0x32,0x26,0xB4,0x1D,0x11,0x2A,0x00,0x00,0x0C,0x48,0xDF,
+0x44,0x11,0x00,0x80,0x02,0xDA,0xE1,0xB3,0x10,0xCB,0x97,0x03,0x80,0xE1,0xF7,0x7C,
+0x00,0x0C,0xE4,0xD9,0x2C,0x08,0xC0,0xBF,0x02,0x30,0x22,0x30,0x02,0x32,0x14,0xB0,
+0x00,0xC6,0x39,0x67,0x55,0x11,0x00,0x80,0xFF,0x48,0xF7,0x6C,0x30,0xCB,0xF7,0xEC,
+0x01,0xCB,0x97,0x03,0x44,0x11,0x00,0x80,0x00,0x0C,0xE4,0xD9,0xA0,0x07,0xC0,0x3F,
+0xB2,0x00,0xA8,0xAA,0xEB,0x00,0xF4,0xBB,0xB2,0x00,0x48,0x2A,0xA0,0x00,0xAC,0xA8,
+0x04,0x30,0xB0,0xB3,0x04,0xC8,0xA9,0xB3,0x06,0xD8,0x53,0x67,0xF0,0xD7,0xAF,0x0B,
+0x03,0x11,0xA8,0x33,0xD4,0x01,0x18,0xB8,0xB2,0x00,0xC8,0x2D,0x00,0x0C,0xF6,0x54,
+0x04,0x3A,0x58,0x7F,0x04,0xD8,0x69,0x30,0x02,0x06,0x22,0x30,0xFF,0x11,0x22,0x8C,
+0x01,0xC7,0x14,0xB0,0x00,0xC5,0x14,0x08,0x80,0x0A,0x74,0x6F,0x40,0x0A,0x78,0x6F,
+0x20,0x0A,0x7E,0x6F,0x08,0x0A,0x9C,0x6F,0x04,0x0A,0xB2,0x6F,0x02,0x0A,0xB6,0xEF,
+0x01,0x0A,0xBA,0xEF,0xFF,0x11,0x22,0x8C,0x80,0x11,0x8E,0x81,0x20,0xC9,0x93,0x87,
+0x10,0x11,0x16,0x5D,0x40,0x11,0x8E,0x81,0xE4,0x11,0x88,0xC7,0x04,0xCB,0x84,0x7F,
+0x04,0x11,0x96,0x81,0x08,0x11,0x16,0x5D,0x20,0x11,0x8E,0x81,0xE0,0x11,0x88,0x47,
+0x01,0x11,0x4A,0x80,0x01,0x11,0x1A,0x80,0x04,0x12,0xB0,0xB3,0x01,0x00,0x14,0xB8,
+0x83,0xD8,0xB1,0x2B,0x00,0x00,0x14,0x38,0x84,0xDA,0xB5,0xAB,0x00,0x0C,0xF6,0x4C,
+0xFC,0x0C,0x1C,0x18,0x04,0xD8,0x27,0xB4,0x01,0xC7,0x19,0x88,0x01,0xCB,0x14,0x08,
+0x00,0x0C,0xAA,0xF7,0xFE,0xC7,0x8F,0x8B,0x00,0xC7,0x8F,0x83,0x01,0x0A,0xAC,0xFF,
+0xEF,0x11,0xA4,0xDA,0x08,0x11,0x8E,0x05,0x08,0x11,0x8E,0x81,0xEC,0x11,0x70,0xDA,
+0xE8,0x11,0x88,0xC7,0x04,0x11,0x8E,0x81,0x04,0xC9,0x93,0x87,0x02,0x11,0x8E,0x81,
+0x08,0xC9,0x93,0x87,0x01,0x11,0x8E,0x81,0x40,0xC9,0x93,0x87,0x80,0x11,0x8E,0x81,
+0xDF,0xC9,0x93,0x0F,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x01,0x4E,0x15,0xB0,0x01,0x4C,0x17,0xB0,0x81,0x5A,0x15,0x28,0x02,0x0B,0x0C,0xF8,
+0xB1,0x00,0x9E,0xA9,0x00,0x0C,0x56,0x40,0x20,0x0A,0x14,0x78,0x03,0xE5,0xCB,0x83,
+0x22,0x11,0x9E,0x82,0xDD,0x5A,0xB5,0x0A,0x02,0x0A,0x1A,0xF8,0x02,0xE5,0xCB,0x03,
+0x02,0x11,0x9E,0x02,0x10,0x0A,0x20,0xF8,0x04,0xE5,0xCB,0x03,0x10,0x11,0x9E,0x02,
+0x40,0x0A,0x26,0xF8,0xFD,0x4D,0x9B,0x8A,0xFD,0x5B,0xB7,0x8A,0x10,0xCB,0x3B,0xE8,
+0xEB,0x0A,0x14,0x08,0xFF,0x0A,0x54,0x78,0x20,0xCB,0x55,0x68,0x20,0xCB,0x97,0x03,
+0x97,0xC5,0x8A,0x89,0x7D,0x08,0xC0,0xBB,0x40,0x0A,0x42,0x78,0x01,0xCB,0x97,0x03,
+0x00,0x0C,0x42,0x40,0x40,0x4E,0x9F,0x0A,0x20,0x0A,0x42,0xE8,0xA9,0x44,0x15,0x88,
+0xFF,0x0A,0x54,0x78,0xA9,0x0A,0x46,0x78,0x08,0xE5,0xCB,0x03,0x01,0x0A,0xDC,0xB3,
+0x00,0x0C,0x02,0xDB,0x02,0xE5,0x4F,0x78,0x02,0xEE,0xDD,0x03,0x04,0xE5,0x53,0xF8,
+0x10,0xEE,0xDD,0x03,0xFE,0x3F,0x7E,0x88,0xFF,0x11,0x9E,0x82,0x01,0x11,0x76,0x04,
+0x02,0xF0,0x41,0x30,0x80,0x0A,0x75,0x70,0x81,0x0A,0x47,0x73,0x82,0x0A,0x49,0xF3,
+0x15,0x11,0x2A,0x80,0xB2,0x00,0x46,0x2E,0x00,0x0C,0x1C,0xDB,0xFF,0xF1,0x59,0x60,
+0x02,0x05,0x0A,0x00,0x0F,0xCB,0x97,0x0B,0x40,0x3D,0x7A,0x00,0x01,0x3F,0x7E,0x00,
+0xB1,0x00,0xE4,0x29,0xA0,0x00,0xAC,0xA8,0xF4,0xCB,0x97,0x8B,0x01,0x0C,0x15,0xB0,
+0x01,0x0A,0x88,0xF0,0x81,0x0A,0x8C,0xF0,0x02,0x0A,0x90,0xF0,0xFF,0x0A,0xBC,0x78,
+0x03,0x0A,0x88,0x70,0x04,0x0A,0x88,0xF0,0x05,0x0A,0xE2,0x70,0x15,0x11,0x2A,0x80,
+0x01,0x11,0xE8,0x03,0x00,0x0C,0xA6,0x40,0x02,0x11,0xE8,0x03,0x00,0x0C,0xA6,0x40,
+0x54,0x11,0x02,0x80,0x02,0x05,0x0A,0x00,0x01,0x0D,0x85,0xB2,0x55,0x11,0x00,0x80,
+0x20,0x11,0x9E,0x02,0x20,0x11,0x88,0x82,0x20,0x11,0x9C,0x82,0x22,0x5A,0xB5,0x82,
+0xFD,0x05,0x0A,0x88,0x01,0x01,0x22,0xB0,0x00,0x0C,0xA8,0xC0,0x00,0x0C,0x24,0xDA,
+0x00,0x0C,0xBE,0xDA,0x01,0x11,0xB3,0xF8,0x03,0x11,0x48,0x80,0x04,0xD8,0x81,0x33,
+0x00,0x11,0x48,0x08,0x00,0x0C,0x64,0x50,0x00,0x0C,0x1C,0xDB,0xFF,0xFF,0x40,0xB8,
+0x40,0xEF,0xA7,0x69,0x00,0x0C,0x24,0xC1,0x7A,0x08,0x0C,0x38,0x55,0x11,0x02,0x00,
+0x02,0x05,0x0A,0x00,0x00,0x00,0xB0,0x3A,0x00,0x00,0xB4,0xBA,0xFE,0x3F,0x7E,0x88,
+0x08,0x11,0x80,0x02,0x00,0x11,0x82,0x8A,0x00,0x11,0x80,0x0A,0xC2,0x60,0xC1,0x02,
+0xFF,0xFF,0x94,0x3A,0xFF,0x11,0x9E,0x82,0x01,0x01,0x22,0xB0,0xB2,0x00,0x04,0x2E,
+0x97,0xC5,0x8A,0x89,0xB2,0x00,0x08,0x2B,0x03,0x11,0x90,0xB3,0x08,0x11,0x96,0x03,
+0xFD,0x05,0x0A,0x0C,0x10,0x0D,0xEB,0xF8,0x55,0x11,0x00,0x80,0xEF,0x5A,0xB5,0x8A,
+0x44,0x11,0x00,0x80,0x00,0x0C,0x66,0xDA,0x10,0x0D,0xF5,0x68,0x55,0x11,0x00,0x80,
+0x10,0x5A,0xB5,0x02,0x44,0x11,0x00,0x80,0x00,0x11,0x78,0x8A,0x03,0x11,0x7A,0xB2,
+0x11,0x11,0x62,0xC0,0x00,0x0C,0xA8,0x5A,0x40,0xEE,0x09,0xF9,0xB1,0x00,0x10,0xAA,
+0x00,0x0C,0x12,0x5B,0x00,0x0A,0x44,0x5E,0xBF,0xEE,0xDD,0x8B,0xA9,0xEE,0x67,0x78,
+0x14,0xCB,0x97,0x83,0xF4,0xCB,0x97,0x8B,0x01,0x11,0xE8,0x03,0xFF,0xFF,0x40,0xB8,
+0x00,0x0C,0xBE,0xDA,0xB1,0x00,0x10,0xAA,0x00,0x0C,0x12,0x5B,0x00,0x0A,0x44,0x5E,
+0x08,0xEE,0x1F,0x79,0x00,0x0C,0x48,0xDA,0x00,0x0C,0x66,0x40,0x80,0xEE,0x67,0xF8,
+0x01,0xF6,0xEB,0x33,0x40,0xEF,0xA7,0x69,0x00,0x11,0x02,0x88,0x00,0x11,0x8C,0x09,
+0x01,0x01,0x22,0xB0,0x91,0x00,0x40,0xB9,0x02,0x00,0x40,0xB9,0x01,0x11,0x48,0xDE,
+0xB1,0x00,0xAC,0x29,0xB0,0x00,0xCC,0x28,0xC0,0xCA,0x51,0xEE,0x02,0xF4,0x71,0xF1,
+0x00,0x0C,0x24,0x5B,0xE4,0x11,0x40,0xDE,0x11,0x11,0x42,0x5B,0xB1,0x00,0x8E,0x2C,
+0x44,0x11,0x42,0x5B,0xB0,0x00,0xCC,0x28,0x40,0xCB,0x55,0xE9,0x80,0xCB,0x69,0xE9,
+0x00,0x0C,0x12,0xDA,0x00,0x0C,0xEE,0x49,0x02,0xCB,0xF1,0x69,0xE7,0x11,0xEA,0xDD,
+0x00,0x0C,0xF2,0xC9,0x00,0x0C,0x50,0x46,0x20,0x11,0x06,0x81,0x20,0xE3,0xC6,0x01,
+0x00,0x11,0x42,0x5B,0xB1,0x00,0x8E,0x2C,0x00,0x00,0x90,0xB9,0x00,0x11,0xB2,0x89,
+0x1C,0xD8,0x94,0x31,0x40,0x11,0x72,0x00,0x1C,0xF0,0xF4,0x3B,0x00,0x0C,0xD0,0x41,
+0x84,0x80,0x40,0x38,0x08,0x11,0x44,0xDE,0xFF,0xFF,0x40,0xB8,0x00,0x0C,0x66,0x40,
+0x00,0x0C,0xA8,0x5A,0x55,0x11,0x00,0x80,0x10,0x11,0x80,0x02,0x44,0x11,0x00,0x80,
+0x2D,0x11,0x4A,0xDE,0x02,0x05,0x0A,0x00,0x0F,0xCB,0x97,0x0B,0xB1,0x00,0xE4,0x29,
+0xFD,0x05,0x0A,0x88,0xB0,0x00,0xCC,0x28,0x00,0x0C,0x12,0xDA,0x00,0x0C,0x92,0xC9,
+0x08,0xC7,0x8E,0x79,0x08,0x11,0x8E,0x81,0x01,0xCB,0x92,0xF9,0xFF,0xF1,0x67,0xE0,
+0x00,0x0C,0x50,0x46,0x40,0x11,0x72,0x00,0xB0,0x00,0xCC,0x28,0x55,0x11,0x00,0x80,
+0x40,0x48,0xA1,0xE9,0x44,0x11,0x00,0x80,0xFF,0xF1,0x67,0xE0,0x00,0x0C,0x50,0x46,
+0x90,0x11,0x80,0x82,0x44,0x11,0x00,0x80,0x00,0x0C,0x66,0x40,0xB1,0x11,0x14,0x80,
+0xB1,0x00,0x2A,0xA9,0xFE,0xCD,0x9B,0x8B,0xB0,0x00,0xCC,0x28,0x40,0xCA,0x51,0x6E,
+0xD0,0x01,0x1C,0xB8,0xE8,0x11,0x4C,0xDE,0xB0,0x00,0xCC,0x28,0x40,0xCB,0xC7,0x69,
+0x00,0x0C,0x12,0xDA,0x00,0x0C,0xEE,0x49,0x02,0xCB,0xF1,0x69,0xD0,0x01,0x1C,0xB8,
+0xEB,0x11,0xE8,0x5D,0x00,0x0C,0xF4,0xC9,0x00,0x0C,0x50,0x46,0x20,0x11,0x06,0x81,
+0x20,0xE3,0xC6,0x01,0x00,0x11,0x42,0x5B,0x20,0x11,0xB8,0x00,0x14,0x20,0xF4,0x3B,
+0xB1,0x00,0x10,0xAA,0x01,0x0A,0xC4,0xB3,0x01,0xFA,0x15,0xB0,0x00,0x11,0x16,0x88,
+0xB1,0x00,0x44,0x2A,0xB1,0x00,0x60,0x2A,0x02,0x0C,0x1C,0x98,0xFF,0xC6,0x27,0x08,
+0x01,0xFB,0x27,0xB0,0x02,0x0A,0x26,0xB0,0xB1,0x00,0x8E,0x2C,0x00,0xE2,0x45,0xDE,
+0x44,0x11,0x42,0x5B,0xFB,0xCB,0x97,0x8B,0x00,0x0C,0x66,0x40,0x01,0x11,0xF6,0x41,
+0x02,0x11,0xF6,0x41,0x00,0x11,0xF6,0xC1,0x03,0x11,0xF6,0xC1,0x01,0x0C,0xE4,0x33,
+0xB1,0x00,0x10,0xAA,0x02,0x0C,0x1C,0x98,0x18,0xC6,0x27,0x80,0x01,0xF2,0x27,0xB0,
+0x01,0xF5,0x27,0x30,0x00,0x0A,0x44,0x5E,0x03,0xF2,0x67,0x70,0xFF,0xF5,0x0D,0x6A,
+0x00,0x0C,0xBE,0x58,0x00,0x0C,0x66,0x40,0xFF,0xF5,0xEB,0x9B,0x00,0x0C,0x48,0xDA,
+0x00,0x0C,0x66,0x40,0x55,0x11,0x02,0x00,0x40,0x4E,0x21,0xFA,0x00,0x11,0x82,0x8A,
+0xC0,0x11,0x9E,0x82,0x01,0x11,0x76,0x80,0x01,0x01,0x22,0xB0,0x01,0x10,0x22,0x1C,
+0x01,0x01,0x22,0xB0,0x01,0x11,0x22,0x9C,0x00,0x0C,0xA8,0x5A,0x00,0x0C,0x66,0xDA,
+0x01,0x10,0x9F,0xB3,0x01,0x16,0xED,0xB3,0x01,0x16,0xEB,0xB3,0x01,0x11,0x37,0x7A,
+0x03,0x11,0x48,0x80,0x04,0x12,0x81,0x33,0x00,0x11,0x48,0x08,0x55,0x11,0x00,0x80,
+0x03,0x0A,0x70,0x72,0x04,0x0A,0x70,0xF2,0xFD,0x11,0x9E,0x02,0xEB,0x00,0xF4,0xBB,
+0x10,0x42,0x45,0xEA,0x10,0xFA,0xF5,0x03,0xFD,0x60,0xC1,0x8A,0x44,0x11,0x00,0x80,
+0xB0,0x00,0xC6,0x28,0xE3,0x11,0xEC,0x5D,0x00,0x0C,0x54,0xD2,0xD8,0x01,0x1C,0x38,
+0xE3,0x11,0xE8,0xDD,0x00,0x0C,0x50,0xD6,0x55,0x11,0x02,0x00,0x00,0x11,0x82,0x8A,
+0x10,0x11,0x80,0x02,0x90,0x11,0x80,0x82,0x02,0xFA,0xB5,0x32,0x01,0x01,0x22,0xB0,
+0xD8,0x01,0x1C,0x38,0xE0,0x11,0x4C,0x5E,0xA0,0x00,0xD2,0xA8,0x54,0x11,0x02,0x80,
+0x01,0x0F,0xA1,0x32,0x01,0x0D,0x85,0xB2,0x01,0x0E,0x8B,0x32,0x01,0x01,0x22,0x34,
+0x01,0xA2,0x18,0x38,0x03,0x02,0x1C,0x38,0x03,0x0A,0x7A,0x72,0x08,0xA1,0x18,0x38,
+0x11,0x10,0x1C,0x38,0x00,0x11,0x8C,0x0A,0x3D,0x60,0xC1,0x8A,0x01,0x0C,0x82,0xB2,
+0x50,0x11,0x80,0x82,0x08,0x11,0xC4,0x83,0xFF,0xE2,0xC5,0x9B,0xFF,0xE2,0x85,0x6A,
+0xA0,0x41,0x83,0x82,0x01,0x0E,0x14,0xB0,0x00,0x49,0xC5,0x8B,0xFF,0xE2,0x8D,0x7A,
+0x01,0x0D,0x82,0x32,0x01,0x0F,0x14,0x30,0x00,0xE2,0x99,0xEA,0x00,0x49,0x97,0x7A,
+0x80,0x11,0x9C,0x82,0xE0,0x11,0x82,0x82,0x03,0x11,0x8C,0x82,0x0A,0xE5,0xCB,0x83,
+0x82,0x11,0xDC,0x03,0x00,0x0C,0x02,0xDB,0xFF,0x11,0x9E,0x82,0x44,0x11,0x00,0x04,
+0x04,0xCB,0x97,0x03,0x22,0x11,0x02,0x00,0x97,0xC5,0x8A,0x89,0xEF,0x11,0x4E,0xDE,
+0xFE,0xC7,0x8F,0x8B,0x01,0x01,0x22,0xB0,0x08,0x11,0x88,0x00,0x02,0x00,0x40,0xB9,
+0x00,0x11,0x8A,0x88,0x00,0x11,0x48,0x5E,0xDF,0xE3,0xC6,0x0D,0x01,0x3F,0x7E,0x00,
+0xC0,0x01,0x1C,0x38,0xEC,0x11,0x4C,0x5E,0xB0,0x00,0xC6,0x28,0x08,0xE5,0xD7,0x7A,
+0x80,0xEE,0xD3,0x7A,0x02,0xF4,0xD3,0x72,0xB2,0x00,0x08,0x2B,0x68,0xC5,0x8A,0x01,
+0xB1,0x00,0xA2,0xA9,0x00,0x0C,0x0E,0xDE,0x00,0x0C,0xEA,0x42,0x02,0xE5,0x51,0xEE,
+0xC0,0x01,0x1C,0x38,0xEF,0x11,0xE8,0xDD,0x00,0x0C,0x50,0xD6,0x55,0x11,0x02,0x00,
+0xFE,0x3F,0x7E,0x88,0x01,0x44,0xDD,0x33,0x00,0x0C,0x02,0xDB,0xFF,0x11,0x9E,0x82,
+0x01,0x01,0x22,0xB0,0xF1,0xE5,0xCB,0x8B,0xFF,0x21,0xF8,0x72,0x11,0x11,0x46,0xDE,
+0x00,0x11,0x78,0x8A,0x01,0xEE,0x7B,0xB2,0x01,0xEF,0x7D,0x32,0x01,0xF3,0x7F,0x32,
+0x01,0xCB,0x14,0x08,0xFE,0xC7,0x8F,0x8B,0x00,0xC7,0x8F,0x83,0x11,0xEE,0x23,0x28,
+0xA0,0x00,0xD2,0xA8,0x01,0x43,0xDF,0x33,0x80,0x48,0xE7,0x8B,0xFF,0x11,0x94,0x06,
+0x06,0x11,0x96,0x01,0x68,0xC7,0x14,0x08,0xFF,0x0A,0xEE,0xFD,0x68,0x11,0x8E,0x81,
+0x80,0x11,0x74,0x84,0x02,0x0C,0x1C,0x98,0x10,0xC6,0x27,0x00,0x01,0xEE,0x27,0x30,
+0x01,0xEF,0x27,0xB0,0x01,0xF3,0x27,0xB4,0x02,0x00,0xE1,0x33,0xFF,0xF1,0x23,0xE3,
+0x0F,0x11,0x44,0x46,0x10,0x11,0x44,0xC6,0x11,0x11,0x02,0x00,0x08,0x11,0xB8,0x00,
+0x01,0xC0,0x23,0xB0,0x02,0x11,0x4A,0x80,0x03,0xE0,0x15,0x08,0x1C,0x00,0x98,0x38,
+0xFC,0xE0,0xC1,0x08,0x07,0xE1,0xC1,0xB0,0x1C,0x11,0xC0,0x00,0x06,0x11,0xC0,0xB0,
+0x44,0x0A,0xC0,0xA8,0x00,0x11,0x4A,0x88,0x10,0x04,0xBC,0xB8,0x49,0x11,0xB8,0x00,
+0x01,0x01,0x22,0x34,0x80,0xE1,0xC3,0x03,0x01,0x0C,0x00,0xB4,0x00,0x11,0x62,0xC0,
+0x01,0x0C,0x15,0xB0,0xFF,0x0A,0x52,0x7B,0x01,0x0A,0x68,0x73,0x02,0x0A,0x7A,0x73,
+0x15,0x11,0x2A,0x80,0x02,0x05,0x0A,0x00,0x22,0x11,0x02,0x00,0x01,0x11,0x4A,0x80,
+0x42,0x11,0x00,0x80,0x0C,0xE0,0x21,0xB2,0x22,0x11,0x00,0x80,0x00,0x11,0x4A,0x88,
+0x45,0x11,0x00,0x00,0x04,0x3C,0x39,0xB2,0x01,0x01,0x22,0xB0,0x0A,0x11,0x62,0xC0,
+0x02,0x05,0x0A,0x00,0x22,0x11,0x02,0x00,0x01,0x11,0x4A,0x80,0x0C,0x11,0xC0,0xB3,
+0x00,0x11,0x4A,0x88,0x55,0x11,0x00,0x80,0x04,0x11,0x78,0xB2,0x01,0x01,0x22,0xB0,
+0x00,0x11,0x62,0xC0,0x01,0x11,0x04,0x01,0x01,0xE2,0xC4,0x01,0x00,0x11,0x62,0xC0,
+0x04,0x4C,0x9D,0x7B,0xFB,0xFF,0x18,0xB8,0xB2,0x00,0xA4,0x2E,0x08,0x11,0x90,0xDE,
+0x00,0x0C,0x86,0x5C,0xCA,0x11,0xC6,0x5B,0x0C,0x28,0x95,0x31,0x0C,0x40,0x93,0xF3,
+0x04,0x34,0x95,0x31,0x00,0x00,0x80,0x3A,0x10,0x00,0xBC,0x38,0x00,0xC8,0x42,0xDE,
+0x00,0x0C,0xC0,0x5B,0xA0,0x00,0x4E,0xAB,0x10,0x4C,0xA5,0xFB,0xDF,0x9D,0x3B,0x8B,
+0x20,0x4C,0x15,0x88,0x00,0x9D,0x3B,0x83,0x00,0x0C,0x9E,0xDD,0x00,0x0C,0x7E,0xDC,
+0x14,0x10,0x95,0xB1,0x00,0xC8,0x42,0xDE,0x02,0x20,0x4C,0x33,0x10,0x00,0xBC,0x38,
+0x11,0x48,0x15,0x88,0x11,0x0A,0xBA,0x63,0x04,0x0C,0x81,0xB2,0x00,0x0C,0xA2,0xDD,
+0x00,0x0C,0xBC,0xC3,0x04,0x11,0x80,0x32,0x00,0x0C,0xC0,0x5B,0xA0,0x00,0x48,0xAB,
+0x00,0x11,0x94,0x88,0x04,0x11,0xA4,0xB0,0x04,0x11,0x24,0x05,0x01,0x0C,0x1C,0xB0,
+0x00,0x11,0x1E,0x08,0x46,0x00,0x26,0x38,0x00,0x00,0x26,0x3C,0x30,0xCB,0xD3,0xFB,
+0x40,0xCB,0x97,0x87,0x02,0x8A,0xC4,0x30,0x02,0x38,0x0D,0xB4,0xB1,0x00,0x82,0xAB,
+0x04,0x11,0x4C,0x5D,0x00,0x0C,0xE4,0x43,0x04,0x11,0x4C,0x5D,0x18,0x11,0xB8,0x80,
+0x40,0x11,0x90,0x00,0xBF,0xE5,0xCB,0x8B,0xFF,0xFF,0xC4,0xB8,0xFF,0x11,0x22,0x8C,
+0x04,0x11,0x90,0xDE,0x00,0x0C,0x14,0x5D,0x04,0x94,0x80,0xB2,0xB1,0x00,0x5E,0xAC,
+0x00,0x0C,0xDE,0x43,0x00,0x0C,0x24,0x5D,0x80,0xB5,0xDF,0xEB,0xF2,0x09,0x0C,0xB8,
+0xFF,0xFF,0x4C,0xBB,0x21,0xB5,0x03,0x6C,0x0B,0x0A,0x03,0x74,0x40,0x48,0x05,0x6C,
+0xA0,0x00,0xF6,0x29,0x0C,0x11,0x06,0xC4,0x0B,0x11,0x06,0x44,0xA0,0x00,0xFA,0x29,
+0x00,0x0C,0xD8,0xDC,0x01,0x48,0x13,0xEC,0x00,0x0C,0x14,0x5D,0x80,0x9E,0x3D,0x03,
+0x00,0x0C,0x30,0x45,0x00,0x0C,0x14,0x5D,0x00,0x0C,0x3E,0xC5,0x40,0x4C,0x29,0xFC,
+0x01,0xB6,0x6B,0x33,0x1B,0x48,0x15,0x88,0x01,0x0A,0x28,0xE4,0x80,0x11,0x90,0xDE,
+0xFF,0xFF,0x4C,0xBB,0x02,0x11,0x48,0x00,0x0C,0xD4,0x51,0xB2,0x00,0x11,0x48,0x08,
+0xB1,0x00,0x64,0x2B,0x08,0x49,0xE5,0xEB,0x00,0x0C,0xE6,0xC3,0xEF,0x09,0x0C,0xB8,
+0xB1,0x00,0x5E,0xAC,0x04,0x0C,0xB1,0x33,0x00,0x0C,0xA8,0xDD,0x00,0x0C,0xBC,0x44,
+0x40,0xE5,0xDF,0xEB,0x02,0x8A,0xC4,0x30,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,
+0xA1,0x0A,0x74,0x74,0x34,0x0A,0xF2,0x73,0x46,0x0A,0x66,0x74,0x39,0x0A,0x70,0x74,
+0x41,0x0A,0xC0,0x75,0x5F,0x0A,0x54,0x74,0x27,0x0A,0xD6,0xF3,0x58,0x0A,0x72,0x74,
+0x02,0x11,0x54,0x5D,0x00,0x0C,0xDE,0x43,0x18,0x48,0x15,0x88,0xFF,0x0A,0xD6,0xEB,
+0x01,0x11,0x94,0x80,0x20,0x52,0x14,0x08,0x5B,0x0A,0x14,0x28,0x01,0x0A,0x14,0x18,
+0x03,0x0A,0x14,0x10,0x00,0x48,0xD7,0xFB,0x00,0x0C,0x0A,0xC4,0x00,0x11,0x86,0x09,
+0x46,0x3A,0xD7,0x63,0x01,0x48,0xD7,0x7B,0xB1,0x00,0x74,0xAB,0x00,0x0C,0xE4,0x43,
+0x00,0x0C,0xD6,0xC3,0x00,0x0C,0xDE,0x43,0x02,0x11,0x94,0x80,0x77,0x52,0x14,0x88,
+0x88,0xB5,0x6B,0x0B,0x00,0xB5,0x6B,0x83,0x00,0x0C,0xDE,0x43,0x09,0x0A,0x87,0xF4,
+0x0A,0x0A,0x99,0xF4,0x04,0x1F,0x9F,0x7C,0x01,0x00,0x74,0xBE,0x0B,0x48,0x9F,0xFC,
+0x1B,0x48,0x15,0x88,0x01,0x0A,0xAA,0x74,0x02,0x0A,0xA4,0xF4,0x03,0x0A,0xB0,0x74,
+0x11,0x0A,0xB6,0x74,0x12,0x0A,0xBC,0x74,0x13,0x0A,0xC2,0xF4,0x17,0x11,0x2A,0x00,
+0x02,0x00,0x74,0x3A,0xFF,0x20,0x9C,0x3A,0xF4,0x09,0x70,0x3E,0x34,0x00,0x74,0x3A,
+0xFF,0x00,0x9C,0xBA,0xF9,0x09,0x70,0xBE,0x5F,0x00,0x74,0xBA,0xFF,0x20,0x9C,0x3A,
+0x06,0x0A,0x70,0xBE,0x5F,0x20,0x74,0x3A,0xFF,0x20,0x9C,0x3A,0x09,0x0A,0x70,0xBE,
+0x5F,0x00,0x74,0xBA,0xFF,0x00,0x9C,0xBA,0x04,0x0A,0x70,0x3E,0x46,0x00,0x74,0x3A,
+0xFF,0x00,0x9C,0xBA,0x0B,0x0A,0x70,0x3E,0x39,0x00,0x74,0xBA,0xFF,0x00,0x9C,0xBA,
+0x17,0x0A,0x70,0xBE,0x03,0x00,0x74,0x3E,0x40,0x49,0xD1,0xEC,0x40,0x4C,0xD1,0xEC,
+0x1B,0x48,0x15,0x88,0x12,0x0A,0xEE,0x75,0x01,0xB6,0x6B,0x33,0x00,0x0C,0x8A,0x44,
+0x1B,0x48,0x15,0x88,0x01,0x0A,0xD6,0x64,0x0A,0x0A,0xC3,0x64,0x00,0x0C,0x9E,0x44,
+0x01,0x11,0x94,0x80,0x20,0x52,0x18,0x08,0x5B,0x0C,0x18,0x28,0x01,0x0C,0x18,0x18,
+0xB0,0x00,0x26,0x2F,0x00,0x0C,0x86,0x44,0x00,0x00,0x90,0x38,0x02,0x3A,0xF1,0xF4,
+0x01,0x3A,0xC3,0xF5,0x03,0x3A,0xC3,0x75,0x02,0x3A,0xA1,0xB0,0x00,0x0C,0xF2,0x44,
+0x5F,0x00,0xA0,0x38,0x02,0x4E,0xA3,0x30,0x16,0x11,0xA0,0x30,0x16,0x11,0xA2,0xB0,
+0x00,0x11,0x90,0x08,0x41,0x50,0xEE,0xE5,0x10,0x10,0x90,0x38,0x04,0x24,0xA1,0xB0,
+0x04,0x10,0xA2,0xB4,0x02,0x22,0x0C,0x30,0x02,0xA6,0x41,0x30,0xFF,0xFF,0x14,0x38,
+0x8A,0x20,0x10,0x2D,0x02,0x20,0x14,0x31,0x02,0x06,0x44,0x30,0x01,0x11,0x22,0x9C,
+0x02,0x06,0x44,0x30,0x01,0x10,0x22,0x1C,0x0F,0x11,0x94,0x00,0x01,0x52,0x6C,0xB3,
+0x04,0x4C,0x25,0xED,0x01,0x48,0x25,0xFD,0x88,0xB6,0x25,0x6D,0x40,0x11,0x90,0xDE,
+0x00,0x11,0x94,0x88,0x14,0x52,0x20,0x32,0x02,0x11,0x94,0x80,0x01,0x52,0x6A,0xB3,
+0x7F,0x9E,0x3D,0x8B,0x01,0x11,0x94,0x80,0x80,0x52,0xEE,0xFD,0x80,0x9E,0x3D,0x87,
+0xB1,0x00,0x42,0x2C,0x80,0x49,0x39,0xFD,0xB1,0x00,0x5C,0x2C,0x00,0x0C,0xDC,0xC3,
+0xEF,0x09,0x0C,0xB8,0x80,0x9E,0xBD,0x7C,0xA1,0x00,0x5E,0x2C,0xB1,0x00,0x4C,0xAC,
+0x80,0x49,0xDD,0x6B,0x00,0x0C,0xA2,0xDD,0x00,0x0C,0xB6,0x5C,0x00,0x0C,0xDE,0x43,
+0x01,0x0C,0x14,0x30,0xD8,0x11,0x58,0xC5,0x01,0x0C,0x14,0x30,0xD9,0x11,0x58,0x45,
+0x01,0x0C,0x14,0x30,0xDA,0x11,0x58,0x45,0x01,0x0C,0x14,0x30,0xDB,0x11,0x58,0xC5,
+0x02,0x11,0x48,0x00,0x01,0x11,0x1A,0x80,0x02,0x0C,0x1C,0xB0,0x00,0x12,0x26,0x00,
+0x00,0x11,0x48,0x8C,0xCC,0x01,0x1C,0x38,0xEC,0x11,0x4C,0x5E,0xB0,0x00,0xCC,0x28,
+0xCC,0x01,0x1C,0x38,0xEF,0x11,0xE8,0xDD,0x00,0x0C,0x50,0xD6,0xFB,0x1F,0x3F,0x8A,
+0xA0,0x00,0xEA,0xAA,0x11,0x11,0x02,0x00,0x10,0x02,0xE0,0x39,0xFF,0x11,0x22,0x20,
+0x04,0x11,0xD0,0x31,0x0F,0x02,0xE0,0xB9,0xFF,0x11,0x22,0x20,0x04,0x11,0xD0,0x31,
+0x00,0x00,0xE0,0x39,0x00,0x11,0xB0,0x88,0x32,0x11,0x00,0x00,0x02,0xF2,0x91,0x30,
+0x01,0x01,0x22,0x34,0x20,0x84,0xEE,0x7D,0x20,0x11,0x08,0x01,0x1C,0x11,0x46,0x46,
+0xFF,0xA7,0xD1,0x65,0x01,0x11,0x22,0x9C,0x03,0x0C,0x14,0x08,0xFF,0x0A,0x14,0x10,
+0x01,0x0A,0x14,0x18,0x04,0x0A,0x14,0x18,0x03,0x0A,0x14,0x8C,0x00,0x0C,0x95,0x5D,
+0x22,0x0A,0x7E,0xAE,0x00,0x40,0x95,0xDD,0xFC,0x3F,0x7F,0x0A,0x00,0x3F,0x7F,0x06,
+0xFF,0xFF,0x14,0x38,0x89,0xDA,0xB3,0x2D,0x00,0xE0,0x14,0xB8,0x89,0xD8,0xB3,0xAD,
+0x04,0xD8,0x81,0x36,0x00,0x20,0x80,0xBA,0x00,0x00,0x84,0x3E,0x80,0x11,0x50,0xDD,
+0x02,0xCA,0x95,0x87,0x00,0x0C,0xBE,0x5D,0x77,0xB5,0x6B,0x8F,0xFF,0xFF,0x4C,0x3F,
+0x00,0x0C,0xD6,0xC3,0x00,0x00,0x90,0x38,0x18,0x11,0xA0,0xB0,0x18,0x10,0xA2,0x34,
+0x00,0x00,0x14,0x38,0x88,0x12,0xD0,0x2D,0x88,0x12,0xD0,0x2D,0x01,0x11,0x22,0x9C,
+0x01,0x10,0x22,0x1C,0x01,0x11,0x02,0x80,0x02,0x22,0x44,0x30,0x21,0x11,0x00,0x80,
+0x02,0x22,0x44,0x30,0x01,0x01,0x22,0x34,0x10,0x11,0x02,0x80,0x02,0x22,0x44,0x30,
+0x20,0x11,0x00,0x00,0x02,0x22,0x44,0x30,0x01,0x01,0x22,0x34,0xA0,0x00,0xA4,0x28,
+0xA1,0x00,0x84,0xAA,0xA1,0x00,0x82,0xAA,0xA1,0x00,0x9E,0x2A,0xFF,0x11,0x22,0x8C,
+0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,0x02,0x0A,0x0C,0x30,
+0xFF,0xFF,0x14,0x38,0x84,0x11,0x1C,0x28,0x02,0x06,0x14,0x30,0x83,0x0C,0x18,0x28,
+0x00,0x00,0x14,0x38,0x84,0x0E,0x1C,0x2C,0x09,0x10,0x00,0xB1,0x01,0x11,0x74,0x00,
+0x00,0x0C,0x26,0xC6,0x00,0x0C,0x0E,0xDE,0x00,0x0C,0x18,0x46,0x00,0x0C,0x1C,0xDE,
+0x10,0x11,0x06,0x81,0x04,0x11,0x0E,0x01,0x01,0x11,0x10,0x85,0x00,0x0C,0x1C,0xDE,
+0x80,0x11,0x08,0x01,0x08,0x11,0x10,0x85,0xFF,0x11,0x00,0x01,0xF0,0xEF,0x04,0xB9,
+0x7F,0xFF,0x08,0xB9,0xFF,0xFB,0x0C,0x39,0x10,0x11,0x10,0x01,0x00,0x11,0x02,0x88,
+0x00,0x0C,0x32,0xDE,0x11,0x11,0x00,0x80,0x00,0x0C,0x3A,0x5E,0x01,0x01,0x22,0x34,
+0x11,0x00,0x3A,0x76,0xFF,0x11,0x8C,0x00,0xFF,0x11,0x8E,0x80,0x7F,0x03,0x24,0x39,
+0x02,0x11,0x74,0x84,0xFF,0x11,0x8C,0x00,0xFF,0x11,0x8E,0x80,0x02,0x11,0x74,0x84,
+0xA1,0x00,0x70,0x2A,0xA0,0x00,0x28,0x2F,0xA1,0x00,0xD2,0xA9,0xA0,0x00,0x76,0xAF,
+0xA1,0x00,0x4E,0xA9,0xA1,0x00,0xD8,0xAA,0xA1,0x00,0x72,0xAA,0xA1,0x00,0xA4,0x2A,
+0xA0,0x00,0xAE,0x28,0x01,0x0C,0x1A,0xB0,0x00,0x11,0x58,0xC6,0x00,0x11,0x1A,0x88,
+0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,0x02,0x48,0x15,0xB0,
+0x80,0x0C,0x04,0xA8,0xE2,0x48,0x67,0x2E,0xA0,0x00,0x8A,0xAF,0x02,0x48,0x91,0x32,
+0x00,0x0C,0x5E,0xC6,0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,
+0x02,0x48,0x15,0xB0,0x81,0x0C,0x04,0x28,0xE2,0x48,0x79,0x2E,0xA0,0x00,0x8A,0xAF,
+0x02,0x48,0x91,0x32,0x00,0x0C,0x70,0xC6,0x00,0x11,0x1A,0x88,0x01,0x05,0x0C,0x30,
+0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,0x02,0x48,0x15,0xB0,0x82,0x0C,0x04,0x28,
+0xE2,0x48,0x8D,0xAE,0xA0,0x00,0x8A,0xAF,0x02,0x48,0x91,0x32,0x00,0x0C,0x84,0x46,
+0x00,0x11,0x1A,0x88,0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,
+0x02,0x4C,0x15,0x30,0x80,0x0C,0x04,0xA8,0xE2,0x4C,0xA1,0xAE,0xA0,0x00,0x8A,0xAF,
+0x02,0x4C,0x99,0x32,0x00,0x0C,0x98,0xC6,0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,
+0x02,0x05,0x0A,0x00,0x02,0x4C,0x15,0x30,0x81,0x0C,0x04,0x28,0xE2,0x4C,0xB3,0xAE,
+0xA0,0x00,0x8A,0xAF,0x02,0x4C,0x99,0x32,0x00,0x0C,0xAA,0x46,0xB0,0x00,0x90,0xAF,
+0x20,0x48,0xC1,0x6E,0x00,0x0C,0xC4,0xDE,0xB0,0x00,0xA0,0xAF,0x01,0x11,0x22,0x9C,
+0xB0,0x00,0xA0,0xAF,0x01,0x10,0x22,0x1C,0x02,0x05,0x0A,0x00,0x02,0x4A,0x15,0x30,
+0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x98,0xE2,0x4A,0xD1,0x2E,0x00,0x0C,0xF4,0xC6,
+0x02,0x4A,0x95,0x32,0x00,0x0C,0xC6,0x46,0x02,0x05,0x0A,0x00,0x02,0x4A,0x15,0x30,
+0x01,0x0A,0x04,0xB0,0xFF,0x0B,0x06,0x18,0xE2,0x4A,0xE1,0x2E,0x00,0x0C,0xF4,0xC6,
+0x02,0x4A,0x95,0x32,0x00,0x0C,0xD6,0xC6,0x02,0x05,0x0A,0x00,0x02,0x4A,0x15,0x30,
+0xFF,0x0A,0x04,0x18,0x01,0x0B,0x06,0xB0,0xE2,0x4A,0xF1,0xAE,0x00,0x0C,0xF4,0xC6,
+0x02,0x4A,0x95,0x32,0x00,0x0C,0xE6,0xC6,0xF0,0x04,0xEE,0xED,0xFD,0x05,0x0A,0x0C,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+};
+#endif /* SAS_SEQUENCER_A1 */ 
+
+#if SAS_SEQUENCER_B0 
+
+
+#ifdef SEQUENCER_UPDATE
+/* using V32 Sequencer */
+uint8_t Csb0[] = {
+0x04,0x10,0x88,0xB3,0x88,0x11,0x00,0x80,0x06,0x11,0x48,0x80,0x01,0xC7,0x5F,0x68,
+0xFD,0x05,0x0A,0x88,0x07,0x11,0x48,0x00,0x00,0x00,0x14,0x38,0x02,0x05,0x0A,0x00,
+0x8A,0xD4,0x17,0x28,0xFF,0xD1,0x17,0x70,0x00,0x0C,0x0C,0x5B,0xFD,0x05,0x0A,0x88,
+0x05,0x11,0x48,0x80,0x00,0x00,0x14,0x38,0x02,0x05,0x0A,0x00,0x8A,0xD4,0x25,0xA8,
+0xFF,0xD1,0x25,0xF0,0x00,0x0C,0x0C,0x5B,0xFD,0x05,0x0A,0x88,0x04,0x11,0x48,0x00,
+0xFF,0xC1,0x2D,0xF0,0x00,0x0C,0x5C,0x5B,0xFF,0xC9,0x31,0xF0,0x00,0x0C,0x64,0xDB,
+0x06,0x11,0x48,0x80,0xFF,0xD1,0x37,0xF0,0x00,0x0C,0xB0,0xDE,0x04,0x11,0x48,0x00,
+0xFF,0xDC,0x3D,0xF8,0x00,0x0C,0x2C,0x5C,0x02,0x05,0x0A,0x00,0x80,0xE1,0x45,0x68,
+0x02,0xE2,0x41,0x30,0x02,0xE0,0x0D,0xB4,0x01,0x35,0xB0,0xE9,0xFF,0xCD,0xFD,0xE0,
+0xFF,0xC5,0x7B,0xE0,0xFF,0xD1,0x69,0x61,0x00,0x0C,0x02,0xC0,0x06,0x11,0x48,0x80,
+0x01,0x00,0x8C,0xB3,0x02,0x20,0x88,0xB3,0x04,0x06,0x80,0xB3,0x01,0xC7,0x8F,0x03,
+0x04,0x11,0x48,0x00,0x88,0x11,0x00,0x80,0x00,0x0C,0x3E,0xC0,0xFE,0xC7,0x8F,0x8B,
+0x01,0xC6,0x01,0xB0,0x02,0xC4,0x41,0xB0,0x02,0xC2,0x0D,0x30,0x02,0xC0,0x0D,0xB0,
+0x07,0x11,0x48,0x84,0x02,0x20,0xC4,0x33,0x02,0x06,0xC0,0x33,0x02,0xE0,0x0D,0xB4,
+0x80,0xE1,0xC3,0x03,0x00,0x0C,0x02,0xC0,0x01,0x11,0x2A,0x80,0x02,0x11,0x2A,0x80,
+0x01,0x05,0x0A,0x84,0x80,0x00,0x1C,0x38,0x02,0xC4,0x41,0xB0,0x02,0x08,0x27,0xB0,
+0x01,0x0A,0x15,0xB0,0xC0,0x0A,0x86,0xF0,0xD0,0x0A,0xA6,0x60,0x00,0x04,0x27,0x00,
+0x44,0x04,0x19,0xA8,0x01,0x11,0x1A,0x80,0x01,0x12,0x08,0x32,0x01,0x0C,0x18,0x18,
+0x04,0x12,0x26,0xB0,0x01,0x0C,0x19,0x1A,0x01,0x0C,0x15,0xB0,0x00,0x0B,0xA1,0xE0,
+0x5A,0x00,0x0C,0x38,0xD0,0x0A,0x9F,0xF0,0x07,0x11,0xD2,0x44,0x05,0x11,0xD2,0xC4,
+0xFF,0x04,0xBF,0x68,0x02,0x00,0x41,0x30,0x00,0x0C,0xBE,0x40,0x01,0x4D,0x15,0xB0,
+0x01,0x0A,0x26,0xB0,0x04,0x3C,0xB1,0x33,0xFF,0x0A,0xB2,0x68,0x02,0x30,0xB0,0xB3,
+0x00,0x00,0xB4,0x3B,0x04,0xD8,0x27,0x30,0x02,0x00,0x0D,0xB0,0x02,0x0E,0x0C,0xB0,
+0xB1,0x00,0xAE,0x28,0x02,0x06,0x1C,0xB0,0x02,0x06,0x40,0xB0,0x02,0x11,0x4A,0x80,
+0x01,0xF4,0x27,0xB0,0x00,0x11,0x4A,0x88,0x01,0x4E,0x22,0x30,0xFF,0x21,0xCC,0x70,
+0xFF,0x0E,0xCC,0x78,0x10,0x4D,0x7E,0x78,0x02,0x20,0x88,0xB3,0xFF,0x21,0xD2,0xE0,
+0xFF,0xFF,0x8C,0xBB,0x02,0x11,0x4A,0x80,0x04,0xF0,0x81,0x30,0x04,0xEC,0x89,0x30,
+0x03,0xE8,0x15,0x88,0x44,0x0A,0x14,0xA8,0x00,0x11,0x4A,0x88,0x80,0x0E,0x90,0x98,
+0xFF,0x0A,0x96,0x08,0x1C,0x11,0x6E,0x80,0x00,0x0C,0x6A,0x58,0x40,0x35,0x02,0xF8,
+0x40,0x11,0x6A,0x00,0x04,0x11,0x68,0x80,0x02,0x11,0x4A,0x80,0x04,0x40,0xE0,0x33,
+0x10,0x4D,0xF8,0xF8,0x04,0xE8,0xE1,0x33,0xFC,0xF0,0xE1,0x0B,0x01,0xF4,0xE9,0x93,
+0x00,0x11,0x4A,0x88,0x00,0x0C,0x70,0xC0,0x07,0x11,0x48,0x00,0xFF,0xD1,0x03,0x70,
+0xB1,0x00,0x82,0xA8,0xFF,0x0E,0xFE,0x68,0x04,0x11,0x48,0x00,0x02,0x20,0xC8,0x33,
+0x80,0x00,0x1C,0x38,0x02,0xCC,0x41,0x30,0x17,0x4D,0x17,0xF1,0x0C,0x4D,0x1B,0xF1,
+0x0B,0x4D,0x1B,0x71,0x0A,0x4D,0x2D,0xF1,0x1C,0x11,0x2A,0x80,0x30,0x50,0x27,0xB0,
+0x00,0x0C,0x2E,0xC1,0x04,0x0C,0x27,0x30,0x00,0x00,0x26,0xB8,0x14,0x00,0x26,0xB8,
+0x08,0x11,0x26,0xB0,0x14,0x10,0x27,0x30,0x0C,0x28,0x27,0xB0,0x02,0x46,0x45,0x30,
+0x04,0xB0,0x27,0xB0,0x00,0x0C,0x2E,0xC1,0x10,0x10,0x27,0xB0,0x02,0xE4,0x41,0x30,
+0x44,0x0C,0x18,0xA8,0x01,0x11,0x1A,0x80,0x01,0x0C,0xD2,0x33,0x80,0xFF,0x14,0xB8,
+0x83,0x0E,0x14,0xA8,0xB1,0x00,0x54,0xA9,0x00,0x11,0xD0,0x8B,0x80,0xE8,0xD1,0x2B,
+0x08,0x12,0x80,0xB0,0x01,0x0A,0x90,0x30,0x07,0x0C,0x18,0x18,0x30,0x12,0x14,0x08,
+0xFF,0x0A,0x96,0x08,0x1C,0x11,0x6E,0x80,0x02,0x08,0xCD,0x33,0x00,0x0C,0xC8,0x5C,
+0x02,0xCC,0x41,0x30,0x02,0xE6,0x79,0xB2,0x02,0xE8,0x7D,0xB2,0x00,0x0C,0x6A,0x58,
+0x40,0x35,0x02,0xF8,0x40,0x11,0x6A,0x00,0xFF,0xFF,0xB0,0xBB,0x01,0x11,0x1A,0x80,
+0xCC,0x11,0x6C,0xDF,0x00,0x0C,0x70,0x5F,0xFF,0xCD,0xFD,0xE0,0x00,0x0C,0x70,0xC0,
+0x02,0xD0,0x41,0xB0,0x02,0x0C,0x19,0xB0,0x80,0x00,0x14,0xB8,0xB1,0x00,0xE0,0x2E,
+0x80,0x0F,0x76,0xE9,0x80,0x00,0xFC,0x3A,0x00,0x0C,0x78,0xC1,0x02,0x0C,0xFD,0x32,
+0x08,0x10,0x81,0xB0,0x08,0x18,0x97,0x80,0x01,0x7E,0x91,0xB0,0x1C,0x11,0x6E,0x80,
+0x00,0x0C,0x6A,0x58,0x40,0x35,0x02,0xF8,0x40,0x11,0x6A,0x00,0x08,0x40,0x20,0xB2,
+0x08,0x50,0x81,0x30,0xFF,0x58,0x97,0x08,0x01,0x7E,0x91,0xB0,0x1C,0x11,0x6E,0x80,
+0x00,0x0C,0x6A,0x58,0x40,0x35,0x02,0xF8,0x40,0x11,0x6A,0x00,0x08,0x40,0xA0,0x32,
+0x02,0x7E,0x15,0xB0,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,
+0x83,0x0C,0x19,0x2A,0x02,0x0C,0x15,0xB0,0x89,0x10,0x6A,0x29,0xFF,0xFF,0xB0,0xBB,
+0x01,0x11,0x1A,0x80,0xD0,0x11,0x6C,0x5F,0x00,0x11,0x72,0xDF,0x00,0x0C,0x70,0xC0,
+0x00,0x0C,0xD8,0xD9,0x01,0x11,0x6A,0x00,0x02,0x11,0x4A,0x80,0xFC,0xE0,0x81,0x88,
+0x07,0xE1,0x83,0xB0,0x03,0xE0,0x15,0x08,0x44,0x0A,0x14,0xA8,0x00,0x11,0x4A,0x88,
+0x80,0x11,0x90,0x00,0x08,0x0A,0x96,0x00,0x1C,0x11,0x6E,0x80,0x01,0x00,0x14,0xB8,
+0x83,0x30,0x60,0x28,0x00,0x0C,0x6A,0x58,0x40,0x35,0x02,0xF8,0x40,0x11,0x6A,0x00,
+0x80,0x80,0x00,0x32,0x00,0x0C,0xEC,0x59,0x88,0x11,0x00,0x80,0x00,0x0C,0x70,0xC0,
+0x06,0x11,0x48,0x80,0xD6,0x01,0x18,0x38,0xFF,0xD7,0xE3,0xE1,0xDA,0x01,0x18,0x38,
+0xFF,0xDB,0xEB,0xF1,0x02,0x0C,0x1C,0xB0,0x02,0x12,0x40,0xB0,0x02,0x00,0x27,0x30,
+0x04,0x11,0x48,0x9C,0x14,0x11,0x2A,0x00,0x02,0x11,0x4A,0x80,0x08,0x00,0xC1,0xB3,
+0x00,0x11,0x4A,0x88,0xC0,0x0A,0x15,0x88,0xFF,0x0A,0x0A,0x7A,0x40,0x0A,0x74,0x72,
+0x80,0x0A,0x9E,0xF2,0x01,0x0A,0x15,0xB0,0xC0,0x0A,0xBE,0xF2,0xC3,0x0A,0xF4,0x72,
+0xC4,0x0A,0x08,0xF2,0xC6,0x0A,0xF6,0xF2,0xD0,0x0A,0xC0,0x72,0x15,0x11,0x2A,0x80,
+0xA1,0x00,0x26,0xAB,0x08,0x0A,0x11,0x72,0x03,0x0A,0x11,0xF2,0x04,0x0A,0x2F,0x62,
+0x08,0x48,0x1D,0xFA,0x02,0x46,0x45,0x30,0x08,0x11,0x66,0x5C,0x02,0x52,0x21,0xB3,
+0x80,0xBF,0x1D,0x7A,0x00,0x0C,0x28,0xDF,0x03,0x0A,0x21,0x62,0xA1,0x00,0xE6,0x2A,
+0x08,0x0A,0x2F,0xF2,0x04,0x48,0x2F,0x7A,0xB1,0x00,0xFE,0x2E,0x00,0x0C,0x72,0x4F,
+0x02,0x20,0x0C,0xB0,0x00,0x0C,0xE4,0xDF,0x02,0x06,0x40,0xB0,0xB1,0x00,0xBC,0xA9,
+0xB1,0x00,0xC2,0x28,0x00,0x0C,0x70,0xCF,0x02,0x46,0x45,0x30,0x01,0x00,0x14,0xB8,
+0x83,0xAC,0x59,0x2B,0x0F,0x0A,0xD3,0xF6,0x10,0x9E,0x43,0xFA,0x09,0x0A,0x43,0xE2,
+0x2F,0x12,0x4F,0xF2,0x02,0xA0,0xAD,0xB3,0x02,0x20,0x40,0x33,0xFF,0xFF,0x04,0x3A,
+0xFF,0xD7,0x4D,0xF2,0xA1,0x00,0xA8,0x2F,0xC1,0x11,0x6A,0x47,0x02,0x20,0xA8,0x33,
+0xC0,0x11,0x74,0xDF,0x00,0x0C,0x5A,0x4A,0x02,0xD4,0x41,0x30,0xFF,0xFF,0x40,0xBB,
+0x00,0x0C,0x42,0xC2,0x02,0x20,0x14,0xB0,0xFF,0xD7,0x65,0xF2,0x02,0xD6,0x41,0xB0,
+0x02,0xD4,0x01,0x32,0x00,0x0C,0x66,0xC2,0x02,0xD4,0x81,0x33,0x02,0x0A,0x40,0xB0,
+0x02,0x00,0xAD,0xB3,0x02,0xD4,0x41,0x30,0x02,0x0A,0x04,0x32,0x02,0xD6,0x01,0xB2,
+0xFF,0xD7,0x3B,0x65,0x02,0x20,0x84,0x37,0xB1,0x00,0xBC,0xA9,0xB1,0x00,0xC2,0x28,
+0x80,0x0B,0x87,0x7A,0x00,0x11,0x18,0x08,0xB0,0x00,0x78,0xAF,0x04,0x0C,0x81,0xB2,
+0x02,0x46,0x45,0x30,0x01,0x00,0x14,0xB8,0x83,0xAC,0x59,0x2B,0x00,0x04,0x18,0xB8,
+0xB1,0x00,0x74,0x29,0xFF,0xFF,0x08,0x3A,0x02,0x46,0x45,0x30,0xC8,0x11,0x5E,0xDC,
+0x02,0xA2,0xAD,0x33,0x02,0x20,0x44,0xB3,0x00,0x0C,0x98,0xD2,0xA1,0x00,0xB0,0x2F,
+0xFF,0x8E,0x9D,0x6A,0xC9,0x11,0x6A,0xC7,0x02,0x20,0x18,0x37,0x02,0x20,0x0C,0xB0,
+0x44,0x0B,0x15,0xA8,0x00,0x0B,0x01,0x80,0x02,0x06,0x40,0xB0,0xFF,0xFF,0x00,0xBA,
+0xFF,0xE5,0xB3,0x62,0xFF,0xE7,0xB5,0xE2,0x02,0x20,0xC8,0x33,0x02,0x20,0xCC,0xB3,
+0xA1,0x00,0xA8,0xA8,0xFF,0xE7,0xBD,0xF2,0x02,0xE6,0xA9,0xB3,0x02,0x20,0xCC,0xB3,
+0x02,0xD4,0x41,0x30,0x02,0xE6,0x01,0x36,0x1B,0x11,0x2A,0x00,0x07,0x11,0xCA,0x42,
+0x00,0x00,0x44,0x38,0x00,0x11,0x16,0x88,0x01,0x0B,0x15,0x30,0x83,0x8E,0x1D,0x2B,
+0x05,0x11,0xCA,0xC2,0x01,0x0C,0x48,0x30,0x00,0x11,0x08,0x0A,0x00,0x11,0x0A,0x8A,
+0x00,0x11,0x18,0x8A,0xFF,0xFF,0x04,0x3A,0xFF,0xFF,0x00,0xBA,0xFF,0xD1,0xE1,0x62,
+0x02,0x20,0xA0,0xB3,0x02,0x20,0xA4,0x33,0x01,0x11,0xB0,0x83,0x00,0x0C,0xE8,0xC2,
+0x02,0x20,0x14,0xB0,0x02,0xD2,0x41,0x30,0x02,0x0A,0x04,0x32,0x02,0x0A,0xA4,0xB3,
+0x06,0x11,0x48,0x80,0x01,0xC7,0x15,0x30,0x04,0x11,0x48,0x00,0x01,0x0A,0x3A,0xED,
+0x01,0x0C,0x48,0x30,0x00,0x0C,0x4E,0x43,0xD1,0x11,0x6A,0xC7,0x02,0x46,0x45,0x30,
+0xB1,0x00,0xFE,0x2E,0x00,0x0C,0x72,0x4F,0xFD,0x0B,0x09,0xE3,0xFD,0x8F,0x09,0xE3,
+0x04,0x9F,0x0B,0x6B,0x04,0x11,0x66,0x5C,0x02,0x20,0x60,0xB3,0xA1,0x00,0x0E,0x2F,
+0x2A,0x11,0x72,0x47,0x2B,0x11,0x72,0xC7,0xC0,0x01,0x18,0xB8,0x01,0xD6,0x15,0x30,
+0x00,0x0C,0x18,0x98,0x01,0x12,0x00,0x30,0xC8,0x01,0x18,0x38,0x0F,0x00,0x14,0x08,
+0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,0xFF,0x12,0x5A,0xFB,0xFF,0x0C,0x18,0x98,
+0x02,0x0C,0x0C,0x30,0x02,0x0E,0x0C,0xB0,0xB1,0x00,0x82,0xA8,0xFF,0x0E,0x2E,0x7B,
+0xFF,0xD1,0x25,0x63,0x04,0x06,0x22,0x30,0x00,0x0C,0x56,0x43,0x01,0x0C,0xC0,0x33,
+0x02,0x06,0x1C,0xB0,0x02,0x06,0x18,0x30,0xFF,0xFF,0x14,0x38,0x83,0xD4,0xA9,0x2B,
+0xFF,0x12,0x26,0x18,0x01,0xD6,0xAD,0x1B,0x07,0xD6,0xAD,0x8B,0xFF,0x0C,0x18,0x98,
+0xFF,0x12,0x4C,0x7B,0xC0,0x01,0x1C,0x38,0x01,0xD7,0x15,0xB0,0x00,0x0E,0x1C,0x98,
+0x01,0x00,0x26,0xB0,0x07,0x0E,0xAE,0x8B,0x00,0xE0,0x6F,0x5F,0x02,0x05,0x0A,0x00,
+0x00,0x00,0x14,0x38,0x8A,0xD4,0x57,0xAB,0xFF,0xD1,0x0D,0x63,0x04,0x11,0x48,0x00,
+0x88,0x11,0x00,0x04,0x25,0x11,0x2A,0x80,0xC0,0x11,0x6C,0x5B,0x00,0x0C,0x76,0xCF,
+0x00,0x11,0x6E,0x5F,0x88,0x11,0x00,0x04,0xC8,0x11,0x6C,0xDB,0x00,0x0C,0x76,0xCF,
+0x01,0x11,0x6E,0xDF,0x88,0x11,0x00,0x04,0x01,0x11,0x1A,0x80,0x02,0x05,0x0A,0x00,
+0xFF,0xFF,0xB0,0xBB,0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x18,0x02,0x0C,0x0C,0x30,
+0x02,0x46,0x45,0x30,0x20,0x0B,0x97,0x7B,0x40,0x9E,0x17,0xEC,0x10,0x9E,0x83,0x7B,
+0x08,0x48,0x17,0x6C,0x01,0x9D,0x97,0x7B,0x02,0x9E,0x97,0x7B,0x04,0x4C,0x97,0xEB,
+0x04,0x49,0x97,0xEB,0x10,0x9E,0x91,0x7B,0x09,0x0A,0x91,0x63,0x2F,0x12,0x97,0x73,
+0x20,0x9D,0x17,0xEC,0xB1,0x00,0xD4,0xAE,0x00,0x0C,0x16,0xCC,0x01,0x9C,0x15,0xB0,
+0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,0x00,0xAF,0x15,0x88,0x02,0x06,0x44,0x30,
+0xFF,0x0A,0xAA,0x6B,0x80,0xBF,0x17,0xEC,0x09,0x11,0x6E,0x03,0x00,0x0C,0x28,0xDF,
+0x00,0x0C,0x1A,0x44,0x80,0xBF,0xB9,0x7B,0x09,0xB7,0xB1,0xE3,0x00,0x11,0x7E,0x0B,
+0x02,0x0A,0x0C,0x30,0x00,0x0C,0x50,0xDF,0x02,0x06,0x14,0x30,0x00,0x0C,0x24,0x4C,
+0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,0x00,0xAE,0xC1,0x08,0x02,0x06,0x44,0x30,
+0x02,0x62,0x14,0xB0,0x01,0x0B,0x1A,0x6C,0xFF,0x0A,0x1A,0x74,0x04,0x9D,0xDD,0xFB,
+0x02,0x0A,0x0C,0x30,0x00,0x11,0x4C,0x5C,0x04,0x11,0x14,0x30,0x01,0xA8,0x19,0x30,
+0x01,0xA9,0x15,0xB0,0xB1,0x00,0xE0,0x2E,0x02,0x06,0x14,0x30,0x80,0x0F,0xDC,0xFB,
+0x01,0x11,0x4C,0xDC,0x00,0x0C,0x1A,0x44,0x02,0x06,0x18,0x30,0x02,0x20,0x0C,0xB0,
+0x02,0x22,0x0C,0x30,0x01,0x0A,0x00,0x30,0x02,0x06,0x44,0x30,0x02,0x06,0x40,0xB0,
+0x00,0x0C,0x6C,0xDF,0x04,0x4C,0xFB,0x7B,0xFF,0x03,0xFB,0xF3,0x02,0x20,0x0C,0xB0,
+0x02,0x02,0x41,0xB0,0x01,0x0C,0x18,0x18,0x00,0x0C,0x6A,0xDF,0x02,0x06,0x40,0xB0,
+0xFF,0xFF,0x04,0x3A,0x04,0x9D,0xE3,0xFF,0xC0,0x0C,0xE2,0xF7,0xFF,0xAA,0xE3,0xFF,
+0x02,0x20,0x0C,0xB0,0x01,0x11,0x14,0x00,0x00,0xAA,0x0B,0xE4,0xB1,0x00,0x68,0xAF,
+0x00,0x0C,0x12,0xC4,0xB1,0x00,0x62,0xAF,0xFF,0x21,0x12,0xF4,0x01,0x0A,0x14,0x18,
+0x00,0x0C,0x04,0x44,0x02,0x06,0x40,0xB0,0x01,0x11,0x22,0x9C,0x00,0x0C,0x50,0xDF,
+0x00,0x0C,0x24,0x4C,0x02,0x06,0x18,0x30,0xFF,0x01,0x2B,0x74,0x02,0x20,0xB0,0x33,
+0x02,0x00,0x41,0x30,0x00,0x0C,0x76,0xC3,0x02,0x06,0x18,0x30,0xB1,0x00,0xD8,0x29,
+0xFF,0x21,0x76,0x63,0x01,0x10,0x22,0x1C,0x00,0x11,0x00,0x08,0x02,0x05,0x0A,0x00,
+0xFF,0xE5,0x43,0xF4,0x02,0xE4,0x41,0x30,0xFF,0xFF,0xC8,0xBB,0x01,0x00,0x0E,0xB0,
+0xFF,0x07,0x14,0x90,0x00,0xDC,0xB9,0x0B,0x0A,0x11,0x6E,0x5F,0x02,0x05,0x0A,0x00,
+0xFF,0xDC,0x49,0x7C,0x11,0x00,0x00,0x98,0x01,0x00,0x14,0x30,0x00,0xDD,0x31,0xE4,
+0xFD,0x05,0x0A,0x88,0x88,0x11,0x00,0x04,0x02,0xA8,0x15,0x30,0x01,0x0A,0x04,0xB0,
+0x01,0x0B,0x06,0x98,0xFF,0x0C,0x56,0x7C,0xFF,0x0B,0x06,0x18,0xE0,0xA8,0x5B,0xAC,
+0xFF,0x11,0x22,0x8C,0x02,0xA8,0x51,0x33,0x00,0x0C,0x4C,0x44,0x02,0x20,0x0C,0xB0,
+0xB0,0x00,0x74,0xAF,0x02,0x06,0x40,0xB0,0xFF,0x11,0x22,0x8C,0xA1,0x00,0xB8,0xAF,
+0xA1,0x00,0xC8,0x2F,0x3C,0x00,0x0C,0x38,0x02,0x34,0xA8,0x33,0x02,0x36,0x40,0xB0,
+0xF8,0xD4,0x15,0x08,0xC0,0x0A,0xB0,0x74,0xD0,0x0A,0xB0,0xF4,0x01,0xD4,0x15,0xB0,
+0x00,0x11,0x16,0x88,0x3F,0x02,0x18,0xB8,0x83,0x0C,0x0C,0xAC,0x00,0x0C,0x98,0xC5,
+0x00,0x0C,0xA2,0xC5,0x00,0x0C,0xAE,0xC5,0x00,0x0C,0xBA,0xC5,0x00,0x0C,0xE6,0x44,
+0x00,0x0C,0x40,0xC5,0x00,0x0C,0xDC,0x44,0x00,0x0C,0x3C,0x45,0x00,0x0C,0xD4,0x45,
+0x00,0x0C,0xE8,0x45,0x00,0x0C,0xFE,0xC5,0x00,0x0C,0x1A,0xC5,0x00,0x0C,0x6E,0xC5,
+0x00,0x0C,0xA8,0xC5,0x00,0x0C,0x6A,0x45,0x00,0x0C,0xC2,0xC5,0x00,0x0C,0x60,0x45,
+0x00,0x0C,0xF0,0x45,0x00,0x0C,0xFA,0x45,0x00,0x0C,0x02,0xC6,0x00,0x0C,0x70,0x47,
+0x00,0x0C,0xE0,0xC6,0x00,0x0C,0x78,0x46,0x00,0x0C,0x04,0xC6,0xA1,0x00,0xD8,0xAF,
+0x07,0xD4,0xC9,0xFC,0x01,0x05,0xAD,0xB3,0x07,0xD4,0x0B,0x8A,0x44,0x05,0x1D,0xA8,
+0x01,0x11,0x1E,0x00,0x00,0x11,0x26,0x88,0xFF,0x04,0xC5,0xFC,0x44,0xD6,0x1D,0x28,
+0x01,0x11,0x1E,0x00,0x01,0x05,0x27,0xB4,0x01,0x05,0x09,0xB2,0xC5,0x11,0x6A,0xC7,
+0x01,0x0C,0x19,0x1A,0x01,0x0C,0x15,0xB0,0x00,0x0B,0x3B,0xE5,0x07,0x11,0xD2,0x5C,
+0xA1,0x00,0xAE,0xA8,0x01,0x0C,0x48,0x30,0x02,0xD0,0x15,0x30,0x88,0x20,0xDA,0x2C,
+0xB1,0x00,0x9E,0x28,0x04,0x11,0x48,0x84,0x80,0x0B,0xE1,0x7C,0x00,0x0C,0x40,0xDE,
+0xFF,0xFF,0x04,0x3A,0x00,0x0C,0x60,0x5D,0xA1,0x00,0xA4,0x2F,0x80,0x0B,0xEB,0x7C,
+0x00,0x0C,0x40,0xDE,0x00,0x0C,0x60,0x5D,0x02,0x20,0x0C,0xB0,0x02,0x46,0x45,0x30,
+0x02,0x02,0x0D,0x30,0xFF,0xFF,0x04,0x3A,0x02,0x06,0x40,0xB0,0xC0,0x11,0x5E,0x5C,
+0x00,0x0C,0xFC,0x4C,0xFF,0xFF,0x40,0xBB,0xFF,0x21,0x18,0x75,0x02,0x02,0xB1,0xB3,
+0x40,0x49,0x07,0x7D,0x00,0x0C,0xC6,0x5D,0x00,0x0C,0x14,0x45,0x02,0xA0,0xAD,0xB3,
+0x02,0x20,0x40,0x33,0xFF,0xFF,0x04,0x3A,0xFF,0xD7,0x13,0xF5,0xB1,0x00,0xA8,0xAF,
+0x00,0x0C,0x14,0x45,0xC1,0x11,0x6A,0x5F,0x02,0xD8,0x41,0x30,0xFF,0x21,0xFE,0xE4,
+0xA1,0x00,0xA2,0x2F,0x02,0x46,0x45,0x30,0x02,0x06,0xB1,0x33,0xFF,0xFF,0x0C,0xBA,
+0x40,0x49,0x35,0x6D,0x04,0x4C,0x2B,0xFD,0xB1,0x00,0xA4,0xAF,0xB0,0x00,0x4E,0xAA,
+0x00,0x0C,0x36,0x45,0x80,0x49,0x31,0xED,0x00,0x0C,0x86,0x5A,0x00,0x0C,0x36,0x45,
+0xB1,0x00,0xCA,0x29,0x00,0x0C,0x36,0x45,0x00,0x0C,0xC6,0x5D,0x02,0xD8,0x41,0x30,
+0xFF,0x21,0x1A,0x65,0xFF,0x11,0x22,0x8C,0x00,0x0C,0x52,0xDD,0xA1,0x00,0xA4,0x2F,
+0x02,0x04,0x0D,0x30,0x00,0x0C,0x52,0xDD,0x02,0x06,0x08,0x32,0x02,0x20,0x0C,0xB0,
+0x02,0x46,0x45,0x30,0x02,0x04,0x0D,0x30,0xFF,0xFF,0x08,0x3A,0x02,0x06,0x40,0xB0,
+0xA1,0x00,0x80,0x2F,0x80,0x49,0x59,0xFD,0x80,0x0B,0x61,0xED,0xA1,0x00,0xCA,0xA9,
+0xFF,0x4D,0x5D,0xED,0x04,0x49,0x8B,0xEA,0x80,0x0B,0x61,0x7D,0x00,0x0C,0x58,0xDE,
+0xB1,0x00,0xCA,0x29,0x40,0x49,0xCF,0x6D,0x80,0x49,0x3B,0xED,0x01,0x49,0x3B,0x7D,
+0xA1,0x00,0x00,0x28,0xB1,0x00,0x9C,0x29,0x00,0x0C,0x60,0x45,0x07,0x11,0x48,0x00,
+0x02,0x20,0xB4,0xB3,0x84,0x80,0x14,0xB8,0x88,0xDA,0x7D,0x2D,0x04,0x11,0x48,0x00,
+0xB1,0x00,0x44,0x2F,0x07,0x11,0x48,0x00,0xFF,0xD1,0x83,0x65,0x00,0x0C,0x4E,0x58,
+0xFF,0xD1,0x7F,0xF5,0xB1,0x00,0x82,0xA8,0xFF,0x0E,0x7C,0x6D,0x44,0x0C,0x1C,0x28,
+0x02,0x0E,0x1C,0x18,0x01,0x11,0x1E,0xA0,0x0F,0x00,0x14,0x08,0x08,0x0A,0x26,0x80,
+0x02,0xDA,0x27,0xB0,0x04,0x11,0x48,0x00,0x01,0x0C,0xA8,0xB3,0x00,0x0C,0xB2,0xC4,
+0x04,0x4C,0x1B,0x6D,0x08,0x4C,0xDF,0xED,0x02,0x46,0x45,0x30,0x02,0x20,0x0C,0xB0,
+0x00,0x0C,0xF6,0xC4,0x02,0x46,0x45,0x30,0x02,0x20,0x0C,0xB0,0xA1,0x00,0x80,0x2F,
+0xB1,0x00,0xD6,0xAA,0x00,0x0C,0x3A,0xCD,0xA1,0x00,0x00,0x28,0x02,0x20,0x0C,0xB0,
+0x02,0x46,0x45,0x30,0x80,0x0B,0xB7,0xFD,0x04,0x0C,0x79,0x32,0x00,0x4D,0xC7,0xDD,
+0x00,0x0C,0xF0,0xC4,0x02,0x20,0x0C,0xB0,0x02,0x46,0x45,0x30,0x00,0x4D,0xC7,0xDD,
+0x00,0x0C,0x4A,0xC5,0x02,0x46,0x45,0x30,0x01,0x4D,0x19,0xB0,0xB1,0x00,0xCA,0x29,
+0x40,0x49,0xCF,0x6D,0x80,0x49,0x3B,0xED,0xA1,0x00,0x42,0xAA,0xFF,0x45,0xD3,0xE5,
+0x1B,0x11,0xCC,0x45,0x23,0x11,0xCC,0xC5,0x02,0x20,0x0C,0xB0,0x00,0x0C,0xE6,0xDE,
+0x00,0x0C,0xB2,0xCD,0x08,0x4C,0xF7,0xFC,0x02,0x06,0x22,0x30,0xF7,0x11,0x18,0x00,
+0xB1,0x00,0xAE,0xA9,0x04,0x11,0x18,0x00,0xB1,0x00,0x80,0xA9,0x00,0x0C,0x1A,0xC5,
+0x02,0x20,0x0C,0xB0,0x00,0x0C,0xE6,0xDE,0x00,0x0C,0xBE,0xCD,0xA1,0x00,0x80,0x2F,
+0x02,0x00,0xC9,0x33,0x00,0x0C,0xFA,0x5D,0xFF,0xE5,0xF9,0x65,0xFF,0xFF,0xCC,0xBF,
+0xA1,0x00,0xA8,0xA8,0x0A,0x4D,0x71,0x67,0xCD,0x11,0x6A,0x47,0x02,0x20,0xC8,0x33,
+0xA1,0x00,0xA8,0xA8,0x07,0x11,0x06,0xC6,0x05,0x11,0x06,0x46,0x01,0x0C,0x48,0x30,
+0x02,0x38,0x14,0xFE,0xFF,0xD1,0x15,0xF6,0xB1,0x00,0x82,0xA8,0xFF,0x0E,0x0A,0xEE,
+0x01,0x0C,0x60,0x30,0x02,0x20,0x64,0xB4,0x01,0x00,0x14,0xB8,0x83,0xD4,0xA9,0x2B,
+0xC8,0x01,0x18,0x38,0x0F,0x00,0x14,0x08,0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,
+0x01,0x12,0x14,0x30,0xFF,0x0A,0x30,0x6E,0x01,0x11,0x26,0x80,0xC0,0x01,0x1C,0x38,
+0x01,0xD7,0x15,0xB0,0x00,0x0E,0x1C,0x98,0x01,0x00,0x26,0xB0,0x07,0x0E,0xAE,0x0F,
+0x01,0x0A,0x14,0x18,0x00,0x0C,0x36,0xCE,0x01,0x0A,0x26,0x34,0x24,0x11,0x2A,0x00,
+0x00,0x40,0x18,0xB8,0xA1,0x00,0x26,0x2F,0xFF,0xBF,0x18,0xB8,0xA1,0x00,0x36,0xAF,
+0xC0,0x49,0x3B,0x6D,0x04,0x4E,0x49,0x6E,0x03,0x4E,0x55,0x6E,0x27,0x11,0x2A,0x00,
+0xFB,0x4E,0x9D,0x8A,0x00,0x0C,0x78,0x5E,0x00,0x0C,0x3A,0xD5,0x06,0x11,0x48,0x80,
+0x00,0x0C,0x80,0xDE,0x04,0x11,0x48,0x84,0xFC,0x4E,0x9D,0x0A,0xA1,0x00,0xD6,0x2A,
+0xC0,0x49,0x3B,0x6D,0xFF,0x4D,0x6B,0xEE,0x00,0x0C,0x60,0x46,0xC0,0x49,0x3B,0x6D,
+0x20,0x48,0x67,0x6E,0x01,0x48,0x3B,0xFD,0x00,0x0C,0x78,0x46,0x20,0x49,0x6B,0xEE,
+0x01,0x4E,0x6D,0x6E,0xA1,0x00,0xD6,0x2A,0x00,0x11,0x66,0x8A,0x01,0x4E,0x9D,0x8A,
+0xFC,0x49,0x93,0x0A,0xB1,0x00,0xBC,0xA9,0x02,0x46,0x45,0x30,0x00,0x0C,0x42,0xC2,
+0x02,0x46,0x45,0x30,0xA6,0x01,0x18,0xB8,0x30,0x01,0x1C,0x38,0x00,0x0C,0x30,0xC7,
+0xFF,0xFF,0x0C,0xBA,0xFF,0xD1,0x89,0x66,0x02,0x20,0xA0,0xB3,0x02,0x20,0xA4,0xB7,
+0x02,0x20,0x14,0xB0,0x02,0xD2,0x41,0x30,0x02,0x0A,0x0C,0xB2,0x02,0x0A,0xA4,0xB3,
+0x02,0x0A,0x40,0x34,0xFF,0xD9,0x9F,0x66,0x06,0x11,0x48,0x80,0x02,0x06,0xA1,0xB3,
+0xFF,0x07,0x9D,0xE6,0xFF,0xFF,0xA4,0xBB,0x04,0x11,0x48,0x84,0x02,0x20,0xA8,0x33,
+0x02,0x06,0xAD,0xB3,0x02,0xD8,0x41,0x30,0x02,0xD6,0x0D,0xB2,0x02,0xD4,0x41,0x30,
+0xFF,0x07,0x3B,0xE5,0x06,0x11,0x48,0x80,0x02,0xD8,0xA5,0x33,0x04,0x11,0x48,0x84,
+0x02,0x05,0x0A,0x00,0x02,0xD0,0x41,0xB0,0x04,0x11,0x48,0x00,0xFF,0xFF,0xB0,0xBB,
+0x01,0x49,0xC9,0x6E,0x80,0x33,0xC9,0x7E,0x02,0x46,0x45,0x30,0xA6,0x01,0x1C,0x38,
+0x33,0x01,0x18,0xB8,0x00,0x0C,0x54,0x5F,0x00,0x0C,0xCA,0xD6,0x26,0x11,0x72,0x5F,
+0x00,0x0C,0x92,0xDE,0xFF,0x07,0x77,0x77,0x02,0x20,0xB0,0x33,0x02,0x06,0x41,0x30,
+0x00,0x0C,0xB8,0x46,0x44,0x43,0x15,0xA8,0x00,0x43,0x15,0x80,0x02,0x20,0x0C,0xB0,
+0x01,0x0A,0x00,0x30,0x02,0x06,0x40,0xB0,0x15,0x11,0x6E,0xDF,0x02,0x05,0x0A,0x84,
+0x02,0x46,0x45,0x30,0xB1,0x00,0xCA,0x29,0x00,0x4D,0x73,0x47,0x02,0x46,0x45,0x30,
+0x03,0xD5,0x21,0x77,0x09,0xD5,0x21,0x77,0x12,0xD5,0x21,0x77,0xF0,0xD5,0x15,0x08,
+0x80,0x0A,0x02,0xF7,0x08,0xD5,0xF9,0x6E,0x44,0xD5,0x0F,0x28,0x06,0x07,0xFA,0x7E,
+0x00,0x11,0x7E,0x0B,0x0F,0xD5,0x7D,0x0A,0x02,0x11,0x7A,0x02,0x04,0x11,0x78,0x5F,
+0x01,0x10,0x22,0x1C,0x44,0xD5,0x15,0xA8,0x80,0x0A,0x0E,0xEF,0x01,0x0A,0x0E,0xB0,
+0x0C,0x07,0x0E,0xEF,0xC2,0x07,0x16,0x6F,0x31,0x07,0x12,0xEF,0x00,0x11,0x7E,0x0B,
+0x01,0x11,0x22,0x9C,0x80,0xBF,0x17,0xEF,0x00,0x0C,0x28,0xDF,0x04,0x11,0x6E,0x83,
+0x0F,0x11,0x68,0x5C,0x44,0xD5,0x19,0xA8,0xB0,0x00,0x66,0xAC,0x01,0x11,0x22,0x9C,
+0x80,0xBF,0x25,0x6F,0x00,0x0C,0x28,0xDF,0x01,0xD5,0x6F,0xB3,0x01,0x11,0x22,0x9C,
+0xBA,0x01,0x18,0x38,0xBC,0x01,0x1C,0xB8,0x08,0x9F,0x31,0x7F,0x90,0x01,0x18,0xB8,
+0x02,0x12,0x14,0x30,0x8B,0x10,0xE2,0xAF,0x00,0x0C,0x3A,0xDF,0x04,0x64,0x26,0x30,
+0x01,0x10,0x22,0x1C,0x07,0x11,0x48,0x00,0x04,0x11,0xB8,0x33,0x02,0x0A,0xBA,0xB3,
+0x00,0x0C,0x48,0xDF,0x00,0x0C,0x48,0xDF,0x04,0xDC,0xC9,0xB0,0x04,0x11,0x48,0x84,
+0x02,0xDC,0x15,0x30,0x83,0xDC,0xB9,0x2B,0x02,0xDE,0x15,0xB0,0x84,0xDE,0xBD,0x2F,
+0xBA,0x01,0x1C,0xB8,0xBF,0x01,0x18,0x38,0x11,0x12,0x22,0xA8,0x00,0x0C,0x3A,0xD5,
+0x02,0x0C,0x0C,0x30,0x02,0x0E,0x18,0xB0,0x02,0x12,0x14,0x30,0x00,0x0C,0x3A,0xDF,
+0x02,0x06,0x18,0x30,0xFC,0x0C,0x18,0x98,0x04,0x12,0xC8,0xB0,0xFF,0x11,0x22,0x20,
+0x11,0x67,0x22,0xAC,0xA1,0x00,0x34,0xA8,0xA1,0x00,0x4E,0x28,0xA1,0x00,0x68,0xA8,
+0xA1,0x00,0x76,0x2A,0xA1,0x00,0x70,0x2A,0xA1,0x00,0xA2,0x2A,0xFD,0x05,0x0A,0x0C,
+0xA1,0x00,0x8E,0xA9,0x00,0x0C,0x38,0xDE,0x02,0x86,0x45,0x30,0xFF,0x23,0x3C,0xF6,
+0xB1,0x00,0xF2,0x2D,0x00,0x0C,0x86,0xD7,0xB1,0x00,0x18,0xAE,0x02,0xAE,0x45,0x30,
+0x00,0x0C,0x7E,0xC7,0x00,0x00,0x40,0xB8,0x00,0x0C,0xC2,0x5F,0x00,0x0C,0x9C,0x57,
+0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x02,0x34,0x15,0x30,0x02,0x06,0x40,0xB0,
+0x88,0x20,0x9D,0x2F,0x01,0x10,0x22,0x1C,0xB1,0x00,0xB6,0x2E,0x00,0x0C,0x8C,0xD7,
+0x1F,0x11,0x18,0x9C,0x00,0x00,0x40,0xB8,0x00,0x0C,0xC2,0x5F,0x00,0x0C,0xBC,0xD7,
+0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x09,0x0B,0xB7,0xE7,0x02,0x34,0x15,0x30,
+0x02,0x06,0x40,0xB0,0x88,0x20,0xBD,0xAF,0x00,0x0C,0xB8,0xC7,0x02,0x06,0x40,0xB0,
+0x23,0x11,0x18,0x00,0xB1,0x00,0x32,0xAC,0xB1,0x00,0xB6,0x2E,0x00,0x0C,0xA4,0xD7,
+0xFF,0x11,0x22,0x8C,0xB1,0x00,0xF4,0x2E,0x00,0x0C,0x3A,0xD5,0x01,0x11,0x4A,0x80,
+0x28,0x01,0x18,0xB8,0x80,0x0B,0xCF,0x7F,0x34,0x01,0x18,0x38,0x08,0x12,0xD0,0xB3,
+0xE0,0x01,0x18,0x38,0x01,0x12,0x14,0x30,0x07,0x0C,0x18,0x18,0x00,0x12,0xE0,0xE7,
+0xF8,0x0C,0x18,0x18,0xE8,0x0C,0xD2,0x67,0x00,0x11,0x4A,0x88,0x01,0x10,0x22,0x1C,
+0x00,0x11,0x4A,0x88,0x01,0x11,0x22,0x9C,0x01,0x8E,0x1D,0x1B,0x01,0x8E,0x3B,0xE5,
+0xC8,0x11,0x74,0x5F,0xFF,0x21,0xF0,0xF7,0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x6C,0xDF,
+0x02,0x20,0x18,0x37,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0xFF,0x4B,0x3F,0x6D,0xFF,0x4D,0x07,0x78,0x0B,0x4D,0x27,0x60,0x03,0x48,0x27,0xF8,
+0x20,0x48,0x1F,0x68,0x80,0x49,0x11,0xF8,0xFF,0xFE,0x18,0xB8,0x00,0x0C,0xA2,0x41,
+0x02,0x4C,0x1B,0xF8,0x00,0x00,0x14,0x38,0x88,0x0C,0x1B,0xA8,0x88,0x0E,0x1B,0x28,
+0x17,0x11,0x30,0x40,0x04,0x0C,0x79,0x32,0x01,0x11,0x24,0xC0,0x20,0x49,0x27,0xF8,
+0x04,0x11,0x78,0xB2,0x02,0x11,0x24,0xC0,0x00,0x0C,0x8E,0xD9,0x80,0x4C,0x77,0x7A,
+0x21,0x1F,0x2F,0x68,0x40,0x48,0x77,0xFA,0x0B,0x11,0x30,0xC0,0x0C,0x11,0x30,0x40,
+0x00,0x0C,0x8E,0xD9,0xCD,0x11,0x34,0x40,0x01,0x11,0x1A,0x80,0xFF,0xFF,0x00,0xBA,
+0xFF,0x12,0x42,0xE0,0x01,0x11,0x1E,0x00,0xFE,0x0C,0x1C,0x98,0x02,0x20,0x26,0x30,
+0x02,0x20,0x26,0xB4,0x02,0x0C,0x1C,0xB0,0x02,0x20,0x14,0xB0,0x02,0x12,0x40,0xB0,
+0x02,0x0A,0x00,0xB2,0x02,0x0A,0x26,0xB0,0x02,0x0A,0x40,0x34,0x02,0x0C,0x1C,0xB0,
+0xFF,0xD9,0x59,0x60,0x02,0x00,0x27,0x30,0xFF,0x01,0x3F,0x65,0xFF,0xFF,0x26,0x3C,
+0x02,0x20,0xA8,0x33,0x02,0x00,0xAD,0xB3,0x02,0xD8,0x41,0x30,0x02,0xD6,0x01,0xB2,
+0x02,0xD4,0x41,0x30,0xFF,0x01,0x3F,0x65,0x02,0x0C,0x1C,0x98,0x02,0xD8,0x27,0xB4,
+0x02,0x0C,0xC0,0x33,0x02,0x20,0xC4,0x33,0x01,0x24,0xD0,0xB3,0x04,0x11,0x48,0x00,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0x02,0x38,0x7A,0xE8,0xFD,0x05,0x0A,0x88,
+0x00,0x0C,0x72,0x40,0x01,0xE0,0x61,0x30,0x02,0xE2,0x65,0x30,0x01,0xE8,0x49,0xB0,
+0xFD,0x05,0x0A,0x0C,0x02,0xD0,0x41,0xB0,0x44,0xD8,0x19,0x28,0x0F,0x0C,0x18,0x98,
+0x01,0x11,0x1A,0x20,0xC0,0x12,0x1C,0x88,0x05,0x24,0x90,0x70,0xC0,0xD8,0x9B,0xC0,
+0xFF,0x0E,0x98,0x68,0x00,0x00,0x44,0x38,0xFF,0xFF,0x14,0x38,0x83,0x8E,0x1D,0x2B,
+0xD0,0xD8,0x9B,0x40,0x01,0xD8,0xB1,0x1B,0x07,0xD8,0x3F,0xED,0x02,0x02,0xA1,0x33,
+0xFF,0xFF,0x04,0x3A,0xFF,0xD1,0xA7,0x60,0xFF,0xFF,0xA4,0xBB,0x01,0x11,0xB0,0x07,
+0x01,0x00,0x0E,0xB0,0x01,0x07,0x14,0xB0,0x00,0xDC,0xB9,0x07,0xFF,0x11,0x14,0x02,
+0xFF,0xFF,0x10,0x3A,0xFF,0xFF,0x8C,0x3A,0x06,0x11,0x48,0x80,0x01,0xD5,0x15,0x30,
+0x00,0x21,0xBC,0xE8,0xD7,0x11,0xBE,0x40,0xDB,0x11,0xBE,0x40,0x00,0x0C,0x34,0xD8,
+0x04,0x11,0x48,0x84,0xC0,0x0A,0x15,0x88,0x40,0x0A,0x00,0x71,0x01,0x0A,0x15,0xB0,
+0x00,0x11,0x16,0x88,0x67,0x04,0x18,0x38,0x83,0x0C,0x0C,0xAC,0x00,0x0C,0xFA,0x40,
+0x00,0x0C,0xFA,0x40,0x00,0x0C,0xFA,0x40,0x00,0x0C,0xEE,0x40,0x00,0x0C,0xFA,0x40,
+0x00,0x0C,0x00,0xC1,0x00,0x0C,0x00,0xC1,0x00,0x0C,0x00,0xC1,0x00,0x0C,0xEE,0x40,
+0x00,0x0C,0x06,0xC1,0x00,0x0C,0x42,0xC1,0x00,0x0C,0x42,0xC1,0x00,0x0C,0x42,0xC1,
+0xA0,0x00,0x06,0x2A,0xA0,0x00,0x06,0x2A,0x00,0x0C,0x42,0xC1,0xFF,0xFF,0x14,0x38,
+0x88,0x34,0xF7,0xA8,0x00,0x0C,0x98,0xDE,0x00,0x0C,0x3E,0x4D,0x00,0x0C,0x68,0xDE,
+0x00,0x0C,0x3E,0x4D,0x01,0x21,0x40,0x32,0x01,0x20,0x42,0x32,0x01,0x11,0x22,0x9C,
+0x01,0x21,0x44,0xB2,0x01,0x20,0x46,0xB2,0x01,0x11,0x22,0x9C,0x08,0x48,0x43,0x79,
+0x02,0x46,0x45,0x30,0x04,0x11,0xA8,0xB3,0x01,0xB4,0xAD,0xB3,0xA8,0x01,0x18,0x38,
+0x01,0x12,0xB0,0xB3,0xFF,0xD8,0x19,0x69,0x08,0xD4,0xA9,0x1B,0x00,0x0C,0x20,0x41,
+0x44,0xD4,0x0F,0xA8,0x01,0x07,0x14,0xB0,0x00,0xD8,0x25,0x69,0x01,0xD4,0xA9,0x1B,
+0x07,0xD4,0x19,0xE9,0x00,0x0C,0x10,0x41,0x02,0x0C,0x1C,0xB0,0xFF,0x0E,0x1C,0x98,
+0x00,0xD8,0x27,0x10,0x01,0xD4,0x15,0xB0,0x00,0x0A,0x14,0x98,0x80,0x01,0x1C,0xB8,
+0x00,0x0E,0x1C,0x98,0x02,0xA4,0x45,0x30,0x02,0x20,0x26,0x30,0x33,0xD4,0x15,0x28,
+0x00,0x1C,0x39,0x82,0x01,0x11,0x22,0x9C,0x00,0x00,0x14,0x38,0x88,0x12,0xBE,0xAE,
+0x88,0x12,0xBE,0xAE,0x01,0x11,0x22,0x9C,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,
+0xB8,0x01,0x18,0xB8,0x0F,0x00,0x14,0x08,0x00,0x0C,0x18,0x98,0x01,0x12,0x14,0x30,
+0x02,0x06,0x44,0x30,0xFF,0x11,0x22,0x8C,0x02,0x0C,0x0C,0x30,0x08,0x0C,0x18,0x18,
+0x02,0x12,0x1C,0xB0,0x02,0x0A,0x0C,0x30,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,
+0x84,0x11,0x14,0xA8,0x83,0x0E,0x1C,0x28,0x02,0x06,0x14,0x30,0x80,0x0F,0x6C,0xF9,
+0xFE,0x0C,0x18,0x18,0x02,0x12,0x14,0x30,0x02,0x06,0x18,0x30,0xFF,0x11,0x22,0x8C,
+0x01,0x0C,0x1A,0xB0,0x00,0x11,0x74,0xC1,0x02,0x48,0x15,0xB0,0x80,0x0C,0x04,0xA8,
+0xE1,0x48,0x7D,0x29,0xFF,0x11,0x22,0x8C,0x02,0x48,0x91,0x32,0x00,0x0C,0x74,0xC1,
+0x00,0x11,0x1A,0x88,0x02,0x4C,0x15,0x30,0x80,0x0C,0x04,0xA8,0xE1,0x4C,0x8B,0xA9,
+0xFF,0x11,0x22,0x8C,0x02,0x4C,0x99,0x32,0x00,0x0C,0x82,0xC1,0x02,0x4C,0x15,0x30,
+0x01,0x0A,0x04,0x80,0x01,0x0C,0x06,0x30,0xE1,0x4C,0x99,0xA9,0xFF,0x11,0x22,0x8C,
+0x02,0x4C,0x99,0x32,0x00,0x0C,0x8E,0xC1,0x7F,0x11,0x9E,0xC1,0x01,0x0C,0x1A,0xB0,
+0xFF,0x11,0xA2,0x41,0x02,0x48,0x15,0xB0,0x81,0x0C,0x04,0x28,0xE1,0x48,0xAB,0xA9,
+0xFF,0x11,0x22,0x8C,0x02,0x48,0x91,0x32,0x00,0x0C,0xA2,0x41,0xFF,0x11,0x1A,0x00,
+0x02,0x4C,0x15,0x30,0x81,0x0C,0x04,0x28,0xE1,0x4C,0xB9,0x29,0xFF,0x11,0x22,0x8C,
+0x02,0x4C,0x99,0x32,0x00,0x0C,0xB0,0x41,0x02,0x4A,0x15,0x30,0x01,0x0A,0x04,0xB0,
+0x01,0x0B,0x06,0x98,0xE1,0x4A,0xC7,0x29,0xFF,0x11,0x22,0x8C,0x02,0x4A,0x95,0x32,
+0x00,0x0C,0xBC,0x41,0x02,0x4A,0x15,0x30,0x01,0x0A,0x04,0xB0,0xFF,0x0B,0x06,0x18,
+0xE1,0x4A,0xD5,0x29,0xFF,0x11,0x22,0x8C,0x02,0x4A,0x95,0x32,0x00,0x0C,0xCA,0xC1,
+0x02,0x0C,0x0C,0x30,0x02,0xD8,0x0D,0xB0,0x00,0x0C,0x4E,0x58,0x1B,0x11,0x14,0x80,
+0x00,0x0C,0x1C,0x5A,0xC0,0x0C,0xE6,0x71,0xC0,0x11,0xF2,0x41,0xFF,0x8E,0xF1,0xF9,
+0x02,0x8C,0x41,0xB0,0xFF,0x21,0xFE,0x71,0xFF,0xFF,0x18,0x3B,0xC8,0x11,0xFA,0x41,
+0xC8,0x11,0xF2,0xC1,0x00,0x0C,0xA2,0x5A,0xFF,0x21,0xFE,0x71,0x02,0xD6,0xB1,0xB3,
+0x00,0x0C,0x4E,0x58,0x1B,0x11,0x14,0x80,0x00,0x0C,0x1C,0x5A,0x00,0x00,0x40,0xB8,
+0xFF,0xFF,0xD4,0x3B,0x00,0x0C,0xF4,0xDE,0x00,0x0C,0x08,0xD2,0x1B,0x11,0x32,0x5C,
+0x00,0x0C,0xB6,0xDE,0x00,0x0C,0x02,0xD2,0x00,0x0C,0x1C,0xDE,0x02,0x06,0xB0,0xB3,
+0x02,0x06,0x18,0x30,0xFF,0xD9,0x19,0xF2,0x02,0xD8,0x41,0x30,0x02,0x00,0x41,0xB4,
+0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x9C,0x02,0x0C,0x0C,0x30,0x00,0x0C,0x38,0x5A,
+0x02,0x0A,0x0C,0x30,0x00,0x0A,0x42,0xDA,0x02,0x06,0x14,0x30,0x02,0xD4,0x19,0xB0,
+0x02,0x12,0x0C,0x30,0x02,0xD4,0x1D,0x30,0xFF,0xFF,0x26,0xB8,0x02,0x06,0x40,0xB0,
+0xFF,0x21,0x20,0xE2,0x02,0x06,0x18,0x30,0x02,0xDA,0x1D,0xB0,0xFF,0xFF,0x26,0x3C,
+0xC0,0x0C,0x3E,0xE2,0x02,0x01,0xA8,0xBB,0xA0,0x01,0xB4,0x3F,0x04,0x01,0xA8,0xBB,
+0xA2,0x01,0xB4,0xBF,0x1B,0x0C,0x56,0x62,0x02,0x46,0x45,0x30,0x01,0xB7,0x79,0x32,
+0x04,0xB7,0x51,0x62,0x01,0x11,0x7A,0x02,0xF0,0x9F,0x7D,0x8A,0x00,0x0C,0x70,0x42,
+0x03,0xB7,0x71,0x62,0x01,0x9E,0x7B,0x8A,0x00,0x0C,0x70,0x42,0x23,0x0C,0x5A,0x72,
+0x13,0x0C,0x70,0x62,0x02,0x20,0x78,0x32,0x80,0x0B,0x63,0x7A,0x01,0x21,0x79,0x32,
+0x01,0x20,0x7B,0x32,0x88,0x11,0x02,0x00,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,
+0x02,0x52,0x15,0x30,0x02,0x06,0x40,0xB0,0x01,0x01,0x22,0xB0,0x02,0x0A,0x7C,0x32,
+0x00,0x0C,0xD6,0x5A,0x00,0x0C,0x3E,0x4D,0x00,0x0C,0x8E,0xD9,0x00,0x0C,0xFC,0x5D,
+0x00,0x0C,0xA0,0x52,0x02,0x46,0x45,0x30,0xFF,0xFF,0x14,0x38,0x83,0xAC,0x59,0x2B,
+0x04,0x9F,0x85,0x7A,0x00,0x0C,0x0E,0x5F,0x40,0x49,0x9F,0x7A,0xFF,0x45,0x9F,0x72,
+0x02,0x20,0x0C,0xB0,0x02,0x44,0x0D,0xB0,0x00,0x0C,0xB6,0x5A,0xC5,0x11,0x34,0xD8,
+0x88,0x11,0x02,0x00,0x02,0x06,0x40,0xB0,0xFF,0xFF,0x14,0x38,0x83,0x4A,0x95,0x2A,
+0x00,0x0C,0x66,0xDC,0x01,0x01,0x22,0xB0,0x00,0x0C,0x3C,0x45,0x00,0x0C,0xB6,0x5A,
+0xC5,0x11,0x34,0xC0,0xFF,0xFF,0xAC,0x3B,0x01,0x11,0x1A,0x80,0x02,0x12,0x40,0xB0,
+0xFE,0x0C,0x18,0x18,0xFF,0x21,0x42,0xF1,0x00,0x0C,0xF8,0xDE,0x00,0x0C,0x3E,0x4D,
+0x02,0x20,0xAC,0xB3,0x02,0x00,0x41,0x30,0x00,0x0C,0xAA,0xC2,0x09,0x0A,0x3F,0xE5,
+0x08,0x48,0x3F,0x7D,0x3D,0x1C,0x17,0xA8,0x02,0x22,0x0C,0x30,0x02,0x46,0x45,0x30,
+0xA8,0x01,0x18,0x38,0x3D,0x0B,0x14,0xA8,0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,
+0x44,0x0B,0x0E,0xA8,0x01,0x07,0x14,0xB0,0x00,0x12,0xD4,0xEA,0xFF,0x0C,0x18,0x98,
+0x00,0x12,0x26,0x00,0x00,0x0C,0x50,0xC1,0x1A,0x11,0x2A,0x80,0x02,0x48,0x15,0xB0,
+0x01,0x0B,0xBE,0x6E,0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x80,0xE1,0x48,0xE3,0xAA,
+0x01,0x11,0x22,0x9C,0x02,0x48,0x91,0x32,0x00,0x0C,0xD6,0x42,0x02,0x20,0xD4,0xB3,
+0x01,0x0A,0xE5,0xB3,0x10,0x0B,0xF5,0x7A,0xFF,0xFF,0x14,0x38,0x8A,0x34,0xF5,0x2A,
+0x00,0x0C,0x44,0x5D,0x00,0x0C,0x76,0xCA,0x02,0x46,0x45,0x30,0xFD,0x8F,0x25,0xF3,
+0xC0,0x11,0x52,0xDD,0x00,0x0C,0x02,0x53,0x1E,0x11,0x70,0x5A,0x02,0xEA,0x41,0xB0,
+0x00,0x11,0x70,0x42,0xFF,0x8E,0x0D,0x7B,0x02,0x8C,0x41,0xB0,0xFF,0x21,0x10,0xF3,
+0x00,0x0C,0xB8,0x5D,0x00,0x0C,0x0E,0xC3,0xC8,0x11,0x52,0x5D,0x00,0x0C,0x18,0xCB,
+0x02,0xEA,0x41,0xB0,0x00,0x0C,0x98,0xDE,0x00,0x0C,0x76,0xCA,0x02,0x0A,0x40,0xB0,
+0x10,0x0B,0x21,0xFB,0x80,0x11,0x70,0xD9,0x02,0xEA,0x41,0xB0,0xA0,0x00,0x2E,0x2A,
+0x02,0xEA,0x41,0xB0,0x1D,0x11,0x70,0x42,0x2A,0x11,0x2A,0x80,0x02,0x20,0xD4,0xB3,
+0x01,0x0A,0xE5,0xB3,0xFF,0x0B,0x41,0x7B,0x01,0x0B,0x43,0xF3,0x02,0x0B,0x59,0x73,
+0x03,0x0B,0x89,0x73,0x04,0x0B,0xAF,0x73,0x05,0x0B,0xB9,0x73,0x06,0x0B,0xB5,0x73,
+0x07,0x0B,0xFF,0x73,0x08,0x0B,0xFD,0xF3,0x09,0x0B,0x1B,0x74,0xA0,0x00,0x06,0x2A,
+0xFF,0x11,0x28,0x02,0xC0,0x11,0x8E,0xDC,0xC8,0x11,0x8E,0x5C,0x00,0x00,0x40,0xB8,
+0x00,0x0C,0xF8,0xDD,0x00,0x0C,0x52,0x53,0x00,0x0C,0xE8,0x5D,0x00,0x0C,0x52,0x53,
+0x23,0x11,0x32,0xDC,0x00,0x0C,0xB6,0xDE,0x00,0x0C,0x48,0xD3,0x00,0x0C,0x62,0x44,
+0x00,0x0C,0xFE,0xDE,0x00,0x0C,0x70,0xCA,0x02,0x10,0x63,0xFB,0xC0,0x11,0xB8,0xDC,
+0x02,0xEA,0x41,0xB0,0x04,0x10,0x69,0xFB,0x00,0x0C,0xAA,0xDC,0x02,0xEA,0x41,0xB0,
+0x01,0x10,0x79,0x7B,0x00,0x00,0x40,0xB8,0x00,0x0C,0xF4,0xDE,0x00,0x0C,0x72,0xD3,
+0x23,0x11,0x32,0xDC,0x00,0x0C,0xB6,0xDE,0x00,0x0C,0x6C,0xD3,0x02,0xEA,0x41,0xB0,
+0xFD,0x8F,0x87,0x73,0x80,0x10,0x81,0xFB,0xB0,0x00,0xE4,0xAF,0x02,0xEA,0x41,0xB0,
+0x40,0x10,0x87,0xFB,0xB1,0x00,0xDC,0xAF,0x02,0xEA,0x41,0xB0,0x00,0x0C,0x62,0x44,
+0x02,0x46,0x45,0x30,0x00,0x0C,0x2A,0xDD,0x02,0x10,0x93,0xFB,0xC0,0x11,0xCE,0x5C,
+0x02,0xEA,0x41,0xB0,0x04,0x10,0x99,0xFB,0x00,0x0C,0xC4,0x5C,0x02,0xEA,0x41,0xB0,
+0x01,0x10,0x9F,0xFB,0xB0,0x00,0xA2,0x2F,0x02,0xEA,0x41,0xB0,0xFD,0x8F,0xAD,0xF3,
+0x80,0x10,0xA7,0x7B,0xB0,0x00,0xE4,0xAF,0x02,0xEA,0x41,0xB0,0x40,0x10,0xAD,0x7B,
+0xB1,0x00,0xDC,0xAF,0x02,0xEA,0x41,0xB0,0x00,0x0C,0x62,0x44,0x00,0x0C,0x44,0x5D,
+0x00,0x0C,0x76,0xCA,0x00,0x0C,0xB8,0x43,0x00,0x0C,0x40,0xDD,0x00,0x0C,0x76,0xCA,
+0x02,0x46,0x45,0x30,0xC0,0x11,0x52,0xDD,0x00,0x0C,0xF2,0x4B,0xFF,0x8E,0xC9,0xFB,
+0x02,0x8C,0x41,0xB0,0xFF,0x21,0xCC,0x73,0x00,0x0C,0xB8,0x5D,0x00,0x0C,0xCA,0x43,
+0xC8,0x11,0x52,0x5D,0x00,0x0C,0xD4,0xCB,0x02,0xEA,0x41,0xB0,0x00,0x0C,0x98,0xDE,
+0x00,0x0C,0x76,0xCA,0x02,0x0A,0x40,0xB0,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,
+0x01,0x10,0x15,0x30,0x02,0x06,0x40,0xB0,0x40,0x0A,0xF8,0xFB,0xFF,0x4D,0xED,0x6B,
+0x00,0x0C,0x9C,0xD9,0x40,0x01,0x18,0x38,0x00,0x0C,0x3C,0xD9,0x00,0x0C,0xEE,0xD3,
+0xB0,0x00,0x74,0xAA,0x00,0x0C,0xEE,0x43,0x00,0x4D,0x71,0xDA,0x02,0xEA,0x41,0xB0,
+0x13,0x11,0x42,0x42,0x23,0x11,0x42,0x5A,0x02,0xEA,0x41,0xB0,0x00,0x11,0x70,0x42,
+0x23,0x11,0x32,0xDC,0x00,0x0C,0x62,0x44,0xFF,0x11,0x28,0x02,0x00,0x0C,0x2A,0xDD,
+0xB0,0x00,0x38,0xAE,0x02,0x86,0x45,0x30,0xFF,0x23,0x16,0xF4,0x00,0x0C,0xF2,0xDD,
+0x00,0x0C,0x12,0x54,0xC0,0x11,0xCE,0x5C,0xC8,0x11,0xCE,0xDC,0xB0,0x00,0xA2,0x2F,
+0x02,0xEA,0x41,0xB0,0x02,0xAE,0x45,0x30,0x00,0x0C,0x04,0x44,0xB0,0x00,0x3C,0x2E,
+0x00,0x0C,0x62,0x44,0x00,0x0C,0xFE,0xDE,0x00,0x0C,0x70,0xCA,0xFD,0x8F,0x23,0x74,
+0x22,0x11,0x70,0x42,0x00,0x0C,0x2A,0xDD,0xB0,0x00,0x8A,0x2F,0x02,0xEA,0x41,0xB0,
+0x00,0x0C,0x70,0xD2,0xC0,0x11,0xCE,0x5C,0xC8,0x11,0xCE,0xDC,0xB0,0x00,0xA2,0x2F,
+0x00,0x0C,0x62,0x44,0x68,0x07,0x0C,0x38,0x00,0x0C,0xC0,0x5E,0x02,0x0C,0x0C,0x30,
+0x80,0x11,0x70,0xD9,0x02,0x06,0x18,0x30,0xFF,0x4B,0x43,0xFA,0x40,0x49,0x53,0x7C,
+0xFF,0x45,0x53,0x74,0x02,0x20,0x0C,0xB0,0x02,0x44,0x41,0x30,0xFF,0xFF,0x14,0x38,
+0x83,0x4A,0x95,0x2A,0x02,0x4A,0x15,0x30,0x89,0x10,0x50,0x2C,0x00,0x11,0x70,0x5A,
+0x02,0x06,0x40,0xB0,0x02,0xEA,0x89,0xB2,0x40,0x11,0x70,0xD9,0xFF,0xEB,0x3F,0x75,
+0x02,0x20,0xA8,0x33,0x02,0xEA,0x41,0xB0,0x01,0x00,0x14,0xB8,0x83,0x4A,0x95,0x2A,
+0x02,0xD4,0x41,0xB4,0x02,0xEA,0x41,0xB0,0x40,0x10,0x89,0x74,0x02,0x4A,0x15,0x30,
+0x89,0x10,0x3E,0x2D,0xFF,0x0B,0x81,0xFC,0x01,0x0B,0x81,0xF4,0x02,0x0B,0x85,0x74,
+0x03,0x0B,0x85,0xF4,0x04,0x0B,0x85,0x74,0x05,0x0B,0x85,0xF4,0x06,0x0B,0x85,0xF4,
+0x07,0x0B,0x8B,0xF4,0x08,0x0B,0x8B,0xF4,0x09,0x0B,0x85,0xF4,0xA0,0x00,0x06,0x2A,
+0x00,0x0C,0x04,0xDE,0x00,0x11,0x70,0x42,0x00,0x0C,0x18,0x5E,0x00,0x11,0x70,0x42,
+0x13,0x11,0x42,0x42,0xB0,0x00,0x7A,0x2F,0x00,0x11,0x70,0x42,0x01,0x11,0x1A,0x80,
+0xFF,0xFF,0xB0,0xBB,0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x18,0xFF,0x21,0x3E,0xF5,
+0x00,0x0C,0xE8,0x5D,0x00,0x0C,0xA6,0x54,0x00,0x0C,0x4E,0x58,0x23,0x11,0x14,0x00,
+0x00,0x0C,0x1C,0x5A,0xFF,0xD9,0x93,0x74,0x02,0xD8,0x41,0x30,0x02,0x00,0x41,0x30,
+0x00,0x0C,0x96,0xC4,0xFF,0x8E,0xB7,0x7C,0x02,0x8C,0x41,0xB0,0xFF,0x21,0x3E,0xF5,
+0xFF,0xFF,0x18,0x3B,0xFF,0xFF,0x44,0x3B,0xC8,0x11,0xC0,0x44,0xC8,0x11,0xB8,0x44,
+0x00,0x0C,0xA2,0x5A,0xFF,0x21,0x3E,0xF5,0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x4E,0x58,
+0x23,0x11,0x14,0x00,0x00,0x0C,0x1C,0x42,0xFF,0x8E,0xCD,0xFC,0x02,0x8C,0x41,0xB0,
+0xFF,0x21,0x3E,0xF5,0xC8,0x11,0xD6,0xC4,0xC8,0x11,0xCE,0xC4,0x00,0x0C,0xA2,0x5A,
+0xFF,0x21,0x3E,0xF5,0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x4E,0x58,0x02,0x0C,0x0C,0x30,
+0x02,0x20,0xE0,0x33,0x00,0x0C,0x38,0x5A,0xFF,0xFF,0xB0,0xBB,0xB0,0x00,0xC6,0xAF,
+0x00,0x0C,0x12,0xD5,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x09,0x0B,0xF1,0x64,
+0x02,0x34,0x15,0x30,0x02,0x06,0x40,0xB0,0x88,0x20,0x13,0xAD,0x00,0x0C,0xF2,0x44,
+0x02,0x06,0x40,0xB0,0xFF,0xD9,0xFD,0x64,0x02,0xD4,0x19,0xB0,0x02,0x12,0xE0,0xB3,
+0xFF,0xF1,0x01,0x75,0x00,0x0C,0x04,0xC5,0x00,0x0C,0x30,0x5D,0xFF,0xD7,0x05,0xE5,
+0x02,0xDA,0x1D,0xB0,0x02,0xD8,0x27,0x30,0x02,0xD4,0x19,0xB0,0x02,0x12,0x0C,0x30,
+0x02,0xD4,0x1D,0x30,0xFF,0xFF,0x26,0xB8,0x23,0x11,0x42,0x5A,0x02,0x06,0x40,0xB0,
+0x00,0x0C,0x18,0x45,0x02,0x20,0xB0,0x33,0x02,0xD4,0x19,0xB0,0x02,0x12,0x40,0xB0,
+0xFF,0x21,0xDE,0x64,0x02,0x06,0x18,0x30,0xC8,0x0C,0x20,0xE5,0xFF,0x8E,0x29,0xED,
+0xFF,0xF1,0x3F,0xF5,0x02,0xF0,0x41,0x30,0x01,0x0C,0x18,0x18,0x00,0x0C,0x34,0xC0,
+0x02,0xF0,0x19,0x37,0x01,0x11,0x4A,0x80,0x08,0x28,0xC1,0xB3,0x00,0x11,0x4A,0x0C,
+0x02,0x20,0x0C,0xB0,0x02,0xD4,0x19,0xB0,0x02,0x12,0xAC,0x33,0x02,0xD8,0x41,0x30,
+0x02,0xD4,0x1D,0x30,0x02,0xD6,0x27,0xB0,0x02,0x06,0x40,0xB0,0xFF,0x11,0x22,0x8C,
+0x00,0x0C,0x54,0xDE,0x00,0x0C,0x46,0xC5,0x00,0x0C,0x68,0xDE,0x00,0x0C,0x3E,0x4D,
+0x00,0x0C,0x92,0xDE,0x02,0x08,0x15,0x30,0x02,0xEA,0x41,0xB0,0x02,0x0A,0xA0,0xB2,
+0x01,0x11,0x22,0x9C,0x00,0x0C,0xA2,0x5A,0x02,0x0C,0xDC,0xB3,0x02,0xD6,0xD9,0x33,
+0x00,0x0C,0x38,0x5A,0xFF,0xFF,0xB0,0xBB,0xFF,0x21,0x42,0xF1,0x02,0x20,0x0C,0xB0,
+0x02,0xEA,0x41,0xB0,0x02,0x50,0x15,0xB0,0x02,0x06,0x40,0xB0,0x8A,0x08,0x71,0xAD,
+0x02,0x20,0xB0,0x33,0x02,0xD4,0x19,0xB0,0x02,0x12,0x40,0xB0,0x00,0x0C,0x5C,0x45,
+0xC4,0xF2,0x75,0xF5,0x04,0x4C,0x43,0x69,0xFF,0xD9,0x81,0xF5,0x00,0x0C,0x30,0x5D,
+0xFF,0xD7,0xB3,0x65,0x02,0xDA,0x1D,0xB0,0x02,0xD8,0x27,0x30,0x00,0x0C,0xB2,0x45,
+0x02,0xD4,0x19,0xB0,0x02,0x12,0x14,0x30,0xFF,0x0B,0xAA,0xF5,0xFF,0xED,0x93,0x75,
+0x02,0x20,0x0C,0xB0,0x02,0xEC,0x41,0xB0,0x02,0x0A,0x00,0xB2,0x02,0x06,0x40,0xB0,
+0x00,0x0C,0x96,0x45,0x02,0xEE,0x1D,0x30,0x02,0x0A,0x26,0xB0,0xFF,0x01,0x9F,0x65,
+0x02,0xEE,0x1D,0x30,0x02,0x0E,0x1C,0x18,0x02,0x0A,0x26,0xB0,0x02,0x20,0x0C,0xB0,
+0x02,0x00,0xAD,0xB3,0x02,0x0A,0x40,0xB0,0x02,0xD6,0x01,0xB2,0x02,0x06,0x40,0xB0,
+0x00,0x0C,0xB2,0x45,0x02,0xDA,0x1D,0xB0,0xFF,0xFF,0x26,0xB8,0x02,0xEC,0xB1,0xB3,
+0x00,0xEE,0x4F,0xD8,0xC8,0xEE,0xB7,0x65,0x00,0x0C,0xCA,0xD9,0x01,0x10,0x22,0x1C,
+0xFF,0xFF,0xB0,0xBB,0xFF,0x21,0x42,0xF1,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,
+0x02,0x50,0x15,0xB0,0x02,0x06,0x40,0xB0,0x8A,0x08,0xCD,0x2D,0x02,0x20,0xB0,0x33,
+0x02,0x04,0x41,0xB0,0x00,0x0C,0xBA,0xC5,0xFF,0xD9,0xDF,0x75,0x02,0x20,0x0C,0xB0,
+0x02,0x04,0xAD,0x33,0x02,0xD8,0x41,0x30,0x02,0xD6,0x09,0x32,0x02,0x06,0x40,0xB0,
+0xFF,0xD7,0xE5,0x65,0x02,0xD8,0x45,0xB3,0x00,0x0C,0xE4,0x45,0x02,0x04,0x19,0x33,
+0xFF,0x05,0xE5,0x65,0xFF,0xFF,0x44,0x3B,0x00,0x0C,0xCA,0xD9,0x01,0x10,0x22,0x1C,
+0x02,0x46,0x45,0x30,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x00,0x0C,0xF2,0xDD,
+0x00,0x0C,0x3C,0x45,0x01,0x14,0x15,0xB0,0x00,0x9C,0x43,0xF9,0x01,0x10,0x22,0x1C,
+0x01,0x49,0x43,0x69,0xFF,0x0A,0x43,0x71,0xC0,0x0A,0x15,0x88,0x80,0x0A,0x42,0x71,
+0xC0,0x0A,0x42,0xF1,0x01,0x10,0x22,0x1C,0x01,0x00,0x44,0xB8,0xFE,0x8F,0x0F,0xE6,
+0x00,0x0C,0xF2,0xDD,0x00,0x0C,0x0E,0x56,0x00,0x0C,0x1C,0xDE,0x01,0x00,0x14,0xB8,
+0x83,0x22,0x44,0x28,0x02,0xFE,0x15,0x30,0x88,0x22,0x06,0xAE,0xFF,0x11,0x22,0x8C,
+0x02,0xAC,0x15,0xB0,0x89,0x10,0x3E,0x2D,0x00,0x00,0x3C,0x3B,0x04,0x10,0x40,0x33,
+0x00,0x11,0x7E,0x0B,0x04,0x9D,0x3F,0x6D,0xFF,0xFF,0x4C,0xBB,0x04,0x11,0x60,0x33,
+0x00,0x11,0x6A,0x0B,0x00,0x11,0x6C,0x0B,0xFF,0xB4,0x3F,0xFD,0x04,0x11,0x50,0x33,
+0x3D,0xB4,0x15,0xA8,0xA8,0x01,0x1C,0xB8,0x00,0x11,0x16,0x88,0xFF,0x0A,0x40,0x7E,
+0xFF,0x11,0x26,0x00,0x08,0x0B,0x16,0x18,0xFF,0x0A,0x14,0x98,0x00,0x0C,0x36,0x46,
+0xFF,0x0B,0x14,0x90,0x01,0x0A,0x14,0x18,0x00,0xB4,0x15,0x18,0xFF,0x0A,0x4C,0x7E,
+0x44,0x0A,0x0E,0x28,0xFF,0x07,0x26,0x98,0x02,0x22,0x14,0x30,0x01,0xA4,0x45,0x30,
+0x40,0x10,0x00,0xB3,0x02,0x0A,0x44,0xB4,0x02,0x20,0x0C,0xB0,0x02,0x46,0x45,0x30,
+0x02,0xA4,0x45,0x30,0x01,0x35,0x15,0xB0,0x00,0x0A,0x14,0x98,0x80,0x01,0x18,0x38,
+0x00,0x0C,0x18,0x98,0x02,0x12,0x40,0xB0,0xFF,0x21,0x86,0xF6,0x00,0x0C,0x78,0x46,
+0x02,0x20,0x0C,0xB0,0x00,0x0C,0x92,0xDE,0x02,0x20,0x18,0xB0,0x02,0xFC,0x15,0xB0,
+0x00,0x0C,0xE0,0xDE,0x80,0x0F,0x86,0xFE,0xFF,0x20,0x78,0x66,0xF0,0x21,0x86,0x7E,
+0xFF,0x0A,0x89,0xF6,0x01,0x49,0x8B,0x6E,0x02,0x20,0x14,0xB0,0x02,0x06,0x40,0xB0,
+0x01,0x0A,0x6A,0xB2,0x01,0x0B,0x68,0xB2,0x01,0x11,0x22,0x9C,0x1F,0x11,0x8C,0x46,
+0x20,0x11,0x8C,0x46,0x21,0x11,0x8C,0xC6,0x02,0x06,0x40,0xB0,0x00,0x0C,0x8E,0xD9,
+0x01,0x10,0x22,0x1C,0x01,0x35,0x15,0xB0,0x01,0x34,0x17,0xB0,0x02,0x0A,0x40,0x34,
+0x02,0x50,0xA9,0x33,0x02,0x20,0x0C,0xB0,0x00,0x00,0x40,0xB8,0x02,0x08,0x15,0x30,
+0x8A,0xD4,0xAD,0xAE,0x00,0x0C,0xB6,0xDE,0x00,0x0C,0x9E,0x56,0x02,0x06,0x40,0xB0,
+0x1D,0x11,0x8E,0xD9,0x01,0x10,0x22,0x1C,0x02,0x20,0x14,0xB0,0x02,0x06,0x40,0xB0,
+0x01,0x0B,0x68,0xB2,0x01,0x0A,0x6A,0xB2,0x01,0x11,0x22,0x9C,0x01,0x00,0x14,0xB8,
+0x83,0x20,0x40,0x28,0x02,0xFC,0x15,0xB0,0x88,0x20,0x42,0xA9,0x01,0x10,0x22,0x1C,
+0x02,0x48,0x15,0xB0,0x02,0x0B,0xC0,0x6E,0x01,0x0A,0x04,0xB0,0x02,0x0B,0x06,0x80,
+0xE1,0x48,0xCD,0x2E,0xFF,0x11,0x22,0x8C,0x02,0x48,0x91,0x32,0x00,0x0C,0xC0,0x46,
+0xFF,0xFD,0x18,0xB8,0x00,0x0C,0xA2,0x41,0x01,0x9E,0x1D,0xB0,0x08,0x0E,0xDC,0x7E,
+0xB0,0x01,0x18,0x38,0x00,0x0C,0x3C,0xC1,0xFF,0xA7,0xBF,0xE6,0x01,0x11,0x22,0x9C,
+0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,0x02,0x0A,0x0C,0x30,
+0xFF,0xFF,0x14,0x38,0x84,0x11,0x1C,0x28,0x02,0x06,0x14,0x30,0x83,0x0C,0x18,0x28,
+0x00,0x00,0x14,0x38,0x84,0x0E,0x1C,0x2C,0x00,0x0C,0xF8,0xDD,0x00,0x0C,0x3E,0x55,
+0x02,0x46,0x15,0x30,0x88,0x22,0x42,0x29,0x01,0x10,0x22,0x1C,0x02,0x46,0x45,0x30,
+0x00,0x00,0x14,0x38,0x8A,0x22,0x0C,0xAF,0x02,0x22,0x18,0x30,0x02,0xFE,0x15,0x30,
+0xB1,0x00,0xE0,0x2E,0x80,0x0F,0x42,0x69,0x22,0x11,0xBE,0x46,0x02,0xAC,0x15,0xB0,
+0x89,0x10,0x3E,0x2D,0x02,0x20,0x0C,0xB0,0x02,0xB0,0x41,0xB0,0x02,0x12,0x75,0xB3,
+0x02,0x14,0x4D,0x33,0x02,0x16,0x71,0xB3,0x03,0x18,0x69,0xB3,0xFB,0x11,0x18,0x00,
+0xB1,0x00,0xC8,0xAF,0x00,0x11,0x70,0x5A,0x00,0x0C,0x3C,0x45,0x00,0x00,0x44,0x38,
+0x02,0x8A,0x15,0x30,0x89,0x0C,0x26,0x2F,0x80,0x0C,0x04,0xA8,0xE1,0x8A,0x33,0xAF,
+0xFF,0x11,0x22,0x8C,0x02,0x8A,0x15,0x33,0x00,0x0C,0x26,0x47,0x00,0x00,0x44,0x38,
+0x02,0x8A,0x15,0x30,0x81,0x0C,0x04,0x28,0xE1,0x8A,0x41,0xAF,0xFF,0x11,0x22,0x8C,
+0x02,0x8A,0x15,0x33,0x00,0x0C,0x36,0xC7,0x00,0x0C,0x44,0xD9,0x01,0x0A,0xB0,0xB3,
+0x0F,0x00,0x18,0x08,0x00,0x11,0x1A,0x88,0x00,0x11,0x02,0x88,0x01,0xD8,0x15,0xB0,
+0x01,0x00,0x0E,0xB0,0x00,0x07,0x5A,0xFF,0x02,0x38,0x54,0xFF,0x02,0x00,0x60,0xB8,
+0x02,0x0C,0x64,0xB0,0x11,0x00,0x00,0x98,0x01,0x00,0x14,0x30,0x00,0xDD,0x4F,0xE7,
+0x01,0x01,0x22,0x34,0xC0,0x0C,0x66,0x67,0x02,0x02,0x41,0x34,0x02,0x04,0x41,0x34,
+0xC0,0x0C,0x74,0x67,0x02,0x02,0x0D,0x30,0xFF,0xFF,0x04,0x3A,0x02,0x06,0x40,0xB0,
+0xFF,0x21,0x3E,0xF5,0xC1,0x11,0x34,0x40,0x02,0x04,0x0D,0x30,0xFF,0xFF,0x08,0x3A,
+0x02,0x06,0x40,0xB0,0xFF,0x21,0x3E,0xF5,0xC9,0x11,0x34,0xC0,0xA0,0x00,0x5E,0xAC,
+0xC8,0x11,0x7E,0x5F,0x00,0x0C,0x86,0xCF,0xFF,0xFF,0x44,0x3B,0xFF,0x21,0xA2,0x77,
+0x02,0x04,0xB1,0xB3,0x40,0x49,0x91,0xFF,0xB0,0x00,0xC6,0x2D,0x00,0x0C,0x9E,0x47,
+0x02,0xA2,0xAD,0x33,0x02,0x20,0x44,0xB3,0xFF,0xFF,0x08,0x3A,0xFF,0xD7,0x9D,0x77,
+0x00,0x0C,0xB0,0x5F,0x00,0x0C,0x9E,0x47,0xC9,0x11,0x34,0xD8,0x02,0xD8,0x41,0x30,
+0xFF,0x21,0x88,0x67,0x02,0x06,0x40,0xB0,0x10,0x49,0x3F,0xFD,0xEF,0x11,0x9E,0xC1,
+0x02,0x20,0xA8,0x33,0x02,0xD6,0x41,0xB0,0x02,0xD4,0x05,0xB2,0x02,0xD4,0x41,0xB4,
+0x02,0x20,0xA8,0x33,0x02,0xD6,0x41,0xB0,0x02,0xD4,0x09,0xB2,0x02,0xD4,0x41,0xB4,
+0x01,0x0C,0x1A,0xB0,0x00,0x11,0xBC,0x47,0x02,0x9E,0x15,0x30,0x80,0x0C,0x04,0xA8,
+0xE1,0x9E,0xC5,0xAF,0xFF,0x11,0x22,0x8C,0x02,0x9E,0x3D,0x33,0x00,0x0C,0xBC,0x47,
+0x01,0x0C,0x1A,0xB0,0x00,0x11,0xCC,0xC7,0x02,0x9E,0x15,0x30,0x81,0x0C,0x04,0x28,
+0xE1,0x9E,0xD5,0x2F,0xFF,0x11,0x22,0x8C,0x02,0x9E,0x3D,0x33,0x00,0x0C,0xCC,0xC7,
+0xB0,0x00,0x5E,0xAE,0xA0,0x00,0x60,0xAD,0xFF,0x8E,0x1D,0x9B,0xFF,0x8E,0x3F,0x6D,
+0xFF,0x8D,0x3F,0x75,0x02,0x8C,0x41,0xB0,0xFF,0xFF,0x18,0x3B,0xC9,0x11,0x34,0xC0,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+};
+
+uint8_t Lsb0[] = {
+0x33,0x11,0x00,0x80,0x00,0x00,0x44,0x38,0xB3,0x00,0xF4,0xAB,0xFD,0x05,0x0A,0x88,
+0x44,0x00,0x12,0x70,0x11,0x00,0x00,0x98,0x33,0x00,0x14,0xE0,0x44,0x11,0x00,0x80,
+0x00,0x0C,0x14,0x40,0x00,0x11,0x00,0x08,0x80,0xE1,0x09,0xE8,0x00,0x0C,0x1E,0x40,
+0x02,0x06,0xC0,0x33,0x02,0x06,0xD0,0xB3,0x02,0x06,0xCC,0x33,0x04,0xE6,0x0D,0x30,
+0x02,0xE0,0x0D,0xB4,0x80,0xE1,0xC3,0x03,0x00,0x0C,0x06,0x40,0x46,0x00,0x0C,0xB8,
+0x02,0x3C,0x14,0x30,0x81,0x38,0xB0,0xAB,0x02,0x3E,0x14,0xB0,0x81,0x3A,0xB4,0xAB,
+0x22,0x00,0x34,0x60,0x08,0xDA,0x81,0x68,0x01,0xDA,0x59,0xF8,0x10,0x83,0x14,0x08,
+0x00,0xE3,0x14,0x88,0xFF,0x0A,0x4A,0x78,0x40,0xD9,0x7F,0x78,0x40,0x11,0x72,0x00,
+0xB1,0x00,0x96,0x2A,0x40,0xC8,0x47,0xF8,0x80,0xC8,0x91,0x03,0x10,0x11,0x06,0x81,
+0x01,0x11,0x74,0x84,0xFF,0x80,0x14,0x88,0x00,0xE0,0x14,0x88,0xFF,0x0A,0x7E,0xF8,
+0x40,0xD9,0x7F,0x78,0xC0,0xD9,0x14,0x88,0xC0,0x0A,0x7E,0x70,0xA0,0x00,0x10,0x2E,
+0x55,0x11,0x02,0x00,0x01,0x3B,0x14,0xB0,0x00,0x3F,0x14,0x08,0x01,0x0A,0x82,0xE8,
+0x01,0x01,0x22,0xB0,0x40,0xD9,0x57,0xE8,0x80,0xD9,0x6D,0x6A,0xFF,0x00,0x6E,0x78,
+0x11,0x00,0x74,0x70,0x22,0x00,0x7A,0xF0,0x40,0x05,0x0A,0x84,0x20,0xD9,0x1D,0xE9,
+0x02,0xDA,0xDB,0xFD,0xA3,0x00,0x9A,0x2A,0x02,0xDB,0x89,0x68,0x02,0xDA,0xDB,0xFD,
+0xA3,0x00,0x9A,0x2A,0x80,0xDA,0xDB,0xFD,0xA1,0x00,0x78,0xAF,0xA1,0x00,0x34,0xAD,
+0xA1,0x00,0x90,0x2E,0x01,0x01,0x22,0xB0,0x55,0x11,0x00,0x80,0xA2,0x00,0x00,0x28,
+0x02,0x11,0x76,0x04,0x07,0x11,0x2A,0x80,0x01,0x05,0x0A,0x84,0x46,0x00,0x0C,0xB8,
+0x10,0x45,0xC8,0xE8,0x10,0xCE,0xC9,0x68,0x20,0xCE,0xD7,0x68,0x02,0x54,0x40,0x30,
+0xB2,0x00,0x8C,0xAF,0x00,0x0C,0x14,0x49,0x00,0x00,0x90,0x38,0x18,0x10,0xA1,0xB0,
+0x55,0x11,0x02,0x00,0x01,0x25,0x14,0xB0,0x01,0x11,0x4A,0x80,0x05,0x11,0x00,0x80,
+0x18,0xE0,0xA3,0x30,0x55,0x11,0x00,0x80,0x01,0x0A,0x4A,0xB0,0x01,0x01,0x22,0xB0,
+0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,0x01,0x0A,0xBE,0xF0,0x00,0x11,0x92,0x88,
+0x00,0x11,0xA2,0x88,0x07,0x0A,0xBE,0x60,0xFD,0x11,0xC0,0xC0,0xFF,0x11,0xC0,0x40,
+0x0A,0x11,0x92,0x00,0x01,0x0C,0xA2,0xB0,0x02,0x8A,0xC4,0x30,0x80,0x11,0x90,0x84,
+0x01,0xCA,0xD7,0x78,0x00,0x00,0x90,0x38,0x34,0x00,0xA0,0xB8,0xFF,0x00,0xA2,0xB8,
+0x16,0x11,0xA0,0x30,0x16,0x11,0xA2,0xB0,0x00,0x0C,0x18,0xC1,0x40,0xC8,0x15,0x69,
+0x40,0x9E,0x15,0x69,0xB2,0x00,0x80,0x2D,0x00,0x0C,0x14,0x49,0x00,0x11,0x94,0x88,
+0xA1,0x52,0x16,0x71,0xB1,0x00,0xEA,0xAC,0x00,0x0C,0x14,0x49,0xB2,0x00,0x64,0x2D,
+0x03,0x3A,0x19,0xE1,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,0x46,0x0A,0xF6,0xF0,
+0x39,0x0A,0x04,0x71,0x34,0x0A,0x0E,0xF1,0x00,0x0C,0x18,0xC1,0x1B,0x48,0x15,0x88,
+0x13,0x0A,0x18,0xE1,0x02,0x11,0xA8,0xDF,0xB2,0x00,0x1C,0x2D,0x04,0x0C,0x81,0xB2,
+0xB2,0x00,0x2A,0x2E,0x00,0x0C,0x10,0x41,0x1B,0x48,0x15,0x88,0x13,0x0A,0x18,0xE1,
+0x01,0x11,0xA8,0xDF,0xB2,0x00,0x22,0xAD,0x00,0x0C,0x10,0x41,0xB2,0x00,0xF2,0xAC,
+0xB2,0x00,0x64,0x2D,0x00,0x0C,0x18,0xC1,0x02,0xE4,0xC9,0x03,0xB2,0x00,0x40,0xAF,
+0xFF,0xFF,0xC4,0xB8,0x80,0x11,0x90,0x84,0x20,0x11,0x72,0x00,0x02,0xE4,0x3D,0xE9,
+0xFF,0xC0,0x3C,0xE9,0xFF,0xC1,0x3C,0x69,0x0F,0xC2,0x3C,0x69,0x00,0x11,0x94,0x88,
+0x01,0x52,0x14,0xB0,0x01,0x0A,0x32,0xF1,0x05,0x0A,0x3A,0x61,0xB1,0x00,0x8A,0xAC,
+0x00,0x0C,0x3A,0xC1,0x9F,0x00,0x0C,0x38,0x20,0x49,0x39,0xE9,0xA1,0x00,0x98,0xAB,
+0xA1,0x00,0x82,0x2B,0x80,0x11,0xA6,0x5F,0x18,0x11,0xB8,0x80,0xFD,0xE4,0xC9,0x8B,
+0xFF,0xFF,0xC4,0x3C,0x80,0x0B,0x47,0x79,0xB3,0x00,0x54,0x29,0x00,0x0C,0x18,0x58,
+0x02,0x05,0x0A,0x00,0x0F,0xCB,0x77,0x69,0x80,0x48,0x99,0x69,0x20,0xE4,0x99,0x69,
+0x40,0x49,0xA5,0xE9,0xB2,0x00,0xE0,0xAF,0x10,0xE5,0x81,0xE9,0xB2,0x00,0x82,0x2F,
+0x80,0xC8,0x81,0xE9,0x80,0xCE,0x63,0x79,0x20,0xE5,0x99,0xE9,0x08,0xC8,0x8B,0xE9,
+0x00,0x0C,0x70,0x41,0xB2,0x00,0xDA,0xAF,0x20,0xC8,0x8B,0xE9,0x02,0xCA,0x83,0xE9,
+0x02,0x86,0x84,0xE9,0x40,0x4C,0x71,0x79,0x02,0x93,0x70,0x79,0x02,0x7F,0x8A,0xF9,
+0x80,0xE5,0x8B,0xE9,0x80,0xE4,0x91,0xE9,0x00,0x0C,0x06,0x40,0xC0,0x06,0x14,0x38,
+0x8B,0xB0,0x7E,0xA9,0xC0,0x06,0x60,0xB9,0x80,0x11,0x72,0x00,0x08,0x11,0xA2,0xC1,
+0x05,0x11,0xA2,0x41,0x0F,0x11,0x88,0xC1,0x40,0xE5,0xCB,0x03,0x24,0x11,0x88,0xC1,
+0x00,0x0C,0xDC,0xDD,0xFD,0x05,0x0A,0x88,0x00,0x0C,0xD4,0xDF,0x80,0xC8,0x81,0xE9,
+0x80,0x4C,0xA7,0xF9,0xB1,0x00,0xC2,0xA9,0x00,0x0C,0x64,0xDD,0x00,0x0C,0x62,0x42,
+0x06,0x11,0x18,0x80,0x80,0x0B,0xA3,0x79,0x28,0x11,0x18,0x80,0x20,0xE5,0xA3,0xE9,
+0x29,0x11,0x18,0x00,0x00,0x0C,0xDC,0xDD,0x08,0x11,0xB8,0x00,0xB1,0x00,0xC2,0xA9,
+0x00,0x0C,0x62,0x42,0x06,0x11,0xF8,0x03,0x00,0x0C,0xEC,0xDD,0x00,0x0C,0x62,0x42,
+0x46,0x00,0x0C,0xB8,0x02,0x48,0xC1,0x79,0xB1,0x00,0x7A,0xAC,0x80,0x48,0xC3,0x69,
+0x12,0x11,0x94,0x00,0x02,0x52,0x44,0x32,0xB1,0x00,0x8A,0xAC,0x00,0x0C,0xC4,0x41,
+0x80,0x11,0xA6,0x5F,0xB1,0x00,0x8A,0xAC,0x18,0x11,0xB8,0x80,0xFF,0xFF,0xC4,0x3C,
+0x46,0x00,0x0C,0xB8,0xF7,0x00,0x0C,0xB8,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,
+0x40,0xCE,0xDF,0x69,0x80,0xCC,0xD9,0x79,0x07,0x0A,0xF2,0xF1,0x00,0x0C,0xEC,0x41,
+0x06,0x0A,0xDC,0x71,0x16,0x0A,0xEC,0x61,0xA3,0x00,0xB8,0xA8,0x80,0xCC,0xE5,0x79,
+0x41,0x0A,0xE8,0x61,0xA1,0x00,0x68,0xAE,0x40,0x0A,0xE8,0xE1,0xA3,0x00,0xA2,0x28,
+0x20,0xE4,0xC9,0x03,0xB1,0x00,0x90,0x2A,0x18,0x11,0xB8,0x04,0x40,0xCE,0xDB,0x6D,
+0xFF,0xFF,0xC4,0x3C,0x02,0xE4,0x3D,0xE9,0xFF,0xC0,0xEC,0x69,0xFF,0xC1,0xEC,0xE9,
+0x0F,0xC2,0xEC,0xE9,0x80,0x7F,0xFE,0x69,0x07,0x11,0x02,0xC2,0x08,0x01,0xC0,0x3B,
+0x00,0x0C,0x0A,0xC2,0x01,0x0C,0xF8,0xB3,0xB3,0x00,0x54,0xAB,0x00,0x0C,0xEC,0xC9,
+0x0B,0x01,0xC0,0x3B,0xB1,0x00,0xC2,0xAC,0x40,0xCA,0x95,0x03,0xA2,0x00,0x88,0xAF,
+0x00,0x0C,0x64,0xDD,0x18,0x11,0xB8,0x80,0x00,0x0C,0x60,0xC2,0xB1,0x00,0xE0,0xAF,
+0x00,0x0C,0x5C,0x4A,0x04,0x0C,0x49,0x31,0x03,0x0A,0x21,0x62,0x02,0x34,0x15,0x30,
+0x02,0x0A,0x48,0xB1,0xFC,0xFF,0x14,0x38,0x83,0x90,0x48,0xA9,0x08,0x11,0x48,0xB1,
+0x30,0xCE,0x33,0xFA,0x02,0x11,0x48,0x00,0x0C,0xD4,0x4D,0x31,0x04,0xB0,0x4D,0x31,
+0x00,0x11,0x48,0x08,0x02,0x20,0xFC,0xB3,0xB1,0x00,0xD8,0x29,0x44,0x0A,0xE6,0x2B,
+0x0C,0x00,0x14,0x38,0x30,0xCE,0x3F,0xFA,0x14,0x0A,0x14,0x98,0x83,0x90,0x14,0x28,
+0xB1,0x00,0x10,0xAA,0x00,0x11,0xE4,0x0B,0x80,0xF2,0xE5,0x2B,0x20,0x11,0xB8,0x00,
+0xB1,0x00,0x2C,0xAA,0x02,0x08,0xE1,0xB3,0xC0,0x11,0xB2,0xDF,0x02,0xFE,0x41,0xB0,
+0x00,0xFC,0xAF,0xDF,0x02,0xF0,0x79,0x32,0x02,0xF2,0x7D,0x32,0xB1,0x00,0xB8,0x2C,
+0x0E,0x11,0xB2,0x5F,0x00,0x0C,0x60,0xC2,0x18,0x11,0xB8,0x80,0xB3,0x00,0x72,0x2B,
+0xFF,0xFF,0xC4,0xB8,0xB1,0x00,0xCC,0x2C,0xBF,0xCA,0x95,0x8B,0x01,0xE4,0x4B,0x7D,
+0xB3,0x00,0x10,0xAB,0x00,0x0C,0x4A,0xC5,0x00,0x11,0x00,0x08,0x02,0xB4,0x14,0x30,
+0x81,0xB0,0x14,0x28,0x80,0x0A,0x8A,0xEA,0x40,0x0A,0xAE,0xEA,0x20,0x0A,0xC0,0x6A,
+0x10,0x0A,0xC4,0xEA,0x04,0x0A,0xC6,0x6A,0x02,0x0A,0xC8,0xEA,0x01,0x0A,0xCA,0x6A,
+0x08,0x0B,0xCC,0xEA,0x04,0x0B,0xCE,0x6A,0x02,0x0B,0xD0,0x6A,0x01,0x0B,0xD4,0xEA,
+0x48,0xF0,0x60,0x3D,0x23,0x11,0x02,0x80,0x02,0x48,0xE4,0x33,0x33,0x11,0x00,0x80,
+0x00,0x00,0x90,0x38,0x22,0x11,0x00,0x80,0x03,0x11,0x48,0x80,0xC4,0x01,0x18,0x38,
+0xB3,0x00,0x30,0xAA,0x00,0x11,0x48,0x08,0x00,0x0C,0xA2,0xCA,0xB2,0x00,0x3E,0x2E,
+0x00,0x0C,0xAA,0xC2,0x18,0x11,0x18,0x80,0xB1,0x00,0xE0,0xAA,0xC4,0x01,0x1C,0xB8,
+0xF0,0x11,0xE6,0x5F,0x01,0x01,0x22,0xB0,0x80,0x11,0x60,0x05,0x40,0xCE,0xBB,0xEA,
+0x80,0xCE,0xB5,0xFA,0x02,0x54,0x40,0x30,0xB1,0x00,0x9C,0xAB,0x00,0x0C,0xBC,0xCA,
+0x40,0x11,0x60,0x05,0xB1,0x00,0x90,0x2A,0x20,0xE4,0xC9,0x03,0x40,0x11,0x60,0x05,
+0x00,0x0C,0xF2,0x5A,0x20,0x11,0x60,0x05,0x10,0x11,0x60,0x05,0x04,0x11,0x60,0x05,
+0x02,0x11,0x60,0x05,0x01,0x11,0x60,0x05,0x08,0x11,0x62,0x85,0x04,0x11,0x62,0x85,
+0x00,0x0C,0xF2,0x5A,0x02,0x11,0x62,0x85,0x02,0x90,0x14,0x30,0x8B,0x10,0xE4,0xAA,
+0x03,0x0A,0xE0,0x39,0xFF,0x11,0x22,0x20,0x10,0x00,0xD0,0xB9,0x00,0x00,0xD4,0xB9,
+0x01,0x11,0x62,0x01,0x00,0x00,0xE0,0xBD,0x02,0x54,0x40,0x30,0xB2,0x00,0x8C,0xAF,
+0x00,0x0C,0xF0,0x4A,0xC0,0x11,0xDE,0xDF,0x20,0xE5,0xCB,0x03,0xB1,0x00,0x9E,0x2B,
+0x01,0x11,0x62,0x85,0x80,0xCE,0x03,0x6B,0x40,0xCE,0xFD,0x6A,0xB1,0x00,0x9A,0xAB,
+0x00,0x0C,0xDA,0x55,0x20,0xE4,0xC9,0x87,0x18,0x11,0xB8,0x80,0x20,0xE4,0xC9,0x03,
+0xA1,0x00,0x90,0xAA,0x10,0x11,0xB8,0x84,0x9A,0x01,0x0C,0xB8,0x08,0x11,0xB8,0x00,
+0x00,0x00,0x90,0xB9,0x80,0x0B,0x13,0x7B,0x3F,0x4E,0x15,0x88,0x01,0x0A,0x12,0x63,
+0xA3,0x00,0xAA,0x29,0x01,0x0A,0x15,0xB0,0x00,0x11,0x16,0x88,0x8D,0x01,0x18,0xB8,
+0x83,0x0C,0x0C,0xAC,0x00,0x0C,0x42,0x43,0x00,0x0C,0x4A,0xC3,0x00,0x0C,0x40,0xC3,
+0x00,0x0C,0x5A,0x43,0x00,0x0C,0x5A,0x43,0x00,0x0C,0x66,0x43,0x00,0x0C,0x66,0x43,
+0xA3,0x00,0x98,0xA9,0x00,0x0C,0x5A,0x43,0xA2,0x00,0xBC,0xAB,0xA2,0x00,0xA4,0xAB,
+0xA2,0x00,0xBC,0xAB,0x00,0x0C,0x60,0x43,0x02,0x05,0x0A,0x00,0x01,0x4C,0x3B,0xEB,
+0x00,0x11,0xAE,0x5F,0xB2,0x00,0xE8,0xA8,0x60,0x13,0x08,0xB9,0x05,0x11,0xB8,0x04,
+0x15,0x11,0x2A,0x80,0x06,0x11,0x94,0x81,0x33,0x11,0x95,0x31,0x34,0x11,0xAA,0x5F,
+0x10,0x01,0xBC,0x3C,0x06,0x11,0x94,0x81,0x23,0x11,0x95,0xB1,0x24,0x00,0x14,0x38,
+0x83,0x3C,0x99,0x28,0x04,0x11,0xAC,0x5F,0x00,0x11,0xAC,0xDF,0x10,0x34,0xC1,0x30,
+0x10,0x01,0xBC,0x3C,0x34,0x10,0x95,0x31,0x34,0x11,0xAA,0x5F,0x10,0x01,0xBC,0x3C,
+0x10,0x00,0xBC,0x38,0x04,0x3C,0x99,0x30,0x10,0x34,0xC1,0xB4,0x05,0x11,0x94,0x81,
+0x13,0x11,0x95,0xB1,0x04,0x11,0x94,0x31,0x04,0x24,0x95,0xB1,0x08,0x2C,0x95,0x31,
+0x24,0x11,0xAA,0xDF,0x10,0x01,0xBC,0x3C,0x00,0x0C,0x04,0xDB,0x02,0xE4,0x31,0xEF,
+0x04,0x5D,0x8C,0x7B,0x30,0xCE,0x89,0xFB,0x00,0x0C,0x18,0x58,0xB2,0x00,0x40,0x2E,
+0x00,0x0C,0x94,0x4B,0xB2,0x00,0xC4,0xAF,0xB1,0x00,0x1A,0x2D,0x00,0x0C,0x8C,0xC3,
+0xFF,0xC6,0x28,0x7C,0xB1,0x00,0x0C,0xAD,0x00,0x0C,0x18,0x58,0x40,0xCE,0x19,0x6C,
+0x80,0xCE,0x95,0xFB,0x08,0x5D,0xB2,0x6B,0x0F,0xCB,0x2B,0x6C,0x80,0xC8,0x2D,0xEC,
+0x30,0xCE,0xBD,0xEB,0x04,0xC9,0x29,0xEC,0x08,0xC9,0x2F,0xEC,0x01,0x85,0x46,0x6C,
+0xB2,0x00,0xE0,0xAF,0x10,0xE5,0x47,0xEC,0x04,0x85,0x06,0xF8,0xFF,0xC6,0x06,0x68,
+0x02,0x11,0xC4,0x5D,0x00,0x0C,0xD0,0xDD,0x02,0x85,0xB2,0x6B,0xB1,0x00,0xBE,0x29,
+0x00,0x0C,0x28,0xC4,0x00,0x0C,0x9A,0xDF,0x08,0xC9,0xBB,0xEB,0x02,0x11,0x0A,0x81,
+0x00,0x0C,0xF0,0x43,0x04,0x11,0x62,0xC4,0xB2,0x00,0xDA,0xAF,0x20,0xC8,0xD7,0x6B,
+0x02,0xCA,0x33,0x6C,0xC0,0x49,0x43,0xEC,0x02,0x86,0x34,0x6C,0x04,0xC4,0xD6,0xEB,
+0x08,0x5D,0x06,0xF8,0x20,0x84,0x46,0xEC,0x10,0x85,0x06,0xF8,0x10,0x11,0x0A,0x81,
+0x0B,0x0A,0xF1,0xE3,0x01,0x3A,0xF1,0xE3,0xA2,0x00,0xE2,0x2D,0x04,0x5D,0x14,0x08,
+0x00,0xE4,0xC9,0x83,0x02,0x11,0xC4,0x5D,0x00,0x0C,0xD0,0xDD,0x10,0x85,0xEC,0xEB,
+0x20,0x84,0x46,0xEC,0x08,0x11,0xC4,0x5D,0x04,0xE4,0xEB,0xEB,0x08,0x4C,0xEB,0x6B,
+0xB2,0x00,0x50,0xAE,0x00,0x11,0x6A,0xC4,0x10,0x11,0x0A,0x81,0x00,0x0C,0x22,0xC4,
+0x80,0xCC,0xF5,0xEB,0xC0,0xC9,0x23,0x6C,0xFF,0x03,0x23,0x74,0x08,0x48,0xC7,0x0B,
+0x79,0x0B,0xC5,0x0B,0x02,0x02,0x41,0xB0,0x08,0x48,0x17,0x88,0x79,0x0B,0x15,0x88,
+0x02,0xEE,0x41,0x30,0x00,0xE2,0x23,0xE4,0x30,0xCE,0x11,0xFC,0x08,0xCE,0x23,0xFC,
+0x01,0x0B,0x14,0xB0,0x00,0xE3,0x23,0x64,0xB2,0x00,0xDA,0xAF,0x20,0xC8,0x23,0x6C,
+0x02,0x02,0xDD,0xB3,0x06,0x11,0x56,0x5D,0x02,0xEE,0x41,0x30,0x00,0x0C,0x74,0x43,
+0x08,0x5D,0x06,0xF8,0x00,0x11,0x02,0x88,0xDC,0x01,0x1C,0xB8,0xE0,0x11,0xE6,0xDF,
+0x01,0x01,0x22,0xB0,0x08,0x4C,0x27,0xEC,0x04,0x11,0x6A,0x44,0x06,0x11,0x6A,0xC4,
+0x00,0x11,0x62,0x44,0x0D,0x11,0x38,0xC4,0x0E,0x11,0x38,0xC4,0x80,0xE5,0xB3,0xEB,
+0x18,0x11,0x38,0x44,0x19,0x11,0x38,0xC4,0x40,0xE5,0xCB,0x03,0x25,0x11,0x38,0xC4,
+0x80,0x0B,0x5F,0xEC,0x80,0xCE,0x3F,0x7C,0x16,0x10,0x5F,0xF4,0x00,0x0C,0xDC,0xDD,
+0x30,0xCE,0x45,0x7C,0xB2,0x00,0x50,0xAE,0x02,0x11,0x62,0xC4,0x60,0x01,0x08,0xB9,
+0xEF,0xE5,0xCB,0x8B,0x1A,0x11,0x4C,0xC4,0x30,0xCE,0x53,0xFC,0xB2,0x00,0x50,0xAE,
+0x00,0x0C,0x5A,0xC4,0x80,0x0B,0x5F,0x7C,0x3F,0x4E,0x15,0x88,0x01,0x0A,0x5A,0x74,
+0x02,0x0A,0x5E,0x64,0xB3,0x00,0x82,0x2B,0xFF,0x4A,0x75,0x6B,0x00,0x0C,0xAE,0x5F,
+0x02,0x11,0x62,0xC4,0x01,0x0C,0xD6,0xB3,0x08,0x11,0xC4,0x5D,0x01,0xEB,0x19,0xB0,
+0x20,0xE4,0xC9,0x03,0x00,0x0C,0x56,0x5D,0xDF,0x5F,0xBE,0x88,0x04,0x11,0x88,0x81,
+0x00,0x0C,0x2E,0x45,0xB2,0x00,0xC4,0xAF,0x80,0x48,0x91,0xEC,0xC0,0x49,0x91,0xEC,
+0x00,0x11,0x94,0x88,0x10,0x0B,0x83,0xFC,0x18,0x10,0xA5,0x30,0x18,0x11,0x24,0x01,
+0x00,0x0C,0x86,0x44,0x52,0x11,0xEC,0xDF,0x04,0x11,0x24,0x81,0xB1,0x00,0xB8,0x2C,
+0x08,0x11,0xB8,0x00,0x01,0xC0,0x23,0xB0,0xFF,0x11,0x22,0x20,0xB1,0x00,0xC0,0xAB,
+0x02,0xE4,0x31,0xEF,0xB1,0x00,0x0C,0xAD,0x00,0x0C,0x18,0x58,0x02,0x05,0x0A,0x00,
+0x0F,0xCB,0x0B,0x6D,0xB2,0x00,0x82,0x2F,0x80,0xC8,0x0D,0xED,0x80,0x48,0x09,0xED,
+0xC0,0x49,0x23,0x6D,0x30,0xCE,0xC9,0x6C,0xFF,0x58,0xA8,0xEC,0xC0,0xC9,0xFF,0xEC,
+0x04,0xC9,0xFF,0x6C,0x08,0xC9,0x0F,0xED,0x01,0x85,0x18,0x6D,0x04,0x85,0xC2,0xFC,
+0xFF,0xC6,0xC2,0x6C,0x80,0xE4,0xDF,0xEC,0x02,0x11,0xC4,0x5D,0x04,0x7F,0xBC,0x6C,
+0xB1,0x00,0xBE,0x29,0x00,0x0C,0xFE,0x44,0x01,0x11,0xB8,0x00,0x00,0x0C,0x18,0x58,
+0x00,0x0C,0xD2,0xC4,0xFF,0x58,0x06,0xE8,0x02,0x11,0x0A,0x81,0x00,0x0C,0xD2,0xC4,
+0xB2,0x00,0x0A,0xAE,0xB2,0x00,0xDA,0xAF,0x20,0xC8,0xD9,0x6C,0x02,0xCA,0x13,0x6D,
+0x02,0x86,0x14,0x6D,0x80,0xE5,0xDD,0xEC,0x80,0xE4,0xDF,0xEC,0x00,0x0C,0x06,0x40,
+0x00,0x0C,0xB4,0xDF,0x00,0x0C,0xFC,0xC4,0x00,0x0C,0xD4,0xDF,0x30,0xCE,0xE5,0x7C,
+0xB2,0x00,0x0A,0xAE,0x00,0x0C,0xFC,0xC4,0xFF,0x05,0xFD,0x74,0x79,0x0B,0x15,0x88,
+0x02,0x04,0x41,0xB0,0x79,0x0B,0xC5,0x0B,0x02,0xEE,0x41,0x30,0x00,0xE2,0xFD,0xE4,
+0x02,0x04,0xDD,0xB3,0x07,0x11,0x56,0xDD,0x00,0x00,0xC8,0xBB,0x02,0xEE,0x41,0x30,
+0x00,0x0C,0x72,0xC4,0x20,0xE4,0xC9,0x03,0x05,0x11,0x26,0xC5,0x00,0x0C,0xB4,0xDF,
+0x80,0xC8,0x07,0x7D,0x05,0x11,0xDC,0xDD,0x03,0x11,0x26,0xC5,0x01,0x11,0x26,0x45,
+0x06,0x11,0x1C,0xC5,0x08,0x11,0x1C,0x45,0x05,0x11,0x1C,0xC5,0x80,0xE5,0xFB,0x6C,
+0x14,0x11,0x1C,0xC5,0x0F,0x11,0x1C,0xC5,0x40,0xE5,0xCB,0x03,0x24,0x11,0x1C,0xC5,
+0x03,0x11,0x0A,0x01,0x10,0x11,0x1C,0x45,0x00,0x0C,0xDC,0xDD,0x00,0x0C,0xB4,0xDF,
+0x00,0x0C,0x24,0x45,0x08,0x11,0xC4,0x5D,0x03,0x11,0x26,0xC5,0x30,0xCE,0x2D,0x7D,
+0x40,0x9E,0x2D,0xFD,0xB2,0x00,0x50,0xAE,0x00,0x0C,0x56,0x5D,0xB1,0x00,0xB8,0x2C,
+0xFF,0xFF,0xDC,0xBB,0x20,0xE4,0x3F,0xED,0xFF,0x8E,0x3F,0x6D,0xFF,0xC1,0x3F,0xF5,
+0x00,0x0C,0x70,0xDD,0xFF,0xEF,0x3F,0xF5,0x02,0xE0,0x0D,0xB4,0x02,0x05,0x0A,0x00,
+0x7F,0xCA,0x95,0x8B,0x01,0xE4,0x47,0x7D,0xB3,0x00,0x10,0xAB,0x02,0x86,0x4A,0x7D,
+0x00,0x11,0xB0,0x88,0x40,0xE5,0x51,0x7D,0x02,0x11,0x0C,0x81,0x02,0xE6,0xCC,0x01,
+0x00,0x00,0xC8,0xBB,0xFF,0xFF,0x40,0xB8,0x00,0x0C,0x22,0x40,0x02,0x0C,0x0C,0x30,
+0x10,0x11,0xA4,0xDF,0x02,0x06,0x18,0x30,0x00,0x0C,0xB2,0xDF,0x00,0x0C,0x18,0x58,
+0x10,0x49,0x07,0xE8,0xFF,0xFF,0xC4,0x3C,0xB3,0x00,0x54,0xAB,0x00,0x0C,0xDA,0x4D,
+0xB1,0x00,0xE0,0xAF,0x00,0x0C,0x6E,0x4D,0x0E,0x11,0xB2,0x47,0xA3,0x00,0x72,0xAB,
+0x11,0x11,0x02,0x00,0x02,0x05,0x0A,0x00,0x02,0xC0,0x41,0x30,0x02,0x20,0xDC,0x33,
+0x04,0x4C,0xA7,0xED,0x80,0x49,0x8D,0xFD,0xB3,0x00,0x72,0x2B,0x02,0xEE,0x15,0xB0,
+0x88,0x20,0x84,0x2D,0xFF,0xFF,0xDC,0xBB,0x02,0x06,0x41,0x30,0xFF,0x21,0x9C,0x75,
+0xFF,0xEF,0x77,0xF5,0x00,0x0C,0x7A,0xC5,0x02,0x06,0x09,0xB2,0xFF,0xFF,0x0C,0xBA,
+0x04,0x11,0xA4,0xDF,0x02,0x04,0x41,0xB0,0xFF,0x21,0x9C,0x75,0x04,0x4C,0x7B,0xFD,
+0x02,0x20,0x80,0x33,0x00,0x0C,0x9E,0xC5,0xB3,0x00,0xF2,0xAB,0xFF,0xEF,0xBB,0xF5,
+0x01,0x11,0xF6,0x03,0x39,0x02,0xC0,0xBB,0x00,0x0C,0xB2,0x45,0x00,0x11,0xF6,0x0B,
+0xBA,0x01,0xC0,0x3B,0x02,0x06,0x81,0x33,0xFF,0xFF,0x0C,0xBA,0xFF,0xC1,0xB3,0xE5,
+0xFF,0xFF,0x84,0x3B,0x02,0xEE,0x41,0x30,0x02,0x46,0x45,0x30,0x00,0x00,0xC8,0xBB,
+0x80,0xCA,0x95,0x03,0x01,0x01,0x22,0xB0,0xFD,0x05,0x0A,0x0C,0xFF,0xC1,0xDB,0xF5,
+0xB3,0x00,0xF0,0x2B,0x0B,0x11,0xB2,0x47,0x01,0x0C,0xD8,0x33,0x01,0xEC,0xB9,0x30,
+0xB0,0x00,0x18,0x28,0x01,0xEC,0xB9,0x30,0x20,0x5D,0x06,0x68,0xFF,0x11,0x22,0x8C,
+0x00,0x0C,0x18,0x58,0x05,0x11,0xF6,0x80,0x02,0x78,0x14,0x30,0x00,0x7A,0x14,0x00,
+0x89,0x10,0x06,0xA8,0xFF,0x11,0x22,0x8C,0x80,0xCE,0xE1,0xFD,0x80,0x49,0xDB,0x6D,
+0x00,0x0C,0xAE,0x5F,0x80,0x0B,0xDB,0x6D,0x02,0x08,0xE1,0xB3,0x01,0x4D,0xF9,0x33,
+0x80,0x11,0xA4,0xDF,0x80,0xCE,0xF9,0x6D,0x40,0x9E,0xDB,0x6D,0xB2,0x00,0x10,0x2E,
+0x00,0x0C,0xF6,0xCD,0xB2,0x00,0x68,0xAF,0xFD,0x05,0x0A,0x88,0x40,0x11,0xF0,0x5F,
+0x02,0x20,0xFC,0xB3,0xB1,0x00,0xD8,0x29,0x02,0x0C,0x1C,0x98,0x80,0xCE,0x07,0x7E,
+0xF0,0x11,0x26,0x00,0x02,0xF0,0x27,0x30,0x00,0x0C,0x0A,0x46,0xF1,0x11,0x26,0x80,
+0x02,0x22,0x26,0xB0,0x01,0xFC,0x27,0x30,0x00,0x0A,0xB2,0xDF,0x02,0xFE,0x41,0x34,
+0xC0,0xD9,0x14,0x88,0x40,0x0A,0x20,0x76,0xC0,0x0A,0x20,0xF6,0xFF,0x0A,0x1A,0x7E,
+0x40,0x11,0x72,0x84,0x30,0xCB,0x19,0xFE,0x40,0xCB,0x97,0x03,0xBF,0x3D,0x7A,0x0C,
+0x0C,0x03,0x0C,0x38,0x01,0xCD,0xDB,0x6D,0x30,0xCB,0xDB,0xED,0x20,0xD9,0x1C,0x6F,
+0x00,0x11,0xB2,0x89,0xF0,0xD8,0x14,0x08,0x10,0x0A,0x3E,0x76,0x20,0x0A,0x42,0xF6,
+0x90,0x0A,0x36,0x76,0x80,0x0A,0x3A,0xF6,0x00,0x0C,0x1A,0x47,0x08,0xCF,0x45,0x6E,
+0x00,0x0C,0x1A,0x47,0x02,0xCF,0x45,0x6E,0x00,0x0C,0x1A,0x47,0x80,0xCF,0x45,0x6E,
+0x00,0x0C,0x1A,0x47,0x40,0xCF,0x1B,0xFF,0x0F,0xD8,0x14,0x08,0x08,0x0A,0x4E,0xF6,
+0x09,0x0A,0x1E,0x67,0x55,0x11,0x00,0x80,0x01,0x43,0x1F,0x6F,0x00,0x11,0x00,0x08,
+0x44,0xC6,0x0F,0xA8,0x01,0x07,0x14,0xB0,0x00,0x00,0x44,0x38,0x00,0xAF,0x19,0xFF,
+0x02,0xC8,0x91,0x03,0xFE,0x11,0xAC,0x03,0x01,0xC8,0x9F,0xFE,0x11,0x11,0x00,0x80,
+0x08,0xE4,0x7B,0xEE,0x01,0x96,0x17,0x30,0x01,0x97,0x15,0x30,0x16,0x11,0xB2,0x81,
+0x01,0xD8,0x1A,0xB0,0x01,0xD8,0x18,0x30,0x8A,0x0C,0x74,0x2E,0xB3,0x00,0x5A,0xAA,
+0x80,0x0F,0x2E,0x6F,0x00,0x0C,0x7A,0xC6,0xA8,0x00,0x18,0xB8,0xB3,0x00,0x92,0xAB,
+0xFF,0x0A,0x2E,0x7F,0xB2,0x00,0xE8,0x2F,0x84,0x01,0x18,0xB8,0xB3,0x00,0x92,0xAB,
+0x01,0x0A,0xAC,0x33,0x01,0x0A,0x9E,0xE6,0x00,0x11,0xB2,0x89,0xF0,0xD8,0xB0,0x8B,
+0x80,0xD8,0xA5,0x8B,0x70,0xD8,0xB1,0x8B,0x70,0x0B,0x15,0x88,0x00,0xD8,0x9F,0xE6,
+0x80,0x80,0x97,0x7E,0xFF,0xD2,0x9F,0x6E,0x00,0x0C,0x98,0xC6,0x80,0xD2,0x9F,0x66,
+0x20,0xD8,0x9F,0xF6,0x11,0x11,0x00,0x80,0xB1,0x00,0x0A,0xAD,0x00,0x11,0xB2,0x89,
+0xF0,0xD8,0x14,0x08,0x80,0x0A,0xB0,0x0B,0x30,0x0A,0x14,0x08,0x80,0xD8,0xAB,0x6E,
+0x80,0x0A,0x14,0x00,0x01,0xD8,0xB2,0xEE,0x55,0x11,0x00,0x80,0x01,0x43,0xB3,0xEE,
+0x08,0x0A,0x14,0x00,0x00,0x11,0x00,0x08,0x01,0x0A,0xA4,0xB3,0x80,0x0A,0xBA,0x6E,
+0xA3,0x00,0x00,0xA8,0x01,0xD8,0x46,0xB0,0x01,0xD8,0x44,0x30,0x00,0x00,0x14,0x38,
+0x8A,0x22,0x1A,0x2F,0x02,0x22,0x18,0x30,0x02,0xEE,0x15,0xB0,0xB3,0x00,0x5A,0xAA,
+0x80,0x0F,0x1A,0x7F,0xFE,0x8F,0x1B,0x67,0x84,0x01,0x18,0xB8,0xB3,0x00,0x92,0xAB,
+0x01,0x0A,0x1A,0x67,0x20,0xD2,0xDF,0xFE,0x20,0x9E,0x19,0x6F,0x40,0x9D,0xDB,0xFE,
+0xA2,0x00,0xC6,0xAF,0xB2,0x00,0x1E,0x2F,0x00,0x0C,0xF2,0xC6,0x02,0xC9,0xF3,0xEE,
+0x04,0x9D,0xF3,0xFE,0xB3,0x00,0xB6,0xAB,0x04,0x11,0x14,0x30,0x01,0xA8,0x19,0x30,
+0x01,0xA9,0x15,0xB0,0xB3,0x00,0x5A,0xAA,0x80,0x0F,0xF2,0xFE,0xB3,0x00,0xC6,0x2B,
+0x00,0x0C,0x18,0xC7,0x08,0xD2,0x41,0x09,0x01,0xD2,0x15,0xB0,0xB1,0x00,0xFA,0xA8,
+0x11,0x11,0x00,0x80,0x04,0xE5,0xCB,0x03,0x00,0x11,0x00,0x08,0x34,0x11,0xEA,0xDF,
+0xB1,0x00,0x08,0x2B,0xB1,0x00,0x12,0x29,0xB0,0xCC,0x15,0x08,0x10,0x0A,0x0A,0xE7,
+0xB3,0x00,0x5A,0xA9,0xFE,0xC8,0x91,0x8B,0xB3,0x00,0x10,0xAB,0x80,0xCA,0x13,0xEF,
+0xA3,0x00,0x4E,0x2A,0xB1,0x00,0xC2,0xAC,0xC5,0x03,0xC0,0x3B,0x40,0xCA,0x95,0x87,
+0x4F,0x11,0x20,0xC7,0x44,0x11,0x20,0x47,0x51,0x11,0x20,0xC7,0x41,0x11,0x20,0x47,
+0x00,0x11,0x00,0x08,0xFD,0xC9,0x93,0x8B,0x00,0x0C,0xEA,0x5F,0x80,0xCA,0x2F,0x7F,
+0xBF,0x3D,0x7A,0x88,0xC9,0x03,0xC0,0x3B,0x40,0xCA,0x95,0x87,0xFD,0xC8,0x91,0x0F,
+0x00,0x0C,0x18,0x58,0x02,0x02,0x14,0x38,0x81,0xC8,0x15,0xA8,0x02,0x0B,0x46,0x6F,
+0x02,0x0A,0x4C,0xEF,0x10,0xE4,0x75,0xEF,0x0F,0xCB,0x53,0x6F,0x80,0xC8,0x55,0xEF,
+0xEB,0x11,0xB0,0x5F,0x00,0x0C,0x06,0xD0,0x03,0x11,0x56,0xC7,0xFD,0xE4,0xC9,0x8B,
+0xFF,0xFB,0x79,0xFB,0x00,0x0C,0x92,0x44,0xB3,0x00,0xC6,0x2B,0xFB,0x11,0xEE,0x5F,
+0x00,0xFB,0x63,0x44,0x09,0x11,0x56,0xC7,0x12,0x11,0x56,0xC7,0x01,0x0C,0xF4,0xB3,
+0xB2,0x00,0xE8,0x2F,0xB1,0x00,0x90,0x2A,0x22,0x11,0x02,0x00,0xE8,0x11,0xE8,0xDF,
+0x01,0x01,0x22,0xB0,0xB1,0x00,0x08,0x2B,0x00,0x0C,0x74,0x4F,0x00,0x0C,0x18,0x58,
+0x80,0xC8,0x75,0x6F,0x22,0x11,0x02,0x00,0xEB,0x11,0xB0,0x5F,0x01,0x01,0x22,0xB0,
+0x00,0x0C,0x06,0xD0,0x01,0x11,0xF0,0x5F,0xB3,0x00,0xC6,0x2B,0xB2,0x00,0x68,0xAF,
+0xFD,0x05,0x0A,0x88,0x08,0xFB,0x63,0xC4,0x10,0xC7,0xDB,0xFD,0x30,0xCE,0xDB,0xED,
+0x02,0xFA,0x15,0xB0,0x83,0x10,0xF4,0x2B,0x89,0x10,0xDA,0x2D,0x02,0xFC,0xF5,0x33,
+0x30,0x11,0xEA,0x47,0x00,0x0C,0x18,0x58,0x80,0xCA,0x07,0x68,0xB3,0x00,0x4E,0xAA,
+0x00,0x0C,0x62,0x42,0x00,0x0C,0x18,0x58,0x80,0xCA,0x07,0x68,0xB2,0x00,0x68,0xAF,
+0x00,0x0C,0x62,0x42,0x10,0x48,0xDB,0xED,0x10,0x11,0xA6,0x5F,0xFF,0x0A,0xA3,0x7F,
+0x01,0x0A,0xDB,0x65,0x04,0x11,0x80,0xB6,0xA3,0x00,0xB8,0x2A,0xA3,0x00,0xBC,0xAA,
+0xA3,0x00,0xDE,0x2A,0xA3,0x00,0x3E,0xAA,0xA3,0x00,0x38,0xAA,0xA3,0x00,0xA4,0xAA,
+0xA1,0x00,0x50,0xAA,0xA3,0x00,0x1E,0x2A,0x20,0xE4,0xC9,0x03,0x80,0xE4,0xDB,0xED,
+0x08,0x5D,0xDA,0xED,0x06,0x11,0xC4,0xDD,0x05,0x11,0xB8,0x80,0x80,0x11,0xB8,0x00,
+0xB3,0x00,0xB4,0xAA,0x04,0x11,0xD4,0x03,0xB1,0x00,0x9A,0x29,0x01,0xC5,0x0B,0xB0,
+0x00,0x0C,0x18,0x58,0x80,0xE4,0xDB,0xED,0x80,0xC8,0xD3,0x6F,0xFF,0xEA,0x07,0x68,
+0x80,0x11,0xA6,0x5F,0x08,0x11,0xB8,0x84,0x80,0xE4,0xDB,0xED,0x08,0x5D,0xDA,0xED,
+0xA0,0xE5,0xDD,0x6F,0xC0,0x11,0xDE,0xDF,0x00,0x0C,0xC0,0xC7,0xFF,0x00,0xE4,0xEF,
+0x00,0x11,0x86,0x09,0x40,0x11,0x90,0x00,0x01,0x0C,0xB8,0xB4,0xA1,0x00,0x3E,0x2A,
+0xA1,0x00,0x3C,0xAA,0xA1,0x00,0xD4,0xAA,0xA2,0x00,0xE0,0xAB,0xA2,0x00,0xB4,0xAF,
+0xA3,0x00,0x0E,0x2B,0xFF,0xEA,0xDB,0x7D,0xFF,0xEA,0xD5,0x1F,0x00,0x11,0x00,0x08,
+0x00,0x0C,0xF2,0x5F,0x11,0x11,0x00,0x80,0x00,0x0C,0xF2,0x5F,0x55,0x11,0x00,0x04,
+0x02,0x05,0x0A,0x00,0x01,0xCB,0x2C,0xE8,0xEF,0x11,0x50,0x5A,0x00,0x0C,0x2C,0x50,
+0xEF,0x11,0x74,0x5A,0x02,0xCB,0x97,0x03,0xB3,0x00,0x10,0xAB,0x55,0x11,0x02,0x00,
+0x01,0x48,0x15,0xB0,0x01,0x01,0x22,0xB0,0xFF,0x0A,0x2C,0xE8,0x30,0xCB,0x2D,0xE8,
+0x44,0x11,0x02,0x00,0xFA,0x0B,0xC0,0xBB,0x01,0x01,0x22,0xB0,0xFD,0x05,0x0A,0x88,
+0x00,0x0C,0xD8,0xD9,0x02,0x0C,0x1C,0x98,0x20,0xC6,0x27,0x00,0x00,0x11,0x26,0x88,
+0x00,0x0A,0xD6,0x59,0x00,0x04,0xC0,0xBB,0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,
+0x03,0x00,0x0C,0x38,0x01,0xCD,0x2B,0x7A,0x80,0xCA,0x2B,0x6A,0x0F,0xCB,0x9B,0x68,
+0x10,0xCE,0xEB,0x68,0x40,0xC8,0x89,0xE8,0xB2,0x00,0x82,0x2F,0x80,0xC8,0x7D,0x68,
+0x10,0xC8,0x73,0xE8,0x40,0xCE,0xA5,0x68,0x20,0xCE,0xB1,0x68,0x04,0xC8,0x5D,0xE8,
+0x80,0xCA,0x2B,0x6A,0xFF,0x8E,0x59,0x68,0xFF,0xC1,0xF3,0x60,0x40,0x83,0x2A,0x6A,
+0x01,0xC8,0x59,0x68,0x08,0xC8,0x59,0x68,0x80,0xCC,0x59,0x78,0x40,0xC9,0x2B,0xFA,
+0x5A,0x01,0x18,0xB8,0x00,0x0C,0xC4,0x5A,0x08,0xC8,0x63,0x68,0x20,0xC9,0x2B,0xFA,
+0x00,0x0C,0x80,0xC0,0x02,0x11,0x1A,0x80,0x00,0x0C,0xCE,0x5A,0x00,0x0C,0x38,0x59,
+0x00,0x0C,0x80,0x5A,0xFD,0x05,0x0A,0x88,0xB2,0x00,0xDA,0xAF,0x20,0xC8,0x9D,0xE8,
+0xE4,0x11,0x3C,0xC2,0xB2,0x00,0xDA,0xAF,0x20,0xC8,0x9D,0xE8,0xE7,0x11,0x50,0xDA,
+0x00,0x0C,0x2A,0xD2,0x00,0x0C,0x80,0xC0,0x40,0x39,0x80,0xF8,0x40,0x11,0x72,0x00,
+0x00,0x0C,0x38,0x59,0x00,0x0C,0x90,0xDA,0x80,0xC8,0x91,0xE8,0xE8,0x11,0x3C,0xC2,
+0x80,0xC8,0x91,0xE8,0xEB,0x11,0x50,0xDA,0x00,0x0C,0x2A,0xD2,0x01,0x11,0xF8,0xDF,
+0x03,0xC8,0x91,0x0B,0xF0,0x08,0x04,0xB9,0x03,0x11,0x0E,0x81,0x3F,0xC9,0x93,0x0B,
+0x00,0x0C,0x9C,0x40,0x00,0x0C,0x38,0x59,0x40,0xCA,0x2B,0x6A,0xB0,0x00,0xBE,0x2D,
+0x00,0x04,0xC0,0xBB,0x00,0x0C,0x5E,0x41,0x80,0xCC,0xAB,0x68,0x10,0xC9,0x2B,0xFA,
+0x00,0x0C,0x66,0x40,0x40,0xCA,0x2B,0x6A,0x10,0xC9,0x81,0xE8,0x00,0x0C,0x66,0x40,
+0x80,0xCA,0xE5,0x68,0x80,0x83,0xE4,0x68,0x10,0xCA,0xE5,0x68,0x02,0xCA,0xE7,0xE8,
+0xB2,0x00,0xDA,0xAF,0x20,0xC8,0x67,0xE8,0xFF,0xC1,0xF3,0x60,0x02,0xA1,0x42,0x01,
+0xB2,0x00,0x82,0x2F,0xB2,0x00,0xDA,0xAF,0xA0,0xC8,0xE5,0x68,0x80,0x83,0xE4,0x68,
+0x13,0x00,0xE0,0xB9,0xFF,0x11,0x22,0x20,0xFF,0xE8,0xE4,0x68,0x04,0x86,0xE4,0x68,
+0x04,0xA1,0xD8,0x68,0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0x00,0x0C,0xC0,0x40,
+0x80,0xC4,0xE1,0x68,0x04,0xC4,0xE1,0x70,0x01,0xC4,0x89,0x1B,0xFD,0xA1,0x42,0x0D,
+0x00,0x11,0x88,0x0B,0x00,0x0C,0x66,0x40,0xFD,0xA1,0x42,0x0D,0xB2,0x00,0xF2,0x2D,
+0x00,0x0C,0x80,0xC0,0xB2,0x00,0x10,0x2E,0x00,0x0C,0x9A,0xD0,0x02,0xCA,0xF5,0xE8,
+0xFF,0xC1,0x2B,0x72,0xA0,0x00,0x70,0x2D,0xB2,0x00,0xF2,0x2D,0x00,0x0C,0x9A,0x40,
+0xA0,0x00,0x06,0xA8,0x30,0x0A,0x18,0x08,0x30,0x0C,0x00,0x61,0x00,0x11,0x0A,0xC1,
+0x20,0x0C,0x0C,0xE1,0x02,0x0A,0x0C,0x30,0x20,0x11,0xF8,0xDF,0x02,0x06,0x14,0x30,
+0x08,0x11,0x0A,0x41,0x00,0x0C,0x32,0x59,0x00,0x11,0x30,0xD9,0x01,0x0A,0x40,0x31,
+0x01,0x0A,0x2A,0x7A,0x10,0x45,0x18,0xE9,0x00,0x11,0x7E,0x0B,0xF7,0x11,0xFA,0x5F,
+0x02,0xA0,0x98,0xB3,0x01,0x45,0x9C,0x37,0x40,0x45,0x20,0xF9,0x10,0x11,0x30,0x41,
+0x80,0x45,0x2E,0x79,0x80,0xA0,0x2C,0xE9,0x01,0xC8,0x2D,0x79,0xB3,0x00,0x14,0xA9,
+0x00,0x0C,0x2C,0xD1,0xA3,0x00,0x08,0xA9,0x20,0x11,0x30,0x41,0x40,0x11,0x30,0x41,
+0xA2,0x00,0x62,0x2F,0x11,0x11,0x02,0x00,0x01,0x0C,0x96,0x30,0x01,0x01,0x22,0x34,
+0x01,0xA1,0x2A,0xFA,0xF5,0x45,0x8A,0x08,0x10,0x45,0x2A,0x6A,0x20,0x45,0x4C,0x69,
+0x80,0xA0,0x48,0x69,0xF7,0x11,0x74,0x5A,0x80,0x45,0x48,0x79,0x02,0xF4,0x45,0xB1,
+0x00,0x0C,0x50,0xD9,0x01,0x11,0x32,0xC1,0x0A,0x11,0x32,0x59,0x1F,0x11,0x58,0xD9,
+0x08,0xA0,0x14,0x88,0x02,0x0A,0x14,0x00,0x00,0x11,0x16,0x88,0x02,0x0A,0x40,0xB5,
+0x11,0x11,0x02,0x00,0x01,0x0C,0x90,0x30,0x01,0x01,0x22,0x34,0x02,0x05,0x0A,0x00,
+0x04,0x9E,0x65,0x79,0xF9,0x11,0xFC,0xDF,0xDF,0x11,0xFC,0x5F,0xB3,0x00,0xC6,0x2B,
+0x03,0x11,0x90,0xB3,0x10,0x45,0x72,0xE9,0x00,0x00,0x98,0xBB,0x00,0x11,0x9C,0x0B,
+0x00,0x0C,0x76,0x41,0xFE,0xCD,0x9B,0x8B,0xF5,0xCE,0x9D,0x0B,0x00,0x11,0x02,0x88,
+0xF7,0x5E,0xBC,0x88,0x40,0x11,0x90,0x00,0x00,0x11,0x86,0x09,0x40,0xCB,0x83,0x69,
+0x08,0x11,0xB8,0x00,0x01,0x01,0x22,0xB0,0x40,0x3D,0x7A,0x00,0xFF,0xE0,0xC0,0x81,
+0xB3,0x00,0x80,0x2A,0xB3,0x00,0x10,0xAB,0xFD,0x05,0x0A,0x0C,0xFD,0x4D,0x9B,0x8A,
+0xB0,0x00,0x7C,0x2F,0xB3,0x00,0x80,0x29,0xB0,0x00,0xF6,0xAF,0x30,0x45,0x9A,0xF9,
+0x00,0x0C,0xA4,0x59,0x55,0x11,0x02,0x00,0x1D,0x11,0xAC,0x02,0x02,0x4D,0x9B,0x02,
+0x02,0x5B,0xB7,0x02,0x01,0x01,0x22,0x34,0x22,0x11,0x02,0x00,0x02,0x11,0x4A,0x80,
+0xF3,0x11,0x6E,0x5A,0x00,0x0C,0xBA,0xD1,0xC4,0x01,0x1C,0xB8,0xF3,0x11,0x52,0x5A,
+0x00,0x0C,0xB6,0xD1,0xB2,0x00,0x3E,0x2E,0x00,0x0C,0xB8,0xC1,0x08,0x44,0xBA,0xE9,
+0xF3,0x11,0x74,0xDA,0x00,0x11,0x4A,0x88,0x01,0x01,0x22,0x34,0x04,0x11,0x0A,0x81,
+0x00,0x0C,0xD0,0x47,0xB0,0x00,0x18,0x28,0x80,0x5D,0xF8,0x78,0xFF,0x4D,0xCF,0xE9,
+0x80,0x0B,0xCD,0xF9,0x18,0x11,0xD6,0x41,0x10,0x11,0xD6,0xC1,0x0F,0x11,0xD6,0x59,
+0x30,0xCE,0x2B,0xFA,0x40,0x9E,0x2B,0x7A,0xA2,0x00,0x50,0x2E,0xA3,0x00,0x1E,0x2A,
+0x13,0x11,0xD6,0x83,0x02,0x11,0xE0,0xC1,0x17,0x11,0xD6,0x03,0x01,0x11,0xE0,0xC1,
+0x01,0x0C,0xD8,0x33,0xB0,0x00,0x18,0x28,0x02,0x05,0x0A,0x00,0x04,0x3A,0xF8,0xF8,
+0x01,0xEB,0x69,0x30,0x03,0x11,0x6A,0xB0,0xFD,0x05,0x0A,0x88,0xB0,0x00,0x18,0x28,
+0x01,0xEC,0x49,0x30,0xFF,0xCE,0xF9,0x69,0x00,0x11,0x48,0x08,0x00,0x0C,0xF8,0xC0,
+0xC8,0xCC,0x19,0x98,0x01,0x11,0x1A,0x80,0x01,0x12,0x16,0xB0,0x11,0xCC,0x15,0x28,
+0x03,0x0C,0x98,0x8B,0xFF,0xCE,0x9D,0x9B,0xC0,0x0A,0x18,0x98,0x02,0x12,0x40,0xB0,
+0x00,0x11,0x48,0x08,0x01,0x0B,0x14,0xB0,0x44,0x0A,0x18,0xA8,0x02,0x0C,0x1C,0x34,
+0x02,0x0C,0x0C,0x30,0x08,0x0C,0x18,0x18,0x02,0x12,0x1C,0xB0,0x02,0x0A,0x0C,0x30,
+0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,0x83,0x0E,0x1C,0x28,
+0x02,0x06,0x14,0x30,0x80,0x0F,0x28,0xFA,0xFE,0x0C,0x18,0x18,0x02,0x12,0x14,0x30,
+0x02,0x06,0x18,0x30,0xFF,0x11,0x22,0x8C,0x08,0x0C,0x1C,0x98,0x01,0x0D,0x1E,0xB0,
+0x02,0x0A,0x26,0xB0,0x00,0x00,0x26,0xB8,0x10,0x12,0xC0,0x30,0xF0,0x0C,0x18,0x98,
+0x20,0x00,0xBC,0x38,0x49,0x11,0xB8,0x84,0xD4,0x01,0x1C,0x38,0xB3,0x00,0xB4,0xAA,
+0x01,0x0E,0x1A,0x30,0x01,0x0C,0x1C,0xB0,0x01,0x0D,0x18,0xB0,0x00,0x0C,0x7C,0x5A,
+0x04,0x12,0x50,0x30,0x04,0x28,0x26,0xB0,0x00,0x00,0x48,0x38,0x01,0xC5,0x0B,0x34,
+0xD4,0x01,0x1C,0x38,0xB3,0x00,0xB4,0xAA,0x00,0x0C,0x7C,0x5A,0x11,0x12,0x22,0xA8,
+0x00,0x0C,0x6A,0x52,0x02,0x0C,0x0C,0x30,0x02,0x0E,0x18,0xB0,0x04,0x12,0x50,0x30,
+0x02,0x06,0x18,0x30,0xFC,0x0C,0x18,0x98,0x04,0x12,0x50,0x30,0xFF,0x11,0x22,0x20,
+0x11,0x2B,0x22,0xA8,0x00,0x00,0x48,0x38,0x01,0xC5,0x0B,0x34,0x00,0x0C,0x7C,0x5A,
+0x11,0x12,0x22,0xA8,0x00,0x00,0x48,0xBC,0x00,0x0C,0x7C,0x5A,0x02,0x0C,0x1C,0xB0,
+0x00,0x11,0x26,0x88,0x00,0x00,0x48,0xBC,0x03,0x02,0x48,0xB8,0x01,0x11,0x1A,0x04,
+0x10,0x30,0x14,0xB8,0x00,0x0C,0xDA,0x5C,0x00,0x0C,0xA8,0x5A,0x00,0x0C,0x8A,0xCA,
+0x28,0x11,0x8C,0x42,0x29,0x11,0x8C,0xC2,0x00,0x0C,0xD8,0xDA,0x00,0x0C,0xA2,0x42,
+0x40,0xC0,0x14,0xB8,0x00,0x0C,0xDA,0x5C,0x00,0x0C,0xA8,0x5A,0x1C,0x11,0xDC,0xDA,
+0x00,0x11,0x02,0x88,0x18,0x11,0xB8,0x80,0x11,0x11,0x02,0x00,0x08,0x11,0xB8,0x00,
+0x01,0x01,0x22,0xB0,0xFF,0x11,0x58,0x59,0xF7,0xA0,0x40,0x89,0x01,0x11,0x32,0xC1,
+0x20,0xCE,0xBB,0xFB,0x01,0x9F,0xBB,0xFA,0xB2,0x00,0x10,0x2E,0x00,0x0C,0x2A,0xCA,
+0xDF,0x9D,0x3B,0x8B,0x02,0x9F,0x15,0x08,0x44,0x0A,0x14,0xA8,0x00,0x9D,0x3B,0x83,
+0xFC,0x11,0xFA,0xDF,0x20,0x9D,0xBB,0xFB,0xB2,0x00,0x10,0x2E,0x00,0x0C,0x2A,0xCA,
+0x04,0x11,0xF8,0xDF,0x01,0x11,0x22,0x9C,0x04,0xC8,0x91,0x03,0x00,0x0C,0xD4,0xDA,
+0x01,0xC9,0xCF,0xFA,0x03,0x0A,0xCE,0xFA,0x09,0x11,0x1A,0x00,0x01,0x0D,0xE4,0x31,
+0x80,0x11,0x8E,0x81,0xDF,0xC9,0x93,0x0F,0x01,0x0C,0x14,0x30,0x10,0x11,0xE8,0x42,
+0x01,0x0C,0x14,0x30,0x30,0x11,0xE8,0xC2,0x01,0x0C,0x14,0x30,0x60,0x11,0xE8,0xC2,
+0x01,0x0C,0x14,0x30,0x20,0x11,0xE8,0x42,0x01,0x0C,0x14,0x30,0x24,0x11,0xE8,0xC2,
+0xB3,0x00,0xB4,0xAA,0x02,0xCA,0xF1,0xEA,0xF0,0x44,0xF2,0x6A,0x08,0x44,0xF6,0xFA,
+0x08,0x11,0x88,0x00,0x00,0x0C,0x08,0xDB,0x00,0x0C,0x06,0xCB,0xFF,0x21,0x00,0x73,
+0x81,0x0A,0x01,0x63,0x04,0x10,0x81,0xB0,0x01,0x0D,0x89,0x30,0x00,0x0C,0x06,0x43,
+0x01,0x0A,0xB6,0x31,0x04,0xDC,0x80,0x30,0x01,0x0C,0x88,0x00,0x01,0xC5,0x0B,0x34,
+0x08,0x44,0xFC,0xFC,0x0B,0xCB,0x15,0xEB,0x55,0x11,0x02,0x00,0x40,0x4E,0x17,0x88,
+0x01,0x01,0x22,0xB0,0xFF,0x0B,0x08,0xFB,0x08,0x11,0x88,0x00,0x01,0x10,0x22,0x1C,
+0x46,0x00,0x0C,0xB8,0x01,0x39,0x46,0x6B,0x02,0x39,0x2A,0x7A,0x04,0x67,0x14,0x08,
+0x80,0x5B,0x28,0x6B,0x08,0x68,0xB0,0x33,0x30,0x67,0xA4,0x0B,0x00,0x0C,0x32,0xC3,
+0x08,0x53,0xB0,0xB3,0x07,0x53,0x22,0x30,0x30,0x53,0xA4,0x8B,0x08,0xD8,0xD1,0x30,
+0x00,0xD2,0xCF,0x80,0xFF,0x67,0xCE,0x08,0x80,0x11,0xCC,0x00,0x05,0x11,0xB4,0x80,
+0x01,0x11,0x4A,0x80,0x22,0x0A,0x1C,0x28,0xE0,0x0E,0x1C,0x18,0x01,0x11,0x1E,0xA0,
+0x08,0xD8,0x27,0x30,0x07,0x11,0x26,0xB0,0x01,0xD2,0x27,0xB4,0xFF,0x65,0x50,0xFB,
+0xBF,0xE4,0xC9,0x8B,0x0F,0x53,0xC0,0xB0,0x01,0x53,0xFA,0x33,0x00,0x0C,0x58,0xC3,
+0x80,0x5B,0x5C,0xFB,0x40,0xE4,0x5D,0x6B,0x40,0xE4,0xC9,0x03,0x0F,0x11,0xC0,0xB0,
+0x01,0xFD,0xC1,0x30,0x01,0x11,0x72,0x84,0x10,0x53,0xC0,0x30,0x01,0x11,0x72,0x84,
+0x46,0x00,0x0C,0xB8,0x20,0x11,0x08,0x5D,0x00,0x0C,0x00,0xDC,0xFF,0x00,0x2A,0x6A,
+0x30,0xCE,0x2B,0xFA,0x40,0x11,0x90,0x84,0x46,0x00,0x0C,0xB8,0x02,0x54,0x40,0x30,
+0x01,0x48,0x99,0x7B,0x88,0x49,0x83,0x6B,0x20,0x48,0x81,0xEB,0xB3,0x00,0x54,0xAB,
+0x00,0x0C,0x82,0xCB,0x00,0x0C,0xC0,0x5B,0xA1,0x00,0xC0,0xBB,0x40,0xCA,0x95,0x87,
+0x20,0x11,0x06,0xDD,0x00,0x0C,0xBC,0xDB,0x30,0xCE,0x2B,0xFA,0x1B,0x48,0x15,0x88,
+0x01,0x0A,0x2A,0x62,0x04,0x11,0x80,0x32,0xB2,0x00,0x2A,0x2D,0x80,0x4C,0x2B,0x7A,
+0xB3,0x00,0x54,0xAB,0x00,0x0C,0x2A,0xCA,0xC9,0x00,0xC0,0x3B,0x40,0xCA,0x95,0x87,
+0x80,0x11,0x08,0x5D,0x00,0x0C,0xBC,0xDB,0x80,0xCE,0xA3,0xFB,0x80,0x49,0xFD,0x6C,
+0x00,0x0C,0xA4,0xC3,0x40,0x9E,0xFD,0x6C,0x00,0x0C,0xC2,0x5C,0x80,0xE1,0xBB,0x7B,
+0xFF,0x21,0xB6,0xF3,0xB3,0x00,0x54,0xAB,0x00,0x0C,0xB2,0xD3,0x00,0x0C,0xCC,0xDC,
+0x01,0x11,0x22,0x9C,0x00,0x0C,0x7C,0xDB,0x01,0x10,0x22,0x1C,0xD5,0x00,0xC0,0xBB,
+0x40,0xCA,0x95,0x03,0x01,0x10,0x22,0x1C,0x00,0x0C,0x00,0x5D,0x18,0x11,0xB8,0x04,
+0x04,0x40,0x99,0xB0,0x04,0x0C,0xE1,0x30,0x04,0x24,0x31,0x31,0x20,0x10,0xBC,0xB8,
+0x11,0x00,0xD2,0x73,0x20,0x0B,0xD9,0x7B,0xF0,0x04,0x14,0x88,0x60,0x0A,0xD8,0x73,
+0x20,0x11,0xDA,0x43,0x04,0xE5,0xD7,0x6B,0x01,0xCD,0xD9,0xEB,0x05,0x11,0xDA,0xC3,
+0x00,0x11,0xDA,0xC3,0x01,0x05,0x14,0x30,0x82,0x05,0x0A,0x80,0x30,0x50,0xC1,0x30,
+0x01,0x0C,0xB8,0x30,0x01,0x0A,0x0A,0x30,0x40,0xE4,0xC9,0x03,0x20,0x0C,0xEA,0xE3,
+0x02,0xC3,0x86,0x01,0x40,0x61,0x2A,0x6A,0x5F,0x01,0x18,0xB8,0x80,0x5F,0xF3,0xEB,
+0x6F,0x01,0x18,0xB8,0x04,0x12,0x1C,0x08,0x22,0x0E,0x1C,0xA8,0xE0,0x0E,0x1C,0x18,
+0x01,0x11,0x1E,0xA0,0x01,0x11,0x4A,0x80,0x10,0x12,0x26,0xB0,0x00,0x11,0x4A,0x0C,
+0x40,0x61,0x06,0x7C,0x30,0x60,0xA0,0x32,0x00,0x0C,0x18,0xC4,0x20,0x60,0xA0,0xB2,
+0x80,0x6F,0xDF,0x02,0x04,0x6F,0x19,0x08,0x22,0x0C,0x18,0xA8,0xE0,0x0C,0x18,0x18,
+0x01,0x11,0x1A,0x20,0x01,0x11,0x4A,0x80,0x10,0x12,0xE0,0x32,0x00,0x11,0x4A,0x88,
+0x11,0x00,0x32,0x74,0x30,0xCE,0x33,0xFC,0x0C,0x3F,0x29,0xFC,0x01,0x7F,0x28,0x7C,
+0x0C,0x3F,0xB1,0x0B,0x2E,0xD8,0xB1,0xAB,0x03,0x11,0xB2,0xB3,0x04,0xD8,0xE1,0x30,
+0x03,0x3F,0x33,0x7C,0x01,0x93,0x32,0x7C,0x03,0x3F,0xB1,0x0B,0x03,0x11,0xB2,0xB3,
+0x04,0xD8,0x99,0x30,0x04,0x70,0x18,0x32,0x04,0x4C,0x80,0xB2,0xFF,0x00,0x3A,0x7C,
+0x01,0xC4,0x38,0x6C,0x04,0x98,0x48,0x32,0x11,0x00,0x5C,0xF4,0x01,0x7F,0x44,0x7C,
+0x20,0x11,0x06,0xDD,0x00,0x0C,0x00,0x5D,0xFF,0xFF,0xC4,0xB8,0x00,0x0C,0xC2,0x5C,
+0x01,0x93,0x14,0x30,0x02,0x5B,0x4A,0x6C,0x48,0x11,0xB8,0x80,0x30,0xCE,0x79,0x7C,
+0x02,0x0A,0x76,0xEC,0x20,0x49,0x77,0xEC,0x01,0x0A,0x78,0xFC,0x80,0x11,0x08,0x5D,
+0x00,0x0C,0x00,0x5D,0x00,0x0C,0x76,0x44,0x30,0xCE,0x65,0xFC,0x00,0x11,0x02,0x88,
+0x00,0x0C,0xCC,0xDC,0x01,0x01,0x22,0xB0,0x01,0x7F,0x14,0xB0,0x08,0x11,0xB8,0x00,
+0x04,0x0A,0x70,0xEC,0x20,0x48,0x79,0x7C,0x80,0x11,0x08,0x5D,0x00,0x0C,0x78,0xC4,
+0xFF,0xFB,0x18,0xB8,0xB3,0x00,0xD0,0x2A,0x30,0xCE,0x79,0x7C,0xB2,0x00,0x2A,0x2D,
+0x80,0xE4,0xC9,0x87,0x40,0x01,0x18,0x38,0xB3,0x00,0x30,0xAA,0x00,0x0C,0x88,0x4C,
+0x94,0x00,0x18,0xB8,0xB3,0x00,0x30,0xAA,0x00,0x0C,0x88,0x54,0x04,0x94,0x80,0x36,
+0x80,0x11,0x08,0x45,0xB3,0x00,0x54,0xAB,0x00,0x0C,0x2A,0xCA,0xFF,0xFF,0x0C,0xBA,
+0xFF,0xC1,0x97,0x64,0x02,0x20,0x80,0x33,0x02,0x20,0x84,0x37,0x02,0x20,0x14,0xB0,
+0x02,0xC2,0x41,0xB0,0x02,0x0A,0x0C,0xB2,0x02,0x0A,0x84,0x33,0x02,0x0A,0x40,0x34,
+0x46,0x00,0x0C,0xB8,0x08,0x39,0xAE,0xEC,0x04,0x39,0xA8,0xEC,0x10,0x3A,0x2A,0x7A,
+0x00,0x0C,0x00,0xDC,0x04,0x11,0x72,0x00,0x10,0x11,0x74,0x84,0xFF,0x63,0xB6,0x74,
+0xC0,0x11,0x18,0x80,0xB0,0x00,0xDE,0xAF,0x80,0xE5,0xCB,0x03,0x08,0x11,0x72,0x84,
+0xB0,0x00,0x18,0x28,0x08,0x5D,0x2A,0x6A,0x01,0xE4,0xF9,0x78,0x08,0x11,0xB8,0x00,
+0x00,0x0C,0xF8,0xC0,0x08,0xE4,0x2B,0x6A,0x04,0x3C,0xEC,0xB3,0x00,0x11,0x78,0x08,
+0x5F,0x3D,0x7A,0x08,0x08,0xE4,0xC9,0x87,0x02,0x05,0x0A,0x00,0x08,0xE4,0x2B,0xFA,
+0x40,0x3D,0x14,0x08,0xBF,0xF7,0xEF,0x8B,0x00,0xF7,0xEF,0x83,0x04,0xF6,0x79,0xB0,
+0xF7,0xE4,0xC9,0x0F,0x02,0x05,0x0A,0x00,0x00,0xC8,0x91,0x83,0x01,0x0B,0x14,0xB0,
+0x00,0xC8,0x17,0x88,0x00,0x0B,0xE8,0xE4,0xBF,0x3D,0x7A,0x88,0x00,0x11,0xC0,0x89,
+0xA2,0x00,0xE8,0x28,0x02,0x20,0x18,0xB0,0x02,0xF4,0x15,0x30,0xB3,0x00,0x5A,0xAA,
+0x80,0x0F,0xBA,0xFB,0xFF,0x0A,0xBB,0x73,0xC0,0x0A,0x15,0x88,0x80,0x0A,0xBA,0x73,
+0xC0,0x0A,0xBA,0xF3,0x41,0x49,0xBB,0xEB,0x01,0x11,0x22,0x9C,0xA3,0x00,0xA4,0xAA,
+0x08,0x5E,0xBC,0x00,0xFF,0x21,0x2A,0x72,0x08,0x11,0x06,0xC5,0xA3,0x00,0xB8,0x2A,
+0xA3,0x00,0xBC,0xAA,0x02,0xC9,0x93,0x03,0x04,0x5D,0x2A,0xFA,0xFF,0xFB,0x2B,0xED,
+0x30,0xCE,0x17,0xED,0xB2,0x00,0xC4,0xAF,0x00,0x0C,0x26,0xC5,0xB2,0x00,0x40,0x2E,
+0x00,0x0C,0x2A,0xCA,0x0B,0x0A,0x23,0xE5,0x04,0x1F,0x27,0xFD,0x04,0x11,0x60,0x33,
+0x00,0x0C,0x26,0xC5,0x08,0x48,0x27,0x7D,0xB2,0x00,0x24,0x2F,0xFB,0xE5,0xCB,0x8B,
+0x49,0x11,0xB8,0x84,0xFB,0xE5,0xCB,0x8B,0x30,0xCE,0x31,0x6D,0xFF,0xC6,0x2A,0xFA,
+0x01,0x11,0xB8,0x84,0xA3,0x00,0x3E,0xAA,0xAF,0x06,0x0C,0x38,0x02,0xE0,0x14,0xB0,
+0x81,0x80,0xB0,0xAB,0x02,0xE2,0x14,0x30,0x81,0x82,0xB4,0xAB,0x02,0xE4,0x14,0x30,
+0x40,0x0A,0x14,0x00,0x81,0x84,0xB8,0xAB,0x02,0xE6,0x14,0xB0,0x81,0x86,0xBC,0xAB,
+0x40,0xC8,0x4F,0x7D,0x10,0xDB,0xFB,0x6D,0x08,0xD8,0x01,0xB5,0x01,0x88,0x60,0xED,
+0x10,0x88,0x54,0xFD,0x1E,0x11,0x08,0x05,0x08,0x88,0x04,0x6E,0x04,0x88,0x28,0xEE,
+0x02,0x88,0x5C,0x7D,0xA3,0x00,0xD8,0xAB,0x02,0x06,0x22,0x30,0x01,0x11,0x74,0x84,
+0x04,0xDB,0x6F,0xED,0x08,0xDB,0xE7,0xED,0xF0,0xDA,0xED,0xED,0xFF,0xD8,0xDB,0x6D,
+0x03,0xDB,0xA9,0x6D,0x10,0xDB,0xFB,0x6D,0x00,0x0C,0x50,0x45,0xD3,0x06,0x0C,0xB8,
+0x01,0xCD,0x2B,0xEA,0x11,0x11,0x00,0x80,0x01,0xC8,0x79,0xED,0x00,0x11,0x8C,0x8D,
+0x04,0x9E,0x7F,0x7D,0xFB,0x11,0xFC,0x5F,0x02,0x11,0xF8,0xDF,0x70,0x0B,0x15,0x88,
+0x80,0x80,0xB1,0x0B,0x00,0xD8,0x15,0x00,0x08,0xA0,0xB0,0x0B,0x00,0xD8,0x15,0x00,
+0x01,0x0A,0x14,0x00,0x00,0x0C,0xFA,0x58,0x00,0x0C,0x0A,0x5D,0xB2,0x00,0xE4,0x2F,
+0x00,0x11,0x2A,0x8B,0xB3,0x00,0x46,0x2A,0x40,0xCE,0xA3,0xFD,0x01,0x11,0x00,0x00,
+0x02,0x20,0x40,0x30,0x00,0x11,0x00,0x08,0xE3,0x11,0x74,0x5A,0x1A,0x07,0xC0,0x3B,
+0x40,0xCA,0x95,0x87,0x80,0xCC,0x2B,0x6A,0xA3,0x00,0x5A,0x29,0x04,0x11,0x06,0x05,
+0x01,0xCD,0xD9,0xED,0xF7,0xA0,0x40,0x89,0x11,0x11,0x00,0x80,0xFE,0xC8,0x91,0x8B,
+0x10,0xE4,0xC9,0x03,0x01,0x83,0xBC,0xED,0x0F,0x8C,0x14,0x88,0x90,0x0A,0xF4,0x03,
+0xB2,0x00,0xE4,0x2F,0x00,0x0C,0xD4,0x45,0x4C,0x8C,0x14,0xA8,0x80,0x0A,0xF4,0x83,
+0x80,0x8C,0xCC,0x6D,0xF0,0x8C,0x0E,0x08,0x0C,0x07,0xCC,0xED,0xB2,0x00,0xE8,0x2F,
+0xC2,0x07,0xD0,0xED,0x31,0x07,0xD4,0x6D,0xB2,0x00,0xE4,0x2F,0x00,0x0C,0xD4,0x45,
+0xFF,0x95,0xD5,0xF5,0x01,0x95,0x2B,0x1B,0xBF,0x3D,0x7A,0x88,0x00,0x11,0xC0,0x89,
+0x03,0x11,0x06,0x85,0x01,0xCD,0xE5,0xED,0x11,0x11,0x00,0x80,0x02,0xC8,0xE3,0xED,
+0x08,0xE4,0xC9,0x03,0xE8,0x11,0x3C,0xDA,0xFF,0x11,0x00,0x85,0x80,0xCE,0xEB,0xFD,
+0x08,0xC8,0x91,0x03,0x08,0x11,0x06,0x05,0x60,0xCE,0xF5,0xED,0x80,0xCE,0xF9,0xFD,
+0x0C,0xC8,0xB1,0x8B,0x0C,0xD8,0xF9,0xE5,0x20,0x30,0x14,0xB8,0x00,0x0C,0xDA,0x5C,
+0xF0,0x11,0x04,0x05,0x10,0x45,0x02,0xEE,0x03,0xC8,0x03,0x7E,0x80,0xC0,0x14,0xB8,
+0x00,0x0C,0xDA,0x5C,0x10,0x11,0x06,0x05,0x80,0xDC,0x0D,0xEE,0x40,0xDC,0x17,0x6E,
+0x02,0xDE,0x1F,0x6E,0x00,0x0C,0x56,0x45,0x01,0xCD,0x15,0xEE,0x30,0xCB,0x15,0xFE,
+0x80,0xCB,0x15,0xEE,0x80,0xCB,0x97,0x03,0x80,0x11,0x08,0x85,0x00,0x11,0x02,0x88,
+0x40,0x11,0xB8,0x00,0x01,0x01,0x22,0xB0,0x40,0x11,0x08,0x85,0x01,0xA1,0x26,0x7E,
+0xFD,0xE6,0xCC,0x89,0x00,0x11,0x00,0x08,0x00,0x0C,0xA4,0xC3,0x02,0x11,0x0C,0x05,
+0xFF,0xD9,0x59,0x7D,0x81,0x11,0xB0,0x03,0xFF,0x81,0xB2,0x0B,0xFF,0x11,0x02,0x81,
+0x01,0xA1,0x2A,0x6A,0xA3,0x00,0xE6,0x2B,0xB0,0x00,0x18,0x28,0x02,0x05,0x0A,0x00,
+0x10,0xE4,0x5D,0x6E,0x0F,0xCB,0x51,0x6E,0x20,0xE4,0x55,0xEE,0xB2,0x00,0x82,0x2F,
+0x80,0xC8,0x53,0x6E,0x20,0xC8,0x55,0x6E,0xB2,0x00,0xDA,0xAF,0xDC,0x01,0x1C,0xB8,
+0xE3,0x11,0x52,0xDA,0x00,0x0C,0xF8,0x50,0x10,0xC9,0x93,0x03,0x15,0x11,0x56,0xC6,
+0x08,0x11,0x56,0xC6,0x05,0x11,0x56,0x46,0x16,0x11,0x56,0xC6,0xFD,0x05,0x0A,0x88,
+0x00,0x0C,0xFE,0x5C,0x14,0x11,0x64,0xC6,0xFD,0x05,0x0A,0x88,0x00,0x0C,0xB8,0xDC,
+0xB3,0x00,0x72,0x2B,0x0D,0x11,0x64,0x46,0x00,0x0C,0xD6,0x59,0xA0,0x00,0x62,0xAA,
+0x10,0xE4,0x8F,0x6E,0xB3,0x00,0x62,0xAB,0x02,0x58,0x19,0x30,0xFC,0xFF,0x14,0x38,
+0x83,0x90,0x14,0x28,0x8A,0x0C,0x86,0xAE,0xB3,0x00,0x5A,0xAA,0x80,0x0F,0x82,0xEE,
+0x04,0x0C,0x78,0xB2,0x01,0x11,0xFE,0xDC,0xFC,0xFF,0x14,0x38,0x83,0x90,0xB0,0x2A,
+0x00,0x0C,0x86,0xC6,0x04,0x11,0x78,0xB2,0x02,0x11,0xFE,0xDC,0x10,0x50,0xC1,0xB0,
+0x20,0x00,0xBC,0x38,0x69,0x11,0xB8,0x80,0x10,0xE4,0xC9,0x87,0x18,0x11,0xB8,0x04,
+0x01,0x30,0x14,0x30,0xFF,0x0A,0xA6,0xFE,0x01,0x0A,0xA6,0xF6,0x15,0x0A,0xA4,0x76,
+0x0A,0x0A,0x68,0x77,0x02,0x0A,0xA2,0x76,0xF8,0x0A,0x14,0x88,0xC0,0x0A,0x52,0x77,
+0xD0,0x0A,0x54,0xF7,0xA2,0x00,0xEC,0x2F,0xA3,0x00,0xBA,0xA9,0x04,0x30,0xB0,0xB3,
+0x11,0x11,0x00,0x80,0x02,0x22,0x0C,0x30,0x02,0x20,0x0C,0xB0,0x02,0xDA,0x41,0xB0,
+0x02,0x46,0x45,0x30,0x03,0xC8,0xF3,0xEE,0xC0,0xCA,0xF3,0x6E,0x3F,0xCB,0xF3,0xEE,
+0x04,0x06,0x22,0x30,0x01,0xD8,0xF7,0xB3,0x02,0x20,0xDC,0x33,0x20,0x0B,0xFD,0x7E,
+0x40,0x9E,0xF9,0x6E,0xF7,0x11,0xFC,0x5F,0x08,0x48,0x19,0x08,0xB1,0x00,0xF8,0xAF,
+0xB2,0x00,0x1E,0x2F,0x01,0x9D,0xE5,0xEE,0x01,0x02,0x90,0x3B,0x80,0x11,0x94,0x83,
+0x01,0xCD,0x9B,0x03,0x01,0x45,0x9C,0xB3,0xB3,0x00,0x10,0xAB,0xB3,0x00,0x46,0x2A,
+0x01,0xFB,0xE3,0xF6,0xB0,0x00,0x04,0xAB,0x10,0xCE,0xE1,0xFE,0x00,0x0C,0x10,0xDD,
+0xBB,0x01,0xC0,0x3F,0x39,0x02,0xC0,0x3F,0x02,0x9E,0xE9,0xEE,0x04,0x11,0xF8,0xDF,
+0xFC,0x11,0xFA,0xDF,0x30,0x4C,0x19,0x08,0x4C,0x0C,0x18,0x28,0x00,0x0C,0xF6,0xDF,
+0x00,0x0C,0xFC,0x46,0xB3,0x00,0xC6,0x2B,0x02,0x06,0x40,0xB0,0x02,0x06,0x44,0x30,
+0x04,0x3A,0xF8,0xFE,0x04,0xD8,0x69,0xB4,0x70,0x0B,0x15,0x88,0xFF,0x0A,0x06,0x7F,
+0x80,0x80,0x0D,0x6F,0x02,0x82,0xE5,0xB3,0x00,0x0C,0x10,0x47,0x01,0x7C,0x06,0x7F,
+0xFF,0xFF,0xE4,0x3B,0x00,0x0C,0x10,0x47,0x01,0x23,0xE4,0xB3,0x01,0x22,0xE6,0xB3,
+0x08,0x11,0xB8,0x00,0x00,0x00,0x90,0xB9,0x8F,0x80,0x17,0x08,0x00,0x0B,0x94,0x01,
+0x09,0x0B,0x15,0x08,0x55,0x11,0x00,0x80,0x01,0x43,0x21,0x7F,0x08,0x11,0x14,0x00,
+0x11,0x11,0x00,0x80,0xF6,0x81,0x17,0x08,0x00,0x0B,0x94,0x01,0x02,0xF2,0x95,0x31,
+0x08,0x84,0x95,0xB1,0x08,0xA8,0x94,0xB1,0x08,0x94,0x95,0x31,0x09,0x0A,0x38,0x77,
+0x55,0x11,0x00,0x80,0x01,0x43,0x37,0x6F,0x08,0x11,0x40,0x01,0x11,0x11,0x00,0x80,
+0x10,0x04,0xBC,0xB8,0x1C,0x11,0x32,0x5D,0x49,0x11,0xB8,0x00,0x01,0xC8,0x91,0x03,
+0x80,0xCA,0x95,0x03,0xB3,0x00,0x10,0xAB,0x02,0x96,0x71,0xB1,0x01,0xBA,0x74,0x01,
+0xFE,0x11,0xFC,0x5F,0xE8,0x11,0x3C,0xDA,0x02,0x7C,0x4C,0xFF,0x02,0xE4,0xC9,0x03,
+0x00,0x0C,0xD8,0x46,0x02,0x11,0x56,0x47,0x01,0x11,0x56,0x47,0x01,0x0C,0x48,0x30,
+0xC8,0xCD,0x1D,0x98,0x01,0x11,0x1E,0x00,0x01,0x30,0x26,0xB0,0x11,0xCD,0x15,0xA8,
+0x03,0x0E,0x9A,0x8B,0x01,0xCE,0x9D,0x1B,0xC0,0x0A,0x1C,0x18,0x02,0x32,0x26,0xB4,
+0x04,0x30,0xB0,0xB3,0x30,0xCB,0xF9,0xEE,0x44,0x11,0x00,0x80,0x02,0xDA,0xE1,0xB3,
+0x10,0xCB,0x97,0x03,0x80,0xE1,0x2B,0xFA,0xB3,0x00,0x10,0xAB,0x2F,0x08,0xC0,0xBF,
+0x01,0xC7,0x14,0xB0,0x00,0xC5,0x14,0x08,0x80,0x0A,0x8E,0x6F,0x40,0x0A,0x92,0xEF,
+0x20,0x0A,0x96,0x6F,0x08,0x0A,0xB6,0xEF,0x04,0x0A,0xCC,0x6F,0x02,0x0A,0xD6,0xEF,
+0x01,0x0A,0x2A,0x7A,0x01,0x11,0x8E,0x81,0x40,0xC9,0x93,0x87,0x80,0x11,0x8E,0x81,
+0x20,0xC9,0x93,0x87,0x40,0x11,0x8E,0x81,0xE4,0x11,0x9A,0xC7,0x20,0x11,0x8E,0x81,
+0xE0,0x11,0x9A,0x47,0x04,0x0C,0x0C,0x30,0x01,0x11,0x4A,0x80,0x01,0x11,0x1A,0x80,
+0x02,0x0C,0x1C,0xB0,0x04,0x12,0xB0,0xB3,0x01,0x00,0x14,0xB8,0x83,0xD8,0xB1,0x2B,
+0x00,0x00,0x14,0x38,0x84,0xDA,0xB5,0xAB,0x00,0x0C,0xB0,0xCF,0x04,0xD8,0x27,0x30,
+0x02,0x06,0x1C,0xB0,0x02,0x06,0x18,0x30,0xFF,0x11,0x22,0x8C,0x01,0xC7,0x19,0x88,
+0x01,0xCB,0x14,0x08,0x00,0x0C,0xC4,0x77,0xFE,0xC7,0x8F,0x8B,0x00,0xC7,0x8F,0x83,
+0x01,0x0A,0xC6,0xFF,0xEF,0x11,0x74,0x5A,0x08,0x11,0x8E,0x05,0x08,0x11,0x8E,0x81,
+0xEC,0x11,0x3C,0x5A,0xE8,0x11,0x9A,0xC7,0x04,0x11,0x8E,0x81,0x04,0xC8,0x2B,0xEA,
+0x04,0xC9,0x93,0x03,0x59,0x01,0x18,0xB8,0x00,0x0C,0xC4,0x42,0x02,0x11,0x8E,0x81,
+0x04,0xC8,0x2B,0xEA,0x08,0xC9,0x93,0x03,0x58,0x05,0x18,0xB8,0x00,0x0C,0xC4,0x42,
+0xB3,0x00,0xB4,0xAA,0xF8,0x07,0x0C,0x38,0x02,0x48,0x15,0xB0,0x01,0x0B,0xBA,0xEB,
+0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x80,0xE1,0x48,0xF3,0x2F,0x01,0x11,0x22,0x9C,
+0x01,0xC5,0x0B,0x34,0x02,0x48,0x91,0x32,0x00,0x0C,0xE4,0xC7,0xA2,0x00,0x9C,0xAF,
+0xA2,0x00,0xA0,0xAF,0xA2,0x00,0xB0,0x2F,0xA2,0x00,0xB4,0xAF,0x00,0x00,0x01,0xB8,
+0x01,0x4E,0x15,0xB0,0x01,0x4C,0x17,0xB0,0x81,0x5A,0x15,0x28,0x02,0x0B,0x0C,0xF8,
+0xB1,0x00,0x8E,0x29,0x00,0x0C,0x5C,0x40,0x20,0x0A,0x14,0x78,0x30,0xE4,0xC9,0x83,
+0x22,0x11,0x9E,0x82,0xDD,0x5A,0xB5,0x0A,0x02,0x0A,0x1A,0xF8,0x20,0xE4,0xC9,0x03,
+0x02,0x11,0x9E,0x02,0x10,0x0A,0x20,0xF8,0x40,0xE4,0xC9,0x03,0x10,0x11,0x9E,0x02,
+0x40,0x0A,0x26,0xF8,0xFD,0x4D,0x9B,0x8A,0xFD,0x5B,0xB7,0x8A,0x10,0xCB,0x3D,0xE8,
+0xEB,0x0A,0x14,0x08,0xFF,0x0A,0x5A,0xF8,0x20,0xCB,0x5B,0xE8,0x20,0xCB,0x97,0x03,
+0x97,0xC5,0x8A,0x89,0x82,0x08,0xC0,0xBB,0x00,0x0C,0xBC,0x5A,0x40,0x0A,0x44,0x78,
+0x01,0xCB,0x97,0x03,0x00,0x0C,0x44,0x40,0x40,0x4E,0x9F,0x0A,0x20,0x0A,0x44,0xE8,
+0xA9,0x44,0x15,0x88,0xFF,0x0A,0x5A,0xF8,0xA9,0x0A,0x48,0xF8,0x80,0xE4,0xC9,0x03,
+0x01,0x0A,0xDC,0xB3,0x00,0x0C,0x1C,0xDB,0x40,0xEF,0x51,0x78,0x01,0xCA,0x95,0x03,
+0x20,0xE4,0x55,0x78,0x02,0xEE,0xDD,0x03,0x40,0xE4,0x59,0x78,0x10,0xEE,0xDD,0x03,
+0xFE,0x3F,0x7E,0x88,0xFF,0x11,0x9E,0x82,0x01,0x11,0x76,0x04,0x02,0xF0,0x41,0x30,
+0x80,0x0A,0x79,0x70,0x81,0x0A,0x5F,0x73,0x00,0x0C,0x6E,0xC3,0xB2,0x00,0x60,0x2F,
+0x00,0x0C,0x34,0xDB,0xFF,0xF1,0x5F,0x60,0x02,0x05,0x0A,0x00,0x0F,0xCB,0x97,0x0B,
+0x40,0x3D,0x7A,0x00,0x01,0x3F,0x7E,0x00,0xB3,0x00,0x10,0xAB,0xA0,0x00,0x22,0xA8,
+0xF4,0xCB,0x97,0x8B,0x01,0x0C,0x15,0xB0,0x01,0x0A,0x8A,0x70,0x81,0x0A,0x8E,0x70,
+0x02,0x0A,0x92,0x70,0xFF,0x0A,0xC6,0xF8,0x03,0x0A,0x8A,0xF0,0x04,0x0A,0x8A,0x70,
+0x00,0x0C,0xEC,0xC0,0x01,0x11,0xE8,0x03,0x00,0x0C,0xA8,0xC0,0x02,0x11,0xE8,0x03,
+0x00,0x0C,0xA8,0xC0,0x54,0x11,0x02,0x80,0x02,0x05,0x0A,0x00,0x01,0x0D,0x85,0xB2,
+0x55,0x11,0x00,0x80,0x20,0x11,0x9E,0x02,0x20,0x11,0x88,0x82,0x20,0x11,0x9C,0x82,
+0x22,0x5A,0xB5,0x82,0xFD,0x05,0x0A,0x88,0x01,0x01,0x22,0xB0,0x00,0x0C,0xAA,0x40,
+0x00,0x0C,0x2E,0xDA,0x00,0x0C,0xD0,0x5A,0x01,0x11,0xB5,0xF8,0x03,0x11,0x48,0x80,
+0x04,0xD8,0x81,0x33,0x00,0x11,0x48,0x08,0x00,0x0C,0xBE,0xC8,0x34,0x08,0x0C,0x38,
+0x20,0xEE,0x8B,0x6F,0x02,0x11,0x8B,0xFF,0x00,0x0C,0xC8,0xC0,0x00,0x0C,0x34,0xDB,
+0xFF,0xFF,0x40,0xB8,0x40,0xEF,0xA9,0xE9,0x00,0x0C,0x2A,0x41,0x7F,0x08,0x0C,0x38,
+0x55,0x11,0x02,0x00,0x02,0x05,0x0A,0x00,0x04,0x11,0xB0,0x32,0xFE,0x3F,0x7E,0x88,
+0x08,0x11,0x80,0x02,0x00,0x11,0x82,0x8A,0x00,0x11,0x80,0x0A,0xC2,0x60,0xC1,0x02,
+0xFF,0xFF,0x94,0x3A,0xFF,0x11,0x9E,0x82,0x01,0x01,0x22,0xB0,0xB3,0x00,0x6E,0x2A,
+0x97,0xC5,0x8A,0x89,0xB2,0x00,0x22,0xAB,0x03,0x11,0x90,0xB3,0x08,0x11,0x96,0x03,
+0xF0,0x04,0x8A,0xEF,0xFD,0x05,0x0A,0x0C,0x10,0x0D,0xF5,0xF8,0x55,0x11,0x00,0x80,
+0xEF,0x5A,0xB5,0x8A,0x44,0x11,0x00,0x80,0x00,0x0C,0x70,0x5A,0x10,0x0D,0xFF,0x68,
+0x55,0x11,0x00,0x80,0x10,0x5A,0xB5,0x02,0x44,0x11,0x00,0x80,0x00,0x11,0x78,0x8A,
+0x03,0x11,0x7A,0xB2,0x11,0x11,0x66,0x40,0x40,0xEE,0x11,0xF9,0xB1,0x00,0xD8,0x29,
+0x00,0x0C,0x2A,0xDB,0x00,0x0A,0x4E,0xDF,0xBF,0xEE,0xDD,0x8B,0xA9,0xEE,0x6B,0x78,
+0x14,0xCB,0x97,0x83,0xF4,0xCB,0x97,0x8B,0x01,0x11,0xE8,0x03,0xFF,0xFF,0x40,0xB8,
+0x00,0x0C,0xD0,0x5A,0xB1,0x00,0xD8,0x29,0x00,0x0C,0x2A,0xDB,0x00,0x0A,0x4E,0xDF,
+0x08,0xEE,0x27,0xF9,0x00,0x0C,0x52,0x5A,0x00,0x0C,0x6A,0x40,0x80,0xEE,0x6B,0xF8,
+0x40,0xEF,0xA9,0xE9,0x00,0x11,0x62,0x5F,0x91,0x00,0x40,0xB9,0x02,0x00,0x40,0xB9,
+0x01,0x11,0x50,0x5F,0x02,0xFE,0xF5,0xB3,0xB0,0x00,0x7C,0x2F,0xB0,0x00,0x18,0x28,
+0xC0,0xCA,0x5B,0x6F,0x02,0xF4,0x73,0x71,0x00,0x0C,0x3C,0x5B,0xE4,0x11,0x4A,0x5F,
+0x11,0x11,0x5A,0x5B,0xB1,0x00,0xB8,0x2C,0x44,0x11,0x5A,0x5B,0xB0,0x00,0x18,0x28,
+0x40,0xCB,0x59,0xE9,0x80,0xCB,0x69,0xE9,0x00,0x0C,0x1C,0x5A,0x00,0x0C,0xFA,0x49,
+0x02,0xCB,0xFD,0x69,0xE7,0x11,0x48,0xDF,0x00,0x0C,0xFE,0xC9,0x00,0x0C,0x5A,0xC7,
+0x00,0x11,0x5A,0x5B,0xB1,0x00,0xB8,0x2C,0x00,0x00,0x90,0xB9,0x00,0x11,0xB2,0x89,
+0x1C,0xD8,0x94,0x31,0x40,0x11,0x72,0x00,0x1C,0xF0,0xF4,0x3B,0x00,0x0C,0xD8,0xC1,
+0x00,0x0C,0xC8,0xD8,0x84,0x80,0x40,0x38,0x0C,0x11,0x4E,0xDF,0xFF,0xFF,0x40,0xB8,
+0x00,0x0C,0x6A,0x40,0x00,0x0C,0xBC,0x5A,0x55,0x11,0x00,0x80,0x10,0x11,0x80,0x02,
+0x44,0x11,0x00,0x80,0x2D,0x11,0x52,0x5F,0x02,0x05,0x0A,0x00,0x0F,0xCB,0x97,0x0B,
+0xB3,0x00,0x10,0xAB,0xFD,0x05,0x0A,0x88,0xB0,0x00,0x18,0x28,0x00,0x0C,0x1C,0x5A,
+0x00,0x0C,0x94,0xC9,0x08,0xC7,0x90,0x79,0x08,0x11,0x8E,0x81,0x01,0xCB,0x94,0xF9,
+0xFF,0xF1,0x6B,0xE0,0x00,0x0C,0x5A,0xC7,0x40,0x11,0x72,0x00,0xB0,0x00,0x18,0x28,
+0x55,0x11,0x00,0x80,0x40,0x48,0xA3,0x69,0x44,0x11,0x00,0x80,0xFF,0xF1,0x6B,0xE0,
+0x00,0x0C,0x5A,0xC7,0x90,0x11,0x80,0x82,0x44,0x11,0x00,0x80,0x00,0x0C,0x6A,0x40,
+0x02,0xCC,0x0D,0xB0,0xB1,0x11,0x14,0x80,0xB1,0x00,0xFA,0xA8,0xB1,0x00,0x1C,0xA9,
+0x02,0x06,0x14,0x30,0x01,0x0B,0xB8,0x79,0xB0,0x00,0x18,0x28,0x01,0xCD,0x5B,0x6F,
+0xFE,0xCD,0x9B,0x8B,0xB0,0x00,0x18,0x28,0x40,0xCA,0x5B,0xEF,0xD0,0x01,0x1C,0xB8,
+0xE8,0x11,0x54,0x5F,0xB0,0x00,0x18,0x28,0x40,0xCB,0xD5,0x69,0x00,0x0C,0x1C,0x5A,
+0x00,0x0C,0xFA,0x49,0x02,0xCB,0xFD,0x69,0xD0,0x01,0x1C,0xB8,0xEB,0x11,0x46,0x5F,
+0x00,0x0C,0x00,0x4A,0x00,0x0C,0x5A,0xC7,0x00,0x11,0x5A,0x5B,0x14,0x20,0xF4,0x3B,
+0xB1,0x00,0xD8,0x29,0x01,0x0A,0xC4,0xB3,0x01,0xFA,0x15,0xB0,0x00,0x11,0x16,0x88,
+0xB1,0x00,0x10,0xAA,0xB1,0x00,0x2C,0xAA,0x02,0x0C,0x1C,0x98,0xFF,0xC6,0x27,0x08,
+0x01,0xFB,0x27,0xB0,0x02,0x0A,0x26,0xB0,0xB1,0x00,0xB8,0x2C,0x00,0xE2,0x4F,0x5F,
+0xFF,0xFF,0x40,0xB8,0x44,0x11,0x5A,0x5B,0xFB,0xCB,0x97,0x8B,0x01,0xF6,0xEB,0x33,
+0x00,0x0C,0x6A,0x40,0x01,0x11,0x02,0xC2,0x02,0x11,0x02,0xC2,0x00,0x11,0x02,0x42,
+0x03,0x11,0x02,0x42,0x01,0x0C,0xE4,0x33,0xB1,0x00,0xD8,0x29,0x03,0xF2,0x0B,0x62,
+0x00,0x11,0xEA,0x8B,0x02,0x0C,0x1C,0x98,0x18,0xC6,0x27,0x80,0x01,0xF2,0x27,0xB0,
+0x01,0xF5,0x27,0x30,0x00,0x0A,0x4E,0xDF,0x35,0x08,0x0C,0xB8,0xFF,0xF5,0xC9,0xF8,
+0xFF,0xF5,0xEB,0x9B,0x00,0x0C,0x52,0x42,0x55,0x11,0x02,0x00,0x40,0x4E,0x2B,0xFA,
+0x00,0x11,0x82,0x8A,0xC0,0x11,0x9E,0x82,0x01,0x11,0x76,0x80,0x01,0x01,0x22,0xB0,
+0x01,0x10,0x22,0x1C,0x01,0x01,0x22,0xB0,0x01,0x11,0x22,0x9C,0x00,0x0C,0xBC,0x5A,
+0x00,0x0C,0x70,0x5A,0x01,0x10,0x9F,0xB3,0x01,0x16,0xED,0xB3,0x01,0x16,0xEB,0xB3,
+0x01,0x11,0x41,0xFA,0x03,0x11,0x48,0x80,0x04,0x12,0x81,0x33,0x00,0x11,0x48,0x08,
+0x55,0x11,0x00,0x80,0x03,0x0A,0x82,0xF2,0x04,0x0A,0x82,0x72,0xFD,0x11,0x9E,0x02,
+0xEB,0x00,0xF0,0x3B,0x10,0x42,0x4F,0xEA,0x10,0xF8,0xF1,0x03,0xFD,0x60,0xC1,0x8A,
+0x44,0x11,0x00,0x80,0xE3,0x11,0x58,0xDF,0x00,0x0C,0x5E,0xD2,0xB0,0x00,0x18,0x28,
+0xD8,0x01,0x1C,0x38,0xE3,0x11,0x46,0xDF,0x00,0x0C,0x5A,0x57,0x55,0x11,0x02,0x00,
+0x00,0x11,0x82,0x8A,0x80,0x11,0x8E,0x82,0x10,0x11,0x80,0x02,0x90,0x11,0x80,0x82,
+0x02,0xF8,0xB5,0xB2,0x01,0x01,0x22,0xB0,0xD8,0x01,0x1C,0x38,0xE0,0x11,0x54,0xC7,
+0x54,0x11,0x02,0x80,0x01,0x0F,0xA1,0x32,0x01,0x0D,0x85,0xB2,0x01,0x0E,0x8B,0x32,
+0x06,0x11,0xE2,0x02,0x00,0x11,0xE4,0x8A,0x29,0x11,0xE6,0x02,0x01,0x11,0xD8,0x82,
+0x01,0x01,0x22,0x34,0x01,0xA2,0x18,0x38,0x03,0x02,0x1C,0x38,0x03,0x0A,0x8E,0xF2,
+0x08,0xA1,0x18,0x38,0x11,0x10,0x1C,0x38,0x01,0xCA,0x95,0x03,0x00,0x11,0x8C,0x0A,
+0x3D,0x60,0xC1,0x8A,0x01,0x0C,0x82,0xB2,0x50,0x11,0x80,0x82,0x08,0x11,0xC4,0x83,
+0xFF,0xE2,0xC5,0x9B,0xFF,0xE2,0x99,0xEA,0xA0,0x41,0x83,0x82,0x01,0x0E,0x14,0xB0,
+0x00,0x49,0xC5,0x8B,0xFF,0xE2,0xA1,0xFA,0x01,0x0D,0x82,0x32,0x01,0x0F,0x14,0x30,
+0x00,0xE2,0xAD,0x6A,0x00,0x49,0xAB,0x7A,0x80,0x11,0x9C,0x82,0xE0,0x11,0x82,0x82,
+0x03,0x11,0x8C,0x82,0xA0,0xE4,0xC9,0x83,0x82,0x11,0xDC,0x03,0x00,0x0C,0x1C,0xDB,
+0xFF,0x11,0x9E,0x82,0x44,0x11,0x00,0x04,0x04,0xCB,0x97,0x03,0x22,0x11,0x02,0x00,
+0x97,0xC5,0x8A,0x89,0xEF,0x11,0x56,0x5F,0xFE,0xC7,0x8F,0x8B,0x01,0x01,0x22,0xB0,
+0x08,0x11,0x88,0x00,0x02,0x00,0x40,0xB9,0x00,0x11,0x8A,0x88,0x00,0x11,0x50,0xC7,
+0x01,0x3F,0x7E,0x00,0xC0,0x01,0x1C,0x38,0xEC,0x11,0x54,0xDF,0xB0,0x00,0x18,0x28,
+0x80,0xE4,0xE9,0x7A,0x80,0xEE,0xE5,0x7A,0x02,0xF4,0xE5,0x72,0xB2,0x00,0x22,0xAB,
+0x68,0xC5,0x8A,0x01,0xB1,0x00,0x9A,0x29,0xB3,0x00,0x78,0xAA,0x00,0x0C,0x06,0x43,
+0x55,0x11,0x02,0x00,0x20,0xE4,0xF3,0xFA,0x04,0x4E,0xF9,0xFA,0x04,0x11,0x88,0x82,
+0x00,0x0C,0xFC,0xC2,0xC0,0x01,0x1C,0x38,0xEF,0x11,0x46,0xDF,0x00,0x0C,0xFC,0x4A,
+0x01,0x11,0x22,0x00,0x00,0x0C,0x5A,0xC7,0xFE,0x3F,0x7E,0x88,0x01,0x44,0xDD,0x33,
+0x00,0x0C,0x1C,0xDB,0xFF,0x11,0x9E,0x82,0x01,0x01,0x22,0xB0,0x1F,0xE4,0xC9,0x8B,
+0xFF,0x21,0x14,0x73,0x11,0x11,0x60,0xDF,0x00,0x11,0x78,0x8A,0x01,0xEE,0x7B,0xB2,
+0x01,0xEF,0x7D,0x32,0x01,0xF3,0x7F,0x32,0x01,0xCB,0x14,0x08,0xFE,0xC7,0x8F,0x8B,
+0x00,0xC7,0x8F,0x83,0x11,0xEE,0x23,0xAC,0x01,0x43,0xDF,0x33,0x80,0x48,0xE7,0x8B,
+0xFF,0x11,0x94,0x06,0x06,0x11,0x96,0x01,0x68,0xC7,0x8A,0xFF,0x68,0x11,0x8E,0x81,
+0x80,0x11,0x74,0x84,0x02,0x0C,0x1C,0x98,0x10,0xC6,0x27,0x00,0x01,0xEE,0x27,0x30,
+0x01,0xEF,0x27,0xB0,0x01,0xF3,0x27,0xB4,0x02,0x00,0xE1,0x33,0xFF,0xF1,0x3B,0xE3,
+0x11,0x11,0x4E,0xC7,0x12,0x11,0x4E,0xC7,0x11,0x11,0x02,0x00,0x08,0x11,0xB8,0x00,
+0x01,0xC0,0x23,0xB0,0x02,0x11,0x4A,0x80,0x03,0xE0,0x15,0x08,0x1C,0x00,0x98,0x38,
+0xFC,0xE0,0xC1,0x08,0x07,0xE1,0xC1,0xB0,0x1C,0x11,0xC0,0x00,0x06,0x11,0xC0,0xB0,
+0x44,0x0A,0xC0,0xA8,0x00,0x11,0x4A,0x88,0x10,0x04,0xBC,0xB8,0x49,0x11,0xB8,0x00,
+0x01,0x01,0x22,0x34,0x80,0xE1,0xC3,0x03,0x01,0x0C,0x00,0xB4,0xB1,0x00,0xE8,0x2A,
+0x00,0x0C,0x6C,0xCB,0xF0,0x0D,0x6B,0xFB,0x01,0x0C,0x6B,0xFB,0xB1,0x00,0x08,0x2B,
+0x00,0x0C,0x6C,0xCB,0x00,0x11,0x66,0x40,0x09,0x11,0x66,0x40,0x01,0x0C,0x15,0xB0,
+0xFF,0x0A,0x76,0x7B,0x01,0x0A,0x8C,0x73,0x00,0x0C,0x9E,0xC3,0x02,0x05,0x0A,0x00,
+0x22,0x11,0x02,0x00,0x01,0x11,0x4A,0x80,0x42,0x11,0x00,0x80,0x0C,0xE0,0x21,0xB2,
+0x22,0x11,0x00,0x80,0x00,0x11,0x4A,0x88,0x45,0x11,0x00,0x00,0x04,0x3C,0x39,0xB2,
+0x01,0x01,0x22,0xB0,0x0A,0x11,0x66,0x40,0x02,0x05,0x0A,0x00,0x22,0x11,0x02,0x00,
+0x01,0x11,0x4A,0x80,0x0C,0x11,0xC0,0xB3,0x00,0x11,0x4A,0x88,0x55,0x11,0x00,0x80,
+0x04,0x11,0x78,0xB2,0x01,0x01,0x22,0xB0,0x00,0x11,0x66,0x40,0x01,0x11,0x04,0x01,
+0x01,0xE2,0xC4,0x01,0x00,0x11,0x66,0x40,0x04,0x4C,0xBD,0xFB,0xFB,0xFF,0x18,0xB8,
+0xB3,0x00,0xFE,0x2A,0x08,0x11,0x5E,0xDF,0x00,0x0C,0xD4,0xDC,0xCA,0x11,0xE0,0xDB,
+0x0C,0x28,0x95,0x31,0x10,0x3F,0xB7,0x7B,0x04,0x34,0x95,0x31,0x10,0x00,0xBC,0x38,
+0x00,0xC8,0x4C,0xDF,0x00,0x0C,0xDA,0xC3,0x80,0x9E,0xC1,0x7B,0xA0,0x00,0xEA,0x2B,
+0x00,0x0C,0x26,0xDE,0x00,0x0C,0xCC,0xDC,0x14,0x10,0x95,0xB1,0x00,0xC8,0x4C,0xDF,
+0x08,0x48,0xD7,0xEB,0x10,0x00,0xBC,0x38,0x11,0x48,0x15,0x88,0x11,0x0A,0xD8,0xE3,
+0x04,0x0C,0x81,0xB2,0x00,0x0C,0x2A,0xDE,0x00,0x0C,0xDA,0xC3,0x10,0x20,0xBC,0xB8,
+0x04,0x11,0x80,0x32,0x00,0x11,0x94,0x88,0x04,0x11,0xA4,0xB0,0x04,0x11,0x24,0x05,
+0x01,0x0C,0x1C,0xB0,0x00,0x11,0x1E,0x08,0x46,0x11,0x26,0x80,0x0F,0x11,0x27,0x08,
+0x00,0x00,0x26,0x3C,0x46,0x00,0x0C,0xB8,0x01,0xCA,0xF5,0x7B,0xFE,0xCA,0x95,0x8B,
+0x40,0xCB,0x97,0x03,0x20,0x11,0xB8,0x84,0x02,0xC8,0xF9,0xFB,0x80,0xC4,0x89,0x03,
+0x02,0x38,0x0D,0xB4,0xB1,0x00,0x98,0x2B,0x00,0x0C,0x00,0xC4,0x18,0x11,0xB8,0x80,
+0x40,0x11,0x90,0x00,0xFD,0xE4,0xC9,0x8B,0xFF,0xFF,0xC4,0xB8,0xFF,0x11,0x22,0x8C,
+0x04,0x11,0x5E,0xDF,0x00,0x0C,0xB0,0xDD,0x0C,0x94,0x10,0xF4,0x10,0x3F,0x7F,0x02,
+0xB1,0x00,0x8A,0xAC,0x00,0x0C,0xFE,0xC3,0x00,0x0C,0xC0,0x5D,0x80,0xB5,0xFF,0x6B,
+0x02,0x0A,0x0C,0xB8,0x08,0x48,0x31,0x7C,0x21,0xB5,0x27,0x6C,0x18,0x11,0xB8,0x80,
+0xFF,0xFF,0x4C,0xBB,0x1B,0x48,0x15,0x88,0x00,0x0C,0xE6,0x44,0x02,0x20,0x0C,0xB0,
+0xF8,0x1C,0x17,0x08,0x00,0x0C,0x02,0x5F,0x02,0x06,0x40,0xB0,0x00,0x0C,0x3A,0xC4,
+0xFF,0xFF,0x4C,0xBB,0x21,0xB5,0x3B,0xEC,0x0B,0x0A,0x3B,0xF4,0x40,0x48,0x3D,0xEC,
+0xA0,0x00,0xFE,0xA9,0x0C,0x11,0x3E,0x44,0x0B,0x11,0x3E,0xC4,0xA0,0x00,0x02,0xAA,
+0x00,0x0C,0x58,0xDD,0x01,0x48,0x4B,0x6C,0x00,0x0C,0xB0,0xDD,0x04,0xE4,0xC9,0x03,
+0x00,0x0C,0xCC,0x45,0x00,0x0C,0xB0,0xDD,0x00,0x0C,0xD8,0x45,0x40,0x4C,0x61,0xFC,
+0x01,0xB6,0x6B,0x33,0x1B,0x48,0x15,0x88,0x01,0x0A,0x60,0xE4,0x80,0x11,0x5E,0xDF,
+0xFF,0xFF,0x4C,0xBB,0x02,0x11,0x48,0x00,0x0C,0xD4,0x51,0xB2,0x00,0x11,0x48,0x08,
+0xB1,0x00,0x72,0xAB,0x08,0x49,0x05,0xEC,0x00,0x0C,0x06,0xC4,0xFF,0x09,0x0C,0x38,
+0xB1,0x00,0x8A,0xAC,0x08,0x48,0x73,0x6E,0x04,0x0C,0xB1,0x33,0x00,0x0C,0x30,0x5E,
+0x00,0x0C,0x22,0x45,0x46,0x00,0x0C,0xB8,0x02,0xE4,0x7D,0xFC,0xFD,0xE4,0xC9,0x8B,
+0x02,0x5E,0x14,0xB0,0x00,0x0C,0xFE,0xC3,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,
+0xA1,0x0A,0xB2,0x74,0x34,0x0A,0x14,0x74,0x46,0x0A,0xA6,0x74,0x39,0x0A,0xB0,0x74,
+0x41,0x0A,0x70,0xF6,0x5F,0x0A,0x90,0xF4,0x27,0x0A,0xFA,0x73,0x00,0x0C,0xFE,0xC3,
+0x18,0x48,0x15,0x88,0xFF,0x0A,0xFA,0x6B,0x01,0x11,0x94,0x80,0x20,0x52,0x14,0x08,
+0x5B,0x0A,0x14,0x28,0x01,0x0A,0x14,0x18,0x03,0x0A,0x14,0x10,0x00,0x48,0xFB,0x7B,
+0x01,0x0A,0x42,0xFC,0x46,0x3A,0x43,0x64,0x00,0x0C,0xFA,0x43,0x00,0x11,0x86,0x09,
+0x46,0x3A,0xFB,0xE3,0x01,0x48,0xFB,0xFB,0xB1,0x00,0x80,0x2B,0x00,0x0C,0x04,0x44,
+0x00,0x0C,0xFA,0x43,0x02,0x11,0x94,0x80,0x77,0x52,0x14,0x88,0x88,0xB5,0x6B,0x0B,
+0x00,0xB5,0x6B,0x83,0x01,0x11,0x94,0x80,0x40,0x52,0xC0,0xEC,0x20,0xCA,0x95,0x03,
+0x4A,0x0B,0xC0,0x3B,0x50,0xCA,0x95,0x83,0xB1,0x00,0xC2,0xAC,0x02,0x11,0x4A,0x80,
+0x02,0x22,0xF8,0xB3,0x00,0x0C,0x06,0xC4,0x09,0x0A,0xD5,0x74,0x0A,0x0A,0xED,0xF4,
+0x04,0x1F,0xF3,0x7C,0x01,0x00,0x74,0xBE,0x0B,0x48,0xF3,0xFC,0x1B,0x48,0x15,0x88,
+0x08,0x0A,0xF2,0xEC,0x11,0x0A,0x1C,0xF5,0x12,0x0A,0x22,0x75,0x13,0x0A,0x28,0xF5,
+0x01,0x0A,0xFE,0xF4,0x02,0x0A,0xF8,0xF4,0x03,0x0A,0x04,0xF5,0x19,0x0A,0x10,0x75,
+0x1A,0x0A,0x0A,0xF5,0x1B,0x0A,0x16,0xF5,0x02,0x00,0x74,0x3A,0xFF,0x20,0x9C,0x3A,
+0x04,0x0A,0x70,0x3E,0x34,0x00,0x74,0x3A,0xFF,0x00,0x9C,0xBA,0x0A,0x0A,0x70,0xBE,
+0x5F,0x00,0x74,0xBA,0xFF,0x20,0x9C,0x3A,0x22,0x0A,0x70,0xBE,0x5F,0x20,0x74,0x3A,
+0xFF,0x20,0x9C,0x3A,0x25,0x0A,0x70,0x3E,0x5F,0x00,0x74,0xBA,0xFF,0x00,0x9C,0xBA,
+0x20,0x0A,0x70,0x3E,0x41,0x00,0x74,0xBA,0xFF,0x20,0x9C,0x3A,0x31,0x0B,0x70,0xBE,
+0x41,0x20,0x74,0x3A,0xFF,0x20,0x9C,0x3A,0x35,0x0B,0x70,0x3E,0x41,0x00,0x74,0xBA,
+0xFF,0x00,0x9C,0xBA,0x2F,0x0B,0x70,0xBE,0x46,0x00,0x74,0x3A,0xFF,0x00,0x9C,0xBA,
+0x27,0x0A,0x70,0xBE,0x39,0x00,0x74,0xBA,0xFF,0x00,0x9C,0xBA,0x33,0x0A,0x70,0xBE,
+0x03,0x00,0x74,0x3E,0x20,0x48,0x49,0x6D,0x40,0x4C,0x49,0xED,0x1B,0x48,0x15,0x88,
+0x08,0x0A,0x42,0x7D,0x40,0x01,0x18,0x38,0x01,0x0A,0x38,0x6D,0x28,0x01,0x18,0xB8,
+0xB3,0x00,0x30,0xAA,0x00,0x0C,0x8A,0xCF,0x7F,0x11,0xB4,0x5F,0x01,0x48,0x11,0xED,
+0xFF,0x11,0x22,0x8C,0x10,0x0A,0x8A,0xEF,0x01,0xB6,0x6B,0x33,0x00,0x0C,0xDA,0x44,
+0x1B,0x48,0x15,0x88,0x01,0x0A,0x52,0xE5,0x0A,0x0A,0xF3,0xF4,0xB0,0x00,0x6C,0xAA,
+0x00,0x0C,0x28,0x45,0x08,0x0A,0xF2,0x7C,0x7F,0x11,0xB4,0x5F,0x00,0x0C,0x28,0x45,
+0x01,0x11,0x94,0x80,0x20,0x52,0x18,0x08,0x5B,0x0C,0x18,0x28,0x01,0x0C,0x18,0x18,
+0xB0,0x00,0xA8,0x2F,0x00,0x0C,0xD4,0xC4,0x00,0x00,0x90,0x38,0x02,0x3A,0x71,0xF5,
+0x01,0x3A,0x41,0x77,0x03,0x3A,0x41,0xF7,0x02,0x3A,0xA1,0xB0,0x00,0x0C,0x72,0x45,
+0x5F,0x00,0xA0,0x38,0x02,0x4E,0xA3,0x30,0x16,0x11,0xA0,0x30,0x16,0x11,0xA2,0xB0,
+0x10,0x10,0x90,0x38,0x04,0x24,0xA1,0xB0,0x41,0x3A,0x8B,0x67,0x04,0x10,0xA2,0xB4,
+0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,0xA1,0x0A,0xA4,0x75,0x08,0xCE,0xA9,0xFD,
+0x34,0x0A,0xA8,0x75,0x41,0x0A,0xA0,0xE5,0x02,0xA4,0x45,0x30,0x1F,0x54,0x14,0x08,
+0x00,0x0A,0x14,0x98,0x80,0x01,0x18,0x38,0x00,0x0C,0x18,0x98,0x02,0x12,0x40,0xB0,
+0xFF,0x21,0xAE,0xF5,0x02,0x46,0x45,0x30,0x02,0x20,0x70,0x33,0x00,0x0C,0xAC,0x45,
+0x02,0xB8,0x41,0x30,0x00,0x0C,0xAA,0x45,0xFF,0xFF,0x40,0xB8,0x00,0x0C,0xAC,0x45,
+0x02,0xA6,0x41,0x30,0xFF,0x21,0xAE,0xF5,0x01,0x11,0x22,0x9C,0x01,0x10,0x22,0x1C,
+0x0F,0x11,0x94,0x00,0x01,0x52,0x6C,0xB3,0x04,0x4C,0xC1,0xED,0x01,0x48,0xC1,0xFD,
+0x88,0xB6,0xC1,0x6D,0x40,0x11,0x5E,0xDF,0x00,0x11,0x94,0x88,0x14,0x52,0x20,0x32,
+0x02,0x11,0x94,0x80,0x01,0x52,0x6A,0xB3,0xFB,0xE4,0xC9,0x8B,0x01,0x11,0x94,0x80,
+0x80,0x52,0x8A,0xFF,0x04,0xE4,0xC9,0x87,0xB1,0x00,0x7A,0xAC,0x80,0x48,0xFB,0x6B,
+0xFF,0x09,0x0C,0x38,0x04,0xE4,0x23,0xFD,0x08,0x48,0x69,0x6C,0xA1,0x00,0x8A,0x2C,
+0xB1,0x00,0x7A,0xAC,0x80,0x48,0xFF,0xEB,0x00,0x0C,0x2A,0xDE,0x00,0x0C,0x1C,0xDD,
+0x00,0x0C,0xFE,0xC3,0xCC,0x01,0x1C,0x38,0xEC,0x11,0x54,0xDF,0xB0,0x00,0x18,0x28,
+0xCC,0x01,0x1C,0x38,0xEF,0x11,0x46,0xDF,0x00,0x0C,0x5A,0x57,0xFB,0x1F,0x3F,0x8A,
+0xA0,0x00,0x74,0xAB,0x11,0x11,0x02,0x00,0x10,0x02,0xE0,0x39,0xFF,0x11,0x22,0x20,
+0x04,0x11,0xD0,0x31,0x0F,0x02,0xE0,0xB9,0xFF,0x11,0x22,0x20,0x04,0x11,0xD0,0x31,
+0x00,0x00,0xE0,0x39,0x00,0x11,0xB0,0x88,0x32,0x11,0x00,0x00,0x02,0xF2,0x91,0x30,
+0x01,0x01,0x22,0x34,0x20,0x84,0x8A,0x7F,0x20,0x11,0x08,0x01,0x1C,0x11,0x60,0x47,
+0x01,0x9E,0x1D,0xB0,0x08,0x0E,0x18,0xFE,0xB0,0x01,0x18,0x38,0xA3,0x00,0x30,0x2A,
+0xFF,0xA7,0x29,0x62,0x01,0x11,0x22,0x9C,0x03,0x0C,0x14,0x08,0xFF,0x0A,0x14,0x10,
+0x01,0x0A,0x14,0x18,0x04,0x0A,0x14,0x18,0x03,0x0A,0x14,0x8C,0x00,0x0C,0x1D,0x5E,
+0x22,0x0A,0x7E,0xAE,0x00,0x40,0x1D,0xDE,0xFC,0x3F,0x7F,0x0A,0x00,0x3F,0x7F,0x06,
+0xFF,0xFF,0x14,0x38,0x89,0xDA,0x3B,0x2E,0x00,0xE0,0x14,0xB8,0x89,0xD8,0x3B,0xAE,
+0x04,0xD8,0x81,0x36,0x00,0x20,0x80,0xBA,0x00,0x00,0x84,0x3E,0x02,0xCA,0x95,0x87,
+0x08,0x4C,0x2D,0xEA,0x0B,0x0A,0x47,0x66,0x04,0x1F,0x2D,0x7A,0x88,0xB5,0x4B,0x7E,
+0x01,0x10,0x22,0x1C,0x80,0xB5,0x6B,0x03,0x02,0x20,0x4C,0x33,0x01,0x11,0x22,0x9C,
+0x00,0x0C,0x54,0xDE,0x77,0xB5,0x6B,0x8F,0x08,0x48,0x5D,0xFE,0x02,0x0C,0x0C,0x30,
+0xB2,0x00,0x2C,0xAF,0x02,0x06,0x18,0x30,0xFF,0xFF,0x4C,0x3F,0x00,0x0C,0x58,0xDD,
+0x01,0x48,0x6B,0x6E,0x80,0x11,0xA0,0x5F,0x00,0x0C,0xC4,0xDD,0x04,0x94,0x50,0x32,
+0x00,0x0C,0xCC,0x45,0x80,0x11,0xA0,0x5F,0x00,0x0C,0xC4,0xDD,0x00,0x0C,0xD8,0x45,
+0x00,0x0C,0xFA,0x43,0x04,0x28,0xB1,0x33,0xB2,0x00,0x30,0xAE,0xFF,0xFF,0x14,0x38,
+0x82,0x40,0xB1,0x2B,0x82,0x42,0xB5,0x2B,0x01,0x00,0x14,0xB8,0x83,0xD8,0xB1,0x2B,
+0x00,0x00,0x14,0x38,0x84,0xDA,0xB5,0xAB,0x02,0xD8,0x15,0xB0,0x83,0x28,0x51,0x2A,
+0x02,0xDA,0x15,0x30,0x84,0x2A,0x55,0xAA,0x28,0x01,0x18,0xB8,0xB3,0x00,0x30,0xAA,
+0x00,0x0C,0x0A,0xD5,0x00,0x0C,0x22,0x45,0x02,0x11,0x4A,0x80,0x02,0xFC,0x45,0xB0,
+0x10,0x9E,0xD7,0x6E,0x08,0xCE,0x9F,0x6E,0x20,0xCA,0xF9,0x7E,0x00,0x11,0xFE,0x8B,
+0xFF,0xB4,0x15,0x90,0x01,0x0A,0xFC,0x1B,0x04,0x11,0x94,0x80,0x01,0x52,0xF6,0xB3,
+0xFF,0xFB,0xC1,0xFE,0x44,0xFF,0x0F,0xA8,0x01,0x07,0x14,0xB0,0x00,0xFB,0xC7,0xFE,
+0x00,0xFB,0xF7,0x13,0x33,0xFF,0x17,0xA8,0x00,0x11,0x4A,0x88,0x00,0x0C,0x02,0x5F,
+0x00,0x0C,0xBC,0x4E,0xB0,0x00,0x64,0xAD,0x02,0x11,0x4A,0x80,0xFF,0xFB,0xC7,0x6E,
+0xF8,0xFF,0xFF,0x8B,0x08,0xFF,0xFF,0x1B,0x00,0x0C,0xC8,0xC6,0x01,0xFF,0xFF,0x1B,
+0x01,0xFE,0x15,0x30,0x00,0xFF,0x15,0x18,0x80,0x0A,0xD2,0x7E,0x07,0xFF,0xAB,0x6E,
+0x00,0x0C,0xA6,0x46,0x00,0x11,0x4A,0x88,0x01,0xB5,0xFD,0x7E,0x00,0x11,0x4A,0x88,
+0xB1,0x00,0xD8,0x29,0x02,0x0C,0x1C,0x98,0x10,0x9E,0xF1,0xEE,0xF2,0x11,0x26,0x80,
+0x02,0x0A,0x0C,0x30,0x10,0x11,0xA0,0x5F,0x7F,0x11,0xB4,0x5F,0x02,0x06,0x14,0x30,
+0x04,0x11,0x60,0x33,0xF5,0x45,0x8A,0x08,0xF5,0xCE,0x9D,0x0B,0x00,0x0C,0xF2,0xC6,
+0xF3,0x11,0x26,0x00,0x02,0x22,0x26,0xB0,0x00,0x0A,0x4E,0xDF,0x00,0x0C,0xFC,0x46,
+0x06,0x11,0xF8,0x03,0xB0,0x00,0xEC,0xAD,0x18,0x11,0xB8,0x80,0xCF,0xCA,0x95,0x0B,
+0xA0,0x00,0x62,0xAA,0x00,0x0C,0x34,0x5F,0x00,0x12,0x28,0x7A,0xFF,0x0C,0x18,0x98,
+0x00,0x12,0x26,0x90,0x02,0x22,0x0C,0x30,0x02,0xA4,0x45,0x30,0x2E,0x0B,0x14,0x28,
+0x80,0x01,0x18,0x38,0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,0x02,0x12,0x40,0xB0,
+0xFF,0xFF,0x26,0xB8,0x02,0x06,0x44,0x30,0xA1,0x00,0xEA,0x2C,0x08,0x9E,0x23,0xFF,
+0x02,0x45,0x8A,0x84,0xF5,0x45,0x8A,0x8C,0xF8,0x1C,0x17,0x08,0xB2,0x00,0x34,0xAF,
+0x00,0x12,0x26,0x00,0x00,0x0C,0x32,0x47,0xF8,0x1C,0x17,0x08,0xB2,0x00,0x34,0xAF,
+0x00,0x12,0x26,0x90,0xFF,0x11,0x22,0x8C,0x6A,0x0B,0x14,0x28,0xB0,0x01,0x18,0x38,
+0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,0x11,0x0B,0x0E,0xA8,0x01,0x07,0x14,0x34,
+0x00,0x00,0x90,0x38,0x18,0x11,0xA0,0xB0,0x18,0x10,0xA2,0x34,0xA1,0x00,0x52,0x2A,
+0xA1,0x00,0x50,0xAA,0xA1,0x00,0x3C,0xAA,0xA3,0x00,0x3E,0xAA,0xA3,0x00,0x1E,0x2A,
+0xA1,0x00,0x32,0x29,0xA1,0x00,0xDC,0x2A,0xA1,0x00,0x3E,0x2A,0xA1,0x00,0x74,0xAA,
+0xA1,0x00,0x6E,0x2A,0xA0,0x00,0x06,0xA8,0xA3,0x00,0xB8,0x2A,0xA3,0x00,0xEE,0x2A,
+0xA3,0x00,0xA4,0xAA,0x00,0x11,0x02,0x88,0x01,0x0C,0x8C,0x31,0x01,0x01,0x22,0x34,
+0x11,0x11,0x02,0x00,0xF5,0x45,0x8A,0x08,0xF7,0xA0,0x40,0x89,0xFB,0xFC,0x18,0xB8,
+0x00,0x0C,0xB6,0x5F,0x00,0x00,0x90,0x3B,0xC0,0xCA,0x95,0x0B,0x02,0x05,0x0A,0x00,
+0x40,0x3D,0x7A,0x00,0xFF,0xE0,0xC0,0x81,0xB3,0x00,0x74,0xAA,0x01,0x01,0x22,0xB0,
+0x01,0xE4,0xC9,0x87,0x04,0x87,0x8A,0x7F,0x80,0xC8,0x91,0x03,0x04,0x11,0x0E,0x85,
+0x02,0x06,0x22,0x30,0xFF,0x11,0x22,0x8C,0xB1,0x00,0xEA,0xAC,0x00,0x0C,0x8A,0xCF,
+0xC0,0xC8,0x29,0xEA,0xB0,0x00,0x9A,0xAF,0x80,0xCC,0x15,0x08,0x80,0x0B,0x17,0x08,
+0x00,0x0B,0x28,0x72,0x01,0x11,0x22,0x9C,0x01,0x0C,0x1A,0xB0,0x00,0x11,0xA2,0x47,
+0x00,0x11,0x1A,0x88,0xB3,0x00,0xB4,0xAA,0x02,0x9E,0x15,0x30,0x80,0x0C,0x04,0xA8,
+0xE2,0x9E,0xAD,0x2F,0x01,0xC5,0x0B,0x34,0x02,0x9E,0x3D,0x33,0x00,0x0C,0xA4,0x47,
+0x01,0x0C,0x1A,0xB0,0xFF,0x11,0xB6,0x47,0xFF,0x11,0x1A,0x00,0xB3,0x00,0xB4,0xAA,
+0x02,0x9E,0x15,0x30,0x81,0x0C,0x04,0x28,0xE2,0x9E,0xC1,0x2F,0x01,0xC5,0x0B,0x34,
+0x02,0x9E,0x3D,0x33,0x00,0x0C,0xB8,0xC7,0x02,0x20,0xC4,0xB4,0x02,0x9E,0xD5,0x6F,
+0x08,0x9E,0xCF,0x7F,0xFF,0xB9,0xD7,0x77,0x00,0x0C,0xD0,0x47,0xFF,0xA7,0xD7,0x77,
+0xFB,0x11,0xB4,0x5F,0x02,0x11,0xA0,0x5F,0xA0,0x00,0xDA,0x2E,0xFF,0xFF,0x40,0xB8,
+0xA0,0x00,0x1A,0xAF,0x02,0x87,0x8A,0x7F,0x20,0xC8,0x91,0x03,0x02,0x11,0x0E,0x85,
+0x40,0x84,0x8A,0x7F,0xA1,0x00,0x16,0xAE,0xFE,0xBA,0x74,0x89,0x02,0x92,0x71,0x31,
+0xFE,0xBA,0x74,0x89,0x02,0xB8,0x2C,0x37,0x04,0x30,0x22,0x30,0x44,0x11,0x00,0x80,
+0xB2,0x00,0xC8,0x28,0xA3,0x00,0x10,0x2B,0xB2,0x00,0xBC,0xAA,0xEB,0x00,0xF0,0x3B,
+0xB2,0x00,0x52,0xAA,0xA0,0x00,0x22,0xA8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x0C,0x14,0xD9,0x00,0x0C,0x06,0xD0,0xA0,0x00,0x18,0x2F,0x00,0x0C,0x2E,0xD9,
+0x02,0x86,0xA9,0xB3,0xFF,0xD5,0x1F,0x70,0x02,0xD4,0x45,0xB0,0x84,0x01,0x18,0xB8,
+0x00,0x0C,0x92,0xDB,0x01,0x0A,0x1A,0xE0,0x44,0xC6,0x0F,0xA8,0x01,0x07,0x14,0xB0,
+0x00,0x9C,0x69,0x68,0x02,0xAE,0xA9,0xB3,0x00,0x0C,0x0A,0x40,0x00,0x0C,0x2A,0x59,
+0x02,0x84,0x15,0xB0,0x8B,0x10,0x72,0x28,0x83,0x10,0x08,0x2B,0x02,0x80,0xA9,0xB3,
+0x02,0xD4,0x45,0xB0,0x02,0xAE,0x15,0x30,0xFF,0xFF,0x5C,0x3B,0x00,0x00,0x44,0x38,
+0x02,0x0A,0x00,0x33,0xFF,0x0B,0x36,0x60,0x02,0x0A,0x04,0xB3,0x00,0x0C,0x40,0x59,
+0xFF,0x87,0x3F,0xE0,0x02,0xD4,0x0D,0xB3,0x00,0x0C,0x44,0x40,0x02,0x88,0x45,0xB0,
+0x02,0xD4,0x5D,0xB3,0x00,0x00,0x44,0x38,0x02,0xD4,0x11,0x33,0x02,0xD4,0x45,0xB0,
+0x00,0x11,0xB2,0x89,0x0F,0xD8,0x00,0x0B,0xF0,0xD8,0x02,0x8B,0x0C,0x11,0xB2,0x01,
+0x08,0xD8,0x08,0xB3,0x08,0xD8,0x28,0x33,0x00,0x0C,0x08,0x5A,0x01,0x0A,0x38,0xB3,
+0x01,0x0B,0x54,0x33,0x00,0x0C,0x78,0x58,0x04,0x9D,0x3B,0x03,0x01,0x11,0x14,0x00,
+0x00,0x9C,0x65,0xF8,0x01,0xA8,0x51,0x1B,0x11,0x0A,0x14,0xA8,0xFF,0x0A,0x60,0x68,
+0x02,0x11,0xB2,0x81,0x02,0xD8,0x04,0xB3,0x00,0x0C,0x44,0xD9,0x02,0xD4,0x45,0xB0,
+0xA0,0x00,0xDE,0xAE,0x00,0x0C,0x44,0xD9,0x00,0x0C,0x40,0x59,0xA0,0x00,0x1A,0xAF,
+0x00,0x00,0x44,0x38,0x02,0x86,0x15,0x30,0xFF,0x0B,0xA0,0xF0,0x8A,0xD4,0x9B,0xA8,
+0x02,0x0A,0x0C,0x30,0x02,0x0A,0x44,0x30,0x01,0x9C,0x15,0xB0,0x02,0xD4,0x45,0xB0,
+0x00,0x9C,0x99,0xF8,0x02,0x06,0x44,0x30,0x02,0xA6,0x0D,0xB0,0x08,0xB4,0xB1,0x33,
+0x02,0xD4,0x45,0xB0,0x02,0x06,0x4C,0xB3,0x08,0xD8,0x69,0x33,0x00,0x11,0x6E,0x0F,
+0x02,0x06,0x14,0x30,0x02,0x0A,0x44,0x30,0x02,0xAE,0x15,0x30,0x00,0x0C,0x7C,0xC0,
+0x02,0xD4,0x45,0x34,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,0x01,0x00,0x18,0xB8,
+0x02,0x8C,0x15,0x30,0x83,0x0C,0x04,0xA8,0xE3,0x8C,0xB1,0xA8,0x00,0x0C,0xB4,0x40,
+0x02,0x8C,0x19,0x33,0x00,0x0C,0xA8,0xC0,0x02,0x06,0x44,0x30,0x02,0x0A,0xA0,0x33,
+0xB1,0x00,0xC2,0xAC,0x5F,0x0C,0xC0,0x3B,0x40,0xCA,0x95,0x87,0x08,0x84,0x49,0x31,
+0x02,0x22,0x48,0xB1,0x02,0xD0,0x49,0xB1,0xFC,0xFF,0x14,0x38,0x83,0x90,0x48,0xA9,
+0x02,0x11,0x48,0xB1,0xB1,0x00,0xDC,0xA9,0x01,0x0A,0xC4,0xB3,0x02,0x0C,0x0C,0x30,
+0x00,0x0C,0xFE,0xD8,0x02,0x06,0x18,0x30,0x0C,0x00,0x14,0x38,0x83,0x90,0x14,0x28,
+0xB1,0x00,0x10,0xAA,0x20,0x11,0xB8,0x00,0xB1,0x00,0x2C,0xAA,0x02,0x0A,0x0C,0x30,
+0x02,0x0C,0x1C,0x98,0x28,0xC6,0x27,0x80,0x55,0x11,0x02,0x00,0x01,0x43,0xED,0x68,
+0x08,0xCC,0xED,0xE8,0x09,0x11,0xEE,0x40,0x08,0x11,0xEE,0xC0,0x01,0x01,0x22,0xB0,
+0x30,0xCC,0x15,0x88,0x80,0x0A,0x14,0x00,0x00,0x0C,0x26,0x00,0x02,0x06,0x26,0xB0,
+0xB1,0x00,0xB8,0x2C,0x00,0xE2,0x1F,0x5A,0xA0,0x00,0x62,0xAA,0x00,0x0C,0x14,0xD9,
+0x00,0x0C,0x18,0x52,0x80,0x45,0x18,0x7A,0x01,0xC9,0x19,0xEA,0x00,0x11,0x8C,0x09,
+0x53,0x11,0x28,0xD9,0x01,0xC9,0x93,0x03,0x1C,0xF2,0x14,0x08,0x10,0x0A,0x18,0xE2,
+0x09,0x11,0x1A,0x00,0xA1,0x00,0xCE,0x2A,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,
+0x02,0x90,0x15,0xB0,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,
+0x83,0x8E,0x15,0xA8,0x02,0x06,0x44,0x30,0x80,0x0B,0x60,0x6B,0x01,0x11,0x22,0x9C,
+0xA1,0x00,0xD4,0xAA,0x00,0x80,0x18,0xB8,0x00,0x0C,0x30,0xC1,0x00,0x40,0x18,0xB8,
+0x00,0x00,0x44,0x38,0x02,0x8A,0x15,0x30,0x89,0x0C,0x32,0x29,0x80,0x0C,0x04,0xA8,
+0xE3,0x8A,0x3D,0xA9,0xFF,0x11,0x22,0x8C,0x02,0x8A,0x15,0x33,0x00,0x0C,0x32,0x41,
+0xFF,0x7F,0x18,0xB8,0x00,0x0C,0x46,0x41,0xFF,0xBF,0x18,0xB8,0x00,0x00,0x44,0x38,
+0x02,0x8A,0x15,0x30,0x81,0x0C,0x04,0x28,0xE3,0x8A,0x51,0xA9,0xFF,0x11,0x22,0x8C,
+0x02,0x8A,0x15,0x33,0x00,0x0C,0x48,0xC1,0x02,0xA6,0x15,0xB0,0x8B,0x10,0x18,0xAA,
+0x16,0x11,0x1E,0x42,0x04,0x9F,0x63,0xF9,0x02,0xAC,0x15,0xB0,0x89,0x10,0x62,0xA9,
+0x04,0x9F,0x61,0xE9,0x03,0xB4,0xB1,0xB3,0x00,0x11,0xB6,0x8B,0x02,0xB8,0xA5,0x33,
+0x22,0x11,0x02,0x00,0x02,0xA2,0xE8,0xB3,0x02,0xD2,0x45,0x31,0xFF,0xD8,0x79,0x69,
+0xFF,0xD9,0x79,0xE9,0xFF,0xDA,0x79,0xE9,0xF7,0x11,0x1A,0xDA,0x01,0x01,0x22,0x34,
+0x04,0xD8,0x51,0xB0,0x02,0x11,0x4A,0x80,0x04,0x28,0xE8,0x33,0x00,0x0C,0x94,0x41,
+0x22,0x11,0x02,0x00,0x02,0x11,0x4A,0x80,0x80,0xF7,0x95,0x79,0x03,0xB4,0x51,0x30,
+0x00,0x11,0x56,0x08,0x04,0xF4,0x51,0x30,0xFF,0x11,0x22,0x20,0x80,0x2B,0x94,0x79,
+0x00,0x11,0xEE,0x0B,0x80,0xC9,0x93,0x03,0x00,0x11,0x4A,0x88,0x01,0x01,0x22,0x34,
+0xC0,0x5F,0x15,0x88,0xC0,0x0A,0xB2,0xF1,0x18,0x10,0x95,0xB1,0x18,0x00,0x14,0x38,
+0x83,0x58,0x99,0xA8,0x04,0x11,0x38,0xDA,0x00,0x11,0x38,0x5A,0x10,0x50,0xC1,0xB0,
+0x10,0x01,0xBC,0x3C,0x07,0x11,0x94,0x01,0x13,0x11,0x95,0xB1,0x04,0x11,0x94,0x31,
+0x00,0x0C,0xB4,0xC1,0x18,0x10,0x95,0xB1,0x18,0x11,0x94,0xB1,0x30,0x11,0x3E,0x5A,
+0x10,0x01,0xBC,0x3C,0x04,0x30,0xB0,0xB3,0x02,0xDA,0x41,0xB0,0x0F,0xCB,0xE7,0x69,
+0x01,0xCD,0xE5,0xF9,0x80,0xCC,0xE5,0xE9,0x40,0xCE,0xE5,0xF9,0x02,0x44,0x15,0xB0,
+0x88,0xD0,0xE5,0x29,0x11,0x11,0x00,0x80,0x02,0xDA,0x41,0xB0,0x02,0x46,0x45,0x30,
+0x00,0x00,0x90,0xB9,0x10,0x00,0xBC,0x38,0x04,0x58,0x99,0xB0,0x10,0x50,0xC1,0xB0,
+0x00,0x11,0xA4,0x5A,0x20,0x13,0x08,0x39,0x49,0x11,0xB8,0x00,0x00,0x0C,0x46,0x5A,
+0x80,0xCA,0x95,0x03,0xF6,0x0C,0xC0,0xBF,0x27,0x11,0xE8,0xC1,0x09,0x11,0xE8,0xC1,
+0x00,0x0C,0xA4,0x5A,0xA1,0x00,0xF8,0xAE,0xB0,0x00,0x18,0x28,0x02,0x05,0x0A,0x00,
+0x0F,0xCB,0xFB,0xE9,0x80,0xC8,0x01,0x6A,0x08,0x5D,0x1C,0xFA,0x10,0xC9,0x93,0x03,
+0x00,0x0C,0x04,0x42,0x08,0x11,0x18,0x00,0xB0,0x00,0xC4,0xAD,0x09,0x11,0x02,0x42,
+0x05,0x11,0x02,0x42,0x00,0x0C,0xA4,0x5A,0x15,0x11,0x1E,0x5A,0xA0,0x00,0x3E,0x2D,
+0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,0xB8,0x01,0x18,0xB8,0x01,0xC6,0x15,0xB0,
+0x00,0x0C,0x18,0x98,0x01,0x12,0x14,0x30,0x01,0x96,0x17,0x30,0x02,0x06,0x44,0x30,
+0xFF,0x11,0x22,0x8C,0xA1,0x00,0x74,0xAA,0xA0,0x00,0x06,0xA8,0x01,0x0C,0xD6,0xB3,
+0x02,0x20,0xD8,0xB3,0xB0,0x00,0x18,0x28,0x02,0x05,0x0A,0x00,0x04,0x3A,0x1C,0x7A,
+0x01,0xEB,0x69,0x30,0x01,0xFA,0x6B,0xB0,0x02,0xEC,0x6D,0x30,0xFD,0x05,0x0A,0x0C,
+0x00,0x00,0x14,0x38,0x88,0x12,0x60,0xAB,0x88,0x12,0x60,0xAB,0x01,0x11,0x22,0x9C,
+0x01,0x0C,0xF6,0x30,0x01,0x0A,0xF0,0x30,0x02,0x11,0xF2,0x34,0x01,0x0C,0x98,0xB0,
+0x03,0x11,0x9A,0xB0,0x01,0x0C,0x14,0x30,0x04,0x11,0x38,0xC2,0x01,0x11,0x02,0x80,
+0x02,0x22,0x44,0x30,0x21,0x11,0x00,0x80,0x00,0x0C,0x54,0x42,0x10,0x11,0x02,0x80,
+0x02,0x22,0x44,0x30,0x20,0x11,0x00,0x00,0x8E,0x04,0x0C,0xB8,0x02,0x22,0x44,0x30,
+0x01,0x01,0x22,0x34,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,
+0x02,0x0A,0x0C,0x30,0xFF,0xFF,0x14,0x38,0x84,0x11,0x1C,0x28,0x02,0x06,0x14,0x30,
+0x83,0x0C,0x18,0x28,0x00,0x00,0x14,0x38,0x84,0x0E,0x1C,0x2C,0x09,0x10,0x00,0xB1,
+0x01,0x11,0x74,0x00,0x00,0x0C,0x90,0xC2,0x00,0x0C,0x78,0xDA,0x00,0x0C,0x82,0xC2,
+0x00,0x0C,0x86,0x5A,0x10,0x11,0x06,0x81,0x04,0x11,0x0E,0x01,0x01,0x11,0x10,0x85,
+0x00,0x0C,0x86,0x5A,0xC0,0x11,0x08,0x81,0x08,0x11,0x10,0x85,0xFF,0x11,0x00,0x01,
+0xF0,0xEF,0x04,0xB9,0x7F,0xFF,0x08,0xB9,0xFF,0xFB,0x0C,0x39,0x10,0x11,0x10,0x01,
+0x00,0x11,0x02,0x88,0x00,0x0C,0x9C,0xDA,0x11,0x11,0x00,0x80,0x00,0x0C,0x9E,0x5A,
+0x01,0x01,0x22,0x34,0x11,0x00,0x9E,0x72,0x7F,0x03,0x24,0x39,0xFF,0x11,0x8C,0x00,
+0xFF,0x11,0x8E,0x80,0x02,0x11,0x74,0x84,0x00,0x0C,0xB4,0xDA,0x02,0x4C,0x15,0x30,
+0x01,0x0A,0x04,0x80,0x01,0x0C,0x06,0x30,0xE3,0x4C,0xB1,0x2A,0x01,0xC5,0x0B,0x34,
+0x02,0x4C,0x99,0x32,0x00,0x0C,0xA6,0xC2,0x01,0x05,0x8A,0xB3,0x02,0x05,0x0A,0x84,
+0x01,0x0C,0x1A,0xB0,0x00,0x11,0xBE,0xC2,0x00,0x11,0x1A,0x88,0x00,0x0C,0xB4,0xDA,
+0x02,0x48,0x15,0xB0,0x80,0x0C,0x04,0xA8,0xE3,0x48,0xC9,0xAA,0x01,0xC5,0x0B,0x34,
+0x02,0x48,0x91,0x32,0x00,0x0C,0xC0,0xC2,0x01,0x0C,0x1A,0xB0,0xFF,0x11,0xD0,0x42,
+0x00,0x0C,0xB4,0xDA,0x02,0x48,0x15,0xB0,0x81,0x0C,0x04,0x28,0xE3,0x48,0xDB,0xAA,
+0x01,0xC5,0x0B,0x34,0x02,0x48,0x91,0x32,0x00,0x0C,0xD2,0xC2,0x00,0x11,0x1A,0x88,
+0x00,0x0C,0xB4,0xDA,0x02,0x48,0x15,0xB0,0x82,0x0C,0x04,0x28,0xE3,0x48,0xEB,0xAA,
+0x01,0xC5,0x0B,0x34,0x02,0x48,0x91,0x32,0x00,0x0C,0xE2,0xC2,0x00,0x11,0x1A,0x88,
+0x00,0x0C,0xB4,0xDA,0x02,0x4C,0x15,0x30,0x80,0x0C,0x04,0xA8,0xE3,0x4C,0xFB,0xAA,
+0x01,0xC5,0x0B,0x34,0x02,0x4C,0x99,0x32,0x00,0x0C,0xF2,0x42,0x00,0x0C,0xB4,0xDA,
+0x02,0x4C,0x15,0x30,0x81,0x0C,0x04,0x28,0xE3,0x4C,0x09,0xAB,0x01,0xC5,0x0B,0x34,
+0x02,0x4C,0x99,0x32,0x00,0x0C,0x00,0x43,0xA2,0x00,0xB4,0xAF,0xA2,0x00,0xA0,0xAF,
+0x00,0x0C,0xB4,0xDA,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,0x44,0xC6,0x0F,0xA8,
+0x01,0x07,0x1C,0x30,0x02,0xAE,0x19,0x30,0xFF,0x0E,0x14,0x90,0x00,0x0C,0xB0,0x8B,
+0x01,0x0D,0xB2,0xB3,0x0F,0xCB,0x27,0x7B,0x00,0xD9,0xB3,0x0B,0x01,0x0E,0x14,0xB0,
+0x03,0xC8,0x31,0x6B,0xC0,0xCA,0x31,0xEB,0x30,0xCB,0x31,0x6B,0x00,0xD8,0xB1,0x83,
+0x02,0x0C,0x14,0x30,0x02,0xD8,0x05,0x30,0xE3,0xAE,0x3B,0x2B,0x02,0x06,0x44,0x30,
+0x01,0xC5,0x0B,0x34,0x02,0xAE,0x5D,0x33,0x00,0x0C,0x1A,0xC3,0x00,0x0C,0xB4,0xDA,
+0x02,0x48,0x15,0xB0,0x02,0x0B,0x40,0xEB,0x01,0x0A,0x04,0xB0,0x02,0x0B,0x06,0x80,
+0xE3,0x48,0x4D,0x2B,0x01,0xC5,0x0B,0x34,0x02,0x48,0x91,0x32,0x00,0x0C,0x40,0xC3,
+0xFF,0xFD,0x18,0xB8,0x00,0x0C,0xD0,0x42,0x00,0x0C,0x3E,0xDB,0x40,0x49,0x5F,0x6B,
+0x00,0x0C,0x62,0xDB,0x00,0x0C,0x50,0x5B,0x01,0x11,0x22,0x9C,0x00,0x0C,0x50,0x5B,
+0x01,0x10,0x22,0x1C,0x00,0x0C,0xB4,0xDA,0x02,0x4A,0x15,0x30,0x01,0x0A,0x04,0xB0,
+0x01,0x0B,0x06,0x98,0xE3,0x4A,0x6F,0xAB,0x01,0xC5,0x0B,0x34,0x02,0x4A,0x95,0x32,
+0x00,0x0C,0x64,0xC3,0x00,0x0C,0xB4,0xDA,0x02,0x4A,0x15,0x30,0x01,0x0A,0x04,0xB0,
+0xFF,0x0B,0x06,0x18,0xE3,0x4A,0x7F,0x2B,0x01,0xC5,0x0B,0x34,0x02,0x4A,0x95,0x32,
+0x00,0x0C,0x74,0x43,0x02,0x05,0x0A,0x00,0x02,0x4A,0x15,0x30,0xFF,0x0A,0x04,0x18,
+0x01,0x0B,0x06,0xB0,0xE3,0x4A,0x8F,0x2B,0xA2,0x00,0xE8,0x28,0x02,0x4A,0x95,0x32,
+0x00,0x0C,0x84,0x43,0x0C,0x11,0xB2,0x01,0x01,0x12,0x14,0x30,0x00,0xD8,0x9E,0x63,
+0x1F,0xD9,0x14,0x08,0x14,0x0A,0x94,0x63,0x01,0x11,0x14,0x84,0xFF,0xD9,0xB2,0x99,
+0xFF,0x0C,0x18,0x98,0xFF,0x12,0x14,0x10,0xFF,0x11,0x16,0x00,0x01,0x10,0x22,0x98,
+0x84,0x11,0x14,0xA8,0x01,0xD8,0xB0,0xB3,0x00,0x11,0xB2,0x0B,0x83,0xD8,0x15,0xA8,
+0x80,0x0B,0xB4,0x6B,0x02,0x11,0x14,0x84,0x00,0x11,0x14,0x8C,0xB3,0x00,0xB4,0xAA,
+0x02,0xA8,0x15,0x30,0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x98,0xE3,0xA8,0xC3,0xAB,
+0x01,0xC5,0x0B,0x34,0x02,0xA8,0x51,0x33,0x00,0x0C,0xB8,0x43,0x04,0x9D,0x19,0xFA,
+0xB3,0x00,0xB4,0xAA,0x02,0xA8,0x15,0x30,0x01,0x0A,0x04,0xB0,0xFF,0x0B,0x06,0x18,
+0xE3,0xA8,0xD5,0x2B,0x01,0xC5,0x0B,0x34,0x02,0xA8,0x51,0x33,0x00,0x0C,0xCA,0x43,
+0x0E,0xDA,0xE1,0x6B,0x01,0xDA,0xDF,0xEB,0xA1,0x00,0x5C,0x2D,0xFE,0xE2,0xC4,0x89,
+0x82,0x11,0xB0,0x03,0x0F,0x82,0xB2,0x0B,0x0F,0x11,0x04,0x81,0x04,0x3A,0xE6,0xFB,
+0x0C,0x00,0x68,0xB8,0x02,0xD8,0x6D,0x34,0x80,0x11,0x8E,0x81,0xDF,0xC9,0x93,0x0F,
+0x02,0xC0,0x41,0x30,0x04,0x10,0x80,0xB7,0x11,0x11,0x00,0x80,0x00,0x11,0xD4,0x0B,
+0x00,0x11,0x00,0x08,0x00,0x11,0xD4,0x8F,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+};
+
+#else /* SEQUENCER_UPDATE */
+
+uint8_t Csb0[] = {
+0x00,0x0C,0x32,0xC0,0x05,0x00,0x0C,0x38,0x00,0x0C,0xBC,0xC3,0x01,0x11,0x2A,0x80,
+0x02,0x11,0x2A,0x80,0x01,0x05,0x0A,0x84,0x06,0x11,0x48,0x80,0x01,0x00,0x8C,0xB3,
+0x02,0x20,0x88,0xB3,0x02,0x06,0x80,0xB3,0x02,0x06,0x84,0x33,0x01,0xC7,0x8F,0x03,
+0x04,0x11,0x48,0x00,0x88,0x11,0x00,0x80,0x00,0x0C,0x66,0x40,0xFE,0xC7,0x8F,0x8B,
+0x01,0xC6,0x01,0xB0,0x02,0xC4,0x41,0xB0,0x02,0xC2,0x0D,0x30,0x02,0xC0,0x0D,0xB0,
+0x07,0x11,0x48,0x84,0x80,0xE1,0xC3,0x03,0x00,0x0C,0x32,0xC0,0x02,0x06,0xC0,0x33,
+0x02,0x20,0xC4,0x33,0x88,0x11,0x00,0x80,0x06,0x11,0x48,0x80,0x01,0xC7,0x1F,0xE8,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0x07,0x11,0x48,0x00,0x00,0x00,0x14,0x38,
+0x8A,0xD4,0x47,0x28,0xFF,0xD1,0x47,0x70,0x00,0x0C,0xA8,0x5A,0x04,0x11,0x48,0x00,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0xFF,0xC1,0x51,0x70,0x00,0x0C,0xFC,0xDA,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0xFF,0xC9,0x59,0x70,0x00,0x0C,0x04,0xDB,
+0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0xFF,0xDC,0x63,0x78,0x00,0x0C,0x88,0x5B,
+0x88,0x11,0x00,0x80,0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0x80,0xE1,0x6D,0x68,
+0x02,0xE2,0x41,0x30,0x02,0xE0,0x0D,0xB4,0x01,0x35,0xA0,0x69,0xFF,0xCD,0xF3,0x60,
+0xFF,0xC5,0x77,0xE0,0xFF,0xD1,0x59,0x61,0x00,0x0C,0x32,0xC0,0x80,0x00,0x1C,0x38,
+0x02,0xC4,0x41,0xB0,0x02,0x08,0x27,0xB0,0x01,0x0A,0x15,0xB0,0xC0,0x0A,0x9C,0xE0,
+0x00,0x04,0x27,0x00,0x44,0x04,0x19,0xA8,0x01,0x11,0x1A,0x80,0x01,0x12,0x08,0x32,
+0x01,0x0C,0x18,0x18,0x04,0x12,0x26,0xB0,0x01,0x0C,0x19,0x1A,0x01,0x0C,0x15,0xB0,
+0x00,0x0B,0x97,0xE0,0xB1,0x00,0x94,0x28,0x00,0x0C,0xAA,0x40,0xFF,0x04,0xB5,0x68,
+0x02,0x00,0x41,0x30,0x00,0x0C,0xB4,0x40,0x01,0x4D,0x15,0xB0,0x01,0x0A,0x26,0xB0,
+0x04,0x3C,0xB1,0x33,0xFF,0x0A,0xA8,0xE8,0x02,0x30,0xB0,0xB3,0x00,0x00,0xB4,0x3B,
+0x04,0xD8,0x27,0x30,0x02,0x00,0xA9,0x33,0x02,0x0E,0x0C,0xB0,0xB1,0x00,0xA4,0x28,
+0x02,0x06,0x1C,0xB0,0x02,0xD4,0x41,0x30,0x02,0x11,0x4A,0x80,0x01,0xF4,0x27,0xB0,
+0x00,0x11,0x4A,0x88,0x01,0x4E,0x22,0x30,0xFF,0x21,0xC2,0xF0,0xFF,0x0E,0xC2,0xF8,
+0x10,0x4D,0x7A,0xF8,0x02,0x20,0x88,0xB3,0xFF,0x21,0xC8,0x60,0xFF,0xFF,0x8C,0xBB,
+0x02,0x11,0x4A,0x80,0x04,0xF0,0x81,0x30,0x04,0xEC,0x89,0x30,0x03,0xE8,0x15,0x88,
+0x44,0x0A,0x14,0xA8,0x00,0x11,0x4A,0x88,0x80,0x0E,0x90,0x98,0xFF,0x0A,0x96,0x08,
+0x1C,0x11,0x6E,0x80,0x00,0x0C,0x2E,0x58,0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,
+0x04,0x11,0x68,0x80,0x02,0x11,0x4A,0x80,0x04,0x40,0xE0,0x33,0x10,0x4D,0xEE,0x78,
+0x04,0xE8,0xE1,0x33,0xFC,0xF0,0xE1,0x0B,0x01,0xF4,0xE9,0x93,0x00,0x11,0x4A,0x88,
+0x00,0x0C,0x2A,0xC0,0x07,0x11,0x48,0x00,0xFF,0xD1,0x33,0x70,0xB1,0x00,0x7A,0x28,
+0xFF,0x0E,0xF4,0x68,0x04,0x11,0x48,0x00,0x02,0x20,0xC8,0x33,0x80,0x00,0x1C,0x38,
+0x02,0xCC,0x41,0x30,0x0C,0x4D,0x0B,0x71,0x0B,0x4D,0x0B,0xF1,0x0A,0x4D,0x1D,0xF1,
+0x1C,0x11,0x2A,0x80,0x04,0x0C,0x27,0x30,0x00,0x00,0x26,0xB8,0x14,0x00,0x26,0xB8,
+0x08,0x11,0x26,0xB0,0x14,0x10,0x27,0x30,0x0C,0x28,0x27,0xB0,0x02,0x46,0x45,0x30,
+0x04,0xB0,0x27,0xB0,0x00,0x0C,0x1E,0xC1,0x10,0x10,0x27,0xB0,0x02,0xE4,0x41,0x30,
+0x44,0x0C,0x18,0xA8,0x01,0x11,0x1A,0x80,0x01,0x0C,0xD2,0x33,0x80,0xFF,0x14,0xB8,
+0x83,0x0E,0x14,0xA8,0xB1,0x00,0x58,0xA9,0x00,0x11,0xD0,0x8B,0x80,0xE8,0xD1,0x2B,
+0x08,0x12,0x80,0xB0,0x01,0x0A,0x90,0x30,0x07,0x0C,0x18,0x18,0x30,0x12,0x14,0x08,
+0xFF,0x0A,0x96,0x08,0x1C,0x11,0x6E,0x80,0x02,0x08,0xCD,0x33,0x00,0x0C,0x0E,0x5C,
+0x02,0xCC,0x41,0x30,0x02,0xE6,0x79,0xB2,0x02,0xE8,0x7D,0xB2,0x00,0x0C,0x2E,0x58,
+0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,0xFF,0xFF,0xB0,0xBB,0x01,0x11,0x1A,0x80,
+0xCC,0x11,0x22,0x5E,0x00,0x0C,0x28,0x5E,0xFF,0xCD,0xF3,0x60,0x00,0x0C,0x2A,0xC0,
+0x02,0xD0,0x41,0xB0,0x02,0x0C,0x19,0xB0,0x80,0x00,0x14,0xB8,0xB1,0x00,0x5E,0xAF,
+0x80,0x0B,0x66,0xE9,0x80,0x00,0xFC,0x3A,0x00,0x0C,0x68,0x41,0x02,0x0C,0xFD,0x32,
+0x08,0x10,0x81,0xB0,0x08,0x18,0x97,0x80,0x01,0x7E,0x91,0xB0,0x1C,0x11,0x6E,0x80,
+0x00,0x0C,0x2E,0x58,0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,0x08,0x40,0x20,0xB2,
+0x08,0x50,0x81,0x30,0xFF,0x58,0x97,0x08,0x01,0x7E,0x91,0xB0,0x1C,0x11,0x6E,0x80,
+0x00,0x0C,0x2E,0x58,0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,0x08,0x40,0xA0,0x32,
+0x02,0x7E,0x15,0xB0,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,
+0x83,0x0C,0x19,0x2A,0x02,0x0C,0x15,0xB0,0x89,0x10,0x5A,0x29,0xFF,0xFF,0xB0,0xBB,
+0x01,0x11,0x1A,0x80,0xD0,0x11,0x22,0xDE,0x00,0x11,0x2A,0xDE,0x00,0x0C,0x2A,0xC0,
+0x01,0x11,0x6A,0x00,0x02,0x11,0x4A,0x80,0x08,0xE0,0x81,0xB0,0x00,0x11,0x4A,0x88,
+0x80,0x11,0x90,0x00,0x03,0x40,0x14,0x88,0xFC,0x40,0x80,0x08,0x44,0x0A,0x14,0xA8,
+0x08,0x0A,0x96,0x00,0x1C,0x11,0x6E,0x80,0x01,0x00,0x14,0xB8,0x83,0x30,0x60,0x28,
+0x05,0x11,0x48,0x80,0xD6,0x01,0x18,0x38,0xFF,0xD7,0xC3,0x61,0xDA,0x01,0x18,0x38,
+0xFF,0xDB,0xE1,0xF1,0x02,0x0C,0x1C,0xB0,0x02,0x12,0x40,0xB0,0x02,0x00,0x27,0x30,
+0xFF,0x0A,0xE3,0xE1,0xFF,0x0C,0x18,0x98,0xFF,0x12,0xD0,0xE1,0xFF,0xFF,0x26,0xB8,
+0x04,0x11,0x48,0x00,0x00,0x0C,0x2E,0x58,0x40,0x35,0x32,0xF8,0x40,0x11,0x6A,0x00,
+0x80,0x80,0x00,0x32,0x80,0xE1,0xC3,0x03,0x00,0x0C,0xE4,0xD9,0x00,0x0C,0x2A,0xC0,
+0x14,0x11,0x2A,0x00,0x1F,0x11,0x2A,0x80,0x02,0x11,0x4A,0x80,0x08,0x00,0xC1,0xB3,
+0x00,0x11,0x4A,0x88,0xC0,0x0A,0x15,0x88,0xFF,0x0A,0x06,0x7A,0x40,0x0A,0x40,0xF2,
+0x80,0x0A,0x5E,0xF2,0x01,0x0A,0x15,0xB0,0xC0,0x0A,0x7E,0xF2,0xC1,0x0A,0x04,0xF2,
+0xC2,0x0A,0x04,0xF2,0xC3,0x0A,0xA6,0xF2,0xC4,0x0A,0x02,0xF2,0xC5,0x0A,0x68,0xF5,
+0x00,0x0C,0x04,0x42,0xA1,0x00,0x7C,0xAB,0x15,0x11,0x2A,0x80,0x03,0x0A,0x31,0x72,
+0x04,0x0A,0x33,0x72,0xB1,0x00,0xB0,0xA9,0xB1,0x00,0xB8,0xA8,0x00,0x0C,0x28,0xCE,
+0x02,0x46,0x45,0x30,0x02,0x9D,0x1B,0x7A,0x4C,0x9D,0x15,0x28,0x00,0x11,0x23,0x82,
+0x02,0xAE,0x45,0x30,0x01,0x00,0x14,0xB8,0x83,0xAC,0x59,0x2B,0x02,0xA0,0xAD,0xB3,
+0x02,0x20,0x40,0x33,0xFF,0xFF,0x04,0x3A,0xFF,0xD7,0x2F,0x72,0x02,0x20,0xA8,0x33,
+0x02,0xD6,0x41,0xB0,0x02,0xD4,0x05,0xB2,0x02,0xD4,0x41,0xB4,0xC1,0x11,0x20,0x46,
+0xA1,0x00,0x42,0x2B,0x04,0x48,0x0B,0x7A,0xB1,0x00,0x86,0xAF,0x00,0x0C,0x2A,0x4E,
+0x02,0x20,0x0C,0xB0,0xB1,0x00,0x98,0xAF,0x02,0x06,0x40,0xB0,0x00,0x0C,0x0A,0xC2,
+0xB1,0x00,0xB0,0xA9,0xB1,0x00,0xB8,0xA8,0x00,0x04,0x18,0xB8,0xB1,0x00,0x7A,0xA9,
+0xFF,0xFF,0x08,0x3A,0xB1,0x00,0x72,0x2F,0x02,0xA2,0xAD,0x33,0x02,0x20,0x44,0xB3,
+0xFF,0xD7,0x59,0xF2,0x02,0x20,0xA8,0x33,0x02,0xD6,0x41,0xB0,0x02,0xD4,0x09,0x36,
+0xFF,0x8E,0x5D,0x6A,0xC9,0x11,0x20,0xC6,0x02,0x20,0x18,0x37,0x02,0x20,0x0C,0xB0,
+0x44,0x0B,0x15,0xA8,0x00,0x0B,0x01,0x80,0x02,0x06,0x40,0xB0,0xFF,0xFF,0x00,0xBA,
+0xFF,0xE5,0x73,0x62,0xFF,0xE7,0x75,0xE2,0x02,0x20,0xC8,0x33,0x02,0x20,0xCC,0xB3,
+0xA1,0x00,0x9E,0xA8,0xFF,0xE7,0x7D,0xF2,0x02,0xE6,0xA9,0xB3,0x02,0x20,0xCC,0xB3,
+0x02,0xD4,0x41,0x30,0x02,0xE6,0x01,0x36,0x1B,0x11,0x2A,0x00,0x07,0x11,0x48,0x00,
+0x00,0x11,0x08,0x0A,0x00,0x11,0x0A,0x8A,0x00,0x11,0x18,0x8A,0xFF,0xFF,0x04,0x3A,
+0xFF,0xFF,0x00,0xBA,0xFF,0xD1,0x95,0x62,0x02,0x20,0xA0,0xB3,0x02,0x20,0xA4,0x33,
+0x01,0x11,0xB0,0x83,0x00,0x0C,0x9C,0xC2,0x02,0x20,0x14,0xB0,0x02,0xD2,0x41,0x30,
+0x02,0x0A,0x04,0x32,0x02,0x0A,0xA4,0xB3,0x06,0x11,0x48,0x80,0x01,0xC7,0x15,0x30,
+0x04,0x11,0x48,0x00,0x01,0x0A,0x2E,0xEE,0x00,0x0C,0xEC,0x42,0xD1,0x11,0x20,0xC6,
+0xC0,0x01,0x18,0xB8,0x01,0xD6,0x15,0x30,0x00,0x0C,0x18,0x98,0x01,0x12,0x00,0x30,
+0xC8,0x01,0x18,0x38,0x0F,0x00,0x14,0x08,0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,
+0xFF,0x12,0xFA,0x7A,0xFF,0x0C,0x18,0x98,0x02,0x0C,0x0C,0x30,0x02,0x0E,0x0C,0xB0,
+0xB1,0x00,0x7A,0x28,0xFF,0x0E,0xCA,0xFA,0xFF,0xD1,0xC1,0xE2,0x04,0x06,0x22,0x30,
+0x00,0x0C,0xF6,0xC2,0x01,0x0C,0xC0,0x33,0x02,0x06,0x1C,0xB0,0x02,0x06,0x18,0x30,
+0xFF,0xFF,0x14,0x38,0x83,0xD4,0xA9,0x2B,0xFF,0x12,0x26,0x18,0x01,0xD6,0xAD,0x1B,
+0x07,0xD6,0xAD,0x8B,0xFF,0x0C,0x18,0x98,0xFF,0x12,0xE8,0x7A,0xC0,0x01,0x1C,0x38,
+0x01,0xD7,0x15,0xB0,0x00,0x0E,0x1C,0x98,0x01,0x00,0x26,0xB0,0x07,0x0E,0xAE,0x8B,
+0x04,0x11,0x48,0x00,0x00,0xE0,0x27,0xDE,0x02,0x05,0x0A,0x00,0x07,0x11,0x48,0x00,
+0x00,0x00,0x14,0x38,0x8A,0xD4,0xF7,0x2A,0xFF,0xD1,0xA9,0x62,0x04,0x11,0x48,0x00,
+0x88,0x11,0x00,0x04,0x25,0x11,0x2A,0x80,0xC0,0x11,0x0C,0x5B,0x00,0x0C,0x2E,0xCE,
+0x00,0x11,0x26,0xDE,0x88,0x11,0x00,0x04,0xC8,0x11,0x0C,0xDB,0x00,0x0C,0x2E,0xCE,
+0x01,0x11,0x26,0x5E,0x88,0x11,0x00,0x04,0xFF,0xFF,0xB0,0xBB,0x01,0x11,0x1A,0x80,
+0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x18,0x02,0x0C,0x0C,0x30,0xB1,0x00,0x72,0x2F,
+0x01,0x9D,0x29,0x7B,0x20,0x0B,0x2B,0xFB,0x02,0x9E,0x2B,0xFB,0x04,0x4C,0x2B,0x6B,
+0x04,0x49,0x2B,0x6B,0x20,0x9D,0x53,0x6B,0xB1,0x00,0x32,0xAF,0x00,0x0C,0x52,0x4B,
+0x40,0x9E,0x53,0x6B,0x01,0x9C,0x15,0xB0,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,
+0x00,0xAF,0x15,0x88,0x02,0x06,0x44,0x30,0xFF,0x0A,0x40,0xEB,0xB1,0x00,0x12,0x2A,
+0x00,0x0C,0x52,0x4B,0xB1,0x00,0x16,0xAA,0x09,0x11,0x6E,0x03,0x00,0x0C,0x5A,0x43,
+0x09,0xB7,0x45,0x63,0xB1,0x00,0x1C,0xAA,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,
+0x00,0xAE,0xC1,0x08,0x02,0x06,0x44,0x30,0x02,0x62,0x14,0xB0,0x01,0x0B,0x52,0xEB,
+0xFF,0x0A,0x6C,0xE3,0xBA,0x01,0x1C,0xB8,0xBF,0x01,0x18,0x38,0xB0,0x00,0xF0,0x2D,
+0x00,0x0C,0x64,0x4B,0x02,0x06,0x18,0x30,0xFF,0x01,0x6B,0x73,0x02,0x20,0xB0,0x33,
+0x02,0x00,0x41,0x30,0x00,0x0C,0x14,0x43,0x02,0x06,0x18,0x30,0xB1,0x00,0x22,0x2A,
+0xFF,0x21,0x14,0xE3,0x01,0x10,0x22,0x1C,0x02,0x06,0x18,0x30,0x02,0x20,0xA8,0x33,
+0x01,0x0A,0x00,0x30,0x02,0xD4,0x41,0x30,0x00,0x0C,0x22,0x5E,0x04,0x4C,0x87,0xFB,
+0xFF,0x03,0x87,0x73,0x02,0x20,0xA8,0x33,0x02,0x02,0x41,0xB0,0x01,0x0C,0x18,0x18,
+0x00,0x0C,0x20,0xDE,0x02,0xD4,0x41,0x30,0xFF,0xFF,0x04,0x3A,0x01,0x11,0x22,0x9C,
+0x00,0x11,0x00,0x08,0x03,0x11,0x14,0x80,0x28,0x00,0x18,0x38,0xFF,0xE5,0xB1,0xF3,
+0x02,0xE4,0x41,0x30,0xFF,0xFF,0xC8,0xBB,0x01,0x00,0x0E,0xB0,0xFF,0x07,0x14,0x90,
+0x00,0xDC,0xB9,0x0B,0x06,0x11,0x48,0x80,0x02,0x0A,0x98,0xB3,0x02,0x0C,0x9C,0x33,
+0x04,0x11,0x48,0x00,0x06,0x11,0x26,0xDE,0x06,0x11,0x48,0x80,0x02,0xCC,0x15,0xB0,
+0x02,0xCE,0x19,0x30,0x04,0x11,0x48,0x00,0x02,0x05,0x0A,0x00,0xFF,0xDC,0x2F,0xFE,
+0x11,0x00,0x00,0x98,0x88,0x00,0x2E,0x76,0x02,0x0A,0x14,0x28,0x44,0x00,0x8E,0xE3,
+0x01,0x0C,0x18,0x18,0x00,0x0C,0x8E,0x43,0x02,0x34,0xA8,0x33,0x02,0x36,0x40,0xB0,
+0xF8,0xD4,0x15,0x08,0xC0,0x0A,0xF6,0x73,0xED,0xFF,0x14,0x38,0x83,0xD4,0x15,0xA8,
+0x80,0x0B,0xF4,0x7B,0xE7,0x01,0x14,0xB8,0x83,0xD4,0x0D,0x2C,0x00,0x0C,0xD2,0xC4,
+0x00,0x0C,0xD6,0x44,0x00,0x0C,0xE0,0x44,0x00,0x0C,0xF6,0xC4,0x00,0x0C,0x1E,0xC4,
+0x00,0x0C,0x7C,0x44,0x00,0x0C,0x2C,0xC5,0x00,0x0C,0x36,0xC4,0x00,0x0C,0xAC,0xC4,
+0x00,0x0C,0x18,0xC4,0x00,0x0C,0x78,0xC4,0x00,0x0C,0xDA,0x44,0x00,0x0C,0xDA,0x44,
+0x00,0x0C,0x0C,0x45,0x00,0x0C,0xA2,0x44,0x00,0x0C,0x1E,0x45,0x00,0x0C,0x28,0x45,
+0x00,0x0C,0x30,0x45,0x00,0x0C,0x28,0x46,0x16,0x11,0x2A,0x80,0x07,0xD4,0x0F,0xFC,
+0x01,0x05,0xAD,0xB3,0x07,0xD4,0x0B,0x8A,0x44,0x05,0x1D,0xA8,0x01,0x11,0x1E,0x00,
+0x00,0x11,0x26,0x88,0xFF,0x04,0x0B,0x7C,0x44,0xD6,0x1D,0x28,0x01,0x11,0x1E,0x00,
+0x01,0x05,0x27,0xB4,0x01,0x05,0x09,0xB2,0xC5,0x11,0x20,0xC6,0x01,0x0C,0x19,0x1A,
+0x01,0x0C,0x15,0xB0,0x00,0x0B,0x2F,0xE6,0xB1,0x00,0x94,0x28,0xA1,0x00,0xA4,0xA8,
+0xFF,0xFF,0x04,0x3A,0x00,0x0C,0xA2,0x5C,0xA1,0x00,0x94,0x29,0x00,0x0C,0xA2,0x5C,
+0x02,0x02,0xAD,0x33,0xFF,0xFF,0x04,0x3A,0x02,0x20,0x0C,0xB0,0xB1,0x00,0x72,0x2F,
+0x02,0xD6,0x41,0xB0,0xFF,0x21,0x30,0x64,0xFF,0xFF,0x40,0xBB,0x00,0x0C,0x32,0x44,
+0xC1,0x11,0x20,0x5E,0x02,0x06,0x40,0xB0,0xA1,0x00,0x94,0x29,0x02,0x06,0xB1,0x33,
+0xFF,0xFF,0x0C,0xBA,0x04,0x4C,0x47,0xEC,0x80,0x48,0x43,0xEC,0x00,0x0C,0x44,0xDA,
+0x00,0x0C,0x72,0xC4,0xB1,0x00,0xBE,0x29,0x00,0x0C,0x72,0xC4,0xB1,0x00,0x72,0x2F,
+0xFF,0xA1,0x4F,0x64,0xC1,0x11,0x20,0x5E,0x00,0x0C,0x72,0xC4,0x02,0x20,0xA8,0x33,
+0xC0,0x01,0x18,0xB8,0xB1,0x00,0xFA,0x2A,0xFF,0x21,0x58,0xE4,0x23,0x11,0x2A,0x80,
+0x02,0x20,0x14,0xB0,0xFF,0xD7,0x63,0xF4,0x02,0xD6,0x41,0xB0,0x02,0xD4,0x01,0x32,
+0x00,0x0C,0x64,0x44,0x02,0xD4,0x81,0x33,0x02,0x0A,0x40,0xB0,0x02,0x00,0xAD,0xB3,
+0x02,0xD4,0x41,0x30,0x02,0x0A,0x04,0x32,0x02,0xD6,0x01,0xB2,0xFF,0xD7,0x73,0xE4,
+0x02,0x20,0x84,0xB3,0x02,0xD8,0x41,0x30,0xFF,0x21,0x36,0x64,0xFF,0x11,0x22,0x8C,
+0x00,0x0C,0x94,0x5C,0xA1,0x00,0x94,0x29,0x00,0x0C,0x94,0x5C,0x02,0x04,0xAD,0x33,
+0xFF,0xFF,0x08,0x3A,0x02,0x20,0x0C,0xB0,0xB1,0x00,0x72,0x2F,0x02,0xD6,0x41,0xB0,
+0xFF,0x21,0x8E,0x64,0xFF,0xFF,0x44,0x3B,0x00,0x0C,0x90,0xC4,0xC9,0x11,0x20,0xDE,
+0x02,0x06,0x40,0xB0,0xA1,0x00,0x94,0x29,0x80,0x48,0xA1,0xEC,0xFF,0x4D,0xA3,0xEC,
+0x04,0x49,0xA3,0x7C,0x02,0x20,0xB0,0x33,0x00,0x0C,0x48,0xDA,0x02,0xD8,0x41,0xB4,
+0xA1,0x00,0xBE,0xA9,0xB1,0x00,0xBE,0x29,0x20,0x48,0x19,0x6D,0x80,0x48,0x2F,0x6E,
+0x01,0x49,0x2F,0x7E,0xA1,0x00,0x00,0x28,0x07,0x11,0x48,0x00,0x02,0x20,0xB4,0xB3,
+0x84,0x80,0x14,0xB8,0x88,0xDA,0xB7,0xAC,0x00,0x0C,0x08,0xDE,0xFF,0xD1,0xBD,0x64,
+0x00,0x0C,0x0C,0x58,0xFF,0xD1,0xB9,0x74,0xB1,0x00,0x7A,0x28,0xFF,0x0E,0xB6,0xEC,
+0x44,0x0C,0x1C,0x28,0x02,0x0E,0x1C,0x18,0x01,0x11,0x1E,0xA0,0x0F,0x00,0x14,0x08,
+0x08,0x0A,0x26,0x80,0x02,0xDA,0x27,0xB0,0x04,0x11,0x48,0x00,0x01,0x0C,0xA8,0xB3,
+0x00,0x0C,0xF8,0xC3,0xC0,0x11,0x24,0x5E,0xA1,0x00,0x94,0x29,0xC8,0x11,0x24,0xDE,
+0xA1,0x00,0x94,0x29,0xB1,0x00,0x2E,0xAB,0x00,0x0C,0x2E,0xCE,0xA1,0x00,0x00,0x28,
+0x02,0x20,0x0C,0xB0,0xB1,0x00,0xCE,0xA9,0x00,0x0C,0xF0,0x54,0x00,0x4D,0x11,0x5D,
+0x02,0x02,0x41,0xB0,0xFF,0x21,0xF0,0x64,0xFF,0xFF,0x40,0xBB,0x00,0x0C,0xF2,0x44,
+0xC1,0x11,0x20,0x5E,0x02,0x06,0x40,0xB0,0xA1,0x00,0x94,0x29,0x02,0x20,0x0C,0xB0,
+0xB1,0x00,0xCE,0xA9,0x00,0x0C,0x06,0xD5,0x00,0x4D,0x11,0x5D,0x02,0x04,0x41,0xB0,
+0xFF,0x21,0x06,0xE5,0xFF,0xFF,0x44,0x3B,0x00,0x0C,0x08,0xC5,0xC9,0x11,0x20,0xDE,
+0x02,0x06,0x40,0xB0,0xA1,0x00,0x94,0x29,0xB1,0x00,0x72,0x2F,0x01,0x4D,0x19,0xB0,
+0xB1,0x00,0xBE,0x29,0x20,0x48,0x19,0x6D,0x80,0x48,0x2F,0x6E,0xA1,0x00,0x90,0xAA,
+0xFF,0x45,0x1D,0x65,0x1B,0x11,0x16,0xC5,0x23,0x11,0x16,0x45,0x02,0x00,0xC9,0x33,
+0x00,0x0C,0x28,0x5D,0xFF,0xE5,0x27,0x65,0xFF,0xFF,0xCC,0xBF,0xA1,0x00,0x9E,0xA8,
+0x0A,0x4D,0x29,0x66,0xCD,0x11,0x20,0x46,0x02,0x20,0xC8,0x33,0xA1,0x00,0x9E,0xA8,
+0x07,0x11,0x48,0x00,0x02,0x38,0x40,0x7D,0xFF,0xD1,0x41,0x75,0xB1,0x00,0x7A,0x28,
+0xFF,0x0E,0x34,0x6D,0x01,0x0C,0x60,0x30,0x02,0x20,0x64,0x30,0x00,0x0C,0x64,0xC5,
+0x01,0x00,0x14,0xB8,0x83,0xD4,0xA9,0x2B,0xC8,0x01,0x18,0x38,0x0F,0x00,0x14,0x08,
+0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,0x01,0x12,0x14,0x30,0xFF,0x0A,0x5E,0xED,
+0x01,0x11,0x26,0x80,0xC0,0x01,0x1C,0x38,0x01,0xD7,0x15,0xB0,0x00,0x0E,0x1C,0x98,
+0x01,0x00,0x26,0xB0,0x07,0x0E,0xAE,0x8B,0x00,0x0C,0x64,0xC5,0x01,0x0A,0x14,0x18,
+0x00,0x0C,0x66,0xCD,0x01,0x0A,0x26,0xB0,0x04,0x11,0x48,0x84,0x24,0x11,0x2A,0x00,
+0x00,0x00,0x44,0x38,0x00,0x0C,0x94,0xDD,0x01,0x0B,0x15,0x30,0x10,0x01,0x18,0x38,
+0x02,0x12,0x44,0x30,0x02,0x22,0xA8,0xB3,0xFF,0xFF,0x5C,0x3B,0x00,0x00,0x44,0x38,
+0xFF,0x81,0x7F,0x65,0x02,0xD4,0x01,0xB3,0x00,0x0C,0x84,0x45,0x02,0x82,0x45,0xB0,
+0x02,0xD4,0x5D,0xB3,0x00,0x00,0x44,0x38,0x02,0xD4,0x05,0x33,0xFF,0x0A,0x14,0x98,
+0xFF,0x0A,0x70,0xED,0x01,0x0B,0x15,0x30,0x00,0x11,0x16,0x88,0x83,0x84,0x09,0x2B,
+0x00,0x0C,0xB4,0x5D,0x00,0x11,0x2A,0xC6,0x02,0x8A,0x15,0x30,0xFF,0x0A,0x94,0xED,
+0xFF,0x11,0x04,0x00,0x01,0x0B,0x06,0xB0,0xE0,0x8A,0xA1,0x2D,0xFF,0x11,0x22,0x8C,
+0x02,0x8A,0x15,0x33,0x00,0x0C,0x94,0xC5,0x02,0x8A,0x15,0x30,0xFF,0x0B,0xA4,0x6D,
+0x01,0x0A,0x04,0xB0,0xFF,0x11,0x06,0x80,0xE0,0x8A,0xB1,0xAD,0xFF,0x11,0x22,0x8C,
+0x02,0x8A,0x15,0x33,0x00,0x0C,0xA4,0xC5,0x02,0x8A,0x15,0x30,0x00,0x11,0x04,0x88,
+0x01,0x0B,0x06,0xB0,0xE0,0x8A,0xBF,0x2D,0xFF,0x11,0x22,0x8C,0x02,0x8A,0x15,0x33,
+0x00,0x0C,0xB4,0x45,0x02,0x8A,0x15,0x30,0x01,0x0A,0x04,0xB0,0x00,0x11,0x06,0x08,
+0xE0,0x8A,0xCD,0x2D,0xFF,0x11,0x22,0x8C,0x02,0x8A,0x15,0x33,0x00,0x0C,0xC2,0xC5,
+0x02,0x12,0x14,0x30,0x8B,0x10,0x30,0x2E,0x00,0x0C,0xDA,0xDD,0x04,0x64,0x26,0x30,
+0x01,0x10,0x22,0x1C,0x07,0x11,0x48,0x00,0x04,0x11,0xB8,0x33,0x02,0x0A,0xBA,0xB3,
+0x00,0x0C,0xE8,0x5D,0x00,0x0C,0xE8,0x5D,0x04,0xDC,0xC9,0xB0,0x04,0x11,0x48,0x84,
+0x02,0xDC,0x15,0x30,0x83,0xDC,0xB9,0x2B,0x02,0xDE,0x15,0xB0,0x84,0xDE,0xBD,0x2F,
+0x11,0x12,0x22,0xA8,0x00,0x0C,0x2E,0xD6,0x02,0x0C,0x0C,0x30,0x02,0x0E,0x18,0xB0,
+0x02,0x12,0x14,0x30,0x00,0x0C,0xDA,0xDD,0x02,0x06,0x18,0x30,0xFC,0x0C,0x18,0x98,
+0x04,0x12,0xC8,0xB0,0xFF,0x11,0x22,0x20,0x11,0x67,0x22,0xAC,0x11,0x12,0x22,0x2C,
+0xB1,0x00,0x48,0x29,0x0F,0x00,0x18,0x08,0x00,0x11,0x02,0x88,0x01,0x00,0x0E,0xB0,
+0x00,0x07,0x1A,0xFE,0x02,0x38,0x12,0xFE,0x02,0x00,0x60,0xB8,0x01,0x0C,0x64,0xB0,
+0x00,0x11,0x66,0x08,0x11,0x00,0x00,0x98,0x88,0x00,0x0E,0x66,0x01,0x01,0x22,0x34,
+0xA1,0x00,0x26,0xA8,0xA1,0x00,0x40,0xA8,0xA1,0x00,0x5A,0x28,0xA1,0x00,0x66,0x28,
+0xA1,0x00,0xBE,0xAA,0xA1,0x00,0xB8,0xAA,0xA1,0x00,0x74,0xA9,0xFF,0x11,0x22,0x8C,
+0x01,0x11,0x22,0x9C,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0xFF,0x4B,0xCD,0x69,0x01,0x4C,0x15,0x78,0xFF,0x4D,0x19,0xE8,0x03,0x48,0x19,0x78,
+0x40,0x49,0x0F,0x68,0x04,0x0C,0x79,0x32,0x01,0x11,0x16,0x40,0x20,0x49,0x15,0x78,
+0x04,0x11,0x78,0xB2,0x02,0x11,0x16,0x40,0x00,0x11,0x16,0xC0,0x00,0x0C,0x86,0x59,
+0x80,0x4C,0xBF,0xFA,0x21,0x1F,0x21,0xE8,0x40,0x48,0xBF,0x7A,0x0B,0x11,0x22,0xC0,
+0x0C,0x11,0x22,0x40,0x00,0x0C,0x86,0x59,0xCD,0x11,0x26,0x40,0x01,0x11,0x1A,0x80,
+0xFF,0xFF,0x00,0xBA,0xFF,0x12,0x34,0x60,0x01,0x11,0x1E,0x00,0xFE,0x0C,0x1C,0x98,
+0x02,0x20,0x26,0x30,0x02,0x20,0x26,0xB4,0x02,0x0C,0x1C,0xB0,0x02,0x20,0x14,0xB0,
+0x02,0x12,0x40,0xB0,0x02,0x0A,0x00,0xB2,0x02,0x0A,0x26,0xB0,0x02,0x0A,0x40,0x34,
+0x02,0x0C,0x1C,0xB0,0xFF,0xD9,0x4B,0x60,0x02,0x00,0x27,0x30,0xFF,0x01,0xCD,0x61,
+0xFF,0xFF,0x26,0x3C,0x02,0x20,0xA8,0x33,0x02,0x00,0xAD,0xB3,0x02,0xD8,0x41,0x30,
+0x02,0xD6,0x01,0xB2,0x02,0xD4,0x41,0x30,0xFF,0x01,0xCD,0x61,0x02,0x0C,0x1C,0x98,
+0x02,0xD8,0x27,0xB4,0x01,0x11,0x1A,0x80,0x02,0x0C,0x1C,0xB0,0x02,0x12,0x00,0xB2,
+0x02,0x20,0x26,0x30,0xFF,0x01,0xCD,0x61,0x02,0x20,0x26,0xB4,0x02,0x0C,0xC0,0x33,
+0x02,0x20,0xC4,0x33,0xFD,0x05,0x0A,0x88,0x02,0x05,0x0A,0x00,0x02,0x38,0x74,0x68,
+0xFD,0x05,0x0A,0x88,0x00,0x0C,0x6C,0x40,0x01,0xE0,0x61,0x30,0x02,0xE2,0x65,0x30,
+0xFD,0x05,0x0A,0x0C,0x02,0xD0,0x41,0xB0,0x44,0xD8,0x19,0x28,0x0F,0x0C,0x18,0x98,
+0x01,0x11,0x1A,0x20,0xC0,0x12,0x1C,0x88,0xC0,0xD8,0x19,0x00,0x01,0xD8,0xB1,0x1B,
+0x07,0xD8,0xCD,0xE9,0x02,0x02,0xA1,0x33,0xFF,0xFF,0x04,0x3A,0xFF,0xD1,0x93,0xE0,
+0xFF,0xFF,0xA4,0xBB,0x01,0x11,0xB0,0x07,0x07,0x11,0x48,0x00,0x02,0xD0,0x15,0x30,
+0x88,0x20,0x9C,0x28,0x00,0x0C,0x8A,0xD8,0x04,0x11,0x48,0x84,0x01,0x00,0x0E,0xB0,
+0x01,0x07,0x14,0xB0,0x00,0xDC,0xB9,0x07,0xFF,0x11,0x14,0x02,0xFF,0xFF,0x10,0x3A,
+0xFF,0xFF,0x8C,0x3A,0x05,0x11,0x48,0x80,0x01,0xD5,0x15,0x30,0x00,0x21,0xB2,0x68,
+0xD7,0x11,0xB4,0x40,0xDB,0x11,0xB4,0x40,0x00,0x0C,0x26,0xD8,0x04,0x11,0x48,0x84,
+0xC0,0x0A,0x15,0x88,0x40,0x0A,0xFE,0x70,0x01,0x0A,0x15,0xB0,0x00,0x11,0x16,0x88,
+0xF1,0xFF,0x18,0xB8,0x83,0x0C,0x18,0x28,0x80,0x0D,0xC8,0xE8,0xA0,0x00,0x04,0xAA,
+0x66,0x04,0x18,0xB8,0x83,0x0C,0x0C,0xAC,0x00,0x0C,0xF8,0xC0,0x00,0x0C,0xF8,0xC0,
+0x00,0x0C,0xF8,0xC0,0x00,0x0C,0xEC,0xC0,0x00,0x0C,0xF8,0xC0,0x00,0x0C,0xFE,0xC0,
+0x00,0x0C,0xFE,0xC0,0x00,0x0C,0xFE,0xC0,0x00,0x0C,0xEC,0xC0,0x00,0x0C,0x04,0x41,
+0x00,0x0C,0x04,0x41,0x00,0x0C,0x38,0x41,0x00,0x0C,0x38,0x41,0xA0,0x00,0x04,0xAA,
+0xA0,0x00,0x04,0xAA,0x00,0x0C,0x38,0x41,0xFF,0xFF,0x14,0x38,0x88,0x34,0xF5,0x28,
+0x00,0x0C,0xF6,0x5E,0x00,0x0C,0xCC,0x49,0x00,0x0C,0xC8,0xDE,0x00,0x0C,0xCC,0x49,
+0x01,0x21,0x40,0x32,0x01,0x20,0x42,0x32,0x00,0x0C,0x38,0x41,0x01,0x21,0x44,0xB2,
+0x01,0x20,0x46,0xB2,0x00,0x0C,0x38,0x41,0x08,0x48,0x39,0xF9,0x02,0x46,0x45,0x30,
+0x00,0x11,0xA8,0x8B,0x01,0x11,0xAC,0x03,0xA8,0x01,0x18,0x38,0x01,0x12,0xB0,0xB3,
+0x01,0xD6,0x15,0x30,0x00,0xD8,0x23,0x69,0x01,0xD6,0xAD,0x2B,0x01,0xD4,0xA9,0x1B,
+0x01,0xB4,0x15,0xB0,0x00,0xD4,0x1F,0xE1,0x18,0x11,0x2A,0x00,0x01,0xD6,0x11,0x61,
+0x00,0x0C,0x0E,0x41,0x02,0x0C,0x1C,0xB0,0xFF,0x0E,0x1C,0x98,0x00,0xD8,0x27,0x10,
+0x01,0xD4,0x15,0xB0,0x00,0x0A,0x14,0x98,0x80,0x01,0x1C,0xB8,0x00,0x0E,0x1C,0x98,
+0x02,0xA4,0x45,0x30,0x02,0x20,0x26,0x30,0x33,0xD4,0x15,0x28,0x00,0x1C,0x39,0x82,
+0x01,0x11,0x22,0x9C,0x02,0x06,0x40,0xB0,0x00,0x0C,0x86,0x59,0x01,0x10,0x22,0x1C,
+0x00,0x00,0x14,0x38,0x88,0x12,0x40,0x2B,0x88,0x12,0x40,0x2B,0x01,0x11,0x22,0x9C,
+0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,0xB8,0x01,0x18,0xB8,0x0F,0x00,0x14,0x08,
+0x00,0x0C,0x18,0x98,0x01,0x12,0x14,0x30,0x02,0x06,0x44,0x30,0xFF,0x11,0x22,0x8C,
+0x02,0x0C,0x0C,0x30,0x08,0x0C,0x18,0x18,0x02,0x12,0x1C,0xB0,0x02,0x0A,0x0C,0x30,
+0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,0x83,0x0E,0x1C,0x28,
+0x02,0x06,0x14,0x30,0x80,0x0F,0x70,0x79,0xFE,0x0C,0x18,0x18,0x02,0x12,0x14,0x30,
+0x02,0x06,0x18,0x30,0xFF,0x11,0x22,0x8C,0x01,0x0C,0x1A,0xB0,0x00,0x11,0x7A,0x41,
+0x00,0x11,0x1A,0x88,0x02,0x48,0x15,0xB0,0x80,0x0C,0x04,0xA8,0xE1,0x48,0x83,0xA9,
+0xFF,0x11,0x22,0x8C,0x02,0x48,0x91,0x32,0x00,0x0C,0x7A,0x41,0x02,0x4C,0x15,0x30,
+0x01,0x0A,0x04,0x80,0x01,0x0C,0x06,0x30,0xE1,0x4C,0x91,0x29,0xFF,0x11,0x22,0x8C,
+0x02,0x4C,0x99,0x32,0x00,0x0C,0x86,0x41,0x10,0x49,0xCD,0xF9,0xFF,0xEF,0x18,0xB8,
+0x02,0x48,0x15,0xB0,0x81,0x0C,0x04,0x28,0xE1,0x48,0xA1,0xA9,0xFF,0x11,0x22,0x8C,
+0x02,0x48,0x91,0x32,0x00,0x0C,0x98,0x41,0x02,0x4C,0x15,0x30,0x81,0x0C,0x04,0x28,
+0xE1,0x4C,0xAD,0x29,0xFF,0x11,0x22,0x8C,0x02,0x4C,0x99,0x32,0x00,0x0C,0xA4,0x41,
+0x02,0x4A,0x15,0x30,0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x98,0xE1,0x4A,0xBB,0xA9,
+0xFF,0x11,0x22,0x8C,0x02,0x4A,0x95,0x32,0x00,0x0C,0xB0,0x41,0x02,0x4A,0x15,0x30,
+0x01,0x0A,0x04,0xB0,0xFF,0x0B,0x06,0x18,0xE1,0x4A,0xC9,0xA9,0xFF,0x11,0x22,0x8C,
+0x02,0x4A,0x95,0x32,0x00,0x0C,0xBE,0xC1,0xFF,0x11,0x22,0x8C,0x00,0x0C,0x72,0xDF,
+0x03,0x4D,0x05,0xF2,0x09,0x4D,0x05,0xF2,0x12,0x4D,0x05,0xF2,0x04,0x4D,0xEB,0xE1,
+0x26,0x4E,0xDF,0x61,0x00,0x11,0x9C,0x8A,0x00,0x0C,0x00,0xC2,0x04,0x9F,0xED,0x69,
+0x4C,0x9F,0x15,0xA8,0x01,0x0A,0xE8,0x71,0x02,0x0A,0xE8,0x71,0x08,0x0A,0xEA,0x61,
+0x00,0x0C,0x20,0x5A,0x01,0x10,0x22,0x1C,0xF0,0x9F,0x15,0x88,0xFF,0x0A,0x04,0xFA,
+0x10,0x0A,0x0A,0x72,0x20,0x0A,0x00,0x72,0x30,0x0A,0x00,0xF2,0x40,0x0A,0x04,0xF2,
+0x50,0x0A,0x04,0x72,0x60,0x0A,0x0A,0xF2,0x70,0x0A,0x0A,0x72,0x80,0x0A,0x00,0x72,
+0x00,0x0C,0x1C,0x5A,0x00,0x0C,0x0C,0xC2,0x00,0x0C,0x12,0xDA,0x00,0x0C,0x0A,0x4A,
+0x00,0x0C,0x16,0x5A,0x01,0x4D,0x6F,0x33,0xFE,0x00,0x18,0xB8,0x00,0x0C,0xA4,0x59,
+0x01,0x11,0x22,0x9C,0xBF,0x01,0x18,0x38,0xA0,0x00,0x06,0xAE,0xBA,0x01,0x18,0x38,
+0xBC,0x01,0x1C,0xB8,0xA0,0x00,0xD0,0x2D,0x03,0x9F,0x3F,0x0B,0x00,0x11,0x6E,0x8B,
+0x04,0x11,0x78,0xB7,0x02,0x0C,0x0C,0x30,0x02,0xD8,0x0D,0xB0,0x00,0x0C,0x40,0xD8,
+0x1B,0x11,0x14,0x80,0x00,0x0C,0x6A,0xDA,0xC0,0x0C,0x30,0xF2,0xC0,0x11,0x3C,0xC2,
+0xFF,0x8E,0x3B,0xFA,0x02,0x8C,0x41,0xB0,0xFF,0x21,0x48,0xF2,0xFF,0xFF,0x18,0x3B,
+0xC8,0x11,0x44,0x42,0xC8,0x11,0x3C,0x42,0x00,0x0C,0xFA,0xDA,0xFF,0x21,0x48,0xF2,
+0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x40,0xD8,0x1B,0x11,0x14,0x80,0x00,0x0C,0x6A,0xDA,
+0x00,0x00,0x40,0xB8,0xFF,0xFF,0xD4,0x3B,0x00,0x0C,0x3A,0x5E,0x00,0x0C,0x56,0x52,
+0x00,0x0C,0x78,0xDF,0x00,0x0C,0x56,0x52,0x1B,0x11,0x66,0xDC,0x00,0x0C,0x14,0xDF,
+0x00,0x0C,0x4C,0xD2,0x00,0x0C,0x5E,0xDE,0x02,0x06,0xB0,0xB3,0x02,0x06,0x18,0x30,
+0xFF,0xD9,0x67,0xF2,0x02,0xD8,0x41,0x30,0x02,0x00,0x41,0xB4,0x02,0x12,0x40,0xB0,
+0xFE,0x0C,0x18,0x9C,0x02,0x0C,0x0C,0x30,0x00,0x0C,0x86,0x5A,0x02,0x0A,0x0C,0x30,
+0x00,0x0A,0x90,0xDA,0x02,0x06,0x14,0x30,0x02,0xD4,0x19,0xB0,0x02,0x12,0x0C,0x30,
+0x02,0xD4,0x1D,0x30,0xFF,0xFF,0x26,0xB8,0x02,0x06,0x40,0xB0,0xFF,0x21,0x6E,0xE2,
+0x02,0x06,0x18,0x30,0x02,0xDA,0x1D,0xB0,0xFF,0xFF,0x26,0x3C,0xC0,0x0C,0x8C,0xE2,
+0x02,0x01,0xA8,0xBB,0xA0,0x01,0xB4,0x3F,0x04,0x01,0xA8,0xBB,0xA2,0x01,0xB4,0xBF,
+0x04,0x0C,0x9A,0x72,0x1B,0x0C,0xA4,0xE2,0x01,0xB7,0x15,0xB0,0x01,0x0A,0x78,0xB2,
+0x04,0x0A,0x9E,0x62,0x00,0x0C,0xF0,0xDA,0x00,0x0C,0xB8,0xC2,0x03,0x0A,0xB8,0x62,
+0x01,0x9E,0x7B,0x8A,0x00,0x0C,0xB8,0xC2,0x23,0x0C,0xA8,0xF2,0x13,0x0C,0xB8,0xE2,
+0x02,0x20,0x78,0x32,0x88,0x11,0x02,0x00,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,
+0x02,0x52,0x15,0x30,0x02,0x06,0x40,0xB0,0x01,0x01,0x22,0xB0,0x02,0x0A,0x7C,0x32,
+0x00,0x0C,0x2E,0x5B,0x00,0x0C,0xCC,0x49,0x00,0x0C,0x86,0x59,0x00,0x0C,0x3E,0xDE,
+0x00,0x0C,0xEE,0x52,0x00,0x0C,0x72,0xDF,0xFF,0xFF,0x14,0x38,0x83,0xAC,0x59,0x2B,
+0x20,0x48,0xED,0xFA,0xFF,0x45,0xED,0x72,0x02,0x20,0x0C,0xB0,0x02,0x44,0x41,0x30,
+0xFF,0xFF,0x14,0x38,0x83,0x4A,0x95,0x2A,0x02,0x20,0x14,0xB0,0x02,0x06,0x40,0xB0,
+0x02,0x20,0x0C,0xB0,0x02,0x0A,0x0C,0x30,0x00,0x0C,0x0C,0x5B,0xC5,0x11,0x26,0xD8,
+0x88,0x11,0x02,0x00,0x02,0x06,0x40,0xB0,0x00,0x0C,0x9A,0xDC,0x01,0x01,0x22,0xB0,
+0x02,0x06,0x40,0xB0,0xFF,0x11,0x22,0x8C,0x00,0x0C,0x0C,0x5B,0xC5,0x11,0x26,0xC0,
+0x0C,0x9F,0x7B,0x8A,0x2E,0x3D,0x7B,0xAA,0x04,0x9F,0xF9,0x6A,0x4C,0x9F,0x7D,0x2E,
+0xF0,0x9F,0x7D,0x0E,0xFF,0xFF,0xAC,0x3B,0x02,0x12,0x40,0xB0,0xFE,0x0C,0x18,0x18,
+0xFF,0x21,0xCC,0xF1,0x00,0x0C,0x78,0xDF,0x00,0x0C,0xCC,0x49,0x02,0x20,0xAC,0xB3,
+0x02,0x00,0x41,0x30,0x00,0x0C,0x00,0x43,0x09,0x0A,0x11,0x73,0x0A,0x0A,0xCD,0xE1,
+0x08,0x48,0xCD,0x79,0xF8,0x1C,0x17,0x08,0x3D,0x0B,0x16,0x28,0x02,0x46,0x45,0x30,
+0xA8,0x01,0x18,0x38,0x3D,0x0B,0x14,0xA8,0x00,0x0C,0x18,0x98,0x02,0x0C,0x1C,0xB0,
+0x44,0x0B,0x0E,0xA8,0x01,0x07,0x14,0xB0,0x00,0x12,0x2C,0xEB,0xFF,0x0C,0x18,0x98,
+0x00,0x12,0x26,0x00,0x00,0x0C,0x72,0xC7,0x1A,0x11,0x2A,0x80,0x02,0x48,0x15,0xB0,
+0x01,0x0B,0x40,0xEB,0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x80,0xE1,0x48,0x3B,0x2B,
+0x01,0x11,0x22,0x9C,0x02,0x48,0x91,0x32,0x00,0x0C,0x2E,0x43,0x01,0x11,0x22,0x9C,
+0x01,0x10,0x22,0x1C,0x02,0x20,0xD4,0xB3,0x01,0x0A,0xE1,0x33,0x10,0x0B,0x51,0x7B,
+0xFF,0xFF,0x14,0x38,0x8A,0x34,0x51,0x2B,0x00,0x0C,0x72,0x5D,0x00,0x0C,0xBE,0x4A,
+0x00,0x0C,0x72,0xDF,0xC0,0x11,0x84,0x5D,0x00,0x0C,0x5C,0xD3,0x1E,0x11,0xB8,0xDA,
+0x02,0xEA,0x41,0xB0,0x00,0x11,0xB8,0xC2,0xFF,0x8E,0x67,0x7B,0x02,0x8C,0x41,0xB0,
+0xFF,0x21,0x6A,0x73,0x00,0x0C,0xF8,0xDD,0x00,0x0C,0x68,0xC3,0xC8,0x11,0x84,0xDD,
+0x00,0x0C,0x72,0xCB,0x02,0xEA,0x41,0xB0,0x00,0x0C,0xF6,0x5E,0x00,0x0C,0xBE,0x4A,
+0x02,0x0A,0x40,0xB0,0x10,0x0B,0x7B,0xFB,0x80,0x11,0x78,0x59,0x02,0xEA,0x41,0xB0,
+0xA0,0x00,0x0A,0x2A,0x1D,0x11,0xB8,0xC2,0x02,0x20,0xD4,0xB3,0x01,0x0A,0xE1,0x33,
+0x01,0x0B,0x15,0x30,0xFF,0x0A,0x92,0x7B,0x01,0x0A,0x94,0x73,0x02,0x0A,0xAA,0xF3,
+0x03,0x0A,0xDC,0xF3,0x04,0x0A,0x16,0xF4,0x05,0x0A,0x20,0x74,0x06,0x0A,0x1C,0x74,
+0xA0,0x00,0x04,0xAA,0xFF,0x11,0x28,0x02,0xC0,0x11,0xBA,0x5C,0xC8,0x11,0xBA,0xDC,
+0x00,0x00,0x40,0xB8,0x00,0x0C,0x3A,0x5E,0x00,0x0C,0xA4,0x53,0x00,0x0C,0x28,0x5E,
+0x00,0x0C,0xA4,0x53,0x23,0x11,0x66,0x5C,0x00,0x0C,0x14,0xDF,0x00,0x0C,0x9A,0xD3,
+0x00,0x0C,0x96,0xC4,0x00,0x0C,0x86,0x5F,0x00,0x0C,0xB8,0x4A,0x02,0x10,0xB5,0x7B,
+0xC0,0x11,0xE4,0xDC,0x02,0xEA,0x41,0xB0,0x04,0x10,0xBB,0xFB,0x00,0x0C,0xD6,0x5C,
+0x02,0xEA,0x41,0xB0,0x01,0x10,0xCF,0xFB,0x00,0x00,0x40,0xB8,0x00,0x0C,0x3A,0x5E,
+0x00,0x0C,0xC8,0x53,0x00,0x0C,0x78,0xDF,0x00,0x0C,0xC8,0x53,0x23,0x11,0x66,0x5C,
+0x00,0x0C,0x14,0xDF,0x00,0x0C,0xBE,0xD3,0x02,0xEA,0x41,0xB0,0x80,0x10,0xD5,0x7B,
+0x00,0x0C,0x98,0x5F,0x02,0xEA,0x41,0xB0,0x40,0x10,0xDB,0xFB,0x00,0x0C,0xA8,0x5F,
+0x02,0xEA,0x41,0xB0,0x00,0x0C,0x96,0xC4,0x02,0x46,0x45,0x30,0x01,0x11,0x4A,0x80,
+0x08,0x28,0xC1,0xB3,0x00,0x11,0x4A,0x88,0x02,0x10,0xEB,0xFB,0xC0,0x11,0xFC,0xDC,
+0x02,0xEA,0x41,0xB0,0x04,0x10,0xF1,0x7B,0x00,0x0C,0xF2,0x5C,0x02,0xEA,0x41,0xB0,
+0x01,0x10,0x09,0x7C,0x00,0x00,0x40,0xB8,0x00,0x0C,0x3A,0x5E,0x00,0x0C,0x02,0xD4,
+0x00,0x0C,0x78,0xDF,0x00,0x0C,0x02,0xD4,0x00,0x0C,0x56,0x5D,0x00,0x0C,0x02,0xD4,
+0x23,0x11,0x66,0x5C,0x00,0x0C,0x14,0xDF,0x00,0x0C,0xF4,0x53,0x02,0xEA,0x41,0xB0,
+0x80,0x10,0x0F,0x7C,0x00,0x0C,0x98,0x5F,0x02,0xEA,0x41,0xB0,0x40,0x10,0x15,0xFC,
+0x00,0x0C,0xA8,0x5F,0x02,0xEA,0x41,0xB0,0x00,0x0C,0x96,0xC4,0x00,0x0C,0x72,0x5D,
+0x00,0x0C,0xBE,0x4A,0x00,0x0C,0x20,0x44,0x00,0x0C,0x6E,0xDD,0x00,0x0C,0xBE,0x4A,
+0x00,0x0C,0x72,0xDF,0xC0,0x11,0x84,0x5D,0x00,0x0C,0x5C,0x4C,0xFF,0x8E,0x31,0xFC,
+0x02,0x8C,0x41,0xB0,0xFF,0x21,0x34,0x74,0x00,0x0C,0xF8,0xDD,0x00,0x0C,0x32,0x44,
+0xC8,0x11,0x84,0xDD,0x00,0x0C,0x3C,0x4C,0x02,0xEA,0x41,0xB0,0x00,0x0C,0xF6,0x5E,
+0x00,0x0C,0xBE,0x4A,0x02,0x0A,0x40,0xB0,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,
+0x01,0x10,0x15,0x30,0x02,0x06,0x40,0xB0,0x40,0x0A,0x62,0x7C,0xFF,0x4D,0x57,0x6C,
+0x7F,0xFF,0x18,0xB8,0x00,0x0C,0x98,0x59,0x40,0x01,0x18,0x38,0x00,0x0C,0x40,0x59,
+0x00,0x0C,0x58,0xD4,0xB0,0x00,0x40,0x2A,0x00,0x0C,0x58,0x44,0x00,0x4D,0xB9,0x5A,
+0x02,0xEA,0x41,0xB0,0x13,0x11,0x90,0x42,0x23,0x11,0x90,0x5A,0x02,0xEA,0x41,0xB0,
+0x00,0x11,0xB8,0xC2,0x23,0x11,0x66,0x5C,0x00,0x0C,0x96,0xC4,0x97,0x07,0x0C,0x38,
+0x00,0x0C,0x1E,0xDF,0x02,0x0C,0x0C,0x30,0x80,0x11,0x78,0x59,0x02,0x06,0x18,0x30,
+0xFF,0x4B,0x91,0xFA,0x20,0x48,0x87,0xFC,0xFF,0x45,0x87,0x74,0x02,0x20,0x0C,0xB0,
+0x02,0x44,0x41,0x30,0xFF,0xFF,0x14,0x38,0x83,0x4A,0x95,0x2A,0x02,0x4A,0x15,0x30,
+0x89,0x10,0x84,0x2C,0x00,0x11,0xB8,0xDA,0x02,0x06,0x40,0xB0,0x02,0xEA,0x89,0xB2,
+0x20,0x11,0x78,0x59,0xFF,0xEB,0xCD,0x71,0x02,0x20,0xA8,0x33,0x02,0xEA,0x41,0xB0,
+0x01,0x00,0x14,0xB8,0x83,0x4A,0x95,0x2A,0x02,0xD4,0x41,0xB4,0x02,0xEA,0x41,0xB0,
+0x40,0x10,0xB9,0x74,0x02,0x4A,0x15,0x30,0x89,0x10,0xCC,0x29,0x01,0x0B,0x15,0x30,
+0xFF,0x0A,0xB0,0xFC,0x01,0x0A,0xB0,0xF4,0x02,0x0A,0xB4,0x74,0x03,0x0A,0xB4,0xF4,
+0x04,0x0A,0xB4,0x74,0x05,0x0A,0xB4,0xF4,0x06,0x0A,0xB4,0xF4,0xA0,0x00,0x04,0xAA,
+0x00,0x0C,0x46,0xDE,0x00,0x11,0xB8,0xC2,0x00,0x0C,0x5A,0x5E,0x00,0x11,0xB8,0xC2,
+0x13,0x11,0x90,0x42,0x01,0x11,0x1A,0x80,0xFF,0xFF,0xB0,0xBB,0x02,0x12,0x40,0xB0,
+0xFE,0x0C,0x18,0x18,0xFF,0x21,0xCC,0xF1,0x00,0x0C,0x28,0x5E,0x00,0x0C,0xD2,0x54,
+0x00,0x0C,0x40,0xD8,0x23,0x11,0x14,0x00,0x00,0x0C,0x6A,0xDA,0xFF,0xD9,0xBF,0xF4,
+0x02,0xD8,0x41,0x30,0x02,0x00,0x41,0x30,0x00,0x0C,0xC2,0x44,0xFF,0x8E,0xE3,0xFC,
+0x02,0x8C,0x41,0xB0,0xFF,0x21,0xCC,0xF1,0xFF,0xFF,0x18,0x3B,0xFF,0xFF,0x44,0x3B,
+0xC8,0x11,0xEE,0x44,0xC8,0x11,0xE4,0x44,0x01,0x11,0x1A,0x80,0x00,0x0C,0xFA,0xDA,
+0xFF,0x21,0xCC,0xF1,0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x40,0xD8,0x23,0x11,0x14,0x00,
+0x00,0x0C,0x6A,0xC2,0xFF,0x8E,0xFB,0xFC,0x02,0x8C,0x41,0xB0,0xFF,0x21,0xCC,0xF1,
+0xC8,0x11,0x06,0xC5,0xC8,0x11,0xFC,0x44,0x01,0x11,0x1A,0x80,0x00,0x0C,0xFA,0xDA,
+0xFF,0x21,0xCC,0xF1,0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x40,0xD8,0x02,0x0C,0x0C,0x30,
+0x02,0x20,0xE4,0xB3,0x00,0x0C,0x86,0x5A,0xFF,0xFF,0xB0,0xBB,0x00,0x0C,0x56,0x5D,
+0x00,0x0C,0x3E,0x55,0xFF,0xD9,0x1D,0x65,0x02,0xD4,0x19,0xB0,0x02,0x12,0xE4,0x33,
+0xFF,0xF3,0x2D,0x75,0x00,0x0C,0x30,0x45,0x02,0x20,0x0C,0xB0,0x02,0xD4,0x19,0xB0,
+0x02,0x12,0xAC,0x33,0x02,0xD8,0x41,0x30,0x02,0xD4,0x1D,0x30,0x02,0xD6,0x27,0xB0,
+0x02,0x06,0x40,0xB0,0xFF,0xD7,0x31,0x65,0x02,0xDA,0x1D,0xB0,0x02,0xD8,0x27,0x30,
+0x02,0xD4,0x19,0xB0,0x02,0x12,0x0C,0x30,0x02,0xD4,0x1D,0x30,0xFF,0xFF,0x26,0xB8,
+0x23,0x11,0x90,0x5A,0x02,0x06,0x40,0xB0,0x00,0x0C,0x44,0x45,0x02,0x20,0xB0,0x33,
+0x02,0xD4,0x19,0xB0,0x02,0x12,0x40,0xB0,0xFF,0x21,0x0E,0x65,0x02,0x06,0x18,0x30,
+0xC8,0x0C,0x4C,0xE5,0xFF,0x8E,0x55,0x6D,0xFF,0xF3,0xCD,0x71,0x02,0xF2,0x41,0xB0,
+0x01,0x0C,0x18,0x18,0x00,0x0C,0x26,0xC0,0x02,0xF2,0x19,0xB7,0x01,0x11,0x4A,0x80,
+0x08,0x28,0xD1,0x33,0xE0,0x01,0x18,0x38,0x01,0x12,0x14,0x30,0x07,0x0C,0x18,0x18,
+0x00,0x12,0x6A,0xE5,0xF8,0x0C,0x18,0x18,0xE8,0x0C,0x5C,0xE5,0x00,0x11,0x4A,0x88,
+0x01,0x10,0x22,0x1C,0x00,0x11,0x4A,0x88,0x01,0x11,0x22,0x9C,0x00,0x0C,0xB2,0x5E,
+0x00,0x0C,0x74,0x45,0x00,0x0C,0xC8,0xDE,0x00,0x0C,0xCC,0x49,0x01,0x34,0x17,0xB0,
+0x01,0x35,0x15,0xB0,0x02,0x0A,0x40,0xB0,0x02,0x08,0x15,0x30,0x02,0xEA,0x41,0xB0,
+0x02,0x0A,0xA0,0xB2,0x01,0x11,0x22,0x9C,0x01,0x11,0x1A,0x80,0x02,0x0C,0xDC,0xB3,
+0x00,0x0C,0xFA,0xDA,0x02,0xD6,0xD9,0x33,0x00,0x0C,0x86,0x5A,0xFF,0xFF,0xB0,0xBB,
+0xFF,0x21,0x3E,0xF3,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x02,0x50,0x15,0xB0,
+0x02,0x06,0x40,0xB0,0x8A,0x08,0xA5,0xAD,0x02,0x20,0xB0,0x33,0x02,0xD4,0x19,0xB0,
+0x02,0x12,0x40,0xB0,0x00,0x0C,0x90,0x45,0xC4,0xF0,0xA9,0xF5,0x04,0x4C,0x3F,0x6B,
+0xFF,0xD9,0xC1,0x75,0x02,0x20,0x0C,0xB0,0x02,0xD4,0x19,0xB0,0x02,0x12,0xAC,0x33,
+0x02,0xD8,0x41,0x30,0x02,0xD4,0x1D,0x30,0x02,0xD6,0x27,0xB0,0x02,0x06,0x40,0xB0,
+0xFF,0xD7,0xF3,0xE5,0x02,0xDA,0x1D,0xB0,0x02,0xD8,0x27,0x30,0x00,0x0C,0xF2,0xC5,
+0x02,0xD4,0x19,0xB0,0x02,0x12,0x14,0x30,0xFF,0x0B,0xEA,0x75,0xFF,0xED,0xD3,0xF5,
+0x02,0x20,0x0C,0xB0,0x02,0xEC,0x41,0xB0,0x02,0x0A,0x00,0xB2,0x02,0x06,0x40,0xB0,
+0x00,0x0C,0xD6,0xC5,0x02,0xEE,0x1D,0x30,0x02,0x0A,0x26,0xB0,0xFF,0x01,0xDF,0xE5,
+0x02,0xEE,0x1D,0x30,0x02,0x0E,0x1C,0x18,0x02,0x0A,0x26,0xB0,0x02,0x20,0x0C,0xB0,
+0x02,0x00,0xAD,0xB3,0x02,0x0A,0x40,0xB0,0x02,0xD6,0x01,0xB2,0x02,0x06,0x40,0xB0,
+0x00,0x0C,0xF2,0xC5,0x02,0xDA,0x1D,0xB0,0xFF,0xFF,0x26,0xB8,0x02,0xEC,0xB1,0xB3,
+0x00,0xEE,0x41,0x58,0xC8,0xEE,0xF7,0xE5,0x00,0x0C,0xBE,0xD9,0x01,0x10,0x22,0x1C,
+0xFF,0xFF,0xB0,0xBB,0xFF,0x21,0x3E,0xF3,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,
+0x02,0x50,0x15,0xB0,0x02,0x06,0x40,0xB0,0x8A,0x08,0x0D,0x2E,0x02,0x20,0xB0,0x33,
+0x02,0x04,0x41,0xB0,0x00,0x0C,0xFA,0x45,0xFF,0xD9,0x1F,0x76,0x02,0x20,0x0C,0xB0,
+0x02,0x04,0xAD,0x33,0x02,0xD8,0x41,0x30,0x02,0xD6,0x09,0x32,0x02,0x06,0x40,0xB0,
+0xFF,0xD7,0x25,0x66,0x02,0xD8,0x45,0xB3,0x00,0x0C,0x24,0x46,0x02,0x04,0x19,0x33,
+0xFF,0x05,0x25,0x66,0xFF,0xFF,0x44,0x3B,0x00,0x0C,0xBE,0xD9,0x01,0x10,0x22,0x1C,
+0x00,0x0C,0x72,0xDF,0x02,0x20,0x0C,0xB0,0x02,0xEA,0x41,0xB0,0x00,0x0C,0x34,0xDE,
+0x02,0x06,0x40,0xB0,0xFF,0x11,0x22,0x8C,0x01,0x14,0x15,0xB0,0x00,0x9C,0x3F,0xFB,
+0x01,0x10,0x22,0x1C,0x01,0x49,0x3F,0x6B,0xFF,0x0A,0x3F,0x73,0xC0,0x0A,0x15,0x88,
+0x80,0x0A,0x3E,0x73,0xC0,0x0A,0x3E,0xF3,0x01,0x10,0x22,0x1C,0x02,0x00,0x44,0xB8,
+0xFE,0x8F,0x51,0x66,0x00,0x0C,0x34,0xDE,0x00,0x0C,0x50,0xD6,0x00,0x0C,0x5E,0xDE,
+0x01,0x00,0x14,0xB8,0x83,0x22,0x44,0x28,0x02,0xFE,0x15,0x30,0x88,0x22,0x48,0xAE,
+0xFF,0x11,0x22,0x8C,0x02,0xAC,0x15,0xB0,0x89,0x10,0xCC,0x29,0x80,0x9D,0x79,0x7E,
+0x02,0x22,0x0C,0x30,0x02,0xA4,0x45,0x30,0x00,0x11,0xB4,0x0B,0x80,0x01,0x18,0x38,
+0x02,0x22,0x0C,0x30,0x02,0x12,0x44,0x30,0xFF,0x23,0x70,0x76,0x00,0x0C,0x78,0x5E,
+0x02,0x06,0x44,0x30,0x01,0xDA,0xB5,0x1B,0x10,0xDA,0x69,0xE6,0x02,0x06,0x44,0x30,
+0x00,0x11,0x3C,0x0B,0x04,0x10,0x40,0x33,0xFF,0xFF,0x4C,0xBB,0x04,0x11,0x60,0x33,
+0x00,0x11,0x6A,0x0B,0x00,0x11,0x6C,0x0B,0x03,0x9F,0x3F,0x0B,0x00,0x11,0x6E,0x8B,
+0x00,0x0C,0x1C,0x5A,0xFF,0xB4,0xCD,0xF9,0x04,0x11,0x50,0x33,0x3D,0xB4,0x15,0xA8,
+0xA8,0x01,0x1C,0xB8,0x00,0x11,0x16,0x88,0xFF,0x0A,0x9E,0x7E,0xFF,0x11,0x26,0x00,
+0x08,0x0B,0x16,0x18,0xFF,0x0A,0x14,0x98,0x00,0x0C,0x94,0xC6,0xFF,0x0B,0x14,0x90,
+0x01,0x0A,0x14,0x18,0x00,0xB4,0x15,0x18,0xFF,0x0A,0xAA,0xFE,0x44,0x0A,0x0E,0x28,
+0xFF,0x07,0x26,0x98,0x02,0x22,0x14,0x30,0x01,0xA4,0x45,0x30,0x40,0x10,0x00,0xB3,
+0x02,0x0A,0x44,0xB4,0x02,0x20,0x0C,0xB0,0x02,0x46,0x45,0x30,0x02,0xA4,0x45,0x30,
+0x01,0x35,0x15,0xB0,0x00,0x0A,0x14,0x98,0x80,0x01,0x18,0x38,0x00,0x0C,0x18,0x98,
+0x02,0x12,0x40,0xB0,0xFF,0xFF,0x14,0x38,0x8A,0x20,0xEA,0x2E,0x00,0x0C,0xDC,0xC6,
+0x02,0x20,0x0C,0xB0,0x01,0x35,0x15,0xB0,0x01,0x34,0x17,0xB0,0x02,0x0A,0x40,0xB0,
+0x02,0x20,0x18,0xB0,0x02,0xFC,0x15,0xB0,0x00,0x0C,0x5E,0x5F,0x80,0x0B,0xEA,0x7E,
+0xFF,0x20,0xDC,0xE6,0xF0,0x21,0xEA,0x7E,0xFF,0x0A,0xED,0x76,0x01,0x49,0xEF,0xEE,
+0x02,0x20,0x14,0xB0,0x02,0x06,0x40,0xB0,0x01,0x0A,0x6A,0xB2,0x01,0x0B,0x68,0xB2,
+0x01,0x11,0x22,0x9C,0x1F,0x11,0xF0,0xC6,0x20,0x11,0xF0,0xC6,0x21,0x11,0xF0,0x46,
+0x02,0x06,0x40,0xB0,0x00,0x0C,0x86,0x59,0x01,0x10,0x22,0x1C,0x02,0x50,0xA9,0x33,
+0x02,0x20,0x0C,0xB0,0x00,0x00,0x40,0xB8,0x02,0x08,0x15,0x30,0x8A,0xD4,0x0B,0x2F,
+0x00,0x0C,0x14,0xDF,0x00,0x0C,0xFC,0xD6,0x02,0x06,0x40,0xB0,0x1D,0x11,0x86,0x59,
+0x01,0x10,0x22,0x1C,0x02,0x20,0x14,0xB0,0x02,0x06,0x40,0xB0,0x01,0x0B,0x68,0xB2,
+0x01,0x0A,0x6A,0xB2,0x01,0x11,0x22,0x9C,0x01,0x00,0x14,0xB8,0x83,0x20,0x40,0x28,
+0x02,0xFC,0x15,0xB0,0x88,0x20,0x3E,0xAB,0x01,0x10,0x22,0x1C,0x02,0x48,0x15,0xB0,
+0x02,0x0B,0x1E,0xEF,0x01,0x0A,0x04,0xB0,0x02,0x0B,0x06,0x80,0xE1,0x48,0x2B,0x2F,
+0xFF,0x11,0x22,0x8C,0x02,0x48,0x91,0x32,0x00,0x0C,0x1E,0xC7,0xFF,0xFD,0x18,0xB8,
+0x00,0x0C,0x98,0x41,0x80,0x9D,0x55,0x7F,0x02,0x22,0xA8,0xB3,0x02,0xA4,0x45,0x30,
+0x00,0x11,0xB4,0x0B,0x02,0x22,0xAC,0x33,0x80,0x01,0x18,0x38,0x11,0xDA,0x15,0xA8,
+0x00,0x0C,0x18,0x98,0x02,0x12,0x44,0x30,0xFF,0x23,0x4A,0xF7,0x00,0x0C,0x54,0x5F,
+0x00,0x0C,0x52,0xCF,0x02,0xD6,0x45,0x30,0x01,0xDA,0xB5,0x1B,0x10,0xDA,0x3B,0xE7,
+0x01,0x11,0x22,0x18,0x02,0xD4,0x45,0x34,0x08,0x9E,0x5B,0xFF,0xB0,0x01,0x18,0x38,
+0x00,0x0C,0x40,0x41,0xFF,0xA7,0x41,0x63,0x01,0x11,0x22,0x9C,0x82,0x10,0x14,0x28,
+0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,0x02,0x0A,0x0C,0x30,0xFF,0xFF,0x14,0x38,
+0x84,0x11,0x1C,0x28,0x02,0x06,0x14,0x30,0x83,0x0C,0x22,0x28,0x00,0x00,0x14,0x38,
+0x84,0x0E,0x14,0xAC,0x02,0x46,0x45,0x30,0x02,0x9D,0xCD,0xF9,0x02,0xAE,0x45,0xB4,
+0x02,0x22,0x14,0x30,0x00,0x0C,0x72,0xDF,0x88,0x22,0x82,0x2F,0x01,0x10,0x22,0x98,
+0x02,0x0A,0x44,0xB4,0x01,0x11,0x22,0x18,0x02,0x0A,0x44,0xB4,0x02,0x46,0x45,0x30,
+0xFE,0xFF,0x14,0xB8,0x8B,0x22,0x94,0xAF,0x02,0x22,0x18,0x30,0x02,0xFE,0x15,0x30,
+0xB1,0x00,0x5E,0xAF,0x80,0x0B,0x3E,0xEB,0x22,0x11,0x18,0x80,0x01,0x10,0x22,0x1C,
+0x01,0x8E,0x1D,0x1B,0x01,0x8E,0xCD,0x61,0xC8,0x01,0x18,0x38,0x00,0x0C,0xFA,0xDA,
+0xFF,0x21,0xA6,0xF7,0x02,0xD6,0xB1,0xB3,0x00,0x0C,0x40,0xD8,0x02,0x20,0x18,0x37,
+0xFF,0x8E,0x1D,0x9B,0xFF,0x8E,0xCD,0x69,0xFF,0x8D,0xCD,0x71,0x02,0x8C,0x41,0xB0,
+0xFF,0xFF,0x18,0x3B,0xC9,0x11,0x26,0xC0,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+};
+
+uint8_t Lsb0[] = {
+0x22,0x11,0x00,0x80,0x00,0x04,0xC0,0xBB,0x33,0x11,0x00,0x80,0x00,0x00,0x44,0x38,
+0xFD,0x05,0x0A,0x88,0x00,0x11,0x00,0x08,0x00,0x0C,0xC2,0xC0,0x55,0x00,0x0C,0x38,
+0x00,0x0C,0xD4,0x40,0x55,0x00,0x0C,0x38,0x00,0x0C,0xB4,0xC1,0x55,0x00,0x0C,0x38,
+0x00,0x0C,0xBA,0x41,0x55,0x00,0x0C,0x38,0x00,0x0C,0xD4,0xC1,0x55,0x00,0x0C,0x38,
+0xA1,0x00,0x58,0xAB,0x55,0x00,0x0C,0x38,0xA2,0x00,0xD4,0x2B,0x55,0x00,0x0C,0x38,
+0xA2,0x00,0x3E,0x2C,0x55,0x00,0x0C,0x38,0x00,0x0C,0xA4,0xC0,0x55,0x00,0x0C,0x38,
+0xA1,0x00,0x10,0xAB,0x55,0x00,0x0C,0x38,0xA1,0x00,0x72,0xAC,0x55,0x00,0x0C,0x38,
+0x02,0x3C,0x14,0x30,0x81,0x38,0xB0,0xAB,0x02,0x3E,0x14,0xB0,0x81,0x3A,0xB4,0xAB,
+0x01,0xDA,0x65,0xF8,0x10,0x83,0x14,0x08,0x00,0xE3,0x14,0x88,0xFF,0x0A,0x56,0xF8,
+0x40,0xD9,0x95,0xF8,0x40,0x11,0x72,0x00,0xB1,0x00,0xC8,0xAA,0x40,0xC8,0x53,0xF8,
+0x80,0xC8,0x91,0x03,0x10,0x11,0x06,0x81,0x01,0x11,0x74,0x84,0xFF,0x80,0x14,0x88,
+0x00,0xE0,0x14,0x88,0xFF,0x0A,0x94,0x78,0x40,0xD9,0x95,0xF8,0xC0,0xD9,0x14,0x88,
+0xC0,0x0A,0x94,0xF0,0x00,0x0C,0xAE,0xC5,0x55,0x11,0x02,0x00,0x01,0x3B,0x14,0xB0,
+0x00,0x3F,0x14,0x08,0x01,0x0A,0x9C,0xE8,0x01,0x01,0x22,0xB0,0x40,0xD9,0xAF,0x6D,
+0x80,0xD9,0x67,0x6A,0x3B,0x00,0x18,0xB8,0x00,0x0C,0x12,0xC7,0x00,0x0C,0x80,0xC0,
+0x00,0x0C,0x86,0xC0,0x00,0x0C,0x8C,0xC0,0xFF,0x11,0x22,0x20,0x00,0x0C,0x92,0xC0,
+0x20,0xD9,0x4B,0xE9,0x02,0xDA,0x97,0xE8,0xFF,0x11,0x22,0x8C,0x02,0xDB,0xA3,0xE8,
+0x02,0xDA,0x97,0xE8,0xFF,0x11,0x22,0x8C,0x08,0xDA,0x99,0x68,0x80,0xDA,0x9B,0xE8,
+0xFF,0x11,0x22,0x8C,0x00,0x0C,0xA4,0xC0,0xA1,0x00,0x16,0xAD,0xA2,0x00,0x36,0x2E,
+0xA1,0x00,0x7A,0xAE,0xA1,0x00,0x58,0x2F,0x01,0x01,0x22,0xB0,0x55,0x11,0x00,0x80,
+0xA2,0x00,0x00,0x28,0x02,0x11,0x76,0x04,0xF0,0x04,0x14,0x88,0x4C,0x0A,0x14,0x28,
+0xFF,0x0A,0x2A,0x18,0x01,0x05,0x0A,0x84,0x80,0xE1,0xC3,0x03,0xFD,0x05,0x0A,0x88,
+0x5A,0x00,0x18,0x38,0x00,0x0C,0x12,0xC7,0x00,0x0C,0xC0,0x40,0x00,0x0C,0xC0,0x40,
+0x00,0x0C,0xBE,0x40,0xFF,0x11,0x22,0x20,0x00,0x0C,0x08,0xC0,0x11,0x00,0x00,0x98,
+0x11,0x00,0x00,0x98,0x80,0xE1,0xAF,0xE8,0x02,0xE0,0x0D,0xB4,0x02,0x06,0xC0,0x33,
+0x02,0x06,0xCC,0x33,0x02,0xE0,0x0D,0xB4,0x02,0x06,0xC0,0x33,0x02,0xE0,0x0D,0xB4,
+0xFD,0x05,0x0A,0x88,0x02,0xE6,0x0D,0xB4,0x10,0x45,0x00,0xE9,0x20,0xCE,0x0D,0x69,
+0x02,0x54,0x40,0x30,0xB1,0x00,0xBE,0x2C,0x00,0x0C,0x44,0x49,0x00,0x00,0x90,0x38,
+0x18,0x10,0xA1,0xB0,0x01,0x11,0x48,0x00,0x18,0xC0,0xA3,0xB0,0x00,0x11,0x48,0x08,
+0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,0x01,0x0A,0xFC,0xF0,0x00,0x11,0x92,0x88,
+0x00,0x11,0xA2,0x88,0x0B,0x11,0x92,0x80,0x00,0x11,0xA2,0x88,0x05,0x0A,0xFC,0x70,
+0x14,0x11,0x92,0x00,0x04,0x11,0xA2,0xB0,0x02,0x8A,0xC4,0x30,0x80,0x11,0x90,0x84,
+0x30,0xCB,0x0D,0x79,0x00,0x00,0x90,0x38,0x34,0x00,0xA0,0xB8,0xFF,0x00,0xA2,0xB8,
+0xB2,0x00,0xFA,0x2C,0x80,0x11,0x90,0x84,0xB2,0x00,0x08,0x2D,0x00,0x0C,0x44,0x49,
+0xB1,0x00,0xBE,0x2C,0x00,0x0C,0x44,0x49,0x80,0x49,0x45,0x69,0xB2,0x00,0xEA,0xAC,
+0x03,0x3A,0x49,0xE1,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,0x46,0x0A,0x26,0xF1,
+0x39,0x0A,0x34,0x71,0x34,0x0A,0x3E,0xF1,0x80,0x11,0x90,0x84,0x1B,0x48,0x15,0x88,
+0x13,0x0A,0x48,0xE1,0x02,0x11,0x1C,0xDF,0xB2,0x00,0xBC,0xAC,0x04,0x0C,0x81,0xB2,
+0xB2,0x00,0xA8,0x2D,0x00,0x0C,0x40,0x41,0x1B,0x48,0x15,0x88,0x13,0x0A,0x48,0xE1,
+0x01,0x11,0x1C,0xDF,0xB2,0x00,0xC2,0xAC,0x00,0x0C,0x40,0x41,0xB2,0x00,0xA4,0xAC,
+0xB2,0x00,0xEA,0xAC,0x80,0x11,0x90,0x84,0x40,0xE5,0xCB,0x03,0xB2,0x00,0xC8,0x2D,
+0x80,0x11,0x90,0x84,0x20,0x11,0x72,0x00,0x40,0xE5,0x6B,0x69,0xFF,0xC0,0x6A,0xE9,
+0xFF,0xC1,0x6A,0x69,0x0F,0xC2,0x6A,0x69,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,
+0x01,0x0A,0x60,0x71,0x05,0x0A,0x68,0xE1,0xB1,0x00,0x5A,0x2C,0x00,0x0C,0x68,0x41,
+0xB6,0x00,0x0C,0xB8,0x20,0x49,0x67,0x69,0xA1,0x00,0x80,0xAB,0xA1,0x00,0x74,0x2B,
+0x80,0x11,0x18,0x5F,0x18,0x11,0xB8,0x80,0xBF,0xE5,0xCB,0x8B,0xFF,0xFF,0xC4,0x3C,
+0x00,0x0C,0xCC,0x58,0x02,0x05,0x0A,0x00,0x0F,0xCB,0x99,0x69,0x80,0x49,0xAF,0xE9,
+0x20,0x48,0xA3,0x69,0x80,0xC8,0x9B,0x69,0x80,0xCE,0x83,0xF9,0x08,0xC8,0xA3,0xE9,
+0x00,0x0C,0x92,0x41,0x20,0xC8,0xA3,0xE9,0x80,0xCE,0x93,0xE9,0x02,0xCA,0x9D,0xE9,
+0x08,0xCA,0xAF,0x69,0x02,0x86,0x9E,0x69,0x40,0x4C,0x93,0x79,0x02,0x93,0x92,0x79,
+0x02,0x7F,0xA2,0xF9,0x80,0xE5,0xA3,0xE9,0x80,0xE4,0xA7,0xE9,0x00,0x0C,0xAE,0xC0,
+0x08,0x11,0xA0,0x41,0x05,0x11,0xA0,0xC1,0x0F,0x11,0xA0,0xC1,0x24,0x11,0xA0,0xC1,
+0x00,0x0C,0x82,0x5D,0xFD,0x05,0x0A,0x88,0x00,0x0C,0x4C,0x5F,0x80,0x4C,0xB1,0x79,
+0xB1,0x00,0xBA,0xA9,0x0C,0x11,0x30,0xDF,0x00,0x0C,0x60,0xC2,0x06,0x11,0x82,0x5D,
+0xB1,0x00,0xBA,0xA9,0x00,0x0C,0x60,0xC2,0x01,0x48,0xB9,0x79,0xA1,0x00,0x62,0xAB,
+0xA1,0x00,0x80,0xAB,0x28,0x00,0x14,0x38,0x88,0x90,0xCC,0x29,0x02,0x48,0xCD,0x79,
+0xB1,0x00,0x40,0xAC,0x80,0x49,0xCF,0xE9,0x12,0x11,0x94,0x00,0x02,0x52,0x44,0x32,
+0xB1,0x00,0x5C,0x2C,0x00,0x0C,0xD0,0x41,0x80,0x11,0x18,0x5F,0xB1,0x00,0x5A,0x2C,
+0x18,0x11,0xB8,0x80,0xFF,0xFF,0xC4,0x3C,0xF5,0x00,0x0C,0x38,0x00,0x11,0x94,0x88,
+0x01,0x52,0xB0,0x33,0x40,0xCE,0xE1,0xE9,0x07,0xD8,0xEF,0xF1,0x00,0x0C,0xE8,0xC1,
+0x41,0xD8,0xE5,0xE1,0xA1,0x00,0x54,0xAE,0x08,0xCA,0x95,0x03,0xB1,0x00,0xC4,0xAA,
+0x18,0x11,0xB8,0x04,0x40,0xCE,0x2D,0xEF,0xFF,0xFF,0xC4,0x3C,0x80,0x7F,0xF2,0x69,
+0x07,0x11,0xF6,0x41,0x01,0x01,0xC0,0x3B,0x40,0xCA,0x95,0x87,0x01,0x0C,0xF8,0xB3,
+0xB2,0x00,0xBC,0x2E,0x00,0x0C,0xE8,0x49,0xB1,0x00,0x98,0xAC,0x04,0x01,0xC0,0x3B,
+0x40,0xCA,0x95,0x87,0x0C,0x11,0x30,0xDF,0x18,0x11,0xB8,0x80,0x00,0x0C,0x60,0xC2,
+0x02,0x48,0x15,0xB0,0x01,0x0B,0x58,0x6A,0x01,0x0A,0x04,0xB0,0x01,0x0B,0x06,0x80,
+0xE0,0x48,0x15,0x2A,0x00,0x0C,0x18,0xC2,0x02,0x48,0x91,0x32,0x00,0x0C,0x08,0x42,
+0x04,0x0C,0x49,0x31,0x03,0x0A,0x1F,0xE2,0x02,0x34,0x15,0x30,0x02,0x0A,0x48,0xB1,
+0xFC,0xFF,0x14,0x38,0x83,0x90,0x48,0xA9,0x08,0x11,0x48,0xB1,0x30,0xCE,0x31,0x7A,
+0x02,0x11,0x48,0x00,0x0C,0xD4,0x4D,0x31,0x04,0xB0,0x4D,0x31,0x00,0x11,0x48,0x08,
+0x02,0x20,0xFC,0xB3,0xB1,0x00,0x0E,0xAA,0x44,0x0A,0xE6,0x2B,0x0C,0x00,0x14,0x38,
+0x30,0xCE,0x3D,0x7A,0x14,0x0A,0x14,0x98,0x83,0x90,0x14,0x28,0xB1,0x00,0x42,0x2A,
+0x00,0x11,0xE4,0x0B,0x80,0xF2,0xE5,0x2B,0x20,0x11,0xB8,0x00,0xB1,0x00,0x5E,0xAA,
+0x02,0x08,0xE1,0xB3,0xC0,0x11,0x30,0xDF,0x02,0xFE,0x41,0xB0,0x00,0xFC,0x6D,0x5F,
+0x02,0xF0,0x79,0x32,0x02,0xF2,0x7D,0x32,0xB1,0x00,0x8C,0xAC,0x00,0x0C,0x5A,0xC2,
+0x18,0x11,0xB8,0x80,0x7F,0xFF,0x18,0xB8,0xB2,0x00,0x70,0x2E,0x0E,0x11,0x30,0x5F,
+0xB1,0x00,0xA2,0xAC,0xBF,0xCA,0x95,0x8B,0x00,0x0C,0xEE,0xC4,0x00,0x11,0x00,0x08,
+0x02,0xB4,0x14,0x30,0x81,0xB0,0x14,0x28,0x80,0x0A,0x82,0x6A,0x20,0x0A,0xA6,0x6A,
+0x10,0x0A,0xAC,0x6A,0x04,0x0A,0xAE,0xEA,0x02,0x0A,0xB0,0xEA,0x01,0x0A,0xB2,0x6A,
+0x08,0x0B,0xB4,0xEA,0x04,0x0B,0xB6,0x6A,0x02,0x0B,0xB8,0xEA,0x01,0x0B,0xBC,0x6A,
+0x48,0xF0,0x60,0x3D,0x23,0x11,0x02,0x80,0x02,0x48,0xE4,0x33,0x33,0x11,0x00,0x80,
+0x00,0x00,0x90,0x38,0x22,0x11,0x00,0x80,0x03,0x11,0x48,0x80,0xC4,0x01,0x18,0x38,
+0xB2,0x00,0xCE,0x2D,0x00,0x11,0x48,0x08,0x00,0x0C,0x9A,0x4A,0xB2,0x00,0xBC,0x2D,
+0x00,0x0C,0xA2,0x42,0x18,0x11,0x18,0x80,0xB1,0x00,0xDA,0xAA,0xC4,0x01,0x1C,0xB8,
+0xF0,0x11,0x62,0x5F,0x01,0x01,0x22,0xB0,0x80,0x11,0x60,0x05,0x00,0x0C,0xD8,0xDA,
+0x20,0x11,0x32,0xDF,0x20,0x11,0x60,0x05,0x10,0x11,0x60,0x05,0x04,0x11,0x60,0x05,
+0x02,0x11,0x60,0x05,0x01,0x11,0x60,0x05,0x08,0x11,0x62,0x85,0x04,0x11,0x62,0x85,
+0x00,0x0C,0xD8,0xDA,0x02,0x11,0x62,0x85,0x02,0x90,0x14,0x30,0x8B,0x10,0xCC,0xAA,
+0x03,0x0A,0xE0,0x39,0xFF,0x11,0x22,0x20,0x10,0x00,0xD0,0xB9,0x00,0x00,0xD4,0xB9,
+0x01,0x11,0x62,0x01,0x00,0x00,0xE0,0xBD,0x02,0x54,0x40,0x30,0xB1,0x00,0xBE,0x2C,
+0x00,0x0C,0xD6,0xCA,0xB1,0x00,0xF4,0xAC,0xB1,0x00,0x86,0x2B,0x01,0x11,0x62,0x85,
+0x80,0xCE,0xE5,0x6A,0x08,0xCA,0x95,0x03,0x40,0xCE,0xE1,0xEA,0xA1,0x00,0x80,0xAB,
+0x18,0x11,0xB8,0x80,0xA1,0x00,0xC4,0x2A,0x10,0x11,0xB8,0x84,0x08,0x11,0xB8,0x00,
+0x00,0x00,0x90,0xB9,0x01,0x0A,0x15,0xB0,0x00,0x11,0x16,0x88,0xF1,0xFF,0x18,0xB8,
+0x83,0x0C,0x18,0x28,0x80,0x0D,0x16,0x7B,0x7C,0x01,0x18,0x38,0x83,0x0C,0x0C,0xAC,
+0x00,0x0C,0x18,0x43,0x00,0x0C,0x20,0xC3,0x00,0x0C,0x30,0x43,0x00,0x0C,0x36,0x43,
+0x00,0x0C,0x36,0x43,0x00,0x0C,0x16,0xC3,0x00,0x0C,0x16,0xC3,0x00,0x0C,0x16,0xC3,
+0x00,0x0C,0x36,0x43,0xA2,0x00,0xA2,0xAB,0xA2,0x00,0x86,0xAB,0xA2,0x00,0xA2,0xAB,
+0x00,0x0C,0x3E,0xC3,0x00,0x0C,0x16,0xC3,0x00,0x0C,0x16,0xC3,0x15,0x11,0x2A,0x80,
+0x06,0x11,0x94,0x81,0x33,0x11,0x95,0x31,0x34,0x11,0x1E,0x5F,0x00,0x0C,0x32,0xC3,
+0x06,0x11,0x94,0x81,0x23,0x11,0x95,0xB1,0x24,0x00,0x14,0x38,0x83,0x3C,0x99,0x28,
+0x04,0x11,0x26,0xDF,0x00,0x11,0x26,0x5F,0x10,0x34,0xC1,0x30,0x00,0x0C,0x32,0xC3,
+0x00,0x0C,0x16,0xC3,0x40,0x11,0x1A,0xDF,0x00,0x0C,0x3A,0x43,0x34,0x10,0x95,0x31,
+0x34,0x11,0x1E,0x5F,0x10,0x01,0xBC,0xB8,0x00,0x0C,0x44,0x43,0x10,0x00,0xBC,0x38,
+0x04,0x3C,0x99,0x30,0x10,0x34,0xC1,0x30,0x02,0x05,0x0A,0x00,0x01,0x4C,0x4B,0x6B,
+0x00,0x11,0x6C,0xDF,0xFD,0x05,0x0A,0x88,0x20,0x13,0x08,0x39,0x05,0x11,0xB8,0x80,
+0x02,0xE4,0xA9,0xEE,0x40,0xCE,0x63,0x6B,0x30,0xCE,0x63,0x7B,0x08,0x4C,0x63,0x6B,
+0x0B,0x0A,0x5D,0xE3,0x04,0x1F,0x63,0xFB,0x00,0x0C,0xCC,0x58,0x88,0xB5,0xAF,0xE8,
+0x80,0xB5,0x6B,0x03,0xB1,0x00,0x06,0xAD,0x00,0x0C,0xCC,0x58,0x0F,0xCB,0xE1,0xEB,
+0x80,0xC8,0xE3,0xEB,0x40,0xCE,0xCF,0x6B,0x30,0xCE,0x8D,0xEB,0x04,0xC9,0xDF,0x6B,
+0x08,0xC9,0xE5,0x6B,0x01,0x85,0xF4,0xEB,0x04,0x85,0x84,0xFB,0xFF,0xC6,0x84,0x6B,
+0x02,0x11,0x64,0x5D,0x00,0x0C,0x76,0xDD,0x02,0x85,0x86,0xEB,0x04,0x11,0x0A,0x81,
+0x04,0xC9,0x93,0x03,0x00,0x0C,0xDE,0x43,0x08,0x5D,0xAE,0x78,0x10,0x11,0x1A,0xDF,
+0x02,0x11,0x0A,0x81,0x00,0x0C,0xB8,0x43,0x20,0xC8,0xA1,0xEB,0x02,0xCA,0xE7,0xEB,
+0x02,0x86,0xF8,0xEB,0x08,0x5D,0xAE,0x78,0x20,0x84,0xF4,0x6B,0x10,0x85,0xAE,0x78,
+0x10,0x11,0x0A,0x81,0x0B,0x0A,0xB9,0xE3,0x01,0x3A,0xB9,0xE3,0xA2,0x00,0x68,0xAD,
+0x02,0x11,0x64,0x5D,0x00,0x0C,0x76,0xDD,0x20,0x84,0xAC,0xEB,0x10,0x85,0xB2,0xFB,
+0x10,0x11,0x0A,0x81,0x00,0x0C,0xD8,0x43,0x04,0xC4,0xF4,0x7B,0x20,0x11,0x08,0x01,
+0x00,0x0C,0xB4,0x43,0x08,0x11,0x64,0x5D,0xB2,0x00,0xC0,0xAD,0x00,0x11,0x10,0x44,
+0xFF,0x03,0xD9,0xF3,0x7F,0x0B,0x15,0x88,0x02,0x02,0x41,0xB0,0x7F,0x0B,0xC5,0x0B,
+0x02,0xEE,0x41,0x30,0x00,0xE2,0xD9,0x63,0x30,0xCE,0xD9,0x6B,0x02,0x02,0xDD,0xB3,
+0x09,0x11,0xF6,0xDC,0x02,0xEE,0x41,0x30,0x00,0x0C,0xE6,0x42,0x08,0x5D,0xAE,0x78,
+0x00,0x11,0x02,0x88,0xDC,0x01,0x1C,0xB8,0xF0,0x11,0x62,0x5F,0x01,0x01,0x22,0xB0,
+0x08,0x4C,0xDD,0x6B,0x04,0x11,0x10,0xC4,0x09,0x11,0x10,0x44,0x00,0x11,0x08,0x44,
+0x0D,0x11,0xE8,0xC3,0x0E,0x11,0xE8,0xC3,0x18,0x11,0xE8,0x43,0x19,0x11,0xE8,0xC3,
+0x80,0xCE,0xED,0xFB,0x16,0x10,0x05,0xF4,0x00,0x0C,0x82,0x5D,0x30,0xCE,0xF3,0x7B,
+0xB2,0x00,0xC0,0xAD,0x02,0x11,0x08,0xC4,0x20,0x01,0x08,0x39,0x1A,0x11,0xFA,0xC3,
+0x25,0x11,0xFA,0xC3,0x30,0xCE,0x05,0xFC,0xB2,0x00,0xC2,0x2D,0xB2,0x00,0xEA,0x2E,
+0xFF,0x4A,0xE7,0x6A,0xB2,0x00,0xC4,0x2D,0x00,0x0C,0x6C,0xDF,0x02,0x11,0x08,0xC4,
+0x01,0x0C,0xD6,0xB3,0x08,0x11,0x64,0x5D,0x01,0xEB,0x19,0xB0,0x20,0xE5,0xCB,0x03,
+0x00,0x0C,0xF6,0xDC,0x00,0x0C,0xD2,0xC4,0x02,0x20,0x14,0x31,0x02,0x20,0xA4,0xB1,
+0x00,0x0C,0xCC,0x58,0x10,0x39,0xAE,0x68,0x02,0x20,0xC4,0x30,0x80,0x49,0x91,0x6C,
+0xC0,0x5F,0x15,0x88,0xC0,0x0A,0x8C,0x74,0xA0,0x48,0x93,0xEC,0x00,0x11,0x94,0x88,
+0x10,0x0B,0x31,0xFC,0x18,0x10,0xA5,0x30,0x18,0x11,0x24,0x01,0x00,0x0C,0x34,0x44,
+0x52,0x11,0x6A,0x5F,0x04,0x11,0x24,0x81,0xB1,0x00,0x8C,0xAC,0x08,0x11,0xB8,0x00,
+0x01,0xC0,0x23,0xB0,0xFF,0x11,0x22,0x20,0xB1,0x00,0x9A,0xAB,0x02,0xE4,0xA9,0xEE,
+0xB1,0x00,0x06,0xAD,0x00,0x0C,0xCC,0x58,0x02,0x05,0x0A,0x00,0x0F,0xCB,0xB5,0xEC,
+0x80,0xC8,0xB7,0xEC,0x80,0x49,0x91,0x6C,0x20,0x48,0xC3,0x6C,0x30,0xCE,0x77,0x6C,
+0xFF,0x58,0x54,0xEC,0x40,0xC9,0xB1,0x6C,0x04,0xC9,0xB1,0x6C,0x08,0xC9,0xB9,0xEC,
+0x01,0x85,0xBE,0xEC,0x04,0x85,0x70,0xFC,0xFF,0xC6,0x70,0x6C,0x80,0xE4,0x93,0x6C,
+0x02,0x11,0x64,0x5D,0x04,0x7F,0x6A,0xEC,0x04,0x11,0x0A,0x81,0x04,0xC9,0x93,0x03,
+0x00,0x0C,0xB0,0x44,0x01,0x11,0xB8,0x00,0x00,0x0C,0xCC,0x58,0x00,0x0C,0x7E,0xC4,
+0xFF,0x58,0xAE,0x68,0x02,0x11,0x0A,0x81,0x00,0x0C,0x7E,0xC4,0xB2,0x00,0x90,0xAD,
+0x20,0xC8,0x85,0x6C,0x02,0xCA,0xBB,0x6C,0x02,0x86,0xBC,0x6C,0x80,0xE5,0x89,0x6C,
+0x80,0xE4,0x93,0x6C,0x00,0x0C,0xAE,0xC0,0x00,0x0C,0x34,0x5F,0x00,0x0C,0xAE,0x44,
+0x00,0x0C,0x4C,0x5F,0x00,0x0C,0x92,0x44,0x20,0x11,0x18,0x5F,0x00,0x0C,0x92,0x44,
+0x06,0x11,0x82,0x5D,0x30,0xCE,0x99,0xFC,0xB2,0x00,0x90,0xAD,0x00,0x0C,0xAE,0x44,
+0xFF,0x05,0xAF,0xF4,0x7F,0x0B,0x15,0x88,0x02,0x04,0x41,0xB0,0x7F,0x0B,0xC5,0x0B,
+0x02,0xEE,0x41,0x30,0x00,0xE2,0xAF,0x64,0x02,0x04,0xDD,0xB3,0x0A,0x11,0xF6,0xDC,
+0x00,0x00,0xC8,0xBB,0x02,0xEE,0x41,0x30,0x00,0x0C,0x14,0xC4,0x05,0x11,0xCA,0xC4,
+0x00,0x0C,0x34,0x5F,0x01,0x11,0xCA,0x44,0x08,0x11,0xC4,0xC4,0x05,0x11,0xC4,0x44,
+0x14,0x11,0xC4,0x44,0x0F,0x11,0xC4,0x44,0x24,0x11,0xC4,0x44,0x03,0x11,0x0A,0x01,
+0x10,0x11,0xC4,0xC4,0x00,0x0C,0xC6,0xC4,0x00,0x0C,0x82,0x5D,0x00,0x0C,0x34,0x5F,
+0x03,0x11,0xCA,0xC4,0x30,0xCE,0xD1,0xFC,0x40,0x9E,0xD1,0x7C,0xB2,0x00,0xC0,0xAD,
+0x00,0x0C,0xF6,0xDC,0xB1,0x00,0x8C,0xAC,0xFF,0xFF,0xDC,0xBB,0x20,0xE5,0xE3,0x6C,
+0xFF,0x8E,0xE3,0x6C,0xFF,0xC1,0xE3,0xF4,0x00,0x0C,0x08,0xDD,0xFF,0xEF,0xE3,0xF4,
+0x02,0xE0,0x0D,0xB4,0x02,0x05,0x0A,0x00,0x7F,0xCA,0x95,0x8B,0x04,0xE4,0xEB,0xFC,
+0xB1,0x00,0xE2,0x29,0x02,0x86,0xEE,0x7C,0x00,0x11,0xB0,0x88,0x02,0x11,0x0C,0x81,
+0x02,0xE6,0xCC,0x01,0x00,0x00,0xC8,0xBB,0x00,0x0C,0xAC,0x40,0x02,0x06,0xD0,0xB3,
+0x02,0x0C,0x0C,0x30,0x10,0x11,0x18,0x5F,0x02,0x06,0x18,0x30,0x00,0x0C,0x30,0xDF,
+0x00,0x0C,0xCC,0x58,0x10,0x49,0xAF,0x68,0xFF,0xFF,0xC4,0xB8,0x02,0xE8,0x0D,0x34,
+0x11,0x11,0x02,0x00,0x02,0x05,0x0A,0x00,0x02,0xC0,0x41,0x30,0x02,0x20,0xDC,0x33,
+0x04,0x4C,0x3F,0x6D,0x80,0x48,0x25,0xFD,0xB2,0x00,0xDA,0x2E,0x02,0xEE,0x15,0xB0,
+0x88,0x20,0x1C,0xAD,0xFF,0xFF,0xDC,0xBB,0x02,0x06,0x41,0x30,0xFF,0x21,0x34,0xF5,
+0xFF,0xEF,0x0F,0xF5,0x00,0x0C,0x12,0x45,0x02,0x06,0x09,0xB2,0xFF,0xFF,0x0C,0xBA,
+0x04,0x11,0x18,0x5F,0x02,0x04,0x41,0xB0,0xFF,0x21,0x34,0xF5,0x04,0x4C,0x13,0x7D,
+0x02,0x20,0x80,0x33,0x00,0x0C,0x36,0x45,0x00,0x0C,0x58,0xDD,0xFF,0xEF,0x53,0xF5,
+0x01,0x11,0xF6,0x03,0x0A,0x02,0xC0,0xBB,0x00,0x0C,0x4A,0xC5,0x00,0x11,0xF6,0x0B,
+0x73,0x01,0xC0,0x3B,0x02,0x06,0x81,0x33,0xFF,0xFF,0x0C,0xBA,0xFF,0xC1,0x4B,0x65,
+0xFF,0xFF,0x84,0x3B,0x02,0xEE,0x41,0x30,0x02,0x46,0x45,0x30,0x00,0x00,0xC8,0xBB,
+0x80,0xCA,0x95,0x03,0x01,0x01,0x22,0xB0,0xFD,0x05,0x0A,0x0C,0x02,0xC0,0x41,0x30,
+0x04,0x10,0x80,0xB7,0xFF,0xC1,0x2D,0x77,0x02,0x06,0xD0,0xB3,0x00,0x0C,0x56,0x5D,
+0x07,0x11,0x30,0x5F,0x02,0xE8,0x0D,0x34,0x01,0x0C,0xB8,0x30,0x02,0x06,0xD0,0xB3,
+0x00,0x0C,0x6C,0x5D,0x02,0xE8,0x0D,0x34,0x01,0x0C,0xD8,0x33,0xB0,0x00,0xC6,0x28,
+0x01,0xEC,0xB9,0x30,0x20,0x5D,0xAE,0xE8,0xA0,0x00,0xD2,0xA8,0x00,0x0C,0xC6,0x58,
+0x05,0x11,0xF6,0x80,0x02,0x78,0x14,0x30,0x00,0x7A,0x14,0x00,0x89,0x10,0xAE,0x28,
+0x00,0x0C,0xD2,0x40,0x80,0xCE,0x87,0xFD,0x80,0x48,0x2D,0x6F,0x00,0x0C,0x6C,0xDF,
+0x80,0x11,0x1A,0xDF,0x80,0xCE,0x91,0xED,0x40,0x9E,0x2D,0xEF,0x40,0x9E,0x3D,0x03,
+0x02,0x06,0xD0,0xB3,0x02,0x20,0xFC,0xB3,0x02,0x08,0xE1,0xB3,0x01,0x4D,0xF9,0x33,
+0xB1,0x00,0x0E,0xAA,0x02,0x0C,0x1C,0x98,0x80,0xCE,0xA3,0xFD,0xF0,0x11,0x26,0x00,
+0x00,0x0C,0xA4,0xC5,0xF1,0x11,0x26,0x80,0x02,0xF0,0x27,0x30,0x01,0xFC,0x27,0x30,
+0x00,0x0A,0x30,0xDF,0x02,0xFE,0x41,0xB0,0x02,0xE8,0x0D,0x34,0xC0,0xD9,0xB0,0x0B,
+0x40,0xD8,0xBF,0x75,0xC0,0xD8,0xBF,0xF5,0xFF,0xD8,0xB9,0x7D,0x40,0x11,0x72,0x84,
+0x30,0xCB,0xB7,0x7D,0x40,0xCB,0x97,0x03,0xBF,0x3D,0x7A,0x0C,0x01,0xCD,0xB7,0x6D,
+0x30,0xCB,0xB7,0xED,0xDB,0x02,0x0C,0xB8,0x20,0xD9,0x7A,0xEE,0x00,0x11,0xB2,0x89,
+0xF0,0xD8,0x14,0x08,0x10,0x0A,0xD0,0x75,0x20,0x0A,0xD4,0xF5,0x00,0x0C,0x78,0x46,
+0x80,0xCF,0xD7,0xED,0x00,0x0C,0x78,0x46,0x40,0xCF,0x79,0xFE,0x0F,0xD8,0x14,0x08,
+0x08,0x0A,0xE0,0x75,0x09,0x0A,0x7C,0x66,0x55,0x11,0x00,0x80,0x01,0x43,0x7D,0x6E,
+0x02,0xC8,0x91,0x03,0x01,0xC8,0x1F,0x7E,0x11,0x11,0x00,0x80,0x02,0xC9,0x01,0x6E,
+0x01,0x96,0x17,0x30,0x01,0x97,0x15,0x30,0x16,0x11,0xB2,0x81,0x01,0xD8,0x1A,0xB0,
+0x01,0xD8,0x18,0x30,0x8A,0x0C,0xFA,0x2D,0xB2,0x00,0xF6,0xAD,0x80,0x0F,0x82,0xEE,
+0x00,0x0C,0x00,0x46,0xA8,0x00,0x18,0xB8,0x00,0x0C,0x84,0x5E,0xFF,0x0A,0x82,0xFE,
+0xB1,0x00,0x00,0xAD,0x84,0x01,0x18,0xB8,0x00,0x0C,0x84,0x5E,0x01,0x0A,0x20,0xE6,
+0x00,0x11,0xB2,0x89,0xF0,0xD8,0xB0,0x8B,0x80,0xD8,0xA5,0x8B,0x70,0xD8,0xB1,0x8B,
+0x70,0x0B,0x15,0x88,0x00,0xD8,0x21,0xE6,0x80,0x80,0x1B,0xFE,0xFF,0xD2,0x21,0x6E,
+0x00,0x0C,0x1C,0xC6,0x80,0xD2,0x21,0x66,0x20,0xD8,0x21,0xF6,0x80,0xC9,0x93,0x03,
+0x00,0x11,0xB2,0x89,0xF0,0xD8,0x14,0x08,0x80,0x0A,0xB0,0x0B,0x30,0x0A,0x14,0x08,
+0x80,0xD8,0x2D,0xEE,0x80,0x0A,0x14,0x00,0x01,0xD8,0x34,0x6E,0x55,0x11,0x00,0x80,
+0x01,0x43,0x35,0x6E,0x08,0x0A,0x14,0x00,0x00,0x11,0x00,0x08,0x01,0x0A,0xA4,0xB3,
+0x01,0xD8,0x46,0xB0,0x01,0xD8,0x44,0x30,0xFE,0xFF,0x14,0xB8,0x8B,0x22,0x78,0xAE,
+0x02,0x22,0x18,0x30,0x02,0xEE,0x15,0xB0,0xB2,0x00,0xF6,0xAD,0x80,0x0F,0x78,0x7E,
+0xFE,0x8F,0x4D,0x76,0xFD,0x8F,0x79,0x66,0x84,0x01,0x18,0xB8,0x00,0x0C,0x84,0x5E,
+0x01,0x0A,0x78,0x66,0x20,0xD2,0x5B,0xFE,0x20,0x9E,0x77,0x6E,0x40,0x9D,0x5B,0x7E,
+0x02,0x9E,0x79,0x7E,0x00,0x11,0x7E,0x0B,0x08,0xD2,0x41,0x09,0x01,0xD2,0x15,0xB0,
+0xB1,0x00,0x2A,0xA9,0x34,0x11,0x66,0x5F,0xB1,0x00,0x00,0xAB,0xB1,0x00,0x4A,0xA9,
+0xFE,0xC8,0x91,0x8B,0xB1,0x00,0xE2,0x29,0x80,0xCA,0x71,0xEE,0xA2,0x00,0xE2,0x2D,
+0xB1,0x00,0x98,0xAC,0x85,0x03,0xC0,0xBB,0x40,0xCA,0x95,0x87,0x4F,0x11,0x7E,0xC6,
+0x44,0x11,0x7E,0x46,0x51,0x11,0x7E,0xC6,0x41,0x11,0x7E,0x46,0x7F,0xC9,0x93,0x8B,
+0x00,0x0C,0x66,0xDF,0xFD,0xC8,0x91,0x0F,0x0C,0x11,0xB2,0x01,0x01,0x12,0x14,0x30,
+0x00,0xD8,0x90,0xE6,0x1F,0xD9,0x14,0x08,0x14,0x0A,0x86,0x66,0x01,0x11,0x14,0x84,
+0xFF,0xD9,0xB2,0x99,0xFF,0x0C,0x18,0x98,0xFF,0x12,0x14,0x10,0xFF,0x11,0x16,0x00,
+0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,0x01,0xD8,0xB0,0xB3,0x00,0x11,0xB2,0x0B,
+0x83,0xD8,0x15,0xA8,0x80,0x0B,0xA6,0x6E,0x02,0x11,0x14,0x84,0x00,0x11,0x14,0x8C,
+0x00,0x0C,0xCC,0x58,0x02,0x05,0x0A,0x00,0x0F,0xCB,0xCB,0x6E,0x80,0xC8,0xCD,0xEE,
+0x01,0xC9,0xEF,0x6E,0x80,0xC9,0xBD,0xEE,0x02,0xC8,0xC5,0x6E,0xEB,0x11,0x2E,0xDF,
+0x00,0x0C,0xAE,0x50,0x03,0x11,0xCE,0xC6,0xFD,0x05,0x0A,0x88,0xFD,0xE4,0xC9,0x8B,
+0xFF,0xFB,0x53,0x7B,0x00,0x0C,0x40,0x44,0xFD,0x05,0x0A,0x88,0xFD,0x9E,0x3D,0x8B,
+0x00,0xFB,0x09,0x44,0x09,0x11,0xCE,0xC6,0x12,0x11,0xCE,0xC6,0x00,0x0C,0x6C,0xDF,
+0xFD,0x05,0x0A,0x88,0xB1,0x00,0x00,0xAD,0xB1,0x00,0xC4,0xAA,0x22,0x11,0x02,0x00,
+0xE8,0x11,0x64,0x5F,0x01,0x01,0x22,0xB0,0xB1,0x00,0x00,0xAB,0x00,0x0C,0xEE,0xCE,
+0x00,0x0C,0xCC,0x58,0x80,0xC8,0xEF,0xEE,0x22,0x11,0x02,0x00,0xEB,0x11,0x2E,0xDF,
+0x01,0x01,0x22,0xB0,0x00,0x0C,0xAE,0x50,0x01,0x9E,0x3D,0x03,0xF7,0xA0,0x40,0x89,
+0xFD,0x9E,0x3D,0x8B,0x00,0x00,0x90,0x3B,0xC0,0xCA,0x95,0x0B,0x40,0x3D,0x7A,0x00,
+0xB2,0x00,0x10,0x2E,0x04,0xE4,0xC9,0x03,0x02,0xFB,0x09,0xC4,0x00,0x0C,0xCC,0x58,
+0x0F,0xCB,0xCB,0x6E,0x02,0x7C,0xAE,0x78,0x02,0xE4,0xC9,0x03,0xFF,0xFB,0xE7,0xFA,
+0x00,0x0C,0x14,0xC4,0x00,0x0C,0xCC,0x58,0x80,0xCA,0xAF,0xE8,0xB2,0x00,0xE2,0xAD,
+0x00,0x0C,0x60,0xC2,0x0F,0x00,0x14,0x08,0x00,0x11,0x16,0x88,0x83,0x0C,0x0C,0xAC,
+0xA2,0x00,0x58,0xAE,0xA2,0x00,0x5C,0x2E,0xA2,0x00,0x82,0x2E,0x01,0x0C,0x98,0xB0,
+0x03,0x11,0x9A,0xB0,0x01,0x0C,0x14,0x30,0x04,0x11,0x26,0xC7,0x01,0x0C,0xF6,0x30,
+0x01,0x0A,0xF0,0x30,0x02,0x11,0xF2,0x34,0xFF,0x11,0x22,0x8C,0xA1,0x00,0x80,0x2A,
+0xA1,0x00,0xD0,0x29,0xA2,0x00,0x56,0x2D,0x20,0xE5,0xCB,0x03,0x80,0xE4,0x2D,0x6F,
+0x08,0x5D,0x2C,0x6F,0x02,0x11,0xB8,0x00,0x02,0x06,0xD0,0xB3,0x02,0x11,0x6C,0xDD,
+0x02,0xE8,0x0D,0xB0,0x05,0x11,0xB8,0x80,0x80,0x11,0xB8,0x00,0x00,0x0C,0xC6,0x58,
+0x80,0xE4,0xAF,0x78,0xA0,0x00,0xD2,0xA8,0x80,0xE4,0x2D,0x6F,0x08,0x5D,0x2C,0x6F,
+0x80,0xE5,0x55,0xEF,0xC0,0x11,0x5A,0xDF,0xB0,0x00,0xC6,0x28,0x80,0xE4,0xAF,0x78,
+0xA0,0x00,0xD2,0xA8,0xFF,0x00,0x60,0xEF,0x00,0x11,0x86,0x09,0x40,0x11,0x90,0x00,
+0x01,0x0C,0xB8,0xB4,0xA1,0x00,0x70,0x2A,0xA1,0x00,0x6E,0x2A,0xA1,0x00,0xCE,0x2A,
+0x01,0x11,0x22,0x9C,0xA2,0x00,0xCC,0x2B,0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,
+0x02,0x05,0x0A,0x00,0x02,0x4C,0x15,0x30,0x01,0x0A,0x04,0x80,0x01,0x0C,0x06,0x30,
+0xE0,0x4C,0x7D,0x2F,0x00,0x0C,0x80,0x47,0x02,0x4C,0x99,0x32,0x00,0x0C,0x72,0xC7,
+0x01,0x06,0x0A,0x30,0x01,0x06,0x22,0x30,0xFF,0x11,0x22,0x8C,0x02,0x48,0x15,0xB0,
+0x02,0x0B,0x86,0x6F,0x01,0x0A,0x04,0xB0,0x02,0x0B,0x06,0x80,0xE0,0x48,0x93,0xAF,
+0xFF,0x11,0x22,0x8C,0x02,0x48,0x91,0x32,0x00,0x0C,0x86,0x47,0xFF,0xFD,0x18,0xB8,
+0xA2,0x00,0x70,0xAE,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x0C,0x0C,0x40,0xFD,0x05,0x0A,0x88,0x00,0x04,0xC0,0xBB,0x00,0x0C,0x56,0x40,
+0x00,0x04,0xC0,0xBB,0x00,0x0C,0xF8,0x44,0x02,0x05,0x0A,0x00,0xEF,0x11,0x80,0xDA,
+0x00,0x0C,0x2A,0x50,0xEF,0x11,0xA2,0xDA,0x02,0xCB,0x97,0x03,0x30,0xCB,0x2B,0xE8,
+0xFD,0x05,0x0A,0x88,0x00,0x0C,0x0E,0x5A,0x02,0x0C,0x1C,0x98,0x20,0xC6,0x27,0x00,
+0x00,0x11,0x26,0x88,0x00,0x0A,0xD0,0x59,0x02,0x05,0x0A,0x00,0x00,0x0C,0x2A,0x5F,
+0x22,0x11,0x00,0x80,0x02,0x05,0x0A,0x00,0x10,0xE4,0x41,0x78,0x02,0xCA,0x3D,0x68,
+0x05,0x86,0x40,0xF8,0x18,0x11,0x08,0x81,0x05,0x86,0x40,0xF8,0x08,0x11,0x88,0x00,
+0x18,0xE4,0xC8,0x81,0x00,0x0C,0x3E,0xC0,0xFD,0xCA,0x95,0x8B,0xEF,0xE4,0xC9,0x8B,
+0x30,0x45,0x02,0xF8,0xF3,0x11,0x9C,0xDA,0x00,0x0C,0x02,0x50,0xC4,0x01,0x1C,0xB8,
+0xF3,0x11,0x82,0xDA,0x00,0x0C,0x50,0xD0,0xB2,0x00,0xBC,0x2D,0x00,0x0C,0x52,0xC0,
+0x08,0x44,0x02,0x68,0xF3,0x11,0xA2,0x5A,0x00,0x0C,0x02,0xC0,0x02,0x05,0x0A,0x00,
+0x04,0x04,0x0C,0x38,0x01,0xCD,0x29,0xF9,0x80,0xCA,0xF3,0x6C,0x0F,0xCB,0xC7,0x68,
+0x10,0x45,0x1A,0x69,0x40,0xC8,0xB5,0xE8,0x80,0xC8,0xA9,0x68,0x10,0xC8,0xA1,0xE8,
+0x40,0xCE,0xD3,0xE8,0x20,0xCE,0xD9,0xE8,0x04,0xC8,0x8F,0xE8,0x04,0xC9,0x75,0xF8,
+0x59,0x11,0xCC,0xDA,0x08,0x11,0x8A,0x40,0x08,0xC9,0x7B,0x78,0x58,0x11,0xCC,0x5A,
+0x04,0x11,0x8A,0x40,0xFF,0x8E,0x87,0x68,0xFF,0xC1,0x23,0x61,0x40,0x83,0xF2,0x6C,
+0x01,0xC8,0x87,0x68,0x08,0xC8,0x87,0x68,0x40,0xC9,0xF3,0xFC,0x5A,0x11,0xCC,0xDA,
+0x00,0x11,0x8A,0xC0,0xB1,0x00,0xB6,0xAF,0x01,0x0C,0xE4,0x81,0x08,0xC8,0x95,0x68,
+0x20,0xC9,0xF3,0xFC,0x00,0x0C,0xAC,0x40,0x02,0x11,0xE4,0x81,0xB1,0x00,0xB6,0xAF,
+0x00,0x0C,0x54,0x59,0x00,0x0C,0xAE,0x5A,0x20,0xC8,0xC9,0x68,0xE4,0x11,0x6E,0x42,
+0x20,0xC8,0xC9,0x68,0xE7,0x11,0x80,0x5A,0x00,0x0C,0xF2,0xD4,0x00,0x0C,0xAC,0x40,
+0x40,0x39,0xAC,0x78,0x40,0x11,0x72,0x00,0x00,0x0C,0x54,0x59,0x00,0x0C,0xC4,0x5A,
+0x80,0xC8,0xBD,0x68,0xE8,0x11,0x6E,0x42,0x80,0xC8,0xBD,0x68,0xEB,0x11,0x80,0x5A,
+0x00,0x0C,0xF2,0xD4,0x01,0x9E,0x3D,0x03,0x03,0xC8,0x91,0x0B,0xF0,0x08,0x04,0xB9,
+0x03,0x11,0x0E,0x81,0xBF,0xC9,0x93,0x8B,0x00,0x0C,0xC8,0xC0,0x00,0x0C,0x54,0x59,
+0x40,0xCA,0xF3,0x6C,0x02,0x06,0x22,0x30,0xB0,0x00,0x5A,0x2D,0x00,0x0C,0x76,0x59,
+0x00,0x0C,0x08,0xC0,0x40,0xCA,0xF3,0x6C,0x10,0xC9,0xAD,0x68,0x00,0x0C,0x98,0xC0,
+0x80,0x83,0x00,0xE9,0x02,0xCA,0x13,0xE9,0x02,0xA1,0x0E,0x69,0x20,0xC8,0x0B,0x69,
+0xFF,0xC1,0x17,0xE1,0x02,0x9F,0xF3,0x6C,0x01,0x9F,0xED,0x78,0xB2,0x00,0x96,0xAD,
+0x00,0x0C,0xF2,0xCC,0x00,0x0C,0x0A,0xC1,0xE3,0x11,0x9C,0x5A,0x00,0x0C,0xF6,0xC8,
+0x80,0x11,0x0E,0x01,0xC8,0x01,0x1C,0xB8,0xE0,0x11,0x70,0xC2,0x80,0x87,0x00,0x69,
+0x13,0x00,0xE0,0xB9,0xFF,0x11,0x22,0x20,0xFF,0xE8,0x00,0xE9,0x04,0x86,0x04,0xF9,
+0xFD,0xA1,0x42,0x89,0xE3,0x11,0xA2,0xC2,0xC8,0x01,0x1C,0xB8,0xE3,0x11,0x82,0x5A,
+0x00,0x0C,0xF2,0xD4,0xE3,0x11,0xA2,0xDA,0x02,0xA1,0x42,0x01,0x04,0xA1,0xF2,0xFC,
+0x00,0x0C,0x98,0xC0,0xB2,0x00,0x78,0xAD,0x00,0x0C,0xAC,0x40,0xE3,0x11,0xA2,0xDA,
+0x00,0x0C,0x22,0xC1,0xB2,0x00,0x96,0xAD,0x00,0x0C,0xC6,0xD0,0x02,0xCA,0x25,0xE9,
+0xFF,0xC1,0xF3,0x74,0xA0,0x00,0x08,0x2D,0xB2,0x00,0x78,0xAD,0x00,0x0C,0xC6,0x40,
+0xA0,0x00,0x5A,0xAD,0x30,0x0A,0x18,0x08,0xFF,0x0C,0x34,0xF9,0x20,0x0C,0x36,0x71,
+0x30,0x0C,0x3C,0xF1,0x20,0x11,0x40,0xC1,0x10,0x11,0x40,0xC1,0x08,0x11,0x4E,0x59,
+0x20,0x9E,0x3D,0x03,0x00,0x0C,0x3E,0x41,0x00,0x11,0x4E,0xD9,0x40,0x11,0x40,0xC1,
+0x00,0x11,0x02,0x88,0x01,0x0C,0x8C,0x31,0x01,0x01,0x22,0xB0,0x01,0x0A,0x40,0x31,
+0x01,0x0A,0xF2,0x7C,0x02,0xA0,0x98,0xB3,0x01,0x45,0x9C,0x37,0x11,0x11,0x02,0x00,
+0x01,0x0C,0x96,0x30,0x01,0x01,0x22,0x34,0x01,0xA1,0xF2,0xFC,0x10,0x45,0xF2,0x6C,
+0x20,0x45,0x5E,0x69,0x00,0x0C,0x62,0x59,0x01,0x11,0x4E,0x41,0x0A,0x11,0x4E,0xD9,
+0x1F,0x11,0x6A,0x59,0x08,0xA0,0x14,0x88,0x02,0x0A,0x14,0x00,0x00,0x11,0x16,0x88,
+0x02,0x0A,0x40,0xB5,0x11,0x11,0x02,0x00,0x01,0x0C,0x90,0x30,0x01,0x01,0x22,0x34,
+0xFF,0x11,0x6A,0xD9,0xF7,0xA0,0x40,0x89,0x01,0x11,0x4E,0x41,0x02,0x05,0x0A,0x00,
+0x20,0xCA,0x7D,0xF9,0xFD,0x9E,0x3D,0x8B,0xDF,0x9E,0x3D,0x8B,0x03,0x11,0x90,0xB3,
+0x10,0x45,0x88,0xE9,0x00,0x00,0x98,0xBB,0x00,0x11,0x9C,0x0B,0x00,0x0C,0x94,0x41,
+0x00,0x11,0x02,0x88,0xF7,0x5E,0xBC,0x88,0x40,0x11,0x90,0x00,0x00,0x11,0x86,0x09,
+0x01,0x01,0x22,0xB0,0xFE,0xCD,0x9B,0x8B,0x40,0x3D,0x7A,0x00,0xB2,0x00,0x1C,0x2E,
+0x00,0x0C,0xE2,0xD9,0xFD,0x05,0x0A,0x0C,0xFD,0x4D,0x9B,0x8A,0x00,0x0C,0xAA,0xD9,
+0x55,0x11,0x02,0x00,0x92,0x11,0xAC,0x82,0x02,0x4D,0x9B,0x02,0x02,0x5B,0xB7,0x02,
+0x01,0x01,0x22,0x34,0x10,0xC7,0xF3,0x7C,0x10,0x45,0xF2,0x6C,0x20,0xCE,0xF3,0xEC,
+0x02,0xFE,0x15,0x30,0x83,0x10,0xFC,0xAB,0x89,0x10,0xF2,0xAC,0x02,0xFC,0xFD,0xB3,
+0x30,0x11,0xCE,0x42,0x02,0x06,0xD0,0xB3,0xB0,0x00,0xCC,0x28,0x80,0x5D,0xF8,0xFC,
+0xFF,0x4D,0xC7,0x69,0x0E,0x11,0xD0,0xD9,0x02,0xE8,0x0D,0x34,0x0D,0x11,0xD0,0xD9,
+0x30,0xCE,0xCF,0xF9,0x40,0x9E,0xCF,0x79,0xB2,0x00,0xC0,0xAD,0x02,0xE8,0x0D,0x34,
+0x01,0x0C,0xD6,0xB3,0x02,0x20,0xD8,0xB3,0xB0,0x00,0xC6,0x28,0x02,0x05,0x0A,0x00,
+0x04,0x3A,0xF8,0x7C,0x01,0xEB,0x69,0x30,0x00,0x11,0x6A,0x08,0x02,0xEC,0x6D,0x30,
+0xA0,0x00,0xD0,0x28,0x02,0x22,0x0C,0x30,0x00,0x00,0x44,0x38,0x44,0xC6,0x0F,0xA8,
+0x01,0x07,0x1C,0x30,0x02,0xAE,0x19,0x30,0xFF,0x0E,0x14,0x90,0xFF,0x0E,0x16,0x10,
+0x81,0x0C,0x04,0x28,0x01,0x0E,0x14,0xB0,0x0F,0xCB,0xF9,0x69,0x00,0x03,0x06,0x80,
+0xFF,0xC8,0x03,0x6A,0xFF,0xC9,0x03,0xEA,0xFF,0xCA,0x03,0xEA,0xF0,0xCB,0x03,0x6A,
+0x00,0x02,0x04,0x80,0x02,0x0C,0x14,0x30,0xE1,0xAE,0x0B,0x2A,0x02,0x06,0x44,0x30,
+0xFF,0x11,0x22,0x8C,0x02,0xAE,0x5D,0x33,0x00,0x0C,0xEA,0x41,0xB0,0x00,0xC6,0x28,
+0x02,0x05,0x0A,0x00,0x04,0x3A,0xF8,0x7C,0x11,0x00,0x68,0xB8,0x00,0x00,0x6C,0x38,
+0xFD,0x05,0x0A,0x88,0xB0,0x00,0xCC,0x28,0x02,0x11,0x48,0x00,0xFF,0xCE,0x25,0xEA,
+0x00,0x11,0x48,0x08,0x00,0x0C,0xF8,0x44,0xC8,0xCC,0x19,0x98,0x01,0x11,0x1A,0x80,
+0x01,0x12,0x16,0xB0,0x11,0xCC,0x15,0x28,0x03,0x0C,0x98,0x8B,0xFF,0xCE,0x9D,0x9B,
+0xC0,0x0A,0x18,0x98,0x02,0x0C,0x1C,0xB0,0x02,0x12,0x40,0xB0,0xFF,0xFF,0x26,0xB8,
+0x00,0x11,0x48,0x08,0x01,0x0B,0x14,0xB0,0x44,0x0A,0x18,0xA8,0x02,0x0C,0x1C,0xB0,
+0xA0,0x00,0xD2,0xA8,0x02,0x0C,0x0C,0x30,0x08,0x0C,0x18,0x18,0x02,0x12,0x1C,0xB0,
+0x02,0x0A,0x0C,0x30,0x82,0x10,0x14,0x28,0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,
+0x83,0x0E,0x1C,0x28,0x02,0x06,0x14,0x30,0x80,0x0F,0x5A,0xFA,0xFE,0x0C,0x18,0x18,
+0x02,0x12,0x14,0x30,0x02,0x06,0x18,0x30,0xFF,0x11,0x22,0x8C,0x08,0x0C,0x1C,0x98,
+0x01,0x0D,0x1E,0xB0,0x02,0x0A,0x26,0xB0,0x00,0x00,0x26,0xB8,0x10,0x12,0xC0,0x30,
+0xF0,0x0C,0x18,0x98,0x20,0x00,0xBC,0x38,0x49,0x11,0xB8,0x84,0xD4,0x01,0x1C,0x38,
+0x01,0x0E,0x1A,0x30,0x01,0x0C,0x1C,0xB0,0x01,0x0D,0x18,0xB0,0x03,0x11,0x48,0x80,
+0x00,0x0C,0xAA,0xDA,0x04,0x12,0x50,0x30,0x04,0x28,0x26,0xB0,0x00,0x00,0x48,0xBC,
+0xD4,0x01,0x1C,0x38,0x03,0x11,0x48,0x80,0x00,0x0C,0xAA,0xDA,0x11,0x12,0x22,0xA8,
+0x00,0x0C,0x9A,0x52,0x02,0x0C,0x0C,0x30,0x02,0x0E,0x18,0xB0,0x04,0x12,0x50,0x30,
+0x02,0x06,0x18,0x30,0xFC,0x0C,0x18,0x98,0x04,0x12,0x50,0x30,0xFF,0x11,0x22,0x20,
+0x11,0x2B,0x22,0xA8,0x00,0x00,0x48,0xBC,0x00,0x0C,0xAA,0xDA,0x11,0x12,0x22,0xA8,
+0x00,0x11,0x4A,0x0C,0x00,0x0C,0xAA,0xDA,0x02,0x0C,0x1C,0xB0,0x00,0x11,0x26,0x88,
+0x00,0x11,0x4A,0x0C,0x02,0x11,0x4A,0x80,0x01,0x11,0x1A,0x04,0x10,0x30,0x14,0xB8,
+0x00,0x0C,0xB0,0x5C,0x20,0xCE,0xBF,0xFA,0x20,0x9D,0xBF,0xFA,0xB2,0x00,0x96,0xAD,
+0x00,0x0C,0xBE,0x4A,0x20,0xCA,0x95,0x03,0x28,0x11,0xC0,0xC2,0x29,0x11,0xC0,0x42,
+0x00,0x0C,0xD2,0xDA,0x00,0x0C,0x70,0x41,0x40,0xC0,0x14,0xB8,0x00,0x0C,0xB0,0x5C,
+0x1C,0x11,0xD6,0xDA,0x00,0x0C,0x70,0x41,0x04,0xC8,0x91,0x03,0x01,0x0C,0x14,0x30,
+0x10,0x11,0xE2,0x42,0x01,0x0C,0x14,0x30,0x30,0x11,0xE2,0xC2,0x01,0x0C,0x14,0x30,
+0x60,0x11,0xE2,0xC2,0x01,0x0C,0x14,0x30,0x20,0x11,0xE2,0x42,0x01,0x0C,0x14,0x30,
+0x24,0x11,0xE2,0xC2,0x01,0x05,0x16,0xB0,0x02,0x05,0x0A,0x00,0x02,0xCA,0xED,0x6A,
+0xF0,0x44,0xEE,0xEA,0x08,0x44,0xF2,0x7A,0x08,0x11,0x88,0x00,0x00,0x0C,0x00,0x5B,
+0x00,0x0C,0xFE,0xCA,0x01,0x0A,0xB6,0x31,0x04,0xDC,0x80,0x30,0x30,0xCE,0xFB,0x7A,
+0x02,0x0C,0xFC,0x42,0x01,0x0C,0x18,0x00,0x01,0x0C,0x88,0x30,0x01,0x0B,0x0A,0x34,
+0x08,0x44,0xEC,0x7C,0x0B,0xCB,0x0D,0xEB,0x55,0x11,0x02,0x00,0x40,0x4E,0x1B,0x88,
+0x01,0x01,0x22,0xB0,0xFF,0x0D,0x00,0x7B,0x08,0x11,0x88,0x00,0x01,0x10,0x22,0x1C,
+0x01,0x39,0x16,0x6B,0x02,0x39,0x30,0xEB,0xFF,0x11,0x22,0x8C,0xFF,0x65,0x20,0x7B,
+0xBF,0xE4,0xC9,0x8B,0x0F,0x53,0xC0,0xB0,0x01,0x53,0xFA,0x33,0x00,0x0C,0x28,0x43,
+0x80,0x5B,0x2C,0x7B,0x40,0xE4,0x2D,0xEB,0x40,0xE4,0xC9,0x03,0x0F,0x11,0xC0,0xB0,
+0x01,0xFD,0xC1,0x30,0x01,0x11,0x72,0x84,0x10,0x53,0xC0,0x30,0x01,0x11,0x72,0x84,
+0x04,0x67,0x14,0x08,0x80,0x5B,0x3A,0x6B,0x08,0x68,0xB0,0x33,0x30,0x67,0xA4,0x0B,
+0x00,0x0C,0x44,0x43,0x08,0x53,0xB0,0xB3,0x07,0x53,0x22,0x30,0x30,0x53,0xA4,0x8B,
+0x08,0xD8,0xD1,0x30,0x00,0xD2,0xCF,0x80,0xFF,0x67,0xCE,0x08,0x80,0x11,0xCC,0x00,
+0x05,0x11,0xB4,0x80,0x01,0x11,0x4A,0x80,0x22,0x0A,0x1C,0x28,0xE0,0x0E,0x1C,0x18,
+0x01,0x11,0x1E,0xA0,0x08,0xD8,0x27,0x30,0x07,0x11,0x26,0xB0,0x01,0xD2,0x27,0xB4,
+0x40,0x11,0xFA,0x5C,0x00,0x0C,0xD8,0x5B,0xFF,0x00,0xF2,0x6C,0x30,0xCE,0xF3,0xFC,
+0x40,0x11,0x90,0x84,0x08,0x49,0x75,0xEB,0x40,0x49,0x73,0xEB,0x80,0x48,0x75,0x6B,
+0xB2,0x00,0xBC,0x2E,0x00,0x0C,0x74,0xCB,0x00,0x0C,0x9A,0x5B,0xB8,0x00,0xC0,0x3B,
+0x40,0xCA,0x95,0x87,0x20,0x11,0xFA,0x5C,0x00,0x0C,0x96,0x5B,0x80,0x4C,0xF3,0x7C,
+0xB2,0x00,0xBC,0x2E,0x00,0x0C,0xF2,0xCC,0xD4,0x00,0xC0,0x3B,0x40,0xCA,0x95,0x87,
+0x00,0x0C,0x96,0x5B,0x80,0x11,0xFA,0x5C,0x80,0xCE,0x8B,0xFB,0x80,0x48,0xF3,0x6C,
+0x00,0x0C,0x8C,0xC3,0x40,0x9E,0xF3,0xEC,0x00,0x0C,0x98,0x5C,0x80,0xE1,0xF3,0xFC,
+0xB2,0x00,0xBC,0x2E,0x00,0x0C,0xA2,0xCC,0x00,0x0C,0x6E,0xC3,0x00,0x0C,0xF4,0x5C,
+0x18,0x11,0xB8,0x04,0x04,0x40,0x99,0xB0,0x04,0x0C,0xE1,0x30,0x04,0x24,0x31,0x31,
+0x20,0x10,0xBC,0xB8,0x11,0x00,0xAC,0x73,0x20,0x0B,0xB1,0xFB,0xF0,0x04,0x14,0x88,
+0x60,0x0A,0xB0,0xF3,0x20,0x11,0xB2,0xC3,0x01,0xCD,0xB1,0x6B,0x05,0x11,0xB2,0x43,
+0x00,0x11,0xB2,0x43,0x01,0x05,0x14,0x30,0x82,0x05,0x0A,0x80,0x30,0x50,0xC1,0x30,
+0x01,0x0C,0xB8,0x30,0x01,0x0A,0x0A,0x30,0x40,0xE4,0xC9,0x03,0x20,0x0C,0xC2,0xE3,
+0x02,0xC3,0x86,0x01,0x40,0x61,0xF2,0x6C,0x5F,0x01,0x18,0xB8,0x80,0x5F,0xCB,0x6B,
+0x6F,0x01,0x18,0xB8,0x04,0x12,0x1C,0x08,0x22,0x0E,0x1C,0xA8,0xE0,0x0E,0x1C,0x18,
+0x01,0x11,0x1E,0xA0,0x01,0x11,0x4A,0x80,0x10,0x12,0x26,0xB0,0x00,0x11,0x4A,0x0C,
+0x40,0x61,0xDE,0xFB,0x30,0x60,0xA0,0x32,0x00,0x0C,0xF0,0x43,0x20,0x60,0xA0,0xB2,
+0x80,0x6F,0xDF,0x02,0x04,0x6F,0x19,0x08,0x22,0x0C,0x18,0xA8,0xE0,0x0C,0x18,0x18,
+0x01,0x11,0x1A,0x20,0x01,0x11,0x4A,0x80,0x10,0x12,0xE0,0x32,0x00,0x11,0x4A,0x88,
+0x11,0x00,0x0A,0xF4,0x30,0xCE,0x0B,0x7C,0x0C,0x3F,0x01,0xFC,0x01,0x7F,0x00,0x7C,
+0x0C,0x3F,0xB1,0x0B,0x2E,0xD8,0xB1,0xAB,0x03,0x11,0xB2,0xB3,0x04,0xD8,0xE1,0x30,
+0x03,0x3F,0x0B,0xFC,0x01,0x93,0x0A,0xFC,0x03,0x3F,0xB1,0x0B,0x03,0x11,0xB2,0xB3,
+0x04,0xD8,0x99,0x30,0x04,0x70,0x18,0x32,0x04,0x98,0x48,0x32,0x04,0x4C,0x80,0xB2,
+0x11,0x00,0x2A,0x74,0x08,0x5E,0x16,0xFC,0x00,0x0C,0x18,0xC4,0x01,0x7F,0x1C,0xFC,
+0x20,0x11,0xFA,0x5C,0x00,0x0C,0xF4,0x5C,0xFF,0xFF,0xC4,0xB8,0x00,0x0C,0x96,0xDC,
+0x01,0x93,0x14,0x30,0x48,0x11,0xB8,0x80,0x30,0xCE,0x3F,0xFC,0x02,0x0A,0x3E,0x7C,
+0x00,0x0C,0x3C,0xC4,0x01,0x7F,0x14,0xB0,0x08,0x11,0xB8,0x00,0x04,0x0A,0x36,0x6C,
+0x40,0x49,0x3F,0x7C,0x80,0x11,0xFA,0x5C,0x00,0x0C,0x3E,0x44,0xFF,0xFB,0x18,0xB8,
+0xB2,0x00,0x70,0x2E,0x30,0xCE,0x3F,0xFC,0xB2,0x00,0xCA,0x2C,0x80,0xE4,0xC9,0x87,
+0x80,0xCE,0x4B,0x7C,0x40,0x48,0x4B,0xFC,0xBF,0xFF,0x18,0xB8,0xB2,0x00,0x70,0x2E,
+0x00,0x0C,0x50,0xC4,0x40,0x01,0x18,0x38,0xB2,0x00,0xCE,0x2D,0x00,0x0C,0x58,0xCC,
+0x94,0x00,0x18,0xB8,0xB2,0x00,0xCE,0x2D,0x00,0x0C,0x58,0xD4,0x04,0x94,0x80,0x36,
+0x80,0x11,0xFA,0x44,0x04,0x10,0x80,0xB2,0xB2,0x00,0xBC,0x2E,0x00,0x0C,0xF2,0xCC,
+0xFF,0xFF,0x0C,0xBA,0xFF,0xC1,0x69,0xE4,0x02,0x20,0x80,0x33,0x02,0x20,0x84,0x37,
+0x02,0x20,0xB0,0x33,0x02,0xC2,0x41,0xB0,0x02,0xD8,0x0D,0x32,0x02,0xD8,0x85,0xB3,
+0x02,0xD8,0x41,0xB4,0x08,0x39,0x80,0xEC,0x04,0x39,0x7A,0xEC,0x10,0x3A,0x7A,0xEC,
+0xFF,0x11,0x22,0x8C,0x00,0x0C,0xD8,0x5B,0x04,0x11,0x72,0x00,0x10,0x11,0x74,0x84,
+0xFF,0xFF,0x14,0x38,0x8A,0x62,0x8A,0xAC,0xC0,0x11,0x18,0x80,0xB0,0x00,0x5A,0xAF,
+0x80,0xE5,0xCB,0x03,0x08,0x11,0x72,0x84,0xB0,0x00,0xC6,0x28,0x0F,0x00,0x14,0x08,
+0x01,0x0A,0x14,0x18,0x00,0x7C,0xF8,0x7C,0xA0,0x00,0xD2,0xA8,0x80,0xE1,0xF3,0x6C,
+0x08,0xE4,0xF3,0x6C,0x04,0x3C,0xEC,0xB3,0x00,0x11,0x78,0x08,0x5F,0x3D,0x7A,0x08,
+0x08,0xE4,0xC9,0x87,0x02,0x05,0x0A,0x00,0x08,0xE4,0xF3,0xFC,0x40,0x3D,0x14,0x08,
+0xBF,0xF7,0xEF,0x8B,0x00,0xF7,0xEF,0x83,0x04,0xF6,0x79,0xB0,0xF7,0xE4,0xC9,0x0F,
+0x02,0x05,0x0A,0x00,0x00,0xC8,0x91,0x83,0x01,0x0B,0x14,0xB0,0x00,0xC8,0x17,0x88,
+0x00,0x0B,0xBC,0x64,0xBF,0x3D,0x7A,0x88,0xA2,0x00,0xFA,0x2E,0x00,0x0C,0xD4,0xDC,
+0x00,0x0C,0xF2,0xCC,0xC0,0xC8,0xEF,0xEC,0x80,0xCE,0xCF,0x7C,0x08,0xC8,0xEF,0x6C,
+0x80,0xCC,0xD3,0x7C,0x10,0x48,0xEF,0x7C,0x01,0x11,0x22,0x9C,0x60,0xCE,0xD3,0x7C,
+0x20,0xC8,0xEF,0x6C,0x01,0x11,0x22,0x9C,0x02,0x20,0x18,0xB0,0x02,0xF4,0x15,0x30,
+0xB2,0x00,0xF6,0xAD,0x80,0x0F,0xEE,0xFC,0xFF,0x20,0xE0,0x64,0xF0,0x21,0xEE,0x7C,
+0xFF,0x0A,0xEF,0x74,0xC0,0x0A,0x15,0x88,0x80,0x0A,0xEE,0x74,0xC0,0x0A,0xEE,0xF4,
+0x01,0x49,0xEF,0x6C,0x20,0x48,0xEF,0xEC,0x01,0x11,0x22,0x9C,0x01,0x10,0x22,0x1C,
+0xA0,0x00,0x6C,0x2F,0xFF,0x11,0x22,0x8C,0x08,0x5E,0xBC,0x00,0x08,0x11,0xFA,0x44,
+0xA0,0x00,0xAE,0x28,0xA2,0x00,0x58,0xAE,0xFE,0xBA,0x74,0x89,0x02,0x92,0x71,0x31,
+0xFE,0xBA,0x74,0x89,0x02,0xB8,0x2C,0x37,0x80,0xC9,0x93,0x03,0x04,0x5D,0xF2,0xFC,
+0xFF,0xFB,0x11,0xED,0x30,0xCE,0x0F,0xED,0x02,0x20,0xC4,0x30,0x49,0x11,0xB8,0x84,
+0x01,0x11,0xB8,0x84,0xA2,0x00,0x56,0x2D,0xA0,0x00,0x1E,0x2F,0x9B,0x06,0x0C,0xB8,
+0x02,0xE0,0x14,0xB0,0x81,0x80,0xB0,0xAB,0x02,0xE2,0x14,0x30,0x81,0x82,0xB4,0xAB,
+0x02,0xE4,0x14,0x30,0x81,0x84,0xB8,0xAB,0x02,0xE6,0x14,0xB0,0x81,0x86,0xBC,0xAB,
+0x01,0x88,0x38,0x6D,0x10,0x88,0xD4,0xED,0x08,0x88,0xE2,0xED,0x04,0x88,0xFE,0x6D,
+0x02,0x88,0x0A,0xEE,0x20,0xDB,0x19,0x6E,0x02,0x06,0x22,0x30,0x01,0x11,0x74,0x84,
+0x04,0xDB,0x47,0xED,0x03,0xDB,0x79,0xED,0xFF,0xD8,0xAB,0xED,0x08,0xDB,0xB7,0xED,
+0xF0,0xDA,0xBD,0xED,0x10,0xDB,0xCB,0x6D,0x00,0x0C,0x2A,0xC5,0x01,0xCD,0x77,0x6D,
+0x11,0x11,0x00,0x80,0x01,0xC8,0x51,0xED,0x00,0x11,0x8C,0x09,0x00,0x0C,0x76,0xC5,
+0x70,0x0B,0x15,0x88,0x80,0x80,0xB1,0x0B,0x00,0xD8,0x15,0x00,0x08,0xA0,0xB0,0x0B,
+0x00,0xD8,0x15,0x00,0x01,0x0A,0x14,0x00,0x00,0x0C,0x2A,0x59,0x00,0x0C,0x04,0xDD,
+0x00,0x0C,0xFC,0xDC,0x00,0x11,0x2A,0x8B,0x00,0x11,0x7E,0x0B,0xB2,0x00,0xD8,0xAD,
+0x40,0xCE,0x77,0xFD,0x01,0x11,0x00,0x00,0x02,0x20,0x40,0x30,0x00,0x11,0x00,0x08,
+0xF3,0x11,0xA2,0x5A,0x12,0x07,0xC0,0xBB,0x40,0xCA,0x95,0x03,0x04,0x11,0x06,0x05,
+0x01,0xCD,0xA7,0xED,0xF7,0xA0,0x40,0x89,0x11,0x11,0x00,0x80,0xFE,0xC8,0x91,0x8B,
+0x01,0xC9,0x93,0x03,0x01,0x83,0x8C,0xED,0x00,0x0C,0xFC,0xDC,0x44,0x8C,0x14,0x28,
+0x08,0x0A,0x3E,0x83,0x00,0x0C,0xA4,0xC5,0x00,0x0C,0x00,0x5D,0xF0,0x8C,0x14,0x88,
+0x04,0x0A,0x3E,0x83,0x80,0x0A,0xA2,0x75,0x10,0x0A,0x9A,0xF5,0x70,0x0A,0x9A,0xF5,
+0x60,0x0A,0xA4,0x65,0x01,0x95,0x2B,0x1B,0x00,0x0C,0xA4,0x55,0xFF,0x11,0x2A,0x03,
+0x00,0x0C,0xA4,0xC5,0x26,0x11,0x9C,0x82,0x04,0x11,0xF0,0x5C,0xBF,0x3D,0x7A,0x88,
+0x03,0x11,0x06,0x85,0x01,0xCD,0xB5,0xED,0x11,0x11,0x00,0x80,0x02,0xC8,0xB3,0xED,
+0x02,0xC9,0x93,0x03,0xE8,0x11,0x6E,0x5A,0xFF,0x11,0x00,0x85,0x80,0xCE,0xBB,0xFD,
+0x08,0xC8,0x91,0x03,0x08,0x11,0x06,0x05,0x60,0xCE,0xC5,0xED,0x80,0xCE,0xC9,0xFD,
+0x0C,0xC8,0xB1,0x8B,0x0C,0xD8,0xC9,0xE5,0x20,0x30,0x14,0xB8,0x00,0x0C,0xB0,0x5C,
+0xF0,0x11,0x04,0x05,0x10,0x45,0xD2,0x6D,0x03,0xC8,0xD3,0xFD,0x80,0xC0,0x14,0xB8,
+0x00,0x0C,0xB0,0x5C,0x10,0x11,0x06,0x05,0x1E,0xDC,0x2D,0x7D,0x18,0xDC,0xE1,0x7D,
+0x87,0x11,0xDE,0xDA,0x22,0x11,0x00,0x80,0x10,0xE4,0xC9,0x03,0xE7,0xE4,0xC8,0x09,
+0x1E,0x11,0x08,0x05,0x80,0xDC,0xEB,0x6D,0x01,0xDC,0xF5,0x6D,0x02,0xDE,0xF9,0xED,
+0x00,0x0C,0x2E,0x45,0x01,0xCD,0xF3,0x6D,0x30,0xCB,0xF3,0x7D,0x80,0xCB,0xF3,0x6D,
+0x80,0xCB,0x97,0x03,0x80,0x11,0x08,0x85,0x04,0xCA,0x95,0x03,0x01,0x11,0x08,0x85,
+0xFD,0xE6,0xCC,0x89,0x00,0x11,0x00,0x08,0x00,0x0C,0x8C,0xC3,0xFF,0xD9,0x31,0xFD,
+0x81,0x11,0xB0,0x03,0xFF,0x81,0xB2,0x0B,0xFF,0x11,0x02,0x81,0x01,0xA1,0xF2,0x6C,
+0x00,0x0C,0x1E,0x46,0x0E,0xDA,0x11,0x6E,0x01,0xDA,0x33,0xFD,0xFE,0xE2,0xC4,0x89,
+0x82,0x11,0xB0,0x03,0x0F,0x82,0xB2,0x0B,0x0F,0x11,0x04,0x81,0x00,0x0C,0x1E,0x46,
+0x83,0x11,0xB0,0x83,0x20,0x83,0xB2,0x0B,0x20,0x11,0x06,0x81,0x04,0x3A,0x1E,0x7E,
+0x08,0x00,0x68,0x38,0x02,0xD8,0x6D,0x34,0xB0,0x00,0xCC,0x28,0x02,0x05,0x0A,0x00,
+0x01,0xCA,0x4B,0xEE,0x0F,0xCB,0x41,0xEE,0x08,0xCA,0x45,0x6E,0x80,0xC8,0x43,0xEE,
+0x20,0xC8,0x45,0xEE,0xF3,0x11,0x9C,0xDA,0x00,0x0C,0xF8,0xD4,0xDC,0x01,0x1C,0xB8,
+0xF3,0x11,0x82,0xDA,0x00,0x0C,0xF8,0xD4,0x10,0xC9,0x93,0x03,0x15,0x11,0x46,0x46,
+0x08,0x11,0x46,0x46,0x05,0x11,0x46,0xC6,0x16,0x11,0x46,0x46,0x00,0x0C,0xF0,0xDC,
+0x12,0x11,0x50,0x46,0x00,0x0C,0x8C,0x5C,0xB2,0x00,0xDA,0x2E,0x0B,0x11,0x50,0xC6,
+0x00,0x0C,0xD0,0x59,0xA0,0x00,0x60,0x2A,0x01,0xCA,0x79,0x6E,0xB2,0x00,0xCA,0xAE,
+0x02,0x58,0x19,0x30,0xFC,0xFF,0x14,0x38,0x83,0x90,0x14,0x28,0x8A,0x0C,0x6E,0xAE,
+0xB2,0x00,0xF6,0xAD,0x80,0x0F,0x6C,0xEE,0x04,0x0C,0x78,0xB2,0xFC,0xFF,0x14,0x38,
+0x83,0x90,0xB0,0x2A,0x00,0x0C,0x70,0xC6,0x20,0x11,0xFA,0x5C,0x40,0x11,0xFA,0x5C,
+0x10,0x50,0xC1,0xB0,0x20,0x00,0xBC,0x38,0x69,0x11,0xB8,0x80,0x01,0xCA,0x95,0x87,
+0x18,0x11,0xB8,0x04,0x01,0x30,0x14,0x30,0xFF,0x0A,0x8A,0x7E,0x01,0x0A,0x8A,0x76,
+0x06,0x0A,0x16,0x77,0x02,0x0A,0x24,0x77,0xF8,0x0A,0x14,0x88,0xC0,0x0A,0x00,0xF7,
+0x16,0x11,0x2A,0x80,0x00,0x0C,0x40,0x5F,0x11,0x11,0x00,0x80,0x01,0xD8,0xF7,0xB3,
+0x02,0xDA,0x41,0xB0,0x02,0x20,0xDC,0x33,0x02,0x46,0x45,0x30,0x20,0x0B,0xB3,0x7E,
+0x40,0x9E,0x9D,0x7E,0x00,0x0C,0x50,0xDF,0x01,0x9D,0xB1,0x6E,0x01,0x80,0x90,0x3B,
+0x80,0xCA,0x95,0x03,0x01,0xCD,0x9B,0x03,0x01,0x45,0x9C,0xB3,0x00,0x0C,0xE2,0xD9,
+0xB2,0x00,0xD8,0xAD,0x01,0xFB,0xAF,0x76,0x73,0x01,0xC0,0xBF,0x0A,0x02,0xC0,0x3F,
+0x02,0x9E,0x3D,0x03,0x70,0x0B,0xB1,0x0B,0xFF,0xD8,0xBB,0xFE,0x80,0x80,0xC1,0xEE,
+0x00,0x0C,0xC4,0xC6,0x01,0x7C,0xBA,0x7E,0xFF,0xFF,0x04,0xBB,0x00,0x0C,0xC4,0xC6,
+0x01,0x23,0x04,0x33,0x01,0x22,0x06,0x33,0x08,0x11,0xB8,0x00,0x00,0x00,0x90,0xB9,
+0x8F,0x80,0x15,0x88,0x00,0xD8,0x95,0x01,0x0F,0x0B,0xB1,0x8B,0x55,0x11,0x00,0x80,
+0x01,0x43,0xD5,0x7E,0x08,0x11,0xB0,0x83,0x11,0x11,0x00,0x80,0xF0,0x81,0x15,0x88,
+0x00,0xD8,0x95,0x01,0x0A,0x82,0x95,0x31,0x08,0xA8,0x94,0xB1,0x08,0x94,0x95,0x31,
+0x01,0xD8,0xEB,0xEE,0x55,0x11,0x00,0x80,0x01,0x43,0xE9,0xEE,0x08,0x11,0x40,0x01,
+0x11,0x11,0x00,0x80,0x10,0x04,0xBC,0xB8,0x1C,0x11,0x14,0xDD,0x01,0xC8,0x91,0x03,
+0x02,0x96,0x71,0xB1,0x01,0xBA,0x74,0x01,0xFE,0x9E,0x3D,0x8B,0xE8,0x11,0x6E,0x5A,
+0x49,0x11,0xB8,0x00,0x00,0x0C,0xE2,0xD9,0x7F,0x03,0xC0,0xBB,0x80,0xCA,0x95,0x87,
+0x02,0x11,0x48,0x00,0x04,0xCE,0x15,0x77,0xC8,0xCD,0x1D,0x98,0x01,0x11,0x1E,0x00,
+0x01,0x30,0x26,0xB0,0x11,0xCD,0x15,0xA8,0x03,0x0E,0x9A,0x8B,0x01,0xCE,0x9D,0x1B,
+0xC0,0x0A,0x1C,0x18,0x02,0x32,0x26,0xB4,0x1D,0x11,0x2A,0x00,0x00,0x0C,0x40,0x5F,
+0x44,0x11,0x00,0x80,0x02,0xDA,0xE1,0xB3,0x10,0xCB,0x97,0x03,0x80,0xE1,0xF3,0xFC,
+0x00,0x0C,0xE2,0xD9,0x2C,0x08,0xC0,0xBF,0x02,0x30,0x22,0x30,0x02,0x32,0x14,0xB0,
+0x00,0xC6,0x31,0xE7,0x55,0x11,0x00,0x80,0xFF,0x48,0xF3,0xEC,0x30,0xCB,0xF3,0x6C,
+0x01,0xCB,0x97,0x03,0x44,0x11,0x00,0x80,0x00,0x0C,0xE2,0xD9,0x9C,0x07,0xC0,0x3F,
+0xB2,0x00,0xAE,0xAA,0xEB,0x00,0xF4,0xBB,0xB2,0x00,0x4E,0x2A,0xA0,0x00,0xAC,0xA8,
+0x04,0x30,0xB0,0xB3,0x04,0xC8,0xA9,0xB3,0x06,0xD8,0x4B,0x67,0xF0,0xD7,0xAF,0x0B,
+0x03,0x11,0xA8,0x33,0xD4,0x01,0x18,0xB8,0xB2,0x00,0xCE,0x2D,0x00,0x0C,0xF2,0xD4,
+0x04,0x3A,0x50,0xFF,0x04,0xD8,0x69,0x30,0x02,0x06,0x22,0x30,0xFF,0x11,0x22,0x8C,
+0x01,0xC7,0x14,0xB0,0x00,0xC5,0x14,0x08,0x80,0x0A,0x6C,0x6F,0x40,0x0A,0x70,0xEF,
+0x20,0x0A,0x76,0xEF,0x08,0x0A,0x94,0xEF,0x04,0x0A,0xAA,0x6F,0x02,0x0A,0xAE,0xEF,
+0x01,0x0A,0xB2,0x6F,0xFF,0x11,0x22,0x8C,0x80,0x11,0x8E,0x81,0x20,0xC9,0x93,0x87,
+0x10,0x11,0x12,0xDD,0x40,0x11,0x8E,0x81,0xE4,0x11,0x80,0x47,0x04,0xCB,0x7C,0xFF,
+0x04,0x11,0x96,0x81,0x08,0x11,0x12,0xDD,0x20,0x11,0x8E,0x81,0xE0,0x11,0x80,0xC7,
+0x01,0x11,0x4A,0x80,0x01,0x11,0x1A,0x80,0x04,0x12,0xB0,0xB3,0x01,0x00,0x14,0xB8,
+0x83,0xD8,0xB1,0x2B,0x00,0x00,0x14,0x38,0x84,0xDA,0xB5,0xAB,0x00,0x0C,0xF2,0xCC,
+0xFC,0x0C,0x1C,0x18,0x04,0xD8,0x27,0xB4,0x01,0xC7,0x19,0x88,0x01,0xCB,0x14,0x08,
+0x00,0x0C,0xA2,0x77,0xFE,0xC7,0x8F,0x8B,0x00,0xC7,0x8F,0x83,0x01,0x0A,0xA4,0x7F,
+0xEF,0x11,0xA2,0xDA,0x08,0x11,0x8E,0x05,0x08,0x11,0x8E,0x81,0xEC,0x11,0x6E,0xDA,
+0xE8,0x11,0x80,0x47,0x04,0x11,0x8E,0x81,0x04,0xC9,0x93,0x87,0x02,0x11,0x8E,0x81,
+0x08,0xC9,0x93,0x87,0x01,0x11,0x8E,0x81,0x40,0xC9,0x93,0x87,0x80,0x11,0x8E,0x81,
+0xDF,0xC9,0x93,0x0F,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x01,0x4E,0x15,0xB0,0x01,0x4C,0x17,0xB0,0x81,0x5A,0x15,0x28,0x02,0x0B,0x0C,0xF8,
+0xB1,0x00,0x9C,0x29,0x00,0x0C,0x56,0x40,0x20,0x0A,0x14,0x78,0x03,0xE5,0xCB,0x83,
+0x22,0x11,0x9E,0x82,0xDD,0x5A,0xB5,0x0A,0x02,0x0A,0x1A,0xF8,0x02,0xE5,0xCB,0x03,
+0x02,0x11,0x9E,0x02,0x10,0x0A,0x20,0xF8,0x04,0xE5,0xCB,0x03,0x10,0x11,0x9E,0x02,
+0x40,0x0A,0x26,0xF8,0xFD,0x4D,0x9B,0x8A,0xFD,0x5B,0xB7,0x8A,0x10,0xCB,0x3B,0xE8,
+0xEB,0x0A,0x14,0x08,0xFF,0x0A,0x54,0x78,0x20,0xCB,0x55,0x68,0x20,0xCB,0x97,0x03,
+0x97,0xC5,0x8A,0x89,0x7D,0x08,0xC0,0xBB,0x40,0x0A,0x42,0x78,0x01,0xCB,0x97,0x03,
+0x00,0x0C,0x42,0x40,0x40,0x4E,0x9F,0x0A,0x20,0x0A,0x42,0xE8,0xA9,0x44,0x15,0x88,
+0xFF,0x0A,0x54,0x78,0xA9,0x0A,0x46,0x78,0x08,0xE5,0xCB,0x03,0x01,0x0A,0xDC,0xB3,
+0x00,0x0C,0x08,0xDB,0x02,0xE5,0x4F,0x78,0x02,0xEE,0xDD,0x03,0x04,0xE5,0x53,0xF8,
+0x10,0xEE,0xDD,0x03,0xFE,0x3F,0x7E,0x88,0xFF,0x11,0x9E,0x82,0x01,0x11,0x76,0x04,
+0x02,0xF0,0x41,0x30,0x80,0x0A,0x75,0x70,0x81,0x0A,0x4D,0x73,0x82,0x0A,0x4F,0xF3,
+0x15,0x11,0x2A,0x80,0xB2,0x00,0x4C,0x2E,0x00,0x0C,0x22,0x5B,0xFF,0xF1,0x59,0x60,
+0x02,0x05,0x0A,0x00,0x0F,0xCB,0x97,0x0B,0x40,0x3D,0x7A,0x00,0x01,0x3F,0x7E,0x00,
+0xB1,0x00,0xE2,0x29,0xA0,0x00,0xAC,0xA8,0xF4,0xCB,0x97,0x8B,0x01,0x0C,0x15,0xB0,
+0x01,0x0A,0x88,0xF0,0x81,0x0A,0x8C,0xF0,0x02,0x0A,0x90,0xF0,0xFF,0x0A,0xBC,0x78,
+0x03,0x0A,0x88,0x70,0x04,0x0A,0x88,0xF0,0x05,0x0A,0xE2,0x70,0x15,0x11,0x2A,0x80,
+0x01,0x11,0xE8,0x03,0x00,0x0C,0xA6,0x40,0x02,0x11,0xE8,0x03,0x00,0x0C,0xA6,0x40,
+0x54,0x11,0x02,0x80,0x02,0x05,0x0A,0x00,0x01,0x0D,0x85,0xB2,0x55,0x11,0x00,0x80,
+0x20,0x11,0x9E,0x02,0x20,0x11,0x88,0x82,0x20,0x11,0x9C,0x82,0x22,0x5A,0xB5,0x82,
+0xFD,0x05,0x0A,0x88,0x01,0x01,0x22,0xB0,0x00,0x0C,0xA8,0xC0,0x00,0x0C,0x1C,0x5A,
+0x00,0x0C,0xC4,0x5A,0x01,0x11,0xB3,0xF8,0x03,0x11,0x48,0x80,0x04,0xD8,0x81,0x33,
+0x00,0x11,0x48,0x08,0x00,0x0C,0x64,0x50,0x00,0x0C,0x22,0x5B,0xFF,0xFF,0x40,0xB8,
+0x40,0xEF,0x9F,0xE9,0x00,0x0C,0x24,0xC1,0x7A,0x08,0x0C,0x38,0x55,0x11,0x02,0x00,
+0x02,0x05,0x0A,0x00,0x00,0x00,0xB0,0x3A,0x00,0x00,0xB4,0xBA,0xFE,0x3F,0x7E,0x88,
+0x08,0x11,0x80,0x02,0x00,0x11,0x82,0x8A,0x00,0x11,0x80,0x0A,0xC2,0x60,0xC1,0x02,
+0xFF,0xFF,0x94,0x3A,0xFF,0x11,0x9E,0x82,0x01,0x01,0x22,0xB0,0xB2,0x00,0x0A,0xAE,
+0x97,0xC5,0x8A,0x89,0xB2,0x00,0x0E,0x2B,0x03,0x11,0x90,0xB3,0x08,0x11,0x96,0x03,
+0xFD,0x05,0x0A,0x0C,0x10,0x0D,0xEB,0xF8,0x55,0x11,0x00,0x80,0xEF,0x5A,0xB5,0x8A,
+0x44,0x11,0x00,0x80,0x00,0x0C,0x6C,0xDA,0x10,0x0D,0xF5,0x68,0x55,0x11,0x00,0x80,
+0x10,0x5A,0xB5,0x02,0x44,0x11,0x00,0x80,0x00,0x11,0x78,0x8A,0x03,0x11,0x7A,0xB2,
+0x11,0x11,0x62,0xC0,0x00,0x0C,0xAE,0x5A,0x40,0xEE,0x09,0xF9,0xB1,0x00,0x0E,0xAA,
+0x00,0x0C,0x18,0x5B,0x00,0x0A,0x4A,0xDE,0xBF,0xEE,0xDD,0x8B,0xA9,0xEE,0x67,0x78,
+0x14,0xCB,0x97,0x83,0xF4,0xCB,0x97,0x8B,0x01,0x11,0xE8,0x03,0xFF,0xFF,0x40,0xB8,
+0x00,0x0C,0xC4,0x5A,0xB1,0x00,0x0E,0xAA,0x00,0x0C,0x18,0x5B,0x00,0x0A,0x4A,0xDE,
+0x08,0xEE,0x1F,0x79,0x00,0x0C,0x4E,0xDA,0x00,0x0C,0x66,0x40,0x80,0xEE,0x67,0xF8,
+0x01,0xF6,0xEB,0x33,0x40,0xEF,0x9F,0xE9,0x01,0x11,0x4E,0xDE,0xB1,0x00,0xAA,0x29,
+0xB0,0x00,0xCC,0x28,0xC0,0xCA,0x57,0xEE,0x02,0xF4,0x69,0xF1,0x00,0x0C,0x2A,0xDB,
+0xE4,0x11,0x46,0xDE,0x11,0x11,0x48,0x5B,0xB1,0x00,0x8C,0xAC,0x44,0x11,0x48,0x5B,
+0xB0,0x00,0xCC,0x28,0x40,0xCB,0x4B,0xE9,0x80,0xCB,0x61,0x69,0x00,0x0C,0x0A,0xDA,
+0x00,0x0C,0xE6,0xC9,0x02,0xCB,0xE9,0x69,0xE7,0x11,0xF0,0x5D,0x00,0x0C,0xEA,0xC9,
+0x00,0x0C,0x56,0x46,0x20,0x11,0x06,0x81,0x20,0xE3,0xC6,0x01,0x00,0x11,0x48,0x5B,
+0x08,0x11,0xB8,0x00,0xB1,0x00,0x8C,0xAC,0x00,0x00,0x90,0xB9,0x00,0x11,0xB2,0x89,
+0x1C,0xD8,0x94,0x31,0x40,0x11,0x72,0x00,0x1C,0xF0,0xF4,0x3B,0x00,0x0C,0xC8,0x41,
+0x84,0x80,0x40,0x38,0x08,0x11,0x4A,0x5E,0xFF,0xFF,0x40,0xB8,0x00,0x0C,0x66,0x40,
+0x00,0x0C,0xAE,0x5A,0x55,0x11,0x00,0x80,0x10,0x11,0x80,0x02,0x44,0x11,0x00,0x80,
+0x2D,0x11,0x50,0x5E,0x02,0x05,0x0A,0x00,0x0F,0xCB,0x97,0x0B,0xB1,0x00,0xE2,0x29,
+0xFD,0x05,0x0A,0x88,0xB0,0x00,0xCC,0x28,0x00,0x0C,0x0A,0xDA,0x00,0x0C,0x8A,0xC9,
+0x08,0xC7,0x86,0xF9,0x08,0x11,0x8E,0x81,0x01,0xCB,0x8A,0xF9,0xFF,0xF1,0x67,0xE0,
+0x00,0x0C,0x56,0x46,0x40,0x11,0x72,0x00,0xB0,0x00,0xCC,0x28,0x55,0x11,0x00,0x80,
+0x40,0x48,0x99,0x69,0x44,0x11,0x00,0x80,0xFF,0xF1,0x67,0xE0,0x00,0x0C,0x56,0x46,
+0x90,0x11,0x80,0x82,0x44,0x11,0x00,0x80,0x00,0x0C,0x66,0x40,0xB1,0x11,0x14,0x80,
+0xB1,0x00,0x2A,0xA9,0xFE,0xCD,0x9B,0x8B,0xB0,0x00,0xCC,0x28,0x40,0xCA,0x57,0x6E,
+0xD0,0x01,0x1C,0xB8,0xE8,0x11,0x52,0xDE,0xB0,0x00,0xCC,0x28,0x40,0xCB,0xBF,0x69,
+0x00,0x0C,0x0A,0xDA,0x00,0x0C,0xE6,0xC9,0x02,0xCB,0xE9,0x69,0xD0,0x01,0x1C,0xB8,
+0xEB,0x11,0xEE,0x5D,0x00,0x0C,0xEC,0xC9,0x00,0x0C,0x56,0x46,0x20,0x11,0x06,0x81,
+0x20,0xE3,0xC6,0x01,0x00,0x11,0x48,0x5B,0x20,0x11,0xB8,0x00,0x14,0x20,0xF4,0x3B,
+0xB1,0x00,0x0E,0xAA,0x01,0x0A,0xC4,0xB3,0x01,0xFA,0x15,0xB0,0x00,0x11,0x16,0x88,
+0xB1,0x00,0x42,0x2A,0xB1,0x00,0x5E,0xAA,0x02,0x0C,0x1C,0x98,0xFF,0xC6,0x27,0x08,
+0x01,0xFB,0x27,0xB0,0x02,0x0A,0x26,0xB0,0xB1,0x00,0x8C,0xAC,0x00,0xE2,0x4B,0x5E,
+0x44,0x11,0x48,0x5B,0xFB,0xCB,0x97,0x8B,0x00,0x0C,0x66,0x40,0x01,0x11,0xEE,0x41,
+0x02,0x11,0xEE,0x41,0x00,0x11,0xEE,0xC1,0x03,0x11,0xEE,0xC1,0x01,0x0C,0xE4,0x33,
+0xB1,0x00,0x0E,0xAA,0x02,0x0C,0x1C,0x98,0x18,0xC6,0x27,0x80,0x01,0xF2,0x27,0xB0,
+0x01,0xF5,0x27,0x30,0x00,0x0A,0x4A,0xDE,0x03,0xF2,0x67,0x70,0xFF,0xF5,0x05,0xEA,
+0x00,0x0C,0xBE,0x58,0x00,0x0C,0x66,0x40,0xFF,0xF5,0xEB,0x9B,0x00,0x0C,0x4E,0xDA,
+0x00,0x0C,0x66,0x40,0x55,0x11,0x02,0x00,0x40,0x4E,0x19,0x7A,0x00,0x11,0x82,0x8A,
+0xC0,0x11,0x9E,0x82,0x01,0x11,0x76,0x80,0x01,0x01,0x22,0xB0,0x01,0x10,0x22,0x1C,
+0x01,0x01,0x22,0xB0,0x01,0x11,0x22,0x9C,0x00,0x0C,0xAE,0x5A,0x00,0x0C,0x6C,0xDA,
+0x01,0x10,0x9F,0xB3,0x01,0x16,0xED,0xB3,0x01,0x16,0xEB,0xB3,0x01,0x11,0x2F,0x7A,
+0x03,0x11,0x48,0x80,0x04,0x12,0x81,0x33,0x00,0x11,0x48,0x08,0x55,0x11,0x00,0x80,
+0x03,0x0A,0x76,0x72,0x04,0x0A,0x76,0xF2,0x20,0x43,0x43,0xFA,0x08,0x68,0xD1,0x02,
+0xF3,0x60,0xC1,0x0A,0x08,0x60,0xC1,0x02,0xF8,0x61,0xC3,0x8A,0x04,0x62,0xC5,0x8A,
+0x80,0x62,0xC5,0x02,0xFD,0x11,0x9E,0x02,0xEB,0x00,0xF4,0xBB,0x10,0x42,0x4B,0x6A,
+0x10,0xFA,0xF5,0x03,0xFD,0x60,0xC1,0x8A,0x44,0x11,0x00,0x80,0xB0,0x00,0xC6,0x28,
+0xE3,0x11,0xF2,0x5D,0x00,0x0C,0x5A,0x52,0xD8,0x01,0x1C,0x38,0xE3,0x11,0xEE,0xDD,
+0x00,0x0C,0x56,0xD6,0x55,0x11,0x02,0x00,0x00,0x11,0x82,0x8A,0x10,0x11,0x80,0x02,
+0x90,0x11,0x80,0x82,0x02,0xFA,0xB5,0x32,0x01,0x01,0x22,0xB0,0xD8,0x01,0x1C,0x38,
+0xE0,0x11,0x52,0x5E,0xA0,0x00,0xD2,0xA8,0x54,0x11,0x02,0x80,0x01,0x0F,0xA1,0x32,
+0x01,0x0D,0x85,0xB2,0x01,0x0E,0x8B,0x32,0x01,0x01,0x22,0x34,0x01,0xA2,0x18,0x38,
+0x03,0x02,0x1C,0x38,0x03,0x0A,0x80,0x72,0x08,0xA1,0x18,0x38,0x11,0x10,0x1C,0x38,
+0x00,0x11,0x8C,0x0A,0x3D,0x60,0xC1,0x8A,0x01,0x0C,0x82,0xB2,0x50,0x11,0x80,0x82,
+0x08,0x11,0xC4,0x83,0xFF,0xE2,0xC5,0x9B,0xFF,0xE2,0x8B,0xEA,0xA0,0x41,0x83,0x82,
+0x01,0x0E,0x14,0xB0,0x00,0x49,0xC5,0x8B,0xFF,0xE2,0x93,0x7A,0x01,0x0D,0x82,0x32,
+0x01,0x0F,0x14,0x30,0x00,0xE2,0x9F,0xEA,0x00,0x49,0x9D,0x7A,0x80,0x11,0x9C,0x82,
+0xE0,0x11,0x82,0x82,0x03,0x11,0x8C,0x82,0x0A,0xE5,0xCB,0x83,0x82,0x11,0xDC,0x03,
+0x00,0x0C,0x08,0xDB,0xFF,0x11,0x9E,0x82,0x44,0x11,0x00,0x04,0x04,0xCB,0x97,0x03,
+0x22,0x11,0x02,0x00,0x97,0xC5,0x8A,0x89,0xEF,0x11,0x54,0x5E,0xFE,0xC7,0x8F,0x8B,
+0x01,0x01,0x22,0xB0,0x08,0x11,0x88,0x00,0x02,0x00,0x40,0xB9,0x00,0x11,0x8A,0x88,
+0x00,0x11,0x4E,0x5E,0xDF,0xE3,0xC6,0x0D,0x01,0x3F,0x7E,0x00,0xC0,0x01,0x1C,0x38,
+0xEC,0x11,0x52,0x5E,0xB0,0x00,0xC6,0x28,0x08,0xE5,0xDD,0x7A,0x80,0xEE,0xD9,0x7A,
+0x02,0xF4,0xD9,0x72,0xB2,0x00,0x0E,0x2B,0x68,0xC5,0x8A,0x01,0xB1,0x00,0xA0,0x29,
+0x00,0x0C,0x14,0x5E,0x00,0x0C,0xF0,0xC2,0x02,0xE5,0x57,0xEE,0xC0,0x01,0x1C,0x38,
+0xEF,0x11,0xEE,0xDD,0x00,0x0C,0x56,0xD6,0x55,0x11,0x02,0x00,0xFE,0x3F,0x7E,0x88,
+0x01,0x44,0xDD,0x33,0x00,0x0C,0x08,0xDB,0xFF,0x11,0x9E,0x82,0x01,0x01,0x22,0xB0,
+0xF1,0xE5,0xCB,0x8B,0xFF,0x21,0xFE,0x72,0x11,0x11,0x4C,0xDE,0x00,0x11,0x78,0x8A,
+0x01,0xEE,0x7B,0xB2,0x01,0xEF,0x7D,0x32,0x01,0xF3,0x7F,0x32,0x01,0xCB,0x14,0x08,
+0xFE,0xC7,0x8F,0x8B,0x00,0xC7,0x8F,0x83,0x11,0xEE,0x23,0x28,0xA0,0x00,0xD2,0xA8,
+0x01,0x43,0xDF,0x33,0x80,0x48,0xE7,0x8B,0xFF,0x11,0x94,0x06,0x06,0x11,0x96,0x01,
+0x68,0xC7,0x14,0x08,0xFF,0x0A,0xF4,0x7D,0x68,0x11,0x8E,0x81,0x80,0x11,0x74,0x84,
+0x02,0x0C,0x1C,0x98,0x10,0xC6,0x27,0x00,0x01,0xEE,0x27,0x30,0x01,0xEF,0x27,0xB0,
+0x01,0xF3,0x27,0xB4,0x02,0x00,0xE1,0x33,0xFF,0xF1,0x29,0xE3,0x0F,0x11,0x4A,0xC6,
+0x10,0x11,0x4A,0x46,0x11,0x11,0x02,0x00,0x08,0x11,0xB8,0x00,0x01,0xC0,0x23,0xB0,
+0x02,0x11,0x4A,0x80,0x03,0xE0,0x15,0x08,0x1C,0x00,0x98,0x38,0xFC,0xE0,0xC1,0x08,
+0x07,0xE1,0xC1,0xB0,0x1C,0x11,0xC0,0x00,0x06,0x11,0xC0,0xB0,0x44,0x0A,0xC0,0xA8,
+0x00,0x11,0x4A,0x88,0x10,0x04,0xBC,0xB8,0x49,0x11,0xB8,0x00,0x01,0x01,0x22,0x34,
+0x80,0xE1,0xC3,0x03,0x01,0x0C,0x00,0xB4,0x00,0x11,0x62,0xC0,0x01,0x0C,0x15,0xB0,
+0xFF,0x0A,0x58,0x7B,0x01,0x0A,0x6E,0x73,0x02,0x0A,0x80,0x73,0x15,0x11,0x2A,0x80,
+0x02,0x05,0x0A,0x00,0x22,0x11,0x02,0x00,0x01,0x11,0x4A,0x80,0x42,0x11,0x00,0x80,
+0x0C,0xE0,0x21,0xB2,0x22,0x11,0x00,0x80,0x00,0x11,0x4A,0x88,0x45,0x11,0x00,0x00,
+0x04,0x3C,0x39,0xB2,0x01,0x01,0x22,0xB0,0x0A,0x11,0x62,0xC0,0x02,0x05,0x0A,0x00,
+0x22,0x11,0x02,0x00,0x01,0x11,0x4A,0x80,0x0C,0x11,0xC0,0xB3,0x00,0x11,0x4A,0x88,
+0x55,0x11,0x00,0x80,0x04,0x11,0x78,0xB2,0x01,0x01,0x22,0xB0,0x00,0x11,0x62,0xC0,
+0x01,0x11,0x04,0x01,0x01,0xE2,0xC4,0x01,0x00,0x11,0x62,0xC0,0x04,0x4C,0xA3,0xFB,
+0xFB,0xFF,0x18,0xB8,0xB2,0x00,0xAA,0xAE,0x08,0x11,0x96,0xDE,0x00,0x0C,0x8C,0x5C,
+0xCA,0x11,0xCC,0x5B,0x0C,0x28,0x95,0x31,0x0C,0x40,0x99,0xF3,0x04,0x34,0x95,0x31,
+0x00,0x00,0x80,0x3A,0x10,0x00,0xBC,0x38,0x00,0xC8,0x48,0xDE,0x00,0x0C,0xC6,0x5B,
+0xA0,0x00,0x4A,0x2B,0x10,0x4C,0xAB,0x7B,0xDF,0x9D,0x3B,0x8B,0x20,0x4C,0x15,0x88,
+0x00,0x9D,0x3B,0x83,0x00,0x0C,0xA4,0xDD,0x00,0x0C,0x84,0xDC,0x14,0x10,0x95,0xB1,
+0x00,0xC8,0x48,0xDE,0x02,0x20,0x4C,0x33,0x10,0x00,0xBC,0x38,0x11,0x48,0x15,0x88,
+0x11,0x0A,0xC0,0xE3,0x04,0x0C,0x81,0xB2,0x00,0x0C,0xA8,0xDD,0x00,0x0C,0xC2,0xC3,
+0x04,0x11,0x80,0x32,0x00,0x0C,0xC6,0x5B,0xA0,0x00,0x44,0xAB,0x00,0x11,0x94,0x88,
+0x04,0x11,0xA4,0xB0,0x04,0x11,0x24,0x05,0x01,0x0C,0x1C,0xB0,0x00,0x11,0x1E,0x08,
+0x46,0x00,0x26,0x38,0x00,0x00,0x26,0x3C,0x30,0xCB,0xD9,0xFB,0x40,0xCB,0x97,0x87,
+0x02,0x8A,0xC4,0x30,0x02,0x38,0x0D,0xB4,0xB1,0x00,0x80,0x2B,0x04,0x11,0x52,0x5D,
+0x00,0x0C,0xEA,0xC3,0x04,0x11,0x52,0x5D,0x18,0x11,0xB8,0x80,0x40,0x11,0x90,0x00,
+0xBF,0xE5,0xCB,0x8B,0xFF,0xFF,0xC4,0xB8,0xFF,0x11,0x22,0x8C,0x04,0x11,0x96,0xDE,
+0x00,0x0C,0x1A,0xDD,0x04,0x94,0x80,0xB2,0xB1,0x00,0x5C,0x2C,0x00,0x0C,0xE4,0x43,
+0x00,0x0C,0x2A,0xDD,0x80,0xB5,0xE5,0xEB,0xF5,0x09,0x0C,0x38,0xFF,0xFF,0x4C,0xBB,
+0x21,0xB5,0x09,0x6C,0x0B,0x0A,0x09,0x74,0x40,0x48,0x0B,0xEC,0xA0,0x00,0xF2,0xA9,
+0x0C,0x11,0x0C,0xC4,0x0B,0x11,0x0C,0x44,0xA0,0x00,0xF6,0x29,0x00,0x0C,0xDE,0xDC,
+0x01,0x48,0x19,0xEC,0x00,0x0C,0x1A,0xDD,0x80,0x9E,0x3D,0x03,0x00,0x0C,0x36,0x45,
+0x00,0x0C,0x1A,0xDD,0x00,0x0C,0x44,0x45,0x40,0x4C,0x2F,0xFC,0x01,0xB6,0x6B,0x33,
+0x1B,0x48,0x15,0x88,0x01,0x0A,0x2E,0xE4,0x80,0x11,0x96,0xDE,0xFF,0xFF,0x4C,0xBB,
+0x02,0x11,0x48,0x00,0x0C,0xD4,0x51,0xB2,0x00,0x11,0x48,0x08,0xB1,0x00,0x62,0x2B,
+0x08,0x49,0xEB,0x6B,0x00,0x0C,0xEC,0xC3,0xF2,0x09,0x0C,0xB8,0xB1,0x00,0x5C,0x2C,
+0x04,0x0C,0xB1,0x33,0x00,0x0C,0xAE,0xDD,0x00,0x0C,0xC2,0x44,0x40,0xE5,0xE5,0xEB,
+0x02,0x8A,0xC4,0x30,0x00,0x11,0x94,0x88,0x01,0x52,0x14,0xB0,0xA1,0x0A,0x7A,0xF4,
+0x34,0x0A,0xF8,0x73,0x46,0x0A,0x6C,0x74,0x39,0x0A,0x76,0x74,0x41,0x0A,0xC6,0x75,
+0x5F,0x0A,0x5A,0xF4,0x27,0x0A,0xDC,0xF3,0x58,0x0A,0x78,0x74,0x02,0x11,0x5A,0xDD,
+0x00,0x0C,0xE4,0x43,0x18,0x48,0x15,0x88,0xFF,0x0A,0xDC,0xEB,0x01,0x11,0x94,0x80,
+0x20,0x52,0x14,0x08,0x5B,0x0A,0x14,0x28,0x01,0x0A,0x14,0x18,0x03,0x0A,0x14,0x10,
+0x00,0x48,0xDD,0xFB,0x00,0x0C,0x10,0x44,0x00,0x11,0x86,0x09,0x46,0x3A,0xDD,0x63,
+0x01,0x48,0xDD,0x7B,0xB1,0x00,0x72,0xAB,0x00,0x0C,0xEA,0xC3,0x00,0x0C,0xDC,0xC3,
+0x00,0x0C,0xE4,0x43,0x02,0x11,0x94,0x80,0x77,0x52,0x14,0x88,0x88,0xB5,0x6B,0x0B,
+0x00,0xB5,0x6B,0x83,0x00,0x0C,0xE4,0x43,0x09,0x0A,0x8D,0xF4,0x0A,0x0A,0x9F,0xF4,
+0x04,0x1F,0xA5,0x7C,0x01,0x00,0x74,0xBE,0x0B,0x48,0xA5,0xFC,0x1B,0x48,0x15,0x88,
+0x01,0x0A,0xB0,0xF4,0x02,0x0A,0xAA,0x74,0x03,0x0A,0xB6,0x74,0x11,0x0A,0xBC,0x74,
+0x12,0x0A,0xC2,0x74,0x13,0x0A,0xC8,0xF4,0x17,0x11,0x2A,0x00,0x02,0x00,0x74,0x3A,
+0xFF,0x20,0x9C,0x3A,0xF7,0x09,0x70,0x3E,0x34,0x00,0x74,0x3A,0xFF,0x00,0x9C,0xBA,
+0xFC,0x09,0x70,0xBE,0x5F,0x00,0x74,0xBA,0xFF,0x20,0x9C,0x3A,0x09,0x0A,0x70,0xBE,
+0x5F,0x20,0x74,0x3A,0xFF,0x20,0x9C,0x3A,0x0C,0x0A,0x70,0xBE,0x5F,0x00,0x74,0xBA,
+0xFF,0x00,0x9C,0xBA,0x07,0x0A,0x70,0x3E,0x46,0x00,0x74,0x3A,0xFF,0x00,0x9C,0xBA,
+0x0E,0x0A,0x70,0x3E,0x39,0x00,0x74,0xBA,0xFF,0x00,0x9C,0xBA,0x1A,0x0A,0x70,0x3E,
+0x03,0x00,0x74,0x3E,0x40,0x49,0xD7,0xEC,0x40,0x4C,0xD7,0xEC,0x1B,0x48,0x15,0x88,
+0x12,0x0A,0xF4,0xF5,0x01,0xB6,0x6B,0x33,0x00,0x0C,0x90,0xC4,0x1B,0x48,0x15,0x88,
+0x01,0x0A,0xDC,0x64,0x0A,0x0A,0xC9,0x64,0x00,0x0C,0xA4,0x44,0x01,0x11,0x94,0x80,
+0x20,0x52,0x18,0x08,0x5B,0x0C,0x18,0x28,0x01,0x0C,0x18,0x18,0xB0,0x00,0x1C,0x2F,
+0x00,0x0C,0x8C,0x44,0x00,0x00,0x90,0x38,0x02,0x3A,0xF7,0xF4,0x01,0x3A,0xC9,0xF5,
+0x03,0x3A,0xC9,0x75,0x02,0x3A,0xA1,0xB0,0x00,0x0C,0xF8,0x44,0x5F,0x00,0xA0,0x38,
+0x02,0x4E,0xA3,0x30,0x16,0x11,0xA0,0x30,0x16,0x11,0xA2,0xB0,0x00,0x11,0x90,0x08,
+0x41,0x50,0xF4,0x65,0x10,0x10,0x90,0x38,0x04,0x24,0xA1,0xB0,0x04,0x10,0xA2,0xB4,
+0x02,0x22,0x0C,0x30,0x02,0xA6,0x41,0x30,0xFF,0xFF,0x14,0x38,0x8A,0x20,0x16,0x2D,
+0x02,0x20,0x14,0x31,0x02,0x06,0x44,0x30,0x01,0x11,0x22,0x9C,0x02,0x06,0x44,0x30,
+0x01,0x10,0x22,0x1C,0x0F,0x11,0x94,0x00,0x01,0x52,0x6C,0xB3,0x04,0x4C,0x2B,0x6D,
+0x01,0x48,0x2B,0x7D,0x88,0xB6,0x2B,0xED,0x40,0x11,0x96,0xDE,0x00,0x11,0x94,0x88,
+0x14,0x52,0x20,0x32,0x02,0x11,0x94,0x80,0x01,0x52,0x6A,0xB3,0x7F,0x9E,0x3D,0x8B,
+0x01,0x11,0x94,0x80,0x80,0x52,0xF4,0x7D,0x80,0x9E,0x3D,0x87,0xB1,0x00,0x40,0xAC,
+0x80,0x49,0x3F,0xFD,0xB1,0x00,0x5A,0x2C,0x00,0x0C,0xE2,0x43,0xF2,0x09,0x0C,0xB8,
+0x80,0x9E,0xC3,0x7C,0xA1,0x00,0x5C,0xAC,0xB1,0x00,0x4A,0xAC,0x80,0x49,0xE3,0xEB,
+0x00,0x0C,0xA8,0xDD,0x00,0x0C,0xBC,0x5C,0x00,0x0C,0xE4,0x43,0x01,0x0C,0x14,0x30,
+0xD8,0x11,0x5E,0xC5,0x01,0x0C,0x14,0x30,0xD9,0x11,0x5E,0x45,0x01,0x0C,0x14,0x30,
+0xDA,0x11,0x5E,0x45,0x01,0x0C,0x14,0x30,0xDB,0x11,0x5E,0xC5,0x02,0x11,0x48,0x00,
+0x01,0x11,0x1A,0x80,0x02,0x0C,0x1C,0xB0,0x00,0x12,0x26,0x00,0x00,0x11,0x48,0x8C,
+0xCC,0x01,0x1C,0x38,0xEC,0x11,0x52,0x5E,0xB0,0x00,0xCC,0x28,0xCC,0x01,0x1C,0x38,
+0xEF,0x11,0xEE,0xDD,0x00,0x0C,0x56,0xD6,0xFB,0x1F,0x3F,0x8A,0xA0,0x00,0xE6,0xAA,
+0x11,0x11,0x02,0x00,0x10,0x02,0xE0,0x39,0xFF,0x11,0x22,0x20,0x04,0x11,0xD0,0x31,
+0x0F,0x02,0xE0,0xB9,0xFF,0x11,0x22,0x20,0x04,0x11,0xD0,0x31,0x00,0x00,0xE0,0x39,
+0x00,0x11,0xB0,0x88,0x32,0x11,0x00,0x00,0x02,0xF2,0x91,0x30,0x01,0x01,0x22,0x34,
+0x20,0x84,0xF4,0xFD,0x20,0x11,0x08,0x01,0x1C,0x11,0x4C,0x46,0xFF,0xA7,0xD7,0x65,
+0x01,0x11,0x22,0x9C,0x03,0x0C,0x14,0x08,0xFF,0x0A,0x14,0x10,0x01,0x0A,0x14,0x18,
+0x04,0x0A,0x14,0x18,0x03,0x0A,0x14,0x8C,0x00,0x0C,0x9B,0xDD,0x22,0x0A,0x7E,0xAE,
+0x00,0x40,0x9B,0x5D,0xFC,0x3F,0x7F,0x0A,0x00,0x3F,0x7F,0x06,0xFF,0xFF,0x14,0x38,
+0x89,0xDA,0xB9,0x2D,0x00,0xE0,0x14,0xB8,0x89,0xD8,0xB9,0xAD,0x04,0xD8,0x81,0x36,
+0x00,0x20,0x80,0xBA,0x00,0x00,0x84,0x3E,0x80,0x11,0x56,0xDD,0x02,0xCA,0x95,0x87,
+0x00,0x0C,0xC4,0xDD,0x77,0xB5,0x6B,0x8F,0xFF,0xFF,0x4C,0x3F,0x00,0x0C,0xDC,0xC3,
+0x00,0x00,0x90,0x38,0x18,0x11,0xA0,0xB0,0x18,0x10,0xA2,0x34,0x00,0x00,0x14,0x38,
+0x88,0x12,0xD6,0x2D,0x88,0x12,0xD6,0x2D,0x01,0x11,0x22,0x9C,0x01,0x10,0x22,0x1C,
+0x01,0x11,0x02,0x80,0x02,0x22,0x44,0x30,0x21,0x11,0x00,0x80,0x02,0x22,0x44,0x30,
+0x01,0x01,0x22,0x34,0x10,0x11,0x02,0x80,0x02,0x22,0x44,0x30,0x20,0x11,0x00,0x00,
+0x02,0x22,0x44,0x30,0x01,0x01,0x22,0x34,0xA0,0x00,0xA4,0x28,0xA1,0x00,0x82,0xAA,
+0xA1,0x00,0x80,0x2A,0xA1,0x00,0x9C,0xAA,0xFF,0x11,0x22,0x8C,0x82,0x10,0x14,0x28,
+0x01,0x10,0x22,0x98,0x84,0x11,0x14,0xA8,0x02,0x0A,0x0C,0x30,0xFF,0xFF,0x14,0x38,
+0x84,0x11,0x1C,0x28,0x02,0x06,0x14,0x30,0x83,0x0C,0x18,0x28,0x00,0x00,0x14,0x38,
+0x84,0x0E,0x1C,0x2C,0x09,0x10,0x00,0xB1,0x01,0x11,0x74,0x00,0x00,0x0C,0x2C,0xC6,
+0x00,0x0C,0x14,0x5E,0x00,0x0C,0x1E,0x46,0x00,0x0C,0x22,0x5E,0x10,0x11,0x06,0x81,
+0x04,0x11,0x0E,0x01,0x01,0x11,0x10,0x85,0x00,0x0C,0x22,0x5E,0x80,0x11,0x08,0x01,
+0x08,0x11,0x10,0x85,0xFF,0x11,0x00,0x01,0xF0,0xEF,0x04,0xB9,0x7F,0xFF,0x08,0xB9,
+0xFF,0xFB,0x0C,0x39,0x10,0x11,0x10,0x01,0x00,0x11,0x02,0x88,0x00,0x0C,0x38,0xDE,
+0x11,0x11,0x00,0x80,0x00,0x0C,0x40,0xDE,0x01,0x01,0x22,0x34,0x11,0x00,0x40,0xF6,
+0xFF,0x11,0x8C,0x00,0xFF,0x11,0x8E,0x80,0x7F,0x03,0x24,0x39,0x02,0x11,0x74,0x84,
+0xFF,0x11,0x8C,0x00,0xFF,0x11,0x8E,0x80,0x02,0x11,0x74,0x84,0xA1,0x00,0x6E,0x2A,
+0xA0,0x00,0x1E,0x2F,0xA1,0x00,0xD0,0x29,0xA0,0x00,0x6C,0x2F,0xA1,0x00,0x4E,0xA9,
+0xA1,0x00,0xD6,0x2A,0xA1,0x00,0x70,0x2A,0xA1,0x00,0xA2,0x2A,0xA0,0x00,0xAE,0x28,
+0x01,0x0C,0x1A,0xB0,0x00,0x11,0x5E,0xC6,0x00,0x11,0x1A,0x88,0x01,0x05,0x0C,0x30,
+0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,0x02,0x48,0x15,0xB0,0x80,0x0C,0x04,0xA8,
+0xE2,0x48,0x6D,0x2E,0xA0,0x00,0x80,0xAF,0x02,0x48,0x91,0x32,0x00,0x0C,0x64,0xC6,
+0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,0x02,0x48,0x15,0xB0,
+0x81,0x0C,0x04,0x28,0xE2,0x48,0x7F,0x2E,0xA0,0x00,0x80,0xAF,0x02,0x48,0x91,0x32,
+0x00,0x0C,0x76,0xC6,0x00,0x11,0x1A,0x88,0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,
+0x02,0x05,0x0A,0x00,0x02,0x48,0x15,0xB0,0x82,0x0C,0x04,0x28,0xE2,0x48,0x93,0xAE,
+0xA0,0x00,0x80,0xAF,0x02,0x48,0x91,0x32,0x00,0x0C,0x8A,0xC6,0x00,0x11,0x1A,0x88,
+0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,0x02,0x4C,0x15,0x30,
+0x80,0x0C,0x04,0xA8,0xE2,0x4C,0xA7,0xAE,0xA0,0x00,0x80,0xAF,0x02,0x4C,0x99,0x32,
+0x00,0x0C,0x9E,0xC6,0x01,0x05,0x0C,0x30,0x00,0x11,0x0C,0x08,0x02,0x05,0x0A,0x00,
+0x02,0x4C,0x15,0x30,0x81,0x0C,0x04,0x28,0xE2,0x4C,0xB9,0xAE,0xA0,0x00,0x80,0xAF,
+0x02,0x4C,0x99,0x32,0x00,0x0C,0xB0,0xC6,0xB0,0x00,0x86,0x2F,0x20,0x48,0xC7,0x6E,
+0x00,0x0C,0xCA,0x5E,0xB0,0x00,0x96,0xAF,0x01,0x11,0x22,0x9C,0xB0,0x00,0x96,0xAF,
+0x01,0x10,0x22,0x1C,0x02,0x05,0x0A,0x00,0x02,0x4A,0x15,0x30,0x01,0x0A,0x04,0xB0,
+0x01,0x0B,0x06,0x98,0xE2,0x4A,0xD7,0x2E,0x00,0x0C,0xFA,0x46,0x02,0x4A,0x95,0x32,
+0x00,0x0C,0xCC,0x46,0x02,0x05,0x0A,0x00,0x02,0x4A,0x15,0x30,0x01,0x0A,0x04,0xB0,
+0xFF,0x0B,0x06,0x18,0xE2,0x4A,0xE7,0x2E,0x00,0x0C,0xFA,0x46,0x02,0x4A,0x95,0x32,
+0x00,0x0C,0xDC,0xC6,0x02,0x05,0x0A,0x00,0x02,0x4A,0x15,0x30,0xFF,0x0A,0x04,0x18,
+0x01,0x0B,0x06,0xB0,0xE2,0x4A,0xF7,0xAE,0x00,0x0C,0xFA,0x46,0x02,0x4A,0x95,0x32,
+0x00,0x0C,0xEC,0xC6,0xF0,0x04,0xF4,0x6D,0xFD,0x05,0x0A,0x0C,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,0x00,0x00,0x01,0xB8,
+};
+#endif /* SEQUENCER_UPDATE */
+#endif /* SAS_SEQUENCER_B0 */ 
diff -uNr linux-2.6.16.old/drivers/scsi/adp94xx/readme.txt linux-2.6.16/drivers/scsi/adp94xx/readme.txt
--- linux-2.6.16.old/drivers/scsi/adp94xx/readme.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/scsi/adp94xx/readme.txt	2007-04-05 23:35:00.000000000 +0000
@@ -0,0 +1,396 @@
+====================================================================
+=            Adaptec SAS/SATA Family Manager Set v1.0.8            =
+=                                                                  =
+= README for:                                                      =
+=                                                                  =
+= Red Hat Enterprise Linux 3.0 i686                                =
+= Red Hat Enterprise Linux 3.0 x86_64                              =
+= Red Hat Enterprise Linux 3.0 QU-5 i686                           =
+= Red Hat Enterprise Linux 3.0 QU-5 x86_64                         =
+= Red Hat Enterprise Linux 3.0 QU-6 i686                           =
+= Red Hat Enterprise Linux 3.0 QU-6 x86_64                         =
+= Red Hat Enterprise Linux 4.0 i686                                =
+= Red Hat Enterprise Linux 4.0 x86_64                              =
+= Red Hat Enterprise Linux 4.0 QU-1 i686                           =
+= Red Hat Enterprise Linux 4.0 QU-1 x86_64                         =
+= Red Hat Enterprise Linux 4.0 QU-2 i686                           =
+= Red Hat Enterprise Linux 4.0 QU-2 x86_64                         =
+= SuSE Linux Enterprise Server 9 i586                              =
+= SuSE Linux Enterprise Server 9 x86_64                            =
+= SuSE Linux Enterprise Server 9 SP-1 i586                         =
+= SuSE Linux Enterprise Server 9 SP-1 x86_64                       =
+= SuSE Linux Enterprise Server 9 SP-2 i586                         =
+= SuSE Linux Enterprise Server 9 SP-2 x86_64                       =
+= SuSE Linux Enterprise Server 9 SP-3 i586                         =
+= SuSE Linux Enterprise Server 9 SP-3 x86_64                       =
+= SuSE Linux Enterprise Server 10 i586                         =
+= SuSE Linux Enterprise Server 10 x86_64                       =
+= Novell Linux Desktop 9 i586                                      =
+= Novell Linux Desktop 9 SP-1 i586                                 =
+= Novell Linux Desktop 9 SP-1 x86_64                               =
+=                                                                  =
+====================================================================
+
+0. Supported Hardware
+
+   The following Adaptec SAS/SATA Host Adapters are supported by this 
+   driver set. 
+
+   SAS/SATA Adapters          Description
+   ----------------------------------------------------------------
+   AIC-9405                   Four port SAS and SATA 64-bit PCI-X
+                              133MHz ASIC.
+   AIC-9410                   Eight port SAS and SATA 64-bit PCI-X
+                              133MHz ASIC.
+
+
+1. Version History
+   1.0.8, Bug fixes.
+   1.0.7, Support for RazorLite
+   1.0.6, June 28th, 2005, Driver update.
+   1.0.0, November 1st, 2004, Initial driver release.
+
+1.1. Software/Hardware Features
+     - Support for the Serial Attached SCSI (SAS) protocol
+       as specified in T10/1562-D specification, Revision 5.
+     - Protocol supported: SSP, STP and SMP.
+     - Support for ATA/ATAPI protocols as specified in
+       ATA/ATAPI-7 V1, Revision 4b and ATA/ATAPI-7 V3,
+       Revision 4a.
+     - Protocol supported: SATA and ATAPI.
+     - Initiator Mode (target mode not currently supported)
+     - Support for the PCI-x standard up to 133MHz
+     - Support for the PCI v2.2 standard
+
+1.2. Operating System Support:
+
+   - Red Hat Enterprise Linux 3.0 QU-2 i686
+   - Red Hat Enterprise Linux 3.0 QU-4 i686
+   - Red Hat Enterprise Linux 3.0 QU-5 i686
+   - Red Hat Enterprise Linux 4.0 i686
+   - Red Hat Enterprise Linux 4.0 x86_64
+   - Red Hat Enterprise Linux 4.0 QU-1 i686
+   - Red Hat Enterprise Linux 4.0 QU-1 x86_64
+   - SuSE Linux Enterprise Server 9 i586
+   - SuSE Linux Enterprise Server 9 x86_64
+   - SuSE Linux Enterprise Server 9 SP-1 i586
+   - SuSE Linux Enterprise Server 9 SP-1 x86_64
+   - SuSE Linux Enterprise Server 9 SP-2 i586
+   - SuSE Linux Enterprise Server 9 SP-2 x86_64
+   - Novell Linux Desktop 9 i586
+   - Novell Linux Desktop 9 SP-1 i586
+   - Novell Linux Desktop 9 SP-1 x86_64
+
+     Refer to the User's Guide for more details.
+
+2. Installation Instructions
+
+2.1. Installing Red Hat Linux with a SAS/SATA Host Adapter
+
+     1) Install the SAS/SATA adapter and power on your
+     system.
+     2) Boot from the Red Hat CDROM.
+     3) At the boot menu, type 'linux dd' and press ENTER.
+     4) Follow the on-screen prompts to insert the Adaptec
+        Red Hat driver disk.
+     5) Proceed with the normal Red Hat installation steps.
+
+2.2. Installing SuSE Linux Enterprise Server or UnitedLinux
+     with a SAS/SATA Host Adapter
+
+     1) Install the SAS/SATA adapter and power on your system.
+     2) Boot from the SuSE CDROM.
+     3) At the boot menu, press the ALT key to stop the boot.
+        For SLES 9, use the F6 key instead of the ALT key.
+     4) Select installation and press 'Enter' and follow the on-screen
+        prompts to insert the Adaptec SuSE driver disk.
+     5) Proceed with the normal SuSE installation steps.
+
+2.3. Installing the Driver when Red Hat or SuSE is Already
+     Installed
+
+     1) Download the Adaptec driver RPM file appropriate to
+        your version of Red Hat/SuSE.
+     2) From a shell prompt, type: rpm -ivh <RPM file> to perform a fresh
+        install, or rpm -Uvh <RPM file> to upgrade to a newer driver.
+     3) Make sure to reboot the system by issuing the
+        command "shutdown -h now". After the system reboots,
+        the procedure is then done.
+ 
+2.4. Removing the Driver
+
+     Removing the Adaptec SAS/SATA driver is not presently supported.
+
+3. Command Line Options
+
+   WARNING: ALTERING OR ADDING THESE DRIVER PARAMETERS
+            INCORRECTLY CAN RENDER YOUR SYSTEM INOPERABLE.
+            USE THEM WITH CAUTION. 
+
+   Edit the file "modules.conf" or "modprobe.conf.local" in the
+   directory /etc and add/edit a line containing
+	     options adp94xx adp94xx=parameter[,parameter,...]
+   "parameter" is one or more of the following:
+
+   cmd_per_lun:<int>
+	Global tag depth for all targets on all ports.
+	This option sets the default tag depth for all
+	targets if they support tag-queueing.
+	Default Value: 32, range 1 to 64.
+
+   attach_HostRAID:<int>
+	Controls whether the driver should atttach to
+	HostRAID enabled controllers.
+	Default: 0, false, the driver would *not* attach to
+	RAID enabled controllers.  To make the driver
+	attach to RAID controllers, turn this on by setting
+	it to 1.
+
+   Example: 
+      options adp94xx adp94xx=cmd_per_lun:12,attach_HostRAID:1
+
+   Sets the queue depth to 12 for all targets that support
+   tag-queueing, and instructs the driver not to attach to
+   RAID enabled controllers.
+
+4. Additional Notes
+
+4.1. Known/Unresolved or FYI Issues
+
+4.2. Third-Party Compatibility Issues
+
+     Adaptec only supports SAS and SATA hard drives running
+     the latest firmware available. Please check with your
+     hard drive manufacturer to ensure you have the latest
+     version.
+
+4.3. Operating System or Technology Limitations
+
+     * PCI Hot Plug is untested, use at your own risk!
+
+     * Sparse LUN space may not be automatically probed.
+       This is a limitation of some kernels.  Contact your
+       OS vendor for support on this.
+
+     * Using the Driver Update Disk version of this package
+       during OS installation under Red Hat might result in
+       two versions of this driver being installed into the
+       system module directory.  This might cause problems
+       with the /sbin/mkinitrd program and/or other RPM
+       packages that try to install system modules.  The
+       best way to correct this once the system is running
+       is to install the latest RPM package version of this
+       driver, available from http://www.adaptec.com/.
+
+     * When updating with the kernel-hugemem-2.4.21-
+       32.EL.i686.rpm under Red Hat, because the kernel-
+       hugemem-2.4.21-32.EL.i686.rpm contains only those 
+       embedded drivers and doesn't give users a chance to 
+       load additional drivers, users have to perform the 
+       following: 
+
+       -Backup /etc/modules.conf
+       cp modules.conf modules.conf.bkup
+
+       -Remove adp94xx entry from modules.conf using editor
+
+       -Install hugemem kernel
+       rpm -ivh kernel-hugemem-VERSION.rpm
+
+       -Restore original modules.conf
+       cp modules.conf.bkup modules.conf
+
+       -Install adaptec driver
+       rpm -ivh adp94xx-VERISON.rpm
+
+4.4. Controlling Boot order on non SES-2 systems
+
+    Linux discovers drives by walking sequentially through
+    each channel/target/lun of the host adapter, mapping the
+    drives that it finds sequentially to sda, sdb, sdc, etc.
+    SAS, on the other hand, does not guarantee what order
+    drives will be discovered, or appear.  Because of this
+    "drive drift" (different than migration) a mechanism is
+    needed to guarantee that SAS drives will be consistently
+    mapped to device names.  The Razor BIOS provides a
+    mechanism for determining what order drives have been
+    reported to the system BIOS.  Because of the different
+    mechanisms that system BIOS vendors use to manage
+    devices in BIOS and because of the limited size of the
+    Razor OCM structures, the Razor BIOS structures can not
+    be use to consistently map all drives to a unique device
+    name that persists across boots.
+
+    The only way to solve the problem of "drive drift" is to
+    require that users assign a UUID or label to the
+    filesystems on their drives.  In addition, because swap
+    does not support labels or UUIDs, we should recommend
+    that the users use swap files instead of swap
+    partitions.
+
+    Labels:
+
+    The reason why drive name mapping is an issue results
+    from the way that Linux approaches assigning mount
+    points to filesystems.  Linux uses the /etc/fstab file
+    in order to map device names to mount points.  Normally
+    the fstab file is populated with lines that look
+    something like:
+
+        /dev/sdb2 /users ext3 defaults 0 0
+
+    Unless specified in the options field (field number 4),
+    the filesystems that are listed in /etc/fstab are
+    automatically mounted by the init scripts as the system
+    changes states into multi-user mode.  Unfortunately,
+    technologies like SAS and Fibre Channel do not guarantee
+    what order drives will be presented to the system.  As a
+    result, a drive that was mapped to /dev/sdb on one boot
+    might be mapped to a completely different device name
+    after a subsequent reboot.  To address this issue, Linux
+    has added filesystem labels and UUIDs (Universally
+    Unique Identifier).  The main difference between
+    filesystem labels and UUIDs is that filesystem labels
+    are generated by the user, and UUIDs are generated
+    automatically.  For simplicity, this document will refer
+    to filesystem labels and UUIDs as "labels".  Once a
+    filesystem has a label, the administrator can then
+    specify that filesystem by its label instead or its
+    device name.  For example:
+
+    # mount UUID=754b0958-f447-490b-9ae2-551987bc31a9 /users
+    # mount LABEL=mylabel /users
+
+    Regardless of what drive mapping has been assigned to
+    the drive that has the filesystem that contains the
+    label specified, mount will find the filesystem and
+    mount it.  In addition, the administrator can create
+    entries in /etc/fstab that look like:
+
+    UUID=754b0958-f447-490b-9ae2-551987bc31a9 /users ext3 defaults 0 0
+    LABEL=mylabel /users ext3 defaults 0 0
+
+    Suse allows the user who is installing the operating
+    system to specify that a label should be used for the
+    root filesystem.  The user needs to select the 'fstab
+    options' button when preparing the boot disk in YaST.
+    In the fstab options popup the user will be allowed to
+    assign a label or UUID to the filesystem.  During the
+    process of installing the system, the install program
+    will embed the label for the root filesystem in the
+    linuxrc script in initrd.
+
+    The filesystem creation utilities support labels.
+    Reiserfs will automatically create a UUID for a
+    filesystem, regardless of whether it is being used in
+    fstab.  The user can specify the UUID using the '-u'
+    option to mkreiserfs, or they can specifiy a label by
+    using the '-l' option.  The user can determine the label
+    of a filesystem by using the dumpe2fs or debugreiserfs
+    user level commands.
+
+    Swap:
+
+    Currently, the mount utility only supports labels on
+    ext2, ext3 and xfs.  Suse has added a patch that
+    supports reiserfs (Suse's default filesystem).  Any
+    other filesystem type will not be be automatically
+    mounted as the system transitions to multiuser.
+    Unfortunately, swap labeling is not supported.  In
+    Linux, a swap device can be a filesystem or a file.  TO
+    ensure that the swap file is always correctly identified
+    during drive drift, the user should use swap files
+    instead of swap partitions.  In order to use a file for
+    swap, the user needs to create a file that will be used
+    for swap.  For example, to create a 256M zero
+    initialized file and prepare it for the swap subsystem,
+    the user might execute the following commands:
+
+     # dd if=/dev/zero of=/swapfile bs=1k count=262144
+     # mkswap /swapfile
+
+    After creating the swap file, the user would then edit
+    the fstab file, remove the swap line and add the
+    following line:
+
+    /swapfile swap swap pri=42 0 0
+
+    To notify the kernel about the new swap file, the user
+    would execute the following command:
+
+     # swapon -a
+
+    In the future, there is space that is reserved for a
+    label in the swap header.
+
+5. Contacting Adaptec
+
+   A Technical Support Identification (TSID) Number is required for 
+   Adaptec technical support.
+    - The 12-digit TSID can be found on the white barcode-type label
+      included inside the box with your product. The TSID helps us 
+      provide more efficient service by accurately identifying your 
+      product and support status.
+   Support Options
+    - Search the Adaptec Support Knowledgebase (ASK) at
+      http://ask.adaptec.com for articles, troubleshooting tips, and
+      frequently asked questions for your product.
+    - For support via Email, submit your question to Adaptec's 
+      Technical Support Specialists at http://ask.adaptec.com.
+     
+   North America
+    - Visit our Web site at http://www.adaptec.com.
+    - To speak with a Fibre Channel/RAID/External Storage Technical
+      Support Specialist, call 1-321-207-2000,
+      Hours: Monday-Friday, 3:00 A.M. to 5:00 P.M., PST.
+      (Not open on holidays)
+    - For Technical Support in all other technologies including 
+      SAS, call 1-408-934-7274,
+      Hours: Monday-Friday, 6:00 A.M. to 5:00 P.M., PST.
+      (Not open on holidays)
+    - For after hours support, call 1-800-416-8066 ($99/call, 
+      $149/call on holidays)
+    - To order Adaptec products including software and cables, call
+      1-800-442-7274 or 1-408-957-7274. You can also visit our 
+      online store at http://www.adaptecstore.com
+
+   Europe
+    - Visit our Web site at http://www.adaptec-europe.com.
+    - English and French: To speak with a Technical Support 
+      Specialist, call one of the following numbers:
+        - English: +32-2-352-3470
+        - French:  +32-2-352-3460
+      Hours: Monday-Thursday, 10:00 to 12:30, 13:30 to 17:30 CET 
+             Friday, 10:00 to 12:30, 13:30 to 16:30 CET
+    - German: To speak with a Technical Support Specialist,
+      call +49-89-456-40660
+      Hours: Monday-Thursday, 09:30 to 12:30, 13:30 to 16:30 CET
+             Friday, 09:30 to 12:30, 13:30 to 15:00 CET
+    - To order Adaptec products, including accessories and cables:
+        - UK: +0800-96-65-26 or fax +0800-731-02-95
+        - Other European countries: +32-11-300-379
+
+   Australia and New Zealand
+    - Visit our Web site at http://www.adaptec.com.au.
+    - To speak with a Technical Support Specialist, call 
+      +612-9416-0698
+      Hours: Monday-Friday, 10:00 A.M. to 4:30 P.M., EAT
+      (Not open on holidays)
+
+   Japan
+    - To speak with a Technical Support Specialist, call 
+      +81-3-5308-6120 
+      Hours: Monday-Friday, 9:00 a.m. to 12:00 p.m., 1:00 p.m. to
+      6:00 p.m. TSC
+
+   Hong Kong and China
+    - To speak with a Technical Support Specialist, call 
+      +852-2869-7200
+      Hours: Monday-Friday, 10:00 to 17:00.
+    - Fax Technical Support at +852-2869-7100.
+
+   Singapore
+    - To speak with a Technical Support Specialist, call 
+      +65-245-7470
+      Hours: Monday-Friday, 10:00 to 17:00.
+    - Fax Technical Support at +852-2869-7100
