diff -Nurw linux-2.6.10/drivers/media/em8300/adv717x.c linux-2.6.10-em8300/drivers/media/em8300/adv717x.c
--- linux-2.6.10/drivers/media/em8300/adv717x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/adv717x.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,586 @@
+/* 
+   ADV7175A - Analog Devices ADV7175A video encoder driver version 0.0.3
+
+   Copyright (C) 2000 Henrik Johannson <henrikjo@post.utfors.se>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <asm/segment.h>
+#include <linux/types.h>
+
+#include <linux/videodev.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/video_encoder.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+
+#include "adv717x.h"
+#include "encoder.h"
+
+MODULE_SUPPORTED_DEVICE("adv717x");
+MODULE_LICENSE("GPL");
+
+#ifdef CONFIG_ADV717X_PIXELPORT16BIT
+int pixelport_16bit = 1;
+#else
+int pixelport_16bit = 0;
+#endif
+MODULE_PARM(pixelport_16bit, "i");
+MODULE_PARM_DESC(pixelport_16bit, "Changes how the ADV717x expects its input data to be formatted. If the colours on the TV appear green, try changing this. Defaults to 1.");
+
+#ifdef CONFIG_ADV717X_PIXELPORTPAL
+int pixelport_other_pal = 1;
+#else
+int pixelport_other_pal = 0;
+#endif
+MODULE_PARM(pixelport_other_pal, "i");
+MODULE_PARM_DESC(pixelport_other_pal, "If this is set to 1, then the pixelport setting is swapped for PAL from the setting given with pixelport_16bit. Defaults to 1.");
+
+int pixeldata_adjust_ntsc = 1;
+MODULE_PARM(pixeldata_adjust_ntsc, "i");
+MODULE_PARM_DESC(pixeldata_adjust_ntsc, "If your red and blue colours are swapped in NTSC, try setting this to 0,1,2 or 3. Defaults to 1.");
+
+int pixeldata_adjust_pal = 1;
+MODULE_PARM(pixeldata_adjust_pal, "i");
+MODULE_PARM_DESC(pixeldata_adjust_pal, "If your red and blue colours are swapped in PAL, try setting this to 0,1,2 or 3. Defaults to 1.");
+
+static int color_bars = 0;
+MODULE_PARM(color_bars, "i");
+MODULE_PARM_DESC(color_bars, "If you set this to 1 a set of color bars will be displayed on your screen (used for testing if the chip is working). Defaults to 0.");
+
+#define i2c_is_isa_client(clientptr) \
+		((clientptr)->adapter->algo->id == I2C_ALGO_ISA)
+#define i2c_is_isa_adapter(adapptr) \
+		((adapptr)->algo->id == I2C_ALGO_ISA)
+
+
+#define ADV7175_REG_MR0 0
+#define ADV7175_REG_MR1 1
+#define ADV7175_REG_TTXRQ_CTRL 0x24
+
+static int adv717x_attach_adapter(struct i2c_adapter *adapter);
+static int adv717x_detach_client(struct i2c_client *client);
+static int adv717x_command(struct i2c_client *client, unsigned int cmd, void *arg);
+
+#define CHIP_ADV7175A 1
+#define CHIP_ADV7170  2
+
+struct adv717x_data_s {
+	int chiptype;
+	int mode;
+	int bars;
+	int rgbmode;
+	int enableoutput;
+
+	unsigned char config[32];
+	int configlen;
+};
+
+/* This is the driver that will be inserted */
+static struct i2c_driver adv717x_driver = {
+	.owner            = THIS_MODULE,
+	.name             = "adv717x",
+	.id	         = I2C_DRIVERID_ADV717X,
+	.flags 	         = I2C_DF_NOTIFY,
+	.attach_adapter   = &adv717x_attach_adapter,
+	.detach_client    = &adv717x_detach_client,
+	.command          = &adv717x_command,
+};
+
+int adv717x_id = 0;
+
+static unsigned char PAL_config_7170[27] = {
+	0x05,   // Mode Register 0
+	0x00,   // Mode Register 1 (was: 0x07)
+	0x02,   // Mode Register 2 (was: 0x48)
+	0x00,   // Mode Register 3
+	0x00,   // Mode Register 4
+	0x00,   // Reserved
+	0x00,   // Reserved
+	0x0d,   // Timing Register 0
+	0x77,   // Timing Register 1
+	0xcb,   // Subcarrier Frequency Register 0
+	0x8a,   // Subcarrier Frequency Register 1
+	0x09,   // Subcarrier Frequency Register 2
+	0x2a,   // Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register 
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0 
+	0x00,   // Closed Captioning Register 1 
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x00,	// CGMS_WSS Reg 0
+	0x00,	// CGMS_WSS Reg 1
+	0x00,	// CGMS_WSS Reg 2
+	0x00	// TeleText Control Register
+};
+
+static unsigned char NTSC_config_7170[27] = {
+	0x10,   // Mode Register 0
+	0x06,   // Mode Register 1
+	0x08,   // Mode Register 2
+	0x00,   // Mode Register 3
+	0x00,   // Mode Register 4
+	0x00,   // Reserved
+	0x00,   // Reserved
+	0x0d,   // Timing Register 0
+	0x77,   // Timing Register 1
+	0x16,   // Subcarrier Frequency Register 0
+	0x7c,   // Subcarrier Frequency Register 1
+	0xf0,   // Subcarrier Frequency Register 2
+	0x21,   // Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register 
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0 
+	0x00,   // Closed Captioning Register 1 
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x00,	// CGMS_WSS Reg 0
+	0x00,	// CGMS_WSS Reg 1
+	0x00,	// CGMS_WSS Reg 2
+	0x00	// TeleText Control Register
+};
+
+static unsigned char PAL_M_config_7175[19] = {   //These need to be tested
+	0x06,   // Mode Register 0
+	0x00,   // Mode Register 1
+	0xa3,   // Subcarrier Frequency Register 0
+	0xef, 	// Subcarrier Frequency Register 1
+	0xe6, 	// Subcarrier Frequency Register 2
+	0x21,  	// Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register
+	0x0d,   // Timing Register 0
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0
+	0x00,   // Closed Captioning Register 1
+	0x70, 	// Timing Register 1
+	0x73,  	// Mode Register 2
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x42,   // Mode Register 3
+};
+
+static unsigned char PAL_config_7175[19] = {
+	0x01,   // Mode Register 0
+	0x06,   // Mode Register 1
+	0xcb,   // Subcarrier Frequency Register 0
+	0x8a,   // Subcarrier Frequency Register 1
+	0x09,   // Subcarrier Frequency Register 2
+	0x2a,   // Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register 
+	0x0d,   // Timing Register 0
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0 
+	0x00,   // Closed Captioning Register 1 
+	0x73,   // Timing Register 1
+	0x08,   // Mode Register 2
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x42,   // Mode Register 3
+};
+
+static unsigned char PAL60_config_7175[19] = {
+	0x12,   // Mode Register 0
+	0x0,	// Mode Register 1
+	0xcb,   // Subcarrier Frequency Register 0
+	0x8a,   // Subcarrier Frequency Register 1
+	0x09,   // Subcarrier Frequency Register 2
+	0x2a,   // Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register 
+	0x0d,   // Timing Register 0
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0 
+	0x00,   // Closed Captioning Register 1 
+	0x73,   // Timing Register 1
+	0x08,   // Mode Register 2
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x42,   // Mode Register 3
+};
+
+static unsigned char NTSC_config_7175[19] = {
+	0x04,   // Mode Register 0
+	0x00,   // Mode Register 1
+	0x16,   // Subcarrier Frequency Register 0
+	0x7c, 	// Subcarrier Frequency Register 1
+	0xf0, 	// Subcarrier Frequency Register 2
+	0x21,  	// Subcarrier Frequency Register 3
+	0x00,   // Subcarrier Phase Register
+	0x0d,   // Timing Register 0
+	0x00,   // Closed Captioning Ext Register 0
+	0x00,   // Closed Captioning Ext Register 1
+	0x00,   // Closed Captioning Register 0
+	0x00,   // Closed Captioning Register 1
+	0x77,  	// Timing Register 1
+	0x00, 	// Mode Register 2
+	0x00,   // Pedestal Control Register 0
+	0x00,   // Pedestal Control Register 1
+	0x00,   // Pedestal Control Register 2
+	0x00,   // Pedestal Control Register 3
+	0x42,   // Mode Register 3
+};
+
+static int adv717x_update(struct i2c_client *client)
+{
+	struct adv717x_data_s *data = i2c_get_clientdata(client);
+	char tmpconfig[32];
+	int n, i;
+
+	memcpy(tmpconfig, data->config, data->configlen);
+
+	tmpconfig[1] |= data->bars ? 0x80 : 0;
+
+	switch(data->chiptype) {
+	case CHIP_ADV7175A:
+		if (data->rgbmode) {
+			tmpconfig[0] |= 0x40;
+		}
+		break;
+	case CHIP_ADV7170:
+		if (data->rgbmode) {
+			tmpconfig[3] |= 0x10;
+		}
+		break;
+	}
+	
+	if (!data->enableoutput) {
+		tmpconfig[1] |= 0x7f;
+	}
+	
+	for(i=0; i < data->configlen; i++) {
+		n = i2c_smbus_write_byte_data(client, i, tmpconfig[i]);
+	}
+
+	i2c_smbus_write_byte_data(client, 7, tmpconfig[7] & 0x7f);
+	i2c_smbus_write_byte_data(client, 7, tmpconfig[7] | 0x80);
+	i2c_smbus_write_byte_data(client, 7, tmpconfig[7] & 0x7f);
+
+	return 0;
+}
+
+static int adv717x_setmode(int mode, struct i2c_client *client) {
+	struct adv717x_data_s *data = i2c_get_clientdata(client);
+	unsigned char *config = NULL;
+
+	pr_debug("adv717x_setmode(%d,%p)\n", mode, client);
+	
+	switch (mode) {
+	case ENCODER_MODE_PAL:
+		printk(KERN_DEBUG "adv717x.o: Configuring for PAL\n");
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			config = PAL_config_7175;
+			data->configlen = sizeof(PAL_config_7175);
+			break;
+		case CHIP_ADV7170:
+			config = PAL_config_7170;
+			data->configlen = sizeof(PAL_config_7170);
+			break;
+		}
+		break;
+	case ENCODER_MODE_PAL_M:
+		printk(KERN_DEBUG "adv717x.o: Configuring for PALM\n");
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			config = PAL_config_7175;
+			data->configlen = sizeof(PAL_M_config_7175);
+			break;
+		case CHIP_ADV7170:
+			config = PAL_config_7170;
+			data->configlen = sizeof(PAL_config_7170);
+			break;
+		}
+		break;
+	case ENCODER_MODE_PAL60:
+		printk(KERN_DEBUG "adv717x.o: Configuring for PAL 60\n");
+		switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			config = PAL60_config_7175;
+			data->configlen = sizeof(PAL60_config_7175);
+			break;
+		case CHIP_ADV7170:
+			config = PAL_config_7170;
+			data->configlen = sizeof(PAL_config_7170);
+			break;
+		}
+		break;
+	case ENCODER_MODE_NTSC:
+		printk(KERN_DEBUG "adv717x.o: Configuring for NTSC\n");
+	 	switch (data->chiptype) {
+		case CHIP_ADV7175A:
+			config = NTSC_config_7175;
+			data->configlen = sizeof(NTSC_config_7175);
+			break;
+		case CHIP_ADV7170:
+			config = NTSC_config_7170;
+			data->configlen = sizeof(NTSC_config_7170);
+			break;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	data->mode = mode;
+
+	if (config) {
+		memcpy(data->config, config, data->configlen);
+	}
+
+	return 0;
+}
+
+static int adv717x_setup(struct i2c_client *client)
+{
+	struct adv717x_data_s *data = i2c_get_clientdata(client);
+	
+	memset(data->config, 0, sizeof(data->config));
+
+	data->bars = 0;
+	data->rgbmode = 0;
+	data->enableoutput = 0;
+
+	adv717x_setmode(ENCODER_MODE_PAL60, client);
+	
+	adv717x_update(client);
+	
+	return 0;
+}
+
+static int adv717x_detect(struct i2c_adapter *adapter, int address)
+{
+	struct i2c_client *new_client;
+	struct adv717x_data_s *data;
+	int mr0, mr1;
+	int err;
+
+	if (i2c_is_isa_adapter(adapter)) {
+		dev_err(&adapter->dev,
+			"adv717x_detect called for an ISA bus adapter?!?\n");
+		return 0;
+	}
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {
+		return 0;
+	}
+	 
+	if (!(new_client = kmalloc(sizeof(struct i2c_client) +
+				sizeof(struct adv717x_data_s),
+				GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	memset(new_client,0x00, sizeof(struct i2c_client) +
+	                        sizeof(struct adv717x_data_s));
+	data = (struct adv717x_data_s *) (new_client + 1);
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &adv717x_driver;
+	new_client->flags = 0;
+
+	i2c_smbus_write_byte_data(new_client, ADV7175_REG_MR1, 0x55);
+	mr1=i2c_smbus_read_byte_data(new_client, ADV7175_REG_MR1);
+	 
+	if (mr1 == 0x55) {
+		mr0 = i2c_smbus_read_byte_data(new_client, ADV7175_REG_MR0);
+
+		if (mr0 & 0x20) {
+			strncpy(new_client->name, "ADV7175A chip", DEVICE_NAME_SIZE);
+			data->chiptype = CHIP_ADV7175A;
+			printk(KERN_NOTICE "adv717x.o: ADV7175A chip detected\n");
+		} else {
+			strncpy(new_client->name, "ADV7170 chip", DEVICE_NAME_SIZE);
+			data->chiptype = CHIP_ADV7170;
+			printk(KERN_NOTICE "adv717x.o: ADV7170 chip detected\n");
+		}
+	 
+		new_client->id = adv717x_id++;
+
+		if ((err = i2c_attach_client(new_client))) {
+			kfree(new_client);
+			return err;
+		}
+
+		adv717x_setup(new_client);
+
+		return 0;
+	} 
+	kfree(new_client);
+
+	return 0;			  
+}
+
+static int adv717x_attach_adapter(struct i2c_adapter *adapter)
+{
+	if (!(adapter->class & I2C_CLASS_TV_ANALOG))
+		return 0;
+
+	adv717x_detect(adapter, 0x6a);
+	adv717x_detect(adapter, 0x7a);
+	adv717x_detect(adapter, 0xa);
+	return 0;
+}
+
+
+static int adv717x_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	pr_debug("adv717x_detach_client 1\n");
+	if ((err = i2c_detach_client(client))) {
+		dev_err(&client->dev,
+		"adv717x: Client deregistration failed, client not detached.\n");
+		return err;
+	}
+
+	pr_debug("adv717x_detach_client 2\n");
+	kfree(client);
+	pr_debug("adv717x_detach_client 3\n");
+
+	return 0;
+}
+
+static int adv717x_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	struct adv717x_data_s *data = i2c_get_clientdata(client);
+
+	switch (cmd) {
+	case ENCODER_CMD_SETMODE:
+		adv717x_setmode((int) arg, client);
+		adv717x_update(client);
+		break;
+	case ENCODER_CMD_ENABLEOUTPUT:
+		data->enableoutput = (int) arg;
+		adv717x_update(client);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+
+static int __init adv717x_init(void)
+{
+	int pp_ntsc;
+	int pp_pal;
+	int pd_adj_ntsc;
+	int pd_adj_pal;
+	int bars;
+
+	if (pixelport_16bit) {
+		pp_ntsc = pp_pal = 0x40;
+		if (pixelport_other_pal) {
+			pp_pal = 0x00;
+		}
+	} else {
+		pp_ntsc = pp_pal = 0x00;
+		if (pixelport_other_pal) {
+			pp_pal = 0x40;
+		}
+	}
+
+	pd_adj_ntsc = (0x03 & pixeldata_adjust_ntsc ) << 6;
+	pd_adj_pal = (0x03 & pixeldata_adjust_pal ) << 6;
+	
+	//      rb_pal = 0xA0;
+
+	if (color_bars) {
+		bars = 0x80;
+	} else {
+		bars = 0x00;
+	}
+
+	pr_debug("adv717x.o: pixelport_16bit: %d\n", pixelport_16bit);
+	pr_debug("adv717x.o: pixelport_other_pal: %d\n", pixelport_other_pal);
+	pr_debug("adv717x.o: pixeldata_adjust_pal: %d\n", pixeldata_adjust_pal);
+	pr_debug("adv717x.o: pixeldata_adjust_ntsc: %d\n", pixeldata_adjust_ntsc);
+	pr_debug("adv717x.o: color_bars: %d\n", color_bars);
+
+	PAL_config_7170[7] = (PAL_config_7170[7] & ~0x40) | pp_pal;
+	NTSC_config_7170[7] = (NTSC_config_7170[7] & ~0x40) | pp_ntsc;
+	PAL_M_config_7175[7] = (PAL_M_config_7175[7] & ~0x40) | pp_pal;
+	PAL_config_7175[7] = (PAL_config_7175[7] & ~0x40) | pp_pal;
+	PAL60_config_7175[7] = (PAL60_config_7175[7] & ~0x40) | pp_pal;
+	NTSC_config_7175[7] = (NTSC_config_7175[7] & ~0x40) | pp_ntsc;
+
+	PAL_config_7170[12] = (PAL_config_7170[12] & ~0xC0) | pd_adj_pal;
+	NTSC_config_7170[12] = (NTSC_config_7170[12] & ~0xC0) | pd_adj_ntsc;
+	PAL_M_config_7175[12] = (PAL_M_config_7175[12] & ~0xC0) | pd_adj_pal;
+	PAL_config_7175[12] = (PAL_config_7175[12] & ~0xC0) | pd_adj_pal;
+	PAL60_config_7175[12] = (PAL60_config_7175[12] & ~0xC0) | pd_adj_pal;
+	NTSC_config_7175[12] = (NTSC_config_7175[12] & ~0xC0) | pd_adj_ntsc;
+
+
+	PAL_config_7170[1] = (PAL_config_7170[1] & ~0x80) | bars;
+	NTSC_config_7170[1] = (NTSC_config_7170[1] & ~0x80) | bars;
+	PAL_M_config_7175[1] = (PAL_M_config_7175[1] & ~0x80) | bars;
+	PAL_config_7175[1] = (PAL_config_7175[1] & ~0x80) | bars;
+	PAL60_config_7175[1] = (PAL60_config_7175[1] & ~0x80) | bars;
+	NTSC_config_7175[1] = (NTSC_config_7175[1] & ~0x80) | bars;
+
+	//request_module("i2c-algo-bit");
+	return i2c_add_driver(&adv717x_driver);
+}
+
+static void __exit adv717x_cleanup(void)
+{
+	i2c_del_driver(&adv717x_driver);
+}
+
+module_init(adv717x_init);
+module_exit(adv717x_cleanup);
+
diff -Nurw linux-2.6.10/drivers/media/em8300/adv717x.h linux-2.6.10-em8300/drivers/media/em8300/adv717x.h
--- linux-2.6.10/drivers/media/em8300/adv717x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/adv717x.h	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1 @@
+#define I2C_DRIVERID_ADV717X 0xf000
diff -Nurw linux-2.6.10/drivers/media/em8300/bt865.c linux-2.6.10-em8300/drivers/media/em8300/bt865.c
--- linux-2.6.10/drivers/media/em8300/bt865.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/bt865.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,1005 @@
+/* 
+   BT865A - Brook Tree BT865A video encoder driver version 0.0.4
+
+   Henrik Johannson <henrikjo@post.utfors.se>
+   As modified by Chris C. Hoover <cchoover@home.com>
+
+   Modified by Luis Correia <lfcorreia@users.sourceforge.net>
+   added rgb_mode (requires hacking DXR3 hardware)
+   
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <asm/segment.h>
+#include <linux/types.h>
+
+#include <linux/videodev.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/video_encoder.h>
+
+#include "bt865.h"
+#include "encoder.h"
+
+MODULE_SUPPORTED_DEVICE("bt865");
+
+static int color_bars = 0;
+MODULE_PARM(color_bars, "i");
+MODULE_PARM_DESC(color_bars, "If you set this to 1 a set of color bars will be displayed on your screen (used for testing if the chip is working). Defaults to 0.");
+
+static int rgb_mode = 0;
+MODULE_PARM(rgb_mode, "i");
+MODULE_PARM_DESC(rgb_mode, "If you set this to 1, RGB output is enabled. You will need to hack the DXR3 hardware. Defaults to 0.");
+
+MODULE_LICENSE("GPL");
+
+#define i2c_is_isa_client(clientptr) \
+		((clientptr)->adapter->algo->id == I2C_ALGO_ISA)
+#define i2c_is_isa_adapter(adapptr) \
+		((adapptr)->algo->id == I2C_ALGO_ISA)
+
+
+static int bt865_attach_adapter(struct i2c_adapter *adapter);
+int bt865_detach_client(struct i2c_client *client);
+int bt865_command(struct i2c_client *client, unsigned int cmd, void *arg);
+static int bt865_setup(struct i2c_client *client);
+
+struct bt865_data_s {
+	int chiptype;
+	int mode;
+	int bars;
+	int rgbmode;
+	int enableoutput;
+
+	unsigned char config[48];
+	int configlen;
+};
+
+/* This is the driver that will be inserted */
+static struct i2c_driver bt865_driver = {
+	.owner          = THIS_MODULE,
+	.name           = "BT865 video encoder driver",
+	.id             = I2C_DRIVERID_BT865,
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = &bt865_attach_adapter,
+	.detach_client  = &bt865_detach_client,
+	.command        = &bt865_command,
+};
+
+int bt865_id = 0;
+
+// Register settings come from Rockwell Semiconductor 
+// Advance Information sheet l865a.pdf
+
+// Bits from the Left for Register A0
+// 1. one bit EWSF2 (Enable Wide Screen for Field 2)
+//    enable/disable Wide Screen Signaling/Copy Generation Management 
+//    System encoding for field 2 (16:9)
+//    if 0 then Disable WSS/CGMS for Field 2
+//    if 1 then Enable WSS/CGMS for Field 2
+// 2. one bit EWSF1 (Enable Wide Screen for Field 1)
+//    enable/disable Wide Screen Signaling/Copy Generation Management 
+//    System encoding for field 1 (16:9)
+//    if 0 then Disable WSS/CGMS for Field 1
+//    if 1 then Enable WSS/CGMS for Field 1
+// 3. two reserved bits, zero for normal operation
+//    this should have been done by the reset above
+// 4. four bits of WSDAT[1:4] (Wide Screen Data)
+
+// Bits from the Left for Register A2
+// 1. eight bits of WSDAT[5:12] (Wide Screen Data)
+
+// Bits from the Left for Register A4
+// 1. eight bits of WSDAT[13:20] (Wide Screen Data)
+//    there is a typo in the document here. it Should Say A4
+
+// Bits from the Left for Register A6
+// 1. one bit SRESET (System Reset)
+//    if 0 then Do Nothing
+//    if 1 then Reset All Registers (including this one) To Zero
+// 2. seven reserved bits, zero for normal operation
+//    this should be done by the reset anyway
+
+// Bits from the Left for Register A8
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register AA
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register AC
+// 1. eight bits TXHS[7:0] (Rising Edge Position of TeleText Request Pin)
+//    first eight bits of eleven
+
+// Bits from the Left for Register AE
+// 1. eight bits TXHE[7:0] (Falling Edge Position of TeleText Request Pin)
+//    first eight bits of eleven
+
+// Bits from the Left for Register B0
+// 1. two bits LUMADLY[1:0] (Luminance Delay Mode, B Output)
+//    D7   D6             Function
+//    ----------------------------
+//    0    0              No Delay
+//    0    1              1 Pixel Clock Delay
+//    1    0              2 Pixel Clock Delay
+//    1    1              3 Pixel Clock Delay
+//    used to program the Luminance Delay on the CVBS/B Output
+// 2. three bits TXHE[10:8] (Last Three Bits Teletext Falling Edge) 
+//    (Falling Edge Position of TeleText Request Pin)
+// 3. three bits TXHS[10:8] (Last Three Bits Teletext Rising Edge) 
+//    (Rising Edge Position of TeleText Request Pin)
+// (It's a programmable pulse generator)
+
+// Bits from the Left for Register B2
+// 1. two reserved bits, zero for normal operation
+//    this should have been done by the reset above
+// 2. one bit TXRM (Teletext Request Mode)
+//    if 0 then TTXREQ Pin outputs Request
+//    if 1 then TTXREQ Pin outputs TTX Clock
+// 3. one bit TXE (Teletext Enable)
+//    if 0 then Disable Teletext
+//    if 1 then Enable Teletext
+// 4. one bit TXEF2[8] (Last Line of Teletext Field 2 (last bit)) 
+// 5. one bit TXBF2[8] (First Line of Teletext Field 2 (last bit)) 
+// 6. one bit TXEF1[8] (Last Line of Teletext Field 1 (last bit)) 
+// 7. one bit TXBF1[8] (First Line of Teletext Field 1 (last bit)) 
+
+// Bits from the Left for Register B4
+// 1. eight bits TXBF1[7:0] (First Line of Teletext Field 1 
+//    (first eight bits))
+
+// Bits from the Left for Register B6
+// 1. eight bits TXEF1[7:0] (Last Line of Teletext Field 1 
+//    (first eight bits))
+
+// Bits from the Left for Register B8
+// 1. eight bits TXBF2[7:0] (First Line of Teletext Field 2 
+//    (first eight bits))
+
+// Bits from the Left for Register BA
+// 1. eight bits TXEF2[7:0] (Last Line of Teletext Field 2
+//    (first eight bits))
+
+// Bits from the Left for Register BC
+// 1. one bit ECCF2 (Enable Closed Caption Encoding on Field 2) 
+//    if 0 then Disable Closed Caption Encoding on Field 2
+//    if 1 then Enable Closed Caption Encoding on Field 2
+// 2. one bit ECCF1 (Enable Closed Caption Encoding on Field 1) 
+//    if 0 then Disable Closed Caption Encoding on Field 1
+//    if 1 then Enable Closed Caption Encoding on Field 1
+// 3. one bit ECCGATE (Closed Caption Mode)
+//    if 0 then Normal Closed Caption Encoding 
+//    if 1 then Prevent Encoding of Redundant or Incomplete Data
+//         Future Encoding is Disabled Until a Complete Pair of 
+//         New Data Bytes is Received
+// 4. one reserved bit, zero for normal operation
+//    this should have been done by the reset above
+//    this is the bit that the original code mysteriously sets to one
+// 5. one bit DACOFF (Turn Off DAC)
+//    used to Limit Curent Consumption to Digital Circuits Only
+//    if 0 then Normal Operation
+//    if 1 then Disable DAC Output Current and Internal Voltage Reference
+//    This Bit is Forced High After Powerup Until Either 8 Fields Have
+//    Been Output or Register 0xCE Has Been Written
+// 6. one bit YC16 (YC Mode)
+//    if 0 then 8 Bit Mode: P[7:0] is Multiplexed YCrCb 8 Bit Video Data
+//    if 1 then 16 Bit Mode: P[7:0] is Multiplexed CrCb 8 Bit Video Data
+//                       and Y[7:0] is Y 8 Bit Data
+// 7. one bit CBSWAP (Chroma Red/Blue Swap)
+//    if 0 then Normal Pixel Sequence
+//    if 1 then Cr and Cb Pixels are Swapped at the Input to the Pixel Port
+// 8. one bit PORCH
+//    if 0 then Front and Back Porch Timing Meets ITU-RBT.470-3
+//         this must be the standard Porch Timing
+//    if 1 then CCIR601 Porch Timing. This allows 720 Pixels Width
+//         by Narrowing Front and Back Porch in Favor of Active Video
+
+// Bits from the Left for Register BE
+// 1. eight bits CCF2B1[7:0] (First Byte of Closed Captioning 
+//    Information for Field 2)
+
+// Bits from the Left for Register C0
+// 1. eight bits CCF2B2[7:0] (Second Byte of Closed Captioning 
+//    Information for Field 2)
+
+// Bits from the Left for Register C2
+// 1. eight bits CCF1B1[7:0] (First Byte of Closed Captioning 
+//    Information for Field 1)
+
+// Bits from the Left for Register C4
+// 1. eight bits CCF1B2[7:0] (Second Byte of Closed Captioning 
+//    Information for Field 1)
+
+// Bits from the Left for Register C6
+// 1. eight bits HSYNCF[7:0] (First Eight Bits Falling Edge Sync Data) 
+//    SYNC Pulse Position Relative to Internal Horizontal Pixel Clock
+//    for Falling Edge of HSYNC
+// Needs ADJHSYNC = 1
+// Master Mode Only
+
+// Bits from the Left for Register C8
+// 1. eight bits HSYNCR[7:0] (First Eight Bits Rising Edge Sync Data) 
+//    SYNC Pulse Position Relative to Internal Horizontal Pixel Clock
+//    for Rising Edge of HSYNC
+// Needs ADJHSYNC = 1
+// Master Mode Only
+
+// Bits from the Left for Register CA
+// 1. one bit SYNCDLY (Sync Delay Mode)
+//    if 0 then Normal SYNC Timing
+//    if 1 then Delayed SYNC Timing
+//    set this to one to see a pretty green screen :)
+// 2. one bit FIELD1 (the so-called Color Flag)
+//    if 0 then If FIELD Pin = 1 this Indicates Field 2
+//    if 1 then If FIELD Pin = 1 this Indicates Field 1
+// 3. one bit SYNCDIS (VBI SYNC Mode)
+//    if 0 then Normal HSYNC Operation
+//    if 1 then Disable HSYNC Durring VBI (No H Serrations In VBI)
+//    Master Mode Only
+// 4. one bit ADJHSYNC (HSYNC Pulse Timing Mode)
+//    if 0 then Normal 4.7usec HSYNC Pulse
+//    if 1 then Use HSYNCR[10:0] and HSYNCF[10:0] to Program HSYNC Pulse
+//         Rising and Falling Times
+//    See HSYNCR[7:0] and HSYNCF[7:0] Above
+//    (It's a programmable pulse generator and this is it's Enable Bit)
+// 5. two bits HSYNCF[9:8] (Last Two Bits Falling Edge Sync Data) 
+// 6. two bits HSYNCR[9:8] (Last Two Bits Rising Edge Sync Data) 
+
+// Bits from the Left for Register CC
+// 1. one bit SETMODE (Automatic Mode Detection)
+//    if 0 then Use Automatic Mode Detection
+//    if 1 then Override Automatic Mode Detection
+//         Use VIDFORM[3:0], NONINTL and SQUARE Registers Bits to Set Mode
+//    Slave Mode Only
+// 2. one bit SETUPDIS (Disable 7.5 IRE Setup on Output)
+//    if 0 then Setup On: 7.5 IRE Setup Enabled for Active Video Lines
+//    if 1 then Setup Off: Disable 7.5 IRE Setup on Output Video
+// 3. four bits VIDFORM[3:0]
+//    These Bits Control the World Television Standard
+//    D5  D4  D3  D2  Format         Market
+//    -------------------------------------
+//    0   0   0   0   NTSC Normal    USA/Japan
+//    0   0   1   0   NTSC-60/HDTV   USA-HDTV (SCRESET Must Be 1)
+//    1   1   0   0   PAL-M Normal   Brazil
+//    1   1   1   0   PAL-M-60/HDTV  Brazil-HDTV
+//    1   0   0   1   PAL-BDGHIN     Western Europe
+//    1   1   0   1   PAL-NC         Argentina
+// 4. one bit NONINTL (Non Interlace Mode)
+//    if 0 then Interlaced Operation
+//    if 1 then Non Interlaced Operation (Progressive Scan)
+// 5. one bit SQUARE (Square Pixel Operation Mode)
+//    if 0 then CCIR601 Operation
+//    if 1 then Square Pixel Operation
+
+// Bits from the Left for Register CE
+// 1. one bit ESTATUS (I2C Readback Information Mode)
+//    if 0 then I2C Readback Information Contains Version Number
+//    if 1 then I2C Readback Information Contains Closed Caption Status
+//         and Field Number
+// 2. one bit RGBO (RGB Output Mode)
+//    if 0 then Normal Operation
+//    if 1 then Enable RGB Outputs
+// 3. one bit DCHROMA (Disable Chroma)
+//    if 0 then Normal Operation
+//    if 1 then Disable Chroma (B/W Operation)
+// 4. one bit ECBAR (Enable Color Bars)
+//    if 0 then Normal Operation
+//    if 1 then Enable Internally Generated Color Bars on Output
+// 5. one bit SCRESET (Sub Carrier Reset Mode)
+//    if 0 then Normal Operation 
+//         (SC Phase is Reset at Beginning of Each Field)
+//    if 1 then Disable Sub Carrier Reset Event at the
+//         Beginning of Each Field Sequence
+// 6. one bit EVBI (Enable HSYNC Durring VBI)
+//    if 0 then Video is Blanked Durring Vertical Blanking Interval
+//    if 1 then Enable Active Video Durring Vertical Blanking Interval
+//         Setup is Added if SETUPDIS = 0
+//         Scaling of YCrCb Pixels is based on 100% Blank to White
+//         i.e. Normal PAL Input Scaling
+// 7. one bit EACTIVE (Enable Active Video)
+//    if 0 then Output Black With Burst if ECBAR = 0
+//         or Color Bars if ECBAR = 1
+//    if 1 then Normal Operation (Output Active Video)
+// 8. one bit ECLIP (Enable DAC Clipping)
+//    if 0 then Normal Operation
+//    if 1 then DAC Values Less Than 31 Are Set To 31 (This Limit
+//         Corresponds Roughly to 1/4 of Sync Height)
+
+// Bits from the Left for Register D0
+// 1. seven reserved bits, zero for normal operation
+//    this should have been done by the reset above
+// 2. one bit PALN (Enable PAL-N Mode)
+//    if 0 then Normal PAL-BDGHI Operation As Set By VIDFORM[3:0]
+//    if 1 then PAL-N Operation As Set By VIDFORM[3:0]
+
+// Bits from the Left for Register D2
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register D4
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register D6
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register D8
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register DA
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register DC
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register DE
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E0
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E2
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E4
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E6
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register E8
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register EA
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register EC
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register EE
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F0
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F2
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F4
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F6
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register F8
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register FA
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register FC
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// Bits from the Left for Register FE
+// 1. eight reserved bits, zero for normal operation
+//    this should have been done by the reset above
+
+// starts at register A0 by twos
+static unsigned char NTSC_CONFIG_BT865[ 48 ] = {
+/*  0 A0 */	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+/*  1 A2 */	0x00,	// WSDAT[12:5]
+/*  2 A4 */	0x00,	// WSDAT[20:13]
+/*  3 A6 */	0x00,	// SRESET RSRVD[6:0]
+/*  4 A8 */	0x00,	// RSRVD[7:0]
+/*  5 AA */	0x00,	// RSRVD[7:0]
+/*  6 AC */	0x00,	// TXHS[7:0]
+/*  7 AE */	0x00,	// TXHE[7:0]
+/*  8 B0 */	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+/*  9 B2 */	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+/* 10 B4 */	0x00,	// TXBF1[7:0]
+/* 11 B6 */	0x00,	// TXEF1[7:0]
+/* 12 B8 */	0x00,	// TXBF2[7:0]
+/* 13 BA */	0x00,	// TXEF2[7:0]
+/* 14 BC */	0xc1,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+/* 15 BE */	0x00,	// CCF2B1[7:0]
+/* 16 C0 */	0x00,	// CCF2B2[7:0]
+/* 17 C2 */	0x00,	// CCF1B1[7:0]
+/* 18 C4 */	0x00,	// CCF1B2[7:0]
+/* 19 C6 */	0x00,	// HSYNCF[7:0]
+/* 20 C8 */	0x00,	// HSYNCR[7:0]
+/* 21 CA */	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+/* 22 CC */	0x00,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+/* 23 CE */	0x04,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+/* 24 D0 */	0x00,	// RSRVD[6:0] PALN
+/* 25 D2 */	0x00,	// RSRVD[7:0]
+/* 26 D4 */	0x00,	// RSRVD[7:0]
+/* 27 D6 */	0x00,	// RSRVD[7:0]
+/* 28 D8 */	0x00,	// RSRVD[7:0]
+/* 29 DA */	0x00,	// RSRVD[7:0]
+/* 30 DC */	0x00,	// RSRVD[7:0]
+/* 31 DE */	0x00,	// RSRVD[7:0]
+/* 32 E0 */	0x00,	// RSRVD[7:0]
+/* 33 E2 */	0x00,	// RSRVD[7:0]
+/* 34 E4 */	0x00,	// RSRVD[7:0]
+/* 35 E6 */	0x00,	// RSRVD[7:0]
+/* 36 E8 */	0x00,	// RSRVD[7:0]
+/* 37 EA */	0x00,	// RSRVD[7:0]
+/* 38 EC */	0x00,	// RSRVD[7:0]
+/* 39 EE */	0x00,	// RSRVD[7:0]
+/* 40 F0 */	0x00,	// RSRVD[7:0]
+/* 41 F2 */	0x00,	// RSRVD[7:0]
+/* 42 F4 */	0x00,	// RSRVD[7:0]
+/* 43 F6 */	0x00,	// RSRVD[7:0]
+/* 44 F8 */	0x00,	// RSRVD[7:0]
+/* 45 FA */	0x00,	// RSRVD[7:0]
+/* 46 FC */	0x00,	// RSRVD[7:0]
+/* 47 FE */	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char NTSC60_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0x88,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+	0x0a,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x00,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char PALM_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0xf0,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+	0x02,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x00,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char PALM60_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0xf8,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+	0x02,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x00,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char PAL_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0xe4,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE // or 0x24
+	0x02,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x00,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+// starts at register A0 by twos
+static unsigned char PALNC_CONFIG_BT865[ 48 ] = {
+	0x00,	// EWSF2 EWSF1 RSRVD[1:0] WSDAT[4:1]
+	0x00,	// WSDAT[12:5]
+	0x00,	// WSDAT[20:13]
+	0x00,	// SRESET RSRVD[6:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// TXHS[7:0]
+	0x00,	// TXHE[7:0]
+	0x00,	// LUMADLY[1:0] TXHE[10:8] TXHS[10:8]
+	0x00,	// RSRVD[1:0] TXRM TXE TXEF2[8] TXBF2[8] TXEF1[8] TXBF1[8]
+	0x00,	// TXBF1[7:0]
+	0x00,	// TXEF1[7:0]
+	0x00,	// TXBF2[7:0]
+	0x00,	// TXEF2[7:0]
+	0x00,	// ECCF2 ECCF1 ECCGATE RSRVD DACOFF YC16 CBSWAP PORCH
+	0x00,	// CCF2B1[7:0]
+	0x00,	// CCF2B2[7:0]
+	0x00,	// CCF1B1[7:0]
+	0x00,	// CCF1B2[7:0]
+	0x00,	// HSYNCF[7:0]
+	0x00,	// HSYNCR[7:0]
+	0x00,	// SYNCDLY FIELD1 SYNCDIS ADJHSYNC HSYNCF[9:8] HSYNCR[9:8]
+	0xf4,	// SETMODE SETUPDIS VIDFORM[3:0] NONINTL SQUARE
+	0x02,	// ESTATUS RGBO DCHROMA ECBAR SCRESET EVBI EACTIVE ECLIP
+	0x01,	// RSRVD[6:0] PALN
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+	0x00,	// RSRVD[7:0]
+};
+
+static int bt865_update( struct i2c_client *client )
+{
+	struct bt865_data_s *data = i2c_get_clientdata(client) ;
+	char tmpconfig[48];
+	int i;
+
+	if (memcpy(tmpconfig, data->config, data->configlen) != tmpconfig) {
+		printk(KERN_NOTICE "bt865_update: memcpy error\n");
+		return -1;
+	}
+
+	if (data->bars) {
+		tmpconfig[23] |= 0x10;
+	}
+
+	if (data->enableoutput) {
+		tmpconfig[23] |= 0x02;
+	}
+
+	if (data->rgbmode) {
+		tmpconfig[23] |= 0x40;
+	}
+
+	for (i = 0; i < data->configlen; i++) {
+		i2c_smbus_write_byte_data(client, 2 * i + 0xA0, tmpconfig[i]);
+	}
+
+	return 0;
+}
+
+static int bt865_setmode(int mode, struct i2c_client *client)
+{
+	struct bt865_data_s *data = i2c_get_clientdata(client);
+	unsigned char *config = NULL;
+
+	pr_debug("bt865_setmode( %d, %p )\n", mode, client);
+
+	switch (mode) {
+	case ENCODER_MODE_NTSC:
+		printk(KERN_NOTICE "bt865.o: Configuring for NTSC\n");
+		config = NTSC_CONFIG_BT865;
+		data->configlen = sizeof(NTSC_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_NTSC60:
+		printk(KERN_NOTICE "bt865.o: Configuring for NTSC\n");
+		config = NTSC60_CONFIG_BT865;
+		data->configlen = sizeof(NTSC60_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_PAL_M:
+		printk(KERN_NOTICE "bt865.o: Configuring for PAL_M\n");
+		config = PALM_CONFIG_BT865;
+		data->configlen = sizeof(PALM_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_PALM60:
+		printk(KERN_NOTICE "bt865.o: Configuring for PAL_M60\n");
+		config = PALM60_CONFIG_BT865;
+		data->configlen = sizeof(PALM60_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_PAL:
+		printk(KERN_NOTICE "bt865.o: Configuring for PAL\n");
+		config = PAL_CONFIG_BT865;
+		data->configlen = sizeof(PAL_CONFIG_BT865);
+		break;
+	case ENCODER_MODE_PALNC:
+		printk(KERN_NOTICE "bt865.o: Configuring for PAL\n");
+		config = PALNC_CONFIG_BT865;
+		data->configlen = sizeof(PALNC_CONFIG_BT865);
+		break;
+	default:
+		return -1;
+	}
+
+	data->mode = mode;
+
+	if (config) {
+		if (memcpy(data->config, config, data->configlen) != data->config) {
+			printk(KERN_NOTICE "bt865_setmode: memcpy error\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int bt865_setup(struct i2c_client *client)
+{
+	struct bt865_data_s *data = i2c_get_clientdata(client);
+	
+	if (memset(data->config, 0, sizeof(data->config)) != data->config) {
+		printk(KERN_NOTICE "bt865_setup: memset error\n");
+		return -1;
+	}
+
+	data->bars = 0;
+	data->rgbmode = 0;
+	data->enableoutput = 0;
+
+	if (EM8300_VIDEOMODE_DEFAULT == EM8300_VIDEOMODE_PAL) {
+		printk(KERN_NOTICE "bt865.o: Defaulting to PAL\n");
+		bt865_setmode(ENCODER_MODE_PAL, client);
+	} else if (EM8300_VIDEOMODE_DEFAULT == EM8300_VIDEOMODE_NTSC) {
+		printk(KERN_NOTICE "bt865.o: Defaulting to NTSC\n");
+		bt865_setmode(ENCODER_MODE_NTSC, client);
+	}
+
+	if (bt865_update(client)) {
+		printk(KERN_NOTICE "bt865_setup: bt865_update error\n");
+		return -1;
+	}
+	
+	return 0;
+}
+
+static int bt865_detect(struct i2c_adapter *adapter, int address)
+{
+	struct bt865_data_s *data;
+	struct i2c_client *new_client;
+	int err, chk = 0;
+
+	if (i2c_is_isa_adapter(adapter)) {
+		printk(KERN_ERR "bt865a.o: called for an ISA bus adapter?!?\n");
+		return 0;
+	}
+
+	chk = i2c_check_functionality(adapter,
+			I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA);
+
+	if (!chk) {
+		return 0;
+	}
+
+	new_client = kmalloc(sizeof(struct i2c_client) + sizeof(struct bt865_data_s), 
+			GFP_KERNEL);
+
+	if (!new_client) {
+		return -ENOMEM;
+	}
+
+	data = (struct bt865_data_s *) (((struct i2c_client *) new_client) + 1);
+	new_client->addr = address;
+	i2c_set_clientdata(new_client, data);
+	new_client->adapter = adapter;
+	new_client->driver = &bt865_driver;
+	new_client->flags = 0;
+
+//	i2c_smbus_write_byte_data(new_client,0xa6, 0x80/*b1*/);
+//	the write is not needed
+//	from the left we have three bits identifying the chip
+//	which is a 4 (100) for the bt864 and a 5 (101) for the bt865
+//  followed by 5 bits for the version number. in this case 17 (1 0001)
+//	thus 1011 0001 (0xb1) is correct for the bt865a version 17
+	if (i2c_smbus_read_byte_data(new_client, 0) == 0xb1) {
+		strncpy(new_client->name, "BT865 chip", DEVICE_NAME_SIZE);
+		printk(KERN_NOTICE "bt865.o: BT865 chip detected\n");
+
+		new_client->id = bt865_id++;
+
+		if ((err = i2c_attach_client(new_client))) {
+			kfree(new_client);
+			return err;
+		}
+
+		if (bt865_setup(new_client)) {
+			return -1;
+		}
+
+		return 0;
+	}
+
+	kfree(new_client);
+	return 0;			  
+}
+
+static int bt865_attach_adapter(struct i2c_adapter *adapter)
+{
+	if (!(adapter->class & I2C_CLASS_TV_ANALOG))
+		return 0;
+
+	bt865_detect(adapter, 0x45);
+	return 0;
+}
+
+
+int bt865_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	if ((err = i2c_detach_client(client))) {
+		printk(KERN_ERR "bt865.o: Client deregistration failed, client not detached.\n");
+		return err;
+	}
+
+	kfree(client);
+
+	return 0;
+}
+
+int bt865_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	struct bt865_data_s *data = i2c_get_clientdata(client);
+
+	switch(cmd) {
+	case ENCODER_CMD_SETMODE:
+		bt865_setmode((int) arg, client);
+		bt865_update(client);
+		break;
+	case ENCODER_CMD_ENABLEOUTPUT:
+		data->enableoutput = (int) arg;
+		bt865_update(client);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+
+int __init bt865_init(void)
+{
+	int bars;
+	
+        if (color_bars) {
+		bars = 0x10;
+	} else {
+		bars = 0x00;
+        }
+	
+        if (rgb_mode) {
+	    bars = bars | 0x40;
+	    pr_debug("bt865.o: rgb_mode: %d\n", rgb_mode);
+	}
+
+	pr_debug("bt865.o: color_bars: %d\n", color_bars);
+	
+	NTSC_CONFIG_BT865[23] = (NTSC_CONFIG_BT865[23] & ~0x10) | bars;
+	NTSC60_CONFIG_BT865[23] = (NTSC60_CONFIG_BT865[23] & ~0x10) | bars;
+	PALM_CONFIG_BT865[23] = (PALM_CONFIG_BT865[23] & ~0x10) | bars;
+	PALM60_CONFIG_BT865[23] = (PALM60_CONFIG_BT865[23] & ~0x10) | bars;
+	PAL_CONFIG_BT865[23] = (PAL_CONFIG_BT865[23] & ~0x10) | bars;
+	PALNC_CONFIG_BT865[23] = (PALNC_CONFIG_BT865[23] & ~0x10) | bars;
+
+	//request_module("i2c-algo-bit");
+	return i2c_add_driver(&bt865_driver);
+}
+
+static void __exit bt865_cleanup(void)
+{
+	i2c_del_driver(&bt865_driver);
+}
+
+module_init(bt865_init);
+module_exit(bt865_cleanup);
+
diff -Nurw linux-2.6.10/drivers/media/em8300/bt865.h linux-2.6.10-em8300/drivers/media/em8300/bt865.h
--- linux-2.6.10/drivers/media/em8300/bt865.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/bt865.h	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1 @@
+#define I2C_DRIVERID_BT865 0xf001
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_audio.c linux-2.6.10-em8300/drivers/media/em8300/em8300_audio.c
--- linux-2.6.10/drivers/media/em8300/em8300_audio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_audio.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,636 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <linux/soundcard.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+#include "em8300_fifo.h"
+
+#ifndef AFMT_AC3
+#define AFMT_AC3 0x00000400
+#endif
+
+#include <asm/byteorder.h>
+
+int em8300_audio_calcbuffered(struct em8300_s *em);
+static int set_audiomode(struct em8300_s *em, int mode);
+
+/* C decompilation of sub_prepare_SPDIF by 
+*  Anton Altaparmakov <antona@bigfoot.com>
+*
+*  If outblock == inblock generate mute pattern.
+*
+* Notes:
+*  local1 = "in" = current inblock position pointer.
+*  local3 = "i" = for loop counter.
+*  Need unsigned everywhere, otherwise get into trouble with signed shift rights!
+*/
+
+void sub_prepare_SPDIF(struct em8300_s *em, unsigned char *outblock, unsigned char *inblock, unsigned int inlength)
+{
+	// 	ebp-4 = local1 = in	ebp-8 = local2
+	//	ebp-0ch = local3 = i	ebp-10h = local4
+
+	unsigned char *in; // 32 bit points to array of 8 bit chars
+	unsigned short int local2; // 16 bit, unsigned
+	unsigned int i; // 32 bit, signed
+	unsigned char local4; // 8 bit, unsigned
+	unsigned char mutepattern[] = {0x00, 0x00};
+	int mute;
+
+	mute = (inblock == outblock) ? 1 : 0;
+	in = (mute) ? mutepattern : inblock;
+
+	for (i = 0; i < (inlength >> 2); i++) {
+		if (em->dword_DB4 == 0xc0) {
+			em->dword_DB4 = 0;
+		}
+		
+		{
+			register int ebx;
+			if (em->dword_DB4 < 0) {
+				ebx = em->byte_D90[(em->dword_DB4 + 7) >> 3] & 0xff << (!((!em->dword_DB4 + 1) & 7) + 1) & 0xff;
+			} else {
+				ebx = (em->byte_D90[em->dword_DB4 >> 3] & 0xff) << (em->dword_DB4 & 7);
+			}
+			local4 = (unsigned char) ((ebx & 0x80) >> 1);
+		}
+
+		local2 = in[0] << 8 | in[1];
+		if (!mute)
+			in +=2;
+
+		if (em->dword_DB4 != 0) {
+			outblock[i * 8 + 3] = 2;
+		} else {
+			outblock[i * 8 + 3] = 0;
+		}
+
+		outblock[i * 8 + 2] = local2 << 4;
+		outblock[i * 8 + 1] = local2 >> 4;
+		outblock[i * 8] = local2 >> 12 | local4;
+
+       		local2 = in[0] << 8 | in[1];
+		if (!mute)
+			in +=2;
+
+		outblock[i * 8 + 7] = 1;
+		outblock[i * 8 + 6] = local2 << 4;
+		outblock[i * 8 + 5] = local2 >> 4;
+		outblock[i * 8 + 4] = local2 >> 12 | local4;
+
+		++em->dword_DB4;
+	}
+	
+	return;
+}
+
+static void preprocess_analog(struct em8300_s *em, unsigned char *outbuf, const unsigned char *inbuf_user, int inlength)
+{
+	int i;
+	
+#ifdef __BIG_ENDIAN
+	if (em->audio.format == AFMT_S16_BE) {
+#else /* __LITTLE_ENDIAN */
+	if (em->audio.format == AFMT_S16_LE ||
+	    em->audio_mode == EM8300_AUDIOMODE_DIGITALAC3) {
+#endif
+		if (em->audio.channels == 2) {
+			for (i = 0; i < inlength; i += 4) {
+				get_user(outbuf[i + 3], inbuf_user++);
+				get_user(outbuf[i + 2], inbuf_user++);
+				get_user(outbuf[i + 1], inbuf_user++);
+				get_user(outbuf[i], inbuf_user++);
+			}
+		} else {
+			for (i = 0; i < inlength; i += 2) {
+				get_user(outbuf[2 * i + 1], inbuf_user++);
+				get_user(outbuf[2 * i], inbuf_user++);
+				outbuf[2 * i + 3] = outbuf[2 * i + 1];
+				outbuf[2 * i + 2] = outbuf[2 * i];
+			}
+		}
+	} else {
+		for (i = 0; i < inlength / 2; i++) {
+			outbuf[2 * i] = inbuf_user[i];
+			outbuf[2 * i + 1] = inbuf_user[i];
+		}	
+	}
+}
+
+static void preprocess_digital(struct em8300_s *em, unsigned char *outbuf,
+			       const unsigned char *inbuf_user, int inlength)
+{
+	int i;
+
+	if (!em->mafifo->preprocess_buffer)
+		return;
+
+#ifdef __BIG_ENDIAN
+	if (em->audio.format == AFMT_S16_BE) {
+#else /* __LITTLE_ENDIAN */
+        if (em->audio.format == AFMT_S16_LE ||
+	    em->audio_mode == EM8300_AUDIOMODE_DIGITALAC3) {
+#endif
+		if (em->audio.channels == 2) {
+			for(i = 0; i < inlength; i += 2) {
+				get_user(em->mafifo->preprocess_buffer[i + 1], inbuf_user++);				
+				get_user(em->mafifo->preprocess_buffer[i], inbuf_user++);
+			}
+		} else {
+			for(i = 0; i < inlength; i += 2) {
+				get_user(em->mafifo->preprocess_buffer[2 * i + 1], inbuf_user++);				
+				get_user(em->mafifo->preprocess_buffer[2 * i], inbuf_user++);
+				em->mafifo->preprocess_buffer[2 * i + 3] = em->mafifo->preprocess_buffer[2 * i + 1];
+				em->mafifo->preprocess_buffer[2 * i + 2] = em->mafifo->preprocess_buffer[2 * i];
+			}
+			inlength *= 2; /* ensure correct size for sub_prepare_SPDIF */
+		}
+	} else {
+		copy_from_user(em->mafifo->preprocess_buffer, inbuf_user, inlength);
+	}
+
+	sub_prepare_SPDIF(em,outbuf, em->mafifo->preprocess_buffer, inlength);
+}
+
+static void setup_mafifo(struct em8300_s *em)
+{
+	if (em->audio_mode == EM8300_AUDIOMODE_ANALOG) {
+		em->mafifo->preprocess_ratio = ((em->audio.channels == 2) ? 1 : 2);
+		em->mafifo->preprocess_cb = &preprocess_analog;
+	} else {
+		em->mafifo->preprocess_ratio = ((em->audio.channels == 2) ? 2 : 4);
+		em->mafifo->preprocess_cb = &preprocess_digital;
+	}
+}
+
+int mpegaudio_command(struct em8300_s *em, int cmd)
+{
+	em8300_waitfor(em, ucregister(MA_Command), 0xffff, 0xffff);
+
+	pr_debug("MA_Command: %d\n", cmd);
+	write_ucregister(MA_Command, cmd);
+
+	return em8300_waitfor(em, ucregister(MA_Status), cmd, 0xffff);
+}
+
+static int audio_start(struct em8300_s *em)
+{
+	em->irqmask |= IRQSTATUS_AUDIO_FIFO;
+	write_ucregister(Q_IrqMask, em->irqmask);
+	em->audio.enable_bits = PCM_ENABLE_OUTPUT;
+	return mpegaudio_command(em, MACOMMAND_PLAY);
+}
+
+static int audio_stop(struct em8300_s *em)
+{
+	em->irqmask &= ~IRQSTATUS_AUDIO_FIFO;
+	write_ucregister(Q_IrqMask, em->irqmask);
+	em->audio.enable_bits = 0;
+	return mpegaudio_command(em, MACOMMAND_STOP);
+}
+
+static int set_speed(struct em8300_s *em, int speed)
+{
+	em->clockgen &= ~CLOCKGEN_SAMPFREQ_MASK;
+
+	switch (speed) {
+	case 48000:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_48;
+		break;
+	case 44100:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_44;
+		break;
+	case 66000:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_66;
+		break;
+	case 32000:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_32;
+		break;
+	default:
+		em->clockgen |= CLOCKGEN_SAMPFREQ_48;
+		speed = 48000;
+	}
+	
+	em->audio.speed = speed;
+
+	em8300_clockgen_write(em, em->clockgen);
+	
+	return speed;
+}
+
+static int set_channels(struct em8300_s *em, int val)
+{
+	if (val > 2) val = 2;
+	em->audio.channels = val;
+	setup_mafifo(em);
+
+	return val;
+}
+
+static int set_format(struct em8300_s *em, int fmt)
+{
+	if (fmt != AFMT_QUERY) {
+		switch (fmt) {
+#ifdef AFMT_AC3
+		case AFMT_AC3:
+			if (em->audio_mode != EM8300_AUDIOMODE_DIGITALAC3)
+            {
+			    set_speed(em, 48000);
+				set_audiomode(em, EM8300_AUDIOMODE_DIGITALAC3);
+                setup_mafifo(em);
+            }
+			em->audio.format = fmt;
+			break;
+#endif
+		case AFMT_S16_BE:
+		case AFMT_S16_LE:
+			if (em->audio_mode == EM8300_AUDIOMODE_DIGITALAC3)
+            {
+				set_audiomode(em, em->pcm_mode);
+                setup_mafifo(em);
+            }
+			em->audio.format = fmt;
+			break;
+		default:
+			if (em->audio_mode == EM8300_AUDIOMODE_DIGITALAC3)
+            {
+				set_audiomode(em, em->pcm_mode);
+                setup_mafifo(em);
+            }
+			fmt = AFMT_S16_BE;
+			break;
+		}
+	}
+	return em->audio.format;
+}
+
+int em8300_audio_ioctl(struct em8300_s *em,unsigned int cmd, unsigned long arg)
+{
+	int err, len = 0;
+	int val = 0;
+
+	if (_SIOC_DIR(cmd) != _SIOC_NONE && _SIOC_DIR(cmd) != 0) {
+		/*
+		 * Have to validate the address given by the process.
+		 */
+		len = _SIOC_SIZE(cmd);
+		if (len < 1 || len > 65536 || arg == 0) {
+			return -EFAULT;
+		}
+		if (_SIOC_DIR(cmd) & _SIOC_WRITE) {
+			if ((err = verify_area(VERIFY_READ, (void *) arg, len)) < 0) {
+				return err;
+			}
+		}
+		if (_SIOC_DIR(cmd) & _SIOC_READ) {
+			if ((err = verify_area(VERIFY_WRITE, (void *) arg, len)) < 0) {
+				return err;
+			}
+		}
+	}
+
+	switch (cmd) { 
+	case SNDCTL_DSP_RESET: /* reset device */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_RESET\n");
+		em8300_audio_flush(em);
+		return 0;
+
+	case SNDCTL_DSP_SYNC:  /* wait until last byte is played and reset device */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SYNC\n");
+		em8300_fifo_sync(em->mafifo);
+		val = 0;
+		break;
+
+	case SNDCTL_DSP_SPEED: /* set sample rate */
+		if (get_user(val, (int *) arg)) {
+			return -EFAULT;
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SPEED %i ", val);
+		val = set_speed(em, val);
+		pr_debug("%i\n", val);
+		break;
+
+	case SOUND_PCM_READ_RATE: /* read sample rate */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_RATE %i ", val);
+		val = em->audio.speed;
+		pr_debug("%i\n", val);
+		break;
+
+	case SNDCTL_DSP_STEREO: /* set stereo or mono mode */
+		if (get_user(val, (int *) arg)) {
+			return -EFAULT;
+		}
+		if (val > 1 || val < 0) {
+			return -EINVAL;
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_STEREO %i\n", val);
+		set_channels(em, val + 1);
+		break;
+
+	case SNDCTL_DSP_GETBLKSIZE: /* get fragment size */
+		val = em->audio.slotsize;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETBLKSIZE %i\n", val);
+		break;
+
+	case SNDCTL_DSP_CHANNELS: /* set number of channels */
+		if (get_user(val, (int *) arg)) {
+			return -EFAULT;
+		}
+		if (val > 2 || val < 1) {
+			return -EINVAL;
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_CHANNELS %i\n", val);
+		set_channels(em, val);
+		break;
+
+	case SOUND_PCM_READ_CHANNELS: /* read number of channels */
+		val = em->audio.channels;
+		pr_debug("em8300_audio.o: SOUND_PCM_READ_CHANNELS %i\n", val);
+		break;
+
+	case SNDCTL_DSP_POST: /* "there is likely to be a pause in the output" */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_POST\n");
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETPOST not implemented yet\n");
+		return -ENOSYS;
+		break;
+
+	case SNDCTL_DSP_SETFRAGMENT: /* set fragment size */
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SETFRAGMENT %i\n", val);
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SETFRAGMENT not implemented yet\n");
+		break;
+
+	case SNDCTL_DSP_GETFMTS: /* get possible formats */
+#ifdef AFMT_AC3
+		val = AFMT_AC3 | AFMT_S16_BE | AFMT_S16_LE;
+#else
+		val = AFMT_S16_BE | AFMT_S16_LE;
+#endif
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETFMTS\n");
+		break;
+
+	case SNDCTL_DSP_SETFMT: /* set sample format */
+		if (get_user(val, (int *) arg)) {
+			return -EFAULT;
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SETFMT %i ", val);
+		val = set_format(em, val);
+		pr_debug("%i\n", val);
+		break;
+
+	case SOUND_PCM_READ_BITS: /* read sample format */
+		val = em->audio.format;
+		pr_debug("em8300_audio.o: SOUND_PCM_READ_BITS\n");
+		break;
+
+	case SNDCTL_DSP_GETOSPACE:
+	{
+		audio_buf_info buf_info;
+		switch(em->audio_mode)
+		{
+			case EM8300_AUDIOMODE_ANALOG:
+				buf_info.fragments=
+					em8300_fifo_freeslots(em->mafifo) -
+					em->mafifo->nslots / 2;
+				break;
+			default:
+				buf_info.fragments=
+					em8300_fifo_freeslots(em->mafifo) / 2;
+				break;
+		}
+		buf_info.fragments = (buf_info.fragments > 0) ? buf_info.fragments : 0;
+		buf_info.fragstotal = em->mafifo->nslots / 2;
+		buf_info.fragsize = em->audio.slotsize;
+		buf_info.bytes = em->mafifo->nslots * em->audio.slotsize / 2;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETOSPACE\n");
+		return copy_to_user((void *) arg, &buf_info, sizeof(audio_buf_info));
+	}
+	
+	case SNDCTL_DSP_GETISPACE:
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETISPACE\n");
+		return -ENOSYS;
+		break;
+
+	case SNDCTL_DSP_GETCAPS:
+		val = DSP_CAP_REALTIME | DSP_CAP_BATCH | DSP_CAP_TRIGGER;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETCAPS\n");
+		break;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = em->audio.enable_bits;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETTRIGGER\n");
+		break;
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (val & PCM_ENABLE_OUTPUT) {
+			if (em->audio.enable_bits & PCM_ENABLE_OUTPUT) {
+				em->audio.enable_bits |= PCM_ENABLE_OUTPUT;
+				mpegaudio_command(em, MACOMMAND_PLAY);
+			}
+		}
+		pr_debug("em8300_audio.o: SNDCTL_DSP_SETTRIGGER\n");
+		pr_info("em8300_audio.o: SNDCTL_DSP_SETTRIGGER not implemented properly yet\n");
+		break;
+
+	case SNDCTL_DSP_GETIPTR:
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETIPTR\n");
+		return -ENOSYS;
+		break;
+
+	case SNDCTL_DSP_GETOPTR:
+	{
+		count_info ci;
+		ci.bytes = em->mafifo->bytes - em8300_audio_calcbuffered(em);
+		if (ci.bytes < 0) ci.bytes = 0;
+		ci.blocks = 0;
+		ci.ptr = 0;
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETOPTR %i\n", ci.bytes);
+		return copy_to_user((void *) arg, &ci, sizeof(count_info));
+	}
+	case SNDCTL_DSP_GETODELAY:
+		val = em8300_audio_calcbuffered(em);
+		pr_debug("em8300_audio.o: SNDCTL_DSP_GETODELAY %i\n", val);
+		break;
+
+	default:
+		pr_info("em8300_audio.o: unknown ioctl called\n");
+		return -EINVAL;
+	}
+
+	return put_user(val, (int *) arg);
+}
+
+int em8300_audio_flush(struct em8300_s *em)
+{
+	int pcirdptr = read_ucregister(MA_PCIRdPtr);
+	write_ucregister(MA_PCIWrPtr, pcirdptr);
+	*em->mafifo->writeptr = *em->mafifo->readptr;
+	em8300_fifo_sync(em->mafifo);
+	return 0;
+}
+
+int em8300_audio_open(struct em8300_s *em)
+{
+	if (!em->ucodeloaded) {
+		return -ENODEV;
+	}
+	
+	em->mafifo->bytes = 0;
+
+	return audio_start(em);
+}
+
+int em8300_audio_release(struct em8300_s *em)
+{
+        em8300_fifo_sync(em->mafifo);
+	em8300_audio_flush(em);
+	return audio_stop(em);	
+}
+
+static int set_audiomode(struct em8300_s *em, int mode)
+{
+	em->audio_mode = mode;
+	
+	em->clockgen &= ~CLOCKGEN_OUTMASK;
+
+	if (em->audio_mode == EM8300_AUDIOMODE_ANALOG) {
+		em->clockgen |= CLOCKGEN_ANALOGOUT;
+	} else {
+		em->clockgen |= CLOCKGEN_DIGITALOUT;
+	}
+	
+	em8300_clockgen_write(em, em->clockgen);
+
+	memset(em->byte_D90, 0, sizeof(em->byte_D90));
+
+	em->byte_D90[1] = 0x98;
+
+	switch (em->audio.speed) {
+	case 32000:
+		em->byte_D90[3] = 0xc0;
+		break;
+	case 44100:
+		em->byte_D90[3] = 0;
+		break;
+	case 48000:
+		em->byte_D90[3] = 0x40;
+		break;
+	}
+	 
+	switch (em->audio_mode) {
+	case EM8300_AUDIOMODE_ANALOG:
+		em->pcm_mode = EM8300_AUDIOMODE_ANALOG;
+
+		write_register(EM8300_AUDIO_RATE, 0x62);
+		em8300_setregblock(em, 2 * ucregister(Mute_Pattern), 0, 0x600);
+		printk(KERN_DEBUG "em8300_audio.o: Analog audio enabled\n");
+		break;
+	case EM8300_AUDIOMODE_DIGITALPCM:
+		em->pcm_mode = EM8300_AUDIOMODE_DIGITALPCM;
+
+		write_register(EM8300_AUDIO_RATE, 0x3a0);
+
+		em->byte_D90[0] = 0x0;
+        sub_prepare_SPDIF(em, em->mafifo->preprocess_buffer, em->mafifo->preprocess_buffer, 0x300);
+
+        em8300_writeregblock(em, 2*ucregister(Mute_Pattern), (unsigned *)em->mafifo->preprocess_buffer, em->mafifo->slotsize);
+
+		printk(KERN_DEBUG "em8300_audio.o: Digital PCM audio enabled\n");
+		break;
+	case EM8300_AUDIOMODE_DIGITALAC3:
+		write_register(EM8300_AUDIO_RATE, 0x3a0);
+
+		em->byte_D90[0] = 0x40;
+        sub_prepare_SPDIF(em, em->mafifo->preprocess_buffer, em->mafifo->preprocess_buffer, 0x300);
+
+        em8300_writeregblock(em, 2*ucregister(Mute_Pattern), (unsigned *)em->mafifo->preprocess_buffer, em->mafifo->slotsize);
+		printk(KERN_DEBUG "em8300_audio.o: Digital AC3 audio enabled\n");
+		break;
+	}
+	return 0;
+}
+
+int em8300_audio_setup(struct em8300_s *em)
+{
+	int ret;
+
+	em->audio.channels = 2;
+	em->audio.format = AFMT_S16_NE;
+	em->audio.slotsize = em->mafifo->slotsize;
+
+	em->clockgen = em->clockgen_tvmode;
+
+	set_speed(em, 48000);
+	
+	set_audiomode(em, EM8300_AUDIOMODE_DEFAULT);
+	
+	ret = em8300_audio_flush(em);
+
+	setup_mafifo(em);
+	
+	if (ret) {
+		printk(KERN_ERR "em8300_audio.o: Couldn't zero audio buffer\n");
+		return ret;
+	}
+	
+	write_ucregister(MA_Threshold, 6);
+	
+	mpegaudio_command(em, MACOMMAND_PLAY);
+	mpegaudio_command(em, MACOMMAND_PAUSE);
+
+	em->audio.enable_bits = 0;
+
+	return 0;
+}
+
+int em8300_audio_calcbuffered(struct em8300_s *em)
+{
+	int readptr, writeptr, bufsize, n;
+
+	readptr = read_ucregister(MA_Rdptr) | (read_ucregister(MA_Rdptr_Hi) << 16);
+	writeptr = read_ucregister(MA_Wrptr) | (read_ucregister(MA_Wrptr_Hi) << 16);
+	bufsize = read_ucregister(MA_BuffSize) | (read_ucregister(MA_BuffSize_Hi) << 16);
+
+	n = ((bufsize+writeptr-readptr) % bufsize);
+
+	return (em8300_fifo_calcbuffered(em->mafifo) + n) /
+		em->mafifo->preprocess_ratio;
+}
+
+int em8300_audio_write(struct em8300_s *em, const char * buf, size_t count, loff_t *ppos)
+{
+	return em8300_fifo_write(em->mafifo, count, buf, 0, em->nonblock[1]);
+}
+
+/* 18-09-2000 - Ze'ev Maor - added these two ioctls to set and get audio mode. */
+
+int em8300_ioctl_setaudiomode(struct em8300_s *em, int mode)
+{
+	em8300_audio_flush(em);
+	set_audiomode(em, mode);
+	setup_mafifo(em);
+	mpegaudio_command(em, MACOMMAND_PLAY);
+	em->audio.enable_bits = PCM_ENABLE_OUTPUT;
+	return 0;
+}
+
+int em8300_ioctl_getaudiomode(struct em8300_s *em, int mode)
+{
+	int a = em->audio_mode;
+	copy_to_user((void *) mode, &a, sizeof(int));
+	return 0;
+}
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_dicom.c linux-2.6.10-em8300/drivers/media/em8300/em8300_dicom.c
--- linux-2.6.10/drivers/media/em8300/em8300_dicom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_dicom.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,372 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+
+extern int dicom_other_pal;
+extern int dicom_fix;
+extern int dicom_control;
+
+struct dicom_tvmode {
+	int vertsize;
+	int horizsize;
+	int vertoffset;
+	int horizoffset;
+	int vis_vertsize;
+	int vis_horizsize;
+	int vis_vertoffset;
+	int vis_horizoffset;
+};
+
+struct dicom_tvmode tvmodematrix[EM8300_VIDEOMODE_LAST + 1] = {
+	{576, 720, 46, 122, 572, 720, 50, 122},     // PAL 4:3
+	{480, 720, 46, 138, 480, 720, 46, 138},     // PAL60 4:3
+	{480, 720, 31, 138, 480, 720, 31, 138},     // NTSC 4:3
+	{576, 960, 46,   8, 576, 720, 46, 122},     // PAL 16:9 cropped to 4:3
+};
+
+/* C decompilation of the chromaluma code
+*  by Anton Altaparmakov <antona@bigfoot.com>
+*
+*  This basically returns the result of calculating param1 / param2 and
+*  depending on some weird rules either adds 1 to the result or not.
+*  Returns 0 on error, ie. when param2 is 0.
+*/
+int sub_265C1 (int param1, unsigned int param2, short int param3)
+{
+	int local1;
+	if (!param2) {
+		return 0;
+	}
+	local1 = param1 / param2;
+	if (param2 & 1) {
+		param1 <<= 1;
+		param2 <<= 1;
+	}
+	if (param3) {
+		// Original was stupid, so there:
+		if (param1 % param2 >= param2) {
+			++local1;
+		}
+	} else {
+		if (param1 % param2 >= param2 >> 1) {
+			++local1;
+		}
+	}
+
+	return local1;
+}
+
+/* sub_40137 calculates the contents of the dicom_bcsluma and dicom_bcschroma
+*		 registers with brightness contrast and saturation values as inputs.
+*/
+int sub_40137(struct em8300_s *em)
+{
+	short int local1;
+	int local2, local3;
+	short int local4;
+	int local5;
+	short int local6, local7;
+	int ir;
+	register int eax;
+
+	local3 = sub_265C1(em->dicom_contrast * 0x7f, 0x3e8, 0); // 0x3e8 = 1000
+	local2 = sub_265C1(em->dicom_brightness * 0xff, 0x3e8, 0);
+	local5 = sub_265C1(em->dicom_saturation * 0x1f, 0x3e8, 0);
+	if (local3 >= 0x40) {
+		local1 = 0x2000 / (0xc0 - local3);
+		ir = local2 - 0x80 - ((local3 - 0x40) << 7) / (0xc0 - local3);
+		if (ir > -128) {
+			local4 = ir;
+		} else {
+			local4 = -128;
+		}
+		if ((eax = local5 << 7) < 0) {
+			eax += 0xf;
+		}
+		local6 = local7 = ((eax & 0xfffffff0) << 2) / (0xc0 - local3);
+	} else {
+		register int eax;
+		if ((eax = (local3 + 0x40) << 6) < 0) {
+			eax += 0x7f;
+		}
+		local1 = eax >> 7;
+		if ((eax = local2 - local3 - 0x40) < 0x7f) {
+			local4 = eax;
+		} else {
+			local4 = 0x7f;
+		}
+		if ((eax = local5 * (local3 + 0x40)) < 0) {
+			eax += 0xf;
+		}
+		if ((eax = (eax & 0xfffffff0) << 2) < 0) {
+			eax += 0x7f;
+		}
+		local6 = local7 =  eax >> 7;
+	}
+#if 0
+	if (em->encoder_type != ENCODER_BT865) {
+#endif
+		write_ucregister(DICOM_BCSLuma, (local1 << 8) | (local4 & 0xff));
+		write_ucregister(DICOM_BCSChroma, local7 << 8 | local6);
+#if 0
+	}
+#endif
+
+	return 1;
+}
+
+void em8300_dicom_setBCS(struct em8300_s *em, int brightness, int contrast, int saturation) 
+{
+	em->dicom_brightness = brightness;
+	em->dicom_contrast = contrast;
+	em->dicom_saturation = saturation;
+
+	if (read_ucregister(DICOM_UpdateFlag) == 1) {
+		write_ucregister(DICOM_UpdateFlag, 0);
+		udelay(1);
+	}
+
+	sub_40137(em); // Update brightness/contrast/saturation
+
+	write_ucregister(DICOM_UpdateFlag, 1);
+}
+
+int em8300_dicom_update(struct em8300_s *em) 
+{
+	int ret;
+	int vmode_ntsc = 1;
+	
+	if (dicom_other_pal) {
+		vmode_ntsc = (em->video_mode == EM8300_VIDEOMODE_NTSC);
+	}
+
+	if ((ret = em8300_waitfor(em, ucregister(DICOM_UpdateFlag), 0, 1))) {
+		return ret;
+	}
+
+	if (em->overlay_enabled) {
+		sub_4288c(em, em->overlay_frame_xpos, em->overlay_frame_ypos, em->overlay_frame_width,
+				em->overlay_frame_height, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+				em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+	} else {
+		write_ucregister(DICOM_FrameTop, tvmodematrix[em->video_mode].vertoffset);
+		write_ucregister(DICOM_FrameBottom, tvmodematrix[em->video_mode].vertoffset + tvmodematrix[em->video_mode].vertsize - 1);
+		write_ucregister(DICOM_FrameLeft, tvmodematrix[em->video_mode].horizoffset); 
+		write_ucregister(DICOM_FrameRight, tvmodematrix[em->video_mode].horizoffset + tvmodematrix[em->video_mode].horizsize - 1);
+		write_ucregister(DICOM_VisibleTop, tvmodematrix[em->video_mode].vis_vertoffset);
+		write_ucregister(DICOM_VisibleBottom, tvmodematrix[em->video_mode].vis_vertoffset + tvmodematrix[em->video_mode].vis_vertsize - 1); 
+		write_ucregister(DICOM_VisibleLeft, tvmodematrix[em->video_mode].vis_horizoffset); 
+		write_ucregister(DICOM_VisibleRight, tvmodematrix[em->video_mode].vis_horizoffset + tvmodematrix[em->video_mode].vis_horizsize - 1);
+	}
+
+	if (em->aspect_ratio == EM8300_ASPECTRATIO_16_9) {
+		em->dicom_tvout |= 0x10;
+	} else {
+		em->dicom_tvout &= ~0x10;
+	}
+
+	write_ucregister(DICOM_TvOut, em->dicom_tvout);
+
+	if (em->overlay_enabled) {
+		write_register(0x1f47, 0x0);
+		write_register(0x1f5e, 0x1afe);
+		write_ucregister(DICOM_Control, 0x9afe);
+
+#if 0 /* don't know if this is necessary yet */
+#ifdef EM8300_DICOM_0x1f5e_0x1efe
+		write_register(0x1f5e, 0x1efe);
+#else
+		write_register(0x1f5e, 0x1afe);
+#endif
+#ifdef EM8300_DICOM_CONTROL_0x9efe
+		write_ucregister(DICOM_Control, 0x9efe);
+#else
+		write_ucregister(DICOM_Control, 0x9afe);
+#endif
+#endif
+	} else {
+
+		if (em->encoder_type == ENCODER_BT865) {
+			write_register(0x1f47, 0x0);
+			if (em->video_mode == EM8300_VIDEOMODE_NTSC) {
+				write_register(EM8300_HSYNC_LO, 134);
+				write_register(EM8300_HSYNC_HI, 720);
+			} else {
+				write_register(EM8300_HSYNC_LO, 140);
+				write_register(EM8300_HSYNC_HI, 720);
+			}
+			if (vmode_ntsc) {
+				write_register(EM8300_VSYNC_HI, 260);
+			        write_register(0x1f5e, 0xfefe);
+			} else {
+				write_register(EM8300_VSYNC_HI, 310);	 
+			        write_register(0x1f5e, 0x9cfe);
+			}
+
+			write_ucregister(DICOM_VSyncLo1, 0x1); 
+			write_ucregister(DICOM_VSyncLo2, 0x0);
+			write_ucregister(DICOM_VSyncDelay1, 0xd2); 
+			write_ucregister(DICOM_VSyncDelay2, 0x00);  
+
+			write_register(0x1f46, 0x00);
+			write_register(0x1f47, 0x1f);
+
+			write_ucregister(DICOM_Control, 0x9efe);		
+		} else { /* ADV7170 or ADV7175A */
+			write_register(0x1f47, 0x18);
+
+			if (vmode_ntsc) {
+				if (dicom_fix) {
+					write_register(0x1f5e, 0x1efe);
+				} else {
+					write_register(0x1f5e, 0x1afe);
+				}
+
+				if (dicom_control) {
+					write_ucregister(DICOM_Control, 0x9efe);
+				} else {
+					write_ucregister(DICOM_Control, 0x9afe);
+				}
+			} else {
+				if (dicom_fix) {
+					write_register(0x1f5e, 0x1afe);
+				} else {
+					write_register(0x1f5e, 0x1efe);
+				}
+	
+				if (dicom_control) {
+					write_ucregister(DICOM_Control, 0x9afe);
+				} else {
+					write_ucregister(DICOM_Control, 0x9efe);
+				}
+			}			 
+		}
+	}
+
+	pr_debug("em8300_dicom.o: vmode_ntsc: %d\n", vmode_ntsc);
+	pr_debug("em8300_dicom.o: dicom_other_pal: %d\n", dicom_other_pal);
+	pr_debug("em8300_dicom.o: dicom_control: %d\n", dicom_control);
+	pr_debug("em8300_dicom.o: dicom_fix: %d\n", dicom_fix);
+
+	write_ucregister(DICOM_UpdateFlag, 1);
+	
+	return em8300_waitfor(em, ucregister(DICOM_UpdateFlag), 0, 1);
+}
+
+
+
+void em8300_dicom_disable(struct em8300_s *em)
+{
+	em->dicom_tvout = 0x8000;
+	write_ucregister(DICOM_TvOut, em->dicom_tvout);
+}
+
+void em8300_dicom_init(struct em8300_s *em)
+{
+}
+
+void em8300_dicom_enable(struct em8300_s *em)
+{
+	if (em->overlay_enabled) {
+		em->dicom_tvout = 0x4000;
+	} else {
+		em->dicom_tvout = 0x4001;
+	}
+
+	if (em->aspect_ratio == EM8300_ASPECTRATIO_16_9) {
+	  em->dicom_tvout |= 0x10;
+	} else {
+	  em->dicom_tvout &= ~0x10;
+	}
+
+	write_ucregister(DICOM_TvOut, em->dicom_tvout);
+}
+
+int em8300_dicom_get_dbufinfo(struct em8300_s *em)
+{
+	int displaybuffer;
+	struct displaybuffer_info_s *di = &em->dbuf_info;
+	
+	displaybuffer = read_ucregister(DICOM_DisplayBuffer) + 0x1000;
+
+	di->xsize = read_register(displaybuffer);
+	di->ysize = read_register(displaybuffer+1);
+	di->xsize2 = read_register(displaybuffer+2) & 0xfff;
+	di->flag1 = read_register(displaybuffer+2) & 0x8000;
+	di->flag2 = read_ucregister(Vsync_DBuf) & 0x4000;
+
+	if(read_ucregister(MicroCodeVersion) <= 0xf) {
+		di->buffer1 = (read_register(displaybuffer + 3) | (read_register(displaybuffer + 4) << 16)) << 4;
+		di->buffer2 = (read_register(displaybuffer + 5) | (read_register(displaybuffer + 6) << 16)) << 4;
+	} else {
+		di->buffer1 = read_register(displaybuffer + 3) << 6;
+		di->buffer2 = read_register(displaybuffer + 4) << 6;
+	}
+
+	if(displaybuffer == ucregister(Width_Buf3)) {
+		di->unk_present = 1;
+		if(read_ucregister(MicroCodeVersion) <= 0xf) {
+			di->unknown1 = read_register(displaybuffer + 7);
+			di->unknown2 = (read_register(displaybuffer + 8) | (read_register(displaybuffer + 9) <<16)) << 4;
+			di->unknown3 = (read_register(displaybuffer + 0xa) | (read_register(displaybuffer + 0xb) <<16)) << 4;
+		} else {
+			di->unknown2 = read_register(displaybuffer + 6);
+			di->unknown3 = read_register(displaybuffer + 7);
+		}
+	} else {
+		di->unk_present = 0;
+	}
+	
+	pr_debug("DICOM buffer: xsize=0x%x(%d)\n", di->xsize, di->xsize);
+	pr_debug("			  ysize=0x%x(%d)\n", di->ysize, di->ysize);
+	pr_debug("			  xsize2=0x%x(%d)\n", di->xsize2, di->xsize2);
+	pr_debug("			  flag1=%d, flag2=%d\n", di->flag1, di->flag2);
+	pr_debug("			  buffer1=0x%x(%d)\n", di->buffer1, di->buffer1);
+	pr_debug("			  buffer2=0x%x(%d)\n", di->buffer2, di->buffer2);
+	
+	if (di->unk_present) {
+		pr_debug("			  unknown1=0x%x(%d)\n", di->unknown1, di->unknown1);
+		pr_debug("			  unknown2=0x%x(%d)\n", di->unknown2, di->unknown2);
+		pr_debug("			  unknown3=0x%x(%d)\n", di->unknown3, di->unknown3);
+	}
+	return 0;
+}
+
+/* sub_42A32
+   Arguments 
+   xoffset = ebp+0x8
+   yoffset = ebp+0xc
+   c = ebp+0x10
+   lines = ebp+0x14
+   pat1 = ebp+0x18
+   pat2 = ebp+0x1c
+ */
+void em8300_dicom_fill_dispbuffers(struct em8300_s *em, int xpos, int ypos, int xsize, int ysize, unsigned int pat1, unsigned int pat2)
+{
+	int i;
+
+	pr_debug("ysize: %d, xsize: %d\n", ysize, xsize);
+	pr_debug("buffer1: %d, buffer2: %d\n", em->dbuf_info.buffer1, em->dbuf_info.buffer2);
+	
+	for (i = 0; i < ysize; i++) {
+		em8300_setregblock(em, em->dbuf_info.buffer1 + xpos + (ypos + i) * em->dbuf_info.xsize, pat1, xsize);
+		em8300_setregblock(em, em->dbuf_info.buffer2 + xpos + (ypos + i) / 2 * em->dbuf_info.xsize, pat2, xsize);
+	}
+}
+
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_fifo.c linux-2.6.10-em8300/drivers/media/em8300/em8300_fifo.c
--- linux-2.6.10/drivers/media/em8300/em8300_fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_fifo.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,349 @@
+/*
+	Copyright (C) 2000 Henrik Johansson <henrikjo@post.utfors.se>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <asm/segment.h>
+#include <asm/semaphore.h>
+
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+#include "em8300_fifo.h"
+
+
+DECLARE_MUTEX(em8300_fifo_lock);
+
+
+
+int em8300_fifo_init(struct em8300_s *em, struct fifo_s *f, int start, int wrptr, int rdptr, int pcisize, int slotsize, int fifotype)
+{
+	int i;
+	unsigned phys;
+
+	f->em = em;
+	f->preprocess_ratio = 1;
+	f->preprocess_cb = NULL;
+	f->preprocess_buffer = NULL;
+	
+	f->type = fifotype;
+	
+	f->writeptr = (unsigned * volatile) ucregister_ptr(wrptr);
+	f->readptr = (unsigned * volatile) ucregister_ptr(rdptr);
+	
+	switch (f->type) {
+	case FIFOTYPE_AUDIO:
+		f->slotptrsize = 3;
+		f->slots.a = (struct audio_fifoslot_s *) ucregister_ptr(start);
+		f->nslots = read_ucregister(pcisize) / 3;
+		f->preprocess_buffer=kmalloc(slotsize, GFP_KERNEL);
+		if (!f->preprocess_buffer)
+			return -ENOMEM;
+		break;
+	case FIFOTYPE_VIDEO:
+		f->slotptrsize = 4;
+		f->slots.v = (struct video_fifoslot_s *) ucregister_ptr(start);
+		f->nslots = read_ucregister(pcisize) / 4;
+		break;
+	}
+	
+	f->slotsize = slotsize;
+	f->start = ucregister(start) - 0x1000;
+	f->threshold = f->nslots / 2;
+
+	f->bytes = 0;
+
+	if (f->fifobuffer) {
+		kfree(f->fifobuffer);
+	}
+	
+	f->fifobuffer = kmalloc(f->nslots * f->slotsize, GFP_KERNEL);
+	if (f->fifobuffer == NULL) {
+		return -ENOMEM;
+	}
+	init_waitqueue_head(&f->wait);
+	
+	for (i = 0; i < f->nslots; i++) {
+		phys = virt_to_phys(f->fifobuffer + i * f->slotsize);
+		switch (f->type) {
+		case FIFOTYPE_AUDIO:
+			f->slots.a[i].physaddress_hi = phys >> 16;
+			f->slots.a[i].physaddress_lo = phys & 0xffff;
+			f->slots.a[i].slotsize = f->slotsize;
+			break;
+		case FIFOTYPE_VIDEO:
+			f->slots.v[i].flags = 0;
+			f->slots.v[i].physaddress_hi = phys >> 16;
+			f->slots.v[i].physaddress_lo = phys & 0xffff;
+			f->slots.v[i].slotsize = f->slotsize;
+		}
+	}
+	
+	spin_lock_init(&f->lock);
+	f->valid = 1;
+	
+	return 0;
+}
+
+void em8300_fifo_free(struct fifo_s *f)
+{
+	if (f) {
+		if(f->valid && f->fifobuffer) {
+			kfree(f->fifobuffer);
+		}
+		if(f->valid && f->preprocess_buffer) {
+			kfree(f->preprocess_buffer);
+		}
+		kfree(f);
+	}
+}
+
+struct fifo_s *em8300_fifo_alloc()
+{
+	struct fifo_s *f = kmalloc(sizeof(struct fifo_s), GFP_KERNEL);
+	if (f) {
+		memset(f, 0, sizeof(struct fifo_s));
+	}
+	return f;
+}
+
+int em8300_fifo_check(struct fifo_s *fifo)
+{
+	int freeslots;
+	
+	if (!fifo || !fifo->valid) {
+		return -1;
+	}
+
+	freeslots = em8300_fifo_freeslots(fifo);
+
+	if (freeslots > fifo->threshold) {
+		wake_up_interruptible(&fifo->wait);
+	}
+
+	return 0;
+}
+
+int em8300_fifo_sync(struct fifo_s *fifo)
+{
+	unsigned long safe_jiff = jiffies;
+
+	while (*fifo->writeptr != *fifo->readptr) {
+		interruptible_sleep_on_timeout(&fifo->wait, 3 * HZ);
+		if time_after_eq(jiffies, safe_jiff + (3 * HZ)) {
+			printk(KERN_ERR 
+			       "em8300.o: FIFO sync timeout during sync\n");
+			return -EINTR;
+		}
+
+		if (signal_pending(current)) {
+			printk(KERN_ERR "em8300.o: FIFO sync interrupted\n");
+			return -EINTR;
+		}
+	}
+
+	return 0;
+}
+
+static int em8300_fifo_write_nonblock(struct fifo_s *fifo, int n, const char *userbuffer, int flags)
+{
+	int freeslots, writeindex, i, bytes_transferred = 0, copysize;
+
+	if (!fifo || !fifo->valid) {
+		return -1;
+	}
+	
+	spin_lock(&fifo->lock);
+
+	freeslots = em8300_fifo_freeslots(fifo);
+	writeindex = (*fifo->writeptr - fifo->start) / fifo->slotptrsize;
+	for (i = 0; i < freeslots && n; i++) {
+		copysize = n < fifo->slotsize / fifo->preprocess_ratio ? n : fifo->slotsize / fifo->preprocess_ratio;
+
+		switch (fifo->type) {
+		case FIFOTYPE_AUDIO:
+			fifo->slots.a[writeindex].slotsize = copysize * fifo->preprocess_ratio;
+			break;
+		case FIFOTYPE_VIDEO:
+			fifo->slots.v[writeindex].flags = flags;
+			fifo->slots.v[writeindex].slotsize = copysize * fifo->preprocess_ratio;
+			break;
+		}
+
+		if (fifo->preprocess_cb) {
+			fifo->preprocess_cb(fifo->em, fifo->fifobuffer + writeindex * fifo->slotsize, userbuffer, copysize);
+		} else {
+			copy_from_user(fifo->fifobuffer + writeindex * fifo->slotsize, userbuffer, copysize);
+		}
+	
+		writeindex++;
+		writeindex %= fifo->nslots;
+		n -= copysize;
+		userbuffer += copysize;
+		bytes_transferred += copysize;
+		fifo->bytes += copysize;
+	}
+	*fifo->writeptr = fifo->start + writeindex * fifo->slotptrsize;
+
+	spin_unlock(&fifo->lock);
+	
+	return bytes_transferred;
+}
+
+static int em8300_wait_and_recover(struct fifo_s *fifo) {
+	unsigned long safe_jiff = jiffies;
+	
+	interruptible_sleep_on_timeout(&fifo->wait, HZ);
+	if time_before(jiffies, safe_jiff + HZ) {
+		return 0;
+	}
+
+	printk("Fifo %p still full, trying to clear\n", fifo);
+
+	em8300_video_setplaymode(fifo->em, EM8300_PLAYMODE_STOPPED);
+	em8300_video_setplaymode(fifo->em, EM8300_PLAYMODE_PLAY);
+	
+	safe_jiff = jiffies;
+	interruptible_sleep_on_timeout(&fifo->wait, 3 * HZ);
+	if time_before(jiffies, safe_jiff + (3 * HZ)) {
+		return 0;
+	}
+		
+	printk(KERN_ERR "em8300.o: FIFO sync timeout during blocking write\n");
+	return -EINTR;
+}
+
+
+
+static int em8300_fifo_writeblocking(struct fifo_s *fifo, int n, const char *userbuffer, int flags)
+{
+	int total_bytes_written = 0, copy_size;
+
+	if (!fifo->valid) {
+		return -EPERM;
+	}
+		
+	while (n) {
+		copy_size = em8300_fifo_write_nonblock(fifo, n, userbuffer, flags);
+
+		if (copy_size < 0) {
+			return -EIO;
+		}
+	
+		n -= copy_size;
+		userbuffer += copy_size;
+		total_bytes_written += copy_size;
+
+		if (!copy_size) {
+			if (em8300_wait_and_recover(fifo)) {
+				return -EINTR;
+			}
+		}
+	
+		if (signal_pending(current)) {
+			if (total_bytes_written) {
+				return total_bytes_written;
+			} else {
+				return -EINTR;
+			}
+		}
+	}
+
+	return total_bytes_written;
+}
+
+int em8300_fifo_write(struct fifo_s *fifo, int n, const char *userbuffer, int flags, int nonblock)
+{
+	int ret;
+
+	if (nonblock) {
+		if (down_trylock(&em8300_fifo_lock)) {
+			return 0;
+		}
+		ret = em8300_fifo_write_nonblock(fifo, n, userbuffer, flags);
+	} else {
+		if (down_interruptible(&em8300_fifo_lock)) {
+			return -EINTR;
+		}
+		ret = em8300_fifo_writeblocking(fifo, n, userbuffer, flags);
+	}
+	up(&em8300_fifo_lock);
+	return ret;
+}
+
+
+int em8300_fifo_freeslots(struct fifo_s *fifo)
+{
+	return ((*fifo->readptr - *fifo->writeptr) / fifo->slotptrsize + fifo->nslots - 1) % fifo->nslots;
+}
+
+void em8300_fifo_statusmsg(struct fifo_s *fifo, char *str)
+{
+	int freeslots = em8300_fifo_freeslots(fifo);
+	sprintf(str,"Free slots: %d/%d", freeslots, fifo->nslots);
+}
+
+int em8300_fifo_calcbuffered(struct fifo_s *fifo)
+{
+	int readindex, writeindex, i, n;
+
+	writeindex = (*fifo->writeptr - fifo->start) / fifo->slotptrsize;
+	readindex = (*fifo->readptr - fifo->start) / fifo->slotptrsize;
+	n = 0;
+	i = readindex;
+	while (i != writeindex) {
+		switch (fifo->type) {
+		case FIFOTYPE_AUDIO:
+			n += fifo->slots.a[i].slotsize;
+			break;
+		case FIFOTYPE_VIDEO:
+			n += fifo->slots.v[i].slotsize;
+			break;
+		}
+		i++;
+		i &= fifo->nslots-1;
+	}
+
+	return n;
+}
+
+int em8300_fifo_isempty(struct fifo_s *fifo)
+{
+	return !(*fifo->writeptr - *fifo->readptr);
+}
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_fifo.h linux-2.6.10-em8300/drivers/media/em8300/em8300_fifo.h
--- linux-2.6.10/drivers/media/em8300/em8300_fifo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_fifo.h	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,86 @@
+#ifndef EM8300_FIFO_H
+#define EM8300_FIFO_H
+
+#include <linux/spinlock.h>
+
+#define FIFOTYPE_AUDIO 1
+#define FIFOTYPE_VIDEO 2
+
+struct video_fifoslot_s {
+	unsigned flags;
+	unsigned physaddress_hi;
+	unsigned physaddress_lo;
+	unsigned slotsize;
+};
+
+struct audio_fifoslot_s {
+	unsigned physaddress_hi;
+	unsigned physaddress_lo;
+	unsigned slotsize;
+};
+
+struct pts_fifoslot_s {
+	unsigned streamoffset_hi;
+	unsigned streamoffset_lo;
+	unsigned pts_hi;
+	unsigned pts_lo;
+};
+
+struct em8300_s;
+typedef void (*preprocess_cb_t) (struct em8300_s *, unsigned char *, const unsigned char *, int);
+
+struct fifo_s {
+	struct em8300_s *em;
+    
+	int valid;
+
+	int type;
+	int nslots;
+	union {
+		struct video_fifoslot_s *v;
+		struct audio_fifoslot_s *a;
+		struct pts_fifoslot_s *pts;
+	} slots;
+	int slotptrsize;
+	int slotsize;
+	
+	int start;
+	int * volatile writeptr;
+	int * volatile readptr;
+	int localreadptr;
+	int threshold;
+
+	int bytes;
+
+	char *fifobuffer;
+	
+	preprocess_cb_t preprocess_cb;
+	int preprocess_ratio;
+	char *preprocess_buffer;
+	
+	wait_queue_head_t wait;
+	spinlock_t lock;
+};
+
+struct em8300_s;
+
+/*
+  Prototypes
+*/
+int em8300_fifo_init(struct em8300_s *em, struct fifo_s *f,
+		     int start, int wrptr, int rdptr,
+		     int pcisize, int slotsize, int fifotype);
+
+struct fifo_s * em8300_fifo_alloc(void);
+void em8300_fifo_free(struct fifo_s *f);
+
+int em8300_fifo_write(struct fifo_s *fifo, int n, const char *userbuffer,
+		      int flags, int blocking);
+int em8300_fifo_check(struct fifo_s *fifo);
+int em8300_fifo_sync(struct fifo_s *fifo);
+int em8300_fifo_freeslots(struct fifo_s *fifo);
+void em8300_fifo_statusmsg(struct fifo_s *fifo, char *str);
+int em8300_fifo_calcbuffered(struct fifo_s *fifo);
+int em8300_fifo_isempty(struct fifo_s *fifo);
+
+#endif /* EM8300_FIFO_H */
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_i2c.c linux-2.6.10-em8300/drivers/media/em8300/em8300_i2c.c
--- linux-2.6.10/drivers/media/em8300/em8300_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_i2c.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,357 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+
+#include "adv717x.h"
+#include "bt865.h"
+//#include <linux/sensors.h>
+
+#define I2C_HW_B_EM8300 0xa
+
+struct private_data_s {
+	int clk;
+	int data;
+	struct em8300_s *em;
+};
+
+/* ----------------------------------------------------------------------- */
+/* I2C bitbanger functions						   */
+/* ----------------------------------------------------------------------- */
+
+/* software I2C functions */
+
+static void em8300_setscl(void *data,int state)
+{
+	struct private_data_s *p = (struct private_data_s *) data;
+	int sel = p->clk << 8;
+
+	p->em->mem[p->em->i2c_oe_reg] = sel | p->clk;
+	p->em->mem[p->em->i2c_pin_reg] = sel | (state ? p->clk : 0);
+}
+
+static void em8300_setsda(void *data, int state)
+{
+	struct private_data_s *p = (struct private_data_s *) data;
+	struct em8300_s *em = p->em;
+	int sel = p->data << 8;
+
+	em->mem[em->i2c_oe_reg] = sel | p->data;
+	em->mem[em->i2c_pin_reg] = sel | (state ? p->data : 0);
+}
+
+static int em8300_getscl(void *data)
+{
+	struct private_data_s *p = (struct private_data_s *)data;
+	struct em8300_s *em = p->em;
+
+	return em->mem[em->i2c_pin_reg] & (p->clk << 8);
+}
+
+static int em8300_getsda(void *data)
+{
+	struct private_data_s *p = (struct private_data_s *)data;
+	struct em8300_s *em = p->em;
+
+	return em->mem[em->i2c_pin_reg] & (p->data << 8);
+}
+
+
+static int em8300_i2c_reg(struct i2c_client *client)
+{
+	struct em8300_s *em = i2c_get_adapdata(client->adapter);
+
+	switch (client->driver->id) {
+	case I2C_DRIVERID_ADV717X:
+		if (!strncmp(client->name, "ADV7175", 7)) {
+			em->encoder_type = ENCODER_ADV7175;
+		}
+		if (!strncmp(client->name, "ADV7170", 7)) {
+			em->encoder_type = ENCODER_ADV7170;
+		}
+		em->encoder = client;
+		break;
+	case  I2C_DRIVERID_BT865:
+		em->encoder_type = ENCODER_BT865;
+		em->encoder = client;
+		break;
+	default:
+		printk(KERN_ERR "em8300_i2c: unknown client id\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int em8300_i2c_unreg(struct i2c_client *client)
+{
+	struct em8300_s *em = i2c_get_adapdata(client->adapter);
+
+	switch (client->driver->id) {
+	case I2C_DRIVERID_ADV717X:
+		em->encoder = NULL;
+		break;
+	case  I2C_DRIVERID_BT865:
+		em->encoder = NULL;
+		break;
+	}
+
+	return 0;
+}
+
+static struct i2c_algo_bit_data i2c_data_template = {
+	.setsda   = &em8300_setsda,
+	.setscl   = &em8300_setscl,
+	.getsda   = &em8300_getsda,
+	.getscl   = &em8300_getscl,
+	.mdelay   = 10,
+	.udelay   = 10,
+	.timeout  = 100,
+};
+
+static struct i2c_adapter i2c_ops_template = {
+	.owner             = THIS_MODULE,
+	.id                = I2C_HW_B_EM8300,
+	.class             = I2C_CLASS_TV_ANALOG,
+	.client_register   = em8300_i2c_reg,
+	.client_unregister = em8300_i2c_unreg,
+	.name      = "unset",
+};
+
+/* ----------------------------------------------------------------------- */
+/* I2C functions							   */
+/* ----------------------------------------------------------------------- */
+int em8300_i2c_init(struct em8300_s *em)
+{
+	int ret;
+	struct private_data_s *pdata;
+
+	//request_module("i2c-algo-bit");
+	
+	switch (em->chip_revision) {
+	case 2:
+		em->i2c_oe_reg = EM8300_I2C_OE;
+		em->i2c_pin_reg = EM8300_I2C_PIN;
+		break;
+	case 1:
+		em->i2c_oe_reg = 0x1f4f;
+		em->i2c_pin_reg = EM8300_I2C_OE;
+		break;
+	}
+	
+	/*
+	  Reset devices on I2C bus
+	*/
+	em->mem[em->i2c_pin_reg] = 0x3f3f;
+	em->mem[em->i2c_oe_reg] = 0x3b3b;
+	em->mem[em->i2c_pin_reg] = 0x0100;
+	em->mem[em->i2c_pin_reg] = 0x0101;
+	em->mem[em->i2c_pin_reg] = 0x0808;
+	
+	/*
+	  Setup info structure for bus 1
+	*/
+
+	memcpy(&em->i2c_data_1, &i2c_data_template , sizeof(struct i2c_algo_bit_data));
+
+	pdata = kmalloc(sizeof(struct private_data_s),GFP_KERNEL);
+	pdata->clk = 0x10;
+	pdata->data = 0x8;
+	pdata->em = em;
+	
+	em->i2c_data_1.data = pdata;
+
+	memcpy(&em->i2c_ops_1, &i2c_ops_template, sizeof(struct i2c_adapter));
+	strncpy(em->i2c_ops_1.name, "EM8300 I2C bus 1", DEVICE_NAME_SIZE);
+	em->i2c_ops_1.algo_data = &em->i2c_data_1;
+	em->i2c_ops_1.dev.parent = &em->dev->dev;
+	i2c_set_adapdata(&em->i2c_ops_1, (void *)em);
+	
+	ret = i2c_bit_add_bus(&em->i2c_ops_1);
+
+	if (ret) {
+		return ret;
+	}
+
+	/*
+	  Setup info structure for bus 2
+	*/
+
+	memcpy(&em->i2c_data_2, &i2c_data_template , sizeof(struct i2c_algo_bit_data));
+
+	pdata = kmalloc(sizeof(struct private_data_s), GFP_KERNEL);
+	pdata->clk = 0x4;
+	pdata->data = 0x8;
+	pdata->em = em;
+	
+	em->i2c_data_2.data = pdata;
+
+	memcpy(&em->i2c_ops_2, &i2c_ops_template, sizeof(struct i2c_adapter));
+	strncpy(em->i2c_ops_2.name, "EM8300 I2C bus 2", DEVICE_NAME_SIZE);
+	em->i2c_ops_2.algo_data = &em->i2c_data_2;
+	em->i2c_ops_2.dev.parent = &em->dev->dev;
+	i2c_set_adapdata(&em->i2c_ops_2, (void *)em);
+	
+	ret = i2c_bit_add_bus(&em->i2c_ops_2);
+	return ret;
+}
+
+void em8300_i2c_exit(struct em8300_s *em)
+{
+	/* unregister i2c_bus */
+	kfree(em->i2c_data_1.data);
+	kfree(em->i2c_data_2.data);
+	i2c_bit_del_bus(&em->i2c_ops_1);
+	i2c_bit_del_bus(&em->i2c_ops_2);
+}
+
+void em8300_clockgen_write(struct em8300_s *em, int abyte)
+{
+	int i;
+
+	em->mem[em->i2c_pin_reg] = 0x808;
+	for (i=0; i < 8; i++) {
+		em->mem[em->i2c_pin_reg] = 0x2000;
+		em->mem[em->i2c_pin_reg] = 0x800 | ((abyte & 1) ? 8 : 0);
+		em->mem[em->i2c_pin_reg] = 0x2020;
+		abyte >>= 1;
+	}
+
+	em->mem[em->i2c_pin_reg] = 0x200;
+	udelay(10);
+	em->mem[em->i2c_pin_reg] = 0x202;
+}	
+
+static void I2C_clk(struct em8300_s *em, int level)
+{
+	em->mem[em->i2c_pin_reg] = 0x1000 | (level ? 0x10 : 0);
+	udelay(1);
+}
+
+static void I2C_data(struct em8300_s *em, int level)
+{
+	em->mem[em->i2c_pin_reg] = 0x800 | (level ? 0x8 : 0);
+	udelay(1);
+}
+
+static void I2C_drivedata(struct em8300_s *em, int level)
+{
+	em->mem[em->i2c_oe_reg] = 0x800 | (level ? 0x8 : 0);
+	udelay(1);
+}
+
+#define I2C_read_data ((em->mem[em->i2c_pin_reg] & 0x800) ? 1 : 0)
+
+static void I2C_out(struct em8300_s *em, int data, int bits)
+{
+	int i;
+	for (i = bits - 1; i >= 0; i--) {
+		I2C_data(em, data & (1 << i));
+		I2C_clk(em, 1);
+		I2C_clk(em, 0);
+	}
+}
+
+static int I2C_in(struct em8300_s *em, int bits)
+{
+	int i, data = 0;
+	
+	for(i = bits - 1; i >= 0; i--) {
+		data |= I2C_read_data << i;
+		I2C_clk(em, 0);
+		I2C_clk(em, 1);
+	}
+	return data;
+}
+
+static void sub_23660(struct em8300_s *em, int arg1, int arg2)
+{
+	I2C_clk(em, 0);
+	I2C_out(em, arg1, 8);
+	I2C_data(em, arg2);  
+	I2C_clk(em, 1);
+}
+
+
+static void sub_236f0 (struct em8300_s *em,int arg1, int arg2, int arg3)
+{
+	I2C_clk(em, 1);
+	I2C_data(em, 1);
+	I2C_clk(em, 0);
+	I2C_data(em, 1);
+	I2C_clk(em, 1);
+	I2C_clk(em, 0);
+
+	sub_23660(em, 1, arg2);
+
+	sub_23660(em, arg1, arg3);
+}
+
+void em9010_write(struct em8300_s *em, int reg, int data)
+{
+	sub_236f0(em, reg, 1, 0);
+	sub_23660(em, data, 1);
+}
+
+int em9010_read(struct em8300_s *em, int reg)
+{
+	int val;
+
+	sub_236f0(em, reg, 0, 0);
+	I2C_drivedata(em, 0);
+	val = I2C_in(em, 8);
+	I2C_drivedata(em, 1);
+	I2C_clk(em, 0);
+	I2C_data(em, 1);
+	I2C_clk(em, 1);
+
+	return val;
+}
+
+/* loc_2A5d8 in cl.asm
+   call dword ptr [exx+0x14]
+*/
+int em9010_read16(struct em8300_s *em, int reg)
+{
+	if (reg > 128) {
+		em9010_write(em, 3, 0);
+		em9010_write(em, 4, reg);
+	} else {
+		em9010_write(em, 4, 0);
+		em9010_write(em, 3, reg);
+	}
+
+	return em9010_read(em, 2) | (em9010_read(em, 1) << 8);
+}
+
+/* loc_2A558 in cl.asm
+   call dword ptr [exx+0x10]
+*/
+void em9010_write16(struct em8300_s *em, int reg, int value)
+{
+	if (reg > 128) {
+		em9010_write(em, 3, 0);
+		em9010_write(em, 4, reg);
+	} else {
+		em9010_write(em, 4, 0);
+		em9010_write(em, 3, reg);
+	}
+	em9010_write(em, 2, value & 0xff);
+	em9010_write(em, 1, value >> 8);
+}
+
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_ioctl.c linux-2.6.10-em8300/drivers/media/em8300/em8300_ioctl.c
--- linux-2.6.10/drivers/media/em8300/em8300_ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_ioctl.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,619 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+#include "em8300_fifo.h"
+
+#include "encoder.h"
+
+int em8300_control_ioctl(struct em8300_s *em, int cmd, unsigned long arg)
+{
+	em8300_register_t reg;
+	int val, len, err;
+	em8300_bcs_t bcs;
+	em8300_overlay_window_t ov_win;
+	em8300_overlay_screen_t ov_scr;
+	em8300_overlay_calibrate_t ov_cal;
+	em8300_attribute_t attr;
+	unsigned long safe_jiff = jiffies;
+	
+	if (_IOC_DIR(cmd) != 0) {
+		len = _IOC_SIZE(cmd);
+
+		if (len < 1 || len > 65536 || arg == 0) {
+			return -EFAULT;
+		}
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if ((err = verify_area(VERIFY_READ, (void *) arg, len)) < 0) {
+				return err;
+			}
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			if ((err = verify_area(VERIFY_WRITE, (void *) arg, len)) < 0) {
+				return err;
+			}
+		}
+	}	
+
+	switch(_IOC_NR(cmd)) {
+	case _IOC_NR(EM8300_IOCTL_INIT):
+		return em8300_ioctl_init(em, (em8300_microcode_t *) arg);
+
+	case _IOC_NR(EM8300_IOCTL_WRITEREG):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		copy_from_user(&reg, (void *) arg, sizeof(em8300_register_t));
+
+		if (reg.microcode_register) {
+			write_ucregister(reg.reg, reg.val);
+		} else {
+			write_register(reg.reg, reg.val);
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_READREG):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		copy_from_user(&reg, (void *) arg, sizeof(em8300_register_t));
+
+		if (reg.microcode_register) {
+			reg.val = read_ucregister(reg.reg);
+			reg.reg = ucregister(reg.reg);
+		} else {
+			reg.val = read_register(reg.reg);
+		}
+		copy_to_user((void *) arg, &reg, sizeof(em8300_register_t));
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_GETSTATUS):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		em8300_ioctl_getstatus(em, (char *) arg);
+		return 0;
+
+	case _IOC_NR(EM8300_IOCTL_VBI):
+	         if (!em->ucodeloaded) {
+		         return -ENOTTY;
+		 }
+		 
+		 em->irqmask |= IRQSTATUS_VIDEO_VBL;
+		 write_ucregister(Q_IrqMask, em->irqmask);
+		 
+		 /* go to sleep */
+		 // interruptible_sleep_on(&em->vbi_wait);
+ 		interruptible_sleep_on_timeout(&em->vbi_wait, HZ);
+		if time_after_eq(jiffies, safe_jiff + HZ) return -EINTR;
+        
+		 /* check if signal arrived */
+		 if (signal_pending(current)) {
+		          return -EINTR;
+		 }
+		 /* copy timestamp and return */
+		 copy_to_user((void *) arg, &em->tv, sizeof(struct timeval));
+		 return 0;
+
+	case _IOC_NR(EM8300_IOCTL_GETBCS):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			copy_from_user(&bcs, (void *) arg, sizeof(em8300_bcs_t));
+			em8300_dicom_setBCS(em, bcs.brightness, bcs.contrast, bcs.saturation);
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			bcs.brightness = em->dicom_brightness;
+			bcs.contrast = em->dicom_contrast;
+			bcs.saturation = em->dicom_saturation;
+			copy_to_user((void *) arg, &bcs, sizeof(em8300_bcs_t));
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SET_VIDEOMODE):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setvideomode(em, val);
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			copy_to_user((void *) arg, &em->video_mode, sizeof(em->video_mode));
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SET_PLAYMODE):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setplaymode(em, val);
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SET_ASPECTRATIO):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setaspectratio(em, val);
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			copy_to_user((void *) arg, &em->aspect_ratio, sizeof(em->aspect_ratio));
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_GET_AUDIOMODE):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setaudiomode(em, val);
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			em8300_ioctl_getaudiomode(em, arg);
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SET_SPUMODE):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			em8300_ioctl_setspumode(em, val);
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			copy_to_user((void *) arg, &em->sp_mode, sizeof(em->sp_mode));
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_SETMODE):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			if (!em8300_ioctl_overlay_setmode(em, val)) {
+				return -EINVAL;
+			}
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_SIGNALMODE):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int *) arg);
+			if (!em9010_overlay_set_signalmode(em, val)) {
+				return -EINVAL;
+			}
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_SETWINDOW):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			copy_from_user(&ov_win, (void *) arg, sizeof(em8300_overlay_window_t));
+			if (!em8300_ioctl_overlay_setwindow(em, &ov_win)) {
+				return -EINVAL;
+			}
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			copy_to_user((void *) arg, &ov_win, sizeof(em8300_overlay_window_t));
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_SETSCREEN):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			copy_from_user(&ov_scr, (void *) arg, sizeof(em8300_overlay_screen_t));
+			if (!em8300_ioctl_overlay_setscreen(em, &ov_scr)) {
+				return -EINVAL;
+			}
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			copy_to_user((void *) arg, &ov_scr, sizeof(em8300_overlay_screen_t));
+		}
+	break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_CALIBRATE):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			copy_from_user(&ov_cal, (void *) arg, sizeof(em8300_overlay_calibrate_t));
+			if(!em8300_ioctl_overlay_calibrate(em, &ov_cal)) {
+				return -EIO;
+			}
+		}
+	
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			copy_to_user((void *) arg, &ov_cal, sizeof(em8300_overlay_calibrate_t));
+		}
+	break;
+
+	case _IOC_NR(EM8300_IOCTL_OVERLAY_GET_ATTRIBUTE):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		copy_from_user(&attr, (void *) arg, sizeof(em8300_attribute_t));		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			em9010_set_attribute(em, attr.attribute, attr.value);
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			attr.value = em9010_get_attribute(em, attr.attribute);
+			copy_to_user((void *) arg, &attr, sizeof(em8300_attribute_t));
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_SCR_GET):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			unsigned scr;
+			if (get_user(val, (unsigned*) arg))
+				return -EFAULT;
+			scr = read_ucregister(MV_SCRlo) | (read_ucregister(MV_SCRhi) << 16);
+			
+			if (scr > val)
+				scr = scr - val;
+			else
+				scr = val - scr;
+				
+			if (scr > 2 * 1800) { /* Tolerance: 2 frames */
+				pr_info("adjusting scr: %i\n", val);
+				write_ucregister(MV_SCRlo, val & 0xffff);
+				write_ucregister(MV_SCRhi, (val >> 16) & 0xffff);
+			}
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			val = read_ucregister(MV_SCRlo) | (read_ucregister(MV_SCRhi) << 16);
+			copy_to_user((void *) arg, &val, sizeof(unsigned));
+		}
+	break;
+
+	case _IOC_NR(EM8300_IOCTL_SCR_GETSPEED):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			get_user(val, (int*) arg);
+			val &= 0xFFFF;
+
+			write_ucregister(MV_SCRSpeed,
+			 read_ucregister(MicroCodeVersion) >= 0x29 ? val : val >> 8);
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			val = read_ucregister(MV_SCRSpeed);
+			if (! read_ucregister(MicroCodeVersion) >= 0x29)
+				val <<= 8;
+
+			copy_to_user((void *) arg, &val, sizeof(unsigned));
+		}
+	break;
+
+	case _IOC_NR(EM8300_IOCTL_FLUSH):
+		if (!em->ucodeloaded) {
+			return -ENOTTY;
+		}
+		
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (get_user(val, (unsigned*) arg))
+				return -EFAULT;
+			
+			switch (val) {
+			case EM8300_SUBDEVICE_CONTROL:
+				return -ENOSYS;
+			case EM8300_SUBDEVICE_VIDEO:
+				return em8300_video_flush(em);
+			case EM8300_SUBDEVICE_AUDIO:
+				return em8300_audio_flush(em);
+			case EM8300_SUBDEVICE_SUBPICTURE:
+				return -ENOSYS;
+			default:
+				return -EINVAL;
+			}
+		}
+	break;
+	
+	default:
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+int em8300_ioctl_init(struct em8300_s *em, em8300_microcode_t *useruc)
+{
+	em8300_microcode_t uc;
+	int ret;
+
+	copy_from_user(&uc, useruc, sizeof(em8300_microcode_t));
+
+	if ((ret = em8300_ucode_upload(em, uc.ucode, uc.ucode_size))) {
+		return ret;
+	}
+
+	em8300_dicom_init(em);
+	
+	if ((ret = em8300_video_setup(em))) {
+		return ret;
+	}
+
+	if (em->mvfifo) {
+		em8300_fifo_free(em->mvfifo);
+	}
+	if (em->mafifo) {
+		em8300_fifo_free(em->mafifo);
+	}
+	if (em->spfifo) {
+		em8300_fifo_free(em->spfifo);
+	}
+	
+	if (!(em->mvfifo = em8300_fifo_alloc())) {
+		return -ENOMEM;
+	}
+	
+	if (!(em->mafifo = em8300_fifo_alloc())) {
+		return -ENOMEM;
+	}
+
+	if (!(em->spfifo = em8300_fifo_alloc())) {
+		return -ENOMEM;
+	}
+
+	em8300_fifo_init(em,em->mvfifo, MV_PCIStart, MV_PCIWrPtr, MV_PCIRdPtr, MV_PCISize, 0x900, FIFOTYPE_VIDEO);
+	em8300_fifo_init(em,em->mafifo, MA_PCIStart, MA_PCIWrPtr, MA_PCIRdPtr, MA_PCISize, 0x1000, FIFOTYPE_AUDIO); 
+	//	em8300_fifo_init(em,em->spfifo, SP_PCIStart, SP_PCIWrPtr, SP_PCIRdPtr, SP_PCISize, 0x1000, FIFOTYPE_VIDEO);
+	em8300_fifo_init(em,em->spfifo, SP_PCIStart, SP_PCIWrPtr, SP_PCIRdPtr, SP_PCISize, 0x800, FIFOTYPE_VIDEO);
+	em8300_spu_init(em);
+
+	if ((ret = em8300_audio_setup(em))) {
+		return ret;
+	}
+
+	em8300_ioctl_enable_videoout(em, 1);
+	
+	em->ucodeloaded = 1;
+
+	printk(KERN_NOTICE "em8300: Microcode version 0x%02x loaded\n", read_ucregister(MicroCodeVersion));
+	return 0;
+}
+
+void em8300_ioctl_getstatus(struct em8300_s *em, char *usermsg) 
+{
+	char tmpstr[1024];
+	struct timeval tv;
+	long tdiff, frames, scr, picpts;
+	char mvfstatus[128];
+	char mafstatus[128];
+	char spfstatus[128];
+
+	em8300_fifo_statusmsg(em->mvfifo, mvfstatus);
+	em8300_fifo_statusmsg(em->mafifo, mafstatus);
+	em8300_fifo_statusmsg(em->spfifo, spfstatus);
+		
+	frames = (read_ucregister(MV_FrameCntHi) << 16) | read_ucregister(MV_FrameCntLo);
+	picpts = (read_ucregister(PicPTSHi) << 16) |
+	read_ucregister(PicPTSLo);
+	scr = (read_ucregister(MV_SCRhi) << 16) | read_ucregister(MV_SCRlo);
+	
+	do_gettimeofday(&tv);
+	tdiff = TIMEDIFF(tv, em->last_status_time);
+	em->last_status_time = tv;
+	em->irqcount = 0;
+	em->frames = frames;
+	em->scr = scr;
+	copy_to_user((void *) usermsg, tmpstr, strlen(tmpstr) + 1);
+}
+
+
+int em8300_ioctl_setvideomode(struct em8300_s *em, int mode)
+{
+	int encoder;
+
+	switch (mode) {
+	case EM8300_VIDEOMODE_PAL:
+	case EM8300_VIDEOMODE_PALCROP:
+		encoder = ENCODER_MODE_PAL;
+		break;
+	case EM8300_VIDEOMODE_PAL60:
+		encoder = ENCODER_MODE_PAL60;
+		break;
+	case EM8300_VIDEOMODE_NTSC:
+		encoder = ENCODER_MODE_NTSC;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	em->video_mode = mode;
+
+	em8300_dicom_disable(em);
+
+	if (em->encoder) {
+		em->encoder->driver->command(em->encoder, ENCODER_CMD_SETMODE, (void *)encoder);
+	}
+	em8300_dicom_enable(em);
+	em8300_dicom_update(em);
+
+	return 0;
+}
+
+void em8300_ioctl_enable_videoout(struct em8300_s *em, int mode)
+{
+	em8300_dicom_disable(em);
+	
+	if (em->encoder) {
+		em->encoder->driver->command(em->encoder, ENCODER_CMD_ENABLEOUTPUT, (void *) mode);
+	}
+	em8300_dicom_enable(em);
+}
+
+
+int em8300_ioctl_setaspectratio(struct em8300_s *em, int ratio)
+{
+	em->aspect_ratio = ratio;	
+	em8300_dicom_update(em);
+
+	return 0;
+}
+
+int em8300_ioctl_setplaymode(struct em8300_s *em, int mode)
+{
+	switch (mode) {
+	case EM8300_PLAYMODE_PLAY:
+		mpegaudio_command(em, MACOMMAND_PLAY);
+		if (em->playmode == EM8300_PLAYMODE_STOPPED) {
+			em8300_ioctl_enable_videoout(em, 1);
+		}
+		em8300_video_setplaymode(em, mode);
+		break;
+	case EM8300_PLAYMODE_STOPPED:
+		em8300_ioctl_enable_videoout(em, 0);
+		em8300_video_setplaymode(em, mode);
+		break;
+	case EM8300_PLAYMODE_PAUSED:
+		mpegaudio_command(em, MACOMMAND_PAUSE);
+		em8300_video_setplaymode(em, mode);
+		break;
+	default:
+		return -1;
+	}
+	em->playmode = mode;
+
+	return 0;
+}
+
+int em8300_ioctl_setspumode(struct em8300_s *em, int mode)
+{
+	em->sp_mode = mode;
+	return 0;
+}
+
+int em8300_ioctl_overlay_setmode(struct em8300_s *em, int val)
+{
+	switch (val) {
+	case EM8300_OVERLAY_MODE_OFF:
+		if (em->overlay_enabled) {
+		        em->clockgen = (em->clockgen & ~CLOCKGEN_MODEMASK) | em->clockgen_tvmode;
+			em8300_clockgen_write(em, em->clockgen);
+			em->overlay_enabled = 0;
+			em->overlay_mode = val;
+			em8300_ioctl_setvideomode(em, em->video_mode);
+			em9010_overlay_update(em);
+		}
+		break;
+	case EM8300_OVERLAY_MODE_RECTANGLE:
+	case EM8300_OVERLAY_MODE_OVERLAY:
+		if (!em->overlay_enabled) {
+		        em->clockgen = (em->clockgen & ~CLOCKGEN_MODEMASK) | em->clockgen_overlaymode;
+			em8300_clockgen_write(em, em->clockgen);
+			em->overlay_enabled = 1;
+			em->overlay_mode = val;
+			em8300_dicom_disable(em);
+			em8300_dicom_enable(em);
+			em8300_dicom_update(em);
+			em9010_overlay_update(em);
+		} else {
+			em->overlay_mode = val;
+			em9010_overlay_update(em);
+		}
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+int em8300_ioctl_overlay_setwindow(struct em8300_s *em, em8300_overlay_window_t *w)
+{
+	if (w->xpos < -2000 || w->xpos > 2000) {
+		return 0;
+	}
+	if (w->ypos < -2000 || w->ypos > 2000) {
+		return 0;
+	}
+	if (w->width <= 0 || w->width > 2000) {
+		return 0;
+	}
+	if (w->height <= 0 || w->height > 2000) {
+		return 0;
+	}
+	em->overlay_frame_xpos = w->xpos;
+	em->overlay_frame_ypos = w->ypos;
+	em->overlay_frame_width = w->width;
+	em->overlay_frame_height = w->height;
+
+	if (em->overlay_enabled) {
+		sub_4288c(em, em->overlay_frame_xpos, em->overlay_frame_ypos, em->overlay_frame_width,
+			em->overlay_frame_height, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+	} else {
+		em8300_dicom_update(em);
+	}
+
+	return 1;
+}
+
+int em8300_ioctl_overlay_setscreen(struct em8300_s *em, em8300_overlay_screen_t *s)
+{
+	if (s->xsize < 0 || s->xsize > 2000) {
+		return 0;
+	}
+	if (s->ysize < 0 || s->ysize > 2000) {
+		return 0;
+	}
+
+	em9010_overlay_set_res(em, s->xsize, s->ysize);
+	return 1;
+}
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_main.c linux-2.6.10-em8300/drivers/media/em8300/em8300_main.c
--- linux-2.6.10/drivers/media/em8300/em8300_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_main.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,814 @@
+/*
+	em8300.c - EM8300 MPEG-2 decoder device driver
+
+	Copyright (C) 2000 Henrik Johansson <henrikjo@post.utfors.se>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/autoconf.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/sound.h>
+#include <linux/signal.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/devfs_fs_kernel.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <asm/segment.h>
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "encoder.h"
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+#include "em8300_fifo.h"
+
+/* It seems devfs will implement a new scheme of enumerating minor numbers.
+ * Currently it seems broken. But that is why we added these macros.
+ */
+#define EM8300_MINOR(inode) (iminor(inode) % 4)
+#define EM8300_CARD(inode) (iminor(inode) / 4)
+
+#if !defined(CONFIG_I2C_ALGOBIT) && !defined(CONFIG_I2C_ALGOBIT_MODULE)
+#error "This needs the I2C Bit Banging Interface in your Kernel"
+#endif
+
+MODULE_AUTHOR("Henrik Johansson <henrikjo@post.utfors.se>");
+MODULE_DESCRIPTION("EM8300 MPEG-2 decoder");
+MODULE_SUPPORTED_DEVICE("em8300");
+
+MODULE_LICENSE("GPL");
+
+static unsigned int use_bt865[EM8300_MAX]={};
+MODULE_PARM(use_bt865, "1-" __MODULE_STRING(EM8300_MAX) "i");
+MODULE_PARM_DESC(use_bt865, "Set this to 1 if you have a bt865. It changes some internal register values. Defaults to 0.");
+
+/*
+ * Module params by Jonas Birm (birme@jpl.nu)
+ */
+#ifdef CONFIG_EM8300_DICOMPAL
+int dicom_other_pal = 1;
+#else
+int dicom_other_pal = 0;
+#endif
+MODULE_PARM(dicom_other_pal, "i");
+MODULE_PARM_DESC(dicom_other_pal, "If this is set, then some internal register values are swapped for PAL and NTSC. Defaults to 1.");
+
+#ifdef CONFIG_EM8300_DICOMFIX
+int dicom_fix = 1;
+#else
+int dicom_fix = 0;
+#endif
+MODULE_PARM(dicom_fix, "i");
+MODULE_PARM_DESC(dicom_fix, "If this is set then some internal register values are changed. Fixes green screen problems for some. Defaults to 1.");
+
+#ifdef CONFIG_EM8300_DICOMCTRL
+int dicom_control = 1;
+#else
+int dicom_control = 0;
+#endif
+MODULE_PARM(dicom_control, "i");
+MODULE_PARM_DESC(dicom_control, "If this is set then some internal register values are changed. Fixes green screen problems for some. Defaults to 1.");
+
+#ifdef CONFIG_EM8300_UCODETIMEOUT
+int bt865_ucode_timeout = 1;
+#else
+int bt865_ucode_timeout = 0;
+#endif
+MODULE_PARM(bt865_ucode_timeout, "i");
+MODULE_PARM_DESC(bt865_ucode_timeout, "Set this to 1 if you have a bt865 and get timeouts when uploading the microcode. Defaults to 0.");
+
+#ifdef CONFIG_EM8300_LOOPBACK
+int activate_loopback = 1;
+#else
+int activate_loopback = 0;
+#endif
+MODULE_PARM(activate_loopback, "i");
+MODULE_PARM_DESC(activate_loopback, "If you lose video after loading the modules or uploading the microcode set this to 1. Defaults to 0.");
+
+static int em8300_cards = 0;
+static int clients = 0;
+
+static struct em8300_s em8300[EM8300_MAX];
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+static int dsp_num_table[16];
+#endif
+struct proc_dir_entry *em8300_proc;
+
+/* structure to keep track of the memory that has been allocated by
+   the user via mmap() */
+struct memory_info
+{
+       struct list_head item;
+       long length;
+       char *ptr;
+};
+
+static struct pci_device_id em8300_pci_table[] __devinitdata = {
+	{ 0x1105, 0x8300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, em8300_pci_table);
+
+static irqreturn_t em8300_irq(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct em8300_s *em = (struct em8300_s *) dev_id;
+	int irqstatus;
+	struct timeval tv;
+
+	irqstatus = read_ucregister(Q_IrqStatus);
+
+	if (irqstatus & 0x8000) {
+		write_ucregister(Q_IrqMask, 0x0);
+		em->mem[EM8300_INTERRUPT_ACK] = 2;
+
+		write_ucregister(Q_IrqStatus, 0x8000);
+
+		if (irqstatus & IRQSTATUS_VIDEO_FIFO) {
+			em8300_fifo_check(em->mvfifo);
+		}
+	
+		if (irqstatus & IRQSTATUS_AUDIO_FIFO) {
+			em8300_fifo_check(em->mafifo);
+		}
+
+		if (irqstatus & IRQSTATUS_VIDEO_VBL) {
+			em8300_fifo_check(em->spfifo);
+			em8300_video_check_ptsfifo(em);
+			em8300_spu_check_ptsfifo(em);
+
+			do_gettimeofday(&tv);
+			em->irqtimediff = TIMEDIFF(tv, em->tv);
+			em->tv = tv;
+			em->irqcount++;
+			wake_up(&em->vbi_wait);
+		}
+	
+		write_ucregister(Q_IrqMask, em->irqmask);
+		write_ucregister(Q_IrqStatus, 0x0000);
+	}
+	return IRQ_HANDLED;
+}
+
+static void release_em8300(struct em8300_s *em)
+{
+	if(em->encoder) {
+		em->encoder->driver->command(em->encoder, ENCODER_CMD_ENABLEOUTPUT, (void *) 0);
+	}
+	
+#ifdef CONFIG_MTRR	
+	if (em->mtrr_reg) {
+		mtrr_del(em->mtrr_reg,em->adr, em->memsize);
+	}
+#endif
+	
+	em8300_i2c_exit(em);
+	
+	write_ucregister(Q_IrqMask, 0);
+	write_ucregister(Q_IrqStatus, 0);
+	em->mem[0x2000] = 0;
+	
+	em8300_fifo_free(em->mvfifo);
+	em8300_fifo_free(em->mafifo);
+	em8300_fifo_free(em->spfifo);
+	
+	/* free it */
+	free_irq(em->dev->irq, em);
+	
+	/* unmap and free memory */
+	if (em->mem) {
+		iounmap((unsigned *) em->mem);
+	}
+}
+
+static int em8300_io_ioctl(struct inode* inode, struct file* filp, unsigned int cmd, unsigned long arg)
+{
+	struct em8300_s *em = filp->private_data;
+	int subdevice = EM8300_MINOR(inode);
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_AUDIO:
+		return em8300_audio_ioctl(em, cmd, arg);
+	case EM8300_SUBDEVICE_VIDEO:
+		return em8300_video_ioctl(em, cmd, arg);
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		return em8300_spu_ioctl(em, cmd, arg);
+	case EM8300_SUBDEVICE_CONTROL:
+		return em8300_control_ioctl(em, cmd, arg);
+	}
+
+	return -EINVAL;
+}
+
+static int em8300_io_open(struct inode* inode, struct file* filp) 
+{
+	int card = EM8300_CARD(inode);
+	int subdevice = EM8300_MINOR(inode);
+	struct em8300_s *em = &em8300[card];
+	int err = 0;
+  
+	pr_debug("em8300_main.o: Opening card %d, device %d, cards:%d\n",
+		 card, subdevice, em8300_cards);
+
+	if (card >= em8300_cards) {
+		return -ENODEV;
+	}
+
+	if (subdevice != EM8300_SUBDEVICE_CONTROL) {
+		if (em8300[card].inuse[subdevice]) {
+			return -EBUSY;
+		}
+	}
+  
+	filp->private_data = &em8300[card];
+	/* initalize the memory list */
+	INIT_LIST_HEAD(&em->memory);
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_CONTROL:
+		em8300[card].nonblock[0] = (filp->f_flags == O_NONBLOCK);
+		break;
+	case EM8300_SUBDEVICE_AUDIO:
+		em8300[card].nonblock[1] = (filp->f_flags == O_NONBLOCK);
+		err = em8300_audio_open(em);
+		break;
+	case EM8300_SUBDEVICE_VIDEO:
+		em8300[card].nonblock[2] = (filp->f_flags == O_NONBLOCK);
+		if (!em->ucodeloaded) {
+			return -ENODEV;
+		}
+		em8300_video_open(em);
+
+		em8300_ioctl_enable_videoout(em, 1);
+
+		em8300_video_setplaymode(em, EM8300_PLAYMODE_PLAY);
+		break;
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		em8300[card].nonblock[3] = (filp->f_flags == O_NONBLOCK);
+		if (!em->ucodeloaded) {
+			return -ENODEV;
+		}
+		err = em8300_spu_open(em);
+		break;
+	default:
+		return -ENODEV;
+		break;
+	}
+
+	if (err) {
+		return err;
+	}
+	
+	em8300[card].inuse[subdevice]++;
+
+	clients++;
+	pr_debug("em8300_main.o: Opening device %d, Clients:%d\n", subdevice, clients);
+  
+	return(0);
+}
+
+static int em8300_io_write(struct file *file, const char * buf,	size_t count, loff_t *ppos)
+{
+	struct em8300_s *em = file->private_data;
+	int subdevice = EM8300_MINOR(file->f_dentry->d_inode);
+	int ret;
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_VIDEO:
+		ret = em8300_video_write(em, buf, count, ppos);
+		break;
+	case EM8300_SUBDEVICE_AUDIO:
+		ret = em8300_audio_write(em, buf, count, ppos);
+		break;
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		ret = em8300_spu_write(em, buf, count, ppos);
+		break;
+	default:
+		ret = -EPERM;
+	}
+	return ret;
+}
+
+
+int em8300_io_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct em8300_s *em = file->private_data;
+	unsigned long size = vma->vm_end - vma->vm_start;
+	int subdevice = EM8300_MINOR(file->f_dentry->d_inode);
+
+	if (subdevice != EM8300_SUBDEVICE_CONTROL) {
+		return -EPERM;
+	}
+
+	switch (vma->vm_pgoff) {
+	case 1: {
+	        /* fixme: we should count the total size of allocated memories
+		   so we don't risk a out-of-memory or denial-of-service attack... */
+		
+	        char *mem = 0;
+		struct memory_info *info = NULL;
+		unsigned long adr = 0;
+		unsigned long size = vma->vm_end - vma->vm_start;
+		unsigned long pages = (size+(PAGE_SIZE-1))/PAGE_SIZE;
+		/* round up the memory */
+		size = pages * PAGE_SIZE;
+		
+		/* allocate the physical contiguous memory */
+		mem = (char*)kmalloc(pages*PAGE_SIZE, GFP_KERNEL);
+		if( mem == NULL) {
+			return -ENOMEM;
+		}
+		/* clear out the memory for sure */
+		memset(mem, 0x00, pages*PAGE_SIZE);
+		
+		/* reserve all pages */
+		for(adr = (long)mem; adr < (long)mem + size; adr += PAGE_SIZE) {
+                        SetPageReserved(virt_to_page(adr));
+		}
+		
+		/* lock the area*/
+		vma->vm_flags |=VM_LOCKED;
+		
+		/* remap the memory to user space */
+		if (remap_page_range(vma, vma->vm_start, virt_to_phys((void *)mem), size, vma->vm_page_prot)) {
+			kfree(mem);
+			return -EAGAIN;
+		}
+		
+		/* put the physical address into the first dword of the memory */
+		*((long*)mem) = virt_to_phys((void *)mem);
+		
+		/* keep track of the memory we have allocated */
+		info = (struct memory_info*)vmalloc(sizeof(struct memory_info));
+		if( NULL == info ) {
+			kfree(mem);
+			return -ENOMEM;
+		}
+		
+		info->ptr = mem;
+		info->length = size;
+		list_add_tail(&info->item,&em->memory);
+		
+		break;
+	}
+	case 0:
+		if (size > em->memsize) {
+			return -EINVAL;
+		}
+		remap_page_range(vma, vma->vm_start, em->adr, vma->vm_end - vma->vm_start, vma->vm_page_prot);
+		vma->vm_file = file;
+		atomic_inc(&file->f_dentry->d_inode->i_count);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int em8300_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct em8300_s *em = file->private_data;
+	int subdevice = EM8300_MINOR(file->f_dentry->d_inode);
+	unsigned int mask = 0;
+
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_AUDIO:
+		poll_wait(file, &em->mafifo->wait, wait);
+		if (file->f_mode & FMODE_WRITE) {
+			if (em8300_fifo_freeslots(em->mafifo)) {
+				pr_debug("Poll audio - Free slots: %d\n", em8300_fifo_freeslots(em->mafifo));
+				mask |= POLLOUT | POLLWRNORM;
+			}
+		}
+		break;
+	case EM8300_SUBDEVICE_VIDEO:
+		poll_wait(file, &em->mvfifo->wait, wait);
+		if (file->f_mode & FMODE_WRITE) {
+			if (em8300_fifo_freeslots(em->mvfifo)) {
+				pr_debug("Poll video - Free slots: %d\n", em8300_fifo_freeslots(em->mvfifo));
+				mask |= POLLOUT | POLLWRNORM;
+			}
+		}
+		break;
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		poll_wait(file, &em->spfifo->wait, wait);
+		if (file->f_mode & FMODE_WRITE) {
+			if (em8300_fifo_freeslots(em->spfifo)) {
+				pr_debug("Poll subpic - Free slots: %d\n", em8300_fifo_freeslots(em->spfifo));
+				mask |= POLLOUT | POLLWRNORM;
+			}
+		}
+	}
+	
+	return mask;
+}
+
+int em8300_io_release(struct inode* inode, struct file *filp)
+{
+	struct em8300_s *em = filp->private_data;
+	int subdevice = EM8300_MINOR(inode);
+	
+	switch (subdevice) {
+	case EM8300_SUBDEVICE_AUDIO:
+		em8300_audio_release(em);
+		break;
+	case EM8300_SUBDEVICE_VIDEO:
+		em8300_video_release(em);
+		em8300_ioctl_enable_videoout(em, 0);	
+		break;
+	case EM8300_SUBDEVICE_SUBPICTURE:
+		em8300_spu_release(em);
+		break;
+	}
+
+	while( 0 == list_empty(&em->memory)) {
+	    unsigned long adr = 0;
+	    
+	    struct memory_info *info = list_entry(em->memory.next, struct memory_info, item);
+	    list_del(&info->item);
+	    
+	    for(adr = (long)info->ptr; adr < (long)info->ptr + info->length; adr += PAGE_SIZE) {
+		    ClearPageReserved(virt_to_page(adr));
+	    }
+	    
+	    kfree(info->ptr);
+	    vfree(info);
+	}
+	
+	em->inuse[subdevice]--;
+
+	clients--;
+	pr_debug("em8300_main.o: Releasing device %d, clients:%d\n", subdevice, clients);
+
+	return(0);
+}
+   
+static struct file_operations em8300_fops = {
+	.owner    = THIS_MODULE,
+	.write    = em8300_io_write,
+	.ioctl    = em8300_io_ioctl,
+	.mmap     = em8300_io_mmap,
+	.poll     = em8300_poll,
+	.open     = em8300_io_open,
+	.release  = em8300_io_release,
+};
+
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+static int em8300_dsp_ioctl(struct inode* inode, struct file* filp, unsigned int cmd, unsigned long arg)
+{
+	struct em8300_s *em = filp->private_data;
+	return em8300_audio_ioctl(em, cmd, arg);
+}
+
+static int em8300_dsp_open(struct inode* inode, struct file* filp) 
+{
+	int dsp_num = ((iminor(inode) >> 4) & 0x0f);
+	int card = dsp_num_table[dsp_num] - 1;
+	int err = 0;
+
+        pr_debug("em8300: opening dsp %i for card %i\n", dsp_num, card);
+
+	if (card < 0 || card >= em8300_cards) {
+		return -ENODEV;
+	}
+
+        if (em8300[card].inuse[EM8300_SUBDEVICE_AUDIO]) {
+		return -EBUSY;
+	}
+  
+	filp->private_data = &em8300[card];
+
+        err = em8300_audio_open(&em8300[card]);
+
+	if (err) {
+		return err;
+	}
+	
+	em8300[card].inuse[EM8300_SUBDEVICE_AUDIO]++;
+
+	clients++;
+	pr_debug("em8300_main.o: Opening device %d, Clients:%d\n", EM8300_SUBDEVICE_AUDIO, clients);
+  
+	return(0);
+}
+
+static int em8300_dsp_write(struct file *file, const char * buf, size_t count, loff_t *ppos)
+{
+	struct em8300_s *em = file->private_data;
+	return em8300_audio_write(em, buf, count, ppos);
+}
+
+static unsigned int em8300_dsp_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct em8300_s *em = file->private_data;
+	unsigned int mask = 0;
+	poll_wait(file, &em->mafifo->wait, wait);
+	if (file->f_mode & FMODE_WRITE) {
+		if (em8300_fifo_freeslots(em->mafifo)) {
+			pr_debug("Poll dsp - Free slots: %d\n", em8300_fifo_freeslots(em->mafifo));
+			mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+	return mask;
+}
+
+int em8300_dsp_release(struct inode* inode, struct file* filp) 
+{
+	struct em8300_s *em = filp->private_data;
+	
+	em8300_audio_release(em);
+	
+	em->inuse[EM8300_SUBDEVICE_AUDIO]--;
+
+	clients--;
+	pr_debug("em8300_main.o: Releasing device %d, clients:%d\n", EM8300_SUBDEVICE_AUDIO, clients);
+
+	return(0);
+}
+
+static struct file_operations em8300_dsp_audio_fops = {
+	.owner   = THIS_MODULE,
+	.write   = em8300_dsp_write,
+	.ioctl   = em8300_dsp_ioctl,
+	.poll    = em8300_dsp_poll,
+	.open    = em8300_dsp_open,
+	.release = em8300_dsp_release,
+};
+#endif
+
+int em8300_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+        int len = 0;
+	struct em8300_s *em = (struct em8300_s *) data;    
+    
+        *start = 0;
+        *eof = 1;
+    
+        len += sprintf(page + len, "----- Driver Info -----\n");
+	len += sprintf(page + len, "em8300 module version %s\n", EM8300_VERSION);
+        if (em->ucodeloaded) {
+		/* Device information */
+		len += sprintf(page + len, "Card revision %d\n", em->pci_revision);
+		len += sprintf(page + len, "Chip revision %d\n", em->chip_revision);
+		len += sprintf(page + len, "Memory mapped at addressrange 0x%0x->0x%0x%s\n", (unsigned int) em->mem, 
+				(unsigned int) em->mem + (unsigned int) em->memsize, (em->mtrr_reg ? " (FIFOs using MTRR)" : ""));
+		len += sprintf(page + len, "Displaybuffer resolution: %dx%d\n", em->dbuf_info.xsize, em->dbuf_info.ysize);
+		len += sprintf(page + len, "Dicom set to %s\n", (em->dicom_tvout?"TV-out":"overlay"));
+		if (em->dicom_tvout) {
+			len += sprintf(page + len, "Using %s\n", (em->video_mode == EM8300_VIDEOMODE_PAL ? "PAL" : "NTSC"));
+			len += sprintf(page + len, "Aspect is %s\n", (em->aspect_ratio == EM8300_ASPECTRATIO_4_3 ? "4:3" : "16:9"));
+		} else {
+			len += sprintf(page + len, "em9010 %s\n", (em->overlay_enabled ? "online" : "offline"));
+			len += sprintf(page + len, "video mapped to screen coordinates %dx%d (%dx%d)\n", em->overlay_frame_xpos,
+					em->overlay_frame_ypos, em->overlay_xres, em->overlay_yres);
+		}
+		len += sprintf(page + len, "%s audio output\n", (em->audio_mode == EM8300_AUDIOMODE_ANALOG ? "analog" : "digital"));
+	}
+	else {
+		len += sprintf(page + len, "Microcode hasn't been loaded\n");
+	}
+	
+        return len;
+}
+
+static int init_em8300(struct em8300_s *em)
+{
+	/* Setup parameters */
+	static unsigned int *bt = use_bt865; 
+    
+	write_register(0x30000, read_register(0x30000));
+
+	write_register(0x1f50, 0x123);
+
+	if (read_register(0x1f50) == 0x123) {
+		em->chip_revision = 2;
+		if (0x40 & read_register(0x1c08)) {
+			em->var_video_value = 3375; /* was 0xd34 = 3380 */
+			em->mystery_divisor = 0x107ac;
+			em->var_ucode_reg2 = 0x272;
+			em->var_ucode_reg3 = 0x8272;
+			if (0x20 & read_register(0x1c08)) {
+				if(*bt) {
+					em->var_ucode_reg1 = 0x800;
+				} else {
+					em->var_ucode_reg1 = 0x818;
+				}
+			}
+		} else {
+			em->var_video_value = 0xce4;
+			em->mystery_divisor = 0x101d0;
+			em->var_ucode_reg2 = 0x25a;
+			em->var_ucode_reg3 = 0x825a;
+		}
+	} else {
+		em->chip_revision = 1;            
+		em->var_ucode_reg1 = 0x80;
+		em->var_video_value = 0xce4;
+		em->mystery_divisor = 0x101d0;
+		em->var_ucode_reg2 = 0xC7;
+		em->var_ucode_reg3 = 0x8c7;
+	}
+
+	pr_info("em8300_main.o: Chip revision: %d\n", em->chip_revision);
+	pr_debug("em8300_main.o: use_bt865: %d\n", *bt);
+	em8300_i2c_init(em);
+
+	bt++;
+
+	if (activate_loopback == 0) {
+		em->clockgen_tvmode = CLOCKGEN_TVMODE_1;
+		em->clockgen_overlaymode = CLOCKGEN_OVERLAYMODE_1;
+	} else {
+		em->clockgen_tvmode = CLOCKGEN_TVMODE_2;
+		em->clockgen_overlaymode = CLOCKGEN_OVERLAYMODE_2;
+	}
+
+	pr_debug("em8300_main.o: activate_loopback: %d\n", activate_loopback);
+
+	return 0;
+}
+
+static int __devinit em8300_probe(struct pci_dev *dev,
+				  const struct pci_device_id *pci_id)
+{
+	unsigned char revision;
+	struct em8300_s *em;
+	char devname[64];
+	int result;
+	struct proc_dir_entry *proc;
+
+	em = &em8300[em8300_cards];
+	em->card = em8300_cards;
+	em->dev = dev;
+	em->adr = dev->resource[0].start;
+	em->memsize = 1024 * 1024;
+
+	pci_enable_device(dev);
+	pci_read_config_byte(dev, PCI_CLASS_REVISION, &revision);
+	em->pci_revision = revision;
+	pr_info("em8300: EM8300 %x (rev %d) ", dev->device, revision);
+	printk("bus: %d, devfn: %d, irq: %d, ", dev->bus->number, dev->devfn, dev->irq);
+	printk("memory: 0x%08lx.\n", em->adr);
+
+	em->mem = ioremap(em->adr, em->memsize);
+	pr_info("em8300: mapped-memory at 0x%p\n", em->mem);
+#ifdef CONFIG_MTRR
+	em->mtrr_reg = mtrr_add(em->adr, em->memsize, MTRR_TYPE_UNCACHABLE, 1);
+	if (em->mtrr_reg) pr_info("em8300: using MTRR\n");
+#endif
+	
+	result = request_irq(dev->irq, em8300_irq, SA_SHIRQ | SA_INTERRUPT, "em8300", (void *) em);
+	
+	if (result == -EINVAL) {
+		printk(KERN_ERR "em8300: Bad irq number or handler\n");
+		return -EINVAL;
+	}	
+	
+	pci_set_master(dev);
+	pci_set_drvdata(dev, (void *)em);
+
+	em->irqmask = 0;
+	em->encoder = NULL;
+	em->linecounter=0;
+		
+	init_em8300(em);
+
+	sprintf(devname, "%d", em8300_cards );
+	proc = create_proc_entry(devname, S_IFREG | S_IRUGO, em8300_proc);
+	proc->data = (void *) em;
+	proc->read_proc = em8300_proc_read;
+	proc->owner = THIS_MODULE;
+	devfs_mk_cdev(MKDEV(EM8300_MAJOR, (em8300_cards * 4)),
+		      S_IFCHR | S_IRUSR | S_IWUSR,
+		      "%s-%d", EM8300_LOGNAME, em8300_cards);
+	devfs_mk_cdev(MKDEV(EM8300_MAJOR, (em8300_cards * 4) + 1),
+		      S_IFCHR | S_IRUGO | S_IWUGO,
+		      "%s_mv-%d", EM8300_LOGNAME, em8300_cards);
+	devfs_mk_cdev(MKDEV(EM8300_MAJOR, (em8300_cards * 4) + 2),
+		      S_IFCHR | S_IRUGO | S_IWUGO,
+		      "%s_ma-%d", EM8300_LOGNAME, em8300_cards);
+	devfs_mk_cdev(MKDEV(EM8300_MAJOR, (em8300_cards * 4) + 3),
+		      S_IFCHR | S_IRUGO | S_IWUGO,
+		      "%s_sp-%d", EM8300_LOGNAME, em8300_cards);
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+	if ((em->dsp_num = register_sound_dsp(&em8300_dsp_audio_fops, -1)) < 0) {
+		printk(KERN_ERR "em8300: cannot register oss audio device!\n");
+	} else {
+		dsp_num_table[em->dsp_num >> 4 & 0x0f] = em8300_cards + 1;
+		pr_debug("em8300: registered dsp %i for device %i\n", em->dsp_num >> 4 & 0x0f, em8300_cards);
+	}
+#endif
+
+	em8300_cards++;
+	return 0;
+}
+
+static void __devexit em8300_remove(struct pci_dev *pci)
+{
+	struct em8300_s *em = pci_get_drvdata(pci);
+	char devname[64];
+
+	if (em) {
+		devfs_remove("%s-%d", EM8300_LOGNAME, em->card);
+		devfs_remove("%s_mv-%d", EM8300_LOGNAME, em->card);
+		devfs_remove("%s_ma-%d", EM8300_LOGNAME, em->card);
+		devfs_remove("%s_sp-%d", EM8300_LOGNAME, em->card);
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+		unregister_sound_dsp(em->dsp_num);
+#endif
+		sprintf(devname, "%d", em->card );
+		remove_proc_entry(devname, em8300_proc);
+		release_em8300(em);
+	}
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name     = "Sigma Designs EM8300",
+	.id_table = em8300_pci_table,
+	.probe    = em8300_probe,
+	.remove   = __devexit_p(em8300_remove),
+};
+
+static void __exit em8300_exit(void)
+{
+	char devname[64];
+
+	pci_unregister_driver(&driver);
+
+	sprintf(devname, "%s", EM8300_LOGNAME );
+	if (em8300_proc != NULL) remove_proc_entry(devname, &proc_root);
+	unregister_chrdev(EM8300_MAJOR, EM8300_LOGNAME);
+}
+
+static int __init em8300_init(void)
+{
+	int err = -ENODEV;
+	char devname[32];
+
+#if defined(CONFIG_SOUND) || defined(CONFIG_SOUND_MODULE)
+	memset(&dsp_num_table, 0, sizeof(dsp_num_table));
+	//request_module("soundcore");
+#endif
+
+	sprintf(devname, "%s", EM8300_LOGNAME);
+	em8300_proc = create_proc_entry(devname, S_IFDIR | S_IRUGO | S_IXUGO, &proc_root);
+	if (em8300_proc == NULL) {
+		printk(KERN_ERR "em8300: unable to register proc entry!\n");
+		return -ENODEV;
+	}
+	em8300_proc->owner = THIS_MODULE;
+
+        if ((err = pci_module_init(&driver)) < 0) {
+#ifdef MODULE
+		printk(KERN_ERR "Sigmadesigns EM8300 not found or device busy\n");
+#endif
+		return err;
+	}
+
+	if (register_chrdev(EM8300_MAJOR, EM8300_LOGNAME, &em8300_fops)) {
+		printk(KERN_ERR "em8300: unable to get major %d\n", EM8300_MAJOR);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+module_init(em8300_init);
+module_exit(em8300_exit);
+
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_misc.c linux-2.6.10-em8300/drivers/media/em8300/em8300_misc.c
--- linux-2.6.10/drivers/media/em8300/em8300_misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_misc.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,140 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+
+#include <linux/soundcard.h>
+
+int em8300_waitfor(struct em8300_s *em, int reg, int val, int mask)
+{
+	int tries;
+
+	for (tries = 0; tries < 100; tries++) {
+		if ((em->mem[reg] & mask) == val) {
+			return 0;
+		}
+		//mdelay(10);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ*10/1000);
+	}
+
+	return -ETIME;
+}
+
+int em8300_waitfor_not(struct em8300_s *em, int reg, int val, int mask)
+{
+	int tries;
+
+	for (tries = 0; tries < 100; tries++) {
+		if ((em->mem[reg] & mask) != val) {
+			return 0;
+		}
+		//mdelay(10);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ*10/1000);
+	}
+
+	return -ETIME;
+}
+
+int em8300_setregblock(struct em8300_s *em, int offset, int val, int len)
+{
+	int i;
+
+	for (i = 1000; i; i--) {
+		if (!read_register(0x1c1a)) {
+			break;
+		}
+		if (!i) {
+			return -ETIME;
+		}
+	}
+#if 0 /* FIXME: was in the zeev01 branch, verify if it is necessary */
+	val = val | (val << 8) | (val << 16) | (val << 24);
+#endif
+
+	em->mem[0x1c11] = offset & 0xffff;
+	em->mem[0x1c12] = (offset >> 16) & 0xffff;
+	em->mem[0x1c13] = len;
+	em->mem[0x1c14] = len;
+	em->mem[0x1c15] = 0;
+	em->mem[0x1c16] = 1;
+	em->mem[0x1c17] = 1;
+	em->mem[0x1c18] = offset & 0xffff;
+	em->mem[0x1c19] = 0;
+
+	em->mem[0x1c1a] = 1;
+
+	for (i = 0; i < len / 4; i++) {
+		em->mem[0x11800] = val;
+	}
+
+	switch (len % 4) {
+	case 1:
+		em->mem[0x10000] = val;
+		break;
+	case 2:
+		em->mem[0x10800] = val;
+		break;
+	case 3:
+		em->mem[0x11000] = val;
+		break;
+	}
+
+	for (i = 1000; i; i--) {
+		if (!read_register(0x1c1a)) {
+			break;
+		}
+		if (!i) {
+			return -ETIME;
+		}
+	}
+
+#if 0 /* FIXME: was in zeev01 branch, verify if it is necessary */	
+	if (em8300_waitfor(em, 0x1c1a, 0, 1)) 
+	        return -ETIME;  
+#endif
+
+	return 0;
+}
+
+int em8300_writeregblock(struct em8300_s *em, int offset, unsigned *buf, int len)
+{
+	int i;
+
+	em->mem[0x1c11] = offset & 0xffff;
+	em->mem[0x1c12] = (offset >> 16) & 0xffff;
+	em->mem[0x1c13] = len;
+	em->mem[0x1c14] = len;
+	em->mem[0x1c15] = 0;
+	em->mem[0x1c16] = 1;
+	em->mem[0x1c17] = 1;
+	em->mem[0x1c18] = offset & 0xffff;
+	em->mem[0x1c19] = (offset >> 16) & 0xffff;
+
+	em->mem[0x1c1a] = 1;
+
+	for (i = 0; i < len / 4; i++) {
+		em->mem[0x11800] = *buf++;
+	}
+
+	if (em8300_waitfor(em, 0x1c1a, 0, 1)) {
+		return -ETIME;
+	}
+	return 0;
+}
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_reg.c linux-2.6.10-em8300/drivers/media/em8300/em8300_reg.c
--- linux-2.6.10/drivers/media/em8300/em8300_reg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_reg.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,114 @@
+char *ucodereg_names[] = {
+	"MV_Command",
+	"MV_Status",
+	"MV_BuffStart_Lo",
+	"MV_BuffStart_Hi",
+	"MV_BuffSize_Lo",
+	"MV_BuffSize_Hi",
+	"MV_RdPtr_Lo",
+	"MV_RdPtr_Hi",
+	"MV_Threshold",
+	"MV_Wrptr_Lo",
+	"MV_Wrptr_Hi",
+	"MV_PCIRdPtr",
+	"MV_PCIWrPtr",
+	"MV_PCISize",
+	"MV_PCIStart",
+	"MV_PTSRdPtr",
+	"MV_PTSSize",
+	"MV_PTSFifo",
+	"MV_SCRSpeed",
+	"MV_SCRlo",
+	"MV_SCRhi",
+	"MV_FrameCntLo",
+	"MV_FrameCntHi",
+	"MV_FrameEventLo",
+	"MV_FrameEventHi",
+	"MV_AccSpeed",
+	"Width_Buf3",
+	"MA_Command",
+	"MA_Status",
+	"MA_BuffStart_Lo",
+	"MA_BuffStart_Hi",
+	"MA_BuffSize",
+	"MA_BuffSize_Hi",
+	"MA_Rdptr",
+	"MA_Rdptr_Hi",
+	"MA_Threshold",
+	"MA_Wrptr",
+	"MA_Wrptr_Hi",
+	"Q_IrqMask",
+	"Q_IrqStatus",
+	"Q_IntCnt",
+	"MA_PCIRdPtr",
+	"MA_PCIWrPtr",
+	"MA_PCISize",
+	"MA_PCIStart",
+	"SP_Command",
+	"SP_Status",
+	"SP_BuffStart_Lo",
+	"SP_BuffStart_Hi",
+	"SP_BuffSize_Lo",
+	"SP_BuffSize_Hi",
+	"SP_RdPtr_Lo",
+	"SP_RdPtr_Hi",
+	"SP_Wrptr_Lo",
+	"SP_Wrptr_Hi",
+	"SP_PCIRdPtr",
+	"SP_PCIWrPtr",
+	"SP_PCISize",
+	"SP_PCIStart",
+	"SP_PTSRdPtr",
+	"SP_PTSSize",
+	"SP_PTSFifo",
+	"DICOM_DisplayBuffer",
+	"Vsync_DBuf",
+	"DICOM_TvOut",
+	"DICOM_UpdateFlag",
+	"DICOM_VSyncLo1",
+	"DICOM_VSyncLo2",
+	"DICOM_VSyncDelay1",
+	"DICOM_VSyncDelay2",
+	"DICOM_Display_Data",
+	"PicPTSLo",
+	"PicPTSHi",
+	"Error_Code",
+	"DisplayHorSize",
+	"Line21Buf1_Cnt",
+	"Line21Buf2_Cnt",
+	"TimeCodeHi",
+	"TimeCodeLo",
+	"AUTH_Challenge",
+	"AUTH_Response",
+	"AUTH_Command",
+	"Timer_Cnt",
+	"Ovl_Addr",
+	"Button_Color",
+	"Button_Contrast",
+	"Button_Top",
+	"Button_Bottom",
+	"Button_Left",
+	"Button_Right",
+	"SP_Palette",
+	"DICOM_FrameTop",
+	"DICOM_FrameBottom",
+	"DICOM_FrameLeft",
+	"DICOM_FrameRight",
+	"DICOM_VisibleTop",
+	"DICOM_VisibleBottom",
+	"DICOM_VisibleLeft",
+	"DICOM_VisibleRight",
+	"DICOM_BCSLuma",
+	"DICOM_BCSChroma",
+	"DICOM_Control",
+	"DICOM_Controlx",
+	"MV_CryptKey",
+	"DICOM_Kmin",
+	"MicroCodeVersion",
+	"ForcedLeftParity",
+	"L21_Buf1",
+	"L21_Buf2",
+	"Mute_Pattern",
+	"Mute_Patternrityhtm",
+	NULL
+};
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_reg.h linux-2.6.10-em8300/drivers/media/em8300/em8300_reg.h
--- linux-2.6.10/drivers/media/em8300/em8300_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_reg.h	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,141 @@
+/*
+  Register access macros
+*/
+
+#define register_ptr(a) &em->mem[a]
+#define ucregister_ptr(a) &em->mem[em->ucode_regs[a]]
+#define ucregister(a) em->ucode_regs[a]
+
+#define write_register(a,v) *((volatile unsigned *) (em->mem + a)) = v
+#define read_register(a) *((volatile unsigned *) (em->mem + a))
+#define write_ucregister(a,v) *((volatile unsigned *) (em->mem + em->ucode_regs[a])) = v
+#define read_ucregister(a) *((volatile unsigned *) (em->mem + em->ucode_regs[a]))
+
+/*
+  EM8300 fixed registers
+*/
+
+#define EM8300_I2C_OE 0x1f4e
+#define EM8300_I2C_PIN 0x1f4d
+#define EM8300_AUDIO_RATE 0x1fb0
+#define EM8300_INTERRUPT_ACK 0x1ffa
+#define EM8300_HSYNC_HI 0x1f43
+#define EM8300_HSYNC_LO 0x1f42
+#define EM8300_VSYNC_HI 0x1f45
+
+/*
+  EM8300 microcode dependent registers
+*/
+
+#define MV_Command 0
+#define MV_Status 1
+#define MV_BuffStart_Lo 2
+#define MV_BuffStart_Hi 3
+#define MV_BuffSize_Lo 4
+#define MV_BuffSize_Hi 5
+#define MV_RdPtr_Lo 6
+#define MV_RdPtr_Hi 7
+#define MV_Threshold 8
+#define MV_Wrptr_Lo 9
+#define MV_Wrptr_Hi 10
+#define MV_PCIRdPtr 11
+#define MV_PCIWrPtr 12
+#define MV_PCISize 13
+#define MV_PCIStart 14
+#define MV_PTSRdPtr 15
+#define MV_PTSSize 16
+#define MV_PTSFifo 17
+#define MV_SCRSpeed 18
+#define MV_SCRlo 19
+#define MV_SCRhi 20
+#define MV_FrameCntLo 21
+#define MV_FrameCntHi 22
+#define MV_FrameEventLo 23
+#define MV_FrameEventHi 24
+#define MV_AccSpeed 25
+#define Width_Buf3 26
+#define MA_Command 27
+#define MA_Status 28
+#define MA_BuffStart_Lo 29
+#define MA_BuffStart_Hi 30
+#define MA_BuffSize 31
+#define MA_BuffSize_Hi 32
+#define MA_Rdptr 33
+#define MA_Rdptr_Hi 34
+#define MA_Threshold 35
+#define MA_Wrptr 36
+#define MA_Wrptr_Hi 37
+#define Q_IrqMask 38
+#define Q_IrqStatus 39
+#define Q_IntCnt 40
+#define MA_PCIRdPtr 41
+#define MA_PCIWrPtr 42
+#define MA_PCISize 43
+#define MA_PCIStart 44
+#define SP_Command 45
+#define SP_Status 46
+#define SP_BuffStart_Lo 47
+#define SP_BuffStart_Hi 48
+#define SP_BuffSize_Lo 49
+#define SP_BuffSize_Hi 50
+#define SP_RdPtr_Lo 51
+#define SP_RdPtr_Hi 52
+#define SP_Wrptr_Lo 53
+#define SP_Wrptr_Hi 54
+#define SP_PCIRdPtr 55
+#define SP_PCIWrPtr 56
+#define SP_PCISize 57
+#define SP_PCIStart 58
+#define SP_PTSRdPtr 59
+#define SP_PTSSize 60
+#define SP_PTSFifo 61
+#define DICOM_DisplayBuffer 62
+#define Vsync_DBuf 63
+#define DICOM_TvOut 64
+#define DICOM_UpdateFlag 65
+#define DICOM_VSyncLo1 66
+#define DICOM_VSyncLo2 67
+#define DICOM_VSyncDelay1 68
+#define DICOM_VSyncDelay2 69
+#define DICOM_Display_Data 70
+#define PicPTSLo 71
+#define PicPTSHi 72
+#define Error_Code 73
+#define DisplayHorSize 74
+#define Line21Buf1_Cnt 75
+#define Line21Buf2_Cnt 76
+#define TimeCodeHi 77
+#define TimeCodeLo 78
+#define AUTH_Challenge 79
+#define AUTH_Response 80
+#define AUTH_Command 81
+#define Timer_Cnt 82
+#define Ovl_Addr 83
+#define Button_Color 84
+#define Button_Contrast 85
+#define Button_Top 86
+#define Button_Bottom 87
+#define Button_Left 88
+#define Button_Right 89
+#define SP_Palette 90
+#define DICOM_FrameTop 91
+#define DICOM_FrameBottom 92
+#define DICOM_FrameLeft 93
+#define DICOM_FrameRight 94
+#define DICOM_VisibleTop 95
+#define DICOM_VisibleBottom 96
+#define DICOM_VisibleLeft 97
+#define DICOM_VisibleRight 98
+#define DICOM_BCSLuma 99
+#define DICOM_BCSChroma 100
+#define DICOM_Control 101
+#define DICOM_Controlx 102
+#define MV_CryptKey 103
+#define DICOM_Kmin 104
+#define MicroCodeVersion 105
+#define ForcedLeftParity 106
+#define L21_Buf1 107
+#define L21_Buf2 108
+#define Mute_Pattern 109
+#define Mute_Patternrityhtm 110
+
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_spu.c linux-2.6.10-em8300/drivers/media/em8300/em8300_spu.c
--- linux-2.6.10/drivers/media/em8300/em8300_spu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_spu.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,175 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+#include "em8300_fifo.h"
+
+unsigned default_palette[16] = {
+	0xe18080, 0x2b8080, 0x847b9c, 0x51ef5a, 0x7d8080, 0xb48080, 0xa910a5,
+	0x6addca, 0xd29210, 0x1c76b8, 0x50505a, 0x30b86d, 0x5d4792,
+	0x3dafa5, 0x718947, 0xeb8080
+};
+
+int em8300_spu_setpalette(struct em8300_s *em, unsigned *pal)
+{
+	int i, palette;
+	
+	palette = ucregister(SP_Palette);
+
+	for (i=0; i < 16; i++) {
+		write_register(palette + i * 2, pal[i] >> 16);
+		write_register(palette + i * 2 + 1, pal[i] & 0xffff);
+	}
+
+	return 0;
+}
+
+int em8300_spu_button(struct em8300_s *em, em8300_button_t *btn)
+{
+	write_ucregister(SP_Command, 0x2);
+	
+	if (btn == 0) /* btn = 0 means release button */
+		return 0;
+
+	write_ucregister(Button_Color, btn->color);
+	write_ucregister(Button_Contrast, btn->contrast);
+	write_ucregister(Button_Top, btn->top);
+	write_ucregister(Button_Bottom, btn->bottom);
+	write_ucregister(Button_Left, btn->left);
+	write_ucregister(Button_Right, btn->right);
+
+	write_ucregister(DICOM_UpdateFlag, 1);
+	write_ucregister(SP_Command, 0x102);
+
+	return 0;
+}
+
+void em8300_spu_check_ptsfifo(struct em8300_s *em)
+{
+	int ptsfifoptr;
+	
+		ptsfifoptr = ucregister(SP_PTSFifo) + 2 * em->sp_ptsfifo_ptr;
+
+		if (!(read_register(ptsfifoptr + 1) & 1)) {
+			wake_up_interruptible(&em->sp_ptsfifo_wait);
+		}
+	}
+
+int em8300_spu_write(struct em8300_s *em, const char * buf, size_t count, loff_t *ppos)
+{
+	int flags = 0;
+	unsigned long safe_jiff = jiffies;
+    
+	if (!(em->sp_mode)) return 0;
+//	em->sp_ptsvalid=0;
+	if (em->sp_ptsvalid) {
+		int ptsfifoptr;
+	
+		ptsfifoptr = ucregister(SP_PTSFifo) + 2 * em->sp_ptsfifo_ptr;
+	
+		if (read_register(ptsfifoptr + 1) & 1) {
+			interruptible_sleep_on_timeout(&em->sp_ptsfifo_wait, HZ);
+    			if time_after_eq(jiffies, safe_jiff + HZ) {
+				printk(KERN_ERR 
+				       "em8300_spu.c: SPU Fifo timeout\n");
+				return -EINTR;
+			}
+
+			if (signal_pending(current)) {
+				return -EINTR;
+			}
+		}
+
+		write_register(ptsfifoptr + 0, em->sp_pts >> 16);
+		write_register(ptsfifoptr + 1, (em->sp_pts & 0xffff) | 1);
+		em->sp_ptsfifo_ptr++;
+		em->sp_ptsfifo_ptr &= read_ucregister(SP_PTSSize) / 2 - 1;
+
+		em->sp_ptsvalid = 0;
+	}
+
+	return em8300_fifo_write(em->spfifo, count, buf, flags, em->nonblock[3]);
+}
+
+int em8300_spu_ioctl(struct em8300_s *em, unsigned int cmd, unsigned long arg)
+{
+	int err;
+	unsigned clu[16];
+	
+	switch (cmd) {
+	case EM8300_IOCTL_SPU_SETPTS:
+		if (get_user(em->sp_pts, (int *) arg)) {
+			return -EFAULT;
+		}
+		em->sp_pts >>= 1;
+		em->sp_ptsvalid = 1;
+		break;
+	case EM8300_IOCTL_SPU_SETPALETTE:
+		if ((err = verify_area(VERIFY_READ, (void *) arg, 16 * 4) < 0)) {
+			return err;
+		}
+		copy_from_user(clu, (void *) arg, 16 * 4);
+		em8300_spu_setpalette(em, clu);
+		break;
+	case EM8300_IOCTL_SPU_BUTTON:
+		{
+			em8300_button_t btn;
+			if (arg == 0) {
+				em8300_spu_button(em, 0);
+				break;
+			}
+			if ((err = verify_area(VERIFY_READ, (void *) arg, sizeof(btn)) < 0))
+				return err;
+			copy_from_user(&btn, (void*) arg, sizeof(btn));
+			em8300_spu_button(em, &btn);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int em8300_spu_init(struct em8300_s *em)
+{
+	init_waitqueue_head(&em->sp_ptsfifo_wait);
+	return 0;
+}
+
+int em8300_spu_open(struct em8300_s *em)
+{
+	em->sp_ptsfifo_ptr = 0;
+	em->sp_ptsvalid = 0;
+	em->sp_mode = 1;
+	em8300_spu_setpalette(em, default_palette);
+	write_ucregister(SP_Command, 0x2);
+
+	return 0;
+}
+
+void em8300_spu_release(struct em8300_s *em)
+{
+	em->sp_pts = 0;
+	em->sp_ptsvalid = 0;
+	em->sp_count = 0;
+	em->sp_ptsfifo_ptr = 0;
+	em8300_fifo_sync(em->spfifo);
+
+	return em8300_spu_check_ptsfifo(em);
+}
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_ucode.c linux-2.6.10-em8300/drivers/media/em8300/em8300_ucode.c
--- linux-2.6.10/drivers/media/em8300/em8300_ucode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_ucode.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,172 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+
+#include <linux/soundcard.h>
+
+#include "em8300_reg.c"
+
+static int upload_block(struct em8300_s *em, int blocktype, int offset, int len, unsigned char *buf)
+{
+	int i, val;
+
+	switch (blocktype) {
+	case 4:
+		offset *= 2;
+		em->mem[0x1c11] = offset & 0xffff;
+		em->mem[0x1c12] = (offset >> 16) & 0xffff;
+		em->mem[0x1c13] = len;
+		em->mem[0x1c14] = len;
+		em->mem[0x1c15] = 0;
+		em->mem[0x1c16] = 1;
+		em->mem[0x1c17] = 1;
+		em->mem[0x1c18] = offset & 0xffff;
+		em->mem[0x1c19] = (offset >> 16) & 0xffff;
+
+		em->mem[0x1c1a] = 1;
+
+		for (i = 0; i < len; i += 4) {
+			val = (buf[i + 2] << 24) | (buf[i + 3] << 16) | (buf[i] << 8) | buf[i + 1];
+			em->mem[0x11800] = val;
+		}
+	
+		if (em8300_waitfor(em, 0x1c1a, 0, 1)) {
+			return -ETIME;
+		}
+		break;
+	case 1:
+		for (i = 0; i < len; i += 4) {
+			val = (buf[i + 1] << 24) | (buf[i] << 16) | (buf[i + 3] << 8) | buf[i + 2];
+			em->mem[offset / 2 + i / 4] = val;
+		}
+		break;
+	case 2:
+		for (i = 0; i < len; i += 2) {
+			val = (buf[i + 1] << 8) | buf[i];
+			em->mem[0x1000 + offset + i / 2] = val;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static
+int upload_prepare(struct em8300_s *em)
+{
+	em->mem[0x30000] = 0x1ff00;
+	em->mem[0x1f50] = 0x123;
+
+	em->mem[0x20001] = 0x0;
+	em->mem[0x2000] = 0x2;
+	em->mem[0x2000] = 0x0;
+	em->mem[0x1ff8] = 0xffff;
+	em->mem[0x1ff9] = 0xffff;
+	em->mem[0x1ff8] = 0xff00;
+	em->mem[0x1ff9] = 0xff00;
+
+	if (em->chip_revision == 1) {
+		em->mem[0x1c04] = 0x8c7;
+		em->mem[0x1c00] = 0x80;
+		em->mem[0x1c04] = 0xc7;
+	}
+	em->mem[0x1c04] = em->var_ucode_reg3;
+	em->mem[0x1c00] = em->var_ucode_reg1;
+	em->mem[0x1c04] = em->var_ucode_reg2;
+	 
+	em->mem[0x1c08];
+	em->mem[0x1c10] = 0x8;
+	em->mem[0x1c20] = 0x8;
+	em->mem[0x1c30] = 0x8;
+	em->mem[0x1c40] = 0x8;
+	em->mem[0x1c50] = 0x8;
+	em->mem[0x1c60] = 0x8;
+	em->mem[0x1c70] = 0x8;
+	em->mem[0x1c80] = 0x8;
+	em->mem[0x1c90] = 0x10;
+	em->mem[0x1ca0] = 0x10;
+	em->mem[0x1cb0] = 0x8;
+	em->mem[0x1cc0] = 0x8;
+	em->mem[0x1cd0] = 0x8;
+	em->mem[0x1ce0] = 0x8;
+	em->mem[0x1c01] = 0x5555;
+	em->mem[0x1c02] = 0x55a;
+	em->mem[0x1c03] = 0x0;
+	
+	return 0;
+}
+
+int em8300_ucode_upload(struct em8300_s *em, void *ucode_user, int ucode_size)
+{
+	int flags, offset, len;
+	unsigned char *ucode, *p;
+	int memcount, i;
+	char regname[128];
+
+	ucode = kmalloc(ucode_size, GFP_KERNEL);
+	if (!ucode) {
+		return -ENOMEM;
+	}
+
+	upload_prepare(em);
+	
+	copy_from_user(ucode, ucode_user, ucode_size);
+
+	memcount = 0;
+
+	p = ucode;
+	while (memcount < ucode_size) {
+		flags =  p[0] | (p[1] << 8); p += 2;
+		offset = p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24); p += 4; 
+		len = p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24); p += 4;
+		memcount += 10;
+		len *= 2;
+
+		if (!flags)
+			break;
+	
+		switch (flags & 0xf00) {
+		case 0:
+			upload_block(em, flags, offset, len, p);
+			break;
+		case 0x200:
+			for (i = 0;i < len; i++) {
+				if (p[i]) {
+					regname[i] = p[i] ^ 0xff;
+				} else {
+					break;
+				}
+			}
+			regname[i] = 0;
+
+			for (i = 0; i < MAX_UCODE_REGISTER; i++) {
+				if (!strcmp(ucodereg_names[i], regname)) {
+					em->ucode_regs[i] = 0x1000 + offset;
+					break;
+				}
+			}
+			break;
+		}
+		memcount += len;
+		p += len;
+	}
+	
+	kfree(ucode);
+	return 0;
+}
diff -Nurw linux-2.6.10/drivers/media/em8300/em8300_video.c linux-2.6.10-em8300/drivers/media/em8300/em8300_video.c
--- linux-2.6.10/drivers/media/em8300/em8300_video.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em8300_video.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,411 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+#include "em8300_fifo.h"
+
+#include <linux/soundcard.h>
+
+extern int bt865_ucode_timeout;
+
+static int mpegvideo_command(struct em8300_s *em, int cmd)
+{
+	if (em8300_waitfor(em, ucregister(MV_Command), 0xffff, 0xffff)) {
+		return -1;
+	}
+
+	write_ucregister(MV_Command, cmd);
+	
+	if ((cmd == MVCOMMAND_DISPLAYBUFINFO) || (cmd == 0x10)) {
+		return em8300_waitfor_not(em, ucregister(DICOM_Display_Data), 0, 0xffff);
+	} else {
+		return em8300_waitfor(em, ucregister(MV_Command), 0xffff, 0xffff);
+	}
+}
+
+int em8300_video_setplaymode(struct em8300_s *em, int mode)
+{
+	if (mode == EM8300_PLAYMODE_FRAMEBUF) {
+		mpegvideo_command(em, MVCOMMAND_DISPLAYBUFINFO);
+		em->video_playmode = mode;
+		return 0;
+	}
+    
+	if (em->video_playmode != mode) {
+		switch (mode) {
+		case EM8300_PLAYMODE_STOPPED:
+			em->video_ptsfifo_ptr = 0;
+			em->video_offset = 0;
+			mpegvideo_command(em, MVCOMMAND_STOP);
+			break;
+		case EM8300_PLAYMODE_PLAY:
+			em->video_pts = 0;
+			em->video_lastpts = 0;
+			if (em->video_playmode == EM8300_PLAYMODE_STOPPED) {
+				write_ucregister(MV_FrameEventLo, 0xffff);
+				write_ucregister(MV_FrameEventHi, 0x7fff);
+			}
+			mpegvideo_command(em, MVCOMMAND_START);
+			break;
+		case EM8300_PLAYMODE_PAUSED:
+			mpegvideo_command(em, MVCOMMAND_PAUSE);
+			break;
+		default:
+			return -1;
+		}
+
+		em->video_playmode = mode;
+
+		return 0;
+	}
+
+	return -1;
+}
+
+int em8300_video_sync(struct em8300_s *em)
+{
+	int rdptr, wrptr, rdptr_last, synctimeout;
+
+	rdptr_last = 0;
+	synctimeout = 0;
+    
+	do {
+		wrptr = read_ucregister(MV_Wrptr_Lo) |
+			(read_ucregister(MV_Wrptr_Hi) << 16);
+		rdptr = read_ucregister(MV_RdPtr_Lo) |
+			(read_ucregister(MV_RdPtr_Hi) << 16);
+
+		if (rdptr == wrptr) {
+			break;
+		}
+		if (rdptr == rdptr_last) {
+			printk(KERN_DEBUG "em8300_video.o: Video sync rdptr is stuck at 0x%08x, wrptr 0x%08x, left %d\n", rdptr, wrptr, wrptr - rdptr);
+			break;
+		}
+		rdptr_last = rdptr;
+
+                set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ / 2);
+
+		if (signal_pending(current)) {
+		        set_current_state(TASK_RUNNING);
+			printk(KERN_ERR "em8300_video.o: Video sync interrupted\n");
+			return -EINTR;
+		}
+	} while (++synctimeout < 4);
+
+	if (rdptr != wrptr) {
+		printk(KERN_DEBUG "em8300_video.o: Video sync timeout\n");
+	}
+	set_current_state(TASK_RUNNING);
+	
+	return 0;
+}
+
+int em8300_video_flush(struct em8300_s *em)
+{
+	int pcirdptr = read_ucregister(MV_PCIRdPtr);
+	write_ucregister(MV_PCIWrPtr, pcirdptr);
+	*em->mvfifo->writeptr = *em->mvfifo->readptr;
+	em->video_ptsvalid = 0;
+	em->video_pts = 0;
+	return 0;
+}
+
+void set_dicom_kmin(struct em8300_s *em)
+{
+	int kmin;
+
+	kmin = (em->overlay_70 + 10) * 150645 / em->mystery_divisor;
+	if (kmin > 0x900) {
+		kmin = 0x900;
+	}
+	write_ucregister(DICOM_Kmin, kmin);
+	pr_debug("em8300: register DICOM_Kmin = 0x%x\n", kmin);
+}
+
+int em8300_video_setup(struct em8300_s *em)
+{
+	init_waitqueue_head(&em->video_ptsfifo_wait);
+	init_waitqueue_head(&em->vbi_wait);
+
+	write_register(0x1f47, 0x0);
+
+	if (em->encoder_type == ENCODER_BT865) {
+		write_register(0x1f5e, 0x9efe);
+		write_ucregister(DICOM_Control, 0x9efe);
+	} else {
+		write_register(0x1f5e, 0x9afe);
+		write_ucregister(DICOM_Control, 0x9afe);
+	}
+
+	write_register(EM8300_I2C_PIN, 0x3c3c);
+	write_register(EM8300_I2C_OE, 0x3c00);
+	write_register(EM8300_I2C_OE, 0x3c3c);
+	
+	write_register(EM8300_I2C_PIN, 0x808);
+	write_register(EM8300_I2C_PIN, 0x1010);
+	
+	em9010_init(em);
+	
+	em9010_write(em, 7, 0x40);
+	em9010_write(em, 9, 0x4);
+	
+	em9010_read(em, 0);
+	
+	udelay(100);
+	
+	write_ucregister(DICOM_UpdateFlag, 0x0);
+	
+	write_ucregister(DICOM_VisibleLeft, 0x168);
+	write_ucregister(DICOM_VisibleTop, 0x2e);
+	write_ucregister(DICOM_VisibleRight, 0x36b);
+	write_ucregister(DICOM_VisibleBottom, 0x11e);
+	write_ucregister(DICOM_FrameLeft, 0x168);
+	write_ucregister(DICOM_FrameTop, 0x2e);
+	write_ucregister(DICOM_FrameRight, 0x36b);
+	write_ucregister(DICOM_FrameBottom, 0x11e);
+	em8300_dicom_enable(em);
+
+	em9010_write16(em, 0x8, 0xff);
+	em9010_write16(em, 0x10, 0xff);
+	em9010_write16(em, 0x20, 0xff);
+
+	em9010_write(em, 0xa, 0x0);
+
+	if (em9010_cabledetect(em)) {
+		pr_debug("em8300: overlay loop-back cable detected\n");
+	}
+    
+	pr_debug("em8300: overlay reg 0x80 = %x \n", em9010_read16(em, 0x80));
+	
+	em9010_write(em, 0xb, 0xc8);
+	
+	pr_debug("em8300: register 0x1f4b = %x (0x138)\n", read_register(0x1f4b));
+
+	em9010_write16(em, 1, 0x4fe);
+	em9010_write(em, 1, 4);
+	em9010_write(em, 5, 0);
+	em9010_write(em, 6, 0);
+	em9010_write(em, 7, 0x40);
+	em9010_write(em, 8, 0x80);
+	em9010_write(em, 0xc, 0x8c);
+	em9010_write(em, 9, 0);
+
+	set_dicom_kmin(em);
+
+	em9010_write(em, 7, 0x80);
+	em9010_write(em, 9, 0);
+
+	if (bt865_ucode_timeout) {
+		write_register(0x1f47, 0x18);
+	}
+	if (em->encoder_type == ENCODER_BT865) {
+		write_register(0x1f5e, 0x9efe);
+		write_ucregister(DICOM_Control, 0x9efe);
+	} else {
+		if (!bt865_ucode_timeout) {
+			write_register(0x1f47, 0x18);
+		}
+		write_register(0x1f5e,0x9afe);
+		write_ucregister(DICOM_Control, 0x9afe);
+	}
+
+	write_ucregister(DICOM_UpdateFlag, 0x1);
+	
+	udelay(100);
+	
+	write_ucregister(ForcedLeftParity, 0x2);
+
+	write_ucregister(MV_Threshold, 0x90); // was 0x50 for BT865, but this works too
+
+	write_register(EM8300_INTERRUPT_ACK, 0x2);
+	write_ucregister(Q_IrqMask, 0x0);
+	write_ucregister(Q_IrqStatus, 0x0);
+	write_ucregister(Q_IntCnt, 0x64);
+
+	write_register(0x1ffb, em->var_video_value);
+
+	write_ucregister(MA_Threshold, 0x8);
+	
+	/* Release reset */
+	write_register(0x2000, 0x1);
+	
+	if (mpegvideo_command(em, MVCOMMAND_DISPLAYBUFINFO)) {
+		printk(KERN_ERR "em8300_video: mpegvideo_command(0x11) failed\n");
+		return -ETIME;
+	}
+	em8300_dicom_get_dbufinfo(em);
+        
+	write_ucregister(SP_Status, 0x0);
+	
+	if (mpegvideo_command(em, 0x10)) {
+		printk(KERN_ERR "em8300: mpegvideo_command(0x10) failed\n");
+		return -ETIME;
+	}
+
+	em8300_video_setspeed(em, 0x900);
+
+	write_ucregister(MV_FrameEventLo, 0xffff);
+	write_ucregister(MV_FrameEventHi, 0x7fff);
+
+	em8300_ioctl_setvideomode(em, EM8300_VIDEOMODE_DEFAULT);
+	em8300_ioctl_setaspectratio(em, EM8300_ASPECTRATIO_4_3);
+
+	em8300_dicom_setBCS(em, 500, 500, 500);
+
+	if (em8300_dicom_update(em)) {
+		printk(KERN_ERR "em8300: DICOM Update failed\n");
+		return -ETIME;
+	}
+
+	em->video_playmode = -1;
+	em8300_video_setplaymode(em, EM8300_PLAYMODE_STOPPED);
+
+	return 0;
+}
+
+void em8300_video_setspeed(struct em8300_s *em, int speed)
+{
+	if (read_ucregister(MicroCodeVersion) >= 0x29) {
+		write_ucregister(MV_SCRSpeed, speed);
+	} else {
+		write_ucregister(MV_SCRSpeed, speed >> 8);
+	}
+}
+
+void em8300_video_check_ptsfifo(struct em8300_s *em)
+{
+	int ptsfifoptr;
+    
+		ptsfifoptr = ucregister(MV_PTSFifo) + 4 * em->video_ptsfifo_ptr;
+
+		if (!(read_register(ptsfifoptr + 3) & 1)) {
+			wake_up_interruptible(&em->video_ptsfifo_wait);
+		}
+
+
+}
+
+int em8300_video_write(struct em8300_s *em, const char * buf, size_t count, loff_t *ppos)
+{
+	unsigned flags = 0;
+	int written;
+	unsigned long safe_jiff = jiffies;	
+	
+	if (em->video_ptsvalid) {
+		int ptsfifoptr = 0;
+		em->video_pts >>= 1;
+
+		flags = 0x40000000;
+		ptsfifoptr = ucregister(MV_PTSFifo) + 4 * em->video_ptsfifo_ptr;
+		
+		if (read_register(ptsfifoptr+3) & 1) {
+			interruptible_sleep_on_timeout(&em->video_ptsfifo_wait, HZ);
+			if time_after_eq(jiffies, safe_jiff + HZ) {
+				return -EINTR;
+			}
+
+			if (signal_pending(current)) {
+				return -EINTR;
+			}
+		}	
+
+#ifdef DEBUG_SYNC
+		pr_info("em8300_video.o: pts: %u\n", em->video_pts >> 1);
+#endif
+
+		write_register(ptsfifoptr, em->video_offset >> 16);
+		write_register(ptsfifoptr + 1, em->video_offset & 0xffff);
+		write_register(ptsfifoptr + 2, em->video_pts >> 16);
+		write_register(ptsfifoptr + 3, (em->video_pts & 0xffff) | 1);
+	
+		em->video_ptsfifo_ptr++;
+		em->video_ptsfifo_ptr %= read_ucregister(MV_PTSSize) / 4;
+
+		em->video_ptsvalid = 0;
+	}
+	written = em8300_fifo_write(em->mvfifo, count, buf, flags, em->nonblock[2]);
+	if (written > 0) {
+		em->video_offset += written;
+	}
+	return written;
+}
+
+int em8300_video_ioctl(struct em8300_s *em, unsigned int cmd, unsigned long arg)
+{
+    unsigned scr,val;
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(EM8300_IOCTL_VIDEO_SETPTS):
+		if (get_user(em->video_pts, (int *) arg)) {
+			return -EFAULT;
+		}
+		if (em->video_pts != em->video_lastpts) {
+			em->video_ptsvalid = 1;
+			em->video_lastpts = em->video_pts;
+		}
+		break;
+
+	case _IOC_NR(EM8300_IOCTL_VIDEO_SETSCR):
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			if (get_user(val, (unsigned*) arg)) {
+				return -EFAULT;
+			}
+			val >>= 1;
+			scr = read_ucregister(MV_SCRlo) | (read_ucregister(MV_SCRhi) << 16);
+			scr -= val;
+			if (scr < 0) scr = -scr;
+			if (scr > 9000) {
+				pr_info("setting scr: %i\n", val);
+				write_ucregister(MV_SCRlo, val & 0xffff);
+				write_ucregister(MV_SCRhi, (val >> 16) & 0xffff);
+			}
+
+		}
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			scr = read_ucregister(MV_SCRlo) | (read_ucregister(MV_SCRhi) << 16);
+			copy_to_user((void *) arg, &scr, sizeof(unsigned));
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void em8300_video_open(struct em8300_s *em)
+{
+	em->irqmask |= IRQSTATUS_VIDEO_FIFO | IRQSTATUS_VIDEO_VBL;
+	write_ucregister(Q_IrqMask, em->irqmask);
+}
+
+int em8300_video_release(struct em8300_s *em)
+{
+	em->video_ptsfifo_ptr = 0;
+	em->video_offset = 0;
+	em->video_ptsvalid = 0;
+	em8300_fifo_sync(em->mvfifo);
+	em8300_video_sync(em);
+
+	em->irqmask &= ~(IRQSTATUS_VIDEO_FIFO | IRQSTATUS_VIDEO_VBL);
+	write_ucregister(Q_IrqMask, em->irqmask);
+
+	return em8300_video_setplaymode(em, EM8300_PLAYMODE_STOPPED);
+}
diff -Nurw linux-2.6.10/drivers/media/em8300/em9010.c linux-2.6.10-em8300/drivers/media/em8300/em9010.c
--- linux-2.6.10/drivers/media/em8300/em9010.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/em9010.c	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,809 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/time.h>
+
+#include "em8300_reg.h"
+#include <media/em8300.h>
+
+/* sub_2ac2d */
+static int testcable(struct em8300_s *em)
+{
+	int attempts;
+
+	attempts = 0;
+	while (em9010_read(em, 0x0) & 0x20) {
+		if(attempts++ > 100) {
+			return 0;
+		}
+		mdelay(1);
+	}
+
+	attempts = 0;
+	while (!(em9010_read(em, 0x0) & 0x20)) {
+		if(attempts++ > 100) {
+			return 0;
+		}
+		mdelay(1);
+	}
+
+	return 1;
+}
+	 
+/* loc_2abac */
+int em9010_cabledetect(struct em8300_s *em)
+{
+	em9010_write(em, 0xb, 0xc8);
+	em9010_write(em, 0x9, 0x4);
+	em9010_write(em, 0xd, 0x44);
+
+	if (testcable(em)) {
+		return 1;
+	}
+
+	em9010_write(em, 0xd, 0x4c);
+
+	if (testcable(em)) {
+		return 1;
+	}
+
+	em9010_write(em, 0x9, 0x0);
+
+	return 0;
+}
+
+/*
+  sub_2AC2D
+
+  locals:
+  a = [ebp-8]
+*/
+
+/* computes `a - b'  and write the result in `result', assumes `a >= b' */
+static inline void my_timeval_less(struct timeval a, struct timeval b, struct timeval * result)
+{
+		if (a.tv_usec < b.tv_usec) {
+			a.tv_sec--;
+			a.tv_usec += 1000000;
+		}
+
+		result->tv_sec = a.tv_sec - b.tv_sec;
+		result->tv_usec = a.tv_usec - b.tv_usec;
+}
+
+static 
+int sub_2AC2D(struct em8300_s *em)
+{
+	int a;
+	struct timeval t, t2, tr;
+
+	do_gettimeofday(&t);
+	a = 1000;
+	while (em9010_read(em, 0x0) & 0x20) {
+		if (!a--) {
+			do_gettimeofday(&t2);
+			my_timeval_less(t2, t, &tr);
+			if (tr.tv_usec >= 50 * 1000)
+			return(0);
+			a = 1000;
+		}
+	}
+
+	do_gettimeofday(&t);	
+	a = 1000;
+	while (!(em9010_read(em, 0x0) & 0x20)) {
+		if (!a--) {
+			do_gettimeofday(&t2);
+			my_timeval_less(t2, t, &tr);
+			if(tr.tv_usec >= 50*1000)
+			return(0);
+			a = 1000;
+		}
+	}
+
+	return(1);
+}
+
+
+/* sub_4288C
+
+   Arguments
+   pa = [ebp+0x8]
+   pb = [ebp+0xc]
+   pc = [ebp+0x10]
+   pd = [ebp+0x14]
+   pe = [ebp+0x18]
+   pf = [ebp+0x1c]
+   pg = [ebp+0x20]
+   ph = [ebp+0x24]
+ */
+void sub_4288c(struct em8300_s *em, int pa, int pb, int pc, int pd, int pe, int pf, int pg, int ph)
+{
+  int pav, pbv, pcv, pdv, i;
+	/*	pr_debug("sub_4288c:  xpos=%d, ypos=%d, xwin=%d, ywin=%d, xoff=%d, yoff=%d, xcorr=%d, xd=%d\n", 
+	  pa,pb,pc,pd,pe,pf,pg,ph); */
+	if (pg >= 800) {
+		if (ph) {
+			pb >>= 1;
+			pd >>= 1;
+			pf >>= 1;
+		}
+		if (pa < 0) {
+			pav = 0;
+			pcv = pc + pa;
+		}
+		else {
+			pav = pa;
+			pcv = pc;
+		}  
+		if (pb < 0) {
+			pbv = 0;
+			pdv = pd + pb;
+		}
+		else {
+			pbv = pb;
+			pdv = pd;
+		}  
+		if (pav + pcv>em->overlay_xres) {
+			pcv=em->overlay_xres - pav;
+		}
+		if (pb+pd > em->overlay_yres) {
+		  pdv=em->overlay_yres - pb;
+		}
+  
+		pa = (pa * 1000) / pg;
+		pc = (pc * 1000) / pg;
+		pav = (pav * 1000) / pg;
+		pcv = (pcv * 1000) / pg;
+
+		if (read_ucregister(DICOM_UpdateFlag) == 1) {
+		  i=0;
+		  while ((read_ucregister(DICOM_UpdateFlag) == 1) & (i < 20))
+		  {
+		    udelay(50);
+		    i++;
+		  }
+		  if (read_ucregister(DICOM_UpdateFlag) == 1) {
+			write_ucregister(DICOM_UpdateFlag, 0);
+			udelay(50);
+		  }  
+		}
+		    
+		write_ucregister(DICOM_VisibleLeft, pe + pav);
+		write_ucregister(DICOM_VisibleRight, pe + pav + pcv - 1);
+		write_ucregister(DICOM_VisibleTop, pf + pbv);
+		write_ucregister(DICOM_VisibleBottom, pf + pbv + pdv - 1);
+
+		write_ucregister(DICOM_FrameLeft, pe + pa);
+		write_ucregister(DICOM_FrameRight, pe + pa + pc - 1);
+		write_ucregister(DICOM_FrameTop, pf + pb);
+		write_ucregister(DICOM_FrameBottom, pf + pb + pd - 1);
+
+		write_ucregister(DICOM_UpdateFlag, 1);
+	}
+}
+
+static int loc_2BE50(struct em8300_s *em)
+{
+	em9010_write(em, 0xb, 0xc8);
+	sub_2AC2D(em);
+	sub_2AC2D(em);
+	if (read_register(0x1f4b) < (2 * em->overlay_yres / 3)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+int em9010_calibrate_yoffset(struct em8300_s *em)
+{
+	int i;
+
+	pr_debug("em9010: Starting yoffset calibration\n");
+	
+	//clear the stability value
+	em9010_write(em, 0x6, 0x0);
+
+	em->overlay_a[EM9010_ATTRIBUTE_XCORR] = em->overlay_xcorr_default;
+	em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] = 100000 / em->overlay_a[EM9010_ATTRIBUTE_XCORR];
+	em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] = 4;
+
+	em9010_write(em, 0xb, 0x14);
+
+	em9010_write16(em, 0x8, 0x2000);
+	em9010_write16(em, 0x10, 0x2000);
+	em9010_write16(em, 0x20, 0xff20);
+
+	em9010_write(em, 0xa, 0x6);
+	
+	em8300_video_setplaymode(em, EM8300_PLAYMODE_FRAMEBUF );
+
+	if (em->overlay_double_y) {
+		em8300_dicom_fill_dispbuffers(em, 0, 0, em->dbuf_info.xsize, 4, 0xffffffff, 0x80808080 );
+	} else {
+		em8300_dicom_fill_dispbuffers(em, 0, 0, em->dbuf_info.xsize, 2, 0xffffffff, 0x80808080 );
+	}
+
+	sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+
+	pr_debug("em9010: Done drawing y testpattern\n");
+
+	mdelay(20);
+
+	if (!sub_2AC2D(em)) {
+		return 0;
+	}
+
+	em9010_write(em, 0, 0x14);
+	em9010_write(em, 0, 0x10);
+
+	for (i = 0; i < 60; i++) {
+		if (!sub_2AC2D(em)) {
+			pr_debug("em9010: sub_2AC2D failed\n");
+			return 0;
+		}
+		if (!(em9010_read(em,0) & 4)) {
+			sub_4288c(em, 0, i, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+					em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+    			if (!sub_2AC2D(em)) {
+			    return 0;
+			}
+		} else {
+			break;
+		}
+	}
+
+	if (i == 60) {
+		return 0;
+	}
+	
+	em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] = em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] + i - 2;
+
+	if (em->overlay_double_y) {
+		em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] >>= 1;
+	}
+
+	pr_debug("em9010: Sucessfully calibrated yoffset (%d)\n", em->overlay_a[EM9010_ATTRIBUTE_YOFFSET]);
+	
+	return 1;
+}
+
+int em9010_calibrate_xoffset(struct em8300_s *em)
+{
+	int i;
+
+	em9010_write(em, 0xb, 0x14);
+
+	em9010_write16(em, 0x8, 0x2000);
+	em9010_write16(em, 0x10, 0x2000);
+	em9010_write16(em, 0x20, 0xff20);
+
+	em9010_write(em, 0xa, 0x6);
+	
+	em8300_dicom_fill_dispbuffers(em, 0, 0, em->dbuf_info.xsize, 4, 0, 0x80808080 );
+	em8300_dicom_fill_dispbuffers(em, 2, 0, 2, em->dbuf_info.ysize, 0xffffffff, 0x80808080 ); 
+
+	em->overlay_a[EM9010_ATTRIBUTE_XCORR] = 1000;
+	em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] = 100000 / em->overlay_a[EM9010_ATTRIBUTE_XCORR];
+
+	sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+	
+	pr_debug("em9010: Done drawing x testpattern\n");
+
+	mdelay(20);
+
+	if (!sub_2AC2D(em)) {
+		return 0;
+	}
+
+	em9010_write(em, 0, 0x14);
+	em9010_write(em, 0, 0x10);
+
+	for (i = 0; i <  220; i++) {
+		if (!sub_2AC2D(em)) {
+			pr_debug("em9010: sub_2AC2D failed\n");
+			return 0;
+		}
+		if (!(em9010_read(em,0) & 4)) {
+			sub_4288c(em, i, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+					em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+    			if (!sub_2AC2D(em)) {
+			    return 0;
+			}
+		} else {
+			break;
+		}
+	}
+
+	if (i == 220) {
+		return 0;
+	}
+	
+	em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] = em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] + i;
+
+	pr_debug("em9010: Sucessfully calibrated xoffset (%d)\n", em->overlay_a[EM9010_ATTRIBUTE_XOFFSET]);
+	
+	return 1;
+}
+
+static int color_cal(struct em8300_s *em,int ul, int a, int b, int c,int d, int *res)
+{
+	int i;
+
+	if (ul == 1) { 
+		/* Measure upper threshold level */
+	
+		em9010_write16(em, a, d << 8);
+		em9010_write(em, 0xa, b);
+
+		if (!sub_2AC2D(em)) {
+			return 0;
+		}
+
+		em9010_write(em, 0, 0x17);
+		em9010_write(em, 0, 0x10);
+	
+		for (i = d; i > 0; i--) {
+			em9010_write16(em, a, i << 8);
+			if (em9010_read(em, 0) & (a >> 3)) {
+				break;
+			} else {
+				continue;
+			}
+		}
+	} else if (ul == 2) {
+		/* Measure lower threshold level */	
+		em9010_write16(em, a, 0x0);
+		em9010_write(em, 0xa, c);
+		if (!sub_2AC2D(em)) {
+			return 0;
+		}
+		em9010_write(em, 0, 0x17);
+		em9010_write(em, 0, 0x10);
+	
+		for (i = 0; i < d; i++) {
+			em9010_write16(em, a, i);
+			if (em9010_read(em, 0) & (a >> 3)) {
+				break;
+			} else {
+				continue;
+			}
+		}
+	} else {
+		return -1;
+	}
+	
+	*res = i;
+
+	return 1;
+}
+
+int em9010_calibrate_xcorrection(struct em8300_s *em)
+{
+	int i, j;
+
+	em9010_write(em, 0xb, 0x14);
+
+	em9010_write16(em, 0x8, 0x2000);
+	em9010_write16(em, 0x10, 0x2000);
+	em9010_write16(em, 0x20, 0xff20);
+
+	em9010_write(em, 0xa, 0x6);
+	
+	em8300_dicom_fill_dispbuffers(em, 2, 0, 2, em->dbuf_info.ysize, 0, 0x80808080 );
+	em8300_dicom_fill_dispbuffers(em, 356, 0, 2, em->dbuf_info.ysize, 0xffffffff, 0x80808080 ); 
+
+	em->overlay_a[EM9010_ATTRIBUTE_XCORR] = em->overlay_xcorr_default;
+
+	sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+	
+	pr_debug("em9010: Done drawing xcorr testpattern\n");
+
+	mdelay(20);
+
+	if (!sub_2AC2D(em)) {
+		return 0;
+	}
+
+	em9010_write(em, 0, 0x14);
+	em9010_write(em, 0, 0x10);
+
+	j = 1;
+	if (em->overlay_xcorr_default > 1200) {
+		j = 2;
+	}
+	
+	for (i = -100; i < 150; i++) {
+		if (!sub_2AC2D(em)) {
+			return 0;
+		}
+		if (!(em9010_read(em, 0) & 4)) {
+			em->overlay_a[EM9010_ATTRIBUTE_XCORR] = i * j + em->overlay_xcorr_default;
+			sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+					em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+    			if (!sub_2AC2D(em)) {
+			    return 0;
+			}
+		} else {
+			break;
+		}
+
+	}
+
+	if (em->overlay_xcorr_default > 1500) {
+		em->overlay_a[EM9010_ATTRIBUTE_XCORR] += 2;
+	} else {
+		em->overlay_a[EM9010_ATTRIBUTE_XCORR] -= 2;		
+	}
+	sub_4288c(em, 0, 0, em->dbuf_info.xsize, em->dbuf_info.ysize, em->overlay_a[EM9010_ATTRIBUTE_XOFFSET],
+			em->overlay_a[EM9010_ATTRIBUTE_YOFFSET], em->overlay_a[EM9010_ATTRIBUTE_XCORR], em->overlay_double_y);
+
+	pr_debug("em9010: Sucessfully calibrated x correction (%d)\n", em->overlay_a[EM9010_ATTRIBUTE_XCORR]);
+	
+	return 1;
+}
+
+/*
+  l7 = [ebp-0x18]
+  l6 = [ebp-0xc]
+  l5 = [ebp-0x1d]
+  l4 = [ebp-0x14]
+  l2 = [ebp-8]
+  l3 = [ebp-4]
+  l1 = [ebp-0x10]
+ */
+int loc_2bcfe(struct em8300_s *em)
+{
+	int l1 = 10,l2,l3,l4,l5,l6,l7;
+	
+	em9010_write(em, 4, 0);	
+	em9010_write(em, 3, 0x80);	
+	l2 = em9010_read(em, 2);
+	l3 = em9010_read(em, 1);
+	
+	while (--l1 != 0) {
+		l4 = em9010_read(em, 1);
+		if ((l4 & 0xff) == (l3 & 0xff)) {
+			continue;
+		}
+		if ((l3 & 0xff) > (l4 & 0xff)) {
+			l5 = l3;
+		} else {
+			l5 = l4;
+		}
+		l3 = l5;
+		l2 = 0;
+		break;
+	}
+
+	l6 = (l3 << 8) + l2;
+	l7 = 165000 / (l6 + 2);
+	
+	if ((l7 > em->overlay_dword_24bb8 + 1) || (l7 < em->overlay_dword_24bb8 - 1)) {
+		em->overlay_dword_24bb8 = l7;
+	} else {
+		l7 = em->overlay_dword_24bb8;
+	}
+
+	if ((l7 < 100) || (l7 > 1000)) {
+		if (em->overlay_yres) {
+			l7 = em->overlay_yres * 62 / 100;
+		}
+	}
+	
+	pr_debug("em9010: loc_2bcfe -> %d\n", l7);
+	return l7;
+}
+/*
+  loc_2a66e
+  
+  l13 [ebp-38]
+  l12 [ebp-8]
+  l11 [ebp-20]
+  l10 [ebp-34]
+  l9 [ebp-28]
+  l8 [ebp-4]
+  l7 [ebp-18]
+  l6 [ebp-0c]
+  l5 [ebp-30]
+  l4 [ebp-10]
+  l1 [ebp-14]
+  l2 [ebp-1c]
+  l3[ebp-24]
+ */
+int loc_2A66E(struct em8300_s *em)
+{
+	int l1, l2, l3, l4, l5, l6 = 0, l7, l8, l9, l10, l11, l12, l13;
+
+	l1 = 70000;
+	l2 = 0;
+	l3 = 0;
+
+	l7 = em->overlay_70 / 10;
+	l4 = 1000;
+
+	l5 = em->overlay_xres;
+	if (l5 <= 720) {
+		if (l5 == 720) {
+			l6 = 0x398;
+		} else if (l5 == 640) {
+			l6 = 0x370;
+		}
+	} else if (l5 <= 1024) {
+		if (l5 == 1024) {
+			l6 = 0x500;
+		} else if (l5 == 800) {
+			l6 = 0x400;
+		}
+	} else if (l5 <= 1280) {
+		if (l5 == 1280) {
+			l6 = 0x60e;
+		} else if (l5 == 1152) {
+			l6 = 0x5a0;
+		}
+	} else if (l5 == 1600) {
+		l6 = 0x7d0;
+	} else if (l5 == 2048) {
+		l6 = 0xa00;
+	} else {
+		l6 = 0x500;
+	}
+
+	pr_debug("l6 * l7 * (1 << l2)=%d, l1=%d\n", l6 * l7 * (1 << l2), l1);
+	if (l6 * l7 * (1 << l2) >= l1) {
+		l4 = l6 * l7 * (1 << l2) * 1000 / l1;
+		l8 = l1 / (l7*(1 << l2)) ;
+		l9 = l1 / (1 << l2);
+	} else {
+		l4 = 1000;
+		l8 = l6;
+		l9 = l8 * l7;
+	}
+	em->overlay_xcorr_default = l4;
+	if ((em->overlay_xcorr_default < 0x352) || (em->overlay_xcorr_default > 0xdac)) {
+		em->overlay_xcorr_default = 0x5dc;
+	}
+
+	if (l9 * (1 << l2) > 0x7530) {
+		l3 = l8 * (1 << l2) - 2;
+		if (l3 > 0xfff) {
+			l10 = 0xfff;
+		} else {
+			l10 = l3;
+		}
+		l3 = l10;
+		l11 = ((l3 >> 8) & 0xf) | (l2 << 4);
+		l12 = l3;
+	} else {
+		l2++;
+		l3 = l8 * (1 << l2) - 2;
+		if (l3 > 0xfff) {
+			l13 = 0xfff;
+		} else {
+			l13 = l3;
+		}
+		l3 = l13;
+		l11 = ((l3 >> 8) & 0xf) | (l2 << 4);
+		l12 = l3;
+	}
+	pr_debug("em9010: Writing %x to 16-bit register 1.\n", l12 | (l11 << 8));
+	em9010_write16(em, 1, l12 | (l11 << 8));
+	return 1;
+}
+
+int em9010_overlay_set_res(struct em8300_s *em, int xres, int yres)
+{
+	pr_debug("em9010: Setting resolution %d x %d\n", xres, yres);
+	em->overlay_xres = xres;
+	em->overlay_yres = yres;
+	em->overlay_70 = loc_2bcfe(em);
+	loc_2A66E(em);
+	em->overlay_a[EM9010_ATTRIBUTE_XCORR] = em->overlay_xcorr_default;
+	pr_debug("em9010: Xcorrector: %d\n", em->overlay_a[EM9010_ATTRIBUTE_XCORR]);
+	em9010_overlay_update(em);
+	return 1;
+}
+
+static int set_keycolor(struct em8300_s *em, unsigned upper, unsigned lower)
+{
+	int ru = (upper >> 16) & 0xff;
+	int gu = (upper >> 8) & 0xff;
+	int bu = (upper) & 0xff;
+	int rl = (lower >> 16) & 0xff;
+	int gl = (lower >> 8) & 0xff;
+	int bl = (lower) & 0xff;
+
+	em9010_write16(em, 0x8, (ru << 8) | (rl & 0xff));
+	em9010_write16(em, 0x10, (gu << 8) | (gl & 0xff));
+	em9010_write16(em, 0x20, (bu << 8) | (bl & 0xff));
+
+	return 1;
+}
+
+int em9010_overlay_set_signalmode(struct em8300_s *em, int val)
+{
+	switch (val) {
+	case EM8300_OVERLAY_SIGNAL_ONLY:
+		em9010_write(em, 7, em->overlay_a[EM9010_ATTRIBUTE_JITTER]);
+		break;
+	case EM8300_OVERLAY_SIGNAL_WITH_VGA:
+		em9010_write(em, 7, em->overlay_a[EM9010_ATTRIBUTE_JITTER] | 0x40);
+		break;
+	case EM8300_OVERLAY_VGA_ONLY:
+		em9010_write(em, 7, em->overlay_a[EM9010_ATTRIBUTE_JITTER] | 0x80);
+		break;
+	default:
+		return 0;
+	}
+	pr_debug("em9010: overlay reg 7 = %x \n", em9010_read(em, 7));
+
+	return 1;
+}
+
+int em9010_overlay_update(struct em8300_s *em)
+{
+	pr_debug("em9010: Update overlay: enabled=%d, gamma_enabled=%d\n", em->overlay_enabled, em->overlay_gamma_enable);
+
+	em9010_write(em, 5, 0);
+	em9010_write(em, 4, 0);
+	em9010_write(em, 6, em->overlay_a[EM9010_ATTRIBUTE_STABILITY]);
+
+	if (em->overlay_enabled) {
+		em->overlay_gamma_enable=4;
+		em9010_write(em, 9, em->overlay_gamma_enable);
+		em9010_overlay_set_signalmode(em, EM8300_OVERLAY_SIGNAL_WITH_VGA);
+	} else {
+		em->overlay_gamma_enable=0;
+		em9010_write(em, 9, em->overlay_gamma_enable);
+		em9010_overlay_set_signalmode(em, EM8300_OVERLAY_VGA_ONLY);
+	}
+	
+	em9010_write(em, 8, 0x80);
+
+	if (em->overlay_gamma_enable) {
+		em9010_write(em, 0xc, 0x8e);
+	} else {
+		em9010_write(em, 0xc, 0xe);
+	}
+
+	//wait on the display of one frame at least
+	mdelay(20);
+
+	//the setting of the overlay mode shall be done before calling loc_2BE50!
+	em->overlay_double_y = loc_2BE50(em);
+	pr_debug("em9010: ydouble: %d\n", em->overlay_double_y);
+
+	switch(em->overlay_mode) {
+	case EM8300_OVERLAY_MODE_RECTANGLE:
+		em9010_write(em, 0xa, 0x77);
+		break;
+	case EM8300_OVERLAY_MODE_OVERLAY:
+		em9010_write(em, 0xb, 0xc8);
+		em9010_write(em, 0xa, 0x0);
+		set_keycolor(em, em->overlay_a[EM9010_ATTRIBUTE_KEYCOLOR_UPPER], em->overlay_a[EM9010_ATTRIBUTE_KEYCOLOR_LOWER]); 
+		break;
+	}
+
+	return 0;
+}
+
+
+int em9010_init(struct em8300_s *em)
+{
+	em->overlay_dword_24bb8 = 2000;
+	em9010_overlay_set_res(em, 1280, 1024);
+	em->overlay_frame_xpos = 0;
+	em->overlay_frame_ypos = 0;
+	em->overlay_frame_width = 720;
+	em->overlay_frame_height = 480;
+	em->overlay_a[EM9010_ATTRIBUTE_YOFFSET] = 43;
+	em->overlay_a[EM9010_ATTRIBUTE_XOFFSET] = 225;
+	em->overlay_gamma_enable = 4;
+
+	return 1;
+}
+
+int em9010_set_attribute(struct em8300_s *em, int attribute, int value)
+{
+	if (attribute <= EM9010_ATTRIBUTE_MAX) {
+		em->overlay_a[attribute] = value;
+		switch(attribute) {
+		case EM9010_ATTRIBUTE_JITTER:
+			em9010_write(em, 7, (em9010_read(em, 7) & 0xf0) | value);
+			break;
+		case EM9010_ATTRIBUTE_STABILITY:
+			em9010_write(em, 6, value);
+			break;
+		}
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+int em9010_get_attribute(struct em8300_s *em, int attribute)
+{
+	if (attribute <= EM9010_ATTRIBUTE_MAX) {
+		return em->overlay_a[attribute];
+	} else {
+		return -1;
+	}
+}
+
+int em8300_ioctl_overlay_calibrate(struct em8300_s *em, em8300_overlay_calibrate_t *c)
+{
+	int r1;
+	em9010_write(em, 0xc, 0xe);
+
+	switch (c->cal_mode) {
+	case EM8300_OVERLAY_CALMODE_XOFFSET:
+		if (em9010_calibrate_xoffset(em)) {
+			c->result = em->overlay_a[EM9010_ATTRIBUTE_XOFFSET];
+		} else {
+			return 0;
+		}
+		break;
+	case EM8300_OVERLAY_CALMODE_YOFFSET:
+		if (em9010_calibrate_yoffset(em)) {
+			c->result = em->overlay_a[EM9010_ATTRIBUTE_YOFFSET];
+		} else {
+			return 0;
+		}
+		break;
+	case EM8300_OVERLAY_CALMODE_XCORRECTION:
+		if (em9010_calibrate_xcorrection(em)) {
+			c->result = em->overlay_a[EM9010_ATTRIBUTE_XCORR];
+			em8300_dicom_fill_dispbuffers(em, 0x164, 0, 2, em->dbuf_info.ysize, 0x0, 0x80808080 );
+		} else {
+			return 0;
+		}
+		break;
+	case EM8300_OVERLAY_CALMODE_COLOR:
+		r1=1;
+		
+		em9010_write(em, 0xb, 0xc8);
+
+		mdelay(1);
+	
+		if (color_cal(em, c->arg2, 8, 0x37, 0x73, c->arg, &r1)) {
+			c->result = r1 << 16;
+		} else {
+			return 0;
+		}
+
+		if (color_cal(em, c->arg2, 0x10, 0x57, 0x75, c->arg, &r1)) {
+			c->result |= r1 << 8;
+		} else {
+			return 0;
+		}
+
+		if (color_cal(em, c->arg2, 0x20, 0x67, 0x76, c->arg, &r1)) {
+			c->result |= r1;
+		} else {
+			return 0;
+		}
+		break;
+	}
+
+	if (1) {
+		em9010_write(em, 0xc, 0xe);
+	}
+	return 1;
+}
+
diff -Nurw linux-2.6.10/drivers/media/em8300/encoder.h linux-2.6.10-em8300/drivers/media/em8300/encoder.h
--- linux-2.6.10/drivers/media/em8300/encoder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/encoder.h	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,17 @@
+#ifndef _ENCODER_H_
+#define _ENCODER_H_
+
+#include <media/em8300.h>
+
+#define ENCODER_MODE_NTSC	 1
+#define ENCODER_MODE_NTSC60	 2
+#define ENCODER_MODE_PAL_M	 3
+#define ENCODER_MODE_PALM60	 4
+#define ENCODER_MODE_PAL	 5
+#define ENCODER_MODE_PAL60	 6
+#define ENCODER_MODE_PALNC	 7
+
+#define ENCODER_CMD_SETMODE      1
+#define ENCODER_CMD_ENABLEOUTPUT 2
+
+#endif
diff -Nurw linux-2.6.10/drivers/media/em8300/Kconfig linux-2.6.10-em8300/drivers/media/em8300/Kconfig
--- linux-2.6.10/drivers/media/em8300/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/Kconfig	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,128 @@
+#
+# Sigma Designs Hollywood Plus
+# Creative Labs DXR3
+#
+
+menu "Hollywood Plus / DXR3"
+	depends on I2C && I2C_ALGOBIT
+
+config DXR3
+	tristate "Hollywood Plus / DXR3"
+	depends on I2C && I2C_ALGOBIT
+
+config EM8300
+	tristate "Sigma designs EM8300"
+	depends on DXR3
+	help
+  Sigma REALmagic EM8300 single-chip MPEG-2 decoder with full compliance
+  to ISO 13818-2 MPEG-2 standard. The EM8300 is fully DVD-compliant,
+  providing CSS copy protection, sub-picture processing, letterbox, Pan &
+  Scan, and alpha-blending. On-chip digital controls adjust brightness,
+  contrast, and color saturation. 
+
+config EM8300_LOOPBACK
+	bool "  Activate loopback"
+	depends on EM8300
+	help
+  If you lose video after loading the modules or uploading the microcode
+  set this.
+  This is option is only used if you have problems with the loopback cable,
+  it is not used to activate overlay!
+  The module option is called activate_loopback.
+
+config EM8300_UCODETIMEOUT
+	bool "  BT865 uCode timeout"
+	depends on EM8300
+	help
+  Set this if you have a bt865 and get timeouts when uploading the 
+  microcode.
+
+  The module option is called bt865_ucode_timeout. It takes either a 1
+  or a 0 as argument.
+
+config EM8300_DICOMFIX
+	bool "  Dicom fix"
+	depends on EM8300
+	help
+  If this is set then some internal register values are changed.
+  Fixes green screen problems for some.
+
+  The module option is called dicom_fix. It takes either a 1 or a 0 as
+  argument.
+
+config EM8300_DICOMCTRL
+	bool "  Dicom control"
+	depends on EM8300
+	help
+  If this is set then some internal register values are changed.
+  Fixes green screen problems for some.
+
+  The module option is called dicom_control. It takes either a 1 or a 0
+  as argument.
+
+config EM8300_DICOMPAL
+	bool "  Dicom other pal"
+	depends on EM8300
+	help
+  If this is set, then some internal register values are swapped
+  for PAL and NTSC.
+
+  The module option is called dicom_other_pal. It takes either a 1
+  or a 0 as argument.
+
+config ADV717X
+	tristate "ADV717x video encoder"
+	depends on DXR3
+	help
+  The ADV7175A/ADV7176A is an integrated digital video encoder that
+  converts Digital CCIR-601 4:2:2 8 or 16-bit component video data into
+  a standard analog baseband television signal compatible with worldwide
+  standards.
+  This chip is used in all (?) Hollywood Plus cards.
+
+config ADV717X_SWAP
+	bool "  Swap red/blue pal"
+	depends on ADV717X
+	help
+  If your red and blue colours are swapped, set this.
+
+  The module option is called swap_redblue_pal. It takes either a 1 or a
+  0 as argument.
+
+config ADV717X_PIXELPORT16BIT
+	bool "  16bit pixelport"
+	depends on ADV717X
+	help
+  Changes how the ADV717x expects its input data to be formatted.
+  If the colours on the TV appear green, try changing this. The
+  correct value for a particular card varies, even with people with
+  the exact same card using the same microcode.
+
+  The module option is called pixelport_16bit. It takes either a 1 or a 0
+  as argument.
+
+config ADV717X_PIXELPORTPAL
+	bool "  Pixelport other pal"
+	depends on ADV717X
+	help
+  If this is set, then the pixelport setting is swapped for PAL
+  from the setting given with pixelport_16bit.
+
+  The module option is called pixelport_other_pal. It takes either a 1 or
+  a 0 as argument.
+
+config BT865
+	tristate "BT865 video encoder"
+	depends on DXR3
+	help
+  The BT864A/865A is specifically designed for video systems requiring
+  the generation of composite, Y/C (S-video) or RGB (SCART) video signals
+  from an 8- or 16-bit YCrCb digital video stream.
+  This chip was used by Creative Labs in their DXR3 card.
+  Creative Labs sold a few Hollywood Plus cards but with their name on it
+  and called them DXR3 (the cards are virtually identical anyway). This
+  means that a few of you have cards that claim to be DXR3 but use the
+  ADV717X instead of the BT865. If you are uncertain it is recommended
+  that you compile ADV717X support as well.
+
+endmenu
diff -Nurw linux-2.6.10/drivers/media/em8300/Makefile linux-2.6.10-em8300/drivers/media/em8300/Makefile
--- linux-2.6.10/drivers/media/em8300/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/em8300/Makefile	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,13 @@
+#
+# Makefile for the EM8300 drivers
+#
+
+em8300-objs := em8300_main.o em8300_i2c.o em8300_audio.o em8300_fifo.o \
+	   em8300_video.o em8300_misc.o em8300_dicom.o em8300_ucode.o \
+	   em8300_ioctl.o em8300_spu.o em9010.o
+
+# Object file lists.
+
+obj-$(CONFIG_EM8300)	+= em8300.o
+obj-$(CONFIG_ADV717X)	+= adv717x.o
+obj-$(CONFIG_BT865)	+= bt865.o
diff -Nurw linux-2.6.10/drivers/media/Kconfig linux-2.6.10-em8300/drivers/media/Kconfig
--- linux-2.6.10/drivers/media/Kconfig	2004-12-24 22:35:50.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/Kconfig	2004-12-25 11:02:11.000000000 +0100
@@ -32,6 +32,8 @@
 
 source "drivers/media/common/Kconfig"
 
+source "drivers/media/em8300/Kconfig"
+
 config VIDEO_TUNER
 	tristate
 
diff -Nurw linux-2.6.10/drivers/media/Makefile linux-2.6.10-em8300/drivers/media/Makefile
--- linux-2.6.10/drivers/media/Makefile	2004-12-24 22:35:28.000000000 +0100
+++ linux-2.6.10-em8300/drivers/media/Makefile	2004-12-25 11:02:11.000000000 +0100
@@ -2,4 +2,4 @@
 # Makefile for the kernel multimedia device drivers.
 #
 
-obj-y        := video/ radio/ dvb/ common/
+obj-y        := video/ radio/ dvb/ common/ em8300/
diff -Nurw linux-2.6.10/include/media/em8300.h linux-2.6.10-em8300/include/media/em8300.h
--- linux-2.6.10/include/media/em8300.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-em8300/include/media/em8300.h	2004-12-25 11:02:11.000000000 +0100
@@ -0,0 +1,461 @@
+#ifndef LINUX_EM8300_H
+#define LINUX_EM8300_H
+
+typedef struct {
+	void *ucode;
+	int ucode_size;
+} em8300_microcode_t;
+
+typedef struct {
+	int reg;
+	int val;
+	int microcode_register;
+} em8300_register_t;
+
+typedef struct {
+	int brightness;
+	int contrast;
+	int saturation;
+} em8300_bcs_t;
+
+typedef struct {
+	int cal_mode;
+	int arg;
+	int arg2;
+	int result;
+	int result2;
+} em8300_overlay_calibrate_t;
+
+typedef struct {
+	int xpos, ypos;
+	int width, height;
+} em8300_overlay_window_t;
+
+typedef struct {
+	int xsize, ysize;
+} em8300_overlay_screen_t;
+
+typedef struct {
+	int attribute;
+	int value;
+} em8300_attribute_t;
+
+typedef struct {
+	int color;
+	int contrast;
+	int top;
+	int bottom;
+	int left;
+	int right;
+} em8300_button_t;
+
+#define MAX_UCODE_REGISTER 110
+
+#define EM8300_IOCTL_INIT       _IOW('C',0,em8300_microcode_t)
+#define EM8300_IOCTL_READREG    _IOWR('C',1,em8300_register_t)
+#define EM8300_IOCTL_WRITEREG   _IOW('C',2,em8300_register_t)
+#define EM8300_IOCTL_GETSTATUS  _IOR('C',3,char[1024])
+#define EM8300_IOCTL_SETBCS	_IOW('C',4,em8300_bcs_t)
+#define EM8300_IOCTL_GETBCS	_IOR('C',4,em8300_bcs_t)
+#define EM8300_IOCTL_SET_ASPECTRATIO _IOW('C',5,int)
+#define EM8300_IOCTL_GET_ASPECTRATIO _IOR('C',5,int)
+#define EM8300_IOCTL_SET_VIDEOMODE _IOW('C',6,int)
+#define EM8300_IOCTL_GET_VIDEOMODE _IOR('C',6,int)
+#define EM8300_IOCTL_SET_PLAYMODE _IOW('C',7,int)
+#define EM8300_IOCTL_GET_PLAYMODE _IOR('C',7,int)
+#define EM8300_IOCTL_SET_AUDIOMODE _IOW('C',8,int)
+#define EM8300_IOCTL_GET_AUDIOMODE _IOR('C',8,int)
+#define EM8300_IOCTL_SET_SPUMODE _IOW('C',9,int)
+#define EM8300_IOCTL_GET_SPUMODE _IOR('C',9,int)
+#define EM8300_IOCTL_OVERLAY_CALIBRATE _IOWR('C',10,em8300_overlay_calibrate_t)
+#define EM8300_IOCTL_OVERLAY_SETMODE _IOW('C',11,int)
+#define EM8300_IOCTL_OVERLAY_SETWINDOW _IOWR('C',12,em8300_overlay_window_t)
+#define EM8300_IOCTL_OVERLAY_SETSCREEN _IOWR('C',13,em8300_overlay_screen_t)
+#define EM8300_IOCTL_OVERLAY_GET_ATTRIBUTE _IOR('C',14,em8300_attribute_t)
+#define EM8300_IOCTL_OVERLAY_SET_ATTRIBUTE _IOW('C',14,em8300_attribute_t)
+#define EM8300_IOCTL_OVERLAY_SIGNALMODE _IOW('C',15,em8300_attribute_t)
+#define EM8300_IOCTL_SCR_GET _IOR('C',16,unsigned)
+#define EM8300_IOCTL_SCR_SET _IOW('C',16,unsigned)
+#define EM8300_IOCTL_SCR_GETSPEED _IOR('C',17,unsigned)
+#define EM8300_IOCTL_SCR_SETSPEED _IOW('C',17,unsigned)
+#define EM8300_IOCTL_FLUSH _IOW('C',18,int)
+#define EM8300_IOCTL_VBI _IOW('C',19,struct timeval)
+
+#define EM8300_OVERLAY_SIGNAL_ONLY 1
+#define EM8300_OVERLAY_SIGNAL_WITH_VGA 2
+#define EM8300_OVERLAY_VGA_ONLY 3
+
+#define EM8300_IOCTL_VIDEO_SETPTS 1
+#define EM8300_IOCTL_VIDEO_GETSCR _IOR('C',2,unsigned)
+#define EM8300_IOCTL_VIDEO_SETSCR _IOW('C',2,unsigned)
+
+#define EM8300_IOCTL_SPU_SETPTS 1
+#define EM8300_IOCTL_SPU_SETPALETTE 2
+#define EM8300_IOCTL_SPU_BUTTON 3
+
+#define EM8300_ASPECTRATIO_4_3 0
+#define EM8300_ASPECTRATIO_16_9 1
+#define EM8300_ASPECTRATIO_LAST 1
+
+#define EM8300_VIDEOMODE_PAL	0
+#define EM8300_VIDEOMODE_PAL60	1
+#define EM8300_VIDEOMODE_NTSC	2
+#define EM8300_VIDEOMODE_PALCROP 3
+#define EM8300_VIDEOMODE_LAST	3
+#ifndef EM8300_VIDEOMODE_DEFAULT
+#define EM8300_VIDEOMODE_DEFAULT EM8300_VIDEOMODE_PAL
+#endif
+
+#define EM8300_AUDIOMODE_ANALOG 0
+#define EM8300_AUDIOMODE_DIGITALPCM 1
+#define EM8300_AUDIOMODE_DIGITALAC3 2
+#ifndef EM8300_AUDIOMODE_DEFAULT
+#define EM8300_AUDIOMODE_DEFAULT EM8300_AUDIOMODE_ANALOG
+#endif
+
+#define EM8300_SPUMODE_OFF 0
+#define EM8300_SPUMODE_ON 1
+
+#define EM8300_PLAYMODE_STOPPED         0
+#define EM8300_PLAYMODE_PAUSED          1
+#define EM8300_PLAYMODE_SLOWFORWARDS    2
+#define EM8300_PLAYMODE_SLOWBACKWARDS   3
+#define EM8300_PLAYMODE_SINGLESTEP      4
+#define EM8300_PLAYMODE_PLAY            5
+#define EM8300_PLAYMODE_REVERSEPLAY     6
+#define EM8300_PLAYMODE_SCAN            7
+#define EM8300_PLAYMODE_FRAMEBUF	8
+
+#define EM8300_OVERLAY_MODE_OFF 0
+#define EM8300_OVERLAY_MODE_RECTANGLE 1
+#define EM8300_OVERLAY_MODE_OVERLAY 2
+
+#define EM8300_OVERLAY_CALMODE_XOFFSET 1
+#define EM8300_OVERLAY_CALMODE_YOFFSET 2
+#define EM8300_OVERLAY_CALMODE_XCORRECTION 3
+#define EM8300_OVERLAY_CALMODE_COLOR 4
+
+#define EM9010_ATTRIBUTE_XCORR 1
+#define EM9010_ATTRIBUTE_XOFFSET 2
+#define EM9010_ATTRIBUTE_YOFFSET 3
+#define EM9010_ATTRIBUTE_JITTER 4
+#define EM9010_ATTRIBUTE_STABILITY 5
+#define EM9010_ATTRIBUTE_KEYCOLOR_UPPER 6
+#define EM9010_ATTRIBUTE_KEYCOLOR_LOWER 7
+#define EM9010_ATTRIBUTE_MAX 7
+
+#define EM8300_SUBDEVICE_CONTROL 0
+#define EM8300_SUBDEVICE_VIDEO 1
+#define EM8300_SUBDEVICE_AUDIO 2
+#define EM8300_SUBDEVICE_SUBPICTURE 3
+
+#ifndef PCI_VENDOR_ID_SIGMADESIGNS
+#define PCI_VENDOR_ID_SIGMADESIGNS 0x1105
+#define PCI_DEVICE_ID_SIGMADESIGNS_EM8300 0x8300
+#endif
+
+#define CLOCKGEN_SAMPFREQ_MASK 0xc0
+#define CLOCKGEN_SAMPFREQ_66 0xc0
+#define CLOCKGEN_SAMPFREQ_48 0x40
+#define CLOCKGEN_SAMPFREQ_44 0x80
+#define CLOCKGEN_SAMPFREQ_32 0x00
+
+#define CLOCKGEN_OUTMASK 0x30
+#define CLOCKGEN_DIGITALOUT 0x10
+#define CLOCKGEN_ANALOGOUT 0x20
+
+#define CLOCKGEN_MODEMASK 0x0f
+#define CLOCKGEN_OVERLAYMODE_1 0x07
+#define CLOCKGEN_TVMODE_1 0x0b
+#define CLOCKGEN_OVERLAYMODE_2 0x04
+#define CLOCKGEN_TVMODE_2 0x02
+
+#define MVCOMMAND_STOP 0x0
+#define MVCOMMAND_PAUSE 0x1
+#define MVCOMMAND_START 0x3
+#define MVCOMMAND_PLAYINTRA 0x4
+#define MVCOMMAND_SYNC 0x6
+#define MVCOMMAND_FLUSHBUF 0x10
+#define MVCOMMAND_DISPLAYBUFINFO 0x11
+
+#define MACOMMAND_STOP 0x0
+#define MACOMMAND_PAUSE 0x1
+#define MACOMMAND_PLAY 0x2
+
+#define IRQSTATUS_VIDEO_VBL 0x10
+#define IRQSTATUS_VIDEO_FIFO 0x2
+#define IRQSTATUS_AUDIO_FIFO 0x8
+
+#define ENCODER_UNKNOWN 0
+#define ENCODER_ADV7175 1 
+#define ENCODER_ADV7170 2
+#define ENCODER_BT865   3
+
+#ifdef __KERNEL__
+
+#define EM8300_VERSION "cvs-20021026"
+#define EM8300_MAX 4
+#define EM8300_MAJOR 121
+#define EM8300_LOGNAME "em8300"
+
+struct dicom_s {
+	int luma;
+	int chroma;
+	int frametop;
+	int framebottom;
+	int frameleft;
+	int frameright;
+	int visibletop;
+	int visiblebottom;
+	int visibleleft;
+	int visibleright;
+	int tvout;
+};
+
+struct displaybuffer_info_s {
+	int xsize;
+	int ysize;
+	int xsize2;
+	int flag1,flag2;
+	int buffer1;
+	int buffer2;
+	int unk_present;
+	int unknown1;
+	int unknown2;
+	int unknown3;
+};
+
+struct em8300_audio_s {
+	int channels;
+	int format;
+	int speed;
+	int slotsize;
+	int enable_bits;
+};
+
+struct em8300_s
+{
+	char name[40];
+	int card;
+
+	int chip_revision;
+	int pci_revision;
+	
+	int inuse[4];
+	int nonblock[4];
+	int ucodeloaded;
+	
+	struct pci_dev *dev;
+	ulong adr;
+	volatile unsigned *mem;
+	ulong memsize;
+	
+	int playmode;
+	
+	/* Fifos */
+	struct fifo_s *mvfifo;
+	struct fifo_s *mafifo;
+	struct fifo_s *spfifo;
+	int mtrr_reg;
+	
+	/* DICOM */
+	int dicom_vertoffset;
+	int dicom_horizoffset;
+	int dicom_brightness;
+	int dicom_contrast;
+	int dicom_saturation;
+	int dicom_tvout;
+	struct displaybuffer_info_s dbuf_info;
+	
+	/* I2C */
+	int i2c_pin_reg;
+	int i2c_oe_reg;
+	
+	/* different between revision 1 and revision 2 boards */
+	int mystery_divisor;
+	
+	/* I2C bus 1*/
+	struct i2c_algo_bit_data i2c_data_1;
+	struct i2c_adapter i2c_ops_1;
+	
+	/* I2C bus 2*/
+	struct i2c_algo_bit_data i2c_data_2;
+	struct i2c_adapter i2c_ops_2;
+	
+	/* I2C clients */
+	int encoder_type;
+	struct i2c_client *encoder;
+	
+	/* Microcode registers */
+	unsigned ucode_regs[MAX_UCODE_REGISTER];
+	int var_ucode_reg1; /* These are registers that differ */
+	int var_ucode_reg2; /* between versions 1 and 2 of the board */
+	int var_ucode_reg3; /* " */
+	
+	/* Interrupt */
+	unsigned irqmask;
+	
+	/* Clockgenerator */
+	int clockgen;
+	int clockgen_overlaymode;
+	int clockgen_tvmode;
+	
+	/* Timing measurement */
+	struct timeval tv, last_status_time;
+	long irqtimediff;
+	int irqcount;
+	int frames;
+	int scr;
+	
+	/* Audio */
+	struct em8300_audio_s audio;
+	int audio_mode;
+        int pcm_mode;
+	int dsp_num;
+/* */
+	int dword_DB4;
+	unsigned char byte_D90[24];
+	
+	/* Video */
+	int video_mode;
+	int video_playmode;
+	int aspect_ratio;
+	uint32_t video_pts;
+	uint32_t video_lastpts;
+	int video_ptsvalid,video_offset,video_count;
+	int video_ptsfifo_ptr;
+	wait_queue_head_t video_ptsfifo_wait;
+	int video_ptsfifo_waiting;
+	int video_first;
+	int var_video_value;
+	
+	/* Sub Picture */
+	int sp_pts, sp_ptsvalid, sp_count;
+	int sp_ptsfifo_ptr;
+	wait_queue_head_t sp_ptsfifo_wait;
+	int sp_ptsfifo_waiting;
+	int sp_mode;
+	
+	int linecounter;
+
+	wait_queue_head_t vbi_wait;
+	struct list_head memory;
+
+	/* EM9010 overlay processor */
+	int overlay_enabled;
+	int overlay_mode;
+	int overlay_gamma_enable;
+	int overlay_xres;
+	int overlay_yres;
+	int overlay_frame_xpos;
+	int overlay_frame_ypos;
+	int overlay_frame_width;
+	int overlay_frame_height;
+	int overlay_a[EM9010_ATTRIBUTE_MAX+1];
+	int overlay_double_y;
+	int overlay_xcorr_default;
+	int overlay_70;
+	int overlay_dword_24bb8;
+};
+
+#define TIMEDIFF(a,b) a.tv_usec - b.tv_usec + \
+	    1000000 * (a.tv_sec - b.tv_sec)
+
+
+/*
+  Prototypes
+*/
+
+/* em8300_i2c.c */
+int em8300_i2c_init(struct em8300_s *em);
+void em8300_i2c_exit(struct em8300_s *em);
+void em8300_clockgen_write(struct em8300_s *em, int abyte);
+
+void em9010_write(struct em8300_s *em, int reg, int data);
+int em9010_read(struct em8300_s *em, int reg);
+int em9010_read16(struct em8300_s *em, int reg);
+void em9010_write16(struct em8300_s *em, int reg, int value);
+
+/* em8300_audio.c */
+int em8300_audio_ioctl(struct em8300_s *em,unsigned int cmd, unsigned long arg);
+int em8300_audio_flush(struct em8300_s *em);
+int em8300_audio_open(struct em8300_s *em);
+int em8300_audio_release(struct em8300_s *em);
+int em8300_audio_setup(struct em8300_s *em);
+int em8300_audio_write(struct em8300_s *em, const char * buf,
+		       size_t count, loff_t *ppos);
+int mpegaudio_command(struct em8300_s *em, int cmd);
+
+/* em8300_ucode.c */
+int em8300_ucode_upload(struct em8300_s *em, void *ucode_user, int ucode_size);
+
+/* em8300_misc.c */
+int em8300_setregblock(struct em8300_s *em, int offset, int val, int len);
+int em8300_writeregblock(struct em8300_s *em, int offset, unsigned *buf, int len);
+int em8300_waitfor(struct em8300_s *em, int reg, int val, int mask);
+int em8300_waitfor_not(struct em8300_s *em, int reg, int val, int mask);
+
+/* em8300_dicom.c */
+void em8300_dicom_setBCS(struct em8300_s *em, int brightness, int contrast, int saturation);
+void em8300_dicom_enable(struct em8300_s *em);
+void em8300_dicom_disable(struct em8300_s *em);
+int em8300_dicom_update(struct em8300_s *em);
+void em8300_dicom_init(struct em8300_s *em);
+int em8300_dicom_get_dbufinfo(struct em8300_s *em);
+void em8300_dicom_fill_dispbuffers(struct em8300_s *em, int xpos, int ypos, int xsize,
+				  int ysize, unsigned int pat1, unsigned int pat2);
+
+/* em8300_video.c */
+void em8300_video_open(struct em8300_s *em);
+int em8300_video_setplaymode(struct em8300_s *em, int mode);
+int em8300_video_sync(struct em8300_s *em);
+int em8300_video_flush(struct em8300_s *em);
+int em8300_video_setup(struct em8300_s *em);
+int em8300_video_release(struct em8300_s *em);
+void em8300_video_setspeed(struct em8300_s *em, int speed);
+int em8300_video_write(struct em8300_s *em, const char * buf,
+		       size_t count, loff_t *ppos);
+int em8300_video_ioctl(struct em8300_s *em, unsigned int cmd, unsigned long arg);
+void em8300_video_check_ptsfifo(struct em8300_s *em);
+
+/* em8300_spu.c */
+int em8300_spu_write(struct em8300_s *em, const char * buf,
+		       size_t count, loff_t *ppos);
+int em8300_spu_open(struct em8300_s *em);
+int em8300_spu_ioctl(struct em8300_s *em, unsigned int cmd, unsigned long arg);
+int em8300_spu_init(struct em8300_s *em);
+void em8300_spu_check_ptsfifo(struct em8300_s *em);
+int em8300_ioctl_setspumode(struct em8300_s *em, int mode);
+void em8300_spu_release(struct em8300_s *em);
+
+/* em8300_ioctl.c */
+int em8300_control_ioctl(struct em8300_s *em, int cmd, unsigned long arg);
+int em8300_ioctl_setvideomode(struct em8300_s *em, int mode);
+int em8300_ioctl_setaspectratio(struct em8300_s *em, int ratio);
+void em8300_ioctl_getstatus(struct em8300_s *em, char *usermsg);
+int em8300_ioctl_init(struct em8300_s *em, em8300_microcode_t *useruc);
+void em8300_ioctl_enable_videoout(struct em8300_s *em, int mode);
+int em8300_ioctl_setplaymode(struct em8300_s *em, int mode);
+int em8300_ioctl_setaudiomode(struct em8300_s *em, int mode);
+int em8300_ioctl_getaudiomode(struct em8300_s *em, int mode);
+int em8300_ioctl_overlay_calibrate(struct em8300_s *em, em8300_overlay_calibrate_t *c);
+int em8300_ioctl_overlay_setwindow(struct em8300_s *em,em8300_overlay_window_t *w);
+int em8300_ioctl_overlay_setscreen(struct em8300_s *em,em8300_overlay_screen_t *s);
+int em8300_ioctl_overlay_setmode(struct em8300_s *em,int val);
+
+/* em9010.c */
+int em9010_cabledetect(struct em8300_s *em);
+int em9010_calibrate_xoffset(struct em8300_s *em);
+int em9010_calibrate_yoffset(struct em8300_s *em);
+int em9010_init(struct em8300_s *em);
+int em9010_overlay_set_signalmode(struct em8300_s *em, int val);
+int em9010_overlay_update(struct em8300_s *em);
+int em9010_overlay_set_res(struct em8300_s *em, int xres, int yres);
+void sub_4288c(struct em8300_s *em, int pa, int pb, int pc, int pd, int pe, int pf,
+	       int pg, int ph);
+int em9010_get_attribute(struct em8300_s *em, int attribute);
+int em9010_set_attribute(struct em8300_s *em, int attribute, int value);
+
+#endif /* __KERNEL__ */
+
+#endif /* LINUX_EM8300_H */
