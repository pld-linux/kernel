diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/Documentation/dontdiff linux-2.6.20.1-pax/Documentation/dontdiff
--- linux-2.6.20.1/Documentation/dontdiff	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/Documentation/dontdiff	2007-02-10 01:32:42.000000000 +0100
@@ -55,7 +55,7 @@ aic7*seq.h*
 aicasm
 aicdb.h*
 asm
-asm-offsets.*
+asm-offsets.h
 asm_offsets.*
 autoconf.h*
 bbootsect
@@ -127,6 +127,7 @@ pss_boot.h
 raid6altivec*.c
 raid6int*.c
 raid6tables.c
+relocs
 setup
 sim710_d.h*
 sm_tbl*
@@ -139,8 +140,11 @@ utsrelease.h*
 version.h*
 vmlinux
 vmlinux-*
+vmlinux.bin.all
 vmlinux.lds
+vmlinux.relocs
 vsyscall.lds
 wanxlfw.inc
 uImage
+utsrelease.h
 zImage
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/Makefile linux-2.6.20.1-pax/Makefile
--- linux-2.6.20.1/Makefile	2007-02-20 12:36:46.000000000 +0100
+++ linux-2.6.20.1-pax/Makefile	2007-02-20 12:36:39.000000000 +0100
@@ -312,7 +312,7 @@ LINUXINCLUDE    := -Iinclude \
 
 CPPFLAGS        := -D__KERNEL__ $(LINUXINCLUDE)
 
-CFLAGS          := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
+CFLAGS          := -Wall -W -Wno-unused -Wno-sign-compare -Wundef -Wstrict-prototypes -Wno-trigraphs \
                    -fno-strict-aliasing -fno-common
 AFLAGS          := -D__ASSEMBLY__
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/alpha/kernel/module.c linux-2.6.20.1-pax/arch/alpha/kernel/module.c
--- linux-2.6.20.1/arch/alpha/kernel/module.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/alpha/kernel/module.c	2007-02-05 00:56:17.000000000 +0100
@@ -177,7 +177,7 @@ apply_relocate_add(Elf64_Shdr *sechdrs, 
 
 	/* The small sections were sorted to the end of the segment.
 	   The following should definitely cover them.  */
-	gp = (u64)me->module_core + me->core_size - 0x8000;
+	gp = (u64)me->module_core_rw + me->core_size_rw - 0x8000;
 	got = sechdrs[me->arch.gotsecindex].sh_addr;
 
 	for (i = 0; i < n; i++) {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/alpha/kernel/osf_sys.c linux-2.6.20.1-pax/arch/alpha/kernel/osf_sys.c
--- linux-2.6.20.1/arch/alpha/kernel/osf_sys.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/alpha/kernel/osf_sys.c	2007-02-05 00:56:17.000000000 +0100
@@ -1277,6 +1277,10 @@ arch_get_unmapped_area(struct file *filp
 	   merely specific addresses, but regions of memory -- perhaps
 	   this feature should be incorporated into all ports?  */
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);
 		if (addr != (unsigned long) -ENOMEM)
@@ -1284,8 +1288,8 @@ arch_get_unmapped_area(struct file *filp
 	}
 
 	/* Next, try allocating at TASK_UNMAPPED_BASE.  */
-	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),
-					 len, limit);
+	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(current->mm->mmap_base), len, limit);
+
 	if (addr != (unsigned long) -ENOMEM)
 		return addr;
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/alpha/mm/fault.c linux-2.6.20.1-pax/arch/alpha/mm/fault.c
--- linux-2.6.20.1/arch/alpha/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/alpha/mm/fault.c	2007-02-05 00:56:17.000000000 +0100
@@ -24,6 +24,7 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/binfmts.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -55,6 +56,124 @@ __load_new_mm_context(struct mm_struct *
 	__reload_thread(pcb);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int ldah, ldq, jmp;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(ldq, (unsigned int *)(regs->pc+4));
+		err |= get_user(jmp, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (ldq & 0xFFFF0000U) == 0xA77B0000U &&
+		    jmp == 0x6BFB0000U)
+		{
+			unsigned long r27, addr;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = ldq | 0xFFFFFFFFFFFF0000UL;
+
+			addr = regs->r27 + ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			err = get_user(r27, (unsigned long*)addr);
+			if (err)
+				break;
+
+			regs->r27 = r27;
+			regs->pc = r27;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #2 */
+		unsigned int ldah, lda, br;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(lda, (unsigned int *)(regs->pc+4));
+		err |= get_user(br, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (lda & 0xFFFF0000U) == 0xA77B0000U &&
+		    (br & 0xFFE00000U) == 0xC3E00000U)
+		{
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = lda | 0xFFFFFFFFFFFF0000UL;
+
+			regs->r27 += ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			regs->pc += 12 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int br;
+
+		err = get_user(br, (unsigned int *)regs->pc);
+
+		if (!err && (br & 0xFFE00000U) == 0xC3800000U) {
+			unsigned int br2, ldq, nop, jmp;
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL, resolver;
+
+			addr = regs->pc + 4 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			err = get_user(br2, (unsigned int *)addr);
+			err |= get_user(ldq, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			err |= get_user(jmp, (unsigned int *)(addr+12));
+			err |= get_user(resolver, (unsigned long *)(addr+16));
+
+			if (err)
+				break;
+
+			if (br2 == 0xC3600000U &&
+			    ldq == 0xA77B000CU &&
+			    nop == 0x47FF041FU &&
+			    jmp == 0x6B7B0000U)
+			{
+				regs->r28 = regs->pc+4;
+				regs->r27 = addr+16;
+				regs->pc = resolver;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -132,8 +251,29 @@ do_page_fault(unsigned long address, uns
  good_area:
 	si_code = SEGV_ACCERR;
 	if (cause < 0) {
-		if (!(vma->vm_flags & VM_EXEC))
+		if (!(vma->vm_flags & VM_EXEC)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->pc)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			switch(pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->pc, (void*)rdusp());
+			do_exit(SIGKILL);
+#else
 			goto bad_area;
+#endif
+
+		}
 	} else if (!cause) {
 		/* Allow reads even for write-only mappings */
 		if (!(vma->vm_flags & (VM_READ | VM_WRITE)))
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/arm/mm/mmap.c linux-2.6.20.1-pax/arch/arm/mm/mmap.c
--- linux-2.6.20.1/arch/arm/mm/mmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/arm/mm/mmap.c	2007-02-05 00:56:17.000000000 +0100
@@ -61,6 +61,10 @@ arch_get_unmapped_area(struct file *filp
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -75,7 +79,7 @@ arch_get_unmapped_area(struct file *filp
 	if (len > mm->cached_hole_size) {
 	        start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
+	        start_addr = addr = mm->mmap_base;
 	        mm->cached_hole_size = 0;
 	}
 
@@ -92,8 +96,8 @@ full_search:
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/Kconfig linux-2.6.20.1-pax/arch/i386/Kconfig
--- linux-2.6.20.1/arch/i386/Kconfig	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/Kconfig	2007-02-05 00:56:17.000000000 +0100
@@ -864,7 +864,7 @@ config HOTPLUG_CPU
 
 config COMPAT_VDSO
 	bool "Compat VDSO support"
-	default y
+	default n
 	depends on !PARAVIRT
 	help
 	  Map the VDSO to the predictable old-style address too.
@@ -1060,7 +1060,7 @@ config PCI
 choice
 	prompt "PCI access mode"
 	depends on PCI && !X86_VISWS
-	default PCI_GOANY
+	default PCI_GODIRECT
 	---help---
 	  On PCI systems, the BIOS can be used to detect the PCI devices and
 	  determine their configuration. However, some old PCI motherboards
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/Kconfig.cpu linux-2.6.20.1-pax/arch/i386/Kconfig.cpu
--- linux-2.6.20.1/arch/i386/Kconfig.cpu	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/Kconfig.cpu	2007-02-05 00:56:18.000000000 +0100
@@ -267,7 +267,7 @@ config X86_PPRO_FENCE
 
 config X86_F00F_BUG
 	bool
-	depends on M586MMX || M586TSC || M586 || M486 || M386
+	depends on (M586MMX || M586TSC || M586 || M486 || M386) && !PAX_KERNEXEC
 	default y
 
 config X86_WP_WORKS_OK
@@ -297,7 +297,7 @@ config X86_CMPXCHG64
 
 config X86_ALIGNMENT_16
 	bool
-	depends on MWINCHIP3D || MWINCHIP2 || MWINCHIPC6 || MCYRIXIII || X86_ELAN || MK6 || M586MMX || M586TSC || M586 || M486 || MVIAC3_2 || MGEODEGX1
+	depends on MWINCHIP3D || MWINCHIP2 || MWINCHIPC6 || MCYRIXIII || X86_ELAN || MK8 || MK7 || MK6 || MPENTIUM4 || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || M586 || M486 || MVIAC3_2 || MGEODEGX1
 	default y
 
 config X86_GOOD_APIC
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/Kconfig.debug linux-2.6.20.1-pax/arch/i386/Kconfig.debug
--- linux-2.6.20.1/arch/i386/Kconfig.debug	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/Kconfig.debug	2007-02-05 00:56:18.000000000 +0100
@@ -48,7 +48,7 @@ config DEBUG_PAGEALLOC
 
 config DEBUG_RODATA
 	bool "Write protect kernel read-only data structures"
-	depends on DEBUG_KERNEL
+	depends on DEBUG_KERNEL && !PAX_KERNEXEC
 	help
 	  Mark the kernel read-only data as write-protected in the pagetables,
 	  in order to catch accidental (and incorrect) writes to such const
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/boot/setup.S linux-2.6.20.1-pax/arch/i386/boot/setup.S
--- linux-2.6.20.1/arch/i386/boot/setup.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/boot/setup.S	2007-02-05 00:56:18.000000000 +0100
@@ -869,11 +869,13 @@ startup_32:
 	movl %eax, %gs
 	movl %eax, %ss
 
+	movl 0x00000000, %ecx
 	xorl %eax, %eax
 1:	incl %eax				# check that A20 really IS enabled
 	movl %eax, 0x00000000			# loop forever if it isn't
 	cmpl %eax, 0x00100000
 	je 1b
+	movl %ecx, 0x00000000
 
 	# Jump to the 32bit entry point
 	jmpl *(code32_start - start + (DELTA_INITSEG << 4))(%esi)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/acpi/boot.c linux-2.6.20.1-pax/arch/i386/kernel/acpi/boot.c
--- linux-2.6.20.1/arch/i386/kernel/acpi/boot.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/acpi/boot.c	2007-02-15 01:43:45.000000000 +0100
@@ -1152,7 +1152,7 @@ static struct dmi_system_id __initdata a
 		     DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 360"),
 		     },
 	 },
-	{}
+	{ NULL, NULL, {{0, NULL}}, NULL}
 };
 
 #endif				/* __i386__ */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/acpi/sleep.c linux-2.6.20.1-pax/arch/i386/kernel/acpi/sleep.c
--- linux-2.6.20.1/arch/i386/kernel/acpi/sleep.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/acpi/sleep.c	2007-02-15 01:44:30.000000000 +0100
@@ -94,7 +94,7 @@ static __initdata struct dmi_system_id a
 		     DMI_MATCH(DMI_PRODUCT_NAME, "S4030CDT/4.3"),
 		     },
 	 },
-	{}
+	{ NULL, NULL, {{0, NULL}}, NULL}
 };
 
 static int __init acpisleep_dmi_init(void)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/acpi/wakeup.S linux-2.6.20.1-pax/arch/i386/kernel/acpi/wakeup.S
--- linux-2.6.20.1/arch/i386/kernel/acpi/wakeup.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/acpi/wakeup.S	2007-02-18 18:31:31.000000000 +0100
@@ -205,13 +205,11 @@ wakeup_pmode_return:
 	# and restore the stack ... but you need gdt for this to work
 	movl	saved_context_esp, %esp
 
-	movl	%cs:saved_magic, %eax
-	cmpl	$0x12345678, %eax
+	cmpl	$0x12345678, saved_magic
 	jne	bogus_magic
 
 	# jump to place where we left off
-	movl	saved_eip,%eax
-	jmp	*%eax
+	jmp	*(saved_eip)
 
 bogus_magic:
 	movw	$0x0e00 + 'B', 0xb8018
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/alternative.c linux-2.6.20.1-pax/arch/i386/kernel/alternative.c
--- linux-2.6.20.1/arch/i386/kernel/alternative.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/alternative.c	2007-02-18 20:20:56.000000000 +0100
@@ -4,6 +4,7 @@
 #include <linux/list.h>
 #include <asm/alternative.h>
 #include <asm/sections.h>
+#include <asm/desc.h>
 
 static int no_replacement    = 0;
 static int smp_alt_once      = 0;
@@ -156,12 +157,18 @@ void apply_alternatives(struct alt_instr
 	u8 *instr;
 	int diff;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	DPRINTK("%s: alt table %p -> %p\n", __FUNCTION__, start, end);
 	for (a = start; a < end; a++) {
 		BUG_ON(a->replacementlen > a->instrlen);
 		if (!boot_cpu_has(a->cpuid))
 			continue;
-		instr = a->instr;
+		instr = a->instr + __KERNEL_TEXT_OFFSET;
 #ifdef CONFIG_X86_64
 		/* vsyscall code is not mapped yet. resolve it manually. */
 		if (instr >= (u8 *)VSYSCALL_START && instr < (u8*)VSYSCALL_END) {
@@ -174,6 +181,11 @@ void apply_alternatives(struct alt_instr
 		diff = a->instrlen - a->replacementlen;
 		nop_out(instr + a->replacementlen, diff);
 	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 #ifdef CONFIG_SMP
@@ -182,49 +194,95 @@ static void alternatives_smp_save(struct
 {
 	struct alt_instr *a;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	DPRINTK("%s: alt table %p-%p\n", __FUNCTION__, start, end);
 	for (a = start; a < end; a++) {
 		memcpy(a->replacement + a->replacementlen,
-		       a->instr,
+		       a->instr + __KERNEL_TEXT_OFFSET,
 		       a->instrlen);
 	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 static void alternatives_smp_apply(struct alt_instr *start, struct alt_instr *end)
 {
 	struct alt_instr *a;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	for (a = start; a < end; a++) {
-		memcpy(a->instr,
+		memcpy(a->instr + __KERNEL_TEXT_OFFSET,
 		       a->replacement + a->replacementlen,
 		       a->instrlen);
 	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 static void alternatives_smp_lock(u8 **start, u8 **end, u8 *text, u8 *text_end)
 {
-	u8 **ptr;
+	u8 *ptr;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
 
-	for (ptr = start; ptr < end; ptr++) {
-		if (*ptr < text)
+	pax_open_kernel(cr0);
+#endif
+
+	for (; start < end; start++) {
+		ptr = *start + __KERNEL_TEXT_OFFSET;
+		if (ptr < text)
 			continue;
-		if (*ptr > text_end)
+		if (ptr > text_end)
 			continue;
-		**ptr = 0xf0; /* lock prefix */
+		*ptr = 0xf0; /* lock prefix */
 	};
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 static void alternatives_smp_unlock(u8 **start, u8 **end, u8 *text, u8 *text_end)
 {
-	u8 **ptr;
+	u8 *ptr;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
 
-	for (ptr = start; ptr < end; ptr++) {
-		if (*ptr < text)
+	for (; start < end; start++) {
+		ptr = *start + __KERNEL_TEXT_OFFSET;
+		if (ptr < text)
 			continue;
-		if (*ptr > text_end)
+		if (ptr > text_end)
 			continue;
-		nop_out(*ptr, 1);
+		nop_out(ptr, 1);
 	};
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 struct smp_alt_module {
@@ -356,8 +414,9 @@ void apply_paravirt(struct paravirt_patc
 
 	for (p = start; p < end; p++) {
 		unsigned int used;
+		u8 *instr = p->instr + __KERNEL_TEXT_OFFSET;
 
-		used = paravirt_ops.patch(p->instrtype, p->clobbers, p->instr,
+		used = paravirt_ops.patch(p->instrtype, p->clobbers, instr,
 					  p->len);
 #ifdef CONFIG_DEBUG_PARAVIRT
 		{
@@ -365,15 +424,14 @@ void apply_paravirt(struct paravirt_patc
 		/* Deliberately clobber regs using "not %reg" to find bugs. */
 		for (i = 0; i < 3; i++) {
 			if (p->len - used >= 2 && (p->clobbers & (1 << i))) {
-				memcpy(p->instr + used, "\xf7\xd0", 2);
-				p->instr[used+1] |= i;
-				used += 2;
+				instr[used++] = 0xf7;
+				instr[used++] = 0xd0 | i;
 			}
 		}
 		}
 #endif
 		/* Pad the rest with nops */
-		nop_out(p->instr + used, p->len - used);
+		nop_out(instr + used, p->len - used);
 	}
 
 	/* Sync to be conservative, in case we patched following instructions */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/apic.c linux-2.6.20.1-pax/arch/i386/kernel/apic.c
--- linux-2.6.20.1/arch/i386/kernel/apic.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/apic.c	2007-02-05 00:56:18.000000000 +0100
@@ -1211,7 +1211,7 @@ inline void smp_local_timer_interrupt(vo
 {
 	profile_tick(CPU_PROFILING);
 #ifdef CONFIG_SMP
-	update_process_times(user_mode_vm(get_irq_regs()));
+	update_process_times(user_mode(get_irq_regs()));
 #endif
 
 	/*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/apm.c linux-2.6.20.1-pax/arch/i386/kernel/apm.c
--- linux-2.6.20.1/arch/i386/kernel/apm.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/apm.c	2007-02-20 23:00:20.000000000 +0100
@@ -236,7 +236,7 @@
 #include "io_ports.h"
 
 extern unsigned long get_cmos_time(void);
-extern void machine_real_restart(unsigned char *, int);
+extern void machine_real_restart(const unsigned char *, unsigned int);
 
 #if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)
 extern int (*console_blank_hook)(int);
@@ -609,9 +609,18 @@ static u8 apm_bios_call(u32 func, u32 eb
 	struct desc_struct	save_desc_40;
 	struct desc_struct	*gdt;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long		cr0;
+#endif
+
 	cpus = apm_save_cpus();
 	
 	cpu = get_cpu();
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	gdt = get_cpu_gdt_table(cpu);
 	save_desc_40 = gdt[0x40 / 8];
 	gdt[0x40 / 8] = bad_bios_desc;
@@ -622,6 +631,11 @@ static u8 apm_bios_call(u32 func, u32 eb
 	APM_DO_RESTORE_SEGS;
 	apm_irq_restore(flags);
 	gdt[0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	put_cpu();
 	apm_restore_cpus(cpus);
 	
@@ -652,9 +666,18 @@ static u8 apm_bios_call_simple(u32 func,
 	struct desc_struct	save_desc_40;
 	struct desc_struct	*gdt;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long		cr0;
+#endif
+
 	cpus = apm_save_cpus();
 	
 	cpu = get_cpu();
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	gdt = get_cpu_gdt_table(cpu);
 	save_desc_40 = gdt[0x40 / 8];
 	gdt[0x40 / 8] = bad_bios_desc;
@@ -665,6 +688,11 @@ static u8 apm_bios_call_simple(u32 func,
 	APM_DO_RESTORE_SEGS;
 	apm_irq_restore(flags);
 	gdt[0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	put_cpu();
 	apm_restore_cpus(cpus);
 	return error;
@@ -932,7 +960,7 @@ recalc:
  
 static void apm_power_off(void)
 {
-	unsigned char	po_bios_call[] = {
+	const unsigned char	po_bios_call[] = {
 		0xb8, 0x00, 0x10,	/* movw  $0x1000,ax  */
 		0x8e, 0xd0,		/* movw  ax,ss       */
 		0xbc, 0x00, 0xf0,	/* movw  $0xf000,sp  */
@@ -1906,7 +1934,10 @@ static struct file_operations apm_bios_f
 static struct miscdevice apm_device = {
 	APM_MINOR_DEV,
 	"apm_bios",
-	&apm_bios_fops
+	&apm_bios_fops,
+	{NULL, NULL},
+	NULL,
+	NULL
 };
 
 
@@ -2016,210 +2047,210 @@ static struct dmi_system_id __initdata a
 		print_if_true,
 		KERN_WARNING "IBM T23 - BIOS 1.03b+ and controller firmware 1.02+ may be needed for Linux APM.",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
-			DMI_MATCH(DMI_BIOS_VERSION, "1AET38WW (1.01b)"), },
+			DMI_MATCH(DMI_BIOS_VERSION, "1AET38WW (1.01b)"), }, NULL
 	},
 	{	/* Handle problems with APM on the C600 */
 		broken_ps2_resume, "Dell Latitude C600",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "Dell"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude C600"), },
+			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude C600"), }, NULL
 	},
 	{	/* Allow interrupts during suspend on Dell Latitude laptops*/
 		set_apm_ints, "Dell Latitude",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude C510"), }
+			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude C510"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked, "Dell Inspiron 2500",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 2500"),
 			DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
-			DMI_MATCH(DMI_BIOS_VERSION,"A11"), },
+			DMI_MATCH(DMI_BIOS_VERSION,"A11"), }, NULL
 	},
 	{	/* Allow interrupts during suspend on Dell Inspiron laptops*/
 		set_apm_ints, "Dell Inspiron", {
 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 4000"), },
+			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 4000"), }, NULL
 	},
 	{	/* Handle problems with APM on Inspiron 5000e */
 		broken_apm_power, "Dell Inspiron 5000e",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "A04"),
-			DMI_MATCH(DMI_BIOS_DATE, "08/24/2000"), },
+			DMI_MATCH(DMI_BIOS_DATE, "08/24/2000"), }, NULL
 	},
 	{	/* Handle problems with APM on Inspiron 2500 */
 		broken_apm_power, "Dell Inspiron 2500",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "A12"),
-			DMI_MATCH(DMI_BIOS_DATE, "02/04/2002"), },
+			DMI_MATCH(DMI_BIOS_DATE, "02/04/2002"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked, "Dell Dimension 4100",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "XPS-Z"),
 			DMI_MATCH(DMI_BIOS_VENDOR,"Intel Corp."),
-			DMI_MATCH(DMI_BIOS_VERSION,"A11"), },
+			DMI_MATCH(DMI_BIOS_VERSION,"A11"), }, NULL
 	},
 	{	/* Allow interrupts during suspend on Compaq Laptops*/
 		set_apm_ints, "Compaq 12XL125",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "Compaq"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Compaq PC"),
 			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
-			DMI_MATCH(DMI_BIOS_VERSION,"4.06"), },
+			DMI_MATCH(DMI_BIOS_VERSION,"4.06"), }, NULL
 	},
 	{	/* Allow interrupts during APM or the clock goes slow */
 		set_apm_ints, "ASUSTeK",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "L8400K series Notebook PC"), },
+			DMI_MATCH(DMI_PRODUCT_NAME, "L8400K series Notebook PC"), }, NULL
 	},
 	{	/* APM blows on shutdown */
 		apm_is_horked, "ABIT KX7-333[R]",
 		{	DMI_MATCH(DMI_BOARD_VENDOR, "ABIT"),
-			DMI_MATCH(DMI_BOARD_NAME, "VT8367-8233A (KX7-333[R])"), },
+			DMI_MATCH(DMI_BOARD_NAME, "VT8367-8233A (KX7-333[R])"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked, "Trigem Delhi3",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "TriGem Computer, Inc"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Delhi3"), },
+			DMI_MATCH(DMI_PRODUCT_NAME, "Delhi3"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked, "Fujitsu-Siemens",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "hoenix/FUJITSU SIEMENS"),
-			DMI_MATCH(DMI_BIOS_VERSION, "Version1.01"), },
+			DMI_MATCH(DMI_BIOS_VERSION, "Version1.01"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked_d850md, "Intel D850MD",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Intel Corp."),
-			DMI_MATCH(DMI_BIOS_VERSION, "MV85010A.86A.0016.P07.0201251536"), },
+			DMI_MATCH(DMI_BIOS_VERSION, "MV85010A.86A.0016.P07.0201251536"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked, "Intel D810EMO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Intel Corp."),
-			DMI_MATCH(DMI_BIOS_VERSION, "MO81010A.86A.0008.P04.0004170800"), },
+			DMI_MATCH(DMI_BIOS_VERSION, "MO81010A.86A.0008.P04.0004170800"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked, "Dell XPS-Z",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Intel Corp."),
 			DMI_MATCH(DMI_BIOS_VERSION, "A11"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "XPS-Z"), },
+			DMI_MATCH(DMI_PRODUCT_NAME, "XPS-Z"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked, "Sharp PC-PJ/AX",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "SHARP"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "PC-PJ/AX"),
 			DMI_MATCH(DMI_BIOS_VENDOR,"SystemSoft"),
-			DMI_MATCH(DMI_BIOS_VERSION,"Version R2.08"), },
+			DMI_MATCH(DMI_BIOS_VERSION,"Version R2.08"), }, NULL
 	},
 	{	/* APM crashes */
 		apm_is_horked, "Dell Inspiron 2500",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 2500"),
 			DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
-			DMI_MATCH(DMI_BIOS_VERSION,"A11"), },
+			DMI_MATCH(DMI_BIOS_VERSION,"A11"), }, NULL
 	},
 	{	/* APM idle hangs */
 		apm_likes_to_melt, "Jabil AMD",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
-			DMI_MATCH(DMI_BIOS_VERSION, "0AASNP06"), },
+			DMI_MATCH(DMI_BIOS_VERSION, "0AASNP06"), }, NULL
 	},
 	{	/* APM idle hangs */
 		apm_likes_to_melt, "AMI Bios",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
-			DMI_MATCH(DMI_BIOS_VERSION, "0AASNP05"), },
+			DMI_MATCH(DMI_BIOS_VERSION, "0AASNP05"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-N505X(DE) */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0206H"),
-			DMI_MATCH(DMI_BIOS_DATE, "08/23/99"), },
+			DMI_MATCH(DMI_BIOS_DATE, "08/23/99"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-N505VX */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "W2K06H0"),
-			DMI_MATCH(DMI_BIOS_DATE, "02/03/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "02/03/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-XG29 */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0117A0"),
-			DMI_MATCH(DMI_BIOS_DATE, "04/25/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "04/25/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-Z600NE */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0121Z1"),
-			DMI_MATCH(DMI_BIOS_DATE, "05/11/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "05/11/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-Z600NE */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "WME01Z1"),
-			DMI_MATCH(DMI_BIOS_DATE, "08/11/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "08/11/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-Z600LEK(DE) */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0206Z3"),
-			DMI_MATCH(DMI_BIOS_DATE, "12/25/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "12/25/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-Z505LS */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0203D0"),
-			DMI_MATCH(DMI_BIOS_DATE, "05/12/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "05/12/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-Z505LS */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0203Z3"),
-			DMI_MATCH(DMI_BIOS_DATE, "08/25/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "08/25/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-Z505LS (with updated BIOS) */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0209Z3"),
-			DMI_MATCH(DMI_BIOS_DATE, "05/12/01"), },
+			DMI_MATCH(DMI_BIOS_DATE, "05/12/01"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-F104K */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0204K2"),
-			DMI_MATCH(DMI_BIOS_DATE, "08/28/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "08/28/00"), }, NULL
 	},
 
 	{	/* Handle problems with APM on Sony Vaio PCG-C1VN/C1VE */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0208P1"),
-			DMI_MATCH(DMI_BIOS_DATE, "11/09/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "11/09/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-C1VE */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "R0204P1"),
-			DMI_MATCH(DMI_BIOS_DATE, "09/12/00"), },
+			DMI_MATCH(DMI_BIOS_DATE, "09/12/00"), }, NULL
 	},
 	{	/* Handle problems with APM on Sony Vaio PCG-C1VE */
 		swab_apm_power_in_minutes, "Sony VAIO",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			DMI_MATCH(DMI_BIOS_VERSION, "WXPO1Z3"),
-			DMI_MATCH(DMI_BIOS_DATE, "10/26/01"), },
+			DMI_MATCH(DMI_BIOS_DATE, "10/26/01"), }, NULL
 	},
 	{	/* broken PM poweroff bios */
 		set_realmode_power_off, "Award Software v4.60 PGMA",
 		{	DMI_MATCH(DMI_BIOS_VENDOR, "Award Software International, Inc."),
 			DMI_MATCH(DMI_BIOS_VERSION, "4.60 PGMA"),
-			DMI_MATCH(DMI_BIOS_DATE, "134526184"), },
+			DMI_MATCH(DMI_BIOS_DATE, "134526184"), }, NULL
 	},
 
 	/* Generic per vendor APM settings  */
 
 	{	/* Allow interrupts during suspend on IBM laptops */
 		set_apm_ints, "IBM",
-		{	DMI_MATCH(DMI_SYS_VENDOR, "IBM"), },
+		{	DMI_MATCH(DMI_SYS_VENDOR, "IBM"), }, NULL
 	},
 
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL}
 };
 
 /*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/asm-offsets.c linux-2.6.20.1-pax/arch/i386/kernel/asm-offsets.c
--- linux-2.6.20.1/arch/i386/kernel/asm-offsets.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/asm-offsets.c	2007-02-15 00:47:06.000000000 +0100
@@ -94,12 +94,14 @@ void foo(void)
 		 sizeof(struct tss_struct));
 
 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
+	DEFINE(PTRS_PER_PTE_asm, PTRS_PER_PTE);
 	DEFINE(VDSO_PRELINK, VDSO_PRELINK);
 
 	OFFSET(crypto_tfm_ctx_offset, crypto_tfm, __crt_ctx);
 
 	BLANK();
- 	OFFSET(PDA_cpu, i386_pda, cpu_number);
+	DEFINE(PDA_size, sizeof __cpu_pda);
+	OFFSET(PDA_cpu, i386_pda, cpu_number);
 	OFFSET(PDA_pcurrent, i386_pda, pcurrent);
 
 #ifdef CONFIG_PARAVIRT
@@ -110,5 +112,6 @@ void foo(void)
 	OFFSET(PARAVIRT_irq_enable_sysexit, paravirt_ops, irq_enable_sysexit);
 	OFFSET(PARAVIRT_iret, paravirt_ops, iret);
 	OFFSET(PARAVIRT_read_cr0, paravirt_ops, read_cr0);
+	OFFSET(PARAVIRT_write_cr0, paravirt_ops, write_cr0);
 #endif
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/cpu/common.c linux-2.6.20.1-pax/arch/i386/kernel/cpu/common.c
--- linux-2.6.20.1/arch/i386/kernel/cpu/common.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/cpu/common.c	2007-02-15 10:47:12.000000000 +0100
@@ -4,7 +4,6 @@
 #include <linux/smp.h>
 #include <linux/module.h>
 #include <linux/percpu.h>
-#include <linux/bootmem.h>
 #include <asm/semaphore.h>
 #include <asm/processor.h>
 #include <asm/i387.h>
@@ -22,16 +21,18 @@
 
 #include "cpu.h"
 
-DEFINE_PER_CPU(struct Xgt_desc_struct, cpu_gdt_descr);
-EXPORT_PER_CPU_SYMBOL(cpu_gdt_descr);
-
-struct i386_pda *_cpu_pda[NR_CPUS] __read_mostly;
+struct i386_pda *_cpu_pda[NR_CPUS];
 EXPORT_SYMBOL(_cpu_pda);
 
 static int cachesize_override __cpuinitdata = -1;
 static int disable_x86_fxsr __cpuinitdata;
 static int disable_x86_serial_nr __cpuinitdata = 1;
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_KERNEXEC)
+static int disable_x86_sep __cpuinitdata = 1;
+#else
 static int disable_x86_sep __cpuinitdata;
+#endif
 
 struct cpu_dev * cpu_devs[X86_VENDOR_NUM] = {};
 
@@ -609,52 +610,6 @@ struct pt_regs * __devinit idle_regs(str
 	return regs;
 }
 
-static __cpuinit int alloc_gdt(int cpu)
-{
-	struct Xgt_desc_struct *cpu_gdt_descr = &per_cpu(cpu_gdt_descr, cpu);
-	struct desc_struct *gdt;
-	struct i386_pda *pda;
-
-	gdt = (struct desc_struct *)cpu_gdt_descr->address;
-	pda = cpu_pda(cpu);
-
-	/*
-	 * This is a horrible hack to allocate the GDT.  The problem
-	 * is that cpu_init() is called really early for the boot CPU
-	 * (and hence needs bootmem) but much later for the secondary
-	 * CPUs, when bootmem will have gone away
-	 */
-	if (NODE_DATA(0)->bdata->node_bootmem_map) {
-		BUG_ON(gdt != NULL || pda != NULL);
-
-		gdt = alloc_bootmem_pages(PAGE_SIZE);
-		pda = alloc_bootmem(sizeof(*pda));
-		/* alloc_bootmem(_pages) panics on failure, so no check */
-
-		memset(gdt, 0, PAGE_SIZE);
-		memset(pda, 0, sizeof(*pda));
-	} else {
-		/* GDT and PDA might already have been allocated if
-		   this is a CPU hotplug re-insertion. */
-		if (gdt == NULL)
-			gdt = (struct desc_struct *)get_zeroed_page(GFP_KERNEL);
-
-		if (pda == NULL)
-			pda = kmalloc_node(sizeof(*pda), GFP_KERNEL, cpu_to_node(cpu));
-
-		if (unlikely(!gdt || !pda)) {
-			free_pages((unsigned long)gdt, 0);
-			kfree(pda);
-			return 0;
-		}
-	}
-
- 	cpu_gdt_descr->address = (unsigned long)gdt;
-	cpu_pda(cpu) = pda;
-
-	return 1;
-}
-
 /* Initial PDA used by boot CPU */
 struct i386_pda boot_pda = {
 	._pda = &boot_pda,
@@ -672,59 +627,47 @@ static inline void set_kernel_gs(void)
 
 /* Initialize the CPU's GDT and PDA.  The boot CPU does this for
    itself, but secondaries find this done for them. */
-__cpuinit int init_gdt(int cpu, struct task_struct *idle)
+__cpuinit void init_gdt(int cpu, struct task_struct *idle)
 {
-	struct Xgt_desc_struct *cpu_gdt_descr = &per_cpu(cpu_gdt_descr, cpu);
-	struct desc_struct *gdt;
-	struct i386_pda *pda;
-
-	/* For non-boot CPUs, the GDT and PDA should already have been
-	   allocated. */
-	if (!alloc_gdt(cpu)) {
-		printk(KERN_CRIT "CPU%d failed to allocate GDT or PDA\n", cpu);
-		return 0;
-	}
-
-	gdt = (struct desc_struct *)cpu_gdt_descr->address;
-	pda = cpu_pda(cpu);
+	struct desc_struct *gdt = get_cpu_gdt_table(cpu);
+	struct i386_pda *pda = __cpu_pda + cpu;
+	struct i386_pda **_pda = (struct i386_pda **)&pda->_pda;
 
-	BUG_ON(gdt == NULL || pda == NULL);
+	cpu_gdt_descr[cpu].address = gdt;
+	cpu_pda(cpu) = pda;
 
 	/*
 	 * Initialize the per-CPU GDT with the boot GDT,
 	 * and set up the GDT descriptor:
 	 */
- 	memcpy(gdt, cpu_gdt_table, GDT_SIZE);
-	cpu_gdt_descr->size = GDT_SIZE - 1;
+	if (cpu)
+		memcpy(gdt, cpu_gdt_table, GDT_SIZE);
+	cpu_gdt_descr[cpu].size = GDT_SIZE - 1;
 
 	pack_descriptor((u32 *)&gdt[GDT_ENTRY_PDA].a,
 			(u32 *)&gdt[GDT_ENTRY_PDA].b,
 			(unsigned long)pda, sizeof(*pda) - 1,
-			0x80 | DESCTYPE_S | 0x2, 0); /* present read-write data segment */
+			0x80 | DESCTYPE_S | 0x3, 0); /* present read-write data segment */
 
 	memset(pda, 0, sizeof(*pda));
-	pda->_pda = pda;
+	*_pda = pda;
 	pda->cpu_number = cpu;
 	pda->pcurrent = idle;
-
-	return 1;
 }
 
 void __cpuinit cpu_set_gdt(int cpu)
 {
-	struct Xgt_desc_struct *cpu_gdt_descr = &per_cpu(cpu_gdt_descr, cpu);
-
 	/* Reinit these anyway, even if they've already been done (on
 	   the boot CPU, this will transition from the boot gdt+pda to
 	   the real ones). */
-	load_gdt(cpu_gdt_descr);
+	load_gdt(&cpu_gdt_descr[cpu]);
 	set_kernel_gs();
 }
 
 /* Common CPU init for both boot and secondary CPUs */
 static void __cpuinit _cpu_init(int cpu, struct task_struct *curr)
 {
-	struct tss_struct * t = &per_cpu(init_tss, cpu);
+	struct tss_struct * t = init_tss + cpu;
 	struct thread_struct *thread = &curr->thread;
 
 	if (cpu_test_and_set(cpu, cpu_initialized)) {
@@ -805,12 +748,7 @@ void __cpuinit cpu_init(void)
 
 	/* Set up the real GDT and PDA, so we can transition from the
 	   boot versions. */
-	if (!init_gdt(cpu, curr)) {
-		/* failed to allocate something; not much we can do... */
-		for (;;)
-			local_irq_enable();
-	}
-
+	init_gdt(cpu, curr);
 	cpu_set_gdt(cpu);
 	_cpu_init(cpu, curr);
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c linux-2.6.20.1-pax/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c
--- linux-2.6.20.1/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c	2007-02-20 22:58:40.000000000 +0100
@@ -563,7 +563,7 @@ static struct dmi_system_id sw_any_bug_d
 			DMI_MATCH(DMI_PRODUCT_NAME, "X6DLP"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c linux-2.6.20.1-pax/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
--- linux-2.6.20.1/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c	2007-02-20 22:59:00.000000000 +0100
@@ -229,7 +229,7 @@ static struct cpu_model models[] =
 	{ &cpu_ids[CPU_MP4HT_D0], NULL, 0, NULL },
 	{ &cpu_ids[CPU_MP4HT_E0], NULL, 0, NULL },
 
-	{ NULL, }
+	{ NULL, NULL, 0, NULL}
 };
 #undef _BANIAS
 #undef BANIAS
@@ -404,7 +404,7 @@ static struct dmi_system_id sw_any_bug_d
 			DMI_MATCH(DMI_PRODUCT_NAME, "X6DLP"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/cpu/cyrix.c linux-2.6.20.1-pax/arch/i386/kernel/cpu/cyrix.c
--- linux-2.6.20.1/arch/i386/kernel/cpu/cyrix.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/cpu/cyrix.c	2007-02-15 01:57:59.000000000 +0100
@@ -187,7 +187,7 @@ static void __cpuinit geode_configure(vo
 static struct pci_device_id __cpuinitdata cyrix_55x0[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5510) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5520) },
-	{ },
+	{ PCI_DEVICE(0, 0) },
 };
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/cpu/mcheck/therm_throt.c linux-2.6.20.1-pax/arch/i386/kernel/cpu/mcheck/therm_throt.c
--- linux-2.6.20.1/arch/i386/kernel/cpu/mcheck/therm_throt.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/cpu/mcheck/therm_throt.c	2007-02-09 14:43:03.000000000 +0100
@@ -148,7 +148,7 @@ static __cpuinit int thermal_throttle_cp
 	return NOTIFY_OK;
 }
 
-static struct notifier_block thermal_throttle_cpu_notifier =
+static __cpuinitdata struct notifier_block thermal_throttle_cpu_notifier =
 {
 	.notifier_call = thermal_throttle_cpu_callback,
 };
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/cpu/mtrr/generic.c linux-2.6.20.1-pax/arch/i386/kernel/cpu/mtrr/generic.c
--- linux-2.6.20.1/arch/i386/kernel/cpu/mtrr/generic.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/cpu/mtrr/generic.c	2007-02-15 02:01:11.000000000 +0100
@@ -21,7 +21,7 @@ struct mtrr_state {
 };
 
 static unsigned long smp_changes_mask;
-static struct mtrr_state mtrr_state = {};
+static struct mtrr_state mtrr_state;
 
 #undef MODULE_PARAM_PREFIX
 #define MODULE_PARAM_PREFIX "mtrr."
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/crash.c linux-2.6.20.1-pax/arch/i386/kernel/crash.c
--- linux-2.6.20.1/arch/i386/kernel/crash.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/crash.c	2007-02-05 00:56:18.000000000 +0100
@@ -55,7 +55,7 @@ static int crash_nmi_callback(struct not
 		return NOTIFY_STOP;
 	local_irq_disable();
 
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		crash_fixup_ss_esp(&fixed_regs, regs);
 		regs = &fixed_regs;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/doublefault.c linux-2.6.20.1-pax/arch/i386/kernel/doublefault.c
--- linux-2.6.20.1/arch/i386/kernel/doublefault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/doublefault.c	2007-02-15 02:21:00.000000000 +0100
@@ -11,17 +11,17 @@
 
 #define DOUBLEFAULT_STACKSIZE (1024)
 static unsigned long doublefault_stack[DOUBLEFAULT_STACKSIZE];
-#define STACK_START (unsigned long)(doublefault_stack+DOUBLEFAULT_STACKSIZE)
+#define STACK_START (unsigned long)(doublefault_stack+DOUBLEFAULT_STACKSIZE-2)
 
 #define ptr_ok(x) ((x) > PAGE_OFFSET && (x) < PAGE_OFFSET + 0x1000000)
 
 static void doublefault_fn(void)
 {
-	struct Xgt_desc_struct gdt_desc = {0, 0};
+	struct Xgt_desc_struct gdt_desc = {0, NULL, 0};
 	unsigned long gdt, tss;
 
 	store_gdt(&gdt_desc);
-	gdt = gdt_desc.address;
+	gdt = (unsigned long)gdt_desc.address;
 
 	printk("double fault, gdt at %08lx [%d bytes]\n", gdt, gdt_desc.size);
 
@@ -57,10 +57,10 @@ struct tss_struct doublefault_tss __cach
 	.eip		= (unsigned long) doublefault_fn,
 	.eflags		= X86_EFLAGS_SF | 0x2,	/* 0x2 bit is always set */
 	.esp		= STACK_START,
-	.es		= __USER_DS,
+	.es		= __KERNEL_DS,
 	.cs		= __KERNEL_CS,
 	.ss		= __KERNEL_DS,
-	.ds		= __USER_DS,
+	.ds		= __KERNEL_DS,
 
 	.__cr3		= __pa(swapper_pg_dir)
 };
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/efi.c linux-2.6.20.1-pax/arch/i386/kernel/efi.c
--- linux-2.6.20.1/arch/i386/kernel/efi.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/efi.c	2007-02-05 00:56:18.000000000 +0100
@@ -63,82 +63,43 @@ extern void * boot_ioremap(unsigned long
 
 static unsigned long efi_rt_eflags;
 static DEFINE_SPINLOCK(efi_rt_lock);
-static pgd_t efi_bak_pg_dir_pointer[2];
+static pgd_t __initdata efi_bak_pg_dir_pointer[KERNEL_PGD_PTRS] __attribute__ ((aligned (4096)));
 
 static void efi_call_phys_prelog(void) __acquires(efi_rt_lock)
 {
-	unsigned long cr4;
-	unsigned long temp;
-	struct Xgt_desc_struct *cpu_gdt_descr;
-
 	spin_lock(&efi_rt_lock);
 	local_irq_save(efi_rt_eflags);
 
-	cpu_gdt_descr = &per_cpu(cpu_gdt_descr, 0);
-
-	/*
-	 * If I don't have PSE, I should just duplicate two entries in page
-	 * directory. If I have PSE, I just need to duplicate one entry in
-	 * page directory.
-	 */
-	cr4 = read_cr4();
-
-	if (cr4 & X86_CR4_PSE) {
-		efi_bak_pg_dir_pointer[0].pgd =
-		    swapper_pg_dir[pgd_index(0)].pgd;
-		swapper_pg_dir[0].pgd =
-		    swapper_pg_dir[pgd_index(PAGE_OFFSET)].pgd;
-	} else {
-		efi_bak_pg_dir_pointer[0].pgd =
-		    swapper_pg_dir[pgd_index(0)].pgd;
-		efi_bak_pg_dir_pointer[1].pgd =
-		    swapper_pg_dir[pgd_index(0x400000)].pgd;
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    swapper_pg_dir[pgd_index(PAGE_OFFSET)].pgd;
-		temp = PAGE_OFFSET + 0x400000;
-		swapper_pg_dir[pgd_index(0x400000)].pgd =
-		    swapper_pg_dir[pgd_index(temp)].pgd;
-	}
+	clone_pgd_range(efi_bak_pg_dir_pointer, swapper_pg_dir, KERNEL_PGD_PTRS);
+	clone_pgd_range(swapper_pg_dir, swapper_pg_dir + USER_PGD_PTRS,
+			min_t(unsigned long, KERNEL_PGD_PTRS, USER_PGD_PTRS));
 
 	/*
 	 * After the lock is released, the original page table is restored.
 	 */
-	local_flush_tlb();
+	__flush_tlb_all();
 
-	cpu_gdt_descr->address = __pa(cpu_gdt_descr->address);
-	load_gdt(cpu_gdt_descr);
+	cpu_gdt_descr[0].address = __pa(cpu_gdt_descr[0].address);
+	load_gdt((struct Xgt_desc_struct *) __pa(&cpu_gdt_descr[0]));
 }
 
 static void efi_call_phys_epilog(void) __releases(efi_rt_lock)
 {
-	unsigned long cr4;
-	struct Xgt_desc_struct *cpu_gdt_descr = &per_cpu(cpu_gdt_descr, 0);
-
-	cpu_gdt_descr->address = (unsigned long)__va(cpu_gdt_descr->address);
-	load_gdt(cpu_gdt_descr);
-
-	cr4 = read_cr4();
+	cpu_gdt_descr[0].address = (unsigned long) __va(cpu_gdt_descr[0].address);
+	load_gdt(&cpu_gdt_descr[0]);
 
-	if (cr4 & X86_CR4_PSE) {
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    efi_bak_pg_dir_pointer[0].pgd;
-	} else {
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    efi_bak_pg_dir_pointer[0].pgd;
-		swapper_pg_dir[pgd_index(0x400000)].pgd =
-		    efi_bak_pg_dir_pointer[1].pgd;
-	}
+	clone_pgd_range(swapper_pg_dir, efi_bak_pg_dir_pointer, KERNEL_PGD_PTRS);
 
 	/*
 	 * After the lock is released, the original page table is restored.
 	 */
-	local_flush_tlb();
+	__flush_tlb_all();
 
 	local_irq_restore(efi_rt_eflags);
 	spin_unlock(&efi_rt_lock);
 }
 
-static efi_status_t
+static efi_status_t __init
 phys_efi_set_virtual_address_map(unsigned long memory_map_size,
 				 unsigned long descriptor_size,
 				 u32 descriptor_version,
@@ -154,7 +115,7 @@ phys_efi_set_virtual_address_map(unsigne
 	return status;
 }
 
-static efi_status_t
+static efi_status_t __init
 phys_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
 {
 	efi_status_t status;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/efi_stub.S linux-2.6.20.1-pax/arch/i386/kernel/efi_stub.S
--- linux-2.6.20.1/arch/i386/kernel/efi_stub.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/efi_stub.S	2007-02-05 00:56:18.000000000 +0100
@@ -6,6 +6,7 @@
  */
 
 #include <linux/linkage.h>
+#include <linux/init.h>
 #include <asm/page.h>
 
 /*
@@ -20,7 +21,7 @@
  * service functions will comply with gcc calling convention, too.
  */
 
-.text
+__INIT
 ENTRY(efi_call_phys)
 	/*
 	 * 0. The function can only be called in Linux kernel. So CS has been
@@ -36,9 +37,7 @@ ENTRY(efi_call_phys)
 	 * The mapping of lower virtual memory has been created in prelog and
 	 * epilog.
 	 */
-	movl	$1f, %edx
-	subl	$__PAGE_OFFSET, %edx
-	jmp	*%edx
+	jmp	1f-__PAGE_OFFSET
 1:
 
 	/*
@@ -47,14 +46,8 @@ ENTRY(efi_call_phys)
 	 * parameter 2, ..., param n. To make things easy, we save the return
 	 * address of efi_call_phys in a global variable.
 	 */
-	popl	%edx
-	movl	%edx, saved_return_addr
-	/* get the function pointer into ECX*/
-	popl	%ecx
-	movl	%ecx, efi_rt_function_ptr
-	movl	$2f, %edx
-	subl	$__PAGE_OFFSET, %edx
-	pushl	%edx
+	popl	(saved_return_addr)
+	popl	(efi_rt_function_ptr)
 
 	/*
 	 * 3. Clear PG bit in %CR0.
@@ -73,9 +66,8 @@ ENTRY(efi_call_phys)
 	/*
 	 * 5. Call the physical function.
 	 */
-	jmp	*%ecx
+	call	*(efi_rt_function_ptr-__PAGE_OFFSET)
 
-2:
 	/*
 	 * 6. After EFI runtime service returns, control will return to
 	 * following instruction. We'd better readjust stack pointer first.
@@ -85,37 +77,29 @@ ENTRY(efi_call_phys)
 	/*
 	 * 7. Restore PG bit
 	 */
-	movl	%cr0, %edx
-	orl	$0x80000000, %edx
-	movl	%edx, %cr0
-	jmp	1f
-1:
 	/*
 	 * 8. Now restore the virtual mode from flat mode by
 	 * adding EIP with PAGE_OFFSET.
 	 */
-	movl	$1f, %edx
-	jmp	*%edx
+	movl	%cr0, %edx
+	orl	$0x80000000, %edx
+	movl	%edx, %cr0
+	jmp	1f+__PAGE_OFFSET
 1:
 
 	/*
 	 * 9. Balance the stack. And because EAX contain the return value,
 	 * we'd better not clobber it.
 	 */
-	leal	efi_rt_function_ptr, %edx
-	movl	(%edx), %ecx
-	pushl	%ecx
+	pushl	(efi_rt_function_ptr)
 
 	/*
-	 * 10. Push the saved return address onto the stack and return.
+	 * 10. Return to the saved return address.
 	 */
-	leal	saved_return_addr, %edx
-	movl	(%edx), %ecx
-	pushl	%ecx
-	ret
+	jmpl	*(saved_return_addr)
 .previous
 
-.data
+__INITDATA
 saved_return_addr:
 	.long 0
 efi_rt_function_ptr:
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/entry.S linux-2.6.20.1-pax/arch/i386/kernel/entry.S
--- linux-2.6.20.1/arch/i386/kernel/entry.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/entry.S	2007-02-18 22:17:16.000000000 +0100
@@ -49,7 +49,6 @@
 #include <asm/smp.h>
 #include <asm/page.h>
 #include <asm/desc.h>
-#include <asm/percpu.h>
 #include <asm/dwarf2.h>
 #include "irq_vectors.h"
 
@@ -97,7 +96,7 @@ VM_MASK		= 0x00020000
 #define resume_userspace_sig	resume_userspace
 #endif
 
-#define SAVE_ALL \
+#define __SAVE_ALL(_DS) \
 	cld; \
 	pushl %gs; \
 	CFI_ADJUST_CFA_OFFSET 4;\
@@ -129,12 +128,26 @@ VM_MASK		= 0x00020000
 	pushl %ebx; \
 	CFI_ADJUST_CFA_OFFSET 4;\
 	CFI_REL_OFFSET ebx, 0;\
-	movl $(__USER_DS), %edx; \
+	movl $(_DS), %edx; \
 	movl %edx, %ds; \
 	movl %edx, %es; \
 	movl $(__KERNEL_PDA), %edx; \
 	movl %edx, %gs
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define SAVE_ALL \
+	__SAVE_ALL(__KERNEL_DS); \
+	GET_CR0_INTO_EDX; \
+	movl %edx, %esi; \
+	orl $0x10000, %edx; \
+	xorl %edx, %esi; \
+	SET_CR0_FROM_EDX
+#elif defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_MEMORY_UDEREF)
+#define SAVE_ALL __SAVE_ALL(__KERNEL_DS)
+#else
+#define SAVE_ALL __SAVE_ALL(__USER_DS)
+#endif
+
 #define RESTORE_INT_REGS \
 	popl %ebx;	\
 	CFI_ADJUST_CFA_OFFSET -4;\
@@ -247,7 +260,17 @@ check_userspace:
 	movb PT_CS(%esp), %al
 	andl $(VM_MASK | SEGMENT_RPL_MASK), %eax
 	cmpl $USER_RPL, %eax
+
+#ifdef CONFIG_PAX_KERNEXEC
+	jae resume_userspace
+
+	GET_CR0_INTO_EDX
+	xorl %esi, %edx
+	SET_CR0_FROM_EDX
+	jmp resume_kernel
+#else
 	jb resume_kernel		# not returning to v8086 or userspace
+#endif
 
 ENTRY(resume_userspace)
  	DISABLE_INTERRUPTS(CLBR_ANY)	# make sure we don't miss an interrupt
@@ -305,10 +328,9 @@ sysenter_past_esp:
 #ifndef CONFIG_COMPAT_VDSO
 	/*
 	 * Push current_thread_info()->sysenter_return to the stack.
-	 * A tiny bit of offset fixup is necessary - 4*4 means the 4 words
-	 * pushed above; +8 corresponds to copy_thread's esp0 setting.
 	 */
-	pushl (TI_sysenter_return-THREAD_SIZE+8+4*4)(%esp)
+	GET_THREAD_INFO(%ebp)
+	pushl TI_sysenter_return(%ebp)
 #else
 	pushl $SYSENTER_RETURN
 #endif
@@ -319,9 +341,20 @@ sysenter_past_esp:
  * Load the potential sixth argument from user stack.
  * Careful about security.
  */
+	movl 12(%esp),%ebp
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pushl $(__USER_DS)
+	CFI_ADJUST_CFA_OFFSET 4
+	pop %ds
+	CFI_ADJUST_CFA_OFFSET -4
+1:	movl %ds:(%ebp),%ebp
+#else
 	cmpl $__PAGE_OFFSET-3,%ebp
 	jae syscall_fault
 1:	movl (%ebp),%ebp
+#endif
+
 .section __ex_table,"a"
 	.align 4
 	.long 1b,syscall_fault
@@ -344,20 +377,37 @@ sysenter_past_esp:
 	movl TI_flags(%ebp), %ecx
 	testw $_TIF_ALLWORK_MASK, %cx
 	jne syscall_exit_work
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pushl %eax
+	CFI_ADJUST_CFA_OFFSET 4
+	call pax_randomize_kstack
+	popl %eax
+	CFI_ADJUST_CFA_OFFSET -4
+#endif
+
 /* if something modifies registers it must also disable sysexit */
 	movl PT_EIP(%esp), %edx
 	movl PT_OLDESP(%esp), %ecx
 	xorl %ebp,%ebp
 	TRACE_IRQS_ON
 1:	mov  PT_GS(%esp), %gs
+2:	mov  PT_DS(%esp), %ds
+3:	mov  PT_ES(%esp), %es
 	ENABLE_INTERRUPTS_SYSEXIT
 	CFI_ENDPROC
 .pushsection .fixup,"ax"
-2:	movl $0,PT_GS(%esp)
+4:	movl $0,PT_GS(%esp)
 	jmp 1b
+5:	movl $0,PT_DS(%esp)
+	jmp 2b
+6:	movl $0,PT_ES(%esp)
+	jmp 3b
 .section __ex_table,"a"
 	.align 4
-	.long 1b,2b
+	.long 1b,4b
+	.long 2b,5b
+	.long 3b,6b
 .popsection
 
 	# system call handler stub
@@ -389,6 +439,10 @@ syscall_exit:
 	testw $_TIF_ALLWORK_MASK, %cx	# current->work
 	jne syscall_exit_work
 
+#ifdef CONFIG_PAX_RANDKSTACK
+	call pax_randomize_kstack
+#endif
+
 restore_all:
 	movl PT_EFLAGS(%esp), %eax	# mix EFLAGS, SS and CS
 	# Warning: PT_OLDSS(%esp) contains the wrong/random values if we
@@ -551,7 +605,8 @@ syscall_badsys:
 #define FIXUP_ESPFIX_STACK \
 	/* since we are on a wrong stack, we cant make it a C code :( */ \
 	movl %gs:PDA_cpu, %ebx; \
-	PER_CPU(cpu_gdt_descr, %ebx); \
+	shrl $PAGE_SHIFT,%ebx; \
+	leal cpu_gdt_descr(%ebx), %ebx; \
 	movl GDS_address(%ebx), %ebx; \
 	GET_DESC_BASE(GDT_ENTRY_ESPFIX_SS, %ebx, %eax, %ax, %al, %ah); \
 	addl %esp, %eax; \
@@ -577,7 +632,7 @@ syscall_badsys:
  * Build the entry stubs and pointer table with
  * some assembler magic.
  */
-.data
+.section .rodata,"a",@progbits
 ENTRY(interrupt)
 .text
 
@@ -592,7 +647,7 @@ ENTRY(irq_entries_start)
 1:	pushl $~(vector)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp common_interrupt
-.data
+.section .rodata,"a",@progbits
 	.long 1b
 .text
 vector=vector+1
@@ -670,12 +725,21 @@ error_code:
 	popl %ecx
 	CFI_ADJUST_CFA_OFFSET -4
 	/*CFI_REGISTER es, ecx*/
+
+#ifdef CONFIG_PAX_KERNEXEC
+	GET_CR0_INTO_EDX
+	movl %edx, %esi
+	orl $0x10000, %edx
+	xorl %edx, %esi
+	SET_CR0_FROM_EDX
+#endif
+
 	movl PT_GS(%esp), %edi		# get the function address
 	movl PT_ORIG_EAX(%esp), %edx	# get the error code
 	movl $-1, PT_ORIG_EAX(%esp)	# no syscall to restart
 	mov  %ecx, PT_GS(%esp)
 	/*CFI_REL_OFFSET gs, ES*/
-	movl $(__USER_DS), %ecx
+	movl $(__KERNEL_DS), %ecx
 	movl %ecx, %ds
 	movl %ecx, %es
 	movl %esp,%eax			# pt_regs pointer
@@ -806,6 +870,13 @@ nmi_stack_correct:
 	xorl %edx,%edx		# zero error code
 	movl %esp,%eax		# pt_regs pointer
 	call do_nmi
+
+#ifdef CONFIG_PAX_KERNEXEC
+	GET_CR0_INTO_EDX
+	xorl %esi, %edx
+	SET_CR0_FROM_EDX
+#endif
+
 	jmp restore_nocheck_notrace
 	CFI_ENDPROC
 
@@ -846,6 +917,13 @@ nmi_espfix_stack:
 	FIXUP_ESPFIX_STACK		# %eax == %esp
 	xorl %edx,%edx			# zero error code
 	call do_nmi
+
+#ifdef CONFIG_PAX_KERNEXEC
+	GET_CR0_INTO_EDX
+	xorl %esi, %edx
+	SET_CR0_FROM_EDX
+#endif
+
 	RESTORE_REGS
 	lss 12+4(%esp), %esp		# back to espfix stack
 	CFI_ADJUST_CFA_OFFSET -24
@@ -996,7 +1074,6 @@ ENTRY(kernel_thread_helper)
 	CFI_ENDPROC
 ENDPROC(kernel_thread_helper)
 
-.section .rodata,"a"
 #include "syscall_table.S"
 
 syscall_table_size=(.-sys_call_table)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/head.S linux-2.6.20.1-pax/arch/i386/kernel/head.S
--- linux-2.6.20.1/arch/i386/kernel/head.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/head.S	2007-02-18 19:05:19.000000000 +0100
@@ -45,6 +45,16 @@
  */
 #define INIT_MAP_BEYOND_END	(128*1024)
 
+#ifdef CONFIG_PAX_KERNEXEC
+/* PaX: fill first page in .text with int3 to catch NULL derefs in kernel mode */
+.fill 4096,1,0xcc
+#endif
+
+/*
+ * Real beginning of normal "text" segment
+ */
+ENTRY(stext)
+ENTRY(_stext)
 
 /*
  * 32-bit kernel entrypoint; only used by the boot CPU.  On entry,
@@ -72,6 +82,36 @@ ENTRY(startup_32)
 	movl %eax,%fs
 	movl %eax,%gs
 
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	/* check for VMware */
+	movl $0x564d5868,%eax
+	xorl %ebx,%ebx
+	movl $0xa,%ecx
+	movl $0x5658,%edx
+	in (%dx),%eax
+	cmpl $0x564d5868,%ebx
+	jz 1f
+
+	movl $((((__PAGE_OFFSET-1) & 0xf0000000) >> 12) | 0x00c09700),%eax
+	movl %eax,(cpu_gdt_table - __PAGE_OFFSET + GDT_ENTRY_KERNEL_DS * 8 + 4)
+	movl $((((__PAGE_OFFSET-1) & 0xf0000000) >> 12) | 0x00c0f300),%eax
+	movl %eax,(cpu_gdt_table - __PAGE_OFFSET + GDT_ENTRY_DEFAULT_USER_DS * 8 + 4)
+1:
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl $ __KERNEL_TEXT_OFFSET,%eax
+	movw %ax,(cpu_gdt_table - __PAGE_OFFSET + __KERNEL_CS + 2)
+	rorl $16,%eax
+	movb %al,(cpu_gdt_table - __PAGE_OFFSET + __KERNEL_CS + 4)
+	movb %ah,(cpu_gdt_table - __PAGE_OFFSET + __KERNEL_CS + 7)
+
+	movb %al,(boot_gdt_table - __PAGE_OFFSET + __BOOT_CS + 4)
+	movb %ah,(boot_gdt_table - __PAGE_OFFSET + __BOOT_CS + 7)
+	rorl $16,%eax
+	movw %ax,(boot_gdt_table - __PAGE_OFFSET + __BOOT_CS + 2)
+#endif
+
 /*
  * Clear BSS first so that there are no surprises...
  * No need to cld as DF is already clear from cld above...
@@ -119,24 +159,42 @@ ENTRY(startup_32)
  * Warning: don't use %esi or the stack in this code.  However, %esp
  * can be used as a GPR if you really need it...
  */
-page_pde_offset = (__PAGE_OFFSET >> 20);
-
+#ifdef CONFIG_X86_PAE
+page_pde_offset = ((__PAGE_OFFSET >> 21) * (4096 / PTRS_PER_PTE_asm));
+#else
+page_pde_offset = ((__PAGE_OFFSET >> 22) * (4096 / PTRS_PER_PTE_asm));
+#endif
 	movl $(pg0 - __PAGE_OFFSET), %edi
+#ifdef CONFIG_X86_PAE
+	movl $(swapper_pm_dir - __PAGE_OFFSET), %edx
+#else
 	movl $(swapper_pg_dir - __PAGE_OFFSET), %edx
-	movl $0x007, %eax			/* 0x007 = PRESENT+RW+USER */
+#endif
+	movl $0x063, %eax			/* 0x063 = DIRTY+ACCESSED+PRESENT+RW */
 10:
-	leal 0x007(%edi),%ecx			/* Create PDE entry */
+	leal 0x063(%edi),%ecx			/* Create PDE entry */
 	movl %ecx,(%edx)			/* Store identity PDE entry */
 	movl %ecx,page_pde_offset(%edx)		/* Store kernel PDE entry */
+#ifdef CONFIG_X86_PAE
+	movl $0,4(%edx)
+	movl $0,page_pde_offset+4(%edx)
+	addl $8,%edx
+	movl $512, %ecx
+#else
 	addl $4,%edx
 	movl $1024, %ecx
+#endif
 11:
 	stosl
+#ifdef CONFIG_X86_PAE
+	movl $0,(%edi)
+	addl $4,%edi
+#endif
 	addl $0x1000,%eax
 	loop 11b
 	/* End condition: we must map up to and including INIT_MAP_BEYOND_END */
-	/* bytes beyond the end of our own page tables; the +0x007 is the attribute bits */
-	leal (INIT_MAP_BEYOND_END+0x007)(%edi),%ebp
+	/* bytes beyond the end of our own page tables; the +0x063 is the attribute bits */
+	leal (INIT_MAP_BEYOND_END+0x063)(%edi),%ebp
 	cmpl %ebp,%eax
 	jb 10b
 	movl %edi,(init_pg_tables_end - __PAGE_OFFSET)
@@ -159,6 +217,11 @@ ENTRY(startup_32_smp)
 	movl %eax,%fs
 	movl %eax,%gs
 
+	/* This is a secondary processor (AP) */
+	xorl %ebx,%ebx
+	incl %ebx
+#endif /* CONFIG_SMP */
+
 /*
  *	New page tables may be in 4Mbyte page mode and may
  *	be using the global pages. 
@@ -174,26 +237,27 @@ ENTRY(startup_32_smp)
  *	not yet offset PAGE_OFFSET..
  */
 #define cr4_bits mmu_cr4_features-__PAGE_OFFSET
+3:
 	movl cr4_bits,%edx
 	andl %edx,%edx
-	jz 6f
+	jz 5f
 	movl %cr4,%eax		# Turn on paging options (PSE,PAE,..)
 	orl %edx,%eax
 	movl %eax,%cr4
 
-	btl $5, %eax		# check if PAE is enabled
-	jnc 6f
+#ifdef CONFIG_X86_PAE
+	movl %ebx,%edi
 
 	/* Check if extended functions are implemented */
 	movl $0x80000000, %eax
 	cpuid
 	cmpl $0x80000000, %eax
-	jbe 6f
+	jbe 4f
 	mov $0x80000001, %eax
 	cpuid
 	/* Execute Disable bit supported? */
 	btl $20, %edx
-	jnc 6f
+	jnc 4f
 
 	/* Setup EFER (Extended Feature Enable Register) */
 	movl $0xc0000080, %ecx
@@ -202,14 +266,13 @@ ENTRY(startup_32_smp)
 	btsl $11, %eax
 	/* Make changes effective */
 	wrmsr
+	btsl $63,__supported_pte_mask-__PAGE_OFFSET
+	movl $1,nx_enabled-__PAGE_OFFSET
 
-6:
-	/* This is a secondary processor (AP) */
-	xorl %ebx,%ebx
-	incl %ebx
-
-3:
-#endif /* CONFIG_SMP */
+4:
+	movl %edi,%ebx
+#endif
+5:
 
 /*
  * Enable paging
@@ -234,9 +297,7 @@ ENTRY(startup_32_smp)
 
 #ifdef CONFIG_SMP
 	andl %ebx,%ebx
-	jz  1f				/* Initial CPU cleans BSS */
-	jmp checkCPUtype
-1:
+	jnz checkCPUtype	/* Initial CPU cleans BSS */
 #endif /* CONFIG_SMP */
 
 /*
@@ -314,8 +375,6 @@ is386:	movl $2,%ecx		# set MP
 	ljmp $(__KERNEL_CS),$1f
 1:	movl $(__KERNEL_DS),%eax	# reload all the segment registers
 	movl %eax,%ss			# after changing gdt.
-
-	movl $(__USER_DS),%eax		# DS/ES contains default USER segment
 	movl %eax,%ds
 	movl %eax,%es
 
@@ -460,8 +519,8 @@ hlt_loop:
 /* This is the default interrupt "handler" :-) */
 	ALIGN
 ignore_int:
-	cld
 #ifdef CONFIG_PRINTK
+	cld
 	pushl %eax
 	pushl %ecx
 	pushl %edx
@@ -495,7 +554,7 @@ ignore_int:
 #ifdef CONFIG_PARAVIRT
 startup_paravirt:
 	cld
- 	movl $(init_thread_union+THREAD_SIZE),%esp
+	movl $(init_thread_union+THREAD_SIZE-8),%esp
 
 	/* We take pains to preserve all the regs. */
 	pushl	%edx
@@ -519,30 +578,52 @@ startup_paravirt:
 	jmp	1b
 #endif
 
-/*
- * Real beginning of normal "text" segment
- */
-ENTRY(stext)
-ENTRY(_stext)
-
-/*
- * BSS section
- */
-.section ".bss.page_aligned","w"
+.section .swapper_pg_dir,"a",@progbits
 ENTRY(swapper_pg_dir)
+#ifdef CONFIG_X86_PAE
+	.long swapper_pm_dir-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*8-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*16-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*24-__PAGE_OFFSET+1
+	.long 0
+#else
 	.fill 1024,4,0
+#endif
+
+#ifdef CONFIG_X86_PAE
+.section .swapper_pm_dir,"a",@progbits
+ENTRY(swapper_pm_dir)
+	.fill 512,8,0
+	.fill 512,8,0
+	.fill 512,8,0
+	.fill 512,8,0
+#endif
+
+.section .empty_zero_page,"a",@progbits
 ENTRY(empty_zero_page)
 	.fill 4096,1,0
 
 /*
- * This starts the data section.
- */
-.data
+ * The IDT has to be page-aligned to simplify the Pentium
+ * F0 0F bug workaround.. We have a special link segment
+ * for this.
+ */
+.section .idt,"a",@progbits
+ENTRY(idt_table)
+	.fill 256,8,0
+
+.section .rodata,"a",@progbits
 ENTRY(start_pda)
 	.long boot_pda
 
+ENTRY(__cpu_pda)
+	.fill PDA_size,1,0
+
 ENTRY(stack_start)
-	.long init_thread_union+THREAD_SIZE
+	.long init_thread_union+THREAD_SIZE-8
 	.long __BOOT_DS
 
 ready:	.byte 0
@@ -585,6 +666,8 @@ ENTRY(cpu_gdt_descr)
 	.word GDT_ENTRIES*8-1
 	.long cpu_gdt_table
 
+	.fill NR_CPUS*8-6,1,0		# space for the other GDT descriptors
+
 /*
  * The boot_gdt_table must mirror the equivalent in setup.S and is
  * used only for booting.
@@ -592,13 +675,13 @@ ENTRY(cpu_gdt_descr)
 	.align L1_CACHE_BYTES
 ENTRY(boot_gdt_table)
 	.fill GDT_ENTRY_BOOT_CS,8,0
-	.quad 0x00cf9a000000ffff	/* kernel 4GB code at 0x00000000 */
-	.quad 0x00cf92000000ffff	/* kernel 4GB data at 0x00000000 */
+	.quad 0x00cf9b000000ffff	/* kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* kernel 4GB data at 0x00000000 */
 
 /*
  * The Global Descriptor Table contains 28 quadwords, per-CPU.
  */
-	.align L1_CACHE_BYTES
+	.align PAGE_SIZE_asm
 ENTRY(cpu_gdt_table)
 	.quad 0x0000000000000000	/* NULL descriptor */
 	.quad 0x0000000000000000	/* 0x0b reserved */
@@ -613,10 +696,10 @@ ENTRY(cpu_gdt_table)
 	.quad 0x0000000000000000	/* 0x53 reserved */
 	.quad 0x0000000000000000	/* 0x5b reserved */
 
-	.quad 0x00cf9a000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
-	.quad 0x00cf92000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
-	.quad 0x00cffa000000ffff	/* 0x73 user 4GB code at 0x00000000 */
-	.quad 0x00cff2000000ffff	/* 0x7b user 4GB data at 0x00000000 */
+	.quad 0x00cf9b000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
+	.quad 0x00cffb000000ffff	/* 0x73 user 4GB code at 0x00000000 */
+	.quad 0x00cff3000000ffff	/* 0x7b user 4GB data at 0x00000000 */
 
 	.quad 0x0000000000000000	/* 0x80 TSS descriptor */
 	.quad 0x0000000000000000	/* 0x88 LDT descriptor */
@@ -626,24 +709,30 @@ ENTRY(cpu_gdt_table)
 	 * They code segments and data segments have fixed 64k limits,
 	 * the transfer segment sizes are set at run time.
 	 */
-	.quad 0x00409a000000ffff	/* 0x90 32-bit code */
-	.quad 0x00009a000000ffff	/* 0x98 16-bit code */
-	.quad 0x000092000000ffff	/* 0xa0 16-bit data */
-	.quad 0x0000920000000000	/* 0xa8 16-bit data */
-	.quad 0x0000920000000000	/* 0xb0 16-bit data */
+	.quad 0x00409b000000ffff	/* 0x90 32-bit code */
+	.quad 0x00009b000000ffff	/* 0x98 16-bit code */
+	.quad 0x000093000000ffff	/* 0xa0 16-bit data */
+	.quad 0x0000930000000000	/* 0xa8 16-bit data */
+	.quad 0x0000930000000000	/* 0xb0 16-bit data */
 
 	/*
 	 * The APM segments have byte granularity and their bases
 	 * are set at run time.  All have 64k limits.
 	 */
-	.quad 0x00409a000000ffff	/* 0xb8 APM CS    code */
-	.quad 0x00009a000000ffff	/* 0xc0 APM CS 16 code (16 bit) */
-	.quad 0x004092000000ffff	/* 0xc8 APM DS    data */
+	.quad 0x00409b000000ffff	/* 0xb8 APM CS    code */
+	.quad 0x00009b000000ffff	/* 0xc0 APM CS 16 code (16 bit) */
+	.quad 0x004093000000ffff	/* 0xc8 APM DS    data */
 
-	.quad 0x00c0920000000000	/* 0xd0 - ESPFIX SS */
-	.quad 0x00cf92000000ffff	/* 0xd8 - PDA */
+	.quad 0x00c0930000000000	/* 0xd0 - ESPFIX SS */
+	.quad 0x00c093000000ffff	/* 0xd8 - PDA */
 	.quad 0x0000000000000000	/* 0xe0 - unused */
 	.quad 0x0000000000000000	/* 0xe8 - unused */
 	.quad 0x0000000000000000	/* 0xf0 - unused */
 	.quad 0x0000000000000000	/* 0xf8 - GDT entry 31: double-fault TSS */
 
+	/* Be sure this is zeroed to avoid false validations in Xen */
+	.fill PAGE_SIZE_asm / 8 - GDT_ENTRIES,8,0
+
+#ifdef CONFIG_SMP
+	.fill (NR_CPUS-1) * (PAGE_SIZE_asm / 8),8,0 /* other CPU's GDT */
+#endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/i386_ksyms.c linux-2.6.20.1-pax/arch/i386/kernel/i386_ksyms.c
--- linux-2.6.20.1/arch/i386/kernel/i386_ksyms.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/i386_ksyms.c	2007-02-05 00:56:18.000000000 +0100
@@ -2,12 +2,16 @@
 #include <asm/checksum.h>
 #include <asm/desc.h>
 
+EXPORT_SYMBOL_GPL(cpu_gdt_table);
+
 EXPORT_SYMBOL(__down_failed);
 EXPORT_SYMBOL(__down_failed_interruptible);
 EXPORT_SYMBOL(__down_failed_trylock);
 EXPORT_SYMBOL(__up_wakeup);
 /* Networking helper routines. */
 EXPORT_SYMBOL(csum_partial_copy_generic);
+EXPORT_SYMBOL(csum_partial_copy_generic_to_user);
+EXPORT_SYMBOL(csum_partial_copy_generic_from_user);
 
 EXPORT_SYMBOL(__get_user_1);
 EXPORT_SYMBOL(__get_user_2);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/i8259.c linux-2.6.20.1-pax/arch/i386/kernel/i8259.c
--- linux-2.6.20.1/arch/i386/kernel/i8259.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/i8259.c	2007-02-15 01:41:52.000000000 +0100
@@ -350,7 +350,7 @@ static irqreturn_t math_error_irq(int cp
  * New motherboards sometimes make IRQ 13 be a PCI interrupt,
  * so allow interrupt sharing.
  */
-static struct irqaction fpu_irq = { math_error_irq, 0, CPU_MASK_NONE, "fpu", NULL, NULL };
+static struct irqaction fpu_irq = { math_error_irq, 0, CPU_MASK_NONE, "fpu", NULL, NULL, 0, NULL };
 
 void __init init_ISA_irqs (void)
 {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/init_task.c linux-2.6.20.1-pax/arch/i386/kernel/init_task.c
--- linux-2.6.20.1/arch/i386/kernel/init_task.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/init_task.c	2007-02-05 00:56:18.000000000 +0100
@@ -42,5 +42,5 @@ EXPORT_SYMBOL(init_task);
  * per-CPU TSS segments. Threads are completely 'soft' on Linux,
  * no more per-task TSS's.
  */ 
-DEFINE_PER_CPU(struct tss_struct, init_tss) ____cacheline_internodealigned_in_smp = INIT_TSS;
+struct tss_struct init_tss[NR_CPUS] ____cacheline_internodealigned_in_smp = { [0 ... NR_CPUS-1] = INIT_TSS };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/io_apic.c linux-2.6.20.1-pax/arch/i386/kernel/io_apic.c
--- linux-2.6.20.1/arch/i386/kernel/io_apic.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/io_apic.c	2007-02-05 00:56:18.000000000 +0100
@@ -357,8 +357,8 @@ static void set_ioapic_affinity_irq(unsi
 #  define TDprintk(x...) do { printk("<%ld:%s:%d>: ", jiffies, __FILE__, __LINE__); printk(x); } while (0)
 #  define Dprintk(x...) do { TDprintk(x); } while (0)
 # else
-#  define TDprintk(x...) 
-#  define Dprintk(x...) 
+#  define TDprintk(x...) do {} while (0)
+#  define Dprintk(x...) do {} while (0)
 # endif
 
 #define IRQBALANCE_CHECK_ARCH -999
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/ioport.c linux-2.6.20.1-pax/arch/i386/kernel/ioport.c
--- linux-2.6.20.1/arch/i386/kernel/ioport.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/ioport.c	2007-02-05 00:56:18.000000000 +0100
@@ -89,7 +89,7 @@ asmlinkage long sys_ioperm(unsigned long
 	 * because the ->io_bitmap_max value must match the bitmap
 	 * contents:
 	 */
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 
 	set_bitmap(t->io_bitmap_ptr, from, num, !turn_on);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/irq.c linux-2.6.20.1-pax/arch/i386/kernel/irq.c
--- linux-2.6.20.1/arch/i386/kernel/irq.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/irq.c	2007-02-05 00:56:18.000000000 +0100
@@ -100,7 +100,7 @@ fastcall unsigned int do_IRQ(struct pt_r
 		int arg1, arg2, ebx;
 
 		/* build the stack frame on the IRQ stack */
-		isp = (u32*) ((char*)irqctx + sizeof(*irqctx));
+		isp = (u32*) ((char*)irqctx + sizeof(*irqctx)) - 2;
 		irqctx->tinfo.task = curctx->tinfo.task;
 		irqctx->tinfo.previous_esp = current_stack_pointer;
 
@@ -137,10 +137,10 @@ fastcall unsigned int do_IRQ(struct pt_r
  * gcc's 3.0 and earlier don't handle that correctly.
  */
 static char softirq_stack[NR_CPUS * THREAD_SIZE]
-		__attribute__((__aligned__(THREAD_SIZE)));
+		__attribute__((__aligned__(THREAD_SIZE), __section__(".bss.page_aligned")));
 
 static char hardirq_stack[NR_CPUS * THREAD_SIZE]
-		__attribute__((__aligned__(THREAD_SIZE)));
+		__attribute__((__aligned__(THREAD_SIZE), __section__(".bss.page_aligned")));
 
 /*
  * allocate per-cpu stacks for hardirq and for softirq processing
@@ -200,7 +200,7 @@ asmlinkage void do_softirq(void)
 		irqctx->tinfo.previous_esp = current_stack_pointer;
 
 		/* build the stack frame on the softirq stack */
-		isp = (u32*) ((char*)irqctx + sizeof(*irqctx));
+		isp = (u32*) ((char*)irqctx + sizeof(*irqctx)) - 2;
 
 		asm volatile(
 			"       xchgl   %%ebx,%%esp     \n"
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/kprobes.c linux-2.6.20.1-pax/arch/i386/kernel/kprobes.c
--- linux-2.6.20.1/arch/i386/kernel/kprobes.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/kprobes.c	2007-02-05 00:56:18.000000000 +0100
@@ -661,7 +661,7 @@ int __kprobes kprobe_exceptions_notify(s
 	struct die_args *args = (struct die_args *)data;
 	int ret = NOTIFY_DONE;
 
-	if (args->regs && user_mode_vm(args->regs))
+	if (args->regs && user_mode(args->regs))
 		return ret;
 
 	switch (val) {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/ldt.c linux-2.6.20.1-pax/arch/i386/kernel/ldt.c
--- linux-2.6.20.1/arch/i386/kernel/ldt.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/ldt.c	2007-02-05 00:56:18.000000000 +0100
@@ -20,6 +20,9 @@
 #include <asm/desc.h>
 #include <asm/mmu_context.h>
 
+const struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
+		{ 0, 0 }, { 0, 0 } };
+
 #ifdef CONFIG_SMP /* avoids "defined but not used" warnig */
 static void flush_ldt(void *null)
 {
@@ -103,6 +106,22 @@ int init_new_context(struct task_struct 
 		retval = copy_ldt(&mm->context, &old_mm->context);
 		up(&old_mm->context.sem);
 	}
+
+	if (tsk == current) {
+		mm->context.vdso = ~0UL;
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		mm->context.user_cs_base = 0UL;
+		mm->context.user_cs_limit = ~0UL;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+		cpus_clear(mm->context.cpu_user_cs_mask);
+#endif
+
+#endif
+
+	}
+
 	return retval;
 }
 
@@ -213,6 +232,13 @@ static int write_ldt(void __user * ptr, 
 		}
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (ldt_info.contents & MODIFY_LDT_CONTENTS_CODE)) {
+		error = -EINVAL;
+		goto out_unlock;
+	}
+#endif
+
 	entry_1 = LDT_entry_a(&ldt_info);
 	entry_2 = LDT_entry_b(&ldt_info);
 	if (oldmode)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/machine_kexec.c linux-2.6.20.1-pax/arch/i386/kernel/machine_kexec.c
--- linux-2.6.20.1/arch/i386/kernel/machine_kexec.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/machine_kexec.c	2007-02-15 02:21:54.000000000 +0100
@@ -29,25 +29,25 @@ static u32 kexec_pmd1[1024] PAGE_ALIGNED
 static u32 kexec_pte0[1024] PAGE_ALIGNED;
 static u32 kexec_pte1[1024] PAGE_ALIGNED;
 
-static void set_idt(void *newidt, __u16 limit)
+static void set_idt(struct desc_struct *newidt, __u16 limit)
 {
 	struct Xgt_desc_struct curidt;
 
 	/* ia32 supports unaliged loads & stores */
 	curidt.size    = limit;
-	curidt.address = (unsigned long)newidt;
+	curidt.address = newidt;
 
 	load_idt(&curidt);
 };
 
 
-static void set_gdt(void *newgdt, __u16 limit)
+static void set_gdt(struct desc_struct *newgdt, __u16 limit)
 {
 	struct Xgt_desc_struct curgdt;
 
 	/* ia32 supports unaligned loads & stores */
 	curgdt.size    = limit;
-	curgdt.address = (unsigned long)newgdt;
+	curgdt.address = newgdt;
 
 	load_gdt(&curgdt);
 };
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/module.c linux-2.6.20.1-pax/arch/i386/kernel/module.c
--- linux-2.6.20.1/arch/i386/kernel/module.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/module.c	2007-02-05 00:56:18.000000000 +0100
@@ -23,6 +23,8 @@
 #include <linux/kernel.h>
 #include <linux/bug.h>
 
+#include <asm/desc.h>
+
 #if 0
 #define DEBUGP printk
 #else
@@ -33,9 +35,30 @@ void *module_alloc(unsigned long size)
 {
 	if (size == 0)
 		return NULL;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	return vmalloc(size);
+#else
 	return vmalloc_exec(size);
+#endif
+
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+void *module_alloc_exec(unsigned long size)
+{
+	struct vm_struct *area;
+
+	if (size == 0)
+		return NULL;
+
+	area = __get_vm_area(size, 0, (unsigned long)&MODULES_VADDR, (unsigned long)&MODULES_END);
+	if (area)
+		return area->addr;
+
+	return NULL;
+}
+#endif
 
 /* Free memory returned from module_alloc */
 void module_free(struct module *mod, void *module_region)
@@ -45,6 +68,45 @@ void module_free(struct module *mod, voi
            table entries. */
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+void module_free_exec(struct module *mod, void *module_region)
+{
+	struct vm_struct **p, *tmp;
+
+	if (!module_region)
+		return;
+
+	if ((PAGE_SIZE-1) & (unsigned long)module_region) {
+		printk(KERN_ERR "Trying to module_free_exec() bad address (%p)\n", module_region);
+		WARN_ON(1);
+		return;
+	}
+
+	write_lock(&vmlist_lock);
+	for (p = &vmlist ; (tmp = *p) != NULL ;p = &tmp->next)
+		 if (tmp->addr == module_region)
+			break;
+
+	if (tmp) {
+		unsigned long cr0;
+
+		pax_open_kernel(cr0);
+		memset(tmp->addr, 0xCC, tmp->size);
+		pax_close_kernel(cr0);
+
+		*p = tmp->next;
+		kfree(tmp);
+	}
+	write_unlock(&vmlist_lock);
+
+	if (!tmp) {
+		printk(KERN_ERR "Trying to module_free_exec() nonexistent vm area (%p)\n",
+				module_region);
+		WARN_ON(1);
+	}
+}
+#endif
+
 /* We don't need anything special. */
 int module_frob_arch_sections(Elf_Ehdr *hdr,
 			      Elf_Shdr *sechdrs,
@@ -63,14 +125,16 @@ int apply_relocate(Elf32_Shdr *sechdrs,
 	unsigned int i;
 	Elf32_Rel *rel = (void *)sechdrs[relsec].sh_addr;
 	Elf32_Sym *sym;
-	uint32_t *location;
+	uint32_t *plocation, location;
 
 	DEBUGP("Applying relocate section %u to %u\n", relsec,
 	       sechdrs[relsec].sh_info);
 	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
 		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
+		plocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;
+		location = (uint32_t)plocation;
+		if (sechdrs[sechdrs[relsec].sh_info].sh_flags & SHF_EXECINSTR)
+			plocation = (void *)plocation + __KERNEL_TEXT_OFFSET;
 		/* This is the symbol it is referring to.  Note that all
 		   undefined symbols have been resolved.  */
 		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
@@ -79,11 +143,11 @@ int apply_relocate(Elf32_Shdr *sechdrs,
 		switch (ELF32_R_TYPE(rel[i].r_info)) {
 		case R_386_32:
 			/* We add the value into the location given */
-			*location += sym->st_value;
+			*plocation += sym->st_value;
 			break;
 		case R_386_PC32:
 			/* Add the value, subtract its postition */
-			*location += sym->st_value - (uint32_t)location;
+			*plocation += sym->st_value - location;
 			break;
 		default:
 			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/paravirt.c linux-2.6.20.1-pax/arch/i386/kernel/paravirt.c
--- linux-2.6.20.1/arch/i386/kernel/paravirt.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/paravirt.c	2007-02-18 21:41:04.000000000 +0100
@@ -88,7 +88,7 @@ static unsigned native_patch(u8 type, u1
 	if (len < insn_len)
 		return len;
 
-	memcpy(insns, native_insns[type].start, insn_len);
+	memcpy(insns, native_insns[type].start + __KERNEL_TEXT_OFFSET, insn_len);
 	return insn_len;
 }
 
@@ -336,16 +336,40 @@ static fastcall unsigned long native_sto
 
 static fastcall void native_load_tls(struct thread_struct *t, unsigned int cpu)
 {
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 #define C(i) get_cpu_gdt_table(cpu)[GDT_ENTRY_TLS_MIN + i] = t->tls_array[i]
 	C(0); C(1); C(2);
 #undef C
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 static inline void native_write_dt_entry(void *dt, int entry, u32 entry_low, u32 entry_high)
 {
 	u32 *lp = (u32 *)((char *)dt + entry*8);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	lp[0] = entry_low;
 	lp[1] = entry_high;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 static fastcall void native_write_ldt_entry(void *dt, int entrynum, u32 low, u32 high)
@@ -485,7 +509,7 @@ core_initcall(print_banner);
 /* We simply declare start_kernel to be the paravirt probe of last resort. */
 paravirt_probe(start_kernel);
 
-struct paravirt_ops paravirt_ops = {
+const struct paravirt_ops paravirt_ops = {
 	.name = "bare hardware",
 	.paravirt_enabled = 0,
 	.kernel_rpl = 0,
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/process.c linux-2.6.20.1-pax/arch/i386/kernel/process.c
--- linux-2.6.20.1/arch/i386/kernel/process.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/process.c	2007-02-18 22:17:37.000000000 +0100
@@ -70,7 +70,7 @@ EXPORT_SYMBOL(boot_option_idle_override)
  */
 unsigned long thread_saved_pc(struct task_struct *tsk)
 {
-	return ((unsigned long *)tsk->thread.esp)[3];
+	return tsk->thread.eip;
 }
 
 /*
@@ -298,7 +298,7 @@ void show_regs(struct pt_regs * regs)
 	printk("EIP: %04x:[<%08lx>] CPU: %d\n",0xffff & regs->xcs,regs->eip, smp_processor_id());
 	print_symbol("EIP is at %s\n", regs->eip);
 
-	if (user_mode_vm(regs))
+	if (user_mode(regs))
 		printk(" ESP: %04x:%08lx",0xffff & regs->xss,regs->esp);
 	printk(" EFLAGS: %08lx    %s  (%s %.*s)\n",
 	       regs->eflags, print_tainted(), init_utsname()->release,
@@ -338,8 +338,8 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.ebx = (unsigned long) fn;
 	regs.edx = (unsigned long) arg;
 
-	regs.xds = __USER_DS;
-	regs.xes = __USER_DS;
+	regs.xds = __KERNEL_DS;
+	regs.xes = __KERNEL_DS;
 	regs.xgs = __KERNEL_PDA;
 	regs.orig_eax = -1;
 	regs.eip = (unsigned long) kernel_thread_helper;
@@ -361,7 +361,7 @@ void exit_thread(void)
 		struct task_struct *tsk = current;
 		struct thread_struct *t = &tsk->thread;
 		int cpu = get_cpu();
-		struct tss_struct *tss = &per_cpu(init_tss, cpu);
+		struct tss_struct *tss = init_tss + cpu;
 
 		kfree(t->io_bitmap_ptr);
 		t->io_bitmap_ptr = NULL;
@@ -382,6 +382,7 @@ void flush_thread(void)
 {
 	struct task_struct *tsk = current;
 
+	__asm__("mov %0,%%fs\n" : : "r" (0) : "memory");
 	memset(tsk->thread.debugreg, 0, sizeof(unsigned long)*8);
 	memset(tsk->thread.tls_array, 0, sizeof(tsk->thread.tls_array));	
 	clear_tsk_thread_flag(tsk, TIF_DEBUG);
@@ -415,7 +416,7 @@ int copy_thread(int nr, unsigned long cl
 	struct task_struct *tsk;
 	int err;
 
-	childregs = task_pt_regs(p);
+	childregs = task_stack_page(p) + THREAD_SIZE - sizeof(struct pt_regs) - 8;
 	*childregs = *regs;
 	childregs->eax = 0;
 	childregs->esp = esp;
@@ -457,6 +458,11 @@ int copy_thread(int nr, unsigned long cl
 		if (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)
 			goto out;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && (info.contents & MODIFY_LDT_CONTENTS_CODE))
+			goto out;
+#endif
+
 		desc = p->thread.tls_array + idx - GDT_ENTRY_TLS_MIN;
 		desc->a = LDT_entry_a(&info);
 		desc->b = LDT_entry_b(&info);
@@ -636,7 +642,7 @@ struct task_struct fastcall * __switch_t
 	struct thread_struct *prev = &prev_p->thread,
 				 *next = &next_p->thread;
 	int cpu = smp_processor_id();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 
 	/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */
 
@@ -664,6 +670,11 @@ struct task_struct fastcall * __switch_t
 	 */
 	savesegment(fs, prev->fs);
 
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	if (!segment_eq(prev_p->thread_info->addr_limit, next_p->thread_info->addr_limit))
+		__set_fs(next_p->thread_info->addr_limit, cpu);
+#endif
+
 	/*
 	 * Load the per-thread Thread-Local Storage descriptor.
 	 */
@@ -814,6 +825,12 @@ asmlinkage int sys_set_thread_area(struc
 
 	if (copy_from_user(&info, u_info, sizeof(info)))
 		return -EFAULT;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && (info.contents & MODIFY_LDT_CONTENTS_CODE))
+		return -EINVAL;
+#endif
+
 	idx = info.entry_number;
 
 	/*
@@ -902,9 +919,27 @@ asmlinkage int sys_get_thread_area(struc
 	return 0;
 }
 
-unsigned long arch_align_stack(unsigned long sp)
+#ifdef CONFIG_PAX_RANDKSTACK
+asmlinkage void pax_randomize_kstack(void)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() % 8192;
-	return sp & ~0xf;
+	struct tss_struct *tss = init_tss + smp_processor_id();
+	unsigned long time;
+
+	if (!randomize_va_space)
+		return;
+
+	rdtscl(time);
+
+	/* P4 seems to return a 0 LSB, ignore it */
+#ifdef CONFIG_MPENTIUM4
+	time &= 0x1EUL;
+	time <<= 2;
+#else
+	time &= 0xFUL;
+	time <<= 3;
+#endif
+
+	tss->esp0 ^= time;
+	current->thread.esp0 = tss->esp0;
 }
+#endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/ptrace.c linux-2.6.20.1-pax/arch/i386/kernel/ptrace.c
--- linux-2.6.20.1/arch/i386/kernel/ptrace.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/ptrace.c	2007-02-05 00:56:18.000000000 +0100
@@ -162,15 +162,15 @@ static unsigned long convert_eip_to_line
 	 * and APM bios ones we just ignore here.
 	 */
 	if (seg & LDT_SEGMENT) {
-		u32 *desc;
+		struct desc_struct *desc;
 		unsigned long base;
 
 		down(&child->mm->context.sem);
-		desc = child->mm->context.ldt + (seg & ~7);
-		base = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);
+		desc = &child->mm->context.ldt[seg >> 3];
+		base = (desc->a >> 16) | ((desc->b & 0xff) << 16) | (desc->b & 0xff000000);
 
 		/* 16-bit code segment? */
-		if (!((desc[1] >> 22) & 1))
+		if (!((desc->b >> 22) & 1))
 			addr &= 0xffff;
 		addr += base;
 		up(&child->mm->context.sem);
@@ -335,6 +335,11 @@ ptrace_set_thread_area(struct task_struc
 	if (copy_from_user(&info, user_desc, sizeof(info)))
 		return -EFAULT;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((child->mm->pax_flags & MF_PAX_SEGMEXEC) && (info.contents & MODIFY_LDT_CONTENTS_CODE))
+		return -EINVAL;
+#endif
+
 	if (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)
 		return -EINVAL;
 
@@ -641,7 +646,7 @@ void send_sigtrap(struct task_struct *ts
 	info.si_code = TRAP_BRKPT;
 
 	/* User-mode eip? */
-	info.si_addr = user_mode_vm(regs) ? (void __user *) regs->eip : NULL;
+	info.si_addr = user_mode(regs) ? (void __user *) regs->eip : NULL;
 
 	/* Send us the fakey SIGTRAP */
 	force_sig_info(SIGTRAP, &info, tsk);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/reboot.c linux-2.6.20.1-pax/arch/i386/kernel/reboot.c
--- linux-2.6.20.1/arch/i386/kernel/reboot.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/reboot.c	2007-02-15 02:06:11.000000000 +0100
@@ -25,7 +25,7 @@
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
-static int reboot_mode;
+static unsigned short reboot_mode;
 static int reboot_thru_bios;
 
 #ifdef CONFIG_SMP
@@ -120,7 +120,7 @@ static struct dmi_system_id __initdata r
 			DMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {{0, NULL}}, NULL}
 };
 
 static int __init reboot_init(void)
@@ -138,18 +138,18 @@ core_initcall(reboot_init);
    doesn't work with at least one type of 486 motherboard.  It is easy
    to stop this code working; hence the copious comments. */
 
-static unsigned long long
+static const struct desc_struct
 real_mode_gdt_entries [3] =
 {
-	0x0000000000000000ULL,	/* Null descriptor */
-	0x00009a000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
-	0x000092000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
+	{0x00000000, 0x00000000},	/* Null descriptor */
+	{0x0000ffff, 0x00009b00},	/* 16-bit real-mode 64k code at 0x00000000 */
+	{0x0100ffff, 0x00009300}	/* 16-bit real-mode 64k data at 0x00000100 */
 };
 
-static struct Xgt_desc_struct
-real_mode_gdt = { sizeof (real_mode_gdt_entries) - 1, (long)real_mode_gdt_entries },
-real_mode_idt = { 0x3ff, 0 },
-no_idt = { 0, 0 };
+static const struct Xgt_desc_struct
+real_mode_gdt = { sizeof (real_mode_gdt_entries) - 1, real_mode_gdt_entries, 0 },
+real_mode_idt = { 0x3ff, NULL, 0 },
+no_idt = { 0, NULL, 0 };
 
 
 /* This is 16-bit protected mode code to disable paging and the cache,
@@ -171,7 +171,7 @@ no_idt = { 0, 0 };
    More could be done here to set up the registers as if a CPU reset had
    occurred; hopefully real BIOSs don't assume much. */
 
-static unsigned char real_mode_switch [] =
+static const unsigned char real_mode_switch [] =
 {
 	0x66, 0x0f, 0x20, 0xc0,			/*    movl  %cr0,%eax        */
 	0x66, 0x83, 0xe0, 0x11,			/*    andl  $0x00000011,%eax */
@@ -185,7 +185,7 @@ static unsigned char real_mode_switch []
 	0x24, 0x10,				/* f: andb  $0x10,al         */
 	0x66, 0x0f, 0x22, 0xc0			/*    movl  %eax,%cr0        */
 };
-static unsigned char jump_to_bios [] =
+static const unsigned char jump_to_bios [] =
 {
 	0xea, 0x00, 0x00, 0xff, 0xff		/*    ljmp  $0xffff,$0x0000  */
 };
@@ -195,10 +195,14 @@ static unsigned char jump_to_bios [] =
  * specified by the code and length parameters.
  * We assume that length will aways be less that 100!
  */
-void machine_real_restart(unsigned char *code, int length)
+void machine_real_restart(const unsigned char *code, unsigned int length)
 {
 	unsigned long flags;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	local_irq_disable();
 
 	/* Write zero to CMOS register number 0x0f, which the BIOS POST
@@ -219,8 +223,16 @@ void machine_real_restart(unsigned char 
 	   from the kernel segment.  This assumes the kernel segment starts at
 	   virtual address PAGE_OFFSET. */
 
-	memcpy (swapper_pg_dir, swapper_pg_dir + USER_PGD_PTRS,
-		sizeof (swapper_pg_dir [0]) * KERNEL_PGD_PTRS);
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	clone_pgd_range(swapper_pg_dir, swapper_pg_dir + USER_PGD_PTRS,
+			min_t(unsigned long, KERNEL_PGD_PTRS, USER_PGD_PTRS));
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
 
 	/*
 	 * Use `swapper_pg_dir' as our page directory.
@@ -233,7 +245,7 @@ void machine_real_restart(unsigned char 
 	   REBOOT.COM programs, and the previous reset routine did this
 	   too. */
 
-	*((unsigned short *)0x472) = reboot_mode;
+	__put_user(reboot_mode, (unsigned short __user *)0x472);
 
 	/* For the switch to real mode, copy some code to low memory.  It has
 	   to be in the first 64k because it is running in 16-bit mode, and it
@@ -241,9 +253,9 @@ void machine_real_restart(unsigned char 
 	   off paging.  Copy it near the end of the first page, out of the way
 	   of BIOS variables. */
 
-	memcpy ((void *) (0x1000 - sizeof (real_mode_switch) - 100),
+	flags = __copy_to_user ((void __user *) (0x1000 - sizeof (real_mode_switch) - 100),
 		real_mode_switch, sizeof (real_mode_switch));
-	memcpy ((void *) (0x1000 - 100), code, length);
+	flags = __copy_to_user ((void __user *) (0x1000 - 100), code, length);
 
 	/* Set up the IDT for real mode. */
 
@@ -325,7 +337,7 @@ void machine_emergency_restart(void)
 			__asm__ __volatile__("int3");
 		}
 		/* rebooting needs to touch the page at absolute addr 0 */
-		*((unsigned short *)__va(0x472)) = reboot_mode;
+		__put_user(reboot_mode, (unsigned short __user *)0x472);
 		for (;;) {
 			mach_reboot_fixups(); /* for board specific fixups */
 			mach_reboot();
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/setup.c linux-2.6.20.1-pax/arch/i386/kernel/setup.c
--- linux-2.6.20.1/arch/i386/kernel/setup.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/setup.c	2007-02-15 01:34:30.000000000 +0100
@@ -82,7 +82,11 @@ struct cpuinfo_x86 new_cpu_data __cpuini
 struct cpuinfo_x86 boot_cpu_data __read_mostly = { 0, 0, 0, 0, -1, 1, 0, 0, -1 };
 EXPORT_SYMBOL(boot_cpu_data);
 
+#ifdef CONFIG_X86_PAE
+unsigned long mmu_cr4_features = X86_CR4_PAE;
+#else
 unsigned long mmu_cr4_features;
+#endif
 
 /* for MCA, but anyone else can use it if they want */
 unsigned int machine_id;
@@ -404,8 +408,8 @@ void __init setup_bootmem_allocator(void
 	 * the (very unlikely) case of us accidentally initializing the
 	 * bootmem allocator with an invalid RAM area.
 	 */
-	reserve_bootmem(__pa_symbol(_text), (PFN_PHYS(min_low_pfn) +
-			 bootmap_size + PAGE_SIZE-1) - __pa_symbol(_text));
+	reserve_bootmem(LOAD_PHYSICAL_ADDR, (PFN_PHYS(min_low_pfn) +
+			 bootmap_size + PAGE_SIZE-1) - LOAD_PHYSICAL_ADDR);
 
 	/*
 	 * reserve physical page 0 - it's a special BIOS page on many boxes,
@@ -559,14 +563,14 @@ void __init setup_arch(char **cmdline_p)
 
 	if (!MOUNT_ROOT_RDONLY)
 		root_mountflags &= ~MS_RDONLY;
-	init_mm.start_code = (unsigned long) _text;
-	init_mm.end_code = (unsigned long) _etext;
+	init_mm.start_code = (unsigned long) _text + __KERNEL_TEXT_OFFSET;
+	init_mm.end_code = (unsigned long) _etext + __KERNEL_TEXT_OFFSET;
 	init_mm.end_data = (unsigned long) _edata;
 	init_mm.brk = init_pg_tables_end + PAGE_OFFSET;
 
-	code_resource.start = virt_to_phys(_text);
-	code_resource.end = virt_to_phys(_etext)-1;
-	data_resource.start = virt_to_phys(_etext);
+	code_resource.start = virt_to_phys(_text + __KERNEL_TEXT_OFFSET);
+	code_resource.end = virt_to_phys(_etext + __KERNEL_TEXT_OFFSET)-1;
+	data_resource.start = virt_to_phys(_data);
 	data_resource.end = virt_to_phys(_edata)-1;
 
 	parse_early_param();
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/signal.c linux-2.6.20.1-pax/arch/i386/kernel/signal.c
--- linux-2.6.20.1/arch/i386/kernel/signal.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/signal.c	2007-02-05 00:56:18.000000000 +0100
@@ -349,7 +349,7 @@ static int setup_frame(int sig, struct k
 			goto give_sigsegv;
 	}
 
-	restorer = (void *)VDSO_SYM(&__kernel_sigreturn);
+	restorer = (void __user *)VDSO_SYM(&__kernel_sigreturn);
 	if (ka->sa.sa_flags & SA_RESTORER)
 		restorer = ka->sa.sa_restorer;
 
@@ -445,7 +445,8 @@ static int setup_rt_frame(int sig, struc
 		goto give_sigsegv;
 
 	/* Set up to return from userspace.  */
-	restorer = (void *)VDSO_SYM(&__kernel_rt_sigreturn);
+
+	restorer = (void __user *)VDSO_SYM(&__kernel_rt_sigreturn);
 	if (ka->sa.sa_flags & SA_RESTORER)
 		restorer = ka->sa.sa_restorer;
 	err |= __put_user(restorer, &frame->pretcode);
@@ -578,7 +579,7 @@ static void fastcall do_signal(struct pt
  	 * before reaching here, so testing against kernel
  	 * CS suffices.
 	 */
-	if (!user_mode(regs))
+	if (!user_mode_novm(regs))
 		return;
 
 	if (test_thread_flag(TIF_RESTORE_SIGMASK))
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/smp.c linux-2.6.20.1-pax/arch/i386/kernel/smp.c
--- linux-2.6.20.1/arch/i386/kernel/smp.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/smp.c	2007-02-20 22:59:39.000000000 +0100
@@ -104,7 +104,7 @@
  *	about nothing of note with C stepping upwards.
  */
 
-DEFINE_PER_CPU(struct tlb_state, cpu_tlbstate) ____cacheline_aligned = { &init_mm, 0, };
+DEFINE_PER_CPU(struct tlb_state, cpu_tlbstate) ____cacheline_aligned = { &init_mm, 0, {0} };
 
 /*
  * the following functions deal with sending IPIs between CPUs.
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/smpboot.c linux-2.6.20.1-pax/arch/i386/kernel/smpboot.c
--- linux-2.6.20.1/arch/i386/kernel/smpboot.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/smpboot.c	2007-02-20 22:38:22.000000000 +0100
@@ -57,7 +57,6 @@
 #include <asm/desc.h>
 #include <asm/arch_hooks.h>
 #include <asm/nmi.h>
-#include <asm/pda.h>
 #include <asm/genapic.h>
 
 #include <mach_apic.h>
@@ -618,8 +617,6 @@ extern struct {
 	void * esp;
 	unsigned short ss;
 } stack_start;
-extern struct i386_pda *start_pda;
-extern struct Xgt_desc_struct cpu_gdt_descr;
 
 #ifdef CONFIG_NUMA
 
@@ -961,10 +958,7 @@ static int __cpuinit do_boot_cpu(int api
 	/* Pre-allocate and initialize the CPU's GDT and PDA so it
 	   doesn't have to do any memory allocation during the
 	   delicate CPU-bringup phase. */
-	if (!init_gdt(cpu, idle)) {
-		printk(KERN_INFO "Couldn't allocate GDT/PDA for CPU %d\n", cpu);
-		return -1;	/* ? */
-	}
+	init_gdt(cpu, idle);
 
 	idle->thread.eip = (unsigned long) start_secondary;
 	/* start_eip had better be page-aligned! */
@@ -1090,7 +1084,6 @@ static int __cpuinit __smp_prepare_cpu(i
 	DECLARE_COMPLETION_ONSTACK(done);
 	struct warm_boot_cpu_info info;
 	int	apicid, ret;
-	struct Xgt_desc_struct *cpu_gdt_descr = &per_cpu(cpu_gdt_descr, cpu);
 
 	apicid = x86_cpu_to_apicid[cpu];
 	if (apicid == BAD_APICID) {
@@ -1098,18 +1091,6 @@ static int __cpuinit __smp_prepare_cpu(i
 		goto exit;
 	}
 
-	/*
-	 * the CPU isn't initialized at boot time, allocate gdt table here.
-	 * cpu_init will initialize it
-	 */
-	if (!cpu_gdt_descr->address) {
-		cpu_gdt_descr->address = get_zeroed_page(GFP_KERNEL);
-		if (!cpu_gdt_descr->address)
-			printk(KERN_CRIT "CPU%d failed to allocate GDT\n", cpu);
-			ret = -ENOMEM;
-			goto exit;
-	}
-
 	info.complete = &done;
 	info.apicid = apicid;
 	info.cpu = cpu;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/sys_i386.c linux-2.6.20.1-pax/arch/i386/kernel/sys_i386.c
--- linux-2.6.20.1/arch/i386/kernel/sys_i386.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/sys_i386.c	2007-02-05 00:56:18.000000000 +0100
@@ -100,6 +100,191 @@ out:
 	return err;
 }
 
+unsigned long
+arch_get_unmapped_area(struct file *filp, unsigned long addr,
+		unsigned long len, unsigned long pgoff, unsigned long flags)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	unsigned long start_addr, task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > task_size)
+		return -ENOMEM;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		vma = find_vma(mm, addr);
+		if (task_size - len >= addr &&
+		    (!vma || addr + len <= vma->vm_start))
+			return addr;
+	}
+	if (len > mm->cached_hole_size) {
+		start_addr = addr = mm->free_area_cache;
+	} else {
+		start_addr = addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
+	}
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (flags & MAP_EXECUTABLE) && start_addr >= mm->mmap_base) {
+		start_addr = 0x00110000UL;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			start_addr += mm->delta_mmap & 0x03FFF000UL;
+#endif
+
+		if (mm->start_brk <= start_addr && start_addr < mm->mmap_base)
+			start_addr = addr = mm->mmap_base;
+		else
+			addr = start_addr;
+	}
+#endif
+
+full_search:
+	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
+		/* At this point:  (!vma || addr < vma->vm_end). */
+		if (task_size - len < addr) {
+			/*
+			 * Start a new search - just in case we missed
+			 * some holes.
+			 */
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
+				mm->cached_hole_size = 0;
+				goto full_search;
+			}
+			return -ENOMEM;
+		}
+		if (!vma || addr + len <= vma->vm_start) {
+			/*
+			 * Remember the place where we stopped the search:
+			 */
+			mm->free_area_cache = addr + len;
+			return addr;
+		}
+		if (addr + mm->cached_hole_size < vma->vm_start)
+			mm->cached_hole_size = vma->vm_start - addr;
+		addr = vma->vm_end;
+		if (mm->start_brk <= addr && addr < mm->mmap_base) {
+			start_addr = addr = mm->mmap_base;
+			goto full_search;
+		}
+	}
+}
+
+unsigned long
+arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
+			  const unsigned long len, const unsigned long pgoff,
+			  const unsigned long flags)
+{
+	struct vm_area_struct *vma;
+	struct mm_struct *mm = current->mm;
+	unsigned long base = mm->mmap_base, addr = addr0, task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	/* requested length too big for entire address space */
+	if (len > task_size)
+		return -ENOMEM;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (flags & MAP_EXECUTABLE))
+		goto bottomup;
+#endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
+	/* requesting a specific address */
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		vma = find_vma(mm, addr);
+		if (task_size - len >= addr &&
+				(!vma || addr + len <= vma->vm_start))
+			return addr;
+	}
+
+	/* check if free_area_cache is useful for us */
+	if (len <= mm->cached_hole_size) {
+	        mm->cached_hole_size = 0;
+		mm->free_area_cache = mm->mmap_base;
+	}
+
+	/* either no address requested or can't fit in requested address hole */
+	addr = mm->free_area_cache;
+
+	/* make sure it can fit in the remaining address space */
+	if (addr > len) {
+		vma = find_vma(mm, addr-len);
+		if (!vma || addr <= vma->vm_start)
+			/* remember the address as a hint for next time */
+			return (mm->free_area_cache = addr-len);
+	}
+
+	if (mm->mmap_base < len)
+		goto bottomup;
+
+	addr = mm->mmap_base-len;
+
+	do {
+		/*
+		 * Lookup failure means no vma is above this address,
+		 * else if new region fits below vma->vm_start,
+		 * return with success:
+		 */
+		vma = find_vma(mm, addr);
+		if (!vma || addr+len <= vma->vm_start)
+			/* remember the address as a hint for next time */
+			return (mm->free_area_cache = addr);
+
+		/* remember the largest hole we saw so far */
+		if (addr + mm->cached_hole_size < vma->vm_start)
+			mm->cached_hole_size = vma->vm_start - addr;
+
+		/* try just below the current vma->vm_start */
+		addr = vma->vm_start-len;
+	} while (len < vma->vm_start);
+
+bottomup:
+	/*
+	 * A failed mmap() very likely causes application failure,
+	 * so fall back to the bottom-up function here. This scenario
+	 * can happen with large stack limits and large mmap()
+	 * allocations.
+	 */
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
+	mm->cached_hole_size = ~0UL;
+	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
+	/*
+	 * Restore the topdown base:
+	 */
+	mm->mmap_base = base;
+	mm->free_area_cache = base;
+	mm->cached_hole_size = ~0UL;
+
+	return addr;
+}
 
 struct sel_arg_struct {
 	unsigned long n;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/syscall_table.S linux-2.6.20.1-pax/arch/i386/kernel/syscall_table.S
--- linux-2.6.20.1/arch/i386/kernel/syscall_table.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/syscall_table.S	2007-02-05 00:56:18.000000000 +0100
@@ -1,3 +1,4 @@
+.section .rodata,"a",@progbits
 ENTRY(sys_call_table)
 	.long sys_restart_syscall	/* 0 - old "setup()" system call, used for restarting */
 	.long sys_exit
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/sysenter.c linux-2.6.20.1-pax/arch/i386/kernel/sysenter.c
--- linux-2.6.20.1/arch/i386/kernel/sysenter.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/sysenter.c	2007-02-05 00:56:18.000000000 +0100
@@ -49,7 +49,7 @@ extern asmlinkage void sysenter_entry(vo
 void enable_sep_cpu(void)
 {
 	int cpu = get_cpu();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 
 	if (!boot_cpu_has(X86_FEATURE_SEP)) {
 		put_cpu();
@@ -125,16 +125,36 @@ int arch_setup_additional_pages(struct l
 	unsigned long addr;
 	int ret;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m = NULL;
+#endif
+
+	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+	if (!vma)
+		return -ENOMEM;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		vma_m = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+		if (!vma_m) {
+			kmem_cache_free(vm_area_cachep, vma);
+			return -ENOMEM;
+		}
+	}
+#endif
+
 	down_write(&mm->mmap_sem);
-	addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);
+	addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, MAP_EXECUTABLE);
 	if (IS_ERR_VALUE(addr)) {
 		ret = addr;
-		goto up_fail;
-	}
 
-	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
-	if (!vma) {
-		ret = -ENOMEM;
+		kmem_cache_free(vm_area_cachep, vma);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma_m)
+			kmem_cache_free(vm_area_cachep, vma_m);
+#endif
+
 		goto up_fail;
 	}
 
@@ -142,6 +162,12 @@ int arch_setup_additional_pages(struct l
 	vma->vm_end = addr + PAGE_SIZE;
 	/* MAYWRITE to allow gdb to COW and set breakpoints */
 	vma->vm_flags = VM_READ|VM_EXEC|VM_MAYREAD|VM_MAYEXEC|VM_MAYWRITE;
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (mm->pax_flags & MF_PAX_MPROTECT)
+		vma->vm_flags &= ~VM_MAYWRITE;
+#endif
+
 	/*
 	 * Make sure the vDSO gets into every core dump.
 	 * Dumping its contents makes post-mortem fully interpretable later
@@ -150,17 +176,42 @@ int arch_setup_additional_pages(struct l
 	 */
 	vma->vm_flags |= VM_ALWAYSDUMP;
 	vma->vm_flags |= mm->def_flags;
-	vma->vm_page_prot = protection_map[vma->vm_flags & 7];
+	vma->vm_page_prot = protection_map[vma->vm_flags & (VM_READ|VM_WRITE|VM_EXEC)];
 	vma->vm_ops = &syscall_vm_ops;
 	vma->vm_mm = mm;
 
 	ret = insert_vm_struct(mm, vma);
 	if (unlikely(ret)) {
 		kmem_cache_free(vm_area_cachep, vma);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma_m)
+			kmem_cache_free(vm_area_cachep, vma_m);
+#endif
+
 		goto up_fail;
 	}
 
-	current->mm->context.vdso = (void *)addr;
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma_m) {
+		*vma_m = *vma;
+		vma_m->vm_start += SEGMEXEC_TASK_SIZE;
+		vma_m->vm_end += SEGMEXEC_TASK_SIZE;
+		ret = insert_vm_struct(mm, vma_m);
+		if (unlikely(ret)) {
+			kmem_cache_free(vm_area_cachep, vma_m);
+			goto up_fail;
+		}
+		vma_m->vm_flags |= VM_MIRROR;
+		vma->vm_flags |= VM_MIRROR;
+		vma_m->vm_mirror = vma->vm_start - vma_m->vm_start;
+		vma->vm_mirror = vma_m->vm_start - vma->vm_start;
+		vma_m->vm_pgoff = vma->vm_pgoff;
+		mm->total_vm++;
+	}
+#endif
+
+	current->mm->context.vdso = addr;
 	current_thread_info()->sysenter_return =
 				    (void *)VDSO_SYM(&SYSENTER_RETURN);
 	mm->total_vm++;
@@ -171,8 +222,17 @@ up_fail:
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)
+	if (vma->vm_start == vma->vm_mm->context.vdso)
 		return "[vdso]";
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) || !(vma->vm_flags & VM_MIRROR))
+		return NULL;
+
+	if (vma->vm_start + vma->vm_mirror == vma->vm_mm->context.vdso)
+		return "[vdso]";
+#endif
+
 	return NULL;
 }
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/time.c linux-2.6.20.1-pax/arch/i386/kernel/time.c
--- linux-2.6.20.1/arch/i386/kernel/time.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/time.c	2007-02-05 00:56:18.000000000 +0100
@@ -131,7 +131,7 @@ unsigned long profile_pc(struct pt_regs 
 	unsigned long pc = instruction_pointer(regs);
 
 #ifdef CONFIG_SMP
-	if (!user_mode_vm(regs) && in_lock_functions(pc)) {
+	if (!user_mode(regs) && in_lock_functions(pc)) {
 #ifdef CONFIG_FRAME_POINTER
 		return *(unsigned long *)(regs->ebp + 4);
 #else
@@ -340,7 +340,7 @@ static struct sys_device device_timer = 
 	.cls	= &timer_sysclass,
 };
 
-static int time_init_device(void)
+static int __init time_init_device(void)
 {
 	int error = sysdev_class_register(&timer_sysclass);
 	if (!error)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/traps.c linux-2.6.20.1-pax/arch/i386/kernel/traps.c
--- linux-2.6.20.1/arch/i386/kernel/traps.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/traps.c	2007-02-18 22:19:33.000000000 +0100
@@ -31,6 +31,7 @@
 #include <linux/uaccess.h>
 #include <linux/nmi.h>
 #include <linux/bug.h>
+#include <linux/binfmts.h>
 
 #ifdef CONFIG_EISA
 #include <linux/ioport.h>
@@ -66,12 +67,7 @@ asmlinkage int system_call(void);
 /* Do we ignore FPU interrupts ? */
 char ignore_fpu_irq = 0;
 
-/*
- * The IDT has to be page-aligned to simplify the Pentium
- * F0 0F bug workaround.. We have a special link segment
- * for this.
- */
-struct desc_struct idt_table[256] __attribute__((__section__(".data.idt"))) = { {0, 0}, };
+extern struct desc_struct idt_table[256];
 
 asmlinkage void divide_error(void);
 asmlinkage void debug(void);
@@ -140,7 +136,7 @@ static inline unsigned long print_contex
 #else
 	while (valid_stack_ptr(tinfo, stack)) {
 		addr = *stack++;
-		if (__kernel_text_address(addr))
+		if (__kernel_text_address(addr + __KERNEL_TEXT_OFFSET))
 			ops->address(data, addr);
 	}
 #endif
@@ -295,7 +291,7 @@ void show_registers(struct pt_regs *regs
 
 	esp = (unsigned long) (&regs->esp);
 	savesegment(ss, ss);
-	if (user_mode_vm(regs)) {
+	if (user_mode(regs)) {
 		in_kernel = 0;
 		esp = regs->esp;
 		ss = regs->xss & 0xffff;
@@ -313,8 +309,8 @@ void show_registers(struct pt_regs *regs
 		regs->eax, regs->ebx, regs->ecx, regs->edx);
 	printk(KERN_EMERG "esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx\n",
 		regs->esi, regs->edi, regs->ebp, esp);
-	printk(KERN_EMERG "ds: %04x   es: %04x   ss: %04x\n",
-		regs->xds & 0xffff, regs->xes & 0xffff, ss);
+	printk(KERN_EMERG "ds: %04x   es: %04x   gs: %04x   ss: %04x\n",
+		regs->xds & 0xffff, regs->xes & 0xffff, regs->xgs & 0xffff, ss);
 	printk(KERN_EMERG "Process %.*s (pid: %d[#%u], ti=%p task=%p task.ti=%p)",
 		TASK_COMM_LEN, current->comm, current->pid, current->xid,
 		current_thread_info(), current, current->thread_info);
@@ -332,11 +328,11 @@ void show_registers(struct pt_regs *regs
 
 		printk(KERN_EMERG "Code: ");
 
-		eip = (u8 *)regs->eip - 43;
+		eip = (u8 *)regs->eip - 43 + __KERNEL_TEXT_OFFSET;
 		if (eip < (u8 *)PAGE_OFFSET ||
 			probe_kernel_address(eip, c)) {
 			/* try starting at EIP */
-			eip = (u8 *)regs->eip;
+			eip = (u8 *)regs->eip + __KERNEL_TEXT_OFFSET;
 			code_bytes = 32;
 		}
 		for (i = 0; i < code_bytes; i++, eip++) {
@@ -345,7 +341,7 @@ void show_registers(struct pt_regs *regs
 				printk(" Bad EIP value.");
 				break;
 			}
-			if (eip == (u8 *)regs->eip)
+			if (eip == (u8 *)regs->eip + __KERNEL_TEXT_OFFSET)
 				printk("<%02x> ", c);
 			else
 				printk("%02x ", c);
@@ -358,6 +354,7 @@ int is_valid_bugaddr(unsigned long eip)
 {
 	unsigned short ud2;
 
+	eip += __KERNEL_TEXT_OFFSET;
 	if (eip < PAGE_OFFSET)
 		return 0;
 	if (probe_kernel_address((unsigned short *)eip, ud2))
@@ -464,7 +461,7 @@ void die(const char * str, struct pt_reg
 
 static inline void die_if_kernel(const char * str, struct pt_regs * regs, long err)
 {
-	if (!user_mode_vm(regs))
+	if (!user_mode(regs))
 		die(str, regs, err);
 }
 
@@ -482,7 +479,7 @@ static void __kprobes do_trap(int trapnr
 		goto trap_signal;
 	}
 
-	if (!user_mode(regs))
+	if (!user_mode_novm(regs))
 		goto kernel_trap;
 
 	trap_signal: {
@@ -570,7 +567,7 @@ fastcall void __kprobes do_general_prote
 					      long error_code)
 {
 	int cpu = get_cpu();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = &init_tss[cpu];
 	struct thread_struct *thread = &current->thread;
 
 	/*
@@ -606,9 +603,25 @@ fastcall void __kprobes do_general_prote
 	if (regs->eflags & VM_MASK)
 		goto gp_in_vm86;
 
-	if (!user_mode(regs))
+	if (!user_mode_novm(regs))
 		goto gp_in_kernel;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (current->mm && (current->mm->pax_flags & MF_PAX_PAGEEXEC)) {
+		struct mm_struct *mm = current->mm;
+		unsigned long limit;
+
+		down_write(&mm->mmap_sem);
+		limit = mm->context.user_cs_limit;
+		if (limit < TASK_SIZE) {
+			track_exec_limit(mm, limit, TASK_SIZE, PROT_EXEC);
+			up_write(&mm->mmap_sem);
+			return;
+		}
+		up_write(&mm->mmap_sem);
+	}
+#endif
+
 	current->thread.error_code = error_code;
 	current->thread.trap_no = 13;
 	force_sig(SIGSEGV, current);
@@ -624,6 +637,13 @@ gp_in_kernel:
 		if (notify_die(DIE_GPF, "general protection fault", regs,
 				error_code, 13, SIGSEGV) == NOTIFY_STOP)
 			return;
+
+#ifdef CONFIG_PAX_KERNEXEC
+		if ((regs->xcs & 0xFFFF) == __KERNEL_CS)
+			die("PAX: suspicious general protection fault", regs, error_code);
+		else
+#endif
+
 		die("general protection fault", regs, error_code);
 	}
 }
@@ -705,7 +725,7 @@ void __kprobes die_nmi(struct pt_regs *r
 	/* If we are in kernel we are probably nested up pretty bad
 	 * and might aswell get out now while we still can.
 	*/
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		current->thread.trap_no = 2;
 		crash_kexec(regs);
 	}
@@ -837,7 +857,7 @@ fastcall void __kprobes do_debug(struct 
 		 * check for kernel mode by just checking the CPL
 		 * of CS.
 		 */
-		if (!user_mode(regs))
+		if (!user_mode_novm(regs))
 			goto clear_TF_reenable;
 	}
 
@@ -1016,8 +1036,7 @@ fastcall unsigned long patch_espfix_desc
 					  unsigned long kesp)
 {
 	int cpu = smp_processor_id();
-	struct Xgt_desc_struct *cpu_gdt_descr = &per_cpu(cpu_gdt_descr, cpu);
-	struct desc_struct *gdt = (struct desc_struct *)cpu_gdt_descr->address;
+	struct desc_struct *gdt = (struct desc_struct *)cpu_gdt_descr[cpu].address;
 	unsigned long base = (kesp - uesp) & -THREAD_SIZE;
 	unsigned long new_kesp = kesp - base;
 	unsigned long lim_pages = (new_kesp | (THREAD_SIZE - 1)) >> PAGE_SHIFT;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/tsc.c linux-2.6.20.1-pax/arch/i386/kernel/tsc.c
--- linux-2.6.20.1/arch/i386/kernel/tsc.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/tsc.c	2007-02-15 01:44:46.000000000 +0100
@@ -383,7 +383,7 @@ static struct dmi_system_id __initdata b
 		     DMI_MATCH(DMI_BOARD_NAME, "2635FA0"),
 		     },
 	 },
-	 {}
+	{ NULL, NULL, {{0, NULL}}, NULL}
 };
 
 #define TSC_FREQ_CHECK_INTERVAL (10*MSEC_PER_SEC) /* 10sec in MS */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/vm86.c linux-2.6.20.1-pax/arch/i386/kernel/vm86.c
--- linux-2.6.20.1/arch/i386/kernel/vm86.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/vm86.c	2007-02-05 00:56:18.000000000 +0100
@@ -148,7 +148,7 @@ struct pt_regs * fastcall save_v86_state
 		do_exit(SIGSEGV);
 	}
 
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 	current->thread.esp0 = current->thread.saved_esp0;
 	current->thread.sysenter_cs = __KERNEL_CS;
 	load_esp0(tss, &current->thread);
@@ -324,7 +324,7 @@ static void do_sys_vm86(struct kernel_vm
 	savesegment(fs, tsk->thread.saved_fs);
 	tsk->thread.saved_gs = info->regs32->xgs;
 
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 	tsk->thread.esp0 = (unsigned long) &info->VM86_TSS_ESP0;
 	if (cpu_has_sep)
 		tsk->thread.sysenter_cs = 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/kernel/vmlinux.lds.S linux-2.6.20.1-pax/arch/i386/kernel/vmlinux.lds.S
--- linux-2.6.20.1/arch/i386/kernel/vmlinux.lds.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/kernel/vmlinux.lds.S	2007-02-20 00:23:33.000000000 +0100
@@ -8,12 +8,6 @@
  * put it inside the section definition.
  */
 
-/* Don't define absolute symbols until and unless you know that symbol
- * value is should remain constant even if kernel image is relocated
- * at run time. Absolute symbols are not relocated. If symbol value should
- * change if kernel is relocated, make the symbol section relative and
- * put it inside the section definition.
- */
 #define LOAD_OFFSET __PAGE_OFFSET
 
 #include <asm-generic/vmlinux.lds.h>
@@ -21,6 +15,13 @@
 #include <asm/page.h>
 #include <asm/cache.h>
 #include <asm/boot.h>
+#include <asm/segment.h>
+
+#ifdef CONFIG_X86_PAE
+#define PMD_SHIFT 21
+#else
+#define PMD_SHIFT 22
+#endif
 
 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
 OUTPUT_ARCH(i386)
@@ -30,85 +31,19 @@ _proxy_pda = 0;
 
 PHDRS {
 	text PT_LOAD FLAGS(5);	/* R_E */
-	data PT_LOAD FLAGS(7);	/* RWE */
+	data PT_LOAD FLAGS(6);	/* RW_ */
 	note PT_NOTE FLAGS(4);	/* R__ */
 }
 SECTIONS
 {
   . = LOAD_OFFSET + LOAD_PHYSICAL_ADDR;
-  phys_startup_32 = startup_32 - LOAD_OFFSET;
-  /* read-only */
-  .text : AT(ADDR(.text) - LOAD_OFFSET) {
-  	_text = .;			/* Text and read-only data */
-	*(.text)
-	SCHED_TEXT
-	LOCK_TEXT
-	KPROBES_TEXT
-	*(.fixup)
-	*(.gnu.warning)
-  	_etext = .;			/* End of text section */
-  } :text = 0x9090
-
-  . = ALIGN(16);		/* Exception table */
-  __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {
-  	__start___ex_table = .;
-	 *(__ex_table)
-  	__stop___ex_table = .;
-  }
-
-  RODATA
-
-  BUG_TABLE
-
-  . = ALIGN(4);
-  .tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {
-  	__tracedata_start = .;
-	*(.tracedata)
-  	__tracedata_end = .;
-  }
-
-  /* writeable */
-  . = ALIGN(4096);
-  .data : AT(ADDR(.data) - LOAD_OFFSET) {	/* Data */
-	*(.data)
-	CONSTRUCTORS
-	} :data
-
-  .paravirtprobe : AT(ADDR(.paravirtprobe) - LOAD_OFFSET) {
-  	__start_paravirtprobe = .;
-	*(.paravirtprobe)
-  	__stop_paravirtprobe = .;
-  }
+  phys_startup_32 = startup_32 - LOAD_OFFSET + __KERNEL_TEXT_OFFSET;
 
-  . = ALIGN(4096);
-  .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) {
-  	__nosave_begin = .;
-	*(.data.nosave)
-  	. = ALIGN(4096);
-  	__nosave_end = .;
-  }
-
-  . = ALIGN(4096);
-  .data.page_aligned : AT(ADDR(.data.page_aligned) - LOAD_OFFSET) {
-	*(.data.idt)
-  }
-
-  . = ALIGN(32);
-  .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - LOAD_OFFSET) {
-	*(.data.cacheline_aligned)
-  }
-
-  /* rarely changed data like cpu maps */
-  . = ALIGN(32);
-  .data.read_mostly : AT(ADDR(.data.read_mostly) - LOAD_OFFSET) {
-	*(.data.read_mostly)
-	_edata = .;		/* End of data section */
-  }
-
-  . = ALIGN(THREAD_SIZE);	/* init_task */
-  .data.init_task : AT(ADDR(.data.init_task) - LOAD_OFFSET) {
-	*(.data.init_task)
-  }
+  .text.startup : AT(ADDR(.text.startup) - LOAD_OFFSET) {
+	BYTE(0xEA) /* jmp far */
+	LONG(phys_startup_32)
+	SHORT(__BOOT_CS)
+	} :text = 0x9090
 
   /* might get freed after init */
   . = ALIGN(4096);
@@ -137,14 +72,10 @@ SECTIONS
   . = ALIGN(4096);
 
   /* will be freed after init */
-  . = ALIGN(4096);		/* Init code and data */
-  .init.text : AT(ADDR(.init.text) - LOAD_OFFSET) {
-  	__init_begin = .;
-	_sinittext = .;
-	*(.init.text)
-	_einittext = .;
-  }
-  .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) { *(.init.data) }
+  .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) {
+	__init_begin = .;
+	*(.init.data)
+	}
   . = ALIGN(16);
   .init.setup : AT(ADDR(.init.setup) - LOAD_OFFSET) {
   	__setup_start = .;
@@ -177,9 +108,6 @@ SECTIONS
 	*(.parainstructions)
   	__stop_parainstructions = .;
   }
-  /* .exit.text is discard at runtime, not link time, to deal with references
-     from .altinstructions and .eh_frame */
-  .exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET) { *(.exit.text) }
   .exit.data : AT(ADDR(.exit.data) - LOAD_OFFSET) { *(.exit.data) }
   . = ALIGN(4096);
   .init.ramfs : AT(ADDR(.init.ramfs) - LOAD_OFFSET) {
@@ -193,11 +121,134 @@ SECTIONS
 	*(.data.percpu)
 	__per_cpu_end = .;
   }
+
+  /* read-only */
+
+  . = ALIGN(4096);		/* Init code and data */
+  .init.text (. - __KERNEL_TEXT_OFFSET) : AT(ADDR(.init.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	_sinittext = .;
+	*(.init.text)
+	_einittext = .;
+  }
+
+  /* .exit.text is discard at runtime, not link time, to deal with references
+     from .altinstructions and .eh_frame */
+  .exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) { *(.exit.text) }
+
+#ifdef CONFIG_PAX_KERNEXEC
+  .text.align : AT(ADDR(.text.align) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	. = ALIGN(__KERNEL_TEXT_OFFSET - LOAD_OFFSET) - 1;
+	BYTE(0)
+	__init_end = . + __KERNEL_TEXT_OFFSET;
+  }
+#else
   . = ALIGN(4096);
+#endif
+
   /* freed after init ends here */
-	
+
+  .text : AT(ADDR(.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	_text = .;			/* Text and read-only data */
+	*(.text)
+	SCHED_TEXT
+	LOCK_TEXT
+	KPROBES_TEXT
+	*(.fixup)
+	*(.gnu.warning)
+  	_etext = .;			/* End of text section */
+  } :text = 0x9090
+
+  . += __KERNEL_TEXT_OFFSET;
+  . = ALIGN(16);		/* Exception table */
+  __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {
+  	__start___ex_table = .;
+	 *(__ex_table)
+  	__stop___ex_table = .;
+  }
+
+  . = ALIGN(4096);
+  .rodata.page_aligned : AT(ADDR(.rodata.page_aligned) - LOAD_OFFSET) {
+	*(.empty_zero_page)
+
+#ifdef CONFIG_X86_PAE
+	*(.swapper_pm_dir)
+#endif
+
+	*(.swapper_pg_dir)
+	*(.idt)
+	}
+
+  RODATA
+
+  BUG_TABLE
+
+  . = ALIGN(4);
+  .tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {
+  	__tracedata_start = .;
+	*(.tracedata)
+  	__tracedata_end = .;
+  }
+
+#ifdef CONFIG_PAX_KERNEXEC
+  . = ALIGN(4096);
+
+  .module.text : AT(ADDR(.module.text) - LOAD_OFFSET) {
+	MODULES_VADDR = .;
+	. += (4 * 1024 * 1024);
+	. = ALIGN(1 << PMD_SHIFT) - 1;
+	BYTE(0)
+	MODULES_END = .;
+  }
+
+#else
+  . = ALIGN(32);
+#endif
+
+  /* writeable */
+  . = ALIGN(4096);
+  .data : AT(ADDR(.data) - LOAD_OFFSET) {	/* Data */
+	_data = .;
+	*(.data)
+	CONSTRUCTORS
+	} :data
+
+  .paravirtprobe : AT(ADDR(.paravirtprobe) - LOAD_OFFSET) {
+  	__start_paravirtprobe = .;
+	*(.paravirtprobe)
+  	__stop_paravirtprobe = .;
+  }
+
+  . = ALIGN(4096);
+  .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) {
+  	__nosave_begin = .;
+	*(.data.nosave)
+  	. = ALIGN(4096);
+  	__nosave_end = .;
+  }
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - LOAD_OFFSET) {
+	*(.data.cacheline_aligned)
+  }
+
+  /* rarely changed data like cpu maps */
+  . = ALIGN(32);
+  .data.read_mostly : AT(ADDR(.data.read_mostly) - LOAD_OFFSET) {
+	*(.data.read_mostly)
+	_edata = .;		/* End of data section */
+  }
+
+  . = ALIGN(THREAD_SIZE);	/* init_task */
+  .data.init_task : AT(ADDR(.data.init_task) - LOAD_OFFSET) {
+	*(.data.init_task)
+  }
+
+  . = ALIGN(4096);
+
   .bss : AT(ADDR(.bss) - LOAD_OFFSET) {
+#ifndef CONFIG_PAX_KERNEXEC
 	__init_end = .;
+#endif
 	__bss_start = .;		/* BSS */
 	*(.bss.page_aligned)
 	*(.bss)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/lib/checksum.S linux-2.6.20.1-pax/arch/i386/lib/checksum.S
--- linux-2.6.20.1/arch/i386/lib/checksum.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/lib/checksum.S	2007-02-05 00:56:18.000000000 +0100
@@ -26,7 +26,8 @@
  */
 
 #include <asm/errno.h>
-				
+#include <asm/segment.h>
+
 /*
  * computes a partial checksum, e.g. for TCP/UDP fragments
  */
@@ -280,12 +281,23 @@ unsigned int csum_partial_copy_generic (
 
 .align 4
 .globl csum_partial_copy_generic
-				
+.globl csum_partial_copy_generic_to_user
+.globl csum_partial_copy_generic_from_user
+
 #ifndef CONFIG_X86_USE_PPRO_CHECKSUM
 
 #define ARGBASE 16		
 #define FP		12
-		
+
+csum_partial_copy_generic_to_user:
+	pushl $(__USER_DS)
+	popl %es
+	jmp csum_partial_copy_generic
+
+csum_partial_copy_generic_from_user:
+	pushl $(__USER_DS)
+	popl %ds
+
 csum_partial_copy_generic:
 	subl  $4,%esp	
 	pushl %edi
@@ -304,7 +316,7 @@ csum_partial_copy_generic:
 	jmp 4f
 SRC(1:	movw (%esi), %bx	)
 	addl $2, %esi
-DST(	movw %bx, (%edi)	)
+DST(	movw %bx, %es:(%edi)	)
 	addl $2, %edi
 	addw %bx, %ax	
 	adcl $0, %eax
@@ -316,30 +328,30 @@ DST(	movw %bx, (%edi)	)
 SRC(1:	movl (%esi), %ebx	)
 SRC(	movl 4(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 4(%edi)	)
+DST(	movl %edx, %es:4(%edi)	)
 
 SRC(	movl 8(%esi), %ebx	)
 SRC(	movl 12(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 8(%edi)	)
+DST(	movl %ebx, %es:8(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 12(%edi)	)
+DST(	movl %edx, %es:12(%edi)	)
 
 SRC(	movl 16(%esi), %ebx 	)
 SRC(	movl 20(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 16(%edi)	)
+DST(	movl %ebx, %es:16(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 20(%edi)	)
+DST(	movl %edx, %es:20(%edi)	)
 
 SRC(	movl 24(%esi), %ebx	)
 SRC(	movl 28(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 24(%edi)	)
+DST(	movl %ebx, %es:24(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 28(%edi)	)
+DST(	movl %edx, %es:28(%edi)	)
 
 	lea 32(%esi), %esi
 	lea 32(%edi), %edi
@@ -353,7 +365,7 @@ DST(	movl %edx, 28(%edi)	)
 	shrl $2, %edx			# This clears CF
 SRC(3:	movl (%esi), %ebx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	lea 4(%esi), %esi
 	lea 4(%edi), %edi
 	dec %edx
@@ -365,12 +377,12 @@ DST(	movl %ebx, (%edi)	)
 	jb 5f
 SRC(	movw (%esi), %cx	)
 	leal 2(%esi), %esi
-DST(	movw %cx, (%edi)	)
+DST(	movw %cx, %es:(%edi)	)
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%ecx
 SRC(5:	movb (%esi), %cl	)
-DST(	movb %cl, (%edi)	)
+DST(	movb %cl, %es:(%edi)	)
 6:	addl %ecx, %eax
 	adcl $0, %eax
 7:
@@ -381,7 +393,7 @@ DST(	movb %cl, (%edi)	)
 
 6001:
 	movl ARGBASE+20(%esp), %ebx	# src_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 
 	# zero the complete destination - computing the rest
 	# is too much work 
@@ -394,11 +406,15 @@ DST(	movb %cl, (%edi)	)
 
 6002:
 	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT,(%ebx)
+	movl $-EFAULT,%ss:(%ebx)
 	jmp 5000b
 
 .previous
 
+	pushl %ss
+	popl %ds
+	pushl %ss
+	popl %es
 	popl %ebx
 	popl %esi
 	popl %edi
@@ -410,17 +426,28 @@ DST(	movb %cl, (%edi)	)
 /* Version for PentiumII/PPro */
 
 #define ROUND1(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	addl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	; 
+	DST(movl %ebx, %es:x(%edi));
 
 #define ROUND(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	adcl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	;
+	DST(movl %ebx, %es:x(%edi));
 
 #define ARGBASE 12
-		
+
+csum_partial_copy_generic_to_user:
+	pushl $(__USER_DS)
+	popl %es
+	jmp csum_partial_copy_generic
+
+csum_partial_copy_generic_from_user:
+	pushl $(__USER_DS)
+	popl %ds
+
 csum_partial_copy_generic:
 	pushl %ebx
 	pushl %edi
@@ -439,7 +466,7 @@ csum_partial_copy_generic:
 	subl %ebx, %edi  
 	lea  -1(%esi),%edx
 	andl $-32,%edx
-	lea 3f(%ebx,%ebx), %ebx
+	lea 3f(%ebx,%ebx,2), %ebx
 	testl %esi, %esi 
 	jmp *%ebx
 1:	addl $64,%esi
@@ -460,19 +487,19 @@ csum_partial_copy_generic:
 	jb 5f
 SRC(	movw (%esi), %dx         )
 	leal 2(%esi), %esi
-DST(	movw %dx, (%edi)         )
+DST(	movw %dx, %es:(%edi)     )
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%edx
 5:
 SRC(	movb (%esi), %dl         )
-DST(	movb %dl, (%edi)         )
+DST(	movb %dl, %es:(%edi)     )
 6:	addl %edx, %eax
 	adcl $0, %eax
 7:
 .section .fixup, "ax"
 6001:	movl	ARGBASE+20(%esp), %ebx	# src_err_ptr	
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	# zero the complete destination (computing the rest is too much work)
 	movl ARGBASE+8(%esp),%edi	# dst
 	movl ARGBASE+12(%esp),%ecx	# len
@@ -480,10 +507,14 @@ DST(	movb %dl, (%edi)         )
 	rep; stosb
 	jmp 7b
 6002:	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	jmp  7b			
 .previous				
 
+	pushl %ss
+	popl %ds
+	pushl %ss
+	popl %es
 	popl %esi
 	popl %edi
 	popl %ebx
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/lib/getuser.S linux-2.6.20.1-pax/arch/i386/lib/getuser.S
--- linux-2.6.20.1/arch/i386/lib/getuser.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/lib/getuser.S	2007-02-05 00:56:18.000000000 +0100
@@ -9,6 +9,7 @@
  * return value.
  */
 #include <asm/thread_info.h>
+#include <asm/segment.h>
 
 
 /*
@@ -30,8 +31,12 @@ __get_user_1:
 	GET_THREAD_INFO(%edx)
 	cmpl TI_addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 1:	movzbl (%eax),%edx
 	xorl %eax,%eax
+	pushl %ss
+	pop %ds
 	ret
 
 .align 4
@@ -42,7 +47,11 @@ __get_user_2:
 	GET_THREAD_INFO(%edx)
 	cmpl TI_addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 2:	movzwl -1(%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 
@@ -54,11 +63,17 @@ __get_user_4:
 	GET_THREAD_INFO(%edx)
 	cmpl TI_addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 3:	movl -3(%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 
 bad_get_user:
+	pushl %ss
+	pop %ds
 	xorl %edx,%edx
 	movl $-14,%eax
 	ret
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/lib/mmx.c linux-2.6.20.1-pax/arch/i386/lib/mmx.c
--- linux-2.6.20.1/arch/i386/lib/mmx.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/lib/mmx.c	2007-02-05 00:56:18.000000000 +0100
@@ -47,14 +47,30 @@ void *_mmx_memcpy(void *to, const void *
 		"   prefetch 256(%0)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   cli\n"
+		"   movl %%cr0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		" movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   orl $0x00010000, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+		"   sti\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: : "r" (from) : "ax");
 		
 	
 	for(; i>5; i--)
@@ -78,14 +94,30 @@ void *_mmx_memcpy(void *to, const void *
 		"  movq %%mm2, 48(%1)\n"
 		"  movq %%mm3, 56(%1)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"  cli\n"
+		"  movl %%cr0, %%eax\n"
+		"  andl $0xFFFEFFFF, %%eax\n"
+		"  movl %%eax, %%cr0\n"
+#endif
+
+		"  movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"  orl $0x00010000, %%eax\n"
+		"  movl %%eax, %%cr0\n"
+		"  sti\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
@@ -178,14 +210,30 @@ static void fast_copy_page(void *to, voi
 		"   prefetch 256(%0)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   cli\n"
+		"   movl %%cr0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   orl $0x00010000, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+		"   sti\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: : "r" (from) : "ax");
 
 	for(i=0; i<(4096-320)/64; i++)
 	{
@@ -208,14 +256,30 @@ static void fast_copy_page(void *to, voi
 		"   movq 56(%0), %%mm7\n"
 		"   movntq %%mm7, 56(%1)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   cli\n"
+		"   movl %%cr0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   orl $0x00010000, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+		"   sti\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
@@ -308,14 +372,30 @@ static void fast_copy_page(void *to, voi
 		"   prefetch 256(%0)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   cli\n"
+		"   movl %%cr0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   orl $0x00010000, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+		"   sti\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: : "r" (from) : "ax");
 
 	for(i=0; i<4096/64; i++)
 	{
@@ -338,14 +418,30 @@ static void fast_copy_page(void *to, voi
 		"   movq %%mm2, 48(%1)\n"
 		"   movq %%mm3, 56(%1)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   cli\n"
+		"   movl %%cr0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   orl $0x00010000, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+		"   sti\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/lib/putuser.S linux-2.6.20.1-pax/arch/i386/lib/putuser.S
--- linux-2.6.20.1/arch/i386/lib/putuser.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/lib/putuser.S	2007-02-05 00:56:18.000000000 +0100
@@ -9,6 +9,7 @@
  * return value.
  */
 #include <asm/thread_info.h>
+#include <asm/segment.h>
 
 
 /*
@@ -33,7 +34,11 @@ __put_user_1:
 	ENTER
 	cmpl TI_addr_limit(%ebx),%ecx
 	jae bad_put_user
+	pushl $(__USER_DS)
+	popl %ds
 1:	movb %al,(%ecx)
+	pushl %ss
+	popl %ds
 	xorl %eax,%eax
 	EXIT
 
@@ -45,7 +50,11 @@ __put_user_2:
 	subl $1,%ebx
 	cmpl %ebx,%ecx
 	jae bad_put_user
+	pushl $(__USER_DS)
+	popl %ds
 2:	movw %ax,(%ecx)
+	pushl %ss
+	popl %ds
 	xorl %eax,%eax
 	EXIT
 
@@ -57,7 +66,11 @@ __put_user_4:
 	subl $3,%ebx
 	cmpl %ebx,%ecx
 	jae bad_put_user
+	pushl $(__USER_DS)
+	popl %ds
 3:	movl %eax,(%ecx)
+	pushl %ss
+	popl %ds
 	xorl %eax,%eax
 	EXIT
 
@@ -69,12 +82,18 @@ __put_user_8:
 	subl $7,%ebx
 	cmpl %ebx,%ecx
 	jae bad_put_user
+	pushl $(__USER_DS)
+	popl %ds
 4:	movl %eax,(%ecx)
 5:	movl %edx,4(%ecx)
+	pushl %ss
+	popl %ds
 	xorl %eax,%eax
 	EXIT
 
 bad_put_user:
+	pushl %ss
+	popl %ds
 	movl $-14,%eax
 	EXIT
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/lib/usercopy.c linux-2.6.20.1-pax/arch/i386/lib/usercopy.c
--- linux-2.6.20.1/arch/i386/lib/usercopy.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/lib/usercopy.c	2007-02-20 22:42:50.000000000 +0100
@@ -28,34 +28,41 @@ static inline int __movsl_is_ok(unsigned
  * Copy a null terminated string from userspace.
  */
 
-#define __do_strncpy_from_user(dst,src,count,res)			   \
-do {									   \
-	int __d0, __d1, __d2;						   \
-	might_sleep();							   \
-	__asm__ __volatile__(						   \
-		"	testl %1,%1\n"					   \
-		"	jz 2f\n"					   \
-		"0:	lodsb\n"					   \
-		"	stosb\n"					   \
-		"	testb %%al,%%al\n"				   \
-		"	jz 1f\n"					   \
-		"	decl %1\n"					   \
-		"	jnz 0b\n"					   \
-		"1:	subl %1,%0\n"					   \
-		"2:\n"							   \
-		".section .fixup,\"ax\"\n"				   \
-		"3:	movl %5,%0\n"					   \
-		"	jmp 2b\n"					   \
-		".previous\n"						   \
-		".section __ex_table,\"a\"\n"				   \
-		"	.align 4\n"					   \
-		"	.long 0b,3b\n"					   \
-		".previous"						   \
-		: "=d"(res), "=c"(count), "=&a" (__d0), "=&S" (__d1),	   \
-		  "=&D" (__d2)						   \
-		: "i"(-EFAULT), "0"(count), "1"(count), "3"(src), "4"(dst) \
-		: "memory");						   \
-} while (0)
+static long __do_strncpy_from_user(char *dst, const char __user *src, long count)
+{
+	int __d0, __d1, __d2;
+	long res = -EFAULT;
+
+	might_sleep();
+	__asm__ __volatile__(
+		"	movw %w10,%%ds\n"
+		"	testl %1,%1\n"
+		"	jz 2f\n"
+		"0:	lodsb\n"
+		"	stosb\n"
+		"	testb %%al,%%al\n"
+		"	jz 1f\n"
+		"	decl %1\n"
+		"	jnz 0b\n"
+		"1:	subl %1,%0\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%ds\n"
+		".section .fixup,\"ax\"\n"
+		"3:	movl %5,%0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.align 4\n"
+		"	.long 0b,3b\n"
+		".previous"
+		: "=d"(res), "=c"(count), "=&a" (__d0), "=&S" (__d1),
+		  "=&D" (__d2)
+		: "i"(-EFAULT), "0"(count), "1"(count), "3"(src), "4"(dst),
+		  "r"(__USER_DS)
+		: "memory");
+	return res;
+}
 
 /**
  * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.
@@ -80,9 +87,7 @@ do {									   \
 long
 __strncpy_from_user(char *dst, const char __user *src, long count)
 {
-	long res;
-	__do_strncpy_from_user(dst, src, count, res);
-	return res;
+	return __do_strncpy_from_user(dst, src, count);
 }
 EXPORT_SYMBOL(__strncpy_from_user);
 
@@ -109,7 +114,7 @@ strncpy_from_user(char *dst, const char 
 {
 	long res = -EFAULT;
 	if (access_ok(VERIFY_READ, src, 1))
-		__do_strncpy_from_user(dst, src, count, res);
+		res = __do_strncpy_from_user(dst, src, count);
 	return res;
 }
 EXPORT_SYMBOL(strncpy_from_user);
@@ -118,27 +123,33 @@ EXPORT_SYMBOL(strncpy_from_user);
  * Zero Userspace
  */
 
-#define __do_clear_user(addr,size)					\
-do {									\
-	int __d0;							\
-	might_sleep();							\
-  	__asm__ __volatile__(						\
-		"0:	rep; stosl\n"					\
-		"	movl %2,%0\n"					\
-		"1:	rep; stosb\n"					\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"3:	lea 0(%2,%0,4),%0\n"				\
-		"	jmp 2b\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.align 4\n"					\
-		"	.long 0b,3b\n"					\
-		"	.long 1b,2b\n"					\
-		".previous"						\
-		: "=&c"(size), "=&D" (__d0)				\
-		: "r"(size & 3), "0"(size / 4), "1"(addr), "a"(0));	\
-} while (0)
+static unsigned long __do_clear_user(void __user *addr, unsigned long size)
+{
+	int __d0;
+
+	might_sleep();
+	__asm__ __volatile__(
+		"	movw %w6,%%es\n"
+		"0:	rep; stosl\n"
+		"	movl %2,%0\n"
+		"1:	rep; stosb\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%es\n"
+		".section .fixup,\"ax\"\n"
+		"3:	lea 0(%2,%0,4),%0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.align 4\n"
+		"	.long 0b,3b\n"
+		"	.long 1b,2b\n"
+		".previous"
+		: "=&c"(size), "=&D" (__d0)
+		: "r"(size & 3), "0"(size / 4), "1"(addr), "a"(0),
+		  "r"(__USER_DS));
+	return size;
+}
 
 /**
  * clear_user: - Zero a block of memory in user space.
@@ -155,7 +166,7 @@ clear_user(void __user *to, unsigned lon
 {
 	might_sleep();
 	if (access_ok(VERIFY_WRITE, to, n))
-		__do_clear_user(to, n);
+		n = __do_clear_user(to, n);
 	return n;
 }
 EXPORT_SYMBOL(clear_user);
@@ -174,8 +185,7 @@ EXPORT_SYMBOL(clear_user);
 unsigned long
 __clear_user(void __user *to, unsigned long n)
 {
-	__do_clear_user(to, n);
-	return n;
+	return __do_clear_user(to, n);
 }
 EXPORT_SYMBOL(__clear_user);
 
@@ -198,14 +208,17 @@ long strnlen_user(const char __user *s, 
 	might_sleep();
 
 	__asm__ __volatile__(
+		"	movw %w8,%%es\n"
 		"	testl %0, %0\n"
 		"	jz 3f\n"
-		"	andl %0,%%ecx\n"
+		"	movl %0,%%ecx\n"
 		"0:	repne; scasb\n"
 		"	setne %%al\n"
 		"	subl %%ecx,%0\n"
 		"	addl %0,%%eax\n"
 		"1:\n"
+		"	pushl %%ss\n"
+		"	popl %%es\n"
 		".section .fixup,\"ax\"\n"
 		"2:	xorl %%eax,%%eax\n"
 		"	jmp 1b\n"
@@ -217,7 +230,7 @@ long strnlen_user(const char __user *s, 
 		"	.long 0b,2b\n"
 		".previous"
 		:"=r" (n), "=D" (s), "=a" (res), "=c" (tmp)
-		:"0" (n), "1" (s), "2" (0), "3" (mask)
+		:"0" (n), "1" (s), "2" (0), "3" (mask), "r" (__USER_DS)
 		:"cc");
 	return res & mask;
 }
@@ -225,10 +238,11 @@ EXPORT_SYMBOL(strnlen_user);
 
 #ifdef CONFIG_X86_INTEL_USERCOPY
 static unsigned long
-__copy_user_intel(void __user *to, const void *from, unsigned long size)
+__generic_copy_to_user_intel(void __user *to, const void *from, unsigned long size)
 {
 	int d0, d1;
 	__asm__ __volatile__(
+		       "       movw %w6, %%es\n"
 		       "       .align 2,0x90\n"
 		       "1:     movl 32(%4), %%eax\n"
 		       "       cmpl $67, %0\n"
@@ -237,36 +251,36 @@ __copy_user_intel(void __user *to, const
 		       "       .align 2,0x90\n"
 		       "3:     movl 0(%4), %%eax\n"
 		       "4:     movl 4(%4), %%edx\n"
-		       "5:     movl %%eax, 0(%3)\n"
-		       "6:     movl %%edx, 4(%3)\n"
+		       "5:     movl %%eax, %%es:0(%3)\n"
+		       "6:     movl %%edx, %%es:4(%3)\n"
 		       "7:     movl 8(%4), %%eax\n"
 		       "8:     movl 12(%4),%%edx\n"
-		       "9:     movl %%eax, 8(%3)\n"
-		       "10:    movl %%edx, 12(%3)\n"
+		       "9:     movl %%eax, %%es:8(%3)\n"
+		       "10:    movl %%edx, %%es:12(%3)\n"
 		       "11:    movl 16(%4), %%eax\n"
 		       "12:    movl 20(%4), %%edx\n"
-		       "13:    movl %%eax, 16(%3)\n"
-		       "14:    movl %%edx, 20(%3)\n"
+		       "13:    movl %%eax, %%es:16(%3)\n"
+		       "14:    movl %%edx, %%es:20(%3)\n"
 		       "15:    movl 24(%4), %%eax\n"
 		       "16:    movl 28(%4), %%edx\n"
-		       "17:    movl %%eax, 24(%3)\n"
-		       "18:    movl %%edx, 28(%3)\n"
+		       "17:    movl %%eax, %%es:24(%3)\n"
+		       "18:    movl %%edx, %%es:28(%3)\n"
 		       "19:    movl 32(%4), %%eax\n"
 		       "20:    movl 36(%4), %%edx\n"
-		       "21:    movl %%eax, 32(%3)\n"
-		       "22:    movl %%edx, 36(%3)\n"
+		       "21:    movl %%eax, %%es:32(%3)\n"
+		       "22:    movl %%edx, %%es:36(%3)\n"
 		       "23:    movl 40(%4), %%eax\n"
 		       "24:    movl 44(%4), %%edx\n"
-		       "25:    movl %%eax, 40(%3)\n"
-		       "26:    movl %%edx, 44(%3)\n"
+		       "25:    movl %%eax, %%es:40(%3)\n"
+		       "26:    movl %%edx, %%es:44(%3)\n"
 		       "27:    movl 48(%4), %%eax\n"
 		       "28:    movl 52(%4), %%edx\n"
-		       "29:    movl %%eax, 48(%3)\n"
-		       "30:    movl %%edx, 52(%3)\n"
+		       "29:    movl %%eax, %%es:48(%3)\n"
+		       "30:    movl %%edx, %%es:52(%3)\n"
 		       "31:    movl 56(%4), %%eax\n"
 		       "32:    movl 60(%4), %%edx\n"
-		       "33:    movl %%eax, 56(%3)\n"
-		       "34:    movl %%edx, 60(%3)\n"
+		       "33:    movl %%eax, %%es:56(%3)\n"
+		       "34:    movl %%edx, %%es:60(%3)\n"
 		       "       addl $-64, %0\n"
 		       "       addl $64, %4\n"
 		       "       addl $64, %3\n"
@@ -280,6 +294,8 @@ __copy_user_intel(void __user *to, const
 		       "36:    movl %%eax, %0\n"
 		       "37:    rep; movsb\n"
 		       "100:\n"
+		       "       pushl %%ss\n"
+		       "       popl %%es\n"
 		       ".section .fixup,\"ax\"\n"
 		       "101:   lea 0(%%eax,%0,4),%0\n"
 		       "       jmp 100b\n"
@@ -326,7 +342,117 @@ __copy_user_intel(void __user *to, const
 		       "       .long 99b,101b\n"
 		       ".previous"
 		       : "=&c"(size), "=&D" (d0), "=&S" (d1)
-		       :  "1"(to), "2"(from), "0"(size)
+		       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
+		       : "eax", "edx", "memory");
+	return size;
+}
+
+static unsigned long
+__generic_copy_from_user_intel(void *to, const void __user *from, unsigned long size)
+{
+	int d0, d1;
+	__asm__ __volatile__(
+		       "       movw %w6, %%ds\n"
+		       "       .align 2,0x90\n"
+		       "1:     movl 32(%4), %%eax\n"
+		       "       cmpl $67, %0\n"
+		       "       jbe 3f\n"
+		       "2:     movl 64(%4), %%eax\n"
+		       "       .align 2,0x90\n"
+		       "3:     movl 0(%4), %%eax\n"
+		       "4:     movl 4(%4), %%edx\n"
+		       "5:     movl %%eax, %%es:0(%3)\n"
+		       "6:     movl %%edx, %%es:4(%3)\n"
+		       "7:     movl 8(%4), %%eax\n"
+		       "8:     movl 12(%4),%%edx\n"
+		       "9:     movl %%eax, %%es:8(%3)\n"
+		       "10:    movl %%edx, %%es:12(%3)\n"
+		       "11:    movl 16(%4), %%eax\n"
+		       "12:    movl 20(%4), %%edx\n"
+		       "13:    movl %%eax, %%es:16(%3)\n"
+		       "14:    movl %%edx, %%es:20(%3)\n"
+		       "15:    movl 24(%4), %%eax\n"
+		       "16:    movl 28(%4), %%edx\n"
+		       "17:    movl %%eax, %%es:24(%3)\n"
+		       "18:    movl %%edx, %%es:28(%3)\n"
+		       "19:    movl 32(%4), %%eax\n"
+		       "20:    movl 36(%4), %%edx\n"
+		       "21:    movl %%eax, %%es:32(%3)\n"
+		       "22:    movl %%edx, %%es:36(%3)\n"
+		       "23:    movl 40(%4), %%eax\n"
+		       "24:    movl 44(%4), %%edx\n"
+		       "25:    movl %%eax, %%es:40(%3)\n"
+		       "26:    movl %%edx, %%es:44(%3)\n"
+		       "27:    movl 48(%4), %%eax\n"
+		       "28:    movl 52(%4), %%edx\n"
+		       "29:    movl %%eax, %%es:48(%3)\n"
+		       "30:    movl %%edx, %%es:52(%3)\n"
+		       "31:    movl 56(%4), %%eax\n"
+		       "32:    movl 60(%4), %%edx\n"
+		       "33:    movl %%eax, %%es:56(%3)\n"
+		       "34:    movl %%edx, %%es:60(%3)\n"
+		       "       addl $-64, %0\n"
+		       "       addl $64, %4\n"
+		       "       addl $64, %3\n"
+		       "       cmpl $63, %0\n"
+		       "       ja  1b\n"
+		       "35:    movl  %0, %%eax\n"
+		       "       shrl  $2, %0\n"
+		       "       andl  $3, %%eax\n"
+		       "       cld\n"
+		       "99:    rep; movsl\n"
+		       "36:    movl %%eax, %0\n"
+		       "37:    rep; movsb\n"
+		       "100:\n"
+		       "       pushl %%ss\n"
+		       "       popl %%ds\n"
+		       ".section .fixup,\"ax\"\n"
+		       "101:   lea 0(%%eax,%0,4),%0\n"
+		       "       jmp 100b\n"
+		       ".previous\n"
+		       ".section __ex_table,\"a\"\n"
+		       "       .align 4\n"
+		       "       .long 1b,100b\n"
+		       "       .long 2b,100b\n"
+		       "       .long 3b,100b\n"
+		       "       .long 4b,100b\n"
+		       "       .long 5b,100b\n"
+		       "       .long 6b,100b\n"
+		       "       .long 7b,100b\n"
+		       "       .long 8b,100b\n"
+		       "       .long 9b,100b\n"
+		       "       .long 10b,100b\n"
+		       "       .long 11b,100b\n"
+		       "       .long 12b,100b\n"
+		       "       .long 13b,100b\n"
+		       "       .long 14b,100b\n"
+		       "       .long 15b,100b\n"
+		       "       .long 16b,100b\n"
+		       "       .long 17b,100b\n"
+		       "       .long 18b,100b\n"
+		       "       .long 19b,100b\n"
+		       "       .long 20b,100b\n"
+		       "       .long 21b,100b\n"
+		       "       .long 22b,100b\n"
+		       "       .long 23b,100b\n"
+		       "       .long 24b,100b\n"
+		       "       .long 25b,100b\n"
+		       "       .long 26b,100b\n"
+		       "       .long 27b,100b\n"
+		       "       .long 28b,100b\n"
+		       "       .long 29b,100b\n"
+		       "       .long 30b,100b\n"
+		       "       .long 31b,100b\n"
+		       "       .long 32b,100b\n"
+		       "       .long 33b,100b\n"
+		       "       .long 34b,100b\n"
+		       "       .long 35b,100b\n"
+		       "       .long 36b,100b\n"
+		       "       .long 37b,100b\n"
+		       "       .long 99b,101b\n"
+		       ".previous"
+		       : "=&c"(size), "=&D" (d0), "=&S" (d1)
+		       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
 		       : "eax", "edx", "memory");
 	return size;
 }
@@ -336,6 +462,7 @@ __copy_user_zeroing_intel(void *to, cons
 {
 	int d0, d1;
 	__asm__ __volatile__(
+		       "        movw %w6, %%ds\n"
 		       "        .align 2,0x90\n"
 		       "0:      movl 32(%4), %%eax\n"
 		       "        cmpl $67, %0\n"      
@@ -344,36 +471,36 @@ __copy_user_zeroing_intel(void *to, cons
 		       "        .align 2,0x90\n"     
 		       "2:      movl 0(%4), %%eax\n" 
 		       "21:     movl 4(%4), %%edx\n" 
-		       "        movl %%eax, 0(%3)\n" 
-		       "        movl %%edx, 4(%3)\n" 
+		       "        movl %%eax, %%es:0(%3)\n" 
+		       "        movl %%edx, %%es:4(%3)\n" 
 		       "3:      movl 8(%4), %%eax\n" 
 		       "31:     movl 12(%4),%%edx\n" 
-		       "        movl %%eax, 8(%3)\n" 
-		       "        movl %%edx, 12(%3)\n"
+		       "        movl %%eax, %%es:8(%3)\n" 
+		       "        movl %%edx, %%es:12(%3)\n"
 		       "4:      movl 16(%4), %%eax\n"
 		       "41:     movl 20(%4), %%edx\n"
-		       "        movl %%eax, 16(%3)\n"
-		       "        movl %%edx, 20(%3)\n"
+		       "        movl %%eax, %%es:16(%3)\n"
+		       "        movl %%edx, %%es:20(%3)\n"
 		       "10:     movl 24(%4), %%eax\n"
 		       "51:     movl 28(%4), %%edx\n"
-		       "        movl %%eax, 24(%3)\n"
-		       "        movl %%edx, 28(%3)\n"
+		       "        movl %%eax, %%es:24(%3)\n"
+		       "        movl %%edx, %%es:28(%3)\n"
 		       "11:     movl 32(%4), %%eax\n"
 		       "61:     movl 36(%4), %%edx\n"
-		       "        movl %%eax, 32(%3)\n"
-		       "        movl %%edx, 36(%3)\n"
+		       "        movl %%eax, %%es:32(%3)\n"
+		       "        movl %%edx, %%es:36(%3)\n"
 		       "12:     movl 40(%4), %%eax\n"
 		       "71:     movl 44(%4), %%edx\n"
-		       "        movl %%eax, 40(%3)\n"
-		       "        movl %%edx, 44(%3)\n"
+		       "        movl %%eax, %%es:40(%3)\n"
+		       "        movl %%edx, %%es:44(%3)\n"
 		       "13:     movl 48(%4), %%eax\n"
 		       "81:     movl 52(%4), %%edx\n"
-		       "        movl %%eax, 48(%3)\n"
-		       "        movl %%edx, 52(%3)\n"
+		       "        movl %%eax, %%es:48(%3)\n"
+		       "        movl %%edx, %%es:52(%3)\n"
 		       "14:     movl 56(%4), %%eax\n"
 		       "91:     movl 60(%4), %%edx\n"
-		       "        movl %%eax, 56(%3)\n"
-		       "        movl %%edx, 60(%3)\n"
+		       "        movl %%eax, %%es:56(%3)\n"
+		       "        movl %%edx, %%es:60(%3)\n"
 		       "        addl $-64, %0\n"     
 		       "        addl $64, %4\n"      
 		       "        addl $64, %3\n"      
@@ -387,6 +514,8 @@ __copy_user_zeroing_intel(void *to, cons
 		       "        movl %%eax,%0\n"
 		       "7:      rep; movsb\n"	
 		       "8:\n"			
+		       "        pushl %%ss\n"
+		       "        popl %%ds\n"
 		       ".section .fixup,\"ax\"\n"
 		       "9:      lea 0(%%eax,%0,4),%0\n"	
 		       "16:     pushl %0\n"	
@@ -421,7 +550,7 @@ __copy_user_zeroing_intel(void *to, cons
 		       "        .long 7b,16b\n" 
 		       ".previous"		
 		       : "=&c"(size), "=&D" (d0), "=&S" (d1)
-		       :  "1"(to), "2"(from), "0"(size)
+		       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
 		       : "eax", "edx", "memory");
 	return size;
 }
@@ -437,6 +566,7 @@ static unsigned long __copy_user_zeroing
         int d0, d1;
 
 	__asm__ __volatile__(
+	       "        movw %w6, %%ds\n"
 	       "        .align 2,0x90\n"
 	       "0:      movl 32(%4), %%eax\n"
 	       "        cmpl $67, %0\n"
@@ -445,36 +575,36 @@ static unsigned long __copy_user_zeroing
 	       "        .align 2,0x90\n"
 	       "2:      movl 0(%4), %%eax\n"
 	       "21:     movl 4(%4), %%edx\n"
-	       "        movnti %%eax, 0(%3)\n"
-	       "        movnti %%edx, 4(%3)\n"
+	       "        movnti %%eax, %%es:0(%3)\n"
+	       "        movnti %%edx, %%es:4(%3)\n"
 	       "3:      movl 8(%4), %%eax\n"
 	       "31:     movl 12(%4),%%edx\n"
-	       "        movnti %%eax, 8(%3)\n"
-	       "        movnti %%edx, 12(%3)\n"
+	       "        movnti %%eax, %%es:8(%3)\n"
+	       "        movnti %%edx, %%es:12(%3)\n"
 	       "4:      movl 16(%4), %%eax\n"
 	       "41:     movl 20(%4), %%edx\n"
-	       "        movnti %%eax, 16(%3)\n"
-	       "        movnti %%edx, 20(%3)\n"
+	       "        movnti %%eax, %%es:16(%3)\n"
+	       "        movnti %%edx, %%es:20(%3)\n"
 	       "10:     movl 24(%4), %%eax\n"
 	       "51:     movl 28(%4), %%edx\n"
-	       "        movnti %%eax, 24(%3)\n"
-	       "        movnti %%edx, 28(%3)\n"
+	       "        movnti %%eax, %%es:24(%3)\n"
+	       "        movnti %%edx, %%es:28(%3)\n"
 	       "11:     movl 32(%4), %%eax\n"
 	       "61:     movl 36(%4), %%edx\n"
-	       "        movnti %%eax, 32(%3)\n"
-	       "        movnti %%edx, 36(%3)\n"
+	       "        movnti %%eax, %%es:32(%3)\n"
+	       "        movnti %%edx, %%es:36(%3)\n"
 	       "12:     movl 40(%4), %%eax\n"
 	       "71:     movl 44(%4), %%edx\n"
-	       "        movnti %%eax, 40(%3)\n"
-	       "        movnti %%edx, 44(%3)\n"
+	       "        movnti %%eax, %%es:40(%3)\n"
+	       "        movnti %%edx, %%es:44(%3)\n"
 	       "13:     movl 48(%4), %%eax\n"
 	       "81:     movl 52(%4), %%edx\n"
-	       "        movnti %%eax, 48(%3)\n"
-	       "        movnti %%edx, 52(%3)\n"
+	       "        movnti %%eax, %%es:48(%3)\n"
+	       "        movnti %%edx, %%es:52(%3)\n"
 	       "14:     movl 56(%4), %%eax\n"
 	       "91:     movl 60(%4), %%edx\n"
-	       "        movnti %%eax, 56(%3)\n"
-	       "        movnti %%edx, 60(%3)\n"
+	       "        movnti %%eax, %%es:56(%3)\n"
+	       "        movnti %%edx, %%es:60(%3)\n"
 	       "        addl $-64, %0\n"
 	       "        addl $64, %4\n"
 	       "        addl $64, %3\n"
@@ -489,6 +619,8 @@ static unsigned long __copy_user_zeroing
 	       "        movl %%eax,%0\n"
 	       "7:      rep; movsb\n"
 	       "8:\n"
+	       "        pushl %%ss\n"
+	       "        popl %%ds\n"
 	       ".section .fixup,\"ax\"\n"
 	       "9:      lea 0(%%eax,%0,4),%0\n"
 	       "16:     pushl %0\n"
@@ -523,7 +655,7 @@ static unsigned long __copy_user_zeroing
 	       "        .long 7b,16b\n"
 	       ".previous"
 	       : "=&c"(size), "=&D" (d0), "=&S" (d1)
-	       :  "1"(to), "2"(from), "0"(size)
+	       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
 	       : "eax", "edx", "memory");
 	return size;
 }
@@ -534,6 +666,7 @@ static unsigned long __copy_user_intel_n
         int d0, d1;
 
 	__asm__ __volatile__(
+	       "        movw %w6, %%ds\n"
 	       "        .align 2,0x90\n"
 	       "0:      movl 32(%4), %%eax\n"
 	       "        cmpl $67, %0\n"
@@ -542,36 +675,36 @@ static unsigned long __copy_user_intel_n
 	       "        .align 2,0x90\n"
 	       "2:      movl 0(%4), %%eax\n"
 	       "21:     movl 4(%4), %%edx\n"
-	       "        movnti %%eax, 0(%3)\n"
-	       "        movnti %%edx, 4(%3)\n"
+	       "        movnti %%eax, %%es:0(%3)\n"
+	       "        movnti %%edx, %%es:4(%3)\n"
 	       "3:      movl 8(%4), %%eax\n"
 	       "31:     movl 12(%4),%%edx\n"
-	       "        movnti %%eax, 8(%3)\n"
-	       "        movnti %%edx, 12(%3)\n"
+	       "        movnti %%eax, %%es:8(%3)\n"
+	       "        movnti %%edx, %%es:12(%3)\n"
 	       "4:      movl 16(%4), %%eax\n"
 	       "41:     movl 20(%4), %%edx\n"
-	       "        movnti %%eax, 16(%3)\n"
-	       "        movnti %%edx, 20(%3)\n"
+	       "        movnti %%eax, %%es:16(%3)\n"
+	       "        movnti %%edx, %%es:20(%3)\n"
 	       "10:     movl 24(%4), %%eax\n"
 	       "51:     movl 28(%4), %%edx\n"
-	       "        movnti %%eax, 24(%3)\n"
-	       "        movnti %%edx, 28(%3)\n"
+	       "        movnti %%eax, %%es:24(%3)\n"
+	       "        movnti %%edx, %%es:28(%3)\n"
 	       "11:     movl 32(%4), %%eax\n"
 	       "61:     movl 36(%4), %%edx\n"
-	       "        movnti %%eax, 32(%3)\n"
-	       "        movnti %%edx, 36(%3)\n"
+	       "        movnti %%eax, %%es:32(%3)\n"
+	       "        movnti %%edx, %%es:36(%3)\n"
 	       "12:     movl 40(%4), %%eax\n"
 	       "71:     movl 44(%4), %%edx\n"
-	       "        movnti %%eax, 40(%3)\n"
-	       "        movnti %%edx, 44(%3)\n"
+	       "        movnti %%eax, %%es:40(%3)\n"
+	       "        movnti %%edx, %%es:44(%3)\n"
 	       "13:     movl 48(%4), %%eax\n"
 	       "81:     movl 52(%4), %%edx\n"
-	       "        movnti %%eax, 48(%3)\n"
-	       "        movnti %%edx, 52(%3)\n"
+	       "        movnti %%eax, %%es:48(%3)\n"
+	       "        movnti %%edx, %%es:52(%3)\n"
 	       "14:     movl 56(%4), %%eax\n"
 	       "91:     movl 60(%4), %%edx\n"
-	       "        movnti %%eax, 56(%3)\n"
-	       "        movnti %%edx, 60(%3)\n"
+	       "        movnti %%eax, %%es:56(%3)\n"
+	       "        movnti %%edx, %%es:60(%3)\n"
 	       "        addl $-64, %0\n"
 	       "        addl $64, %4\n"
 	       "        addl $64, %3\n"
@@ -586,6 +719,8 @@ static unsigned long __copy_user_intel_n
 	       "        movl %%eax,%0\n"
 	       "7:      rep; movsb\n"
 	       "8:\n"
+	       "        pushl %%ss\n"
+	       "        popl %%ds\n"
 	       ".section .fixup,\"ax\"\n"
 	       "9:      lea 0(%%eax,%0,4),%0\n"
 	       "16:     jmp 8b\n"
@@ -614,7 +749,7 @@ static unsigned long __copy_user_intel_n
 	       "        .long 7b,16b\n"
 	       ".previous"
 	       : "=&c"(size), "=&D" (d0), "=&S" (d1)
-	       :  "1"(to), "2"(from), "0"(size)
+	       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
 	       : "eax", "edx", "memory");
 	return size;
 }
@@ -627,90 +762,146 @@ static unsigned long __copy_user_intel_n
  */
 unsigned long __copy_user_zeroing_intel(void *to, const void __user *from,
 					unsigned long size);
-unsigned long __copy_user_intel(void __user *to, const void *from,
+unsigned long __generic_copy_to_user_intel(void __user *to, const void *from,
+					unsigned long size);
+unsigned long __generic_copy_from_user_intel(void *to, const void __user *from,
 					unsigned long size);
 unsigned long __copy_user_zeroing_intel_nocache(void *to,
 				const void __user *from, unsigned long size);
 #endif /* CONFIG_X86_INTEL_USERCOPY */
 
 /* Generic arbitrary sized copy.  */
-#define __copy_user(to,from,size)					\
-do {									\
-	int __d0, __d1, __d2;						\
-	__asm__ __volatile__(						\
-		"	cmp  $7,%0\n"					\
-		"	jbe  1f\n"					\
-		"	movl %1,%0\n"					\
-		"	negl %0\n"					\
-		"	andl $7,%0\n"					\
-		"	subl %0,%3\n"					\
-		"4:	rep; movsb\n"					\
-		"	movl %3,%0\n"					\
-		"	shrl $2,%0\n"					\
-		"	andl $3,%3\n"					\
-		"	.align 2,0x90\n"				\
-		"0:	rep; movsl\n"					\
-		"	movl %3,%0\n"					\
-		"1:	rep; movsb\n"					\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"5:	addl %3,%0\n"					\
-		"	jmp 2b\n"					\
-		"3:	lea 0(%3,%0,4),%0\n"				\
-		"	jmp 2b\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.align 4\n"					\
-		"	.long 4b,5b\n"					\
-		"	.long 0b,3b\n"					\
-		"	.long 1b,2b\n"					\
-		".previous"						\
-		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)	\
-		: "3"(size), "0"(size), "1"(to), "2"(from)		\
-		: "memory");						\
-} while (0)
-
-#define __copy_user_zeroing(to,from,size)				\
-do {									\
-	int __d0, __d1, __d2;						\
-	__asm__ __volatile__(						\
-		"	cmp  $7,%0\n"					\
-		"	jbe  1f\n"					\
-		"	movl %1,%0\n"					\
-		"	negl %0\n"					\
-		"	andl $7,%0\n"					\
-		"	subl %0,%3\n"					\
-		"4:	rep; movsb\n"					\
-		"	movl %3,%0\n"					\
-		"	shrl $2,%0\n"					\
-		"	andl $3,%3\n"					\
-		"	.align 2,0x90\n"				\
-		"0:	rep; movsl\n"					\
-		"	movl %3,%0\n"					\
-		"1:	rep; movsb\n"					\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"5:	addl %3,%0\n"					\
-		"	jmp 6f\n"					\
-		"3:	lea 0(%3,%0,4),%0\n"				\
-		"6:	pushl %0\n"					\
-		"	pushl %%eax\n"					\
-		"	xorl %%eax,%%eax\n"				\
-		"	rep; stosb\n"					\
-		"	popl %%eax\n"					\
-		"	popl %0\n"					\
-		"	jmp 2b\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.align 4\n"					\
-		"	.long 4b,5b\n"					\
-		"	.long 0b,3b\n"					\
-		"	.long 1b,6b\n"					\
-		".previous"						\
-		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)	\
-		: "3"(size), "0"(size), "1"(to), "2"(from)		\
-		: "memory");						\
-} while (0)
+static unsigned long
+__generic_copy_to_user(void __user *to, const void *from, unsigned long size)
+{
+	int __d0, __d1, __d2;
+
+	__asm__ __volatile__(
+		"	movw %w8,%%es\n"
+		"	cmp  $7,%0\n"
+		"	jbe  1f\n"
+		"	movl %1,%0\n"
+		"	negl %0\n"
+		"	andl $7,%0\n"
+		"	subl %0,%3\n"
+		"4:	rep; movsb\n"
+		"	movl %3,%0\n"
+		"	shrl $2,%0\n"
+		"	andl $3,%3\n"
+		"	.align 2,0x90\n"
+		"0:	rep; movsl\n"
+		"	movl %3,%0\n"
+		"1:	rep; movsb\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%es\n"
+		".section .fixup,\"ax\"\n"
+		"5:	addl %3,%0\n"
+		"	jmp 2b\n"
+		"3:	lea 0(%3,%0,4),%0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.align 4\n"
+		"	.long 4b,5b\n"
+		"	.long 0b,3b\n"
+		"	.long 1b,2b\n"
+		".previous"
+		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)
+		: "3"(size), "0"(size), "1"(to), "2"(from), "r"(__USER_DS)
+		: "memory");
+	return size;
+}
+
+static unsigned long
+__generic_copy_from_user(void *to, const void __user *from, unsigned long size)
+{
+	int __d0, __d1, __d2;
+
+	__asm__ __volatile__(
+		"	movw %w8,%%ds\n"
+		"	cmp  $7,%0\n"
+		"	jbe  1f\n"
+		"	movl %1,%0\n"
+		"	negl %0\n"
+		"	andl $7,%0\n"
+		"	subl %0,%3\n"
+		"4:	rep; movsb\n"
+		"	movl %3,%0\n"
+		"	shrl $2,%0\n"
+		"	andl $3,%3\n"
+		"	.align 2,0x90\n"
+		"0:	rep; movsl\n"
+		"	movl %3,%0\n"
+		"1:	rep; movsb\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%ds\n"
+		".section .fixup,\"ax\"\n"
+		"5:	addl %3,%0\n"
+		"	jmp 2b\n"
+		"3:	lea 0(%3,%0,4),%0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.align 4\n"
+		"	.long 4b,5b\n"
+		"	.long 0b,3b\n"
+		"	.long 1b,2b\n"
+		".previous"
+		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)
+		: "3"(size), "0"(size), "1"(to), "2"(from), "r"(__USER_DS)
+		: "memory");
+	return size;
+}
+
+static unsigned long
+__copy_user_zeroing(void *to, const void __user *from, unsigned long size)
+{
+	int __d0, __d1, __d2;
+
+	__asm__ __volatile__(
+		"	movw %w8,%%ds\n"
+		"	cmp  $7,%0\n"
+		"	jbe  1f\n"
+		"	movl %1,%0\n"
+		"	negl %0\n"
+		"	andl $7,%0\n"
+		"	subl %0,%3\n"
+		"4:	rep; movsb\n"
+		"	movl %3,%0\n"
+		"	shrl $2,%0\n"
+		"	andl $3,%3\n"
+		"	.align 2,0x90\n"
+		"0:	rep; movsl\n"
+		"	movl %3,%0\n"
+		"1:	rep; movsb\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%ds\n"
+		".section .fixup,\"ax\"\n"
+		"5:	addl %3,%0\n"
+		"	jmp 6f\n"
+		"3:	lea 0(%3,%0,4),%0\n"
+		"6:	pushl %0\n"
+		"	pushl %%eax\n"
+		"	xorl %%eax,%%eax\n"
+		"	rep; stosb\n"
+		"	popl %%eax\n"
+		"	popl %0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.align 4\n"
+		"	.long 4b,5b\n"
+		"	.long 0b,3b\n"
+		"	.long 1b,6b\n"
+		".previous"
+		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)
+		: "3"(size), "0"(size), "1"(to), "2"(from), "r"(__USER_DS)
+		: "memory");
+	return size;
+}
 
 unsigned long __copy_to_user_ll(void __user *to, const void *from,
 				unsigned long n)
@@ -766,9 +957,9 @@ survive:
 	}
 #endif
 	if (movsl_is_ok(to, from, n))
-		__copy_user(to, from, n);
+		n = __generic_copy_to_user(to, from, n);
 	else
-		n = __copy_user_intel(to, from, n);
+		n = __generic_copy_to_user_intel(to, from, n);
 	return n;
 }
 EXPORT_SYMBOL(__copy_to_user_ll);
@@ -778,7 +969,7 @@ unsigned long __copy_from_user_ll(void *
 {
 	BUG_ON((long)n < 0);
 	if (movsl_is_ok(to, from, n))
-		__copy_user_zeroing(to, from, n);
+		n = __copy_user_zeroing(to, from, n);
 	else
 		n = __copy_user_zeroing_intel(to, from, n);
 	return n;
@@ -790,10 +981,9 @@ unsigned long __copy_from_user_ll_nozero
 {
 	BUG_ON((long)n < 0);
 	if (movsl_is_ok(to, from, n))
-		__copy_user(to, from, n);
+		n = __generic_copy_from_user(to, from, n);
 	else
-		n = __copy_user_intel((void __user *)to,
-				      (const void *)from, n);
+		n = __generic_copy_from_user_intel(to, from, n);
 	return n;
 }
 EXPORT_SYMBOL(__copy_from_user_ll_nozero);
@@ -804,11 +994,11 @@ unsigned long __copy_from_user_ll_nocach
 	BUG_ON((long)n < 0);
 #ifdef CONFIG_X86_INTEL_USERCOPY
 	if ( n > 64 && cpu_has_xmm2)
-                n = __copy_user_zeroing_intel_nocache(to, from, n);
+		n = __copy_user_zeroing_intel_nocache(to, from, n);
 	else
-		__copy_user_zeroing(to, from, n);
+		n = __copy_user_zeroing(to, from, n);
 #else
-        __copy_user_zeroing(to, from, n);
+	n = __copy_user_zeroing(to, from, n);
 #endif
 	return n;
 }
@@ -819,11 +1009,11 @@ unsigned long __copy_from_user_ll_nocach
 	BUG_ON((long)n < 0);
 #ifdef CONFIG_X86_INTEL_USERCOPY
 	if ( n > 64 && cpu_has_xmm2)
-                n = __copy_user_intel_nocache(to, from, n);
+		n = __copy_user_intel_nocache(to, from, n);
 	else
-		__copy_user(to, from, n);
+		n = __generic_copy_from_user(to, from, n);
 #else
-        __copy_user(to, from, n);
+	n = __generic_copy_from_user(to, from, n);
 #endif
 	return n;
 }
@@ -878,3 +1068,31 @@ copy_from_user(void *to, const void __us
 	return n;
 }
 EXPORT_SYMBOL(copy_from_user);
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+void __set_fs(mm_segment_t x, int cpu)
+{
+	unsigned long limit = x.seg;
+	__u32 a, b;
+
+	current_thread_info()->addr_limit = x;
+	if (likely(limit))
+		limit -= 1UL;
+
+	pack_descriptor(&a, &b, 0UL, limit, 0xF3, 0xC);
+	write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_DEFAULT_USER_DS, a, b);
+}
+
+void set_fs(mm_segment_t x)
+{
+	__set_fs(x, get_cpu());
+	put_cpu_no_resched();
+}
+#else
+void set_fs(mm_segment_t x)
+{
+	current_thread_info()->addr_limit = x;
+}
+#endif
+
+EXPORT_SYMBOL(set_fs);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mach-default/setup.c linux-2.6.20.1-pax/arch/i386/mach-default/setup.c
--- linux-2.6.20.1/arch/i386/mach-default/setup.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mach-default/setup.c	2007-02-15 02:21:37.000000000 +0100
@@ -35,7 +35,7 @@ void __init pre_intr_init_hook(void)
 /*
  * IRQ2 is cascade interrupt to second interrupt controller
  */
-static struct irqaction irq2 = { no_action, 0, CPU_MASK_NONE, "cascade", NULL, NULL};
+static struct irqaction irq2 = { no_action, 0, CPU_MASK_NONE, "cascade", NULL, NULL, 0, NULL};
 
 /**
  * intr_init_hook - post gate setup interrupt initialisation
@@ -79,7 +79,7 @@ void __init trap_init_hook(void)
 {
 }
 
-static struct irqaction irq0  = { timer_interrupt, IRQF_DISABLED, CPU_MASK_NONE, "timer", NULL, NULL};
+static struct irqaction irq0  = { timer_interrupt, IRQF_DISABLED, CPU_MASK_NONE, "timer", NULL, NULL, 0, NULL};
 
 /**
  * time_init_hook - do any specific initialisations for the system timer.
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mach-voyager/voyager_smp.c linux-2.6.20.1-pax/arch/i386/mach-voyager/voyager_smp.c
--- linux-2.6.20.1/arch/i386/mach-voyager/voyager_smp.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mach-voyager/voyager_smp.c	2007-02-15 01:29:24.000000000 +0100
@@ -583,11 +583,7 @@ do_boot_cpu(__u8 cpu)
 	/* Pre-allocate and initialize the CPU's GDT and PDA so it
 	   doesn't have to do any memory allocation during the
 	   delicate CPU-bringup phase. */
-	if (!init_gdt(cpu, idle)) {
-		printk(KERN_INFO "Couldn't allocate GDT/PDA for CPU %d\n", cpu);
-		cpucount--;
-		return;
-	}
+	init_gdt(cpu, idle);
 
 	irq_ctx_init(cpu);
 
@@ -1322,7 +1318,7 @@ smp_local_timer_interrupt(void)
 						per_cpu(prof_counter, cpu);
 		}
 
-		update_process_times(user_mode_vm(get_irq_regs()));
+		update_process_times(user_mode(get_irq_regs()));
 	}
 
 	if( ((1<<cpu) & voyager_extended_vic_processors) == 0)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mm/boot_ioremap.c linux-2.6.20.1-pax/arch/i386/mm/boot_ioremap.c
--- linux-2.6.20.1/arch/i386/mm/boot_ioremap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mm/boot_ioremap.c	2007-02-05 00:56:18.000000000 +0100
@@ -7,15 +7,6 @@
  * Written by Dave Hansen <haveblue@us.ibm.com>
  */
 
-
-/*
- * We need to use the 2-level pagetable functions, but CONFIG_X86_PAE
- * keeps that from happenning.  If anyone has a better way, I'm listening.
- *
- * boot_pte_t is defined only if this all works correctly
- */
-
-#undef CONFIG_X86_PAE
 #undef CONFIG_PARAVIRT
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -23,41 +14,29 @@
 #include <linux/init.h>
 #include <linux/stddef.h>
 
-/* 
- * I'm cheating here.  It is known that the two boot PTE pages are 
- * allocated next to each other.  I'm pretending that they're just
- * one big array. 
- */
-
-#define BOOT_PTE_PTRS (PTRS_PER_PTE*2)
-
-static unsigned long boot_pte_index(unsigned long vaddr) 
-{
-	return __pa(vaddr) >> PAGE_SHIFT;
-}
-
-static inline boot_pte_t* boot_vaddr_to_pte(void *address)
-{
-	boot_pte_t* boot_pg = (boot_pte_t*)pg0;
-	return &boot_pg[boot_pte_index((unsigned long)address)];
-}
-
 /*
  * This is only for a caller who is clever enough to page-align
  * phys_addr and virtual_source, and who also has a preference
  * about which virtual address from which to steal ptes
  */
-static void __boot_ioremap(unsigned long phys_addr, unsigned long nrpages, 
-		    void* virtual_source)
+static void __init __boot_ioremap(unsigned long phys_addr, unsigned long nrpages, 
+		    char* virtual_source)
 {
-	boot_pte_t* pte;
-	int i;
-	char *vaddr = virtual_source;
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t* pte;
+	unsigned int i;
+	unsigned long vaddr = (unsigned long)virtual_source;
+
+	pgd = pgd_offset_k(vaddr);
+	pud = pud_offset(pgd, vaddr);
+	pmd = pmd_offset(pud, vaddr);
+	pte = pte_offset_kernel(pmd, vaddr);
 
-	pte = boot_vaddr_to_pte(virtual_source);
 	for (i=0; i < nrpages; i++, phys_addr += PAGE_SIZE, pte++) {
 		set_pte(pte, pfn_pte(phys_addr>>PAGE_SHIFT, PAGE_KERNEL));
-		__flush_tlb_one(&vaddr[i*PAGE_SIZE]);
+		__flush_tlb_one(&virtual_source[i*PAGE_SIZE]);
 	}
 }
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mm/extable.c linux-2.6.20.1-pax/arch/i386/mm/extable.c
--- linux-2.6.20.1/arch/i386/mm/extable.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mm/extable.c	2007-02-05 00:56:18.000000000 +0100
@@ -11,7 +11,7 @@ int fixup_exception(struct pt_regs *regs
 	const struct exception_table_entry *fixup;
 
 #ifdef CONFIG_PNPBIOS
-	if (unlikely(SEGMENT_IS_PNP_CODE(regs->xcs)))
+	if (unlikely(!(regs->eflags & VM_MASK) && SEGMENT_IS_PNP_CODE(regs->xcs)))
 	{
 		extern u32 pnp_bios_fault_eip, pnp_bios_fault_esp;
 		extern u32 pnp_bios_is_utter_crap;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mm/fault.c linux-2.6.20.1-pax/arch/i386/mm/fault.c
--- linux-2.6.20.1/arch/i386/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mm/fault.c	2007-02-05 00:56:18.000000000 +0100
@@ -23,6 +23,9 @@
 #include <linux/module.h>
 #include <linux/kprobes.h>
 #include <linux/uaccess.h>
+#include <linux/unistd.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
 
 #include <asm/system.h>
 #include <asm/desc.h>
@@ -104,7 +107,8 @@ static inline unsigned long get_segment_
 {
 	unsigned long eip = regs->eip;
 	unsigned seg = regs->xcs & 0xffff;
-	u32 seg_ar, seg_limit, base, *desc;
+	u32 seg_ar, seg_limit, base;
+	struct desc_struct *desc;
 
 	/* Unlikely, but must come before segment checks. */
 	if (unlikely(regs->eflags & VM_MASK)) {
@@ -118,7 +122,7 @@ static inline unsigned long get_segment_
 	
 	/* By far the most common cases. */
 	if (likely(SEGMENT_IS_FLAT_CODE(seg)))
-		return eip;
+		return eip + (seg == __KERNEL_CS ? __KERNEL_TEXT_OFFSET : 0);
 
 	/* Check the segment exists, is within the current LDT/GDT size,
 	   that kernel/user (ring 0..3) has the appropriate privilege,
@@ -136,16 +140,14 @@ static inline unsigned long get_segment_
 	if (seg & (1<<2)) {
 		/* Must lock the LDT while reading it. */
 		down(&current->mm->context.sem);
-		desc = current->mm->context.ldt;
-		desc = (void *)desc + (seg & ~7);
+		desc = &current->mm->context.ldt[seg >> 3];
 	} else {
 		/* Must disable preemption while reading the GDT. */
- 		desc = (u32 *)get_cpu_gdt_table(get_cpu());
-		desc = (void *)desc + (seg & ~7);
+		desc = &get_cpu_gdt_table(get_cpu())[seg >> 3];
 	}
 
 	/* Decode the code segment base from the descriptor */
-	base = get_desc_base((unsigned long *)desc);
+	base = get_desc_base(desc);
 
 	if (seg & (1<<2)) { 
 		up(&current->mm->context.sem);
@@ -246,6 +248,30 @@ static noinline void force_sig_info_faul
 
 fastcall void do_invalid_op(struct pt_regs *, unsigned long);
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+static int pax_handle_fetch_fault(struct pt_regs *regs);
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+static inline pmd_t * pax_get_pmd(struct mm_struct *mm, unsigned long address)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+
+	pgd = pgd_offset(mm, address);
+	if (!pgd_present(*pgd))
+		return NULL;
+	pud = pud_offset(pgd, address);
+	if (!pud_present(*pud))
+		return NULL;
+	pmd = pmd_offset(pud, address);
+	if (!pmd_present(*pmd))
+		return NULL;
+	return pmd;
+}
+#endif
+
 static inline pmd_t *vmalloc_sync_one(pgd_t *pgd, unsigned long address)
 {
 	unsigned index = pgd_index(address);
@@ -326,14 +352,20 @@ fastcall void __kprobes do_page_fault(st
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
-	unsigned long address;
-	unsigned long page;
 	int write, si_code;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	pmd_t *pmd;
+	pte_t *pte;
+	spinlock_t *ptl;
+	unsigned char pte_mask;
+#endif
+
 	/* get the address */
-        address = read_cr2();
+	const unsigned long address = read_cr2();
 
 	tsk = current;
+	mm = tsk->mm;
 
 	si_code = SEGV_MAPERR;
 
@@ -372,14 +404,12 @@ fastcall void __kprobes do_page_fault(st
 	if (regs->eflags & (X86_EFLAGS_IF|VM_MASK))
 		local_irq_enable();
 
-	mm = tsk->mm;
-
 	/*
 	 * If we're in an interrupt, have no user context or are running in an
 	 * atomic region then we must not take the fault..
 	 */
 	if (in_atomic() || !mm)
-		goto bad_area_nosemaphore;
+		goto bad_area_nopax;
 
 	/* When running in the kernel we expect faults to occur only to
 	 * addresses in user space.  All other faults represent errors in the
@@ -399,10 +429,101 @@ fastcall void __kprobes do_page_fault(st
 	if (!down_read_trylock(&mm->mmap_sem)) {
 		if ((error_code & 4) == 0 &&
 		    !search_exception_tables(regs->eip))
-			goto bad_area_nosemaphore;
+			goto bad_area_nopax;
 		down_read(&mm->mmap_sem);
 	}
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (unlikely((error_code & 5) != 5 ||
+		     (regs->eflags & X86_EFLAGS_VM) ||
+		     !(mm->pax_flags & MF_PAX_PAGEEXEC)))
+		goto not_pax_fault;
+
+	/* PaX: it's our fault, let's handle it if we can */
+
+	/* PaX: take a look at read faults before acquiring any locks */
+	if (unlikely(!(error_code & 2) && (regs->eip == address))) {
+		/* instruction fetch attempt from a protected page in user mode */
+		up_read(&mm->mmap_sem);
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		switch (pax_handle_fetch_fault(regs)) {
+		case 2:
+			return;
+		}
+#endif
+
+		pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+		do_exit(SIGKILL);
+	}
+
+	pmd = pax_get_pmd(mm, address);
+	if (unlikely(!pmd))
+		goto not_pax_fault;
+
+	pte = pte_offset_map_lock(mm, pmd, address, &ptl);
+	if (unlikely(!(pte_val(*pte) & _PAGE_PRESENT) || pte_user(*pte))) {
+		pte_unmap_unlock(pte, ptl);
+		goto not_pax_fault;
+	}
+
+	if (unlikely((error_code & 2) && !pte_write(*pte))) {
+		/* write attempt to a protected page in user mode */
+		pte_unmap_unlock(pte, ptl);
+		goto not_pax_fault;
+	}
+
+#ifdef CONFIG_SMP
+	if (likely(address > get_limit(regs->xcs) && cpu_isset(smp_processor_id(), mm->context.cpu_user_cs_mask)))
+#else
+	if (likely(address > get_limit(regs->xcs)))
+#endif
+	{
+		set_pte(pte, pte_mkread(*pte));
+		__flush_tlb_one(address);
+		pte_unmap_unlock(pte, ptl);
+		up_read(&mm->mmap_sem);
+		return;
+	}
+
+	pte_mask = _PAGE_ACCESSED | _PAGE_USER | ((error_code & 2) << (_PAGE_BIT_DIRTY-1));
+
+	/*
+	 * PaX: fill DTLB with user rights and retry
+	 */
+	__asm__ __volatile__ (
+		"movw %w4,%%ds\n"
+		"orb %2,%%ss:(%1)\n"
+#if defined(CONFIG_M586) || defined(CONFIG_M586TSC)
+/*
+ * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's
+ * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+ * page fault when examined during a TLB load attempt. this is true not only
+ * for PTEs holding a non-present entry but also present entries that will
+ * raise a page fault (such as those set up by PaX, or the copy-on-write
+ * mechanism). in effect it means that we do *not* need to flush the TLBs
+ * for our target pages since their PTEs are simply not in the TLBs at all.
+
+ * the best thing in omitting it is that we gain around 15-20% speed in the
+ * fast path of the page fault handler and can get rid of tracing since we
+ * can no longer flush unintended entries.
+ */
+		"invlpg (%0)\n"
+#endif
+		"testb $0,(%0)\n"
+		"xorb %3,%%ss:(%1)\n"
+		"pushl %%ss\n"
+		"popl %%ds\n"
+		:
+		: "q" (address), "r" (pte), "q" (pte_mask), "i" (_PAGE_USER), "r" (__USER_DS)
+		: "memory", "cc");
+	pte_unmap_unlock(pte, ptl);
+	up_read(&mm->mmap_sem);
+	return;
+
+not_pax_fault:
+#endif
+
 	vma = find_vma(mm, address);
 	if (!vma)
 		goto bad_area;
@@ -420,6 +541,12 @@ fastcall void __kprobes do_page_fault(st
 		if (address + 65536 + 32 * sizeof(unsigned long) < regs->esp)
 			goto bad_area;
 	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_end - SEGMEXEC_TASK_SIZE - 1 < address - SEGMEXEC_TASK_SIZE - 1)
+		goto bad_area;
+#endif
+
 	if (expand_stack(vma, address))
 		goto bad_area;
 /*
@@ -484,6 +611,36 @@ bad_area:
 	up_read(&mm->mmap_sem);
 
 bad_area_nosemaphore:
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm && (error_code & 4) && !(regs->eflags & X86_EFLAGS_VM)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && !(error_code & 3) && (regs->eip == address)) {
+			pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+			do_exit(SIGKILL);
+		}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((mm->pax_flags & MF_PAX_SEGMEXEC) && !(error_code & 3) && (regs->eip + SEGMEXEC_TASK_SIZE == address)) {
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			switch (pax_handle_fetch_fault(regs)) {
+			case 2:
+				return;
+			}
+#endif
+
+			pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+			do_exit(SIGKILL);
+		}
+#endif
+
+	}
+#endif
+
+bad_area_nopax:
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & 4) {
 		/* 
@@ -551,6 +708,17 @@ no_context:
 		if (address < PAGE_SIZE)
 			printk(KERN_ALERT "BUG: unable to handle kernel NULL "
 					"pointer dereference");
+
+#ifdef CONFIG_PAX_KERNEXEC
+#ifdef CONFIG_MODULES
+		else if (init_mm.start_code <= address && address < (unsigned long)MODULES_END)
+#else
+		else if (init_mm.start_code <= address && address < init_mm.end_code)
+#endif
+			printk(KERN_ERR "PAX: %s:%d, uid/euid: %u/%u, attempted to modify kernel code",
+					 tsk->comm, tsk->pid, tsk->uid, tsk->euid);
+#endif
+
 		else
 			printk(KERN_ALERT "BUG: unable to handle kernel paging"
 					" request");
@@ -558,24 +726,34 @@ no_context:
 		printk(KERN_ALERT " printing eip:\n");
 		printk("%08lx\n", regs->eip);
 	}
-	page = read_cr3();
-	page = ((unsigned long *) __va(page))[address >> 22];
-	if (oops_may_print())
-		printk(KERN_ALERT "*pde = %08lx\n", page);
-	/*
-	 * We must not directly access the pte in the highpte
-	 * case, the page table might be allocated in highmem.
-	 * And lets rather not kmap-atomic the pte, just in case
-	 * it's allocated already.
-	 */
+
+	if (oops_may_print()) {
+		unsigned long index = pgd_index(address);
+		pgd_t *pgd;
+		pud_t *pud;
+		pmd_t *pmd;
+		pte_t *pte;
+
+		pgd = index + (pgd_t *)__va(read_cr3());
+		printk(KERN_ALERT "*pgd = %*llx\n", sizeof(*pgd), (unsigned long long)pgd_val(*pgd));
+		if (pgd_present(*pgd)) {
+			pud = pud_offset(pgd, address);
+			pmd = pmd_offset(pud, address);
+			printk(KERN_ALERT "*pmd = %*llx\n", sizeof(*pmd), (unsigned long long)pmd_val(*pmd));
+			/*
+			 * We must not directly access the pte in the highpte
+			 * case, the page table might be allocated in highmem.
+			 * And lets rather not kmap-atomic the pte, just in case
+			 * it's allocated already.
+			 */
 #ifndef CONFIG_HIGHPTE
-	if ((page & 1) && oops_may_print()) {
-		page &= PAGE_MASK;
-		address &= 0x003ff000;
-		page = ((unsigned long *) __va(page))[address >> PAGE_SHIFT];
-		printk(KERN_ALERT "*pte = %08lx\n", page);
-	}
+			if (pmd_present(*pmd) && !pmd_large(*pmd)) {
+				pte = pte_offset_kernel(pmd, address);
+				printk(KERN_ALERT "*pte = %*llx\n", sizeof(*pte), (unsigned long long)pte_val(*pte));
+			}
 #endif
+		}
+	}
 	tsk->thread.cr2 = address;
 	tsk->thread.trap_no = 14;
 	tsk->thread.error_code = error_code;
@@ -652,3 +830,101 @@ void vmalloc_sync_all(void)
 	}
 }
 #endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+/*
+ * PaX: decide what to do with offenders (regs->eip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when gcc trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+	static const unsigned char trans[8] = {6, 1, 2, 0, 13, 5, 3, 4};
+	int err;
+
+	if (regs->eflags & X86_EFLAGS_VM)
+		return 1;
+
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+
+	do { /* PaX: gcc trampoline emulation #1 */
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov1, (unsigned char __user *)regs->eip);
+		err |= get_user(addr1, (unsigned long __user *)(regs->eip + 1));
+		err |= get_user(mov2, (unsigned char __user *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long __user *)(regs->eip + 6));
+		err |= get_user(jmp, (unsigned short __user *)(regs->eip + 10));
+
+		if (err)
+			break;
+
+		if ((mov1 & 0xF8) == 0xB8 &&
+		    (mov2 & 0xF8) == 0xB8 &&
+		    (mov1 & 0x07) != (mov2 & 0x07) &&
+		    (jmp & 0xF8FF) == 0xE0FF &&
+		    (mov2 & 0x07) == ((jmp>>8) & 0x07))
+		{
+			((unsigned long *)regs)[trans[mov1 & 0x07]] = addr1;
+			((unsigned long *)regs)[trans[mov2 & 0x07]] = addr2;
+			regs->eip = addr2;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #2 */
+		unsigned char mov, jmp;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov, (unsigned char __user *)regs->eip);
+		err |= get_user(addr1, (unsigned long __user *)(regs->eip + 1));
+		err |= get_user(jmp, (unsigned char __user *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long __user *)(regs->eip + 6));
+
+		if (err)
+			break;
+
+		if ((mov & 0xF8) == 0xB8 &&
+		    jmp == 0xE9)
+		{
+			((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+			regs->eip += addr2 + 10;
+			return 2;
+		}
+	} while (0);
+
+	return 1; /* PaX in action */
+}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_insns(void *pc, void *sp)
+{
+	long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char __user *)pc+i))
+			printk("?? ");
+		else
+			printk("%02x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP-4: ");
+	for (i = -1; i < 20; i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long __user *)sp+i))
+			printk("???????? ");
+		else
+			printk("%08lx ", c);
+	}
+	printk("\n");
+}
+#endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mm/hugetlbpage.c linux-2.6.20.1-pax/arch/i386/mm/hugetlbpage.c
--- linux-2.6.20.1/arch/i386/mm/hugetlbpage.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mm/hugetlbpage.c	2007-02-05 00:56:18.000000000 +0100
@@ -230,7 +230,12 @@ static unsigned long hugetlb_get_unmappe
 {
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
-	unsigned long start_addr;
+	unsigned long start_addr, task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
 
 	if (len > mm->cached_hole_size) {
 	        start_addr = mm->free_area_cache;
@@ -244,7 +249,7 @@ full_search:
 
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
-		if (TASK_SIZE - len < addr) {
+		if (task_size - len < addr) {
 			/*
 			 * Start a new search - just in case we missed
 			 * some holes.
@@ -272,9 +277,8 @@ static unsigned long hugetlb_get_unmappe
 {
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma, *prev_vma;
-	unsigned long base = mm->mmap_base, addr = addr0;
+	unsigned long base = mm->mmap_base, addr;
 	unsigned long largest_hole = mm->cached_hole_size;
-	int first_time = 1;
 
 	/* don't allow allocations above current base */
 	if (mm->free_area_cache > base)
@@ -284,7 +288,7 @@ static unsigned long hugetlb_get_unmappe
 	        largest_hole = 0;
 		mm->free_area_cache  = base;
 	}
-try_again:
+
 	/* make sure it can fit in the remaining address space */
 	if (mm->free_area_cache < len)
 		goto fail;
@@ -326,16 +330,6 @@ try_again:
 
 fail:
 	/*
-	 * if hint left us with no space for the requested
-	 * mapping then try again:
-	 */
-	if (first_time) {
-		mm->free_area_cache = base;
-		largest_hole = 0;
-		first_time = 0;
-		goto try_again;
-	}
-	/*
 	 * A failed mmap() very likely causes application failure,
 	 * so fall back to the bottom-up function here. This scenario
 	 * can happen with large stack limits and large mmap()
@@ -361,16 +355,23 @@ hugetlb_get_unmapped_area(struct file *f
 {
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
+	unsigned long task_size = TASK_SIZE;
 
 	if (len & ~HPAGE_MASK)
 		return -EINVAL;
-	if (len > TASK_SIZE)
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > task_size || addr > task_size - len)
 		return -ENOMEM;
 
 	if (addr) {
 		addr = ALIGN(addr, HPAGE_SIZE);
 		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
+		if (task_size - len >= addr &&
 		    (!vma || addr + len <= vma->vm_start))
 			return addr;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mm/init.c linux-2.6.20.1-pax/arch/i386/mm/init.c
--- linux-2.6.20.1/arch/i386/mm/init.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mm/init.c	2007-02-05 00:56:18.000000000 +0100
@@ -42,6 +42,7 @@
 #include <asm/tlb.h>
 #include <asm/tlbflush.h>
 #include <asm/sections.h>
+#include <asm/desc.h>
 
 unsigned int __VMALLOC_RESERVE = 128 << 20;
 
@@ -51,30 +52,6 @@ unsigned long highstart_pfn, highend_pfn
 static int noinline do_test_wp_bit(void);
 
 /*
- * Creates a middle page table and puts a pointer to it in the
- * given global directory entry. This only returns the gd entry
- * in non-PAE compilation mode, since the middle layer is folded.
- */
-static pmd_t * __init one_md_table_init(pgd_t *pgd)
-{
-	pud_t *pud;
-	pmd_t *pmd_table;
-		
-#ifdef CONFIG_X86_PAE
-	pmd_table = (pmd_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-	set_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));
-	pud = pud_offset(pgd, 0);
-	if (pmd_table != pmd_offset(pud, 0)) 
-		BUG();
-#else
-	pud = pud_offset(pgd, 0);
-	pmd_table = pmd_offset(pud, 0);
-#endif
-
-	return pmd_table;
-}
-
-/*
  * Create a page table and place a pointer to it in a middle page
  * directory entry.
  */
@@ -82,7 +59,11 @@ static pte_t * __init one_page_table_ini
 {
 	if (pmd_none(*pmd)) {
 		pte_t *page_table = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		set_pmd(pmd, __pmd(__pa(page_table) | _KERNPG_TABLE));
+#else
 		set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));
+#endif
 		if (page_table != pte_offset_kernel(pmd, 0))
 			BUG();	
 
@@ -117,8 +98,6 @@ static void __init page_table_range_init
 	pgd = pgd_base + pgd_idx;
 
 	for ( ; (pgd_idx < PTRS_PER_PGD) && (vaddr != end); pgd++, pgd_idx++) {
-		if (pgd_none(*pgd)) 
-			one_md_table_init(pgd);
 		pud = pud_offset(pgd, vaddr);
 		pmd = pmd_offset(pud, vaddr);
 		for (; (pmd_idx < PTRS_PER_PMD) && (vaddr != end); pmd++, pmd_idx++) {
@@ -131,11 +110,22 @@ static void __init page_table_range_init
 	}
 }
 
-static inline int is_kernel_text(unsigned long addr)
+static inline int is_kernel_text(unsigned long start, unsigned long end)
 {
-	if (addr >= PAGE_OFFSET && addr <= (unsigned long)__init_end)
-		return 1;
-	return 0;
+	unsigned long etext;
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+	etext = (unsigned long)&MODULES_END - __KERNEL_TEXT_OFFSET;
+#else
+	etext = (unsigned long)&_etext;
+#endif
+
+	if ((start > etext + __KERNEL_TEXT_OFFSET ||
+	     end <= (unsigned long)_stext + __KERNEL_TEXT_OFFSET) &&
+	    (start > (unsigned long)_einittext + __KERNEL_TEXT_OFFSET ||
+	     end <= (unsigned long)_sinittext + __KERNEL_TEXT_OFFSET))
+		return 0;
+	return 1;
 }
 
 /*
@@ -147,26 +137,24 @@ static void __init kernel_physical_mappi
 {
 	unsigned long pfn;
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
-	int pgd_idx, pmd_idx, pte_ofs;
+	unsigned int pgd_idx, pmd_idx, pte_ofs;
 
 	pgd_idx = pgd_index(PAGE_OFFSET);
 	pgd = pgd_base + pgd_idx;
 	pfn = 0;
 
-	for (; pgd_idx < PTRS_PER_PGD; pgd++, pgd_idx++) {
-		pmd = one_md_table_init(pgd);
-		if (pfn >= max_low_pfn)
-			continue;
+	for (; pgd_idx < PTRS_PER_PGD && pfn < max_low_pfn; pgd++, pgd_idx++) {
+		pud = pud_offset(pgd, 0);
+		pmd = pmd_offset(pud, 0);
 		for (pmd_idx = 0; pmd_idx < PTRS_PER_PMD && pfn < max_low_pfn; pmd++, pmd_idx++) {
-			unsigned int address = pfn * PAGE_SIZE + PAGE_OFFSET;
+			unsigned long address = pfn * PAGE_SIZE + PAGE_OFFSET;
 
 			/* Map with big pages if possible, otherwise create normal page tables. */
 			if (cpu_has_pse) {
-				unsigned int address2 = (pfn + PTRS_PER_PTE - 1) * PAGE_SIZE + PAGE_OFFSET + PAGE_SIZE-1;
-
-				if (is_kernel_text(address) || is_kernel_text(address2))
+				if (is_kernel_text(address, address + PMD_SIZE))
 					set_pmd(pmd, pfn_pmd(pfn, PAGE_KERNEL_LARGE_EXEC));
 				else
 					set_pmd(pmd, pfn_pmd(pfn, PAGE_KERNEL_LARGE));
@@ -175,7 +163,7 @@ static void __init kernel_physical_mappi
 				pte = one_page_table_init(pmd);
 
 				for (pte_ofs = 0; pte_ofs < PTRS_PER_PTE && pfn < max_low_pfn; pte++, pfn++, pte_ofs++) {
-						if (is_kernel_text(address))
+						if (is_kernel_text(address, address + PAGE_SIZE))
 							set_pte(pte, pfn_pte(pfn, PAGE_KERNEL_EXEC));
 						else
 							set_pte(pte, pfn_pte(pfn, PAGE_KERNEL));
@@ -340,13 +328,6 @@ static void __init pagetable_init (void)
 	unsigned long vaddr;
 	pgd_t *pgd_base = swapper_pg_dir;
 
-#ifdef CONFIG_X86_PAE
-	int i;
-	/* Init entries of the first-level page table to the zero page */
-	for (i = 0; i < PTRS_PER_PGD; i++)
-		set_pgd(pgd_base + i, __pgd(__pa(empty_zero_page) | _PAGE_PRESENT));
-#endif
-
 	/* Enable PSE if available */
 	if (cpu_has_pse) {
 		set_in_cr4(X86_CR4_PSE);
@@ -370,17 +351,6 @@ static void __init pagetable_init (void)
 	page_table_range_init(vaddr, 0, pgd_base);
 
 	permanent_kmaps_init(pgd_base);
-
-#ifdef CONFIG_X86_PAE
-	/*
-	 * Add low memory identity-mappings - SMP needs it when
-	 * starting up on an AP from real-mode. In the non-PAE
-	 * case we already have these mappings through head.S.
-	 * All user-space mappings are explicitly cleared after
-	 * SMP startup.
-	 */
-	set_pgd(&pgd_base[0], pgd_base[USER_PTRS_PER_PGD]);
-#endif
 }
 
 #if defined(CONFIG_SOFTWARE_SUSPEND) || defined(CONFIG_ACPI_SLEEP)
@@ -422,7 +392,6 @@ void zap_low_mappings (void)
 	flush_tlb_all();
 }
 
-static int disable_nx __initdata = 0;
 u64 __supported_pte_mask __read_mostly = ~_PAGE_NX;
 
 /*
@@ -436,13 +405,10 @@ u64 __supported_pte_mask __read_mostly =
 static int __init noexec_setup(char *str)
 {
 	if (!str || !strcmp(str, "on")) {
-		if (cpu_has_nx) {
-			__supported_pte_mask |= _PAGE_NX;
-			disable_nx = 0;
-		}
+		if (cpu_has_nx)
+			nx_enabled = 1;
 	} else if (!strcmp(str,"off")) {
-		disable_nx = 1;
-		__supported_pte_mask &= ~_PAGE_NX;
+		nx_enabled = 0;
 	} else
 		return -EINVAL;
 
@@ -455,17 +421,13 @@ int nx_enabled = 0;
 
 static void __init set_nx(void)
 {
-	unsigned int v[4], l, h;
+	if (!nx_enabled && cpu_has_nx) {
+		unsigned l, h;
 
-	if (cpu_has_pae && (cpuid_eax(0x80000000) > 0x80000001)) {
-		cpuid(0x80000001, &v[0], &v[1], &v[2], &v[3]);
-		if ((v[3] & (1 << 20)) && !disable_nx) {
-			rdmsr(MSR_EFER, l, h);
-			l |= EFER_NX;
-			wrmsr(MSR_EFER, l, h);
-			nx_enabled = 1;
-			__supported_pte_mask |= _PAGE_NX;
-		}
+		__supported_pte_mask &= ~_PAGE_NX;
+		rdmsr(MSR_EFER, l, h);
+		l &= ~EFER_NX;
+		wrmsr(MSR_EFER, l, h);
 	}
 }
 
@@ -518,14 +480,6 @@ void __init paging_init(void)
 
 	load_cr3(swapper_pg_dir);
 
-#ifdef CONFIG_X86_PAE
-	/*
-	 * We will bail out later - printk doesn't work right now so
-	 * the user would just see a hanging kernel.
-	 */
-	if (cpu_has_pae)
-		set_in_cr4(X86_CR4_PAE);
-#endif
 	__flush_tlb_all();
 
 	kmap_init();
@@ -596,7 +550,7 @@ void __init mem_init(void)
 	set_highmem_pages_init(bad_ppro);
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
-	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_data;
 	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
 
 	kclist_add(&kcore_mem, __va(0), max_low_pfn << PAGE_SHIFT); 
@@ -641,10 +595,10 @@ void __init mem_init(void)
 	       (unsigned long)&__init_begin, (unsigned long)&__init_end,
 	       ((unsigned long)&__init_end - (unsigned long)&__init_begin) >> 10,
 
-	       (unsigned long)&_etext, (unsigned long)&_edata,
-	       ((unsigned long)&_edata - (unsigned long)&_etext) >> 10,
+	       (unsigned long)&_data, (unsigned long)&_edata,
+	       ((unsigned long)&_edata - (unsigned long)&_data) >> 10,
 
-	       (unsigned long)&_text, (unsigned long)&_etext,
+	       (unsigned long)&_text + __KERNEL_TEXT_OFFSET, (unsigned long)&_etext + __KERNEL_TEXT_OFFSET,
 	       ((unsigned long)&_etext - (unsigned long)&_text) >> 10);
 
 #ifdef CONFIG_HIGHMEM
@@ -655,10 +609,6 @@ void __init mem_init(void)
 	BUG_ON((unsigned long)high_memory      > VMALLOC_START);
 #endif /* double-sanity-check paranoia */
 
-#ifdef CONFIG_X86_PAE
-	if (!cpu_has_pae)
-		panic("cannot execute a PAE-enabled kernel on a PAE-less CPU!");
-#endif
 	if (boot_cpu_data.wp_works_ok < 0)
 		test_wp_bit();
 
@@ -781,6 +731,38 @@ void free_init_pages(char *what, unsigne
 
 void free_initmem(void)
 {
+
+#ifdef CONFIG_PAX_KERNEXEC
+	/* PaX: limit KERNEL_CS to actual size */
+	unsigned long addr, limit;
+	__u32 a, b;
+	int cpu;
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+
+#ifdef CONFIG_MODULES
+	limit = (unsigned long)&MODULES_END - __KERNEL_TEXT_OFFSET;
+#else
+	limit = (unsigned long)&_etext;
+#endif
+	limit = (limit - 1UL) >> PAGE_SHIFT;
+
+	for (cpu = 0; cpu < NR_CPUS; cpu++) {
+		pack_descriptor(&a, &b, get_desc_base(&get_cpu_gdt_table(cpu)[GDT_ENTRY_KERNEL_CS]), limit, 0x9B, 0xC);
+		write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_KERNEL_CS, a, b);
+	}
+
+	/* PaX: make KERNEL_CS read-only */
+	for (addr = __KERNEL_TEXT_OFFSET; addr < (unsigned long)&_data; addr += PMD_SIZE) {
+		pgd = pgd_offset_k(addr);
+		pud = pud_offset(pgd, addr);
+		pmd = pmd_offset(pud, addr);
+		set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_RW));
+	}
+	flush_tlb_all();
+#endif
+
 	free_init_pages("unused kernel memory",
 			(unsigned long)(&__init_begin),
 			(unsigned long)(&__init_end));
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mm/mmap.c linux-2.6.20.1-pax/arch/i386/mm/mmap.c
--- linux-2.6.20.1/arch/i386/mm/mmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mm/mmap.c	2007-02-05 00:56:18.000000000 +0100
@@ -34,12 +34,18 @@
  * Leave an at least ~128 MB hole.
  */
 #define MIN_GAP (128*1024*1024)
-#define MAX_GAP (TASK_SIZE/6*5)
+#define MAX_GAP (task_size/6*5)
 
 static inline unsigned long mmap_base(struct mm_struct *mm)
 {
 	unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
 	unsigned long random_factor = 0;
+	unsigned long task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
 
 	if (current->flags & PF_RANDOMIZE)
 		random_factor = get_random_int() % (1024*1024);
@@ -49,7 +55,7 @@ static inline unsigned long mmap_base(st
 	else if (gap > MAX_GAP)
 		gap = MAX_GAP;
 
-	return PAGE_ALIGN(TASK_SIZE - gap - random_factor);
+	return PAGE_ALIGN(task_size - gap - random_factor);
 }
 
 /*
@@ -66,10 +72,22 @@ void arch_pick_mmap_layout(struct mm_str
 			(current->personality & ADDR_COMPAT_LAYOUT) ||
 			current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base(mm);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/mm/pageattr.c linux-2.6.20.1-pax/arch/i386/mm/pageattr.c
--- linux-2.6.20.1/arch/i386/mm/pageattr.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/mm/pageattr.c	2007-02-05 00:56:18.000000000 +0100
@@ -13,6 +13,7 @@
 #include <asm/tlbflush.h>
 #include <asm/pgalloc.h>
 #include <asm/sections.h>
+#include <asm/desc.h>
 
 static DEFINE_SPINLOCK(cpa_lock);
 static struct list_head df_list = LIST_HEAD_INIT(df_list);
@@ -89,7 +90,18 @@ static void set_pmd_pte(pte_t *kpte, uns
 	struct page *page;
 	unsigned long flags;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	set_pte_atomic(kpte, pte); 	/* change init_mm */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	if (PTRS_PER_PMD > 1)
 		return;
 
@@ -116,7 +128,7 @@ static inline void revert_page(struct pa
 	pte_t *linear;
 
 	ref_prot =
-	((address & LARGE_PAGE_MASK) < (unsigned long)&_etext)
+	((address & LARGE_PAGE_MASK) < (unsigned long)&_etext + __KERNEL_TEXT_OFFSET)
 		? PAGE_KERNEL_LARGE_EXEC : PAGE_KERNEL_LARGE;
 
 	linear = (pte_t *)
@@ -148,7 +160,7 @@ __change_page_attr(struct page *page, pg
 			struct page *split;
 
 			ref_prot =
-			((address & LARGE_PAGE_MASK) < (unsigned long)&_etext)
+			((address & LARGE_PAGE_MASK) < (unsigned long)&_etext + __KERNEL_TEXT_OFFSET)
 				? PAGE_KERNEL_EXEC : PAGE_KERNEL;
 			split = split_large_page(address, prot, ref_prot);
 			if (!split)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/oprofile/backtrace.c linux-2.6.20.1-pax/arch/i386/oprofile/backtrace.c
--- linux-2.6.20.1/arch/i386/oprofile/backtrace.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/oprofile/backtrace.c	2007-02-05 00:56:18.000000000 +0100
@@ -116,7 +116,7 @@ x86_backtrace(struct pt_regs * const reg
 	head = (struct frame_head *)regs->ebp;
 #endif
 
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		while (depth-- && valid_kernel_stack(head, regs))
 			head = dump_kernel_backtrace(head);
 		return;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/oprofile/op_model_p4.c linux-2.6.20.1-pax/arch/i386/oprofile/op_model_p4.c
--- linux-2.6.20.1/arch/i386/oprofile/op_model_p4.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/oprofile/op_model_p4.c	2007-02-05 00:56:18.000000000 +0100
@@ -47,7 +47,7 @@ static inline void setup_num_counters(vo
 #endif
 }
 
-static int inline addr_increment(void)
+static inline int addr_increment(void)
 {
 #ifdef CONFIG_SMP
 	return smp_num_siblings == 2 ? 2 : 1;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/pci/common.c linux-2.6.20.1-pax/arch/i386/pci/common.c
--- linux-2.6.20.1/arch/i386/pci/common.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/pci/common.c	2007-02-15 23:31:59.000000000 +0100
@@ -191,7 +191,7 @@ static struct dmi_system_id __devinitdat
 			DMI_MATCH(DMI_PRODUCT_NAME, "PowerEdge 2950"),
 		},
 	},
-	{}
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL}
 };
 
 struct pci_bus * __devinit pcibios_scan_root(int busnum)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/pci/early.c linux-2.6.20.1-pax/arch/i386/pci/early.c
--- linux-2.6.20.1/arch/i386/pci/early.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/pci/early.c	2007-02-05 00:56:19.000000000 +0100
@@ -7,7 +7,7 @@
 /* Direct PCI access. This is used for PCI accesses in early boot before
    the PCI subsystem works. */
 
-#define PDprintk(x...)
+#define PDprintk(x...) do {} while (0)
 
 u32 read_pci_config(u8 bus, u8 slot, u8 func, u8 offset)
 {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/pci/fixup.c linux-2.6.20.1-pax/arch/i386/pci/fixup.c
--- linux-2.6.20.1/arch/i386/pci/fixup.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/pci/fixup.c	2007-02-15 23:34:41.000000000 +0100
@@ -389,7 +389,7 @@ static struct dmi_system_id __devinitdat
 			DMI_MATCH(DMI_PRODUCT_VERSION, "PSA40U"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 static void __devinit pci_pre_fixup_toshiba_ohci1394(struct pci_dev *dev)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/pci/irq.c linux-2.6.20.1-pax/arch/i386/pci/irq.c
--- linux-2.6.20.1/arch/i386/pci/irq.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/pci/irq.c	2007-02-15 23:34:10.000000000 +0100
@@ -507,7 +507,7 @@ static __init int intel_router_probe(str
 	static struct pci_device_id __initdata pirq_440gx[] = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_0) },
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_2) },
-		{ },
+		{ PCI_DEVICE(0, 0) }
 	};
 
 	/* 440GX has a proprietary PIRQ router -- don't use it */
@@ -1049,7 +1049,7 @@ static struct dmi_system_id __initdata p
 			DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 360"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 static int __init pcibios_irq_init(void)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/i386/power/cpu.c linux-2.6.20.1-pax/arch/i386/power/cpu.c
--- linux-2.6.20.1/arch/i386/power/cpu.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/i386/power/cpu.c	2007-02-05 00:56:19.000000000 +0100
@@ -63,7 +63,7 @@ static void do_fpu_end(void)
 static void fix_processor_context(void)
 {
 	int cpu = smp_processor_id();
-	struct tss_struct * t = &per_cpu(init_tss, cpu);
+	struct tss_struct * t = init_tss + cpu;
 
 	set_tss_desc(cpu,t);	/* This just modifies memory; should not be necessary. But... This is necessary, because 386 hardware has concept of busy TSS or some similar stupidity. */
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/ia64/ia32/binfmt_elf32.c linux-2.6.20.1-pax/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.6.20.1/arch/ia64/ia32/binfmt_elf32.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/ia64/ia32/binfmt_elf32.c	2007-02-05 00:56:19.000000000 +0100
@@ -45,6 +45,17 @@ randomize_stack_top(unsigned long stack_
 
 #define elf_read_implies_exec(ex, have_pt_gnu_stack)	(!(have_pt_gnu_stack))
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	((tsk)->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		IA32_PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - IA32_PAGE_SHIFT)
+#define PAX_DELTA_EXEC_LSB(tsk)		IA32_PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - IA32_PAGE_SHIFT)
+#define PAX_DELTA_STACK_LSB(tsk)	IA32_PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - IA32_PAGE_SHIFT)
+#endif
+
 /* Ugly but avoids duplication */
 #include "../../../fs/binfmt_elf.c"
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/ia64/ia32/ia32priv.h linux-2.6.20.1-pax/arch/ia64/ia32/ia32priv.h
--- linux-2.6.20.1/arch/ia64/ia32/ia32priv.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/ia64/ia32/ia32priv.h	2007-02-05 00:56:19.000000000 +0100
@@ -304,7 +304,14 @@ struct old_linux32_dirent {
 #define ELF_DATA	ELFDATA2LSB
 #define ELF_ARCH	EM_386
 
-#define IA32_STACK_TOP		IA32_PAGE_OFFSET
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __IA32_DELTA_STACK	(current->mm->delta_stack)
+#else
+#define __IA32_DELTA_STACK	0UL
+#endif
+
+#define IA32_STACK_TOP		(IA32_PAGE_OFFSET - __IA32_DELTA_STACK)
+
 #define IA32_GATE_OFFSET	IA32_PAGE_OFFSET
 #define IA32_GATE_END		IA32_PAGE_OFFSET + PAGE_SIZE
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/ia64/kernel/module.c linux-2.6.20.1-pax/arch/ia64/kernel/module.c
--- linux-2.6.20.1/arch/ia64/kernel/module.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/ia64/kernel/module.c	2007-02-05 00:56:19.000000000 +0100
@@ -321,7 +321,7 @@ module_alloc (unsigned long size)
 void
 module_free (struct module *mod, void *module_region)
 {
-	if (mod->arch.init_unw_table && module_region == mod->module_init) {
+	if (mod->arch.init_unw_table && module_region == mod->module_init_rx) {
 		unw_remove_unwind_table(mod->arch.init_unw_table);
 		mod->arch.init_unw_table = NULL;
 	}
@@ -499,15 +499,39 @@ module_frob_arch_sections (Elf_Ehdr *ehd
 }
 
 static inline int
+in_init_rx (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_init_rx < mod->init_size_rx;
+}
+
+static inline int
+in_init_rw (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_init_rw < mod->init_size_rw;
+}
+
+static inline int
 in_init (const struct module *mod, uint64_t addr)
 {
-	return addr - (uint64_t) mod->module_init < mod->init_size;
+	return in_init_rx(mod, value) || in_init_rw(mod, value);
+}
+
+static inline int
+in_core_rx (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_core_rx < mod->core_size_rx;
+}
+
+static inline int
+in_core_rw (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_core_rw < mod->core_size_rw;
 }
 
 static inline int
 in_core (const struct module *mod, uint64_t addr)
 {
-	return addr - (uint64_t) mod->module_core < mod->core_size;
+	return in_core_rx(mod, value) || in_core_rw(mod, value);
 }
 
 static inline int
@@ -691,7 +715,14 @@ do_reloc (struct module *mod, uint8_t r_
 		break;
 
 	      case RV_BDREL:
-		val -= (uint64_t) (in_init(mod, val) ? mod->module_init : mod->module_core);
+		if (in_init_rx(mod, val))
+			val -= (uint64_t) mod->module_init_rx;
+		else if (in_init_rw(mod, val))
+			val -= (uint64_t) mod->module_init_rw;
+		else if (in_core_rx(mod, val))
+			val -= (uint64_t) mod->module_core_rx;
+		else if (in_core_rw(mod, val))
+			val -= (uint64_t) mod->module_core_rw;
 		break;
 
 	      case RV_LTV:
@@ -825,15 +856,15 @@ apply_relocate_add (Elf64_Shdr *sechdrs,
 		 *     addresses have been selected...
 		 */
 		uint64_t gp;
-		if (mod->core_size > MAX_LTOFF)
+		if (mod->core_size_rx + mod->core_size_rw > MAX_LTOFF)
 			/*
 			 * This takes advantage of fact that SHF_ARCH_SMALL gets allocated
 			 * at the end of the module.
 			 */
-			gp = mod->core_size - MAX_LTOFF / 2;
+			gp = mod->core_size_rx + mod->core_size_rw - MAX_LTOFF / 2;
 		else
-			gp = mod->core_size / 2;
-		gp = (uint64_t) mod->module_core + ((gp + 7) & -8);
+			gp = (mod->core_size_rx + mod->core_size_rw) / 2;
+		gp = (uint64_t) mod->module_core_rx + ((gp + 7) & -8);
 		mod->arch.gp = gp;
 		DEBUGP("%s: placing gp at 0x%lx\n", __FUNCTION__, gp);
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/ia64/kernel/sys_ia64.c linux-2.6.20.1-pax/arch/ia64/kernel/sys_ia64.c
--- linux-2.6.20.1/arch/ia64/kernel/sys_ia64.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/ia64/kernel/sys_ia64.c	2007-02-05 00:56:19.000000000 +0100
@@ -37,6 +37,13 @@ arch_get_unmapped_area (struct file *fil
 	if (REGION_NUMBER(addr) == RGN_HPAGE)
 		addr = 0;
 #endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((mm->pax_flags & MF_PAX_RANDMMAP) && addr && filp)
+		addr = mm->free_area_cache;
+	else
+#endif
+
 	if (!addr)
 		addr = mm->free_area_cache;
 
@@ -55,9 +62,9 @@ arch_get_unmapped_area (struct file *fil
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
 		if (TASK_SIZE - len < addr || RGN_MAP_LIMIT - len < REGION_OFFSET(addr)) {
-			if (start_addr != TASK_UNMAPPED_BASE) {
+			if (start_addr != mm->mmap_base) {
 				/* Start a new search --- just in case we missed some holes.  */
-				addr = TASK_UNMAPPED_BASE;
+				addr = mm->mmap_base;
 				goto full_search;
 			}
 			return -ENOMEM;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/ia64/mm/fault.c linux-2.6.20.1-pax/arch/ia64/mm/fault.c
--- linux-2.6.20.1/arch/ia64/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/ia64/mm/fault.c	2007-02-05 00:56:19.000000000 +0100
@@ -10,6 +10,7 @@
 #include <linux/interrupt.h>
 #include <linux/kprobes.h>
 #include <linux/vs_memory.h>
+#include <linux/binfmts.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -85,6 +86,23 @@ mapped_kernel_page_is_present (unsigned 
 	return pte_present(pte);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 8; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void __kprobes
 ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *regs)
 {
@@ -152,9 +170,23 @@ ia64_do_page_fault (unsigned long addres
 	mask = (  (((isr >> IA64_ISR_X_BIT) & 1UL) << VM_EXEC_BIT)
 		| (((isr >> IA64_ISR_W_BIT) & 1UL) << VM_WRITE_BIT));
 
-	if ((vma->vm_flags & mask) != mask)
+	if ((vma->vm_flags & mask) != mask) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(vma->vm_flags & VM_EXEC) && (mask & VM_EXEC)) {
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->cr_iip)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			pax_report_fault(regs, (void*)regs->cr_iip, (void*)regs->r12);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
 
+	}
+
   survive:
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/ia64/mm/init.c linux-2.6.20.1-pax/arch/ia64/mm/init.c
--- linux-2.6.20.1/arch/ia64/mm/init.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/ia64/mm/init.c	2007-02-05 00:56:19.000000000 +0100
@@ -19,8 +19,8 @@
 #include <linux/swap.h>
 #include <linux/proc_fs.h>
 #include <linux/bitops.h>
+#include <linux/a.out.h>
 
-#include <asm/a.out.h>
 #include <asm/dma.h>
 #include <asm/ia32.h>
 #include <asm/io.h>
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/mips/kernel/binfmt_elfn32.c linux-2.6.20.1-pax/arch/mips/kernel/binfmt_elfn32.c
--- linux-2.6.20.1/arch/mips/kernel/binfmt_elfn32.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/mips/kernel/binfmt_elfn32.c	2007-02-05 00:56:19.000000000 +0100
@@ -50,6 +50,17 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/elfcore.h>
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/mips/kernel/binfmt_elfo32.c linux-2.6.20.1-pax/arch/mips/kernel/binfmt_elfo32.c
--- linux-2.6.20.1/arch/mips/kernel/binfmt_elfo32.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/mips/kernel/binfmt_elfo32.c	2007-02-05 00:56:19.000000000 +0100
@@ -52,6 +52,17 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/elfcore.h>
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/mips/kernel/syscall.c linux-2.6.20.1-pax/arch/mips/kernel/syscall.c
--- linux-2.6.20.1/arch/mips/kernel/syscall.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/mips/kernel/syscall.c	2007-02-05 00:56:19.000000000 +0100
@@ -88,6 +88,11 @@ unsigned long arch_get_unmapped_area(str
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -98,7 +103,7 @@ unsigned long arch_get_unmapped_area(str
 		    (!vmm || addr + len <= vmm->vm_start))
 			return addr;
 	}
-	addr = TASK_UNMAPPED_BASE;
+	addr = current->mm->mmap_base;
 	if (do_color_align)
 		addr = COLOUR_ALIGN(addr, pgoff);
 	else
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/mips/mm/fault.c linux-2.6.20.1-pax/arch/mips/mm/fault.c
--- linux-2.6.20.1/arch/mips/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/mips/mm/fault.c	2007-02-05 00:56:19.000000000 +0100
@@ -27,6 +27,23 @@
 #include <asm/ptrace.h>
 #include <asm/highmem.h>		/* For VMALLOC_END */
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/parisc/kernel/module.c linux-2.6.20.1-pax/arch/parisc/kernel/module.c
--- linux-2.6.20.1/arch/parisc/kernel/module.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/parisc/kernel/module.c	2007-02-05 00:56:19.000000000 +0100
@@ -72,16 +72,38 @@
 
 /* three functions to determine where in the module core
  * or init pieces the location is */
+static inline int in_init_rx(struct module *me, void *loc)
+{
+	return (loc >= me->module_init_rx &&
+		loc < (me->module_init_rx + me->init_size_rx));
+}
+
+static inline int in_init_rw(struct module *me, void *loc)
+{
+	return (loc >= me->module_init_rw &&
+		loc < (me->module_init_rw + me->init_size_rw));
+}
+
 static inline int in_init(struct module *me, void *loc)
 {
-	return (loc >= me->module_init &&
-		loc <= (me->module_init + me->init_size));
+	return in_init_rx(me, loc) || in_init_rw(me, loc);
+}
+
+static inline int in_core_rx(struct module *me, void *loc)
+{
+	return (loc >= me->module_core_rx &&
+		loc < (me->module_core_rx + me->core_size_rx));
+}
+
+static inline int in_core_rw(struct module *me, void *loc)
+{
+	return (loc >= me->module_core_rw &&
+		loc < (me->module_core_rw + me->core_size_rw));
 }
 
 static inline int in_core(struct module *me, void *loc)
 {
-	return (loc >= me->module_core &&
-		loc <= (me->module_core + me->core_size));
+	return in_core_rx(me, loc) || in_core_rw(me, loc);
 }
 
 static inline int in_local(struct module *me, void *loc)
@@ -295,21 +317,21 @@ int module_frob_arch_sections(CONST Elf_
 	}
 
 	/* align things a bit */
-	me->core_size = ALIGN(me->core_size, 16);
-	me->arch.got_offset = me->core_size;
-	me->core_size += gots * sizeof(struct got_entry);
-
-	me->core_size = ALIGN(me->core_size, 16);
-	me->arch.fdesc_offset = me->core_size;
-	me->core_size += fdescs * sizeof(Elf_Fdesc);
-
-	me->core_size = ALIGN(me->core_size, 16);
-	me->arch.stub_offset = me->core_size;
-	me->core_size += stubs * sizeof(struct stub_entry);
-
-	me->init_size = ALIGN(me->init_size, 16);
-	me->arch.init_stub_offset = me->init_size;
-	me->init_size += init_stubs * sizeof(struct stub_entry);
+	me->core_size_rw = ALIGN(me->core_size_rw, 16);
+	me->arch.got_offset = me->core_size_rw;
+	me->core_size_rw += gots * sizeof(struct got_entry);
+
+	me->core_size_rw = ALIGN(me->core_size_rw, 16);
+	me->arch.fdesc_offset = me->core_size_rw;
+	me->core_size_rw += fdescs * sizeof(Elf_Fdesc);
+
+	me->core_size_rx = ALIGN(me->core_size_rx, 16);
+	me->arch.stub_offset = me->core_size_rx;
+	me->core_size_rx += stubs * sizeof(struct stub_entry);
+
+	me->init_size_rx = ALIGN(me->init_size_rx, 16);
+	me->arch.init_stub_offset = me->init_size_rx;
+	me->init_size_rx += init_stubs * sizeof(struct stub_entry);
 
 	me->arch.got_max = gots;
 	me->arch.fdesc_max = fdescs;
@@ -329,7 +351,7 @@ static Elf64_Word get_got(struct module 
 
 	BUG_ON(value == 0);
 
-	got = me->module_core + me->arch.got_offset;
+	got = me->module_core_rw + me->arch.got_offset;
 	for (i = 0; got[i].addr; i++)
 		if (got[i].addr == value)
 			goto out;
@@ -347,7 +369,7 @@ static Elf64_Word get_got(struct module 
 #ifdef __LP64__
 static Elf_Addr get_fdesc(struct module *me, unsigned long value)
 {
-	Elf_Fdesc *fdesc = me->module_core + me->arch.fdesc_offset;
+	Elf_Fdesc *fdesc = me->module_core_rw + me->arch.fdesc_offset;
 
 	if (!value) {
 		printk(KERN_ERR "%s: zero OPD requested!\n", me->name);
@@ -365,7 +387,7 @@ static Elf_Addr get_fdesc(struct module 
 
 	/* Create new one */
 	fdesc->addr = value;
-	fdesc->gp = (Elf_Addr)me->module_core + me->arch.got_offset;
+	fdesc->gp = (Elf_Addr)me->module_core_rw + me->arch.got_offset;
 	return (Elf_Addr)fdesc;
 }
 #endif /* __LP64__ */
@@ -385,12 +407,12 @@ static Elf_Addr get_stub(struct module *
 	if(init_section) {
 		i = me->arch.init_stub_count++;
 		BUG_ON(me->arch.init_stub_count > me->arch.init_stub_max);
-		stub = me->module_init + me->arch.init_stub_offset + 
+		stub = me->module_init_rx + me->arch.init_stub_offset + 
 			i * sizeof(struct stub_entry);
 	} else {
 		i = me->arch.stub_count++;
 		BUG_ON(me->arch.stub_count > me->arch.stub_max);
-		stub = me->module_core + me->arch.stub_offset + 
+		stub = me->module_core_rx + me->arch.stub_offset + 
 			i * sizeof(struct stub_entry);
 	}
 
@@ -758,7 +780,7 @@ register_unwind_table(struct module *me,
 
 	table = (unsigned char *)sechdrs[me->arch.unwind_section].sh_addr;
 	end = table + sechdrs[me->arch.unwind_section].sh_size;
-	gp = (Elf_Addr)me->module_core + me->arch.got_offset;
+	gp = (Elf_Addr)me->module_core_rw + me->arch.got_offset;
 
 	DEBUGP("register_unwind_table(), sect = %d at 0x%p - 0x%p (gp=0x%lx)\n",
 	       me->arch.unwind_section, table, end, gp);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/parisc/kernel/sys_parisc.c linux-2.6.20.1-pax/arch/parisc/kernel/sys_parisc.c
--- linux-2.6.20.1/arch/parisc/kernel/sys_parisc.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/parisc/kernel/sys_parisc.c	2007-02-05 00:56:19.000000000 +0100
@@ -107,7 +107,7 @@ unsigned long arch_get_unmapped_area(str
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = current->mm->mmap_base;
 
 	if (filp) {
 		addr = get_shared_area(filp->f_mapping, addr, len, pgoff);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/parisc/kernel/traps.c linux-2.6.20.1-pax/arch/parisc/kernel/traps.c
--- linux-2.6.20.1/arch/parisc/kernel/traps.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/parisc/kernel/traps.c	2007-02-05 00:56:19.000000000 +0100
@@ -716,9 +716,7 @@ void handle_interruption(int code, struc
 
 			down_read(&current->mm->mmap_sem);
 			vma = find_vma(current->mm,regs->iaoq[0]);
-			if (vma && (regs->iaoq[0] >= vma->vm_start)
-				&& (vma->vm_flags & VM_EXEC)) {
-
+			if (vma && (regs->iaoq[0] >= vma->vm_start)) {
 				fault_address = regs->iaoq[0];
 				fault_space = regs->iasq[0];
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/parisc/mm/fault.c linux-2.6.20.1-pax/arch/parisc/mm/fault.c
--- linux-2.6.20.1/arch/parisc/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/parisc/mm/fault.c	2007-02-05 00:56:19.000000000 +0100
@@ -16,6 +16,8 @@
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/unistd.h>
+#include <linux/binfmts.h>
 
 #include <asm/uaccess.h>
 #include <asm/traps.h>
@@ -57,7 +59,7 @@ DEFINE_PER_CPU(struct exception_data, ex
 static unsigned long
 parisc_acctyp(unsigned long code, unsigned int inst)
 {
-	if (code == 6 || code == 16)
+	if (code == 6 || code == 7 || code == 16)
 	    return VM_EXEC;
 
 	switch (inst & 0xf0000000) {
@@ -143,6 +145,116 @@ parisc_acctyp(unsigned long code, unsign
 			}
 #endif
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (instruction_pointer(regs) = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when rt_sigreturn trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int bl, depwi;
+
+		err = get_user(bl, (unsigned int*)instruction_pointer(regs));
+		err |= get_user(depwi, (unsigned int*)(instruction_pointer(regs)+4));
+
+		if (err)
+			break;
+
+		if (bl == 0xEA9F1FDDU && depwi == 0xD6801C1EU) {
+			unsigned int ldw, bv, ldw2, addr = instruction_pointer(regs)-12;
+
+			err = get_user(ldw, (unsigned int*)addr);
+			err |= get_user(bv, (unsigned int*)(addr+4));
+			err |= get_user(ldw2, (unsigned int*)(addr+8));
+
+			if (err)
+				break;
+
+			if (ldw == 0x0E801096U &&
+			    bv == 0xEAC0C000U &&
+			    ldw2 == 0x0E881095U)
+			{
+				unsigned int resolver, map;
+
+				err = get_user(resolver, (unsigned int*)(instruction_pointer(regs)+8));
+				err |= get_user(map, (unsigned int*)(instruction_pointer(regs)+12));
+				if (err)
+					break;
+
+				regs->gr[20] = instruction_pointer(regs)+8;
+				regs->gr[21] = map;
+				regs->gr[22] = resolver;
+				regs->iaoq[0] = resolver | 3UL;
+				regs->iaoq[1] = regs->iaoq[0] + 4;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+
+#ifndef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int ldi1, ldi2, bel, nop;
+
+		err = get_user(ldi1, (unsigned int *)instruction_pointer(regs));
+		err |= get_user(ldi2, (unsigned int *)(instruction_pointer(regs)+4));
+		err |= get_user(bel, (unsigned int *)(instruction_pointer(regs)+8));
+		err |= get_user(nop, (unsigned int *)(instruction_pointer(regs)+12));
+
+		if (err)
+			break;
+
+		if ((ldi1 == 0x34190000U || ldi1 == 0x34190002U) &&
+		    ldi2 == 0x3414015AU &&
+		    bel == 0xE4008200U &&
+		    nop == 0x08000240U)
+		{
+			regs->gr[25] = (ldi1 & 2) >> 1;
+			regs->gr[20] = __NR_rt_sigreturn;
+			regs->gr[31] = regs->iaoq[1] + 16;
+			regs->sr[0] = regs->iasq[1];
+			regs->iaoq[0] = 0x100UL;
+			regs->iaoq[1] = regs->iaoq[0] + 4;
+			regs->iasq[0] = regs->sr[2];
+			regs->iasq[1] = regs->sr[2];
+			return 2;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void do_page_fault(struct pt_regs *regs, unsigned long code,
 			      unsigned long address)
 {
@@ -168,8 +280,33 @@ good_area:
 
 	acc_type = parisc_acctyp(code,regs->iir);
 
-	if ((vma->vm_flags & acc_type) != acc_type)
+	if ((vma->vm_flags & acc_type) != acc_type) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (acc_type & VM_EXEC) &&
+		    (address & ~3UL) == instruction_pointer(regs))
+		{
+			up_read(&mm->mmap_sem);
+			switch(pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 3:
+				return;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			case 2:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)instruction_pointer(regs), (void*)regs->gr[30]);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
+	}
 
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/powerpc/kernel/module_32.c linux-2.6.20.1-pax/arch/powerpc/kernel/module_32.c
--- linux-2.6.20.1/arch/powerpc/kernel/module_32.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/powerpc/kernel/module_32.c	2007-02-05 00:56:19.000000000 +0100
@@ -126,7 +126,7 @@ int module_frob_arch_sections(Elf32_Ehdr
 			me->arch.core_plt_section = i;
 	}
 	if (!me->arch.core_plt_section || !me->arch.init_plt_section) {
-		printk("Module doesn't contain .plt or .init.plt sections.\n");
+		printk("Module %s doesn't contain .plt or .init.plt sections.\n", me->name);
 		return -ENOEXEC;
 	}
 
@@ -167,11 +167,16 @@ static uint32_t do_plt_call(void *locati
 
 	DEBUGP("Doing plt for call to 0x%x at 0x%x\n", val, (unsigned int)location);
 	/* Init, or core PLT? */
-	if (location >= mod->module_core
-	    && location < mod->module_core + mod->core_size)
+	if ((location >= mod->module_core_rx && location < mod->module_core_rx + mod->core_size_rx) ||
+	    (location >= mod->module_core_rw && location < mod->module_core_rw + mod->core_size_rw))
 		entry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;
-	else
+	else if ((location >= mod->module_init_rx && location < mod->module_init_rx + mod->init_size_rx) ||
+		 (location >= mod->module_init_rw && location < mod->module_init_rw + mod->init_size_rw))
 		entry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;
+	else {
+		printk(KERN_ERR "%s: invalid R_PPC_REL24 entry found\n", mod->name);
+		return ~0UL;
+	}
 
 	/* Find this entry, or if that fails, the next avail. entry */
 	while (entry->jump[0]) {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/powerpc/kernel/signal_32.c linux-2.6.20.1-pax/arch/powerpc/kernel/signal_32.c
--- linux-2.6.20.1/arch/powerpc/kernel/signal_32.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/powerpc/kernel/signal_32.c	2007-02-05 00:56:19.000000000 +0100
@@ -759,7 +759,7 @@ static int handle_rt_signal(unsigned lon
 
 	/* Save user registers on the stack */
 	frame = &rt_sf->uc.uc_mcontext;
-	if (vdso32_rt_sigtramp && current->mm->context.vdso_base) {
+	if (vdso32_rt_sigtramp && current->mm->context.vdso_base != ~0UL) {
 		if (save_user_regs(regs, frame, 0))
 			goto badframe;
 		regs->link = current->mm->context.vdso_base + vdso32_rt_sigtramp;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/powerpc/kernel/signal_64.c linux-2.6.20.1-pax/arch/powerpc/kernel/signal_64.c
--- linux-2.6.20.1/arch/powerpc/kernel/signal_64.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/powerpc/kernel/signal_64.c	2007-02-05 00:56:19.000000000 +0100
@@ -397,7 +397,7 @@ static int setup_rt_frame(int signr, str
 	current->thread.fpscr.val = 0;
 
 	/* Set up to return from userspace. */
-	if (vdso64_rt_sigtramp && current->mm->context.vdso_base) {
+	if (vdso64_rt_sigtramp && current->mm->context.vdso_base != ~0UL) {
 		regs->link = current->mm->context.vdso_base + vdso64_rt_sigtramp;
 	} else {
 		err |= setup_trampoline(__NR_rt_sigreturn, &frame->tramp[0]);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/powerpc/kernel/vdso.c linux-2.6.20.1-pax/arch/powerpc/kernel/vdso.c
--- linux-2.6.20.1/arch/powerpc/kernel/vdso.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/powerpc/kernel/vdso.c	2007-02-05 00:56:19.000000000 +0100
@@ -239,7 +239,7 @@ int arch_setup_additional_pages(struct l
 	vdso_base = VDSO32_MBASE;
 #endif
 
-	current->mm->context.vdso_base = 0;
+	current->mm->context.vdso_base = ~0UL;
 
 	/* vDSO has a problem and was disabled, just don't "enable" it for the
 	 * process
@@ -256,7 +256,7 @@ int arch_setup_additional_pages(struct l
 	 */
 	down_write(&mm->mmap_sem);
 	vdso_base = get_unmapped_area(NULL, vdso_base,
-				      vdso_pages << PAGE_SHIFT, 0, 0);
+				      vdso_pages << PAGE_SHIFT, 0, MAP_PRIVATE | MAP_EXECUTABLE);
 	if (IS_ERR_VALUE(vdso_base)) {
 		rc = vdso_base;
 		goto fail_mmapsem;
@@ -284,6 +284,12 @@ int arch_setup_additional_pages(struct l
 	 * pages though
 	 */
 	vma->vm_flags = VM_READ|VM_EXEC|VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (mm->pax_flags & MF_PAX_MPROTECT)
+		vma->vm_flags &= ~VM_MAYWRITE;
+#endif
+
 	/*
 	 * Make sure the vDSO gets into every core dump.
 	 * Dumping its contents makes post-mortem fully interpretable later
@@ -292,7 +298,7 @@ int arch_setup_additional_pages(struct l
 	 */
 	vma->vm_flags |= VM_ALWAYSDUMP;
 	vma->vm_flags |= mm->def_flags;
-	vma->vm_page_prot = protection_map[vma->vm_flags & 0x7];
+	vma->vm_page_prot = protection_map[vma->vm_flags & (VM_READ|VM_WRITE|VM_EXEC)];
 	vma->vm_ops = &vdso_vmops;
 
 	/* Insert new VMA */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/powerpc/mm/fault.c linux-2.6.20.1-pax/arch/powerpc/mm/fault.c
--- linux-2.6.20.1/arch/powerpc/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/powerpc/mm/fault.c	2007-02-05 00:56:19.000000000 +0100
@@ -28,6 +28,12 @@
 #include <linux/highmem.h>
 #include <linux/module.h>
 #include <linux/kprobes.h>
+#include <linux/binfmts.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
+#include <linux/unistd.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -73,6 +79,364 @@ static inline int notify_page_fault(enum
 }
 #endif
 
+#ifdef CONFIG_PAX_EMUSIGRT
+void pax_syscall_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_syscall = 0UL;
+}
+
+static struct page* pax_syscall_nopage(struct vm_area_struct *vma, unsigned long address, int *type)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return NOPAGE_OOM;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x44000002U; /* sc */
+	__flush_dcache_icache(kaddr);
+	kunmap(page);
+	if (type)
+		*type = VM_FAULT_MAJOR;
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_syscall_close,
+	.nopage = pax_syscall_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & (VM_READ|VM_WRITE|VM_EXEC)];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched GOT trampoline was detected
+ *         3 when patched PLT trampoline was detected
+ *         4 when unpatched PLT trampoline was detected
+ *         5 when sigreturn trampoline was detected
+ *         6 when rt_sigreturn trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#if defined(CONFIG_PAX_EMUPLT) || defined(CONFIG_PAX_EMUSIGRT)
+	int err;
+#endif
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched GOT emulation */
+		unsigned int blrl;
+
+		err = get_user(blrl, (unsigned int*)regs->nip);
+
+		if (!err && blrl == 0x4E800021U) {
+			unsigned long temp = regs->nip;
+
+			regs->nip = regs->link & 0xFFFFFFFCUL;
+			regs->link = temp + 4UL;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int b;
+
+		err = get_user(b, (unsigned int *)regs->nip);
+
+		if (!err && (b & 0xFC000003U) == 0x48000000U) {
+			regs->nip += (((b | 0xFC000000UL) ^ 0x02000000UL) + 0x02000000UL);
+			return 3;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation #1 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(rlwinm, (unsigned int*)addr);
+			err |= get_user(add, (unsigned int*)(addr+4));
+			err |= get_user(li2, (unsigned int*)(addr+8));
+			err |= get_user(addis2, (unsigned int*)(addr+12));
+			err |= get_user(mtctr, (unsigned int*)(addr+16));
+			err |= get_user(li3, (unsigned int*)(addr+20));
+			err |= get_user(addis3, (unsigned int*)(addr+24));
+			err |= get_user(bctr, (unsigned int*)(addr+28));
+
+			if (err)
+				break;
+
+			if (rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+
+#if 0
+	do { /* PaX: unpatched PLT emulation #2 */
+		unsigned int lis, lwzu, b, bctr;
+
+		err = get_user(lis, (unsigned int *)regs->nip);
+		err |= get_user(lwzu, (unsigned int *)(regs->nip+4));
+		err |= get_user(b, (unsigned int *)(regs->nip+8));
+		err |= get_user(bctr, (unsigned int *)(regs->nip+12));
+
+		if (err)
+			break;
+
+		if ((lis & 0xFFFF0000U) == 0x39600000U &&
+		    (lwzu & 0xU) == 0xU &&
+		    (b & 0xFC000003U) == 0x48000000U &&
+		    bctr == 0x4E800420U)
+		{
+			unsigned int addis, addi, rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 12 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(addi, (unsigned int*)(addr+4));
+			err |= get_user(rlwinm, (unsigned int*)(addr+8));
+			err |= get_user(add, (unsigned int*)(addr+12));
+			err |= get_user(li2, (unsigned int*)(addr+16));
+			err |= get_user(addis2, (unsigned int*)(addr+20));
+			err |= get_user(mtctr, (unsigned int*)(addr+24));
+			err |= get_user(li3, (unsigned int*)(addr+28));
+			err |= get_user(addis3, (unsigned int*)(addr+32));
+			err |= get_user(bctr, (unsigned int*)(addr+36));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (addi & 0xFFFF0000U) == 0x396B0000U &&
+			    rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+	do { /* PaX: unpatched PLT emulation #3 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int addis, lwz, mtctr, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(lwz, (unsigned int*)(addr+4));
+			err |= get_user(mtctr, (unsigned int*)(addr+8));
+			err |= get_user(bctr, (unsigned int*)(addr+12));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (lwz & 0xFFFF0000U) == 0x816B0000U &&
+			    mtctr == 0x7D6903A6U &&
+			    bctr == 0x4E800420U)
+			{
+				unsigned int r11;
+
+				addr = (addis << 16) + (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				addr += (((lwz | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+
+				err = get_user(r11, (unsigned int*)addr);
+				if (err)
+					break;
+
+				regs->gpr[PT_R11] = r11;
+				regs->ctr = r11;
+				regs->nip = r11;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	do { /* PaX: sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned long call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+emulate:
+			regs->gpr[PT_R0] = __NR_sigreturn;
+			regs->nip = call_syscall;
+			return 5;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_rt_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned int call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto rt_emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto rt_emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+rt_emulate:
+			regs->gpr[PT_R0] = __NR_rt_sigreturn;
+			regs->nip = call_syscall;
+			return 6;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * Check whether the instruction at regs->nip is a store using
  * an update addressing form which will update r1.
@@ -168,7 +532,7 @@ int __kprobes do_page_fault(struct pt_re
 	 * indicate errors in DSISR but can validly be set in SRR1.
 	 */
 	if (trap == 0x400)
-		error_code &= 0x48200000;
+		error_code &= 0x58200000;
 	else
 		is_write = error_code & DSISR_ISSTORE;
 #else
@@ -295,9 +659,9 @@ good_area:
 		/* protection fault */
 		if (error_code & DSISR_PROTFAULT)
 			goto bad_area;
+#endif
 		if (!(vma->vm_flags & VM_EXEC))
 			goto bad_area;
-#endif
 #if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)
 		pte_t *ptep;
 		pmd_t *pmdp;
@@ -368,6 +732,37 @@ bad_area:
 bad_area_nosemaphore:
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+#ifdef CONFIG_PPC64
+			if (is_exec && (error_code & DSISR_PROTFAULT)) {
+#else
+			if (is_exec && regs->nip == address) {
+#endif
+				switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+				case 2:
+				case 3:
+				case 4:
+					return 0;
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+				case 5:
+				case 6:
+					return 0;
+#endif
+
+				}
+
+				pax_report_fault(regs, (void*)regs->nip, (void*)regs->gpr[PT_R1]);
+				do_exit(SIGKILL);
+			}
+		}
+#endif
+
 		_exception(SIGSEGV, regs, code, address);
 		return 0;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/powerpc/mm/hugetlbpage.c linux-2.6.20.1-pax/arch/powerpc/mm/hugetlbpage.c
--- linux-2.6.20.1/arch/powerpc/mm/hugetlbpage.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/powerpc/mm/hugetlbpage.c	2007-02-05 00:56:19.000000000 +0100
@@ -568,6 +568,10 @@ unsigned long arch_get_unmapped_area(str
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
@@ -579,7 +583,7 @@ unsigned long arch_get_unmapped_area(str
 	if (len > mm->cached_hole_size) {
 	        start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
+	        start_addr = addr = mm->mmap_base;
 	        mm->cached_hole_size = 0;
 	}
 
@@ -612,8 +616,8 @@ full_search:
 	}
 
 	/* Make sure we didn't miss any holes */
-	if (start_addr != TASK_UNMAPPED_BASE) {
-		start_addr = addr = TASK_UNMAPPED_BASE;
+	if (start_addr != mm->mmap_base) {
+		start_addr = addr = mm->mmap_base;
 		mm->cached_hole_size = 0;
 		goto full_search;
 	}
@@ -648,6 +652,11 @@ arch_get_unmapped_area_topdown(struct fi
 		mm->free_area_cache = base;
 
 	/* requesting a specific address */
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
@@ -727,12 +736,20 @@ fail:
 	 * can happen with large stack limits and large mmap()
 	 * allocations.
 	 */
-	mm->free_area_cache = TASK_UNMAPPED_BASE;
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
 	mm->cached_hole_size = ~0UL;
 	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
 	/*
 	 * Restore the topdown base:
 	 */
+	mm->mmap_base = base;
 	mm->free_area_cache = base;
 	mm->cached_hole_size = ~0UL;
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/powerpc/mm/mmap.c linux-2.6.20.1-pax/arch/powerpc/mm/mmap.c
--- linux-2.6.20.1/arch/powerpc/mm/mmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/powerpc/mm/mmap.c	2007-02-05 00:56:19.000000000 +0100
@@ -74,10 +74,22 @@ void arch_pick_mmap_layout(struct mm_str
 	 */
 	if (mmap_is_legacy()) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base();
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/ppc/mm/fault.c linux-2.6.20.1-pax/arch/ppc/mm/fault.c
--- linux-2.6.20.1/arch/ppc/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/ppc/mm/fault.c	2007-02-05 00:56:19.000000000 +0100
@@ -25,6 +25,11 @@
 #include <linux/interrupt.h>
 #include <linux/highmem.h>
 #include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
+#include <linux/unistd.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -48,6 +53,379 @@ unsigned long pte_misses;	/* updated by 
 unsigned long pte_errors;	/* updated by do_page_fault() */
 unsigned int probingmem;
 
+#ifdef CONFIG_PAX_EMUSIGRT
+void pax_syscall_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_syscall = 0UL;
+}
+
+static struct page* pax_syscall_nopage(struct vm_area_struct *vma, unsigned long address, int *type)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return NOPAGE_OOM;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x44000002U; /* sc */
+	__flush_dcache_icache(kaddr);
+	kunmap(page);
+	if (type)
+		*type = VM_FAULT_MAJOR;
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_syscall_close,
+	.nopage = pax_syscall_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & (VM_READ|VM_WRITE|VM_EXEC)];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched GOT trampoline was detected
+ *         3 when patched PLT trampoline was detected
+ *         4 when unpatched PLT trampoline was detected
+ *         5 when sigreturn trampoline was detected
+ *         6 when rt_sigreturn trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#if defined(CONFIG_PAX_EMUPLT) || defined(CONFIG_PAX_EMUSIGRT)
+	int err;
+#endif
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched GOT emulation */
+		unsigned int blrl;
+
+		err = get_user(blrl, (unsigned int*)regs->nip);
+
+		if (!err && blrl == 0x4E800021U) {
+			unsigned long temp = regs->nip;
+
+			regs->nip = regs->link & 0xFFFFFFFCUL;
+			regs->link = temp + 4UL;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int b;
+
+		err = get_user(b, (unsigned int *)regs->nip);
+
+		if (!err && (b & 0xFC000003U) == 0x48000000U) {
+			regs->nip += (((b | 0xFC000000UL) ^ 0x02000000UL) + 0x02000000UL);
+			return 3;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation #1 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(rlwinm, (unsigned int*)addr);
+			err |= get_user(add, (unsigned int*)(addr+4));
+			err |= get_user(li2, (unsigned int*)(addr+8));
+			err |= get_user(addis2, (unsigned int*)(addr+12));
+			err |= get_user(mtctr, (unsigned int*)(addr+16));
+			err |= get_user(li3, (unsigned int*)(addr+20));
+			err |= get_user(addis3, (unsigned int*)(addr+24));
+			err |= get_user(bctr, (unsigned int*)(addr+28));
+
+			if (err)
+				break;
+
+			if (rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+
+#if 0
+	do { /* PaX: unpatched PLT emulation #2 */
+		unsigned int lis, lwzu, b, bctr;
+
+		err = get_user(lis, (unsigned int *)regs->nip);
+		err |= get_user(lwzu, (unsigned int *)(regs->nip+4));
+		err |= get_user(b, (unsigned int *)(regs->nip+8));
+		err |= get_user(bctr, (unsigned int *)(regs->nip+12));
+
+		if (err)
+			break;
+
+		if ((lis & 0xFFFF0000U) == 0x39600000U &&
+		    (lwzu & 0xU) == 0xU &&
+		    (b & 0xFC000003U) == 0x48000000U &&
+		    bctr == 0x4E800420U)
+		{
+			unsigned int addis, addi, rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 12 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(addi, (unsigned int*)(addr+4));
+			err |= get_user(rlwinm, (unsigned int*)(addr+8));
+			err |= get_user(add, (unsigned int*)(addr+12));
+			err |= get_user(li2, (unsigned int*)(addr+16));
+			err |= get_user(addis2, (unsigned int*)(addr+20));
+			err |= get_user(mtctr, (unsigned int*)(addr+24));
+			err |= get_user(li3, (unsigned int*)(addr+28));
+			err |= get_user(addis3, (unsigned int*)(addr+32));
+			err |= get_user(bctr, (unsigned int*)(addr+36));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (addi & 0xFFFF0000U) == 0x396B0000U &&
+			    rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+	do { /* PaX: unpatched PLT emulation #3 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int addis, lwz, mtctr, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(lwz, (unsigned int*)(addr+4));
+			err |= get_user(mtctr, (unsigned int*)(addr+8));
+			err |= get_user(bctr, (unsigned int*)(addr+12));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (lwz & 0xFFFF0000U) == 0x816B0000U &&
+			    mtctr == 0x7D6903A6U &&
+			    bctr == 0x4E800420U)
+			{
+				unsigned int r11;
+
+				addr = (addis << 16) + (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				addr += (((lwz | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+
+				err = get_user(r11, (unsigned int*)addr);
+				if (err)
+					break;
+
+				regs->gpr[PT_R11] = r11;
+				regs->ctr = r11;
+				regs->nip = r11;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	do { /* PaX: sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned long call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+emulate:
+			regs->gpr[PT_R0] = __NR_sigreturn;
+			regs->nip = call_syscall;
+			return 5;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_rt_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned int call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto rt_emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto rt_emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+rt_emulate:
+			regs->gpr[PT_R0] = __NR_rt_sigreturn;
+			regs->nip = call_syscall;
+			return 6;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#if defined(CONFIG_PAX_EMUPLT) || defined(CONFIG_PAX_EMUSIGRT)
+	int err;
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * Check whether the instruction at regs->nip is a store using
  * an update addressing form which will update r1.
@@ -108,7 +486,7 @@ int do_page_fault(struct pt_regs *regs, 
 	 * indicate errors in DSISR but can validly be set in SRR1.
 	 */
 	if (TRAP(regs) == 0x400)
-		error_code &= 0x48200000;
+		error_code &= 0x58200000;
 	else
 		is_write = error_code & 0x02000000;
 #endif /* CONFIG_4xx || CONFIG_BOOKE */
@@ -203,15 +581,14 @@ good_area:
 		pte_t *ptep;
 		pmd_t *pmdp;
 
-#if 0
+#if 1
 		/* It would be nice to actually enforce the VM execute
 		   permission on CPUs which can do so, but far too
 		   much stuff in userspace doesn't get the permissions
 		   right, so we let any page be executed for now. */
 		if (! (vma->vm_flags & VM_EXEC))
 			goto bad_area;
-#endif
-
+#else
 		/* Since 4xx/Book-E supports per-page execute permission,
 		 * we lazily flush dcache to icache. */
 		ptep = NULL;
@@ -234,6 +611,7 @@ good_area:
 			pte_unmap_unlock(ptep, ptl);
 		}
 #endif
+#endif
 	/* a read */
 	} else {
 		/* protection fault */
@@ -279,6 +657,33 @@ bad_area:
 
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+			if ((TRAP(regs) == 0x400) && (regs->nip == address)) {
+				switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+				case 2:
+				case 3:
+				case 4:
+					return 0;
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+				case 5:
+				case 6:
+					return 0;
+#endif
+
+				}
+
+				pax_report_fault(regs, (void*)regs->nip, (void*)regs->gpr[1]);
+				do_exit(SIGKILL);
+			}
+		}
+#endif
+
 		_exception(SIGSEGV, regs, code, address);
 		return 0;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/s390/kernel/module.c linux-2.6.20.1-pax/arch/s390/kernel/module.c
--- linux-2.6.20.1/arch/s390/kernel/module.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/s390/kernel/module.c	2007-02-05 00:56:19.000000000 +0100
@@ -164,11 +164,11 @@ module_frob_arch_sections(Elf_Ehdr *hdr,
 
 	/* Increase core size by size of got & plt and set start
 	   offsets for got and plt. */
-	me->core_size = ALIGN(me->core_size, 4);
-	me->arch.got_offset = me->core_size;
-	me->core_size += me->arch.got_size;
-	me->arch.plt_offset = me->core_size;
-	me->core_size += me->arch.plt_size;
+	me->core_size_rw = ALIGN(me->core_size_rw, 4);
+	me->arch.got_offset = me->core_size_rw;
+	me->core_size_rw += me->arch.got_size;
+	me->arch.plt_offset = me->core_size_rx;
+	me->core_size_rx += me->arch.plt_size;
 	return 0;
 }
 
@@ -254,7 +254,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		if (info->got_initialized == 0) {
 			Elf_Addr *gotent;
 
-			gotent = me->module_core + me->arch.got_offset +
+			gotent = me->module_core_rw + me->arch.got_offset +
 				info->got_offset;
 			*gotent = val;
 			info->got_initialized = 1;
@@ -278,7 +278,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		else if (r_type == R_390_GOTENT ||
 			 r_type == R_390_GOTPLTENT)
 			*(unsigned int *) loc =
-				(val + (Elf_Addr) me->module_core - loc) >> 1;
+				(val + (Elf_Addr) me->module_core_rw - loc) >> 1;
 		else if (r_type == R_390_GOT64 ||
 			 r_type == R_390_GOTPLT64)
 			*(unsigned long *) loc = val;
@@ -292,7 +292,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 	case R_390_PLTOFF64:	/* 16 bit offset from GOT to PLT. */
 		if (info->plt_initialized == 0) {
 			unsigned int *ip;
-			ip = me->module_core + me->arch.plt_offset +
+			ip = me->module_core_rx + me->arch.plt_offset +
 				info->plt_offset;
 #ifndef CONFIG_64BIT
 			ip[0] = 0x0d105810; /* basr 1,0; l 1,6(1); br 1 */
@@ -314,7 +314,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 			val = me->arch.plt_offset - me->arch.got_offset +
 				info->plt_offset + rela->r_addend;
 		else
-			val =  (Elf_Addr) me->module_core +
+			val =  (Elf_Addr) me->module_core_rx +
 				me->arch.plt_offset + info->plt_offset + 
 				rela->r_addend - loc;
 		if (r_type == R_390_PLT16DBL)
@@ -334,7 +334,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 	case R_390_GOTOFF32:	/* 32 bit offset to GOT.  */
 	case R_390_GOTOFF64:	/* 64 bit offset to GOT. */
 		val = val + rela->r_addend -
-			((Elf_Addr) me->module_core + me->arch.got_offset);
+			((Elf_Addr) me->module_core_rw + me->arch.got_offset);
 		if (r_type == R_390_GOTOFF16)
 			*(unsigned short *) loc = val;
 		else if (r_type == R_390_GOTOFF32)
@@ -344,7 +344,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		break;
 	case R_390_GOTPC:	/* 32 bit PC relative offset to GOT. */
 	case R_390_GOTPCDBL:	/* 32 bit PC rel. off. to GOT shifted by 1. */
-		val = (Elf_Addr) me->module_core + me->arch.got_offset +
+		val = (Elf_Addr) me->module_core_rw + me->arch.got_offset +
 			rela->r_addend - loc;
 		if (r_type == R_390_GOTPC)
 			*(unsigned int *) loc = val;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc/kernel/sys_sparc.c linux-2.6.20.1-pax/arch/sparc/kernel/sys_sparc.c
--- linux-2.6.20.1/arch/sparc/kernel/sys_sparc.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc/kernel/sys_sparc.c	2007-02-05 00:56:19.000000000 +0100
@@ -57,7 +57,7 @@ unsigned long arch_get_unmapped_area(str
 	if (ARCH_SUN4C_SUN4 && len > 0x20000000)
 		return -ENOMEM;
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = current->mm->mmap_base;
 
 	if (flags & MAP_SHARED)
 		addr = COLOUR_ALIGN(addr);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc/mm/fault.c linux-2.6.20.1-pax/arch/sparc/mm/fault.c
--- linux-2.6.20.1/arch/sparc/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc/mm/fault.c	2007-02-05 00:56:19.000000000 +0100
@@ -21,6 +21,10 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
 
 #include <asm/system.h>
 #include <asm/page.h>
@@ -217,6 +221,252 @@ static unsigned long compute_si_addr(str
 	return safe_compute_effective_address(regs, insn);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_emuplt_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static struct page* pax_emuplt_nopage(struct vm_area_struct *vma, unsigned long address, int *type)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return NOPAGE_OOM;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(page);
+	kunmap(page);
+	if (type)
+		*type = VM_FAULT_MAJOR;
+
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.nopage = pax_emuplt_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & (VM_READ|VM_WRITE|VM_EXEC)];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int*)regs->pc);
+		err |= get_user(sethi2, (unsigned int*)(regs->pc+4));
+		err |= get_user(jmpl, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned int addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int*)regs->pc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned int addr;
+
+			addr = regs->pc + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->pc);
+		err |= get_user(jmpl, (unsigned int*)(regs->pc+4));
+		err |= get_user(nop, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->pc);
+		err |= get_user(ba, (unsigned int*)(regs->pc+4));
+		err |= get_user(nop, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr, save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->pc + 4 + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			else
+				addr = regs->pc + 4 + ((((ba | 0xFFF80000U) ^ 0x00040000U) + 0x00040000U) << 2);
+
+			err = get_user(save, (unsigned int*)addr);
+			err |= get_user(call, (unsigned int*)(addr+4));
+			err |= get_user(nop, (unsigned int*)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->pc = call_dl_resolve;
+				regs->npc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int*)(regs->pc-4));
+		err |= get_user(call, (unsigned int*)regs->pc);
+		err |= get_user(nop, (unsigned int*)(regs->pc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int dl_resolve = regs->pc + ((((call | 0xC0000000U) ^ 0x20000000U) + 0x20000000U) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->pc;
+			regs->pc = dl_resolve;
+			regs->npc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 			       unsigned long address)
 {
@@ -280,6 +530,24 @@ good_area:
 		if(!(vma->vm_flags & VM_WRITE))
 			goto bad_area;
 	} else {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && text_fault && !(vma->vm_flags & VM_EXEC)) {
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->pc, (void*)regs->u_regs[UREG_FP]);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		/* Allow reads even for write-only mappings */
 		if(!(vma->vm_flags & (VM_READ | VM_EXEC)))
 			goto bad_area;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc/mm/init.c linux-2.6.20.1-pax/arch/sparc/mm/init.c
--- linux-2.6.20.1/arch/sparc/mm/init.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc/mm/init.c	2007-02-05 00:56:19.000000000 +0100
@@ -333,17 +333,17 @@ void __init paging_init(void)
 
 	/* Initialize the protection map with non-constant, MMU dependent values. */
 	protection_map[0] = PAGE_NONE;
-	protection_map[1] = PAGE_READONLY;
-	protection_map[2] = PAGE_COPY;
-	protection_map[3] = PAGE_COPY;
+	protection_map[1] = PAGE_READONLY_NOEXEC;
+	protection_map[2] = PAGE_COPY_NOEXEC;
+	protection_map[3] = PAGE_COPY_NOEXEC;
 	protection_map[4] = PAGE_READONLY;
 	protection_map[5] = PAGE_READONLY;
 	protection_map[6] = PAGE_COPY;
 	protection_map[7] = PAGE_COPY;
 	protection_map[8] = PAGE_NONE;
-	protection_map[9] = PAGE_READONLY;
-	protection_map[10] = PAGE_SHARED;
-	protection_map[11] = PAGE_SHARED;
+	protection_map[9] = PAGE_READONLY_NOEXEC;
+	protection_map[10] = PAGE_SHARED_NOEXEC;
+	protection_map[11] = PAGE_SHARED_NOEXEC;
 	protection_map[12] = PAGE_READONLY;
 	protection_map[13] = PAGE_READONLY;
 	protection_map[14] = PAGE_SHARED;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc/mm/srmmu.c linux-2.6.20.1-pax/arch/sparc/mm/srmmu.c
--- linux-2.6.20.1/arch/sparc/mm/srmmu.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc/mm/srmmu.c	2007-02-05 00:56:19.000000000 +0100
@@ -2160,6 +2160,13 @@ void __init ld_mmu_srmmu(void)
 	BTFIXUPSET_INT(page_shared, pgprot_val(SRMMU_PAGE_SHARED));
 	BTFIXUPSET_INT(page_copy, pgprot_val(SRMMU_PAGE_COPY));
 	BTFIXUPSET_INT(page_readonly, pgprot_val(SRMMU_PAGE_RDONLY));
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	BTFIXUPSET_INT(page_shared_noexec, pgprot_val(SRMMU_PAGE_SHARED_NOEXEC));
+	BTFIXUPSET_INT(page_copy_noexec, pgprot_val(SRMMU_PAGE_COPY_NOEXEC));
+	BTFIXUPSET_INT(page_readonly_noexec, pgprot_val(SRMMU_PAGE_RDONLY_NOEXEC));
+#endif
+
 	BTFIXUPSET_INT(page_kernel, pgprot_val(SRMMU_PAGE_KERNEL));
 	page_kernel = pgprot_val(SRMMU_PAGE_KERNEL);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc64/kernel/Makefile linux-2.6.20.1-pax/arch/sparc64/kernel/Makefile
--- linux-2.6.20.1/arch/sparc64/kernel/Makefile	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc64/kernel/Makefile	2007-02-17 01:46:44.000000000 +0100
@@ -3,7 +3,7 @@
 #
 
 EXTRA_AFLAGS := -ansi
-EXTRA_CFLAGS := -Werror
+#EXTRA_CFLAGS := -Werror
 
 extra-y		:= head.o init_task.o vmlinux.lds
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc64/kernel/pci_iommu.c linux-2.6.20.1-pax/arch/sparc64/kernel/pci_iommu.c
--- linux-2.6.20.1/arch/sparc64/kernel/pci_iommu.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc64/kernel/pci_iommu.c	2007-02-19 16:19:07.000000000 +0100
@@ -64,7 +64,7 @@ static void __iommu_flushall(struct pci_
 #define IOPTE_IS_DUMMY(iommu, iopte)	\
 	((iopte_val(*iopte) & IOPTE_PAGE) == (iommu)->dummy_page_pa)
 
-static void inline iopte_make_dummy(struct pci_iommu *iommu, iopte_t *iopte)
+inline static void iopte_make_dummy(struct pci_iommu *iommu, iopte_t *iopte)
 {
 	unsigned long val = iopte_val(*iopte);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc64/kernel/sys_sparc.c linux-2.6.20.1-pax/arch/sparc64/kernel/sys_sparc.c
--- linux-2.6.20.1/arch/sparc64/kernel/sys_sparc.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc64/kernel/sys_sparc.c	2007-02-05 00:56:19.000000000 +0100
@@ -140,6 +140,10 @@ unsigned long arch_get_unmapped_area(str
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -153,9 +157,9 @@ unsigned long arch_get_unmapped_area(str
 	}
 
 	if (len > mm->cached_hole_size) {
-	        start_addr = addr = mm->free_area_cache;
+		start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
+		start_addr = addr = mm->mmap_base;
 	        mm->cached_hole_size = 0;
 	}
 
@@ -175,8 +179,8 @@ full_search:
 			vma = find_vma(mm, VA_EXCLUDE_END);
 		}
 		if (unlikely(task_size < addr)) {
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
@@ -379,6 +383,12 @@ void arch_pick_mmap_layout(struct mm_str
 	    current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY ||
 	    sysctl_legacy_va_layout) {
 		mm->mmap_base = TASK_UNMAPPED_BASE + random_factor;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
@@ -393,6 +403,12 @@ void arch_pick_mmap_layout(struct mm_str
 			gap = (task_size / 6 * 5);
 
 		mm->mmap_base = PAGE_ALIGN(task_size - gap - random_factor);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc64/mm/Makefile linux-2.6.20.1-pax/arch/sparc64/mm/Makefile
--- linux-2.6.20.1/arch/sparc64/mm/Makefile	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc64/mm/Makefile	2007-02-17 01:46:56.000000000 +0100
@@ -3,7 +3,7 @@
 #
 
 EXTRA_AFLAGS := -ansi
-EXTRA_CFLAGS := -Werror
+#EXTRA_CFLAGS := -Werror
 
 obj-y    := ultra.o tlb.o tsb.o fault.o init.o generic.o
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/sparc64/mm/fault.c linux-2.6.20.1-pax/arch/sparc64/mm/fault.c
--- linux-2.6.20.1/arch/sparc64/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/sparc64/mm/fault.c	2007-02-05 00:56:19.000000000 +0100
@@ -20,6 +20,10 @@
 #include <linux/interrupt.h>
 #include <linux/kprobes.h>
 #include <linux/kallsyms.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -290,6 +294,369 @@ cannot_handle:
 	unhandled_fault (address, current, regs);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_EMUPLT
+static void pax_emuplt_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static struct page* pax_emuplt_nopage(struct vm_area_struct *vma, unsigned long address, int *type)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return NOPAGE_OOM;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(page);
+	kunmap(page);
+	if (type)
+		*type = VM_FAULT_MAJOR;
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.nopage = pax_emuplt_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & (VM_READ|VM_WRITE|VM_EXEC)];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->tpc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int*)regs->tpc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned long addr;
+
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #4 */
+		unsigned int mov1, call, mov2;
+
+		err = get_user(mov1, (unsigned int*)regs->tpc);
+		err |= get_user(call, (unsigned int*)(regs->tpc+4));
+		err |= get_user(mov2, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if (mov1 == 0x8210000FU &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    mov2 == 0x9E100001U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = regs->u_regs[UREG_RETPC];
+			addr = regs->tpc + 4 + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #5 */
+		unsigned int sethi1, sethi2, or1, or2, sllx, jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(or1, (unsigned int*)(regs->tpc+8));
+		err |= get_user(or2, (unsigned int*)(regs->tpc+12));
+		err |= get_user(sllx, (unsigned int*)(regs->tpc+16));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+20));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+24));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    (or1 & 0xFFFFE000U) == 0x82106000U &&
+		    (or2 & 0xFFFFE000U) == 0x8A116000U &&
+		    sllx == 0x83287020 &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = ((sethi1 & 0x003FFFFFU) << 10) | (or1 & 0x000003FFU);
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or2 & 0x000003FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #6 */
+		unsigned int sethi1, sethi2, sllx, or,  jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(sllx, (unsigned int*)(regs->tpc+8));
+		err |= get_user(or, (unsigned int*)(regs->tpc+12));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+16));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+20));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    sllx == 0x83287020 &&
+		    (or & 0xFFFFE000U) == 0x8A116000U &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi1 & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or & 0x3FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #7 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(ba, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (ba & 0xFFF00000U) == 0x30600000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(ba, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+			unsigned int save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			else
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			err = get_user(save, (unsigned int*)addr);
+			err |= get_user(call, (unsigned int*)(addr+4));
+			err |= get_user(nop, (unsigned int*)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->tpc = call_dl_resolve;
+				regs->tnpc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int*)(regs->tpc-4));
+		err |= get_user(call, (unsigned int*)regs->tpc);
+		err |= get_user(nop, (unsigned int*)(regs->tpc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long dl_resolve = regs->tpc + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->tpc;
+			regs->tpc = dl_resolve;
+			regs->tnpc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)
 {
 	struct mm_struct *mm = current->mm;
@@ -332,8 +699,10 @@ asmlinkage void __kprobes do_sparc64_fau
 		goto intr_or_no_mm;
 
 	if (test_thread_flag(TIF_32BIT)) {
-		if (!(regs->tstate & TSTATE_PRIV))
+		if (!(regs->tstate & TSTATE_PRIV)) {
 			regs->tpc &= 0xffffffff;
+			regs->tnpc &= 0xffffffff;
+		}
 		address &= 0xffffffff;
 	}
 
@@ -350,6 +719,29 @@ asmlinkage void __kprobes do_sparc64_fau
 	if (!vma)
 		goto bad_area;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	/* PaX: detect ITLB misses on non-exec pages */
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && vma->vm_start <= address &&
+	    !(vma->vm_flags & VM_EXEC) && (fault_code & FAULT_CODE_ITLB))
+	{
+		if (address != regs->tpc)
+			goto good_area;
+
+		up_read(&mm->mmap_sem);
+		switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+		case 2:
+		case 3:
+			return;
+#endif
+
+		}
+		pax_report_fault(regs, (void*)regs->tpc, (void*)(regs->u_regs[UREG_FP] + STACK_BIAS));
+		do_exit(SIGKILL);
+	}
+#endif
+
 	/* Pure DTLB misses do not tell us whether the fault causing
 	 * load/store/atomic was a write or not, it only says that there
 	 * was no match.  So in such a case we (carefully) read the
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/v850/kernel/module.c linux-2.6.20.1-pax/arch/v850/kernel/module.c
--- linux-2.6.20.1/arch/v850/kernel/module.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/v850/kernel/module.c	2007-02-05 00:56:19.000000000 +0100
@@ -150,8 +150,8 @@ static uint32_t do_plt_call (void *locat
 	tramp[1] = ((val >> 16) & 0xffff) + 0x610000; /* ...; jmp r1 */
 
 	/* Init, or core PLT? */
-	if (location >= mod->module_core
-	    && location < mod->module_core + mod->core_size)
+	if (location >= mod->module_core_rx
+	    && location < mod->module_core_rx + mod->core_size_rx)
 		entry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;
 	else
 		entry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/boot/compressed/head.S linux-2.6.20.1-pax/arch/x86_64/boot/compressed/head.S
--- linux-2.6.20.1/arch/x86_64/boot/compressed/head.S	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/boot/compressed/head.S	2007-02-05 00:56:19.000000000 +0100
@@ -41,11 +41,13 @@ startup_32:
 	movl %eax,%gs
 
 	lss stack_start,%esp
+	movl 0x000000,%ecx
 	xorl %eax,%eax
 1:	incl %eax		# check that A20 really IS enabled
 	movl %eax,0x000000	# loop forever if it isn't
 	cmpl %eax,0x100000
 	je 1b
+	movl %ecx,0x000000
 
 /*
  * Initialize eflags.  Some BIOS's leave bits like NT set.  This would
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/ia32/ia32_binfmt.c linux-2.6.20.1-pax/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.6.20.1/arch/x86_64/ia32/ia32_binfmt.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/ia32/ia32_binfmt.c	2007-02-05 00:56:19.000000000 +0100
@@ -141,6 +141,17 @@ struct elf_prpsinfo
 //#include <asm/ia32.h>
 #include <linux/elf.h>
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x08048000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		16
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		16
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	16
+#endif
+
 typedef struct user_i387_ia32_struct elf_fpregset_t;
 typedef struct user32_fxsr_struct elf_fpxregset_t;
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/ia32/mmap32.c linux-2.6.20.1-pax/arch/x86_64/ia32/mmap32.c
--- linux-2.6.20.1/arch/x86_64/ia32/mmap32.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/ia32/mmap32.c	2007-02-05 00:56:19.000000000 +0100
@@ -68,10 +68,22 @@ void ia32_pick_mmap_layout(struct mm_str
 			(current->personality & ADDR_COMPAT_LAYOUT) ||
 			current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base(mm);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/ia32/syscall32.c linux-2.6.20.1-pax/arch/x86_64/ia32/syscall32.c
--- linux-2.6.20.1/arch/x86_64/ia32/syscall32.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/ia32/syscall32.c	2007-02-05 00:56:19.000000000 +0100
@@ -49,16 +49,21 @@ int syscall32_setup_pages(struct linux_b
 	struct mm_struct *mm = current->mm;
 	int ret;
 
-	vma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
 	if (!vma)
 		return -ENOMEM;
 
-	memset(vma, 0, sizeof(struct vm_area_struct));
 	/* Could randomize here */
 	vma->vm_start = VSYSCALL32_BASE;
 	vma->vm_end = VSYSCALL32_END;
 	/* MAYWRITE to allow gdb to COW and set breakpoints */
 	vma->vm_flags = VM_READ|VM_EXEC|VM_MAYREAD|VM_MAYEXEC|VM_MAYWRITE;
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (mm->pax_flags & MF_PAX_MPROTECT)
+		vma->vm_flags &= ~VM_MAYWRITE;
+#endif
+
 	/*
 	 * Make sure the vDSO gets into every core dump.
 	 * Dumping its contents makes post-mortem fully interpretable later
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/kernel/process.c linux-2.6.20.1-pax/arch/x86_64/kernel/process.c
--- linux-2.6.20.1/arch/x86_64/kernel/process.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/kernel/process.c	2007-02-05 00:56:19.000000000 +0100
@@ -878,10 +878,3 @@ int dump_task_regs(struct task_struct *t
  
 	return 1;
 }
-
-unsigned long arch_align_stack(unsigned long sp)
-{
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() % 8192;
-	return sp & ~0xf;
-}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/kernel/setup64.c linux-2.6.20.1-pax/arch/x86_64/kernel/setup64.c
--- linux-2.6.20.1/arch/x86_64/kernel/setup64.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/kernel/setup64.c	2007-02-05 00:56:19.000000000 +0100
@@ -38,7 +38,6 @@ char boot_cpu_stack[IRQSTACKSIZE] __attr
 
 unsigned long __supported_pte_mask __read_mostly = ~0UL;
 EXPORT_SYMBOL(__supported_pte_mask);
-static int do_not_nx __cpuinitdata = 0;
 
 /* noexec=on|off
 Control non executable mappings for 64bit processes.
@@ -52,16 +51,14 @@ static int __init nonx_setup(char *str)
 		return -EINVAL;
 	if (!strncmp(str, "on", 2)) {
                 __supported_pte_mask |= _PAGE_NX; 
- 		do_not_nx = 0; 
 	} else if (!strncmp(str, "off", 3)) {
-		do_not_nx = 1;
 		__supported_pte_mask &= ~_PAGE_NX;
         }
 	return 0;
 } 
 early_param("noexec", nonx_setup);
 
-int force_personality32 = 0; 
+int force_personality32;
 
 /* noexec32=on|off
 Control non executable heap for 32bit processes.
@@ -175,7 +172,7 @@ void __cpuinit check_efer(void)
 	unsigned long efer;
 
 	rdmsrl(MSR_EFER, efer); 
-        if (!(efer & EFER_NX) || do_not_nx) { 
+        if (!(efer & EFER_NX)) { 
                 __supported_pte_mask &= ~_PAGE_NX; 
         }       
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/kernel/signal.c linux-2.6.20.1-pax/arch/x86_64/kernel/signal.c
--- linux-2.6.20.1/arch/x86_64/kernel/signal.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/kernel/signal.c	2007-02-05 00:56:19.000000000 +0100
@@ -254,8 +254,8 @@ static int setup_rt_frame(int sig, struc
 	err |= setup_sigcontext(&frame->uc.uc_mcontext, regs, set->sig[0], me);
 	err |= __put_user(fp, &frame->uc.uc_mcontext.fpstate);
 	if (sizeof(*set) == 16) { 
-		__put_user(set->sig[0], &frame->uc.uc_sigmask.sig[0]);
-		__put_user(set->sig[1], &frame->uc.uc_sigmask.sig[1]); 
+		err |= __put_user(set->sig[0], &frame->uc.uc_sigmask.sig[0]);
+		err |= __put_user(set->sig[1], &frame->uc.uc_sigmask.sig[1]); 
 	} else
 		err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/kernel/sys_x86_64.c linux-2.6.20.1-pax/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.6.20.1/arch/x86_64/kernel/sys_x86_64.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/kernel/sys_x86_64.c	2007-02-05 00:56:20.000000000 +0100
@@ -65,8 +65,8 @@ out:
 	return error;
 }
 
-static void find_start_end(unsigned long flags, unsigned long *begin,
-			   unsigned long *end)
+static void find_start_end(struct mm_struct *mm, unsigned long flags,
+			   unsigned long *begin, unsigned long *end)
 {
 	if (!test_thread_flag(TIF_IA32) && (flags & MAP_32BIT)) {
 		/* This is usually used needed to map code in small
@@ -79,7 +79,7 @@ static void find_start_end(unsigned long
 		*begin = 0x40000000; 
 		*end = 0x80000000;		
 	} else {
-		*begin = TASK_UNMAPPED_BASE;
+		*begin = mm->mmap_base;
 		*end = TASK_SIZE; 
 	}
 } 
@@ -93,11 +93,15 @@ arch_get_unmapped_area(struct file *filp
 	unsigned long start_addr;
 	unsigned long begin, end;
 	
-	find_start_end(flags, &begin, &end); 
+	find_start_end(mm, flags, &begin, &end); 
 
 	if (len > end)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/mm/fault.c linux-2.6.20.1-pax/arch/x86_64/mm/fault.c
--- linux-2.6.20.1/arch/x86_64/mm/fault.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/mm/fault.c	2007-02-05 00:56:20.000000000 +0100
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/kprobes.h>
 #include <linux/uaccess.h>
+#include <linux/binfmts.h>
 
 #include <asm/system.h>
 #include <asm/pgalloc.h>
@@ -322,6 +323,33 @@ static int vmalloc_fault(unsigned long a
 	return 0;
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char __user *)pc+i))
+			printk("?? ");
+		else
+			printk("%02x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP-8: ");
+	for (i = -1; i < 10; i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long __user *)sp+i))
+			printk("???????????????? ");
+		else
+			printk("%016lx ", c);
+	}
+	printk("\n");
+}
+#endif
+
 int page_fault_trace = 0;
 int exception_trace = 1;
 
@@ -453,6 +481,8 @@ asmlinkage void __kprobes do_page_fault(
 good_area:
 	info.si_code = SEGV_ACCERR;
 	write = 0;
+	if ((error_code & PF_INSTR) && !(vma->vm_flags & VM_EXEC))
+		goto bad_area;
 	switch (error_code & (PF_PROT|PF_WRITE)) {
 		default:	/* 3: write, present */
 			/* fall through */
@@ -519,7 +549,14 @@ bad_area_nosemaphore:
 					tsk->comm, tsk->pid, address, regs->rip,
 					regs->rsp, error_code);
 		}
-       
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm && (mm->pax_flags & MF_PAX_PAGEEXEC) && (error_code & 16)) {
+			pax_report_fault(regs, (void*)regs->rip, (void*)regs->rsp);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		tsk->thread.cr2 = address;
 		/* Kernel addresses are always protection faults */
 		tsk->thread.error_code = error_code | (address >= TASK_SIZE);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/arch/x86_64/mm/mmap.c linux-2.6.20.1-pax/arch/x86_64/mm/mmap.c
--- linux-2.6.20.1/arch/x86_64/mm/mmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/arch/x86_64/mm/mmap.c	2007-02-05 00:56:20.000000000 +0100
@@ -23,6 +23,12 @@ void arch_pick_mmap_layout(struct mm_str
 		unsigned rnd = get_random_int() & 0xfffffff;
 		mm->mmap_base += ((unsigned long)rnd) << PAGE_SHIFT;
 	}
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
 	mm->get_unmapped_area = arch_get_unmapped_area;
 	mm->unmap_area = arch_unmap_area;
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/crypto/lrw.c linux-2.6.20.1-pax/crypto/lrw.c
--- linux-2.6.20.1/crypto/lrw.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/crypto/lrw.c	2007-02-16 00:37:01.000000000 +0100
@@ -54,7 +54,7 @@ static int setkey(struct crypto_tfm *par
 	struct priv *ctx = crypto_tfm_ctx(parent);
 	struct crypto_cipher *child = ctx->child;
 	int err, i;
-	be128 tmp = { 0 };
+	be128 tmp = { 0, 0 };
 	int bsize = crypto_cipher_blocksize(child);
 
 	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/acpi/blacklist.c linux-2.6.20.1-pax/drivers/acpi/blacklist.c
--- linux-2.6.20.1/drivers/acpi/blacklist.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/acpi/blacklist.c	2007-02-16 00:39:27.000000000 +0100
@@ -70,7 +70,7 @@ static struct acpi_blacklist_item acpi_b
 	{"ASUS\0\0", "P2B-S   ", 0, ACPI_DSDT, all_versions,
 	 "Bogus PCI routing", 1},
 
-	{""}
+	{"", "", 0, 0, 0, all_versions, 0}
 };
 
 #if	CONFIG_ACPI_BLACKLIST_YEAR
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/acpi/glue.c linux-2.6.20.1-pax/drivers/acpi/glue.c
--- linux-2.6.20.1/drivers/acpi/glue.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/acpi/glue.c	2007-02-05 00:56:20.000000000 +0100
@@ -16,7 +16,7 @@
 #if ACPI_GLUE_DEBUG
 #define DBG(x...) printk(PREFIX x)
 #else
-#define DBG(x...)
+#define DBG(x...) do {} while (0)
 #endif
 static LIST_HEAD(bus_type_list);
 static DECLARE_RWSEM(bus_type_sem);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/acpi/processor_core.c linux-2.6.20.1-pax/drivers/acpi/processor_core.c
--- linux-2.6.20.1/drivers/acpi/processor_core.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/acpi/processor_core.c	2007-02-05 00:56:20.000000000 +0100
@@ -531,7 +531,7 @@ static int __cpuinit acpi_processor_star
 		return 0;
 	}
 
-	BUG_ON((pr->id >= NR_CPUS) || (pr->id < 0));
+	BUG_ON(pr->id >= NR_CPUS);
 
 	/*
 	 * Buggy BIOS check
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/acpi/processor_idle.c linux-2.6.20.1-pax/drivers/acpi/processor_idle.c
--- linux-2.6.20.1/drivers/acpi/processor_idle.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/acpi/processor_idle.c	2007-02-16 00:40:20.000000000 +0100
@@ -153,7 +153,7 @@ static struct dmi_system_id __cpuinitdat
 	  DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
 	  DMI_MATCH(DMI_BIOS_VERSION,"SHE845M0.86C.0013.D.0302131307")},
 	 (void *)2},
-	{},
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL},
 };
 
 static inline u32 ticks_elapsed(u32 t1, u32 t2)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/acpi/sleep/main.c linux-2.6.20.1-pax/drivers/acpi/sleep/main.c
--- linux-2.6.20.1/drivers/acpi/sleep/main.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/acpi/sleep/main.c	2007-02-16 00:39:56.000000000 +0100
@@ -197,7 +197,7 @@ static struct dmi_system_id __initdata a
 	 .ident = "Toshiba Satellite 4030cdt",
 	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "S4030CDT/4.3"),},
 	 },
-	{},
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL},
 };
 
 static int __init acpi_sleep_init(void)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ata/ata_piix.c linux-2.6.20.1-pax/drivers/ata/ata_piix.c
--- linux-2.6.20.1/drivers/ata/ata_piix.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ata/ata_piix.c	2007-02-16 00:42:56.000000000 +0100
@@ -247,7 +247,7 @@ static const struct pci_device_id piix_p
 	/* SATA Controller IDE (ICH9M) */
 	{ 0x8086, 0x292e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_ahci },
 
-	{ }	/* terminate list */
+	{ 0, 0, 0, 0, 0, 0, 0 }	/* terminate list */
 };
 
 static struct pci_driver piix_pci_driver = {
@@ -570,7 +570,7 @@ static const struct ich_laptop ich_lapto
 	/* devid, subvendor, subdev */
 	{ 0x27DF, 0x0005, 0x0280 },	/* ICH7 on Acer 5602WLMi */
 	/* end marker */
-	{ 0, }
+	{ 0, 0, 0 }
 };
 
 /**
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ata/libata-core.c linux-2.6.20.1-pax/drivers/ata/libata-core.c
--- linux-2.6.20.1/drivers/ata/libata-core.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ata/libata-core.c	2007-02-16 00:42:07.000000000 +0100
@@ -460,7 +460,7 @@ static const struct ata_xfer_ent {
 	{ ATA_SHIFT_PIO, ATA_BITS_PIO, XFER_PIO_0 },
 	{ ATA_SHIFT_MWDMA, ATA_BITS_MWDMA, XFER_MW_DMA_0 },
 	{ ATA_SHIFT_UDMA, ATA_BITS_UDMA, XFER_UDMA_0 },
-	{ -1, },
+	{ -1, 0, 0 },
 };
 
 /**
@@ -2226,7 +2226,7 @@ static const struct ata_timing ata_timin
 
 /*	{ XFER_PIO_SLOW, 120, 290, 240, 960, 290, 240, 960,   0 }, */
 
-	{ 0xFF }
+	{ 0xFF, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 #define ENOUGH(v,unit)		(((v)-1)/(unit)+1)
@@ -3321,7 +3321,7 @@ static const struct ata_blacklist_entry 
 	/* Devices with NCQ limits */
 
 	/* End Marker */
-	{ }
+	{ NULL, NULL, 0 }
 };
 
 static int ata_strim(char *s, size_t len)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/agp/frontend.c linux-2.6.20.1-pax/drivers/char/agp/frontend.c
--- linux-2.6.20.1/drivers/char/agp/frontend.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/agp/frontend.c	2007-02-05 00:56:20.000000000 +0100
@@ -818,7 +818,7 @@ static int agpioc_reserve_wrap(struct ag
 	if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))
 		return -EFAULT;
 
-	if ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment))
+	if ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment_priv))
 		return -EFAULT;
 
 	client = agp_find_client_by_pid(reserve.pid);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/agp/intel-agp.c linux-2.6.20.1-pax/drivers/char/agp/intel-agp.c
--- linux-2.6.20.1/drivers/char/agp/intel-agp.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/agp/intel-agp.c	2007-02-16 00:48:37.000000000 +0100
@@ -2024,7 +2024,7 @@ static struct pci_device_id agp_intel_pc
 	ID(PCI_DEVICE_ID_INTEL_82965G_1_HB),
 	ID(PCI_DEVICE_ID_INTEL_82965Q_HB),
 	ID(PCI_DEVICE_ID_INTEL_82965G_HB),
-	{ }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, agp_intel_pci_table);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/drm/drm_drawable.c linux-2.6.20.1-pax/drivers/char/drm/drm_drawable.c
--- linux-2.6.20.1/drivers/char/drm/drm_drawable.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/drm/drm_drawable.c	2007-02-16 00:49:05.000000000 +0100
@@ -234,7 +234,7 @@ int drm_update_drawable_info(DRM_IOCTL_A
 	idx = id / (8 * sizeof(*bitfield));
 	shift = id % (8 * sizeof(*bitfield));
 
-	if (idx < 0 || idx >= bitfield_length ||
+	if (idx >= bitfield_length ||
 	    !(bitfield[idx] & (1 << shift))) {
 		DRM_ERROR("No such drawable %d\n", update.handle);
 		return DRM_ERR(EINVAL);
@@ -319,7 +319,7 @@ drm_drawable_info_t *drm_get_drawable_in
 	idx = id / (8 * sizeof(*bitfield));
 	shift = id % (8 * sizeof(*bitfield));
 
-	if (idx < 0 || idx >= dev->drw_bitfield_length ||
+	if (idx >= dev->drw_bitfield_length ||
 	    !(bitfield[idx] & (1 << shift))) {
 		DRM_DEBUG("No such drawable %d\n", id);
 		return NULL;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/drm/drm_pciids.h linux-2.6.20.1-pax/drivers/char/drm/drm_pciids.h
--- linux-2.6.20.1/drivers/char/drm/drm_pciids.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/drm/drm_pciids.h	2007-02-16 00:50:02.000000000 +0100
@@ -239,7 +239,7 @@
 	{0x8086, 0x7123, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
 	{0x8086, 0x7125, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
 	{0x8086, 0x1132, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
+	{0, 0, 0, 0, 0, 0, 0 }
 
 #define i830_PCI_IDS \
 	{0x8086, 0x3577, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/hpet.c linux-2.6.20.1-pax/drivers/char/hpet.c
--- linux-2.6.20.1/drivers/char/hpet.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/hpet.c	2007-02-16 00:46:06.000000000 +0100
@@ -1008,7 +1008,7 @@ static struct acpi_driver hpet_acpi_driv
 		},
 };
 
-static struct miscdevice hpet_misc = { HPET_MINOR, "hpet", &hpet_fops };
+static struct miscdevice hpet_misc = { HPET_MINOR, "hpet", &hpet_fops, {NULL, NULL}, NULL, NULL };
 
 static int __init hpet_init(void)
 {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/hw_random/intel-rng.c linux-2.6.20.1-pax/drivers/char/hw_random/intel-rng.c
--- linux-2.6.20.1/drivers/char/hw_random/intel-rng.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/hw_random/intel-rng.c	2007-02-16 00:50:28.000000000 +0100
@@ -139,7 +139,7 @@ static const struct pci_device_id pci_tb
 /* E
 	{ 0x8086, 0x245e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, }, */
 	{ 0x8086, 0x2450, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, }, /* E  */
-	{ 0, },	/* terminate list */
+	{ 0, 0, 0, 0, 0, 0, 0 },	/* terminate list */
 };
 MODULE_DEVICE_TABLE(pci, pci_tbl);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/keyboard.c linux-2.6.20.1-pax/drivers/char/keyboard.c
--- linux-2.6.20.1/drivers/char/keyboard.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/keyboard.c	2007-02-16 00:45:37.000000000 +0100
@@ -203,7 +203,7 @@ int setkeycode(unsigned int scancode, un
 
 	if (scancode >= dev->keycodemax)
 		return -EINVAL;
-	if (keycode < 0 || keycode > KEY_MAX)
+	if (keycode > KEY_MAX)
 		return -EINVAL;
 	if (dev->keycodesize < sizeof(keycode) && (keycode >> (dev->keycodesize * 8)))
 		return -EINVAL;
@@ -1354,7 +1354,7 @@ static const struct input_device_id kbd_
                 .evbit = { BIT(EV_SND) },
         },
 
-	{ },    /* Terminating entry */
+	{ 0 },    /* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(input, kbd_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/mem.c linux-2.6.20.1-pax/drivers/char/mem.c
--- linux-2.6.20.1/drivers/char/mem.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/mem.c	2007-02-05 00:56:20.000000000 +0100
@@ -645,8 +645,24 @@ static inline size_t read_zero_pagealign
 		if (count > size)
 			count = size;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR) {
+			unsigned long addr_m;
+			struct vm_area_struct * vma_m;
+
+			addr_m = vma->vm_start + vma->vm_mirror;
+			vma_m = find_vma(mm, addr_m);
+			if (vma_m && vma_m->vm_start == addr_m && (vma_m->vm_flags & VM_MIRROR)) {
+				addr_m = addr + vma->vm_mirror;
+				zap_page_range(vma_m, addr_m, count, NULL);
+			} else
+				printk(KERN_ERR "PAX: VMMIRROR: read_zero bug, %08lx, %08lx\n",
+				       addr, vma->vm_start);
+		}
+#endif
+
 		zap_page_range(vma, addr, count, NULL);
-        	if (zeromap_page_range(vma, addr, count, PAGE_COPY))
+        	if (zeromap_page_range(vma, addr, count, vma->vm_page_prot))
 			break;
 
 		size -= count;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/n_tty.c linux-2.6.20.1-pax/drivers/char/n_tty.c
--- linux-2.6.20.1/drivers/char/n_tty.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/n_tty.c	2007-02-16 00:44:51.000000000 +0100
@@ -1559,6 +1559,8 @@ struct tty_ldisc tty_ldisc_N_TTY = {
 	normal_poll,		/* poll */
 	NULL,			/* hangup */
 	n_tty_receive_buf,	/* receive_buf */
-	n_tty_write_wakeup	/* write_wakeup */
+	n_tty_write_wakeup,	/* write_wakeup */
+	NULL,			/* owner */
+	0			/* refcount */
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/nvram.c linux-2.6.20.1-pax/drivers/char/nvram.c
--- linux-2.6.20.1/drivers/char/nvram.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/nvram.c	2007-02-16 00:47:57.000000000 +0100
@@ -450,7 +450,10 @@ static const struct file_operations nvra
 static struct miscdevice nvram_dev = {
 	NVRAM_MINOR,
 	"nvram",
-	&nvram_fops
+	&nvram_fops,
+	{NULL, NULL},
+	NULL,
+	NULL
 };
 
 static int __init
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/char/random.c linux-2.6.20.1-pax/drivers/char/random.c
--- linux-2.6.20.1/drivers/char/random.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/char/random.c	2007-02-05 00:56:20.000000000 +0100
@@ -1662,3 +1662,23 @@ randomize_range(unsigned long start, uns
 		return 0;
 	return PAGE_ALIGN(get_random_int() % range + start);
 }
+
+unsigned long pax_get_random_long(void)
+{
+	static time_t	rekey_time;
+	static __u32	secret[12];
+	time_t		t;
+
+	/*
+	 * Pick a random secret every REKEY_INTERVAL seconds.
+	 */
+	t = get_seconds();
+	if (!rekey_time || (t - rekey_time) > REKEY_INTERVAL) {
+		rekey_time = t;
+		get_random_bytes(secret, sizeof(secret));
+	}
+
+	secret[1] = half_md4_transform(secret+8, secret);
+	secret[0] = half_md4_transform(secret+8, secret);
+	return *(unsigned long *)secret;
+}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/edac/edac_mc.h linux-2.6.20.1-pax/drivers/edac/edac_mc.h
--- linux-2.6.20.1/drivers/edac/edac_mc.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/edac/edac_mc.h	2007-02-05 00:56:20.000000000 +0100
@@ -71,11 +71,11 @@ extern int edac_debug_level;
 
 #else  /* !CONFIG_EDAC_DEBUG */
 
-#define debugf0( ... )
-#define debugf1( ... )
-#define debugf2( ... )
-#define debugf3( ... )
-#define debugf4( ... )
+#define debugf0( ... ) do {} while (0)
+#define debugf1( ... ) do {} while (0)
+#define debugf2( ... ) do {} while (0)
+#define debugf3( ... ) do {} while (0)
+#define debugf4( ... ) do {} while (0)
 
 #endif  /* !CONFIG_EDAC_DEBUG */
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/hwmon/fscpos.c linux-2.6.20.1-pax/drivers/hwmon/fscpos.c
--- linux-2.6.20.1/drivers/hwmon/fscpos.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/hwmon/fscpos.c	2007-02-05 00:56:20.000000000 +0100
@@ -231,7 +231,6 @@ static ssize_t set_pwm(struct i2c_client
 	unsigned long v = simple_strtoul(buf, NULL, 10);
 
 	/* Range: 0..255 */
-	if (v < 0) v = 0;
 	if (v > 255) v = 255;
 
 	mutex_lock(&data->update_lock);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/hwmon/k8temp.c linux-2.6.20.1-pax/drivers/hwmon/k8temp.c
--- linux-2.6.20.1/drivers/hwmon/k8temp.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/hwmon/k8temp.c	2007-02-16 00:50:48.000000000 +0100
@@ -130,7 +130,7 @@ static DEVICE_ATTR(name, S_IRUGO, show_n
 
 static struct pci_device_id k8temp_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB_MISC) },
-	{ 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 MODULE_DEVICE_TABLE(pci, k8temp_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/hwmon/sis5595.c linux-2.6.20.1-pax/drivers/hwmon/sis5595.c
--- linux-2.6.20.1/drivers/hwmon/sis5595.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/hwmon/sis5595.c	2007-02-16 00:51:07.000000000 +0100
@@ -757,7 +757,7 @@ static struct sis5595_data *sis5595_upda
 
 static struct pci_device_id sis5595_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_503) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, sis5595_pci_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/hwmon/via686a.c linux-2.6.20.1-pax/drivers/hwmon/via686a.c
--- linux-2.6.20.1/drivers/hwmon/via686a.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/hwmon/via686a.c	2007-02-16 00:51:25.000000000 +0100
@@ -814,7 +814,7 @@ static struct via686a_data *via686a_upda
 
 static struct pci_device_id via686a_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686_4) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, via686a_pci_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/hwmon/vt8231.c linux-2.6.20.1-pax/drivers/hwmon/vt8231.c
--- linux-2.6.20.1/drivers/hwmon/vt8231.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/hwmon/vt8231.c	2007-02-16 00:51:43.000000000 +0100
@@ -666,7 +666,7 @@ static struct i2c_driver vt8231_driver =
 
 static struct pci_device_id vt8231_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8231_4) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, vt8231_pci_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/hwmon/w83791d.c linux-2.6.20.1-pax/drivers/hwmon/w83791d.c
--- linux-2.6.20.1/drivers/hwmon/w83791d.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/hwmon/w83791d.c	2007-02-05 00:56:20.000000000 +0100
@@ -289,8 +289,8 @@ static int w83791d_attach_adapter(struct
 static int w83791d_detect(struct i2c_adapter *adapter, int address, int kind);
 static int w83791d_detach_client(struct i2c_client *client);
 
-static int w83791d_read(struct i2c_client *client, u8 register);
-static int w83791d_write(struct i2c_client *client, u8 register, u8 value);
+static int w83791d_read(struct i2c_client *client, u8 reg);
+static int w83791d_write(struct i2c_client *client, u8 reg, u8 value);
 static struct w83791d_data *w83791d_update_device(struct device *dev);
 
 #ifdef DEBUG
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/i2c/busses/i2c-i801.c linux-2.6.20.1-pax/drivers/i2c/busses/i2c-i801.c
--- linux-2.6.20.1/drivers/i2c/busses/i2c-i801.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/i2c/busses/i2c-i801.c	2007-02-16 00:54:52.000000000 +0100
@@ -459,7 +459,7 @@ static struct pci_device_id i801_ids[] =
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ESB2_17) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH8_5) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH9_6) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (pci, i801_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/i2c/busses/i2c-i810.c linux-2.6.20.1-pax/drivers/i2c/busses/i2c-i810.c
--- linux-2.6.20.1/drivers/i2c/busses/i2c-i810.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/i2c/busses/i2c-i810.c	2007-02-16 00:55:09.000000000 +0100
@@ -196,7 +196,7 @@ static struct pci_device_id i810_ids[] _
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810E_IG) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_CGC) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82845G_IG) },
-	{ 0, },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 MODULE_DEVICE_TABLE (pci, i810_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/i2c/busses/i2c-piix4.c linux-2.6.20.1-pax/drivers/i2c/busses/i2c-piix4.c
--- linux-2.6.20.1/drivers/i2c/busses/i2c-piix4.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/i2c/busses/i2c-piix4.c	2007-02-16 00:55:51.000000000 +0100
@@ -113,7 +113,7 @@ static struct dmi_system_id __devinitdat
 		.ident = "IBM",
 		.matches = { DMI_MATCH(DMI_SYS_VENDOR, "IBM"), },
 	},
-	{ },
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL },
 };
 
 static int __devinit piix4_setup(struct pci_dev *PIIX4_dev,
@@ -408,7 +408,7 @@ static struct pci_device_id piix4_ids[] 
 	  .driver_data = 3 },
 	{ PCI_DEVICE(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_3),
 	  .driver_data = 0 },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (pci, piix4_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/i2c/i2c-core.c linux-2.6.20.1-pax/drivers/i2c/i2c-core.c
--- linux-2.6.20.1/drivers/i2c/i2c-core.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/i2c/i2c-core.c	2007-02-16 00:54:26.000000000 +0100
@@ -113,7 +113,7 @@ static ssize_t i2c_adapter_show_name(str
 
 static struct class_device_attribute i2c_adapter_attrs[] = {
 	__ATTR(name, S_IRUGO, i2c_adapter_show_name, NULL),
-	{ },
+	{ {NULL, NULL, 0}, NULL, NULL },
 };
 
 struct class i2c_adapter_class = {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ide/ide-cd.c linux-2.6.20.1-pax/drivers/ide/ide-cd.c
--- linux-2.6.20.1/drivers/ide/ide-cd.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ide/ide-cd.c	2007-02-05 00:56:20.000000000 +0100
@@ -457,8 +457,6 @@ void cdrom_analyze_sense_data(ide_drive_
 			sector &= ~(bio_sectors -1);
 			valid = (sector - failed_command->sector) << 9;
 
-			if (valid < 0)
-				valid = 0;
 			if (sector < get_capacity(info->disk) &&
 				drive->probed_capacity - sector < 4 * 75) {
 				set_capacity(info->disk, sector);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ieee1394/dv1394.c linux-2.6.20.1-pax/drivers/ieee1394/dv1394.c
--- linux-2.6.20.1/drivers/ieee1394/dv1394.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ieee1394/dv1394.c	2007-02-16 00:21:36.000000000 +0100
@@ -740,7 +740,7 @@ static void frame_prepare(struct video_c
 	based upon DIF section and sequence
 */
 
-static void inline
+static inline void
 frame_put_packet (struct frame *f, struct packet *p)
 {
 	int section_type = p->data[0] >> 5;           /* section type is in bits 5 - 7 */
@@ -919,7 +919,7 @@ static int do_dv1394_init(struct video_c
 		/* default SYT offset is 3 cycles */
 		init->syt_offset = 3;
 
-	if ( (init->channel > 63) || (init->channel < 0) )
+	if (init->channel > 63)
 		init->channel = 63;
 
 	chan_mask = (u64)1 << init->channel;
@@ -2174,7 +2174,7 @@ static struct ieee1394_device_id dv1394_
 		.specifier_id	= AVC_UNIT_SPEC_ID_ENTRY & 0xffffff,
 		.version	= AVC_SW_VERSION_ENTRY & 0xffffff
 	},
-	{ }
+	{ 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(ieee1394, dv1394_id_table);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ieee1394/eth1394.c linux-2.6.20.1-pax/drivers/ieee1394/eth1394.c
--- linux-2.6.20.1/drivers/ieee1394/eth1394.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ieee1394/eth1394.c	2007-02-16 00:20:51.000000000 +0100
@@ -468,7 +468,7 @@ static struct ieee1394_device_id eth1394
 		.specifier_id =	ETHER1394_GASP_SPECIFIER_ID,
 		.version = ETHER1394_GASP_VERSION,
 	},
-	{}
+	{ 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(ieee1394, eth1394_id_table);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ieee1394/hosts.c linux-2.6.20.1-pax/drivers/ieee1394/hosts.c
--- linux-2.6.20.1/drivers/ieee1394/hosts.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ieee1394/hosts.c	2007-02-05 00:56:20.000000000 +0100
@@ -79,6 +79,7 @@ static int dummy_isoctl(struct hpsb_iso 
 }
 
 static struct hpsb_host_driver dummy_driver = {
+	.name =		   "dummy",
 	.transmit_packet = dummy_transmit_packet,
 	.devctl =	   dummy_devctl,
 	.isoctl =	   dummy_isoctl
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ieee1394/ohci1394.c linux-2.6.20.1-pax/drivers/ieee1394/ohci1394.c
--- linux-2.6.20.1/drivers/ieee1394/ohci1394.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ieee1394/ohci1394.c	2007-02-16 00:23:19.000000000 +0100
@@ -161,9 +161,9 @@ printk(level "%s: " fmt "\n" , OHCI1394_
 printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, ohci->host->id , ## args)
 
 /* Module Parameters */
-static int phys_dma = 1;
+static int phys_dma = 0;
 module_param(phys_dma, int, 0444);
-MODULE_PARM_DESC(phys_dma, "Enable physical dma (default = 1).");
+MODULE_PARM_DESC(phys_dma, "Enable physical dma (default = 0).");
 
 static void dma_trm_tasklet(unsigned long data);
 static void dma_trm_reset(struct dma_trm_ctx *d);
@@ -3645,7 +3645,7 @@ static struct pci_device_id ohci1394_pci
 		.subvendor =	PCI_ANY_ID,
 		.subdevice =	PCI_ANY_ID,
 	},
-	{ 0, },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 MODULE_DEVICE_TABLE(pci, ohci1394_pci_tbl);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ieee1394/raw1394.c linux-2.6.20.1-pax/drivers/ieee1394/raw1394.c
--- linux-2.6.20.1/drivers/ieee1394/raw1394.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ieee1394/raw1394.c	2007-02-16 00:22:38.000000000 +0100
@@ -2981,7 +2981,7 @@ static struct ieee1394_device_id raw1394
 	 .match_flags = IEEE1394_MATCH_SPECIFIER_ID | IEEE1394_MATCH_VERSION,
 	 .specifier_id = CAMERA_UNIT_SPEC_ID_ENTRY & 0xffffff,
 	 .version = (CAMERA_SW_VERSION_ENTRY + 2) & 0xffffff},
-	{}
+	{ 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(ieee1394, raw1394_id_table);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ieee1394/sbp2.c linux-2.6.20.1-pax/drivers/ieee1394/sbp2.c
--- linux-2.6.20.1/drivers/ieee1394/sbp2.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ieee1394/sbp2.c	2007-02-16 00:22:21.000000000 +0100
@@ -250,7 +250,7 @@ static struct ieee1394_device_id sbp2_id
 	 .match_flags	= IEEE1394_MATCH_SPECIFIER_ID | IEEE1394_MATCH_VERSION,
 	 .specifier_id	= SBP2_UNIT_SPEC_ID_ENTRY & 0xffffff,
 	 .version	= SBP2_SW_VERSION_ENTRY & 0xffffff},
-	{}
+	{ 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(ieee1394, sbp2_id_table);
 
@@ -2118,7 +2118,7 @@ MODULE_DESCRIPTION("IEEE-1394 SBP-2 prot
 MODULE_SUPPORTED_DEVICE(SBP2_DEVICE_NAME);
 MODULE_LICENSE("GPL");
 
-static int sbp2_module_init(void)
+static int __init sbp2_module_init(void)
 {
 	int ret;
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/ieee1394/video1394.c linux-2.6.20.1-pax/drivers/ieee1394/video1394.c
--- linux-2.6.20.1/drivers/ieee1394/video1394.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/ieee1394/video1394.c	2007-02-16 00:22:59.000000000 +0100
@@ -891,7 +891,7 @@ static long video1394_ioctl(struct file 
 		if (unlikely(d == NULL))
 			return -EFAULT;
 
-		if (unlikely((v.buffer<0) || (v.buffer>=d->num_desc - 1))) {
+		if (unlikely(v.buffer>=d->num_desc - 1)) {
 			PRINT(KERN_ERR, ohci->host->id,
 			      "Buffer %d out of range",v.buffer);
 			return -EINVAL;
@@ -957,7 +957,7 @@ static long video1394_ioctl(struct file 
 		if (unlikely(d == NULL))
 			return -EFAULT;
 
-		if (unlikely((v.buffer<0) || (v.buffer>d->num_desc - 1))) {
+		if (unlikely(v.buffer>d->num_desc - 1)) {
 			PRINT(KERN_ERR, ohci->host->id,
 			      "Buffer %d out of range",v.buffer);
 			return -EINVAL;
@@ -1028,7 +1028,7 @@ static long video1394_ioctl(struct file 
 		d = find_ctx(&ctx->context_list, OHCI_ISO_TRANSMIT, v.channel);
 		if (d == NULL) return -EFAULT;
 
-		if ((v.buffer<0) || (v.buffer>=d->num_desc - 1)) {
+		if (v.buffer>=d->num_desc - 1) {
 			PRINT(KERN_ERR, ohci->host->id,
 			      "Buffer %d out of range",v.buffer);
 			return -EINVAL;
@@ -1130,7 +1130,7 @@ static long video1394_ioctl(struct file 
 		d = find_ctx(&ctx->context_list, OHCI_ISO_TRANSMIT, v.channel);
 		if (d == NULL) return -EFAULT;
 
-		if ((v.buffer<0) || (v.buffer>=d->num_desc-1)) {
+		if (v.buffer>=d->num_desc-1) {
 			PRINT(KERN_ERR, ohci->host->id,
 			      "Buffer %d out of range",v.buffer);
 			return -EINVAL;
@@ -1302,7 +1302,7 @@ static struct ieee1394_device_id video13
                 .specifier_id   = CAMERA_UNIT_SPEC_ID_ENTRY & 0xffffff,
                 .version        = (CAMERA_SW_VERSION_ENTRY + 2) & 0xffffff
         },
-	{ }
+	{ 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(ieee1394, video1394_id_table);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/input/keyboard/atkbd.c linux-2.6.20.1-pax/drivers/input/keyboard/atkbd.c
--- linux-2.6.20.1/drivers/input/keyboard/atkbd.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/input/keyboard/atkbd.c	2007-02-16 00:18:53.000000000 +0100
@@ -1065,7 +1065,7 @@ static struct serio_device_id atkbd_seri
 		.id	= SERIO_ANY,
 		.extra	= SERIO_ANY,
 	},
-	{ 0 }
+	{ 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(serio, atkbd_serio_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/input/mouse/lifebook.c linux-2.6.20.1-pax/drivers/input/mouse/lifebook.c
--- linux-2.6.20.1/drivers/input/mouse/lifebook.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/input/mouse/lifebook.c	2007-02-16 00:17:23.000000000 +0100
@@ -63,7 +63,7 @@ static struct dmi_system_id lifebook_dmi
 			DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook B142"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL}
 };
 
 static psmouse_ret_t lifebook_process_byte(struct psmouse *psmouse)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/input/mouse/psmouse-base.c linux-2.6.20.1-pax/drivers/input/mouse/psmouse-base.c
--- linux-2.6.20.1/drivers/input/mouse/psmouse-base.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/input/mouse/psmouse-base.c	2007-02-16 00:18:35.000000000 +0100
@@ -1254,7 +1254,7 @@ static struct serio_device_id psmouse_se
 		.id	= SERIO_ANY,
 		.extra	= SERIO_ANY,
 	},
-	{ 0 }
+	{ 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(serio, psmouse_serio_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/input/mouse/synaptics.c linux-2.6.20.1-pax/drivers/input/mouse/synaptics.c
--- linux-2.6.20.1/drivers/input/mouse/synaptics.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/input/mouse/synaptics.c	2007-02-16 00:17:49.000000000 +0100
@@ -617,7 +617,7 @@ static struct dmi_system_id toshiba_dmi_
 			DMI_MATCH(DMI_PRODUCT_NAME, "PORTEGE M300"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/input/mousedev.c linux-2.6.20.1-pax/drivers/input/mousedev.c
--- linux-2.6.20.1/drivers/input/mousedev.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/input/mousedev.c	2007-02-16 00:19:50.000000000 +0100
@@ -731,7 +731,7 @@ static struct input_handler mousedev_han
 
 #ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
 static struct miscdevice psaux_mouse = {
-	PSMOUSE_MINOR, "psaux", &mousedev_fops
+	PSMOUSE_MINOR, "psaux", &mousedev_fops, {NULL, NULL}, NULL, NULL
 };
 static int psaux_registered;
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/input/serio/i8042-x86ia64io.h linux-2.6.20.1-pax/drivers/input/serio/i8042-x86ia64io.h
--- linux-2.6.20.1/drivers/input/serio/i8042-x86ia64io.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/input/serio/i8042-x86ia64io.h	2007-02-16 00:16:54.000000000 +0100
@@ -92,7 +92,7 @@ static struct dmi_system_id __initdata i
 			DMI_MATCH(DMI_PRODUCT_VERSION, "00"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 /*
@@ -201,7 +201,7 @@ static struct dmi_system_id __initdata i
 			DMI_MATCH(DMI_PRODUCT_NAME, "M636/A737 platform"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/input/serio/libps2.c linux-2.6.20.1-pax/drivers/input/serio/libps2.c
--- linux-2.6.20.1/drivers/input/serio/libps2.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/input/serio/libps2.c	2007-02-16 00:15:40.000000000 +0100
@@ -97,7 +97,7 @@ EXPORT_SYMBOL(ps2_drain);
 
 int ps2_is_keyboard_id(char id_byte)
 {
-	const static char keyboard_ids[] = {
+	static const char keyboard_ids[] = {
 		0xab,	/* Regular keyboards		*/
 		0xac,	/* NCD Sun keyboard		*/
 		0x2b,	/* Trust keyboard, translated	*/
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/input/serio/serio_raw.c linux-2.6.20.1-pax/drivers/input/serio/serio_raw.c
--- linux-2.6.20.1/drivers/input/serio/serio_raw.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/input/serio/serio_raw.c	2007-02-16 00:15:14.000000000 +0100
@@ -369,7 +369,7 @@ static struct serio_device_id serio_raw_
 		.id	= SERIO_ANY,
 		.extra	= SERIO_ANY,
 	},
-	{ 0 }
+	{ 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(serio, serio_raw_serio_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/kvm/kvm_main.c linux-2.6.20.1-pax/drivers/kvm/kvm_main.c
--- linux-2.6.20.1/drivers/kvm/kvm_main.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/kvm/kvm_main.c	2007-02-16 00:14:50.000000000 +0100
@@ -50,19 +50,19 @@ static struct kvm_stats_debugfs_item {
 	u32 *data;
 	struct dentry *dentry;
 } debugfs_entries[] = {
-	{ "pf_fixed", &kvm_stat.pf_fixed },
-	{ "pf_guest", &kvm_stat.pf_guest },
-	{ "tlb_flush", &kvm_stat.tlb_flush },
-	{ "invlpg", &kvm_stat.invlpg },
-	{ "exits", &kvm_stat.exits },
-	{ "io_exits", &kvm_stat.io_exits },
-	{ "mmio_exits", &kvm_stat.mmio_exits },
-	{ "signal_exits", &kvm_stat.signal_exits },
-	{ "irq_window", &kvm_stat.irq_window_exits },
-	{ "halt_exits", &kvm_stat.halt_exits },
-	{ "request_irq", &kvm_stat.request_irq_exits },
-	{ "irq_exits", &kvm_stat.irq_exits },
-	{ 0, 0 }
+	{ "pf_fixed", &kvm_stat.pf_fixed, NULL },
+	{ "pf_guest", &kvm_stat.pf_guest, NULL },
+	{ "tlb_flush", &kvm_stat.tlb_flush, NULL },
+	{ "invlpg", &kvm_stat.invlpg, NULL },
+	{ "exits", &kvm_stat.exits, NULL },
+	{ "io_exits", &kvm_stat.io_exits, NULL },
+	{ "mmio_exits", &kvm_stat.mmio_exits, NULL },
+	{ "signal_exits", &kvm_stat.signal_exits, NULL },
+	{ "irq_window", &kvm_stat.irq_window_exits, NULL },
+	{ "halt_exits", &kvm_stat.halt_exits, NULL },
+	{ "request_irq", &kvm_stat.request_irq_exits, NULL },
+	{ "irq_exits", &kvm_stat.irq_exits, NULL },
+	{ 0, 0, NULL }
 };
 
 static struct dentry *debugfs_dir;
@@ -1741,7 +1741,7 @@ static int kvm_dev_ioctl_interrupt(struc
 
 	if (!valid_vcpu(irq->vcpu))
 		return -EINVAL;
-	if (irq->irq < 0 || irq->irq >= 256)
+	if (irq->irq >= 256)
 		return -EINVAL;
 	vcpu = vcpu_load(kvm, irq->vcpu);
 	if (!vcpu)
@@ -2003,6 +2003,9 @@ static struct miscdevice kvm_dev = {
 	MISC_DYNAMIC_MINOR,
 	"kvm",
 	&kvm_chardev_ops,
+	{NULL, NULL},
+	NULL,
+	NULL
 };
 
 static int kvm_reboot(struct notifier_block *notifier, unsigned long val,
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/kvm/vmx.c linux-2.6.20.1-pax/drivers/kvm/vmx.c
--- linux-2.6.20.1/drivers/kvm/vmx.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/kvm/vmx.c	2007-02-05 00:56:20.000000000 +0100
@@ -1860,7 +1860,7 @@ again:
 	vcpu->interrupt_window_open = (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & 3) == 0;
 
 #ifndef CONFIG_X86_64
-	asm ("mov %0, %%ds; mov %0, %%es" : : "r"(__USER_DS));
+	asm ("mov %0, %%ds; mov %0, %%es" : : "r"(__KERNEL_DS));
 #endif
 
 	/*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/md/bitmap.c linux-2.6.20.1-pax/drivers/md/bitmap.c
--- linux-2.6.20.1/drivers/md/bitmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/md/bitmap.c	2007-02-05 00:56:20.000000000 +0100
@@ -57,7 +57,7 @@
 #  if DEBUG > 0
 #    define PRINTK(x...) printk(KERN_DEBUG x)
 #  else
-#    define PRINTK(x...)
+#    define PRINTK(x...) do {} while (0)
 #  endif
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/net/eepro100.c linux-2.6.20.1-pax/drivers/net/eepro100.c
--- linux-2.6.20.1/drivers/net/eepro100.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/net/eepro100.c	2007-02-16 00:10:48.000000000 +0100
@@ -47,7 +47,7 @@ static int rxdmacount /* = 0 */;
 # define rx_align(skb)		skb_reserve((skb), 2)
 # define RxFD_ALIGNMENT		__attribute__ ((aligned (2), packed))
 #else
-# define rx_align(skb)
+# define rx_align(skb) do {} while (0)
 # define RxFD_ALIGNMENT
 #endif
 
@@ -2339,33 +2339,33 @@ static void __devexit eepro100_remove_on
 }
 
 static struct pci_device_id eepro100_pci_tbl[] = {
-	{ PCI_VENDOR_ID_INTEL, 0x1229, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1209, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1029, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1030, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1031, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1032, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1033, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1034, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1035, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1036, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1037, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1038, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1039, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103A, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103B, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103C, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103D, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103E, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1050, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1059, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1227, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x2449, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x2459, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x245D, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x5200, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x5201, PCI_ANY_ID, PCI_ANY_ID, },
-	{ 0,}
+	{ PCI_VENDOR_ID_INTEL, 0x1229, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1209, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1029, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1030, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1031, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1032, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1033, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1034, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1035, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1036, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1037, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1038, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1039, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1059, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1227, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x2449, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x2459, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x245D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x5200, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x5201, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(pci, eepro100_pci_tbl);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/net/pcnet32.c linux-2.6.20.1-pax/drivers/net/pcnet32.c
--- linux-2.6.20.1/drivers/net/pcnet32.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/net/pcnet32.c	2007-02-05 00:56:20.000000000 +0100
@@ -82,7 +82,7 @@ static int cards_found;
 /*
  * VLB I/O addresses
  */
-static unsigned int pcnet32_portlist[] __initdata =
+static unsigned int pcnet32_portlist[] __devinitdata =
     { 0x300, 0x320, 0x340, 0x360, 0 };
 
 static int pcnet32_debug = 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/pci/pcie/aer/aerdrv.c linux-2.6.20.1-pax/drivers/pci/pcie/aer/aerdrv.c
--- linux-2.6.20.1/drivers/pci/pcie/aer/aerdrv.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/pci/pcie/aer/aerdrv.c	2007-02-16 00:08:25.000000000 +0100
@@ -58,7 +58,7 @@ static struct pcie_port_service_id aer_i
 	.port_type 	= PCIE_RC_PORT,
 	.service_type 	= PCIE_PORT_SERVICE_AER,
 	},
-	{ /* end: all zeroes */ }
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 static struct pci_error_handlers aer_error_handlers = {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/pci/pcie/aer/aerdrv_core.c linux-2.6.20.1-pax/drivers/pci/pcie/aer/aerdrv_core.c
--- linux-2.6.20.1/drivers/pci/pcie/aer/aerdrv_core.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/pci/pcie/aer/aerdrv_core.c	2007-02-16 00:09:19.000000000 +0100
@@ -647,7 +647,7 @@ static void aer_isr_one_error(struct pci
 		struct aer_err_source *e_src)
 {
 	struct device *s_device;
-	struct aer_err_info e_info = {0, 0, 0,};
+	struct aer_err_info e_info = {0, 0, 0, {0, 0, 0, 0}};
 	int i;
 	u16 id;
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/pci/pcie/portdrv_pci.c linux-2.6.20.1-pax/drivers/pci/pcie/portdrv_pci.c
--- linux-2.6.20.1/drivers/pci/pcie/portdrv_pci.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/pci/pcie/portdrv_pci.c	2007-02-16 00:09:42.000000000 +0100
@@ -265,7 +265,7 @@ static void pcie_portdrv_err_resume(stru
 static const struct pci_device_id port_pci_ids[] = { {
 	/* handle any PCI-Express port */
 	PCI_DEVICE_CLASS(((PCI_CLASS_BRIDGE_PCI << 8) | 0x00), ~0),
-	}, { /* end: all zeroes */ }
+	}, { 0, 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(pci, port_pci_ids);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/pcmcia/ti113x.h linux-2.6.20.1-pax/drivers/pcmcia/ti113x.h
--- linux-2.6.20.1/drivers/pcmcia/ti113x.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/pcmcia/ti113x.h	2007-02-16 00:07:48.000000000 +0100
@@ -897,7 +897,7 @@ static struct pci_device_id ene_tune_tbl
 	DEVID(PCI_VENDOR_ID_MOTOROLA, 0x3410, 0xECC0, PCI_ANY_ID,
 		ENE_TEST_C9_TLTENABLE | ENE_TEST_C9_PFENABLE, ENE_TEST_C9_TLTENABLE),
 
-	{}
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 static void ene_tune_bridge(struct pcmcia_socket *sock, struct pci_bus *bus)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/pcmcia/yenta_socket.c linux-2.6.20.1-pax/drivers/pcmcia/yenta_socket.c
--- linux-2.6.20.1/drivers/pcmcia/yenta_socket.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/pcmcia/yenta_socket.c	2007-02-16 00:07:11.000000000 +0100
@@ -1359,7 +1359,7 @@ static struct pci_device_id yenta_table 
 
 	/* match any cardbus bridge */
 	CB_ID(PCI_ANY_ID, PCI_ANY_ID, DEFAULT),
-	{ /* all zeroes */ }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(pci, yenta_table);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/pnp/pnpbios/bioscalls.c linux-2.6.20.1-pax/drivers/pnp/pnpbios/bioscalls.c
--- linux-2.6.20.1/drivers/pnp/pnpbios/bioscalls.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/pnp/pnpbios/bioscalls.c	2007-02-05 00:56:20.000000000 +0100
@@ -65,7 +65,7 @@ set_base(gdt[(selname) >> 3], (u32)(addr
 set_limit(gdt[(selname) >> 3], size); \
 } while(0)
 
-static struct desc_struct bad_bios_desc = { 0, 0x00409200 };
+static struct desc_struct bad_bios_desc = { 0, 0x00409300 };
 
 /*
  * At some point we want to use this stack frame pointer to unwind
@@ -93,6 +93,10 @@ static inline u16 call_pnp_bios(u16 func
 	struct desc_struct save_desc_40;
 	int cpu;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	/*
 	 * PnP BIOSes are generally not terribly re-entrant.
 	 * Also, don't rely on them to save everything correctly.
@@ -107,6 +111,10 @@ static inline u16 call_pnp_bios(u16 func
 	/* On some boxes IRQ's during PnP BIOS calls are deadly.  */
 	spin_lock_irqsave(&pnp_bios_lock, flags);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	/* The lock prevents us bouncing CPU here */
 	if (ts1_size)
 		Q2_SET_SEL(smp_processor_id(), PNP_TS1, ts1_base, ts1_size);
@@ -142,9 +150,14 @@ static inline u16 call_pnp_bios(u16 func
 		  "i" (0)
 		: "memory"
 	);
-	spin_unlock_irqrestore(&pnp_bios_lock, flags);
 
 	get_cpu_gdt_table(cpu)[0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+	spin_unlock_irqrestore(&pnp_bios_lock, flags);
 	put_cpu();
 
 	/* If we get here and this is set then the PnP BIOS faulted on us. */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/pnp/quirks.c linux-2.6.20.1-pax/drivers/pnp/quirks.c
--- linux-2.6.20.1/drivers/pnp/quirks.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/pnp/quirks.c	2007-02-16 00:05:16.000000000 +0100
@@ -126,7 +126,7 @@ static struct pnp_fixup pnp_fixups[] = {
 	{ "CTL0043", quirk_sb16audio_resources },
 	{ "CTL0044", quirk_sb16audio_resources },
 	{ "CTL0045", quirk_sb16audio_resources },
-	{ "" }
+	{ "", NULL }
 };
 
 void pnp_fixup_device(struct pnp_dev *dev)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/pnp/resource.c linux-2.6.20.1-pax/drivers/pnp/resource.c
--- linux-2.6.20.1/drivers/pnp/resource.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/pnp/resource.c	2007-02-05 00:56:21.000000000 +0100
@@ -364,7 +364,7 @@ int pnp_check_irq(struct pnp_dev * dev, 
 		return 1;
 
 	/* check if the resource is valid */
-	if (*irq < 0 || *irq > 15)
+	if (*irq > 15)
 		return 0;
 
 	/* check if the resource is reserved */
@@ -430,7 +430,7 @@ int pnp_check_dma(struct pnp_dev * dev, 
 		return 1;
 
 	/* check if the resource is valid */
-	if (*dma < 0 || *dma == 4 || *dma > 7)
+	if (*dma == 4 || *dma > 7)
 		return 0;
 
 	/* check if the resource is reserved */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/scsi/scsi_lib.c linux-2.6.20.1-pax/drivers/scsi/scsi_lib.c
--- linux-2.6.20.1/drivers/scsi/scsi_lib.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/scsi/scsi_lib.c	2007-02-16 00:04:44.000000000 +0100
@@ -44,7 +44,7 @@ struct scsi_host_sg_pool {
 #error SCSI_MAX_PHYS_SEGMENTS is too small
 #endif
 
-#define SP(x) { x, "sgpool-" #x } 
+#define SP(x) { x, "sgpool-" #x, NULL, NULL }
 static struct scsi_host_sg_pool scsi_sg_pools[] = {
 	SP(8),
 	SP(16),
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/scsi/scsi_logging.h linux-2.6.20.1-pax/drivers/scsi/scsi_logging.h
--- linux-2.6.20.1/drivers/scsi/scsi_logging.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/scsi/scsi_logging.h	2007-02-05 00:56:21.000000000 +0100
@@ -51,7 +51,7 @@ do {								\
 		} while (0);					\
 } while (0)
 #else
-#define SCSI_CHECK_LOGGING(SHIFT, BITS, LEVEL, CMD)
+#define SCSI_CHECK_LOGGING(SHIFT, BITS, LEVEL, CMD) do {} while (0)
 #endif /* CONFIG_SCSI_LOGGING */
 
 /*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/serial/8250_pci.c linux-2.6.20.1-pax/drivers/serial/8250_pci.c
--- linux-2.6.20.1/drivers/serial/8250_pci.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/serial/8250_pci.c	2007-02-15 23:58:09.000000000 +0100
@@ -2394,7 +2394,7 @@ static struct pci_device_id serial_pci_t
 		PCI_ANY_ID, PCI_ANY_ID,
 		PCI_CLASS_COMMUNICATION_MULTISERIAL << 8,
 		0xffff00, pbn_default },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 static struct pci_driver serial_pci_driver = {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/usb/class/cdc-acm.c linux-2.6.20.1-pax/drivers/usb/class/cdc-acm.c
--- linux-2.6.20.1/drivers/usb/class/cdc-acm.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/usb/class/cdc-acm.c	2007-02-15 23:57:45.000000000 +0100
@@ -1107,7 +1107,7 @@ static struct usb_device_id acm_ids[] = 
 		USB_CDC_ACM_PROTO_AT_CDMA) },
 
 	/* NOTE:  COMM/ACM/0xff is likely MSFT RNDIS ... NOT a modem!! */
-	{ }
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (usb, acm_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/usb/class/usblp.c linux-2.6.20.1-pax/drivers/usb/class/usblp.c
--- linux-2.6.20.1/drivers/usb/class/usblp.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/usb/class/usblp.c	2007-02-15 23:57:11.000000000 +0100
@@ -218,7 +218,7 @@ static const struct quirk_printer_struct
 	{ 0x0409, 0xf0be, USBLP_QUIRK_BIDIR }, /* NEC Picty920 (HP OEM) */
 	{ 0x0409, 0xf1be, USBLP_QUIRK_BIDIR }, /* NEC Picty800 (HP OEM) */
 	{ 0x0482, 0x0010, USBLP_QUIRK_BIDIR }, /* Kyocera Mita FS 820, by zut <kernel@zut.de> */
-	{ 0, 0 }
+	{ 0, 0, 0 }
 };
 
 static int usblp_select_alts(struct usblp *usblp);
@@ -1239,7 +1239,7 @@ static struct usb_device_id usblp_ids []
 	{ USB_INTERFACE_INFO(7, 1, 1) },
 	{ USB_INTERFACE_INFO(7, 1, 2) },
 	{ USB_INTERFACE_INFO(7, 1, 3) },
-	{ }						/* Terminating entry */
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }			/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE (usb, usblp_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/usb/core/hub.c linux-2.6.20.1-pax/drivers/usb/core/hub.c
--- linux-2.6.20.1/drivers/usb/core/hub.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/usb/core/hub.c	2007-02-15 23:55:39.000000000 +0100
@@ -2855,7 +2855,7 @@ static struct usb_device_id hub_id_table
       .bDeviceClass = USB_CLASS_HUB},
     { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,
       .bInterfaceClass = USB_CLASS_HUB},
-    { }						/* Terminating entry */
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }						/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE (usb, hub_id_table);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/usb/host/ehci-pci.c linux-2.6.20.1-pax/drivers/usb/host/ehci-pci.c
--- linux-2.6.20.1/drivers/usb/host/ehci-pci.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/usb/host/ehci-pci.c	2007-02-15 23:51:44.000000000 +0100
@@ -361,7 +361,7 @@ static const struct pci_device_id pci_id
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
 	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
 	},
-	{ /* end: all zeroes */ }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(pci, pci_ids);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/usb/host/uhci-hcd.c linux-2.6.20.1-pax/drivers/usb/host/uhci-hcd.c
--- linux-2.6.20.1/drivers/usb/host/uhci-hcd.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/usb/host/uhci-hcd.c	2007-02-15 23:51:17.000000000 +0100
@@ -902,7 +902,7 @@ static const struct pci_device_id uhci_p
 	/* handle any USB UHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_UHCI, ~0),
 	.driver_data =	(unsigned long) &uhci_driver,
-	}, { /* end: all zeroes */ }
+	}, { 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, uhci_pci_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/usb/storage/debug.h linux-2.6.20.1-pax/drivers/usb/storage/debug.h
--- linux-2.6.20.1/drivers/usb/storage/debug.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/usb/storage/debug.h	2007-02-05 00:56:21.000000000 +0100
@@ -56,9 +56,9 @@ void usb_stor_show_sense( unsigned char 
 #define US_DEBUGPX(x...) printk( x )
 #define US_DEBUG(x) x 
 #else
-#define US_DEBUGP(x...)
-#define US_DEBUGPX(x...)
-#define US_DEBUG(x)
+#define US_DEBUGP(x...) do {} while (0)
+#define US_DEBUGPX(x...) do {} while (0)
+#define US_DEBUG(x) do {} while (0)
 #endif
 
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/usb/storage/usb.c linux-2.6.20.1-pax/drivers/usb/storage/usb.c
--- linux-2.6.20.1/drivers/usb/storage/usb.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/usb/storage/usb.c	2007-02-15 23:50:18.000000000 +0100
@@ -141,7 +141,7 @@ static struct usb_device_id storage_usb_
 #undef UNUSUAL_DEV
 #undef USUAL_DEV
 	/* Terminating entry */
-	{ }
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (usb, storage_usb_ids);
@@ -181,7 +181,7 @@ static struct us_unusual_dev us_unusual_
 #	undef USUAL_DEV
 
 	/* Terminating entry */
-	{ NULL }
+	{ NULL, NULL, 0, 0, NULL }
 };
 
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/video/fbcmap.c linux-2.6.20.1-pax/drivers/video/fbcmap.c
--- linux-2.6.20.1/drivers/video/fbcmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/video/fbcmap.c	2007-02-05 00:56:21.000000000 +0100
@@ -251,8 +251,7 @@ int fb_set_user_cmap(struct fb_cmap_user
 	int rc, size = cmap->len * sizeof(u16);
 	struct fb_cmap umap;
 
-	if (cmap->start < 0 || (!info->fbops->fb_setcolreg &&
-			        !info->fbops->fb_setcmap))
+	if (!info->fbops->fb_setcolreg && !info->fbops->fb_setcmap)
 		return -EINVAL;
 
 	memset(&umap, 0, sizeof(struct fb_cmap));
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/video/fbmem.c linux-2.6.20.1-pax/drivers/video/fbmem.c
--- linux-2.6.20.1/drivers/video/fbmem.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/video/fbmem.c	2007-02-05 00:56:21.000000000 +0100
@@ -936,9 +936,9 @@ fb_ioctl(struct inode *inode, struct fil
 	case FBIOPUT_CON2FBMAP:
 		if (copy_from_user(&con2fb, argp, sizeof(con2fb)))
 			return - EFAULT;
-		if (con2fb.console < 0 || con2fb.console > MAX_NR_CONSOLES)
+		if (con2fb.console > MAX_NR_CONSOLES)
 		    return -EINVAL;
-		if (con2fb.framebuffer < 0 || con2fb.framebuffer >= FB_MAX)
+		if (con2fb.framebuffer >= FB_MAX)
 		    return -EINVAL;
 #ifdef CONFIG_KMOD
 		if (!registered_fb[con2fb.framebuffer])
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/video/fbmon.c linux-2.6.20.1-pax/drivers/video/fbmon.c
--- linux-2.6.20.1/drivers/video/fbmon.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/video/fbmon.c	2007-02-05 00:56:21.000000000 +0100
@@ -45,7 +45,7 @@
 #ifdef DEBUG
 #define DPRINTK(fmt, args...) printk(fmt,## args)
 #else
-#define DPRINTK(fmt, args...)
+#define DPRINTK(fmt, args...) do {} while (0)
 #endif
 
 #define FBMON_FIX_HEADER 1
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/video/i810/i810_accel.c linux-2.6.20.1-pax/drivers/video/i810/i810_accel.c
--- linux-2.6.20.1/drivers/video/i810/i810_accel.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/video/i810/i810_accel.c	2007-02-05 00:56:21.000000000 +0100
@@ -73,6 +73,7 @@ static inline int wait_for_space(struct 
 		}
 	}
 	printk("ringbuffer lockup!!!\n");
+	printk("head:%u tail:%u iring.size:%u space:%u\n", head, tail, par->iring.size, space);
 	i810_report_error(mmio); 
 	par->dev_flags |= LOCKUP;
 	info->pixmap.scan_align = 1;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/video/i810/i810_main.c linux-2.6.20.1-pax/drivers/video/i810/i810_main.c
--- linux-2.6.20.1/drivers/video/i810/i810_main.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/video/i810/i810_main.c	2007-02-15 23:44:13.000000000 +0100
@@ -120,7 +120,7 @@ static struct pci_device_id i810fb_pci_t
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4 },
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_CGC,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5 },
-	{ 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 static struct pci_driver i810fb_driver = {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/video/modedb.c linux-2.6.20.1-pax/drivers/video/modedb.c
--- linux-2.6.20.1/drivers/video/modedb.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/video/modedb.c	2007-02-15 23:48:29.000000000 +0100
@@ -38,228 +38,228 @@ static const struct fb_videomode modedb[
     {
 	/* 640x400 @ 70 Hz, 31.5 kHz hsync */
 	NULL, 70, 640, 400, 39721, 40, 24, 39, 9, 96, 2,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 60 Hz, 31.5 kHz hsync */
 	NULL, 60, 640, 480, 39721, 40, 24, 32, 11, 96, 2,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 56 Hz, 35.15 kHz hsync */
 	NULL, 56, 800, 600, 27777, 128, 24, 22, 1, 72, 2,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 87 Hz interlaced, 35.5 kHz hsync */
 	NULL, 87, 1024, 768, 22271, 56, 24, 33, 8, 160, 8,
-	0, FB_VMODE_INTERLACED
+	0, FB_VMODE_INTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x400 @ 85 Hz, 37.86 kHz hsync */
 	NULL, 85, 640, 400, 31746, 96, 32, 41, 1, 64, 3,
-	FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 72 Hz, 36.5 kHz hsync */
 	NULL, 72, 640, 480, 31746, 144, 40, 30, 8, 40, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 75 Hz, 37.50 kHz hsync */
 	NULL, 75, 640, 480, 31746, 120, 16, 16, 1, 64, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 60 Hz, 37.8 kHz hsync */
 	NULL, 60, 800, 600, 25000, 88, 40, 23, 1, 128, 4,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 85 Hz, 43.27 kHz hsync */
 	NULL, 85, 640, 480, 27777, 80, 56, 25, 1, 56, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 89 Hz interlaced, 44 kHz hsync */
 	NULL, 69, 1152, 864, 15384, 96, 16, 110, 1, 216, 10,
-	0, FB_VMODE_INTERLACED
+	0, FB_VMODE_INTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 72 Hz, 48.0 kHz hsync */
 	NULL, 72, 800, 600, 20000, 64, 56, 23, 37, 120, 6,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 60 Hz, 48.4 kHz hsync */
 	NULL, 60, 1024, 768, 15384, 168, 8, 29, 3, 144, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 100 Hz, 53.01 kHz hsync */
 	NULL, 100, 640, 480, 21834, 96, 32, 36, 8, 96, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 60 Hz, 53.5 kHz hsync */
 	NULL, 60, 1152, 864, 11123, 208, 64, 16, 4, 256, 8,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 85 Hz, 55.84 kHz hsync */
 	NULL, 85, 800, 600, 16460, 160, 64, 36, 16, 64, 5,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 70 Hz, 56.5 kHz hsync */
 	NULL, 70, 1024, 768, 13333, 144, 24, 29, 3, 136, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 87 Hz interlaced, 51 kHz hsync */
 	NULL, 87, 1280, 1024, 12500, 56, 16, 128, 1, 216, 12,
-	0, FB_VMODE_INTERLACED
+	0, FB_VMODE_INTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 100 Hz, 64.02 kHz hsync */
 	NULL, 100, 800, 600, 14357, 160, 64, 30, 4, 64, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 76 Hz, 62.5 kHz hsync */
 	NULL, 76, 1024, 768, 11764, 208, 8, 36, 16, 120, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 70 Hz, 62.4 kHz hsync */
 	NULL, 70, 1152, 864, 10869, 106, 56, 20, 1, 160, 10,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 61 Hz, 64.2 kHz hsync */
 	NULL, 61, 1280, 1024, 9090, 200, 48, 26, 1, 184, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1400x1050 @ 60Hz, 63.9 kHz hsync */
 	NULL, 68, 1400, 1050, 9259, 136, 40, 13, 1, 112, 3,
-	0, FB_VMODE_NONINTERLACED   	
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1400x1050 @ 75,107 Hz, 82,392 kHz +hsync +vsync*/
 	NULL, 75, 1400, 1050, 9271, 120, 56, 13, 0, 112, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1400x1050 @ 60 Hz, ? kHz +hsync +vsync*/
         NULL, 60, 1400, 1050, 9259, 128, 40, 12, 0, 112, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 85 Hz, 70.24 kHz hsync */
 	NULL, 85, 1024, 768, 10111, 192, 32, 34, 14, 160, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 78 Hz, 70.8 kHz hsync */
 	NULL, 78, 1152, 864, 9090, 228, 88, 32, 0, 84, 12,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 70 Hz, 74.59 kHz hsync */
 	NULL, 70, 1280, 1024, 7905, 224, 32, 28, 8, 160, 8,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1600x1200 @ 60Hz, 75.00 kHz hsync */
 	NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 84 Hz, 76.0 kHz hsync */
 	NULL, 84, 1152, 864, 7407, 184, 312, 32, 0, 128, 12,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 74 Hz, 78.85 kHz hsync */
 	NULL, 74, 1280, 1024, 7407, 256, 32, 34, 3, 144, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 100Hz, 80.21 kHz hsync */
 	NULL, 100, 1024, 768, 8658, 192, 32, 21, 3, 192, 10,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 76 Hz, 81.13 kHz hsync */
 	NULL, 76, 1280, 1024, 7407, 248, 32, 34, 3, 104, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1600x1200 @ 70 Hz, 87.50 kHz hsync */
 	NULL, 70, 1600, 1200, 5291, 304, 64, 46, 1, 192, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 100 Hz, 89.62 kHz hsync */
 	NULL, 100, 1152, 864, 7264, 224, 32, 17, 2, 128, 19,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 85 Hz, 91.15 kHz hsync */
 	NULL, 85, 1280, 1024, 6349, 224, 64, 44, 1, 160, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1600x1200 @ 75 Hz, 93.75 kHz hsync */
 	NULL, 75, 1600, 1200, 4938, 304, 64, 46, 1, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1680x1050 @ 60 Hz, 65.191 kHz hsync */
 	NULL, 60, 1680, 1050, 6848, 280, 104, 30, 3, 176, 6,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1600x1200 @ 85 Hz, 105.77 kHz hsync */
 	NULL, 85, 1600, 1200, 4545, 272, 16, 37, 4, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 100 Hz, 107.16 kHz hsync */
 	NULL, 100, 1280, 1024, 5502, 256, 32, 26, 7, 128, 15,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1800x1440 @ 64Hz, 96.15 kHz hsync  */
 	NULL, 64, 1800, 1440, 4347, 304, 96, 46, 1, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1800x1440 @ 70Hz, 104.52 kHz hsync  */
 	NULL, 70, 1800, 1440, 4000, 304, 96, 46, 1, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 512x384 @ 78 Hz, 31.50 kHz hsync */
 	NULL, 78, 512, 384, 49603, 48, 16, 16, 1, 64, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 512x384 @ 85 Hz, 34.38 kHz hsync */
 	NULL, 85, 512, 384, 45454, 48, 16, 16, 1, 64, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 320x200 @ 70 Hz, 31.5 kHz hsync, 8:5 aspect ratio */
 	NULL, 70, 320, 200, 79440, 16, 16, 20, 4, 48, 1,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 320x240 @ 60 Hz, 31.5 kHz hsync, 4:3 aspect ratio */
 	NULL, 60, 320, 240, 79440, 16, 16, 16, 5, 48, 1,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 320x240 @ 72 Hz, 36.5 kHz hsync */
 	NULL, 72, 320, 240, 63492, 16, 16, 16, 4, 48, 2,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 400x300 @ 56 Hz, 35.2 kHz hsync, 4:3 aspect ratio */
 	NULL, 56, 400, 300, 55555, 64, 16, 10, 1, 32, 1,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 400x300 @ 60 Hz, 37.8 kHz hsync */
 	NULL, 60, 400, 300, 50000, 48, 16, 11, 1, 64, 2,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 400x300 @ 72 Hz, 48.0 kHz hsync */
 	NULL, 72, 400, 300, 40000, 32, 24, 11, 19, 64, 3,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 480x300 @ 56 Hz, 35.2 kHz hsync, 8:5 aspect ratio */
 	NULL, 56, 480, 300, 46176, 80, 16, 10, 1, 40, 1,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 480x300 @ 60 Hz, 37.8 kHz hsync */
 	NULL, 60, 480, 300, 41858, 56, 16, 11, 1, 80, 2,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 480x300 @ 63 Hz, 39.6 kHz hsync */
 	NULL, 63, 480, 300, 40000, 56, 16, 11, 1, 80, 2,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 480x300 @ 72 Hz, 48.0 kHz hsync */
 	NULL, 72, 480, 300, 33386, 40, 24, 11, 19, 80, 3,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1920x1200 @ 60 Hz, 74.5 Khz hsync */
 	NULL, 60, 1920, 1200, 5177, 128, 336, 1, 38, 208, 3,
 	FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	FB_VMODE_NONINTERLACED
+	FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x768, 60 Hz, PowerBook G4 Titanium I and II */
 	NULL, 60, 1152, 768, 15386, 158, 26, 29, 3, 136, 6,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1366x768, 60 Hz, 47.403 kHz hsync, WXGA 16:9 aspect ratio */
 	NULL, 60, 1366, 768, 13806, 120, 10, 14, 3, 32, 5,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     },
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/drivers/video/vesafb.c linux-2.6.20.1-pax/drivers/video/vesafb.c
--- linux-2.6.20.1/drivers/video/vesafb.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/drivers/video/vesafb.c	2007-02-05 00:56:21.000000000 +0100
@@ -266,7 +266,7 @@ static int __init vesafb_probe(struct pl
 		size_remap = size_total;
 	vesafb_fix.smem_len = size_remap;
 
-#ifndef __i386__
+#if !defined(__i386__) || defined(CONFIG_PAX_KERNEXEC)
 	screen_info.vesapm_seg = 0;
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/binfmt_aout.c linux-2.6.20.1-pax/fs/binfmt_aout.c
--- linux-2.6.20.1/fs/binfmt_aout.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/binfmt_aout.c	2007-02-05 00:56:21.000000000 +0100
@@ -326,6 +326,28 @@ static int load_aout_binary(struct linux
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(N_FLAGS(ex) & F_PAX_PAGEEXEC)) {
+		current->mm->pax_flags |= MF_PAX_PAGEEXEC;
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		if (N_FLAGS(ex) & F_PAX_EMUTRAMP)
+			current->mm->pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (!(N_FLAGS(ex) & F_PAX_MPROTECT))
+			current->mm->pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+	}
+#endif
+
 #ifdef __sparc__
 	if (N_MAGIC(ex) == NMAGIC) {
 		loff_t pos = fd_offset;
@@ -421,7 +443,7 @@ static int load_aout_binary(struct linux
 
 		down_write(&current->mm->mmap_sem);
  		error = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,
-				PROT_READ | PROT_WRITE | PROT_EXEC,
+				PROT_READ | PROT_WRITE,
 				MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
 				fd_offset + ex.a_text);
 		up_write(&current->mm->mmap_sem);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/binfmt_elf.c linux-2.6.20.1-pax/fs/binfmt_elf.c
--- linux-2.6.20.1/fs/binfmt_elf.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/binfmt_elf.c	2007-02-14 23:14:48.000000000 +0100
@@ -43,6 +43,10 @@
 #include <asm/param.h>
 #include <asm/page.h>
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#include <asm/desc.h>
+#endif
+
 static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs);
 static int load_elf_library(struct file *);
 static unsigned long elf_map (struct file *, unsigned long, struct elf_phdr *, int, int);
@@ -83,6 +87,8 @@ static struct linux_binfmt elf_format = 
 
 static int set_brk(unsigned long start, unsigned long end)
 {
+	unsigned long e = end;
+
 	start = ELF_PAGEALIGN(start);
 	end = ELF_PAGEALIGN(end);
 	if (end > start) {
@@ -93,7 +99,7 @@ static int set_brk(unsigned long start, 
 		if (BAD_ADDR(addr))
 			return addr;
 	}
-	current->mm->start_brk = current->mm->brk = end;
+	current->mm->start_brk = current->mm->brk = e;
 	return 0;
 }
 
@@ -314,10 +320,9 @@ static unsigned long load_elf_interp(str
 {
 	struct elf_phdr *elf_phdata;
 	struct elf_phdr *eppnt;
-	unsigned long load_addr = 0;
-	int load_addr_set = 0;
+	unsigned long load_addr = 0, min_addr, max_addr, task_size = TASK_SIZE;
 	unsigned long last_bss = 0, elf_bss = 0;
-	unsigned long error = ~0UL;
+	unsigned long error = -EINVAL;
 	int retval, i, size;
 
 	/* First of all, some simple consistency checks */
@@ -356,66 +361,86 @@ static unsigned long load_elf_interp(str
 		goto out_close;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
 	eppnt = elf_phdata;
+	min_addr = task_size;
+	max_addr = 0;
+	error = -ENOMEM;
+
 	for (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {
-		if (eppnt->p_type == PT_LOAD) {
-			int elf_type = MAP_PRIVATE | MAP_DENYWRITE;
-			int elf_prot = 0;
-			unsigned long vaddr = 0;
-			unsigned long k, map_addr;
-
-			if (eppnt->p_flags & PF_R)
-		    		elf_prot = PROT_READ;
-			if (eppnt->p_flags & PF_W)
-				elf_prot |= PROT_WRITE;
-			if (eppnt->p_flags & PF_X)
-				elf_prot |= PROT_EXEC;
-			vaddr = eppnt->p_vaddr;
-			if (interp_elf_ex->e_type == ET_EXEC || load_addr_set)
-				elf_type |= MAP_FIXED;
-
-			map_addr = elf_map(interpreter, load_addr + vaddr,
-					   eppnt, elf_prot, elf_type);
-			error = map_addr;
-			if (BAD_ADDR(map_addr))
-				goto out_close;
-
-			if (!load_addr_set &&
-			    interp_elf_ex->e_type == ET_DYN) {
-				load_addr = map_addr - ELF_PAGESTART(vaddr);
-				load_addr_set = 1;
-			}
+		if (eppnt->p_type != PT_LOAD)
+			continue;
 
-			/*
-			 * Check to see if the section's size will overflow the
-			 * allowed task size. Note that p_filesz must always be
-			 * <= p_memsize so it's only necessary to check p_memsz.
-			 */
-			k = load_addr + eppnt->p_vaddr;
-			if (BAD_ADDR(k) ||
-			    eppnt->p_filesz > eppnt->p_memsz ||
-			    eppnt->p_memsz > TASK_SIZE ||
-			    TASK_SIZE - eppnt->p_memsz < k) {
-				error = -ENOMEM;
-				goto out_close;
-			}
+		/*
+		 * Check to see if the section's size will overflow the
+		 * allowed task size. Note that p_filesz must always be
+		 * <= p_memsize so it is only necessary to check p_memsz.
+		 */
+		if (eppnt->p_filesz > eppnt->p_memsz || eppnt->p_vaddr >= eppnt->p_vaddr + eppnt->p_memsz)
+			goto out_close;
 
-			/*
-			 * Find the end of the file mapping for this phdr, and
-			 * keep track of the largest address we see for this.
-			 */
-			k = load_addr + eppnt->p_vaddr + eppnt->p_filesz;
-			if (k > elf_bss)
-				elf_bss = k;
+		if (min_addr > ELF_PAGESTART(eppnt->p_vaddr))
+			min_addr = ELF_PAGESTART(eppnt->p_vaddr);
+		if (max_addr < ELF_PAGEALIGN(eppnt->p_vaddr + eppnt->p_memsz))
+			max_addr = ELF_PAGEALIGN(eppnt->p_vaddr + eppnt->p_memsz);
+	}
+	if (min_addr >= max_addr || max_addr > task_size)
+		goto out_close;
 
-			/*
-			 * Do the same thing for the memory mapping - between
-			 * elf_bss and last_bss is the bss section.
-			 */
-			k = load_addr + eppnt->p_memsz + eppnt->p_vaddr;
-			if (k > last_bss)
-				last_bss = k;
-		}
+	if (interp_elf_ex->e_type == ET_DYN) {
+		load_addr = get_unmapped_area(interpreter, 0, max_addr - min_addr, 0, MAP_PRIVATE | MAP_EXECUTABLE);
+
+		if (load_addr >= task_size)
+			goto out_close;
+
+		load_addr -= min_addr;
+	}
+
+	eppnt = elf_phdata;
+	for (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {
+		int elf_type = MAP_PRIVATE | MAP_DENYWRITE | MAP_FIXED;
+		int elf_prot = 0;
+		unsigned long vaddr = 0;
+		unsigned long k, map_addr;
+
+		if (eppnt->p_type != PT_LOAD)
+			continue;
+
+		if (eppnt->p_flags & PF_R)
+	    		elf_prot = PROT_READ;
+		if (eppnt->p_flags & PF_W)
+			elf_prot |= PROT_WRITE;
+		if (eppnt->p_flags & PF_X)
+			elf_prot |= PROT_EXEC;
+		vaddr = eppnt->p_vaddr;
+
+		map_addr = elf_map(interpreter, load_addr + vaddr,
+				   eppnt, elf_prot, elf_type);
+		error = map_addr;
+		if (BAD_ADDR(map_addr))
+			goto out_close;
+
+		k = load_addr + eppnt->p_vaddr;
+
+		/*
+		 * Find the end of the file mapping for this phdr, and
+		 * keep track of the largest address we see for this.
+		 */
+		k = load_addr + eppnt->p_vaddr + eppnt->p_filesz;
+		if (k > elf_bss)
+			elf_bss = k;
+
+		/*
+		 * Do the same thing for the memory mapping - between
+		 * elf_bss and last_bss is the bss section.
+		 */
+		k = load_addr + eppnt->p_memsz + eppnt->p_vaddr;
+		if (k > last_bss)
+			last_bss = k;
 	}
 
 	/*
@@ -443,6 +468,8 @@ static unsigned long load_elf_interp(str
 
 	*interp_load_addr = load_addr;
 	error = ((unsigned long)interp_elf_ex->e_entry) + load_addr;
+	if (BAD_ADDR(error))
+		error = -EFAULT;
 
 out_close:
 	kfree(elf_phdata);
@@ -453,7 +480,7 @@ out:
 static unsigned long load_aout_interp(struct exec *interp_ex,
 		struct file *interpreter)
 {
-	unsigned long text_data, elf_entry = ~0UL;
+	unsigned long text_data, elf_entry = -EINVAL;
 	char __user * addr;
 	loff_t offset;
 
@@ -496,6 +523,180 @@ out:
 	return elf_entry;
 }
 
+#if (defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)) && defined(CONFIG_PAX_SOFTMODE)
+static unsigned long pax_parse_softmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (elf_phdata->p_flags & PF_PAGEEXEC)
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (elf_phdata->p_flags & PF_SEGMEXEC)
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_PAGEEXEC
+	if (pax_flags & MF_PAX_PAGEEXEC)
+		pax_flags &= ~MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_SEGMEXEC
+	if (pax_flags & MF_PAX_SEGMEXEC)
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (elf_phdata->p_flags & PF_EMUTRAMP)
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (elf_phdata->p_flags & PF_MPROTECT)
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+	if (randomize_va_space && (elf_phdata->p_flags & PF_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+static unsigned long pax_parse_hardmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_phdata->p_flags & PF_NOPAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_phdata->p_flags & PF_NOSEGMEXEC))
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_PAGEEXEC
+	if (pax_flags & MF_PAX_PAGEEXEC)
+		pax_flags &= ~MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_SEGMEXEC
+	if (pax_flags & MF_PAX_SEGMEXEC)
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (!(elf_phdata->p_flags & PF_NOEMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (!(elf_phdata->p_flags & PF_NOMPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+	if (randomize_va_space && !(elf_phdata->p_flags & PF_NORANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_EI_PAX
+static unsigned long pax_parse_ei_pax(const struct elfhdr * const elf_ex)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_PAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_SEGMEXEC))
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_PAGEEXEC
+	if (pax_flags & MF_PAX_PAGEEXEC)
+		pax_flags &= ~MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_SEGMEXEC
+	if (pax_flags & MF_PAX_SEGMEXEC)
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && (elf_ex->e_ident[EI_PAX] & EF_PAX_EMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && !(elf_ex->e_ident[EI_PAX] & EF_PAX_MPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	if (randomize_va_space && !(elf_ex->e_ident[EI_PAX] & EF_PAX_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)
+static long pax_parse_elf_flags(const struct elfhdr * const elf_ex, const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	unsigned long i;
+#endif
+
+#ifdef CONFIG_PAX_EI_PAX
+	pax_flags = pax_parse_ei_pax(elf_ex);
+#endif
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	for (i = 0UL; i < elf_ex->e_phnum; i++)
+		if (elf_phdata[i].p_type == PT_PAX_FLAGS) {
+			if (((elf_phdata[i].p_flags & PF_PAGEEXEC) && (elf_phdata[i].p_flags & PF_NOPAGEEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_SEGMEXEC) && (elf_phdata[i].p_flags & PF_NOSEGMEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_EMUTRAMP) && (elf_phdata[i].p_flags & PF_NOEMUTRAMP)) ||
+			    ((elf_phdata[i].p_flags & PF_MPROTECT) && (elf_phdata[i].p_flags & PF_NOMPROTECT)) ||
+			    ((elf_phdata[i].p_flags & PF_RANDMMAP) && (elf_phdata[i].p_flags & PF_NORANDMMAP)))
+				return -EINVAL;
+
+#ifdef CONFIG_PAX_SOFTMODE
+			if (pax_softmode)
+				pax_flags = pax_parse_softmode(&elf_phdata[i]);
+			else
+#endif
+
+				pax_flags = pax_parse_hardmode(&elf_phdata[i]);
+			break;
+		}
+#endif
+
+	if (0 > pax_check_flags(&pax_flags))
+		return -EINVAL;
+
+	current->mm->pax_flags = pax_flags;
+	return 0;
+}
+#endif
+
 /*
  * These are the functions used to load ELF style executables and shared
  * libraries.  There is no binary dependent code anywhere else.
@@ -533,7 +734,7 @@ static int load_elf_binary(struct linux_
 	char * elf_interpreter = NULL;
 	unsigned int interpreter_type = INTERPRETER_NONE;
 	unsigned char ibcs2_interpreter = 0;
-	unsigned long error;
+	unsigned long error = 0;
 	struct elf_phdr *elf_ppnt, *elf_phdata;
 	unsigned long elf_bss, elf_brk;
 	int elf_exec_fileno;
@@ -551,6 +752,7 @@ static int load_elf_binary(struct linux_
 		struct elfhdr interp_elf_ex;
   		struct exec interp_ex;
 	} *loc;
+	unsigned long task_size = TASK_SIZE;
 
 	loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 	if (!loc) {
@@ -781,14 +983,91 @@ static int load_elf_binary(struct linux_
 	current->mm->end_code = 0;
 	current->mm->mmap = NULL;
 	current->flags &= ~PF_FORKNOEXEC;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	current->mm->call_dl_resolve = 0UL;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	current->mm->call_syscall = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	current->mm->delta_mmap = 0UL;
+	current->mm->delta_exec = 0UL;
+	current->mm->delta_stack = 0UL;
+#endif
+
 	current->mm->def_flags = def_flags;
 
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)
+	if (0 > pax_parse_elf_flags(&loc->elf_ex, elf_phdata)) {
+		send_sig(SIGKILL, current, 0);
+		goto out_free_dentry;
+	}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+	pax_set_initial_flags(bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+	if (pax_set_initial_flags_func)
+		(pax_set_initial_flags_func)(bprm);
+#endif
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+	if (current->mm->pax_flags & MF_PAX_PAGEEXEC)
+		current->mm->context.user_cs_limit = PAGE_SIZE;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		current->mm->context.user_cs_base = SEGMEXEC_TASK_SIZE;
+		current->mm->context.user_cs_limit = -SEGMEXEC_TASK_SIZE;
+		task_size = SEGMEXEC_TASK_SIZE;
+	}
+#endif
+
+#if defined(CONFIG_ARCH_TRACK_EXEC_LIMIT) || defined(CONFIG_PAX_SEGMEXEC)
+	if (current->mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		set_user_cs(current->mm, get_cpu());
+		put_cpu_no_resched();
+	}
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+#define pax_delta_mask(delta, lsb, len) (((delta) & ((1UL << (len)) - 1)) << (lsb))
+
+		current->mm->delta_mmap = pax_delta_mask(pax_get_random_long(), PAX_DELTA_MMAP_LSB(current), PAX_DELTA_MMAP_LEN(current));
+		current->mm->delta_exec = pax_delta_mask(pax_get_random_long(), PAX_DELTA_EXEC_LSB(current), PAX_DELTA_EXEC_LEN(current));
+		current->mm->delta_stack = pax_delta_mask(pax_get_random_long(), PAX_DELTA_STACK_LSB(current), PAX_DELTA_STACK_LEN(current));
+	}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (current->mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+		executable_stack = EXSTACK_DEFAULT;
+#endif
+
 	/* Do this immediately, since STACK_TOP as used in setup_arg_pages
 	   may depend on the personality.  */
 	SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (!(current->mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)))
+#endif
+
 	if (elf_read_implies_exec(loc->elf_ex, executable_stack))
 		current->personality |= READ_IMPLIES_EXEC;
 
+#ifdef CONFIG_PAX_ASLR
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		current->flags |= PF_RANDOMIZE;
 	arch_pick_mmap_layout(current->mm);
@@ -864,6 +1143,15 @@ static int load_elf_binary(struct linux_
 			 * might try to exec.  This is because the brk will
 			 * follow the loader, and is not movable.  */
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
+
+#ifdef CONFIG_PAX_RANDMMAP
+			/* PaX: randomize base address at the default exe base if requested */
+			if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+				load_bias = ELF_PAGESTART(PAX_ELF_ET_DYN_BASE(current) - vaddr + current->mm->delta_exec);
+				elf_flags |= MAP_FIXED;
+			}
+#endif
+
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,
@@ -894,9 +1182,9 @@ static int load_elf_binary(struct linux_
 		 * allowed task size. Note that p_filesz must always be
 		 * <= p_memsz so it is only necessary to check p_memsz.
 		 */
-		if (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
-		    elf_ppnt->p_memsz > TASK_SIZE ||
-		    TASK_SIZE - elf_ppnt->p_memsz < k) {
+		if (k >= task_size || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
+		    elf_ppnt->p_memsz > task_size ||
+		    task_size - elf_ppnt->p_memsz < k) {
 			/* set_brk can never work. Avoid overflows. */
 			send_sig(SIGKILL, current, 0);
 			goto out_free_dentry;
@@ -923,6 +1211,12 @@ static int load_elf_binary(struct linux_
 	start_data += load_bias;
 	end_data += load_bias;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+		elf_brk += PAGE_SIZE + pax_delta_mask(pax_get_random_long(), 4, PAGE_SHIFT);
+#undef pax_delta_mask
+#endif
+
 	/* Calling set_brk effectively mmaps the pages that we need
 	 * for the bss and break sections.  We must do this before
 	 * mapping in the interpreter, to make sure it doesn't wind
@@ -1185,7 +1479,7 @@ static int dump_seek(struct file *file, 
  *
  * I think we should skip something. But I am not sure how. H.J.
  */
-static int maydump(struct vm_area_struct *vma)
+static int maydump(struct vm_area_struct *vma, long signr)
 {
 	/* The vma can be set up to tell us the answer directly.  */
 	if (vma->vm_flags & VM_ALWAYSDUMP)
@@ -1200,7 +1494,7 @@ static int maydump(struct vm_area_struct
 		return vma->vm_file->f_path.dentry->d_inode->i_nlink == 0;
 
 	/* If it hasn't been written to, don't write it out */
-	if (!vma->anon_vma)
+	if (signr != SIGKILL && !vma->anon_vma)
 		return 0;
 
 	return 1;
@@ -1646,7 +1940,7 @@ static int elf_core_dump(long signr, str
 		phdr.p_offset = offset;
 		phdr.p_vaddr = vma->vm_start;
 		phdr.p_paddr = 0;
-		phdr.p_filesz = maydump(vma) ? sz : 0;
+		phdr.p_filesz = maydump(vma, signr) ? sz : 0;
 		phdr.p_memsz = sz;
 		offset += phdr.p_filesz;
 		phdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;
@@ -1689,7 +1983,7 @@ static int elf_core_dump(long signr, str
 			vma = next_vma(vma, gate_vma)) {
 		unsigned long addr;
 
-		if (!maydump(vma))
+		if (!maydump(vma, signr))
 			continue;
 
 		for (addr = vma->vm_start;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/binfmt_flat.c linux-2.6.20.1-pax/fs/binfmt_flat.c
--- linux-2.6.20.1/fs/binfmt_flat.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/binfmt_flat.c	2007-02-05 00:56:21.000000000 +0100
@@ -551,7 +551,9 @@ static int load_flat_file(struct linux_b
 				realdatastart = (unsigned long) -ENOMEM;
 			printk("Unable to allocate RAM for process data, errno %d\n",
 					(int)-datapos);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len);
+			up_write(&current->mm->mmap_sem);
 			ret = realdatastart;
 			goto err;
 		}
@@ -573,8 +575,10 @@ static int load_flat_file(struct linux_b
 		}
 		if (result >= (unsigned long)-4096) {
 			printk("Unable to read data+bss, errno %d\n", (int)-result);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len);
 			do_munmap(current->mm, realdatastart, data_len + extra);
+			up_write(&current->mm->mmap_sem);
 			ret = result;
 			goto err;
 		}
@@ -638,8 +642,10 @@ static int load_flat_file(struct linux_b
 		}
 		if (result >= (unsigned long)-4096) {
 			printk("Unable to read code+data+bss, errno %d\n",(int)-result);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len + data_len + extra +
 				MAX_SHARED_LIBS * sizeof(unsigned long));
+			up_write(&current->mm->mmap_sem);
 			ret = result;
 			goto err;
 		}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/binfmt_misc.c linux-2.6.20.1-pax/fs/binfmt_misc.c
--- linux-2.6.20.1/fs/binfmt_misc.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/binfmt_misc.c	2007-02-18 21:17:01.000000000 +0100
@@ -113,9 +113,11 @@ static int load_misc_binary(struct linux
 	struct files_struct *files = NULL;
 
 	retval = -ENOEXEC;
-	if (!enabled)
+	if (!enabled || bprm->misc)
 		goto _ret;
 
+	bprm->misc++;
+
 	/* to keep locking time low, we copy the interpreter string */
 	read_lock(&entries_lock);
 	fmt = check_file(bprm);
@@ -729,7 +731,7 @@ static int bm_fill_super(struct super_bl
 	static struct tree_descr bm_files[] = {
 		[1] = {"status", &bm_status_operations, S_IWUSR|S_IRUGO},
 		[2] = {"register", &bm_register_operations, S_IWUSR},
-		/* last one */ {""}
+		/* last one */ {"", NULL, 0}
 	};
 	int err = simple_fill_super(sb, 0x42494e4d, bm_files);
 	if (!err)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/block_dev.c linux-2.6.20.1-pax/fs/block_dev.c
--- linux-2.6.20.1/fs/block_dev.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/block_dev.c	2007-02-16 00:30:52.000000000 +0100
@@ -950,7 +950,7 @@ static int bd_claim_by_kobject(struct bl
 				struct kobject *kobj)
 {
 	int res;
-	struct bd_holder *bo, *found;
+	struct bd_holder *bo, *found = NULL;
 
 	if (!kobj)
 		return -EINVAL;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/cifs/cifs_uniupr.h linux-2.6.20.1-pax/fs/cifs/cifs_uniupr.h
--- linux-2.6.20.1/fs/cifs/cifs_uniupr.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/cifs/cifs_uniupr.h	2007-02-16 00:32:37.000000000 +0100
@@ -132,7 +132,7 @@ const struct UniCaseRange CifsUniUpperRa
 	{0x0490, 0x04cc, UniCaseRangeU0490},
 	{0x1e00, 0x1ffc, UniCaseRangeU1e00},
 	{0xff40, 0xff5a, UniCaseRangeUff40},
-	{0}
+	{0, 0, NULL}
 };
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/cifs/cifssmb.c linux-2.6.20.1-pax/fs/cifs/cifssmb.c
--- linux-2.6.20.1/fs/cifs/cifssmb.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/cifs/cifssmb.c	2007-02-05 00:56:21.000000000 +0100
@@ -2812,10 +2812,10 @@ GetExtAttrOut:
 
 
 /* security id for everyone */
-const static struct cifs_sid sid_everyone = 
+static const struct cifs_sid sid_everyone = 
 		{1, 1, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}};
 /* group users */
-const static struct cifs_sid sid_user = 
+static const struct cifs_sid sid_user = 
 		{1, 2 , {0, 0, 0, 0, 0, 5}, {32, 545, 0, 0}};
 
 /* Convert CIFS ACL to POSIX form */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/cifs/smbdes.c linux-2.6.20.1-pax/fs/cifs/smbdes.c
--- linux-2.6.20.1/fs/cifs/smbdes.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/cifs/smbdes.c	2007-02-05 00:56:21.000000000 +0100
@@ -196,15 +196,18 @@ dohash(char *out, char *in, char *key, i
 	char c[28];
 	char d[28];
 	char *cd;
-	char ki[16][48];
+	char *ki;
 	char *pd1;
 	char l[32], r[32];
 	char *rl;
+	char *er;  /* er[48]  */
 
 	/* Have to reduce stack usage */
-	pk1 = kmalloc(56+56+64+64,GFP_KERNEL);
-	if(pk1 == NULL)
-		return;
+	pk1 = kmalloc(56+56+64+64, GFP_KERNEL);
+	ki = kmalloc(16*48, GFP_KERNEL);
+	er = kmalloc(48+48+32+32+32, GFP_KERNEL);
+	if (!pk1 || !ki || !er)
+		goto free;
 
 	cd = pk1 + 56;
 	pd1= cd  + 56;
@@ -222,7 +225,7 @@ dohash(char *out, char *in, char *key, i
 		lshift(d, sc[i], 28);
 
 		concat(cd, c, d, 28, 28);
-		permute(ki[i], cd, perm2, 48);
+		permute(ki+48*i, cd, perm2, 48);
 	}
 
 	permute(pd1, in, perm3, 64);
@@ -233,18 +236,12 @@ dohash(char *out, char *in, char *key, i
 	}
 
 	for (i = 0; i < 16; i++) {
-		char *er;  /* er[48]  */
 		char *erk; /* erk[48] */
 		char b[8][6];
 		char *cb;  /* cb[32]  */
 		char *pcb; /* pcb[32] */
 		char *r2;  /* r2[32]  */
 
-		er = kmalloc(48+48+32+32+32, GFP_KERNEL);
-		if(er == NULL) {
-			kfree(pk1);
-			return;
-		}
 		erk = er+48;
 		cb  = erk+48;
 		pcb = cb+32;
@@ -252,7 +249,7 @@ dohash(char *out, char *in, char *key, i
 
 		permute(er, r, perm4, 48);
 
-		xor(erk, er, ki[forw ? i : 15 - i], 48);
+		xor(erk, er, ki+48*(forw ? i : 15 - i), 48);
 
 		for (j = 0; j < 8; j++)
 			for (k = 0; k < 6; k++)
@@ -282,13 +279,15 @@ dohash(char *out, char *in, char *key, i
 
 		for (j = 0; j < 32; j++)
 			r[j] = r2[j];
-
-		kfree(er);
 	}
 
 	concat(rl, r, l, 32, 32);
 
 	permute(out, rl, perm6, 64);
+
+free:
+	kfree(er);
+	kfree(ki);
 	kfree(pk1);
 }
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/debugfs/inode.c linux-2.6.20.1-pax/fs/debugfs/inode.c
--- linux-2.6.20.1/fs/debugfs/inode.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/debugfs/inode.c	2007-02-18 21:18:38.000000000 +0100
@@ -114,7 +114,7 @@ static inline int debugfs_positive(struc
 
 static int debug_fill_super(struct super_block *sb, void *data, int silent)
 {
-	static struct tree_descr debug_files[] = {{""}};
+	static struct tree_descr debug_files[] = {{"", NULL, 0}};
 
 	return simple_fill_super(sb, DEBUGFS_MAGIC, debug_files);
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/exec.c linux-2.6.20.1-pax/fs/exec.c
--- linux-2.6.20.1/fs/exec.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/exec.c	2007-02-08 22:47:56.000000000 +0100
@@ -50,6 +50,7 @@
 #include <linux/cn_proc.h>
 #include <linux/audit.h>
 #include <linux/vs_memory.h>
+#include <linux/random.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -68,6 +69,15 @@ EXPORT_SYMBOL(suid_dumpable);
 static struct linux_binfmt *formats;
 static DEFINE_RWLOCK(binfmt_lock);
 
+#ifdef CONFIG_PAX_SOFTMODE
+unsigned int pax_softmode;
+#endif
+
+#ifdef CONFIG_PAX_HOOK_ACL_FLAGS
+void (*pax_set_initial_flags_func)(struct linux_binprm * bprm);
+EXPORT_SYMBOL(pax_set_initial_flags_func);
+#endif
+
 int register_binfmt(struct linux_binfmt * fmt)
 {
 	struct linux_binfmt ** tmp = &formats;
@@ -313,6 +323,10 @@ void install_arg_page(struct vm_area_str
 	if (unlikely(anon_vma_prepare(vma)))
 		goto out;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (page_count(page) == 1)
+#endif
+
 	flush_dcache_page(page);
 	pte = get_locked_pte(mm, address, &ptl);
 	if (!pte)
@@ -322,9 +336,21 @@ void install_arg_page(struct vm_area_str
 		goto out;
 	}
 	inc_mm_counter(mm, anon_rss);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (page_count(page) == 1)
+#endif
+
 	lru_cache_add_active(page);
 	set_pte_at(mm, address, pte, pte_mkdirty(pte_mkwrite(mk_pte(
 					page, vma->vm_page_prot))));
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (page_count(page) != 1)
+		page_add_anon_rmap(page, vma, address);
+	else
+#endif
+
 	page_add_new_anon_rmap(page, vma, address);
 	pte_unmap_unlock(pte, ptl);
 
@@ -347,6 +373,10 @@ int setup_arg_pages(struct linux_binprm 
 	int i, ret;
 	long arg_size;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *mpnt_m = NULL;
+#endif
+
 #ifdef CONFIG_STACK_GROWSUP
 	/* Move the argument and environment strings to the bottom of the
 	 * stack space.
@@ -405,11 +435,19 @@ int setup_arg_pages(struct linux_binprm 
 		bprm->loader += stack_base;
 	bprm->exec += stack_base;
 
-	mpnt = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+	mpnt = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
 	if (!mpnt)
 		return -ENOMEM;
 
-	memset(mpnt, 0, sizeof(*mpnt));
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (VM_STACK_FLAGS & VM_MAYEXEC)) {
+		mpnt_m = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+		if (!mpnt_m) {
+			kmem_cache_free(vm_area_cachep, mpnt);
+			return -ENOMEM;
+		}
+	}
+#endif
 
 	down_write(&mm->mmap_sem);
 	{
@@ -431,14 +469,51 @@ int setup_arg_pages(struct linux_binprm 
 		else
 			mpnt->vm_flags = VM_STACK_FLAGS;
 		mpnt->vm_flags |= mm->def_flags;
-		mpnt->vm_page_prot = protection_map[mpnt->vm_flags & 0x7];
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+		if (!(mm->pax_flags & MF_PAX_PAGEEXEC))
+			mpnt->vm_page_prot = protection_map[(mpnt->vm_flags | VM_EXEC) & (VM_READ|VM_WRITE|VM_EXEC)];
+		else
+#endif
+
+		mpnt->vm_page_prot = protection_map[mpnt->vm_flags & (VM_READ|VM_WRITE|VM_EXEC)];
 		if ((ret = insert_vm_struct(mm, mpnt))) {
 			up_write(&mm->mmap_sem);
 			kmem_cache_free(vm_area_cachep, mpnt);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (mpnt_m)
+				kmem_cache_free(vm_area_cachep, mpnt_m);
+#endif
+
 			return ret;
 		}
 		vx_vmpages_sub(mm, mm->total_vm - vma_pages(mpnt));
 		mm->stack_vm = mm->total_vm;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (mpnt_m) {
+			*mpnt_m = *mpnt;
+			if (!(mpnt->vm_flags & VM_EXEC)) {
+				mpnt_m->vm_flags &= ~(VM_READ | VM_WRITE | VM_EXEC);
+				mpnt_m->vm_page_prot = PAGE_NONE;
+			}
+			mpnt_m->vm_start += SEGMEXEC_TASK_SIZE;
+			mpnt_m->vm_end += SEGMEXEC_TASK_SIZE;
+			if ((ret = insert_vm_struct(mm, mpnt_m))) {
+				up_write(&mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, mpnt_m);
+				return ret;
+			}
+			mpnt_m->vm_flags |= VM_MIRROR;
+			mpnt->vm_flags |= VM_MIRROR;
+			mpnt_m->vm_mirror = mpnt->vm_start - mpnt_m->vm_start;
+			mpnt->vm_mirror = mpnt_m->vm_start - mpnt->vm_start;
+			mpnt_m->vm_pgoff = mpnt->vm_pgoff;
+			mm->total_vm += vma_pages(mpnt_m);
+		}
+#endif
+
 	}
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
@@ -445,6 +520,14 @@ int setup_arg_pages(struct linux_binprm 
 		if (page) {
 			bprm->page[i] = NULL;
 			install_arg_page(mpnt, page, stack_base);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (mpnt_m) {
+				page_cache_get(page);
+				install_arg_page(mpnt_m, page, stack_base + SEGMEXEC_TASK_SIZE);
+			}
+#endif
+
 		}
 		stack_base += PAGE_SIZE;
 	}
@@ -1144,6 +1227,11 @@ int do_execve(char * filename,
 
 	bprm->p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
 
+#ifdef CONFIG_PAX_RANDUSTACK
+	if (randomize_va_space)
+		bprm->p -= (pax_get_random_long() & ~(sizeof(void *)-1)) & ~PAGE_MASK;
+#endif
+
 	bprm->file = file;
 	bprm->filename = filename;
 	bprm->interp = filename;
@@ -1356,6 +1444,111 @@ static void format_corename(char *corena
 	*out_ptr = 0;
 }
 
+int pax_check_flags(unsigned long * flags)
+{
+	int retval = 0;
+
+#if !defined(__i386__) || !defined(CONFIG_PAX_SEGMEXEC)
+	if (*flags & MF_PAX_SEGMEXEC)
+	{
+		*flags &= ~MF_PAX_SEGMEXEC;
+		retval = -EINVAL;
+	}
+#endif
+
+	if ((*flags & MF_PAX_PAGEEXEC)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	    &&  (*flags & MF_PAX_SEGMEXEC)
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_PAGEEXEC;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_MPROTECT)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_MPROTECT;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_EMUTRAMP)
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_EMUTRAMP;
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+EXPORT_SYMBOL(pax_check_flags);
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp)
+{
+	struct task_struct *tsk = current;
+	struct mm_struct *mm = current->mm;
+	char* buffer_exec = (char*)__get_free_page(GFP_ATOMIC);
+	char* buffer_fault = (char*)__get_free_page(GFP_ATOMIC);
+	char* path_exec=NULL;
+	char* path_fault=NULL;
+	unsigned long start=0UL, end=0UL, offset=0UL;
+
+	if (buffer_exec && buffer_fault) {
+		struct vm_area_struct* vma, * vma_exec=NULL, * vma_fault=NULL;
+
+		down_read(&mm->mmap_sem);
+		vma = mm->mmap;
+		while (vma && (!vma_exec || !vma_fault)) {
+			if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file)
+				vma_exec = vma;
+			if (vma->vm_start <= (unsigned long)pc && (unsigned long)pc < vma->vm_end)
+				vma_fault = vma;
+			vma = vma->vm_next;
+		}
+		if (vma_exec) {
+			path_exec = d_path(vma_exec->vm_file->f_path.dentry, vma_exec->vm_file->f_path.mnt, buffer_exec, PAGE_SIZE);
+			if (IS_ERR(path_exec))
+				path_exec = "<path too long>";
+		}
+		if (vma_fault) {
+			start = vma_fault->vm_start;
+			end = vma_fault->vm_end;
+			offset = vma_fault->vm_pgoff << PAGE_SHIFT;
+			if (vma_fault->vm_file) {
+				path_fault = d_path(vma_fault->vm_file->f_path.dentry, vma_fault->vm_file->f_path.mnt, buffer_fault, PAGE_SIZE);
+				if (IS_ERR(path_fault))
+					path_fault = "<path too long>";
+			} else
+				path_fault = "<anonymous mapping>";
+		}
+		up_read(&mm->mmap_sem);
+	}
+	printk(KERN_ERR "PAX: execution attempt in: %s, %08lx-%08lx %08lx\n", path_fault, start, end, offset);
+	printk(KERN_ERR "PAX: terminating task: %s(%s):%d, uid/euid: %u/%u, "
+			"PC: %p, SP: %p\n", path_exec, tsk->comm, tsk->pid,
+			tsk->uid, tsk->euid, pc, sp);
+	free_page((unsigned long)buffer_exec);
+	free_page((unsigned long)buffer_fault);
+	pax_report_insns(pc, sp);
+	do_coredump(SIGKILL, SIGKILL, regs);
+}
+#endif
+
 static void zap_process(struct task_struct *start)
 {
 	struct task_struct *t;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/ext3/xattr.c linux-2.6.20.1-pax/fs/ext3/xattr.c
--- linux-2.6.20.1/fs/ext3/xattr.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/ext3/xattr.c	2007-02-05 00:56:21.000000000 +0100
@@ -89,8 +89,8 @@
 		printk("\n"); \
 	} while (0)
 #else
-# define ea_idebug(f...)
-# define ea_bdebug(f...)
+# define ea_idebug(f...) do {} while (0)
+# define ea_bdebug(f...) do {} while (0)
 #endif
 
 static void ext3_xattr_cache_insert(struct buffer_head *);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/fuse/control.c linux-2.6.20.1-pax/fs/fuse/control.c
--- linux-2.6.20.1/fs/fuse/control.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/fuse/control.c	2007-02-18 21:19:00.000000000 +0100
@@ -159,7 +159,7 @@ void fuse_ctl_remove_conn(struct fuse_co
 
 static int fuse_ctl_fill_super(struct super_block *sb, void *data, int silent)
 {
-	struct tree_descr empty_descr = {""};
+	struct tree_descr empty_descr = {"", NULL, 0};
 	struct fuse_conn *fc;
 	int err;
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/nls/nls_base.c linux-2.6.20.1-pax/fs/nls/nls_base.c
--- linux-2.6.20.1/fs/nls/nls_base.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/nls/nls_base.c	2007-02-16 00:33:57.000000000 +0100
@@ -42,7 +42,7 @@ static struct utf8_table utf8_table[] =
     {0xF8,  0xF0,   3*6,    0x1FFFFF,       0x10000,   /* 4 byte sequence */},
     {0xFC,  0xF8,   4*6,    0x3FFFFFF,      0x200000,  /* 5 byte sequence */},
     {0xFE,  0xFC,   5*6,    0x7FFFFFFF,     0x4000000, /* 6 byte sequence */},
-    {0,						       /* end of table    */}
+    {0, 0, 0, 0, 0,				       /* end of table    */}
 };
 
 int
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/ntfs/file.c linux-2.6.20.1-pax/fs/ntfs/file.c
--- linux-2.6.20.1/fs/ntfs/file.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/ntfs/file.c	2007-02-16 00:36:12.000000000 +0100
@@ -2335,6 +2335,6 @@ struct inode_operations ntfs_file_inode_
 #endif /* NTFS_RW */
 };
 
-const struct file_operations ntfs_empty_file_ops = {};
+const struct file_operations ntfs_empty_file_ops;
 
-struct inode_operations ntfs_empty_inode_ops = {};
+struct inode_operations ntfs_empty_inode_ops;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/partitions/efi.c linux-2.6.20.1-pax/fs/partitions/efi.c
--- linux-2.6.20.1/fs/partitions/efi.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/partitions/efi.c	2007-02-05 00:56:21.000000000 +0100
@@ -99,7 +99,7 @@
 #ifdef EFI_DEBUG
 #define Dprintk(x...) printk(KERN_DEBUG x)
 #else
-#define Dprintk(x...)
+#define Dprintk(x...) do {} while (0)
 #endif
 
 /* This allows a kernel command line option 'gpt' to override
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/proc/array.c linux-2.6.20.1-pax/fs/proc/array.c
--- linux-2.6.20.1/fs/proc/array.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/proc/array.c	2007-02-05 00:56:21.000000000 +0100
@@ -291,6 +291,21 @@ static inline char *task_cap(struct task
 			    cap_t(p->cap_effective));
 }
 
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline char *task_pax(struct task_struct *p, char *buffer)
+{
+	if (p->mm)
+		return buffer + sprintf(buffer, "PaX:\t%c%c%c%c%c\n",
+				p->mm->pax_flags & MF_PAX_PAGEEXEC ? 'P' : 'p',
+				p->mm->pax_flags & MF_PAX_EMUTRAMP ? 'E' : 'e',
+				p->mm->pax_flags & MF_PAX_MPROTECT ? 'M' : 'm',
+				p->mm->pax_flags & MF_PAX_RANDMMAP ? 'R' : 'r',
+				p->mm->pax_flags & MF_PAX_SEGMEXEC ? 'S' : 's');
+	else
+		return buffer + sprintf(buffer, "PaX:\t-----\n");
+}
+#endif
+
 int proc_pid_status(struct task_struct *task, char * buffer)
 {
 	char * orig = buffer;
@@ -309,6 +324,11 @@ int proc_pid_status(struct task_struct *
 #if defined(CONFIG_S390)
 	buffer = task_show_regs(task, buffer);
 #endif
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	buffer = task_pax(task, buffer);
+#endif
+
 	return buffer - orig;
 }
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/proc/task_mmu.c linux-2.6.20.1-pax/fs/proc/task_mmu.c
--- linux-2.6.20.1/fs/proc/task_mmu.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/proc/task_mmu.c	2007-02-05 00:56:21.000000000 +0100
@@ -43,15 +43,27 @@ char *task_mem(struct mm_struct *mm, cha
 		"VmStk:\t%8lu kB\n"
 		"VmExe:\t%8lu kB\n"
 		"VmLib:\t%8lu kB\n"
-		"VmPTE:\t%8lu kB\n",
-		hiwater_vm << (PAGE_SHIFT-10),
+		"VmPTE:\t%8lu kB\n"
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+		"CsBase:\t%8lx\nCsLim:\t%8lx\n"
+#endif
+
+		,hiwater_vm << (PAGE_SHIFT-10),
 		(total_vm - mm->reserved_vm) << (PAGE_SHIFT-10),
 		mm->locked_vm << (PAGE_SHIFT-10),
 		hiwater_rss << (PAGE_SHIFT-10),
 		total_rss << (PAGE_SHIFT-10),
 		data << (PAGE_SHIFT-10),
 		mm->stack_vm << (PAGE_SHIFT-10), text, lib,
-		(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10);
+		(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+		, mm->context.user_cs_base, mm->context.user_cs_limit
+#endif
+
+	);
+
 	return buffer;
 }
 
@@ -143,9 +155,17 @@ static int show_map_internal(struct seq_
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08lx %02x:%02x %lu %n",
 			vma->vm_start,
 			vma->vm_end,
+
+#if 0
+			flags & VM_MAYREAD ? flags & VM_READ ? 'R' : '+' : flags & VM_READ ? 'r' : '-',
+			flags & VM_MAYWRITE ? flags & VM_WRITE ? 'W' : '+' : flags & VM_WRITE ? 'w' : '-',
+			flags & VM_MAYEXEC ? flags & VM_EXEC ? 'X' : '+' : flags & VM_EXEC ? 'x' : '-',
+#else
 			flags & VM_READ ? 'r' : '-',
 			flags & VM_WRITE ? 'w' : '-',
 			flags & VM_EXEC ? 'x' : '-',
+#endif
+
 			flags & VM_MAYSHARE ? 's' : 'p',
 			vma->vm_pgoff << PAGE_SHIFT,
 			MAJOR(dev), MINOR(dev), ino, &len);
@@ -161,11 +181,11 @@ static int show_map_internal(struct seq_
 		const char *name = arch_vma_name(vma);
 		if (!name) {
 			if (mm) {
-				if (vma->vm_start <= mm->start_brk &&
-						vma->vm_end >= mm->brk) {
+				if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {
 					name = "[heap]";
-				} else if (vma->vm_start <= mm->start_stack &&
-					   vma->vm_end >= mm->start_stack) {
+				} else if ((vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP)) ||
+					   (vma->vm_start <= mm->start_stack &&
+					    vma->vm_end >= mm->start_stack)) {
 					name = "[stack]";
 				}
 			} else {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/udf/balloc.c linux-2.6.20.1-pax/fs/udf/balloc.c
--- linux-2.6.20.1/fs/udf/balloc.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/udf/balloc.c	2007-02-05 00:56:21.000000000 +0100
@@ -153,8 +153,7 @@ static void udf_bitmap_free_blocks(struc
 	unsigned long overflow;
 
 	mutex_lock(&sbi->s_alloc_mutex);
-	if (bloc.logicalBlockNum < 0 ||
-		(bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb, bloc.partitionReferenceNum))
+	if (bloc.logicalBlockNum + count > UDF_SB_PARTLEN(sb, bloc.partitionReferenceNum))
 	{
 		udf_debug("%d < %d || %d + %d > %d\n",
 			bloc.logicalBlockNum, 0, bloc.logicalBlockNum, count,
@@ -227,7 +226,7 @@ static int udf_bitmap_prealloc_blocks(st
 	struct buffer_head *bh;
 
 	mutex_lock(&sbi->s_alloc_mutex);
-	if (first_block < 0 || first_block >= UDF_SB_PARTLEN(sb, partition))
+	if (first_block >= UDF_SB_PARTLEN(sb, partition))
 		goto out;
 
 	if (first_block + block_count > UDF_SB_PARTLEN(sb, partition))
@@ -294,7 +293,7 @@ static int udf_bitmap_new_block(struct s
 	mutex_lock(&sbi->s_alloc_mutex);
 
 repeat:
-	if (goal < 0 || goal >= UDF_SB_PARTLEN(sb, partition))
+	if (goal >= UDF_SB_PARTLEN(sb, partition))
 		goal = 0;
 
 	nr_groups = bitmap->s_nr_groups;
@@ -434,8 +433,7 @@ static void udf_table_free_blocks(struct
 	int i;
 
 	mutex_lock(&sbi->s_alloc_mutex);
-	if (bloc.logicalBlockNum < 0 ||
-		(bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb, bloc.partitionReferenceNum))
+	if (bloc.logicalBlockNum + count > UDF_SB_PARTLEN(sb, bloc.partitionReferenceNum))
 	{
 		udf_debug("%d < %d || %d + %d > %d\n",
 			bloc.logicalBlockNum, 0, bloc.logicalBlockNum, count,
@@ -682,7 +680,7 @@ static int udf_table_prealloc_blocks(str
 	struct buffer_head *bh;
 	int8_t etype = -1;
 
-	if (first_block < 0 || first_block >= UDF_SB_PARTLEN(sb, partition))
+	if (first_block >= UDF_SB_PARTLEN(sb, partition))
 		return 0;
 
 	if (UDF_I_ALLOCTYPE(table) == ICBTAG_FLAG_AD_SHORT)
@@ -762,7 +760,7 @@ static int udf_table_new_block(struct su
 		return newblock;
 
 	mutex_lock(&sbi->s_alloc_mutex);
-	if (goal < 0 || goal >= UDF_SB_PARTLEN(sb, partition))
+	if (goal >= UDF_SB_PARTLEN(sb, partition))
 		goal = 0;
 
 	/* We search for the closest matching block to goal. If we find a exact hit,
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/udf/inode.c linux-2.6.20.1-pax/fs/udf/inode.c
--- linux-2.6.20.1/fs/udf/inode.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/udf/inode.c	2007-02-05 00:56:21.000000000 +0100
@@ -300,9 +300,6 @@ static int udf_get_block(struct inode *i
 
 	lock_kernel();
 
-	if (block < 0)
-		goto abort_negative;
-
 	if (block == UDF_I_NEXT_ALLOC_BLOCK(inode) + 1)
 	{
 		UDF_I_NEXT_ALLOC_BLOCK(inode) ++;
@@ -323,10 +320,6 @@ static int udf_get_block(struct inode *i
 abort:
 	unlock_kernel();
 	return err;
-
-abort_negative:
-	udf_warning(inode->i_sb, "udf_get_block", "block < 0");
-	goto abort;
 }
 
 static struct buffer_head *
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/ufs/inode.c linux-2.6.20.1-pax/fs/ufs/inode.c
--- linux-2.6.20.1/fs/ufs/inode.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/ufs/inode.c	2007-02-05 00:56:21.000000000 +0100
@@ -55,9 +55,7 @@ static int ufs_block_to_path(struct inod
 
 
 	UFSD("ptrs=uspi->s_apb = %d,double_blocks=%ld \n",ptrs,double_blocks);
-	if (i_block < 0) {
-		ufs_warning(inode->i_sb, "ufs_block_to_path", "block < 0");
-	} else if (i_block < direct_blocks) {
+	if (i_block < direct_blocks) {
 		offsets[n++] = i_block;
 	} else if ((i_block -= direct_blocks) < indirect_blocks) {
 		offsets[n++] = UFS_IND_BLOCK;
@@ -425,8 +423,6 @@ int ufs_getfrag_block(struct inode *inod
 	lock_kernel();
 
 	UFSD("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment);
-	if (fragment < 0)
-		goto abort_negative;
 	if (fragment >
 	    ((UFS_NDADDR + uspi->s_apb + uspi->s_2apb + uspi->s_3apb)
 	     << uspi->s_fpbshift))
@@ -489,10 +485,6 @@ abort:
 	unlock_kernel();
 	return err;
 
-abort_negative:
-	ufs_warning(sb, "ufs_get_block", "block < 0");
-	goto abort;
-
 abort_too_big:
 	ufs_warning(sb, "ufs_get_block", "block > big");
 	goto abort;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/xfs/linux-2.6/xfs_file.c linux-2.6.20.1-pax/fs/xfs/linux-2.6/xfs_file.c
--- linux-2.6.20.1/fs/xfs/linux-2.6/xfs_file.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/xfs/linux-2.6/xfs_file.c	2007-02-05 00:56:21.000000000 +0100
@@ -342,6 +342,12 @@ xfs_file_mmap(
 	struct file	*filp,
 	struct vm_area_struct *vma)
 {
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+	if ((vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+		vma->vm_page_prot = __pgprot(pte_val(pte_exprotect(__pte(pgprot_val(vma->vm_page_prot)))));
+#endif
+
 	vma->vm_ops = &xfs_file_vm_ops;
 
 #ifdef CONFIG_XFS_DMAPI
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/fs/xfs/xfs_bmap.c linux-2.6.20.1-pax/fs/xfs/xfs_bmap.c
--- linux-2.6.20.1/fs/xfs/xfs_bmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/fs/xfs/xfs_bmap.c	2007-02-05 00:56:21.000000000 +0100
@@ -376,7 +376,7 @@ xfs_bmap_validate_ret(
 	int			nmap,
 	int			ret_nmap);
 #else
-#define	xfs_bmap_validate_ret(bno,len,flags,mval,onmap,nmap)
+#define	xfs_bmap_validate_ret(bno,len,flags,mval,onmap,nmap) do {} while (0)
 #endif /* DEBUG */
 
 #if defined(XFS_RW_TRACE)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/acpi/acmacros.h linux-2.6.20.1-pax/include/acpi/acmacros.h
--- linux-2.6.20.1/include/acpi/acmacros.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/acpi/acmacros.h	2007-02-05 00:56:21.000000000 +0100
@@ -672,7 +672,7 @@
 #define ACPI_DUMP_PATHNAME(a,b,c,d)
 #define ACPI_DUMP_RESOURCE_LIST(a)
 #define ACPI_DUMP_BUFFER(a,b)
-#define ACPI_DEBUG_PRINT(pl)
+#define ACPI_DEBUG_PRINT(pl) do {} while (0)
 #define ACPI_DEBUG_PRINT_RAW(pl)
 
 #define return_VOID                     return
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-alpha/a.out.h linux-2.6.20.1-pax/include/asm-alpha/a.out.h
--- linux-2.6.20.1/include/asm-alpha/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-alpha/a.out.h	2007-02-05 00:56:21.000000000 +0100
@@ -98,7 +98,7 @@ struct exec
 	set_personality (((BFPM->sh_bang || EX.ah.entry < 0x100000000L \
 			   ? ADDR_LIMIT_32BIT : 0) | PER_OSF4))
 
-#define STACK_TOP \
+#define __STACK_TOP \
   (current->personality & ADDR_LIMIT_32BIT ? 0x80000000 : 0x00120000000UL)
 
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-alpha/elf.h linux-2.6.20.1-pax/include/asm-alpha/elf.h
--- linux-2.6.20.1/include/asm-alpha/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-alpha/elf.h	2007-02-05 00:56:21.000000000 +0100
@@ -91,6 +91,17 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x1000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	((tsk)->personality & ADDR_LIMIT_32BIT ? 0x10000 : 0x120000000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk)->personality & ADDR_LIMIT_32BIT ? 14 : 28)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((tsk)->personality & ADDR_LIMIT_32BIT ? 14 : 28)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk)->personality & ADDR_LIMIT_32BIT ? 14 : 19)
+#endif
+
 /* $0 is set by ld.so to a pointer to a function which might be 
    registered using atexit.  This provides a mean for the dynamic
    linker to call DT_FINI functions for shared libraries that have
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-alpha/kmap_types.h linux-2.6.20.1-pax/include/asm-alpha/kmap_types.h
--- linux-2.6.20.1/include/asm-alpha/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-alpha/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -24,7 +24,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-alpha/page.h linux-2.6.20.1-pax/include/asm-alpha/page.h
--- linux-2.6.20.1/include/asm-alpha/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-alpha/page.h	2007-02-05 00:56:21.000000000 +0100
@@ -93,6 +93,15 @@ typedef unsigned long pgprot_t;
 #define VM_DATA_DEFAULT_FLAGS		(VM_READ | VM_WRITE | VM_EXEC | \
 					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #include <asm-generic/memory_model.h>
 #include <asm-generic/page.h>
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-alpha/pgtable.h linux-2.6.20.1-pax/include/asm-alpha/pgtable.h
--- linux-2.6.20.1/include/asm-alpha/pgtable.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-alpha/pgtable.h	2007-02-05 00:56:21.000000000 +0100
@@ -101,6 +101,17 @@ struct vm_area_struct;
 #define PAGE_SHARED	__pgprot(_PAGE_VALID | __ACCESS_BITS)
 #define PAGE_COPY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
 #define PAGE_READONLY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOE)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_VALID | _PAGE_ASM | _PAGE_KRE | _PAGE_KWE)
 
 #define _PAGE_NORMAL(x) __pgprot(_PAGE_VALID | __ACCESS_BITS | (x))
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-arm/a.out.h linux-2.6.20.1-pax/include/asm-arm/a.out.h
--- linux-2.6.20.1/include/asm-arm/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-arm/a.out.h	2007-02-05 00:56:21.000000000 +0100
@@ -28,7 +28,7 @@ struct exec
 #define M_ARM 103
 
 #ifdef __KERNEL__
-#define STACK_TOP	((current->personality == PER_LINUX_32BIT) ? \
+#define __STACK_TOP	((current->personality == PER_LINUX_32BIT) ? \
 			 TASK_SIZE : TASK_SIZE_26)
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-arm/elf.h linux-2.6.20.1-pax/include/asm-arm/elf.h
--- linux-2.6.20.1/include/asm-arm/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-arm/elf.h	2007-02-05 00:56:21.000000000 +0100
@@ -110,6 +110,17 @@ extern char elf_platform[];
 
 #define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x00008000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk->personality == PER_LINUX_32BIT) ? 16 : 10)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((tsk->personality == PER_LINUX_32BIT) ? 16 : 10)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk->personality == PER_LINUX_32BIT) ? 16 : 10)
+#endif
+
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
    have no such handler.  */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-arm/kmap_types.h linux-2.6.20.1-pax/include/asm-arm/kmap_types.h
--- linux-2.6.20.1/include/asm-arm/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-arm/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -18,6 +18,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-arm26/kmap_types.h linux-2.6.20.1-pax/include/asm-arm26/kmap_types.h
--- linux-2.6.20.1/include/asm-arm26/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-arm26/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -6,7 +6,8 @@
  */
 enum km_type {
         KM_IRQ0,
-        KM_USER1
+        KM_USER1,
+        KM_CLEARPAGE
 };
 
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-cris/kmap_types.h linux-2.6.20.1-pax/include/asm-cris/kmap_types.h
--- linux-2.6.20.1/include/asm-cris/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-cris/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -19,6 +19,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-frv/kmap_types.h linux-2.6.20.1-pax/include/asm-frv/kmap_types.h
--- linux-2.6.20.1/include/asm-frv/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-frv/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -23,6 +23,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-h8300/kmap_types.h linux-2.6.20.1-pax/include/asm-h8300/kmap_types.h
--- linux-2.6.20.1/include/asm-h8300/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-h8300/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -15,6 +15,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/a.out.h linux-2.6.20.1-pax/include/asm-i386/a.out.h
--- linux-2.6.20.1/include/asm-i386/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/a.out.h	2007-02-05 00:56:21.000000000 +0100
@@ -19,7 +19,11 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#ifdef CONFIG_PAX_SEGMEXEC
+#define __STACK_TOP ((current->mm->pax_flags & MF_PAX_SEGMEXEC)?TASK_SIZE/2:TASK_SIZE)
+#else
+#define __STACK_TOP TASK_SIZE
+#endif
 
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/alternative.h linux-2.6.20.1-pax/include/asm-i386/alternative.h
--- linux-2.6.20.1/include/asm-i386/alternative.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/alternative.h	2007-02-05 00:56:21.000000000 +0100
@@ -57,7 +57,7 @@ static inline void alternatives_smp_swit
 		      "  .byte 662b-661b\n"       /* sourcelen */	\
 		      "  .byte 664f-663f\n"       /* replacementlen */	\
 		      ".previous\n"					\
-		      ".section .altinstr_replacement,\"ax\"\n"		\
+		      ".section .altinstr_replacement,\"a\"\n"		\
 		      "663:\n\t" newinstr "\n664:\n"   /* replacement */\
 		      ".previous" :: "i" (feature) : "memory")
 
@@ -81,7 +81,7 @@ static inline void alternatives_smp_swit
 		      "  .byte 662b-661b\n"       /* sourcelen */	\
 		      "  .byte 664f-663f\n"       /* replacementlen */ 	\
 		      ".previous\n"					\
-		      ".section .altinstr_replacement,\"ax\"\n"		\
+		      ".section .altinstr_replacement,\"a\"\n"		\
 		      "663:\n\t" newinstr "\n664:\n"   /* replacement */\
 		      ".previous" :: "i" (feature), ##input)
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/apic.h linux-2.6.20.1-pax/include/asm-i386/apic.h
--- linux-2.6.20.1/include/asm-i386/apic.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/apic.h	2007-02-05 00:56:21.000000000 +0100
@@ -7,7 +7,7 @@
 #include <asm/processor.h>
 #include <asm/system.h>
 
-#define Dprintk(x...)
+#define Dprintk(x...) do {} while (0)
 
 /*
  * Debugging macros
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/checksum.h linux-2.6.20.1-pax/include/asm-i386/checksum.h
--- linux-2.6.20.1/include/asm-i386/checksum.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/checksum.h	2007-02-05 00:56:21.000000000 +0100
@@ -30,6 +30,12 @@ asmlinkage __wsum csum_partial(const voi
 asmlinkage __wsum csum_partial_copy_generic(const void *src, void *dst,
 						  int len, __wsum sum, int *src_err_ptr, int *dst_err_ptr);
 
+asmlinkage __wsum csum_partial_copy_generic_to_user(const unsigned char *src, unsigned char *dst,
+						  int len, __wsum sum, int *src_err_ptr, int *dst_err_ptr);
+
+asmlinkage __wsum csum_partial_copy_generic_from_user(const unsigned char *src, unsigned char *dst,
+						  int len, __wsum sum, int *src_err_ptr, int *dst_err_ptr);
+
 /*
  *	Note: when you get a NULL pointer exception here this means someone
  *	passed in an incorrect kernel address to one of these functions.
@@ -49,7 +55,7 @@ __wsum csum_partial_copy_from_user(const
 						int len, __wsum sum, int *err_ptr)
 {
 	might_sleep();
-	return csum_partial_copy_generic((__force void *)src, dst,
+	return csum_partial_copy_generic_from_user((__force void *)src, dst,
 					len, sum, err_ptr, NULL);
 }
 
@@ -180,7 +186,7 @@ static __inline__ __wsum csum_and_copy_t
 {
 	might_sleep();
 	if (access_ok(VERIFY_WRITE, dst, len))
-		return csum_partial_copy_generic(src, (__force void *)dst, len, sum, NULL, err_ptr);
+		return csum_partial_copy_generic_to_user(src, (__force void *)dst, len, sum, NULL, err_ptr);
 
 	if (len)
 		*err_ptr = -EFAULT;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/desc.h linux-2.6.20.1-pax/include/asm-i386/desc.h
--- linux-2.6.20.1/include/asm-i386/desc.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/desc.h	2007-02-18 23:24:19.000000000 +0100
@@ -8,25 +8,25 @@
 
 #include <linux/preempt.h>
 #include <linux/smp.h>
-#include <linux/percpu.h>
+#include <linux/sched.h>
 
 #include <asm/mmu.h>
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
 
-extern struct desc_struct cpu_gdt_table[GDT_ENTRIES];
+extern struct desc_struct cpu_gdt_table[NR_CPUS][PAGE_SIZE / sizeof(struct desc_struct)];
 
 struct Xgt_desc_struct {
 	unsigned short size;
-	unsigned long address __attribute__((packed));
+	struct desc_struct *address __attribute__((packed));
 	unsigned short pad;
 } __attribute__ ((packed));
 
-extern struct Xgt_desc_struct idt_descr;
-DECLARE_PER_CPU(struct Xgt_desc_struct, cpu_gdt_descr);
-
+extern struct Xgt_desc_struct idt_descr, cpu_gdt_descr[NR_CPUS];
 
 static inline struct desc_struct *get_cpu_gdt_table(unsigned int cpu)
 {
-	return (struct desc_struct *)per_cpu(cpu_gdt_descr, cpu).address;
+	return cpu_gdt_table[cpu];
 }
 
 extern struct desc_struct idt_table[];
@@ -76,9 +76,21 @@ static inline void pack_gate(__u32 *a, _
 
 static inline void load_TLS(struct thread_struct *t, unsigned int cpu)
 {
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 #define C(i) get_cpu_gdt_table(cpu)[GDT_ENTRY_TLS_MIN + i] = t->tls_array[i]
 	C(0); C(1); C(2);
 #undef C
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 #define write_ldt_entry(dt, entry, a, b) write_dt_entry(dt, entry, a, b)
@@ -88,8 +100,20 @@ static inline void load_TLS(struct threa
 static inline void write_dt_entry(void *dt, int entry, __u32 entry_a, __u32 entry_b)
 {
 	__u32 *lp = (__u32 *)((char *)dt + entry*8);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	*lp = entry_a;
 	*(lp+1) = entry_b;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 #define set_ldt native_set_ldt
@@ -144,7 +168,7 @@ static inline void __set_tss_desc(unsign
 	((info)->seg_32bit << 22) | \
 	((info)->limit_in_pages << 23) | \
 	((info)->useable << 20) | \
-	0x7000)
+	0x7100)
 
 #define LDT_empty(info) (\
 	(info)->base_addr	== 0	&& \
@@ -176,15 +200,25 @@ static inline void load_LDT(mm_context_t
 	preempt_enable();
 }
 
-static inline unsigned long get_desc_base(unsigned long *desc)
+static inline unsigned long get_desc_base(struct desc_struct *desc)
 {
 	unsigned long base;
-	base = ((desc[0] >> 16)  & 0x0000ffff) |
-		((desc[1] << 16) & 0x00ff0000) |
-		(desc[1] & 0xff000000);
+	base = ((desc->a >> 16)  & 0x0000ffff) |
+		((desc->b << 16) & 0x00ff0000) |
+		(desc->b & 0xff000000);
 	return base;
 }
 
+static inline void set_user_cs(struct mm_struct *mm, int cpu)
+{
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	__u32 a, b;
+
+	pack_descriptor(&a, &b, mm->context.user_cs_base, mm->context.user_cs_limit - 1, 0xFB, 0xC);
+	write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_DEFAULT_USER_CS, a, b);
+#endif
+}
+
 #else /* __ASSEMBLY__ */
 
 /*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/elf.h linux-2.6.20.1-pax/include/asm-i386/elf.h
--- linux-2.6.20.1/include/asm-i386/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/elf.h	2007-02-05 00:56:21.000000000 +0100
@@ -75,7 +75,22 @@ typedef struct user_fxsr_struct elf_fpxr
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define ELF_ET_DYN_BASE         ((current->mm->pax_flags & MF_PAX_SEGMEXEC) ? SEGMEXEC_TASK_SIZE/3*2 : TASK_SIZE/3*2)
+#else
 #define ELF_ET_DYN_BASE		((TASK_UNMAPPED_BASE) * 2)
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x10000000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk)->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		15
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk)->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+#endif
 
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different) */
@@ -133,7 +148,7 @@ extern int dump_task_extended_fpu (struc
 #define ELF_CORE_COPY_XFPREGS(tsk, elf_xfpregs) dump_task_extended_fpu(tsk, elf_xfpregs)
 
 #define VDSO_HIGH_BASE		(__fix_to_virt(FIX_VDSO))
-#define VDSO_BASE		((unsigned long)current->mm->context.vdso)
+#define VDSO_BASE		(current->mm->context.vdso)
 
 #ifdef CONFIG_COMPAT_VDSO
 # define VDSO_COMPAT_BASE	VDSO_HIGH_BASE
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/futex.h linux-2.6.20.1-pax/include/asm-i386/futex.h
--- linux-2.6.20.1/include/asm-i386/futex.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/futex.h	2007-02-19 10:37:06.000000000 +0100
@@ -11,8 +11,11 @@
 
 #define __futex_atomic_op1(insn, ret, oldval, uaddr, oparg) \
   __asm__ __volatile (						\
+	"movw	%w6, %%ds\n"\
 "1:	" insn "\n"						\
-"2:	.section .fixup,\"ax\"\n\
+"2:	pushl	%%ss\n\
+	popl	%%ds\n\
+	.section .fixup,\"ax\"\n\
 3:	mov	%3, %1\n\
 	jmp	2b\n\
 	.previous\n\
@@ -21,16 +24,19 @@
 	.long	1b,3b\n\
 	.previous"						\
 	: "=r" (oldval), "=r" (ret), "+m" (*uaddr)		\
-	: "i" (-EFAULT), "0" (oparg), "1" (0))
+	: "i" (-EFAULT), "0" (oparg), "1" (0), "r" (__USER_DS))
 
 #define __futex_atomic_op2(insn, ret, oldval, uaddr, oparg) \
   __asm__ __volatile (						\
-"1:	movl	%2, %0\n\
+"	movw	%w7, %%es\n\
+1:	movl	%%es:%2, %0\n\
 	movl	%0, %3\n"					\
 	insn "\n"						\
-"2:	" LOCK_PREFIX "cmpxchgl %3, %2\n\
+"2:	" LOCK_PREFIX "cmpxchgl %3, %%es:%2\n\
 	jnz	1b\n\
-3:	.section .fixup,\"ax\"\n\
+3:	pushl	%%ss\n\
+	popl	%%es\n\
+	.section .fixup,\"ax\"\n\
 4:	mov	%5, %1\n\
 	jmp	3b\n\
 	.previous\n\
@@ -40,7 +46,7 @@
 	.previous"						\
 	: "=&a" (oldval), "=&r" (ret), "+m" (*uaddr),		\
 	  "=&r" (tem)						\
-	: "r" (oparg), "i" (-EFAULT), "1" (0))
+	: "r" (oparg), "i" (-EFAULT), "1" (0), "r" (__USER_DS))
 
 static inline int
 futex_atomic_op_inuser (int encoded_op, int __user *uaddr)
@@ -59,7 +65,7 @@ futex_atomic_op_inuser (int encoded_op, 
 	pagefault_disable();
 
 	if (op == FUTEX_OP_SET)
-		__futex_atomic_op1("xchgl %0, %2", ret, oldval, uaddr, oparg);
+		__futex_atomic_op1("xchgl %0, %%ds:%2", ret, oldval, uaddr, oparg);
 	else {
 #ifndef CONFIG_X86_BSWAP
 		if (boot_cpu_data.x86 == 3)
@@ -68,7 +74,7 @@ futex_atomic_op_inuser (int encoded_op, 
 #endif
 		switch (op) {
 		case FUTEX_OP_ADD:
-			__futex_atomic_op1(LOCK_PREFIX "xaddl %0, %2", ret,
+			__futex_atomic_op1(LOCK_PREFIX "xaddl %0, %%ds:%2", ret,
 					   oldval, uaddr, oparg);
 			break;
 		case FUTEX_OP_OR:
@@ -111,9 +117,11 @@ futex_atomic_cmpxchg_inatomic(int __user
 		return -EFAULT;
 
 	__asm__ __volatile__(
-		"1:	" LOCK_PREFIX "cmpxchgl %3, %1		\n"
-
-		"2:	.section .fixup, \"ax\"			\n"
+		"	movw %w5, %%ds				\n"
+		"1:	" LOCK_PREFIX "cmpxchgl %3, %%ds:%1	\n"
+		"2:	pushl   %%ss				\n"
+		"	popl    %%ds				\n"
+		"	.section .fixup, \"ax\"			\n"
 		"3:	mov     %2, %0				\n"
 		"	jmp     2b				\n"
 		"	.previous				\n"
@@ -124,7 +132,7 @@ futex_atomic_cmpxchg_inatomic(int __user
 		"	.previous				\n"
 
 		: "=a" (oldval), "+m" (*uaddr)
-		: "i" (-EFAULT), "r" (newval), "0" (oldval)
+		: "i" (-EFAULT), "r" (newval), "0" (oldval), "r" (__USER_DS)
 		: "memory"
 	);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/i387.h linux-2.6.20.1-pax/include/asm-i386/i387.h
--- linux-2.6.20.1/include/asm-i386/i387.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/i387.h	2007-02-05 00:56:21.000000000 +0100
@@ -40,13 +40,8 @@ extern void kernel_fpu_begin(void);
 #define kernel_fpu_end() do { stts(); preempt_enable(); } while(0)
 
 /* We need a safe address that is cheap to find and that is already
-   in L1 during context switch. The best choices are unfortunately
-   different for UP and SMP */
-#ifdef CONFIG_SMP
-#define safe_address (__per_cpu_offset[0])
-#else
-#define safe_address (kstat_cpu(0).cpustat.user)
-#endif
+   in L1 during context switch. */
+#define safe_address (init_tss[smp_processor_id()].esp0)
 
 /*
  * These must be called with preempt disabled
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/irqflags.h linux-2.6.20.1-pax/include/asm-i386/irqflags.h
--- linux-2.6.20.1/include/asm-i386/irqflags.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/irqflags.h	2007-02-05 00:56:21.000000000 +0100
@@ -84,6 +84,8 @@ static inline unsigned long __raw_local_
 #define ENABLE_INTERRUPTS_SYSEXIT	sti; sysexit
 #define INTERRUPT_RETURN		iret
 #define GET_CR0_INTO_EAX		movl %cr0, %eax
+#define GET_CR0_INTO_EDX		movl %cr0, %edx
+#define SET_CR0_FROM_EDX		movl %edx, %cr0
 #endif /* __ASSEMBLY__ */
 #endif /* CONFIG_PARAVIRT */
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/kmap_types.h linux-2.6.20.1-pax/include/asm-i386/kmap_types.h
--- linux-2.6.20.1/include/asm-i386/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -22,7 +22,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/mach-default/apm.h linux-2.6.20.1-pax/include/asm-i386/mach-default/apm.h
--- linux-2.6.20.1/include/asm-i386/mach-default/apm.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/mach-default/apm.h	2007-02-05 00:56:21.000000000 +0100
@@ -36,7 +36,7 @@ static inline void apm_bios_call_asm(u32
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		"pushl %%edi\n\t"
 		"pushl %%ebp\n\t"
-		"lcall *%%cs:apm_bios_entry\n\t"
+		"lcall *%%ss:apm_bios_entry\n\t"
 		"setc %%al\n\t"
 		"popl %%ebp\n\t"
 		"popl %%edi\n\t"
@@ -60,7 +60,7 @@ static inline u8 apm_bios_call_simple_as
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		"pushl %%edi\n\t"
 		"pushl %%ebp\n\t"
-		"lcall *%%cs:apm_bios_entry\n\t"
+		"lcall *%%ss:apm_bios_entry\n\t"
 		"setc %%bl\n\t"
 		"popl %%ebp\n\t"
 		"popl %%edi\n\t"
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/mach-default/do_timer.h linux-2.6.20.1-pax/include/asm-i386/mach-default/do_timer.h
--- linux-2.6.20.1/include/asm-i386/mach-default/do_timer.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/mach-default/do_timer.h	2007-02-05 00:56:21.000000000 +0100
@@ -18,7 +18,7 @@ static inline void do_timer_interrupt_ho
 {
 	do_timer(1);
 #ifndef CONFIG_SMP
-	update_process_times(user_mode_vm(get_irq_regs()));
+	update_process_times(user_mode(get_irq_regs()));
 #endif
 /*
  * In the SMP case we use the local APIC timer interrupt to do the
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/mach-voyager/do_timer.h linux-2.6.20.1-pax/include/asm-i386/mach-voyager/do_timer.h
--- linux-2.6.20.1/include/asm-i386/mach-voyager/do_timer.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/mach-voyager/do_timer.h	2007-02-05 00:56:21.000000000 +0100
@@ -5,7 +5,7 @@ static inline void do_timer_interrupt_ho
 {
 	do_timer(1);
 #ifndef CONFIG_SMP
-	update_process_times(user_mode_vm(irq_regs));
+	update_process_times(user_mode(irq_regs));
 #endif
 
 	voyager_timer_interrupt();
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/mman.h linux-2.6.20.1-pax/include/asm-i386/mman.h
--- linux-2.6.20.1/include/asm-i386/mman.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/mman.h	2007-02-05 00:56:21.000000000 +0100
@@ -11,6 +11,10 @@
 #define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
 #define MAP_NONBLOCK	0x10000		/* do not block on IO */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define MAP_MIRROR	0x20000
+#endif
+
 #define MCL_CURRENT	1		/* lock all current mappings */
 #define MCL_FUTURE	2		/* lock all future mappings */
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/mmu.h linux-2.6.20.1-pax/include/asm-i386/mmu.h
--- linux-2.6.20.1/include/asm-i386/mmu.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/mmu.h	2007-02-05 00:56:21.000000000 +0100
@@ -11,8 +11,19 @@
 typedef struct { 
 	int size;
 	struct semaphore sem;
-	void *ldt;
-	void *vdso;
+	struct desc_struct *ldt;
+	unsigned long vdso;
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	unsigned long user_cs_base;
+	unsigned long user_cs_limit;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+	cpumask_t cpu_user_cs_mask;
+#endif
+
+#endif
+
 } mm_context_t;
 
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/mmu_context.h linux-2.6.20.1-pax/include/asm-i386/mmu_context.h
--- linux-2.6.20.1/include/asm-i386/mmu_context.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/mmu_context.h	2007-02-05 00:56:21.000000000 +0100
@@ -45,6 +45,17 @@ static inline void switch_mm(struct mm_s
 		 */
 		if (unlikely(prev->context.ldt != next->context.ldt))
 			load_LDT_nolock(&next->context);
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+		cpu_clear(cpu, prev->context.cpu_user_cs_mask);
+		cpu_set(cpu, next->context.cpu_user_cs_mask);
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		if (unlikely(prev->context.user_cs_base != next->context.user_cs_base ||
+			     prev->context.user_cs_limit != next->context.user_cs_limit))
+#endif
+			set_user_cs(next, cpu);
 	}
 #ifdef CONFIG_SMP
 	else {
@@ -57,6 +68,12 @@ static inline void switch_mm(struct mm_s
 			 */
 			load_cr3(next->pgd);
 			load_LDT_nolock(&next->context);
+
+#ifdef CONFIG_PAX_PAGEEXEC
+			cpu_set(cpu, next->context.cpu_user_cs_mask);
+#endif
+
+			set_user_cs(next, cpu);
 		}
 	}
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/page.h linux-2.6.20.1-pax/include/asm-i386/page.h
--- linux-2.6.20.1/include/asm-i386/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/page.h	2007-02-06 13:28:00.000000000 +0100
@@ -10,6 +10,7 @@
 #define LARGE_PAGE_SIZE (1UL << PMD_SHIFT)
 
 #ifdef __KERNEL__
+#include <asm/boot.h>
 #ifndef __ASSEMBLY__
 
 
@@ -51,14 +52,15 @@ typedef struct { unsigned long long pgpr
 #define pmd_val(x)	((x).pmd)
 #define pte_val(x)	((x).pte_low | ((unsigned long long)(x).pte_high << 32))
 #define __pmd(x) ((pmd_t) { (x) } )
+#define __pte(x) ({ pte_t __pte = {(x), (x) >> 32}; __pte; })
 #define HPAGE_SHIFT	21
 #include <asm-generic/pgtable-nopud.h>
 #else
 typedef struct { unsigned long pte_low; } pte_t;
 typedef struct { unsigned long pgd; } pgd_t;
 typedef struct { unsigned long pgprot; } pgprot_t;
-#define boot_pte_t pte_t /* or would you rather have a typedef */
 #define pte_val(x)	((x).pte_low)
+#define __pte(x) ((pte_t) { (x) } )
 #define HPAGE_SHIFT	22
 #include <asm-generic/pgtable-nopmd.h>
 #endif
@@ -74,7 +76,6 @@ typedef struct { unsigned long pgprot; }
 #define pgd_val(x)	((x).pgd)
 #define pgprot_val(x)	((x).pgprot)
 
-#define __pte(x) ((pte_t) { (x) } )
 #define __pgd(x) ((pgd_t) { (x) } )
 #define __pgprot(x)	((pgprot_t) { (x) } )
 
@@ -118,6 +119,15 @@ extern int page_is_ram(unsigned long pag
 #define __PAGE_OFFSET		((unsigned long)CONFIG_PAGE_OFFSET)
 #endif
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define __KERNEL_TEXT_OFFSET	(__PAGE_OFFSET + ((LOAD_PHYSICAL_ADDR + 4*1024*1024 - 1) & ~(4*1024*1024 - 1)))
+#ifndef __ASSEMBLY__
+extern unsigned char MODULES_VADDR[];
+extern unsigned char MODULES_END[];
+#endif
+#else
+#define __KERNEL_TEXT_OFFSET	(0)
+#endif
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
@@ -140,6 +150,19 @@ extern int page_is_ram(unsigned long pag
 	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
 		 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & (MF_PAX_PAGEEXEC|MF_PAX_SEGMEXEC))?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & (MF_PAX_PAGEEXEC|MF_PAX_SEGMEXEC))?0:VM_EXEC))
+#endif
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define CONFIG_ARCH_TRACK_EXEC_LIMIT 1
+#endif
+
 #include <asm-generic/memory_model.h>
 #include <asm-generic/page.h>
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/paravirt.h linux-2.6.20.1-pax/include/asm-i386/paravirt.h
--- linux-2.6.20.1/include/asm-i386/paravirt.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/paravirt.h	2007-02-18 17:07:43.000000000 +0100
@@ -150,7 +150,7 @@ struct paravirt_ops
  static asmlinkage void (*__paravirtprobe_##fn)(void) __attribute_used__ \
 		__attribute__((__section__(".paravirtprobe"))) = fn
 
-extern struct paravirt_ops paravirt_ops;
+extern const struct paravirt_ops paravirt_ops;
 
 #define paravirt_enabled() (paravirt_ops.paravirt_enabled)
 
@@ -479,7 +479,7 @@ static inline unsigned long __raw_local_
 
 #define INTERRUPT_RETURN				\
 	PARA_PATCH(PARAVIRT_INTERRUPT_RETURN, CLBR_ANY,	\
-	jmp *%cs:paravirt_ops+PARAVIRT_iret)
+	jmp *%ss:paravirt_ops+PARAVIRT_iret)
 
 #define DISABLE_INTERRUPTS(clobbers)			\
 	PARA_PATCH(PARAVIRT_IRQ_DISABLE, clobbers,	\
@@ -490,16 +490,28 @@ static inline unsigned long __raw_local_
 #define ENABLE_INTERRUPTS(clobbers)			\
 	PARA_PATCH(PARAVIRT_IRQ_ENABLE, clobbers,	\
 	pushl %ecx; pushl %edx;				\
-	call *%cs:paravirt_ops+PARAVIRT_irq_enable;	\
+	call *%ss:paravirt_ops+PARAVIRT_irq_enable;	\
 	popl %edx; popl %ecx)
 
 #define ENABLE_INTERRUPTS_SYSEXIT			\
 	PARA_PATCH(PARAVIRT_STI_SYSEXIT, CLBR_ANY,	\
-	jmp *%cs:paravirt_ops+PARAVIRT_irq_enable_sysexit)
+	jmp *%ss:paravirt_ops+PARAVIRT_irq_enable_sysexit)
 
 #define GET_CR0_INTO_EAX			\
 	call *paravirt_ops+PARAVIRT_read_cr0
 
+#define GET_CR0_INTO_EDX			\
+	pushl %eax;				\
+	call *paravirt_ops+PARAVIRT_read_cr0;	\
+	movl %eax, %edx;			\
+	popl %eax
+
+#define SET_CR0_FROM_EDX			\
+	pushl %eax;				\
+	movl %edx, %eax;			\
+	call *paravirt_ops+PARAVIRT_write_cr0;	\
+	popl %eax
+
 #endif /* __ASSEMBLY__ */
 #endif /* CONFIG_PARAVIRT */
 #endif	/* __ASM_PARAVIRT_H */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/pda.h linux-2.6.20.1-pax/include/asm-i386/pda.h
--- linux-2.6.20.1/include/asm-i386/pda.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/pda.h	2007-02-15 01:46:02.000000000 +0100
@@ -11,14 +11,15 @@
 
 struct i386_pda
 {
-	struct i386_pda *_pda;		/* pointer to self */
+	struct i386_pda * const _pda;	/* pointer to self */
 
 	int cpu_number;
 	struct task_struct *pcurrent;	/* current process */
 	struct pt_regs *irq_regs;
 };
 
-extern struct i386_pda *_cpu_pda[];
+extern struct i386_pda *_cpu_pda[NR_CPUS];
+extern struct i386_pda __cpu_pda[NR_CPUS];
 
 #define cpu_pda(i)	(_cpu_pda[i])
 
@@ -33,10 +34,13 @@ extern void __bad_pda_field(void);
    clobbers, so gcc can readily analyse them. */
 extern struct i386_pda _proxy_pda;
 
+#ifdef CONFIG_PAX_KERNEXEC
 #define pda_to_op(op,field,val)						\
 	do {								\
+		unsigned long cr0;					\
 		typedef typeof(_proxy_pda.field) T__;			\
 		if (0) { T__ tmp__; tmp__ = (val); }			\
+		pax_open_kernel(cr0);					\
 		switch (sizeof(_proxy_pda.field)) {			\
 		case 1:							\
 			asm(op "b %1,%%gs:%c2"				\
@@ -58,7 +62,36 @@ extern struct i386_pda _proxy_pda;
 			break;						\
 		default: __bad_pda_field();				\
 		}							\
+		pax_close_kernel(cr0);					\
 	} while (0)
+#else
+#define pda_to_op(op,field,val)						\
+	do {								\
+		typedef typeof(_proxy_pda.field) T__;			\
+		if (0) { T__ tmp__; tmp__ = (val); }			\
+		switch (sizeof(_proxy_pda.field)) {			\
+		case 1:							\
+			asm(op "b %1,%%gs:%c2"				\
+			    : "+m" (_proxy_pda.field)			\
+			    :"ri" ((T__)val),				\
+			     "i"(pda_offset(field)));			\
+			break;						\
+		case 2:							\
+			asm(op "w %1,%%gs:%c2"				\
+			    : "+m" (_proxy_pda.field)			\
+			    :"ri" ((T__)val),				\
+			     "i"(pda_offset(field)));			\
+			break;						\
+		case 4:							\
+			asm(op "l %1,%%gs:%c2"				\
+			    : "+m" (_proxy_pda.field)			\
+			    :"ri" ((T__)val),				\
+			     "i"(pda_offset(field)));			\
+			break;						\
+		default: __bad_pda_field();				\
+		}							\
+	} while (0)
+#endif
 
 #define pda_from_op(op,field)						\
 	({								\
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/pgalloc.h linux-2.6.20.1-pax/include/asm-i386/pgalloc.h
--- linux-2.6.20.1/include/asm-i386/pgalloc.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/pgalloc.h	2007-02-05 00:56:21.000000000 +0100
@@ -2,11 +2,17 @@
 #define _I386_PGALLOC_H
 
 #include <asm/fixmap.h>
+#include <asm/desc.h>
 #include <linux/threads.h>
 #include <linux/mm.h>		/* for struct page */
 
+#ifdef CONFIG_COMPAT_VDSO
 #define pmd_populate_kernel(mm, pmd, pte) \
 		set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
+#else
+#define pmd_populate_kernel(mm, pmd, pte) \
+		set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(pte)))
+#endif
 
 #define pmd_populate(mm, pmd, pte) 				\
 	set_pmd(pmd, __pmd(_PAGE_TABLE +			\
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/pgtable.h linux-2.6.20.1-pax/include/asm-i386/pgtable.h
--- linux-2.6.20.1/include/asm-i386/pgtable.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/pgtable.h	2007-02-05 00:56:21.000000000 +0100
@@ -34,7 +34,6 @@ struct vm_area_struct;
  */
 #define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
 extern unsigned long empty_zero_page[1024];
-extern pgd_t swapper_pg_dir[1024];
 extern struct kmem_cache *pgd_cache;
 extern struct kmem_cache *pmd_cache;
 extern spinlock_t pgd_lock;
@@ -59,6 +58,11 @@ void paging_init(void);
 # include <asm/pgtable-2level-defs.h>
 #endif
 
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+#ifdef CONFIG_X86_PAE
+extern pmd_t swapper_pm_dir[PTRS_PER_PGD][PTRS_PER_PMD];
+#endif
+
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
@@ -68,9 +72,11 @@ void paging_init(void);
 #define USER_PGD_PTRS (PAGE_OFFSET >> PGDIR_SHIFT)
 #define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
 
+#ifndef CONFIG_X86_PAE
 #define TWOLEVEL_PGDIR_SHIFT	22
 #define BOOT_USER_PGD_PTRS (__PAGE_OFFSET >> TWOLEVEL_PGDIR_SHIFT)
 #define BOOT_KERNEL_PGD_PTRS (1024-BOOT_USER_PGD_PTRS)
+#endif
 
 /* Just any arbitrary offset to the start of the vmalloc VM area: the
  * current 8MB value just means that there will be a 8MB "hole" after the
@@ -141,17 +147,26 @@ void paging_init(void);
 
 #define PAGE_SHARED_EXEC \
 	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED)
-#define PAGE_COPY_NOEXEC \
-	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
 #define PAGE_COPY_EXEC \
 	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
-#define PAGE_COPY \
-	PAGE_COPY_NOEXEC
 #define PAGE_READONLY \
 	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
 #define PAGE_READONLY_EXEC \
 	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC \
+	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
+#define PAGE_COPY \
+	PAGE_COPY_NOEXEC
 #define _PAGE_KERNEL \
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_NX)
 #define _PAGE_KERNEL_EXEC \
@@ -176,18 +191,18 @@ extern unsigned long long __PAGE_KERNEL,
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY
+#define __P001	PAGE_READONLY_NOEXEC
+#define __P010	PAGE_COPY_NOEXEC
+#define __P011	PAGE_COPY_NOEXEC
 #define __P100	PAGE_READONLY_EXEC
 #define __P101	PAGE_READONLY_EXEC
 #define __P110	PAGE_COPY_EXEC
 #define __P111	PAGE_COPY_EXEC
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED
+#define __S001	PAGE_READONLY_NOEXEC
+#define __S010	PAGE_SHARED_NOEXEC
+#define __S011	PAGE_SHARED_NOEXEC
 #define __S100	PAGE_READONLY_EXEC
 #define __S101	PAGE_READONLY_EXEC
 #define __S110	PAGE_SHARED_EXEC
@@ -497,6 +512,9 @@ do {									\
 #define update_mmu_cache(vma,address,pte) do { } while (0)
 #endif /* !__ASSEMBLY__ */
 
+#define HAVE_ARCH_UNMAPPED_AREA
+#define HAVE_ARCH_UNMAPPED_AREA_TOPDOWN
+
 #ifdef CONFIG_FLATMEM
 #define kern_addr_valid(addr)	(1)
 #endif /* CONFIG_FLATMEM */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/processor.h linux-2.6.20.1-pax/include/asm-i386/processor.h
--- linux-2.6.20.1/include/asm-i386/processor.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/processor.h	2007-02-15 01:28:25.000000000 +0100
@@ -18,7 +18,6 @@
 #include <asm/system.h>
 #include <linux/cache.h>
 #include <linux/threads.h>
-#include <asm/percpu.h>
 #include <linux/cpumask.h>
 #include <linux/init.h>
 
@@ -99,8 +98,6 @@ struct cpuinfo_x86 {
 
 extern struct cpuinfo_x86 boot_cpu_data;
 extern struct cpuinfo_x86 new_cpu_data;
-extern struct tss_struct doublefault_tss;
-DECLARE_PER_CPU(struct tss_struct, init_tss);
 
 #ifdef CONFIG_SMP
 extern struct cpuinfo_x86 cpu_data[];
@@ -274,10 +271,19 @@ extern int bootloader_type;
  */
 #define TASK_SIZE	(PAGE_OFFSET)
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define SEGMEXEC_TASK_SIZE	((PAGE_OFFSET) / 2)
+#endif
+
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN((current->mm->pax_flags & MF_PAX_SEGMEXEC) ? SEGMEXEC_TASK_SIZE/3 : TASK_SIZE/3))
+#else
 #define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))
+#endif
 
 #define HAVE_ARCH_PICK_MMAP_LAYOUT
 
@@ -393,6 +399,9 @@ struct tss_struct {
 
 #define ARCH_MIN_TASKALIGN	16
 
+extern struct tss_struct doublefault_tss;
+extern struct tss_struct init_tss[NR_CPUS];
+
 struct thread_struct {
 /* cached TLS descriptors. */
 	struct desc_struct tls_array[GDT_ENTRY_TLS_ENTRIES];
@@ -421,6 +430,7 @@ struct thread_struct {
 };
 
 #define INIT_THREAD  {							\
+	.esp0		= sizeof(init_stack) + (long)&init_stack - 8,	\
 	.vm86_info = NULL,						\
 	.sysenter_cs = __KERNEL_CS,					\
 	.io_bitmap_ptr = NULL,						\
@@ -434,7 +444,7 @@ struct thread_struct {
  * be within the limit.
  */
 #define INIT_TSS  {							\
-	.esp0		= sizeof(init_stack) + (long)&init_stack,	\
+	.esp0		= sizeof(init_stack) + (long)&init_stack - 8,	\
 	.ss0		= __KERNEL_DS,					\
 	.ss1		= __KERNEL_CS,					\
 	.io_bitmap_base	= INVALID_IO_BITMAP_OFFSET,			\
@@ -474,11 +484,7 @@ void show_trace(struct task_struct *task
 unsigned long get_wchan(struct task_struct *p);
 
 #define THREAD_SIZE_LONGS      (THREAD_SIZE/sizeof(unsigned long))
-#define KSTK_TOP(info)                                                 \
-({                                                                     \
-       unsigned long *__ptr = (unsigned long *)(info);                 \
-       (unsigned long)(&__ptr[THREAD_SIZE_LONGS]);                     \
-})
+#define KSTK_TOP(info)         ((info)->task.thread.esp0)
 
 /*
  * The below -8 is to reserve 8 bytes on top of the ring0 stack.
@@ -493,7 +499,7 @@ unsigned long get_wchan(struct task_stru
 #define task_pt_regs(task)                                             \
 ({                                                                     \
        struct pt_regs *__regs__;                                       \
-       __regs__ = (struct pt_regs *)(KSTK_TOP(task_stack_page(task))-8); \
+       __regs__ = (struct pt_regs *)((task)->thread.esp0);             \
        __regs__ - 1;                                                   \
 })
 
@@ -742,7 +748,7 @@ extern unsigned long boot_option_idle_ov
 extern void enable_sep_cpu(void);
 extern int sysenter_setup(void);
 
-extern int init_gdt(int cpu, struct task_struct *idle);
+extern void init_gdt(int cpu, struct task_struct *idle);
 extern void cpu_set_gdt(int);
 extern void secondary_cpu_init(void);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/ptrace.h linux-2.6.20.1-pax/include/asm-i386/ptrace.h
--- linux-2.6.20.1/include/asm-i386/ptrace.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/ptrace.h	2007-02-05 00:56:21.000000000 +0100
@@ -35,17 +35,18 @@ struct task_struct;
 extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code);
 
 /*
- * user_mode_vm(regs) determines whether a register set came from user mode.
+ * user_mode(regs) determines whether a register set came from user mode.
  * This is true if V8086 mode was enabled OR if the register set was from
  * protected mode with RPL-3 CS value.  This tricky test checks that with
  * one comparison.  Many places in the kernel can bypass this full check
- * if they have already ruled out V8086 mode, so user_mode(regs) can be used.
+ * if they have already ruled out V8086 mode, so user_mode_novm(regs) can
+ * be used.
  */
-static inline int user_mode(struct pt_regs *regs)
+static inline int user_mode_novm(struct pt_regs *regs)
 {
 	return (regs->xcs & SEGMENT_RPL_MASK) == USER_RPL;
 }
-static inline int user_mode_vm(struct pt_regs *regs)
+static inline int user_mode(struct pt_regs *regs)
 {
 	return ((regs->xcs & SEGMENT_RPL_MASK) | (regs->eflags & VM_MASK)) >= USER_RPL;
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/segment.h linux-2.6.20.1-pax/include/asm-i386/segment.h
--- linux-2.6.20.1/include/asm-i386/segment.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/segment.h	2007-02-05 00:56:21.000000000 +0100
@@ -87,9 +87,9 @@
 #define GDT_SIZE (GDT_ENTRIES * 8)
 
 /* Matches __KERNEL_CS and __USER_CS (they must be 2 entries apart) */
-#define SEGMENT_IS_FLAT_CODE(x)  (((x) & 0xec) == GDT_ENTRY_KERNEL_CS * 8)
+#define SEGMENT_IS_FLAT_CODE(x)  (((x) & 0xFFFCU) == __KERNEL_CS || ((x) & 0xFFFCU) == __USER_CS)
 /* Matches PNP_CS32 and PNP_CS16 (they must be consecutive) */
-#define SEGMENT_IS_PNP_CODE(x)   (((x) & 0xf4) == GDT_ENTRY_PNPBIOS_BASE * 8)
+#define SEGMENT_IS_PNP_CODE(x)   (((x) & 0xFFFCU) == PNP_CS32 || ((x) & 0xFFFCU) == PNP_CS16)
 
 /* Simple and small GDT entries for booting only */
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/serial.h linux-2.6.20.1-pax/include/asm-i386/serial.h
--- linux-2.6.20.1/include/asm-i386/serial.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/serial.h	2007-02-16 00:02:21.000000000 +0100
@@ -23,7 +23,7 @@
 
 #define SERIAL_PORT_DFNS			\
 	/* UART CLK   PORT IRQ     FLAGS        */			\
-	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS },	/* ttyS0 */	\
-	{ 0, BASE_BAUD, 0x2F8, 3, STD_COM_FLAGS },	/* ttyS1 */	\
-	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
-	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
+	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS, 0 ,0, NULL, 0 },	/* ttyS0 */	\
+	{ 0, BASE_BAUD, 0x2F8, 3, STD_COM_FLAGS, 0 ,0, NULL, 0 },	/* ttyS1 */	\
+	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS, 0 ,0, NULL, 0 },	/* ttyS2 */	\
+	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS, 0 ,0, NULL, 0 },	/* ttyS3 */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/system.h linux-2.6.20.1-pax/include/asm-i386/system.h
--- linux-2.6.20.1/include/asm-i386/system.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/system.h	2007-02-19 03:04:28.000000000 +0100
@@ -152,6 +152,21 @@ __asm__ __volatile__ ("movw %%dx,%1\n\t"
 /* Set the 'TS' bit */
 #define stts() write_cr0(8 | read_cr0())
 
+#define pax_open_kernel(cr0)		\
+do {					\
+	typecheck(unsigned long,cr0);	\
+	preempt_disable();		\
+	cr0 = read_cr0();		\
+	write_cr0(cr0 & ~0x10000UL);	\
+} while(0)
+
+#define pax_close_kernel(cr0)		\
+do {					\
+	typecheck(unsigned long,cr0);	\
+	write_cr0(cr0);			\
+	preempt_enable_no_resched();	\
+} while(0)
+
 #endif	/* __KERNEL__ */
 
 static inline unsigned long get_limit(unsigned long segment)
@@ -159,7 +174,7 @@ static inline unsigned long get_limit(un
 	unsigned long __limit;
 	__asm__("lsll %1,%0"
 		:"=r" (__limit):"r" (segment));
-	return __limit+1;
+	return __limit;
 }
 
 #define nop() __asm__ __volatile__ ("nop")
@@ -520,7 +535,7 @@ static inline void sched_cacheflush(void
 	wbinvd();
 }
 
-extern unsigned long arch_align_stack(unsigned long sp);
+#define arch_align_stack(x) (x)
 extern void free_init_pages(char *what, unsigned long begin, unsigned long end);
 
 void default_idle(void);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-i386/uaccess.h linux-2.6.20.1-pax/include/asm-i386/uaccess.h
--- linux-2.6.20.1/include/asm-i386/uaccess.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-i386/uaccess.h	2007-02-05 00:56:21.000000000 +0100
@@ -9,6 +9,8 @@
 #include <linux/prefetch.h>
 #include <linux/string.h>
 #include <asm/page.h>
+#include <asm/segment.h>
+#include <asm/desc.h>
 
 #define VERIFY_READ 0
 #define VERIFY_WRITE 1
@@ -29,7 +31,8 @@
 
 #define get_ds()	(KERNEL_DS)
 #define get_fs()	(current_thread_info()->addr_limit)
-#define set_fs(x)	(current_thread_info()->addr_limit = (x))
+void __set_fs(mm_segment_t x, int cpu);
+void set_fs(mm_segment_t x);
 
 #define segment_eq(a,b)	((a).seg == (b).seg)
 
@@ -280,9 +283,12 @@ extern void __put_user_8(void);
 
 #define __put_user_u64(x, addr, err)				\
 	__asm__ __volatile__(					\
-		"1:	movl %%eax,0(%2)\n"			\
-		"2:	movl %%edx,4(%2)\n"			\
+		"	movw %w5,%%ds\n"			\
+		"1:	movl %%eax,%%ds:0(%2)\n"		\
+		"2:	movl %%edx,%%ds:4(%2)\n"		\
 		"3:\n"						\
+		"	pushl %%ss\n"				\
+		"	popl %%ds\n"				\
 		".section .fixup,\"ax\"\n"			\
 		"4:	movl %3,%0\n"				\
 		"	jmp 3b\n"				\
@@ -293,7 +299,8 @@ extern void __put_user_8(void);
 		"	.long 2b,4b\n"				\
 		".previous"					\
 		: "=r"(err)					\
-		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err))
+		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err),	\
+		  "r"(__USER_DS))
 
 #ifdef CONFIG_X86_WP_WORKS_OK
 
@@ -332,8 +339,11 @@ struct __large_struct { unsigned long bu
  */
 #define __put_user_asm(x, addr, err, itype, rtype, ltype, errret)	\
 	__asm__ __volatile__(						\
-		"1:	mov"itype" %"rtype"1,%2\n"			\
+		"	movw %w5,%%ds\n"				\
+		"1:	mov"itype" %"rtype"1,%%ds:%2\n"			\
 		"2:\n"							\
+		"	pushl %%ss\n"					\
+		"	popl %%ds\n"					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	movl %3,%0\n"					\
 		"	jmp 2b\n"					\
@@ -343,7 +353,8 @@ struct __large_struct { unsigned long bu
 		"	.long 1b,3b\n"					\
 		".previous"						\
 		: "=r"(err)						\
-		: ltype (x), "m"(__m(addr)), "i"(errret), "0"(err))
+		: ltype (x), "m"(__m(addr)), "i"(errret), "0"(err),	\
+		  "r"(__USER_DS))
 
 
 #define __get_user_nocheck(x,ptr,size)				\
@@ -371,8 +382,11 @@ do {									\
 
 #define __get_user_asm(x, addr, err, itype, rtype, ltype, errret)	\
 	__asm__ __volatile__(						\
-		"1:	mov"itype" %2,%"rtype"1\n"			\
+		"	movw %w5,%%ds\n"				\
+		"1:	mov"itype" %%ds:%2,%"rtype"1\n"			\
 		"2:\n"							\
+		"	pushl %%ss\n"					\
+		"	popl %%ds\n"					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	movl %3,%0\n"					\
 		"	xor"itype" %"rtype"1,%"rtype"1\n"		\
@@ -383,7 +397,7 @@ do {									\
 		"	.long 1b,3b\n"					\
 		".previous"						\
 		: "=r"(err), ltype (x)					\
-		: "m"(__m(addr)), "i"(errret), "0"(err))
+		: "m"(__m(addr)), "i"(errret), "0"(err), "r"(__USER_DS))
 
 
 unsigned long __must_check __copy_to_user_ll(void __user *to,
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ia64/elf.h linux-2.6.20.1-pax/include/asm-ia64/elf.h
--- linux-2.6.20.1/include/asm-ia64/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ia64/elf.h	2007-02-05 00:56:21.000000000 +0100
@@ -162,6 +162,16 @@ typedef elf_greg_t elf_gregset_t[ELF_NGR
 typedef struct ia64_fpreg elf_fpreg_t;
 typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	((tsk)->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#endif
 
 
 struct pt_regs;	/* forward declaration... */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ia64/kmap_types.h linux-2.6.20.1-pax/include/asm-ia64/kmap_types.h
--- linux-2.6.20.1/include/asm-ia64/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ia64/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -22,7 +22,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ia64/page.h linux-2.6.20.1-pax/include/asm-ia64/page.h
--- linux-2.6.20.1/include/asm-ia64/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ia64/page.h	2007-02-05 00:56:21.000000000 +0100
@@ -226,5 +226,14 @@ get_order (unsigned long size)
 					 (((current->personality & READ_IMPLIES_EXEC) != 0)	\
 					  ? VM_EXEC : 0))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 # endif /* __KERNEL__ */
 #endif /* _ASM_IA64_PAGE_H */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ia64/pgtable.h linux-2.6.20.1-pax/include/asm-ia64/pgtable.h
--- linux-2.6.20.1/include/asm-ia64/pgtable.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ia64/pgtable.h	2007-02-05 00:56:21.000000000 +0100
@@ -143,6 +143,17 @@
 #define PAGE_READONLY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
 #define PAGE_COPY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
 #define PAGE_COPY_EXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RX)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RW)
+# define PAGE_READONLY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+# define PAGE_COPY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+#endif
+
 #define PAGE_GATE	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_X_RX)
 #define PAGE_KERNEL	__pgprot(__DIRTY_BITS  | _PAGE_PL_0 | _PAGE_AR_RWX)
 #define PAGE_KERNELRX	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_RX)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ia64/processor.h linux-2.6.20.1-pax/include/asm-ia64/processor.h
--- linux-2.6.20.1/include/asm-ia64/processor.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ia64/processor.h	2007-02-05 00:56:21.000000000 +0100
@@ -274,7 +274,7 @@ struct thread_struct {
 	.on_ustack =	0,					\
 	.ksp =		0,					\
 	.map_base =	DEFAULT_MAP_BASE,			\
-	.rbs_bot =	STACK_TOP - DEFAULT_USER_STACK_SIZE,	\
+	.rbs_bot =	__STACK_TOP - DEFAULT_USER_STACK_SIZE,	\
 	.task_size =	DEFAULT_TASK_SIZE,			\
 	.last_fph_cpu =  -1,					\
 	INIT_THREAD_IA32					\
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ia64/ustack.h linux-2.6.20.1-pax/include/asm-ia64/ustack.h
--- linux-2.6.20.1/include/asm-ia64/ustack.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ia64/ustack.h	2007-02-05 00:56:21.000000000 +0100
@@ -10,10 +10,10 @@
 
 /* The absolute hard limit for stack size is 1/2 of the mappable space in the region */
 #define MAX_USER_STACK_SIZE	(RGN_MAP_LIMIT/2)
-#define STACK_TOP		(0x6000000000000000UL + RGN_MAP_LIMIT)
+#define __STACK_TOP		(0x6000000000000000UL + RGN_MAP_LIMIT)
 #endif
 
-/* Make a default stack size of 2GiB */
+/* Make a default stack size of 2GB */
 #define DEFAULT_USER_STACK_SIZE	(1UL << 31)
 
 #endif /* _ASM_IA64_USTACK_H */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-m32r/kmap_types.h linux-2.6.20.1-pax/include/asm-m32r/kmap_types.h
--- linux-2.6.20.1/include/asm-m32r/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-m32r/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -24,7 +24,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-m68k/kmap_types.h linux-2.6.20.1-pax/include/asm-m68k/kmap_types.h
--- linux-2.6.20.1/include/asm-m68k/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-m68k/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -15,6 +15,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-m68knommu/kmap_types.h linux-2.6.20.1-pax/include/asm-m68knommu/kmap_types.h
--- linux-2.6.20.1/include/asm-m68knommu/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-m68knommu/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -15,6 +15,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-mips/a.out.h linux-2.6.20.1-pax/include/asm-mips/a.out.h
--- linux-2.6.20.1/include/asm-mips/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-mips/a.out.h	2007-02-05 00:56:21.000000000 +0100
@@ -35,10 +35,10 @@ struct exec
 #ifdef __KERNEL__
 
 #ifdef CONFIG_32BIT
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 #endif
 #ifdef CONFIG_64BIT
-#define STACK_TOP	(current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
+#define __STACK_TOP	(current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
 #endif
 
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-mips/elf.h linux-2.6.20.1-pax/include/asm-mips/elf.h
--- linux-2.6.20.1/include/asm-mips/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-mips/elf.h	2007-02-05 00:56:21.000000000 +0100
@@ -371,4 +371,15 @@ extern int dump_task_fpu(struct task_str
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #endif /* _ASM_ELF_H */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-mips/kmap_types.h linux-2.6.20.1-pax/include/asm-mips/kmap_types.h
--- linux-2.6.20.1/include/asm-mips/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-mips/kmap_types.h	2007-02-05 00:56:21.000000000 +0100
@@ -22,7 +22,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-mips/page.h linux-2.6.20.1-pax/include/asm-mips/page.h
--- linux-2.6.20.1/include/asm-mips/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-mips/page.h	2007-02-05 00:56:22.000000000 +0100
@@ -75,7 +75,7 @@ extern void copy_user_highpage(struct pa
   #ifdef CONFIG_CPU_MIPS32
     typedef struct { unsigned long pte_low, pte_high; } pte_t;
     #define pte_val(x)    ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
-    #define __pte(x)      ({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
+    #define __pte(x)      ({ pte_t __pte = {(x), (x) >> 32}; __pte; })
   #else
      typedef struct { unsigned long long pte; } pte_t;
      #define pte_val(x)	((x).pte)
@@ -170,6 +170,15 @@ typedef struct { unsigned long pgprot; }
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
 #define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-parisc/a.out.h linux-2.6.20.1-pax/include/asm-parisc/a.out.h
--- linux-2.6.20.1/include/asm-parisc/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-parisc/a.out.h	2007-02-05 00:56:22.000000000 +0100
@@ -22,7 +22,7 @@ struct exec
 /* XXX: STACK_TOP actually should be STACK_BOTTOM for parisc.
  * prumpf */
 
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-parisc/elf.h linux-2.6.20.1-pax/include/asm-parisc/elf.h
--- linux-2.6.20.1/include/asm-parisc/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-parisc/elf.h	2007-02-05 00:56:22.000000000 +0100
@@ -337,6 +337,17 @@ struct pt_regs;	/* forward declaration..
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE + 0x01000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x10000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		16
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		16
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
    but it's not easy, and we've already done it here.  */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-parisc/kmap_types.h linux-2.6.20.1-pax/include/asm-parisc/kmap_types.h
--- linux-2.6.20.1/include/asm-parisc/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-parisc/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -22,7 +22,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-parisc/page.h linux-2.6.20.1-pax/include/asm-parisc/page.h
--- linux-2.6.20.1/include/asm-parisc/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-parisc/page.h	2007-02-05 00:56:22.000000000 +0100
@@ -166,6 +166,15 @@ extern int npmem_ranges;
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #include <asm-generic/memory_model.h>
 #include <asm-generic/page.h>
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-parisc/pgtable.h linux-2.6.20.1-pax/include/asm-parisc/pgtable.h
--- linux-2.6.20.1/include/asm-parisc/pgtable.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-parisc/pgtable.h	2007-02-05 00:56:22.000000000 +0100
@@ -219,6 +219,17 @@ extern  void *vmalloc_start;
 #define PAGE_EXECREAD   __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_EXEC |_PAGE_ACCESSED)
 #define PAGE_COPY       PAGE_EXECREAD
 #define PAGE_RWX        __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_EXEC |_PAGE_ACCESSED)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_RO	__pgprot(_PAGE_KERNEL & ~_PAGE_WRITE)
 #define PAGE_KERNEL_UNC	__pgprot(_PAGE_KERNEL | _PAGE_NO_CACHE)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-powerpc/a.out.h linux-2.6.20.1-pax/include/asm-powerpc/a.out.h
--- linux-2.6.20.1/include/asm-powerpc/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-powerpc/a.out.h	2007-02-05 00:56:22.000000000 +0100
@@ -23,12 +23,12 @@ struct exec
 #define STACK_TOP_USER64 TASK_SIZE_USER64
 #define STACK_TOP_USER32 TASK_SIZE_USER32
 
-#define STACK_TOP (test_thread_flag(TIF_32BIT) ? \
+#define __STACK_TOP (test_thread_flag(TIF_32BIT) ? \
 		   STACK_TOP_USER32 : STACK_TOP_USER64)
 
 #else /* __powerpc64__ */
 
-#define STACK_TOP TASK_SIZE
+#define __STACK_TOP TASK_SIZE
 
 #endif /* __powerpc64__ */
 #endif /* __KERNEL__ */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-powerpc/elf.h linux-2.6.20.1-pax/include/asm-powerpc/elf.h
--- linux-2.6.20.1/include/asm-powerpc/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-powerpc/elf.h	2007-02-05 00:56:22.000000000 +0100
@@ -159,6 +159,26 @@ typedef elf_vrreg_t elf_vrregset_t[ELF_N
 typedef elf_vrreg_t elf_vrregset_t32[ELF_NVRREG32];
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(0x10000000UL)
+
+#ifdef __powerpc64__
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(test_thread_flag(TIF_32BIT) ? 16 : 28)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(test_thread_flag(TIF_32BIT) ? 16 : 28)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(test_thread_flag(TIF_32BIT) ? 16 : 28)
+#else
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		15
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		15
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	15
+#endif
+#endif
+
 #ifdef __KERNEL__
 /*
  * This is used to ensure we don't load something for the wrong architecture.
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-powerpc/kmap_types.h linux-2.6.20.1-pax/include/asm-powerpc/kmap_types.h
--- linux-2.6.20.1/include/asm-powerpc/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-powerpc/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -26,6 +26,7 @@ enum km_type {
 	KM_SOFTIRQ1,
 	KM_PPC_SYNC_PAGE,
 	KM_PPC_SYNC_ICACHE,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-powerpc/page.h linux-2.6.20.1-pax/include/asm-powerpc/page.h
--- linux-2.6.20.1/include/asm-powerpc/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-powerpc/page.h	2007-02-05 00:56:22.000000000 +0100
@@ -71,8 +71,9 @@
  * and needs to be executable.  This means the whole heap ends
  * up being executable.
  */
-#define VM_DATA_DEFAULT_FLAGS32	(VM_READ | VM_WRITE | VM_EXEC | \
-				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#define VM_DATA_DEFAULT_FLAGS32 \
+	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
+	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
 #define VM_DATA_DEFAULT_FLAGS64	(VM_READ | VM_WRITE | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
@@ -83,6 +84,15 @@
 #include <asm/page_32.h>
 #endif
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 /* align addr on a size boundary - adjust address up/down if needed */
 #define _ALIGN_UP(addr,size)	(((addr)+((size)-1))&(~((size)-1)))
 #define _ALIGN_DOWN(addr,size)	((addr)&(~((size)-1)))
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-powerpc/page_64.h linux-2.6.20.1-pax/include/asm-powerpc/page_64.h
--- linux-2.6.20.1/include/asm-powerpc/page_64.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-powerpc/page_64.h	2007-02-05 00:56:22.000000000 +0100
@@ -160,15 +160,18 @@ extern unsigned int HPAGE_SHIFT;
  * stack by default, so in the absense of a PT_GNU_STACK program header
  * we turn execute permission off.
  */
-#define VM_STACK_DEFAULT_FLAGS32	(VM_READ | VM_WRITE | VM_EXEC | \
-					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#define VM_STACK_DEFAULT_FLAGS32 \
+	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
+	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
 #define VM_STACK_DEFAULT_FLAGS64	(VM_READ | VM_WRITE | \
 					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifndef CONFIG_PAX_PAGEEXEC
 #define VM_STACK_DEFAULT_FLAGS \
 	(test_thread_flag(TIF_32BIT) ? \
 	 VM_STACK_DEFAULT_FLAGS32 : VM_STACK_DEFAULT_FLAGS64)
+#endif
 
 #include <asm-generic/page.h>
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ppc/mmu_context.h linux-2.6.20.1-pax/include/asm-ppc/mmu_context.h
--- linux-2.6.20.1/include/asm-ppc/mmu_context.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ppc/mmu_context.h	2007-02-05 00:56:22.000000000 +0100
@@ -144,7 +144,8 @@ static inline void get_mmu_context(struc
 static inline int init_new_context(struct task_struct *t, struct mm_struct *mm)
 {
 	mm->context.id = NO_CONTEXT;
-	mm->context.vdso_base = 0;
+	if (t == current)
+		mm->context.vdso_base = ~0UL;
 	return 0;
 }
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ppc/page.h linux-2.6.20.1-pax/include/asm-ppc/page.h
--- linux-2.6.20.1/include/asm-ppc/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ppc/page.h	2007-02-05 00:56:22.000000000 +0100
@@ -173,6 +173,15 @@ extern __inline__ int get_order(unsigned
 /* We do define AT_SYSINFO_EHDR but don't use the gate mechanism */
 #define __HAVE_ARCH_GATE_AREA		1
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #include <asm-generic/memory_model.h>
 #endif /* __KERNEL__ */
 #endif /* _PPC_PAGE_H */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-ppc/pgtable.h linux-2.6.20.1-pax/include/asm-ppc/pgtable.h
--- linux-2.6.20.1/include/asm-ppc/pgtable.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-ppc/pgtable.h	2007-02-05 00:56:22.000000000 +0100
@@ -440,11 +440,21 @@ extern unsigned long ioremap_bot, iorema
 
 #define PAGE_NONE	__pgprot(_PAGE_BASE)
 #define PAGE_READONLY	__pgprot(_PAGE_BASE | _PAGE_USER)
-#define PAGE_READONLY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC)
+#define PAGE_READONLY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC | _PAGE_HWEXEC)
 #define PAGE_SHARED	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW)
-#define PAGE_SHARED_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_EXEC)
+#define PAGE_SHARED_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_EXEC | _PAGE_HWEXEC)
 #define PAGE_COPY	__pgprot(_PAGE_BASE | _PAGE_USER)
-#define PAGE_COPY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC)
+#define PAGE_COPY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC | _PAGE_HWEXEC)
+
+#if defined(CONFIG_PAX_PAGEEXEC) && !defined(CONFIG_40x) && !defined(CONFIG_44x)
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_GUARDED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_GUARDED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_GUARDED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
 
 #define PAGE_KERNEL		__pgprot(_PAGE_RAM)
 #define PAGE_KERNEL_NOCACHE	__pgprot(_PAGE_IO)
@@ -456,21 +466,21 @@ extern unsigned long ioremap_bot, iorema
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY_X
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY_X
-#define __P100	PAGE_READONLY
+#define __P001	PAGE_READONLY_NOEXEC
+#define __P010	PAGE_COPY_NOEXEC
+#define __P011	PAGE_COPY_NOEXEC
+#define __P100	PAGE_READONLY_X
 #define __P101	PAGE_READONLY_X
-#define __P110	PAGE_COPY
+#define __P110	PAGE_COPY_X
 #define __P111	PAGE_COPY_X
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY_X
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED_X
-#define __S100	PAGE_READONLY
+#define __S001	PAGE_READONLY_NOEXEC
+#define __S010	PAGE_SHARED_NOEXEC
+#define __S011	PAGE_SHARED_NOEXEC
+#define __S100	PAGE_READONLY_X
 #define __S101	PAGE_READONLY_X
-#define __S110	PAGE_SHARED
+#define __S110	PAGE_SHARED_X
 #define __S111	PAGE_SHARED_X
 
 #ifndef __ASSEMBLY__
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-s390/kmap_types.h linux-2.6.20.1-pax/include/asm-s390/kmap_types.h
--- linux-2.6.20.1/include/asm-s390/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-s390/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -16,6 +16,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,	
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sh/kmap_types.h linux-2.6.20.1-pax/include/asm-sh/kmap_types.h
--- linux-2.6.20.1/include/asm-sh/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sh/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -24,7 +24,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc/a.out.h linux-2.6.20.1-pax/include/asm-sparc/a.out.h
--- linux-2.6.20.1/include/asm-sparc/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc/a.out.h	2007-02-05 00:56:22.000000000 +0100
@@ -91,7 +91,7 @@ struct relocation_info /* used when head
 
 #include <asm/page.h>
 
-#define STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
+#define __STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
 
 #endif /* __KERNEL__ */
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc/elf.h linux-2.6.20.1-pax/include/asm-sparc/elf.h
--- linux-2.6.20.1/include/asm-sparc/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc/elf.h	2007-02-05 00:56:22.000000000 +0100
@@ -143,6 +143,17 @@ do {	unsigned long *dest = &(__elf_regs[
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x10000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		16
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		16
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  This can NOT be done in userspace
    on Sparc.  */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc/kmap_types.h linux-2.6.20.1-pax/include/asm-sparc/kmap_types.h
--- linux-2.6.20.1/include/asm-sparc/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -15,6 +15,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc/page.h linux-2.6.20.1-pax/include/asm-sparc/page.h
--- linux-2.6.20.1/include/asm-sparc/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc/page.h	2007-02-05 00:56:22.000000000 +0100
@@ -160,6 +160,15 @@ extern unsigned long pfn_base;
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			 ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #include <asm-generic/memory_model.h>
 #include <asm-generic/page.h>
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc/pgtable.h linux-2.6.20.1-pax/include/asm-sparc/pgtable.h
--- linux-2.6.20.1/include/asm-sparc/pgtable.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc/pgtable.h	2007-02-05 00:56:22.000000000 +0100
@@ -49,6 +49,13 @@ BTFIXUPDEF_INT(page_none)
 BTFIXUPDEF_INT(page_shared)
 BTFIXUPDEF_INT(page_copy)
 BTFIXUPDEF_INT(page_readonly)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+BTFIXUPDEF_INT(page_shared_noexec)
+BTFIXUPDEF_INT(page_copy_noexec)
+BTFIXUPDEF_INT(page_readonly_noexec)
+#endif
+
 BTFIXUPDEF_INT(page_kernel)
 
 #define PMD_SHIFT		SUN4C_PMD_SHIFT
@@ -70,6 +77,16 @@ BTFIXUPDEF_INT(page_kernel)
 #define PAGE_COPY      __pgprot(BTFIXUP_INT(page_copy))
 #define PAGE_READONLY  __pgprot(BTFIXUP_INT(page_readonly))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(BTFIXUP_INT(page_shared_noexec))
+# define PAGE_COPY_NOEXEC	__pgprot(BTFIXUP_INT(page_copy_noexec))
+# define PAGE_READONLY_NOEXEC	__pgprot(BTFIXUP_INT(page_readonly_noexec))
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 extern unsigned long page_kernel;
 
 #ifdef MODULE
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc/pgtsrmmu.h linux-2.6.20.1-pax/include/asm-sparc/pgtsrmmu.h
--- linux-2.6.20.1/include/asm-sparc/pgtsrmmu.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc/pgtsrmmu.h	2007-02-05 00:56:22.000000000 +0100
@@ -115,6 +115,16 @@
 				    SRMMU_EXEC | SRMMU_REF)
 #define SRMMU_PAGE_RDONLY  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
 				    SRMMU_EXEC | SRMMU_REF)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define SRMMU_PAGE_SHARED_NOEXEC  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_WRITE | SRMMU_REF)
+#define SRMMU_PAGE_COPY_NOEXEC    __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_REF)
+#define SRMMU_PAGE_RDONLY_NOEXEC  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_REF)
+#endif
+
 #define SRMMU_PAGE_KERNEL  __pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_PRIV | \
 				    SRMMU_DIRTY | SRMMU_REF)
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc/uaccess.h linux-2.6.20.1-pax/include/asm-sparc/uaccess.h
--- linux-2.6.20.1/include/asm-sparc/uaccess.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc/uaccess.h	2007-02-05 00:56:22.000000000 +0100
@@ -41,7 +41,7 @@
  * No one can read/write anything from userland in the kernel space by setting
  * large size and address near to PAGE_OFFSET - a fault will break his intentions.
  */
-#define __user_ok(addr, size) ({ (void)(size); (addr) < STACK_TOP; })
+#define __user_ok(addr, size) ({ (void)(size); (addr) < __STACK_TOP; })
 #define __kernel_ok (segment_eq(get_fs(), KERNEL_DS))
 #define __access_ok(addr,size) (__user_ok((addr) & get_fs().seg,(size)))
 #define access_ok(type, addr, size)					\
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc64/a.out.h linux-2.6.20.1-pax/include/asm-sparc64/a.out.h
--- linux-2.6.20.1/include/asm-sparc64/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc64/a.out.h	2007-02-05 00:56:22.000000000 +0100
@@ -98,7 +98,7 @@ struct relocation_info /* used when head
 #define STACK_TOP32	((1UL << 32UL) - PAGE_SIZE)
 #define STACK_TOP64	(0x0000080000000000UL - (1UL << 32UL))
 
-#define STACK_TOP (test_thread_flag(TIF_32BIT) ? \
+#define __STACK_TOP (test_thread_flag(TIF_32BIT) ? \
 		   STACK_TOP32 : STACK_TOP64)
 
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc64/elf.h linux-2.6.20.1-pax/include/asm-sparc64/elf.h
--- linux-2.6.20.1/include/asm-sparc64/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc64/elf.h	2007-02-05 00:56:22.000000000 +0100
@@ -142,6 +142,16 @@ typedef struct {
 #define ELF_ET_DYN_BASE         0x0000010000000000UL
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(test_thread_flag(TIF_32BIT) ? 0x10000UL : 0x100000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		(PAGE_SHIFT + 1)
+#define PAX_DELTA_MMAP_LEN(tsk)		(test_thread_flag(TIF_32BIT) ? 14 : 28 )
+#define PAX_DELTA_EXEC_LSB(tsk)		(PAGE_SHIFT + 1)
+#define PAX_DELTA_EXEC_LEN(tsk)		(test_thread_flag(TIF_32BIT) ? 14 : 28 )
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(test_thread_flag(TIF_32BIT) ? 15 : 29 )
+#endif
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc64/kmap_types.h linux-2.6.20.1-pax/include/asm-sparc64/kmap_types.h
--- linux-2.6.20.1/include/asm-sparc64/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc64/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -19,6 +19,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-sparc64/page.h linux-2.6.20.1-pax/include/asm-sparc64/page.h
--- linux-2.6.20.1/include/asm-sparc64/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-sparc64/page.h	2007-02-05 00:56:22.000000000 +0100
@@ -141,6 +141,15 @@ typedef unsigned long pgprot_t;
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #include <asm-generic/page.h>
 
 #endif /* __KERNEL__ */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-v850/kmap_types.h linux-2.6.20.1-pax/include/asm-v850/kmap_types.h
--- linux-2.6.20.1/include/asm-v850/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-v850/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -13,6 +13,7 @@ enum km_type {
 	KM_PTE1,
 	KM_IRQ0,
 	KM_IRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-x86_64/a.out.h linux-2.6.20.1-pax/include/asm-x86_64/a.out.h
--- linux-2.6.20.1/include/asm-x86_64/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-x86_64/a.out.h	2007-02-05 00:56:22.000000000 +0100
@@ -21,7 +21,7 @@ struct exec
 
 #ifdef __KERNEL__
 #include <linux/thread_info.h>
-#define STACK_TOP TASK_SIZE
+#define __STACK_TOP TASK_SIZE
 #endif
 
 #endif /* __A_OUT_GNU_H__ */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-x86_64/elf.h linux-2.6.20.1-pax/include/asm-x86_64/elf.h
--- linux-2.6.20.1/include/asm-x86_64/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-x86_64/elf.h	2007-02-05 00:56:22.000000000 +0100
@@ -92,6 +92,17 @@ typedef struct user_i387_struct elf_fpre
 
 #define ELF_ET_DYN_BASE         (2 * TASK_SIZE / 3)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(test_thread_flag(TIF_IA32) ? 0x08048000UL : 0x400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(test_thread_flag(TIF_IA32) ? 16 : 32)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(test_thread_flag(TIF_IA32) ? 16 : 32)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(test_thread_flag(TIF_IA32) ? 16 : 32)
+#endif
+
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different). Assumes current is the process
    getting dumped. */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-x86_64/ia32.h linux-2.6.20.1-pax/include/asm-x86_64/ia32.h
--- linux-2.6.20.1/include/asm-x86_64/ia32.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-x86_64/ia32.h	2007-02-05 00:56:22.000000000 +0100
@@ -156,7 +156,13 @@ struct ustat32 {
 	char			f_fpack[6];
 };
 
-#define IA32_STACK_TOP IA32_PAGE_OFFSET
+#ifdef CONFIG_PAX_RANDUSTACK
+#define IA32_DELTA_STACK (current->mm->delta_stack)
+#else
+#define IA32_DELTA_STACK 0UL
+#endif
+
+#define IA32_STACK_TOP (IA32_PAGE_OFFSET - IA32_DELTA_STACK)
 
 #ifdef __KERNEL__
 struct user_desc;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-x86_64/kmap_types.h linux-2.6.20.1-pax/include/asm-x86_64/kmap_types.h
--- linux-2.6.20.1/include/asm-x86_64/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-x86_64/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -13,6 +13,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-x86_64/page.h linux-2.6.20.1-pax/include/asm-x86_64/page.h
--- linux-2.6.20.1/include/asm-x86_64/page.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-x86_64/page.h	2007-02-05 00:56:22.000000000 +0100
@@ -88,6 +88,8 @@ typedef struct { unsigned long pgprot; }
 #define __PAGE_OFFSET           0xffff810000000000
 #endif /* !__ASSEMBLY__ */
 
+#define __KERNEL_TEXT_OFFSET	(0)
+
 /* to align the pointer to the (next) page boundary */
 #define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
 
@@ -133,6 +135,15 @@ typedef struct { unsigned long pgprot; }
 	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
 	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #define __HAVE_ARCH_GATE_AREA 1	
 
 #include <asm-generic/memory_model.h>
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-x86_64/pgalloc.h linux-2.6.20.1-pax/include/asm-x86_64/pgalloc.h
--- linux-2.6.20.1/include/asm-x86_64/pgalloc.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-x86_64/pgalloc.h	2007-02-05 00:56:22.000000000 +0100
@@ -7,7 +7,7 @@
 #include <linux/mm.h>
 
 #define pmd_populate_kernel(mm, pmd, pte) \
-		set_pmd(pmd, __pmd(_PAGE_TABLE | __pa(pte)))
+		set_pmd(pmd, __pmd(_KERNPG_TABLE | __pa(pte)))
 #define pud_populate(mm, pud, pmd) \
 		set_pud(pud, __pud(_PAGE_TABLE | __pa(pmd)))
 #define pgd_populate(mm, pgd, pud) \
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-x86_64/pgtable.h linux-2.6.20.1-pax/include/asm-x86_64/pgtable.h
--- linux-2.6.20.1/include/asm-x86_64/pgtable.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-x86_64/pgtable.h	2007-02-05 00:56:22.000000000 +0100
@@ -174,6 +174,10 @@ static inline pte_t ptep_get_and_clear_f
 #define PAGE_COPY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
 #define PAGE_READONLY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+
+#define PAGE_READONLY_NOEXEC PAGE_READONLY
+#define PAGE_SHARED_NOEXEC PAGE_SHARED
+
 #define __PAGE_KERNEL \
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_NX)
 #define __PAGE_KERNEL_EXEC \
@@ -261,7 +265,15 @@ static inline pte_t pfn_pte(unsigned lon
 #define __LARGE_PTE (_PAGE_PSE|_PAGE_PRESENT)
 static inline int pte_user(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
 static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-static inline int pte_exec(pte_t pte)		{ return !(pte_val(pte) & _PAGE_NX); }
+
+static inline int pte_exec(pte_t pte)
+{
+	if (__supported_pte_mask & _PAGE_NX)
+		return pte_val(pte) & _PAGE_NX;
+	else
+		return pte_val(pte) & _PAGE_USER;
+}
+
 static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
 static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
 static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
@@ -269,12 +281,30 @@ static inline int pte_file(pte_t pte)		{
 static inline int pte_huge(pte_t pte)		{ return pte_val(pte) & _PAGE_PSE; }
 
 static inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-static inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+
+static inline pte_t pte_exprotect(pte_t pte)
+{
+	if (__supported_pte_mask & _PAGE_NX)
+		set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_NX));
+	else
+		set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER));
+	return pte;
+}
+
 static inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
 static inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
 static inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
 static inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-static inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_NX)); return pte; }
+
+extern inline pte_t pte_mkexec(pte_t pte)
+{
+	if (__supported_pte_mask & _PAGE_NX)
+		set_pte(&pte, __pte(pte_val(pte) | _PAGE_NX));
+	else
+		set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER));
+	return pte;
+}
+
 static inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
 static inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
 static inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-x86_64/system.h linux-2.6.20.1-pax/include/asm-x86_64/system.h
--- linux-2.6.20.1/include/asm-x86_64/system.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-x86_64/system.h	2007-02-05 00:56:22.000000000 +0100
@@ -248,7 +248,7 @@ static inline unsigned long __cmpxchg(vo
 
 void cpu_idle_wait(void);
 
-extern unsigned long arch_align_stack(unsigned long sp);
+#define arch_align_stack(x) (x)
 extern void free_init_pages(char *what, unsigned long begin, unsigned long end);
 
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/asm-xtensa/kmap_types.h linux-2.6.20.1-pax/include/asm-xtensa/kmap_types.h
--- linux-2.6.20.1/include/asm-xtensa/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/asm-xtensa/kmap_types.h	2007-02-05 00:56:22.000000000 +0100
@@ -25,6 +25,7 @@ enum km_type {
   KM_IRQ1,
   KM_SOFTIRQ0,
   KM_SOFTIRQ1,
+  KM_CLEARPAGE,
   KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/a.out.h linux-2.6.20.1-pax/include/linux/a.out.h
--- linux-2.6.20.1/include/linux/a.out.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/a.out.h	2007-02-05 00:56:22.000000000 +0100
@@ -7,6 +7,16 @@
 
 #include <asm/a.out.h>
 
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __DELTA_STACK (current->mm->delta_stack)
+#else
+#define __DELTA_STACK 0UL
+#endif
+
+#ifndef STACK_TOP
+#define STACK_TOP	(__STACK_TOP - __DELTA_STACK)
+#endif
+
 #endif /* __STRUCT_EXEC_OVERRIDE__ */
 
 /* these go in the N_MACHTYPE field */
@@ -37,6 +47,14 @@ enum machine_type {
   M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
 };
 
+/* Constants for the N_FLAGS field */
+#define F_PAX_PAGEEXEC	1	/* Paging based non-executable pages */
+#define F_PAX_EMUTRAMP	2	/* Emulate trampolines */
+#define F_PAX_MPROTECT	4	/* Restrict mprotect() */
+#define F_PAX_RANDMMAP	8	/* Randomize mmap() base */
+/*#define F_PAX_RANDEXEC	16*/	/* Randomize ET_EXEC base */
+#define F_PAX_SEGMEXEC	32	/* Segmentation based non-executable pages */
+
 #if !defined (N_MAGIC)
 #define N_MAGIC(exec) ((exec).a_info & 0xffff)
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/binfmts.h linux-2.6.20.1-pax/include/linux/binfmts.h
--- linux-2.6.20.1/include/linux/binfmts.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/binfmts.h	2007-02-05 00:56:22.000000000 +0100
@@ -7,10 +7,10 @@ struct pt_regs;
 
 /*
  * MAX_ARG_PAGES defines the number of pages allocated for arguments
- * and envelope for the new program. 32 should suffice, this gives
- * a maximum env+arg of 128kB w/4KB pages!
+ * and envelope for the new program. 33 should suffice, this gives
+ * a maximum env+arg of 132kB w/4KB pages!
  */
-#define MAX_ARG_PAGES 32
+#define MAX_ARG_PAGES 33
 
 /* sizeof(linux_binprm->buf) */
 #define BINPRM_BUF_SIZE 128
@@ -38,6 +38,7 @@ struct linux_binprm{
 	unsigned interp_flags;
 	unsigned interp_data;
 	unsigned long loader, exec;
+	int misc;
 };
 
 #define BINPRM_FLAGS_ENFORCE_NONDUMP_BIT 0
@@ -87,5 +88,8 @@ extern void compute_creds(struct linux_b
 extern int do_coredump(long signr, int exit_code, struct pt_regs * regs);
 extern int set_binfmt(struct linux_binfmt *new);
 
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp);
+void pax_report_insns(void *pc, void *sp);
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_BINFMTS_H */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/elf.h linux-2.6.20.1-pax/include/linux/elf.h
--- linux-2.6.20.1/include/linux/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/elf.h	2007-02-05 00:56:22.000000000 +0100
@@ -8,6 +8,10 @@
 
 struct file;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+#undef elf_read_implies_exec
+#endif
+
 #ifndef elf_read_implies_exec
   /* Executables for which elf_read_implies_exec() returns TRUE will
      have the READ_IMPLIES_EXEC personality flag set automatically.
@@ -49,6 +53,16 @@ typedef __s64	Elf64_Sxword;
 
 #define PT_GNU_STACK	(PT_LOOS + 0x474e551)
 
+#define PT_PAX_FLAGS	(PT_LOOS + 0x5041580)
+
+/* Constants for the e_flags field */
+#define EF_PAX_PAGEEXEC		1	/* Paging based non-executable pages */
+#define EF_PAX_EMUTRAMP		2	/* Emulate trampolines */
+#define EF_PAX_MPROTECT		4	/* Restrict mprotect() */
+#define EF_PAX_RANDMMAP		8	/* Randomize mmap() base */
+/*#define EF_PAX_RANDEXEC		16*/	/* Randomize ET_EXEC base */
+#define EF_PAX_SEGMEXEC		32	/* Segmentation based non-executable pages */
+
 /* These constants define the different elf file types */
 #define ET_NONE   0
 #define ET_REL    1
@@ -83,6 +97,8 @@ typedef __s64	Elf64_Sxword;
 #define DT_DEBUG	21
 #define DT_TEXTREL	22
 #define DT_JMPREL	23
+#define DT_FLAGS	30
+  #define DF_TEXTREL	0x00000004
 #define DT_LOPROC	0x70000000
 #define DT_HIPROC	0x7fffffff
 
@@ -212,6 +228,19 @@ typedef struct elf64_hdr {
 #define PF_W		0x2
 #define PF_X		0x1
 
+#define PF_PAGEEXEC	(1U << 4)	/* Enable  PAGEEXEC */
+#define PF_NOPAGEEXEC	(1U << 5)	/* Disable PAGEEXEC */
+#define PF_SEGMEXEC	(1U << 6)	/* Enable  SEGMEXEC */
+#define PF_NOSEGMEXEC	(1U << 7)	/* Disable SEGMEXEC */
+#define PF_MPROTECT	(1U << 8)	/* Enable  MPROTECT */
+#define PF_NOMPROTECT	(1U << 9)	/* Disable MPROTECT */
+/*#define PF_RANDEXEC	(1U << 10)*/	/* Enable  RANDEXEC */
+/*#define PF_NORANDEXEC	(1U << 11)*/	/* Disable RANDEXEC */
+#define PF_EMUTRAMP	(1U << 12)	/* Enable  EMUTRAMP */
+#define PF_NOEMUTRAMP	(1U << 13)	/* Disable EMUTRAMP */
+#define PF_RANDMMAP	(1U << 14)	/* Enable  RANDMMAP */
+#define PF_NORANDMMAP	(1U << 15)	/* Disable RANDMMAP */
+
 typedef struct elf32_phdr{
   Elf32_Word	p_type;
   Elf32_Off	p_offset;
@@ -304,6 +333,8 @@ typedef struct elf64_shdr {
 #define	EI_OSABI	7
 #define	EI_PAD		8
 
+#define	EI_PAX		14
+
 #define	ELFMAG0		0x7f		/* EI_MAG */
 #define	ELFMAG1		'E'
 #define	ELFMAG2		'L'
@@ -361,6 +392,7 @@ extern Elf32_Dyn _DYNAMIC [];
 #define elf_phdr	elf32_phdr
 #define elf_note	elf32_note
 #define elf_addr_t	Elf32_Off
+#define elf_dyn		Elf32_Dyn
 
 #else
 
@@ -369,6 +401,7 @@ extern Elf64_Dyn _DYNAMIC [];
 #define elf_phdr	elf64_phdr
 #define elf_note	elf64_note
 #define elf_addr_t	Elf64_Off
+#define elf_dyn		Elf64_Dyn
 
 #endif
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/ext4_fs_extents.h linux-2.6.20.1-pax/include/linux/ext4_fs_extents.h
--- linux-2.6.20.1/include/linux/ext4_fs_extents.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/ext4_fs_extents.h	2007-02-05 00:56:22.000000000 +0100
@@ -50,7 +50,7 @@
 #ifdef EXT_DEBUG
 #define ext_debug(a...)		printk(a)
 #else
-#define ext_debug(a...)
+#define ext_debug(a...)		do {} while (0)
 #endif
 
 /*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/highmem.h linux-2.6.20.1-pax/include/linux/highmem.h
--- linux-2.6.20.1/include/linux/highmem.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/highmem.h	2007-02-05 00:56:22.000000000 +0100
@@ -81,6 +81,13 @@ static inline void clear_highpage(struct
 	kunmap_atomic(kaddr, KM_USER0);
 }
 
+static inline void sanitize_highpage(struct page *page)
+{
+	void *kaddr = kmap_atomic(page, KM_CLEARPAGE);
+	clear_page(kaddr);
+	kunmap_atomic(kaddr, KM_CLEARPAGE);
+}
+
 /*
  * Same but also flushes aliased cache contents to RAM.
  */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/jbd.h linux-2.6.20.1-pax/include/linux/jbd.h
--- linux-2.6.20.1/include/linux/jbd.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/jbd.h	2007-02-05 00:56:22.000000000 +0100
@@ -68,7 +68,7 @@ extern int journal_enable_debug;
 		}							\
 	} while (0)
 #else
-#define jbd_debug(f, a...)	/**/
+#define jbd_debug(f, a...)	do {} while (0)
 #endif
 
 extern void * __jbd_kmalloc (const char *where, size_t size, gfp_t flags, int retry);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/jbd2.h linux-2.6.20.1-pax/include/linux/jbd2.h
--- linux-2.6.20.1/include/linux/jbd2.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/jbd2.h	2007-02-05 00:56:22.000000000 +0100
@@ -68,7 +68,7 @@ extern int jbd2_journal_enable_debug;
 		}							\
 	} while (0)
 #else
-#define jbd_debug(f, a...)	/**/
+#define jbd_debug(f, a...)	do {} while (0)
 #endif
 
 extern void * __jbd2_kmalloc (const char *where, size_t size, gfp_t flags, int retry);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/mm.h linux-2.6.20.1-pax/include/linux/mm.h
--- linux-2.6.20.1/include/linux/mm.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/mm.h	2007-02-05 00:56:22.000000000 +0100
@@ -39,6 +39,7 @@ extern int sysctl_legacy_va_layout;
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/processor.h>
+#include <asm/mman.h>
 
 #define nth_page(page,n) pfn_to_page(page_to_pfn((page)) + (n))
 
@@ -112,8 +113,43 @@ struct vm_area_struct {
 #ifdef CONFIG_NUMA
 	struct mempolicy *vm_policy;	/* NUMA policy for the VMA */
 #endif
+
+	unsigned long vm_mirror;	/* PaX: mirror distance */
 };
 
+#ifdef CONFIG_PAX_SOFTMODE
+extern unsigned int pax_softmode;
+#endif
+
+extern int pax_check_flags(unsigned long *);
+
+/* if tsk != current then task_lock must be held on it */
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline unsigned long pax_get_flags(struct task_struct *tsk)
+{
+	if (likely(tsk->mm))
+		return tsk->mm->pax_flags;
+	else
+		return 0UL;
+}
+
+/* if tsk != current then task_lock must be held on it */
+static inline long pax_set_flags(struct task_struct *tsk, unsigned long flags)
+{
+	if (likely(tsk->mm)) {
+		tsk->mm->pax_flags = flags;
+		return 0;
+	}
+	return -EINVAL;
+}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+extern void pax_set_initial_flags(struct linux_binprm * bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+extern void (*pax_set_initial_flags_func)(struct linux_binprm * bprm);
+#endif
+
 extern struct kmem_cache *vm_area_cachep;
 
 /*
@@ -170,6 +206,18 @@ extern unsigned int kobjsize(const void 
 #define VM_INSERTPAGE	0x02000000	/* The vma has had "vm_insert_page()" done on it */
 #define VM_ALWAYSDUMP	0x04000000	/* Always include in core dumps */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define VM_MIRROR	0x04000000	/* vma is mirroring another */
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+#define VM_MAYNOTWRITE	0x08000000	/* vma cannot be granted VM_WRITE any more */
+#endif
+
+#ifdef __VM_STACK_FLAGS
+#define VM_STACK_DEFAULT_FLAGS (0x00000033 | __VM_STACK_FLAGS)
+#endif
+
 #ifndef VM_STACK_DEFAULT_FLAGS		/* arch can override this */
 #define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
 #endif
@@ -1115,7 +1163,6 @@ static inline unsigned long vma_pages(st
 }
 
 pgprot_t vm_get_page_prot(unsigned long vm_flags);
-struct vm_area_struct *find_extend_vma(struct mm_struct *, unsigned long addr);
 struct page *vmalloc_to_page(void *addr);
 unsigned long vmalloc_to_pfn(void *addr);
 int remap_pfn_range(struct vm_area_struct *, unsigned long addr,
@@ -1167,5 +1214,11 @@ extern int randomize_va_space;
 
 __attribute__((weak)) const char *arch_vma_name(struct vm_area_struct *vma);
 
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+extern void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot);
+#else
+static inline void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot) {}
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_MM_H */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/mman.h linux-2.6.20.1-pax/include/linux/mman.h
--- linux-2.6.20.1/include/linux/mman.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/mman.h	2007-02-05 00:56:22.000000000 +0100
@@ -61,6 +61,11 @@ static inline unsigned long
 calc_vm_flag_bits(unsigned long flags)
 {
 	return _calc_vm_trans(flags, MAP_GROWSDOWN,  VM_GROWSDOWN ) |
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	       _calc_vm_trans(flags, MAP_MIRROR, VM_MIRROR) |
+#endif
+
 	       _calc_vm_trans(flags, MAP_DENYWRITE,  VM_DENYWRITE ) |
 	       _calc_vm_trans(flags, MAP_EXECUTABLE, VM_EXECUTABLE) |
 	       _calc_vm_trans(flags, MAP_LOCKED,     VM_LOCKED    );
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/module.h linux-2.6.20.1-pax/include/linux/module.h
--- linux-2.6.20.1/include/linux/module.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/module.h	2007-02-05 00:56:22.000000000 +0100
@@ -297,16 +297,16 @@ struct module
 	int (*init)(void);
 
 	/* If this is non-NULL, vfree after init() returns */
-	void *module_init;
+	void *module_init_rx, *module_init_rw;
 
 	/* Here is the actual code + data, vfree'd on unload. */
-	void *module_core;
+	void *module_core_rx, *module_core_rw;
 
 	/* Here are the sizes of the init and core sections */
-	unsigned long init_size, core_size;
+	unsigned long init_size_rw, core_size_rw;
 
 	/* The size of the executable code in each section.  */
-	unsigned long init_text_size, core_text_size;
+	unsigned long init_size_rx, core_size_rx;
 
 	/* The handle returned from unwind_add_table. */
 	void *unwind_info;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/moduleloader.h linux-2.6.20.1-pax/include/linux/moduleloader.h
--- linux-2.6.20.1/include/linux/moduleloader.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/moduleloader.h	2007-02-05 00:56:22.000000000 +0100
@@ -17,9 +17,21 @@ int module_frob_arch_sections(Elf_Ehdr *
    sections.  Returns NULL on failure. */
 void *module_alloc(unsigned long size);
 
+#ifdef CONFIG_PAX_KERNEXEC
+void *module_alloc_exec(unsigned long size);
+#else
+#define module_alloc_exec(x) module_alloc(x)
+#endif
+
 /* Free memory returned from module_alloc. */
 void module_free(struct module *mod, void *module_region);
 
+#ifdef CONFIG_PAX_KERNEXEC
+void module_free_exec(struct module *mod, void *module_region);
+#else
+#define module_free_exec(x, y) module_free(x, y)
+#endif
+
 /* Apply the given relocation to the (simplified) ELF.  Return -error
    or 0. */
 int apply_relocate(Elf_Shdr *sechdrs,
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/random.h linux-2.6.20.1-pax/include/linux/random.h
--- linux-2.6.20.1/include/linux/random.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/random.h	2007-02-05 00:56:22.000000000 +0100
@@ -62,6 +62,8 @@ extern __u32 secure_tcpv6_sequence_numbe
 extern u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,
 				       __be16 sport, __be16 dport);
 
+extern unsigned long pax_get_random_long(void);
+
 #ifndef MODULE
 extern struct file_operations random_fops, urandom_fops;
 #endif
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/sched.h linux-2.6.20.1-pax/include/linux/sched.h
--- linux-2.6.20.1/include/linux/sched.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/sched.h	2007-02-05 00:56:22.000000000 +0100
@@ -88,6 +88,7 @@ struct sched_param {
 
 struct exec_domain;
 struct futex_pi_state;
+struct linux_binprm;
 
 /*
  * List of flags we want to share for kernel threads,
@@ -373,8 +374,34 @@ struct mm_struct {
 	/* aio bits */
 	rwlock_t		ioctx_list_lock;
 	struct kioctx		*ioctx_list;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	unsigned long pax_flags;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	unsigned long call_dl_resolve;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	unsigned long call_syscall;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	unsigned long delta_mmap;		/* randomized offset */
+	unsigned long delta_exec;		/* randomized offset */
+	unsigned long delta_stack;		/* randomized offset */
+#endif
+
 };
 
+#define MF_PAX_PAGEEXEC		0x01000000	/* Paging based non-executable pages */
+#define MF_PAX_EMUTRAMP		0x02000000	/* Emulate trampolines */
+#define MF_PAX_MPROTECT		0x04000000	/* Restrict mprotect() */
+#define MF_PAX_RANDMMAP		0x08000000	/* Randomize mmap() base */
+/*#define MF_PAX_RANDEXEC		0x10000000*/	/* Randomize ET_EXEC base */
+#define MF_PAX_SEGMEXEC		0x20000000	/* Segmentation based non-executable pages */
+
 struct sighand_struct {
 	atomic_t		count;
 	struct k_sigaction	action[_NSIG];
@@ -1634,6 +1661,12 @@ extern void arch_pick_mmap_layout(struct
 static inline void arch_pick_mmap_layout(struct mm_struct *mm)
 {
 	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
 	mm->get_unmapped_area = arch_get_unmapped_area;
 	mm->unmap_area = arch_unmap_area;
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/skbuff.h linux-2.6.20.1-pax/include/linux/skbuff.h
--- linux-2.6.20.1/include/linux/skbuff.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/skbuff.h	2007-02-05 00:56:22.000000000 +0100
@@ -373,7 +373,7 @@ extern void	      skb_truesize_bug(struc
 
 static inline void skb_truesize_check(struct sk_buff *skb)
 {
-	if (unlikely((int)skb->truesize < sizeof(struct sk_buff) + skb->len))
+	if (unlikely(skb->truesize < sizeof(struct sk_buff) + skb->len))
 		skb_truesize_bug(skb);
 }
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/sysctl.h linux-2.6.20.1-pax/include/linux/sysctl.h
--- linux-2.6.20.1/include/linux/sysctl.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/sysctl.h	2007-02-05 00:56:22.000000000 +0100
@@ -160,9 +160,18 @@ enum
 	KERN_MAX_LOCK_DEPTH=74,
 	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
-};
 
+#ifdef CONFIG_PAX_SOFTMODE
+	KERN_PAX=99,		/* PaX control */
+#endif
+
+};
 
+#ifdef CONFIG_PAX_SOFTMODE
+enum {
+	PAX_SOFTMODE=1		/* PaX: disable/enable soft mode */
+};
+#endif
 
 /* CTL_VM names: */
 enum
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/uaccess.h linux-2.6.20.1-pax/include/linux/uaccess.h
--- linux-2.6.20.1/include/linux/uaccess.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/uaccess.h	2007-02-05 00:56:22.000000000 +0100
@@ -76,11 +76,11 @@ static inline unsigned long __copy_from_
 		long ret;				\
 		mm_segment_t old_fs = get_fs();		\
 							\
-		set_fs(KERNEL_DS);			\
 		pagefault_disable();			\
+		set_fs(KERNEL_DS);			\
 		ret = __get_user(retval, (__force typeof(retval) __user *)(addr));		\
-		pagefault_enable();			\
 		set_fs(old_fs);				\
+		pagefault_enable();			\
 		ret;					\
 	})
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/linux/udf_fs.h linux-2.6.20.1-pax/include/linux/udf_fs.h
--- linux-2.6.20.1/include/linux/udf_fs.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/linux/udf_fs.h	2007-02-05 00:56:22.000000000 +0100
@@ -45,7 +45,7 @@
 		printk (f, ##a); \
 	}
 #else
-#define udf_debug(f, a...) /**/
+#define udf_debug(f, a...) do {} while (0)
 #endif
 
 #define udf_info(f, a...) \
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/net/sctp/sctp.h linux-2.6.20.1-pax/include/net/sctp/sctp.h
--- linux-2.6.20.1/include/net/sctp/sctp.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/net/sctp/sctp.h	2007-02-05 00:56:22.000000000 +0100
@@ -306,8 +306,8 @@ extern int sctp_debug_flag;
 
 #else	/* SCTP_DEBUG */
 
-#define SCTP_DEBUG_PRINTK(whatever...)
-#define SCTP_DEBUG_PRINTK_IPADDR(whatever...)
+#define SCTP_DEBUG_PRINTK(whatever...) do {} while (0)
+#define SCTP_DEBUG_PRINTK_IPADDR(whatever...) do {} while (0)
 #define SCTP_ENABLE_DEBUG
 #define SCTP_DISABLE_DEBUG
 #define SCTP_ASSERT(expr, str, func)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/include/sound/core.h linux-2.6.20.1-pax/include/sound/core.h
--- linux-2.6.20.1/include/sound/core.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/include/sound/core.h	2007-02-05 00:56:22.000000000 +0100
@@ -365,9 +365,9 @@ void snd_verbose_printd(const char *file
 
 #else /* !CONFIG_SND_DEBUG */
 
-#define snd_printd(fmt, args...)	/* nothing */
+#define snd_printd(fmt, args...)	do {} while (0)
 #define snd_assert(expr, args...)	(void)(expr)
-#define snd_BUG()			/* nothing */
+#define snd_BUG()			do {} while (0)
 
 #endif /* CONFIG_SND_DEBUG */
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/init/do_mounts.c linux-2.6.20.1-pax/init/do_mounts.c
--- linux-2.6.20.1/init/do_mounts.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/init/do_mounts.c	2007-02-05 00:56:22.000000000 +0100
@@ -65,11 +65,12 @@ static dev_t try_name(char *name, int pa
 
 	/* read device number from .../dev */
 
-	sprintf(path, "/sys/block/%s/dev", name);
-	fd = sys_open(path, 0, 0);
+	if (sizeof path <= snprintf(path, sizeof path, "/sys/block/%s/dev", name))
+		goto fail;
+	fd = sys_open((char __user *)path, 0, 0);
 	if (fd < 0)
 		goto fail;
-	len = sys_read(fd, buf, 32);
+	len = sys_read(fd, (char __user *)buf, 32);
 	sys_close(fd);
 	if (len <= 0 || len == 32 || buf[len - 1] != '\n')
 		goto fail;
@@ -95,11 +96,12 @@ static dev_t try_name(char *name, int pa
 		return res;
 
 	/* otherwise read range from .../range */
-	sprintf(path, "/sys/block/%s/range", name);
-	fd = sys_open(path, 0, 0);
+	if (sizeof path <= snprintf(path, sizeof path, "/sys/block/%s/range", name))
+		goto fail;
+	fd = sys_open((char __user *)path, 0, 0);
 	if (fd < 0)
 		goto fail;
-	len = sys_read(fd, buf, 32);
+	len = sys_read(fd, (char __user *)buf, 32);
 	sys_close(fd);
 	if (len <= 0 || len == 32 || buf[len - 1] != '\n')
 		goto fail;
@@ -142,12 +144,12 @@ dev_t name_to_dev_t(char *name)
 	int part, mount_result;
 
 #ifdef CONFIG_SYSFS
-	int mkdir_err = sys_mkdir("/sys", 0700);
+	int mkdir_err = sys_mkdir((char __user *)"/sys", 0700);
 	/* 
 	 * When changing resume2 parameter for Software Suspend, sysfs may
 	 * already be mounted. 
 	 */
-	mount_result = sys_mount("sysfs", "/sys", "sysfs", 0, NULL);
+	mount_result = sys_mount((char __user *)"sysfs", (char __user *)"/sys", (char __user *)"sysfs", 0, NULL);
 	if (mount_result < 0 && mount_result != -EBUSY)
 		goto out;
 #endif
@@ -195,10 +197,10 @@ dev_t name_to_dev_t(char *name)
 done:
 #ifdef CONFIG_SYSFS
 	if (mount_result >= 0)
-		sys_umount("/sys", 0);
+		sys_umount((char __user *)"/sys", 0);
 out:
 	if (!mkdir_err)
-		sys_rmdir("/sys");
+		sys_rmdir((char __user *)"/sys");
 #endif
 	return res;
 fail:
@@ -268,11 +270,11 @@ static void __init get_fs_names(char *pa
 
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
-	int err = sys_mount(name, "/root", fs, flags, data);
+	int err = sys_mount((char __user *)name, (char __user *)"/root", (char __user *)fs, flags, (void __user *)data);
 	if (err)
 		return err;
 
-	sys_chdir("/root");
+	sys_chdir((char __user *)"/root");
 	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s.\n",
 	       current->fs->pwdmnt->mnt_sb->s_type->name,
@@ -354,18 +356,18 @@ void __init change_floppy(char *fmt, ...
 	va_start(args, fmt);
 	vsprintf(buf, fmt, args);
 	va_end(args);
-	fd = sys_open("/dev/root", O_RDWR | O_NDELAY, 0);
+	fd = sys_open((char __user *)"/dev/root", O_RDWR | O_NDELAY, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, FDEJECT, 0);
 		sys_close(fd);
 	}
 	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
-	fd = sys_open("/dev/console", O_RDWR, 0);
+	fd = sys_open((char __user *)"/dev/console", O_RDWR, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, TCGETS, (long)&termios);
 		termios.c_lflag &= ~ICANON;
 		sys_ioctl(fd, TCSETSF, (long)&termios);
-		sys_read(fd, &c, 1);
+		sys_read(fd, (char __user *)&c, 1);
 		termios.c_lflag |= ICANON;
 		sys_ioctl(fd, TCSETSF, (long)&termios);
 		sys_close(fd);
@@ -442,8 +444,8 @@ void __init prepare_namespace(void)
 
 	mount_root();
 out:
-	sys_mount(".", "/", NULL, MS_MOVE, NULL);
-	sys_chroot(".");
+	sys_mount((char __user *)".", (char __user *)"/", NULL, MS_MOVE, NULL);
+	sys_chroot((char __user *)".");
 	security_sb_post_mountroot();
 }
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/init/do_mounts.h linux-2.6.20.1-pax/init/do_mounts.h
--- linux-2.6.20.1/init/do_mounts.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/init/do_mounts.h	2007-02-05 00:56:22.000000000 +0100
@@ -15,15 +15,15 @@ extern char *root_device_name;
 
 static inline int create_dev(char *name, dev_t dev)
 {
-	sys_unlink(name);
-	return sys_mknod(name, S_IFBLK|0600, new_encode_dev(dev));
+	sys_unlink((char __user *)name);
+	return sys_mknod((char __user *)name, S_IFBLK|0600, new_encode_dev(dev));
 }
 
 #if BITS_PER_LONG == 32
 static inline u32 bstat(char *name)
 {
 	struct stat64 stat;
-	if (sys_stat64(name, &stat) != 0)
+	if (sys_stat64((char __user *)name, (struct stat64 __user *)&stat) != 0)
 		return 0;
 	if (!S_ISBLK(stat.st_mode))
 		return 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/init/do_mounts_md.c linux-2.6.20.1-pax/init/do_mounts_md.c
--- linux-2.6.20.1/init/do_mounts_md.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/init/do_mounts_md.c	2007-02-05 00:56:22.000000000 +0100
@@ -167,7 +167,7 @@ static void __init md_setup_drive(void)
 			partitioned ? "_d" : "", minor,
 			md_setup_args[ent].device_names);
 
-		fd = sys_open(name, 0, 0);
+		fd = sys_open((char __user *)name, 0, 0);
 		if (fd < 0) {
 			printk(KERN_ERR "md: open failed - cannot start "
 					"array %s\n", name);
@@ -230,7 +230,7 @@ static void __init md_setup_drive(void)
 			 * array without it
 			 */
 			sys_close(fd);
-			fd = sys_open(name, 0, 0);
+			fd = sys_open((char __user *)name, 0, 0);
 			sys_ioctl(fd, BLKRRPART, 0);
 		}
 		sys_close(fd);
@@ -271,7 +271,7 @@ void __init md_run_setup(void)
 	if (raid_noautodetect)
 		printk(KERN_INFO "md: Skipping autodetection of RAID arrays. (raid=noautodetect)\n");
 	else {
-		int fd = sys_open("/dev/md0", 0, 0);
+		int fd = sys_open((char __user *)"/dev/md0", 0, 0);
 		if (fd >= 0) {
 			sys_ioctl(fd, RAID_AUTORUN, raid_autopart);
 			sys_close(fd);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/init/initramfs.c linux-2.6.20.1-pax/init/initramfs.c
--- linux-2.6.20.1/init/initramfs.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/init/initramfs.c	2007-02-05 00:56:22.000000000 +0100
@@ -240,7 +240,7 @@ static int __init maybe_link(void)
 	if (nlink >= 2) {
 		char *old = find_link(major, minor, ino, mode, collected);
 		if (old)
-			return (sys_link(old, collected) < 0) ? -1 : 1;
+			return (sys_link((char __user *)old, (char __user *)collected) < 0) ? -1 : 1;
 	}
 	return 0;
 }
@@ -249,11 +249,11 @@ static void __init clean_path(char *path
 {
 	struct stat st;
 
-	if (!sys_newlstat(path, &st) && (st.st_mode^mode) & S_IFMT) {
+	if (!sys_newlstat((char __user *)path, (struct stat __user *)&st) && (st.st_mode^mode) & S_IFMT) {
 		if (S_ISDIR(st.st_mode))
-			sys_rmdir(path);
+			sys_rmdir((char __user *)path);
 		else
-			sys_unlink(path);
+			sys_unlink((char __user *)path);
 	}
 }
 
@@ -276,7 +276,7 @@ static int __init do_name(void)
 			int openflags = O_WRONLY|O_CREAT;
 			if (ml != 1)
 				openflags |= O_TRUNC;
-			wfd = sys_open(collected, openflags, mode);
+			wfd = sys_open((char __user *)collected, openflags, mode);
 
 			if (wfd >= 0) {
 				sys_fchown(wfd, uid, gid);
@@ -285,15 +285,15 @@ static int __init do_name(void)
 			}
 		}
 	} else if (S_ISDIR(mode)) {
-		sys_mkdir(collected, mode);
-		sys_chown(collected, uid, gid);
-		sys_chmod(collected, mode);
+		sys_mkdir((char __user *)collected, mode);
+		sys_chown((char __user *)collected, uid, gid);
+		sys_chmod((char __user *)collected, mode);
 	} else if (S_ISBLK(mode) || S_ISCHR(mode) ||
 		   S_ISFIFO(mode) || S_ISSOCK(mode)) {
 		if (maybe_link() == 0) {
-			sys_mknod(collected, mode, rdev);
-			sys_chown(collected, uid, gid);
-			sys_chmod(collected, mode);
+			sys_mknod((char __user *)collected, mode, rdev);
+			sys_chown((char __user *)collected, uid, gid);
+			sys_chmod((char __user *)collected, mode);
 		}
 	}
 	return 0;
@@ -302,13 +302,13 @@ static int __init do_name(void)
 static int __init do_copy(void)
 {
 	if (count >= body_len) {
-		sys_write(wfd, victim, body_len);
+		sys_write(wfd, (char __user *)victim, body_len);
 		sys_close(wfd);
 		eat(body_len);
 		state = SkipIt;
 		return 0;
 	} else {
-		sys_write(wfd, victim, count);
+		sys_write(wfd, (char __user *)victim, count);
 		body_len -= count;
 		eat(count);
 		return 1;
@@ -319,8 +319,8 @@ static int __init do_symlink(void)
 {
 	collected[N_ALIGN(name_len) + body_len] = '\0';
 	clean_path(collected, 0);
-	sys_symlink(collected + N_ALIGN(name_len), collected);
-	sys_lchown(collected, uid, gid);
+	sys_symlink((char __user *)collected + N_ALIGN(name_len), (char __user *)collected);
+	sys_lchown((char __user *)collected, uid, gid);
 	state = SkipIt;
 	next_state = Reset;
 	return 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/init/main.c linux-2.6.20.1-pax/init/main.c
--- linux-2.6.20.1/init/main.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/init/main.c	2007-02-16 19:42:40.000000000 +0100
@@ -176,6 +176,15 @@ static int __init set_reset_devices(char
 
 __setup("reset_devices", set_reset_devices);
 
+#ifdef CONFIG_PAX_SOFTMODE
+static int __init setup_pax_softmode(char *str)
+{
+	get_option(&str, &pax_softmode);
+	return 1;
+}
+__setup("pax_softmode=", setup_pax_softmode);
+#endif
+
 static char * argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
 char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
 static const char *panic_later, *panic_param;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/acct.c linux-2.6.20.1-pax/kernel/acct.c
--- linux-2.6.20.1/kernel/acct.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/acct.c	2007-02-05 00:56:22.000000000 +0100
@@ -511,7 +511,7 @@ static void do_acct_process(struct file 
  	 */
 	flim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
 	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
-	file->f_op->write(file, (char *)&ac,
+	file->f_op->write(file, (char __user *)&ac,
 			       sizeof(acct_t), &file->f_pos);
 	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;
 	set_fs(fs);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/fork.c linux-2.6.20.1-pax/kernel/fork.c
--- linux-2.6.20.1/kernel/fork.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/fork.c	2007-02-05 00:56:22.000000000 +0100
@@ -180,7 +180,7 @@ static struct task_struct *dup_task_stru
 	setup_thread_stack(tsk, orig);
 
 #ifdef CONFIG_CC_STACKPROTECTOR
-	tsk->stack_canary = get_random_int();
+	tsk->stack_canary = pax_get_random_long();
 #endif
 
 	/* One for us, one for whoever does the "release_task()" (usually parent) */
@@ -212,8 +212,8 @@ static inline int dup_mmap(struct mm_str
 	mm->locked_vm = 0;
 	mm->mmap = NULL;
 	mm->mmap_cache = NULL;
-	mm->free_area_cache = oldmm->mmap_base;
-	mm->cached_hole_size = ~0UL;
+	mm->free_area_cache = oldmm->free_area_cache;
+	mm->cached_hole_size = oldmm->cached_hole_size;
 	mm->map_count = 0;
 	cpus_clear(mm->cpu_vm_mask);
 	mm->mm_rb = RB_ROOT;
@@ -338,7 +338,7 @@ static struct mm_struct * mm_init(struct
 	spin_lock_init(&mm->page_table_lock);
 	rwlock_init(&mm->ioctx_list_lock);
 	mm->ioctx_list = NULL;
-	mm->free_area_cache = TASK_UNMAPPED_BASE;
+	mm->free_area_cache = ~0UL;
 	mm->cached_hole_size = ~0UL;
 
 	if (likely(!mm_alloc_pgd(mm))) {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/futex.c linux-2.6.20.1-pax/kernel/futex.c
--- linux-2.6.20.1/kernel/futex.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/futex.c	2007-02-18 19:23:25.000000000 +0100
@@ -183,6 +183,11 @@ static int get_futex_key(u32 __user *uad
 	struct page *page;
 	int err;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && ((unsigned long)uaddr >= SEGMEXEC_TASK_SIZE))
+		return -EFAULT;
+#endif
+
 	/*
 	 * The futex address must be "naturally" aligned.
 	 */
@@ -195,8 +200,8 @@ static int get_futex_key(u32 __user *uad
 	 * The futex is hashed differently depending on whether
 	 * it's in a shared or private mapping.  So check vma first.
 	 */
-	vma = find_extend_vma(mm, address);
-	if (unlikely(!vma))
+	vma = find_vma(mm, address);
+	if (unlikely(!vma || address < vma->vm_start))
 		return -EFAULT;
 
 	/*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/kallsyms.c linux-2.6.20.1-pax/kernel/kallsyms.c
--- linux-2.6.20.1/kernel/kallsyms.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/kallsyms.c	2007-02-05 00:56:22.000000000 +0100
@@ -334,7 +334,6 @@ static unsigned long get_ksymbol_core(st
 
 static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)
 {
-	iter->name[0] = '\0';
 	iter->nameoff = get_symbol_offset(new_pos);
 	iter->pos = new_pos;
 }
@@ -413,7 +412,7 @@ static int kallsyms_open(struct inode *i
 	struct kallsym_iter *iter;
 	int ret;
 
-	iter = kmalloc(sizeof(*iter), GFP_KERNEL);
+	iter = kzalloc(sizeof(*iter), GFP_KERNEL);
 	if (!iter)
 		return -ENOMEM;
 	reset_iter(iter, 0);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/kprobes.c linux-2.6.20.1-pax/kernel/kprobes.c
--- linux-2.6.20.1/kernel/kprobes.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/kprobes.c	2007-02-05 00:56:22.000000000 +0100
@@ -162,7 +162,7 @@ kprobe_opcode_t __kprobes *get_insn_slot
 	 * kernel image and loaded module images reside. This is required
 	 * so x86_64 can correctly handle the %rip-relative fixups.
 	 */
-	kip->insns = module_alloc(PAGE_SIZE);
+	kip->insns = module_alloc_exec(PAGE_SIZE);
 	if (!kip->insns) {
 		kfree(kip);
 		return NULL;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/module.c linux-2.6.20.1-pax/kernel/module.c
--- linux-2.6.20.1/kernel/module.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/module.c	2007-02-05 00:56:22.000000000 +0100
@@ -43,6 +43,11 @@
 #include <asm/uaccess.h>
 #include <asm/semaphore.h>
 #include <asm/cacheflush.h>
+
+#ifdef CONFIG_PAX_KERNEXEC
+#include <asm/desc.h>
+#endif
+
 #include <linux/license.h>
 
 #if 0
@@ -1196,16 +1201,19 @@ static void free_module(struct module *m
 	module_unload_free(mod);
 
 	/* This may be NULL, but that's OK */
-	module_free(mod, mod->module_init);
+	module_free(mod, mod->module_init_rw);
+	module_free_exec(mod, mod->module_init_rx);
 	kfree(mod->args);
 	if (mod->percpu)
 		percpu_modfree(mod->percpu);
 
 	/* Free lock-classes: */
-	lockdep_free_key_range(mod->module_core, mod->core_size);
+	lockdep_free_key_range(mod->module_core_rx, mod->core_size_rx);
+	lockdep_free_key_range(mod->module_core_rw, mod->core_size_rw);
 
 	/* Finally, free the core (containing the module structure) */
-	module_free(mod, mod->module_core);
+	module_free_exec(mod, mod->module_core_rx);
+	module_free(mod, mod->module_core_rw);
 }
 
 void *__symbol_get(const char *symbol)
@@ -1362,11 +1370,14 @@ static void layout_sections(struct modul
 			    || strncmp(secstrings + s->sh_name,
 				       ".init", 5) == 0)
 				continue;
-			s->sh_entsize = get_offset(&mod->core_size, s);
+			if ((s->sh_flags & SHF_WRITE) || !(s->sh_flags & SHF_ALLOC))
+				s->sh_entsize = get_offset(&mod->core_size_rw, s);
+			else
+				s->sh_entsize = get_offset(&mod->core_size_rx, s);
 			DEBUGP("\t%s\n", secstrings + s->sh_name);
 		}
 		if (m == 0)
-			mod->core_text_size = mod->core_size;
+			mod->core_size_rx = mod->core_size_rx;
 	}
 
 	DEBUGP("Init section allocation order:\n");
@@ -1380,12 +1391,15 @@ static void layout_sections(struct modul
 			    || strncmp(secstrings + s->sh_name,
 				       ".init", 5) != 0)
 				continue;
-			s->sh_entsize = (get_offset(&mod->init_size, s)
-					 | INIT_OFFSET_MASK);
+			if ((s->sh_flags & SHF_WRITE) || !(s->sh_flags & SHF_ALLOC))
+				s->sh_entsize = get_offset(&mod->init_size_rw, s);
+			else
+				s->sh_entsize = get_offset(&mod->init_size_rx, s);
+			s->sh_entsize |= INIT_OFFSET_MASK;
 			DEBUGP("\t%s\n", secstrings + s->sh_name);
 		}
 		if (m == 0)
-			mod->init_text_size = mod->init_size;
+			mod->init_size_rx = mod->init_size_rx;
 	}
 }
 
@@ -1567,6 +1581,10 @@ static struct module *load_module(void _
 	struct exception_table_entry *extable;
 	mm_segment_t old_fs;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	DEBUGP("load_module: umod=%p, len=%lu, uargs=%p\n",
 	       umod, len, uargs);
 	if (len < sizeof(*hdr))
@@ -1725,21 +1743,57 @@ static struct module *load_module(void _
 	layout_sections(mod, hdr, sechdrs, secstrings);
 
 	/* Do the allocs. */
-	ptr = module_alloc(mod->core_size);
+	ptr = module_alloc(mod->core_size_rw);
 	if (!ptr) {
 		err = -ENOMEM;
 		goto free_percpu;
 	}
-	memset(ptr, 0, mod->core_size);
-	mod->module_core = ptr;
+	memset(ptr, 0, mod->core_size_rw);
+	mod->module_core_rw = ptr;
+
+	ptr = module_alloc(mod->init_size_rw);
+	if (!ptr && mod->init_size_rw) {
+		err = -ENOMEM;
+		goto free_core_rw;
+	}
+	memset(ptr, 0, mod->init_size_rw);
+	mod->module_init_rw = ptr;
 
-	ptr = module_alloc(mod->init_size);
-	if (!ptr && mod->init_size) {
+	ptr = module_alloc_exec(mod->core_size_rx);
+	if (!ptr) {
 		err = -ENOMEM;
-		goto free_core;
+		goto free_init_rw;
 	}
-	memset(ptr, 0, mod->init_size);
-	mod->module_init = ptr;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	memset(ptr, 0, mod->core_size_rx);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+	mod->module_core_rx = ptr;
+
+	ptr = module_alloc_exec(mod->init_size_rx);
+	if (!ptr && mod->init_size_rx) {
+		err = -ENOMEM;
+		goto free_core_rx;
+	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	memset(ptr, 0, mod->init_size_rx);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+	mod->module_init_rx = ptr;
 
 	/* Transfer each section which specifies SHF_ALLOC */
 	DEBUGP("final section addresses:\n");
@@ -1749,17 +1803,44 @@ static struct module *load_module(void _
 		if (!(sechdrs[i].sh_flags & SHF_ALLOC))
 			continue;
 
-		if (sechdrs[i].sh_entsize & INIT_OFFSET_MASK)
-			dest = mod->module_init
-				+ (sechdrs[i].sh_entsize & ~INIT_OFFSET_MASK);
-		else
-			dest = mod->module_core + sechdrs[i].sh_entsize;
+		if (sechdrs[i].sh_entsize & INIT_OFFSET_MASK) {
+			if ((sechdrs[i].sh_flags & SHF_WRITE) || !(sechdrs[i].sh_flags & SHF_ALLOC))
+				dest = mod->module_init_rw
+					+ (sechdrs[i].sh_entsize & ~INIT_OFFSET_MASK);
+			else
+				dest = mod->module_init_rx
+					+ (sechdrs[i].sh_entsize & ~INIT_OFFSET_MASK);
+		} else {
+			if ((sechdrs[i].sh_flags & SHF_WRITE) || !(sechdrs[i].sh_flags & SHF_ALLOC))
+				dest = mod->module_core_rw + sechdrs[i].sh_entsize;
+			else
+				dest = mod->module_core_rx + sechdrs[i].sh_entsize;
+		}
+
+		if (sechdrs[i].sh_type != SHT_NOBITS) {
 
-		if (sechdrs[i].sh_type != SHT_NOBITS)
-			memcpy(dest, (void *)sechdrs[i].sh_addr,
-			       sechdrs[i].sh_size);
+#ifdef CONFIG_PAX_KERNEXEC
+			if (!(sechdrs[i].sh_flags & SHF_WRITE) && (sechdrs[i].sh_flags & SHF_ALLOC))
+				pax_open_kernel(cr0);
+#endif
+
+			memcpy(dest, (void *)sechdrs[i].sh_addr, sechdrs[i].sh_size);
+
+#ifdef CONFIG_PAX_KERNEXEC
+			if (!(sechdrs[i].sh_flags & SHF_WRITE) && (sechdrs[i].sh_flags & SHF_ALLOC))
+				pax_close_kernel(cr0);
+#endif
+
+		}
 		/* Update sh_addr to point to copy in image. */
-		sechdrs[i].sh_addr = (unsigned long)dest;
+
+#ifdef CONFIG_PAX_KERNEXEC
+		if (sechdrs[i].sh_flags & SHF_EXECINSTR)
+			sechdrs[i].sh_addr = (unsigned long)dest - __KERNEL_TEXT_OFFSET;
+		else
+#endif
+
+			sechdrs[i].sh_addr = (unsigned long)dest;
 		DEBUGP("\t0x%lx %s\n", sechdrs[i].sh_addr, secstrings + sechdrs[i].sh_name);
 	}
 	/* Module has been moved. */
@@ -1780,8 +1861,18 @@ static struct module *load_module(void _
 	setup_modinfo(mod, sechdrs, infoindex);
 
 	/* Fix up syms, so that st_value is a pointer to location. */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	err = simplify_symbols(sechdrs, symindex, strtab, versindex, pcpuindex,
 			       mod);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	if (err < 0)
 		goto cleanup;
 
@@ -1836,11 +1927,20 @@ static struct module *load_module(void _
 		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
 			continue;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 		if (sechdrs[i].sh_type == SHT_REL)
 			err = apply_relocate(sechdrs, strtab, symindex, i,mod);
 		else if (sechdrs[i].sh_type == SHT_RELA)
 			err = apply_relocate_add(sechdrs, strtab, symindex, i,
 						 mod);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 		if (err < 0)
 			goto cleanup;
 	}
@@ -1854,14 +1954,31 @@ static struct module *load_module(void _
   	/* Set up and sort exception table */
 	mod->num_exentries = sechdrs[exindex].sh_size / sizeof(*mod->extable);
 	mod->extable = extable = (void *)sechdrs[exindex].sh_addr;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	sort_extable(extable, extable + mod->num_exentries);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	/* Finally, copy percpu area over. */
 	percpu_modcopy(mod->percpu, (void *)sechdrs[pcpuindex].sh_addr,
 		       sechdrs[pcpuindex].sh_size);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	add_kallsyms(mod, sechdrs, symindex, strindex, secstrings);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	err = module_finalize(hdr, sechdrs, mod);
 	if (err < 0)
 		goto cleanup;
@@ -1875,12 +1992,12 @@ static struct module *load_module(void _
 	 * Do it before processing of module parameters, so the module
 	 * can provide parameter accessor functions of its own.
 	 */
-	if (mod->module_init)
-		flush_icache_range((unsigned long)mod->module_init,
-				   (unsigned long)mod->module_init
-				   + mod->init_size);
-	flush_icache_range((unsigned long)mod->module_core,
-			   (unsigned long)mod->module_core + mod->core_size);
+	if (mod->module_init_rx)
+		flush_icache_range((unsigned long)mod->module_init_rx,
+				   (unsigned long)mod->module_init_rx
+				   + mod->init_size_rx);
+	flush_icache_range((unsigned long)mod->module_core_rx,
+			   (unsigned long)mod->module_core_rx + mod->core_size_rx);
 
 	set_fs(old_fs);
 
@@ -1923,9 +2040,13 @@ static struct module *load_module(void _
 	module_arch_cleanup(mod);
  cleanup:
 	module_unload_free(mod);
-	module_free(mod, mod->module_init);
- free_core:
-	module_free(mod, mod->module_core);
+	module_free_exec(mod, mod->module_init_rx);
+ free_core_rx:
+	module_free_exec(mod, mod->module_core_rx);
+ free_init_rw:
+	module_free(mod, mod->module_init_rw);
+ free_core_rw:
+	module_free(mod, mod->module_core_rw);
  free_percpu:
 	if (percpu)
 		percpu_modfree(percpu);
@@ -2012,10 +2133,12 @@ sys_init_module(void __user *umod,
 	/* Drop initial reference. */
 	module_put(mod);
 	unwind_remove_table(mod->unwind_info, 1);
-	module_free(mod, mod->module_init);
-	mod->module_init = NULL;
-	mod->init_size = 0;
-	mod->init_text_size = 0;
+	module_free(mod, mod->module_init_rw);
+	module_free_exec(mod, mod->module_init_rx);
+	mod->module_init_rw = NULL;
+	mod->module_init_rx = NULL;
+	mod->init_size_rw = 0;
+	mod->init_size_rx = 0;
 	mutex_unlock(&module_mutex);
 
 	return 0;
@@ -2046,10 +2169,14 @@ static const char *get_ksymbol(struct mo
 	unsigned long nextval;
 
 	/* At worse, next value is at end of module */
-	if (within(addr, mod->module_init, mod->init_size))
-		nextval = (unsigned long)mod->module_init+mod->init_text_size;
-	else 
-		nextval = (unsigned long)mod->module_core+mod->core_text_size;
+	if (within(addr, mod->module_init_rx, mod->init_size_rx))
+		nextval = (unsigned long)mod->module_init_rw;
+	else if (within(addr, mod->module_init_rw, mod->init_size_rw))
+		nextval = (unsigned long)mod->module_core_rx;
+	else if (within(addr, mod->module_core_rx, mod->core_size_rx))
+		nextval = (unsigned long)mod->module_core_rw;
+	else
+		nextval = (unsigned long)mod->module_core_rw+mod->core_size_rw;
 
 	/* Scan for closest preceeding symbol, and next symbol. (ELF
            starts real symbols at 1). */
@@ -2090,8 +2217,10 @@ const char *module_address_lookup(unsign
 	struct module *mod;
 
 	list_for_each_entry(mod, &modules, list) {
-		if (within(addr, mod->module_init, mod->init_size)
-		    || within(addr, mod->module_core, mod->core_size)) {
+		if (within(addr, mod->module_init_rx, mod->init_size_rx)
+		    || within(addr, mod->module_init_rw, mod->init_size_rw)
+		    || within(addr, mod->module_core_rx, mod->core_size_rx)
+		    || within(addr, mod->module_core_rw, mod->core_size_rw)) {
 			if (modname)
 				*modname = mod->name;
 			return get_ksymbol(mod, addr, size, offset);
@@ -2212,7 +2341,7 @@ static int m_show(struct seq_file *m, vo
 	char buf[8];
 
 	seq_printf(m, "%s %lu",
-		   mod->name, mod->init_size + mod->core_size);
+		   mod->name, mod->init_size_rx + mod->init_size_rw + mod->core_size_rx + mod->core_size_rw);
 	print_unload_info(m, mod);
 
 	/* Informative for users. */
@@ -2221,7 +2350,7 @@ static int m_show(struct seq_file *m, vo
 		   mod->state == MODULE_STATE_COMING ? "Loading":
 		   "Live");
 	/* Used by oprofile and other similar tools. */
-	seq_printf(m, " 0x%p", mod->module_core);
+	seq_printf(m, " 0x%p 0x%p", mod->module_core_rx, mod->module_core_rw);
 
 	/* Taints info */
 	if (mod->taints)
@@ -2279,7 +2408,8 @@ int is_module_address(unsigned long addr
 	spin_lock_irqsave(&modlist_lock, flags);
 
 	list_for_each_entry(mod, &modules, list) {
-		if (within(addr, mod->module_core, mod->core_size)) {
+		if (within(addr, mod->module_core_rx, mod->core_size_rx) ||
+		    within(addr, mod->module_core_rw, mod->core_size_rw)) {
 			spin_unlock_irqrestore(&modlist_lock, flags);
 			return 1;
 		}
@@ -2297,8 +2427,8 @@ struct module *__module_text_address(uns
 	struct module *mod;
 
 	list_for_each_entry(mod, &modules, list)
-		if (within(addr, mod->module_init, mod->init_text_size)
-		    || within(addr, mod->module_core, mod->core_text_size))
+		if (within(addr, mod->module_init_rx, mod->init_size_rx)
+		    || within(addr, mod->module_core_rx, mod->core_size_rx))
 			return mod;
 	return NULL;
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/mutex.c linux-2.6.20.1-pax/kernel/mutex.c
--- linux-2.6.20.1/kernel/mutex.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/mutex.c	2007-02-05 00:56:22.000000000 +0100
@@ -81,7 +81,7 @@ __mutex_lock_slowpath(atomic_t *lock_cou
  *
  * This function is similar to (but not equivalent to) down().
  */
-void inline fastcall __sched mutex_lock(struct mutex *lock)
+inline void fastcall __sched mutex_lock(struct mutex *lock)
 {
 	might_sleep();
 	/*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/pid.c linux-2.6.20.1-pax/kernel/pid.c
--- linux-2.6.20.1/kernel/pid.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/pid.c	2007-02-05 00:56:22.000000000 +0100
@@ -35,7 +35,7 @@ static struct kmem_cache *pid_cachep;
 
 int pid_max = PID_MAX_DEFAULT;
 
-#define RESERVED_PIDS		300
+#define RESERVED_PIDS		500
 
 int pid_max_min = RESERVED_PIDS + 1;
 int pid_max_max = PID_MAX_LIMIT;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/power/poweroff.c linux-2.6.20.1-pax/kernel/power/poweroff.c
--- linux-2.6.20.1/kernel/power/poweroff.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/power/poweroff.c	2007-02-05 00:56:22.000000000 +0100
@@ -35,7 +35,7 @@ static struct sysrq_key_op	sysrq_powerof
  	.enable_mask	= SYSRQ_ENABLE_BOOT,
 };
 
-static int pm_sysrq_init(void)
+static int __init pm_sysrq_init(void)
 {
 	register_sysrq_key('o', &sysrq_poweroff_op);
 	return 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/rcupdate.c linux-2.6.20.1-pax/kernel/rcupdate.c
--- linux-2.6.20.1/kernel/rcupdate.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/rcupdate.c	2007-02-15 02:25:20.000000000 +0100
@@ -63,11 +63,11 @@ static struct rcu_ctrlblk rcu_bh_ctrlblk
 	.cpumask = CPU_MASK_NONE,
 };
 
-DEFINE_PER_CPU(struct rcu_data, rcu_data) = { 0L };
-DEFINE_PER_CPU(struct rcu_data, rcu_bh_data) = { 0L };
+DEFINE_PER_CPU(struct rcu_data, rcu_data);
+DEFINE_PER_CPU(struct rcu_data, rcu_bh_data);
 
 /* Fake initialization required by compiler */
-static DEFINE_PER_CPU(struct tasklet_struct, rcu_tasklet) = {NULL};
+static DEFINE_PER_CPU(struct tasklet_struct, rcu_tasklet);
 static int blimit = 10;
 static int qhimark = 10000;
 static int qlowmark = 100;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/sys.c linux-2.6.20.1-pax/kernel/sys.c
--- linux-2.6.20.1/kernel/sys.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/sys.c	2007-02-05 00:56:22.000000000 +0100
@@ -2092,7 +2092,7 @@ asmlinkage long sys_prctl(int option, un
 			error = current->mm->dumpable;
 			break;
 		case PR_SET_DUMPABLE:
-			if (arg2 < 0 || arg2 > 1) {
+			if (arg2 > 1) {
 				error = -EINVAL;
 				break;
 			}
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/kernel/sysctl.c linux-2.6.20.1-pax/kernel/sysctl.c
--- linux-2.6.20.1/kernel/sysctl.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/kernel/sysctl.c	2007-02-15 02:23:26.000000000 +0100
@@ -155,7 +155,7 @@ static int proc_do_cad_pid(ctl_table *ta
 
 static ctl_table root_table[];
 static struct ctl_table_header root_table_header =
-	{ root_table, LIST_HEAD_INIT(root_table_header.ctl_entry) };
+	{ root_table, LIST_HEAD_INIT(root_table_header.ctl_entry), 0, NULL };
 
 static ctl_table kern_table[];
 static ctl_table vm_table[];
@@ -208,6 +208,21 @@ static void *get_ipc(ctl_table *table, i
 #define get_ipc(T,W) ((T)->data)
 #endif
 
+#ifdef CONFIG_PAX_SOFTMODE
+static ctl_table pax_table[] = {
+	{
+		.ctl_name	= PAX_SOFTMODE,
+		.procname	= "softmode",
+		.data		= &pax_softmode,
+		.maxlen		= sizeof(unsigned int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+
+	{ .ctl_name = 0 }
+};
+#endif
+
 /* /proc declarations: */
 
 #ifdef CONFIG_PROC_SYSCTL
@@ -781,6 +796,15 @@ static ctl_table kern_table[] = {
 	},
 #endif
 
+#ifdef CONFIG_PAX_SOFTMODE
+	{
+		.ctl_name	= KERN_PAX,
+		.procname	= "pax",
+		.mode		= 0500,
+		.child		= pax_table,
+	},
+#endif
+
 	{ .ctl_name = 0 }
 };
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/lib/radix-tree.c linux-2.6.20.1-pax/lib/radix-tree.c
--- linux-2.6.20.1/lib/radix-tree.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/lib/radix-tree.c	2007-02-15 10:49:34.000000000 +0100
@@ -76,7 +76,7 @@ struct radix_tree_preload {
 	int nr;
 	struct radix_tree_node *nodes[RADIX_TREE_MAX_PATH];
 };
-DEFINE_PER_CPU(struct radix_tree_preload, radix_tree_preloads) = { 0, };
+DEFINE_PER_CPU(struct radix_tree_preload, radix_tree_preloads) = { 0, {NULL} };
 
 static inline gfp_t root_gfp_mask(struct radix_tree_root *root)
 {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/filemap.c linux-2.6.20.1-pax/mm/filemap.c
--- linux-2.6.20.1/mm/filemap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/filemap.c	2007-02-05 00:56:22.000000000 +0100
@@ -1717,7 +1717,13 @@ int generic_file_mmap(struct file * file
 	struct address_space *mapping = file->f_mapping;
 
 	if (!mapping->a_ops->readpage)
-		return -ENOEXEC;
+		return -ENODEV;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+	if ((vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+		vma->vm_page_prot = __pgprot(pte_val(pte_exprotect(__pte(pgprot_val(vma->vm_page_prot)))));
+#endif
+
 	file_accessed(file);
 	vma->vm_ops = &generic_file_vm_ops;
 	return 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/filemap_xip.c linux-2.6.20.1-pax/mm/filemap_xip.c
--- linux-2.6.20.1/mm/filemap_xip.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/filemap_xip.c	2007-02-05 00:56:22.000000000 +0100
@@ -262,6 +262,11 @@ int xip_file_mmap(struct file * file, st
 {
 	BUG_ON(!file->f_mapping->a_ops->get_xip_page);
 
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+	if ((vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+		vma->vm_page_prot = __pgprot(pte_val(pte_exprotect(__pte(pgprot_val(vma->vm_page_prot)))));
+#endif
+
 	file_accessed(file);
 	vma->vm_ops = &xip_file_vm_ops;
 	return 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/madvise.c linux-2.6.20.1-pax/mm/madvise.c
--- linux-2.6.20.1/mm/madvise.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/madvise.c	2007-02-05 00:56:22.000000000 +0100
@@ -15,9 +15,46 @@
  * We can potentially split a vm area into separate
  * areas, each area with its own behavior.
  */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+static long __madvise_behavior(struct vm_area_struct * vma,
+		     struct vm_area_struct **prev,
+		     unsigned long start, unsigned long end, int behavior);
+
+static long madvise_behavior(struct vm_area_struct * vma,
+		     struct vm_area_struct **prev,
+		     unsigned long start, unsigned long end, int behavior)
+{
+	if (vma->vm_flags & VM_MIRROR) {
+		struct vm_area_struct * vma_m, * prev_m;
+		unsigned long start_m, end_m;
+		int error;
+
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(vma->vm_mm, start_m, &prev_m);
+		if (vma_m && vma_m->vm_start == start_m && (vma_m->vm_flags & VM_MIRROR)) {
+			start_m = start + vma->vm_mirror;
+			end_m = end + vma->vm_mirror;
+			error = __madvise_behavior(vma_m, &prev_m, start_m, end_m, behavior);
+			if (error)
+				return error;
+		} else {
+			printk("PAX: VMMIRROR: madvise bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+	}
+
+	return __madvise_behavior(vma, prev, start, end, behavior);
+}
+
+static long __madvise_behavior(struct vm_area_struct * vma,
+		     struct vm_area_struct **prev,
+		     unsigned long start, unsigned long end, int behavior)
+#else
 static long madvise_behavior(struct vm_area_struct * vma,
 		     struct vm_area_struct **prev,
 		     unsigned long start, unsigned long end, int behavior)
+#endif
 {
 	struct mm_struct * mm = vma->vm_mm;
 	int error = 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/memory.c linux-2.6.20.1-pax/mm/memory.c
--- linux-2.6.20.1/mm/memory.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/memory.c	2007-02-19 10:29:28.000000000 +0100
@@ -322,6 +322,11 @@ int __pte_alloc(struct mm_struct *mm, pm
 
 int __pte_alloc_kernel(pmd_t *pmd, unsigned long address)
 {
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	pte_t *new = pte_alloc_one_kernel(&init_mm, address);
 	if (!new)
 		return -ENOMEM;
@@ -329,8 +334,19 @@ int __pte_alloc_kernel(pmd_t *pmd, unsig
 	spin_lock(&init_mm.page_table_lock);
 	if (pmd_present(*pmd))		/* Another has populated it */
 		pte_free_kernel(new);
-	else
+	else {
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_open_kernel(cr0);
+#endif
+
 		pmd_populate_kernel(&init_mm, pmd, new);
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_close_kernel(cr0);
+#endif
+
+	}
 	spin_unlock(&init_mm.page_table_lock);
 	return 0;
 }
@@ -995,7 +1011,7 @@ int get_user_pages(struct task_struct *t
 		struct vm_area_struct *vma;
 		unsigned int foll_flags;
 
-		vma = find_extend_vma(mm, start);
+		vma = find_vma(mm, start);
 		if (!vma && in_gate_area(tsk, start)) {
 			unsigned long pg = start & PAGE_MASK;
 			struct vm_area_struct *gate_vma = get_gate_vma(tsk);
@@ -1035,7 +1051,7 @@ int get_user_pages(struct task_struct *t
 			continue;
 		}
 
-		if (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))
+		if (!vma || start < vma->vm_start || (vma->vm_flags & (VM_IO | VM_PFNMAP))
 				|| !(vm_flags & vma->vm_flags))
 			return i ? : -EFAULT;
 
@@ -1469,6 +1485,88 @@ static inline void cow_user_page(struct 
 	copy_user_highpage(dst, src, va, vma);
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+/* PaX: if vma is mirrored, synchronize the mirror's PTE
+ *
+ * the ptl of the lower mapped page is held on entry and is not released on exit
+ * or inside to ensure atomic changes to the PTE states (swapout, mremap, munmap, etc)
+ */
+static void pax_mirror_fault(struct vm_area_struct *vma, unsigned long address, pte_t *pte)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	unsigned long address_m, pfn_m;
+	struct vm_area_struct * vma_m = NULL;
+	pte_t * pte_m, entry_m;
+	struct page * page_m = NULL;
+
+	address_m = vma->vm_start + vma->vm_mirror;
+	vma_m = find_vma(mm, address_m);
+	BUG_ON(!vma_m || vma_m->vm_start != address_m);
+
+	address_m = address + vma->vm_mirror;
+	pte_m = pte_offset_map_nested(pmd_offset(pud_offset(pgd_offset(mm, address_m), address_m), address_m), address_m);
+
+	if (pte_same(*pte, *pte_m)) {
+		pte_unmap_nested(pte_m);
+		return;
+	}
+
+	pfn_m = pte_pfn(*pte);
+	if (pte_present(*pte_m)) {
+		page_m = vm_normal_page(vma_m, address_m, *pte_m);
+		if (page_m) {
+			flush_cache_page(vma_m, address_m, pfn_m);
+			flush_icache_page(vma_m, page_m);
+		}
+	}
+
+	if (pte_present(*pte_m))
+		entry_m = ptep_clear_flush(vma_m, address_m, pte_m);
+	else
+		entry_m = ptep_get_and_clear(mm, address_m, pte_m);
+
+	if (pte_none(entry_m)) {
+	} else if (pte_present(entry_m)) {
+		if (page_m) {
+			page_remove_rmap(page_m, vma_m);
+			if (PageAnon(page_m))
+				dec_mm_counter(mm, anon_rss);
+			else
+				dec_mm_counter(mm, file_rss);
+			page_cache_release(page_m);
+		}
+	} else if (!pte_file(entry_m)) {
+		free_swap_and_cache(pte_to_swp_entry(entry_m));
+	} else {
+		printk(KERN_ERR "PAX: VMMIRROR: bug in mirror_fault: %08lx, %08lx, %08lx, %08lx\n",
+				address, vma->vm_start, address_m, vma_m->vm_start);
+	}
+
+	page_m = vm_normal_page(vma, address, *pte);
+	entry_m = pfn_pte(pfn_m, vma_m->vm_page_prot);
+	if (pte_write(*pte))
+		entry_m = maybe_mkwrite(pte_mkdirty(entry_m), vma_m);
+	if (page_m) {
+		page_cache_get(page_m);
+		/*
+		 * we can test PAGE_MAPPING_ANON without holding page_map_lock because
+		 * we hold the page table lock and have a reference to page_m
+		 */
+		if (PageAnon(page_m)) {
+			page_add_anon_rmap(page_m, vma_m, address_m);
+			inc_mm_counter(mm, anon_rss);
+		} else {
+			page_add_file_rmap(page_m);
+			inc_mm_counter(mm, file_rss);
+		}
+	}
+	set_pte_at(mm, address_m, pte_m, entry_m);
+	update_mmu_cache(vma_m, address_m, entry_m);
+	lazy_mmu_prot_update(entry_m);
+	pte_unmap_nested(pte_m);
+}
+#endif
+
 /*
  * This routine handles present pages, when users try to write
  * to a shared page. It is done by copying the page to a new address
@@ -1612,6 +1710,12 @@ gotten:
 		/* Free the old page.. */
 		new_page = old_page;
 		ret |= VM_FAULT_WRITE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			pax_mirror_fault(vma, address, page_table);
+#endif
+
 	}
 	if (new_page)
 		page_cache_release(new_page);
@@ -2064,6 +2168,12 @@ static int do_swap_page(struct mm_struct
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, address, pte);
 	lazy_mmu_prot_update(pte);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, page_table);
+#endif
+
 unlock:
 	pte_unmap_unlock(page_table, ptl);
 out:
@@ -2126,6 +2236,12 @@ static int do_anonymous_page(struct mm_s
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, address, entry);
 	lazy_mmu_prot_update(entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, page_table);
+#endif
+
 unlock:
 	pte_unmap_unlock(page_table, ptl);
 	return VM_FAULT_MINOR;
@@ -2271,6 +2387,12 @@ retry:
 	/* no need to invalidate: a not-present page shouldn't be cached */
 	update_mmu_cache(vma, address, entry);
 	lazy_mmu_prot_update(entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, page_table);
+#endif
+
 unlock:
 	pte_unmap_unlock(page_table, ptl);
 	if (dirty_page) {
@@ -2438,6 +2560,12 @@ static inline int handle_pte_fault(struc
 			flush_tlb_page(vma, address);
 	}
 unlock:
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, pte);
+#endif
+
 	pte_unmap_unlock(pte, ptl);
 	return VM_FAULT_MINOR;
 }
@@ -2460,6 +2588,49 @@ int __handle_mm_fault(struct mm_struct *
 	if (unlikely(is_vm_hugetlb_page(vma)))
 		return hugetlb_fault(mm, vma, address, write_access);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		unsigned long address_m;
+		struct vm_area_struct * vma_m;
+		pgd_t *pgd_m;
+		pud_t *pud_m;
+		pmd_t *pmd_m;
+
+		address_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma(mm, address_m);
+
+		/* PaX: sanity checks */
+		if (!vma_m) {
+			printk(KERN_ERR "PAX: VMMIRROR: fault bug, %08lx, %p, %08lx, %p\n",
+			       address, vma, address_m, vma_m);
+			return VM_FAULT_SIGBUS;
+		} else if (!(vma_m->vm_flags & VM_MIRROR) ||
+			vma_m->vm_start != address_m ||
+			vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start)
+		{
+			printk(KERN_ERR "PAX: VMMIRROR: fault bug2, %08lx, %08lx, %08lx, %08lx, %08lx\n",
+			       address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+			return VM_FAULT_SIGBUS;
+		}
+
+		if (address_m < address) {
+			address += vma->vm_mirror;
+			vma = vma_m;
+		}
+
+		address_m = address + vma->vm_mirror;
+		pgd_m = pgd_offset(mm, address_m);
+		pud_m = pud_alloc(mm, pgd_m, address_m);
+		if (!pud_m)
+			return VM_FAULT_OOM;
+		pmd_m = pmd_alloc(mm, pud_m, address_m);
+		if (!pmd_m)
+			return VM_FAULT_OOM;
+		if (!pmd_present(*pmd_m) && __pte_alloc(mm, pmd_m, address_m))
+			return VM_FAULT_OOM;
+	}
+#endif
+
 	pgd = pgd_offset(mm, address);
 	pud = pud_alloc(mm, pgd, address);
 	if (!pud)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/mempolicy.c linux-2.6.20.1-pax/mm/mempolicy.c
--- linux-2.6.20.1/mm/mempolicy.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/mempolicy.c	2007-02-05 00:56:23.000000000 +0100
@@ -355,6 +355,12 @@ check_range(struct mm_struct *mm, unsign
 			if (prev && prev->vm_end < vma->vm_start)
 				return ERR_PTR(-EFAULT);
 		}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			return ERR_PTR(-EFAULT);
+#endif
+
 		if (!is_vm_hugetlb_page(vma) &&
 		    ((flags & MPOL_MF_STRICT) ||
 		     ((flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) &&
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/mlock.c linux-2.6.20.1-pax/mm/mlock.c
--- linux-2.6.20.1/mm/mlock.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/mlock.c	2007-02-05 00:56:23.000000000 +0100
@@ -12,42 +12,44 @@
 #include <linux/syscalls.h>
 
 
+static int __mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
+	unsigned long start, unsigned long end, unsigned int newflags);
+
 static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
 	unsigned long start, unsigned long end, unsigned int newflags)
 {
 	struct mm_struct * mm = vma->vm_mm;
-	pgoff_t pgoff;
 	int pages;
-	int ret = 0;
-
-	if (newflags == vma->vm_flags) {
-		*prev = vma;
-		goto out;
-	}
-
-	pgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);
-	*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,
-			  vma->vm_file, pgoff, vma_policy(vma));
-	if (*prev) {
-		vma = *prev;
-		goto success;
-	}
+	int ret;
 
-	*prev = vma;
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL, *prev_m;
+	unsigned long start_m = 0UL, end_m = 0UL, newflags_m = 0UL;
+
+	if (vma->vm_flags & VM_MIRROR) {
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(mm, start_m, &prev_m);
+		if (!vma_m || vma_m->vm_start != start_m || !(vma_m->vm_flags & VM_MIRROR)) {
+			printk("PAX: VMMIRROR: mlock bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
 
-	if (start != vma->vm_start) {
-		ret = split_vma(mm, vma, start, 1);
+		start_m = start + vma->vm_mirror;
+		end_m = end + vma->vm_mirror;
+		if (newflags & VM_LOCKED)
+			newflags_m = vma_m->vm_flags | VM_LOCKED;
+		else
+			newflags_m = vma_m->vm_flags & ~VM_LOCKED;
+		ret = __mlock_fixup(vma_m, &prev_m, start_m, end_m, newflags_m);
 		if (ret)
-			goto out;
+			return ret;
 	}
+#endif
 
-	if (end != vma->vm_end) {
-		ret = split_vma(mm, vma, end, 0);
-		if (ret)
-			goto out;
-	}
+	ret = __mlock_fixup(vma, prev, start, end, newflags);
+	if (ret)
+		return ret;
 
-success:
 	/*
 	 * vm_flags is protected by the mmap_sem held in write mode.
 	 * It's okay if try_to_unmap_one unmaps a page just after we
@@ -55,6 +57,11 @@ success:
 	 */
 	vma->vm_flags = newflags;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		vma_m->vm_flags = newflags_m;
+#endif
+
 	/*
 	 * Keep track of amount of locked VM.
 	 */
@@ -66,6 +73,48 @@ success:
 	}
 
 	vx_vmlocked_sub(mm, pages);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		mm->locked_vm -= pages;
+#endif
+
+	if (ret == -ENOMEM)
+		ret = -EAGAIN;
+	return ret;
+}
+
+static int __mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	struct mm_struct * mm = vma->vm_mm;
+	pgoff_t pgoff;
+	int ret = 0;
+
+	if (newflags == vma->vm_flags) {
+		*prev = vma;
+		goto out;
+	}
+
+	pgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);
+	*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,
+			  vma->vm_file, pgoff, vma_policy(vma));
+	if (*prev) {
+		vma = *prev;
+		goto out;
+	}
+
+	*prev = vma;
+
+	if (start != vma->vm_start) {
+		ret = split_vma(mm, vma, start, 1);
+		if (ret)
+			goto out;
+	}
+
+	if (end != vma->vm_end)
+		ret = split_vma(mm, vma, end, 0);
+
 out:
 	if (ret == -ENOMEM)
 		ret = -EAGAIN;
@@ -84,6 +133,17 @@ static int do_mlock(unsigned long start,
 		return -EINVAL;
 	if (end == start)
 		return 0;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	vma = find_vma_prev(current->mm, start, &prev);
 	if (!vma || vma->vm_start > start)
 		return -ENOMEM;
@@ -173,6 +233,16 @@ static int do_mlockall(int flags)
 	for (vma = current->mm->mmap; vma ; vma = prev->vm_next) {
 		unsigned int newflags;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+			if (vma->vm_end > SEGMEXEC_TASK_SIZE)
+				break;
+		} else
+#endif
+
+		if (vma->vm_end > TASK_SIZE)
+			break;
+
 		newflags = vma->vm_flags | VM_LOCKED;
 		if (!(flags & MCL_CURRENT))
 			newflags &= ~VM_LOCKED;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/mmap.c linux-2.6.20.1-pax/mm/mmap.c
--- linux-2.6.20.1/mm/mmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/mmap.c	2007-02-05 00:56:23.000000000 +0100
@@ -639,11 +639,17 @@ again:			remove_next = 1 + (end > next->
  * If the vma has a ->close operation then the driver probably needs to release
  * per-vma resources, so we don't attempt to merge those.
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+#define VM_SPECIAL (VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_PFNMAP | VM_MIRROR)
+#else
 #define VM_SPECIAL (VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_PFNMAP)
+#endif
 
 static inline int is_mergeable_vma(struct vm_area_struct *vma,
 			struct file *file, unsigned long vm_flags)
 {
+	if ((vma->vm_flags | vm_flags) & VM_SPECIAL)
+		return 0;
 	if (vma->vm_flags != vm_flags)
 		return 0;
 	if (vma->vm_file != file)
@@ -868,14 +874,11 @@ none:
 void vm_stat_account(struct mm_struct *mm, unsigned long flags,
 						struct file *file, long pages)
 {
-	const unsigned long stack_flags
-		= VM_STACK_FLAGS & (VM_GROWSUP|VM_GROWSDOWN);
-
 	if (file) {
 		mm->shared_vm += pages;
 		if ((flags & (VM_EXEC|VM_WRITE)) == VM_EXEC)
 			mm->exec_vm += pages;
-	} else if (flags & stack_flags)
+	} else if (flags & (VM_GROWSUP|VM_GROWSDOWN))
 		mm->stack_vm += pages;
 	if (flags & (VM_RESERVED|VM_IO))
 		mm->reserved_vm += pages;
@@ -886,9 +889,54 @@ void vm_stat_account(struct mm_struct *m
  * The caller must hold down_write(current->mm->mmap_sem).
  */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+static unsigned long __do_mmap_pgoff(struct file * file, unsigned long addr,
+			unsigned long len, unsigned long prot,
+			unsigned long flags, unsigned long pgoff);
+
+unsigned long do_mmap_pgoff(struct file * file, unsigned long addr,
+			unsigned long len, unsigned long prot,
+			unsigned long flags, unsigned long pgoff)
+{
+	unsigned long ret = -EINVAL;
+
+	if (flags & MAP_MIRROR)
+		return ret;
+
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || (addr > SEGMEXEC_TASK_SIZE-len)))
+		return ret;
+
+	ret = __do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && ret < TASK_SIZE && ((flags & MAP_TYPE) == MAP_PRIVATE)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && (!(current->mm->pax_flags & MF_PAX_MPROTECT) || ((prot & PROT_EXEC) && file && !(prot & PROT_WRITE)))
+#endif
+
+	   )
+	{
+		unsigned long ret_m;
+		prot = prot & PROT_EXEC ? prot & ~PROT_WRITE : PROT_NONE;
+		ret_m = __do_mmap_pgoff(NULL, ret + SEGMEXEC_TASK_SIZE, 0UL, prot, flags | MAP_MIRROR | MAP_FIXED, ret);
+		if (ret_m >= TASK_SIZE) {
+			do_munmap(current->mm, ret, len);
+			ret = ret_m;
+		}
+	}
+
+	return ret;
+}
+
+static unsigned long __do_mmap_pgoff(struct file * file, unsigned long addr,
+			unsigned long len, unsigned long prot,
+			unsigned long flags, unsigned long pgoff)
+#else
 unsigned long do_mmap_pgoff(struct file * file, unsigned long addr,
 			unsigned long len, unsigned long prot,
 			unsigned long flags, unsigned long pgoff)
+#endif
 {
 	struct mm_struct * mm = current->mm;
 	struct vm_area_struct * vma, * prev;
@@ -900,13 +948,35 @@ unsigned long do_mmap_pgoff(struct file 
 	int accountable = 1;
 	unsigned long charged = 0, reqprot = prot;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+
+	if (flags & MAP_MIRROR) {
+		/* PaX: sanity checks, to be removed when proved to be stable */
+		if (file || len || ((flags & MAP_TYPE) != MAP_PRIVATE))
+			return -EINVAL;
+
+		vma_m = find_vma(mm, pgoff);
+
+		if (!vma_m || is_vm_hugetlb_page(vma_m) ||
+		    vma_m->vm_start != pgoff ||
+		    (vma_m->vm_flags & VM_SPECIAL) ||
+		    (prot & PROT_WRITE))
+			return -EINVAL;
+
+		file = vma_m->vm_file;
+		pgoff = vma_m->vm_pgoff;
+		len = vma_m->vm_end - vma_m->vm_start;
+	}
+#endif
+
 	/*
 	 * Does the application expect PROT_READ to imply PROT_EXEC?
 	 *
 	 * (the exception is when the underlying filesystem is noexec
 	 *  mounted, in which case we dont add PROT_EXEC.)
 	 */
-	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+	if ((prot & (PROT_READ | PROT_WRITE)) && (current->personality & READ_IMPLIES_EXEC))
 		if (!(file && (file->f_path.mnt->mnt_flags & MNT_NOEXEC)))
 			prot |= PROT_EXEC;
 
@@ -933,7 +1003,7 @@ unsigned long do_mmap_pgoff(struct file 
 	/* Obtain the address to map to. we verify (or select) it and ensure
 	 * that it represents a valid section of the address space.
 	 */
-	addr = get_unmapped_area(file, addr, len, pgoff, flags);
+	addr = get_unmapped_area(file, addr, len, pgoff, flags | ((prot & PROT_EXEC) ? MAP_EXECUTABLE : 0));
 	if (addr & ~PAGE_MASK)
 		return addr;
 
@@ -944,6 +1014,21 @@ unsigned long do_mmap_pgoff(struct file 
 	vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |
 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT) {
+			if ((prot & (PROT_WRITE | PROT_EXEC)) != PROT_EXEC)
+				vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+			else
+				vm_flags &= ~(VM_WRITE | VM_MAYWRITE);
+		}
+#endif
+
+	}
+#endif
+
 	if (flags & MAP_LOCKED) {
 		if (!can_do_mlock())
 			return -EPERM;
@@ -1013,6 +1098,11 @@ unsigned long do_mmap_pgoff(struct file 
 			/*
 			 * Set pgoff according to addr for anon_vma.
 			 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (!(flags & MAP_MIRROR))
+#endif
+
 			pgoff = addr >> PAGE_SHIFT;
 			break;
 		default:
@@ -1026,12 +1116,12 @@ unsigned long do_mmap_pgoff(struct file 
 		
 	/* Clear old maps */
 	error = -ENOMEM;
-munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
 	if (vma && vma->vm_start < addr + len) {
 		if (do_munmap(mm, addr, len))
 			return -ENOMEM;
-		goto munmap_back;
+		vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
+		BUG_ON(vma && vma->vm_start < addr + len);
 	}
 
 	/* Check against address space limit. */
@@ -1079,6 +1169,13 @@ munmap_back:
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 	vma->vm_flags = vm_flags;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+	if ((file || !(mm->pax_flags & MF_PAX_PAGEEXEC)) && (vm_flags & (VM_READ|VM_WRITE)))
+		vma->vm_page_prot = protection_map[(vm_flags | VM_EXEC) & (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];
+	else
+#endif
+
 	vma->vm_page_prot = protection_map[vm_flags &
 				(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];
 	vma->vm_pgoff = pgoff;
@@ -1104,6 +1201,14 @@ munmap_back:
 			goto free_vma;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR) {
+		vma_m->vm_flags |= VM_MIRROR;
+		vma_m->vm_mirror = vma->vm_start - vma_m->vm_start;
+		vma->vm_mirror = vma_m->vm_start - vma->vm_start;
+	}
+#endif
+
 	/* We set VM_ACCOUNT in a shared mapping's vm_flags, to inform
 	 * shmem_zero_setup (perhaps called through /dev/zero's ->mmap)
 	 * that memory reservation must be checked; but that reservation
@@ -1121,9 +1226,17 @@ munmap_back:
 	pgoff = vma->vm_pgoff;
 	vm_flags = vma->vm_flags;
 
-	if (vma_wants_writenotify(vma))
+	if (vma_wants_writenotify(vma)) {
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+		if ((file || !(mm->pax_flags & MF_PAX_PAGEEXEC)) && (vm_flags & (VM_READ|VM_WRITE)))
+			vma->vm_page_prot = protection_map[(vm_flags | VM_EXEC) & (VM_READ|VM_WRITE|VM_EXEC)];
+		else
+#endif
+
 		vma->vm_page_prot =
 			protection_map[vm_flags & (VM_READ|VM_WRITE|VM_EXEC)];
+	}
 
 	if (!file || !vma_merge(mm, prev, addr, vma->vm_end,
 			vma->vm_flags, NULL, file, pgoff, vma_policy(vma))) {
@@ -1143,6 +1256,7 @@ munmap_back:
 out:	
 	mm->total_vm += len >> PAGE_SHIFT;
 	vm_stat_account(mm, vm_flags, file, len >> PAGE_SHIFT);
+	track_exec_limit(mm, addr, addr + len, vm_flags);
 	if (vm_flags & VM_LOCKED) {
 		mm->locked_vm += len >> PAGE_SHIFT;
 		make_pages_present(addr, addr + len);
@@ -1197,6 +1311,10 @@ arch_get_unmapped_area(struct file *filp
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
@@ -1207,7 +1325,7 @@ arch_get_unmapped_area(struct file *filp
 	if (len > mm->cached_hole_size) {
 	        start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
+	        start_addr = addr = mm->mmap_base;
 	        mm->cached_hole_size = 0;
 	}
 
@@ -1219,9 +1337,8 @@ full_search:
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				addr = TASK_UNMAPPED_BASE;
-			        start_addr = addr;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
@@ -1246,7 +1363,7 @@ void arch_unmap_area(struct mm_struct *m
 	/*
 	 * Is this a new hole at the lowest possible address?
 	 */
-	if (addr >= TASK_UNMAPPED_BASE && addr < mm->free_area_cache) {
+	if (addr >= mm->mmap_base && addr < mm->free_area_cache) {
 		mm->free_area_cache = addr;
 		mm->cached_hole_size = ~0UL;
 	}
@@ -1264,12 +1381,16 @@ arch_get_unmapped_area_topdown(struct fi
 {
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
-	unsigned long addr = addr0;
+	unsigned long base = mm->mmap_base, addr = addr0;
 
 	/* requested length too big for entire address space */
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
@@ -1327,13 +1448,21 @@ bottomup:
 	 * can happen with large stack limits and large mmap()
 	 * allocations.
 	 */
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
 	mm->cached_hole_size = ~0UL;
-  	mm->free_area_cache = TASK_UNMAPPED_BASE;
 	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
 	/*
 	 * Restore the topdown base:
 	 */
-	mm->free_area_cache = mm->mmap_base;
+	mm->mmap_base = base;
+	mm->free_area_cache = base;
 	mm->cached_hole_size = ~0UL;
 
 	return addr;
@@ -1349,8 +1478,10 @@ void arch_unmap_area_topdown(struct mm_s
 		mm->free_area_cache = addr;
 
 	/* dont allow allocations above current base */
-	if (mm->free_area_cache > mm->mmap_base)
+	if (mm->free_area_cache > mm->mmap_base) {
 		mm->free_area_cache = mm->mmap_base;
+		mm->cached_hole_size = ~0UL;
+	}
 }
 
 unsigned long
@@ -1571,23 +1702,6 @@ int expand_stack(struct vm_area_struct *
 {
 	return expand_upwards(vma, address);
 }
-
-struct vm_area_struct *
-find_extend_vma(struct mm_struct *mm, unsigned long addr)
-{
-	struct vm_area_struct *vma, *prev;
-
-	addr &= PAGE_MASK;
-	vma = find_vma_prev(mm, addr, &prev);
-	if (vma && (vma->vm_start <= addr))
-		return vma;
-	if (!prev || expand_stack(prev, addr))
-		return NULL;
-	if (prev->vm_flags & VM_LOCKED) {
-		make_pages_present(addr, prev->vm_end);
-	}
-	return prev;
-}
 #else
 /*
  * vma is the first one with address < vma->vm_start.  Have to extend vma.
@@ -1616,41 +1730,54 @@ int expand_stack(struct vm_area_struct *
 	if (address < vma->vm_start) {
 		unsigned long size, grow;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		struct vm_area_struct *vma_m = NULL;
+		unsigned long address_m = 0UL;
+
+		if (vma->vm_flags & VM_MIRROR) {
+			address_m = vma->vm_start + vma->vm_mirror;
+			vma_m = find_vma(vma->vm_mm, address_m);
+			if (!vma_m || vma_m->vm_start != address_m ||
+			    !(vma_m->vm_flags & VM_MIRROR) ||
+			    vma->vm_end - vma->vm_start !=
+			    vma_m->vm_end - vma_m->vm_start ||
+			    vma->anon_vma != vma_m->anon_vma) {
+				printk(KERN_ERR "PAX: VMMIRROR: expand bug, %08lx, %08lx, %08lx, %08lx, %08lx\n",
+				       address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+				anon_vma_unlock(vma);
+				return -EFAULT;
+			}
+			address_m = address + vma->vm_mirror;
+		}
+#endif
+
 		size = vma->vm_end - address;
 		grow = (vma->vm_start - address) >> PAGE_SHIFT;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma_m)
+			error = acct_stack_growth(vma, size, 2*grow);
+		else
+#endif
+
 		error = acct_stack_growth(vma, size, grow);
 		if (!error) {
 			vma->vm_start = address;
 			vma->vm_pgoff -= grow;
+			track_exec_limit(vma->vm_mm, vma->vm_start, vma->vm_end, vma->vm_flags);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (vma_m) {
+				vma_m->vm_start = address_m;
+				vma_m->vm_pgoff -= grow;
+			}
+#endif
+
 		}
 	}
 	anon_vma_unlock(vma);
 	return error;
 }
-
-struct vm_area_struct *
-find_extend_vma(struct mm_struct * mm, unsigned long addr)
-{
-	struct vm_area_struct * vma;
-	unsigned long start;
-
-	addr &= PAGE_MASK;
-	vma = find_vma(mm,addr);
-	if (!vma)
-		return NULL;
-	if (vma->vm_start <= addr)
-		return vma;
-	if (!(vma->vm_flags & VM_GROWSDOWN))
-		return NULL;
-	start = vma->vm_start;
-	if (expand_stack(vma, addr))
-		return NULL;
-	if (vma->vm_flags & VM_LOCKED) {
-		make_pages_present(addr, start);
-	}
-	return vma;
-}
 #endif
 
 /*
@@ -1784,8 +1911,25 @@ int split_vma(struct mm_struct * mm, str
  * work.  This now handles partial unmappings.
  * Jeremy Fitzhardinge <jeremy@goop.org>
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+static int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len);
+
 int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
 {
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		int ret = __do_munmap(mm, start + SEGMEXEC_TASK_SIZE, len);
+		if (ret)
+			return ret;
+	}
+
+	return __do_munmap(mm, start, len);
+}
+
+static int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
+#else
+int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
+#endif
+{
 	unsigned long end;
 	struct vm_area_struct *vma, *prev, *last;
 
@@ -1838,6 +1982,8 @@ int do_munmap(struct mm_struct *mm, unsi
 	/* Fix up all other VM information */
 	remove_vma_list(mm, vma);
 
+	track_exec_limit(mm, start, end, 0UL);
+
 	return 0;
 }
 
@@ -1850,6 +1996,12 @@ asmlinkage long sys_munmap(unsigned long
 
 	profile_munmap(addr);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || addr > SEGMEXEC_TASK_SIZE-len))
+		return -EINVAL;
+#endif
+
 	down_write(&mm->mmap_sem);
 	ret = do_munmap(mm, addr, len);
 	up_write(&mm->mmap_sem);
@@ -1871,11 +2023,35 @@ static inline void verify_mm_writelocked
  *  anonymous maps.  eventually we may be able to do some
  *  brk-specific accounting here.
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+static unsigned long __do_brk(unsigned long addr, unsigned long len);
+
 unsigned long do_brk(unsigned long addr, unsigned long len)
 {
+	unsigned long ret;
+
+	ret = __do_brk(addr, len);
+	if (ret == addr && (current->mm->pax_flags & (MF_PAX_SEGMEXEC | MF_PAX_MPROTECT)) == MF_PAX_SEGMEXEC) {
+		unsigned long ret_m;
+
+		ret_m = __do_mmap_pgoff(NULL, addr + SEGMEXEC_TASK_SIZE, 0UL, PROT_NONE, MAP_PRIVATE | MAP_FIXED | MAP_MIRROR, addr);
+		if (ret_m > TASK_SIZE) {
+			do_munmap(current->mm, addr, len);
+			ret = ret_m;
+		}
+	}
+
+	return ret;
+}
+
+static unsigned long __do_brk(unsigned long addr, unsigned long len)
+#else
+unsigned long do_brk(unsigned long addr, unsigned long len)
+#endif
+{
 	struct mm_struct * mm = current->mm;
 	struct vm_area_struct * vma, * prev;
-	unsigned long flags;
+	unsigned long flags, task_size = TASK_SIZE;
 	struct rb_node ** rb_link, * rb_parent;
 	pgoff_t pgoff = addr >> PAGE_SHIFT;
 	int error;
@@ -1884,7 +2060,12 @@ unsigned long do_brk(unsigned long addr,
 	if (!len)
 		return addr;
 
-	if ((addr + len) > TASK_SIZE || (addr + len) < addr)
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if ((addr + len) > task_size || (addr + len) < addr)
 		return -EINVAL;
 
 	if (is_hugepage_only_range(mm, addr, len))
@@ -1892,6 +2073,18 @@ unsigned long do_brk(unsigned long addr,
 
 	flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		flags &= ~VM_EXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT)
+			flags &= ~VM_MAYEXEC;
+#endif
+
+	}
+#endif
+
 	error = arch_mmap_check(addr, len, flags);
 	if (error)
 		return error;
@@ -1918,12 +2111,12 @@ unsigned long do_brk(unsigned long addr,
 	/*
 	 * Clear old maps.  this also does some error checking for us
 	 */
- munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
 	if (vma && vma->vm_start < addr + len) {
 		if (do_munmap(mm, addr, len))
 			return -ENOMEM;
-		goto munmap_back;
+		vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
+		BUG_ON(vma && vma->vm_start < addr + len);
 	}
 
 	/* Check against address space limits *after* clearing old maps... */
@@ -1955,6 +2148,13 @@ unsigned long do_brk(unsigned long addr,
 	vma->vm_end = addr + len;
 	vma->vm_pgoff = pgoff;
 	vma->vm_flags = flags;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+	if (!(mm->pax_flags & MF_PAX_PAGEEXEC))
+		vma->vm_page_prot = protection_map[(flags | VM_EXEC) & (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];
+	else
+#endif
+
 	vma->vm_page_prot = protection_map[flags &
 				(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];
 	vma_link(mm, vma, prev, rb_link, rb_parent);
@@ -1964,6 +2164,7 @@ out:
 		mm->locked_vm += len >> PAGE_SHIFT;
 		make_pages_present(addr, addr + len);
 	}
+	track_exec_limit(mm, addr, addr + len, flags);
 	return addr;
 }
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/mprotect.c linux-2.6.20.1-pax/mm/mprotect.c
--- linux-2.6.20.1/mm/mprotect.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/mprotect.c	2007-02-05 00:56:23.000000000 +0100
@@ -21,10 +21,16 @@
 #include <linux/syscalls.h>
 #include <linux/swap.h>
 #include <linux/swapops.h>
+
+#ifdef CONFIG_PAX_MPROTECT
+#include <linux/elf.h>
+#endif
+
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
+#include <asm/mmu_context.h>
 
 static void change_pte_range(struct mm_struct *mm, pmd_t *pmd,
 		unsigned long addr, unsigned long end, pgprot_t newprot,
@@ -128,6 +134,94 @@ static void change_protection(struct vm_
 	flush_tlb_range(vma, start, end);
 }
 
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+/* called while holding the mmap semaphor for writing */
+static inline void establish_user_cs_limit(struct mm_struct *mm, unsigned long start, unsigned long end)
+{
+	struct vm_area_struct *vma = find_vma(mm, start);
+
+	for (; vma && vma->vm_start < end; vma = vma->vm_next)
+		change_protection(vma, vma->vm_start, vma->vm_end, vma->vm_page_prot, vma_wants_writenotify(vma));
+
+}
+
+void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot)
+{
+	unsigned long oldlimit, newlimit = 0UL;
+
+	if (!(mm->pax_flags & MF_PAX_PAGEEXEC))
+		return;
+
+	spin_lock(&mm->page_table_lock);
+	oldlimit = mm->context.user_cs_limit;
+	if ((prot & VM_EXEC) && oldlimit < end)
+		/* USER_CS limit moved up */
+		newlimit = end;
+	else if (!(prot & VM_EXEC) && start < oldlimit && oldlimit <= end)
+		/* USER_CS limit moved down */
+		newlimit = start;
+
+	if (newlimit) {
+		mm->context.user_cs_limit = newlimit;
+
+#ifdef CONFIG_SMP
+		wmb();
+		cpus_clear(mm->context.cpu_user_cs_mask);
+		cpu_set(smp_processor_id(), mm->context.cpu_user_cs_mask);
+#endif
+
+		set_user_cs(mm, smp_processor_id());
+	}
+	spin_unlock(&mm->page_table_lock);
+	if (newlimit == end)
+		establish_user_cs_limit(mm, oldlimit, end);
+}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+static int __mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
+	unsigned long start, unsigned long end, unsigned int newflags);
+
+static int mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	if (vma->vm_flags & VM_MIRROR) {
+		struct vm_area_struct * vma_m, * prev_m;
+		unsigned long start_m, end_m;
+		int error;
+
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(vma->vm_mm, start_m, &prev_m);
+		if (vma_m && vma_m->vm_start == start_m && (vma_m->vm_flags & VM_MIRROR)) {
+			start_m = start + vma->vm_mirror;
+			end_m = end + vma->vm_mirror;
+
+			if (vma_m->vm_start >= SEGMEXEC_TASK_SIZE && !(newflags & VM_EXEC))
+				error = __mprotect_fixup(vma_m, &prev_m, start_m, end_m, vma_m->vm_flags & ~(VM_READ | VM_WRITE | VM_EXEC));
+			else
+				error = __mprotect_fixup(vma_m, &prev_m, start_m, end_m, newflags);
+			if (error)
+				return error;
+		} else {
+			printk("PAX: VMMIRROR: mprotect bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+	}
+
+	return __mprotect_fixup(vma, pprev, start, end, newflags);
+}
+
+static int __mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	struct mm_struct * mm = vma->vm_mm;
+	unsigned long oldflags = vma->vm_flags;
+	long nrpages = (end - start) >> PAGE_SHIFT;
+	unsigned long charged = 0;
+	pgoff_t pgoff;
+	int error;
+	int dirty_accountable = 0;
+#else
 static int
 mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
 	unsigned long start, unsigned long end, unsigned long newflags)
@@ -144,6 +238,7 @@ mprotect_fixup(struct vm_area_struct *vm
 		*pprev = vma;
 		return 0;
 	}
+#endif
 
 	/*
 	 * If we make a private mapping writable we increase our commit;
@@ -193,12 +288,29 @@ success:
 	 * held in write mode.
 	 */
 	vma->vm_flags = newflags;
-	vma->vm_page_prot = protection_map[newflags &
-		(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];
 	if (vma_wants_writenotify(vma)) {
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+		if (!(mm->pax_flags & MF_PAX_PAGEEXEC) && (newflags & (VM_READ|VM_WRITE)))
+			vma->vm_page_prot = protection_map[(newflags | VM_EXEC) &
+				(VM_READ|VM_WRITE|VM_EXEC)];
+		else
+#endif
+
 		vma->vm_page_prot = protection_map[newflags &
 			(VM_READ|VM_WRITE|VM_EXEC)];
 		dirty_accountable = 1;
+	} else {
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+		if (!(mm->pax_flags & MF_PAX_PAGEEXEC) && (newflags & (VM_READ|VM_WRITE)))
+			vma->vm_page_prot = protection_map[(newflags | VM_EXEC) &
+				(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];
+		else
+#endif
+
+		vma->vm_page_prot = protection_map[newflags &
+			(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];
 	}
 
 	if (is_vm_hugetlb_page(vma))
@@ -214,6 +326,68 @@ fail:
 	return error;
 }
 
+#ifdef CONFIG_PAX_MPROTECT
+/* PaX: non-PIC ELF libraries need relocations on their executable segments
+ * therefore we'll grant them VM_MAYWRITE once during their life.
+ *
+ * The checks favour ld-linux.so behaviour which operates on a per ELF segment
+ * basis because we want to allow the common case and not the special ones.
+ */
+static inline void pax_handle_maywrite(struct vm_area_struct * vma, unsigned long start)
+{
+	struct elfhdr elf_h;
+	struct elf_phdr elf_p, p_dyn;
+	elf_dyn dyn;
+	unsigned long i, j = 65536UL / sizeof(struct elf_phdr);
+
+#ifndef CONFIG_PAX_NOELFRELOCS
+	if ((vma->vm_start != start) ||
+	    !vma->vm_file ||
+	    !(vma->vm_flags & VM_MAYEXEC) ||
+	    (vma->vm_flags & VM_MAYNOTWRITE))
+#endif
+
+		return;
+
+	if (sizeof(elf_h) != kernel_read(vma->vm_file, 0UL, (char*)&elf_h, sizeof(elf_h)) ||
+	    memcmp(elf_h.e_ident, ELFMAG, SELFMAG) ||
+
+#ifdef CONFIG_PAX_ETEXECRELOCS
+	    (elf_h.e_type != ET_DYN && elf_h.e_type != ET_EXEC) ||
+#else
+	    elf_h.e_type != ET_DYN ||
+#endif
+
+	    !elf_check_arch(&elf_h) ||
+	    elf_h.e_phentsize != sizeof(struct elf_phdr) ||
+	    elf_h.e_phnum > j)
+		return;
+
+	for (i = 0UL; i < elf_h.e_phnum; i++) {
+		if (sizeof(elf_p) != kernel_read(vma->vm_file, elf_h.e_phoff + i*sizeof(elf_p), (char*)&elf_p, sizeof(elf_p)))
+			return;
+		if (elf_p.p_type == PT_DYNAMIC) {
+			p_dyn = elf_p;
+			j = i;
+		}
+	}
+	if (elf_h.e_phnum <= j)
+		return;
+
+	i = 0UL;
+	do {
+		if (sizeof(dyn) != kernel_read(vma->vm_file, p_dyn.p_offset + i*sizeof(dyn), (char*)&dyn, sizeof(dyn)))
+			return;
+		if (dyn.d_tag == DT_TEXTREL || (dyn.d_tag == DT_FLAGS && (dyn.d_un.d_val & DF_TEXTREL))) {
+			vma->vm_flags |= VM_MAYWRITE | VM_MAYNOTWRITE;
+			return;
+		}
+		i++;
+	} while (dyn.d_tag != DT_NULL);
+	return;
+}
+#endif
+
 asmlinkage long
 sys_mprotect(unsigned long start, size_t len, unsigned long prot)
 {
@@ -233,6 +407,17 @@ sys_mprotect(unsigned long start, size_t
 	end = start + len;
 	if (end <= start)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	if (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM))
 		return -EINVAL;
 
@@ -240,7 +425,7 @@ sys_mprotect(unsigned long start, size_t
 	/*
 	 * Does the application expect PROT_READ to imply PROT_EXEC:
 	 */
-	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+	if ((prot & (PROT_READ | PROT_WRITE)) && (current->personality & READ_IMPLIES_EXEC))
 		prot |= PROT_EXEC;
 
 	vm_flags = calc_vm_prot_bits(prot);
@@ -272,6 +457,11 @@ sys_mprotect(unsigned long start, size_t
 	if (start > vma->vm_start)
 		prev = vma;
 
+#ifdef CONFIG_PAX_MPROTECT
+	if ((vma->vm_mm->pax_flags & MF_PAX_MPROTECT) && (prot & PROT_WRITE))
+		pax_handle_maywrite(vma, start);
+#endif
+
 	for (nstart = start ; ; ) {
 		unsigned long newflags;
 
@@ -285,6 +475,12 @@ sys_mprotect(unsigned long start, size_t
 			goto out;
 		}
 
+#ifdef CONFIG_PAX_MPROTECT
+		/* PaX: disallow write access after relocs are done, hopefully noone else needs it... */
+		if ((vma->vm_mm->pax_flags & MF_PAX_MPROTECT) && !(prot & PROT_WRITE) && (vma->vm_flags & VM_MAYNOTWRITE))
+			newflags &= ~VM_MAYWRITE;
+#endif
+
 		error = security_file_mprotect(vma, reqprot, prot);
 		if (error)
 			goto out;
@@ -308,6 +504,9 @@ sys_mprotect(unsigned long start, size_t
 			goto out;
 		}
 	}
+
+	track_exec_limit(current->mm, start, end, vm_flags);
+
 out:
 	up_write(&current->mm->mmap_sem);
 	return error;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/mremap.c linux-2.6.20.1-pax/mm/mremap.c
--- linux-2.6.20.1/mm/mremap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/mremap.c	2007-02-05 00:56:23.000000000 +0100
@@ -106,6 +106,12 @@ static void move_ptes(struct vm_area_str
 			continue;
 		pte = ptep_clear_flush(vma, old_addr, old_pte);
 		pte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+			pte_exprotect(pte);
+#endif
+
 		set_pte_at(mm, new_addr, new_pte, pte);
 	}
 
@@ -254,6 +260,7 @@ unsigned long do_mremap(unsigned long ad
 	struct vm_area_struct *vma;
 	unsigned long ret = -EINVAL;
 	unsigned long charged = 0;
+	unsigned long task_size = TASK_SIZE;
 
 	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
 		goto out;
@@ -272,6 +279,15 @@ unsigned long do_mremap(unsigned long ad
 	if (!new_len)
 		goto out;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (new_len > task_size || addr > task_size-new_len ||
+	    old_len > task_size || addr > task_size-old_len)
+		goto out;
+
 	/* new_addr is only valid if MREMAP_FIXED is specified */
 	if (flags & MREMAP_FIXED) {
 		if (new_addr & ~PAGE_MASK)
@@ -279,16 +295,13 @@ unsigned long do_mremap(unsigned long ad
 		if (!(flags & MREMAP_MAYMOVE))
 			goto out;
 
-		if (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)
+		if (new_addr > task_size - new_len)
 			goto out;
 
 		/* Check if the location we're moving into overlaps the
 		 * old location at all, and fail if it does.
 		 */
-		if ((new_addr <= addr) && (new_addr+new_len) > addr)
-			goto out;
-
-		if ((addr <= new_addr) && (addr+old_len) > new_addr)
+		if (addr + old_len > new_addr && new_addr + new_len > addr)
 			goto out;
 
 		ret = do_munmap(mm, new_addr, new_len);
@@ -322,6 +335,14 @@ unsigned long do_mremap(unsigned long ad
 		ret = -EINVAL;
 		goto out;
 	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		ret = -EINVAL;
+		goto out;
+	}
+#endif
+
 	/* We can't remap across vm area boundaries */
 	if (old_len > vma->vm_end - addr)
 		goto out;
@@ -355,7 +376,7 @@ unsigned long do_mremap(unsigned long ad
 	if (old_len == vma->vm_end - addr &&
 	    !((flags & MREMAP_FIXED) && (addr != new_addr)) &&
 	    (old_len != new_len || !(flags & MREMAP_MAYMOVE))) {
-		unsigned long max_addr = TASK_SIZE;
+		unsigned long max_addr = task_size;
 		if (vma->vm_next)
 			max_addr = vma->vm_next->vm_start;
 		/* can we just expand the current mapping? */
@@ -373,6 +394,7 @@ unsigned long do_mremap(unsigned long ad
 						   addr + new_len);
 			}
 			ret = addr;
+			track_exec_limit(vma->vm_mm, vma->vm_start, addr + new_len, vma->vm_flags);
 			goto out;
 		}
 	}
@@ -383,8 +405,8 @@ unsigned long do_mremap(unsigned long ad
 	 */
 	ret = -ENOMEM;
 	if (flags & MREMAP_MAYMOVE) {
+		unsigned long map_flags = 0;
 		if (!(flags & MREMAP_FIXED)) {
-			unsigned long map_flags = 0;
 			if (vma->vm_flags & VM_MAYSHARE)
 				map_flags |= MAP_SHARED;
 
@@ -394,7 +416,12 @@ unsigned long do_mremap(unsigned long ad
 			if (new_addr & ~PAGE_MASK)
 				goto out;
 		}
+		map_flags = vma->vm_flags;
 		ret = move_vma(vma, addr, old_len, new_len, new_addr);
+		if (!(ret & ~PAGE_MASK)) {
+			track_exec_limit(current->mm, addr, addr + old_len, 0UL);
+			track_exec_limit(current->mm, new_addr, new_addr + new_len, map_flags);
+		}
 	}
 out:
 	if (ret & ~PAGE_MASK)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/nommu.c linux-2.6.20.1-pax/mm/nommu.c
--- linux-2.6.20.1/mm/nommu.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/nommu.c	2007-02-05 00:56:23.000000000 +0100
@@ -350,15 +350,6 @@ struct vm_area_struct *find_vma(struct m
 EXPORT_SYMBOL(find_vma);
 
 /*
- * find a VMA
- * - we don't extend stack VMAs under NOMMU conditions
- */
-struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)
-{
-	return find_vma(mm, addr);
-}
-
-/*
  * look up the first VMA exactly that exactly matches addr
  * - should be called with mm->mmap_sem at least held readlocked
  */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/page_alloc.c linux-2.6.20.1-pax/mm/page_alloc.c
--- linux-2.6.20.1/mm/page_alloc.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/page_alloc.c	2007-02-05 00:56:23.000000000 +0100
@@ -384,7 +384,7 @@ static inline int page_is_buddy(struct p
 static inline void __free_one_page(struct page *page,
 		struct zone *zone, unsigned int order)
 {
-	unsigned long page_idx;
+	unsigned long page_idx, index;
 	int order_size = 1 << order;
 
 	if (unlikely(PageCompound(page)))
@@ -395,6 +395,11 @@ static inline void __free_one_page(struc
 	VM_BUG_ON(page_idx & (order_size - 1));
 	VM_BUG_ON(bad_range(zone, page));
 
+#ifdef CONFIG_PAX_MEMORY_SANITIZE
+	for (index = order_size; index; --index)
+		sanitize_highpage(page + index - 1);
+#endif
+
 	zone->free_pages += order_size;
 	while (order < MAX_ORDER-1) {
 		unsigned long combined_idx;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/rmap.c linux-2.6.20.1-pax/mm/rmap.c
--- linux-2.6.20.1/mm/rmap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/rmap.c	2007-02-05 00:56:23.000000000 +0100
@@ -100,6 +100,19 @@ int anon_vma_prepare(struct vm_area_stru
 			vma->anon_vma = anon_vma;
 			list_add_tail(&vma->anon_vma_node, &anon_vma->head);
 			allocated = NULL;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (vma->vm_flags & VM_MIRROR) {
+				struct vm_area_struct *vma_m;
+
+				vma_m = find_vma(vma->vm_mm, vma->vm_start + vma->vm_mirror);
+				BUG_ON(!vma_m || vma_m->vm_start != vma->vm_start + vma->vm_mirror);
+				BUG_ON(vma_m->anon_vma || vma->vm_pgoff != vma_m->vm_pgoff);
+				vma_m->anon_vma = anon_vma;
+				__anon_vma_link(vma_m);
+			}
+#endif
+
 		}
 		spin_unlock(&mm->page_table_lock);
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/slab.c linux-2.6.20.1-pax/mm/slab.c
--- linux-2.6.20.1/mm/slab.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/slab.c	2007-02-16 00:27:47.000000000 +0100
@@ -305,7 +305,7 @@ struct kmem_list3 {
  * Need this for bootstrapping a per node allocator.
  */
 #define NUM_INIT_LISTS (2 * MAX_NUMNODES + 1)
-struct kmem_list3 __initdata initkmem_list3[NUM_INIT_LISTS];
+struct kmem_list3 initkmem_list3[NUM_INIT_LISTS];
 #define	CACHE_CACHE 0
 #define	SIZE_AC 1
 #define	SIZE_L3 (1 + MAX_NUMNODES)
@@ -662,14 +662,14 @@ struct cache_names {
 static struct cache_names __initdata cache_names[] = {
 #define CACHE(x) { .name = "size-" #x, .name_dma = "size-" #x "(DMA)" },
 #include <linux/kmalloc_sizes.h>
-	{NULL,}
+	{NULL, NULL}
 #undef CACHE
 };
 
 static struct arraycache_init initarray_cache __initdata =
-    { {0, BOOT_CPUCACHE_ENTRIES, 1, 0} };
+    { {0, BOOT_CPUCACHE_ENTRIES, 1, 0}, {NULL} };
 static struct arraycache_init initarray_generic =
-    { {0, BOOT_CPUCACHE_ENTRIES, 1, 0} };
+    { {0, BOOT_CPUCACHE_ENTRIES, 1, 0}, {NULL} };
 
 /* internal cache of cache description objs */
 static struct kmem_cache cache_cache = {
@@ -1694,6 +1694,11 @@ static void store_stackinfo(struct kmem_
 
 		while (!kstack_end(sptr)) {
 			svalue = *sptr++;
+
+#ifdef CONFIG_PAX_KERNEXEC
+			svalue += __KERNEL_TEXT_OFFSET;
+#endif
+
 			if (kernel_text_address(svalue)) {
 				*addr++ = svalue;
 				size -= sizeof(unsigned long);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/swap.c linux-2.6.20.1-pax/mm/swap.c
--- linux-2.6.20.1/mm/swap.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/swap.c	2007-02-16 00:26:25.000000000 +0100
@@ -174,8 +174,8 @@ EXPORT_SYMBOL(mark_page_accessed);
  * lru_cache_add: add a page to the page lists
  * @page: the page to add
  */
-static DEFINE_PER_CPU(struct pagevec, lru_add_pvecs) = { 0, };
-static DEFINE_PER_CPU(struct pagevec, lru_add_active_pvecs) = { 0, };
+static DEFINE_PER_CPU(struct pagevec, lru_add_pvecs) = { 0, 0, {NULL} };
+static DEFINE_PER_CPU(struct pagevec, lru_add_active_pvecs) = { 0, 0, {NULL} };
 
 void fastcall lru_cache_add(struct page *page)
 {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/thrash.c linux-2.6.20.1-pax/mm/thrash.c
--- linux-2.6.20.1/mm/thrash.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/thrash.c	2007-02-05 00:56:23.000000000 +0100
@@ -48,9 +48,8 @@ void grab_swap_token(void)
 		if (current_interval < current->mm->last_interval)
 			current->mm->token_priority++;
 		else {
-			current->mm->token_priority--;
-			if (unlikely(current->mm->token_priority < 0))
-				current->mm->token_priority = 0;
+			if (likely(current->mm->token_priority > 0))
+				current->mm->token_priority--;
 		}
 		/* Check if we deserve the token */
 		if (current->mm->token_priority >
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/mm/vmalloc.c linux-2.6.20.1-pax/mm/vmalloc.c
--- linux-2.6.20.1/mm/vmalloc.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/mm/vmalloc.c	2007-02-05 00:56:23.000000000 +0100
@@ -195,6 +195,8 @@ static struct vm_struct *__get_vm_area_n
 
 	write_lock(&vmlist_lock);
 	for (p = &vmlist; (tmp = *p) != NULL ;p = &tmp->next) {
+		if (addr > end - size)
+			goto out;
 		if ((unsigned long)tmp->addr < addr) {
 			if((unsigned long)tmp->addr + tmp->size >= addr)
 				addr = ALIGN(tmp->size + 
@@ -206,8 +208,6 @@ static struct vm_struct *__get_vm_area_n
 		if (size + addr <= (unsigned long)tmp->addr)
 			goto found;
 		addr = ALIGN(tmp->size + (unsigned long)tmp->addr, align);
-		if (addr > end - size)
-			goto out;
 	}
 
 found:
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/core/flow.c linux-2.6.20.1-pax/net/core/flow.c
--- linux-2.6.20.1/net/core/flow.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/core/flow.c	2007-02-15 23:28:23.000000000 +0100
@@ -40,7 +40,7 @@ atomic_t flow_cache_genid = ATOMIC_INIT(
 
 static u32 flow_hash_shift;
 #define flow_hash_size	(1 << flow_hash_shift)
-static DEFINE_PER_CPU(struct flow_cache_entry **, flow_tables) = { NULL };
+static DEFINE_PER_CPU(struct flow_cache_entry **, flow_tables);
 
 #define flow_table(cpu) (per_cpu(flow_tables, cpu))
 
@@ -53,7 +53,7 @@ struct flow_percpu_info {
 	u32 hash_rnd;
 	int count;
 } ____cacheline_aligned;
-static DEFINE_PER_CPU(struct flow_percpu_info, flow_hash_info) = { 0 };
+static DEFINE_PER_CPU(struct flow_percpu_info, flow_hash_info);
 
 #define flow_hash_rnd_recalc(cpu) \
 	(per_cpu(flow_hash_info, cpu).hash_rnd_recalc)
@@ -70,7 +70,7 @@ struct flow_flush_info {
 	atomic_t cpuleft;
 	struct completion completion;
 };
-static DEFINE_PER_CPU(struct tasklet_struct, flow_flush_tasklets) = { NULL };
+static DEFINE_PER_CPU(struct tasklet_struct, flow_flush_tasklets);
 
 #define flow_flush_tasklet(cpu) (&per_cpu(flow_flush_tasklets, cpu))
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/core/sock.c linux-2.6.20.1-pax/net/core/sock.c
--- linux-2.6.20.1/net/core/sock.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/core/sock.c	2007-02-05 00:56:23.000000000 +0100
@@ -808,7 +808,7 @@ lenout:
  *
  * (We also register the sk_lock with the lock validator.)
  */
-static void inline sock_lock_init(struct sock *sk)
+static inline void sock_lock_init(struct sock *sk)
 {
 	sock_lock_init_class_and_name(sk,
 			af_family_slock_key_strings[sk->sk_family],
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/dccp/ccids/ccid3.c linux-2.6.20.1-pax/net/dccp/ccids/ccid3.c
--- linux-2.6.20.1/net/dccp/ccids/ccid3.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/dccp/ccids/ccid3.c	2007-02-15 23:27:27.000000000 +0100
@@ -45,7 +45,7 @@
 static int ccid3_debug;
 #define ccid3_pr_debug(format, a...)	DCCP_PR_DEBUG(ccid3_debug, format, ##a)
 #else
-#define ccid3_pr_debug(format, a...)
+#define ccid3_pr_debug(format, a...) do {} while (0)
 #endif
 
 static struct dccp_tx_hist *ccid3_tx_hist;
@@ -784,7 +784,7 @@ static u32 ccid3_hc_rx_calc_first_li(str
 	struct dccp_rx_hist_entry *entry, *next, *tail = NULL;
 	u32 x_recv, p;
 	suseconds_t rtt, delta;
-	struct timeval tstamp = { 0, };
+	struct timeval tstamp = { 0, 0 };
 	int interval = 0;
 	int win_count = 0;
 	int step = 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/dccp/dccp.h linux-2.6.20.1-pax/net/dccp/dccp.h
--- linux-2.6.20.1/net/dccp/dccp.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/dccp/dccp.h	2007-02-05 00:56:23.000000000 +0100
@@ -46,8 +46,8 @@ extern int dccp_debug;
 #define dccp_pr_debug(format, a...)	  DCCP_PR_DEBUG(dccp_debug, format, ##a)
 #define dccp_pr_debug_cat(format, a...)   DCCP_PRINTK(dccp_debug, format, ##a)
 #else
-#define dccp_pr_debug(format, a...)
-#define dccp_pr_debug_cat(format, a...)
+#define dccp_pr_debug(format, a...) do {} while (0)
+#define dccp_pr_debug_cat(format, a...) do {} while (0)
 #endif
 
 extern struct inet_hashinfo dccp_hashinfo;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/ipv6/addrconf.c linux-2.6.20.1-pax/net/ipv6/addrconf.c
--- linux-2.6.20.1/net/ipv6/addrconf.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/ipv6/addrconf.c	2007-02-05 00:56:23.000000000 +0100
@@ -875,7 +875,7 @@ struct ipv6_saddr_score {
 #define IPV6_SADDR_SCORE_LABEL		0x0020
 #define IPV6_SADDR_SCORE_PRIVACY	0x0040
 
-static int inline ipv6_saddr_preferred(int type)
+static inline int ipv6_saddr_preferred(int type)
 {
 	if (type & (IPV6_ADDR_MAPPED|IPV6_ADDR_COMPATv4|
 		    IPV6_ADDR_LOOPBACK|IPV6_ADDR_RESERVED))
@@ -884,7 +884,7 @@ static int inline ipv6_saddr_preferred(i
 }
 
 /* static matching label */
-static int inline ipv6_saddr_label(const struct in6_addr *addr, int type)
+static inline int ipv6_saddr_label(const struct in6_addr *addr, int type)
 {
  /*
   * 	prefix (longest match)	label
@@ -3363,7 +3363,7 @@ errout:
 		rtnl_set_sk_err(RTNLGRP_IPV6_IFADDR, err);
 }
 
-static void inline ipv6_store_devconf(struct ipv6_devconf *cnf,
+static inline void ipv6_store_devconf(struct ipv6_devconf *cnf,
 				__s32 *array, int bytes)
 {
 	BUG_ON(bytes < (DEVCONF_MAX * 4));
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/ipv6/exthdrs.c linux-2.6.20.1-pax/net/ipv6/exthdrs.c
--- linux-2.6.20.1/net/ipv6/exthdrs.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/ipv6/exthdrs.c	2007-02-15 23:25:27.000000000 +0100
@@ -691,7 +691,7 @@ static struct tlvtype_proc tlvprochopopt
 		.type	= IPV6_TLV_JUMBO,
 		.func	= ipv6_hop_jumbo,
 	},
-	{ -1, }
+	{ -1, NULL }
 };
 
 int ipv6_parse_hopopts(struct sk_buff **skbp)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/ipv6/raw.c linux-2.6.20.1-pax/net/ipv6/raw.c
--- linux-2.6.20.1/net/ipv6/raw.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/ipv6/raw.c	2007-02-05 00:56:23.000000000 +0100
@@ -548,7 +548,7 @@ out:
 	return err;
 }
 
-static int rawv6_send_hdrinc(struct sock *sk, void *from, int length,
+static int rawv6_send_hdrinc(struct sock *sk, void *from, unsigned int length,
 			struct flowi *fl, struct rt6_info *rt, 
 			unsigned int flags)
 {
@@ -690,7 +690,7 @@ static int rawv6_sendmsg(struct kiocb *i
 	/* Rough check on arithmetic overflow,
 	   better check is made in ip6_build_xmit
 	 */
-	if (len < 0)
+	if ((ssize_t)len < 0)
 		return -EMSGSIZE;
 
 	/* Mirror BSD error message compatibility */
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/ipv6/route.c linux-2.6.20.1-pax/net/ipv6/route.c
--- linux-2.6.20.1/net/ipv6/route.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/ipv6/route.c	2007-02-05 00:56:23.000000000 +0100
@@ -308,7 +308,7 @@ static inline void rt6_probe(struct rt6_
 /*
  * Default Router Selection (RFC 2461 6.3.6)
  */
-static int inline rt6_check_dev(struct rt6_info *rt, int oif)
+static inline int rt6_check_dev(struct rt6_info *rt, int oif)
 {
 	struct net_device *dev = rt->rt6i_dev;
 	if (!oif || dev->ifindex == oif)
@@ -319,7 +319,7 @@ static int inline rt6_check_dev(struct r
 	return 0;
 }
 
-static int inline rt6_check_neigh(struct rt6_info *rt)
+static inline int rt6_check_neigh(struct rt6_info *rt)
 {
 	struct neighbour *neigh = rt->rt6i_nexthop;
 	int m = 0;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/ipv6/xfrm6_tunnel.c linux-2.6.20.1-pax/net/ipv6/xfrm6_tunnel.c
--- linux-2.6.20.1/net/ipv6/xfrm6_tunnel.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/ipv6/xfrm6_tunnel.c	2007-02-05 00:56:23.000000000 +0100
@@ -58,7 +58,7 @@ static struct kmem_cache *xfrm6_tunnel_s
 static struct hlist_head xfrm6_tunnel_spi_byaddr[XFRM6_TUNNEL_SPI_BYADDR_HSIZE];
 static struct hlist_head xfrm6_tunnel_spi_byspi[XFRM6_TUNNEL_SPI_BYSPI_HSIZE];
 
-static unsigned inline xfrm6_tunnel_spi_hash_byaddr(xfrm_address_t *addr)
+static inline unsigned xfrm6_tunnel_spi_hash_byaddr(xfrm_address_t *addr)
 {
 	unsigned h;
 
@@ -70,7 +70,7 @@ static unsigned inline xfrm6_tunnel_spi_
 	return h;
 }
 
-static unsigned inline xfrm6_tunnel_spi_hash_byspi(u32 spi)
+static inline unsigned xfrm6_tunnel_spi_hash_byspi(u32 spi)
 {
 	return spi % XFRM6_TUNNEL_SPI_BYSPI_HSIZE;
 }
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/sctp/sm_statetable.c linux-2.6.20.1-pax/net/sctp/sm_statetable.c
--- linux-2.6.20.1/net/sctp/sm_statetable.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/sctp/sm_statetable.c	2007-02-05 00:56:23.000000000 +0100
@@ -960,7 +960,7 @@ static const sctp_sm_table_entry_t *sctp
 	if (state > SCTP_STATE_MAX)
 		return &bug;
 
-	if (cid >= 0 && cid <= SCTP_CID_BASE_MAX)
+	if (cid <= SCTP_CID_BASE_MAX)
 		return &chunk_event_table[cid][state];
 
 	if (sctp_prsctp_enable) {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/sctp/socket.c linux-2.6.20.1-pax/net/sctp/socket.c
--- linux-2.6.20.1/net/sctp/socket.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/sctp/socket.c	2007-02-15 11:05:27.000000000 +0100
@@ -1358,11 +1358,11 @@ SCTP_STATIC int sctp_sendmsg(struct kioc
 	struct sctp_chunk *chunk;
 	union sctp_addr to;
 	struct sockaddr *msg_name = NULL;
-	struct sctp_sndrcvinfo default_sinfo = { 0 };
+	struct sctp_sndrcvinfo default_sinfo;
 	struct sctp_sndrcvinfo *sinfo;
 	struct sctp_initmsg *sinit;
 	sctp_assoc_t associd = 0;
-	sctp_cmsgs_t cmsgs = { NULL };
+	sctp_cmsgs_t cmsgs = { NULL, NULL };
 	int err;
 	sctp_scope_t scope;
 	long timeo;
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/net/xfrm/xfrm_user.c linux-2.6.20.1-pax/net/xfrm/xfrm_user.c
--- linux-2.6.20.1/net/xfrm/xfrm_user.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/net/xfrm/xfrm_user.c	2007-02-05 00:56:23.000000000 +0100
@@ -1853,7 +1853,7 @@ nlmsg_failure:
 	return -1;
 }
 
-static int inline xfrm_sa_len(struct xfrm_state *x)
+static inline int xfrm_sa_len(struct xfrm_state *x)
 {
 	int l = 0;
 	if (x->aalg)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/scripts/pnmtologo.c linux-2.6.20.1-pax/scripts/pnmtologo.c
--- linux-2.6.20.1/scripts/pnmtologo.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/scripts/pnmtologo.c	2007-02-09 14:52:04.000000000 +0100
@@ -237,14 +237,14 @@ static void write_header(void)
     fprintf(out, " *  Linux logo %s\n", logoname);
     fputs(" */\n\n", out);
     fputs("#include <linux/linux_logo.h>\n\n", out);
-    fprintf(out, "static unsigned char %s_data[] __initdata = {\n",
+    fprintf(out, "static unsigned char %s_data[] = {\n",
 	    logoname);
 }
 
 static void write_footer(void)
 {
     fputs("\n};\n\n", out);
-    fprintf(out, "struct linux_logo %s __initdata = {\n", logoname);
+    fprintf(out, "struct linux_logo %s = {\n", logoname);
     fprintf(out, "    .type\t= %s,\n", logo_types[logo_type]);
     fprintf(out, "    .width\t= %d,\n", logo_width);
     fprintf(out, "    .height\t= %d,\n", logo_height);
@@ -374,7 +374,7 @@ static void write_logo_clut224(void)
     fputs("\n};\n\n", out);
 
     /* write logo clut */
-    fprintf(out, "static unsigned char %s_clut[] __initdata = {\n",
+    fprintf(out, "static unsigned char %s_clut[] = {\n",
 	    logoname);
     write_hex_cnt = 0;
     for (i = 0; i < logo_clutsize; i++) {
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/security/Kconfig linux-2.6.20.1-pax/security/Kconfig
--- linux-2.6.20.1/security/Kconfig	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/security/Kconfig	2007-02-05 00:56:23.000000000 +0100
@@ -4,6 +4,430 @@
 
 menu "Security options"
 
+menu "PaX"
+
+config PAX
+	bool "Enable various PaX features"
+	depends on ALPHA || ARM || IA64 || MIPS32 || MIPS64 || PARISC || PPC32 || PPC64 || SPARC32 || SPARC64 || X86 || X86_64
+	help
+	  This allows you to enable various PaX features.  PaX adds
+	  intrusion prevention mechanisms to the kernel that reduce
+	  the risks posed by exploitable memory corruption bugs.
+
+menu "PaX Control"
+	depends on PAX
+
+config PAX_SOFTMODE
+	bool 'Support soft mode'
+	help
+	  Enabling this option will allow you to run PaX in soft mode, that
+	  is, PaX features will not be enforced by default, only on executables
+	  marked explicitly.  You must also enable PT_PAX_FLAGS support as it
+	  is the only way to mark executables for soft mode use.
+
+	  Soft mode can be activated by using the "pax_softmode=1" kernel command
+	  line option on boot.  Furthermore you can control various PaX features
+	  at runtime via the entries in /proc/sys/kernel/pax.
+
+config PAX_EI_PAX
+	bool 'Use legacy ELF header marking'
+	help
+	  Enabling this option will allow you to control PaX features on
+	  a per executable basis via the 'chpax' utility available at
+	  http://pax.grsecurity.net/.  The control flags will be read from
+	  an otherwise reserved part of the ELF header.  This marking has
+	  numerous drawbacks (no support for soft-mode, toolchain does not
+	  know about the non-standard use of the ELF header) therefore it
+	  has been deprecated in favour of PT_PAX_FLAGS support.
+
+	  If you have applications not marked by the PT_PAX_FLAGS ELF
+	  program header then you MUST enable this option otherwise they
+	  will not get any protection.
+
+	  Note that if you enable PT_PAX_FLAGS marking support as well,
+	  the PT_PAX_FLAG marks will override the legacy EI_PAX marks.
+
+config PAX_PT_PAX_FLAGS
+	bool 'Use ELF program header marking'
+	help
+	  Enabling this option will allow you to control PaX features on
+	  a per executable basis via the 'paxctl' utility available at
+	  http://pax.grsecurity.net/.  The control flags will be read from
+	  a PaX specific ELF program header (PT_PAX_FLAGS).  This marking
+	  has the benefits of supporting both soft mode and being fully
+	  integrated into the toolchain (the binutils patch is available
+	  from http://pax.grsecurity.net).
+
+	  If you have applications not marked by the PT_PAX_FLAGS ELF
+	  program header then you MUST enable the EI_PAX marking support
+	  otherwise they will not get any protection.
+
+	  Note that if you enable the legacy EI_PAX marking support as well,
+	  the EI_PAX marks will be overridden by the PT_PAX_FLAGS marks.
+
+choice
+	prompt 'MAC system integration'
+	default PAX_NO_ACL_FLAGS
+	help
+	  Mandatory Access Control systems have the option of controlling
+	  PaX flags on a per executable basis, choose the method supported
+	  by your particular system.
+
+	  - "none": if your MAC system does not interact with PaX,
+	  - "direct": if your MAC system defines pax_set_flags() itself,
+	  - "hook": if your MAC system uses the pax_set_flags_func callback.
+
+	  NOTE: this option is for developers/integrators only.
+
+config PAX_NO_ACL_FLAGS
+	bool 'none'
+
+config PAX_HAVE_ACL_FLAGS
+	bool 'direct'
+
+config PAX_HOOK_ACL_FLAGS
+	bool 'hook'
+endchoice
+
+endmenu
+
+menu "Non-executable pages"
+	depends on PAX
+
+config PAX_NOEXEC
+	bool "Enforce non-executable pages"
+	depends on (PAX_EI_PAX || PAX_PT_PAX_FLAGS || PAX_HAVE_ACL_FLAGS || PAX_HOOK_ACL_FLAGS) && (ALPHA || IA64 || MIPS32 || MIPS64 || PARISC || PPC32 || PPC64 || SPARC32 || SPARC64 || X86 || X86_64)
+	help
+	  By design some architectures do not allow for protecting memory
+	  pages against execution or even if they do, Linux does not make
+	  use of this feature.  In practice this means that if a page is
+	  readable (such as the stack or heap) it is also executable.
+
+	  There is a well known exploit technique that makes use of this
+	  fact and a common programming mistake where an attacker can
+	  introduce code of his choice somewhere in the attacked program's
+	  memory (typically the stack or the heap) and then execute it.
+
+	  If the attacked program was running with different (typically
+	  higher) privileges than that of the attacker, then he can elevate
+	  his own privilege level (e.g. get a root shell, write to files for
+	  which he does not have write access to, etc).
+
+	  Enabling this option will let you choose from various features
+	  that prevent the injection and execution of 'foreign' code in
+	  a program.
+
+	  This will also break programs that rely on the old behaviour and
+	  expect that dynamically allocated memory via the malloc() family
+	  of functions is executable (which it is not).  Notable examples
+	  are the XFree86 4.x server, the java runtime and wine.
+
+config PAX_PAGEEXEC
+	bool "Paging based non-executable pages"
+	depends on !COMPAT_VDSO && PAX_NOEXEC && (!X86_32 || M586 || M586TSC || M586MMX || M686 || MPENTIUMII || MPENTIUMIII || MPENTIUMM || MPENTIUM4 || MK7 || MK8 || MWINCHIPC6 || MWINCHIP2 || MWINCHIP3D || MVIAC3_2)
+	help
+	  This implementation is based on the paging feature of the CPU.
+	  On i386 and ppc there is a variable but usually low performance
+	  impact on applications.  On alpha, ia64, parisc, sparc, sparc64
+	  and x86_64 there is no performance impact.
+
+config PAX_SEGMEXEC
+	bool "Segmentation based non-executable pages"
+	depends on !COMPAT_VDSO && PAX_NOEXEC && X86_32
+	help
+	  This implementation is based on the segmentation feature of the
+	  CPU and has little performance impact, however applications will
+	  be limited to a 1.5 GB address space instead of the normal 3 GB.
+
+choice
+	prompt "Default non-executable page method"
+	depends on PAX_PAGEEXEC && PAX_SEGMEXEC
+	default PAX_DEFAULT_SEGMEXEC
+	help
+	  Select the default non-executable page method applied to applications
+	  that do not select one themselves.
+
+config	PAX_DEFAULT_PAGEEXEC
+	bool "PAGEEXEC"
+
+config	PAX_DEFAULT_SEGMEXEC
+	bool "SEGMEXEC"
+endchoice
+
+config PAX_EMUTRAMP
+	bool "Emulate trampolines" if (PAX_PAGEEXEC || PAX_SEGMEXEC) && (PARISC || PPC32 || X86_32)
+	default y if PARISC || PPC32
+	help
+	  There are some programs and libraries that for one reason or
+	  another attempt to execute special small code snippets from
+	  non-executable memory pages.  Most notable examples are the
+	  signal handler return code generated by the kernel itself and
+	  the GCC trampolines.
+
+	  If you enabled CONFIG_PAX_PAGEEXEC or CONFIG_PAX_SEGMEXEC then
+	  such programs will no longer work under your kernel.
+
+	  As a remedy you can say Y here and use the 'chpax' or 'paxctl'
+	  utilities to enable trampoline emulation for the affected programs
+	  yet still have the protection provided by the non-executable pages.
+
+	  On parisc and ppc you MUST enable this option and EMUSIGRT as
+	  well, otherwise your system will not even boot.
+
+	  Alternatively you can say N here and use the 'chpax' or 'paxctl'
+	  utilities to disable CONFIG_PAX_PAGEEXEC and CONFIG_PAX_SEGMEXEC
+	  for the affected files.
+
+	  NOTE: enabling this feature *may* open up a loophole in the
+	  protection provided by non-executable pages that an attacker
+	  could abuse.  Therefore the best solution is to not have any
+	  files on your system that would require this option.  This can
+	  be achieved by not using libc5 (which relies on the kernel
+	  signal handler return code) and not using or rewriting programs
+	  that make use of the nested function implementation of GCC.
+	  Skilled users can just fix GCC itself so that it implements
+	  nested function calls in a way that does not interfere with PaX.
+
+config PAX_EMUSIGRT
+	bool "Automatically emulate sigreturn trampolines"
+	depends on PAX_EMUTRAMP && (PARISC || PPC32)
+	default y
+	help
+	  Enabling this option will have the kernel automatically detect
+	  and emulate signal return trampolines executing on the stack
+	  that would otherwise lead to task termination.
+
+	  This solution is intended as a temporary one for users with
+	  legacy versions of libc (libc5, glibc 2.0, uClibc before 0.9.17,
+	  Modula-3 runtime, etc) or executables linked to such, basically
+	  everything that does not specify its own SA_RESTORER function in
+	  normal executable memory like glibc 2.1+ does.
+
+	  On parisc and ppc you MUST enable this option, otherwise your
+	  system will not even boot.
+
+	  NOTE: this feature cannot be disabled on a per executable basis
+	  and since it *does* open up a loophole in the protection provided
+	  by non-executable pages, the best solution is to not have any
+	  files on your system that would require this option.
+
+config PAX_MPROTECT
+	bool "Restrict mprotect()"
+	depends on (PAX_PAGEEXEC || PAX_SEGMEXEC) && !PPC64
+	help
+	  Enabling this option will prevent programs from
+	   - changing the executable status of memory pages that were
+	     not originally created as executable,
+	   - making read-only executable pages writable again,
+	   - creating executable pages from anonymous memory.
+
+	  You should say Y here to complete the protection provided by
+	  the enforcement of non-executable pages.
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+	  this feature on a per file basis.
+
+config PAX_NOELFRELOCS
+	bool "Disallow ELF text relocations"
+	depends on PAX_MPROTECT && !PAX_ETEXECRELOCS && (IA64 || X86 || X86_64)
+	help
+	  Non-executable pages and mprotect() restrictions are effective
+	  in preventing the introduction of new executable code into an
+	  attacked task's address space.  There remain only two venues
+	  for this kind of attack: if the attacker can execute already
+	  existing code in the attacked task then he can either have it
+	  create and mmap() a file containing his code or have it mmap()
+	  an already existing ELF library that does not have position
+	  independent code in it and use mprotect() on it to make it
+	  writable and copy his code there.  While protecting against
+	  the former approach is beyond PaX, the latter can be prevented
+	  by having only PIC ELF libraries on one's system (which do not
+	  need to relocate their code).  If you are sure this is your case,
+	  then enable this option otherwise be careful as you may not even
+	  be able to boot or log on your system (for example, some PAM
+	  modules are erroneously compiled as non-PIC by default).
+
+	  NOTE: if you are using dynamic ELF executables (as suggested
+	  when using ASLR) then you must have made sure that you linked
+	  your files using the PIC version of crt1 (the et_dyn.tar.gz package
+	  referenced there has already been updated to support this).
+
+config PAX_ETEXECRELOCS
+	bool "Allow ELF ET_EXEC text relocations"
+	depends on PAX_MPROTECT && (ALPHA || IA64 || PARISC)
+	default y
+	help
+	  On some architectures there are incorrectly created applications
+	  that require text relocations and would not work without enabling
+	  this option.  If you are an alpha, ia64 or parisc user, you should
+	  enable this option and disable it once you have made sure that
+	  none of your applications need it.
+
+config PAX_EMUPLT
+	bool "Automatically emulate ELF PLT"
+	depends on PAX_MPROTECT && (ALPHA || PARISC || PPC32 || SPARC32 || SPARC64)
+	default y
+	help
+	  Enabling this option will have the kernel automatically detect
+	  and emulate the Procedure Linkage Table entries in ELF files.
+	  On some architectures such entries are in writable memory, and
+	  become non-executable leading to task termination.  Therefore
+	  it is mandatory that you enable this option on alpha, parisc, ppc,
+	  sparc and sparc64, otherwise your system would not even boot.
+
+	  NOTE: this feature *does* open up a loophole in the protection
+	  provided by the non-executable pages, therefore the proper
+	  solution is to modify the toolchain to produce a PLT that does
+	  not need to be writable.
+
+config PAX_DLRESOLVE
+	bool
+	depends on PAX_EMUPLT && (SPARC32 || SPARC64)
+	default y
+
+config PAX_SYSCALL
+	bool
+	depends on PAX_PAGEEXEC && PPC32
+	default y
+
+config PAX_KERNEXEC
+	bool "Enforce non-executable kernel pages"
+	depends on PAX_NOEXEC && X86_32 && !HOTPLUG_PCI_COMPAQ_NVRAM && !PCI_BIOS && !EFI && !COMPAT_VDSO && X86_WP_WORKS_OK
+	help
+	  This is the kernel land equivalent of PAGEEXEC and MPROTECT,
+	  that is, enabling this option will make it harder to inject
+	  and execute 'foreign' code in kernel memory itself.
+
+endmenu
+
+menu "Address Space Layout Randomization"
+	depends on PAX
+
+config PAX_ASLR
+	bool "Address Space Layout Randomization"
+	depends on PAX_EI_PAX || PAX_PT_PAX_FLAGS || PAX_HAVE_ACL_FLAGS || PAX_HOOK_ACL_FLAGS
+	help
+	  Many if not most exploit techniques rely on the knowledge of
+	  certain addresses in the attacked program.  The following options
+	  will allow the kernel to apply a certain amount of randomization
+	  to specific parts of the program thereby forcing an attacker to
+	  guess them in most cases.  Any failed guess will most likely crash
+	  the attacked program which allows the kernel to detect such attempts
+	  and react on them.  PaX itself provides no reaction mechanisms,
+	  instead it is strongly encouraged that you make use of Nergal's
+	  segvguard (ftp://ftp.pl.openwall.com/misc/segvguard/) or grsecurity's
+	  (http://www.grsecurity.net/) built-in crash detection features or
+	  develop one yourself.
+
+	  By saying Y here you can choose to randomize the following areas:
+	   - top of the task's kernel stack
+	   - top of the task's userland stack
+	   - base address for mmap() requests that do not specify one
+	     (this includes all libraries)
+	   - base address of the main executable
+
+	  It is strongly recommended to say Y here as address space layout
+	  randomization has negligible impact on performance yet it provides
+	  a very effective protection.
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+	  this feature on a per file basis.
+
+config PAX_RANDKSTACK
+	bool "Randomize kernel stack base"
+	depends on PAX_ASLR && X86_TSC && X86_32
+	help
+	  By saying Y here the kernel will randomize every task's kernel
+	  stack on every system call.  This will not only force an attacker
+	  to guess it but also prevent him from making use of possible
+	  leaked information about it.
+
+	  Since the kernel stack is a rather scarce resource, randomization
+	  may cause unexpected stack overflows, therefore you should very
+	  carefully test your system.  Note that once enabled in the kernel
+	  configuration, this feature cannot be disabled on a per file basis.
+
+config PAX_RANDUSTACK
+	bool "Randomize user stack base"
+	depends on PAX_ASLR
+	help
+	  By saying Y here the kernel will randomize every task's userland
+	  stack.  The randomization is done in two steps where the second
+	  one may apply a big amount of shift to the top of the stack and
+	  cause problems for programs that want to use lots of memory (more
+	  than 2.5 GB if SEGMEXEC is not active, or 1.25 GB when it is).
+	  For this reason the second step can be controlled by 'chpax' or
+	  'paxctl' on a per file basis.
+
+config PAX_RANDMMAP
+	bool "Randomize mmap() base"
+	depends on PAX_ASLR
+	help
+	  By saying Y here the kernel will use a randomized base address for
+	  mmap() requests that do not specify one themselves.  As a result
+	  all dynamically loaded libraries will appear at random addresses
+	  and therefore be harder to exploit by a technique where an attacker
+	  attempts to execute library code for his purposes (e.g. spawn a
+	  shell from an exploited program that is running at an elevated
+	  privilege level).
+
+	  Furthermore, if a program is relinked as a dynamic ELF file, its
+	  base address will be randomized as well, completing the full
+	  randomization of the address space layout.  Attacking such programs
+	  becomes a guess game.  You can find an example of doing this at
+	  http://pax.grsecurity.net/et_dyn.tar.gz and practical samples at
+	  http://www.grsecurity.net/grsec-gcc-specs.tar.gz .
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control this
+	  feature on a per file basis.
+
+endmenu
+
+menu "Miscellaneous hardening features"
+
+config PAX_MEMORY_SANITIZE
+	bool "Sanitize all freed memory"
+	help
+	  By saying Y here the kernel will erase memory pages as soon as they
+	  are freed.  This in turn reduces the lifetime of data stored in the
+	  pages, making it less likely that sensitive information such as
+	  passwords, cryptographic secrets, etc stay in memory for too long.
+
+	  This is especially useful for programs whose runtime is short, long
+	  lived processes and the kernel itself benefit from this as long as
+	  they operate on whole memory pages and ensure timely freeing of pages
+	  that may hold sensitive information.
+
+	  The tradeoff is performance impact, on a single CPU system kernel
+	  compilation sees a 3% slowdown, other systems and workloads may vary
+	  and you are advised to test this feature on your expected workload
+	  before deploying it.
+
+	  Note that this feature does not protect data stored in live pages,
+	  e.g., process memory swapped to disk may stay there for a long time.
+
+config PAX_MEMORY_UDEREF
+	bool "Prevent invalid userland pointer dereference"
+	depends on X86_32 && !COMPAT_VDSO
+	help
+	  By saying Y here the kernel will be prevented from dereferencing
+	  userland pointers in contexts where the kernel expects only kernel
+	  pointers.  This is both a useful runtime debugging feature and a
+	  security measure that prevents exploiting a class of kernel bugs.
+
+	  The tradeoff is that some virtualization solutions may experience
+	  a huge slowdown and therefore you should not enable this feature
+	  for kernels meant to run in such environments.  Whether a given VM
+	  solution is affected or not is best determined by simply trying it
+	  out, the performance impact will be obvious right on boot as this
+	  mechanism engages from very early on.  A good rule of thumb is that
+	  VMs running on CPUs without hardware virtualization support (i.e.,
+	  the majority of IA-32 CPUs) will likely experience the slowdown.
+
+endmenu
+
+endmenu
+
 config KEYS
 	bool "Enable access key retention support"
 	help
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/sound/core/oss/pcm_oss.c linux-2.6.20.1-pax/sound/core/oss/pcm_oss.c
--- linux-2.6.20.1/sound/core/oss/pcm_oss.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/sound/core/oss/pcm_oss.c	2007-02-05 00:56:23.000000000 +0100
@@ -2881,8 +2881,8 @@ static void snd_pcm_oss_proc_done(struct
 	}
 }
 #else /* !CONFIG_SND_VERBOSE_PROCFS */
-#define snd_pcm_oss_proc_init(pcm)
-#define snd_pcm_oss_proc_done(pcm)
+#define snd_pcm_oss_proc_init(pcm) do {} while (0)
+#define snd_pcm_oss_proc_done(pcm) do {} while (0)
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 
 /*
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/sound/core/seq/seq_lock.h linux-2.6.20.1-pax/sound/core/seq/seq_lock.h
--- linux-2.6.20.1/sound/core/seq/seq_lock.h	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/sound/core/seq/seq_lock.h	2007-02-05 00:56:23.000000000 +0100
@@ -23,10 +23,10 @@ void snd_use_lock_sync_helper(snd_use_lo
 #else /* SMP || CONFIG_SND_DEBUG */
 
 typedef spinlock_t snd_use_lock_t;	/* dummy */
-#define snd_use_lock_init(lockp) /**/
-#define snd_use_lock_use(lockp) /**/
-#define snd_use_lock_free(lockp) /**/
-#define snd_use_lock_sync(lockp) /**/
+#define snd_use_lock_init(lockp) do {} while (0)
+#define snd_use_lock_use(lockp) do {} while (0)
+#define snd_use_lock_free(lockp) do {} while (0)
+#define snd_use_lock_sync(lockp) do {} while (0)
 
 #endif /* SMP || CONFIG_SND_DEBUG */
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/sound/pci/ac97/ac97_codec.c linux-2.6.20.1-pax/sound/pci/ac97/ac97_codec.c
--- linux-2.6.20.1/sound/pci/ac97/ac97_codec.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/sound/pci/ac97/ac97_codec.c	2007-02-15 23:38:42.000000000 +0100
@@ -67,129 +67,129 @@ struct ac97_codec_id {
 };
 
 static const struct ac97_codec_id snd_ac97_codec_id_vendors[] = {
-{ 0x414b4d00, 0xffffff00, "Asahi Kasei",	NULL,	NULL },
-{ 0x41445300, 0xffffff00, "Analog Devices",	NULL,	NULL },
-{ 0x414c4300, 0xffffff00, "Realtek",		NULL,	NULL },
-{ 0x414c4700, 0xffffff00, "Realtek",		NULL,	NULL },
-{ 0x434d4900, 0xffffff00, "C-Media Electronics", NULL,	NULL },
-{ 0x43525900, 0xffffff00, "Cirrus Logic",	NULL,	NULL },
-{ 0x43585400, 0xffffff00, "Conexant",           NULL,	NULL },
-{ 0x44543000, 0xffffff00, "Diamond Technology", NULL,	NULL },
-{ 0x454d4300, 0xffffff00, "eMicro",		NULL,	NULL },
-{ 0x45838300, 0xffffff00, "ESS Technology",	NULL,	NULL },
-{ 0x48525300, 0xffffff00, "Intersil",		NULL,	NULL },
-{ 0x49434500, 0xffffff00, "ICEnsemble",		NULL,	NULL },
-{ 0x49544500, 0xffffff00, "ITE Tech.Inc",	NULL,	NULL },
-{ 0x4e534300, 0xffffff00, "National Semiconductor", NULL, NULL },
-{ 0x50534300, 0xffffff00, "Philips",		NULL,	NULL },
-{ 0x53494c00, 0xffffff00, "Silicon Laboratory",	NULL,	NULL },
-{ 0x54524100, 0xffffff00, "TriTech",		NULL,	NULL },
-{ 0x54584e00, 0xffffff00, "Texas Instruments",	NULL,	NULL },
-{ 0x56494100, 0xffffff00, "VIA Technologies",   NULL,	NULL },
-{ 0x57454300, 0xffffff00, "Winbond",		NULL,	NULL },
-{ 0x574d4c00, 0xffffff00, "Wolfson",		NULL,	NULL },
-{ 0x594d4800, 0xffffff00, "Yamaha",		NULL,	NULL },
-{ 0x83847600, 0xffffff00, "SigmaTel",		NULL,	NULL },
-{ 0,	      0, 	  NULL,			NULL,	NULL }
+{ 0x414b4d00, 0xffffff00, "Asahi Kasei",	NULL,	NULL, 0 },
+{ 0x41445300, 0xffffff00, "Analog Devices",	NULL,	NULL, 0 },
+{ 0x414c4300, 0xffffff00, "Realtek",		NULL,	NULL, 0 },
+{ 0x414c4700, 0xffffff00, "Realtek",		NULL,	NULL, 0 },
+{ 0x434d4900, 0xffffff00, "C-Media Electronics", NULL,	NULL, 0 },
+{ 0x43525900, 0xffffff00, "Cirrus Logic",	NULL,	NULL, 0 },
+{ 0x43585400, 0xffffff00, "Conexant",           NULL,	NULL, 0 },
+{ 0x44543000, 0xffffff00, "Diamond Technology", NULL,	NULL, 0 },
+{ 0x454d4300, 0xffffff00, "eMicro",		NULL,	NULL, 0 },
+{ 0x45838300, 0xffffff00, "ESS Technology",	NULL,	NULL, 0 },
+{ 0x48525300, 0xffffff00, "Intersil",		NULL,	NULL, 0 },
+{ 0x49434500, 0xffffff00, "ICEnsemble",		NULL,	NULL, 0 },
+{ 0x49544500, 0xffffff00, "ITE Tech.Inc",	NULL,	NULL, 0 },
+{ 0x4e534300, 0xffffff00, "National Semiconductor", NULL, NULL, 0 },
+{ 0x50534300, 0xffffff00, "Philips",		NULL,	NULL, 0 },
+{ 0x53494c00, 0xffffff00, "Silicon Laboratory",	NULL,	NULL, 0 },
+{ 0x54524100, 0xffffff00, "TriTech",		NULL,	NULL, 0 },
+{ 0x54584e00, 0xffffff00, "Texas Instruments",	NULL,	NULL, 0 },
+{ 0x56494100, 0xffffff00, "VIA Technologies",   NULL,	NULL, 0 },
+{ 0x57454300, 0xffffff00, "Winbond",		NULL,	NULL, 0 },
+{ 0x574d4c00, 0xffffff00, "Wolfson",		NULL,	NULL, 0 },
+{ 0x594d4800, 0xffffff00, "Yamaha",		NULL,	NULL, 0 },
+{ 0x83847600, 0xffffff00, "SigmaTel",		NULL,	NULL, 0 },
+{ 0,	      0, 	  NULL,			NULL,	NULL, 0 }
 };
 
 static const struct ac97_codec_id snd_ac97_codec_ids[] = {
-{ 0x414b4d00, 0xffffffff, "AK4540",		NULL,		NULL },
-{ 0x414b4d01, 0xffffffff, "AK4542",		NULL,		NULL },
-{ 0x414b4d02, 0xffffffff, "AK4543",		NULL,		NULL },
-{ 0x414b4d06, 0xffffffff, "AK4544A",		NULL,		NULL },
-{ 0x414b4d07, 0xffffffff, "AK4545",		NULL,		NULL },
-{ 0x41445303, 0xffffffff, "AD1819",		patch_ad1819,	NULL },
-{ 0x41445340, 0xffffffff, "AD1881",		patch_ad1881,	NULL },
-{ 0x41445348, 0xffffffff, "AD1881A",		patch_ad1881,	NULL },
-{ 0x41445360, 0xffffffff, "AD1885",		patch_ad1885,	NULL },
-{ 0x41445361, 0xffffffff, "AD1886",		patch_ad1886,	NULL },
-{ 0x41445362, 0xffffffff, "AD1887",		patch_ad1881,	NULL },
-{ 0x41445363, 0xffffffff, "AD1886A",		patch_ad1881,	NULL },
-{ 0x41445368, 0xffffffff, "AD1888",		patch_ad1888,	NULL },
-{ 0x41445370, 0xffffffff, "AD1980",		patch_ad1980,	NULL },
-{ 0x41445372, 0xffffffff, "AD1981A",		patch_ad1981a,	NULL },
-{ 0x41445374, 0xffffffff, "AD1981B",		patch_ad1981b,	NULL },
-{ 0x41445375, 0xffffffff, "AD1985",		patch_ad1985,	NULL },
-{ 0x41445378, 0xffffffff, "AD1986",		patch_ad1985,	NULL },
-{ 0x414c4300, 0xffffff00, "ALC100,100P", 	NULL,		NULL },
-{ 0x414c4710, 0xfffffff0, "ALC200,200P",	NULL,		NULL },
-{ 0x414c4721, 0xffffffff, "ALC650D",		NULL,	NULL }, /* already patched */
-{ 0x414c4722, 0xffffffff, "ALC650E",		NULL,	NULL }, /* already patched */
-{ 0x414c4723, 0xffffffff, "ALC650F",		NULL,	NULL }, /* already patched */
-{ 0x414c4720, 0xfffffff0, "ALC650",		patch_alc650,	NULL },
-{ 0x414c4760, 0xfffffff0, "ALC655",		patch_alc655,	NULL },
-{ 0x414c4781, 0xffffffff, "ALC658D",		NULL,	NULL }, /* already patched */
-{ 0x414c4780, 0xfffffff0, "ALC658",		patch_alc655,	NULL },
-{ 0x414c4790, 0xfffffff0, "ALC850",		patch_alc850,	NULL },
-{ 0x414c4730, 0xffffffff, "ALC101",		NULL,		NULL },
-{ 0x414c4740, 0xfffffff0, "ALC202",		NULL,		NULL },
-{ 0x414c4750, 0xfffffff0, "ALC250",		NULL,		NULL },
-{ 0x414c4770, 0xfffffff0, "ALC203",		NULL,		NULL },
-{ 0x434d4941, 0xffffffff, "CMI9738",		patch_cm9738,	NULL },
-{ 0x434d4961, 0xffffffff, "CMI9739",		patch_cm9739,	NULL },
-{ 0x434d4969, 0xffffffff, "CMI9780",		patch_cm9780,	NULL },
-{ 0x434d4978, 0xffffffff, "CMI9761A",		patch_cm9761,	NULL },
-{ 0x434d4982, 0xffffffff, "CMI9761B",		patch_cm9761,	NULL },
-{ 0x434d4983, 0xffffffff, "CMI9761A+",		patch_cm9761,	NULL },
-{ 0x43525900, 0xfffffff8, "CS4297",		NULL,		NULL },
-{ 0x43525910, 0xfffffff8, "CS4297A",		patch_cirrus_spdif,	NULL },
-{ 0x43525920, 0xfffffff8, "CS4298",		patch_cirrus_spdif,		NULL },
-{ 0x43525928, 0xfffffff8, "CS4294",		NULL,		NULL },
-{ 0x43525930, 0xfffffff8, "CS4299",		patch_cirrus_cs4299,	NULL },
-{ 0x43525948, 0xfffffff8, "CS4201",		NULL,		NULL },
-{ 0x43525958, 0xfffffff8, "CS4205",		patch_cirrus_spdif,	NULL },
-{ 0x43525960, 0xfffffff8, "CS4291",		NULL,		NULL },
-{ 0x43525970, 0xfffffff8, "CS4202",		NULL,		NULL },
-{ 0x43585421, 0xffffffff, "HSD11246",		NULL,		NULL },	// SmartMC II
-{ 0x43585428, 0xfffffff8, "Cx20468",		patch_conexant,	NULL }, // SmartAMC fixme: the mask might be different
-{ 0x44543031, 0xfffffff0, "DT0398",		NULL,		NULL },
-{ 0x454d4328, 0xffffffff, "EM28028",		NULL,		NULL },  // same as TR28028?
-{ 0x45838308, 0xffffffff, "ESS1988",		NULL,		NULL },
-{ 0x48525300, 0xffffff00, "HMP9701",		NULL,		NULL },
-{ 0x49434501, 0xffffffff, "ICE1230",		NULL,		NULL },
-{ 0x49434511, 0xffffffff, "ICE1232",		NULL,		NULL }, // alias VIA VT1611A?
-{ 0x49434514, 0xffffffff, "ICE1232A",		NULL,		NULL },
-{ 0x49434551, 0xffffffff, "VT1616", 		patch_vt1616,	NULL }, 
-{ 0x49434552, 0xffffffff, "VT1616i",		patch_vt1616,	NULL }, // VT1616 compatible (chipset integrated)
-{ 0x49544520, 0xffffffff, "IT2226E",		NULL,		NULL },
-{ 0x49544561, 0xffffffff, "IT2646E",		patch_it2646,	NULL },
-{ 0x4e534300, 0xffffffff, "LM4540,43,45,46,48",	NULL,		NULL }, // only guess --jk
-{ 0x4e534331, 0xffffffff, "LM4549",		NULL,		NULL },
-{ 0x4e534350, 0xffffffff, "LM4550",		patch_lm4550,  	NULL }, // volume wrap fix 
-{ 0x50534304, 0xffffffff, "UCB1400",		patch_ucb1400,	NULL },
+{ 0x414b4d00, 0xffffffff, "AK4540",		NULL,		NULL, 0 },
+{ 0x414b4d01, 0xffffffff, "AK4542",		NULL,		NULL, 0 },
+{ 0x414b4d02, 0xffffffff, "AK4543",		NULL,		NULL, 0 },
+{ 0x414b4d06, 0xffffffff, "AK4544A",		NULL,		NULL, 0 },
+{ 0x414b4d07, 0xffffffff, "AK4545",		NULL,		NULL, 0 },
+{ 0x41445303, 0xffffffff, "AD1819",		patch_ad1819,	NULL, 0 },
+{ 0x41445340, 0xffffffff, "AD1881",		patch_ad1881,	NULL, 0 },
+{ 0x41445348, 0xffffffff, "AD1881A",		patch_ad1881,	NULL, 0 },
+{ 0x41445360, 0xffffffff, "AD1885",		patch_ad1885,	NULL, 0 },
+{ 0x41445361, 0xffffffff, "AD1886",		patch_ad1886,	NULL, 0 },
+{ 0x41445362, 0xffffffff, "AD1887",		patch_ad1881,	NULL, 0 },
+{ 0x41445363, 0xffffffff, "AD1886A",		patch_ad1881,	NULL, 0 },
+{ 0x41445368, 0xffffffff, "AD1888",		patch_ad1888,	NULL, 0 },
+{ 0x41445370, 0xffffffff, "AD1980",		patch_ad1980,	NULL, 0 },
+{ 0x41445372, 0xffffffff, "AD1981A",		patch_ad1981a,	NULL, 0 },
+{ 0x41445374, 0xffffffff, "AD1981B",		patch_ad1981b,	NULL, 0 },
+{ 0x41445375, 0xffffffff, "AD1985",		patch_ad1985,	NULL, 0 },
+{ 0x41445378, 0xffffffff, "AD1986",		patch_ad1985,	NULL, 0 },
+{ 0x414c4300, 0xffffff00, "ALC100,100P", 	NULL,		NULL, 0 },
+{ 0x414c4710, 0xfffffff0, "ALC200,200P",	NULL,		NULL, 0 },
+{ 0x414c4721, 0xffffffff, "ALC650D",		NULL,	NULL, 0 }, /* already patched */
+{ 0x414c4722, 0xffffffff, "ALC650E",		NULL,	NULL, 0 }, /* already patched */
+{ 0x414c4723, 0xffffffff, "ALC650F",		NULL,	NULL, 0 }, /* already patched */
+{ 0x414c4720, 0xfffffff0, "ALC650",		patch_alc650,	NULL, 0 },
+{ 0x414c4760, 0xfffffff0, "ALC655",		patch_alc655,	NULL, 0 },
+{ 0x414c4781, 0xffffffff, "ALC658D",		NULL,	NULL, 0 }, /* already patched */
+{ 0x414c4780, 0xfffffff0, "ALC658",		patch_alc655,	NULL, 0 },
+{ 0x414c4790, 0xfffffff0, "ALC850",		patch_alc850,	NULL, 0 },
+{ 0x414c4730, 0xffffffff, "ALC101",		NULL,		NULL, 0 },
+{ 0x414c4740, 0xfffffff0, "ALC202",		NULL,		NULL, 0 },
+{ 0x414c4750, 0xfffffff0, "ALC250",		NULL,		NULL, 0 },
+{ 0x414c4770, 0xfffffff0, "ALC203",		NULL,		NULL, 0 },
+{ 0x434d4941, 0xffffffff, "CMI9738",		patch_cm9738,	NULL, 0 },
+{ 0x434d4961, 0xffffffff, "CMI9739",		patch_cm9739,	NULL, 0 },
+{ 0x434d4969, 0xffffffff, "CMI9780",		patch_cm9780,	NULL, 0 },
+{ 0x434d4978, 0xffffffff, "CMI9761A",		patch_cm9761,	NULL, 0 },
+{ 0x434d4982, 0xffffffff, "CMI9761B",		patch_cm9761,	NULL, 0 },
+{ 0x434d4983, 0xffffffff, "CMI9761A+",		patch_cm9761,	NULL, 0 },
+{ 0x43525900, 0xfffffff8, "CS4297",		NULL,		NULL, 0 },
+{ 0x43525910, 0xfffffff8, "CS4297A",		patch_cirrus_spdif,	NULL, 0 },
+{ 0x43525920, 0xfffffff8, "CS4298",		patch_cirrus_spdif,		NULL, 0 },
+{ 0x43525928, 0xfffffff8, "CS4294",		NULL,		NULL, 0 },
+{ 0x43525930, 0xfffffff8, "CS4299",		patch_cirrus_cs4299,	NULL, 0 },
+{ 0x43525948, 0xfffffff8, "CS4201",		NULL,		NULL, 0 },
+{ 0x43525958, 0xfffffff8, "CS4205",		patch_cirrus_spdif,	NULL, 0 },
+{ 0x43525960, 0xfffffff8, "CS4291",		NULL,		NULL, 0 },
+{ 0x43525970, 0xfffffff8, "CS4202",		NULL,		NULL, 0 },
+{ 0x43585421, 0xffffffff, "HSD11246",		NULL,		NULL, 0 },	// SmartMC II
+{ 0x43585428, 0xfffffff8, "Cx20468",		patch_conexant,	NULL, 0 }, // SmartAMC fixme: the mask might be different
+{ 0x44543031, 0xfffffff0, "DT0398",		NULL,		NULL, 0 },
+{ 0x454d4328, 0xffffffff, "EM28028",		NULL,		NULL, 0 },  // same as TR28028?
+{ 0x45838308, 0xffffffff, "ESS1988",		NULL,		NULL, 0 },
+{ 0x48525300, 0xffffff00, "HMP9701",		NULL,		NULL, 0 },
+{ 0x49434501, 0xffffffff, "ICE1230",		NULL,		NULL, 0 },
+{ 0x49434511, 0xffffffff, "ICE1232",		NULL,		NULL, 0 }, // alias VIA VT1611A?
+{ 0x49434514, 0xffffffff, "ICE1232A",		NULL,		NULL, 0 },
+{ 0x49434551, 0xffffffff, "VT1616", 		patch_vt1616,	NULL, 0 },
+{ 0x49434552, 0xffffffff, "VT1616i",		patch_vt1616,	NULL, 0 }, // VT1616 compatible (chipset integrated)
+{ 0x49544520, 0xffffffff, "IT2226E",		NULL,		NULL, 0 },
+{ 0x49544561, 0xffffffff, "IT2646E",		patch_it2646,	NULL, 0 },
+{ 0x4e534300, 0xffffffff, "LM4540,43,45,46,48",	NULL,		NULL, 0 }, // only guess --jk
+{ 0x4e534331, 0xffffffff, "LM4549",		NULL,		NULL, 0 },
+{ 0x4e534350, 0xffffffff, "LM4550",		patch_lm4550,  	NULL, 0 }, // volume wrap fix 
+{ 0x50534304, 0xffffffff, "UCB1400",		patch_ucb1400,	NULL, 0 },
 { 0x53494c20, 0xffffffe0, "Si3036,8",		mpatch_si3036,	mpatch_si3036, AC97_MODEM_PATCH },
-{ 0x54524102, 0xffffffff, "TR28022",		NULL,		NULL },
-{ 0x54524106, 0xffffffff, "TR28026",		NULL,		NULL },
-{ 0x54524108, 0xffffffff, "TR28028",		patch_tritech_tr28028,	NULL }, // added by xin jin [07/09/99]
-{ 0x54524123, 0xffffffff, "TR28602",		NULL,		NULL }, // only guess --jk [TR28023 = eMicro EM28023 (new CT1297)]
-{ 0x54584e20, 0xffffffff, "TLC320AD9xC",	NULL,		NULL },
-{ 0x56494161, 0xffffffff, "VIA1612A",		NULL,		NULL }, // modified ICE1232 with S/PDIF
-{ 0x56494170, 0xffffffff, "VIA1617A",		patch_vt1617a,	NULL }, // modified VT1616 with S/PDIF
-{ 0x56494182, 0xffffffff, "VIA1618",		NULL,		NULL },
-{ 0x57454301, 0xffffffff, "W83971D",		NULL,		NULL },
-{ 0x574d4c00, 0xffffffff, "WM9701A",		NULL,		NULL },
-{ 0x574d4C03, 0xffffffff, "WM9703,WM9707,WM9708,WM9717", patch_wolfson03, NULL},
-{ 0x574d4C04, 0xffffffff, "WM9704M,WM9704Q",	patch_wolfson04, NULL},
-{ 0x574d4C05, 0xffffffff, "WM9705,WM9710",	patch_wolfson05, NULL},
-{ 0x574d4C09, 0xffffffff, "WM9709",		NULL,		NULL},
-{ 0x574d4C12, 0xffffffff, "WM9711,WM9712",	patch_wolfson11, NULL},
+{ 0x54524102, 0xffffffff, "TR28022",		NULL,		NULL, 0 },
+{ 0x54524106, 0xffffffff, "TR28026",		NULL,		NULL, 0 },
+{ 0x54524108, 0xffffffff, "TR28028",		patch_tritech_tr28028,	NULL, 0 }, // added by xin jin [07/09/99]
+{ 0x54524123, 0xffffffff, "TR28602",		NULL,		NULL, 0 }, // only guess --jk [TR28023 = eMicro EM28023 (new CT1297)]
+{ 0x54584e20, 0xffffffff, "TLC320AD9xC",	NULL,		NULL, 0 },
+{ 0x56494161, 0xffffffff, "VIA1612A",		NULL,		NULL, 0 }, // modified ICE1232 with S/PDIF
+{ 0x56494170, 0xffffffff, "VIA1617A",		patch_vt1617a,	NULL, 0 }, // modified VT1616 with S/PDIF
+{ 0x56494182, 0xffffffff, "VIA1618",		NULL,		NULL, 0 },
+{ 0x57454301, 0xffffffff, "W83971D",		NULL,		NULL, 0 },
+{ 0x574d4c00, 0xffffffff, "WM9701A",		NULL,		NULL, 0 },
+{ 0x574d4C03, 0xffffffff, "WM9703,WM9707,WM9708,WM9717", patch_wolfson03, NULL, 0},
+{ 0x574d4C04, 0xffffffff, "WM9704M,WM9704Q",	patch_wolfson04, NULL, 0},
+{ 0x574d4C05, 0xffffffff, "WM9705,WM9710",	patch_wolfson05, NULL, 0},
+{ 0x574d4C09, 0xffffffff, "WM9709",		NULL,		NULL, 0},
+{ 0x574d4C12, 0xffffffff, "WM9711,WM9712",	patch_wolfson11, NULL, 0},
 { 0x574d4c13, 0xffffffff, "WM9713,WM9714",	patch_wolfson13, NULL, AC97_DEFAULT_POWER_OFF},
-{ 0x594d4800, 0xffffffff, "YMF743",		NULL,		NULL },
-{ 0x594d4802, 0xffffffff, "YMF752",		NULL,		NULL },
-{ 0x594d4803, 0xffffffff, "YMF753",		patch_yamaha_ymf753,	NULL },
-{ 0x83847600, 0xffffffff, "STAC9700,83,84",	patch_sigmatel_stac9700,	NULL },
-{ 0x83847604, 0xffffffff, "STAC9701,3,4,5",	NULL,		NULL },
-{ 0x83847605, 0xffffffff, "STAC9704",		NULL,		NULL },
-{ 0x83847608, 0xffffffff, "STAC9708,11",	patch_sigmatel_stac9708,	NULL },
-{ 0x83847609, 0xffffffff, "STAC9721,23",	patch_sigmatel_stac9721,	NULL },
-{ 0x83847644, 0xffffffff, "STAC9744",		patch_sigmatel_stac9744,	NULL },
-{ 0x83847650, 0xffffffff, "STAC9750,51",	NULL,		NULL },	// patch?
-{ 0x83847652, 0xffffffff, "STAC9752,53",	NULL,		NULL }, // patch?
-{ 0x83847656, 0xffffffff, "STAC9756,57",	patch_sigmatel_stac9756,	NULL },
-{ 0x83847658, 0xffffffff, "STAC9758,59",	patch_sigmatel_stac9758,	NULL },
-{ 0x83847666, 0xffffffff, "STAC9766,67",	NULL,		NULL }, // patch?
-{ 0, 	      0,	  NULL,			NULL,		NULL }
+{ 0x594d4800, 0xffffffff, "YMF743",		NULL,		NULL, 0 },
+{ 0x594d4802, 0xffffffff, "YMF752",		NULL,		NULL, 0 },
+{ 0x594d4803, 0xffffffff, "YMF753",		patch_yamaha_ymf753,	NULL, 0 },
+{ 0x83847600, 0xffffffff, "STAC9700,83,84",	patch_sigmatel_stac9700,	NULL, 0 },
+{ 0x83847604, 0xffffffff, "STAC9701,3,4,5",	NULL,		NULL, 0 },
+{ 0x83847605, 0xffffffff, "STAC9704",		NULL,		NULL, 0 },
+{ 0x83847608, 0xffffffff, "STAC9708,11",	patch_sigmatel_stac9708,	NULL, 0 },
+{ 0x83847609, 0xffffffff, "STAC9721,23",	patch_sigmatel_stac9721,	NULL, 0 },
+{ 0x83847644, 0xffffffff, "STAC9744",		patch_sigmatel_stac9744,	NULL, 0 },
+{ 0x83847650, 0xffffffff, "STAC9750,51",	NULL,		NULL, 0 },	// patch?
+{ 0x83847652, 0xffffffff, "STAC9752,53",	NULL,		NULL, 0 }, // patch?
+{ 0x83847656, 0xffffffff, "STAC9756,57",	patch_sigmatel_stac9756,	NULL, 0 },
+{ 0x83847658, 0xffffffff, "STAC9758,59",	patch_sigmatel_stac9758,	NULL, 0 },
+{ 0x83847666, 0xffffffff, "STAC9766,67",	NULL,		NULL, 0 }, // patch?
+{ 0, 	      0,	  NULL,			NULL,		NULL, 0 }
 };
 
 
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/sound/pci/ac97/ac97_patch.c linux-2.6.20.1-pax/sound/pci/ac97/ac97_patch.c
--- linux-2.6.20.1/sound/pci/ac97/ac97_patch.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/sound/pci/ac97/ac97_patch.c	2007-02-15 23:35:17.000000000 +0100
@@ -1404,7 +1404,7 @@ static const struct snd_ac97_res_table a
 	{ AC97_VIDEO, 0x9f1f },
 	{ AC97_AUX, 0x9f1f },
 	{ AC97_PCM, 0x9f1f },
-	{ } /* terminator */
+	{ 0, 0} /* terminator */
 };
 
 int patch_ad1819(struct snd_ac97 * ac97)
@@ -2924,7 +2924,7 @@ static struct snd_ac97_res_table lm4550_
 	{ AC97_AUX, 0x1f1f },
 	{ AC97_PCM, 0x1f1f },
 	{ AC97_REC_GAIN, 0x0f0f },
-	{ } /* terminator */
+	{ 0, 0 } /* terminator */
 };
 
 int patch_lm4550(struct snd_ac97 *ac97)
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/sound/pci/ens1370.c linux-2.6.20.1-pax/sound/pci/ens1370.c
--- linux-2.6.20.1/sound/pci/ens1370.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/sound/pci/ens1370.c	2007-02-15 23:42:54.000000000 +0100
@@ -455,7 +455,7 @@ static struct pci_device_id snd_audiopci
 	{ 0x1274, 0x5880, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1373 - CT5880 */
 	{ 0x1102, 0x8938, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* Ectiva EV1938 */
 #endif
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, snd_audiopci_ids);
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/sound/pci/intel8x0.c linux-2.6.20.1-pax/sound/pci/intel8x0.c
--- linux-2.6.20.1/sound/pci/intel8x0.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/sound/pci/intel8x0.c	2007-02-15 23:42:32.000000000 +0100
@@ -437,7 +437,7 @@ static struct pci_device_id snd_intel8x0
 	{ 0x1022, 0x746d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL },	/* AMD8111 */
 	{ 0x1022, 0x7445, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL },	/* AMD768 */
 	{ 0x10b9, 0x5455, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALI },   /* Ali5455 */
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, snd_intel8x0_ids);
@@ -2046,7 +2046,7 @@ static struct ac97_quirk ac97_quirks[] _
 		.type = AC97_TUNE_HP_ONLY
 	},
 #endif
-	{ } /* terminator */
+	{ 0, 0, 0, 0, NULL, 0 } /* terminator */
 };
 
 static int __devinit snd_intel8x0_mixer(struct intel8x0 *chip, int ac97_clock,
diff -NurpX linux-2.6.20.1-pax/Documentation/dontdiff -x 'netfilter*' linux-2.6.20.1/sound/pci/intel8x0m.c linux-2.6.20.1-pax/sound/pci/intel8x0m.c
--- linux-2.6.20.1/sound/pci/intel8x0m.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20.1-pax/sound/pci/intel8x0m.c	2007-02-15 23:39:57.000000000 +0100
@@ -244,7 +244,7 @@ static struct pci_device_id snd_intel8x0
 	{ 0x1022, 0x746d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL },	/* AMD8111 */
 	{ 0x10b9, 0x5455, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALI },   /* Ali5455 */
 #endif
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, snd_intel8x0m_ids);
@@ -1297,7 +1297,7 @@ static struct shortname_table {
 	{ 0x5455, "ALi M5455" },
 	{ 0x746d, "AMD AMD8111" },
 #endif
-	{ 0 },
+	{ 0, NULL },
 };
 
 static int __devinit snd_intel8x0m_probe(struct pci_dev *pci,
--- a/include/asm-i386/pda.h	2007-03-02 02:42:24.000000000 +0100
+++ b/include/asm-i386/pda.h	2007-03-02 09:29:36.000000000 +0100
@@ -8,6 +8,7 @@
 
 #include <linux/stddef.h>
 #include <linux/types.h>
+#include <linux/threads.h>
 
 struct i386_pda
 {
