diff -urN linux-2.2.26.orig/drivers/char/cyclades.c linux-2.2.26/drivers/char/cyclades.c
--- linux-2.2.26.orig/drivers/char/cyclades.c	2001-11-02 17:39:06.000000000 +0100
+++ linux-2.2.26/drivers/char/cyclades.c	2004-10-25 00:41:47.000000000 +0200
@@ -1019,10 +1019,7 @@
 	wake_up_interruptible(&info->delta_msr_wait);
     }
     if (test_and_clear_bit(Cy_EVENT_WRITE_WAKEUP, &info->event)) {
-        if((tty->flags & (1<< TTY_DO_WRITE_WAKEUP))
-        && tty->ldisc.write_wakeup){
-            (tty->ldisc.write_wakeup)(tty);
-        }
+	tty_wakeup(tty);
         wake_up_interruptible(&tty->write_wait);
 	wake_up_interruptible(&tty->poll_wait);
     }
@@ -2821,6 +2818,7 @@
 cy_close(struct tty_struct *tty, struct file *filp)
 {
   struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+  struct tty_ldisc *ld;
   unsigned long flags;
 
 #ifdef CY_DEBUG_OTHER
@@ -2938,8 +2936,12 @@
     shutdown(info);
     if (tty->driver.flush_buffer)
         tty->driver.flush_buffer(tty);
-    if (tty->ldisc.flush_buffer)
-        tty->ldisc.flush_buffer(tty);
+    ld = tty_ldisc_ref(tty);
+    if (ld) {
+	    if (ld->flush_buffer)
+	    ld->flush_buffer(tty);
+	    tty_ldisc_deref(ld);
+    }
     CY_LOCK(info, flags);
 
     tty->closing = 0;
@@ -4701,11 +4703,9 @@
 	}
 	CY_UNLOCK(info, flags);
     }
+    tty_wakeup(tty);
     wake_up_interruptible(&tty->write_wait);
     wake_up_interruptible(&tty->poll_wait);
-    if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP))
-	&& tty->ldisc.write_wakeup)
-	    (tty->ldisc.write_wakeup)(tty);
 } /* cy_flush_buffer */
 
 
diff -urN linux-2.2.26.orig/drivers/char/dz.c linux-2.2.26/drivers/char/dz.c
--- linux-2.2.26.orig/drivers/char/dz.c	2001-03-25 18:31:27.000000000 +0200
+++ linux-2.2.26/drivers/char/dz.c	2004-10-31 09:32:57.000000000 +0100
@@ -1084,10 +1084,10 @@
   info->event = 0;
   info->tty = 0;
 
-  if (tty->ldisc.num != ldiscs[N_TTY].num) {
+  if (tty->ldisc.num != N_TTY) {
     if (tty->ldisc.close)
       (tty->ldisc.close)(tty);
-    tty->ldisc = ldiscs[N_TTY];
+    tty->ldisc = *(tty_ldisc_get(N_TTY));
     tty->termios->c_line = N_TTY;
     if (tty->ldisc.open)
       (tty->ldisc.open)(tty);
diff -urN linux-2.2.26.orig/drivers/char/epca.c linux-2.2.26/drivers/char/epca.c
--- linux-2.2.26.orig/drivers/char/epca.c	2001-11-02 17:39:06.000000000 +0100
+++ linux-2.2.26/drivers/char/epca.c	2004-10-25 00:50:02.000000000 +0200
@@ -572,7 +572,8 @@
 
 	if ((ch = verifyChannel(tty)) != NULL) 
 	{ /* Begin if ch != NULL */
-
+		struct tty_ldisc *ld;	
+	
 		save_flags(flags);
 		cli();
 
@@ -633,8 +634,12 @@
 		if (tty->driver.flush_buffer)
 			tty->driver.flush_buffer(tty);
 
-		if (tty->ldisc.flush_buffer)
-			tty->ldisc.flush_buffer(tty);
+		ld = tty_ldisc_ref(tty);
+			if (ld != NULL) {
+				if(ld->flush_buffer)
+				    ld->flush_buffer(tty);
+			tty_ldisc_deref(ld);
+			}
 
 		shutdown(ch);
 		tty->closing = 0;
@@ -737,12 +742,20 @@
 	{ /* Begin if ch != NULL */
 
 		unsigned long flags;
-
+		struct tty_ldisc *ld;
+		
 		save_flags(flags);
 		cli();
 		if (tty->driver.flush_buffer)
 			tty->driver.flush_buffer(tty);
 
+		ld = tty_ldisc_ref(tty);
+		if (ld != NULL) {
+			if (ld->flush_buffer)
+				ld->flush_buffer(tty);
+			tty_ldisc_deref(ld);
+		}
+		
 		if (tty->ldisc.flush_buffer)
 			tty->ldisc.flush_buffer(tty);
 
@@ -1227,9 +1240,8 @@
 
 	wake_up_interruptible(&tty->write_wait);
 	wake_up_interruptible(&tty->poll_wait);
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup)(tty);
-
+	tty_wakeup(tty);
+	
 } /* End pc_flush_buffer */
 
 /* ------------------ Begin pc_flush_chars  ---------------------- */
@@ -2443,9 +2455,7 @@
 				{ /* Begin if LOWWAIT */
 
 					ch->statusflags &= ~LOWWAIT;
-					if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-						  tty->ldisc.write_wakeup)
-						(tty->ldisc.write_wakeup)(tty);
+					tty_wakeup(tty);
 					wake_up_interruptible(&tty->write_wait);
 					wake_up_interruptible(&tty->poll_wait);
 				} /* End if LOWWAIT */
@@ -2462,9 +2472,7 @@
 				{ /* Begin if EMPTYWAIT */
 
 					ch->statusflags &= ~EMPTYWAIT;
-					if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-						  tty->ldisc.write_wakeup)
-						(tty->ldisc.write_wakeup)(tty);
+					tty_wakeup(tty);
 
 					wake_up_interruptible(&tty->write_wait);
 					wake_up_interruptible(&tty->poll_wait);
@@ -3327,6 +3335,7 @@
 				tty_wait_until_sent(tty, 0);
 			}
 			else 
+			/* ldisc lock already held in ioctl */
 			{
 				if (tty->ldisc.flush_buffer)
 					tty->ldisc.flush_buffer(tty);
diff -urN linux-2.2.26.orig/drivers/char/generic_serial.c linux-2.2.26/drivers/char/generic_serial.c
--- linux-2.2.26.orig/drivers/char/generic_serial.c	2001-03-25 18:31:27.000000000 +0200
+++ linux-2.2.26/drivers/char/generic_serial.c	2004-10-31 08:46:56.000000000 +0100
@@ -453,9 +453,7 @@
 	restore_flags(flags);
 
 	wake_up_interruptible(&tty->write_wait);
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup)(tty);
+	tty_wakeup(tty);
 	func_exit ();
 }
 
@@ -595,9 +593,7 @@
 	if (!tty) return;
 
 	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &port->event)) {
-		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-		    tty->ldisc.write_wakeup)
-			(tty->ldisc.write_wakeup)(tty);
+		tty_wakeup(tty);
 		wake_up_interruptible(&tty->write_wait);
 	}
 	func_exit ();
@@ -740,8 +736,9 @@
 {
 	unsigned long flags;
 	struct gs_port *port;
-
-	func_enter ();
+	struct tty_ldisc *ld;
+ 
+	func_enter();
 
 	if (!tty) return;
 
@@ -818,8 +815,12 @@
 
 	if (tty->driver.flush_buffer)
 		tty->driver.flush_buffer(tty);
-	if (tty->ldisc.flush_buffer)
-		tty->ldisc.flush_buffer(tty);
+	ld = tty_ldisc_ref(tty);
+	if (ld != NULL) {
+		if (ld->flush_buffer) 
+			ld->flush_buffer(tty);
+		tty_ldisc_deref(ld);
+	}
 	tty->closing = 0;
 
 	port->event = 0;
diff -urN linux-2.2.26.orig/drivers/char/isicom.c linux-2.2.26/drivers/char/isicom.c
--- linux-2.2.26.orig/drivers/char/isicom.c	2001-03-25 18:31:27.000000000 +0200
+++ linux-2.2.26/drivers/char/isicom.c	2004-10-31 08:56:09.000000000 +0100
@@ -621,10 +621,8 @@
 	
 	if (!tty)
 		return;
-	
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup)(tty);
+
+	tty_wakeup(tty);
 	wake_up_interruptible(&tty->write_wait);
 } 		
  		
@@ -1349,7 +1347,8 @@
 	struct isi_port * port = (struct isi_port *) tty->driver_data;
 	struct isi_board * card;
 	unsigned long flags;
-	
+	struct tty_ldisc *ld;
+
 #ifdef ISICOM_DEBUG		
 	printk(KERN_DEBUG "ISICOM: Close start!!!.\n");
 #endif	
@@ -1417,6 +1416,12 @@
 	isicom_shutdown_port(port);
 	if (tty->driver.flush_buffer)
 		tty->driver.flush_buffer(tty);
+	ld = tty_ldisc_ref(tty);
+	if (ld != NULL) {
+		if (ld->flush_buffer)
+		ld->flush_buffer(tty);
+		tty_ldisc_deref(ld);
+	}
 	if (tty->ldisc.flush_buffer)
 		tty->ldisc.flush_buffer(tty);
 
@@ -1912,9 +1917,7 @@
 	spin_unlock_irqrestore(&card->card_lock, flags);
 	
 	wake_up_interruptible(&tty->write_wait);
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup)(tty);
+	tty_wakeup(tty);
 }
 
 
diff -urN linux-2.2.26.orig/drivers/char/moxa.c linux-2.2.26/drivers/char/moxa.c
--- linux-2.2.26.orig/drivers/char/moxa.c	2001-11-02 17:39:06.000000000 +0100
+++ linux-2.2.26/drivers/char/moxa.c	2004-10-31 09:02:00.000000000 +0100
@@ -616,6 +616,7 @@
 {
 	struct moxa_str *ch;
 	int port;
+	struct tty_ldisc *ld;
 
 	port = PORTNO(tty);
 	if (port == MAX_PORTS) {
@@ -673,8 +674,13 @@
 
 	if (tty->driver.flush_buffer)
 		tty->driver.flush_buffer(tty);
-	if (tty->ldisc.flush_buffer)
-		tty->ldisc.flush_buffer(tty);
+
+	ld = tty_ldisc_ref(tty);
+	if (ld != NULL) {
+		if (ld->flush_buffer)
+			ld->flush_buffer(tty);
+		tty_ldisc_deref(ld);
+	}
 	tty->closing = 0;
 	ch->event = 0;
 	ch->tty = 0;
@@ -750,9 +756,7 @@
 	if (ch == NULL)
 		return;
 	MoxaPortFlushData(ch->port, 1);
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup) (tty);
+	tty_wakeup(tty);
 	wake_up_interruptible(&tty->write_wait);
 	wake_up_interruptible(&tty->poll_wait);
 }
@@ -989,7 +993,6 @@
 		moxaTimer.function = moxa_poll;
 		moxaTimer.expires = jiffies + (HZ / 50);
 		moxaTimer_on = 1;
-		add_timer(&moxaTimer);
 		return;
 	}
 	for (card = 0; card < MAX_BOARDS; card++) {
@@ -1008,9 +1011,7 @@
 				if (MoxaPortTxQueue(ch->port) <= WAKEUP_CHARS) {
 					if (!tp->stopped) {
 						ch->statusflags &= ~LOWWAIT;
-						if ((tp->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-						  tp->ldisc.write_wakeup)
-							(tp->ldisc.write_wakeup) (tp);
+						tty_wakeup(tp);
 						wake_up_interruptible(&tp->write_wait);
 						wake_up_interruptible(&tp->poll_wait);
 					}
@@ -1199,9 +1200,7 @@
 	if (ch->tty && (ch->statusflags & EMPTYWAIT)) {
 		if (MoxaPortTxQueue(ch->port) == 0) {
 			ch->statusflags &= ~EMPTYWAIT;
-			if ((ch->tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-			    ch->tty->ldisc.write_wakeup)
-				(ch->tty->ldisc.write_wakeup) (ch->tty);
+			tty_wakeup(ch->tty);
 			wake_up_interruptible(&ch->tty->write_wait);
 			wake_up_interruptible(&ch->tty->poll_wait);
 			return;
diff -urN linux-2.2.26.orig/drivers/char/mxser.c linux-2.2.26/drivers/char/mxser.c
--- linux-2.2.26.orig/drivers/char/mxser.c	2001-03-25 18:31:28.000000000 +0200
+++ linux-2.2.26/drivers/char/mxser.c	2004-10-31 09:06:54.000000000 +0100
@@ -712,9 +712,7 @@
 	if (!tty)
 		return;
 	if (test_and_clear_bit(MXSER_EVENT_TXLOW, &info->event)) {
-		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-		    tty->ldisc.write_wakeup)
-			(tty->ldisc.write_wakeup) (tty);
+		tty_wakeup(tty);
 		wake_up_interruptible(&tty->write_wait);
 		wake_up_interruptible(&tty->poll_wait);
 	}
@@ -796,6 +794,7 @@
 	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
 	unsigned long flags;
 	unsigned long timeout;
+	struct tty_ldisc *ld;
 
 	if (PORTNO(tty) == MXSER_PORTS)
 		return;
@@ -876,6 +875,12 @@
 	mxser_shutdown(info);
 	if (tty->driver.flush_buffer)
 		tty->driver.flush_buffer(tty);
+	ld = tty_ldisc_ref(tty);
+	if (ld) {
+		if (ld->flush_buffer)
+			ld->flush_buffer(tty);
+			tty_ldisc_deref(ld);
+	}
 	if (tty->ldisc.flush_buffer)
 		tty->ldisc.flush_buffer(tty);
 	tty->closing = 0;
@@ -1013,9 +1018,7 @@
 	restore_flags(flags);
 	wake_up_interruptible(&tty->write_wait);
 	wake_up_interruptible(&tty->poll_wait);
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup) (tty);
+	tty_wakeup(tty);
 }
 
 static int mxser_ioctl(struct tty_struct *tty, struct file *file,
diff -urN linux-2.2.26.orig/drivers/char/n_tty.c linux-2.2.26/drivers/char/n_tty.c
--- linux-2.2.26.orig/drivers/char/n_tty.c	2001-03-25 18:31:25.000000000 +0200
+++ linux-2.2.26/drivers/char/n_tty.c	2004-10-31 13:27:14.177336648 +0100
@@ -78,11 +78,18 @@
 	spin_unlock_irqrestore(&tty->read_lock, flags);
 }
 
-/* 
+/*
+ * check_unthrottle - allow new receive data
+ * @tty; tty device
+ *
  * Check whether to call the driver.unthrottle function.
  * We test the TTY_THROTTLED bit first so that it always
- * indicates the current state.
- */
+ * indicates the current state. The decision about whether
+ * it is worth allowing more input has been taken by the caller.
+ * Can sleep, may be called under the atomic_read semaphore but
+ * this is not guaranteed.
+*/
+
 static void check_unthrottle(struct tty_struct * tty)
 {
 	if (tty->count &&
@@ -92,10 +99,14 @@
 }
 
 /*
+ * reset_buffer_flags - reset buffer state
+ * @tty: terminal to reset
+ *
  * Reset the read buffer counters, clear the flags, 
  * and make sure the driver is unthrottled. Called
  * from n_tty_open() and n_tty_flush_buffer().
  */
+
 static void reset_buffer_flags(struct tty_struct *tty)
 {
 	unsigned long flags;
@@ -109,8 +120,18 @@
 }
 
 /*
- * Flush the input buffer
+ * n_tty_flush_buffer - clean input queue
+ * @tty: terminal device
+ *
+ * Flush the input buffer. Called when the line discipline is
+ * being closed, when the tty layer wants the buffer flushed (eg
+ * at hangup) or when the N_TTY line discipline internally has to
+ * clean the pending queue (for example some signals).
+ *
+ * FIXME: tty->ctrl_status is not spinlocked and relies on
+ * lock_kernel() still.
  */
+
 void n_tty_flush_buffer(struct tty_struct * tty)
 {
 	/* clear everything and unthrottle the driver */
@@ -127,8 +148,13 @@
 }
 
 /*
- * Return number of characters buffered to be delivered to user
+ * n_tty_chars_in_buffer - report available bytes
+ * @tty: tty device
+ *
+ * Report the number of characters buffered to be delivered to user
+ * at this instant in time. 
  */
+
 ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
 {
 	unsigned long flags;
@@ -210,9 +236,19 @@
 }
 
 /*
- * opost_block --- to speed up block console writes, among other
- * things.
+ * opost_block - block postprocess
+ * @tty: terminal device
+ * @inbuf: user buffer
+ * @nr: number of bytes
+ *
+ * This path is used to speed up block console writes, among other
+ * things when processing blocks of output data. It handles only
+ * the simple cases normally found and helps to generate blocks of
+ * symbols for the console driver and thus improve performance.
+ *
+ * Called from write_chan under the tty layer write lock.
  */
+
 static ssize_t opost_block(struct tty_struct * tty,
 		       const unsigned char * inbuf, unsigned int nr)
 {
@@ -301,6 +337,16 @@
 	}
 }
 
+/*
+ * eraser - handle erase function
+ * @c: character input
+ * @tty: terminal device
+ *
+ * Perform erase and neccessary output when an erase character is
+ * present in the stream from the driver layer. Handles the complexities
+ * of UTF-8 multibyte symbols.
+ */
+
 static void eraser(unsigned char c, struct tty_struct *tty)
 {
 	enum { ERASE, WERASE, KILL } kill_type;
@@ -417,6 +463,18 @@
 		finish_erasing(tty);
 }
 
+/*
+ * isig - handle the ISIG optio
+ * @sig: signal
+ * @tty: terminal
+ * @flush: force flush
+ *
+ * Called when a signal is being sent due to terminal input. This
+ * may caus terminal flushing to take place according to the termios
+ * settings and character used. Called from the driver receive_buf
+ * path so serialized.
+ */
+ 
 static inline void isig(int sig, struct tty_struct *tty, int flush)
 {
 	if (tty->pgrp > 0)
@@ -428,6 +486,16 @@
 	}
 }
 
+/*
+ * n_tty_receive_break - handle break
+ * @tty: terminal
+ *
+ * An RS232 break event has been hit in the incoming bitstream. This
+ * can cause a variety of events depending upon the termios settings.
+ *
+ * Called from the receive_buf path so single threaded.
+ */
+
 static inline void n_tty_receive_break(struct tty_struct *tty)
 {
 	if (I_IGNBRK(tty))
@@ -445,19 +513,41 @@
 	wake_up_interruptible(&tty->poll_wait);
 }
 
+/*
+ * n_tty_receive_overrun - handle overrun reporting
+ * @tty: terminal
+ *
+ * Data arrived faster than we could process it. While the tty
+ * driver has flagged this the bits that were missed are gone
+ * forever.
+ *
+ * Called from the receive_buf path so single threaded. Does not
+ * need locking as num_overrun and overrun_time are function
+ * private.
+ */
+
 static inline void n_tty_receive_overrun(struct tty_struct *tty)
 {
 	char buf[64];
 
 	tty->num_overrun++;
 	if (time_before(tty->overrun_time, jiffies - HZ)) {
-		printk("%s: %d input overrun(s)\n", tty_name(tty, buf),
+		printk(KERN_WARNING "%s: %d input overrun(s)\n", tty_name(tty, buf),
 		       tty->num_overrun);
 		tty->overrun_time = jiffies;
 		tty->num_overrun = 0;
 	}
 }
 
+/*
+ * n_tty_receive_parity_error - error notifier
+ * @tty: terminal device
+ * @c: character
+ *
+ * Process a parity error and queue the right data to indicate
+ * the error case if neccessary. Locking as per n_tty_receive_buf.
+ */
+
 static inline void n_tty_receive_parity_error(struct tty_struct *tty,
 					      unsigned char c)
 {
@@ -476,6 +566,16 @@
 	wake_up_interruptible(&tty->poll_wait);
 }
 
+/*
+ * n_tty_receive_char - perform processing
+ * @tty: terminal device
+ * @c: character
+ *
+ * Process an individual character of input received from the driver.
+ * This is serialized with respect to itself by the rules for the 
+ * driver above.
+ */
+
 static inline void n_tty_receive_char(struct tty_struct *tty, unsigned char c)
 {
 	if (tty->raw) {
@@ -667,6 +767,16 @@
 	put_tty_queue(c, tty);
 }	
 
+/*
+ * n_tty_receive_room - receive space
+ * @tty: terminal
+ *
+ * Called by the driver to find out how much data it is
+ * permitted to feed to the line discipline without any being lost
+ * and thus to manage flow control. Not serialized. Answers for the
+ * "instant".
+ */
+
 static int n_tty_receive_room(struct tty_struct *tty)
 {
 	int	left = N_TTY_BUF_SIZE - tty->read_cnt - 1;
@@ -685,6 +795,19 @@
 	return 0;
 }
 
+/*
+ * n_tty_receive_buf - data receive
+ * @tty: terminal device
+ * @cp: buffer
+ * @fp: flag buffer
+ * @count: characters
+ *
+ * Called by the terminal driver when a block of characters has
+ * been received. This function must be called from soft contexts
+ * not from interrupt context. The driver is responsible for making
+ * calls one at a time and in order (or using queue_ldisc)
+ */
+
 static void n_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,
 			      char *fp, int count)
 {
@@ -770,6 +893,18 @@
 	        current->sig->action[sig-1].sa.sa_handler == SIG_IGN);
 }
 
+/*
+ * n_tty_set_termios - termios data changed
+ * @tty: terminal
+ * @old: previous data
+ *
+ * Called by the tty layer when the user changes termios flags so
+ * that the line discipline can plan ahead. This function cannot sleep
+ * and is protected from re-entry by the tty layer. The user is 
+ * guaranteed that this function will not be re-entered or in progress
+ * when the ldisc is closed.
+ */
+
 static void n_tty_set_termios(struct tty_struct *tty, struct termios * old)
 {
 	if (!tty)
@@ -785,7 +920,6 @@
 	    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||
 	    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||
 	    I_PARMRK(tty)) {
-		cli();
 		memset(tty->process_char_map, 0, 256/8);
 
 		if (I_IGNCR(tty) || I_ICRNL(tty))
@@ -821,7 +955,6 @@
 			set_bit(SUSP_CHAR(tty), &tty->process_char_map);
 		}
 		clear_bit(__DISABLED_CHAR, &tty->process_char_map);
-		sti();
 		tty->raw = 0;
 		tty->real_raw = 0;
 	} else {
@@ -835,6 +968,16 @@
 	}
 }
 
+/*
+ * n_tty_close - close the ldisc for this tty
+ * @tty: device
+ *
+ * Called from the terminal layer when this line discipline is 
+ * being shut down, either because of a close or becsuse of a 
+ * discipline change. The function will not be called while other
+ * ldisc methods are in progress.
+ */
+
 static void n_tty_close(struct tty_struct *tty)
 {
 	n_tty_flush_buffer(tty);
@@ -844,6 +987,16 @@
 	}
 }
 
+/*
+ * n_tty_open - open an ldisc
+ * @tty: terminal to open
+ *
+ * Called when this line discipline is being attached to the 
+ * terminal device. Can sleep. Called serialized so that no
+ * other events will occur in parallel. No further open will occur
+ * until a close.
+ */
+
 static int n_tty_open(struct tty_struct *tty)
 {
 	if (!tty)
@@ -876,13 +1029,22 @@
 }
 
 /*
- * Helper function to speed up read_chan.  It is only called when
+ * copy_from_read_buf - copy read data directly
+ * @tty: terminal device
+ * @b: user data
+ * @nr: size of data
+ *
+ * Helper function to speed up read_chan. It is only called when
  * ICANON is off; it copies characters straight from the tty queue to
- * user space directly.  It can be profitably called twice; once to
+ * user space directly. It can be profitably called twice; once to
  * drain the space from the tail pointer to the (physical) end of the
  * buffer, and once to drain the space from the (physical) beginning of
  * the buffer to head pointer.
+ *
+ * Called under the tty->atomic_read sem and with TTY_DONT_FLIP set
+ *
  */
+
 static inline int copy_from_read_buf(struct tty_struct *tty,
 				      unsigned char **b,
 				      size_t *nr)
@@ -910,25 +1072,18 @@
 	return retval;
 }
 
-static ssize_t read_chan(struct tty_struct *tty, struct file *file,
-			 unsigned char *buf, size_t nr)
+/**
+ * job_control - check job control
+ * @tty: tty
+ * @file: file handle
+ *
+ * Perform job control management checks on this file/tty descriptor
+ * and if appropriate send any needed signals and return a negative
+ * error code if action should be taken.
+*/
+ 
+static int job_control(struct tty_struct *tty, struct file *file)
 {
-	unsigned char *b = buf;
-	struct wait_queue wait = { current, NULL };
-	int c;
-	int minimum, time;
-	ssize_t retval = 0;
-	ssize_t size;
-	long timeout;
-	unsigned long flags;
-
-do_it_again:
-
-	if (!tty->read_buf) {
-		printk("n_tty_read_chan: called with read_buf == NULL?!?\n");
-		return -EIO;
-	}
-
 	/* Job control check -- must be done at start and after
 	   every sleep (POSIX.1 7.1.1.4). */
 	/* NOTE: not yet done after every sleep pending a thorough
@@ -947,7 +1102,48 @@
 			return -ERESTARTSYS;
 		}
 	}
+return 0;
+
+}
+
+/**
+ * read_chan - read function for tty
+ * @tty: tty device
+ * @file: file object
+ * @buf: userspace buffer pointer
+ * @nr: size of I/O
+ *
+ * Perform reads for the line discipline. We are guaranteed that the
+ * line discipline will not be closed under us but we may get multiple
+ * parallel readers and must handle this ourselves. We may also get
+ * a hangup. Always called in user context, may sleep.
+ *
+ * This code must be sure never to sleep through a hangup.
+ */
+ 
+static ssize_t read_chan(struct tty_struct *tty, struct file *file,
+	unsigned char *buf, size_t nr)
+{
+	unsigned char *b = buf;
+	DECLARE_WAITQUEUE(wait, current);
+	int c;
+	int minimum, time;
+	ssize_t retval = 0;
+	ssize_t size;
+	long timeout;
+	unsigned long flags;
 
+	do_it_again:
+	
+	if (!tty->read_buf) {
+		printk("n_tty_read_chan: called with read_buf == NULL?!?\n");
+		return -EIO;
+	}
+	
+	c = job_control(tty, file);
+	if(c < 0)
+		return c;
+	
 	minimum = time = 0;
 	timeout = MAX_SCHEDULE_TIMEOUT;
 	if (!tty->icanon) {
@@ -969,6 +1165,9 @@
 		}
 	}
 
+	/*
+	 * Internal serialization of reads.
+	 */
 	if (file->f_flags & O_NONBLOCK) {
 		if (down_trylock(&tty->atomic_read))
 			return -EAGAIN;
@@ -1103,6 +1302,21 @@
 	return retval;
 }
 
+/*
+ * write_chan - write function for tty
+ * @tty: tty device
+ * @file: file object
+ * @buf: userspace buffer pointer
+ * @nr: size of I/O
+ *
+ * Write function of the terminal device. This is serialized with
+ * respect to other write callers but not to termios changes, reads
+ * and other such events. We must be careful with N_TTY as the receive
+ * code will echo characters, thus calling driver write methods.
+ *
+ * This code must be sure never to sleep through a hangup.
+ */
+
 static ssize_t write_chan(struct tty_struct * tty, struct file * file,
 			  const unsigned char * buf, size_t nr)
 {
@@ -1172,6 +1386,25 @@
 	return (b - buf) ? b - buf : retval;
 }
 
+/*
+ * normal_poll - poll method for N_TTY
+ * @tty: terminal device
+ * @file: file accessing it
+ * @wait: poll table
+ *
+ * Called when the line discipline is asked to poll() for data or
+ * for special events. This code is not serialized with respect to
+ * other events save open/close.
+ *
+ * This code must be sure never to sleep through a hangup.
+ * Called without the kernel lock held - fine
+ *
+ * FIXME: if someone changes the VMIN or discipline settings for the
+ * terminal while another process is in poll() the poll does not
+ * recompute the new limits. Possibly set_termios should issue
+ * a read wakeup to fix this bug.
+ */
+
 static unsigned int normal_poll(struct tty_struct * tty, struct file * file, poll_table *wait)
 {
 	unsigned int mask = 0;
diff -urN linux-2.2.26.orig/drivers/char/pcxx.c linux-2.2.26/drivers/char/pcxx.c
--- linux-2.2.26.orig/drivers/char/pcxx.c	2001-03-25 18:31:25.000000000 +0200
+++ linux-2.2.26/drivers/char/pcxx.c	2004-10-31 09:34:16.000000000 +0100
@@ -621,10 +621,10 @@
 ** please send me a note.  brian@ilinx.com
 ** Don't know either what this is supposed to do clameter@waterf.org.
 */
-		if(tty->ldisc.num != ldiscs[N_TTY].num) {
+		if(tty->ldisc.num != N_TTY) {
 			if(tty->ldisc.close)
 				(tty->ldisc.close)(tty);
-			tty->ldisc = ldiscs[N_TTY];
+			tty->ldisc = *(tty_ldisc_get(N_TTY));
 			tty->termios->c_line = N_TTY;
 			if(tty->ldisc.open)
 				(tty->ldisc.open)(tty);
diff -urN linux-2.2.26.orig/drivers/char/pty.c linux-2.2.26/drivers/char/pty.c
--- linux-2.2.26.orig/drivers/char/pty.c	2001-03-25 18:31:24.000000000 +0200
+++ linux-2.2.26/drivers/char/pty.c	2004-10-31 09:17:13.000000000 +0100
@@ -134,6 +134,10 @@
  *   (2) avoid redundant copying for cases where count >> receive_room
  * N.B. Calls from user space may now return an error code instead of
  * a count.
+ *
+ * FIXME: Our pty_write method is called with our ldisc lock held but
+ * not our partners. We can't just take the other one blindly without
+ + * risking deadlocks. There is also the small matter of TTY_DONT_FLIP
  */
 static int pty_write(struct tty_struct * tty, int from_user,
 		       const unsigned char *buf, int count)
diff -urN linux-2.2.26.orig/drivers/char/riscom8.c linux-2.2.26/drivers/char/riscom8.c
--- linux-2.2.26.orig/drivers/char/riscom8.c	2001-11-02 17:39:06.000000000 +0100
+++ linux-2.2.26/drivers/char/riscom8.c	2004-10-31 09:21:17.000000000 +0100
@@ -1110,7 +1110,8 @@
 	struct riscom_board *bp;
 	unsigned long flags;
 	unsigned long timeout;
-	
+	struct tty_ldisc *ld;
+
 	if (!port || rc_paranoia_check(port, tty->device, "close"))
 		return;
 	
@@ -1180,6 +1181,12 @@
 	rc_shutdown_port(bp, port);
 	if (tty->driver.flush_buffer)
 		tty->driver.flush_buffer(tty);
+	ld = tty_ldisc_ref(tty);
+	if (ld != NULL) {
+		if(ld->flush_buffer)
+			ld->flush_buffer(tty);
+		tty_ldisc_deref(ld);
+	}
 	if (tty->ldisc.flush_buffer)
 		tty->ldisc.flush_buffer(tty);
 	tty->closing = 0;
@@ -1358,9 +1365,7 @@
 	
 	wake_up_interruptible(&tty->write_wait);
 	wake_up_interruptible(&tty->poll_wait);
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup)(tty);
+	tty_wakeup(tty);
 }
 
 static int rc_get_modem_info(struct riscom_port * port, unsigned int *value)
@@ -1736,9 +1741,7 @@
 		return;
 
 	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &port->event)) {
-		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-		    tty->ldisc.write_wakeup)
-			(tty->ldisc.write_wakeup)(tty);
+		tty_wakeup(tty);
 		wake_up_interruptible(&tty->write_wait);
 		wake_up_interruptible(&tty->poll_wait);
 	}
diff -urN linux-2.2.26.orig/drivers/char/selection.c linux-2.2.26/drivers/char/selection.c
--- linux-2.2.26.orig/drivers/char/selection.c	2001-03-25 18:31:25.000000000 +0200
+++ linux-2.2.26/drivers/char/selection.c	2004-10-31 09:22:38.000000000 +0100
@@ -296,9 +296,11 @@
 {
 	struct vt_struct *vt = (struct vt_struct *) tty->driver_data;
 	int	pasted = 0, count;
+	struct tty_ldisc *ld;
 	struct wait_queue wait = { current, NULL };
 
 	poke_blanked_console();
+	ld = tty_ldisc_ref_wait(tty);
 	add_wait_queue(&vt->paste_wait, &wait);
 	while (sel_buffer && sel_buffer_lth > pasted) {
 		current->state = TASK_INTERRUPTIBLE;
@@ -313,6 +315,8 @@
 	}
 	remove_wait_queue(&vt->paste_wait, &wait);
 	current->state = TASK_RUNNING;
+
+	tty_ldisc_deref(ld);
 	return 0;
 }
 
diff -urN linux-2.2.26.orig/drivers/char/serial167.c linux-2.2.26/drivers/char/serial167.c
--- linux-2.2.26.orig/drivers/char/serial167.c	2001-03-25 18:31:26.000000000 +0200
+++ linux-2.2.26/drivers/char/serial167.c	2004-10-31 09:36:07.000000000 +0100
@@ -1943,10 +1943,10 @@
 	tty->ldisc.flush_buffer(tty);
     info->event = 0;
     info->tty = 0;
-    if (tty->ldisc.num != ldiscs[N_TTY].num) {
+    if (tty->ldisc.num != N_TTY) {
 	if (tty->ldisc.close)
 	    (tty->ldisc.close)(tty);
-	tty->ldisc = ldiscs[N_TTY];
+	tty->ldisc = *(tty_ldisc_get(N_TTY));
 	tty->termios->c_line = N_TTY;
 	if (tty->ldisc.open)
 	    (tty->ldisc.open)(tty);
diff -urN linux-2.2.26.orig/drivers/char/synclink.c linux-2.2.26/drivers/char/synclink.c
--- linux-2.2.26.orig/drivers/char/synclink.c	2001-11-02 17:39:06.000000000 +0100
+++ linux-2.2.26/drivers/char/synclink.c	2004-10-31 09:30:48.000000000 +0100
@@ -990,6 +990,42 @@
 	return 0;
 }
 
+/**
+ * line discipline callback wrappers
+ *
+ * The wrappers maintain line discipline references
+ * while calling into the line discipline.
+ *
+ * ldisc_flush_buffer - flush line discipline receive buffers
+ * ldisc_receive_buf - pass receive data to line discipline
+ */
+
+static void ldisc_flush_buffer(struct tty_struct *tty)
+{
+	struct tty_ldisc *ld = tty_ldisc_ref(tty);
+	
+	if (ld) {
+		if (ld->flush_buffer)
+			ld->flush_buffer(tty);
+	tty_ldisc_deref(ld);
+	}
+}
+
+static void ldisc_receive_buf(struct tty_struct *tty,
+	const __u8 *data, char *flags, int count)
+{
+	struct tty_ldisc *ld;
+	
+	if (!tty)
+		return;
+	ld = tty_ldisc_ref(tty);
+	if (ld) {
+		if (ld->receive_buf)
+		ld->receive_buf(tty, data, flags, count);
+		tty_ldisc_deref(ld);
+	}
+}
+
 /* mgsl_stop()		throttle (stop) transmitter
  * 	
  * Arguments:		tty	pointer to tty info structure
@@ -1141,13 +1177,7 @@
 			__FILE__,__LINE__,info->device_name);
 
 	if (tty) {
-		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-		    tty->ldisc.write_wakeup) {
-			if ( debug_level >= DEBUG_LEVEL_BH )
-				printk( "%s(%d):calling ldisc.write_wakeup on %s\n",
-					__FILE__,__LINE__,info->device_name);
-			(tty->ldisc.write_wakeup)(tty);
-		}
+		tty_wakeup(tty);
 		wake_up_interruptible(&tty->write_wait);
 	}
 
@@ -2392,11 +2422,8 @@
 	spin_unlock_irqrestore(&info->irq_spinlock,flags);
 	
 	wake_up_interruptible(&tty->write_wait);
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup)(tty);
-		
-}	/* end of mgsl_flush_buffer() */
+	tty_wakeup(tty);
+}
 
 /* mgsl_send_xchar()
  *
@@ -3297,10 +3324,8 @@
 
 	if (tty->driver.flush_buffer)
 		tty->driver.flush_buffer(tty);
-		
-	if (tty->ldisc.flush_buffer)
-		tty->ldisc.flush_buffer(tty);
-		
+	
+	ldisc_flush_buffer(tty); 		
 	shutdown(info);
 	
 	tty->closing = 0;
@@ -6999,11 +7024,7 @@
 			} 
 			else
 #endif
-			{
-				/* Call the line discipline receive callback directly. */
-				if ( tty && tty->ldisc.receive_buf )
-				tty->ldisc.receive_buf(tty, info->intermediate_rxbuffer, info->flag_buf, framesize);
-			}
+			ldisc_receive_buf(tty, info->intermediate_rxbuffer, info->flag_buf, framesize);
 		}
 	}
 	/* Free the buffers used by this frame. */
@@ -7175,9 +7196,7 @@
 			memcpy( info->intermediate_rxbuffer, pBufEntry->virt_addr, framesize);
 			info->icount.rxok++;
 
-			/* Call the line discipline receive callback directly. */
-			if ( tty && tty->ldisc.receive_buf )
-				tty->ldisc.receive_buf(tty, info->intermediate_rxbuffer, info->flag_buf, framesize);
+			ldisc_receive_buf(tty, info->intermediate_rxbuffer, info->flag_buf, framesize);
 		}
 
 		/* Free the buffers used by this frame. */
diff -urN linux-2.2.26.orig/drivers/char/tty_io.c linux-2.2.26/drivers/char/tty_io.c
--- linux-2.2.26.orig/drivers/char/tty_io.c	2004-10-31 11:15:19.128606952 +0100
+++ linux-2.2.26/drivers/char/tty_io.c	2004-10-31 12:02:45.000000000 +0100
@@ -101,9 +101,13 @@
 #define TTY_PARANOIA_CHECK 1
 #define CHECK_TTY_COUNT 1
 
+#define __builtin_expect(x, expected_value) (x)
+#define likely(x)       __builtin_expect((x),1)
+
+/* Lock for tty_termios changes - private to tty_io/tty_ioctl */
+spinlock_t tty_termios_lock = SPIN_LOCK_UNLOCKED;
 struct termios tty_std_termios;		/* for the benefit of tty drivers  */
 struct tty_driver *tty_drivers = NULL;	/* linked list of tty drivers */
-struct tty_ldisc ldiscs[NR_LDISCS];	/* line disc dispatch table	*/
 
 #ifdef CONFIG_UNIX98_PTYS
 extern struct tty_driver ptm_driver[];	/* Unix98 pty masters; for /dev/ptmx */
@@ -204,44 +208,256 @@
 	return 0;
 }
 
+/*
+ * This is probably overkill for real world processors but
+ * they are not on hot paths so a little discipline won't do
+ * any harm.
+ */ 
+
+static void tty_set_termios_ldisc(struct tty_struct *tty, int num)
+{
+ unsigned long flags;
+ spin_lock_irqsave(&tty_termios_lock, flags);
+ tty->termios->c_line = num;
+ spin_unlock_irqrestore(&tty_termios_lock, flags);
+}
+
+/*
+ * This guards the refcounted line discipline lists. The lock
+ * must be taken with irqs off because there are hangup path
+ * callers who will do ldisc lookups and cannot sleep.
+ */
+
+spinlock_t tty_ldisc_lock = SPIN_LOCK_UNLOCKED;
+DECLARE_WAIT_QUEUE_HEAD(tty_ldisc_wait);
+struct tty_ldisc tty_ldiscs[NR_LDISCS]; /* line disc dispatch table */
+
 int tty_register_ldisc(int disc, struct tty_ldisc *new_ldisc)
 {
+
+ unsigned long flags;
+ int ret = 0;
+
 	if (disc < N_TTY || disc >= NR_LDISCS)
 		return -EINVAL;
-	
+
+	spin_lock_irqsave(&tty_ldisc_lock, flags);
 	if (new_ldisc) {
-		ldiscs[disc] = *new_ldisc;
-		ldiscs[disc].flags |= LDISC_FLAG_DEFINED;
-		ldiscs[disc].num = disc;
-	} else
-		memset(&ldiscs[disc], 0, sizeof(struct tty_ldisc));
+	    tty_ldiscs[disc] = *new_ldisc;
+	    tty_ldiscs[disc].num = disc;
+	    tty_ldiscs[disc].flags |= LDISC_FLAG_DEFINED;
+	    tty_ldiscs[disc].refcount = 0;
+	} else {
+	if(tty_ldiscs[disc].refcount)
+	    ret = -EBUSY;
+	else
+	    tty_ldiscs[disc].flags &= ~LDISC_FLAG_DEFINED;
+	}
+	spin_unlock_irqrestore(&tty_ldisc_lock, flags);
 	
-	return 0;
+	return ret;
 }
 
-/* Set the discipline of a tty line. */
+EXPORT_SYMBOL(tty_register_ldisc);
+
+struct tty_ldisc *tty_ldisc_get(int disc)
+{
+	unsigned long flags;
+	struct tty_ldisc *ld;
+
+        if (disc < N_TTY || disc >= NR_LDISCS)
+		return NULL;
+
+        spin_lock_irqsave(&tty_ldisc_lock, flags);
+
+        ld = &tty_ldiscs[disc];
+        /* Check the entry is defined */
+        if(ld->flags & LDISC_FLAG_DEFINED)
+		ld->refcount++;
+        else
+		ld = NULL;
+	spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+	return ld;
+}
+
+EXPORT_SYMBOL_GPL(tty_ldisc_get);
+
+void tty_ldisc_put(int disc)
+{
+        struct tty_ldisc *ld;
+        unsigned long flags;
+
+        if (disc < N_TTY || disc >= NR_LDISCS)
+		BUG();
+
+        spin_lock_irqsave(&tty_ldisc_lock, flags);
+        ld = &tty_ldiscs[disc];
+        if(ld->refcount <= 0)
+		BUG();
+        ld->refcount--;
+        spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+}
+ 
+EXPORT_SYMBOL_GPL(tty_ldisc_put);
+
+void tty_ldisc_assign(struct tty_struct *tty, struct tty_ldisc *ld)
+{
+        tty->ldisc = *ld;
+        tty->ldisc.refcount = 0;
+}
+
+/**
+ * tty_ldisc_try - internal helper
+ * @tty: the tty
+ *
+ * Make a single attempt to grab and bump the refcount on
+ * the tty ldisc. Return 0 on failure or 1 on success. This is
+ * used to implement both the waiting and non waiting versions
+ * of tty_ldisc_ref
+ */
+
+static int tty_ldisc_try(struct tty_struct *tty)
+{
+        unsigned long flags;
+        struct tty_ldisc *ld;
+        int ret = 0;
+
+        spin_lock_irqsave(&tty_ldisc_lock, flags);
+        ld = &tty->ldisc;
+        if(test_bit(TTY_LDISC, &tty->flags)) {
+	        ld->refcount++;
+    	        ret = 1;
+	}
+    spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+    return ret;
+}
+
+/**
+ * tty_ldisc_ref_wait - wait for the tty ldisc
+ * @tty: tty device
+ *
+ * Dereference the line discipline for the terminal and take a
+ * reference to it. If the line discipline is in flux then
+ * wait patiently until it changes.
+ *
+ * Note: Must not be called from an IRQ/timer context. The caller
+ * must also be careful not to hold other locks that will deadlock
+ * against a discipline change, such as an existing ldisc reference
+ * (which we check for)
+ */
+
+struct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct *tty)
+{
+        /* wait_event is a macro */
+        wait_event(tty_ldisc_wait, tty_ldisc_try(tty));
+        return &tty->ldisc;
+}
+
+EXPORT_SYMBOL_GPL(tty_ldisc_ref_wait);
+
+/**
+ * tty_ldisc_ref - get the tty ldisc
+ * @tty: tty device
+ *
+ * Dereference the line discipline for the terminal and take a
+ * reference to it. If the line discipline is in flux then
+ * return NULL. Can be called from IRQ and timer functions.
+ */
+
+struct tty_ldisc *tty_ldisc_ref(struct tty_struct *tty)
+{
+        if(tty_ldisc_try(tty))
+		return &tty->ldisc;
+        return NULL;
+}
+
+EXPORT_SYMBOL_GPL(tty_ldisc_ref);
+
+void tty_ldisc_deref(struct tty_ldisc *ld)
+{
+        unsigned long flags;
+
+	if(ld == NULL)
+	    BUG();
+
+        spin_lock_irqsave(&tty_ldisc_lock, flags);
+	if(ld->refcount == 0)
+		printk(KERN_EMERG "tty_ldisc_deref: no references.\n");
+        else
+        	ld->refcount--;
+        if(ld->refcount == 0)
+		wake_up(&tty_ldisc_wait);
+        spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+}
+
+EXPORT_SYMBOL_GPL(tty_ldisc_deref);
+
+/**
+ * tty_set_ldisc - set line discipline
+ * @tty: the terminal to set
+ * @ldisc: the line discipline
+ *
+ * Set the discipline of a tty line. Must be called from a process
+ * context.
+ */
+
 static int tty_set_ldisc(struct tty_struct *tty, int ldisc)
 {
 	int	retval = 0;
 	struct	tty_ldisc o_ldisc;
 	char buf[64];
+	int work;
+	unsigned long flags;
+	struct tty_ldisc *ld;
 
 	if ((ldisc < N_TTY) || (ldisc >= NR_LDISCS))
 		return -EINVAL;
+
+	restart:
+
+	if (tty->ldisc.num == ldisc)
+	    return 0; /* We are already in the desired discipline */
+
+	ld = tty_ldisc_get(ldisc);
 	/* Eduardo Blanco <ejbs@cs.cs.com.uy> */
 	/* Cyrus Durgin <cider@speakeasy.org> */
-	if (!(ldiscs[ldisc].flags & LDISC_FLAG_DEFINED)) {
+	if (ld == NULL) {
 		char modname [20];
 		sprintf(modname, "tty-ldisc-%d", ldisc);
 		request_module (modname);
-	}
-	if (!(ldiscs[ldisc].flags & LDISC_FLAG_DEFINED))
+		ld = tty_ldisc_get(ldisc);	}
+	if (ld == NULL)
 		return -EINVAL;
 
-	if (tty->ldisc.num == ldisc)
-		return 0;	/* We are already in the desired discipline */
-	o_ldisc = tty->ldisc;
+	/*
+	* Make sure we don't change while someone holds a
+	* reference to the line discipline. The TTY_LDISC bit
+	* prevents anyone taking a reference once it is clear.
+	* We need the lock to avoid racing reference takers.
+	*/
+
+	spin_lock_irqsave(&tty_ldisc_lock, flags);
+	if(tty->ldisc.refcount)
+	{
+	    /* Free the new ldisc we grabbed. Must drop the lock
+	      first. */
+	    spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+	    tty_ldisc_put(ldisc);
+	    if(wait_event_interruptible(tty_ldisc_wait, tty->ldisc.refcount == 0) < 0)
+		    return -ERESTARTSYS;
+	    goto restart;
+	}
+	clear_bit(TTY_LDISC, &tty->flags);
+	clear_bit(TTY_DONT_FLIP, &tty->flags);
+	spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+		     
+	/*
+	 * From this point on we know nobody has an ldisc
+	 * usage reference, nor can they obtain one until
+	 * we say so later on.
+	 */
 
+	o_ldisc = tty->ldisc;
 	tty_wait_until_sent(tty, 0);
 	
 	/* Shutdown the current discipline. */
@@ -249,16 +465,20 @@
 		(tty->ldisc.close)(tty);
 
 	/* Now set up the new line discipline. */
-	tty->ldisc = ldiscs[ldisc];
-	tty->termios->c_line = ldisc;
+	tty_ldisc_assign(tty, ld);
+	tty_set_termios_ldisc(tty, ldisc);
 	if (tty->ldisc.open)
 		retval = (tty->ldisc.open)(tty);
 	if (retval < 0) {
-		tty->ldisc = o_ldisc;
-		tty->termios->c_line = tty->ldisc.num;
+		tty_ldisc_put(ldisc);
+		/* There is an outstanding reference here so this is safe */
+		tty_ldisc_assign(tty, tty_ldisc_get(o_ldisc.num));
+		tty_set_termios_ldisc(tty, tty->ldisc.num);
 		if (tty->ldisc.open && (tty->ldisc.open(tty) < 0)) {
-			tty->ldisc = ldiscs[N_TTY];
-			tty->termios->c_line = N_TTY;
+			tty_ldisc_put(o_ldisc.num);
+			/* This driver is always present */
+			tty_ldisc_assign(tty, tty_ldisc_get(N_TTY));
+			tty_set_termios_ldisc(tty, N_TTY);
 			if (tty->ldisc.open) {
 				int r = tty->ldisc.open(tty);
 
@@ -269,8 +489,23 @@
 			}
 		}
 	}
+	/* At this point we hold a reference to the new ldisc and a
+	reference to the old ldisc. If we ended up flipping back
+	to the existing ldisc we have two references to it */
+
 	if (tty->ldisc.num != o_ldisc.num && tty->driver.set_ldisc)
 		tty->driver.set_ldisc(tty);
+
+	tty_ldisc_put(o_ldisc.num);
+
+	/*
+	 * Allow ldisc referencing to occur as soon as the driver
+	 * ldisc callback completes.
+	*/
+
+	set_bit(TTY_LDISC, &tty->flags);
+	wake_up(&tty_ldisc_wait);
+	
 	return retval;
 }
 
@@ -385,6 +620,25 @@
 };
 
 /*
+ * Internal and external helper for wakeups of tty
+ */
+
+void tty_wakeup(struct tty_struct *tty)
+{
+	struct tty_ldisc *ld;
+
+	if (test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) {
+	    ld = tty_ldisc_ref(tty);
+	    if(ld) {
+		    if(ld->write_wakeup)
+	    		ld->write_wakeup(tty);
+		    tty_ldisc_deref(ld);
+	    }
+	}
+}
+
+EXPORT_SYMBOL_GPL(tty_wakeup);
+/*
  * This can be called through the "tq_scheduler" 
  * task-list. That is process synchronous, but
  * doesn't hold any locks, so we need to make
@@ -397,6 +651,7 @@
 	struct file * filp;
 	struct file * cons_filp = NULL;
 	struct task_struct *p;
+	struct tty_ldisc *ld;
 	int    closecount = 0, n;
 
 	if (!tty)
@@ -426,19 +681,18 @@
 	}
 	
 	/* FIXME! What are the locking issues here? This may me overdoing things.. */
-	{
-		unsigned long flags;
-
-		save_flags(flags); cli();
-		if (tty->ldisc.flush_buffer)
-			tty->ldisc.flush_buffer(tty);
+		ld = tty_ldisc_ref(tty);
+		if(ld != NULL) 	
+		{
+		if (ld->flush_buffer)
+			ld->flush_buffer(tty);
 		if (tty->driver.flush_buffer)
 			tty->driver.flush_buffer(tty);
-		if ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) &&
-		    tty->ldisc.write_wakeup)
-			(tty->ldisc.write_wakeup)(tty);
-		restore_flags(flags);
-	}
+		if ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) && ld->write_wakeup)
+		    ld->write_wakeup(tty);
+		    //if (ld->hangup)
+		// ld->hangup(tty);
+		}
 
 	wake_up_interruptible(&tty->write_wait);
 	wake_up_interruptible(&tty->read_wait);
@@ -448,20 +702,17 @@
 	 * Shutdown the current line discipline, and reset it to
 	 * N_TTY.
 	 */
+
 	if (tty->driver.flags & TTY_DRIVER_RESET_TERMIOS)
+	{
+		unsigned long flags;
+		spin_lock_irqsave(&tty_termios_lock, flags);
 		*tty->termios = tty->driver.init_termios;
-	if (tty->ldisc.num != ldiscs[N_TTY].num) {
-		if (tty->ldisc.close)
-			(tty->ldisc.close)(tty);
-		tty->ldisc = ldiscs[N_TTY];
-		tty->termios->c_line = N_TTY;
-		if (tty->ldisc.open) {
-			int i = (tty->ldisc.open)(tty);
-			if (i < 0)
-				printk("do_tty_hangup: N_TTY open: error %d\n",
-				       -i);
-		}
+		spin_unlock_irqrestore(&tty_termios_lock, flags);
 	}
+
+	/* Defer ldisc switch */
+	/* tty_deferred_ldisc_switch(N_TTY); */
 	
 	read_lock(&tasklist_lock);
  	for_each_task(p) {
@@ -493,6 +744,15 @@
 				tty->driver.close(tty, cons_filp);
 	} else if (tty->driver.hangup)
 		(tty->driver.hangup)(tty);
+
+	/* We don't want to have driver/ldisc interactions beyond
+	   the ones we did here. The driver layer expects no
+	   calls after ->hangup() from the ldisc side. However we
+	   can't yet guarantee all that */
+
+	set_bit(TTY_HUPPED, &tty->flags);
+	if(ld)
+    	    tty_ldisc_deref(ld);
 	unlock_kernel();
 }
 
@@ -602,9 +862,8 @@
 	}
 	if (tty->driver.start)
 		(tty->driver.start)(tty);
-	if ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup)(tty);
+	/* If we have a running line discipline it may need kicking */
+	    tty_wakeup(tty);	
 	wake_up_interruptible(&tty->write_wait);
 	wake_up_interruptible(&tty->poll_wait);
 }
@@ -615,6 +874,7 @@
 	int i;
 	struct tty_struct * tty;
 	struct inode *inode;
+	struct tty_ldisc *ld;
 
 	/* Can't seek (pread) on ttys.  */
 	if (ppos != &file->f_pos)
@@ -643,10 +903,16 @@
 			return -ERESTARTSYS;
 		}
 #endif
-	if (tty->ldisc.read)
-		i = (tty->ldisc.read)(tty,file,buf,count);
+	/* We want to wait for the line discipline to sort out in this
+	   situation */
+	ld = tty_ldisc_ref_wait(tty);
+	lock_kernel();
+	if (ld->read)
+		i = (ld->read)(tty,file,buf,count);
 	else
 		i = -EIO;
+	tty_ldisc_deref(ld);
+	unlock_kernel();
 	if (i > 0)
 		inode->i_atime = CURRENT_TIME;
 	return i;
@@ -717,7 +983,9 @@
 	int is_console;
 	struct tty_struct * tty;
 	struct inode *inode;
-
+	ssize_t ret;
+	struct tty_ldisc *ld;
+	
 	/* Can't seek (pwrite) on ttys.  */
 	if (ppos != &file->f_pos)
 		return -ESPIPE;
@@ -749,10 +1017,15 @@
 		}
 	}
 #endif
-	if (!tty->ldisc.write)
-		return -EIO;
-	return do_tty_write(tty->ldisc.write, tty, file,
-			    (const unsigned char *)buf, count);
+
+	ld = tty_ldisc_ref_wait(tty);
+	if (!ld->write)
+		ret = -EIO;
+	else
+		ret = do_tty_write(ld->write, tty, file,
+				(const unsigned char *) buf, count);
+		tty_ldisc_deref(ld);
+	return ret;
 }
 
 /* Semaphore to protect creating and releasing a tty */
@@ -917,7 +1190,9 @@
 				(tty->ldisc.close)(tty);
 			goto release_mem_out;
 		}
-	}
+	set_bit(TTY_LDISC, &o_tty->flags);
+         }
+	set_bit(TTY_LDISC, &tty->flags);
 	goto success;
 
 	/*
@@ -945,7 +1220,9 @@
 	}
 	tty->count++;
 	tty->driver = *driver; /* N.B. why do this every time?? */
-
+	/* FIXME */
+	if(!test_bit(TTY_LDISC, &tty->flags))
+		printk(KERN_ERR "init_dev but no ldisc\n");
 success:
 	*ret_tty = tty;
 	
@@ -1023,6 +1300,7 @@
 	int	pty_master, tty_closing, o_tty_closing, do_sleep;
 	int	idx;
 	char	buf[64];
+	unsigned long flags;
 	
 	tty = (struct tty_struct *)filp->private_data;
 	if (tty_paranoia_check(tty, filp->f_dentry->d_inode->i_rdev, "release_dev"))
@@ -1225,17 +1503,51 @@
 #endif
 
 	/*
+	 * Prevent flush_to_ldisc() from rescheduling the work for later. Then
+	 * kill any delayed work. As this is the final close it does not
+	 * race with the set_ldisc code path.
+	 */
+	clear_bit(TTY_LDISC, &tty->flags);
+	clear_bit(TTY_DONT_FLIP, &tty->flags);
+
+	/*
+	* Wait for any short term users (we know they are just driver
+	* side waiters as the file is closing so user count on the file
+	* side is zero.
+	*/
+	
+	spin_lock_irqsave(&tty_ldisc_lock, flags);
+	while(tty->ldisc.refcount)
+	{
+		spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+		wait_event(tty_ldisc_wait, tty->ldisc.refcount == 0);
+		spin_lock_irqsave(&tty_ldisc_lock, flags);
+	}
+	spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+	
+	/*
 	 * Shutdown the current line discipline, and reset it to N_TTY.
 	 * N.B. why reset ldisc when we're releasing the memory??
+	 * FIXME: this MUST get fixed for the new reflocking
 	 */
 	if (tty->ldisc.close)
 		(tty->ldisc.close)(tty);
-	tty->ldisc = ldiscs[N_TTY];
-	tty->termios->c_line = N_TTY;
+	tty_ldisc_put(tty->ldisc.num);
+
+	/*
+	 * Switch the line discipline back
+	 */
+	tty_ldisc_assign(tty, tty_ldisc_get(N_TTY));
+	tty_set_termios_ldisc(tty,N_TTY); 
+       
 	if (o_tty) {
+		/* FIXME: could o_tty be in setldisc here ? */
+		clear_bit(TTY_LDISC, &o_tty->flags);
 		if (o_tty->ldisc.close)
 			(o_tty->ldisc.close)(o_tty);
-		o_tty->ldisc = ldiscs[N_TTY];
+		tty_ldisc_put(o_tty->ldisc.num);
+		tty_ldisc_assign(o_tty, tty_ldisc_get(N_TTY));
+		tty_set_termios_ldisc(o_tty,N_TTY);
 	}
 	
 	/*
@@ -1409,14 +1721,18 @@
 static unsigned int tty_poll(struct file * filp, poll_table * wait)
 {
 	struct tty_struct * tty;
+	struct tty_ldisc *ld;
+	int ret = 0;
 
 	tty = (struct tty_struct *)filp->private_data;
 	if (tty_paranoia_check(tty, filp->f_dentry->d_inode->i_rdev, "tty_poll"))
 		return 0;
 
-	if (tty->ldisc.poll)
-		return (tty->ldisc.poll)(tty, filp, wait);
-	return 0;
+	ld = tty_ldisc_ref_wait(tty);
+	if (ld->poll)
+	        ret = (ld->poll)(tty, filp, wait);
+	tty_ldisc_deref(ld);
+	return ret;
 }
 
 /*
@@ -1493,12 +1809,15 @@
 static int tiocsti(struct tty_struct *tty, char * arg)
 {
 	char ch, mbz = 0;
+	struct tty_ldisc *ld;
 
 	if ((current->tty != tty) && !suser())
 		return -EPERM;
 	if (get_user(ch, arg))
 		return -EFAULT;
-	tty->ldisc.receive_buf(tty, &ch, &mbz, 1);
+	ld = tty_ldisc_ref_wait(tty);
+	ld->receive_buf(tty, &ch, &mbz, 1);
+	tty_ldisc_deref(ld);
 	return 0;
 }
 
@@ -1679,6 +1998,7 @@
 {
 	struct tty_struct *tty, *real_tty;
 	int retval;
+	struct tty_ldisc *ld;
 	
 	tty = (struct tty_struct *)file->private_data;
 	if (tty_paranoia_check(tty, inode->i_rdev, "tty_ioctl"))
@@ -1766,6 +2086,7 @@
 		case TIOCGSID:
 			return tiocgsid(tty, real_tty, (pid_t *) arg);
 		case TIOCGETD:
+			/* FIXME: check this is ok */
 			return put_user(tty->ldisc.num, (int *) arg);
 		case TIOCSETD:
 			return tiocsetd(tty, (int *) arg);
@@ -1799,16 +2120,20 @@
 			return send_break(tty, arg ? arg*(HZ/10) : HZ/4);
 	}
 	if (tty->driver.ioctl) {
-		int retval = (tty->driver.ioctl)(tty, file, cmd, arg);
+		retval = (tty->driver.ioctl)(tty, file, cmd, arg);
 		if (retval != -ENOIOCTLCMD)
 			return retval;
 	}
-	if (tty->ldisc.ioctl) {
-		int retval = (tty->ldisc.ioctl)(tty, file, cmd, arg);
-		if (retval != -ENOIOCTLCMD)
-			return retval;
+	ld = tty_ldisc_ref_wait(tty);
+	retval = -EINVAL;
+	if (ld->ioctl) {
+		if(likely(test_bit(TTY_LDISC, &tty->flags)))
+			retval = ld->ioctl(tty, file, cmd, arg);
+		if (retval == -ENOIOCTLCMD)
+			retval = -EINVAL;
 	}
-	return -EINVAL;
+	tty_ldisc_deref(ld);
+	return retval;
 }
 
 
@@ -1833,14 +2158,20 @@
 	int session;
 	int		i;
 	struct file	*filp;
+	struct tty_ldisc *disc;
 	
 	if (!tty)
 		return;
 	session  = tty->session;
-	if (tty->ldisc.flush_buffer)
-		tty->ldisc.flush_buffer(tty);
+	/* We don't want an ldisc switch during this */
+	disc = tty_ldisc_ref(tty);
+	if (disc && disc->flush_buffer)
+		disc->flush_buffer(tty);
+	tty_ldisc_deref(disc);
+
 	if (tty->driver.flush_buffer)
 		tty->driver.flush_buffer(tty);
+
 	read_lock(&tasklist_lock);
 	for_each_task(p) {
 		if ((p->tty == tty) ||
@@ -1872,10 +2203,15 @@
 	char		*fp;
 	int		count;
 	unsigned long flags;
+	struct tty_ldisc *disc;
+
+	disc = tty_ldisc_ref(tty);
+	if (disc == NULL) /* !TTY_LDISC */
+		return;
 
 	if (test_bit(TTY_DONT_FLIP, &tty->flags)) {
 		queue_task(&tty->flip.tqueue, &tq_timer);
-		return;
+		goto out;
 	}
 	if (tty->flip.buf_num) {
 		cp = tty->flip.char_buf + TTY_FLIPBUF_SIZE;
@@ -1897,8 +2233,31 @@
 	count = tty->flip.count;
 	tty->flip.count = 0;
 	restore_flags(flags);
-	
-	tty->ldisc.receive_buf(tty, cp, fp, count);
+	disc->receive_buf(tty, cp, fp, count);
+	out:
+		    tty_ldisc_deref(disc);
+}
+
+/*
+ * Call the ldisc flush directly from a driver. This function may
+ * return an error and need retrying by the user.
+ */
+
+int tty_push_data(struct tty_struct *tty, unsigned char *cp, unsigned char *fp, int count)
+{
+	int ret = 0;
+	struct tty_ldisc *disc;
+	 
+	disc = tty_ldisc_ref(tty);
+	if(test_bit(TTY_DONT_FLIP, &tty->flags))
+		ret = -EAGAIN;
+	else if(disc == NULL)
+		ret = -EIO;
+	else
+		disc->receive_buf(tty, cp, fp, count);
+		tty_ldisc_deref(disc);
+	return ret;
+
 }
 
 /*
@@ -1960,7 +2319,7 @@
 {
 	memset(tty, 0, sizeof(struct tty_struct));
 	tty->magic = TTY_MAGIC;
-	tty->ldisc = ldiscs[N_TTY];
+	tty_ldisc_assign(tty, tty_ldisc_get(N_TTY));
 	tty->pgrp = -1;
 	tty->flip.char_buf_ptr = tty->flip.char_buf;
 	tty->flip.flag_buf_ptr = tty->flip.flag_buf;
@@ -2080,7 +2439,7 @@
 long __init console_init(long kmem_start, long kmem_end)
 {
 	/* Setup the default TTY line discipline. */
-	memset(ldiscs, 0, sizeof(ldiscs));
+	memset(tty_ldiscs, 0, NR_LDISCS*sizeof(struct tty_ldisc));
 	(void) tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY);
 
 	/*
diff -urN linux-2.2.26.orig/drivers/char/tty_ioctl.c linux-2.2.26/drivers/char/tty_ioctl.c
--- linux-2.2.26.orig/drivers/char/tty_ioctl.c	2001-03-25 18:31:24.000000000 +0200
+++ linux-2.2.26/drivers/char/tty_ioctl.c	2004-10-31 12:06:32.000000000 +0100
@@ -33,6 +33,8 @@
 # define	PRINTK(x)	/**/
 #endif
 
+extern spinlock_t tty_termios_lock;
+
 /*
  * Internal flag options for termios setting behavior
  */
@@ -100,8 +102,17 @@
 {
 	int canon_change;
 	struct termios old_termios = *tty->termios;
+	struct tty_ldisc *ld;
+	unsigned long flags;
+
+	/*
+	 * Perform the actual termios internal changes under lock.
+	 */
+
+	/* FIXME: we need to decide on some locking/ordering semantics
+           for the set_termios notification eventually */
+	spin_lock_irqsave(&tty_termios_lock, flags);
 
-	cli();
 	*tty->termios = *new_termios;
 	unset_locked_termios(tty->termios, &old_termios, tty->termios_locked);
 	canon_change = (old_termios.c_lflag ^ tty->termios->c_lflag) & ICANON;
@@ -111,7 +122,7 @@
 		tty->canon_data = 0;
 		tty->erasing = 0;
 	}
-	sti();
+	
 	if (canon_change && !L_ICANON(tty) && tty->read_cnt)
 	{
 		/* Get characters left over from canonical mode. */
@@ -142,16 +153,21 @@
 	if (tty->driver.set_termios)
 		(*tty->driver.set_termios)(tty, &old_termios);
 
-	if (tty->ldisc.set_termios)
-		(*tty->ldisc.set_termios)(tty, &old_termios);
+	ld = tty_ldisc_ref(tty);
+	if (ld != NULL) {
+		if (ld->set_termios)
+			(ld->set_termios)(tty, &old_termios);
+	tty_ldisc_deref(ld);
+	}
+	spin_unlock_irqrestore(&tty_termios_lock, flags);
 }
 
 static int set_termios(struct tty_struct * tty, unsigned long arg, int opt)
 {
 	struct termios tmp_termios;
-	int retval;
+	struct tty_ldisc *ld;
+	int retval = tty_check_change(tty);
 
-	retval = tty_check_change(tty);
 	if (retval)
 		return retval;
 
@@ -164,9 +180,13 @@
 			return -EFAULT;
 	}
 
-	if ((opt & TERMIOS_FLUSH) && tty->ldisc.flush_buffer)
-		tty->ldisc.flush_buffer(tty);
+	ld = tty_ldisc_ref(tty);
 
+	if (ld != NULL) {
+		if ((opt & TERMIOS_FLUSH) && ld->flush_buffer)
+		    ld->flush_buffer(tty);
+		tty_ldisc_deref(ld);
+	}
 	if (opt & TERMIOS_WAIT) {
 		tty_wait_until_sent(tty, 0);
 		if (signal_pending(current))
@@ -230,12 +250,16 @@
 static int get_sgttyb(struct tty_struct * tty, struct sgttyb * sgttyb)
 {
 	struct sgttyb tmp;
+	unsigned long flags;
 
+	spin_lock_irqsave(&tty_termios_lock, flags);
 	tmp.sg_ispeed = 0;
 	tmp.sg_ospeed = 0;
 	tmp.sg_erase = tty->termios->c_cc[VERASE];
 	tmp.sg_kill = tty->termios->c_cc[VKILL];
 	tmp.sg_flags = get_sgflags(tty);
+	spin_unlock_irqrestore(&tty_termios_lock, flags);
+
 	if (copy_to_user(sgttyb, &tmp, sizeof(tmp)))
 		return -EFAULT;
 	return 0;
@@ -275,12 +299,15 @@
 	retval = tty_check_change(tty);
 	if (retval)
 		return retval;
-	termios =  *tty->termios;
+	
 	if (copy_from_user(&tmp, sgttyb, sizeof(tmp)))
 		return -EFAULT;
+	spin_lock_irqsave(&tty_termios_lock, flags);
+	termios = *tty->termios;
 	termios.c_cc[VERASE] = tmp.sg_erase;
 	termios.c_cc[VKILL] = tmp.sg_kill;
 	set_sgflags(&termios, tmp.sg_flags);
+	spin_unlock_irqrestore(&tty_termios_lock, flags);
 	change_termios(tty, &termios);
 	return 0;
 }
@@ -374,6 +401,8 @@
 {
 	struct tty_struct * real_tty;
 	int retval;
+	struct tty_ldisc *ld;
+	unsigned long flags;
 
 	if (tty->driver.type == TTY_DRIVER_TYPE_PTY &&
 	    tty->driver.subtype == PTY_TYPE_MASTER)
@@ -423,6 +452,8 @@
 			retval = tty_check_change(tty);
 			if (retval)
 				return retval;
+
+			ld = tty_ldisc_ref(tty);
 			switch (arg) {
 			case TCOOFF:
 				if (!tty->flow_stopped) {
@@ -454,20 +485,22 @@
 				return retval;
 			switch (arg) {
 			case TCIFLUSH:
-				if (tty->ldisc.flush_buffer)
-					tty->ldisc.flush_buffer(tty);
+				if (ld->flush_buffer)
+					ld->flush_buffer(tty);
 				break;
 			case TCIOFLUSH:
-				if (tty->ldisc.flush_buffer)
-					tty->ldisc.flush_buffer(tty);
+				if (ld->flush_buffer)
+					ld->flush_buffer(tty);
 				/* fall through */
 			case TCOFLUSH:
 				if (tty->driver.flush_buffer)
 					tty->driver.flush_buffer(tty);
 				break;
 			default:
+			tty_ldisc_deref(ld);
 				return -EINVAL;
 			}
+			tty_ldisc_deref(ld);
 			return 0;
 		case TIOCOUTQ:
 			return put_user(tty->driver.chars_in_buffer ?
@@ -515,9 +548,11 @@
 			retval = get_user(arg, (unsigned int *) arg);
 			if (retval)
 				return retval;
+			spin_lock_irqsave(&tty_termios_lock, flags);
 			tty->termios->c_cflag =
 				((tty->termios->c_cflag & ~CLOCAL) |
 				 (arg ? CLOCAL : 0));
+			spin_unlock_irqrestore(&tty_termios_lock, flags);
 			return 0;
 		default:
 			return -ENOIOCTLCMD;
diff -urN linux-2.2.26.orig/drivers/net/slip.c linux-2.2.26/drivers/net/slip.c
--- linux-2.2.26.orig/drivers/net/slip.c	2001-03-25 18:31:15.000000000 +0200
+++ linux-2.2.26/drivers/net/slip.c	2004-10-24 11:09:19.428600744 +0200
@@ -669,7 +669,9 @@
  * Handle the 'receiver data ready' interrupt.
  * This function is called by the 'tty_io' module in the kernel when
  * a block of SLIP data has been received, which can now be decapsulated
- * and sent on to some IP layer for further processing.
+ * and sent on to some IP layer for further processing. This will not
+ * be re-entered while running but other ldisc functions may be called
+ * in parallel
  */
  
 static void slip_receive_buf(struct tty_struct *tty, const unsigned char *cp, char *fp, int count)
@@ -824,9 +826,11 @@
  * SLIP line discipline is called for.  Because we are
  * sure the tty line exists, we only have to link it to
  * a free SLIP channel...
+ *
+ * Called in process context serialized from other ldisc calls.
  */
-static int
-slip_open(struct tty_struct *tty)
+
+static int slip_open(struct tty_struct *tty)
 {
 	struct slip *sl;
 	int err;
@@ -908,6 +912,9 @@
 }
 
 /*
+
+ FIXME: 1,2 are fixed 3 was never true anyway.
+ 
    Let me to blame a bit.
    1. TTY module calls this funstion on soft interrupt.
    2. TTY module calls this function WITH MASKED INTERRUPTS!
@@ -926,9 +933,8 @@
 
 /*
  * Close down a SLIP channel.
- * This means flushing out any pending queues, and then restoring the
- * TTY line discipline to what it was before it got hooked to SLIP
- * (which usually is TTY again).
+ * This means flushing out any pending queues, and then returning. This
+ * call is serialized against other ldisc functions 
  */
 static void
 slip_close(struct tty_struct *tty)
diff -urN linux-2.2.26.orig/drivers/sbus/char/zs.c linux-2.2.26/drivers/sbus/char/zs.c
--- linux-2.2.26.orig/drivers/sbus/char/zs.c	2001-11-02 17:39:07.000000000 +0100
+++ linux-2.2.26/drivers/sbus/char/zs.c	2004-10-31 09:43:01.192501208 +0100
@@ -1606,10 +1606,10 @@
 	tty->closing = 0;
 	info->event = 0;
 	info->tty = 0;
-	if (tty->ldisc.num != ldiscs[N_TTY].num) {
+	if (tty->ldisc.num != N_TTY) {
 		if (tty->ldisc.close)
 			(tty->ldisc.close)(tty);
-		tty->ldisc = ldiscs[N_TTY];
+		tty->ldisc = *(tty_ldisc_get(N_TTY));
 		tty->termios->c_line = N_TTY;
 		if (tty->ldisc.open)
 			(tty->ldisc.open)(tty);
diff -urN linux-2.2.26.orig/drivers/sgi/char/sgiserial.c linux-2.2.26/drivers/sgi/char/sgiserial.c
--- linux-2.2.26.orig/drivers/sgi/char/sgiserial.c	2001-03-25 18:31:41.000000000 +0200
+++ linux-2.2.26/drivers/sgi/char/sgiserial.c	2004-10-31 09:38:06.825251832 +0100
@@ -1465,10 +1465,10 @@
 	tty->closing = 0;
 	info->event = 0;
 	info->tty = 0;
-	if (tty->ldisc.num != ldiscs[N_TTY].num) {
+	if (tty->ldisc.num != N_TTY) {
 		if (tty->ldisc.close)
 			(tty->ldisc.close)(tty);
-		tty->ldisc = ldiscs[N_TTY];
+		tty->ldisc = *(tty_ldisc_get(N_TTY));
 		tty->termios->c_line = N_TTY;
 		if (tty->ldisc.open)
 			(tty->ldisc.open)(tty);
diff -urN linux-2.2.26.orig/fs/proc/proc_tty.c linux-2.2.26/fs/proc/proc_tty.c
--- linux-2.2.26.orig/fs/proc/proc_tty.c	2004-02-24 14:48:05.000000000 +0100
+++ linux-2.2.26/fs/proc/proc_tty.c	2004-10-31 13:07:51.212134232 +0100
@@ -15,8 +15,6 @@
 #include <asm/bitops.h>
 
 extern struct tty_driver *tty_drivers;	/* linked list of tty drivers */
-extern struct tty_ldisc ldiscs[];
-
 
 static int tty_drivers_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data);
@@ -112,16 +110,20 @@
 	int	len = 0;
 	off_t	begin = 0;
 	off_t	end;
+	struct tty_ldisc *ld;
 
 	end = off + count;	/* XXX: undefined on overflow per ISO C99 */
 	if (end < off)
 		return -EINVAL;
 
 	for (i=0; i < NR_LDISCS; i++) {
-		if (!(ldiscs[i].flags & LDISC_FLAG_DEFINED))
+		ld = tty_ldisc_get(i);
+		if (ld == NULL)
+		
 			continue;
 		len += sprintf(page+len, "%-10s %2d\n",
-			       ldiscs[i].name ? ldiscs[i].name : "???", i);
+			ld->name ? ld->name : "???", i);
+			tty_ldisc_put(i);
 		if (len+begin > end)
 			break;
 		if (len+begin < off) {
diff -urN linux-2.2.26.orig/include/linux/tty.h linux-2.2.26/include/linux/tty.h
--- linux-2.2.26.orig/include/linux/tty.h	2004-02-24 18:33:31.000000000 +0100
+++ linux-2.2.26/include/linux/tty.h	2004-10-24 10:59:54.653459616 +0200
@@ -319,19 +319,21 @@
  * tty->write.  Thus, you must use the inline functions set_bit() and
  * clear_bit() to make things atomic.
  */
-#define TTY_THROTTLED 0
-#define TTY_IO_ERROR 1
-#define TTY_OTHER_CLOSED 2
-#define TTY_EXCLUSIVE 3
-#define TTY_DEBUG 4
-#define TTY_DO_WRITE_WAKEUP 5
-#define TTY_PUSH 6
-#define TTY_CLOSING 7
-#define TTY_DONT_FLIP 8
-#define TTY_HW_COOK_OUT 14
-#define TTY_HW_COOK_IN 15
-#define TTY_PTY_LOCK 16
-#define TTY_NO_WRITE_SPLIT 17
+#define TTY_THROTTLED 0		/* Call unthrottle() at threshold min */
+#define TTY_IO_ERROR 1		/* Canse an I/O error (may be no ldisc too) */
+#define TTY_OTHER_CLOSED 2	/* Other side (if any) has closed */
+#define TTY_EXCLUSIVE 3		/* Exclusive open mode */
+#define TTY_DEBUG 4		/* Debugging */
+#define TTY_DO_WRITE_WAKEUP 5	/* Call write_wakeup after queuing new */
+#define TTY_PUSH 6		/* n_tty private */
+#define TTY_CLOSING 7		/* ->close() in progress */
+#define TTY_DONT_FLIP 8		/* Defer buffer flip */
+#define TTY_LDISC 9		/* Line discipline attached */
+#define TTY_HW_COOK_OUT 14	/* Hardware can do output cooking */
+#define TTY_HW_COOK_IN 15	/* Hardware can do input cooking */
+#define TTY_PTY_LOCK 16		/* pty private */
+#define TTY_NO_WRITE_SPLIT 17	/* Preserve write boundaries to driver */
+#define TTY_HUPPED 18		/* Post driver->hangup() */
 
 #define TTY_WRITE_FLUSH(tty) tty_write_flush((tty))
 
@@ -339,7 +341,7 @@
 
 extern struct termios tty_std_termios;
 extern struct tty_struct * redirect;
-extern struct tty_ldisc ldiscs[];
+extern struct tty_ldisc tty_ldiscs[];
 extern int fg_console, last_console, want_console;
 
 extern int kmsg_redirect;
@@ -393,6 +395,16 @@
 extern void tty_flip_buffer_push(struct tty_struct *tty);
 extern int tty_get_baud_rate(struct tty_struct *tty);
 
+extern struct tty_ldisc *tty_ldisc_ref(struct tty_struct *);
+extern void tty_ldisc_deref(struct tty_ldisc *);
+extern struct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct *);
+
+extern struct tty_ldisc *tty_ldisc_get(int);
+extern void tty_ldisc_put(int);
+
+extern void tty_wakeup(struct tty_struct *tty);
+
+
 /* n_tty.c */
 extern struct tty_ldisc tty_ldisc_N_TTY;
 
diff -urN linux-2.2.26.orig/include/linux/tty_ldisc.h linux-2.2.26/include/linux/tty_ldisc.h
--- linux-2.2.26.orig/include/linux/tty_ldisc.h	2004-02-24 18:33:31.000000000 +0100
+++ linux-2.2.26/include/linux/tty_ldisc.h	2004-10-24 11:04:07.991946312 +0200
@@ -129,6 +129,7 @@
 			       char *fp, int count);
 	int	(*receive_room)(struct tty_struct *);
 	void	(*write_wakeup)(struct tty_struct *);
+int refcount;
 };
 
 #define TTY_LDISC_MAGIC	0x5403
