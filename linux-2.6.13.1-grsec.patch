diff -Nur linux-2.6.13.1.org/Makefile grsecurity226/Makefile
--- linux-2.6.13.1.org/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/Makefile	2005-08-30 01:12:29.000000000 +0200
@@ -562,7 +562,7 @@
 
 
 ifeq ($(KBUILD_EXTMOD),)
-core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/
+core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ grsecurity/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff -Nur linux-2.6.13.1.org/arch/alpha/kernel/osf_sys.c grsecurity226/arch/alpha/kernel/osf_sys.c
--- linux-2.6.13.1.org/arch/alpha/kernel/osf_sys.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/alpha/kernel/osf_sys.c	2005-09-13 23:56:59.000000000 +0200
@@ -1268,6 +1268,10 @@
 	   merely specific addresses, but regions of memory -- perhaps
 	   this feature should be incorporated into all ports?  */
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);
 		if (addr != (unsigned long) -ENOMEM)
@@ -1275,8 +1279,8 @@
 	}
 
 	/* Next, try allocating at TASK_UNMAPPED_BASE.  */
-	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),
-					 len, limit);
+	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(current->mm->mmap_base), len, limit);
+
 	if (addr != (unsigned long) -ENOMEM)
 		return addr;
 
diff -Nur linux-2.6.13.1.org/arch/alpha/kernel/ptrace.c grsecurity226/arch/alpha/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/alpha/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/alpha/kernel/ptrace.c	2005-08-30 01:12:33.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/security.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -290,6 +291,9 @@
 	if (!child)
 		goto out_notsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out;
diff -Nur linux-2.6.13.1.org/arch/alpha/mm/fault.c grsecurity226/arch/alpha/mm/fault.c
--- linux-2.6.13.1.org/arch/alpha/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/alpha/mm/fault.c	2005-08-30 01:12:35.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/binfmts.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -56,6 +57,125 @@
 	__reload_thread(pcb);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int ldah, ldq, jmp;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(ldq, (unsigned int *)(regs->pc+4));
+		err |= get_user(jmp, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (ldq & 0xFFFF0000U) == 0xA77B0000U &&
+		    jmp == 0x6BFB0000U)
+		{
+			unsigned long r27, addr;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = ldq | 0xFFFFFFFFFFFF0000UL;
+
+			addr = regs->r27 + ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			err = get_user(r27, (unsigned long*)addr);
+			if (err)
+				break;
+
+			regs->r27 = r27;
+			regs->pc = r27;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #2 */
+		unsigned int ldah, lda, br;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(lda, (unsigned int *)(regs->pc+4));
+		err |= get_user(br, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U)== 0x277B0000U &&
+		    (lda & 0xFFFF0000U) == 0xA77B0000U &&
+		    (br & 0xFFE00000U) == 0xC3E00000U)
+		{
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = lda | 0xFFFFFFFFFFFF0000UL;
+
+			regs->r27 += ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			regs->pc += 12 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int br;
+
+		err = get_user(br, (unsigned int *)regs->pc);
+
+		if (!err && (br & 0xFFE00000U) == 0xC3800000U) {
+			unsigned int br2, ldq, nop, jmp;
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL, resolver;
+
+			addr = regs->pc + 4 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			err = get_user(br2, (unsigned int *)addr);
+			err |= get_user(ldq, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			err |= get_user(jmp, (unsigned int *)(addr+12));
+			err |= get_user(resolver, (unsigned long *)(addr+16));
+
+			if (err)
+				break;
+
+			if (br2 == 0xC3600000U &&
+			    ldq == 0xA77B000CU &&
+			    nop == 0x47FF041FU &&
+			    jmp == 0x6B7B0000U)
+			{
+				regs->r28 = regs->pc+4;
+				regs->r27 = addr+16;
+				regs->pc = resolver;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -133,8 +253,29 @@
  good_area:
 	si_code = SEGV_ACCERR;
 	if (cause < 0) {
-		if (!(vma->vm_flags & VM_EXEC))
+		if (!(vma->vm_flags & VM_EXEC)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->pc)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			switch(pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->pc, (void*)rdusp());
+			do_exit(SIGKILL);
+#else
 			goto bad_area;
+#endif
+
+		}
 	} else if (!cause) {
 		/* Allow reads even for write-only mappings */
 		if (!(vma->vm_flags & (VM_READ | VM_WRITE)))
diff -Nur linux-2.6.13.1.org/arch/arm/mm/mmap.c grsecurity226/arch/arm/mm/mmap.c
--- linux-2.6.13.1.org/arch/arm/mm/mmap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/arm/mm/mmap.c	2005-08-30 01:12:38.000000000 +0200
@@ -62,6 +62,10 @@
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -76,7 +80,7 @@
 	if (len > mm->cached_hole_size) {
 	        start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
+	        start_addr = addr = mm->mmap_base;
 	        mm->cached_hole_size = 0;
 	}
 
@@ -93,8 +97,8 @@
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/README.mm grsecurity226/arch/cris/arch-v10/README.mm
--- linux-2.6.13.1.org/arch/cris/arch-v10/README.mm	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/README.mm	2005-08-30 00:59:40.000000000 +0200
@@ -3,6 +3,9 @@
 HISTORY:
 
 $Log$
+Revision 1.1.1.1  2005/08/29 22:59:40  spender
+Initial import of Linux 2.6.13
+
 Revision 1.1  2001/12/17 13:59:27  bjornw
 Initial revision
 
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/drivers/axisflashmap.c grsecurity226/arch/cris/arch-v10/drivers/axisflashmap.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/drivers/axisflashmap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/drivers/axisflashmap.c	2005-08-30 00:59:40.000000000 +0200
@@ -11,6 +11,9 @@
  * partition split defined below.
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.11  2004/11/15 10:27:14  starvik
  * Corrected typo (Thanks to Milton Miller <miltonm@bga.com>).
  *
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/drivers/ds1302.c grsecurity226/arch/cris/arch-v10/drivers/ds1302.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/drivers/ds1302.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/drivers/ds1302.c	2005-08-30 00:59:40.000000000 +0200
@@ -7,6 +7,9 @@
 *! Functions exported: ds1302_readreg, ds1302_writereg, ds1302_init
 *!
 *! $Log$
+*! Revision 1.1.1.1  2005/08/29 22:59:40  spender
+*! Initial import of Linux 2.6.13
+*!
 *! Revision 1.18  2005/01/24 09:11:26  mikaelam
 *! Minor changes to get DS1302 RTC chip driver to work
 *!
@@ -135,7 +138,7 @@
 *!
 *! (C) Copyright 1999, 2000, 2001, 2002, 2003, 2004  Axis Communications AB, LUND, SWEDEN
 *!
-*! $Id$
+*! $Id$
 *!
 *!***************************************************************************/
 
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/drivers/eeprom.c grsecurity226/arch/cris/arch-v10/drivers/eeprom.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/drivers/eeprom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/drivers/eeprom.c	2005-08-30 00:59:40.000000000 +0200
@@ -20,6 +20,9 @@
 *!                                  in the spin-lock.
 *!
 *!  $Log$
+*!  Revision 1.1.1.1  2005/08/29 22:59:40  spender
+*!  Initial import of Linux 2.6.13
+*!
 *!  Revision 1.12  2005/06/19 17:06:46  starvik
 *!  Merge of Linux 2.6.12.
 *!
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/drivers/gpio.c grsecurity226/arch/cris/arch-v10/drivers/gpio.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/drivers/gpio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/drivers/gpio.c	2005-08-30 00:59:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Etrax general port I/O device
  *
@@ -9,6 +9,9 @@
  *             Johan Adolfsson  (read/set directions, write, port G)
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.17  2005/06/19 17:06:46  starvik
  * Merge of Linux 2.6.12.
  *
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/drivers/i2c.c grsecurity226/arch/cris/arch-v10/drivers/i2c.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/drivers/i2c.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/drivers/i2c.c	2005-08-30 00:59:40.000000000 +0200
@@ -12,6 +12,9 @@
 *!                                 don't use PB_I2C if DS1302 uses same bits,
 *!                                 use PB.
 *! $Log$
+*! Revision 1.1.1.1  2005/08/29 22:59:40  spender
+*! Initial import of Linux 2.6.13
+*!
 *! Revision 1.13  2005/03/07 13:13:07  starvik
 *! Added spinlocks to protect states etc
 *!
@@ -84,7 +87,7 @@
 *! (C) Copyright 1999-2002 Axis Communications AB, LUND, SWEDEN
 *!
 *!***************************************************************************/
-/* $Id$ */
+/* $Id$ */
 
 /****************** INCLUDE FILES SECTION ***********************************/
 
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/drivers/pcf8563.c grsecurity226/arch/cris/arch-v10/drivers/pcf8563.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/drivers/pcf8563.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/drivers/pcf8563.c	2005-08-30 00:59:40.000000000 +0200
@@ -15,7 +15,7 @@
  *
  * Author: Tobias Anderberg <tobiasa@axis.com>.
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
@@ -40,7 +40,7 @@
 #define PCF8563_MAJOR 121		/* Local major number. */
 #define DEVICE_NAME "rtc"		/* Name which is registered in /proc/devices. */
 #define PCF8563_NAME "PCF8563"
-#define DRIVER_VERSION "$Revision$"
+#define DRIVER_VERSION "$Revision$"
 
 /* I2C bus slave registers. */
 #define RTC_I2C_READ		0xa3
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/kernel/debugport.c grsecurity226/arch/cris/arch-v10/kernel/debugport.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/kernel/debugport.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/kernel/debugport.c	2005-08-30 00:59:40.000000000 +0200
@@ -12,6 +12,9 @@
  *    init_etrax_debug()
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.27  2005/06/10 10:34:14  starvik
  * Real console support
  *
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/kernel/entry.S grsecurity226/arch/cris/arch-v10/kernel/entry.S
--- linux-2.6.13.1.org/arch/cris/arch-v10/kernel/entry.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/kernel/entry.S	2005-08-30 00:59:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  *  linux/arch/cris/entry.S
  *
@@ -7,6 +7,9 @@
  *  Authors:	Bjorn Wesen (bjornw@axis.com)
  *
  *  $Log$
+ *  Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ *  Initial import of Linux 2.6.13
+ *
  *  Revision 1.28  2005/06/20 05:06:30  starvik
  *  Remove unnecessary diff to kernel.org tree
  *
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/kernel/fasttimer.c grsecurity226/arch/cris/arch-v10/kernel/fasttimer.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/kernel/fasttimer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/kernel/fasttimer.c	2005-08-30 00:59:40.000000000 +0200
@@ -1,10 +1,13 @@
-/* $Id$
+/* $Id$
  * linux/arch/cris/kernel/fasttimer.c
  *
  * Fast timers for ETRAX100/ETRAX100LX
  * This may be useful in other OS than Linux so use 2 space indentation...
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.9  2005/03/04 08:16:16  starvik
  * Merge of Linux 2.6.11.
  *
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/kernel/head.S grsecurity226/arch/cris/arch-v10/kernel/head.S
--- linux-2.6.13.1.org/arch/cris/arch-v10/kernel/head.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/kernel/head.S	2005-08-30 00:59:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Head of the kernel - alter with care
  *
@@ -7,6 +7,9 @@
  * Authors:	Bjorn Wesen (bjornw@axis.com)
  * 
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.10  2005/06/20 05:12:54  starvik
  * Remove unnecessary diff to kernel.org tree
  *
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/kernel/kgdb.c grsecurity226/arch/cris/arch-v10/kernel/kgdb.c
--- linux-2.6.13.1.org/arch/cris/arch-v10/kernel/kgdb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/kernel/kgdb.c	2005-08-30 00:59:40.000000000 +0200
@@ -18,6 +18,9 @@
 *! Jul 21 1999  Bjorn Wesen     eLinux port
 *!
 *! $Log$
+*! Revision 1.1.1.1  2005/08/29 22:59:40  spender
+*! Initial import of Linux 2.6.13
+*!
 *! Revision 1.6  2005/01/14 10:12:17  starvik
 *! KGDB on separate port.
 *! Console fixes from 2.4.
@@ -75,7 +78,7 @@
 *!
 *!---------------------------------------------------------------------------
 *!
-*! $Id$
+*! $Id$
 *!
 *! (C) Copyright 1999, Axis Communications AB, LUND, SWEDEN
 *!
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v10/lib/dram_init.S grsecurity226/arch/cris/arch-v10/lib/dram_init.S
--- linux-2.6.13.1.org/arch/cris/arch-v10/lib/dram_init.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v10/lib/dram_init.S	2005-08-30 00:59:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * DRAM/SDRAM initialization - alter with care
  * This file is intended to be included from other assembler files
@@ -11,6 +11,9 @@
  * Authors:  Mikael Starvik (starvik@axis.com)	
  * 
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.4  2003/09/22 09:21:59  starvik
  * Decompresser is linked to 0x407xxxxx and sdram commands are at 0x000xxxxx
  * so we need to mask off 12 bits.
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v32/drivers/gpio.c grsecurity226/arch/cris/arch-v32/drivers/gpio.c
--- linux-2.6.13.1.org/arch/cris/arch-v32/drivers/gpio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v32/drivers/gpio.c	2005-08-30 00:59:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ETRAX CRISv32 general port I/O device
  *
@@ -10,6 +10,9 @@
  *                               port to ETRAX FS.
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.16  2005/06/19 17:06:49  starvik
  * Merge of Linux 2.6.12.
  *
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v32/drivers/pcf8563.c grsecurity226/arch/cris/arch-v32/drivers/pcf8563.c
--- linux-2.6.13.1.org/arch/cris/arch-v32/drivers/pcf8563.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v32/drivers/pcf8563.c	2005-08-30 00:59:40.000000000 +0200
@@ -39,7 +39,7 @@
 #define PCF8563_MAJOR	121	/* Local major number. */
 #define DEVICE_NAME	"rtc"	/* Name which is registered in /proc/devices. */
 #define PCF8563_NAME	"PCF8563"
-#define DRIVER_VERSION	"$Revision$"
+#define DRIVER_VERSION	"$Revision$"
 
 /* Two simple wrapper macros, saves a few keystrokes. */
 #define rtc_read(x) i2c_readreg(RTC_I2C_READ, x)
diff -Nur linux-2.6.13.1.org/arch/cris/arch-v32/kernel/fasttimer.c grsecurity226/arch/cris/arch-v32/kernel/fasttimer.c
--- linux-2.6.13.1.org/arch/cris/arch-v32/kernel/fasttimer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/arch-v32/kernel/fasttimer.c	2005-08-30 00:59:40.000000000 +0200
@@ -1,10 +1,13 @@
-/* $Id$
+/* $Id$
  * linux/arch/cris/kernel/fasttimer.c
  *
  * Fast timers for ETRAX FS
  * This may be useful in other OS than Linux so use 2 space indentation...
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.11  2005/01/04 11:15:46  starvik
  * Don't share timer IRQ.
  *
diff -Nur linux-2.6.13.1.org/arch/cris/kernel/process.c grsecurity226/arch/cris/kernel/process.c
--- linux-2.6.13.1.org/arch/cris/kernel/process.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/kernel/process.c	2005-08-30 00:59:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  *  linux/arch/cris/kernel/process.c
  *
@@ -8,6 +8,9 @@
  *  Authors:   Bjorn Wesen (bjornw@axis.com)
  *
  *  $Log$
+ *  Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ *  Initial import of Linux 2.6.13
+ *
  *  Revision 1.21  2005/03/04 08:16:17  starvik
  *  Merge of Linux 2.6.11.
  *
diff -Nur linux-2.6.13.1.org/arch/cris/kernel/ptrace.c grsecurity226/arch/cris/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/cris/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/kernel/ptrace.c	2005-08-30 00:59:40.000000000 +0200
@@ -8,6 +8,9 @@
  * Authors:   Bjorn Wesen
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.10  2004/09/22 11:50:01  orjanf
  * * Moved get_reg/put_reg to arch-specific files.
  * * Added functions to access debug registers (CRISv32).
diff -Nur linux-2.6.13.1.org/arch/cris/mm/fault.c grsecurity226/arch/cris/mm/fault.c
--- linux-2.6.13.1.org/arch/cris/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/mm/fault.c	2005-08-30 00:59:40.000000000 +0200
@@ -6,6 +6,9 @@
  *  Authors:  Bjorn Wesen 
  * 
  *  $Log$
+ *  Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ *  Initial import of Linux 2.6.13
+ *
  *  Revision 1.20  2005/03/04 08:16:18  starvik
  *  Merge of Linux 2.6.11.
  *
diff -Nur linux-2.6.13.1.org/arch/cris/mm/init.c grsecurity226/arch/cris/mm/init.c
--- linux-2.6.13.1.org/arch/cris/mm/init.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/cris/mm/init.c	2005-08-30 00:59:40.000000000 +0200
@@ -7,6 +7,9 @@
  *  Authors:  Bjorn Wesen (bjornw@axis.com)
  *
  *  $Log$
+ *  Revision 1.1.1.1  2005/08/29 22:59:40  spender
+ *  Initial import of Linux 2.6.13
+ *
  *  Revision 1.11  2004/05/28 09:28:56  starvik
  *  Calculation of loops_per_usec moved because initalization order has changed
  *  in Linux 2.6.
diff -Nur linux-2.6.13.1.org/arch/i386/Kconfig grsecurity226/arch/i386/Kconfig
--- linux-2.6.13.1.org/arch/i386/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/Kconfig	2005-08-30 01:12:43.000000000 +0200
@@ -414,7 +414,7 @@
 
 config X86_ALIGNMENT_16
 	bool
-	depends on MWINCHIP3D || MWINCHIP2 || MWINCHIPC6 || MCYRIXIII || X86_ELAN || MK6 || M586MMX || M586TSC || M586 || M486 || MVIAC3_2 || MGEODEGX1
+	depends on MWINCHIP3D || MWINCHIP2 || MWINCHIPC6 || MCYRIXIII || X86_ELAN || MK8 || MK7 || MK6 || MPENTIUM4 || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || M586 || M486 || MVIAC3_2 || MGEODEGX1
 	default y
 
 config X86_GOOD_APIC
diff -Nur linux-2.6.13.1.org/arch/i386/boot/compressed/head.S grsecurity226/arch/i386/boot/compressed/head.S
--- linux-2.6.13.1.org/arch/i386/boot/compressed/head.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/boot/compressed/head.S	2005-08-30 01:12:45.000000000 +0200
@@ -39,11 +39,13 @@
 	movl %eax,%gs
 
 	lss stack_start,%esp
+	movl 0x000000,%ecx
 	xorl %eax,%eax
 1:	incl %eax		# check that A20 really IS enabled
 	movl %eax,0x000000	# loop forever if it isn't
 	cmpl %eax,0x100000
 	je 1b
+	movl %ecx,0x000000
 
 /*
  * Initialize eflags.  Some BIOS's leave bits like NT set.  This would
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/apm.c grsecurity226/arch/i386/kernel/apm.c
--- linux-2.6.13.1.org/arch/i386/kernel/apm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/apm.c	2005-08-30 01:12:47.000000000 +0200
@@ -598,19 +598,39 @@
 	int			cpu;
 	struct desc_struct	save_desc_40;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long		cr3;
+#endif
+
 	cpus = apm_save_cpus();
-	
 	cpu = get_cpu();
-	save_desc_40 = per_cpu(cpu_gdt_table, cpu)[0x40 / 8];
-	per_cpu(cpu_gdt_table, cpu)[0x40 / 8] = bad_bios_desc;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(flags, cr3);
+#endif
+
+	save_desc_40 = cpu_gdt_table[cpu][0x40 / 8];
+	cpu_gdt_table[cpu][0x40 / 8] = bad_bios_desc;
+
+#ifndef CONFIG_PAX_KERNEXEC
 	local_save_flags(flags);
 	APM_DO_CLI;
+#endif
+
 	APM_DO_SAVE_SEGS;
 	apm_bios_call_asm(func, ebx_in, ecx_in, eax, ebx, ecx, edx, esi);
 	APM_DO_RESTORE_SEGS;
+
+#ifndef CONFIG_PAX_KERNEXEC
 	local_irq_restore(flags);
-	per_cpu(cpu_gdt_table, cpu)[0x40 / 8] = save_desc_40;
+#endif
+
+	cpu_gdt_table[cpu][0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(flags, cr3);
+#endif
+
 	put_cpu();
 	apm_restore_cpus(cpus);
 	
@@ -640,20 +660,39 @@
 	int			cpu;
 	struct desc_struct	save_desc_40;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long		cr3;
+#endif
 
 	cpus = apm_save_cpus();
-	
 	cpu = get_cpu();
-	save_desc_40 = per_cpu(cpu_gdt_table, cpu)[0x40 / 8];
-	per_cpu(cpu_gdt_table, cpu)[0x40 / 8] = bad_bios_desc;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(flags, cr3);
+#endif
+
+	save_desc_40 = cpu_gdt_table[cpu][0x40 / 8];
+	cpu_gdt_table[cpu][0x40 / 8] = bad_bios_desc;
+
+#ifndef CONFIG_PAX_KERNEXEC
 	local_save_flags(flags);
 	APM_DO_CLI;
+#endif
+
 	APM_DO_SAVE_SEGS;
 	error = apm_bios_call_simple_asm(func, ebx_in, ecx_in, eax);
 	APM_DO_RESTORE_SEGS;
+
+#ifndef CONFIG_PAX_KERNEXEC
 	local_irq_restore(flags);
-	__get_cpu_var(cpu_gdt_table)[0x40 / 8] = save_desc_40;
+#endif
+
+	cpu_gdt_table[cpu][0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(flags, cr3);
+#endif
+
 	put_cpu();
 	apm_restore_cpus(cpus);
 	return error;
@@ -2295,35 +2334,35 @@
 	apm_bios_entry.segment = APM_CS;
 
 	for (i = 0; i < NR_CPUS; i++) {
-		set_base(per_cpu(cpu_gdt_table, i)[APM_CS >> 3],
+		set_base(cpu_gdt_table[i][APM_CS >> 3],
 			 __va((unsigned long)apm_info.bios.cseg << 4));
-		set_base(per_cpu(cpu_gdt_table, i)[APM_CS_16 >> 3],
+		set_base(cpu_gdt_table[i][APM_CS_16 >> 3],
 			 __va((unsigned long)apm_info.bios.cseg_16 << 4));
-		set_base(per_cpu(cpu_gdt_table, i)[APM_DS >> 3],
+		set_base(cpu_gdt_table[i][APM_DS >> 3],
 			 __va((unsigned long)apm_info.bios.dseg << 4));
 #ifndef APM_RELAX_SEGMENTS
 		if (apm_info.bios.version == 0x100) {
 #endif
 			/* For ASUS motherboard, Award BIOS rev 110 (and others?) */
-			_set_limit((char *)&per_cpu(cpu_gdt_table, i)[APM_CS >> 3], 64 * 1024 - 1);
+			_set_limit((char *)&cpu_gdt_table[i][APM_CS >> 3], 64 * 1024 - 1);
 			/* For some unknown machine. */
-			_set_limit((char *)&per_cpu(cpu_gdt_table, i)[APM_CS_16 >> 3], 64 * 1024 - 1);
+			_set_limit((char *)&cpu_gdt_table[i][APM_CS_16 >> 3], 64 * 1024 - 1);
 			/* For the DEC Hinote Ultra CT475 (and others?) */
-			_set_limit((char *)&per_cpu(cpu_gdt_table, i)[APM_DS >> 3], 64 * 1024 - 1);
+			_set_limit((char *)&cpu_gdt_table[i][APM_DS >> 3], 64 * 1024 - 1);
 #ifndef APM_RELAX_SEGMENTS
 		} else {
-			_set_limit((char *)&per_cpu(cpu_gdt_table, i)[APM_CS >> 3],
+			_set_limit((char *)&cpu_gdt_table[i][APM_CS >> 3],
 				(apm_info.bios.cseg_len - 1) & 0xffff);
-			_set_limit((char *)&per_cpu(cpu_gdt_table, i)[APM_CS_16 >> 3],
+			_set_limit((char *)&cpu_gdt_table[i][APM_CS_16 >> 3],
 				(apm_info.bios.cseg_16_len - 1) & 0xffff);
-			_set_limit((char *)&per_cpu(cpu_gdt_table, i)[APM_DS >> 3],
+			_set_limit((char *)&cpu_gdt_table[i][APM_DS >> 3],
 				(apm_info.bios.dseg_len - 1) & 0xffff);
 		      /* workaround for broken BIOSes */
 	                if (apm_info.bios.cseg_len <= apm_info.bios.offset)
-        	                _set_limit((char *)&per_cpu(cpu_gdt_table, i)[APM_CS >> 3], 64 * 1024 -1);
+        	                _set_limit((char *)&cpu_gdt_table[i][APM_CS >> 3], 64 * 1024 -1);
                        if (apm_info.bios.dseg_len <= 0x40) { /* 0x40 * 4kB == 64kB */
                         	/* for the BIOS that assumes granularity = 1 */
-                        	per_cpu(cpu_gdt_table, i)[APM_DS >> 3].b |= 0x800000;
+                        	cpu_gdt_table[i][APM_DS >> 3].b |= 0x800000;
                         	printk(KERN_NOTICE "apm: we set the granularity of dseg.\n");
         	        }
 		}
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/cpu/common.c grsecurity226/arch/i386/kernel/cpu/common.c
--- linux-2.6.13.1.org/arch/i386/kernel/cpu/common.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/cpu/common.c	2005-08-30 01:12:50.000000000 +0200
@@ -18,8 +18,7 @@
 
 #include "cpu.h"
 
-DEFINE_PER_CPU(struct desc_struct, cpu_gdt_table[GDT_ENTRIES]);
-EXPORT_PER_CPU_SYMBOL(cpu_gdt_table);
+EXPORT_SYMBOL_GPL(cpu_gdt_table);
 
 DEFINE_PER_CPU(unsigned char, cpu_16bit_stack[CPU_16BIT_STACK_SIZE]);
 EXPORT_PER_CPU_SYMBOL(cpu_16bit_stack);
@@ -376,6 +375,10 @@
 	if (this_cpu->c_init)
 		this_cpu->c_init(c);
 
+#if defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_KERNEXEC) || defined(CONFIG_PAX_NOVSYSCALL)
+	clear_bit(X86_FEATURE_SEP, c->x86_capability);
+#endif
+
 	/* Disable the PN if appropriate */
 	squash_the_stupid_serial_number(c);
 
@@ -571,7 +574,7 @@
 void __devinit cpu_init(void)
 {
 	int cpu = smp_processor_id();
-	struct tss_struct * t = &per_cpu(init_tss, cpu);
+	struct tss_struct * t = init_tss + cpu;
 	struct thread_struct *thread = &current->thread;
 	__u32 stk16_off = (__u32)&per_cpu(cpu_16bit_stack, cpu);
 
@@ -594,24 +597,22 @@
 	 * Initialize the per-CPU GDT with the boot GDT,
 	 * and set up the GDT descriptor:
 	 */
-	memcpy(&per_cpu(cpu_gdt_table, cpu), cpu_gdt_table,
-	       GDT_SIZE);
+	if (cpu)
+		memcpy(cpu_gdt_table[cpu], cpu_gdt_table[0], GDT_SIZE);
 
 	/* Set up GDT entry for 16bit stack */
-	*(__u64 *)&(per_cpu(cpu_gdt_table, cpu)[GDT_ENTRY_ESPFIX_SS]) |=
+	*(__u64 *)&(cpu_gdt_table[cpu][GDT_ENTRY_ESPFIX_SS]) |=
 		((((__u64)stk16_off) << 16) & 0x000000ffffff0000ULL) |
 		((((__u64)stk16_off) << 32) & 0xff00000000000000ULL) |
 		(CPU_16BIT_STACK_SIZE - 1);
 
 	cpu_gdt_descr[cpu].size = GDT_SIZE - 1;
-	cpu_gdt_descr[cpu].address =
-	    (unsigned long)&per_cpu(cpu_gdt_table, cpu);
+	cpu_gdt_descr[cpu].address = (unsigned long)cpu_gdt_table[cpu];
 
 	/*
 	 * Set up the per-thread TLS descriptor cache:
 	 */
-	memcpy(thread->tls_array, &per_cpu(cpu_gdt_table, cpu),
-		GDT_ENTRY_TLS_ENTRIES * 8);
+	memcpy(thread->tls_array, cpu_gdt_table[cpu], GDT_ENTRY_TLS_ENTRIES * 8);
 
 	__asm__ __volatile__("lgdt %0" : : "m" (cpu_gdt_descr[cpu]));
 	__asm__ __volatile__("lidt %0" : : "m" (idt_descr));
@@ -633,7 +634,7 @@
 	load_esp0(t, thread);
 	set_tss_desc(cpu,t);
 	load_TR_desc();
-	load_LDT(&init_mm.context);
+	_load_LDT(&init_mm.context);
 
 	/* Set up doublefault TSS pointer in the GDT */
 	__set_tss_desc(cpu, GDT_ENTRY_DOUBLEFAULT_TSS, &doublefault_tss);
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/cpu/mtrr/if.c grsecurity226/arch/i386/kernel/cpu/mtrr/if.c
--- linux-2.6.13.1.org/arch/i386/kernel/cpu/mtrr/if.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/cpu/mtrr/if.c	2005-08-30 01:12:52.000000000 +0200
@@ -105,7 +105,7 @@
 	if (!len)
 		return -EINVAL;
 	memset(line, 0, LINE_SIZE);
-	if (len > LINE_SIZE)
+	if (!len || len > LINE_SIZE)
 		len = LINE_SIZE;
 	if (copy_from_user(line, buf, len - 1))
 		return -EFAULT;
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/entry.S grsecurity226/arch/i386/kernel/entry.S
--- linux-2.6.13.1.org/arch/i386/kernel/entry.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/entry.S	2005-08-30 01:12:47.000000000 +0200
@@ -213,6 +213,13 @@
 	movl TI_flags(%ebp), %ecx
 	testw $_TIF_ALLWORK_MASK, %cx
 	jne syscall_exit_work
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pushl %eax
+	call pax_randomize_kstack
+	popl %eax
+#endif
+
 /* if something modifies registers it must also disable sysexit */
 	movl EIP(%esp), %edx
 	movl OLDESP(%esp), %ecx
@@ -243,6 +250,10 @@
 	testw $_TIF_ALLWORK_MASK, %cx	# current->work
 	jne syscall_exit_work
 
+#ifdef CONFIG_PAX_RANDKSTACK
+	call pax_randomize_kstack
+#endif
+
 restore_all:
 	movl EFLAGS(%esp), %eax		# mix EFLAGS, SS and CS
 	# Warning: OLDSS(%esp) contains the wrong/random values if we
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/head.S grsecurity226/arch/i386/kernel/head.S
--- linux-2.6.13.1.org/arch/i386/kernel/head.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/head.S	2005-08-30 01:12:47.000000000 +0200
@@ -48,6 +48,12 @@
 
 
 /*
+ * Real beginning of normal "text" segment
+ */
+ENTRY(stext)
+ENTRY(_stext)
+
+/*
  * 32-bit kernel entrypoint; only used by the boot CPU.  On entry,
  * %esi points to the real-mode code as a 32-bit pointer.
  * CS and DS must be 4 GB flat segments, but we don't depend on
@@ -78,6 +84,19 @@
 	shrl $2,%ecx
 	rep ; stosl
 
+#ifdef CONFIG_PAX_KERNEXEC
+	movl $ __KERNEL_TEXT_OFFSET,%eax
+	movw %ax,(cpu_gdt_table - __PAGE_OFFSET + __KERNEL_CS + 2)
+	rorl $16,%eax
+	movb %al,(cpu_gdt_table - __PAGE_OFFSET + __KERNEL_CS + 4)
+	movb %ah,(cpu_gdt_table - __PAGE_OFFSET + __KERNEL_CS + 7)
+
+	movb %al,(boot_gdt_table - __PAGE_OFFSET + __BOOT_CS + 4)
+	movb %ah,(boot_gdt_table - __PAGE_OFFSET + __BOOT_CS + 7)
+	rorl $16,%eax
+	movw %ax,(boot_gdt_table - __PAGE_OFFSET + __BOOT_CS + 2)
+#endif
+
 /*
  * Initialize page tables.  This creates a PDE and a set of page
  * tables, which are located immediately beyond _end.  The variable
@@ -88,24 +107,42 @@
  * Warning: don't use %esi or the stack in this code.  However, %esp
  * can be used as a GPR if you really need it...
  */
-page_pde_offset = (__PAGE_OFFSET >> 20);
-
+#ifdef CONFIG_X86_PAE
+page_pde_offset = ((__PAGE_OFFSET >> 21) * (4096 / PTRS_PER_PTE));
+#else
+page_pde_offset = ((__PAGE_OFFSET >> 22) * (4096 / PTRS_PER_PTE));
+#endif
 	movl $(pg0 - __PAGE_OFFSET), %edi
+#ifdef CONFIG_X86_PAE
+	movl $(swapper_pm_dir - __PAGE_OFFSET), %edx
+#else
 	movl $(swapper_pg_dir - __PAGE_OFFSET), %edx
-	movl $0x007, %eax			/* 0x007 = PRESENT+RW+USER */
+#endif
+	movl $0x063, %eax			/* 0x063 = DIRTY+ACCESSED+PRESENT+RW */
 10:
-	leal 0x007(%edi),%ecx			/* Create PDE entry */
+	leal 0x063(%edi),%ecx			/* Create PDE entry */
 	movl %ecx,(%edx)			/* Store identity PDE entry */
 	movl %ecx,page_pde_offset(%edx)		/* Store kernel PDE entry */
+#ifdef CONFIG_X86_PAE
+	movl $0,4(%edx)
+	movl $0,page_pde_offset+4(%edx)
+	addl $8,%edx
+	movl $512, %ecx
+#else
 	addl $4,%edx
 	movl $1024, %ecx
+#endif
 11:
 	stosl
+#ifdef CONFIG_X86_PAE
+	movl $0,(%edi)
+	addl $4,%edi
+#endif
 	addl $0x1000,%eax
 	loop 11b
 	/* End condition: we must map up to and including INIT_MAP_BEYOND_END */
-	/* bytes beyond the end of our own page tables; the +0x007 is the attribute bits */
-	leal (INIT_MAP_BEYOND_END+0x007)(%edi),%ebp
+	/* bytes beyond the end of our own page tables; the +0x063 is the attribute bits */
+	leal (INIT_MAP_BEYOND_END+0x063)(%edi),%ebp
 	cmpl %ebp,%eax
 	jb 10b
 	movl %edi,(init_pg_tables_end - __PAGE_OFFSET)
@@ -128,6 +165,11 @@
 	movl %eax,%fs
 	movl %eax,%gs
 
+	/* This is a secondary processor (AP) */
+	xorl %ebx,%ebx
+	incl %ebx
+#endif /* CONFIG_SMP */
+
 /*
  *	New page tables may be in 4Mbyte page mode and may
  *	be using the global pages. 
@@ -143,26 +185,27 @@
  *	not yet offset PAGE_OFFSET..
  */
 #define cr4_bits mmu_cr4_features-__PAGE_OFFSET
+3:
 	movl cr4_bits,%edx
 	andl %edx,%edx
-	jz 6f
+	jz 5f
 	movl %cr4,%eax		# Turn on paging options (PSE,PAE,..)
 	orl %edx,%eax
 	movl %eax,%cr4
 
-	btl $5, %eax		# check if PAE is enabled
-	jnc 6f
+#ifdef CONFIG_X86_PAE
+	movl %ebx,%edi
 
 	/* Check if extended functions are implemented */
 	movl $0x80000000, %eax
 	cpuid
 	cmpl $0x80000000, %eax
-	jbe 6f
+	jbe 4f
 	mov $0x80000001, %eax
 	cpuid
 	/* Execute Disable bit supported? */
 	btl $20, %edx
-	jnc 6f
+	jnc 4f
 
 	/* Setup EFER (Extended Feature Enable Register) */
 	movl $0xc0000080, %ecx
@@ -172,13 +215,10 @@
 	/* Make changes effective */
 	wrmsr
 
-6:
-	/* This is a secondary processor (AP) */
-	xorl %ebx,%ebx
-	incl %ebx
-
-3:
-#endif /* CONFIG_SMP */
+4:
+	movl %edi,%ebx
+#endif
+5:
 
 /*
  * Enable paging
@@ -203,9 +243,7 @@
 
 #ifdef CONFIG_SMP
 	andl %ebx,%ebx
-	jz  1f				/* Initial CPU cleans BSS */
-	jmp checkCPUtype
-1:
+	jnz  checkCPUtype	/* Initial CPU cleans BSS */
 #endif /* CONFIG_SMP */
 
 /*
@@ -404,32 +442,74 @@
 #endif
 	iret
 
-/*
- * Real beginning of normal "text" segment
- */
-ENTRY(stext)
-ENTRY(_stext)
-
-/*
- * BSS section
- */
-.section ".bss.page_aligned","w"
+.section .data.swapper_pg_dir,"a",@progbits
 ENTRY(swapper_pg_dir)
+#ifdef CONFIG_X86_PAE
+	.long swapper_pm_dir-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*8-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*16-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*24-__PAGE_OFFSET+1
+	.long 0
+#else
+	.fill 1024,4,0
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+ENTRY(kernexec_pg_dir)
+#ifdef CONFIG_X86_PAE
+	.long kernexec_pm_dir-__PAGE_OFFSET+1
+	.long 0
+	.long kernexec_pm_dir+512*8-__PAGE_OFFSET+1
+	.long 0
+	.long kernexec_pm_dir+512*16-__PAGE_OFFSET+1
+	.long 0
+	.long kernexec_pm_dir+512*24-__PAGE_OFFSET+1
+	.long 0
+#else
 	.fill 1024,4,0
+#endif
+#endif
+
+#ifdef CONFIG_X86_PAE
+.section .data.swapper_pm_dir,"a",@progbits
+ENTRY(swapper_pm_dir)
+	.fill 512,8,0
+	.fill 512,8,0
+	.fill 512,8,0
+	.fill 512,8,0
+
+#ifdef CONFIG_PAX_KERNEXEC
+ENTRY(kernexec_pm_dir)
+	.fill 512,8,0
+	.fill 512,8,0
+	.fill 512,8,0
+	.fill 512,8,0
+#endif
+#endif
+
+.section .rodata.empty_zero_page,"a",@progbits
 ENTRY(empty_zero_page)
 	.fill 4096,1,0
 
 /*
- * This starts the data section.
- */
-.data
+ * The IDT has to be page-aligned to simplify the Pentium
+ * F0 0F bug workaround.. We have a special link segment
+ * for this.
+ */
+.section .rodata.idt,"a",@progbits
+ENTRY(idt_table)
+	.fill 256,8,0
+
+.section .rodata,"a",@progbits
+ready:	.byte 0
 
 ENTRY(stack_start)
 	.long init_thread_union+THREAD_SIZE
 	.long __BOOT_DS
 
-ready:	.byte 0
-
 int_msg:
 	.asciz "Unknown interrupt or fault at EIP %p %p %p\n"
 
@@ -471,8 +551,8 @@
 	.align L1_CACHE_BYTES
 ENTRY(boot_gdt_table)
 	.fill GDT_ENTRY_BOOT_CS,8,0
-	.quad 0x00cf9a000000ffff	/* kernel 4GB code at 0x00000000 */
-	.quad 0x00cf92000000ffff	/* kernel 4GB data at 0x00000000 */
+	.quad 0x00cf9b000000ffff	/* kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* kernel 4GB data at 0x00000000 */
 
 /*
  * The Global Descriptor Table contains 28 quadwords, per-CPU.
@@ -491,28 +571,27 @@
 	.quad 0x0000000000000000	/* 0x4b reserved */
 	.quad 0x0000000000000000	/* 0x53 reserved */
 	.quad 0x0000000000000000	/* 0x5b reserved */
-
-	.quad 0x00cf9a000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
-	.quad 0x00cf92000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
-	.quad 0x00cffa000000ffff	/* 0x73 user 4GB code at 0x00000000 */
-	.quad 0x00cff2000000ffff	/* 0x7b user 4GB data at 0x00000000 */
+	.quad 0x00cf9b000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
+	.quad 0x00cffb000000ffff	/* 0x73 user 4GB code at 0x00000000 */
+	.quad 0x00cff3000000ffff	/* 0x7b user 4GB data at 0x00000000 */
 
 	.quad 0x0000000000000000	/* 0x80 TSS descriptor */
 	.quad 0x0000000000000000	/* 0x88 LDT descriptor */
 
 	/* Segments used for calling PnP BIOS */
-	.quad 0x00c09a0000000000	/* 0x90 32-bit code */
-	.quad 0x00809a0000000000	/* 0x98 16-bit code */
-	.quad 0x0080920000000000	/* 0xa0 16-bit data */
-	.quad 0x0080920000000000	/* 0xa8 16-bit data */
-	.quad 0x0080920000000000	/* 0xb0 16-bit data */
+	.quad 0x00c09b0000000000	/* 0x90 32-bit code */
+	.quad 0x00809b0000000000	/* 0x98 16-bit code */
+	.quad 0x0080930000000000	/* 0xa0 16-bit data */
+	.quad 0x0080930000000000	/* 0xa8 16-bit data */
+	.quad 0x0080930000000000	/* 0xb0 16-bit data */
 	/*
 	 * The APM segments have byte granularity and their bases
 	 * and limits are set at run time.
 	 */
-	.quad 0x00409a0000000000	/* 0xb8 APM CS    code */
-	.quad 0x00009a0000000000	/* 0xc0 APM CS 16 code (16 bit) */
-	.quad 0x0040920000000000	/* 0xc8 APM DS    data */
+	.quad 0x00409b0000000000	/* 0xb8 APM CS    code */
+	.quad 0x00009b0000000000	/* 0xc0 APM CS 16 code (16 bit) */
+	.quad 0x0040930000000000	/* 0xc8 APM DS    data */
 
 	.quad 0x0000920000000000	/* 0xd0 - ESPFIX 16-bit SS */
 	.quad 0x0000000000000000	/* 0xd8 - unused */
@@ -521,3 +600,6 @@
 	.quad 0x0000000000000000	/* 0xf0 - unused */
 	.quad 0x0000000000000000	/* 0xf8 - GDT entry 31: double-fault TSS */
 
+#ifdef CONFIG_SMP
+	.fill (NR_CPUS-1)*GDT_ENTRIES,8,0 /* other CPU's GDT */
+#endif
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/init_task.c grsecurity226/arch/i386/kernel/init_task.c
--- linux-2.6.13.1.org/arch/i386/kernel/init_task.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/init_task.c	2005-08-30 01:12:47.000000000 +0200
@@ -42,5 +42,4 @@
  * per-CPU TSS segments. Threads are completely 'soft' on Linux,
  * no more per-task TSS's.
  */ 
-DEFINE_PER_CPU(struct tss_struct, init_tss) ____cacheline_maxaligned_in_smp = INIT_TSS;
-
+struct tss_struct init_tss[NR_CPUS] ____cacheline_maxaligned_in_smp = { [0 ... NR_CPUS-1] = INIT_TSS };
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/ioport.c grsecurity226/arch/i386/kernel/ioport.c
--- linux-2.6.13.1.org/arch/i386/kernel/ioport.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/ioport.c	2005-08-30 01:12:47.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/stddef.h>
 #include <linux/slab.h>
 #include <linux/thread_info.h>
+#include <linux/grsecurity.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base, unsigned int extent, int new_value)
@@ -63,9 +64,16 @@
 
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
+#ifdef CONFIG_GRKERNSEC_IO
+	if (turn_on) {
+		gr_handle_ioperm();
+#else
 	if (turn_on && !capable(CAP_SYS_RAWIO))
+#endif
 		return -EPERM;
-
+#ifdef CONFIG_GRKERNSEC_IO
+	}
+#endif
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -87,7 +95,7 @@
 	 * because the ->io_bitmap_max value must match the bitmap
 	 * contents:
 	 */
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 
 	set_bitmap(t->io_bitmap_ptr, from, num, !turn_on);
 
@@ -137,8 +145,13 @@
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
+#ifdef CONFIG_GRKERNSEC_IO
+		gr_handle_iopl();
+		return -EPERM;
+#else
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
+#endif
 	}
 	regs->eflags = (regs->eflags &~ 0x3000UL) | (level << 12);
 	/* Make sure we return the long way (not sysenter) */
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/irq.c grsecurity226/arch/i386/kernel/irq.c
--- linux-2.6.13.1.org/arch/i386/kernel/irq.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/irq.c	2005-08-30 01:12:47.000000000 +0200
@@ -119,10 +119,10 @@
  * gcc's 3.0 and earlier don't handle that correctly.
  */
 static char softirq_stack[NR_CPUS * THREAD_SIZE]
-		__attribute__((__aligned__(THREAD_SIZE)));
+		__attribute__((__aligned__(THREAD_SIZE), __section__(".bss.page_aligned")));
 
 static char hardirq_stack[NR_CPUS * THREAD_SIZE]
-		__attribute__((__aligned__(THREAD_SIZE)));
+		__attribute__((__aligned__(THREAD_SIZE), __section__(".bss.page_aligned")));
 
 /*
  * allocate per-cpu stacks for hardirq and for softirq processing
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/ldt.c grsecurity226/arch/i386/kernel/ldt.c
--- linux-2.6.13.1.org/arch/i386/kernel/ldt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/ldt.c	2005-08-30 01:12:47.000000000 +0200
@@ -102,6 +102,19 @@
 		retval = copy_ldt(&mm->context, &old_mm->context);
 		up(&old_mm->context.sem);
 	}
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (!mm->context.user_cs_limit) {
+		mm->context.user_cs_base = 0UL;
+		mm->context.user_cs_limit = ~0UL;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+		cpus_clear(mm->context.cpu_user_cs_mask);
+#endif
+
+	}
+#endif
+
 	return retval;
 }
 
@@ -159,7 +172,7 @@
 {
 	int err;
 	unsigned long size;
-	void *address;
+	const void *address;
 
 	err = 0;
 	address = &default_ldt[0];
@@ -216,6 +229,13 @@
 		}
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (ldt_info.contents & 2)) {
+		error = -EINVAL;
+		goto out_unlock;
+	}
+#endif
+
 	entry_1 = LDT_entry_a(&ldt_info);
 	entry_2 = LDT_entry_b(&ldt_info);
 	if (oldmode)
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/process.c grsecurity226/arch/i386/kernel/process.c
--- linux-2.6.13.1.org/arch/i386/kernel/process.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/process.c	2005-08-30 01:12:47.000000000 +0200
@@ -385,7 +385,7 @@
 	/* The process may have allocated an io port bitmap... nuke it. */
 	if (unlikely(NULL != t->io_bitmap_ptr)) {
 		int cpu = get_cpu();
-		struct tss_struct *tss = &per_cpu(init_tss, cpu);
+		struct tss_struct *tss = init_tss + cpu;
 
 		kfree(t->io_bitmap_ptr);
 		t->io_bitmap_ptr = NULL;
@@ -412,6 +412,9 @@
 	 */
 	kprobe_flush_task(tsk);
 
+	__asm__("mov %0,%%fs\n"
+		"mov %0,%%gs\n"
+		: : "r" (0) : "memory");
 	memset(tsk->thread.debugreg, 0, sizeof(unsigned long)*8);
 	memset(tsk->thread.tls_array, 0, sizeof(tsk->thread.tls_array));	
 	/*
@@ -571,9 +574,8 @@
 int dump_task_regs(struct task_struct *tsk, elf_gregset_t *regs)
 {
 	struct pt_regs ptregs;
-	
-	ptregs = *(struct pt_regs *)
-		((unsigned long)tsk->thread_info+THREAD_SIZE - sizeof(ptregs));
+
+	ptregs = *(struct pt_regs *)(tsk->thread.esp0 - sizeof(ptregs));
 	ptregs.xcs &= 0xffff;
 	ptregs.xds &= 0xffff;
 	ptregs.xes &= 0xffff;
@@ -675,12 +677,20 @@
 	struct thread_struct *prev = &prev_p->thread,
 				 *next = &next_p->thread;
 	int cpu = smp_processor_id();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long flags, cr3;
+#endif
 
 	/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */
 
 	__unlazy_fpu(prev_p);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(flags, cr3);
+#endif
+
 	/*
 	 * Reload esp0, LDT and the page table pointer:
 	 */
@@ -691,6 +701,10 @@
 	 */
 	load_TLS(next, cpu);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(flags, cr3);
+#endif
+
 	/*
 	 * Save away %fs and %gs. No need to save %es and %ds, as
 	 * those are always kernel segments while inside the kernel.
@@ -846,6 +860,10 @@
 	struct desc_struct *desc;
 	int cpu, idx;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long flags, cr3;
+#endif
+
 	if (copy_from_user(&info, u_info, sizeof(info)))
 		return -EFAULT;
 	idx = info.entry_number;
@@ -879,8 +897,17 @@
 		desc->a = LDT_entry_a(&info);
 		desc->b = LDT_entry_b(&info);
 	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(flags, cr3);
+#endif
+
 	load_TLS(t, cpu);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(flags, cr3);
+#endif
+
 	put_cpu();
 
 	return 0;
@@ -942,3 +969,28 @@
 		sp -= get_random_int() % 8192;
 	return sp & ~0xf;
 }
+
+#ifdef CONFIG_PAX_RANDKSTACK
+asmlinkage void pax_randomize_kstack(void)
+{
+	struct tss_struct *tss = init_tss + smp_processor_id();
+	unsigned long time;
+
+	if (!randomize_va_space)
+		return;
+
+	rdtscl(time);
+
+      /* P4 seems to return a 0 LSB, ignore it */
+#ifdef CONFIG_MPENTIUM4
+	time &= 0x3EUL;
+	time <<= 1;
+#else
+	time &= 0x1FUL;
+	time <<= 2;
+#endif
+
+	tss->esp0 ^= time;
+	current->thread.esp0 = tss->esp0;
+}
+#endif
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/ptrace.c grsecurity226/arch/i386/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/i386/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/ptrace.c	2005-08-30 01:12:47.000000000 +0200
@@ -17,6 +17,7 @@
 #include <linux/audit.h>
 #include <linux/seccomp.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -386,6 +387,9 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
@@ -464,6 +468,17 @@
 			  if(addr == (long) &dummy->u_debugreg[5]) break;
 			  if(addr < (long) &dummy->u_debugreg[4] &&
 			     ((unsigned long) data) >= TASK_SIZE-3) break;
+
+#ifdef CONFIG_GRKERNSEC
+			  if(addr >= (long) &dummy->u_debugreg[0] &&
+			     addr <= (long) &dummy->u_debugreg[3]){
+				long reg   = (addr - (long) &dummy->u_debugreg[0]) >> 2;
+				long type  = (child->thread.debugreg[7] >> (DR_CONTROL_SHIFT + 4*reg)) & 3;
+				long align = (child->thread.debugreg[7] >> (DR_CONTROL_SHIFT + 2 + 4*reg)) & 3;
+				if((type & 1) && (data & align))
+					break;
+			  }
+#endif
 			  
 			  /* Sanity-check data. Take one half-byte at once with
 			   * check = (val >> (16 + 4*i)) & 0xf. It contains the
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/reboot.c grsecurity226/arch/i386/kernel/reboot.c
--- linux-2.6.13.1.org/arch/i386/kernel/reboot.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/reboot.c	2005-08-30 01:12:48.000000000 +0200
@@ -129,18 +129,18 @@
    doesn't work with at least one type of 486 motherboard.  It is easy
    to stop this code working; hence the copious comments. */
 
-static unsigned long long
+static const unsigned long long
 real_mode_gdt_entries [3] =
 {
 	0x0000000000000000ULL,	/* Null descriptor */
-	0x00009a000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
-	0x000092000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
+	0x00009b000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
+	0x000093000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
 };
 
 static struct
 {
 	unsigned short       size __attribute__ ((packed));
-	unsigned long long * base __attribute__ ((packed));
+	const unsigned long long * base __attribute__ ((packed));
 }
 real_mode_gdt = { sizeof (real_mode_gdt_entries) - 1, real_mode_gdt_entries },
 real_mode_idt = { 0x3ff, NULL },
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/setup.c grsecurity226/arch/i386/kernel/setup.c
--- linux-2.6.13.1.org/arch/i386/kernel/setup.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/setup.c	2005-09-05 18:41:51.000000000 +0200
@@ -85,7 +85,11 @@
 struct cpuinfo_x86 boot_cpu_data = { 0, 0, 0, 0, -1, 1, 0, 0, -1 };
 EXPORT_SYMBOL(boot_cpu_data);
 
+#ifdef CONFIG_X86_PAE
+unsigned long mmu_cr4_features = X86_CR4_PAE;
+#else
 unsigned long mmu_cr4_features;
+#endif
 
 #ifdef	CONFIG_ACPI_INTERPRETER
 	int acpi_disabled = 0;
@@ -1518,14 +1522,14 @@
 
 	if (!MOUNT_ROOT_RDONLY)
 		root_mountflags &= ~MS_RDONLY;
-	init_mm.start_code = (unsigned long) _text;
-	init_mm.end_code = (unsigned long) _etext;
+	init_mm.start_code = (unsigned long) _text + __KERNEL_TEXT_OFFSET;
+	init_mm.end_code = (unsigned long) _etext + __KERNEL_TEXT_OFFSET;
 	init_mm.end_data = (unsigned long) _edata;
 	init_mm.brk = init_pg_tables_end + PAGE_OFFSET;
 
-	code_resource.start = virt_to_phys(_text);
-	code_resource.end = virt_to_phys(_etext)-1;
-	data_resource.start = virt_to_phys(_etext);
+	code_resource.start = virt_to_phys(_text + __KERNEL_TEXT_OFFSET);
+	code_resource.end = virt_to_phys(_etext + __KERNEL_TEXT_OFFSET)-1;
+	data_resource.start = virt_to_phys(_data);
 	data_resource.end = virt_to_phys(_edata)-1;
 
 	parse_cmdline_early(cmdline_p);
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/signal.c grsecurity226/arch/i386/kernel/signal.c
--- linux-2.6.13.1.org/arch/i386/kernel/signal.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/signal.c	2005-08-30 01:12:48.000000000 +0200
@@ -380,7 +380,17 @@
 			goto give_sigsegv;
 	}
 
+#ifdef CONFIG_PAX_NOVSYSCALL
+	restorer = frame->retcode;
+#else
 	restorer = &__kernel_sigreturn;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		restorer -= SEGMEXEC_TASK_SIZE;
+#endif
+#endif
+
 	if (ka->sa.sa_flags & SA_RESTORER)
 		restorer = ka->sa.sa_restorer;
 
@@ -476,7 +486,18 @@
 		goto give_sigsegv;
 
 	/* Set up to return from userspace.  */
+
+#ifdef CONFIG_PAX_NOVSYSCALL
+	restorer = frame->retcode;
+#else
 	restorer = &__kernel_rt_sigreturn;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		restorer -= SEGMEXEC_TASK_SIZE;
+#endif
+#endif
+
 	if (ka->sa.sa_flags & SA_RESTORER)
 		restorer = ka->sa.sa_restorer;
 	err |= __put_user(restorer, &frame->pretcode);
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/sys_i386.c grsecurity226/arch/i386/kernel/sys_i386.c
--- linux-2.6.13.1.org/arch/i386/kernel/sys_i386.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/sys_i386.c	2005-09-05 18:41:51.000000000 +0200
@@ -49,6 +49,11 @@
 	int error = -EBADF;
 	struct file * file = NULL;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR)
+		return -EINVAL;
+#endif
+
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
@@ -106,6 +111,117 @@
 	return err;
 }
 
+unsigned long
+arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
+			  const unsigned long len, const unsigned long pgoff,
+			  const unsigned long flags)
+{
+	struct vm_area_struct *vma;
+	struct mm_struct *mm = current->mm;
+	unsigned long base = mm->mmap_base, addr = addr0, task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	/* requested length too big for entire address space */
+	if (len > task_size)
+		return -ENOMEM;
+
+	if (flags & MAP_EXECUTABLE) {
+		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
+		mm->free_area_cache = mm->mmap_base;
+		addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
+		mm->free_area_cache = base;
+		mm->mmap_base = base;
+		return addr;
+	}
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
+	/* requesting a specific address */
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		vma = find_vma(mm, addr);
+		if (task_size - len >= addr &&
+				(!vma || addr + len <= vma->vm_start))
+			return addr;
+	}
+
+	/* check if free_area_cache is useful for us */
+	if (len <= mm->cached_hole_size) {
+	        mm->cached_hole_size = 0;
+		mm->free_area_cache = mm->mmap_base;
+	}
+
+	/* either no address requested or can't fit in requested address hole */
+	addr = mm->free_area_cache;
+
+	/* make sure it can fit in the remaining address space */
+	if (addr > len) {
+		vma = find_vma(mm, addr-len);
+		if (!vma || addr <= vma->vm_start)
+			/* remember the address as a hint for next time */
+			return (mm->free_area_cache = addr-len);
+	}
+
+	if (mm->mmap_base < len)
+		goto bottomup;
+
+	addr = mm->mmap_base-len;
+
+	do {
+		/*
+		 * Lookup failure means no vma is above this address,
+		 * else if new region fits below vma->vm_start,
+		 * return with success:
+		 */
+		vma = find_vma(mm, addr);
+		if (!vma || addr+len <= vma->vm_start)
+			/* remember the address as a hint for next time */
+			return (mm->free_area_cache = addr);
+
+		/* remember the largest hole we saw so far */
+		if (addr + mm->cached_hole_size < vma->vm_start)
+			mm->cached_hole_size = vma->vm_start - addr;
+
+		/* try just below the current vma->vm_start */
+		addr = vma->vm_start-len;
+	} while (len < vma->vm_start);
+
+bottomup:
+	/*
+	 * A failed mmap() very likely causes application failure,
+	 * so fall back to the bottom-up function here. This scenario
+	 * can happen with large stack limits and large mmap()
+	 * allocations.
+	 */
+	mm->cached_hole_size = ~0UL;
+	mm->free_area_cache = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->free_area_cache += mm->delta_mmap;
+#endif
+
+	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
+	/*
+	 * Restore the topdown base:
+	 */
+	mm->free_area_cache = base;
+	mm->cached_hole_size = ~0UL;
+
+	return addr;
+}
 
 struct sel_arg_struct {
 	unsigned long n;
@@ -250,3 +366,81 @@
 
 	return error;
 }
+unsigned long
+arch_get_unmapped_area(struct file *filp, unsigned long addr,
+		unsigned long len, unsigned long pgoff, unsigned long flags)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	unsigned long start_addr, start_mmap, task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > task_size)
+		return -ENOMEM;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		vma = find_vma(mm, addr);
+		if (task_size - len >= addr &&
+		    (!vma || addr + len <= vma->vm_start))
+			return addr;
+	}
+	if (len > mm->cached_hole_size) {
+		start_addr = addr = mm->free_area_cache;
+	} else {
+		start_addr = addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
+	}
+
+	start_mmap = PAGE_ALIGN(task_size/3);
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		start_mmap += mm->delta_mmap;
+#endif
+
+	if (!(flags & MAP_EXECUTABLE) && start_addr < start_mmap)
+		start_addr = addr = start_mmap;
+	else if ((flags & MAP_EXECUTABLE) && start_addr >= start_mmap)
+		start_addr = addr = mm->mmap_base;
+
+full_search:
+	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
+		/* At this point:  (!vma || addr < vma->vm_end). */
+		if (task_size - len < addr) {
+			/*
+			 * Start a new search - just in case we missed
+			 * some holes.
+			 */
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
+				mm->cached_hole_size = 0;
+				goto full_search;
+			}
+			return -ENOMEM;
+		}
+		if (!vma || (addr + len <= vma->vm_start && (addr + len <= mm->start_brk || start_mmap <= addr))) {
+			/*
+			 * Remember the place where we stopped the search:
+			 */
+			mm->free_area_cache = addr + len;
+			return addr;
+		}
+		if (addr < start_mmap && addr + len > mm->start_brk) {
+			addr = start_mmap = mm->mmap_base;
+			mm->cached_hole_size = 0;
+			goto full_search;
+		}
+		if (addr + mm->cached_hole_size < vma->vm_start)
+		        mm->cached_hole_size = vma->vm_start - addr;
+		addr = vma->vm_end;
+	}
+}
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/syscall_table.S grsecurity226/arch/i386/kernel/syscall_table.S
--- linux-2.6.13.1.org/arch/i386/kernel/syscall_table.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/syscall_table.S	2005-08-30 01:12:48.000000000 +0200
@@ -1,4 +1,4 @@
-.data
+.section .rodata,"a",@progbits
 ENTRY(sys_call_table)
 	.long sys_restart_syscall	/* 0 - old "setup()" system call, used for restarting */
 	.long sys_exit
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/sysenter.c grsecurity226/arch/i386/kernel/sysenter.c
--- linux-2.6.13.1.org/arch/i386/kernel/sysenter.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/sysenter.c	2005-08-30 01:12:48.000000000 +0200
@@ -24,7 +24,7 @@
 void enable_sep_cpu(void)
 {
 	int cpu = get_cpu();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 
 	if (!boot_cpu_has(X86_FEATURE_SEP)) {
 		put_cpu();
@@ -48,6 +48,7 @@
 
 int __init sysenter_setup(void)
 {
+#ifndef CONFIG_PAX_NOVSYSCALL
 	void *page = (void *)get_zeroed_page(GFP_ATOMIC);
 
 	__set_fixmap(FIX_VSYSCALL, __pa(page), PAGE_READONLY_EXEC);
@@ -62,6 +63,7 @@
 	memcpy(page,
 	       &vsyscall_sysenter_start,
 	       &vsyscall_sysenter_end - &vsyscall_sysenter_start);
+#endif
 
 	return 0;
 }
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/traps.c grsecurity226/arch/i386/kernel/traps.c
--- linux-2.6.13.1.org/arch/i386/kernel/traps.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/traps.c	2005-08-30 01:12:48.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/utsname.h>
 #include <linux/kprobes.h>
 #include <linux/kexec.h>
+#include <linux/binfmts.h>
 
 #ifdef CONFIG_EISA
 #include <linux/ioport.h>
@@ -59,18 +60,13 @@
 
 asmlinkage int system_call(void);
 
-struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
+const struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
 		{ 0, 0 }, { 0, 0 } };
 
 /* Do we ignore FPU interrupts ? */
 char ignore_fpu_irq = 0;
 
-/*
- * The IDT has to be page-aligned to simplify the Pentium
- * F0 0F bug workaround.. We have a special link segment
- * for this.
- */
-struct desc_struct idt_table[256] __attribute__((__section__(".data.idt"))) = { {0, 0}, };
+extern struct desc_struct idt_table[256];
 
 asmlinkage void divide_error(void);
 asmlinkage void debug(void);
@@ -117,6 +113,7 @@
 				unsigned long *stack, unsigned long ebp)
 {
 	unsigned long addr;
+	int i = kstack_depth_to_print;
 
 #ifdef	CONFIG_FRAME_POINTER
 	while (valid_stack_ptr(tinfo, (void *)ebp)) {
@@ -125,6 +122,7 @@
 		print_symbol("%s", addr);
 		printk("\n");
 		ebp = *(unsigned long *)ebp;
+		--i;
 	}
 #else
 	while (valid_stack_ptr(tinfo, stack)) {
@@ -133,6 +131,7 @@
 			printk(" [<%08lx>]", addr);
 			print_symbol(" %s", addr);
 			printk("\n");
+			--i;
 		}
 	}
 #endif
@@ -242,7 +241,7 @@
 
 		printk("Code: ");
 
-		eip = (u8 __user *)regs->eip - 43;
+		eip = (u8 __user *)regs->eip - 43 + __KERNEL_TEXT_OFFSET;
 		for (i = 0; i < 64; i++, eip++) {
 			unsigned char c;
 
@@ -270,7 +269,7 @@
 	if (user_mode(regs))
 		goto no_bug;		/* Not in kernel */
 
-	eip = regs->eip;
+	eip = regs->eip + __KERNEL_TEXT_OFFSET;
 
 	if (eip < PAGE_OFFSET)
 		goto no_bug;
@@ -466,7 +465,7 @@
 fastcall void do_general_protection(struct pt_regs * regs, long error_code)
 {
 	int cpu = get_cpu();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = &init_tss[cpu];
 	struct thread_struct *thread = &current->thread;
 
 	/*
@@ -504,6 +503,24 @@
 	if (!user_mode(regs))
 		goto gp_in_kernel;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (current->mm) {
+		struct mm_struct *mm = current->mm;
+		unsigned long limit;
+
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+			down_write(&mm->mmap_sem);
+			limit = mm->context.user_cs_limit;
+			if (limit < TASK_SIZE) {
+				track_exec_limit(mm, limit, TASK_SIZE, PROT_EXEC);
+				up_write(&mm->mmap_sem);
+				return;
+			}
+			up_write(&mm->mmap_sem);
+		}
+	}
+#endif
+
 	current->thread.error_code = error_code;
 	current->thread.trap_no = 13;
 	force_sig(SIGSEGV, current);
@@ -519,6 +536,13 @@
 		if (notify_die(DIE_GPF, "general protection fault", regs,
 				error_code, 13, SIGSEGV) == NOTIFY_STOP)
 			return;
+
+#ifdef CONFIG_PAX_KERNEXEC
+		if ((regs->xcs & 0xFFFF) == __KERNEL_CS)
+			die("PAX: suspicious general protection fault", regs, error_code);
+		else
+#endif
+
 		die("general protection fault", regs, error_code);
 	}
 }
@@ -1001,6 +1025,8 @@
 #ifdef CONFIG_X86_F00F_BUG
 void __init trap_init_f00f_bug(void)
 {
+
+#ifndef CONFIG_PAX_KERNEXEC
 	__set_fixmap(FIX_F00F_IDT, __pa(&idt_table), PAGE_KERNEL_RO);
 
 	/*
@@ -1009,6 +1035,8 @@
 	 */
 	idt_descr.address = fix_to_virt(FIX_F00F_IDT);
 	__asm__ __volatile__("lidt %0" : : "m" (idt_descr));
+#endif
+
 }
 #endif
 
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/vm86.c grsecurity226/arch/i386/kernel/vm86.c
--- linux-2.6.13.1.org/arch/i386/kernel/vm86.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/vm86.c	2005-08-30 01:12:48.000000000 +0200
@@ -121,7 +121,7 @@
 		do_exit(SIGSEGV);
 	}
 
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 	current->thread.esp0 = current->thread.saved_esp0;
 	current->thread.sysenter_cs = __KERNEL_CS;
 	load_esp0(tss, &current->thread);
@@ -297,7 +297,7 @@
 	asm volatile("mov %%fs,%0":"=m" (tsk->thread.saved_fs));
 	asm volatile("mov %%gs,%0":"=m" (tsk->thread.saved_gs));
 
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 	tsk->thread.esp0 = (unsigned long) &info->VM86_TSS_ESP0;
 	if (cpu_has_sep)
 		tsk->thread.sysenter_cs = 0;
diff -Nur linux-2.6.13.1.org/arch/i386/kernel/vmlinux.lds.S grsecurity226/arch/i386/kernel/vmlinux.lds.S
--- linux-2.6.13.1.org/arch/i386/kernel/vmlinux.lds.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/kernel/vmlinux.lds.S	2005-09-10 21:36:53.000000000 +0200
@@ -4,9 +4,18 @@
 
 #define LOAD_OFFSET __PAGE_OFFSET
 
+#include <linux/config.h>
+
 #include <asm-generic/vmlinux.lds.h>
 #include <asm/thread_info.h>
 #include <asm/page.h>
+#include <asm/segment.h>
+
+#ifdef CONFIG_X86_PAE
+#define PMD_SHIFT 21
+#else
+#define PMD_SHIFT 22
+#endif
 
 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
 OUTPUT_ARCH(i386)
@@ -15,66 +24,17 @@
 SECTIONS
 {
   . = __KERNEL_START;
-  phys_startup_32 = startup_32 - LOAD_OFFSET;
-  /* read-only */
-  _text = .;			/* Text and read-only data */
-  .text : AT(ADDR(.text) - LOAD_OFFSET) {
-	*(.text)
-	SCHED_TEXT
-	LOCK_TEXT
-	*(.fixup)
-	*(.gnu.warning)
-	} = 0x9090
-
-  _etext = .;			/* End of text section */
-
-  . = ALIGN(16);		/* Exception table */
-  __start___ex_table = .;
-  __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) { *(__ex_table) }
-  __stop___ex_table = .;
-
-  RODATA
+  phys_startup_32 = startup_32 - LOAD_OFFSET + __KERNEL_TEXT_OFFSET;
 
-  /* writeable */
-  .data : AT(ADDR(.data) - LOAD_OFFSET) {	/* Data */
-	*(.data)
-	CONSTRUCTORS
+  .text.startup : AT(ADDR(.text.startup) - LOAD_OFFSET) {
+	BYTE(0xEA) /* jmp far */
+	LONG(phys_startup_32)
+	SHORT(__BOOT_CS)
 	}
 
-  . = ALIGN(4096);
-  __nosave_begin = .;
-  .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) { *(.data.nosave) }
-  . = ALIGN(4096);
-  __nosave_end = .;
-
-  . = ALIGN(4096);
-  .data.page_aligned : AT(ADDR(.data.page_aligned) - LOAD_OFFSET) {
-	*(.data.idt)
-  }
-
-  . = ALIGN(32);
-  .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - LOAD_OFFSET) {
-	*(.data.cacheline_aligned)
-  }
-
-  /* rarely changed data like cpu maps */
-  . = ALIGN(32);
-  .data.read_mostly : AT(ADDR(.data.read_mostly) - LOAD_OFFSET) { *(.data.read_mostly) }
-  _edata = .;			/* End of data section */
-
-  . = ALIGN(THREAD_SIZE);	/* init_task */
-  .data.init_task : AT(ADDR(.data.init_task) - LOAD_OFFSET) {
-	*(.data.init_task)
-  }
-
   /* will be freed after init */
   . = ALIGN(4096);		/* Init code and data */
   __init_begin = .;
-  .init.text : AT(ADDR(.init.text) - LOAD_OFFSET) {
-	_sinittext = .;
-	*(.init.text)
-	_einittext = .;
-  }
   .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) { *(.init.data) }
   . = ALIGN(16);
   __setup_start = .;
@@ -106,9 +66,7 @@
   .altinstr_replacement : AT(ADDR(.altinstr_replacement) - LOAD_OFFSET) {
 	*(.altinstr_replacement)
   }
-  /* .exit.text is discard at runtime, not link time, to deal with references
-     from .altinstructions and .eh_frame */
-  .exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET) { *(.exit.text) }
+
   .exit.data : AT(ADDR(.exit.data) - LOAD_OFFSET) { *(.exit.data) }
   . = ALIGN(4096);
   __initramfs_start = .;
@@ -118,10 +76,104 @@
   __per_cpu_start = .;
   .data.percpu  : AT(ADDR(.data.percpu) - LOAD_OFFSET) { *(.data.percpu) }
   __per_cpu_end = .;
+
+  /* read-only */
+
+  .init.text (. - __KERNEL_TEXT_OFFSET) : AT(ADDR(.init.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	_sinittext = .;
+	*(.init.text)
+	_einittext = .;
+  }
+
+  /* .exit.text is discard at runtime, not link time, to deal with references
+     from .altinstructions and .eh_frame */
+  .exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) { *(.exit.text) }
+
+#ifdef CONFIG_PAX_KERNEXEC
+  .text.align : AT(ADDR(.text.align) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	. = ALIGN(__KERNEL_TEXT_OFFSET - LOAD_OFFSET) - 1;
+	BYTE(0)
+  }
+#else
   . = ALIGN(4096);
-  __init_end = .;
+#endif
+
+  __init_end = . + __KERNEL_TEXT_OFFSET;
   /* freed after init ends here */
-	
+
+  _text = .;			/* Text and read-only data */
+  .text : AT(ADDR(.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	*(.text)
+	SCHED_TEXT
+	LOCK_TEXT
+	*(.fixup)
+	*(.gnu.warning)
+	} = 0x9090
+
+  _etext = .;			/* End of text section */
+  . += __KERNEL_TEXT_OFFSET;
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(4096);
+  .rodata.page_aligned : AT(ADDR(.rodata.page_aligned) - LOAD_OFFSET) {
+	*(.rodata.empty_zero_page)
+	*(.rodata.idt)
+	}
+
+  RODATA
+
+#ifdef CONFIG_PAX_KERNEXEC
+  .data.align : AT(ADDR(.data.align) - LOAD_OFFSET) {
+	. = ALIGN(1 << PMD_SHIFT) - 1;
+	BYTE(0)
+  }
+#else
+  . = ALIGN(32);
+#endif
+
+  /* writeable */
+  .data : AT(ADDR(.data) - LOAD_OFFSET) {	/* Data */
+	_data = .;
+	*(.data)
+	CONSTRUCTORS
+	}
+
+  . = ALIGN(4096);
+  __nosave_begin = .;
+  .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) { *(.data.nosave) }
+  . = ALIGN(4096);
+  __nosave_end = .;
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - LOAD_OFFSET) {
+	*(.data.cacheline_aligned)
+  }
+
+  /* rarely changed data like cpu maps */
+  . = ALIGN(32);
+  .data.read_mostly : AT(ADDR(.data.read_mostly) - LOAD_OFFSET) { *(.data.read_mostly) }
+
+  . = ALIGN(THREAD_SIZE);	/* init_task */
+  .data.init_task : AT(ADDR(.data.init_task) - LOAD_OFFSET) {
+	*(.data.init_task)
+  }
+
+  . = ALIGN(4096);
+  .data.page_aligned : AT(ADDR(.data.page_aligned) - LOAD_OFFSET) {
+
+#ifdef CONFIG_X86_PAE
+	*(.data.swapper_pm_dir)
+#endif
+
+	*(.data.swapper_pg_dir)
+  }
+
+  _edata = .;			/* End of data section */
+
+  . = ALIGN(4096);
   __bss_start = .;		/* BSS */
   .bss.page_aligned : AT(ADDR(.bss.page_aligned) - LOAD_OFFSET) {
 	*(.bss.page_aligned)
diff -Nur linux-2.6.13.1.org/arch/i386/mm/fault.c grsecurity226/arch/i386/mm/fault.c
--- linux-2.6.13.1.org/arch/i386/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/mm/fault.c	2005-09-10 21:36:55.000000000 +0200
@@ -21,6 +21,9 @@
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/highmem.h>
 #include <linux/module.h>
+#include <linux/unistd.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -81,7 +84,7 @@
 
 	/* Unlikely, but must come before segment checks. */
 	if (unlikely((regs->eflags & VM_MASK) != 0))
-		return eip + (seg << 4);
+		return (eip & 0xFFFF) + (seg << 4);
 	
 	/* By far the most common cases. */
 	if (likely(seg == __USER_CS || seg == __KERNEL_CS))
@@ -107,7 +110,7 @@
 		desc = (void *)desc + (seg & ~7);
 	} else {
 		/* Must disable preemption while reading the GDT. */
-		desc = (u32 *)&per_cpu(cpu_gdt_table, get_cpu());
+		desc = (u32 *)&cpu_gdt_table[get_cpu()];
 		desc = (void *)desc + (seg & ~7);
 	}
 
@@ -201,6 +204,31 @@
 
 fastcall void do_invalid_op(struct pt_regs *, unsigned long);
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+static int pax_handle_fetch_fault(struct pt_regs *regs);
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/* PaX: called with the page_table_lock spinlock held */
+static inline pte_t * pax_get_pte(struct mm_struct *mm, unsigned long address)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+
+	pgd = pgd_offset(mm, address);
+	if (!pgd || !pgd_present(*pgd))
+		return 0;
+	pud = pud_offset(pgd, address);
+	if (!pud || !pud_present(*pud))
+		return 0;
+	pmd = pmd_offset(pud, address);
+	if (!pmd || !pmd_present(*pmd))
+		return 0;
+	return pte_offset_map(pmd, address);
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
@@ -217,10 +245,14 @@
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
 	unsigned long address;
-	unsigned long page;
 	int write;
 	siginfo_t info;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	pte_t *pte;
+	unsigned char pte_mask1, pte_mask2;
+#endif
+
 	/* get the address */
 	__asm__("movl %%cr2,%0":"=r" (address));
 
@@ -232,6 +264,7 @@
 		local_irq_enable();
 
 	tsk = current;
+	mm = tsk->mm;
 
 	info.si_code = SEGV_MAPERR;
 
@@ -258,14 +291,94 @@
 		goto bad_area_nosemaphore;
 	} 
 
-	mm = tsk->mm;
-
 	/*
 	 * If we're in an interrupt, have no user context or are running in an
 	 * atomic region then we must not take the fault..
 	 */
 	if (in_atomic() || !mm)
-		goto bad_area_nosemaphore;
+		goto bad_area_nopax;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (unlikely((error_code & 5) != 5 ||
+		     (regs->eflags & X86_EFLAGS_VM) ||
+		     !(mm->pax_flags & MF_PAX_PAGEEXEC)))
+		goto not_pax_fault;
+
+	/* PaX: it's our fault, let's handle it if we can */
+
+	/* PaX: take a look at read faults before acquiring any locks */
+	if (unlikely(!(error_code & 2) && (regs->eip == address))) {
+		/* instruction fetch attempt from a protected page in user mode */
+		switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		case 2:
+			return;
+#endif
+
+		}
+		pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+		do_exit(SIGKILL);
+	}
+
+	spin_lock(&mm->page_table_lock);
+	pte = pax_get_pte(mm, address);
+	if (unlikely(!pte || !(pte_val(*pte) & _PAGE_PRESENT) || pte_user(*pte))) {
+		pte_unmap(pte);
+		spin_unlock(&mm->page_table_lock);
+		goto not_pax_fault;
+	}
+
+	if (unlikely((error_code & 2) && !pte_write(*pte))) {
+		/* write attempt to a protected page in user mode */
+		pte_unmap(pte);
+		spin_unlock(&mm->page_table_lock);
+		goto not_pax_fault;
+	}
+
+	pte_mask1 = _PAGE_ACCESSED | _PAGE_USER | ((error_code & 2) << (_PAGE_BIT_DIRTY-1));
+
+#ifdef CONFIG_SMP
+	if (likely(cpu_isset(smp_processor_id(), mm->context.cpu_user_cs_mask)) && address >= get_limit(regs->xcs))
+		pte_mask2 = 0;
+	else
+		pte_mask2 = _PAGE_USER;
+#else
+	pte_mask2 = (address >= get_limit(regs->xcs)) ? 0 : _PAGE_USER;
+#endif
+
+	/*
+	 * PaX: fill DTLB with user rights and retry
+	 */
+	__asm__ __volatile__ (
+		"orb %2,%1\n"
+#if defined(CONFIG_M586) || defined(CONFIG_M586TSC)
+/*
+ * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's
+ * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+ * page fault when examined during a TLB load attempt. this is true not only
+ * for PTEs holding a non-present entry but also present entries that will
+ * raise a page fault (such as those set up by PaX, or the copy-on-write
+ * mechanism). in effect it means that we do *not* need to flush the TLBs
+ * for our target pages since their PTEs are simply not in the TLBs at all.
+
+ * the best thing in omitting it is that we gain around 15-20% speed in the
+ * fast path of the page fault handler and can get rid of tracing since we
+ * can no longer flush unintended entries.
+ */
+		"invlpg %0\n"
+#endif
+		"testb $0,%0\n"
+		"xorb %3,%1\n"
+		:
+		: "m" (*(char*)address), "m" (*(char*)pte), "q" (pte_mask1), "q" (pte_mask2)
+		: "memory", "cc");
+	pte_unmap(pte);
+	spin_unlock(&mm->page_table_lock);
+	return;
+
+not_pax_fault:
+#endif
 
 	/* When running in the kernel we expect faults to occur only to
 	 * addresses in user space.  All other faults represent errors in the
@@ -285,7 +398,7 @@
 	if (!down_read_trylock(&mm->mmap_sem)) {
 		if ((error_code & 4) == 0 &&
 		    !search_exception_tables(regs->eip))
-			goto bad_area_nosemaphore;
+			goto bad_area_nopax;
 		down_read(&mm->mmap_sem);
 	}
 
@@ -374,6 +487,37 @@
 	up_read(&mm->mmap_sem);
 
 bad_area_nosemaphore:
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm && (error_code & 4) && !(regs->eflags & X86_EFLAGS_VM)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && !(error_code & 3) && (regs->eip == address)) {
+			pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+			do_exit(SIGKILL);
+		}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((mm->pax_flags & MF_PAX_SEGMEXEC) && !(error_code & 3) && (regs->eip + SEGMEXEC_TASK_SIZE == address)) {
+
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			case 2:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+			do_exit(SIGKILL);
+		}
+#endif
+
+	}
+#endif
+
+bad_area_nopax:
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & 4) {
 		/* 
@@ -441,28 +585,53 @@
 #endif
 	if (address < PAGE_SIZE)
 		printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference");
+
+#ifdef CONFIG_PAX_KERNEXEC
+	else if (init_mm.start_code <= address && address < init_mm.end_code)
+	{
+		if (tsk->signal->curr_ip)
+			printk(KERN_ERR "PAX: From %u.%u.%u.%u: %s:%d, uid/euid: %u/%u, attempted to modify kernel code",
+				 NIPQUAD(tsk->signal->curr_ip), tsk->comm, tsk->pid, tsk->uid, tsk->euid);
+		else
+			printk(KERN_ERR "PAX: %s:%d, uid/euid: %u/%u, attempted to modify kernel code",
+				 tsk->comm, tsk->pid, tsk->uid, tsk->euid);
+	}
+#endif
+
 	else
 		printk(KERN_ALERT "Unable to handle kernel paging request");
 	printk(" at virtual address %08lx\n",address);
 	printk(KERN_ALERT " printing eip:\n");
 	printk("%08lx\n", regs->eip);
-	asm("movl %%cr3,%0":"=r" (page));
-	page = ((unsigned long *) __va(page))[address >> 22];
-	printk(KERN_ALERT "*pde = %08lx\n", page);
-	/*
-	 * We must not directly access the pte in the highpte
-	 * case, the page table might be allocated in highmem.
-	 * And lets rather not kmap-atomic the pte, just in case
-	 * it's allocated already.
-	 */
+	{
+		unsigned long index = pgd_index(address);
+		unsigned long pgd_paddr;
+		pgd_t *pgd;
+		pud_t *pud;
+		pmd_t *pmd;
+		pte_t *pte;
+
+		asm("movl %%cr3,%0":"=r" (pgd_paddr));
+		pgd = index + (pgd_t *)__va(pgd_paddr);
+		printk(KERN_ALERT "*pgd = %*llx\n", sizeof(*pgd), (unsigned long long)pgd_val(*pgd));
+		if (pgd_present(*pgd)) {
+			pud = pud_offset(pgd, address);
+			pmd = pmd_offset(pud, address);
+			printk(KERN_ALERT "*pmd = %*llx\n", sizeof(*pmd), (unsigned long long)pmd_val(*pmd));
+			/*
+			 * We must not directly access the pte in the highpte
+			 * case, the page table might be allocated in highmem.
+			 * And lets rather not kmap-atomic the pte, just in case
+			 * it's allocated already.
+			 */
 #ifndef CONFIG_HIGHPTE
-	if (page & 1) {
-		page &= PAGE_MASK;
-		address &= 0x003ff000;
-		page = ((unsigned long *) __va(page))[address >> PAGE_SHIFT];
-		printk(KERN_ALERT "*pte = %08lx\n", page);
-	}
+			if (pmd_present(*pmd) && !pmd_large(*pmd)) {
+				pte = pte_offset_kernel(pmd, address);
+				printk(KERN_ALERT "*pte = %*llx\n", sizeof(*pte), (unsigned long long)pte_val(*pte));
+			}
 #endif
+		}
+	}
 	tsk->thread.cr2 = address;
 	tsk->thread.trap_no = 14;
 	tsk->thread.error_code = error_code;
@@ -516,7 +685,7 @@
 		 * Do _not_ use "tsk" here. We might be inside
 		 * an interrupt in the middle of a task switch..
 		 */
-		int index = pgd_index(address);
+		unsigned long index = pgd_index(address);
 		unsigned long pgd_paddr;
 		pgd_t *pgd, *pgd_k;
 		pud_t *pud, *pud_k;
@@ -553,3 +722,236 @@
 		return;
 	}
 }
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+/*
+ * PaX: decide what to do with offenders (regs->eip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when gcc trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	static const unsigned char trans[8] = {6, 1, 2, 0, 13, 5, 3, 4};
+	int err;
+#endif
+
+	if (regs->eflags & X86_EFLAGS_VM)
+		return 1;
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+
+	do { /* PaX: gcc trampoline emulation #1 */
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned long addr1, addr2, ret;
+		unsigned short call;
+
+		err = get_user(mov1, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(mov2, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= get_user(jmp, (unsigned short *)(regs->eip + 10));
+		err |= get_user(ret, (unsigned long *)regs->esp);
+
+		if (err)
+			break;
+
+		err = get_user(call, (unsigned short *)(ret-2));
+		if (err)
+			break;
+
+		if ((mov1 & 0xF8) == 0xB8 &&
+		    (mov2 & 0xF8) == 0xB8 &&
+		    (mov1 & 0x07) != (mov2 & 0x07) &&
+		    (jmp & 0xF8FF) == 0xE0FF &&
+		    (mov2 & 0x07) == ((jmp>>8) & 0x07) &&
+		    (call & 0xF8FF) == 0xD0FF &&
+		    regs->eip == ((unsigned long*)regs)[trans[(call>>8) & 0x07]])
+		{
+			((unsigned long *)regs)[trans[mov1 & 0x07]] = addr1;
+			((unsigned long *)regs)[trans[mov2 & 0x07]] = addr2;
+			regs->eip = addr2;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #2 */
+		unsigned char mov, jmp;
+		unsigned long addr1, addr2, ret;
+		unsigned short call;
+
+		err = get_user(mov, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(jmp, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= get_user(ret, (unsigned long *)regs->esp);
+
+		if (err)
+			break;
+
+		err = get_user(call, (unsigned short *)(ret-2));
+		if (err)
+			break;
+
+		if ((mov & 0xF8) == 0xB8 &&
+		    jmp == 0xE9 &&
+		    (call & 0xF8FF) == 0xD0FF &&
+		    regs->eip == ((unsigned long*)regs)[trans[(call>>8) & 0x07]])
+		{
+			((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+			regs->eip += addr2 + 10;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #3 */
+		unsigned char mov, jmp;
+		char offset;
+		unsigned long addr1, addr2, ret;
+		unsigned short call;
+
+		err = get_user(mov, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(jmp, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= get_user(ret, (unsigned long *)regs->esp);
+
+		if (err)
+			break;
+
+		err = get_user(call, (unsigned short *)(ret-3));
+		err |= get_user(offset, (char *)(ret-1));
+		if (err)
+			break;
+
+		if ((mov & 0xF8) == 0xB8 &&
+		    jmp == 0xE9 &&
+		    (call & 0xF8FF) == 0x50FF &&
+		    call != 0x54FF)
+		{
+			unsigned long addr, target;
+
+			target = ((unsigned long*)regs)[trans[(call>>8) & 0x07]] + (unsigned long)(long)offset;
+			err = get_user(addr, (unsigned long*)target);
+			if (err || regs->eip != addr)
+				break;
+
+			((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+			regs->eip += addr2 + 10;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #4 */
+		unsigned char mov, jmp, sib;
+		char offset;
+		unsigned long addr1, addr2, ret;
+		unsigned short call;
+
+		err = get_user(mov, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(jmp, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= get_user(ret, (unsigned long *)regs->esp);
+
+		if (err)
+			break;
+
+		err = get_user(call, (unsigned short *)(ret-4));
+		err |= get_user(sib, (unsigned char *)(ret-2));
+		err |= get_user(offset, (char *)(ret-1));
+		if (err)
+			break;
+
+		if ((mov & 0xF8) == 0xB8 &&
+		    jmp == 0xE9 &&
+		    call == 0x54FF &&
+		    sib == 0x24)
+		{
+			unsigned long addr;
+
+			err = get_user(addr, (unsigned long*)(regs->esp + 4 + (unsigned long)(long)offset));
+			if (err || regs->eip != addr)
+				break;
+
+			((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+			regs->eip += addr2 + 10;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #5 */
+		unsigned char mov, jmp, sib;
+		unsigned long addr1, addr2, ret, offset;
+		unsigned short call;
+
+		err = get_user(mov, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(jmp, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= get_user(ret, (unsigned long *)regs->esp);
+
+		if (err)
+			break;
+
+		err = get_user(call, (unsigned short *)(ret-7));
+		err |= get_user(sib, (unsigned char *)(ret-5));
+		err |= get_user(offset, (unsigned long *)(ret-4));
+		if (err)
+			break;
+
+		if ((mov & 0xF8) == 0xB8 &&
+		    jmp == 0xE9 &&
+		    call == 0x94FF &&
+		    sib == 0x24)
+		{
+			unsigned long addr;
+
+			err = get_user(addr, (unsigned long*)(regs->esp + 4 + offset));
+			if (err || regs->eip != addr)
+				break;
+
+			((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+			regs->eip += addr2 + 10;
+			return 2;
+		}
+	} while (0);
+#endif
+
+	return 1; /* PaX in action */
+}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%02x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP: ");
+	for (i = 0; i < 20; i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long*)sp+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08lx ", c);
+	}
+	printk("\n");
+}
+#endif
diff -Nur linux-2.6.13.1.org/arch/i386/mm/init.c grsecurity226/arch/i386/mm/init.c
--- linux-2.6.13.1.org/arch/i386/mm/init.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/mm/init.c	2005-09-05 18:41:52.000000000 +0200
@@ -39,6 +39,7 @@
 #include <asm/tlb.h>
 #include <asm/tlbflush.h>
 #include <asm/sections.h>
+#include <asm/desc.h>
 
 unsigned int __VMALLOC_RESERVE = 128 << 20;
 
@@ -48,30 +49,6 @@
 static int noinline do_test_wp_bit(void);
 
 /*
- * Creates a middle page table and puts a pointer to it in the
- * given global directory entry. This only returns the gd entry
- * in non-PAE compilation mode, since the middle layer is folded.
- */
-static pmd_t * __init one_md_table_init(pgd_t *pgd)
-{
-	pud_t *pud;
-	pmd_t *pmd_table;
-		
-#ifdef CONFIG_X86_PAE
-	pmd_table = (pmd_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-	set_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));
-	pud = pud_offset(pgd, 0);
-	if (pmd_table != pmd_offset(pud, 0)) 
-		BUG();
-#else
-	pud = pud_offset(pgd, 0);
-	pmd_table = pmd_offset(pud, 0);
-#endif
-
-	return pmd_table;
-}
-
-/*
  * Create a page table and place a pointer to it in a middle page
  * directory entry.
  */
@@ -114,8 +91,6 @@
 	pgd = pgd_base + pgd_idx;
 
 	for ( ; (pgd_idx < PTRS_PER_PGD) && (vaddr != end); pgd++, pgd_idx++) {
-		if (pgd_none(*pgd)) 
-			one_md_table_init(pgd);
 		pud = pud_offset(pgd, vaddr);
 		pmd = pmd_offset(pud, vaddr);
 		for (; (pmd_idx < PTRS_PER_PMD) && (vaddr != end); pmd++, pmd_idx++) {
@@ -144,6 +119,7 @@
 {
 	unsigned long pfn;
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 	int pgd_idx, pmd_idx, pte_ofs;
@@ -153,7 +129,8 @@
 	pfn = 0;
 
 	for (; pgd_idx < PTRS_PER_PGD; pgd++, pgd_idx++) {
-		pmd = one_md_table_init(pgd);
+		pud = pud_offset(pgd, 0);
+		pmd = pmd_offset(pud, 0);
 		if (pfn >= max_low_pfn)
 			continue;
 		for (pmd_idx = 0; pmd_idx < PTRS_PER_PMD && pfn < max_low_pfn; pmd++, pmd_idx++) {
@@ -309,13 +286,6 @@
 	unsigned long vaddr;
 	pgd_t *pgd_base = swapper_pg_dir;
 
-#ifdef CONFIG_X86_PAE
-	int i;
-	/* Init entries of the first-level page table to the zero page */
-	for (i = 0; i < PTRS_PER_PGD; i++)
-		set_pgd(pgd_base + i, __pgd(__pa(empty_zero_page) | _PAGE_PRESENT));
-#endif
-
 	/* Enable PSE if available */
 	if (cpu_has_pse) {
 		set_in_cr4(X86_CR4_PSE);
@@ -339,17 +309,6 @@
 	page_table_range_init(vaddr, 0, pgd_base);
 
 	permanent_kmaps_init(pgd_base);
-
-#ifdef CONFIG_X86_PAE
-	/*
-	 * Add low memory identity-mappings - SMP needs it when
-	 * starting up on an AP from real-mode. In the non-PAE
-	 * case we already have these mappings through head.S.
-	 * All user-space mappings are explicitly cleared after
-	 * SMP startup.
-	 */
-	pgd_base[0] = pgd_base[USER_PTRS_PER_PGD];
-#endif
 }
 
 #ifdef CONFIG_SOFTWARE_SUSPEND
@@ -391,8 +350,7 @@
 	flush_tlb_all();
 }
 
-static int disable_nx __initdata = 0;
-u64 __supported_pte_mask = ~_PAGE_NX;
+u64 __supported_pte_mask = ~0ULL;
 
 /*
  * noexec = on|off
@@ -406,9 +364,7 @@
 {
 	if (!strncmp(str, "on",2) && cpu_has_nx) {
 		__supported_pte_mask |= _PAGE_NX;
-		disable_nx = 0;
 	} else if (!strncmp(str,"off",3)) {
-		disable_nx = 1;
 		__supported_pte_mask &= ~_PAGE_NX;
 	}
 }
@@ -422,14 +378,15 @@
 
 	if (cpu_has_pae && (cpuid_eax(0x80000000) > 0x80000001)) {
 		cpuid(0x80000001, &v[0], &v[1], &v[2], &v[3]);
-		if ((v[3] & (1 << 20)) && !disable_nx) {
+		if ((v[3] & (1 << 20)) && (__supported_pte_mask & _PAGE_NX)) {
 			rdmsr(MSR_EFER, l, h);
 			l |= EFER_NX;
 			wrmsr(MSR_EFER, l, h);
 			nx_enabled = 1;
-			__supported_pte_mask |= _PAGE_NX;
+			return;
 		}
 	}
+	__supported_pte_mask &= ~_PAGE_NX;
 }
 
 /*
@@ -480,15 +437,17 @@
 
 	load_cr3(swapper_pg_dir);
 
+	__flush_tlb_all();
+
+#ifdef CONFIG_PAX_KERNEXEC
+
 #ifdef CONFIG_X86_PAE
-	/*
-	 * We will bail out later - printk doesn't work right now so
-	 * the user would just see a hanging kernel.
-	 */
-	if (cpu_has_pae)
-		set_in_cr4(X86_CR4_PAE);
+	memcpy(kernexec_pm_dir, swapper_pm_dir, sizeof(kernexec_pm_dir));
+#else
+	memcpy(kernexec_pg_dir, swapper_pg_dir, sizeof(kernexec_pg_dir));
+#endif
+
 #endif
-	__flush_tlb_all();
 
 	kmap_init();
 }
@@ -579,7 +538,7 @@
 	set_highmem_pages_init(bad_ppro);
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
-	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_data;
 	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
 
 	kclist_add(&kcore_mem, __va(0), max_low_pfn << PAGE_SHIFT); 
@@ -596,10 +555,6 @@
 		(unsigned long) (totalhigh_pages << (PAGE_SHIFT-10))
 	       );
 
-#ifdef CONFIG_X86_PAE
-	if (!cpu_has_pae)
-		panic("cannot execute a PAE-enabled kernel on a PAE-less CPU!");
-#endif
 	if (boot_cpu_data.wp_works_ok < 0)
 		test_wp_bit();
 
@@ -670,6 +625,46 @@
 {
 	unsigned long addr;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	/* PaX: limit KERNEL_CS to actual size */
+	{
+		unsigned long limit;
+		int cpu;
+		pgd_t *pgd;
+		pud_t *pud;
+		pmd_t *pmd;
+
+		limit = (unsigned long)&_etext >> PAGE_SHIFT;
+		for (cpu = 0; cpu < NR_CPUS; cpu++) {
+			cpu_gdt_table[cpu][GDT_ENTRY_KERNEL_CS].a = (cpu_gdt_table[cpu][GDT_ENTRY_KERNEL_CS].a & 0xFFFF0000UL) | (limit & 0x0FFFFUL);
+			cpu_gdt_table[cpu][GDT_ENTRY_KERNEL_CS].b = (cpu_gdt_table[cpu][GDT_ENTRY_KERNEL_CS].b & 0xFFF0FFFFUL) | (limit & 0xF0000UL);
+		}
+
+	/* PaX: make KERNEL_CS read-only */
+		for (addr = __KERNEL_TEXT_OFFSET; addr < (unsigned long)&_data; addr += PMD_SIZE) {
+			pgd = pgd_offset_k(addr);
+			pud = pud_offset(pgd, addr);
+			pmd = pmd_offset(pud, addr);
+			set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_GLOBAL));
+		}
+
+#ifdef CONFIG_X86_PAE
+		memcpy(kernexec_pm_dir, swapper_pm_dir, sizeof(kernexec_pm_dir));
+#else
+		memcpy(kernexec_pg_dir, swapper_pg_dir, sizeof(kernexec_pg_dir));
+#endif
+
+		for (addr = __KERNEL_TEXT_OFFSET; addr < (unsigned long)&_data; addr += PMD_SIZE) {
+			pgd = pgd_offset_k(addr);
+			pud = pud_offset(pgd, addr);
+			pmd = pmd_offset(pud, addr);
+			set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_RW));
+		}
+		flush_tlb_all();
+	}
+#endif
+
+	memset(__init_begin, 0, (unsigned long)&__init_end - (unsigned long)&__init_begin);
 	addr = (unsigned long)(&__init_begin);
 	for (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(addr));
diff -Nur linux-2.6.13.1.org/arch/i386/mm/mmap.c grsecurity226/arch/i386/mm/mmap.c
--- linux-2.6.13.1.org/arch/i386/mm/mmap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/mm/mmap.c	2005-08-30 01:12:54.000000000 +0200
@@ -40,6 +40,12 @@
 {
 	unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
 	unsigned long random_factor = 0;
+	unsigned long task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
 
 	if (current->flags & PF_RANDOMIZE)
 		random_factor = get_random_int() % (1024*1024);
@@ -49,7 +55,7 @@
 	else if (gap > MAX_GAP)
 		gap = MAX_GAP;
 
-	return PAGE_ALIGN(TASK_SIZE - gap - random_factor);
+	return PAGE_ALIGN(task_size - gap - random_factor);
 }
 
 /*
@@ -66,10 +72,22 @@
 			(current->personality & ADDR_COMPAT_LAYOUT) ||
 			current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base(mm);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -Nur linux-2.6.13.1.org/arch/i386/pci/common.c grsecurity226/arch/i386/pci/common.c
--- linux-2.6.13.1.org/arch/i386/pci/common.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/pci/common.c	2005-08-30 00:59:42.000000000 +0200
@@ -165,6 +165,7 @@
 	if ((pci_probe & PCI_BIOS_SORT) && !(pci_probe & PCI_NO_SORT))
 		pcibios_sort();
 #endif
+	pci_assign_unassigned_resources();
 	return 0;
 }
 
diff -Nur linux-2.6.13.1.org/arch/i386/pci/i386.c grsecurity226/arch/i386/pci/i386.c
--- linux-2.6.13.1.org/arch/i386/pci/i386.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/pci/i386.c	2005-08-30 00:59:43.000000000 +0200
@@ -170,26 +170,43 @@
 static int __init pcibios_assign_resources(void)
 {
 	struct pci_dev *dev = NULL;
-	struct resource *r, *pr;
+	int idx;
+	struct resource *r;
 
-	if (!(pci_probe & PCI_ASSIGN_ROMS)) {
-		/* Try to use BIOS settings for ROMs, otherwise let
-		   pci_assign_unassigned_resources() allocate the new
-		   addresses. */
-		for_each_pci_dev(dev) {
-			r = &dev->resource[PCI_ROM_RESOURCE];
-			if (!r->flags || !r->start)
+	for_each_pci_dev(dev) {
+		int class = dev->class >> 8;
+
+		/* Don't touch classless devices and host bridges */
+		if (!class || class == PCI_CLASS_BRIDGE_HOST)
+			continue;
+
+		for(idx=0; idx<6; idx++) {
+			r = &dev->resource[idx];
+
+			/*
+			 *  Don't touch IDE controllers and I/O ports of video cards!
+			 */
+			if ((class == PCI_CLASS_STORAGE_IDE && idx < 4) ||
+			    (class == PCI_CLASS_DISPLAY_VGA && (r->flags & IORESOURCE_IO)))
 				continue;
-			pr = pci_find_parent_resource(dev, r);
-			if (!pr || request_resource(pr, r) < 0) {
-				r->end -= r->start;
-				r->start = 0;
-			}
-		}
-	}
 
-	pci_assign_unassigned_resources();
+			/*
+			 *  We shall assign a new address to this resource, either because
+			 *  the BIOS forgot to do so or because we have decided the old
+			 *  address was unusable for some reason.
+			 */
+			if (!r->start && r->end)
+				pci_assign_resource(dev, idx);
+		}
 
+		if (pci_probe & PCI_ASSIGN_ROMS) {
+			r = &dev->resource[PCI_ROM_RESOURCE];
+			r->end -= r->start;
+			r->start = 0;
+			if (r->end)
+				pci_assign_resource(dev, PCI_ROM_RESOURCE);
+		}
+	}
 	return 0;
 }
 
diff -Nur linux-2.6.13.1.org/arch/i386/pci/pcbios.c grsecurity226/arch/i386/pci/pcbios.c
--- linux-2.6.13.1.org/arch/i386/pci/pcbios.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/pci/pcbios.c	2005-08-30 01:12:55.000000000 +0200
@@ -8,7 +8,6 @@
 #include "pci.h"
 #include "pci-functions.h"
 
-
 /* BIOS32 signature: "_32_" */
 #define BIOS32_SIGNATURE	(('_' << 0) + ('3' << 8) + ('2' << 16) + ('_' << 24))
 
diff -Nur linux-2.6.13.1.org/arch/i386/power/cpu.c grsecurity226/arch/i386/power/cpu.c
--- linux-2.6.13.1.org/arch/i386/power/cpu.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/i386/power/cpu.c	2005-08-30 01:12:57.000000000 +0200
@@ -81,10 +81,9 @@
 static void fix_processor_context(void)
 {
 	int cpu = smp_processor_id();
-	struct tss_struct * t = &per_cpu(init_tss, cpu);
+	struct tss_struct * t = init_tss + cpu;
 
 	set_tss_desc(cpu,t);	/* This just modifies memory; should not be necessary. But... This is necessary, because 386 hardware has concept of busy TSS or some similar stupidity. */
-        per_cpu(cpu_gdt_table, cpu)[GDT_ENTRY_TSS].b &= 0xfffffdff;
 
 	load_TR_desc();				/* This does ltr */
 	load_LDT(&current->active_mm->context);	/* This does lldt */
diff -Nur linux-2.6.13.1.org/arch/ia64/ia32/binfmt_elf32.c grsecurity226/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.6.13.1.org/arch/ia64/ia32/binfmt_elf32.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ia64/ia32/binfmt_elf32.c	2005-08-30 01:12:58.000000000 +0200
@@ -43,6 +43,17 @@
 
 #define elf_read_implies_exec(ex, have_pt_gnu_stack)	(!(have_pt_gnu_stack))
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	((tsk)->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		IA32_PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk)->personality == PER_LINUX32 ? 16 : 43 - IA32_PAGE_SHIFT)
+#define PAX_DELTA_EXEC_LSB(tsk)		IA32_PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((tsk)->personality == PER_LINUX32 ? 16 : 43 - IA32_PAGE_SHIFT)
+#define PAX_DELTA_STACK_LSB(tsk)	IA32_PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk)->personality == PER_LINUX32 ? 16 : 43 - IA32_PAGE_SHIFT)
+#endif
+
 /* Ugly but avoids duplication */
 #include "../../../fs/binfmt_elf.c"
 
diff -Nur linux-2.6.13.1.org/arch/ia64/ia32/ia32priv.h grsecurity226/arch/ia64/ia32/ia32priv.h
--- linux-2.6.13.1.org/arch/ia64/ia32/ia32priv.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ia64/ia32/ia32priv.h	2005-08-30 01:12:58.000000000 +0200
@@ -306,10 +306,17 @@
 #define ELF_ARCH	EM_386
 
 #define IA32_PAGE_OFFSET	0xc0000000
-#define IA32_STACK_TOP		IA32_PAGE_OFFSET
 #define IA32_GATE_OFFSET	IA32_PAGE_OFFSET
 #define IA32_GATE_END		IA32_PAGE_OFFSET + PAGE_SIZE
 
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __IA32_DELTA_STACK	(current->mm->delta_stack)
+#else
+#define __IA32_DELTA_STACK	0UL
+#endif
+
+#define IA32_STACK_TOP		(IA32_PAGE_OFFSET - __IA32_DELTA_STACK)
+
 /*
  * The system segments (GDT, TSS, LDT) have to be mapped below 4GB so the IA-32 engine can
  * access them.
diff -Nur linux-2.6.13.1.org/arch/ia64/kernel/ptrace.c grsecurity226/arch/ia64/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/ia64/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ia64/kernel/ptrace.c	2005-08-30 01:13:01.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/security.h>
 #include <linux/audit.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -1460,6 +1461,9 @@
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -Nur linux-2.6.13.1.org/arch/ia64/kernel/sys_ia64.c grsecurity226/arch/ia64/kernel/sys_ia64.c
--- linux-2.6.13.1.org/arch/ia64/kernel/sys_ia64.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ia64/kernel/sys_ia64.c	2005-09-05 18:41:54.000000000 +0200
@@ -38,6 +38,13 @@
 	if (REGION_NUMBER(addr) == REGION_HPAGE)
 		addr = 0;
 #endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((mm->pax_flags & MF_PAX_RANDMMAP) && addr && filp)
+		addr = mm->free_area_cache;
+	else
+#endif
+
 	if (!addr)
 		addr = mm->free_area_cache;
 
@@ -56,9 +63,9 @@
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
 		if (TASK_SIZE - len < addr || RGN_MAP_LIMIT - len < REGION_OFFSET(addr)) {
-			if (start_addr != TASK_UNMAPPED_BASE) {
+			if (start_addr != mm->mmap_base) {
 				/* Start a new search --- just in case we missed some holes.  */
-				addr = TASK_UNMAPPED_BASE;
+				addr = mm->mmap_base;
 				goto full_search;
 			}
 			return -ENOMEM;
diff -Nur linux-2.6.13.1.org/arch/ia64/mm/fault.c grsecurity226/arch/ia64/mm/fault.c
--- linux-2.6.13.1.org/arch/ia64/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ia64/mm/fault.c	2005-08-30 01:13:04.000000000 +0200
@@ -9,6 +9,7 @@
 #include <linux/mm.h>
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
+#include <linux/binfmts.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -36,6 +37,10 @@
 	if (address - vma->vm_start > current->signal->rlim[RLIMIT_STACK].rlim_cur
 	    || (((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->signal->rlim[RLIMIT_AS].rlim_cur))
 		return -ENOMEM;
+	if ((vma->vm_flags & VM_LOCKED) &&
+	    ((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) > current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur &&
+	    !capable(CAP_IPC_LOCK))
+		return -ENOMEM;
 	vma->vm_end += PAGE_SIZE;
 	vma->vm_mm->total_vm += grow;
 	if (vma->vm_flags & VM_LOCKED)
@@ -76,6 +81,24 @@
 	return pte_present(pte);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 8; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void
 ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *regs)
 {
@@ -138,9 +161,23 @@
 		| (((isr >> IA64_ISR_W_BIT) & 1UL) << VM_WRITE_BIT)
 		| (((isr >> IA64_ISR_R_BIT) & 1UL) << VM_READ_BIT));
 
-	if ((vma->vm_flags & mask) != mask)
+	if ((vma->vm_flags & mask) != mask) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(vma->vm_flags & VM_EXEC) && (mask & VM_EXEC)) {
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->cr_iip)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			pax_report_fault(regs, (void*)regs->cr_iip, (void*)regs->r12);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
 
+	}
+
   survive:
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -Nur linux-2.6.13.1.org/arch/ia64/mm/init.c grsecurity226/arch/ia64/mm/init.c
--- linux-2.6.13.1.org/arch/ia64/mm/init.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ia64/mm/init.c	2005-08-30 01:13:04.000000000 +0200
@@ -20,8 +20,8 @@
 #include <linux/swap.h>
 #include <linux/proc_fs.h>
 #include <linux/bitops.h>
+#include <linux/a.out.h>
 
-#include <asm/a.out.h>
 #include <asm/dma.h>
 #include <asm/ia32.h>
 #include <asm/io.h>
diff -Nur linux-2.6.13.1.org/arch/mips/kernel/binfmt_elfn32.c grsecurity226/arch/mips/kernel/binfmt_elfn32.c
--- linux-2.6.13.1.org/arch/mips/kernel/binfmt_elfn32.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/mips/kernel/binfmt_elfn32.c	2005-08-30 01:13:11.000000000 +0200
@@ -50,6 +50,17 @@
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/arch/mips/kernel/binfmt_elfo32.c grsecurity226/arch/mips/kernel/binfmt_elfo32.c
--- linux-2.6.13.1.org/arch/mips/kernel/binfmt_elfo32.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/mips/kernel/binfmt_elfo32.c	2005-08-30 01:13:11.000000000 +0200
@@ -52,6 +52,17 @@
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/arch/mips/kernel/syscall.c grsecurity226/arch/mips/kernel/syscall.c
--- linux-2.6.13.1.org/arch/mips/kernel/syscall.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/mips/kernel/syscall.c	2005-09-05 18:41:56.000000000 +0200
@@ -84,6 +84,11 @@
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -94,7 +99,7 @@
 		    (!vmm || addr + len <= vmm->vm_start))
 			return addr;
 	}
-	addr = TASK_UNMAPPED_BASE;
+	addr = current->mm->mmap_base;
 	if (do_color_align)
 		addr = COLOUR_ALIGN(addr, pgoff);
 	else
diff -Nur linux-2.6.13.1.org/arch/mips/mm/fault.c grsecurity226/arch/mips/mm/fault.c
--- linux-2.6.13.1.org/arch/mips/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/mips/mm/fault.c	2005-08-30 01:13:13.000000000 +0200
@@ -26,6 +26,24 @@
 #include <asm/uaccess.h>
 #include <asm/ptrace.h>
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff -Nur linux-2.6.13.1.org/arch/parisc/kernel/ptrace.c grsecurity226/arch/parisc/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/parisc/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/parisc/kernel/ptrace.c	2005-08-30 01:13:16.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/security.h>
 #include <linux/compat.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -115,6 +116,9 @@
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -Nur linux-2.6.13.1.org/arch/parisc/kernel/sys_parisc.c grsecurity226/arch/parisc/kernel/sys_parisc.c
--- linux-2.6.13.1.org/arch/parisc/kernel/sys_parisc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/parisc/kernel/sys_parisc.c	2005-09-05 18:41:58.000000000 +0200
@@ -105,7 +105,7 @@
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = current->mm->mmap_base;
 
 	if (filp) {
 		addr = get_shared_area(filp->f_mapping, addr, len, pgoff);
@@ -123,6 +123,7 @@
 {
 	struct file * file = NULL;
 	unsigned long error = -EBADF;
+
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
 		if (!file)
diff -Nur linux-2.6.13.1.org/arch/parisc/kernel/traps.c grsecurity226/arch/parisc/kernel/traps.c
--- linux-2.6.13.1.org/arch/parisc/kernel/traps.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/parisc/kernel/traps.c	2005-08-30 01:13:16.000000000 +0200
@@ -687,9 +687,7 @@
 
 			down_read(&current->mm->mmap_sem);
 			vma = find_vma(current->mm,regs->iaoq[0]);
-			if (vma && (regs->iaoq[0] >= vma->vm_start)
-				&& (vma->vm_flags & VM_EXEC)) {
-
+			if (vma && (regs->iaoq[0] >= vma->vm_start)) {
 				fault_address = regs->iaoq[0];
 				fault_space = regs->iasq[0];
 
diff -Nur linux-2.6.13.1.org/arch/parisc/mm/fault.c grsecurity226/arch/parisc/mm/fault.c
--- linux-2.6.13.1.org/arch/parisc/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/parisc/mm/fault.c	2005-08-30 01:13:18.000000000 +0200
@@ -16,6 +16,8 @@
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/unistd.h>
+#include <linux/binfmts.h>
 
 #include <asm/uaccess.h>
 #include <asm/traps.h>
@@ -57,7 +59,7 @@
 static unsigned long
 parisc_acctyp(unsigned long code, unsigned int inst)
 {
-	if (code == 6 || code == 16)
+	if (code == 6 || code == 7 || code == 16)
 	    return VM_EXEC;
 
 	switch (inst & 0xf0000000) {
@@ -143,6 +145,117 @@
 			}
 #endif
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (instruction_pointer(regs) = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when rt_sigreturn trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int bl, depwi;
+
+		err = get_user(bl, (unsigned int*)instruction_pointer(regs));
+		err |= get_user(depwi, (unsigned int*)(instruction_pointer(regs)+4));
+
+		if (err)
+			break;
+
+		if (bl == 0xEA9F1FDDU && depwi == 0xD6801C1EU) {
+			unsigned int ldw, bv, ldw2, addr = instruction_pointer(regs)-12;
+
+			err = get_user(ldw, (unsigned int*)addr);
+			err |= get_user(bv, (unsigned int*)(addr+4));
+			err |= get_user(ldw2, (unsigned int*)(addr+8));
+
+			if (err)
+				break;
+
+			if (ldw == 0x0E801096U &&
+			    bv == 0xEAC0C000U &&
+			    ldw2 == 0x0E881095U)
+			{
+				unsigned int resolver, map;
+
+				err = get_user(resolver, (unsigned int*)(instruction_pointer(regs)+8));
+				err |= get_user(map, (unsigned int*)(instruction_pointer(regs)+12));
+				if (err)
+					break;
+
+				regs->gr[20] = instruction_pointer(regs)+8;
+				regs->gr[21] = map;
+				regs->gr[22] = resolver;
+				regs->iaoq[0] = resolver | 3UL;
+				regs->iaoq[1] = regs->iaoq[0] + 4;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+
+#ifndef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int ldi1, ldi2, bel, nop;
+
+		err = get_user(ldi1, (unsigned int *)instruction_pointer(regs));
+		err |= get_user(ldi2, (unsigned int *)(instruction_pointer(regs)+4));
+		err |= get_user(bel, (unsigned int *)(instruction_pointer(regs)+8));
+		err |= get_user(nop, (unsigned int *)(instruction_pointer(regs)+12));
+
+		if (err)
+			break;
+
+		if ((ldi1 == 0x34190000U || ldi1 == 0x34190002U) &&
+		    ldi2 == 0x3414015AU &&
+		    bel == 0xE4008200U &&
+		    nop == 0x08000240U)
+		{
+			regs->gr[25] = (ldi1 & 2) >> 1;
+			regs->gr[20] = __NR_rt_sigreturn;
+			regs->gr[31] = regs->iaoq[1] + 16;
+			regs->sr[0] = regs->iasq[1];
+			regs->iaoq[0] = 0x100UL;
+			regs->iaoq[1] = regs->iaoq[0] + 4;
+			regs->iasq[0] = regs->sr[2];
+			regs->iasq[1] = regs->sr[2];
+			return 2;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void do_page_fault(struct pt_regs *regs, unsigned long code,
 			      unsigned long address)
 {
@@ -168,8 +281,33 @@
 
 	acc_type = parisc_acctyp(code,regs->iir);
 
-	if ((vma->vm_flags & acc_type) != acc_type)
+	if ((vma->vm_flags & acc_type) != acc_type) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (acc_type & VM_EXEC) &&
+		    (address & ~3UL) == instruction_pointer(regs))
+		{
+			up_read(&mm->mmap_sem);
+			switch(pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 3:
+				return;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			case 2:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)instruction_pointer(regs), (void*)regs->gr[30]);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
+	}
 
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -Nur linux-2.6.13.1.org/arch/ppc/kernel/ptrace.c grsecurity226/arch/ppc/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/ppc/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ppc/kernel/ptrace.c	2005-08-30 01:13:20.000000000 +0200
@@ -30,6 +30,7 @@
 #include <linux/seccomp.h>
 #include <linux/audit.h>
 #include <linux/module.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -271,6 +272,9 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -Nur linux-2.6.13.1.org/arch/ppc/mm/fault.c grsecurity226/arch/ppc/mm/fault.c
--- linux-2.6.13.1.org/arch/ppc/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ppc/mm/fault.c	2005-08-30 01:13:23.000000000 +0200
@@ -28,6 +28,11 @@
 #include <linux/interrupt.h>
 #include <linux/highmem.h>
 #include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
+#include <linux/unistd.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -51,6 +56,348 @@
 unsigned long pte_errors;	/* updated by do_page_fault() */
 unsigned int probingmem;
 
+#ifdef CONFIG_PAX_EMUSIGRT
+void pax_syscall_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_syscall = 0UL;
+}
+
+static struct page* pax_syscall_nopage(struct vm_area_struct *vma, unsigned long address, int *type)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return NOPAGE_OOM;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x44000002U; /* sc */
+	__flush_dcache_icache(kaddr);
+	kunmap(page);
+	if (type)
+		*type = VM_FAULT_MAJOR;
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	close:		pax_syscall_close,
+	nopage:		pax_syscall_nopage,
+};
+
+static void pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+	insert_vm_struct(current->mm, vma);
+	++current->mm->total_vm;
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched GOT trampoline was detected
+ *         3 when patched PLT trampoline was detected
+ *         4 when unpatched PLT trampoline was detected
+ *         5 when sigreturn trampoline was detected
+ *         7 when rt_sigreturn trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#if defined(CONFIG_PAX_EMUPLT) || defined(CONFIG_PAX_EMUSIGRT)
+	int err;
+#endif
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched GOT emulation */
+		unsigned int blrl;
+
+		err = get_user(blrl, (unsigned int*)regs->nip);
+
+		if (!err && blrl == 0x4E800021U) {
+			unsigned long temp = regs->nip;
+
+			regs->nip = regs->link & 0xFFFFFFFCUL;
+			regs->link = temp + 4UL;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int b;
+
+		err = get_user(b, (unsigned int *)regs->nip);
+
+		if (!err && (b & 0xFC000003U) == 0x48000000U) {
+			regs->nip += (((b | 0xFC000000UL) ^ 0x02000000UL) + 0x02000000UL);
+			return 3;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation #1 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(rlwinm, (unsigned int*)addr);
+			err |= get_user(add, (unsigned int*)(addr+4));
+			err |= get_user(li2, (unsigned int*)(addr+8));
+			err |= get_user(addis2, (unsigned int*)(addr+12));
+			err |= get_user(mtctr, (unsigned int*)(addr+16));
+			err |= get_user(li3, (unsigned int*)(addr+20));
+			err |= get_user(addis3, (unsigned int*)(addr+24));
+			err |= get_user(bctr, (unsigned int*)(addr+28));
+
+			if (err)
+				break;
+
+			if (rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+
+#if 0
+	do { /* PaX: unpatched PLT emulation #2 */
+		unsigned int lis, lwzu, b, bctr;
+
+		err = get_user(lis, (unsigned int *)regs->nip);
+		err |= get_user(lwzu, (unsigned int *)(regs->nip+4));
+		err |= get_user(b, (unsigned int *)(regs->nip+8));
+		err |= get_user(bctr, (unsigned int *)(regs->nip+12));
+
+		if (err)
+			break;
+
+		if ((lis & 0xFFFF0000U) == 0x39600000U &&
+		    (lwzu & 0xU) == 0xU &&
+		    (b & 0xFC000003U) == 0x48000000U &&
+		    bctr == 0x4E800420U)
+		{
+			unsigned int addis, addi, rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 12 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(addi, (unsigned int*)(addr+4));
+			err |= get_user(rlwinm, (unsigned int*)(addr+8));
+			err |= get_user(add, (unsigned int*)(addr+12));
+			err |= get_user(li2, (unsigned int*)(addr+16));
+			err |= get_user(addis2, (unsigned int*)(addr+20));
+			err |= get_user(mtctr, (unsigned int*)(addr+24));
+			err |= get_user(li3, (unsigned int*)(addr+28));
+			err |= get_user(addis3, (unsigned int*)(addr+32));
+			err |= get_user(bctr, (unsigned int*)(addr+36));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (addi & 0xFFFF0000U) == 0x396B0000U &&
+			    rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+	do { /* PaX: unpatched PLT emulation #3 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int addis, lwz, mtctr, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(lwz, (unsigned int*)(addr+4));
+			err |= get_user(mtctr, (unsigned int*)(addr+8));
+			err |= get_user(bctr, (unsigned int*)(addr+12));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (lwz & 0xFFFF0000U) == 0x816B0000U &&
+			    mtctr == 0x7D6903A6U &&
+			    bctr == 0x4E800420U)
+			{
+				unsigned int r11;
+
+				addr = (addis << 16) + (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				addr += (((lwz | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+
+				err = get_user(r11, (unsigned int*)addr);
+				if (err)
+					break;
+
+				regs->gpr[PT_R11] = r11;
+				regs->ctr = r11;
+				regs->nip = r11;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	do { /* PaX: sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned long call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			pax_insert_vma(vma, call_syscall);
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+emulate:
+			regs->gpr[PT_R0] = __NR_sigreturn;
+			regs->nip = call_syscall;
+			return 5;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_rt_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned int call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto rt_emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto rt_emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			pax_insert_vma(vma, call_syscall);
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+rt_emulate:
+			regs->gpr[PT_R0] = __NR_rt_sigreturn;
+			regs->nip = call_syscall;
+			return 6;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * Check whether the instruction at regs->nip is a store using
  * an update addressing form which will update r1.
@@ -111,7 +458,7 @@
 	 * indicate errors in DSISR but can validly be set in SRR1.
 	 */
 	if (TRAP(regs) == 0x400)
-		error_code &= 0x48200000;
+		error_code &= 0x58200000;
 	else
 		is_write = error_code & 0x02000000;
 #endif /* CONFIG_4xx || CONFIG_BOOKE */
@@ -205,15 +552,14 @@
 	} else if (TRAP(regs) == 0x400) {
 		pte_t *ptep;
 
-#if 0
+#if 1
 		/* It would be nice to actually enforce the VM execute
 		   permission on CPUs which can do so, but far too
 		   much stuff in userspace doesn't get the permissions
 		   right, so we let any page be executed for now. */
 		if (! (vma->vm_flags & VM_EXEC))
 			goto bad_area;
-#endif
-
+#else
 		/* Since 4xx/Book-E supports per-page execute permission,
 		 * we lazily flush dcache to icache. */
 		ptep = NULL;
@@ -233,6 +579,7 @@
 		if (ptep != NULL)
 			pte_unmap(ptep);
 #endif
+#endif
 	/* a read */
 	} else {
 		/* protection fault */
@@ -278,6 +625,33 @@
 
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+			if ((TRAP(regs) == 0x400) && (regs->nip == address)) {
+				switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+				case 2:
+				case 3:
+				case 4:
+					return 0;
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+				case 5:
+				case 6:
+					return 0;
+#endif
+
+				}
+
+				pax_report_fault(regs, (void*)regs->nip, (void*)regs->gpr[1]);
+				do_exit(SIGKILL);
+			}
+		}
+#endif
+
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
 		info.si_code = code;
diff -Nur linux-2.6.13.1.org/arch/ppc64/mm/fault.c grsecurity226/arch/ppc64/mm/fault.c
--- linux-2.6.13.1.org/arch/ppc64/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ppc64/mm/fault.c	2005-08-30 01:13:25.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp_lock.h>
 #include <linux/module.h>
+#include <linux/binfmts.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -76,6 +77,39 @@
 	return 0;
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#if defined(CONFIG_PAX_EMUPLT) || defined(CONFIG_PAX_EMUSIGRT)
+	int err;
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * The error_code parameter is
  *  - DSISR for a non-SLB data access fault,
@@ -247,6 +281,19 @@
 bad_area_nosemaphore:
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+			if ((trap == 0x400) && (error_code & DSISR_PROTFAULT)) {
+				switch (pax_handle_fetch_fault(regs)) {
+				}
+
+				pax_report_fault(regs, (void*)regs->nip, (void*)regs->gpr[1]);
+				do_exit(SIGKILL);
+			}
+		}
+#endif
+
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
 		info.si_code = code;
diff -Nur linux-2.6.13.1.org/arch/ppc64/mm/mmap.c grsecurity226/arch/ppc64/mm/mmap.c
--- linux-2.6.13.1.org/arch/ppc64/mm/mmap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/ppc64/mm/mmap.c	2005-08-30 01:13:25.000000000 +0200
@@ -76,10 +76,22 @@
 	 */
 	if (mmap_is_legacy()) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base();
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -Nur linux-2.6.13.1.org/arch/sparc/Makefile grsecurity226/arch/sparc/Makefile
--- linux-2.6.13.1.org/arch/sparc/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc/Makefile	2005-08-30 01:13:30.000000000 +0200
@@ -34,7 +34,7 @@
 # Renaming is done to avoid confusing pattern matching rules in 2.5.45 (multy-)
 INIT_Y		:= $(patsubst %/, %/built-in.o, $(init-y))
 CORE_Y		:= $(core-y)
-CORE_Y		+= kernel/ mm/ fs/ ipc/ security/ crypto/
+CORE_Y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ grsecurity/
 CORE_Y		:= $(patsubst %/, %/built-in.o, $(CORE_Y))
 DRIVERS_Y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
 NET_Y		:= $(patsubst %/, %/built-in.o, $(net-y))
diff -Nur linux-2.6.13.1.org/arch/sparc/kernel/ptrace.c grsecurity226/arch/sparc/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/sparc/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc/kernel/ptrace.c	2005-08-30 01:13:32.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/smp_lock.h>
 #include <linux/security.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -323,6 +324,11 @@
 		goto out;
 	}
 
+	if (gr_handle_ptrace(child, request)) {
+		pt_error_return(regs, EPERM);
+		goto out_tsk;
+	}
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -Nur linux-2.6.13.1.org/arch/sparc/kernel/sys_sparc.c grsecurity226/arch/sparc/kernel/sys_sparc.c
--- linux-2.6.13.1.org/arch/sparc/kernel/sys_sparc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc/kernel/sys_sparc.c	2005-09-05 18:42:00.000000000 +0200
@@ -56,7 +56,7 @@
 	if (ARCH_SUN4C_SUN4 && len > 0x20000000)
 		return -ENOMEM;
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = current->mm->mmap_base;
 
 	if (flags & MAP_SHARED)
 		addr = COLOUR_ALIGN(addr);
diff -Nur linux-2.6.13.1.org/arch/sparc/mm/fault.c grsecurity226/arch/sparc/mm/fault.c
--- linux-2.6.13.1.org/arch/sparc/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc/mm/fault.c	2005-08-30 01:13:35.000000000 +0200
@@ -21,6 +21,10 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
 
 #include <asm/system.h>
 #include <asm/segment.h>
@@ -220,6 +224,241 @@
 	return safe_compute_effective_address(regs, insn);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_emuplt_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static struct page* pax_emuplt_nopage(struct vm_area_struct *vma, unsigned long address, int *type)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return NOPAGE_OOM;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(page);
+	kunmap(page);
+	if (type)
+		*type = VM_FAULT_MAJOR;
+
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	close:		pax_emuplt_close,
+	nopage:		pax_emuplt_nopage,
+};
+
+static void pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+	insert_vm_struct(current->mm, vma);
+	++current->mm->total_vm;
+}
+
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int*)regs->pc);
+		err |= get_user(sethi2, (unsigned int*)(regs->pc+4));
+		err |= get_user(jmpl, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned int addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int*)regs->pc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned int addr;
+
+			addr = regs->pc + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->pc);
+		err |= get_user(jmpl, (unsigned int*)(regs->pc+4));
+		err |= get_user(nop, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->pc);
+		err |= get_user(ba, (unsigned int*)(regs->pc+4));
+		err |= get_user(nop, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr, save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->pc + 4 + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			else
+				addr = regs->pc + 4 + ((((ba | 0xFFF80000U) ^ 0x00040000U) + 0x00040000U) << 2);
+
+			err = get_user(save, (unsigned int*)addr);
+			err |= get_user(call, (unsigned int*)(addr+4));
+			err |= get_user(nop, (unsigned int*)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				pax_insert_vma(vma, call_dl_resolve);
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->pc = call_dl_resolve;
+				regs->npc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int*)(regs->pc-4));
+		err |= get_user(call, (unsigned int*)regs->pc);
+		err |= get_user(nop, (unsigned int*)(regs->pc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int dl_resolve = regs->pc + ((((call | 0xC0000000U) ^ 0x20000000U) + 0x20000000U) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->pc;
+			regs->pc = dl_resolve;
+			regs->npc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 			       unsigned long address)
 {
@@ -283,6 +522,24 @@
 		if(!(vma->vm_flags & VM_WRITE))
 			goto bad_area;
 	} else {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && text_fault && !(vma->vm_flags & VM_EXEC)) {
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->pc, (void*)regs->u_regs[UREG_FP]);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		/* Allow reads even for write-only mappings */
 		if(!(vma->vm_flags & (VM_READ | VM_EXEC)))
 			goto bad_area;
diff -Nur linux-2.6.13.1.org/arch/sparc/mm/init.c grsecurity226/arch/sparc/mm/init.c
--- linux-2.6.13.1.org/arch/sparc/mm/init.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc/mm/init.c	2005-08-30 01:13:35.000000000 +0200
@@ -334,17 +334,17 @@
 
 	/* Initialize the protection map with non-constant, MMU dependent values. */
 	protection_map[0] = PAGE_NONE;
-	protection_map[1] = PAGE_READONLY;
-	protection_map[2] = PAGE_COPY;
-	protection_map[3] = PAGE_COPY;
+	protection_map[1] = PAGE_READONLY_NOEXEC;
+	protection_map[2] = PAGE_COPY_NOEXEC;
+	protection_map[3] = PAGE_COPY_NOEXEC;
 	protection_map[4] = PAGE_READONLY;
 	protection_map[5] = PAGE_READONLY;
 	protection_map[6] = PAGE_COPY;
 	protection_map[7] = PAGE_COPY;
 	protection_map[8] = PAGE_NONE;
-	protection_map[9] = PAGE_READONLY;
-	protection_map[10] = PAGE_SHARED;
-	protection_map[11] = PAGE_SHARED;
+	protection_map[9] = PAGE_READONLY_NOEXEC;
+	protection_map[10] = PAGE_SHARED_NOEXEC;
+	protection_map[11] = PAGE_SHARED_NOEXEC;
 	protection_map[12] = PAGE_READONLY;
 	protection_map[13] = PAGE_READONLY;
 	protection_map[14] = PAGE_SHARED;
diff -Nur linux-2.6.13.1.org/arch/sparc/mm/srmmu.c grsecurity226/arch/sparc/mm/srmmu.c
--- linux-2.6.13.1.org/arch/sparc/mm/srmmu.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc/mm/srmmu.c	2005-08-30 01:13:35.000000000 +0200
@@ -2148,6 +2148,13 @@
 	BTFIXUPSET_INT(page_shared, pgprot_val(SRMMU_PAGE_SHARED));
 	BTFIXUPSET_INT(page_copy, pgprot_val(SRMMU_PAGE_COPY));
 	BTFIXUPSET_INT(page_readonly, pgprot_val(SRMMU_PAGE_RDONLY));
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	BTFIXUPSET_INT(page_shared_noexec, pgprot_val(SRMMU_PAGE_SHARED_NOEXEC));
+	BTFIXUPSET_INT(page_copy_noexec, pgprot_val(SRMMU_PAGE_COPY_NOEXEC));
+	BTFIXUPSET_INT(page_readonly_noexec, pgprot_val(SRMMU_PAGE_RDONLY_NOEXEC));
+#endif
+
 	BTFIXUPSET_INT(page_kernel, pgprot_val(SRMMU_PAGE_KERNEL));
 	page_kernel = pgprot_val(SRMMU_PAGE_KERNEL);
 	pg_iobits = SRMMU_VALID | SRMMU_WRITE | SRMMU_REF;
diff -Nur linux-2.6.13.1.org/arch/sparc64/kernel/ptrace.c grsecurity226/arch/sparc64/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/sparc64/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc64/kernel/ptrace.c	2005-08-30 01:13:38.000000000 +0200
@@ -22,6 +22,7 @@
 #include <linux/seccomp.h>
 #include <linux/audit.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <asm/asi.h>
 #include <asm/pgtable.h>
@@ -225,6 +226,11 @@
 		goto out;
 	}
 
+	if (gr_handle_ptrace(child, (long)request)) {
+		pt_error_return(regs, EPERM);
+		goto out_tsk;
+	}
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -Nur linux-2.6.13.1.org/arch/sparc64/kernel/sys_sparc.c grsecurity226/arch/sparc64/kernel/sys_sparc.c
--- linux-2.6.13.1.org/arch/sparc64/kernel/sys_sparc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc64/kernel/sys_sparc.c	2005-09-05 18:42:02.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/arch/sparc64/kernel/sys_sparc.c
  *
  * This file contains various random system calls that
@@ -72,6 +72,10 @@
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -86,7 +90,7 @@
 
 	if (len <= mm->cached_hole_size) {
 	        mm->cached_hole_size = 0;
-		mm->free_area_cache = TASK_UNMAPPED_BASE;
+		mm->free_area_cache = mm->mmap_base;
 	}
 	start_addr = addr = mm->free_area_cache;
 
@@ -105,8 +109,8 @@
 			vma = find_vma(mm, PAGE_OFFSET);
 		}
 		if (task_size < addr) {
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
diff -Nur linux-2.6.13.1.org/arch/sparc64/mm/fault.c grsecurity226/arch/sparc64/mm/fault.c
--- linux-2.6.13.1.org/arch/sparc64/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/sparc64/mm/fault.c	2005-08-30 01:13:39.000000000 +0200
@@ -18,6 +18,10 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/binfmts.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -304,6 +308,358 @@
 	unhandled_fault (address, current, regs);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_EMUPLT
+static void pax_emuplt_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static struct page* pax_emuplt_nopage(struct vm_area_struct *vma, unsigned long address, int *type)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return NOPAGE_OOM;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(page);
+	kunmap(page);
+	if (type)
+		*type = VM_FAULT_MAJOR;
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	close:		pax_emuplt_close,
+	nopage:		pax_emuplt_nopage,
+};
+
+static void pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+	insert_vm_struct(current->mm, vma);
+	++current->mm->total_vm;
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->tpc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int*)regs->tpc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned long addr;
+
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #4 */
+		unsigned int mov1, call, mov2;
+
+		err = get_user(mov1, (unsigned int*)regs->tpc);
+		err |= get_user(call, (unsigned int*)(regs->tpc+4));
+		err |= get_user(mov2, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if (mov1 == 0x8210000FU &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    mov2 == 0x9E100001U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = regs->u_regs[UREG_RETPC];
+			addr = regs->tpc + 4 + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #5 */
+		unsigned int sethi1, sethi2, or1, or2, sllx, jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(or1, (unsigned int*)(regs->tpc+8));
+		err |= get_user(or2, (unsigned int*)(regs->tpc+12));
+		err |= get_user(sllx, (unsigned int*)(regs->tpc+16));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+20));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+24));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    (or1 & 0xFFFFE000U) == 0x82106000U &&
+		    (or2 & 0xFFFFE000U) == 0x8A116000U &&
+		    sllx == 0x83287020 &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = ((sethi1 & 0x003FFFFFU) << 10) | (or1 & 0x000003FFU);
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or2 & 0x000003FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #6 */
+		unsigned int sethi1, sethi2, sllx, or,  jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(sllx, (unsigned int*)(regs->tpc+8));
+		err |= get_user(or, (unsigned int*)(regs->tpc+12));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+16));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+20));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    sllx == 0x83287020 &&
+		    (or & 0xFFFFE000U) == 0x8A116000U &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi1 & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or & 0x3FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #7 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(ba, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (ba & 0xFFF00000U) == 0x30600000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(ba, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+			unsigned int save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			else
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			err = get_user(save, (unsigned int*)addr);
+			err |= get_user(call, (unsigned int*)(addr+4));
+			err |= get_user(nop, (unsigned int*)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				pax_insert_vma(vma, call_dl_resolve);
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->tpc = call_dl_resolve;
+				regs->tnpc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int*)(regs->tpc-4));
+		err |= get_user(call, (unsigned int*)regs->tpc);
+		err |= get_user(nop, (unsigned int*)(regs->tpc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long dl_resolve = regs->tpc + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->tpc;
+			regs->tpc = dl_resolve;
+			regs->tnpc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc64_fault(struct pt_regs *regs)
 {
 	struct mm_struct *mm = current->mm;
@@ -346,8 +702,10 @@
 		goto intr_or_no_mm;
 
 	if (test_thread_flag(TIF_32BIT)) {
-		if (!(regs->tstate & TSTATE_PRIV))
+		if (!(regs->tstate & TSTATE_PRIV)) {
 			regs->tpc &= 0xffffffff;
+			regs->tnpc &= 0xffffffff;
+		}
 		address &= 0xffffffff;
 	}
 
@@ -364,6 +722,29 @@
 	if (!vma)
 		goto bad_area;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	/* PaX: detect ITLB misses on non-exec pages */
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && vma->vm_start <= address &&
+	    !(vma->vm_flags & VM_EXEC) && (fault_code & FAULT_CODE_ITLB))
+	{
+		if (address != regs->tpc)
+			goto good_area;
+
+		up_read(&mm->mmap_sem);
+		switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+		case 2:
+		case 3:
+			goto fault_done;
+#endif
+
+		}
+		pax_report_fault(regs, (void*)regs->tpc, (void*)(regs->u_regs[UREG_FP] + STACK_BIAS));
+		do_exit(SIGKILL);
+	}
+#endif
+
 	/* Pure DTLB misses do not tell us whether the fault causing
 	 * load/store/atomic was a write or not, it only says that there
 	 * was no match.  So in such a case we (carefully) read the
diff -Nur linux-2.6.13.1.org/arch/x86_64/boot/compressed/head.S grsecurity226/arch/x86_64/boot/compressed/head.S
--- linux-2.6.13.1.org/arch/x86_64/boot/compressed/head.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/x86_64/boot/compressed/head.S	2005-09-05 18:42:04.000000000 +0200
@@ -41,11 +41,13 @@
 	movl %eax,%gs
 
 	lss stack_start,%esp
+	movl 0x000000,%ecx
 	xorl %eax,%eax
 1:	incl %eax		# check that A20 really IS enabled
 	movl %eax,0x000000	# loop forever if it isn't
 	cmpl %eax,0x100000
 	je 1b
+	movl %ecx,0x000000
 
 /*
  * Initialize eflags.  Some BIOS's leave bits like NT set.  This would
diff -Nur linux-2.6.13.1.org/arch/x86_64/ia32/ia32_binfmt.c grsecurity226/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.6.13.1.org/arch/x86_64/ia32/ia32_binfmt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/x86_64/ia32/ia32_binfmt.c	2005-08-30 01:13:43.000000000 +0200
@@ -186,6 +186,17 @@
 //#include <asm/ia32.h>
 #include <linux/elf.h>
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(test_thread_flag(TIF_IA32) ? 0x08048000UL : 0x400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(test_thread_flag(TIF_IA32) ? 16 : 24)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(test_thread_flag(TIF_IA32) ? 16 : 24)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(test_thread_flag(TIF_IA32) ? 16 : 24)
+#endif
+
 typedef struct user_i387_ia32_struct elf_fpregset_t;
 typedef struct user32_fxsr_struct elf_fpxregset_t;
 
diff -Nur linux-2.6.13.1.org/arch/x86_64/ia32/sys_ia32.c grsecurity226/arch/x86_64/ia32/sys_ia32.c
--- linux-2.6.13.1.org/arch/x86_64/ia32/sys_ia32.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/x86_64/ia32/sys_ia32.c	2005-08-30 00:59:59.000000000 +0200
@@ -1043,7 +1043,7 @@
 
 static int __init ia32_init (void)
 {
-	printk("IA32 emulation $Id$\n");  
+	printk("IA32 emulation $Id$\n");  
 	return 0;
 }
 
diff -Nur linux-2.6.13.1.org/arch/x86_64/kernel/ptrace.c grsecurity226/arch/x86_64/kernel/ptrace.c
--- linux-2.6.13.1.org/arch/x86_64/kernel/ptrace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/x86_64/kernel/ptrace.c	2005-08-30 01:13:45.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/audit.h>
 #include <linux/seccomp.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -347,6 +348,9 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        if (gr_handle_ptrace(child, request))
+                goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -Nur linux-2.6.13.1.org/arch/x86_64/kernel/setup64.c grsecurity226/arch/x86_64/kernel/setup64.c
--- linux-2.6.13.1.org/arch/x86_64/kernel/setup64.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/x86_64/kernel/setup64.c	2005-09-05 18:42:06.000000000 +0200
@@ -37,7 +37,6 @@
 char boot_cpu_stack[IRQSTACKSIZE] __attribute__((section(".bss.page_aligned")));
 
 unsigned long __supported_pte_mask = ~0UL;
-static int do_not_nx __initdata = 0;
 
 /* noexec=on|off
 Control non executable mappings for 64bit processes.
@@ -49,16 +48,14 @@
 {
 	if (!strncmp(str, "on", 2)) {
                 __supported_pte_mask |= _PAGE_NX; 
- 		do_not_nx = 0; 
 	} else if (!strncmp(str, "off", 3)) {
-		do_not_nx = 1;
 		__supported_pte_mask &= ~_PAGE_NX;
         }
 	return 0;
 } 
 __setup("noexec=", nonx_setup);	/* parsed early actually */
 
-int force_personality32 = READ_IMPLIES_EXEC;
+int force_personality32;
 
 /* noexec32=on|off
 Control non executable heap for 32bit processes.
@@ -170,7 +167,7 @@
 	unsigned long efer;
 
 	rdmsrl(MSR_EFER, efer); 
-        if (!(efer & EFER_NX) || do_not_nx) { 
+        if (!(efer & EFER_NX)) { 
                 __supported_pte_mask &= ~_PAGE_NX; 
         }       
 }
diff -Nur linux-2.6.13.1.org/arch/x86_64/kernel/sys_x86_64.c grsecurity226/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.6.13.1.org/arch/x86_64/kernel/sys_x86_64.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/x86_64/kernel/sys_x86_64.c	2005-09-05 18:42:06.000000000 +0200
@@ -65,8 +65,8 @@
 	return error;
 }
 
-static void find_start_end(unsigned long flags, unsigned long *begin,
-			   unsigned long *end)
+static void find_start_end(struct mm_struct *mm, unsigned long flags,
+			   unsigned long *begin, unsigned long *end)
 {
 	if (!test_thread_flag(TIF_IA32) && (flags & MAP_32BIT)) {
 		/* This is usually used needed to map code in small
@@ -78,8 +78,14 @@
 		   of playground for now. -AK */ 
 		*begin = 0x40000000; 
 		*end = 0x80000000;		
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			begin += mm->delta_mmap & 0x0FFFFFFFU;
+#endif
+
 	} else {
-		*begin = TASK_UNMAPPED_BASE;
+		*begin = mm->mmap_base;
 		*end = TASK_SIZE; 
 	}
 } 
@@ -93,11 +99,15 @@
 	unsigned long start_addr;
 	unsigned long begin, end;
 	
-	find_start_end(flags, &begin, &end); 
+	find_start_end(mm, flags, &begin, &end); 
 
 	if (len > end)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
diff -Nur linux-2.6.13.1.org/arch/x86_64/mm/fault.c grsecurity226/arch/x86_64/mm/fault.c
--- linux-2.6.13.1.org/arch/x86_64/mm/fault.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/arch/x86_64/mm/fault.c	2005-08-30 01:13:48.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/compiler.h>
 #include <linux/module.h>
+#include <linux/binfmts.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -280,6 +281,24 @@
 	return 0;
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned char*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 int page_fault_trace = 0;
 int exception_trace = 1;
 
@@ -416,6 +435,8 @@
 good_area:
 	info.si_code = SEGV_ACCERR;
 	write = 0;
+	if ((error_code & 16) && !(vma->vm_flags & VM_EXEC))
+		goto bad_area;
 	switch (error_code & 3) {
 		default:	/* 3: write, present */
 			/* fall through */
@@ -482,7 +503,14 @@
 					tsk->comm, tsk->pid, address, regs->rip,
 					regs->rsp, error_code);
 		}
-       
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm && (mm->pax_flags & MF_PAX_PAGEEXEC) && (error_code & 16)) {
+			pax_report_fault(regs, (void*)regs->rip, (void*)regs->rsp);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		tsk->thread.cr2 = address;
 		/* Kernel addresses are always protection faults */
 		tsk->thread.error_code = error_code | (address >= TASK_SIZE);
diff -Nur linux-2.6.13.1.org/crypto/cipher.c grsecurity226/crypto/cipher.c
--- linux-2.6.13.1.org/crypto/cipher.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/crypto/cipher.c	2005-08-30 01:00:00.000000000 +0200
@@ -191,8 +191,6 @@
 	u8 *iv = desc->info;
 	unsigned int done = 0;
 
-	nbytes -= bsize;
-
 	do {
 		xor(iv, src);
 		fn(crypto_tfm_ctx(tfm), dst, iv);
@@ -200,7 +198,7 @@
 
 		src += bsize;
 		dst += bsize;
-	} while ((done += bsize) <= nbytes);
+	} while ((done += bsize) < nbytes);
 
 	return done;
 }
@@ -221,8 +219,6 @@
 	u8 *iv = desc->info;
 	unsigned int done = 0;
 
-	nbytes -= bsize;
-
 	do {
 		u8 *tmp_dst = *dst_p;
 
@@ -234,7 +230,7 @@
 
 		src += bsize;
 		dst += bsize;
-	} while ((done += bsize) <= nbytes);
+	} while ((done += bsize) < nbytes);
 
 	return done;
 }
@@ -247,14 +243,12 @@
 	void (*fn)(void *, u8 *, const u8 *) = desc->crfn;
 	unsigned int done = 0;
 
-	nbytes -= bsize;
-
 	do {
 		fn(crypto_tfm_ctx(tfm), dst, src);
 
 		src += bsize;
 		dst += bsize;
-	} while ((done += bsize) <= nbytes);
+	} while ((done += bsize) < nbytes);
 
 	return done;
 }
diff -Nur linux-2.6.13.1.org/drivers/atm/he.c grsecurity226/drivers/atm/he.c
--- linux-2.6.13.1.org/drivers/atm/he.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/atm/he.c	2005-08-30 01:00:01.000000000 +0200
@@ -102,7 +102,7 @@
 
 /* version definition */
 
-static char *version = "$Id$";
+static char *version = "$Id$";
 
 /* declarations */
 
diff -Nur linux-2.6.13.1.org/drivers/cdrom/cm206.c grsecurity226/drivers/cdrom/cm206.c
--- linux-2.6.13.1.org/drivers/cdrom/cm206.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/cdrom/cm206.c	2005-08-30 01:00:02.000000000 +0200
@@ -1,6 +1,6 @@
 /* cm206.c. A linux-driver for the cm206 cdrom player with cm260 adapter card.
    Copyright (c) 1995--1997 David A. van Leeuwen.
-   $Id$
+   $Id$
    
      This program is free software; you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
@@ -176,7 +176,7 @@
  * - Philips/LMS cm260 product specification
  *
  * David van Leeuwen, david@tm.tno.nl.  */
-#define REVISION "$Revision$"
+#define REVISION "$Revision$"
 
 #include <linux/module.h>
 
diff -Nur linux-2.6.13.1.org/drivers/cdrom/mcdx.c grsecurity226/drivers/cdrom/mcdx.c
--- linux-2.6.13.1.org/drivers/cdrom/mcdx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/cdrom/mcdx.c	2005-08-30 01:00:02.000000000 +0200
@@ -53,7 +53,7 @@
 
 #ifdef RCS
 static const char *mcdx_c_version
-    = "$Id$";
+    = "$Id$";
 #endif
 
 #include <linux/module.h>
@@ -1264,7 +1264,7 @@
 	int drive;
 	xwarn("Version 2.14(hs) \n");
 
-	xwarn("$Id$\n");
+	xwarn("$Id$\n");
 
 	/* zero the pointer array */
 	for (drive = 0; drive < MCDX_NDRIVES; drive++)
diff -Nur linux-2.6.13.1.org/drivers/char/agp/frontend.c grsecurity226/drivers/char/agp/frontend.c
--- linux-2.6.13.1.org/drivers/char/agp/frontend.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/agp/frontend.c	2005-08-30 01:13:53.000000000 +0200
@@ -848,7 +848,7 @@
 	if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))
 		return -EFAULT;
 
-	if ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment))
+	if ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment_priv))
 		return -EFAULT;
 
 	client = agp_find_client_by_pid(reserve.pid);
diff -Nur linux-2.6.13.1.org/drivers/char/applicom.c grsecurity226/drivers/char/applicom.c
--- linux-2.6.13.1.org/drivers/char/applicom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/applicom.c	2005-08-30 01:00:02.000000000 +0200
@@ -197,7 +197,7 @@
 	void __iomem *RamIO;
 	int boardno;
 
-	printk(KERN_INFO "Applicom driver: $Id$\n");
+	printk(KERN_INFO "Applicom driver: $Id$\n");
 
 	/* No mem and irq given - check for a PCI card */
 
@@ -781,7 +781,7 @@
 		writeb(1, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);
 		break;
 	case 6:
-		printk(KERN_INFO "APPLICOM driver release .... V2.8.0 ($Revision$)\n");
+		printk(KERN_INFO "APPLICOM driver release .... V2.8.0 ($Revision$)\n");
 		printk(KERN_INFO "Number of installed boards . %d\n", (int) numboards);
 		printk(KERN_INFO "Segment of board ........... %X\n", (int) mem);
 		printk(KERN_INFO "Interrupt IRQ number ....... %d\n", (int) irq);
diff -Nur linux-2.6.13.1.org/drivers/char/cyclades.c grsecurity226/drivers/char/cyclades.c
--- linux-2.6.13.1.org/drivers/char/cyclades.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/cyclades.c	2005-08-30 01:00:02.000000000 +0200
@@ -2,7 +2,7 @@
 #define	Z_WAKE
 #undef	Z_EXT_CHARS_IN_BUFFER
 static char rcsid[] =
-"$Revision$$Date$";
+"$Revision$$Date$";
 
 /*
  *  linux/drivers/char/cyclades.c
@@ -25,6 +25,9 @@
  * This version supports shared IRQ's (only for PCI boards).
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:02  spender
+ * Initial import of Linux 2.6.13
+ *
  * Prevent users from opening non-existing Z ports.
  *
  * Revision 2.3.2.8   2000/07/06 18:14:16 ivan
diff -Nur linux-2.6.13.1.org/drivers/char/keyboard.c grsecurity226/drivers/char/keyboard.c
--- linux-2.6.13.1.org/drivers/char/keyboard.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/keyboard.c	2005-08-30 01:13:50.000000000 +0200
@@ -608,6 +608,16 @@
 	     kbd->kbdmode == VC_MEDIUMRAW) && 
 	     value != KVAL(K_SAK))
 		return;		/* SAK is allowed even in raw mode */
+
+#if defined(CONFIG_GRKERNSEC_PROC) || defined(CONFIG_GRKERNSEC_PROC_MEMMAP)
+	{
+		void *func = fn_handler[value];
+		if (func == fn_show_state || func == fn_show_ptregs ||
+		    func == fn_show_mem)
+			return;
+	}
+#endif
+
 	fn_handler[value](vc, regs);
 }
 
diff -Nur linux-2.6.13.1.org/drivers/char/mem.c grsecurity226/drivers/char/mem.c
--- linux-2.6.13.1.org/drivers/char/mem.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/mem.c	2005-08-30 01:13:50.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/crash_dump.h>
 #include <linux/backing-dev.h>
 #include <linux/bootmem.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -39,6 +40,10 @@
 extern void tapechar_init(void);
 #endif
 
+#ifdef CONFIG_GRKERNSEC
+extern struct file_operations grsec_fops;
+#endif
+
 /*
  * Architectures vary in how they handle caching for addresses
  * outside of main memory.
@@ -179,6 +184,11 @@
 	if (!valid_phys_addr_range(p, &count))
 		return -EFAULT;
 
+#ifdef CONFIG_GRKERNSEC_KMEM
+	gr_handle_mem_write();
+	return -EPERM;
+#endif
+
 	written = 0;
 
 #ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
@@ -249,6 +259,11 @@
 		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 #endif
 
+#ifdef CONFIG_GRKERNSEC_KMEM
+	if (gr_handle_mem_mmap(vma->vm_pgoff << PAGE_SHIFT, vma))
+		return -EPERM;
+#endif
+
 	/* Remap-pfn-range will mark the range VM_IO and VM_RESERVED */
 	if (remap_pfn_range(vma,
 			    vma->vm_start,
@@ -478,6 +493,11 @@
 	ssize_t written;
 	char * kbuf; /* k-addr because vwrite() takes vmlist_lock rwlock */
 
+#ifdef CONFIG_GRKERNSEC_KMEM
+	gr_handle_kmem_write();
+	return -EPERM;
+#endif
+
 	if (p < (unsigned long) high_memory) {
 
 		wrote = count;
@@ -604,7 +624,23 @@
 			count = size;
 
 		zap_page_range(vma, addr, count, NULL);
-        	zeromap_page_range(vma, addr, count, PAGE_COPY);
+        	zeromap_page_range(vma, addr, count, vma->vm_page_prot);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR) {
+			unsigned long addr_m;
+			struct vm_area_struct * vma_m;
+
+			addr_m = vma->vm_start + vma->vm_mirror;
+			vma_m = find_vma(mm, addr_m);
+			if (vma_m && vma_m->vm_start == addr_m && (vma_m->vm_flags & VM_MIRROR)) {
+				addr_m = addr + vma->vm_mirror;
+				zap_page_range(vma_m, addr_m, count, NULL);
+			} else
+				printk(KERN_ERR "PAX: VMMIRROR: read_zero bug, %08lx, %08lx\n",
+				       addr, vma->vm_start);
+		}
+#endif
 
 		size -= count;
 		buf += count;
@@ -753,6 +789,16 @@
 
 static int open_port(struct inode * inode, struct file * filp)
 {
+#ifdef CONFIG_GRKERNSEC_KMEM
+	gr_handle_open_port();
+	return -EPERM;
+#endif
+
+	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+}
+
+static int open_mem(struct inode * inode, struct file * filp)
+{
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
 
@@ -760,7 +806,6 @@
 #define full_lseek      null_lseek
 #define write_zero	write_null
 #define read_full       read_zero
-#define open_mem	open_port
 #define open_kmem	open_mem
 #define open_oldmem	open_mem
 
@@ -879,6 +924,11 @@
 			filp->f_op = &oldmem_fops;
 			break;
 #endif
+#ifdef CONFIG_GRKERNSEC
+		case 13:
+			filp->f_op = &grsec_fops;
+			break;
+#endif
 		default:
 			return -ENXIO;
 	}
@@ -911,6 +961,9 @@
 #ifdef CONFIG_CRASH_DUMP
 	{12,"oldmem",    S_IRUSR | S_IWUSR | S_IRGRP, &oldmem_fops},
 #endif
+#ifdef CONFIG_GRKERNSEC
+	{13,"grsec",	S_IRUSR | S_IWUGO,	    &grsec_fops},
+#endif
 };
 
 static struct class *mem_class;
diff -Nur linux-2.6.13.1.org/drivers/char/n_hdlc.c grsecurity226/drivers/char/n_hdlc.c
--- linux-2.6.13.1.org/drivers/char/n_hdlc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/n_hdlc.c	2005-08-30 01:00:02.000000000 +0200
@@ -10,7 +10,7 @@
  *	Paul Mackerras <Paul.Mackerras@cs.anu.edu.au>
  *
  * Original release 01/11/99
- * $Id$
+ * $Id$
  *
  * This code is released under the GNU General Public License (GPL)
  *
@@ -79,7 +79,7 @@
  */
 
 #define HDLC_MAGIC 0x239e
-#define HDLC_VERSION "$Revision$"
+#define HDLC_VERSION "$Revision$"
 
 #include <linux/config.h>
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/char/n_r3964.c grsecurity226/drivers/char/n_r3964.c
--- linux-2.6.13.1.org/drivers/char/n_r3964.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/n_r3964.c	2005-08-30 01:00:02.000000000 +0200
@@ -13,6 +13,9 @@
  * L. Haag
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:02  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.10  2001/03/18 13:02:24  dwmw2
  * Fix timer usage, use spinlocks properly.
  *
@@ -217,7 +220,7 @@
 {
    int status;
    
-   printk ("r3964: Philips r3964 Driver $Revision$\n");
+   printk ("r3964: Philips r3964 Driver $Revision$\n");
 
    /*
     * Register the tty line discipline
diff -Nur linux-2.6.13.1.org/drivers/char/pcmcia/synclink_cs.c grsecurity226/drivers/char/pcmcia/synclink_cs.c
--- linux-2.6.13.1.org/drivers/char/pcmcia/synclink_cs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/pcmcia/synclink_cs.c	2005-08-30 01:00:04.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * linux/drivers/char/pcmcia/synclink_cs.c
  *
- * $Id$
+ * $Id$
  *
  * Device driver for Microgate SyncLink PC Card
  * multiprotocol serial adapter.
@@ -472,7 +472,7 @@
 MODULE_LICENSE("GPL");
 
 static char *driver_name = "SyncLink PC Card driver";
-static char *driver_version = "$Revision$";
+static char *driver_version = "$Revision$";
 
 static struct tty_driver *serial_driver;
 
diff -Nur linux-2.6.13.1.org/drivers/char/random.c grsecurity226/drivers/char/random.c
--- linux-2.6.13.1.org/drivers/char/random.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/random.c	2005-08-30 01:13:51.000000000 +0200
@@ -249,8 +249,13 @@
 /*
  * Configuration information
  */
+#ifdef CONFIG_GRKERNSEC_RANDNET
+#define INPUT_POOL_WORDS 256
+#define OUTPUT_POOL_WORDS 64
+#else
 #define INPUT_POOL_WORDS 128
 #define OUTPUT_POOL_WORDS 32
+#endif
 #define SEC_XFER_SIZE 512
 
 /*
@@ -1627,3 +1632,25 @@
 		return 0;
 	return PAGE_ALIGN(get_random_int() % range + start);
 }
+
+#if defined(CONFIG_PAX_ASLR) || defined(CONFIG_GRKERNSEC)
+unsigned long pax_get_random_long(void)
+{
+	static time_t   rekey_time;
+	static __u32    secret[12];
+	time_t          t;
+
+	/*
+	 * Pick a random secret every REKEY_INTERVAL seconds.
+	 */
+	t = get_seconds();
+	if (!rekey_time || (t - rekey_time) > REKEY_INTERVAL) {
+		rekey_time = t;
+		get_random_bytes(secret, sizeof(secret));
+	}
+
+	secret[1] = half_md4_transform(secret+8, secret);
+	secret[0] = half_md4_transform(secret+8, secret);
+	return *(unsigned long *)secret;
+}
+#endif
diff -Nur linux-2.6.13.1.org/drivers/char/rtc.c grsecurity226/drivers/char/rtc.c
--- linux-2.6.13.1.org/drivers/char/rtc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/rtc.c	2005-08-30 01:00:03.000000000 +0200
@@ -938,9 +938,10 @@
 
 	/*
 	 * XXX Interrupt pin #7 in Espresso is shared between RTC and
-	 * PCI Slot 2 INTA# (and some INTx# in Slot 1).
+	 * PCI Slot 2 INTA# (and some INTx# in Slot 1). SA_INTERRUPT here
+	 * is asking for trouble with add-on boards. Change to SA_SHIRQ.
 	 */
-	if (request_irq(rtc_irq, rtc_interrupt, SA_SHIRQ, "rtc", (void *)&rtc_port)) {
+	if (request_irq(rtc_irq, rtc_interrupt, SA_INTERRUPT, "rtc", (void *)&rtc_port)) {
 		/*
 		 * Standard way for sparc to print irq's is to use
 		 * __irq_itoa(). I think for EBus it's ok to use %d.
diff -Nur linux-2.6.13.1.org/drivers/char/sx.c grsecurity226/drivers/char/sx.c
--- linux-2.6.13.1.org/drivers/char/sx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/sx.c	2005-08-30 01:00:03.000000000 +0200
@@ -33,6 +33,9 @@
  *
  * Revision history:
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:03  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.33  2000/03/09 10:00:00  pvdl,wolff
  * - Fixed module and port counting
  * - Fixed signal handling
@@ -200,8 +203,8 @@
  * */
 
 
-#define RCS_ID "$Id$"
-#define RCS_REV "$Revision$"
+#define RCS_ID "$Id$"
+#define RCS_REV "$Revision$"
 
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/char/synclink.c grsecurity226/drivers/char/synclink.c
--- linux-2.6.13.1.org/drivers/char/synclink.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/synclink.c	2005-08-30 01:00:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * linux/drivers/char/synclink.c
  *
- * $Id$
+ * $Id$
  *
  * Device driver for Microgate SyncLink ISA and PCI
  * high speed multiprotocol serial adapters.
@@ -896,7 +896,7 @@
 module_param_array(txholdbufs, int, NULL, 0);
 
 static char *driver_name = "SyncLink serial driver";
-static char *driver_version = "$Revision$";
+static char *driver_version = "$Revision$";
 
 static int synclink_init_one (struct pci_dev *dev,
 				     const struct pci_device_id *ent);
diff -Nur linux-2.6.13.1.org/drivers/char/synclinkmp.c grsecurity226/drivers/char/synclinkmp.c
--- linux-2.6.13.1.org/drivers/char/synclinkmp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/synclinkmp.c	2005-08-30 01:00:03.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Device driver for Microgate SyncLink Multiport
  * high speed multiprotocol serial adapter.
@@ -487,7 +487,7 @@
 module_param_array(dosyncppp, int, NULL, 0);
 
 static char *driver_name = "SyncLink MultiPort driver";
-static char *driver_version = "$Revision$";
+static char *driver_version = "$Revision$";
 
 static int synclinkmp_init_one(struct pci_dev *dev,const struct pci_device_id *ent);
 static void synclinkmp_remove_one(struct pci_dev *dev);
diff -Nur linux-2.6.13.1.org/drivers/char/vt_ioctl.c grsecurity226/drivers/char/vt_ioctl.c
--- linux-2.6.13.1.org/drivers/char/vt_ioctl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/char/vt_ioctl.c	2005-08-30 01:13:51.000000000 +0200
@@ -93,6 +93,12 @@
 	case KDSKBENT:
 		if (!perm)
 			return -EPERM;
+
+#ifdef CONFIG_GRKERNSEC
+		if (!capable(CAP_SYS_TTY_CONFIG))
+			return -EPERM;
+#endif
+
 		if (!i && v == K_NOSUCHMAP) {
 			/* disallocate map */
 			key_map = key_maps[s];
@@ -230,6 +236,13 @@
 			goto reterr;
 		}
 
+#ifdef CONFIG_GRKERNSEC
+		if (!capable(CAP_SYS_TTY_CONFIG)) {
+			ret = -EPERM;
+			goto reterr;
+		}
+#endif
+
 		q = func_table[i];
 		first_free = funcbufptr + (funcbufsize - funcbufleft);
 		for (j = i+1; j < MAX_NR_FUNC && !func_table[j]; j++) 
--- linux-2.6.13.1.org/drivers/infiniband/hw/mthca/mthca_mcg.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/infiniband/hw/mthca/mthca_mcg.c	2005-08-30 01:00:06.000000000 +0200
@@ -29,7 +29,7 @@
  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/init.h>
diff -Nur linux-2.6.13.1.org/drivers/isdn/capi/capi.c grsecurity226/drivers/isdn/capi/capi.c
--- linux-2.6.13.1.org/drivers/isdn/capi/capi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/capi/capi.c	2005-08-30 01:00:06.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * CAPI 2.0 Interface for Linux
  *
@@ -46,7 +46,7 @@
 #include "capifs.h"
 #endif
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 MODULE_DESCRIPTION("CAPI4Linux: Userspace /dev/capi20 interface");
 MODULE_AUTHOR("Carsten Paeth");
diff -Nur linux-2.6.13.1.org/drivers/isdn/capi/capidrv.c grsecurity226/drivers/isdn/capi/capidrv.c
--- linux-2.6.13.1.org/drivers/isdn/capi/capidrv.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/capi/capidrv.c	2005-08-30 01:00:06.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISDN4Linux Driver, using capi20 interface (kernelcapi)
  *
@@ -35,7 +35,7 @@
 #include <linux/isdn/capicmd.h>
 #include "capidrv.h"
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 static int debugmode = 0;
 
 MODULE_DESCRIPTION("CAPI4Linux: Interface to ISDN4Linux");
diff -Nur linux-2.6.13.1.org/drivers/isdn/capi/capidrv.h grsecurity226/drivers/isdn/capi/capidrv.h
--- linux-2.6.13.1.org/drivers/isdn/capi/capidrv.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/capi/capidrv.h	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISDN4Linux Driver, using capi20 interface (kernelcapi)
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/capi/capifs.c grsecurity226/drivers/isdn/capi/capifs.c
--- linux-2.6.13.1.org/drivers/isdn/capi/capifs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/capi/capifs.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Copyright 2000 by Carsten Paeth <calle@calle.de>
  *
@@ -22,7 +22,7 @@
 
 /* ------------------------------------------------------------------ */
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 /* ------------------------------------------------------------------ */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/capi/kcapi.c grsecurity226/drivers/isdn/capi/kcapi.c
--- linux-2.6.13.1.org/drivers/isdn/capi/kcapi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/capi/kcapi.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Kernel CAPI 2.0 Module
  * 
@@ -33,7 +33,7 @@
 #include <linux/b1lli.h>
 #endif
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 /* ------------------------------------------------------------- */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1.c grsecurity226/drivers/isdn/hardware/avm/b1.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/avm/b1.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Common module for AVM B1 cards.
  * 
@@ -28,7 +28,7 @@
 #include <linux/isdn/capicmd.h>
 #include <linux/isdn/capiutil.h>
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 /* ------------------------------------------------------------- */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1dma.c grsecurity226/drivers/isdn/hardware/avm/b1dma.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1dma.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/avm/b1dma.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Common module for AVM B1 cards that support dma with AMCC
  * 
@@ -28,7 +28,7 @@
 #include <linux/isdn/capicmd.h>
 #include <linux/isdn/capiutil.h>
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 #undef CONFIG_B1DMA_DEBUG
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1isa.c grsecurity226/drivers/isdn/hardware/avm/b1isa.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1isa.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/avm/b1isa.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Module for AVM B1 ISA-card.
  * 
@@ -27,7 +27,7 @@
 
 /* ------------------------------------------------------------- */
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 /* ------------------------------------------------------------- */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1pci.c grsecurity226/drivers/isdn/hardware/avm/b1pci.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/avm/b1pci.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Module for AVM B1 PCI-card.
  * 
@@ -28,7 +28,7 @@
 
 /* ------------------------------------------------------------- */
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 /* ------------------------------------------------------------- */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1pcmcia.c grsecurity226/drivers/isdn/hardware/avm/b1pcmcia.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/avm/b1pcmcia.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/avm/b1pcmcia.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Module for AVM B1/M1/M2 PCMCIA-card.
  * 
@@ -27,7 +27,7 @@
 
 /* ------------------------------------------------------------- */
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 /* ------------------------------------------------------------- */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/avm/c4.c grsecurity226/drivers/isdn/hardware/avm/c4.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/avm/c4.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/avm/c4.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Module for AVM C4 & C2 card.
  * 
@@ -34,7 +34,7 @@
 
 /* ------------------------------------------------------------- */
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 /* ------------------------------------------------------------- */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/avm/t1isa.c grsecurity226/drivers/isdn/hardware/avm/t1isa.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/avm/t1isa.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/avm/t1isa.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Module for AVM T1 HEMA-card.
  * 
@@ -29,7 +29,7 @@
 
 /* ------------------------------------------------------------- */
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 
 /* ------------------------------------------------------------- */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/avm/t1pci.c grsecurity226/drivers/isdn/hardware/avm/t1pci.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/avm/t1pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/avm/t1pci.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Module for AVM T1 PCI-card.
  * 
@@ -30,7 +30,7 @@
 #undef CONFIG_T1PCI_POLLDEBUG
 
 /* ------------------------------------------------------------- */
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 /* ------------------------------------------------------------- */
 
 static struct pci_device_id t1pci_pci_tbl[] = {
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/eicon/capimain.c grsecurity226/drivers/isdn/hardware/eicon/capimain.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/eicon/capimain.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/eicon/capimain.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISDN interface module for Eicon active cards DIVA.
  * CAPI Interface
@@ -26,7 +26,7 @@
 #include "cp_vers.h"
 #include "capifunc.h"
 
-static char *main_revision = "$Revision$";
+static char *main_revision = "$Revision$";
 static char *DRIVERNAME =
     "Eicon DIVA - CAPI Interface driver (http://www.melware.net)";
 static char *DRIVERLNAME = "divacapi";
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/eicon/diva_didd.c grsecurity226/drivers/isdn/hardware/eicon/diva_didd.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/eicon/diva_didd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/eicon/diva_didd.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * DIDD Interface module for Eicon active cards.
  * 
@@ -23,7 +23,7 @@
 #include "divasync.h"
 #include "did_vers.h"
 
-static char *main_revision = "$Revision$";
+static char *main_revision = "$Revision$";
 
 static char *DRIVERNAME =
     "Eicon DIVA - DIDD table (http://www.melware.net)";
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/eicon/divamnt.c grsecurity226/drivers/isdn/hardware/eicon/divamnt.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/eicon/divamnt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/eicon/divamnt.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Driver for Eicon DIVA Server ISDN cards.
  * Maint module
@@ -25,7 +25,7 @@
 #include "divasync.h"
 #include "debug_if.h"
 
-static char *main_revision = "$Revision$";
+static char *main_revision = "$Revision$";
 
 static int major;
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/eicon/divasi.c grsecurity226/drivers/isdn/hardware/eicon/divasi.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/eicon/divasi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/eicon/divasi.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Driver for Eicon DIVA Server ISDN cards.
  * User Mode IDI Interface 
@@ -28,7 +28,7 @@
 #include "um_xdi.h"
 #include "um_idi.h"
 
-static char *main_revision = "$Revision$";
+static char *main_revision = "$Revision$";
 
 static int major;
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hardware/eicon/divasmain.c grsecurity226/drivers/isdn/hardware/eicon/divasmain.c
--- linux-2.6.13.1.org/drivers/isdn/hardware/eicon/divasmain.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hardware/eicon/divasmain.c	2005-08-30 01:00:07.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Low level driver for Eicon DIVA Server ISDN cards.
  *
@@ -41,7 +41,7 @@
 #include "diva_dma.h"
 #include "diva_pci.h"
 
-static char *main_revision = "$Revision$";
+static char *main_revision = "$Revision$";
 
 static int major;
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/asuscom.c grsecurity226/drivers/isdn/hisax/asuscom.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/asuscom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/asuscom.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for ASUSCOM NETWORK INC. ISDNLink cards
  *
@@ -22,7 +22,7 @@
 
 extern const char *CardType[];
 
-static const char *Asuscom_revision = "$Revision$";
+static const char *Asuscom_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/avm_a1.c grsecurity226/drivers/isdn/hisax/avm_a1.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/avm_a1.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/avm_a1.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for AVM A1 (Fritz) isdn cards
  *
@@ -17,7 +17,7 @@
 #include "isdnl1.h"
 
 extern const char *CardType[];
-static const char *avm_revision = "$Revision$";
+static const char *avm_revision = "$Revision$";
 
 #define	 AVM_A1_STAT_ISAC	0x01
 #define	 AVM_A1_STAT_HSCX	0x02
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/avm_a1p.c grsecurity226/drivers/isdn/hisax/avm_a1p.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/avm_a1p.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/avm_a1p.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for the following AVM cards:
  * A1 PCMCIA
@@ -56,7 +56,7 @@
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
 
-static const char *avm_revision = "$Revision$";
+static const char *avm_revision = "$Revision$";
 
 static inline u_char
 ReadISAC(struct IsdnCardState *cs, u_char offset)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/avm_pci.c grsecurity226/drivers/isdn/hisax/avm_pci.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/avm_pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/avm_pci.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for AVM Fritz!PCI and ISA PnP isdn cards
  *
@@ -22,7 +22,7 @@
 #include <linux/interrupt.h>
 
 extern const char *CardType[];
-static const char *avm_pci_rev = "$Revision$";
+static const char *avm_pci_rev = "$Revision$";
 
 #define  AVM_FRITZ_PCI		1
 #define  AVM_FRITZ_PNP		2
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/bkm_a4t.c grsecurity226/drivers/isdn/hisax/bkm_a4t.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/bkm_a4t.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/bkm_a4t.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for T-Berkom A4T
  *
@@ -23,7 +23,7 @@
 
 extern const char *CardType[];
 
-static const char *bkm_a4t_revision = "$Revision$";
+static const char *bkm_a4t_revision = "$Revision$";
 
 
 static inline u_char
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/bkm_a8.c grsecurity226/drivers/isdn/hisax/bkm_a8.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/bkm_a8.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/bkm_a8.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Scitel Quadro (4*S0, passive)
  *
@@ -27,7 +27,7 @@
 
 extern const char *CardType[];
 
-static const char sct_quadro_revision[] = "$Revision$";
+static const char sct_quadro_revision[] = "$Revision$";
 
 static const char *sct_quadro_subtypes[] =
 {
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/bkm_ax.h grsecurity226/drivers/isdn/hisax/bkm_ax.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/bkm_ax.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/bkm_ax.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level decls for T-Berkom cards A4T and Scitel Quadro (4*S0, passive)
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/callc.c grsecurity226/drivers/isdn/hisax/callc.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/callc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/callc.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Author       Karsten Keil
  * Copyright    by Karsten Keil      <keil@isdn4linux.de>
@@ -21,7 +21,7 @@
 #include "hisax.h"
 #include <linux/isdn/capicmd.h>
 
-const char *lli_revision = "$Revision$";
+const char *lli_revision = "$Revision$";
 
 extern struct IsdnCard cards[];
 extern int nrcards;
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/diva.c grsecurity226/drivers/isdn/hisax/diva.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/diva.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/diva.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Eicon.Diehl Diva Family ISDN cards
  *
@@ -28,7 +28,7 @@
 
 extern const char *CardType[];
 
-static const char *Diva_revision = "$Revision$";
+static const char *Diva_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/elsa.c grsecurity226/drivers/isdn/hisax/elsa.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/elsa.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/elsa.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Elsa isdn cards
  *
@@ -33,7 +33,7 @@
 
 extern const char *CardType[];
 
-static const char *Elsa_revision = "$Revision$";
+static const char *Elsa_revision = "$Revision$";
 static const char *Elsa_Types[] =
 {"None", "PC", "PCC-8", "PCC-16", "PCF", "PCF-Pro",
  "PCMCIA", "QS 1000", "QS 3000", "Microlink PCI", "QS 3000 PCI", 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/elsa_cs.c grsecurity226/drivers/isdn/hisax/elsa_cs.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/elsa_cs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/elsa_cs.c	2005-08-30 01:00:08.000000000 +0200
@@ -71,7 +71,7 @@
 module_param(pc_debug, int, 0);
 #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args);
 static char *version =
-"elsa_cs.c $Revision$ $Date$ (K.Lichtenwalder)";
+"elsa_cs.c $Revision$ $Date$ (K.Lichtenwalder)";
 #else
 #define DEBUG(n, args...)
 #endif
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/enternow_pci.c grsecurity226/drivers/isdn/hisax/enternow_pci.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/enternow_pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/enternow_pci.c	2005-08-30 01:00:08.000000000 +0200
@@ -73,7 +73,7 @@
 
 
 
-static const char *enternow_pci_rev = "$Revision$";
+static const char *enternow_pci_rev = "$Revision$";
 
 
 /* fr PowerISDN PCI */
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/fsm.c grsecurity226/drivers/isdn/hisax/fsm.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/fsm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/fsm.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Finite state machine
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/gazel.c grsecurity226/drivers/isdn/hisax/gazel.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/gazel.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/gazel.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Gazel isdn cards
  *
@@ -21,7 +21,7 @@
 #include <linux/pci.h>
 
 extern const char *CardType[];
-static const char *gazel_revision = "$Revision$";
+static const char *gazel_revision = "$Revision$";
 
 #define R647      1
 #define R685      2
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/hfcscard.c grsecurity226/drivers/isdn/hisax/hfcscard.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/hfcscard.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/hfcscard.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for hfcs based cards (Teles3c, ACER P10)
  *
@@ -18,7 +18,7 @@
 
 extern const char *CardType[];
 
-static const char *hfcs_revision = "$Revision$";
+static const char *hfcs_revision = "$Revision$";
 
 static irqreturn_t
 hfcs_interrupt(int intno, void *dev_id, struct pt_regs *regs)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/hisax.h grsecurity226/drivers/isdn/hisax/hisax.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/hisax.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/hisax.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Basic declarations, defines and prototypes
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/hisax_cfg.h grsecurity226/drivers/isdn/hisax/hisax_cfg.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/hisax_cfg.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/hisax_cfg.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * define of the basic HiSax configuration structures
  * and pcmcia interface
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/hscx.c grsecurity226/drivers/isdn/hisax/hscx.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/hscx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/hscx.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * HSCX specific routines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/hscx.h grsecurity226/drivers/isdn/hisax/hscx.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/hscx.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/hscx.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * HSCX specific defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/hscx_irq.c grsecurity226/drivers/isdn/hisax/hscx_irq.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/hscx_irq.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/hscx_irq.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level b-channel stuff for Siemens HSCX
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/icc.c grsecurity226/drivers/isdn/hisax/icc.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/icc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/icc.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ICC specific routines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/icc.h grsecurity226/drivers/isdn/hisax/icc.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/icc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/icc.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ICC specific routines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/ipac.h grsecurity226/drivers/isdn/hisax/ipac.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/ipac.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/ipac.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * IPAC specific defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isac.c grsecurity226/drivers/isdn/hisax/isac.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/isac.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isac.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISAC specific routines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isac.h grsecurity226/drivers/isdn/hisax/isac.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/isac.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isac.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISAC specific defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isar.c grsecurity226/drivers/isdn/hisax/isar.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/isar.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isar.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * isar.c   ISAR (Siemens PSB 7110) specific routines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isar.h grsecurity226/drivers/isdn/hisax/isar.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/isar.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isar.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISAR (Siemens PSB 7110) specific defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isdnl1.c grsecurity226/drivers/isdn/hisax/isdnl1.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/isdnl1.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isdnl1.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * common low level stuff for Siemens Chipsetbased isdn cards
  *
@@ -18,7 +18,7 @@
  *
  */
 
-const char *l1_revision = "$Revision$";
+const char *l1_revision = "$Revision$";
 
 #include <linux/init.h>
 #include "hisax.h"
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isdnl1.h grsecurity226/drivers/isdn/hisax/isdnl1.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/isdnl1.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isdnl1.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Layer 1 defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isdnl2.c grsecurity226/drivers/isdn/hisax/isdnl2.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/isdnl2.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isdnl2.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Author       Karsten Keil
  *              based on the teles driver from Jan den Ouden
@@ -19,7 +19,7 @@
 #include "hisax.h"
 #include "isdnl2.h"
 
-const char *l2_revision = "$Revision$";
+const char *l2_revision = "$Revision$";
 
 static void l2m_debug(struct FsmInst *fi, char *fmt, ...);
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isdnl2.h grsecurity226/drivers/isdn/hisax/isdnl2.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/isdnl2.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isdnl2.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Layer 2 defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isdnl3.c grsecurity226/drivers/isdn/hisax/isdnl3.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/isdnl3.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isdnl3.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Author       Karsten Keil
  *              based on the teles driver from Jan den Ouden
@@ -20,7 +20,7 @@
 #include "isdnl3.h"
 #include <linux/config.h>
 
-const char *l3_revision = "$Revision$";
+const char *l3_revision = "$Revision$";
 
 static struct Fsm l3fsm;
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isdnl3.h grsecurity226/drivers/isdn/hisax/isdnl3.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/isdnl3.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isdnl3.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * This software may be used and distributed according to the terms
  * of the GNU General Public License, incorporated herein by reference.
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/isurf.c grsecurity226/drivers/isdn/hisax/isurf.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/isurf.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/isurf.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Siemens I-Surf/I-Talk cards
  *
@@ -19,7 +19,7 @@
 
 extern const char *CardType[];
 
-static const char *ISurf_revision = "$Revision$";
+static const char *ISurf_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/ix1_micro.c grsecurity226/drivers/isdn/hisax/ix1_micro.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/ix1_micro.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/ix1_micro.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for ITK ix1-micro Rev.2 isdn cards
  * derived from the original file teles3.c from Karsten Keil
@@ -25,7 +25,7 @@
 #include "isdnl1.h"
 
 extern const char *CardType[];
-static const char *ix1_revision = "$Revision$";
+static const char *ix1_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/jade.c grsecurity226/drivers/isdn/hisax/jade.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/jade.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/jade.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * JADE stuff (derived from original hscx.c)
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/jade.h grsecurity226/drivers/isdn/hisax/jade.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/jade.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/jade.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * JADE specific defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/jade_irq.c grsecurity226/drivers/isdn/hisax/jade_irq.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/jade_irq.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/jade_irq.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Low level JADE IRQ stuff (derived from original hscx_irq.c)
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/l3_1tr6.c grsecurity226/drivers/isdn/hisax/l3_1tr6.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/l3_1tr6.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/l3_1tr6.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * German 1TR6 D-channel protocol
  *
@@ -19,7 +19,7 @@
 #include <linux/ctype.h>
 
 extern char *HiSax_getrev(const char *revision);
-static const char *l3_1tr6_revision = "$Revision$";
+static const char *l3_1tr6_revision = "$Revision$";
 
 #define MsgHead(ptr, cref, mty, dis) \
 	*ptr++ = dis; \
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/l3_1tr6.h grsecurity226/drivers/isdn/hisax/l3_1tr6.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/l3_1tr6.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/l3_1tr6.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * German 1TR6 D-channel protocol defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/l3dss1.c grsecurity226/drivers/isdn/hisax/l3dss1.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/l3dss1.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/l3dss1.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * EURO/DSS1 D-channel protocol
  *
@@ -26,7 +26,7 @@
 #include <linux/config.h>
 
 extern char *HiSax_getrev(const char *revision);
-static const char *dss1_revision = "$Revision$";
+static const char *dss1_revision = "$Revision$";
 
 #define EXT_BEARER_CAPS 1
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/l3dss1.h grsecurity226/drivers/isdn/hisax/l3dss1.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/l3dss1.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/l3dss1.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * DSS1 (Euro) D-channel protocol defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/l3ni1.c grsecurity226/drivers/isdn/hisax/l3ni1.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/l3ni1.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/l3ni1.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * NI1 D-channel protocol
  *
@@ -24,7 +24,7 @@
 #include <linux/ctype.h>
 
 extern char *HiSax_getrev(const char *revision);
-static const char *ni1_revision = "$Revision$";
+static const char *ni1_revision = "$Revision$";
 
 #define EXT_BEARER_CAPS 1
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/l3ni1.h grsecurity226/drivers/isdn/hisax/l3ni1.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/l3ni1.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/l3ni1.h	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * NI1 D-channel protocol
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/lmgr.c grsecurity226/drivers/isdn/hisax/lmgr.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/lmgr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/lmgr.c	2005-08-30 01:00:08.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Layermanagement module
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/mic.c grsecurity226/drivers/isdn/hisax/mic.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/mic.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/mic.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for mic cards
  *
@@ -18,7 +18,7 @@
 
 extern const char *CardType[];
 
-static const char *mic_revision = "$Revision$";
+static const char *mic_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/netjet.c grsecurity226/drivers/isdn/hisax/netjet.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/netjet.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/netjet.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Traverse Technologie NETJet ISDN cards
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/netjet.h grsecurity226/drivers/isdn/hisax/netjet.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/netjet.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/netjet.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * NETjet common header file
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/niccy.c grsecurity226/drivers/isdn/hisax/niccy.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/niccy.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/niccy.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Dr. Neuhaus NICCY PnP and NICCY PCI and
  * compatible (SAGEM cybermodem)
@@ -24,7 +24,7 @@
 #include <linux/isapnp.h>
 
 extern const char *CardType[];
-static const char *niccy_revision = "$Revision$";
+static const char *niccy_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/nj_s.c grsecurity226/drivers/isdn/hisax/nj_s.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/nj_s.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/nj_s.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * This software may be used and distributed according to the terms
  * of the GNU General Public License, incorporated herein by reference.
@@ -15,7 +15,7 @@
 #include <linux/ppp_defs.h>
 #include "netjet.h"
 
-static const char *NETjet_S_revision = "$Revision$";
+static const char *NETjet_S_revision = "$Revision$";
 
 static u_char dummyrr(struct IsdnCardState *cs, int chan, u_char off)
 {
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/nj_u.c grsecurity226/drivers/isdn/hisax/nj_u.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/nj_u.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/nj_u.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ 
+/* $Id$ 
  *
  * This software may be used and distributed according to the terms
  * of the GNU General Public License, incorporated herein by reference.
@@ -15,7 +15,7 @@
 #include <linux/ppp_defs.h>
 #include "netjet.h"
 
-static const char *NETjet_U_revision = "$Revision$";
+static const char *NETjet_U_revision = "$Revision$";
 
 static u_char dummyrr(struct IsdnCardState *cs, int chan, u_char off)
 {
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/q931.c grsecurity226/drivers/isdn/hisax/q931.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/q931.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/q931.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * code to decode ITU Q.931 call control messages
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/s0box.c grsecurity226/drivers/isdn/hisax/s0box.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/s0box.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/s0box.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Creatix S0BOX
  *
@@ -17,7 +17,7 @@
 #include "isdnl1.h"
 
 extern const char *CardType[];
-static const char *s0box_revision = "$Revision$";
+static const char *s0box_revision = "$Revision$";
 
 static inline void
 writereg(unsigned int padr, signed int addr, u_char off, u_char val) {
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/saphir.c grsecurity226/drivers/isdn/hisax/saphir.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/saphir.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/saphir.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for HST Saphir 1
  *
@@ -19,7 +19,7 @@
 #include "isdnl1.h"
 
 extern const char *CardType[];
-static char *saphir_rev = "$Revision$";
+static char *saphir_rev = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/sedlbauer.c grsecurity226/drivers/isdn/hisax/sedlbauer.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/sedlbauer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/sedlbauer.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Sedlbauer cards
  * includes support for the Sedlbauer speed star (speed star II),
@@ -51,7 +51,7 @@
 
 extern const char *CardType[];
 
-static const char *Sedlbauer_revision = "$Revision$";
+static const char *Sedlbauer_revision = "$Revision$";
 
 static const char *Sedlbauer_Types[] =
 	{"None", "speed card/win", "speed star", "speed fax+",
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/sportster.c grsecurity226/drivers/isdn/hisax/sportster.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/sportster.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/sportster.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for USR Sportster internal TA
  *
@@ -19,7 +19,7 @@
 #include "isdnl1.h"
 
 extern const char *CardType[];
-static const char *sportster_revision = "$Revision$";
+static const char *sportster_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/st5481_init.c grsecurity226/drivers/isdn/hisax/st5481_init.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/st5481_init.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/st5481_init.c	2005-08-30 01:00:09.000000000 +0200
@@ -196,7 +196,7 @@
 	st5481_debug = debug;
 #endif
 
-	printk(KERN_INFO "hisax_st5481: ST5481 USB ISDN driver $Revision$\n");
+	printk(KERN_INFO "hisax_st5481: ST5481 USB ISDN driver $Revision$\n");
 
 	retval = st5481_d_init();
 	if (retval < 0)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/tei.c grsecurity226/drivers/isdn/hisax/tei.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/tei.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/tei.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Author       Karsten Keil
  *              based on the teles driver from Jan den Ouden
@@ -20,7 +20,7 @@
 #include <linux/init.h>
 #include <linux/random.h>
 
-const char *tei_revision = "$Revision$";
+const char *tei_revision = "$Revision$";
 
 #define ID_REQUEST	1
 #define ID_ASSIGNED	2
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/teleint.c grsecurity226/drivers/isdn/hisax/teleint.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/teleint.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/teleint.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for TeleInt isdn cards
  *
@@ -18,7 +18,7 @@
 
 extern const char *CardType[];
 
-static const char *TeleInt_revision = "$Revision$";
+static const char *TeleInt_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/teles0.c grsecurity226/drivers/isdn/hisax/teles0.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/teles0.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/teles0.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Teles Memory IO isdn cards
  *
@@ -23,7 +23,7 @@
 
 extern const char *CardType[];
 
-static const char *teles0_revision = "$Revision$";
+static const char *teles0_revision = "$Revision$";
 
 #define TELES_IOMEM_SIZE	0x400
 #define byteout(addr,val) outb(val,addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/teles3.c grsecurity226/drivers/isdn/hisax/teles3.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/teles3.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/teles3.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Teles 16.3 & PNP isdn cards
  *
@@ -21,7 +21,7 @@
 #include "isdnl1.h"
 
 extern const char *CardType[];
-static const char *teles3_revision = "$Revision$";
+static const char *teles3_revision = "$Revision$";
 
 #define byteout(addr,val) outb(val,addr)
 #define bytein(addr) inb(addr)
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/teles_cs.c grsecurity226/drivers/isdn/hisax/teles_cs.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/teles_cs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/teles_cs.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 /*======================================================================
 
     A teles S0 PCMCIA client driver
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/telespci.c grsecurity226/drivers/isdn/hisax/telespci.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/telespci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/telespci.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * low level stuff for Teles PCI isdn cards
  *
@@ -21,7 +21,7 @@
 #include <linux/pci.h>
 
 extern const char *CardType[];
-static const char *telespci_revision = "$Revision$";
+static const char *telespci_revision = "$Revision$";
 
 #define ZORAN_PO_RQ_PEN	0x02000000
 #define ZORAN_PO_WR	0x00800000
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/w6692.c grsecurity226/drivers/isdn/hisax/w6692.c
--- linux-2.6.13.1.org/drivers/isdn/hisax/w6692.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/w6692.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Winbond W6692 specific routines
  *
@@ -41,7 +41,7 @@
 
 extern const char *CardType[];
 
-static const char *w6692_revision = "$Revision$";
+static const char *w6692_revision = "$Revision$";
 
 #define DBUSY_TIMER_VALUE 80
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hisax/w6692.h grsecurity226/drivers/isdn/hisax/w6692.h
--- linux-2.6.13.1.org/drivers/isdn/hisax/w6692.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hisax/w6692.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Winbond W6692 specific defines
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/boardergo.c grsecurity226/drivers/isdn/hysdn/boardergo.c
--- linux-2.6.13.1.org/drivers/isdn/hysdn/boardergo.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/boardergo.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards, specific routines for ergo type boards.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/boardergo.h grsecurity226/drivers/isdn/hysdn/boardergo.h
--- linux-2.6.13.1.org/drivers/isdn/hysdn/boardergo.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/boardergo.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards, definitions for ergo type boards (buffers..).
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hycapi.c grsecurity226/drivers/isdn/hysdn/hycapi.c
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hycapi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hycapi.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards, CAPI2.0-Interface.
  *
@@ -29,7 +29,7 @@
 #include "hysdn_defs.h"
 #include <linux/kernelcapi.h>
 
-static char hycapi_revision[]="$Revision$";
+static char hycapi_revision[]="$Revision$";
 
 unsigned int hycapi_enable = 0xffffffff; 
 MODULE_PARM(hycapi_enable, "i");
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_boot.c grsecurity226/drivers/isdn/hysdn/hysdn_boot.c
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_boot.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hysdn_boot.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards
  * specific routines for booting and pof handling
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_defs.h grsecurity226/drivers/isdn/hysdn/hysdn_defs.h
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hysdn_defs.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards
  * global definitions and exported vars and functions.
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_init.c grsecurity226/drivers/isdn/hysdn/hysdn_init.c
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_init.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hysdn_init.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards, init functions.
  *
@@ -33,7 +33,7 @@
 MODULE_AUTHOR("Werner Cornelius");
 MODULE_LICENSE("GPL");
 
-static char *hysdn_init_revision = "$Revision$";
+static char *hysdn_init_revision = "$Revision$";
 static int cardmax;		/* number of found cards */
 hysdn_card *card_root = NULL;	/* pointer to first card */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_net.c grsecurity226/drivers/isdn/hysdn/hysdn_net.c
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_net.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hysdn_net.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards, net (ethernet type) handling routines.
  *
@@ -28,7 +28,7 @@
 MODULE_PARM(hynet_enable, "i");
 
 /* store the actual version for log reporting */
-char *hysdn_net_revision = "$Revision$";
+char *hysdn_net_revision = "$Revision$";
 
 #define MAX_SKB_BUFFERS 20	/* number of buffers for keeping TX-data */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_pof.h grsecurity226/drivers/isdn/hysdn/hysdn_pof.h
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_pof.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hysdn_pof.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards, definitions used for handling pof-files.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_procconf.c grsecurity226/drivers/isdn/hysdn/hysdn_procconf.c
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_procconf.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hysdn_procconf.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards, /proc/net filesystem dir and conf functions.
  *
@@ -20,7 +20,7 @@
 
 #include "hysdn_defs.h"
 
-static char *hysdn_procconf_revision = "$Revision$";
+static char *hysdn_procconf_revision = "$Revision$";
 
 #define INFO_OUT_LEN 80		/* length of info line including lf */
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_proclog.c grsecurity226/drivers/isdn/hysdn/hysdn_proclog.c
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_proclog.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hysdn_proclog.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards, /proc/net filesystem log functions.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_sched.c grsecurity226/drivers/isdn/hysdn/hysdn_sched.c
--- linux-2.6.13.1.org/drivers/isdn/hysdn/hysdn_sched.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/hysdn/hysdn_sched.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards
  * scheduler routines for handling exchange card <-> pc.
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_audio.c grsecurity226/drivers/isdn/i4l/isdn_audio.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_audio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_audio.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, audio conversion and compression (linklevel).
  *
@@ -15,7 +15,7 @@
 #include "isdn_audio.h"
 #include "isdn_common.h"
 
-char *isdn_audio_revision = "$Revision$";
+char *isdn_audio_revision = "$Revision$";
 
 /*
  * Misc. lookup-tables.
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_audio.h grsecurity226/drivers/isdn/i4l/isdn_audio.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_audio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_audio.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, audio conversion and compression (linklevel).
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_common.c grsecurity226/drivers/isdn/i4l/isdn_common.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_common.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_common.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, common used functions (linklevel).
  *
@@ -43,7 +43,7 @@
 
 isdn_dev *dev;
 
-static char *isdn_revision = "$Revision$";
+static char *isdn_revision = "$Revision$";
 
 extern char *isdn_net_revision;
 extern char *isdn_tty_revision;
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_common.h grsecurity226/drivers/isdn/i4l/isdn_common.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_common.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_common.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * header for Linux ISDN subsystem
  * common used functions and debugging-switches (linklevel).
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_concap.c grsecurity226/drivers/isdn/i4l/isdn_concap.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_concap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_concap.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Linux ISDN subsystem, protocol encapsulation
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_concap.h grsecurity226/drivers/isdn/i4l/isdn_concap.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_concap.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_concap.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, protocol encapsulation
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_net.c grsecurity226/drivers/isdn/i4l/isdn_net.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_net.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_net.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, network interfaces and related functions (linklevel).
  *
@@ -182,7 +182,7 @@
 static void isdn_net_ciscohdlck_connected(isdn_net_local *lp);
 static void isdn_net_ciscohdlck_disconnected(isdn_net_local *lp);
 
-char *isdn_net_revision = "$Revision$";
+char *isdn_net_revision = "$Revision$";
 
  /*
   * Code for raw-networking over ISDN
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_net.h grsecurity226/drivers/isdn/i4l/isdn_net.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_net.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_net.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * header for Linux ISDN subsystem, network related functions (linklevel).
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_ppp.c grsecurity226/drivers/isdn/i4l/isdn_ppp.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_ppp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_ppp.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, functions for synchronous PPP (linklevel).
  *
@@ -72,7 +72,7 @@
 static int isdn_ppp_bundle(struct ippp_struct *, int unit);
 #endif	/* CONFIG_ISDN_MPP */
   
-char *isdn_ppp_revision = "$Revision$";
+char *isdn_ppp_revision = "$Revision$";
 
 static struct ippp_struct *ippp_table[ISDN_MAX_CHANNELS];
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_ppp.h grsecurity226/drivers/isdn/i4l/isdn_ppp.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_ppp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_ppp.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * header for Linux ISDN subsystem, functions for synchronous PPP (linklevel).
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_tty.c grsecurity226/drivers/isdn/i4l/isdn_tty.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_tty.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_tty.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, tty functions and AT-command emulator (linklevel).
  *
@@ -46,7 +46,7 @@
 static int si2bit[8] =
 {4, 1, 4, 4, 4, 4, 4, 4};
 
-char *isdn_tty_revision = "$Revision$";
+char *isdn_tty_revision = "$Revision$";
 
 
 /* isdn_tty_try_read() is called from within isdn_tty_rcv_skb()
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_tty.h grsecurity226/drivers/isdn/i4l/isdn_tty.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_tty.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_tty.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * header for Linux ISDN subsystem, tty related functions (linklevel).
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_ttyfax.c grsecurity226/drivers/isdn/i4l/isdn_ttyfax.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_ttyfax.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_ttyfax.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, tty_fax AT-command emulator (linklevel).
  *
@@ -20,7 +20,7 @@
 #include "isdn_ttyfax.h"
 
 
-static char *isdn_tty_fax_revision = "$Revision$";
+static char *isdn_tty_fax_revision = "$Revision$";
 
 #define PARSE_ERROR1 { isdn_tty_fax_modem_result(1, info); return 1; }
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_ttyfax.h grsecurity226/drivers/isdn/i4l/isdn_ttyfax.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_ttyfax.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_ttyfax.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * header for Linux ISDN subsystem, tty_fax related functions (linklevel).
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_v110.c grsecurity226/drivers/isdn/i4l/isdn_v110.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_v110.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_v110.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, V.110 related functions (linklevel).
  *
@@ -20,7 +20,7 @@
 
 #undef ISDN_V110_DEBUG
 
-char *isdn_v110_revision = "$Revision$";
+char *isdn_v110_revision = "$Revision$";
 
 #define V110_38400 255
 #define V110_19200  15
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_v110.h grsecurity226/drivers/isdn/i4l/isdn_v110.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_v110.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_v110.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, V.110 related functions (linklevel).
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_x25iface.c grsecurity226/drivers/isdn/i4l/isdn_x25iface.c
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_x25iface.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_x25iface.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem, X.25 related functions
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/i4l/isdn_x25iface.h grsecurity226/drivers/isdn/i4l/isdn_x25iface.h
--- linux-2.6.13.1.org/drivers/isdn/i4l/isdn_x25iface.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/i4l/isdn_x25iface.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * header for Linux ISDN subsystem, x.25 related functions
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/icn/icn.c grsecurity226/drivers/isdn/icn/icn.c
--- linux-2.6.13.1.org/drivers/isdn/icn/icn.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/icn/icn.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISDN low-level module for the ICN active ISDN-Card.
  *
@@ -41,7 +41,7 @@
 #undef MAP_DEBUG
 
 static char
-*revision = "$Revision$";
+*revision = "$Revision$";
 
 static int icn_addcard(int, char *, char *);
 
diff -Nur linux-2.6.13.1.org/drivers/isdn/icn/icn.h grsecurity226/drivers/isdn/icn/icn.h
--- linux-2.6.13.1.org/drivers/isdn/icn/icn.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/icn/icn.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISDN lowlevel-module for the ICN active ISDN-Card.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/isdnloop/isdnloop.c grsecurity226/drivers/isdn/isdnloop/isdnloop.c
--- linux-2.6.13.1.org/drivers/isdn/isdnloop/isdnloop.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/isdnloop/isdnloop.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISDN low-level module implementing a dummy loop driver.
  *
@@ -16,7 +16,7 @@
 #include <linux/sched.h>
 #include "isdnloop.h"
 
-static char *revision = "$Revision$";
+static char *revision = "$Revision$";
 static char *isdnloop_id = "loop0";
 
 MODULE_DESCRIPTION("ISDN4Linux: Pseudo Driver that simulates an ISDN card");
diff -Nur linux-2.6.13.1.org/drivers/isdn/isdnloop/isdnloop.h grsecurity226/drivers/isdn/isdnloop/isdnloop.h
--- linux-2.6.13.1.org/drivers/isdn/isdnloop/isdnloop.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/isdnloop/isdnloop.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Loopback lowlevel module for testing of linklevel.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/card.h grsecurity226/drivers/isdn/sc/card.h
--- linux-2.6.13.1.org/drivers/isdn/sc/card.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/card.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Driver parameters for SpellCaster ISA ISDN adapters
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/command.c grsecurity226/drivers/isdn/sc/command.c
--- linux-2.6.13.1.org/drivers/isdn/sc/command.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/command.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright (C) 1996  SpellCaster Telecommunications Inc.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/debug.h grsecurity226/drivers/isdn/sc/debug.h
--- linux-2.6.13.1.org/drivers/isdn/sc/debug.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/debug.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright (C) 1996  SpellCaster Telecommunications Inc.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/event.c grsecurity226/drivers/isdn/sc/event.c
--- linux-2.6.13.1.org/drivers/isdn/sc/event.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/event.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright (C) 1996  SpellCaster Telecommunications Inc.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/interrupt.c grsecurity226/drivers/isdn/sc/interrupt.c
--- linux-2.6.13.1.org/drivers/isdn/sc/interrupt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/interrupt.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright (C) 1996  SpellCaster Telecommunications Inc.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/message.c grsecurity226/drivers/isdn/sc/message.c
--- linux-2.6.13.1.org/drivers/isdn/sc/message.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/message.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * functions for sending and receiving control messages
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/message.h grsecurity226/drivers/isdn/sc/message.h
--- linux-2.6.13.1.org/drivers/isdn/sc/message.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/message.h	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright (C) 1996  SpellCaster Telecommunications Inc.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/packet.c grsecurity226/drivers/isdn/sc/packet.c
--- linux-2.6.13.1.org/drivers/isdn/sc/packet.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/packet.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright (C) 1996  SpellCaster Telecommunications Inc.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/shmem.c grsecurity226/drivers/isdn/sc/shmem.c
--- linux-2.6.13.1.org/drivers/isdn/sc/shmem.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/shmem.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright (C) 1996  SpellCaster Telecommunications Inc.
  *
diff -Nur linux-2.6.13.1.org/drivers/isdn/sc/timer.c grsecurity226/drivers/isdn/sc/timer.c
--- linux-2.6.13.1.org/drivers/isdn/sc/timer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/isdn/sc/timer.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright (C) 1996  SpellCaster Telecommunications Inc.
  *
diff -Nur linux-2.6.13.1.org/drivers/md/mktables.c grsecurity226/drivers/md/mktables.c
--- linux-2.6.13.1.org/drivers/md/mktables.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/md/mktables.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,4 +1,4 @@
-#ident "$Id$"
+#ident "$Id$"
 /* ----------------------------------------------------------------------- *
  *
  *   Copyright 2002 H. Peter Anvin - All Rights Reserved
diff -Nur linux-2.6.13.1.org/drivers/media/common/ir-common.c grsecurity226/drivers/media/common/ir-common.c
--- linux-2.6.13.1.org/drivers/media/common/ir-common.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/common/ir-common.c	2005-08-30 01:00:09.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * some common structs and functions to handle infrared remotes via
  * input layer ...
diff -Nur linux-2.6.13.1.org/drivers/media/radio/radio-gemtek-pci.c grsecurity226/drivers/media/radio/radio-gemtek-pci.c
--- linux-2.6.13.1.org/drivers/media/radio/radio-gemtek-pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/radio/radio-gemtek-pci.c	2005-08-30 01:00:10.000000000 +0200
@@ -85,7 +85,7 @@
 	u8  mute;
 };
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 static int nr_radio = -1;
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/Kconfig grsecurity226/drivers/media/video/Kconfig
--- linux-2.6.13.1.org/drivers/media/video/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/Kconfig	2005-08-30 01:00:10.000000000 +0200
@@ -254,7 +254,6 @@
 	select VIDEO_BUF_DVB
 	select DVB_MT352
 	select DVB_CX22702
-	select DVB_TDA1004X
 	---help---
 	  This adds support for DVB cards based on the
 	  Philips saa7134 chip.
diff -Nur linux-2.6.13.1.org/drivers/media/video/btcx-risc.c grsecurity226/drivers/media/video/btcx-risc.c
--- linux-2.6.13.1.org/drivers/media/video/btcx-risc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/btcx-risc.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     btcx-risc.c
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/btcx-risc.h grsecurity226/drivers/media/video/btcx-risc.h
--- linux-2.6.13.1.org/drivers/media/video/btcx-risc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/btcx-risc.h	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 struct btcx_riscmem {
 	unsigned int   size;
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttv-cards.c grsecurity226/drivers/media/video/bttv-cards.c
--- linux-2.6.13.1.org/drivers/media/video/bttv-cards.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttv-cards.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     bttv-cards.c
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttv-driver.c grsecurity226/drivers/media/video/bttv-driver.c
--- linux-2.6.13.1.org/drivers/media/video/bttv-driver.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttv-driver.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     bttv - Bt848 frame grabber driver
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttv-gpio.c grsecurity226/drivers/media/video/bttv-gpio.c
--- linux-2.6.13.1.org/drivers/media/video/bttv-gpio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttv-gpio.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     bttv-gpio.c  --  gpio sub drivers
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttv-i2c.c grsecurity226/drivers/media/video/bttv-i2c.c
--- linux-2.6.13.1.org/drivers/media/video/bttv-i2c.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttv-i2c.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     bttv-i2c.c  --  all the i2c code is here
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttv-if.c grsecurity226/drivers/media/video/bttv-if.c
--- linux-2.6.13.1.org/drivers/media/video/bttv-if.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttv-if.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     bttv-if.c  --  old gpio interface to other kernel modules
                    don't use in new code, will go away in 2.7
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttv-risc.c grsecurity226/drivers/media/video/bttv-risc.c
--- linux-2.6.13.1.org/drivers/media/video/bttv-risc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttv-risc.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     bttv-risc.c  --  interfaces to other kernel modules
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttv-vbi.c grsecurity226/drivers/media/video/bttv-vbi.c
--- linux-2.6.13.1.org/drivers/media/video/bttv-vbi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttv-vbi.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     bttv - Bt848 frame grabber driver
     vbi interface
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttv.h grsecurity226/drivers/media/video/bttv.h
--- linux-2.6.13.1.org/drivers/media/video/bttv.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttv.h	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  bttv - Bt848 frame grabber driver
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/bttvp.h grsecurity226/drivers/media/video/bttvp.h
--- linux-2.6.13.1.org/drivers/media/video/bttvp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/bttvp.h	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     bttv - Bt848 frame grabber driver
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-blackbird.c grsecurity226/drivers/media/video/cx88/cx88-blackbird.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-blackbird.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-blackbird.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Support for a cx23416 mpeg encoder via cx2388x host port.
  *  "blackbird" reference design.
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-cards.c grsecurity226/drivers/media/video/cx88/cx88-cards.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-cards.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-cards.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for Conexant 2388x based TV cards
  * card-specific stuff.
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-core.c grsecurity226/drivers/media/video/cx88/cx88-core.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-core.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for Conexant 2388x based TV cards
  * driver core
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-dvb.c grsecurity226/drivers/media/video/cx88/cx88-dvb.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-dvb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-dvb.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for Conexant 2388x based TV cards
  * MPEG Transport Stream (DVB) routines
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-i2c.c grsecurity226/drivers/media/video/cx88/cx88-i2c.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-i2c.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-i2c.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     cx88-i2c.c  --  all the i2c code is here
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-input.c grsecurity226/drivers/media/video/cx88/cx88-input.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-input.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-input.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Device driver for GPIO attached remote control interfaces
  * on Conexant 2388x based TV/DVB cards.
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-mpeg.c grsecurity226/drivers/media/video/cx88/cx88-mpeg.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-mpeg.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-mpeg.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Support for the mpeg transport stream transfers
  *  PCI function #2 of the cx2388x.
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-reg.h grsecurity226/drivers/media/video/cx88/cx88-reg.h
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-reg.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-reg.h	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     cx88x-hw.h - CX2388x register offsets
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-tvaudio.c grsecurity226/drivers/media/video/cx88/cx88-tvaudio.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-tvaudio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-tvaudio.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
-    $Id$
+    $Id$
 
     cx88x-audio.c - Conexant CX23880/23881 audio downstream driver driver
 
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-vbi.c grsecurity226/drivers/media/video/cx88/cx88-vbi.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-vbi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-vbi.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88-video.c grsecurity226/drivers/media/video/cx88/cx88-video.c
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88-video.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88-video.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for Conexant 2388x based TV cards
  * video4linux video interface
diff -Nur linux-2.6.13.1.org/drivers/media/video/cx88/cx88.h grsecurity226/drivers/media/video/cx88/cx88.h
--- linux-2.6.13.1.org/drivers/media/video/cx88/cx88.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/cx88/cx88.h	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * v4l2 device driver for cx2388x based TV cards
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/ir-kbd-gpio.c grsecurity226/drivers/media/video/ir-kbd-gpio.c
--- linux-2.6.13.1.org/drivers/media/video/ir-kbd-gpio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/ir-kbd-gpio.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Copyright (c) 2003 Gerd Knorr
  * Copyright (c) 2003 Pavel Machek
diff -Nur linux-2.6.13.1.org/drivers/media/video/ir-kbd-i2c.c grsecurity226/drivers/media/video/ir-kbd-i2c.c
--- linux-2.6.13.1.org/drivers/media/video/ir-kbd-i2c.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/ir-kbd-i2c.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * keyboard input driver for i2c IR remote controls
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/msp3400.h grsecurity226/drivers/media/video/msp3400.h
--- linux-2.6.13.1.org/drivers/media/video/msp3400.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/msp3400.h	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 
 #ifndef MSP3400_H
diff -Nur linux-2.6.13.1.org/drivers/media/video/mt20xx.c grsecurity226/drivers/media/video/mt20xx.c
--- linux-2.6.13.1.org/drivers/media/video/mt20xx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/mt20xx.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * i2c tv tuner chip device driver
  * controls microtune tuners, mt2032 + mt2050 at the moment.
diff -Nur linux-2.6.13.1.org/drivers/media/video/planb.c grsecurity226/drivers/media/video/planb.c
--- linux-2.6.13.1.org/drivers/media/video/planb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/planb.c	2005-08-30 01:00:10.000000000 +0200
@@ -25,7 +25,7 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/init.h>
 #include <linux/errno.h>
diff -Nur linux-2.6.13.1.org/drivers/media/video/planb.h grsecurity226/drivers/media/video/planb.h
--- linux-2.6.13.1.org/drivers/media/video/planb.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/planb.h	2005-08-30 01:00:10.000000000 +0200
@@ -26,7 +26,7 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _PLANB_H_
 #define _PLANB_H_
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa5249.c grsecurity226/drivers/media/video/saa5249.c
--- linux-2.6.13.1.org/drivers/media/video/saa5249.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa5249.c	2005-08-30 01:00:10.000000000 +0200
@@ -15,7 +15,7 @@
  *
  *	Copyright (c) 1998 Richard Guenther <richard.guenther@student.uni-tuebingen.de>
  *
- * $Id$
+ * $Id$
  *
  *	Derived From
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-cards.c grsecurity226/drivers/media/video/saa7134/saa7134-cards.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-cards.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-cards.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for philips saa7134 based TV cards
  * card-specific stuff.
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-core.c grsecurity226/drivers/media/video/saa7134/saa7134-core.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-core.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for philips saa7134 based TV cards
  * driver core
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-dvb.c grsecurity226/drivers/media/video/saa7134/saa7134-dvb.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-dvb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-dvb.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * (c) 2004 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-empress.c grsecurity226/drivers/media/video/saa7134/saa7134-empress.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-empress.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-empress.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * (c) 2004 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-i2c.c grsecurity226/drivers/media/video/saa7134/saa7134-i2c.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-i2c.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-i2c.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for philips saa7134 based TV cards
  * i2c interface support
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-input.c grsecurity226/drivers/media/video/saa7134/saa7134-input.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-input.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-input.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * handle saa7134 IR remotes via linux kernel input layer.
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-oss.c grsecurity226/drivers/media/video/saa7134/saa7134-oss.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-oss.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-oss.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for philips saa7134 based TV cards
  * oss dsp interface
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-reg.h grsecurity226/drivers/media/video/saa7134/saa7134-reg.h
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-reg.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-reg.h	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * philips saa7134 registers
  */
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-ts.c grsecurity226/drivers/media/video/saa7134/saa7134-ts.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-ts.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-ts.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for philips saa7134 based TV cards
  * video4linux video interface
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-tvaudio.c grsecurity226/drivers/media/video/saa7134/saa7134-tvaudio.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-tvaudio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-tvaudio.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for philips saa7134 based TV cards
  * tv audio decoder (fm stereo, nicam, ...)
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-vbi.c grsecurity226/drivers/media/video/saa7134/saa7134-vbi.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-vbi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-vbi.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for philips saa7134 based TV cards
  * video4linux video interface
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-video.c grsecurity226/drivers/media/video/saa7134/saa7134-video.c
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134-video.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134-video.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * device driver for philips saa7134 based TV cards
  * video4linux video interface
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134.h grsecurity226/drivers/media/video/saa7134/saa7134.h
--- linux-2.6.13.1.org/drivers/media/video/saa7134/saa7134.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7134/saa7134.h	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * v4l2 device driver for philips saa7134 based TV cards
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/saa7196.h grsecurity226/drivers/media/video/saa7196.h
--- linux-2.6.13.1.org/drivers/media/video/saa7196.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/saa7196.h	2005-08-30 01:00:10.000000000 +0200
@@ -15,7 +15,7 @@
     The default values used for PlanB are my mistakes.
 */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _SAA7196_H_
 #define _SAA7196_H_
diff -Nur linux-2.6.13.1.org/drivers/media/video/tda8290.c grsecurity226/drivers/media/video/tda8290.c
--- linux-2.6.13.1.org/drivers/media/video/tda8290.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/tda8290.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * i2c tv tuner chip device driver
  * controls the philips tda8290+75 tuner chip combo.
diff -Nur linux-2.6.13.1.org/drivers/media/video/tea5767.c grsecurity226/drivers/media/video/tea5767.c
--- linux-2.6.13.1.org/drivers/media/video/tea5767.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/tea5767.c	2005-08-30 01:00:10.000000000 +0200
@@ -2,7 +2,7 @@
  * For Philips TEA5767 FM Chip used on some TV Cards like Prolink Pixelview
  * I2C address is allways 0xC0.
  *
- * $Id$
+ * $Id$
  *
  * Copyright (c) 2005 Mauro Carvalho Chehab (mchehab@brturbo.com.br)
  * This code is placed under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/drivers/media/video/tuner-core.c grsecurity226/drivers/media/video/tuner-core.c
--- linux-2.6.13.1.org/drivers/media/video/tuner-core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/tuner-core.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * i2c tv tuner chip device driver
  * core core, i.e. kernel interfaces, registering and so on
diff -Nur linux-2.6.13.1.org/drivers/media/video/tuner-simple.c grsecurity226/drivers/media/video/tuner-simple.c
--- linux-2.6.13.1.org/drivers/media/video/tuner-simple.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/tuner-simple.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * i2c tv tuner chip device driver
  * controls all those simple 4-control-bytes style tuners.
diff -Nur linux-2.6.13.1.org/drivers/media/video/tvmixer.c grsecurity226/drivers/media/video/tvmixer.c
--- linux-2.6.13.1.org/drivers/media/video/tvmixer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/tvmixer.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/media/video/v4l1-compat.c grsecurity226/drivers/media/video/v4l1-compat.c
--- linux-2.6.13.1.org/drivers/media/video/v4l1-compat.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/v4l1-compat.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *	Video for Linux Two
  *	Backward Compatibility Layer
diff -Nur linux-2.6.13.1.org/drivers/media/video/video-buf-dvb.c grsecurity226/drivers/media/video/video-buf-dvb.c
--- linux-2.6.13.1.org/drivers/media/video/video-buf-dvb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/video-buf-dvb.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * some helper function for simple DVB cards which simply DMA the
  * complete transport stream and let the computer sort everything else
diff -Nur linux-2.6.13.1.org/drivers/media/video/video-buf.c grsecurity226/drivers/media/video/video-buf.c
--- linux-2.6.13.1.org/drivers/media/video/video-buf.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/video-buf.c	2005-08-30 01:00:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * generic helper functions for video4linux capture buffers, to handle
  * memory management and PCI DMA.  Right now bttv + saa7134 use it.
diff -Nur linux-2.6.13.1.org/drivers/media/video/videocodec.c grsecurity226/drivers/media/video/videocodec.c
--- linux-2.6.13.1.org/drivers/media/video/videocodec.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/videocodec.c	2005-08-30 01:00:10.000000000 +0200
@@ -6,7 +6,7 @@
  *
  * (c) 2002 Wolfgang Scherr <scherr@net4you.at>
  *
- * $Id$
+ * $Id$
  *
  * ------------------------------------------------------------------------
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/videocodec.h grsecurity226/drivers/media/video/videocodec.h
--- linux-2.6.13.1.org/drivers/media/video/videocodec.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/videocodec.h	2005-08-30 01:00:10.000000000 +0200
@@ -6,7 +6,7 @@
  *
  * (c) 2002 Wolfgang Scherr <scherr@net4you.at>
  *
- * $Id$
+ * $Id$
  *
  * ------------------------------------------------------------------------
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/zr36016.c grsecurity226/drivers/media/video/zr36016.c
--- linux-2.6.13.1.org/drivers/media/video/zr36016.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/zr36016.c	2005-08-30 01:00:10.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2001 Wolfgang Scherr <scherr@net4you.at>
  *
- * $Id$
+ * $Id$
  *
  * ------------------------------------------------------------------------
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/zr36016.h grsecurity226/drivers/media/video/zr36016.h
--- linux-2.6.13.1.org/drivers/media/video/zr36016.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/zr36016.h	2005-08-30 01:00:10.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2001 Wolfgang Scherr <scherr@net4you.at>
  *
- * $Id$
+ * $Id$
  *
  * ------------------------------------------------------------------------
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/zr36050.c grsecurity226/drivers/media/video/zr36050.c
--- linux-2.6.13.1.org/drivers/media/video/zr36050.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/zr36050.c	2005-08-30 01:00:10.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2001 Wolfgang Scherr <scherr@net4you.at>
  *
- * $Id$
+ * $Id$
  *
  * ------------------------------------------------------------------------
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/zr36050.h grsecurity226/drivers/media/video/zr36050.h
--- linux-2.6.13.1.org/drivers/media/video/zr36050.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/zr36050.h	2005-08-30 01:00:10.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2001 Wolfgang Scherr <scherr@net4you.at>
  *
- * $Id$
+ * $Id$
  *
  * ------------------------------------------------------------------------
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/zr36060.c grsecurity226/drivers/media/video/zr36060.c
--- linux-2.6.13.1.org/drivers/media/video/zr36060.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/zr36060.c	2005-08-30 01:00:10.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2002 Laurent Pinchart <laurent.pinchart@skynet.be>
  *
- * $Id$
+ * $Id$
  *
  * ------------------------------------------------------------------------
  *
diff -Nur linux-2.6.13.1.org/drivers/media/video/zr36060.h grsecurity226/drivers/media/video/zr36060.h
--- linux-2.6.13.1.org/drivers/media/video/zr36060.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/media/video/zr36060.h	2005-08-30 01:00:10.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2002 Laurent Pinchart <laurent.pinchart@skynet.be>
  *
- * $Id$
+ * $Id$
  *
  * ------------------------------------------------------------------------
  *
diff -Nur linux-2.6.13.1.org/drivers/message/fusion/lsi/fc_log.h grsecurity226/drivers/message/fusion/lsi/fc_log.h
--- linux-2.6.13.1.org/drivers/message/fusion/lsi/fc_log.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/message/fusion/lsi/fc_log.h	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  *                  in the IOCLogInfo field of a MPI Default Reply Message.
  *
  *  CREATION DATE:  6/02/2000
- *  ID:             $Id$
+ *  ID:             $Id$
  */
 
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/Kconfig grsecurity226/drivers/mtd/Kconfig
--- linux-2.6.13.1.org/drivers/mtd/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/Kconfig	2005-08-30 01:00:11.000000000 +0200
@@ -1,4 +1,4 @@
-# $Id$
+# $Id$
 
 menu "Memory Technology Devices (MTD)"
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/Makefile grsecurity226/drivers/mtd/Makefile
--- linux-2.6.13.1.org/drivers/mtd/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/Makefile	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Makefile for the memory technology device drivers.
 #
-# $Id$
+# $Id$
 
 # Core functionality.
 mtd-y				:= mtdcore.o
diff -Nur linux-2.6.13.1.org/drivers/mtd/afs.c grsecurity226/drivers/mtd/afs.c
--- linux-2.6.13.1.org/drivers/mtd/afs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/afs.c	2005-08-30 01:00:11.000000000 +0200
@@ -21,7 +21,7 @@
    This is access code for flashes using ARM's flash partitioning 
    standards.
 
-   $Id$
+   $Id$
 
 ======================================================================*/
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/Kconfig grsecurity226/drivers/mtd/chips/Kconfig
--- linux-2.6.13.1.org/drivers/mtd/chips/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/Kconfig	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 # drivers/mtd/chips/Kconfig
-# $Id$
+# $Id$
 
 menu "RAM/ROM/Flash chip drivers"
 	depends on MTD!=n
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/Makefile grsecurity226/drivers/mtd/chips/Makefile
--- linux-2.6.13.1.org/drivers/mtd/chips/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/Makefile	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # linux/drivers/chips/Makefile
 #
-# $Id$
+# $Id$
 
 #                       *** BIG UGLY NOTE ***
 #
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/amd_flash.c grsecurity226/drivers/mtd/chips/amd_flash.c
--- linux-2.6.13.1.org/drivers/mtd/chips/amd_flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/amd_flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Author: Jonas Holmberg <jonas.holmberg@axis.com>
  *
- * $Id$
+ * $Id$
  *
  * Copyright (c) 2001 Axis Communications AB
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/cfi_cmdset_0001.c grsecurity226/drivers/mtd/chips/cfi_cmdset_0001.c
--- linux-2.6.13.1.org/drivers/mtd/chips/cfi_cmdset_0001.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/cfi_cmdset_0001.c	2005-08-30 01:00:11.000000000 +0200
@@ -4,7 +4,7 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id$
+ * $Id$
  *
  * 
  * 10/10/2000	Nicolas Pitre <nico@cam.org>
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/cfi_cmdset_0002.c grsecurity226/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.6.13.1.org/drivers/mtd/chips/cfi_cmdset_0002.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/cfi_cmdset_0002.c	2005-08-30 01:00:11.000000000 +0200
@@ -17,7 +17,7 @@
  *
  * This code is GPL
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/cfi_cmdset_0020.c grsecurity226/drivers/mtd/chips/cfi_cmdset_0020.c
--- linux-2.6.13.1.org/drivers/mtd/chips/cfi_cmdset_0020.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/cfi_cmdset_0020.c	2005-08-30 01:00:11.000000000 +0200
@@ -4,7 +4,7 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id$
+ * $Id$
  * 
  * 10/10/2000	Nicolas Pitre <nico@cam.org>
  * 	- completely revamped method functions so they are aware and
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/cfi_probe.c grsecurity226/drivers/mtd/chips/cfi_probe.c
--- linux-2.6.13.1.org/drivers/mtd/chips/cfi_probe.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/cfi_probe.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
    Common Flash Interface probe code.
    (C) 2000 Red Hat. GPL'd.
-   $Id$
+   $Id$
 */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/cfi_util.c grsecurity226/drivers/mtd/chips/cfi_util.c
--- linux-2.6.13.1.org/drivers/mtd/chips/cfi_util.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/cfi_util.c	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * This code is covered by the GPL.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/chipreg.c grsecurity226/drivers/mtd/chips/chipreg.c
--- linux-2.6.13.1.org/drivers/mtd/chips/chipreg.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/chipreg.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Registration for chip drivers
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/gen_probe.c grsecurity226/drivers/mtd/chips/gen_probe.c
--- linux-2.6.13.1.org/drivers/mtd/chips/gen_probe.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/gen_probe.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
  * Routines common to all CFI-type probes.
  * (C) 2001-2003 Red Hat, Inc.
  * GPL'd
- * $Id$
+ * $Id$
  */
 
 #include <linux/kernel.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/jedec.c grsecurity226/drivers/mtd/chips/jedec.c
--- linux-2.6.13.1.org/drivers/mtd/chips/jedec.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/jedec.c	2005-08-30 01:00:11.000000000 +0200
@@ -11,7 +11,7 @@
  * not going to guess how to send commands to them, plus I expect they will
  * all speak CFI..
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/init.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/jedec_probe.c grsecurity226/drivers/mtd/chips/jedec_probe.c
--- linux-2.6.13.1.org/drivers/mtd/chips/jedec_probe.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/jedec_probe.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
    Common Flash Interface probe code.
    (C) 2000 Red Hat. GPL'd.
-   $Id$
+   $Id$
    See JEDEC (http://www.jedec.org/) standard JESD21C (section 3.5)
    for the standard this probe goes back to.
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/map_absent.c grsecurity226/drivers/mtd/chips/map_absent.c
--- linux-2.6.13.1.org/drivers/mtd/chips/map_absent.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/map_absent.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Common code to handle absent "placeholder" devices
  * Copyright 2001 Resilience Corporation <ebrower@resilience.com>
- * $Id$
+ * $Id$
  *
  * This map driver is used to allocate "placeholder" MTD
  * devices on systems that have socketed/removable media. 
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/map_ram.c grsecurity226/drivers/mtd/chips/map_ram.c
--- linux-2.6.13.1.org/drivers/mtd/chips/map_ram.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/map_ram.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Common code to handle map devices which are simple RAM
  * (C) 2000 Red Hat. GPL'd.
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/map_rom.c grsecurity226/drivers/mtd/chips/map_rom.c
--- linux-2.6.13.1.org/drivers/mtd/chips/map_rom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/map_rom.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Common code to handle map devices which are simple ROM
  * (C) 2000 Red Hat. GPL'd.
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/chips/sharp.c grsecurity226/drivers/mtd/chips/sharp.c
--- linux-2.6.13.1.org/drivers/mtd/chips/sharp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/chips/sharp.c	2005-08-30 01:00:11.000000000 +0200
@@ -4,7 +4,7 @@
  * Copyright 2000,2001 David A. Schleef <ds@schleef.org>
  *           2000,2001 Lineo, Inc.
  *
- * $Id$
+ * $Id$
  *
  * Devices supported:
  *   LH28F016SCT Symmetrical block flash memory, 2Mx8
diff -Nur linux-2.6.13.1.org/drivers/mtd/cmdlinepart.c grsecurity226/drivers/mtd/cmdlinepart.c
--- linux-2.6.13.1.org/drivers/mtd/cmdlinepart.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/cmdlinepart.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Read flash partition table from command line
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/Kconfig grsecurity226/drivers/mtd/devices/Kconfig
--- linux-2.6.13.1.org/drivers/mtd/devices/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/Kconfig	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 # drivers/mtd/maps/Kconfig
-# $Id$
+# $Id$
 
 menu "Self-contained MTD device drivers"
 	depends on MTD!=n
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/Makefile grsecurity226/drivers/mtd/devices/Makefile
--- linux-2.6.13.1.org/drivers/mtd/devices/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/Makefile	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # linux/drivers/devices/Makefile
 #
-# $Id$
+# $Id$
 
 #                       *** BIG UGLY NOTE ***
 #
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/blkmtd.c grsecurity226/drivers/mtd/devices/blkmtd.c
--- linux-2.6.13.1.org/drivers/mtd/devices/blkmtd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/blkmtd.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * blkmtd.c - use a block device as a fake MTD
  *
@@ -39,7 +39,7 @@
 
 /* Default erase size in K, always make it a multiple of PAGE_SIZE */
 #define CONFIG_MTD_BLKDEV_ERASESIZE (128 << 10)	/* 128KiB */
-#define VERSION "$Revision$"
+#define VERSION "$Revision$"
 
 /* Info for the block device */
 struct blkmtd_dev {
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/block2mtd.c grsecurity226/drivers/mtd/devices/block2mtd.c
--- linux-2.6.13.1.org/drivers/mtd/devices/block2mtd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/block2mtd.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * block2mtd.c - create an mtd from a block device
  *
@@ -19,7 +19,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/buffer_head.h>
 
-#define VERSION "$Revision$"
+#define VERSION "$Revision$"
 
 
 #define ERROR(fmt, args...) printk(KERN_ERR "block2mtd: " fmt "\n" , ## args)
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/doc2000.c grsecurity226/drivers/mtd/devices/doc2000.c
--- linux-2.6.13.1.org/drivers/mtd/devices/doc2000.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/doc2000.c	2005-08-30 01:00:11.000000000 +0200
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/kernel.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/doc2001.c grsecurity226/drivers/mtd/devices/doc2001.c
--- linux-2.6.13.1.org/drivers/mtd/devices/doc2001.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/doc2001.c	2005-08-30 01:13:57.000000000 +0200
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/kernel.h>
@@ -423,6 +423,8 @@
 	/* Don't allow read past end of device */
 	if (from >= this->totlen)
 		return -EINVAL;
+	if (!len)
+		return -EINVAL;
 
 	/* Don't allow a single read to cross a 512-byte block boundary */
 	if (from + len > ((from | 0x1ff) + 1)) 
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/doc2001plus.c grsecurity226/drivers/mtd/devices/doc2001plus.c
--- linux-2.6.13.1.org/drivers/mtd/devices/doc2001plus.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/doc2001plus.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id$
+ * $Id$
  *
  * Released under GPL
  */
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/docecc.c grsecurity226/drivers/mtd/devices/docecc.c
--- linux-2.6.13.1.org/drivers/mtd/devices/docecc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/docecc.c	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/docprobe.c grsecurity226/drivers/mtd/devices/docprobe.c
--- linux-2.6.13.1.org/drivers/mtd/devices/docprobe.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/docprobe.c	2005-08-30 01:00:11.000000000 +0200
@@ -4,7 +4,7 @@
 /* (C) 1999 Machine Vision Holdings, Inc.			*/
 /* (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>		*/
 
-/* $Id$	*/
+/* $Id$	*/
 
 
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/lart.c grsecurity226/drivers/mtd/devices/lart.c
--- linux-2.6.13.1.org/drivers/mtd/devices/lart.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/lart.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
 /*
  * MTD driver for the 28F160F3 Flash Memory (non-CFI) on LART.
  *
- * $Id$
+ * $Id$
  *
  * Author: Abraham vd Merwe <abraham@2d3d.co.za>
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/ms02-nv.c grsecurity226/drivers/mtd/devices/ms02-nv.c
--- linux-2.6.13.1.org/drivers/mtd/devices/ms02-nv.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/ms02-nv.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  *
- *	$Id$
+ *	$Id$
  */
 
 #include <linux/init.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/ms02-nv.h grsecurity226/drivers/mtd/devices/ms02-nv.h
--- linux-2.6.13.1.org/drivers/mtd/devices/ms02-nv.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/ms02-nv.h	2005-08-30 01:00:11.000000000 +0200
@@ -10,7 +10,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  *
- *	$Id$
+ *	$Id$
  */
 
 #include <linux/ioport.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/mtdram.c grsecurity226/drivers/mtd/devices/mtdram.c
--- linux-2.6.13.1.org/drivers/mtd/devices/mtdram.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/mtdram.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * mtdram - a test mtd device
- * $Id$
+ * $Id$
  * Author: Alexander Larsson <alex@cendio.se>
  *
  * Copyright (c) 1999 Alexander Larsson <alex@cendio.se>
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/phram.c grsecurity226/drivers/mtd/devices/phram.c
--- linux-2.6.13.1.org/drivers/mtd/devices/phram.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/phram.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * $Id$
+ * $Id$
  *
  * Copyright (c) ????		Jochen Schuble <psionic@psionic.de>
  * Copyright (c) 2003-2004	Jrn Engel <joern@wh.fh-wedel.de>
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/pmc551.c grsecurity226/drivers/mtd/devices/pmc551.c
--- linux-2.6.13.1.org/drivers/mtd/devices/pmc551.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/pmc551.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * PMC551 PCI Mezzanine Ram Device
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/devices/slram.c grsecurity226/drivers/mtd/devices/slram.c
--- linux-2.6.13.1.org/drivers/mtd/devices/slram.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/devices/slram.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,6 +1,6 @@
 /*======================================================================
 
-  $Id$
+  $Id$
 
   This driver provides a method to access memory not used by the kernel
   itself (i.e. if the kernel commandline mem=xxx is used). To actually
diff -Nur linux-2.6.13.1.org/drivers/mtd/ftl.c grsecurity226/drivers/mtd/ftl.c
--- linux-2.6.13.1.org/drivers/mtd/ftl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/ftl.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- * $Id$
+ * $Id$
  *
  * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
@@ -1097,7 +1097,7 @@
 
 int init_ftl(void)
 {
-	DEBUG(0, "$Id$\n");
+	DEBUG(0, "$Id$\n");
 
 	return register_mtd_blktrans(&ftl_tr);
 }
diff -Nur linux-2.6.13.1.org/drivers/mtd/inftlcore.c grsecurity226/drivers/mtd/inftlcore.c
--- linux-2.6.13.1.org/drivers/mtd/inftlcore.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/inftlcore.c	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * Author: David Woodhouse <dwmw2@infradead.org>
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -893,7 +893,7 @@
 
 static int __init init_inftl(void)
 {
-	printk(KERN_INFO "INFTL: inftlcore.c $Revision$, "
+	printk(KERN_INFO "INFTL: inftlcore.c $Revision$, "
 		"inftlmount.c %s\n", inftlmountrev);
 
 	return register_mtd_blktrans(&inftl_tr);
diff -Nur linux-2.6.13.1.org/drivers/mtd/inftlmount.c grsecurity226/drivers/mtd/inftlmount.c
--- linux-2.6.13.1.org/drivers/mtd/inftlmount.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/inftlmount.c	2005-08-30 01:00:11.000000000 +0200
@@ -8,7 +8,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -41,7 +41,7 @@
 #include <linux/mtd/inftl.h>
 #include <linux/mtd/compatmac.h>
 
-char inftlmountrev[]="$Revision$";
+char inftlmountrev[]="$Revision$";
 
 /*
  * find_boot_record: Find the INFTL Media Header and its Spare copy which
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/Kconfig grsecurity226/drivers/mtd/maps/Kconfig
--- linux-2.6.13.1.org/drivers/mtd/maps/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/Kconfig	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 # drivers/mtd/maps/Kconfig
-# $Id$
+# $Id$
 
 menu "Mapping drivers for chip access"
 	depends on MTD!=n
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/Makefile grsecurity226/drivers/mtd/maps/Makefile
--- linux-2.6.13.1.org/drivers/mtd/maps/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/Makefile	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # linux/drivers/maps/Makefile
 #
-# $Id$
+# $Id$
 
 ifeq ($(CONFIG_MTD_COMPLEX_MAPPINGS),y)
 obj-$(CONFIG_MTD)		+= map_funcs.o
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/alchemy-flash.c grsecurity226/drivers/mtd/maps/alchemy-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/alchemy-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/alchemy-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Flash memory access on AMD Alchemy evaluation boards
  * 
- * $Id$
+ * $Id$
  *
  * (C) 2003, 2004 Pete Popov <ppopov@embeddedalley.com>
  * 
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/amd76xrom.c grsecurity226/drivers/mtd/maps/amd76xrom.c
--- linux-2.6.13.1.org/drivers/mtd/maps/amd76xrom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/amd76xrom.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
  * amd76xrom.c
  *
  * Normal mappings of chips in physical memory
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/arctic-mtd.c grsecurity226/drivers/mtd/maps/arctic-mtd.c
--- linux-2.6.13.1.org/drivers/mtd/maps/arctic-mtd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/arctic-mtd.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  * 
  * drivers/mtd/maps/arctic-mtd.c MTD mappings and partition tables for 
  *                              IBM 405LP Arctic boards.
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/autcpu12-nvram.c grsecurity226/drivers/mtd/maps/autcpu12-nvram.c
--- linux-2.6.13.1.org/drivers/mtd/maps/autcpu12-nvram.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/autcpu12-nvram.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
  * NV-RAM memory access on autcpu12 
  * (C) 2002 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id$ 
+ * $Id$ 
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/bast-flash.c grsecurity226/drivers/mtd/maps/bast-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/bast-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/bast-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -9,7 +9,7 @@
  *	20-Sep-2004  BJD  Initial version
  *	17-Jan-2005  BJD  Add whole device if no partitions found
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/beech-mtd.c grsecurity226/drivers/mtd/maps/beech-mtd.c
--- linux-2.6.13.1.org/drivers/mtd/maps/beech-mtd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/beech-mtd.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  * 
  * drivers/mtd/maps/beech-mtd.c MTD mappings and partition tables for 
  *                              IBM 405LP Beech boards.
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/cdb89712.c grsecurity226/drivers/mtd/maps/cdb89712.c
--- linux-2.6.13.1.org/drivers/mtd/maps/cdb89712.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/cdb89712.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Flash on Cirrus CDB89712
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/ceiva.c grsecurity226/drivers/mtd/maps/ceiva.c
--- linux-2.6.13.1.org/drivers/mtd/maps/ceiva.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/ceiva.c	2005-08-30 01:00:11.000000000 +0200
@@ -11,7 +11,7 @@
  *
  * (C) 2000 Nicolas Pitre <nico@cam.org>
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/cfi_flagadm.c grsecurity226/drivers/mtd/maps/cfi_flagadm.c
--- linux-2.6.13.1.org/drivers/mtd/maps/cfi_flagadm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/cfi_flagadm.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  Copyright  2001 Flaga hf. Medical Devices, Kri Davsson <kd@flaga.is>
  *
- *  $Id$
+ *  $Id$
  *  
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/cstm_mips_ixx.c grsecurity226/drivers/mtd/maps/cstm_mips_ixx.c
--- linux-2.6.13.1.org/drivers/mtd/maps/cstm_mips_ixx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/cstm_mips_ixx.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Mapping of a custom board with both AMD CFI and JEDEC flash in partitions.
  * Config with both CFI and JEDEC device support.
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/dbox2-flash.c grsecurity226/drivers/mtd/maps/dbox2-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/dbox2-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/dbox2-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * D-Box 2 flash driver
  */
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/dc21285.c grsecurity226/drivers/mtd/maps/dc21285.c
--- linux-2.6.13.1.org/drivers/mtd/maps/dc21285.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/dc21285.c	2005-08-30 01:00:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  * 
- * $Id$
+ * $Id$
  */
 #include <linux/config.h>
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/dilnetpc.c grsecurity226/drivers/mtd/maps/dilnetpc.c
--- linux-2.6.13.1.org/drivers/mtd/maps/dilnetpc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/dilnetpc.c	2005-08-30 01:00:11.000000000 +0200
@@ -14,7 +14,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  *
- * $Id$
+ * $Id$
  *
  * The DIL/Net PC is a tiny embedded PC board made by SSV Embedded Systems
  * featuring the AMD Elan SC410 processor. There are two variants of this
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/dmv182.c grsecurity226/drivers/mtd/maps/dmv182.c
--- linux-2.6.13.1.org/drivers/mtd/maps/dmv182.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/dmv182.c	2005-08-30 01:00:11.000000000 +0200
@@ -4,7 +4,7 @@
  * 
  * Flash map driver for the Dy4 SVME182 board
  * 
- * $Id$
+ * $Id$
  *
  * Copyright 2003-2004, TimeSys Corporation
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/ebony.c grsecurity226/drivers/mtd/maps/ebony.c
--- linux-2.6.13.1.org/drivers/mtd/maps/ebony.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/ebony.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  * 
  * Mapping for Ebony user flash
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/edb7312.c grsecurity226/drivers/mtd/maps/edb7312.c
--- linux-2.6.13.1.org/drivers/mtd/maps/edb7312.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/edb7312.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Handle mapping of the NOR flash on Cogent EDB7312 boards
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/epxa10db-flash.c grsecurity226/drivers/mtd/maps/epxa10db-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/epxa10db-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/epxa10db-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -5,7 +5,7 @@
  *  Copyright (C) 2001 Altera Corporation
  *  Copyright (C) 2001 Red Hat, Inc.
  *
- * $Id$ 
+ * $Id$ 
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/fortunet.c grsecurity226/drivers/mtd/maps/fortunet.c
--- linux-2.6.13.1.org/drivers/mtd/maps/fortunet.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/fortunet.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,6 +1,6 @@
 /* fortunet.c memory map
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/h720x-flash.c grsecurity226/drivers/mtd/maps/h720x-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/h720x-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/h720x-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
  * Flash memory access on Hynix GMS30C7201/HMS30C7202 based 
  * evaluation boards
  * 
- * $Id$
+ * $Id$
  *
  * (C) 2002 Jungjun Kim <jungjun.kim@hynix.com>
  *     2003 Thomas Gleixner <tglx@linutronix.de>	
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/ichxrom.c grsecurity226/drivers/mtd/maps/ichxrom.c
--- linux-2.6.13.1.org/drivers/mtd/maps/ichxrom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/ichxrom.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
  * ichxrom.c
  *
  * Normal mappings of chips in physical memory
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/impa7.c grsecurity226/drivers/mtd/maps/impa7.c
--- linux-2.6.13.1.org/drivers/mtd/maps/impa7.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/impa7.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Handle mapping of the NOR flash on implementa A7 boards
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/integrator-flash.c grsecurity226/drivers/mtd/maps/integrator-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/integrator-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/integrator-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -22,7 +22,7 @@
    This is access code for flashes using ARM's flash partitioning 
    standards.
 
-   $Id$
+   $Id$
 
 ======================================================================*/
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/ipaq-flash.c grsecurity226/drivers/mtd/maps/ipaq-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/ipaq-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/ipaq-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -5,7 +5,7 @@
  * (C) 2002 Hewlett-Packard Company <jamey.hicks@hp.com>
  * (C) 2003 Christian Pellegrin <chri@ascensit.com>, <chri@infis.univ.ts.it>: concatenation of multiple flashes
  * 
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/iq80310.c grsecurity226/drivers/mtd/maps/iq80310.c
--- linux-2.6.13.1.org/drivers/mtd/maps/iq80310.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/iq80310.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Mapping for the Intel XScale IQ80310 evaluation board
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/ixp2000.c grsecurity226/drivers/mtd/maps/ixp2000.c
--- linux-2.6.13.1.org/drivers/mtd/maps/ixp2000.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/ixp2000.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * drivers/mtd/maps/ixp2000.c
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/ixp4xx.c grsecurity226/drivers/mtd/maps/ixp4xx.c
--- linux-2.6.13.1.org/drivers/mtd/maps/ixp4xx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/ixp4xx.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * drivers/mtd/maps/ixp4xx.c
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/l440gx.c grsecurity226/drivers/mtd/maps/l440gx.c
--- linux-2.6.13.1.org/drivers/mtd/maps/l440gx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/l440gx.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * BIOS Flash chip on Intel 440GX board.
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/lasat.c grsecurity226/drivers/mtd/maps/lasat.c
--- linux-2.6.13.1.org/drivers/mtd/maps/lasat.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/lasat.c	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  * modify it under the terms of the GNU General Public License version
  * 2 as published by the Free Software Foundation.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/lubbock-flash.c grsecurity226/drivers/mtd/maps/lubbock-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/lubbock-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/lubbock-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Map driver for the Lubbock developer platform.
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/mainstone-flash.c grsecurity226/drivers/mtd/maps/mainstone-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/mainstone-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/mainstone-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Map driver for the Mainstone developer platform.
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/map_funcs.c grsecurity226/drivers/mtd/maps/map_funcs.c
--- linux-2.6.13.1.org/drivers/mtd/maps/map_funcs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/map_funcs.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Out-of-line map I/O functions for simple maps when CONFIG_COMPLEX_MAPPINGS
  * is enabled.
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/mbx860.c grsecurity226/drivers/mtd/maps/mbx860.c
--- linux-2.6.13.1.org/drivers/mtd/maps/mbx860.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/mbx860.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Handle mapping of the flash on MBX860 boards
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/mpc1211.c grsecurity226/drivers/mtd/maps/mpc1211.c
--- linux-2.6.13.1.org/drivers/mtd/maps/mpc1211.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/mpc1211.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Flash on MPC-1211
  *
- * $Id$
+ * $Id$
  *
  * (C) 2002 Interface, Saito.K & Jeanne
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/netsc520.c grsecurity226/drivers/mtd/maps/netsc520.c
--- linux-2.6.13.1.org/drivers/mtd/maps/netsc520.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/netsc520.c	2005-08-30 01:00:11.000000000 +0200
@@ -3,7 +3,7 @@
  * Copyright (C) 2001 Mark Langsdorf (mark.langsdorf@amd.com)
  *	based on sc520cdp.c by Sysgo Real-Time Solutions GmbH
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/nettel.c grsecurity226/drivers/mtd/maps/nettel.c
--- linux-2.6.13.1.org/drivers/mtd/maps/nettel.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/nettel.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  *      (C) Copyright 2000-2001, Greg Ungerer (gerg@snapgear.com)
  *      (C) Copyright 2001-2002, SnapGear (www.snapgear.com)
  *
- *	$Id$
+ *	$Id$
  */
 
 /****************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/ocelot.c grsecurity226/drivers/mtd/maps/ocelot.c
--- linux-2.6.13.1.org/drivers/mtd/maps/ocelot.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/ocelot.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Flash on Momenco Ocelot
  */
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/octagon-5066.c grsecurity226/drivers/mtd/maps/octagon-5066.c
--- linux-2.6.13.1.org/drivers/mtd/maps/octagon-5066.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/octagon-5066.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,4 +1,4 @@
-// $Id$
+// $Id$
 /* ######################################################################
 
    Octagon 5066 MTD Driver. 
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/omap-toto-flash.c grsecurity226/drivers/mtd/maps/omap-toto-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/omap-toto-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/omap-toto-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *  (C) 2002 MontVista Software, Inc.
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/pci.c grsecurity226/drivers/mtd/maps/pci.c
--- linux-2.6.13.1.org/drivers/mtd/maps/pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/pci.c	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- *  $Id$
+ *  $Id$
  * 
  * Generic PCI memory map driver.  We support the following boards:
  *  - Intel IQ80310 ATU.
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/pcmciamtd.c grsecurity226/drivers/mtd/maps/pcmciamtd.c
--- linux-2.6.13.1.org/drivers/mtd/maps/pcmciamtd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/pcmciamtd.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * pcmciamtd.c - MTD driver for PCMCIA flash memory cards
  *
@@ -48,7 +48,7 @@
 
 
 #define DRIVER_DESC	"PCMCIA Flash memory card driver"
-#define DRIVER_VERSION	"$Revision$"
+#define DRIVER_VERSION	"$Revision$"
 
 /* Size of the PCMCIA address space: 26 bits = 64 MB */
 #define MAX_PCMCIA_ADDR	0x4000000
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/physmap.c grsecurity226/drivers/mtd/maps/physmap.c
--- linux-2.6.13.1.org/drivers/mtd/maps/physmap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/physmap.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Normal mappings of chips in physical memory
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/plat-ram.c grsecurity226/drivers/mtd/maps/plat-ram.c
--- linux-2.6.13.1.org/drivers/mtd/maps/plat-ram.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/plat-ram.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  *
  * Generic platfrom device based RAM map
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/pnc2000.c grsecurity226/drivers/mtd/maps/pnc2000.c
--- linux-2.6.13.1.org/drivers/mtd/maps/pnc2000.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/pnc2000.c	2005-08-30 01:00:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/redwood.c grsecurity226/drivers/mtd/maps/redwood.c
--- linux-2.6.13.1.org/drivers/mtd/maps/redwood.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/redwood.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * drivers/mtd/maps/redwood.c
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/rpxlite.c grsecurity226/drivers/mtd/maps/rpxlite.c
--- linux-2.6.13.1.org/drivers/mtd/maps/rpxlite.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/rpxlite.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Handle mapping of the flash on the RPX Lite and CLLF boards
  */
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/sa1100-flash.c grsecurity226/drivers/mtd/maps/sa1100-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/sa1100-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/sa1100-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -3,7 +3,7 @@
  * 
  * (C) 2000 Nicolas Pitre <nico@cam.org>
  * 
- * $Id$
+ * $Id$
  */
 #include <linux/config.h>
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/sbc8240.c grsecurity226/drivers/mtd/maps/sbc8240.c
--- linux-2.6.13.1.org/drivers/mtd/maps/sbc8240.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/sbc8240.c	2005-08-30 01:00:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPLed
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/sbc_gxx.c grsecurity226/drivers/mtd/maps/sbc_gxx.c
--- linux-2.6.13.1.org/drivers/mtd/maps/sbc_gxx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/sbc_gxx.c	2005-08-30 01:00:11.000000000 +0200
@@ -17,7 +17,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 
-   $Id$
+   $Id$
 
 The SBC-MediaGX / SBC-GXx has up to 16 MiB of 
 Intel StrataFlash (28F320/28F640) in x8 mode.  
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/sc520cdp.c grsecurity226/drivers/mtd/maps/sc520cdp.c
--- linux-2.6.13.1.org/drivers/mtd/maps/sc520cdp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/sc520cdp.c	2005-08-30 01:00:11.000000000 +0200
@@ -16,7 +16,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  *
- * $Id$
+ * $Id$
  *
  *
  * The SC520CDP is an evaluation board for the Elan SC520 processor available
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/scb2_flash.c grsecurity226/drivers/mtd/maps/scb2_flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/scb2_flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/scb2_flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * MTD map driver for BIOS Flash on Intel SCB2 boards
- * $Id$
+ * $Id$
  * Copyright (C) 2002 Sun Microsystems, Inc.
  * Tim Hockin <thockin@sun.com>
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/scx200_docflash.c grsecurity226/drivers/mtd/maps/scx200_docflash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/scx200_docflash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/scx200_docflash.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
 
    Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>
 
-   $Id$ 
+   $Id$ 
 
    National Semiconductor SCx200 flash mapped with DOCCS
 */
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/sharpsl-flash.c grsecurity226/drivers/mtd/maps/sharpsl-flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/sharpsl-flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/sharpsl-flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -4,7 +4,7 @@
  * Copyright (C) 2001 Lineo Japan, Inc.
  * Copyright (C) 2002  SHARP
  *
- * $Id$
+ * $Id$
  *
  * based on rpxlite.c,v 1.15 2001/10/02 15:05:14 dwmw2 Exp
  *          Handle mapping of the flash on the RPX Lite and CLLF boards
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/solutionengine.c grsecurity226/drivers/mtd/maps/solutionengine.c
--- linux-2.6.13.1.org/drivers/mtd/maps/solutionengine.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/solutionengine.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Flash and EPROM on Hitachi Solution Engine and similar boards.
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/sun_uflash.c grsecurity226/drivers/mtd/maps/sun_uflash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/sun_uflash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/sun_uflash.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * sun_uflash - Driver implementation for user-programmable flash
  * present on many Sun Microsystems SME boardsets.
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/tqm8xxl.c grsecurity226/drivers/mtd/maps/tqm8xxl.c
--- linux-2.6.13.1.org/drivers/mtd/maps/tqm8xxl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/tqm8xxl.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
  * Handle mapping of the flash memory access routines 
  * on TQM8xxL based devices.
  *
- * $Id$
+ * $Id$
  *
  * based on rpxlite.c
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/ts5500_flash.c grsecurity226/drivers/mtd/maps/ts5500_flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/ts5500_flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/ts5500_flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -25,7 +25,7 @@
  * - If you have created your own jffs file system and the bios overwrites 
  *   it during boot, try disabling Drive A: and B: in the boot order.
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/tsunami_flash.c grsecurity226/drivers/mtd/maps/tsunami_flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/tsunami_flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/tsunami_flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -2,7 +2,7 @@
  * tsunami_flash.c
  *
  * flash chip on alpha ds10...
- * $Id$
+ * $Id$
  */
 #include <asm/io.h>
 #include <asm/core_tsunami.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/uclinux.c grsecurity226/drivers/mtd/maps/uclinux.c
--- linux-2.6.13.1.org/drivers/mtd/maps/uclinux.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/uclinux.c	2005-08-30 01:00:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *	(C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
  *
- * 	$Id$
+ * 	$Id$
  */
 
 /****************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/vmax301.c grsecurity226/drivers/mtd/maps/vmax301.c
--- linux-2.6.13.1.org/drivers/mtd/maps/vmax301.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/vmax301.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,4 +1,4 @@
-// $Id$
+// $Id$
 /* ######################################################################
 
    Tempustech VMAX SBC301 MTD Driver.
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/walnut.c grsecurity226/drivers/mtd/maps/walnut.c
--- linux-2.6.13.1.org/drivers/mtd/maps/walnut.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/walnut.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  * 
  * Mapping for Walnut flash
  * (used ebony.c as a "framework")
diff -Nur linux-2.6.13.1.org/drivers/mtd/maps/wr_sbc82xx_flash.c grsecurity226/drivers/mtd/maps/wr_sbc82xx_flash.c
--- linux-2.6.13.1.org/drivers/mtd/maps/wr_sbc82xx_flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/maps/wr_sbc82xx_flash.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Map for flash chips on Wind River PowerQUICC II SBC82xx board.
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/mtd_blkdevs.c grsecurity226/drivers/mtd/mtd_blkdevs.c
--- linux-2.6.13.1.org/drivers/mtd/mtd_blkdevs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/mtd_blkdevs.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/mtdblock.c grsecurity226/drivers/mtd/mtdblock.c
--- linux-2.6.13.1.org/drivers/mtd/mtdblock.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/mtdblock.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
  * Direct MTD block device access
  *
- * $Id$
+ * $Id$
  *
  * (C) 2000-2003 Nicolas Pitre <nico@cam.org>
  * (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>
diff -Nur linux-2.6.13.1.org/drivers/mtd/mtdblock_ro.c grsecurity226/drivers/mtd/mtdblock_ro.c
--- linux-2.6.13.1.org/drivers/mtd/mtdblock_ro.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/mtdblock_ro.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/mtdchar.c grsecurity226/drivers/mtd/mtdchar.c
--- linux-2.6.13.1.org/drivers/mtd/mtdchar.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/mtdchar.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Character-device access to raw MTD devices.
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/mtdconcat.c grsecurity226/drivers/mtd/mtdconcat.c
--- linux-2.6.13.1.org/drivers/mtd/mtdconcat.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/mtdconcat.c	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * This code is GPL
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/mtdcore.c grsecurity226/drivers/mtd/mtdcore.c
--- linux-2.6.13.1.org/drivers/mtd/mtdcore.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/mtdcore.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Core registration and callback routines for MTD
  * drivers and users.
diff -Nur linux-2.6.13.1.org/drivers/mtd/mtdpart.c grsecurity226/drivers/mtd/mtdpart.c
--- linux-2.6.13.1.org/drivers/mtd/mtdpart.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/mtdpart.c	2005-08-30 01:00:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id$
+ * $Id$
  *
  * 	02-21-2002	Thomas Gleixner <gleixner@autronix.de>
  *			added support for read_oob, write_oob
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/Kconfig grsecurity226/drivers/mtd/nand/Kconfig
--- linux-2.6.13.1.org/drivers/mtd/nand/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/Kconfig	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 # drivers/mtd/nand/Kconfig
-# $Id$
+# $Id$
 
 menu "NAND Flash Device Drivers"
 	depends on MTD!=n
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/Makefile grsecurity226/drivers/mtd/nand/Makefile
--- linux-2.6.13.1.org/drivers/mtd/nand/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/Makefile	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # linux/drivers/nand/Makefile
 #
-# $Id$
+# $Id$
 
 obj-$(CONFIG_MTD_NAND)			+= nand.o nand_ecc.o
 obj-$(CONFIG_MTD_NAND_IDS)		+= nand_ids.o
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/au1550nd.c grsecurity226/drivers/mtd/nand/au1550nd.c
--- linux-2.6.13.1.org/drivers/mtd/nand/au1550nd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/au1550nd.c	2005-08-30 01:00:11.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2004 Embedded Edge, LLC
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/autcpu12.c grsecurity226/drivers/mtd/nand/autcpu12.c
--- linux-2.6.13.1.org/drivers/mtd/nand/autcpu12.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/autcpu12.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/spia.c
  * 	 Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/diskonchip.c grsecurity226/drivers/mtd/nand/diskonchip.c
--- linux-2.6.13.1.org/drivers/mtd/nand/diskonchip.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/diskonchip.c	2005-08-30 01:00:11.000000000 +0200
@@ -16,7 +16,7 @@
  *  
  * Interface to generic NAND code for M-Systems DiskOnChip devices
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/kernel.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/edb7312.c grsecurity226/drivers/mtd/nand/edb7312.c
--- linux-2.6.13.1.org/drivers/mtd/nand/edb7312.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/edb7312.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/nand/autcpu12.c
  *       Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/h1910.c grsecurity226/drivers/mtd/nand/h1910.c
--- linux-2.6.13.1.org/drivers/mtd/nand/h1910.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/h1910.c	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  *       Copyright (C) 2002 Marius Grger (mag@sysgo.de)
  *       Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/nand_base.c grsecurity226/drivers/mtd/nand/nand_base.c
--- linux-2.6.13.1.org/drivers/mtd/nand/nand_base.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/nand_base.c	2005-08-30 01:00:11.000000000 +0200
@@ -59,7 +59,7 @@
  *	The AG-AND chips have nice features for speed improvement,
  *	which are not supported yet. Read / program 4 pages in one go.
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/nand_bbt.c grsecurity226/drivers/mtd/nand/nand_bbt.c
--- linux-2.6.13.1.org/drivers/mtd/nand/nand_bbt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/nand_bbt.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  *   
  *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/nand_ecc.c grsecurity226/drivers/mtd/nand/nand_ecc.c
--- linux-2.6.13.1.org/drivers/mtd/nand/nand_ecc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/nand_ecc.c	2005-08-30 01:00:11.000000000 +0200
@@ -7,7 +7,7 @@
  * Copyright (C) 2000-2004 Steven J. Hill (sjhill@realitydiluted.com)
  *                         Toshiba America Electronics Components, Inc.
  *
- * $Id$
+ * $Id$
  *
  * This file is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/nand_ids.c grsecurity226/drivers/mtd/nand/nand_ids.c
--- linux-2.6.13.1.org/drivers/mtd/nand/nand_ids.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/nand_ids.c	2005-08-30 01:00:11.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/nandsim.c grsecurity226/drivers/mtd/nand/nandsim.c
--- linux-2.6.13.1.org/drivers/mtd/nand/nandsim.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/nandsim.c	2005-08-30 01:00:11.000000000 +0200
@@ -22,7 +22,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/ppchameleonevb.c grsecurity226/drivers/mtd/nand/ppchameleonevb.c
--- linux-2.6.13.1.org/drivers/mtd/nand/ppchameleonevb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/ppchameleonevb.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/nand/edb7312.c
  *
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/rtc_from4.c grsecurity226/drivers/mtd/nand/rtc_from4.c
--- linux-2.6.13.1.org/drivers/mtd/nand/rtc_from4.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/rtc_from4.c	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/nand/spia.c
  *       Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/s3c2410.c grsecurity226/drivers/mtd/nand/s3c2410.c
--- linux-2.6.13.1.org/drivers/mtd/nand/s3c2410.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/s3c2410.c	2005-08-30 01:00:11.000000000 +0200
@@ -18,7 +18,7 @@
  *	20-Jun-2005  BJD  Updated s3c2440 support, fixed timing bug
  *	08-Jul-2005  BJD  Fix OOPS when no platform data supplied
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/sharpsl.c grsecurity226/drivers/mtd/nand/sharpsl.c
--- linux-2.6.13.1.org/drivers/mtd/nand/sharpsl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/sharpsl.c	2005-08-30 01:00:11.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2004 Richard Purdie
  *
- *  $Id$
+ *  $Id$
  *
  *  Based on Sharp's NAND driver sharp_sl.c
  *
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/spia.c grsecurity226/drivers/mtd/nand/spia.c
--- linux-2.6.13.1.org/drivers/mtd/nand/spia.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/spia.c	2005-08-30 01:00:11.000000000 +0200
@@ -8,7 +8,7 @@
  *			to controllines	(due to change in nand.c)
  *			page_cache added
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/drivers/mtd/nand/toto.c grsecurity226/drivers/mtd/nand/toto.c
--- linux-2.6.13.1.org/drivers/mtd/nand/toto.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nand/toto.c	2005-08-30 01:00:11.000000000 +0200
@@ -15,7 +15,7 @@
  *   This is a device driver for the NAND flash device found on the
  *   TI fido board. It supports 32MiB and 64MiB cards
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/slab.h>
diff -Nur linux-2.6.13.1.org/drivers/mtd/nftlcore.c grsecurity226/drivers/mtd/nftlcore.c
--- linux-2.6.13.1.org/drivers/mtd/nftlcore.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nftlcore.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* Linux driver for NAND Flash Translation Layer      */
 /* (c) 1999 Machine Vision Holdings, Inc.             */
 /* Author: David Woodhouse <dwmw2@infradead.org>      */
-/* $Id$ */
+/* $Id$ */
 
 /*
   The contents of this file are distributed under the GNU General
@@ -749,7 +749,7 @@
 
 static int __init init_nftl(void)
 {
-	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision$, nftlmount.c %s\n", nftlmountrev);
+	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision$, nftlmount.c %s\n", nftlmountrev);
 
 	return register_mtd_blktrans(&nftl_tr);
 }
diff -Nur linux-2.6.13.1.org/drivers/mtd/nftlmount.c grsecurity226/drivers/mtd/nftlmount.c
--- linux-2.6.13.1.org/drivers/mtd/nftlmount.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/nftlmount.c	2005-08-30 01:00:11.000000000 +0200
@@ -4,7 +4,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -31,7 +31,7 @@
 
 #define SECTORSIZE 512
 
-char nftlmountrev[]="$Revision$";
+char nftlmountrev[]="$Revision$";
 
 /* find_boot_record: Find the NFTL Media Header and its Spare copy which contains the
  *	various device information of the NFTL partition and Bad Unit Table. Update
diff -Nur linux-2.6.13.1.org/drivers/mtd/redboot.c grsecurity226/drivers/mtd/redboot.c
--- linux-2.6.13.1.org/drivers/mtd/redboot.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/mtd/redboot.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Parse RedBoot-style Flash Image System (FIS) tables and
  * produce a Linux partition array to match.
diff -Nur linux-2.6.13.1.org/drivers/net/3c505.c grsecurity226/drivers/net/3c505.c
--- linux-2.6.13.1.org/drivers/net/3c505.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/3c505.c	2005-08-30 01:00:11.000000000 +0200
@@ -10,7 +10,7 @@
  *              be here without 3C505 technical reference provided by
  *              3Com.
  *
- * $Id$
+ * $Id$
  *
  * Authors:     Linux 3c505 device driver by
  *                      Craig Southeren, <craigs@ineluki.apana.org.au>
diff -Nur linux-2.6.13.1.org/drivers/net/3c523.c grsecurity226/drivers/net/3c523.c
--- linux-2.6.13.1.org/drivers/net/3c523.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/3c523.c	2005-08-30 01:00:11.000000000 +0200
@@ -84,7 +84,7 @@
    Nov 2001
    added support for ethtool (jgarzik)
 	
-   $Header$
+   $Header$
  */
 
 #define DRV_NAME		"3c523"
diff -Nur linux-2.6.13.1.org/drivers/net/3c523.h grsecurity226/drivers/net/3c523.h
--- linux-2.6.13.1.org/drivers/net/3c523.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/3c523.h	2005-08-30 01:00:11.000000000 +0200
@@ -15,7 +15,7 @@
  *
  * See 3c523.c for details.
  *
- * $Header$
+ * $Header$
  */
 
 /*
diff -Nur linux-2.6.13.1.org/drivers/net/82596.c grsecurity226/drivers/net/82596.c
--- linux-2.6.13.1.org/drivers/net/82596.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/82596.c	2005-08-30 01:00:11.000000000 +0200
@@ -60,7 +60,7 @@
 #include <asm/pgtable.h>
 
 static char version[] __initdata =
-	"82596.c $Revision$\n";
+	"82596.c $Revision$\n";
 
 #define DRV_NAME	"82596"
 
diff -Nur linux-2.6.13.1.org/drivers/net/appletalk/ltpc.c grsecurity226/drivers/net/appletalk/ltpc.c
--- linux-2.6.13.1.org/drivers/net/appletalk/ltpc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/appletalk/ltpc.c	2005-08-30 01:00:14.000000000 +0200
@@ -62,6 +62,9 @@
 /***
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:14  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.1.2.1  2000/03/01 05:35:07  jgarzik
  * at and tr cleanup
  *
diff -Nur linux-2.6.13.1.org/drivers/net/cris/eth_v10.c grsecurity226/drivers/net/cris/eth_v10.c
--- linux-2.6.13.1.org/drivers/net/cris/eth_v10.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/cris/eth_v10.c	2005-08-30 01:00:15.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * e100net.c: A network driver for the ETRAX 100LX network controller.
  *
@@ -6,7 +6,10 @@
  *
  * The outline of this driver comes from skeleton.c.
  *
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:15  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.31  2004/10/18 14:49:03  starvik
  * Use RX interrupt as random source
  *
@@ -1547,7 +1550,7 @@
 			struct ethtool_drvinfo info;
 			memset((void *) &info, 0, sizeof (info));
 			strncpy(info.driver, "ETRAX 100LX", sizeof(info.driver) - 1);
-			strncpy(info.version, "$Revision$", sizeof(info.version) - 1);
+			strncpy(info.version, "$Revision$", sizeof(info.version) - 1);
 			strncpy(info.fw_version, "N/A", sizeof(info.fw_version) - 1);
 			strncpy(info.bus_info, "N/A", sizeof(info.bus_info) - 1);
 			info.regdump_len = 0;
diff -Nur linux-2.6.13.1.org/drivers/net/de600.c grsecurity226/drivers/net/de600.c
--- linux-2.6.13.1.org/drivers/net/de600.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/de600.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,4 +1,4 @@
-static const char version[] = "de600.c: $Revision$,  Bjorn Ekwall (bj0rn@blox.se)\n";
+static const char version[] = "de600.c: $Revision$,  Bjorn Ekwall (bj0rn@blox.se)\n";
 /*
  *	de600.c
  *
diff -Nur linux-2.6.13.1.org/drivers/net/de620.c grsecurity226/drivers/net/de620.c
--- linux-2.6.13.1.org/drivers/net/de620.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/de620.c	2005-08-30 01:00:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *	de620.c $Revision$ BETA
+ *	de620.c $Revision$ BETA
  *
  *
  *	Linux driver for the D-Link DE-620 Ethernet pocket adapter.
@@ -39,7 +39,7 @@
  *
  *****************************************************************************/
 static const char version[] =
-	"de620.c: $Revision$,  Bjorn Ekwall <bj0rn@blox.se>\n";
+	"de620.c: $Revision$,  Bjorn Ekwall <bj0rn@blox.se>\n";
 
 /***********************************************************************
  *
diff -Nur linux-2.6.13.1.org/drivers/net/dgrs.c grsecurity226/drivers/net/dgrs.c
--- linux-2.6.13.1.org/drivers/net/dgrs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/dgrs.c	2005-08-30 01:00:11.000000000 +0200
@@ -104,7 +104,7 @@
 #include <asm/uaccess.h>
 
 static char version[] __initdata =
-	"$Id$";
+	"$Id$";
 
 /*
  *	DGRS include files
diff -Nur linux-2.6.13.1.org/drivers/net/dgrs_asstruct.h grsecurity226/drivers/net/dgrs_asstruct.h
--- linux-2.6.13.1.org/drivers/net/dgrs_asstruct.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/dgrs_asstruct.h	2005-08-30 01:00:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *	For declaring structures shared with assembly routines
  *
- *	$Id$
+ *	$Id$
  */
 
 #ifdef ASSEMBLER
diff -Nur linux-2.6.13.1.org/drivers/net/dgrs_es4h.h grsecurity226/drivers/net/dgrs_es4h.h
--- linux-2.6.13.1.org/drivers/net/dgrs_es4h.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/dgrs_es4h.h	2005-08-30 01:00:11.000000000 +0200
@@ -6,7 +6,7 @@
 /*		board.  Everything that says "es4h" should really be	*/
 /*		"se4".  But we'll keep the old name for now.		*/
 /*									*/
-/*	$Id$		*/
+/*	$Id$		*/
 /*									*/
 /************************************************************************/
 
diff -Nur linux-2.6.13.1.org/drivers/net/dgrs_i82596.h grsecurity226/drivers/net/dgrs_i82596.h
--- linux-2.6.13.1.org/drivers/net/dgrs_i82596.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/dgrs_i82596.h	2005-08-30 01:00:12.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *	i82596 ethernet controller bits and structures (little endian)
  *
- *	$Id$
+ *	$Id$
  */
 
 /************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/eepro100.c grsecurity226/drivers/net/eepro100.c
--- linux-2.6.13.1.org/drivers/net/eepro100.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/eepro100.c	2005-08-30 01:00:12.000000000 +0200
@@ -29,7 +29,7 @@
 
 static const char *version =
 "eepro100.c:v1.09j-t 9/29/99 Donald Becker http://www.scyld.com/network/eepro100.html\n"
-"eepro100.c: $Revision$ 2000/11/17 Modified by Andrey V. Savochkin <saw@saw.sw.com.sg> and others\n";
+"eepro100.c: $Revision$ 2000/11/17 Modified by Andrey V. Savochkin <saw@saw.sw.com.sg> and others\n";
 
 /* A few user-configurable values that apply to all boards.
    First set is undocumented and spelled per Intel recommendations. */
diff -Nur linux-2.6.13.1.org/drivers/net/eql.c grsecurity226/drivers/net/eql.c
--- linux-2.6.13.1.org/drivers/net/eql.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/eql.c	2005-08-30 01:00:12.000000000 +0200
@@ -29,6 +29,9 @@
 
 /*
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:12  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.2  1996/04/11 17:51:52  guru
  * Added one-line eql_remove_slave patch.
  *
diff -Nur linux-2.6.13.1.org/drivers/net/hamradio/scc.c grsecurity226/drivers/net/hamradio/scc.c
--- linux-2.6.13.1.org/drivers/net/hamradio/scc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/hamradio/scc.c	2005-08-30 01:00:15.000000000 +0200
@@ -1,4 +1,4 @@
-#define RCS_ID "$Id$"
+#define RCS_ID "$Id$"
 
 #define VERSION "3.0"
 
diff -Nur linux-2.6.13.1.org/drivers/net/hp100.c grsecurity226/drivers/net/hp100.c
--- linux-2.6.13.1.org/drivers/net/hp100.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/hp100.c	2005-08-30 01:00:12.000000000 +0200
@@ -2,7 +2,7 @@
 ** hp100.c 
 ** HP CASCADE Architecture Driver for 100VG-AnyLan Network Adapters
 **
-** $Id$
+** $Id$
 **
 ** Based on the HP100 driver written by Jaroslav Kysela <perex@jcu.cz>
 ** Extended for new busmaster capable chipsets by 
diff -Nur linux-2.6.13.1.org/drivers/net/hp100.h grsecurity226/drivers/net/hp100.h
--- linux-2.6.13.1.org/drivers/net/hp100.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/hp100.h	2005-08-30 01:00:12.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * hp100.h: Hewlett Packard HP10/100VG ANY LAN ethernet driver for Linux.
  *
- * $Id$
+ * $Id$
  *
  * Authors:  Jaroslav Kysela, <perex@pf.jcu.cz>
  *           Siegfried Loeffler <floeff@tunix.mathematik.uni-stuttgart.de>
diff -Nur linux-2.6.13.1.org/drivers/net/irda/donauboe.c grsecurity226/drivers/net/irda/donauboe.c
--- linux-2.6.13.1.org/drivers/net/irda/donauboe.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/irda/donauboe.c	2005-08-30 01:00:15.000000000 +0200
@@ -51,7 +51,7 @@
 
 
 static char *rcsid =
-  "$Id$";
+  "$Id$";
 
 /* See below for a description of the logic in this driver */
 
diff -Nur linux-2.6.13.1.org/drivers/net/irda/smsc-ircc2.c grsecurity226/drivers/net/irda/smsc-ircc2.c
--- linux-2.6.13.1.org/drivers/net/irda/smsc-ircc2.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/irda/smsc-ircc2.c	2005-08-30 01:00:16.000000000 +0200
@@ -1,5 +1,5 @@
 /*********************************************************************
- * $Id$
+ * $Id$
  *
  * Description:   Driver for the SMC Infrared Communications Controller
  * Status:        Experimental.
diff -Nur linux-2.6.13.1.org/drivers/net/irda/smsc-ircc2.h grsecurity226/drivers/net/irda/smsc-ircc2.h
--- linux-2.6.13.1.org/drivers/net/irda/smsc-ircc2.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/irda/smsc-ircc2.h	2005-08-30 01:00:16.000000000 +0200
@@ -1,5 +1,5 @@
 /*********************************************************************
- * $Id$               
+ * $Id$               
  *
  * Description:   Definitions for the SMC IrCC chipset
  * Status:        Experimental.
diff -Nur linux-2.6.13.1.org/drivers/net/ns83820.c grsecurity226/drivers/net/ns83820.c
--- linux-2.6.13.1.org/drivers/net/ns83820.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/ns83820.c	2005-08-30 01:00:12.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Questions/comments/discussion to linux-ns83820@kvack.org.
  *
- * $Revision$
+ * $Revision$
  *
  * Copyright 2001 Benjamin LaHaise.
  * Copyright 2001, 2002 Red Hat.
diff -Nur linux-2.6.13.1.org/drivers/net/plip.c grsecurity226/drivers/net/plip.c
--- linux-2.6.13.1.org/drivers/net/plip.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/plip.c	2005-08-30 01:00:12.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 /* PLIP: A parallel port "network" driver for Linux. */
 /* This driver is for parallel port with 5-bit cable (LapLink (R) cable). */
 /*
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/lm80.h grsecurity226/drivers/net/sk98lin/h/lm80.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/lm80.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/lm80.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	lm80.h	
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Contains all defines for the LM80 Chip
  *		(National Semiconductor).
  *
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skaddr.h grsecurity226/drivers/net/sk98lin/h/skaddr.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skaddr.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skaddr.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skaddr.h
  * Project:	Gigabit Ethernet Adapters, ADDR-Modul
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Header file for Address Management (MC, UC, Prom).
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skcsum.h grsecurity226/drivers/net/sk98lin/h/skcsum.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skcsum.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skcsum.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skcsum.h
  * Project:	GEnesis - SysKonnect SK-NET Gigabit Ethernet (SK-98xx)
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skdebug.h grsecurity226/drivers/net/sk98lin/h/skdebug.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skdebug.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skdebug.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skdebug.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	SK specific DEBUG support
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skdrv1st.h grsecurity226/drivers/net/sk98lin/h/skdrv1st.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skdrv1st.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skdrv1st.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skdrv1st.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	First header file for driver and all other modules
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skdrv2nd.h grsecurity226/drivers/net/sk98lin/h/skdrv2nd.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skdrv2nd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skdrv2nd.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skdrv2nd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Second header file for driver and all other modules
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skerror.h grsecurity226/drivers/net/sk98lin/h/skerror.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skerror.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skerror.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skerror.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skgedrv.h grsecurity226/drivers/net/sk98lin/h/skgedrv.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skgedrv.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skgedrv.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgedrv.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Interface with the driver
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skgehw.h grsecurity226/drivers/net/sk98lin/h/skgehw.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skgehw.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skgehw.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgehw.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines and Macros for the Gigabit Ethernet Adapter Product Family
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skgehwt.h grsecurity226/drivers/net/sk98lin/h/skgehwt.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skgehwt.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skgehwt.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skhwt.h
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines for the hardware timer functions
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skgei2c.h grsecurity226/drivers/net/sk98lin/h/skgei2c.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skgei2c.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skgei2c.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgei2c.h
  * Project:	Gigabit Ethernet Adapters, TWSI-Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Special defines for TWSI
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skgeinit.h grsecurity226/drivers/net/sk98lin/h/skgeinit.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skgeinit.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skgeinit.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgeinit.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Structures and prototypes for the GE Init Module
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skgepnm2.h grsecurity226/drivers/net/sk98lin/h/skgepnm2.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skgepnm2.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skgepnm2.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnm2.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skgepnmi.h grsecurity226/drivers/net/sk98lin/h/skgepnmi.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skgepnmi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skgepnmi.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnmi.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skgesirq.h grsecurity226/drivers/net/sk98lin/h/skgesirq.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skgesirq.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skgesirq.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgesirq.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	SK specific Gigabit Ethernet special IRQ functions
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/ski2c.h grsecurity226/drivers/net/sk98lin/h/ski2c.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/ski2c.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/ski2c.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	ski2c.h
  * Project:	Gigabit Ethernet Adapters, TWSI-Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines to access Voltage and Temperature Sensor
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skqueue.h grsecurity226/drivers/net/sk98lin/h/skqueue.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skqueue.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skqueue.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skqueue.h
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines for the Event queue
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skrlmt.h grsecurity226/drivers/net/sk98lin/h/skrlmt.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skrlmt.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skrlmt.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skrlmt.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Header file for Redundant Link ManagemenT.
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/sktimer.h grsecurity226/drivers/net/sk98lin/h/sktimer.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/sktimer.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/sktimer.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	sktimer.h
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines for the timer functions
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/sktypes.h grsecurity226/drivers/net/sk98lin/h/sktypes.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/sktypes.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/sktypes.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	sktypes.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Define data types for Linux
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skversion.h grsecurity226/drivers/net/sk98lin/h/skversion.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skversion.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skversion.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	version.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/skvpd.h grsecurity226/drivers/net/sk98lin/h/skvpd.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/skvpd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/skvpd.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skvpd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines and Macros for VPD handling
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/h/xmac_ii.h grsecurity226/drivers/net/sk98lin/h/xmac_ii.h
--- linux-2.6.13.1.org/drivers/net/sk98lin/h/xmac_ii.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/h/xmac_ii.h	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	xmac_ii.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Defines and Macros for Gigabit Ethernet Controller
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skaddr.c grsecurity226/drivers/net/sk98lin/skaddr.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skaddr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skaddr.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skaddr.c
  * Project:	Gigabit Ethernet Adapters, ADDR-Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Manage Addresses (Multicast and Unicast) and Promiscuous Mode.
  *
  ******************************************************************************/
@@ -44,7 +44,7 @@
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif /* DEBUG ||!LINT || !SK_SLIM */
 
 #define __SKADDR_C
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skcsum.c grsecurity226/drivers/net/sk98lin/skcsum.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skcsum.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skcsum.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skcsum.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
@@ -25,7 +25,7 @@
 
 #ifndef lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) SysKonnect.";
+	"@(#) $Id$ (C) SysKonnect.";
 #endif	/* !lint */
 
 /******************************************************************************
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skdim.c grsecurity226/drivers/net/sk98lin/skdim.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skdim.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skdim.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skdim.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	All functions to maintain interrupt moderation
  *
  ******************************************************************************/
@@ -38,7 +38,7 @@
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) SysKonnect.";
+	"@(#) $Id$ (C) SysKonnect.";
 #endif
 
 #define __SKADDR_C
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skethtool.c grsecurity226/drivers/net/sk98lin/skethtool.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skethtool.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skethtool.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:        skethtool.c
  * Project:     GEnesis, PCI Gigabit Ethernet Adapter
- * Version:     $Revision$
- * Date:        $Date$
+ * Version:     $Revision$
+ * Date:        $Date$
  * Purpose:     All functions regarding ethtool handling
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skge.c grsecurity226/drivers/net/sk98lin/skge.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skge.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skge.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skge.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:       	$Date$
+ * Version:	$Revision$
+ * Date:       	$Date$
  * Purpose:	The main driver source module
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skgehwt.c grsecurity226/drivers/net/sk98lin/skgehwt.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skgehwt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skgehwt.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgehwt.c
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Hardware Timer
  *
  ******************************************************************************/
@@ -27,7 +27,7 @@
  */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skgeinit.c grsecurity226/drivers/net/sk98lin/skgeinit.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skgeinit.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skgeinit.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgeinit.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Contains functions to initialize the adapter
  *
  ******************************************************************************/
@@ -31,7 +31,7 @@
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif
 
 struct s_QOffTab {
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skgemib.c grsecurity226/drivers/net/sk98lin/skgemib.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skgemib.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skgemib.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgemib.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Private Network Management Interface Management Database
  *
  ****************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skgepnmi.c grsecurity226/drivers/net/sk98lin/skgepnmi.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skgepnmi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skgepnmi.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnmi.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Private Network Management Interface
  *
  ****************************************************************************/
@@ -25,7 +25,7 @@
 
 #ifndef _lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif /* !_lint */
 
 #include "h/skdrv1st.h"
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skgesirq.c grsecurity226/drivers/net/sk98lin/skgesirq.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skgesirq.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skgesirq.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skgesirq.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Special IRQ module
  *
  ******************************************************************************/
@@ -48,7 +48,7 @@
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/ski2c.c grsecurity226/drivers/net/sk98lin/ski2c.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/ski2c.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/ski2c.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	ski2c.c
  * Project:	Gigabit Ethernet Adapters, TWSI-Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Functions to access Voltage and Temperature Sensor
  *
  ******************************************************************************/
@@ -27,7 +27,7 @@
  */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell. ";
+	"@(#) $Id$ (C) Marvell. ";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/sklm80.c grsecurity226/drivers/net/sk98lin/sklm80.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/sklm80.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/sklm80.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	sklm80.c
  * Project:	Gigabit Ethernet Adapters, TWSI-Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Functions to access Voltage and Temperature Sensor (LM80)
  *
  ******************************************************************************/
@@ -27,7 +27,7 @@
 */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell. ";
+	"@(#) $Id$ (C) Marvell. ";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skproc.c grsecurity226/drivers/net/sk98lin/skproc.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skproc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skproc.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skproc.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Funktions to display statictic data
  *
  ******************************************************************************/
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skqueue.c grsecurity226/drivers/net/sk98lin/skqueue.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skqueue.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skqueue.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skqueue.c
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Management of an event queue.
  *
  ******************************************************************************/
@@ -28,7 +28,7 @@
  */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skrlmt.c grsecurity226/drivers/net/sk98lin/skrlmt.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skrlmt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skrlmt.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skrlmt.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Manage links on SK-NET Adapters, esp. redundant ones.
  *
  ******************************************************************************/
@@ -39,7 +39,7 @@
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif	/* !defined(lint) */
 
 #define __SKRLMT_C
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/sktimer.c grsecurity226/drivers/net/sk98lin/sktimer.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/sktimer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/sktimer.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	sktimer.c
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	High level timer functions.
  *
  ******************************************************************************/
@@ -28,7 +28,7 @@
  */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skvpd.c grsecurity226/drivers/net/sk98lin/skvpd.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skvpd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skvpd.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skvpd.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Shared software to read and write VPD data
  *
  ******************************************************************************/
@@ -25,7 +25,7 @@
 	Please refer skvpd.txt for infomation how to include this module
  */
 static const char SysKonnectFileId[] =
-	"@(#)$Id$ (C) SK";
+	"@(#)$Id$ (C) SK";
 
 #include "h/skdrv1st.h"
 #include "h/sktypes.h"
diff -Nur linux-2.6.13.1.org/drivers/net/sk98lin/skxmac2.c grsecurity226/drivers/net/sk98lin/skxmac2.c
--- linux-2.6.13.1.org/drivers/net/sk98lin/skxmac2.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sk98lin/skxmac2.c	2005-08-30 01:00:16.000000000 +0200
@@ -2,8 +2,8 @@
  *
  * Name:	skxmac2.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision$
- * Date:	$Date$
+ * Version:	$Revision$
+ * Date:	$Date$
  * Purpose:	Contains functions to initialize the MACs and PHYs
  *
  ******************************************************************************/
@@ -37,7 +37,7 @@
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id$ (C) Marvell.";
+	"@(#) $Id$ (C) Marvell.";
 #endif
 
 #ifdef GENESIS
diff -Nur linux-2.6.13.1.org/drivers/net/sunbmac.c grsecurity226/drivers/net/sunbmac.c
--- linux-2.6.13.1.org/drivers/net/sunbmac.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sunbmac.c	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sunbmac.c: Driver for Sparc BigMAC 100baseT ethernet adapters.
  *
  * Copyright (C) 1997, 1998, 1999, 2003 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/drivers/net/sunbmac.h grsecurity226/drivers/net/sunbmac.h
--- linux-2.6.13.1.org/drivers/net/sunbmac.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sunbmac.h	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sunbmac.h: Defines for the Sun "Big MAC" 100baseT ethernet cards.
  *
  * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/drivers/net/sungem.c grsecurity226/drivers/net/sungem.c
--- linux-2.6.13.1.org/drivers/net/sungem.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sungem.c	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sungem.c: Sun GEM ethernet driver.
  *
  * Copyright (C) 2000, 2001, 2002, 2003 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/drivers/net/sungem.h grsecurity226/drivers/net/sungem.h
--- linux-2.6.13.1.org/drivers/net/sungem.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sungem.h	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sungem.h: Definitions for Sun GEM ethernet driver.
  *
  * Copyright (C) 2000 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/drivers/net/sunhme.c grsecurity226/drivers/net/sunhme.c
--- linux-2.6.13.1.org/drivers/net/sunhme.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sunhme.c	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sunhme.c: Sparc HME/BigMac 10/100baseT half/full duplex auto switching,
  *           auto carrier detecting ethernet driver.  Also known as the
  *           "Happy Meal Ethernet" found on SunSwift SBUS cards.
diff -Nur linux-2.6.13.1.org/drivers/net/sunhme.h grsecurity226/drivers/net/sunhme.h
--- linux-2.6.13.1.org/drivers/net/sunhme.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sunhme.h	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sunhme.h: Definitions for Sparc HME/BigMac 10/100baseT ethernet driver.
  *           Also known as the "Happy Meal".
  *
diff -Nur linux-2.6.13.1.org/drivers/net/sunlance.c grsecurity226/drivers/net/sunlance.c
--- linux-2.6.13.1.org/drivers/net/sunlance.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sunlance.c	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * lance.c: Linux/Sparc/Lance driver
  *
  *	Written 1995, 1996 by Miguel de Icaza
diff -Nur linux-2.6.13.1.org/drivers/net/sunqe.c grsecurity226/drivers/net/sunqe.c
--- linux-2.6.13.1.org/drivers/net/sunqe.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sunqe.c	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sunqe.c: Sparc QuadEthernet 10baseT SBUS card driver.
  *          Once again I am out to prove that every ethernet
  *          controller out there can be most efficiently programmed
diff -Nur linux-2.6.13.1.org/drivers/net/sunqe.h grsecurity226/drivers/net/sunqe.h
--- linux-2.6.13.1.org/drivers/net/sunqe.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/sunqe.h	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sunqe.h: Definitions for the Sun QuadEthernet driver.
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/drivers/net/tg3.h grsecurity226/drivers/net/tg3.h
--- linux-2.6.13.1.org/drivers/net/tg3.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/tg3.h	2005-08-30 01:00:14.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * tg3.h: Definitions for Broadcom Tigon3 ethernet driver.
  *
  * Copyright (C) 2001, 2002, 2003, 2004 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/drivers/net/tulip/xircom_cb.c grsecurity226/drivers/net/tulip/xircom_cb.c
--- linux-2.6.13.1.org/drivers/net/tulip/xircom_cb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/tulip/xircom_cb.c	2005-08-30 01:00:16.000000000 +0200
@@ -11,7 +11,7 @@
  *      of the GNU General Public License, incorporated herein by reference.
  *
  *
- * 	$Id$
+ * 	$Id$
  */
 
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/net/tun.c grsecurity226/drivers/net/tun.c
--- linux-2.6.13.1.org/drivers/net/tun.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/tun.c	2005-08-30 01:00:14.000000000 +0200
@@ -12,7 +12,7 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
  *
- *  $Id$
+ *  $Id$
  */
 
 /*
diff -Nur linux-2.6.13.1.org/drivers/net/wan/cosa.c grsecurity226/drivers/net/wan/cosa.c
--- linux-2.6.13.1.org/drivers/net/wan/cosa.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/cosa.c	2005-08-30 01:00:16.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 /*
  *  Copyright (C) 1995-1997  Jan "Yenya" Kasprzak <kas@fi.muni.cz>
diff -Nur linux-2.6.13.1.org/drivers/net/wan/cosa.h grsecurity226/drivers/net/wan/cosa.h
--- linux-2.6.13.1.org/drivers/net/wan/cosa.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/cosa.h	2005-08-30 01:00:16.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 /*
  *  Copyright (C) 1995-1997  Jan "Yenya" Kasprzak <kas@fi.muni.cz>
diff -Nur linux-2.6.13.1.org/drivers/net/wan/dscc4.c grsecurity226/drivers/net/wan/dscc4.c
--- linux-2.6.13.1.org/drivers/net/wan/dscc4.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/dscc4.c	2005-08-30 01:00:16.000000000 +0200
@@ -107,7 +107,7 @@
 #include <linux/hdlc.h>
 
 /* Version */
-static const char version[] = "$Id$ for Linux\n";
+static const char version[] = "$Id$ for Linux\n";
 static int debug;
 static int quartz;
 
diff -Nur linux-2.6.13.1.org/drivers/net/wan/hd64572.h grsecurity226/drivers/net/wan/hd64572.h
--- linux-2.6.13.1.org/drivers/net/wan/hd64572.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/hd64572.h	2005-08-30 01:00:16.000000000 +0200
@@ -12,6 +12,9 @@
  *	2 of the License, or (at your option) any later version.
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:16  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 3.1  2001/06/15 12:41:10  regina
  * upping major version number
  *
diff -Nur linux-2.6.13.1.org/drivers/net/wan/lmc/lmc_ioctl.h grsecurity226/drivers/net/wan/lmc/lmc_ioctl.h
--- linux-2.6.13.1.org/drivers/net/wan/lmc/lmc_ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/lmc/lmc_ioctl.h	2005-08-30 01:00:17.000000000 +0200
@@ -1,6 +1,6 @@
 #ifndef _LMC_IOCTL_H_
 #define _LMC_IOCTL_H_
-/*	$Id$	*/
+/*	$Id$	*/
 
  /*
   * Copyright (c) 1997-2000 LAN Media Corporation (LMC)
diff -Nur linux-2.6.13.1.org/drivers/net/wan/lmc/lmc_main.c grsecurity226/drivers/net/wan/lmc/lmc_main.c
--- linux-2.6.13.1.org/drivers/net/wan/lmc/lmc_main.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/lmc/lmc_main.c	2005-08-30 01:00:17.000000000 +0200
@@ -36,7 +36,7 @@
   *
   */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/kernel.h>
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/drivers/net/wan/lmc/lmc_media.c grsecurity226/drivers/net/wan/lmc/lmc_media.c
--- linux-2.6.13.1.org/drivers/net/wan/lmc/lmc_media.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/lmc/lmc_media.c	2005-08-30 01:00:17.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/config.h>
 #include <linux/kernel.h>
diff -Nur linux-2.6.13.1.org/drivers/net/wan/lmc/lmc_var.h grsecurity226/drivers/net/wan/lmc/lmc_var.h
--- linux-2.6.13.1.org/drivers/net/wan/lmc/lmc_var.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/lmc/lmc_var.h	2005-08-30 01:00:17.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _LMC_VAR_H_
 #define _LMC_VAR_H_
 
-/* $Id$ */
+/* $Id$ */
 
  /*
   * Copyright (c) 1997-2000 LAN Media Corporation (LMC)
diff -Nur linux-2.6.13.1.org/drivers/net/wan/pc300-falc-lh.h grsecurity226/drivers/net/wan/pc300-falc-lh.h
--- linux-2.6.13.1.org/drivers/net/wan/pc300-falc-lh.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/pc300-falc-lh.h	2005-08-30 01:00:16.000000000 +0200
@@ -10,7 +10,10 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  *
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:16  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 3.1  2001/06/15 12:41:10  regina
  * upping major version number
  *
diff -Nur linux-2.6.13.1.org/drivers/net/wan/pc300.h grsecurity226/drivers/net/wan/pc300.h
--- linux-2.6.13.1.org/drivers/net/wan/pc300.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/pc300.h	2005-08-30 01:00:16.000000000 +0200
@@ -11,6 +11,9 @@
  *	2 of the License, or (at your option) any later version.
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:16  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 3.12  2002/03/07 14:17:09  henrique
  * License data fixed
  *
diff -Nur linux-2.6.13.1.org/drivers/net/wan/pc300_drv.c grsecurity226/drivers/net/wan/pc300_drv.c
--- linux-2.6.13.1.org/drivers/net/wan/pc300_drv.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/pc300_drv.c	2005-08-30 01:00:16.000000000 +0200
@@ -18,6 +18,9 @@
  *	Using tabstop = 4.
  * 
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:16  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 3.23  2002/03/20 13:58:40  henrique
  * Fixed ortographic mistakes
  *
diff -Nur linux-2.6.13.1.org/drivers/net/wan/pc300_tty.c grsecurity226/drivers/net/wan/pc300_tty.c
--- linux-2.6.13.1.org/drivers/net/wan/pc300_tty.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/pc300_tty.c	2005-08-30 01:00:16.000000000 +0200
@@ -11,6 +11,9 @@
  *  2 of the License, or (at your option) any later version.
  *   
  *  $Log$
+ *  Revision 1.1.1.1  2005/08/29 23:00:16  spender
+ *  Initial import of Linux 2.6.13
+ *
  *  Revision 3.7  2002/03/07 14:17:09  henrique
  *  License data fixed
  *
diff -Nur linux-2.6.13.1.org/drivers/net/wan/sdla_ppp.c grsecurity226/drivers/net/wan/sdla_ppp.c
--- linux-2.6.13.1.org/drivers/net/wan/sdla_ppp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/sdla_ppp.c	2005-08-30 01:13:59.000000000 +0200
@@ -451,7 +451,7 @@
 	sdla_t* card = wandev->private;
  	struct net_device* dev;
         volatile ppp_private_area_t *ppp_priv_area;
-	ppp_flags_t *flags = card->flags;
+	ppp_flags_t *flags;
 	unsigned long timeout;
 
 	/* sanity checks */
@@ -475,6 +475,7 @@
 	
 	ppp_priv_area->update_comms_stats = 2;
 	ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_UPDATE;
+	flags = card->flags;
 	flags->imask |= PPP_INTR_TIMER;	
 	
 	/* wait a maximum of 1 second for the statistics to be updated */ 
diff -Nur linux-2.6.13.1.org/drivers/net/wan/syncppp.c grsecurity226/drivers/net/wan/syncppp.c
--- linux-2.6.13.1.org/drivers/net/wan/syncppp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wan/syncppp.c	2005-08-30 01:00:17.000000000 +0200
@@ -33,7 +33,7 @@
  *
  * Version 1.9, Wed Oct  4 18:58:15 MSK 1995
  *
- * $Id$
+ * $Id$
  */
 #undef DEBUG
 
diff -Nur linux-2.6.13.1.org/drivers/net/wireless/airo_cs.c grsecurity226/drivers/net/wireless/airo_cs.c
--- linux-2.6.13.1.org/drivers/net/wireless/airo_cs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wireless/airo_cs.c	2005-08-30 01:00:17.000000000 +0200
@@ -52,7 +52,7 @@
 #ifdef PCMCIA_DEBUG
 static int pc_debug = PCMCIA_DEBUG;
 module_param(pc_debug, int, 0);
-static char *version = "$Revision$";
+static char *version = "$Revision$";
 #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args);
 #else
 #define DEBUG(n, args...)
diff -Nur linux-2.6.13.1.org/drivers/net/wireless/atmel_cs.c grsecurity226/drivers/net/wireless/atmel_cs.c
--- linux-2.6.13.1.org/drivers/net/wireless/atmel_cs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wireless/atmel_cs.c	2005-08-30 01:00:17.000000000 +0200
@@ -66,7 +66,7 @@
 #ifdef PCMCIA_DEBUG
 static int pc_debug = PCMCIA_DEBUG;
 module_param(pc_debug, int, 0);
-static char *version = "$Revision$";
+static char *version = "$Revision$";
 #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args);
 #else
 #define DEBUG(n, args...)
diff -Nur linux-2.6.13.1.org/drivers/net/wireless/prism54/Makefile grsecurity226/drivers/net/wireless/prism54/Makefile
--- linux-2.6.13.1.org/drivers/net/wireless/prism54/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/net/wireless/prism54/Makefile	2005-08-30 01:00:17.000000000 +0200
@@ -1,4 +1,4 @@
-# $Id$
+# $Id$
 
 prism54-objs := islpci_eth.o islpci_mgt.o \
                 isl_38xx.o isl_ioctl.o islpci_dev.o \
diff -Nur linux-2.6.13.1.org/drivers/parport/ieee1284.c grsecurity226/drivers/parport/ieee1284.c
--- linux-2.6.13.1.org/drivers/parport/ieee1284.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/parport/ieee1284.c	2005-08-30 01:00:18.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * IEEE-1284 implementation for parport.
  *
  * Authors: Phil Blundell <philb@gnu.org>
diff -Nur linux-2.6.13.1.org/drivers/parport/parport_sunbpp.c grsecurity226/drivers/parport/parport_sunbpp.c
--- linux-2.6.13.1.org/drivers/parport/parport_sunbpp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/parport/parport_sunbpp.c	2005-08-30 01:00:18.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * Parallel-port routines for Sun architecture
  * 
  * Author: Derrick J. Brashear <shadow@dementia.org>
diff -Nur linux-2.6.13.1.org/drivers/parport/probe.c grsecurity226/drivers/parport/probe.c
--- linux-2.6.13.1.org/drivers/parport/probe.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/parport/probe.c	2005-08-30 01:00:18.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * Parallel port device probing code
  *
  * Authors:    Carsten Gross, carsten@sol.wohnheim.uni-ulm.de
diff -Nur linux-2.6.13.1.org/drivers/parport/share.c grsecurity226/drivers/parport/share.c
--- linux-2.6.13.1.org/drivers/parport/share.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/parport/share.c	2005-08-30 01:00:18.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * Parallel-port resource manager code.
  * 
  * Authors: David Campbell <campbell@tirian.che.curtin.edu.au>
diff -Nur linux-2.6.13.1.org/drivers/pci/pci.c grsecurity226/drivers/pci/pci.c
--- linux-2.6.13.1.org/drivers/pci/pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/pci/pci.c	2005-08-30 01:00:18.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *	$Id$
+ *	$Id$
  *
  *	PCI Bus Services, see include/linux/pci.h for further explanation.
  *
diff -Nur linux-2.6.13.1.org/drivers/pci/proc.c grsecurity226/drivers/pci/proc.c
--- linux-2.6.13.1.org/drivers/pci/proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/pci/proc.c	2005-08-30 01:14:04.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *	$Id$
+ *	$Id$
  *
  *	Procfs interface for the PCI bus.
  *
@@ -575,7 +575,15 @@
 
 static void legacy_proc_init(void)
 {
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	struct proc_dir_entry * entry = create_proc_entry("pci", S_IRUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	struct proc_dir_entry * entry = create_proc_entry("pci", S_IRUSR | S_IRGRP, NULL);
+#endif
+#else
 	struct proc_dir_entry * entry = create_proc_entry("pci", 0, NULL);
+#endif
 	if (entry)
 		entry->proc_fops = &proc_pci_operations;
 }
@@ -604,7 +612,15 @@
 {
 	struct proc_dir_entry *entry;
 	struct pci_dev *dev = NULL;
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_bus_pci_dir = proc_mkdir_mode("pci", S_IRUSR | S_IXUSR, proc_bus);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_bus_pci_dir = proc_mkdir_mode("pci", S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP, proc_bus);
+#endif
+#else
 	proc_bus_pci_dir = proc_mkdir("pci", proc_bus);
+#endif
 	entry = create_proc_entry("devices", 0, proc_bus_pci_dir);
 	if (entry)
 		entry->proc_fops = &proc_bus_pci_dev_operations;
diff -Nur linux-2.6.13.1.org/drivers/pci/rom.c grsecurity226/drivers/pci/rom.c
--- linux-2.6.13.1.org/drivers/pci/rom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/pci/rom.c	2005-08-30 01:00:18.000000000 +0200
@@ -21,21 +21,13 @@
  * between the ROM and other resources, so enabling it may disable access
  * to MMIO registers or other card memory.
  */
-static int pci_enable_rom(struct pci_dev *pdev)
+static void pci_enable_rom(struct pci_dev *pdev)
 {
-	struct resource *res = pdev->resource + PCI_ROM_RESOURCE;
-	struct pci_bus_region region;
 	u32 rom_addr;
 
-	if (!res->flags)
-		return -1;
-
-	pcibios_resource_to_bus(pdev, &region, res);
 	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
-	rom_addr &= ~PCI_ROM_ADDRESS_MASK;
-	rom_addr |= region.start | PCI_ROM_ADDRESS_ENABLE;
+	rom_addr |= PCI_ROM_ADDRESS_ENABLE;
 	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
-	return 0;
 }
 
 /**
@@ -79,21 +71,19 @@
 	} else {
 		if (res->flags & IORESOURCE_ROM_COPY) {
 			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-			return (void __iomem *)pci_resource_start(pdev,
-							     PCI_ROM_RESOURCE);
+			return (void __iomem *)pci_resource_start(pdev, PCI_ROM_RESOURCE);
 		} else {
 			/* assign the ROM an address if it doesn't have one */
-			if (res->parent == NULL &&
-			    pci_assign_resource(pdev,PCI_ROM_RESOURCE))
-				return NULL;
+			if (res->parent == NULL)
+				pci_assign_resource(pdev, PCI_ROM_RESOURCE);
+
 			start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
 			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
 			if (*size == 0)
 				return NULL;
 
 			/* Enable ROM space decodes */
-			if (pci_enable_rom(pdev))
-				return NULL;
+			pci_enable_rom(pdev);
 		}
 	}
 
diff -Nur linux-2.6.13.1.org/drivers/pci/setup-bus.c grsecurity226/drivers/pci/setup-bus.c
--- linux-2.6.13.1.org/drivers/pci/setup-bus.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/pci/setup-bus.c	2005-08-30 01:00:18.000000000 +0200
@@ -40,7 +40,7 @@
  * FIXME: IO should be max 256 bytes.  However, since we may
  * have a P2P bridge below a cardbus bridge, we need 4K.
  */
-#define CARDBUS_IO_SIZE		(4*1024)
+#define CARDBUS_IO_SIZE		(256)
 #define CARDBUS_MEM_SIZE	(32*1024*1024)
 
 static void __devinit
diff -Nur linux-2.6.13.1.org/drivers/pcmcia/hd64465_ss.c grsecurity226/drivers/pcmcia/hd64465_ss.c
--- linux-2.6.13.1.org/drivers/pcmcia/hd64465_ss.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/pcmcia/hd64465_ss.c	2005-08-30 01:00:19.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Device driver for the PCMCIA controller module of the
  * Hitachi HD64465 handheld companion chip.
diff -Nur linux-2.6.13.1.org/drivers/pcmcia/i82092.c grsecurity226/drivers/pcmcia/i82092.c
--- linux-2.6.13.1.org/drivers/pcmcia/i82092.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/pcmcia/i82092.c	2005-08-30 01:00:19.000000000 +0200
@@ -6,7 +6,7 @@
  * Author: Arjan Van De Ven <arjanv@redhat.com>
  * Loosly based on i82365.c from the pcmcia-cs package
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/kernel.h>
diff -Nur linux-2.6.13.1.org/drivers/pcmcia/i82092aa.h grsecurity226/drivers/pcmcia/i82092aa.h
--- linux-2.6.13.1.org/drivers/pcmcia/i82092aa.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/pcmcia/i82092aa.h	2005-08-30 01:00:19.000000000 +0200
@@ -3,7 +3,7 @@
 
 #include <linux/interrupt.h>
 
-/* $Id$ */
+/* $Id$ */
 
 /* Debuging defines */
 #ifdef NOTRACE
diff -Nur linux-2.6.13.1.org/drivers/pnp/pnpbios/bioscalls.c grsecurity226/drivers/pnp/pnpbios/bioscalls.c
--- linux-2.6.13.1.org/drivers/pnp/pnpbios/bioscalls.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/pnp/pnpbios/bioscalls.c	2005-08-30 01:14:09.000000000 +0200
@@ -69,17 +69,17 @@
 
 #define Q_SET_SEL(cpu, selname, address, size) \
 do { \
-set_base(per_cpu(cpu_gdt_table,cpu)[(selname) >> 3], __va((u32)(address))); \
-set_limit(per_cpu(cpu_gdt_table,cpu)[(selname) >> 3], size); \
+set_base(cpu_gdt_table[cpu][(selname) >> 3], __va((u32)(address))); \
+set_limit(cpu_gdt_table[cpu][(selname) >> 3], size); \
 } while(0)
 
 #define Q2_SET_SEL(cpu, selname, address, size) \
 do { \
-set_base(per_cpu(cpu_gdt_table,cpu)[(selname) >> 3], (u32)(address)); \
-set_limit(per_cpu(cpu_gdt_table,cpu)[(selname) >> 3], size); \
+set_base(cpu_gdt_table[cpu][(selname) >> 3], (u32)(address)); \
+set_limit(cpu_gdt_table[cpu][(selname) >> 3], size); \
 } while(0)
 
-static struct desc_struct bad_bios_desc = { 0, 0x00409200 };
+static struct desc_struct bad_bios_desc = { 0, 0x00409300 };
 
 /*
  * At some point we want to use this stack frame pointer to unwind
@@ -107,6 +107,10 @@
 	struct desc_struct save_desc_40;
 	int cpu;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr3;
+#endif
+
 	/*
 	 * PnP BIOSes are generally not terribly re-entrant.
 	 * Also, don't rely on them to save everything correctly.
@@ -115,12 +119,17 @@
 		return PNP_FUNCTION_NOT_SUPPORTED;
 
 	cpu = get_cpu();
-	save_desc_40 = per_cpu(cpu_gdt_table,cpu)[0x40 / 8];
-	per_cpu(cpu_gdt_table,cpu)[0x40 / 8] = bad_bios_desc;
 
 	/* On some boxes IRQ's during PnP BIOS calls are deadly.  */
 	spin_lock_irqsave(&pnp_bios_lock, flags);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel_noirq(cr3);
+#endif
+
+	save_desc_40 = cpu_gdt_table[cpu][0x40 / 8];
+	cpu_gdt_table[cpu][0x40 / 8] = bad_bios_desc;
+
 	/* The lock prevents us bouncing CPU here */
 	if (ts1_size)
 		Q2_SET_SEL(smp_processor_id(), PNP_TS1, ts1_base, ts1_size);
@@ -156,9 +165,14 @@
 		  "i" (0)
 		: "memory"
 	);
-	spin_unlock_irqrestore(&pnp_bios_lock, flags);
 
-	per_cpu(cpu_gdt_table,cpu)[0x40 / 8] = save_desc_40;
+	cpu_gdt_table[cpu][0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel_noirq(cr3);
+#endif
+
+	spin_unlock_irqrestore(&pnp_bios_lock, flags);
 	put_cpu();
 
 	/* If we get here and this is set then the PnP BIOS faulted on us. */
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd.c grsecurity226/drivers/s390/block/dasd.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd.c	2005-08-30 01:00:20.000000000 +0200
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_3370_erp.c grsecurity226/drivers/s390/block/dasd_3370_erp.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_3370_erp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_3370_erp.c	2005-08-30 01:00:20.000000000 +0200
@@ -4,7 +4,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #define PRINTK_HEADER "dasd_erp(3370)"
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_3990_erp.c grsecurity226/drivers/s390/block/dasd_3990_erp.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_3990_erp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_3990_erp.c	2005-08-30 01:00:20.000000000 +0200
@@ -5,7 +5,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000, 2001
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/timer.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_9336_erp.c grsecurity226/drivers/s390/block/dasd_9336_erp.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_9336_erp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_9336_erp.c	2005-08-30 01:00:20.000000000 +0200
@@ -4,7 +4,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #define PRINTK_HEADER "dasd_erp(9336)"
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_9343_erp.c grsecurity226/drivers/s390/block/dasd_9343_erp.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_9343_erp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_9343_erp.c	2005-08-30 01:00:20.000000000 +0200
@@ -4,7 +4,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #define PRINTK_HEADER "dasd_erp(9343)"
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_cmb.c grsecurity226/drivers/s390/block/dasd_cmb.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_cmb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_cmb.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/s390/block/dasd_cmb.c ($Revision$)
+ * linux/drivers/s390/block/dasd_cmb.c ($Revision$)
  *
  * Linux on zSeries Channel Measurement Facility support
  *  (dasd device driver interface)
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_devmap.c grsecurity226/drivers/s390/block/dasd_devmap.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_devmap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_devmap.c	2005-08-30 01:00:20.000000000 +0200
@@ -11,7 +11,7 @@
  * functions may not be called from interrupt context. In particular
  * dasd_get_device is a no-no from interrupt context.
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_diag.c grsecurity226/drivers/s390/block/dasd_diag.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_diag.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_diag.c	2005-08-30 01:00:20.000000000 +0200
@@ -6,7 +6,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_diag.h grsecurity226/drivers/s390/block/dasd_diag.h
--- linux-2.6.13.1.org/drivers/s390/block/dasd_diag.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_diag.h	2005-08-30 01:00:20.000000000 +0200
@@ -6,7 +6,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #define MDSK_WRITE_REQ 0x01
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_eckd.c grsecurity226/drivers/s390/block/dasd_eckd.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_eckd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_eckd.c	2005-08-30 01:00:20.000000000 +0200
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_eckd.h grsecurity226/drivers/s390/block/dasd_eckd.h
--- linux-2.6.13.1.org/drivers/s390/block/dasd_eckd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_eckd.h	2005-08-30 01:00:20.000000000 +0200
@@ -5,7 +5,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #ifndef DASD_ECKD_H
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_erp.c grsecurity226/drivers/s390/block/dasd_erp.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_erp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_erp.c	2005-08-30 01:00:20.000000000 +0200
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_fba.c grsecurity226/drivers/s390/block/dasd_fba.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_fba.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_fba.c	2005-08-30 01:00:20.000000000 +0200
@@ -4,7 +4,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_fba.h grsecurity226/drivers/s390/block/dasd_fba.h
--- linux-2.6.13.1.org/drivers/s390/block/dasd_fba.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_fba.h	2005-08-30 01:00:20.000000000 +0200
@@ -4,7 +4,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #ifndef DASD_FBA_H
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_genhd.c grsecurity226/drivers/s390/block/dasd_genhd.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_genhd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_genhd.c	2005-08-30 01:00:20.000000000 +0200
@@ -9,7 +9,7 @@
  *
  * gendisk related functions for the dasd driver.
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_int.h grsecurity226/drivers/s390/block/dasd_int.h
--- linux-2.6.13.1.org/drivers/s390/block/dasd_int.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_int.h	2005-08-30 01:00:20.000000000 +0200
@@ -6,7 +6,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision$
+ * $Revision$
  */
 
 #ifndef DASD_INT_H
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_ioctl.c grsecurity226/drivers/s390/block/dasd_ioctl.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_ioctl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_ioctl.c	2005-08-30 01:00:20.000000000 +0200
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision$
+ * $Revision$
  *
  * i/o controls for the dasd driver.
  */
diff -Nur linux-2.6.13.1.org/drivers/s390/block/dasd_proc.c grsecurity226/drivers/s390/block/dasd_proc.c
--- linux-2.6.13.1.org/drivers/s390/block/dasd_proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/block/dasd_proc.c	2005-08-30 01:00:20.000000000 +0200
@@ -9,7 +9,7 @@
  *
  * /proc interface for the dasd driver.
  *
- * $Revision$
+ * $Revision$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/char/tape_34xx.c grsecurity226/drivers/s390/char/tape_34xx.c
--- linux-2.6.13.1.org/drivers/s390/char/tape_34xx.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/char/tape_34xx.c	2005-08-30 01:00:20.000000000 +0200
@@ -1357,7 +1357,7 @@
 	debug_set_level(TAPE_DBF_AREA, 6);
 #endif
 
-	DBF_EVENT(3, "34xx init: $Revision$\n");
+	DBF_EVENT(3, "34xx init: $Revision$\n");
 	/* Register driver for 3480/3490 tapes. */
 	rc = ccw_driver_register(&tape_34xx_driver);
 	if (rc)
@@ -1378,7 +1378,7 @@
 MODULE_DEVICE_TABLE(ccw, tape_34xx_ids);
 MODULE_AUTHOR("(C) 2001-2002 IBM Deutschland Entwicklung GmbH");
 MODULE_DESCRIPTION("Linux on zSeries channel attached 3480 tape "
-		   "device driver ($Revision$)");
+		   "device driver ($Revision$)");
 MODULE_LICENSE("GPL");
 
 module_init(tape_34xx_init);
diff -Nur linux-2.6.13.1.org/drivers/s390/char/tape_class.c grsecurity226/drivers/s390/char/tape_class.c
--- linux-2.6.13.1.org/drivers/s390/char/tape_class.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/char/tape_class.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright IBM Corp. 2004
- * tape_class.c ($Revision$)
+ * tape_class.c ($Revision$)
  *
  * Tape class device support
  *
@@ -12,7 +12,7 @@
 MODULE_AUTHOR("Stefan Bader <shbader@de.ibm.com>");
 MODULE_DESCRIPTION(
 	"(C) Copyright IBM Corp. 2004   All Rights Reserved.\n"
-	"tape_class.c ($Revision$)"
+	"tape_class.c ($Revision$)"
 );
 MODULE_LICENSE("GPL");
 
diff -Nur linux-2.6.13.1.org/drivers/s390/char/tape_class.h grsecurity226/drivers/s390/char/tape_class.h
--- linux-2.6.13.1.org/drivers/s390/char/tape_class.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/char/tape_class.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright IBM Corp. 2004   All Rights Reserved.
- * tape_class.h ($Revision$)
+ * tape_class.h ($Revision$)
  *
  * Tape class device support
  *
diff -Nur linux-2.6.13.1.org/drivers/s390/char/tape_core.c grsecurity226/drivers/s390/char/tape_core.c
--- linux-2.6.13.1.org/drivers/s390/char/tape_core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/char/tape_core.c	2005-08-30 01:00:20.000000000 +0200
@@ -1242,7 +1242,7 @@
 #ifdef DBF_LIKE_HELL
 	debug_set_level(TAPE_DBF_AREA, 6);
 #endif
-	DBF_EVENT(3, "tape init: ($Revision$)\n");
+	DBF_EVENT(3, "tape init: ($Revision$)\n");
 	tape_proc_init();
 	tapechar_init ();
 	tapeblock_init ();
@@ -1267,7 +1267,7 @@
 MODULE_AUTHOR("(C) 2001 IBM Deutschland Entwicklung GmbH by Carsten Otte and "
 	      "Michael Holzheu (cotte@de.ibm.com,holzheu@de.ibm.com)");
 MODULE_DESCRIPTION("Linux on zSeries channel attached "
-		   "tape device driver ($Revision$)");
+		   "tape device driver ($Revision$)");
 MODULE_LICENSE("GPL");
 
 module_init(tape_init);
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/airq.c grsecurity226/drivers/s390/cio/airq.c
--- linux-2.6.13.1.org/drivers/s390/cio/airq.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/airq.c	2005-08-30 01:00:20.000000000 +0200
@@ -2,7 +2,7 @@
  *  drivers/s390/cio/airq.c
  *   S/390 common I/O routines -- support for adapter interruptions
  *
- *   $Revision$
+ *   $Revision$
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/blacklist.c grsecurity226/drivers/s390/cio/blacklist.c
--- linux-2.6.13.1.org/drivers/s390/cio/blacklist.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/blacklist.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/blacklist.c
  *   S/390 common I/O routines -- blacklisting of specific devices
- *   $Revision$
+ *   $Revision$
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/ccwgroup.c grsecurity226/drivers/s390/cio/ccwgroup.c
--- linux-2.6.13.1.org/drivers/s390/cio/ccwgroup.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/ccwgroup.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/ccwgroup.c
  *  bus driver for ccwgroup
- *   $Revision$
+ *   $Revision$
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *                       IBM Corporation
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/chsc.c grsecurity226/drivers/s390/cio/chsc.c
--- linux-2.6.13.1.org/drivers/s390/cio/chsc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/chsc.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/chsc.c
  *   S/390 common I/O routines -- channel subsystem call
- *   $Revision$
+ *   $Revision$
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/cio.c grsecurity226/drivers/s390/cio/cio.c
--- linux-2.6.13.1.org/drivers/s390/cio/cio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/cio.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/cio.c
  *   S/390 common I/O routines -- low level i/o calls
- *   $Revision$
+ *   $Revision$
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/cmf.c grsecurity226/drivers/s390/cio/cmf.c
--- linux-2.6.13.1.org/drivers/s390/cio/cmf.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/cmf.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/s390/cio/cmf.c ($Revision$)
+ * linux/drivers/s390/cio/cmf.c ($Revision$)
  *
  * Linux on zSeries Channel Measurement Facility support
  *
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/css.c grsecurity226/drivers/s390/cio/css.c
--- linux-2.6.13.1.org/drivers/s390/cio/css.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/css.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/css.c
  *  driver for channel subsystem
- *   $Revision$
+ *   $Revision$
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/device.c grsecurity226/drivers/s390/cio/device.c
--- linux-2.6.13.1.org/drivers/s390/cio/device.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/device.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device.c
  *  bus driver for ccw devices
- *   $Revision$
+ *   $Revision$
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/device_ops.c grsecurity226/drivers/s390/cio/device_ops.c
--- linux-2.6.13.1.org/drivers/s390/cio/device_ops.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/device_ops.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device_ops.c
  *
- *   $Revision$
+ *   $Revision$
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/qdio.c grsecurity226/drivers/s390/cio/qdio.c
--- linux-2.6.13.1.org/drivers/s390/cio/qdio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/qdio.c	2005-08-30 01:00:20.000000000 +0200
@@ -56,7 +56,7 @@
 #include "ioasm.h"
 #include "chsc.h"
 
-#define VERSION_QDIO_C "$Revision$"
+#define VERSION_QDIO_C "$Revision$"
 
 /****************** MODULE PARAMETER VARIABLES ********************/
 MODULE_AUTHOR("Utz Bacher <utz.bacher@de.ibm.com>");
diff -Nur linux-2.6.13.1.org/drivers/s390/cio/qdio.h grsecurity226/drivers/s390/cio/qdio.h
--- linux-2.6.13.1.org/drivers/s390/cio/qdio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/cio/qdio.h	2005-08-30 01:00:20.000000000 +0200
@@ -3,7 +3,7 @@
 
 #include <asm/page.h>
 
-#define VERSION_CIO_QDIO_H "$Revision$"
+#define VERSION_CIO_QDIO_H "$Revision$"
 
 #ifdef CONFIG_QDIO_DEBUG
 #define QDIO_VERBOSE_LEVEL 9
diff -Nur linux-2.6.13.1.org/drivers/s390/crypto/z90common.h grsecurity226/drivers/s390/crypto/z90common.h
--- linux-2.6.13.1.org/drivers/s390/crypto/z90common.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/crypto/z90common.h	2005-08-30 01:00:20.000000000 +0200
@@ -27,7 +27,7 @@
 #ifndef _Z90COMMON_H_
 #define _Z90COMMON_H_
 
-#define VERSION_Z90COMMON_H "$Revision$"
+#define VERSION_Z90COMMON_H "$Revision$"
 
 
 #define RESPBUFFSIZE 256
diff -Nur linux-2.6.13.1.org/drivers/s390/crypto/z90crypt.h grsecurity226/drivers/s390/crypto/z90crypt.h
--- linux-2.6.13.1.org/drivers/s390/crypto/z90crypt.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/crypto/z90crypt.h	2005-08-30 01:00:20.000000000 +0200
@@ -29,7 +29,7 @@
 
 #include <linux/ioctl.h>
 
-#define VERSION_Z90CRYPT_H "$Revision$"
+#define VERSION_Z90CRYPT_H "$Revision$"
 
 #define z90crypt_VERSION 1
 #define z90crypt_RELEASE 3	// 2 = PCIXCC, 3 = rewrite for coding standards
diff -Nur linux-2.6.13.1.org/drivers/s390/crypto/z90hardware.c grsecurity226/drivers/s390/crypto/z90hardware.c
--- linux-2.6.13.1.org/drivers/s390/crypto/z90hardware.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/crypto/z90hardware.c	2005-08-30 01:00:20.000000000 +0200
@@ -32,7 +32,7 @@
 #include "z90crypt.h"
 #include "z90common.h"
 
-#define VERSION_Z90HARDWARE_C "$Revision$"
+#define VERSION_Z90HARDWARE_C "$Revision$"
 
 char z90hardware_version[] __initdata =
 	"z90hardware.o (" VERSION_Z90HARDWARE_C "/"
diff -Nur linux-2.6.13.1.org/drivers/s390/crypto/z90main.c grsecurity226/drivers/s390/crypto/z90main.c
--- linux-2.6.13.1.org/drivers/s390/crypto/z90main.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/crypto/z90main.c	2005-08-30 01:00:20.000000000 +0200
@@ -51,7 +51,7 @@
 #  error "This kernel is too recent: not supported by this file"
 #endif
 
-#define VERSION_Z90MAIN_C "$Revision$"
+#define VERSION_Z90MAIN_C "$Revision$"
 
 static char z90main_version[] __initdata =
 	"z90main.o (" VERSION_Z90MAIN_C "/"
diff -Nur linux-2.6.13.1.org/drivers/s390/net/claw.c grsecurity226/drivers/s390/net/claw.c
--- linux-2.6.13.1.org/drivers/s390/net/claw.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/claw.c	2005-08-30 01:00:20.000000000 +0200
@@ -2,7 +2,7 @@
  *  drivers/s390/net/claw.c
  *    ESCON CLAW network driver
  *
- *    $Revision$ $Date$
+ *    $Revision$ $Date$
  *
  *  Linux fo zSeries version
  *    Copyright (C) 2002,2005 IBM Corporation
@@ -4410,7 +4410,7 @@
 #else
                 "compiled into kernel "
 #endif
-                " $Revision$ $Date$ \n");
+                " $Revision$ $Date$ \n");
 
 
 #ifdef FUNCTRACE
diff -Nur linux-2.6.13.1.org/drivers/s390/net/claw.h grsecurity226/drivers/s390/net/claw.h
--- linux-2.6.13.1.org/drivers/s390/net/claw.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/claw.h	2005-08-30 01:00:20.000000000 +0200
@@ -2,7 +2,7 @@
 *  Define constants                                    *
 *                                                      *
 ********************************************************/
-#define VERSION_CLAW_H "$Revision$"
+#define VERSION_CLAW_H "$Revision$"
 /*-----------------------------------------------------*
 *     CCW command codes for CLAW protocol              *
 *------------------------------------------------------*/
diff -Nur linux-2.6.13.1.org/drivers/s390/net/ctcdbug.c grsecurity226/drivers/s390/net/ctcdbug.c
--- linux-2.6.13.1.org/drivers/s390/net/ctcdbug.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/ctcdbug.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/ctcdbug.c ($Revision$)
+ * linux/drivers/s390/net/ctcdbug.c ($Revision$)
  *
  * CTC / ESCON network driver - s390 dbf exploit.
  *
@@ -9,7 +9,7 @@
  *    Author(s): Original Code written by
  *			  Peter Tiedemann (ptiedem@de.ibm.com)
  *
- *    $Revision$	 $Date$
+ *    $Revision$	 $Date$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/s390/net/ctcdbug.h grsecurity226/drivers/s390/net/ctcdbug.h
--- linux-2.6.13.1.org/drivers/s390/net/ctcdbug.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/ctcdbug.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/ctcdbug.h ($Revision$)
+ * linux/drivers/s390/net/ctcdbug.h ($Revision$)
  *
  * CTC / ESCON network driver - s390 dbf exploit.
  *
@@ -9,7 +9,7 @@
  *    Author(s): Original Code written by
  *			  Peter Tiedemann (ptiedem@de.ibm.com)
  *
- *    $Revision$	 $Date$
+ *    $Revision$	 $Date$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/drivers/s390/net/ctcmain.c grsecurity226/drivers/s390/net/ctcmain.c
--- linux-2.6.13.1.org/drivers/s390/net/ctcmain.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/ctcmain.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * CTC / ESCON network driver
  *
@@ -37,7 +37,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision$
+ * RELEASE-TAG: CTC/ESCON network driver $Revision$
  *
  */
 
@@ -249,7 +249,7 @@
 print_banner(void)
 {
 	static int printed = 0;
-	char vbuf[] = "$Revision$";
+	char vbuf[] = "$Revision$";
 	char *version = vbuf;
 
 	if (printed)
diff -Nur linux-2.6.13.1.org/drivers/s390/net/ctcmain.h grsecurity226/drivers/s390/net/ctcmain.h
--- linux-2.6.13.1.org/drivers/s390/net/ctcmain.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/ctcmain.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * CTC / ESCON network driver
  *
@@ -29,7 +29,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision$
+ * RELEASE-TAG: CTC/ESCON network driver $Revision$
  *
  */
 
diff -Nur linux-2.6.13.1.org/drivers/s390/net/ctctty.c grsecurity226/drivers/s390/net/ctctty.c
--- linux-2.6.13.1.org/drivers/s390/net/ctctty.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/ctctty.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * CTC / ESCON network driver, tty interface.
  *
diff -Nur linux-2.6.13.1.org/drivers/s390/net/ctctty.h grsecurity226/drivers/s390/net/ctctty.h
--- linux-2.6.13.1.org/drivers/s390/net/ctctty.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/ctctty.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * CTC / ESCON network driver, tty interface.
  *
diff -Nur linux-2.6.13.1.org/drivers/s390/net/cu3088.c grsecurity226/drivers/s390/net/cu3088.c
--- linux-2.6.13.1.org/drivers/s390/net/cu3088.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/cu3088.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * CTC / LCS ccw_device driver
  *
diff -Nur linux-2.6.13.1.org/drivers/s390/net/fsm.c grsecurity226/drivers/s390/net/fsm.c
--- linux-2.6.13.1.org/drivers/s390/net/fsm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/fsm.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * $Id$
+ * $Id$
  *
  * A generic FSM based on fsm used in isdn4linux
  *
diff -Nur linux-2.6.13.1.org/drivers/s390/net/fsm.h grsecurity226/drivers/s390/net/fsm.h
--- linux-2.6.13.1.org/drivers/s390/net/fsm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/fsm.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  */
 #ifndef _FSM_H_
 #define _FSM_H_
diff -Nur linux-2.6.13.1.org/drivers/s390/net/iucv.c grsecurity226/drivers/s390/net/iucv.c
--- linux-2.6.13.1.org/drivers/s390/net/iucv.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/iucv.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /* 
- * $Id$
+ * $Id$
  *
  * IUCV network driver
  *
@@ -29,7 +29,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV lowlevel driver $Revision$
+ * RELEASE-TAG: IUCV lowlevel driver $Revision$
  *
  */
 
@@ -355,7 +355,7 @@
 static void
 iucv_banner(void)
 {
-	char vbuf[] = "$Revision$";
+	char vbuf[] = "$Revision$";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
diff -Nur linux-2.6.13.1.org/drivers/s390/net/lcs.c grsecurity226/drivers/s390/net/lcs.c
--- linux-2.6.13.1.org/drivers/s390/net/lcs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/lcs.c	2005-08-30 01:00:20.000000000 +0200
@@ -11,7 +11,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Martin Schwidefsky <schwidefsky@de.ibm.com>
  *
- *    $Revision$	 $Date$
+ *    $Revision$	 $Date$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -59,7 +59,7 @@
 /**
  * initialization string for output
  */
-#define VERSION_LCS_C  "$Revision$"
+#define VERSION_LCS_C  "$Revision$"
 
 static char version[] __initdata = "LCS driver ("VERSION_LCS_C "/" VERSION_LCS_H ")";
 static char debug_buffer[255];
diff -Nur linux-2.6.13.1.org/drivers/s390/net/lcs.h grsecurity226/drivers/s390/net/lcs.h
--- linux-2.6.13.1.org/drivers/s390/net/lcs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/lcs.h	2005-08-30 01:00:20.000000000 +0200
@@ -6,7 +6,7 @@
 #include <linux/workqueue.h>
 #include <asm/ccwdev.h>
 
-#define VERSION_LCS_H "$Revision$"
+#define VERSION_LCS_H "$Revision$"
 
 #define LCS_DBF_TEXT(level, name, text) \
 	do { \
diff -Nur linux-2.6.13.1.org/drivers/s390/net/netiucv.c grsecurity226/drivers/s390/net/netiucv.c
--- linux-2.6.13.1.org/drivers/s390/net/netiucv.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/netiucv.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * IUCV network driver
  *
@@ -30,7 +30,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV network driver $Revision$
+ * RELEASE-TAG: IUCV network driver $Revision$
  *
  */
 
@@ -2076,7 +2076,7 @@
 static void
 netiucv_banner(void)
 {
-	char vbuf[] = "$Revision$";
+	char vbuf[] = "$Revision$";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth.h grsecurity226/drivers/s390/net/qeth.h
--- linux-2.6.13.1.org/drivers/s390/net/qeth.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth.h	2005-08-30 01:00:20.000000000 +0200
@@ -24,7 +24,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision$"
+#define VERSION_QETH_H 		"$Revision$"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_eddp.c grsecurity226/drivers/s390/net/qeth_eddp.c
--- linux-2.6.13.1.org/drivers/s390/net/qeth_eddp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_eddp.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_eddp.c ($Revision$)
+ * linux/drivers/s390/net/qeth_eddp.c ($Revision$)
  *
  * Enhanced Device Driver Packing (EDDP) support for the qeth driver.
  *
@@ -8,7 +8,7 @@
  *
  *    Author(s): Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision$	 $Date$
+ *    $Revision$	 $Date$
  *
  */
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_eddp.h grsecurity226/drivers/s390/net/qeth_eddp.h
--- linux-2.6.13.1.org/drivers/s390/net/qeth_eddp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_eddp.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/s390/net/qeth_eddp.c ($Revision$)
+ * linux/drivers/s390/net/qeth_eddp.c ($Revision$)
  *
  * Header file for qeth enhanced device driver pakcing.
  *
@@ -7,7 +7,7 @@
  *
  *    Author(s): Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision$	 $Date$
+ *    $Revision$	 $Date$
  *
  */
 #ifndef __QETH_EDDP_H__
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_fs.h grsecurity226/drivers/s390/net/qeth_fs.h
--- linux-2.6.13.1.org/drivers/s390/net/qeth_fs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_fs.h	2005-08-30 01:00:20.000000000 +0200
@@ -12,7 +12,7 @@
 #ifndef __QETH_FS_H__
 #define __QETH_FS_H__
 
-#define VERSION_QETH_FS_H "$Revision$"
+#define VERSION_QETH_FS_H "$Revision$"
 
 extern const char *VERSION_QETH_PROC_C;
 extern const char *VERSION_QETH_SYS_C;
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_main.c grsecurity226/drivers/s390/net/qeth_main.c
--- linux-2.6.13.1.org/drivers/s390/net/qeth_main.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_main.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_main.c ($Revision$)
+ * linux/drivers/s390/net/qeth_main.c ($Revision$)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision$	 $Date$
+ *    $Revision$	 $Date$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -80,7 +80,7 @@
 #include "qeth_eddp.h"
 #include "qeth_tso.h"
 
-#define VERSION_QETH_C "$Revision$"
+#define VERSION_QETH_C "$Revision$"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_mpc.c grsecurity226/drivers/s390/net/qeth_mpc.c
--- linux-2.6.13.1.org/drivers/s390/net/qeth_mpc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_mpc.c	2005-08-30 01:00:20.000000000 +0200
@@ -11,7 +11,7 @@
 #include <asm/cio.h>
 #include "qeth_mpc.h"
 
-const char *VERSION_QETH_MPC_C = "$Revision$";
+const char *VERSION_QETH_MPC_C = "$Revision$";
 
 unsigned char IDX_ACTIVATE_READ[]={
 	0x00,0x00,0x80,0x00, 0x00,0x00,0x00,0x00,
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_mpc.h grsecurity226/drivers/s390/net/qeth_mpc.h
--- linux-2.6.13.1.org/drivers/s390/net/qeth_mpc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_mpc.h	2005-08-30 01:00:20.000000000 +0200
@@ -14,7 +14,7 @@
 
 #include <asm/qeth.h>
 
-#define VERSION_QETH_MPC_H "$Revision$"
+#define VERSION_QETH_MPC_H "$Revision$"
 
 extern const char *VERSION_QETH_MPC_C;
 
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_proc.c grsecurity226/drivers/s390/net/qeth_proc.c
--- linux-2.6.13.1.org/drivers/s390/net/qeth_proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_proc.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_fs.c ($Revision$)
+ * linux/drivers/s390/net/qeth_fs.c ($Revision$)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to procfs.
@@ -21,7 +21,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-const char *VERSION_QETH_PROC_C = "$Revision$";
+const char *VERSION_QETH_PROC_C = "$Revision$";
 
 /***** /proc/qeth *****/
 #define QETH_PROCFILE_NAME "qeth"
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_sys.c grsecurity226/drivers/s390/net/qeth_sys.c
--- linux-2.6.13.1.org/drivers/s390/net/qeth_sys.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_sys.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_sys.c ($Revision$)
+ * linux/drivers/s390/net/qeth_sys.c ($Revision$)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to sysfs.
@@ -20,7 +20,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-const char *VERSION_QETH_SYS_C = "$Revision$";
+const char *VERSION_QETH_SYS_C = "$Revision$";
 
 /*****************************************************************************/
 /*                                                                           */
diff -Nur linux-2.6.13.1.org/drivers/s390/net/qeth_tso.h grsecurity226/drivers/s390/net/qeth_tso.h
--- linux-2.6.13.1.org/drivers/s390/net/qeth_tso.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/net/qeth_tso.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/s390/net/qeth_tso.h ($Revision$)
+ * linux/drivers/s390/net/qeth_tso.h ($Revision$)
  *
  * Header file for qeth TCP Segmentation Offload support.
  *
@@ -7,7 +7,7 @@
  *
  *    Author(s): Frank Pavlic <pavlic@de.ibm.com>
  *
- *    $Revision$	 $Date$
+ *    $Revision$	 $Date$
  *
  */
 #ifndef __QETH_TSO_H__
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_aux.c grsecurity226/drivers/s390/scsi/zfcp_aux.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_aux.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_aux.c	2005-08-30 01:00:20.000000000 +0200
@@ -29,7 +29,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_AUX_REVISION "$Revision$"
+#define ZFCP_AUX_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_ccw.c grsecurity226/drivers/s390/scsi/zfcp_ccw.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_ccw.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_ccw.c	2005-08-30 01:00:20.000000000 +0200
@@ -27,7 +27,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_CCW_C_REVISION "$Revision$"
+#define ZFCP_CCW_C_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_def.h grsecurity226/drivers/s390/scsi/zfcp_def.h
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_def.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_def.h	2005-08-30 01:00:20.000000000 +0200
@@ -34,7 +34,7 @@
 #ifndef ZFCP_DEF_H
 #define ZFCP_DEF_H
 
-#define ZFCP_DEF_REVISION "$Revision$"
+#define ZFCP_DEF_REVISION "$Revision$"
 
 /*************************** INCLUDES *****************************************/
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_erp.c grsecurity226/drivers/s390/scsi/zfcp_erp.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_erp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_erp.c	2005-08-30 01:00:20.000000000 +0200
@@ -31,7 +31,7 @@
 
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_ERP
 
-#define ZFCP_ERP_REVISION "$Revision$"
+#define ZFCP_ERP_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_ext.h grsecurity226/drivers/s390/scsi/zfcp_ext.h
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_ext.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_ext.h	2005-08-30 01:00:20.000000000 +0200
@@ -32,7 +32,7 @@
 #ifndef ZFCP_EXT_H
 #define ZFCP_EXT_H
 
-#define ZFCP_EXT_REVISION "$Revision$"
+#define ZFCP_EXT_REVISION "$Revision$"
 
 #include "zfcp_def.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_fsf.c grsecurity226/drivers/s390/scsi/zfcp_fsf.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_fsf.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_fsf.c	2005-08-30 01:00:20.000000000 +0200
@@ -30,7 +30,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_FSF_C_REVISION "$Revision$"
+#define ZFCP_FSF_C_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_qdio.c grsecurity226/drivers/s390/scsi/zfcp_qdio.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_qdio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_qdio.c	2005-08-30 01:00:20.000000000 +0200
@@ -29,7 +29,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_QDIO_C_REVISION "$Revision$"
+#define ZFCP_QDIO_C_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_scsi.c grsecurity226/drivers/s390/scsi/zfcp_scsi.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_scsi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_scsi.c	2005-08-30 01:00:20.000000000 +0200
@@ -31,7 +31,7 @@
 
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
 
-#define ZFCP_SCSI_REVISION "$Revision$"
+#define ZFCP_SCSI_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_sysfs_adapter.c grsecurity226/drivers/s390/scsi/zfcp_sysfs_adapter.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_sysfs_adapter.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_sysfs_adapter.c	2005-08-30 01:00:20.000000000 +0200
@@ -27,7 +27,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_SYSFS_ADAPTER_C_REVISION "$Revision$"
+#define ZFCP_SYSFS_ADAPTER_C_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_sysfs_driver.c grsecurity226/drivers/s390/scsi/zfcp_sysfs_driver.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_sysfs_driver.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_sysfs_driver.c	2005-08-30 01:00:20.000000000 +0200
@@ -27,7 +27,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_SYSFS_DRIVER_C_REVISION "$Revision$"
+#define ZFCP_SYSFS_DRIVER_C_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_sysfs_port.c grsecurity226/drivers/s390/scsi/zfcp_sysfs_port.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_sysfs_port.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_sysfs_port.c	2005-08-30 01:00:20.000000000 +0200
@@ -28,7 +28,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_SYSFS_PORT_C_REVISION "$Revision$"
+#define ZFCP_SYSFS_PORT_C_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/s390/scsi/zfcp_sysfs_unit.c grsecurity226/drivers/s390/scsi/zfcp_sysfs_unit.c
--- linux-2.6.13.1.org/drivers/s390/scsi/zfcp_sysfs_unit.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/s390/scsi/zfcp_sysfs_unit.c	2005-08-30 01:00:20.000000000 +0200
@@ -28,7 +28,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_SYSFS_UNIT_C_REVISION "$Revision$"
+#define ZFCP_SYSFS_UNIT_C_REVISION "$Revision$"
 
 #include "zfcp_ext.h"
 
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/aurora.c grsecurity226/drivers/sbus/char/aurora.c
--- linux-2.6.13.1.org/drivers/sbus/char/aurora.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/aurora.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/*	$Id$
+/*	$Id$
  *	linux/drivers/sbus/char/aurora.c -- Aurora multiport driver
  *
  *	Copyright (c) 1999 by Oliver Aldulea (oli at bv dot ro)
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/aurora.h grsecurity226/drivers/sbus/char/aurora.h
--- linux-2.6.13.1.org/drivers/sbus/char/aurora.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/aurora.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/*	$Id$
+/*	$Id$
  *	linux/drivers/sbus/char/aurora.h -- Aurora multiport driver
  *
  *	Copyright (c) 1999 by Oliver Aldulea (oli@bv.ro)
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/bbc_envctrl.c grsecurity226/drivers/sbus/char/bbc_envctrl.c
--- linux-2.6.13.1.org/drivers/sbus/char/bbc_envctrl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/bbc_envctrl.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * bbc_envctrl.c: UltraSPARC-III environment control driver.
  *
  * Copyright (C) 2001 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/bbc_i2c.c grsecurity226/drivers/sbus/char/bbc_i2c.c
--- linux-2.6.13.1.org/drivers/sbus/char/bbc_i2c.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/bbc_i2c.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * bbc_i2c.c: I2C low-level driver for BBC device on UltraSPARC-III
  *            platforms.
  *
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/bbc_i2c.h grsecurity226/drivers/sbus/char/bbc_i2c.h
--- linux-2.6.13.1.org/drivers/sbus/char/bbc_i2c.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/bbc_i2c.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _BBC_I2C_H
 #define _BBC_I2C_H
 
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/display7seg.c grsecurity226/drivers/sbus/char/display7seg.c
--- linux-2.6.13.1.org/drivers/sbus/char/display7seg.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/display7seg.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * display7seg - Driver implementation for the 7-segment display
  * present on Sun Microsystems CP1400 and CP1500
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/envctrl.c grsecurity226/drivers/sbus/char/envctrl.c
--- linux-2.6.13.1.org/drivers/sbus/char/envctrl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/envctrl.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * envctrl.c: Temperature and Fan monitoring on Machines providing it.
  *
  * Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/flash.c grsecurity226/drivers/sbus/char/flash.c
--- linux-2.6.13.1.org/drivers/sbus/char/flash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/flash.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * flash.c: Allow mmap access to the OBP Flash, for OBP updates.
  *
  * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/max1617.h grsecurity226/drivers/sbus/char/max1617.h
--- linux-2.6.13.1.org/drivers/sbus/char/max1617.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/max1617.h	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _MAX1617_H
 #define _MAX1617_H
 
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/riowatchdog.c grsecurity226/drivers/sbus/char/riowatchdog.c
--- linux-2.6.13.1.org/drivers/sbus/char/riowatchdog.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/riowatchdog.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * riowatchdog.c - driver for hw watchdog inside Super I/O of RIO
  *
  * Copyright (C) 2001 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/rtc.c grsecurity226/drivers/sbus/char/rtc.c
--- linux-2.6.13.1.org/drivers/sbus/char/rtc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/rtc.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux/SPARC Real Time Clock Driver
  * Copyright (C) 1996 Thomas K. Dyas (tdyas@eden.rutgers.edu)
diff -Nur linux-2.6.13.1.org/drivers/sbus/char/uctrl.c grsecurity226/drivers/sbus/char/uctrl.c
--- linux-2.6.13.1.org/drivers/sbus/char/uctrl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/char/uctrl.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * uctrl.c: TS102 Microcontroller interface on Tadpole Sparcbook 3
  *
  * Copyright 1999 Derrick J Brashear (shadow@dementia.org)
diff -Nur linux-2.6.13.1.org/drivers/sbus/sbus.c grsecurity226/drivers/sbus/sbus.c
--- linux-2.6.13.1.org/drivers/sbus/sbus.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/sbus/sbus.c	2005-08-30 01:00:20.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sbus.c:  SBus support routines.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/drivers/scsi/NCR5380.c grsecurity226/drivers/scsi/NCR5380.c
--- linux-2.6.13.1.org/drivers/scsi/NCR5380.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/NCR5380.c	2005-08-30 01:00:21.000000000 +0200
@@ -28,6 +28,9 @@
 
 /*
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
 
  * Revision 1.10 1998/9/2	Alan Cox
  *				(alan@redhat.com)
diff -Nur linux-2.6.13.1.org/drivers/scsi/NCR5380.h grsecurity226/drivers/scsi/NCR5380.h
--- linux-2.6.13.1.org/drivers/scsi/NCR5380.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/NCR5380.h	2005-08-30 01:00:21.000000000 +0200
@@ -23,6 +23,9 @@
 
 /*
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 #ifndef NCR5380_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/a2091.h grsecurity226/drivers/scsi/a2091.h
--- linux-2.6.13.1.org/drivers/scsi/a2091.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/a2091.h	2005-08-30 01:00:21.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef A2091_H
 #define A2091_H
 
-/* $Id$
+/* $Id$
  *
  * Header file for the Commodore A2091 Zorro II SCSI controller for Linux
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/a3000.h grsecurity226/drivers/scsi/a3000.h
--- linux-2.6.13.1.org/drivers/scsi/a3000.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/a3000.h	2005-08-30 01:00:21.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef A3000_H
 #define A3000_H
 
-/* $Id$
+/* $Id$
  *
  * Header file for the Amiga 3000 built-in SCSI controller for Linux
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/aacraid/aachba.c grsecurity226/drivers/scsi/aacraid/aachba.c
--- linux-2.6.13.1.org/drivers/scsi/aacraid/aachba.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aacraid/aachba.c	2005-08-30 01:00:22.000000000 +0200
@@ -968,7 +968,7 @@
 		fibsize = sizeof(struct aac_read64) + 
 			((le32_to_cpu(readcmd->sg.count) - 1) * 
 			 sizeof (struct sgentry64));
-		BUG_ON (fibsize > (dev->max_fib_size - 
+		BUG_ON (fibsize > (sizeof(struct hw_fib) - 
 					sizeof(struct aac_fibhdr)));
 		/*
 		 *	Now send the Fib to the adapter
diff -Nur linux-2.6.13.1.org/drivers/scsi/aha152x.c grsecurity226/drivers/scsi/aha152x.c
--- linux-2.6.13.1.org/drivers/scsi/aha152x.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aha152x.c	2005-08-30 01:00:21.000000000 +0200
@@ -13,9 +13,12 @@
  * General Public License for more details.
  *
  *
- * $Id$
+ * $Id$
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 2.7  2004/01/24 11:42:59  fischer
  * - gather code that is not used by PCMCIA at the end
  * - move request_region for !PCMCIA case to detection
diff -Nur linux-2.6.13.1.org/drivers/scsi/aha152x.h grsecurity226/drivers/scsi/aha152x.h
--- linux-2.6.13.1.org/drivers/scsi/aha152x.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aha152x.h	2005-08-30 01:00:21.000000000 +0200
@@ -2,14 +2,14 @@
 #define _AHA152X_H
 
 /*
- * $Id$
+ * $Id$
  */
 
 /* number of queueable commands
    (unless we support more than 1 cmd_per_lun this should do) */
 #define AHA152X_MAXQUEUE 7
 
-#define AHA152X_REVID "Adaptec 152x SCSI driver; $Revision$"
+#define AHA152X_REVID "Adaptec 152x SCSI driver; $Revision$"
 
 /* port addresses */
 #define SCSISEQ      (HOSTIOPORT0+0x00)    /* SCSI sequence control */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aha1542.c grsecurity226/drivers/scsi/aha1542.c
--- linux-2.6.13.1.org/drivers/scsi/aha1542.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aha1542.c	2005-08-30 01:00:21.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *  linux/kernel/aha1542.c
  *
  *  Copyright (C) 1992  Tommy Thorn
@@ -88,7 +88,7 @@
 #endif
 
 /*
-   static const char RCSid[] = "$Header$";
+   static const char RCSid[] = "$Header$";
  */
 
 /* The adaptec can be configured for quite a number of addresses, but
diff -Nur linux-2.6.13.1.org/drivers/scsi/aha1542.h grsecurity226/drivers/scsi/aha1542.h
--- linux-2.6.13.1.org/drivers/scsi/aha1542.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aha1542.h	2005-08-30 01:00:21.000000000 +0200
@@ -1,10 +1,13 @@
 #ifndef _AHA1542_H
 
-/* $Id$
+/* $Id$
  *
  * Header file for the adaptec 1542 driver for Linux
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.1  1992/07/24  06:27:38  root
  * Initial revision
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/aha1740.c grsecurity226/drivers/scsi/aha1740.c
--- linux-2.6.13.1.org/drivers/scsi/aha1740.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aha1740.c	2005-08-30 01:00:21.000000000 +0200
@@ -1,4 +1,4 @@
-/*  $Id$
+/*  $Id$
  *  1993/03/31
  *  linux/kernel/aha1740.c
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/aha1740.h grsecurity226/drivers/scsi/aha1740.h
--- linux-2.6.13.1.org/drivers/scsi/aha1740.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aha1740.h	2005-08-30 01:00:21.000000000 +0200
@@ -1,6 +1,6 @@
 #ifndef _AHA1740_H
 
-/* $Id$
+/* $Id$
  *
  * Header file for the adaptec 1740 driver for Linux
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/Kconfig.aic79xx grsecurity226/drivers/scsi/aic7xxx/Kconfig.aic79xx
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/Kconfig.aic79xx	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/Kconfig.aic79xx	2005-08-30 01:00:22.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # AIC79XX 2.5.X Kernel configuration File.
-# $Id$
+# $Id$
 #
 config SCSI_AIC79XX
 	tristate "Adaptec AIC79xx U320 support"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/Kconfig.aic7xxx grsecurity226/drivers/scsi/aic7xxx/Kconfig.aic7xxx
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/Kconfig.aic7xxx	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/Kconfig.aic7xxx	2005-08-30 01:00:22.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # AIC7XXX and AIC79XX 2.5.X Kernel configuration File.
-# $Id$
+# $Id$
 #
 config SCSI_AIC7XXX
 	tristate "Adaptec AIC7xxx Fast -> U160 support (New Driver)"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/Makefile grsecurity226/drivers/scsi/aic7xxx/Makefile
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/Makefile	2005-08-30 01:00:22.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Makefile for the Linux aic7xxx SCSI driver.
 #
-# $Id$
+# $Id$
 #
 
 # Let kbuild descend into aicasm when cleaning
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7770.c grsecurity226/drivers/scsi/aic7xxx/aic7770.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7770.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7770.c	2005-08-30 01:00:22.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7770_osm.c grsecurity226/drivers/scsi/aic7xxx/aic7770_osm.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7770_osm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7770_osm.c	2005-08-30 01:00:22.000000000 +0200
@@ -36,7 +36,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  */
 
 #include "aic7xxx_osm.h"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx.h grsecurity226/drivers/scsi/aic7xxx/aic79xx.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx.h	2005-08-30 01:00:22.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx.reg grsecurity226/drivers/scsi/aic7xxx/aic79xx.reg
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx.reg	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx.reg	2005-08-30 01:00:22.000000000 +0200
@@ -39,7 +39,7 @@
  *
  * $FreeBSD$
  */
-VERSION = "$Id$"
+VERSION = "$Id$"
 
 /*
  * This file is processed by the aic7xxx_asm utility for use in assembling
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx.seq grsecurity226/drivers/scsi/aic7xxx/aic79xx.seq
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx.seq	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx.seq	2005-08-30 01:00:22.000000000 +0200
@@ -40,7 +40,7 @@
  * $FreeBSD$
  */
 
-VERSION = "$Id$"
+VERSION = "$Id$"
 PATCH_ARG_LIST = "struct ahd_softc *ahd"
 PREFIX = "ahd_"
 
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_core.c grsecurity226/drivers/scsi/aic7xxx/aic79xx_core.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_core.c	2005-08-30 01:00:22.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_inline.h grsecurity226/drivers/scsi/aic7xxx/aic79xx_inline.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_inline.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_inline.h	2005-08-30 01:00:22.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_osm.c grsecurity226/drivers/scsi/aic7xxx/aic79xx_osm.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_osm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_osm.c	2005-08-30 01:00:22.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Adaptec AIC79xx device driver for Linux.
  *
- * $Id$
+ * $Id$
  *
  * --------------------------------------------------------------------------
  * Copyright (c) 1994-2000 Justin T. Gibbs.
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_osm.h grsecurity226/drivers/scsi/aic7xxx/aic79xx_osm.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_osm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_osm.h	2005-08-30 01:00:22.000000000 +0200
@@ -36,7 +36,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  */
 #ifndef _AIC79XX_LINUX_H_
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_osm_pci.c grsecurity226/drivers/scsi/aic7xxx/aic79xx_osm_pci.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_osm_pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_osm_pci.c	2005-08-30 01:00:22.000000000 +0200
@@ -36,7 +36,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  */
 
 #include "aic79xx_osm.h"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_pci.c grsecurity226/drivers/scsi/aic7xxx/aic79xx_pci.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_pci.c	2005-08-30 01:00:23.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_pci.h grsecurity226/drivers/scsi/aic7xxx/aic79xx_pci.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_pci.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_pci.h	2005-08-30 01:00:23.000000000 +0200
@@ -36,7 +36,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  */
 #ifndef _AIC79XX_PCI_H_
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_proc.c grsecurity226/drivers/scsi/aic7xxx/aic79xx_proc.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_proc.c	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * String handling code courtesy of Gerard Roudier's <groudier@club-internet.fr>
  * sym driver.
  *
- * $Id$
+ * $Id$
  */
 #include "aic79xx_osm.h"
 #include "aic79xx_inline.h"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_reg.h_shipped grsecurity226/drivers/scsi/aic7xxx/aic79xx_reg.h_shipped
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_reg.h_shipped	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_reg.h_shipped	2005-08-30 01:00:23.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id$
- * $Id$
+ * $Id$
+ * $Id$
  */
 typedef int (ahd_reg_print_t)(u_int, u_int *, u_int);
 typedef struct ahd_reg_parse_entry {
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_reg_print.c_shipped grsecurity226/drivers/scsi/aic7xxx/aic79xx_reg_print.c_shipped
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_reg_print.c_shipped	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_reg_print.c_shipped	2005-08-30 01:00:23.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id$
- * $Id$
+ * $Id$
+ * $Id$
  */
 
 #include "aic79xx_osm.h"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_seq.h_shipped grsecurity226/drivers/scsi/aic7xxx/aic79xx_seq.h_shipped
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic79xx_seq.h_shipped	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic79xx_seq.h_shipped	2005-08-30 01:00:23.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id$
- * $Id$
+ * $Id$
+ * $Id$
  */
 static uint8_t seqprog[] = {
 	0xff, 0x02, 0x06, 0x78,
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx.h grsecurity226/drivers/scsi/aic7xxx/aic7xxx.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx.h	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx.reg grsecurity226/drivers/scsi/aic7xxx/aic7xxx.reg
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx.reg	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx.reg	2005-08-30 01:00:23.000000000 +0200
@@ -39,7 +39,7 @@
  *
  * $FreeBSD$
  */
-VERSION = "$Id$"
+VERSION = "$Id$"
 
 /*
  * This file is processed by the aic7xxx_asm utility for use in assembling
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx.seq grsecurity226/drivers/scsi/aic7xxx/aic7xxx.seq
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx.seq	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx.seq	2005-08-30 01:00:23.000000000 +0200
@@ -40,7 +40,7 @@
  * $FreeBSD$
  */
 
-VERSION = "$Id$"
+VERSION = "$Id$"
 PATCH_ARG_LIST = "struct ahc_softc *ahc"
 PREFIX = "ahc_"
 
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_93cx6.c grsecurity226/drivers/scsi/aic7xxx/aic7xxx_93cx6.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_93cx6.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_93cx6.c	2005-08-30 01:00:23.000000000 +0200
@@ -28,7 +28,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_93cx6.h grsecurity226/drivers/scsi/aic7xxx/aic7xxx_93cx6.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_93cx6.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_93cx6.h	2005-08-30 01:00:23.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_core.c grsecurity226/drivers/scsi/aic7xxx/aic7xxx_core.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_core.c	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_inline.h grsecurity226/drivers/scsi/aic7xxx/aic7xxx_inline.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_inline.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_inline.h	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_osm.c grsecurity226/drivers/scsi/aic7xxx/aic7xxx_osm.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_osm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_osm.c	2005-08-30 01:00:23.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Adaptec AIC7xxx device driver for Linux.
  *
- * $Id$
+ * $Id$
  *
  * Copyright (c) 1994 John Aycock
  *   The University of Calgary Department of Computer Science.
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_osm.h grsecurity226/drivers/scsi/aic7xxx/aic7xxx_osm.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_osm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_osm.h	2005-08-30 01:00:23.000000000 +0200
@@ -53,7 +53,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  */
 #ifndef _AIC7XXX_LINUX_H_
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c grsecurity226/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c	2005-08-30 01:00:23.000000000 +0200
@@ -36,7 +36,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  */
 
 #include "aic7xxx_osm.h"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_pci.c grsecurity226/drivers/scsi/aic7xxx/aic7xxx_pci.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_pci.c	2005-08-30 01:00:23.000000000 +0200
@@ -39,7 +39,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_pci.h grsecurity226/drivers/scsi/aic7xxx/aic7xxx_pci.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_pci.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_pci.h	2005-08-30 01:00:23.000000000 +0200
@@ -36,7 +36,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  */
 #ifndef _AIC7XXX_PCI_H_
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_proc.c grsecurity226/drivers/scsi/aic7xxx/aic7xxx_proc.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_proc.c	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * String handling code courtesy of Gerard Roudier's <groudier@club-internet.fr>
  * sym driver.
  *
- * $Id$
+ * $Id$
  */
 #include "aic7xxx_osm.h"
 #include "aic7xxx_inline.h"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped grsecurity226/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped	2005-08-30 01:00:23.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id$
- * $Id$
+ * $Id$
+ * $Id$
  */
 typedef int (ahc_reg_print_t)(u_int, u_int *, u_int);
 typedef struct ahc_reg_parse_entry {
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_reg_print.c_shipped grsecurity226/drivers/scsi/aic7xxx/aic7xxx_reg_print.c_shipped
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_reg_print.c_shipped	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_reg_print.c_shipped	2005-08-30 01:00:23.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id$
- * $Id$
+ * $Id$
+ * $Id$
  */
 
 #include "aic7xxx_osm.h"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped grsecurity226/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped	2005-08-30 01:00:23.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id$
- * $Id$
+ * $Id$
+ * $Id$
  */
 static uint8_t seqprog[] = {
 	0xb2, 0x00, 0x00, 0x08,
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm.c grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm.c	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm.h grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm.h	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y	2005-08-30 01:00:23.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y	2005-08-30 01:00:23.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l	2005-08-30 01:00:23.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l	2005-08-30 01:00:23.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h	2005-08-30 01:00:23.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  *
  * $FreeBSD$
  */
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aiclib.c grsecurity226/drivers/scsi/aic7xxx/aiclib.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aiclib.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aiclib.c	2005-08-30 01:00:23.000000000 +0200
@@ -27,7 +27,7 @@
  * SUCH DAMAGE.
  *
  * $FreeBSD: src/sys/cam/scsi/scsi_all.c,v 1.38 2002/09/23 04:56:35 mjacob Exp $
- * $Id$
+ * $Id$
  */
 
 #include <linux/blkdev.h>
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/aiclib.h grsecurity226/drivers/scsi/aic7xxx/aiclib.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/aiclib.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/aiclib.h	2005-08-30 01:00:23.000000000 +0200
@@ -51,7 +51,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef	_AICLIB_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx/cam.h grsecurity226/drivers/scsi/aic7xxx/cam.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx/cam.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx/cam.h	2005-08-30 01:00:23.000000000 +0200
@@ -29,7 +29,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _AIC7XXX_CAM_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/aic7xxx.h grsecurity226/drivers/scsi/aic7xxx_old/aic7xxx.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/aic7xxx.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx_old/aic7xxx.h	2005-08-30 01:00:23.000000000 +0200
@@ -18,7 +18,7 @@
  * along with this program; see the file COPYING.  If not, write to
  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  * 
- * $Id$
+ * $Id$
  *-M*************************************************************************/
 #ifndef _aic7xxx_h
 #define _aic7xxx_h
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/aic7xxx.reg grsecurity226/drivers/scsi/aic7xxx_old/aic7xxx.reg
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/aic7xxx.reg	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx_old/aic7xxx.reg	2005-08-30 01:00:23.000000000 +0200
@@ -32,7 +32,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *	$Id$
+ *	$Id$
  */
 
 /*
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/aic7xxx.seq grsecurity226/drivers/scsi/aic7xxx_old/aic7xxx.seq
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/aic7xxx.seq	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx_old/aic7xxx.seq	2005-08-30 01:00:23.000000000 +0200
@@ -32,7 +32,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *	$Id$
+ *	$Id$
  */
 
 #include "aic7xxx.reg"
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/aic7xxx_proc.c grsecurity226/drivers/scsi/aic7xxx_old/aic7xxx_proc.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/aic7xxx_proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx_old/aic7xxx_proc.c	2005-08-30 01:00:23.000000000 +0200
@@ -26,7 +26,7 @@
  *
  *  Dean W. Gehnert, deang@teleport.com, 05/01/96
  *
- *  $Id$
+ *  $Id$
  *-M*************************************************************************/
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/sequencer.h grsecurity226/drivers/scsi/aic7xxx_old/sequencer.h
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx_old/sequencer.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx_old/sequencer.h	2005-08-30 01:00:23.000000000 +0200
@@ -33,7 +33,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *      $Id$
+ *      $Id$
  */
 
 #ifdef __LITTLE_ENDIAN_BITFIELD
diff -Nur linux-2.6.13.1.org/drivers/scsi/aic7xxx_old.c grsecurity226/drivers/scsi/aic7xxx_old.c
--- linux-2.6.13.1.org/drivers/scsi/aic7xxx_old.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/aic7xxx_old.c	2005-08-30 01:00:21.000000000 +0200
@@ -73,7 +73,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *      $Id$
+ *      $Id$
  *---------------------------------------------------------------------------
  *
  *  Thanks also go to (in alphabetical order) the following:
@@ -93,7 +93,7 @@
  *
  *  Daniel M. Eischen, deischen@iworks.InterWorks.org, 1/23/97
  *
- *  $Id$
+ *  $Id$
  *-M*************************************************************************/
 
 /*+M**************************************************************************
diff -Nur linux-2.6.13.1.org/drivers/scsi/esp.c grsecurity226/drivers/scsi/esp.c
--- linux-2.6.13.1.org/drivers/scsi/esp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/esp.c	2005-08-30 01:00:21.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * esp.c:  EnhancedScsiProcessor Sun SCSI driver code.
  *
  * Copyright (C) 1995, 1998 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/drivers/scsi/esp.h grsecurity226/drivers/scsi/esp.h
--- linux-2.6.13.1.org/drivers/scsi/esp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/esp.h	2005-08-30 01:00:21.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * esp.h:  Defines and structures for the Sparc ESP (Enhanced SCSI
  *         Processor) driver under Linux.
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/fd_mcs.c grsecurity226/drivers/scsi/fd_mcs.c
--- linux-2.6.13.1.org/drivers/scsi/fd_mcs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/fd_mcs.c	2005-08-30 01:00:21.000000000 +0200
@@ -28,7 +28,7 @@
  * Author: Rickard E. Faith, faith@cs.unc.edu
  * Copyright 1992, 1993, 1994, 1995, 1996 Rickard E. Faith
  *
- * $Id$
+ * $Id$
 
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
diff -Nur linux-2.6.13.1.org/drivers/scsi/fdomain.c grsecurity226/drivers/scsi/fdomain.c
--- linux-2.6.13.1.org/drivers/scsi/fdomain.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/fdomain.c	2005-08-30 01:00:21.000000000 +0200
@@ -296,7 +296,7 @@
 MODULE_LICENSE("GPL");
 
   
-#define VERSION          "$Revision$"
+#define VERSION          "$Revision$"
 
 /* START OF USER DEFINABLE OPTIONS */
 
diff -Nur linux-2.6.13.1.org/drivers/scsi/g_NCR5380.c grsecurity226/drivers/scsi/g_NCR5380.c
--- linux-2.6.13.1.org/drivers/scsi/g_NCR5380.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/g_NCR5380.c	2005-08-30 01:00:21.000000000 +0200
@@ -79,7 +79,10 @@
  */
 
 /*
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 /* settings for DTC3181E card with only Mustek scanner attached */
diff -Nur linux-2.6.13.1.org/drivers/scsi/g_NCR5380.h grsecurity226/drivers/scsi/g_NCR5380.h
--- linux-2.6.13.1.org/drivers/scsi/g_NCR5380.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/g_NCR5380.h	2005-08-30 01:00:21.000000000 +0200
@@ -26,7 +26,10 @@
  */
 
 /*
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 #ifndef GENERIC_NCR5380_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/gdth.c grsecurity226/drivers/scsi/gdth.c
--- linux-2.6.13.1.org/drivers/scsi/gdth.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/gdth.c	2005-08-30 01:00:21.000000000 +0200
@@ -30,6 +30,9 @@
  * Linux kernel 2.2.x, 2.4.x, 2.6.x supported                           *
  *                                                                      *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.73  2004/03/31 13:33:03  achim
  * Special command 0xfd implemented to detect 64-bit DMA support
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/gdth.h grsecurity226/drivers/scsi/gdth.h
--- linux-2.6.13.1.org/drivers/scsi/gdth.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/gdth.h	2005-08-30 01:00:21.000000000 +0200
@@ -10,7 +10,7 @@
  *
  * <achim_leubner@adaptec.com>
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/version.h>
diff -Nur linux-2.6.13.1.org/drivers/scsi/gdth_ioctl.h grsecurity226/drivers/scsi/gdth_ioctl.h
--- linux-2.6.13.1.org/drivers/scsi/gdth_ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/gdth_ioctl.h	2005-08-30 01:00:21.000000000 +0200
@@ -2,7 +2,7 @@
 #define _GDTH_IOCTL_H
 
 /* gdth_ioctl.h
- * $Id$
+ * $Id$
  */
 
 /* IOCTLs */
diff -Nur linux-2.6.13.1.org/drivers/scsi/gdth_proc.c grsecurity226/drivers/scsi/gdth_proc.c
--- linux-2.6.13.1.org/drivers/scsi/gdth_proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/gdth_proc.c	2005-08-30 01:00:21.000000000 +0200
@@ -1,5 +1,5 @@
 /* gdth_proc.c 
- * $Id$
+ * $Id$
  */
 
 #include <linux/completion.h>
diff -Nur linux-2.6.13.1.org/drivers/scsi/gdth_proc.h grsecurity226/drivers/scsi/gdth_proc.h
--- linux-2.6.13.1.org/drivers/scsi/gdth_proc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/gdth_proc.h	2005-08-30 01:00:21.000000000 +0200
@@ -2,7 +2,7 @@
 #define _GDTH_PROC_H
 
 /* gdth_proc.h 
- * $Id$
+ * $Id$
  */
 
 static int gdth_set_info(char *buffer,int length,struct Scsi_Host *host,
diff -Nur linux-2.6.13.1.org/drivers/scsi/gvp11.h grsecurity226/drivers/scsi/gvp11.h
--- linux-2.6.13.1.org/drivers/scsi/gvp11.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/gvp11.h	2005-08-30 01:00:21.000000000 +0200
@@ -1,6 +1,6 @@
 #ifndef GVP11_H
 
-/* $Id$
+/* $Id$
  *
  * Header file for the GVP Series II SCSI controller for Linux
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/libata-scsi.c grsecurity226/drivers/scsi/libata-scsi.c
--- linux-2.6.13.1.org/drivers/scsi/libata-scsi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/libata-scsi.c	2005-08-30 01:14:12.000000000 +0200
@@ -916,7 +916,7 @@
 	return 0;
 }
 
-static const char *inq_83_str = "Linux ATA-SCSI simulator";
+static const char inq_83_str[] = "Linux ATA-SCSI simulator";
 
 /**
  *	ata_scsiop_inq_83 - Simulate INQUIRY EVPD page 83, device identity
@@ -935,13 +935,13 @@
 			      unsigned int buflen)
 {
 	rbuf[1] = 0x83;			/* this page code */
-	rbuf[3] = 4 + strlen(inq_83_str);	/* page len */
+	rbuf[3] = 3 + sizeof(inq_83_str);	/* page len */
 
 	/* our one and only identification descriptor (vendor-specific) */
-	if (buflen > (strlen(inq_83_str) + 4 + 4 - 1)) {
+	if (buflen >= (sizeof(inq_83_str) + 4 + 4 - 1)) {
 		rbuf[4 + 0] = 2;	/* code set: ASCII */
-		rbuf[4 + 3] = strlen(inq_83_str);
-		memcpy(rbuf + 4 + 4, inq_83_str, strlen(inq_83_str));
+		rbuf[4 + 3] = sizeof(inq_83_str)-1;
+		memcpy(rbuf + 4 + 4, inq_83_str, sizeof(inq_83_str)-1);
 	}
 
 	return 0;
diff -Nur linux-2.6.13.1.org/drivers/scsi/mac_scsi.c grsecurity226/drivers/scsi/mac_scsi.c
--- linux-2.6.13.1.org/drivers/scsi/mac_scsi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/mac_scsi.c	2005-08-30 01:00:21.000000000 +0200
@@ -26,7 +26,10 @@
  */
 
 /*
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 #include <linux/types.h>
diff -Nur linux-2.6.13.1.org/drivers/scsi/mac_scsi.h grsecurity226/drivers/scsi/mac_scsi.h
--- linux-2.6.13.1.org/drivers/scsi/mac_scsi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/mac_scsi.h	2005-08-30 01:00:21.000000000 +0200
@@ -23,7 +23,10 @@
  */
 
 /*
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 #ifndef MAC_NCR5380_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/mvme147.h grsecurity226/drivers/scsi/mvme147.h
--- linux-2.6.13.1.org/drivers/scsi/mvme147.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/mvme147.h	2005-08-30 01:00:21.000000000 +0200
@@ -1,6 +1,6 @@
 #ifndef MVME147_H
 
-/* $Id$
+/* $Id$
  *
  * Header file for the MVME147 built-in SCSI controller for Linux
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/nsp32.c grsecurity226/drivers/scsi/nsp32.c
--- linux-2.6.13.1.org/drivers/scsi/nsp32.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/nsp32.c	2005-08-30 01:00:21.000000000 +0200
@@ -1544,7 +1544,7 @@
 	base = host->io_port;
 
 	SPRINTF("NinjaSCSI-32 status\n\n");
-	SPRINTF("Driver version:        %s, $Revision$\n", nsp32_release_version);
+	SPRINTF("Driver version:        %s, $Revision$\n", nsp32_release_version);
 	SPRINTF("SCSI host No.:         %d\n",		hostno);
 	SPRINTF("IRQ:                   %d\n",		host->irq);
 	SPRINTF("IO:                    0x%lx-0x%lx\n", host->io_port, host->io_port + host->n_io_port - 1);
diff -Nur linux-2.6.13.1.org/drivers/scsi/osst.c grsecurity226/drivers/scsi/osst.c
--- linux-2.6.13.1.org/drivers/scsi/osst.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/osst.c	2005-08-30 01:00:21.000000000 +0200
@@ -16,14 +16,14 @@
   Copyright 1992 - 2002 Kai Makisara / 2000 - 2004 Willem Riede
 	 email osst@riede.org
 
-  $Header$
+  $Header$
 
   Microscopic alterations - Rik Ling, 2000/12/21
   Last st.c sync: Tue Oct 15 22:01:04 2002 by makisara
   Some small formal changes - aeb, 950809
 */
 
-static const char * cvsid = "$Id$";
+static const char * cvsid = "$Id$";
 static const char * osst_version = "0.99.3";
 
 /* The "failure to reconnect" firmware bug */
diff -Nur linux-2.6.13.1.org/drivers/scsi/osst.h grsecurity226/drivers/scsi/osst.h
--- linux-2.6.13.1.org/drivers/scsi/osst.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/osst.h	2005-08-30 01:00:21.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *	$Header$
+ *	$Header$
  */
 
 #include <asm/byteorder.h>
diff -Nur linux-2.6.13.1.org/drivers/scsi/osst_options.h grsecurity226/drivers/scsi/osst_options.h
--- linux-2.6.13.1.org/drivers/scsi/osst_options.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/osst_options.h	2005-08-30 01:00:21.000000000 +0200
@@ -8,7 +8,7 @@
    Changed (and renamed) for OnStream SCSI drives garloff@suse.de
    2000-06-21
 
-   $Header$
+   $Header$
 */
 
 #ifndef _OSST_OPTIONS_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_cs.c grsecurity226/drivers/scsi/pcmcia/nsp_cs.c
--- linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_cs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/pcmcia/nsp_cs.c	2005-08-30 01:00:25.000000000 +0200
@@ -25,7 +25,7 @@
 
 ***********************************************************************/
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/version.h>
 #include <linux/module.h>
@@ -60,7 +60,7 @@
 #include "nsp_cs.h"
 
 MODULE_AUTHOR("YOKOTA Hiroshi <yokota@netlab.is.tsukuba.ac.jp>");
-MODULE_DESCRIPTION("WorkBit NinjaSCSI-3 / NinjaSCSI-32Bi(16bit) PCMCIA SCSI host adapter module $Revision$");
+MODULE_DESCRIPTION("WorkBit NinjaSCSI-3 / NinjaSCSI-32Bi(16bit) PCMCIA SCSI host adapter module $Revision$");
 MODULE_SUPPORTED_DEVICE("sd,sr,sg,st");
 #ifdef MODULE_LICENSE
 MODULE_LICENSE("GPL");
@@ -1345,7 +1345,7 @@
 
 	snprintf(data->nspinfo,
 		 sizeof(data->nspinfo),
-		 "NinjaSCSI-3/32Bi Driver $Revision$ IO:0x%04lx-0x%04lx MMIO(virt addr):0x%04lx IRQ:%02d",
+		 "NinjaSCSI-3/32Bi Driver $Revision$ IO:0x%04lx-0x%04lx MMIO(virt addr):0x%04lx IRQ:%02d",
 		 host->io_port, host->io_port + host->n_io_port - 1,
 		 host->base,
 		 host->irq);
@@ -1448,7 +1448,7 @@
 
 
 	SPRINTF("NinjaSCSI status\n\n");
-	SPRINTF("Driver version:        $Revision$\n");
+	SPRINTF("Driver version:        $Revision$\n");
 	SPRINTF("SCSI host No.:         %d\n",          hostno);
 	SPRINTF("IRQ:                   %d\n",          host->irq);
 	SPRINTF("IO:                    0x%lx-0x%lx\n", host->io_port, host->io_port + host->n_io_port - 1);
diff -Nur linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_cs.h grsecurity226/drivers/scsi/pcmcia/nsp_cs.h
--- linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_cs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/pcmcia/nsp_cs.h	2005-08-30 01:00:25.000000000 +0200
@@ -10,7 +10,7 @@
 
 =========================================================*/
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef  __nsp_cs__
 #define  __nsp_cs__
diff -Nur linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_debug.c grsecurity226/drivers/scsi/pcmcia/nsp_debug.c
--- linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_debug.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/pcmcia/nsp_debug.c	2005-08-30 01:00:25.000000000 +0200
@@ -6,7 +6,7 @@
     the GNU General Public License.
 =========================================================================*/
 
-/* $Id$ */
+/* $Id$ */
 
 /*
  * Show the command data of a command
diff -Nur linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_io.h grsecurity226/drivers/scsi/pcmcia/nsp_io.h
--- linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_io.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/pcmcia/nsp_io.h	2005-08-30 01:00:25.000000000 +0200
@@ -7,7 +7,7 @@
 
   */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef __NSP_IO_H__
 #define __NSP_IO_H__
diff -Nur linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_message.c grsecurity226/drivers/scsi/pcmcia/nsp_message.c
--- linux-2.6.13.1.org/drivers/scsi/pcmcia/nsp_message.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/pcmcia/nsp_message.c	2005-08-30 01:00:25.000000000 +0200
@@ -6,7 +6,7 @@
    the GNU General Public License.
  */
 
-/* $Id$ */
+/* $Id$ */
 
 static void nsp_message_in(Scsi_Cmnd *SCpnt)
 {
diff -Nur linux-2.6.13.1.org/drivers/scsi/qlogicfc.c grsecurity226/drivers/scsi/qlogicfc.c
--- linux-2.6.13.1.org/drivers/scsi/qlogicfc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/qlogicfc.c	2005-08-30 01:00:21.000000000 +0200
@@ -27,10 +27,13 @@
  */
 
 /*
- * $Date$
- * $Revision$
+ * $Date$
+ * $Revision$
+ *
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:21  spender
+ * Initial import of Linux 2.6.13
  *
- * $Log$
  * Revision 0.5  1995/09/22  02:23:15  root
  * do auto request sense
  *
diff -Nur linux-2.6.13.1.org/drivers/scsi/sgiwd93.h grsecurity226/drivers/scsi/sgiwd93.h
--- linux-2.6.13.1.org/drivers/scsi/sgiwd93.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/sgiwd93.h	2005-08-30 01:00:22.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sgiwd93.h: SGI WD93 scsi definitions.
  *
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
diff -Nur linux-2.6.13.1.org/drivers/scsi/sun3_scsi.c grsecurity226/drivers/scsi/sun3_scsi.c
--- linux-2.6.13.1.org/drivers/scsi/sun3_scsi.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/sun3_scsi.c	2005-08-30 01:00:22.000000000 +0200
@@ -46,7 +46,10 @@
  */
 
 /*
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:22  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 #define AUTOSENSE
diff -Nur linux-2.6.13.1.org/drivers/scsi/sun3_scsi.h grsecurity226/drivers/scsi/sun3_scsi.h
--- linux-2.6.13.1.org/drivers/scsi/sun3_scsi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/sun3_scsi.h	2005-08-30 01:00:22.000000000 +0200
@@ -30,7 +30,10 @@
  */
 
 /*
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:22  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 #ifndef SUN3_NCR5380_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/t128.c grsecurity226/drivers/scsi/t128.c
--- linux-2.6.13.1.org/drivers/scsi/t128.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/t128.c	2005-08-30 01:00:22.000000000 +0200
@@ -104,6 +104,9 @@
  
 /*
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:22  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 #include <asm/system.h>
diff -Nur linux-2.6.13.1.org/drivers/scsi/t128.h grsecurity226/drivers/scsi/t128.h
--- linux-2.6.13.1.org/drivers/scsi/t128.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/t128.h	2005-08-30 01:00:22.000000000 +0200
@@ -36,6 +36,9 @@
 
 /*
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:22  spender
+ * Initial import of Linux 2.6.13
+ *
  */
 
 #ifndef T128_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/tmscsim.c grsecurity226/drivers/scsi/tmscsim.c
--- linux-2.6.13.1.org/drivers/scsi/tmscsim.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/tmscsim.c	2005-08-30 01:00:22.000000000 +0200
@@ -8,7 +8,7 @@
  * (C) Copyright: put under GNU GPL in 10/96				*
  *				(see Documentation/scsi/tmscsim.txt)	*
  ************************************************************************
- * $Id$		*
+ * $Id$		*
  *	Enhancements and bugfixes by					*
  *	Kurt Garloff <kurt@garloff.de>	<garloff@suse.de>		*
  ************************************************************************
diff -Nur linux-2.6.13.1.org/drivers/scsi/tmscsim.h grsecurity226/drivers/scsi/tmscsim.h
--- linux-2.6.13.1.org/drivers/scsi/tmscsim.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/tmscsim.h	2005-08-30 01:00:22.000000000 +0200
@@ -3,7 +3,7 @@
 ;*		    TEKRAM DC-390(T) PCI SCSI Bus Master Host Adapter  *
 ;*		    Device Driver				       *
 ;***********************************************************************/
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _TMSCSIM_H
 #define _TMSCSIM_H
diff -Nur linux-2.6.13.1.org/drivers/scsi/wd7000.c grsecurity226/drivers/scsi/wd7000.c
--- linux-2.6.13.1.org/drivers/scsi/wd7000.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/scsi/wd7000.c	2005-08-30 01:00:22.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *  linux/drivers/scsi/wd7000.c
  *
  *  Copyright (C) 1992  Thomas Wuensche
diff -Nur linux-2.6.13.1.org/drivers/serial/21285.c grsecurity226/drivers/serial/21285.c
--- linux-2.6.13.1.org/drivers/serial/21285.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/21285.c	2005-08-30 01:00:25.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * Based on drivers/char/serial.c
  *
- *  $Id$
+ *  $Id$
  */
 #include <linux/config.h>
 #include <linux/module.h>
@@ -506,7 +506,7 @@
 {
 	int ret;
 
-	printk(KERN_INFO "Serial: 21285 driver $Revision$\n");
+	printk(KERN_INFO "Serial: 21285 driver $Revision$\n");
 
 	serial21285_setup_ports();
 
@@ -527,5 +527,5 @@
 module_exit(serial21285_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Intel Footbridge (21285) serial driver $Revision$");
+MODULE_DESCRIPTION("Intel Footbridge (21285) serial driver $Revision$");
 MODULE_ALIAS_CHARDEV(SERIAL_21285_MAJOR, SERIAL_21285_MINOR);
diff -Nur linux-2.6.13.1.org/drivers/serial/8250.h grsecurity226/drivers/serial/8250.h
--- linux-2.6.13.1.org/drivers/serial/8250.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/8250.h	2005-08-30 01:00:25.000000000 +0200
@@ -12,7 +12,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- *  $Id$
+ *  $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/serial/8250_pci.c grsecurity226/drivers/serial/8250_pci.c
--- linux-2.6.13.1.org/drivers/serial/8250_pci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/8250_pci.c	2005-08-30 01:00:25.000000000 +0200
@@ -11,7 +11,7 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License.
  *
- *  $Id$
+ *  $Id$
  */
 #include <linux/module.h>
 #include <linux/init.h>
diff -Nur linux-2.6.13.1.org/drivers/serial/8250_pnp.c grsecurity226/drivers/serial/8250_pnp.c
--- linux-2.6.13.1.org/drivers/serial/8250_pnp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/8250_pnp.c	2005-08-30 01:00:25.000000000 +0200
@@ -13,7 +13,7 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License.
  *
- *  $Id$
+ *  $Id$
  */
 #include <linux/module.h>
 #include <linux/init.h>
diff -Nur linux-2.6.13.1.org/drivers/serial/Kconfig grsecurity226/drivers/serial/Kconfig
--- linux-2.6.13.1.org/drivers/serial/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/Kconfig	2005-08-30 01:00:25.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Serial device configuration
 #
-# $Id$
+# $Id$
 #
 
 menu "Serial drivers"
diff -Nur linux-2.6.13.1.org/drivers/serial/Makefile grsecurity226/drivers/serial/Makefile
--- linux-2.6.13.1.org/drivers/serial/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/Makefile	2005-08-30 01:00:25.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Makefile for the kernel serial device drivers.
 #
-#  $Id$
+#  $Id$
 #
 
 serial-8250-y :=
diff -Nur linux-2.6.13.1.org/drivers/serial/amba-pl010.c grsecurity226/drivers/serial/amba-pl010.c
--- linux-2.6.13.1.org/drivers/serial/amba-pl010.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/amba-pl010.c	2005-08-30 01:00:25.000000000 +0200
@@ -22,7 +22,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- *  $Id$
+ *  $Id$
  *
  * This is a generic driver for ARM AMBA-type serial ports.  They
  * have a lot of 16550-like features, but are not register compatible.
@@ -805,7 +805,7 @@
 {
 	int ret;
 
-	printk(KERN_INFO "Serial: AMBA driver $Revision$\n");
+	printk(KERN_INFO "Serial: AMBA driver $Revision$\n");
 
 	ret = uart_register_driver(&amba_reg);
 	if (ret == 0) {
@@ -826,5 +826,5 @@
 module_exit(pl010_exit);
 
 MODULE_AUTHOR("ARM Ltd/Deep Blue Solutions Ltd");
-MODULE_DESCRIPTION("ARM AMBA serial port driver $Revision$");
+MODULE_DESCRIPTION("ARM AMBA serial port driver $Revision$");
 MODULE_LICENSE("GPL");
diff -Nur linux-2.6.13.1.org/drivers/serial/amba-pl011.c grsecurity226/drivers/serial/amba-pl011.c
--- linux-2.6.13.1.org/drivers/serial/amba-pl011.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/amba-pl011.c	2005-08-30 01:00:25.000000000 +0200
@@ -22,7 +22,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- *  $Id$
+ *  $Id$
  *
  * This is a generic driver for ARM AMBA-type serial ports.  They
  * have a lot of 16550-like features, but are not register compatible.
diff -Nur linux-2.6.13.1.org/drivers/serial/clps711x.c grsecurity226/drivers/serial/clps711x.c
--- linux-2.6.13.1.org/drivers/serial/clps711x.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/clps711x.c	2005-08-30 01:00:25.000000000 +0200
@@ -22,7 +22,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- *  $Id$
+ *  $Id$
  *
  */
 #include <linux/config.h>
@@ -564,7 +564,7 @@
 {
 	int ret, i;
 
-	printk(KERN_INFO "Serial: CLPS711x driver $Revision$\n");
+	printk(KERN_INFO "Serial: CLPS711x driver $Revision$\n");
 
 	ret = uart_register_driver(&clps711x_reg);
 	if (ret)
@@ -590,6 +590,6 @@
 module_exit(clps711xuart_exit);
 
 MODULE_AUTHOR("Deep Blue Solutions Ltd");
-MODULE_DESCRIPTION("CLPS-711x generic serial driver $Revision$");
+MODULE_DESCRIPTION("CLPS-711x generic serial driver $Revision$");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_CHARDEV(SERIAL_CLPS711X_MAJOR, SERIAL_CLPS711X_MINOR);
diff -Nur linux-2.6.13.1.org/drivers/serial/cpm_uart/cpm_uart_core.c grsecurity226/drivers/serial/cpm_uart/cpm_uart_core.c
--- linux-2.6.13.1.org/drivers/serial/cpm_uart/cpm_uart_core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/cpm_uart/cpm_uart_core.c	2005-08-30 01:00:25.000000000 +0200
@@ -1174,7 +1174,7 @@
 {
 	int ret, i;
 
-	printk(KERN_INFO "Serial: CPM driver $Revision$\n");
+	printk(KERN_INFO "Serial: CPM driver $Revision$\n");
 
 #ifndef CONFIG_SERIAL_CPM_CONSOLE
 	ret = cpm_uart_init_portdesc();
@@ -1214,6 +1214,6 @@
 module_exit(cpm_uart_exit);
 
 MODULE_AUTHOR("Kumar Gala/Antoniou Pantelis");
-MODULE_DESCRIPTION("CPM SCC/SMC port driver $Revision$");
+MODULE_DESCRIPTION("CPM SCC/SMC port driver $Revision$");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_CHARDEV(SERIAL_CPM_MAJOR, SERIAL_CPM_MINOR);
diff -Nur linux-2.6.13.1.org/drivers/serial/crisv10.c grsecurity226/drivers/serial/crisv10.c
--- linux-2.6.13.1.org/drivers/serial/crisv10.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/crisv10.c	2005-08-30 01:00:25.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Serial port driver for the ETRAX 100LX chip
  *
@@ -6,7 +6,10 @@
  *
  *    Many, many authors. Based once upon a time on serial.c for 16x50.
  *
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:25  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.25  2004/09/29 10:33:49  starvik
  * Resolved a dealock when printing debug from kernel.
  *
@@ -423,7 +426,7 @@
  *
  */
 
-static char *serial_version = "$Revision$";
+static char *serial_version = "$Revision$";
 
 #include <linux/config.h>
 #include <linux/types.h>
diff -Nur linux-2.6.13.1.org/drivers/serial/m32r_sio.c grsecurity226/drivers/serial/m32r_sio.c
--- linux-2.6.13.1.org/drivers/serial/m32r_sio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/m32r_sio.c	2005-08-30 01:00:25.000000000 +0200
@@ -1186,7 +1186,7 @@
 {
 	int ret, i;
 
-	printk(KERN_INFO "Serial: M32R SIO driver $Revision$ ");
+	printk(KERN_INFO "Serial: M32R SIO driver $Revision$ ");
 
 	for (i = 0; i < NR_IRQS; i++)
 		spin_lock_init(&irq_lists[i].lock);
@@ -1215,4 +1215,4 @@
 EXPORT_SYMBOL(m32r_sio_resume_port);
 
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Generic M32R SIO serial driver $Revision$");
+MODULE_DESCRIPTION("Generic M32R SIO serial driver $Revision$");
diff -Nur linux-2.6.13.1.org/drivers/serial/mpsc.c grsecurity226/drivers/serial/mpsc.c
--- linux-2.6.13.1.org/drivers/serial/mpsc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/mpsc.c	2005-08-30 01:00:25.000000000 +0200
@@ -1788,7 +1788,7 @@
 {
 	int	rc;
 
-	printk(KERN_INFO "Serial: MPSC driver $Revision$\n");
+	printk(KERN_INFO "Serial: MPSC driver $Revision$\n");
 
 	memset(mpsc_ports, 0, sizeof(mpsc_ports));
 	memset(&mpsc_shared_regs, 0, sizeof(mpsc_shared_regs));
@@ -1823,7 +1823,7 @@
 module_exit(mpsc_drv_exit);
 
 MODULE_AUTHOR("Mark A. Greer <mgreer@mvista.com>");
-MODULE_DESCRIPTION("Generic Marvell MPSC serial/UART driver $Revision$");
+MODULE_DESCRIPTION("Generic Marvell MPSC serial/UART driver $Revision$");
 MODULE_VERSION(MPSC_VERSION);
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_CHARDEV_MAJOR(MPSC_MAJOR);
diff -Nur linux-2.6.13.1.org/drivers/serial/sa1100.c grsecurity226/drivers/serial/sa1100.c
--- linux-2.6.13.1.org/drivers/serial/sa1100.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/sa1100.c	2005-08-30 01:00:25.000000000 +0200
@@ -21,7 +21,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- *  $Id$
+ *  $Id$
  *
  */
 #include <linux/config.h>
@@ -904,7 +904,7 @@
 {
 	int ret;
 
-	printk(KERN_INFO "Serial: SA11x0 driver $Revision$\n");
+	printk(KERN_INFO "Serial: SA11x0 driver $Revision$\n");
 
 	sa1100_init_ports();
 
@@ -927,6 +927,6 @@
 module_exit(sa1100_serial_exit);
 
 MODULE_AUTHOR("Deep Blue Solutions Ltd");
-MODULE_DESCRIPTION("SA1100 generic serial port driver $Revision$");
+MODULE_DESCRIPTION("SA1100 generic serial port driver $Revision$");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_CHARDEV_MAJOR(SERIAL_SA1100_MAJOR);
diff -Nur linux-2.6.13.1.org/drivers/serial/sh-sci.h grsecurity226/drivers/serial/sh-sci.h
--- linux-2.6.13.1.org/drivers/serial/sh-sci.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/sh-sci.h	2005-08-30 01:00:25.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  *  linux/drivers/serial/sh-sci.h
  *
diff -Nur linux-2.6.13.1.org/drivers/serial/sunsu.c grsecurity226/drivers/serial/sunsu.c
--- linux-2.6.13.1.org/drivers/serial/sunsu.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/sunsu.c	2005-08-30 01:00:25.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * su.c: Small serial driver for keyboard/mouse interface on sparc32/PCI
  *
  * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)
diff -Nur linux-2.6.13.1.org/drivers/serial/uart00.c grsecurity226/drivers/serial/uart00.c
--- linux-2.6.13.1.org/drivers/serial/uart00.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/serial/uart00.c	2005-08-30 01:00:25.000000000 +0200
@@ -23,7 +23,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- *  $Id$
+ *  $Id$
  *
  */
 #include <linux/config.h>
@@ -759,7 +759,7 @@
 {
 	int result;
 
-	printk(KERN_INFO "Serial: UART00 driver $Revision$\n");
+	printk(KERN_INFO "Serial: UART00 driver $Revision$\n");
 
 	printk(KERN_WARNING "serial_uart00:Using temporary major/minor pairs"
 		" - these WILL change in the future\n");
diff -Nur linux-2.6.13.1.org/drivers/telephony/ixj.c grsecurity226/drivers/telephony/ixj.c
--- linux-2.6.13.1.org/drivers/telephony/ixj.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/telephony/ixj.c	2005-08-30 01:00:26.000000000 +0200
@@ -43,6 +43,9 @@
 
 /*
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:26  spender
+ * Initial import of Linux 2.6.13
+ *
  *
  * Revision 4.8  2003/07/09 19:39:00  Daniele Bellucci
  * Audit some copy_*_user and minor cleanup.
diff -Nur linux-2.6.13.1.org/drivers/usb/core/devices.c grsecurity226/drivers/usb/core/devices.c
--- linux-2.6.13.1.org/drivers/usb/core/devices.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/core/devices.c	2005-08-30 01:00:26.000000000 +0200
@@ -47,7 +47,7 @@
  *   Converted file reading routine to dump to buffer once
  *   per device, not per bus
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/fs.h>
diff -Nur linux-2.6.13.1.org/drivers/usb/core/devio.c grsecurity226/drivers/usb/core/devio.c
--- linux-2.6.13.1.org/drivers/usb/core/devio.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/core/devio.c	2005-08-30 01:00:26.000000000 +0200
@@ -19,7 +19,7 @@
  *      along with this program; if not, write to the Free Software
  *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- *  $Id$
+ *  $Id$
  *
  *  This file implements the usbfs/x/y files, where
  *  x is the bus number and y the device number.
diff -Nur linux-2.6.13.1.org/drivers/usb/gadget/rndis.c grsecurity226/drivers/usb/gadget/rndis.c
--- linux-2.6.13.1.org/drivers/usb/gadget/rndis.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/gadget/rndis.c	2005-08-30 01:00:26.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
  * RNDIS MSG parser
  * 
- * Version:     $Id$
+ * Version:     $Id$
  * 
  * Authors:	Benedikt Spranger, Pengutronix
  * 		Robert Schwebel, Pengutronix
diff -Nur linux-2.6.13.1.org/drivers/usb/gadget/rndis.h grsecurity226/drivers/usb/gadget/rndis.h
--- linux-2.6.13.1.org/drivers/usb/gadget/rndis.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/gadget/rndis.h	2005-08-30 01:00:26.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
  * RNDIS	Definitions for Remote NDIS
  * 
- * Version:	$Id$
+ * Version:	$Id$
  * 
  * Authors:	Benedikt Spranger, Pengutronix
  * 		Robert Schwebel, Pengutronix
diff -Nur linux-2.6.13.1.org/drivers/usb/host/hc_crisv10.c grsecurity226/drivers/usb/host/hc_crisv10.c
--- linux-2.6.13.1.org/drivers/usb/host/hc_crisv10.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/host/hc_crisv10.c	2005-08-30 01:00:26.000000000 +0200
@@ -36,7 +36,7 @@
 #define ETRAX_USB_RX_IRQ USB_DMA_RX_IRQ_NBR
 #define ETRAX_USB_TX_IRQ USB_DMA_TX_IRQ_NBR
 
-static const char *usb_hcd_version = "$Revision$";
+static const char *usb_hcd_version = "$Revision$";
 
 #undef KERN_DEBUG
 #define KERN_DEBUG ""
diff -Nur linux-2.6.13.1.org/drivers/usb/input/hid-debug.h grsecurity226/drivers/usb/input/hid-debug.h
--- linux-2.6.13.1.org/drivers/usb/input/hid-debug.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/input/hid-debug.h	2005-08-30 01:00:26.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  (c) 1999 Andreas Gal		<gal@cs.uni-magdeburg.de>
  *  (c) 2000-2001 Vojtech Pavlik	<vojtech@ucw.cz>
diff -Nur linux-2.6.13.1.org/drivers/usb/input/hid-ff.c grsecurity226/drivers/usb/input/hid-ff.c
--- linux-2.6.13.1.org/drivers/usb/input/hid-ff.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/input/hid-ff.c	2005-08-30 01:00:26.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Force feedback support for hid devices.
  *  Not all hid devices use the same protocol. For example, some use PID,
diff -Nur linux-2.6.13.1.org/drivers/usb/input/hid-input.c grsecurity226/drivers/usb/input/hid-input.c
--- linux-2.6.13.1.org/drivers/usb/input/hid-input.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/input/hid-input.c	2005-08-30 01:00:26.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 2000-2001 Vojtech Pavlik
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/input/hid.h grsecurity226/drivers/usb/input/hid.h
--- linux-2.6.13.1.org/drivers/usb/input/hid.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/input/hid.h	2005-08-30 01:00:26.000000000 +0200
@@ -2,7 +2,7 @@
 #define __HID_H
 
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999 Andreas Gal
  *  Copyright (c) 2000-2001 Vojtech Pavlik
diff -Nur linux-2.6.13.1.org/drivers/usb/input/usbkbd.c grsecurity226/drivers/usb/input/usbkbd.c
--- linux-2.6.13.1.org/drivers/usb/input/usbkbd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/input/usbkbd.c	2005-08-30 01:00:26.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999-2001 Vojtech Pavlik
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/input/usbmouse.c grsecurity226/drivers/usb/input/usbmouse.c
--- linux-2.6.13.1.org/drivers/usb/input/usbmouse.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/input/usbmouse.c	2005-08-30 01:00:26.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999-2001 Vojtech Pavlik
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/media/dabusb.c grsecurity226/drivers/usb/media/dabusb.c
--- linux-2.6.13.1.org/drivers/usb/media/dabusb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/media/dabusb.c	2005-08-30 01:00:26.000000000 +0200
@@ -21,7 +21,7 @@
  *
  *
  *
- *  $Id$
+ *  $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/drivers/usb/misc/emi62.c grsecurity226/drivers/usb/misc/emi62.c
--- linux-2.6.13.1.org/drivers/usb/misc/emi62.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/misc/emi62.c	2005-08-30 01:00:26.000000000 +0200
@@ -7,7 +7,7 @@
  * it under the terms of the GNU General Public License, as published by
  * the Free Software Foundation, version 2.
  * 
- * $Id$
+ * $Id$
  */
 #include <linux/kernel.h>
 #include <linux/errno.h>
diff -Nur linux-2.6.13.1.org/drivers/usb/serial/digi_acceleport.c grsecurity226/drivers/usb/serial/digi_acceleport.c
--- linux-2.6.13.1.org/drivers/usb/serial/digi_acceleport.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/serial/digi_acceleport.c	2005-08-30 01:00:28.000000000 +0200
@@ -230,7 +230,7 @@
 *  - Following Documentation/DocBook/kernel-locking.pdf no spin locks
 *    are held when calling copy_to/from_user or printk.
 *    
-*  $Id$
+*  $Id$
 */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/drivers/usb/serial/keyspan_pda.S grsecurity226/drivers/usb/serial/keyspan_pda.S
--- linux-2.6.13.1.org/drivers/usb/serial/keyspan_pda.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/serial/keyspan_pda.S	2005-08-30 01:00:28.000000000 +0200
@@ -1,4 +1,4 @@
-/*  $Id$
+/*  $Id$
  * 
  *  Firmware for the Keyspan PDA Serial Adapter, a USB serial port based on
  *  the EzUSB microcontroller.
diff -Nur linux-2.6.13.1.org/drivers/usb/serial/xircom_pgs.S grsecurity226/drivers/usb/serial/xircom_pgs.S
--- linux-2.6.13.1.org/drivers/usb/serial/xircom_pgs.S	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/serial/xircom_pgs.S	2005-08-30 01:00:29.000000000 +0200
@@ -1,4 +1,4 @@
-/*  $Id$
+/*  $Id$
  * 
  *  Firmware for the Keyspan PDA Serial Adapter, a USB serial port based on
  *  the EzUSB microcontroller.
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/datafab.c grsecurity226/drivers/usb/storage/datafab.c
--- linux-2.6.13.1.org/drivers/usb/storage/datafab.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/datafab.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for Datafab USB Compact Flash reader
  *
- * $Id$
+ * $Id$
  *
  * datafab driver v0.1:
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/debug.c grsecurity226/drivers/usb/storage/debug.c
--- linux-2.6.13.1.org/drivers/usb/storage/debug.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/debug.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for USB Mass Storage compliant devices
  * Debugging Functions Source Code File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/debug.h grsecurity226/drivers/usb/storage/debug.h
--- linux-2.6.13.1.org/drivers/usb/storage/debug.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/debug.h	2005-08-30 01:00:29.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for USB Mass Storage compliant devices
  * Debugging Functions Header File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/dpcm.c grsecurity226/drivers/usb/storage/dpcm.c
--- linux-2.6.13.1.org/drivers/usb/storage/dpcm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/dpcm.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for Microtech DPCM-USB CompactFlash/SmartMedia reader
  *
- * $Id$
+ * $Id$
  *
  * DPCM driver v0.1:
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/dpcm.h grsecurity226/drivers/usb/storage/dpcm.h
--- linux-2.6.13.1.org/drivers/usb/storage/dpcm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/dpcm.h	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for Microtech DPCM-USB CompactFlash/SmartMedia reader
  *
- * $Id$
+ * $Id$
  *
  * DPCM driver v0.1:
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/freecom.c grsecurity226/drivers/usb/storage/freecom.c
--- linux-2.6.13.1.org/drivers/usb/storage/freecom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/freecom.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for Freecom USB/IDE adaptor
  *
- * $Id$
+ * $Id$
  *
  * Freecom v0.1:
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/freecom.h grsecurity226/drivers/usb/storage/freecom.h
--- linux-2.6.13.1.org/drivers/usb/storage/freecom.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/freecom.h	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for Freecom USB/IDE adaptor
  *
- * $Id$
+ * $Id$
  *
  * Freecom v0.1:
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/initializers.c grsecurity226/drivers/usb/storage/initializers.c
--- linux-2.6.13.1.org/drivers/usb/storage/initializers.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/initializers.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Special Initializers for certain USB Mass Storage devices
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/initializers.h grsecurity226/drivers/usb/storage/initializers.h
--- linux-2.6.13.1.org/drivers/usb/storage/initializers.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/initializers.h	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Header file for Special Initializers for certain USB Mass Storage devices
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/isd200.c grsecurity226/drivers/usb/storage/isd200.c
--- linux-2.6.13.1.org/drivers/usb/storage/isd200.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/isd200.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Transport & Protocol Driver for In-System Design, Inc. ISD200 ASIC
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance:
  *   (C) 2001-2002 Bjrn Stenberg (bjorn@haxx.se)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/jumpshot.c grsecurity226/drivers/usb/storage/jumpshot.c
--- linux-2.6.13.1.org/drivers/usb/storage/jumpshot.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/jumpshot.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for Lexar "Jumpshot" Compact Flash reader
  *
- * $Id$
+ * $Id$
  *
  * jumpshot driver v0.1:
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/protocol.c grsecurity226/drivers/usb/storage/protocol.c
--- linux-2.6.13.1.org/drivers/usb/storage/protocol.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/protocol.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for USB Mass Storage compliant devices
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/protocol.h grsecurity226/drivers/usb/storage/protocol.h
--- linux-2.6.13.1.org/drivers/usb/storage/protocol.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/protocol.h	2005-08-30 01:00:29.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for USB Mass Storage compliant devices
  * Protocol Functions Header File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/scsiglue.c grsecurity226/drivers/usb/storage/scsiglue.c
--- linux-2.6.13.1.org/drivers/usb/storage/scsiglue.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/scsiglue.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for USB Mass Storage compliant devices
  * SCSI layer glue code
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/scsiglue.h grsecurity226/drivers/usb/storage/scsiglue.h
--- linux-2.6.13.1.org/drivers/usb/storage/scsiglue.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/scsiglue.h	2005-08-30 01:00:29.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for USB Mass Storage compliant devices
  * SCSI Connecting Glue Header File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/sddr09.c grsecurity226/drivers/usb/storage/sddr09.c
--- linux-2.6.13.1.org/drivers/usb/storage/sddr09.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/sddr09.c	2005-08-30 01:00:29.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for SanDisk SDDR-09 SmartMedia reader
  *
- * $Id$
+ * $Id$
  *   (c) 2000, 2001 Robert Baruch (autophile@starband.net)
  *   (c) 2002 Andries Brouwer (aeb@cwi.nl)
  * Developed with the assistance of:
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/sddr09.h grsecurity226/drivers/usb/storage/sddr09.h
--- linux-2.6.13.1.org/drivers/usb/storage/sddr09.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/sddr09.h	2005-08-30 01:00:30.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for SanDisk SDDR-09 SmartMedia reader
  * Header File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 2000 Robert Baruch (autophile@dol.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/sddr55.c grsecurity226/drivers/usb/storage/sddr55.c
--- linux-2.6.13.1.org/drivers/usb/storage/sddr55.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/sddr55.c	2005-08-30 01:00:30.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for SanDisk SDDR-55 SmartMedia reader
  *
- * $Id$
+ * $Id$
  *
  * SDDR55 driver v0.1:
  *
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/sddr55.h grsecurity226/drivers/usb/storage/sddr55.h
--- linux-2.6.13.1.org/drivers/usb/storage/sddr55.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/sddr55.h	2005-08-30 01:00:30.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for SanDisk SDDR-55 SmartMedia reader
  * Header File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 2002 Simon Munton
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/shuttle_usbat.c grsecurity226/drivers/usb/storage/shuttle_usbat.c
--- linux-2.6.13.1.org/drivers/usb/storage/shuttle_usbat.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/shuttle_usbat.c	2005-08-30 01:00:30.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for SCM Microsystems USB-ATAPI cable
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 2000, 2001 Robert Baruch (autophile@starband.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/shuttle_usbat.h grsecurity226/drivers/usb/storage/shuttle_usbat.h
--- linux-2.6.13.1.org/drivers/usb/storage/shuttle_usbat.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/shuttle_usbat.h	2005-08-30 01:00:30.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for SCM Microsystems USB-ATAPI cable
  * Header File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 2000 Robert Baruch (autophile@dol.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/transport.c grsecurity226/drivers/usb/storage/transport.c
--- linux-2.6.13.1.org/drivers/usb/storage/transport.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/transport.c	2005-08-30 01:00:30.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for USB Mass Storage compliant devices
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/transport.h grsecurity226/drivers/usb/storage/transport.h
--- linux-2.6.13.1.org/drivers/usb/storage/transport.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/transport.h	2005-08-30 01:00:30.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for USB Mass Storage compliant devices
  * Transport Functions Header File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/unusual_devs.h grsecurity226/drivers/usb/storage/unusual_devs.h
--- linux-2.6.13.1.org/drivers/usb/storage/unusual_devs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/unusual_devs.h	2005-08-30 01:00:30.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for USB Mass Storage compliant devices
  * Unusual Devices File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 2000-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/usb.c grsecurity226/drivers/usb/storage/usb.c
--- linux-2.6.13.1.org/drivers/usb/storage/usb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/usb.c	2005-08-30 01:00:30.000000000 +0200
@@ -1,6 +1,6 @@
 /* Driver for USB Mass Storage compliant devices
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999-2003 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/usb/storage/usb.h grsecurity226/drivers/usb/storage/usb.h
--- linux-2.6.13.1.org/drivers/usb/storage/usb.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/usb/storage/usb.h	2005-08-30 01:00:30.000000000 +0200
@@ -1,7 +1,7 @@
 /* Driver for USB Mass Storage compliant devices
  * Main Header File
  *
- * $Id$
+ * $Id$
  *
  * Current development and maintenance by:
  *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
diff -Nur linux-2.6.13.1.org/drivers/video/aty/aty128fb.c grsecurity226/drivers/video/aty/aty128fb.c
--- linux-2.6.13.1.org/drivers/video/aty/aty128fb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/video/aty/aty128fb.c	2005-08-30 01:00:30.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *  linux/drivers/video/aty128fb.c -- Frame buffer device for ATI Rage128
  *
  *  Copyright (C) 1999-2003, Brad Douglas <brad@neruo.com>
diff -Nur linux-2.6.13.1.org/drivers/video/console/promcon.c grsecurity226/drivers/video/console/promcon.c
--- linux-2.6.13.1.org/drivers/video/console/promcon.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/video/console/promcon.c	2005-08-30 01:00:30.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * Console driver utilizing PROM sun terminal emulation
  *
  * Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)
diff -Nur linux-2.6.13.1.org/drivers/video/cyberfb.c grsecurity226/drivers/video/cyberfb.c
--- linux-2.6.13.1.org/drivers/video/cyberfb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/video/cyberfb.c	2005-08-30 01:00:30.000000000 +0200
@@ -1,6 +1,6 @@
 /*
 * linux/drivers/video/cyberfb.c -- CyberVision64 frame buffer device
-* $Id$
+* $Id$
 *
 *    Copyright (C) 1998 Alan Bair
 *
@@ -33,6 +33,9 @@
 *   - 05 Jan 96: Geert: integration into the current source tree
 *   - 01 Aug 98: Alan: Merge in code from cvision.c and cvision_core.c
 * $Log$
+* Revision 1.1.1.1  2005/08/29 23:00:30  spender
+* Initial import of Linux 2.6.13
+*
 * Revision 1.6  1998/09/11 04:54:58  abair
 * Update for 2.1.120 change in include file location.
 * Clean up for public release.
diff -Nur linux-2.6.13.1.org/drivers/video/g364fb.c grsecurity226/drivers/video/g364fb.c
--- linux-2.6.13.1.org/drivers/video/g364fb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/video/g364fb.c	2005-08-30 01:00:30.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * linux/drivers/video/g364fb.c -- Mips Magnum frame buffer device
  *
diff -Nur linux-2.6.13.1.org/drivers/video/pm3fb.c grsecurity226/drivers/video/pm3fb.c
--- linux-2.6.13.1.org/drivers/video/pm3fb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/video/pm3fb.c	2005-08-30 01:00:30.000000000 +0200
@@ -16,7 +16,7 @@
  *  License. See the file COPYING in the main directory of this archive for
  *  more details.
  *
- *  $Header$
+ *  $Header$
  *
  *  CHANGELOG:
  *  Mon Feb 11 10:35:48 MET 2002, v 1.4.11B: Cosmetic update.
@@ -3515,7 +3515,7 @@
 {
 	DTRACE;
 
-	DPRINTK(2, "This is pm3fb.c, CVS version: $Header$");
+	DPRINTK(2, "This is pm3fb.c, CVS version: $Header$");
 
 	pm3fb_real_setup(g_options);
 
diff -Nur linux-2.6.13.1.org/drivers/video/vesafb.c grsecurity226/drivers/video/vesafb.c
--- linux-2.6.13.1.org/drivers/video/vesafb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/video/vesafb.c	2005-08-30 01:14:15.000000000 +0200
@@ -265,7 +265,7 @@
 		size_remap = size_total;
 	vesafb_fix.smem_len = size_remap;
 
-#ifndef __i386__
+#if !defined(__i386__) || defined(CONFIG_PAX_KERNEXEC)
 	screen_info.vesapm_seg = 0;
 #endif
 
diff -Nur linux-2.6.13.1.org/drivers/zorro/proc.c grsecurity226/drivers/zorro/proc.c
--- linux-2.6.13.1.org/drivers/zorro/proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/zorro/proc.c	2005-08-30 01:00:31.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *	$Id$
+ *	$Id$
  *
  *	Procfs interface for the Zorro bus.
  *
diff -Nur linux-2.6.13.1.org/drivers/zorro/zorro.c grsecurity226/drivers/zorro/zorro.c
--- linux-2.6.13.1.org/drivers/zorro/zorro.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/zorro/zorro.c	2005-08-30 01:00:31.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *    $Id$
+ *    $Id$
  *
  *    Zorro Bus Services
  *
diff -Nur linux-2.6.13.1.org/drivers/zorro/zorro.ids grsecurity226/drivers/zorro/zorro.ids
--- linux-2.6.13.1.org/drivers/zorro/zorro.ids	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/drivers/zorro/zorro.ids	2005-08-30 01:00:31.000000000 +0200
@@ -4,7 +4,7 @@
 #	Maintained by Geert Uytterhoeven <zorro@linux-m68k.org>
 #	If you have any new entries, please send them to the maintainer.
 #
-#	$Id$
+#	$Id$
 #
 
 # Manufacturers and Products. Please keep sorted.
diff -Nur linux-2.6.13.1.org/fs/Kconfig grsecurity226/fs/Kconfig
--- linux-2.6.13.1.org/fs/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/Kconfig	2005-08-30 01:14:17.000000000 +0200
@@ -751,7 +751,7 @@
 
 config PROC_KCORE
 	bool "/proc/kcore support" if !ARM
-	depends on PROC_FS && MMU
+	depends on PROC_FS && MMU && !GRKERNSEC_PROC_ADD
 
 config PROC_VMCORE
         bool "/proc/vmcore support (EXPERIMENTAL)"
diff -Nur linux-2.6.13.1.org/fs/binfmt_aout.c grsecurity226/fs/binfmt_aout.c
--- linux-2.6.13.1.org/fs/binfmt_aout.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/binfmt_aout.c	2005-08-30 01:14:18.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 #include <linux/init.h>
+#include <linux/grsecurity.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -125,10 +126,12 @@
 /* If the size of the dump file exceeds the rlimit, then see what would happen
    if we wrote the stack, but not the data area.  */
 #ifdef __sparc__
+	gr_learn_resource(current, RLIMIT_CORE, dump.u_dsize+dump.u_ssize, 1);
 	if ((dump.u_dsize+dump.u_ssize) >
 	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
 #else
+	gr_learn_resource(current, RLIMIT_CORE, (dump.u_dsize+dump.u_ssize+1) * PAGE_SIZE, 1);
 	if ((dump.u_dsize+dump.u_ssize+1) * PAGE_SIZE >
 	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
@@ -136,10 +139,12 @@
 
 /* Make sure we have enough room to write the stack and data areas. */
 #ifdef __sparc__
+	gr_learn_resource(current, RLIMIT_CORE, dump.u_ssize, 1);
 	if ((dump.u_ssize) >
 	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
 #else
+	gr_learn_resource(current, RLIMIT_CORE, (dump.u_ssize+1) * PAGE_SIZE, 1);
 	if ((dump.u_ssize+1) * PAGE_SIZE >
 	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
@@ -289,6 +294,8 @@
 	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
+
+	gr_learn_resource(current, RLIMIT_DATA, ex.a_data + ex.a_bss, 1);
 	if (ex.a_data + ex.a_bss > rlim)
 		return -ENOMEM;
 
@@ -322,6 +329,28 @@
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(N_FLAGS(ex) & F_PAX_PAGEEXEC)) {
+		current->mm->pax_flags |= MF_PAX_PAGEEXEC;
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		if (N_FLAGS(ex) & F_PAX_EMUTRAMP)
+			current->mm->pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (!(N_FLAGS(ex) & F_PAX_MPROTECT))
+			current->mm->pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+	}
+#endif
+
 #ifdef __sparc__
 	if (N_MAGIC(ex) == NMAGIC) {
 		loff_t pos = fd_offset;
@@ -417,7 +446,7 @@
 
 		down_write(&current->mm->mmap_sem);
  		error = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,
-				PROT_READ | PROT_WRITE | PROT_EXEC,
+				PROT_READ | PROT_WRITE,
 				MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
 				fd_offset + ex.a_text);
 		up_write(&current->mm->mmap_sem);
diff -Nur linux-2.6.13.1.org/fs/binfmt_elf.c grsecurity226/fs/binfmt_elf.c
--- linux-2.6.13.1.org/fs/binfmt_elf.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/binfmt_elf.c	2005-08-30 01:14:18.000000000 +0200
@@ -38,11 +38,16 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#include <asm/desc.h>
+#endif
+
 #include <linux/elf.h>
 
 static int load_elf_binary(struct linux_binprm * bprm, struct pt_regs * regs);
@@ -90,8 +95,11 @@
 
 static int set_brk(unsigned long start, unsigned long end)
 {
+	unsigned long e = end;
+
 	start = ELF_PAGEALIGN(start);
 	end = ELF_PAGEALIGN(end);
+
 	if (end > start) {
 		unsigned long addr;
 		down_write(&current->mm->mmap_sem);
@@ -99,8 +107,9 @@
 		up_write(&current->mm->mmap_sem);
 		if (BAD_ADDR(addr))
 			return addr;
+
 	}
-	current->mm->start_brk = current->mm->brk = end;
+	current->mm->start_brk = current->mm->brk = e;
 	return 0;
 }
 
@@ -310,11 +319,11 @@
 {
 	struct elf_phdr *elf_phdata;
 	struct elf_phdr *eppnt;
-	unsigned long load_addr = 0;
-	int load_addr_set = 0;
+	unsigned long load_addr = 0, min_addr, max_addr;
 	unsigned long last_bss = 0, elf_bss = 0;
-	unsigned long error = ~0UL;
+	unsigned long error = -EINVAL;
 	int retval, i, size;
+	unsigned long task_size = TASK_SIZE;
 
 	/* First of all, some simple consistency checks */
 	if (interp_elf_ex->e_type != ET_EXEC &&
@@ -352,10 +361,43 @@
 		goto out_close;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	eppnt = elf_phdata;
+	min_addr = task_size;
+	max_addr = 0;
+	error = -ENOMEM;
+
+	for (i=0; i<interp_elf_ex->e_phnum; i++, eppnt++) {
+		if (eppnt->p_type != PT_LOAD)
+			continue;
+
+		/*
+		 * Check to see if the section's size will overflow the
+		 * allowed task size. Note that p_filesz must always be
+		 * <= p_memsize so it is only necessary to check p_memsz.
+		 */
+		if (eppnt->p_filesz > eppnt->p_memsz || eppnt->p_vaddr >= eppnt->p_vaddr + eppnt->p_memsz)
+			goto out_close;
+
+		if (min_addr > eppnt->p_vaddr)
+			min_addr = eppnt->p_vaddr;
+		if (max_addr < eppnt->p_vaddr + eppnt->p_memsz)
+			max_addr = eppnt->p_vaddr;
+	}
+	if (min_addr >= max_addr || max_addr >= task_size)
+		goto out_close;
+
+	if (interp_elf_ex->e_type == ET_DYN)
+		load_addr = get_unmapped_area(interpreter, 0, max_addr - min_addr, 0, MAP_PRIVATE | MAP_EXECUTABLE);
+
 	eppnt = elf_phdata;
 	for (i=0; i<interp_elf_ex->e_phnum; i++, eppnt++) {
 	  if (eppnt->p_type == PT_LOAD) {
-	    int elf_type = MAP_PRIVATE | MAP_DENYWRITE;
+	    int elf_type = MAP_PRIVATE | MAP_DENYWRITE | MAP_FIXED;
 	    int elf_prot = 0;
 	    unsigned long vaddr = 0;
 	    unsigned long k, map_addr;
@@ -364,30 +406,11 @@
 	    if (eppnt->p_flags & PF_W) elf_prot |= PROT_WRITE;
 	    if (eppnt->p_flags & PF_X) elf_prot |= PROT_EXEC;
 	    vaddr = eppnt->p_vaddr;
-	    if (interp_elf_ex->e_type == ET_EXEC || load_addr_set)
-	    	elf_type |= MAP_FIXED;
 
 	    map_addr = elf_map(interpreter, load_addr + vaddr, eppnt, elf_prot, elf_type);
 	    error = map_addr;
 	    if (BAD_ADDR(map_addr))
-	    	goto out_close;
-
-	    if (!load_addr_set && interp_elf_ex->e_type == ET_DYN) {
-		load_addr = map_addr - ELF_PAGESTART(vaddr);
-		load_addr_set = 1;
-	    }
-
-	    /*
-	     * Check to see if the section's size will overflow the
-	     * allowed task size. Note that p_filesz must always be
-	     * <= p_memsize so it is only necessary to check p_memsz.
-	     */
-	    k = load_addr + eppnt->p_vaddr;
-	    if (k > TASK_SIZE || eppnt->p_filesz > eppnt->p_memsz ||
-		eppnt->p_memsz > TASK_SIZE || TASK_SIZE - eppnt->p_memsz < k) {
-	        error = -ENOMEM;
 		goto out_close;
-	    }
 
 	    /*
 	     * Find the end of the file mapping for this phdr, and keep
@@ -441,7 +464,7 @@
 static unsigned long load_aout_interp(struct exec * interp_ex,
 			     struct file * interpreter)
 {
-	unsigned long text_data, elf_entry = ~0UL;
+	unsigned long text_data, elf_entry = -EINVAL;
 	char __user * addr;
 	loff_t offset;
 
@@ -485,6 +508,180 @@
 	return elf_entry;
 }
 
+#if (defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)) && defined(CONFIG_PAX_SOFTMODE)
+static unsigned long pax_parse_softmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (elf_phdata->p_flags & PF_PAGEEXEC)
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (elf_phdata->p_flags & PF_SEGMEXEC)
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_PAGEEXEC
+	if (pax_flags & MF_PAX_PAGEEXEC)
+		pax_flags &= ~MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_SEGMEXEC
+	if (pax_flags & MF_PAX_SEGMEXEC)
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (elf_phdata->p_flags & PF_EMUTRAMP)
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (elf_phdata->p_flags & PF_MPROTECT)
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+	if (randomize_va_space && (elf_phdata->p_flags & PF_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+static unsigned long pax_parse_hardmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_phdata->p_flags & PF_NOPAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_phdata->p_flags & PF_NOSEGMEXEC))
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_PAGEEXEC
+	if (pax_flags & MF_PAX_PAGEEXEC)
+		pax_flags &= ~MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_SEGMEXEC
+	if (pax_flags & MF_PAX_SEGMEXEC)
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (!(elf_phdata->p_flags & PF_NOEMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (!(elf_phdata->p_flags & PF_NOMPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+	if (randomize_va_space && !(elf_phdata->p_flags & PF_NORANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_EI_PAX
+static unsigned long pax_parse_ei_pax(const struct elfhdr * const elf_ex)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_PAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_SEGMEXEC))
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_PAGEEXEC
+	if (pax_flags & MF_PAX_PAGEEXEC)
+		pax_flags &= ~MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_DEFAULT_SEGMEXEC
+	if (pax_flags & MF_PAX_SEGMEXEC)
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && (elf_ex->e_ident[EI_PAX] & EF_PAX_EMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && !(elf_ex->e_ident[EI_PAX] & EF_PAX_MPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	if (randomize_va_space && !(elf_ex->e_ident[EI_PAX] & EF_PAX_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)
+static long pax_parse_elf_flags(const struct elfhdr * const elf_ex, const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	unsigned long i;
+#endif
+
+#ifdef CONFIG_PAX_EI_PAX
+	pax_flags = pax_parse_ei_pax(elf_ex);
+#endif
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	for (i = 0UL; i < elf_ex->e_phnum; i++)
+		if (elf_phdata[i].p_type == PT_PAX_FLAGS) {
+			if (((elf_phdata[i].p_flags & PF_PAGEEXEC) && (elf_phdata[i].p_flags & PF_NOPAGEEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_SEGMEXEC) && (elf_phdata[i].p_flags & PF_NOSEGMEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_EMUTRAMP) && (elf_phdata[i].p_flags & PF_NOEMUTRAMP)) ||
+			    ((elf_phdata[i].p_flags & PF_MPROTECT) && (elf_phdata[i].p_flags & PF_NOMPROTECT)) ||
+			    ((elf_phdata[i].p_flags & PF_RANDMMAP) && (elf_phdata[i].p_flags & PF_NORANDMMAP)))
+				return -EINVAL;
+
+#ifdef CONFIG_PAX_SOFTMODE
+			if (pax_softmode)
+				pax_flags = pax_parse_softmode(&elf_phdata[i]);
+			else
+#endif
+
+				pax_flags = pax_parse_hardmode(&elf_phdata[i]);
+			break;
+		}
+#endif
+
+	if (0 > pax_check_flags(&pax_flags))
+		return -EINVAL;
+
+	current->mm->pax_flags = pax_flags;
+	return 0;
+}
+#endif
+
 /*
  * These are the functions used to load ELF style executables and shared
  * libraries.  There is no binary dependent code anywhere else.
@@ -516,7 +713,7 @@
 	char * elf_interpreter = NULL;
 	unsigned int interpreter_type = INTERPRETER_NONE;
 	unsigned char ibcs2_interpreter = 0;
-	unsigned long error;
+	unsigned long error = 0;
 	struct elf_phdr * elf_ppnt, *elf_phdata;
 	unsigned long elf_bss, elf_brk;
 	int elf_exec_fileno;
@@ -534,6 +731,7 @@
 		struct elfhdr interp_elf_ex;
   		struct exec interp_ex;
 	} *loc;
+	unsigned long task_size = TASK_SIZE;
 
 	loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 	if (!loc) {
@@ -759,14 +957,88 @@
 	current->mm->end_code = 0;
 	current->mm->mmap = NULL;
 	current->flags &= ~PF_FORKNOEXEC;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	current->mm->call_dl_resolve = 0UL;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	current->mm->call_syscall = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	current->mm->delta_mmap = 0UL;
+	current->mm->delta_exec = 0UL;
+	current->mm->delta_stack = 0UL;
+#endif
+
 	current->mm->def_flags = def_flags;
 
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)
+	if (0 > pax_parse_elf_flags(&loc->elf_ex, elf_phdata)) {
+		send_sig(SIGKILL, current, 0);
+		goto out_free_dentry;
+	}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+	pax_set_initial_flags(bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+	if (pax_set_initial_flags_func)
+		(pax_set_initial_flags_func)(bprm);
+#endif
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+	if (current->mm->pax_flags & MF_PAX_PAGEEXEC)
+		current->mm->context.user_cs_limit = PAGE_SIZE;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		int cpu = get_cpu();
+
+		current->mm->context.user_cs_base = SEGMEXEC_TASK_SIZE;
+		current->mm->context.user_cs_limit = -SEGMEXEC_TASK_SIZE;
+		set_user_cs(current->mm, cpu);
+		put_cpu();
+		task_size = SEGMEXEC_TASK_SIZE;
+	}
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+#define pax_delta_mask(delta, lsb, len) (((delta) & ((1UL << (len)) - 1)) << (lsb))
+
+		current->mm->delta_mmap = pax_delta_mask(pax_get_random_long(), PAX_DELTA_MMAP_LSB(current), PAX_DELTA_MMAP_LEN(current));
+		current->mm->delta_exec = pax_delta_mask(pax_get_random_long(), PAX_DELTA_EXEC_LSB(current), PAX_DELTA_EXEC_LEN(current));
+		current->mm->delta_stack = pax_delta_mask(pax_get_random_long(), PAX_DELTA_STACK_LSB(current), PAX_DELTA_STACK_LEN(current));
+	}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (current->mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+		executable_stack = EXSTACK_DEFAULT;
+#endif
+
 	/* Do this immediately, since STACK_TOP as used in setup_arg_pages
 	   may depend on the personality.  */
 	SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (!(current->mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)))
+#endif
+
 	if (elf_read_implies_exec(loc->elf_ex, executable_stack))
 		current->personality |= READ_IMPLIES_EXEC;
 
+#ifdef CONFIG_PAX_ASLR
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if ( !(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		current->flags |= PF_RANDOMIZE;
 	arch_pick_mmap_layout(current->mm);
@@ -839,6 +1111,15 @@
 			   base, as well as whatever program they might try to exec.  This
 			   is because the brk will follow the loader, and is not movable.  */
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
+
+#ifdef CONFIG_PAX_RANDMMAP
+			/* PaX: randomize base address at the default exe base if requested */
+			if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+				load_bias = ELF_PAGESTART(PAX_ELF_ET_DYN_BASE(current) - vaddr + current->mm->delta_exec);
+				elf_flags |= MAP_FIXED;
+			}
+#endif
+
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);
@@ -866,9 +1147,9 @@
 		 * allowed task size. Note that p_filesz must always be
 		 * <= p_memsz so it is only necessary to check p_memsz.
 		 */
-		if (k > TASK_SIZE || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
-		    elf_ppnt->p_memsz > TASK_SIZE ||
-		    TASK_SIZE - elf_ppnt->p_memsz < k) {
+		if (k > task_size || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
+		    elf_ppnt->p_memsz > task_size ||
+		    task_size - elf_ppnt->p_memsz < k) {
 			/* set_brk can never work.  Avoid overflows.  */
 			send_sig(SIGKILL, current, 0);
 			goto out_free_dentry;
@@ -895,6 +1176,12 @@
 	start_data += load_bias;
 	end_data += load_bias;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (randomize_va_space)
+		elf_brk += PAGE_SIZE + pax_delta_mask(pax_get_random_long(), 4, PAGE_SHIFT);
+#undef pax_delta_mask
+#endif
+
 	/* Calling set_brk effectively mmaps the pages that we need
 	 * for the bss and break sections.  We must do this before
 	 * mapping in the interpreter, to make sure it doesn't wind
@@ -923,7 +1210,7 @@
 			printk(KERN_ERR "Unable to load interpreter %.128s\n",
 				elf_interpreter);
 			force_sig(SIGSEGV, current);
-			retval = -ENOEXEC; /* Nobody gets to see this, but.. */
+			retval = elf_entry; /* Nobody gets to see this, but.. */
 			goto out_free_dentry;
 		}
 		reloc_func_desc = interp_load_addr;
@@ -1153,9 +1440,11 @@
 	if (vma->vm_flags & VM_SHARED)
 		return vma->vm_file->f_dentry->d_inode->i_nlink == 0;
 
+#if 0
 	/* If it hasn't been written to, don't write it out */
 	if (!vma->anon_vma)
 		return 0;
+#endif
 
 	return 1;
 }
@@ -1208,8 +1497,11 @@
 #undef DUMP_SEEK
 
 #define DUMP_WRITE(addr, nr)	\
+	do { \
+	gr_learn_resource(current, RLIMIT_CORE, size + (nr), 1); \
 	if ((size += (nr)) > limit || !dump_write(file, (addr), (nr))) \
-		goto end_coredump;
+		goto end_coredump; \
+	} while (0);
 #define DUMP_SEEK(off)	\
 	if (!dump_seek(file, (off))) \
 		goto end_coredump;
@@ -1614,6 +1906,7 @@
 					void *kaddr;
 					flush_cache_page(vma, addr, page_to_pfn(page));
 					kaddr = kmap(page);
+					gr_learn_resource(current, RLIMIT_CORE, size + PAGE_SIZE, 1);
 					if ((size += PAGE_SIZE) > limit ||
 					    !dump_write(file, kaddr,
 					    PAGE_SIZE)) {
diff -Nur linux-2.6.13.1.org/fs/binfmt_flat.c grsecurity226/fs/binfmt_flat.c
--- linux-2.6.13.1.org/fs/binfmt_flat.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/binfmt_flat.c	2005-08-30 01:14:18.000000000 +0200
@@ -540,7 +540,9 @@
 				realdatastart = (unsigned long) -ENOMEM;
 			printk("Unable to allocate RAM for process data, errno %d\n",
 					(int)-datapos);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len);
+			up_write(&current->mm->mmap_sem);
 			return realdatastart;
 		}
 		datapos = realdatastart + MAX_SHARED_LIBS * sizeof(unsigned long);
@@ -561,8 +563,10 @@
 		}
 		if (result >= (unsigned long)-4096) {
 			printk("Unable to read data+bss, errno %d\n", (int)-result);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len);
 			do_munmap(current->mm, realdatastart, data_len + extra);
+			up_write(&current->mm->mmap_sem);
 			return result;
 		}
 
@@ -624,8 +628,10 @@
 		}
 		if (result >= (unsigned long)-4096) {
 			printk("Unable to read code+data+bss, errno %d\n",(int)-result);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len + data_len + extra +
 				MAX_SHARED_LIBS * sizeof(unsigned long));
+			up_write(&current->mm->mmap_sem);
 			return result;
 		}
 	}
diff -Nur linux-2.6.13.1.org/fs/binfmt_misc.c grsecurity226/fs/binfmt_misc.c
--- linux-2.6.13.1.org/fs/binfmt_misc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/binfmt_misc.c	2005-08-30 01:14:18.000000000 +0200
@@ -112,9 +112,11 @@
 	struct files_struct *files = NULL;
 
 	retval = -ENOEXEC;
-	if (!enabled)
+	if (!enabled || bprm->misc)
 		goto _ret;
 
+	bprm->misc++;
+
 	/* to keep locking time low, we copy the interpreter string */
 	read_lock(&entries_lock);
 	fmt = check_file(bprm);
diff -Nur linux-2.6.13.1.org/fs/buffer.c grsecurity226/fs/buffer.c
--- linux-2.6.13.1.org/fs/buffer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/buffer.c	2005-08-30 01:14:18.000000000 +0200
@@ -40,6 +40,7 @@
 #include <linux/cpu.h>
 #include <linux/bitops.h>
 #include <linux/mpage.h>
+#include <linux/grsecurity.h>
 
 static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);
 static void invalidate_bh_lrus(void);
@@ -2158,6 +2159,7 @@
 
 	err = -EFBIG;
         limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
+	gr_learn_resource(current, RLIMIT_FSIZE, (unsigned long) size, 1);
 	if (limit != RLIM_INFINITY && size > (loff_t)limit) {
 		send_sig(SIGXFSZ, current, 0);
 		goto out;
diff -Nur linux-2.6.13.1.org/fs/compat.c grsecurity226/fs/compat.c
--- linux-2.6.13.1.org/fs/compat.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/compat.c	2005-08-30 01:14:18.000000000 +0200
@@ -44,6 +44,7 @@
 #include <linux/nfsd/syscall.h>
 #include <linux/personality.h>
 #include <linux/rwsem.h>
+#include <linux/grsecurity.h>
 
 #include <net/sock.h>		/* siocdevprivate_ioctl */
 
@@ -1505,6 +1506,11 @@
 	struct file *file;
 	int retval;
 	int i;
+#ifdef CONFIG_GRKERNSEC
+	struct file *old_exec_file;
+	struct acl_subject_label *old_acl;
+	struct rlimit old_rlim[RLIM_NLIMITS];
+#endif
 
 	retval = -ENOMEM;
 	bprm = kmalloc(sizeof(*bprm), GFP_KERNEL);
@@ -1523,6 +1529,15 @@
 	bprm->file = file;
 	bprm->filename = filename;
 	bprm->interp = filename;
+
+	gr_learn_resource(current, RLIMIT_NPROC, atomic_read(&current->user->processes), 1);
+	retval = -EAGAIN;
+	if (gr_handle_nproc())
+		goto out_file;
+	retval = -EACCES;
+	if (!gr_acl_handle_execve(file->f_dentry, file->f_vfsmnt))
+		goto out_file;
+
 	bprm->mm = mm_alloc();
 	retval = -ENOMEM;
 	if (!bprm->mm)
@@ -1561,16 +1576,52 @@
 	if (retval < 0)
 		goto out;
 
+	if (!gr_tpe_allow(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	if (gr_check_crash_exec(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	gr_log_chroot_exec(file->f_dentry, file->f_vfsmnt);
+
+	gr_handle_exec_args(bprm, (char __user * __user *)argv);
+
+#ifdef CONFIG_GRKERNSEC
+	old_acl = current->acl;
+	memcpy(old_rlim, current->signal->rlim, sizeof(old_rlim));
+	old_exec_file = current->exec_file;
+	get_file(file);
+	current->exec_file = file;
+#endif
+
+	gr_set_proc_label(file->f_dentry, file->f_vfsmnt);
+
 	retval = search_binary_handler(bprm, regs);
 	if (retval >= 0) {
 		free_arg_pages(bprm);
 
+#ifdef CONFIG_GRKERNSEC
+		if (old_exec_file)
+			fput(old_exec_file);
+#endif
+
 		/* execve success */
 		security_bprm_free(bprm);
 		kfree(bprm);
 		return retval;
 	}
 
+#ifdef CONFIG_GRKERNSEC
+	current->acl = old_acl;
+	memcpy(current->signal->rlim, old_rlim, sizeof(old_rlim));
+	fput(current->exec_file);
+	current->exec_file = old_exec_file;
+#endif
+
 out:
 	/* Something went wrong, return the inode and free the argument pages*/
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
diff -Nur linux-2.6.13.1.org/fs/dcache.c grsecurity226/fs/dcache.c
--- linux-2.6.13.1.org/fs/dcache.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/dcache.c	2005-08-30 01:14:18.000000000 +0200
@@ -1362,7 +1362,7 @@
  *
  * "buflen" should be positive. Caller holds the dcache_lock.
  */
-static char * __d_path( struct dentry *dentry, struct vfsmount *vfsmnt,
+char * __d_path( struct dentry *dentry, struct vfsmount *vfsmnt,
 			struct dentry *root, struct vfsmount *rootmnt,
 			char *buffer, int buflen)
 {
diff -Nur linux-2.6.13.1.org/fs/dquot.c grsecurity226/fs/dquot.c
--- linux-2.6.13.1.org/fs/dquot.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/dquot.c	2005-08-30 01:00:31.000000000 +0200
@@ -9,7 +9,7 @@
  * implementation is based on one of the several variants of the LINUX
  * inode-subsystem with added complexity of the diskquota system.
  * 
- * Version: $Id$
+ * Version: $Id$
  * 
  * Author:	Marco van Wieringen <mvw@planets.elm.net>
  *
diff -Nur linux-2.6.13.1.org/fs/exec.c grsecurity226/fs/exec.c
--- linux-2.6.13.1.org/fs/exec.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/exec.c	2005-08-30 01:14:18.000000000 +0200
@@ -48,6 +48,8 @@
 #include <linux/syscalls.h>
 #include <linux/rmap.h>
 #include <linux/acct.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -66,6 +68,15 @@
 static struct linux_binfmt *formats;
 static DEFINE_RWLOCK(binfmt_lock);
 
+#ifdef CONFIG_PAX_SOFTMODE
+unsigned int pax_softmode;
+#endif
+
+#ifdef CONFIG_PAX_HOOK_ACL_FLAGS
+void (*pax_set_initial_flags_func)(struct linux_binprm * bprm);
+EXPORT_SYMBOL(pax_set_initial_flags_func);
+#endif
+
 int register_binfmt(struct linux_binfmt * fmt)
 {
 	struct linux_binfmt ** tmp = &formats;
@@ -313,6 +324,10 @@
 	if (unlikely(anon_vma_prepare(vma)))
 		goto out_sig;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (page_count(page) == 1)
+#endif
+
 	flush_dcache_page(page);
 	pgd = pgd_offset(mm, address);
 
@@ -331,6 +346,11 @@
 		goto out;
 	}
 	inc_mm_counter(mm, rss);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (page_count(page) == 1)
+#endif
+
 	lru_cache_add_active(page);
 	set_pte_at(mm, address, pte, pte_mkdirty(pte_mkwrite(mk_pte(
 					page, vma->vm_page_prot))));
@@ -359,6 +379,10 @@
 	int i, ret;
 	long arg_size;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *mpnt_m = NULL;
+#endif
+
 #ifdef CONFIG_STACK_GROWSUP
 	/* Move the argument and environment strings to the bottom of the
 	 * stack space.
@@ -421,8 +445,24 @@
 	if (!mpnt)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (VM_STACK_FLAGS & VM_MAYEXEC)) {
+		mpnt_m = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+		if (!mpnt_m) {
+			kmem_cache_free(vm_area_cachep, mpnt);
+			return -ENOMEM;
+		}
+	}
+#endif
+
 	if (security_vm_enough_memory(arg_size >> PAGE_SHIFT)) {
 		kmem_cache_free(vm_area_cachep, mpnt);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (mpnt_m)
+			kmem_cache_free(vm_area_cachep, mpnt_m);
+#endif
+
 		return -ENOMEM;
 	}
 
@@ -448,13 +488,50 @@
 		else
 			mpnt->vm_flags = VM_STACK_FLAGS;
 		mpnt->vm_flags |= mm->def_flags;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(mm->pax_flags & MF_PAX_PAGEEXEC))
+			mpnt->vm_page_prot = protection_map[(mpnt->vm_flags | VM_EXEC) & 0x7];
+		else
+#endif
+
 		mpnt->vm_page_prot = protection_map[mpnt->vm_flags & 0x7];
 		if ((ret = insert_vm_struct(mm, mpnt))) {
 			up_write(&mm->mmap_sem);
 			kmem_cache_free(vm_area_cachep, mpnt);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (mpnt_m)
+				kmem_cache_free(vm_area_cachep, mpnt_m);
+#endif
+
 			return ret;
 		}
 		mm->stack_vm = mm->total_vm = vma_pages(mpnt);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (mpnt_m) {
+			*mpnt_m = *mpnt;
+			if (!(mpnt->vm_flags & VM_EXEC)) {
+				mpnt_m->vm_flags &= ~(VM_READ | VM_WRITE | VM_EXEC);
+				mpnt_m->vm_page_prot = PAGE_NONE;
+			}
+			mpnt_m->vm_start += SEGMEXEC_TASK_SIZE;
+			mpnt_m->vm_end += SEGMEXEC_TASK_SIZE;
+			if ((ret = insert_vm_struct(mm, mpnt_m))) {
+				up_write(&mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, mpnt_m);
+				return ret;
+			}
+			mpnt_m->vm_flags |= VM_MIRROR;
+			mpnt->vm_flags |= VM_MIRROR;
+			mpnt_m->vm_mirror = mpnt->vm_start - mpnt_m->vm_start;
+			mpnt->vm_mirror = mpnt_m->vm_start - mpnt->vm_start;
+			mpnt_m->vm_pgoff = mpnt->vm_pgoff;
+			mm->total_vm += (mpnt_m->vm_end - mpnt_m->vm_start) >> PAGE_SHIFT;
+		}
+#endif
+
 	}
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
@@ -462,6 +539,14 @@
 		if (page) {
 			bprm->page[i] = NULL;
 			install_arg_page(mpnt, page, stack_base);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (mpnt_m) {
+				page_cache_get(page);
+				install_arg_page(mpnt_m, page, stack_base + SEGMEXEC_TASK_SIZE);
+			}
+#endif
+
 		}
 		stack_base += PAGE_SIZE;
 	}
@@ -1147,6 +1232,11 @@
 	struct file *file;
 	int retval;
 	int i;
+#ifdef CONFIG_GRKERNSEC
+	struct file *old_exec_file;
+	struct acl_subject_label *old_acl;
+	struct rlimit old_rlim[RLIM_NLIMITS];
+#endif
 
 	retval = -ENOMEM;
 	bprm = kmalloc(sizeof(*bprm), GFP_KERNEL);
@@ -1159,10 +1249,29 @@
 	if (IS_ERR(file))
 		goto out_kfree;
 
+	gr_learn_resource(current, RLIMIT_NPROC, atomic_read(&current->user->processes), 1);
+
+	if (gr_handle_nproc()) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+
+	if (!gr_acl_handle_execve(file->f_dentry, file->f_vfsmnt)) {
+		allow_write_access(file);
+		fput(file);
+		return -EACCES;
+	}
+
 	sched_exec();
 
 	bprm->p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
 
+#ifdef CONFIG_PAX_RANDUSTACK
+	if (randomize_va_space)
+		bprm->p -= (pax_get_random_long() & ~(sizeof(void *)-1)) & ~PAGE_MASK;
+#endif
+
 	bprm->file = file;
 	bprm->filename = filename;
 	bprm->interp = filename;
@@ -1204,8 +1313,38 @@
 	if (retval < 0)
 		goto out;
 
+	if (!gr_tpe_allow(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	if (gr_check_crash_exec(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	gr_log_chroot_exec(file->f_dentry, file->f_vfsmnt);
+
+	gr_handle_exec_args(bprm, argv);
+
+#ifdef CONFIG_GRKERNSEC
+	old_acl = current->acl;
+	memcpy(old_rlim, current->signal->rlim, sizeof(old_rlim));
+	old_exec_file = current->exec_file;
+	get_file(file);
+	current->exec_file = file;
+#endif
+
+	retval = gr_set_proc_label(file->f_dentry, file->f_vfsmnt);
+	if (retval < 0)
+		goto out_fail;
+
 	retval = search_binary_handler(bprm,regs);
 	if (retval >= 0) {
+#ifdef CONFIG_GRKERNSEC
+		if (old_exec_file)
+			fput(old_exec_file);
+#endif
 		free_arg_pages(bprm);
 
 		/* execve success */
@@ -1216,6 +1355,14 @@
 		return retval;
 	}
 
+out_fail:
+#ifdef CONFIG_GRKERNSEC
+	current->acl = old_acl;
+	memcpy(current->signal->rlim, old_rlim, sizeof(old_rlim));
+	fput(current->exec_file);
+	current->exec_file = old_exec_file;
+#endif
+
 out:
 	/* Something went wrong, return the inode and free the argument pages*/
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
@@ -1376,6 +1523,114 @@
 	*out_ptr = 0;
 }
 
+int pax_check_flags(unsigned long * flags)
+{
+	int retval = 0;
+
+#if !defined(__i386__) || !defined(CONFIG_PAX_SEGMEXEC)
+	if (*flags & MF_PAX_SEGMEXEC)
+	{
+		*flags &= ~MF_PAX_SEGMEXEC;
+		retval = -EINVAL;
+	}
+#endif
+
+	if ((*flags & MF_PAX_PAGEEXEC)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	    &&  (*flags & MF_PAX_SEGMEXEC)
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_PAGEEXEC;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_MPROTECT)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_MPROTECT;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_EMUTRAMP)
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_EMUTRAMP;
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+EXPORT_SYMBOL(pax_check_flags);
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp)
+{
+	struct task_struct *tsk = current;
+	struct mm_struct *mm = current->mm;
+	char* buffer_exec = (char*)__get_free_page(GFP_ATOMIC);
+	char* buffer_fault = (char*)__get_free_page(GFP_ATOMIC);
+	char* path_exec=NULL;
+	char* path_fault=NULL;
+	unsigned long start=0UL, end=0UL, offset=0UL;
+
+	if (buffer_exec && buffer_fault) {
+		struct vm_area_struct* vma, * vma_exec=NULL, * vma_fault=NULL;
+
+		down_read(&mm->mmap_sem);
+		vma = mm->mmap;
+		while (vma && (!vma_exec || !vma_fault)) {
+			if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file)
+				vma_exec = vma;
+			if (vma->vm_start <= (unsigned long)pc && (unsigned long)pc < vma->vm_end)
+				vma_fault = vma;
+			vma = vma->vm_next;
+		}
+		if (vma_exec) {
+			path_exec = d_path(vma_exec->vm_file->f_dentry, vma_exec->vm_file->f_vfsmnt, buffer_exec, PAGE_SIZE);
+			if (IS_ERR(path_exec))
+				path_exec = "<path too long>";
+		}
+		if (vma_fault) {
+			start = vma_fault->vm_start;
+			end = vma_fault->vm_end;
+			offset = vma_fault->vm_pgoff << PAGE_SHIFT;
+			if (vma_fault->vm_file) {
+				path_fault = d_path(vma_fault->vm_file->f_dentry, vma_fault->vm_file->f_vfsmnt, buffer_fault, PAGE_SIZE);
+				if (IS_ERR(path_fault))
+					path_fault = "<path too long>";
+			} else
+				path_fault = "<anonymous mapping>";
+		}
+		up_read(&mm->mmap_sem);
+	}
+	if (tsk->signal->curr_ip)
+		printk(KERN_ERR "PAX: From %u.%u.%u.%u: execution attempt in: %s, %08lx-%08lx %08lx\n", NIPQUAD(tsk->signal->curr_ip), path_fault, start, end, offset);
+	else
+		printk(KERN_ERR "PAX: execution attempt in: %s, %08lx-%08lx %08lx\n", path_fault, start, end, offset);
+	printk(KERN_ERR "PAX: terminating task: %s(%s):%d, uid/euid: %u/%u, "
+			"PC: %p, SP: %p\n", path_exec, tsk->comm, tsk->pid,
+			tsk->uid, tsk->euid, pc, sp);
+	free_page((unsigned long)buffer_exec);
+	free_page((unsigned long)buffer_fault);
+	pax_report_insns(pc, sp);
+	do_coredump(SIGKILL, SIGKILL, regs);
+}
+#endif
+
 static void zap_threads (struct mm_struct *mm)
 {
 	struct task_struct *g, *p;
@@ -1486,6 +1741,10 @@
 	current->signal->group_stop_count = 0;
 	clear_thread_flag(TIF_SIGPENDING);
 
+	if (signr == SIGKILL || signr == SIGILL)
+		gr_handle_brute_attach(current);
+
+	gr_learn_resource(current, RLIMIT_CORE, binfmt->min_coredump, 1);
 	if (current->signal->rlim[RLIMIT_CORE].rlim_cur < binfmt->min_coredump)
 		goto fail_unlock;
 
@@ -1511,7 +1770,7 @@
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
-	if (do_truncate(file->f_dentry, 0) != 0)
+	if (do_truncate(file->f_dentry, 0, file->f_vfsmnt) != 0)
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);
diff -Nur linux-2.6.13.1.org/fs/fcntl.c grsecurity226/fs/fcntl.c
--- linux-2.6.13.1.org/fs/fcntl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/fcntl.c	2005-08-30 01:14:18.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/security.h>
 #include <linux/ptrace.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <asm/poll.h>
 #include <asm/siginfo.h>
@@ -56,6 +57,7 @@
 	int error;
 
 	error = -EINVAL;
+	gr_learn_resource(current, RLIMIT_NOFILE, orig_start, 0);
 	if (orig_start >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
@@ -75,6 +77,7 @@
 	}
 	
 	error = -EMFILE;
+	gr_learn_resource(current, RLIMIT_NOFILE, newfd, 0);
 	if (newfd >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
@@ -124,6 +127,8 @@
 	struct file * file, *tofree;
 	struct files_struct * files = current->files;
 
+	gr_learn_resource(current, RLIMIT_NOFILE, newfd, 0);
+
 	spin_lock(&files->file_lock);
 	if (!(file = fcheck(oldfd)))
 		goto out_unlock;
@@ -406,7 +411,8 @@
 	return (((fown->euid == 0) ||
 		 (fown->euid == p->suid) || (fown->euid == p->uid) ||
 		 (fown->uid == p->suid) || (fown->uid == p->uid)) &&
-		!security_file_send_sigiotask(p, fown, sig));
+		!security_file_send_sigiotask(p, fown, sig) &&
+		!gr_check_protected_task(p) && !gr_pid_is_chrooted(p));
 }
 
 static void send_sigio_to_task(struct task_struct *p,
diff -Nur linux-2.6.13.1.org/fs/jffs/Makefile grsecurity226/fs/jffs/Makefile
--- linux-2.6.13.1.org/fs/jffs/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs/Makefile	2005-08-30 01:00:36.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Makefile for the linux Journalling Flash FileSystem (JFFS) routines.
 #
-# $Id$
+# $Id$
 #
 
 obj-$(CONFIG_JFFS_FS) += jffs.o
diff -Nur linux-2.6.13.1.org/fs/jffs/inode-v23.c grsecurity226/fs/jffs/inode-v23.c
--- linux-2.6.13.1.org/fs/jffs/inode-v23.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs/inode-v23.c	2005-08-30 01:00:36.000000000 +0200
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id$
+ * $Id$
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
diff -Nur linux-2.6.13.1.org/fs/jffs/intrep.c grsecurity226/fs/jffs/intrep.c
--- linux-2.6.13.1.org/fs/jffs/intrep.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs/intrep.c	2005-08-30 01:00:36.000000000 +0200
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id$
+ * $Id$
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
diff -Nur linux-2.6.13.1.org/fs/jffs/intrep.h grsecurity226/fs/jffs/intrep.h
--- linux-2.6.13.1.org/fs/jffs/intrep.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs/intrep.h	2005-08-30 01:00:36.000000000 +0200
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs/jffs_fm.c grsecurity226/fs/jffs/jffs_fm.c
--- linux-2.6.13.1.org/fs/jffs/jffs_fm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs/jffs_fm.c	2005-08-30 01:00:36.000000000 +0200
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id$
+ * $Id$
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
diff -Nur linux-2.6.13.1.org/fs/jffs/jffs_fm.h grsecurity226/fs/jffs/jffs_fm.h
--- linux-2.6.13.1.org/fs/jffs/jffs_fm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs/jffs_fm.h	2005-08-30 01:00:36.000000000 +0200
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id$
+ * $Id$
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
diff -Nur linux-2.6.13.1.org/fs/jffs/jffs_proc.c grsecurity226/fs/jffs/jffs_proc.c
--- linux-2.6.13.1.org/fs/jffs/jffs_proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs/jffs_proc.c	2005-08-30 01:00:36.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * Created by Simon Kagstrom <simonk@axis.com>.
  *
- * $Id$
+ * $Id$
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by
diff -Nur linux-2.6.13.1.org/fs/jffs/jffs_proc.h grsecurity226/fs/jffs/jffs_proc.h
--- linux-2.6.13.1.org/fs/jffs/jffs_proc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs/jffs_proc.h	2005-08-30 01:00:36.000000000 +0200
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id$
+ * $Id$
  */
 
 /* jffs_proc.h defines a structure for inclusion in the proc-file system.  */
diff -Nur linux-2.6.13.1.org/fs/jffs2/LICENCE grsecurity226/fs/jffs2/LICENCE
--- linux-2.6.13.1.org/fs/jffs2/LICENCE	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/LICENCE	2005-08-30 01:00:36.000000000 +0200
@@ -32,4 +32,4 @@
 http://sources.redhat.com/jffs2/jffs2-licence.html
 
 
-	$Id$
+	$Id$
diff -Nur linux-2.6.13.1.org/fs/jffs2/Makefile grsecurity226/fs/jffs2/Makefile
--- linux-2.6.13.1.org/fs/jffs2/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/Makefile	2005-08-30 01:00:36.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Makefile for the Linux Journalling Flash File System v2 (JFFS2)
 #
-# $Id$
+# $Id$
 #
 
 obj-$(CONFIG_JFFS2_FS) += jffs2.o
diff -Nur linux-2.6.13.1.org/fs/jffs2/README.Locking grsecurity226/fs/jffs2/README.Locking
--- linux-2.6.13.1.org/fs/jffs2/README.Locking	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/README.Locking	2005-08-30 01:00:36.000000000 +0200
@@ -1,4 +1,4 @@
-	$Id$
+	$Id$
 
 	JFFS2 LOCKING DOCUMENTATION
 	---------------------------
diff -Nur linux-2.6.13.1.org/fs/jffs2/TODO grsecurity226/fs/jffs2/TODO
--- linux-2.6.13.1.org/fs/jffs2/TODO	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/TODO	2005-08-30 01:00:36.000000000 +0200
@@ -1,4 +1,4 @@
-$Id$
+$Id$
 
  - disable compression in commit_write()?
  - fine-tune the allocation / GC thresholds
diff -Nur linux-2.6.13.1.org/fs/jffs2/background.c grsecurity226/fs/jffs2/background.c
--- linux-2.6.13.1.org/fs/jffs2/background.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/background.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/build.c grsecurity226/fs/jffs2/build.c
--- linux-2.6.13.1.org/fs/jffs2/build.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/build.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/compr.c grsecurity226/fs/jffs2/compr.c
--- linux-2.6.13.1.org/fs/jffs2/compr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/compr.c	2005-08-30 01:00:36.000000000 +0200
@@ -9,7 +9,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/compr.h grsecurity226/fs/jffs2/compr.h
--- linux-2.6.13.1.org/fs/jffs2/compr.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/compr.h	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  * For licensing information, see the file 'LICENCE' in the 
  * jffs2 directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/compr_rtime.c grsecurity226/fs/jffs2/compr_rtime.c
--- linux-2.6.13.1.org/fs/jffs2/compr_rtime.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/compr_rtime.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  *
  * Very simple lz77-ish encoder.
diff -Nur linux-2.6.13.1.org/fs/jffs2/compr_rubin.c grsecurity226/fs/jffs2/compr_rubin.c
--- linux-2.6.13.1.org/fs/jffs2/compr_rubin.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/compr_rubin.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/compr_rubin.h grsecurity226/fs/jffs2/compr_rubin.h
--- linux-2.6.13.1.org/fs/jffs2/compr_rubin.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/compr_rubin.h	2005-08-30 01:00:36.000000000 +0200
@@ -1,7 +1,7 @@
 /* Rubin encoder/decoder header       */
 /* work started at   : aug   3, 1994  */
 /* last modification : aug  15, 1994  */
-/* $Id$ */
+/* $Id$ */
 
 #include "pushpull.h"
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/compr_zlib.c grsecurity226/fs/jffs2/compr_zlib.c
--- linux-2.6.13.1.org/fs/jffs2/compr_zlib.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/compr_zlib.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/comprtest.c grsecurity226/fs/jffs2/comprtest.c
--- linux-2.6.13.1.org/fs/jffs2/comprtest.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/comprtest.c	2005-08-30 01:00:36.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/kernel.h>
 #include <linux/string.h>
diff -Nur linux-2.6.13.1.org/fs/jffs2/dir.c grsecurity226/fs/jffs2/dir.c
--- linux-2.6.13.1.org/fs/jffs2/dir.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/dir.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/erase.c grsecurity226/fs/jffs2/erase.c
--- linux-2.6.13.1.org/fs/jffs2/erase.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/erase.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/file.c grsecurity226/fs/jffs2/file.c
--- linux-2.6.13.1.org/fs/jffs2/file.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/file.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/fs.c grsecurity226/fs/jffs2/fs.c
--- linux-2.6.13.1.org/fs/jffs2/fs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/fs.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/gc.c grsecurity226/fs/jffs2/gc.c
--- linux-2.6.13.1.org/fs/jffs2/gc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/gc.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/ioctl.c grsecurity226/fs/jffs2/ioctl.c
--- linux-2.6.13.1.org/fs/jffs2/ioctl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/ioctl.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/malloc.c grsecurity226/fs/jffs2/malloc.c
--- linux-2.6.13.1.org/fs/jffs2/malloc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/malloc.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/nodelist.c grsecurity226/fs/jffs2/nodelist.c
--- linux-2.6.13.1.org/fs/jffs2/nodelist.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/nodelist.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/nodelist.h grsecurity226/fs/jffs2/nodelist.h
--- linux-2.6.13.1.org/fs/jffs2/nodelist.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/nodelist.h	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/nodemgmt.c grsecurity226/fs/jffs2/nodemgmt.c
--- linux-2.6.13.1.org/fs/jffs2/nodemgmt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/nodemgmt.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/os-linux.h grsecurity226/fs/jffs2/os-linux.h
--- linux-2.6.13.1.org/fs/jffs2/os-linux.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/os-linux.h	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/pushpull.h grsecurity226/fs/jffs2/pushpull.h
--- linux-2.6.13.1.org/fs/jffs2/pushpull.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/pushpull.h	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/read.c grsecurity226/fs/jffs2/read.c
--- linux-2.6.13.1.org/fs/jffs2/read.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/read.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/readinode.c grsecurity226/fs/jffs2/readinode.c
--- linux-2.6.13.1.org/fs/jffs2/readinode.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/readinode.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/scan.c grsecurity226/fs/jffs2/scan.c
--- linux-2.6.13.1.org/fs/jffs2/scan.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/scan.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 #include <linux/kernel.h>
diff -Nur linux-2.6.13.1.org/fs/jffs2/super.c grsecurity226/fs/jffs2/super.c
--- linux-2.6.13.1.org/fs/jffs2/super.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/super.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/symlink.c grsecurity226/fs/jffs2/symlink.c
--- linux-2.6.13.1.org/fs/jffs2/symlink.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/symlink.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/wbuf.c grsecurity226/fs/jffs2/wbuf.c
--- linux-2.6.13.1.org/fs/jffs2/wbuf.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/wbuf.c	2005-08-30 01:00:36.000000000 +0200
@@ -9,7 +9,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/write.c grsecurity226/fs/jffs2/write.c
--- linux-2.6.13.1.org/fs/jffs2/write.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/write.c	2005-08-30 01:00:36.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/jffs2/writev.c grsecurity226/fs/jffs2/writev.c
--- linux-2.6.13.1.org/fs/jffs2/writev.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/jffs2/writev.c	2005-08-30 01:00:37.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/fs/namei.c grsecurity226/fs/namei.c
--- linux-2.6.13.1.org/fs/namei.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/namei.c	2005-08-30 01:14:18.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/syscalls.h>
 #include <linux/mount.h>
 #include <linux/audit.h>
+#include <linux/grsecurity.h>
 #include <asm/namei.h>
 #include <asm/uaccess.h>
 
@@ -544,6 +545,13 @@
 	err = security_inode_follow_link(path->dentry, nd);
 	if (err)
 		goto loop;
+
+	if (gr_handle_follow_link(path->dentry->d_parent->d_inode,
+				  path->dentry->d_inode, path->dentry, nd->mnt)) {
+		err = -EACCES;
+		goto loop;
+	}
+
 	current->link_count++;
 	current->total_link_count++;
 	nd->depth++;
@@ -899,6 +907,10 @@
 				break;
 		}
 return_base:
+		if (!gr_acl_handle_hidden_file(nd->dentry, nd->mnt)) {
+			path_release(nd);
+			return -ENOENT;
+		}
 		return 0;
 out_dput:
 		dput(next.dentry);
@@ -906,6 +918,9 @@
 			mntput(next.mnt);
 		break;
 	}
+	if (!gr_acl_handle_hidden_file(nd->dentry, nd->mnt))
+		err = -ENOENT;
+
 	path_release(nd);
 return_err:
 	return err;
@@ -1388,7 +1403,7 @@
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0);
+			error = do_truncate(dentry, 0, nd->mnt);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1439,6 +1454,17 @@
 		error = path_lookup(pathname, lookup_flags(flag)|LOOKUP_OPEN, nd);
 		if (error)
 			return error;
+
+		if (gr_handle_rawio(nd->dentry->d_inode)) {
+			error = -EPERM;
+			goto exit;
+		}
+
+		if (!gr_acl_handle_open(nd->dentry, nd->mnt, flag)) {
+			error = -EACCES;
+			goto exit;
+		}
+
 		goto ok;
 	}
 
@@ -1473,9 +1499,18 @@
 
 	/* Negative dentry, just create the file */
 	if (!path.dentry->d_inode) {
+		if (!gr_acl_handle_creat(path.dentry, nd->dentry, nd->mnt, flag, mode)) {
+			error = -EACCES;
+			up(&dir->d_inode->i_sem);
+			goto exit_dput;
+		}
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
+
+		if (!error)
+			gr_handle_create(path.dentry, nd->mnt);
+
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
 		nd->dentry = path.dentry;
@@ -1490,6 +1525,25 @@
 	/*
 	 * It already exists.
 	 */
+
+	if (gr_handle_rawio(path.dentry->d_inode)) {
+		error = -EPERM;
+		up(&dir->d_inode->i_sem);
+		goto exit_dput;
+	}
+
+	if (!gr_acl_handle_open(path.dentry, nd->mnt, flag)) {
+		up(&dir->d_inode->i_sem);
+		error = -EACCES;
+		goto exit_dput;
+	}
+
+	if (gr_handle_fifo(path.dentry, nd->mnt, dir, flag, acc_mode)) {
+		up(&dir->d_inode->i_sem);
+		error = -EACCES;
+		goto exit_dput;
+	}
+
 	up(&dir->d_inode->i_sem);
 
 	error = -EEXIST;
@@ -1547,6 +1601,13 @@
 	error = security_inode_follow_link(path.dentry, nd);
 	if (error)
 		goto exit_dput;
+
+	if (gr_handle_follow_link(path.dentry->d_parent->d_inode, path.dentry->d_inode,
+				  path.dentry, nd->mnt)) {
+		error = -EACCES;
+		goto exit_dput;
+	}
+
 	error = __do_follow_link(&path, nd);
 	if (error)
 		return error;
@@ -1668,6 +1729,22 @@
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		if (gr_handle_chroot_mknod(dentry, nd.mnt, mode)) {
+			error = -EPERM;
+			dput(dentry);
+			up(&nd.dentry->d_inode->i_sem);
+			path_release(&nd);
+			goto out;
+		}
+
+		if (!gr_acl_handle_mknod(dentry, nd.dentry, nd.mnt, mode)) {
+			error = -EACCES;
+			dput(dentry);
+			up(&nd.dentry->d_inode->i_sem);
+			path_release(&nd);
+			goto out;
+		}
+
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
@@ -1685,6 +1762,10 @@
 		default:
 			error = -EINVAL;
 		}
+
+		if (!error)
+			gr_handle_create(dentry, nd.mnt);
+
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1736,9 +1817,19 @@
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
+			error = 0;
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
-			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
+
+			if (!gr_acl_handle_mkdir(dentry, nd.dentry, nd.mnt))
+				error = -EACCES;
+
+			if (!error)
+				error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
+
+			if (!error)
+				gr_handle_create(dentry, nd.mnt);
+
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1817,6 +1908,8 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	ino_t saved_ino = 0;
+	dev_t saved_dev = 0;
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1841,7 +1934,21 @@
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
-		error = vfs_rmdir(nd.dentry->d_inode, dentry);
+		error = 0;
+		if (dentry->d_inode) {
+			if (dentry->d_inode->i_nlink <= 1) {
+				saved_ino = dentry->d_inode->i_ino;
+				saved_dev = dentry->d_inode->i_sb->s_dev;
+			}
+
+			if (!gr_acl_handle_rmdir(dentry, nd.mnt))
+				error = -EACCES;
+		}
+
+		if (!error)
+			error = vfs_rmdir(nd.dentry->d_inode, dentry);
+		if (!error && (saved_dev || saved_ino))
+			gr_handle_delete(saved_ino, saved_dev);
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1895,6 +2002,8 @@
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
+	ino_t saved_ino = 0;
+	dev_t saved_dev = 0;
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1910,13 +2019,26 @@
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
+		error = 0;
 		/* Why not before? Because we want correct error value */
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		inode = dentry->d_inode;
-		if (inode)
+		if (inode) {
+			if (inode->i_nlink <= 1) {
+				saved_ino = inode->i_ino;
+				saved_dev = inode->i_sb->s_dev;
+			}
+
+			if (!gr_acl_handle_unlink(dentry, nd.mnt))
+				error = -EACCES;
+
 			atomic_inc(&inode->i_count);
-		error = vfs_unlink(nd.dentry->d_inode, dentry);
+		}
+		if (!error)
+			error = vfs_unlink(nd.dentry->d_inode, dentry);
+		if (!error && (saved_ino || saved_dev))
+			gr_handle_delete(saved_ino, saved_dev);
 	exit2:
 		dput(dentry);
 	}
@@ -1979,7 +2101,15 @@
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
-			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
+			error = 0;
+			if (!gr_acl_handle_symlink(dentry, nd.dentry, nd.mnt, from))
+				error = -EACCES;
+
+			if (!error)
+				error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
+
+			if (!error)
+				gr_handle_create(dentry, nd.mnt);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -2063,7 +2193,20 @@
 	new_dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
-		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
+		error = 0;
+		if (gr_handle_hardlink(old_nd.dentry, old_nd.mnt,
+				       old_nd.dentry->d_inode,
+				       old_nd.dentry->d_inode->i_mode, to))
+			error = -EPERM;
+		if (!gr_acl_handle_link(new_dentry, nd.dentry, nd.mnt,
+					old_nd.dentry, old_nd.mnt, to))
+			error = -EACCES;
+		if (!error)
+			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
+
+		if (!error)
+			gr_handle_create(new_dentry, nd.mnt);
+
 		dput(new_dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -2287,8 +2430,16 @@
 	if (new_dentry == trap)
 		goto exit5;
 
-	error = vfs_rename(old_dir->d_inode, old_dentry,
+	error = gr_acl_handle_rename(new_dentry, newnd.dentry, newnd.mnt,
+				     old_dentry, old_dir->d_inode, oldnd.mnt,
+				     newname);
+
+	if (!error)
+		error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
+	if (!error)
+		gr_handle_rename(old_dir->d_inode, newnd.dentry->d_inode, old_dentry, 
+				 new_dentry, oldnd.mnt, new_dentry->d_inode ? 1 : 0);
 exit5:
 	dput(new_dentry);
 exit4:
diff -Nur linux-2.6.13.1.org/fs/namespace.c grsecurity226/fs/namespace.c
--- linux-2.6.13.1.org/fs/namespace.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/namespace.c	2005-08-30 01:14:18.000000000 +0200
@@ -22,6 +22,8 @@
 #include <linux/namei.h>
 #include <linux/security.h>
 #include <linux/mount.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
@@ -427,6 +429,8 @@
 			DQUOT_OFF(sb);
 			retval = do_remount_sb(sb, MS_RDONLY, NULL, 0);
 			unlock_kernel();
+
+			gr_log_remount(mnt->mnt_devname, retval);
 		}
 		up_write(&sb->s_umount);
 		return retval;
@@ -455,6 +459,9 @@
 	if (retval)
 		security_sb_umount_busy(mnt);
 	up_write(&current->namespace->sem);
+
+	gr_log_unmount(mnt->mnt_devname, retval);
+
 	return retval;
 }
 
@@ -1052,6 +1059,11 @@
 	if (retval)
 		goto dput_out;
 
+	if (gr_handle_chroot_mount(nd.dentry, nd.mnt, dev_name)) {
+		retval = -EPERM;
+		goto dput_out;
+	}
+
 	if (flags & MS_REMOUNT)
 		retval = do_remount(&nd, flags & ~MS_REMOUNT, mnt_flags,
 				    data_page);
@@ -1064,6 +1076,9 @@
 				      dev_name, data_page);
 dput_out:
 	path_release(&nd);
+
+	gr_log_mount(dev_name, dir_name, retval);
+
 	return retval;
 }
 
@@ -1293,6 +1308,9 @@
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+	if (gr_handle_chroot_pivot())
+		return -EPERM;
+
 	lock_kernel();
 
 	error = __user_walk(new_root, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd);
diff -Nur linux-2.6.13.1.org/fs/nfs/nfsroot.c grsecurity226/fs/nfs/nfsroot.c
--- linux-2.6.13.1.org/fs/nfs/nfsroot.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/nfs/nfsroot.c	2005-08-30 01:00:38.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *  $Id$
+ *  $Id$
  *
  *  Copyright (C) 1995, 1996  Gero Kuhlmann <gero@gkminix.han.de>
  *
diff -Nur linux-2.6.13.1.org/fs/open.c grsecurity226/fs/open.c
--- linux-2.6.13.1.org/fs/open.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/open.c	2005-08-30 01:14:18.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/personality.h>
 #include <linux/pagemap.h>
 #include <linux/syscalls.h>
+#include <linux/grsecurity.h>
 
 #include <asm/unistd.h>
 
@@ -193,7 +194,7 @@
 	return error;
 }
 
-int do_truncate(struct dentry *dentry, loff_t length)
+int do_truncate(struct dentry *dentry, loff_t length, struct vfsmount *mnt)
 {
 	int err;
 	struct iattr newattrs;
@@ -202,6 +203,9 @@
 	if (length < 0)
 		return -EINVAL;
 
+	if (!gr_acl_handle_truncate(dentry, mnt))
+		return -EACCES;
+
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
 
@@ -261,7 +265,7 @@
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length);
+		error = do_truncate(nd.dentry, length, nd.mnt);
 	}
 	put_write_access(inode);
 
@@ -313,7 +317,7 @@
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length);
+		error = do_truncate(dentry, length, file->f_vfsmnt);
 out_putf:
 	fput(file);
 out:
@@ -392,6 +396,11 @@
 		    (error = permission(inode,MAY_WRITE,&nd)) != 0)
 			goto dput_and_out;
 	}
+	if (!gr_acl_handle_utime(nd.dentry, nd.mnt)) {
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	down(&inode->i_sem);
 	error = notify_change(nd.dentry, &newattrs);
 	up(&inode->i_sem);
@@ -445,6 +454,12 @@
 		    (error = permission(inode,MAY_WRITE,&nd)) != 0)
 			goto dput_and_out;
 	}
+
+	if (!gr_acl_handle_utime(nd.dentry, nd.mnt)) {
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	down(&inode->i_sem);
 	error = notify_change(nd.dentry, &newattrs);
 	up(&inode->i_sem);
@@ -506,6 +521,10 @@
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+
+		if (!res && !gr_acl_handle_access(nd.dentry, nd.mnt, mode))
+			res = -EACCES;
+
 		path_release(&nd);
 	}
 
@@ -529,6 +548,8 @@
 	if (error)
 		goto dput_and_out;
 
+	gr_log_chdir(nd.dentry, nd.mnt);
+
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
@@ -559,6 +580,13 @@
 		goto out_putf;
 
 	error = permission(inode, MAY_EXEC, NULL);
+
+	if (!error && !gr_chroot_fchdir(dentry, mnt))
+		error = -EPERM;
+
+	if (!error)
+		gr_log_chdir(dentry, mnt);
+
 	if (!error)
 		set_fs_pwd(current->fs, mnt, dentry);
 out_putf:
@@ -584,8 +612,16 @@
 	if (!capable(CAP_SYS_CHROOT))
 		goto dput_and_out;
 
+	if (gr_handle_chroot_chroot(nd.dentry, nd.mnt))
+		goto dput_and_out;
+
 	set_fs_root(current->fs, nd.mnt, nd.dentry);
 	set_fs_altroot();
+
+	gr_handle_chroot_caps(current);
+
+	gr_handle_chroot_chdir(nd.dentry, nd.mnt);
+
 	error = 0;
 dput_and_out:
 	path_release(&nd);
@@ -614,9 +650,22 @@
 	err = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out_putf;
+
+	if (!gr_acl_handle_fchmod(dentry, file->f_vfsmnt, mode)) {
+		err = -EACCES;
+		goto out_putf;
+	}
+
 	down(&inode->i_sem);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
+
+	if (gr_handle_chroot_chmod(dentry, file->f_vfsmnt, mode)) {
+		err = -EPERM;
+		up(&inode->i_sem);
+		goto out_putf;
+	}
+
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	err = notify_change(dentry, &newattrs);
@@ -648,9 +697,21 @@
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
 
+	if (!gr_acl_handle_chmod(nd.dentry, nd.mnt, mode)) {
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	down(&inode->i_sem);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
+
+	if (gr_handle_chroot_chmod(nd.dentry, nd.mnt, mode)) {
+		error = -EACCES;
+		up(&inode->i_sem);
+		goto dput_and_out;
+	}
+
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	error = notify_change(nd.dentry, &newattrs);
@@ -662,7 +723,7 @@
 	return error;
 }
 
-static int chown_common(struct dentry * dentry, uid_t user, gid_t group)
+static int chown_common(struct dentry * dentry, uid_t user, gid_t group, struct vfsmount *mnt)
 {
 	struct inode * inode;
 	int error;
@@ -679,6 +740,12 @@
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
+
+	if (!gr_acl_handle_chown(dentry, mnt)) {
+		error = -EACCES;
+		goto out;
+	}
+
 	newattrs.ia_valid =  ATTR_CTIME;
 	if (user != (uid_t) -1) {
 		newattrs.ia_valid |= ATTR_UID;
@@ -704,7 +771,7 @@
 
 	error = user_path_walk(filename, &nd);
 	if (!error) {
-		error = chown_common(nd.dentry, user, group);
+		error = chown_common(nd.dentry, user, group, nd.mnt);
 		path_release(&nd);
 	}
 	return error;
@@ -717,7 +784,7 @@
 
 	error = user_path_walk_link(filename, &nd);
 	if (!error) {
-		error = chown_common(nd.dentry, user, group);
+		error = chown_common(nd.dentry, user, group, nd.mnt);
 		path_release(&nd);
 	}
 	return error;
@@ -731,7 +798,8 @@
 
 	file = fget(fd);
 	if (file) {
-		error = chown_common(file->f_dentry, user, group);
+		error = chown_common(file->f_dentry, user,
+				     group, file->f_vfsmnt);
 		fput(file);
 	}
 	return error;
@@ -855,6 +923,7 @@
 	 * N.B. For clone tasks sharing a files structure, this test
 	 * will limit the total number of files that can be opened.
 	 */
+	gr_learn_resource(current, RLIMIT_NOFILE, fd, 0);
 	if (fd >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
diff -Nur linux-2.6.13.1.org/fs/openpromfs/inode.c grsecurity226/fs/openpromfs/inode.c
--- linux-2.6.13.1.org/fs/openpromfs/inode.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/openpromfs/inode.c	2005-08-30 01:00:39.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * openpromfs.c: /proc/openprom handling routines
  *
  * Copyright (C) 1996-1999 Jakub Jelinek  (jakub@redhat.com)
diff -Nur linux-2.6.13.1.org/fs/proc/array.c grsecurity226/fs/proc/array.c
--- linux-2.6.13.1.org/fs/proc/array.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/proc/array.c	2005-08-30 01:14:21.000000000 +0200
@@ -287,6 +287,21 @@
 			    cap_t(p->cap_effective));
 }
 
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline char *task_pax(struct task_struct *p, char *buffer)
+{
+	if (p->mm)
+		return buffer + sprintf(buffer, "PaX:\t%c%c%c%c%c\n",
+				p->mm->pax_flags & MF_PAX_PAGEEXEC ? 'P' : 'p',
+				p->mm->pax_flags & MF_PAX_EMUTRAMP ? 'E' : 'e',
+				p->mm->pax_flags & MF_PAX_MPROTECT ? 'M' : 'm',
+				p->mm->pax_flags & MF_PAX_RANDMMAP ? 'R' : 'r',
+				p->mm->pax_flags & MF_PAX_SEGMEXEC ? 'S' : 's');
+	else
+		return buffer + sprintf(buffer, "PaX:\t-----\n");
+}
+#endif
+
 int proc_pid_status(struct task_struct *task, char * buffer)
 {
 	char * orig = buffer;
@@ -305,9 +320,19 @@
 #if defined(CONFIG_ARCH_S390)
 	buffer = task_show_regs(task, buffer);
 #endif
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	buffer = task_pax(task, buffer);
+#endif
+
 	return buffer - orig;
 }
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+#define PAX_RAND_FLAGS (task->mm && (task->mm->pax_flags & MF_PAX_RANDMMAP || \
+			task->mm->pax_flags & MF_PAX_SEGMEXEC))
+#endif
+
 static int do_task_stat(struct task_struct *task, char * buffer, int whole)
 {
 	unsigned long vsize, eip, esp, wchan = ~0UL;
@@ -394,6 +419,19 @@
 		stime = task->stime;
 	}
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	if (PAX_RAND_FLAGS) {
+		eip = 0;
+		esp = 0;
+		wchan = 0;
+	}
+#endif
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	wchan = 0;
+	eip =0;
+	esp =0;
+#endif
+
 	/* scale priority and nice values from timeslices to -20..20 */
 	/* to make it look like a "normal" Unix priority/nice value  */
 	priority = task_prio(task);
@@ -434,9 +472,15 @@
 		vsize,
 		mm ? get_mm_counter(mm, rss) : 0, /* you might want to shift this left 3 */
 	        rsslim,
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+		PAX_RAND_FLAGS ? 0 : (mm ? mm->start_code : 0),
+		PAX_RAND_FLAGS ? 0 : (mm ? mm->end_code : 0),
+		PAX_RAND_FLAGS ? 0 : (mm ? mm->start_stack : 0),
+#else
 		mm ? mm->start_code : 0,
 		mm ? mm->end_code : 0,
 		mm ? mm->start_stack : 0,
+#endif
 		esp,
 		eip,
 		/* The signal information here is obsolete.
@@ -482,3 +526,14 @@
 	return sprintf(buffer,"%d %d %d %d %d %d %d\n",
 		       size, resident, shared, text, lib, data, 0);
 }
+
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+int proc_pid_ipaddr(struct task_struct *task, char * buffer)
+{
+	int len;
+
+	len = sprintf(buffer, "%u.%u.%u.%u\n", NIPQUAD(task->signal->curr_ip));
+	return len;
+}
+#endif
+
diff -Nur linux-2.6.13.1.org/fs/proc/base.c grsecurity226/fs/proc/base.c
--- linux-2.6.13.1.org/fs/proc/base.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/proc/base.c	2005-08-30 01:14:21.000000000 +0200
@@ -35,6 +35,7 @@
 #include <linux/seccomp.h>
 #include <linux/cpuset.h>
 #include <linux/audit.h>
+#include <linux/grsecurity.h>
 #include "internal.h"
 
 /*
@@ -83,6 +84,9 @@
 #ifdef CONFIG_AUDITSYSCALL
 	PROC_TGID_LOGINUID,
 #endif
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+	PROC_TGID_IPADDR,
+#endif
 	PROC_TGID_FD_DIR,
 	PROC_TGID_OOM_SCORE,
 	PROC_TGID_OOM_ADJUST,
@@ -152,6 +156,9 @@
 	E(PROC_TGID_ROOT,      "root",    S_IFLNK|S_IRWXUGO),
 	E(PROC_TGID_EXE,       "exe",     S_IFLNK|S_IRWXUGO),
 	E(PROC_TGID_MOUNTS,    "mounts",  S_IFREG|S_IRUGO),
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+	E(PROC_TGID_IPADDR,     "ipaddr",  S_IFREG|S_IRUSR),
+#endif
 #ifdef CONFIG_SECURITY
 	E(PROC_TGID_ATTR,      "attr",    S_IFDIR|S_IRUGO|S_IXUGO),
 #endif
@@ -296,7 +303,7 @@
 	(task->parent == current && \
 	(task->ptrace & PT_PTRACED) && \
 	 (task->state == TASK_STOPPED || task->state == TASK_TRACED) && \
-	 security_ptrace(current,task) == 0))
+	 security_ptrace(current,task) == 0 && !gr_handle_proc_ptrace(task)))
 
 static int may_ptrace_attach(struct task_struct *task)
 {
@@ -311,10 +318,10 @@
 	     (current->uid != task->uid) ||
 	     (current->gid != task->egid) ||
 	     (current->gid != task->sgid) ||
-	     (current->gid != task->gid)) && !capable(CAP_SYS_PTRACE))
+	     (current->gid != task->gid)) && !capable_nolog(CAP_SYS_PTRACE))
 		goto out;
 	rmb();
-	if (task->mm->dumpable != 1 && !capable(CAP_SYS_PTRACE))
+	if (task->mm->dumpable != 1 && !capable_nolog(CAP_SYS_PTRACE))
 		goto out;
 	if (security_ptrace(current, task))
 		goto out;
@@ -491,9 +498,25 @@
 
 static int proc_permission(struct inode *inode, int mask, struct nameidata *nd)
 {
+	int ret = -EACCES;
+	struct task_struct *task;
+
 	if (generic_permission(inode, mask, NULL) != 0)
-		return -EACCES;
-	return proc_check_root(inode);
+		goto out;
+
+	ret = proc_check_root(inode);
+	if (ret)
+		goto out;
+
+	task = proc_task(inode);
+
+	if (!task)
+		goto out;
+
+	ret = gr_acl_handle_procpidmem(task);
+
+out:
+	return ret;
 }
 
 extern struct seq_operations proc_pid_maps_op;
@@ -1151,6 +1174,9 @@
 		inode->i_uid = task->euid;
 		inode->i_gid = task->egid;
 	}
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+	inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#endif
 	security_task_to_inode(task, inode);
 
 out:
@@ -1179,7 +1205,9 @@
 	if (pid_alive(task)) {
 		if (proc_type(inode) == PROC_TGID_INO || proc_type(inode) == PROC_TID_INO || task_dumpable(task)) {
 			inode->i_uid = task->euid;
+#ifndef CONFIG_GRKERNSEC_PROC_USERGROUP
 			inode->i_gid = task->egid;
+#endif
 		} else {
 			inode->i_uid = 0;
 			inode->i_gid = 0;
@@ -1502,6 +1530,12 @@
 			inode->i_fop = &proc_info_file_operations;
 			ei->op.proc_read = proc_pid_status;
 			break;
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+		case PROC_TGID_IPADDR:
+			inode->i_fop = &proc_info_file_operations;
+			ei->op.proc_read = proc_pid_ipaddr;
+			break;
+#endif
 		case PROC_TID_STAT:
 			inode->i_fop = &proc_info_file_operations;
 			ei->op.proc_read = proc_tid_stat;
@@ -1794,6 +1828,22 @@
 	if (!task)
 		goto out;
 
+	if (gr_check_hidden_task(task)) {
+		put_task_struct(task);
+		goto out;
+	}
+
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	if (current->uid && (task->uid != current->uid)
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+	    && !in_group_p(CONFIG_GRKERNSEC_PROC_GID)
+#endif
+	) {
+		put_task_struct(task);
+		goto out;
+	}
+#endif
+
 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_TGID_INO);
 
 
@@ -1801,7 +1851,15 @@
 		put_task_struct(task);
 		goto out;
 	}
+
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR;
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP;
+	inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#else
 	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
+#endif
 	inode->i_op = &proc_tgid_base_inode_operations;
 	inode->i_fop = &proc_tgid_base_operations;
 	inode->i_flags|=S_IMMUTABLE;
@@ -1893,6 +1951,9 @@
 static int get_tgid_list(int index, unsigned long version, unsigned int *tgids)
 {
 	struct task_struct *p;
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	struct task_struct *tmp = current;
+#endif
 	int nr_tgids = 0;
 
 	index--;
@@ -1913,6 +1974,18 @@
 		int tgid = p->pid;
 		if (!pid_alive(p))
 			continue;
+		if (gr_pid_is_chrooted(p))
+			continue;
+		if (gr_check_hidden_task(p))
+			continue;
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+		if (tmp->uid && (p->uid != tmp->uid)
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+		    && !in_group_p(CONFIG_GRKERNSEC_PROC_GID)
+#endif
+		)
+			continue;
+#endif
 		if (--index >= 0)
 			continue;
 		tgids[nr_tgids] = tgid;
diff -Nur linux-2.6.13.1.org/fs/proc/inode.c grsecurity226/fs/proc/inode.c
--- linux-2.6.13.1.org/fs/proc/inode.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/proc/inode.c	2005-08-30 01:14:21.000000000 +0200
@@ -163,7 +163,11 @@
 		if (de->mode) {
 			inode->i_mode = de->mode;
 			inode->i_uid = de->uid;
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+			inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#else
 			inode->i_gid = de->gid;
+#endif
 		}
 		if (de->size)
 			inode->i_size = de->size;
diff -Nur linux-2.6.13.1.org/fs/proc/internal.h grsecurity226/fs/proc/internal.h
--- linux-2.6.13.1.org/fs/proc/internal.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/proc/internal.h	2005-08-30 01:14:21.000000000 +0200
@@ -36,6 +36,9 @@
 extern int proc_tgid_stat(struct task_struct *, char *);
 extern int proc_pid_status(struct task_struct *, char *);
 extern int proc_pid_statm(struct task_struct *, char *);
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+extern int proc_pid_ipaddr(struct task_struct*,char*);
+#endif
 
 static inline struct task_struct *proc_task(struct inode *inode)
 {
diff -Nur linux-2.6.13.1.org/fs/proc/proc_misc.c grsecurity226/fs/proc/proc_misc.c
--- linux-2.6.13.1.org/fs/proc/proc_misc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/proc/proc_misc.c	2005-08-30 01:14:21.000000000 +0200
@@ -566,6 +566,8 @@
 void __init proc_misc_init(void)
 {
 	struct proc_dir_entry *entry;
+	int gr_mode = 0;
+
 	static struct {
 		char *name;
 		int (*read_proc)(char*,char**,off_t,int,int*,void*);
@@ -580,9 +582,13 @@
 #ifdef CONFIG_STRAM_PROC
 		{"stram",	stram_read_proc},
 #endif
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"devices",	devices_read_proc},
+#endif
 		{"filesystems",	filesystems_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"cmdline",	cmdline_read_proc},
+#endif
 		{"locks",	locks_read_proc},
 		{"execdomains",	execdomains_read_proc},
 		{NULL,}
@@ -590,6 +596,16 @@
 	for (p = simple_ones; p->name; p++)
 		create_proc_read_entry(p->name, 0, NULL, p->read_proc, NULL);
 
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	gr_mode = S_IRUSR;
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	gr_mode = S_IRUSR | S_IRGRP;
+#endif
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	create_proc_read_entry("devices", gr_mode, NULL, &devices_read_proc, NULL);
+	create_proc_read_entry("cmdline", gr_mode, NULL, &cmdline_read_proc, NULL);
+#endif
+
 	proc_symlink("mounts", NULL, "self/mounts");
 
 	/* And now for trickier ones */
@@ -600,18 +616,22 @@
 	create_seq_entry("partitions", 0, &proc_partitions_operations);
 	create_seq_entry("stat", 0, &proc_stat_operations);
 	create_seq_entry("interrupts", 0, &proc_interrupts_operations);
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	create_seq_entry("slabinfo",S_IWUSR|gr_mode,&proc_slabinfo_operations);
+#else
 	create_seq_entry("slabinfo",S_IWUSR|S_IRUGO,&proc_slabinfo_operations);
+#endif
 	create_seq_entry("buddyinfo",S_IRUGO, &fragmentation_file_operations);
 	create_seq_entry("vmstat",S_IRUGO, &proc_vmstat_file_operations);
 	create_seq_entry("zoneinfo",S_IRUGO, &proc_zoneinfo_file_operations);
 	create_seq_entry("diskstats", 0, &proc_diskstats_operations);
 #ifdef CONFIG_MODULES
-	create_seq_entry("modules", 0, &proc_modules_operations);
+	create_seq_entry("modules", gr_mode, &proc_modules_operations);
 #endif
 #ifdef CONFIG_SCHEDSTATS
 	create_seq_entry("schedstat", 0, &proc_schedstat_operations);
 #endif
-#ifdef CONFIG_PROC_KCORE
+#if defined(CONFIG_PROC_KCORE) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 	proc_root_kcore = create_proc_entry("kcore", S_IRUSR, NULL);
 	if (proc_root_kcore) {
 		proc_root_kcore->proc_fops = &proc_kcore_operations;
diff -Nur linux-2.6.13.1.org/fs/proc/root.c grsecurity226/fs/proc/root.c
--- linux-2.6.13.1.org/fs/proc/root.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/proc/root.c	2005-08-30 01:14:21.000000000 +0200
@@ -52,7 +52,13 @@
 		return;
 	}
 	proc_misc_init();
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_net = proc_mkdir_mode("net", S_IRUSR | S_IXUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_net = proc_mkdir_mode("net", S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP, NULL);
+#else
 	proc_net = proc_mkdir("net", NULL);
+#endif
 	proc_net_stat = proc_mkdir("net/stat", NULL);
 
 #ifdef CONFIG_SYSVIPC
@@ -76,7 +82,15 @@
 #ifdef CONFIG_PROC_DEVICETREE
 	proc_device_tree_init();
 #endif
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_bus = proc_mkdir_mode("bus", S_IRUSR | S_IXUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_bus = proc_mkdir_mode("bus", S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP, NULL);
+#endif
+#else
 	proc_bus = proc_mkdir("bus", NULL);
+#endif
 }
 
 static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)
diff -Nur linux-2.6.13.1.org/fs/proc/task_mmu.c grsecurity226/fs/proc/task_mmu.c
--- linux-2.6.13.1.org/fs/proc/task_mmu.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/proc/task_mmu.c	2005-08-30 01:14:21.000000000 +0200
@@ -21,13 +21,24 @@
 		"VmStk:\t%8lu kB\n"
 		"VmExe:\t%8lu kB\n"
 		"VmLib:\t%8lu kB\n"
-		"VmPTE:\t%8lu kB\n",
-		(mm->total_vm - mm->reserved_vm) << (PAGE_SHIFT-10),
+		"VmPTE:\t%8lu kB\n"
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+		"CsBase:\t%8lx\nCsLim:\t%8lx\n"
+#endif
+
+		,(mm->total_vm - mm->reserved_vm) << (PAGE_SHIFT-10),
 		mm->locked_vm << (PAGE_SHIFT-10),
 		get_mm_counter(mm, rss) << (PAGE_SHIFT-10),
 		data << (PAGE_SHIFT-10),
 		mm->stack_vm << (PAGE_SHIFT-10), text, lib,
-		(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10);
+		(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+		, mm->context.user_cs_base, mm->context.user_cs_limit
+#endif
+
+	);
 	return buffer;
 }
 
@@ -87,6 +98,11 @@
 	seq_printf(m, "%*c", len, ' ');
 }
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+#define PAX_RAND_FLAGS (task->mm && (task->mm->pax_flags & MF_PAX_RANDMMAP || \
+			task->mm->pax_flags & MF_PAX_SEGMEXEC))
+#endif
+
 static int show_map(struct seq_file *m, void *v)
 {
 	struct task_struct *task = m->private;
@@ -105,13 +121,23 @@
 	}
 
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08lx %02x:%02x %lu %n",
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+			PAX_RAND_FLAGS ? 0UL : map->vm_start,
+			PAX_RAND_FLAGS ? 0UL : map->vm_end,
+#else
 			map->vm_start,
 			map->vm_end,
+#endif
+
 			flags & VM_READ ? 'r' : '-',
 			flags & VM_WRITE ? 'w' : '-',
 			flags & VM_EXEC ? 'x' : '-',
 			flags & VM_MAYSHARE ? 's' : 'p',
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+			PAX_RAND_FLAGS ? 0UL : map->vm_pgoff << PAGE_SHIFT,
+#else
 			map->vm_pgoff << PAGE_SHIFT,
+#endif
 			MAJOR(dev), MINOR(dev), ino, &len);
 
 	/*
diff -Nur linux-2.6.13.1.org/fs/readdir.c grsecurity226/fs/readdir.c
--- linux-2.6.13.1.org/fs/readdir.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/readdir.c	2005-08-30 01:14:18.000000000 +0200
@@ -16,6 +16,8 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/unistd.h>
+#include <linux/namei.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -65,6 +67,7 @@
 
 struct readdir_callback {
 	struct old_linux_dirent __user * dirent;
+	struct file * file;
 	int result;
 };
 
@@ -76,6 +79,10 @@
 
 	if (buf->result)
 		return -EINVAL;
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+
 	buf->result++;
 	dirent = buf->dirent;
 	if (!access_ok(VERIFY_WRITE, dirent,
@@ -107,6 +114,7 @@
 
 	buf.result = 0;
 	buf.dirent = dirent;
+	buf.file = file;
 
 	error = vfs_readdir(file, fillonedir, &buf);
 	if (error >= 0)
@@ -133,6 +141,7 @@
 struct getdents_callback {
 	struct linux_dirent __user * current_dir;
 	struct linux_dirent __user * previous;
+	struct file * file;
 	int count;
 	int error;
 };
@@ -147,6 +156,10 @@
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+
 	dirent = buf->previous;
 	if (dirent) {
 		if (__put_user(offset, &dirent->d_off))
@@ -191,6 +204,7 @@
 
 	buf.current_dir = dirent;
 	buf.previous = NULL;
+	buf.file = file;
 	buf.count = count;
 	buf.error = 0;
 
@@ -217,6 +231,7 @@
 struct getdents_callback64 {
 	struct linux_dirent64 __user * current_dir;
 	struct linux_dirent64 __user * previous;
+	struct file * file;
 	int count;
 	int error;
 };
@@ -231,6 +246,10 @@
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+
 	dirent = buf->previous;
 	if (dirent) {
 		if (__put_user(offset, &dirent->d_off))
@@ -277,6 +296,7 @@
 
 	buf.current_dir = dirent;
 	buf.previous = NULL;
+	buf.file = file;
 	buf.count = count;
 	buf.error = 0;
 
diff -Nur linux-2.6.13.1.org/fs/reiserfs/procfs.c grsecurity226/fs/reiserfs/procfs.c
--- linux-2.6.13.1.org/fs/reiserfs/procfs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/reiserfs/procfs.c	2005-08-30 01:00:39.000000000 +0200
@@ -8,7 +8,7 @@
 
 /* proc info support a la one created by Sizif@Botik.RU for PGC */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/config.h>
 #include <linux/module.h>
@@ -617,6 +617,9 @@
 
 /*
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:39  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.1.8.2  2001/07/15 17:08:42  god
  *  . use get_super() in procfs.c
  *  . remove remove_save_link() from reiserfs_do_truncate()
diff -Nur linux-2.6.13.1.org/fs/xfs/linux-2.6/xfs_file.c grsecurity226/fs/xfs/linux-2.6/xfs_file.c
--- linux-2.6.13.1.org/fs/xfs/linux-2.6/xfs_file.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/fs/xfs/linux-2.6/xfs_file.c	2005-08-30 01:14:23.000000000 +0200
@@ -409,6 +409,11 @@
 	vattr_t		va = { .va_mask = XFS_AT_UPDATIME };
 	int		error;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC)
+		vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+#endif
+
 	vma->vm_ops = &linvfs_file_vm_ops;
 
 	if (vp->v_vfsp->vfs_flag & VFS_DMI) {
diff -Nur linux-2.6.13.1.org/grsecurity/Kconfig grsecurity226/grsecurity/Kconfig
--- linux-2.6.13.1.org/grsecurity/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/Kconfig	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,878 @@
+#
+# grecurity configuration
+#
+
+menu "Grsecurity"
+
+config GRKERNSEC
+	bool "Grsecurity"
+	select CRYPTO
+	select CRYPTO_SHA256
+	help
+	  If you say Y here, you will be able to configure many features
+	  that will enhance the security of your system.  It is highly
+	  recommended that you say Y here and read through the help
+	  for each option so that you fully understand the features and
+	  can evaluate their usefulness for your machine.
+
+choice
+	prompt "Security Level"
+	depends GRKERNSEC
+	default GRKERNSEC_CUSTOM
+
+config GRKERNSEC_LOW
+	bool "Low"
+	select GRKERNSEC_LINK
+	select GRKERNSEC_FIFO
+	select GRKERNSEC_RANDPID
+	select GRKERNSEC_EXECVE
+	select GRKERNSEC_RANDNET
+	select GRKERNSEC_DMESG
+	select GRKERNSEC_CHROOT_CHDIR
+	help
+	  If you choose this option, several of the grsecurity options will
+	  be enabled that will give you greater protection against a number
+	  of attacks, while assuring that none of your software will have any
+	  conflicts with the additional security measures.  If you run a lot
+	  of unusual software, or you are having problems with the higher
+	  security levels, you should say Y here.  With this option, the
+	  following features are enabled:
+
+	  - Linking restrictions
+	  - FIFO restrictions
+	  - Randomized PIDs
+	  - Enforcing RLIMIT_NPROC on execve
+	  - Restricted dmesg
+	  - Enforced chdir("/") on chroot
+
+config GRKERNSEC_MEDIUM
+	bool "Medium"
+	select PAX
+	select PAX_EI_PAX
+	select PAX_PT_PAX_FLAGS
+	select PAX_HAVE_ACL_FLAGS
+	select GRKERNSEC_PROC_MEMMAP if (PAX_NOEXEC || PAX_ASLR)
+	select GRKERNSEC_CHROOT_SYSCTL
+	select GRKERNSEC_LINK
+	select GRKERNSEC_FIFO
+	select GRKERNSEC_RANDPID
+	select GRKERNSEC_EXECVE
+	select GRKERNSEC_DMESG
+	select GRKERNSEC_RANDNET
+	select GRKERNSEC_RANDSRC
+	select GRKERNSEC_FORKFAIL
+	select GRKERNSEC_TIME
+	select GRKERNSEC_SIGNAL
+	select GRKERNSEC_CHROOT
+	select GRKERNSEC_CHROOT_UNIX
+	select GRKERNSEC_CHROOT_MOUNT
+	select GRKERNSEC_CHROOT_PIVOT
+	select GRKERNSEC_CHROOT_DOUBLE
+	select GRKERNSEC_CHROOT_CHDIR
+	select GRKERNSEC_CHROOT_MKNOD
+	select GRKERNSEC_PROC
+	select GRKERNSEC_PROC_USERGROUP
+	select PAX_RANDUSTACK
+	select PAX_ASLR
+	select PAX_RANDMMAP
+	select PAX_NOVSYSCALL if (X86 && !X86_64)
+
+	help
+	  If you say Y here, several features in addition to those included
+	  in the low additional security level will be enabled.  These
+	  features provide even more security to your system, though in rare
+	  cases they may be incompatible with very old or poorly written
+	  software.  If you enable this option, make sure that your auth
+	  service (identd) is running as gid 1001.  With this option, 
+	  the following features (in addition to those provided in the 
+	  low additional security level) will be enabled:
+
+	  - Randomized TCP source ports
+	  - Failed fork logging
+	  - Time change logging
+	  - Signal logging
+	  - Deny mounts in chroot
+	  - Deny double chrooting
+	  - Deny sysctl writes in chroot
+	  - Deny mknod in chroot
+	  - Deny access to abstract AF_UNIX sockets out of chroot
+	  - Deny pivot_root in chroot
+	  - Denied writes of /dev/kmem, /dev/mem, and /dev/port
+	  - /proc restrictions with special GID set to 10 (usually wheel)
+	  - Address Space Layout Randomization (ASLR)
+
+config GRKERNSEC_HIGH
+	bool "High"
+	select GRKERNSEC_LINK
+	select GRKERNSEC_FIFO
+	select GRKERNSEC_RANDPID
+	select GRKERNSEC_EXECVE
+	select GRKERNSEC_DMESG
+	select GRKERNSEC_RANDSRC
+	select GRKERNSEC_FORKFAIL
+	select GRKERNSEC_TIME
+	select GRKERNSEC_SIGNAL
+	select GRKERNSEC_CHROOT_SHMAT
+	select GRKERNSEC_CHROOT_UNIX
+	select GRKERNSEC_CHROOT_MOUNT
+	select GRKERNSEC_CHROOT_FCHDIR
+	select GRKERNSEC_CHROOT_PIVOT
+	select GRKERNSEC_CHROOT_DOUBLE
+	select GRKERNSEC_CHROOT_CHDIR
+	select GRKERNSEC_CHROOT_MKNOD
+	select GRKERNSEC_CHROOT_CAPS
+	select GRKERNSEC_CHROOT_SYSCTL
+	select GRKERNSEC_CHROOT_FINDTASK
+	select GRKERNSEC_PROC
+	select GRKERNSEC_PROC_MEMMAP if (PAX_NOEXEC || PAX_ASLR)
+	select GRKERNSEC_HIDESYM
+	select GRKERNSEC_BRUTE
+	select GRKERNSEC_SHM if (SYSVIPC)
+	select GRKERNSEC_PROC_USERGROUP
+	select GRKERNSEC_KMEM
+	select GRKERNSEC_RESLOG
+	select GRKERNSEC_RANDNET
+	select GRKERNSEC_PROC_ADD
+	select GRKERNSEC_CHROOT_CHMOD
+	select GRKERNSEC_CHROOT_NICE
+	select GRKERNSEC_AUDIT_MOUNT
+	select PAX
+	select PAX_RANDUSTACK
+	select PAX_ASLR
+	select PAX_RANDMMAP
+	select PAX_NOEXEC
+	select PAX_MPROTECT
+	select PAX_EI_PAX
+	select PAX_PT_PAX_FLAGS
+	select PAX_HAVE_ACL_FLAGS
+	select PAX_KERNEXEC if (!X86_64 && !MODULES && !HOTPLUG_PCI_COMPAQ_NVRAM && !PCI_BIOS)
+	select PAX_RANDKSTACK if (X86_TSC && !X86_64)
+	select PAX_SEGMEXEC if (X86 && !X86_64)
+	select PAX_PAGEEXEC if (!X86)
+	select PAX_EMUPLT if (ALPHA || PARISC || PPC32 || SPARC32 || SPARC64)
+	select PAX_DLRESOLVE if (SPARC32 || SPARC64)
+	select PAX_SYSCALL if (PPC32)
+	select PAX_EMUTRAMP if (PARISC)
+	select PAX_EMUSIGRT if (PARISC)
+	select PAX_NOVSYSCALL if (X86 && !X86_64)
+	select PAX_ETEXECRELOCS if (ALPHA || IA64 || PARISC)
+	help
+	  If you say Y here, many of the features of grsecurity will be
+	  enabled, which will protect you against many kinds of attacks
+	  against your system.  The heightened security comes at a cost
+	  of an increased chance of incompatibilities with rare software
+	  on your machine.  Since this security level enables PaX, you should
+	  view <http://pax.grsecurity.net> and read about the PaX
+	  project.  While you are there, download chpax and run it on
+	  binaries that cause problems with PaX.  Also remember that
+	  since the /proc restrictions are enabled, you must run your
+	  identd as gid 1001.  This security level enables the following 
+	  features in addition to those listed in the low and medium 
+	  security levels:
+
+	  - Additional /proc restrictions
+	  - Chmod restrictions in chroot
+	  - No signals, ptrace, or viewing of processes outside of chroot
+	  - Capability restrictions in chroot
+	  - Deny fchdir out of chroot
+	  - Priority restrictions in chroot
+	  - Segmentation-based implementation of PaX
+	  - Mprotect restrictions
+	  - Removal of addresses from /proc/<pid>/[maps|stat]
+	  - Kernel stack randomization
+	  - Mount/unmount/remount logging
+	  - Kernel symbol hiding
+	  - Destroy unused shared memory	
+	  - Prevention of memory exhaustion-based exploits
+config GRKERNSEC_CUSTOM
+	bool "Custom"
+	help
+	  If you say Y here, you will be able to configure every grsecurity
+	  option, which allows you to enable many more features that aren't
+	  covered in the basic security levels.  These additional features
+	  include TPE, socket restrictions, and the sysctl system for
+	  grsecurity.  It is advised that you read through the help for
+	  each option to determine its usefulness in your situation.
+
+endchoice
+
+menu "Address Space Protection"
+depends on GRKERNSEC
+
+config GRKERNSEC_KMEM
+	bool "Deny writing to /dev/kmem, /dev/mem, and /dev/port"
+	help
+	  If you say Y here, /dev/kmem and /dev/mem won't be allowed to
+	  be written to via mmap or otherwise to modify the running kernel.
+	  /dev/port will also not be allowed to be opened. If you have module
+	  support disabled, enabling this will close up four ways that are
+	  currently used  to insert malicious code into the running kernel.
+	  Even with all these features enabled, we still highly recommend that
+	  you use the RBAC system, as it is still possible for an attacker to
+	  modify the running kernel through privileged I/O granted by ioperm/iopl.
+	  If you are not using XFree86, you may be able to stop this additional
+	  case by enabling the 'Disable privileged I/O' option. Though nothing
+	  legitimately writes to /dev/kmem, XFree86 does need to write to /dev/mem,
+	  but only to video memory, which is the only writing we allow in this
+	  case.  If /dev/kmem or /dev/mem are mmaped without PROT_WRITE, they will
+	  not be allowed to mprotect it with PROT_WRITE later.
+	  It is highly recommended that you say Y here if you meet all the
+	  conditions above.
+
+config GRKERNSEC_IO
+	bool "Disable privileged I/O"
+	depends on X86
+	select RTC
+	help
+	  If you say Y here, all ioperm and iopl calls will return an error.
+	  Ioperm and iopl can be used to modify the running kernel.
+	  Unfortunately, some programs need this access to operate properly,
+	  the most notable of which are XFree86 and hwclock.  hwclock can be
+	  remedied by having RTC support in the kernel, so CONFIG_RTC is
+	  enabled if this option is enabled, to ensure that hwclock operates
+	  correctly.  XFree86 still will not operate correctly with this option
+	  enabled, so DO NOT CHOOSE Y IF YOU USE XFree86.  If you use XFree86
+	  and you still want to protect your kernel against modification,
+	  use the RBAC system.
+
+config GRKERNSEC_PROC_MEMMAP
+	bool "Remove addresses from /proc/<pid>/[maps|stat]"
+	depends on PAX_NOEXEC || PAX_ASLR
+	help
+	  If you say Y here, the /proc/<pid>/maps and /proc/<pid>/stat files will
+	  give no information about the addresses of its mappings if
+	  PaX features that rely on random addresses are enabled on the task.
+	  If you use PaX it is greatly recommended that you say Y here as it
+	  closes up a hole that makes the full ASLR useless for suid
+	  binaries.
+
+config GRKERNSEC_BRUTE
+	bool "Deter exploit bruteforcing"
+	help
+	  If you say Y here, attempts to bruteforce exploits against forking
+	  daemons such as apache or sshd will be deterred.  When a child of a
+	  forking daemon is killed by PaX or crashes due to an illegal
+	  instruction, the parent process will be delayed 30 seconds upon every
+	  subsequent fork until the administrator is able to assess the
+	  situation and restart the daemon.  It is recommended that you also
+	  enable signal logging in the auditing section so that logs are
+	  generated when a process performs an illegal instruction.
+
+config GRKERNSEC_HIDESYM
+	bool "Hide kernel symbols"
+	help
+	  If you say Y here, getting information on loaded modules, and
+	  displaying all kernel symbols through a syscall will be restricted
+	  to users with CAP_SYS_MODULE.  This option is only effective
+	  provided the following conditions are met:
+	  1) The kernel using grsecurity is not precompiled by some distribution
+	  2) You are using the RBAC system and hiding other files such as your
+	     kernel image and System.map
+	  3) You have the additional /proc restrictions enabled, which removes
+	     /proc/kcore
+	  If the above conditions are met, this option will aid to provide a
+	  useful protection against local and remote kernel exploitation of
+	  overflows and arbitrary read/write vulnerabilities.
+
+endmenu
+menu "Role Based Access Control Options"
+depends on GRKERNSEC
+
+config GRKERNSEC_ACL_HIDEKERN
+	bool "Hide kernel processes"
+	help
+	  If you say Y here, all kernel threads will be hidden to all
+	  processes but those whose subject has the "view hidden processes"
+	  flag.
+
+config GRKERNSEC_ACL_MAXTRIES
+	int "Maximum tries before password lockout"
+	default 3
+	help
+	  This option enforces the maximum number of times a user can attempt
+	  to authorize themselves with the grsecurity RBAC system before being
+	  denied the ability to attempt authorization again for a specified time.
+	  The lower the number, the harder it will be to brute-force a password.
+
+config GRKERNSEC_ACL_TIMEOUT
+	int "Time to wait after max password tries, in seconds"
+	default 30
+	help
+	  This option specifies the time the user must wait after attempting to
+	  authorize to the RBAC system with the maximum number of invalid
+	  passwords.  The higher the number, the harder it will be to brute-force
+	  a password.
+
+endmenu
+menu "Filesystem Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_PROC
+	bool "Proc restrictions"
+	help
+	  If you say Y here, the permissions of the /proc filesystem
+	  will be altered to enhance system security and privacy.  You MUST
+  	  choose either a user only restriction or a user and group restriction.
+	  Depending upon the option you choose, you can either restrict users to
+	  see only the processes they themselves run, or choose a group that can
+	  view all processes and files normally restricted to root if you choose
+	  the "restrict to user only" option.  NOTE: If you're running identd as
+	  a non-root user, you will have to run it as the group you specify here.
+
+config GRKERNSEC_PROC_USER
+	bool "Restrict /proc to user only"
+	depends on GRKERNSEC_PROC
+	help
+	  If you say Y here, non-root users will only be able to view their own
+	  processes, and restricts them from viewing network-related information,
+	  and viewing kernel symbol and module information.
+
+config GRKERNSEC_PROC_USERGROUP
+	bool "Allow special group"
+	depends on GRKERNSEC_PROC && !GRKERNSEC_PROC_USER
+	help
+	  If you say Y here, you will be able to select a group that will be
+	  able to view all processes, network-related information, and
+	  kernel and symbol information.  This option is useful if you want
+	  to run identd as a non-root user.
+
+config GRKERNSEC_PROC_GID
+	int "GID for special group"
+	depends on GRKERNSEC_PROC_USERGROUP
+	default 1001
+
+config GRKERNSEC_PROC_ADD
+	bool "Additional restrictions"
+	depends on GRKERNSEC_PROC_USER || GRKERNSEC_PROC_USERGROUP
+	help
+	  If you say Y here, additional restrictions will be placed on
+	  /proc that keep normal users from viewing device information and 
+	  slabinfo information that could be useful for exploits.
+
+config GRKERNSEC_LINK
+	bool "Linking restrictions"
+	help
+	  If you say Y here, /tmp race exploits will be prevented, since users
+	  will no longer be able to follow symlinks owned by other users in
+	  world-writable +t directories (i.e. /tmp), unless the owner of the
+	  symlink is the owner of the directory. users will also not be
+	  able to hardlink to files they do not own.  If the sysctl option is
+	  enabled, a sysctl option with name "linking_restrictions" is created.
+
+config GRKERNSEC_FIFO
+	bool "FIFO restrictions"
+	help
+	  If you say Y here, users will not be able to write to FIFOs they don't
+	  own in world-writable +t directories (i.e. /tmp), unless the owner of
+	  the FIFO is the same owner of the directory it's held in.  If the sysctl
+	  option is enabled, a sysctl option with name "fifo_restrictions" is
+	  created.
+
+config GRKERNSEC_CHROOT
+	bool "Chroot jail restrictions"
+	help
+	  If you say Y here, you will be able to choose several options that will
+	  make breaking out of a chrooted jail much more difficult.  If you
+	  encounter no software incompatibilities with the following options, it
+	  is recommended that you enable each one.
+
+config GRKERNSEC_CHROOT_MOUNT
+	bool "Deny mounts"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to
+	  mount or remount filesystems.  If the sysctl option is enabled, a
+	  sysctl option with name "chroot_deny_mount" is created.
+
+config GRKERNSEC_CHROOT_DOUBLE
+	bool "Deny double-chroots"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to chroot
+	  again outside the chroot.  This is a widely used method of breaking
+	  out of a chroot jail and should not be allowed.  If the sysctl 
+	  option is enabled, a sysctl option with name 
+	  "chroot_deny_chroot" is created.
+
+config GRKERNSEC_CHROOT_PIVOT
+	bool "Deny pivot_root in chroot"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to use
+	  a function called pivot_root() that was introduced in Linux 2.3.41.  It
+	  works similar to chroot in that it changes the root filesystem.  This
+	  function could be misused in a chrooted process to attempt to break out
+	  of the chroot, and therefore should not be allowed.  If the sysctl
+	  option is enabled, a sysctl option with name "chroot_deny_pivot" is
+	  created.
+
+config GRKERNSEC_CHROOT_CHDIR
+	bool "Enforce chdir(\"/\") on all chroots"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, the current working directory of all newly-chrooted
+	  applications will be set to the the root directory of the chroot.
+	  The man page on chroot(2) states:
+	  Note that this call does not change  the  current  working
+	  directory,  so  that `.' can be outside the tree rooted at
+	  `/'.  In particular, the  super-user  can  escape  from  a
+	  `chroot jail' by doing `mkdir foo; chroot foo; cd ..'.
+
+	  It is recommended that you say Y here, since it's not known to break
+	  any software.  If the sysctl option is enabled, a sysctl option with
+	  name "chroot_enforce_chdir" is created.
+
+config GRKERNSEC_CHROOT_CHMOD
+	bool "Deny (f)chmod +s"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to chmod
+	  or fchmod files to make them have suid or sgid bits.  This protects
+	  against another published method of breaking a chroot.  If the sysctl
+	  option is enabled, a sysctl option with name "chroot_deny_chmod" is
+	  created.
+
+config GRKERNSEC_CHROOT_FCHDIR
+	bool "Deny fchdir out of chroot"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, a well-known method of breaking chroots by fchdir'ing
+	  to a file descriptor of the chrooting process that points to a directory
+	  outside the filesystem will be stopped.  If the sysctl option
+	  is enabled, a sysctl option with name "chroot_deny_fchdir" is created.
+
+config GRKERNSEC_CHROOT_MKNOD
+	bool "Deny mknod"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be allowed to
+	  mknod.  The problem with using mknod inside a chroot is that it
+	  would allow an attacker to create a device entry that is the same
+	  as one on the physical root of your system, which could range from
+	  anything from the console device to a device for your harddrive (which
+	  they could then use to wipe the drive or steal data).  It is recommended
+	  that you say Y here, unless you run into software incompatibilities.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "chroot_deny_mknod" is created.
+
+config GRKERNSEC_CHROOT_SHMAT
+	bool "Deny shmat() out of chroot"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to attach
+	  to shared memory segments that were created outside of the chroot jail.
+	  It is recommended that you say Y here.  If the sysctl option is enabled,
+	  a sysctl option with name "chroot_deny_shmat" is created.
+
+config GRKERNSEC_CHROOT_UNIX
+	bool "Deny access to abstract AF_UNIX sockets out of chroot"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to
+	  connect to abstract (meaning not belonging to a filesystem) Unix
+	  domain sockets that were bound outside of a chroot.  It is recommended
+	  that you say Y here.  If the sysctl option is enabled, a sysctl option
+	  with name "chroot_deny_unix" is created.
+
+config GRKERNSEC_CHROOT_FINDTASK
+	bool "Protect outside processes"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to
+	  kill, send signals with fcntl, ptrace, capget, setpgid, getpgid,
+	  getsid, or view any process outside of the chroot.  If the sysctl
+	  option is enabled, a sysctl option with name "chroot_findtask" is
+	  created.
+
+config GRKERNSEC_CHROOT_NICE
+	bool "Restrict priority changes"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, processes inside a chroot will not be able to raise
+	  the priority of processes in the chroot, or alter the priority of
+	  processes outside the chroot.  This provides more security than simply
+	  removing CAP_SYS_NICE from the process' capability set.  If the
+	  sysctl option is enabled, a sysctl option with name "chroot_restrict_nice"
+	  is created.
+
+config GRKERNSEC_CHROOT_SYSCTL
+	bool "Deny sysctl writes"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, an attacker in a chroot will not be able to
+	  write to sysctl entries, either by sysctl(2) or through a /proc
+	  interface.  It is strongly recommended that you say Y here. If the
+	  sysctl option is enabled, a sysctl option with name
+	  "chroot_deny_sysctl" is created.
+
+config GRKERNSEC_CHROOT_CAPS
+	bool "Capability restrictions"
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, the capabilities on all root processes within a
+	  chroot jail will be lowered to stop module insertion, raw i/o,
+	  system and net admin tasks, rebooting the system, modifying immutable
+	  files, modifying IPC owned by another, and changing the system time.
+	  This is left an option because it can break some apps.  Disable this
+	  if your chrooted apps are having problems performing those kinds of
+	  tasks.  If the sysctl option is enabled, a sysctl option with
+	  name "chroot_caps" is created.
+
+endmenu
+menu "Kernel Auditing"
+depends on GRKERNSEC
+
+config GRKERNSEC_AUDIT_GROUP
+	bool "Single group for auditing"
+	help
+	  If you say Y here, the exec, chdir, (un)mount, and ipc logging features
+	  will only operate on a group you specify.  This option is recommended
+	  if you only want to watch certain users instead of having a large
+	  amount of logs from the entire system.  If the sysctl option is enabled,
+	  a sysctl option with name "audit_group" is created.
+
+config GRKERNSEC_AUDIT_GID
+	int "GID for auditing"
+	depends on GRKERNSEC_AUDIT_GROUP
+	default 1007
+
+config GRKERNSEC_EXECLOG
+	bool "Exec logging"
+	help
+	  If you say Y here, all execve() calls will be logged (since the
+	  other exec*() calls are frontends to execve(), all execution
+	  will be logged).  Useful for shell-servers that like to keep track
+	  of their users.  If the sysctl option is enabled, a sysctl option with
+	  name "exec_logging" is created.
+	  WARNING: This option when enabled will produce a LOT of logs, especially
+	  on an active system.
+
+config GRKERNSEC_RESLOG
+	bool "Resource logging"
+	help
+	  If you say Y here, all attempts to overstep resource limits will
+	  be logged with the resource name, the requested size, and the current
+	  limit.  It is highly recommended that you say Y here.
+
+config GRKERNSEC_CHROOT_EXECLOG
+	bool "Log execs within chroot"
+	help
+	  If you say Y here, all executions inside a chroot jail will be logged
+	  to syslog.  This can cause a large amount of logs if certain
+	  applications (eg. djb's daemontools) are installed on the system, and
+	  is therefore left as an option.  If the sysctl option is enabled, a
+	  sysctl option with name "chroot_execlog" is created.
+
+config GRKERNSEC_AUDIT_CHDIR
+	bool "Chdir logging"
+	help
+	  If you say Y here, all chdir() calls will be logged.  If the sysctl
+ 	  option is enabled, a sysctl option with name "audit_chdir" is created.
+
+config GRKERNSEC_AUDIT_MOUNT
+	bool "(Un)Mount logging"
+	help
+	  If you say Y here, all mounts and unmounts will be logged.  If the
+	  sysctl option is enabled, a sysctl option with name "audit_mount" is
+	  created.
+
+config GRKERNSEC_AUDIT_IPC
+	bool "IPC logging"
+	help
+	  If you say Y here, creation and removal of message queues, semaphores,
+	  and shared memory will be logged.  If the sysctl option is enabled, a
+	  sysctl option with name "audit_ipc" is created.
+
+config GRKERNSEC_SIGNAL
+	bool "Signal logging"
+	help
+	  If you say Y here, certain important signals will be logged, such as
+	  SIGSEGV, which will as a result inform you of when a error in a program
+	  occurred, which in some cases could mean a possible exploit attempt.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "signal_logging" is created.
+
+config GRKERNSEC_FORKFAIL
+	bool "Fork failure logging"
+	help
+	  If you say Y here, all failed fork() attempts will be logged.
+	  This could suggest a fork bomb, or someone attempting to overstep
+	  their process limit.  If the sysctl option is enabled, a sysctl option
+	  with name "forkfail_logging" is created.
+
+config GRKERNSEC_TIME
+	bool "Time change logging"
+	help
+	  If you say Y here, any changes of the system clock will be logged.
+	  If the sysctl option is enabled, a sysctl option with name
+	  "timechange_logging" is created.
+
+config GRKERNSEC_PROC_IPADDR
+	bool "/proc/<pid>/ipaddr support"
+	help
+	  If you say Y here, a new entry will be added to each /proc/<pid>
+	  directory that contains the IP address of the person using the task.
+	  The IP is carried across local TCP and AF_UNIX stream sockets.
+	  This information can be useful for IDS/IPSes to perform remote response
+	  to a local attack.  The entry is readable by only the owner of the
+	  process (and root if he has CAP_DAC_OVERRIDE, which can be removed via
+	  the RBAC system), and thus does not create privacy concerns.
+
+config GRKERNSEC_AUDIT_TEXTREL
+	bool 'ELF text relocations logging (READ HELP)'
+	depends on PAX_MPROTECT
+	help
+	  If you say Y here, text relocations will be logged with the filename
+	  of the offending library or binary.  The purpose of the feature is
+	  to help Linux distribution developers get rid of libraries and
+	  binaries that need text relocations which hinder the future progress
+	  of PaX.  Only Linux distribution developers should say Y here, and
+	  never on a production machine, as this option creates an information
+	  leak that could aid an attacker in defeating the randomization of
+	  a single memory region.  If the sysctl option is enabled, a sysctl
+	  option with name "audit_textrel" is created.
+
+endmenu
+
+menu "Executable Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_EXECVE
+	bool "Enforce RLIMIT_NPROC on execs"
+	help
+	  If you say Y here, users with a resource limit on processes will
+	  have the value checked during execve() calls.  The current system
+	  only checks the system limit during fork() calls.  If the sysctl option
+	  is enabled, a sysctl option with name "execve_limiting" is created.
+
+config GRKERNSEC_SHM
+	bool "Destroy unused shared memory"
+	depends on SYSVIPC
+	help
+	  If you say Y here, shared memory will be destroyed when no one is
+	  attached to it.  Otherwise, resources involved with the shared
+	  memory can be used up and not be associated with any process (as the
+	  shared memory still exists, and the creating process has exited).  If
+	  the sysctl option is enabled, a sysctl option with name
+	  "destroy_unused_shm" is created.
+
+config GRKERNSEC_DMESG
+	bool "Dmesg(8) restriction"
+	help
+	  If you say Y here, non-root users will not be able to use dmesg(8)
+	  to view up to the last 4kb of messages in the kernel's log buffer.
+	  If the sysctl option is enabled, a sysctl option with name "dmesg" is
+	  created.
+
+config GRKERNSEC_RANDPID
+	bool "Randomized PIDs"
+	help
+	  If you say Y here, all PIDs created on the system will be
+	  pseudo-randomly generated.  This is extremely effective along
+	  with the /proc restrictions to disallow an attacker from guessing
+	  pids of daemons, etc.  PIDs are also used in some cases as part
+	  of a naming system for temporary files, so this option would keep
+	  those filenames from being predicted as well.  We also use code
+	  to make sure that PID numbers aren't reused too soon.  If the sysctl
+	  option is enabled, a sysctl option with name "rand_pids" is created.
+
+config GRKERNSEC_TPE
+	bool "Trusted Path Execution (TPE)"
+	help
+	  If you say Y here, you will be able to choose a gid to add to the
+	  supplementary groups of users you want to mark as "untrusted."
+	  These users will not be able to execute any files that are not in
+	  root-owned directories writable only by root.  If the sysctl option
+	  is enabled, a sysctl option with name "tpe" is created.
+
+config GRKERNSEC_TPE_ALL
+	bool "Partially restrict non-root users"
+	depends on GRKERNSEC_TPE
+	help
+	  If you say Y here, All non-root users other than the ones in the
+	  group specified in the main TPE option will only be allowed to
+	  execute files in directories they own that are not group or
+	  world-writable, or in directories owned by root and writable only by
+	  root.  If the sysctl option is enabled, a sysctl option with name
+	  "tpe_restrict_all" is created.
+
+config GRKERNSEC_TPE_INVERT
+	bool "Invert GID option"
+	depends on GRKERNSEC_TPE
+	help
+	  If you say Y here, the group you specify in the TPE configuration will
+	  decide what group TPE restrictions will be *disabled* for.  This
+	  option is useful if you want TPE restrictions to be applied to most
+	  users on the system.
+
+config GRKERNSEC_TPE_GID
+	int "GID for untrusted users"
+	depends on GRKERNSEC_TPE && !GRKERNSEC_TPE_INVERT
+	default 1005
+	help
+	  If you have selected the "Invert GID option" above, setting this
+	  GID determines what group TPE restrictions will be *disabled* for.
+	  If you have not selected the "Invert GID option" above, setting this
+	  GID determines what group TPE restrictions will be *enabled* for.
+	  If the sysctl option is enabled, a sysctl option with name "tpe_gid"
+	  is created.
+
+config GRKERNSEC_TPE_GID
+	int "GID for trusted users"
+	depends on GRKERNSEC_TPE && GRKERNSEC_TPE_INVERT
+	default 1005
+	help
+	  If you have selected the "Invert GID option" above, setting this
+	  GID determines what group TPE restrictions will be *disabled* for.
+	  If you have not selected the "Invert GID option" above, setting this
+	  GID determines what group TPE restrictions will be *enabled* for.
+	  If the sysctl option is enabled, a sysctl option with name "tpe_gid"
+	  is created.
+
+endmenu
+menu "Network Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_RANDNET
+	bool "Larger entropy pools"
+	help
+	  If you say Y here, the entropy pools used for many features of Linux
+	  and grsecurity will be doubled in size.  Since several grsecurity
+	  features use additional randomness, it is recommended that you say Y
+	  here.  Saying Y here has a similar effect as modifying
+	  /proc/sys/kernel/random/poolsize.
+
+config GRKERNSEC_RANDSRC
+	bool "Randomized TCP source ports"
+	default n if GRKERNSEC_LOW || GRKERNSEC_MID
+	default y if GRKERNSEC_HIGH
+	help
+	  If you say Y here, situations where a source port is generated on the
+	  fly for the TCP protocol (ie. with connect() ) will be altered so that
+	  the source port is generated at random, instead of a simple incrementing
+	  algorithm.  If the sysctl option is enabled, a sysctl option with name
+	  "rand_tcp_src_ports" is created.
+
+config GRKERNSEC_SOCKET
+	bool "Socket restrictions"
+	help
+	  If you say Y here, you will be able to choose from several options.
+	  If you assign a GID on your system and add it to the supplementary
+	  groups of users you want to restrict socket access to, this patch
+	  will perform up to three things, based on the option(s) you choose.
+
+config GRKERNSEC_SOCKET_ALL
+	bool "Deny any sockets to group"
+	depends on GRKERNSEC_SOCKET
+	help
+	  If you say Y here, you will be able to choose a GID of whose users will
+	  be unable to connect to other hosts from your machine or run server
+	  applications from your machine.  If the sysctl option is enabled, a
+	  sysctl option with name "socket_all" is created.
+
+config GRKERNSEC_SOCKET_ALL_GID
+	int "GID to deny all sockets for"
+	depends on GRKERNSEC_SOCKET_ALL
+	default 1004
+	help
+	  Here you can choose the GID to disable socket access for. Remember to
+	  add the users you want socket access disabled for to the GID
+	  specified here.  If the sysctl option is enabled, a sysctl option
+	  with name "socket_all_gid" is created.
+
+config GRKERNSEC_SOCKET_CLIENT
+	bool "Deny client sockets to group"
+	depends on GRKERNSEC_SOCKET
+	help
+	  If you say Y here, you will be able to choose a GID of whose users will
+	  be unable to connect to other hosts from your machine, but will be
+	  able to run servers.  If this option is enabled, all users in the group
+	  you specify will have to use passive mode when initiating ftp transfers
+	  from the shell on your machine.  If the sysctl option is enabled, a
+	  sysctl option with name "socket_client" is created.
+
+config GRKERNSEC_SOCKET_CLIENT_GID
+	int "GID to deny client sockets for"
+	depends on GRKERNSEC_SOCKET_CLIENT
+	default 1003
+	help
+	  Here you can choose the GID to disable client socket access for.
+	  Remember to add the users you want client socket access disabled for to
+	  the GID specified here.  If the sysctl option is enabled, a sysctl
+	  option with name "socket_client_gid" is created.
+
+config GRKERNSEC_SOCKET_SERVER
+	bool "Deny server sockets to group"
+	depends on GRKERNSEC_SOCKET
+	help
+	  If you say Y here, you will be able to choose a GID of whose users will
+	  be unable to run server applications from your machine.  If the sysctl
+	  option is enabled, a sysctl option with name "socket_server" is created.
+
+config GRKERNSEC_SOCKET_SERVER_GID
+	int "GID to deny server sockets for"
+	depends on GRKERNSEC_SOCKET_SERVER
+	default 1002
+	help
+	  Here you can choose the GID to disable server socket access for.
+	  Remember to add the users you want server socket access disabled for to
+	  the GID specified here.  If the sysctl option is enabled, a sysctl
+	  option with name "socket_server_gid" is created.
+
+endmenu
+menu "Sysctl support"
+depends on GRKERNSEC && SYSCTL
+
+config GRKERNSEC_SYSCTL
+	bool "Sysctl support"
+	help
+	  If you say Y here, you will be able to change the options that
+	  grsecurity runs with at bootup, without having to recompile your
+	  kernel.  You can echo values to files in /proc/sys/kernel/grsecurity
+	  to enable (1) or disable (0) various features.  All the sysctl entries
+	  are mutable until the "grsec_lock" entry is set to a non-zero value.
+	  All features enabled in the kernel configuration are disabled at boot
+	  if you do not say Y to the "Turn on features by default" option.
+	  All options should be set at startup, and the grsec_lock entry should
+	  be set to a non-zero value after all the options are set.
+	  *THIS IS EXTREMELY IMPORTANT*
+
+config GRKERNSEC_SYSCTL_ON
+	bool "Turn on features by default"
+	depends on GRKERNSEC_SYSCTL
+	help
+	  If you say Y here, instead of having all features enabled in the
+	  kernel configuration disabled at boot time, the features will be
+	  enabled at boot time.  It is recommended you say Y here unless
+	  there is some reason you would want all sysctl-tunable features to
+	  be disabled by default.  As mentioned elsewhere, it is important
+	  to enable the grsec_lock entry once you have finished modifying
+	  the sysctl entries.
+
+endmenu
+menu "Logging Options"
+depends on GRKERNSEC
+
+config GRKERNSEC_FLOODTIME
+	int "Seconds in between log messages (minimum)"
+	default 10
+	help
+	  This option allows you to enforce the number of seconds between
+	  grsecurity log messages.  The default should be suitable for most
+	  people, however, if you choose to change it, choose a value small enough
+	  to allow informative logs to be produced, but large enough to
+	  prevent flooding.
+
+config GRKERNSEC_FLOODBURST
+	int "Number of messages in a burst (maximum)"
+	default 4
+	help
+	  This option allows you to choose the maximum number of messages allowed
+	  within the flood time interval you chose in a separate option.  The
+	  default should be suitable for most people, however if you find that
+	  many of your logs are being interpreted as flooding, you may want to
+	  raise this value.
+
+endmenu
+
+endmenu
diff -Nur linux-2.6.13.1.org/grsecurity/Makefile grsecurity226/grsecurity/Makefile
--- linux-2.6.13.1.org/grsecurity/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/Makefile	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,20 @@
+# grsecurity's ACL system was originally written in 2001 by Michael Dalton
+# during 2001-2005 it has been completely redesigned by Brad Spengler
+# into an RBAC system
+#
+# All code in this directory and various hooks inserted throughout the kernel
+# are copyright Brad Spengler, and released under the GPL v2 or higher
+
+obj-y = grsec_chdir.o grsec_chroot.o grsec_exec.o grsec_fifo.o grsec_fork.o \
+	grsec_mount.o grsec_rand.o grsec_sig.o grsec_sock.o grsec_sysctl.o \
+	grsec_time.o grsec_tpe.o grsec_ipc.o grsec_link.o grsec_textrel.o
+
+obj-$(CONFIG_GRKERNSEC) += grsec_init.o grsum.o gracl.o gracl_ip.o gracl_segv.o \
+	gracl_cap.o gracl_alloc.o gracl_shm.o grsec_mem.o gracl_fs.o \
+	gracl_learn.o grsec_log.o
+obj-$(CONFIG_GRKERNSEC_RESLOG) += gracl_res.o
+
+ifndef CONFIG_GRKERNSEC
+obj-y += grsec_disabled.o
+endif
+
diff -Nur linux-2.6.13.1.org/grsecurity/gracl.c grsecurity226/grsecurity/gracl.c
--- linux-2.6.13.1.org/grsecurity/gracl.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl.c	2005-09-12 12:15:13.000000000 +0200
@@ -0,0 +1,3480 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/tty.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/sysctl.h>
+#include <linux/ptrace.h>
+#include <linux/gracl.h>
+#include <linux/gralloc.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/percpu.h>
+
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+
+static struct acl_role_db acl_role_set;
+static struct name_db name_set;
+static struct name_db inodev_set;
+
+/* for keeping track of userspace pointers used for subjects, so we
+   can share references in the kernel as well
+*/
+
+static struct dentry *real_root;
+static struct vfsmount *real_root_mnt;
+
+static struct acl_subj_map_db subj_map_set;
+
+static struct acl_role_label *default_role;
+
+static u16 acl_sp_role_value;
+
+extern char *gr_shared_page[4];
+static DECLARE_MUTEX(gr_dev_sem);
+rwlock_t gr_inode_lock = RW_LOCK_UNLOCKED;
+
+struct gr_arg *gr_usermode;
+
+static unsigned int gr_status = GR_STATUS_INIT;
+
+extern int chkpw(struct gr_arg *entry, unsigned char *salt, unsigned char *sum);
+extern void gr_clear_learn_entries(void);
+
+#ifdef CONFIG_GRKERNSEC_RESLOG
+extern void gr_log_resource(const struct task_struct *task,
+			    const int res, const unsigned long wanted, const int gt);
+#endif
+
+extern char * __d_path(struct dentry *dentry, struct vfsmount *vfsmnt,
+                        struct dentry *root, struct vfsmount *rootmnt,
+                        char *buffer, int buflen);
+
+unsigned char *gr_system_salt;
+unsigned char *gr_system_sum;
+
+static struct sprole_pw **acl_special_roles = NULL;
+static __u16 num_sprole_pws = 0;
+
+static struct acl_role_label *kernel_role = NULL;
+
+static unsigned int gr_auth_attempts = 0;
+static unsigned long gr_auth_expires = 0UL;
+
+extern int gr_init_uidset(void);
+extern void gr_free_uidset(void);
+extern void gr_remove_uid(uid_t uid);
+extern int gr_find_uid(uid_t uid);
+
+__inline__ int
+gr_acl_is_enabled(void)
+{
+	return (gr_status & GR_READY);
+}
+
+char gr_roletype_to_char(void)
+{
+	switch (current->role->roletype &
+		(GR_ROLE_DEFAULT | GR_ROLE_USER | GR_ROLE_GROUP |
+		 GR_ROLE_SPECIAL)) {
+	case GR_ROLE_DEFAULT:
+		return 'D';
+	case GR_ROLE_USER:
+		return 'U';
+	case GR_ROLE_GROUP:
+		return 'G';
+	case GR_ROLE_SPECIAL:
+		return 'S';
+	}
+
+	return 'X';
+}
+
+__inline__ int
+gr_acl_tpe_check(void)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+	if (current->role->roletype & GR_ROLE_TPE)
+		return 1;
+	else
+		return 0;
+}
+
+int
+gr_handle_rawio(const struct inode *inode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (inode && S_ISBLK(inode->i_mode) &&
+	    grsec_enable_chroot_caps && proc_is_chrooted(current) &&
+	    !capable(CAP_SYS_RAWIO))
+		return 1;
+#endif
+	return 0;
+}
+
+static int
+gr_streq(const char *a, const char *b, const unsigned int lena, const unsigned int lenb)
+{
+	int i;
+	unsigned long *l1;
+	unsigned long *l2;
+	unsigned char *c1;
+	unsigned char *c2;
+	int num_longs;
+
+	if (likely(lena != lenb))
+		return 0;
+
+	l1 = (unsigned long *)a;
+	l2 = (unsigned long *)b;
+
+	num_longs = lena / sizeof(unsigned long);
+
+	for (i = num_longs; i--; l1++, l2++) {
+		if (unlikely(*l1 != *l2))
+			return 0;
+	}
+
+	c1 = (unsigned char *) l1;
+	c2 = (unsigned char *) l2;
+
+	i = lena - (num_longs * sizeof(unsigned long));	
+
+	for (; i--; c1++, c2++) {
+		if (unlikely(*c1 != *c2))
+			return 0;
+	}
+
+	return 1;
+}
+		
+static char *
+__d_real_path(const struct dentry *dentry, const struct vfsmount *vfsmnt,
+		char *buf, int buflen)
+{
+	char *res;
+	struct dentry *l_dentry = (struct dentry *)dentry;
+
+	/* we can use real_root, real_root_mnt, because this is only called
+	   by the RBAC system */
+	res = __d_path(l_dentry, (struct vfsmount *)vfsmnt, real_root, real_root_mnt, buf, buflen);
+	if (unlikely(IS_ERR(res)))
+		res = strcpy(buf, "<path too long>");
+	else if (!IS_ROOT(l_dentry) && d_unhashed(l_dentry)) {
+		unsigned int len;
+
+		/* strip off (deleted) */
+		len = strlen(res);
+		*(res + len - 10) = '\0';
+	}
+
+	return res;
+}
+
+static char *
+d_real_path(const struct dentry *dentry, const struct vfsmount *vfsmnt,
+	    char *buf, int buflen)
+{
+	char *res;
+	struct dentry *l_dentry = (struct dentry *)dentry;
+	struct dentry *root;
+	struct vfsmount *rootmnt;
+
+	/* we can't use real_root, real_root_mnt, because they belong only to the RBAC system */
+	read_lock(&child_reaper->fs->lock);
+	root = dget(child_reaper->fs->root);
+	rootmnt = mntget(child_reaper->fs->rootmnt);
+	read_unlock(&child_reaper->fs->lock);
+
+	spin_lock(&dcache_lock);
+	res = __d_path(l_dentry, (struct vfsmount *)vfsmnt, root, rootmnt, buf, buflen);
+	if (unlikely(IS_ERR(res)))
+		res = strcpy(buf, "<path too long>");
+	else if (!IS_ROOT(l_dentry) && d_unhashed(l_dentry)) {
+		unsigned int len;
+
+		/* strip off (deleted) */
+		len = strlen(res);
+		*(res + len - 10) = '\0';
+	}
+	spin_unlock(&dcache_lock);
+
+	dput(root);
+	mntput(rootmnt);
+	return res;
+}
+
+static char *
+gr_to_filename_rbac(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	char *ret;
+	spin_lock(&dcache_lock);
+	ret = __d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[0],smp_processor_id()),
+			     PAGE_SIZE);
+	spin_unlock(&dcache_lock);
+	return ret;
+}
+
+char *
+gr_to_filename_nolock(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return __d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[0],smp_processor_id()),
+			     PAGE_SIZE);
+}
+
+char *
+gr_to_filename(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[0], smp_processor_id()),
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename1(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[1], smp_processor_id()),
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename2(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[2], smp_processor_id()),
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename3(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[3], smp_processor_id()),
+			   PAGE_SIZE);
+}
+
+__inline__ __u32
+to_gr_audit(const __u32 reqmode)
+{
+	/* masks off auditable permission flags, then shifts them to create
+	   auditing flags, and adds the special case of append auditing if
+	   we're requesting write */
+	return (((reqmode & GR_AUDIT_READ) << 10) | ((reqmode & GR_WRITE) ? GR_AUDIT_APPEND : 0));
+}
+
+struct acl_subject_label *
+lookup_subject_map(const struct acl_subject_label *userp)
+{
+	unsigned int index = shash(userp, subj_map_set.s_size);
+	struct subject_map *match;
+
+	match = subj_map_set.s_hash[index];
+
+	while (match && match->user != userp)
+		match = match->next;
+
+	if (match != NULL)
+		return match->kernel;
+	else
+		return NULL;
+}
+
+static void
+insert_subj_map_entry(struct subject_map *subjmap)
+{
+	unsigned int index = shash(subjmap->user, subj_map_set.s_size);
+	struct subject_map **curr;
+
+	subjmap->prev = NULL;
+
+	curr = &subj_map_set.s_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = subjmap;
+
+	subjmap->next = *curr;
+	*curr = subjmap;
+
+	return;
+}
+
+static struct acl_role_label *
+lookup_acl_role_label(const struct task_struct *task, const uid_t uid,
+		      const gid_t gid)
+{
+	unsigned int index = rhash(uid, GR_ROLE_USER, acl_role_set.r_size);
+	struct acl_role_label *match;
+	struct role_allowed_ip *ipp;
+	unsigned int x;
+
+	match = acl_role_set.r_hash[index];
+
+	while (match) {
+		if ((match->roletype & (GR_ROLE_DOMAIN | GR_ROLE_USER)) == (GR_ROLE_DOMAIN | GR_ROLE_USER)) {
+			for (x = 0; x < match->domain_child_num; x++) {
+				if (match->domain_children[x] == uid)
+					goto found;
+			}
+		} else if (match->uidgid == uid && match->roletype & GR_ROLE_USER)
+			break;
+		match = match->next;
+	}
+found:
+	if (match == NULL) {
+	      try_group:
+		index = rhash(gid, GR_ROLE_GROUP, acl_role_set.r_size);
+		match = acl_role_set.r_hash[index];
+
+		while (match) {
+			if ((match->roletype & (GR_ROLE_DOMAIN | GR_ROLE_GROUP)) == (GR_ROLE_DOMAIN | GR_ROLE_GROUP)) {
+				for (x = 0; x < match->domain_child_num; x++) {
+					if (match->domain_children[x] == gid)
+						goto found2;
+				}
+			} else if (match->uidgid == gid && match->roletype & GR_ROLE_GROUP)
+				break;
+			match = match->next;
+		}
+found2:
+		if (match == NULL)
+			match = default_role;
+		if (match->allowed_ips == NULL)
+			return match;
+		else {
+			for (ipp = match->allowed_ips; ipp; ipp = ipp->next) {
+				if (likely
+				    ((ntohl(task->signal->curr_ip) & ipp->netmask) ==
+				     (ntohl(ipp->addr) & ipp->netmask)))
+					return match;
+			}
+			match = default_role;
+		}
+	} else if (match->allowed_ips == NULL) {
+		return match;
+	} else {
+		for (ipp = match->allowed_ips; ipp; ipp = ipp->next) {
+			if (likely
+			    ((ntohl(task->signal->curr_ip) & ipp->netmask) ==
+			     (ntohl(ipp->addr) & ipp->netmask)))
+				return match;
+		}
+		goto try_group;
+	}
+
+	return match;
+}
+
+struct acl_subject_label *
+lookup_acl_subj_label(const ino_t ino, const dev_t dev,
+		      const struct acl_role_label *role)
+{
+	unsigned int index = fhash(ino, dev, role->subj_hash_size);
+	struct acl_subject_label *match;
+
+	match = role->subj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+static struct acl_object_label *
+lookup_acl_obj_label(const ino_t ino, const dev_t dev,
+		     const struct acl_subject_label *subj)
+{
+	unsigned int index = fhash(ino, dev, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+static struct acl_object_label *
+lookup_acl_obj_label_create(const ino_t ino, const dev_t dev,
+		     const struct acl_subject_label *subj)
+{
+	unsigned int index = fhash(ino, dev, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       !(match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && (match->mode & GR_DELETED))
+		return match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+static struct name_entry *
+lookup_name_entry(const char *name)
+{
+	unsigned int len = strlen(name);
+	unsigned int key = full_name_hash(name, len);
+	unsigned int index = key % name_set.n_size;
+	struct name_entry *match;
+
+	match = name_set.n_hash[index];
+
+	while (match && (match->key != key || !gr_streq(match->name, name, match->len, len)))
+		match = match->next;
+
+	return match;
+}
+
+static struct name_entry *
+lookup_inodev_entry(const ino_t ino, const dev_t dev)
+{
+	unsigned int index = fhash(ino, dev, inodev_set.n_size);
+	struct name_entry *match;
+
+	match = inodev_set.n_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev))
+		match = match->next;
+
+	return match;
+}
+
+static void
+insert_inodev_entry(struct name_entry *nentry)
+{
+	unsigned int index = fhash(nentry->inode, nentry->device,
+				    inodev_set.n_size);
+	struct name_entry **curr;
+
+	nentry->prev = NULL;
+
+	curr = &inodev_set.n_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = nentry;
+	
+	nentry->next = *curr;
+	*curr = nentry;
+
+	return;
+}
+
+static void
+__insert_acl_role_label(struct acl_role_label *role, uid_t uidgid)
+{
+	unsigned int index =
+	    rhash(uidgid, role->roletype & (GR_ROLE_USER | GR_ROLE_GROUP), acl_role_set.r_size);
+	struct acl_role_label **curr;
+
+	role->prev = NULL;
+
+	curr = &acl_role_set.r_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = role;
+
+	role->next = *curr;
+	*curr = role;
+
+	return;
+}
+
+static void
+insert_acl_role_label(struct acl_role_label *role)
+{
+	int i;
+
+	if (role->roletype & GR_ROLE_DOMAIN) {
+		for (i = 0; i < role->domain_child_num; i++)
+			__insert_acl_role_label(role, role->domain_children[i]);
+	} else
+		__insert_acl_role_label(role, role->uidgid);
+}
+					
+static int
+insert_name_entry(char *name, const ino_t inode, const dev_t device)
+{
+	struct name_entry **curr, *nentry;
+	unsigned int len = strlen(name);
+	unsigned int key = full_name_hash(name, len);
+	unsigned int index = key % name_set.n_size;
+
+	curr = &name_set.n_hash[index];
+
+	while (*curr && ((*curr)->key != key || !gr_streq((*curr)->name, name, (*curr)->len, len)))
+		curr = &((*curr)->next);
+
+	if (*curr != NULL)
+		return 1;
+
+	nentry = acl_alloc(sizeof (struct name_entry));
+	if (nentry == NULL)
+		return 0;
+
+	nentry->key = key;
+	nentry->name = name;
+	nentry->inode = inode;
+	nentry->device = device;
+	nentry->len = len;
+
+	nentry->prev = NULL;
+	curr = &name_set.n_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = nentry;
+	nentry->next = *curr;
+	*curr = nentry;
+
+	/* insert us into the table searchable by inode/dev */
+	insert_inodev_entry(nentry);
+
+	return 1;
+}
+
+static void
+insert_acl_obj_label(struct acl_object_label *obj,
+		     struct acl_subject_label *subj)
+{
+	unsigned int index =
+	    fhash(obj->inode, obj->device, subj->obj_hash_size);
+	struct acl_object_label **curr;
+
+	
+	obj->prev = NULL;
+
+	curr = &subj->obj_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = obj;
+
+	obj->next = *curr;
+	*curr = obj;
+
+	return;
+}
+
+static void
+insert_acl_subj_label(struct acl_subject_label *obj,
+		      struct acl_role_label *role)
+{
+	unsigned int index = fhash(obj->inode, obj->device, role->subj_hash_size);
+	struct acl_subject_label **curr;
+
+	obj->prev = NULL;
+
+	curr = &role->subj_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = obj;
+
+	obj->next = *curr;
+	*curr = obj;
+
+	return;
+}
+
+/* allocating chained hash tables, so optimal size is where lambda ~ 1 */
+
+static void *
+create_table(__u32 * len, int elementsize)
+{
+	unsigned int table_sizes[] = {
+		7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381,
+		32749, 65521, 131071, 262139, 524287, 1048573, 2097143,
+		4194301, 8388593, 16777213, 33554393, 67108859, 134217689,
+		268435399, 536870909, 1073741789, 2147483647
+	};
+	void *newtable = NULL;
+	unsigned int pwr = 0;
+
+	while ((pwr < ((sizeof (table_sizes) / sizeof (table_sizes[0])) - 1)) &&
+	       table_sizes[pwr] <= *len)
+		pwr++;
+
+	if (table_sizes[pwr] <= *len)
+		return newtable;
+
+	if ((table_sizes[pwr] * elementsize) <= PAGE_SIZE)
+		newtable =
+		    kmalloc(table_sizes[pwr] * elementsize, GFP_KERNEL);
+	else
+		newtable = vmalloc(table_sizes[pwr] * elementsize);
+
+	*len = table_sizes[pwr];
+
+	return newtable;
+}
+
+static int
+init_variables(const struct gr_arg *arg)
+{
+	unsigned int stacksize;
+
+	subj_map_set.s_size = arg->role_db.num_subjects;
+	acl_role_set.r_size = arg->role_db.num_roles + arg->role_db.num_domain_children;
+	name_set.n_size = arg->role_db.num_objects;
+	inodev_set.n_size = arg->role_db.num_objects;
+
+	if (!subj_map_set.s_size || !acl_role_set.r_size ||
+	    !name_set.n_size || !inodev_set.n_size)
+		return 1;
+
+	if (!gr_init_uidset())
+		return 1;
+
+	/* set up the stack that holds allocation info */
+
+	stacksize = arg->role_db.num_pointers + 5;
+
+	if (!acl_alloc_stack_init(stacksize))
+		return 1;
+
+	/* grab reference for the real root dentry and vfsmount */
+	read_lock(&child_reaper->fs->lock);
+	real_root_mnt = mntget(child_reaper->fs->rootmnt);
+	real_root = dget(child_reaper->fs->root);
+	read_unlock(&child_reaper->fs->lock);
+	
+
+	subj_map_set.s_hash =
+	    (struct subject_map **) create_table(&subj_map_set.s_size, sizeof(void *));
+	acl_role_set.r_hash =
+	    (struct acl_role_label **) create_table(&acl_role_set.r_size, sizeof(void *));
+	name_set.n_hash = (struct name_entry **) create_table(&name_set.n_size, sizeof(void *));
+	inodev_set.n_hash =
+	    (struct name_entry **) create_table(&inodev_set.n_size, sizeof(void *));
+
+	if (!subj_map_set.s_hash || !acl_role_set.r_hash ||
+	    !name_set.n_hash || !inodev_set.n_hash)
+		return 1;
+
+	memset(subj_map_set.s_hash, 0,
+	       sizeof(struct subject_map *) * subj_map_set.s_size);
+	memset(acl_role_set.r_hash, 0,
+	       sizeof (struct acl_role_label *) * acl_role_set.r_size);
+	memset(name_set.n_hash, 0,
+	       sizeof (struct name_entry *) * name_set.n_size);
+	memset(inodev_set.n_hash, 0,
+	       sizeof (struct name_entry *) * inodev_set.n_size);
+
+	return 0;
+}
+
+/* free information not needed after startup
+   currently contains user->kernel pointer mappings for subjects
+*/
+
+static void
+free_init_variables(void)
+{
+	__u32 i;
+
+	if (subj_map_set.s_hash) {
+		for (i = 0; i < subj_map_set.s_size; i++) {
+			if (subj_map_set.s_hash[i]) {
+				kfree(subj_map_set.s_hash[i]);
+				subj_map_set.s_hash[i] = NULL;
+			}
+		}
+
+		if ((subj_map_set.s_size * sizeof (struct subject_map *)) <=
+		    PAGE_SIZE)
+			kfree(subj_map_set.s_hash);
+		else
+			vfree(subj_map_set.s_hash);
+	}
+
+	return;
+}
+
+static void
+free_variables(void)
+{
+	struct acl_subject_label *s;
+	struct acl_role_label *r;
+	struct task_struct *task, *task2;
+	unsigned int i, x;
+
+	gr_clear_learn_entries();
+
+	read_lock(&tasklist_lock);
+	do_each_thread(task2, task) {
+		task->acl_sp_role = 0;
+		task->acl_role_id = 0;
+		task->acl = NULL;
+		task->role = NULL;
+	} while_each_thread(task2, task);
+	read_unlock(&tasklist_lock);
+
+	/* release the reference to the real root dentry and vfsmount */
+	if (real_root)
+		dput(real_root);
+	real_root = NULL;
+	if (real_root_mnt)
+		mntput(real_root_mnt);
+	real_root_mnt = NULL;
+
+	/* free all object hash tables */
+
+	FOR_EACH_ROLE_START(r, i)
+		if (r->subj_hash == NULL)
+			break;
+		FOR_EACH_SUBJECT_START(r, s, x)
+			if (s->obj_hash == NULL)
+				break;
+			if ((s->obj_hash_size * sizeof (struct acl_object_label *)) <= PAGE_SIZE)
+				kfree(s->obj_hash);
+			else
+				vfree(s->obj_hash);
+		FOR_EACH_SUBJECT_END(x)
+		FOR_EACH_NESTED_SUBJECT_START(r, s)
+			if (s->obj_hash == NULL)
+				break;
+			if ((s->obj_hash_size * sizeof (struct acl_object_label *)) <= PAGE_SIZE)
+				kfree(s->obj_hash);
+			else
+				vfree(s->obj_hash);
+		FOR_EACH_NESTED_SUBJECT_END(s)
+		if ((r->subj_hash_size * sizeof (struct acl_subject_label *)) <= PAGE_SIZE)
+			kfree(r->subj_hash);
+		else
+			vfree(r->subj_hash);
+	FOR_EACH_ROLE_END(i)
+
+	acl_free_all();
+
+	if (acl_role_set.r_hash) {
+		if ((acl_role_set.r_size * sizeof (struct acl_role_label *)) <=
+		    PAGE_SIZE)
+			kfree(acl_role_set.r_hash);
+		else
+			vfree(acl_role_set.r_hash);
+	}
+	if (name_set.n_hash) {
+		if ((name_set.n_size * sizeof (struct name_entry *)) <=
+		    PAGE_SIZE)
+			kfree(name_set.n_hash);
+		else
+			vfree(name_set.n_hash);
+	}
+
+	if (inodev_set.n_hash) {
+		if ((inodev_set.n_size * sizeof (struct name_entry *)) <=
+		    PAGE_SIZE)
+			kfree(inodev_set.n_hash);
+		else
+			vfree(inodev_set.n_hash);
+	}
+
+	gr_free_uidset();
+
+	memset(&name_set, 0, sizeof (struct name_db));
+	memset(&inodev_set, 0, sizeof (struct name_db));
+	memset(&acl_role_set, 0, sizeof (struct acl_role_db));
+	memset(&subj_map_set, 0, sizeof (struct acl_subj_map_db));
+
+	default_role = NULL;
+
+	return;
+}
+
+static __u32
+count_user_objs(struct acl_object_label *userp)
+{
+	struct acl_object_label o_tmp;
+	__u32 num = 0;
+
+	while (userp) {
+		if (copy_from_user(&o_tmp, userp,
+				   sizeof (struct acl_object_label)))
+			break;
+
+		userp = o_tmp.prev;
+		num++;
+	}
+
+	return num;
+}
+
+static struct acl_subject_label *
+do_copy_user_subj(struct acl_subject_label *userp, struct acl_role_label *role);
+
+static int
+copy_user_glob(struct acl_object_label *obj)
+{
+	struct acl_object_label *g_tmp, **guser;
+	unsigned int len;
+	char *tmp;
+
+	if (obj->globbed == NULL)
+		return 0;
+
+	guser = &obj->globbed;
+	while (*guser) {
+		g_tmp = (struct acl_object_label *)
+			acl_alloc(sizeof (struct acl_object_label));
+		if (g_tmp == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(g_tmp, *guser,
+				   sizeof (struct acl_object_label)))
+			return -EFAULT;
+
+		len = strnlen_user(g_tmp->filename, PATH_MAX);
+
+		if (!len || len >= PATH_MAX)
+			return -EINVAL;
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(tmp, g_tmp->filename, len))
+			return -EFAULT;
+
+		g_tmp->filename = tmp;
+
+		*guser = g_tmp;
+		guser = &(g_tmp->next);
+	}
+
+	return 0;
+}
+
+static int
+copy_user_objs(struct acl_object_label *userp, struct acl_subject_label *subj,
+	       struct acl_role_label *role)
+{
+	struct acl_object_label *o_tmp;
+	unsigned int len;
+	int ret;
+	char *tmp;
+
+	while (userp) {
+		if ((o_tmp = (struct acl_object_label *)
+		     acl_alloc(sizeof (struct acl_object_label))) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(o_tmp, userp,
+				   sizeof (struct acl_object_label)))
+			return -EFAULT;
+
+		userp = o_tmp->prev;
+
+		len = strnlen_user(o_tmp->filename, PATH_MAX);
+
+		if (!len || len >= PATH_MAX)
+			return -EINVAL;
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(tmp, o_tmp->filename, len))
+			return -EFAULT;
+
+		o_tmp->filename = tmp;
+
+		insert_acl_obj_label(o_tmp, subj);
+		if (!insert_name_entry(o_tmp->filename, o_tmp->inode,
+				       o_tmp->device))
+			return -ENOMEM;
+
+		ret = copy_user_glob(o_tmp);
+		if (ret)
+			return ret;
+
+		if (o_tmp->nested) {
+			o_tmp->nested = do_copy_user_subj(o_tmp->nested, role);
+			if (IS_ERR(o_tmp->nested))
+				return PTR_ERR(o_tmp->nested);
+
+			/* insert into nested subject list */
+			o_tmp->nested->next = role->hash->first;
+			role->hash->first = o_tmp->nested;
+		}
+	}
+
+	return 0;
+}
+
+static __u32
+count_user_subjs(struct acl_subject_label *userp)
+{
+	struct acl_subject_label s_tmp;
+	__u32 num = 0;
+
+	while (userp) {
+		if (copy_from_user(&s_tmp, userp,
+				   sizeof (struct acl_subject_label)))
+			break;
+
+		userp = s_tmp.prev;
+		/* do not count nested subjects against this count, since
+		   they are not included in the hash table, but are
+		   attached to objects.  We have already counted
+		   the subjects in userspace for the allocation 
+		   stack
+		*/
+		if (!(s_tmp.mode & GR_NESTED))
+			num++;
+	}
+
+	return num;
+}
+
+static int
+copy_user_allowedips(struct acl_role_label *rolep)
+{
+	struct role_allowed_ip *ruserip, *rtmp = NULL, *rlast;
+
+	ruserip = rolep->allowed_ips;
+
+	while (ruserip) {
+		rlast = rtmp;
+
+		if ((rtmp = (struct role_allowed_ip *)
+		     acl_alloc(sizeof (struct role_allowed_ip))) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(rtmp, ruserip,
+				   sizeof (struct role_allowed_ip)))
+			return -EFAULT;
+
+		ruserip = rtmp->prev;
+
+		if (!rlast) {
+			rtmp->prev = NULL;
+			rolep->allowed_ips = rtmp;
+		} else {
+			rlast->next = rtmp;
+			rtmp->prev = rlast;
+		}
+
+		if (!ruserip)
+			rtmp->next = NULL;
+	}
+
+	return 0;
+}
+
+static int
+copy_user_transitions(struct acl_role_label *rolep)
+{
+	struct role_transition *rusertp, *rtmp = NULL, *rlast;
+	
+	unsigned int len;
+	char *tmp;
+
+	rusertp = rolep->transitions;
+
+	while (rusertp) {
+		rlast = rtmp;
+
+		if ((rtmp = (struct role_transition *)
+		     acl_alloc(sizeof (struct role_transition))) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(rtmp, rusertp,
+				   sizeof (struct role_transition)))
+			return -EFAULT;
+
+		rusertp = rtmp->prev;
+
+		len = strnlen_user(rtmp->rolename, GR_SPROLE_LEN);
+
+		if (!len || len >= GR_SPROLE_LEN)
+			return -EINVAL;
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(tmp, rtmp->rolename, len))
+			return -EFAULT;
+
+		rtmp->rolename = tmp;
+
+		if (!rlast) {
+			rtmp->prev = NULL;
+			rolep->transitions = rtmp;
+		} else {
+			rlast->next = rtmp;
+			rtmp->prev = rlast;
+		}
+
+		if (!rusertp)
+			rtmp->next = NULL;
+	}
+
+	return 0;
+}
+
+static struct acl_subject_label *
+do_copy_user_subj(struct acl_subject_label *userp, struct acl_role_label *role)
+{
+	struct acl_subject_label *s_tmp = NULL, *s_tmp2;
+	unsigned int len;
+	char *tmp;
+	__u32 num_objs;
+	struct acl_ip_label **i_tmp, *i_utmp2;
+	struct gr_hash_struct ghash;
+	struct subject_map *subjmap;
+	unsigned int i_num;
+	int err;
+
+	s_tmp = lookup_subject_map(userp);
+
+	/* we've already copied this subject into the kernel, just return
+	   the reference to it, and don't copy it over again
+	*/
+	if (s_tmp)
+		return(s_tmp);
+
+	if ((s_tmp = (struct acl_subject_label *)
+	    acl_alloc(sizeof (struct acl_subject_label))) == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	subjmap = (struct subject_map *)kmalloc(sizeof (struct subject_map), GFP_KERNEL);
+	if (subjmap == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	subjmap->user = userp;
+	subjmap->kernel = s_tmp;
+	insert_subj_map_entry(subjmap);
+
+	if (copy_from_user(s_tmp, userp,
+			   sizeof (struct acl_subject_label)))
+		return ERR_PTR(-EFAULT);
+
+	len = strnlen_user(s_tmp->filename, PATH_MAX);
+
+	if (!len || len >= PATH_MAX)
+		return ERR_PTR(-EINVAL);
+
+	if ((tmp = (char *) acl_alloc(len)) == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	if (copy_from_user(tmp, s_tmp->filename, len))
+		return ERR_PTR(-EFAULT);
+
+	s_tmp->filename = tmp;
+
+	if (!strcmp(s_tmp->filename, "/"))
+		role->root_label = s_tmp;
+
+	if (copy_from_user(&ghash, s_tmp->hash, sizeof(struct gr_hash_struct)))
+		return ERR_PTR(-EFAULT);
+
+	/* copy user and group transition tables */
+
+	if (s_tmp->user_trans_num) {
+		uid_t *uidlist;
+
+		uidlist = (uid_t *)acl_alloc(s_tmp->user_trans_num * sizeof(uid_t));
+		if (uidlist == NULL)
+			return ERR_PTR(-ENOMEM);
+		if (copy_from_user(uidlist, s_tmp->user_transitions, s_tmp->user_trans_num * sizeof(uid_t)))
+			return ERR_PTR(-EFAULT);
+
+		s_tmp->user_transitions = uidlist;
+	}
+
+	if (s_tmp->group_trans_num) {
+		gid_t *gidlist;
+
+		gidlist = (gid_t *)acl_alloc(s_tmp->group_trans_num * sizeof(gid_t));
+		if (gidlist == NULL)
+			return ERR_PTR(-ENOMEM);
+		if (copy_from_user(gidlist, s_tmp->group_transitions, s_tmp->group_trans_num * sizeof(gid_t)))
+			return ERR_PTR(-EFAULT);
+
+		s_tmp->group_transitions = gidlist;
+	}
+
+	/* set up object hash table */
+	num_objs = count_user_objs(ghash.first);
+
+	s_tmp->obj_hash_size = num_objs;
+	s_tmp->obj_hash =
+	    (struct acl_object_label **)
+	    create_table(&(s_tmp->obj_hash_size), sizeof(void *));
+
+	if (!s_tmp->obj_hash)
+		return ERR_PTR(-ENOMEM);
+
+	memset(s_tmp->obj_hash, 0,
+	       s_tmp->obj_hash_size *
+	       sizeof (struct acl_object_label *));
+
+	/* add in objects */
+	err = copy_user_objs(ghash.first, s_tmp, role);
+
+	if (err)
+		return ERR_PTR(err);
+
+	/* set pointer for parent subject */
+	if (s_tmp->parent_subject) {
+		s_tmp2 = do_copy_user_subj(s_tmp->parent_subject, role);
+
+		if (IS_ERR(s_tmp2))
+			return s_tmp2;
+
+		s_tmp->parent_subject = s_tmp2;
+	}
+
+	/* add in ip acls */
+
+	if (!s_tmp->ip_num) {
+		s_tmp->ips = NULL;
+		goto insert;
+	}
+
+	i_tmp =
+	    (struct acl_ip_label **) acl_alloc(s_tmp->ip_num *
+					       sizeof (struct
+						       acl_ip_label *));
+
+	if (!i_tmp)
+		return ERR_PTR(-ENOMEM);
+
+	for (i_num = 0; i_num < s_tmp->ip_num; i_num++) {
+		*(i_tmp + i_num) =
+		    (struct acl_ip_label *)
+		    acl_alloc(sizeof (struct acl_ip_label));
+		if (!*(i_tmp + i_num))
+			return ERR_PTR(-ENOMEM);
+
+		if (copy_from_user
+		    (&i_utmp2, s_tmp->ips + i_num,
+		     sizeof (struct acl_ip_label *)))
+			return ERR_PTR(-EFAULT);
+
+		if (copy_from_user
+		    (*(i_tmp + i_num), i_utmp2,
+		     sizeof (struct acl_ip_label)))
+			return ERR_PTR(-EFAULT);
+	}
+
+	s_tmp->ips = i_tmp;
+
+insert:
+	if (!insert_name_entry(s_tmp->filename, s_tmp->inode,
+			       s_tmp->device))
+		return ERR_PTR(-ENOMEM);
+
+	return s_tmp;
+}
+
+static int
+copy_user_subjs(struct acl_subject_label *userp, struct acl_role_label *role)
+{
+	struct acl_subject_label s_pre;
+	struct acl_subject_label * ret;
+	int err;
+
+	while (userp) {
+		if (copy_from_user(&s_pre, userp,
+				   sizeof (struct acl_subject_label)))
+			return -EFAULT;
+		
+		/* do not add nested subjects here, add
+		   while parsing objects
+		*/
+
+		if (s_pre.mode & GR_NESTED) {
+			userp = s_pre.prev;
+			continue;
+		}
+
+		ret = do_copy_user_subj(userp, role);
+
+		err = PTR_ERR(ret);
+		if (IS_ERR(ret))
+			return err;
+
+		insert_acl_subj_label(ret, role);
+
+		userp = s_pre.prev;
+	}
+
+	return 0;
+}
+
+static int
+copy_user_acl(struct gr_arg *arg)
+{
+	struct acl_role_label *r_tmp = NULL, **r_utmp, *r_utmp2;
+	struct sprole_pw *sptmp;
+	struct gr_hash_struct *ghash;
+	uid_t *domainlist;
+	unsigned int r_num;
+	unsigned int len;
+	char *tmp;
+	int err = 0;
+	__u16 i;
+	__u32 num_subjs;
+
+	/* we need a default and kernel role */
+	if (arg->role_db.num_roles < 2)
+		return -EINVAL;
+
+	/* copy special role authentication info from userspace */
+
+	num_sprole_pws = arg->num_sprole_pws;
+	acl_special_roles = (struct sprole_pw **) acl_alloc(num_sprole_pws * sizeof(struct sprole_pw *));
+
+	if (!acl_special_roles) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+
+	for (i = 0; i < num_sprole_pws; i++) {
+		sptmp = (struct sprole_pw *) acl_alloc(sizeof(struct sprole_pw));
+		if (!sptmp) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(sptmp, arg->sprole_pws + i,
+				   sizeof (struct sprole_pw))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+		len =
+		    strnlen_user(sptmp->rolename, GR_SPROLE_LEN);
+
+		if (!len || len >= GR_SPROLE_LEN) {
+			err = -EINVAL;
+			goto cleanup;
+		}
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+
+		if (copy_from_user(tmp, sptmp->rolename, len)) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+		printk(KERN_ALERT "Copying special role %s\n", tmp);
+#endif
+		sptmp->rolename = tmp;
+		acl_special_roles[i] = sptmp;
+	}
+
+	r_utmp = (struct acl_role_label **) arg->role_db.r_table;
+
+	for (r_num = 0; r_num < arg->role_db.num_roles; r_num++) {
+		r_tmp = acl_alloc(sizeof (struct acl_role_label));
+
+		if (!r_tmp) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+
+		if (copy_from_user(&r_utmp2, r_utmp + r_num,
+				   sizeof (struct acl_role_label *))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+		if (copy_from_user(r_tmp, r_utmp2,
+				   sizeof (struct acl_role_label))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+		len = strnlen_user(r_tmp->rolename, GR_SPROLE_LEN);
+
+		if (!len || len >= PATH_MAX) {
+			err = -EINVAL;
+			goto cleanup;
+		}
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(tmp, r_tmp->rolename, len)) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+		r_tmp->rolename = tmp;
+
+		if (!strcmp(r_tmp->rolename, "default")
+		    && (r_tmp->roletype & GR_ROLE_DEFAULT)) {
+			default_role = r_tmp;
+		} else if (!strcmp(r_tmp->rolename, ":::kernel:::")) {
+			kernel_role = r_tmp;
+		}
+
+		if ((ghash = (struct gr_hash_struct *) acl_alloc(sizeof(struct gr_hash_struct))) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(ghash, r_tmp->hash, sizeof(struct gr_hash_struct))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+		r_tmp->hash = ghash;
+
+		num_subjs = count_user_subjs(r_tmp->hash->first);
+
+		r_tmp->subj_hash_size = num_subjs;
+		r_tmp->subj_hash =
+		    (struct acl_subject_label **)
+		    create_table(&(r_tmp->subj_hash_size), sizeof(void *));
+
+		if (!r_tmp->subj_hash) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+
+		err = copy_user_allowedips(r_tmp);
+		if (err)
+			goto cleanup;
+
+		/* copy domain info */
+		if (r_tmp->domain_children != NULL) {
+			domainlist = acl_alloc(r_tmp->domain_child_num * sizeof(uid_t));
+			if (domainlist == NULL) {
+				err = -ENOMEM;
+				goto cleanup;
+			}
+			if (copy_from_user(domainlist, r_tmp->domain_children, r_tmp->domain_child_num * sizeof(uid_t))) {
+				err = -EFAULT;
+				goto cleanup;
+			}
+			r_tmp->domain_children = domainlist;
+		}
+
+		err = copy_user_transitions(r_tmp);
+		if (err)
+			goto cleanup;
+
+		memset(r_tmp->subj_hash, 0,
+		       r_tmp->subj_hash_size *
+		       sizeof (struct acl_subject_label *));
+
+		err = copy_user_subjs(r_tmp->hash->first, r_tmp);
+
+		if (err)
+			goto cleanup;
+
+		/* set nested subject list to null */
+		r_tmp->hash->first = NULL;
+
+		insert_acl_role_label(r_tmp);
+	}
+
+	goto return_err;
+      cleanup:
+	free_variables();
+      return_err:
+	return err;
+
+}
+
+static int
+gracl_init(struct gr_arg *args)
+{
+	int error = 0;
+
+	memcpy(gr_system_salt, args->salt, GR_SALT_LEN);
+	memcpy(gr_system_sum, args->sum, GR_SHA_LEN);
+
+	if (init_variables(args)) {
+		gr_log_str(GR_DONT_AUDIT_GOOD, GR_INITF_ACL_MSG, GR_VERSION);
+		error = -ENOMEM;
+		free_variables();
+		goto out;
+	}
+
+	error = copy_user_acl(args);
+	free_init_variables();
+	if (error) {
+		free_variables();
+		goto out;
+	}
+
+	if ((error = gr_set_acls(0))) {
+		free_variables();
+		goto out;
+	}
+
+	gr_status |= GR_READY;
+      out:
+	return error;
+}
+
+/* derived from glibc fnmatch() 0: match, 1: no match*/
+
+static int
+glob_match(const char *p, const char *n)
+{
+	char c;
+
+	while ((c = *p++) != '\0') {
+	switch (c) {
+		case '?':
+			if (*n == '\0')
+				return 1;
+			else if (*n == '/')
+				return 1;
+			break;
+		case '\\':
+			if (*n != c)
+				return 1;
+			break;
+		case '*':
+			for (c = *p++; c == '?' || c == '*'; c = *p++) {
+				if (*n == '/')
+					return 1;
+				else if (c == '?') {
+					if (*n == '\0')
+						return 1;
+					else
+						++n;
+				}
+			}
+			if (c == '\0') {
+				return 0;
+			} else {
+				const char *endp;
+
+				if ((endp = strchr(n, '/')) == NULL)
+					endp = n + strlen(n);
+
+				if (c == '[') {
+					for (--p; n < endp; ++n)
+						if (!glob_match(p, n))
+							return 0;
+				} else if (c == '/') {
+					while (*n != '\0' && *n != '/')
+						++n;
+					if (*n == '/' && !glob_match(p, n + 1))
+						return 0;
+				} else {
+					for (--p; n < endp; ++n)
+						if (*n == c && !glob_match(p, n))
+							return 0;
+				}
+
+				return 1;
+			}
+		case '[':
+			{
+			int not;
+			char cold;
+
+			if (*n == '\0' || *n == '/')
+				return 1;
+
+			not = (*p == '!' || *p == '^');
+			if (not)
+				++p;
+
+			c = *p++;
+			for (;;) {
+				unsigned char fn = (unsigned char)*n;
+
+				if (c == '\0')
+					return 1;
+				else {
+					if (c == fn)
+						goto matched;
+					cold = c;
+					c = *p++;
+
+					if (c == '-' && *p != ']') {
+						unsigned char cend = *p++;
+
+						if (cend == '\0')
+							return 1;
+
+						if (cold <= fn && fn <= cend)
+							goto matched;
+
+						c = *p++;
+					}
+				}
+
+				if (c == ']')
+					break;
+			}
+			if (!not)
+				return 1;
+			break;
+		matched:
+			while (c != ']') {
+				if (c == '\0')
+					return 1;
+
+				c = *p++;
+			}
+			if (not)
+				return 1;
+		}
+		break;
+	default:
+		if (c != *n)
+			return 1;
+	}
+
+	++n;
+	}
+
+	if (*n == '\0')
+		return 0;
+
+	if (*n == '/')
+		return 0;
+
+	return 1;
+}
+
+static struct acl_object_label *
+chk_glob_label(struct acl_object_label *globbed,
+	struct dentry *dentry, struct vfsmount *mnt, char **path)
+{
+	struct acl_object_label *tmp;
+
+	if (*path == NULL)
+		*path = gr_to_filename_nolock(dentry, mnt);
+
+	tmp = globbed;
+
+	while (tmp) {
+		if (!glob_match(tmp->filename, *path))
+			return tmp;
+		tmp = tmp->next;
+	}
+
+	return NULL;
+}
+
+static struct acl_object_label *
+__full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
+	    const ino_t curr_ino, const dev_t curr_dev,
+	    const struct acl_subject_label *subj, char **path)
+{
+	struct acl_subject_label *tmpsubj;
+	struct acl_object_label *retval;
+	struct acl_object_label *retval2;
+
+	tmpsubj = (struct acl_subject_label *) subj;
+	read_lock(&gr_inode_lock);
+	do {
+		retval = lookup_acl_obj_label(curr_ino, curr_dev, tmpsubj);
+		if (retval) {
+			if (retval->globbed) {
+				retval2 = chk_glob_label(retval->globbed, (struct dentry *)orig_dentry,
+						(struct vfsmount *)orig_mnt, path);
+				if (retval2)
+					retval = retval2;
+			}
+			break;
+		}
+	} while ((tmpsubj = tmpsubj->parent_subject));
+	read_unlock(&gr_inode_lock);
+
+	return retval;
+}
+
+static __inline__ struct acl_object_label *
+full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
+	    const struct dentry *curr_dentry,
+	    const struct acl_subject_label *subj, char **path)
+{
+	return __full_lookup(orig_dentry, orig_mnt,
+			     curr_dentry->d_inode->i_ino, 
+			     curr_dentry->d_inode->i_sb->s_dev, subj, path);
+}
+
+static struct acl_object_label *
+__chk_obj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj, char *path)
+{
+	struct dentry *dentry = (struct dentry *) l_dentry;
+	struct vfsmount *mnt = (struct vfsmount *) l_mnt;
+	struct acl_object_label *retval;
+
+	spin_lock(&dcache_lock);
+
+	for (;;) {
+		if (dentry == real_root && mnt == real_root_mnt)
+			break;
+
+		if (dentry == mnt->mnt_root || IS_ROOT(dentry)) {
+			if (mnt->mnt_parent == mnt)
+				break;
+
+			retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path);
+			if (retval != NULL)
+				goto out;
+
+			dentry = mnt->mnt_mountpoint;
+			mnt = mnt->mnt_parent;
+			continue;
+		}
+
+		retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path);
+		if (retval != NULL)
+			goto out;
+
+		dentry = dentry->d_parent;
+	}
+
+	retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path);
+
+	if (retval == NULL)
+		retval = full_lookup(l_dentry, l_mnt, real_root, subj, &path);
+out:
+	spin_unlock(&dcache_lock);
+	return retval;
+}
+
+static __inline__ struct acl_object_label *
+chk_obj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj)
+{
+	char *path = NULL;
+	return __chk_obj_label(l_dentry, l_mnt, subj, path);
+}
+
+static __inline__ struct acl_object_label *
+chk_obj_create_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+		     const struct acl_subject_label *subj, char *path)
+{
+	return __chk_obj_label(l_dentry, l_mnt, subj, path);
+}
+
+static struct acl_subject_label *
+chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	       const struct acl_role_label *role)
+{
+	struct dentry *dentry = (struct dentry *) l_dentry;
+	struct vfsmount *mnt = (struct vfsmount *) l_mnt;
+	struct acl_subject_label *retval;
+
+	spin_lock(&dcache_lock);
+
+	for (;;) {
+		if (dentry == real_root && mnt == real_root_mnt)
+			break;
+		if (dentry == mnt->mnt_root || IS_ROOT(dentry)) {
+			if (mnt->mnt_parent == mnt)
+				break;
+
+			read_lock(&gr_inode_lock);
+			retval =
+				lookup_acl_subj_label(dentry->d_inode->i_ino,
+						dentry->d_inode->i_sb->s_dev, role);
+			read_unlock(&gr_inode_lock);
+			if (retval != NULL)
+				goto out;
+
+			dentry = mnt->mnt_mountpoint;
+			mnt = mnt->mnt_parent;
+			continue;
+		}
+
+		read_lock(&gr_inode_lock);
+		retval = lookup_acl_subj_label(dentry->d_inode->i_ino,
+					  dentry->d_inode->i_sb->s_dev, role);
+		read_unlock(&gr_inode_lock);
+		if (retval != NULL)
+			goto out;
+
+		dentry = dentry->d_parent;
+	}
+
+	read_lock(&gr_inode_lock);
+	retval = lookup_acl_subj_label(dentry->d_inode->i_ino,
+				  dentry->d_inode->i_sb->s_dev, role);
+	read_unlock(&gr_inode_lock);
+
+	if (unlikely(retval == NULL)) {
+		read_lock(&gr_inode_lock);
+		retval = lookup_acl_subj_label(real_root->d_inode->i_ino,
+					  real_root->d_inode->i_sb->s_dev, role);
+		read_unlock(&gr_inode_lock);
+	}
+out:
+	spin_unlock(&dcache_lock);
+
+	return retval;
+}
+
+static void
+gr_log_learn(const struct task_struct *task, const struct dentry *dentry, const struct vfsmount *mnt, const __u32 mode)
+{
+	security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename, task->role->roletype,
+		       task->uid, task->gid, task->exec_file ? gr_to_filename1(task->exec_file->f_dentry,
+		       task->exec_file->f_vfsmnt) : task->acl->filename, task->acl->filename,
+		       1, 1, gr_to_filename(dentry, mnt), (unsigned long) mode, NIPQUAD(task->signal->curr_ip));
+
+	return;
+}
+
+static void
+gr_log_learn_id_change(const struct task_struct *task, const char type, const unsigned int real, 
+		       const unsigned int effective, const unsigned int fs)
+{
+	security_learn(GR_ID_LEARN_MSG, task->role->rolename, task->role->roletype,
+		       task->uid, task->gid, task->exec_file ? gr_to_filename1(task->exec_file->f_dentry,
+		       task->exec_file->f_vfsmnt) : task->acl->filename, task->acl->filename,
+		       type, real, effective, fs, NIPQUAD(task->signal->curr_ip));
+
+	return;
+}
+
+__u32
+gr_check_link(const struct dentry * new_dentry,
+	      const struct dentry * parent_dentry,
+	      const struct vfsmount * parent_mnt,
+	      const struct dentry * old_dentry, const struct vfsmount * old_mnt)
+{
+	struct acl_object_label *obj;
+	__u32 oldmode, newmode;
+	__u32 needmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (GR_CREATE | GR_LINK);
+
+	obj = chk_obj_label(old_dentry, old_mnt, current->acl);
+	oldmode = obj->mode;
+
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		oldmode |= (GR_CREATE | GR_LINK);
+
+	needmode = GR_CREATE | GR_AUDIT_CREATE | GR_SUPPRESS;
+	if (old_dentry->d_inode->i_mode & (S_ISUID | S_ISGID))
+		needmode |= GR_SETID | GR_AUDIT_SETID;
+
+	newmode =
+	    gr_check_create(new_dentry, parent_dentry, parent_mnt,
+			    oldmode | needmode);
+
+	needmode = newmode & (GR_FIND | GR_APPEND | GR_WRITE | GR_EXEC |
+			      GR_SETID | GR_READ | GR_FIND | GR_DELETE |
+			      GR_INHERIT | GR_AUDIT_INHERIT);
+
+	if (old_dentry->d_inode->i_mode & (S_ISUID | S_ISGID) && !(newmode & GR_SETID))
+		goto bad;
+
+	if ((oldmode & needmode) != needmode)
+		goto bad;
+
+	needmode = oldmode & (GR_NOPTRACE | GR_PTRACERD | GR_INHERIT | GR_AUDITS);
+	if ((newmode & needmode) != needmode)
+		goto bad;
+
+	if ((newmode & (GR_CREATE | GR_LINK)) == (GR_CREATE | GR_LINK))
+		return newmode;
+bad:
+	needmode = oldmode;
+	if (old_dentry->d_inode->i_mode & (S_ISUID | S_ISGID))
+		needmode |= GR_SETID;
+	
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		gr_log_learn(current, old_dentry, old_mnt, needmode);
+		return (GR_CREATE | GR_LINK);
+	} else if (newmode & GR_SUPPRESS)
+		return GR_SUPPRESS;
+	else
+		return 0;
+}
+
+__u32
+gr_search_file(const struct dentry * dentry, const __u32 mode,
+	       const struct vfsmount * mnt)
+{
+	__u32 retval = mode;
+	struct acl_subject_label *curracl;
+	struct acl_object_label *currobj;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (mode & ~GR_AUDITS);
+
+	curracl = current->acl;
+
+	currobj = chk_obj_label(dentry, mnt, curracl);
+	retval = currobj->mode & mode;
+
+	if (unlikely
+	    ((curracl->mode & (GR_LEARN | GR_INHERITLEARN)) && !(mode & GR_NOPTRACE)
+	     && (retval != (mode & ~(GR_AUDITS | GR_SUPPRESS))))) {
+		__u32 new_mode = mode;
+
+		new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+		retval = new_mode;
+
+		if (new_mode & GR_EXEC && curracl->mode & GR_INHERITLEARN)
+			new_mode |= GR_INHERIT;
+
+		if (!(mode & GR_NOLEARN))
+			gr_log_learn(current, dentry, mnt, new_mode);
+	}
+
+	return retval;
+}
+
+__u32
+gr_check_create(const struct dentry * new_dentry, const struct dentry * parent,
+		const struct vfsmount * mnt, const __u32 mode)
+{
+	struct name_entry *match;
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *curracl;
+	char *path;
+	__u32 retval;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (mode & ~GR_AUDITS);
+
+	preempt_disable();
+	path = gr_to_filename_rbac(new_dentry, mnt);
+	match = lookup_name_entry(path);
+
+	if (!match)
+		goto check_parent;
+
+	curracl = current->acl;
+
+	read_lock(&gr_inode_lock);
+	matchpo = lookup_acl_obj_label_create(match->inode, match->device, curracl);
+	read_unlock(&gr_inode_lock);
+
+	if (matchpo) {
+		if ((matchpo->mode & mode) !=
+		    (mode & ~(GR_AUDITS | GR_SUPPRESS))
+		    && curracl->mode & (GR_LEARN | GR_INHERITLEARN)) {
+			__u32 new_mode = mode;
+
+			new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+			gr_log_learn(current, new_dentry, mnt, new_mode);
+
+			preempt_enable();
+			return new_mode;
+		}
+		preempt_enable();
+		return (matchpo->mode & mode);
+	}
+
+      check_parent:
+	curracl = current->acl;
+
+	matchpo = chk_obj_create_label(parent, mnt, curracl, path);
+	retval = matchpo->mode & mode;
+
+	if ((retval != (mode & ~(GR_AUDITS | GR_SUPPRESS)))
+	    && (curracl->mode & (GR_LEARN | GR_INHERITLEARN))) {
+		__u32 new_mode = mode;
+
+		new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+		gr_log_learn(current, new_dentry, mnt, new_mode);
+		preempt_enable();
+		return new_mode;
+	}
+
+	preempt_enable();
+	return retval;
+}
+
+int
+gr_check_hidden_task(const struct task_struct *task)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (!(task->acl->mode & GR_PROCFIND) && !(current->acl->mode & GR_VIEW))
+		return 1;
+
+	return 0;
+}
+
+int
+gr_check_protected_task(const struct task_struct *task)
+{
+	if (unlikely(!(gr_status & GR_READY) || !task))
+		return 0;
+
+	if ((task->acl->mode & GR_PROTECTED) && !(current->acl->mode & GR_KILL) &&
+	    task->acl != current->acl)
+		return 1;
+
+	return 0;
+}
+
+void
+gr_copy_label(struct task_struct *tsk)
+{
+	tsk->signal->used_accept = 0;
+	tsk->acl_sp_role = 0;
+	tsk->acl_role_id = current->acl_role_id;
+	tsk->acl = current->acl;
+	tsk->role = current->role;
+	tsk->signal->curr_ip = current->signal->curr_ip;
+	if (current->exec_file)
+		get_file(current->exec_file);
+	tsk->exec_file = current->exec_file;
+	tsk->is_writable = current->is_writable;
+	if (unlikely(current->signal->used_accept))
+		current->signal->curr_ip = 0;
+
+	return;
+}
+
+static void
+gr_set_proc_res(struct task_struct *task)
+{
+	struct acl_subject_label *proc;
+	unsigned short i;
+
+	proc = task->acl;
+
+	if (proc->mode & (GR_LEARN | GR_INHERITLEARN))
+		return;
+
+	for (i = 0; i < (GR_NLIMITS - 1); i++) {
+		if (!(proc->resmask & (1 << i)))
+			continue;
+
+		task->signal->rlim[i].rlim_cur = proc->res[i].rlim_cur;
+		task->signal->rlim[i].rlim_max = proc->res[i].rlim_max;
+	}
+
+	return;
+}
+
+int
+gr_check_user_change(int real, int effective, int fs)
+{
+	unsigned int i;
+	__u16 num;
+	uid_t *uidlist;
+	int curuid;
+	int realok = 0;
+	int effectiveok = 0;
+	int fsok = 0;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		gr_log_learn_id_change(current, 'u', real, effective, fs);
+
+	num = current->acl->user_trans_num;
+	uidlist = current->acl->user_transitions;
+
+	if (uidlist == NULL)
+		return 0;
+
+	if (real == -1)
+		realok = 1;
+	if (effective == -1)
+		effectiveok = 1;
+	if (fs == -1)
+		fsok = 1;
+
+	if (current->acl->user_trans_type & GR_ID_ALLOW) {
+		for (i = 0; i < num; i++) {
+			curuid = (int)uidlist[i];
+			if (real == curuid)
+				realok = 1;
+			if (effective == curuid)
+				effectiveok = 1;
+			if (fs == curuid)
+				fsok = 1;
+		}
+	} else if (current->acl->user_trans_type & GR_ID_DENY) {
+		for (i = 0; i < num; i++) {
+			curuid = (int)uidlist[i];
+			if (real == curuid)
+				break;
+			if (effective == curuid)
+				break;
+			if (fs == curuid)
+				break;
+		}
+		/* not in deny list */
+		if (i == num) {
+			realok = 1;
+			effectiveok = 1;
+			fsok = 1;
+		}
+	}
+
+	if (realok && effectiveok && fsok)
+		return 0;
+	else {
+		gr_log_int(GR_DONT_AUDIT, GR_USRCHANGE_ACL_MSG, realok ? (effectiveok ? (fsok ? 0 : fs) : effective) : real);
+		return 1;
+	}
+}
+
+int
+gr_check_group_change(int real, int effective, int fs)
+{
+	unsigned int i;
+	__u16 num;
+	gid_t *gidlist;
+	int curgid;
+	int realok = 0;
+	int effectiveok = 0;
+	int fsok = 0;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		gr_log_learn_id_change(current, 'g', real, effective, fs);
+
+	num = current->acl->group_trans_num;
+	gidlist = current->acl->group_transitions;
+
+	if (gidlist == NULL)
+		return 0;
+
+	if (real == -1)
+		realok = 1;
+	if (effective == -1)
+		effectiveok = 1;
+	if (fs == -1)
+		fsok = 1;
+
+	if (current->acl->group_trans_type & GR_ID_ALLOW) {
+		for (i = 0; i < num; i++) {
+			curgid = (int)gidlist[i];
+			if (real == curgid)
+				realok = 1;
+			if (effective == curgid)
+				effectiveok = 1;
+			if (fs == curgid)
+				fsok = 1;
+		}
+	} else if (current->acl->group_trans_type & GR_ID_DENY) {
+		for (i = 0; i < num; i++) {
+			curgid = (int)gidlist[i];
+			if (real == curgid)
+				break;
+			if (effective == curgid)
+				break;
+			if (fs == curgid)
+				break;
+		}
+		/* not in deny list */
+		if (i == num) {
+			realok = 1;
+			effectiveok = 1;
+			fsok = 1;
+		}
+	}
+
+	if (realok && effectiveok && fsok)
+		return 0;
+	else {
+		gr_log_int(GR_DONT_AUDIT, GR_GRPCHANGE_ACL_MSG, realok ? (effectiveok ? (fsok ? 0 : fs) : effective) : real);
+		return 1;
+	}
+}
+
+void
+gr_set_role_label(struct task_struct *task, const uid_t uid, const uid_t gid)
+{
+	struct acl_role_label *role = task->role;
+	struct acl_subject_label *subj = NULL;
+	struct acl_object_label *obj;
+	struct file *filp;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	filp = task->exec_file;
+
+	/* kernel process, we'll give them the kernel role */
+	if (unlikely(!filp)) {
+		task->role = kernel_role;
+		task->acl = kernel_role->root_label;
+		return;
+	} else if (!task->role || !(task->role->roletype & GR_ROLE_SPECIAL))
+		role = lookup_acl_role_label(task, uid, gid);
+
+	/* perform subject lookup in possibly new role
+	   we can use this result below in the case where role == task->role
+	*/
+	subj = chk_subj_label(filp->f_dentry, filp->f_vfsmnt, role);
+
+	/* if we changed uid/gid, but result in the same role
+	   and are using inheritance, don't lose the inherited subject
+	   if current subject is other than what normal lookup
+	   would result in, we arrived via inheritance, don't
+	   lose subject
+	*/
+	if (role != task->role || (!(task->acl->mode & GR_INHERITLEARN) &&
+				   (subj == task->acl)))
+		task->acl = subj;
+
+	task->role = role;
+
+	task->is_writable = 0;
+
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+	obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, task->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "Set role label for (%s:%d): role:%s, subject:%s\n", task->comm, task->pid, task->role->rolename, task->acl->filename);
+#endif
+
+	gr_set_proc_res(task);
+
+	return;
+}
+
+int
+gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	struct task_struct *task = current;
+	struct acl_subject_label *newacl;
+	struct acl_object_label *obj;
+	__u32 retmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	newacl = chk_subj_label(dentry, mnt, task->role);
+
+	task_lock(task);
+	if (((task->ptrace & PT_PTRACED) && !(task->acl->mode &
+	     GR_POVERRIDE) && (task->acl != newacl) &&
+	     !(task->role->roletype & GR_ROLE_GOD) &&
+	     !gr_search_file(dentry, GR_PTRACERD, mnt) &&
+	     !(task->acl->mode & (GR_LEARN | GR_INHERITLEARN))) ||
+	    (atomic_read(&task->fs->count) > 1 ||
+	     atomic_read(&task->files->count) > 1 ||
+	     atomic_read(&task->sighand->count) > 1)) {
+                task_unlock(task);
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_PTRACE_EXEC_ACL_MSG, dentry, mnt);
+		return -EACCES;
+	}
+	task_unlock(task);
+
+	obj = chk_obj_label(dentry, mnt, task->acl);
+	retmode = obj->mode & (GR_INHERIT | GR_AUDIT_INHERIT);
+
+	if (!(task->acl->mode & GR_INHERITLEARN) &&
+	    ((newacl->mode & GR_LEARN) || !(retmode & GR_INHERIT))) {
+		if (obj->nested)
+			task->acl = obj->nested;
+		else
+			task->acl = newacl;
+	} else if (retmode & GR_INHERIT && retmode & GR_AUDIT_INHERIT)
+		gr_log_str_fs(GR_DO_AUDIT, GR_INHERIT_ACL_MSG, task->acl->filename, dentry, mnt);
+
+	task->is_writable = 0;
+
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(dentry, mnt, default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+	obj = chk_obj_label(dentry, mnt, task->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+
+	gr_set_proc_res(task);
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "Set subject label for (%s:%d): role:%s, subject:%s\n", task->comm, task->pid, task->role->rolename, task->acl->filename);
+#endif
+	return 0;
+}
+
+static void
+do_handle_delete(const ino_t ino, const dev_t dev)
+{
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *matchps;
+	struct acl_subject_label *subj;
+	struct acl_role_label *role;
+	unsigned int i, x;
+
+	FOR_EACH_ROLE_START(role, i)
+		FOR_EACH_SUBJECT_START(role, subj, x)
+			if ((matchpo = lookup_acl_obj_label(ino, dev, subj)) != NULL)
+				matchpo->mode |= GR_DELETED;
+		FOR_EACH_SUBJECT_END(x)
+		FOR_EACH_NESTED_SUBJECT_START(role, subj)
+			if (subj->inode == ino && subj->device == dev)
+				subj->mode |= GR_DELETED;
+		FOR_EACH_NESTED_SUBJECT_END(subj)
+		if ((matchps = lookup_acl_subj_label(ino, dev, role)) != NULL)
+			matchps->mode |= GR_DELETED;
+	FOR_EACH_ROLE_END(i)
+
+	return;
+}
+
+void
+gr_handle_delete(const ino_t ino, const dev_t dev)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	write_lock(&gr_inode_lock);
+	if (unlikely((unsigned long)lookup_inodev_entry(ino, dev)))
+		do_handle_delete(ino, dev);
+	write_unlock(&gr_inode_lock);
+
+	return;
+}
+
+static void
+update_acl_obj_label(const ino_t oldinode, const dev_t olddevice,
+		     const ino_t newinode, const dev_t newdevice,
+		     struct acl_subject_label *subj)
+{
+	unsigned int index = fhash(oldinode, olddevice, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != oldinode ||
+	       match->device != olddevice ||
+	       !(match->mode & GR_DELETED)))
+		match = match->next;
+
+	if (match && (match->inode == oldinode)
+	    && (match->device == olddevice)
+	    && (match->mode & GR_DELETED)) {
+		if (match->prev == NULL) {
+			subj->obj_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->inode = newinode;
+		match->device = newdevice;
+		match->mode &= ~GR_DELETED;
+
+		insert_acl_obj_label(match, subj);
+	}
+
+	return;
+}
+
+static void
+update_acl_subj_label(const ino_t oldinode, const dev_t olddevice,
+		      const ino_t newinode, const dev_t newdevice,
+		      struct acl_role_label *role)
+{
+	unsigned int index = fhash(oldinode, olddevice, role->subj_hash_size);
+	struct acl_subject_label *match;
+
+	match = role->subj_hash[index];
+
+	while (match && (match->inode != oldinode ||
+	       match->device != olddevice ||
+	       !(match->mode & GR_DELETED)))
+		match = match->next;
+
+	if (match && (match->inode == oldinode)
+	    && (match->device == olddevice)
+	    && (match->mode & GR_DELETED)) {
+		if (match->prev == NULL) {
+			role->subj_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->inode = newinode;
+		match->device = newdevice;
+		match->mode &= ~GR_DELETED;
+
+		insert_acl_subj_label(match, role);
+	}
+
+	return;
+}
+
+static void
+update_inodev_entry(const ino_t oldinode, const dev_t olddevice,
+		    const ino_t newinode, const dev_t newdevice)
+{
+	unsigned int index = fhash(oldinode, olddevice, inodev_set.n_size);
+	struct name_entry *match;
+
+	match = inodev_set.n_hash[index];
+
+	while (match && (match->inode != oldinode ||
+	       match->device != olddevice))
+		match = match->next;
+
+	if (match && (match->inode == oldinode)
+	    && (match->device == olddevice)) {
+		if (match->prev == NULL) {
+			inodev_set.n_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->inode = newinode;
+		match->device = newdevice;
+
+		insert_inodev_entry(match);
+	}
+
+	return;
+}
+
+static void
+do_handle_create(const struct name_entry *matchn, const struct dentry *dentry,
+		 const struct vfsmount *mnt)
+{
+	struct acl_subject_label *subj;
+	struct acl_role_label *role;
+	unsigned int i, x;
+
+	FOR_EACH_ROLE_START(role, i)
+		update_acl_subj_label(matchn->inode, matchn->device,
+				      dentry->d_inode->i_ino,
+				      dentry->d_inode->i_sb->s_dev, role);
+
+		FOR_EACH_NESTED_SUBJECT_START(role, subj)
+			if ((subj->inode == dentry->d_inode->i_ino) &&
+			    (subj->device == dentry->d_inode->i_sb->s_dev)) {
+				subj->inode = dentry->d_inode->i_ino;
+				subj->device = dentry->d_inode->i_sb->s_dev;
+			}
+		FOR_EACH_NESTED_SUBJECT_END(subj)
+		FOR_EACH_SUBJECT_START(role, subj, x)
+			update_acl_obj_label(matchn->inode, matchn->device,
+					     dentry->d_inode->i_ino,
+					     dentry->d_inode->i_sb->s_dev, subj);
+		FOR_EACH_SUBJECT_END(x)
+	FOR_EACH_ROLE_END(i)
+
+	update_inodev_entry(matchn->inode, matchn->device,
+			    dentry->d_inode->i_ino, dentry->d_inode->i_sb->s_dev);
+
+	return;
+}
+
+void
+gr_handle_create(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	struct name_entry *matchn;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	preempt_disable();
+	matchn = lookup_name_entry(gr_to_filename_rbac(dentry, mnt));
+	preempt_enable();
+
+	if (unlikely((unsigned long)matchn)) {
+		write_lock(&gr_inode_lock);
+		do_handle_create(matchn, dentry, mnt);
+		write_unlock(&gr_inode_lock);
+	}
+
+	return;
+}
+
+void
+gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+		 struct dentry *old_dentry,
+		 struct dentry *new_dentry,
+		 struct vfsmount *mnt, const __u8 replace)
+{
+	struct name_entry *matchn;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	preempt_disable();
+	matchn = lookup_name_entry(gr_to_filename_rbac(new_dentry, mnt));
+	preempt_enable();
+
+	/* we wouldn't have to check d_inode if it weren't for
+	   NFS silly-renaming
+	 */
+
+	write_lock(&gr_inode_lock);
+	if (unlikely(replace && new_dentry->d_inode)) {
+		if (unlikely(lookup_inodev_entry(new_dentry->d_inode->i_ino,
+					new_dentry->d_inode->i_sb->s_dev) &&
+		    (old_dentry->d_inode->i_nlink <= 1)))
+			do_handle_delete(new_dentry->d_inode->i_ino,
+					 new_dentry->d_inode->i_sb->s_dev);
+	}
+
+	if (unlikely(lookup_inodev_entry(old_dentry->d_inode->i_ino,
+				old_dentry->d_inode->i_sb->s_dev) &&
+	    (old_dentry->d_inode->i_nlink <= 1)))
+		do_handle_delete(old_dentry->d_inode->i_ino,
+				 old_dentry->d_inode->i_sb->s_dev);
+
+	if (unlikely((unsigned long)matchn))
+		do_handle_create(matchn, old_dentry, mnt);
+
+	write_unlock(&gr_inode_lock);
+
+	return;
+}
+
+static int
+lookup_special_role_auth(__u16 mode, const char *rolename, unsigned char **salt,
+			 unsigned char **sum)
+{
+	struct acl_role_label *r;
+	struct role_allowed_ip *ipp;
+	struct role_transition *trans;
+	unsigned int i;
+	int found = 0;
+
+	/* check transition table */
+
+	for (trans = current->role->transitions; trans; trans = trans->next) {
+		if (!strcmp(rolename, trans->rolename)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		return 0;
+
+	/* handle special roles that do not require authentication
+	   and check ip */
+
+	FOR_EACH_ROLE_START(r, i)
+		if (!strcmp(rolename, r->rolename) &&
+		    (r->roletype & GR_ROLE_SPECIAL)) {
+			found = 0;
+			if (r->allowed_ips != NULL) {
+				for (ipp = r->allowed_ips; ipp; ipp = ipp->next) {
+					if ((ntohl(current->signal->curr_ip) & ipp->netmask) ==
+					     (ntohl(ipp->addr) & ipp->netmask))
+						found = 1;
+				}
+			} else
+				found = 2;
+			if (!found)
+				return 0;
+
+			if (((mode == SPROLE) && (r->roletype & GR_ROLE_NOPW)) ||
+			    ((mode == SPROLEPAM) && (r->roletype & GR_ROLE_PAM))) {
+				*salt = NULL;
+				*sum = NULL;
+				return 1;
+			}
+		}
+	FOR_EACH_ROLE_END(i)
+
+	for (i = 0; i < num_sprole_pws; i++) {
+		if (!strcmp(rolename, acl_special_roles[i]->rolename)) {
+			*salt = acl_special_roles[i]->salt;
+			*sum = acl_special_roles[i]->sum;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void
+assign_special_role(char *rolename)
+{
+	struct acl_object_label *obj;
+	struct acl_role_label *r;
+	struct acl_role_label *assigned = NULL;
+	struct task_struct *tsk;
+	struct file *filp;
+	unsigned int i;
+
+	FOR_EACH_ROLE_START(r, i)
+		if (!strcmp(rolename, r->rolename) &&
+		    (r->roletype & GR_ROLE_SPECIAL))
+			assigned = r;
+	FOR_EACH_ROLE_END(i)
+
+	if (!assigned)
+		return;
+
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+
+	tsk = current->parent;
+	if (tsk == NULL)
+		goto out_unlock;
+
+	filp = tsk->exec_file;
+	if (filp == NULL)
+		goto out_unlock;
+
+	tsk->is_writable = 0;
+
+	tsk->acl_sp_role = 1;
+	tsk->acl_role_id = ++acl_sp_role_value;
+	tsk->role = assigned;
+	tsk->acl = chk_subj_label(filp->f_dentry, filp->f_vfsmnt, tsk->role);
+
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		tsk->is_writable = 1;
+	obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, tsk->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		tsk->is_writable = 1;
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "Assigning special role:%s subject:%s to process (%s:%d)\n", tsk->role->rolename, tsk->acl->filename, tsk->comm, tsk->pid);
+#endif
+
+out_unlock:
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+	return;
+}
+
+int gr_check_secure_terminal(struct task_struct *task)
+{
+	struct task_struct *p, *p2, *p3;
+	struct files_struct *files;
+	struct file *our_file = NULL, *file;
+	int i;
+
+	if (task->signal->tty == NULL)
+		return 1;
+
+	task_lock(task);
+	files = task->files;
+	if (files != NULL) {
+		spin_lock(&files->file_lock);
+		for (i=0; i < files->max_fds; i++) {
+			file = fcheck_files(files, i);
+			if (file && (our_file == NULL) && (file->private_data == task->signal->tty)) {
+				get_file(file);
+				our_file = file;
+			}
+		}
+		spin_unlock(&files->file_lock);
+	}
+	task_unlock(task);
+
+	if (our_file == NULL)
+		return 1;
+
+	read_lock(&tasklist_lock);
+	do_each_thread(p2, p) {
+		task_lock(p);
+		files = p->files;
+		if (files == NULL ||
+		    (p->signal && p->signal->tty == task->signal->tty)) {
+			task_unlock(p);
+			continue;
+		}
+		spin_lock(&files->file_lock);
+		for (i=0; i < files->max_fds; i++) {
+			file = fcheck_files(files, i);
+			if (file && S_ISCHR(file->f_dentry->d_inode->i_mode) &&
+			    file->f_dentry->d_inode->i_rdev == our_file->f_dentry->d_inode->i_rdev) {
+				p3 = task;
+				while (p3->pid > 0) {
+					if (p3 == p)
+						break;
+					p3 = p3->parent;
+				}
+				if (p3 == p)
+					break;
+				gr_log_ttysniff(GR_DONT_AUDIT_GOOD, GR_TTYSNIFF_ACL_MSG, p);
+				gr_handle_alertkill(p);
+				spin_unlock(&files->file_lock);
+				task_unlock(p);
+				read_unlock(&tasklist_lock);
+				fput(our_file);
+				return 0;
+			}
+		}
+		spin_unlock(&files->file_lock);
+		task_unlock(p);
+	} while_each_thread(p2, p);
+	read_unlock(&tasklist_lock);
+
+	fput(our_file);
+	return 1;
+}
+
+ssize_t
+write_grsec_handler(struct file *file, const char * buf, size_t count, loff_t *ppos)
+{
+	struct gr_arg_wrapper uwrap;
+	unsigned char *sprole_salt;
+	unsigned char *sprole_sum;
+	int error = sizeof (struct gr_arg_wrapper);
+	int error2 = 0;
+
+	down(&gr_dev_sem);
+
+	if ((gr_status & GR_READY) && !(current->acl->mode & GR_KERNELAUTH)) {
+		error = -EPERM;
+		goto out;
+	}
+
+	if (count != sizeof (struct gr_arg_wrapper)) {
+		gr_log_int_int(GR_DONT_AUDIT_GOOD, GR_DEV_ACL_MSG, (int)count, (int)sizeof(struct gr_arg_wrapper));
+		error = -EINVAL;
+		goto out;
+	}
+
+	
+	if (gr_auth_expires && time_after_eq(get_seconds(), gr_auth_expires)) {
+		gr_auth_expires = 0;
+		gr_auth_attempts = 0;
+	}
+
+	if (copy_from_user(&uwrap, buf, sizeof (struct gr_arg_wrapper))) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	if ((uwrap.version != GRSECURITY_VERSION) || (uwrap.size != sizeof(struct gr_arg))) {
+		error = -EINVAL;
+		goto out;
+	}
+
+	if (copy_from_user(gr_usermode, uwrap.arg, sizeof (struct gr_arg))) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	if (gr_usermode->mode != SPROLE && gr_usermode->mode != SPROLEPAM &&
+	    gr_auth_attempts >= CONFIG_GRKERNSEC_ACL_MAXTRIES &&
+	    time_after(gr_auth_expires, get_seconds())) {
+		error = -EBUSY;
+		goto out;
+	}
+
+	/* if non-root trying to do anything other than use a special role,
+	   do not attempt authentication, do not count towards authentication
+	   locking
+	 */
+
+	if (gr_usermode->mode != SPROLE && gr_usermode->mode != STATUS &&
+	    gr_usermode->mode != UNSPROLE && gr_usermode->mode != SPROLEPAM &&
+	    current->uid) {
+		error = -EPERM;
+		goto out;
+	}
+
+	/* ensure pw and special role name are null terminated */
+
+	gr_usermode->pw[GR_PW_LEN - 1] = '\0';
+	gr_usermode->sp_role[GR_SPROLE_LEN - 1] = '\0';
+
+	/* Okay. 
+	 * We have our enough of the argument structure..(we have yet
+	 * to copy_from_user the tables themselves) . Copy the tables
+	 * only if we need them, i.e. for loading operations. */
+
+	switch (gr_usermode->mode) {
+	case STATUS:
+			if (gr_status & GR_READY) {
+				error = 1;
+				if (!gr_check_secure_terminal(current))
+					error = 3;
+			} else
+				error = 2;
+			goto out;
+	case SHUTDOWN:
+		if ((gr_status & GR_READY)
+		    && !(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			gr_status &= ~GR_READY;
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SHUTS_ACL_MSG);
+			free_variables();
+			memset(gr_usermode, 0, sizeof (struct gr_arg));
+			memset(gr_system_salt, 0, GR_SALT_LEN);
+			memset(gr_system_sum, 0, GR_SHA_LEN);
+		} else if (gr_status & GR_READY) {
+			gr_log_noargs(GR_DONT_AUDIT, GR_SHUTF_ACL_MSG);
+			error = -EPERM;
+		} else {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SHUTI_ACL_MSG);
+			error = -EAGAIN;
+		}
+		break;
+	case ENABLE:
+		if (!(gr_status & GR_READY) && !(error2 = gracl_init(gr_usermode)))
+			gr_log_str(GR_DONT_AUDIT_GOOD, GR_ENABLE_ACL_MSG, GR_VERSION);
+		else {
+			if (gr_status & GR_READY)
+				error = -EAGAIN;
+			else
+				error = error2;
+			gr_log_str(GR_DONT_AUDIT, GR_ENABLEF_ACL_MSG, GR_VERSION);
+		}
+		break;
+	case RELOAD:
+		if (!(gr_status & GR_READY)) {
+			gr_log_str(GR_DONT_AUDIT_GOOD, GR_RELOADI_ACL_MSG, GR_VERSION);
+			error = -EAGAIN;
+		} else if (!(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			lock_kernel();
+			gr_status &= ~GR_READY;
+			free_variables();
+			if (!(error2 = gracl_init(gr_usermode))) {
+				unlock_kernel();
+				gr_log_str(GR_DONT_AUDIT_GOOD, GR_RELOAD_ACL_MSG, GR_VERSION);
+			} else {
+				unlock_kernel();
+				error = error2;
+				gr_log_str(GR_DONT_AUDIT, GR_RELOADF_ACL_MSG, GR_VERSION);
+			}
+		} else {
+			gr_log_str(GR_DONT_AUDIT, GR_RELOADF_ACL_MSG, GR_VERSION);
+			error = -EPERM;
+		}
+		break;
+	case SEGVMOD:
+		if (unlikely(!(gr_status & GR_READY))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SEGVMODI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (!(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SEGVMODS_ACL_MSG);
+			if (gr_usermode->segv_device && gr_usermode->segv_inode) {
+				struct acl_subject_label *segvacl;
+				segvacl =
+				    lookup_acl_subj_label(gr_usermode->segv_inode,
+							  gr_usermode->segv_device,
+							  current->role);
+				if (segvacl) {
+					segvacl->crashes = 0;
+					segvacl->expires = 0;
+				}
+			} else if (gr_find_uid(gr_usermode->segv_uid) >= 0) {
+				gr_remove_uid(gr_usermode->segv_uid);
+			}
+		} else {
+			gr_log_noargs(GR_DONT_AUDIT, GR_SEGVMODF_ACL_MSG);
+			error = -EPERM;
+		}
+		break;
+	case SPROLE:
+	case SPROLEPAM:
+		if (unlikely(!(gr_status & GR_READY))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SPROLEI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (current->role->expires && time_after_eq(get_seconds(), current->role->expires)) {
+			current->role->expires = 0;
+			current->role->auth_attempts = 0;
+		}
+
+		if (current->role->auth_attempts >= CONFIG_GRKERNSEC_ACL_MAXTRIES &&
+		    time_after(current->role->expires, get_seconds())) {
+			error = -EBUSY;
+			goto out;
+		}
+
+		if (lookup_special_role_auth
+		    (gr_usermode->mode, gr_usermode->sp_role, &sprole_salt, &sprole_sum)
+		    && ((!sprole_salt && !sprole_sum)
+			|| !(chkpw(gr_usermode, sprole_salt, sprole_sum)))) {
+			char *p = "";
+			assign_special_role(gr_usermode->sp_role);
+			read_lock(&tasklist_lock);
+			if (current->parent)
+				p = current->parent->role->rolename;
+			read_unlock(&tasklist_lock);
+			gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_SPROLES_ACL_MSG,
+					p, acl_sp_role_value);
+		} else {
+			gr_log_str(GR_DONT_AUDIT, GR_SPROLEF_ACL_MSG, gr_usermode->sp_role);
+			error = -EPERM;
+			if(!(current->role->auth_attempts++))
+				current->role->expires = get_seconds() + CONFIG_GRKERNSEC_ACL_TIMEOUT;
+
+			goto out;
+		}
+		break;
+	case UNSPROLE:
+		if (unlikely(!(gr_status & GR_READY))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_UNSPROLEI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (current->role->roletype & GR_ROLE_SPECIAL) {
+			char *p = "";
+			int i = 0;
+
+			read_lock(&tasklist_lock);
+			if (current->parent) {
+				p = current->parent->role->rolename;
+				i = current->parent->acl_role_id;
+			}
+			read_unlock(&tasklist_lock);
+
+			gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_UNSPROLES_ACL_MSG, p, i);
+			gr_set_acls(1);
+		} else {
+			gr_log_str(GR_DONT_AUDIT, GR_UNSPROLEF_ACL_MSG, current->role->rolename);
+			error = -EPERM;
+			goto out;
+		}
+		break;
+	default:
+		gr_log_int(GR_DONT_AUDIT, GR_INVMODE_ACL_MSG, gr_usermode->mode);
+		error = -EINVAL;
+		break;
+	}
+
+	if (error != -EPERM)
+		goto out;
+
+	if(!(gr_auth_attempts++))
+		gr_auth_expires = get_seconds() + CONFIG_GRKERNSEC_ACL_TIMEOUT;
+
+      out:
+	up(&gr_dev_sem);
+	return error;
+}
+
+int
+gr_set_acls(const int type)
+{
+	struct acl_object_label *obj;
+	struct task_struct *task, *task2;
+	struct file *filp;
+
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	do_each_thread(task2, task) {
+		/* check to see if we're called from the exit handler,
+		   if so, only replace ACLs that have inherited the admin
+		   ACL */
+
+		if (type && (task->role != current->role ||
+			     task->acl_role_id != current->acl_role_id))
+			continue;
+
+		task->acl_role_id = 0;
+		task->acl_sp_role = 0;
+
+		if ((filp = task->exec_file)) {
+			task->role = lookup_acl_role_label(task, task->uid, task->gid);
+
+			task->acl =
+			    chk_subj_label(filp->f_dentry, filp->f_vfsmnt,
+					   task->role);
+			if (task->acl) {
+				struct acl_subject_label *curr;
+				curr = task->acl;
+
+				task->is_writable = 0;
+				/* ignore additional mmap checks for processes that are writable 
+				   by the default ACL */
+				obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, default_role->root_label);
+				if (unlikely(obj->mode & GR_WRITE))
+					task->is_writable = 1;
+				obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, task->role->root_label);
+				if (unlikely(obj->mode & GR_WRITE))
+					task->is_writable = 1;
+
+				gr_set_proc_res(task);
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+				printk(KERN_ALERT "gr_set_acls for (%s:%d): role:%s, subject:%s\n", task->comm, task->pid, task->role->rolename, task->acl->filename);
+#endif
+			} else {
+				read_unlock(&grsec_exec_file_lock);
+				read_unlock(&tasklist_lock);
+				gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_DEFACL_MSG, task->comm, task->pid);
+				return 1;
+			}
+		} else {
+			// it's a kernel process
+			task->role = kernel_role;
+			task->acl = kernel_role->root_label;
+#ifdef CONFIG_GRKERNSEC_ACL_HIDEKERN
+			task->acl->mode &= ~GR_PROCFIND;
+#endif
+		}
+	} while_each_thread(task2, task);
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+	return 0;
+}
+
+void
+gr_learn_resource(const struct task_struct *task,
+		  const int res, const unsigned long wanted, const int gt)
+{
+	struct acl_subject_label *acl;
+
+	if (unlikely((gr_status & GR_READY) &&
+		     task->acl && (task->acl->mode & (GR_LEARN | GR_INHERITLEARN))))
+		goto skip_reslog;
+
+#ifdef CONFIG_GRKERNSEC_RESLOG
+	gr_log_resource(task, res, wanted, gt);
+#endif
+      skip_reslog:
+
+	if (unlikely(!(gr_status & GR_READY) || !wanted))
+		return;
+
+	acl = task->acl;
+
+	if (likely(!acl || !(acl->mode & (GR_LEARN | GR_INHERITLEARN)) ||
+		   !(acl->resmask & (1 << (unsigned short) res))))
+		return;
+
+	if (wanted >= acl->res[res].rlim_cur) {
+		unsigned long res_add;
+
+		res_add = wanted;
+		switch (res) {
+		case RLIMIT_CPU:
+			res_add += GR_RLIM_CPU_BUMP;
+			break;
+		case RLIMIT_FSIZE:
+			res_add += GR_RLIM_FSIZE_BUMP;
+			break;
+		case RLIMIT_DATA:
+			res_add += GR_RLIM_DATA_BUMP;
+			break;
+		case RLIMIT_STACK:
+			res_add += GR_RLIM_STACK_BUMP;
+			break;
+		case RLIMIT_CORE:
+			res_add += GR_RLIM_CORE_BUMP;
+			break;
+		case RLIMIT_RSS:
+			res_add += GR_RLIM_RSS_BUMP;
+			break;
+		case RLIMIT_NPROC:
+			res_add += GR_RLIM_NPROC_BUMP;
+			break;
+		case RLIMIT_NOFILE:
+			res_add += GR_RLIM_NOFILE_BUMP;
+			break;
+		case RLIMIT_MEMLOCK:
+			res_add += GR_RLIM_MEMLOCK_BUMP;
+			break;
+		case RLIMIT_AS:
+			res_add += GR_RLIM_AS_BUMP;
+			break;
+		case RLIMIT_LOCKS:
+			res_add += GR_RLIM_LOCKS_BUMP;
+			break;
+		}
+
+		acl->res[res].rlim_cur = res_add;
+
+		if (wanted > acl->res[res].rlim_max)
+			acl->res[res].rlim_max = res_add;
+
+		security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename,
+			       task->role->roletype, acl->filename,
+			       acl->res[res].rlim_cur, acl->res[res].rlim_max,
+			       "", (unsigned long) res);
+	}
+
+	return;
+}
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+void
+pax_set_initial_flags(struct linux_binprm *bprm)
+{
+	struct task_struct *task = current;
+        struct acl_subject_label *proc;
+	unsigned long flags;
+
+        if (unlikely(!(gr_status & GR_READY)))
+                return;
+
+	flags = pax_get_flags(task);
+
+        proc = task->acl;
+
+        if (proc->mode & GR_PAXPAGE)
+                flags &= ~MF_PAX_PAGEEXEC;
+        if (proc->mode & GR_PAXSEGM)
+                flags &= ~MF_PAX_SEGMEXEC;
+        if (proc->mode & GR_PAXGCC)
+                flags |= MF_PAX_EMUTRAMP;
+        if (proc->mode & GR_PAXMPROTECT)
+                flags &= ~MF_PAX_MPROTECT;
+        if (proc->mode & GR_PAXRANDMMAP)
+                flags &= ~MF_PAX_RANDMMAP;
+
+	pax_set_flags(task, flags);
+
+        return;
+}
+#endif
+
+#ifdef CONFIG_SYSCTL
+extern struct proc_dir_entry *proc_sys_root;
+
+/* the following function is called under the BKL */
+
+__u32
+gr_handle_sysctl(const struct ctl_table *table, const void *oldval,
+		 const void *newval)
+{
+	struct proc_dir_entry *tmp;
+	struct nameidata nd;
+	const char *proc_sys = "/proc/sys";
+	char *path;
+	struct acl_object_label *obj;
+	unsigned short len = 0, pos = 0, depth = 0, i;
+	__u32 err = 0;
+	__u32 mode = 0;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 1;
+
+	path = per_cpu_ptr(gr_shared_page[0], smp_processor_id());
+
+	if (oldval)
+		mode |= GR_READ;
+	if (newval)
+		mode |= GR_WRITE;
+
+	/* convert the requested sysctl entry into a pathname */
+
+	for (tmp = table->de; tmp != proc_sys_root; tmp = tmp->parent) {
+		len += strlen(tmp->name);
+		len++;
+		depth++;
+	}
+
+	if ((len + depth + strlen(proc_sys) + 1) > PAGE_SIZE)
+		return 0;	/* deny */
+
+	memset(path, 0, PAGE_SIZE);
+
+	memcpy(path, proc_sys, strlen(proc_sys));
+
+	pos += strlen(proc_sys);
+
+	for (; depth > 0; depth--) {
+		path[pos] = '/';
+		pos++;
+		for (i = 1, tmp = table->de; tmp != proc_sys_root;
+		     tmp = tmp->parent) {
+			if (depth == i) {
+				memcpy(path + pos, tmp->name,
+				       strlen(tmp->name));
+				pos += strlen(tmp->name);
+			}
+			i++;
+		}
+	}
+
+	err = path_lookup(path, LOOKUP_FOLLOW, &nd);
+
+	if (err)
+		goto out;
+
+	obj = chk_obj_label(nd.dentry, nd.mnt, current->acl);
+	err = obj->mode & (mode | to_gr_audit(mode) | GR_SUPPRESS);
+
+	if (unlikely((current->acl->mode & (GR_LEARN | GR_INHERITLEARN)) &&
+		     ((err & mode) != mode))) {
+		__u32 new_mode = mode;
+
+		new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+		err = new_mode;
+		gr_log_learn(current, nd.dentry, nd.mnt, new_mode);
+	} else if ((err & mode) != mode && !(err & GR_SUPPRESS)) {
+		gr_log_str4(GR_DONT_AUDIT, GR_SYSCTL_ACL_MSG, "denied",
+			       path, (mode & GR_READ) ? " reading" : "",
+			       (mode & GR_WRITE) ? " writing" : "");
+		err = 0;
+	} else if ((err & mode) != mode) {
+		err = 0;
+	} else if (((err & mode) == mode) && (err & GR_AUDITS)) {
+		gr_log_str4(GR_DO_AUDIT, GR_SYSCTL_ACL_MSG, "successful",
+			       path, (mode & GR_READ) ? " reading" : "",
+			       (mode & GR_WRITE) ? " writing" : "");
+	}
+
+	path_release(&nd);
+
+      out:
+	return err;
+}
+#endif
+
+int
+gr_handle_proc_ptrace(struct task_struct *task)
+{
+	struct file *filp;
+	struct task_struct *tmp = task;
+	struct task_struct *curtemp = current;
+	__u32 retmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	filp = task->exec_file;
+
+	while (tmp->pid > 0) {
+		if (tmp == curtemp)
+			break;
+		tmp = tmp->parent;
+	}
+
+	if (!filp || (tmp->pid == 0 && !(current->acl->mode & GR_RELAXPTRACE))) {
+		read_unlock(&grsec_exec_file_lock);
+		read_unlock(&tasklist_lock);
+		return 1;
+	}
+
+	retmode = gr_search_file(filp->f_dentry, GR_NOPTRACE, filp->f_vfsmnt);
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+
+	if (retmode & GR_NOPTRACE)
+		return 1;
+
+	if (!(current->acl->mode & GR_POVERRIDE) && !(current->role->roletype & GR_ROLE_GOD)
+	    && (current->acl != task->acl || (current->acl != current->role->root_label
+	    && current->pid != task->pid)))
+		return 1;
+
+	return 0;
+}
+
+int
+gr_handle_ptrace(struct task_struct *task, const long request)
+{
+	struct task_struct *tmp = task;
+	struct task_struct *curtemp = current;
+	__u32 retmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	read_lock(&tasklist_lock);
+	while (tmp->pid > 0) {
+		if (tmp == curtemp)
+			break;
+		tmp = tmp->parent;
+	}
+
+	if (tmp->pid == 0 && !(current->acl->mode & GR_RELAXPTRACE)) {
+		read_unlock(&tasklist_lock);
+		gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+		return 1;
+	}
+	read_unlock(&tasklist_lock);
+
+	read_lock(&grsec_exec_file_lock);
+	if (unlikely(!task->exec_file)) {
+		read_unlock(&grsec_exec_file_lock);
+		return 0;
+	}
+
+	retmode = gr_search_file(task->exec_file->f_dentry, GR_PTRACERD | GR_NOPTRACE, task->exec_file->f_vfsmnt);
+	read_unlock(&grsec_exec_file_lock);
+
+	if (retmode & GR_NOPTRACE) {
+		gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+		return 1;
+	}
+		
+	if (retmode & GR_PTRACERD) {
+		switch (request) {
+		case PTRACE_POKETEXT:
+		case PTRACE_POKEDATA:
+		case PTRACE_POKEUSR:
+#if !defined(CONFIG_PPC32) && !defined(CONFIG_PPC64) && !defined(CONFIG_PARISC) && !defined(CONFIG_ALPHA) && !defined(CONFIG_IA64)
+		case PTRACE_SETREGS:
+		case PTRACE_SETFPREGS:
+#endif
+#ifdef CONFIG_X86
+		case PTRACE_SETFPXREGS:
+#endif
+#ifdef CONFIG_ALTIVEC
+		case PTRACE_SETVRREGS:
+#endif
+			return 1;
+		default:
+			return 0;
+		}
+	} else if (!(current->acl->mode & GR_POVERRIDE) &&
+		   !(current->role->roletype & GR_ROLE_GOD) &&
+		   (current->acl != task->acl)) {
+		gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int is_writable_mmap(const struct file *filp)
+{
+	struct task_struct *task = current;
+	struct acl_object_label *obj, *obj2;
+
+	if (gr_status & GR_READY && !(task->acl->mode & GR_OVERRIDE) &&
+	    !task->is_writable && S_ISREG(filp->f_dentry->d_inode->i_mode)) {
+		obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, default_role->root_label);
+		obj2 = chk_obj_label(filp->f_dentry, filp->f_vfsmnt,
+				     task->role->root_label);
+		if (unlikely((obj->mode & GR_WRITE) || (obj2->mode & GR_WRITE))) {
+			gr_log_fs_generic(GR_DONT_AUDIT, GR_WRITLIB_ACL_MSG, filp->f_dentry, filp->f_vfsmnt);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int
+gr_acl_handle_mmap(const struct file *file, const unsigned long prot)
+{
+	__u32 mode;
+
+	if (unlikely(!file || !(prot & PROT_EXEC)))
+		return 1;
+
+	if (is_writable_mmap(file))
+		return 0;
+
+	mode =
+	    gr_search_file(file->f_dentry,
+			   GR_EXEC | GR_AUDIT_EXEC | GR_SUPPRESS,
+			   file->f_vfsmnt);
+
+	if (!gr_tpe_allow(file))
+		return 0;
+
+	if (unlikely(!(mode & GR_EXEC) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_MMAP_ACL_MSG, file->f_dentry, file->f_vfsmnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_EXEC))) {
+		return 0;
+	} else if (unlikely(mode & GR_EXEC && mode & GR_AUDIT_EXEC)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_MMAP_ACL_MSG, file->f_dentry, file->f_vfsmnt);
+		return 1;
+	}
+
+	return 1;
+}
+
+int
+gr_acl_handle_mprotect(const struct file *file, const unsigned long prot)
+{
+	__u32 mode;
+
+	if (unlikely(!file || !(prot & PROT_EXEC)))
+		return 1;
+
+	if (is_writable_mmap(file))
+		return 0;
+
+	mode =
+	    gr_search_file(file->f_dentry,
+			   GR_EXEC | GR_AUDIT_EXEC | GR_SUPPRESS,
+			   file->f_vfsmnt);
+
+	if (!gr_tpe_allow(file))
+		return 0;
+
+	if (unlikely(!(mode & GR_EXEC) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_MPROTECT_ACL_MSG, file->f_dentry, file->f_vfsmnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_EXEC))) {
+		return 0;
+	} else if (unlikely(mode & GR_EXEC && mode & GR_AUDIT_EXEC)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_MPROTECT_ACL_MSG, file->f_dentry, file->f_vfsmnt);
+		return 1;
+	}
+
+	return 1;
+}
+
+void
+gr_acl_handle_psacct(struct task_struct *task, const long code)
+{
+	unsigned long runtime;
+	unsigned long cputime;
+	unsigned int wday, cday;
+	__u8 whr, chr;
+	__u8 wmin, cmin;
+	__u8 wsec, csec;
+
+	if (unlikely(!(gr_status & GR_READY) || !task->acl ||
+		     !(task->acl->mode & GR_PROCACCT)))
+		return;
+
+	runtime = xtime.tv_sec - task->start_time.tv_sec;
+	wday = runtime / (3600 * 24);
+	runtime -= wday * (3600 * 24);
+	whr = runtime / 3600;
+	runtime -= whr * 3600;
+	wmin = runtime / 60;
+	runtime -= wmin * 60;
+	wsec = runtime;
+
+	cputime = (task->utime + task->stime) / HZ;
+	cday = cputime / (3600 * 24);
+	cputime -= cday * (3600 * 24);
+	chr = cputime / 3600;
+	cputime -= chr * 3600;
+	cmin = cputime / 60;
+	cputime -= cmin * 60;
+	csec = cputime;
+
+	gr_log_procacct(GR_DO_AUDIT, GR_ACL_PROCACCT_MSG, task, wday, whr, wmin, wsec, cday, chr, cmin, csec, code);
+
+	return;
+}
+
+void gr_set_kernel_label(struct task_struct *task)
+{
+	if (gr_status & GR_READY) {
+		task->role = kernel_role;
+		task->acl = kernel_role->root_label;
+	}
+	return;
+}
+
+int gr_acl_handle_filldir(const struct file *file, const char *name, const unsigned int namelen, const ino_t ino)
+{
+	struct task_struct *task = current;
+	struct dentry *dentry = file->f_dentry;
+	struct vfsmount *mnt = file->f_vfsmnt;
+	struct acl_object_label *obj, *tmp;
+	struct acl_subject_label *subj;
+	unsigned int bufsize;
+	int is_not_root;
+	char *path;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 1;
+
+	if (task->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		return 1;
+
+	subj = task->acl;
+	do {
+		obj = lookup_acl_obj_label(ino, dentry->d_inode->i_sb->s_dev, subj);
+		if (obj != NULL)
+			return (obj->mode & GR_FIND) ? 1 : 0;
+	} while ((subj = subj->parent_subject));
+	
+	obj = chk_obj_label(dentry, mnt, task->acl);
+	if (obj->globbed == NULL)
+		return (obj->mode & GR_FIND) ? 1 : 0;
+
+	is_not_root = ((obj->filename[0] == '/') &&
+		   (obj->filename[1] == '\0')) ? 0 : 1;
+	bufsize = PAGE_SIZE - namelen - is_not_root;
+
+	/* check bufsize > PAGE_SIZE || bufsize == 0 */
+	if (unlikely((bufsize - 1) > (PAGE_SIZE - 1)))
+		return 1;
+
+	preempt_disable();
+	path = d_real_path(dentry, mnt, per_cpu_ptr(gr_shared_page[0], smp_processor_id()),
+			   bufsize);
+
+	bufsize = strlen(path);
+
+	/* if base is "/", don't append an additional slash */
+	if (is_not_root)
+		*(path + bufsize) = '/';
+	memcpy(path + bufsize + is_not_root, name, namelen);
+	*(path + bufsize + namelen + is_not_root) = '\0';
+
+	tmp = obj->globbed;
+	while (tmp) {
+		if (!glob_match(tmp->filename, path)) {
+			preempt_enable();
+			return (tmp->mode & GR_FIND) ? 1 : 0;
+		}
+		tmp = tmp->next;
+	}
+	preempt_enable();
+	return (obj->mode & GR_FIND) ? 1 : 0;
+}
+
+EXPORT_SYMBOL(gr_learn_resource);
+EXPORT_SYMBOL(gr_set_kernel_label);
+#ifdef CONFIG_SECURITY
+EXPORT_SYMBOL(gr_check_user_change);
+EXPORT_SYMBOL(gr_check_group_change);
+#endif
+
diff -Nur linux-2.6.13.1.org/grsecurity/gracl_alloc.c grsecurity226/grsecurity/gracl_alloc.c
--- linux-2.6.13.1.org/grsecurity/gracl_alloc.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl_alloc.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,91 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+
+static unsigned long alloc_stack_next = 1;
+static unsigned long alloc_stack_size = 1;
+static void **alloc_stack;
+
+static __inline__ int
+alloc_pop(void)
+{
+	if (alloc_stack_next == 1)
+		return 0;
+
+	kfree(alloc_stack[alloc_stack_next - 2]);
+
+	alloc_stack_next--;
+
+	return 1;
+}
+
+static __inline__ void
+alloc_push(void *buf)
+{
+	if (alloc_stack_next >= alloc_stack_size)
+		BUG();
+
+	alloc_stack[alloc_stack_next - 1] = buf;
+
+	alloc_stack_next++;
+
+	return;
+}
+
+void *
+acl_alloc(unsigned long len)
+{
+	void *ret;
+
+	if (len > PAGE_SIZE)
+		BUG();
+
+	ret = kmalloc(len, GFP_KERNEL);
+
+	if (ret)
+		alloc_push(ret);
+
+	return ret;
+}
+
+void
+acl_free_all(void)
+{
+	if (gr_acl_is_enabled() || !alloc_stack)
+		return;
+
+	while (alloc_pop()) ;
+
+	if (alloc_stack) {
+		if ((alloc_stack_size * sizeof (void *)) <= PAGE_SIZE)
+			kfree(alloc_stack);
+		else
+			vfree(alloc_stack);
+	}
+
+	alloc_stack = NULL;
+	alloc_stack_size = 1;
+	alloc_stack_next = 1;
+
+	return;
+}
+
+int
+acl_alloc_stack_init(unsigned long size)
+{
+	if ((size * sizeof (void *)) <= PAGE_SIZE)
+		alloc_stack =
+		    (void **) kmalloc(size * sizeof (void *), GFP_KERNEL);
+	else
+		alloc_stack = (void **) vmalloc(size * sizeof (void *));
+
+	alloc_stack_size = size;
+
+	if (!alloc_stack)
+		return 0;
+	else
+		return 1;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/gracl_cap.c grsecurity226/grsecurity/gracl_cap.c
--- linux-2.6.13.1.org/grsecurity/gracl_cap.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl_cap.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,110 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/capability.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+static const char *captab_log[] = {
+	"CAP_CHOWN",
+	"CAP_DAC_OVERRIDE",
+	"CAP_DAC_READ_SEARCH",
+	"CAP_FOWNER",
+	"CAP_FSETID",
+	"CAP_KILL",
+	"CAP_SETGID",
+	"CAP_SETUID",
+	"CAP_SETPCAP",
+	"CAP_LINUX_IMMUTABLE",
+	"CAP_NET_BIND_SERVICE",
+	"CAP_NET_BROADCAST",
+	"CAP_NET_ADMIN",
+	"CAP_NET_RAW",
+	"CAP_IPC_LOCK",
+	"CAP_IPC_OWNER",
+	"CAP_SYS_MODULE",
+	"CAP_SYS_RAWIO",
+	"CAP_SYS_CHROOT",
+	"CAP_SYS_PTRACE",
+	"CAP_SYS_PACCT",
+	"CAP_SYS_ADMIN",
+	"CAP_SYS_BOOT",
+	"CAP_SYS_NICE",
+	"CAP_SYS_RESOURCE",
+	"CAP_SYS_TIME",
+	"CAP_SYS_TTY_CONFIG",
+	"CAP_MKNOD",
+	"CAP_LEASE"
+};
+
+EXPORT_SYMBOL(gr_task_is_capable);
+
+int
+gr_task_is_capable(struct task_struct *task, const int cap)
+{
+	struct acl_subject_label *curracl;
+	__u32 cap_drop = 0, cap_mask = 0;
+
+	if (!gr_acl_is_enabled())
+		return 1;
+
+	curracl = task->acl;
+
+	cap_drop = curracl->cap_lower;
+	cap_mask = curracl->cap_mask;
+
+	while ((curracl = curracl->parent_subject)) {
+		if (!(cap_mask & (1 << cap)) && (curracl->cap_mask & (1 << cap)))
+			cap_drop |= curracl->cap_lower & (1 << cap);
+		cap_mask |= curracl->cap_mask;
+	}
+
+	if (!cap_raised(cap_drop, cap))
+		return 1;
+
+	curracl = task->acl;
+
+	if ((curracl->mode & (GR_LEARN | GR_INHERITLEARN))
+	    && cap_raised(task->cap_effective, cap)) {
+		security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename,
+			       task->role->roletype, task->uid,
+			       task->gid, task->exec_file ?
+			       gr_to_filename(task->exec_file->f_dentry,
+			       task->exec_file->f_vfsmnt) : curracl->filename,
+			       curracl->filename, 0UL,
+			       0UL, "", (unsigned long) cap, NIPQUAD(task->signal->curr_ip));
+		return 1;
+	}
+
+	if ((cap >= 0) && (cap < (sizeof(captab_log)/sizeof(captab_log[0]))) && cap_raised(task->cap_effective, cap))
+		gr_log_cap(GR_DONT_AUDIT, GR_CAP_ACL_MSG, task, captab_log[cap]);
+
+	return 0;
+}
+
+int
+gr_is_capable_nolog(const int cap)
+{
+	struct acl_subject_label *curracl;
+	__u32 cap_drop = 0, cap_mask = 0;
+
+	if (!gr_acl_is_enabled())
+		return 1;
+
+	curracl = current->acl;
+
+	cap_drop = curracl->cap_lower;
+	cap_mask = curracl->cap_mask;
+
+	while ((curracl = curracl->parent_subject)) {
+		cap_drop |= curracl->cap_lower & (cap_mask & ~curracl->cap_mask);
+		cap_mask |= curracl->cap_mask;
+	}
+
+	if (!cap_raised(cap_drop, cap))
+		return 1;
+
+	return 0;
+}
+
diff -Nur linux-2.6.13.1.org/grsecurity/gracl_fs.c grsecurity226/grsecurity/gracl_fs.c
--- linux-2.6.13.1.org/grsecurity/gracl_fs.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl_fs.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,423 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/stat.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/gracl.h>
+
+__u32
+gr_acl_handle_hidden_file(const struct dentry * dentry,
+			  const struct vfsmount * mnt)
+{
+	__u32 mode;
+
+	if (unlikely(!dentry->d_inode))
+		return GR_FIND;
+
+	mode =
+	    gr_search_file(dentry, GR_FIND | GR_AUDIT_FIND | GR_SUPPRESS, mnt);
+
+	if (unlikely(mode & GR_FIND && mode & GR_AUDIT_FIND)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_HIDDEN_ACL_MSG, dentry, mnt);
+		return mode;
+	} else if (unlikely(!(mode & GR_FIND) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_HIDDEN_ACL_MSG, dentry, mnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_FIND)))
+		return 0;
+
+	return GR_FIND;
+}
+
+__u32
+gr_acl_handle_open(const struct dentry * dentry, const struct vfsmount * mnt,
+		   const int fmode)
+{
+	__u32 reqmode = GR_FIND;
+	__u32 mode;
+
+	if (unlikely(!dentry->d_inode))
+		return reqmode;
+
+	if (unlikely(fmode & O_APPEND))
+		reqmode |= GR_APPEND;
+	else if (unlikely(fmode & FMODE_WRITE))
+		reqmode |= GR_WRITE;
+	if (likely((fmode & FMODE_READ) && !(fmode & O_DIRECTORY)))
+		reqmode |= GR_READ;
+
+	mode =
+	    gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS,
+			   mnt);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode2(GR_DO_AUDIT, GR_OPEN_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode2(GR_DONT_AUDIT, GR_OPEN_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+__u32
+gr_acl_handle_creat(const struct dentry * dentry,
+		    const struct dentry * p_dentry,
+		    const struct vfsmount * p_mnt, const int fmode,
+		    const int imode)
+{
+	__u32 reqmode = GR_WRITE | GR_CREATE;
+	__u32 mode;
+
+	if (unlikely(fmode & O_APPEND))
+		reqmode |= GR_APPEND;
+	if (unlikely((fmode & FMODE_READ) && !(fmode & O_DIRECTORY)))
+		reqmode |= GR_READ;
+	if (unlikely((fmode & O_CREAT) && (imode & (S_ISUID | S_ISGID))))
+		reqmode |= GR_SETID;
+
+	mode =
+	    gr_check_create(dentry, p_dentry, p_mnt,
+			    reqmode | to_gr_audit(reqmode) | GR_SUPPRESS);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode2(GR_DO_AUDIT, GR_CREATE_ACL_MSG, dentry, p_mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode2(GR_DONT_AUDIT, GR_CREATE_ACL_MSG, dentry, p_mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+__u32
+gr_acl_handle_access(const struct dentry * dentry, const struct vfsmount * mnt,
+		     const int fmode)
+{
+	__u32 mode, reqmode = GR_FIND;
+
+	if ((fmode & S_IXOTH) && !S_ISDIR(dentry->d_inode->i_mode))
+		reqmode |= GR_EXEC;
+	if (fmode & S_IWOTH)
+		reqmode |= GR_WRITE;
+	if (fmode & S_IROTH)
+		reqmode |= GR_READ;
+
+	mode =
+	    gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS,
+			   mnt);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode3(GR_DO_AUDIT, GR_ACCESS_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : "",
+			       reqmode & GR_EXEC ? " executing" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode3(GR_DONT_AUDIT, GR_ACCESS_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : "",
+			       reqmode & GR_EXEC ? " executing" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+static __u32 generic_fs_handler(const struct dentry *dentry, const struct vfsmount *mnt, __u32 reqmode, const char *fmt)
+{
+	__u32 mode;
+
+	mode = gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS, mnt);
+
+	if (unlikely(((mode & (reqmode)) == (reqmode)) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, fmt, dentry, mnt);
+		return mode;
+	} else if (unlikely((mode & (reqmode)) != (reqmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, fmt, dentry, mnt);
+		return 0;
+	} else if (unlikely((mode & (reqmode)) != (reqmode)))
+		return 0;
+
+	return (reqmode);
+}
+
+__u32
+gr_acl_handle_rmdir(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE | GR_DELETE , GR_RMDIR_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_unlink(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE | GR_DELETE , GR_UNLINK_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_truncate(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_TRUNCATE_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_utime(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_ATIME_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_fchmod(const struct dentry *dentry, const struct vfsmount *mnt,
+		     mode_t mode)
+{
+	if (unlikely(dentry->d_inode && S_ISSOCK(dentry->d_inode->i_mode)))
+		return 1;
+
+	if (unlikely((mode != (mode_t)-1) && (mode & (S_ISUID | S_ISGID)))) {
+		return generic_fs_handler(dentry, mnt, GR_WRITE | GR_SETID,
+				   GR_FCHMOD_ACL_MSG);
+	} else {
+		return generic_fs_handler(dentry, mnt, GR_WRITE, GR_FCHMOD_ACL_MSG);
+	}
+}
+
+__u32
+gr_acl_handle_chmod(const struct dentry *dentry, const struct vfsmount *mnt,
+		    mode_t mode)
+{
+	if (unlikely((mode != (mode_t)-1) && (mode & (S_ISUID | S_ISGID)))) {
+		return generic_fs_handler(dentry, mnt, GR_WRITE | GR_SETID,
+				   GR_CHMOD_ACL_MSG);
+	} else {
+		return generic_fs_handler(dentry, mnt, GR_WRITE, GR_CHMOD_ACL_MSG);
+	}
+}
+
+__u32
+gr_acl_handle_chown(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_CHOWN_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_execve(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_EXEC, GR_EXEC_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_unix(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_READ | GR_WRITE,
+			   GR_UNIXCONNECT_ACL_MSG);
+}
+
+/* hardlinks require at minimum create permission,
+   any additional privilege required is based on the
+   privilege of the file being linked to
+*/
+__u32
+gr_acl_handle_link(const struct dentry * new_dentry,
+		   const struct dentry * parent_dentry,
+		   const struct vfsmount * parent_mnt,
+		   const struct dentry * old_dentry,
+		   const struct vfsmount * old_mnt, const char *to)
+{
+	__u32 mode;
+	__u32 needmode = GR_CREATE | GR_LINK;
+	__u32 needaudit = GR_AUDIT_CREATE | GR_AUDIT_LINK;
+
+	mode =
+	    gr_check_link(new_dentry, parent_dentry, parent_mnt, old_dentry,
+			  old_mnt);
+
+	if (unlikely(((mode & needmode) == needmode) && (mode & needaudit))) {
+		gr_log_fs_rbac_str(GR_DO_AUDIT, GR_LINK_ACL_MSG, old_dentry, old_mnt, to);
+		return mode;
+	} else if (unlikely(((mode & needmode) != needmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_str(GR_DONT_AUDIT, GR_LINK_ACL_MSG, old_dentry, old_mnt, to);
+		return 0;
+	} else if (unlikely((mode & needmode) != needmode))
+		return 0;
+
+	return 1;
+}
+
+__u32
+gr_acl_handle_symlink(const struct dentry * new_dentry,
+		      const struct dentry * parent_dentry,
+		      const struct vfsmount * parent_mnt, const char *from)
+{
+	__u32 needmode = GR_WRITE | GR_CREATE;
+	__u32 mode;
+
+	mode =
+	    gr_check_create(new_dentry, parent_dentry, parent_mnt,
+			    GR_CREATE | GR_AUDIT_CREATE |
+			    GR_WRITE | GR_AUDIT_WRITE | GR_SUPPRESS);
+
+	if (unlikely(mode & GR_WRITE && mode & GR_AUDITS)) {
+		gr_log_fs_str_rbac(GR_DO_AUDIT, GR_SYMLINK_ACL_MSG, from, new_dentry, parent_mnt);
+		return mode;
+	} else if (unlikely(((mode & needmode) != needmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_str_rbac(GR_DONT_AUDIT, GR_SYMLINK_ACL_MSG, from, new_dentry, parent_mnt);
+		return 0;
+	} else if (unlikely((mode & needmode) != needmode))
+		return 0;
+
+	return (GR_WRITE | GR_CREATE);
+}
+
+static __u32 generic_fs_create_handler(const struct dentry *new_dentry, const struct dentry *parent_dentry, const struct vfsmount *parent_mnt, __u32 reqmode, const char *fmt)
+{
+	__u32 mode;
+
+	mode = gr_check_create(new_dentry, parent_dentry, parent_mnt, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS);
+
+	if (unlikely(((mode & (reqmode)) == (reqmode)) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, fmt, new_dentry, parent_mnt);
+		return mode;
+	} else if (unlikely((mode & (reqmode)) != (reqmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, fmt, new_dentry, parent_mnt);
+		return 0;
+	} else if (unlikely((mode & (reqmode)) != (reqmode)))
+		return 0;
+
+	return (reqmode);
+}
+
+__u32
+gr_acl_handle_mknod(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt,
+		    const int mode)
+{
+	__u32 reqmode = GR_WRITE | GR_CREATE;
+	if (unlikely(mode & (S_ISUID | S_ISGID)))
+		reqmode |= GR_SETID;
+
+	return generic_fs_create_handler(new_dentry, parent_dentry, parent_mnt,
+				  reqmode, GR_MKNOD_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_mkdir(const struct dentry *new_dentry,
+		    const struct dentry *parent_dentry,
+		    const struct vfsmount *parent_mnt)
+{
+	return generic_fs_create_handler(new_dentry, parent_dentry, parent_mnt,
+				  GR_WRITE | GR_CREATE, GR_MKDIR_ACL_MSG);
+}
+
+#define RENAME_CHECK_SUCCESS(old, new) \
+	(((old & (GR_WRITE | GR_READ)) == (GR_WRITE | GR_READ)) && \
+	 ((new & (GR_WRITE | GR_READ)) == (GR_WRITE | GR_READ)))
+
+int
+gr_acl_handle_rename(struct dentry *new_dentry,
+		     struct dentry *parent_dentry,
+		     const struct vfsmount *parent_mnt,
+		     struct dentry *old_dentry,
+		     struct inode *old_parent_inode,
+		     struct vfsmount *old_mnt, const char *newname)
+{
+	__u32 comp1, comp2;
+	int error = 0;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	if (!new_dentry->d_inode) {
+		comp1 = gr_check_create(new_dentry, parent_dentry, parent_mnt,
+					GR_READ | GR_WRITE | GR_CREATE | GR_AUDIT_READ |
+					GR_AUDIT_WRITE | GR_AUDIT_CREATE | GR_SUPPRESS);
+		comp2 = gr_search_file(old_dentry, GR_READ | GR_WRITE |
+				       GR_DELETE | GR_AUDIT_DELETE |
+				       GR_AUDIT_READ | GR_AUDIT_WRITE |
+				       GR_SUPPRESS, old_mnt);
+	} else {
+		comp1 = gr_search_file(new_dentry, GR_READ | GR_WRITE |
+				       GR_CREATE | GR_DELETE |
+				       GR_AUDIT_CREATE | GR_AUDIT_DELETE |
+				       GR_AUDIT_READ | GR_AUDIT_WRITE |
+				       GR_SUPPRESS, parent_mnt);
+		comp2 =
+		    gr_search_file(old_dentry,
+				   GR_READ | GR_WRITE | GR_AUDIT_READ |
+				   GR_DELETE | GR_AUDIT_DELETE |
+				   GR_AUDIT_WRITE | GR_SUPPRESS, old_mnt);
+	}
+
+	if (RENAME_CHECK_SUCCESS(comp1, comp2) &&
+	    ((comp1 & GR_AUDITS) || (comp2 & GR_AUDITS)))
+		gr_log_fs_rbac_str(GR_DO_AUDIT, GR_RENAME_ACL_MSG, old_dentry, old_mnt, newname);
+	else if (!RENAME_CHECK_SUCCESS(comp1, comp2) && !(comp1 & GR_SUPPRESS)
+		 && !(comp2 & GR_SUPPRESS)) {
+		gr_log_fs_rbac_str(GR_DONT_AUDIT, GR_RENAME_ACL_MSG, old_dentry, old_mnt, newname);
+		error = -EACCES;
+	} else if (unlikely(!RENAME_CHECK_SUCCESS(comp1, comp2)))
+		error = -EACCES;
+
+	return error;
+}
+
+void
+gr_acl_handle_exit(void)
+{
+	u16 id;
+	char *rolename;
+	struct file *exec_file;
+
+	if (unlikely(current->acl_sp_role && gr_acl_is_enabled())) {
+		id = current->acl_role_id;
+		rolename = current->role->rolename;
+		gr_set_acls(1);
+		gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_SPROLEL_ACL_MSG, rolename, id);
+	}
+
+	write_lock(&grsec_exec_file_lock);
+	exec_file = current->exec_file;
+	current->exec_file = NULL;
+	write_unlock(&grsec_exec_file_lock);
+
+	if (exec_file)
+		fput(exec_file);
+}
+
+int
+gr_acl_handle_procpidmem(const struct task_struct *task)
+{
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	if (task->acl->mode & GR_PROTPROCFD)
+		return -EACCES;
+
+	return 0;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/gracl_ip.c grsecurity226/grsecurity/gracl_ip.c
--- linux-2.6.13.1.org/grsecurity/gracl_ip.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl_ip.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,255 @@
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <net/sock.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/smp_lock.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+#define GR_BIND 	0x01
+#define GR_CONNECT 	0x02
+#define GR_INVERT 	0x04
+
+static const char * gr_protocols[256] = {
+	"ip", "icmp", "igmp", "ggp", "ipencap", "st", "tcp", "cbt",
+	"egp", "igp", "bbn-rcc", "nvp", "pup", "argus", "emcon", "xnet",
+	"chaos", "udp", "mux", "dcn", "hmp", "prm", "xns-idp", "trunk-1",
+	"trunk-2", "leaf-1", "leaf-2", "rdp", "irtp", "iso-tp4", "netblt", "mfe-nsp",
+	"merit-inp", "sep", "3pc", "idpr", "xtp", "ddp", "idpr-cmtp", "tp++",
+	"il", "ipv6", "sdrp", "ipv6-route", "ipv6-frag", "idrp", "rsvp", "gre",
+	"mhrp", "bna", "ipv6-crypt", "ipv6-auth", "i-nlsp", "swipe", "narp", "mobile",
+	"tlsp", "skip", "ipv6-icmp", "ipv6-nonxt", "ipv6-opts", "unknown:61", "cftp", "unknown:63",
+	"sat-expak", "kryptolan", "rvd", "ippc", "unknown:68", "sat-mon", "visa", "ipcv",
+	"cpnx", "cphb", "wsn", "pvp", "br-sat-mon", "sun-nd", "wb-mon", "wb-expak", 
+	"iso-ip", "vmtp", "secure-vmtp", "vines", "ttp", "nfsnet-igp", "dgp", "tcf", 
+	"eigrp", "ospf", "sprite-rpc", "larp", "mtp", "ax.25", "ipip", "micp",
+	"scc-sp", "etherip", "encap", "unknown:99", "gmtp", "ifmp", "pnni", "pim",
+	"aris", "scps", "qnx", "a/n", "ipcomp", "snp", "compaq-peer", "ipx-in-ip",
+	"vrrp", "pgm", "unknown:114", "l2tp", "ddx", "iatp", "stp", "srp",
+	"uti", "smp", "sm", "ptp", "isis", "fire", "crtp", "crdup",
+	"sscopmce", "iplt", "sps", "pipe", "sctp", "fc", "unkown:134", "unknown:135",
+	"unknown:136", "unknown:137", "unknown:138", "unknown:139", "unknown:140", "unknown:141", "unknown:142", "unknown:143",
+	"unknown:144", "unknown:145", "unknown:146", "unknown:147", "unknown:148", "unknown:149", "unknown:150", "unknown:151",
+	"unknown:152", "unknown:153", "unknown:154", "unknown:155", "unknown:156", "unknown:157", "unknown:158", "unknown:159",
+	"unknown:160", "unknown:161", "unknown:162", "unknown:163", "unknown:164", "unknown:165", "unknown:166", "unknown:167",
+	"unknown:168", "unknown:169", "unknown:170", "unknown:171", "unknown:172", "unknown:173", "unknown:174", "unknown:175",
+	"unknown:176", "unknown:177", "unknown:178", "unknown:179", "unknown:180", "unknown:181", "unknown:182", "unknown:183",
+	"unknown:184", "unknown:185", "unknown:186", "unknown:187", "unknown:188", "unknown:189", "unknown:190", "unknown:191",
+	"unknown:192", "unknown:193", "unknown:194", "unknown:195", "unknown:196", "unknown:197", "unknown:198", "unknown:199",
+	"unknown:200", "unknown:201", "unknown:202", "unknown:203", "unknown:204", "unknown:205", "unknown:206", "unknown:207",
+	"unknown:208", "unknown:209", "unknown:210", "unknown:211", "unknown:212", "unknown:213", "unknown:214", "unknown:215",
+	"unknown:216", "unknown:217", "unknown:218", "unknown:219", "unknown:220", "unknown:221", "unknown:222", "unknown:223",
+	"unknown:224", "unknown:225", "unknown:226", "unknown:227", "unknown:228", "unknown:229", "unknown:230", "unknown:231",
+	"unknown:232", "unknown:233", "unknown:234", "unknown:235", "unknown:236", "unknown:237", "unknown:238", "unknown:239",
+	"unknown:240", "unknown:241", "unknown:242", "unknown:243", "unknown:244", "unknown:245", "unknown:246", "unknown:247",
+	"unknown:248", "unknown:249", "unknown:250", "unknown:251", "unknown:252", "unknown:253", "unknown:254", "unknown:255",
+	};
+
+static const char * gr_socktypes[11] = {
+	"unknown:0", "stream", "dgram", "raw", "rdm", "seqpacket", "unknown:6", 
+	"unknown:7", "unknown:8", "unknown:9", "packet"
+	};
+
+const char *
+gr_proto_to_name(unsigned char proto)
+{
+	return gr_protocols[proto];
+}
+
+const char *
+gr_socktype_to_name(unsigned char type)
+{
+	return gr_socktypes[type];
+}
+
+int
+gr_search_socket(const int domain, const int type, const int protocol)
+{
+	struct acl_subject_label *curr;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		goto exit;
+
+	if ((domain < 0) || (type < 0) || (protocol < 0) || (domain != PF_INET)
+	    || (domain >= NPROTO) || (type >= SOCK_MAX) || (protocol > 255))
+		goto exit;	// let the kernel handle it
+
+	curr = current->acl;
+
+	if (!curr->ips)
+		goto exit;
+
+	if ((curr->ip_type & (1 << type)) &&
+	    (curr->ip_proto[protocol / 32] & (1 << (protocol % 32))))
+		goto exit;
+
+	if (curr->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		/* we don't place acls on raw sockets , and sometimes
+		   dgram/ip sockets are opened for ioctl and not
+		   bind/connect, so we'll fake a bind learn log */
+		if (type == SOCK_RAW || type == SOCK_PACKET) {
+			__u32 fakeip = 0;
+			security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+				       current->role->roletype, current->uid,
+				       current->gid, current->exec_file ?
+				       gr_to_filename(current->exec_file->f_dentry,
+				       current->exec_file->f_vfsmnt) :
+				       curr->filename, curr->filename,
+				       NIPQUAD(fakeip), 0, type,
+				       protocol, GR_CONNECT, 
+NIPQUAD(current->signal->curr_ip));
+		} else if ((type == SOCK_DGRAM) && (protocol == IPPROTO_IP)) {
+			__u32 fakeip = 0;
+			security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+				       current->role->roletype, current->uid,
+				       current->gid, current->exec_file ?
+				       gr_to_filename(current->exec_file->f_dentry,
+				       current->exec_file->f_vfsmnt) :
+				       curr->filename, curr->filename,
+				       NIPQUAD(fakeip), 0, type,
+				       protocol, GR_BIND, NIPQUAD(current->signal->curr_ip));
+		}
+		/* we'll log when they use connect or bind */
+		goto exit;
+	}
+
+	gr_log_str3(GR_DONT_AUDIT, GR_SOCK_MSG, "inet", 
+		    gr_socktype_to_name(type), gr_proto_to_name(protocol));
+
+	return 0;
+      exit:
+	return 1;
+}
+
+static __inline__ int
+gr_search_connectbind(const int mode, const struct sock *sk,
+		      const struct sockaddr_in *addr, const int type)
+{
+	struct acl_subject_label *curr;
+	struct acl_ip_label *ip;
+	unsigned long i;
+	__u32 ip_addr = 0;
+	__u16 ip_port = 0;
+
+	if (unlikely(!gr_acl_is_enabled() || sk->sk_family != PF_INET))
+		return 1;
+
+	curr = current->acl;
+
+	if (!curr->ips)
+		return 1;
+
+	ip_addr = addr->sin_addr.s_addr;
+	ip_port = ntohs(addr->sin_port);
+
+	if (curr->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+			       current->role->roletype, current->uid,
+			       current->gid, current->exec_file ?
+			       gr_to_filename(current->exec_file->f_dentry,
+			       current->exec_file->f_vfsmnt) :
+			       curr->filename, curr->filename,
+			       NIPQUAD(ip_addr), ip_port, type,
+			       sk->sk_protocol, mode, NIPQUAD(current->signal->curr_ip));
+		return 1;
+	}
+
+	for (i = 0; i < curr->ip_num; i++) {
+		ip = *(curr->ips + i);
+		if ((ip->mode & mode) &&
+		    (ip_port >= ip->low) &&
+		    (ip_port <= ip->high) &&
+		    ((ntohl(ip_addr) & ip->netmask) ==
+		     (ntohl(ip->addr) & ip->netmask))
+		    && (ip->
+			proto[sk->sk_protocol / 32] & (1 << (sk->sk_protocol % 32)))
+		    && (ip->type & (1 << type))) {
+			if (ip->mode & GR_INVERT)
+				goto denied;
+			else
+				return 1;
+		}
+	}
+
+denied:
+	if (mode == GR_BIND)
+		gr_log_int5_str2(GR_DONT_AUDIT, GR_BIND_ACL_MSG, NIPQUAD(ip_addr), ip_port, gr_socktype_to_name(type), gr_proto_to_name(sk->sk_protocol));
+	else if (mode == GR_CONNECT)
+		gr_log_int5_str2(GR_DONT_AUDIT, GR_CONNECT_ACL_MSG, NIPQUAD(ip_addr), ip_port, gr_socktype_to_name(type), gr_proto_to_name(sk->sk_protocol));
+
+	return 0;
+}
+
+int
+gr_search_connect(const struct socket *sock, const struct sockaddr_in *addr)
+{
+	return gr_search_connectbind(GR_CONNECT, sock->sk, addr, sock->type);
+}
+
+int
+gr_search_bind(const struct socket *sock, const struct sockaddr_in *addr)
+{
+	return gr_search_connectbind(GR_BIND, sock->sk, addr, sock->type);
+}
+
+int gr_search_listen(const struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_in addr;
+
+	addr.sin_addr.s_addr = inet_sk(sk)->saddr;
+	addr.sin_port = inet_sk(sk)->sport;
+
+	return gr_search_connectbind(GR_BIND, sock->sk, &addr, sock->type);
+}
+
+int gr_search_accept(const struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_in addr;
+
+	addr.sin_addr.s_addr = inet_sk(sk)->saddr;
+	addr.sin_port = inet_sk(sk)->sport;
+
+	return gr_search_connectbind(GR_BIND, sock->sk, &addr, sock->type);
+}
+
+int
+gr_search_udp_sendmsg(const struct sock *sk, const struct sockaddr_in *addr)
+{
+	if (addr)
+		return gr_search_connectbind(GR_CONNECT, sk, addr, SOCK_DGRAM);
+	else {
+		struct sockaddr_in sin;
+		const struct inet_sock *inet = inet_sk(sk);
+
+		sin.sin_addr.s_addr = inet->daddr;
+		sin.sin_port = inet->dport;
+
+		return gr_search_connectbind(GR_CONNECT, sk, &sin, SOCK_DGRAM);
+	}
+}
+
+int
+gr_search_udp_recvmsg(const struct sock *sk, const struct sk_buff *skb)
+{
+	struct sockaddr_in sin;
+
+	if (unlikely(skb->len < sizeof (struct udphdr)))
+		return 1;	// skip this packet
+
+	sin.sin_addr.s_addr = skb->nh.iph->saddr;
+	sin.sin_port = skb->h.uh->source;
+
+	return gr_search_connectbind(GR_CONNECT, sk, &sin, SOCK_DGRAM);
+}
diff -Nur linux-2.6.13.1.org/grsecurity/gracl_learn.c grsecurity226/grsecurity/gracl_learn.c
--- linux-2.6.13.1.org/grsecurity/gracl_learn.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl_learn.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,204 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/smp_lock.h>
+#include <linux/string.h>
+#include <linux/file.h>
+#include <linux/types.h>
+#include <linux/vmalloc.h>
+#include <linux/grinternal.h>
+
+extern ssize_t write_grsec_handler(struct file * file, const char __user * buf,
+				   size_t count, loff_t *ppos);
+extern int gr_acl_is_enabled(void);
+
+static DECLARE_WAIT_QUEUE_HEAD(learn_wait);
+static int gr_learn_attached;
+
+/* use a 512k buffer */
+#define LEARN_BUFFER_SIZE (512 * 1024)
+
+static spinlock_t gr_learn_lock = SPIN_LOCK_UNLOCKED;
+static DECLARE_MUTEX(gr_learn_user_sem);
+
+/* we need to maintain two buffers, so that the kernel context of grlearn
+   uses a semaphore around the userspace copying, and the other kernel contexts
+   use a spinlock when copying into the buffer, since they cannot sleep
+*/
+static char *learn_buffer;
+static char *learn_buffer_user;
+static int learn_buffer_len;
+static int learn_buffer_user_len;
+
+static ssize_t
+read_learn(struct file *file, char __user * buf, size_t count, loff_t * ppos)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t retval = 0;
+
+	add_wait_queue(&learn_wait, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	do {
+		down(&gr_learn_user_sem);
+		spin_lock(&gr_learn_lock);
+		if (learn_buffer_len)
+			break;
+		spin_unlock(&gr_learn_lock);
+		up(&gr_learn_user_sem);
+		if (file->f_flags & O_NONBLOCK) {
+			retval = -EAGAIN;
+			goto out;
+		}
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			goto out;
+		}
+
+		schedule();
+	} while (1);
+
+	memcpy(learn_buffer_user, learn_buffer, learn_buffer_len);
+	learn_buffer_user_len = learn_buffer_len;
+	retval = learn_buffer_len;
+	learn_buffer_len = 0;
+
+	spin_unlock(&gr_learn_lock);
+
+	if (copy_to_user(buf, learn_buffer_user, learn_buffer_user_len))
+		retval = -EFAULT;
+
+	up(&gr_learn_user_sem);
+out:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&learn_wait, &wait);
+	return retval;
+}
+
+static unsigned int
+poll_learn(struct file * file, poll_table * wait)
+{
+	poll_wait(file, &learn_wait, wait);
+
+	if (learn_buffer_len)
+		return (POLLIN | POLLRDNORM);
+
+	return 0;
+}
+
+void
+gr_clear_learn_entries(void)
+{
+	char *tmp;
+
+	down(&gr_learn_user_sem);
+	if (learn_buffer != NULL) {
+		spin_lock(&gr_learn_lock);
+		tmp = learn_buffer;
+		learn_buffer = NULL;
+		spin_unlock(&gr_learn_lock);
+		vfree(learn_buffer);
+	}
+	if (learn_buffer_user != NULL) {
+		vfree(learn_buffer_user);
+		learn_buffer_user = NULL;
+	}
+	learn_buffer_len = 0;
+	up(&gr_learn_user_sem);
+
+	return;
+}
+
+void
+gr_add_learn_entry(const char *fmt, ...)
+{
+	va_list args;
+	unsigned int len;
+
+	if (!gr_learn_attached)
+		return;
+
+	spin_lock(&gr_learn_lock);
+
+	/* leave a gap at the end so we know when it's "full" but don't have to
+	   compute the exact length of the string we're trying to append
+	*/
+	if (learn_buffer_len > LEARN_BUFFER_SIZE - 16384) {
+		spin_unlock(&gr_learn_lock);
+		wake_up_interruptible(&learn_wait);
+		return;
+	}
+	if (learn_buffer == NULL) {
+		spin_unlock(&gr_learn_lock);
+		return;
+	}
+
+	va_start(args, fmt);
+	len = vsnprintf(learn_buffer + learn_buffer_len, LEARN_BUFFER_SIZE - learn_buffer_len, fmt, args);
+	va_end(args);
+
+	learn_buffer_len += len + 1;
+
+	spin_unlock(&gr_learn_lock);
+	wake_up_interruptible(&learn_wait);
+
+	return;
+}
+
+static int
+open_learn(struct inode *inode, struct file *file)
+{
+	if (file->f_mode & FMODE_READ && gr_learn_attached)
+		return -EBUSY;
+	if (file->f_mode & FMODE_READ) {
+		down(&gr_learn_user_sem);
+		if (learn_buffer == NULL)
+			learn_buffer = vmalloc(LEARN_BUFFER_SIZE);
+		if (learn_buffer_user == NULL)
+			learn_buffer_user = vmalloc(LEARN_BUFFER_SIZE);
+		if (learn_buffer == NULL)
+			return -ENOMEM;
+		if (learn_buffer_user == NULL)
+			return -ENOMEM;
+		learn_buffer_len = 0;
+		learn_buffer_user_len = 0;
+		gr_learn_attached = 1;
+		up(&gr_learn_user_sem);
+	}
+	return 0;
+}
+
+static int
+close_learn(struct inode *inode, struct file *file)
+{
+	char *tmp;
+
+	if (file->f_mode & FMODE_READ) {
+		down(&gr_learn_user_sem);
+		if (learn_buffer != NULL) {
+			spin_lock(&gr_learn_lock);
+			tmp = learn_buffer;
+			learn_buffer = NULL;
+			spin_unlock(&gr_learn_lock);
+			vfree(tmp);
+		}
+		if (learn_buffer_user != NULL) {
+			vfree(learn_buffer_user);
+			learn_buffer_user = NULL;
+		}
+		learn_buffer_len = 0;
+		learn_buffer_user_len = 0;
+		gr_learn_attached = 0;
+		up(&gr_learn_user_sem);
+	}
+
+	return 0;
+}
+		
+struct file_operations grsec_fops = {
+	.read		= read_learn,
+	.write		= write_grsec_handler,
+	.open		= open_learn,
+	.release	= close_learn,
+	.poll		= poll_learn,
+};
diff -Nur linux-2.6.13.1.org/grsecurity/gracl_res.c grsecurity226/grsecurity/gracl_res.c
--- linux-2.6.13.1.org/grsecurity/gracl_res.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl_res.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,42 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+#include <linux/grinternal.h>
+
+static const char *restab_log[] = {
+	[RLIMIT_CPU] = "RLIMIT_CPU",
+	[RLIMIT_FSIZE] = "RLIMIT_FSIZE",
+	[RLIMIT_DATA] = "RLIMIT_DATA",
+	[RLIMIT_STACK] = "RLIMIT_STACK",
+	[RLIMIT_CORE] = "RLIMIT_CORE",
+	[RLIMIT_RSS] = "RLIMIT_RSS",
+	[RLIMIT_NPROC] = "RLIMIT_NPROC",
+	[RLIMIT_NOFILE] = "RLIMIT_NOFILE",
+	[RLIMIT_MEMLOCK] = "RLIMIT_MEMLOCK",
+	[RLIMIT_AS] = "RLIMIT_AS",
+	[RLIMIT_LOCKS] = "RLIMIT_LOCKS",
+	[RLIMIT_LOCKS + 1] = "RLIMIT_CRASH"
+};
+
+void
+gr_log_resource(const struct task_struct *task,
+		const int res, const unsigned long wanted, const int gt)
+{
+	if (res == RLIMIT_NPROC && 
+	    (cap_raised(task->cap_effective, CAP_SYS_ADMIN) || 
+	     cap_raised(task->cap_effective, CAP_SYS_RESOURCE)))
+		return;
+	else if (res == RLIMIT_MEMLOCK &&
+		 cap_raised(task->cap_effective, CAP_IPC_LOCK))
+		return;
+
+	preempt_disable();
+
+	if (unlikely(((gt && wanted > task->signal->rlim[res].rlim_cur) ||
+		      (!gt && wanted >= task->signal->rlim[res].rlim_cur)) &&
+		     task->signal->rlim[res].rlim_cur != RLIM_INFINITY))
+		gr_log_res_ulong2_str(GR_DONT_AUDIT, GR_RESOURCE_MSG, task, wanted, restab_log[res], task->signal->rlim[res].rlim_cur);
+	preempt_enable_no_resched();
+
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/gracl_segv.c grsecurity226/grsecurity/gracl_segv.c
--- linux-2.6.13.1.org/grsecurity/gracl_segv.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl_segv.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,295 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+#include <net/sock.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+static struct crash_uid *uid_set;
+static unsigned short uid_used;
+static spinlock_t gr_uid_lock = SPIN_LOCK_UNLOCKED;
+extern rwlock_t gr_inode_lock;
+extern struct acl_subject_label *
+	lookup_acl_subj_label(const ino_t inode, const dev_t dev,
+			      struct acl_role_label *role);
+extern int specific_send_sig_info(int sig, struct siginfo *info, struct task_struct *t);
+
+int
+gr_init_uidset(void)
+{
+	uid_set =
+	    kmalloc(GR_UIDTABLE_MAX * sizeof (struct crash_uid), GFP_KERNEL);
+	uid_used = 0;
+
+	return uid_set ? 1 : 0;
+}
+
+void
+gr_free_uidset(void)
+{
+	if (uid_set)
+		kfree(uid_set);
+
+	return;
+}
+
+int
+gr_find_uid(const uid_t uid)
+{
+	struct crash_uid *tmp = uid_set;
+	uid_t buid;
+	int low = 0, high = uid_used - 1, mid;
+
+	while (high >= low) {
+		mid = (low + high) >> 1;
+		buid = tmp[mid].uid;
+		if (buid == uid)
+			return mid;
+		if (buid > uid)
+			high = mid - 1;
+		if (buid < uid)
+			low = mid + 1;
+	}
+
+	return -1;
+}
+
+static __inline__ void
+gr_insertsort(void)
+{
+	unsigned short i, j;
+	struct crash_uid index;
+
+	for (i = 1; i < uid_used; i++) {
+		index = uid_set[i];
+		j = i;
+		while ((j > 0) && uid_set[j - 1].uid > index.uid) {
+			uid_set[j] = uid_set[j - 1];
+			j--;
+		}
+		uid_set[j] = index;
+	}
+
+	return;
+}
+
+static __inline__ void
+gr_insert_uid(const uid_t uid, const unsigned long expires)
+{
+	int loc;
+
+	if (uid_used == GR_UIDTABLE_MAX)
+		return;
+
+	loc = gr_find_uid(uid);
+
+	if (loc >= 0) {
+		uid_set[loc].expires = expires;
+		return;
+	}
+
+	uid_set[uid_used].uid = uid;
+	uid_set[uid_used].expires = expires;
+	uid_used++;
+
+	gr_insertsort();
+
+	return;
+}
+
+void
+gr_remove_uid(const unsigned short loc)
+{
+	unsigned short i;
+
+	for (i = loc + 1; i < uid_used; i++)
+		uid_set[i - 1] = uid_set[i];
+
+	uid_used--;
+
+	return;
+}
+
+int
+gr_check_crash_uid(const uid_t uid)
+{
+	int loc;
+	int ret = 0;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	spin_lock(&gr_uid_lock);
+	loc = gr_find_uid(uid);
+
+	if (loc < 0)
+		goto out_unlock;
+
+	if (time_before_eq(uid_set[loc].expires, get_seconds()))
+		gr_remove_uid(loc);
+	else
+		ret = 1;
+
+out_unlock:
+	spin_unlock(&gr_uid_lock);
+	return ret;
+}
+
+static __inline__ int
+proc_is_setxid(const struct task_struct *task)
+{
+	if (task->uid != task->euid || task->uid != task->suid ||
+	    task->uid != task->fsuid)
+		return 1;
+	if (task->gid != task->egid || task->gid != task->sgid ||
+	    task->gid != task->fsgid)
+		return 1;
+
+	return 0;
+}
+static __inline__ int
+gr_fake_force_sig(int sig, struct task_struct *t)
+{
+	unsigned long int flags;
+	int ret;
+
+	spin_lock_irqsave(&t->sighand->siglock, flags);
+	if (sigismember(&t->blocked, sig) || t->sighand->action[sig-1].sa.sa_handler == SIG_IGN) {
+		t->sighand->action[sig-1].sa.sa_handler = SIG_DFL;
+		sigdelset(&t->blocked, sig);
+		recalc_sigpending_tsk(t);
+	}
+	ret = specific_send_sig_info(sig, (void*)1L, t);
+	spin_unlock_irqrestore(&t->sighand->siglock, flags);
+
+	return ret;
+}
+
+void
+gr_handle_crash(struct task_struct *task, const int sig)
+{
+	struct acl_subject_label *curr;
+	struct acl_subject_label *curr2;
+	struct task_struct *tsk, *tsk2;
+
+	if (sig != SIGSEGV && sig != SIGKILL && sig != SIGBUS && sig != SIGILL)
+		return;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return;
+
+	curr = task->acl;
+
+	if (!(curr->resmask & (1 << GR_CRASH_RES)))
+		return;
+
+	if (time_before_eq(curr->expires, get_seconds())) {
+		curr->expires = 0;
+		curr->crashes = 0;
+	}
+
+	curr->crashes++;
+
+	if (!curr->expires)
+		curr->expires = get_seconds() + curr->res[GR_CRASH_RES].rlim_max;
+
+	if ((curr->crashes >= curr->res[GR_CRASH_RES].rlim_cur) &&
+	    time_after(curr->expires, get_seconds())) {
+		if (task->uid && proc_is_setxid(task)) {
+			gr_log_crash1(GR_DONT_AUDIT, GR_SEGVSTART_ACL_MSG, task, curr->res[GR_CRASH_RES].rlim_max);
+			spin_lock(&gr_uid_lock);
+			gr_insert_uid(task->uid, curr->expires);
+			spin_unlock(&gr_uid_lock);
+			curr->expires = 0;
+			curr->crashes = 0;
+			read_lock(&tasklist_lock);
+			do_each_thread(tsk2, tsk) {
+				if (tsk != task && tsk->uid == task->uid)
+					gr_fake_force_sig(SIGKILL, tsk);
+			} while_each_thread(tsk2, tsk);
+			read_unlock(&tasklist_lock);
+		} else {
+			gr_log_crash2(GR_DONT_AUDIT, GR_SEGVNOSUID_ACL_MSG, task, curr->res[GR_CRASH_RES].rlim_max);
+			read_lock(&tasklist_lock);
+			do_each_thread(tsk2, tsk) {
+				if (likely(tsk != task)) {
+					curr2 = tsk->acl;
+
+					if (curr2->device == curr->device &&
+					    curr2->inode == curr->inode)
+						gr_fake_force_sig(SIGKILL, tsk);
+				}
+			} while_each_thread(tsk2, tsk);
+			read_unlock(&tasklist_lock);
+		}
+	}
+
+	return;
+}
+
+int
+gr_check_crash_exec(const struct file *filp)
+{
+	struct acl_subject_label *curr;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	read_lock(&gr_inode_lock);
+	curr = lookup_acl_subj_label(filp->f_dentry->d_inode->i_ino,
+				     filp->f_dentry->d_inode->i_sb->s_dev,
+				     current->role);
+	read_unlock(&gr_inode_lock);
+
+	if (!curr || !(curr->resmask & (1 << GR_CRASH_RES)) ||
+	    (!curr->crashes && !curr->expires))
+		return 0;
+
+	if ((curr->crashes >= curr->res[GR_CRASH_RES].rlim_cur) &&
+	    time_after(curr->expires, get_seconds()))
+		return 1;
+	else if (time_before_eq(curr->expires, get_seconds())) {
+		curr->crashes = 0;
+		curr->expires = 0;
+	}
+
+	return 0;
+}
+
+void
+gr_handle_alertkill(struct task_struct *task)
+{
+	struct acl_subject_label *curracl;
+	__u32 curr_ip;
+	struct task_struct *p, *p2;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return;
+
+	curracl = task->acl;
+	curr_ip = task->signal->curr_ip;
+
+	if ((curracl->mode & GR_KILLIPPROC) && curr_ip) {
+		read_lock(&tasklist_lock);
+		do_each_thread(p2, p) {
+			if (p->signal->curr_ip == curr_ip)
+				gr_fake_force_sig(SIGKILL, p);
+		} while_each_thread(p2, p);
+		read_unlock(&tasklist_lock);
+	} else if (curracl->mode & GR_KILLPROC)
+		gr_fake_force_sig(SIGKILL, task);
+
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/gracl_shm.c grsecurity226/grsecurity/gracl_shm.c
--- linux-2.6.13.1.org/grsecurity/gracl_shm.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/gracl_shm.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,33 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/ipc.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const time_t shm_createtime, const uid_t cuid, const int shmid)
+{
+	struct task_struct *task;
+
+	if (!gr_acl_is_enabled())
+		return 1;
+
+	task = find_task_by_pid(shm_cprid);
+
+	if (unlikely(!task))
+		task = find_task_by_pid(shm_lapid);
+
+	if (unlikely(task && (time_before((unsigned long)task->start_time.tv_sec, (unsigned long)shm_createtime) ||
+			      (task->pid == shm_lapid)) &&
+		     (task->acl->mode & GR_PROTSHM) &&
+		     (task->acl != current->acl))) {
+		gr_log_int3(GR_DONT_AUDIT, GR_SHMAT_ACL_MSG, cuid, shm_cprid, shmid);
+		return 0;
+	}
+
+	return 1;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_chdir.c grsecurity226/grsecurity/grsec_chdir.c
--- linux-2.6.13.1.org/grsecurity/grsec_chdir.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_chdir.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,19 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_chdir(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	if ((grsec_enable_chdir && grsec_enable_group &&
+	     in_group_p(grsec_audit_gid)) || (grsec_enable_chdir &&
+					      !grsec_enable_group)) {
+		gr_log_fs_generic(GR_DO_AUDIT, GR_CHDIR_AUDIT_MSG, dentry, mnt);
+	}
+#endif
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_chroot.c grsecurity226/grsecurity/grsec_chroot.c
--- linux-2.6.13.1.org/grsecurity/grsec_chroot.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_chroot.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,332 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/types.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_chroot_unix(const pid_t pid)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	struct pid *spid = NULL;
+
+	if (unlikely(!grsec_enable_chroot_unix))
+		return 1;
+
+	if (likely(!proc_is_chrooted(current)))
+		return 1;
+
+	read_lock(&tasklist_lock);
+
+	spid = find_pid(PIDTYPE_PID, pid);
+	if (spid) {
+		struct task_struct *p;
+		p = pid_task(&spid->pid_list, PIDTYPE_PID);
+		task_lock(p);
+		if (unlikely(!have_same_root(current, p))) {
+			task_unlock(p);
+			read_unlock(&tasklist_lock);
+			gr_log_noargs(GR_DONT_AUDIT, GR_UNIX_CHROOT_MSG);
+			return 0;
+		}
+		task_unlock(p);
+	}
+	read_unlock(&tasklist_lock);
+#endif
+	return 1;
+}
+
+int
+gr_handle_chroot_nice(void)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	if (grsec_enable_chroot_nice && proc_is_chrooted(current)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_NICE_CHROOT_MSG);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_setpriority(struct task_struct *p, const int niceval)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	if (grsec_enable_chroot_nice && (niceval < task_nice(p))
+			&& proc_is_chrooted(current)) {
+		gr_log_str_int(GR_DONT_AUDIT, GR_PRIORITY_CHROOT_MSG, p->comm, p->pid);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_rawio(const struct inode *inode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (grsec_enable_chroot_caps && proc_is_chrooted(current) && 
+	    inode && S_ISBLK(inode->i_mode) && !capable(CAP_SYS_RAWIO))
+		return 1;
+#endif
+	return 0;
+}
+
+int
+gr_pid_is_chrooted(struct task_struct *p)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	if (!grsec_enable_chroot_findtask || !proc_is_chrooted(current) || !p)
+		return 0;
+
+	task_lock(p);
+	if ((p->exit_state & (EXIT_ZOMBIE | EXIT_DEAD)) ||
+	    !have_same_root(current, p)) {
+		task_unlock(p);
+		return 1;
+	}
+	task_unlock(p);
+#endif
+	return 0;
+}
+
+EXPORT_SYMBOL(gr_pid_is_chrooted);
+
+#if defined(CONFIG_GRKERNSEC_CHROOT_DOUBLE) || defined(CONFIG_GRKERNSEC_CHROOT_FCHDIR)
+int gr_is_outside_chroot(const struct dentry *u_dentry, const struct vfsmount *u_mnt)
+{
+	struct dentry *dentry = (struct dentry *)u_dentry;
+	struct vfsmount *mnt = (struct vfsmount *)u_mnt;
+	struct dentry *realroot;
+	struct vfsmount *realrootmnt;
+	struct dentry *currentroot;
+	struct vfsmount *currentmnt;
+	int ret = 1;
+
+	read_lock(&child_reaper->fs->lock);
+	realrootmnt = mntget(child_reaper->fs->rootmnt);
+	realroot = dget(child_reaper->fs->root);
+	read_unlock(&child_reaper->fs->lock);
+
+	read_lock(&current->fs->lock);
+	currentmnt = mntget(current->fs->rootmnt);
+	currentroot = dget(current->fs->root);
+	read_unlock(&current->fs->lock);
+
+	spin_lock(&dcache_lock);
+	for (;;) {
+		if (unlikely((dentry == realroot && mnt == realrootmnt)
+		     || (dentry == currentroot && mnt == currentmnt)))
+			break;
+		if (unlikely(dentry == mnt->mnt_root || IS_ROOT(dentry))) {
+			if (mnt->mnt_parent == mnt)
+				break;
+			dentry = mnt->mnt_mountpoint;
+			mnt = mnt->mnt_parent;
+			continue;
+		}
+		dentry = dentry->d_parent;
+	}
+	spin_unlock(&dcache_lock);
+
+	dput(currentroot);
+	mntput(currentmnt);
+
+	/* access is outside of chroot */
+	if (dentry == realroot && mnt == realrootmnt)
+		ret = 0;
+
+	dput(realroot);
+	mntput(realrootmnt);
+	return ret;
+}
+#endif
+
+int
+gr_chroot_fchdir(struct dentry *u_dentry, struct vfsmount *u_mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	if (!grsec_enable_chroot_fchdir)
+		return 1;
+
+	if (!proc_is_chrooted(current))
+		return 1;
+	else if (!gr_is_outside_chroot(u_dentry, u_mnt)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_FCHDIR_MSG, u_dentry, u_mnt);
+		return 0;
+	}
+#endif
+	return 1;
+}
+
+int
+gr_chroot_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const time_t shm_createtime)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	struct pid *pid = NULL;
+	time_t starttime;
+
+	if (unlikely(!grsec_enable_chroot_shmat))
+		return 1;
+
+	if (likely(!proc_is_chrooted(current)))
+		return 1;
+
+	read_lock(&tasklist_lock);
+
+	pid = find_pid(PIDTYPE_PID, shm_cprid);
+	if (pid) {
+		struct task_struct *p;
+		p = pid_task(&pid->pid_list, PIDTYPE_PID);
+		task_lock(p);
+		starttime = p->start_time.tv_sec;
+		if (unlikely(!have_same_root(current, p) &&
+			     time_before((unsigned long)starttime, (unsigned long)shm_createtime))) {
+			task_unlock(p);
+			read_unlock(&tasklist_lock);
+			gr_log_noargs(GR_DONT_AUDIT, GR_SHMAT_CHROOT_MSG);
+			return 0;
+		}
+		task_unlock(p);
+	} else {
+		pid = find_pid(PIDTYPE_PID, shm_lapid);
+		if (pid) {
+			struct task_struct *p;
+			p = pid_task(&pid->pid_list, PIDTYPE_PID);
+			task_lock(p);
+			if (unlikely(!have_same_root(current, p))) {
+				task_unlock(p);
+				read_unlock(&tasklist_lock);
+				gr_log_noargs(GR_DONT_AUDIT, GR_SHMAT_CHROOT_MSG);
+				return 0;
+			}
+			task_unlock(p);
+		}
+	}
+
+	read_unlock(&tasklist_lock);
+#endif
+	return 1;
+}
+
+void
+gr_log_chroot_exec(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	if (grsec_enable_chroot_execlog && proc_is_chrooted(current))
+		gr_log_fs_generic(GR_DO_AUDIT, GR_EXEC_CHROOT_MSG, dentry, mnt);
+#endif
+	return;
+}
+
+int
+gr_handle_chroot_mknod(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const int mode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	if (grsec_enable_chroot_mknod && !S_ISFIFO(mode) && !S_ISREG(mode) && 
+	    proc_is_chrooted(current)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_MKNOD_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_mount(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const char *dev_name)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	if (grsec_enable_chroot_mount && proc_is_chrooted(current)) {
+		gr_log_str_fs(GR_DONT_AUDIT, GR_MOUNT_CHROOT_MSG, dev_name, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_pivot(void)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	if (grsec_enable_chroot_pivot && proc_is_chrooted(current)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_PIVOT_CHROOT_MSG);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_chroot(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	if (grsec_enable_chroot_double && proc_is_chrooted(current) &&
+	    !gr_is_outside_chroot(dentry, mnt)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+void
+gr_handle_chroot_caps(struct task_struct *task)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (grsec_enable_chroot_caps && proc_is_chrooted(task)) {
+		task->cap_permitted =
+		    cap_drop(task->cap_permitted, GR_CHROOT_CAPS);
+		task->cap_inheritable =
+		    cap_drop(task->cap_inheritable, GR_CHROOT_CAPS);
+		task->cap_effective =
+		    cap_drop(task->cap_effective, GR_CHROOT_CAPS);
+	}
+#endif
+	return;
+}
+
+int
+gr_handle_chroot_sysctl(const int op)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	if (grsec_enable_chroot_sysctl && proc_is_chrooted(current)
+	    && (op & 002))
+		return -EACCES;
+#endif
+	return 0;
+}
+
+void
+gr_handle_chroot_chdir(struct dentry *dentry, struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	if (grsec_enable_chroot_chdir)
+		set_fs_pwd(current->fs, mnt, dentry);
+#endif
+	return;
+}
+
+int
+gr_handle_chroot_chmod(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const int mode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	if (grsec_enable_chroot_chmod &&
+	    ((mode & S_ISUID) || ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))) &&
+	    proc_is_chrooted(current)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHMOD_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_SECURITY
+EXPORT_SYMBOL(gr_handle_chroot_caps);
+#endif
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_disabled.c grsecurity226/grsecurity/grsec_disabled.c
--- linux-2.6.13.1.org/grsecurity/grsec_disabled.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_disabled.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,418 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/kdev_t.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/sysctl.h>
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+void
+pax_set_initial_flags(struct linux_binprm *bprm)
+{
+	return;
+}
+#endif
+
+#ifdef CONFIG_SYSCTL
+__u32
+gr_handle_sysctl(const struct ctl_table * table, __u32 mode)
+{
+	return mode;
+}
+#endif
+
+int
+gr_acl_is_enabled(void)
+{
+	return 0;
+}
+
+int
+gr_handle_rawio(const struct inode *inode)
+{
+	return 0;
+}
+
+void
+gr_acl_handle_psacct(struct task_struct *task, const long code)
+{
+	return;
+}
+
+int
+gr_handle_ptrace(struct task_struct *task, const long request)
+{
+	return 0;
+}
+
+int
+gr_handle_proc_ptrace(struct task_struct *task)
+{
+	return 0;
+}
+
+void
+gr_learn_resource(const struct task_struct *task,
+		  const int res, const unsigned long wanted, const int gt)
+{
+	return;
+}
+
+int
+gr_set_acls(const int type)
+{
+	return 0;
+}
+
+int
+gr_check_hidden_task(const struct task_struct *tsk)
+{
+	return 0;
+}
+
+int
+gr_check_protected_task(const struct task_struct *task)
+{
+	return 0;
+}
+
+void
+gr_copy_label(struct task_struct *tsk)
+{
+	return;
+}
+
+void
+gr_set_pax_flags(struct task_struct *task)
+{
+	return;
+}
+
+int
+gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return 0;
+}
+
+void
+gr_handle_delete(const ino_t ino, const dev_t dev)
+{
+	return;
+}
+
+void
+gr_handle_create(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return;
+}
+
+void
+gr_handle_crash(struct task_struct *task, const int sig)
+{
+	return;
+}
+
+int
+gr_check_crash_exec(const struct file *filp)
+{
+	return 0;
+}
+
+int
+gr_check_crash_uid(const uid_t uid)
+{
+	return 0;
+}
+
+void
+gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+		 struct dentry *old_dentry,
+		 struct dentry *new_dentry,
+		 struct vfsmount *mnt, const __u8 replace)
+{
+	return;
+}
+
+int
+gr_search_socket(const int family, const int type, const int protocol)
+{
+	return 1;
+}
+
+int
+gr_search_connectbind(const int mode, const struct socket *sock,
+		      const struct sockaddr_in *addr)
+{
+	return 1;
+}
+
+int
+gr_task_is_capable(struct task_struct *task, const int cap)
+{
+	return 1;
+}
+
+int
+gr_is_capable_nolog(const int cap)
+{
+	return 1;
+}
+
+void
+gr_handle_alertkill(struct task_struct *task)
+{
+	return;
+}
+
+__u32
+gr_acl_handle_execve(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_hidden_file(const struct dentry * dentry,
+			  const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_open(const struct dentry * dentry, const struct vfsmount * mnt,
+		   const int fmode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_rmdir(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_unlink(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+int
+gr_acl_handle_mmap(const struct file *file, const unsigned long prot,
+		   unsigned int *vm_flags)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_truncate(const struct dentry * dentry,
+		       const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_utime(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_access(const struct dentry * dentry,
+		     const struct vfsmount * mnt, const int fmode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_fchmod(const struct dentry * dentry, const struct vfsmount * mnt,
+		     mode_t mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_chmod(const struct dentry * dentry, const struct vfsmount * mnt,
+		    mode_t mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_chown(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+void
+grsecurity_init(void)
+{
+	return;
+}
+
+__u32
+gr_acl_handle_mknod(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt,
+		    const int mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_mkdir(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_symlink(const struct dentry * new_dentry,
+		      const struct dentry * parent_dentry,
+		      const struct vfsmount * parent_mnt, const char *from)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_link(const struct dentry * new_dentry,
+		   const struct dentry * parent_dentry,
+		   const struct vfsmount * parent_mnt,
+		   const struct dentry * old_dentry,
+		   const struct vfsmount * old_mnt, const char *to)
+{
+	return 1;
+}
+
+int
+gr_acl_handle_rename(const struct dentry *new_dentry,
+		     const struct dentry *parent_dentry,
+		     const struct vfsmount *parent_mnt,
+		     const struct dentry *old_dentry,
+		     const struct inode *old_parent_inode,
+		     const struct vfsmount *old_mnt, const char *newname)
+{
+	return 0;
+}
+
+int
+gr_acl_handle_filldir(const struct file *file, const char *name,
+		      const int namelen, const ino_t ino)
+{
+	return 1;
+}
+
+int
+gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const time_t shm_createtime, const uid_t cuid, const int shmid)
+{
+	return 1;
+}
+
+int
+gr_search_bind(const struct socket *sock, const struct sockaddr_in *addr)
+{
+	return 1;
+}
+
+int
+gr_search_accept(const struct socket *sock)
+{
+	return 1;
+}
+
+int
+gr_search_listen(const struct socket *sock)
+{
+	return 1;
+}
+
+int
+gr_search_connect(const struct socket *sock, const struct sockaddr_in *addr)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_unix(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_creat(const struct dentry * dentry,
+		    const struct dentry * p_dentry,
+		    const struct vfsmount * p_mnt, const int fmode,
+		    const int imode)
+{
+	return 1;
+}
+
+void
+gr_acl_handle_exit(void)
+{
+	return;
+}
+
+int
+gr_acl_handle_mprotect(const struct file *file, const unsigned long prot)
+{
+	return 1;
+}
+
+void
+gr_set_role_label(const uid_t uid, const gid_t gid)
+{
+	return;
+}
+
+int
+gr_acl_handle_procpidmem(const struct task_struct *task)
+{
+	return 0;
+}
+
+int
+gr_search_udp_recvmsg(const struct sock *sk, const struct sk_buff *skb)
+{
+	return 1;
+}
+
+int
+gr_search_udp_sendmsg(const struct sock *sk, const struct sockaddr_in *addr)
+{
+	return 1;
+}
+
+void
+gr_set_kernel_label(struct task_struct *task)
+{
+	return;
+}
+
+int
+gr_check_user_change(int real, int effective, int fs)
+{
+	return 0;
+}
+
+int
+gr_check_group_change(int real, int effective, int fs)
+{
+	return 0;
+}
+
+
+EXPORT_SYMBOL(gr_task_is_capable);
+EXPORT_SYMBOL(gr_learn_resource);
+EXPORT_SYMBOL(gr_set_kernel_label);
+#ifdef CONFIG_SECURITY
+EXPORT_SYMBOL(gr_check_user_change);
+EXPORT_SYMBOL(gr_check_group_change);
+#endif
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_exec.c grsecurity226/grsecurity/grsec_exec.c
--- linux-2.6.13.1.org/grsecurity/grsec_exec.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_exec.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,88 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/binfmts.h>
+#include <linux/smp_lock.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/grdefs.h>
+#include <linux/grinternal.h>
+#include <linux/capability.h>
+
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+static char gr_exec_arg_buf[132];
+static DECLARE_MUTEX(gr_exec_arg_sem);
+#endif
+
+int
+gr_handle_nproc(void)
+{
+#ifdef CONFIG_GRKERNSEC_EXECVE
+	if (grsec_enable_execve && current->user &&
+	    (atomic_read(&current->user->processes) >
+	     current->signal->rlim[RLIMIT_NPROC].rlim_cur) &&
+	    !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_NPROC_MSG);
+		return -EAGAIN;
+	}
+#endif
+	return 0;
+}
+
+void
+gr_handle_exec_args(struct linux_binprm *bprm, const char __user *__user *argv)
+{
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	char *grarg = gr_exec_arg_buf;
+	unsigned int i, x, execlen = 0;
+	char c;
+
+	if (!((grsec_enable_execlog && grsec_enable_group &&
+	       in_group_p(grsec_audit_gid))
+	      || (grsec_enable_execlog && !grsec_enable_group)))
+		return;
+
+	down(&gr_exec_arg_sem);
+	memset(grarg, 0, sizeof(gr_exec_arg_buf));
+
+	if (unlikely(argv == NULL))
+		goto log;
+
+	for (i = 0; i < bprm->argc && execlen < 128; i++) {
+		const char __user *p;
+		unsigned int len;
+
+		if (copy_from_user(&p, argv + i, sizeof(p)))
+			goto log;
+		if (!p)
+			goto log;
+		len = strnlen_user(p, 128 - execlen);
+		if (len > 128 - execlen)
+			len = 128 - execlen;
+		else if (len > 0)
+			len--;
+		if (copy_from_user(grarg + execlen, p, len))
+			goto log;
+
+		/* rewrite unprintable characters */
+		for (x = 0; x < len; x++) {
+			c = *(grarg + execlen + x);
+			if (c < 32 || c > 126)
+				*(grarg + execlen + x) = ' ';
+		}
+
+		execlen += len;
+		*(grarg + execlen) = ' ';
+		*(grarg + execlen + 1) = '\0';
+		execlen++;
+	}
+
+      log:
+	gr_log_fs_str(GR_DO_AUDIT, GR_EXEC_AUDIT_MSG, bprm->file->f_dentry,
+			bprm->file->f_vfsmnt, grarg);
+	up(&gr_exec_arg_sem);
+#endif
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_fifo.c grsecurity226/grsecurity/grsec_fifo.c
--- linux-2.6.13.1.org/grsecurity/grsec_fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_fifo.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,22 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_fifo(const struct dentry *dentry, const struct vfsmount *mnt,
+	       const struct dentry *dir, const int flag, const int acc_mode)
+{
+#ifdef CONFIG_GRKERNSEC_FIFO
+	if (grsec_enable_fifo && S_ISFIFO(dentry->d_inode->i_mode) &&
+	    !(flag & O_EXCL) && (dir->d_inode->i_mode & S_ISVTX) &&
+	    (dentry->d_inode->i_uid != dir->d_inode->i_uid) &&
+	    (current->fsuid != dentry->d_inode->i_uid)) {
+		if (!generic_permission(dentry->d_inode, acc_mode, NULL))
+			gr_log_fs_int2(GR_DONT_AUDIT, GR_FIFO_MSG, dentry, mnt, dentry->d_inode->i_uid, dentry->d_inode->i_gid);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_fork.c grsecurity226/grsecurity/grsec_fork.c
--- linux-2.6.13.1.org/grsecurity/grsec_fork.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_fork.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,14 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_forkfail(const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	if (grsec_enable_forkfail)
+		gr_log_int(GR_DONT_AUDIT, GR_FAILFORK_MSG, retval);
+#endif
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_init.c grsecurity226/grsecurity/grsec_init.c
--- linux-2.6.13.1.org/grsecurity/grsec_init.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_init.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,236 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/gracl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/percpu.h>
+
+int grsec_enable_shm;
+int grsec_enable_link;
+int grsec_enable_dmesg;
+int grsec_enable_fifo;
+int grsec_enable_execve;
+int grsec_enable_execlog;
+int grsec_enable_signal;
+int grsec_enable_forkfail;
+int grsec_enable_time;
+int grsec_enable_audit_textrel;
+int grsec_enable_group;
+int grsec_audit_gid;
+int grsec_enable_chdir;
+int grsec_enable_audit_ipc;
+int grsec_enable_mount;
+int grsec_enable_chroot_findtask;
+int grsec_enable_chroot_mount;
+int grsec_enable_chroot_shmat;
+int grsec_enable_chroot_fchdir;
+int grsec_enable_chroot_double;
+int grsec_enable_chroot_pivot;
+int grsec_enable_chroot_chdir;
+int grsec_enable_chroot_chmod;
+int grsec_enable_chroot_mknod;
+int grsec_enable_chroot_nice;
+int grsec_enable_chroot_execlog;
+int grsec_enable_chroot_caps;
+int grsec_enable_chroot_sysctl;
+int grsec_enable_chroot_unix;
+int grsec_enable_tpe;
+int grsec_tpe_gid;
+int grsec_enable_tpe_all;
+int grsec_enable_randpid;
+int grsec_enable_randsrc;
+int grsec_enable_socket_all;
+int grsec_socket_all_gid;
+int grsec_enable_socket_client;
+int grsec_socket_client_gid;
+int grsec_enable_socket_server;
+int grsec_socket_server_gid;
+int grsec_lock;
+
+spinlock_t grsec_alert_lock = SPIN_LOCK_UNLOCKED;
+unsigned long grsec_alert_wtime = 0;
+unsigned long grsec_alert_fyet = 0;
+
+spinlock_t grsec_audit_lock = SPIN_LOCK_UNLOCKED;
+
+rwlock_t grsec_exec_file_lock = RW_LOCK_UNLOCKED;
+
+char *gr_shared_page[4];
+
+char *gr_alert_log_fmt;
+char *gr_audit_log_fmt;
+char *gr_alert_log_buf;
+char *gr_audit_log_buf;
+
+extern struct gr_arg *gr_usermode;
+extern unsigned char *gr_system_salt;
+extern unsigned char *gr_system_sum;
+
+void
+grsecurity_init(void)
+{
+	int j;
+	/* create the per-cpu shared pages */
+
+	preempt_disable();
+	for (j = 0; j < 4; j++) {
+		gr_shared_page[j] = (char *)__alloc_percpu(PAGE_SIZE, __alignof__(char *));
+		if (gr_shared_page[j] == NULL) {
+			panic("Unable to allocate grsecurity shared page");
+			return;
+		}
+	}
+	preempt_enable();
+
+	/* allocate log buffers */
+	gr_alert_log_fmt = kmalloc(512, GFP_KERNEL);
+	if (!gr_alert_log_fmt) {
+		panic("Unable to allocate grsecurity alert log format buffer");
+		return;
+	}
+	gr_audit_log_fmt = kmalloc(512, GFP_KERNEL);
+	if (!gr_audit_log_fmt) {
+		panic("Unable to allocate grsecurity audit log format buffer");
+		return;
+	}
+	gr_alert_log_buf = (char *) get_zeroed_page(GFP_KERNEL);
+	if (!gr_alert_log_buf) {
+		panic("Unable to allocate grsecurity alert log buffer");
+		return;
+	}
+	gr_audit_log_buf = (char *) get_zeroed_page(GFP_KERNEL);
+	if (!gr_audit_log_buf) {
+		panic("Unable to allocate grsecurity audit log buffer");
+		return;
+	}
+
+	/* allocate memory for authentication structure */
+	gr_usermode = kmalloc(sizeof(struct gr_arg), GFP_KERNEL);
+	gr_system_salt = kmalloc(GR_SALT_LEN, GFP_KERNEL);
+	gr_system_sum = kmalloc(GR_SHA_LEN, GFP_KERNEL);
+
+	if (!gr_usermode || !gr_system_salt || !gr_system_sum) {
+		panic("Unable to allocate grsecurity authentication structure");
+		return;
+	}
+
+#if !defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_SYSCTL_ON)
+#ifndef CONFIG_GRKERNSEC_SYSCTL
+	grsec_lock = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SHM
+	grsec_enable_shm = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_TEXTREL
+	grsec_enable_audit_textrel = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+	grsec_enable_group = 1;
+	grsec_audit_gid = CONFIG_GRKERNSEC_AUDIT_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	grsec_enable_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	grsec_enable_audit_ipc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	grsec_enable_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_LINK
+	grsec_enable_link = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+	grsec_enable_dmesg = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+	grsec_enable_fifo = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECVE
+	grsec_enable_execve = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	grsec_enable_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	grsec_enable_signal = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	grsec_enable_forkfail = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+	grsec_enable_time = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	grsec_enable_chroot_findtask = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	grsec_enable_chroot_unix = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	grsec_enable_chroot_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	grsec_enable_chroot_fchdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	grsec_enable_chroot_shmat = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	grsec_enable_chroot_double = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	grsec_enable_chroot_pivot = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	grsec_enable_chroot_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	grsec_enable_chroot_chmod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	grsec_enable_chroot_mknod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	grsec_enable_chroot_nice = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	grsec_enable_chroot_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	grsec_enable_chroot_caps = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	grsec_enable_chroot_sysctl = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+	grsec_enable_tpe = 1;
+	grsec_tpe_gid = CONFIG_GRKERNSEC_TPE_GID;
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	grsec_enable_tpe_all = 1;
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPID
+	grsec_enable_randpid = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+	grsec_enable_randsrc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	grsec_enable_socket_all = 1;
+	grsec_socket_all_gid = CONFIG_GRKERNSEC_SOCKET_ALL_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	grsec_enable_socket_client = 1;
+	grsec_socket_client_gid = CONFIG_GRKERNSEC_SOCKET_CLIENT_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	grsec_enable_socket_server = 1;
+	grsec_socket_server_gid = CONFIG_GRKERNSEC_SOCKET_SERVER_GID;
+#endif
+#endif
+
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_ipc.c grsecurity226/grsecurity/grsec_ipc.c
--- linux-2.6.13.1.org/grsecurity/grsec_ipc.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_ipc.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,81 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/ipc.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_msgget(const int ret, const int msgflg)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if (((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	      grsec_enable_audit_ipc) || (grsec_enable_audit_ipc &&
+					  !grsec_enable_group)) && (ret >= 0)
+	    && (msgflg & IPC_CREAT))
+		gr_log_noargs(GR_DO_AUDIT, GR_MSGQ_AUDIT_MSG);
+#endif
+	return;
+}
+
+void
+gr_log_msgrm(const uid_t uid, const uid_t cuid)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if ((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	     grsec_enable_audit_ipc) ||
+	    (grsec_enable_audit_ipc && !grsec_enable_group))
+		gr_log_int_int(GR_DO_AUDIT, GR_MSGQR_AUDIT_MSG, uid, cuid);
+#endif
+	return;
+}
+
+void
+gr_log_semget(const int err, const int semflg)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if (((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	      grsec_enable_audit_ipc) || (grsec_enable_audit_ipc &&
+					  !grsec_enable_group)) && (err >= 0)
+	    && (semflg & IPC_CREAT))
+		gr_log_noargs(GR_DO_AUDIT, GR_SEM_AUDIT_MSG);
+#endif
+	return;
+}
+
+void
+gr_log_semrm(const uid_t uid, const uid_t cuid)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if ((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	     grsec_enable_audit_ipc) ||
+	    (grsec_enable_audit_ipc && !grsec_enable_group))
+		gr_log_int_int(GR_DO_AUDIT, GR_SEMR_AUDIT_MSG, uid, cuid);
+#endif
+	return;
+}
+
+void
+gr_log_shmget(const int err, const int shmflg, const size_t size)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if (((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	      grsec_enable_audit_ipc) || (grsec_enable_audit_ipc &&
+					  !grsec_enable_group)) && (err >= 0)
+	    && (shmflg & IPC_CREAT))
+		gr_log_int(GR_DO_AUDIT, GR_SHM_AUDIT_MSG, size);
+#endif
+	return;
+}
+
+void
+gr_log_shmrm(const uid_t uid, const uid_t cuid)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if ((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	     grsec_enable_audit_ipc) ||
+	    (grsec_enable_audit_ipc && !grsec_enable_group))
+		gr_log_int_int(GR_DO_AUDIT, GR_SHMR_AUDIT_MSG, uid, cuid);
+#endif
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_link.c grsecurity226/grsecurity/grsec_link.c
--- linux-2.6.13.1.org/grsecurity/grsec_link.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_link.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,39 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_follow_link(const struct inode *parent,
+		      const struct inode *inode,
+		      const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_LINK
+	if (grsec_enable_link && S_ISLNK(inode->i_mode) &&
+	    (parent->i_mode & S_ISVTX) && (parent->i_uid != inode->i_uid) &&
+	    (parent->i_mode & S_IWOTH) && (current->fsuid != inode->i_uid)) {
+		gr_log_fs_int2(GR_DONT_AUDIT, GR_SYMLINK_MSG, dentry, mnt, inode->i_uid, inode->i_gid);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_hardlink(const struct dentry *dentry,
+		   const struct vfsmount *mnt,
+		   struct inode *inode, const int mode, const char *to)
+{
+#ifdef CONFIG_GRKERNSEC_LINK
+	if (grsec_enable_link && current->fsuid != inode->i_uid &&
+	    (!S_ISREG(mode) || (mode & S_ISUID) ||
+	     ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) ||
+	     (generic_permission(inode, MAY_READ | MAY_WRITE, NULL))) &&
+	    !capable(CAP_FOWNER) && current->uid) {
+		gr_log_fs_int2_str(GR_DONT_AUDIT, GR_HARDLINK_MSG, dentry, mnt, inode->i_uid, inode->i_gid, to);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_log.c grsecurity226/grsecurity/grsec_log.c
--- linux-2.6.13.1.org/grsecurity/grsec_log.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_log.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,265 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/tty.h>
+#include <linux/fs.h>
+#include <linux/grinternal.h>
+
+#define BEGIN_LOCKS(x) \
+	read_lock(&tasklist_lock); \
+	read_lock(&grsec_exec_file_lock); \
+	if (x != GR_DO_AUDIT) \
+		spin_lock(&grsec_alert_lock); \
+	else \
+		spin_lock(&grsec_audit_lock)
+
+#define END_LOCKS(x) \
+	if (x != GR_DO_AUDIT) \
+		spin_unlock(&grsec_alert_lock); \
+	else \
+		spin_unlock(&grsec_audit_lock); \
+	read_unlock(&grsec_exec_file_lock); \
+	read_unlock(&tasklist_lock); \
+	if (x == GR_DONT_AUDIT) \
+		gr_handle_alertkill(current)
+
+enum {
+	FLOODING,
+	NO_FLOODING
+};
+
+extern char *gr_alert_log_fmt;
+extern char *gr_audit_log_fmt;
+extern char *gr_alert_log_buf;
+extern char *gr_audit_log_buf;
+
+static int gr_log_start(int audit)
+{
+	char *loglevel = (audit == GR_DO_AUDIT) ? KERN_INFO : KERN_ALERT;
+	char *fmt = (audit == GR_DO_AUDIT) ? gr_audit_log_fmt : gr_alert_log_fmt;
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+
+	if (audit == GR_DO_AUDIT)
+		goto set_fmt;
+
+	if (!grsec_alert_wtime || jiffies - grsec_alert_wtime > CONFIG_GRKERNSEC_FLOODTIME * HZ) {
+		grsec_alert_wtime = jiffies;
+		grsec_alert_fyet = 0;
+	} else if ((jiffies - grsec_alert_wtime < CONFIG_GRKERNSEC_FLOODTIME * HZ) && (grsec_alert_fyet < CONFIG_GRKERNSEC_FLOODBURST)) {
+		grsec_alert_fyet++;
+	} else if (grsec_alert_fyet == CONFIG_GRKERNSEC_FLOODBURST) {
+		grsec_alert_wtime = jiffies;
+		grsec_alert_fyet++;
+		printk(KERN_ALERT "grsec: more alerts, logging disabled for %d seconds\n", CONFIG_GRKERNSEC_FLOODTIME);
+		return FLOODING;
+	} else return FLOODING;
+
+set_fmt:
+	memset(buf, 0, PAGE_SIZE);
+	if (current->signal->curr_ip && gr_acl_is_enabled()) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: From %u.%u.%u.%u: (%.64s:%c:%.950s) ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, NIPQUAD(current->signal->curr_ip), current->role->rolename, gr_roletype_to_char(), current->acl->filename);
+	} else if (current->signal->curr_ip) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: From %u.%u.%u.%u: ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, NIPQUAD(current->signal->curr_ip));
+	} else if (gr_acl_is_enabled()) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: (%.64s:%c:%.950s) ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, current->role->rolename, gr_roletype_to_char(), current->acl->filename);
+	} else {
+		sprintf(fmt, "%s%s", loglevel, "grsec: ");
+		strcpy(buf, fmt);
+	}
+
+	return NO_FLOODING;
+}
+
+static void gr_log_middle(int audit, const char *msg, va_list ap)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	unsigned int len = strlen(buf);
+
+	vsnprintf(buf + len, PAGE_SIZE - len - 1, msg, ap);
+
+	return;
+}
+
+static void gr_log_middle_varargs(int audit, const char *msg, ...)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	unsigned int len = strlen(buf);
+	va_list ap;
+
+	va_start(ap, msg);
+	vsnprintf(buf + len, PAGE_SIZE - len - 1, msg, ap);
+	va_end(ap);
+
+	return;
+}
+
+static void gr_log_end(int audit)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	unsigned int len = strlen(buf);
+
+	snprintf(buf + len, PAGE_SIZE - len - 1, DEFAULTSECMSG, DEFAULTSECARGS(current));
+	printk("%s\n", buf);
+
+	return;
+}
+
+void gr_log_varargs(int audit, const char *msg, int argtypes, ...)
+{
+	int logtype;
+	char *result = (audit == GR_DO_AUDIT) ? "successful" : "denied";
+	char *str1, *str2, *str3;
+	int num1, num2;
+	unsigned long ulong1, ulong2;
+	struct dentry *dentry;
+	struct vfsmount *mnt;
+	struct file *file;
+	struct task_struct *task;
+	va_list ap;
+
+	BEGIN_LOCKS(audit);
+	logtype = gr_log_start(audit);
+	if (logtype == FLOODING) {
+		END_LOCKS(audit);
+		return;
+	}
+	va_start(ap, argtypes);
+	switch (argtypes) {
+	case GR_TTYSNIFF:
+		task = va_arg(ap, struct task_struct *);
+		gr_log_middle_varargs(audit, msg, NIPQUAD(task->signal->curr_ip), gr_task_fullpath0(task), task->comm, task->pid, gr_parent_task_fullpath0(task), task->parent->comm, task->parent->pid);
+		break;
+	case GR_RBAC:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt));
+		break;
+	case GR_RBAC_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1);
+		break;
+	case GR_STR_RBAC:
+		str1 = va_arg(ap, char *);
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, result, str1, gr_to_filename(dentry, mnt));
+		break;
+	case GR_RBAC_MODE2:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		str2 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1, str2);
+		break;
+	case GR_RBAC_MODE3:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		str2 = va_arg(ap, char *);
+		str3 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1, str2, str3);
+		break;
+	case GR_FILENAME:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt));
+		break;
+	case GR_STR_FILENAME:
+		str1 = va_arg(ap, char *);
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, str1, gr_to_filename(dentry, mnt));
+		break;
+	case GR_FILENAME_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), str1);
+		break;
+	case GR_FILENAME_TWO_INT:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		num1 = va_arg(ap, int);
+		num2 = va_arg(ap, int);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), num1, num2);
+		break;
+	case GR_FILENAME_TWO_INT_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		num1 = va_arg(ap, int);
+		num2 = va_arg(ap, int);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), num1, num2, str1);
+		break;
+	case GR_TEXTREL:
+		file = va_arg(ap, struct file *);
+		ulong1 = va_arg(ap, unsigned long);
+		ulong2 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, file ? gr_to_filename(file->f_dentry, file->f_vfsmnt) : "<anonymous mapping>", ulong1, ulong2);
+		break;
+	case GR_PTRACE:
+		task = va_arg(ap, struct task_struct *);
+		gr_log_middle_varargs(audit, msg, task->exec_file ? gr_to_filename(task->exec_file->f_dentry, task->exec_file->f_vfsmnt) : "(none)", task->comm, task->pid);
+		break;
+	case GR_RESOURCE:
+		task = va_arg(ap, struct task_struct *);
+		ulong1 = va_arg(ap, unsigned long);
+		str1 = va_arg(ap, char *);
+		ulong2 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, ulong1, str1, ulong2, gr_task_fullpath(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath(task), task->parent->comm, task->parent->pid, task->parent->uid, task->parent->euid, task->parent->gid, task->parent->egid);
+		break;
+	case GR_CAP:
+		task = va_arg(ap, struct task_struct *);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, str1, gr_task_fullpath(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath(task), task->parent->comm, task->parent->pid, task->parent->uid, task->parent->euid, task->parent->gid, task->parent->egid);
+		break;
+	case GR_SIG:
+		task = va_arg(ap, struct task_struct *);
+		num1 = va_arg(ap, int);
+		gr_log_middle_varargs(audit, msg, num1, gr_task_fullpath0(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath0(task), task->parent->comm, task->parent->pid, task->parent->uid, task->parent->euid, task->parent->gid, task->parent->egid);
+		break;
+	case GR_CRASH1:
+		task = va_arg(ap, struct task_struct *);
+		ulong1 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath(task), task->parent->comm, task->parent->pid, task->parent->uid, task->parent->euid, task->parent->gid, task->parent->egid, task->uid, ulong1);
+		break;
+	case GR_CRASH2:
+		task = va_arg(ap, struct task_struct *);
+		ulong1 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath(task), task->parent->comm, task->parent->pid, task->parent->uid, task->parent->euid, task->parent->gid, task->parent->egid, ulong1);
+		break;
+	case GR_PSACCT:
+		{
+			unsigned int wday, cday;
+			__u8 whr, chr;
+			__u8 wmin, cmin;
+			__u8 wsec, csec;
+			char cur_tty[64] = { 0 };
+			char parent_tty[64] = { 0 };
+
+			task = va_arg(ap, struct task_struct *);
+			wday = va_arg(ap, unsigned int);
+			cday = va_arg(ap, unsigned int);
+			whr = va_arg(ap, int);
+			chr = va_arg(ap, int);
+			wmin = va_arg(ap, int);
+			cmin = va_arg(ap, int);
+			wsec = va_arg(ap, int);
+			csec = va_arg(ap, int);
+			ulong1 = va_arg(ap, unsigned long);
+
+			gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task->pid, NIPQUAD(task->signal->curr_ip), tty_name(task->signal->tty, cur_tty), task->uid, task->euid, task->gid, task->egid, wday, whr, wmin, wsec, cday, chr, cmin, csec, (task->flags & PF_SIGNALED) ? "killed by signal" : "exited", ulong1, gr_parent_task_fullpath(task), task->parent->comm, task->parent->pid, NIPQUAD(task->parent->signal->curr_ip), tty_name(task->parent->signal->tty, parent_tty), task->parent->uid, task->parent->euid, task->parent->gid, task->parent->egid);
+		}
+		break;
+	default:
+		gr_log_middle(audit, msg, ap);
+	}
+	va_end(ap);
+	gr_log_end(audit);
+	END_LOCKS(audit);
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_mem.c grsecurity226/grsecurity/grsec_mem.c
--- linux-2.6.13.1.org/grsecurity/grsec_mem.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_mem.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,71 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/grinternal.h>
+
+void
+gr_handle_ioperm(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_IOPERM_MSG);
+	return;
+}
+
+void
+gr_handle_iopl(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_IOPL_MSG);
+	return;
+}
+
+void
+gr_handle_mem_write(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_MEM_WRITE_MSG);
+	return;
+}
+
+void
+gr_handle_kmem_write(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_KMEM_MSG);
+	return;
+}
+
+void
+gr_handle_open_port(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_PORT_OPEN_MSG);
+	return;
+}
+
+int
+gr_handle_mem_mmap(const unsigned long offset, struct vm_area_struct *vma)
+{
+	unsigned long start, end;
+
+	start = offset;
+	end = start + vma->vm_end - vma->vm_start;
+
+	if (start > end) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_MEM_MMAP_MSG);
+		return -EPERM;
+	}
+
+	/* allowed ranges : ISA I/O BIOS */
+	if ((start >= __pa(high_memory))
+#ifdef CONFIG_X86
+	    || (start >= 0x000a0000 && end <= 0x00100000)
+	    || (start >= 0x00000000 && end <= 0x00001000)
+#endif
+	)
+		return 0;
+
+	if (vma->vm_flags & VM_WRITE) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_MEM_MMAP_MSG);
+		return -EPERM;
+	} else
+		vma->vm_flags &= ~VM_MAYWRITE;
+
+	return 0;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_mount.c grsecurity226/grsecurity/grsec_mount.c
--- linux-2.6.13.1.org/grsecurity/grsec_mount.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_mount.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,34 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_remount(const char *devname, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str(GR_DO_AUDIT, GR_REMOUNT_AUDIT_MSG, devname ? devname : "none");
+#endif
+	return;
+}
+
+void
+gr_log_unmount(const char *devname, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str(GR_DO_AUDIT, GR_UNMOUNT_AUDIT_MSG, devname ? devname : "none");
+#endif
+	return;
+}
+
+void
+gr_log_mount(const char *from, const char *to, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str_str(GR_DO_AUDIT, GR_MOUNT_AUDIT_MSG, from, to);
+#endif
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_rand.c grsecurity226/grsecurity/grsec_rand.c
--- linux-2.6.13.1.org/grsecurity/grsec_rand.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_rand.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,26 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+extern int pid_max;
+
+int
+gr_random_pid(void)
+{
+#ifdef CONFIG_GRKERNSEC_RANDPID
+	int pid;
+
+	if (grsec_enable_randpid && current->fs->root) {
+		/* return a pid in the range 1 ... pid_max - 1
+		   optimize this so we don't have to do a real division
+		*/
+		pid = 1 + (get_random_long() % pid_max);
+		if (pid == pid_max)
+			pid = pid_max - 1;
+		return pid;
+	}
+#endif
+	return 0;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_sig.c grsecurity226/grsecurity/grsec_sig.c
--- linux-2.6.13.1.org/grsecurity/grsec_sig.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_sig.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,59 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_signal(const int sig, const struct task_struct *t)
+{
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	if (grsec_enable_signal && ((sig == SIGSEGV) || (sig == SIGILL) ||
+				    (sig == SIGABRT) || (sig == SIGBUS))) {
+		if (t->pid == current->pid) {
+			gr_log_int(GR_DONT_AUDIT_GOOD, GR_UNISIGLOG_MSG, sig);
+		} else {
+			gr_log_sig(GR_DONT_AUDIT_GOOD, GR_DUALSIGLOG_MSG, t, sig);
+		}
+	}
+#endif
+	return;
+}
+
+int
+gr_handle_signal(const struct task_struct *p, const int sig)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (current->pid > 1 && gr_check_protected_task(p)) {
+		gr_log_sig(GR_DONT_AUDIT, GR_SIG_ACL_MSG, p, sig);
+		return -EPERM;
+	} else if (gr_pid_is_chrooted((struct task_struct *)p)) {
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+void gr_handle_brute_attach(struct task_struct *p)
+{
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	if (p->parent && p->parent->exec_file == p->exec_file)
+		p->parent->brute = 1;
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+#endif
+	return;
+}
+
+void gr_handle_brute_check(void)
+{
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	if (current->brute) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(30 * HZ);
+	}
+#endif
+	return;
+}
+
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_sock.c grsecurity226/grsecurity/grsec_sock.c
--- linux-2.6.13.1.org/grsecurity/grsec_sock.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_sock.c	2005-09-12 22:44:34.000000000 +0200
@@ -0,0 +1,267 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <net/sock.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/gracl.h>
+
+#if defined(CONFIG_IP_NF_MATCH_STEALTH_MODULE)
+extern struct sock *udp_v4_lookup(u32 saddr, u16 sport, u32 daddr, u16 dport, int dif);
+EXPORT_SYMBOL(udp_v4_lookup);
+#endif
+
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+EXPORT_SYMBOL(pax_get_random_long);
+EXPORT_SYMBOL(grsec_enable_randsrc);
+#endif
+
+EXPORT_SYMBOL(gr_cap_rtnetlink);
+
+extern int gr_search_udp_recvmsg(const struct sock *sk, const struct sk_buff *skb);
+extern int gr_search_udp_sendmsg(const struct sock *sk, const struct sockaddr_in *addr);
+
+EXPORT_SYMBOL(gr_search_udp_recvmsg);
+EXPORT_SYMBOL(gr_search_udp_sendmsg);
+
+#ifdef CONFIG_UNIX_MODULE
+EXPORT_SYMBOL(gr_acl_handle_unix);
+EXPORT_SYMBOL(gr_acl_handle_mknod);
+EXPORT_SYMBOL(gr_handle_chroot_unix);
+EXPORT_SYMBOL(gr_handle_create);
+#endif
+
+#ifdef CONFIG_GRKERNSEC
+#define gr_conn_table_size 32749
+struct conn_table_entry {
+	struct conn_table_entry *next;
+	struct signal_struct *sig;
+};
+
+struct conn_table_entry *gr_conn_table[gr_conn_table_size];
+spinlock_t gr_conn_table_lock = SPIN_LOCK_UNLOCKED;
+
+extern const char * gr_socktype_to_name(unsigned char type);
+extern const char * gr_proto_to_name(unsigned char proto);
+
+static __inline__ int 
+conn_hash(__u32 saddr, __u32 daddr, __u16 sport, __u16 dport, unsigned int size)
+{
+	return ((daddr + saddr + (sport << 8) + (dport << 16)) % size);
+}
+
+static __inline__ int
+conn_match(const struct signal_struct *sig, __u32 saddr, __u32 daddr, 
+	   __u16 sport, __u16 dport)
+{
+	if (unlikely(sig->gr_saddr == saddr && sig->gr_daddr == daddr &&
+		     sig->gr_sport == sport && sig->gr_dport == dport))
+		return 1;
+	else
+		return 0;
+}
+
+static void gr_add_to_task_ip_table_nolock(struct signal_struct *sig, struct conn_table_entry *newent)
+{
+	struct conn_table_entry **match;
+	unsigned int index;
+
+	index = conn_hash(sig->gr_saddr, sig->gr_daddr, 
+			  sig->gr_sport, sig->gr_dport, 
+			  gr_conn_table_size);
+
+	newent->sig = sig;
+	
+	match = &gr_conn_table[index];
+	newent->next = *match;
+	*match = newent;
+
+	return;
+}
+
+static void gr_del_task_from_ip_table_nolock(struct signal_struct *sig)
+{
+	struct conn_table_entry *match, *last = NULL;
+	unsigned int index;
+
+	index = conn_hash(sig->gr_saddr, sig->gr_daddr, 
+			  sig->gr_sport, sig->gr_dport, 
+			  gr_conn_table_size);
+
+	match = gr_conn_table[index];
+	while (match && !conn_match(match->sig, 
+		sig->gr_saddr, sig->gr_daddr, sig->gr_sport, 
+		sig->gr_dport)) {
+		last = match;
+		match = match->next;
+	}
+
+	if (match) {
+		if (last)
+			last->next = match->next;
+		else
+			gr_conn_table[index] = NULL;
+		kfree(match);
+	}
+
+	return;
+}
+
+static struct signal_struct * gr_lookup_task_ip_table(__u32 saddr, __u32 daddr,
+					     __u16 sport, __u16 dport)
+{
+	struct conn_table_entry *match;
+	unsigned int index;
+
+	index = conn_hash(saddr, daddr, sport, dport, gr_conn_table_size);
+
+	match = gr_conn_table[index];
+	while (match && !conn_match(match->sig, saddr, daddr, sport, dport))
+		match = match->next;
+
+	if (match)
+		return match->sig;
+	else
+		return NULL;
+}
+
+#endif
+
+void gr_update_task_in_ip_table(struct task_struct *task, const struct inet_sock *inet)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct signal_struct *sig = task->signal;
+	struct conn_table_entry *newent;
+
+	newent = kmalloc(sizeof(struct conn_table_entry), GFP_ATOMIC);
+	if (newent == NULL)
+		return;
+	
+	spin_lock(&gr_conn_table_lock);
+	gr_del_task_from_ip_table_nolock(sig);
+	sig->gr_saddr = inet->rcv_saddr;
+	sig->gr_daddr = inet->daddr;
+	sig->gr_sport = inet->sport;
+	sig->gr_dport = inet->dport;
+	gr_add_to_task_ip_table_nolock(sig, newent);
+	spin_unlock(&gr_conn_table_lock);
+#endif
+	return;
+}
+
+void gr_del_task_from_ip_table(struct task_struct *task)
+{
+#ifdef CONFIG_GRKERNSEC
+	spin_lock(&gr_conn_table_lock);
+	gr_del_task_from_ip_table_nolock(task->signal);
+	spin_unlock(&gr_conn_table_lock);
+#endif
+	return;
+}
+
+void
+gr_attach_curr_ip(const struct sock *sk)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct signal_struct *p, *set;
+	const struct inet_sock *inet = inet_sk(sk);	
+
+	if (unlikely(sk->sk_protocol != IPPROTO_TCP))
+		return;
+
+	set = current->signal;
+
+	spin_lock(&gr_conn_table_lock);
+	p = gr_lookup_task_ip_table(inet->daddr, inet->rcv_saddr,
+				    inet->dport, inet->sport);
+	if (unlikely(p != NULL)) {
+		set->curr_ip = p->curr_ip;
+		set->used_accept = 1;
+		gr_del_task_from_ip_table_nolock(p);
+		spin_unlock(&gr_conn_table_lock);
+		return;
+	}
+	spin_unlock(&gr_conn_table_lock);
+
+	set->curr_ip = inet->daddr;
+	set->used_accept = 1;
+#endif
+	return;
+}
+
+int
+gr_handle_sock_all(const int family, const int type, const int protocol)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	if (grsec_enable_socket_all && in_group_p(grsec_socket_all_gid) &&
+	    (family != AF_UNIX) && (family != AF_LOCAL)) {
+		gr_log_int_str2(GR_DONT_AUDIT, GR_SOCK2_MSG, family, gr_socktype_to_name(type), gr_proto_to_name(protocol));
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_server(const struct sockaddr *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	if (grsec_enable_socket_server &&
+	    in_group_p(grsec_socket_server_gid) &&
+	    sck && (sck->sa_family != AF_UNIX) &&
+	    (sck->sa_family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_BIND_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_server_other(const struct sock *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	if (grsec_enable_socket_server &&
+	    in_group_p(grsec_socket_server_gid) &&
+	    sck && (sck->sk_family != AF_UNIX) &&
+	    (sck->sk_family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_BIND_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_client(const struct sockaddr *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	if (grsec_enable_socket_client && in_group_p(grsec_socket_client_gid) &&
+	    sck && (sck->sa_family != AF_UNIX) &&
+	    (sck->sa_family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_CONNECT_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+__u32
+gr_cap_rtnetlink(void)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (!gr_acl_is_enabled())
+		return current->cap_effective;
+	else if (cap_raised(current->cap_effective, CAP_NET_ADMIN) &&
+		 gr_task_is_capable(current, CAP_NET_ADMIN))
+		return current->cap_effective;
+	else
+		return 0;
+#else
+	return current->cap_effective;
+#endif
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_sysctl.c grsecurity226/grsecurity/grsec_sysctl.c
--- linux-2.6.13.1.org/grsecurity/grsec_sysctl.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_sysctl.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,432 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/sysctl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_sysctl_mod(const char *dirname, const char *name, const int op)
+{
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+	if (!strcmp(dirname, "grsecurity") && grsec_lock && (op & 002)) {
+		gr_log_str(GR_DONT_AUDIT, GR_SYSCTL_MSG, name);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+enum {GS_LINK=1, GS_FIFO, GS_EXECVE, GS_EXECLOG, GS_SIGNAL,
+GS_FORKFAIL, GS_TIME, GS_CHROOT_SHMAT, GS_CHROOT_UNIX, GS_CHROOT_MNT,
+GS_CHROOT_FCHDIR, GS_CHROOT_DBL, GS_CHROOT_PVT, GS_CHROOT_CD, GS_CHROOT_CM,
+GS_CHROOT_MK, GS_CHROOT_NI, GS_CHROOT_EXECLOG, GS_CHROOT_CAPS,
+GS_CHROOT_SYSCTL, GS_TPE, GS_TPE_GID, GS_TPE_ALL, GS_SIDCAPS,
+GS_RANDPID, GS_RANDSRC, GS_SOCKET_ALL, GS_SOCKET_ALL_GID, GS_SOCKET_CLIENT,
+GS_SOCKET_CLIENT_GID, GS_SOCKET_SERVER, GS_SOCKET_SERVER_GID, 
+GS_GROUP, GS_GID, GS_ACHDIR, GS_AMOUNT, GS_AIPC, GS_DMSG,
+GS_TEXTREL, GS_FINDTASK, GS_SHM, GS_LOCK};
+
+
+ctl_table grsecurity_table[] = {
+#ifdef CONFIG_GRKERNSEC_LINK
+	{
+		.ctl_name	= GS_LINK,
+		.procname	= "linking_restrictions",
+		.data		= &grsec_enable_link,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+	{
+		.ctl_name	= GS_FIFO,
+		.procname	= "fifo_restrictions",
+		.data		= &grsec_enable_fifo,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECVE
+	{
+		.ctl_name	= GS_EXECVE,
+		.procname	= "execve_limiting",
+		.data		= &grsec_enable_execve,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	{
+		.ctl_name	= GS_EXECLOG,
+		.procname	= "exec_logging",
+		.data		= &grsec_enable_execlog,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	{
+		.ctl_name	= GS_SIGNAL,
+		.procname	= "signal_logging",
+		.data		= &grsec_enable_signal,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	{
+		.ctl_name	= GS_FORKFAIL,
+		.procname	= "forkfail_logging",
+		.data		= &grsec_enable_forkfail,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+	{
+		.ctl_name	= GS_TIME,
+		.procname	= "timechange_logging",
+		.data		= &grsec_enable_time,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	{
+		.ctl_name	= GS_CHROOT_SHMAT,
+		.procname	= "chroot_deny_shmat",
+		.data		= &grsec_enable_chroot_shmat,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	{
+		.ctl_name	= GS_CHROOT_UNIX,
+		.procname	= "chroot_deny_unix",
+		.data		= &grsec_enable_chroot_unix,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	{
+		.ctl_name	= GS_CHROOT_MNT,
+		.procname	= "chroot_deny_mount",
+		.data		= &grsec_enable_chroot_mount,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	{
+		.ctl_name	= GS_CHROOT_FCHDIR,
+		.procname	= "chroot_deny_fchdir",
+		.data		= &grsec_enable_chroot_fchdir,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	{
+		.ctl_name	= GS_CHROOT_DBL,
+		.procname	= "chroot_deny_chroot",
+		.data		= &grsec_enable_chroot_double,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	{
+		.ctl_name	= GS_CHROOT_PVT,
+		.procname	= "chroot_deny_pivot",
+		.data		= &grsec_enable_chroot_pivot,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	{
+		.ctl_name	= GS_CHROOT_CD,
+		.procname	= "chroot_enforce_chdir",
+		.data		= &grsec_enable_chroot_chdir,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	{
+		.ctl_name	= GS_CHROOT_CM,
+		.procname	= "chroot_deny_chmod",
+		.data		= &grsec_enable_chroot_chmod,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	{
+		.ctl_name	= GS_CHROOT_MK,
+		.procname	= "chroot_deny_mknod",
+		.data		= &grsec_enable_chroot_mknod,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	{
+		.ctl_name	= GS_CHROOT_NI,
+		.procname	= "chroot_restrict_nice",
+		.data		= &grsec_enable_chroot_nice,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	{
+		.ctl_name	= GS_CHROOT_EXECLOG,
+		.procname	= "chroot_execlog",
+		.data		= &grsec_enable_chroot_execlog,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	{
+		.ctl_name	= GS_CHROOT_CAPS,
+		.procname	= "chroot_caps",
+		.data		= &grsec_enable_chroot_caps,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	{
+		.ctl_name	= GS_CHROOT_SYSCTL,
+		.procname	= "chroot_deny_sysctl",
+		.data		= &grsec_enable_chroot_sysctl,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+	{
+		.ctl_name	= GS_TPE,
+		.procname	= "tpe",
+		.data		= &grsec_enable_tpe,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= GS_TPE_GID,
+		.procname	= "tpe_gid",
+		.data		= &grsec_tpe_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	{
+		.ctl_name	= GS_TPE_ALL,
+		.procname	= "tpe_restrict_all",
+		.data		= &grsec_enable_tpe_all,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPID
+	{
+		.ctl_name	= GS_RANDPID,
+		.procname	= "rand_pids",
+		.data		= &grsec_enable_randpid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+	{
+		.ctl_name	= GS_RANDSRC,
+		.procname	= "rand_tcp_src_ports",
+		.data		= &grsec_enable_randsrc,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	{
+		.ctl_name	= GS_SOCKET_ALL,
+		.procname	= "socket_all",
+		.data		= &grsec_enable_socket_all,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= GS_SOCKET_ALL_GID,
+		.procname	= "socket_all_gid",
+		.data		= &grsec_socket_all_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	{
+		.ctl_name	= GS_SOCKET_CLIENT,
+		.procname	= "socket_client",
+		.data		= &grsec_enable_socket_client,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= GS_SOCKET_CLIENT_GID,
+		.procname	= "socket_client_gid",
+		.data		= &grsec_socket_client_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	{
+		.ctl_name	= GS_SOCKET_SERVER,
+		.procname	= "socket_server",
+		.data		= &grsec_enable_socket_server,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= GS_SOCKET_SERVER_GID,
+		.procname	= "socket_server_gid",
+		.data		= &grsec_socket_server_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+	{
+		.ctl_name	= GS_GROUP,
+		.procname	= "audit_group",
+		.data		= &grsec_enable_group,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= GS_GID,
+		.procname	= "audit_gid",
+		.data		= &grsec_audit_gid,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	{
+		.ctl_name	= GS_ACHDIR,
+		.procname	= "audit_chdir",
+		.data		= &grsec_enable_chdir,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	{
+		.ctl_name	= GS_AMOUNT,
+		.procname	= "audit_mount",
+		.data		= &grsec_enable_mount,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	{
+		.ctl_name	= GS_AIPC,
+		.procname	= "audit_ipc",
+		.data		= &grsec_enable_audit_ipc,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_TEXTREL
+	{
+		.ctl_name	= GS_TEXTREL,
+		.procname	= "audit_textrel",
+		.data		= &grsec_enable_audit_textrel,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+	{
+		.ctl_name	= GS_DMSG,
+		.procname	= "dmesg",
+		.data		= &grsec_enable_dmesg,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	{
+		.ctl_name	= GS_FINDTASK,
+		.procname	= "chroot_findtask",
+		.data		= &grsec_enable_chroot_findtask,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+#ifdef CONFIG_GRKERNSEC_SHM
+	{
+		.ctl_name	= GS_SHM,
+		.procname	= "destroy_unused_shm",
+		.data		= &grsec_enable_shm,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+	{
+		.ctl_name	= GS_LOCK,
+		.procname	= "grsec_lock",
+		.data		= &grsec_lock,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+	{ .ctl_name = 0 }
+};
+#endif
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_textrel.c grsecurity226/grsecurity/grsec_textrel.c
--- linux-2.6.13.1.org/grsecurity/grsec_textrel.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_textrel.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,16 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+#include <linux/grsecurity.h>
+
+void
+gr_log_textrel(struct vm_area_struct * vma)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_TEXTREL
+	if (grsec_enable_audit_textrel)
+		gr_log_textrel_ulong_ulong(GR_DO_AUDIT, GR_TEXTREL_AUDIT_MSG, vma->vm_file, vma->vm_start, vma->vm_pgoff);
+#endif
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_time.c grsecurity226/grsecurity/grsec_time.c
--- linux-2.6.13.1.org/grsecurity/grsec_time.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_time.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,13 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_timechange(void)
+{
+#ifdef CONFIG_GRKERNSEC_TIME
+	if (grsec_enable_time)
+		gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_TIME_MSG);
+#endif
+	return;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsec_tpe.c grsecurity226/grsecurity/grsec_tpe.c
--- linux-2.6.13.1.org/grsecurity/grsec_tpe.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsec_tpe.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,37 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/grinternal.h>
+
+extern int gr_acl_tpe_check(void);
+
+int
+gr_tpe_allow(const struct file *file)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct inode *inode = file->f_dentry->d_parent->d_inode;
+
+	if (current->uid && ((grsec_enable_tpe &&
+#ifdef CONFIG_GRKERNSEC_TPE_INVERT
+	    !in_group_p(grsec_tpe_gid)
+#else
+	    in_group_p(grsec_tpe_gid)
+#endif
+	    ) || gr_acl_tpe_check()) &&
+	    (inode->i_uid || (!inode->i_uid && ((inode->i_mode & S_IWGRP) ||
+						(inode->i_mode & S_IWOTH))))) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_EXEC_TPE_MSG, file->f_dentry, file->f_vfsmnt);
+		return 0;
+	}
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	if (current->uid && grsec_enable_tpe && grsec_enable_tpe_all &&
+	    ((inode->i_uid && (inode->i_uid != current->uid)) ||
+	     (inode->i_mode & S_IWGRP) || (inode->i_mode & S_IWOTH))) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_EXEC_TPE_MSG, file->f_dentry, file->f_vfsmnt);
+		return 0;
+	}
+#endif
+#endif
+	return 1;
+}
diff -Nur linux-2.6.13.1.org/grsecurity/grsum.c grsecurity226/grsecurity/grsum.c
--- linux-2.6.13.1.org/grsecurity/grsum.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/grsecurity/grsum.c	2005-08-30 01:14:26.000000000 +0200
@@ -0,0 +1,59 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/scatterlist.h>
+#include <linux/crypto.h>
+#include <linux/gracl.h>
+
+
+#if !defined(CONFIG_CRYPTO) || defined(CONFIG_CRYPTO_MODULE) || !defined(CONFIG_CRYPTO_SHA256) || defined(CONFIG_CRYPTO_SHA256_MODULE)
+#error "crypto and sha256 must be built into the kernel"
+#endif
+
+int
+chkpw(struct gr_arg *entry, unsigned char *salt, unsigned char *sum)
+{
+	char *p;
+	struct crypto_tfm *tfm;
+	unsigned char temp_sum[GR_SHA_LEN];
+	struct scatterlist sg[2];
+	volatile int retval = 0;
+	volatile int dummy = 0;
+	unsigned int i;
+
+	tfm = crypto_alloc_tfm("sha256", 0);
+	if (tfm == NULL) {
+		/* should never happen, since sha256 should be built in */
+		return 1;
+	}
+
+	crypto_digest_init(tfm);
+
+	p = salt;
+	sg[0].page = virt_to_page(p);
+	sg[0].offset = ((long) p & ~PAGE_MASK);
+	sg[0].length = GR_SALT_LEN;
+	
+	crypto_digest_update(tfm, sg, 1);
+
+	p = entry->pw;
+	sg[0].page = virt_to_page(p);
+	sg[0].offset = ((long) p & ~PAGE_MASK);
+	sg[0].length = strlen(entry->pw);
+
+	crypto_digest_update(tfm, sg, 1);
+
+	crypto_digest_final(tfm, temp_sum);
+
+	memset(entry->pw, 0, GR_PW_LEN);
+
+	for (i = 0; i < GR_SHA_LEN; i++)
+		if (sum[i] != temp_sum[i])
+			retval = 1;
+		else
+			dummy = 1;	// waste a cycle
+
+	crypto_free_tfm(tfm);
+
+	return retval;
+}
diff -Nur linux-2.6.13.1.org/include/acpi/acpi_bus.h grsecurity226/include/acpi/acpi_bus.h
--- linux-2.6.13.1.org/include/acpi/acpi_bus.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/acpi/acpi_bus.h	2005-08-30 01:00:40.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *  acpi_bus.h - ACPI Bus Driver ($Revision$)
+ *  acpi_bus.h - ACPI Bus Driver ($Revision$)
  *
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
diff -Nur linux-2.6.13.1.org/include/acpi/acpi_drivers.h grsecurity226/include/acpi/acpi_drivers.h
--- linux-2.6.13.1.org/include/acpi/acpi_drivers.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/acpi/acpi_drivers.h	2005-08-30 01:00:40.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *  acpi_drivers.h  ($Revision$)
+ *  acpi_drivers.h  ($Revision$)
  *
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
diff -Nur linux-2.6.13.1.org/include/asm-alpha/a.out.h grsecurity226/include/asm-alpha/a.out.h
--- linux-2.6.13.1.org/include/asm-alpha/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-alpha/a.out.h	2005-08-30 01:14:29.000000000 +0200
@@ -98,7 +98,7 @@
 	set_personality (((BFPM->sh_bang || EX.ah.entry < 0x100000000L \
 			   ? ADDR_LIMIT_32BIT : 0) | PER_OSF4))
 
-#define STACK_TOP \
+#define __STACK_TOP \
   (current->personality & ADDR_LIMIT_32BIT ? 0x80000000 : 0x00120000000UL)
 
 #endif
diff -Nur linux-2.6.13.1.org/include/asm-alpha/dma.h grsecurity226/include/asm-alpha/dma.h
--- linux-2.6.13.1.org/include/asm-alpha/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-alpha/dma.h	2005-08-30 01:00:40.000000000 +0200
@@ -8,7 +8,7 @@
  * as this will also enable DMA across 64 KB boundaries.
  */
 
-/* $Id$
+/* $Id$
  * linux/include/asm/dma.h: Defines for using and allocating dma channels.
  * Written by Hennus Bergman, 1992.
  * High DMA channel support & info by Hannu Savolainen
diff -Nur linux-2.6.13.1.org/include/asm-alpha/elf.h grsecurity226/include/asm-alpha/elf.h
--- linux-2.6.13.1.org/include/asm-alpha/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-alpha/elf.h	2005-08-30 01:14:29.000000000 +0200
@@ -89,6 +89,17 @@
 
 #define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x1000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	((tsk)->personality & ADDR_LIMIT_32BIT ? 0x10000 : 0x120000000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk)->personality & ADDR_LIMIT_32BIT ? 14 : 28)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((tsk)->personality & ADDR_LIMIT_32BIT ? 14 : 28)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk)->personality & ADDR_LIMIT_32BIT ? 14 : 19)
+#endif
+
 /* $0 is set by ld.so to a pointer to a function which might be 
    registered using atexit.  This provides a mean for the dynamic
    linker to call DT_FINI functions for shared libraries that have
diff -Nur linux-2.6.13.1.org/include/asm-alpha/md.h grsecurity226/include/asm-alpha/md.h
--- linux-2.6.13.1.org/include/asm-alpha/md.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-alpha/md.h	2005-08-30 01:00:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * md.h: High speed xor_block operation for RAID4/5 
  *
  */
diff -Nur linux-2.6.13.1.org/include/asm-alpha/namei.h grsecurity226/include/asm-alpha/namei.h
--- linux-2.6.13.1.org/include/asm-alpha/namei.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-alpha/namei.h	2005-08-30 01:00:40.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm-alpha/namei.h
  *
  * Included from linux/fs/namei.c
diff -Nur linux-2.6.13.1.org/include/asm-alpha/page.h grsecurity226/include/asm-alpha/page.h
--- linux-2.6.13.1.org/include/asm-alpha/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-alpha/page.h	2005-08-30 01:14:29.000000000 +0200
@@ -110,6 +110,15 @@
 #define VM_DATA_DEFAULT_FLAGS		(VM_READ | VM_WRITE | VM_EXEC | \
 					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _ALPHA_PAGE_H */
diff -Nur linux-2.6.13.1.org/include/asm-alpha/pgtable.h grsecurity226/include/asm-alpha/pgtable.h
--- linux-2.6.13.1.org/include/asm-alpha/pgtable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-alpha/pgtable.h	2005-08-30 01:14:29.000000000 +0200
@@ -99,6 +99,17 @@
 #define PAGE_SHARED	__pgprot(_PAGE_VALID | __ACCESS_BITS)
 #define PAGE_COPY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
 #define PAGE_READONLY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOE)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_VALID | _PAGE_ASM | _PAGE_KRE | _PAGE_KWE)
 
 #define _PAGE_NORMAL(x) __pgprot(_PAGE_VALID | __ACCESS_BITS | (x))
diff -Nur linux-2.6.13.1.org/include/asm-arm/a.out.h grsecurity226/include/asm-arm/a.out.h
--- linux-2.6.13.1.org/include/asm-arm/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/a.out.h	2005-08-30 01:14:31.000000000 +0200
@@ -28,7 +28,7 @@
 #define M_ARM 103
 
 #ifdef __KERNEL__
-#define STACK_TOP	((current->personality == PER_LINUX_32BIT) ? \
+#define __STACK_TOP	((current->personality == PER_LINUX_32BIT) ? \
 			 TASK_SIZE : TASK_SIZE_26)
 #endif
 
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-integrator/platform.h grsecurity226/include/asm-arm/arch-integrator/platform.h
--- linux-2.6.13.1.org/include/asm-arm/arch-integrator/platform.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-integrator/platform.h	2005-08-30 01:00:41.000000000 +0200
@@ -26,7 +26,7 @@
  * 	NOTE: This is a multi-hosted header file for use with uHAL and
  * 	      supported debuggers.
  *
- * 	$Id$
+ * 	$Id$
  *
  * ***********************************************************************/
 
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-pxa/mtd-xip.h grsecurity226/include/asm-arm/arch-pxa/mtd-xip.h
--- linux-2.6.13.1.org/include/asm-arm/arch-pxa/mtd-xip.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-pxa/mtd-xip.h	2005-08-30 01:00:42.000000000 +0200
@@ -11,7 +11,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef __ARCH_PXA_MTD_XIP_H__
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-clock.h grsecurity226/include/asm-arm/arch-s3c2410/regs-clock.h
--- linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-clock.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-s3c2410/regs-clock.h	2005-08-30 01:00:42.000000000 +0200
@@ -20,7 +20,7 @@
  */
 
 #ifndef __ASM_ARM_REGS_CLOCK
-#define __ASM_ARM_REGS_CLOCK "$Id$"
+#define __ASM_ARM_REGS_CLOCK "$Id$"
 
 #define S3C2410_CLKREG(x) ((x) + S3C24XX_VA_CLKPWR)
 
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-gpio.h grsecurity226/include/asm-arm/arch-s3c2410/regs-gpio.h
--- linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-gpio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-s3c2410/regs-gpio.h	2005-08-30 01:00:42.000000000 +0200
@@ -24,7 +24,7 @@
 
 
 #ifndef __ASM_ARCH_REGS_GPIO_H
-#define __ASM_ARCH_REGS_GPIO_H "$Id$"
+#define __ASM_ARCH_REGS_GPIO_H "$Id$"
 
 #define S3C2410_GPIONO(bank,offset) ((bank) + (offset))
 
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-irq.h grsecurity226/include/asm-arm/arch-s3c2410/regs-irq.h
--- linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-irq.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-s3c2410/regs-irq.h	2005-08-30 01:00:42.000000000 +0200
@@ -17,7 +17,7 @@
 
 
 #ifndef ___ASM_ARCH_REGS_IRQ_H
-#define ___ASM_ARCH_REGS_IRQ_H "$Id$"
+#define ___ASM_ARCH_REGS_IRQ_H "$Id$"
 
 /* interrupt controller */
 
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-lcd.h grsecurity226/include/asm-arm/arch-s3c2410/regs-lcd.h
--- linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-lcd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-s3c2410/regs-lcd.h	2005-08-30 01:00:42.000000000 +0200
@@ -18,7 +18,7 @@
 
 
 #ifndef ___ASM_ARCH_REGS_LCD_H
-#define ___ASM_ARCH_REGS_LCD_H "$Id$"
+#define ___ASM_ARCH_REGS_LCD_H "$Id$"
 
 #define S3C2410_LCDREG(x) ((x) + S3C24XX_VA_LCD)
 
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-mem.h grsecurity226/include/asm-arm/arch-s3c2410/regs-mem.h
--- linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-mem.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-s3c2410/regs-mem.h	2005-08-30 01:00:42.000000000 +0200
@@ -17,7 +17,7 @@
 */
 
 #ifndef __ASM_ARM_MEMREGS_H
-#define __ASM_ARM_MEMREGS_H "$Id$"
+#define __ASM_ARM_MEMREGS_H "$Id$"
 
 #ifndef S3C2410_MEMREG
 #define S3C2410_MEMREG(x) (S3C24XX_VA_MEMCTRL + (x))
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-nand.h grsecurity226/include/asm-arm/arch-s3c2410/regs-nand.h
--- linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-nand.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-s3c2410/regs-nand.h	2005-08-30 01:00:42.000000000 +0200
@@ -15,7 +15,7 @@
 */
 
 #ifndef __ASM_ARM_REGS_NAND
-#define __ASM_ARM_REGS_NAND "$Id$"
+#define __ASM_ARM_REGS_NAND "$Id$"
 
 
 #define S3C2410_NFREG(x) (x)
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-timer.h grsecurity226/include/asm-arm/arch-s3c2410/regs-timer.h
--- linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-timer.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-s3c2410/regs-timer.h	2005-08-30 01:00:42.000000000 +0200
@@ -19,7 +19,7 @@
 
 
 #ifndef __ASM_ARCH_REGS_TIMER_H
-#define __ASM_ARCH_REGS_TIMER_H "$Id$"
+#define __ASM_ARCH_REGS_TIMER_H "$Id$"
 
 #define S3C2410_TIMERREG(x) (S3C24XX_VA_TIMER + (x))
 #define S3C2410_TIMERREG2(tmr,reg) S3C2410_TIMERREG((reg)+0x0c+((tmr)*0x0c))
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-watchdog.h grsecurity226/include/asm-arm/arch-s3c2410/regs-watchdog.h
--- linux-2.6.13.1.org/include/asm-arm/arch-s3c2410/regs-watchdog.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-s3c2410/regs-watchdog.h	2005-08-30 01:00:42.000000000 +0200
@@ -17,7 +17,7 @@
 
 
 #ifndef __ASM_ARCH_REGS_WATCHDOG_H
-#define __ASM_ARCH_REGS_WATCHDOG_H "$Id$"
+#define __ASM_ARCH_REGS_WATCHDOG_H "$Id$"
 
 #define S3C2410_WDOGREG(x) ((x) + S3C24XX_VA_WATCHDOG)
 
diff -Nur linux-2.6.13.1.org/include/asm-arm/arch-sa1100/mtd-xip.h grsecurity226/include/asm-arm/arch-sa1100/mtd-xip.h
--- linux-2.6.13.1.org/include/asm-arm/arch-sa1100/mtd-xip.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/arch-sa1100/mtd-xip.h	2005-08-30 01:00:42.000000000 +0200
@@ -11,7 +11,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef __ARCH_SA1100_MTD_XIP_H__
diff -Nur linux-2.6.13.1.org/include/asm-arm/elf.h grsecurity226/include/asm-arm/elf.h
--- linux-2.6.13.1.org/include/asm-arm/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/elf.h	2005-08-30 01:14:31.000000000 +0200
@@ -54,6 +54,17 @@
 
 #define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x00008000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk->personality == PER_LINUX_32BIT) ? 16 : 10)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((tsk->personality == PER_LINUX_32BIT) ? 16 : 10)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk->personality == PER_LINUX_32BIT) ? 16 : 10)
+#endif
+
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
    have no such handler.  */
diff -Nur linux-2.6.13.1.org/include/asm-arm/mtd-xip.h grsecurity226/include/asm-arm/mtd-xip.h
--- linux-2.6.13.1.org/include/asm-arm/mtd-xip.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-arm/mtd-xip.h	2005-08-30 01:00:41.000000000 +0200
@@ -11,7 +11,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef __ARM_MTD_XIP_H__
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v10/io_interface_mux.h grsecurity226/include/asm-cris/arch-v10/io_interface_mux.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v10/io_interface_mux.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v10/io_interface_mux.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,6 +1,6 @@
 /* IO interface mux allocator for ETRAX100LX.
  * Copyright 2004, Axis Communications AB
- * $Id$
+ * $Id$
  */
 
 
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/Makefile grsecurity226/include/asm-cris/arch-v32/hwregs/Makefile
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/Makefile	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-# $Id$
+# $Id$
 # Makefile to generate or copy the latest register definitions
 # and related datastructures and helpermacros.
 # The offical place for these files is at:
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/ata_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/ata_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/ata_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/ata_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:25 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/ata_defs_asm.h ../../inst/ata/rtl/ata_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/bif_core_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/bif_core_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/bif_core_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/bif_core_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:33 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/bif_core_defs_asm.h ../../inst/bif/rtl/bif_core_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/bif_dma_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/bif_dma_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/bif_dma_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/bif_dma_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:33 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/bif_dma_defs_asm.h ../../inst/bif/rtl/bif_dma_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/bif_slave_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/bif_slave_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/bif_slave_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/bif_slave_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:34 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/bif_slave_defs_asm.h ../../inst/bif/rtl/bif_slave_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/config_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/config_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/config_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/config_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Thu Mar  4 12:34:39 2004
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/config_defs_asm.h ../../rtl/config_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/cris_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/cris_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/cris_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/cris_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:39 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/cris_defs_asm.h ../../inst/crisp/doc/cris.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/dma_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/dma_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/dma_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/dma_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:51 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/dma_defs_asm.h ../../inst/dma/inst/dma_common/rtl/dma_regdes.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/eth_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/eth_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/eth_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/eth_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:07:03 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/eth_defs_asm.h ../../inst/eth/rtl/eth_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/gio_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/gio_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/gio_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/gio_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:07:47 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/gio_defs_asm.h ../../inst/gio/rtl/gio_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/intr_vect_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/intr_vect_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/intr_vect_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/intr_vect_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:03 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/intr_vect_defs_asm.h ../../inst/intr_vect/rtl/guinness/ivmask.config.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/irq_nmi_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/irq_nmi_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/irq_nmi_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/irq_nmi_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Thu Jan 22 09:22:43 2004
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/irq_nmi_defs_asm.h ../../mod/irq_nmi.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/marb_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/marb_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/marb_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/marb_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:12:16 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/marb_defs_asm.h ../../inst/memarb/rtl/guinness/marb_top.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
@@ -315,7 +315,7 @@
  *     last modfied: Mon Apr 11 16:12:16 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/marb_defs_asm.h ../../inst/memarb/rtl/guinness/marb_top.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/mmu_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/mmu_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/mmu_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/mmu_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 17:03:20 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/mmu_defs_asm.h ../../inst/mmu/doc/mmu_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/pinmux_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/pinmux_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/pinmux_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/pinmux_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:11 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/pinmux_defs_asm.h ../../inst/pinmux/rtl/guinness/pinmux_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/reg_map_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/reg_map_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/reg_map_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/reg_map_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -14,7 +14,7 @@
  *     last modified: Fri Feb 20 16:40:04 2004
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/reg_map_asm.h -base 0xb0000000 ../../rtl/global.rmap ../../mod/modreg.rmap ../../inst/memarb/rtl/guinness/marb_top.r ../../mod/fakereg.rmap
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/rt_trace_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/rt_trace_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/rt_trace_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/rt_trace_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:14 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/rt_trace_defs_asm.h ../../inst/rt_trace/rtl/rt_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/ser_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/ser_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/ser_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/ser_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:21 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/ser_defs_asm.h ../../inst/ser/rtl/ser_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/sser_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/sser_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/sser_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/sser_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:48 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/sser_defs_asm.h ../../inst/syncser/rtl/sser_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/strcop_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/strcop_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/strcop_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/strcop_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:38 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/strcop_defs_asm.h ../../inst/strcop/rtl/strcop_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/strmux_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/strmux_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/strmux_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/strmux_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:43 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/strmux_defs_asm.h ../../inst/strmux/rtl/guinness/strmux_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/timer_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/asm/timer_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/asm/timer_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/asm/timer_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:53 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/timer_defs_asm.h ../../inst/timer/rtl/timer_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/ata_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/ata_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/ata_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/ata_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:25 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile ata_defs.h ../../inst/ata/rtl/ata_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/bif_core_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/bif_core_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/bif_core_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/bif_core_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:33 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile bif_core_defs.h ../../inst/bif/rtl/bif_core_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/bif_dma_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/bif_dma_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/bif_dma_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/bif_dma_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:33 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile bif_dma_defs.h ../../inst/bif/rtl/bif_dma_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/bif_slave_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/bif_slave_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/bif_slave_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/bif_slave_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:34 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile bif_slave_defs.h ../../inst/bif/rtl/bif_slave_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/config_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/config_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/config_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/config_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Thu Mar  4 12:34:39 2004
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile config_defs.h ../../rtl/config_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/dma.h grsecurity226/include/asm-cris/arch-v32/hwregs/dma.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/dma.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * DMA C definitions and help macros
  *
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/dma_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/dma_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/dma_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/dma_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:06:51 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile dma_defs.h ../../inst/dma/inst/dma_common/rtl/dma_regdes.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/eth_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/eth_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/eth_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/eth_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:07:03 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile eth_defs.h ../../inst/eth/rtl/eth_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/extmem_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/extmem_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/extmem_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/extmem_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Tue Mar 30 22:26:21 2004
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile extmem_defs.h ../../inst/ext_mem/mod/extmem_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/gio_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/gio_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/gio_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/gio_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:07:47 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile gio_defs.h ../../inst/gio/rtl/gio_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/intr_vect_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/intr_vect_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/intr_vect_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/intr_vect_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:03 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile intr_vect_defs.h ../../inst/intr_vect/rtl/guinness/ivmask.config.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/Makefile grsecurity226/include/asm-cris/arch-v32/hwregs/iop/Makefile
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/Makefile	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-# $Id$
+# $Id$
 # Makefile to generate or copy the latest register definitions
 # and related datastructures and helpermacros.
 # The offical place for these files is probably at:
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_crc_par_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_crc_par_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_crc_par_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_crc_par_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_crc_par_defs_asm.h ../../inst/io_proc/rtl/iop_crc_par.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_dmc_in_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_dmc_in_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_dmc_in_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_dmc_in_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_dmc_in_defs_asm.h ../../inst/io_proc/rtl/iop_dmc_in.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_dmc_out_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_dmc_out_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_dmc_out_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_dmc_out_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_dmc_out_defs_asm.h ../../inst/io_proc/rtl/iop_dmc_out.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_in_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_in_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_in_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_in_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:07 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_fifo_in_defs_asm.h ../../inst/io_proc/rtl/iop_fifo_in.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_in_extra_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_in_extra_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_in_extra_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_in_extra_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:08 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_fifo_in_extra_defs_asm.h ../../inst/io_proc/rtl/iop_fifo_in_extra.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_out_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_out_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_out_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_out_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:09 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_fifo_out_defs_asm.h ../../inst/io_proc/rtl/iop_fifo_out.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_out_extra_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_out_extra_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_out_extra_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_fifo_out_extra_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:10 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_fifo_out_extra_defs_asm.h ../../inst/io_proc/rtl/iop_fifo_out_extra.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_mpu_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_mpu_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_mpu_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_mpu_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_mpu_defs_asm.h ../../inst/io_proc/rtl/iop_mpu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sap_in_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sap_in_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sap_in_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sap_in_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_sap_in_defs_asm.h ../../inst/io_proc/rtl/iop_sap_in.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sap_out_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sap_out_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sap_out_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sap_out_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_sap_out_defs_asm.h ../../inst/io_proc/rtl/iop_sap_out.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_scrc_in_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_scrc_in_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_scrc_in_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_scrc_in_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_scrc_in_defs_asm.h ../../inst/io_proc/rtl/iop_scrc_in.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_scrc_out_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_scrc_out_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_scrc_out_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_scrc_out_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_scrc_out_defs_asm.h ../../inst/io_proc/rtl/iop_scrc_out.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_spu_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_spu_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_spu_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_spu_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_spu_defs_asm.h ../../inst/io_proc/rtl/iop_spu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_cfg_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_cfg_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_cfg_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_cfg_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:19 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_sw_cfg_defs_asm.h ../../inst/io_proc/rtl/guinness/iop_sw_cfg.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_cpu_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_cpu_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_cpu_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_cpu_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:19 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_sw_cpu_defs_asm.h ../../inst/io_proc/rtl/guinness/iop_sw_cpu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_mpu_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_mpu_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_mpu_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_mpu_defs_asm.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:19 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_sw_mpu_defs_asm.h ../../inst/io_proc/rtl/guinness/iop_sw_mpu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_spu_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_spu_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_spu_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_sw_spu_defs_asm.h	2005-08-30 01:00:46.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:19 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_sw_spu_defs_asm.h ../../inst/io_proc/rtl/guinness/iop_sw_spu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_timer_grp_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_timer_grp_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_timer_grp_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_timer_grp_defs_asm.h	2005-08-30 01:00:46.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_timer_grp_defs_asm.h ../../inst/io_proc/rtl/iop_timer_grp.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_trigger_grp_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_trigger_grp_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_trigger_grp_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_trigger_grp_defs_asm.h	2005-08-30 01:00:46.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_trigger_grp_defs_asm.h ../../inst/io_proc/rtl/iop_trigger_grp.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_version_defs_asm.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_version_defs_asm.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/asm/iop_version_defs_asm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/asm/iop_version_defs_asm.h	2005-08-30 01:00:46.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:44 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -asm --outfile asm/iop_version_defs_asm.h ../../inst/io_proc/rtl/guinness/iop_version.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_crc_par_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_crc_par_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_crc_par_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_crc_par_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_crc_par_defs.h ../../inst/io_proc/rtl/iop_crc_par.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_dmc_in_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_dmc_in_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_dmc_in_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_dmc_in_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_dmc_in_defs.h ../../inst/io_proc/rtl/iop_dmc_in.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_dmc_out_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_dmc_out_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_dmc_out_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_dmc_out_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_dmc_out_defs.h ../../inst/io_proc/rtl/iop_dmc_out.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_in_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_in_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_in_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_in_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:07 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_fifo_in_defs.h ../../inst/io_proc/rtl/iop_fifo_in.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_in_extra_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_in_extra_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_in_extra_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_in_extra_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:08 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_fifo_in_extra_defs.h ../../inst/io_proc/rtl/iop_fifo_in_extra.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_out_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_out_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_out_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_out_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:09 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_fifo_out_defs.h ../../inst/io_proc/rtl/iop_fifo_out.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_out_extra_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_out_extra_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_out_extra_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_fifo_out_extra_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:10 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_fifo_out_extra_defs.h ../../inst/io_proc/rtl/iop_fifo_out_extra.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_mpu_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_mpu_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_mpu_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_mpu_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_mpu_defs.h ../../inst/io_proc/rtl/iop_mpu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sap_in_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sap_in_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sap_in_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sap_in_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:45 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_sap_in_defs.h ../../inst/io_proc/rtl/iop_sap_in.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sap_out_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sap_out_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sap_out_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sap_out_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_sap_out_defs.h ../../inst/io_proc/rtl/iop_sap_out.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_scrc_in_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_scrc_in_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_scrc_in_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_scrc_in_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_scrc_in_defs.h ../../inst/io_proc/rtl/iop_scrc_in.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_scrc_out_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_scrc_out_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_scrc_out_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_scrc_out_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_scrc_out_defs.h ../../inst/io_proc/rtl/iop_scrc_out.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_spu_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_spu_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_spu_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_spu_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_spu_defs.h ../../inst/io_proc/rtl/iop_spu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sw_cfg_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sw_cfg_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sw_cfg_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sw_cfg_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:19 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_sw_cfg_defs.h ../../inst/io_proc/rtl/guinness/iop_sw_cfg.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sw_cpu_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sw_cpu_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sw_cpu_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sw_cpu_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:19 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_sw_cpu_defs.h ../../inst/io_proc/rtl/guinness/iop_sw_cpu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sw_mpu_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sw_mpu_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sw_mpu_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sw_mpu_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:19 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_sw_mpu_defs.h ../../inst/io_proc/rtl/guinness/iop_sw_mpu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sw_spu_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sw_spu_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_sw_spu_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_sw_spu_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:10:19 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_sw_spu_defs.h ../../inst/io_proc/rtl/guinness/iop_sw_spu.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_timer_grp_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_timer_grp_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_timer_grp_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_timer_grp_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_timer_grp_defs.h ../../inst/io_proc/rtl/iop_timer_grp.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_trigger_grp_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_trigger_grp_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_trigger_grp_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_trigger_grp_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:46 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_trigger_grp_defs.h ../../inst/io_proc/rtl/iop_trigger_grp.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_version_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_version_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/iop/iop_version_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/iop/iop_version_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:08:44 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile iop_version_defs.h ../../inst/io_proc/rtl/guinness/iop_version.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/irq_nmi_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/irq_nmi_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/irq_nmi_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/irq_nmi_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Thu Jan 22 09:22:43 2004
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile irq_nmi_defs.h ../../mod/irq_nmi.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/marb_bp_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/marb_bp_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/marb_bp_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/marb_bp_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Fri Nov  7 15:36:04 2003
  *
  *   by /n/asic/projects/guinness/design/top/inst/rdesc/rdes2c ../../rtl/global.rmap ../../mod/modreg.rmap -base 0xb0000000 ../../inst/memarb/rtl/guinness/marb_top.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/marb_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/marb_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/marb_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/marb_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:12:16 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile marb_defs.h ../../inst/memarb/rtl/guinness/marb_top.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
@@ -267,7 +267,7 @@
  *     last modfied: Mon Apr 11 16:12:16 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile marb_defs.h ../../inst/memarb/rtl/guinness/marb_top.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/pinmux_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/pinmux_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/pinmux_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/pinmux_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:11 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile pinmux_defs.h ../../inst/pinmux/rtl/guinness/pinmux_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/reg_map.h grsecurity226/include/asm-cris/arch-v32/hwregs/reg_map.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/reg_map.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/reg_map.h	2005-08-30 01:00:45.000000000 +0200
@@ -14,7 +14,7 @@
  *     last modified: Fri Feb 20 16:40:04 2004
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c -map -base 0xb0000000 ../../rtl/global.rmap ../../mod/modreg.rmap ../../inst/io_proc/rtl/guinness/iop_top.r ../../inst/memarb/rtl/guinness/marb_top.r ../../mod/fakereg.rmap
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/reg_rdwr.h grsecurity226/include/asm-cris/arch-v32/hwregs/reg_rdwr.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/reg_rdwr.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/reg_rdwr.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Read/write register macros used by *_defs.h
  */
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/rt_trace_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/rt_trace_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/rt_trace_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/rt_trace_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:14 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile rt_trace_defs.h ../../inst/rt_trace/rtl/rt_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/ser_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/ser_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/ser_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/ser_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:21 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile ser_defs.h ../../inst/ser/rtl/ser_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/sser_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/sser_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/sser_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/sser_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:48 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile sser_defs.h ../../inst/syncser/rtl/sser_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/strcop.h grsecurity226/include/asm-cris/arch-v32/hwregs/strcop.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/strcop.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/strcop.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-// $Id$
+// $Id$
 
 // Streamcop meta-data configuration structs
 
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/strcop_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/strcop_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/strcop_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/strcop_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:38 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile strcop_defs.h ../../inst/strcop/rtl/strcop_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/strmux_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/strmux_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/strmux_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/strmux_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:43 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile strmux_defs.h ../../inst/strmux/rtl/guinness/strmux_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/timer_defs.h grsecurity226/include/asm-cris/arch-v32/hwregs/timer_defs.h
--- linux-2.6.13.1.org/include/asm-cris/arch-v32/hwregs/timer_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/arch-v32/hwregs/timer_defs.h	2005-08-30 01:00:45.000000000 +0200
@@ -8,7 +8,7 @@
  *     last modfied: Mon Apr 11 16:09:53 2005
  *
  *   by /n/asic/design/tools/rdesc/src/rdes2c --outfile timer_defs.h ../../inst/timer/rtl/timer_regs.r
- *      id: $Id$
+ *      id: $Id$
  * Any changes here will be lost.
  *
  * -*- buffer-read-only: t -*-
diff -Nur linux-2.6.13.1.org/include/asm-cris/atomic.h grsecurity226/include/asm-cris/atomic.h
--- linux-2.6.13.1.org/include/asm-cris/atomic.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/atomic.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef __ASM_CRIS_ATOMIC__
 #define __ASM_CRIS_ATOMIC__
diff -Nur linux-2.6.13.1.org/include/asm-cris/bugs.h grsecurity226/include/asm-cris/bugs.h
--- linux-2.6.13.1.org/include/asm-cris/bugs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/bugs.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  *  include/asm-cris/bugs.h
  *
diff -Nur linux-2.6.13.1.org/include/asm-cris/dma.h grsecurity226/include/asm-cris/dma.h
--- linux-2.6.13.1.org/include/asm-cris/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/dma.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _ASM_DMA_H
 #define _ASM_DMA_H
diff -Nur linux-2.6.13.1.org/include/asm-cris/eshlibld.h grsecurity226/include/asm-cris/eshlibld.h
--- linux-2.6.13.1.org/include/asm-cris/eshlibld.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/eshlibld.h	2005-08-30 01:00:45.000000000 +0200
@@ -12,7 +12,7 @@
 *! (C) Copyright 1998, 1999 Axis Communications AB, LUND, SWEDEN
 *!
 *!**************************************************************************/
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _cris_relocate_h
 #define _cris_relocate_h
diff -Nur linux-2.6.13.1.org/include/asm-cris/etraxgpio.h grsecurity226/include/asm-cris/etraxgpio.h
--- linux-2.6.13.1.org/include/asm-cris/etraxgpio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/etraxgpio.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 /*
  * The following devices are accessable using this driver using
  * GPIO_MAJOR (120) and a couple of minor numbers:
diff -Nur linux-2.6.13.1.org/include/asm-cris/etraxi2c.h grsecurity226/include/asm-cris/etraxi2c.h
--- linux-2.6.13.1.org/include/asm-cris/etraxi2c.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/etraxi2c.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _LINUX_ETRAXI2C_H
 #define _LINUX_ETRAXI2C_H
diff -Nur linux-2.6.13.1.org/include/asm-cris/fasttimer.h grsecurity226/include/asm-cris/fasttimer.h
--- linux-2.6.13.1.org/include/asm-cris/fasttimer.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/fasttimer.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm-cris/fasttimer.h
  *
  * Fast timers for ETRAX100LX
diff -Nur linux-2.6.13.1.org/include/asm-cris/namei.h grsecurity226/include/asm-cris/namei.h
--- linux-2.6.13.1.org/include/asm-cris/namei.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/namei.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm-cris/namei.h
  *
  * Included from linux/fs/namei.c
diff -Nur linux-2.6.13.1.org/include/asm-cris/posix_types.h grsecurity226/include/asm-cris/posix_types.h
--- linux-2.6.13.1.org/include/asm-cris/posix_types.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/posix_types.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 /* We cheat a bit and use our C-coded bitops functions from asm/bitops.h */
 /* I guess we should write these in assembler because they are used often. */
diff -Nur linux-2.6.13.1.org/include/asm-cris/rtc.h grsecurity226/include/asm-cris/rtc.h
--- linux-2.6.13.1.org/include/asm-cris/rtc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/rtc.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef __RTC_H__
 #define __RTC_H__
diff -Nur linux-2.6.13.1.org/include/asm-cris/semaphore-helper.h grsecurity226/include/asm-cris/semaphore-helper.h
--- linux-2.6.13.1.org/include/asm-cris/semaphore-helper.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/semaphore-helper.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * SMP- and interrupt-safe semaphores helper functions. Generic versions, no
  * optimizations whatsoever... 
diff -Nur linux-2.6.13.1.org/include/asm-cris/semaphore.h grsecurity226/include/asm-cris/semaphore.h
--- linux-2.6.13.1.org/include/asm-cris/semaphore.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/semaphore.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 /* On the i386 these are coded in asm, perhaps we should as well. Later.. */
 
diff -Nur linux-2.6.13.1.org/include/asm-cris/sigcontext.h grsecurity226/include/asm-cris/sigcontext.h
--- linux-2.6.13.1.org/include/asm-cris/sigcontext.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/sigcontext.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _ASM_CRIS_SIGCONTEXT_H
 #define _ASM_CRIS_SIGCONTEXT_H
diff -Nur linux-2.6.13.1.org/include/asm-cris/termbits.h grsecurity226/include/asm-cris/termbits.h
--- linux-2.6.13.1.org/include/asm-cris/termbits.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/termbits.h	2005-08-30 01:00:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef __ARCH_ETRAX100_TERMBITS_H__
 #define __ARCH_ETRAX100_TERMBITS_H__
diff -Nur linux-2.6.13.1.org/include/asm-cris/uaccess.h grsecurity226/include/asm-cris/uaccess.h
--- linux-2.6.13.1.org/include/asm-cris/uaccess.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-cris/uaccess.h	2005-08-30 01:00:45.000000000 +0200
@@ -3,6 +3,9 @@
  *	       Hans-Peter Nilsson (hp@axis.com)
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:45  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.8  2001/10/29 13:01:48  bjornw
  * Removed unused variable tmp2 in strnlen_user
  *
diff -Nur linux-2.6.13.1.org/include/asm-h8300/ioctl.h grsecurity226/include/asm-h8300/ioctl.h
--- linux-2.6.13.1.org/include/asm-h8300/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-h8300/ioctl.h	2005-08-30 01:00:46.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * linux/ioctl.h for Linux by H.H. Bergman.
  */
diff -Nur linux-2.6.13.1.org/include/asm-h8300/md.h grsecurity226/include/asm-h8300/md.h
--- linux-2.6.13.1.org/include/asm-h8300/md.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-h8300/md.h	2005-08-30 01:00:46.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * md.h: High speed xor_block operation for RAID4/5 
  *
  */
diff -Nur linux-2.6.13.1.org/include/asm-i386/a.out.h grsecurity226/include/asm-i386/a.out.h
--- linux-2.6.13.1.org/include/asm-i386/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/a.out.h	2005-08-30 01:14:34.000000000 +0200
@@ -19,7 +19,11 @@
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#ifdef CONFIG_PAX_SEGMEXEC
+#define __STACK_TOP ((current->mm->pax_flags & MF_PAX_SEGMEXEC)?TASK_SIZE/2:TASK_SIZE)
+#else
+#define __STACK_TOP TASK_SIZE
+#endif
 
 #endif
 
diff -Nur linux-2.6.13.1.org/include/asm-i386/desc.h grsecurity226/include/asm-i386/desc.h
--- linux-2.6.13.1.org/include/asm-i386/desc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/desc.h	2005-08-30 01:14:34.000000000 +0200
@@ -10,12 +10,70 @@
 
 #include <linux/preempt.h>
 #include <linux/smp.h>
-#include <linux/percpu.h>
+#include <linux/sched.h>
 
 #include <asm/mmu.h>
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
 
-extern struct desc_struct cpu_gdt_table[GDT_ENTRIES];
-DECLARE_PER_CPU(struct desc_struct, cpu_gdt_table[GDT_ENTRIES]);
+extern struct desc_struct cpu_gdt_table[NR_CPUS][GDT_ENTRIES];
+
+#define pax_open_kernel(flags, cr3)		\
+do {						\
+	typecheck(unsigned long,flags);		\
+	typecheck(unsigned long,cr3);		\
+	local_irq_save(flags);			\
+	asm("movl %%cr3,%0":"=r" (cr3));	\
+	load_cr3(kernexec_pg_dir);		\
+} while(0)
+
+#define pax_close_kernel(flags, cr3)		\
+do {						\
+	typecheck(unsigned long,flags);		\
+	typecheck(unsigned long,cr3);		\
+	asm("movl %0,%%cr3": :"r" (cr3));	\
+	local_irq_restore(flags);		\
+} while(0)
+
+#define pax_open_kernel_noirq(cr3)		\
+do {						\
+	typecheck(unsigned long,cr3);		\
+	asm("movl %%cr3,%0":"=r" (cr3));	\
+	load_cr3(kernexec_pg_dir);		\
+} while(0)
+
+#define pax_close_kernel_noirq(cr3)		\
+do {						\
+	typecheck(unsigned long,cr3);		\
+	asm("movl %0,%%cr3": :"r" (cr3));	\
+} while(0)
+
+static inline void set_user_cs(struct mm_struct *mm, int cpu)
+{
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	unsigned long base = mm->context.user_cs_base;
+	unsigned long limit = mm->context.user_cs_limit;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long flags, cr3;
+
+	pax_open_kernel(flags, cr3);
+#endif
+
+	if (limit) {
+		limit -= 1UL;
+		limit >>= 12;
+	}
+
+	cpu_gdt_table[cpu][GDT_ENTRY_DEFAULT_USER_CS].a = (limit & 0xFFFFUL) | (base << 16);
+	cpu_gdt_table[cpu][GDT_ENTRY_DEFAULT_USER_CS].b = (limit & 0xF0000UL) | 0xC0FB00UL | (base & 0xFF000000UL) | ((base >> 16) & 0xFFUL);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(flags, cr3);
+#endif
+
+#endif
+}
 
 DECLARE_PER_CPU(unsigned char, cpu_16bit_stack[CPU_16BIT_STACK_SIZE]);
 
@@ -34,7 +92,7 @@
  * This is the ldt that every process will get unless we need
  * something other than this.
  */
-extern struct desc_struct default_ldt[];
+extern const struct desc_struct default_ldt[];
 extern void set_intr_gate(unsigned int irq, void * addr);
 
 #define _set_tssldt_desc(n,addr,limit,type) \
@@ -48,17 +106,34 @@
 	"rorl $16,%%eax" \
 	: "=m"(*(n)) : "a" (addr), "r"(n), "ir"(limit), "i"(type))
 
-static inline void __set_tss_desc(unsigned int cpu, unsigned int entry, void *addr)
+static inline void __set_tss_desc(unsigned int cpu, unsigned int entry, const void *addr)
 {
-	_set_tssldt_desc(&per_cpu(cpu_gdt_table, cpu)[entry], (int)addr,
+	_set_tssldt_desc(&cpu_gdt_table[cpu][entry], (int)addr,
 		offsetof(struct tss_struct, __cacheline_filler) - 1, 0x89);
 }
 
 #define set_tss_desc(cpu,addr) __set_tss_desc(cpu, GDT_ENTRY_TSS, addr)
 
-static inline void set_ldt_desc(unsigned int cpu, void *addr, unsigned int size)
+static inline void __set_ldt_desc(unsigned int cpu, const void *addr, unsigned int size)
 {
-	_set_tssldt_desc(&per_cpu(cpu_gdt_table, cpu)[GDT_ENTRY_LDT], (int)addr, ((size << 3)-1), 0x82);
+	_set_tssldt_desc(&cpu_gdt_table[cpu][GDT_ENTRY_LDT], (int)addr, ((size << 3)-1), 0x82);
+}
+
+static inline void set_ldt_desc(unsigned int cpu, const void *addr, unsigned int size)
+{
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long flags, cr3;
+
+	pax_open_kernel(flags, cr3);
+#endif
+
+	_set_tssldt_desc(&cpu_gdt_table[cpu][GDT_ENTRY_LDT], (int)addr, ((size << 3)-1), 0x82);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(flags, cr3);
+#endif
+
 }
 
 #define LDT_entry_a(info) \
@@ -74,7 +149,7 @@
 	((info)->seg_32bit << 22) | \
 	((info)->limit_in_pages << 23) | \
 	((info)->useable << 20) | \
-	0x7000)
+	0x7100)
 
 #define LDT_empty(info) (\
 	(info)->base_addr	== 0	&& \
@@ -92,7 +167,7 @@
 
 static inline void load_TLS(struct thread_struct *t, unsigned int cpu)
 {
-#define C(i) per_cpu(cpu_gdt_table, cpu)[GDT_ENTRY_TLS_MIN + i] = t->tls_array[i]
+#define C(i) cpu_gdt_table[cpu][GDT_ENTRY_TLS_MIN + i] = t->tls_array[i]
 	C(0); C(1); C(2);
 #undef C
 }
@@ -111,7 +186,7 @@
  */
 static inline void load_LDT_nolock(mm_context_t *pc, int cpu)
 {
-	void *segments = pc->ldt;
+	const void *segments = pc->ldt;
 	int count = pc->size;
 
 	if (likely(!count)) {
@@ -139,6 +214,22 @@
 	return base;
 }
 
+static inline void _load_LDT(mm_context_t *pc)
+{
+	int cpu = get_cpu();
+	const void *segments = pc->ldt;
+	int count = pc->size;
+
+	if (likely(!count)) {
+		segments = &default_ldt[0];
+		count = 5;
+	}
+		
+	__set_ldt_desc(cpu, segments, count);
+	load_LDT_desc();
+	put_cpu();
+}
+
 #endif /* !__ASSEMBLY__ */
 
 #endif
diff -Nur linux-2.6.13.1.org/include/asm-i386/dma.h grsecurity226/include/asm-i386/dma.h
--- linux-2.6.13.1.org/include/asm-i386/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/dma.h	2005-08-30 01:00:46.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm/dma.h: Defines for using and allocating dma channels.
  * Written by Hennus Bergman, 1992.
  * High DMA channel support & info by Hannu Savolainen
diff -Nur linux-2.6.13.1.org/include/asm-i386/elf.h grsecurity226/include/asm-i386/elf.h
--- linux-2.6.13.1.org/include/asm-i386/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/elf.h	2005-08-30 01:14:34.000000000 +0200
@@ -70,7 +70,22 @@
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define ELF_ET_DYN_BASE         ((current->mm->pax_flags & MF_PAX_SEGMEXEC) ? SEGMEXEC_TASK_SIZE/3*2 : TASK_SIZE/3*2)
+#else
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x10000000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk)->mm->pax_flags & MF_PAX_PAGEEXEC ? 15 : 15)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		15
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk)->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+#endif
 
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different) */
@@ -113,8 +128,11 @@
  * Architecture-neutral AT_ values in 0-17, leave some room
  * for more of them, start the x86-specific ones at 32.
  */
+
+#ifndef CONFIG_PAX_NOVSYSCALL
 #define AT_SYSINFO		32
 #define AT_SYSINFO_EHDR		33
+#endif
 
 #ifdef __KERNEL__
 #define SET_PERSONALITY(ex, ibcs2) do { } while (0)
@@ -135,7 +153,14 @@
 
 #define VSYSCALL_BASE	(__fix_to_virt(FIX_VSYSCALL))
 #define VSYSCALL_EHDR	((const struct elfhdr *) VSYSCALL_BASE)
+
+#ifndef CONFIG_PAX_NOVSYSCALL
+#ifdef CONFIG_PAX_SEGMEXEC
+#define VSYSCALL_ENTRY	((current->mm->pax_flags & MF_PAX_SEGMEXEC) ? (unsigned long) &__kernel_vsyscall - SEGMEXEC_TASK_SIZE : (unsigned long) &__kernel_vsyscall)
+#else
 #define VSYSCALL_ENTRY	((unsigned long) &__kernel_vsyscall)
+#endif
+
 extern void __kernel_vsyscall;
 
 #define ARCH_DLINFO						\
@@ -191,3 +216,5 @@
 #endif
 
 #endif
+
+#endif
diff -Nur linux-2.6.13.1.org/include/asm-i386/i387.h grsecurity226/include/asm-i386/i387.h
--- linux-2.6.13.1.org/include/asm-i386/i387.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/i387.h	2005-08-30 01:14:34.000000000 +0200
@@ -30,8 +30,8 @@
  */
 #define restore_fpu(tsk)			\
 	alternative_input(			\
-		"nop ; frstor %1",		\
-		"fxrstor %1",			\
+		"nop ; frstor %2",		\
+		"fxrstor %2",			\
 		X86_FEATURE_FXSR,		\
 		"m" ((tsk)->thread.i387.fxsave))
 
@@ -44,8 +44,8 @@
 static inline void __save_init_fpu( struct task_struct *tsk )
 {
 	alternative_input(
-		"fnsave %1 ; fwait ;" GENERIC_NOP2,
-		"fxsave %1 ; fnclex",
+		"fnsave %2 ; fwait ;" GENERIC_NOP2,
+		"fxsave %2 ; fnclex",
 		X86_FEATURE_FXSR,
 		"m" (tsk->thread.i387.fxsave)
 		:"memory");
diff -Nur linux-2.6.13.1.org/include/asm-i386/ioctl.h grsecurity226/include/asm-i386/ioctl.h
--- linux-2.6.13.1.org/include/asm-i386/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/ioctl.h	2005-08-30 01:00:46.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * linux/ioctl.h for Linux by H.H. Bergman.
  */
diff -Nur linux-2.6.13.1.org/include/asm-i386/mach-default/apm.h grsecurity226/include/asm-i386/mach-default/apm.h
--- linux-2.6.13.1.org/include/asm-i386/mach-default/apm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/mach-default/apm.h	2005-08-30 01:14:36.000000000 +0200
@@ -36,7 +36,7 @@
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		"pushl %%edi\n\t"
 		"pushl %%ebp\n\t"
-		"lcall *%%cs:apm_bios_entry\n\t"
+		"lcall *%%ss:apm_bios_entry\n\t"
 		"setc %%al\n\t"
 		"popl %%ebp\n\t"
 		"popl %%edi\n\t"
@@ -60,7 +60,7 @@
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		"pushl %%edi\n\t"
 		"pushl %%ebp\n\t"
-		"lcall *%%cs:apm_bios_entry\n\t"
+		"lcall *%%ss:apm_bios_entry\n\t"
 		"setc %%bl\n\t"
 		"popl %%ebp\n\t"
 		"popl %%edi\n\t"
diff -Nur linux-2.6.13.1.org/include/asm-i386/mman.h grsecurity226/include/asm-i386/mman.h
--- linux-2.6.13.1.org/include/asm-i386/mman.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/mman.h	2005-08-30 01:14:34.000000000 +0200
@@ -23,6 +23,10 @@
 #define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
 #define MAP_NONBLOCK	0x10000		/* do not block on IO */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define MAP_MIRROR	0x20000
+#endif
+
 #define MS_ASYNC	1		/* sync memory asynchronously */
 #define MS_INVALIDATE	2		/* invalidate the caches */
 #define MS_SYNC		4		/* synchronous memory sync */
diff -Nur linux-2.6.13.1.org/include/asm-i386/mmu.h grsecurity226/include/asm-i386/mmu.h
--- linux-2.6.13.1.org/include/asm-i386/mmu.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/mmu.h	2005-08-30 01:14:34.000000000 +0200
@@ -12,6 +12,17 @@
 	int size;
 	struct semaphore sem;
 	void *ldt;
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	unsigned long user_cs_base;
+	unsigned long user_cs_limit;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+	cpumask_t cpu_user_cs_mask;
+#endif
+
+#endif
+
 } mm_context_t;
 
 #endif
diff -Nur linux-2.6.13.1.org/include/asm-i386/mmu_context.h grsecurity226/include/asm-i386/mmu_context.h
--- linux-2.6.13.1.org/include/asm-i386/mmu_context.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/mmu_context.h	2005-08-30 01:14:34.000000000 +0200
@@ -46,6 +46,13 @@
 		 */
 		if (unlikely(prev->context.ldt != next->context.ldt))
 			load_LDT_nolock(&next->context, cpu);
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+		cpu_clear(cpu, prev->context.cpu_user_cs_mask);
+		cpu_set(cpu, next->context.cpu_user_cs_mask);
+#endif
+
+		set_user_cs(next, cpu);
 	}
 #ifdef CONFIG_SMP
 	else {
@@ -58,6 +65,12 @@
 			 */
 			load_cr3(next->pgd);
 			load_LDT_nolock(&next->context, cpu);
+
+#ifdef CONFIG_PAX_PAGEEXEC
+			cpu_set(cpu, next->context.cpu_user_cs_mask);
+#endif
+
+			set_user_cs(next, cpu);
 		}
 	}
 #endif
diff -Nur linux-2.6.13.1.org/include/asm-i386/module.h grsecurity226/include/asm-i386/module.h
--- linux-2.6.13.1.org/include/asm-i386/module.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/module.h	2005-08-30 01:14:34.000000000 +0200
@@ -70,6 +70,12 @@
 #define MODULE_STACKSIZE ""
 #endif
 
-#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_REGPARM MODULE_STACKSIZE
+#ifdef CONFIG_GRKERNSEC
+#define MODULE_GRSEC "GRSECURITY "
+#else
+#define MODULE_GRSEC ""
+#endif
+
+#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_REGPARM MODULE_STACKSIZE MODULE_GRSEC
 
 #endif /* _ASM_I386_MODULE_H */
diff -Nur linux-2.6.13.1.org/include/asm-i386/namei.h grsecurity226/include/asm-i386/namei.h
--- linux-2.6.13.1.org/include/asm-i386/namei.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/namei.h	2005-08-30 01:00:46.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm-i386/namei.h
  *
  * Included from linux/fs/namei.c
diff -Nur linux-2.6.13.1.org/include/asm-i386/page.h grsecurity226/include/asm-i386/page.h
--- linux-2.6.13.1.org/include/asm-i386/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/page.h	2005-08-30 01:14:34.000000000 +0200
@@ -9,11 +9,11 @@
 #define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
 #define LARGE_PAGE_SIZE (1UL << PMD_SHIFT)
 
+#include <linux/config.h>
+
 #ifdef __KERNEL__
 #ifndef __ASSEMBLY__
 
-#include <linux/config.h>
-
 #ifdef CONFIG_X86_USE_3DNOW
 
 #include <asm/mmx.h>
@@ -133,6 +133,23 @@
 #endif
 #define __KERNEL_START		(__PAGE_OFFSET + __PHYSICAL_START)
 
+#endif /* __KERNEL__ */
+
+#ifdef CONFIG_PAX_KERNEXEC
+#ifdef __ASSEMBLY__
+#define __KERNEL_TEXT_OFFSET	(0xC0400000)
+#else
+#define __KERNEL_TEXT_OFFSET	(0xC0400000UL)
+#endif
+#else
+#ifdef __ASSEMBLY__
+#define __KERNEL_TEXT_OFFSET	(0)
+#else
+#define __KERNEL_TEXT_OFFSET	(0x0UL)
+#endif
+#endif
+
+#ifdef __KERNEL__
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
@@ -154,6 +171,19 @@
 	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
 		 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & (MF_PAX_PAGEEXEC|MF_PAX_SEGMEXEC))?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & (MF_PAX_PAGEEXEC|MF_PAX_SEGMEXEC))?0:VM_EXEC))
+#endif
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define CONFIG_ARCH_TRACK_EXEC_LIMIT 1
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _I386_PAGE_H */
diff -Nur linux-2.6.13.1.org/include/asm-i386/pgalloc.h grsecurity226/include/asm-i386/pgalloc.h
--- linux-2.6.13.1.org/include/asm-i386/pgalloc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/pgalloc.h	2005-08-30 01:14:34.000000000 +0200
@@ -7,7 +7,7 @@
 #include <linux/mm.h>		/* for struct page */
 
 #define pmd_populate_kernel(mm, pmd, pte) \
-		set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
+		set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(pte)))
 
 #define pmd_populate(mm, pmd, pte) 				\
 	set_pmd(pmd, __pmd(_PAGE_TABLE +			\
diff -Nur linux-2.6.13.1.org/include/asm-i386/pgtable.h grsecurity226/include/asm-i386/pgtable.h
--- linux-2.6.13.1.org/include/asm-i386/pgtable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/pgtable.h	2005-08-30 01:14:34.000000000 +0200
@@ -31,7 +31,6 @@
  */
 #define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
 extern unsigned long empty_zero_page[1024];
-extern pgd_t swapper_pg_dir[1024];
 extern kmem_cache_t *pgd_cache;
 extern kmem_cache_t *pmd_cache;
 extern spinlock_t pgd_lock;
@@ -42,6 +41,7 @@
 void pgd_dtor(void *, kmem_cache_t *, unsigned long);
 void pgtable_cache_init(void);
 void paging_init(void);
+#endif /* !__ASSEMBLY__ */
 
 /*
  * The Linux x86 paging architecture is 'compile-time dual-mode', it
@@ -56,6 +56,23 @@
 # include <asm/pgtable-2level-defs.h>
 #endif
 
+#ifndef __ASSEMBLY__
+#ifdef CONFIG_X86_PAE
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+extern pmd_t swapper_pm_dir[PTRS_PER_PGD][PTRS_PER_PMD];
+
+#ifdef CONFIG_PAX_KERNEXEC
+extern pgd_t kernexec_pg_dir[PTRS_PER_PGD];
+extern pmd_t kernexec_pm_dir[PTRS_PER_PGD][PTRS_PER_PMD];
+#endif
+#else
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+
+#ifdef CONFIG_PAX_KERNEXEC
+extern pgd_t kernexec_pg_dir[PTRS_PER_PGD];
+#endif
+#endif
+
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
@@ -138,17 +155,26 @@
 
 #define PAGE_SHARED_EXEC \
 	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED)
-#define PAGE_COPY_NOEXEC \
-	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
 #define PAGE_COPY_EXEC \
 	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
-#define PAGE_COPY \
-	PAGE_COPY_NOEXEC
 #define PAGE_READONLY \
 	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
 #define PAGE_READONLY_EXEC \
 	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC \
+	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
+#define PAGE_COPY \
+	PAGE_COPY_NOEXEC
 #define _PAGE_KERNEL \
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_NX)
 #define _PAGE_KERNEL_EXEC \
@@ -173,18 +199,18 @@
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY
+#define __P001	PAGE_READONLY_NOEXEC
+#define __P010	PAGE_COPY_NOEXEC
+#define __P011	PAGE_COPY_NOEXEC
 #define __P100	PAGE_READONLY_EXEC
 #define __P101	PAGE_READONLY_EXEC
 #define __P110	PAGE_COPY_EXEC
 #define __P111	PAGE_COPY_EXEC
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED
+#define __S001	PAGE_READONLY_NOEXEC
+#define __S010	PAGE_SHARED_NOEXEC
+#define __S011	PAGE_SHARED_NOEXEC
 #define __S100	PAGE_READONLY_EXEC
 #define __S101	PAGE_READONLY_EXEC
 #define __S110	PAGE_SHARED_EXEC
@@ -398,6 +424,9 @@
 
 #endif /* !__ASSEMBLY__ */
 
+#define HAVE_ARCH_UNMAPPED_AREA
+#define HAVE_ARCH_UNMAPPED_AREA_TOPDOWN
+
 #ifdef CONFIG_FLATMEM
 #define kern_addr_valid(addr)	(1)
 #endif /* CONFIG_FLATMEM */
diff -Nur linux-2.6.13.1.org/include/asm-i386/processor.h grsecurity226/include/asm-i386/processor.h
--- linux-2.6.13.1.org/include/asm-i386/processor.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/processor.h	2005-09-05 18:42:08.000000000 +0200
@@ -19,7 +19,6 @@
 #include <linux/cache.h>
 #include <linux/config.h>
 #include <linux/threads.h>
-#include <asm/percpu.h>
 
 /* flag for disabling the tsc */
 extern int tsc_disable;
@@ -29,7 +28,7 @@
 };
 
 #define desc_empty(desc) \
-		(!((desc)->a | (desc)->b))
+		(!((desc)->a + (desc)->b))
 
 #define desc_equal(desc1, desc2) \
 		(((desc1)->a == (desc2)->a) && ((desc1)->b == (desc2)->b))
@@ -86,8 +85,6 @@
 
 extern struct cpuinfo_x86 boot_cpu_data;
 extern struct cpuinfo_x86 new_cpu_data;
-extern struct tss_struct doublefault_tss;
-DECLARE_PER_CPU(struct tss_struct, init_tss);
 
 #ifdef CONFIG_SMP
 extern struct cpuinfo_x86 cpu_data[];
@@ -313,10 +310,23 @@
  */
 #define TASK_SIZE	(PAGE_OFFSET)
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define SEGMEXEC_TASK_SIZE	((PAGE_OFFSET) / 2)
+#endif
+
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_PAX_SEGMEXEC)
+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN((current->mm->pax_flags & MF_PAX_PAGEEXEC)? 0x00110000UL : (current->mm->pax_flags & MF_PAX_SEGMEXEC) ? SEGMEXEC_TASK_SIZE/3 : TASK_SIZE/3))
+#elif defined(CONFIG_PAX_PAGEEXEC)
+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN((current->mm->pax_flags & MF_PAX_PAGEEXEC)? 0x00110000UL : TASK_SIZE/3))
+#elif defined(CONFIG_PAX_SEGMEXEC)
+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN((current->mm->pax_flags & MF_PAX_SEGMEXEC) ? SEGMEXEC_TASK_SIZE/3 : TASK_SIZE/3))
+#else
 #define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))
+#endif
 
 #define HAVE_ARCH_PICK_MMAP_LAYOUT
 
@@ -432,6 +442,9 @@
 
 #define ARCH_MIN_TASKALIGN	16
 
+extern struct tss_struct doublefault_tss;
+extern struct tss_struct init_tss[NR_CPUS];
+
 struct thread_struct {
 /* cached TLS descriptors. */
 	struct desc_struct tls_array[GDT_ENTRY_TLS_ENTRIES];
@@ -533,16 +546,12 @@
 unsigned long get_wchan(struct task_struct *p);
 
 #define THREAD_SIZE_LONGS      (THREAD_SIZE/sizeof(unsigned long))
-#define KSTK_TOP(info)                                                 \
-({                                                                     \
-       unsigned long *__ptr = (unsigned long *)(info);                 \
-       (unsigned long)(&__ptr[THREAD_SIZE_LONGS]);                     \
-})
+#define KSTK_TOP(info)         ((info)->task.thread.esp0)
 
 #define task_pt_regs(task)                                             \
 ({                                                                     \
        struct pt_regs *__regs__;                                       \
-       __regs__ = (struct pt_regs *)KSTK_TOP((task)->thread_info);     \
+       __regs__ = (struct pt_regs *)((task)->thread.esp0);             \
        __regs__ - 1;                                                   \
 })
 
@@ -666,7 +675,7 @@
 extern inline void prefetch(const void *x)
 {
 	alternative_input(ASM_NOP4,
-			  "prefetchnta (%1)",
+			  "prefetchnta (%2)",
 			  X86_FEATURE_XMM,
 			  "r" (x));
 }
@@ -680,7 +689,7 @@
 extern inline void prefetchw(const void *x)
 {
 	alternative_input(ASM_NOP4,
-			  "prefetchw (%1)",
+			  "prefetchw (%2)",
 			  X86_FEATURE_3DNOW,
 			  "r" (x));
 }
diff -Nur linux-2.6.13.1.org/include/asm-i386/system.h grsecurity226/include/asm-i386/system.h
--- linux-2.6.13.1.org/include/asm-i386/system.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-i386/system.h	2005-08-30 01:14:34.000000000 +0200
@@ -5,6 +5,7 @@
 #include <linux/kernel.h>
 #include <asm/segment.h>
 #include <asm/cpufeature.h>
+#include <asm/page.h>
 #include <linux/bitops.h> /* for LOCK_PREFIX */
 
 #ifdef __KERNEL__
@@ -301,15 +302,15 @@
 	asm volatile ("661:\n\t" oldinstr "\n662:\n" 		     \
 		      ".section .altinstructions,\"a\"\n"     	     \
 		      "  .align 4\n"				       \
-		      "  .long 661b\n"            /* label */          \
+		      "  .long 661b + %c1\n"       /* label */          \
 		      "  .long 663f\n"		  /* new instruction */ 	\
 		      "  .byte %c0\n"             /* feature bit */    \
 		      "  .byte 662b-661b\n"       /* sourcelen */      \
 		      "  .byte 664f-663f\n"       /* replacementlen */ \
 		      ".previous\n"						\
-		      ".section .altinstr_replacement,\"ax\"\n"			\
+		      ".section .altinstr_replacement,\"a\"\n"			\
 		      "663:\n\t" newinstr "\n664:\n"   /* replacement */    \
-		      ".previous" :: "i" (feature) : "memory")  
+		      ".previous" :: "i" (feature), "i" (__KERNEL_TEXT_OFFSET) : "memory")  
 
 /*
  * Alternative inline assembly with input.
@@ -325,15 +326,15 @@
 	asm volatile ("661:\n\t" oldinstr "\n662:\n"				\
 		      ".section .altinstructions,\"a\"\n"			\
 		      "  .align 4\n"						\
-		      "  .long 661b\n"            /* label */			\
+		      "  .long 661b + %c1\n"      /* label */			\
 		      "  .long 663f\n"		  /* new instruction */ 	\
 		      "  .byte %c0\n"             /* feature bit */		\
 		      "  .byte 662b-661b\n"       /* sourcelen */		\
 		      "  .byte 664f-663f\n"       /* replacementlen */ 		\
 		      ".previous\n"						\
-		      ".section .altinstr_replacement,\"ax\"\n"			\
+		      ".section .altinstr_replacement,\"a\"\n"			\
 		      "663:\n\t" newinstr "\n664:\n"   /* replacement */ 	\
-		      ".previous" :: "i" (feature), ##input)
+		      ".previous" :: "i" (feature), "i" (__KERNEL_TEXT_OFFSET), ##input)
 
 /*
  * Force strict CPU ordering.
diff -Nur linux-2.6.13.1.org/include/asm-ia64/elf.h grsecurity226/include/asm-ia64/elf.h
--- linux-2.6.13.1.org/include/asm-ia64/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ia64/elf.h	2005-08-30 01:14:37.000000000 +0200
@@ -162,6 +162,16 @@
 typedef struct ia64_fpreg elf_fpreg_t;
 typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	((tsk)->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((tsk)->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#endif
 
 
 struct pt_regs;	/* forward declaration... */
diff -Nur linux-2.6.13.1.org/include/asm-ia64/page.h grsecurity226/include/asm-ia64/page.h
--- linux-2.6.13.1.org/include/asm-ia64/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ia64/page.h	2005-08-30 01:14:37.000000000 +0200
@@ -204,4 +204,13 @@
 					 (((current->personality & READ_IMPLIES_EXEC) != 0)	\
 					  ? VM_EXEC : 0))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* _ASM_IA64_PAGE_H */
diff -Nur linux-2.6.13.1.org/include/asm-ia64/pgtable.h grsecurity226/include/asm-ia64/pgtable.h
--- linux-2.6.13.1.org/include/asm-ia64/pgtable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ia64/pgtable.h	2005-08-30 01:14:37.000000000 +0200
@@ -121,6 +121,17 @@
 #define PAGE_READONLY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
 #define PAGE_COPY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
 #define PAGE_COPY_EXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RX)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RW)
+# define PAGE_READONLY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+# define PAGE_COPY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+#endif
+
 #define PAGE_GATE	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_X_RX)
 #define PAGE_KERNEL	__pgprot(__DIRTY_BITS  | _PAGE_PL_0 | _PAGE_AR_RWX)
 #define PAGE_KERNELRX	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_RX)
diff -Nur linux-2.6.13.1.org/include/asm-ia64/processor.h grsecurity226/include/asm-ia64/processor.h
--- linux-2.6.13.1.org/include/asm-ia64/processor.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ia64/processor.h	2005-08-30 01:14:37.000000000 +0200
@@ -287,7 +287,7 @@
 	.on_ustack =	0,					\
 	.ksp =		0,					\
 	.map_base =	DEFAULT_MAP_BASE,			\
-	.rbs_bot =	STACK_TOP - DEFAULT_USER_STACK_SIZE,	\
+	.rbs_bot =	__STACK_TOP - DEFAULT_USER_STACK_SIZE,	\
 	.task_size =	DEFAULT_TASK_SIZE,			\
 	.last_fph_cpu =  -1,					\
 	INIT_THREAD_IA32					\
diff -Nur linux-2.6.13.1.org/include/asm-ia64/ustack.h grsecurity226/include/asm-ia64/ustack.h
--- linux-2.6.13.1.org/include/asm-ia64/ustack.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ia64/ustack.h	2005-08-30 01:14:37.000000000 +0200
@@ -11,6 +11,6 @@
 #define MAX_USER_STACK_SIZE	(RGN_MAP_LIMIT/2)
 /* Make a default stack size of 2GB */
 #define DEFAULT_USER_STACK_SIZE	(1UL << 31)
-#define STACK_TOP		(0x6000000000000000UL + RGN_MAP_LIMIT)
+#define __STACK_TOP		(0x6000000000000000UL + RGN_MAP_LIMIT)
 
 #endif /* _ASM_IA64_USTACK_H */
diff -Nur linux-2.6.13.1.org/include/asm-m32r/addrspace.h grsecurity226/include/asm-m32r/addrspace.h
--- linux-2.6.13.1.org/include/asm-m32r/addrspace.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/addrspace.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
diff -Nur linux-2.6.13.1.org/include/asm-m32r/bugs.h grsecurity226/include/asm-m32r/bugs.h
--- linux-2.6.13.1.org/include/asm-m32r/bugs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/bugs.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_BUGS_H
 #define _ASM_M32R_BUGS_H
 
-/* $Id$ */
+/* $Id$ */
 
 /*
  * This is included by init/main.c to check for architecture-dependent bugs.
diff -Nur linux-2.6.13.1.org/include/asm-m32r/byteorder.h grsecurity226/include/asm-m32r/byteorder.h
--- linux-2.6.13.1.org/include/asm-m32r/byteorder.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/byteorder.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_BYTEORDER_H
 #define _ASM_M32R_BYTEORDER_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <asm/types.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/cache.h grsecurity226/include/asm-m32r/cache.h
--- linux-2.6.13.1.org/include/asm-m32r/cache.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/cache.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_CACHE_H
 #define _ASM_M32R_CACHE_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* L1 cache line size */
 #define L1_CACHE_SHIFT		4
diff -Nur linux-2.6.13.1.org/include/asm-m32r/current.h grsecurity226/include/asm-m32r/current.h
--- linux-2.6.13.1.org/include/asm-m32r/current.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/current.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_CURRENT_H
 #define _ASM_M32R_CURRENT_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/thread_info.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/delay.h grsecurity226/include/asm-m32r/delay.h
--- linux-2.6.13.1.org/include/asm-m32r/delay.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/delay.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_DELAY_H
 #define _ASM_M32R_DELAY_H
 
-/* $Id$ */
+/* $Id$ */
 
 /*
  * Copyright (C) 1993 Linus Torvalds
diff -Nur linux-2.6.13.1.org/include/asm-m32r/dma.h grsecurity226/include/asm-m32r/dma.h
--- linux-2.6.13.1.org/include/asm-m32r/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/dma.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_DMA_H
 #define _ASM_M32R_DMA_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <asm/io.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/errno.h grsecurity226/include/asm-m32r/errno.h
--- linux-2.6.13.1.org/include/asm-m32r/errno.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/errno.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_ERRNO_H
 #define _ASM_M32R_ERRNO_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <asm-generic/errno.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/fcntl.h grsecurity226/include/asm-m32r/fcntl.h
--- linux-2.6.13.1.org/include/asm-m32r/fcntl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/fcntl.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_FCNTL_H
 #define _ASM_M32R_FCNTL_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/ide.h grsecurity226/include/asm-m32r/ide.h
--- linux-2.6.13.1.org/include/asm-m32r/ide.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/ide.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_IDE_H
 #define _ASM_M32R_IDE_H
 
-/* $Id$ */
+/* $Id$ */
 
 /*
  *  linux/include/asm-m32r/ide.h
diff -Nur linux-2.6.13.1.org/include/asm-m32r/ioctl.h grsecurity226/include/asm-m32r/ioctl.h
--- linux-2.6.13.1.org/include/asm-m32r/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/ioctl.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_IOCTL_H
 #define _ASM_M32R_IOCTL_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/ioctls.h grsecurity226/include/asm-m32r/ioctls.h
--- linux-2.6.13.1.org/include/asm-m32r/ioctls.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/ioctls.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef __ARCH_M32R_IOCTLS_H__
 #define __ARCH_M32R_IOCTLS_H__
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.5.67 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/ipcbuf.h grsecurity226/include/asm-m32r/ipcbuf.h
--- linux-2.6.13.1.org/include/asm-m32r/ipcbuf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/ipcbuf.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_IPCBUF_H
 #define _ASM_M32R_IPCBUF_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/m32700ut/m32700ut_lan.h grsecurity226/include/asm-m32r/m32700ut/m32700ut_lan.h
--- linux-2.6.13.1.org/include/asm-m32r/m32700ut/m32700ut_lan.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/m32700ut/m32700ut_lan.h	2005-08-30 01:00:49.000000000 +0200
@@ -9,7 +9,7 @@
  * Public License.  See the file "COPYING" in the main directory of
  * this archive for more details.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _M32700UT_M32700UT_LAN_H
diff -Nur linux-2.6.13.1.org/include/asm-m32r/m32700ut/m32700ut_lcd.h grsecurity226/include/asm-m32r/m32700ut/m32700ut_lcd.h
--- linux-2.6.13.1.org/include/asm-m32r/m32700ut/m32700ut_lcd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/m32700ut/m32700ut_lcd.h	2005-08-30 01:00:49.000000000 +0200
@@ -9,7 +9,7 @@
  * Public License.  See the file "COPYING" in the main directory of
  * this archive for more details.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _M32700UT_M32700UT_LCD_H
diff -Nur linux-2.6.13.1.org/include/asm-m32r/m32700ut/m32700ut_pld.h grsecurity226/include/asm-m32r/m32700ut/m32700ut_pld.h
--- linux-2.6.13.1.org/include/asm-m32r/m32700ut/m32700ut_pld.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/m32700ut/m32700ut_pld.h	2005-08-30 01:00:49.000000000 +0200
@@ -9,7 +9,7 @@
  * Public License.  See the file "COPYING" in the main directory of
  * this archive for more details.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _M32700UT_M32700UT_PLD_H
diff -Nur linux-2.6.13.1.org/include/asm-m32r/module.h grsecurity226/include/asm-m32r/module.h
--- linux-2.6.13.1.org/include/asm-m32r/module.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/module.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_MODULE_H
 #define _ASM_M32R_MODULE_H
 
-/* $Id$ */
+/* $Id$ */
 
 struct mod_arch_specific { };
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/msgbuf.h grsecurity226/include/asm-m32r/msgbuf.h
--- linux-2.6.13.1.org/include/asm-m32r/msgbuf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/msgbuf.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_MSGBUF_H
 #define _ASM_M32R_MSGBUF_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/namei.h grsecurity226/include/asm-m32r/namei.h
--- linux-2.6.13.1.org/include/asm-m32r/namei.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/namei.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_NAMEI_H
 #define _ASM_M32R_NAMEI_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/opsput/opsput_lan.h grsecurity226/include/asm-m32r/opsput/opsput_lan.h
--- linux-2.6.13.1.org/include/asm-m32r/opsput/opsput_lan.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/opsput/opsput_lan.h	2005-08-30 01:00:49.000000000 +0200
@@ -9,7 +9,7 @@
  * Public License.  See the file "COPYING" in the main directory of
  * this archive for more details.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _OPSPUT_OPSPUT_LAN_H
diff -Nur linux-2.6.13.1.org/include/asm-m32r/opsput/opsput_lcd.h grsecurity226/include/asm-m32r/opsput/opsput_lcd.h
--- linux-2.6.13.1.org/include/asm-m32r/opsput/opsput_lcd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/opsput/opsput_lcd.h	2005-08-30 01:00:49.000000000 +0200
@@ -9,7 +9,7 @@
  * Public License.  See the file "COPYING" in the main directory of
  * this archive for more details.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _OPSPUT_OPSPUT_LCD_H
diff -Nur linux-2.6.13.1.org/include/asm-m32r/opsput/opsput_pld.h grsecurity226/include/asm-m32r/opsput/opsput_pld.h
--- linux-2.6.13.1.org/include/asm-m32r/opsput/opsput_pld.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/opsput/opsput_pld.h	2005-08-30 01:00:49.000000000 +0200
@@ -9,7 +9,7 @@
  * Public License.  See the file "COPYING" in the main directory of
  * this archive for more details.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _OPSPUT_OPSPUT_PLD_H
diff -Nur linux-2.6.13.1.org/include/asm-m32r/param.h grsecurity226/include/asm-m32r/param.h
--- linux-2.6.13.1.org/include/asm-m32r/param.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/param.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_PARAM_H
 #define _ASM_M32R_PARAM_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.5.67 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/pci.h grsecurity226/include/asm-m32r/pci.h
--- linux-2.6.13.1.org/include/asm-m32r/pci.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/pci.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_PCI_H
 #define _ASM_M32R_PCI_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <asm-generic/pci.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/pgalloc.h grsecurity226/include/asm-m32r/pgalloc.h
--- linux-2.6.13.1.org/include/asm-m32r/pgalloc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/pgalloc.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_PGALLOC_H
 #define _ASM_M32R_PGALLOC_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/config.h>
 #include <linux/mm.h>
diff -Nur linux-2.6.13.1.org/include/asm-m32r/posix_types.h grsecurity226/include/asm-m32r/posix_types.h
--- linux-2.6.13.1.org/include/asm-m32r/posix_types.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/posix_types.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_POSIX_TYPES_H
 #define _ASM_M32R_POSIX_TYPES_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386, sh 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/rtc.h grsecurity226/include/asm-m32r/rtc.h
--- linux-2.6.13.1.org/include/asm-m32r/rtc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/rtc.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef __RTC_H__
 #define __RTC_H__
diff -Nur linux-2.6.13.1.org/include/asm-m32r/scatterlist.h grsecurity226/include/asm-m32r/scatterlist.h
--- linux-2.6.13.1.org/include/asm-m32r/scatterlist.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/scatterlist.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SCATTERLIST_H
 #define _ASM_M32R_SCATTERLIST_H
 
-/* $Id$ */
+/* $Id$ */
 
 struct scatterlist {
     char *  address;    /* Location data is to be transferred to, NULL for
diff -Nur linux-2.6.13.1.org/include/asm-m32r/segment.h grsecurity226/include/asm-m32r/segment.h
--- linux-2.6.13.1.org/include/asm-m32r/segment.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/segment.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SEGMENT_H
 #define _ASM_M32R_SEGMENT_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 (2.4.18) */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/sembuf.h grsecurity226/include/asm-m32r/sembuf.h
--- linux-2.6.13.1.org/include/asm-m32r/sembuf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/sembuf.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SEMBUF_H
 #define _ASM_M32R_SEMBUF_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/shmbuf.h grsecurity226/include/asm-m32r/shmbuf.h
--- linux-2.6.13.1.org/include/asm-m32r/shmbuf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/shmbuf.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SHMBUF_H
 #define _ASM_M32R_SHMBUF_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/shmparam.h grsecurity226/include/asm-m32r/shmparam.h
--- linux-2.6.13.1.org/include/asm-m32r/shmparam.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/shmparam.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SHMPARAM_H
 #define _ASM_M32R_SHMPARAM_H
 
-/* $Id$ */
+/* $Id$ */
 
 #define	SHMLBA PAGE_SIZE		 /* attach addr a multiple of this */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/sigcontext.h grsecurity226/include/asm-m32r/sigcontext.h
--- linux-2.6.13.1.org/include/asm-m32r/sigcontext.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/sigcontext.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SIGCONTEXT_H
 #define _ASM_M32R_SIGCONTEXT_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/config.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/siginfo.h grsecurity226/include/asm-m32r/siginfo.h
--- linux-2.6.13.1.org/include/asm-m32r/siginfo.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/siginfo.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _M32R_SIGINFO_H
 #define _M32R_SIGINFO_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <asm-generic/siginfo.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/signal.h grsecurity226/include/asm-m32r/signal.h
--- linux-2.6.13.1.org/include/asm-m32r/signal.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/signal.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SIGNAL_H
 #define _ASM_M32R_SIGNAL_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/smp.h grsecurity226/include/asm-m32r/smp.h
--- linux-2.6.13.1.org/include/asm-m32r/smp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/smp.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SMP_H
 #define _ASM_M32R_SMP_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/config.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/sockios.h grsecurity226/include/asm-m32r/sockios.h
--- linux-2.6.13.1.org/include/asm-m32r/sockios.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/sockios.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SOCKIOS_H
 #define _ASM_M32R_SOCKIOS_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* Socket-level I/O control calls. */
 #define FIOSETOWN 	0x8901
diff -Nur linux-2.6.13.1.org/include/asm-m32r/stat.h grsecurity226/include/asm-m32r/stat.h
--- linux-2.6.13.1.org/include/asm-m32r/stat.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/stat.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_STAT_H
 #define _ASM_M32R_STAT_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/string.h grsecurity226/include/asm-m32r/string.h
--- linux-2.6.13.1.org/include/asm-m32r/string.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/string.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_STRING_H
 #define _ASM_M32R_STRING_H
 
-/* $Id$ */
+/* $Id$ */
 
 #define  __HAVE_ARCH_STRLEN
 extern size_t strlen(const char * s);
diff -Nur linux-2.6.13.1.org/include/asm-m32r/syscall.h grsecurity226/include/asm-m32r/syscall.h
--- linux-2.6.13.1.org/include/asm-m32r/syscall.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/syscall.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_SYSCALL_H
 #define _ASM_M32R_SYSCALL_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* Definitions for the system call vector.  */
 #define SYSCALL_VECTOR          "2"
diff -Nur linux-2.6.13.1.org/include/asm-m32r/termbits.h grsecurity226/include/asm-m32r/termbits.h
--- linux-2.6.13.1.org/include/asm-m32r/termbits.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/termbits.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_TERMBITS_H
 #define _ASM_M32R_TERMBITS_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/posix_types.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/timex.h grsecurity226/include/asm-m32r/timex.h
--- linux-2.6.13.1.org/include/asm-m32r/timex.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/timex.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_TIMEX_H
 #define _ASM_M32R_TIMEX_H
 
-/* $Id$ */
+/* $Id$ */
 
 /*
  * linux/include/asm-m32r/timex.h
diff -Nur linux-2.6.13.1.org/include/asm-m32r/types.h grsecurity226/include/asm-m32r/types.h
--- linux-2.6.13.1.org/include/asm-m32r/types.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/types.h	2005-08-30 01:00:49.000000000 +0200
@@ -3,7 +3,7 @@
 
 #ifndef __ASSEMBLY__
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : i386 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/unaligned.h grsecurity226/include/asm-m32r/unaligned.h
--- linux-2.6.13.1.org/include/asm-m32r/unaligned.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/unaligned.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_UNALIGNED_H
 #define _ASM_M32R_UNALIGNED_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : generic 2.4.18 */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/unistd.h grsecurity226/include/asm-m32r/unistd.h
--- linux-2.6.13.1.org/include/asm-m32r/unistd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/unistd.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_UNISTD_H
 #define _ASM_M32R_UNISTD_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <asm/syscall.h>	/* SYSCALL_* */
 
diff -Nur linux-2.6.13.1.org/include/asm-m32r/user.h grsecurity226/include/asm-m32r/user.h
--- linux-2.6.13.1.org/include/asm-m32r/user.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/user.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_USER_H
 #define _ASM_M32R_USER_H
 
-/* $Id$ */
+/* $Id$ */
 
 /* orig : sh 2.4.18
  * mod  : remove fpu registers
diff -Nur linux-2.6.13.1.org/include/asm-m32r/vga.h grsecurity226/include/asm-m32r/vga.h
--- linux-2.6.13.1.org/include/asm-m32r/vga.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/vga.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_VGA_H
 #define _ASM_M32R_VGA_H
 
-/* $Id$ */
+/* $Id$ */
 
 /*
  *	Access to VGA videoram
diff -Nur linux-2.6.13.1.org/include/asm-m32r/xor.h grsecurity226/include/asm-m32r/xor.h
--- linux-2.6.13.1.org/include/asm-m32r/xor.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m32r/xor.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_M32R_XOR_H
 #define _ASM_M32R_XOR_H
 
-/* $Id$ */
+/* $Id$ */
 
 #include <asm-generic/xor.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-m68k/apollodma.h grsecurity226/include/asm-m68k/apollodma.h
--- linux-2.6.13.1.org/include/asm-m68k/apollodma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68k/apollodma.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm/dma.h: Defines for using and allocating dma channels.
  * Written by Hennus Bergman, 1992.
  * High DMA channel support & info by Hannu Savolainen
diff -Nur linux-2.6.13.1.org/include/asm-m68k/dvma.h grsecurity226/include/asm-m68k/dvma.h
--- linux-2.6.13.1.org/include/asm-m68k/dvma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68k/dvma.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * include/asm-m68k/dma.h
  *
  * Copyright 1995 (C) David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-m68k/ioctl.h grsecurity226/include/asm-m68k/ioctl.h
--- linux-2.6.13.1.org/include/asm-m68k/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68k/ioctl.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * linux/ioctl.h for Linux by H.H. Bergman.
  */
diff -Nur linux-2.6.13.1.org/include/asm-m68k/machines.h grsecurity226/include/asm-m68k/machines.h
--- linux-2.6.13.1.org/include/asm-m68k/machines.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68k/machines.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * machines.h:  Defines for taking apart the machine type value in the
  *              idprom and determining the kind of machine we are on.
  *
diff -Nur linux-2.6.13.1.org/include/asm-m68k/md.h grsecurity226/include/asm-m68k/md.h
--- linux-2.6.13.1.org/include/asm-m68k/md.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68k/md.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * md.h: High speed xor_block operation for RAID4/5
  *
  */
diff -Nur linux-2.6.13.1.org/include/asm-m68k/openprom.h grsecurity226/include/asm-m68k/openprom.h
--- linux-2.6.13.1.org/include/asm-m68k/openprom.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68k/openprom.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC_OPENPROM_H
 #define __SPARC_OPENPROM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-m68k/oplib.h grsecurity226/include/asm-m68k/oplib.h
--- linux-2.6.13.1.org/include/asm-m68k/oplib.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68k/oplib.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * oplib.h:  Describes the interface and available routines in the
  *           Linux Prom library.
  *
diff -Nur linux-2.6.13.1.org/include/asm-m68k/sun3-head.h grsecurity226/include/asm-m68k/sun3-head.h
--- linux-2.6.13.1.org/include/asm-m68k/sun3-head.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68k/sun3-head.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SUN3_HEAD_H
 #define __SUN3_HEAD_H
 
diff -Nur linux-2.6.13.1.org/include/asm-m68knommu/m68360_enet.h grsecurity226/include/asm-m68knommu/m68360_enet.h
--- linux-2.6.13.1.org/include/asm-m68knommu/m68360_enet.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68knommu/m68360_enet.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,5 +1,5 @@
 /***********************************
- * $Id$
+ * $Id$
  ***********************************
  *
  ***************************************
diff -Nur linux-2.6.13.1.org/include/asm-m68knommu/m68360_pram.h grsecurity226/include/asm-m68knommu/m68360_pram.h
--- linux-2.6.13.1.org/include/asm-m68knommu/m68360_pram.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68knommu/m68360_pram.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,5 +1,5 @@
 /***********************************
- * $Id$
+ * $Id$
  ***********************************
  *
  ***************************************
diff -Nur linux-2.6.13.1.org/include/asm-m68knommu/m68360_quicc.h grsecurity226/include/asm-m68knommu/m68360_quicc.h
--- linux-2.6.13.1.org/include/asm-m68knommu/m68360_quicc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68knommu/m68360_quicc.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,5 +1,5 @@
 /***********************************
- * $Id$
+ * $Id$
  ***********************************
  *
  ***************************************
diff -Nur linux-2.6.13.1.org/include/asm-m68knommu/m68360_regs.h grsecurity226/include/asm-m68knommu/m68360_regs.h
--- linux-2.6.13.1.org/include/asm-m68knommu/m68360_regs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68knommu/m68360_regs.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,5 +1,5 @@
 /***********************************
- * $Id$
+ * $Id$
  ***********************************
  *
  ***************************************
diff -Nur linux-2.6.13.1.org/include/asm-m68knommu/quicc_simple.h grsecurity226/include/asm-m68knommu/quicc_simple.h
--- linux-2.6.13.1.org/include/asm-m68knommu/quicc_simple.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-m68knommu/quicc_simple.h	2005-08-30 01:00:49.000000000 +0200
@@ -1,5 +1,5 @@
 /***********************************
- * $Id$
+ * $Id$
  ***********************************
  *
  ***************************************
diff -Nur linux-2.6.13.1.org/include/asm-mips/a.out.h grsecurity226/include/asm-mips/a.out.h
--- linux-2.6.13.1.org/include/asm-mips/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-mips/a.out.h	2005-08-30 01:14:39.000000000 +0200
@@ -36,10 +36,10 @@
 #ifdef __KERNEL__
 
 #ifdef CONFIG_MIPS32
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 #endif
 #ifdef CONFIG_MIPS64
-#define STACK_TOP	(current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
+#define __STACK_TOP	(current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
 #endif
 
 #endif
diff -Nur linux-2.6.13.1.org/include/asm-mips/elf.h grsecurity226/include/asm-mips/elf.h
--- linux-2.6.13.1.org/include/asm-mips/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-mips/elf.h	2005-08-30 01:14:40.000000000 +0200
@@ -279,4 +279,15 @@
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(((tsk)->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #endif /* _ASM_ELF_H */
diff -Nur linux-2.6.13.1.org/include/asm-mips/page.h grsecurity226/include/asm-mips/page.h
--- linux-2.6.13.1.org/include/asm-mips/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-mips/page.h	2005-08-30 01:14:40.000000000 +0200
@@ -139,6 +139,15 @@
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
 #define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
 
diff -Nur linux-2.6.13.1.org/include/asm-mips/sn/nmi.h grsecurity226/include/asm-mips/sn/nmi.h
--- linux-2.6.13.1.org/include/asm-mips/sn/nmi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-mips/sn/nmi.h	2005-08-30 01:00:50.000000000 +0200
@@ -8,7 +8,7 @@
 #ifndef __ASM_SN_NMI_H
 #define __ASM_SN_NMI_H
 
-#ident "$Revision$"
+#ident "$Revision$"
 
 #include <asm/sn/addrs.h>
 
diff -Nur linux-2.6.13.1.org/include/asm-parisc/a.out.h grsecurity226/include/asm-parisc/a.out.h
--- linux-2.6.13.1.org/include/asm-parisc/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-parisc/a.out.h	2005-08-30 01:14:43.000000000 +0200
@@ -22,7 +22,7 @@
 /* XXX: STACK_TOP actually should be STACK_BOTTOM for parisc.
  * prumpf */
 
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 
 #endif
 
diff -Nur linux-2.6.13.1.org/include/asm-parisc/dma.h grsecurity226/include/asm-parisc/dma.h
--- linux-2.6.13.1.org/include/asm-parisc/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-parisc/dma.h	2005-08-30 01:00:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm/dma.h: Defines for using and allocating dma channels.
  * Written by Hennus Bergman, 1992.
  * High DMA channel support & info by Hannu Savolainen
diff -Nur linux-2.6.13.1.org/include/asm-parisc/elf.h grsecurity226/include/asm-parisc/elf.h
--- linux-2.6.13.1.org/include/asm-parisc/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-parisc/elf.h	2005-08-30 01:14:43.000000000 +0200
@@ -337,6 +337,17 @@
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE + 0x01000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x10000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		16
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		16
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
    but it's not easy, and we've already done it here.  */
diff -Nur linux-2.6.13.1.org/include/asm-parisc/namei.h grsecurity226/include/asm-parisc/namei.h
--- linux-2.6.13.1.org/include/asm-parisc/namei.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-parisc/namei.h	2005-08-30 01:00:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm-parisc/namei.h
  *
  * Included from linux/fs/namei.c
diff -Nur linux-2.6.13.1.org/include/asm-parisc/page.h grsecurity226/include/asm-parisc/page.h
--- linux-2.6.13.1.org/include/asm-parisc/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-parisc/page.h	2005-08-30 01:14:43.000000000 +0200
@@ -157,6 +157,15 @@
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _PARISC_PAGE_H */
diff -Nur linux-2.6.13.1.org/include/asm-parisc/pgtable.h grsecurity226/include/asm-parisc/pgtable.h
--- linux-2.6.13.1.org/include/asm-parisc/pgtable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-parisc/pgtable.h	2005-08-30 01:14:43.000000000 +0200
@@ -211,6 +211,17 @@
 #define PAGE_EXECREAD   __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_EXEC |_PAGE_ACCESSED)
 #define PAGE_COPY       PAGE_EXECREAD
 #define PAGE_RWX        __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_EXEC |_PAGE_ACCESSED)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_RO	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_DIRTY | _PAGE_ACCESSED)
 #define PAGE_KERNEL_UNC	__pgprot(_PAGE_KERNEL | _PAGE_NO_CACHE)
diff -Nur linux-2.6.13.1.org/include/asm-ppc/a.out.h grsecurity226/include/asm-ppc/a.out.h
--- linux-2.6.13.1.org/include/asm-ppc/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ppc/a.out.h	2005-08-30 01:14:45.000000000 +0200
@@ -2,7 +2,7 @@
 #define __PPC_A_OUT_H__
 
 /* grabbed from the intel stuff  */
-#define STACK_TOP TASK_SIZE
+#define __STACK_TOP TASK_SIZE
 
 
 struct exec
diff -Nur linux-2.6.13.1.org/include/asm-ppc/elf.h grsecurity226/include/asm-ppc/elf.h
--- linux-2.6.13.1.org/include/asm-ppc/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ppc/elf.h	2005-08-30 01:14:46.000000000 +0200
@@ -90,6 +90,17 @@
 
 #define ELF_ET_DYN_BASE         (0x08000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x10000000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		15
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		15
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	15
+#endif
+
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	4096
 
diff -Nur linux-2.6.13.1.org/include/asm-ppc/page.h grsecurity226/include/asm-ppc/page.h
--- linux-2.6.13.1.org/include/asm-ppc/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ppc/page.h	2005-08-30 01:14:46.000000000 +0200
@@ -165,5 +165,14 @@
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _PPC_PAGE_H */
diff -Nur linux-2.6.13.1.org/include/asm-ppc/pgtable.h grsecurity226/include/asm-ppc/pgtable.h
--- linux-2.6.13.1.org/include/asm-ppc/pgtable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ppc/pgtable.h	2005-08-30 01:14:46.000000000 +0200
@@ -440,11 +440,21 @@
 
 #define PAGE_NONE	__pgprot(_PAGE_BASE)
 #define PAGE_READONLY	__pgprot(_PAGE_BASE | _PAGE_USER)
-#define PAGE_READONLY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC)
+#define PAGE_READONLY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC | _PAGE_HWEXEC)
 #define PAGE_SHARED	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW)
-#define PAGE_SHARED_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_EXEC)
+#define PAGE_SHARED_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_EXEC | _PAGE_HWEXEC)
 #define PAGE_COPY	__pgprot(_PAGE_BASE | _PAGE_USER)
-#define PAGE_COPY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC)
+#define PAGE_COPY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC | _PAGE_HWEXEC)
+
+#if defined(CONFIG_PAX_PAGEEXEC) && !defined(CONFIG_40x) && !defined(CONFIG_44x)
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_GUARDED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_GUARDED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_GUARDED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
 
 #define PAGE_KERNEL		__pgprot(_PAGE_RAM)
 #define PAGE_KERNEL_NOCACHE	__pgprot(_PAGE_IO)
@@ -456,21 +466,21 @@
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY_X
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY_X
-#define __P100	PAGE_READONLY
+#define __P001	PAGE_READONLY_NOEXEC
+#define __P010	PAGE_COPY_NOEXEC
+#define __P011	PAGE_COPY_NOEXEC
+#define __P100	PAGE_READONLY_X
 #define __P101	PAGE_READONLY_X
-#define __P110	PAGE_COPY
+#define __P110	PAGE_COPY_X
 #define __P111	PAGE_COPY_X
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY_X
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED_X
-#define __S100	PAGE_READONLY
+#define __S001	PAGE_READONLY_NOEXEC
+#define __S010	PAGE_SHARED_NOEXEC
+#define __S011	PAGE_SHARED_NOEXEC
+#define __S100	PAGE_READONLY_X
 #define __S101	PAGE_READONLY_X
-#define __S110	PAGE_SHARED
+#define __S110	PAGE_SHARED_X
 #define __S111	PAGE_SHARED_X
 
 #ifndef __ASSEMBLY__
diff -Nur linux-2.6.13.1.org/include/asm-ppc64/a.out.h grsecurity226/include/asm-ppc64/a.out.h
--- linux-2.6.13.1.org/include/asm-ppc64/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ppc64/a.out.h	2005-08-30 01:14:48.000000000 +0200
@@ -31,7 +31,7 @@
 #define STACK_TOP_USER64 TASK_SIZE_USER64
 #define STACK_TOP_USER32 TASK_SIZE_USER32
 
-#define STACK_TOP (test_thread_flag(TIF_32BIT) ? \
+#define __STACK_TOP (test_thread_flag(TIF_32BIT) ? \
 		   STACK_TOP_USER32 : STACK_TOP_USER64)
 
 #endif /* __KERNEL__ */
diff -Nur linux-2.6.13.1.org/include/asm-ppc64/elf.h grsecurity226/include/asm-ppc64/elf.h
--- linux-2.6.13.1.org/include/asm-ppc64/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ppc64/elf.h	2005-08-30 01:14:48.000000000 +0200
@@ -154,6 +154,17 @@
 
 #define ELF_ET_DYN_BASE         (0x08000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(0x10000000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		((test_thread_flag(TIF_32BIT) || (ppcdebugset(PPCDBG_BINFMT_32ADDR))) ? 16 : 24)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		((test_thread_flag(TIF_32BIT) || (ppcdebugset(PPCDBG_BINFMT_32ADDR))) ? 16 : 24)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	((test_thread_flag(TIF_32BIT) || (ppcdebugset(PPCDBG_BINFMT_32ADDR))) ? 16 : 24)
+#endif
+
 #ifdef __KERNEL__
 
 /* Common routine for both 32-bit and 64-bit processes */
diff -Nur linux-2.6.13.1.org/include/asm-ppc64/page.h grsecurity226/include/asm-ppc64/page.h
--- linux-2.6.13.1.org/include/asm-ppc64/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-ppc64/page.h	2005-08-30 01:14:48.000000000 +0200
@@ -260,5 +260,14 @@
 	(test_thread_flag(TIF_32BIT) ? \
 	 VM_STACK_DEFAULT_FLAGS32 : VM_STACK_DEFAULT_FLAGS64)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			 ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _PPC64_PAGE_H */
diff -Nur linux-2.6.13.1.org/include/asm-s390/dasd.h grsecurity226/include/asm-s390/dasd.h
--- linux-2.6.13.1.org/include/asm-s390/dasd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-s390/dasd.h	2005-08-30 01:00:54.000000000 +0200
@@ -8,7 +8,7 @@
  * any future changes wrt the API will result in a change of the APIVERSION reported
  * to userspace by the DASDAPIVER-ioctl
  *
- * $Revision$
+ * $Revision$
  *
  */
 
diff -Nur linux-2.6.13.1.org/include/asm-s390/qdio.h grsecurity226/include/asm-s390/qdio.h
--- linux-2.6.13.1.org/include/asm-s390/qdio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-s390/qdio.h	2005-08-30 01:00:54.000000000 +0200
@@ -11,7 +11,7 @@
 #ifndef __QDIO_H__
 #define __QDIO_H__
 
-#define VERSION_QDIO_H "$Revision$"
+#define VERSION_QDIO_H "$Revision$"
 
 /* note, that most of the typedef's are from ingo. */
 
diff -Nur linux-2.6.13.1.org/include/asm-sh/cache.h grsecurity226/include/asm-sh/cache.h
--- linux-2.6.13.1.org/include/asm-sh/cache.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/cache.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * include/asm-sh/cache.h
  *
diff -Nur linux-2.6.13.1.org/include/asm-sh/hd64461/hd64461.h grsecurity226/include/asm-sh/hd64461/hd64461.h
--- linux-2.6.13.1.org/include/asm-sh/hd64461/hd64461.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/hd64461/hd64461.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef __ASM_SH_HD64461
 #define __ASM_SH_HD64461
 /*
- *	$Id$
+ *	$Id$
  *	Copyright (C) 2000 YAEGASHI Takeshi
  *	Hitachi HD64461 companion chip support
  */
diff -Nur linux-2.6.13.1.org/include/asm-sh/hd64465/gpio.h grsecurity226/include/asm-sh/hd64465/gpio.h
--- linux-2.6.13.1.org/include/asm-sh/hd64465/gpio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/hd64465/gpio.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_SH_HD64465_GPIO_
 #define _ASM_SH_HD64465_GPIO_ 1
 /*
- * $Id$
+ * $Id$
  *
  * Hitachi HD64465 companion chip: General Purpose IO pins support.
  * This layer enables other device drivers to configure GPIO
diff -Nur linux-2.6.13.1.org/include/asm-sh/hd64465/hd64465.h grsecurity226/include/asm-sh/hd64465/hd64465.h
--- linux-2.6.13.1.org/include/asm-sh/hd64465/hd64465.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/hd64465/hd64465.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _ASM_SH_HD64465_
 #define _ASM_SH_HD64465_ 1
 /*
- * $Id$
+ * $Id$
  *
  * Hitachi HD64465 companion chip support
  *
diff -Nur linux-2.6.13.1.org/include/asm-sh/ioctl.h grsecurity226/include/asm-sh/ioctl.h
--- linux-2.6.13.1.org/include/asm-sh/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/ioctl.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * linux/ioctl.h for Linux by H.H. Bergman.
  */
diff -Nur linux-2.6.13.1.org/include/asm-sh/keyboard.h grsecurity226/include/asm-sh/keyboard.h
--- linux-2.6.13.1.org/include/asm-sh/keyboard.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/keyboard.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef	__ASM_SH_KEYBOARD_H
 #define	__ASM_SH_KEYBOARD_H
 /*
- *	$Id$
+ *	$Id$
  */
 
 #include <linux/kd.h>
diff -Nur linux-2.6.13.1.org/include/asm-sh/mpc1211/dma.h grsecurity226/include/asm-sh/mpc1211/dma.h
--- linux-2.6.13.1.org/include/asm-sh/mpc1211/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/mpc1211/dma.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm/dma.h: Defines for using and allocating dma channels.
  * Written by Hennus Bergman, 1992.
  * High DMA channel support & info by Hannu Savolainen
diff -Nur linux-2.6.13.1.org/include/asm-sh/namei.h grsecurity226/include/asm-sh/namei.h
--- linux-2.6.13.1.org/include/asm-sh/namei.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/namei.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm-sh/namei.h
  *
  * Included from linux/fs/namei.c
diff -Nur linux-2.6.13.1.org/include/asm-sh/uaccess.h grsecurity226/include/asm-sh/uaccess.h
--- linux-2.6.13.1.org/include/asm-sh/uaccess.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sh/uaccess.h	2005-08-30 01:00:54.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * User space memory access functions
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/a.out.h grsecurity226/include/asm-sparc/a.out.h
--- linux-2.6.13.1.org/include/asm-sparc/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/a.out.h	2005-08-30 01:14:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC_A_OUT_H__
 #define __SPARC_A_OUT_H__
 
@@ -91,7 +91,7 @@
 
 #include <asm/page.h>
 
-#define STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
+#define __STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
 
 #endif /* __KERNEL__ */
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/asi.h grsecurity226/include/asm-sparc/asi.h
--- linux-2.6.13.1.org/include/asm-sparc/asi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/asi.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_ASI_H
 #define _SPARC_ASI_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/auxio.h grsecurity226/include/asm-sparc/auxio.h
--- linux-2.6.13.1.org/include/asm-sparc/auxio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/auxio.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * auxio.h:  Definitions and code for the Auxiliary I/O register.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/bitops.h grsecurity226/include/asm-sparc/bitops.h
--- linux-2.6.13.1.org/include/asm-sparc/bitops.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/bitops.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * bitops.h: Bit string operations on the Sparc.
  *
  * Copyright 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/bsderrno.h grsecurity226/include/asm-sparc/bsderrno.h
--- linux-2.6.13.1.org/include/asm-sparc/bsderrno.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/bsderrno.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * bsderrno.h: Error numbers for NetBSD binary compatibility
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/btfixup.h grsecurity226/include/asm-sparc/btfixup.h
--- linux-2.6.13.1.org/include/asm-sparc/btfixup.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/btfixup.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *  asm-sparc/btfixup.h:    Macros for boot time linking.
  *
  *  Copyright (C) 1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/bugs.h grsecurity226/include/asm-sparc/bugs.h
--- linux-2.6.13.1.org/include/asm-sparc/bugs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/bugs.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/*  $Id$
+/*  $Id$
  *  include/asm-sparc/bugs.h:  Sparc probes for various bugs.
  *
  *  Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/byteorder.h grsecurity226/include/asm-sparc/byteorder.h
--- linux-2.6.13.1.org/include/asm-sparc/byteorder.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/byteorder.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_BYTEORDER_H
 #define _SPARC_BYTEORDER_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/cache.h grsecurity226/include/asm-sparc/cache.h
--- linux-2.6.13.1.org/include/asm-sparc/cache.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/cache.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * cache.h:  Cache specific code for the Sparc.  These include flushing
  *           and direct tag/data line access.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/checksum.h grsecurity226/include/asm-sparc/checksum.h
--- linux-2.6.13.1.org/include/asm-sparc/checksum.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/checksum.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC_CHECKSUM_H
 #define __SPARC_CHECKSUM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/clock.h grsecurity226/include/asm-sparc/clock.h
--- linux-2.6.13.1.org/include/asm-sparc/clock.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/clock.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * clock.h:  Definitions for clock operations on the Sparc.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/contregs.h grsecurity226/include/asm-sparc/contregs.h
--- linux-2.6.13.1.org/include/asm-sparc/contregs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/contregs.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_CONTREGS_H
 #define _SPARC_CONTREGS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/cypress.h grsecurity226/include/asm-sparc/cypress.h
--- linux-2.6.13.1.org/include/asm-sparc/cypress.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/cypress.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * cypress.h: Cypress module specific definitions and defines.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/delay.h grsecurity226/include/asm-sparc/delay.h
--- linux-2.6.13.1.org/include/asm-sparc/delay.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/delay.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * delay.h: Linux delay routines on the Sparc.
  *
  * Copyright (C) 1994 David S. Miller (davem@caip.rutgers.edu).
diff -Nur linux-2.6.13.1.org/include/asm-sparc/dma.h grsecurity226/include/asm-sparc/dma.h
--- linux-2.6.13.1.org/include/asm-sparc/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/dma.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * include/asm-sparc/dma.h
  *
  * Copyright 1995 (C) David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/ebus.h grsecurity226/include/asm-sparc/ebus.h
--- linux-2.6.13.1.org/include/asm-sparc/ebus.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/ebus.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * ebus.h: PCI to Ebus pseudo driver software state.
  *
  * Copyright (C) 1997 Eddie C. Dost (ecd@skynet.be) 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/ecc.h grsecurity226/include/asm-sparc/ecc.h
--- linux-2.6.13.1.org/include/asm-sparc/ecc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/ecc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * ecc.h: Definitions and defines for the external cache/memory
  *        controller on the sun4m.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/eeprom.h grsecurity226/include/asm-sparc/eeprom.h
--- linux-2.6.13.1.org/include/asm-sparc/eeprom.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/eeprom.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * eeprom.h:  Definitions for the Sun eeprom.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/elf.h grsecurity226/include/asm-sparc/elf.h
--- linux-2.6.13.1.org/include/asm-sparc/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/elf.h	2005-08-30 01:14:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __ASMSPARC_ELF_H
 #define __ASMSPARC_ELF_H
 
@@ -145,6 +145,17 @@
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	0x10000UL
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		16
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		16
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  This can NOT be done in userspace
    on Sparc.  */
diff -Nur linux-2.6.13.1.org/include/asm-sparc/errno.h grsecurity226/include/asm-sparc/errno.h
--- linux-2.6.13.1.org/include/asm-sparc/errno.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/errno.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_ERRNO_H
 #define _SPARC_ERRNO_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/fcntl.h grsecurity226/include/asm-sparc/fcntl.h
--- linux-2.6.13.1.org/include/asm-sparc/fcntl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/fcntl.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_FCNTL_H
 #define _SPARC_FCNTL_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/head.h grsecurity226/include/asm-sparc/head.h
--- linux-2.6.13.1.org/include/asm-sparc/head.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/head.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC_HEAD_H
 #define __SPARC_HEAD_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/ide.h grsecurity226/include/asm-sparc/ide.h
--- linux-2.6.13.1.org/include/asm-sparc/ide.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/ide.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * ide.h: SPARC PCI specific IDE glue.
  *
  * Copyright (C) 1997  David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/idprom.h grsecurity226/include/asm-sparc/idprom.h
--- linux-2.6.13.1.org/include/asm-sparc/idprom.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/idprom.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * idprom.h: Macros and defines for idprom routines
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/io.h grsecurity226/include/asm-sparc/io.h
--- linux-2.6.13.1.org/include/asm-sparc/io.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/io.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 #ifndef __SPARC_IO_H
 #define __SPARC_IO_H
diff -Nur linux-2.6.13.1.org/include/asm-sparc/ioctl.h grsecurity226/include/asm-sparc/ioctl.h
--- linux-2.6.13.1.org/include/asm-sparc/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/ioctl.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_IOCTL_H
 #define _SPARC_IOCTL_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/irq.h grsecurity226/include/asm-sparc/irq.h
--- linux-2.6.13.1.org/include/asm-sparc/irq.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/irq.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * irq.h: IRQ registers on the Sparc.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/kdebug.h grsecurity226/include/asm-sparc/kdebug.h
--- linux-2.6.13.1.org/include/asm-sparc/kdebug.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/kdebug.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * kdebug.h:  Defines and definitions for debugging the Linux kernel
  *            under various kernel debuggers.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/kgdb.h grsecurity226/include/asm-sparc/kgdb.h
--- linux-2.6.13.1.org/include/asm-sparc/kgdb.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/kgdb.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * kgdb.h: Defines and declarations for serial line source level
  *         remote debugging of the Linux kernel using gdb.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/machines.h grsecurity226/include/asm-sparc/machines.h
--- linux-2.6.13.1.org/include/asm-sparc/machines.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/machines.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * machines.h:  Defines for taking apart the machine type value in the
  *              idprom and determining the kind of machine we are on.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/mbus.h grsecurity226/include/asm-sparc/mbus.h
--- linux-2.6.13.1.org/include/asm-sparc/mbus.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/mbus.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * mbus.h:  Various defines for MBUS modules.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/memreg.h grsecurity226/include/asm-sparc/memreg.h
--- linux-2.6.13.1.org/include/asm-sparc/memreg.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/memreg.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_MEMREG_H
 #define _SPARC_MEMREG_H
 /* memreg.h:  Definitions of the values found in the synchronous
diff -Nur linux-2.6.13.1.org/include/asm-sparc/mman.h grsecurity226/include/asm-sparc/mman.h
--- linux-2.6.13.1.org/include/asm-sparc/mman.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/mman.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC_MMAN_H__
 #define __SPARC_MMAN_H__
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/mostek.h grsecurity226/include/asm-sparc/mostek.h
--- linux-2.6.13.1.org/include/asm-sparc/mostek.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/mostek.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * mostek.h:  Describes the various Mostek time of day clock registers.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/mpmbox.h grsecurity226/include/asm-sparc/mpmbox.h
--- linux-2.6.13.1.org/include/asm-sparc/mpmbox.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/mpmbox.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * mpmbox.h:  Interface and defines for the OpenProm mailbox
  *               facilities for MP machines under Linux.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/msi.h grsecurity226/include/asm-sparc/msi.h
--- linux-2.6.13.1.org/include/asm-sparc/msi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/msi.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * msi.h:  Defines specific to the MBus - Sbus - Interface.
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/mxcc.h grsecurity226/include/asm-sparc/mxcc.h
--- linux-2.6.13.1.org/include/asm-sparc/mxcc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/mxcc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * mxcc.h:  Definitions of the Viking MXCC registers
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/namei.h grsecurity226/include/asm-sparc/namei.h
--- linux-2.6.13.1.org/include/asm-sparc/namei.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/namei.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm-sparc/namei.h
  *
  * Routines to handle famous /usr/gnemul/s*.
diff -Nur linux-2.6.13.1.org/include/asm-sparc/obio.h grsecurity226/include/asm-sparc/obio.h
--- linux-2.6.13.1.org/include/asm-sparc/obio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/obio.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * obio.h:  Some useful locations in 0xFXXXXXXXX PA obio space on sun4d.
  *
  * Copyright (C) 1997 Jakub Jelinek <jj@sunsite.mff.cuni.cz>
diff -Nur linux-2.6.13.1.org/include/asm-sparc/openprom.h grsecurity226/include/asm-sparc/openprom.h
--- linux-2.6.13.1.org/include/asm-sparc/openprom.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/openprom.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC_OPENPROM_H
 #define __SPARC_OPENPROM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/oplib.h grsecurity226/include/asm-sparc/oplib.h
--- linux-2.6.13.1.org/include/asm-sparc/oplib.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/oplib.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * oplib.h:  Describes the interface and available routines in the
  *           Linux Prom library.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/page.h grsecurity226/include/asm-sparc/page.h
--- linux-2.6.13.1.org/include/asm-sparc/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/page.h	2005-08-30 01:14:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * page.h:  Various defines and such for MMU operations on the Sparc for
  *          the Linux kernel.
  *
@@ -176,6 +176,15 @@
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			 ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _SPARC_PAGE_H */
diff -Nur linux-2.6.13.1.org/include/asm-sparc/param.h grsecurity226/include/asm-sparc/param.h
--- linux-2.6.13.1.org/include/asm-sparc/param.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/param.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASMSPARC_PARAM_H
 #define _ASMSPARC_PARAM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/pbm.h grsecurity226/include/asm-sparc/pbm.h
--- linux-2.6.13.1.org/include/asm-sparc/pbm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/pbm.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * pbm.h: PCI bus module pseudo driver software state
  *        Adopted from sparc64 by V. Roganov and G. Raiko
diff -Nur linux-2.6.13.1.org/include/asm-sparc/pcic.h grsecurity226/include/asm-sparc/pcic.h
--- linux-2.6.13.1.org/include/asm-sparc/pcic.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/pcic.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * pcic.h: JavaEngine 1 specific PCI definitions.
  *
  * Copyright (C) 1998 V. Roganov and G. Raiko
diff -Nur linux-2.6.13.1.org/include/asm-sparc/pconf.h grsecurity226/include/asm-sparc/pconf.h
--- linux-2.6.13.1.org/include/asm-sparc/pconf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/pconf.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * pconf.h: pathconf() and fpathconf() defines for SunOS
  *          system call compatibility.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/pgalloc.h grsecurity226/include/asm-sparc/pgalloc.h
--- linux-2.6.13.1.org/include/asm-sparc/pgalloc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/pgalloc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_PGALLOC_H
 #define _SPARC_PGALLOC_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/pgtable.h grsecurity226/include/asm-sparc/pgtable.h
--- linux-2.6.13.1.org/include/asm-sparc/pgtable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/pgtable.h	2005-08-30 01:14:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_PGTABLE_H
 #define _SPARC_PGTABLE_H
 
@@ -50,6 +50,13 @@
 BTFIXUPDEF_INT(page_shared)
 BTFIXUPDEF_INT(page_copy)
 BTFIXUPDEF_INT(page_readonly)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+BTFIXUPDEF_INT(page_shared_noexec)
+BTFIXUPDEF_INT(page_copy_noexec)
+BTFIXUPDEF_INT(page_readonly_noexec)
+#endif
+
 BTFIXUPDEF_INT(page_kernel)
 
 #define PMD_SHIFT		SUN4C_PMD_SHIFT
@@ -71,6 +78,16 @@
 #define PAGE_COPY      __pgprot(BTFIXUP_INT(page_copy))
 #define PAGE_READONLY  __pgprot(BTFIXUP_INT(page_readonly))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(BTFIXUP_INT(page_shared_noexec))
+# define PAGE_COPY_NOEXEC	__pgprot(BTFIXUP_INT(page_copy_noexec))
+# define PAGE_READONLY_NOEXEC	__pgprot(BTFIXUP_INT(page_readonly_noexec))
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 extern unsigned long page_kernel;
 
 #ifdef MODULE
diff -Nur linux-2.6.13.1.org/include/asm-sparc/pgtsrmmu.h grsecurity226/include/asm-sparc/pgtsrmmu.h
--- linux-2.6.13.1.org/include/asm-sparc/pgtsrmmu.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/pgtsrmmu.h	2005-08-30 01:14:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * pgtsrmmu.h:  SRMMU page table defines and code.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
@@ -115,6 +115,16 @@
 				    SRMMU_EXEC | SRMMU_REF)
 #define SRMMU_PAGE_RDONLY  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
 				    SRMMU_EXEC | SRMMU_REF)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define SRMMU_PAGE_SHARED_NOEXEC  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_WRITE | SRMMU_REF)
+#define SRMMU_PAGE_COPY_NOEXEC    __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_REF)
+#define SRMMU_PAGE_RDONLY_NOEXEC  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_REF)
+#endif
+
 #define SRMMU_PAGE_KERNEL  __pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_PRIV | \
 				    SRMMU_DIRTY | SRMMU_REF)
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/pgtsun4.h grsecurity226/include/asm-sparc/pgtsun4.h
--- linux-2.6.13.1.org/include/asm-sparc/pgtsun4.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/pgtsun4.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * pgtsun4.h:  Sun4 specific pgtable.h defines and code.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/pgtsun4c.h grsecurity226/include/asm-sparc/pgtsun4c.h
--- linux-2.6.13.1.org/include/asm-sparc/pgtsun4c.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/pgtsun4c.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * pgtsun4c.h:  Sun4c specific pgtable.h defines and code.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/processor.h grsecurity226/include/asm-sparc/processor.h
--- linux-2.6.13.1.org/include/asm-sparc/processor.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/processor.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * include/asm-sparc/processor.h
  *
  * Copyright (C) 1994 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/psr.h grsecurity226/include/asm-sparc/psr.h
--- linux-2.6.13.1.org/include/asm-sparc/psr.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/psr.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * psr.h: This file holds the macros for masking off various parts of
  *        the processor status register on the Sparc. This is valid
  *        for Version 8. On the V9 this is renamed to the PSTATE
diff -Nur linux-2.6.13.1.org/include/asm-sparc/ptrace.h grsecurity226/include/asm-sparc/ptrace.h
--- linux-2.6.13.1.org/include/asm-sparc/ptrace.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/ptrace.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_PTRACE_H
 #define _SPARC_PTRACE_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/resource.h grsecurity226/include/asm-sparc/resource.h
--- linux-2.6.13.1.org/include/asm-sparc/resource.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/resource.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * resource.h: Resource definitions.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/ross.h grsecurity226/include/asm-sparc/ross.h
--- linux-2.6.13.1.org/include/asm-sparc/ross.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/ross.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * ross.h: Ross module specific definitions and defines.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/rtc.h grsecurity226/include/asm-sparc/rtc.h
--- linux-2.6.13.1.org/include/asm-sparc/rtc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/rtc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * rtc.h: Definitions for access to the Mostek real time clock
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/sbi.h grsecurity226/include/asm-sparc/sbi.h
--- linux-2.6.13.1.org/include/asm-sparc/sbi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/sbi.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sbi.h:  SBI (Sbus Interface on sun4d) definitions
  *
  * Copyright (C) 1997 Jakub Jelinek <jj@sunsite.mff.cuni.cz>
diff -Nur linux-2.6.13.1.org/include/asm-sparc/sbus.h grsecurity226/include/asm-sparc/sbus.h
--- linux-2.6.13.1.org/include/asm-sparc/sbus.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/sbus.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sbus.h:  Defines for the Sun SBus.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/scatterlist.h grsecurity226/include/asm-sparc/scatterlist.h
--- linux-2.6.13.1.org/include/asm-sparc/scatterlist.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/scatterlist.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_SCATTERLIST_H
 #define _SPARC_SCATTERLIST_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/shmparam.h grsecurity226/include/asm-sparc/shmparam.h
--- linux-2.6.13.1.org/include/asm-sparc/shmparam.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/shmparam.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASMSPARC_SHMPARAM_H
 #define _ASMSPARC_SHMPARAM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/sigcontext.h grsecurity226/include/asm-sparc/sigcontext.h
--- linux-2.6.13.1.org/include/asm-sparc/sigcontext.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/sigcontext.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC_SIGCONTEXT_H
 #define __SPARC_SIGCONTEXT_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/siginfo.h grsecurity226/include/asm-sparc/siginfo.h
--- linux-2.6.13.1.org/include/asm-sparc/siginfo.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/siginfo.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * siginfo.c:
  */
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/signal.h grsecurity226/include/asm-sparc/signal.h
--- linux-2.6.13.1.org/include/asm-sparc/signal.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/signal.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASMSPARC_SIGNAL_H
 #define _ASMSPARC_SIGNAL_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/smpprim.h grsecurity226/include/asm-sparc/smpprim.h
--- linux-2.6.13.1.org/include/asm-sparc/smpprim.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/smpprim.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/*  $Id$
+/*  $Id$
  *  smpprim.h:  SMP locking primitives on the Sparc
  *
  *  God knows we won't be actually using this code for some time
diff -Nur linux-2.6.13.1.org/include/asm-sparc/socket.h grsecurity226/include/asm-sparc/socket.h
--- linux-2.6.13.1.org/include/asm-sparc/socket.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/socket.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASM_SOCKET_H
 #define _ASM_SOCKET_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/solerrno.h grsecurity226/include/asm-sparc/solerrno.h
--- linux-2.6.13.1.org/include/asm-sparc/solerrno.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/solerrno.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * solerrno.h: Solaris error return codes for compatibility.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/stat.h grsecurity226/include/asm-sparc/stat.h
--- linux-2.6.13.1.org/include/asm-sparc/stat.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/stat.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_STAT_H
 #define _SPARC_STAT_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/statfs.h grsecurity226/include/asm-sparc/statfs.h
--- linux-2.6.13.1.org/include/asm-sparc/statfs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/statfs.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_STATFS_H
 #define _SPARC_STATFS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/string.h grsecurity226/include/asm-sparc/string.h
--- linux-2.6.13.1.org/include/asm-sparc/string.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/string.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * string.h: External definitions for optimized assembly string
  *           routines for the Linux Kernel.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/sun4paddr.h grsecurity226/include/asm-sparc/sun4paddr.h
--- linux-2.6.13.1.org/include/asm-sparc/sun4paddr.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/sun4paddr.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sun4paddr.h:  Various physical addresses on sun4 machines
  *
  * Copyright (C) 1997 Anton Blanchard (anton@progsoc.uts.edu.au)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/sunbpp.h grsecurity226/include/asm-sparc/sunbpp.h
--- linux-2.6.13.1.org/include/asm-sparc/sunbpp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/sunbpp.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * include/asm-sparc/sunbpp.h
  */
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/sysen.h grsecurity226/include/asm-sparc/sysen.h
--- linux-2.6.13.1.org/include/asm-sparc/sysen.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/sysen.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sysen.h:  Bit fields within the "System Enable" register accessed via
  *           the ASI_CONTROL address space at address AC_SYSENABLE.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/system.h grsecurity226/include/asm-sparc/system.h
--- linux-2.6.13.1.org/include/asm-sparc/system.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/system.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #include <linux/config.h>
 
 #ifndef __SPARC_SYSTEM_H
diff -Nur linux-2.6.13.1.org/include/asm-sparc/termios.h grsecurity226/include/asm-sparc/termios.h
--- linux-2.6.13.1.org/include/asm-sparc/termios.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/termios.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_TERMIOS_H
 #define _SPARC_TERMIOS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/timer.h grsecurity226/include/asm-sparc/timer.h
--- linux-2.6.13.1.org/include/asm-sparc/timer.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/timer.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * timer.h:  Definitions for the timer chips on the Sparc.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/traps.h grsecurity226/include/asm-sparc/traps.h
--- linux-2.6.13.1.org/include/asm-sparc/traps.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/traps.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * traps.h:  Format of entries for the Sparc trap table.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/tsunami.h grsecurity226/include/asm-sparc/tsunami.h
--- linux-2.6.13.1.org/include/asm-sparc/tsunami.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/tsunami.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * tsunami.h:  Module specific definitions for Tsunami V8 Sparcs
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc/turbosparc.h grsecurity226/include/asm-sparc/turbosparc.h
--- linux-2.6.13.1.org/include/asm-sparc/turbosparc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/turbosparc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * turbosparc.h:  Defines specific to the TurboSparc module.
  *            This is SRMMU stuff.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/types.h grsecurity226/include/asm-sparc/types.h
--- linux-2.6.13.1.org/include/asm-sparc/types.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/types.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_TYPES_H
 #define _SPARC_TYPES_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/uaccess.h grsecurity226/include/asm-sparc/uaccess.h
--- linux-2.6.13.1.org/include/asm-sparc/uaccess.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/uaccess.h	2005-08-30 01:14:51.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * uaccess.h: User space memore access functions.
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
@@ -41,7 +41,7 @@
  * No one can read/write anything from userland in the kernel space by setting
  * large size and address near to PAGE_OFFSET - a fault will break his intentions.
  */
-#define __user_ok(addr, size) ({ (void)(size); (addr) < STACK_TOP; })
+#define __user_ok(addr, size) ({ (void)(size); (addr) < __STACK_TOP; })
 #define __kernel_ok (segment_eq(get_fs(), KERNEL_DS))
 #define __access_ok(addr,size) (__user_ok((addr) & get_fs().seg,(size)))
 #define access_ok(type, addr, size)					\
diff -Nur linux-2.6.13.1.org/include/asm-sparc/unistd.h grsecurity226/include/asm-sparc/unistd.h
--- linux-2.6.13.1.org/include/asm-sparc/unistd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/unistd.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_UNISTD_H
 #define _SPARC_UNISTD_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/user.h grsecurity226/include/asm-sparc/user.h
--- linux-2.6.13.1.org/include/asm-sparc/user.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/user.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * asm-sparc/user.h: Core file definitions for the Sparc.
  *
  * Keep in sync with reg.h.  Actually, we could get rid of this
diff -Nur linux-2.6.13.1.org/include/asm-sparc/vac-ops.h grsecurity226/include/asm-sparc/vac-ops.h
--- linux-2.6.13.1.org/include/asm-sparc/vac-ops.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/vac-ops.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_VAC_OPS_H
 #define _SPARC_VAC_OPS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/vaddrs.h grsecurity226/include/asm-sparc/vaddrs.h
--- linux-2.6.13.1.org/include/asm-sparc/vaddrs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/vaddrs.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC_VADDRS_H
 #define _SPARC_VADDRS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc/viking.h grsecurity226/include/asm-sparc/viking.h
--- linux-2.6.13.1.org/include/asm-sparc/viking.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/viking.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * viking.h:  Defines specific to the GNU/Viking MBUS module.
  *            This is SRMMU stuff.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc/winmacro.h grsecurity226/include/asm-sparc/winmacro.h
--- linux-2.6.13.1.org/include/asm-sparc/winmacro.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc/winmacro.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * winmacro.h: Window loading-unloading macros.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/a.out.h grsecurity226/include/asm-sparc64/a.out.h
--- linux-2.6.13.1.org/include/asm-sparc64/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/a.out.h	2005-08-30 01:14:53.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC64_A_OUT_H__
 #define __SPARC64_A_OUT_H__
 
@@ -95,7 +95,7 @@
 
 #ifdef __KERNEL__
 
-#define STACK_TOP (test_thread_flag(TIF_32BIT) ? 0xf0000000 : 0x80000000000L)
+#define __STACK_TOP (test_thread_flag(TIF_32BIT) ? 0xf0000000 : 0x80000000000L)
 
 #endif
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/apb.h grsecurity226/include/asm-sparc64/apb.h
--- linux-2.6.13.1.org/include/asm-sparc64/apb.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/apb.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * apb.h: Advanced PCI Bridge Configuration Registers and Bits
  *
  * Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/asi.h grsecurity226/include/asm-sparc64/asi.h
--- linux-2.6.13.1.org/include/asm-sparc64/asi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/asi.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_ASI_H
 #define _SPARC64_ASI_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/atomic.h grsecurity226/include/asm-sparc64/atomic.h
--- linux-2.6.13.1.org/include/asm-sparc64/atomic.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/atomic.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * atomic.h: Thankfully the V9 is at least reasonable for this
  *           stuff.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/auxio.h grsecurity226/include/asm-sparc64/auxio.h
--- linux-2.6.13.1.org/include/asm-sparc64/auxio.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/auxio.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * auxio.h:  Definitions and code for the Auxiliary I/O registers.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/bbc.h grsecurity226/include/asm-sparc64/bbc.h
--- linux-2.6.13.1.org/include/asm-sparc64/bbc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/bbc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * bbc.h: Defines for BootBus Controller found on UltraSPARC-III
  *        systems.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/bitops.h grsecurity226/include/asm-sparc64/bitops.h
--- linux-2.6.13.1.org/include/asm-sparc64/bitops.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/bitops.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * bitops.h: Bit string operations on the V9.
  *
  * Copyright 1996, 1997 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/bsderrno.h grsecurity226/include/asm-sparc64/bsderrno.h
--- linux-2.6.13.1.org/include/asm-sparc64/bsderrno.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/bsderrno.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * bsderrno.h: Error numbers for NetBSD binary compatibility
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/bugs.h grsecurity226/include/asm-sparc64/bugs.h
--- linux-2.6.13.1.org/include/asm-sparc64/bugs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/bugs.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/*  $Id$
+/*  $Id$
  *  include/asm-sparc64/bugs.h:  Sparc probes for various bugs.
  *
  *  Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/byteorder.h grsecurity226/include/asm-sparc64/byteorder.h
--- linux-2.6.13.1.org/include/asm-sparc64/byteorder.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/byteorder.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_BYTEORDER_H
 #define _SPARC64_BYTEORDER_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/chafsr.h grsecurity226/include/asm-sparc64/chafsr.h
--- linux-2.6.13.1.org/include/asm-sparc64/chafsr.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/chafsr.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_CHAFSR_H
 #define _SPARC64_CHAFSR_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/checksum.h grsecurity226/include/asm-sparc64/checksum.h
--- linux-2.6.13.1.org/include/asm-sparc64/checksum.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/checksum.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC64_CHECKSUM_H
 #define __SPARC64_CHECKSUM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/chmctrl.h grsecurity226/include/asm-sparc64/chmctrl.h
--- linux-2.6.13.1.org/include/asm-sparc64/chmctrl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/chmctrl.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_CHMCTRL_H
 #define _SPARC64_CHMCTRL_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/dcr.h grsecurity226/include/asm-sparc64/dcr.h
--- linux-2.6.13.1.org/include/asm-sparc64/dcr.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/dcr.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_DCR_H
 #define _SPARC64_DCR_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/dcu.h grsecurity226/include/asm-sparc64/dcu.h
--- linux-2.6.13.1.org/include/asm-sparc64/dcu.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/dcu.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_DCU_H
 #define _SPARC64_DCU_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/display7seg.h grsecurity226/include/asm-sparc64/display7seg.h
--- linux-2.6.13.1.org/include/asm-sparc64/display7seg.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/display7seg.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * display7seg - Driver interface for the 7-segment display
  * present on Sun Microsystems CP1400 and CP1500
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/dma.h grsecurity226/include/asm-sparc64/dma.h
--- linux-2.6.13.1.org/include/asm-sparc64/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/dma.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * include/asm-sparc64/dma.h
  *
  * Copyright 1996 (C) David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/ebus.h grsecurity226/include/asm-sparc64/ebus.h
--- linux-2.6.13.1.org/include/asm-sparc64/ebus.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/ebus.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * ebus.h: PCI to Ebus pseudo driver software state.
  *
  * Copyright (C) 1997 Eddie C. Dost (ecd@skynet.be)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/elf.h grsecurity226/include/asm-sparc64/elf.h
--- linux-2.6.13.1.org/include/asm-sparc64/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/elf.h	2005-08-30 01:14:53.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __ASM_SPARC64_ELF_H
 #define __ASM_SPARC64_ELF_H
 
@@ -140,6 +140,16 @@
 #define ELF_ET_DYN_BASE         0x0000010000000000UL
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(test_thread_flag(TIF_32BIT) ? 0x10000UL : 0x100000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		(PAGE_SHIFT + 1)
+#define PAX_DELTA_MMAP_LEN(tsk)		(test_thread_flag(TIF_32BIT) ? 14 : 28 )
+#define PAX_DELTA_EXEC_LSB(tsk)		(PAGE_SHIFT + 1)
+#define PAX_DELTA_EXEC_LEN(tsk)		(test_thread_flag(TIF_32BIT) ? 14 : 28 )
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(test_thread_flag(TIF_32BIT) ? 15 : 29 )
+#endif
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  */
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/envctrl.h grsecurity226/include/asm-sparc64/envctrl.h
--- linux-2.6.13.1.org/include/asm-sparc64/envctrl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/envctrl.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * envctrl.h: Definitions for access to the i2c environment
  *            monitoring on Ultrasparc systems.
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/errno.h grsecurity226/include/asm-sparc64/errno.h
--- linux-2.6.13.1.org/include/asm-sparc64/errno.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/errno.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_ERRNO_H
 #define _SPARC64_ERRNO_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/estate.h grsecurity226/include/asm-sparc64/estate.h
--- linux-2.6.13.1.org/include/asm-sparc64/estate.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/estate.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_ESTATE_H
 #define _SPARC64_ESTATE_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/fcntl.h grsecurity226/include/asm-sparc64/fcntl.h
--- linux-2.6.13.1.org/include/asm-sparc64/fcntl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/fcntl.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_FCNTL_H
 #define _SPARC64_FCNTL_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/fhc.h grsecurity226/include/asm-sparc64/fhc.h
--- linux-2.6.13.1.org/include/asm-sparc64/fhc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/fhc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * fhc.h: Structures for central/fhc pseudo driver on Sunfire/Starfire/Wildfire.
  *
  * Copyright (C) 1997, 1999 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/floppy.h grsecurity226/include/asm-sparc64/floppy.h
--- linux-2.6.13.1.org/include/asm-sparc64/floppy.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/floppy.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * asm-sparc64/floppy.h: Sparc specific parts of the Floppy driver.
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/head.h grsecurity226/include/asm-sparc64/head.h
--- linux-2.6.13.1.org/include/asm-sparc64/head.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/head.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_HEAD_H
 #define _SPARC64_HEAD_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/ide.h grsecurity226/include/asm-sparc64/ide.h
--- linux-2.6.13.1.org/include/asm-sparc64/ide.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/ide.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * ide.h: Ultra/PCI specific IDE glue.
  *
  * Copyright (C) 1997  David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/idprom.h grsecurity226/include/asm-sparc64/idprom.h
--- linux-2.6.13.1.org/include/asm-sparc64/idprom.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/idprom.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * idprom.h: Macros and defines for idprom routines
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/io.h grsecurity226/include/asm-sparc64/io.h
--- linux-2.6.13.1.org/include/asm-sparc64/io.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/io.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC64_IO_H
 #define __SPARC64_IO_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/ioctl.h grsecurity226/include/asm-sparc64/ioctl.h
--- linux-2.6.13.1.org/include/asm-sparc64/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/ioctl.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_IOCTL_H
 #define _SPARC64_IOCTL_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/ioctls.h grsecurity226/include/asm-sparc64/ioctls.h
--- linux-2.6.13.1.org/include/asm-sparc64/ioctls.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/ioctls.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASM_SPARC64_IOCTLS_H
 #define _ASM_SPARC64_IOCTLS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/iommu.h grsecurity226/include/asm-sparc64/iommu.h
--- linux-2.6.13.1.org/include/asm-sparc64/iommu.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/iommu.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * iommu.h: Definitions for the sun5 IOMMU.
  *
  * Copyright (C) 1996, 1999 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/irq.h grsecurity226/include/asm-sparc64/irq.h
--- linux-2.6.13.1.org/include/asm-sparc64/irq.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/irq.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * irq.h: IRQ registers on the 64-bit Sparc.
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/isa.h grsecurity226/include/asm-sparc64/isa.h
--- linux-2.6.13.1.org/include/asm-sparc64/isa.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/isa.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * isa.h: Sparc64 layer for PCI to ISA bridge devices.
  *
  * Copyright (C) 2001 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/lsu.h grsecurity226/include/asm-sparc64/lsu.h
--- linux-2.6.13.1.org/include/asm-sparc64/lsu.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/lsu.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_LSU_H
 #define _SPARC64_LSU_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/mman.h grsecurity226/include/asm-sparc64/mman.h
--- linux-2.6.13.1.org/include/asm-sparc64/mman.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/mman.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC64_MMAN_H__
 #define __SPARC64_MMAN_H__
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/mmu_context.h grsecurity226/include/asm-sparc64/mmu_context.h
--- linux-2.6.13.1.org/include/asm-sparc64/mmu_context.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/mmu_context.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC64_MMU_CONTEXT_H
 #define __SPARC64_MMU_CONTEXT_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/mostek.h grsecurity226/include/asm-sparc64/mostek.h
--- linux-2.6.13.1.org/include/asm-sparc64/mostek.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/mostek.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * mostek.h:  Describes the various Mostek time of day clock registers.
  *
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/namei.h grsecurity226/include/asm-sparc64/namei.h
--- linux-2.6.13.1.org/include/asm-sparc64/namei.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/namei.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm-sparc64/namei.h
  *
  * Routines to handle famous /usr/gnemul/s*.
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/ns87303.h grsecurity226/include/asm-sparc64/ns87303.h
--- linux-2.6.13.1.org/include/asm-sparc64/ns87303.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/ns87303.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * ns87303.h: Configuration Register Description for the
  *            National Semiconductor PC87303 (SuperIO).
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/openprom.h grsecurity226/include/asm-sparc64/openprom.h
--- linux-2.6.13.1.org/include/asm-sparc64/openprom.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/openprom.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC64_OPENPROM_H
 #define __SPARC64_OPENPROM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/oplib.h grsecurity226/include/asm-sparc64/oplib.h
--- linux-2.6.13.1.org/include/asm-sparc64/oplib.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/oplib.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * oplib.h:  Describes the interface and available routines in the
  *           Linux Prom library.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/page.h grsecurity226/include/asm-sparc64/page.h
--- linux-2.6.13.1.org/include/asm-sparc64/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/page.h	2005-08-30 01:14:53.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _SPARC64_PAGE_H
 #define _SPARC64_PAGE_H
@@ -169,6 +169,15 @@
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* !(__KERNEL__) */
 
 #endif /* !(_SPARC64_PAGE_H) */
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/parport.h grsecurity226/include/asm-sparc64/parport.h
--- linux-2.6.13.1.org/include/asm-sparc64/parport.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/parport.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * parport.h: sparc64 specific parport initialization and dma.
  *
  * Copyright (C) 1999  Eddie C. Dost  (ecd@skynet.be)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/pbm.h grsecurity226/include/asm-sparc64/pbm.h
--- linux-2.6.13.1.org/include/asm-sparc64/pbm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/pbm.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * pbm.h: UltraSparc PCI controller software state.
  *
  * Copyright (C) 1997, 1998, 1999 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/pconf.h grsecurity226/include/asm-sparc64/pconf.h
--- linux-2.6.13.1.org/include/asm-sparc64/pconf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/pconf.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * pconf.h: pathconf() and fpathconf() defines for SunOS
  *          system call compatibility.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/pgalloc.h grsecurity226/include/asm-sparc64/pgalloc.h
--- linux-2.6.13.1.org/include/asm-sparc64/pgalloc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/pgalloc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_PGALLOC_H
 #define _SPARC64_PGALLOC_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/pgtable.h grsecurity226/include/asm-sparc64/pgtable.h
--- linux-2.6.13.1.org/include/asm-sparc64/pgtable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/pgtable.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * pgtable.h: SpitFire page table operations.
  *
  * Copyright 1996,1997 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/pil.h grsecurity226/include/asm-sparc64/pil.h
--- linux-2.6.13.1.org/include/asm-sparc64/pil.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/pil.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_PIL_H
 #define _SPARC64_PIL_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/processor.h grsecurity226/include/asm-sparc64/processor.h
--- linux-2.6.13.1.org/include/asm-sparc64/processor.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/processor.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * include/asm-sparc64/processor.h
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/psrcompat.h grsecurity226/include/asm-sparc64/psrcompat.h
--- linux-2.6.13.1.org/include/asm-sparc64/psrcompat.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/psrcompat.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_PSRCOMPAT_H
 #define _SPARC64_PSRCOMPAT_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/pstate.h grsecurity226/include/asm-sparc64/pstate.h
--- linux-2.6.13.1.org/include/asm-sparc64/pstate.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/pstate.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_PSTATE_H
 #define _SPARC64_PSTATE_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/ptrace.h grsecurity226/include/asm-sparc64/ptrace.h
--- linux-2.6.13.1.org/include/asm-sparc64/ptrace.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/ptrace.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_PTRACE_H
 #define _SPARC64_PTRACE_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/reg.h grsecurity226/include/asm-sparc64/reg.h
--- linux-2.6.13.1.org/include/asm-sparc64/reg.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/reg.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/asm-sparc64/reg.h
  * Layout of the registers as expected by gdb on the Sparc
  * we should replace the user.h definitions with those in
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/resource.h grsecurity226/include/asm-sparc64/resource.h
--- linux-2.6.13.1.org/include/asm-sparc64/resource.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/resource.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * resource.h: Resource definitions.
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/rtc.h grsecurity226/include/asm-sparc64/rtc.h
--- linux-2.6.13.1.org/include/asm-sparc64/rtc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/rtc.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * rtc.h: Definitions for access to the Mostek real time clock
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/rwsem.h grsecurity226/include/asm-sparc64/rwsem.h
--- linux-2.6.13.1.org/include/asm-sparc64/rwsem.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/rwsem.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * rwsem.h: R/W semaphores implemented using CAS
  *
  * Written by David S. Miller (davem@redhat.com), 2001.
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/sbus.h grsecurity226/include/asm-sparc64/sbus.h
--- linux-2.6.13.1.org/include/asm-sparc64/sbus.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/sbus.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * sbus.h: Defines for the Sun SBus.
  *
  * Copyright (C) 1996, 1999 David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/scatterlist.h grsecurity226/include/asm-sparc64/scatterlist.h
--- linux-2.6.13.1.org/include/asm-sparc64/scatterlist.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/scatterlist.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_SCATTERLIST_H
 #define _SPARC64_SCATTERLIST_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/shmparam.h grsecurity226/include/asm-sparc64/shmparam.h
--- linux-2.6.13.1.org/include/asm-sparc64/shmparam.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/shmparam.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASMSPARC64_SHMPARAM_H
 #define _ASMSPARC64_SHMPARAM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/sigcontext.h grsecurity226/include/asm-sparc64/sigcontext.h
--- linux-2.6.13.1.org/include/asm-sparc64/sigcontext.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/sigcontext.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC64_SIGCONTEXT_H
 #define __SPARC64_SIGCONTEXT_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/signal.h grsecurity226/include/asm-sparc64/signal.h
--- linux-2.6.13.1.org/include/asm-sparc64/signal.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/signal.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASMSPARC64_SIGNAL_H
 #define _ASMSPARC64_SIGNAL_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/socket.h grsecurity226/include/asm-sparc64/socket.h
--- linux-2.6.13.1.org/include/asm-sparc64/socket.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/socket.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASM_SOCKET_H
 #define _ASM_SOCKET_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/solerrno.h grsecurity226/include/asm-sparc64/solerrno.h
--- linux-2.6.13.1.org/include/asm-sparc64/solerrno.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/solerrno.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * solerrno.h: Solaris error return codes for compatibility.
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/spitfire.h grsecurity226/include/asm-sparc64/spitfire.h
--- linux-2.6.13.1.org/include/asm-sparc64/spitfire.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/spitfire.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * spitfire.h: SpitFire/BlackBird/Cheetah inline MMU operations.
  *
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/starfire.h grsecurity226/include/asm-sparc64/starfire.h
--- linux-2.6.13.1.org/include/asm-sparc64/starfire.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/starfire.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * starfire.h: Group all starfire specific code together.
  *
  * Copyright (C) 2000 Anton Blanchard (anton@samba.org)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/stat.h grsecurity226/include/asm-sparc64/stat.h
--- linux-2.6.13.1.org/include/asm-sparc64/stat.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/stat.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_STAT_H
 #define _SPARC64_STAT_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/statfs.h grsecurity226/include/asm-sparc64/statfs.h
--- linux-2.6.13.1.org/include/asm-sparc64/statfs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/statfs.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_STATFS_H
 #define _SPARC64_STATFS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/string.h grsecurity226/include/asm-sparc64/string.h
--- linux-2.6.13.1.org/include/asm-sparc64/string.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/string.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * string.h: External definitions for optimized assembly string
  *           routines for the Linux Kernel.
  *
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/sunbpp.h grsecurity226/include/asm-sparc64/sunbpp.h
--- linux-2.6.13.1.org/include/asm-sparc64/sunbpp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/sunbpp.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * include/asm-sparc64/sunbpp.h
  */
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/system.h grsecurity226/include/asm-sparc64/system.h
--- linux-2.6.13.1.org/include/asm-sparc64/system.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/system.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef __SPARC64_SYSTEM_H
 #define __SPARC64_SYSTEM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/termios.h grsecurity226/include/asm-sparc64/termios.h
--- linux-2.6.13.1.org/include/asm-sparc64/termios.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/termios.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_TERMIOS_H
 #define _SPARC64_TERMIOS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/thread_info.h grsecurity226/include/asm-sparc64/thread_info.h
--- linux-2.6.13.1.org/include/asm-sparc64/thread_info.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/thread_info.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * thread_info.h: sparc64 low-level thread information
  *
  * Copyright (C) 2002  David S. Miller (davem@redhat.com)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/timer.h grsecurity226/include/asm-sparc64/timer.h
--- linux-2.6.13.1.org/include/asm-sparc64/timer.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/timer.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * timer.h: System timer definitions for sun5.
  *
  * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/ttable.h grsecurity226/include/asm-sparc64/ttable.h
--- linux-2.6.13.1.org/include/asm-sparc64/ttable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/ttable.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_TTABLE_H
 #define _SPARC64_TTABLE_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/types.h grsecurity226/include/asm-sparc64/types.h
--- linux-2.6.13.1.org/include/asm-sparc64/types.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/types.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_TYPES_H
 #define _SPARC64_TYPES_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/uaccess.h grsecurity226/include/asm-sparc64/uaccess.h
--- linux-2.6.13.1.org/include/asm-sparc64/uaccess.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/uaccess.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _ASM_UACCESS_H
 #define _ASM_UACCESS_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/uctx.h grsecurity226/include/asm-sparc64/uctx.h
--- linux-2.6.13.1.org/include/asm-sparc64/uctx.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/uctx.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * uctx.h: Sparc64 {set,get}context() register state layouts.
  *
  * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/unistd.h grsecurity226/include/asm-sparc64/unistd.h
--- linux-2.6.13.1.org/include/asm-sparc64/unistd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/unistd.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_UNISTD_H
 #define _SPARC64_UNISTD_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/upa.h grsecurity226/include/asm-sparc64/upa.h
--- linux-2.6.13.1.org/include/asm-sparc64/upa.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/upa.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_UPA_H
 #define _SPARC64_UPA_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/user.h grsecurity226/include/asm-sparc64/user.h
--- linux-2.6.13.1.org/include/asm-sparc64/user.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/user.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * asm-sparc64/user.h: Core file definitions for the Sparc.
  *
  * Keep in sync with reg.h.  Actually, we could get rid of this
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/utrap.h grsecurity226/include/asm-sparc64/utrap.h
--- linux-2.6.13.1.org/include/asm-sparc64/utrap.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/utrap.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * include/asm-sparc64/utrap.h
  *
  * Copyright (C) 1997 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/visasm.h grsecurity226/include/asm-sparc64/visasm.h
--- linux-2.6.13.1.org/include/asm-sparc64/visasm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/visasm.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 #ifndef _SPARC64_VISASM_H
 #define _SPARC64_VISASM_H
 
diff -Nur linux-2.6.13.1.org/include/asm-sparc64/watchdog.h grsecurity226/include/asm-sparc64/watchdog.h
--- linux-2.6.13.1.org/include/asm-sparc64/watchdog.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-sparc64/watchdog.h	2005-08-30 01:00:55.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * watchdog - Driver interface for the hardware watchdog timers
  * present on Sun Microsystems boardsets
diff -Nur linux-2.6.13.1.org/include/asm-v850/ioctl.h grsecurity226/include/asm-v850/ioctl.h
--- linux-2.6.13.1.org/include/asm-v850/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-v850/ioctl.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * linux/ioctl.h for Linux by H.H. Bergman.
  */
diff -Nur linux-2.6.13.1.org/include/asm-x86_64/a.out.h grsecurity226/include/asm-x86_64/a.out.h
--- linux-2.6.13.1.org/include/asm-x86_64/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-x86_64/a.out.h	2005-08-30 01:14:55.000000000 +0200
@@ -21,7 +21,7 @@
 
 #ifdef __KERNEL__
 #include <linux/thread_info.h>
-#define STACK_TOP TASK_SIZE
+#define __STACK_TOP TASK_SIZE
 #endif
 
 #endif /* __A_OUT_GNU_H__ */
diff -Nur linux-2.6.13.1.org/include/asm-x86_64/dma.h grsecurity226/include/asm-x86_64/dma.h
--- linux-2.6.13.1.org/include/asm-x86_64/dma.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-x86_64/dma.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/include/asm/dma.h: Defines for using and allocating dma channels.
  * Written by Hennus Bergman, 1992.
  * High DMA channel support & info by Hannu Savolainen
diff -Nur linux-2.6.13.1.org/include/asm-x86_64/elf.h grsecurity226/include/asm-x86_64/elf.h
--- linux-2.6.13.1.org/include/asm-x86_64/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-x86_64/elf.h	2005-08-30 01:14:55.000000000 +0200
@@ -89,6 +89,17 @@
 
 #define ELF_ET_DYN_BASE         (2 * TASK_SIZE / 3)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE(tsk)	(test_thread_flag(TIF_IA32) ? 0x08048000UL : 0x400000UL)
+
+#define PAX_DELTA_MMAP_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_MMAP_LEN(tsk)		(test_thread_flag(TIF_IA32) ? 16 : 32)
+#define PAX_DELTA_EXEC_LSB(tsk)		PAGE_SHIFT
+#define PAX_DELTA_EXEC_LEN(tsk)		(test_thread_flag(TIF_IA32) ? 16 : 32)
+#define PAX_DELTA_STACK_LSB(tsk)	PAGE_SHIFT
+#define PAX_DELTA_STACK_LEN(tsk)	(test_thread_flag(TIF_IA32) ? 16 : 32)
+#endif
+
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different). Assumes current is the process
    getting dumped. */
diff -Nur linux-2.6.13.1.org/include/asm-x86_64/hw_irq.h grsecurity226/include/asm-x86_64/hw_irq.h
--- linux-2.6.13.1.org/include/asm-x86_64/hw_irq.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-x86_64/hw_irq.h	2005-08-30 01:00:56.000000000 +0200
@@ -13,7 +13,7 @@
  *
  *	hacked by Andi Kleen for x86-64.
  * 
- *  $Id$
+ *  $Id$
  */
 
 #ifndef __ASSEMBLY__
diff -Nur linux-2.6.13.1.org/include/asm-x86_64/ioctl.h grsecurity226/include/asm-x86_64/ioctl.h
--- linux-2.6.13.1.org/include/asm-x86_64/ioctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-x86_64/ioctl.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * linux/ioctl.h for Linux by H.H. Bergman.
  */
diff -Nur linux-2.6.13.1.org/include/asm-x86_64/page.h grsecurity226/include/asm-x86_64/page.h
--- linux-2.6.13.1.org/include/asm-x86_64/page.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-x86_64/page.h	2005-09-05 18:42:10.000000000 +0200
@@ -11,7 +11,7 @@
 #define PAGE_SIZE	(1UL << PAGE_SHIFT)
 #endif
 #define PAGE_MASK	(~(PAGE_SIZE-1))
-#define PHYSICAL_PAGE_MASK	(~(PAGE_SIZE-1) & (__PHYSICAL_MASK << PAGE_SHIFT))
+#define PHYSICAL_PAGE_MASK	(__PHYSICAL_MASK << PAGE_SHIFT)
 
 #define THREAD_ORDER 1 
 #ifdef __ASSEMBLY__
@@ -137,6 +137,15 @@
 	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
 	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #define __HAVE_ARCH_GATE_AREA 1	
 
 #endif /* __KERNEL__ */
diff -Nur linux-2.6.13.1.org/include/asm-x86_64/pgalloc.h grsecurity226/include/asm-x86_64/pgalloc.h
--- linux-2.6.13.1.org/include/asm-x86_64/pgalloc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-x86_64/pgalloc.h	2005-08-30 01:14:55.000000000 +0200
@@ -7,7 +7,7 @@
 #include <linux/mm.h>
 
 #define pmd_populate_kernel(mm, pmd, pte) \
-		set_pmd(pmd, __pmd(_PAGE_TABLE | __pa(pte)))
+		set_pmd(pmd, __pmd(_KERNPG_TABLE | __pa(pte)))
 #define pud_populate(mm, pud, pmd) \
 		set_pud(pud, __pud(_PAGE_TABLE | __pa(pmd)))
 #define pgd_populate(mm, pgd, pud) \
diff -Nur linux-2.6.13.1.org/include/asm-x86_64/pgtable.h grsecurity226/include/asm-x86_64/pgtable.h
--- linux-2.6.13.1.org/include/asm-x86_64/pgtable.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-x86_64/pgtable.h	2005-09-05 18:42:10.000000000 +0200
@@ -162,6 +162,10 @@
 #define PAGE_COPY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
 #define PAGE_READONLY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+
+#define PAGE_READONLY_NOEXEC PAGE_READONLY
+#define PAGE_SHARED_NOEXEC PAGE_SHARED
+
 #define __PAGE_KERNEL \
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_NX)
 #define __PAGE_KERNEL_EXEC \
@@ -249,7 +253,13 @@
  */
 static inline int pte_user(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
 extern inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+extern inline int pte_exec(pte_t pte)
+{
+	if (__supported_pte_mask & _PAGE_NX)
+		return pte_val(pte) & _PAGE_NX;
+	else
+		return pte_val(pte) & _PAGE_USER;
+}
 extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
 extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
 extern inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
@@ -257,12 +267,26 @@
 
 #define __LARGE_PTE (_PAGE_PSE|_PAGE_PRESENT)
 extern inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+extern inline pte_t pte_exprotect(pte_t pte)
+{
+	if (__supported_pte_mask & _PAGE_NX)
+		set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_NX));
+	else
+		set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER));
+	return pte;
+}
 extern inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
 extern inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
 extern inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
 extern inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+extern inline pte_t pte_mkexec(pte_t pte)
+{
+	if (__supported_pte_mask & _PAGE_NX)
+		set_pte(&pte, __pte(pte_val(pte) | _PAGE_NX));
+	else
+		set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER));
+	return pte;
+}
 extern inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
 extern inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
 extern inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
diff -Nur linux-2.6.13.1.org/include/asm-xtensa/xtensa/config-linux_be/specreg.h grsecurity226/include/asm-xtensa/xtensa/config-linux_be/specreg.h
--- linux-2.6.13.1.org/include/asm-xtensa/xtensa/config-linux_be/specreg.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/asm-xtensa/xtensa/config-linux_be/specreg.h	2005-08-30 01:00:56.000000000 +0200
@@ -2,7 +2,7 @@
  * Xtensa Special Register symbolic names
  */
 
-/* $Id$ */
+/* $Id$ */
 
 /*
  * Copyright (c) 2003 Tensilica, Inc.  All Rights Reserved.
diff -Nur linux-2.6.13.1.org/include/linux/a.out.h grsecurity226/include/linux/a.out.h
--- linux-2.6.13.1.org/include/linux/a.out.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/a.out.h	2005-08-30 01:14:57.000000000 +0200
@@ -7,6 +7,16 @@
 
 #include <asm/a.out.h>
 
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __DELTA_STACK (current->mm->delta_stack)
+#else
+#define __DELTA_STACK 0UL
+#endif
+
+#ifndef STACK_TOP
+#define STACK_TOP	(__STACK_TOP - __DELTA_STACK)
+#endif
+
 #endif /* __STRUCT_EXEC_OVERRIDE__ */
 
 /* these go in the N_MACHTYPE field */
@@ -37,6 +47,14 @@
   M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
 };
 
+/* Constants for the N_FLAGS field */
+#define F_PAX_PAGEEXEC	1	/* Paging based non-executable pages */
+#define F_PAX_EMUTRAMP	2	/* Emulate trampolines */
+#define F_PAX_MPROTECT	4	/* Restrict mprotect() */
+#define F_PAX_RANDMMAP	8	/* Randomize mmap() base */
+/*#define F_PAX_RANDEXEC	16*/	/* Randomize ET_EXEC base */
+#define F_PAX_SEGMEXEC	32	/* Segmentation based non-executable pages */
+
 #if !defined (N_MAGIC)
 #define N_MAGIC(exec) ((exec).a_info & 0xffff)
 #endif
diff -Nur linux-2.6.13.1.org/include/linux/b1lli.h grsecurity226/include/linux/b1lli.h
--- linux-2.6.13.1.org/include/linux/b1lli.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/b1lli.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * ISDN lowlevel-module for AVM B1-card.
  *
diff -Nur linux-2.6.13.1.org/include/linux/b1pcmcia.h grsecurity226/include/linux/b1pcmcia.h
--- linux-2.6.13.1.org/include/linux/b1pcmcia.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/b1pcmcia.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Exported functions of module b1pcmcia to be called by
  * avm_cs card services module.
diff -Nur linux-2.6.13.1.org/include/linux/binfmts.h grsecurity226/include/linux/binfmts.h
--- linux-2.6.13.1.org/include/linux/binfmts.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/binfmts.h	2005-08-30 01:14:57.000000000 +0200
@@ -38,6 +38,7 @@
 	unsigned interp_flags;
 	unsigned interp_data;
 	unsigned long loader, exec;
+	int misc;
 };
 
 #define BINPRM_FLAGS_ENFORCE_NONDUMP_BIT 0
@@ -87,5 +88,8 @@
 extern int do_coredump(long signr, int exit_code, struct pt_regs * regs);
 extern int set_binfmt(struct linux_binfmt *new);
 
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp);
+void pax_report_insns(void *pc, void *sp);
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_BINFMTS_H */
diff -Nur linux-2.6.13.1.org/include/linux/capi.h grsecurity226/include/linux/capi.h
--- linux-2.6.13.1.org/include/linux/capi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/capi.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * CAPI 2.0 Interface for Linux
  * 
diff -Nur linux-2.6.13.1.org/include/linux/cobalt-nvram.h grsecurity226/include/linux/cobalt-nvram.h
--- linux-2.6.13.1.org/include/linux/cobalt-nvram.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/cobalt-nvram.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  * cobalt-nvram.h : defines for the various fields in the cobalt NVRAM
  *
  * Copyright 2001,2002 Sun Microsystems, Inc.
diff -Nur linux-2.6.13.1.org/include/linux/concap.h grsecurity226/include/linux/concap.h
--- linux-2.6.13.1.org/include/linux/concap.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/concap.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Copyright 1997 by Henner Eisen <eis@baty.hanse.de>
  *
diff -Nur linux-2.6.13.1.org/include/linux/cpufreq.h grsecurity226/include/linux/cpufreq.h
--- linux-2.6.13.1.org/include/linux/cpufreq.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/cpufreq.h	2005-08-30 01:00:56.000000000 +0200
@@ -5,7 +5,7 @@
  *            (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
  *            
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/include/linux/cyclades.h grsecurity226/include/linux/cyclades.h
--- linux-2.6.13.1.org/include/linux/cyclades.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/cyclades.h	2005-08-30 01:00:56.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Revision$$Date$
+/* $Revision$$Date$
  * linux/include/linux/cyclades.h
  *
  * This file was initially written by
@@ -7,6 +7,9 @@
  *
  * This file contains the general definitions for the cyclades.c driver
  *$Log$
+ *Revision 1.1.1.1  2005/08/29 23:00:56  spender
+ *Initial import of Linux 2.6.13
+ *
  *Revision 3.1  2002/01/29 11:36:16  henrique
  *added throttle field on struct cyclades_port to indicate whether the
  *port is throttled or not
diff -Nur linux-2.6.13.1.org/include/linux/elf.h grsecurity226/include/linux/elf.h
--- linux-2.6.13.1.org/include/linux/elf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/elf.h	2005-08-30 01:14:57.000000000 +0200
@@ -4,6 +4,10 @@
 #include <linux/types.h>
 #include <asm/elf.h>
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+#undef elf_read_implies_exec
+#endif
+
 #ifndef elf_read_implies_exec
   /* Executables for which elf_read_implies_exec() returns TRUE will
      have the READ_IMPLIES_EXEC personality flag set automatically.
@@ -45,6 +49,16 @@
 
 #define PT_GNU_STACK	(PT_LOOS + 0x474e551)
 
+#define PT_PAX_FLAGS	(PT_LOOS + 0x5041580)
+
+/* Constants for the e_flags field */
+#define EF_PAX_PAGEEXEC		1	/* Paging based non-executable pages */
+#define EF_PAX_EMUTRAMP		2	/* Emulate trampolines */
+#define EF_PAX_MPROTECT		4	/* Restrict mprotect() */
+#define EF_PAX_RANDMMAP		8	/* Randomize mmap() base */
+/*#define EF_PAX_RANDEXEC		16*/	/* Randomize ET_EXEC base */
+#define EF_PAX_SEGMEXEC		32	/* Segmentation based non-executable pages */
+
 /* These constants define the different elf file types */
 #define ET_NONE   0
 #define ET_REL    1
@@ -137,6 +151,8 @@
 #define DT_DEBUG	21
 #define DT_TEXTREL	22
 #define DT_JMPREL	23
+#define DT_FLAGS	30
+  #define DF_TEXTREL	0x00000004
 #define DT_LOPROC	0x70000000
 #define DT_HIPROC	0x7fffffff
 
@@ -287,6 +303,19 @@
 #define PF_W		0x2
 #define PF_X		0x1
 
+#define PF_PAGEEXEC	(1U << 4)	/* Enable  PAGEEXEC */
+#define PF_NOPAGEEXEC	(1U << 5)	/* Disable PAGEEXEC */
+#define PF_SEGMEXEC	(1U << 6)	/* Enable  SEGMEXEC */
+#define PF_NOSEGMEXEC	(1U << 7)	/* Disable SEGMEXEC */
+#define PF_MPROTECT	(1U << 8)	/* Enable  MPROTECT */
+#define PF_NOMPROTECT	(1U << 9)	/* Disable MPROTECT */
+/*#define PF_RANDEXEC	(1U << 10)*/	/* Enable  RANDEXEC */
+/*#define PF_NORANDEXEC	(1U << 11)*/	/* Disable RANDEXEC */
+#define PF_EMUTRAMP	(1U << 12)	/* Enable  EMUTRAMP */
+#define PF_NOEMUTRAMP	(1U << 13)	/* Disable EMUTRAMP */
+#define PF_RANDMMAP	(1U << 14)	/* Enable  RANDMMAP */
+#define PF_NORANDMMAP	(1U << 15)	/* Disable RANDMMAP */
+
 typedef struct elf32_phdr{
   Elf32_Word	p_type;
   Elf32_Off	p_offset;
@@ -379,6 +408,8 @@
 #define	EI_OSABI	7
 #define	EI_PAD		8
 
+#define	EI_PAX		14
+
 #define	ELFMAG0		0x7f		/* EI_MAG */
 #define	ELFMAG1		'E'
 #define	ELFMAG2		'L'
@@ -435,6 +466,7 @@
 #define elfhdr		elf32_hdr
 #define elf_phdr	elf32_phdr
 #define elf_note	elf32_note
+#define elf_dyn		Elf32_Dyn
 
 #else
 
@@ -442,6 +474,7 @@
 #define elfhdr		elf64_hdr
 #define elf_phdr	elf64_phdr
 #define elf_note	elf64_note
+#define elf_dyn		Elf64_Dyn
 
 #endif
 
diff -Nur linux-2.6.13.1.org/include/linux/fs.h grsecurity226/include/linux/fs.h
--- linux-2.6.13.1.org/include/linux/fs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/fs.h	2005-08-30 01:14:57.000000000 +0200
@@ -1290,7 +1290,7 @@
 
 /* fs/open.c */
 
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, struct vfsmount *);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
 extern int filp_close(struct file *, fl_owner_t id);
diff -Nur linux-2.6.13.1.org/include/linux/ftape-header-segment.h grsecurity226/include/linux/ftape-header-segment.h
--- linux-2.6.13.1.org/include/linux/ftape-header-segment.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/ftape-header-segment.h	2005-08-30 01:00:57.000000000 +0200
@@ -19,9 +19,9 @@
  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
  *
- * $Source$
- * $Revision$
- * $Date$
+ * $Source$
+ * $Revision$
+ * $Date$
  *
  *      This file defines some offsets into the header segment of a
  *      floppy tape cartridge.  For use with the QIC-40/80/3010/3020
diff -Nur linux-2.6.13.1.org/include/linux/ftape-vendors.h grsecurity226/include/linux/ftape-vendors.h
--- linux-2.6.13.1.org/include/linux/ftape-vendors.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/ftape-vendors.h	2005-08-30 01:00:57.000000000 +0200
@@ -20,9 +20,9 @@
  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
  *
- * $Source$
- * $Revision$
- * $Date$
+ * $Source$
+ * $Revision$
+ * $Date$
  *
  *      This file contains the supported drive types with their
  *      QIC-117 spec. vendor code and drive dependent configuration
diff -Nur linux-2.6.13.1.org/include/linux/ftape.h grsecurity226/include/linux/ftape.h
--- linux-2.6.13.1.org/include/linux/ftape.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/ftape.h	2005-08-30 01:00:57.000000000 +0200
@@ -20,9 +20,9 @@
  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
  *
- * $Source$
- * $Revision$
- * $Date$
+ * $Source$
+ * $Revision$
+ * $Date$
  *
  *      This file contains global definitions, typedefs and macro's
  *      for the QIC-40/80/3010/3020 floppy-tape driver for Linux.
diff -Nur linux-2.6.13.1.org/include/linux/gracl.h grsecurity226/include/linux/gracl.h
--- linux-2.6.13.1.org/include/linux/gracl.h	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/include/linux/gracl.h	2005-09-06 03:20:26.000000000 +0200
@@ -0,0 +1,305 @@
+#ifndef GR_ACL_H
+#define GR_ACL_H
+
+#include <linux/grdefs.h>
+#include <linux/resource.h>
+#include <linux/dcache.h>
+#include <asm/resource.h>
+
+/* Major status information */
+
+#define GR_VERSION  "grsecurity 2.1.7"
+#define GRSECURITY_VERSION 0x217
+
+enum {
+
+	SHUTDOWN = 0,
+	ENABLE = 1,
+	SPROLE = 2,
+	RELOAD = 3,
+	SEGVMOD = 4,
+	STATUS = 5,
+	UNSPROLE = 6,
+	PASSSET = 7,
+	SPROLEPAM = 8
+};
+
+/* Password setup definitions
+ * kernel/grhash.c */
+enum {
+	GR_PW_LEN = 128,
+	GR_SALT_LEN = 16,
+	GR_SHA_LEN = 32,
+};
+
+enum {
+	GR_SPROLE_LEN = 64,
+};
+
+#define GR_NLIMITS (RLIMIT_LOCKS + 2)
+
+/* Begin Data Structures */
+
+struct sprole_pw {
+	unsigned char *rolename;
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];	/* 256-bit SHA hash of the password */
+};
+
+struct name_entry {
+	__u32 key;
+	ino_t inode;
+	dev_t device;
+	char *name;
+	__u16 len;
+	struct name_entry *prev;
+	struct name_entry *next;
+};
+
+struct acl_role_db {
+	struct acl_role_label **r_hash;
+	__u32 r_size;
+};
+
+struct name_db {
+	struct name_entry **n_hash;
+	__u32 n_size;
+};
+
+struct crash_uid {
+	uid_t uid;
+	unsigned long expires;
+};
+
+struct gr_hash_struct {
+	void **table;
+	void **nametable;
+	void *first;
+	__u32 table_size;
+	__u32 used_size;
+	int type;
+};
+
+/* Userspace Grsecurity ACL data structures */
+
+struct acl_subject_label {
+	char *filename;
+	ino_t inode;
+	dev_t device;
+	__u32 mode;
+	__u32 cap_mask;
+	__u32 cap_lower;
+
+	struct rlimit res[GR_NLIMITS];
+	__u16 resmask;
+
+	__u8 user_trans_type;
+	__u8 group_trans_type;
+	uid_t *user_transitions;
+	gid_t *group_transitions;
+	__u16 user_trans_num;
+	__u16 group_trans_num;
+
+	__u32 ip_proto[8];
+	__u32 ip_type;
+	struct acl_ip_label **ips;
+	__u32 ip_num;
+
+	__u32 crashes;
+	unsigned long expires;
+
+	struct acl_subject_label *parent_subject;
+	struct gr_hash_struct *hash;
+	struct acl_subject_label *prev;
+	struct acl_subject_label *next;
+
+	struct acl_object_label **obj_hash;
+	__u32 obj_hash_size;
+};
+
+struct role_allowed_ip {
+	__u32 addr;
+	__u32 netmask;
+
+	struct role_allowed_ip *prev;
+	struct role_allowed_ip *next;
+};
+
+struct role_transition {
+	char *rolename;
+
+	struct role_transition *prev;
+	struct role_transition *next;
+};
+
+struct acl_role_label {
+	char *rolename;
+	uid_t uidgid;
+	__u16 roletype;
+
+	__u16 auth_attempts;
+	unsigned long expires;
+
+	struct acl_subject_label *root_label;
+	struct gr_hash_struct *hash;
+
+	struct acl_role_label *prev;
+	struct acl_role_label *next;
+
+	struct role_transition *transitions;
+	struct role_allowed_ip *allowed_ips;
+	uid_t *domain_children;
+	__u16 domain_child_num;
+
+	struct acl_subject_label **subj_hash;
+	__u32 subj_hash_size;
+};
+
+struct user_acl_role_db {
+	struct acl_role_label **r_table;
+	__u32 num_pointers;		/* Number of allocations to track */
+	__u32 num_roles;		/* Number of roles */
+	__u32 num_domain_children;	/* Number of domain children */
+	__u32 num_subjects;		/* Number of subjects */
+	__u32 num_objects;		/* Number of objects */
+};
+
+struct acl_object_label {
+	char *filename;
+	ino_t inode;
+	dev_t device;
+	__u32 mode;
+
+	struct acl_subject_label *nested;
+	struct acl_object_label *globbed;
+
+	/* next two structures not used */
+
+	struct acl_object_label *prev;
+	struct acl_object_label *next;
+};
+
+struct acl_ip_label {
+	__u32 addr;
+	__u32 netmask;
+	__u16 low, high;
+	__u8 mode;
+	__u32 type;
+	__u32 proto[8];
+
+	/* next two structures not used */
+
+	struct acl_ip_label *prev;
+	struct acl_ip_label *next;
+};
+
+struct gr_arg {
+	struct user_acl_role_db role_db;
+	unsigned char pw[GR_PW_LEN];
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];
+	unsigned char sp_role[GR_SPROLE_LEN];
+	struct sprole_pw *sprole_pws;
+	dev_t segv_device;
+	ino_t segv_inode;
+	uid_t segv_uid;
+	__u16 num_sprole_pws;
+	__u16 mode;
+};
+
+struct gr_arg_wrapper {
+	struct gr_arg *arg;
+	__u32 version;
+	__u32 size;
+};
+
+struct subject_map {
+	struct acl_subject_label *user;
+	struct acl_subject_label *kernel;
+	struct subject_map *prev;
+	struct subject_map *next;
+};
+
+struct acl_subj_map_db {
+	struct subject_map **s_hash;
+	__u32 s_size;
+};
+
+/* End Data Structures Section */
+
+/* Hash functions generated by empirical testing by Brad Spengler
+   Makes good use of the low bits of the inode.  Generally 0-1 times
+   in loop for successful match.  0-3 for unsuccessful match.
+   Shift/add algorithm with modulus of table size and an XOR*/
+
+static __inline__ unsigned int
+rhash(const uid_t uid, const __u16 type, const unsigned int sz)
+{
+	return (((uid << type) + (uid ^ type)) % sz);
+}
+
+ static __inline__ unsigned int
+shash(const struct acl_subject_label *userp, const unsigned int sz)
+{
+	return ((const unsigned long)userp % sz);
+}
+
+static __inline__ unsigned int
+fhash(const ino_t ino, const dev_t dev, const unsigned int sz)
+{
+	return (((ino + dev) ^ ((ino << 13) + (ino << 23) + (dev << 9))) % sz);
+}
+
+static __inline__ unsigned int
+nhash(const char *name, const __u16 len, const unsigned int sz)
+{
+	return full_name_hash(name, len) % sz;
+}
+
+#define FOR_EACH_ROLE_START(role,iter) \
+	role = NULL; \
+	iter = 0; \
+	while (iter < acl_role_set.r_size) { \
+		if (role != NULL) { \
+			role = role->next; \
+			continue; \
+		} \
+		role = acl_role_set.r_hash[iter]; \
+		if (role == NULL) { \
+			iter++; \
+			continue; \
+		}
+
+#define FOR_EACH_ROLE_END(iter) \
+		iter++; \
+	}
+
+#define FOR_EACH_SUBJECT_START(role,subj,iter) \
+	subj = NULL; \
+	iter = 0; \
+	while (iter < role->subj_hash_size) { \
+		if (subj != NULL) { \
+			subj = subj->next; \
+			continue; \
+		} \
+		subj = role->subj_hash[iter]; \
+		if (subj == NULL) { \
+			iter++; \
+			continue; \
+		}
+
+#define FOR_EACH_SUBJECT_END(iter) \
+		iter++; \
+	}
+
+
+#define FOR_EACH_NESTED_SUBJECT_START(role,subj) \
+	subj = role->hash->first; \
+	while (subj != NULL) {
+
+#define FOR_EACH_NESTED_SUBJECT_END(subj) \
+		subj = subj->next; \
+	}
+
+#endif
+
diff -Nur linux-2.6.13.1.org/include/linux/gralloc.h grsecurity226/include/linux/gralloc.h
--- linux-2.6.13.1.org/include/linux/gralloc.h	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/include/linux/gralloc.h	2005-08-30 01:14:58.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __GRALLOC_H
+#define __GRALLOC_H
+
+void acl_free_all(void);
+int acl_alloc_stack_init(unsigned long size);
+void *acl_alloc(unsigned long len);
+
+#endif
diff -Nur linux-2.6.13.1.org/include/linux/grdefs.h grsecurity226/include/linux/grdefs.h
--- linux-2.6.13.1.org/include/linux/grdefs.h	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/include/linux/grdefs.h	2005-08-30 01:14:58.000000000 +0200
@@ -0,0 +1,123 @@
+#ifndef GRDEFS_H
+#define GRDEFS_H
+
+/* Begin grsecurity status declarations */
+
+enum {
+	GR_READY = 0x01,
+	GR_STATUS_INIT = 0x00	// disabled state
+};
+
+/* Begin  ACL declarations */
+
+/* Role flags */
+
+enum {
+	GR_ROLE_USER = 0x0001,
+	GR_ROLE_GROUP = 0x0002,
+	GR_ROLE_DEFAULT = 0x0004,
+	GR_ROLE_SPECIAL = 0x0008,
+	GR_ROLE_AUTH = 0x0010,
+	GR_ROLE_NOPW = 0x0020,
+	GR_ROLE_GOD = 0x0040,
+	GR_ROLE_LEARN = 0x0080,
+	GR_ROLE_TPE = 0x0100,
+	GR_ROLE_DOMAIN = 0x0200,
+	GR_ROLE_PAM = 0x0400
+};
+
+/* ACL Subject and Object mode flags */
+enum {
+	GR_DELETED = 0x80000000
+};
+
+/* ACL Object-only mode flags */
+enum {
+	GR_READ 	= 0x00000001,
+	GR_APPEND 	= 0x00000002,
+	GR_WRITE 	= 0x00000004,
+	GR_EXEC 	= 0x00000008,
+	GR_FIND 	= 0x00000010,
+	GR_INHERIT 	= 0x00000020,
+	GR_SETID 	= 0x00000040,
+	GR_CREATE 	= 0x00000080,
+	GR_DELETE 	= 0x00000100,
+	GR_LINK		= 0x00000200,
+	GR_AUDIT_READ 	= 0x00000400,
+	GR_AUDIT_APPEND = 0x00000800,
+	GR_AUDIT_WRITE 	= 0x00001000,
+	GR_AUDIT_EXEC 	= 0x00002000,
+	GR_AUDIT_FIND 	= 0x00004000,
+	GR_AUDIT_INHERIT= 0x00008000,
+	GR_AUDIT_SETID 	= 0x00010000,
+	GR_AUDIT_CREATE = 0x00020000,
+	GR_AUDIT_DELETE = 0x00040000,
+	GR_AUDIT_LINK	= 0x00080000,
+	GR_PTRACERD 	= 0x00100000,
+	GR_NOPTRACE	= 0x00200000,
+	GR_SUPPRESS 	= 0x00400000,
+	GR_NOLEARN 	= 0x00800000
+};
+
+#define GR_AUDITS (GR_AUDIT_READ | GR_AUDIT_WRITE | GR_AUDIT_APPEND | GR_AUDIT_EXEC | \
+		   GR_AUDIT_FIND | GR_AUDIT_INHERIT | GR_AUDIT_SETID | \
+		   GR_AUDIT_CREATE | GR_AUDIT_DELETE | GR_AUDIT_LINK)
+
+/* ACL subject-only mode flags */
+enum {
+	GR_KILL 	= 0x00000001,
+	GR_VIEW 	= 0x00000002,
+	GR_PROTECTED 	= 0x00000004,
+	GR_LEARN 	= 0x00000008,
+	GR_OVERRIDE 	= 0x00000010,
+	/* just a placeholder, this mode is only used in userspace */
+	GR_DUMMY 	= 0x00000020,
+	GR_PAXPAGE 	= 0x00000040,
+	GR_PAXSEGM 	= 0x00000080,
+	GR_PAXGCC 	= 0x00000100,
+	GR_PAXRANDMMAP 	= 0x00000200,
+	GR_PAXMPROTECT 	= 0x00000400,
+	GR_PROTSHM 	= 0x00000800,
+	GR_KILLPROC 	= 0x00001000,
+	GR_KILLIPPROC	= 0x00002000,
+	/* just a placeholder, this mode is only used in userspace */
+	GR_NOTROJAN 	= 0x00004000,
+	GR_PROTPROCFD 	= 0x00008000,
+	GR_PROCACCT 	= 0x00010000,
+	GR_RELAXPTRACE	= 0x00020000,
+	GR_NESTED	= 0x00040000,
+	GR_INHERITLEARN = 0x00080000,
+	GR_PROCFIND	= 0x00100000,
+	GR_POVERRIDE	= 0x00200000,
+	GR_KERNELAUTH	= 0x00400000
+};
+
+enum {
+	GR_ID_USER	= 0x01,
+	GR_ID_GROUP	= 0x02,
+};
+
+enum {
+	GR_ID_ALLOW	= 0x01,
+	GR_ID_DENY	= 0x02,
+};
+
+#define GR_CRASH_RES	11
+#define GR_UIDTABLE_MAX 500
+
+/* begin resource learning section */
+enum {
+	GR_RLIM_CPU_BUMP = 60,
+	GR_RLIM_FSIZE_BUMP = 50000,
+	GR_RLIM_DATA_BUMP = 10000,
+	GR_RLIM_STACK_BUMP = 1000,
+	GR_RLIM_CORE_BUMP = 10000,
+	GR_RLIM_RSS_BUMP = 500000,
+	GR_RLIM_NPROC_BUMP = 1,
+	GR_RLIM_NOFILE_BUMP = 5,
+	GR_RLIM_MEMLOCK_BUMP = 50000,
+	GR_RLIM_AS_BUMP = 500000,
+	GR_RLIM_LOCKS_BUMP = 2
+};
+
+#endif
diff -Nur linux-2.6.13.1.org/include/linux/grinternal.h grsecurity226/include/linux/grinternal.h
--- linux-2.6.13.1.org/include/linux/grinternal.h	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/include/linux/grinternal.h	2005-08-30 01:14:58.000000000 +0200
@@ -0,0 +1,210 @@
+#ifndef __GRINTERNAL_H
+#define __GRINTERNAL_H
+
+#ifdef CONFIG_GRKERNSEC
+
+#include <linux/fs.h>
+#include <linux/gracl.h>
+#include <linux/grdefs.h>
+#include <linux/grmsg.h>
+
+extern void gr_add_learn_entry(const char *fmt, ...);
+extern __u32 gr_search_file(const struct dentry *dentry, const __u32 mode,
+			    const struct vfsmount *mnt);
+extern __u32 gr_check_create(const struct dentry *new_dentry,
+			     const struct dentry *parent,
+			     const struct vfsmount *mnt, const __u32 mode);
+extern int gr_check_protected_task(const struct task_struct *task);
+extern __u32 to_gr_audit(const __u32 reqmode);
+extern int gr_set_acls(const int type);
+
+extern int gr_acl_is_enabled(void);
+extern char gr_roletype_to_char(void);
+
+extern void gr_handle_alertkill(struct task_struct *task);
+extern char *gr_to_filename(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+extern char *gr_to_filename1(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+extern char *gr_to_filename2(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+extern char *gr_to_filename3(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+
+extern int grsec_enable_link;
+extern int grsec_enable_fifo;
+extern int grsec_enable_execve;
+extern int grsec_enable_shm;
+extern int grsec_enable_execlog;
+extern int grsec_enable_signal;
+extern int grsec_enable_forkfail;
+extern int grsec_enable_time;
+extern int grsec_enable_chroot_shmat;
+extern int grsec_enable_chroot_findtask;
+extern int grsec_enable_chroot_mount;
+extern int grsec_enable_chroot_double;
+extern int grsec_enable_chroot_pivot;
+extern int grsec_enable_chroot_chdir;
+extern int grsec_enable_chroot_chmod;
+extern int grsec_enable_chroot_mknod;
+extern int grsec_enable_chroot_fchdir;
+extern int grsec_enable_chroot_nice;
+extern int grsec_enable_chroot_execlog;
+extern int grsec_enable_chroot_caps;
+extern int grsec_enable_chroot_sysctl;
+extern int grsec_enable_chroot_unix;
+extern int grsec_enable_tpe;
+extern int grsec_tpe_gid;
+extern int grsec_enable_tpe_all;
+extern int grsec_enable_sidcaps;
+extern int grsec_enable_randpid;
+extern int grsec_enable_socket_all;
+extern int grsec_socket_all_gid;
+extern int grsec_enable_socket_client;
+extern int grsec_socket_client_gid;
+extern int grsec_enable_socket_server;
+extern int grsec_socket_server_gid;
+extern int grsec_audit_gid;
+extern int grsec_enable_group;
+extern int grsec_enable_audit_ipc;
+extern int grsec_enable_audit_textrel;
+extern int grsec_enable_mount;
+extern int grsec_enable_chdir;
+extern int grsec_lock;
+
+extern struct task_struct *child_reaper;
+
+extern spinlock_t grsec_alert_lock;
+extern unsigned long grsec_alert_wtime;
+extern unsigned long grsec_alert_fyet;
+
+extern spinlock_t grsec_audit_lock;
+
+extern rwlock_t grsec_exec_file_lock;
+
+#define gr_task_fullpath(tsk) (tsk->exec_file ? \
+			gr_to_filename2(tsk->exec_file->f_dentry, \
+			tsk->exec_file->f_vfsmnt) : "/")
+
+#define gr_parent_task_fullpath(tsk) (tsk->parent->exec_file ? \
+			gr_to_filename3(tsk->parent->exec_file->f_dentry, \
+			tsk->parent->exec_file->f_vfsmnt) : "/")
+
+#define gr_task_fullpath0(tsk) (tsk->exec_file ? \
+			gr_to_filename(tsk->exec_file->f_dentry, \
+			tsk->exec_file->f_vfsmnt) : "/")
+
+#define gr_parent_task_fullpath0(tsk) (tsk->parent->exec_file ? \
+			gr_to_filename1(tsk->parent->exec_file->f_dentry, \
+			tsk->parent->exec_file->f_vfsmnt) : "/")
+
+#define proc_is_chrooted(tsk_a)  ((tsk_a->pid > 1) && (tsk_a->fs != NULL) && \
+			  ((tsk_a->fs->root->d_inode->i_sb->s_dev != \
+			  child_reaper->fs->root->d_inode->i_sb->s_dev) || \
+			  (tsk_a->fs->root->d_inode->i_ino != \
+			  child_reaper->fs->root->d_inode->i_ino)))
+
+#define have_same_root(tsk_a,tsk_b) ((tsk_a->fs != NULL) && (tsk_b->fs != NULL) && \
+			  (tsk_a->fs->root->d_inode->i_sb->s_dev == \
+			  tsk_b->fs->root->d_inode->i_sb->s_dev) && \
+			  (tsk_a->fs->root->d_inode->i_ino == \
+			  tsk_b->fs->root->d_inode->i_ino))
+
+#define DEFAULTSECARGS(task) gr_task_fullpath(task), task->comm, \
+		       task->pid, task->uid, \
+		       task->euid, task->gid, task->egid, \
+		       gr_parent_task_fullpath(task), \
+		       task->parent->comm, task->parent->pid, \
+		       task->parent->uid, task->parent->euid, \
+		       task->parent->gid, task->parent->egid
+
+#define GR_CHROOT_CAPS ( \
+	CAP_TO_MASK(CAP_LINUX_IMMUTABLE) | CAP_TO_MASK(CAP_NET_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_MODULE) | CAP_TO_MASK(CAP_SYS_RAWIO) | \
+	CAP_TO_MASK(CAP_SYS_PACCT) | CAP_TO_MASK(CAP_SYS_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_BOOT) | CAP_TO_MASK(CAP_SYS_TIME) | \
+	CAP_TO_MASK(CAP_NET_RAW) | CAP_TO_MASK(CAP_SYS_TTY_CONFIG) | \
+	CAP_TO_MASK(CAP_IPC_OWNER))
+
+#define security_learn(normal_msg,args...) \
+({ \
+	read_lock(&grsec_exec_file_lock); \
+	gr_add_learn_entry(normal_msg "\n", ## args); \
+	read_unlock(&grsec_exec_file_lock); \
+})
+
+enum {
+	GR_DO_AUDIT,
+	GR_DONT_AUDIT,
+	GR_DONT_AUDIT_GOOD
+};
+
+enum {
+	GR_TTYSNIFF,
+	GR_RBAC,
+	GR_RBAC_STR,
+	GR_STR_RBAC,
+	GR_RBAC_MODE2,
+	GR_RBAC_MODE3,
+	GR_FILENAME,
+	GR_NOARGS,
+	GR_ONE_INT,
+	GR_ONE_INT_TWO_STR,
+	GR_ONE_STR,
+	GR_STR_INT,
+	GR_TWO_INT,
+	GR_THREE_INT,
+	GR_FIVE_INT_TWO_STR,
+	GR_TWO_STR,
+	GR_THREE_STR,
+	GR_FOUR_STR,
+	GR_STR_FILENAME,
+	GR_FILENAME_STR,
+	GR_FILENAME_TWO_INT,
+	GR_FILENAME_TWO_INT_STR,
+	GR_TEXTREL,
+	GR_PTRACE,
+	GR_RESOURCE,
+	GR_CAP,
+	GR_SIG,
+	GR_CRASH1,
+	GR_CRASH2,
+	GR_PSACCT
+};
+
+#define gr_log_ttysniff(audit, msg, task) gr_log_varargs(audit, msg, GR_TTYSNIFF, task)
+#define gr_log_fs_rbac_generic(audit, msg, dentry, mnt) gr_log_varargs(audit, msg, GR_RBAC, dentry, mnt)
+#define gr_log_fs_rbac_str(audit, msg, dentry, mnt, str) gr_log_varargs(audit, msg, GR_RBAC_STR, dentry, mnt, str)
+#define gr_log_fs_str_rbac(audit, msg, str, dentry, mnt) gr_log_varargs(audit, msg, GR_STR_RBAC, str, dentry, mnt)
+#define gr_log_fs_rbac_mode2(audit, msg, dentry, mnt, str1, str2) gr_log_varargs(audit, msg, GR_RBAC_MODE2, dentry, mnt, str1, str2)
+#define gr_log_fs_rbac_mode3(audit, msg, dentry, mnt, str1, str2, str3) gr_log_varargs(audit, msg, GR_RBAC_MODE3, dentry, mnt, str1, str2, str3)
+#define gr_log_fs_generic(audit, msg, dentry, mnt) gr_log_varargs(audit, msg, GR_FILENAME, dentry, mnt)
+#define gr_log_noargs(audit, msg) gr_log_varargs(audit, msg, GR_NOARGS)
+#define gr_log_int(audit, msg, num) gr_log_varargs(audit, msg, GR_ONE_INT, num)
+#define gr_log_int_str2(audit, msg, num, str1, str2) gr_log_varargs(audit, msg, GR_ONE_INT_TWO_STR, num, str1, str2)
+#define gr_log_str(audit, msg, str) gr_log_varargs(audit, msg, GR_ONE_STR, str)
+#define gr_log_str_int(audit, msg, str, num) gr_log_varargs(audit, msg, GR_STR_INT, str, num)
+#define gr_log_int_int(audit, msg, num1, num2) gr_log_varargs(audit, msg, GR_TWO_INT, num1, num2)
+#define gr_log_int3(audit, msg, num1, num2, num3) gr_log_varargs(audit, msg, GR_THREE_INT, num1, num2, num3)
+#define gr_log_int5_str2(audit, msg, num1, num2, str1, str2) gr_log_varargs(audit, msg, GR_FIVE_INT_TWO_STR, num1, num2, str1, str2)
+#define gr_log_str_str(audit, msg, str1, str2) gr_log_varargs(audit, msg, GR_TWO_STR, str1, str2)
+#define gr_log_str3(audit, msg, str1, str2, str3) gr_log_varargs(audit, msg, GR_THREE_STR, str1, str2, str3)
+#define gr_log_str4(audit, msg, str1, str2, str3, str4) gr_log_varargs(audit, msg, GR_FOUR_STR, str1, str2, str3, str4)
+#define gr_log_str_fs(audit, msg, str, dentry, mnt) gr_log_varargs(audit, msg, GR_STR_FILENAME, str, dentry, mnt)
+#define gr_log_fs_str(audit, msg, dentry, mnt, str) gr_log_varargs(audit, msg, GR_FILENAME_STR, dentry, mnt, str)
+#define gr_log_fs_int2(audit, msg, dentry, mnt, num1, num2) gr_log_varargs(audit, msg, GR_FILENAME_TWO_INT, dentry, mnt, num1, num2)
+#define gr_log_fs_int2_str(audit, msg, dentry, mnt, num1, num2, str) gr_log_varargs(audit, msg, GR_FILENAME_TWO_INT_STR, dentry, mnt, num1, num2, str)
+#define gr_log_textrel_ulong_ulong(audit, msg, file, ulong1, ulong2) gr_log_varargs(audit, msg, GR_TEXTREL, file, ulong1, ulong2)
+#define gr_log_ptrace(audit, msg, task) gr_log_varargs(audit, msg, GR_PTRACE, task)
+#define gr_log_res_ulong2_str(audit, msg, task, ulong1, str, ulong2) gr_log_varargs(audit, msg, GR_RESOURCE, task, ulong1, str, ulong2)
+#define gr_log_cap(audit, msg, task, str) gr_log_varargs(audit, msg, GR_CAP, task, str)
+#define gr_log_sig(audit, msg, task, num) gr_log_varargs(audit, msg, GR_SIG, task, num)
+#define gr_log_crash1(audit, msg, task, ulong) gr_log_varargs(audit, msg, GR_CRASH1, task, ulong)
+#define gr_log_crash2(audit, msg, task, ulong1) gr_log_varargs(audit, msg, GR_CRASH2, task, ulong1)
+#define gr_log_procacct(audit, msg, task, num1, num2, num3, num4, num5, num6, num7, num8, num9) gr_log_varargs(audit, msg, GR_PSACCT, task, num1, num2, num3, num4, num5, num6, num7, num8, num9)
+
+extern void gr_log_varargs(int audit, const char *msg, int argtypes, ...);
+
+#endif
+
+#endif
diff -Nur linux-2.6.13.1.org/include/linux/grmsg.h grsecurity226/include/linux/grmsg.h
--- linux-2.6.13.1.org/include/linux/grmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/include/linux/grmsg.h	2005-08-30 01:14:58.000000000 +0200
@@ -0,0 +1,107 @@
+#define DEFAULTSECMSG "%.256s[%.16s:%d] uid/euid:%u/%u gid/egid:%u/%u, parent %.256s[%.16s:%d] uid/euid:%u/%u gid/egid:%u/%u"
+#define GR_ACL_PROCACCT_MSG "%.256s[%.16s:%d] IP:%u.%u.%u.%u TTY:%.64s uid/euid:%u/%u gid/egid:%u/%u run time:[%ud %uh %um %us] cpu time:[%ud %uh %um %us] %s with exit code %ld, parent %.256s[%.16s:%d] IP:%u.%u.%u.%u TTY:%.64s uid/euid:%u/%u gid/egid:%u/%u"
+#define GR_PTRACE_ACL_MSG "denied ptrace of %.950s(%.16s:%d) by "
+#define GR_IOPERM_MSG "denied use of ioperm() by "
+#define GR_IOPL_MSG "denied use of iopl() by "
+#define GR_SHMAT_ACL_MSG "denied attach of shared memory of UID %u, PID %d, ID %u by "
+#define GR_UNIX_CHROOT_MSG "denied connect() to abstract AF_UNIX socket outside of chroot by "
+#define GR_SHMAT_CHROOT_MSG "denied attach of shared memory outside of chroot by "
+#define GR_KMEM_MSG "denied write of /dev/kmem by "
+#define GR_PORT_OPEN_MSG "denied open of /dev/port by "
+#define GR_MEM_WRITE_MSG "denied write of /dev/mem by "
+#define GR_MEM_MMAP_MSG "denied mmap write of /dev/[k]mem by "
+#define GR_SYMLINK_MSG "not following symlink %.950s owned by %d.%d by "
+#define GR_LEARN_AUDIT_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%lu\t%lu\t%.4095s\t%lu\t%u.%u.%u.%u"
+#define GR_ID_LEARN_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%c\t%d\t%d\t%d\t%u.%u.%u.%u"
+#define GR_HIDDEN_ACL_MSG "%s access to hidden file %.950s by "
+#define GR_OPEN_ACL_MSG "%s open of %.950s for%s%s by "
+#define GR_CREATE_ACL_MSG "%s create of %.950s for%s%s by "
+#define GR_FIFO_MSG "denied writing FIFO %.950s of %d.%d by "
+#define GR_MKNOD_CHROOT_MSG "denied mknod of %.950s from chroot by "
+#define GR_MKNOD_ACL_MSG "%s mknod of %.950s by "
+#define GR_UNIXCONNECT_ACL_MSG "%s connect() to the unix domain socket %.950s by "
+#define GR_TTYSNIFF_ACL_MSG "terminal being sniffed by IP:%u.%u.%u.%u %.480s[%.16s:%d], parent %.480s[%.16s:%d] against "
+#define GR_MKDIR_ACL_MSG "%s mkdir of %.950s by "
+#define GR_RMDIR_ACL_MSG "%s rmdir of %.950s by "
+#define GR_UNLINK_ACL_MSG "%s unlink of %.950s by "
+#define GR_SYMLINK_ACL_MSG "%s symlink from %.480s to %.480s by "
+#define GR_HARDLINK_MSG "denied hardlink of %.930s (owned by %d.%d) to %.30s for "
+#define GR_LINK_ACL_MSG "%s link of %.480s to %.480s by "
+#define GR_INHERIT_ACL_MSG "successful inherit of %.480s's ACL for %.480s by "
+#define GR_RENAME_ACL_MSG "%s rename of %.480s to %.480s by "
+#define GR_PTRACE_EXEC_ACL_MSG "denied ptrace of %.950s by "
+#define GR_NPROC_MSG "denied overstep of process limit by "
+#define GR_EXEC_ACL_MSG "%s execution of %.950s by "
+#define GR_EXEC_TPE_MSG "denied untrusted exec of %.950s by "
+#define GR_SEGVSTART_ACL_MSG "possible exploit bruteforcing on " DEFAULTSECMSG " banning uid %u from login for %lu seconds"
+#define GR_SEGVNOSUID_ACL_MSG "possible exploit bruteforcing on " DEFAULTSECMSG " banning execution for %lu seconds"
+#define GR_MOUNT_CHROOT_MSG "denied mount of %.30s as %.930s from chroot by "
+#define GR_PIVOT_CHROOT_MSG "denied pivot_root from chroot by "
+#define GR_TRUNCATE_ACL_MSG "%s truncate of %.950s by "
+#define GR_ATIME_ACL_MSG "%s access time change of %.950s by "
+#define GR_ACCESS_ACL_MSG "%s access of %.950s for%s%s%s by "
+#define GR_CHROOT_CHROOT_MSG "denied double chroot to %.950s by "
+#define GR_FCHMOD_ACL_MSG "%s fchmod of %.950s by "
+#define GR_CHMOD_CHROOT_MSG "denied chmod +s of %.950s by "
+#define GR_CHMOD_ACL_MSG "%s chmod of %.950s by "
+#define GR_CHROOT_FCHDIR_MSG "denied fchdir outside of chroot to %.950s by "
+#define GR_CHOWN_ACL_MSG "%s chown of %.950s by "
+#define GR_WRITLIB_ACL_MSG "denied load of writable library %.950s by "
+#define GR_INITF_ACL_MSG "init_variables() failed %s by "
+#define GR_DISABLED_ACL_MSG "Error loading %s, trying to run kernel with acls disabled. To disable acls at startup use <kernel image name> gracl=off from your boot loader"
+#define GR_DEV_ACL_MSG "/dev/grsec: %d bytes sent %d required, being fed garbaged by "
+#define GR_SHUTS_ACL_MSG "shutdown auth success for "
+#define GR_SHUTF_ACL_MSG "shutdown auth failure for "
+#define GR_SHUTI_ACL_MSG "ignoring shutdown for disabled RBAC system for "
+#define GR_SEGVMODS_ACL_MSG "segvmod auth success for "
+#define GR_SEGVMODF_ACL_MSG "segvmod auth failure for "
+#define GR_SEGVMODI_ACL_MSG "ignoring segvmod for disabled RBAC system for "
+#define GR_ENABLE_ACL_MSG "%s RBAC system loaded by "
+#define GR_ENABLEF_ACL_MSG "unable to load %s for "
+#define GR_RELOADI_ACL_MSG "ignoring reload request for disabled RBAC system"
+#define GR_RELOAD_ACL_MSG "%s RBAC system reloaded by "
+#define GR_RELOADF_ACL_MSG "failed reload of %s for "
+#define GR_SPROLEI_ACL_MSG "ignoring change to special role for disabled RBAC system for "
+#define GR_SPROLES_ACL_MSG "successful change to special role %s (id %d) by "
+#define GR_SPROLEL_ACL_MSG "special role %s (id %d) exited by "
+#define GR_SPROLEF_ACL_MSG "special role %s failure for "
+#define GR_UNSPROLEI_ACL_MSG "ignoring unauth of special role for disabled RBAC system for "
+#define GR_UNSPROLES_ACL_MSG "successful unauth of special role %s (id %d) by "
+#define GR_UNSPROLEF_ACL_MSG "special role unauth of %s failure for "
+#define GR_INVMODE_ACL_MSG "invalid mode %d by "
+#define GR_PRIORITY_CHROOT_MSG "denied priority change of process (%.16s:%d) by "
+#define GR_FAILFORK_MSG "failed fork with errno %d by "
+#define GR_NICE_CHROOT_MSG "denied priority change by "
+#define GR_UNISIGLOG_MSG "signal %d sent to "
+#define GR_DUALSIGLOG_MSG "signal %d sent to " DEFAULTSECMSG " by "
+#define GR_SIG_ACL_MSG "denied send of signal %d to protected task " DEFAULTSECMSG " by "
+#define GR_SYSCTL_MSG "denied modification of grsecurity sysctl value : %.32s by "
+#define GR_SYSCTL_ACL_MSG "%s sysctl of %.950s for%s%s by "
+#define GR_TIME_MSG "time set by "
+#define GR_DEFACL_MSG "fatal: unable to find subject for (%.16s:%d), loaded by "
+#define GR_MMAP_ACL_MSG "%s executable mmap of %.950s by "
+#define GR_MPROTECT_ACL_MSG "%s executable mprotect of %.950s by "
+#define GR_SOCK_MSG "denied socket(%.16s,%.16s,%.16s) by "
+#define GR_SOCK2_MSG "denied socket(%d,%.16s,%.16s) by "
+#define GR_BIND_MSG "denied bind() by "
+#define GR_CONNECT_MSG "denied connect() by "
+#define GR_BIND_ACL_MSG "denied bind() to %u.%u.%u.%u port %u sock type %.16s protocol %.16s by "
+#define GR_CONNECT_ACL_MSG "denied connect() to %u.%u.%u.%u port %u sock type %.16s protocol %.16s by "
+#define GR_IP_LEARN_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%u.%u.%u.%u\t%u\t%u\t%u\t%u\t%u.%u.%u.%u"
+#define GR_EXEC_CHROOT_MSG "exec of %.980s within chroot by process "
+#define GR_CAP_ACL_MSG "use of %s denied for "
+#define GR_USRCHANGE_ACL_MSG "change to uid %u denied for "
+#define GR_GRPCHANGE_ACL_MSG "change to gid %u denied for "
+#define GR_REMOUNT_AUDIT_MSG "remount of %.30s by "
+#define GR_UNMOUNT_AUDIT_MSG "unmount of %.30s by "
+#define GR_MOUNT_AUDIT_MSG "mount of %.30s to %.64s by "
+#define GR_CHDIR_AUDIT_MSG "chdir to %.980s by "
+#define GR_EXEC_AUDIT_MSG "exec of %.930s (%.128s) by "
+#define GR_MSGQ_AUDIT_MSG "message queue created by "
+#define GR_MSGQR_AUDIT_MSG "message queue of uid:%u euid:%u removed by "
+#define GR_SEM_AUDIT_MSG "semaphore created by "
+#define GR_SEMR_AUDIT_MSG "semaphore of uid:%u euid:%u removed by "
+#define GR_SHM_AUDIT_MSG "shared memory of size %d created by "
+#define GR_SHMR_AUDIT_MSG "shared memory of uid:%u euid:%u removed by "
+#define GR_RESOURCE_MSG "denied resource overstep by requesting %lu for %.16s against limit %lu for "
+#define GR_TEXTREL_AUDIT_MSG "text relocation in %s, VMA:0x%08lx 0x%08lx by "
diff -Nur linux-2.6.13.1.org/include/linux/grsecurity.h grsecurity226/include/linux/grsecurity.h
--- linux-2.6.13.1.org/include/linux/grsecurity.h	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/include/linux/grsecurity.h	2005-08-30 01:14:58.000000000 +0200
@@ -0,0 +1,196 @@
+#ifndef GR_SECURITY_H
+#define GR_SECURITY_H
+#include <linux/fs.h>
+#include <linux/binfmts.h>
+#include <linux/gracl.h>
+
+extern void gr_handle_brute_attach(struct task_struct *p);
+extern void gr_handle_brute_check(void);
+
+extern char gr_roletype_to_char(void);
+
+extern int gr_check_user_change(int real, int effective, int fs);
+extern int gr_check_group_change(int real, int effective, int fs);
+
+extern void gr_del_task_from_ip_table(struct task_struct *p);
+
+extern int gr_pid_is_chrooted(struct task_struct *p);
+extern int gr_handle_chroot_nice(void);
+extern int gr_handle_chroot_sysctl(const int op);
+extern int gr_handle_chroot_setpriority(struct task_struct *p,
+					const int niceval);
+extern int gr_chroot_fchdir(struct dentry *u_dentry, struct vfsmount *u_mnt);
+extern int gr_handle_chroot_chroot(const struct dentry *dentry,
+				   const struct vfsmount *mnt);
+extern void gr_handle_chroot_caps(struct task_struct *task);
+extern void gr_handle_chroot_chdir(struct dentry *dentry, struct vfsmount *mnt);
+extern int gr_handle_chroot_chmod(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int mode);
+extern int gr_handle_chroot_mknod(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int mode);
+extern int gr_handle_chroot_mount(const struct dentry *dentry,
+				  const struct vfsmount *mnt,
+				  const char *dev_name);
+extern int gr_handle_chroot_pivot(void);
+extern int gr_handle_chroot_unix(const pid_t pid);
+
+extern int gr_handle_rawio(const struct inode *inode);
+extern int gr_handle_nproc(void);
+
+extern void gr_handle_ioperm(void);
+extern void gr_handle_iopl(void);
+
+extern int gr_tpe_allow(const struct file *file);
+
+extern int gr_random_pid(void);
+
+extern void gr_log_forkfail(const int retval);
+extern void gr_log_timechange(void);
+extern void gr_log_signal(const int sig, const struct task_struct *t);
+extern void gr_log_chdir(const struct dentry *dentry,
+			 const struct vfsmount *mnt);
+extern void gr_log_chroot_exec(const struct dentry *dentry,
+			       const struct vfsmount *mnt);
+extern void gr_handle_exec_args(struct linux_binprm *bprm, char **argv);
+extern void gr_log_remount(const char *devname, const int retval);
+extern void gr_log_unmount(const char *devname, const int retval);
+extern void gr_log_mount(const char *from, const char *to, const int retval);
+extern void gr_log_msgget(const int ret, const int msgflg);
+extern void gr_log_msgrm(const uid_t uid, const uid_t cuid);
+extern void gr_log_semget(const int err, const int semflg);
+extern void gr_log_semrm(const uid_t uid, const uid_t cuid);
+extern void gr_log_shmget(const int err, const int shmflg, const size_t size);
+extern void gr_log_shmrm(const uid_t uid, const uid_t cuid);
+extern void gr_log_textrel(struct vm_area_struct *vma);
+
+extern int gr_handle_follow_link(const struct inode *parent,
+				 const struct inode *inode,
+				 const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+extern int gr_handle_fifo(const struct dentry *dentry,
+			  const struct vfsmount *mnt,
+			  const struct dentry *dir, const int flag,
+			  const int acc_mode);
+extern int gr_handle_hardlink(const struct dentry *dentry,
+			      const struct vfsmount *mnt,
+			      struct inode *inode,
+			      const int mode, const char *to);
+
+extern int gr_task_is_capable(struct task_struct *task, const int cap);
+extern int gr_is_capable_nolog(const int cap);
+extern void gr_learn_resource(const struct task_struct *task, const int limit,
+			      const unsigned long wanted, const int gt);
+extern void gr_copy_label(struct task_struct *tsk);
+extern void gr_handle_crash(struct task_struct *task, const int sig);
+extern int gr_handle_signal(const struct task_struct *p, const int sig);
+extern int gr_check_crash_uid(const uid_t uid);
+extern int gr_check_protected_task(const struct task_struct *task);
+extern int gr_acl_handle_mmap(const struct file *file,
+			      const unsigned long prot);
+extern int gr_acl_handle_mprotect(const struct file *file,
+				  const unsigned long prot);
+extern int gr_check_hidden_task(const struct task_struct *tsk);
+extern __u32 gr_acl_handle_truncate(const struct dentry *dentry,
+				    const struct vfsmount *mnt);
+extern __u32 gr_acl_handle_utime(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+extern __u32 gr_acl_handle_access(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int fmode);
+extern __u32 gr_acl_handle_fchmod(const struct dentry *dentry,
+				  const struct vfsmount *mnt, mode_t mode);
+extern __u32 gr_acl_handle_chmod(const struct dentry *dentry,
+				 const struct vfsmount *mnt, mode_t mode);
+extern __u32 gr_acl_handle_chown(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+extern int gr_handle_ptrace(struct task_struct *task, const long request);
+extern int gr_handle_proc_ptrace(struct task_struct *task);
+extern __u32 gr_acl_handle_execve(const struct dentry *dentry,
+				  const struct vfsmount *mnt);
+extern int gr_check_crash_exec(const struct file *filp);
+extern int gr_acl_is_enabled(void);
+extern void gr_set_kernel_label(struct task_struct *task);
+extern void gr_set_role_label(struct task_struct *task, const uid_t uid,
+			      const gid_t gid);
+extern int gr_set_proc_label(const struct dentry *dentry,
+			      const struct vfsmount *mnt);
+extern __u32 gr_acl_handle_hidden_file(const struct dentry *dentry,
+				       const struct vfsmount *mnt);
+extern __u32 gr_acl_handle_open(const struct dentry *dentry,
+				const struct vfsmount *mnt, const int fmode);
+extern __u32 gr_acl_handle_creat(const struct dentry *dentry,
+				 const struct dentry *p_dentry,
+				 const struct vfsmount *p_mnt, const int fmode,
+				 const int imode);
+extern void gr_handle_create(const struct dentry *dentry,
+			     const struct vfsmount *mnt);
+extern __u32 gr_acl_handle_mknod(const struct dentry *new_dentry,
+				 const struct dentry *parent_dentry,
+				 const struct vfsmount *parent_mnt,
+				 const int mode);
+extern __u32 gr_acl_handle_mkdir(const struct dentry *new_dentry,
+				 const struct dentry *parent_dentry,
+				 const struct vfsmount *parent_mnt);
+extern __u32 gr_acl_handle_rmdir(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+extern void gr_handle_delete(const ino_t ino, const dev_t dev);
+extern __u32 gr_acl_handle_unlink(const struct dentry *dentry,
+				  const struct vfsmount *mnt);
+extern __u32 gr_acl_handle_symlink(const struct dentry *new_dentry,
+				   const struct dentry *parent_dentry,
+				   const struct vfsmount *parent_mnt,
+				   const char *from);
+extern __u32 gr_acl_handle_link(const struct dentry *new_dentry,
+				const struct dentry *parent_dentry,
+				const struct vfsmount *parent_mnt,
+				const struct dentry *old_dentry,
+				const struct vfsmount *old_mnt, const char *to);
+extern int gr_acl_handle_rename(struct dentry *new_dentry,
+				struct dentry *parent_dentry,
+				const struct vfsmount *parent_mnt,
+				struct dentry *old_dentry,
+				struct inode *old_parent_inode,
+				struct vfsmount *old_mnt, const char *newname);
+extern void gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+				struct dentry *old_dentry,
+				struct dentry *new_dentry,
+				struct vfsmount *mnt, const __u8 replace);
+extern __u32 gr_check_link(const struct dentry *new_dentry,
+			   const struct dentry *parent_dentry,
+			   const struct vfsmount *parent_mnt,
+			   const struct dentry *old_dentry,
+			   const struct vfsmount *old_mnt);
+extern int gr_acl_handle_filldir(const struct file *file, const char *name,
+				 const unsigned int namelen, const ino_t ino);
+
+extern __u32 gr_acl_handle_unix(const struct dentry *dentry,
+				const struct vfsmount *mnt);
+extern void gr_acl_handle_exit(void);
+extern void gr_acl_handle_psacct(struct task_struct *task, const long code);
+extern int gr_acl_handle_procpidmem(const struct task_struct *task);
+extern __u32 gr_cap_rtnetlink(void);
+
+#ifdef CONFIG_SYSVIPC
+extern void gr_shm_exit(struct task_struct *task);
+#else
+static inline void gr_shm_exit(struct task_struct *task)
+{
+	return;
+}
+#endif
+
+#ifdef CONFIG_GRKERNSEC
+extern void gr_handle_mem_write(void);
+extern void gr_handle_kmem_write(void);
+extern void gr_handle_open_port(void);
+extern int gr_handle_mem_mmap(const unsigned long offset,
+			      struct vm_area_struct *vma);
+
+extern unsigned long pax_get_random_long(void);
+#define get_random_long() pax_get_random_long()
+
+extern int grsec_enable_dmesg;
+extern int grsec_enable_randsrc;
+extern int grsec_enable_shm;
+#endif
+
+#endif
diff -Nur linux-2.6.13.1.org/include/linux/hiddev.h grsecurity226/include/linux/hiddev.h
--- linux-2.6.13.1.org/include/linux/hiddev.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/hiddev.h	2005-08-30 01:00:57.000000000 +0200
@@ -2,7 +2,7 @@
 #define _HIDDEV_H
 
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999-2000 Vojtech Pavlik
  *
diff -Nur linux-2.6.13.1.org/include/linux/hysdn_if.h grsecurity226/include/linux/hysdn_if.h
--- linux-2.6.13.1.org/include/linux/hysdn_if.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/hysdn_if.h	2005-08-30 01:00:57.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux driver for HYSDN cards
  * ioctl definitions shared by hynetmgr and driver.
diff -Nur linux-2.6.13.1.org/include/linux/i2c-algo-bit.h grsecurity226/include/linux/i2c-algo-bit.h
--- linux-2.6.13.1.org/include/linux/i2c-algo-bit.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/i2c-algo-bit.h	2005-08-30 01:00:57.000000000 +0200
@@ -21,7 +21,7 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
    Frodo Looijaard <frodol@dds.nl> */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _LINUX_I2C_ALGO_BIT_H
 #define _LINUX_I2C_ALGO_BIT_H
diff -Nur linux-2.6.13.1.org/include/linux/i2c-algo-pcf.h grsecurity226/include/linux/i2c-algo-pcf.h
--- linux-2.6.13.1.org/include/linux/i2c-algo-pcf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/i2c-algo-pcf.h	2005-08-30 01:00:57.000000000 +0200
@@ -22,7 +22,7 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
    Frodo Looijaard <frodol@dds.nl> */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _LINUX_I2C_ALGO_PCF_H
 #define _LINUX_I2C_ALGO_PCF_H
diff -Nur linux-2.6.13.1.org/include/linux/i2c-dev.h grsecurity226/include/linux/i2c-dev.h
--- linux-2.6.13.1.org/include/linux/i2c-dev.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/i2c-dev.h	2005-08-30 01:00:57.000000000 +0200
@@ -19,7 +19,7 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _LINUX_I2C_DEV_H
 #define _LINUX_I2C_DEV_H
diff -Nur linux-2.6.13.1.org/include/linux/i2c.h grsecurity226/include/linux/i2c.h
--- linux-2.6.13.1.org/include/linux/i2c.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/i2c.h	2005-08-30 01:00:57.000000000 +0200
@@ -23,7 +23,7 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and
    Frodo Looijaard <frodol@dds.nl> */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _LINUX_I2C_H
 #define _LINUX_I2C_H
diff -Nur linux-2.6.13.1.org/include/linux/if_bridge.h grsecurity226/include/linux/if_bridge.h
--- linux-2.6.13.1.org/include/linux/if_bridge.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/if_bridge.h	2005-08-30 01:00:57.000000000 +0200
@@ -4,7 +4,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/include/linux/if_infiniband.h grsecurity226/include/linux/if_infiniband.h
--- linux-2.6.13.1.org/include/linux/if_infiniband.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/if_infiniband.h	2005-08-30 01:00:57.000000000 +0200
@@ -18,7 +18,7 @@
  *
  * Copyright (c) 2004 Topspin Communications.  All rights reserved.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _LINUX_IF_INFINIBAND_H
diff -Nur linux-2.6.13.1.org/include/linux/if_ppp.h grsecurity226/include/linux/if_ppp.h
--- linux-2.6.13.1.org/include/linux/if_ppp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/if_ppp.h	2005-08-30 01:00:57.000000000 +0200
@@ -1,4 +1,4 @@
-/*	$Id$	*/
+/*	$Id$	*/
 
 /*
  * if_ppp.h - Point-to-Point Protocol definitions.
diff -Nur linux-2.6.13.1.org/include/linux/if_tun.h grsecurity226/include/linux/if_tun.h
--- linux-2.6.13.1.org/include/linux/if_tun.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/if_tun.h	2005-08-30 01:00:58.000000000 +0200
@@ -12,7 +12,7 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
  *
- *  $Id$
+ *  $Id$
  */
 
 #ifndef __IF_TUN_H
diff -Nur linux-2.6.13.1.org/include/linux/inet.h grsecurity226/include/linux/inet.h
--- linux-2.6.13.1.org/include/linux/inet.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/inet.h	2005-08-30 01:00:58.000000000 +0200
@@ -8,31 +8,31 @@
  *		This work was derived from Ross Biro's inspirational work
  *		for the LINUX operating system.  His version numbers were:
  *
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- * 		$Id$
- * 		$Id$
- * 		$Id$
- * 		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
- *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ * 		$Id$
+ * 		$Id$
+ * 		$Id$
+ * 		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
+ *		$Id$
  *
  *		This program is free software; you can redistribute it and/or
  *		modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/include/linux/ip6_tunnel.h grsecurity226/include/linux/ip6_tunnel.h
--- linux-2.6.13.1.org/include/linux/ip6_tunnel.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/ip6_tunnel.h	2005-08-30 01:00:58.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 
 #ifndef _IP6_TUNNEL_H
diff -Nur linux-2.6.13.1.org/include/linux/isdn/capicmd.h grsecurity226/include/linux/isdn/capicmd.h
--- linux-2.6.13.1.org/include/linux/isdn/capicmd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/isdn/capicmd.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * CAPI 2.0 Interface for Linux
  * 
diff -Nur linux-2.6.13.1.org/include/linux/isdn/capilli.h grsecurity226/include/linux/isdn/capilli.h
--- linux-2.6.13.1.org/include/linux/isdn/capilli.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/isdn/capilli.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * 
  * Kernel CAPI 2.0 Driver Interface for Linux
  * 
diff -Nur linux-2.6.13.1.org/include/linux/isdn/capiutil.h grsecurity226/include/linux/isdn/capiutil.h
--- linux-2.6.13.1.org/include/linux/isdn/capiutil.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/isdn/capiutil.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * CAPI 2.0 defines & types
  *
diff -Nur linux-2.6.13.1.org/include/linux/isdn/tpam.h grsecurity226/include/linux/isdn/tpam.h
--- linux-2.6.13.1.org/include/linux/isdn/tpam.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/isdn/tpam.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Turbo PAM ISDN driver for Linux. (Kernel Driver)
  *
diff -Nur linux-2.6.13.1.org/include/linux/isdn.h grsecurity226/include/linux/isdn.h
--- linux-2.6.13.1.org/include/linux/isdn.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/isdn.h	2005-08-30 01:00:58.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Main header for the Linux ISDN subsystem (linklevel).
  *
diff -Nur linux-2.6.13.1.org/include/linux/isdn_divertif.h grsecurity226/include/linux/isdn_divertif.h
--- linux-2.6.13.1.org/include/linux/isdn_divertif.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/isdn_divertif.h	2005-08-30 01:00:58.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Header for the diversion supplementary interface for i4l.
  *
diff -Nur linux-2.6.13.1.org/include/linux/isdnif.h grsecurity226/include/linux/isdnif.h
--- linux-2.6.13.1.org/include/linux/isdnif.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/isdnif.h	2005-08-30 01:00:58.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * Linux ISDN subsystem
  * Definition of the interface between the subsystem and its low-level drivers.
diff -Nur linux-2.6.13.1.org/include/linux/jffs.h grsecurity226/include/linux/jffs.h
--- linux-2.6.13.1.org/include/linux/jffs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/jffs.h	2005-08-30 01:00:58.000000000 +0200
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id$
+ * $Id$
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
diff -Nur linux-2.6.13.1.org/include/linux/jffs2.h grsecurity226/include/linux/jffs2.h
--- linux-2.6.13.1.org/include/linux/jffs2.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/jffs2.h	2005-08-30 01:00:58.000000000 +0200
@@ -8,7 +8,7 @@
  * For licensing information, see the file 'LICENCE' in the 
  * jffs2 directory.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/include/linux/jffs2_fs_i.h grsecurity226/include/linux/jffs2_fs_i.h
--- linux-2.6.13.1.org/include/linux/jffs2_fs_i.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/jffs2_fs_i.h	2005-08-30 01:00:58.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _JFFS2_FS_I
 #define _JFFS2_FS_I
diff -Nur linux-2.6.13.1.org/include/linux/jffs2_fs_sb.h grsecurity226/include/linux/jffs2_fs_sb.h
--- linux-2.6.13.1.org/include/linux/jffs2_fs_sb.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/jffs2_fs_sb.h	2005-08-30 01:00:58.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef _JFFS2_FS_SB
 #define _JFFS2_FS_SB
diff -Nur linux-2.6.13.1.org/include/linux/joystick.h grsecurity226/include/linux/joystick.h
--- linux-2.6.13.1.org/include/linux/joystick.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/joystick.h	2005-08-30 01:00:58.000000000 +0200
@@ -2,7 +2,7 @@
 #define _LINUX_JOYSTICK_H
 
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (C) 1996-2000 Vojtech Pavlik
  *
diff -Nur linux-2.6.13.1.org/include/linux/kernelcapi.h grsecurity226/include/linux/kernelcapi.h
--- linux-2.6.13.1.org/include/linux/kernelcapi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/kernelcapi.h	2005-08-30 01:00:58.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  * 
  * Kernel CAPI 2.0 Interface for Linux
  * 
diff -Nur linux-2.6.13.1.org/include/linux/mm.h grsecurity226/include/linux/mm.h
--- linux-2.6.13.1.org/include/linux/mm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mm.h	2005-08-30 01:14:58.000000000 +0200
@@ -36,6 +36,7 @@
 #include <asm/pgtable.h>
 #include <asm/processor.h>
 #include <asm/atomic.h>
+#include <asm/mman.h>
 
 #define nth_page(page,n) pfn_to_page(page_to_pfn((page)) + (n))
 
@@ -109,8 +110,43 @@
 #ifdef CONFIG_NUMA
 	struct mempolicy *vm_policy;	/* NUMA policy for the VMA */
 #endif
+
+	unsigned long vm_mirror;	/* PaX: mirror distance */
 };
 
+#ifdef CONFIG_PAX_SOFTMODE
+extern unsigned int pax_softmode;
+#endif
+
+extern int pax_check_flags(unsigned long *);
+
+/* if tsk != current then task_lock must be held on it */
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline unsigned long pax_get_flags(struct task_struct *tsk)
+{
+	if (likely(tsk->mm))
+		return tsk->mm->pax_flags;
+	else
+		return 0UL;
+}
+
+/* if tsk != current then task_lock must be held on it */
+static inline long pax_set_flags(struct task_struct *tsk, unsigned long flags)
+{
+	if (likely(tsk->mm)) {
+		tsk->mm->pax_flags = flags;
+		return 0;
+	}
+	return -EINVAL;
+}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+extern void pax_set_initial_flags(struct linux_binprm * bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+extern void (*pax_set_initial_flags_func)(struct linux_binprm * bprm);
+#endif
+
 /*
  * This struct defines the per-mm list of VMAs for uClinux. If CONFIG_MMU is
  * disabled, then there's a single shared list of VMAs maintained by the
@@ -162,6 +198,18 @@
 #define VM_NONLINEAR	0x00800000	/* Is non-linear (remap_file_pages) */
 #define VM_MAPPED_COPY	0x01000000	/* T if mapped copy of data (nommu mmap) */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define VM_MIRROR	0x01000000	/* vma is mirroring another */
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+#define VM_MAYNOTWRITE	0x02000000	/* vma cannot be granted VM_WRITE any more */
+#endif
+
+#ifdef __VM_STACK_FLAGS
+#define VM_STACK_DEFAULT_FLAGS (0x00000033 | __VM_STACK_FLAGS)
+#endif
+
 #ifndef VM_STACK_DEFAULT_FLAGS		/* arch can override this */
 #define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
 #endif
@@ -845,6 +893,10 @@
 	unsigned long len, unsigned long prot,
 	unsigned long flag, unsigned long pgoff);
 
+extern unsigned long __do_mmap_pgoff(struct file *file, unsigned long addr,
+	unsigned long len, unsigned long prot,
+	unsigned long flag, unsigned long pgoff);
+
 static inline unsigned long do_mmap(struct file *file, unsigned long addr,
 	unsigned long len, unsigned long prot,
 	unsigned long flag, unsigned long offset)
@@ -917,7 +969,7 @@
 	return (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 }
 
-extern struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr);
+extern struct vm_area_struct *find_extend_vma(struct mm_struct * mm, unsigned long addr);
 
 extern struct page * vmalloc_to_page(void *addr);
 extern unsigned long vmalloc_to_pfn(void *addr);
@@ -970,5 +1022,11 @@
 /* /proc/<pid>/oom_adj set to -17 protects from the oom-killer */
 #define OOM_DISABLE -17
 
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+extern void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot);
+#else
+static inline void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot) {}
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_MM_H */
diff -Nur linux-2.6.13.1.org/include/linux/mman.h grsecurity226/include/linux/mman.h
--- linux-2.6.13.1.org/include/linux/mman.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mman.h	2005-08-30 01:14:58.000000000 +0200
@@ -59,6 +59,11 @@
 calc_vm_flag_bits(unsigned long flags)
 {
 	return _calc_vm_trans(flags, MAP_GROWSDOWN,  VM_GROWSDOWN ) |
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	       _calc_vm_trans(flags, MAP_MIRROR, VM_MIRROR) |
+#endif
+
 	       _calc_vm_trans(flags, MAP_DENYWRITE,  VM_DENYWRITE ) |
 	       _calc_vm_trans(flags, MAP_EXECUTABLE, VM_EXECUTABLE) |
 	       _calc_vm_trans(flags, MAP_LOCKED,     VM_LOCKED    );
diff -Nur linux-2.6.13.1.org/include/linux/mmc/protocol.h grsecurity226/include/linux/mmc/protocol.h
--- linux-2.6.13.1.org/include/linux/mmc/protocol.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mmc/protocol.h	2005-08-30 01:00:59.000000000 +0200
@@ -16,7 +16,7 @@
  * Based strongly on code by:
  *
  * Author: Yong-iL Joh <tolkien@mizi.com>
- * Date  : $Date$
+ * Date  : $Date$
  *
  * Author:  Andrew Christian
  *          15 May 2002
diff -Nur linux-2.6.13.1.org/include/linux/mount.h grsecurity226/include/linux/mount.h
--- linux-2.6.13.1.org/include/linux/mount.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mount.h	2005-08-30 01:00:59.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * Author:  Marco van Wieringen <mvw@planets.elm.net>
  *
- * Version: $Id$
+ * Version: $Id$
  *
  */
 #ifndef _LINUX_MOUNT_H
diff -Nur linux-2.6.13.1.org/include/linux/mtd/blktrans.h grsecurity226/include/linux/mtd/blktrans.h
--- linux-2.6.13.1.org/include/linux/mtd/blktrans.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/blktrans.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
diff -Nur linux-2.6.13.1.org/include/linux/mtd/cfi.h grsecurity226/include/linux/mtd/cfi.h
--- linux-2.6.13.1.org/include/linux/mtd/cfi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/cfi.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,7 +1,7 @@
 
 /* Common Flash Interface structures 
  * See http://support.intel.com/design/flash/technote/index.htm
- * $Id$
+ * $Id$
  */
 
 #ifndef __MTD_CFI_H__
diff -Nur linux-2.6.13.1.org/include/linux/mtd/cfi_endian.h grsecurity226/include/linux/mtd/cfi_endian.h
--- linux-2.6.13.1.org/include/linux/mtd/cfi_endian.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/cfi_endian.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/include/linux/mtd/concat.h grsecurity226/include/linux/mtd/concat.h
--- linux-2.6.13.1.org/include/linux/mtd/concat.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/concat.h	2005-08-30 01:00:59.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef MTD_CONCAT_H
diff -Nur linux-2.6.13.1.org/include/linux/mtd/doc2000.h grsecurity226/include/linux/mtd/doc2000.h
--- linux-2.6.13.1.org/include/linux/mtd/doc2000.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/doc2000.h	2005-08-30 01:00:59.000000000 +0200
@@ -6,7 +6,7 @@
  * Copyright (C) 2002-2003 Greg Ungerer <gerg@snapgear.com>
  * Copyright (C) 2002-2003 SnapGear Inc
  *
- * $Id$ 
+ * $Id$ 
  *
  * Released under GPL
  */
diff -Nur linux-2.6.13.1.org/include/linux/mtd/flashchip.h grsecurity226/include/linux/mtd/flashchip.h
--- linux-2.6.13.1.org/include/linux/mtd/flashchip.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/flashchip.h	2005-08-30 01:00:59.000000000 +0200
@@ -6,7 +6,7 @@
  *
  * (C) 2000 Red Hat. GPLd.
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/include/linux/mtd/ftl.h grsecurity226/include/linux/mtd/ftl.h
--- linux-2.6.13.1.org/include/linux/mtd/ftl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/ftl.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  * 
  * Derived from (and probably identical to):
  * ftl.h 1.7 1999/10/25 20:23:17
diff -Nur linux-2.6.13.1.org/include/linux/mtd/gen_probe.h grsecurity226/include/linux/mtd/gen_probe.h
--- linux-2.6.13.1.org/include/linux/mtd/gen_probe.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/gen_probe.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * (C) 2001, 2001 Red Hat, Inc.
  * GPL'd
- * $Id$
+ * $Id$
  */
 
 #ifndef __LINUX_MTD_GEN_PROBE_H__
diff -Nur linux-2.6.13.1.org/include/linux/mtd/iflash.h grsecurity226/include/linux/mtd/iflash.h
--- linux-2.6.13.1.org/include/linux/mtd/iflash.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/iflash.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef __MTD_IFLASH_H__
 #define __MTD_IFLASH_H__
diff -Nur linux-2.6.13.1.org/include/linux/mtd/inftl.h grsecurity226/include/linux/mtd/inftl.h
--- linux-2.6.13.1.org/include/linux/mtd/inftl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/inftl.h	2005-08-30 01:00:59.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *	(C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
  *
- *	$Id$
+ *	$Id$
  */
 
 #ifndef __MTD_INFTL_H__
diff -Nur linux-2.6.13.1.org/include/linux/mtd/jedec.h grsecurity226/include/linux/mtd/jedec.h
--- linux-2.6.13.1.org/include/linux/mtd/jedec.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/jedec.h	2005-08-30 01:00:59.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * See the AMD flash databook for information on how to operate the interface.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef __LINUX_MTD_JEDEC_H__
diff -Nur linux-2.6.13.1.org/include/linux/mtd/map.h grsecurity226/include/linux/mtd/map.h
--- linux-2.6.13.1.org/include/linux/mtd/map.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/map.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id$ */
+/* $Id$ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
diff -Nur linux-2.6.13.1.org/include/linux/mtd/mtd.h grsecurity226/include/linux/mtd/mtd.h
--- linux-2.6.13.1.org/include/linux/mtd/mtd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/mtd.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,5 +1,5 @@
 /* 
- * $Id$
+ * $Id$
  *
  * Copyright (C) 1999-2003 David Woodhouse <dwmw2@infradead.org> et al.
  *
diff -Nur linux-2.6.13.1.org/include/linux/mtd/nand.h grsecurity226/include/linux/mtd/nand.h
--- linux-2.6.13.1.org/include/linux/mtd/nand.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/nand.h	2005-08-30 01:00:59.000000000 +0200
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/include/linux/mtd/nand_ecc.h grsecurity226/include/linux/mtd/nand_ecc.h
--- linux-2.6.13.1.org/include/linux/mtd/nand_ecc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/nand_ecc.h	2005-08-30 01:00:59.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/include/linux/mtd/nftl.h grsecurity226/include/linux/mtd/nftl.h
--- linux-2.6.13.1.org/include/linux/mtd/nftl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/nftl.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>
  */
diff -Nur linux-2.6.13.1.org/include/linux/mtd/partitions.h grsecurity226/include/linux/mtd/partitions.h
--- linux-2.6.13.1.org/include/linux/mtd/partitions.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/partitions.h	2005-08-30 01:00:59.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef MTD_PARTITIONS_H
diff -Nur linux-2.6.13.1.org/include/linux/mtd/physmap.h grsecurity226/include/linux/mtd/physmap.h
--- linux-2.6.13.1.org/include/linux/mtd/physmap.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/physmap.h	2005-08-30 01:00:59.000000000 +0200
@@ -2,7 +2,7 @@
  * For boards with physically mapped flash and using 
  * drivers/mtd/maps/physmap.c mapping driver.
  *
- * $Id$
+ * $Id$
  *
  * Copyright (C) 2003 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
diff -Nur linux-2.6.13.1.org/include/linux/mtd/plat-ram.h grsecurity226/include/linux/mtd/plat-ram.h
--- linux-2.6.13.1.org/include/linux/mtd/plat-ram.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/plat-ram.h	2005-08-30 01:00:59.000000000 +0200
@@ -6,7 +6,7 @@
  *
  * Generic platform device based RAM map
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/include/linux/mtd/pmc551.h grsecurity226/include/linux/mtd/pmc551.h
--- linux-2.6.13.1.org/include/linux/mtd/pmc551.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/pmc551.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * PMC551 PCI Mezzanine Ram Device
  *
@@ -17,7 +17,7 @@
 
 #include <linux/mtd/mtd.h>
 
-#define PMC551_VERSION "$Id$\n"\
+#define PMC551_VERSION "$Id$\n"\
        "Ramix PMC551 PCI Mezzanine Ram Driver. (C) 1999,2000 Nortel Networks.\n"
 
 /*
diff -Nur linux-2.6.13.1.org/include/linux/mtd/xip.h grsecurity226/include/linux/mtd/xip.h
--- linux-2.6.13.1.org/include/linux/mtd/xip.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/mtd/xip.h	2005-08-30 01:00:59.000000000 +0200
@@ -12,7 +12,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef __LINUX_MTD_XIP_H__
diff -Nur linux-2.6.13.1.org/include/linux/n_r3964.h grsecurity226/include/linux/n_r3964.h
--- linux-2.6.13.1.org/include/linux/n_r3964.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/n_r3964.h	2005-08-30 01:00:59.000000000 +0200
@@ -12,7 +12,10 @@
  * Author:
  * L. Haag
  *
- * $Log$
+ * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:00:59  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.3  2001/03/18 13:02:24  dwmw2
  * Fix timer usage, use spinlocks properly.
  *
diff -Nur linux-2.6.13.1.org/include/linux/parport.h grsecurity226/include/linux/parport.h
--- linux-2.6.13.1.org/include/linux/parport.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/parport.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 /*
  * Any part of this program may be used in documents licensed under
diff -Nur linux-2.6.13.1.org/include/linux/ppp-comp.h grsecurity226/include/linux/ppp-comp.h
--- linux-2.6.13.1.org/include/linux/ppp-comp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/ppp-comp.h	2005-08-30 01:00:59.000000000 +0200
@@ -24,7 +24,7 @@
  * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
  * OR MODIFICATIONS.
  *
- * $Id$
+ * $Id$
  */
 
 /*
diff -Nur linux-2.6.13.1.org/include/linux/ppp_defs.h grsecurity226/include/linux/ppp_defs.h
--- linux-2.6.13.1.org/include/linux/ppp_defs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/ppp_defs.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,4 +1,4 @@
-/*	$Id$	*/
+/*	$Id$	*/
 
 /*
  * ppp_defs.h - PPP definitions.
diff -Nur linux-2.6.13.1.org/include/linux/qic117.h grsecurity226/include/linux/qic117.h
--- linux-2.6.13.1.org/include/linux/qic117.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/qic117.h	2005-08-30 01:00:59.000000000 +0200
@@ -20,9 +20,9 @@
  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
  *
- * $Source$
- * $Revision$
- * $Date$
+ * $Source$
+ * $Revision$
+ * $Date$
  *
  *      This file contains QIC-117 spec. related definitions for the
  *      QIC-40/80/3010/3020 floppy-tape driver "ftape" for Linux.
diff -Nur linux-2.6.13.1.org/include/linux/quota.h grsecurity226/include/linux/quota.h
--- linux-2.6.13.1.org/include/linux/quota.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/quota.h	2005-08-30 01:00:59.000000000 +0200
@@ -29,7 +29,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * Version: $Id$
+ * Version: $Id$
  */
 
 #ifndef _LINUX_QUOTA_
diff -Nur linux-2.6.13.1.org/include/linux/quotaops.h grsecurity226/include/linux/quotaops.h
--- linux-2.6.13.1.org/include/linux/quotaops.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/quotaops.h	2005-08-30 01:00:59.000000000 +0200
@@ -4,7 +4,7 @@
  *
  * Author:  Marco van Wieringen <mvw@planets.elm.net>
  *
- * Version: $Id$
+ * Version: $Id$
  *
  */
 #ifndef _LINUX_QUOTAOPS_
diff -Nur linux-2.6.13.1.org/include/linux/random.h grsecurity226/include/linux/random.h
--- linux-2.6.13.1.org/include/linux/random.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/random.h	2005-08-30 01:14:58.000000000 +0200
@@ -60,6 +60,8 @@
 extern __u32 secure_tcpv6_sequence_number(__u32 *saddr, __u32 *daddr,
 					  __u16 sport, __u16 dport);
 
+extern unsigned long pax_get_random_long(void);
+
 #ifndef MODULE
 extern struct file_operations random_fops, urandom_fops;
 #endif
diff -Nur linux-2.6.13.1.org/include/linux/rslib.h grsecurity226/include/linux/rslib.h
--- linux-2.6.13.1.org/include/linux/rslib.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/rslib.h	2005-08-30 01:00:59.000000000 +0200
@@ -9,7 +9,7 @@
  * RS code lifted from reed solomon library written by Phil Karn
  * Copyright 2002 Phil Karn, KA9Q
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/include/linux/scc.h grsecurity226/include/linux/scc.h
--- linux-2.6.13.1.org/include/linux/scc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/scc.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id$ */
 
 #ifndef	_SCC_H
 #define	_SCC_H
diff -Nur linux-2.6.13.1.org/include/linux/sched.h grsecurity226/include/linux/sched.h
--- linux-2.6.13.1.org/include/linux/sched.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/sched.h	2005-08-30 01:14:58.000000000 +0200
@@ -36,6 +36,7 @@
 #include <linux/seccomp.h>
 
 struct exec_domain;
+struct linux_binprm;
 
 /*
  * cloning flags:
@@ -268,8 +269,34 @@
 
 	unsigned long hiwater_rss;	/* High-water RSS usage */
 	unsigned long hiwater_vm;	/* High-water virtual memory usage */
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	unsigned long pax_flags;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	unsigned long call_dl_resolve;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	unsigned long call_syscall;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	unsigned long delta_mmap;		/* randomized offset */
+	unsigned long delta_exec;		/* randomized offset */
+	unsigned long delta_stack;		/* randomized offset */
+#endif
+
 };
 
+#define MF_PAX_PAGEEXEC		0x01000000	/* Paging based non-executable pages */
+#define MF_PAX_EMUTRAMP		0x02000000	/* Emulate trampolines */
+#define MF_PAX_MPROTECT		0x04000000	/* Restrict mprotect() */
+#define MF_PAX_RANDMMAP		0x08000000	/* Randomize mmap() base */
+/*#define MF_PAX_RANDEXEC		0x10000000*/	/* Randomize ET_EXEC base */
+#define MF_PAX_SEGMEXEC		0x20000000	/* Segmentation based non-executable pages */
+
 struct sighand_struct {
 	atomic_t		count;
 	struct k_sigaction	action[_NSIG];
@@ -366,6 +393,15 @@
 	struct key *session_keyring;	/* keyring inherited over fork */
 	struct key *process_keyring;	/* keyring private to this process */
 #endif
+
+#ifdef CONFIG_GRKERNSEC
+	u32 curr_ip;
+	u32 gr_saddr;
+	u32 gr_daddr;
+	u16 gr_sport;
+	u16 gr_dport;
+	u8 used_accept:1;
+#endif
 };
 
 /* Context switch must be unlocked if interrupts are to be enabled */
@@ -770,6 +806,17 @@
 	int cpuset_mems_generation;
 #endif
 	atomic_t fs_excl;	/* holding fs exclusive resources */
+
+#ifdef CONFIG_GRKERNSEC
+	/* grsecurity */
+	struct acl_subject_label *acl;
+	struct acl_role_label *role;
+	struct file *exec_file;
+	u16 acl_role_id;
+	u8 acl_sp_role:1;
+	u8 is_writable:1;
+	u8 brute:1;
+#endif
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
@@ -1006,14 +1053,29 @@
 		: on_sig_stack(sp) ? SS_ONSTACK : 0);
 }
 
+extern int gr_task_is_capable(struct task_struct *task, const int cap);
+extern int gr_is_capable_nolog(const int cap);
 
 #ifdef CONFIG_SECURITY
 /* code is in security.c */
 extern int capable(int cap);
+static inline int capable_nolog(int cap)
+{
+	return capable(cap);
+}
 #else
 static inline int capable(int cap)
 {
-	if (cap_raised(current->cap_effective, cap)) {
+	if (cap_raised(current->cap_effective, cap) && gr_task_is_capable(current, cap)) {
+		current->flags |= PF_SUPERPRIV;
+		return 1;
+	}
+	return 0;
+}
+
+static inline int capable_nolog(int cap)
+{
+	if (cap_raised(current->cap_effective, cap) && gr_is_capable_nolog(cap)) {
 		current->flags |= PF_SUPERPRIV;
 		return 1;
 	}
@@ -1259,6 +1321,12 @@
 static inline void arch_pick_mmap_layout(struct mm_struct *mm)
 {
 	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
 	mm->get_unmapped_area = arch_get_unmapped_area;
 	mm->unmap_area = arch_unmap_area;
 }
diff -Nur linux-2.6.13.1.org/include/linux/shm.h grsecurity226/include/linux/shm.h
--- linux-2.6.13.1.org/include/linux/shm.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/shm.h	2005-08-30 01:14:58.000000000 +0200
@@ -86,6 +86,10 @@
 	pid_t			shm_cprid;
 	pid_t			shm_lprid;
 	struct user_struct	*mlock_user;
+#ifdef CONFIG_GRKERNSEC
+	time_t			shm_createtime;
+	pid_t			shm_lapid;
+#endif
 };
 
 /* shm_mode upper byte flags */
diff -Nur linux-2.6.13.1.org/include/linux/sunrpc/auth_gss.h grsecurity226/include/linux/sunrpc/auth_gss.h
--- linux-2.6.13.1.org/include/linux/sunrpc/auth_gss.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/sunrpc/auth_gss.h	2005-08-30 01:01:00.000000000 +0200
@@ -8,7 +8,7 @@
  * Bruce Fields <bfields@umich.edu>
  * Copyright (c) 2000 The Regents of the University of Michigan
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _LINUX_SUNRPC_AUTH_GSS_H
diff -Nur linux-2.6.13.1.org/include/linux/sunrpc/gss_api.h grsecurity226/include/linux/sunrpc/gss_api.h
--- linux-2.6.13.1.org/include/linux/sunrpc/gss_api.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/sunrpc/gss_api.h	2005-08-30 01:01:00.000000000 +0200
@@ -8,7 +8,7 @@
  * Bruce Fields <bfields@umich.edu>
  * Copyright (c) 2000 The Regents of the University of Michigan
  *
- * $Id$
+ * $Id$
  */
 
 #ifndef _LINUX_SUNRPC_GSS_API_H
diff -Nur linux-2.6.13.1.org/include/linux/sunrpc/svcauth_gss.h grsecurity226/include/linux/sunrpc/svcauth_gss.h
--- linux-2.6.13.1.org/include/linux/sunrpc/svcauth_gss.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/sunrpc/svcauth_gss.h	2005-08-30 01:01:00.000000000 +0200
@@ -4,7 +4,7 @@
  * Bruce Fields <bfields@umich.edu>
  * Copyright (c) 2002 The Regents of the Unviersity of Michigan
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/include/linux/synclink.h grsecurity226/include/linux/synclink.h
--- linux-2.6.13.1.org/include/linux/synclink.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/synclink.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * SyncLink Multiprotocol Serial Adapter Driver
  *
- * $Id$
+ * $Id$
  *
  * Copyright (C) 1998-2000 by Microgate Corporation
  *
diff -Nur linux-2.6.13.1.org/include/linux/sysctl.h grsecurity226/include/linux/sysctl.h
--- linux-2.6.13.1.org/include/linux/sysctl.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/sysctl.h	2005-08-30 01:14:59.000000000 +0200
@@ -146,7 +146,19 @@
 	KERN_RANDOMIZE=68, /* int: randomize virtual address space */
 	KERN_SETUID_DUMPABLE=69, /* int: behaviour of dumps for setuid core */
 	KERN_SPIN_RETRY=70,	/* int: number of spinlock retries */
+	KERN_GRSECURITY=71,	/* grsecurity */
+
+#ifdef CONFIG_PAX_SOFTMODE
+	KERN_PAX=99,            /* PaX control */
+#endif
+
+};
+
+#ifdef CONFIG_PAX_SOFTMODE
+enum {
+	PAX_SOFTMODE=1		/* PaX: disable/enable soft mode */
 };
+#endif
 
 
 /* CTL_VM names: */
diff -Nur linux-2.6.13.1.org/include/linux/sysrq.h grsecurity226/include/linux/sysrq.h
--- linux-2.6.13.1.org/include/linux/sysrq.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/sysrq.h	2005-08-30 01:00:59.000000000 +0200
@@ -1,6 +1,6 @@
 /* -*- linux-c -*-
  *
- *	$Id$
+ *	$Id$
  *
  *	Linux Magic System Request Key Hacks
  *
diff -Nur linux-2.6.13.1.org/include/linux/telephony.h grsecurity226/include/linux/telephony.h
--- linux-2.6.13.1.org/include/linux/telephony.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/telephony.h	2005-08-30 01:00:59.000000000 +0200
@@ -28,9 +28,9 @@
  * ON AN "AS IS" BASIS, AND QUICKNET TECHNOLOGIES, INC. HAS NO OBLIGATION
  * TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
- * Version:       $Revision$
+ * Version:       $Revision$
  *
- * $Id$
+ * $Id$
  *
  *****************************************************************************/
 
diff -Nur linux-2.6.13.1.org/include/linux/ufs_fs_sb.h grsecurity226/include/linux/ufs_fs_sb.h
--- linux-2.6.13.1.org/include/linux/ufs_fs_sb.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/ufs_fs_sb.h	2005-08-30 01:00:59.000000000 +0200
@@ -6,7 +6,7 @@
  * Laboratory for Computer Science Research Computing Facility
  * Rutgers, The State University of New Jersey
  *
- * $Id$
+ * $Id$
  *
  * Write support by Daniel Pirkl <daniel.pirkl@email.cz>
  */
diff -Nur linux-2.6.13.1.org/include/linux/usbdevice_fs.h grsecurity226/include/linux/usbdevice_fs.h
--- linux-2.6.13.1.org/include/linux/usbdevice_fs.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/usbdevice_fs.h	2005-08-30 01:00:59.000000000 +0200
@@ -23,7 +23,7 @@
  *  History:
  *   0.1  04.01.2000  Created
  *
- *  $Id$
+ *  $Id$
  */
 
 /*****************************************************************************/
diff -Nur linux-2.6.13.1.org/include/linux/zconf.h grsecurity226/include/linux/zconf.h
--- linux-2.6.13.1.org/include/linux/zconf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/zconf.h	2005-08-30 01:00:59.000000000 +0200
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id$ */
 
 #ifndef _ZCONF_H
 #define _ZCONF_H
diff -Nur linux-2.6.13.1.org/include/linux/zftape.h grsecurity226/include/linux/zftape.h
--- linux-2.6.13.1.org/include/linux/zftape.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/zftape.h	2005-08-30 01:00:59.000000000 +0200
@@ -19,9 +19,9 @@
  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
  *
- * $Source$
- * $Revision$
- * $Date$
+ * $Source$
+ * $Revision$
+ * $Date$
  *
  *      Special ioctl and other global info for the zftape VFS
  *      interface for the QIC-40/80/3010/3020 floppy-tape driver for
diff -Nur linux-2.6.13.1.org/include/linux/zutil.h grsecurity226/include/linux/zutil.h
--- linux-2.6.13.1.org/include/linux/zutil.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/linux/zutil.h	2005-08-30 01:00:59.000000000 +0200
@@ -8,7 +8,7 @@
    subject to change. Applications should only use zlib.h.
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id$ */
 
 #ifndef _Z_UTIL_H
 #define _Z_UTIL_H
diff -Nur linux-2.6.13.1.org/include/media/audiochip.h grsecurity226/include/media/audiochip.h
--- linux-2.6.13.1.org/include/media/audiochip.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/media/audiochip.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 
 #ifndef AUDIOCHIP_H
diff -Nur linux-2.6.13.1.org/include/media/id.h grsecurity226/include/media/id.h
--- linux-2.6.13.1.org/include/media/id.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/media/id.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 
 /* FIXME: this temporarely, until these are included in linux/i2c-id.h */
diff -Nur linux-2.6.13.1.org/include/media/ir-common.h grsecurity226/include/media/ir-common.h
--- linux-2.6.13.1.org/include/media/ir-common.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/media/ir-common.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * some common structs and functions to handle infrared remotes via
  * input layer ...
diff -Nur linux-2.6.13.1.org/include/media/tuner.h grsecurity226/include/media/tuner.h
--- linux-2.6.13.1.org/include/media/tuner.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/media/tuner.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 
-/* $Id$
+/* $Id$
  *
     tuner.h - definition for different tuners
 
diff -Nur linux-2.6.13.1.org/include/media/tveeprom.h grsecurity226/include/media/tveeprom.h
--- linux-2.6.13.1.org/include/media/tveeprom.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/media/tveeprom.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 
 struct tveeprom {
diff -Nur linux-2.6.13.1.org/include/media/video-buf.h grsecurity226/include/media/video-buf.h
--- linux-2.6.13.1.org/include/media/video-buf.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/media/video-buf.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * generic helper functions for video4linux capture buffers, to handle
  * memory management and PCI DMA.  Right now bttv + saa7134 use it.
diff -Nur linux-2.6.13.1.org/include/mtd/inftl-user.h grsecurity226/include/mtd/inftl-user.h
--- linux-2.6.13.1.org/include/mtd/inftl-user.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/mtd/inftl-user.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Parts of INFTL headers shared with userspace 
  *
diff -Nur linux-2.6.13.1.org/include/mtd/jffs2-user.h grsecurity226/include/mtd/jffs2-user.h
--- linux-2.6.13.1.org/include/mtd/jffs2-user.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/mtd/jffs2-user.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * JFFS2 definitions for use in user space only
  */
diff -Nur linux-2.6.13.1.org/include/mtd/mtd-abi.h grsecurity226/include/mtd/mtd-abi.h
--- linux-2.6.13.1.org/include/mtd/mtd-abi.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/mtd/mtd-abi.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Portions of MTD ABI definition which are shared by kernel and user space 
  */
diff -Nur linux-2.6.13.1.org/include/mtd/mtd-user.h grsecurity226/include/mtd/mtd-user.h
--- linux-2.6.13.1.org/include/mtd/mtd-user.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/mtd/mtd-user.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * MTD ABI header for use by user space only.
  */
diff -Nur linux-2.6.13.1.org/include/mtd/nftl-user.h grsecurity226/include/mtd/nftl-user.h
--- linux-2.6.13.1.org/include/mtd/nftl-user.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/mtd/nftl-user.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  * Parts of NFTL headers shared with userspace 
  *
diff -Nur linux-2.6.13.1.org/include/net/compat.h grsecurity226/include/net/compat.h
--- linux-2.6.13.1.org/include/net/compat.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/net/compat.h	2005-08-30 01:01:00.000000000 +0200
@@ -33,8 +33,7 @@
 extern asmlinkage long compat_sys_recvmsg(int,struct compat_msghdr __user *,unsigned);
 extern asmlinkage long compat_sys_getsockopt(int, int, int, char __user *, int __user *);
 extern int put_cmsg_compat(struct msghdr*, int, int, int, void *);
-
-struct sock;
-extern int cmsghdr_from_user_compat_to_kern(struct msghdr *, struct sock *, unsigned char *, int);
+extern int cmsghdr_from_user_compat_to_kern(struct msghdr *, unsigned char *,
+		int);
 
 #endif /* NET_COMPAT_H */
diff -Nur linux-2.6.13.1.org/include/net/inetpeer.h grsecurity226/include/net/inetpeer.h
--- linux-2.6.13.1.org/include/net/inetpeer.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/net/inetpeer.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *		INETPEER - A storage for permanent information about peers
  *
- *  Version:	$Id$
+ *  Version:	$Id$
  *
  *  Authors:	Andrey V. Savochkin <saw@msu.ru>
  */
diff -Nur linux-2.6.13.1.org/include/net/ip6_tunnel.h grsecurity226/include/net/ip6_tunnel.h
--- linux-2.6.13.1.org/include/net/ip6_tunnel.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/net/ip6_tunnel.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  */
 
 #ifndef _NET_IP6_TUNNEL_H
diff -Nur linux-2.6.13.1.org/include/net/ipconfig.h grsecurity226/include/net/ipconfig.h
--- linux-2.6.13.1.org/include/net/ipconfig.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/net/ipconfig.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *  $Id$
+ *  $Id$
  *
  *  Copyright (C) 1997 Martin Mares
  *
diff -Nur linux-2.6.13.1.org/include/net/ipv6.h grsecurity226/include/net/ipv6.h
--- linux-2.6.13.1.org/include/net/ipv6.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/net/ipv6.h	2005-08-30 01:01:00.000000000 +0200
@@ -4,7 +4,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/include/net/slhc_vj.h grsecurity226/include/net/slhc_vj.h
--- linux-2.6.13.1.org/include/net/slhc_vj.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/net/slhc_vj.h	2005-08-30 01:01:00.000000000 +0200
@@ -3,7 +3,7 @@
 /*
  * Definitions for tcp compression routines.
  *
- * $Header$
+ * $Header$
  *
  * Copyright (c) 1989 Regents of the University of California.
  * All rights reserved.
diff -Nur linux-2.6.13.1.org/include/net/snmp.h grsecurity226/include/net/snmp.h
--- linux-2.6.13.1.org/include/net/snmp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/net/snmp.h	2005-08-30 01:01:00.000000000 +0200
@@ -14,7 +14,7 @@
  *		as published by the Free Software Foundation; either version
  *		2 of the License, or (at your option) any later version.
  *
- *		$Id$
+ *		$Id$
  *
  */
  
diff -Nur linux-2.6.13.1.org/include/sound/uda1341.h grsecurity226/include/sound/uda1341.h
--- linux-2.6.13.1.org/include/sound/uda1341.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/sound/uda1341.h	2005-08-30 01:01:00.000000000 +0200
@@ -15,7 +15,7 @@
  *                           features support
  */
 
-/* $Id$ */
+/* $Id$ */
 
 #define UDA1341_ALSA_NAME "snd-uda1341"
 
diff -Nur linux-2.6.13.1.org/include/video/aty128.h grsecurity226/include/video/aty128.h
--- linux-2.6.13.1.org/include/video/aty128.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/video/aty128.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,4 +1,4 @@
-/*  $Id$
+/*  $Id$
  *  linux/drivers/video/aty128.h
  *  Register definitions for ATI Rage128 boards
  *
diff -Nur linux-2.6.13.1.org/include/video/cvisionppc.h grsecurity226/include/video/cvisionppc.h
--- linux-2.6.13.1.org/include/video/cvisionppc.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/video/cvisionppc.h	2005-08-30 01:01:00.000000000 +0200
@@ -4,7 +4,7 @@
  *
  * Copyright (c) 1998-1999 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
  * --------------------------------------------------------------------------
- * $Id$
+ * $Id$
  * --------------------------------------------------------------------------
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive
diff -Nur linux-2.6.13.1.org/include/video/iga.h grsecurity226/include/video/iga.h
--- linux-2.6.13.1.org/include/video/iga.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/video/iga.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * iga1682.h: Sparc/PCI iga1682 driver constants etc.
  *
  * Copyleft 1998 V. Roganov and G. Raiko
diff -Nur linux-2.6.13.1.org/include/video/newport.h grsecurity226/include/video/newport.h
--- linux-2.6.13.1.org/include/video/newport.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/video/newport.h	2005-08-30 01:01:00.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  *
  * newport.h: Defines and register layout for NEWPORT graphics
  *            hardware.
diff -Nur linux-2.6.13.1.org/include/video/permedia2.h grsecurity226/include/video/permedia2.h
--- linux-2.6.13.1.org/include/video/permedia2.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/video/permedia2.h	2005-08-30 01:01:00.000000000 +0200
@@ -2,7 +2,7 @@
  * Permedia2 framebuffer driver definitions.
  * Copyright (c) 1998-2000 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
  * --------------------------------------------------------------------------
- * $Id$
+ * $Id$
  * --------------------------------------------------------------------------
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive
diff -Nur linux-2.6.13.1.org/include/video/pm3fb.h grsecurity226/include/video/pm3fb.h
--- linux-2.6.13.1.org/include/video/pm3fb.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/video/pm3fb.h	2005-08-30 01:01:00.000000000 +0200
@@ -8,7 +8,7 @@
  *  License. See the file COPYING in the main directory of this archive for
  *  more details.
  *
- *  $Header$
+ *  $Header$
  *
  */
 
diff -Nur linux-2.6.13.1.org/include/video/tgafb.h grsecurity226/include/video/tgafb.h
--- linux-2.6.13.1.org/include/video/tgafb.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/include/video/tgafb.h	2005-08-30 01:01:01.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *  	Copyright (C) 1999,2000 Martin Lucina, Tom Zerucha
  *  
- *  $Id$
+ *  $Id$
  *
  *  This file is subject to the terms and conditions of the GNU General Public
  *  License. See the file COPYING in the main directory of this archive for
diff -Nur linux-2.6.13.1.org/init/Kconfig grsecurity226/init/Kconfig
--- linux-2.6.13.1.org/init/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/init/Kconfig	2005-08-30 01:15:05.000000000 +0200
@@ -249,6 +249,7 @@
 config KALLSYMS
 	 bool "Load all symbols for debugging/kksymoops" if EMBEDDED
 	 default y
+	 depends on !GRKERNSEC_HIDESYM
 	 help
 	   Say Y here to let the kernel print out symbolic crash information and
 	   symbolic stack backtraces. This increases the size of the kernel
diff -Nur linux-2.6.13.1.org/init/main.c grsecurity226/init/main.c
--- linux-2.6.13.1.org/init/main.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/init/main.c	2005-08-30 01:15:05.000000000 +0200
@@ -100,6 +100,7 @@
 #else
 static inline void acpi_early_init(void) { }
 #endif
+extern void grsecurity_init(void);
 
 #ifdef CONFIG_TC
 extern void tc_init(void);
@@ -153,6 +154,15 @@
 
 __setup("maxcpus=", maxcpus);
 
+#ifdef CONFIG_PAX_SOFTMODE
+static int __init setup_pax_softmode(char *str)
+{
+	get_option(&str, &pax_softmode);
+	return 1;
+}
+__setup("pax_softmode=", setup_pax_softmode);
+#endif
+
 static char * argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
 char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
 static const char *panic_later, *panic_param;
@@ -684,6 +694,7 @@
 		execute_command = "/init";
 	else
 		prepare_namespace();
+	grsecurity_init();
 
 	/*
 	 * Ok, we have completed the initial bootup, and
diff -Nur linux-2.6.13.1.org/ipc/msg.c grsecurity226/ipc/msg.c
--- linux-2.6.13.1.org/ipc/msg.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/ipc/msg.c	2005-08-30 01:15:08.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/sched.h>
 #include <linux/syscalls.h>
 #include <linux/audit.h>
+#include <linux/grsecurity.h>
 #include <asm/current.h>
 #include <asm/uaccess.h>
 #include "util.h"
@@ -230,6 +231,9 @@
 		msg_unlock(msq);
 	}
 	up(&msg_ids.sem);
+
+	gr_log_msgget(ret, msgflg);
+
 	return ret;
 }
 
@@ -481,6 +485,8 @@
 		break;
 	}
 	case IPC_RMID:
+		gr_log_msgrm(ipcp->uid, ipcp->cuid);
+
 		freeque (msq, msqid); 
 		break;
 	}
diff -Nur linux-2.6.13.1.org/ipc/sem.c grsecurity226/ipc/sem.c
--- linux-2.6.13.1.org/ipc/sem.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/ipc/sem.c	2005-08-30 01:15:08.000000000 +0200
@@ -73,6 +73,7 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/audit.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -240,6 +241,9 @@
 	}
 
 	up(&sem_ids.sem);
+
+	gr_log_semget(err, semflg);
+
 	return err;
 }
 
@@ -829,6 +833,8 @@
 
 	switch(cmd){
 	case IPC_RMID:
+		gr_log_semrm(ipcp->uid, ipcp->cuid);
+
 		freeary(sma, semid);
 		err = 0;
 		break;
diff -Nur linux-2.6.13.1.org/ipc/shm.c grsecurity226/ipc/shm.c
--- linux-2.6.13.1.org/ipc/shm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/ipc/shm.c	2005-08-30 01:15:08.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/syscalls.h>
 #include <linux/audit.h>
 #include <linux/ptrace.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -54,6 +55,14 @@
 static int sysvipc_shm_read_proc(char *buffer, char **start, off_t offset, int length, int *eof, void *data);
 #endif
 
+#ifdef CONFIG_GRKERNSEC
+extern int gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+			   const time_t shm_createtime, const uid_t cuid,
+			   const int shmid);
+extern int gr_chroot_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+			   const time_t shm_createtime);
+#endif
+
 size_t	shm_ctlmax = SHMMAX;
 size_t 	shm_ctlall = SHMALL;
 int 	shm_ctlmni = SHMMNI;
@@ -146,6 +155,17 @@
 	shp->shm_lprid = current->tgid;
 	shp->shm_dtim = get_seconds();
 	shp->shm_nattch--;
+#ifdef CONFIG_GRKERNSEC_SHM
+	if (grsec_enable_shm) {
+		if (shp->shm_nattch == 0) {
+			shp->shm_flags |= SHM_DEST;
+			shm_destroy(shp);
+		} else
+			shm_unlock(shp);
+		up(&shm_ids.sem);
+		return;
+	}
+#endif
 	if(shp->shm_nattch == 0 &&
 	   shp->shm_flags & SHM_DEST)
 		shm_destroy (shp);
@@ -227,6 +247,9 @@
 	shp->shm_lprid = 0;
 	shp->shm_atim = shp->shm_dtim = 0;
 	shp->shm_ctim = get_seconds();
+#ifdef CONFIG_GRKERNSEC
+	shp->shm_createtime = get_seconds();
+#endif
 	shp->shm_segsz = size;
 	shp->shm_nattch = 0;
 	shp->id = shm_buildid(id,shp->shm_perm.seq);
@@ -281,6 +304,8 @@
 	}
 	up(&shm_ids.sem);
 
+	gr_log_shmget(err, shmflg, size);
+
 	return err;
 }
 
@@ -586,6 +611,8 @@
 		if (err)
 			goto out_unlock_up;
 
+		gr_log_shmrm(shp->shm_perm.uid, shp->shm_perm.cuid);
+
 		if (shp->shm_nattch){
 			shp->shm_flags |= SHM_DEST;
 			/* Do not find it any more */
@@ -730,9 +757,27 @@
 		return err;
 	}
 		
+#ifdef CONFIG_GRKERNSEC
+	if (!gr_handle_shmat(shp->shm_cprid, shp->shm_lapid, shp->shm_createtime,
+			     shp->shm_perm.cuid, shmid)) {
+		shm_unlock(shp);
+		return -EACCES;
+	}
+
+	if (!gr_chroot_shmat(shp->shm_cprid, shp->shm_lapid, shp->shm_createtime)) {
+		shm_unlock(shp);
+		return -EACCES;
+	}
+#endif
+
 	file = shp->shm_file;
 	size = i_size_read(file->f_dentry->d_inode);
 	shp->shm_nattch++;
+
+#ifdef CONFIG_GRKERNSEC
+	shp->shm_lapid = current->pid;
+#endif
+
 	shm_unlock(shp);
 
 	down_write(&current->mm->mmap_sem);
@@ -929,3 +974,24 @@
 	return len;
 }
 #endif
+
+void gr_shm_exit(struct task_struct *task)
+{
+#ifdef CONFIG_GRKERNSEC_SHM
+	int i;
+	struct shmid_kernel *shp;
+
+	if (!grsec_enable_shm)
+		return;
+
+	for (i = 0; i <= shm_ids.max_id; i++) {
+		shp = shm_get(i);
+		if (shp && (shp->shm_cprid == task->pid) &&
+		    (shp->shm_nattch <= 0)) {
+			shp->shm_flags |= SHM_DEST;
+			shm_destroy(shp);
+		}
+	}
+#endif
+	return;
+}
diff -Nur linux-2.6.13.1.org/kernel/capability.c grsecurity226/kernel/capability.c
--- linux-2.6.13.1.org/kernel/capability.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/capability.c	2005-08-30 01:15:10.000000000 +0200
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/security.h>
 #include <linux/syscalls.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 
 unsigned securebits = SECUREBITS_DEFAULT; /* systemwide security settings */
diff -Nur linux-2.6.13.1.org/kernel/configs.c grsecurity226/kernel/configs.c
--- linux-2.6.13.1.org/kernel/configs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/configs.c	2005-08-30 01:15:10.000000000 +0200
@@ -89,8 +89,16 @@
 	struct proc_dir_entry *entry;
 
 	/* create the current config file */
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	entry = create_proc_entry("config.gz", S_IFREG | S_IRUSR, &proc_root);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	entry = create_proc_entry("config.gz", S_IFREG | S_IRUSR | S_IRGRP, &proc_root);
+#endif
+#else
 	entry = create_proc_entry("config.gz", S_IFREG | S_IRUGO,
 				  &proc_root);
+#endif
 	if (!entry)
 		return -ENOMEM;
 
diff -Nur linux-2.6.13.1.org/kernel/dma.c grsecurity226/kernel/dma.c
--- linux-2.6.13.1.org/kernel/dma.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/dma.c	2005-08-30 01:01:01.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id$
+/* $Id$
  * linux/kernel/dma.c: A DMA channel allocator. Inspired by linux/kernel/irq.c.
  *
  * Written by Hennus Bergman, 1992.
diff -Nur linux-2.6.13.1.org/kernel/exit.c grsecurity226/kernel/exit.c
--- linux-2.6.13.1.org/kernel/exit.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/exit.c	2005-08-30 01:15:10.000000000 +0200
@@ -28,6 +28,11 @@
 #include <linux/cpuset.h>
 #include <linux/syscalls.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
+
+#ifdef CONFIG_GRKERNSEC
+extern rwlock_t grsec_exec_file_lock;
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -232,6 +237,15 @@
 {
 	write_lock_irq(&tasklist_lock);
 
+#ifdef CONFIG_GRKERNSEC
+	write_lock(&grsec_exec_file_lock);
+	if (current->exec_file) {
+		fput(current->exec_file);
+		current->exec_file = NULL;
+	}
+	write_unlock(&grsec_exec_file_lock);
+#endif
+
 	ptrace_unlink(current);
 	/* Reparent to init */
 	REMOVE_LINKS(current);
@@ -239,6 +253,8 @@
 	current->real_parent = child_reaper;
 	SET_LINKS(current);
 
+	gr_set_kernel_label(current);
+
 	/* Set the exit signal to SIGCHLD so we signal init on exit */
 	current->exit_signal = SIGCHLD;
 
@@ -333,6 +349,17 @@
 	vsnprintf(current->comm, sizeof(current->comm), name, args);
 	va_end(args);
 
+#ifdef CONFIG_GRKERNSEC
+	write_lock(&grsec_exec_file_lock);
+	if (current->exec_file) {
+		fput(current->exec_file);
+		current->exec_file = NULL;
+	}
+	write_unlock(&grsec_exec_file_lock);
+#endif
+
+	gr_set_kernel_label(current);
+
 	/*
 	 * If we were started as result of loading a module, close all of the
 	 * user space pages.  We don't need them, and if we didn't close them
@@ -833,9 +860,14 @@
  		del_timer_sync(&tsk->signal->real_timer);
 		acct_process(code);
 	}
+
+	gr_acl_handle_psacct(tsk, code);
+	gr_acl_handle_exit();
+
 	exit_mm(tsk);
 
 	exit_sem(tsk);
+	gr_shm_exit(tsk);
 	__exit_files(tsk);
 	__exit_fs(tsk);
 	exit_namespace(tsk);
diff -Nur linux-2.6.13.1.org/kernel/fork.c grsecurity226/kernel/fork.c
--- linux-2.6.13.1.org/kernel/fork.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/fork.c	2005-08-30 01:15:10.000000000 +0200
@@ -41,6 +41,7 @@
 #include <linux/profile.h>
 #include <linux/rmap.h>
 #include <linux/acct.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -193,7 +194,7 @@
 	mm->locked_vm = 0;
 	mm->mmap = NULL;
 	mm->mmap_cache = NULL;
-	mm->free_area_cache = oldmm->mmap_base;
+	mm->free_area_cache = oldmm->free_area_cache;
 	mm->cached_hole_size = ~0UL;
 	mm->map_count = 0;
 	set_mm_counter(mm, rss, 0);
@@ -325,7 +326,6 @@
 	rwlock_init(&mm->ioctx_list_lock);
 	mm->ioctx_list = NULL;
 	mm->default_kioctx = (struct kioctx)INIT_KIOCTX(mm->default_kioctx, *mm);
-	mm->free_area_cache = TASK_UNMAPPED_BASE;
 	mm->cached_hole_size = ~0UL;
 
 	if (likely(!mm_alloc_pgd(mm))) {
@@ -879,6 +879,9 @@
 		goto fork_out;
 
 	retval = -EAGAIN;
+
+	gr_learn_resource(p, RLIMIT_NPROC, atomic_read(&p->user->processes), 0);
+
 	if (atomic_read(&p->user->processes) >=
 			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {
 		if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&
@@ -983,6 +986,8 @@
 	if (retval)
 		goto bad_fork_cleanup_namespace;
 
+	gr_copy_label(p);
+
 	p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;
 	/*
 	 * Clear TID on mm_release()?
@@ -1158,6 +1163,9 @@
 	free_uid(p->user);
 bad_fork_free:
 	free_task(p);
+
+	gr_log_forkfail(retval);
+
 	goto fork_out;
 }
 
@@ -1215,6 +1223,9 @@
 
 	if (pid < 0)
 		return -EAGAIN;
+
+	gr_handle_brute_check();
+
 	if (unlikely(current->ptrace)) {
 		trace = fork_traceflag (clone_flags);
 		if (trace)
diff -Nur linux-2.6.13.1.org/kernel/futex.c grsecurity226/kernel/futex.c
--- linux-2.6.13.1.org/kernel/futex.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/futex.c	2005-08-30 01:15:10.000000000 +0200
@@ -146,6 +146,11 @@
 	struct page *page;
 	int err;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (uaddr >= SEGMEXEC_TASK_SIZE))
+		return -EFAULT;
+#endif
+
 	/*
 	 * The futex address must be "naturally" aligned.
 	 */
diff -Nur linux-2.6.13.1.org/kernel/kallsyms.c grsecurity226/kernel/kallsyms.c
--- linux-2.6.13.1.org/kernel/kallsyms.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/kallsyms.c	2005-08-30 01:15:10.000000000 +0200
@@ -410,7 +410,15 @@
 {
 	struct proc_dir_entry *entry;
 
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	entry = create_proc_entry("kallsyms", S_IFREG | S_IRUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	entry = create_proc_entry("kallsyms", S_IFREG | S_IRUSR | S_IRGRP, NULL);
+#endif
+#else
 	entry = create_proc_entry("kallsyms", 0444, NULL);
+#endif
 	if (entry)
 		entry->proc_fops = &kallsyms_operations;
 	return 0;
diff -Nur linux-2.6.13.1.org/kernel/pid.c grsecurity226/kernel/pid.c
--- linux-2.6.13.1.org/kernel/pid.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/pid.c	2005-08-30 01:15:10.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/bootmem.h>
 #include <linux/hash.h>
+#include <linux/grsecurity.h>
 
 #define pid_hashfn(nr) hash_long((unsigned long)nr, pidhash_shift)
 static struct hlist_head *pid_hash[PIDTYPE_MAX];
@@ -76,7 +77,9 @@
 	int i, offset, max_scan, pid, last = last_pid;
 	pidmap_t *map;
 
-	pid = last + 1;
+	pid = gr_random_pid();
+	if (!pid)
+		pid = last_pid + 1;
 	if (pid >= pid_max)
 		pid = RESERVED_PIDS;
 	offset = pid & BITS_PER_PAGE_MASK;
@@ -207,12 +210,18 @@
 task_t *find_task_by_pid_type(int type, int nr)
 {
 	struct pid *pid;
+	task_t *task = NULL;
 
 	pid = find_pid(type, nr);
 	if (!pid)
 		return NULL;
 
-	return pid_task(&pid->pid_list, type);
+	task = pid_task(&pid->pid_list, type);
+
+	if (gr_pid_is_chrooted(task))
+		return NULL;
+
+	return task;
 }
 
 EXPORT_SYMBOL(find_task_by_pid_type);
diff -Nur linux-2.6.13.1.org/kernel/posix-cpu-timers.c grsecurity226/kernel/posix-cpu-timers.c
--- linux-2.6.13.1.org/kernel/posix-cpu-timers.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/posix-cpu-timers.c	2005-08-30 01:15:11.000000000 +0200
@@ -6,6 +6,7 @@
 #include <linux/posix-timers.h>
 #include <asm/uaccess.h>
 #include <linux/errno.h>
+#include <linux/grsecurity.h>
 
 static int check_clock(clockid_t which_clock)
 {
@@ -1129,6 +1130,7 @@
 			__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);
 			return;
 		}
+		gr_learn_resource(tsk, RLIMIT_CPU, psecs, 1);
 		if (psecs >= sig->rlim[RLIMIT_CPU].rlim_cur) {
 			/*
 			 * At the soft limit, send a SIGXCPU every second.
diff -Nur linux-2.6.13.1.org/kernel/printk.c grsecurity226/kernel/printk.c
--- linux-2.6.13.1.org/kernel/printk.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/printk.c	2005-08-30 01:15:11.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/security.h>
 #include <linux/bootmem.h>
 #include <linux/syscalls.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -224,6 +225,11 @@
 	char c;
 	int error = 0;
 
+#ifdef CONFIG_GRKERNSEC_DMESG
+	if (grsec_enable_dmesg && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+#endif
+
 	error = security_syslog(type);
 	if (error)
 		return error;
diff -Nur linux-2.6.13.1.org/kernel/resource.c grsecurity226/kernel/resource.c
--- linux-2.6.13.1.org/kernel/resource.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/resource.c	2005-08-30 01:15:11.000000000 +0200
@@ -136,10 +136,27 @@
 {
 	struct proc_dir_entry *entry;
 
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	entry = create_proc_entry("ioports", S_IRUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	entry = create_proc_entry("ioports", S_IRUSR | S_IRGRP, NULL);
+#endif
+#else
 	entry = create_proc_entry("ioports", 0, NULL);
+#endif
 	if (entry)
 		entry->proc_fops = &proc_ioports_operations;
+
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	entry = create_proc_entry("iomem", S_IRUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	entry = create_proc_entry("iomem", S_IRUSR | S_IRGRP, NULL);
+#endif
+#else
 	entry = create_proc_entry("iomem", 0, NULL);
+#endif
 	if (entry)
 		entry->proc_fops = &proc_iomem_operations;
 	return 0;
diff -Nur linux-2.6.13.1.org/kernel/sched.c grsecurity226/kernel/sched.c
--- linux-2.6.13.1.org/kernel/sched.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/sched.c	2005-08-30 01:15:11.000000000 +0200
@@ -47,6 +47,7 @@
 #include <linux/syscalls.h>
 #include <linux/times.h>
 #include <linux/acct.h>
+#include <linux/grsecurity.h>
 #include <asm/tlb.h>
 
 #include <asm/unistd.h>
@@ -3414,7 +3415,8 @@
 	if (nice > 19)
 		nice = 19;
 
-	if (increment < 0 && !can_nice(current, nice))
+	if (increment < 0 && (!can_nice(current, nice) ||
+			      gr_handle_chroot_nice()))
 		return -EPERM;
 
 	retval = security_task_setnice(current, nice);
diff -Nur linux-2.6.13.1.org/kernel/signal.c grsecurity226/kernel/signal.c
--- linux-2.6.13.1.org/kernel/signal.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/signal.c	2005-08-30 01:15:11.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/posix-timers.h>
 #include <linux/signal.h>
 #include <linux/audit.h>
+#include <linux/grsecurity.h>
 #include <asm/param.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -358,6 +359,7 @@
 		posix_cpu_timers_exit_group(tsk);
 		if (tsk == sig->curr_target)
 			sig->curr_target = next_thread(tsk);
+		gr_del_task_from_ip_table(tsk);
 		tsk->signal = NULL;
 		spin_unlock(&sighand->siglock);
 		flush_sigqueue(&sig->shared_pending);
@@ -663,16 +665,18 @@
 	error = -EPERM;
 	if ((!info || ((unsigned long)info != 1 &&
 			(unsigned long)info != 2 && SI_FROMUSER(info)))
-	    && ((sig != SIGCONT) ||
+	    && ((((sig != SIGCONT) ||
 		(current->signal->session != t->signal->session))
 	    && (current->euid ^ t->suid) && (current->euid ^ t->uid)
 	    && (current->uid ^ t->suid) && (current->uid ^ t->uid)
-	    && !capable(CAP_KILL))
+	    && !capable(CAP_KILL)) || gr_handle_signal(t, sig)))
 		return error;
 
 	error = security_task_kill(t, info, sig);
-	if (!error)
+	if (!error) {
 		audit_signal_info(sig, t); /* Let audit system see the signal */
+		gr_log_signal(sig, t);
+	}
 	return error;
 }
 
@@ -873,7 +877,7 @@
 	(((sig) < SIGRTMIN) && sigismember(&(sigptr)->signal, (sig)))
 
 
-static int
+int
 specific_send_sig_info(int sig, struct siginfo *info, struct task_struct *t)
 {
 	int ret = 0;
@@ -923,6 +927,10 @@
 		recalc_sigpending_tsk(t);
 	}
 	ret = specific_send_sig_info(sig, info, t);
+
+	gr_log_signal(sig, t);
+	gr_handle_crash(t, sig);
+
 	spin_unlock_irqrestore(&t->sighand->siglock, flags);
 
 	return ret;
diff -Nur linux-2.6.13.1.org/kernel/sys.c grsecurity226/kernel/sys.c
--- linux-2.6.13.1.org/kernel/sys.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/sys.c	2005-08-30 01:15:11.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/suspend.h>
 #include <linux/tty.h>
 #include <linux/signal.h>
+#include <linux/grsecurity.h>
 
 #include <linux/compat.h>
 #include <linux/syscalls.h>
@@ -234,6 +235,12 @@
 		error = -EACCES;
 		goto out;
 	}
+
+	if (gr_handle_chroot_setpriority(p, niceval)) {
+		error = -EACCES;
+		goto out;
+	}
+
 	no_nice = security_task_setnice(p, niceval);
 	if (no_nice) {
 		error = no_nice;
@@ -579,6 +586,9 @@
 	if (rgid != (gid_t) -1 ||
 	    (egid != (gid_t) -1 && egid != old_rgid))
 		current->sgid = new_egid;
+
+	gr_set_role_label(current, current->uid, new_rgid);
+
 	current->fsgid = new_egid;
 	current->egid = new_egid;
 	current->gid = new_rgid;
@@ -607,6 +617,9 @@
 			current->mm->dumpable = suid_dumpable;
 			smp_wmb();
 		}
+
+		gr_set_role_label(current, current->uid, gid);
+
 		current->gid = current->egid = current->sgid = current->fsgid = gid;
 	}
 	else if ((gid == current->gid) || (gid == current->sgid))
@@ -647,6 +660,9 @@
 		current->mm->dumpable = suid_dumpable;
 		smp_wmb();
 	}
+
+	gr_set_role_label(current, new_ruid, current->gid);
+
 	current->uid = new_ruid;
 	return 0;
 }
@@ -749,6 +765,9 @@
 	} else if ((uid != current->uid) && (uid != new_suid))
 		return -EPERM;
 
+	if (gr_check_crash_uid(uid))
+		return -EPERM;
+
 	if (old_euid != uid)
 	{
 		current->mm->dumpable = suid_dumpable;
@@ -852,8 +871,10 @@
 		current->egid = egid;
 	}
 	current->fsgid = current->egid;
-	if (rgid != (gid_t) -1)
+	if (rgid != (gid_t) -1) {
+		gr_set_role_label(current, current->uid, rgid);
 		current->gid = rgid;
+	}
 	if (sgid != (gid_t) -1)
 		current->sgid = sgid;
 
diff -Nur linux-2.6.13.1.org/kernel/sysctl.c grsecurity226/kernel/sysctl.c
--- linux-2.6.13.1.org/kernel/sysctl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/sysctl.c	2005-09-05 18:42:11.000000000 +0200
@@ -50,6 +50,14 @@
 #endif
 
 #if defined(CONFIG_SYSCTL)
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+extern __u32 gr_handle_sysctl(const ctl_table *table, const void *oldval,
+			      const void *newval);
+extern int gr_handle_sysctl_mod(const char *dirname, const char *name,
+				const int op);
+extern int gr_handle_chroot_sysctl(const int op);
 
 /* External variables not in a header file. */
 extern int C_A_D;
@@ -154,6 +162,22 @@
 #ifdef HAVE_ARCH_PICK_MMAP_LAYOUT
 int sysctl_legacy_va_layout;
 #endif
+extern ctl_table grsecurity_table[];
+
+#ifdef CONFIG_PAX_SOFTMODE
+static ctl_table pax_table[] = {
+	{
+		.ctl_name	= PAX_SOFTMODE,
+		.procname	= "softmode",
+		.data		= &pax_softmode,
+		.maxlen		= sizeof(unsigned int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+
+	{ .ctl_name = 0 }
+};
+#endif
 
 /* /proc declarations: */
 
@@ -658,6 +682,24 @@
 		.proc_handler	= &proc_dointvec,
 	},
 #endif
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+	{
+		.ctl_name	= KERN_GRSECURITY,
+		.procname	= "grsecurity",
+		.mode		= 0500,
+		.child		= grsecurity_table,
+	},
+#endif
+
+#ifdef CONFIG_PAX_SOFTMODE
+	{
+		.ctl_name	= KERN_PAX,
+		.procname	= "pax",
+		.mode		= 0500,
+		.child		= pax_table,
+	},
+#endif
+
 	{ .ctl_name = 0 }
 };
 
@@ -1064,6 +1106,10 @@
 static inline int ctl_perm(ctl_table *table, int op)
 {
 	int error;
+	if (table->de && gr_handle_sysctl_mod(table->de->parent->name, table->de->name, op))
+		return -EACCES;
+	if (gr_handle_chroot_sysctl(op))
+		return -EACCES;
 	error = security_sysctl(table, op);
 	if (error)
 		return error;
@@ -1100,6 +1146,10 @@
 				table = table->child;
 				goto repeat;
 			}
+
+			if (!gr_handle_sysctl(table, oldval, newval))
+				return -EACCES;
+
 			error = do_sysctl_strategy(table, name, nlen,
 						   oldval, oldlenp,
 						   newval, newlen, context);
diff -Nur linux-2.6.13.1.org/kernel/time.c grsecurity226/kernel/time.c
--- linux-2.6.13.1.org/kernel/time.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/kernel/time.c	2005-08-30 01:15:11.000000000 +0200
@@ -35,6 +35,7 @@
 #include <linux/security.h>
 #include <linux/fs.h>
 #include <linux/module.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -92,6 +93,9 @@
 		return err;
 
 	do_settimeofday(&tv);
+
+	gr_log_timechange();
+
 	return 0;
 }
 
@@ -195,6 +199,8 @@
 			return -EFAULT;
 	}
 
+	gr_log_timechange();
+
 	return do_sys_settimeofday(tv ? &new_ts : NULL, tz ? &new_tz : NULL);
 }
 
diff -Nur linux-2.6.13.1.org/lib/reed_solomon/decode_rs.c grsecurity226/lib/reed_solomon/decode_rs.c
--- linux-2.6.13.1.org/lib/reed_solomon/decode_rs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/lib/reed_solomon/decode_rs.c	2005-08-30 01:01:01.000000000 +0200
@@ -9,7 +9,7 @@
  *
  * Adaption to the kernel by Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/lib/reed_solomon/encode_rs.c grsecurity226/lib/reed_solomon/encode_rs.c
--- linux-2.6.13.1.org/lib/reed_solomon/encode_rs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/lib/reed_solomon/encode_rs.c	2005-08-30 01:01:01.000000000 +0200
@@ -9,7 +9,7 @@
  *
  * Adaption to the kernel by Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id$
+ * $Id$
  *
  */
 
diff -Nur linux-2.6.13.1.org/lib/reed_solomon/reed_solomon.c grsecurity226/lib/reed_solomon/reed_solomon.c
--- linux-2.6.13.1.org/lib/reed_solomon/reed_solomon.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/lib/reed_solomon/reed_solomon.c	2005-08-30 01:01:01.000000000 +0200
@@ -9,7 +9,7 @@
  * Reed Solomon code lifted from reed solomon library written by Phil Karn
  * Copyright 2002 Phil Karn, KA9Q
  *
- * $Id$
+ * $Id$
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Nur linux-2.6.13.1.org/mm/filemap.c grsecurity226/mm/filemap.c
--- linux-2.6.13.1.org/mm/filemap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/filemap.c	2005-08-30 01:15:13.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/blkdev.h>
 #include <linux/security.h>
 #include <linux/syscalls.h>
+#include <linux/grsecurity.h>
 #include "filemap.h"
 /*
  * FIXME: remove all knowledge of the buffer layer from the core VM
@@ -1540,7 +1541,13 @@
 	struct address_space *mapping = file->f_mapping;
 
 	if (!mapping->a_ops->readpage)
-		return -ENOEXEC;
+		return -ENODEV;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC)
+		vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+#endif
+
 	file_accessed(file);
 	vma->vm_ops = &generic_file_vm_ops;
 	return 0;
@@ -1763,6 +1770,7 @@
                         *pos = i_size_read(inode);
 
 		if (limit != RLIM_INFINITY) {
+			gr_learn_resource(current, RLIMIT_FSIZE,*pos, 0);
 			if (*pos >= limit) {
 				send_sig(SIGXFSZ, current, 0);
 				return -EFBIG;
diff -Nur linux-2.6.13.1.org/mm/madvise.c grsecurity226/mm/madvise.c
--- linux-2.6.13.1.org/mm/madvise.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/madvise.c	2005-08-30 01:15:13.000000000 +0200
@@ -15,9 +15,46 @@
  * We can potentially split a vm area into separate
  * areas, each area with its own behavior.
  */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+static long __madvise_behavior(struct vm_area_struct * vma,
+		     struct vm_area_struct **prev,
+		     unsigned long start, unsigned long end, int behavior);
+
+static long madvise_behavior(struct vm_area_struct * vma,
+		     struct vm_area_struct **prev,
+		     unsigned long start, unsigned long end, int behavior)
+{
+	if (vma->vm_flags & VM_MIRROR) {
+		struct vm_area_struct * vma_m, * prev_m;
+		unsigned long start_m, end_m;
+		int error;
+
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(vma->vm_mm, start_m, &prev_m);
+		if (vma_m && vma_m->vm_start == start_m && (vma_m->vm_flags & VM_MIRROR)) {
+			start_m = start + vma->vm_mirror;
+			end_m = end + vma->vm_mirror;
+			error = __madvise_behavior(vma_m, &prev_m, start_m, end_m, behavior);
+			if (error)
+				return error;
+		} else {
+			printk("PAX: VMMIRROR: madvise bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+	}
+
+	return __madvise_behavior(vma, prev, start, end, behavior);
+}
+
+static long __madvise_behavior(struct vm_area_struct * vma,
+		     struct vm_area_struct **prev,
+		     unsigned long start, unsigned long end, int behavior)
+#else
 static long madvise_behavior(struct vm_area_struct * vma,
 		     struct vm_area_struct **prev,
 		     unsigned long start, unsigned long end, int behavior)
+#endif
 {
 	struct mm_struct * mm = vma->vm_mm;
 	int error = 0;
diff -Nur linux-2.6.13.1.org/mm/memory.c grsecurity226/mm/memory.c
--- linux-2.6.13.1.org/mm/memory.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/memory.c	2005-09-05 18:42:13.000000000 +0200
@@ -48,6 +48,7 @@
 #include <linux/rmap.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -1211,6 +1212,96 @@
 	lazy_mmu_prot_update(entry);
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+/* PaX: if vma is mirrored, synchronize the mirror's PTE
+ *
+ * mm->page_table_lock is held on entry and is not released on exit or inside
+ * to ensure atomic changes to the PTE states (swapout, mremap, munmap, etc)
+ */
+static void pax_mirror_fault(struct mm_struct *mm, struct vm_area_struct * vma,
+	unsigned long address, pte_t *pte)
+{
+	unsigned long address_m, pfn_m;
+	struct vm_area_struct * vma_m = NULL;
+	pte_t * pte_m, entry_m;
+	struct page * page_m = NULL;
+
+	address_m = vma->vm_start + vma->vm_mirror;
+	vma_m = find_vma(mm, address_m);
+	BUG_ON(!vma_m || vma_m->vm_start != address_m);
+
+	address_m = address + vma->vm_mirror;
+
+	{
+		pgd_t *pgd_m;
+		pud_t *pud_m;
+		pmd_t *pmd_m;
+
+		pgd_m = pgd_offset(mm, address_m);
+		pud_m = pud_offset(pgd_m, address_m);
+		pmd_m = pmd_offset(pud_m, address_m);
+		pte_m = pte_offset_map_nested(pmd_m, address_m);
+	}
+
+	if (pte_present(*pte_m)) {
+		pfn_m = pte_pfn(*pte_m);
+		if (pfn_valid(pfn_m)) {
+			page_m = pfn_to_page(pfn_m);
+			flush_cache_page(vma_m, address_m, pfn_m);
+			flush_icache_page(vma_m, page_m);
+		}
+	}
+	entry_m = ptep_get_and_clear(mm, address_m, pte_m);
+	if (pte_present(entry_m))
+		flush_tlb_page(vma_m, address_m);
+
+	if (pte_none(entry_m)) {
+		inc_mm_counter(mm, rss);
+	} else if (pte_present(entry_m)) {
+		if (page_m) {
+			if (PageAnon(page_m))
+				dec_mm_counter(mm, anon_rss);
+			if (!PageReserved(page_m)) {
+				page_remove_rmap(page_m);
+				page_cache_release(page_m);
+			} else
+				inc_mm_counter(mm, rss);
+		} else
+			inc_mm_counter(mm, rss);
+	} else if (!pte_file(entry_m)) {
+		free_swap_and_cache(pte_to_swp_entry(entry_m));
+		inc_mm_counter(mm, rss);
+	} else {
+		printk(KERN_ERR "PAX: VMMIRROR: bug in mirror_fault: %08lx, %08lx, %08lx, %08lx\n",
+				address, vma->vm_start, address_m, vma_m->vm_start);
+	}
+
+	pfn_m = pte_pfn(*pte);
+	page_m = NULL;
+	if (pfn_valid(pfn_m))
+		page_m = pfn_to_page(pfn_m);
+	entry_m = pfn_pte(pfn_m, vma_m->vm_page_prot);
+	if (pte_write(*pte))
+		entry_m = maybe_mkwrite(pte_mkdirty(entry_m), vma_m);
+	if (page_m && !PageReserved(page_m)) {
+		page_cache_get(page_m);
+		/*
+		 * we can test PAGE_MAPPING_ANON without holding page_map_lock because
+		 * we hold the page table lock and have a reference to page_m
+		 */
+		if (PageAnon(page_m))
+			page_add_anon_rmap(page_m, vma_m, address_m);
+		else
+			page_add_file_rmap(page_m);
+	} else
+		dec_mm_counter(mm, rss);
+	set_pte_at(mm, address_m, pte_m, entry_m);
+	update_mmu_cache(vma_m, address_m, entry_m);
+	lazy_mmu_prot_update(entry_m);
+	pte_unmap_nested(pte_m);
+}
+#endif
+
 /*
  * This routine handles present pages, when users try to write
  * to a shared page. It is done by copying the page to a new address
@@ -1310,6 +1401,12 @@
 		/* Free the old page.. */
 		new_page = old_page;
 		ret |= VM_FAULT_WRITE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			pax_mirror_fault(mm, vma, address, page_table);
+#endif
+
 	}
 	pte_unmap(page_table);
 	page_cache_release(new_page);
@@ -1565,6 +1662,7 @@
 
 do_expand:
 	limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
+	gr_learn_resource(current, RLIMIT_FSIZE, offset, 1);
 	if (limit != RLIM_INFINITY && offset > limit)
 		goto out_sig;
 	if (offset > inode->i_sb->s_maxbytes)
@@ -1729,6 +1827,12 @@
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, address, pte);
 	lazy_mmu_prot_update(pte);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(mm, vma, address, page_table);
+#endif
+
 	pte_unmap(page_table);
 	spin_unlock(&mm->page_table_lock);
 out:
@@ -1788,11 +1892,17 @@
 	}
 
 	set_pte_at(mm, addr, page_table, entry);
-	pte_unmap(page_table);
 
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, addr, entry);
 	lazy_mmu_prot_update(entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(mm, vma, addr, page_table);
+#endif
+
+	pte_unmap(page_table);
 	spin_unlock(&mm->page_table_lock);
 out:
 	return VM_FAULT_MINOR;
@@ -1907,6 +2017,16 @@
 			page_add_anon_rmap(new_page, vma, address);
 		} else
 			page_add_file_rmap(new_page);
+
+		/* no need to invalidate: a not-present page shouldn't be cached */
+		update_mmu_cache(vma, address, entry);
+		lazy_mmu_prot_update(entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			pax_mirror_fault(mm, vma, address, page_table);
+#endif
+
 		pte_unmap(page_table);
 	} else {
 		/* One of our sibling threads was faster, back out. */
@@ -1916,9 +2036,6 @@
 		goto out;
 	}
 
-	/* no need to invalidate: a not-present page shouldn't be cached */
-	update_mmu_cache(vma, address, entry);
-	lazy_mmu_prot_update(entry);
 	spin_unlock(&mm->page_table_lock);
 out:
 	return ret;
@@ -2029,6 +2146,11 @@
 	pmd_t *pmd;
 	pte_t *pte;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	unsigned long address_m = 0UL;
+	struct vm_area_struct * vma_m = NULL;
+#endif
+
 	__set_current_state(TASK_RUNNING);
 
 	inc_page_state(pgfault);
@@ -2043,6 +2165,45 @@
 	pgd = pgd_offset(mm, address);
 	spin_lock(&mm->page_table_lock);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		pgd_t *pgd_m;
+		pud_t *pud_m;
+		pmd_t *pmd_m = NULL;
+		pte_t *pte_m = NULL;
+
+		address_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma(mm, address_m);
+
+		/* PaX: sanity checks */
+		if (!vma_m) {
+			spin_unlock(&mm->page_table_lock);
+			printk(KERN_ERR "PAX: VMMIRROR: fault bug, %08lx, %p, %08lx, %p\n",
+			       address, vma, address_m, vma_m);
+			return VM_FAULT_SIGBUS;
+		} else if (!(vma_m->vm_flags & VM_MIRROR) ||
+			vma_m->vm_start != address_m ||
+			vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start)
+		{
+			spin_unlock(&mm->page_table_lock);
+			printk(KERN_ERR "PAX: VMMIRROR: fault bug2, %08lx, %08lx, %08lx, %08lx, %08lx\n",
+			       address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+			return VM_FAULT_SIGBUS;
+		}
+
+		address_m = address + vma->vm_mirror;
+		pgd_m = pgd_offset(mm, address_m);
+		pud_m = pud_alloc(mm, pgd_m, address_m);
+		if (pud_m)
+			pmd_m = pmd_alloc(mm, pud_m, address_m);
+		if (pmd_m)
+			pte_m = pte_alloc_map(mm, pmd_m, address_m);
+		if (!pud_m || !pmd_m || !pte_m)
+			goto oom;
+		pte_unmap(pte_m);
+	}
+#endif
+
 	pud = pud_alloc(mm, pgd, address);
 	if (!pud)
 		goto oom;
diff -Nur linux-2.6.13.1.org/mm/mempolicy.c grsecurity226/mm/mempolicy.c
--- linux-2.6.13.1.org/mm/mempolicy.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/mempolicy.c	2005-08-30 01:15:13.000000000 +0200
@@ -332,6 +332,12 @@
 			return ERR_PTR(-EFAULT);
 		if (prev && prev->vm_end < vma->vm_start)
 			return ERR_PTR(-EFAULT);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			return ERR_PTR(-EFAULT);
+#endif
+
 		if ((flags & MPOL_MF_STRICT) && !is_vm_hugetlb_page(vma)) {
 			err = check_pgd_range(vma->vm_mm,
 					   vma->vm_start, vma->vm_end, nodes);
diff -Nur linux-2.6.13.1.org/mm/mlock.c grsecurity226/mm/mlock.c
--- linux-2.6.13.1.org/mm/mlock.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/mlock.c	2005-09-06 04:15:34.000000000 +0200
@@ -9,14 +9,85 @@
 #include <linux/mm.h>
 #include <linux/mempolicy.h>
 #include <linux/syscalls.h>
+#include <linux/grsecurity.h>
 
+static int __mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
+	unsigned long start, unsigned long end, unsigned int newflags);
 
 static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
 	unsigned long start, unsigned long end, unsigned int newflags)
 {
 	struct mm_struct * mm = vma->vm_mm;
-	pgoff_t pgoff;
 	int pages;
+	int ret;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL, *prev_m;
+	unsigned long start_m = 0UL, end_m = 0UL, newflags_m = 0UL;
+
+	if (vma->vm_flags & VM_MIRROR) {
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(mm, start_m, &prev_m);
+		if (!vma_m || vma_m->vm_start != start_m || !(vma_m->vm_flags & VM_MIRROR)) {
+			printk("PAX: VMMIRROR: mlock bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+
+		start_m = start + vma->vm_mirror;
+		end_m = end + vma->vm_mirror;
+		if (newflags & VM_LOCKED)
+			newflags_m = vma_m->vm_flags | VM_LOCKED;
+		else
+			newflags_m = vma_m->vm_flags & ~VM_LOCKED;
+		ret = __mlock_fixup(vma_m, &prev_m, start_m, end_m, newflags_m);
+		if (ret)
+			return ret;
+	}
+#endif
+
+	ret = __mlock_fixup(vma, prev, start, end, newflags);
+	if (ret)
+		return ret;
+
+	/*
+	 * vm_flags is protected by the mmap_sem held in write mode.
+	 * It's okay if try_to_unmap_one unmaps a page just after we
+	 * set VM_LOCKED, make_pages_present below will bring it back.
+	 */
+	vma->vm_flags = newflags;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		vma_m->vm_flags = newflags_m;
+#endif
+
+	/*
+	 * Keep track of amount of locked VM.
+	 */
+	pages = (end - start) >> PAGE_SHIFT;
+	if (newflags & VM_LOCKED) {
+		pages = -pages;
+		if (!(newflags & VM_IO))
+			ret = make_pages_present(start, end);
+	}
+
+	mm->locked_vm -= pages;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		mm->locked_vm -= pages;
+#endif
+
+	if (ret == -ENOMEM)
+		ret = -EAGAIN;
+	return ret;
+}
+
+static int __mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	struct mm_struct * mm = vma->vm_mm;
+	pgoff_t pgoff;
 	int ret = 0;
 
 	if (newflags == vma->vm_flags) {
@@ -29,7 +100,7 @@
 			  vma->vm_file, pgoff, vma_policy(vma));
 	if (*prev) {
 		vma = *prev;
-		goto success;
+		goto out;
 	}
 
 	*prev = vma;
@@ -40,31 +111,9 @@
 			goto out;
 	}
 
-	if (end != vma->vm_end) {
+	if (end != vma->vm_end)
 		ret = split_vma(mm, vma, end, 0);
-		if (ret)
-			goto out;
-	}
 
-success:
-	/*
-	 * vm_flags is protected by the mmap_sem held in write mode.
-	 * It's okay if try_to_unmap_one unmaps a page just after we
-	 * set VM_LOCKED, make_pages_present below will bring it back.
-	 */
-	vma->vm_flags = newflags;
-
-	/*
-	 * Keep track of amount of locked VM.
-	 */
-	pages = (end - start) >> PAGE_SHIFT;
-	if (newflags & VM_LOCKED) {
-		pages = -pages;
-		if (!(newflags & VM_IO))
-			ret = make_pages_present(start, end);
-	}
-
-	vma->vm_mm->locked_vm -= pages;
 out:
 	if (ret == -ENOMEM)
 		ret = -EAGAIN;
@@ -83,6 +132,17 @@
 		return -EINVAL;
 	if (end == start)
 		return 0;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	vma = find_vma_prev(current->mm, start, &prev);
 	if (!vma || vma->vm_start > start)
 		return -ENOMEM;
@@ -140,6 +200,7 @@
 	lock_limit >>= PAGE_SHIFT;
 
 	/* check against resource limits */
+	gr_learn_resource(current, RLIMIT_MEMLOCK, (current->mm->locked_vm << PAGE_SHIFT) + len, 1);
 	if ((locked <= lock_limit) || capable(CAP_IPC_LOCK))
 		error = do_mlock(start, len, 1);
 	up_write(&current->mm->mmap_sem);
@@ -172,6 +233,16 @@
 	for (vma = current->mm->mmap; vma ; vma = prev->vm_next) {
 		unsigned int newflags;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+			if (vma->vm_end > SEGMEXEC_TASK_SIZE)
+				break;
+		} else
+#endif
+
+		if (vma->vm_end > TASK_SIZE)
+			break;
+
 		newflags = vma->vm_flags | VM_LOCKED;
 		if (!(flags & MCL_CURRENT))
 			newflags &= ~VM_LOCKED;
@@ -201,6 +272,7 @@
 	lock_limit >>= PAGE_SHIFT;
 
 	ret = -ENOMEM;
+	gr_learn_resource(current, RLIMIT_MEMLOCK, current->mm->total_vm, 1);
 	if (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||
 	    capable(CAP_IPC_LOCK))
 		ret = do_mlockall(flags);
diff -Nur linux-2.6.13.1.org/mm/mmap.c grsecurity226/mm/mmap.c
--- linux-2.6.13.1.org/mm/mmap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/mmap.c	2005-09-05 18:42:13.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/mount.h>
 #include <linux/mempolicy.h>
 #include <linux/rmap.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
@@ -155,6 +156,7 @@
 	return -ENOMEM;
 }
 
+EXPORT_SYMBOL(protection_map);
 EXPORT_SYMBOL(sysctl_overcommit_memory);
 EXPORT_SYMBOL(sysctl_overcommit_ratio);
 EXPORT_SYMBOL(sysctl_max_map_count);
@@ -234,6 +236,7 @@
 
 	/* Check against rlimit.. */
 	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
+	gr_learn_resource(current, RLIMIT_DATA, brk - mm->start_data, 1);
 	if (rlim < RLIM_INFINITY && brk - mm->start_data > rlim)
 		goto out;
 
@@ -612,7 +615,11 @@
  * If the vma has a ->close operation then the driver probably needs to release
  * per-vma resources, so we don't attempt to merge those.
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+#define VM_SPECIAL (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED | VM_MIRROR)
+#else
 #define VM_SPECIAL (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED)
+#endif
 
 static inline int is_mergeable_vma(struct vm_area_struct *vma,
 			struct file *file, unsigned long vm_flags)
@@ -872,6 +879,42 @@
 			unsigned long len, unsigned long prot,
 			unsigned long flags, unsigned long pgoff)
 {
+	unsigned long ret = -EINVAL;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || (addr > SEGMEXEC_TASK_SIZE-len)))
+		return ret;
+#endif
+
+	ret = __do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && ret < TASK_SIZE && ((flags & MAP_TYPE) == MAP_PRIVATE)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && (!(current->mm->pax_flags & MF_PAX_MPROTECT) || ((prot & PROT_EXEC) && file && !(prot & PROT_WRITE)))
+#endif
+
+	   )
+	{
+		unsigned long ret_m;
+		prot = prot & PROT_EXEC ? prot : PROT_NONE;
+		ret_m = __do_mmap_pgoff(NULL, ret + SEGMEXEC_TASK_SIZE, 0UL, prot, flags | MAP_MIRROR | MAP_FIXED, ret);
+		if (ret_m >= TASK_SIZE) {
+			do_munmap(current->mm, ret, len);
+			ret = ret_m;
+		}
+	}
+#endif
+
+	return ret;
+}
+
+unsigned long __do_mmap_pgoff(struct file * file, unsigned long addr,
+			unsigned long len, unsigned long prot,
+			unsigned long flags, unsigned long pgoff)
+{
 	struct mm_struct * mm = current->mm;
 	struct vm_area_struct * vma, * prev;
 	struct inode *inode;
@@ -882,6 +925,28 @@
 	int accountable = 1;
 	unsigned long charged = 0, reqprot = prot;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+
+	if (flags & MAP_MIRROR) {
+		/* PaX: sanity checks, to be removed when proved to be stable */
+		if (file || len || ((flags & MAP_TYPE) != MAP_PRIVATE))
+			return -EINVAL;
+
+		vma_m = find_vma(mm, pgoff);
+
+		if (!vma_m || is_vm_hugetlb_page(vma_m) ||
+		    vma_m->vm_start != pgoff ||
+		    (vma_m->vm_flags & VM_MIRROR) ||
+		    (!(vma_m->vm_flags & VM_WRITE) && (prot & PROT_WRITE)))
+			return -EINVAL;
+
+		file = vma_m->vm_file;
+		pgoff = vma_m->vm_pgoff;
+		len = vma_m->vm_end - vma_m->vm_start;
+	}
+#endif
+
 	if (file) {
 		if (is_file_hugepages(file))
 			accountable = 0;
@@ -922,7 +987,7 @@
 	/* Obtain the address to map to. we verify (or select) it and ensure
 	 * that it represents a valid section of the address space.
 	 */
-	addr = get_unmapped_area(file, addr, len, pgoff, flags);
+	addr = get_unmapped_area(file, addr, len, pgoff, flags | ((prot & PROT_EXEC) ? MAP_EXECUTABLE : 0));
 	if (addr & ~PAGE_MASK)
 		return addr;
 
@@ -933,6 +998,24 @@
 	vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |
 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+	if (file && (file->f_vfsmnt->mnt_flags & MNT_NOEXEC))
+		vm_flags &= ~VM_MAYEXEC;
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT) {
+			if ((prot & (PROT_WRITE | PROT_EXEC)) != PROT_EXEC)
+				vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+			else
+				vm_flags &= ~(VM_WRITE | VM_MAYWRITE);
+		}
+#endif
+
+	}
+#endif
+
 	if (flags & MAP_LOCKED) {
 		if (!can_do_mlock())
 			return -EPERM;
@@ -945,6 +1028,7 @@
 		locked += mm->locked_vm;
 		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		lock_limit >>= PAGE_SHIFT;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked << PAGE_SHIFT, 1);
 		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 			return -EAGAIN;
 	}
@@ -992,6 +1076,11 @@
 			/*
 			 * Set pgoff according to addr for anon_vma.
 			 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (!(flags & MAP_MIRROR))
+#endif
+
 			pgoff = addr >> PAGE_SHIFT;
 			break;
 		default:
@@ -1003,14 +1092,17 @@
 	if (error)
 		return error;
 		
+	if (!gr_acl_handle_mmap(file, prot))
+		return -EACCES;
+
 	/* Clear old maps */
 	error = -ENOMEM;
-munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
 	if (vma && vma->vm_start < addr + len) {
 		if (do_munmap(mm, addr, len))
 			return -ENOMEM;
-		goto munmap_back;
+		vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
+		BUG_ON(vma && vma->vm_start < addr + len);
 	}
 
 	/* Check against address space limit. */
@@ -1059,6 +1151,13 @@
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 	vma->vm_flags = vm_flags;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if ((file || !(mm->pax_flags & MF_PAX_PAGEEXEC)) && (vm_flags & (VM_READ|VM_WRITE)))
+		vma->vm_page_prot = protection_map[(vm_flags | VM_EXEC) & 0x0f];
+	else
+#endif
+
 	vma->vm_page_prot = protection_map[vm_flags & 0x0f];
 	vma->vm_pgoff = pgoff;
 
@@ -1083,6 +1182,14 @@
 			goto free_vma;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR) {
+		vma_m->vm_flags |= VM_MIRROR;
+		vma_m->vm_mirror = vma->vm_start - vma_m->vm_start;
+		vma->vm_mirror = vma_m->vm_start - vma->vm_start;
+	}
+#endif
+
 	/* We set VM_ACCOUNT in a shared mapping's vm_flags, to inform
 	 * shmem_zero_setup (perhaps called through /dev/zero's ->mmap)
 	 * that memory reservation must be checked; but that reservation
@@ -1118,6 +1225,7 @@
 out:	
 	mm->total_vm += len >> PAGE_SHIFT;
 	__vm_stat_account(mm, vm_flags, file, len >> PAGE_SHIFT);
+	track_exec_limit(mm, addr, addr + len, vm_flags);
 	if (vm_flags & VM_LOCKED) {
 		mm->locked_vm += len >> PAGE_SHIFT;
 		make_pages_present(addr, addr + len);
@@ -1148,6 +1256,7 @@
 }
 
 EXPORT_SYMBOL(do_mmap_pgoff);
+EXPORT_SYMBOL(__do_mmap_pgoff);
 
 /* Get an address range which is currently unmapped.
  * For shmat() with addr=0.
@@ -1172,6 +1281,10 @@
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
@@ -1182,7 +1295,7 @@
 	if (len > mm->cached_hole_size) {
 	        start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
+	        start_addr = addr = mm->mmap_base;
 	        mm->cached_hole_size = 0;
 	}
 
@@ -1194,8 +1307,8 @@
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				addr = mm->mmap_base;
 			        start_addr = addr;
 				mm->cached_hole_size = 0;
 				goto full_search;
@@ -1221,7 +1334,7 @@
 	/*
 	 * Is this a new hole at the lowest possible address?
 	 */
-	if (addr >= TASK_UNMAPPED_BASE && addr < mm->free_area_cache) {
+	if (addr >= mm->mmap_base && addr < mm->free_area_cache) {
 		mm->free_area_cache = addr;
 		mm->cached_hole_size = ~0UL;
 	}
@@ -1245,6 +1358,10 @@
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
@@ -1304,6 +1421,12 @@
 	 */
 	mm->cached_hole_size = ~0UL;
   	mm->free_area_cache = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->free_area_cache += mm->delta_mmap;
+#endif
+
 	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
 	/*
 	 * Restore the topdown base:
@@ -1458,6 +1581,7 @@
 		return -ENOMEM;
 
 	/* Stack limit test */
+	gr_learn_resource(current, RLIMIT_STACK, size, 1);
 	if (size > rlim[RLIMIT_STACK].rlim_cur)
 		return -ENOMEM;
 
@@ -1467,6 +1591,7 @@
 		unsigned long limit;
 		locked = mm->locked_vm + grow;
 		limit = rlim[RLIMIT_MEMLOCK].rlim_cur >> PAGE_SHIFT;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked << PAGE_SHIFT, 1);
 		if (locked > limit && !capable(CAP_IPC_LOCK))
 			return -ENOMEM;
 	}
@@ -1573,13 +1698,50 @@
 	if (address < vma->vm_start) {
 		unsigned long size, grow;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		struct vm_area_struct *vma_m = NULL;
+		unsigned long address_m = 0UL;
+
+		if (vma->vm_flags & VM_MIRROR) {
+			address_m = vma->vm_start + vma->vm_mirror;
+			vma_m = find_vma(vma->vm_mm, address_m);
+			if (!vma_m || vma_m->vm_start != address_m ||
+			    !(vma_m->vm_flags & VM_MIRROR) ||
+			    vma->vm_end - vma->vm_start !=
+			    vma_m->vm_end - vma_m->vm_start ||
+			    vma->anon_vma != vma_m->anon_vma) {
+				printk(KERN_ERR "PAX: VMMIRROR: expand bug, %08lx, %08lx, %08lx, %08lx, %08lx\n",
+				       address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+				anon_vma_unlock(vma);
+				return -EFAULT;
+			}
+			address_m = address + vma->vm_mirror;
+		}
+#endif
+
 		size = vma->vm_end - address;
 		grow = (vma->vm_start - address) >> PAGE_SHIFT;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma_m)
+			error = acct_stack_growth(vma, size, 2*grow);
+		else
+#endif
+
 		error = acct_stack_growth(vma, size, grow);
 		if (!error) {
 			vma->vm_start = address;
 			vma->vm_pgoff -= grow;
+			track_exec_limit(vma->vm_mm, vma->vm_start, vma->vm_end, vma->vm_flags);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (vma_m) {
+				vma_m->vm_start = address_m;
+				vma_m->vm_pgoff -= grow;
+				track_exec_limit(vma_m->vm_mm, vma_m->vm_start, vma_m->vm_end, vma_m->vm_flags);
+			}
+#endif
+
 		}
 	}
 	anon_vma_unlock(vma);
@@ -1587,7 +1749,7 @@
 }
 
 struct vm_area_struct *
-find_extend_vma(struct mm_struct * mm, unsigned long addr)
+find_extend_vma(struct mm_struct *mm, unsigned long addr)
 {
 	struct vm_area_struct * vma;
 	unsigned long start;
@@ -1621,9 +1783,9 @@
 {
 	size_t len = area->vm_end - area->vm_start;
 
-	area->vm_mm->total_vm -= len >> PAGE_SHIFT;
+	mm->total_vm -= len >> PAGE_SHIFT;
 	if (area->vm_flags & VM_LOCKED)
-		area->vm_mm->locked_vm -= len >> PAGE_SHIFT;
+		mm->locked_vm -= len >> PAGE_SHIFT;
 	vm_stat_unaccount(area);
 	remove_vm_struct(area);
 }
@@ -1754,8 +1916,25 @@
  * work.  This now handles partial unmappings.
  * Jeremy Fitzhardinge <jeremy@goop.org>
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+static int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len);
+
 int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
 {
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		int ret = __do_munmap(mm, start + SEGMEXEC_TASK_SIZE, len);
+		if (ret)
+			return ret;
+	}
+
+	return __do_munmap(mm, start, len);
+}
+
+static int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
+#else
+int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
+#endif
+{
 	unsigned long end;
 	struct vm_area_struct *vma, *prev, *last;
 
@@ -1808,6 +1987,8 @@
 	/* Fix up all other VM information */
 	unmap_vma_list(mm, vma);
 
+	track_exec_limit(mm, start, end, 0UL);
+
 	return 0;
 }
 
@@ -1820,6 +2001,12 @@
 
 	profile_munmap(addr);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || addr > SEGMEXEC_TASK_SIZE-len))
+		return -EINVAL;
+#endif
+
 	down_write(&mm->mmap_sem);
 	ret = do_munmap(mm, addr, len);
 	up_write(&mm->mmap_sem);
@@ -1841,8 +2028,32 @@
  *  anonymous maps.  eventually we may be able to do some
  *  brk-specific accounting here.
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+unsigned long __do_brk(unsigned long addr, unsigned long len);
+
 unsigned long do_brk(unsigned long addr, unsigned long len)
 {
+	unsigned long ret;
+
+	ret = __do_brk(addr, len);
+	if (ret == addr && (current->mm->pax_flags & (MF_PAX_SEGMEXEC | MF_PAX_MPROTECT)) == MF_PAX_SEGMEXEC) {
+		unsigned long ret_m;
+
+		ret_m = __do_mmap_pgoff(NULL, addr + SEGMEXEC_TASK_SIZE, 0UL, PROT_NONE, MAP_PRIVATE | MAP_FIXED | MAP_MIRROR, addr);
+		if (ret_m > TASK_SIZE) {
+			do_munmap(current->mm, addr, len);
+			ret = ret_m;
+		}
+	}
+
+	return ret;
+}
+
+unsigned long __do_brk(unsigned long addr, unsigned long len)
+#else
+unsigned long do_brk(unsigned long addr, unsigned long len)
+#endif
+{
 	struct mm_struct * mm = current->mm;
 	struct vm_area_struct * vma, * prev;
 	unsigned long flags;
@@ -1853,6 +2064,13 @@
 	if (!len)
 		return addr;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if ((addr + len) > SEGMEXEC_TASK_SIZE || (addr + len) < addr)
+			return -EINVAL;
+	} else
+#endif
+
 	if ((addr + len) > TASK_SIZE || (addr + len) < addr)
 		return -EINVAL;
 
@@ -1865,6 +2083,7 @@
 		locked += mm->locked_vm;
 		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		lock_limit >>= PAGE_SHIFT;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked << PAGE_SHIFT, 1);
 		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 			return -EAGAIN;
 	}
@@ -1878,12 +2097,12 @@
 	/*
 	 * Clear old maps.  this also does some error checking for us
 	 */
- munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
 	if (vma && vma->vm_start < addr + len) {
 		if (do_munmap(mm, addr, len))
 			return -ENOMEM;
-		goto munmap_back;
+		vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
+		BUG_ON(vma && vma->vm_start < addr + len);
 	}
 
 	/* Check against address space limits *after* clearing old maps... */
@@ -1898,6 +2117,18 @@
 
 	flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		flags &= ~VM_EXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT)
+			flags &= ~VM_MAYEXEC;
+#endif
+
+	}
+#endif
+
 	/* Can we just expand an old private anonymous mapping? */
 	if (vma_merge(mm, prev, addr, addr + len, flags,
 					NULL, NULL, pgoff, NULL))
@@ -1918,6 +2149,13 @@
 	vma->vm_end = addr + len;
 	vma->vm_pgoff = pgoff;
 	vma->vm_flags = flags;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(mm->pax_flags & MF_PAX_PAGEEXEC) && (flags & (VM_READ|VM_WRITE)))
+		vma->vm_page_prot = protection_map[(flags | VM_EXEC) & 0x0f];
+	else
+#endif
+
 	vma->vm_page_prot = protection_map[flags & 0x0f];
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 out:
@@ -1926,6 +2164,7 @@
 		mm->locked_vm += len >> PAGE_SHIFT;
 		make_pages_present(addr, addr + len);
 	}
+	track_exec_limit(mm, addr, addr + len, flags);
 	return addr;
 }
 
@@ -2068,7 +2307,7 @@
 	unsigned long lim;
 
 	lim = current->signal->rlim[RLIMIT_AS].rlim_cur >> PAGE_SHIFT;
-
+	gr_learn_resource(current, RLIMIT_AS, (cur + npages) << PAGE_SHIFT, 1);
 	if (cur + npages > lim)
 		return 0;
 	return 1;
diff -Nur linux-2.6.13.1.org/mm/mprotect.c grsecurity226/mm/mprotect.c
--- linux-2.6.13.1.org/mm/mprotect.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/mprotect.c	2005-08-30 01:15:13.000000000 +0200
@@ -19,11 +19,18 @@
 #include <linux/mempolicy.h>
 #include <linux/personality.h>
 #include <linux/syscalls.h>
+#include <linux/grsecurity.h>
+
+#ifdef CONFIG_PAX_MPROTECT
+#include <linux/elf.h>
+#include <linux/fs.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
+#include <asm/mmu_context.h>
 
 static void change_pte_range(struct mm_struct *mm, pmd_t *pmd,
 		unsigned long addr, unsigned long end, pgprot_t newprot)
@@ -99,6 +106,94 @@
 	spin_unlock(&mm->page_table_lock);
 }
 
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+/* called while holding the mmap semaphor for writing */
+static inline void establish_user_cs_limit(struct mm_struct *mm, unsigned long start, unsigned long end)
+{
+	struct vm_area_struct *vma = find_vma(mm, start);
+
+	for (; vma && vma->vm_start < end; vma = vma->vm_next)
+		change_protection(vma, vma->vm_start, vma->vm_end, vma->vm_page_prot);
+
+}
+
+void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot)
+{
+	unsigned long oldlimit, newlimit = 0UL;
+
+	if (!(mm->pax_flags & MF_PAX_PAGEEXEC))
+		return;
+
+	spin_lock(&mm->page_table_lock);
+	oldlimit = mm->context.user_cs_limit;
+	if ((prot & VM_EXEC) && oldlimit < end)
+		/* USER_CS limit moved up */
+		newlimit = end;
+	else if (!(prot & VM_EXEC) && start < oldlimit && oldlimit <= end)
+		/* USER_CS limit moved down */
+		newlimit = start;
+
+	if (newlimit) {
+		mm->context.user_cs_limit = newlimit;
+
+#ifdef CONFIG_SMP
+		wmb();
+		cpus_clear(mm->context.cpu_user_cs_mask);
+		cpu_set(smp_processor_id(), mm->context.cpu_user_cs_mask);
+#endif
+
+		set_user_cs(mm, smp_processor_id());
+	}
+	spin_unlock(&mm->page_table_lock);
+	if (newlimit == end)
+		establish_user_cs_limit(mm, oldlimit, end);
+}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+static int __mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
+	unsigned long start, unsigned long end, unsigned int newflags);
+
+static int mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	if (vma->vm_flags & VM_MIRROR) {
+		struct vm_area_struct * vma_m, * prev_m;
+		unsigned long start_m, end_m;
+		int error;
+
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(vma->vm_mm, start_m, &prev_m);
+		if (vma_m && vma_m->vm_start == start_m && (vma_m->vm_flags & VM_MIRROR)) {
+			start_m = start + vma->vm_mirror;
+			end_m = end + vma->vm_mirror;
+
+			if (vma_m->vm_start >= SEGMEXEC_TASK_SIZE && !(newflags & VM_EXEC))
+				error = __mprotect_fixup(vma_m, &prev_m, start_m, end_m, vma_m->vm_flags & ~(VM_READ | VM_WRITE | VM_EXEC));
+			else
+				error = __mprotect_fixup(vma_m, &prev_m, start_m, end_m, newflags);
+			if (error)
+				return error;
+		} else {
+			printk("PAX: VMMIRROR: mprotect bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+	}
+
+	return __mprotect_fixup(vma, pprev, start, end, newflags);
+}
+
+static int __mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	struct mm_struct * mm = vma->vm_mm;
+	unsigned long oldflags = vma->vm_flags;
+	long nrpages = (end - start) >> PAGE_SHIFT;
+	unsigned long charged = 0;
+	pgprot_t newprot;
+	pgoff_t pgoff;
+	int error;
+#else
 static int
 mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
 	unsigned long start, unsigned long end, unsigned long newflags)
@@ -115,6 +210,7 @@
 		*pprev = vma;
 		return 0;
 	}
+#endif
 
 	/*
 	 * If we make a private mapping writable we increase our commit;
@@ -133,6 +229,12 @@
 		}
 	}
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(mm->pax_flags & MF_PAX_PAGEEXEC) && (newflags & (VM_READ|VM_WRITE)))
+		newprot = protection_map[(newflags | VM_EXEC) & 0xf];
+	else
+#endif
+
 	newprot = protection_map[newflags & 0xf];
 
 	/*
@@ -177,6 +279,69 @@
 	return error;
 }
 
+#ifdef CONFIG_PAX_MPROTECT
+/* PaX: non-PIC ELF libraries need relocations on their executable segments
+ * therefore we'll grant them VM_MAYWRITE once during their life.
+ *
+ * The checks favour ld-linux.so behaviour which operates on a per ELF segment
+ * basis because we want to allow the common case and not the special ones.
+ */
+static inline void pax_handle_maywrite(struct vm_area_struct * vma, unsigned long start)
+{
+	struct elfhdr elf_h;
+	struct elf_phdr elf_p, p_dyn;
+	elf_dyn dyn;
+	unsigned long i, j = 65536UL / sizeof(struct elf_phdr);
+
+#ifndef CONFIG_PAX_NOELFRELOCS
+	if ((vma->vm_start != start) ||
+	    !vma->vm_file ||
+	    !(vma->vm_flags & VM_MAYEXEC) ||
+	    (vma->vm_flags & VM_MAYNOTWRITE))
+#endif
+
+		return;
+
+	if (sizeof(elf_h) != kernel_read(vma->vm_file, 0UL, (char*)&elf_h, sizeof(elf_h)) ||
+	    memcmp(elf_h.e_ident, ELFMAG, SELFMAG) ||
+
+#ifdef CONFIG_PAX_ETEXECRELOCS
+	    (elf_h.e_type != ET_DYN && elf_h.e_type != ET_EXEC) ||
+#else
+	    elf_h.e_type != ET_DYN ||
+#endif
+
+	    !elf_check_arch(&elf_h) ||
+	    elf_h.e_phentsize != sizeof(struct elf_phdr) ||
+	    elf_h.e_phnum > j)
+		return;
+
+	for (i = 0UL; i < elf_h.e_phnum; i++) {
+		if (sizeof(elf_p) != kernel_read(vma->vm_file, elf_h.e_phoff + i*sizeof(elf_p), (char*)&elf_p, sizeof(elf_p)))
+			return;
+		if (elf_p.p_type == PT_DYNAMIC) {
+			p_dyn = elf_p;
+			j = i;
+		}
+	}
+	if (elf_h.e_phnum <= j)
+		return;
+
+	i = 0UL;
+	do {
+		if (sizeof(dyn) != kernel_read(vma->vm_file, p_dyn.p_offset + i*sizeof(dyn), (char*)&dyn, sizeof(dyn)))
+			return;
+		if (dyn.d_tag == DT_TEXTREL || (dyn.d_tag == DT_FLAGS && (dyn.d_un.d_val & DF_TEXTREL))) {
+			vma->vm_flags |= VM_MAYWRITE | VM_MAYNOTWRITE;
+			gr_log_textrel(vma);
+			return;
+		}
+		i++;
+	} while (dyn.d_tag != DT_NULL);
+	return;
+}
+#endif
+
 asmlinkage long
 sys_mprotect(unsigned long start, size_t len, unsigned long prot)
 {
@@ -196,6 +361,17 @@
 	end = start + len;
 	if (end <= start)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	if (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM))
 		return -EINVAL;
 
@@ -236,6 +412,16 @@
 	if (start > vma->vm_start)
 		prev = vma;
 
+	if (!gr_acl_handle_mprotect(vma->vm_file, prot)) {
+		error = -EACCES;
+		goto out;
+	}
+
+#ifdef CONFIG_PAX_MPROTECT
+	if ((vma->vm_mm->pax_flags & MF_PAX_MPROTECT) && (prot & PROT_WRITE))
+		pax_handle_maywrite(vma, start);
+#endif
+
 	for (nstart = start ; ; ) {
 		unsigned long newflags;
 
@@ -253,6 +439,12 @@
 			goto out;
 		}
 
+#ifdef CONFIG_PAX_MPROTECT
+		/* PaX: disallow write access after relocs are done, hopefully noone else needs it... */
+		if ((vma->vm_mm->pax_flags & MF_PAX_MPROTECT) && (prot & PROT_WRITE) && (vma->vm_flags & VM_MAYNOTWRITE))
+			newflags &= ~VM_MAYWRITE;
+#endif
+
 		error = security_file_mprotect(vma, reqprot, prot);
 		if (error)
 			goto out;
@@ -276,6 +468,9 @@
 			goto out;
 		}
 	}
+
+	track_exec_limit(current->mm, start, end, vm_flags);
+
 out:
 	up_write(&current->mm->mmap_sem);
 	return error;
diff -Nur linux-2.6.13.1.org/mm/mremap.c grsecurity226/mm/mremap.c
--- linux-2.6.13.1.org/mm/mremap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/mremap.c	2005-08-30 01:15:13.000000000 +0200
@@ -141,6 +141,12 @@
 			if (dst) {
 				pte_t pte;
 				pte = ptep_clear_flush(vma, old_addr, src);
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+				if ((mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+					pte_exprotect(pte);
+#endif
+
 				set_pte_at(mm, new_addr, dst, pte);
 			} else
 				error = -ENOMEM;
@@ -286,6 +292,18 @@
 	if (!new_len)
 		goto out;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (new_len > SEGMEXEC_TASK_SIZE || addr > SEGMEXEC_TASK_SIZE-new_len ||
+		    old_len > SEGMEXEC_TASK_SIZE || addr > SEGMEXEC_TASK_SIZE-old_len)
+			goto out;
+	} else
+#endif
+
+	if (new_len > TASK_SIZE || addr > TASK_SIZE-new_len ||
+	    old_len > TASK_SIZE || addr > TASK_SIZE-old_len)
+		goto out;
+
 	/* new_addr is only valid if MREMAP_FIXED is specified */
 	if (flags & MREMAP_FIXED) {
 		if (new_addr & ~PAGE_MASK)
@@ -293,6 +311,13 @@
 		if (!(flags & MREMAP_MAYMOVE))
 			goto out;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+			if (new_len > SEGMEXEC_TASK_SIZE || new_addr > SEGMEXEC_TASK_SIZE-new_len)
+				goto out;
+		} else
+#endif
+
 		if (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)
 			goto out;
 
@@ -336,6 +361,14 @@
 		ret = -EINVAL;
 		goto out;
 	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		ret = -EINVAL;
+		goto out;
+	}
+#endif
+
 	/* We can't remap across vm area boundaries */
 	if (old_len > vma->vm_end - addr)
 		goto out;
@@ -388,6 +421,7 @@
 						   addr + new_len);
 			}
 			ret = addr;
+			track_exec_limit(vma->vm_mm, vma->vm_start, addr + new_len, vma->vm_flags);
 			goto out;
 		}
 	}
@@ -398,8 +432,8 @@
 	 */
 	ret = -ENOMEM;
 	if (flags & MREMAP_MAYMOVE) {
+		unsigned long map_flags = 0;
 		if (!(flags & MREMAP_FIXED)) {
-			unsigned long map_flags = 0;
 			if (vma->vm_flags & VM_MAYSHARE)
 				map_flags |= MAP_SHARED;
 
@@ -409,7 +443,12 @@
 			if (new_addr & ~PAGE_MASK)
 				goto out;
 		}
+		map_flags = vma->vm_flags;
 		ret = move_vma(vma, addr, old_len, new_len, new_addr);
+		if (!(ret & ~PAGE_MASK)) {
+			track_exec_limit(current->mm, addr, addr + old_len, 0UL);
+			track_exec_limit(current->mm, new_addr, new_addr + new_len, map_flags);
+		}
 	}
 out:
 	if (ret & ~PAGE_MASK)
diff -Nur linux-2.6.13.1.org/mm/rmap.c grsecurity226/mm/rmap.c
--- linux-2.6.13.1.org/mm/rmap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/mm/rmap.c	2005-08-30 01:15:14.000000000 +0200
@@ -108,6 +108,19 @@
 			list_add(&vma->anon_vma_node, &anon_vma->head);
 			allocated = NULL;
 		}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR) {
+			struct vm_area_struct *vma_m;
+
+			vma_m = find_vma(vma->vm_mm, vma->vm_start + vma->vm_mirror);
+			BUG_ON(!vma_m || vma_m->vm_start != vma->vm_start + vma->vm_mirror);
+			BUG_ON(vma_m->anon_vma || vma->vm_pgoff != vma_m->vm_pgoff);
+			vma_m->anon_vma = anon_vma;
+			__anon_vma_link(vma_m);
+		}
+#endif
+
 		spin_unlock(&mm->page_table_lock);
 
 		if (locked)
diff -Nur linux-2.6.13.1.org/net/bluetooth/bnep/bnep.h grsecurity226/net/bluetooth/bnep/bnep.h
--- linux-2.6.13.1.org/net/bluetooth/bnep/bnep.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bluetooth/bnep/bnep.h	2005-08-30 01:01:02.000000000 +0200
@@ -17,7 +17,7 @@
 */
 
 /*
- * $Id$
+ * $Id$
  */
 
 #ifndef _BNEP_H
diff -Nur linux-2.6.13.1.org/net/bluetooth/bnep/core.c grsecurity226/net/bluetooth/bnep/core.c
--- linux-2.6.13.1.org/net/bluetooth/bnep/core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bluetooth/bnep/core.c	2005-08-30 01:01:02.000000000 +0200
@@ -26,7 +26,7 @@
 */
 
 /*
- * $Id$
+ * $Id$
  */ 
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/net/bluetooth/bnep/netdev.c grsecurity226/net/bluetooth/bnep/netdev.c
--- linux-2.6.13.1.org/net/bluetooth/bnep/netdev.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bluetooth/bnep/netdev.c	2005-08-30 01:01:02.000000000 +0200
@@ -26,7 +26,7 @@
 */
 
 /*
- * $Id$
+ * $Id$
  */ 
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/net/bluetooth/bnep/sock.c grsecurity226/net/bluetooth/bnep/sock.c
--- linux-2.6.13.1.org/net/bluetooth/bnep/sock.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bluetooth/bnep/sock.c	2005-08-30 01:01:02.000000000 +0200
@@ -25,7 +25,7 @@
 */
 
 /*
- * $Id$
+ * $Id$
  */ 
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/net/bluetooth/rfcomm/core.c grsecurity226/net/bluetooth/rfcomm/core.c
--- linux-2.6.13.1.org/net/bluetooth/rfcomm/core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bluetooth/rfcomm/core.c	2005-08-30 01:01:02.000000000 +0200
@@ -28,7 +28,7 @@
 /*
  * Bluetooth RFCOMM core.
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/net/bluetooth/rfcomm/crc.c grsecurity226/net/bluetooth/rfcomm/crc.c
--- linux-2.6.13.1.org/net/bluetooth/rfcomm/crc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bluetooth/rfcomm/crc.c	2005-08-30 01:01:02.000000000 +0200
@@ -24,7 +24,7 @@
 /*
  * RFCOMM FCS calculation.
  *
- * $Id$
+ * $Id$
  */
 
 /* reversed, 8-bit, poly=0x07 */
diff -Nur linux-2.6.13.1.org/net/bluetooth/rfcomm/sock.c grsecurity226/net/bluetooth/rfcomm/sock.c
--- linux-2.6.13.1.org/net/bluetooth/rfcomm/sock.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bluetooth/rfcomm/sock.c	2005-08-30 01:01:02.000000000 +0200
@@ -24,7 +24,7 @@
 /*
  * RFCOMM sockets.
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/net/bluetooth/rfcomm/tty.c grsecurity226/net/bluetooth/rfcomm/tty.c
--- linux-2.6.13.1.org/net/bluetooth/rfcomm/tty.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bluetooth/rfcomm/tty.c	2005-08-30 01:01:02.000000000 +0200
@@ -24,7 +24,7 @@
 /*
  * RFCOMM TTY.
  *
- * $Id$
+ * $Id$
  */
 
 #include <linux/config.h>
diff -Nur linux-2.6.13.1.org/net/bridge/br.c grsecurity226/net/bridge/br.c
--- linux-2.6.13.1.org/net/bridge/br.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_device.c grsecurity226/net/bridge/br_device.c
--- linux-2.6.13.1.org/net/bridge/br_device.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_device.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_fdb.c grsecurity226/net/bridge/br_fdb.c
--- linux-2.6.13.1.org/net/bridge/br_fdb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_fdb.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_forward.c grsecurity226/net/bridge/br_forward.c
--- linux-2.6.13.1.org/net/bridge/br_forward.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_forward.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_if.c grsecurity226/net/bridge/br_if.c
--- linux-2.6.13.1.org/net/bridge/br_if.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_if.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_input.c grsecurity226/net/bridge/br_input.c
--- linux-2.6.13.1.org/net/bridge/br_input.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_input.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_ioctl.c grsecurity226/net/bridge/br_ioctl.c
--- linux-2.6.13.1.org/net/bridge/br_ioctl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_ioctl.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_notify.c grsecurity226/net/bridge/br_notify.c
--- linux-2.6.13.1.org/net/bridge/br_notify.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_notify.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_private.h grsecurity226/net/bridge/br_private.h
--- linux-2.6.13.1.org/net/bridge/br_private.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_private.h	2005-08-30 01:01:02.000000000 +0200
@@ -4,7 +4,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_private_stp.h grsecurity226/net/bridge/br_private_stp.h
--- linux-2.6.13.1.org/net/bridge/br_private_stp.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_private_stp.h	2005-08-30 01:01:02.000000000 +0200
@@ -4,7 +4,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_stp.c grsecurity226/net/bridge/br_stp.c
--- linux-2.6.13.1.org/net/bridge/br_stp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_stp.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_stp_bpdu.c grsecurity226/net/bridge/br_stp_bpdu.c
--- linux-2.6.13.1.org/net/bridge/br_stp_bpdu.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_stp_bpdu.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_stp_if.c grsecurity226/net/bridge/br_stp_if.c
--- linux-2.6.13.1.org/net/bridge/br_stp_if.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_stp_if.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/bridge/br_stp_timer.c grsecurity226/net/bridge/br_stp_timer.c
--- linux-2.6.13.1.org/net/bridge/br_stp_timer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/bridge/br_stp_timer.c	2005-08-30 01:01:02.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/compat.c grsecurity226/net/compat.c
--- linux-2.6.13.1.org/net/compat.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/compat.c	2005-08-30 01:01:01.000000000 +0200
@@ -135,14 +135,13 @@
  * thus placement) of cmsg headers and length are different for
  * 32-bit apps.  -DaveM
  */
-int cmsghdr_from_user_compat_to_kern(struct msghdr *kmsg, struct sock *sk,
+int cmsghdr_from_user_compat_to_kern(struct msghdr *kmsg,
 			       unsigned char *stackbuf, int stackbuf_size)
 {
 	struct compat_cmsghdr __user *ucmsg;
 	struct cmsghdr *kcmsg, *kcmsg_base;
 	compat_size_t ucmlen;
 	__kernel_size_t kcmlen, tmp;
-	int err = -EFAULT;
 
 	kcmlen = 0;
 	kcmsg_base = kcmsg = (struct cmsghdr *)stackbuf;
@@ -157,7 +156,6 @@
 
 		tmp = ((ucmlen - CMSG_COMPAT_ALIGN(sizeof(*ucmsg))) +
 		       CMSG_ALIGN(sizeof(struct cmsghdr)));
-		tmp = CMSG_ALIGN(tmp);
 		kcmlen += tmp;
 		ucmsg = cmsg_compat_nxthdr(kmsg, ucmsg, ucmlen);
 	}
@@ -169,34 +167,30 @@
 	 * until we have successfully copied over all of the data
 	 * from the user.
 	 */
-	if (kcmlen > stackbuf_size)
-		kcmsg_base = kcmsg = sock_kmalloc(sk, kcmlen, GFP_KERNEL);
-	if (kcmsg == NULL)
+	if(kcmlen > stackbuf_size)
+		kcmsg_base = kcmsg = kmalloc(kcmlen, GFP_KERNEL);
+	if(kcmsg == NULL)
 		return -ENOBUFS;
 
 	/* Now copy them over neatly. */
 	memset(kcmsg, 0, kcmlen);
 	ucmsg = CMSG_COMPAT_FIRSTHDR(kmsg);
 	while(ucmsg != NULL) {
-		if (__get_user(ucmlen, &ucmsg->cmsg_len))
-			goto Efault;
-		if (!CMSG_COMPAT_OK(ucmlen, ucmsg, kmsg))
-			goto Einval;
+		__get_user(ucmlen, &ucmsg->cmsg_len);
 		tmp = ((ucmlen - CMSG_COMPAT_ALIGN(sizeof(*ucmsg))) +
 		       CMSG_ALIGN(sizeof(struct cmsghdr)));
-		if ((char *)kcmsg_base + kcmlen - (char *)kcmsg < CMSG_ALIGN(tmp))
-			goto Einval;
 		kcmsg->cmsg_len = tmp;
-		tmp = CMSG_ALIGN(tmp);
-		if (__get_user(kcmsg->cmsg_level, &ucmsg->cmsg_level) ||
-		    __get_user(kcmsg->cmsg_type, &ucmsg->cmsg_type) ||
-		    copy_from_user(CMSG_DATA(kcmsg),
-				   CMSG_COMPAT_DATA(ucmsg),
-				   (ucmlen - CMSG_COMPAT_ALIGN(sizeof(*ucmsg)))))
-			goto Efault;
+		__get_user(kcmsg->cmsg_level, &ucmsg->cmsg_level);
+		__get_user(kcmsg->cmsg_type, &ucmsg->cmsg_type);
+
+		/* Copy over the data. */
+		if(copy_from_user(CMSG_DATA(kcmsg),
+				  CMSG_COMPAT_DATA(ucmsg),
+				  (ucmlen - CMSG_COMPAT_ALIGN(sizeof(*ucmsg)))))
+			goto out_free_efault;
 
 		/* Advance. */
-		kcmsg = (struct cmsghdr *)((char *)kcmsg + tmp);
+		kcmsg = (struct cmsghdr *)((char *)kcmsg + CMSG_ALIGN(tmp));
 		ucmsg = cmsg_compat_nxthdr(kmsg, ucmsg, ucmlen);
 	}
 
@@ -205,12 +199,10 @@
 	kmsg->msg_controllen = kcmlen;
 	return 0;
 
-Einval:
-	err = -EINVAL;
-Efault:
-	if (kcmsg_base != (struct cmsghdr *)stackbuf)
-		sock_kfree_s(sk, kcmsg_base, kcmlen);
-	return err;
+out_free_efault:
+	if(kcmsg_base != (struct cmsghdr *)stackbuf)
+		kfree(kcmsg_base);
+	return -EFAULT;
 }
 
 int put_cmsg_compat(struct msghdr *kmsg, int level, int type, int len, void *data)
diff -Nur linux-2.6.13.1.org/net/core/filter.c grsecurity226/net/core/filter.c
--- linux-2.6.13.1.org/net/core/filter.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/core/filter.c	2005-08-30 01:01:02.000000000 +0200
@@ -182,7 +182,7 @@
 				A = ntohl(*(u32 *)ptr);
 				continue;
 			}
-			break;
+			return 0;
 		case BPF_LD|BPF_H|BPF_ABS:
 			k = fentry->k;
  load_h:
@@ -191,7 +191,7 @@
 				A = ntohs(*(u16 *)ptr);
 				continue;
 			}
-			break;
+			return 0;
 		case BPF_LD|BPF_B|BPF_ABS:
 			k = fentry->k;
 load_b:
@@ -200,7 +200,7 @@
 				A = *(u8 *)ptr;
 				continue;
 			}
-			break;
+			return 0;
 		case BPF_LD|BPF_W|BPF_LEN:
 			A = skb->len;
 			continue;
diff -Nur linux-2.6.13.1.org/net/core/skbuff.c grsecurity226/net/core/skbuff.c
--- linux-2.6.13.1.org/net/core/skbuff.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/core/skbuff.c	2005-08-30 01:01:02.000000000 +0200
@@ -4,7 +4,7 @@
  *	Authors:	Alan Cox <iiitac@pyr.swan.ac.uk>
  *			Florian La Roche <rzsfl@rz.uni-sb.de>
  *
- *	Version:	$Id$
+ *	Version:	$Id$
  *
  *	Fixes:
  *		Alan Cox	:	Fixed the worst of the load
diff -Nur linux-2.6.13.1.org/net/core/sock.c grsecurity226/net/core/sock.c
--- linux-2.6.13.1.org/net/core/sock.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/core/sock.c	2005-08-30 01:01:02.000000000 +0200
@@ -7,7 +7,7 @@
  *		handler for protocols to use and generic option handler.
  *
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/af_inet.c grsecurity226/net/ipv4/af_inet.c
--- linux-2.6.13.1.org/net/ipv4/af_inet.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/af_inet.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		PF_INET protocol family socket handler.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/arp.c grsecurity226/net/ipv4/arp.c
--- linux-2.6.13.1.org/net/ipv4/arp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/arp.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,6 +1,6 @@
 /* linux/net/inet/arp.c
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Copyright (C) 1994 by Florian  La Roche
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/devinet.c grsecurity226/net/ipv4/devinet.c
--- linux-2.6.13.1.org/net/ipv4/devinet.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/devinet.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *	NET3	IP device support routines.
  *
- *	Version: $Id$
+ *	Version: $Id$
  *
  *		This program is free software; you can redistribute it and/or
  *		modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv4/fib_frontend.c grsecurity226/net/ipv4/fib_frontend.c
--- linux-2.6.13.1.org/net/ipv4/fib_frontend.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/fib_frontend.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		IPv4 Forwarding Information Base: FIB frontend.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/fib_hash.c grsecurity226/net/ipv4/fib_hash.c
--- linux-2.6.13.1.org/net/ipv4/fib_hash.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/fib_hash.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		IPv4 FIB: lookup engine and maintenance routines.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/fib_rules.c grsecurity226/net/ipv4/fib_rules.c
--- linux-2.6.13.1.org/net/ipv4/fib_rules.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/fib_rules.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		IPv4 Forwarding Information Base: policy rules.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/fib_semantics.c grsecurity226/net/ipv4/fib_semantics.c
--- linux-2.6.13.1.org/net/ipv4/fib_semantics.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/fib_semantics.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		IPv4 Forwarding Information Base: semantics.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/fib_trie.c grsecurity226/net/ipv4/fib_trie.c
--- linux-2.6.13.1.org/net/ipv4/fib_trie.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/fib_trie.c	2005-08-30 01:01:03.000000000 +0200
@@ -22,7 +22,7 @@
  * IP-address lookup using LC-tries. Stefan Nilsson and Gunnar Karlsson
  * IEEE Journal on Selected Areas in Communications, 17(6):1083-1092, June 1999
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  *
  * Code from fib_hash has been reused which includes the following header:
diff -Nur linux-2.6.13.1.org/net/ipv4/icmp.c grsecurity226/net/ipv4/icmp.c
--- linux-2.6.13.1.org/net/ipv4/icmp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/icmp.c	2005-08-30 01:01:03.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *		Alan Cox, <alan@redhat.com>
  *
- *	Version: $Id$
+ *	Version: $Id$
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv4/igmp.c grsecurity226/net/ipv4/igmp.c
--- linux-2.6.13.1.org/net/ipv4/igmp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/igmp.c	2005-08-30 01:01:03.000000000 +0200
@@ -8,7 +8,7 @@
  *	the older version didn't come out right using gcc 2.5.8, the newer one
  *	seems to fall out with gcc 2.6.2.
  *
- *	Version: $Id$
+ *	Version: $Id$
  *
  *	Authors:
  *		Alan Cox <Alan.Cox@linux.org>
diff -Nur linux-2.6.13.1.org/net/ipv4/inetpeer.c grsecurity226/net/ipv4/inetpeer.c
--- linux-2.6.13.1.org/net/ipv4/inetpeer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/inetpeer.c	2005-08-30 01:01:03.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *  This source is covered by the GNU GPL, the same as all kernel sources.
  *
- *  Version:	$Id$
+ *  Version:	$Id$
  *
  *  Authors:	Andrey V. Savochkin <saw@msu.ru>
  */
diff -Nur linux-2.6.13.1.org/net/ipv4/ip_forward.c grsecurity226/net/ipv4/ip_forward.c
--- linux-2.6.13.1.org/net/ipv4/ip_forward.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ip_forward.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		The IP forwarding functionality.
  *		
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	see ip.c
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ip_fragment.c grsecurity226/net/ipv4/ip_fragment.c
--- linux-2.6.13.1.org/net/ipv4/ip_fragment.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ip_fragment.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		The IP fragmentation functionality.
  *		
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Fred N. van Kempen <waltje@uWalt.NL.Mugnet.ORG>
  *		Alan Cox <Alan.Cox@linux.org>
@@ -457,7 +457,7 @@
 
 	if (pskb_pull(skb, ihl) == NULL)
 		goto err;
-	if (pskb_trim_rcsum(skb, end-offset))
+	if (pskb_trim(skb, end-offset))
 		goto err;
 
 	/* Find out which fragments are in front and at the back of us
diff -Nur linux-2.6.13.1.org/net/ipv4/ip_input.c grsecurity226/net/ipv4/ip_input.c
--- linux-2.6.13.1.org/net/ipv4/ip_input.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ip_input.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		The Internet Protocol (IP) module.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/ip_options.c grsecurity226/net/ipv4/ip_options.c
--- linux-2.6.13.1.org/net/ipv4/ip_options.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ip_options.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		The options processing module for ip.c
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	A.N.Kuznetsov
  *		
diff -Nur linux-2.6.13.1.org/net/ipv4/ip_output.c grsecurity226/net/ipv4/ip_output.c
--- linux-2.6.13.1.org/net/ipv4/ip_output.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ip_output.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		The Internet Protocol (IP) output module.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/ip_sockglue.c grsecurity226/net/ipv4/ip_sockglue.c
--- linux-2.6.13.1.org/net/ipv4/ip_sockglue.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ip_sockglue.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		The IP to API glue.
  *		
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	see ip.c
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipconfig.c grsecurity226/net/ipv4/ipconfig.c
--- linux-2.6.13.1.org/net/ipv4/ipconfig.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipconfig.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *  $Id$
+ *  $Id$
  *
  *  Automatic Configuration of IP -- use DHCP, BOOTP, RARP, or
  *  user-supplied information to configure own IP address and routes.
diff -Nur linux-2.6.13.1.org/net/ipv4/ipip.c grsecurity226/net/ipv4/ipip.c
--- linux-2.6.13.1.org/net/ipv4/ipip.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipip.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *	Linux NET3:	IP/IP protocol decoder. 
  *
- *	Version: $Id$
+ *	Version: $Id$
  *
  *	Authors:
  *		Sam Lantinga (slouken@cs.ucdavis.edu)  02/01/95
diff -Nur linux-2.6.13.1.org/net/ipv4/ipmr.c grsecurity226/net/ipv4/ipmr.c
--- linux-2.6.13.1.org/net/ipv4/ipmr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipmr.c	2005-08-30 01:01:03.000000000 +0200
@@ -9,7 +9,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  *
- *	Version: $Id$
+ *	Version: $Id$
  *
  *	Fixes:
  *	Michael Chastain	:	Incorrect size of copying.
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_app.c grsecurity226/net/ipv4/ipvs/ip_vs_app.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_app.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_app.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_app.c: Application module support for IPVS
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_conn.c grsecurity226/net/ipv4/ipvs/ip_vs_conn.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_conn.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_conn.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *              high-performance and highly available server based on a
  *              cluster of servers.
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Peter Kese <peter.kese@ijs.si>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_core.c grsecurity226/net/ipv4/ipvs/ip_vs_core.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_core.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_core.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *              high-performance and highly available server based on a
  *              cluster of servers.
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Peter Kese <peter.kese@ijs.si>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_ctl.c grsecurity226/net/ipv4/ipvs/ip_vs_ctl.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_ctl.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_ctl.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *              high-performance and highly available server based on a
  *              cluster of servers.
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Peter Kese <peter.kese@ijs.si>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_dh.c grsecurity226/net/ipv4/ipvs/ip_vs_dh.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_dh.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_dh.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Destination Hashing scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@gnuchina.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_est.c grsecurity226/net/ipv4/ipvs/ip_vs_est.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_est.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_est.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_est.c: simple rate estimator for IPVS
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_ftp.c grsecurity226/net/ipv4/ipvs/ip_vs_ftp.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_ftp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_ftp.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_ftp.c: IPVS ftp application module
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Wensong Zhang <wensong@linuxvirtualserver.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_lblc.c grsecurity226/net/ipv4/ipvs/ip_vs_lblc.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_lblc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_lblc.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Locality-Based Least-Connection scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@gnuchina.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_lblcr.c grsecurity226/net/ipv4/ipvs/ip_vs_lblcr.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_lblcr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_lblcr.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Locality-Based Least-Connection with Replication scheduler
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@gnuchina.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_lc.c grsecurity226/net/ipv4/ipvs/ip_vs_lc.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_lc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_lc.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Least-Connection Scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_nq.c grsecurity226/net/ipv4/ipvs/ip_vs_nq.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_nq.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_nq.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Never Queue scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto.c grsecurity226/net/ipv4/ipvs/ip_vs_proto.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_proto.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_proto.c: transport protocol load balancing support for IPVS
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Julian Anastasov <ja@ssi.bg>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto_ah.c grsecurity226/net/ipv4/ipvs/ip_vs_proto_ah.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto_ah.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_proto_ah.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_proto_ah.c:	AH IPSec load balancing support for IPVS
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:	Julian Anastasov <ja@ssi.bg>, February 2002
  *		Wensong Zhang <wensong@linuxvirtualserver.org>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto_esp.c grsecurity226/net/ipv4/ipvs/ip_vs_proto_esp.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto_esp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_proto_esp.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_proto_esp.c:	ESP IPSec load balancing support for IPVS
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:	Julian Anastasov <ja@ssi.bg>, February 2002
  *		Wensong Zhang <wensong@linuxvirtualserver.org>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto_tcp.c grsecurity226/net/ipv4/ipvs/ip_vs_proto_tcp.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto_tcp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_proto_tcp.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_proto_tcp.c:	TCP load balancing support for IPVS
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Julian Anastasov <ja@ssi.bg>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto_udp.c grsecurity226/net/ipv4/ipvs/ip_vs_proto_udp.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_proto_udp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_proto_udp.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_proto_udp.c:	UDP load balancing support for IPVS
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Julian Anastasov <ja@ssi.bg>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_rr.c grsecurity226/net/ipv4/ipvs/ip_vs_rr.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_rr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_rr.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Round-Robin Scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Peter Kese <peter.kese@ijs.si>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_sched.c grsecurity226/net/ipv4/ipvs/ip_vs_sched.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_sched.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_sched.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *              high-performance and highly available server based on a
  *              cluster of servers.
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Peter Kese <peter.kese@ijs.si>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_sed.c grsecurity226/net/ipv4/ipvs/ip_vs_sed.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_sed.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_sed.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Shortest Expected Delay scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_sh.c grsecurity226/net/ipv4/ipvs/ip_vs_sh.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_sh.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_sh.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Source Hashing scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@gnuchina.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_sync.c grsecurity226/net/ipv4/ipvs/ip_vs_sync.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_sync.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_sync.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *              high-performance and highly available server based on a
  *              cluster of servers.
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_wlc.c grsecurity226/net/ipv4/ipvs/ip_vs_wlc.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_wlc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_wlc.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Weighted Least-Connection Scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Peter Kese <peter.kese@ijs.si>
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_wrr.c grsecurity226/net/ipv4/ipvs/ip_vs_wrr.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_wrr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_wrr.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * IPVS:        Weighted Round-Robin Scheduling module
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_xmit.c grsecurity226/net/ipv4/ipvs/ip_vs_xmit.c
--- linux-2.6.13.1.org/net/ipv4/ipvs/ip_vs_xmit.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/ipvs/ip_vs_xmit.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * ip_vs_xmit.c: various packet transmitters for IPVS
  *
- * Version:     $Id$
+ * Version:     $Id$
  *
  * Authors:     Wensong Zhang <wensong@linuxvirtualserver.org>
  *              Julian Anastasov <ja@ssi.bg>
diff -Nur linux-2.6.13.1.org/net/ipv4/multipath_drr.c grsecurity226/net/ipv4/multipath_drr.c
--- linux-2.6.13.1.org/net/ipv4/multipath_drr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/multipath_drr.c	2005-08-30 01:01:03.000000000 +0200
@@ -2,7 +2,7 @@
  *              Device round robin policy for multipath.
  *
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Einar Lueck <elueck@de.ibm.com><lkml@einar-lueck.de>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/multipath_random.c grsecurity226/net/ipv4/multipath_random.c
--- linux-2.6.13.1.org/net/ipv4/multipath_random.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/multipath_random.c	2005-08-30 01:01:03.000000000 +0200
@@ -2,7 +2,7 @@
  *              Random policy for multipath.
  *
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Einar Lueck <elueck@de.ibm.com><lkml@einar-lueck.de>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/multipath_rr.c grsecurity226/net/ipv4/multipath_rr.c
--- linux-2.6.13.1.org/net/ipv4/multipath_rr.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/multipath_rr.c	2005-08-30 01:01:03.000000000 +0200
@@ -2,7 +2,7 @@
  *              Round robin policy for multipath.
  *
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Einar Lueck <elueck@de.ibm.com><lkml@einar-lueck.de>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/multipath_wrandom.c grsecurity226/net/ipv4/multipath_wrandom.c
--- linux-2.6.13.1.org/net/ipv4/multipath_wrandom.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/multipath_wrandom.c	2005-08-30 01:01:03.000000000 +0200
@@ -2,7 +2,7 @@
  *              Weighted random policy for multipath.
  *
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Einar Lueck <elueck@de.ibm.com><lkml@einar-lueck.de>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/netfilter/Kconfig grsecurity226/net/ipv4/netfilter/Kconfig
--- linux-2.6.13.1.org/net/ipv4/netfilter/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/netfilter/Kconfig	2005-08-30 01:15:20.000000000 +0200
@@ -256,6 +256,21 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_MATCH_STEALTH
+	tristate "stealth match support"
+	depends on IP_NF_IPTABLES
+	help
+	  Enabling this option will drop all syn packets coming to unserved tcp
+	  ports as well as all packets coming to unserved udp ports.  If you
+	  are using your system to route any type of packets (ie. via NAT)
+	  you should put this module at the end of your ruleset, since it will
+	  drop packets that aren't going to ports that are listening on your
+	  machine itself, it doesn't take into account that the packet might be
+	  destined for someone on your internal network if you're using NAT for
+	  instance.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config IP_NF_MATCH_HELPER
 	tristate "Helper match support"
 	depends on IP_NF_CONNTRACK && IP_NF_IPTABLES
diff -Nur linux-2.6.13.1.org/net/ipv4/netfilter/Makefile grsecurity226/net/ipv4/netfilter/Makefile
--- linux-2.6.13.1.org/net/ipv4/netfilter/Makefile	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/netfilter/Makefile	2005-08-30 01:15:20.000000000 +0200
@@ -59,6 +59,7 @@
 obj-$(CONFIG_IP_NF_MATCH_ADDRTYPE) += ipt_addrtype.o
 obj-$(CONFIG_IP_NF_MATCH_PHYSDEV) += ipt_physdev.o
 obj-$(CONFIG_IP_NF_MATCH_COMMENT) += ipt_comment.o
+obj-$(CONFIG_IP_NF_MATCH_STEALTH) += ipt_stealth.o
 
 # targets
 obj-$(CONFIG_IP_NF_TARGET_REJECT) += ipt_REJECT.o
diff -Nur linux-2.6.13.1.org/net/ipv4/netfilter/ipt_hashlimit.c grsecurity226/net/ipv4/netfilter/ipt_hashlimit.c
--- linux-2.6.13.1.org/net/ipv4/netfilter/ipt_hashlimit.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/netfilter/ipt_hashlimit.c	2005-08-30 01:01:04.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * (C) 2003-2004 by Harald Welte <laforge@netfilter.org>
  *
- * $Id$
+ * $Id$
  *
  * Development of this code was funded by Astaro AG, http://www.astaro.com/
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/netfilter/ipt_realm.c grsecurity226/net/ipv4/netfilter/ipt_realm.c
--- linux-2.6.13.1.org/net/ipv4/netfilter/ipt_realm.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/netfilter/ipt_realm.c	2005-08-30 01:01:04.000000000 +0200
@@ -1,6 +1,6 @@
 /* IP tables module for matching the routing realm
  *
- * $Id$
+ * $Id$
  *
  * (C) 2003 by Sampsa Ranta <sampsa@netsonic.fi>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/netfilter/ipt_stealth.c grsecurity226/net/ipv4/netfilter/ipt_stealth.c
--- linux-2.6.13.1.org/net/ipv4/netfilter/ipt_stealth.c	1970-01-01 01:00:00.000000000 +0100
+++ grsecurity226/net/ipv4/netfilter/ipt_stealth.c	2005-08-30 01:15:20.000000000 +0200
@@ -0,0 +1,113 @@
+/* Kernel module to add stealth support.
+ *
+ * Copyright (C) 2002 Brad Spengler  <spender@grsecurity.net>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/net.h>
+#include <linux/sched.h>
+#include <linux/inet.h>
+#include <linux/stddef.h>
+
+#include <net/ip.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+#include <net/udp.h>
+#include <net/route.h>
+#include <net/inet_common.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+MODULE_LICENSE("GPL");
+
+extern struct sock *tcp_v4_lookup_listener(u32 daddr, unsigned short hnum, int dif);
+extern struct sock *udp_v4_lookup(u32 saddr, u16 sport, u32 daddr, u16 dport, int dif);
+
+static int
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+      const void *matchinfo,
+      int offset,
+      int *hotdrop)
+{
+	struct iphdr *ip = skb->nh.iph;
+	struct tcphdr th;
+	struct udphdr uh;
+	struct sock *sk = NULL;
+
+	if (!ip || offset) return 0;
+
+	switch(ip->protocol) {
+	case IPPROTO_TCP:
+		if (skb_copy_bits(skb, skb->nh.iph->ihl*4, &th, sizeof(th)) < 0) {
+			*hotdrop = 1;
+			return 0;
+		}
+		if (!(th.syn && !th.ack)) return 0;
+		sk = tcp_v4_lookup_listener(ip->daddr, ntohs(th.dest), ((struct rtable*)skb->dst)->rt_iif);	
+		break;
+	case IPPROTO_UDP:
+		if (skb_copy_bits(skb, skb->nh.iph->ihl*4, &uh, sizeof(uh)) < 0) {
+			*hotdrop = 1;
+			return 0;
+		}
+		sk = udp_v4_lookup(ip->saddr, uh.source, ip->daddr, uh.dest, skb->dev->ifindex);
+		break;
+	default:
+		return 0;
+	}
+
+	if(!sk) // port is being listened on, match this
+		return 1;
+	else {
+		sock_put(sk);
+		return 0;
+	}
+}
+
+/* Called when user tries to insert an entry of this type. */
+static int
+checkentry(const char *tablename,
+           const struct ipt_ip *ip,
+           void *matchinfo,
+           unsigned int matchsize,
+           unsigned int hook_mask)
+{
+        if (matchsize != IPT_ALIGN(0))
+                return 0;
+
+	if(((ip->proto == IPPROTO_TCP && !(ip->invflags & IPT_INV_PROTO)) ||
+		((ip->proto == IPPROTO_UDP) && !(ip->invflags & IPT_INV_PROTO)))
+		&& (hook_mask & (1 << NF_IP_LOCAL_IN)))
+			return 1;
+
+	printk("stealth: Only works on TCP and UDP for the INPUT chain.\n");
+
+        return 0;
+}
+
+
+static struct ipt_match stealth_match = {
+	.name = "stealth",
+	.match = &match,
+	.checkentry = &checkentry,
+	.destroy = NULL,
+	.me = THIS_MODULE
+};
+
+static int __init init(void)
+{
+	return ipt_register_match(&stealth_match);
+}
+
+static void __exit fini(void)
+{
+	ipt_unregister_match(&stealth_match);
+}
+
+module_init(init);
+module_exit(fini);
diff -Nur linux-2.6.13.1.org/net/ipv4/proc.c grsecurity226/net/ipv4/proc.c
--- linux-2.6.13.1.org/net/ipv4/proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/proc.c	2005-08-30 01:01:03.000000000 +0200
@@ -7,7 +7,7 @@
  *		PROC file system.  It is mainly used for debugging and
  *		statistics.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
  *		Gerald J. Heim, <heim@peanuts.informatik.uni-tuebingen.de>
diff -Nur linux-2.6.13.1.org/net/ipv4/protocol.c grsecurity226/net/ipv4/protocol.c
--- linux-2.6.13.1.org/net/ipv4/protocol.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/protocol.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		INET protocol dispatch tables.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/raw.c grsecurity226/net/ipv4/raw.c
--- linux-2.6.13.1.org/net/ipv4/raw.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/raw.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		RAW - implementation of IP "raw" sockets.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
@@ -358,7 +358,7 @@
 
 			if (type && code) {
 				get_user(fl->fl_icmp_type, type);
-			        get_user(fl->fl_icmp_code, code);
+				__get_user(fl->fl_icmp_code, code);
 				probed = 1;
 			}
 			break;
diff -Nur linux-2.6.13.1.org/net/ipv4/route.c grsecurity226/net/ipv4/route.c
--- linux-2.6.13.1.org/net/ipv4/route.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/route.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		ROUTE - implementation of the IP router.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/syncookies.c grsecurity226/net/ipv4/syncookies.c
--- linux-2.6.13.1.org/net/ipv4/syncookies.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/syncookies.c	2005-08-30 01:01:03.000000000 +0200
@@ -9,7 +9,7 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  * 
- *  $Id$
+ *  $Id$
  *
  *  Missing: IPv6 support. 
  */
diff -Nur linux-2.6.13.1.org/net/ipv4/sysctl_net_ipv4.c grsecurity226/net/ipv4/sysctl_net_ipv4.c
--- linux-2.6.13.1.org/net/ipv4/sysctl_net_ipv4.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/sysctl_net_ipv4.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * sysctl_net_ipv4.c: sysctl interface to net IPV4 subsystem.
  *
- * $Id$
+ * $Id$
  *
  * Begun April 1, 1996, Mike Shaver.
  * Added /proc/sys/net/ipv4 directory entry (empty =) ). [MS]
diff -Nur linux-2.6.13.1.org/net/ipv4/tcp.c grsecurity226/net/ipv4/tcp.c
--- linux-2.6.13.1.org/net/ipv4/tcp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/tcp.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		Implementation of the Transmission Control Protocol(TCP).
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/tcp_diag.c grsecurity226/net/ipv4/tcp_diag.c
--- linux-2.6.13.1.org/net/ipv4/tcp_diag.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/tcp_diag.c	2005-08-30 01:01:03.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * tcp_diag.c	Module for monitoring TCP sockets.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
  *
diff -Nur linux-2.6.13.1.org/net/ipv4/tcp_input.c grsecurity226/net/ipv4/tcp_input.c
--- linux-2.6.13.1.org/net/ipv4/tcp_input.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/tcp_input.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		Implementation of the Transmission Control Protocol(TCP).
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/tcp_ipv4.c grsecurity226/net/ipv4/tcp_ipv4.c
--- linux-2.6.13.1.org/net/ipv4/tcp_ipv4.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/tcp_ipv4.c	2005-08-30 01:15:18.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		Implementation of the Transmission Control Protocol(TCP).
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  *		IPv4 specific functions
  *
@@ -62,6 +62,7 @@
 #include <linux/jhash.h>
 #include <linux/init.h>
 #include <linux/times.h>
+#include <linux/grsecurity.h>
 
 #include <net/icmp.h>
 #include <net/tcp.h>
@@ -75,6 +76,8 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
+extern void gr_update_task_in_ip_table(struct task_struct *task, const struct inet_sock *inet);
+
 extern int sysctl_ip_dynaddr;
 int sysctl_tcp_tw_reuse;
 int sysctl_tcp_low_latency;
@@ -226,6 +229,10 @@
 			rover = low;
 		else
 			rover = tcp_port_rover;
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+		if (grsec_enable_randsrc && (high > low))
+			rover = low + (get_random_long() % remaining);
+#endif
 		do {
 			rover++;
 			if (rover > high)
@@ -456,7 +463,7 @@
 }
 
 /* Optimize the common listener case. */
-static inline struct sock *tcp_v4_lookup_listener(u32 daddr,
+struct sock *tcp_v4_lookup_listener(u32 daddr,
 		unsigned short hnum, int dif)
 {
 	struct sock *sk = NULL;
@@ -482,6 +489,8 @@
 	return sk;
 }
 
+EXPORT_SYMBOL_GPL(tcp_v4_lookup_listener);
+
 /* Sockets in TCP_CLOSE state are _always_ taken out of the hash, so
  * we need not check it for TCP lookups anymore, thanks Alexey. -DaveM
  *
@@ -673,7 +682,12 @@
 		struct hlist_node *node;
  		struct tcp_tw_bucket *tw = NULL;
 
- 		local_bh_disable();
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+		if (grsec_enable_randsrc)
+			offset = get_random_long();
+#endif
+
+		local_bh_disable();
 		for (i = 1; i <= range; i++) {
 			port = low + (i + offset) % range;
  			head = &tcp_bhash[tcp_bhashfn(port)];
@@ -722,6 +736,8 @@
  		}
  		spin_unlock(&head->lock);
 
+		gr_update_task_in_ip_table(current, inet_sk(sk));
+
  		if (tw) {
  			tcp_tw_deschedule(tw);
  			tcp_tw_put(tw);
diff -Nur linux-2.6.13.1.org/net/ipv4/tcp_minisocks.c grsecurity226/net/ipv4/tcp_minisocks.c
--- linux-2.6.13.1.org/net/ipv4/tcp_minisocks.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/tcp_minisocks.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		Implementation of the Transmission Control Protocol(TCP).
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/tcp_output.c grsecurity226/net/ipv4/tcp_output.c
--- linux-2.6.13.1.org/net/ipv4/tcp_output.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/tcp_output.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		Implementation of the Transmission Control Protocol(TCP).
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/tcp_timer.c grsecurity226/net/ipv4/tcp_timer.c
--- linux-2.6.13.1.org/net/ipv4/tcp_timer.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/tcp_timer.c	2005-08-30 01:01:03.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		Implementation of the Transmission Control Protocol(TCP).
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/ipv4/udp.c grsecurity226/net/ipv4/udp.c
--- linux-2.6.13.1.org/net/ipv4/udp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv4/udp.c	2005-08-30 01:15:18.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		The User Datagram Protocol (UDP).
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
@@ -100,6 +100,7 @@
 #include <linux/skbuff.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/grsecurity.h>
 #include <net/sock.h>
 #include <net/udp.h>
 #include <net/icmp.h>
@@ -108,6 +109,12 @@
 #include <net/checksum.h>
 #include <net/xfrm.h>
 
+extern int gr_search_udp_recvmsg(const struct sock *sk,
+				 const struct sk_buff *skb);
+extern int gr_search_udp_sendmsg(const struct sock *sk,
+				 const struct sockaddr_in *addr);
+
+
 /*
  *	Snmp MIB for the UDP layer
  */
@@ -264,8 +271,7 @@
 	return result;
 }
 
-static __inline__ struct sock *udp_v4_lookup(u32 saddr, u16 sport,
-					     u32 daddr, u16 dport, int dif)
+struct sock *udp_v4_lookup(u32 saddr, u16 sport, u32 daddr, u16 dport, int dif)
 {
 	struct sock *sk;
 
@@ -540,9 +546,16 @@
 		dport = usin->sin_port;
 		if (dport == 0)
 			return -EINVAL;
+
+		if (!gr_search_udp_sendmsg(sk, usin))
+			return -EPERM;
 	} else {
 		if (sk->sk_state != TCP_ESTABLISHED)
 			return -EDESTADDRREQ;
+
+		if (!gr_search_udp_sendmsg(sk, NULL))
+			return -EPERM;
+
 		daddr = inet->daddr;
 		dport = inet->dport;
 		/* Open fast path for connected socket.
@@ -796,6 +809,11 @@
 	if (!skb)
 		goto out;
   
+	if (!gr_search_udp_recvmsg(sk, skb)) {
+		err = -EPERM;
+		goto out_free;
+	}
+
   	copied = skb->len - sizeof(struct udphdr);
 	if (copied > len) {
 		copied = len;
diff -Nur linux-2.6.13.1.org/net/ipv6/addrconf.c grsecurity226/net/ipv6/addrconf.c
--- linux-2.6.13.1.org/net/ipv6/addrconf.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/addrconf.c	2005-08-30 01:01:04.000000000 +0200
@@ -6,7 +6,7 @@
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *	Alexey Kuznetsov	<kuznet@ms2.inr.ac.ru>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv6/af_inet6.c grsecurity226/net/ipv6/af_inet6.c
--- linux-2.6.13.1.org/net/ipv6/af_inet6.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/af_inet6.c	2005-08-30 01:01:04.000000000 +0200
@@ -7,7 +7,7 @@
  *
  *	Adapted from linux/net/ipv4/af_inet.c
  *
- *	$Id$
+ *	$Id$
  *
  * 	Fixes:
  *	piggy, Karl Knutson	:	Socket protocol table
diff -Nur linux-2.6.13.1.org/net/ipv6/datagram.c grsecurity226/net/ipv6/datagram.c
--- linux-2.6.13.1.org/net/ipv6/datagram.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/datagram.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv6/exthdrs.c grsecurity226/net/ipv6/exthdrs.c
--- linux-2.6.13.1.org/net/ipv6/exthdrs.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/exthdrs.c	2005-08-30 01:01:04.000000000 +0200
@@ -7,7 +7,7 @@
  *	Andi Kleen		<ak@muc.de>
  *	Alexey Kuznetsov	<kuznet@ms2.inr.ac.ru>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv6/icmp.c grsecurity226/net/ipv6/icmp.c
--- linux-2.6.13.1.org/net/ipv6/icmp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/icmp.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>
  *
- *	$Id$
+ *	$Id$
  *
  *	Based on net/ipv4/icmp.c
  *
diff -Nur linux-2.6.13.1.org/net/ipv6/ip6_fib.c grsecurity226/net/ipv6/ip6_fib.c
--- linux-2.6.13.1.org/net/ipv6/ip6_fib.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/ip6_fib.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv6/ip6_input.c grsecurity226/net/ipv6/ip6_input.c
--- linux-2.6.13.1.org/net/ipv6/ip6_input.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/ip6_input.c	2005-08-30 01:01:04.000000000 +0200
@@ -6,7 +6,7 @@
  *	Pedro Roque		<roque@di.fc.ul.pt>
  *	Ian P. Morris		<I.P.Morris@soton.ac.uk>
  *
- *	$Id$
+ *	$Id$
  *
  *	Based in linux/net/ipv4/ip_input.c
  *
diff -Nur linux-2.6.13.1.org/net/ipv6/ip6_output.c grsecurity226/net/ipv6/ip6_output.c
--- linux-2.6.13.1.org/net/ipv6/ip6_output.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/ip6_output.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *
- *	$Id$
+ *	$Id$
  *
  *	Based on linux/net/ipv4/ip_output.c
  *
diff -Nur linux-2.6.13.1.org/net/ipv6/ip6_tunnel.c grsecurity226/net/ipv6/ip6_tunnel.c
--- linux-2.6.13.1.org/net/ipv6/ip6_tunnel.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/ip6_tunnel.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Ville Nuorvala		<vnuorval@tcs.hut.fi>	
  *
- *	$Id$
+ *	$Id$
  *
  *      Based on:
  *      linux/net/ipv6/sit.c
diff -Nur linux-2.6.13.1.org/net/ipv6/ipv6_sockglue.c grsecurity226/net/ipv6/ipv6_sockglue.c
--- linux-2.6.13.1.org/net/ipv6/ipv6_sockglue.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/ipv6_sockglue.c	2005-08-30 01:01:04.000000000 +0200
@@ -7,7 +7,7 @@
  *
  *	Based on linux/net/ipv4/ip_sockglue.c
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv6/mcast.c grsecurity226/net/ipv6/mcast.c
--- linux-2.6.13.1.org/net/ipv6/mcast.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/mcast.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *
- *	$Id$
+ *	$Id$
  *
  *	Based on linux/ipv4/igmp.c and linux/ipv4/ip_sockglue.c 
  *
diff -Nur linux-2.6.13.1.org/net/ipv6/proc.c grsecurity226/net/ipv6/proc.c
--- linux-2.6.13.1.org/net/ipv6/proc.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/proc.c	2005-08-30 01:01:04.000000000 +0200
@@ -7,7 +7,7 @@
  *		PROC file system.  This is very similar to the IPv4 version,
  *		except it reports the sockets in the INET6 address family.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	David S. Miller (davem@caip.rutgers.edu)
  * 		YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
diff -Nur linux-2.6.13.1.org/net/ipv6/protocol.c grsecurity226/net/ipv6/protocol.c
--- linux-2.6.13.1.org/net/ipv6/protocol.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/protocol.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		PF_INET6 protocol dispatch tables.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Pedro Roque	<roque@di.fc.ul.pt>
  *
diff -Nur linux-2.6.13.1.org/net/ipv6/raw.c grsecurity226/net/ipv6/raw.c
--- linux-2.6.13.1.org/net/ipv6/raw.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/raw.c	2005-08-30 01:01:04.000000000 +0200
@@ -7,7 +7,7 @@
  *
  *	Adapted from linux/net/ipv4/raw.c
  *
- *	$Id$
+ *	$Id$
  *
  *	Fixes:
  *	Hideaki YOSHIFUJI	:	sin6_scope_id support
@@ -619,7 +619,7 @@
 
 			if (type && code) {
 				get_user(fl->fl_icmp_type, type);
-				get_user(fl->fl_icmp_code, code);
+				__get_user(fl->fl_icmp_code, code);
 				probed = 1;
 			}
 			break;
diff -Nur linux-2.6.13.1.org/net/ipv6/reassembly.c grsecurity226/net/ipv6/reassembly.c
--- linux-2.6.13.1.org/net/ipv6/reassembly.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/reassembly.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *
- *	$Id$
+ *	$Id$
  *
  *	Based on: net/ipv4/ip_fragment.c
  *
diff -Nur linux-2.6.13.1.org/net/ipv6/route.c grsecurity226/net/ipv6/route.c
--- linux-2.6.13.1.org/net/ipv6/route.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/route.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv6/sit.c grsecurity226/net/ipv6/sit.c
--- linux-2.6.13.1.org/net/ipv6/sit.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/sit.c	2005-08-30 01:01:04.000000000 +0200
@@ -6,7 +6,7 @@
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *	Alexey Kuznetsov	<kuznet@ms2.inr.ac.ru>
  *
- *	$Id$
+ *	$Id$
  *
  *	This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
diff -Nur linux-2.6.13.1.org/net/ipv6/tcp_ipv6.c grsecurity226/net/ipv6/tcp_ipv6.c
--- linux-2.6.13.1.org/net/ipv6/tcp_ipv6.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/tcp_ipv6.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>	
  *
- *	$Id$
+ *	$Id$
  *
  *	Based on: 
  *	linux/net/ipv4/tcp.c
diff -Nur linux-2.6.13.1.org/net/ipv6/udp.c grsecurity226/net/ipv6/udp.c
--- linux-2.6.13.1.org/net/ipv6/udp.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/ipv6/udp.c	2005-08-30 01:01:04.000000000 +0200
@@ -7,7 +7,7 @@
  *
  *	Based on linux/ipv4/udp.c
  *
- *	$Id$
+ *	$Id$
  *
  *	Fixes:
  *	Hideaki YOSHIFUJI	:	sin6_scope_id support
diff -Nur linux-2.6.13.1.org/net/packet/af_packet.c grsecurity226/net/packet/af_packet.c
--- linux-2.6.13.1.org/net/packet/af_packet.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/packet/af_packet.c	2005-08-30 01:01:04.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *		PACKET - implements raw packet sockets.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
diff -Nur linux-2.6.13.1.org/net/sched/sch_htb.c grsecurity226/net/sched/sch_htb.c
--- linux-2.6.13.1.org/net/sched/sch_htb.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/sched/sch_htb.c	2005-08-30 01:01:05.000000000 +0200
@@ -25,7 +25,7 @@
  *			fixed requeue routine
  *		and many others. thanks.
  *
- * $Id$
+ * $Id$
  */
 #include <linux/config.h>
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/net/socket.c grsecurity226/net/socket.c
--- linux-2.6.13.1.org/net/socket.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/socket.c	2005-08-30 01:15:16.000000000 +0200
@@ -82,6 +82,7 @@
 #include <linux/compat.h>
 #include <linux/kmod.h>
 #include <linux/audit.h>
+#include <linux/in.h>
 
 #ifdef CONFIG_NET_RADIO
 #include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
@@ -95,6 +96,21 @@
 #include <net/sock.h>
 #include <linux/netfilter.h>
 
+extern void gr_attach_curr_ip(const struct sock *sk);
+extern int gr_handle_sock_all(const int family, const int type,
+			      const int protocol);
+extern int gr_handle_sock_server(const struct sockaddr *sck);
+extern int gr_handle_sock_server_other(const struct socket *sck);
+extern int gr_handle_sock_client(const struct sockaddr *sck);
+extern int gr_search_connect(const struct socket * sock,
+			     const struct sockaddr_in * addr);
+extern int gr_search_bind(const struct socket * sock,
+			   const struct sockaddr_in * addr);
+extern int gr_search_listen(const struct socket * sock);
+extern int gr_search_accept(const struct socket * sock);
+extern int gr_search_socket(const int domain, const int type,
+			    const int protocol);
+
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
 			 size_t size, loff_t pos);
@@ -1182,6 +1198,16 @@
 	int retval;
 	struct socket *sock;
 
+	if(!gr_search_socket(family, type, protocol)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	if (gr_handle_sock_all(family, type, protocol)) {
+		retval = -EACCES;
+		goto out;
+	}
+
 	retval = sock_create(family, type, protocol, &sock);
 	if (retval < 0)
 		goto out;
@@ -1277,11 +1303,23 @@
 {
 	struct socket *sock;
 	char address[MAX_SOCK_ADDR];
+	struct sockaddr *sck;
 	int err;
 
 	if((sock = sockfd_lookup(fd,&err))!=NULL)
 	{
 		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
+			sck = (struct sockaddr *)address;
+			if (!gr_search_bind(sock, (struct sockaddr_in *)sck)) {
+				sockfd_put(sock);
+				return -EACCES;
+			}
+
+			if (gr_handle_sock_server(sck)) {
+				sockfd_put(sock);
+				return -EACCES;
+			}
+
 			err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);
 			if (err) {
 				sockfd_put(sock);
@@ -1318,6 +1356,16 @@
 			return err;
 		}
 
+		if (gr_handle_sock_server_other(sock)) {
+			sockfd_put(sock);
+			return -EPERM;
+		}
+
+		if(!gr_search_listen(sock)) {
+			sockfd_put(sock);
+			return -EPERM;
+		}
+
 		err=sock->ops->listen(sock, backlog);
 		sockfd_put(sock);
 	}
@@ -1358,6 +1406,16 @@
 	if (err)
 		goto out_release;
 
+	if (gr_handle_sock_server_other(sock)) {
+		err = -EPERM;
+		goto out_release;
+	}
+
+	if(!gr_search_accept(sock)) {
+		err = -EPERM;
+		goto out_release;
+	}
+
 	/*
 	 * We don't need try_module_get here, as the listening socket (sock)
 	 * has the protocol module (sock->ops->owner) held.
@@ -1384,6 +1442,7 @@
 		goto out_release;
 
 	security_socket_post_accept(sock, newsock);
+	gr_attach_curr_ip(newsock->sk);
 
 out_put:
 	sockfd_put(sock);
@@ -1411,6 +1470,7 @@
 {
 	struct socket *sock;
 	char address[MAX_SOCK_ADDR];
+	struct sockaddr *sck;
 	int err;
 
 	sock = sockfd_lookup(fd, &err);
@@ -1420,6 +1480,18 @@
 	if (err < 0)
 		goto out_put;
 
+	sck = (struct sockaddr *)address;
+
+	if (!gr_search_connect(sock, (struct sockaddr_in *)sck)) {
+		err = -EACCES;
+		goto out_put;
+	}
+
+	if (gr_handle_sock_client(sck)) {
+		err = -EACCES;
+		goto out_put;
+	}
+
 	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
 	if (err)
 		goto out_put;
@@ -1673,6 +1745,7 @@
 		err=sock->ops->shutdown(sock, how);
 		sockfd_put(sock);
 	}
+
 	return err;
 }
 
@@ -1739,11 +1812,10 @@
 		goto out_freeiov;
 	ctl_len = msg_sys.msg_controllen; 
 	if ((MSG_CMSG_COMPAT & flags) && ctl_len) {
-		err = cmsghdr_from_user_compat_to_kern(&msg_sys, sock->sk, ctl, sizeof(ctl));
+		err = cmsghdr_from_user_compat_to_kern(&msg_sys, ctl, sizeof(ctl));
 		if (err)
 			goto out_freeiov;
 		ctl_buf = msg_sys.msg_control;
-		ctl_len = msg_sys.msg_controllen;
 	} else if (ctl_len) {
 		if (ctl_len > sizeof(ctl))
 		{
diff -Nur linux-2.6.13.1.org/net/sunrpc/auth_gss/auth_gss.c grsecurity226/net/sunrpc/auth_gss/auth_gss.c
--- linux-2.6.13.1.org/net/sunrpc/auth_gss/auth_gss.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/sunrpc/auth_gss/auth_gss.c	2005-08-30 01:01:05.000000000 +0200
@@ -34,7 +34,7 @@
  *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * $Id$
+ * $Id$
  */
 
 
diff -Nur linux-2.6.13.1.org/net/sunrpc/xprt.c grsecurity226/net/sunrpc/xprt.c
--- linux-2.6.13.1.org/net/sunrpc/xprt.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/sunrpc/xprt.c	2005-08-30 01:15:23.000000000 +0200
@@ -58,6 +58,7 @@
 #include <linux/file.h>
 #include <linux/workqueue.h>
 #include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #include <net/sock.h>
 #include <net/checksum.h>
diff -Nur linux-2.6.13.1.org/net/sysctl_net.c grsecurity226/net/sysctl_net.c
--- linux-2.6.13.1.org/net/sysctl_net.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/sysctl_net.c	2005-08-30 01:01:01.000000000 +0200
@@ -5,6 +5,9 @@
  * Added /proc/sys/net directories for each protocol family. [MS]
  *
  * $Log$
+ * Revision 1.1.1.1  2005/08/29 23:01:01  spender
+ * Initial import of Linux 2.6.13
+ *
  * Revision 1.2  1996/05/08  20:24:40  shaver
  * Added bits for NET_BRIDGE and the NET_IPV4_ARP stuff and
  * NET_IPV4_IP_FORWARD.
diff -Nur linux-2.6.13.1.org/net/unix/af_unix.c grsecurity226/net/unix/af_unix.c
--- linux-2.6.13.1.org/net/unix/af_unix.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/net/unix/af_unix.c	2005-08-30 01:15:25.000000000 +0200
@@ -8,7 +8,7 @@
  *		as published by the Free Software Foundation; either version
  *		2 of the License, or (at your option) any later version.
  *
- * Version:	$Id$
+ * Version:	$Id$
  *
  * Fixes:
  *		Linus Torvalds	:	Assorted bug cures.
@@ -117,6 +117,7 @@
 #include <linux/mount.h>
 #include <net/checksum.h>
 #include <linux/security.h>
+#include <linux/grsecurity.h>
 
 int sysctl_unix_max_dgram_qlen = 10;
 
@@ -680,6 +681,11 @@
 		if (err)
 			goto put_fail;
 
+		if (!gr_acl_handle_unix(nd.dentry, nd.mnt)) {
+			err = -EACCES;
+			goto put_fail;
+		}
+
 		err = -ECONNREFUSED;
 		if (!S_ISSOCK(nd.dentry->d_inode->i_mode))
 			goto put_fail;
@@ -703,6 +709,13 @@
 		if (u) {
 			struct dentry *dentry;
 			dentry = unix_sk(u)->dentry;
+
+			if (!gr_handle_chroot_unix(u->sk_peercred.pid)) {
+				err = -EPERM;
+				sock_put(u);
+				goto fail;
+			}
+
 			if (dentry)
 				touch_atime(unix_sk(u)->mnt, dentry);
 		} else
@@ -781,9 +794,18 @@
 		 */
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
+
+		if (!gr_acl_handle_mknod(dentry, nd.dentry, nd.mnt, mode)) {
+			err = -EACCES;
+			goto out_mknod_dput;
+		}
+
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
 		if (err)
 			goto out_mknod_dput;
+
+		gr_handle_create(dentry, nd.mnt);
+
 		up(&nd.dentry->d_inode->i_sem);
 		dput(nd.dentry);
 		nd.dentry = dentry;
@@ -801,6 +823,10 @@
 			goto out_unlock;
 		}
 
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+		sk->sk_peercred.pid = current->pid;
+#endif
+
 		list = &unix_socket_table[addr->hash];
 	} else {
 		list = &unix_socket_table[dentry->d_inode->i_ino & (UNIX_HASH_SIZE-1)];
diff -Nur linux-2.6.13.1.org/scripts/genksyms/lex.c_shipped grsecurity226/scripts/genksyms/lex.c_shipped
--- linux-2.6.13.1.org/scripts/genksyms/lex.c_shipped	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/scripts/genksyms/lex.c_shipped	2005-08-30 01:01:05.000000000 +0200
@@ -2,7 +2,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header$
+ * $Header$
  */
 
 #define FLEX_SCANNER
diff -Nur linux-2.6.13.1.org/scripts/mod/sumversion.c grsecurity226/scripts/mod/sumversion.c
--- linux-2.6.13.1.org/scripts/mod/sumversion.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/scripts/mod/sumversion.c	2005-08-30 01:01:05.000000000 +0200
@@ -469,7 +469,7 @@
 	full_len = strlen(version) + strlen(version + strlen(version) + 1) + 2;
 
 	/* Move string to start with version number: prefix will be
-	 * $Revision$ or $Revision: */
+	 * $Revision$ or $Revision: */
 	len = strlen("$Revision");
 	if (version[len] == ':' || version[len] == '$')
 		len++;
diff -Nur linux-2.6.13.1.org/security/Kconfig grsecurity226/security/Kconfig
--- linux-2.6.13.1.org/security/Kconfig	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/security/Kconfig	2005-08-30 01:15:28.000000000 +0200
@@ -4,6 +4,407 @@
 
 menu "Security options"
 
+source grsecurity/Kconfig
+
+menu "PaX"
+
+config PAX
+	bool "Enable various PaX features"
+	depends on GRKERNSEC && (ALPHA || ARM || IA64 || MIPS32 || MIPS64 || PARISC || PPC32 || PPC64 || SPARC32 || SPARC64 || X86 || X86_64)
+	help
+	  This allows you to enable various PaX features.  PaX adds
+	  intrusion prevention mechanisms to the kernel that reduce
+	  the risks posed by exploitable memory corruption bugs.
+
+menu "PaX Control"
+	depends on PAX
+
+config PAX_SOFTMODE
+	bool 'Support soft mode'
+	help
+	  Enabling this option will allow you to run PaX in soft mode, that
+	  is, PaX features will not be enforced by default, only on executables
+	  marked explicitly.  You must also enable PT_PAX_FLAGS support as it
+	  is the only way to mark executables for soft mode use.
+
+	  Soft mode can be activated by using the "pax_softmode=1" kernel command
+	  line option on boot.  Furthermore you can control various PaX features
+	  at runtime via the entries in /proc/sys/kernel/pax.
+
+config PAX_EI_PAX
+	bool 'Use legacy ELF header marking'
+	help
+	  Enabling this option will allow you to control PaX features on
+	  a per executable basis via the 'chpax' utility available at
+	  http://pax.grsecurity.net/.  The control flags will be read from
+	  an otherwise reserved part of the ELF header.  This marking has
+	  numerous drawbacks (no support for soft-mode, toolchain does not
+	  know about the non-standard use of the ELF header) therefore it
+	  has been deprecated in favour of PT_PAX_FLAGS support.
+
+	  If you have applications not marked by the PT_PAX_FLAGS ELF
+	  program header then you MUST enable this option otherwise they
+	  will not get any protection.
+
+	  Note that if you enable PT_PAX_FLAGS marking support as well,
+	  the PT_PAX_FLAG marks will override the legacy EI_PAX marks.
+
+config PAX_PT_PAX_FLAGS
+	bool 'Use ELF program header marking'
+	help
+	  Enabling this option will allow you to control PaX features on
+	  a per executable basis via the 'paxctl' utility available at
+	  http://pax.grsecurity.net/.  The control flags will be read from
+	  a PaX specific ELF program header (PT_PAX_FLAGS).  This marking
+	  has the benefits of supporting both soft mode and being fully
+	  integrated into the toolchain (the binutils patch is available
+	  from http://pax.grsecurity.net).
+
+	  If you have applications not marked by the PT_PAX_FLAGS ELF
+	  program header then you MUST enable the EI_PAX marking support
+	  otherwise they will not get any protection.
+
+	  Note that if you enable the legacy EI_PAX marking support as well,
+	  the EI_PAX marks will be overridden by the PT_PAX_FLAGS marks.
+
+choice
+	prompt 'MAC system integration'
+	default PAX_HAVE_ACL_FLAGS
+	help
+	  Mandatory Access Control systems have the option of controlling
+	  PaX flags on a per executable basis, choose the method supported
+	  by your particular system.
+
+	  - "none": if your MAC system does not interact with PaX,
+	  - "direct": if your MAC system defines pax_set_flags() itself,
+	  - "hook": if your MAC system uses the pax_set_flags_func callback.
+
+	  NOTE: this option is for developers/integrators only.
+
+config PAX_NO_ACL_FLAGS
+	bool 'none'
+
+config PAX_HAVE_ACL_FLAGS
+	bool 'direct'
+
+config PAX_HOOK_ACL_FLAGS
+	bool 'hook'
+endchoice
+
+endmenu
+
+menu "Non-executable pages"
+	depends on PAX
+
+config PAX_NOEXEC
+	bool "Enforce non-executable pages"
+	depends on (PAX_EI_PAX || PAX_PT_PAX_FLAGS || PAX_HAVE_ACL_FLAGS || PAX_HOOK_ACL_FLAGS) && (ALPHA || IA64 || MIPS32 || MIPS64 || PARISC || PPC32 || PPC64 || SPARC32 || SPARC64 || X86 || X86_64)
+	help
+	  By design some architectures do not allow for protecting memory
+	  pages against execution or even if they do, Linux does not make
+	  use of this feature.  In practice this means that if a page is
+	  readable (such as the stack or heap) it is also executable.
+
+	  There is a well known exploit technique that makes use of this
+	  fact and a common programming mistake where an attacker can
+	  introduce code of his choice somewhere in the attacked program's
+	  memory (typically the stack or the heap) and then execute it.
+
+	  If the attacked program was running with different (typically
+	  higher) privileges than that of the attacker, then he can elevate
+	  his own privilege level (e.g. get a root shell, write to files for
+	  which he does not have write access to, etc).
+
+	  Enabling this option will let you choose from various features
+	  that prevent the injection and execution of 'foreign' code in
+	  a program.
+
+	  This will also break programs that rely on the old behaviour and
+	  expect that dynamically allocated memory via the malloc() family
+	  of functions is executable (which it is not).  Notable examples
+	  are the XFree86 4.x server, the java runtime and wine.
+
+config PAX_PAGEEXEC
+	bool "Paging based non-executable pages"
+	depends on PAX_NOEXEC && (!X86 || X86_64 || M586 || M586TSC || M586MMX || M686 || MPENTIUMII || MPENTIUMIII || MPENTIUMM || MPENTIUM4 || MK7 || MK8 || MWINCHIPC6 || MWINCHIP2 || MWINCHIP3D || MVIAC3_2)
+	select PAX_NOVSYSCALL if X86 && !X86_64
+	help
+	  This implementation is based on the paging feature of the CPU.
+	  On i386 and ppc there is a variable but usually low performance
+	  impact on applications.  On alpha, ia64, parisc, sparc, sparc64
+	  and x86_64 there is no performance impact.
+
+config PAX_SEGMEXEC
+	bool "Segmentation based non-executable pages"
+	depends on PAX_NOEXEC && X86 && !X86_64
+	help
+	  This implementation is based on the segmentation feature of the
+	  CPU and has little performance impact, however applications will
+	  be limited to a 1.5 GB address space instead of the normal 3 GB.
+
+choice
+	prompt "Default non-executable page method"
+	depends on PAX_PAGEEXEC && PAX_SEGMEXEC
+	default PAX_DEFAULT_SEGMEXEC
+	help
+	  Select the default non-executable page method applied to applications
+	  that do not select one themselves.
+
+config	PAX_DEFAULT_PAGEEXEC
+	bool "PAGEEXEC"
+
+config	PAX_DEFAULT_SEGMEXEC
+	bool "SEGMEXEC"
+endchoice
+
+config PAX_EMUTRAMP
+	bool "Emulate trampolines" if (PAX_PAGEEXEC || PAX_SEGMEXEC) && (PARISC || PPC32 || X86) && !X86_64
+	default y if PARISC || PPC32
+	help
+	  There are some programs and libraries that for one reason or
+	  another attempt to execute special small code snippets from
+	  non-executable memory pages.  Most notable examples are the
+	  signal handler return code generated by the kernel itself and
+	  the GCC trampolines.
+
+	  If you enabled CONFIG_PAX_PAGEEXEC or CONFIG_PAX_SEGMEXEC then
+	  such programs will no longer work under your kernel.
+
+	  As a remedy you can say Y here and use the 'chpax' or 'paxctl'
+	  utilities to enable trampoline emulation for the affected programs
+	  yet still have the protection provided by the non-executable pages.
+
+	  On parisc and ppc you MUST enable this option and EMUSIGRT as
+	  well, otherwise your system will not even boot.
+
+	  Alternatively you can say N here and use the 'chpax' or 'paxctl'
+	  utilities to disable CONFIG_PAX_PAGEEXEC and CONFIG_PAX_SEGMEXEC
+	  for the affected files.
+
+	  NOTE: enabling this feature *may* open up a loophole in the
+	  protection provided by non-executable pages that an attacker
+	  could abuse.  Therefore the best solution is to not have any
+	  files on your system that would require this option.  This can
+	  be achieved by not using libc5 (which relies on the kernel
+	  signal handler return code) and not using or rewriting programs
+	  that make use of the nested function implementation of GCC.
+	  Skilled users can just fix GCC itself so that it implements
+	  nested function calls in a way that does not interfere with PaX.
+
+config PAX_EMUSIGRT
+	bool "Automatically emulate sigreturn trampolines"
+	depends on PAX_EMUTRAMP && (PARISC || PPC32)
+	default y
+	help
+	  Enabling this option will have the kernel automatically detect
+	  and emulate signal return trampolines executing on the stack
+	  that would otherwise lead to task termination.
+
+	  This solution is intended as a temporary one for users with
+	  legacy versions of libc (libc5, glibc 2.0, uClibc before 0.9.17,
+	  Modula-3 runtime, etc) or executables linked to such, basically
+	  everything that does not specify its own SA_RESTORER function in
+	  normal executable memory like glibc 2.1+ does.
+
+	  On parisc and ppc you MUST enable this option, otherwise your
+	  system will not even boot.
+
+	  NOTE: this feature cannot be disabled on a per executable basis
+	  and since it *does* open up a loophole in the protection provided
+	  by non-executable pages, the best solution is to not have any
+	  files on your system that would require this option.
+
+config PAX_MPROTECT
+	bool "Restrict mprotect()"
+	depends on (PAX_PAGEEXEC || PAX_SEGMEXEC) && !PPC64
+	help
+	  Enabling this option will prevent programs from
+	   - changing the executable status of memory pages that were
+	     not originally created as executable,
+	   - making read-only executable pages writable again,
+	   - creating executable pages from anonymous memory.
+
+	  You should say Y here to complete the protection provided by
+	  the enforcement of non-executable pages.
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+	  this feature on a per file basis.
+
+config PAX_NOELFRELOCS
+	bool "Disallow ELF text relocations"
+	depends on PAX_MPROTECT && !PAX_ETEXECRELOCS && (IA64 || X86 || X86_64)
+	help
+	  Non-executable pages and mprotect() restrictions are effective
+	  in preventing the introduction of new executable code into an
+	  attacked task's address space.  There remain only two venues
+	  for this kind of attack: if the attacker can execute already
+	  existing code in the attacked task then he can either have it
+	  create and mmap() a file containing his code or have it mmap()
+	  an already existing ELF library that does not have position
+	  independent code in it and use mprotect() on it to make it
+	  writable and copy his code there.  While protecting against
+	  the former approach is beyond PaX, the latter can be prevented
+	  by having only PIC ELF libraries on one's system (which do not
+	  need to relocate their code).  If you are sure this is your case,
+	  then enable this option otherwise be careful as you may not even
+	  be able to boot or log on your system (for example, some PAM
+	  modules are erroneously compiled as non-PIC by default).
+
+	  NOTE: if you are using dynamic ELF executables (as suggested
+	  when using ASLR) then you must have made sure that you linked
+	  your files using the PIC version of crt1 (the et_dyn.tar.gz package
+	  referenced there has already been updated to support this).
+
+config PAX_ETEXECRELOCS
+	bool "Allow ELF ET_EXEC text relocations"
+	depends on PAX_MPROTECT && (ALPHA || IA64 || PARISC)
+	default y
+	help
+	  On some architectures there are incorrectly created applications
+	  that require text relocations and would not work without enabling
+	  this option.  If you are an alpha, ia64 or parisc user, you should
+	  enable this option and disable it once you have made sure that
+	  none of your applications need it.
+
+config PAX_EMUPLT
+	bool "Automatically emulate ELF PLT"
+	depends on PAX_MPROTECT && (ALPHA || PARISC || PPC32 || SPARC32 || SPARC64)
+	default y
+	help
+	  Enabling this option will have the kernel automatically detect
+	  and emulate the Procedure Linkage Table entries in ELF files.
+	  On some architectures such entries are in writable memory, and
+	  become non-executable leading to task termination.  Therefore
+	  it is mandatory that you enable this option on alpha, parisc, ppc,
+	  sparc and sparc64, otherwise your system would not even boot.
+
+	  NOTE: this feature *does* open up a loophole in the protection
+	  provided by the non-executable pages, therefore the proper
+	  solution is to modify the toolchain to produce a PLT that does
+	  not need to be writable.
+
+config PAX_DLRESOLVE
+	bool
+	depends on PAX_EMUPLT && (SPARC32 || SPARC64)
+	default y
+
+config PAX_SYSCALL
+	bool
+	depends on PAX_PAGEEXEC && PPC32
+	default y
+
+config PAX_KERNEXEC
+	bool "Enforce non-executable kernel pages"
+	depends on PAX_NOEXEC && X86 && !X86_64 && !MODULES && !HOTPLUG_PCI_COMPAQ_NVRAM && !PCI_BIOS
+	help
+	  This is the kernel land equivalent of PAGEEXEC and MPROTECT,
+	  that is, enabling this option will make it harder to inject
+	  and execute 'foreign' code in kernel memory itself.
+
+endmenu
+
+menu "Address Space Layout Randomization"
+	depends on PAX
+
+config PAX_ASLR
+	bool "Address Space Layout Randomization"
+	depends on PAX_EI_PAX || PAX_PT_PAX_FLAGS || PAX_HAVE_ACL_FLAGS || PAX_HOOK_ACL_FLAGS
+	help
+	  Many if not most exploit techniques rely on the knowledge of
+	  certain addresses in the attacked program.  The following options
+	  will allow the kernel to apply a certain amount of randomization
+	  to specific parts of the program thereby forcing an attacker to
+	  guess them in most cases.  Any failed guess will most likely crash
+	  the attacked program which allows the kernel to detect such attempts
+	  and react on them.  PaX itself provides no reaction mechanisms,
+	  instead it is strongly encouraged that you make use of Nergal's
+	  segvguard (ftp://ftp.pl.openwall.com/misc/segvguard/) or grsecurity's
+	  (http://www.grsecurity.net/) built-in crash detection features or
+	  develop one yourself.
+
+	  By saying Y here you can choose to randomize the following areas:
+	   - top of the task's kernel stack
+	   - top of the task's userland stack
+	   - base address for mmap() requests that do not specify one
+	     (this includes all libraries)
+	   - base address of the main executable
+
+	  It is strongly recommended to say Y here as address space layout
+	  randomization has negligible impact on performance yet it provides
+	  a very effective protection.
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+	  this feature on a per file basis.
+
+config PAX_RANDKSTACK
+	bool "Randomize kernel stack base"
+	depends on PAX_ASLR && X86_TSC && !X86_64
+	help
+	  By saying Y here the kernel will randomize every task's kernel
+	  stack on every system call.  This will not only force an attacker
+	  to guess it but also prevent him from making use of possible
+	  leaked information about it.
+
+	  Since the kernel stack is a rather scarce resource, randomization
+	  may cause unexpected stack overflows, therefore you should very
+	  carefully test your system.  Note that once enabled in the kernel
+	  configuration, this feature cannot be disabled on a per file basis.
+
+config PAX_RANDUSTACK
+	bool "Randomize user stack base"
+	depends on PAX_ASLR
+	help
+	  By saying Y here the kernel will randomize every task's userland
+	  stack.  The randomization is done in two steps where the second
+	  one may apply a big amount of shift to the top of the stack and
+	  cause problems for programs that want to use lots of memory (more
+	  than 2.5 GB if SEGMEXEC is not active, or 1.25 GB when it is).
+	  For this reason the second step can be controlled by 'chpax' or
+	  'paxctl' on a per file basis.
+
+config PAX_RANDMMAP
+	bool "Randomize mmap() base"
+	depends on PAX_ASLR
+	help
+	  By saying Y here the kernel will use a randomized base address for
+	  mmap() requests that do not specify one themselves.  As a result
+	  all dynamically loaded libraries will appear at random addresses
+	  and therefore be harder to exploit by a technique where an attacker
+	  attempts to execute library code for his purposes (e.g. spawn a
+	  shell from an exploited program that is running at an elevated
+	  privilege level).
+
+	  Furthermore, if a program is relinked as a dynamic ELF file, its
+	  base address will be randomized as well, completing the full
+	  randomization of the address space layout.  Attacking such programs
+	  becomes a guess game.  You can find an example of doing this at
+	  http://pax.grsecurity.net/et_dyn.tar.gz and practical samples at
+	  http://www.grsecurity.net/grsec-gcc-specs.tar.gz .
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control this
+	  feature on a per file basis.
+
+config PAX_NOVSYSCALL
+	bool "Disable the vsyscall page"
+	depends on PAX_ASLR && X86 && !X86_64
+	help
+	  The Linux 2.6 kernel introduced a new feature that speeds up or
+	  simplifies certain operations, such as system calls or returns
+	  from signal handlers.
+
+	  Unfortunately the implementation also gives a powerful instrument
+	  into the hands of exploit writers: the so-called vsyscall page exists
+	  in every task at the same fixed address and it contains machine code
+	  that is very useful in performing the return-to-libc style attack.
+
+	  Since this exploit technique cannot in general be protected against
+	  via kernel solutions, this option will allow you to disable the use
+	  of the vsyscall page and revert back to the old behaviour.
+
+endmenu
+
+endmenu
+
 config KEYS
 	bool "Enable access key retention support"
 	help
diff -Nur linux-2.6.13.1.org/security/commoncap.c grsecurity226/security/commoncap.c
--- linux-2.6.13.1.org/security/commoncap.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/security/commoncap.c	2005-08-30 01:15:28.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/ptrace.h>
 #include <linux/xattr.h>
 #include <linux/hugetlb.h>
+#include <linux/grsecurity.h>
 
 int cap_netlink_send(struct sock *sk, struct sk_buff *skb)
 {
@@ -44,7 +45,15 @@
 int cap_capable (struct task_struct *tsk, int cap)
 {
 	/* Derived from include/linux/sched.h:capable. */
-	if (cap_raised(tsk->cap_effective, cap))
+	if (cap_raised (tsk->cap_effective, cap) && gr_task_is_capable(tsk, cap))
+		return 0;
+	return -EPERM;
+}
+
+int cap_capable_nolog (struct task_struct *tsk, int cap)
+{
+	/* Derived from include/linux/sched.h:capable. */
+	if (cap_raised (tsk->cap_effective, cap))
 		return 0;
 	return -EPERM;
 }
@@ -60,7 +69,7 @@
 {
 	/* Derived from arch/i386/kernel/ptrace.c:sys_ptrace. */
 	if (!cap_issubset (child->cap_permitted, current->cap_permitted) &&
-	    !capable(CAP_SYS_PTRACE))
+	    !capable_nolog(CAP_SYS_PTRACE))
 		return -EPERM;
 	return 0;
 }
@@ -163,8 +172,11 @@
 		}
 	}
 
-	current->suid = current->euid = current->fsuid = bprm->e_uid;
-	current->sgid = current->egid = current->fsgid = bprm->e_gid;
+	if (!gr_check_user_change(-1, bprm->e_uid, bprm->e_uid))
+		current->suid = current->euid = current->fsuid = bprm->e_uid;
+
+	if (!gr_check_group_change(-1, bprm->e_gid, bprm->e_gid))
+		current->sgid = current->egid = current->fsgid = bprm->e_gid;
 
 	/* For init, we want to retain the capabilities set
 	 * in the init_task struct. Thus we skip the usual
@@ -175,6 +187,8 @@
 		    cap_intersect (new_permitted, bprm->cap_effective);
 	}
 
+	gr_handle_chroot_caps(current);
+
 	/* AUD: Audit candidate if current->cap_effective is set */
 
 	current->keep_capabilities = 0;
@@ -320,12 +334,13 @@
 {
 	int cap_sys_admin = 0;
 
-	if (cap_capable(current, CAP_SYS_ADMIN) == 0)
+	if (cap_capable_nolog(current, CAP_SYS_ADMIN) == 0)
 		cap_sys_admin = 1;
 	return __vm_enough_memory(pages, cap_sys_admin);
 }
 
 EXPORT_SYMBOL(cap_capable);
+EXPORT_SYMBOL(cap_capable_nolog);
 EXPORT_SYMBOL(cap_settime);
 EXPORT_SYMBOL(cap_ptrace);
 EXPORT_SYMBOL(cap_capget);
diff -Nur linux-2.6.13.1.org/security/dummy.c grsecurity226/security/dummy.c
--- linux-2.6.13.1.org/security/dummy.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/security/dummy.c	2005-08-30 01:15:28.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/hugetlb.h>
 #include <linux/ptrace.h>
 #include <linux/file.h>
+#include <linux/grsecurity.h>
 
 static int dummy_ptrace (struct task_struct *parent, struct task_struct *child)
 {
@@ -138,8 +139,11 @@
 		}
 	}
 
-	current->suid = current->euid = current->fsuid = bprm->e_uid;
-	current->sgid = current->egid = current->fsgid = bprm->e_gid;
+	if (!gr_check_user_change(-1, bprm->e_uid, bprm->e_uid))
+		current->suid = current->euid = current->fsuid = bprm->e_uid;
+
+	if (!gr_check_group_change(-1, bprm->e_gid, bprm->e_gid))
+		current->sgid = current->egid = current->fsgid = bprm->e_gid;
 
 	dummy_capget(current, &current->cap_effective, &current->cap_inheritable, &current->cap_permitted);
 }
diff -Nur linux-2.6.13.1.org/security/security.c grsecurity226/security/security.c
--- linux-2.6.13.1.org/security/security.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/security/security.c	2005-08-30 01:15:28.000000000 +0200
@@ -200,4 +200,5 @@
 EXPORT_SYMBOL_GPL(mod_reg_security);
 EXPORT_SYMBOL_GPL(mod_unreg_security);
 EXPORT_SYMBOL(capable);
+EXPORT_SYMBOL(capable_nolog);
 EXPORT_SYMBOL(security_ops);
diff -Nur linux-2.6.13.1.org/sound/arm/sa11xx-uda1341.c grsecurity226/sound/arm/sa11xx-uda1341.c
--- linux-2.6.13.1.org/sound/arm/sa11xx-uda1341.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/arm/sa11xx-uda1341.c	2005-08-30 01:01:06.000000000 +0200
@@ -21,7 +21,7 @@
  *                              merged HAL layer (patches from Brian)
  */
 
-/* $Id$ */
+/* $Id$ */
 
 /***************************************************************************************************
 *
diff -Nur linux-2.6.13.1.org/sound/i2c/l3/uda1341.c grsecurity226/sound/i2c/l3/uda1341.c
--- linux-2.6.13.1.org/sound/i2c/l3/uda1341.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/i2c/l3/uda1341.c	2005-08-30 01:01:06.000000000 +0200
@@ -17,7 +17,7 @@
  * 2002-05-12   Tomas Kasparek  another code cleanup
  */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <sound/driver.h>
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/sound/oss/ad1889.c grsecurity226/sound/oss/ad1889.c
--- linux-2.6.13.1.org/sound/oss/ad1889.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/ad1889.c	2005-08-30 01:01:07.000000000 +0200
@@ -24,7 +24,7 @@
 <jsm> tausq: Anyway, to set up sample rates for D to A, you just use the sample rate on the codec. For A to D, you need to set the codec always to 48K (using the split sample rate feature on the codec) and then set the resampler on the AD1889 to the sample rate you want.
 <jsm> Also, when changing the sample rate on the codec you need to power it down and re power it up for the change to take effect!
  *
- * $Id$
+ * $Id$
  */
 #include <linux/config.h>
 #include <linux/module.h>
diff -Nur linux-2.6.13.1.org/sound/oss/cmpci.c grsecurity226/sound/oss/cmpci.c
--- linux-2.6.13.1.org/sound/oss/cmpci.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/cmpci.c	2005-08-30 01:01:07.000000000 +0200
@@ -3365,7 +3365,7 @@
 
 static int __init init_cmpci(void)
 {
-	printk(KERN_INFO "cmpci: version $Revision$ time " __TIME__ " " __DATE__ "\n");
+	printk(KERN_INFO "cmpci: version $Revision$ time " __TIME__ " " __DATE__ "\n");
 	return pci_module_init(&cm_driver);
 }
 
diff -Nur linux-2.6.13.1.org/sound/oss/forte.c grsecurity226/sound/oss/forte.c
--- linux-2.6.13.1.org/sound/oss/forte.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/forte.c	2005-08-30 01:01:07.000000000 +0200
@@ -48,7 +48,7 @@
 #include <asm/io.h>
 
 #define DRIVER_NAME	"forte"
-#define DRIVER_VERSION 	"$Id$"
+#define DRIVER_VERSION 	"$Id$"
 #define PFX 		DRIVER_NAME ": "
 
 #undef M_DEBUG
diff -Nur linux-2.6.13.1.org/sound/oss/msnd.c grsecurity226/sound/oss/msnd.c
--- linux-2.6.13.1.org/sound/oss/msnd.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/msnd.c	2005-08-30 01:01:08.000000000 +0200
@@ -20,7 +20,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * $Id$
+ * $Id$
  *
  ********************************************************************/
 
diff -Nur linux-2.6.13.1.org/sound/oss/msnd.h grsecurity226/sound/oss/msnd.h
--- linux-2.6.13.1.org/sound/oss/msnd.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/msnd.h	2005-08-30 01:01:08.000000000 +0200
@@ -24,7 +24,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * $Id$
+ * $Id$
  *
  ********************************************************************/
 #ifndef __MSND_H
diff -Nur linux-2.6.13.1.org/sound/oss/msnd_classic.h grsecurity226/sound/oss/msnd_classic.h
--- linux-2.6.13.1.org/sound/oss/msnd_classic.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/msnd_classic.h	2005-08-30 01:01:08.000000000 +0200
@@ -24,7 +24,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  * 
- * $Id$
+ * $Id$
  *
  ********************************************************************/
 #ifndef __MSND_CLASSIC_H
diff -Nur linux-2.6.13.1.org/sound/oss/msnd_pinnacle.c grsecurity226/sound/oss/msnd_pinnacle.c
--- linux-2.6.13.1.org/sound/oss/msnd_pinnacle.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/msnd_pinnacle.c	2005-08-30 01:01:08.000000000 +0200
@@ -29,7 +29,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * $Id$
+ * $Id$
  *
  * 12-3-2000  Modified IO port validation  Steve Sycamore
  *
diff -Nur linux-2.6.13.1.org/sound/oss/msnd_pinnacle.h grsecurity226/sound/oss/msnd_pinnacle.h
--- linux-2.6.13.1.org/sound/oss/msnd_pinnacle.h	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/msnd_pinnacle.h	2005-08-30 01:01:08.000000000 +0200
@@ -24,7 +24,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * $Id$
+ * $Id$
  *
  ********************************************************************/
 #ifndef __MSND_PINNACLE_H
diff -Nur linux-2.6.13.1.org/sound/oss/wavfront.c grsecurity226/sound/oss/wavfront.c
--- linux-2.6.13.1.org/sound/oss/wavfront.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/oss/wavfront.c	2005-08-30 01:01:09.000000000 +0200
@@ -56,7 +56,7 @@
  * aspects of configuring a WaveFront soundcard, particularly the
  * effects processor.
  *
- * $Id$
+ * $Id$
  *
  * This program is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
  * Version 2 (June 1991). See the "COPYING" file distributed with this software
diff -Nur linux-2.6.13.1.org/sound/pci/au88x0/au88x0_game.c grsecurity226/sound/pci/au88x0/au88x0_game.c
--- linux-2.6.13.1.org/sound/pci/au88x0/au88x0_game.c	2005-09-10 04:42:58.000000000 +0200
+++ grsecurity226/sound/pci/au88x0/au88x0_game.c	2005-08-30 01:01:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Manuel Jander.
  *
