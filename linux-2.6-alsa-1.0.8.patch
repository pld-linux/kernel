diff -uNr a/Documentation/sound/alsa/ALSA-Configuration.txt b/Documentation/sound/alsa/ALSA-Configuration.txt
--- a/Documentation/sound/alsa/ALSA-Configuration.txt	2004-12-24 22:33:52.000000000 +0100
+++ b/Documentation/sound/alsa/ALSA-Configuration.txt	2005-01-14 22:28:25.627462464 +0100
@@ -184,6 +184,8 @@
     Module for ATI IXP 150/200/250 AC97 controllers.
 
     ac97_clock		- AC'97 clock (defalut = 48000)
+    ac97_quirk		- AC'97 workaround for strange hardware
+			  See the description of intel8x0 module for details.
     spdif_aclink	- S/PDIF transfer over AC-link (default = 1)
 
     This module supports up to 8 cards and autoprobe.
@@ -252,9 +254,18 @@
     Module for video cards based on Bt87x chips.
 
     digital_rate - Override the default digital rate (Hz)
+    load_all	- Load the driver even if the card model isn't known
 
     Module supports up to 8 cards.
 
+  Module snd-ca0106
+  -----------------
+
+    Module for Creative Audigy LS and SB Live 24bit
+
+    Module supports up to 8 cards.
+
+
   Module snd-cmi8330
   ------------------
 
@@ -426,6 +437,13 @@
 	* Creative Card 5.1 (c) 2003			[0x3fc3/0x7cff]
         * Creative Card all ins and outs		[0x3fff/0x7fff]
     
+  Module snd-emu10k1x
+  -------------------
+
+    Module for Creative Emu10k1X (SB Live Dell OEM version)
+
+    Module supports up to 8 cards.
+
   Module snd-ens1370
   ------------------
 
@@ -595,8 +613,11 @@
 
     Module supports up to 8 cards.
 
-    Note: you need to load the firmware via hdsploader utility included
-          in alsa-tools and alsa-firmware packages.
+    Note: The firmware data can be automatically loaded via hotplug
+          when CONFIG_FW_LOADER is set.  Otherwise, you need to load
+          the firmware via hdsploader utility included in alsa-tools
+          package.
+          The firmware data is found in alsa-firmware package.
 
     Note: snd-page-alloc module does the job which snd-hammerfall-mem
           module did formerly.  It will allocate the buffers in advance
@@ -661,16 +682,21 @@
 			* ALi m5455
 
     ac97_clock	  - AC'97 codec clock base (0 = auto-detect)
-    ac97_quirk    - AC'97 workaround for strange hardware (-1 = default)
-                    -1 = default, don't override
-                     0 = disable
-                     1 = use headphone control as master
-                     2 = swap headphone and master controls
-                     3 = for AD1985, turn on OMS bit and use headphone
-                     4 = for ALC65x, turn on the jack sense mode
-                     5 = inverted EAPD implementation
-    buggy_irq      - Enable workaround for buggy interrupts on some
-                     motherboards (default off)
+    ac97_quirk    - AC'97 workaround for strange hardware
+                    The following strings are accepted:
+                      default = don't override the default setting
+                      disable = disable the quirk
+                      hp_only = use headphone control as master
+                      swap_hp = swap headphone and master controls
+                      swap_surround = swap master and surround controls
+                      ad_shring = for AD1985, turn on OMS bit and use headphone
+                      alc_jack = for ALC65x, turn on the jack sense mode
+                      inv_eapd = inverted EAPD implementation
+                      mute_led = bind EAPD bit for turning on/off mute LED
+                    For backward compatibility, the corresponding integer
+                    value -1, 0, ... are accepted, too.
+    buggy_irq     - Enable workaround for buggy interrupts on some
+                    motherboards (default off)
 
     Module supports autoprobe and multiple bus-master chips (max 8).
 
@@ -774,6 +800,12 @@
     Note: One miXart8 board will be represented as 4 alsa cards.
           See MIXART.txt for details.
 
+    When the driver is compiled as a module and the hotplug firmware
+    is supported, the firmware data is loaded via hotplug automatically.
+    Install the necessary firmware files in alsa-firmware package.
+    When no hotplug fw loader is available, you need to load the
+    firmware via mixartloader utility in alsa-tools package.
+
   Module snd-mpu401
   -----------------
 
@@ -1182,6 +1214,15 @@
     Note: for the MPU401 on VIA823x, use snd-mpu401 driver
 	  additonally.  The mpu_port option is for VIA686 chips only.
 
+  Module snd-via82xx-modem
+  ------------------------
+
+    Module for VIA82xx AC97 modem
+
+    ac97_clock	- AC'97 codec clock base (default 48000Hz)
+
+    Module supports up to 8 cards.
+
   Module snd-virmidi
   ------------------
 
@@ -1203,9 +1244,12 @@
 
     Module supports up to 8 cards.
 
-    For loading the firmware, use vxloader utility in alsa-tools
-    and alsa-firmware packages.  You can load the firmware automatically
-    by adding the following to /etc/modprobe.conf
+    When the driver is compiled as a module and the hotplug firmware
+    is supported, the firmware data is loaded via hotplug automatically.
+    Install the necessary firmware files in alsa-firmware package.
+    When no hotplug fw loader is available, you need to load the
+    firmware via vxloader utility in alsa-tools package.  To invoke
+    vxloader automatically, add the following to /etc/modprobe.conf
 
 	install snd-vx222 /sbin/modprobe --first-time -i snd-vx222 && /usr/bin/vxloader
 
@@ -1234,8 +1278,11 @@
     To activate the driver via the card manager, you'll need to set
     up /etc/pcmcia/vxpocket.conf.  See the sound/pcmcia/vx/vxpocket.c.
 
-    For loading the firmware, use vxloader utility in alsa-tools
-    and alsa-firmware packages.
+    When the driver is compiled as a module and the hotplug firmware
+    is supported, the firmware data is loaded via hotplug automatically.
+    Install the necessary firmware files in alsa-firmware package.
+    When no hotplug fw loader is available, you need to load the
+    firmware via vxloader utility in alsa-tools package.
 
     The irq_mask and irq_list are provided to avoid allocation of
     specific IRQs.  Usually you don't need to specify them.
@@ -1260,8 +1307,11 @@
     To activate the driver via the card manager, you'll need to set
     up /etc/pcmcia/vxp440.conf.  See the sound/pcmcia/vx/vxp440.c.
 
-    For loading the firmware, use vxloader utility in alsa-tools
-    and alsa-firmware packages.
+    When the driver is compiled as a module and the hotplug firmware
+    is supported, the firmware data is loaded via hotplug automatically.
+    Install the necessary firmware files in alsa-firmware package.
+    When no hotplug fw loader is available, you need to load the
+    firmware via vxloader utility in alsa-tools package.
 
     The irq_mask and irq_list are provided to avoid allocation of
     specific IRQs.  Usually you don't need to specify them.
@@ -1359,18 +1409,21 @@
 ALSA PCM devices to OSS devices mapping
 =======================================
 
-/dev/snd/pcmC0D0  -> /dev/audio0 (/dev/audio) -> minor 4
-/dev/snd/pcmC0D0  -> /dev/dsp0 (/dev/dsp)     -> minor 3
-/dev/snd/pcmC0D1  -> /dev/adsp0 (/dev/adsp)   -> minor 12
-/dev/snd/pcmC1D0  -> /dev/audio1              -> minor 4+16 = 20
-/dev/snd/pcmC1D0  -> /dev/dsp1                -> minor 3+16 = 19
-/dev/snd/pcmC1D1  -> /dev/adsp1               -> minor 12+16 = 28
-/dev/snd/pcmC2D0  -> /dev/audio2              -> minor 4+32 = 36
-/dev/snd/pcmC2D0  -> /dev/dsp2                -> minor 3+32 = 39
-/dev/snd/pcmC2D1  -> /dev/adsp2               -> minor 12+32 = 44
+/dev/snd/pcmC0D0[c|p]  -> /dev/audio0 (/dev/audio) -> minor 4
+/dev/snd/pcmC0D0[c|p]  -> /dev/dsp0 (/dev/dsp)     -> minor 3
+/dev/snd/pcmC0D1[c|p]  -> /dev/adsp0 (/dev/adsp)   -> minor 12
+/dev/snd/pcmC1D0[c|p]  -> /dev/audio1              -> minor 4+16 = 20
+/dev/snd/pcmC1D0[c|p]  -> /dev/dsp1                -> minor 3+16 = 19
+/dev/snd/pcmC1D1[c|p]  -> /dev/adsp1               -> minor 12+16 = 28
+/dev/snd/pcmC2D0[c|p]  -> /dev/audio2              -> minor 4+32 = 36
+/dev/snd/pcmC2D0[c|p]  -> /dev/dsp2                -> minor 3+32 = 39
+/dev/snd/pcmC2D1[c|p]  -> /dev/adsp2               -> minor 12+32 = 44
+
+The first number from /dev/snd/pcmC{X}D{Y}[c|p] expression means
+soundcard number and second means device number.  The ALSA devices
+have either 'c' or 'p' suffix indicating the direction, capture and
+playback, respectively.
 
-The first number from /dev/snd/pcmC{X}D{Y} expression means soundcard number
-and second means device number.
 Please note that the device mapping above may be varied via the module
 options of snd-pcm-oss module.
 
diff -uNr a/Documentation/sound/alsa/Bt87x.txt b/Documentation/sound/alsa/Bt87x.txt
--- a/Documentation/sound/alsa/Bt87x.txt	1970-01-01 01:00:00.000000000 +0100
+++ b/Documentation/sound/alsa/Bt87x.txt	2005-01-14 22:28:11.464615544 +0100
@@ -0,0 +1,78 @@
+Intro
+=====
+
+You might have noticed that the bt878 grabber cards have actually
+_two_ PCI functions:
+
+$ lspci
+[ ... ]
+00:0a.0 Multimedia video controller: Brooktree Corporation Bt878 (rev 02)
+00:0a.1 Multimedia controller: Brooktree Corporation Bt878 (rev 02)
+[ ... ]
+
+The first does video, it is backward compatible to the bt848.  The second
+does audio.  snd-bt87x is a driver for the second function.  It's a sound
+driver which can be used for recording sound (and _only_ recording, no
+playback).  As most TV cards come with a short cable which can be plugged
+into your sound card's line-in you probably don't need this driver if all
+you want to do is just watching TV...
+
+Some cards do not bother to connect anything to the audio input pins of
+the chip, and some other cards use the audio function to transport MPEG
+video data, so it's quite possible that audio recording may not work
+with your card.
+
+
+Driver Status
+=============
+
+The driver is now stable.  However, it doesn't know about many TV cards,
+and it refuses to load for cards it doesn't know.
+
+If the driver complains ("Unknown TV card found, the audio driver will
+not load"), you can specify the load_all=1 option to force the driver to
+try to use the audio capture function of your card.  If the frequency of
+recorded data is not right, try to specify the digital_rate option with
+other values than the default 32000 (often it's 44100 or 64000).
+
+If you have an unknown card, please mail the ID and board name to
+<alsa-devel@lists.sf.net>, regardless of whether audio capture works or
+not, so that future versions of this driver know about your card.
+
+
+Audio modes
+===========
+
+The chip knows two different modes (digital/analog).  snd-bt87x
+registers two PCM devices, one for each mode.  They cannot be used at
+the same time.
+
+
+Digital audio mode
+==================
+
+The first device (hw:X,0) gives you 16 bit stereo sound.  The sample
+rate depends on the external source which feeds the Bt87x with digital
+sound via I2S interface.
+
+
+Analog audio mode (A/D)
+=======================
+
+The second device (hw:X,1) gives you 8 or 16 bit mono sound.  Supported
+sample rates are between 119466 and 448000 Hz (yes, these numbers are
+that high).  If you've set the CONFIG_SND_BT87X_OVERCLOCK option, the
+maximum sample rate is 1792000 Hz, but audio data becomes unusable
+beyond 896000 Hz on my card.
+
+The chip has three analog inputs.  Consequently you'll get a mixer
+device to control these.
+
+
+Have fun,
+
+  Clemens
+
+
+Written by Clemens Ladisch <clemens@ladisch.de>
+big parts copied from btaudio.txt by Gerd Knorr <kraxel@bytesex.org>
diff -uNr a/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl b/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl
--- a/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl	2004-12-24 22:34:30.000000000 +0100
+++ b/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl	2005-01-14 22:28:11.487612048 +0100
@@ -397,12 +397,12 @@
   #include <sound/core.h>
   #include <sound/initval.h>
 
-  // module parameters (see "Module Parameters")
+  /* module parameters (see "Module Parameters") */
   static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
   static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
   static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
 
-  // definition of the chip-specific record
+  /* definition of the chip-specific record */
   typedef struct snd_mychip mychip_t;
   struct snd_mychip {
           snd_card_t *card;
@@ -410,23 +410,26 @@
           // "PCI Resource Managements"
   };
 
-  // chip-specific destructor
-  // (see "PCI Resource Managements")
+  /* chip-specific destructor
+   * (see "PCI Resource Managements")
+   */
   static int snd_mychip_free(mychip_t *chip)
   {
-          // will be implemented later...
+          .... // will be implemented later...
   }
 
-  // component-destructor
-  // (see "Management of Cards and Components")
+  /* component-destructor
+   * (see "Management of Cards and Components")
+   */
   static int snd_mychip_dev_free(snd_device_t *device)
   {
           mychip_t *chip = device->device_data;
           return snd_mychip_free(chip);
   }
 
-  // chip-specific constructor
-  // (see "Management of Cards and Components")
+  /* chip-specific constructor
+   * (see "Management of Cards and Components")
+   */
   static int __devinit snd_mychip_create(snd_card_t *card,
                                          struct pci_dev *pci,
                                          mychip_t **rchip)
@@ -441,8 +444,9 @@
 
           // check PCI availability here
           // (see "PCI Resource Managements")
+          ....
 
-          // allocate a chip-specific data with zero filled
+          /* allocate a chip-specific data with zero filled */
           chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
           if (chip == NULL)
                   return -ENOMEM;
@@ -451,17 +455,21 @@
 
           // rest of initialization here; will be implemented
           // later, see "PCI Resource Managements"
+          ....
 
           if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
                                     chip, &ops)) < 0) {
                   snd_mychip_free(chip);
                   return err;
           }
+
+          snd_card_set_dev(card, &pci->dev);
+
           *rchip = chip;
           return 0;
   }
 
-  // constructor -- see "Constructor" sub-section
+  /* constructor -- see "Constructor" sub-section */
   static int __devinit snd_mychip_probe(struct pci_dev *pci,
                                const struct pci_device_id *pci_id)
   {
@@ -470,7 +478,7 @@
           mychip_t *chip;
           int err;
 
-          // (1)
+          /* (1) */
           if (dev >= SNDRV_CARDS)
                   return -ENODEV;
           if (!enable[dev]) {
@@ -478,39 +486,39 @@
                   return -ENOENT;
           }
 
-          // (2)
+          /* (2) */
           card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
           if (card == NULL)
                   return -ENOMEM;
 
-          // (3)
+          /* (3) */
           if ((err = snd_mychip_create(card, pci, &chip)) < 0) {
                   snd_card_free(card);
                   return err;
           }
 
-          // (4)
+          /* (4) */
           strcpy(card->driver, "My Chip");
           strcpy(card->shortname, "My Own Chip 123");
           sprintf(card->longname, "%s at 0x%lx irq %i",
                   card->shortname, chip->ioport, chip->irq);
 
-          // (5)
-          // implemented later
+          /* (5) */
+          .... // implemented later
 
-          // (6)
+          /* (6) */
           if ((err = snd_card_register(card)) < 0) {
                   snd_card_free(card);
                   return err;
           }
 
-          // (7)
+          /* (7) */
           pci_set_drvdata(pci, card);
           dev++;
           return 0;
   }
 
-  // destructor -- see "Destructor" sub-section
+  /* destructor -- see "Destructor" sub-section */
   static void __devexit snd_mychip_remove(struct pci_dev *pci)
   {
           snd_card_free(pci_get_drvdata(pci));
@@ -743,7 +751,7 @@
           </programlisting>
         </informalexample>
 
-	where the last twos are necessary only when module options are
+	where the last one is necessary only when module options are
       defined in the source file.  If the codes are split to several
       files, the file without module options don't need them.
       </para>
@@ -1089,20 +1097,22 @@
 
   static int snd_mychip_free(mychip_t *chip)
   {
-          // disable hardware here if any
-          // (not implemented in this document)
+          /* disable hardware here if any */
+          .... // (not implemented in this document)
 
-          // release the irq
+          /* release the irq */
           if (chip->irq >= 0)
                   free_irq(chip->irq, (void *)chip);
-          // release the i/o ports
+          /* release the i/o ports */
           pci_release_regions(chip->pci);
-          // release the data
+          /* disable the PCI entry */
+          pci_disable_device(chip->pci);
+          /* release the data */
           kfree(chip);
           return 0;
   }
 
-  // chip-specific constructor
+  /* chip-specific constructor */
   static int __devinit snd_mychip_create(snd_card_t *card,
                                          struct pci_dev *pci,
                                          mychip_t **rchip)
@@ -1115,27 +1125,32 @@
 
           *rchip = NULL;
 
-          // check PCI availability (28bit DMA)
+          /* initialize the PCI entry */
           if ((err = pci_enable_device(pci)) < 0)
                   return err;
+          /* check PCI availability (28bit DMA) */
           if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
               pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
                   printk(KERN_ERR "error to set 28bit mask DMA\n");
+                  pci_disable_device(pci);
                   return -ENXIO;
           }
 
           chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
-          if (chip == NULL)
+          if (chip == NULL) {
+                  pci_disable_device(pci);
                   return -ENOMEM;
+          }
 
-          // initialize the stuff
+          /* initialize the stuff */
           chip->card = card;
           chip->pci = pci;
           chip->irq = -1;
 
-          // (1) PCI resource allocation
+          /* (1) PCI resource allocation */
           if ((err = pci_request_regions(pci, "My Chip")) < 0) {
                   kfree(chip);
+                  pci_disable_device(pci);
                   return err;
           }
           chip->port = pci_resource_start(pci, 0);
@@ -1148,19 +1163,22 @@
           }
           chip->irq = pci->irq;
 
-          // (2) initialization of the chip hardware
-          //     (not implemented in this document)
+          /* (2) initialization of the chip hardware */
+          .... //   (not implemented in this document)
 
           if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
                                     chip, &ops)) < 0) {
                   snd_mychip_free(chip);
                   return err;
           }
+
+          snd_card_set_dev(card, &pci->dev);
+
           *rchip = chip;
           return 0;
   }        
 
-  // PCI IDs
+  /* PCI IDs */
   static struct pci_device_id snd_mychip_ids[] = {
           { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
             PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
@@ -1169,7 +1187,7 @@
   };
   MODULE_DEVICE_TABLE(pci, snd_mychip_ids);
 
-  // pci_driver definition
+  /* pci_driver definition */
   static struct pci_driver driver = {
           .name = "My Own Chip",
           .id_table = snd_mychip_ids,
@@ -1177,13 +1195,13 @@
           .remove = __devexit_p(snd_mychip_remove),
   };
 
-  // initialization of the module
+  /* initialization of the module */
   static int __init alsa_card_mychip_init(void)
   {
           return pci_module_init(&driver);
   }
 
-  // clean up the module
+  /* clean up the module */
   static void __exit alsa_card_mychip_exit(void)
   {
           pci_unregister_driver(&driver);
@@ -1228,6 +1246,7 @@
   if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
       pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
           printk(KERN_ERR "error to set 28bit mask DMA\n");
+          pci_disable_device(pci);
           return -ENXIO;
   }
   
@@ -1285,6 +1304,7 @@
 <![CDATA[
   if ((err = pci_request_regions(pci, "My Chip")) < 0) { 
           kfree(chip);
+          pci_disable_device(pci);
           return err;
   }
   chip->port = pci_resource_start(pci, 0);
@@ -1434,6 +1454,11 @@
       </para>
 
       <para>
+      Don't forget to call <function>pci_disable_device()</function>
+      before all finished.
+      </para>
+
+      <para>
         And finally, release the chip-specific record.
 
         <informalexample>
@@ -1462,7 +1487,7 @@
       When the chip-data is assigned to the card using
       <function>snd_device_new()</function> with
       <constant>SNDRV_DEV_LOWLELVEL</constant> , its destructor is 
-      called at the last.  that is, it is assured that all other
+      called at the last.  That is, it is assured that all other
       components like PCMs and controls have been already released.
       You don't have to call stopping PCMs, etc. explicitly, but just
       stop the hardware in the low-level.
@@ -1485,7 +1510,7 @@
           </programlisting>
         </informalexample>
 
-        and the allocation would be (assuming its size is 512 bytes):
+        and the allocation would be like below:
 
         <informalexample>
           <programlisting>
@@ -1522,6 +1547,30 @@
 
     </section>
 
+    <section id="pci-resource-device-struct">
+      <title>Registration of Device Struct</title>
+      <para>
+	At some point, typically after calling <function>snd_device_new()</function>,
+	you need to register the <structname>struct device</structname> of the chip
+	you're handling for udev and co.  ALSA provides a macro for compatibility with
+	older kernels.  Simply call like the following:
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  snd_card_set_dev(card, &pci->dev);
+]]>
+          </programlisting>
+        </informalexample>
+	so that it stores the PCI's device pointer to the card.  This will be
+	referred by ALSA core functions later when the devices are registered.
+      </para>
+      <para>
+	In the case of non-PCI, pass the proper device struct pointer of the BUS
+	instead.  (In the case of legacy ISA without PnP, you don't have to do
+	anything.)
+      </para>
+    </section>
+
     <section id="pci-resource-entries">
       <title>PCI Entries</title>
       <para>
@@ -1801,8 +1850,9 @@
           mychip_t *chip = snd_pcm_substream_chip(substream);
           snd_pcm_runtime_t *runtime = substream->runtime;
 
-          // set up the hardware with the current configuration
-          // for example...
+          /* set up the hardware with the current configuration
+           * for example...
+           */
           mychip_set_sample_format(chip, runtime->format);
           mychip_set_sample_rate(chip, runtime->rate);
           mychip_set_channels(chip, runtime->channels);
@@ -1835,7 +1885,7 @@
           mychip_t *chip = snd_pcm_substream_chip(substream);
           unsigned int current_ptr;
 
-          // get the current hardware pointer
+          /* get the current hardware pointer */
           current_ptr = mychip_get_hw_pointer(chip);
           return current_ptr;
   }
@@ -2068,18 +2118,19 @@
   static void mychip_pcm_free(snd_pcm_t *pcm)
   {
           mychip_t *chip = snd_pcm_chip(pcm);
-          // free your own data
+          /* free your own data */
           kfree(chip->my_private_pcm_data);
-          // do what you like else...
+          // do what you like else
+          ....
   }
 
   static int __devinit snd_mychip_new_pcm(mychip_t *chip)
   {
           snd_pcm_t *pcm;
           ....
-          // allocate your own data
+          /* allocate your own data */
           chip->my_private_pcm_data = kmalloc(...);
-          // set the destructor
+          /* set the destructor */
           pcm->private_data = chip;
           pcm->private_free = mychip_pcm_free;
           ....
@@ -2231,7 +2282,7 @@
 <![CDATA[
           snd_pcm_runtime_t *runtime = substream->runtime;
           ...
-          runtime->hw = snd_mychip_playback_hw; // common definition
+          runtime->hw = snd_mychip_playback_hw; /* common definition */
           if (chip->model == VERY_OLD_ONE)
                   runtime->hw.channels_max = 1;
 ]]>
@@ -3030,7 +3081,7 @@
           spin_lock(&chip->lock);
           ....
           if (pcm_irq_invoked(chip)) {
-                  // call updater, unlock before it
+                  /* call updater, unlock before it */
                   spin_unlock(&chip->lock);
                   snd_pcm_period_elapsed(chip->substream);
                   spin_lock(&chip->lock);
@@ -3075,24 +3126,25 @@
           ....
           if (pcm_irq_invoked(chip)) {
                   unsigned int last_ptr, size;
-                  // get the current hardware pointer (in frames)
+                  /* get the current hardware pointer (in frames) */
                   last_ptr = get_hw_ptr(chip);
-                  // calculate the processed frames since the
-                  // last update
+                  /* calculate the processed frames since the
+                   * last update
+                   */
                   if (last_ptr < chip->last_ptr)
                           size = runtime->buffer_size + last_ptr 
                                    - chip->last_ptr; 
                   else
                           size = last_ptr - chip->last_ptr;
-                  // remember the last updated point
+                  /* remember the last updated point */
                   chip->last_ptr = last_ptr;
-                  // accumulate the size
+                  /* accumulate the size */
                   chip->size += size;
-                  // over the period boundary?
+                  /* over the period boundary? */
                   if (chip->size >= runtime->period_size) {
-                          // reset the accumulator
+                          /* reset the accumulator */
                           chip->size %= runtime->period_size;
-                          // call updater
+                          /* call updater */
                           spin_unlock(&chip->lock);
                           snd_pcm_period_elapsed(substream);
                           spin_lock(&chip->lock);
@@ -3216,7 +3268,7 @@
           snd_mask_t *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
           snd_mask_t fmt;
 
-          snd_mask_any(&fmt);    // Init the struct
+          snd_mask_any(&fmt);    /* Init the struct */
           if (c->min < 2) {
                   fmt.bits[0] &= SNDRV_PCM_FMTBIT_S16_LE;
                   return snd_mask_refine(f, &fmt);
@@ -5131,7 +5183,7 @@
         <listitem><para>Call <function>snd_pcm_suspend_all()</function> to suspend the running PCM streams.</para></listitem>
         <listitem><para>Save the register values if necessary.</para></listitem>
         <listitem><para>Stop the hardware if necessary.</para></listitem>
-        <listitem><para>Set the power-state as D3hot by calling <function>snd_power_change_state()</function>.</para></listitem>
+        <listitem><para>Disable the PCI device by calling <function>pci_disable_device()</function>.</para></listitem>
       </orderedlist>
     </para>
 
@@ -5143,16 +5195,16 @@
 <![CDATA[
   static int mychip_suspend(snd_card_t *card, unsigned int state)
   {
-          // (1)
+          /* (1) */
           mychip_t *chip = card->pm_private_data;
-          // (2)
+          /* (2) */
           snd_pcm_suspend_all(chip->pcm);
-          // (3)
+          /* (3) */
           snd_mychip_save_registers(chip);
-          // (4)
+          /* (4) */
           snd_mychip_stop_hardware(chip);
-          // (5)
-          snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+          /* (5) */
+          pci_disable_device(chip->pci);
           return 0;
   }
 ]]>
@@ -5172,8 +5224,6 @@
     <listitem><para>Resume the mixer, e.g. calling
     <function>snd_ac97_resume()</function>.</para></listitem>
     <listitem><para>Restart the hardware (if any).</para></listitem>
-    <listitem><para>Set the power-state as D0 by calling
-    <function>snd_power_change_state()</function>.</para></listitem>
     </orderedlist>
     </para>
 
@@ -5185,20 +5235,18 @@
 <![CDATA[
   static void mychip_resume(mychip_t *chip)
   {
-          // (1)
+          /* (1) */
           mychip_t *chip = card->pm_private_data;
-          // (2)
+          /* (2) */
           pci_enable_device(chip->pci);
-          // (3)
+          /* (3) */
           snd_mychip_reinit_chip(chip);
-          // (4)
+          /* (4) */
           snd_mychip_restore_registers(chip);
-          // (5)
+          /* (5) */
           snd_ac97_resume(chip->ac97);
-          // (6)
+          /* (6) */
           snd_mychip_restart_chip(chip);
-          // (7)
-          snd_power_change_state(card, SNDRV_CTL_POWER_D0);
           return 0;
   }
 ]]>
@@ -5314,19 +5362,15 @@
 <![CDATA[
   #define CARD_NAME "My Chip"
 
-  static int boot_devs;
-  module_param_array(index, int, boot_devs, 0444);
+  module_param_array(index, int, NULL, 0444);
   MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
-  module_param_array(id, charp, boot_devs, 0444);
+  module_param_array(id, charp, NULL, 0444);
   MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
-  module_param_array(enable, bool, boot_devs, 0444);
+  module_param_array(enable, bool, NULL, 0444);
   MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
 ]]>
         </programlisting>
       </informalexample>
-
-    Here boot_devs is passed but simply ignored since we don't care
-    the number of parsed parameters.
     </para>
 
     <para>
@@ -5423,7 +5467,10 @@
           depends on SND
           select SND_PCM
           help
-            Say 'Y' or 'M' to include support for Foobar XYZ soundcard.
+            Say Y here to include support for Foobar XYZ soundcard.
+
+            To compile this driver as a module, choose M here: the module
+            will be called snd-xyz.
 ]]>
         </programlisting>
       </informalexample>
diff -uNr a/Documentation/sound/alsa/MIXART.txt b/Documentation/sound/alsa/MIXART.txt
--- a/Documentation/sound/alsa/MIXART.txt	2004-12-24 22:35:01.000000000 +0100
+++ b/Documentation/sound/alsa/MIXART.txt	2005-01-14 22:28:11.489611744 +0100
@@ -72,6 +72,10 @@
 FIRMWARE
 ========
 
+[As of 2.6.11, the firmware can be loaded automatically with hotplug
+ when CONFIG_FW_LOADER is set.  The mixartloader is necessary only
+ for older versions or when you build the driver into kernel.]
+ 
 For loading the firmware automatically after the module is loaded, use
 the post-install command.  For example, add the following entry to
 /etc/modprobe.conf for miXart driver:
diff -uNr a/Documentation/sound/alsa/OSS-Emulation.txt b/Documentation/sound/alsa/OSS-Emulation.txt
--- a/Documentation/sound/alsa/OSS-Emulation.txt	2004-12-24 22:34:58.000000000 +0100
+++ b/Documentation/sound/alsa/OSS-Emulation.txt	2005-01-14 22:28:11.492611288 +0100
@@ -164,16 +164,15 @@
 
 The block and non-block options are used to change the behavior of
 opening the device file.
-As default, ALSA behaves as defined in POSIX, i.e. blocks the file
-when it's busy until the device becomes free (unless O_NONBLOCK is
-specified).  Some applications assume the non-block open behavior,
-which are actually implemented in some real OSS drivers.
+
+As default, ALSA behaves as original OSS drivers, i.e. does not block
+the file when it's busy. The -EBUSY error is returned in this case.
 
 This blocking behavior can be changed globally via nonblock_open
-module option of snd-pcm-oss.  For using the non-block mode as default
+module option of snd-pcm-oss.  For using the blocking mode as default
 for OSS devices, define like the following:
 
-	options snd-pcm-oss nonblock_open=1
+	options snd-pcm-oss nonblock_open=0
 
 The partial-frag and no-silence commands have been added recently.
 Both commands are for optimization use only.  The former command
diff -uNr a/include/asm-s390/setup.h.orig b/include/asm-s390/setup.h.orig
--- a/include/asm-s390/setup.h.orig	2004-12-24 22:35:28.000000000 +0100
+++ b/include/asm-s390/setup.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-/*
- *  include/asm-s390/setup.h
- *
- *  S390 version
- *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- */
-
-#ifndef _ASM_S390_SETUP_H
-#define _ASM_S390_SETUP_H
-
-#define PARMAREA		0x10400
-#define COMMAND_LINE_SIZE 	896
-#define RAMDISK_ORIGIN		0x800000
-#define RAMDISK_SIZE		0x800000
-#define MEMORY_CHUNKS		16	/* max 0x7fff */
-
-#ifndef __ASSEMBLY__
-
-#ifndef __s390x__
-#define IPL_DEVICE        (*(unsigned long *)  (0x10404))
-#define INITRD_START      (*(unsigned long *)  (0x1040C))
-#define INITRD_SIZE       (*(unsigned long *)  (0x10414))
-#else /* __s390x__ */
-#define IPL_DEVICE        (*(unsigned long *)  (0x10400))
-#define INITRD_START      (*(unsigned long *)  (0x10408))
-#define INITRD_SIZE       (*(unsigned long *)  (0x10410))
-#endif /* __s390x__ */
-#define COMMAND_LINE      ((char *)            (0x10480))
-
-/*
- * Machine features detected in head.S
- */
-extern unsigned long machine_flags;
-
-#define MACHINE_IS_VM		(machine_flags & 1)
-#define MACHINE_IS_P390		(machine_flags & 4)
-#define MACHINE_HAS_MVPG	(machine_flags & 16)
-#define MACHINE_HAS_DIAG44	(machine_flags & 32)
-#define MACHINE_HAS_IDTE	(machine_flags & 128)
-
-#ifndef __s390x__
-#define MACHINE_HAS_IEEE	(machine_flags & 2)
-#define MACHINE_HAS_CSP		(machine_flags & 8)
-#else /* __s390x__ */
-#define MACHINE_HAS_IEEE	(1)
-#define MACHINE_HAS_CSP		(1)
-#endif /* __s390x__ */
-
-
-#define MACHINE_HAS_SCLP	(!MACHINE_IS_P390)
-
-/*
- * Console mode. Override with conmode=
- */
-extern unsigned int console_mode;
-extern unsigned int console_devno;
-extern unsigned int console_irq;
-
-#define CONSOLE_IS_UNDEFINED	(console_mode == 0)
-#define CONSOLE_IS_SCLP		(console_mode == 1)
-#define CONSOLE_IS_3215		(console_mode == 2)
-#define CONSOLE_IS_3270		(console_mode == 3)
-#define SET_CONSOLE_SCLP	do { console_mode = 1; } while (0)
-#define SET_CONSOLE_3215	do { console_mode = 2; } while (0)
-#define SET_CONSOLE_3270	do { console_mode = 3; } while (0)
-
-#else 
-
-#ifndef __s390x__
-#define IPL_DEVICE        0x10404
-#define INITRD_START      0x1040C
-#define INITRD_SIZE       0x10414
-#else /* __s390x__ */
-#define IPL_DEVICE        0x10400
-#define INITRD_START      0x10408
-#define INITRD_SIZE       0x10410
-#endif /* __s390x__ */
-#define COMMAND_LINE      0x10480
-
-#endif
-
-#endif
diff -uNr a/include/linux/kernel.h.orig b/include/linux/kernel.h.orig
--- a/include/linux/kernel.h.orig	2004-12-24 22:33:48.000000000 +0100
+++ b/include/linux/kernel.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,283 +0,0 @@
-#ifndef _LINUX_KERNEL_H
-#define _LINUX_KERNEL_H
-
-/*
- * 'kernel.h' contains some often-used function prototypes etc
- */
-
-#ifdef __KERNEL__
-
-#include <stdarg.h>
-#include <linux/linkage.h>
-#include <linux/stddef.h>
-#include <linux/types.h>
-#include <linux/compiler.h>
-#include <linux/bitops.h>
-#include <asm/byteorder.h>
-#include <asm/bug.h>
-
-#define INT_MAX		((int)(~0U>>1))
-#define INT_MIN		(-INT_MAX - 1)
-#define UINT_MAX	(~0U)
-#define LONG_MAX	((long)(~0UL>>1))
-#define LONG_MIN	(-LONG_MAX - 1)
-#define ULONG_MAX	(~0UL)
-
-#define STACK_MAGIC	0xdeadbeef
-
-#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
-#define ALIGN(x,a) (((x)+(a)-1)&~((a)-1))
-
-#define	KERN_EMERG	"<0>"	/* system is unusable			*/
-#define	KERN_ALERT	"<1>"	/* action must be taken immediately	*/
-#define	KERN_CRIT	"<2>"	/* critical conditions			*/
-#define	KERN_ERR	"<3>"	/* error conditions			*/
-#define	KERN_WARNING	"<4>"	/* warning conditions			*/
-#define	KERN_NOTICE	"<5>"	/* normal but significant condition	*/
-#define	KERN_INFO	"<6>"	/* informational			*/
-#define	KERN_DEBUG	"<7>"	/* debug-level messages			*/
-
-extern int console_printk[];
-
-#define console_loglevel (console_printk[0])
-#define default_message_loglevel (console_printk[1])
-#define minimum_console_loglevel (console_printk[2])
-#define default_console_loglevel (console_printk[3])
-
-struct completion;
-
-#ifdef CONFIG_DEBUG_SPINLOCK_SLEEP
-void __might_sleep(char *file, int line);
-#define might_sleep() __might_sleep(__FILE__, __LINE__)
-#define might_sleep_if(cond) do { if (unlikely(cond)) might_sleep(); } while (0)
-#else
-#define might_sleep() do {} while(0)
-#define might_sleep_if(cond) do {} while (0)
-#endif
-
-#define abs(x) ({				\
-		int __x = (x);			\
-		(__x < 0) ? -__x : __x;		\
-	})
-
-#define labs(x) ({				\
-		long __x = (x);			\
-		(__x < 0) ? -__x : __x;		\
-	})
-
-extern struct notifier_block *panic_notifier_list;
-extern long (*panic_blink)(long time);
-NORET_TYPE void panic(const char * fmt, ...)
-	__attribute__ ((NORET_AND format (printf, 1, 2)));
-fastcall NORET_TYPE void do_exit(long error_code)
-	ATTRIB_NORET;
-NORET_TYPE void complete_and_exit(struct completion *, long)
-	ATTRIB_NORET;
-extern unsigned long simple_strtoul(const char *,char **,unsigned int);
-extern long simple_strtol(const char *,char **,unsigned int);
-extern unsigned long long simple_strtoull(const char *,char **,unsigned int);
-extern long long simple_strtoll(const char *,char **,unsigned int);
-extern int sprintf(char * buf, const char * fmt, ...)
-	__attribute__ ((format (printf, 2, 3)));
-extern int vsprintf(char *buf, const char *, va_list);
-extern int snprintf(char * buf, size_t size, const char * fmt, ...)
-	__attribute__ ((format (printf, 3, 4)));
-extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
-extern int scnprintf(char * buf, size_t size, const char * fmt, ...)
-	__attribute__ ((format (printf, 3, 4)));
-extern int vscnprintf(char *buf, size_t size, const char *fmt, va_list args);
-
-extern int sscanf(const char *, const char *, ...)
-	__attribute__ ((format (scanf,2,3)));
-extern int vsscanf(const char *, const char *, va_list);
-
-extern int get_option(char **str, int *pint);
-extern char *get_options(const char *str, int nints, int *ints);
-extern unsigned long long memparse(char *ptr, char **retptr);
-
-extern int __kernel_text_address(unsigned long addr);
-extern int kernel_text_address(unsigned long addr);
-extern int session_of_pgrp(int pgrp);
-
-asmlinkage int vprintk(const char *fmt, va_list args);
-asmlinkage int printk(const char * fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-
-unsigned long int_sqrt(unsigned long);
-
-static inline int __attribute_pure__ long_log2(unsigned long x)
-{
-	int r = 0;
-	for (x >>= 1; x > 0; x >>= 1)
-		r++;
-	return r;
-}
-
-static inline unsigned long __attribute_const__ roundup_pow_of_two(unsigned long x)
-{
-	return (1UL << fls(x - 1));
-}
-
-extern int printk_ratelimit(void);
-extern int __printk_ratelimit(int ratelimit_jiffies, int ratelimit_burst);
-
-static inline void console_silent(void)
-{
-	console_loglevel = 0;
-}
-
-static inline void console_verbose(void)
-{
-	if (console_loglevel)
-		console_loglevel = 15;
-}
-
-extern void bust_spinlocks(int yes);
-extern int oops_in_progress;		/* If set, an oops, panic(), BUG() or die() is in progress */
-extern int panic_on_oops;
-extern int tainted;
-extern const char *print_tainted(void);
-extern void add_taint(unsigned);
-
-/* Values used for system_state */
-extern enum system_states {
-	SYSTEM_BOOTING,
-	SYSTEM_RUNNING,
-	SYSTEM_HALT,
-	SYSTEM_POWER_OFF,
-	SYSTEM_RESTART,
-} system_state;
-
-#define TAINT_PROPRIETARY_MODULE	(1<<0)
-#define TAINT_FORCED_MODULE		(1<<1)
-#define TAINT_UNSAFE_SMP		(1<<2)
-#define TAINT_FORCED_RMMOD		(1<<3)
-#define TAINT_MACHINE_CHECK		(1<<4)
-#define TAINT_BAD_PAGE			(1<<5)
-
-extern void dump_stack(void);
-
-#ifdef DEBUG
-#define pr_debug(fmt,arg...) \
-	printk(KERN_DEBUG fmt,##arg)
-#else
-#define pr_debug(fmt,arg...) \
-	do { } while (0)
-#endif
-
-#define pr_info(fmt,arg...) \
-	printk(KERN_INFO fmt,##arg)
-
-/*
- *      Display an IP address in readable format.
- */
-
-#define NIPQUAD(addr) \
-	((unsigned char *)&addr)[0], \
-	((unsigned char *)&addr)[1], \
-	((unsigned char *)&addr)[2], \
-	((unsigned char *)&addr)[3]
-
-#define NIP6(addr) \
-	ntohs((addr).s6_addr16[0]), \
-	ntohs((addr).s6_addr16[1]), \
-	ntohs((addr).s6_addr16[2]), \
-	ntohs((addr).s6_addr16[3]), \
-	ntohs((addr).s6_addr16[4]), \
-	ntohs((addr).s6_addr16[5]), \
-	ntohs((addr).s6_addr16[6]), \
-	ntohs((addr).s6_addr16[7])
-
-#if defined(__LITTLE_ENDIAN)
-#define HIPQUAD(addr) \
-	((unsigned char *)&addr)[3], \
-	((unsigned char *)&addr)[2], \
-	((unsigned char *)&addr)[1], \
-	((unsigned char *)&addr)[0]
-#elif defined(__BIG_ENDIAN)
-#define HIPQUAD	NIPQUAD
-#else
-#error "Please fix asm/byteorder.h"
-#endif /* __LITTLE_ENDIAN */
-
-/*
- * min()/max() macros that also do
- * strict type-checking.. See the
- * "unnecessary" pointer comparison.
- */
-#define min(x,y) ({ \
-	typeof(x) _x = (x);	\
-	typeof(y) _y = (y);	\
-	(void) (&_x == &_y);		\
-	_x < _y ? _x : _y; })
-
-#define max(x,y) ({ \
-	typeof(x) _x = (x);	\
-	typeof(y) _y = (y);	\
-	(void) (&_x == &_y);		\
-	_x > _y ? _x : _y; })
-
-/*
- * ..and if you can't take the strict
- * types, you can specify one yourself.
- *
- * Or not use min/max at all, of course.
- */
-#define min_t(type,x,y) \
-	({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
-#define max_t(type,x,y) \
-	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
-
-
-/**
- * container_of - cast a member of a structure out to the containing structure
- *
- * @ptr:	the pointer to the member.
- * @type:	the type of the container struct this is embedded in.
- * @member:	the name of the member within the struct.
- *
- */
-#define container_of(ptr, type, member) ({			\
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-        (type *)( (char *)__mptr - offsetof(type,member) );})
-
-/*
- * Check at compile time that something is of a particular type.
- * Always evaluates to 1 so you may use it easily in comparisons.
- */
-#define typecheck(type,x) \
-({	type __dummy; \
-	typeof(x) __dummy2; \
-	(void)(&__dummy == &__dummy2); \
-	1; \
-})
-
-#endif /* __KERNEL__ */
-
-#define SI_LOAD_SHIFT	16
-struct sysinfo {
-	long uptime;			/* Seconds since boot */
-	unsigned long loads[3];		/* 1, 5, and 15 minute load averages */
-	unsigned long totalram;		/* Total usable main memory size */
-	unsigned long freeram;		/* Available memory size */
-	unsigned long sharedram;	/* Amount of shared memory */
-	unsigned long bufferram;	/* Memory used by buffers */
-	unsigned long totalswap;	/* Total swap space size */
-	unsigned long freeswap;		/* swap space still available */
-	unsigned short procs;		/* Number of current processes */
-	unsigned short pad;		/* explicit padding for m68k */
-	unsigned long totalhigh;	/* Total high memory size */
-	unsigned long freehigh;		/* Available high memory size */
-	unsigned int mem_unit;		/* Memory unit size in bytes */
-	char _f[20-2*sizeof(long)-sizeof(int)];	/* Padding: libc5 uses this.. */
-};
-
-extern void BUILD_BUG(void);
-#define BUILD_BUG_ON(condition) do { if (condition) BUILD_BUG(); } while(0)
-
-/* Trap pasters of __FUNCTION__ at compile-time */
-#if __GNUC__ > 2 || __GNUC_MINOR__ >= 95
-#define __FUNCTION__ (__func__)
-#endif
-
-#endif
diff -uNr a/include/linux/netfilter_ipv4/ip_conntrack.h.orig b/include/linux/netfilter_ipv4/ip_conntrack.h.orig
--- a/include/linux/netfilter_ipv4/ip_conntrack.h.orig	2005-01-14 22:24:29.731324128 +0100
+++ b/include/linux/netfilter_ipv4/ip_conntrack.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,347 +0,0 @@
-#ifndef _IP_CONNTRACK_H
-#define _IP_CONNTRACK_H
-/* Connection state tracking for netfilter.  This is separated from,
-   but required by, the NAT layer; it can also be used by an iptables
-   extension. */
-
-#include <linux/config.h>
-#include <linux/netfilter_ipv4/ip_conntrack_tuple.h>
-#include <linux/bitops.h>
-#include <linux/compiler.h>
-#include <asm/atomic.h>
-
-enum ip_conntrack_info
-{
-	/* Part of an established connection (either direction). */
-	IP_CT_ESTABLISHED,
-
-	/* Like NEW, but related to an existing connection, or ICMP error
-	   (in either direction). */
-	IP_CT_RELATED,
-
-	/* Started a new connection to track (only
-           IP_CT_DIR_ORIGINAL); may be a retransmission. */
-	IP_CT_NEW,
-
-	/* >= this indicates reply direction */
-	IP_CT_IS_REPLY,
-
-	/* Number of distinct IP_CT types (no NEW in reply dirn). */
-	IP_CT_NUMBER = IP_CT_IS_REPLY * 2 - 1
-};
-
-/* Bitset representing status of connection. */
-enum ip_conntrack_status {
-	/* It's an expected connection: bit 0 set.  This bit never changed */
-	IPS_EXPECTED_BIT = 0,
-	IPS_EXPECTED = (1 << IPS_EXPECTED_BIT),
-
-	/* We've seen packets both ways: bit 1 set.  Can be set, not unset. */
-	IPS_SEEN_REPLY_BIT = 1,
-	IPS_SEEN_REPLY = (1 << IPS_SEEN_REPLY_BIT),
-
-	/* Conntrack should never be early-expired. */
-	IPS_ASSURED_BIT = 2,
-	IPS_ASSURED = (1 << IPS_ASSURED_BIT),
-
-	/* Connection is confirmed: originating packet has left box */
-	IPS_CONFIRMED_BIT = 3,
-	IPS_CONFIRMED = (1 << IPS_CONFIRMED_BIT),
-};
-
-#include <linux/netfilter_ipv4/ip_conntrack_tcp.h>
-#include <linux/netfilter_ipv4/ip_conntrack_icmp.h>
-#include <linux/netfilter_ipv4/ip_conntrack_proto_gre.h>
-#include <linux/netfilter_ipv4/ip_conntrack_sctp.h>
-
-/* per conntrack: protocol private data */
-union ip_conntrack_proto {
-	/* insert conntrack proto private data here */
-	struct ip_ct_gre gre;
-	struct ip_ct_sctp sctp;
-	struct ip_ct_tcp tcp;
-	struct ip_ct_icmp icmp;
-};
-
-union ip_conntrack_expect_proto {
-	/* insert expect proto private data here */
-	struct ip_ct_gre_expect gre;
-};
-
-/* Add protocol helper include file here */
-#include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
-#include <linux/netfilter_ipv4/ip_conntrack_amanda.h>
-#include <linux/netfilter_ipv4/ip_conntrack_ftp.h>
-#include <linux/netfilter_ipv4/ip_conntrack_irc.h>
-
-/* per expectation: application helper private data */
-union ip_conntrack_expect_help {
-	/* insert conntrack helper private data (expect) here */
-	struct ip_ct_pptp_expect exp_pptp_info;
-	struct ip_ct_amanda_expect exp_amanda_info;
-	struct ip_ct_ftp_expect exp_ftp_info;
-	struct ip_ct_irc_expect exp_irc_info;
-
-#ifdef CONFIG_IP_NF_NAT_NEEDED
-	union {
-		/* insert nat helper private data (expect) here */
-	} nat;
-#endif
-};
-
-/* per conntrack: application helper private data */
-union ip_conntrack_help {
-	/* insert conntrack helper private data (master) here */
-	struct ip_ct_pptp_master ct_pptp_info;
-	struct ip_ct_ftp_master ct_ftp_info;
-	struct ip_ct_irc_master ct_irc_info;
-};
-
-#ifdef CONFIG_IP_NF_NAT_NEEDED
-#include <linux/netfilter_ipv4/ip_nat.h>
-#include <linux/netfilter_ipv4/ip_nat_pptp.h>
-
-/* per conntrack: nat application helper private data */
-union ip_conntrack_nat_help {
-	/* insert nat helper private data here */
-	struct ip_nat_pptp nat_pptp_info;
-};
-#endif
-
-#ifdef CONFIG_IP_NF_CONNTRACK_RATE
-#include <linux/netfilter_ipv4/ip_conntrack_rate.h>
-#endif
-
-#ifdef __KERNEL__
-
-#include <linux/types.h>
-#include <linux/skbuff.h>
-
-#ifdef CONFIG_NETFILTER_DEBUG
-#define IP_NF_ASSERT(x)							\
-do {									\
-	if (!(x))							\
-		/* Wooah!  I'm tripping my conntrack in a frenzy of	\
-		   netplay... */					\
-		printk("NF_IP_ASSERT: %s:%i(%s)\n",			\
-		       __FILE__, __LINE__, __FUNCTION__);		\
-} while(0)
-#else
-#define IP_NF_ASSERT(x)
-#endif
-
-struct ip_conntrack_expect
-{
-	/* Internal linked list (global expectation list) */
-	struct list_head list;
-
-	/* reference count */
-	atomic_t use;
-
-	/* expectation list for this master */
-	struct list_head expected_list;
-
-	/* The conntrack of the master connection */
-	struct ip_conntrack *expectant;
-
-	/* The conntrack of the sibling connection, set after
-	 * expectation arrived */
-	struct ip_conntrack *sibling;
-
-	/* Tuple saved for conntrack */
-	struct ip_conntrack_tuple ct_tuple;
-
-	/* Timer function; deletes the expectation. */
-	struct timer_list timeout;
-
-	/* Data filled out by the conntrack helpers follow: */
-
-	/* We expect this tuple, with the following mask */
-	struct ip_conntrack_tuple tuple, mask;
-
-	/* Function to call after setup and insertion */
-	int (*expectfn)(struct ip_conntrack *new);
-
-	/* At which sequence number did this expectation occur */
-	u_int32_t seq;
-  
-	union ip_conntrack_expect_proto proto;
-
-	union ip_conntrack_expect_help help;
-};
-
-struct ip_conntrack_counter
-{
-	u_int64_t packets;
-	u_int64_t bytes;
-};
-
-struct ip_conntrack_helper;
-
-struct ip_conntrack
-{
-	/* Usage count in here is 1 for hash table/destruct timer, 1 per skb,
-           plus 1 for any connection(s) we are `master' for */
-	struct nf_conntrack ct_general;
-
-	/* Have we seen traffic both ways yet? (bitset) */
-	unsigned long status;
-
-	/* Timer function; drops refcnt when it goes off. */
-	struct timer_list timeout;
-
-#ifdef CONFIG_IP_NF_CT_ACCT
-	/* Accounting Information (same cache line as other written members) */
-	struct ip_conntrack_counter counters[IP_CT_DIR_MAX];
-#endif
-
-	/* If we're expecting another related connection, this will be
-           in expected linked list */
-	struct list_head sibling_list;
-	
-	/* Current number of expected connections */
-	unsigned int expecting;
-
-	/* If we were expected by an expectation, this will be it */
-	struct ip_conntrack_expect *master;
-
-	/* Helper, if any. */
-	struct ip_conntrack_helper *helper;
-
-	/* Storage reserved for other modules: */
-	union ip_conntrack_proto proto;
-
-	union ip_conntrack_help help;
-
-#ifdef CONFIG_IP_NF_NAT_NEEDED
-	struct {
-		struct ip_nat_info info;
-		union ip_conntrack_nat_help help;
-#if defined(CONFIG_IP_NF_TARGET_MASQUERADE) || \
-	defined(CONFIG_IP_NF_TARGET_MASQUERADE_MODULE)
-		int masq_index;
-#endif
-	} nat;
-#endif /* CONFIG_IP_NF_NAT_NEEDED */
-
-#if defined(CONFIG_IP_NF_CONNTRACK_MARK)
-	unsigned long mark;
-#endif
-
-#ifdef CONFIG_IP_NF_CONNTRACK_RATE
-	struct ip_conntrack_rate rate;
-#endif
-
-	/* Traversed often, so hopefully in different cacheline to top */
-	/* These are my tuples; original and reply */
-	struct ip_conntrack_tuple_hash tuplehash[IP_CT_DIR_MAX];
-};
-
-/* get master conntrack via master expectation */
-#define master_ct(conntr) (conntr->master ? conntr->master->expectant : NULL)
-
-/* Alter reply tuple (maybe alter helper).  If it's already taken,
-   return 0 and don't do alteration. */
-extern int
-ip_conntrack_alter_reply(struct ip_conntrack *conntrack,
-			 const struct ip_conntrack_tuple *newreply);
-
-/* Is this tuple taken? (ignoring any belonging to the given
-   conntrack). */
-extern int
-ip_conntrack_tuple_taken(const struct ip_conntrack_tuple *tuple,
-			 const struct ip_conntrack *ignored_conntrack);
-
-/* Return conntrack_info and tuple hash for given skb. */
-static inline struct ip_conntrack *
-ip_conntrack_get(const struct sk_buff *skb, enum ip_conntrack_info *ctinfo)
-{
-	*ctinfo = skb->nfctinfo;
-	return (struct ip_conntrack *)skb->nfct;
-}
-
-/* decrement reference count on a conntrack */
-extern inline void ip_conntrack_put(struct ip_conntrack *ct);
-
-/* find unconfirmed expectation based on tuple */
-struct ip_conntrack_expect *
-ip_conntrack_expect_find_get(const struct ip_conntrack_tuple *tuple);
-
-/* decrement reference count on an expectation */
-void ip_conntrack_expect_put(struct ip_conntrack_expect *exp);
-
-/* call to create an explicit dependency on ip_conntrack. */
-extern void need_ip_conntrack(void);
-
-extern int invert_tuplepr(struct ip_conntrack_tuple *inverse,
-			  const struct ip_conntrack_tuple *orig);
-
-/* Refresh conntrack for this many jiffies */
-extern void ip_ct_refresh_acct(struct ip_conntrack *ct,
-			       enum ip_conntrack_info ctinfo,
-			       const struct sk_buff *skb,
-			       unsigned long extra_jiffies);
-
-/* These are for NAT.  Icky. */
-/* Update TCP window tracking data when NAT mangles the packet */
-extern int ip_conntrack_tcp_update(struct sk_buff *skb,
-				   struct ip_conntrack *conntrack,
-				   int dir);
-
-/* Call me when a conntrack is destroyed. */
-extern void (*ip_conntrack_destroyed)(struct ip_conntrack *conntrack);
-
-/* Fake conntrack entry for untracked connections */
-extern struct ip_conntrack ip_conntrack_untracked;
-
-extern int ip_ct_no_defrag;
-/* Returns new sk_buff, or NULL */
-struct sk_buff *
-ip_ct_gather_frags(struct sk_buff *skb);
-
-/* Delete all conntracks which match. */
-extern void
-ip_ct_selective_cleanup(int (*kill)(const struct ip_conntrack *i, void *data),
-			void *data);
-
-/* It's confirmed if it is, or has been in the hash table. */
-static inline int is_confirmed(struct ip_conntrack *ct)
-{
-	return test_bit(IPS_CONFIRMED_BIT, &ct->status);
-}
-
-extern unsigned int ip_conntrack_htable_size;
- 
-struct ip_conntrack_stat
-{
-	unsigned int searched;
-	unsigned int found;
-	unsigned int new;
-	unsigned int invalid;
-	unsigned int ignore;
-	unsigned int delete;
-	unsigned int delete_list;
-	unsigned int insert;
-	unsigned int insert_failed;
-	unsigned int drop;
-	unsigned int early_drop;
-	unsigned int error;
-	unsigned int expect_new;
-	unsigned int expect_create;
-	unsigned int expect_delete;
-};
-
-#define CONNTRACK_STAT_INC(count) (__get_cpu_var(ip_conntrack_stat).count++)
-
-/* eg. PROVIDES_CONNTRACK(ftp); */
-#define PROVIDES_CONNTRACK(name)                        \
-        int needs_ip_conntrack_##name;                  \
-        EXPORT_SYMBOL(needs_ip_conntrack_##name)
-
-/*. eg. NEEDS_CONNTRACK(ftp); */
-#define NEEDS_CONNTRACK(name)                                           \
-        extern int needs_ip_conntrack_##name;                           \
-        static int *need_ip_conntrack_##name __attribute_used__ = &needs_ip_conntrack_##name
-
-#endif /* __KERNEL__ */
-#endif /* _IP_CONNTRACK_H */
diff -uNr a/include/linux/pkt_sched.h.orig b/include/linux/pkt_sched.h.orig
--- a/include/linux/pkt_sched.h.orig	2005-01-14 22:24:29.970287800 +0100
+++ b/include/linux/pkt_sched.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,464 +0,0 @@
-#ifndef __LINUX_PKT_SCHED_H
-#define __LINUX_PKT_SCHED_H
-
-/* Logical priority bands not depending on specific packet scheduler.
-   Every scheduler will map them to real traffic classes, if it has
-   no more precise mechanism to classify packets.
-
-   These numbers have no special meaning, though their coincidence
-   with obsolete IPv6 values is not occasional :-). New IPv6 drafts
-   preferred full anarchy inspired by diffserv group.
-
-   Note: TC_PRIO_BESTEFFORT does not mean that it is the most unhappy
-   class, actually, as rule it will be handled with more care than
-   filler or even bulk.
- */
-
-#define TC_PRIO_BESTEFFORT		0
-#define TC_PRIO_FILLER			1
-#define TC_PRIO_BULK			2
-#define TC_PRIO_INTERACTIVE_BULK	4
-#define TC_PRIO_INTERACTIVE		6
-#define TC_PRIO_CONTROL			7
-
-#define TC_PRIO_MAX			15
-
-/* Generic queue statistics, available for all the elements.
-   Particular schedulers may have also their private records.
- */
-
-struct tc_stats
-{
-	__u64	bytes;			/* NUmber of enqueues bytes */
-	__u32	packets;		/* Number of enqueued packets	*/
-	__u32	drops;			/* Packets dropped because of lack of resources */
-	__u32	overlimits;		/* Number of throttle events when this
-					 * flow goes out of allocated bandwidth */
-	__u32	bps;			/* Current flow byte rate */
-	__u32	pps;			/* Current flow packet rate */
-	__u32	qlen;
-	__u32	backlog;
-};
-
-struct tc_estimator
-{
-	signed char	interval;
-	unsigned char	ewma_log;
-};
-
-/* "Handles"
-   ---------
-
-    All the traffic control objects have 32bit identifiers, or "handles".
-
-    They can be considered as opaque numbers from user API viewpoint,
-    but actually they always consist of two fields: major and
-    minor numbers, which are interpreted by kernel specially,
-    that may be used by applications, though not recommended.
-
-    F.e. qdisc handles always have minor number equal to zero,
-    classes (or flows) have major equal to parent qdisc major, and
-    minor uniquely identifying class inside qdisc.
-
-    Macros to manipulate handles:
- */
-
-#define TC_H_MAJ_MASK (0xFFFF0000U)
-#define TC_H_MIN_MASK (0x0000FFFFU)
-#define TC_H_MAJ(h) ((h)&TC_H_MAJ_MASK)
-#define TC_H_MIN(h) ((h)&TC_H_MIN_MASK)
-#define TC_H_MAKE(maj,min) (((maj)&TC_H_MAJ_MASK)|((min)&TC_H_MIN_MASK))
-
-#define TC_H_UNSPEC	(0U)
-#define TC_H_ROOT	(0xFFFFFFFFU)
-#define TC_H_INGRESS    (0xFFFFFFF1U)
-
-struct tc_ratespec
-{
-	unsigned char	cell_log;
-	unsigned char	__reserved;
-	unsigned short	feature;
-	short		addend;
-	unsigned short	mpu;
-	__u32		rate;
-};
-
-/* FIFO section */
-
-struct tc_fifo_qopt
-{
-	__u32	limit;	/* Queue length: bytes for bfifo, packets for pfifo */
-};
-
-/* PRIO section */
-
-#define TCQ_PRIO_BANDS	16
-
-struct tc_prio_qopt
-{
-	int	bands;			/* Number of bands */
-	__u8	priomap[TC_PRIO_MAX+1];	/* Map: logical priority -> PRIO band */
-};
-
-/* TBF section */
-
-struct tc_tbf_qopt
-{
-	struct tc_ratespec rate;
-	struct tc_ratespec peakrate;
-	__u32		limit;
-	__u32		buffer;
-	__u32		mtu;
-};
-
-enum
-{
-	TCA_TBF_UNSPEC,
-	TCA_TBF_PARMS,
-	TCA_TBF_RTAB,
-	TCA_TBF_PTAB,
-	__TCA_TBF_MAX,
-};
-
-#define TCA_TBF_MAX (__TCA_TBF_MAX - 1)
-
-
-/* TEQL section */
-
-/* TEQL does not require any parameters */
-
-/* SFQ section */
-
-enum
-{
-	TCA_SFQ_HASH_CLASSIC,
-	TCA_SFQ_HASH_DST,
-	TCA_SFQ_HASH_SRC,
-};
-
-struct tc_sfq_qopt
-{
-	unsigned	quantum;	/* Bytes per round allocated to flow */
-	int		perturb_period;	/* Period of hash perturbation */
-	__u32		limit;		/* Maximal packets in queue */
-	unsigned	divisor;	/* Hash divisor  */
-	unsigned	flows;		/* Maximal number of flows  */
-	unsigned	hash_kind;	/* Hash function to use for flow identification */
-};
-
-/*
- *  NOTE: limit, divisor and flows are hardwired to code at the moment.
- *
- *	limit=flows=128, divisor=1024;
- *
- *	The only reason for this is efficiency, it is possible
- *	to change these parameters in compile time.
- *	
- *	If you need to play with this values use esfq.
- */
-
-/* RED section */
-
-enum
-{
-	TCA_RED_UNSPEC,
-	TCA_RED_PARMS,
-	TCA_RED_STAB,
-	__TCA_RED_MAX,
-};
-
-#define TCA_RED_MAX (__TCA_RED_MAX - 1)
-
-struct tc_red_qopt
-{
-	__u32		limit;		/* HARD maximal queue length (bytes)	*/
-	__u32		qth_min;	/* Min average length threshold (bytes) */
-	__u32		qth_max;	/* Max average length threshold (bytes) */
-	unsigned char   Wlog;		/* log(W)		*/
-	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
-	unsigned char   Scell_log;	/* cell size for idle damping */
-	unsigned char	flags;
-#define TC_RED_ECN	1
-};
-
-struct tc_red_xstats
-{
-	__u32           early;          /* Early drops */
-	__u32           pdrop;          /* Drops due to queue limits */
-	__u32           other;          /* Drops due to drop() calls */
-	__u32           marked;         /* Marked packets */
-};
-
-/* GRED section */
-
-#define MAX_DPs 16
-
-enum
-{
-       TCA_GRED_UNSPEC,
-       TCA_GRED_PARMS,
-       TCA_GRED_STAB,
-       TCA_GRED_DPS,
-	   __TCA_GRED_MAX,
-};
-
-#define TCA_GRED_MAX (__TCA_GRED_MAX - 1)
-
-#define TCA_SET_OFF TCA_GRED_PARMS
-struct tc_gred_qopt
-{
-       __u32           limit;          /* HARD maximal queue length (bytes)    
-*/
-       __u32           qth_min;        /* Min average length threshold (bytes) 
-*/
-       __u32           qth_max;        /* Max average length threshold (bytes) 
-*/
-       __u32           DP;             /* upto 2^32 DPs */
-       __u32           backlog;        
-       __u32           qave;   
-       __u32           forced; 
-       __u32           early;  
-       __u32           other;  
-       __u32           pdrop;  
-
-       unsigned char   Wlog;           /* log(W)               */
-       unsigned char   Plog;           /* log(P_max/(qth_max-qth_min)) */
-       unsigned char   Scell_log;      /* cell size for idle damping */
-       __u8            prio;		/* prio of this VQ */
-       __u32	packets;
-       __u32	bytesin;
-};
-/* gred setup */
-struct tc_gred_sopt
-{
-       __u32           DPs;
-       __u32           def_DP;
-       __u8            grio;
-};
-
-/* HTB section */
-#define TC_HTB_NUMPRIO		8
-#define TC_HTB_MAXDEPTH		8
-#define TC_HTB_PROTOVER		3 /* the same as HTB and TC's major */
-
-struct tc_htb_opt
-{
-	struct tc_ratespec 	rate;
-	struct tc_ratespec 	ceil;
-	__u32	buffer;
-	__u32	cbuffer;
-	__u32	quantum;
-	__u32	level;		/* out only */
-	__u32	prio;
-};
-struct tc_htb_glob
-{
-	__u32 version;		/* to match HTB/TC */
-    	__u32 rate2quantum;	/* bps->quantum divisor */
-    	__u32 defcls;		/* default class number */
-	__u32 debug;		/* debug flags */
-
-	/* stats */
-	__u32 direct_pkts; /* count of non shapped packets */
-};
-enum
-{
-	TCA_HTB_UNSPEC,
-	TCA_HTB_PARMS,
-	TCA_HTB_INIT,
-	TCA_HTB_CTAB,
-	TCA_HTB_RTAB,
-	__TCA_HTB_MAX,
-};
-
-#define TCA_HTB_MAX (__TCA_HTB_MAX - 1)
-
-struct tc_htb_xstats
-{
-	__u32 lends;
-	__u32 borrows;
-	__u32 giants;	/* too big packets (rate will not be accurate) */
-	__u32 tokens;
-	__u32 ctokens;
-};
-
-/* HFSC section */
-
-struct tc_hfsc_qopt
-{
-	__u16	defcls;		/* default class */
-};
-
-struct tc_service_curve
-{
-	__u32	m1;		/* slope of the first segment in bps */
-	__u32	d;		/* x-projection of the first segment in us */
-	__u32	m2;		/* slope of the second segment in bps */
-};
-
-struct tc_hfsc_stats
-{
-	__u64	work;		/* total work done */
-	__u64	rtwork;		/* work done by real-time criteria */
-	__u32	period;		/* current period */
-	__u32	level;		/* class level in hierarchy */
-};
-
-enum
-{
-	TCA_HFSC_UNSPEC,
-	TCA_HFSC_RSC,
-	TCA_HFSC_FSC,
-	TCA_HFSC_USC,
-	__TCA_HFSC_MAX,
-};
-
-#define TCA_HFSC_MAX (__TCA_HFSC_MAX - 1)
-
-
-/* CBQ section */
-
-#define TC_CBQ_MAXPRIO		8
-#define TC_CBQ_MAXLEVEL		8
-#define TC_CBQ_DEF_EWMA		5
-
-struct tc_cbq_lssopt
-{
-	unsigned char	change;
-	unsigned char	flags;
-#define TCF_CBQ_LSS_BOUNDED	1
-#define TCF_CBQ_LSS_ISOLATED	2
-	unsigned char  	ewma_log;
-	unsigned char  	level;
-#define TCF_CBQ_LSS_FLAGS	1
-#define TCF_CBQ_LSS_EWMA	2
-#define TCF_CBQ_LSS_MAXIDLE	4
-#define TCF_CBQ_LSS_MINIDLE	8
-#define TCF_CBQ_LSS_OFFTIME	0x10
-#define TCF_CBQ_LSS_AVPKT	0x20
-	__u32		maxidle;
-	__u32		minidle;
-	__u32		offtime;
-	__u32		avpkt;
-};
-
-struct tc_cbq_wrropt
-{
-	unsigned char	flags;
-	unsigned char	priority;
-	unsigned char	cpriority;
-	unsigned char	__reserved;
-	__u32		allot;
-	__u32		weight;
-};
-
-struct tc_cbq_ovl
-{
-	unsigned char	strategy;
-#define	TC_CBQ_OVL_CLASSIC	0
-#define	TC_CBQ_OVL_DELAY	1
-#define	TC_CBQ_OVL_LOWPRIO	2
-#define	TC_CBQ_OVL_DROP		3
-#define	TC_CBQ_OVL_RCLASSIC	4
-	unsigned char	priority2;
-	__u32		penalty;
-};
-
-struct tc_cbq_police
-{
-	unsigned char	police;
-	unsigned char	__res1;
-	unsigned short	__res2;
-};
-
-struct tc_cbq_fopt
-{
-	__u32		split;
-	__u32		defmap;
-	__u32		defchange;
-};
-
-struct tc_cbq_xstats
-{
-	__u32		borrows;
-	__u32		overactions;
-	__s32		avgidle;
-	__s32		undertime;
-};
-
-enum
-{
-	TCA_CBQ_UNSPEC,
-	TCA_CBQ_LSSOPT,
-	TCA_CBQ_WRROPT,
-	TCA_CBQ_FOPT,
-	TCA_CBQ_OVL_STRATEGY,
-	TCA_CBQ_RATE,
-	TCA_CBQ_RTAB,
-	TCA_CBQ_POLICE,
-	__TCA_CBQ_MAX,
-};
-
-#define TCA_CBQ_MAX	(__TCA_CBQ_MAX - 1)
-
-/* dsmark section */
-
-enum {
-	TCA_DSMARK_UNSPEC,
-	TCA_DSMARK_INDICES,
-	TCA_DSMARK_DEFAULT_INDEX,
-	TCA_DSMARK_SET_TC_INDEX,
-	TCA_DSMARK_MASK,
-	TCA_DSMARK_VALUE,
-	__TCA_DSMARK_MAX,
-};
-
-#define TCA_DSMARK_MAX (__TCA_DSMARK_MAX - 1)
-
-/* ATM  section */
-
-enum {
-	TCA_ATM_UNSPEC,
-	TCA_ATM_FD,		/* file/socket descriptor */
-	TCA_ATM_PTR,		/* pointer to descriptor - later */
-	TCA_ATM_HDR,		/* LL header */
-	TCA_ATM_EXCESS,		/* excess traffic class (0 for CLP)  */
-	TCA_ATM_ADDR,		/* PVC address (for output only) */
-	TCA_ATM_STATE,		/* VC state (ATM_VS_*; for output only) */
-	__TCA_ATM_MAX,
-};
-
-#define TCA_ATM_MAX	(__TCA_ATM_MAX - 1)
-
-/* Network emulator */
-
-enum
-{
-	TCA_NETEM_UNSPEC,
-	TCA_NETEM_CORR,
-	TCA_NETEM_DELAY_DIST,
-	__TCA_NETEM_MAX,
-};
-
-#define TCA_NETEM_MAX (__TCA_NETEM_MAX - 1)
-
-struct tc_netem_qopt
-{
-	__u32	latency;	/* added delay (us) */
-	__u32   limit;		/* fifo limit (packets) */
-	__u32	loss;		/* random packet loss (0=none ~0=100%) */
-	__u32	gap;		/* re-ordering gap (0 for delay all) */
-	__u32   duplicate;	/* random packet dup  (0=none ~0=100%) */
-	__u32	jitter;		/* random jitter in latency (us) */
-};
-
-struct tc_netem_corr
-{
-	__u32	delay_corr;	/* delay correlation */
-	__u32	loss_corr;	/* packet loss correlation */
-	__u32	dup_corr;	/* duplicate correlation  */
-};
-
-#define NETEM_DIST_SCALE	8192
-
-#endif
diff -uNr a/include/linux/serial_core.h.orig b/include/linux/serial_core.h.orig
--- a/include/linux/serial_core.h.orig	2004-12-24 22:34:00.000000000 +0100
+++ b/include/linux/serial_core.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,471 +0,0 @@
-/*
- *  linux/drivers/char/serial_core.h
- *
- *  Copyright (C) 2000 Deep Blue Solutions Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#ifndef LINUX_SERIAL_CORE_H
-#define LINUX_SERIAL_CORE_H
-
-/*
- * The type definitions.  These are from Ted Ts'o's serial.h
- */
-#define PORT_UNKNOWN	0
-#define PORT_8250	1
-#define PORT_16450	2
-#define PORT_16550	3
-#define PORT_16550A	4
-#define PORT_CIRRUS	5
-#define PORT_16650	6
-#define PORT_16650V2	7
-#define PORT_16750	8
-#define PORT_STARTECH	9
-#define PORT_16C950	10
-#define PORT_16654	11
-#define PORT_16850	12
-#define PORT_RSA	13
-#define PORT_NS16550A	14
-#define PORT_XSCALE	15
-#define PORT_MAX_8250	15	/* max port ID */
-
-/*
- * ARM specific type numbers.  These are not currently guaranteed
- * to be implemented, and will change in the future.  These are
- * separate so any additions to the old serial.c that occur before
- * we are merged can be easily merged here.
- */
-#define PORT_PXA	31
-#define PORT_AMBA	32
-#define PORT_CLPS711X	33
-#define PORT_SA1100	34
-#define PORT_UART00	35
-#define PORT_21285	37
-
-/* Sparc type numbers.  */
-#define PORT_SUNZILOG	38
-#define PORT_SUNSAB	39
-
-/* NEC v850.  */
-#define PORT_V850E_UART	40
-
-/* DZ */
-#define PORT_DZ		47
-
-/* Parisc type numbers. */
-#define PORT_MUX	48
-
-/* Macintosh Zilog type numbers */
-#define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
-#define PORT_PMAC_ZILOG	51
-
-/* SH-SCI */
-#define PORT_SCI	52
-#define PORT_SCIF	53
-#define PORT_IRDA	54
-
-/* Samsung S3C2410 SoC and derivatives thereof */
-#define PORT_S3C2410    55
-
-/* SGI IP22 aka Indy / Challenge S / Indigo 2 */
-#define PORT_IP22ZILOG	56
-
-/* Sharp LH7a40x -- an ARM9 SoC series */
-#define PORT_LH7A40X	57
-
-/* PPC CPM type number */
-#define PORT_CPM        58
-
-/* MPC52xx type numbers */
-#define PORT_MPC52xx	59
-
-/* IBM icom */
-#define PORT_ICOM	60
-
-/* Samsung S3C2440 SoC */
-#define PORT_S3C2440	61
-
-/* Motorola i.MX SoC */
-#define PORT_IMX	62
-
-#ifdef __KERNEL__
-
-#include <linux/config.h>
-#include <linux/interrupt.h>
-#include <linux/circ_buf.h>
-#include <linux/spinlock.h>
-#include <linux/sched.h>
-#include <linux/tty.h>
-
-struct uart_port;
-struct uart_info;
-struct serial_struct;
-struct device;
-
-/*
- * This structure describes all the operations that can be
- * done on the physical hardware.
- */
-struct uart_ops {
-	unsigned int	(*tx_empty)(struct uart_port *);
-	void		(*set_mctrl)(struct uart_port *, unsigned int mctrl);
-	unsigned int	(*get_mctrl)(struct uart_port *);
-	void		(*stop_tx)(struct uart_port *, unsigned int tty_stop);
-	void		(*start_tx)(struct uart_port *, unsigned int tty_start);
-	void		(*send_xchar)(struct uart_port *, char ch);
-	void		(*stop_rx)(struct uart_port *);
-	void		(*enable_ms)(struct uart_port *);
-	void		(*break_ctl)(struct uart_port *, int ctl);
-	int		(*startup)(struct uart_port *);
-	void		(*shutdown)(struct uart_port *);
-	void		(*set_termios)(struct uart_port *, struct termios *new,
-				       struct termios *old);
-	void		(*pm)(struct uart_port *, unsigned int state,
-			      unsigned int oldstate);
-	int		(*set_wake)(struct uart_port *, unsigned int state);
-
-	/*
-	 * Return a string describing the type of the port
-	 */
-	const char *(*type)(struct uart_port *);
-
-	/*
-	 * Release IO and memory resources used by the port.
-	 * This includes iounmap if necessary.
-	 */
-	void		(*release_port)(struct uart_port *);
-
-	/*
-	 * Request IO and memory resources used by the port.
-	 * This includes iomapping the port if necessary.
-	 */
-	int		(*request_port)(struct uart_port *);
-	void		(*config_port)(struct uart_port *, int);
-	int		(*verify_port)(struct uart_port *, struct serial_struct *);
-	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
-};
-
-#define UART_CONFIG_TYPE	(1 << 0)
-#define UART_CONFIG_IRQ		(1 << 1)
-
-struct uart_icount {
-	__u32	cts;
-	__u32	dsr;
-	__u32	rng;
-	__u32	dcd;
-	__u32	rx;
-	__u32	tx;
-	__u32	frame;
-	__u32	overrun;
-	__u32	parity;
-	__u32	brk;
-	__u32	buf_overrun;
-};
-
-struct uart_port {
-	spinlock_t		lock;			/* port lock */
-	unsigned int		iobase;			/* in/out[bwl] */
-	unsigned char __iomem	*membase;		/* read/write[bwl] */
-	unsigned int		irq;			/* irq number */
-	unsigned int		uartclk;		/* base uart clock */
-	unsigned char		fifosize;		/* tx fifo size */
-	unsigned char		x_char;			/* xon/xoff char */
-	unsigned char		regshift;		/* reg offset shift */
-	unsigned char		iotype;			/* io access style */
-
-#define UPIO_PORT		(0)
-#define UPIO_HUB6		(1)
-#define UPIO_MEM		(2)
-#define UPIO_MEM32		(3)
-
-	unsigned int		read_status_mask;	/* driver specific */
-	unsigned int		ignore_status_mask;	/* driver specific */
-	struct uart_info	*info;			/* pointer to parent info */
-	struct uart_icount	icount;			/* statistics */
-
-	struct console		*cons;			/* struct console, if any */
-#ifdef CONFIG_SERIAL_CORE_CONSOLE
-	unsigned long		sysrq;			/* sysrq timeout */
-#endif
-
-	unsigned int		flags;
-
-#define UPF_FOURPORT		(1 << 1)
-#define UPF_SAK			(1 << 2)
-#define UPF_SPD_MASK		(0x1030)
-#define UPF_SPD_HI		(0x0010)
-#define UPF_SPD_VHI		(0x0020)
-#define UPF_SPD_CUST		(0x0030)
-#define UPF_SPD_SHI		(0x1000)
-#define UPF_SPD_WARP		(0x1010)
-#define UPF_SKIP_TEST		(1 << 6)
-#define UPF_AUTO_IRQ		(1 << 7)
-#define UPF_HARDPPS_CD		(1 << 11)
-#define UPF_LOW_LATENCY		(1 << 13)
-#define UPF_BUGGY_UART		(1 << 14)
-#define UPF_AUTOPROBE		(1 << 15)
-#define UPF_MAGIC_MULTIPLIER	(1 << 16)
-#define UPF_BOOT_ONLYMCA	(1 << 22)
-#define UPF_CONS_FLOW		(1 << 23)
-#define UPF_SHARE_IRQ		(1 << 24)
-#define UPF_BOOT_AUTOCONF	(1 << 28)
-#define UPF_IOREMAP		(1 << 31)
-
-#define UPF_CHANGE_MASK		(0x17fff)
-#define UPF_USR_MASK		(UPF_SPD_MASK|UPF_LOW_LATENCY)
-
-	unsigned int		mctrl;			/* current modem ctrl settings */
-	unsigned int		timeout;		/* character-based timeout */
-	unsigned int		type;			/* port type */
-	struct uart_ops		*ops;
-	unsigned int		custom_divisor;
-	unsigned int		line;			/* port index */
-	unsigned long		mapbase;		/* for ioremap */
-	struct device		*dev;			/* parent device */
-	unsigned char		hub6;			/* this should be in the 8250 driver */
-	unsigned char		unused[3];
-};
-
-/*
- * This is the state information which is persistent across opens.
- * The low level driver must not to touch any elements contained
- * within.
- */
-struct uart_state {
-	unsigned int		close_delay;		/* msec */
-	unsigned int		closing_wait;		/* msec */
-
-#define USF_CLOSING_WAIT_INF	(0)
-#define USF_CLOSING_WAIT_NONE	(~0U)
-
-	int			count;
-	int			pm_state;
-	struct uart_info	*info;
-	struct uart_port	*port;
-
-	struct semaphore	sem;
-};
-
-#define UART_XMIT_SIZE	PAGE_SIZE
-/*
- * This is the state information which is only valid when the port
- * is open; it may be freed by the core driver once the device has
- * been closed.  Either the low level driver or the core can modify
- * stuff here.
- */
-struct uart_info {
-	struct tty_struct	*tty;
-	struct circ_buf		xmit;
-	unsigned int		flags;
-
-/*
- * These are the flags that specific to info->flags, and reflect our
- * internal state.  They can not be accessed via port->flags.  Low
- * level drivers must not change these, but may query them instead.
- */
-#define UIF_CHECK_CD		(1 << 25)
-#define UIF_CTS_FLOW		(1 << 26)
-#define UIF_NORMAL_ACTIVE	(1 << 29)
-#define UIF_INITIALIZED		(1 << 31)
-
-	int			blocked_open;
-
-	struct tasklet_struct	tlet;
-
-	wait_queue_head_t	open_wait;
-	wait_queue_head_t	delta_msr_wait;
-};
-
-/* number of characters left in xmit buffer before we ask for more */
-#define WAKEUP_CHARS		256
-
-struct module;
-struct tty_driver;
-
-struct uart_driver {
-	struct module		*owner;
-	const char		*driver_name;
-	const char		*dev_name;
-	const char		*devfs_name;
-	int			 major;
-	int			 minor;
-	int			 nr;
-	struct console		*cons;
-
-	/*
-	 * these are private; the low level driver should not
-	 * touch these; they should be initialised to NULL
-	 */
-	struct uart_state	*state;
-	struct tty_driver	*tty_driver;
-};
-
-void uart_write_wakeup(struct uart_port *port);
-
-/*
- * Baud rate helpers.
- */
-void uart_update_timeout(struct uart_port *port, unsigned int cflag,
-			 unsigned int baud);
-unsigned int uart_get_baud_rate(struct uart_port *port, struct termios *termios,
-				struct termios *old, unsigned int min,
-				unsigned int max);
-unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);
-
-/*
- * Console helpers.
- */
-struct uart_port *uart_get_console(struct uart_port *ports, int nr,
-				   struct console *c);
-void uart_parse_options(char *options, int *baud, int *parity, int *bits,
-			int *flow);
-int uart_set_options(struct uart_port *port, struct console *co, int baud,
-		     int parity, int bits, int flow);
-struct tty_driver *uart_console_device(struct console *co, int *index);
-
-/*
- * Port/driver registration/removal
- */
-int uart_register_driver(struct uart_driver *uart);
-void uart_unregister_driver(struct uart_driver *uart);
-void uart_unregister_port(struct uart_driver *reg, int line);
-int uart_register_port(struct uart_driver *reg, struct uart_port *port);
-int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
-int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
-
-/*
- * Power Management
- */
-int uart_suspend_port(struct uart_driver *reg, struct uart_port *port);
-int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
-
-#define uart_circ_empty(circ)		((circ)->head == (circ)->tail)
-#define uart_circ_clear(circ)		((circ)->head = (circ)->tail = 0)
-
-#define uart_circ_chars_pending(circ)	\
-	(CIRC_CNT((circ)->head, (circ)->tail, UART_XMIT_SIZE))
-
-#define uart_circ_chars_free(circ)	\
-	(CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))
-
-#define uart_tx_stopped(port)		\
-	((port)->info->tty->stopped || (port)->info->tty->hw_stopped)
-
-/*
- * The following are helper functions for the low level drivers.
- */
-#ifdef SUPPORT_SYSRQ
-static inline int
-uart_handle_sysrq_char(struct uart_port *port, unsigned int ch,
-		       struct pt_regs *regs)
-{
-	if (port->sysrq) {
-		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, regs, NULL);
-			port->sysrq = 0;
-			return 1;
-		}
-		port->sysrq = 0;
-	}
-	return 0;
-}
-#else
-#define uart_handle_sysrq_char(port,ch,regs)	(0)
-#endif
-
-/*
- * We do the SysRQ and SAK checking like this...
- */
-static inline int uart_handle_break(struct uart_port *port)
-{
-	struct uart_info *info = port->info;
-#ifdef SUPPORT_SYSRQ
-	if (port->cons && port->cons->index == port->line) {
-		if (!port->sysrq) {
-			port->sysrq = jiffies + HZ*5;
-			return 1;
-		}
-		port->sysrq = 0;
-	}
-#endif
-	if (info->flags & UPF_SAK)
-		do_SAK(info->tty);
-	return 0;
-}
-
-/**
- *	uart_handle_dcd_change - handle a change of carrier detect state
- *	@port: uart_port structure for the open port
- *	@status: new carrier detect status, nonzero if active
- */
-static inline void
-uart_handle_dcd_change(struct uart_port *port, unsigned int status)
-{
-	struct uart_info *info = port->info;
-
-	port->icount.dcd++;
-
-#ifdef CONFIG_HARD_PPS
-	if ((port->flags & UPF_HARDPPS_CD) && status)
-		hardpps();
-#endif
-
-	if (info->flags & UIF_CHECK_CD) {
-		if (status)
-			wake_up_interruptible(&info->open_wait);
-		else if (info->tty)
-			tty_hangup(info->tty);
-	}
-}
-
-/**
- *	uart_handle_cts_change - handle a change of clear-to-send state
- *	@port: uart_port structure for the open port
- *	@status: new clear to send status, nonzero if active
- */
-static inline void
-uart_handle_cts_change(struct uart_port *port, unsigned int status)
-{
-	struct uart_info *info = port->info;
-	struct tty_struct *tty = info->tty;
-
-	port->icount.cts++;
-
-	if (info->flags & UIF_CTS_FLOW) {
-		if (tty->hw_stopped) {
-			if (status) {
-				tty->hw_stopped = 0;
-				port->ops->start_tx(port, 0);
-				uart_write_wakeup(port);
-			}
-		} else {
-			if (!status) {
-				tty->hw_stopped = 1;
-				port->ops->stop_tx(port, 0);
-			}
-		}
-	}
-}
-
-/*
- *	UART_ENABLE_MS - determine if port should enable modem status irqs
- */
-#define UART_ENABLE_MS(port,cflag)	((port)->flags & UPF_HARDPPS_CD || \
-					 (cflag) & CRTSCTS || \
-					 !((cflag) & CLOCAL))
-
-#endif
-
-#endif /* LINUX_SERIAL_CORE_H */
diff -uNr a/include/sound/ac97_codec.h b/include/sound/ac97_codec.h
--- a/include/sound/ac97_codec.h	2004-12-24 22:34:57.000000000 +0100
+++ b/include/sound/ac97_codec.h	2005-01-14 22:28:25.632461704 +0100
@@ -364,6 +364,8 @@
 #define AC97_CX_SPDIF		(1<<3)	/* Conexant's spdif interface */
 #define AC97_STEREO_MUTES	(1<<4)	/* has stereo mute bits */
 #define AC97_DOUBLE_RATE	(1<<5)	/* supports double rate playback */
+#define AC97_HAS_NO_MASTER_VOL	(1<<6)	/* no Master volume */
+#define AC97_HAS_NO_PCM_VOL	(1<<7)	/* no PCM volume */
 
 /* rates indexes */
 #define AC97_RATES_FRONT_DAC	0
@@ -423,6 +425,10 @@
 	int (*build_specific) (ac97_t *ac97);
 	int (*build_spdif) (ac97_t *ac97);
 	int (*build_post_spdif) (ac97_t *ac97);
+#ifdef CONFIG_PM
+	void (*suspend) (ac97_t *ac97);
+	void (*resume) (ac97_t *ac97);
+#endif
 };
 
 struct _snd_ac97_bus_ops {
@@ -477,8 +483,8 @@
 	snd_info_entry_t *proc_regs;
 	unsigned short subsystem_vendor;
 	unsigned short subsystem_device;
-	spinlock_t reg_lock;
-	struct semaphore mutex;	/* mutex for AD18xx multi-codecs and paging (2.3) */
+	struct semaphore reg_mutex;
+	struct semaphore page_mutex;	/* mutex for AD18xx multi-codecs and paging (2.3) */
 	unsigned short num;	/* number of codec: 0 = primary, 1 = secondary */
 	unsigned short addr;	/* physical address of codec [0-3] */
 	unsigned int id;	/* identification of codec */
@@ -551,6 +557,7 @@
 	AC97_TUNE_AD_SHARING,	/* for AD1985, turn on OMS bit and use headphone */
 	AC97_TUNE_ALC_JACK,	/* for Realtek, enable JACK detection */
 	AC97_TUNE_INV_EAPD,	/* inverted EAPD implementation */
+	AC97_TUNE_MUTE_LED,	/* EAPD bit works as mute LED */
 };
 
 struct ac97_quirk {
@@ -562,7 +569,7 @@
 	int type;		/* quirk type above */
 };
 
-int snd_ac97_tune_hardware(ac97_t *ac97, struct ac97_quirk *quirk, int override);
+int snd_ac97_tune_hardware(ac97_t *ac97, struct ac97_quirk *quirk, const char *override);
 int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned int rate);
 
 int snd_ac97_pcm_assign(ac97_bus_t *ac97,
diff -uNr a/include/sound/ad1848.h b/include/sound/ad1848.h
--- a/include/sound/ad1848.h	2004-12-24 22:34:30.000000000 +0100
+++ b/include/sound/ad1848.h	2005-01-14 22:28:11.498610376 +0100
@@ -157,10 +157,6 @@
 /* exported functions */
 
 void snd_ad1848_out(ad1848_t *chip, unsigned char reg, unsigned char value);
-void snd_ad1848_dout(ad1848_t *chip, unsigned char reg, unsigned char value);
-unsigned char snd_ad1848_in(ad1848_t *chip, unsigned char reg);
-void snd_ad1848_mce_up(ad1848_t *chip);
-void snd_ad1848_mce_down(ad1848_t *chip);
 
 int snd_ad1848_create(snd_card_t * card,
 		      unsigned long port,
@@ -171,7 +167,6 @@
 int snd_ad1848_pcm(ad1848_t * chip, int device, snd_pcm_t **rpcm);
 const snd_pcm_ops_t *snd_ad1848_get_pcm_ops(int direction);
 int snd_ad1848_mixer(ad1848_t * chip);
-irqreturn_t snd_ad1848_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
 /* exported mixer stuffs */
 enum { AD1848_MIX_SINGLE, AD1848_MIX_DOUBLE, AD1848_MIX_CAPTURE };
@@ -208,8 +203,4 @@
 	return snd_ad1848_add_ctl(chip, c->name, c->index, c->type, c->private_value);
 }
 
-#ifdef CONFIG_SND_DEBUG
-void snd_ad1848_debug(ad1848_t *chip);
-#endif
-
 #endif /* __SOUND_AD1848_H */
diff -uNr a/include/sound/ainstr_fm.h b/include/sound/ainstr_fm.h
--- a/include/sound/ainstr_fm.h	2004-12-24 22:34:44.000000000 +0100
+++ b/include/sound/ainstr_fm.h	2005-01-14 22:28:11.500610072 +0100
@@ -122,8 +122,6 @@
 
 #include "seq_instr.h"
 
-extern char *snd_seq_fm_id;
-
 int snd_seq_fm_init(snd_seq_kinstr_ops_t * ops,
 		    snd_seq_kinstr_ops_t * next);
 
diff -uNr a/include/sound/ainstr_gf1.h b/include/sound/ainstr_gf1.h
--- a/include/sound/ainstr_gf1.h	2004-12-24 22:35:23.000000000 +0100
+++ b/include/sound/ainstr_gf1.h	2005-01-14 22:28:11.503609616 +0100
@@ -203,8 +203,6 @@
 
 #include "seq_instr.h"
 
-extern char *snd_seq_gf1_id;
-
 typedef struct {
 	void *private_data;
 	int (*info)(void *private_data, gf1_info_t *info);
diff -uNr a/include/sound/ainstr_iw.h b/include/sound/ainstr_iw.h
--- a/include/sound/ainstr_iw.h	2004-12-24 22:35:50.000000000 +0100
+++ b/include/sound/ainstr_iw.h	2005-01-14 22:28:11.506609160 +0100
@@ -351,8 +351,6 @@
 
 #include "seq_instr.h"
 
-extern char *snd_seq_iwffff_id;
-
 typedef struct {
 	void *private_data;
 	int (*info)(void *private_data, iwffff_info_t *info);
diff -uNr a/include/sound/ainstr_simple.h b/include/sound/ainstr_simple.h
--- a/include/sound/ainstr_simple.h	2004-12-24 22:35:24.000000000 +0100
+++ b/include/sound/ainstr_simple.h	2005-01-14 22:28:11.508608856 +0100
@@ -134,8 +134,6 @@
 
 #include "seq_instr.h"
 
-extern char *snd_seq_simple_id;
-
 typedef struct {
 	void *private_data;
 	int (*info)(void *private_data, simple_instrument_info_t *info);
diff -uNr a/include/sound/ak4531_codec.h b/include/sound/ak4531_codec.h
--- a/include/sound/ak4531_codec.h	2004-12-24 22:34:29.000000000 +0100
+++ b/include/sound/ak4531_codec.h	2005-01-14 22:28:11.510608552 +0100
@@ -72,7 +72,7 @@
 	void (*private_free) (ak4531_t *ak4531);
 	/* --- */
 	unsigned char regs[0x20];
-	spinlock_t reg_lock;
+	struct semaphore reg_mutex;
 };
 
 int snd_ak4531_mixer(snd_card_t * card, ak4531_t * _ak4531, ak4531_t ** rak4531);
diff -uNr a/include/sound/asound.h b/include/sound/asound.h
--- a/include/sound/asound.h	2004-12-24 22:35:01.000000000 +0100
+++ b/include/sound/asound.h	2005-01-14 22:28:11.515607792 +0100
@@ -110,9 +110,12 @@
 	SNDRV_HWDEP_IFACE_MIXART,	/* Digigram miXart cards */
 	SNDRV_HWDEP_IFACE_USX2Y,	/* Tascam US122, US224 & US428 usb */
 	SNDRV_HWDEP_IFACE_EMUX_WAVETABLE, /* EmuX wavetable */	
+	SNDRV_HWDEP_IFACE_BLUETOOTH,	/* Bluetooth audio */
+	SNDRV_HWDEP_IFACE_USX2Y_PCM,	/* Tascam US122, US224 & US428 rawusb pcm */
+	SNDRV_HWDEP_IFACE_PCXHR,	/* Digigram PCXHR */
 
 	/* Don't forget to change the following: */
-	SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_EMUX_WAVETABLE,
+	SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_PCXHR
 };
 
 struct sndrv_hwdep_info {
diff -uNr a/include/sound/control.h b/include/sound/control.h
--- a/include/sound/control.h	2004-12-24 22:34:45.000000000 +0100
+++ b/include/sound/control.h	2005-01-14 22:28:11.517607488 +0100
@@ -115,13 +115,14 @@
 snd_kcontrol_t *snd_ctl_find_numid(snd_card_t * card, unsigned int numid);
 snd_kcontrol_t *snd_ctl_find_id(snd_card_t * card, snd_ctl_elem_id_t *id);
 
-int snd_ctl_register(snd_card_t *card);
-int snd_ctl_disconnect(snd_card_t *card);
-int snd_ctl_can_unregister(snd_card_t *card);
-int snd_ctl_unregister(snd_card_t *card);
+int snd_ctl_create(snd_card_t *card);
+
 int snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn);
 int snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn);
 
+int snd_ctl_elem_read(snd_card_t *card, snd_ctl_elem_value_t *control);
+int snd_ctl_elem_write(snd_card_t *card, snd_ctl_file_t *file, snd_ctl_elem_value_t *control);
+
 static inline unsigned int snd_ctl_get_ioffnum(snd_kcontrol_t *kctl, snd_ctl_elem_id_t *id)
 {
 	return id->numid - kctl->id.numid;
diff -uNr a/include/sound/core.h b/include/sound/core.h
--- a/include/sound/core.h	2004-12-24 22:35:40.000000000 +0100
+++ b/include/sound/core.h	2005-01-14 22:28:11.520607032 +0100
@@ -49,6 +49,7 @@
 
 typedef enum {
 	SNDRV_DEV_TOPLEVEL =		(0*SNDRV_DEV_TYPE_RANGE_SIZE),
+	SNDRV_DEV_CONTROL,
 	SNDRV_DEV_LOWLEVEL_PRE,
 	SNDRV_DEV_LOWLEVEL_NORMAL =	(1*SNDRV_DEV_TYPE_RANGE_SIZE),
 	SNDRV_DEV_PCM,
@@ -57,6 +58,8 @@
 	SNDRV_DEV_SEQUENCER,
 	SNDRV_DEV_HWDEP,
 	SNDRV_DEV_INFO,
+	SNDRV_DEV_BUS,
+	SNDRV_DEV_CODEC,
 	SNDRV_DEV_LOWLEVEL =		(2*SNDRV_DEV_TYPE_RANGE_SIZE)
 } snd_device_type_t;
 
@@ -147,6 +150,7 @@
 	struct rw_semaphore controls_rwsem;	/* controls list lock */
 	rwlock_t ctl_files_rwlock;	/* ctl_files list lock */
 	int controls_count;		/* count of all controls */
+	int user_ctl_count;		/* count of all user controls */
 	struct list_head controls;	/* all controls for this card */
 	struct list_head ctl_files;	/* active control files */
 
@@ -307,12 +311,11 @@
 #define vfree_nocheck(obj) vfree(obj)
 #endif
 char *snd_kmalloc_strdup(const char *string, int flags);
-int copy_to_user_fromio(void __user *dst, const void __iomem *src, size_t count);
-int copy_from_user_toio(void __iomem *dst, const void __user *src, size_t count);
+int copy_to_user_fromio(void __user *dst, const volatile void __iomem *src, size_t count);
+int copy_from_user_toio(volatile void __iomem *dst, const void __user *src, size_t count);
 
 /* init.c */
 
-extern int snd_cards_count;
 extern unsigned int snd_cards_lock;
 extern snd_card_t *snd_cards[SNDRV_CARDS];
 extern rwlock_t snd_card_rwlock;
diff -uNr a/include/sound/cs4231.h b/include/sound/cs4231.h
--- a/include/sound/cs4231.h	2004-12-24 22:34:45.000000000 +0100
+++ b/include/sound/cs4231.h	2005-01-14 22:28:11.522606728 +0100
@@ -309,7 +309,6 @@
 
 void snd_cs4231_out(cs4231_t *chip, unsigned char reg, unsigned char val);
 unsigned char snd_cs4231_in(cs4231_t *chip, unsigned char reg);
-void snd_cs4231_outm(cs4231_t *chip, unsigned char reg, unsigned char mask, unsigned char val);
 void snd_cs4236_ext_out(cs4231_t *chip, unsigned char reg, unsigned char val);
 unsigned char snd_cs4236_ext_in(cs4231_t *chip, unsigned char reg);
 void snd_cs4231_mce_up(cs4231_t *chip);
@@ -364,8 +363,4 @@
 int snd_cs4231_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
 int snd_cs4231_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
 
-#ifdef CONFIG_SND_DEBUG
-void snd_cs4231_debug(cs4231_t *chip);
-#endif
-
 #endif /* __SOUND_CS4231_H */
diff -uNr a/include/sound/cs8427.h b/include/sound/cs8427.h
--- a/include/sound/cs8427.h	2004-12-24 22:35:00.000000000 +0100
+++ b/include/sound/cs8427.h	2005-01-14 22:28:11.525606272 +0100
@@ -186,12 +186,9 @@
 #define CS8427_VERSHIFT		0
 #define CS8427_VER8427A		0x71
 
-int snd_cs8427_detect(snd_i2c_bus_t *bus, unsigned char addr);
 int snd_cs8427_create(snd_i2c_bus_t *bus, unsigned char addr,
 		      unsigned int reset_timeout, snd_i2c_device_t **r_cs8427);
-void snd_cs8427_reset(snd_i2c_device_t *cs8427);
 int snd_cs8427_reg_write(snd_i2c_device_t *device, unsigned char reg, unsigned char val);
-int snd_cs8427_reg_read(snd_i2c_device_t *device, unsigned char reg);
 int snd_cs8427_iec958_build(snd_i2c_device_t *cs8427, snd_pcm_substream_t *playback_substream, snd_pcm_substream_t *capture_substream);
 int snd_cs8427_iec958_active(snd_i2c_device_t *cs8427, int active);
 int snd_cs8427_iec958_pcm(snd_i2c_device_t *cs8427, unsigned int rate);
diff -uNr a/include/sound/emu10k1.h b/include/sound/emu10k1.h
--- a/include/sound/emu10k1.h	2004-12-24 22:34:27.000000000 +0100
+++ b/include/sound/emu10k1.h	2005-01-14 22:28:11.536604600 +0100
@@ -31,6 +31,7 @@
 #include <sound/ac97_codec.h>
 #include <sound/util_mem.h>
 #include <sound/pcm-indirect.h>
+#include <sound/timer.h>
 #include <linux/interrupt.h>
 #include <asm/io.h>
 
@@ -828,6 +829,7 @@
 };
 
 typedef struct {
+	/* mono, left, right x 8 sends (4 on emu10k1) */
 	unsigned char send_routing[3][8];
 	unsigned char send_volume[3][8];
 	unsigned short attn[3];
@@ -838,10 +840,10 @@
 ((route[0] | (route[1] << 4) | (route[2] << 8) | (route[3] << 12)) << 16)
 
 #define snd_emu10k1_compose_audigy_fxrt1(route) \
-(((unsigned int)route[0] | ((unsigned int)route[1] << 8) | ((unsigned int)route[2] << 16) | ((unsigned int)route[3] << 12)) << 24)
+((unsigned int)route[0] | ((unsigned int)route[1] << 8) | ((unsigned int)route[2] << 16) | ((unsigned int)route[3] << 24))
 
 #define snd_emu10k1_compose_audigy_fxrt2(route) \
-(((unsigned int)route[4] | ((unsigned int)route[5] << 8) | ((unsigned int)route[6] << 16) | ((unsigned int)route[7] << 12)) << 24)
+((unsigned int)route[4] | ((unsigned int)route[5] << 8) | ((unsigned int)route[6] << 16) | ((unsigned int)route[7] << 24))
 
 typedef struct snd_emu10k1_memblk {
 	snd_util_memblk_t mem;
@@ -1000,6 +1002,8 @@
 	snd_pcm_substream_t *pcm_capture_mic_substream;
 	snd_pcm_substream_t *pcm_capture_efx_substream;
 
+	snd_timer_t *timer;
+
 	emu10k1_midi_t midi;
 	emu10k1_midi_t midi2; /* for audigy */
 
@@ -1019,6 +1023,7 @@
 int snd_emu10k1_pcm_efx(emu10k1_t * emu, int device, snd_pcm_t ** rpcm);
 int snd_emu10k1_fx8010_pcm(emu10k1_t * emu, int device, snd_pcm_t ** rpcm);
 int snd_emu10k1_mixer(emu10k1_t * emu);
+int snd_emu10k1_timer(emu10k1_t * emu, int device);
 int snd_emu10k1_fx8010_new(emu10k1_t *emu, int device, snd_hwdep_t ** rhwdep);
 
 irqreturn_t snd_emu10k1_interrupt(int irq, void *dev_id, struct pt_regs *regs);
@@ -1032,7 +1037,6 @@
 /* I/O functions */
 unsigned int snd_emu10k1_ptr_read(emu10k1_t * emu, unsigned int reg, unsigned int chn);
 void snd_emu10k1_ptr_write(emu10k1_t *emu, unsigned int reg, unsigned int chn, unsigned int data);
-void snd_emu10k1_efx_write(emu10k1_t *emu, unsigned int pc, unsigned int data);
 unsigned int snd_emu10k1_efx_read(emu10k1_t *emu, unsigned int pc);
 void snd_emu10k1_intr_enable(emu10k1_t *emu, unsigned int intrenb);
 void snd_emu10k1_intr_disable(emu10k1_t *emu, unsigned int intrenb);
@@ -1046,7 +1050,6 @@
 unsigned short snd_emu10k1_ac97_read(ac97_t *ac97, unsigned short reg);
 void snd_emu10k1_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short data);
 unsigned int snd_emu10k1_rate_to_pitch(unsigned int rate);
-unsigned char snd_emu10k1_sum_vol_attn(unsigned int value);
 
 /* memory allocation */
 snd_util_memblk_t *snd_emu10k1_alloc_pages(emu10k1_t *emu, snd_pcm_substream_t *substream);
@@ -1334,7 +1337,7 @@
 	char name[128];
 
 	DECLARE_BITMAP(gpr_valid, 0x200); /* bitmask of valid initializers */
-	unsigned int gpr_map[0x200];	  /* initializers */
+	u_int32_t __user *gpr_map;	  /* initializers */
 
 	unsigned int gpr_add_control_count; /* count of GPR controls to add/replace */
 	emu10k1_fx8010_control_gpr_t __user *gpr_add_controls; /* GPR controls to add/replace */
@@ -1347,11 +1350,11 @@
 	emu10k1_fx8010_control_gpr_t __user *gpr_list_controls; /* listed GPR controls */
 
 	DECLARE_BITMAP(tram_valid, 0x100); /* bitmask of valid initializers */
-	unsigned int tram_data_map[0x100]; /* data initializers */
-	unsigned int tram_addr_map[0x100]; /* map initializers */
+	u_int32_t __user *tram_data_map;  /* data initializers */
+	u_int32_t __user *tram_addr_map;  /* map initializers */
 
 	DECLARE_BITMAP(code_valid, 1024); /* bitmask of valid instructions */
-	unsigned int code[1024][2];	  /* one instruction - 64 bits */
+	u_int32_t __user *code;		  /* one instruction - 64 bits */
 } emu10k1_fx8010_code_t;
 
 typedef struct {
diff -uNr a/include/sound/es1688.h b/include/sound/es1688.h
--- a/include/sound/es1688.h	2004-12-24 22:35:01.000000000 +0100
+++ b/include/sound/es1688.h	2005-01-14 22:28:11.543603536 +0100
@@ -108,9 +108,6 @@
  */
 
 void snd_es1688_mixer_write(es1688_t *chip, unsigned char reg, unsigned char data);
-unsigned char snd_es1688_mixer_read(es1688_t *chip, unsigned char reg);
-
-irqreturn_t snd_es1688_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
 int snd_es1688_create(snd_card_t * card,
 		      unsigned long port,
diff -uNr a/include/sound/gus.h b/include/sound/gus.h
--- a/include/sound/gus.h	2004-12-24 22:33:50.000000000 +0100
+++ b/include/sound/gus.h	2005-01-14 22:28:11.546603080 +0100
@@ -598,10 +598,6 @@
 
 /* gus_dma.c */
 
-void snd_gf1_dma_program(snd_gus_card_t * gus, unsigned int addr,
-			 unsigned long buf_addr, unsigned int count,
-			 unsigned int cmd);
-void snd_gf1_dma_ack(snd_gus_card_t * gus);
 int snd_gf1_dma_init(snd_gus_card_t * gus);
 int snd_gf1_dma_done(snd_gus_card_t * gus);
 int snd_gf1_dma_transfer_block(snd_gus_card_t * gus,
diff -uNr a/include/sound/info.h b/include/sound/info.h
--- a/include/sound/info.h	2004-12-24 22:35:23.000000000 +0100
+++ b/include/sound/info.h	2005-01-14 22:28:11.549602624 +0100
@@ -131,11 +131,6 @@
 int snd_info_register(snd_info_entry_t * entry);
 int snd_info_unregister(snd_info_entry_t * entry);
 
-struct proc_dir_entry *snd_create_proc_entry(const char *name, mode_t mode,
-					     struct proc_dir_entry *parent);
-void snd_remove_proc_entry(struct proc_dir_entry *parent,
-			   struct proc_dir_entry *de);
-
 /* for card drivers */
 int snd_card_proc_new(snd_card_t *card, const char *name, snd_info_entry_t **entryp);
 
@@ -171,10 +166,6 @@
 static inline int snd_info_register(snd_info_entry_t * entry) { return 0; }
 static inline int snd_info_unregister(snd_info_entry_t * entry) { return 0; }
 
-static inline struct proc_dir_entry *snd_create_proc_entry(const char *name, mode_t mode, struct proc_dir_entry *parent) { return NULL; }
-static inline void snd_remove_proc_entry(struct proc_dir_entry *parent,
-					 struct proc_dir_entry *de) { ; }
-
 #define snd_card_proc_new(card,name,entryp)  0 /* always success */
 #define snd_info_set_text_ops(entry,private_data,read_size,read) /*NOP*/
 
diff -uNr a/include/sound/pcm.h b/include/sound/pcm.h
--- a/include/sound/pcm.h	2004-12-24 22:34:45.000000000 +0100
+++ b/include/sound/pcm.h	2005-01-14 22:28:11.553602016 +0100
@@ -497,10 +497,6 @@
 int snd_pcm_kernel_playback_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
 int snd_pcm_kernel_capture_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
 int snd_pcm_kernel_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
-int snd_pcm_open(struct inode *inode, struct file *file);
-int snd_pcm_release(struct inode *inode, struct file *file);
-unsigned int snd_pcm_playback_poll(struct file *file, poll_table * wait);
-unsigned int snd_pcm_capture_poll(struct file *file, poll_table * wait);
 int snd_pcm_open_substream(snd_pcm_t *pcm, int stream, snd_pcm_substream_t **rsubstream);
 void snd_pcm_release_substream(snd_pcm_substream_t *substream);
 void snd_pcm_vma_notify_data(void *client, void *data);
@@ -709,6 +705,80 @@
 	return runtime->buffer_size - snd_pcm_capture_avail(runtime);
 }
 
+/**
+ * snd_pcm_playback_ready - check whether the playback buffer is available
+ * @substream: the pcm substream instance
+ *
+ * Checks whether enough free space is available on the playback buffer.
+ *
+ * Returns non-zero if available, or zero if not.
+ */
+static inline int snd_pcm_playback_ready(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return snd_pcm_playback_avail(runtime) >= runtime->control->avail_min;
+}
+
+/**
+ * snd_pcm_capture_ready - check whether the capture buffer is available
+ * @substream: the pcm substream instance
+ *
+ * Checks whether enough capture data is available on the capture buffer.
+ *
+ * Returns non-zero if available, or zero if not.
+ */
+static inline int snd_pcm_capture_ready(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return snd_pcm_capture_avail(runtime) >= runtime->control->avail_min;
+}
+
+/**
+ * snd_pcm_playback_data - check whether any data exists on the playback buffer
+ * @substream: the pcm substream instance
+ *
+ * Checks whether any data exists on the playback buffer. If stop_threshold
+ * is bigger or equal to boundary, then this function returns always non-zero.
+ *
+ * Returns non-zero if exists, or zero if not.
+ */
+static inline int snd_pcm_playback_data(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	
+	if (runtime->stop_threshold >= runtime->boundary)
+		return 1;
+	return snd_pcm_playback_avail(runtime) < runtime->buffer_size;
+}
+
+/**
+ * snd_pcm_playback_empty - check whether the playback buffer is empty
+ * @substream: the pcm substream instance
+ *
+ * Checks whether the playback buffer is empty.
+ *
+ * Returns non-zero if empty, or zero if not.
+ */
+static inline int snd_pcm_playback_empty(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return snd_pcm_playback_avail(runtime) >= runtime->buffer_size;
+}
+
+/**
+ * snd_pcm_capture_empty - check whether the capture buffer is empty
+ * @substream: the pcm substream instance
+ *
+ * Checks whether the capture buffer is empty.
+ *
+ * Returns non-zero if empty, or zero if not.
+ */
+static inline int snd_pcm_capture_empty(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return snd_pcm_capture_avail(runtime) == 0;
+}
+
 static inline void snd_pcm_trigger_done(snd_pcm_substream_t *substream, 
 					snd_pcm_substream_t *master)
 {
@@ -772,13 +842,9 @@
 void snd_interval_mulkdiv(const snd_interval_t *a, unsigned int k,
 			  const snd_interval_t *b, snd_interval_t *c);
 int snd_interval_list(snd_interval_t *i, unsigned int count, unsigned int *list, unsigned int mask);
-int snd_interval_step(snd_interval_t *i, unsigned int min, unsigned int step);
 int snd_interval_ratnum(snd_interval_t *i,
 			unsigned int rats_count, ratnum_t *rats,
 			unsigned int *nump, unsigned int *denp);
-int snd_interval_ratden(snd_interval_t *i,
-			unsigned int rats_count, ratden_t *rats,
-			unsigned int *nump, unsigned int *denp);
 
 void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params);
 void _snd_pcm_hw_param_setempty(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var);
@@ -810,6 +876,7 @@
 int snd_pcm_hw_params_choose(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
 
 int snd_pcm_hw_refine(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
+int snd_pcm_hw_params(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
 
 int snd_pcm_hw_constraints_init(snd_pcm_substream_t *substream);
 int snd_pcm_hw_constraints_complete(snd_pcm_substream_t *substream);
@@ -860,9 +927,7 @@
 const unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);
 int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
 snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian);
-ssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples);
 const char *snd_pcm_format_name(snd_pcm_format_t format);
-const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat);
 
 void snd_pcm_set_ops(snd_pcm_t * pcm, int direction, snd_pcm_ops_t *ops);
 void snd_pcm_set_sync(snd_pcm_substream_t * substream);
@@ -875,13 +940,6 @@
 int snd_pcm_playback_xrun_asap(snd_pcm_substream_t *substream);
 int snd_pcm_capture_xrun_asap(snd_pcm_substream_t *substream);
 void snd_pcm_playback_silence(snd_pcm_substream_t *substream, snd_pcm_uframes_t new_hw_ptr);
-int snd_pcm_playback_ready(snd_pcm_substream_t *substream);
-int snd_pcm_capture_ready(snd_pcm_substream_t *substream);
-long snd_pcm_playback_ready_jiffies(snd_pcm_substream_t *substream);
-long snd_pcm_capture_ready_jiffies(snd_pcm_substream_t *substream);
-int snd_pcm_playback_data(snd_pcm_substream_t *substream);
-int snd_pcm_playback_empty(snd_pcm_substream_t *substream);
-int snd_pcm_capture_empty(snd_pcm_substream_t *substream);
 void snd_pcm_tick_prepare(snd_pcm_substream_t *substream);
 void snd_pcm_tick_set(snd_pcm_substream_t *substream, unsigned long ticks);
 void snd_pcm_tick_elapsed(snd_pcm_substream_t *substream);
diff -uNr a/include/sound/rawmidi.h b/include/sound/rawmidi.h
--- a/include/sound/rawmidi.h	2004-12-24 22:35:24.000000000 +0100
+++ b/include/sound/rawmidi.h	2005-01-14 22:28:11.557601408 +0100
@@ -152,13 +152,6 @@
 		    snd_rawmidi_t ** rmidi);
 void snd_rawmidi_set_ops(snd_rawmidi_t * rmidi, int stream, snd_rawmidi_ops_t * ops);
 
-/* control functions */
-
-int snd_rawmidi_control_ioctl(snd_card_t * card,
-			      snd_ctl_file_t * control,
-			      unsigned int cmd,
-			      unsigned long arg);
-
 /* callbacks */
 
 void snd_rawmidi_receive_reset(snd_rawmidi_substream_t * substream);
diff -uNr a/include/sound/sb.h b/include/sound/sb.h
--- a/include/sound/sb.h	2004-12-24 22:34:44.000000000 +0100
+++ b/include/sound/sb.h	2005-01-14 22:28:11.559601104 +0100
@@ -311,10 +311,6 @@
 int snd_sb16dsp_configure(sb_t *chip);
 /* sb16.c */
 irqreturn_t snd_sb16dsp_interrupt(int irq, void *dev_id, struct pt_regs *regs);
-int snd_sb16_playback_open(snd_pcm_substream_t *substream);
-int snd_sb16_capture_open(snd_pcm_substream_t *substream);
-int snd_sb16_playback_close(snd_pcm_substream_t *substream);
-int snd_sb16_capture_close(snd_pcm_substream_t *substream);
 
 /* exported mixer stuffs */
 enum {
diff -uNr a/include/sound/seq_midi_emul.h b/include/sound/seq_midi_emul.h
--- a/include/sound/seq_midi_emul.h	2004-12-24 22:35:23.000000000 +0100
+++ b/include/sound/seq_midi_emul.h	2005-01-14 22:28:11.561600800 +0100
@@ -189,8 +189,6 @@
 void snd_midi_process_event(snd_midi_op_t *ops, snd_seq_event_t *ev,
 			    snd_midi_channel_set_t *chanset);
 void snd_midi_channel_set_clear(snd_midi_channel_set_t *chset);
-void snd_midi_channel_init(snd_midi_channel_t *p, int n);
-snd_midi_channel_t *snd_midi_channel_init_set(int n);
 snd_midi_channel_set_t *snd_midi_channel_alloc_set(int n);
 void snd_midi_channel_free_set(snd_midi_channel_set_t *chset);
 
diff -uNr a/include/sound/snd_wavefront.h b/include/sound/snd_wavefront.h
--- a/include/sound/snd_wavefront.h	2004-12-24 22:34:01.000000000 +0100
+++ b/include/sound/snd_wavefront.h	2005-01-14 22:28:11.563600496 +0100
@@ -107,7 +107,6 @@
 };
 
 extern void snd_wavefront_internal_interrupt (snd_wavefront_card_t *card);
-extern int  snd_wavefront_interrupt_bits (int irq);
 extern int  snd_wavefront_detect_irq (snd_wavefront_t *dev) ;
 extern int  snd_wavefront_check_irq (snd_wavefront_t *dev, int irq);
 extern int  snd_wavefront_restart (snd_wavefront_t *dev);
diff -uNr a/include/sound/soundfont.h b/include/sound/soundfont.h
--- a/include/sound/soundfont.h	2004-12-24 22:35:40.000000000 +0100
+++ b/include/sound/soundfont.h	2005-01-14 22:28:11.567599888 +0100
@@ -112,7 +112,6 @@
 
 int snd_soundfont_remove_samples(snd_sf_list_t *sflist);
 int snd_soundfont_remove_unlocked(snd_sf_list_t *sflist);
-int snd_soundfont_mem_used(snd_sf_list_t *sflist);
 
 int snd_soundfont_search_zone(snd_sf_list_t *sflist, int *notep, int vel,
 			      int preset, int bank,
diff -uNr a/include/sound/soundmem.h b/include/sound/soundmem.h
--- a/include/sound/soundmem.h	2004-12-24 22:33:48.000000000 +0100
+++ b/include/sound/soundmem.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-/*
- *  Onboard memory management
- */
-
-struct SNDRV_STRU_BANK_INFO {
-	unsigned int address;
-	unsigned int size;
-};
diff -uNr a/include/sound/trident.h b/include/sound/trident.h
--- a/include/sound/trident.h	2004-12-24 22:34:58.000000000 +0100
+++ b/include/sound/trident.h	2005-01-14 22:28:11.588596696 +0100
@@ -457,27 +457,23 @@
 		       int pcm_spdif_device,
 		       int max_wavetable_size,
 		       trident_t ** rtrident);
-int snd_trident_free(trident_t *trident);
 void snd_trident_gameport(trident_t *trident);
 
 int snd_trident_pcm(trident_t * trident, int device, snd_pcm_t **rpcm);
 int snd_trident_foldback_pcm(trident_t * trident, int device, snd_pcm_t **rpcm);
 int snd_trident_spdif_pcm(trident_t * trident, int device, snd_pcm_t **rpcm);
 int snd_trident_attach_synthesizer(trident_t * trident);
-int snd_trident_detach_synthesizer(trident_t * trident);
 snd_trident_voice_t *snd_trident_alloc_voice(trident_t * trident, int type, int client, int port);
 void snd_trident_free_voice(trident_t * trident, snd_trident_voice_t *voice);
 void snd_trident_start_voice(trident_t * trident, unsigned int voice);
 void snd_trident_stop_voice(trident_t * trident, unsigned int voice);
 void snd_trident_write_voice_regs(trident_t * trident, snd_trident_voice_t *voice);
-void snd_trident_clear_voices(trident_t * trident, unsigned short v_min, unsigned short v_max);
 
 /* TLB memory allocation */
 snd_util_memblk_t *snd_trident_alloc_pages(trident_t *trident, snd_pcm_substream_t *substream);
 int snd_trident_free_pages(trident_t *trident, snd_util_memblk_t *blk);
 snd_util_memblk_t *snd_trident_synth_alloc(trident_t *trident, unsigned int size);
 int snd_trident_synth_free(trident_t *trident, snd_util_memblk_t *blk);
-int snd_trident_synth_bzero(trident_t *trident, snd_util_memblk_t *blk, int offset, int size);
 int snd_trident_synth_copy_from_user(trident_t *trident, snd_util_memblk_t *blk, int offset, const char __user *data, int size);
 
 #endif /* __SOUND_TRIDENT_H */
diff -uNr a/include/sound/version.h b/include/sound/version.h
--- a/include/sound/version.h	2004-12-24 22:35:50.000000000 +0100
+++ b/include/sound/version.h	2005-01-14 22:28:25.635461248 +0100
@@ -1,3 +1,3 @@
 /* include/version.h.  Generated by configure.  */
-#define CONFIG_SND_VERSION "1.0.6"
-#define CONFIG_SND_DATE " (Sun Aug 15 07:17:53 2004 UTC)"
+#define CONFIG_SND_VERSION "1.0.8"
+#define CONFIG_SND_DATE " (Thu Jan 13 09:39:32 2005 UTC)"
diff -uNr a/include/sound/vx_core.h b/include/sound/vx_core.h
--- a/include/sound/vx_core.h	2004-12-24 22:33:50.000000000 +0100
+++ b/include/sound/vx_core.h	2005-01-14 22:28:11.594595784 +0100
@@ -27,6 +27,15 @@
 #include <sound/hwdep.h>
 #include <linux/interrupt.h>
 
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+#if !defined(CONFIG_USE_VXLOADER) && !defined(CONFIG_SND_VX_LIB) /* built-in kernel */
+#define SND_VX_FW_LOADER	/* use the standard firmware loader */
+#endif
+#endif
+
+struct firmware;
+struct device;
+
 typedef struct snd_vx_core vx_core_t;
 typedef struct vx_pipe vx_pipe_t;
 
@@ -100,7 +109,7 @@
 	void (*change_audio_source)(vx_core_t *chip, int src);
 	void (*set_clock_source)(vx_core_t *chp, int src);
 	/* chip init */
-	int (*load_dsp)(vx_core_t *chip, const snd_hwdep_dsp_image_t *dsp);
+	int (*load_dsp)(vx_core_t *chip, int idx, const struct firmware *fw);
 	void (*reset_dsp)(vx_core_t *chip);
 	void (*reset_board)(vx_core_t *chip, int cold_reset);
 	int (*add_controls)(vx_core_t *chip);
@@ -169,6 +178,7 @@
 	unsigned int chip_status;
 	unsigned int pcm_running;
 
+	struct device *dev;
 	snd_hwdep_t *hwdep;
 
 	struct vx_rmh irq_rmh;	/* RMH used in interrupts */
@@ -198,6 +208,8 @@
 	unsigned char audio_monitor_active[4];	/* playback hw-monitor mute/unmute */
 
 	struct semaphore mixer_mutex;
+
+	const struct firmware *firmware[4]; /* loaded firmware data */
 };
 
 
@@ -206,10 +218,12 @@
  */
 vx_core_t *snd_vx_create(snd_card_t *card, struct snd_vx_hardware *hw,
 			 struct snd_vx_ops *ops, int extra_size);
-int snd_vx_hwdep_new(vx_core_t *chip);
-int snd_vx_load_boot_image(vx_core_t *chip, const snd_hwdep_dsp_image_t *boot);
-int snd_vx_dsp_boot(vx_core_t *chip, const snd_hwdep_dsp_image_t *boot);
-int snd_vx_dsp_load(vx_core_t *chip, const snd_hwdep_dsp_image_t *dsp);
+int snd_vx_setup_firmware(vx_core_t *chip);
+int snd_vx_load_boot_image(vx_core_t *chip, const struct firmware *dsp);
+int snd_vx_dsp_boot(vx_core_t *chip, const struct firmware *dsp);
+int snd_vx_dsp_load(vx_core_t *chip, const struct firmware *dsp);
+
+void snd_vx_free_firmware(vx_core_t *chip);
 
 /*
  * interrupt handler; exported for pcmcia
@@ -217,15 +231,6 @@
 irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs);
 
 /*
- * power-management routines
- */
-#ifdef CONFIG_PM
-void snd_vx_suspend(vx_core_t *chip);
-void snd_vx_resume(vx_core_t *chip);
-#endif
-
-
-/*
  * lowlevel functions
  */
 inline static int vx_test_and_ack(vx_core_t *chip)
@@ -340,7 +345,6 @@
  */
 void vx_set_iec958_status(vx_core_t *chip, unsigned int bits);
 int vx_set_clock(vx_core_t *chip, unsigned int freq);
-void vx_change_clock_source(vx_core_t *chip, int source);
 void vx_set_internal_clock(vx_core_t *chip, unsigned int freq);
 int vx_change_frequency(vx_core_t *chip);
 
diff -uNr a/include/sound/ymfpci.h b/include/sound/ymfpci.h
--- a/include/sound/ymfpci.h	2004-12-24 22:34:31.000000000 +0100
+++ b/include/sound/ymfpci.h	2005-01-14 22:28:11.597595328 +0100
@@ -389,9 +389,6 @@
 int snd_ymfpci_mixer(ymfpci_t *chip, int rear_switch);
 int snd_ymfpci_timer(ymfpci_t *chip, int device);
 
-int snd_ymfpci_voice_alloc(ymfpci_t *chip, ymfpci_voice_type_t type, int pair, ymfpci_voice_t **rvoice);
-int snd_ymfpci_voice_free(ymfpci_t *chip, ymfpci_voice_t *pvoice);
-
 #if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
 #define SUPPORT_JOYSTICK
 #endif
diff -uNr a/sound/arm/sa11xx-uda1341.c b/sound/arm/sa11xx-uda1341.c
--- a/sound/arm/sa11xx-uda1341.c	2004-12-24 22:33:50.000000000 +0100
+++ b/sound/arm/sa11xx-uda1341.c	2005-01-14 22:28:11.602594568 +0100
@@ -21,7 +21,7 @@
  *                              merged HAL layer (patches from Brian)
  */
 
-/* $Id$ */
+/* $Id$ */
 
 /***************************************************************************************************
 *
@@ -875,7 +875,6 @@
 #endif
 	l3_command(chip->uda1341, CMD_SUSPEND, NULL);
 	sa11xx_uda1341_audio_shutdown(chip);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -891,7 +890,6 @@
 #else
 	//FIXME
 #endif
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* COMFIG_PM */
diff -uNr a/sound/core/control.c b/sound/core/control.c
--- a/sound/core/control.c	2004-12-24 22:34:01.000000000 +0100
+++ b/sound/core/control.c	2005-01-14 22:28:11.608593656 +0100
@@ -31,6 +31,9 @@
 #include <sound/info.h>
 #include <sound/control.h>
 
+/* max number of user-defined controls */
+#define MAX_USER_CONTROLS	32
+
 typedef struct _snd_kctl_ioctl {
 	struct list_head list;		/* list of all ioctls */
 	snd_kctl_ioctl_func_t fioctl;
@@ -635,19 +638,13 @@
 	return result;
 }
 
-static int snd_ctl_elem_read(snd_card_t *card, snd_ctl_elem_value_t __user *_control)
+int snd_ctl_elem_read(snd_card_t *card, snd_ctl_elem_value_t *control)
 {
-	snd_ctl_elem_value_t *control;
 	snd_kcontrol_t *kctl;
 	snd_kcontrol_volatile_t *vd;
 	unsigned int index_offset;
 	int result, indirect;
-	
-	control = kmalloc(sizeof(*control), GFP_KERNEL);
-	if (control == NULL)
-		return -ENOMEM;	
-	if (copy_from_user(control, _control, sizeof(*control)))
-		return -EFAULT;
+
 	down_read(&card->controls_rwsem);
 	kctl = snd_ctl_find_id(card, &control->id);
 	if (kctl == NULL) {
@@ -668,27 +665,36 @@
 		}
 	}
 	up_read(&card->controls_rwsem);
+	return result;
+}
+
+static int snd_ctl_elem_read_user(snd_card_t *card, snd_ctl_elem_value_t __user *_control)
+{
+	snd_ctl_elem_value_t *control;
+	int result;
+	
+	control = kmalloc(sizeof(*control), GFP_KERNEL);
+	if (control == NULL)
+		return -ENOMEM;	
+	if (copy_from_user(control, _control, sizeof(*control))) {
+		kfree(control);
+		return -EFAULT;
+	}
+	result = snd_ctl_elem_read(card, control);
 	if (result >= 0)
 		if (copy_to_user(_control, control, sizeof(*control)))
-			return -EFAULT;
+			result = -EFAULT;
 	kfree(control);
 	return result;
 }
 
-static int snd_ctl_elem_write(snd_ctl_file_t *file, snd_ctl_elem_value_t __user *_control)
+int snd_ctl_elem_write(snd_card_t *card, snd_ctl_file_t *file, snd_ctl_elem_value_t *control)
 {
-	snd_card_t *card = file->card;
-	snd_ctl_elem_value_t *control;
 	snd_kcontrol_t *kctl;
 	snd_kcontrol_volatile_t *vd;
 	unsigned int index_offset;
 	int result, indirect;
 
-	control = kmalloc(sizeof(*control), GFP_KERNEL);
-	if (control == NULL)
-		return -ENOMEM;	
-	if (copy_from_user(control, _control, sizeof(*control)))
-		return -EFAULT;
 	down_read(&card->controls_rwsem);
 	kctl = snd_ctl_find_id(card, &control->id);
 	if (kctl == NULL) {
@@ -702,7 +708,7 @@
 		} else {
 			if (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||
 			    kctl->put == NULL ||
-			    (vd->owner != NULL && vd->owner != file)) {
+			    (file && vd->owner != NULL && vd->owner != file)) {
 				result = -EPERM;
 			} else {
 				snd_ctl_build_ioff(&control->id, kctl, index_offset);
@@ -711,16 +717,30 @@
 			if (result > 0) {
 				up_read(&card->controls_rwsem);
 				snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &control->id);
-				result = 0;
-				goto __unlocked;
+				return 0;
 			}
 		}
 	}
 	up_read(&card->controls_rwsem);
-      __unlocked:
+	return result;
+}
+
+static int snd_ctl_elem_write_user(snd_ctl_file_t *file, snd_ctl_elem_value_t __user *_control)
+{
+	snd_ctl_elem_value_t *control;
+	int result;
+
+	control = kmalloc(sizeof(*control), GFP_KERNEL);
+	if (control == NULL)
+		return -ENOMEM;	
+	if (copy_from_user(control, _control, sizeof(*control))) {
+		kfree(control);
+		return -EFAULT;
+	}
+	result = snd_ctl_elem_write(file->card, file, control);
 	if (result >= 0)
 		if (copy_to_user(_control, control, sizeof(*control)))
-			return -EFAULT;
+			result = -EFAULT;
 	kfree(control);
 	return result;
 }
@@ -784,30 +804,21 @@
 }
 
 struct user_element {
-	enum sndrv_ctl_elem_type type;	/* element type */
-	unsigned int elem_count;	/* count of elements */
-	union {
-		struct {
-			unsigned int items;
-		} enumerated;
-	} u;
+	snd_ctl_elem_info_t info;
 	void *elem_data;		/* element data */
 	unsigned long elem_data_size;	/* size of element data in bytes */
 	void *priv_data;		/* private data (like strings for enumerated type) */
 	unsigned long priv_data_size;	/* size of private data in bytes */
-	unsigned short dimen_count;	/* count of dimensions */
-	unsigned short dimen[0];	/* array of dimensions */
 };
 
 static int snd_ctl_elem_user_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
 {
 	struct user_element *ue = kcontrol->private_data;
 
-	uinfo->type = ue->type;
-	uinfo->count = ue->elem_count;
-	if (ue->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
-		uinfo->value.enumerated.items = ue->u.enumerated.items;
-		if (uinfo->value.enumerated.item >= ue->u.enumerated.items)
+	*uinfo = ue->info;
+	if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+		uinfo->value.enumerated.items = ue->info.value.enumerated.items;
+		if (uinfo->value.enumerated.item >= ue->info.value.enumerated.items)
 			uinfo->value.enumerated.item = 0;
 		strlcpy(uinfo->value.enumerated.name,
 			(char *)ue->priv_data + uinfo->value.enumerated.item * 64,
@@ -829,9 +840,10 @@
 	int change;
 	struct user_element *ue = kcontrol->private_data;
 	
-	change = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size);
-	memcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);
-	return !!change;
+	change = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;
+	if (change)
+		memcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);
+	return change;
 }
 
 static void snd_ctl_elem_user_free(snd_kcontrol_t * kcontrol)
@@ -845,34 +857,35 @@
 	snd_ctl_elem_info_t info;
 	snd_kcontrol_t kctl, *_kctl;
 	unsigned int access;
-	long private_size, dimen_size, extra_size;
+	long private_size, extra_size;
 	struct user_element *ue;
 	int idx, err;
 	
+	if (card->user_ctl_count >= MAX_USER_CONTROLS)
+		return -ENOMEM;
 	if (copy_from_user(&info, _info, sizeof(info)))
 		return -EFAULT;
 	if (info.count > 1024)
 		return -EINVAL;
 	access = info.access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
-		 (info.access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|SNDRV_CTL_ELEM_ACCESS_INACTIVE|
-		 		 SNDRV_CTL_ELEM_ACCESS_DINDIRECT|SNDRV_CTL_ELEM_ACCESS_INDIRECT));
-	if (access & (SNDRV_CTL_ELEM_ACCESS_DINDIRECT | SNDRV_CTL_ELEM_ACCESS_INDIRECT))
-		return -EINVAL;
+		(info.access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|SNDRV_CTL_ELEM_ACCESS_INACTIVE));
 	info.id.numid = 0;
 	memset(&kctl, 0, sizeof(kctl));
 	down_write(&card->controls_rwsem);
-	if (!!((_kctl = snd_ctl_find_id(card, &info.id)) != NULL) ^ replace) {
-		up_write(&card->controls_rwsem);
-		return !replace ? -EBUSY : -ENOENT;
-	}
-	if (replace) {
-		err = snd_ctl_remove(card, _kctl);
-		if (err < 0) {
-			up_write(&card->controls_rwsem);
-			return err;
-		}
+	_kctl = snd_ctl_find_id(card, &info.id);
+	err = 0;
+	if (_kctl) {
+		if (replace)
+			err = snd_ctl_remove(card, _kctl);
+		else
+			err = -EBUSY;
+	} else {
+		if (replace)
+			err = -ENOENT;
 	}
 	up_write(&card->controls_rwsem);
+	if (err < 0)
+		return err;
 	memcpy(&kctl.id, &info.id, sizeof(info.id));
 	kctl.count = info.owner ? info.owner : 1;
 	access |= SNDRV_CTL_ELEM_ACCESS_USER;
@@ -902,7 +915,7 @@
 		private_size = sizeof(unsigned int);
 		if (info.count > 128)
 			return -EINVAL;
-		if (info.value.enumerated.items > 1024)
+		if (info.value.enumerated.items > 128)
 			return -EINVAL;
 		extra_size = info.value.enumerated.items * 64;
 		break;
@@ -920,31 +933,18 @@
 		return -EINVAL;
 	}
 	private_size *= info.count;
-	if (private_size > 1024 * 1024)
-		return -EINVAL;
-	dimen_size = 0;
-	if (!(info.access & SNDRV_CTL_ELEM_ACCESS_DINDIRECT))
-		for (idx = 0; idx < 4 && info.dimen.d[idx]; idx++)
-			dimen_size += sizeof(unsigned short);
-	ue = kcalloc(1, sizeof(struct user_element) + dimen_size + private_size + extra_size, GFP_KERNEL);
+	ue = kcalloc(1, sizeof(struct user_element) + private_size + extra_size, GFP_KERNEL);
 	if (ue == NULL)
 		return -ENOMEM;
-	ue->type = info.type;
-	ue->elem_count = info.count;
-	if (!(info.access & SNDRV_CTL_ELEM_ACCESS_DINDIRECT)) {
-		for (idx = 0; idx < 4 && info.dimen.d[idx]; idx++)
-			ue->dimen[idx] = info.dimen.d[idx];
-		ue->dimen_count = dimen_size / sizeof(unsigned short);
-	}
-	ue->elem_data = (char *)ue + sizeof(ue) + dimen_size;
+	ue->info = info;
+	ue->elem_data = (char *)ue + sizeof(ue);
 	ue->elem_data_size = private_size;
 	if (extra_size) {
-		ue->priv_data = (char *)ue + sizeof(ue) + dimen_size + private_size;
+		ue->priv_data = (char *)ue + sizeof(ue) + private_size;
 		ue->priv_data_size = extra_size;
-		if (ue->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
-			if (copy_from_user(ue->priv_data, *(char **)info.value.enumerated.name, extra_size))
+		if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+			if (copy_from_user(ue->priv_data, *(char __user **)info.value.enumerated.name, extra_size))
 				return -EFAULT;
-			ue->u.enumerated.items = info.value.enumerated.items;
 		}
 	}
 	kctl.private_free = snd_ctl_elem_user_free;
@@ -961,16 +961,29 @@
 		snd_ctl_free_one(_kctl);
 		return err;
 	}
+
+	down_write(&card->controls_rwsem);
+	card->user_ctl_count++;
+	up_write(&card->controls_rwsem);
+
 	return 0;
 }
 
 static int snd_ctl_elem_remove(snd_ctl_file_t *file, snd_ctl_elem_id_t __user *_id)
 {
 	snd_ctl_elem_id_t id;
+	int err;
 
 	if (copy_from_user(&id, _id, sizeof(id)))
 		return -EFAULT;
-	return snd_ctl_remove_unlocked_id(file, &id);
+	err = snd_ctl_remove_unlocked_id(file, &id);
+	if (! err) {
+		snd_card_t *card = file->card;
+		down_write(&card->controls_rwsem);
+		card->user_ctl_count--;
+		up_write(&card->controls_rwsem);
+	}
+	return err;
 }
 
 static int snd_ctl_subscribe_events(snd_ctl_file_t *file, int __user *ptr)
@@ -1002,18 +1015,23 @@
 {
 	switch (power_state) {
 	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		if (card->power_state != power_state)
+		if (card->power_state != power_state) {
 			/* FIXME: pass the correct state value */
 			card->pm_resume(card, 0);
+			snd_power_change_state(card, power_state);
+		}
 		break;
 	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		if (card->power_state != power_state)
+		if (card->power_state != power_state) {
 			/* FIXME: pass the correct state value */
 			card->pm_suspend(card, 0);
+			snd_power_change_state(card, power_state);
+		}
 		break;
+	case SNDRV_CTL_POWER_D1:
+	case SNDRV_CTL_POWER_D2:
+	case SNDRV_CTL_POWER_D3cold:
+		/* not supported yet */
 	default:
 		return -EINVAL;
 	}
@@ -1045,9 +1063,9 @@
 	case SNDRV_CTL_IOCTL_ELEM_INFO:
 		return snd_ctl_elem_info(ctl, argp);
 	case SNDRV_CTL_IOCTL_ELEM_READ:
-		return snd_ctl_elem_read(ctl->card, argp);
+		return snd_ctl_elem_read_user(ctl->card, argp);
 	case SNDRV_CTL_IOCTL_ELEM_WRITE:
-		return snd_ctl_elem_write(ctl, argp);
+		return snd_ctl_elem_write_user(ctl, argp);
 	case SNDRV_CTL_IOCTL_ELEM_LOCK:
 		return snd_ctl_elem_lock(ctl, argp);
 	case SNDRV_CTL_IOCTL_ELEM_UNLOCK:
@@ -1252,11 +1270,11 @@
 };
 
 /*
- * registration of the control device:
- * called from init.c
+ * registration of the control device
  */
-int snd_ctl_register(snd_card_t *card)
+static int snd_ctl_dev_register(snd_device_t *device)
 {
+	snd_card_t *card = device->device_data;
 	int err, cardnum;
 	char name[16];
 
@@ -1271,11 +1289,11 @@
 }
 
 /*
- * disconnection of the control device:
- * called from init.c
+ * disconnection of the control device
  */
-int snd_ctl_disconnect(snd_card_t *card)
+static int snd_ctl_dev_disconnect(snd_device_t *device)
 {
+	snd_card_t *card = device->device_data;
 	struct list_head *flist;
 	snd_ctl_file_t *ctl;
 
@@ -1290,19 +1308,13 @@
 }
 
 /*
- * de-registration of the control device:
- * called from init.c
+ * free all controls
  */
-int snd_ctl_unregister(snd_card_t *card)
+static int snd_ctl_dev_free(snd_device_t *device)
 {
-	int err, cardnum;
+	snd_card_t *card = device->device_data;
 	snd_kcontrol_t *control;
 
-	snd_assert(card != NULL, return -ENXIO);
-	cardnum = card->number;
-	snd_assert(cardnum >= 0 && cardnum < SNDRV_CARDS, return -ENXIO);
-	if ((err = snd_unregister_device(SNDRV_DEVICE_TYPE_CONTROL, card, 0)) < 0)
-		return err;
 	down_write(&card->controls_rwsem);
 	while (!list_empty(&card->controls)) {
 		control = snd_kcontrol(card->controls.next);
@@ -1311,3 +1323,36 @@
 	up_write(&card->controls_rwsem);
 	return 0;
 }
+
+/*
+ * de-registration of the control device
+ */
+static int snd_ctl_dev_unregister(snd_device_t *device)
+{
+	snd_card_t *card = device->device_data;
+	int err, cardnum;
+
+	snd_assert(card != NULL, return -ENXIO);
+	cardnum = card->number;
+	snd_assert(cardnum >= 0 && cardnum < SNDRV_CARDS, return -ENXIO);
+	if ((err = snd_unregister_device(SNDRV_DEVICE_TYPE_CONTROL, card, 0)) < 0)
+		return err;
+	return snd_ctl_dev_free(device);
+}
+
+/*
+ * create control core:
+ * called from init.c
+ */
+int snd_ctl_create(snd_card_t *card)
+{
+	static snd_device_ops_t ops = {
+		.dev_free = snd_ctl_dev_free,
+		.dev_register =	snd_ctl_dev_register,
+		.dev_disconnect = snd_ctl_dev_disconnect,
+		.dev_unregister = snd_ctl_dev_unregister
+	};
+
+	snd_assert(card != NULL, return -ENXIO);
+	return snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);
+}
diff -uNr a/sound/core/hwdep.c b/sound/core/hwdep.c
--- a/sound/core/hwdep.c	2004-12-24 22:33:50.000000000 +0100
+++ b/sound/core/hwdep.c	2005-01-14 22:28:11.611593200 +0100
@@ -35,7 +35,7 @@
 MODULE_DESCRIPTION("Hardware dependent layer");
 MODULE_LICENSE("GPL");
 
-snd_hwdep_t *snd_hwdep_devices[SNDRV_CARDS * SNDRV_MINOR_HWDEPS];
+static snd_hwdep_t *snd_hwdep_devices[SNDRV_CARDS * SNDRV_MINOR_HWDEPS];
 
 static DECLARE_MUTEX(register_mutex);
 
diff -uNr a/sound/core/info.c b/sound/core/info.c
--- a/sound/core/info.c	2004-12-24 22:35:39.000000000 +0100
+++ b/sound/core/info.c	2005-01-14 22:28:11.614592744 +0100
@@ -20,18 +20,14 @@
  */
 
 #include <sound/driver.h>
-#include <linux/version.h>
 #include <linux/init.h>
 #include <linux/vmalloc.h>
 #include <linux/time.h>
 #include <linux/smp_lock.h>
-#include <linux/utsname.h>
-#include <linux/config.h>
-
 #include <sound/core.h>
-#include <sound/version.h>
 #include <sound/minors.h>
 #include <sound/info.h>
+#include <sound/version.h>
 #include <linux/proc_fs.h>
 #include <linux/devfs_fs_kernel.h>
 #include <stdarg.h>
@@ -129,8 +125,8 @@
 	de->owner = THIS_MODULE;
 }
 
-void snd_remove_proc_entry(struct proc_dir_entry *parent,
-			   struct proc_dir_entry *de)
+static void snd_remove_proc_entry(struct proc_dir_entry *parent,
+				  struct proc_dir_entry *de)
 {
 	if (de)
 		remove_proc_entry(de->name, parent);
@@ -525,8 +521,8 @@
  *
  * Returns the pointer of new instance or NULL on failure.
  */
-struct proc_dir_entry *snd_create_proc_entry(const char *name, mode_t mode,
-					     struct proc_dir_entry *parent)
+static struct proc_dir_entry *snd_create_proc_entry(const char *name, mode_t mode,
+						    struct proc_dir_entry *parent)
 {
 	struct proc_dir_entry *p;
 	p = create_proc_entry(name, mode, parent);
@@ -895,8 +891,7 @@
 {
 	if (entry == NULL)
 		return;
-	if (entry->name)
-		kfree((char *)entry->name);
+	kfree(entry->name);
 	if (entry->private_free)
 		entry->private_free(entry);
 	kfree(entry);
@@ -962,18 +957,10 @@
 
 static void snd_info_version_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
 {
-	static char *kernel_version = system_utsname.release;
-
 	snd_iprintf(buffer,
-		    "Advanced Linux Sound Architecture Driver Version " CONFIG_SND_VERSION CONFIG_SND_DATE ".\n"
-		    "Compiled on " __DATE__ " for kernel %s"
-#ifdef CONFIG_SMP
-		    " (SMP)"
-#endif
-#ifdef MODVERSIONS
-		    " with versioned symbols"
-#endif
-		    ".\n", kernel_version);
+		    "Advanced Linux Sound Architecture Driver Version "
+		    CONFIG_SND_VERSION CONFIG_SND_DATE ".\n"
+		   );
 }
 
 static int __init snd_info_version_init(void)
diff -uNr a/sound/core/init.c b/sound/core/init.c
--- a/sound/core/init.c	2004-12-24 22:34:02.000000000 +0100
+++ b/sound/core/init.c	2005-01-14 22:28:11.619591984 +0100
@@ -37,7 +37,6 @@
 	struct snd_shutdown_f_ops *next;
 };
 
-int snd_cards_count = 0;
 unsigned int snd_cards_lock = 0;	/* locked for registering/using */
 snd_card_t *snd_cards[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = NULL};
 rwlock_t snd_card_rwlock = RW_LOCK_UNLOCKED;
@@ -125,7 +124,7 @@
 #endif
 	/* the control interface cannot be accessed from the user space until */
 	/* snd_cards_bitmask and snd_cards are set with snd_card_register */
-	if ((err = snd_ctl_register(card)) < 0) {
+	if ((err = snd_ctl_create(card)) < 0) {
 		snd_printd("unable to register control minors\n");
 		goto __error;
 	}
@@ -138,7 +137,7 @@
 	return card;
 
       __error_ctl:
-	snd_ctl_unregister(card);
+	snd_device_free_all(card, SNDRV_DEV_CMD_PRE);
       __error:
 	kfree(card);
       	return NULL;
@@ -217,8 +216,6 @@
 	/* phase 3: notify all connected devices about disconnection */
 	/* at this point, they cannot respond to any calls except release() */
 
-	snd_ctl_disconnect(card);
-
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);
@@ -251,7 +248,6 @@
 		return -EINVAL;
 	write_lock(&snd_card_rwlock);
 	snd_cards[card->number] = NULL;
-	snd_cards_count--;
 	write_unlock(&snd_card_rwlock);
 
 #ifdef CONFIG_PM
@@ -279,10 +275,6 @@
 		snd_printk(KERN_ERR "unable to free all devices (normal)\n");
 		/* Fatal, but this situation should never occur */
 	}
-	if (snd_ctl_unregister(card) < 0) {
-		snd_printk(KERN_ERR "unable to unregister control minors\n");
-		/* Not fatal error */
-	}
 	if (snd_device_free_all(card, SNDRV_DEV_CMD_POST) < 0) {
 		snd_printk(KERN_ERR "unable to free all devices (post)\n");
 		/* Fatal, but this situation should never occur */
@@ -441,7 +433,6 @@
 	if (card->id[0] == '\0')
 		choose_default_id(card);
 	snd_cards[card->number] = card;
-	snd_cards_count++;
 	write_unlock(&snd_card_rwlock);
 	if ((err = snd_info_card_register(card)) < 0) {
 		snd_printd("unable to create card info\n");
@@ -665,12 +656,11 @@
 	spin_unlock(&card->files_lock);
 	if (card->files == NULL)
 		wake_up(&card->shutdown_sleep);
-	if (mfile) {
-		kfree(mfile);
-	} else {
+	if (!mfile) {
 		snd_printk(KERN_ERR "ALSA card file remove problem (%p)\n", file);
 		return -ENOENT;
 	}
+	kfree(mfile);
 	return 0;
 }
 
@@ -745,12 +735,18 @@
 
 	switch (rqst) {
 	case PM_SUSPEND:
+		if (card->power_state == SNDRV_CTL_POWER_D3hot)
+			break;
 		/* FIXME: the correct state value? */
 		card->pm_suspend(card, 0);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 		break;
 	case PM_RESUME:
+		if (card->power_state == SNDRV_CTL_POWER_D0)
+			break;
 		/* FIXME: the correct state value? */
 		card->pm_resume(card, 0);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 		break;
 	}
 	return 0;
@@ -793,6 +789,7 @@
 	/* FIXME: correct state value? */
 	err = card->pm_suspend(card, 0);
 	pci_save_state(dev);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return err;
 }
 
@@ -806,7 +803,9 @@
 	/* restore the PCI config space */
 	pci_restore_state(dev);
 	/* FIXME: correct state value? */
-	return card->pm_resume(card, 0);
+	card->pm_resume(card, 0);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
 }
 #endif
 
diff -uNr a/sound/core/ioctl32/hwdep32.c b/sound/core/ioctl32/hwdep32.c
--- a/sound/core/ioctl32/hwdep32.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/core/ioctl32/hwdep32.c	2005-01-14 22:28:11.622591528 +0100
@@ -36,24 +36,24 @@
 
 static inline int _snd_ioctl32_hwdep_dsp_image(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
 {
-	struct sndrv_hwdep_dsp_image data;
-	struct sndrv_hwdep_dsp_image32 data32;
-	mm_segment_t oldseg;
-	int err;
+	struct sndrv_hwdep_dsp_image __user *data, *dst;
+	struct sndrv_hwdep_dsp_image32 __user *data32, *src;
+	compat_caddr_t ptr;
 
-	if (copy_from_user(&data32, (void __user *)arg, sizeof(data32)))
+	data32 = compat_ptr(arg);
+	data = compat_alloc_user_space(sizeof(*data));
+
+	/* index and name */
+	if (copy_in_user(data, data32, 4 + 64))
+		return -EFAULT;
+	if (__get_user(ptr, &data32->image) ||
+	    __put_user(compat_ptr(ptr), &data->image))
 		return -EFAULT;
-	memset(&data, 0, sizeof(data));
-	data.index = data32.index;
-	memcpy(data.name, data32.name, sizeof(data.name));
-	data.image = compat_ptr(data32.image);
-	data.length = data32.length;
-	data.driver_data = data32.driver_data;
-	oldseg = get_fs();
-	set_fs(KERNEL_DS);
-	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)&data);
-	set_fs(oldseg);
-	return err;
+	src = data32;
+	dst = data;
+	COPY_CVT(length);
+	COPY_CVT(driver_data);
+	return file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)data);
 }
 
 DEFINE_ALSA_IOCTL_ENTRY(hwdep_dsp_image, hwdep_dsp_image, SNDRV_HWDEP_IOCTL_DSP_LOAD);
diff -uNr a/sound/core/ioctl32/ioctl32.c b/sound/core/ioctl32/ioctl32.c
--- a/sound/core/ioctl32/ioctl32.c	2004-12-24 22:34:00.000000000 +0100
+++ b/sound/core/ioctl32/ioctl32.c	2005-01-14 22:28:25.638460792 +0100
@@ -27,9 +27,11 @@
 #include <linux/fs.h>
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/minors.h>
 #include <asm/uaccess.h>
 #include "ioctl32.h"
 
+
 /*
  * register/unregister mappers
  * exported for other modules
@@ -93,43 +95,28 @@
 	unsigned char reserved[50];
 } /* don't set packed attribute here */;
 
-#define CVT_sndrv_ctl_elem_list()\
-{\
-	COPY(offset);\
-	COPY(space);\
-	COPY(used);\
-	COPY(count);\
-	CPTR(pids);\
-}
-
 static inline int _snd_ioctl32_ctl_elem_list(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
 {
-	struct sndrv_ctl_elem_list32 data32;
-	struct sndrv_ctl_elem_list data;
-	mm_segment_t oldseg;
+	struct sndrv_ctl_elem_list32 __user *data32;
+	struct sndrv_ctl_elem_list __user *data;
+	compat_caddr_t ptr;
 	int err;
 
-	if (copy_from_user(&data32, (void __user *)arg, sizeof(data32)))
+	data32 = compat_ptr(arg);
+	data = compat_alloc_user_space(sizeof(*data));
+
+	/* offset, space, used, count */
+	if (copy_in_user(data, data32, 4 * sizeof(u32)))
+		return -EFAULT;
+	/* pids */
+	if (__get_user(ptr, &data32->pids) ||
+	    __put_user(compat_ptr(ptr), &data->pids))
 		return -EFAULT;
-	memset(&data, 0, sizeof(data));
-	data.offset = data32.offset;
-	data.space = data32.space;
-	data.used = data32.used;
-	data.count = data32.count;
-	data.pids = compat_ptr(data32.pids);
-	oldseg = get_fs();
-	set_fs(KERNEL_DS);
-	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)&data);
-	set_fs(oldseg);
+	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)data);
 	if (err < 0)
 		return err;
 	/* copy the result */
-	data32.offset = data.offset;
-	data32.space = data.space;
-	data32.used = data.used;
-	data32.count = data.count;
-	//data.pids = data.pids;
-	if (copy_to_user((void __user *)arg, &data32, sizeof(data32)))
+	if (copy_in_user(data32, data, 4 * sizeof(u32)))
 		return -EFAULT;
 	return 0;
 }
@@ -170,54 +157,59 @@
 
 static inline int _snd_ioctl32_ctl_elem_info(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
 {
-	struct sndrv_ctl_elem_info data;
-	struct sndrv_ctl_elem_info32 data32;
+	struct sndrv_ctl_elem_info __user *data, *src;
+	struct sndrv_ctl_elem_info32 __user *data32, *dst;
+	unsigned int type;
 	int err;
-	mm_segment_t oldseg;
 
-	if (copy_from_user(&data32, (void __user *)arg, sizeof(data32)))
+	data32 = compat_ptr(arg);
+	data = compat_alloc_user_space(sizeof(*data));
+
+	/* copy id */
+	if (copy_in_user(&data->id, &data32->id, sizeof(data->id)))
 		return -EFAULT;
-	memset(&data, 0, sizeof(data));
-	data.id = data32.id;
 	/* we need to copy the item index.
 	 * hope this doesn't break anything..
 	 */
-	data.value.enumerated.item = data32.value.enumerated.item;
-	oldseg = get_fs();
-	set_fs(KERNEL_DS);
-	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)&data);
-	set_fs(oldseg);
+	if (copy_in_user(&data->value.enumerated.item,
+			 &data32->value.enumerated.item,
+			 sizeof(data->value.enumerated.item)))
+		return -EFAULT;
+	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)data);
 	if (err < 0)
 		return err;
 	/* restore info to 32bit */
-	data32.id = data.id;
-	data32.type = data.type;
-	data32.access = data.access;
-	data32.count = data.count;
-	data32.owner = data.owner;
-	switch (data.type) {
+	/* for COPY_CVT macro */
+	src = data;
+	dst = data32;
+	/* id, type, access, count */
+	if (copy_in_user(&data32->id, &data->id, sizeof(data->id)) ||
+	    copy_in_user(&data32->type, &data->type, 3 * sizeof(u32)))
+		return -EFAULT;
+	COPY_CVT(owner);
+	__get_user(type, &data->type);
+	switch (type) {
 	case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
 	case SNDRV_CTL_ELEM_TYPE_INTEGER:
-		data32.value.integer.min = data.value.integer.min;
-		data32.value.integer.max = data.value.integer.max;
-		data32.value.integer.step = data.value.integer.step;
+		COPY_CVT(value.integer.min);
+		COPY_CVT(value.integer.max);
+		COPY_CVT(value.integer.step);
 		break;
 	case SNDRV_CTL_ELEM_TYPE_INTEGER64:
-		data32.value.integer64.min = data.value.integer64.min;
-		data32.value.integer64.max = data.value.integer64.max;
-		data32.value.integer64.step = data.value.integer64.step;
+		if (copy_in_user(&data32->value.integer64,
+				 &data->value.integer64,
+				 sizeof(data->value.integer64)))
+			return -EFAULT;
 		break;
 	case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
-		data32.value.enumerated.items = data.value.enumerated.items;
-		data32.value.enumerated.item = data.value.enumerated.item;
-		memcpy(data32.value.enumerated.name, data.value.enumerated.name,
-		       sizeof(data.value.enumerated.name));
+		if (copy_in_user(&data32->value.enumerated,
+				 &data->value.enumerated,
+				 sizeof(data->value.enumerated)))
+			return -EFAULT;
 		break;
 	default:
 		break;
 	}
-	if (copy_to_user((void __user *)arg, &data32, sizeof(data32)))
-		return -EFAULT;
 	return 0;
 }
 
@@ -227,153 +219,137 @@
 	struct sndrv_ctl_elem_id id;
 	unsigned int indirect;	/* bit-field causes misalignment */
         union {
-		union {
-			s32 value[128];
-			u32 value_ptr;
-		} integer;
-		union {
-			s64 value[64];
-			u32 value_ptr;
-		} integer64;
-		union {
-			u32 item[128];
-			u32 item_ptr;
-		} enumerated;
-		union {
-			unsigned char data[512];
-			u32 data_ptr;
-		} bytes;
-		struct sndrv_aes_iec958 iec958;
+		s32 integer[128];	/* integer and boolean need conversion */
+		unsigned char data[512];	/* others should be compatible */
         } value;
-        unsigned char reserved[128];
+        unsigned char reserved[128];	/* not used */
 };
 
 
 /* hmm, it's so hard to retrieve the value type from the control id.. */
-static int get_ctl_type(struct file *file, snd_ctl_elem_id_t *id)
+static int get_ctl_type(snd_card_t *card, snd_ctl_elem_id_t *id)
 {
-	snd_ctl_file_t *ctl;
 	snd_kcontrol_t *kctl;
 	snd_ctl_elem_info_t info;
 	int err;
 
-	ctl = file->private_data;
-
-	down_read(&ctl->card->controls_rwsem);
-	kctl = snd_ctl_find_id(ctl->card, id);
+	down_read(&card->controls_rwsem);
+	kctl = snd_ctl_find_id(card, id);
 	if (! kctl) {
-		up_read(&ctl->card->controls_rwsem);
+		up_read(&card->controls_rwsem);
 		return -ENXIO;
 	}
 	info.id = *id;
 	err = kctl->info(kctl, &info);
-	up_read(&ctl->card->controls_rwsem);
+	up_read(&card->controls_rwsem);
 	if (err >= 0)
 		err = info.type;
 	return err;
 }
 
+extern int snd_major;
 
 static inline int _snd_ioctl32_ctl_elem_value(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
 {
 	struct sndrv_ctl_elem_value *data;
-	struct sndrv_ctl_elem_value32 *data32;
-	int err, i;
+	struct sndrv_ctl_elem_value32 __user *data32;
+	snd_ctl_file_t *ctl;
+	int err, i, indirect;
 	int type;
-	mm_segment_t oldseg;
 
-	/* FIXME: check the sane ioctl.. */
+	/* sanity check */
+	if (imajor(file->f_dentry->d_inode) != snd_major ||
+	    SNDRV_MINOR_DEVICE(iminor(file->f_dentry->d_inode)) != SNDRV_MINOR_CONTROL)
+		return -ENOTTY;
+
+	if ((ctl = file->private_data) == NULL)
+		return -ENOTTY;
 
-	data = kmalloc(sizeof(*data), GFP_KERNEL);
-	data32 = kmalloc(sizeof(*data32), GFP_KERNEL);
-	if (data == NULL || data32 == NULL) {
-		err = -ENOMEM;
+	data32 = compat_ptr(arg);
+	data = kcalloc(1, sizeof(*data), GFP_KERNEL);
+	if (data == NULL)
+		return -ENOMEM;
+
+	if (copy_from_user(&data->id, &data32->id, sizeof(data->id))) {
+		err = -EFAULT;
 		goto __end;
 	}
-
-	if (copy_from_user(data32, (void __user *)arg, sizeof(*data32))) {
+	if (__get_user(indirect, &data32->indirect)) {
 		err = -EFAULT;
 		goto __end;
 	}
-	memset(data, 0, sizeof(*data));
-	data->id = data32->id;
-	data->indirect = data32->indirect;
-	if (data->indirect) /* FIXME: this is not correct for long arrays */
-		data->value.integer.value_ptr = compat_ptr(data32->value.integer.value_ptr);
-	type = get_ctl_type(file, &data->id);
+	/* FIXME: indirect access is not supported */
+	if (indirect) {
+		err = -EINVAL;
+		goto __end;
+	}
+	type = get_ctl_type(ctl->card, &data->id);
 	if (type < 0) {
 		err = type;
 		goto __end;
 	}
-	if (! data->indirect) {
-		switch (type) {
-		case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
-		case SNDRV_CTL_ELEM_TYPE_INTEGER:
-			for (i = 0; i < 128; i++)
-				data->value.integer.value[i] = data32->value.integer.value[i];
-			break;
-		case SNDRV_CTL_ELEM_TYPE_INTEGER64:
-			for (i = 0; i < 64; i++)
-				data->value.integer64.value[i] = data32->value.integer64.value[i];
-			break;
-		case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
-			for (i = 0; i < 128; i++)
-				data->value.enumerated.item[i] = data32->value.enumerated.item[i];
-			break;
-		case SNDRV_CTL_ELEM_TYPE_BYTES:
-			memcpy(data->value.bytes.data, data32->value.bytes.data,
-			       sizeof(data->value.bytes.data));
-			break;
-		case SNDRV_CTL_ELEM_TYPE_IEC958:
-			data->value.iec958 = data32->value.iec958;
-			break;
-		default:
-			printk("unknown type %d\n", type);
-			break;
+
+	switch (type) {
+	case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+	case SNDRV_CTL_ELEM_TYPE_INTEGER:
+		for (i = 0; i < 128; i++) {
+			int val;
+			if (__get_user(val, &data32->value.integer[i])) {
+				err = -EFAULT;
+				goto __end;
+			}
+			data->value.integer.value[i] = val;
 		}
+		break;
+	case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+	case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+	case SNDRV_CTL_ELEM_TYPE_BYTES:
+	case SNDRV_CTL_ELEM_TYPE_IEC958:
+		if (__copy_from_user(data->value.bytes.data,
+				     data32->value.data,
+				     sizeof(data32->value.data))) {
+			err = -EFAULT;
+			goto __end;
+		}
+		break;
+	default:
+		printk(KERN_ERR "snd_ioctl32_ctl_elem_value: unknown type %d\n", type);
+		err = -EINVAL;
+		goto __end;
 	}
 
-	oldseg = get_fs();
-	set_fs(KERNEL_DS);
-	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)data);
-	set_fs(oldseg);
+	if (native_ctl == SNDRV_CTL_IOCTL_ELEM_READ)
+		err = snd_ctl_elem_read(ctl->card, data);
+	else
+		err = snd_ctl_elem_write(ctl->card, ctl, data);
 	if (err < 0)
 		goto __end;
 	/* restore info to 32bit */
-	if (! data->indirect) {
-		switch (type) {
-		case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
-		case SNDRV_CTL_ELEM_TYPE_INTEGER:
-			for (i = 0; i < 128; i++)
-				data32->value.integer.value[i] = data->value.integer.value[i];
-			break;
-		case SNDRV_CTL_ELEM_TYPE_INTEGER64:
-			for (i = 0; i < 64; i++)
-				data32->value.integer64.value[i] = data->value.integer64.value[i];
-			break;
-		case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
-			for (i = 0; i < 128; i++)
-				data32->value.enumerated.item[i] = data->value.enumerated.item[i];
-			break;
-		case SNDRV_CTL_ELEM_TYPE_BYTES:
-			memcpy(data32->value.bytes.data, data->value.bytes.data,
-			       sizeof(data->value.bytes.data));
-			break;
-		case SNDRV_CTL_ELEM_TYPE_IEC958:
-			data32->value.iec958 = data->value.iec958;
-			break;
-		default:
-			break;
+	switch (type) {
+	case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+	case SNDRV_CTL_ELEM_TYPE_INTEGER:
+		for (i = 0; i < 128; i++) {
+			int val;
+			val = data->value.integer.value[i];
+			if (__put_user(val, &data32->value.integer[i])) {
+				err = -EFAULT;
+				goto __end;
+			}
 		}
+		break;
+	default:
+		if (__copy_to_user(data32->value.data,
+				   data->value.bytes.data,
+				   sizeof(data32->value.data))) {
+			err = -EFAULT;
+			goto __end;
+		}
+		break;
+		break;
 	}
 	err = 0;
-	if (copy_to_user((void __user *)arg, data32, sizeof(*data32)))
-		err = -EFAULT;
       __end:
-      	if (data32)
-      		kfree(data32);
-	if (data)
-		kfree(data);
+	kfree(data);
 	return err;
 }
 
diff -uNr a/sound/core/ioctl32/ioctl32.h b/sound/core/ioctl32/ioctl32.h
--- a/sound/core/ioctl32/ioctl32.h	2004-12-24 22:34:32.000000000 +0100
+++ b/sound/core/ioctl32/ioctl32.h	2005-01-14 22:28:11.634589704 +0100
@@ -28,20 +28,37 @@
 
 #include <linux/compat.h>
 
-#define COPY(x)  (dst->x = src->x)
-#define CPTR(x)	 (dst->x = compat_ptr(src->x))
+#define COPY(x) \
+	do { \
+		if (copy_in_user(&dst->x, &src->x, sizeof(dst->x))) \
+			return -EFAULT; \
+	} while (0)
+
+#define COPY_ARRAY(x) \
+	do { \
+		if (copy_in_user(dst->x, src->x, sizeof(dst->x))) \
+			return -EFAULT; \
+	} while (0)
+
+#define COPY_CVT(x) \
+	do { \
+		__typeof__(src->x) __val_tmp; \
+		if (get_user(__val_tmp, &src->x) || \
+		    put_user(__val_tmp, &dst->x))\
+			return -EFAULT; \
+	} while (0)
 
 #define convert_from_32(type, dstp, srcp)\
 {\
-	struct sndrv_##type *dst = dstp;\
-	struct sndrv_##type##32 *src = srcp;\
+	struct sndrv_##type __user *dst = dstp;\
+	struct sndrv_##type##32 __user *src = srcp;\
 	CVT_##sndrv_##type();\
 }
 
 #define convert_to_32(type, dstp, srcp)\
 {\
-	struct sndrv_##type *src = srcp;\
-	struct sndrv_##type##32 *dst = dstp;\
+	struct sndrv_##type __user *src = srcp;\
+	struct sndrv_##type##32 __user *dst = dstp;\
 	CVT_##sndrv_##type();\
 }
 
@@ -49,65 +66,19 @@
 #define DEFINE_ALSA_IOCTL(type) \
 static inline int _snd_ioctl32_##type(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)\
 {\
-	struct sndrv_##type##32 data32;\
-	struct sndrv_##type data;\
-	mm_segment_t oldseg;\
+	struct sndrv_##type##32 __user *data32;\
+	struct sndrv_##type __user *data;\
 	int err;\
-	if (copy_from_user(&data32, (void __user *)arg, sizeof(data32)))\
-		return -EFAULT;\
-	memset(&data, 0, sizeof(data));\
-	convert_from_32(type, &data, &data32);\
-	oldseg = get_fs();\
-	set_fs(KERNEL_DS);\
-	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)&data);\
-	set_fs(oldseg);\
-	if (err < 0) \
-		return err;\
-	if (native_ctl & (_IOC_READ << _IOC_DIRSHIFT)) {\
-		convert_to_32(type, &data32, &data);\
-		if (copy_to_user((void __user *)arg, &data32, sizeof(data32)))\
-			return -EFAULT;\
-	}\
-	return 0;\
-}
-
-#define DEFINE_ALSA_IOCTL_BIG(type) \
-static inline int _snd_ioctl32_##type(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)\
-{\
-	struct sndrv_##type##32 *data32;\
-	struct sndrv_##type *data;\
-	mm_segment_t oldseg;\
-	int err;\
-	data32 = kmalloc(sizeof(*data32), GFP_KERNEL); \
-	data = kmalloc(sizeof(*data), GFP_KERNEL); \
-	if (data32 == NULL || data == NULL) { \
-		err = -ENOMEM; \
-		goto __end; \
-	}\
-	if (copy_from_user(data32, (void __user *)arg, sizeof(*data32))) { \
-		err = -EFAULT; \
-		goto __end; \
-	}\
-	memset(data, 0, sizeof(*data));\
+	data32 = compat_ptr(arg);\
+	data = compat_alloc_user_space(sizeof(*data));\
 	convert_from_32(type, data, data32);\
-	oldseg = get_fs();\
-	set_fs(KERNEL_DS);\
 	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)data);\
-	set_fs(oldseg);\
 	if (err < 0) \
-		goto __end;\
-	err = 0;\
+		return err;\
 	if (native_ctl & (_IOC_READ << _IOC_DIRSHIFT)) {\
 		convert_to_32(type, data32, data);\
-		if (copy_to_user((void __user *)arg, data32, sizeof(*data32)))\
-			err = -EFAULT;\
 	}\
-      __end:\
-      	if (data)\
-      		kfree(data);\
-      	if (data32)\
-      		kfree(data32);\
-	return err;\
+	return 0;\
 }
 
 #define DEFINE_ALSA_IOCTL_ENTRY(name,type,native_ctl) \
diff -uNr a/sound/core/ioctl32/pcm32.c b/sound/core/ioctl32/pcm32.c
--- a/sound/core/ioctl32/pcm32.c	2004-12-24 22:35:00.000000000 +0100
+++ b/sound/core/ioctl32/pcm32.c	2005-01-14 22:28:11.644588184 +0100
@@ -24,6 +24,7 @@
 #include <linux/compat.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
+#include <sound/minors.h>
 #include "ioctl32.h"
 
 
@@ -41,23 +42,15 @@
 	u32 val;
 };
 
-#define CVT_sndrv_pcm_sframes_str() { COPY(val); }
-#define CVT_sndrv_pcm_uframes_str() { COPY(val); }
+#define CVT_sndrv_pcm_sframes_str() { COPY_CVT(val); }
+#define CVT_sndrv_pcm_uframes_str() { COPY_CVT(val); }
 
 
-struct sndrv_interval32 {
-	u32 min, max;
-	unsigned int openmin:1,
-		     openmax:1,
-		     integer:1,
-		     empty:1;
-};
-
 struct sndrv_pcm_hw_params32 {
 	u32 flags;
 	struct sndrv_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK - SNDRV_PCM_HW_PARAM_FIRST_MASK + 1]; /* this must be identical */
 	struct sndrv_mask mres[5];	/* reserved masks */
-	struct sndrv_interval32 intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
+	struct sndrv_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
 	struct sndrv_interval ires[9];	/* reserved intervals */
 	u32 rmask;
 	u32 cmask;
@@ -69,31 +62,6 @@
 	unsigned char reserved[64];
 } __attribute__((packed));
 
-#define numberof(array) ARRAY_SIZE(array)
-
-#define CVT_sndrv_pcm_hw_params()\
-{\
-	unsigned int i;\
-	COPY(flags);\
-	for (i = 0; i < numberof(dst->masks); i++)\
-		COPY(masks[i]);\
-	for (i = 0; i < numberof(dst->intervals); i++) {\
-		COPY(intervals[i].min);\
-		COPY(intervals[i].max);\
-		COPY(intervals[i].openmin);\
-		COPY(intervals[i].openmax);\
-		COPY(intervals[i].integer);\
-		COPY(intervals[i].empty);\
-	}\
-	COPY(rmask);\
-	COPY(cmask);\
-	COPY(info);\
-	COPY(msbits);\
-	COPY(rate_num);\
-	COPY(rate_den);\
-	COPY(fifo_size);\
-}
-
 struct sndrv_pcm_sw_params32 {
 	s32 tstamp_mode;
 	u32 period_step;
@@ -113,13 +81,13 @@
 	COPY(tstamp_mode);\
 	COPY(period_step);\
 	COPY(sleep_min);\
-	COPY(avail_min);\
-	COPY(xfer_align);\
-	COPY(start_threshold);\
-	COPY(stop_threshold);\
-	COPY(silence_threshold);\
-	COPY(silence_size);\
-	COPY(boundary);\
+	COPY_CVT(avail_min);\
+	COPY_CVT(xfer_align);\
+	COPY_CVT(start_threshold);\
+	COPY_CVT(stop_threshold);\
+	COPY_CVT(silence_threshold);\
+	COPY_CVT(silence_size);\
+	COPY_CVT(boundary);\
 }
 
 struct sndrv_pcm_channel_info32 {
@@ -132,7 +100,7 @@
 #define CVT_sndrv_pcm_channel_info()\
 {\
 	COPY(channel);\
-	COPY(offset);\
+	COPY_CVT(offset);\
 	COPY(first);\
 	COPY(step);\
 }
@@ -154,16 +122,16 @@
 #define CVT_sndrv_pcm_status()\
 {\
 	COPY(state);\
-	COPY(trigger_tstamp.tv_sec);\
-	COPY(trigger_tstamp.tv_nsec);\
-	COPY(tstamp.tv_sec);\
-	COPY(tstamp.tv_nsec);\
-	COPY(appl_ptr);\
-	COPY(hw_ptr);\
-	COPY(delay);\
-	COPY(avail);\
-	COPY(avail_max);\
-	COPY(overrange);\
+	COPY_CVT(trigger_tstamp.tv_sec);\
+	COPY_CVT(trigger_tstamp.tv_nsec);\
+	COPY_CVT(tstamp.tv_sec);\
+	COPY_CVT(tstamp.tv_nsec);\
+	COPY_CVT(appl_ptr);\
+	COPY_CVT(hw_ptr);\
+	COPY_CVT(delay);\
+	COPY_CVT(avail);\
+	COPY_CVT(avail_max);\
+	COPY_CVT(overrange);\
 	COPY(suspended_state);\
 }
 
@@ -173,61 +141,73 @@
 DEFINE_ALSA_IOCTL(pcm_channel_info);
 DEFINE_ALSA_IOCTL(pcm_status);
 
-/* recalcuate the boundary within 32bit */
-static void recalculate_boundary(struct file *file)
+/* sanity device check */
+extern int snd_major;
+static int sanity_check_pcm(struct file *file)
 {
-	snd_pcm_file_t *pcm_file;
-	snd_pcm_substream_t *substream;
-	snd_pcm_runtime_t *runtime;
+	unsigned short minor;
+	if (imajor(file->f_dentry->d_inode) != snd_major)
+		return -ENOTTY;
+	minor = iminor(file->f_dentry->d_inode);
+	if (minor >= 256 || 
+	    minor % SNDRV_MINOR_DEVICES < SNDRV_MINOR_PCM_PLAYBACK)
+		return -ENOTTY;
+	return 0;
+}
 
-	/* FIXME: need to check whether fop->ioctl is sane */
-	if (! (pcm_file = file->private_data))
-		return;
-	if (! (substream = pcm_file->substream))
-		return;
-	if (! (runtime = substream->runtime))
+/* recalcuate the boundary within 32bit */
+static void recalculate_boundary(snd_pcm_runtime_t *runtime)
+{
+	if (! runtime->buffer_size)
 		return;
 	runtime->boundary = runtime->buffer_size;
 	while (runtime->boundary * 2 <= 0x7fffffffUL - runtime->buffer_size)
 		runtime->boundary *= 2;
 }
 
-static inline int _snd_ioctl32_pcm_hw_params(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
+/* both for HW_PARAMS and HW_REFINE */
+static int _snd_ioctl32_pcm_hw_params(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
 {
-	struct sndrv_pcm_hw_params32 *data32;
+	struct sndrv_pcm_hw_params32 __user *data32;
 	struct sndrv_pcm_hw_params *data;
-	mm_segment_t oldseg;
+	snd_pcm_file_t *pcm_file;
+	snd_pcm_substream_t *substream;
+	snd_pcm_runtime_t *runtime;
 	int err;
 
-	data32 = kmalloc(sizeof(*data32), GFP_KERNEL);
+	if (sanity_check_pcm(file))
+		return -ENOTTY;
+	if (! (pcm_file = file->private_data))
+		return -ENOTTY;
+	if (! (substream = pcm_file->substream))
+		return -ENOTTY;
+	if (! (runtime = substream->runtime))
+		return -ENOTTY;
+
+	data32 = compat_ptr(arg);
 	data = kmalloc(sizeof(*data), GFP_KERNEL);
-	if (data32 == NULL || data == NULL) {
-		err = -ENOMEM;
-		goto __end;
-	}
-	if (copy_from_user(data32, (void __user *)arg, sizeof(*data32))) {
+	if (data == NULL)
+		return -ENOMEM;
+	if (copy_from_user(data, data32, sizeof(*data32))) {
 		err = -EFAULT;
-		goto __end;
+		goto error;
 	}
-	memset(data, 0, sizeof(*data));
-	convert_from_32(pcm_hw_params, data, data32);
-	oldseg = get_fs();
-	set_fs(KERNEL_DS);
-	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)data);
-	set_fs(oldseg);
+	if (native_ctl == SNDRV_PCM_IOCTL_HW_REFINE)
+		err = snd_pcm_hw_refine(substream, data);
+	else
+		err = snd_pcm_hw_params(substream, data);
 	if (err < 0)
-		goto __end;
-	err = 0;
-	convert_to_32(pcm_hw_params, data32, data);
-	if (copy_to_user((void __user *)arg, data32, sizeof(*data32)))
+		goto error;
+	if (copy_to_user(data32, data, sizeof(*data32)) ||
+	    __put_user((u32)data->fifo_size, &data32->fifo_size)) {
 		err = -EFAULT;
-	else
-		recalculate_boundary(file);
-      __end:
-      	if (data)
-      		kfree(data);
-      	if (data32)
-      		kfree(data32);
+		goto error;
+	}
+
+	if (native_ctl == SNDRV_PCM_IOCTL_HW_PARAMS)
+		recalculate_boundary(runtime);
+ error:
+	kfree(data);
 	return err;
 }
 
@@ -240,27 +220,27 @@
 	u32 frames;
 } __attribute__((packed));
 
-static inline int _snd_ioctl32_xferi(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
+static int _snd_ioctl32_xferi(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
 {
 	struct sndrv_xferi32 data32;
-	struct sndrv_xferi data;
-	mm_segment_t oldseg;
+	struct sndrv_xferi __user *data;
+	snd_pcm_sframes_t result;
 	int err;
 
 	if (copy_from_user(&data32, (void __user *)arg, sizeof(data32)))
 		return -EFAULT;
-	memset(&data, 0, sizeof(data));
-	data.result = data32.result;
-	data.buf = compat_ptr(data32.buf);
-	data.frames = data32.frames;
-	oldseg = get_fs();
-	set_fs(KERNEL_DS);
-	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)&data);
-	set_fs(oldseg);
+	data = compat_alloc_user_space(sizeof(*data));
+	if (put_user((snd_pcm_sframes_t)data32.result, &data->result) ||
+	    __put_user(compat_ptr(data32.buf), &data->buf) ||
+	    __put_user((snd_pcm_uframes_t)data32.frames, &data->frames))
+		return -EFAULT;
+	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)data);
 	if (err < 0)
 		return err;
 	/* copy the result */
-	data32.result = data.result;
+	if (__get_user(result, &data->result))
+		return -EFAULT;
+	data32.result = result;
 	if (copy_to_user((void __user *)arg, &data32, sizeof(data32)))
 		return -EFAULT;
 	return 0;
@@ -280,22 +260,24 @@
  * handler there expands again the same 128 pointers on stack, so it is better
  * to handle the function (calling pcm_readv/writev) directly in this handler.
  */
-static inline int _snd_ioctl32_xfern(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
+static int _snd_ioctl32_xfern(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
 {
 	snd_pcm_file_t *pcm_file;
 	snd_pcm_substream_t *substream;
+	struct sndrv_xfern32 __user *srcptr = compat_ptr(arg);
 	struct sndrv_xfern32 data32;
-	struct sndrv_xfern32 __user *srcptr = (void __user *)arg;
-	void __user **bufs = NULL;
+	void __user **bufs;
 	int err = 0, ch, i;
 	u32 __user *bufptr;
-	mm_segment_t oldseg;
-
-	/* FIXME: need to check whether fop->ioctl is sane */
 
-	pcm_file = file->private_data;
-	substream = pcm_file->substream;
-	snd_assert(substream != NULL && substream->runtime, return -ENXIO);
+	if (sanity_check_pcm(file))
+		return -ENOTTY;
+	if (! (pcm_file = file->private_data))
+		return -ENOTTY;
+	if (! (substream = pcm_file->substream))
+		return -ENOTTY;
+	if (! substream->runtime)
+		return -ENOTTY;
 
 	/* check validty of the command */
 	switch (native_ctl) {
@@ -312,22 +294,21 @@
 	}
 	if ((ch = substream->runtime->channels) > 128)
 		return -EINVAL;
-	if (get_user(data32.frames, &srcptr->frames))
+	if (copy_from_user(&data32, (void __user *)arg, sizeof(data32)))
 		return -EFAULT;
-	__get_user(data32.bufs, &srcptr->bufs);
 	bufptr = compat_ptr(data32.bufs);
-	bufs = kmalloc(sizeof(void *) * 128, GFP_KERNEL);
+	bufs = kmalloc(sizeof(void __user *) * ch, GFP_KERNEL);
 	if (bufs == NULL)
 		return -ENOMEM;
 	for (i = 0; i < ch; i++) {
 		u32 ptr;
-		if (get_user(ptr, bufptr))
+		if (get_user(ptr, bufptr)) {
+			kfree(bufs);
 			return -EFAULT;
+		}
 		bufs[ch] = compat_ptr(ptr);
 		bufptr++;
 	}
-	oldseg = get_fs();
-	set_fs(KERNEL_DS);
 	switch (native_ctl) {
 	case SNDRV_PCM_IOCTL_WRITEN_FRAMES:
 		err = snd_pcm_lib_writev(substream, bufs, data32.frames);
@@ -336,109 +317,15 @@
 		err = snd_pcm_lib_readv(substream, bufs, data32.frames);
 		break;
 	}
-	set_fs(oldseg);
 	if (err >= 0) {
 		if (put_user(err, &srcptr->result))
 			err = -EFAULT;
 	}
 	kfree(bufs);
-	return 0;
-}
-
-
-struct sndrv_pcm_hw_params_old32 {
-	u32 flags;
-	u32 masks[SNDRV_PCM_HW_PARAM_SUBFORMAT -
-			   SNDRV_PCM_HW_PARAM_ACCESS + 1];
-	struct sndrv_interval32 intervals[SNDRV_PCM_HW_PARAM_TICK_TIME -
-					SNDRV_PCM_HW_PARAM_SAMPLE_BITS + 1];
-	u32 rmask;
-	u32 cmask;
-	u32 info;
-	u32 msbits;
-	u32 rate_num;
-	u32 rate_den;
-	u32 fifo_size;
-	unsigned char reserved[64];
-} __attribute__((packed));
-
-#define __OLD_TO_NEW_MASK(x) ((x&7)|((x&0x07fffff8)<<5))
-#define __NEW_TO_OLD_MASK(x) ((x&7)|((x&0xffffff00)>>5))
-
-static void snd_pcm_hw_convert_from_old_params(snd_pcm_hw_params_t *params, struct sndrv_pcm_hw_params_old32 *oparams)
-{
-	unsigned int i;
-
-	memset(params, 0, sizeof(*params));
-	params->flags = oparams->flags;
-	for (i = 0; i < ARRAY_SIZE(oparams->masks); i++)
-		params->masks[i].bits[0] = oparams->masks[i];
-	memcpy(params->intervals, oparams->intervals, sizeof(oparams->intervals));
-	params->rmask = __OLD_TO_NEW_MASK(oparams->rmask);
-	params->cmask = __OLD_TO_NEW_MASK(oparams->cmask);
-	params->info = oparams->info;
-	params->msbits = oparams->msbits;
-	params->rate_num = oparams->rate_num;
-	params->rate_den = oparams->rate_den;
-	params->fifo_size = oparams->fifo_size;
-}
-
-static void snd_pcm_hw_convert_to_old_params(struct sndrv_pcm_hw_params_old32 *oparams, snd_pcm_hw_params_t *params)
-{
-	unsigned int i;
-
-	memset(oparams, 0, sizeof(*oparams));
-	oparams->flags = params->flags;
-	for (i = 0; i < ARRAY_SIZE(oparams->masks); i++)
-		oparams->masks[i] = params->masks[i].bits[0];
-	memcpy(oparams->intervals, params->intervals, sizeof(oparams->intervals));
-	oparams->rmask = __NEW_TO_OLD_MASK(params->rmask);
-	oparams->cmask = __NEW_TO_OLD_MASK(params->cmask);
-	oparams->info = params->info;
-	oparams->msbits = params->msbits;
-	oparams->rate_num = params->rate_num;
-	oparams->rate_den = params->rate_den;
-	oparams->fifo_size = params->fifo_size;
-}
-
-static inline int _snd_ioctl32_pcm_hw_params_old(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file, unsigned int native_ctl)
-{
-	struct sndrv_pcm_hw_params_old32 *data32;
-	struct sndrv_pcm_hw_params *data;
-	mm_segment_t oldseg;
-	int err;
-
-	data32 = kcalloc(1, sizeof(*data32), GFP_KERNEL);
-	data = kcalloc(1, sizeof(*data), GFP_KERNEL);
-	if (data32 == NULL || data == NULL) {
-		err = -ENOMEM;
-		goto __end;
-	}
-	if (copy_from_user(data32, (void __user *)arg, sizeof(*data32))) {
-		err = -EFAULT;
-		goto __end;
-	}
-	snd_pcm_hw_convert_from_old_params(data, data32);
-	oldseg = get_fs();
-	set_fs(KERNEL_DS);
-	err = file->f_op->ioctl(file->f_dentry->d_inode, file, native_ctl, (unsigned long)data);
-	set_fs(oldseg);
-	if (err < 0)
-		goto __end;
-	snd_pcm_hw_convert_to_old_params(data32, data);
-	err = 0;
-	if (copy_to_user((void __user *)arg, data32, sizeof(*data32)))
-		err = -EFAULT;
-	else
-		recalculate_boundary(file);
-      __end:
-      	if (data)
-      		kfree(data);
-      	if (data32)
-      		kfree(data32);
 	return err;
 }
 
+
 struct sndrv_pcm_mmap_status32 {
 	s32 state;
 	s32 pad1;
@@ -469,15 +356,15 @@
 	COPY(flags);\
 	COPY(s.status.state);\
 	COPY(s.status.pad1);\
-	COPY(s.status.hw_ptr);\
-	COPY(s.status.tstamp.tv_sec);\
-	COPY(s.status.tstamp.tv_nsec);\
+	COPY_CVT(s.status.hw_ptr);\
+	COPY_CVT(s.status.tstamp.tv_sec);\
+	COPY_CVT(s.status.tstamp.tv_nsec);\
 	COPY(s.status.suspended_state);\
-	COPY(c.control.appl_ptr);\
-	COPY(c.control.avail_min);\
+	COPY_CVT(c.control.appl_ptr);\
+	COPY_CVT(c.control.avail_min);\
 }
 
-DEFINE_ALSA_IOCTL_BIG(pcm_sync_ptr);
+DEFINE_ALSA_IOCTL(pcm_sync_ptr);
 
 /*
  */
@@ -485,8 +372,6 @@
 DEFINE_ALSA_IOCTL_ENTRY(pcm_hw_refine, pcm_hw_params, SNDRV_PCM_IOCTL_HW_REFINE);
 DEFINE_ALSA_IOCTL_ENTRY(pcm_hw_params, pcm_hw_params, SNDRV_PCM_IOCTL_HW_PARAMS);
 DEFINE_ALSA_IOCTL_ENTRY(pcm_sw_params, pcm_sw_params, SNDRV_PCM_IOCTL_SW_PARAMS);
-DEFINE_ALSA_IOCTL_ENTRY(pcm_hw_refine_old, pcm_hw_params_old, SNDRV_PCM_IOCTL_HW_REFINE);
-DEFINE_ALSA_IOCTL_ENTRY(pcm_hw_params_old, pcm_hw_params_old, SNDRV_PCM_IOCTL_HW_PARAMS);
 DEFINE_ALSA_IOCTL_ENTRY(pcm_status, pcm_status, SNDRV_PCM_IOCTL_STATUS);
 DEFINE_ALSA_IOCTL_ENTRY(pcm_delay, pcm_sframes_str, SNDRV_PCM_IOCTL_DELAY);
 DEFINE_ALSA_IOCTL_ENTRY(pcm_channel_info, pcm_channel_info, SNDRV_PCM_IOCTL_CHANNEL_INFO);
@@ -538,8 +423,6 @@
 	SNDRV_PCM_IOCTL_READI_FRAMES32 = _IOR('A', 0x51, struct sndrv_xferi32),
 	SNDRV_PCM_IOCTL_WRITEN_FRAMES32 = _IOW('A', 0x52, struct sndrv_xfern32),
 	SNDRV_PCM_IOCTL_READN_FRAMES32 = _IOR('A', 0x53, struct sndrv_xfern32),
-	SNDRV_PCM_IOCTL_HW_REFINE_OLD32 = _IOWR('A', 0x10, struct sndrv_pcm_hw_params_old32),
-	SNDRV_PCM_IOCTL_HW_PARAMS_OLD32 = _IOWR('A', 0x11, struct sndrv_pcm_hw_params_old32),
 	SNDRV_PCM_IOCTL_SYNC_PTR32 = _IOWR('A', 0x23, struct sndrv_pcm_sync_ptr32),
 
 };
@@ -551,8 +434,6 @@
 	MAP_COMPAT(SNDRV_PCM_IOCTL_TSTAMP),
 	{ SNDRV_PCM_IOCTL_HW_REFINE32, AP(pcm_hw_refine) },
 	{ SNDRV_PCM_IOCTL_HW_PARAMS32, AP(pcm_hw_params) },
-	{ SNDRV_PCM_IOCTL_HW_REFINE_OLD32, AP(pcm_hw_refine_old) },
-	{ SNDRV_PCM_IOCTL_HW_PARAMS_OLD32, AP(pcm_hw_params_old) },
 	MAP_COMPAT(SNDRV_PCM_IOCTL_HW_FREE),
 	{ SNDRV_PCM_IOCTL_SW_PARAMS32, AP(pcm_sw_params) },
 	{ SNDRV_PCM_IOCTL_STATUS32, AP(pcm_status) },
diff -uNr a/sound/core/ioctl32/rawmidi32.c b/sound/core/ioctl32/rawmidi32.c
--- a/sound/core/ioctl32/rawmidi32.c	2004-12-24 22:34:45.000000000 +0100
+++ b/sound/core/ioctl32/rawmidi32.c	2005-01-14 22:28:11.647587728 +0100
@@ -38,9 +38,11 @@
 #define CVT_sndrv_rawmidi_params()\
 {\
 	COPY(stream);\
-	COPY(buffer_size);\
-	COPY(avail_min);\
-	COPY(no_active_sensing);\
+	COPY_CVT(buffer_size);\
+	COPY_CVT(avail_min);\
+	if (copy_in_user(((size_t __user *)&dst->avail_min + 1),\
+			 ((size_t __user *)&src->avail_min + 1), 4)) \
+		return -EFAULT;\
 }
 
 struct sndrv_rawmidi_status32 {
@@ -54,10 +56,10 @@
 #define CVT_sndrv_rawmidi_status()\
 {\
 	COPY(stream);\
-	COPY(tstamp.tv_sec);\
-	COPY(tstamp.tv_nsec);\
-	COPY(avail);\
-	COPY(xruns);\
+	COPY_CVT(tstamp.tv_sec);\
+	COPY_CVT(tstamp.tv_nsec);\
+	COPY_CVT(avail);\
+	COPY_CVT(xruns);\
 }
 
 DEFINE_ALSA_IOCTL(rawmidi_params);
diff -uNr a/sound/core/ioctl32/seq32.c b/sound/core/ioctl32/seq32.c
--- a/sound/core/ioctl32/seq32.c	2004-12-24 22:35:40.000000000 +0100
+++ b/sound/core/ioctl32/seq32.c	2005-01-14 22:28:11.649587424 +0100
@@ -42,13 +42,14 @@
 
 	u32 kernel;			/* reserved for kernel use (must be NULL) */
 	u32 flags;		/* misc. conditioning */
-	char reserved[60];		/* for future use */
+	unsigned char time_queue;	/* queue # for timestamping */
+	char reserved[59];		/* for future use */
 };
 
 #define CVT_sndrv_seq_port_info()\
 {\
 	COPY(addr);\
-	memcpy(dst->name, src->name, sizeof(dst->name));\
+	COPY_ARRAY(name);\
 	COPY(capability);\
 	COPY(type);\
 	COPY(midi_channels);\
@@ -57,6 +58,7 @@
 	COPY(read_use);\
 	COPY(write_use);\
 	COPY(flags);\
+	COPY(time_queue);\
 }
 
 DEFINE_ALSA_IOCTL(seq_port_info);
diff -uNr a/sound/core/ioctl32/timer32.c b/sound/core/ioctl32/timer32.c
--- a/sound/core/ioctl32/timer32.c	2004-12-24 22:34:58.000000000 +0100
+++ b/sound/core/ioctl32/timer32.c	2005-01-14 22:28:11.650587272 +0100
@@ -41,9 +41,9 @@
 {\
 	COPY(flags);\
 	COPY(card);\
-	memcpy(dst->id, src->id, sizeof(src->id));\
-	memcpy(dst->name, src->name, sizeof(src->name));\
-	COPY(resolution);\
+	COPY_ARRAY(id);\
+	COPY_ARRAY(name);\
+	COPY_CVT(resolution);\
 }
 
 struct sndrv_timer_status32 {
@@ -57,8 +57,8 @@
 
 #define CVT_sndrv_timer_status()\
 {\
-	COPY(tstamp.tv_sec);\
-	COPY(tstamp.tv_nsec);\
+	COPY_CVT(tstamp.tv_sec);\
+	COPY_CVT(tstamp.tv_nsec);\
 	COPY(resolution);\
 	COPY(lost);\
 	COPY(overrun);\
diff -uNr a/sound/core/Kconfig b/sound/core/Kconfig
--- a/sound/core/Kconfig	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/core/Kconfig	2005-01-14 22:28:11.653586816 +0100
@@ -83,7 +83,7 @@
 
 config SND_BIT32_EMUL
 	tristate "Emulation for 32-bit applications"
-	depends on SND && (MIPS64 || SPARC64 || PPC64 || X86_64 && IA32_EMULATION)
+	depends on SND && COMPAT
 	select SND_PCM
 	select SND_RAWMIDI
 	select SND_TIMER
diff -uNr a/sound/core/memory.c b/sound/core/memory.c
--- a/sound/core/memory.c	2004-12-24 22:33:50.000000000 +0100
+++ b/sound/core/memory.c	2005-01-14 22:28:11.656586360 +0100
@@ -89,7 +89,7 @@
 	}
 }
 
-void *__snd_kmalloc(size_t size, int flags, void *caller)
+static void *__snd_kmalloc(size_t size, int flags, void *caller)
 {
 	unsigned long cpu_flags;
 	struct snd_alloc_track *t;
@@ -131,10 +131,8 @@
 {
 	unsigned long flags;
 	struct snd_alloc_track *t;
-	if (obj == NULL) {
-		snd_printk(KERN_WARNING "null kfree (called from %p)\n", __builtin_return_address(0));
+	if (obj == NULL)
 		return;
-	}
 	t = snd_alloc_track_entry(obj);
 	if (t->magic != KMALLOC_MAGIC) {
 		snd_printk(KERN_WARNING "bad kfree (called from %p)\n", __builtin_return_address(0));
@@ -170,10 +168,8 @@
 void snd_hidden_vfree(void *obj)
 {
 	struct snd_alloc_track *t;
-	if (obj == NULL) {
-		snd_printk(KERN_WARNING "null vfree (called from %p)\n", __builtin_return_address(0));
+	if (obj == NULL)
 		return;
-	}
 	t = snd_alloc_track_entry(obj);
 	if (t->magic != VMALLOC_MAGIC) {
 		snd_printk(KERN_ERR "bad vfree (called from %p)\n", __builtin_return_address(0));
@@ -257,7 +253,7 @@
  *
  * Returns zero if successful, or non-zero on failure.
  */
-int copy_to_user_fromio(void __user *dst, const void __iomem *src, size_t count)
+int copy_to_user_fromio(void __user *dst, const volatile void __iomem *src, size_t count)
 {
 #if defined(__i386__) || defined(CONFIG_SPARC32)
 	return copy_to_user(dst, (const void*)src, count) ? -EFAULT : 0;
@@ -267,7 +263,7 @@
 		size_t c = count;
 		if (c > sizeof(buf))
 			c = sizeof(buf);
-		memcpy_fromio(buf, src, c);
+		memcpy_fromio(buf, (void __iomem *)src, c);
 		if (copy_to_user(dst, buf, c))
 			return -EFAULT;
 		count -= c;
@@ -288,7 +284,7 @@
  *
  * Returns zero if successful, or non-zero on failure.
  */
-int copy_from_user_toio(void __iomem *dst, const void __user *src, size_t count)
+int copy_from_user_toio(volatile void __iomem *dst, const void __user *src, size_t count)
 {
 #if defined(__i386__) || defined(CONFIG_SPARC32)
 	return copy_from_user((void*)dst, src, count) ? -EFAULT : 0;
diff -uNr a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
--- a/sound/core/oss/mixer_oss.c	2004-12-24 22:35:01.000000000 +0100
+++ b/sound/core/oss/mixer_oss.c	2005-01-14 22:28:11.660585752 +0100
@@ -360,8 +360,8 @@
 }
 
 /* FIXME: need to unlock BKL to allow preemption */
-int snd_mixer_oss_ioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, unsigned long arg)
+static int snd_mixer_oss_ioctl(struct inode *inode, struct file *file,
+			       unsigned int cmd, unsigned long arg)
 {
 	int err;
 	/* FIXME: need to unlock BKL to allow preemption */
@@ -527,10 +527,8 @@
 		*right = snd_mixer_oss_conv1(uctl->value.integer.value[1], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[1]);
       __unalloc:
 	up_read(&card->controls_rwsem);
-      	if (uctl)
-      		kfree(uctl);
-      	if (uinfo)
-      		kfree(uinfo);
+      	kfree(uctl);
+      	kfree(uinfo);
 }
 
 static void snd_mixer_oss_get_volume1_sw(snd_mixer_oss_file_t *fmixer,
@@ -566,10 +564,8 @@
 		*right = 0;
       __unalloc:
 	up_read(&card->controls_rwsem);
-      	if (uctl)
-      		kfree(uctl);
-      	if (uinfo)
-		kfree(uinfo);
+      	kfree(uctl);
+	kfree(uinfo);
 }
 
 static int snd_mixer_oss_get_volume1(snd_mixer_oss_file_t *fmixer,
@@ -628,10 +624,8 @@
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);
       __unalloc:
 	up_read(&card->controls_rwsem);
-      	if (uctl)
-      		kfree(uctl);
-      	if (uinfo)
-		kfree(uinfo);
+      	kfree(uctl);
+	kfree(uinfo);
 }
 
 static void snd_mixer_oss_put_volume1_sw(snd_mixer_oss_file_t *fmixer,
@@ -673,10 +667,8 @@
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);
       __unalloc:
 	up_read(&card->controls_rwsem);
-      	if (uctl)
-      		kfree(uctl);
-      	if (uinfo)
-		kfree(uinfo);
+      	kfree(uctl);
+	kfree(uinfo);
 }
 
 static int snd_mixer_oss_put_volume1(snd_mixer_oss_file_t *fmixer,
@@ -802,10 +794,8 @@
 	err = 0;
       __unlock:
      	up_read(&card->controls_rwsem);
-      	if (uctl)
-      		kfree(uctl);
-      	if (uinfo)
-      		kfree(uinfo);
+      	kfree(uctl);
+      	kfree(uinfo);
       	return err;
 }
 
@@ -853,10 +843,8 @@
 	err = 0;
       __unlock:
 	up_read(&card->controls_rwsem);
-	if (uctl)
-		kfree(uctl);
-	if (uinfo)
-		kfree(uinfo);
+	kfree(uctl);
+	kfree(uinfo);
 	return err;
 }
 
diff -uNr a/sound/core/oss/mulaw.c b/sound/core/oss/mulaw.c
--- a/sound/core/oss/mulaw.c	2004-12-24 22:35:50.000000000 +0100
+++ b/sound/core/oss/mulaw.c	2005-01-14 22:28:11.662585448 +0100
@@ -301,6 +301,7 @@
 	data = (mulaw_t*)plugin->extra_data;
 	data->func = func;
 	data->conv = getput_index(format->format);
+	snd_assert(data->conv >= 0 && data->conv < 4*2*2, return -EINVAL);
 	plugin->transfer = mulaw_transfer;
 	*r_plugin = plugin;
 	return 0;
diff -uNr a/sound/core/oss/pcm_oss.c b/sound/core/oss/pcm_oss.c
--- a/sound/core/oss/pcm_oss.c	2004-12-24 22:35:25.000000000 +0100
+++ b/sound/core/oss/pcm_oss.c	2005-01-14 22:28:11.670584232 +0100
@@ -46,7 +46,7 @@
 
 static int dsp_map[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 0};
 static int adsp_map[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};
-static int nonblock_open;
+static int nonblock_open = 1;
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Abramo Bagnara <abramo@alsa-project.org>");
 MODULE_DESCRIPTION("PCM OSS emulation for ALSA.");
@@ -77,7 +77,7 @@
 	set_fs(fs);
 }
 
-int snd_pcm_oss_plugin_clear(snd_pcm_substream_t *substream)
+static int snd_pcm_oss_plugin_clear(snd_pcm_substream_t *substream)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_pcm_plugin_t *plugin, *next;
@@ -92,7 +92,7 @@
 	return 0;
 }
 
-int snd_pcm_plugin_insert(snd_pcm_plugin_t *plugin)
+static int snd_pcm_plugin_insert(snd_pcm_plugin_t *plugin)
 {
 	snd_pcm_runtime_t *runtime = plugin->plug->runtime;
 	plugin->next = runtime->oss.plugin_first;
@@ -513,8 +513,7 @@
 
 	runtime->oss.params = 0;
 	runtime->oss.prepare = 1;
-	if (runtime->oss.buffer != NULL)
-		vfree(runtime->oss.buffer);
+	vfree(runtime->oss.buffer);
 	runtime->oss.buffer = vmalloc(runtime->oss.period_bytes);
 	runtime->oss.buffer_used = 0;
 	if (runtime->dma_area)
@@ -524,12 +523,9 @@
 
 	err = 0;
 failure:
-	if (sw_params)
-		kfree(sw_params);
-	if (params)
-		kfree(params);
-	if (sparams)
-		kfree(sparams);
+	kfree(sw_params);
+	kfree(params);
+	kfree(sparams);
 	return err;
 }
 
@@ -1671,8 +1667,7 @@
 {
 	snd_pcm_runtime_t *runtime;
 	runtime = substream->runtime;
-	if (runtime->oss.buffer)
-		vfree(runtime->oss.buffer);
+	vfree(runtime->oss.buffer);
 	snd_pcm_oss_plugin_clear(substream);
 	substream->oss.file = NULL;
 	substream->oss.oss = 0;
diff -uNr a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
--- a/sound/core/oss/pcm_plugin.c	2004-12-24 22:34:29.000000000 +0100
+++ b/sound/core/oss/pcm_plugin.c	2005-01-14 22:28:11.677583168 +0100
@@ -86,8 +86,7 @@
 	snd_assert((size % 8) == 0, return -ENXIO);
 	size /= 8;
 	if (plugin->buf_frames < frames) {
-		if (plugin->buf)
-			vfree(plugin->buf);
+		vfree(plugin->buf);
 		plugin->buf = vmalloc(size);
 		plugin->buf_frames = frames;
 	}
@@ -217,14 +216,10 @@
 		return 0;
 	if (plugin->private_free)
 		plugin->private_free(plugin);
-	if (plugin->buf_channels)
-		kfree(plugin->buf_channels);
-	if (plugin->buf)
-		vfree(plugin->buf);
-	if (plugin->src_vmask)
-		kfree(plugin->src_vmask);
-	if (plugin->dst_vmask)
-		kfree(plugin->dst_vmask);
+	kfree(plugin->buf_channels);
+	vfree(plugin->buf);
+	kfree(plugin->src_vmask);
+	kfree(plugin->dst_vmask);
 	kfree(plugin);
 	return 0;
 }
@@ -390,7 +385,7 @@
 	snd_pcm_plugin_format_t srcformat;
 	int src_access, dst_access;
 	snd_pcm_plugin_t *plugin = NULL;
-	int err, first;
+	int err;
 	int stream = snd_pcm_plug_stream(plug);
 	int slave_interleaved = (params_channels(slave_params) == 1 ||
 				 params_access(slave_params) == SNDRV_PCM_ACCESS_RW_INTERLEAVED);
@@ -442,7 +437,6 @@
 			tmpformat.format = dstformat.format;
 		else
 			tmpformat.format = SNDRV_PCM_FORMAT_S16;
-		first = plugin == NULL;
 		switch (srcformat.format) {
 		case SNDRV_PCM_FORMAT_MU_LAW:
 			err = snd_pcm_plugin_build_mulaw(plug,
@@ -656,8 +650,8 @@
 	return count;
 }
 
-int snd_pcm_plug_playback_channels_mask(snd_pcm_plug_t *plug,
-					bitset_t *client_vmask)
+static int snd_pcm_plug_playback_channels_mask(snd_pcm_plug_t *plug,
+					       bitset_t *client_vmask)
 {
 	snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
 	if (plugin == NULL) {
@@ -687,33 +681,6 @@
 	}
 }
 
-int snd_pcm_plug_capture_channels_mask(snd_pcm_plug_t *plug,
-				       bitset_t *client_vmask)
-{
-	snd_pcm_plugin_t *plugin = snd_pcm_plug_first(plug);
-	if (plugin == NULL) {
-		return 0;
-	} else {
-		int schannels = plugin->src_format.channels;
-		bitset_t bs[bitset_size(schannels)];
-		bitset_t *srcmask = bs;
-		bitset_t *dstmask;
-		int err;
-		bitset_one(srcmask, schannels);
-		while (1) {
-			err = plugin->dst_channels_mask(plugin, srcmask, &dstmask);
-			if (err < 0)
-				return err;
-			srcmask = dstmask;
-			if (plugin->next == NULL)
-				break;
-			plugin = plugin->next;
-		}
-		bitset_and(client_vmask, srcmask, plugin->dst_format.channels);
-		return 0;
-	}
-}
-
 static int snd_pcm_plug_playback_disable_useless_channels(snd_pcm_plug_t *plug,
 							  snd_pcm_plugin_channel_t *src_channels)
 {
diff -uNr a/sound/core/oss/pcm_plugin.h b/sound/core/oss/pcm_plugin.h
--- a/sound/core/oss/pcm_plugin.h	2004-12-24 22:35:24.000000000 +0100
+++ b/sound/core/oss/pcm_plugin.h	2005-01-14 22:28:11.680582712 +0100
@@ -168,7 +168,6 @@
 snd_pcm_sframes_t snd_pcm_plug_client_size(snd_pcm_plug_t *handle, snd_pcm_uframes_t drv_size);
 snd_pcm_sframes_t snd_pcm_plug_slave_size(snd_pcm_plug_t *handle, snd_pcm_uframes_t clt_size);
 
-#define ROUTE_PLUGIN_USE_FLOAT 0
 #define FULL ROUTE_PLUGIN_RESOLUTION
 #define HALF ROUTE_PLUGIN_RESOLUTION / 2
 typedef int route_ttable_entry_t;
diff -uNr a/sound/core/oss/rate.c b/sound/core/oss/rate.c
--- a/sound/core/oss/rate.c	2004-12-24 22:34:45.000000000 +0100
+++ b/sound/core/oss/rate.c	2005-01-14 22:28:11.682582408 +0100
@@ -355,7 +355,9 @@
 		return err;
 	data = (rate_t *)plugin->extra_data;
 	data->get = getput_index(src_format->format);
+	snd_assert(data->get >= 0 && data->get < 4*2*2, return -EINVAL);
 	data->put = getput_index(dst_format->format);
+	snd_assert(data->put >= 0 && data->put < 4*2*2, return -EINVAL);
 
 	if (src_format->rate < dst_format->rate) {
 		data->pitch = ((src_format->rate << SHIFT) + (dst_format->rate >> 1)) / dst_format->rate;
diff -uNr a/sound/core/oss/route.c b/sound/core/oss/route.c
--- a/sound/core/oss/route.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/core/oss/route.c	2005-01-14 22:28:11.687581648 +0100
@@ -46,9 +46,6 @@
 typedef struct {
 	int channel;
 	int as_int;
-#if ROUTE_PLUGIN_USE_FLOAT
-	float as_float;
-#endif
 } ttable_src_t;
 
 struct ttable_dst {
@@ -59,7 +56,7 @@
 };
 
 struct route_private_data {
-	enum {R_UINT32=0, R_UINT64=1, R_FLOAT=2} sum_type;
+	enum {R_UINT32=0, R_UINT64=1} sum_type;
 	int get, put;
 	int conv;
 	int src_sample_size;
@@ -69,9 +66,6 @@
 typedef union {
 	u_int32_t as_uint32;
 	u_int64_t as_uint64;
-#if ROUTE_PLUGIN_USE_FLOAT
-	float as_float;
-#endif
 } sum_t;
 
 
@@ -136,20 +130,13 @@
 #include "plugin_ops.h"
 #undef GET_U_LABELS
 #undef PUT_U32_LABELS
-	static void *zero_labels[3] = { &&zero_int32, &&zero_int64,
-#if ROUTE_PLUGIN_USE_FLOAT
-				 &&zero_float
-#endif
-	};
+	static void *zero_labels[2] = { &&zero_int32, &&zero_int64 };
 	/* sum_type att */
-	static void *add_labels[3 * 2] = { &&add_int32_noatt, &&add_int32_att,
+	static void *add_labels[2 * 2] = { &&add_int32_noatt, &&add_int32_att,
 				    &&add_int64_noatt, &&add_int64_att,
-#if ROUTE_PLUGIN_USE_FLOAT
-				    &&add_float_noatt, &&add_float_att
-#endif
 	};
 	/* sum_type att shift */
-	static void *norm_labels[3 * 2 * 4] = { NULL,
+	static void *norm_labels[2 * 2 * 4] = { NULL,
 					 &&norm_int32_8_noatt,
 					 &&norm_int32_16_noatt,
 					 &&norm_int32_24_noatt,
@@ -165,16 +152,6 @@
 					 &&norm_int64_8_att,
 					 &&norm_int64_16_att,
 					 &&norm_int64_24_att,
-#if ROUTE_PLUGIN_USE_FLOAT
-					 &&norm_float_0,
-					 &&norm_float_8,
-					 &&norm_float_16,
-					 &&norm_float_24,
-					 &&norm_float_0,
-					 &&norm_float_8,
-					 &&norm_float_16,
-					 &&norm_float_24,
-#endif
 	};
 	route_t *data = (route_t *)plugin->extra_data;
 	void *zero, *get, *add, *norm, *put_u32;
@@ -225,11 +202,6 @@
 	zero_int64: 
 		sum.as_uint64 = 0;
 		goto zero_end;
-#if ROUTE_PLUGIN_USE_FLOAT
-	zero_float:
-		sum.as_float = 0.0;
-		goto zero_end;
-#endif
 	zero_end:
 		for (srcidx = 0; srcidx < nsrcs; ++srcidx) {
 			char *src = srcs[srcidx];
@@ -257,15 +229,6 @@
 			if (ttp->as_int)
 				sum.as_uint64 += sample;
 			goto after_sum;
-#if ROUTE_PLUGIN_USE_FLOAT
-		add_float_att:
-			sum.as_float += sample * ttp->as_float;
-			goto after_sum;
-		add_float_noatt:
-			if (ttp->as_int)
-				sum.as_float += sample;
-			goto after_sum;
-#endif
 		after_sum:
 			srcs[srcidx] += src_steps[srcidx];
 			ttp++;
@@ -321,25 +284,6 @@
 			sample = sum.as_uint64;
 		goto after_norm;
 
-#if ROUTE_PLUGIN_USE_FLOAT
-	norm_float_8:
-		sum.as_float *= 1 << 8;
-		goto norm_float;
-	norm_float_16:
-		sum.as_float *= 1 << 16;
-		goto norm_float;
-	norm_float_24:
-		sum.as_float *= 1 << 24;
-		goto norm_float;
-	norm_float_0:
-	norm_float:
-		sum.as_float = floor(sum.as_float + 0.5);
-		if (sum.as_float > (u_int32_t)0xffffffff)
-			sample = (u_int32_t)0xffffffff;
-		else
-			sample = sum.as_float;
-		goto after_norm;
-#endif
 	after_norm:
 		
 		/* Put sample */
@@ -353,9 +297,9 @@
 	}
 }
 
-int route_src_channels_mask(snd_pcm_plugin_t *plugin,
-			  bitset_t *dst_vmask,
-			  bitset_t **src_vmask)
+static int route_src_channels_mask(snd_pcm_plugin_t *plugin,
+				   bitset_t *dst_vmask,
+				   bitset_t **src_vmask)
 {
 	route_t *data = (route_t *)plugin->extra_data;
 	int schannels = plugin->src_format.channels;
@@ -377,9 +321,9 @@
 	return 0;
 }
 
-int route_dst_channels_mask(snd_pcm_plugin_t *plugin,
-			  bitset_t *src_vmask,
-			  bitset_t **dst_vmask)
+static int route_dst_channels_mask(snd_pcm_plugin_t *plugin,
+				   bitset_t *src_vmask,
+				   bitset_t **dst_vmask)
 {
 	route_t *data = (route_t *)plugin->extra_data;
 	int dchannels = plugin->dst_format.channels;
@@ -407,8 +351,7 @@
 	route_t *data = (route_t *)plugin->extra_data;
 	unsigned int dst_channel;
 	for (dst_channel = 0; dst_channel < plugin->dst_format.channels; ++dst_channel) {
-		if (data->ttable[dst_channel].srcs != NULL)
-			kfree(data->ttable[dst_channel].srcs);
+		kfree(data->ttable[dst_channel].srcs);
 	}
 }
 
@@ -434,13 +377,7 @@
 			snd_assert(*sptr >= 0 || *sptr <= FULL, return -ENXIO);
 			if (*sptr != 0) {
 				srcs[nsrcs].channel = src_channel;
-#if ROUTE_PLUGIN_USE_FLOAT
-				/* Also in user space for non attenuated */
-				srcs[nsrcs].as_int = (*sptr == FULL ? ROUTE_PLUGIN_RESOLUTION : 0);
-				srcs[nsrcs].as_float = *sptr;
-#else
 				srcs[nsrcs].as_int = *sptr;
-#endif
 				if (*sptr != FULL)
 					att = 1;
 				t += *sptr;
@@ -559,17 +496,15 @@
 	data = (route_t *) plugin->extra_data;
 
 	data->get = getput_index(src_format->format);
+	snd_assert(data->get >= 0 && data->get < 4*2*2, return -EINVAL);
 	data->put = getput_index(dst_format->format);
+	snd_assert(data->get >= 0 && data->get < 4*2*2, return -EINVAL);
 	data->conv = conv_index(src_format->format, dst_format->format);
 
-#if ROUTE_PLUGIN_USE_FLOAT
-	data->sum_type = R_FLOAT;
-#else
 	if (snd_pcm_format_width(src_format->format) == 32)
 		data->sum_type = R_UINT64;
 	else
 		data->sum_type = R_UINT32;
-#endif
 	data->src_sample_size = snd_pcm_format_width(src_format->format) / 8;
 
 	if ((err = route_load_ttable(plugin, ttable)) < 0) {
diff -uNr a/sound/core/pcm.c b/sound/core/pcm.c
--- a/sound/core/pcm.c	2004-12-24 22:35:49.000000000 +0100
+++ b/sound/core/pcm.c	2005-01-14 22:28:11.692580888 +0100
@@ -126,12 +126,12 @@
 #define FORMAT(v) [SNDRV_PCM_FORMAT_##v] = #v
 #define SUBFORMAT(v) [SNDRV_PCM_SUBFORMAT_##v] = #v 
 
-char *snd_pcm_stream_names[] = {
+static char *snd_pcm_stream_names[] = {
 	STREAM(PLAYBACK),
 	STREAM(CAPTURE),
 };
 
-char *snd_pcm_state_names[] = {
+static char *snd_pcm_state_names[] = {
 	STATE(OPEN),
 	STATE(SETUP),
 	STATE(PREPARED),
@@ -142,7 +142,7 @@
 	STATE(SUSPENDED),
 };
 
-char *snd_pcm_access_names[] = {
+static char *snd_pcm_access_names[] = {
 	ACCESS(MMAP_INTERLEAVED), 
 	ACCESS(MMAP_NONINTERLEAVED),
 	ACCESS(MMAP_COMPLEX),
@@ -150,7 +150,7 @@
 	ACCESS(RW_NONINTERLEAVED),
 };
 
-char *snd_pcm_format_names[] = {
+static char *snd_pcm_format_names[] = {
 	FORMAT(S8),
 	FORMAT(U8),
 	FORMAT(S16_LE),
@@ -191,22 +191,22 @@
 	FORMAT(U18_3BE),
 };
 
-char *snd_pcm_subformat_names[] = {
+static char *snd_pcm_subformat_names[] = {
 	SUBFORMAT(STD), 
 };
 
-char *snd_pcm_tstamp_mode_names[] = {
+static char *snd_pcm_tstamp_mode_names[] = {
 	TSTAMP(NONE),
 	TSTAMP(MMAP),
 };
 
-const char *snd_pcm_stream_name(snd_pcm_stream_t stream)
+static const char *snd_pcm_stream_name(snd_pcm_stream_t stream)
 {
 	snd_assert(stream <= SNDRV_PCM_STREAM_LAST, return NULL);
 	return snd_pcm_stream_names[stream];
 }
 
-const char *snd_pcm_access_name(snd_pcm_access_t access)
+static const char *snd_pcm_access_name(snd_pcm_access_t access)
 {
 	snd_assert(access <= SNDRV_PCM_ACCESS_LAST, return NULL);
 	return snd_pcm_access_names[access];
@@ -218,19 +218,19 @@
 	return snd_pcm_format_names[format];
 }
 
-const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)
+static const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)
 {
 	snd_assert(subformat <= SNDRV_PCM_SUBFORMAT_LAST, return NULL);
 	return snd_pcm_subformat_names[subformat];
 }
 
-const char *snd_pcm_tstamp_mode_name(snd_pcm_tstamp_t mode)
+static const char *snd_pcm_tstamp_mode_name(snd_pcm_tstamp_t mode)
 {
 	snd_assert(mode <= SNDRV_PCM_TSTAMP_LAST, return NULL);
 	return snd_pcm_tstamp_mode_names[mode];
 }
 
-const char *snd_pcm_state_name(snd_pcm_state_t state)
+static const char *snd_pcm_state_name(snd_pcm_state_t state)
 {
 	snd_assert(state <= SNDRV_PCM_STATE_LAST, return NULL);
 	return snd_pcm_state_names[state];
@@ -238,7 +238,7 @@
 
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 #include <linux/soundcard.h>
-const char *snd_pcm_oss_format_name(int format)
+static const char *snd_pcm_oss_format_name(int format)
 {
 	switch (format) {
 	case AFMT_MU_LAW:
@@ -830,8 +830,7 @@
 		runtime->private_free(runtime);
 	snd_free_pages((void*)runtime->status, PAGE_ALIGN(sizeof(snd_pcm_mmap_status_t)));
 	snd_free_pages((void*)runtime->control, PAGE_ALIGN(sizeof(snd_pcm_mmap_control_t)));
-	if (runtime->hw_constraints.rules)
-		kfree(runtime->hw_constraints.rules);
+	kfree(runtime->hw_constraints.rules);
 	kfree(runtime);
 	substream->runtime = NULL;
 	substream->pstr->substream_opened--;
@@ -1035,7 +1034,6 @@
 EXPORT_SYMBOL(snd_pcm_open_substream);
 EXPORT_SYMBOL(snd_pcm_release_substream);
 EXPORT_SYMBOL(snd_pcm_format_name);
-EXPORT_SYMBOL(snd_pcm_subformat_name);
   /* pcm_native.c */
 EXPORT_SYMBOL(snd_pcm_link_rwlock);
 EXPORT_SYMBOL(snd_pcm_start);
@@ -1046,10 +1044,6 @@
 EXPORT_SYMBOL(snd_pcm_kernel_playback_ioctl);
 EXPORT_SYMBOL(snd_pcm_kernel_capture_ioctl);
 EXPORT_SYMBOL(snd_pcm_kernel_ioctl);
-EXPORT_SYMBOL(snd_pcm_open);
-EXPORT_SYMBOL(snd_pcm_release);
-EXPORT_SYMBOL(snd_pcm_playback_poll);
-EXPORT_SYMBOL(snd_pcm_capture_poll);
 EXPORT_SYMBOL(snd_pcm_mmap_data);
 #if SNDRV_PCM_INFO_MMAP_IOMEM
 EXPORT_SYMBOL(snd_pcm_lib_mmap_iomem);
@@ -1062,7 +1056,6 @@
 EXPORT_SYMBOL(snd_pcm_format_big_endian);
 EXPORT_SYMBOL(snd_pcm_format_width);
 EXPORT_SYMBOL(snd_pcm_format_physical_width);
-EXPORT_SYMBOL(snd_pcm_format_size);
 EXPORT_SYMBOL(snd_pcm_format_silence_64);
 EXPORT_SYMBOL(snd_pcm_format_set_silence);
 EXPORT_SYMBOL(snd_pcm_build_linear_format);
diff -uNr a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
--- a/sound/core/pcm_lib.c	2004-12-24 22:34:32.000000000 +0100
+++ b/sound/core/pcm_lib.c	2005-01-14 22:28:11.699579824 +0100
@@ -371,7 +371,7 @@
 	return n;
 }
 
-int snd_interval_refine_min(snd_interval_t *i, unsigned int min, int openmin)
+static int snd_interval_refine_min(snd_interval_t *i, unsigned int min, int openmin)
 {
 	int changed = 0;
 	assert(!snd_interval_empty(i));
@@ -396,7 +396,7 @@
 	return changed;
 }
 
-int snd_interval_refine_max(snd_interval_t *i, unsigned int max, int openmax)
+static int snd_interval_refine_max(snd_interval_t *i, unsigned int max, int openmax)
 {
 	int changed = 0;
 	assert(!snd_interval_empty(i));
@@ -474,7 +474,7 @@
 	return changed;
 }
 
-int snd_interval_refine_first(snd_interval_t *i)
+static int snd_interval_refine_first(snd_interval_t *i)
 {
 	assert(!snd_interval_empty(i));
 	if (snd_interval_single(i))
@@ -486,7 +486,7 @@
 	return 1;
 }
 
-int snd_interval_refine_last(snd_interval_t *i)
+static int snd_interval_refine_last(snd_interval_t *i)
 {
 	assert(!snd_interval_empty(i));
 	if (snd_interval_single(i))
@@ -498,7 +498,7 @@
 	return 1;
 }
 
-int snd_interval_refine_set(snd_interval_t *i, unsigned int val)
+static int snd_interval_refine_set(snd_interval_t *i, unsigned int val)
 {
 	snd_interval_t t;
 	t.empty = 0;
@@ -718,9 +718,9 @@
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-int snd_interval_ratden(snd_interval_t *i,
-		    unsigned int rats_count, ratden_t *rats,
-		    unsigned int *nump, unsigned int *denp)
+static int snd_interval_ratden(snd_interval_t *i,
+			       unsigned int rats_count, ratden_t *rats,
+			       unsigned int *nump, unsigned int *denp)
 {
 	unsigned int best_num, best_diff, best_den;
 	unsigned int k;
@@ -858,7 +858,7 @@
         return changed;
 }
 
-int snd_interval_step(snd_interval_t *i, unsigned int min, unsigned int step)
+static int snd_interval_step(snd_interval_t *i, unsigned int min, unsigned int step)
 {
 	unsigned int n;
 	int changed = 0;
@@ -1856,80 +1856,6 @@
  *  Conditions
  */
 
-/**
- * snd_pcm_playback_ready - check whether the playback buffer is available
- * @substream: the pcm substream instance
- *
- * Checks whether enough free space is available on the playback buffer.
- *
- * Returns non-zero if available, or zero if not.
- */
-int snd_pcm_playback_ready(snd_pcm_substream_t *substream)
-{
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	return snd_pcm_playback_avail(runtime) >= runtime->control->avail_min;
-}
-
-/**
- * snd_pcm_capture_ready - check whether the capture buffer is available
- * @substream: the pcm substream instance
- *
- * Checks whether enough capture data is available on the capture buffer.
- *
- * Returns non-zero if available, or zero if not.
- */
-int snd_pcm_capture_ready(snd_pcm_substream_t *substream)
-{
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	return snd_pcm_capture_avail(runtime) >= runtime->control->avail_min;
-}
-
-/**
- * snd_pcm_playback_data - check whether any data exists on the playback buffer
- * @substream: the pcm substream instance
- *
- * Checks whether any data exists on the playback buffer. If stop_threshold
- * is bigger or equal to boundary, then this function returns always non-zero.
- *
- * Returns non-zero if exists, or zero if not.
- */
-int snd_pcm_playback_data(snd_pcm_substream_t *substream)
-{
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	
-	if (runtime->stop_threshold >= runtime->boundary)
-		return 1;
-	return snd_pcm_playback_avail(runtime) < runtime->buffer_size;
-}
-
-/**
- * snd_pcm_playback_empty - check whether the playback buffer is empty
- * @substream: the pcm substream instance
- *
- * Checks whether the playback buffer is empty.
- *
- * Returns non-zero if empty, or zero if not.
- */
-int snd_pcm_playback_empty(snd_pcm_substream_t *substream)
-{
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	return snd_pcm_playback_avail(runtime) >= runtime->buffer_size;
-}
-
-/**
- * snd_pcm_capture_empty - check whether the capture buffer is empty
- * @substream: the pcm substream instance
- *
- * Checks whether the capture buffer is empty.
- *
- * Returns non-zero if empty, or zero if not.
- */
-int snd_pcm_capture_empty(snd_pcm_substream_t *substream)
-{
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	return snd_pcm_capture_avail(runtime) == 0;
-}
-
 static void snd_pcm_system_tick_set(snd_pcm_substream_t *substream, 
 				    unsigned long ticks)
 {
@@ -2643,7 +2569,6 @@
 EXPORT_SYMBOL(snd_interval_refine);
 EXPORT_SYMBOL(snd_interval_list);
 EXPORT_SYMBOL(snd_interval_ratnum);
-EXPORT_SYMBOL(snd_interval_ratden);
 EXPORT_SYMBOL(snd_interval_muldivk);
 EXPORT_SYMBOL(snd_interval_mulkdiv);
 EXPORT_SYMBOL(snd_interval_div);
@@ -2660,6 +2585,7 @@
 EXPORT_SYMBOL(snd_pcm_hw_param_near);
 EXPORT_SYMBOL(snd_pcm_hw_param_set);
 EXPORT_SYMBOL(snd_pcm_hw_refine);
+EXPORT_SYMBOL(snd_pcm_hw_params);
 EXPORT_SYMBOL(snd_pcm_hw_constraints_init);
 EXPORT_SYMBOL(snd_pcm_hw_constraints_complete);
 EXPORT_SYMBOL(snd_pcm_hw_constraint_list);
@@ -2674,10 +2600,6 @@
 EXPORT_SYMBOL(snd_pcm_set_ops);
 EXPORT_SYMBOL(snd_pcm_set_sync);
 EXPORT_SYMBOL(snd_pcm_lib_ioctl);
-EXPORT_SYMBOL(snd_pcm_playback_ready);
-EXPORT_SYMBOL(snd_pcm_capture_ready);
-EXPORT_SYMBOL(snd_pcm_playback_data);
-EXPORT_SYMBOL(snd_pcm_capture_empty);
 EXPORT_SYMBOL(snd_pcm_stop);
 EXPORT_SYMBOL(snd_pcm_period_elapsed);
 EXPORT_SYMBOL(snd_pcm_lib_write);
@@ -2687,7 +2609,6 @@
 EXPORT_SYMBOL(snd_pcm_lib_buffer_bytes);
 EXPORT_SYMBOL(snd_pcm_lib_period_bytes);
 /* pcm_memory.c */
-EXPORT_SYMBOL(snd_pcm_lib_preallocate_free);
 EXPORT_SYMBOL(snd_pcm_lib_preallocate_free_for_all);
 EXPORT_SYMBOL(snd_pcm_lib_preallocate_pages);
 EXPORT_SYMBOL(snd_pcm_lib_preallocate_pages_for_all);
diff -uNr a/sound/core/pcm_memory.c b/sound/core/pcm_memory.c
--- a/sound/core/pcm_memory.c	2004-12-24 22:35:15.000000000 +0100
+++ b/sound/core/pcm_memory.c	2005-01-14 22:28:11.701579520 +0100
@@ -37,7 +37,7 @@
 module_param(maximum_substreams, int, 0444);
 MODULE_PARM_DESC(maximum_substreams, "Maximum substreams with preallocated DMA memory.");
 
-const static size_t snd_minimum_buffer = 16384;
+static const size_t snd_minimum_buffer = 16384;
 
 
 /*
diff -uNr a/sound/core/pcm_native.c b/sound/core/pcm_native.c
--- a/sound/core/pcm_native.c	2004-12-24 22:34:30.000000000 +0100
+++ b/sound/core/pcm_native.c	2005-01-14 22:28:11.710578152 +0100
@@ -329,8 +329,8 @@
 	return err;
 }
 
-static int snd_pcm_hw_params(snd_pcm_substream_t *substream,
-			     snd_pcm_hw_params_t *params)
+int snd_pcm_hw_params(snd_pcm_substream_t *substream,
+		      snd_pcm_hw_params_t *params)
 {
 	snd_pcm_runtime_t *runtime;
 	int err;
@@ -1445,7 +1445,7 @@
 
  _end:
 	snd_pcm_stream_unlock_irq(substream);
-	if (drec && drec != &drec_tmp)
+	if (drec != &drec_tmp)
 		kfree(drec);
  _unlock:
 	snd_power_unlock(card);
@@ -2020,7 +2020,7 @@
 	return 0;
 }
 
-int snd_pcm_open(struct inode *inode, struct file *file)
+static int snd_pcm_open(struct inode *inode, struct file *file)
 {
 	int cardnum = SNDRV_MINOR_CARD(iminor(inode));
 	int device = SNDRV_MINOR_DEVICE(iminor(inode));
@@ -2079,7 +2079,7 @@
       	return err;
 }
 
-int snd_pcm_release(struct inode *inode, struct file *file)
+static int snd_pcm_release(struct inode *inode, struct file *file)
 {
 	snd_pcm_t *pcm;
 	snd_pcm_substream_t *substream;
@@ -2101,7 +2101,7 @@
 	return 0;
 }
 
-snd_pcm_sframes_t snd_pcm_playback_rewind(snd_pcm_substream_t *substream, snd_pcm_uframes_t frames)
+static snd_pcm_sframes_t snd_pcm_playback_rewind(snd_pcm_substream_t *substream, snd_pcm_uframes_t frames)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_pcm_sframes_t appl_ptr;
@@ -2150,7 +2150,7 @@
 	return ret;
 }
 
-snd_pcm_sframes_t snd_pcm_capture_rewind(snd_pcm_substream_t *substream, snd_pcm_uframes_t frames)
+static snd_pcm_sframes_t snd_pcm_capture_rewind(snd_pcm_substream_t *substream, snd_pcm_uframes_t frames)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_pcm_sframes_t appl_ptr;
@@ -2199,7 +2199,7 @@
 	return ret;
 }
 
-snd_pcm_sframes_t snd_pcm_playback_forward(snd_pcm_substream_t *substream, snd_pcm_uframes_t frames)
+static snd_pcm_sframes_t snd_pcm_playback_forward(snd_pcm_substream_t *substream, snd_pcm_uframes_t frames)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_pcm_sframes_t appl_ptr;
@@ -2249,7 +2249,7 @@
 	return ret;
 }
 
-snd_pcm_sframes_t snd_pcm_capture_forward(snd_pcm_substream_t *substream, snd_pcm_uframes_t frames)
+static snd_pcm_sframes_t snd_pcm_capture_forward(snd_pcm_substream_t *substream, snd_pcm_uframes_t frames)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_pcm_sframes_t appl_ptr;
@@ -2835,7 +2835,7 @@
 	return result;
 }
 
-unsigned int snd_pcm_playback_poll(struct file *file, poll_table * wait)
+static unsigned int snd_pcm_playback_poll(struct file *file, poll_table * wait)
 {
 	snd_pcm_file_t *pcm_file;
 	snd_pcm_substream_t *substream;
@@ -2873,7 +2873,7 @@
 	return mask;
 }
 
-unsigned int snd_pcm_capture_poll(struct file *file, poll_table * wait)
+static unsigned int snd_pcm_capture_poll(struct file *file, poll_table * wait)
 {
 	snd_pcm_file_t *pcm_file;
 	snd_pcm_substream_t *substream;
diff -uNr a/sound/core/rawmidi.c b/sound/core/rawmidi.c
--- a/sound/core/rawmidi.c	2004-12-24 22:34:01.000000000 +0100
+++ b/sound/core/rawmidi.c	2005-01-14 22:28:25.642460184 +0100
@@ -54,7 +54,7 @@
 static int snd_rawmidi_dev_disconnect(snd_device_t *device);
 static int snd_rawmidi_dev_unregister(snd_device_t *device);
 
-snd_rawmidi_t *snd_rawmidi_devices[SNDRV_CARDS * SNDRV_RAWMIDI_DEVICES];
+static snd_rawmidi_t *snd_rawmidi_devices[SNDRV_CARDS * SNDRV_RAWMIDI_DEVICES];
 
 static DECLARE_MUTEX(register_mutex);
 
@@ -747,7 +747,7 @@
 	case SNDRV_RAWMIDI_IOCTL_DROP:
 	{
 		int val;
-		if (get_user(val, (long __user *) argp))
+		if (get_user(val, (int __user *) argp))
 			return -EFAULT;
 		switch (val) {
 		case SNDRV_RAWMIDI_STREAM_OUTPUT:
@@ -761,7 +761,7 @@
 	case SNDRV_RAWMIDI_IOCTL_DRAIN:
 	{
 		int val;
-		if (get_user(val, (long __user *) argp))
+		if (get_user(val, (int __user *) argp))
 			return -EFAULT;
 		switch (val) {
 		case SNDRV_RAWMIDI_STREAM_OUTPUT:
@@ -795,8 +795,10 @@
 	return err;
 }
 
-int snd_rawmidi_control_ioctl(snd_card_t * card, snd_ctl_file_t * control,
-			      unsigned int cmd, unsigned long arg)
+static int snd_rawmidi_control_ioctl(snd_card_t * card,
+				     snd_ctl_file_t * control,
+				     unsigned int cmd,
+				     unsigned long arg)
 {
 	void __user *argp = (void __user *)arg;
 	unsigned int tmp;
diff -uNr a/sound/core/seq/instr/ainstr_fm.c b/sound/core/seq/instr/ainstr_fm.c
--- a/sound/core/seq/instr/ainstr_fm.c	2004-12-24 22:34:32.000000000 +0100
+++ b/sound/core/seq/instr/ainstr_fm.c	2005-01-14 22:28:11.718576936 +0100
@@ -30,8 +30,6 @@
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture FM Instrument support.");
 MODULE_LICENSE("GPL");
 
-char *snd_seq_fm_id = SNDRV_SEQ_INSTR_ID_OPL2_3;
-
 static int snd_seq_fm_put(void *private_data, snd_seq_kinstr_t *instr,
 			  char __user *instr_data, long len, int atomic, int cmd)
 {
@@ -129,7 +127,7 @@
 	memset(ops, 0, sizeof(*ops));
 	// ops->private_data = private_data;
 	ops->add_len = sizeof(fm_instrument_t);
-	ops->instr_type = snd_seq_fm_id;
+	ops->instr_type = SNDRV_SEQ_INSTR_ID_OPL2_3;
 	ops->put = snd_seq_fm_put;
 	ops->get = snd_seq_fm_get;
 	ops->get_size = snd_seq_fm_get_size;
@@ -155,5 +153,4 @@
 module_init(alsa_ainstr_fm_init)
 module_exit(alsa_ainstr_fm_exit)
 
-EXPORT_SYMBOL(snd_seq_fm_id);
 EXPORT_SYMBOL(snd_seq_fm_init);
diff -uNr a/sound/core/seq/instr/ainstr_gf1.c b/sound/core/seq/instr/ainstr_gf1.c
--- a/sound/core/seq/instr/ainstr_gf1.c	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/core/seq/instr/ainstr_gf1.c	2005-01-14 22:28:11.723576176 +0100
@@ -31,8 +31,6 @@
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture GF1 (GUS) Patch support.");
 MODULE_LICENSE("GPL");
 
-char *snd_seq_gf1_id = SNDRV_SEQ_INSTR_ID_GUS_PATCH;
-
 static unsigned int snd_seq_gf1_size(unsigned int size, unsigned int format)
 {
 	unsigned int result = size;
@@ -331,7 +329,7 @@
 	ops->private_data = private_data;
 	ops->kops.private_data = ops;
 	ops->kops.add_len = sizeof(gf1_instrument_t);
-	ops->kops.instr_type = snd_seq_gf1_id;
+	ops->kops.instr_type = SNDRV_SEQ_INSTR_ID_GUS_PATCH;
 	ops->kops.put = snd_seq_gf1_put;
 	ops->kops.get = snd_seq_gf1_get;
 	ops->kops.get_size = snd_seq_gf1_get_size;
@@ -357,5 +355,4 @@
 module_init(alsa_ainstr_gf1_init)
 module_exit(alsa_ainstr_gf1_exit)
 
-EXPORT_SYMBOL(snd_seq_gf1_id);
 EXPORT_SYMBOL(snd_seq_gf1_init);
diff -uNr a/sound/core/seq/instr/ainstr_iw.c b/sound/core/seq/instr/ainstr_iw.c
--- a/sound/core/seq/instr/ainstr_iw.c	2004-12-24 22:34:45.000000000 +0100
+++ b/sound/core/seq/instr/ainstr_iw.c	2005-01-14 22:28:11.727575568 +0100
@@ -31,8 +31,6 @@
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture IWFFFF support.");
 MODULE_LICENSE("GPL");
 
-char *snd_seq_iwffff_id = SNDRV_SEQ_INSTR_ID_INTERWAVE;
-
 static unsigned int snd_seq_iwffff_size(unsigned int size, unsigned int format)
 {
 	unsigned int result = size;
@@ -595,7 +593,7 @@
 	ops->private_data = private_data;
 	ops->kops.private_data = ops;
 	ops->kops.add_len = sizeof(iwffff_instrument_t);
-	ops->kops.instr_type = snd_seq_iwffff_id;
+	ops->kops.instr_type = SNDRV_SEQ_INSTR_ID_INTERWAVE;
 	ops->kops.put = snd_seq_iwffff_put;
 	ops->kops.get = snd_seq_iwffff_get;
 	ops->kops.get_size = snd_seq_iwffff_get_size;
@@ -621,5 +619,4 @@
 module_init(alsa_ainstr_iw_init)
 module_exit(alsa_ainstr_iw_exit)
 
-EXPORT_SYMBOL(snd_seq_iwffff_id);
 EXPORT_SYMBOL(snd_seq_iwffff_init);
diff -uNr a/sound/core/seq/instr/ainstr_simple.c b/sound/core/seq/instr/ainstr_simple.c
--- a/sound/core/seq/instr/ainstr_simple.c	2004-12-24 22:35:24.000000000 +0100
+++ b/sound/core/seq/instr/ainstr_simple.c	2005-01-14 22:28:11.730575112 +0100
@@ -31,8 +31,6 @@
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture Simple Instrument support.");
 MODULE_LICENSE("GPL");
 
-char *snd_seq_simple_id = SNDRV_SEQ_INSTR_ID_SIMPLE;
-
 static unsigned int snd_seq_simple_size(unsigned int size, unsigned int format)
 {
 	unsigned int result = size;
@@ -188,7 +186,7 @@
 	ops->private_data = private_data;
 	ops->kops.private_data = ops;
 	ops->kops.add_len = sizeof(simple_instrument_t);
-	ops->kops.instr_type = snd_seq_simple_id;
+	ops->kops.instr_type = SNDRV_SEQ_INSTR_ID_SIMPLE;
 	ops->kops.put = snd_seq_simple_put;
 	ops->kops.get = snd_seq_simple_get;
 	ops->kops.get_size = snd_seq_simple_get_size;
@@ -214,5 +212,4 @@
 module_init(alsa_ainstr_simple_init)
 module_exit(alsa_ainstr_simple_exit)
 
-EXPORT_SYMBOL(snd_seq_simple_id);
 EXPORT_SYMBOL(snd_seq_simple_init);
diff -uNr a/sound/core/seq/Makefile b/sound/core/seq/Makefile
--- a/sound/core/seq/Makefile	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/core/seq/Makefile	2005-01-14 22:28:11.731574960 +0100
@@ -37,6 +37,8 @@
 obj-$(CONFIG_SND_VIRMIDI) += snd-seq-virmidi.o snd-seq-midi-event.o
 obj-$(call sequencer,$(CONFIG_SND_RAWMIDI)) += snd-seq-midi.o snd-seq-midi-event.o
 obj-$(call sequencer,$(CONFIG_SND_OPL3_LIB)) += snd-seq-midi-event.o snd-seq-midi-emul.o snd-seq-instr.o
+obj-$(call sequencer,$(CONFIG_SND_OPL4_LIB)) += snd-seq-midi-event.o snd-seq-midi-emul.o snd-seq-instr.o
+obj-$(call sequencer,$(CONFIG_SND_GUS_SYNTH)) += snd-seq-instr.o
 obj-$(call sequencer,$(CONFIG_SND_SBAWE)) += snd-seq-midi-emul.o snd-seq-virmidi.o
 obj-$(call sequencer,$(CONFIG_SND_EMU10K1)) += snd-seq-midi-emul.o snd-seq-virmidi.o
 obj-$(call sequencer,$(CONFIG_SND_TRIDENT)) += snd-seq-midi-emul.o snd-seq-instr.o
diff -uNr a/sound/core/seq/oss/seq_oss_device.h b/sound/core/seq/oss/seq_oss_device.h
--- a/sound/core/seq/oss/seq_oss_device.h	2004-12-24 22:34:46.000000000 +0100
+++ b/sound/core/seq/oss/seq_oss_device.h	2005-01-14 22:28:11.734574504 +0100
@@ -185,7 +185,6 @@
 
 /* misc. functions for proc interface */
 char *enabled_str(int bool);
-char *filemode_str(int fmode);
 
 
 /* for debug */
diff -uNr a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
--- a/sound/core/seq/oss/seq_oss_init.c	2004-12-24 22:33:51.000000000 +0100
+++ b/sound/core/seq/oss/seq_oss_init.c	2005-01-14 22:28:11.737574048 +0100
@@ -491,6 +491,26 @@
 	snd_seq_oss_timer_stop(dp->timer);
 }
 
+
+/*
+ * misc. functions for proc interface
+ */
+char *
+enabled_str(int bool)
+{
+	return bool ? "enabled" : "disabled";
+}
+
+static char *
+filemode_str(int val)
+{
+	static char *str[] = {
+		"none", "read", "write", "read/write",
+	};
+	return str[val & SNDRV_SEQ_OSS_FILE_ACMODE];
+}
+
+
 /*
  * proc interface
  */
@@ -523,22 +543,3 @@
 	}
 }
 
-/*
- * misc. functions for proc interface
- */
-char *
-enabled_str(int bool)
-{
-	return bool ? "enabled" : "disabled";
-}
-
-char *
-filemode_str(int val)
-{
-	static char *str[] = {
-		"none", "read", "write", "read/write",
-	};
-	return str[val & SNDRV_SEQ_OSS_FILE_ACMODE];
-}
-
-
diff -uNr a/sound/core/seq/oss/seq_oss_misc.c b/sound/core/seq/oss/seq_oss_misc.c
--- a/sound/core/seq/oss/seq_oss_misc.c	2004-12-24 22:33:59.000000000 +0100
+++ b/sound/core/seq/oss/seq_oss_misc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,110 +0,0 @@
-/*----------------------------------------------------------------
- * miscellaneous functions
- *----------------------------------------------------------------*/
-
-unsigned short snd_seq_oss_semitone_tuning[24] = 
-{
-/*   0 */ 10000, 10595, 11225, 11892, 12599, 13348, 14142, 14983, 
-/*   8 */ 15874, 16818, 17818, 18877, 20000, 21189, 22449, 23784, 
-/*  16 */ 25198, 26697, 28284, 29966, 31748, 33636, 35636, 37755
-};
-
-unsigned short snd_seq_oss_cent_tuning[100] =
-{
-/*   0 */ 10000, 10006, 10012, 10017, 10023, 10029, 10035, 10041, 
-/*   8 */ 10046, 10052, 10058, 10064, 10070, 10075, 10081, 10087, 
-/*  16 */ 10093, 10099, 10105, 10110, 10116, 10122, 10128, 10134, 
-/*  24 */ 10140, 10145, 10151, 10157, 10163, 10169, 10175, 10181, 
-/*  32 */ 10187, 10192, 10198, 10204, 10210, 10216, 10222, 10228, 
-/*  40 */ 10234, 10240, 10246, 10251, 10257, 10263, 10269, 10275, 
-/*  48 */ 10281, 10287, 10293, 10299, 10305, 10311, 10317, 10323, 
-/*  56 */ 10329, 10335, 10341, 10347, 10353, 10359, 10365, 10371, 
-/*  64 */ 10377, 10383, 10389, 10395, 10401, 10407, 10413, 10419, 
-/*  72 */ 10425, 10431, 10437, 10443, 10449, 10455, 10461, 10467, 
-/*  80 */ 10473, 10479, 10485, 10491, 10497, 10503, 10509, 10515, 
-/*  88 */ 10521, 10528, 10534, 10540, 10546, 10552, 10558, 10564, 
-/*  96 */ 10570, 10576, 10582, 10589
-};
-
-/* convert from MIDI note to frequency */
-int
-snd_seq_oss_note_to_freq(int note_num)
-{
-
-	/*
-	 * This routine converts a midi note to a frequency (multiplied by 1000)
-	 */
-
-	int note, octave, note_freq;
-	static int notes[] = {
-		261632, 277189, 293671, 311132, 329632, 349232,
-		369998, 391998, 415306, 440000, 466162, 493880
-	};
-
-#define BASE_OCTAVE	5
-
-	octave = note_num / 12;
-	note = note_num % 12;
-
-	note_freq = notes[note];
-
-	if (octave < BASE_OCTAVE)
-		note_freq >>= (BASE_OCTAVE - octave);
-	else if (octave > BASE_OCTAVE)
-		note_freq <<= (octave - BASE_OCTAVE);
-
-	/*
-	 * note_freq >>= 1;
-	 */
-
-	return note_freq;
-}
-
-unsigned long
-snd_seq_oss_compute_finetune(unsigned long base_freq, int bend, int range, int vibrato_cents)
-{
-	unsigned long amount;
-	int negative, semitones, cents, multiplier = 1;
-
-	if (!bend || !range || !base_freq)
-		return base_freq;
-
-	if (range >= 8192)
-		range = 8192;
-
-	bend = bend * range / 8192;	/* Convert to cents */
-	bend += vibrato_cents;
-
-	if (!bend)
-		return base_freq;
-
-	negative = bend < 0 ? 1 : 0;
-
-	if (bend < 0)
-		bend *= -1;
-	if (bend > range)
-		bend = range;
-
-	/*
-	   if (bend > 2399)
-	   bend = 2399;
-	 */
-	while (bend > 2399) {
-		multiplier *= 4;
-		bend -= 2400;
-	}
-
-	semitones = bend / 100;
-	if (semitones > 99)
-		semitones = 99;
-	cents = bend % 100;
-
-	amount = (int) (snd_seq_oss_semitone_tuning[semitones] * multiplier *
-			snd_seq_oss_cent_tuning[cents]) / 10000;
-
-	if (negative)
-		return (base_freq * 10000) / amount;	/* Bend down */
-	else
-		return (base_freq * amount) / 10000;	/* Bend up */
-}
-
diff -uNr a/sound/core/seq/oss/seq_oss_readq.c b/sound/core/seq/oss/seq_oss_readq.c
--- a/sound/core/seq/oss/seq_oss_readq.c	2004-12-24 22:34:26.000000000 +0100
+++ b/sound/core/seq/oss/seq_oss_readq.c	2005-01-14 22:28:11.747572528 +0100
@@ -74,8 +74,7 @@
 snd_seq_oss_readq_delete(seq_oss_readq_t *q)
 {
 	if (q) {
-		if (q->q)
-			kfree(q->q);
+		kfree(q->q);
 		kfree(q);
 	}
 }
diff -uNr a/sound/core/seq/oss/seq_oss_timer.c b/sound/core/seq/oss/seq_oss_timer.c
--- a/sound/core/seq/oss/seq_oss_timer.c	2004-12-24 22:34:26.000000000 +0100
+++ b/sound/core/seq/oss/seq_oss_timer.c	2005-01-14 22:28:11.749572224 +0100
@@ -149,7 +149,7 @@
 	ev.queue = dp->queue;
 	ev.data.queue.queue = dp->queue;
 	ev.data.queue.param.value = value;
-	return snd_seq_kernel_client_dispatch(dp->cseq, &ev, 0, 0);
+	return snd_seq_kernel_client_dispatch(dp->cseq, &ev, 1, 0);
 }
 
 /*
diff -uNr a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c
--- a/sound/core/seq/seq_clientmgr.c	2004-12-24 22:34:00.000000000 +0100
+++ b/sound/core/seq/seq_clientmgr.c	2005-01-14 22:28:11.756571160 +0100
@@ -751,8 +751,8 @@
  *               n == 0 : the event was not passed to any client.
  *               n < 0  : error - event was not processed.
  */
-int snd_seq_deliver_event(client_t *client, snd_seq_event_t *event,
-			  int atomic, int hop)
+static int snd_seq_deliver_event(client_t *client, snd_seq_event_t *event,
+				 int atomic, int hop)
 {
 	int result;
 
@@ -904,7 +904,7 @@
 		return -ENXIO; /* queue is not allocated */
 
 	/* allocate an event cell */
-	err = snd_seq_event_dup(client->pool, event, &cell, !blocking && !atomic, file);
+	err = snd_seq_event_dup(client->pool, event, &cell, !blocking || atomic, file);
 	if (err < 0)
 		return err;
 
diff -uNr a/sound/core/seq/seq_clientmgr.h b/sound/core/seq/seq_clientmgr.h
--- a/sound/core/seq/seq_clientmgr.h	2004-12-24 22:35:25.000000000 +0100
+++ b/sound/core/seq/seq_clientmgr.h	2005-01-14 22:28:11.758570856 +0100
@@ -100,6 +100,5 @@
 int snd_seq_kernel_client_enqueue_blocking(int client, snd_seq_event_t * ev, struct file *file, int atomic, int hop);
 int snd_seq_kernel_client_write_poll(int clientid, struct file *file, poll_table *wait);
 int snd_seq_client_notify_subscription(int client, int port, snd_seq_port_subscribe_t *info, int evtype);
-int snd_seq_deliver_event(client_t *client, snd_seq_event_t *event, int atomic, int hop);
 
 #endif
diff -uNr a/sound/core/seq/seq_instr.c b/sound/core/seq/seq_instr.c
--- a/sound/core/seq/seq_instr.c	2004-12-24 22:34:31.000000000 +0100
+++ b/sound/core/seq/seq_instr.c	2005-01-14 22:28:11.761570400 +0100
@@ -49,19 +49,7 @@
 	}
 }
 
-snd_seq_kcluster_t *snd_seq_cluster_new(int atomic)
-{
-	return kcalloc(1, sizeof(snd_seq_kcluster_t), atomic ? GFP_ATOMIC : GFP_KERNEL);
-}
-
-void snd_seq_cluster_free(snd_seq_kcluster_t *cluster, int atomic)
-{
-	if (cluster == NULL)
-		return;
-	kfree(cluster);
-}
-
-snd_seq_kinstr_t *snd_seq_instr_new(int add_len, int atomic)
+static snd_seq_kinstr_t *snd_seq_instr_new(int add_len, int atomic)
 {
 	snd_seq_kinstr_t *instr;
 	
@@ -72,7 +60,7 @@
 	return instr;
 }
 
-int snd_seq_instr_free(snd_seq_kinstr_t *instr, int atomic)
+static int snd_seq_instr_free(snd_seq_kinstr_t *instr, int atomic)
 {
 	int result = 0;
 
@@ -132,7 +120,7 @@
 		while ((cluster = list->chash[idx]) != NULL) {
 			list->chash[idx] = cluster->next;
 			list->ccount--;
-			snd_seq_cluster_free(cluster, 0);
+			kfree(cluster);
 		}
 	}
 	kfree(list);
diff -uNr a/sound/core/seq/seq_memory.c b/sound/core/seq/seq_memory.c
--- a/sound/core/seq/seq_memory.c	2004-12-24 22:33:59.000000000 +0100
+++ b/sound/core/seq/seq_memory.c	2005-01-14 22:28:11.763570096 +0100
@@ -215,7 +215,7 @@
 /*
  * allocate an event cell.
  */
-int snd_seq_cell_alloc(pool_t *pool, snd_seq_event_cell_t **cellp, int nonblock, struct file *file)
+static int snd_seq_cell_alloc(pool_t *pool, snd_seq_event_cell_t **cellp, int nonblock, struct file *file)
 {
 	snd_seq_event_cell_t *cell;
 	unsigned long flags;
@@ -436,8 +436,7 @@
 	pool->total_elements = 0;
 	spin_unlock_irqrestore(&pool->lock, flags);
 
-	if (ptr)
-		vfree(ptr);
+	vfree(ptr);
 
 	spin_lock_irqsave(&pool->lock, flags);
 	pool->closing = 0;
diff -uNr a/sound/core/seq/seq_memory.h b/sound/core/seq/seq_memory.h
--- a/sound/core/seq/seq_memory.h	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/core/seq/seq_memory.h	2005-01-14 22:28:11.769569184 +0100
@@ -64,7 +64,6 @@
 };
 
 extern void snd_seq_cell_free(snd_seq_event_cell_t* cell);
-int snd_seq_cell_alloc(pool_t *pool, snd_seq_event_cell_t **cellp, int nonblock, struct file *file);
 
 int snd_seq_event_dup(pool_t *pool, snd_seq_event_t *event, snd_seq_event_cell_t **cellp, int nonblock, struct file *file);
 
diff -uNr a/sound/core/seq/seq_midi.c b/sound/core/seq/seq_midi.c
--- a/sound/core/seq/seq_midi.c	2004-12-24 22:36:01.000000000 +0100
+++ b/sound/core/seq/seq_midi.c	2005-01-14 22:28:11.772568728 +0100
@@ -43,10 +43,10 @@
 MODULE_AUTHOR("Frank van de Pol <fvdpol@coil.demon.nl>, Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture sequencer MIDI synth.");
 MODULE_LICENSE("GPL");
-int output_buffer_size = PAGE_SIZE;
+static int output_buffer_size = PAGE_SIZE;
 module_param(output_buffer_size, int, 0644);
 MODULE_PARM_DESC(output_buffer_size, "Output buffer size in bytes.");
-int input_buffer_size = PAGE_SIZE;
+static int input_buffer_size = PAGE_SIZE;
 module_param(input_buffer_size, int, 0644);
 MODULE_PARM_DESC(input_buffer_size, "Input buffer size in bytes.");
 
@@ -284,7 +284,7 @@
 }
 
 /* register new midi synth port */
-int
+static int
 snd_seq_midisynth_register_port(snd_seq_device_t *dev)
 {
 	seq_midisynth_client_t *client;
@@ -423,7 +423,7 @@
 }
 
 /* release midi synth port */
-int
+static int
 snd_seq_midisynth_unregister_port(snd_seq_device_t *dev)
 {
 	seq_midisynth_client_t *client;
diff -uNr a/sound/core/seq/seq_midi_emul.c b/sound/core/seq/seq_midi_emul.c
--- a/sound/core/seq/seq_midi_emul.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/core/seq/seq_midi_emul.c	2005-01-14 22:28:11.776568120 +0100
@@ -53,7 +53,7 @@
 static void sysex(snd_midi_op_t *ops, void *private, unsigned char *sysex, int len, snd_midi_channel_set_t *chset);
 static void all_sounds_off(snd_midi_op_t *ops, void *private, snd_midi_channel_t *chan);
 static void all_notes_off(snd_midi_op_t *ops, void *private, snd_midi_channel_t *chan);
-void snd_midi_reset_controllers(snd_midi_channel_t *chan);
+static void snd_midi_reset_controllers(snd_midi_channel_t *chan);
 static void reset_all_channels(snd_midi_channel_set_t *chset);
 
 
@@ -549,12 +549,12 @@
 
 		} else if (buf[5] == 0x01 && buf[6] == 0x30) {
 			/* reverb mode */
-			parsed = SNDRV_MIDI_SYSEX_GS_CHORUS_MODE;
+			parsed = SNDRV_MIDI_SYSEX_GS_REVERB_MODE;
 			chset->gs_reverb_mode = buf[7];
 
 		} else if (buf[5] == 0x01 && buf[6] == 0x38) {
 			/* chorus mode */
-			parsed = SNDRV_MIDI_SYSEX_GS_REVERB_MODE;
+			parsed = SNDRV_MIDI_SYSEX_GS_CHORUS_MODE;
 			chset->gs_chorus_mode = buf[7];
 
 		} else if (buf[5] == 0x00 && buf[6] == 0x04) {
@@ -621,7 +621,7 @@
 /*
  * Initialise a single midi channel control block.
  */
-void snd_midi_channel_init(snd_midi_channel_t *p, int n)
+static void snd_midi_channel_init(snd_midi_channel_t *p, int n)
 {
 	if (p == NULL)
 		return;
@@ -642,7 +642,7 @@
 /*
  * Allocate and initialise a set of midi channel control blocks.
  */
-snd_midi_channel_t *snd_midi_channel_init_set(int n)
+static snd_midi_channel_t *snd_midi_channel_init_set(int n)
 {
 	snd_midi_channel_t *chan;
 	int  i;
@@ -697,7 +697,7 @@
 /*
  * Reset the midi controllers on a particular channel to default values.
  */
-void snd_midi_reset_controllers(snd_midi_channel_t *chan)
+static void snd_midi_reset_controllers(snd_midi_channel_t *chan)
 {
 	memset(chan->control, 0, sizeof(chan->control));
 	chan->gm_volume = 127;
@@ -713,8 +713,7 @@
 {
 	if (chset == NULL)
 		return;
-	if (chset->channels != NULL)
-		kfree(chset->channels);
+	kfree(chset->channels);
 	kfree(chset);
 }
 
@@ -732,7 +731,5 @@
 
 EXPORT_SYMBOL(snd_midi_process_event);
 EXPORT_SYMBOL(snd_midi_channel_set_clear);
-EXPORT_SYMBOL(snd_midi_channel_init);
-EXPORT_SYMBOL(snd_midi_channel_init_set);
 EXPORT_SYMBOL(snd_midi_channel_alloc_set);
 EXPORT_SYMBOL(snd_midi_channel_free_set);
diff -uNr a/sound/core/seq/seq_midi_event.c b/sound/core/seq/seq_midi_event.c
--- a/sound/core/seq/seq_midi_event.c	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/core/seq/seq_midi_event.c	2005-01-14 22:28:11.779567664 +0100
@@ -138,8 +138,7 @@
 void snd_midi_event_free(snd_midi_event_t *dev)
 {
 	if (dev != NULL) {
-		if (dev->buf)
-			kfree(dev->buf);
+		kfree(dev->buf);
 		kfree(dev);
 	}
 }
@@ -202,8 +201,7 @@
 	dev->bufsize = bufsize;
 	reset_encode(dev);
 	spin_unlock_irqrestore(&dev->lock, flags);
-	if (old_buf)
-		kfree(old_buf);
+	kfree(old_buf);
 	return 0;
 }
 
diff -uNr a/sound/core/sgbuf.c b/sound/core/sgbuf.c
--- a/sound/core/sgbuf.c	2004-12-24 22:35:15.000000000 +0100
+++ b/sound/core/sgbuf.c	2005-01-14 22:28:11.781567360 +0100
@@ -51,10 +51,8 @@
 		vunmap(dmab->area);
 	dmab->area = NULL;
 
-	if (sgbuf->table)
-		kfree(sgbuf->table);
-	if (sgbuf->page_table)
-		kfree(sgbuf->page_table);
+	kfree(sgbuf->table);
+	kfree(sgbuf->page_table);
 	kfree(sgbuf);
 	dmab->private_data = NULL;
 	
diff -uNr a/sound/core/sound.c b/sound/core/sound.c
--- a/sound/core/sound.c	2004-12-24 22:35:14.000000000 +0100
+++ b/sound/core/sound.c	2005-01-14 22:28:11.784566904 +0100
@@ -159,7 +159,7 @@
 	return err;
 }
 
-struct file_operations snd_fops =
+static struct file_operations snd_fops =
 {
 	.owner =	THIS_MODULE,
 	.open =		snd_open
@@ -228,12 +228,11 @@
 		return -EBUSY;
 	}
 	list_add_tail(&preg->list, &snd_minors_hash[SNDRV_MINOR_CARD(minor)]);
-	if (strncmp(name, "controlC", 8) || card->number >= cards_limit) {
+	if (strncmp(name, "controlC", 8) || card->number >= cards_limit)
 		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
-		if (card)
-			device = card->dev;
-		class_simple_device_add(sound_class, MKDEV(major, minor), device, name);
-	}
+	if (card)
+		device = card->dev;
+	class_simple_device_add(sound_class, MKDEV(major, minor), device, name);
 
 	up(&sound_mutex);
 	return 0;
@@ -263,10 +262,9 @@
 		return -EINVAL;
 	}
 
-	if (strncmp(mptr->name, "controlC", 8) || card->number >= cards_limit) { /* created in sound.c */
+	if (strncmp(mptr->name, "controlC", 8) || card->number >= cards_limit) /* created in sound.c */
 		devfs_remove("snd/%s", mptr->name);
-		class_simple_device_remove(MKDEV(major, minor));
-	}
+	class_simple_device_remove(MKDEV(major, minor));
 
 	list_del(&mptr->list);
 	up(&sound_mutex);
@@ -357,10 +355,8 @@
 		return -ENOMEM;
 	}
 	snd_info_minor_register();
-	for (controlnum = 0; controlnum < cards_limit; controlnum++) {
+	for (controlnum = 0; controlnum < cards_limit; controlnum++)
 		devfs_mk_cdev(MKDEV(major, controlnum<<5), S_IFCHR | device_mode, "snd/controlC%d", controlnum);
-		class_simple_device_add(sound_class, MKDEV(major, controlnum<<5), NULL, "controlC%d", controlnum);
-	}
 #ifndef MODULE
 	printk(KERN_INFO "Advanced Linux Sound Architecture Driver Version " CONFIG_SND_VERSION CONFIG_SND_DATE ".\n");
 #endif
@@ -371,10 +367,8 @@
 {
 	short controlnum;
 
-	for (controlnum = 0; controlnum < cards_limit; controlnum++) {
+	for (controlnum = 0; controlnum < cards_limit; controlnum++)
 		devfs_remove("snd/controlC%d", controlnum);
-		class_simple_device_remove(MKDEV(major, controlnum<<5));
-	}
 
 	snd_info_minor_unregister();
 	snd_info_done();
@@ -411,7 +405,6 @@
 EXPORT_SYMBOL(copy_to_user_fromio);
 EXPORT_SYMBOL(copy_from_user_toio);
   /* init.c */
-EXPORT_SYMBOL(snd_cards_count);
 EXPORT_SYMBOL(snd_cards);
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
@@ -447,8 +440,6 @@
   /* info.c */
 #ifdef CONFIG_PROC_FS
 EXPORT_SYMBOL(snd_seq_root);
-EXPORT_SYMBOL(snd_create_proc_entry);
-EXPORT_SYMBOL(snd_remove_proc_entry);
 EXPORT_SYMBOL(snd_iprintf);
 EXPORT_SYMBOL(snd_info_get_line);
 EXPORT_SYMBOL(snd_info_get_str);
@@ -476,6 +467,8 @@
 EXPORT_SYMBOL(snd_ctl_notify);
 EXPORT_SYMBOL(snd_ctl_register_ioctl);
 EXPORT_SYMBOL(snd_ctl_unregister_ioctl);
+EXPORT_SYMBOL(snd_ctl_elem_read);
+EXPORT_SYMBOL(snd_ctl_elem_write);
   /* misc.c */
 EXPORT_SYMBOL(snd_task_name);
 #ifdef CONFIG_SND_VERBOSE_PRINTK
diff -uNr a/sound/core/timer.c b/sound/core/timer.c
--- a/sound/core/timer.c	2004-12-24 22:35:00.000000000 +0100
+++ b/sound/core/timer.c	2005-01-14 22:28:11.789566144 +0100
@@ -351,8 +351,7 @@
 	}
 	if (timeri->private_free)
 		timeri->private_free(timeri);
-	if (timeri->owner)
-		kfree(timeri->owner);
+	kfree(timeri->owner);
 	kfree(timeri);
 	if (timer && timer->card)
 		module_put(timer->card->module);
@@ -1004,8 +1003,7 @@
 
 static void snd_timer_free_system(snd_timer_t *timer)
 {
-	if (timer->private_data)
-		kfree(timer->private_data);
+	kfree(timer->private_data);
 }
 
 static int snd_timer_register_system(void)
@@ -1226,10 +1224,8 @@
 		fasync_helper(-1, file, 0, &tu->fasync);
 		if (tu->timeri)
 			snd_timer_close(tu->timeri);
-		if (tu->queue)
-			kfree(tu->queue);
-		if (tu->tqueue)
-			kfree(tu->tqueue);
+		kfree(tu->queue);
+		kfree(tu->tqueue);
 		kfree(tu);
 	}
 	return 0;
diff -uNr a/sound/drivers/opl3/Makefile b/sound/drivers/opl3/Makefile
--- a/sound/drivers/opl3/Makefile	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/drivers/opl3/Makefile	2005-01-14 22:28:11.791565840 +0100
@@ -18,4 +18,5 @@
 sequencer = $(if $(subst y,,$(CONFIG_SND_SEQUENCER)),$(if $(1),m),$(if $(CONFIG_SND_SEQUENCER),$(1)))
 
 obj-$(CONFIG_SND_OPL3_LIB) += snd-opl3-lib.o
+obj-$(CONFIG_SND_OPL4_LIB) += snd-opl3-lib.o
 obj-$(call sequencer,$(CONFIG_SND_OPL3_LIB)) += snd-opl3-synth.o
diff -uNr a/sound/drivers/opl3/opl3_drums.c b/sound/drivers/opl3/opl3_drums.c
--- a/sound/drivers/opl3/opl3_drums.c	2004-12-24 22:35:50.000000000 +0100
+++ b/sound/drivers/opl3/opl3_drums.c	2005-01-14 22:28:11.794565384 +0100
@@ -80,7 +80,7 @@
 /*
  * set drum voice characteristics
  */
-void snd_opl3_drum_voice_set(opl3_t *opl3, snd_opl3_drum_voice_t *data)
+static void snd_opl3_drum_voice_set(opl3_t *opl3, snd_opl3_drum_voice_t *data)
 {
 	unsigned char op_offset = snd_opl3_regmap[data->voice][data->op];
 	unsigned char voice_offset = data->voice;
@@ -114,7 +114,7 @@
 /*
  * Set drum voice pitch
  */
-void snd_opl3_drum_note_set(opl3_t *opl3, snd_opl3_drum_note_t *data)
+static void snd_opl3_drum_note_set(opl3_t *opl3, snd_opl3_drum_note_t *data)
 {
 	unsigned char voice_offset = data->voice;
 	unsigned short opl3_reg;
@@ -131,8 +131,8 @@
 /*
  * Set drum voice volume and position
  */
-void snd_opl3_drum_vol_set(opl3_t *opl3, snd_opl3_drum_voice_t *data, int vel,
-			   snd_midi_channel_t *chan)
+static void snd_opl3_drum_vol_set(opl3_t *opl3, snd_opl3_drum_voice_t *data,
+				  int vel, snd_midi_channel_t *chan)
 {
 	unsigned char op_offset = snd_opl3_regmap[data->voice][data->op];
 	unsigned char voice_offset = data->voice;
diff -uNr a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
--- a/sound/drivers/opl3/opl3_lib.c	2004-12-24 22:34:26.000000000 +0100
+++ b/sound/drivers/opl3/opl3_lib.c	2005-01-14 22:28:11.797564928 +0100
@@ -37,7 +37,7 @@
 
 extern char snd_opl3_regmap[MAX_OPL2_VOICES][4];
 
-void snd_opl2_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
+static void snd_opl2_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
 {
 	unsigned long flags;
 	unsigned long port;
@@ -60,7 +60,7 @@
 	spin_unlock_irqrestore(&opl3->reg_lock, flags);
 }
 
-void snd_opl3_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
+static void snd_opl3_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
 {
 	unsigned long flags;
 	unsigned long port;
@@ -364,7 +364,7 @@
 	spin_lock_init(&opl3->timer_lock);
 	init_MUTEX(&opl3->access_mutex);
 
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, opl3, &ops)) < 0) {
+	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, opl3, &ops)) < 0) {
 		snd_opl3_free(opl3);
 		return err;
 	}
diff -uNr a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
--- a/sound/drivers/opl3/opl3_midi.c	2004-12-24 22:34:58.000000000 +0100
+++ b/sound/drivers/opl3/opl3_midi.c	2005-01-14 22:28:11.800564472 +0100
@@ -263,7 +263,7 @@
 /*
  * Start system timer
  */
-void snd_opl3_start_timer(opl3_t *opl3)
+static void snd_opl3_start_timer(opl3_t *opl3)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
diff -uNr a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
--- a/sound/drivers/opl3/opl3_seq.c	2004-12-24 22:35:00.000000000 +0100
+++ b/sound/drivers/opl3/opl3_seq.c	2005-01-14 22:28:11.803564016 +0100
@@ -96,7 +96,7 @@
 	up(&opl3->access_mutex);
 }
 
-int snd_opl3_synth_use(void *private_data, snd_seq_port_subscribe_t * info)
+static int snd_opl3_synth_use(void *private_data, snd_seq_port_subscribe_t * info)
 {
 	opl3_t *opl3 = private_data;
 	int err;
@@ -123,7 +123,7 @@
 	return 0;
 }
 
-int snd_opl3_synth_unuse(void *private_data, snd_seq_port_subscribe_t * info)
+static int snd_opl3_synth_unuse(void *private_data, snd_seq_port_subscribe_t * info)
 {
 	opl3_t *opl3 = private_data;
 
diff -uNr a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
--- a/sound/drivers/opl4/opl4_lib.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/drivers/opl4/opl4_lib.c	2005-01-14 22:28:11.806563560 +0100
@@ -229,22 +229,21 @@
 		return err;
 	}
 
-	err = snd_opl3_create(card, fm_port, fm_port + 2, opl4->hardware, 1, &opl3);
+	err = snd_device_new(card, SNDRV_DEV_CODEC, opl4, &ops);
 	if (err < 0) {
 		snd_opl4_free(opl4);
 		return err;
 	}
 
-	/* opl3 initialization disabled opl4, so reenable */
-	snd_opl4_enable_opl4(opl4);
-
-	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, opl4, &ops);
+	err = snd_opl3_create(card, fm_port, fm_port + 2, opl4->hardware, 1, &opl3);
 	if (err < 0) {
-		snd_device_free(card, opl3);
-		snd_opl4_free(opl4);
+		snd_device_free(card, opl4);
 		return err;
 	}
 
+	/* opl3 initialization disabled opl4, so reenable */
+	snd_opl4_enable_opl4(opl4);
+
 	snd_opl4_create_mixer(opl4);
 #ifdef CONFIG_PROC_FS
 	snd_opl4_create_proc(opl4);
diff -uNr a/sound/drivers/vx/vx_cmd.c b/sound/drivers/vx/vx_cmd.c
--- a/sound/drivers/vx/vx_cmd.c	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/drivers/vx/vx_cmd.c	2005-01-14 22:28:11.807563408 +0100
@@ -29,7 +29,7 @@
 /*
  * Array of DSP commands
  */
-struct vx_cmd_info vx_dsp_cmds[] = {
+static struct vx_cmd_info vx_dsp_cmds[] = {
 [CMD_VERSION] =			{ 0x010000, 2, RMH_SSIZE_FIXED, 1 },
 [CMD_SUPPORTED] =		{ 0x020000, 1, RMH_SSIZE_FIXED, 2 },
 [CMD_TEST_IT] =			{ 0x040000, 1, RMH_SSIZE_FIXED, 1 },
diff -uNr a/sound/drivers/vx/vx_cmd.h b/sound/drivers/vx/vx_cmd.h
--- a/sound/drivers/vx/vx_cmd.h	2004-12-24 22:34:31.000000000 +0100
+++ b/sound/drivers/vx/vx_cmd.h	2005-01-14 22:28:11.810562952 +0100
@@ -209,8 +209,6 @@
 /*
  *
  */
-extern struct vx_cmd_info vx_dsp_cmds[];
-
 void vx_init_rmh(struct vx_rmh *rmh, unsigned int cmd);
 
 /**
diff -uNr a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
--- a/sound/drivers/vx/vx_core.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/drivers/vx/vx_core.c	2005-01-14 22:28:11.818561736 +0100
@@ -25,6 +25,7 @@
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
+#include <linux/firmware.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/asoundef.h>
@@ -430,20 +431,19 @@
  * snd_vx_boot_xilinx - boot up the xilinx interface
  * @boot: the boot record to load
  */
-int snd_vx_load_boot_image(vx_core_t *chip, const snd_hwdep_dsp_image_t *boot)
+int snd_vx_load_boot_image(vx_core_t *chip, const struct firmware *boot)
 {
 	unsigned int i;
 	int no_fillup = vx_has_new_dsp(chip);
 
 	/* check the length of boot image */
-	snd_assert(boot->length > 0, return -EINVAL);
-	snd_assert(boot->length % 3 == 0, return -EINVAL);
-	snd_assert(boot->image, return -EINVAL);
+	snd_assert(boot->size > 0, return -EINVAL);
+	snd_assert(boot->size % 3 == 0, return -EINVAL);
 #if 0
 	{
 		/* more strict check */
-		unsigned int c = ((u32)boot->image[0] << 16) | ((u32)boot->image[1] << 8) | boot->image[2];
-		snd_assert(boot->length == (c + 2) * 3, return -EINVAL);
+		unsigned int c = ((u32)boot->data[0] << 16) | ((u32)boot->data[1] << 8) | boot->data[2];
+		snd_assert(boot->size == (c + 2) * 3, return -EINVAL);
 	}
 #endif
 
@@ -454,7 +454,7 @@
 
 	/* download boot strap */
 	for (i = 0; i < 0x600; i += 3) {
-		if (i >= boot->length) {
+		if (i >= boot->size) {
 			if (no_fillup)
 				break;
 			if (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {
@@ -465,9 +465,7 @@
 			vx_outb(chip, TXM, 0);
 			vx_outb(chip, TXL, 0);
 		} else {
-			unsigned char image[3];
-			if (copy_from_user(image, boot->image + i, 3))
-				return -EFAULT;
+			unsigned char *image = boot->data + i;
 			if (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {
 				snd_printk(KERN_ERR "dsp boot failed at %d\n", i);
 				return -EIO;
@@ -653,7 +651,7 @@
 /**
  * snd_vx_dsp_boot - load the DSP boot
  */
-int snd_vx_dsp_boot(vx_core_t *chip, const snd_hwdep_dsp_image_t *boot)
+int snd_vx_dsp_boot(vx_core_t *chip, const struct firmware *boot)
 {
 	int err;
 	int cold_reset = !(chip->chip_status & VX_STAT_DEVICE_INIT);
@@ -671,21 +669,20 @@
 /**
  * snd_vx_dsp_load - load the DSP image
  */
-int snd_vx_dsp_load(vx_core_t *chip, const snd_hwdep_dsp_image_t *dsp)
+int snd_vx_dsp_load(vx_core_t *chip, const struct firmware *dsp)
 {
 	unsigned int i;
 	int err;
 	unsigned int csum = 0;
-	unsigned char image[3], *cptr;
+	unsigned char *image, *cptr;
 
-	snd_assert(dsp->length % 3 == 0, return -EINVAL);
+	snd_assert(dsp->size % 3 == 0, return -EINVAL);
 
 	vx_toggle_dac_mute(chip, 1);
 
 	/* Transfert data buffer from PC to DSP */
-	for (i = 0; i < dsp->length; i += 3) {
-		if (copy_from_user(image, dsp->image + i, 3))
-			return -EFAULT;
+	for (i = 0; i < dsp->size; i += 3) {
+		image = dsp->data + i;
 		/* Wait DSP ready for a new read */
 		if ((err = vx_wait_isr_bit(chip, ISR_TX_EMPTY)) < 0) {
 			printk("dsp loading error at position %d\n", i);
@@ -717,6 +714,54 @@
 	return 0;
 }
 
+#ifdef CONFIG_PM
+/*
+ * suspend
+ */
+static int snd_vx_suspend(snd_card_t *card, unsigned int state)
+{
+	vx_core_t *chip = card->pm_private_data;
+	unsigned int i;
+
+	snd_assert(chip, return -EINVAL);
+
+	chip->chip_status |= VX_STAT_IN_SUSPEND;
+	for (i = 0; i < chip->hw->num_codecs; i++)
+		snd_pcm_suspend_all(chip->pcm[i]);
+
+	return 0;
+}
+
+/*
+ * resume
+ */
+static int snd_vx_resume(snd_card_t *card, unsigned int state)
+{
+	vx_core_t *chip = card->pm_private_data;
+	int i, err;
+
+	snd_assert(chip, return -EINVAL);
+
+	chip->chip_status &= ~VX_STAT_CHIP_INIT;
+
+	for (i = 0; i < 4; i++) {
+		if (! chip->firmware[i])
+			continue;
+		err = chip->ops->load_dsp(chip, i, chip->firmware[i]);
+		if (err < 0) {
+			snd_printk(KERN_ERR "vx: firmware resume error at DSP %d\n", i);
+			return -EIO;
+		}
+	}
+
+	chip->chip_status |= VX_STAT_CHIP_INIT;
+	chip->chip_status &= ~VX_STAT_IN_SUSPEND;
+
+	return 0;
+}
+
+#endif
+
 /**
  * snd_vx_create - constructor for vx_core_t
  * @hw: hardware specific record
@@ -734,7 +779,7 @@
 
 	snd_assert(card && hw && ops, return NULL);
 
-	chip = kcalloc(1, sizeof(chip) + extra_size, GFP_KERNEL);
+	chip = kcalloc(1, sizeof(*chip) + extra_size, GFP_KERNEL);
 	if (! chip) {
 		snd_printk(KERN_ERR "vx_core: no memory\n");
 		return NULL;
@@ -753,37 +798,13 @@
 	strcpy(card->driver, hw->name);
 	sprintf(card->shortname, "Digigram %s", hw->name);
 
+	snd_card_set_pm_callback(card, snd_vx_suspend, snd_vx_resume, chip);
+
 	vx_proc_init(chip);
 
 	return chip;
 }
 
-#ifdef CONFIG_PM
-/*
- * suspend
- */
-void snd_vx_suspend(vx_core_t *chip)
-{
-	unsigned int i;
-
-	chip->chip_status |= VX_STAT_IN_SUSPEND;
-	for (i = 0; i < chip->hw->num_codecs; i++)
-		snd_pcm_suspend_all(chip->pcm[i]);
-	if (chip->hwdep)
-		chip->hwdep->dsp_loaded = 0;
-}
-
-/*
- * resume
- */
-void snd_vx_resume(vx_core_t *chip)
-{
-	/* clear all stuff... */
-	chip->chip_status &= ~(VX_STAT_IN_SUSPEND|VX_STAT_CHIP_INIT);
-}
-
-#endif
-
 /*
  * module entries
  */
@@ -804,13 +825,10 @@
  */
 EXPORT_SYMBOL(snd_vx_check_reg_bit);
 EXPORT_SYMBOL(snd_vx_create);
-EXPORT_SYMBOL(snd_vx_hwdep_new);
+EXPORT_SYMBOL(snd_vx_setup_firmware);
+EXPORT_SYMBOL(snd_vx_free_firmware);
 EXPORT_SYMBOL(snd_vx_irq_handler);
 EXPORT_SYMBOL(snd_vx_delay);
 EXPORT_SYMBOL(snd_vx_dsp_boot);
 EXPORT_SYMBOL(snd_vx_dsp_load);
 EXPORT_SYMBOL(snd_vx_load_boot_image);
-#ifdef CONFIG_PM
-EXPORT_SYMBOL(snd_vx_suspend);
-EXPORT_SYMBOL(snd_vx_resume);
-#endif
diff -uNr a/sound/drivers/vx/vx_hwdep.c b/sound/drivers/vx/vx_hwdep.c
--- a/sound/drivers/vx/vx_hwdep.c	2004-12-24 22:34:30.000000000 +0100
+++ b/sound/drivers/vx/vx_hwdep.c	2005-01-14 22:28:11.821561280 +0100
@@ -1,7 +1,7 @@
 /*
  * Driver for Digigram VX soundcards
  *
- * hwdep device manager
+ * DSP firmware management
  *
  * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
  *
@@ -21,10 +21,89 @@
  */
 
 #include <sound/driver.h>
+#include <linux/firmware.h>
 #include <sound/core.h>
 #include <sound/hwdep.h>
 #include <sound/vx_core.h>
 
+#ifdef SND_VX_FW_LOADER
+
+int snd_vx_setup_firmware(vx_core_t *chip)
+{
+	static char *fw_files[VX_TYPE_NUMS][4] = {
+		[VX_TYPE_BOARD] = {
+			NULL, "x1_1_vx2.xlx", "bd56002.boot", "l_1_vx2.d56",
+		},
+		[VX_TYPE_V2] = {
+			NULL, "x1_2_v22.xlx", "bd563v2.boot", "l_1_v22.d56",
+		},
+		[VX_TYPE_MIC] = {
+			NULL, "x1_2_v22.xlx", "bd563v2.boot", "l_1_v22.d56",
+		},
+		[VX_TYPE_VXPOCKET] = {
+			"bx_1_vxp.b56", "x1_1_vxp.xlx", "bd563s3.boot", "l_1_vxp.d56"
+		},
+		[VX_TYPE_VXP440] = {
+			"bx_1_vp4.b56", "x1_1_vp4.xlx", "bd563s3.boot", "l_1_vp4.d56"
+		},
+	};
+
+	int i, err;
+
+	for (i = 0; i < 4; i++) {
+		char path[32];
+		const struct firmware *fw;
+		if (! fw_files[chip->type][i])
+			continue;
+		sprintf(path, "vx/%s", fw_files[chip->type][i]);
+		if (request_firmware(&fw, path, chip->dev)) {
+			snd_printk(KERN_ERR "vx: can't load firmware %s\n", path);
+			return -ENOENT;
+		}
+		err = chip->ops->load_dsp(chip, i, fw);
+		if (err < 0) {
+			release_firmware(fw);
+			return err;
+		}
+		if (i == 1)
+			chip->chip_status |= VX_STAT_XILINX_LOADED;
+#ifdef CONFIG_PM
+		chip->firmware[i] = fw;
+#else
+		release_firmware(fw);
+#endif
+	}
+
+	/* ok, we reached to the last one */
+	/* create the devices if not built yet */
+	if ((err = snd_vx_pcm_new(chip)) < 0)
+		return err;
+
+	if ((err = snd_vx_mixer_new(chip)) < 0)
+		return err;
+
+	if (chip->ops->add_controls)
+		if ((err = chip->ops->add_controls(chip)) < 0)
+			return err;
+
+	chip->chip_status |= VX_STAT_DEVICE_INIT;
+	chip->chip_status |= VX_STAT_CHIP_INIT;
+
+	return snd_card_register(chip->card);
+}
+
+/* exported */
+void snd_vx_free_firmware(vx_core_t *chip)
+{
+#ifdef CONFIG_PM
+	int i;
+	for (i = 0; i < 4; i++)
+		release_firmware(chip->firmware[i]);
+#endif
+}
+
+#else /* old style firmware loading */
+
 static int vx_hwdep_open(snd_hwdep_t *hw, struct file *file)
 {
 	return 0;
@@ -58,19 +137,54 @@
 	return 0;
 }
 
+static void free_fw(const struct firmware *fw)
+{
+	if (fw) {
+		vfree(fw->data);
+		kfree(fw);
+	}
+}
+
 static int vx_hwdep_dsp_load(snd_hwdep_t *hw, snd_hwdep_dsp_image_t *dsp)
 {
 	vx_core_t *vx = hw->private_data;
 	int index, err;
+	struct firmware *fw;
 
 	snd_assert(vx->ops->load_dsp, return -ENXIO);
-	err = vx->ops->load_dsp(vx, dsp);
-	if (err < 0)
-		return err;
+
+	fw = kmalloc(sizeof(*fw), GFP_KERNEL);
+	if (! fw) {
+		snd_printk(KERN_ERR "cannot allocate firmware\n");
+		return -ENOMEM;
+	}
+	fw->size = dsp->length;
+	fw->data = vmalloc(fw->size);
+	if (! fw->data) {
+		snd_printk(KERN_ERR "cannot allocate firmware image (length=%d)\n",
+			   (int)fw->size);
+		kfree(fw);
+		return -ENOMEM;
+	}
+	if (copy_from_user(fw->data, dsp->image, dsp->length)) {
+		free_fw(fw);
+		return -EFAULT;
+	}
 
 	index = dsp->index;
 	if (! vx_is_pcmcia(vx))
 		index++;
+	err = vx->ops->load_dsp(vx, index, fw);
+	if (err < 0) {
+		free_fw(fw);
+		return err;
+	}
+#ifdef CONFIG_PM
+	vx->firmware[index] = fw;
+#else
+	free_fw(fw);
+#endif
+
 	if (index == 1)
 		vx->chip_status |= VX_STAT_XILINX_LOADED;
 	if (index < 3)
@@ -100,7 +214,7 @@
 
 
 /* exported */
-int snd_vx_hwdep_new(vx_core_t *chip)
+int snd_vx_setup_firmware(vx_core_t *chip)
 {
 	int err;
 	snd_hwdep_t *hw;
@@ -118,5 +232,17 @@
 	sprintf(hw->name, "VX Loader (%s)", chip->card->driver);
 	chip->hwdep = hw;
 
-	return 0;
+	return snd_card_register(chip->card);
 }
+
+/* exported */
+void snd_vx_free_firmware(vx_core_t *chip)
+{
+#ifdef CONFIG_PM
+	int i;
+	for (i = 0; i < 4; i++)
+		free_fw(chip->firmware[i]);
+#endif
+}
+
+#endif /* SND_VX_FW_LOADER */
diff -uNr a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
--- a/sound/drivers/vx/vx_pcm.c	2004-12-24 22:33:52.000000000 +0100
+++ b/sound/drivers/vx/vx_pcm.c	2005-01-14 22:28:11.824560824 +0100
@@ -549,7 +549,8 @@
 
 static snd_pcm_hardware_t vx_pcm_playback_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_RESUME),
 	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
 	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5000,
@@ -802,6 +803,7 @@
 		
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
 		if (! pipe->is_capture)
 			vx_pcm_playback_transfer(chip, subs, pipe, 2);
 		/* FIXME:
@@ -813,6 +815,7 @@
 		pipe->running = 1;
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		vx_toggle_pipe(chip, pipe, 0);
 		vx_stop_pipe(chip, pipe);
 		vx_stop_stream(chip, pipe);
@@ -946,7 +949,8 @@
 
 static snd_pcm_hardware_t vx_pcm_capture_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_RESUME),
 	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
 	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5000,
diff -uNr a/sound/drivers/vx/vx_uer.c b/sound/drivers/vx/vx_uer.c
--- a/sound/drivers/vx/vx_uer.c	2004-12-24 22:34:30.000000000 +0100
+++ b/sound/drivers/vx/vx_uer.c	2005-01-14 22:28:11.827560368 +0100
@@ -197,7 +197,7 @@
  * vx_change_clock_source - change the clock source
  * @source: the new source
  */
-void vx_change_clock_source(vx_core_t *chip, int source)
+static void vx_change_clock_source(vx_core_t *chip, int source)
 {
 	unsigned long flags;
 
diff -uNr a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
--- a/sound/i2c/cs8427.c	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/i2c/cs8427.c	2005-01-14 22:28:11.930544712 +0100
@@ -30,6 +30,8 @@
 #include <sound/cs8427.h>
 #include <sound/asoundef.h>
 
+static void snd_cs8427_reset(snd_i2c_device_t *cs8427);
+
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("IEC958 (S/PDIF) receiver & transmitter by Cirrus Logic");
 MODULE_LICENSE("GPL");
@@ -65,16 +67,6 @@
 	return res;
 }
 
-int snd_cs8427_detect(snd_i2c_bus_t *bus, unsigned char addr)
-{
-	int res;
-
-	snd_i2c_lock(bus);
-	res = snd_i2c_probeaddr(bus, CS8427_ADDR | (addr & 7));
-	snd_i2c_unlock(bus);
-	return res;
-}
-
 int snd_cs8427_reg_write(snd_i2c_device_t *device, unsigned char reg, unsigned char val)
 {
 	int err;
@@ -89,7 +81,7 @@
 	return 0;
 }
 
-int snd_cs8427_reg_read(snd_i2c_device_t *device, unsigned char reg)
+static int snd_cs8427_reg_read(snd_i2c_device_t *device, unsigned char reg)
 {
 	int err;
 	unsigned char buf;
@@ -156,8 +148,7 @@
 
 static void snd_cs8427_free(snd_i2c_device_t *device)
 {
-	if (device->private_data)
-		kfree(device->private_data);
+	kfree(device->private_data);
 }
 
 int snd_cs8427_create(snd_i2c_bus_t *bus,
@@ -288,7 +279,7 @@
  * put back AES3INPUT. This workaround is described in latest
  * CS8427 datasheet, otherwise TXDSERIAL will not work.
  */
-void snd_cs8427_reset(snd_i2c_device_t *cs8427)
+static void snd_cs8427_reset(snd_i2c_device_t *cs8427)
 {
 	cs8427_t *chip;
 	unsigned long end_time;
@@ -573,11 +564,9 @@
 module_init(alsa_cs8427_module_init)
 module_exit(alsa_cs8427_module_exit)
 
-EXPORT_SYMBOL(snd_cs8427_detect);
 EXPORT_SYMBOL(snd_cs8427_create);
 EXPORT_SYMBOL(snd_cs8427_reset);
 EXPORT_SYMBOL(snd_cs8427_reg_write);
-EXPORT_SYMBOL(snd_cs8427_reg_read);
 EXPORT_SYMBOL(snd_cs8427_iec958_build);
 EXPORT_SYMBOL(snd_cs8427_iec958_active);
 EXPORT_SYMBOL(snd_cs8427_iec958_pcm);
diff -uNr a/sound/i2c/i2c.c b/sound/i2c/i2c.c
--- a/sound/i2c/i2c.c	2004-12-24 22:34:33.000000000 +0100
+++ b/sound/i2c/i2c.c	2005-01-14 22:28:11.932544408 +0100
@@ -94,7 +94,7 @@
 		bus->master = master;
 	}
 	strlcpy(bus->name, name, sizeof(bus->name));
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, bus, &ops)) < 0) {
+	if ((err = snd_device_new(card, SNDRV_DEV_BUS, bus, &ops)) < 0) {
 		snd_i2c_bus_free(bus);
 		return err;
 	}
diff -uNr a/sound/i2c/l3/uda1341.c b/sound/i2c/l3/uda1341.c
--- a/sound/i2c/l3/uda1341.c	2004-12-24 22:34:45.000000000 +0100
+++ b/sound/i2c/l3/uda1341.c	2005-01-14 22:28:11.935543952 +0100
@@ -17,7 +17,7 @@
  * 2002-05-12   Tomas Kasparek  another code cleanup
  */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <sound/driver.h>
 #include <linux/module.h>
@@ -679,7 +679,7 @@
 		return err;
 	}
 
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, uda1341, &ops)) < 0) {
+	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, uda1341, &ops)) < 0) {
 		l3_detach_client(uda1341);
 		kfree(uda1341);
 		return err;
@@ -730,8 +730,7 @@
 
 static void uda1341_detach(struct l3_client *clnt)
 {
-	if (clnt->driver_data)
-		kfree(clnt->driver_data);
+	kfree(clnt->driver_data);
 }
 
 static int
diff -uNr a/sound/i2c/other/ak4117.c b/sound/i2c/other/ak4117.c
--- a/sound/i2c/other/ak4117.c	2004-12-24 22:34:58.000000000 +0100
+++ b/sound/i2c/other/ak4117.c	2005-01-14 22:28:11.943542736 +0100
@@ -103,7 +103,7 @@
 	chip->rcs1 = reg_read(chip, AK4117_REG_RCS1);
 	chip->rcs2 = reg_read(chip, AK4117_REG_RCS2);
 
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
+	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, chip, &ops)) < 0)
 		goto __fail;
 
 	if (r_ak4117)
diff -uNr a/sound/isa/ad1816a/ad1816a_lib.c b/sound/isa/ad1816a/ad1816a_lib.c
--- a/sound/isa/ad1816a/ad1816a_lib.c	2004-12-24 22:35:01.000000000 +0100
+++ b/sound/isa/ad1816a/ad1816a_lib.c	2005-01-14 22:28:11.831559760 +0100
@@ -46,20 +46,20 @@
 	return -EBUSY;
 }
 
-inline unsigned char snd_ad1816a_in(ad1816a_t *chip, unsigned char reg)
+static inline unsigned char snd_ad1816a_in(ad1816a_t *chip, unsigned char reg)
 {
 	snd_ad1816a_busy_wait(chip);
 	return inb(AD1816A_REG(reg));
 }
 
-inline void snd_ad1816a_out(ad1816a_t *chip, unsigned char reg,
+static inline void snd_ad1816a_out(ad1816a_t *chip, unsigned char reg,
 			    unsigned char value)
 {
 	snd_ad1816a_busy_wait(chip);
 	outb(value, AD1816A_REG(reg));
 }
 
-inline void snd_ad1816a_out_mask(ad1816a_t *chip, unsigned char reg,
+static inline void snd_ad1816a_out_mask(ad1816a_t *chip, unsigned char reg,
 				 unsigned char mask, unsigned char value)
 {
 	snd_ad1816a_out(chip, reg,
@@ -372,6 +372,7 @@
 	.fifo_size =		0,
 };
 
+#if 0 /* not used now */
 static int snd_ad1816a_timer_close(snd_timer_t *timer)
 {
 	ad1816a_t *chip = snd_timer_chip(timer);
@@ -435,6 +436,7 @@
 	.start =	snd_ad1816a_timer_start,
 	.stop =		snd_ad1816a_timer_stop,
 };
+#endif /* not used now */
 
 
 static int snd_ad1816a_playback_open(snd_pcm_substream_t *substream)
@@ -692,6 +694,7 @@
 	return 0;
 }
 
+#if 0 /* not used now */
 static void snd_ad1816a_timer_free(snd_timer_t *timer)
 {
 	ad1816a_t *chip = timer->private_data;
@@ -720,6 +723,7 @@
 		*rtimer = timer;
 	return 0;
 }
+#endif /* not used now */
 
 /*
  *
diff -uNr a/sound/isa/ad1848/ad1848_lib.c b/sound/isa/ad1848/ad1848_lib.c
--- a/sound/isa/ad1848/ad1848_lib.c	2004-12-24 22:35:39.000000000 +0100
+++ b/sound/isa/ad1848/ad1848_lib.c	2005-01-14 22:28:11.837558848 +0100
@@ -119,9 +119,8 @@
 #endif
 }
 
-void snd_ad1848_dout(ad1848_t *chip,
-		     unsigned char reg,
-		     unsigned char value)
+static void snd_ad1848_dout(ad1848_t *chip,
+			    unsigned char reg, unsigned char value)
 {
 	int timeout;
 
@@ -132,7 +131,7 @@
 	mb();
 }
 
-unsigned char snd_ad1848_in(ad1848_t *chip, unsigned char reg)
+static unsigned char snd_ad1848_in(ad1848_t *chip, unsigned char reg)
 {
 	int timeout;
 
@@ -147,9 +146,9 @@
 	return inb(AD1848P(chip, REG));
 }
 
-#ifdef CONFIG_SND_DEBUG
+#if 0
 
-void snd_ad1848_debug(ad1848_t *chip)
+static void snd_ad1848_debug(ad1848_t *chip)
 {
 	printk("AD1848 REGS:      INDEX = 0x%02x  ", inb(AD1848P(chip, REGSEL)));
 	printk("                 STATUS = 0x%02x\n", inb(AD1848P(chip, STATUS)));
@@ -177,7 +176,7 @@
  *  AD1848 detection / MCE routines
  */
 
-void snd_ad1848_mce_up(ad1848_t *chip)
+static void snd_ad1848_mce_up(ad1848_t *chip)
 {
 	unsigned long flags;
 	int timeout;
@@ -198,7 +197,7 @@
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
-void snd_ad1848_mce_down(ad1848_t *chip)
+static void snd_ad1848_mce_down(ad1848_t *chip)
 {
 	unsigned long flags;
 	int timeout;
@@ -584,7 +583,7 @@
 	return 0;
 }
 
-irqreturn_t snd_ad1848_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_ad1848_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	ad1848_t *chip = dev_id;
 
@@ -649,16 +648,12 @@
 {
 	ad1848_t *chip = card->pm_private_data;
 
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return 0;
-
 	snd_pcm_suspend_all(chip->pcm);
 	/* FIXME: save registers? */
 
 	if (chip->thinkpad_flag)
 		snd_ad1848_thinkpad_twiddle(chip, 0);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -666,15 +661,11 @@
 {
 	ad1848_t *chip = card->pm_private_data;
 
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return 0;
-
 	if (chip->thinkpad_flag)
 		snd_ad1848_thinkpad_twiddle(chip, 1);
 
 	/* FIXME: restore registers? */
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1264,12 +1255,7 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(snd_ad1848_in);
 EXPORT_SYMBOL(snd_ad1848_out);
-EXPORT_SYMBOL(snd_ad1848_dout);
-EXPORT_SYMBOL(snd_ad1848_mce_up);
-EXPORT_SYMBOL(snd_ad1848_mce_down);
-EXPORT_SYMBOL(snd_ad1848_interrupt);
 EXPORT_SYMBOL(snd_ad1848_create);
 EXPORT_SYMBOL(snd_ad1848_pcm);
 EXPORT_SYMBOL(snd_ad1848_get_pcm_ops);
diff -uNr a/sound/isa/als100.c b/sound/isa/als100.c
--- a/sound/isa/als100.c	2004-12-24 22:33:59.000000000 +0100
+++ b/sound/isa/als100.c	2005-01-14 22:28:11.843557936 +0100
@@ -94,6 +94,8 @@
 	{ .id = "ALS0120", .devs = { { "@@@2001" }, { "@X@2001" }, { "@H@2001" } } },
 	/* ALS200 */
 	{ .id = "ALS0200", .devs = { { "@@@0020" }, { "@X@0020" }, { "@H@0001" } } },
+	/* ALS200 OEM */
+	{ .id = "ALS0200", .devs = { { "@@@0020" }, { "@X@0020" }, { "@H@0020" } } },
 	/* RTL3000 */
 	{ .id = "RTL3000", .devs = { { "@@@2001" }, { "@X@2001" }, { "@H@2001" } } },
 	{ .id = "", } /* end */
diff -uNr a/sound/isa/cs423x/cs4231_lib.c b/sound/isa/cs423x/cs4231_lib.c
--- a/sound/isa/cs423x/cs4231_lib.c	2004-12-24 22:34:26.000000000 +0100
+++ b/sound/isa/cs423x/cs4231_lib.c	2005-01-14 22:28:11.849557024 +0100
@@ -166,8 +166,8 @@
 #endif
 }
 
-void snd_cs4231_outm(cs4231_t *chip, unsigned char reg,
-		     unsigned char mask, unsigned char value)
+static void snd_cs4231_outm(cs4231_t *chip, unsigned char reg,
+			    unsigned char mask, unsigned char value)
 {
 	int timeout;
 	unsigned char tmp;
@@ -271,9 +271,9 @@
 #endif
 }
 
-#ifdef CONFIG_SND_DEBUG
+#if 0
 
-void snd_cs4231_debug(cs4231_t *chip)
+static void snd_cs4231_debug(cs4231_t *chip)
 {
 	printk("CS4231 REGS:      INDEX = 0x%02x  ", cs4231_inb(chip, CS4231P(REGSEL)));
 	printk("                 STATUS = 0x%02x\n", cs4231_inb(chip, CS4231P(STATUS)));
@@ -356,7 +356,6 @@
 {
 	unsigned long flags;
 	int timeout;
-	signed long time;
 
 	snd_cs4231_busy_wait(chip);
 #if 0
@@ -390,34 +389,26 @@
 #if 0
 	printk("(2) timeout = %i, jiffies = %li\n", timeout, jiffies);
 #endif
-	timeout = HZ / 4 / 2;
-	time = 2;
+	/* in 10 ms increments, check condition, up to 250 ms */
+	timeout = 25;
 	while (snd_cs4231_in(chip, CS4231_TEST_INIT) & CS4231_CALIB_IN_PROGRESS) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		time = schedule_timeout(time);
-		if (time > 0)
-			continue;
-		time = 2;
 		if (--timeout < 0) {
 			snd_printk("mce_down - auto calibration time out (2)\n");
 			return;
 		}
+		msleep(10);
 	}
 #if 0
 	printk("(3) jiffies = %li\n", jiffies);
 #endif
-	timeout = HZ / 10 / 2;
-	time = 2;
+	/* in 10 ms increments, check condition, up to 100 ms */
+	timeout = 10;
 	while (cs4231_inb(chip, CS4231P(REGSEL)) & CS4231_INIT) {
-		set_current_state(TASK_INTERRUPTIBLE);		
-		time = schedule_timeout(time);
-		if (time > 0)
-			continue;
-		time = 2;
 		if (--timeout < 0) {
 			snd_printk(KERN_ERR "mce_down - auto calibration time out (3)\n");
 			return;
 		}
+		msleep(10);
 	}
 #if 0
 	printk("(4) jiffies = %li\n", jiffies);
@@ -694,7 +685,7 @@
 
 	snd_cs4231_mce_down(chip);
 
-#ifdef SNDRV_DEBUGq_MCE
+#ifdef SNDRV_DEBUG_MCE
 	snd_printk("init: (1)\n");
 #endif
 	snd_cs4231_mce_up(chip);
@@ -1035,7 +1026,7 @@
 
  */
 
-int snd_cs4231_probe(cs4231_t *chip)
+static int snd_cs4231_probe(cs4231_t *chip)
 {
 	unsigned long flags;
 	int i, id, rev;
@@ -1406,20 +1397,16 @@
 static int snd_cs4231_pm_suspend(snd_card_t *card, unsigned int state)
 {
 	cs4231_t *chip = card->pm_private_data;
-	if (chip->suspend) {
+	if (chip->suspend)
 		chip->suspend(chip);
-		snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	}
 	return 0;
 }
 
 static int snd_cs4231_pm_resume(snd_card_t *card, unsigned int state)
 {
 	cs4231_t *chip = card->pm_private_data;
-	if (chip->resume) {
+	if (chip->resume)
 		chip->resume(chip);
-		snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-	}
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1943,7 +1930,6 @@
 
 EXPORT_SYMBOL(snd_cs4231_out);
 EXPORT_SYMBOL(snd_cs4231_in);
-EXPORT_SYMBOL(snd_cs4231_outm);
 EXPORT_SYMBOL(snd_cs4236_ext_out);
 EXPORT_SYMBOL(snd_cs4236_ext_in);
 EXPORT_SYMBOL(snd_cs4231_mce_up);
diff -uNr a/sound/isa/cs423x/cs4236.c b/sound/isa/cs423x/cs4236.c
--- a/sound/isa/cs423x/cs4236.c	2004-12-24 22:34:00.000000000 +0100
+++ b/sound/isa/cs423x/cs4236.c	2005-01-14 22:28:11.852556568 +0100
@@ -242,6 +242,8 @@
 	{ .id = "CSCd937", .devs = { { "CSC0000" }, { "CSC0010" }, { "CSC0003" } } },
 	/* CS4235 without MPU401 */
 	{ .id = "CSCe825", .devs = { { "CSC0100" }, { "CSC0110" } } },
+	/* Unknown SiS530 - CS4235 */
+	{ .id = "CSC4825", .devs = { { "CSC0100" }, { "CSC0110" } } },
 	/* IBM IntelliStation M Pro 6898 11U - CS4236B */
 	{ .id = "CSCe835", .devs = { { "CSC0000" }, { "CSC0010" } } },
 	/* IBM PC 300PL Onboard - CS4236B */
diff -uNr a/sound/isa/es1688/es1688_lib.c b/sound/isa/es1688/es1688_lib.c
--- a/sound/isa/es1688/es1688_lib.c	2004-12-24 22:35:00.000000000 +0100
+++ b/sound/isa/es1688/es1688_lib.c	2005-01-14 22:28:11.861555200 +0100
@@ -70,7 +70,7 @@
 	return snd_es1688_dsp_command(chip, data);
 }
 
-int snd_es1688_read(es1688_t *chip, unsigned char reg)
+static int snd_es1688_read(es1688_t *chip, unsigned char reg)
 {
 	/* Read a byte from an extended mode register of ES1688 */
 	if (!snd_es1688_dsp_command(chip, 0xc0))
@@ -89,7 +89,7 @@
 	udelay(10);
 }
 
-unsigned char snd_es1688_mixer_read(es1688_t *chip, unsigned char reg)
+static unsigned char snd_es1688_mixer_read(es1688_t *chip, unsigned char reg)
 {
 	unsigned char result;
 
@@ -479,7 +479,7 @@
 	return snd_es1688_trigger(chip, cmd, 0x0f);
 }
 
-irqreturn_t snd_es1688_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_es1688_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	es1688_t *chip = dev_id;
 
@@ -1041,8 +1041,6 @@
 }
 
 EXPORT_SYMBOL(snd_es1688_mixer_write);
-EXPORT_SYMBOL(snd_es1688_mixer_read);
-EXPORT_SYMBOL(snd_es1688_interrupt);
 EXPORT_SYMBOL(snd_es1688_create);
 EXPORT_SYMBOL(snd_es1688_pcm);
 EXPORT_SYMBOL(snd_es1688_mixer);
diff -uNr a/sound/isa/es18xx.c b/sound/isa/es18xx.c
--- a/sound/isa/es18xx.c	2004-12-24 22:34:32.000000000 +0100
+++ b/sound/isa/es18xx.c	2005-01-14 22:28:11.867554288 +0100
@@ -268,7 +268,7 @@
 	return ret;
 }
 
-inline void snd_es18xx_mixer_write(es18xx_t *chip,
+static inline void snd_es18xx_mixer_write(es18xx_t *chip,
 			    unsigned char reg, unsigned char data)
 {
 	unsigned long flags;
@@ -281,7 +281,7 @@
 #endif
 }
 
-inline int snd_es18xx_mixer_read(es18xx_t *chip, unsigned char reg)
+static inline int snd_es18xx_mixer_read(es18xx_t *chip, unsigned char reg)
 {
 	unsigned long flags;
 	int data;
@@ -1569,7 +1569,7 @@
 	snd_pcm_lib_preallocate_free_for_all(pcm);
 }
 
-int __devinit snd_es18xx_pcm(es18xx_t *chip, int device, snd_pcm_t ** rpcm)
+static int __devinit snd_es18xx_pcm(es18xx_t *chip, int device, snd_pcm_t ** rpcm)
 {
         snd_pcm_t *pcm;
 	char str[16];
@@ -1624,7 +1624,6 @@
 	snd_es18xx_write(chip, ES18XX_PM, chip->pm_reg);
 	snd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_SUS);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1635,7 +1634,6 @@
 	/* restore PM register, we won't wake till (not 0x07) i/o activity though */
 	snd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_FM);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1849,7 +1847,7 @@
 static int isapnp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
 #endif
 static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;	/* 0x220,0x240,0x260,0x280 */
-#ifndef CONFIG_PNP_
+#ifndef CONFIG_PNP
 static long mpu_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};
 #else
 static long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;
@@ -1988,7 +1986,7 @@
 	kfree(cfg);
 	return 0;
 }
-#endif /* CONFIG_PNP_ */
+#endif /* CONFIG_PNP */
 
 static int __devinit snd_audiodrive_probe(int dev, struct pnp_card_link *pcard,
 					  const struct pnp_card_device_id *pid)
diff -uNr a/sound/isa/gus/gus_dma.c b/sound/isa/gus/gus_dma.c
--- a/sound/isa/gus/gus_dma.c	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/isa/gus/gus_dma.c	2005-01-14 22:28:11.869553984 +0100
@@ -25,7 +25,7 @@
 #include <sound/core.h>
 #include <sound/gus.h>
 
-void snd_gf1_dma_ack(snd_gus_card_t * gus)
+static void snd_gf1_dma_ack(snd_gus_card_t * gus)
 {
 	unsigned long flags;
 
@@ -35,11 +35,11 @@
 	spin_unlock_irqrestore(&gus->reg_lock, flags);
 }
 
-void snd_gf1_dma_program(snd_gus_card_t * gus,
-			 unsigned int addr,
-			 unsigned long buf_addr,
-			 unsigned int count,
-			 unsigned int cmd)
+static void snd_gf1_dma_program(snd_gus_card_t * gus,
+				unsigned int addr,
+				unsigned long buf_addr,
+				unsigned int count,
+				unsigned int cmd)
 {
 	unsigned long flags;
 	unsigned int address;
diff -uNr a/sound/isa/gus/gus_mem.c b/sound/isa/gus/gus_mem.c
--- a/sound/isa/gus/gus_mem.c	2004-12-24 22:34:32.000000000 +0100
+++ b/sound/isa/gus/gus_mem.c	2005-01-14 22:28:11.872553528 +0100
@@ -100,8 +100,7 @@
 		if (block->prev)
 			block->prev->next = block->next;
 	}
-	if (block->name)
-		kfree(block->name);
+	kfree(block->name);
 	kfree(block);
 	return 0;
 }
diff -uNr a/sound/isa/gus/gus_sample.c b/sound/isa/gus/gus_sample.c
--- a/sound/isa/gus/gus_sample.c	2004-12-24 22:34:45.000000000 +0100
+++ b/sound/isa/gus/gus_sample.c	2005-01-14 22:28:11.874553224 +0100
@@ -42,7 +42,7 @@
 	instr = snd_seq_instr_find(gus->gf1.ilist, &v->instr, 0, 1);
 	if (instr != NULL) {
 		if (instr->ops) {
-			if (instr->ops->instr_type == snd_seq_simple_id)
+			if (!strcmp(instr->ops->instr_type, SNDRV_SEQ_INSTR_ID_SIMPLE))
 				snd_gf1_simple_init(v);
 		}
 		snd_seq_instr_free_use(gus->gf1.ilist, instr);
diff -uNr a/sound/isa/opl3sa2.c b/sound/isa/opl3sa2.c
--- a/sound/isa/opl3sa2.c	2004-12-24 22:35:39.000000000 +0100
+++ b/sound/isa/opl3sa2.c	2005-01-14 22:28:11.879552464 +0100
@@ -341,7 +341,7 @@
 	return 0;
 }
 
-int snd_opl3sa2_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opl3sa2_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	opl3sa2_t *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
@@ -358,7 +358,7 @@
 	return 0;
 }
 
-int snd_opl3sa2_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opl3sa2_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	opl3sa2_t *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
@@ -388,7 +388,7 @@
   .get = snd_opl3sa2_get_double, .put = snd_opl3sa2_put_double, \
   .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }
 
-int snd_opl3sa2_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_opl3sa2_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
 {
 	int mask = (kcontrol->private_value >> 24) & 0xff;
 
@@ -399,7 +399,7 @@
 	return 0;
 }
 
-int snd_opl3sa2_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opl3sa2_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	opl3sa2_t *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
@@ -421,7 +421,7 @@
 	return 0;
 }
 
-int snd_opl3sa2_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opl3sa2_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	opl3sa2_t *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
@@ -539,7 +539,6 @@
 	/* power down */
 	snd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D3);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -563,7 +562,6 @@
 	/* restore cs4231 */
 	chip->cs4231_resume(chip->cs4231);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
diff -uNr a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
--- a/sound/isa/opti9xx/opti92x-ad1848.c	2004-12-24 22:34:01.000000000 +0100
+++ b/sound/isa/opti9xx/opti92x-ad1848.c	2005-01-14 22:28:11.884551704 +0100
@@ -1095,7 +1095,7 @@
 	spin_unlock_irqrestore(&chip->lock, flags);
 }
 
-irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	opti93x_t *codec = dev_id;
 	unsigned char status;
@@ -1263,9 +1263,9 @@
 	}
 }
 
-int snd_opti93x_create(snd_card_t *card, opti9xx_t *chip,
-		       int dma1, int dma2,
-		       opti93x_t **rcodec)
+static int snd_opti93x_create(snd_card_t *card, opti9xx_t *chip,
+			      int dma1, int dma2,
+			      opti93x_t **rcodec)
 {
 	static snd_device_ops_t ops = {
 		.dev_free =	snd_opti93x_dev_free,
@@ -1359,7 +1359,7 @@
 	snd_pcm_lib_preallocate_free_for_all(pcm);
 }
 
-int snd_opti93x_pcm(opti93x_t *codec, int device, snd_pcm_t **rpcm)
+static int snd_opti93x_pcm(opti93x_t *codec, int device, snd_pcm_t **rpcm)
 {
 	int error;
 	snd_pcm_t *pcm;
@@ -1603,7 +1603,7 @@
 }
 };
                                         
-int snd_opti93x_mixer(opti93x_t *chip)
+static int snd_opti93x_mixer(opti93x_t *chip)
 {
 	snd_card_t *card;
 	snd_kcontrol_new_t knew;
diff -uNr a/sound/isa/sb/emu8000.c b/sound/isa/sb/emu8000.c
--- a/sound/isa/sb/emu8000.c	2004-12-24 22:34:30.000000000 +0100
+++ b/sound/isa/sb/emu8000.c	2005-01-14 22:28:11.888551096 +0100
@@ -1133,7 +1133,7 @@
 		return err;
 	}
 	
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, hw, &ops)) < 0) {
+	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, hw, &ops)) < 0) {
 		snd_emu8000_free(hw);
 		return err;
 	}
diff -uNr a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
--- a/sound/isa/sb/emu8000_callback.c	2004-12-24 22:34:31.000000000 +0100
+++ b/sound/isa/sb/emu8000_callback.c	2005-01-14 22:28:11.891550640 +0100
@@ -528,6 +528,10 @@
 	emu8000_t *hw;
 	hw = emu->hw;
 
+	/* skip header */
+	buf += 16;
+	len -= 16;
+
 	switch (type) {
 	case SNDRV_EMU8000_LOAD_CHORUS_FX:
 		return snd_emu8000_load_chorus_fx(hw, mode, buf, len);
diff -uNr a/sound/isa/sb/emu8000_pcm.c b/sound/isa/sb/emu8000_pcm.c
--- a/sound/isa/sb/emu8000_pcm.c	2004-12-24 22:35:39.000000000 +0100
+++ b/sound/isa/sb/emu8000_pcm.c	2005-01-14 22:28:11.893550336 +0100
@@ -260,8 +260,7 @@
 static int emu8k_pcm_close(snd_pcm_substream_t *subs)
 {
 	emu8k_pcm_t *rec = subs->runtime->private_data;
-	if (rec)
-		kfree(rec);
+	kfree(rec);
 	subs->runtime->private_data = NULL;
 	return 0;
 }
diff -uNr a/sound/isa/sb/sb16_main.c b/sound/isa/sb/sb16_main.c
--- a/sound/isa/sb/sb16_main.c	2004-12-24 22:34:44.000000000 +0100
+++ b/sound/isa/sb/sb16_main.c	2005-01-14 22:28:11.901549120 +0100
@@ -509,7 +509,7 @@
  *  open/close
  */
 
-int snd_sb16_playback_open(snd_pcm_substream_t * substream)
+static int snd_sb16_playback_open(snd_pcm_substream_t * substream)
 {
 	unsigned long flags;
 	sb_t *chip = snd_pcm_substream_chip(substream);
@@ -566,7 +566,7 @@
 	return 0;
 }
 
-int snd_sb16_playback_close(snd_pcm_substream_t * substream)
+static int snd_sb16_playback_close(snd_pcm_substream_t * substream)
 {
 	unsigned long flags;
 	sb_t *chip = snd_pcm_substream_chip(substream);
@@ -579,7 +579,7 @@
 	return 0;
 }
 
-int snd_sb16_capture_open(snd_pcm_substream_t * substream)
+static int snd_sb16_capture_open(snd_pcm_substream_t * substream)
 {
 	unsigned long flags;
 	sb_t *chip = snd_pcm_substream_chip(substream);
@@ -636,7 +636,7 @@
 	return 0;
 }
 
-int snd_sb16_capture_close(snd_pcm_substream_t * substream)
+static int snd_sb16_capture_close(snd_pcm_substream_t * substream)
 {
 	unsigned long flags;
 	sb_t *chip = snd_pcm_substream_chip(substream);
@@ -728,7 +728,7 @@
 	return change;
 }
 
-snd_kcontrol_new_t snd_sb16_dma_control = {
+static snd_kcontrol_new_t snd_sb16_dma_control = {
 	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 	.name = "16-bit DMA Allocation",
 	.info = snd_sb16_dma_control_info,
diff -uNr a/sound/isa/sb/sb8_main.c b/sound/isa/sb/sb8_main.c
--- a/sound/isa/sb/sb8_main.c	2004-12-24 22:34:33.000000000 +0100
+++ b/sound/isa/sb/sb8_main.c	2005-01-14 22:28:11.908548056 +0100
@@ -425,7 +425,7 @@
  *
  */
  
-int snd_sb8_open(snd_pcm_substream_t *substream)
+static int snd_sb8_open(snd_pcm_substream_t *substream)
 {
 	sb_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -471,7 +471,7 @@
 	return 0;	
 }
 
-int snd_sb8_close(snd_pcm_substream_t *substream)
+static int snd_sb8_close(snd_pcm_substream_t *substream)
 {
 	unsigned long flags;
 	sb_t *chip = snd_pcm_substream_chip(substream);
diff -uNr a/sound/isa/sb/sb_common.c b/sound/isa/sb/sb_common.c
--- a/sound/isa/sb/sb_common.c	2004-12-24 22:35:40.000000000 +0100
+++ b/sound/isa/sb/sb_common.c	2005-01-14 22:28:11.897549728 +0100
@@ -92,7 +92,7 @@
 	return -ENODEV;
 }
 
-int snd_sbdsp_version(sb_t * chip)
+static int snd_sbdsp_version(sb_t * chip)
 {
 	unsigned int result = -ENODEV;
 
diff -uNr a/sound/isa/sscape.c b/sound/isa/sscape.c
--- a/sound/isa/sscape.c	2004-12-24 22:33:59.000000000 +0100
+++ b/sound/isa/sscape.c	2005-01-14 22:28:11.912547448 +0100
@@ -487,7 +487,7 @@
 		 * the userspace pointer ...
 		 */
 		len = min(size, dma.bytes);
-		__copy_from_user(dma.area, data, len);
+		len -= __copy_from_user(dma.area, data, len);
 		data += len;
 		size -= len;
 
@@ -571,8 +571,9 @@
 		if (data < 0) {
 			snd_printk(KERN_ERR "sscape: timeout reading firmware version\n");
 			ret = -EAGAIN;
-		} else {
-			__copy_to_user(&bb->version, &data, sizeof(bb->version));
+		}
+		else if (__copy_to_user(&bb->version, &data, sizeof(bb->version))) {
+			ret = -EFAULT;
 		}
 	}
 
@@ -591,7 +592,7 @@
 {
 	unsigned long flags;
 	char __user *code;
-	int err, ret;
+	int err;
 
 	/*
 	 * We are going to have to copy this data into a special
@@ -601,12 +602,11 @@
 	 * NOTE: This buffer is 64K long! That's WAY too big to
 	 *       copy into a stack-temporary anyway.
 	 */
-	if (get_user(code, &mc->code))
+	if ( get_user(code, &mc->code) ||
+	     !access_ok(VERIFY_READ, code, SSCAPE_MICROCODE_SIZE) )
 		return -EFAULT;
-	if ((err = verify_area(VERIFY_READ, code, SSCAPE_MICROCODE_SIZE)) != 0)
-		return err;
 
-	if ((ret = upload_dma_data(sscape, code, SSCAPE_MICROCODE_SIZE)) == 0) {
+	if ((err = upload_dma_data(sscape, code, SSCAPE_MICROCODE_SIZE)) == 0) {
 		snd_printk(KERN_INFO "sscape: MIDI firmware loaded\n");
 	}
 
@@ -616,7 +616,7 @@
 
 	initialise_mpu401(sscape->mpu);
 
-	return ret;
+	return err;
 }
 
 /*
@@ -673,14 +673,14 @@
 			 * DMA-able buffer before we can upload it. We shall therefore
 			 * just check that the data pointer is valid for now ...
 			 */
-			if ((err = verify_area(VERIFY_READ, bb->code, sizeof(bb->code))) != 0)
-				return err;
+			if ( !access_ok(VERIFY_READ, bb->code, sizeof(bb->code)) )
+				return -EFAULT;
 
 			/*
 			 * Now check that we can write the firmware version number too...
 			 */
-			if ((err = verify_area(VERIFY_WRITE, &bb->version, sizeof(bb->version))) != 0)
-				return err;
+			if ( !access_ok(VERIFY_WRITE, &bb->version, sizeof(bb->version)) )
+				return -EFAULT;
 
 			err = sscape_upload_bootblock(sscape, bb);
 		}
diff -uNr a/sound/isa/wavefront/wavefront.c b/sound/isa/wavefront/wavefront.c
--- a/sound/isa/wavefront/wavefront.c	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/isa/wavefront/wavefront.c	2005-01-14 22:28:11.915546992 +0100
@@ -279,7 +279,7 @@
 	return IRQ_HANDLED;
 }
 
-snd_hwdep_t * __devinit
+static snd_hwdep_t * __devinit
 snd_wavefront_new_synth (snd_card_t *card,
 			 int hw_dev,
 			 snd_wavefront_card_t *acard)
@@ -305,7 +305,7 @@
 	return wavefront_synth;
 }
 
-snd_hwdep_t * __devinit
+static snd_hwdep_t * __devinit
 snd_wavefront_new_fx (snd_card_t *card,
 		      int hw_dev,
 		      snd_wavefront_card_t *acard,
@@ -332,7 +332,7 @@
 static snd_wavefront_mpu_id internal_id = internal_mpu;
 static snd_wavefront_mpu_id external_id = external_mpu;
 
-snd_rawmidi_t * __devinit
+static snd_rawmidi_t * __devinit
 snd_wavefront_new_midi (snd_card_t *card,
 			int midi_dev,
 			snd_wavefront_card_t *acard,
diff -uNr a/sound/isa/wavefront/wavefront_fx.c b/sound/isa/wavefront/wavefront_fx.c
--- a/sound/isa/wavefront/wavefront_fx.c	2004-12-24 22:35:01.000000000 +0100
+++ b/sound/isa/wavefront/wavefront_fx.c	2005-01-14 22:28:11.920546232 +0100
@@ -537,8 +537,7 @@
 			     r.data[1], /* addr */
 			     r.data[2], /* cnt */
 			     pd);
-		if (page_data)
-			kfree(page_data);
+		kfree(page_data);
 		break;
 
 	default:
diff -uNr a/sound/isa/wavefront/wavefront_synth.c b/sound/isa/wavefront/wavefront_synth.c
--- a/sound/isa/wavefront/wavefront_synth.c	2004-12-24 22:34:31.000000000 +0100
+++ b/sound/isa/wavefront/wavefront_synth.c	2005-01-14 22:28:11.925545472 +0100
@@ -32,58 +32,58 @@
 #include <sound/snd_wavefront.h>
 #include <sound/initval.h>
 
-int wf_raw = 0; /* we normally check for "raw state" to firmware
-		   loading. if non-zero, then during driver loading, the
-		   state of the board is ignored, and we reset the
-		   board and load the firmware anyway.
-		*/
+static int wf_raw = 0; /* we normally check for "raw state" to firmware
+			  loading. if non-zero, then during driver loading, the
+			  state of the board is ignored, and we reset the
+			  board and load the firmware anyway.
+		       */
 		   
-int fx_raw = 1; /* if this is zero, we'll leave the FX processor in
-		   whatever state it is when the driver is loaded.
-		   The default is to download the microprogram and
-		   associated coefficients to set it up for "default"
-		   operation, whatever that means.
-		*/
-
-int debug_default = 0;  /* you can set this to control debugging
-			      during driver loading. it takes any combination
-			      of the WF_DEBUG_* flags defined in
-			      wavefront.h
-			   */
+static int fx_raw = 1; /* if this is zero, we'll leave the FX processor in
+			  whatever state it is when the driver is loaded.
+			  The default is to download the microprogram and
+			  associated coefficients to set it up for "default"
+			  operation, whatever that means.
+		       */
+
+static int debug_default = 0;  /* you can set this to control debugging
+				  during driver loading. it takes any combination
+				  of the WF_DEBUG_* flags defined in
+				  wavefront.h
+			       */
 
 /* XXX this needs to be made firmware and hardware version dependent */
 
-char *ospath = "/etc/sound/wavefront.os"; /* where to find a processed
-					     version of the WaveFront OS
-					  */
-
-int wait_usecs = 150; /* This magic number seems to give pretty optimal
-			 throughput based on my limited experimentation.
-			 If you want to play around with it and find a better
-			 value, be my guest. Remember, the idea is to
-			 get a number that causes us to just busy wait
-			 for as many WaveFront commands as possible, without
-			 coming up with a number so large that we hog the
-			 whole CPU.
-
-			 Specifically, with this number, out of about 134,000
-			 status waits, only about 250 result in a sleep.
-		      */
-
-int sleep_interval = 100;   /* HZ/sleep_interval seconds per sleep */
-int sleep_tries = 50;       /* number of times we'll try to sleep */
-
-int reset_time = 2;        /* hundreths of a second we wait after a HW
-			      reset for the expected interrupt.
-			   */
-
-int ramcheck_time = 20;    /* time in seconds to wait while ROM code
-			      checks on-board RAM.
-			   */
-
-int osrun_time = 10;       /* time in seconds we wait for the OS to
-			      start running.
-			   */
+static char *ospath = "/etc/sound/wavefront.os"; /* where to find a processed
+						    version of the WaveFront OS
+						 */
+
+static int wait_usecs = 150; /* This magic number seems to give pretty optimal
+				throughput based on my limited experimentation.
+				If you want to play around with it and find a better
+				value, be my guest. Remember, the idea is to
+				get a number that causes us to just busy wait
+				for as many WaveFront commands as possible, without
+				coming up with a number so large that we hog the
+				whole CPU.
+
+				Specifically, with this number, out of about 134,000
+				status waits, only about 250 result in a sleep.
+			    */
+
+static int sleep_interval = 100;   /* HZ/sleep_interval seconds per sleep */
+static int sleep_tries = 50;       /* number of times we'll try to sleep */
+
+static int reset_time = 2;        /* hundreths of a second we wait after a HW
+				     reset for the expected interrupt.
+				  */
+
+static int ramcheck_time = 20;    /* time in seconds to wait while ROM code
+				     checks on-board RAM.
+				  */
+
+static int osrun_time = 10;       /* time in seconds we wait for the OS to
+				     start running.
+				  */
 module_param(wf_raw, int, 0444);
 MODULE_PARM_DESC(wf_raw, "if non-zero, assume that we need to boot the OS");
 module_param(fx_raw, int, 0444);
@@ -1709,7 +1709,7 @@
 7 Unused
 */
 
-int __init
+static int __init
 snd_wavefront_interrupt_bits (int irq)
 
 {
@@ -1922,7 +1922,7 @@
 
 {
 	unsigned char section[WF_SECTION_MAX];
-	char section_length; /* yes, just a char; max value is WF_SECTION_MAX */
+	signed char section_length; /* yes, just a char; max value is WF_SECTION_MAX */
 	int section_cnt_downloaded = 0;
 	int fd;
 	int c;
diff -uNr a/sound/Kconfig b/sound/Kconfig
--- a/sound/Kconfig	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/Kconfig	2005-01-14 22:28:11.945542432 +0100
@@ -70,7 +70,7 @@
 endmenu
 
 menu "Open Sound System"
-	depends on SOUND!=n && (BROKEN || !(SPARC32 || SPARC64))
+	depends on SOUND!=n && (BROKEN || (!SPARC32 && !SPARC64))
 
 config SOUND_PRIME
 	tristate "Open Sound System (DEPRECATED)"
diff -uNr a/sound/pci/ac97/ac97_codec.c b/sound/pci/ac97/ac97_codec.c
--- a/sound/pci/ac97/ac97_codec.c	2004-12-24 22:35:50.000000000 +0100
+++ b/sound/pci/ac97/ac97_codec.c	2005-01-14 22:28:25.650458968 +0100
@@ -332,11 +332,11 @@
 {
 	if (!snd_ac97_valid_reg(ac97, reg))
 		return;
-	spin_lock(&ac97->reg_lock);
+	down(&ac97->reg_mutex);
 	ac97->regs[reg] = value;
-	spin_unlock(&ac97->reg_lock);
 	ac97->bus->ops->write(ac97, reg, value);
 	set_bit(reg, ac97->reg_accessed);
+	up(&ac97->reg_mutex);
 }
 
 /**
@@ -357,14 +357,13 @@
 
 	if (!snd_ac97_valid_reg(ac97, reg))
 		return -EINVAL;
-	spin_lock(&ac97->reg_lock);
+	down(&ac97->reg_mutex);
 	change = ac97->regs[reg] != value;
 	if (change) {
 		ac97->regs[reg] = value;
-		spin_unlock(&ac97->reg_lock);
 		ac97->bus->ops->write(ac97, reg, value);
-	} else
-		spin_unlock(&ac97->reg_lock);
+	}
+	up(&ac97->reg_mutex);
 	return change;
 }
 
@@ -384,20 +383,29 @@
 int snd_ac97_update_bits(ac97_t *ac97, unsigned short reg, unsigned short mask, unsigned short value)
 {
 	int change;
-	unsigned short old, new;
 
 	if (!snd_ac97_valid_reg(ac97, reg))
 		return -EINVAL;
-	spin_lock(&ac97->reg_lock);
+	down(&ac97->reg_mutex);
+	change = snd_ac97_update_bits_nolock(ac97, reg, mask, value);
+	up(&ac97->reg_mutex);
+	return change;
+}
+
+/* no lock version - see snd_ac97_updat_bits() */
+int snd_ac97_update_bits_nolock(ac97_t *ac97, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
 	old = snd_ac97_read_cache(ac97, reg);
 	new = (old & ~mask) | value;
 	change = old != new;
 	if (change) {
 		ac97->regs[reg] = new;
-		spin_unlock(&ac97->reg_lock);
 		ac97->bus->ops->write(ac97, reg, new);
-	} else
-		spin_unlock(&ac97->reg_lock);
+	}
 	return change;
 }
 
@@ -406,15 +414,14 @@
 	int change;
 	unsigned short old, new, cfg;
 
-	down(&ac97->mutex);
-	spin_lock(&ac97->reg_lock);
+	down(&ac97->page_mutex);
 	old = ac97->spec.ad18xx.pcmreg[codec];
 	new = (old & ~mask) | value;
-	cfg = snd_ac97_read_cache(ac97, AC97_AD_SERIAL_CFG);
 	change = old != new;
 	if (change) {
+		down(&ac97->reg_mutex);
+		cfg = snd_ac97_read_cache(ac97, AC97_AD_SERIAL_CFG);
 		ac97->spec.ad18xx.pcmreg[codec] = new;
-		spin_unlock(&ac97->reg_lock);
 		/* select single codec */
 		ac97->bus->ops->write(ac97, AC97_AD_SERIAL_CFG,
 				 (cfg & ~0x7000) |
@@ -424,9 +431,9 @@
 		/* select all codecs */
 		ac97->bus->ops->write(ac97, AC97_AD_SERIAL_CFG,
 				 cfg | 0x7000);
-	} else
-		spin_unlock(&ac97->reg_lock);
-	up(&ac97->mutex);
+		up(&ac97->reg_mutex);
+	}
+	up(&ac97->page_mutex);
 	return change;
 }
 
@@ -536,104 +543,70 @@
 	return snd_ac97_update_bits(ac97, reg, 1 << shift, val << shift);
 }
 
-int snd_ac97_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+int snd_ac97_info_volsw(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
 {
 	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
 
 	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
+	uinfo->count = shift == rshift ? 1 : 2;
 	uinfo->value.integer.min = 0;
 	uinfo->value.integer.max = mask;
 	return 0;
 }
 
-int snd_ac97_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+int snd_ac97_get_volsw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 	int invert = (kcontrol->private_value >> 24) & 0x01;
 	
 	ucontrol->value.integer.value[0] = (snd_ac97_read_cache(ac97, reg) >> shift) & mask;
-	if (invert)
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] = (snd_ac97_read_cache(ac97, reg) >> rshift) & mask;
+	if (invert) {
 		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];
+	}
 	return 0;
 }
 
-int snd_ac97_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+int snd_ac97_put_volsw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 	int invert = (kcontrol->private_value >> 24) & 0x01;
-	unsigned short val;
+	unsigned short val, val2, val_mask;
 	
 	val = (ucontrol->value.integer.value[0] & mask);
 	if (invert)
 		val = mask - val;
-	return snd_ac97_update_bits(ac97, reg, mask << shift, val << shift);
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = mask - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+	return snd_ac97_update_bits(ac97, reg, val_mask, val);
 }
 
 #define AC97_DOUBLE(xname, reg, shift_left, shift_right, mask, invert) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), .info = snd_ac97_info_double, \
-  .get = snd_ac97_get_double, .put = snd_ac97_put_double, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), .info = snd_ac97_info_volsw, \
+  .get = snd_ac97_get_volsw, .put = snd_ac97_put_volsw, \
   .private_value = (reg) | ((shift_left) << 8) | ((shift_right) << 12) | ((mask) << 16) | ((invert) << 24) }
 
-static int snd_ac97_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
-{
-	int mask = (kcontrol->private_value >> 16) & 0xff;
-
-	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = mask;
-	return 0;
-}
-
-static int snd_ac97_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
-{
-	ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int shift_left = (kcontrol->private_value >> 8) & 0x0f;
-	int shift_right = (kcontrol->private_value >> 12) & 0x0f;
-	int mask = (kcontrol->private_value >> 16) & 0xff;
-	int invert = (kcontrol->private_value >> 24) & 0xff;
-	
-	spin_lock(&ac97->reg_lock);
-	ucontrol->value.integer.value[0] = (snd_ac97_read_cache(ac97, reg) >> shift_left) & mask;
-	ucontrol->value.integer.value[1] = (snd_ac97_read_cache(ac97, reg) >> shift_right) & mask;
-	spin_unlock(&ac97->reg_lock);
-	if (invert) {
-		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
-		ucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];
-	}
-	return 0;
-}
-
-static int snd_ac97_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
-{
-	ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int shift_left = (kcontrol->private_value >> 8) & 0x0f;
-	int shift_right = (kcontrol->private_value >> 12) & 0x0f;
-	int mask = (kcontrol->private_value >> 16) & 0xff;
-	int invert = (kcontrol->private_value >> 24) & 0xff;
-	unsigned short val1, val2;
-	
-	val1 = ucontrol->value.integer.value[0] & mask;
-	val2 = ucontrol->value.integer.value[1] & mask;
-	if (invert) {
-		val1 = mask - val1;
-		val2 = mask - val2;
-	}
-	return snd_ac97_update_bits(ac97, reg, 
-				    (mask << shift_left) | (mask << shift_right),
-				    (val1 << shift_left) | (val2 << shift_right));
-}
-
-int snd_ac97_getput_page(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol,
+static int snd_ac97_getput_page(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol,
 			 int (*func)(snd_kcontrol_t *, snd_ctl_elem_value_t *))
 {
 	ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
@@ -644,27 +617,27 @@
 	    (reg >= 0x60 && reg < 0x70)) {
 		unsigned short page_save;
 		unsigned short page = (kcontrol->private_value >> 25) & 0x0f;
-		down(&ac97->mutex); /* lock paging */
+		down(&ac97->page_mutex); /* lock paging */
 		page_save = snd_ac97_read(ac97, AC97_INT_PAGING) & AC97_PAGE_MASK;
 		snd_ac97_update_bits(ac97, AC97_INT_PAGING, AC97_PAGE_MASK, page);
 		err = func(kcontrol, ucontrol);
 		snd_ac97_update_bits(ac97, AC97_INT_PAGING, AC97_PAGE_MASK, page_save);
-		up(&ac97->mutex); /* unlock paging */
+		up(&ac97->page_mutex); /* unlock paging */
 	} else
 		err = func(kcontrol, ucontrol);
 	return err;
 }
 
 /* for rev2.3 paging */
-int snd_ac97_page_get_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+int snd_ac97_page_get_volsw(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
-	return snd_ac97_getput_page(kcontrol, ucontrol, snd_ac97_get_single);
+	return snd_ac97_getput_page(kcontrol, ucontrol, snd_ac97_get_volsw);
 }
 
 /* for rev2.3 paging */
-int snd_ac97_page_put_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+int snd_ac97_page_put_volsw(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
-	return snd_ac97_getput_page(kcontrol, ucontrol, snd_ac97_put_single);
+	return snd_ac97_getput_page(kcontrol, ucontrol, snd_ac97_put_volsw);
 }
 
 static const snd_kcontrol_new_t snd_ac97_controls_master_mono[2] = {
@@ -682,16 +655,9 @@
 AC97_SINGLE("PC Speaker Playback Volume", AC97_PC_BEEP, 1, 15, 1)
 };
 
-static const snd_kcontrol_new_t snd_ac97_controls_phone[2] = {
-AC97_SINGLE("Phone Playback Switch", AC97_PHONE, 15, 1, 1),
-AC97_SINGLE("Phone Playback Volume", AC97_PHONE, 0, 15, 1)
-};
+static const snd_kcontrol_new_t snd_ac97_controls_mic_boost =
+	AC97_SINGLE("Mic Boost (+20dB)", AC97_MIC, 6, 1, 0);
 
-static const snd_kcontrol_new_t snd_ac97_controls_mic[3] = {
-AC97_SINGLE("Mic Playback Switch", AC97_MIC, 15, 1, 1),
-AC97_SINGLE("Mic Playback Volume", AC97_MIC, 0, 15, 1),
-AC97_SINGLE("Mic Boost (+20dB)", AC97_MIC, 6, 1, 0)
-};
 
 static const snd_kcontrol_new_t snd_ac97_control_capture_src = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -793,12 +759,12 @@
 {
 	ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
 
-	spin_lock(&ac97->reg_lock);
+	down(&ac97->reg_mutex);
 	ucontrol->value.iec958.status[0] = ac97->spdif_status & 0xff;
 	ucontrol->value.iec958.status[1] = (ac97->spdif_status >> 8) & 0xff;
 	ucontrol->value.iec958.status[2] = (ac97->spdif_status >> 16) & 0xff;
 	ucontrol->value.iec958.status[3] = (ac97->spdif_status >> 24) & 0xff;
-	spin_unlock(&ac97->reg_lock);
+	up(&ac97->reg_mutex);
 	return 0;
 }
                         
@@ -809,7 +775,6 @@
 	unsigned short val = 0;
 	int change;
 
-	spin_lock(&ac97->reg_lock);
 	new = val = ucontrol->value.iec958.status[0] & (IEC958_AES0_PROFESSIONAL|IEC958_AES0_NONAUDIO);
 	if (ucontrol->value.iec958.status[0] & IEC958_AES0_PROFESSIONAL) {
 		new |= ucontrol->value.iec958.status[0] & (IEC958_AES0_PRO_FS|IEC958_AES0_PRO_EMPHASIS_5015);
@@ -838,9 +803,9 @@
 		}
 	}
 
+	down(&ac97->reg_mutex);
 	change = ac97->spdif_status != new;
 	ac97->spdif_status = new;
-	spin_unlock(&ac97->reg_lock);
 
 	if (ac97->flags & AC97_CS_SPDIF) {
 		int x = (val >> 12) & 0x03;
@@ -849,23 +814,24 @@
 		case 2: x = 0; break;  // 48.0
 		default: x = 0; break; // illegal.
 		}
-		change |= snd_ac97_update_bits(ac97, AC97_CSR_SPDIF, 0x3fff, ((val & 0xcfff) | (x << 12)));
+		change |= snd_ac97_update_bits_nolock(ac97, AC97_CSR_SPDIF, 0x3fff, ((val & 0xcfff) | (x << 12)));
 	} else if (ac97->flags & AC97_CX_SPDIF) {
 		int v;
 		v = new & (IEC958_AES0_CON_EMPHASIS_5015|IEC958_AES0_CON_NOT_COPYRIGHT) ? 0 : AC97_CXR_COPYRGT;
 		v |= new & IEC958_AES0_NONAUDIO ? AC97_CXR_SPDIF_AC3 : AC97_CXR_SPDIF_PCM;
-		change |= snd_ac97_update_bits(ac97, AC97_CXR_AUDIO_MISC, 
-					       AC97_CXR_SPDIF_MASK | AC97_CXR_COPYRGT,
-					       v);
+		change |= snd_ac97_update_bits_nolock(ac97, AC97_CXR_AUDIO_MISC, 
+						      AC97_CXR_SPDIF_MASK | AC97_CXR_COPYRGT,
+						      v);
 	} else {
 		unsigned short extst = snd_ac97_read_cache(ac97, AC97_EXTENDED_STATUS);
-		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0); /* turn off */
+		snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0); /* turn off */
 
-		change |= snd_ac97_update_bits(ac97, AC97_SPDIF, 0x3fff, val);
+		change |= snd_ac97_update_bits_nolock(ac97, AC97_SPDIF, 0x3fff, val);
 		if (extst & AC97_EA_SPDIF) {
-			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF); /* turn on again */
+			snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF); /* turn on again */
                 }
 	}
+	up(&ac97->reg_mutex);
 
 	return change;
 }
@@ -878,26 +844,26 @@
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 	// int invert = (kcontrol->private_value >> 24) & 0xff;
 	unsigned short value, old, new;
+	int change;
 
 	value = (ucontrol->value.integer.value[0] & mask);
 
+	down(&ac97->reg_mutex);
 	mask <<= shift;
 	value <<= shift;
-	spin_lock(&ac97->reg_lock);
 	old = snd_ac97_read_cache(ac97, reg);
 	new = (old & ~mask) | value;
-	spin_unlock(&ac97->reg_lock);
+	change = old != new;
 
-	if (old != new) {
-		int change;
+	if (change) {
 		unsigned short extst = snd_ac97_read_cache(ac97, AC97_EXTENDED_STATUS);
-		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0); /* turn off */
-		change = snd_ac97_update_bits(ac97, reg, mask, value);
+		snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0); /* turn off */
+		change = snd_ac97_update_bits_nolock(ac97, reg, mask, value);
 		if (extst & AC97_EA_SPDIF)
-			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF); /* turn on again */
-		return change;
+			snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF); /* turn on again */
 	}
-	return 0;
+	up(&ac97->reg_mutex);
+	return change;
 }
 
 const snd_kcontrol_new_t snd_ac97_controls_spdif[5] = {
@@ -927,8 +893,8 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "AC97-SPSA",
-		.info = snd_ac97_info_single,
-		.get = snd_ac97_get_single,
+		.info = snd_ac97_info_volsw,
+		.get = snd_ac97_get_volsw,
 		.put = snd_ac97_put_spsa,
 		.private_value = AC97_SINGLE_VALUE(AC97_EXTENDED_STATUS, 4, 3, 0)
 	},
@@ -1007,10 +973,10 @@
 	ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
 	int codec = kcontrol->private_value & 3;
 	
-	spin_lock(&ac97->reg_lock);
+	down(&ac97->page_mutex);
 	ucontrol->value.integer.value[0] = 31 - ((ac97->spec.ad18xx.pcmreg[codec] >> 0) & 31);
 	ucontrol->value.integer.value[1] = 31 - ((ac97->spec.ad18xx.pcmreg[codec] >> 8) & 31);
-	spin_unlock(&ac97->reg_lock);
+	up(&ac97->page_mutex);
 	return 0;
 }
 
@@ -1055,8 +1021,7 @@
 {
 	if (bus) {
 		snd_ac97_bus_proc_done(bus);
-		if (bus->pcms)
-			kfree(bus->pcms);
+		kfree(bus->pcms);
 		if (bus->private_free)
 			bus->private_free(bus);
 		kfree(bus);
@@ -1148,6 +1113,26 @@
 	return 1;		/* success, useable */
 }
 
+static void check_volume_resolution(ac97_t *ac97, int reg, unsigned char *lo_max, unsigned char *hi_max)
+{
+	unsigned short cbit[3] = { 0x20, 0x10, 0x01 };
+	unsigned char max[3] = { 63, 31, 15 };
+	int i;
+
+	*lo_max = *hi_max = 0;
+	for (i = 0 ; i < ARRAY_SIZE(cbit); i++) {
+		unsigned short val;
+		snd_ac97_write(ac97, reg, 0x8080 | cbit[i] | (cbit[i] << 8));
+		val = snd_ac97_read(ac97, reg);
+		if (! *lo_max && (val & cbit[i]))
+			*lo_max = max[i];
+		if (! *hi_max && (val & (cbit[i] << 8)))
+			*hi_max = max[i];
+		if (*lo_max && *hi_max)
+			break;
+	}
+}
+
 int snd_ac97_try_bit(ac97_t * ac97, int reg, int bit)
 {
 	unsigned short mask, val, orig, res;
@@ -1161,21 +1146,6 @@
 	return res == val;
 }
 
-static void snd_ac97_change_volume_params1(ac97_t * ac97, int reg, unsigned char *max)
-{
-	unsigned short val, val1;
-
-	*max = 63;
-	val = 0x8000 | 0x0020;
-	snd_ac97_write(ac97, reg, val);
-	val1 = snd_ac97_read(ac97, reg);
-	if (val != val1) {
-		*max = 31;
-	}
-	/* reset volume to zero */
-	snd_ac97_write_cache(ac97, reg, 0x8000);
-}
-
 /* check the volume resolution of center/lfe */
 static void snd_ac97_change_volume_params2(ac97_t * ac97, int reg, int shift, unsigned char *max)
 {
@@ -1192,34 +1162,6 @@
 	snd_ac97_write_cache(ac97, reg, 0x8080);
 }
 
-/* check whether the volume resolution is 4 or 5 bits */
-static void snd_ac97_change_volume_params3(ac97_t * ac97, int reg, unsigned char *max)
-{
-	unsigned short val, val1;
-
-	*max = 31;
-	val = 0x8000 | 0x0010;
-	snd_ac97_write(ac97, reg, val);
-	val1 = snd_ac97_read(ac97, reg);
-	if (val != val1) {
-		*max = 15;
-	}
-	/* reset volume to zero */
-	snd_ac97_write_cache(ac97, reg, 0x8000);
-}
-
-/* check whether the volume is mono or stereo */
-static int snd_ac97_is_stereo_vol(ac97_t *ac97, int reg)
-{
-	unsigned short val, val1, val2;
-	val = snd_ac97_read(ac97, reg);
-	val1 = val | 0x8000 | (0x01 << 8);
-	snd_ac97_write(ac97, reg, val1);
-	val2 = snd_ac97_read(ac97, reg);
-	snd_ac97_write(ac97, reg, val); /* restore */
-	return val1 == val2;
-}
-
 static inline int printable(unsigned int x)
 {
 	x &= 0xff;
@@ -1246,22 +1188,22 @@
 static int snd_ac97_cmute_new(snd_card_t *card, char *name, int reg, ac97_t *ac97)
 {
 	snd_kcontrol_t *kctl;
-	int stereo = 0;
+	int err;
+	unsigned short val, val1, mute_mask;
 
 	if (! snd_ac97_valid_reg(ac97, reg))
 		return 0;
 
+	mute_mask = 0x8000;
+	val = snd_ac97_read(ac97, reg);
 	if (ac97->flags & AC97_STEREO_MUTES) {
 		/* check whether both mute bits work */
-		unsigned short val, val1;
-		val = snd_ac97_read(ac97, reg);
 		val1 = val | 0x8080;
 		snd_ac97_write(ac97, reg, val1);
 		if (val1 == snd_ac97_read(ac97, reg))
-			stereo = 1;
-		snd_ac97_write(ac97, reg, val);
+			mute_mask = 0x8080;
 	}
-	if (stereo) {
+	if (mute_mask == 0x8080) {
 		snd_kcontrol_new_t tmp = AC97_DOUBLE(name, reg, 15, 7, 1, 1);
 		tmp.index = ac97->num;
 		kctl = snd_ctl_new1(&tmp, ac97);
@@ -1270,50 +1212,68 @@
 		tmp.index = ac97->num;
 		kctl = snd_ctl_new1(&tmp, ac97);
 	}
-	return snd_ctl_add(card, kctl);
+	err = snd_ctl_add(card, kctl);
+	if (err < 0)
+		return err;
+	/* mute as default */
+	snd_ac97_write_cache(ac97, reg, val | mute_mask);
+	return 0;
 }
 
 /*
- * create volumes for normal stereo controls
+ * create a volume for normal stereo/mono controls
  */
-static int snd_ac97_cvol_new(snd_card_t *card, char *name, int reg, unsigned int max, ac97_t *ac97)
+static int snd_ac97_cvol_new(snd_card_t *card, char *name, int reg, unsigned int lo_max,
+			     unsigned int hi_max, ac97_t *ac97)
 {
 	int err;
-	snd_kcontrol_new_t tmp = AC97_DOUBLE(name, reg, 8, 0, (unsigned int)max, 1);
-	tmp.index = ac97->num;
+	snd_kcontrol_t *kctl;
 
 	if (! snd_ac97_valid_reg(ac97, reg))
 		return 0;
-	if ((err = snd_ctl_add(card, snd_ctl_new1(&tmp, ac97))) < 0)
+	if (hi_max) {
+		/* invert */
+		snd_kcontrol_new_t tmp = AC97_DOUBLE(name, reg, 8, 0, lo_max, 1);
+		tmp.index = ac97->num;
+		kctl = snd_ctl_new1(&tmp, ac97);
+	} else {
+		/* invert */
+		snd_kcontrol_new_t tmp = AC97_SINGLE(name, reg, 0, lo_max, 1);
+		tmp.index = ac97->num;
+		kctl = snd_ctl_new1(&tmp, ac97);
+	}
+	err = snd_ctl_add(card, kctl);
+	if (err < 0)
 		return err;
 	snd_ac97_write_cache(ac97, reg,
-			     ((ac97->flags & AC97_STEREO_MUTES) ? 0x8080 : 0x8000) |
-			     (unsigned short)max | ((unsigned short)max << 8));
+			     (snd_ac97_read(ac97, reg) & 0x8080) |
+			     lo_max | (hi_max << 8));
 	return 0;
 }
 
 /*
- * create mute-switch and volumes for normal stereo controls
+ * create a mute-switch and a volume for normal stereo/mono controls
  */
-static int snd_ac97_cmix_new(snd_card_t *card, const char *pfx, int reg, int check_res, ac97_t *ac97)
+static int snd_ac97_cmix_new(snd_card_t *card, const char *pfx, int reg, ac97_t *ac97)
 {
 	int err;
 	char name[44];
-	unsigned char max;
+	unsigned char lo_max, hi_max;
 
 	if (! snd_ac97_valid_reg(ac97, reg))
 		return 0;
 
-	sprintf(name, "%s Switch", pfx);
-	if ((err = snd_ac97_cmute_new(card, name, reg, ac97)) < 0)
-		return err;
-	sprintf(name, "%s Volume", pfx);
-	if (check_res)
-		snd_ac97_change_volume_params1(ac97, reg, &max);
-	else
-		max = 31; /* 5bit */
-	if ((err = snd_ac97_cvol_new(card, name, reg, max, ac97)) < 0)
-		return err;
+	if (snd_ac97_try_bit(ac97, reg, 15)) {
+		sprintf(name, "%s Switch", pfx);
+		if ((err = snd_ac97_cmute_new(card, name, reg, ac97)) < 0)
+			return err;
+	}
+	check_volume_resolution(ac97, reg, &lo_max, &hi_max);
+	if (lo_max) {
+		sprintf(name, "%s Volume", pfx);
+		if ((err = snd_ac97_cvol_new(card, name, reg, lo_max, hi_max, ac97)) < 0)
+			return err;
+	}
 	return 0;
 }
 
@@ -1331,7 +1291,11 @@
 	/* build master controls */
 	/* AD claims to remove this control from AD1887, although spec v2.2 does not allow this */
 	if (snd_ac97_try_volume_mix(ac97, AC97_MASTER)) {
-		if ((err = snd_ac97_cmix_new(card, "Master Playback", AC97_MASTER, 1, ac97)) < 0)
+		if (ac97->flags & AC97_HAS_NO_MASTER_VOL)
+			err = snd_ac97_cmute_new(card, "Master Playback Switch", AC97_MASTER, ac97);
+		else
+			err = snd_ac97_cmix_new(card, "Master Playback", AC97_MASTER, ac97);
+		if (err < 0)
 			return err;
 	}
 
@@ -1363,32 +1327,20 @@
 
 	/* build surround controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_SURROUND_MASTER)) {
-		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_surround[0], ac97))) < 0)
-			return err;
-		if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_surround[1], ac97))) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Surround Playback", AC97_SURROUND_MASTER, ac97)) < 0)
 			return err;
-		snd_ac97_change_volume_params2(ac97, AC97_SURROUND_MASTER, 0, &max);
-		kctl->private_value &= ~(0xff << 16);
-		kctl->private_value |= (int)max << 16;
-		snd_ac97_write_cache(ac97, AC97_SURROUND_MASTER, 0x8080 | max | (max << 8));
 	}
 
 	/* build headphone controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_HEADPHONE)) {
-		if ((err = snd_ac97_cmix_new(card, "Headphone Playback", AC97_HEADPHONE, 1, ac97)) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Headphone Playback", AC97_HEADPHONE, ac97)) < 0)
 			return err;
 	}
 	
 	/* build master mono controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_MASTER_MONO)) {
-		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_master_mono[0], ac97))) < 0)
-			return err;
-		if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_master_mono[1], ac97))) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Master Mono Playback", AC97_MASTER_MONO, ac97)) < 0)
 			return err;
-		snd_ac97_change_volume_params1(ac97, AC97_MASTER_MONO, &max);
-		kctl->private_value &= ~(0xff << 16);
-		kctl->private_value |= (int)max << 16;
-		snd_ac97_write_cache(ac97, AC97_MASTER_MONO, 0x8000 | max);
 	}
 	
 	/* build master tone controls */
@@ -1416,56 +1368,39 @@
 	
 	/* build Phone controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_PHONE)) {
-		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_phone[0], ac97))) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Phone Playback", AC97_PHONE, ac97)) < 0)
 			return err;
-		if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_phone[1], ac97))) < 0)
-			return err;
-		snd_ac97_change_volume_params3(ac97, AC97_PHONE, &max);
-		kctl->private_value &= ~(0xff << 16);
-		kctl->private_value |= (int)max << 16;
-		snd_ac97_write_cache(ac97, AC97_PHONE, 0x8000 | max);
 	}
 	
 	/* build MIC controls */
-	snd_ac97_change_volume_params3(ac97, AC97_MIC, &max);
-	if (snd_ac97_is_stereo_vol(ac97, AC97_MIC)) {
-		/* build stereo mic */
-		if ((err = snd_ac97_cmute_new(card, "Mic Playback Switch", AC97_MIC, ac97)) < 0)
-			return err;
-		if ((err = snd_ac97_cvol_new(card, "Mic Playback Volume", AC97_MIC, max, ac97)) < 0)
+	if (snd_ac97_try_volume_mix(ac97, AC97_MIC)) {
+		if ((err = snd_ac97_cmix_new(card, "Mic Playback", AC97_MIC, ac97)) < 0)
 			return err;
-		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_mic[2], ac97))) < 0)
+		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_mic_boost, ac97))) < 0)
 			return err;
-	} else {
-		/* build mono mic */
-		for (idx = 0; idx < 3; idx++) {
-			if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_mic[idx], ac97))) < 0)
-				return err;
-			if (idx == 1) {		// volume
-				kctl->private_value &= ~(0xff << 16);
-				kctl->private_value |= (int)max << 16;
-			}
-		}
-		snd_ac97_write_cache(ac97, AC97_MIC, 0x8000 | max);
 	}
 
 	/* build Line controls */
-	if ((err = snd_ac97_cmix_new(card, "Line Playback", AC97_LINE, 0, ac97)) < 0)
-		return err;
+	if (snd_ac97_try_volume_mix(ac97, AC97_LINE)) {
+		if ((err = snd_ac97_cmix_new(card, "Line Playback", AC97_LINE, ac97)) < 0)
+			return err;
+	}
 	
 	/* build CD controls */
-	if ((err = snd_ac97_cmix_new(card, "CD Playback", AC97_CD, 0, ac97)) < 0)
-		return err;
+	if (snd_ac97_try_volume_mix(ac97, AC97_CD)) {
+		if ((err = snd_ac97_cmix_new(card, "CD Playback", AC97_CD, ac97)) < 0)
+			return err;
+	}
 	
 	/* build Video controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_VIDEO)) {
-		if ((err = snd_ac97_cmix_new(card, "Video Playback", AC97_VIDEO, 0, ac97)) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Video Playback", AC97_VIDEO, ac97)) < 0)
 			return err;
 	}
 
 	/* build Aux controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_AUX)) {
-		if ((err = snd_ac97_cmix_new(card, "Aux Playback", AC97_AUX, 0, ac97)) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Aux Playback", AC97_AUX, ac97)) < 0)
 			return err;
 	}
 
@@ -1497,15 +1432,12 @@
 		}
 		snd_ac97_write_cache(ac97, AC97_PCM, init_val);
 	} else {
-		if ((err = snd_ac97_cmute_new(card, "PCM Playback Switch", AC97_PCM, ac97)) < 0)
+		if (ac97->flags & AC97_HAS_NO_PCM_VOL)
+			err = snd_ac97_cmute_new(card, "PCM Playback Switch", AC97_PCM, ac97);
+		else
+			err = snd_ac97_cmix_new(card, "PCM Playback", AC97_PCM, ac97);
+		if (err < 0)
 			return err;
-		/* FIXME: C-Media chips have no PCM volume!! */
-		if (ac97->id == AC97_ID_CM9739)
-			snd_ac97_write_cache(ac97, AC97_PCM, 0x9f1f);
-		else {
-			if ((err = snd_ac97_cvol_new(card, "PCM Playback Volume", AC97_PCM, 31, ac97)) < 0)
-				return err;
-		}
 	}
 
 	/* build Capture controls */
@@ -1573,7 +1505,7 @@
 	snd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, ~AC97_GP_DRSS_MASK, 0x0000);
 
 	/* build 3D controls */
-	if (ac97->build_ops && ac97->build_ops->build_3d) {
+	if (ac97->build_ops->build_3d) {
 		ac97->build_ops->build_3d(ac97);
 	} else {
 		if (snd_ac97_try_volume_mix(ac97, AC97_3D_CONTROL)) {
@@ -1596,14 +1528,14 @@
 
 	/* build S/PDIF controls */
 	if (ac97->ext_id & AC97_EI_SPDIF) {
-		if (ac97->build_ops && ac97->build_ops->build_spdif) {
+		if (ac97->build_ops->build_spdif) {
 			if ((err = ac97->build_ops->build_spdif(ac97)) < 0)
 				return err;
 		} else {
 			for (idx = 0; idx < 5; idx++)
 				if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_spdif[idx], ac97))) < 0)
 					return err;
-			if (ac97->build_ops && ac97->build_ops->build_post_spdif) {
+			if (ac97->build_ops->build_post_spdif) {
 				if ((err = ac97->build_ops->build_post_spdif(ac97)) < 0)
 					return err;
 			}
@@ -1616,7 +1548,7 @@
 	}
 	
 	/* build chip specific controls */
-	if (ac97->build_ops && ac97->build_ops->build_specific)
+	if (ac97->build_ops->build_specific)
 		if ((err = ac97->build_ops->build_specific(ac97)) < 0)
 			return err;
 
@@ -1662,6 +1594,14 @@
 {
 	unsigned int result = 0;
 
+	if (ac97->bus->no_vra) {
+		*r_result = SNDRV_PCM_RATE_48000;
+		if ((ac97->flags & AC97_DOUBLE_RATE) &&
+		    reg == AC97_PCM_FRONT_DAC_RATE)
+			*r_result |= SNDRV_PCM_RATE_96000;
+		return;
+	}
+
 	if ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)
 		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,
 				     AC97_EA_DRA, 0);
@@ -1863,7 +1803,7 @@
 	bus->clock = 48000;
 	spin_lock_init(&bus->bus_lock);
 	snd_ac97_bus_proc_init(bus);
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, bus, &dev_ops)) < 0) {
+	if ((err = snd_device_new(card, SNDRV_DEV_BUS, bus, &dev_ops)) < 0) {
 		snd_ac97_bus_free(bus);
 		return err;
 	}
@@ -1871,6 +1811,9 @@
 	return 0;
 }
 
+/* build_ops to do nothing */
+static struct snd_ac97_build_ops null_build_ops;
+
 /**
  * snd_ac97_mixer - create an Codec97 component
  * @bus: the AC97 bus which codec is attached to
@@ -1936,8 +1879,8 @@
 	ac97->limited_regs = template->limited_regs;
 	memcpy(ac97->reg_accessed, template->reg_accessed, sizeof(ac97->reg_accessed));
 	bus->codec[ac97->num] = ac97;
-	spin_lock_init(&ac97->reg_lock);
-	init_MUTEX(&ac97->mutex);
+	init_MUTEX(&ac97->reg_mutex);
+	init_MUTEX(&ac97->page_mutex);
 
 	if (ac97->pci) {
 		pci_read_config_word(ac97->pci, PCI_SUBSYSTEM_VENDOR_ID, &ac97->subsystem_vendor);
@@ -1968,7 +1911,8 @@
       __access_ok:
 	ac97->id = snd_ac97_read(ac97, AC97_VENDOR_ID1) << 16;
 	ac97->id |= snd_ac97_read(ac97, AC97_VENDOR_ID2);
-	if (ac97->id == 0x00000000 || ac97->id == 0xffffffff) {
+	if (! (ac97->scaps & AC97_SCAP_DETECT_BY_VENDOR) &&
+	    (ac97->id == 0x00000000 || ac97->id == 0xffffffff)) {
 		snd_printk(KERN_ERR "AC'97 %d access is not valid [0x%x], removing mixer.\n", ac97->num, ac97->id);
 		snd_ac97_free(ac97);
 		return -EIO;
@@ -2064,9 +2008,11 @@
 		ac97->addr = (ac97->ext_id & AC97_EI_ADDR_MASK) >> AC97_EI_ADDR_SHIFT;
 	else
 		ac97->addr = (ac97->ext_mid & AC97_MEI_ADDR_MASK) >> AC97_MEI_ADDR_SHIFT;
-	if (ac97->ext_id & 0x0189) {	/* L/R, MIC, SDAC, LDAC VRA support */
+	if (ac97->ext_id & 0x01c9) {	/* L/R, MIC, SDAC, LDAC VRA support */
 		reg = snd_ac97_read(ac97, AC97_EXTENDED_STATUS);
-		reg |= ac97->ext_id & 0x0189;
+		reg |= ac97->ext_id & 0x01c0; /* LDAC/SDAC/CDAC */
+		if (! bus->no_vra)
+			reg |= ac97->ext_id & 0x0009; /* VRA/VRM */
 		snd_ac97_write_cache(ac97, AC97_EXTENDED_STATUS, reg);
 	}
 	if ((ac97->ext_id & AC97_EI_DRA) && bus->dra) {
@@ -2107,7 +2053,11 @@
 		bus->ops->init(ac97);
 	snd_ac97_get_name(ac97, ac97->id, name, !ac97_is_audio(ac97));
 	snd_ac97_get_name(NULL, ac97->id, name, !ac97_is_audio(ac97));  // ac97->id might be changed in the special setup code
+	if (! ac97->build_ops)
+		ac97->build_ops = &null_build_ops;
+
 	if (ac97_is_audio(ac97)) {
+		char comp[16];
 		if (card->mixername[0] == '\0') {
 			strcpy(card->mixername, name);
 		} else {
@@ -2116,7 +2066,8 @@
 				strcat(card->mixername, name);
 			}
 		}
-		if ((err = snd_component_add(card, "AC97a")) < 0) {
+		sprintf(comp, "AC97a:%08x", ac97->id);
+		if ((err = snd_component_add(card, comp)) < 0) {
 			snd_ac97_free(ac97);
 			return err;
 		}
@@ -2126,6 +2077,7 @@
 		}
 	}
 	if (ac97_is_modem(ac97)) {
+		char comp[16];
 		if (card->mixername[0] == '\0') {
 			strcpy(card->mixername, name);
 		} else {
@@ -2134,7 +2086,8 @@
 				strcat(card->mixername, name);
 			}
 		}
-		if ((err = snd_component_add(card, "AC97m")) < 0) {
+		sprintf(comp, "AC97m:%08x", ac97->id);
+		if ((err = snd_component_add(card, comp)) < 0) {
 			snd_ac97_free(ac97);
 			return err;
 		}
@@ -2153,7 +2106,7 @@
 		snd_ac97_write_cache(ac97, AC97_EXTENDED_STATUS, reg);
 	}
 	snd_ac97_proc_init(ac97);
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ac97, &ops)) < 0) {
+	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, ac97, &ops)) < 0) {
 		snd_ac97_free(ac97);
 		return err;
 	}
@@ -2210,9 +2163,51 @@
  */
 void snd_ac97_suspend(ac97_t *ac97)
 {
+	if (ac97->build_ops->suspend)
+		ac97->build_ops->suspend(ac97);
 	snd_ac97_powerdown(ac97);
 }
 
+/*
+ * restore ac97 status
+ */
+void snd_ac97_restore_status(ac97_t *ac97)
+{
+	int i;
+
+	for (i = 2; i < 0x7c ; i += 2) {
+		if (i == AC97_POWERDOWN || i == AC97_EXTENDED_ID)
+			continue;
+		/* restore only accessible registers
+		 * some chip (e.g. nm256) may hang up when unsupported registers
+		 * are accessed..!
+		 */
+		if (test_bit(i, ac97->reg_accessed)) {
+			snd_ac97_write(ac97, i, ac97->regs[i]);
+			snd_ac97_read(ac97, i);
+		}
+	}
+}
+
+/*
+ * restore IEC958 status
+ */
+void snd_ac97_restore_iec958(ac97_t *ac97)
+{
+	if (ac97->ext_id & AC97_EI_SPDIF) {
+		if (ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_SPDIF) {
+			/* reset spdif status */
+			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
+			snd_ac97_write(ac97, AC97_EXTENDED_STATUS, ac97->regs[AC97_EXTENDED_STATUS]);
+			if (ac97->flags & AC97_CS_SPDIF)
+				snd_ac97_write(ac97, AC97_CSR_SPDIF, ac97->regs[AC97_CSR_SPDIF]);
+			else
+				snd_ac97_write(ac97, AC97_SPDIF, ac97->regs[AC97_SPDIF]);
+			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF); /* turn on again */
+		}
+	}
+}
+
 /**
  * snd_ac97_resume - General resume function for AC97 codec
  * @ac97: the ac97 instance
@@ -2222,7 +2217,7 @@
  */
 void snd_ac97_resume(ac97_t *ac97)
 {
-	int i, is_ad18xx, codec;
+	int i;
 
 	if (ac97->bus->ops->reset) {
 		ac97->bus->ops->reset(ac97);
@@ -2264,72 +2259,18 @@
 	if (ac97->bus->ops->init)
 		ac97->bus->ops->init(ac97);
 
-	is_ad18xx = (ac97->flags & AC97_AD_MULTI);
-	if (is_ad18xx) {
-		/* restore the AD18xx codec configurations */
-		for (codec = 0; codec < 3; codec++) {
-			if (! ac97->spec.ad18xx.id[codec])
-				continue;
-			/* select single codec */
-			snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000,
-					     ac97->spec.ad18xx.unchained[codec] | ac97->spec.ad18xx.chained[codec]);
-			ac97->bus->ops->write(ac97, AC97_AD_CODEC_CFG, ac97->spec.ad18xx.codec_cfg[codec]);
-		}
-		/* select all codecs */
-		snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000, 0x7000);
-	}
-
-	/* restore ac97 status */
-	for (i = 2; i < 0x7c ; i += 2) {
-		if (i == AC97_POWERDOWN || i == AC97_EXTENDED_ID)
-			continue;
-		/* restore only accessible registers
-		 * some chip (e.g. nm256) may hang up when unsupported registers
-		 * are accessed..!
-		 */
-		if (test_bit(i, ac97->reg_accessed)) {
-			if (is_ad18xx) {
-				/* handle multi codecs for AD18xx */
-				if (i == AC97_PCM) {
-					for (codec = 0; codec < 3; codec++) {
-						if (! ac97->spec.ad18xx.id[codec])
-							continue;
-						/* select single codec */
-						snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000,
-								     ac97->spec.ad18xx.unchained[codec] | ac97->spec.ad18xx.chained[codec]);
-						/* update PCM bits */
-						ac97->bus->ops->write(ac97, AC97_PCM, ac97->spec.ad18xx.pcmreg[codec]);
-					}
-					/* select all codecs */
-					snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000, 0x7000);
-					continue;
-				} else if (i == AC97_AD_TEST ||
-					   i == AC97_AD_CODEC_CFG ||
-					   i == AC97_AD_SERIAL_CFG)
-					continue; /* ignore */
-			}
-			snd_ac97_write(ac97, i, ac97->regs[i]);
-			snd_ac97_read(ac97, i);
-		}
-	}
-
-	if (ac97->ext_id & AC97_EI_SPDIF) {
-		if (ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_SPDIF) {
-			/* reset spdif status */
-			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
-			snd_ac97_write(ac97, AC97_EXTENDED_STATUS, ac97->regs[AC97_EXTENDED_STATUS]);
-			if (ac97->flags & AC97_CS_SPDIF)
-				snd_ac97_write(ac97, AC97_CSR_SPDIF, ac97->regs[AC97_CSR_SPDIF]);
-			else
-				snd_ac97_write(ac97, AC97_SPDIF, ac97->regs[AC97_SPDIF]);
-			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF); /* turn on again */
-		}
+	if (ac97->build_ops->resume)
+		ac97->build_ops->resume(ac97);
+	else {
+		snd_ac97_restore_status(ac97);
+		snd_ac97_restore_iec958(ac97);
 	}
 }
 #endif
 
 
 /*
+ * Hardware tuning
  */
 static void set_ctl_name(char *dst, const char *src, const char *suffix)
 {
@@ -2339,6 +2280,7 @@
 		strcpy(dst, src);
 }	
 
+/* remove the control with the given name and optional suffix */
 int snd_ac97_remove_ctl(ac97_t *ac97, const char *name, const char *suffix)
 {
 	snd_ctl_elem_id_t id;
@@ -2357,6 +2299,7 @@
 	return snd_ctl_find_id(ac97->bus->card, &sid);
 }
 
+/* rename the control with the given name and optional suffix */
 int snd_ac97_rename_ctl(ac97_t *ac97, const char *src, const char *dst, const char *suffix)
 {
 	snd_kcontrol_t *kctl = ctl_find(ac97, src, suffix);
@@ -2374,6 +2317,7 @@
 	snd_ac97_rename_ctl(ac97, src, dst, "Volume");
 }
 
+/* swap controls */
 int snd_ac97_swap_ctl(ac97_t *ac97, const char *s1, const char *s2, const char *suffix)
 {
 	snd_kcontrol_t *kctl1, *kctl2;
@@ -2387,20 +2331,29 @@
 	return -ENOENT;
 }
 
-static int swap_headphone(ac97_t *ac97, int remove_master)
+/* ac97 tune: use Headphone control as master */
+static int tune_hp_only(ac97_t *ac97)
 {
 	if (ctl_find(ac97, "Headphone Playback Switch", NULL) == NULL)
 		return -ENOENT;
-	if (remove_master) {
-		snd_ac97_remove_ctl(ac97, "Master Playback", "Switch");
-		snd_ac97_remove_ctl(ac97, "Master Playback", "Volume");
-	} else
-		snd_ac97_rename_vol_ctl(ac97, "Master Playback", "Line-Out Playback");
+	snd_ac97_remove_ctl(ac97, "Master Playback", "Switch");
+	snd_ac97_remove_ctl(ac97, "Master Playback", "Volume");
+	snd_ac97_rename_vol_ctl(ac97, "Headphone Playback", "Master Playback");
+	return 0;
+}
+
+/* ac97 tune: swap Headphone and Master controls */
+static int tune_swap_hp(ac97_t *ac97)
+{
+	if (ctl_find(ac97, "Headphone Playback Switch", NULL) == NULL)
+		return -ENOENT;
+	snd_ac97_rename_vol_ctl(ac97, "Master Playback", "Line-Out Playback");
 	snd_ac97_rename_vol_ctl(ac97, "Headphone Playback", "Master Playback");
 	return 0;
 }
 
-static int swap_surround(ac97_t *ac97)
+/* ac97 tune: swap Surround and Master controls */
+static int tune_swap_surround(ac97_t *ac97)
 {
 	if (snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Switch") ||
 	    snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Volume"))
@@ -2408,6 +2361,7 @@
 	return 0;
 }
 
+/* ac97 tune: set up mic sharing for AD codecs */
 static int tune_ad_sharing(ac97_t *ac97)
 {
 	unsigned short scfg;
@@ -2424,6 +2378,7 @@
 static const snd_kcontrol_new_t snd_ac97_alc_jack_detect = 
 AC97_SINGLE("Jack Detect", AC97_ALC650_CLOCK, 5, 1, 0);
 
+/* ac97 tune: set up ALC jack-select */
 static int tune_alc_jack(ac97_t *ac97)
 {
 	if ((ac97->id & 0xffffff00) != 0x414c4700) {
@@ -2435,6 +2390,7 @@
 	return snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&snd_ac97_alc_jack_detect, ac97));
 }
 
+/* ac97 tune: inversed EAPD bit */
 static int tune_inv_eapd(ac97_t *ac97)
 {
 	snd_kcontrol_t *kctl = ctl_find(ac97, "External Amplifier", NULL);
@@ -2444,24 +2400,79 @@
 	return 0;
 }
 
-static int apply_quirk(ac97_t *ac97, int quirk)
+static int master_mute_sw_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
-	switch (quirk) {
-	case AC97_TUNE_NONE:
-		return 0;
-	case AC97_TUNE_HP_ONLY:
-		return swap_headphone(ac97, 1);
-	case AC97_TUNE_SWAP_HP:
-		return swap_headphone(ac97, 0);
-	case AC97_TUNE_SWAP_SURROUND:
-		return swap_surround(ac97);
-	case AC97_TUNE_AD_SHARING:
-		return tune_ad_sharing(ac97);
-	case AC97_TUNE_ALC_JACK:
-		return tune_alc_jack(ac97);
-	case AC97_TUNE_INV_EAPD:
-		return tune_inv_eapd(ac97);
+	int err = snd_ac97_put_volsw(kcontrol, ucontrol);
+	if (err > 0) {
+		ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
+		int shift = (kcontrol->private_value >> 8) & 0x0f;
+		int rshift = (kcontrol->private_value >> 12) & 0x0f;
+		unsigned short mask;
+		if (shift != rshift)
+			mask = 0x8080;
+		else
+			mask = 0x8000;
+		snd_ac97_update_bits(ac97, AC97_POWERDOWN, 0x8000,
+				     (ac97->regs[AC97_MASTER] & mask) == mask ?
+				     0x8000 : 0);
 	}
+	return err;
+}
+
+/* ac97 tune: EAPD controls mute LED bound with the master mute */
+static int tune_mute_led(ac97_t *ac97)
+{
+	snd_kcontrol_t *msw = ctl_find(ac97, "Master Playback Switch", NULL);
+	if (! msw)
+		return -ENOENT;
+	msw->put = master_mute_sw_put;
+	snd_ac97_remove_ctl(ac97, "External Amplifier", NULL);
+	snd_ac97_update_bits(ac97, AC97_POWERDOWN, 0x8000, 0x8000); /* mute LED on */
+	return 0;
+}
+
+struct quirk_table {
+	const char *name;
+	int (*func)(ac97_t *);
+};
+
+static struct quirk_table applicable_quirks[] = {
+	{ "none", NULL },
+	{ "hp_only", tune_hp_only },
+	{ "swap_hp", tune_swap_hp },
+	{ "swap_surround", tune_swap_surround },
+	{ "ad_sharing", tune_ad_sharing },
+	{ "alc_jack", tune_alc_jack },
+	{ "inv_eapd", tune_inv_eapd },
+	{ "mute_led", tune_mute_led },
+};
+
+/* apply the quirk with the given type */
+static int apply_quirk(ac97_t *ac97, int type)
+{
+	if (type <= 0)
+		return 0;
+	else if (type >= ARRAY_SIZE(applicable_quirks))
+		return -EINVAL;
+	if (applicable_quirks[type].func)
+		return applicable_quirks[type].func(ac97);
+	return 0;
+}
+
+/* apply the quirk with the given name */
+static int apply_quirk_str(ac97_t *ac97, const char *typestr)
+{
+	int i;
+	struct quirk_table *q;
+
+	for (i = 0; i < ARRAY_SIZE(applicable_quirks); i++) {
+		q = &applicable_quirks[i];
+		if (q->name && ! strcmp(typestr, q->name))
+			return apply_quirk(ac97, i);
+	}
+	/* for compatibility, accept the numbers, too */
+	if (*typestr >= '0' && *typestr <= '9')
+		return apply_quirk(ac97, (int)simple_strtol(typestr, NULL, 10));
 	return -EINVAL;
 }
 
@@ -2469,7 +2480,7 @@
  * snd_ac97_tune_hardware - tune up the hardware
  * @ac97: the ac97 instance
  * @quirk: quirk list
- * @override: explicit quirk value (overrides the list if not AC97_TUNE_DEFAULT)
+ * @override: explicit quirk value (overrides the list if non-NULL)
  *
  * Do some workaround for each pci device, such as renaming of the
  * headphone (true line-out) control as "Master".
@@ -2478,16 +2489,17 @@
  * Returns zero if successful, or a negative error code on failure.
  */
 
-int snd_ac97_tune_hardware(ac97_t *ac97, struct ac97_quirk *quirk, int override)
+int snd_ac97_tune_hardware(ac97_t *ac97, struct ac97_quirk *quirk, const char *override)
 {
 	int result;
 
 	snd_assert(quirk, return -EINVAL);
 
-	if (override != AC97_TUNE_DEFAULT) {
-		result = apply_quirk(ac97, override);
+	/* quirk overriden? */
+	if (override && strcmp(override, "-1") && strcmp(override, "default")) {
+		result = apply_quirk_str(ac97, override);
 		if (result < 0)
-			snd_printk(KERN_ERR "applying quirk type %d failed (%d)\n", override, result);
+			snd_printk(KERN_ERR "applying quirk type %s failed (%d)\n", override, result);
 		return result;
 	}
 
diff -uNr a/sound/pci/ac97/ac97_local.h b/sound/pci/ac97/ac97_local.h
--- a/sound/pci/ac97/ac97_local.h	2004-12-24 22:34:30.000000000 +0100
+++ b/sound/pci/ac97/ac97_local.h	2005-01-14 22:28:11.964539544 +0100
@@ -22,15 +22,15 @@
  *
  */
 
-#define AC97_SINGLE_VALUE(reg,shift,mask,invert) ((reg) | ((shift) << 8) | ((mask) << 16) | ((invert) << 24))
-#define AC97_PAGE_SINGLE_VALUE(reg,shift,mask,invert,page) ((reg) | ((shift) << 8) | ((mask) << 16) | ((invert) << 24) | ((page) << 25))
+#define AC97_SINGLE_VALUE(reg,shift,mask,invert) ((reg) | ((shift) << 8) | ((shift) << 12) | ((mask) << 16) | ((invert) << 24))
+#define AC97_PAGE_SINGLE_VALUE(reg,shift,mask,invert,page) (AC97_SINGLE_VALUE(reg,shift,mask,invert) | ((page) << 25))
 #define AC97_SINGLE(xname, reg, shift, mask, invert) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ac97_info_single, \
-  .get = snd_ac97_get_single, .put = snd_ac97_put_single, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ac97_info_volsw, \
+  .get = snd_ac97_get_volsw, .put = snd_ac97_put_volsw, \
   .private_value =  AC97_SINGLE_VALUE(reg, shift, mask, invert) }
 #define AC97_PAGE_SINGLE(xname, reg, shift, mask, invert, page)		\
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ac97_info_single, \
-  .get = snd_ac97_page_get_single, .put = snd_ac97_page_put_single, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ac97_info_volsw, \
+  .get = snd_ac97_page_get_volsw, .put = snd_ac97_page_put_volsw, \
   .private_value =  AC97_PAGE_SINGLE_VALUE(reg, shift, mask, invert, page) }
 
 /* ac97_codec.c */
@@ -39,16 +39,21 @@
 extern const snd_kcontrol_new_t snd_ac97_controls_spdif[];
 snd_kcontrol_t *snd_ac97_cnew(const snd_kcontrol_new_t *_template, ac97_t * ac97);
 void snd_ac97_get_name(ac97_t *ac97, unsigned int id, char *name, int modem);
-int snd_ac97_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo);
-int snd_ac97_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
-int snd_ac97_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
-int snd_ac97_page_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
-int snd_ac97_page_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
+int snd_ac97_info_volsw(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo);
+int snd_ac97_get_volsw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
+int snd_ac97_put_volsw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
+int snd_ac97_page_get_volsw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
+int snd_ac97_page_put_volsw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol);
 int snd_ac97_try_bit(ac97_t * ac97, int reg, int bit);
 int snd_ac97_remove_ctl(ac97_t *ac97, const char *name, const char *suffix);
 int snd_ac97_rename_ctl(ac97_t *ac97, const char *src, const char *dst, const char *suffix);
 int snd_ac97_swap_ctl(ac97_t *ac97, const char *s1, const char *s2, const char *suffix);
 void snd_ac97_rename_vol_ctl(ac97_t *ac97, const char *src, const char *dst);
+void snd_ac97_restore_status(ac97_t *ac97);
+void snd_ac97_restore_iec958(ac97_t *ac97);
+
+int snd_ac97_update_bits_nolock(ac97_t *ac97, unsigned short reg,
+				unsigned short mask, unsigned short value);
 
 /* ac97_proc.c */
 #ifdef CONFIG_PROC_FS
diff -uNr a/sound/pci/ac97/ac97_patch.c b/sound/pci/ac97/ac97_patch.c
--- a/sound/pci/ac97/ac97_patch.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/pci/ac97/ac97_patch.c	2005-01-14 22:28:25.661457296 +0100
@@ -55,12 +55,12 @@
 	unsigned short page_save;
 	int ret;
 
-	down(&ac97->mutex);
+	down(&ac97->page_mutex);
 	page_save = snd_ac97_read(ac97, AC97_INT_PAGING) & AC97_PAGE_MASK;
 	snd_ac97_update_bits(ac97, AC97_INT_PAGING, AC97_PAGE_MASK, page);
 	ret = snd_ac97_update_bits(ac97, reg, mask, value);
 	snd_ac97_update_bits(ac97, AC97_INT_PAGING, AC97_PAGE_MASK, page_save);
-	up(&ac97->mutex); /* unlock paging */
+	up(&ac97->page_mutex); /* unlock paging */
 	return ret;
 }
 
@@ -775,6 +775,71 @@
 /*
  * Analog Device AD18xx, AD19xx codecs
  */
+#ifdef CONFIG_PM
+static void ad18xx_resume(ac97_t *ac97)
+{
+	static unsigned short setup_regs[] = {
+		AC97_AD_MISC, AC97_AD_SERIAL_CFG, AC97_AD_JACK_SPDIF,
+	};
+	int i, codec;
+
+	for (i = 0; i < (int)ARRAY_SIZE(setup_regs); i++) {
+		unsigned short reg = setup_regs[i];
+		if (test_bit(reg, ac97->reg_accessed)) {
+			snd_ac97_write(ac97, reg, ac97->regs[reg]);
+			snd_ac97_read(ac97, reg);
+		}
+	}
+
+	if (! (ac97->flags & AC97_AD_MULTI))
+		/* normal restore */
+		snd_ac97_restore_status(ac97);
+	else {
+		/* restore the AD18xx codec configurations */
+		for (codec = 0; codec < 3; codec++) {
+			if (! ac97->spec.ad18xx.id[codec])
+				continue;
+			/* select single codec */
+			snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000,
+					     ac97->spec.ad18xx.unchained[codec] | ac97->spec.ad18xx.chained[codec]);
+			ac97->bus->ops->write(ac97, AC97_AD_CODEC_CFG, ac97->spec.ad18xx.codec_cfg[codec]);
+		}
+		/* select all codecs */
+		snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000, 0x7000);
+
+		/* restore status */
+		for (i = 2; i < 0x7c ; i += 2) {
+			if (i == AC97_POWERDOWN || i == AC97_EXTENDED_ID)
+				continue;
+			if (test_bit(i, ac97->reg_accessed)) {
+				/* handle multi codecs for AD18xx */
+				if (i == AC97_PCM) {
+					for (codec = 0; codec < 3; codec++) {
+						if (! ac97->spec.ad18xx.id[codec])
+							continue;
+						/* select single codec */
+						snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000,
+								     ac97->spec.ad18xx.unchained[codec] | ac97->spec.ad18xx.chained[codec]);
+						/* update PCM bits */
+						ac97->bus->ops->write(ac97, AC97_PCM, ac97->spec.ad18xx.pcmreg[codec]);
+					}
+					/* select all codecs */
+					snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 0x7000, 0x7000);
+					continue;
+				} else if (i == AC97_AD_TEST ||
+					   i == AC97_AD_CODEC_CFG ||
+					   i == AC97_AD_SERIAL_CFG)
+					continue; /* ignore */
+			}
+			snd_ac97_write(ac97, i, ac97->regs[i]);
+			snd_ac97_read(ac97, i);
+		}
+	}
+
+	snd_ac97_restore_iec958(ac97);
+}
+#endif
+
 int patch_ad1819(ac97_t * ac97)
 {
 	unsigned short scfg;
@@ -843,6 +908,12 @@
 	}
 }
 
+static struct snd_ac97_build_ops patch_ad1881_build_ops = {
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume
+#endif
+};
+
 int patch_ad1881(ac97_t * ac97)
 {
 	static const char cfg_idxs[3][2] = {
@@ -897,6 +968,7 @@
 		ac97->id &= 0xffff0000;
 		ac97->id |= ac97->spec.ad18xx.id[0];
 	}
+	ac97->build_ops = &patch_ad1881_build_ops;
 	return 0;
 }
 
@@ -919,7 +991,10 @@
 }
 
 static struct snd_ac97_build_ops patch_ad1885_build_ops = {
-	.build_specific = &patch_ad1885_specific
+	.build_specific = &patch_ad1885_specific,
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume
+#endif
 };
 
 int patch_ad1885(ac97_t * ac97)
@@ -1013,8 +1088,23 @@
  	return patch_build_controls(ac97, &snd_ac97_ad198x_spdif_source, 1);
 }
 
+static const snd_kcontrol_new_t snd_ac97_ad1981x_jack_sense[] = {
+	AC97_SINGLE("Headphone Jack Sense", AC97_AD_JACK_SPDIF, 11, 1, 0),
+	AC97_SINGLE("Line Jack Sense", AC97_AD_JACK_SPDIF, 12, 1, 0),
+};
+
+static int patch_ad1981a_specific(ac97_t * ac97)
+{
+	return patch_build_controls(ac97, snd_ac97_ad1981x_jack_sense,
+				    ARRAY_SIZE(snd_ac97_ad1981x_jack_sense));
+}
+
 static struct snd_ac97_build_ops patch_ad1981a_build_ops = {
-	.build_post_spdif = patch_ad198x_post_spdif
+	.build_post_spdif = patch_ad198x_post_spdif,
+	.build_specific = patch_ad1981a_specific,
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume
+#endif
 };
 
 int patch_ad1981a(ac97_t *ac97)
@@ -1023,6 +1113,7 @@
 	ac97->build_ops = &patch_ad1981a_build_ops;
 	snd_ac97_update_bits(ac97, AC97_AD_MISC, AC97_AD198X_MSPLT, AC97_AD198X_MSPLT);
 	ac97->flags |= AC97_STEREO_MUTES;
+	snd_ac97_update_bits(ac97, AC97_AD_JACK_SPDIF, 1<<11, 1<<11); /* HP jack sense */
 	return 0;
 }
 
@@ -1031,12 +1122,20 @@
 
 static int patch_ad1981b_specific(ac97_t *ac97)
 {
-	return patch_build_controls(ac97, &snd_ac97_ad198x_2cmic, 1);
+	int err;
+
+	if ((err = patch_build_controls(ac97, &snd_ac97_ad198x_2cmic, 1)) < 0)
+		return err;
+	return patch_build_controls(ac97, snd_ac97_ad1981x_jack_sense,
+				    ARRAY_SIZE(snd_ac97_ad1981x_jack_sense));
 }
 
 static struct snd_ac97_build_ops patch_ad1981b_build_ops = {
 	.build_post_spdif = patch_ad198x_post_spdif,
-	.build_specific = patch_ad1981b_specific
+	.build_specific = patch_ad1981b_specific,
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume
+#endif
 };
 
 int patch_ad1981b(ac97_t *ac97)
@@ -1045,6 +1144,7 @@
 	ac97->build_ops = &patch_ad1981b_build_ops;
 	snd_ac97_update_bits(ac97, AC97_AD_MISC, AC97_AD198X_MSPLT, AC97_AD198X_MSPLT);
 	ac97->flags |= AC97_STEREO_MUTES;
+	snd_ac97_update_bits(ac97, AC97_AD_JACK_SPDIF, 1<<11, 1<<11); /* HP jack sense */
 	return 0;
 }
 
@@ -1150,7 +1250,10 @@
 
 static struct snd_ac97_build_ops patch_ad1888_build_ops = {
 	.build_post_spdif = patch_ad198x_post_spdif,
-	.build_specific = patch_ad1888_specific
+	.build_specific = patch_ad1888_specific,
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume
+#endif
 };
 
 int patch_ad1888(ac97_t * ac97)
@@ -1184,7 +1287,10 @@
 
 static struct snd_ac97_build_ops patch_ad1980_build_ops = {
 	.build_post_spdif = patch_ad198x_post_spdif,
-	.build_specific = patch_ad1980_specific
+	.build_specific = patch_ad1980_specific,
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume
+#endif
 };
 
 int patch_ad1980(ac97_t * ac97)
@@ -1210,7 +1316,10 @@
 
 static struct snd_ac97_build_ops patch_ad1985_build_ops = {
 	.build_post_spdif = patch_ad198x_post_spdif,
-	.build_specific = patch_ad1985_specific
+	.build_specific = patch_ad1985_specific,
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume
+#endif
 };
 
 int patch_ad1985(ac97_t * ac97)
@@ -1294,7 +1403,7 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Mic As Center/LFE",
-		.info = snd_ac97_info_single,
+		.info = snd_ac97_info_volsw,
 		.get = snd_ac97_alc650_mic_get,
 		.put = snd_ac97_alc650_mic_put,
 		.private_value = AC97_SINGLE_VALUE(0, 0, 1, 0) /* only mask needed */
@@ -1304,7 +1413,8 @@
 static const snd_kcontrol_new_t snd_ac97_spdif_controls_alc650[] = {
         AC97_SINGLE("IEC958 Capture Switch", AC97_ALC650_MULTICH, 11, 1, 0),
         AC97_SINGLE("Analog to IEC958 Output", AC97_ALC650_MULTICH, 12, 1, 0),
-        AC97_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 13, 1, 0),
+	/* disable this controls since it doesn't work as expected */
+	/* AC97_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 13, 1, 0), */
 };
 
 static int patch_alc650_specific(ac97_t * ac97)
@@ -1405,7 +1515,7 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Mic As Center/LFE",
-		.info = snd_ac97_info_single,
+		.info = snd_ac97_info_volsw,
 		.get = snd_ac97_alc655_mic_get,
 		.put = snd_ac97_alc655_mic_put,
 		.private_value = AC97_SINGLE_VALUE(0, 0, 1, 0) /* only mask needed */
@@ -1454,7 +1564,8 @@
 
 static const snd_kcontrol_new_t snd_ac97_spdif_controls_alc655[] = {
         AC97_PAGE_SINGLE("IEC958 Capture Switch", AC97_ALC650_MULTICH, 11, 1, 0, 0),
-        AC97_PAGE_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 14, 1, 0, 0),
+	/* disable this controls since it doesn't work as expected */
+        /* AC97_PAGE_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 14, 1, 0, 0), */
 	{
 		.iface  = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name   = "IEC958 Playback Route",
@@ -1494,7 +1605,10 @@
 
 	/* adjust default values */
 	val = snd_ac97_read(ac97, 0x7a); /* misc control */
-	val |= (1 << 1); /* spdif input pin */
+	if (ac97->id == 0x414c4780) /* ALC658 */
+		val &= ~(1 << 1); /* Pin 47 is spdif input pin */
+	else /* ALC655 */
+		val |= (1 << 1); /* Pin 47 is spdif input pin */
 	val &= ~(1 << 12); /* vref enable */
 	snd_ac97_write_cache(ac97, 0x7a, val);
 	/* set default: spdif-in enabled,
@@ -1557,7 +1671,7 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Line-In As Surround",
-		.info = snd_ac97_info_single,
+		.info = snd_ac97_info_volsw,
 		.get = ac97_alc850_surround_get,
 		.put = ac97_alc850_surround_put,
 		.private_value = AC97_SINGLE_VALUE(0, 0, 1, 0) /* only mask needed */
@@ -1565,7 +1679,7 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Mic As Center/LFE",
-		.info = snd_ac97_info_single,
+		.info = snd_ac97_info_volsw,
 		.get = ac97_alc850_mic_get,
 		.put = ac97_alc850_mic_put,
 		.private_value = AC97_SINGLE_VALUE(0, 0, 1, 0) /* only mask needed */
@@ -1644,6 +1758,11 @@
 int patch_cm9738(ac97_t * ac97)
 {
 	ac97->build_ops = &patch_cm9738_ops;
+	/* FIXME: can anyone confirm below? */
+	/* CM9738 has no PCM volume although the register reacts */
+	ac97->flags |= AC97_HAS_NO_PCM_VOL;
+	snd_ac97_write_cache(ac97, AC97_PCM, 0x8000);
+
 	return 0;
 }
 
@@ -1720,7 +1839,7 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Mic As Center/LFE",
-		.info = snd_ac97_info_single,
+		.info = snd_ac97_info_volsw,
 		.get = snd_ac97_cm9739_center_mic_get,
 		.put = snd_ac97_cm9739_center_mic_put,
 		.private_value = AC97_SINGLE_VALUE(0, 0, 1, 0) /* only mask needed */
@@ -1748,6 +1867,11 @@
 
 	ac97->build_ops = &patch_cm9739_ops;
 
+	/* CM9739/A has no Master and PCM volume although the register reacts */
+	ac97->flags |= AC97_HAS_NO_MASTER_VOL | AC97_HAS_NO_PCM_VOL;
+	snd_ac97_write_cache(ac97, AC97_MASTER, 0x8000);
+	snd_ac97_write_cache(ac97, AC97_PCM, 0x8000);
+
 	/* check spdif */
 	val = snd_ac97_read(ac97, AC97_EXTENDED_STATUS);
 	if (val & AC97_EA_SPCV) {
@@ -1766,8 +1890,12 @@
 	/* bit 12: disable center/lfe (swithable) */
 	/* bit 10: disable surround/line (switchable) */
 	/* bit 9: mix 2 surround off */
+	/* bit 4: undocumented; 0 mutes the CM9739A, which defaults to 1 */
+	/* bit 3: undocumented; surround? */
 	/* bit 0: dB */
-	val = (1 << 13);
+	val = snd_ac97_read(ac97, AC97_CM9739_MULTI_CHAN) & (1 << 4);
+	val |= (1 << 3);
+	val |= (1 << 13);
 	if (! (ac97->ext_id & AC97_EI_SPDIF))
 		val |= (1 << 14);
 	snd_ac97_write_cache(ac97, AC97_CM9739_MULTI_CHAN, val);
@@ -1830,7 +1958,7 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Line-In As Surround",
-		.info = snd_ac97_info_single,
+		.info = snd_ac97_info_volsw,
 		.get = snd_ac97_cm9761_linein_rear_get,
 		.put = snd_ac97_cm9761_linein_rear_put,
 		.private_value = AC97_SINGLE_VALUE(0, 0, 1, 0) /* only mask needed */
@@ -1838,7 +1966,7 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Mic As Center/LFE",
-		.info = snd_ac97_info_single,
+		.info = snd_ac97_info_volsw,
 		.get = snd_ac97_cm9761_center_mic_get,
 		.put = snd_ac97_cm9761_center_mic_put,
 		.private_value = AC97_SINGLE_VALUE(0, 0, 1, 0) /* only mask needed */
@@ -1859,6 +1987,11 @@
 {
 	unsigned short val;
 
+	/* CM9761 has no Master and PCM volume although the register reacts */
+	ac97->flags |= AC97_HAS_NO_MASTER_VOL | AC97_HAS_NO_PCM_VOL;
+	snd_ac97_write_cache(ac97, AC97_MASTER, 0x8000);
+	snd_ac97_write_cache(ac97, AC97_PCM, 0x8000);
+
 	ac97->spec.dev_flags = 0; /* 1 = model 82 revision B */
 	if (ac97->id == AC97_ID_CM9761_82) {
 		unsigned short tmp;
diff -uNr a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
--- a/sound/pci/ac97/ac97_pcm.c	2004-12-24 22:34:00.000000000 +0100
+++ b/sound/pci/ac97/ac97_pcm.c	2005-01-14 22:28:11.976537720 +0100
@@ -206,14 +206,12 @@
 		mask = AC97_SC_SPSR_MASK;
 	}
 
-	spin_lock(&ac97->reg_lock);
+	down(&ac97->reg_mutex);
 	old = snd_ac97_read(ac97, reg) & mask;
-	spin_unlock(&ac97->reg_lock);
 	if (old != bits) {
-		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
-		snd_ac97_update_bits(ac97, reg, mask, bits);
+		snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
+		snd_ac97_update_bits_nolock(ac97, reg, mask, bits);
 		/* update the internal spdif bits */
-		spin_lock(&ac97->reg_lock);
 		sbits = ac97->spdif_status;
 		if (sbits & IEC958_AES0_PROFESSIONAL) {
 			sbits &= ~IEC958_AES0_PRO_FS;
@@ -231,9 +229,9 @@
 			}
 		}
 		ac97->spdif_status = sbits;
-		spin_unlock(&ac97->reg_lock);
 	}
-	snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);
+	snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);
+	up(&ac97->reg_mutex);
 	return 0;
 }
 
diff -uNr a/sound/pci/ac97/ac97_proc.c b/sound/pci/ac97/ac97_proc.c
--- a/sound/pci/ac97/ac97_proc.c	2004-12-24 22:35:49.000000000 +0100
+++ b/sound/pci/ac97/ac97_proc.c	2005-01-14 22:28:11.979537264 +0100
@@ -296,7 +296,7 @@
 {
 	ac97_t *ac97 = entry->private_data;
 	
-	down(&ac97->mutex);
+	down(&ac97->page_mutex);
 	if ((ac97->id & 0xffffff40) == AC97_ID_AD1881) {	// Analog Devices AD1881/85/86
 		int idx;
 		for (idx = 0; idx < 3; idx++)
@@ -322,7 +322,7 @@
 	} else {
 		snd_ac97_proc_read_main(ac97, buffer, 0);
 	}
-	up(&ac97->mutex);
+	up(&ac97->page_mutex);
 }
 
 #ifdef CONFIG_SND_DEBUG
@@ -332,7 +332,7 @@
 	ac97_t *ac97 = entry->private_data;
 	char line[64];
 	unsigned int reg, val;
-	down(&ac97->mutex);
+	down(&ac97->page_mutex);
 	while (!snd_info_get_line(buffer, line, sizeof(line))) {
 		if (sscanf(line, "%x %x", &reg, &val) != 2)
 			continue;
@@ -340,7 +340,7 @@
 		if (reg < 0x80 && (reg & 1) == 0 && val <= 0xffff)
 			snd_ac97_write_cache(ac97, reg, val);
 	}
-	up(&ac97->mutex);
+	up(&ac97->page_mutex);
 }
 #endif
 
@@ -359,7 +359,7 @@
 {
 	ac97_t *ac97 = entry->private_data;
 
-	down(&ac97->mutex);
+	down(&ac97->page_mutex);
 	if ((ac97->id & 0xffffff40) == AC97_ID_AD1881) {	// Analog Devices AD1881/85/86
 
 		int idx;
@@ -375,7 +375,7 @@
 	} else {
 		snd_ac97_proc_regs_read_main(ac97, buffer, 0);
 	}	
-	up(&ac97->mutex);
+	up(&ac97->page_mutex);
 }
 
 void snd_ac97_proc_init(ac97_t * ac97)
diff -uNr a/sound/pci/ac97/ak4531_codec.c b/sound/pci/ac97/ak4531_codec.c
--- a/sound/pci/ac97/ak4531_codec.c	2004-12-24 22:34:00.000000000 +0100
+++ b/sound/pci/ac97/ak4531_codec.c	2005-01-14 22:28:11.983536656 +0100
@@ -72,16 +72,15 @@
 static int snd_ak4531_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	ak4531_t *ak4531 = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 16) & 0x07;
 	int mask = (kcontrol->private_value >> 24) & 0xff;
 	int invert = (kcontrol->private_value >> 22) & 1;
 	int val;
 
-	spin_lock_irqsave(&ak4531->reg_lock, flags);
+	down(&ak4531->reg_mutex);
 	val = (ak4531->regs[reg] >> shift) & mask;
-	spin_unlock_irqrestore(&ak4531->reg_lock, flags);
+	up(&ak4531->reg_mutex);
 	if (invert) {
 		val = mask - val;
 	}
@@ -92,7 +91,6 @@
 static int snd_ak4531_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	ak4531_t *ak4531 = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 16) & 0x07;
 	int mask = (kcontrol->private_value >> 24) & 0xff;
@@ -105,11 +103,11 @@
 		val = mask - val;
 	}
 	val <<= shift;
-	spin_lock_irqsave(&ak4531->reg_lock, flags);
+	down(&ak4531->reg_mutex);
 	val = (ak4531->regs[reg] & ~(mask << shift)) | val;
 	change = val != ak4531->regs[reg];
 	ak4531->write(ak4531, reg, ak4531->regs[reg] = val);
-	spin_unlock_irqrestore(&ak4531->reg_lock, flags);
+	up(&ak4531->reg_mutex);
 	return change;
 }
 
@@ -133,7 +131,6 @@
 static int snd_ak4531_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	ak4531_t *ak4531 = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int left_reg = kcontrol->private_value & 0xff;
 	int right_reg = (kcontrol->private_value >> 8) & 0xff;
 	int left_shift = (kcontrol->private_value >> 16) & 0x07;
@@ -142,10 +139,10 @@
 	int invert = (kcontrol->private_value >> 22) & 1;
 	int left, right;
 
-	spin_lock_irqsave(&ak4531->reg_lock, flags);
+	down(&ak4531->reg_mutex);
 	left = (ak4531->regs[left_reg] >> left_shift) & mask;
 	right = (ak4531->regs[right_reg] >> right_shift) & mask;
-	spin_unlock_irqrestore(&ak4531->reg_lock, flags);
+	up(&ak4531->reg_mutex);
 	if (invert) {
 		left = mask - left;
 		right = mask - right;
@@ -158,7 +155,6 @@
 static int snd_ak4531_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	ak4531_t *ak4531 = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int left_reg = kcontrol->private_value & 0xff;
 	int right_reg = (kcontrol->private_value >> 8) & 0xff;
 	int left_shift = (kcontrol->private_value >> 16) & 0x07;
@@ -176,7 +172,7 @@
 	}
 	left <<= left_shift;
 	right <<= right_shift;
-	spin_lock_irqsave(&ak4531->reg_lock, flags);
+	down(&ak4531->reg_mutex);
 	if (left_reg == right_reg) {
 		left = (ak4531->regs[left_reg] & ~((mask << left_shift) | (mask << right_shift))) | left | right;
 		change = left != ak4531->regs[left_reg];
@@ -188,7 +184,7 @@
 		ak4531->write(ak4531, left_reg, ak4531->regs[left_reg] = left);
 		ak4531->write(ak4531, right_reg, ak4531->regs[right_reg] = right);
 	}
-	spin_unlock_irqrestore(&ak4531->reg_lock, flags);
+	up(&ak4531->reg_mutex);
 	return change;
 }
 
@@ -210,25 +206,23 @@
 static int snd_ak4531_get_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	ak4531_t *ak4531 = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int reg1 = kcontrol->private_value & 0xff;
 	int reg2 = (kcontrol->private_value >> 8) & 0xff;
 	int left_shift = (kcontrol->private_value >> 16) & 0x0f;
 	int right_shift = (kcontrol->private_value >> 24) & 0x0f;
 
-	spin_lock_irqsave(&ak4531->reg_lock, flags);
+	down(&ak4531->reg_mutex);
 	ucontrol->value.integer.value[0] = (ak4531->regs[reg1] >> left_shift) & 1;
 	ucontrol->value.integer.value[1] = (ak4531->regs[reg2] >> left_shift) & 1;
 	ucontrol->value.integer.value[2] = (ak4531->regs[reg1] >> right_shift) & 1;
 	ucontrol->value.integer.value[3] = (ak4531->regs[reg2] >> right_shift) & 1;
-	spin_unlock_irqrestore(&ak4531->reg_lock, flags);
+	up(&ak4531->reg_mutex);
 	return 0;
 }
 
 static int snd_ak4531_put_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	ak4531_t *ak4531 = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int reg1 = kcontrol->private_value & 0xff;
 	int reg2 = (kcontrol->private_value >> 8) & 0xff;
 	int left_shift = (kcontrol->private_value >> 16) & 0x0f;
@@ -236,7 +230,7 @@
 	int change;
 	int val1, val2;
 
-	spin_lock_irqsave(&ak4531->reg_lock, flags);
+	down(&ak4531->reg_mutex);
 	val1 = ak4531->regs[reg1] & ~((1 << left_shift) | (1 << right_shift));
 	val2 = ak4531->regs[reg2] & ~((1 << left_shift) | (1 << right_shift));
 	val1 |= (ucontrol->value.integer.value[0] & 1) << left_shift;
@@ -246,7 +240,7 @@
 	change = val1 != ak4531->regs[reg1] || val2 != ak4531->regs[reg2];
 	ak4531->write(ak4531, reg1, ak4531->regs[reg1] = val1);
 	ak4531->write(ak4531, reg2, ak4531->regs[reg2] = val2);
-	spin_unlock_irqrestore(&ak4531->reg_lock, flags);
+	up(&ak4531->reg_mutex);
 	return change;
 }
 
@@ -367,7 +361,7 @@
 	if (ak4531 == NULL)
 		return -ENOMEM;
 	*ak4531 = *_ak4531;
-	spin_lock_init(&ak4531->reg_lock);
+	init_MUTEX(&ak4531->reg_mutex);
 	if ((err = snd_component_add(card, "AK4531")) < 0) {
 		snd_ak4531_free(ak4531);
 		return err;
@@ -388,7 +382,7 @@
 		}
 	}
 	snd_ak4531_proc_init(card, ak4531);
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ak4531, &ops)) < 0) {
+	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, ak4531, &ops)) < 0) {
 		snd_ak4531_free(ak4531);
 		return err;
 	}
diff -uNr a/sound/pci/ali5451/ali5451.c b/sound/pci/ali5451/ali5451.c
--- a/sound/pci/ali5451/ali5451.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/pci/ali5451/ali5451.c	2005-01-14 22:28:11.989535744 +0100
@@ -1933,7 +1933,6 @@
 
 	spin_unlock_irq(&chip->reg_lock);
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1971,7 +1970,6 @@
 	spin_unlock_irq(&chip->reg_lock);
 
 	snd_ac97_resume(chip->ac97);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	
 	return 0;
 }
@@ -1989,8 +1987,7 @@
 		pci_release_regions(codec->pci);
 	pci_disable_device(codec->pci);
 #ifdef CONFIG_PM
-	if (codec->image)
-		kfree(codec->image);
+	kfree(codec->image);
 #endif
 	kfree(codec);
 	return 0;
diff -uNr a/sound/pci/atiixp.c b/sound/pci/atiixp.c
--- a/sound/pci/atiixp.c	2004-12-24 22:34:58.000000000 +0100
+++ b/sound/pci/atiixp.c	2005-01-14 22:28:25.670455928 +0100
@@ -43,6 +43,7 @@
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int ac97_clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 48000};
+static char *ac97_quirk[SNDRV_CARDS];
 static int spdif_aclink[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
 
 module_param_array(index, int, NULL, 0444);
@@ -53,6 +54,8 @@
 MODULE_PARM_DESC(enable, "Enable audio part of ATI IXP controller.");
 module_param_array(ac97_clock, int, NULL, 0444);
 MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (default 48000Hz).");
+module_param_array(ac97_quirk, charp, NULL, 0444);
+MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
 module_param_array(spdif_aclink, bool, NULL, 0444);
 MODULE_PARM_DESC(spdif_aclink, "S/PDIF over AC-link.");
 
@@ -264,7 +267,6 @@
 	ac97_t *ac97[NUM_ATI_CODECS];
 
 	spinlock_t reg_lock;
-	spinlock_t ac97_lock;
 
 	atiixp_dma_t dmas[NUM_ATI_DMAS];
 	struct ac97_pcm *pcms[NUM_ATI_PCMS];
@@ -476,20 +478,14 @@
 static unsigned short snd_atiixp_ac97_read(ac97_t *ac97, unsigned short reg)
 {
 	atiixp_t *chip = ac97->private_data;
-	unsigned short data;
-	spin_lock(&chip->ac97_lock);
-	data = snd_atiixp_codec_read(chip, ac97->num, reg);
-	spin_unlock(&chip->ac97_lock);
-	return data;
+	return snd_atiixp_codec_read(chip, ac97->num, reg);
     
 }
 
 static void snd_atiixp_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
 {
 	atiixp_t *chip = ac97->private_data;
-	spin_lock(&chip->ac97_lock);
 	snd_atiixp_codec_write(chip, ac97->num, reg, val);
-	spin_unlock(&chip->ac97_lock);
 }
 
 /*
@@ -637,21 +633,20 @@
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	atiixp_dma_t *dma = (atiixp_dma_t *)runtime->private_data;
 	unsigned int curptr;
+	int timeout = 1000;
 
-	spin_lock(&chip->reg_lock);
-	curptr = readl(chip->remap_addr + dma->ops->dt_cur);
-	if (curptr < dma->buf_addr) {
-		snd_printdd("curptr = %x, base = %x\n", curptr, dma->buf_addr);
-		curptr = 0;
-	} else {
+	while (timeout--) {
+		curptr = readl(chip->remap_addr + dma->ops->dt_cur);
+		if (curptr < dma->buf_addr)
+			continue;
 		curptr -= dma->buf_addr;
-		if (curptr >= dma->buf_bytes) {
-			snd_printdd("curptr = %x, size = %x\n", curptr, dma->buf_bytes);
-			curptr = 0;
-		}
+		if (curptr >= dma->buf_bytes)
+			continue;
+		return bytes_to_frames(runtime, curptr);
 	}
-	spin_unlock(&chip->reg_lock);
-	return bytes_to_frames(runtime, curptr);
+	snd_printd("atiixp: invalid DMA pointer read 0x%x (buf=%x)\n",
+		   readl(chip->remap_addr + dma->ops->dt_cur), dma->buf_addr);
+	return 0;
 }
 
 /*
@@ -1336,7 +1331,11 @@
  * ac97 mixer section
  */
 
-static int __devinit snd_atiixp_mixer_new(atiixp_t *chip, int clock)
+static struct ac97_quirk ac97_quirks[] __devinitdata = {
+	{ } /* terminator */
+};
+
+static int __devinit snd_atiixp_mixer_new(atiixp_t *chip, int clock, const char *quirk_override)
 {
 	ac97_bus_t *pbus;
 	ac97_template_t ac97;
@@ -1383,7 +1382,7 @@
 		return -ENODEV;
 	}
 
-	/* snd_ac97_tune_hardware(chip->ac97, ac97_quirks); */
+	snd_ac97_tune_hardware(chip->ac97[0], ac97_quirks, quirk_override);
 
 	return 0;
 }
@@ -1409,7 +1408,6 @@
 
 	pci_set_power_state(chip->pci, 3);
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1429,7 +1427,6 @@
 		if (chip->ac97[i])
 			snd_ac97_resume(chip->ac97[i]);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1508,7 +1505,6 @@
 	}
 
 	spin_lock_init(&chip->reg_lock);
-	spin_lock_init(&chip->ac97_lock);
 	init_MUTEX(&chip->open_mutex);
 	chip->card = card;
 	chip->pci = pci;
@@ -1579,7 +1575,7 @@
 
 	chip->spdif_over_aclink = spdif_aclink[dev];
 
-	if ((err = snd_atiixp_mixer_new(chip, ac97_clock[dev])) < 0)
+	if ((err = snd_atiixp_mixer_new(chip, ac97_clock[dev], ac97_quirk[dev])) < 0)
 		goto __error;
 
 	if ((err = snd_atiixp_pcm_new(chip)) < 0)
diff -uNr a/sound/pci/atiixp_modem.c b/sound/pci/atiixp_modem.c
--- a/sound/pci/atiixp_modem.c	2004-12-24 22:35:39.000000000 +0100
+++ b/sound/pci/atiixp_modem.c	2005-01-14 22:28:12.022530728 +0100
@@ -247,7 +247,6 @@
 	ac97_t *ac97[NUM_ATI_CODECS];
 
 	spinlock_t reg_lock;
-	spinlock_t ac97_lock;
 
 	atiixp_dma_t dmas[NUM_ATI_DMAS];
 	struct ac97_pcm *pcms[NUM_ATI_PCMS];
@@ -457,20 +456,14 @@
 static unsigned short snd_atiixp_ac97_read(ac97_t *ac97, unsigned short reg)
 {
 	atiixp_t *chip = ac97->private_data;
-	unsigned short data;
-	spin_lock(&chip->ac97_lock);
-	data = snd_atiixp_codec_read(chip, ac97->num, reg);
-	spin_unlock(&chip->ac97_lock);
-	return data;
+	return snd_atiixp_codec_read(chip, ac97->num, reg);
     
 }
 
 static void snd_atiixp_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
 {
 	atiixp_t *chip = ac97->private_data;
-	spin_lock(&chip->ac97_lock);
 	snd_atiixp_codec_write(chip, ac97->num, reg, val);
-	spin_unlock(&chip->ac97_lock);
 }
 
 /*
@@ -1131,7 +1124,6 @@
 
 	pci_set_power_state(chip->pci, 3);
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1151,7 +1143,6 @@
 		if (chip->ac97[i])
 			snd_ac97_resume(chip->ac97[i]);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1230,7 +1221,6 @@
 	}
 
 	spin_lock_init(&chip->reg_lock);
-	spin_lock_init(&chip->ac97_lock);
 	init_MUTEX(&chip->open_mutex);
 	chip->card = card;
 	chip->pci = pci;
diff -uNr a/sound/pci/au88x0/au88x0.c b/sound/pci/au88x0/au88x0.c
--- a/sound/pci/au88x0/au88x0.c	2004-12-24 22:34:48.000000000 +0100
+++ b/sound/pci/au88x0/au88x0.c	2005-01-14 22:28:12.025530272 +0100
@@ -4,7 +4,7 @@
  *
  *   This driver is the result of the OpenVortex Project from Savannah
  * (savannah.nongnu.org/projects/openvortex). I would like to thank
- * the developers of OpenVortex, Jeff Muizelar and Kester Maddock, from
+ * the developers of OpenVortex, Jeff Muizelaar and Kester Maddock, from
  * whom i got plenty of help, and their codebase was invaluable.
  *   Thanks to the ALSA developers, they helped a lot working out
  * the ALSA part.
@@ -170,9 +170,8 @@
 	if ((err = pci_request_regions(pci, CARD_NAME_SHORT)) != 0)
 		goto regions_out;
 
-	chip->mmio =
-	    ioremap_nocache(pci_resource_start(pci, 0),
-			    pci_resource_len(pci, 0));
+	chip->mmio = ioremap_nocache(pci_resource_start(pci, 0),
+	                             pci_resource_len(pci, 0));
 	if (!chip->mmio) {
 		printk(KERN_ERR "MMIO area remap failed.\n");
 		err = -ENOMEM;
@@ -187,10 +186,9 @@
 		goto core_out;
 	}
 
-	if ((err =
-	     request_irq(pci->irq, vortex_interrupt,
-			 SA_INTERRUPT | SA_SHIRQ, CARD_NAME_SHORT,
-			 (void *)chip)) != 0) {
+	if ((err = request_irq(pci->irq, vortex_interrupt,
+	                       SA_INTERRUPT | SA_SHIRQ, CARD_NAME_SHORT,
+	                       chip)) != 0) {
 		printk(KERN_ERR "cannot grab irq\n");
 		goto irq_out;
 	}
@@ -214,7 +212,6 @@
       irq_out:
 	vortex_core_shutdown(chip);
       core_out:
-	//FIXME: the type of chip->mmio might need to be changed??
 	iounmap(chip->mmio);
       ioremap_out:
 	pci_release_regions(chip->pci_dev);
diff -uNr a/sound/pci/au88x0/au88x0_core.c b/sound/pci/au88x0/au88x0_core.c
--- a/sound/pci/au88x0/au88x0_core.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/pci/au88x0/au88x0_core.c	2005-01-14 22:28:12.034528904 +0100
@@ -21,7 +21,7 @@
  These functions are mainly the result of translations made
  from the original disassembly of the au88x0 binary drivers,
  written by Aureal before they went down.
- Many thanks to the Jeff Muizelar, Kester Maddock, and whoever
+ Many thanks to the Jeff Muizelaar, Kester Maddock, and whoever
  contributed to the OpenVortex project.
  The author of this file, put the few available pieces together
  and translated the rest of the riddle (Mix, Src and connection stuff).
@@ -1223,6 +1223,33 @@
 	return delta;
 }
 
+
+static void vortex_adbdma_resetup(vortex_t *vortex, int adbdma) {
+	stream_t *dma = &vortex->dma_adb[adbdma];
+	int p, pp, i;
+
+	/* refresh hw page table */
+	for (i=0 ; i < 4 && i < dma->nr_periods; i++) {
+		/* p: audio buffer page index */
+		p = dma->period_virt + i;
+		if (p >= dma->nr_periods)
+			p -= dma->nr_periods;
+		/* pp: hardware DMA page index. */
+		pp = dma->period_real + i;
+		if (dma->nr_periods < 4) {
+			if (pp >= dma->nr_periods)
+				pp -= dma->nr_periods;
+		}
+		else {
+			if (pp >= 4)
+				pp -= 4;
+		}
+		hwwrite(vortex->mmio, VORTEX_ADBDMA_BUFBASE+(((adbdma << 2)+pp) << 2), snd_sgbuf_get_addr(dma->sgbuf, dma->period_bytes * p));
+		/* Force write thru cache. */
+		hwread(vortex->mmio, VORTEX_ADBDMA_BUFBASE + (((adbdma << 2)+pp) << 2));
+	}
+}
+
 static int inline vortex_adbdma_getlinearpos(vortex_t * vortex, int adbdma)
 {
 	stream_t *dma = &vortex->dma_adb[adbdma];
@@ -2081,7 +2108,6 @@
 	    || ((dir == SNDRV_PCM_STREAM_CAPTURE) && (nr_ch > 2)))
 		return -EBUSY;
 
-	spin_lock(&vortex->lock);
 	if (dma >= 0) {
 		en = 0;
 		vortex_adb_checkinout(vortex,
@@ -2277,7 +2303,6 @@
 		}
 	}
 	vortex->dma_adb[dma].nr_ch = nr_ch;
-	spin_unlock(&vortex->lock);
 
 #if 0
 	/* AC97 Codec channel setup. FIXME: this has no effect on some cards !! */
@@ -2406,22 +2431,28 @@
 	}
 	if (source & IRQ_PCMOUT) {
 		/* ALSA period acknowledge. */
+		spin_lock(&vortex->lock);
 		for (i = 0; i < NR_ADB; i++) {
 			if (vortex->dma_adb[i].fifo_status == FIFO_START) {
 				if (vortex_adbdma_bufshift(vortex, i)) ;
+				spin_unlock(&vortex->lock);
 				snd_pcm_period_elapsed(vortex->dma_adb[i].
 						       substream);
+				spin_lock(&vortex->lock);
 			}
 		}
 #ifndef CHIP_AU8810
 		for (i = 0; i < NR_WT; i++) {
 			if (vortex->dma_wt[i].fifo_status == FIFO_START) {
 				if (vortex_wtdma_bufshift(vortex, i)) ;
+				spin_unlock(&vortex->lock);
 				snd_pcm_period_elapsed(vortex->dma_wt[i].
 						       substream);
+				spin_lock(&vortex->lock);
 			}
 		}
 #endif
+		spin_unlock(&vortex->lock);
 		handled = 1;
 	}
 	//Acknowledge the Timer interrupt
@@ -2450,32 +2481,32 @@
 
 	for (i = 0; i < 32; i++) {
 		hwwrite(vortex->mmio, (VORTEX_CODEC_CHN + (i << 2)), 0);
-		udelay(2000);
+		msleep(2);
 	}
 	if (0) {
 		hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x8068);
-		udelay(1000);
+		msleep(1);
 		hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00e8);
-		udelay(1000);
+		msleep(1);
 	} else {
 		hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00a8);
-		udelay(2000);
+		msleep(2);
 		hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80a8);
-		udelay(2000);
+		msleep(2);
 		hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80e8);
-		udelay(2000);
+		msleep(2);
 		hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80a8);
-		udelay(2000);
+		msleep(2);
 		hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00a8);
-		udelay(2000);
+		msleep(2);
 		hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00e8);
 	}
 	for (i = 0; i < 32; i++) {
 		hwwrite(vortex->mmio, (VORTEX_CODEC_CHN + (i << 2)), 0);
-		udelay(5000);
+		msleep(5);
 	}
 	hwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0xe8);
-	udelay(1000);
+	msleep(1);
 	/* Enable codec channels 0 and 1. */
 	hwwrite(vortex->mmio, VORTEX_CODEC_EN,
 		hwread(vortex->mmio, VORTEX_CODEC_EN) | EN_CODEC);
@@ -2486,16 +2517,13 @@
 {
 
 	vortex_t *card = (vortex_t *) codec->private_data;
-	unsigned long flags;
 	unsigned int lifeboat = 0;
-	spin_lock_irqsave(&card->lock, flags);
 
 	/* wait for transactions to clear */
 	while (!(hwread(card->mmio, VORTEX_CODEC_CTRL) & 0x100)) {
 		udelay(100);
 		if (lifeboat++ > POLL_COUNT) {
 			printk(KERN_ERR "vortex: ac97 codec stuck busy\n");
-			spin_unlock_irqrestore(&card->lock, flags);
 			return;
 		}
 	}
@@ -2507,8 +2535,6 @@
 
 	/* Flush Caches. */
 	hwread(card->mmio, VORTEX_CODEC_IO);
-
-	spin_unlock_irqrestore(&card->lock, flags);
 }
 
 static unsigned short vortex_codec_read(ac97_t * codec, unsigned short addr)
@@ -2516,17 +2542,13 @@
 
 	vortex_t *card = (vortex_t *) codec->private_data;
 	u32 read_addr, data;
-	unsigned long flags;
 	unsigned lifeboat = 0;
 
-	spin_lock_irqsave(&card->lock, flags);
-
 	/* wait for transactions to clear */
 	while (!(hwread(card->mmio, VORTEX_CODEC_CTRL) & 0x100)) {
 		udelay(100);
 		if (lifeboat++ > POLL_COUNT) {
 			printk(KERN_ERR "vortex: ac97 codec stuck busy\n");
-			spin_unlock_irqrestore(&card->lock, flags);
 			return 0xffff;
 		}
 	}
@@ -2535,20 +2557,15 @@
 	hwwrite(card->mmio, VORTEX_CODEC_IO, read_addr);
 
 	/* wait for address */
-	{
+	do {
 		udelay(100);
 		data = hwread(card->mmio, VORTEX_CODEC_IO);
 		if (lifeboat++ > POLL_COUNT) {
 			printk(KERN_ERR "vortex: ac97 address never arrived\n");
-			spin_unlock_irqrestore(&card->lock, flags);
 			return 0xffff;
 		}
-	}
-	while ((data & VORTEX_CODEC_ADDMASK) !=
-	       (addr << VORTEX_CODEC_ADDSHIFT)) ;
-
-	/* Unlock. */
-	spin_unlock_irqrestore(&card->lock, flags);
+	} while ((data & VORTEX_CODEC_ADDMASK) !=
+		 (addr << VORTEX_CODEC_ADDSHIFT));
 
 	/* return data. */
 	return (u16) (data & VORTEX_CODEC_DATMASK);
@@ -2644,10 +2661,10 @@
 	printk(KERN_INFO "Vortex: init.... ");
 	/* Hardware Init. */
 	hwwrite(vortex->mmio, VORTEX_CTRL, 0xffffffff);
-	udelay(5000);
+	msleep(5);
 	hwwrite(vortex->mmio, VORTEX_CTRL,
 		hwread(vortex->mmio, VORTEX_CTRL) & 0xffdfffff);
-	udelay(5000);
+	msleep(5);
 	/* Reset IRQ flags */
 	hwwrite(vortex->mmio, VORTEX_IRQ_SOURCE, 0xffffffff);
 	hwread(vortex->mmio, VORTEX_IRQ_STAT);
@@ -2714,7 +2731,7 @@
 
 	hwwrite(vortex->mmio, VORTEX_IRQ_CTRL, 0);
 	hwwrite(vortex->mmio, VORTEX_CTRL, 0);
-	udelay(5000);
+	msleep(5);
 	hwwrite(vortex->mmio, VORTEX_IRQ_SOURCE, 0xffff);
 
 	printk(KERN_INFO "done.\n");
diff -uNr a/sound/pci/au88x0/au88x0_eq.c b/sound/pci/au88x0/au88x0_eq.c
--- a/sound/pci/au88x0/au88x0_eq.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/pci/au88x0/au88x0_eq.c	2005-01-14 22:28:12.038528296 +0100
@@ -45,6 +45,8 @@
 #define VORTEX_EQ_SOURCE (VORTEX_EQ_BASE + 0x430)
 #define VORTEX_EQ_CTRL   (VORTEX_EQ_BASE + 0x440)
 
+#define VORTEX_BAND_COEFF_SIZE 0x30
+
 /* CEqHw.s */
 static void vortex_EqHw_SetTimeConsts(vortex_t * vortex, u16 gain, u16 level)
 {
@@ -52,10 +54,10 @@
 	hwwrite(vortex->mmio, 0x2b3c8, level);
 }
 
-static inline short sign_invert(short a)
+static inline u16 sign_invert(u16 a)
 {
 	/* -(-32768) -> -32768 so we do -(-32768) -> 32767 to make the result positive */
-	if (a == -32768)
+	if (a == (u16)-32768)
 		return 32767;
 	else
 		return -a;
@@ -71,13 +73,13 @@
 		hwwrite(vortex->mmio, 0x2b004 + n * 0x30, coefs[i + 1]);
 
 		if (eqhw->this08 == 0) {
-			hwwrite(vortex->mmio, 0x2b008 + n * 0x30, coefs[i + 2] & 0xffff);
-			hwwrite(vortex->mmio, 0x2b00c + n * 0x30, coefs[i + 3] & 0xffff);
-			hwwrite(vortex->mmio, 0x2b010 + n * 0x30, coefs[i + 4] & 0xffff);
+			hwwrite(vortex->mmio, 0x2b008 + n * 0x30, coefs[i + 2]);
+			hwwrite(vortex->mmio, 0x2b00c + n * 0x30, coefs[i + 3]);
+			hwwrite(vortex->mmio, 0x2b010 + n * 0x30, coefs[i + 4]);
 		} else {
-			hwwrite(vortex->mmio, 0x2b008 + n * 0x30, sign_invert(coefs[2 + i]) & 0xffff);
-			hwwrite(vortex->mmio, 0x2b00c + n * 0x30, sign_invert(coefs[3 + i]) & 0xffff);
-		        hwwrite(vortex->mmio, 0x2b010 + n * 0x30, sign_invert(coefs[4 + i]) & 0xffff);
+			hwwrite(vortex->mmio, 0x2b008 + n * 0x30, sign_invert(coefs[2 + i]));
+			hwwrite(vortex->mmio, 0x2b00c + n * 0x30, sign_invert(coefs[3 + i]));
+		        hwwrite(vortex->mmio, 0x2b010 + n * 0x30, sign_invert(coefs[4 + i]));
 		}
 		i += 5;
 	}
@@ -93,13 +95,13 @@
 		hwwrite(vortex->mmio, 0x2b1e4 + n * 0x30, coefs[1 + i]);
 
 		if (eqhw->this08 == 0) {
-			hwwrite(vortex->mmio, 0x2b1e8 + n * 0x30, coefs[2 + i] & 0xffff);
-			hwwrite(vortex->mmio, 0x2b1ec + n * 0x30, coefs[3 + i] & 0xffff);
-			hwwrite(vortex->mmio, 0x2b1f0 + n * 0x30, coefs[4 + i] & 0xffff);
+			hwwrite(vortex->mmio, 0x2b1e8 + n * 0x30, coefs[2 + i]);
+			hwwrite(vortex->mmio, 0x2b1ec + n * 0x30, coefs[3 + i]);
+			hwwrite(vortex->mmio, 0x2b1f0 + n * 0x30, coefs[4 + i]);
 		} else {
-			hwwrite(vortex->mmio, 0x2b1e8 + n * 0x30, sign_invert(coefs[2 + i]) & 0xffff);
-			hwwrite(vortex->mmio, 0x2b1ec + n * 0x30, sign_invert(coefs[3 + i]) & 0xffff);
-			hwwrite(vortex->mmio, 0x2b1f0 + n * 0x30, sign_invert(coefs[4 + i]) & 0xffff);
+			hwwrite(vortex->mmio, 0x2b1e8 + n * 0x30, sign_invert(coefs[2 + i]));
+			hwwrite(vortex->mmio, 0x2b1ec + n * 0x30, sign_invert(coefs[3 + i]));
+			hwwrite(vortex->mmio, 0x2b1f0 + n * 0x30, sign_invert(coefs[4 + i]));
 		}
 		i += 5;
 	}
@@ -176,8 +178,8 @@
 		hwwrite(vortex->mmio, 0x2b3d4, a);
 		hwwrite(vortex->mmio, 0x2b3ec, b);
 	} else {
-		hwwrite(vortex->mmio, 0x2b3d4, sign_invert(a) & 0xffff);
-		hwwrite(vortex->mmio, 0x2b3ec, sign_invert(b) & 0xffff);
+		hwwrite(vortex->mmio, 0x2b3d4, sign_invert(a));
+		hwwrite(vortex->mmio, 0x2b3ec, sign_invert(b));
 	}
 }
 
@@ -319,25 +321,27 @@
 
 #endif
 /* EQ band levels settings */
-static void vortex_EqHw_SetLevels(vortex_t * vortex, u16 a[])
+static void vortex_EqHw_SetLevels(vortex_t * vortex, u16 peaks[])
 {
 	eqhw_t *eqhw = &(vortex->eq.this04);
-	int ebx;
+	int i;
 
-	for (ebx = 0; ebx < eqhw->this04; ebx++) {
-		hwwrite(vortex->mmio, 0x2b024 + ebx * 0x30, a[ebx]);
+	/* set left peaks */
+	for (i = 0; i < eqhw->this04; i++) {
+		hwwrite(vortex->mmio, 0x2b024 + i * VORTEX_BAND_COEFF_SIZE, peaks[i]);
 	}
 
-	hwwrite(vortex->mmio, 0x2b3cc, a[eqhw->this04]);
-	hwwrite(vortex->mmio, 0x2b3d8, a[eqhw->this04 + 1]);
+	hwwrite(vortex->mmio, 0x2b3cc, peaks[eqhw->this04]);
+	hwwrite(vortex->mmio, 0x2b3d8, peaks[eqhw->this04 + 1]);
 
-	for (ebx = 0; ebx < eqhw->this04; ebx++) {
-		hwwrite(vortex->mmio, 0x2b204 + ebx * 0x30,
-			a[ebx + (eqhw->this04 + 2)]);
+	/* set right peaks */
+	for (i = 0; i < eqhw->this04; i++) {
+		hwwrite(vortex->mmio, 0x2b204 + i * VORTEX_BAND_COEFF_SIZE,
+			peaks[i + (eqhw->this04 + 2)]);
 	}
 
-	hwwrite(vortex->mmio, 0x2b3e4, a[2 + (eqhw->this04 * 2)]);
-	hwwrite(vortex->mmio, 0x2b3f0, a[3 + (eqhw->this04 * 2)]);
+	hwwrite(vortex->mmio, 0x2b3e4, peaks[2 + (eqhw->this04 * 2)]);
+	hwwrite(vortex->mmio, 0x2b3f0, peaks[3 + (eqhw->this04 * 2)]);
 }
 
 #if 0
diff -uNr a/sound/pci/au88x0/au88x0.h b/sound/pci/au88x0/au88x0.h
--- a/sound/pci/au88x0/au88x0.h	2004-12-24 22:34:58.000000000 +0100
+++ b/sound/pci/au88x0/au88x0.h	2005-01-14 22:28:12.044527384 +0100
@@ -80,7 +80,8 @@
 #define VORTEX_RESOURCE_LAST	0x00000005
 
 /* Check for SDAC bit in "Extended audio ID" AC97 register */
-#define VORTEX_IS_QUAD(x) ((x->codec == NULL) ?  0 : (x->codec->ext_id&0x80))
+//#define VORTEX_IS_QUAD(x) (((x)->codec == NULL) ?  0 : ((x)->codec->ext_id&0x80))
+#define VORTEX_IS_QUAD(x) ((x)->isquad)
 /* Check if chip has bug. */
 #define IS_BAD_CHIP(x) (\
 	(x->rev == 0xfe && x->device == PCI_DEVICE_ID_AUREAL_VORTEX_2) || \
@@ -164,6 +165,8 @@
 	int xt_mode;		/* 1: speakers, 0:headphones. */
 #endif
 
+	int isquad;		/* cache of extended ID codec flag. */
+
 	/* Gameport stuff. */
 	struct gameport *gameport;
 
@@ -208,6 +211,7 @@
 static void vortex_adbdma_pausefifo(vortex_t * vortex, int adbdma);
 static void vortex_adbdma_resumefifo(vortex_t * vortex, int adbdma);
 static int inline vortex_adbdma_getlinearpos(vortex_t * vortex, int adbdma);
+static void vortex_adbdma_resetup(vortex_t *vortex, int adbdma);
 
 #ifndef CHIP_AU8810
 static void vortex_wtdma_startfifo(vortex_t * vortex, int wtdma);
diff -uNr a/sound/pci/au88x0/au88x0_mixer.c b/sound/pci/au88x0/au88x0_mixer.c
--- a/sound/pci/au88x0/au88x0_mixer.c	2004-12-24 22:34:26.000000000 +0100
+++ b/sound/pci/au88x0/au88x0_mixer.c	2005-01-14 22:28:12.047526928 +0100
@@ -26,5 +26,7 @@
 	memset(&ac97, 0, sizeof(ac97));
 	// Intialize AC97 codec stuff.
 	ac97.private_data = vortex;
-	return snd_ac97_mixer(pbus, &ac97, &vortex->codec);
+	err = snd_ac97_mixer(pbus, &ac97, &vortex->codec);
+	vortex->isquad = ((vortex->codec == NULL) ?  0 : (vortex->codec->ext_id&0x80));
+	return err;
 }
diff -uNr a/sound/pci/au88x0/au88x0_pcm.c b/sound/pci/au88x0/au88x0_pcm.c
--- a/sound/pci/au88x0/au88x0_pcm.c	2004-12-24 22:34:45.000000000 +0100
+++ b/sound/pci/au88x0/au88x0_pcm.c	2005-01-14 22:28:12.049526624 +0100
@@ -206,6 +206,7 @@
 	   printk(KERN_INFO "Vortex: periods %d, period_bytes %d, channels = %d\n", params_periods(hw_params),
 	   params_period_bytes(hw_params), params_channels(hw_params));
 	 */
+	spin_lock_irq(&chip->lock);
 	// Make audio routes and config buffer DMA.
 	if (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {
 		int dma, type = VORTEX_PCM_TYPE(substream->pcm);
@@ -243,6 +244,7 @@
 					params_periods(hw_params));
 	}
 #endif
+	spin_unlock_irq(&chip->lock);
 	return 0;
 }
 
@@ -252,6 +254,7 @@
 	vortex_t *chip = snd_pcm_substream_chip(substream);
 	stream_t *stream = (stream_t *) (substream->runtime->private_data);
 
+	spin_lock_irq(&chip->lock);
 	// Delete audio routes.
 	if (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {
 		if (stream != NULL)
@@ -266,6 +269,7 @@
 	}
 #endif
 	substream->runtime->private_data = NULL;
+	spin_unlock_irq(&chip->lock);
 
 	return snd_pcm_lib_free_pages(substream);
 }
@@ -284,6 +288,7 @@
 	else
 		dir = 0;
 	fmt = vortex_alsafmt_aspfmt(runtime->format);
+	spin_lock_irq(&chip->lock);
 	if (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {
 		vortex_adbdma_setmode(chip, dma, 1, dir, fmt, 0 /*? */ ,
 				      0);
@@ -298,6 +303,7 @@
 		vortex_wtdma_setstartbuffer(chip, dma, 0);
 	}
 #endif
+	spin_unlock_irq(&chip->lock);
 	return 0;
 }
 
@@ -308,13 +314,16 @@
 	stream_t *stream = (stream_t *) substream->runtime->private_data;
 	int dma = stream->dma;
 
+	spin_lock(&chip->lock);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		// do something to start the PCM engine
 		//printk(KERN_INFO "vortex: start %d\n", dma);
 		stream->fifo_enabled = 1;
-		if (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)
+		if (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {
+			vortex_adbdma_resetup(chip, dma);
 			vortex_adbdma_startfifo(chip, dma);
+		}
 #ifndef CHIP_AU8810
 		else {
 			printk(KERN_INFO "vortex: wt start %d\n", dma);
@@ -355,8 +364,10 @@
 #endif
 		break;
 	default:
+		spin_unlock(&chip->lock);
 		return -EINVAL;
 	}
+	spin_unlock(&chip->lock);
 	return 0;
 }
 
diff -uNr a/sound/pci/azt3328.c b/sound/pci/azt3328.c
--- a/sound/pci/azt3328.c	2004-12-24 22:34:58.000000000 +0100
+++ b/sound/pci/azt3328.c	2005-01-14 22:28:12.057525408 +0100
@@ -214,17 +214,17 @@
 
 MODULE_DEVICE_TABLE(pci, snd_azf3328_ids);
 
-void snd_azf3328_io2_write(azf3328_t *chip, int reg, unsigned char value)
+static inline void snd_azf3328_io2_write(azf3328_t *chip, int reg, unsigned char value)
 {
 	outb(value, chip->io2_port + reg);
 }
 
-unsigned char snd_azf3328_io2_read(azf3328_t *chip, int reg)
+static inline unsigned char snd_azf3328_io2_read(azf3328_t *chip, int reg)
 {
 	return inb(chip->io2_port + reg);
 }
 
-void snd_azf3328_mixer_write(azf3328_t *chip, int reg, unsigned long value, int type)
+static void snd_azf3328_mixer_write(azf3328_t *chip, int reg, unsigned long value, int type)
 {
 	switch(type) {
 	case WORD_VALUE:
@@ -239,26 +239,7 @@
 	}
 }
 
-unsigned long snd_azf3328_mixer_read(azf3328_t *chip, int reg, int type)
-{
-	unsigned long res = 0;
-
-	switch(type) {
-	case WORD_VALUE:
-		res = (unsigned long)inw(chip->mixer_port + reg);
-		break;
-	case DWORD_VALUE:
-		res = (unsigned long)inl(chip->mixer_port + reg);
-		break;
-	case BYTE_VALUE:
-		res = (unsigned long)inb(chip->mixer_port + reg);
-		break;
-	}
-
-	return res;
-}
-
-void snd_azf3328_mixer_set_mute(azf3328_t *chip, int reg, int do_mute)
+static void snd_azf3328_mixer_set_mute(azf3328_t *chip, int reg, int do_mute)
 {
 	unsigned char oldval;
 
@@ -272,7 +253,7 @@
 	outb(oldval, chip->mixer_port + reg + 1);
 }
 
-void snd_azf3328_mixer_write_volume_gradually(azf3328_t *chip, int reg, unsigned char dst_vol_left, unsigned char dst_vol_right, int chan_sel, int delay)
+static void snd_azf3328_mixer_write_volume_gradually(azf3328_t *chip, int reg, unsigned char dst_vol_left, unsigned char dst_vol_right, int chan_sel, int delay)
 {
 	unsigned char curr_vol_left = 0, curr_vol_right = 0;
 	int left_done = 0, right_done = 0;
@@ -1363,15 +1344,15 @@
 	for (tmp=0; tmp <= 0x01; tmp += 1)
 		snd_azf3328_dbgmisc("0x%02x: opl 0x%04x, mpu300 0x%04x, mpu310 0x%04x, mpu320 0x%04x, mpu330 0x%04x\n", tmp, inb(0x388 + tmp), inb(0x300 + tmp), inb(0x310 + tmp), inb(0x320 + tmp), inb(0x330 + tmp));
 
-	/* create mixer interface & switches */
-	if ((err = snd_azf3328_mixer_new(chip)) < 0)
-		return err;
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_azf3328_free(chip);
 		return err;
 	}
 
+	/* create mixer interface & switches */
+	if ((err = snd_azf3328_mixer_new(chip)) < 0)
+		return err;
+
 #if 0
 	/* set very low bitrate to reduce noise and power consumption? */
 	snd_azf3328_setfmt(chip, IDX_IO_PLAY_SOUNDFORMAT, 5512, 8, 1);
diff -uNr a/sound/pci/bt87x.c b/sound/pci/bt87x.c
--- a/sound/pci/bt87x.c	2004-12-24 22:34:58.000000000 +0100
+++ b/sound/pci/bt87x.c	2005-01-14 22:28:12.061524800 +0100
@@ -45,6 +45,7 @@
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int digital_rate[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 }; /* digital input rate */
+static int load_all;	/* allow to load the non-whitelisted cards */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for Bt87x soundcard");
@@ -54,6 +55,8 @@
 MODULE_PARM_DESC(enable, "Enable Bt87x soundcard");
 module_param_array(digital_rate, int, NULL, 0444);
 MODULE_PARM_DESC(digital_rate, "Digital input rate for Bt87x soundcard");
+module_param(load_all, bool, 0444);
+MODULE_PARM_DESC(load_all, "Allow to load the non-whitelisted cards");
 
 
 #ifndef PCI_VENDOR_ID_BROOKTREE
@@ -173,7 +176,11 @@
 	unsigned int lines;
 
 	u32 reg_control;
+	u32 interrupt_mask;
+
 	int current_line;
+
+	int pci_parity_errors;
 };
 
 enum { DEVICE_DIGITAL, DEVICE_ANALOG };
@@ -246,33 +253,53 @@
 	}
 }
 
+static void snd_bt87x_pci_error(bt87x_t *chip, unsigned int status)
+{
+	u16 pci_status;
+
+	pci_read_config_word(chip->pci, PCI_STATUS, &pci_status);
+	pci_status &= PCI_STATUS_PARITY | PCI_STATUS_SIG_TARGET_ABORT |
+		PCI_STATUS_REC_TARGET_ABORT | PCI_STATUS_REC_MASTER_ABORT |
+		PCI_STATUS_SIG_SYSTEM_ERROR | PCI_STATUS_DETECTED_PARITY;
+	pci_write_config_word(chip->pci, PCI_STATUS, pci_status);
+	if (pci_status != PCI_STATUS_DETECTED_PARITY)
+		snd_printk(KERN_ERR "Aieee - PCI error! status %#08x, PCI status %#04x\n",
+			   status & ERROR_INTERRUPTS, pci_status);
+	else {
+		snd_printk(KERN_ERR "Aieee - PCI parity error detected!\n");
+		/* error 'handling' similar to aic7xxx_pci.c: */
+		chip->pci_parity_errors++;
+		if (chip->pci_parity_errors > 20) {
+			snd_printk(KERN_ERR "Too many PCI parity errors observed.\n");
+			snd_printk(KERN_ERR "Some device on this bus is generating bad parity.\n");
+			snd_printk(KERN_ERR "This is an error *observed by*, not *generated by*, this card.\n");
+			snd_printk(KERN_ERR "PCI parity error checking has been disabled.\n");
+			chip->interrupt_mask &= ~(INT_PPERR | INT_RIPERR);
+			snd_bt87x_writel(chip, REG_INT_MASK, chip->interrupt_mask);
+		}
+	}
+}
+
 static irqreturn_t snd_bt87x_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	bt87x_t *chip = dev_id;
-	unsigned int status;
+	unsigned int status, irq_status;
 
 	status = snd_bt87x_readl(chip, REG_INT_STAT);
-	if (!(status & MY_INTERRUPTS))
+	irq_status = status & chip->interrupt_mask;
+	if (!irq_status)
 		return IRQ_NONE;
-	snd_bt87x_writel(chip, REG_INT_STAT, status & MY_INTERRUPTS);
+	snd_bt87x_writel(chip, REG_INT_STAT, irq_status);
 
-	if (status & ERROR_INTERRUPTS) {
-		if (status & (INT_FBUS | INT_FTRGT))
+	if (irq_status & ERROR_INTERRUPTS) {
+		if (irq_status & (INT_FBUS | INT_FTRGT))
 			snd_printk(KERN_WARNING "FIFO overrun, status %#08x\n", status);
-		if (status & INT_OCERR)
+		if (irq_status & INT_OCERR)
 			snd_printk(KERN_ERR "internal RISC error, status %#08x\n", status);
-		if (status & (INT_PPERR | INT_RIPERR | INT_PABORT)) {
-			u16 pci_status;
-			pci_read_config_word(chip->pci, PCI_STATUS, &pci_status);
-			pci_write_config_word(chip->pci, PCI_STATUS, pci_status &
-					      (PCI_STATUS_PARITY | PCI_STATUS_SIG_TARGET_ABORT |
-					       PCI_STATUS_REC_TARGET_ABORT | PCI_STATUS_REC_MASTER_ABORT |
-					       PCI_STATUS_SIG_SYSTEM_ERROR | PCI_STATUS_DETECTED_PARITY));
-			snd_printk(KERN_ERR "Aieee - PCI error! status %#08x, PCI status %#04x\n",
-				   status, pci_status);
-		}
+		if (irq_status & (INT_PPERR | INT_RIPERR | INT_PABORT))
+			snd_bt87x_pci_error(chip, irq_status);
 	}
-	if ((status & INT_RISCI) && (chip->reg_control & CTL_ACAP_EN)) {
+	if ((irq_status & INT_RISCI) && (chip->reg_control & CTL_ACAP_EN)) {
 		int current_block, irq_block;
 
 		/* assume that exactly one line has been recorded */
@@ -458,7 +485,7 @@
 	snd_bt87x_writel(chip, REG_RISC_STRT_ADD, chip->dma_risc.addr);
 	snd_bt87x_writel(chip, REG_PACKET_LEN,
 			 chip->line_bytes | (chip->lines << 16));
-	snd_bt87x_writel(chip, REG_INT_MASK, MY_INTERRUPTS);
+	snd_bt87x_writel(chip, REG_INT_MASK, chip->interrupt_mask);
 	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
 	spin_unlock(&chip->reg_lock);
 	return 0;
@@ -717,6 +744,7 @@
 	}
 
 	chip->reg_control = CTL_DA_ES2 | CTL_PKTP_16 | (15 << CTL_DA_SDR_SHIFT);
+	chip->interrupt_mask = MY_INTERRUPTS;
 	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
 	snd_bt87x_writel(chip, REG_INT_MASK, 0);
 	snd_bt87x_writel(chip, REG_INT_STAT, MY_INTERRUPTS);
@@ -741,13 +769,73 @@
 	return 0;
 }
 
+#define BT_DEVICE(chip, subvend, subdev, rate) \
+	{ .vendor = PCI_VENDOR_ID_BROOKTREE, \
+	  .device = PCI_DEVICE_ID_BROOKTREE_##chip, \
+	  .subvendor = subvend, .subdevice = subdev, \
+	  .driver_data = rate }
+
+/* driver_data is the default digital_rate value for that device */
+static struct pci_device_id snd_bt87x_ids[] = {
+	BT_DEVICE(878, 0x0070, 0x13eb, 32000), /* Hauppauge WinTV series */
+	BT_DEVICE(879, 0x0070, 0x13eb, 32000), /* Hauppauge WinTV series */
+	BT_DEVICE(878, 0x0070, 0xff01, 44100), /* Viewcast Osprey 200 */
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, snd_bt87x_ids);
+
+/* cards known not to have audio
+ * (DVB cards use the audio function to transfer MPEG data) */
+static struct {
+	unsigned short subvendor, subdevice;
+} blacklist[] __devinitdata = {
+	{0x0071, 0x0101}, /* Nebula Electronics DigiTV */
+	{0x11bd, 0x0026}, /* Pinnacle PCTV SAT CI */
+	{0x1461, 0x0761}, /* AVermedia AverTV DVB-T */
+	{0x1461, 0x0771}, /* AVermedia DVB-T 771 */
+	{0x1822, 0x0001}, /* Twinhan VisionPlus DVB-T */
+	{0x18ac, 0xdb10}, /* DVICO FusionHDTV DVB-T Lite */
+	{0x270f, 0xfc00}, /* Chaintech Digitop DST-1000 DVB-S */
+};
+
+/* return the rate of the card, or a negative value if it's blacklisted */
+static int __devinit snd_bt87x_detect_card(struct pci_dev *pci)
+{
+	int i;
+	const struct pci_device_id *supported;
+
+	supported = pci_match_device(snd_bt87x_ids, pci);
+	if (supported)
+		return supported->driver_data;
+
+	for (i = 0; i < ARRAY_SIZE(blacklist); ++i)
+		if (blacklist[i].subvendor == pci->subsystem_vendor &&
+		    blacklist[i].subdevice == pci->subsystem_device) {
+			snd_printdd(KERN_INFO "card %#04x:%#04x has no audio\n",
+				    pci->subsystem_vendor, pci->subsystem_device);
+			return -EBUSY;
+		}
+
+	snd_printk(KERN_INFO "unknown card %#04x:%#04x, using default rate 32000\n",
+		   pci->subsystem_vendor, pci->subsystem_device);
+	snd_printk(KERN_DEBUG "please mail id, board name, and, "
+		   "if it works, the correct digital_rate option to "
+		   "<alsa-devel@lists.sf.net>\n");
+	return 32000; /* default rate */
+}
+
 static int __devinit snd_bt87x_probe(struct pci_dev *pci,
 				     const struct pci_device_id *pci_id)
 {
 	static int dev;
 	snd_card_t *card;
 	bt87x_t *chip;
-	int err;
+	int err, rate;
+
+	rate = pci_id->driver_data;
+	if (! rate)
+		if ((rate = snd_bt87x_detect_card(pci)) <= 0)
+			return -ENODEV;
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
@@ -767,7 +855,7 @@
 	if (digital_rate[dev] > 0)
 		chip->dig_rate = digital_rate[dev];
 	else
-		chip->dig_rate = (int)pci_id->driver_data;
+		chip->dig_rate = rate;
 
 	err = snd_bt87x_pcm(chip, DEVICE_DIGITAL, "Bt87x Digital");
 	if (err < 0)
@@ -811,22 +899,13 @@
 	pci_set_drvdata(pci, NULL);
 }
 
-#define BT_DEVICE(chip, subvend, subdev, rate) \
-	{ .vendor = PCI_VENDOR_ID_BROOKTREE, \
-	  .device = PCI_DEVICE_ID_BROOKTREE_##chip, \
-	  .subvendor = subvend, .subdevice = subdev, \
-	  .driver_data = rate }
-
-/* driver_data is the default digital_rate value for that device */
-static struct pci_device_id snd_bt87x_ids[] = {
-	BT_DEVICE(878, 0x0070, 0xff01, 44100), /* Osprey 200 */
-
-	/* default entries for 32kHz and generic Bt87x cards */
-	BT_DEVICE(878, PCI_ANY_ID, PCI_ANY_ID, 32000),
-	BT_DEVICE(879, PCI_ANY_ID, PCI_ANY_ID, 32000),
+/* default entries for all Bt87x cards - it's not exported */
+/* driver_data is set to 0 to call detection */
+static struct pci_device_id snd_bt87x_default_ids[] = {
+	BT_DEVICE(878, PCI_ANY_ID, PCI_ANY_ID, 0),
+	BT_DEVICE(879, PCI_ANY_ID, PCI_ANY_ID, 0),
 	{ }
 };
-MODULE_DEVICE_TABLE(pci, snd_bt87x_ids);
 
 static struct pci_driver driver = {
 	.name = "Bt87x",
@@ -837,6 +916,8 @@
 
 static int __init alsa_card_bt87x_init(void)
 {
+	if (load_all)
+		driver.id_table = snd_bt87x_default_ids;
 	return pci_module_init(&driver);
 }
 
diff -uNr a/sound/pci/ca0106/ca0106.h b/sound/pci/ca0106/ca0106.h
--- a/sound/pci/ca0106/ca0106.h	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/pci/ca0106/ca0106.h	2005-01-14 22:28:12.070523432 +0100
@@ -0,0 +1,549 @@
+/*
+ *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
+ *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
+ *  Version: 0.0.20
+ *
+ *  FEATURES currently supported:
+ *    See ca0106_main.c for features.
+ * 
+ *  Changelog:
+ *    Support interrupts per period.
+ *    Removed noise from Center/LFE channel when in Analog mode.
+ *    Rename and remove mixer controls.
+ *  0.0.6
+ *    Use separate card based DMA buffer for periods table list.
+ *  0.0.7
+ *    Change remove and rename ctrls into lists.
+ *  0.0.8
+ *    Try to fix capture sources.
+ *  0.0.9
+ *    Fix AC3 output.
+ *    Enable S32_LE format support.
+ *  0.0.10
+ *    Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)
+ *  0.0.11
+ *    Add Model name recognition.
+ *  0.0.12
+ *    Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.
+ *    Remove redundent "voice" handling.
+ *  0.0.13
+ *    Single trigger call for multi channels.
+ *  0.0.14
+ *    Set limits based on what the sound card hardware can do.
+ *    playback periods_min=2, periods_max=8
+ *    capture hw constraints require period_size = n * 64 bytes.
+ *    playback hw constraints require period_size = n * 64 bytes.
+ *  0.0.15
+ *    Separated ca0106.c into separate functional .c files.
+ *  0.0.16
+ *    Implement 192000 sample rate.
+ *  0.0.17
+ *    Add support for SB0410 and SB0413.
+ *  0.0.18
+ *    Modified Copyright message.
+ *  0.0.19
+ *    Added I2C and SPI registers. Filled in interrupt enable.
+ *  0.0.20
+ *    Added GPIO info for SB Live 24bit.
+ *
+ *
+ *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/************************************************************************************************/
+/* PCI function 0 registers, address = <val> + PCIBASE0						*/
+/************************************************************************************************/
+
+#define PTR			0x00		/* Indexed register set pointer register	*/
+						/* NOTE: The CHANNELNUM and ADDRESS words can	*/
+						/* be modified independently of each other.	*/
+						/* CNL[1:0], ADDR[27:16]                        */
+
+#define DATA			0x04		/* Indexed register set data register		*/
+						/* DATA[31:0]					*/
+
+#define IPR			0x08		/* Global interrupt pending register		*/
+						/* Clear pending interrupts by writing a 1 to	*/
+						/* the relevant bits and zero to the other bits	*/
+#define IPR_MIDI_RX_B		0x00020000	/* MIDI UART-B Receive buffer non-empty		*/
+#define IPR_MIDI_TX_B		0x00010000	/* MIDI UART-B Transmit buffer empty		*/
+#define IPR_SPDIF_IN_USER	0x00004000      /* SPDIF input user data has 16 more bits	*/
+#define IPR_SPDIF_OUT_USER	0x00002000      /* SPDIF output user data needs 16 more bits	*/
+#define IPR_SPDIF_OUT_FRAME	0x00001000      /* SPDIF frame about to start			*/
+#define IPR_SPI			0x00000800      /* SPI transaction completed			*/
+#define IPR_I2C_EEPROM		0x00000400      /* I2C EEPROM transaction completed		*/
+#define IPR_I2C_DAC		0x00000200      /* I2C DAC transaction completed		*/
+#define IPR_AI			0x00000100      /* Audio pending register changed. See PTR reg 0x76	*/
+#define IPR_GPI			0x00000080      /* General Purpose input changed		*/
+#define IPR_SRC_LOCKED          0x00000040      /* SRC lock status changed			*/
+#define IPR_SPDIF_STATUS        0x00000020      /* SPDIF status changed				*/
+#define IPR_TIMER2              0x00000010      /* 192000Hz Timer				*/
+#define IPR_TIMER1              0x00000008      /* 44100Hz Timer				*/
+#define IPR_MIDI_RX_A		0x00000004	/* MIDI UART-A Receive buffer non-empty		*/
+#define IPR_MIDI_TX_A		0x00000002	/* MIDI UART-A Transmit buffer empty		*/
+#define IPR_PCI			0x00000001	/* PCI Bus error				*/
+
+#define INTE			0x0c		/* Interrupt enable register			*/
+
+#define INTE_MIDI_RX_B		0x00020000	/* MIDI UART-B Receive buffer non-empty		*/
+#define INTE_MIDI_TX_B		0x00010000	/* MIDI UART-B Transmit buffer empty		*/
+#define INTE_SPDIF_IN_USER	0x00004000      /* SPDIF input user data has 16 more bits	*/
+#define INTE_SPDIF_OUT_USER	0x00002000      /* SPDIF output user data needs 16 more bits	*/
+#define INTE_SPDIF_OUT_FRAME	0x00001000      /* SPDIF frame about to start			*/
+#define INTE_SPI		0x00000800      /* SPI transaction completed			*/
+#define INTE_I2C_EEPROM		0x00000400      /* I2C EEPROM transaction completed		*/
+#define INTE_I2C_DAC		0x00000200      /* I2C DAC transaction completed		*/
+#define INTE_AI			0x00000100      /* Audio pending register changed. See PTR reg 0x75 */
+#define INTE_GPI		0x00000080      /* General Purpose input changed		*/
+#define INTE_SRC_LOCKED         0x00000040      /* SRC lock status changed			*/
+#define INTE_SPDIF_STATUS       0x00000020      /* SPDIF status changed				*/
+#define INTE_TIMER2             0x00000010      /* 192000Hz Timer				*/
+#define INTE_TIMER1             0x00000008      /* 44100Hz Timer				*/
+#define INTE_MIDI_RX_A		0x00000004	/* MIDI UART-A Receive buffer non-empty		*/
+#define INTE_MIDI_TX_A		0x00000002	/* MIDI UART-A Transmit buffer empty		*/
+#define INTE_PCI		0x00000001	/* PCI Bus error				*/
+
+#define UNKNOWN10		0x10		/* Unknown ??. Defaults to 0 */
+#define HCFG			0x14		/* Hardware config register			*/
+						/* 0x1000 causes AC3 to fails. It adds a dither bit. */
+
+#define HCFG_STAC		0x10000000	/* Special mode for STAC9460 Codec. */
+#define HCFG_CAPTURE_I2S_BYPASS	0x08000000	/* 1 = bypass I2S input async SRC. */
+#define HCFG_CAPTURE_SPDIF_BYPASS 0x04000000	/* 1 = bypass SPDIF input async SRC. */
+#define HCFG_PLAYBACK_I2S_BYPASS 0x02000000	/* 0 = I2S IN mixer output, 1 = I2S IN1. */
+#define HCFG_FORCE_LOCK		0x01000000	/* For test only. Force input SRC tracker to lock. */
+#define HCFG_PLAYBACK_ATTENUATION 0x00006000	/* Playback attenuation mask. 0 = 0dB, 1 = 6dB, 2 = 12dB, 3 = Mute. */
+#define HCFG_PLAYBACK_DITHER	0x00001000	/* 1 = Add dither bit to all playback channels. */
+#define HCFG_PLAYBACK_S32_LE	0x00000800	/* 1 = S32_LE, 0 = S16_LE                       */
+#define HCFG_CAPTURE_S32_LE	0x00000400	/* 1 = S32_LE, 0 = S16_LE (S32_LE current not working)	*/
+#define HCFG_8_CHANNEL_PLAY	0x00000200	/* 1 = 8 channels, 0 = 2 channels per substream.*/
+#define HCFG_8_CHANNEL_CAPTURE	0x00000100	/* 1 = 8 channels, 0 = 2 channels per substream.*/
+#define HCFG_MONO		0x00000080	/* 1 = I2S Input mono                           */
+#define HCFG_I2S_OUTPUT		0x00000010	/* 1 = I2S Output disabled                      */
+#define HCFG_AC97		0x00000008	/* 0 = AC97 1.0, 1 = AC97 2.0                   */
+#define HCFG_LOCK_PLAYBACK_CACHE 0x00000004	/* 1 = Cancel bustmaster accesses to soundcache */
+						/* NOTE: This should generally never be used.  	*/
+#define HCFG_LOCK_CAPTURE_CACHE	0x00000002	/* 1 = Cancel bustmaster accesses to soundcache */
+						/* NOTE: This should generally never be used.  	*/
+#define HCFG_AUDIOENABLE	0x00000001	/* 0 = CODECs transmit zero-valued samples	*/
+						/* Should be set to 1 when the EMU10K1 is	*/
+						/* completely initialized.			*/
+#define GPIO			0x18		/* Defaults: 005f03a3-Analog, 005f02a2-SPDIF.   */
+						/* Here pins 0,1,2,3,4,,6 are output. 5,7 are input */
+						/* For the Audigy LS, pin 0 (or bit 8) controls the SPDIF/Analog jack. */
+						/* SB Live 24bit:
+						 * bit 8 0 = SPDIF in and out / 1 = Analog (Mic or Line)-in.
+						 * bit 9 0 = Mute / 1 = Analog out.
+						 * bit 10 0 = Line-in / 1 = Mic-in.
+						 * bit 11 0 = ? / 1 = ?
+						 * bit 12 0 = ? / 1 = ?
+						 * bit 13 0 = ? / 1 = ?
+						 * bit 14 0 = Mute / 1 = Analog out
+						 * bit 15 0 = ? / 1 = ?
+						 * Both bit 9 and bit 14 have to be set for analog sound to work on the SB Live 24bit.
+						 */
+						/* 8 general purpose programmable In/Out pins.
+						 * GPI [8:0] Read only. Default 0.
+						 * GPO [15:8] Default 0x9. (Default to SPDIF jack enabled for SPDIF)
+						 * GPO Enable [23:16] Default 0x0f. Setting a bit to 1, causes the pin to be an output pin.
+						 */
+#define AC97DATA		0x1c		/* AC97 register set data register (16 bit)	*/
+
+#define AC97ADDRESS		0x1e		/* AC97 register set address register (8 bit)	*/
+
+/********************************************************************************************************/
+/* CA0106 pointer-offset register set, accessed through the PTR and DATA registers                     */
+/********************************************************************************************************/
+                                                                                                                           
+/* Initally all registers from 0x00 to 0x3f have zero contents. */
+#define PLAYBACK_LIST_ADDR	0x00		/* Base DMA address of a list of pointers to each period/size */
+						/* One list entry: 4 bytes for DMA address, 
+						 * 4 bytes for period_size << 16.
+						 * One list entry is 8 bytes long.
+						 * One list entry for each period in the buffer.
+						 */
+						/* ADDR[31:0], Default: 0x0 */
+#define PLAYBACK_LIST_SIZE	0x01		/* Size of list in bytes << 16. E.g. 8 periods -> 0x00380000  */
+						/* SIZE[21:16], Default: 0x8 */
+#define PLAYBACK_LIST_PTR	0x02		/* Pointer to the current period being played */
+						/* PTR[5:0], Default: 0x0 */
+#define PLAYBACK_UNKNOWN3	0x03		/* Not used ?? */
+#define PLAYBACK_DMA_ADDR	0x04		/* Playback DMA addresss */
+						/* DMA[31:0], Default: 0x0 */
+#define PLAYBACK_PERIOD_SIZE	0x05		/* Playback period size. win2000 uses 0x04000000 */
+						/* SIZE[31:16], Default: 0x0 */
+#define PLAYBACK_POINTER	0x06		/* Playback period pointer. Used with PLAYBACK_LIST_PTR to determine buffer position currently in DAC */
+						/* POINTER[15:0], Default: 0x0 */
+#define PLAYBACK_PERIOD_END_ADDR 0x07		/* Playback fifo end address */
+						/* END_ADDR[15:0], FLAG[16] 0 = don't stop, 1 = stop */
+#define PLAYBACK_FIFO_OFFSET_ADDRESS	0x08	/* Current fifo offset address [21:16] */
+						/* Cache size valid [5:0] */
+#define PLAYBACK_UNKNOWN9	0x09		/* 0x9 to 0xf Unused */
+#define CAPTURE_DMA_ADDR	0x10		/* Capture DMA address */
+						/* DMA[31:0], Default: 0x0 */
+#define CAPTURE_BUFFER_SIZE	0x11		/* Capture buffer size */
+						/* SIZE[31:16], Default: 0x0 */
+#define CAPTURE_POINTER		0x12		/* Capture buffer pointer. Sample currently in ADC */
+						/* POINTER[15:0], Default: 0x0 */
+#define CAPTURE_FIFO_OFFSET_ADDRESS	0x13	/* Current fifo offset address [21:16] */
+						/* Cache size valid [5:0] */
+#define PLAYBACK_LAST_SAMPLE    0x20		/* The sample currently being played */
+/* 0x21 - 0x3f unused */
+#define BASIC_INTERRUPT         0x40		/* Used by both playback and capture interrupt handler */
+						/* Playback (0x1<<channel_id) */
+						/* Capture  (0x100<<channel_id) */
+						/* Playback sample rate 96000 = 0x20000 */
+						/* Start Playback [3:0] (one bit per channel)
+						 * Start Capture [11:8] (one bit per channel)
+						 * Playback rate [23:16] (2 bits per channel) (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)
+						 * Playback mixer in enable [27:24] (one bit per channel)
+						 * Playback mixer out enable [31:28] (one bit per channel)
+						 */
+/* The Digital out jack is shared with the Center/LFE Analogue output. 
+ * The jack has 4 poles. I will call 1 - Tip, 2 - Next to 1, 3 - Next to 2, 4 - Next to 3
+ * For Analogue: 1 -> Center Speaker, 2 -> Sub Woofer, 3 -> Ground, 4 -> Ground
+ * For Digital: 1 -> Front SPDIF, 2 -> Rear SPDIF, 3 -> Center/Subwoofer SPDIF, 4 -> Ground.
+ * Standard 4 pole Video A/V cable with RCA outputs: 1 -> White, 2 -> Yellow, 3 -> Sheild on all three, 4 -> Red.
+ * So, from this you can see that you cannot use a Standard 4 pole Video A/V cable with the SB Audigy LS card.
+ */
+/* The Front SPDIF PCM gets mixed with samples from the AC97 codec, so can only work for Stereo PCM and not AC3/DTS
+ * The Rear SPDIF can be used for Stereo PCM and also AC3/DTS
+ * The Center/LFE SPDIF cannot be used for AC3/DTS, but can be used for Stereo PCM.
+ * Summary: For ALSA we use the Rear channel for SPDIF Digital AC3/DTS output
+ */
+/* A standard 2 pole mono mini-jack to RCA plug can be used for SPDIF Stereo PCM output from the Front channel.
+ * A standard 3 pole stereo mini-jack to 2 RCA plugs can be used for SPDIF AC3/DTS and Stereo PCM output utilising the Rear channel and just one of the RCA plugs. 
+ */
+#define SPCS0			0x41		/* SPDIF output Channel Status 0 register. For Rear. default=0x02108004, non-audio=0x02108006	*/
+#define SPCS1			0x42		/* SPDIF output Channel Status 1 register. For Front */
+#define SPCS2			0x43		/* SPDIF output Channel Status 2 register. For Center/LFE */
+#define SPCS3			0x44		/* SPDIF output Channel Status 3 register. Unknown */
+						/* When Channel set to 0: */
+#define SPCS_CLKACCYMASK	0x30000000	/* Clock accuracy				*/
+#define SPCS_CLKACCY_1000PPM	0x00000000	/* 1000 parts per million			*/
+#define SPCS_CLKACCY_50PPM	0x10000000	/* 50 parts per million				*/
+#define SPCS_CLKACCY_VARIABLE	0x20000000	/* Variable accuracy				*/
+#define SPCS_SAMPLERATEMASK	0x0f000000	/* Sample rate					*/
+#define SPCS_SAMPLERATE_44	0x00000000	/* 44.1kHz sample rate				*/
+#define SPCS_SAMPLERATE_48	0x02000000	/* 48kHz sample rate				*/
+#define SPCS_SAMPLERATE_32	0x03000000	/* 32kHz sample rate				*/
+#define SPCS_CHANNELNUMMASK	0x00f00000	/* Channel number				*/
+#define SPCS_CHANNELNUM_UNSPEC	0x00000000	/* Unspecified channel number			*/
+#define SPCS_CHANNELNUM_LEFT	0x00100000	/* Left channel					*/
+#define SPCS_CHANNELNUM_RIGHT	0x00200000	/* Right channel				*/
+#define SPCS_SOURCENUMMASK	0x000f0000	/* Source number				*/
+#define SPCS_SOURCENUM_UNSPEC	0x00000000	/* Unspecified source number			*/
+#define SPCS_GENERATIONSTATUS	0x00008000	/* Originality flag (see IEC-958 spec)		*/
+#define SPCS_CATEGORYCODEMASK	0x00007f00	/* Category code (see IEC-958 spec)		*/
+#define SPCS_MODEMASK		0x000000c0	/* Mode (see IEC-958 spec)			*/
+#define SPCS_EMPHASISMASK	0x00000038	/* Emphasis					*/
+#define SPCS_EMPHASIS_NONE	0x00000000	/* No emphasis					*/
+#define SPCS_EMPHASIS_50_15	0x00000008	/* 50/15 usec 2 channel				*/
+#define SPCS_COPYRIGHT		0x00000004	/* Copyright asserted flag -- do not modify	*/
+#define SPCS_NOTAUDIODATA	0x00000002	/* 0 = Digital audio, 1 = not audio		*/
+#define SPCS_PROFESSIONAL	0x00000001	/* 0 = Consumer (IEC-958), 1 = pro (AES3-1992)	*/
+
+						/* When Channel set to 1: */
+#define SPCS_WORD_LENGTH_MASK	0x0000000f	/* Word Length Mask				*/
+#define SPCS_WORD_LENGTH_16	0x00000008	/* Word Length 16 bit				*/
+#define SPCS_WORD_LENGTH_17	0x00000006	/* Word Length 17 bit				*/
+#define SPCS_WORD_LENGTH_18	0x00000004	/* Word Length 18 bit				*/
+#define SPCS_WORD_LENGTH_19	0x00000002	/* Word Length 19 bit				*/
+#define SPCS_WORD_LENGTH_20A	0x0000000a	/* Word Length 20 bit				*/
+#define SPCS_WORD_LENGTH_20	0x00000009	/* Word Length 20 bit (both 0xa and 0x9 are 20 bit) */
+#define SPCS_WORD_LENGTH_21	0x00000007	/* Word Length 21 bit				*/
+#define SPCS_WORD_LENGTH_21	0x00000007	/* Word Length 21 bit				*/
+#define SPCS_WORD_LENGTH_22	0x00000005	/* Word Length 22 bit				*/
+#define SPCS_WORD_LENGTH_23	0x00000003	/* Word Length 23 bit				*/
+#define SPCS_WORD_LENGTH_24	0x0000000b	/* Word Length 24 bit				*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_MASK	0x000000f0 /* Original Sample rate			*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_NONE	0x00000000 /* Original Sample rate not indicated	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_16000	0x00000010 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_RES1	0x00000020 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_32000	0x00000030 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_12000	0x00000040 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_11025	0x00000050 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_8000	0x00000060 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_RES2	0x00000070 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_192000 0x00000080 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_24000	0x00000090 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_96000	0x000000a0 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_48000	0x000000b0 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_176400 0x000000c0 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_22050	0x000000d0 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_88200	0x000000e0 /* Original Sample rate	*/
+#define SPCS_ORIGINAL_SAMPLE_RATE_44100	0x000000f0 /* Original Sample rate	*/
+
+#define SPDIF_SELECT1		0x45		/* Enables SPDIF or Analogue outputs 0-SPDIF, 0xf00-Analogue */
+						/* 0x100 - Front, 0x800 - Rear, 0x200 - Center/LFE.
+						 * But as the jack is shared, use 0xf00.
+						 * The Windows2000 driver uses 0x0000000f for both digital and analog.
+						 * 0xf00 introduces interesting noises onto the Center/LFE.
+						 * If you turn the volume up, you hear computer noise,
+						 * e.g. mouse moving, changing between app windows etc.
+						 * So, I am going to set this to 0x0000000f all the time now,
+						 * same as the windows driver does.
+						 * Use register SPDIF_SELECT2(0x72) to switch between SPDIF and Analog.
+						 */
+						/* When Channel = 0:
+						 * Wide SPDIF format [3:0] (one bit for each channel) (0=20bit, 1=24bit)
+						 * Tristate SPDIF Output [11:8] (one bit for each channel) (0=Not tristate, 1=Tristate)
+						 * SPDIF Bypass enable [19:16] (one bit for each channel) (0=Not bypass, 1=Bypass)
+						 */
+						/* When Channel = 1:
+						 * SPDIF 0 User data [7:0]
+						 * SPDIF 1 User data [15:8]
+						 * SPDIF 0 User data [23:16]
+						 * SPDIF 0 User data [31:24]
+						 * User data can be sent by using the SPDIF output frame pending and SPDIF output user bit interrupts.
+						 */
+#define WATERMARK		0x46		/* Test bit to indicate cache usage level */
+#define SPDIF_INPUT_STATUS	0x49		/* SPDIF Input status register. Bits the same as SPCS.
+						 * When Channel = 0: Bits the same as SPCS channel 0.
+						 * When Channel = 1: Bits the same as SPCS channel 1.
+						 * When Channel = 2:
+						 * SPDIF Input User data [16:0]
+						 * SPDIF Input Frame count [21:16]
+						 */
+#define CAPTURE_CACHE_DATA	0x50		/* 0x50-0x5f Recorded samples. */
+#define CAPTURE_SOURCE          0x60            /* Capture Source 0 = MIC */
+#define CAPTURE_SOURCE_CHANNEL0 0xf0000000	/* Mask for selecting the Capture sources */
+#define CAPTURE_SOURCE_CHANNEL1 0x0f000000	/* 0 - SPDIF mixer output. */
+#define CAPTURE_SOURCE_CHANNEL2 0x00f00000      /* 1 - What you hear or . 2 - ?? */
+#define CAPTURE_SOURCE_CHANNEL3 0x000f0000	/* 3 - Mic in, Line in, TAD in, Aux in. */
+#define CAPTURE_SOURCE_RECORD_MAP 0x0000ffff	/* Default 0x00e4 */
+						/* Record Map [7:0] (2 bits per channel) 0=mapped to channel 0, 1=mapped to channel 1, 2=mapped to channel2, 3=mapped to channel3 
+						 * Record source select for channel 0 [18:16]
+						 * Record source select for channel 1 [22:20]
+						 * Record source select for channel 2 [26:24]
+						 * Record source select for channel 3 [30:28]
+						 * 0 - SPDIF mixer output.
+						 * 1 - i2s mixer output.
+						 * 2 - SPDIF input.
+						 * 3 - i2s input.
+						 * 4 - AC97 capture.
+						 * 5 - SRC output.
+						 */
+#define CAPTURE_VOLUME1         0x61            /* Capture  volume per channel 0-3 */
+#define CAPTURE_VOLUME2         0x62            /* Capture  volume per channel 4-7 */
+
+#define PLAYBACK_ROUTING1       0x63            /* Playback routing of channels 0-7. Effects AC3 output. Default 0x32765410 */
+#define ROUTING1_REAR           0x77000000      /* Channel_id 0 sends to 10, Channel_id 1 sends to 32 */
+#define ROUTING1_NULL           0x00770000      /* Channel_id 2 sends to 54, Channel_id 3 sends to 76 */
+#define ROUTING1_CENTER_LFE     0x00007700      /* 0x32765410 means, send Channel_id 0 to FRONT, Channel_id 1 to REAR */
+#define ROUTING1_FRONT          0x00000077	/* Channel_id 2 to CENTER_LFE, Channel_id 3 to NULL. */
+						/* Channel_id's handle stereo channels. Channel X is a single mono channel */
+						/* Host is input from the PCI bus. */
+						/* Host channel 0 [2:0] -> SPDIF Mixer/Router channel 0-7.
+						 * Host channel 1 [6:4] -> SPDIF Mixer/Router channel 0-7.
+						 * Host channel 2 [10:8] -> SPDIF Mixer/Router channel 0-7.
+						 * Host channel 3 [14:12] -> SPDIF Mixer/Router channel 0-7.
+						 * Host channel 4 [18:16] -> SPDIF Mixer/Router channel 0-7.
+						 * Host channel 5 [22:20] -> SPDIF Mixer/Router channel 0-7.
+						 * Host channel 6 [26:24] -> SPDIF Mixer/Router channel 0-7.
+						 * Host channel 7 [30:28] -> SPDIF Mixer/Router channel 0-7.
+						 */
+
+#define PLAYBACK_ROUTING2       0x64            /* Playback Routing . Feeding Capture channels back into Playback. Effects AC3 output. Default 0x76767676 */
+						/* SRC is input from the capture inputs. */
+						/* SRC channel 0 [2:0] -> SPDIF Mixer/Router channel 0-7.
+						 * SRC channel 1 [6:4] -> SPDIF Mixer/Router channel 0-7.
+						 * SRC channel 2 [10:8] -> SPDIF Mixer/Router channel 0-7.
+						 * SRC channel 3 [14:12] -> SPDIF Mixer/Router channel 0-7.
+						 * SRC channel 4 [18:16] -> SPDIF Mixer/Router channel 0-7.
+						 * SRC channel 5 [22:20] -> SPDIF Mixer/Router channel 0-7.
+						 * SRC channel 6 [26:24] -> SPDIF Mixer/Router channel 0-7.
+						 * SRC channel 7 [30:28] -> SPDIF Mixer/Router channel 0-7.
+						 */
+
+#define PLAYBACK_MUTE           0x65            /* Unknown. While playing 0x0, while silent 0x00fc0000 */
+						/* SPDIF Mixer input control:
+						 * Invert SRC to SPDIF Mixer [7-0] (One bit per channel)
+						 * Invert Host to SPDIF Mixer [15:8] (One bit per channel)
+						 * SRC to SPDIF Mixer disable [23:16] (One bit per channel)
+						 * Host to SPDIF Mixer disable [31:24] (One bit per channel)
+						 */
+#define PLAYBACK_VOLUME1        0x66            /* Playback SPDIF volume per channel. Set to the same PLAYBACK_VOLUME(0x6a) */
+						/* PLAYBACK_VOLUME1 must be set to 30303030 for SPDIF AC3 Playback */
+						/* SPDIF mixer input volume. 0=12dB, 0x30=0dB, 0xFE=-51.5dB, 0xff=Mute */
+						/* One register for each of the 4 stereo streams. */
+						/* SRC Right volume [7:0]
+						 * SRC Left  volume [15:8]
+						 * Host Right volume [23:16]
+						 * Host Left  volume [31:24]
+						 */
+#define CAPTURE_ROUTING1        0x67            /* Capture Routing. Default 0x32765410 */
+						/* Similar to register 0x63, except that the destination is the I2S mixer instead of the SPDIF mixer. I.E. Outputs to the Analog outputs instead of SPDIF. */
+#define CAPTURE_ROUTING2        0x68            /* Unknown Routing. Default 0x76767676 */
+						/* Similar to register 0x64, except that the destination is the I2S mixer instead of the SPDIF mixer. I.E. Outputs to the Analog outputs instead of SPDIF. */
+#define CAPTURE_MUTE            0x69            /* Unknown. While capturing 0x0, while silent 0x00fc0000 */
+						/* Similar to register 0x65, except that the destination is the I2S mixer instead of the SPDIF mixer. I.E. Outputs to the Analog outputs instead of SPDIF. */
+#define PLAYBACK_VOLUME2        0x6a            /* Playback Analog volume per channel. Does not effect AC3 output */
+						/* Similar to register 0x66, except that the destination is the I2S mixer instead of the SPDIF mixer. I.E. Outputs to the Analog outputs instead of SPDIF. */
+#define UNKNOWN6b               0x6b            /* Unknown. Readonly. Default 00400000 00400000 00400000 00400000 */
+#define UART_A_DATA		0x6c            /* Uart, used in setting sample rates, bits per sample etc. */
+#define UART_A_CMD		0x6d            /* Uart, used in setting sample rates, bits per sample etc. */
+#define UART_B_DATA		0x6e            /* Uart, Unknown. */
+#define UART_B_CMD		0x6f            /* Uart, Unknown. */
+#define SAMPLE_RATE_TRACKER_STATUS 0x70         /* Readonly. Default 00108000 00108000 00500000 00500000 */
+						/* Estimated sample rate [19:0] Relative to 48kHz. 0x8000 =  1.0
+						 * Rate Locked [20]
+						 * SPDIF Locked [21] For SPDIF channel only.
+						 * Valid Audio [22] For SPDIF channel only.
+						 */
+#define CAPTURE_CONTROL         0x71            /* Some sort of routing. default = 40c81000 30303030 30300000 00700000 */
+						/* Channel_id 0: 0x40c81000 must be changed to 0x40c80000 for SPDIF AC3 input or output. */
+						/* Channel_id 1: 0xffffffff(mute) 0x30303030(max) controls CAPTURE feedback into PLAYBACK. */
+						/* Sample rate output control register Channel=0
+						 * Sample output rate [1:0] (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)
+						 * Sample input rate [3:2] (0=48kHz, 1=Not available, 2=96kHz, 3=192Khz)
+						 * SRC input source select [4] 0=Audio from digital mixer, 1=Audio from analog source.
+						 * Record rate [9:8] (0=48kHz, 1=Not available, 2=96kHz, 3=192Khz)
+						 * Record mixer output enable [12:10] 
+						 * I2S input rate master mode [15:14] (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)
+						 * I2S output rate [17:16] (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)
+						 * I2S output source select [18] (0=Audio from host, 1=Audio from SRC)
+						 * Record mixer I2S enable [20:19] (enable/disable i2sin1 and i2sin0)
+						 * I2S output master clock select [21] (0=256*I2S output rate, 1=512*I2S output rate.)
+						 * I2S input master clock select [22] (0=256*I2S input rate, 1=512*I2S input rate.)
+						 * I2S input mode [23] (0=Slave, 1=Master)
+						 * SPDIF output rate [25:24] (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)
+						 * SPDIF output source select [26] (0=host, 1=SRC)
+						 * Not used [27]
+						 * Record Source 0 input [29:28] (0=SPDIF in, 1=I2S in, 2=AC97 Mic, 3=AC97 PCM)
+						 * Record Source 1 input [31:30] (0=SPDIF in, 1=I2S in, 2=AC97 Mic, 3=AC97 PCM)
+						 */ 
+						/* Sample rate output control register Channel=1
+						 * I2S Input 0 volume Right [7:0]
+						 * I2S Input 0 volume Left [15:8]
+						 * I2S Input 1 volume Right [23:16]
+						 * I2S Input 1 volume Left [31:24]
+						 */
+						/* Sample rate output control register Channel=2
+						 * SPDIF Input volume Right [23:16]
+						 * SPDIF Input volume Left [31:24]
+						 */
+						/* Sample rate output control register Channel=3
+						 * No used
+						 */
+#define SPDIF_SELECT2           0x72            /* Some sort of routing. Channel_id 0 only. default = 0x0f0f003f. Analog 0x000b0000, Digital 0x0b000000 */
+#define ROUTING2_FRONT_MASK     0x00010000      /* Enable for Front speakers. */
+#define ROUTING2_CENTER_LFE_MASK 0x00020000     /* Enable for Center/LFE speakers. */
+#define ROUTING2_REAR_MASK      0x00080000      /* Enable for Rear speakers. */
+						/* Audio output control
+						 * AC97 output enable [5:0]
+						 * I2S output enable [19:16]
+						 * SPDIF output enable [27:24]
+						 */ 
+#define UNKNOWN73               0x73            /* Unknown. Readonly. Default 0x0 */
+#define CHIP_VERSION            0x74            /* P17 Chip version. Channel_id 0 only. Default 00000071 */
+#define EXTENDED_INT_MASK       0x75            /* Used by both playback and capture interrupt handler */
+						/* Sets which Interrupts are enabled. */
+						/* 0x00000001 = Half period. Playback.
+						 * 0x00000010 = Full period. Playback.
+						 * 0x00000100 = Half buffer. Playback.
+						 * 0x00001000 = Full buffer. Playback.
+						 * 0x00010000 = Half buffer. Capture.
+						 * 0x00100000 = Full buffer. Capture.
+						 * Capture can only do 2 periods.
+						 * 0x01000000 = End audio. Playback.
+						 * 0x40000000 = Half buffer Playback,Caputre xrun.
+						 * 0x80000000 = Full buffer Playback,Caputre xrun.
+						 */
+#define EXTENDED_INT            0x76            /* Used by both playback and capture interrupt handler */
+						/* Shows which interrupts are active at the moment. */
+						/* Same bit layout as EXTENDED_INT_MASK */
+#define COUNTER77               0x77		/* Counter range 0 to 0x3fffff, 192000 counts per second. */
+#define COUNTER78               0x78		/* Counter range 0 to 0x3fffff, 44100 counts per second. */
+#define EXTENDED_INT_TIMER      0x79            /* Channel_id 0 only. Used by both playback and capture interrupt handler */
+						/* Causes interrupts based on timer intervals. */
+#define SPI			0x7a		/* SPI: Serial Interface Register */
+#define I2C_A			0x7b		/* I2C Address. 32 bit */
+#define I2C_0			0x7c		/* I2C Data Port 0. 32 bit */
+#define I2C_1			0x7d		/* I2C Data Port 1. 32 bit */
+
+
+#define SET_CHANNEL 0  /* Testing channel outputs 0=Front, 1=Center/LFE, 2=Unknown, 3=Rear */
+#define PCM_FRONT_CHANNEL 0
+#define PCM_REAR_CHANNEL 1
+#define PCM_CENTER_LFE_CHANNEL 2
+#define PCM_UNKNOWN_CHANNEL 3
+#define CONTROL_FRONT_CHANNEL 0
+#define CONTROL_REAR_CHANNEL 3
+#define CONTROL_CENTER_LFE_CHANNEL 1
+#define CONTROL_UNKNOWN_CHANNEL 2
+
+typedef struct snd_ca0106_channel ca0106_channel_t;
+typedef struct snd_ca0106 ca0106_t;
+typedef struct snd_ca0106_pcm ca0106_pcm_t;
+
+struct snd_ca0106_channel {
+	ca0106_t *emu;
+	int number;
+	int use;
+	void (*interrupt)(ca0106_t *emu, ca0106_channel_t *channel);
+	ca0106_pcm_t *epcm;
+};
+
+struct snd_ca0106_pcm {
+	ca0106_t *emu;
+	snd_pcm_substream_t *substream;
+        int channel_id;
+	unsigned short running;
+};
+
+// definition of the chip-specific record
+struct snd_ca0106 {
+	snd_card_t *card;
+	struct pci_dev *pci;
+
+	unsigned long port;
+	struct resource *res_port;
+	int irq;
+
+	unsigned int revision;		/* chip revision */
+	unsigned int serial;            /* serial number */
+	unsigned short model;		/* subsystem id */
+
+	spinlock_t emu_lock;
+
+	ac97_t *ac97;
+	snd_pcm_t *pcm;
+
+	ca0106_channel_t playback_channels[4];
+	ca0106_channel_t capture_channels[4];
+	u32 spdif_bits[4];             /* s/pdif out setup */
+	int spdif_enable;
+	int capture_source;
+
+	struct snd_dma_buffer buffer;
+};
+
+int __devinit snd_ca0106_mixer(ca0106_t *emu);
+int __devinit snd_ca0106_proc_init(ca0106_t * emu);
+
+unsigned int snd_ca0106_ptr_read(ca0106_t * emu, 
+					  unsigned int reg, 
+					  unsigned int chn);
+
+void snd_ca0106_ptr_write(ca0106_t *emu, 
+				   unsigned int reg, 
+				   unsigned int chn, 
+				   unsigned int data);
+
diff -uNr a/sound/pci/ca0106/ca0106_main.c b/sound/pci/ca0106/ca0106_main.c
--- a/sound/pci/ca0106/ca0106_main.c	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/pci/ca0106/ca0106_main.c	2005-01-14 22:28:12.077522368 +0100
@@ -0,0 +1,1274 @@
+/*
+ *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
+ *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
+ *  Version: 0.0.21
+ *
+ *  FEATURES currently supported:
+ *    Front, Rear and Center/LFE.
+ *    Surround40 and Surround51.
+ *    Capture from MIC an LINE IN input.
+ *    SPDIF digital playback of PCM stereo and AC3/DTS works.
+ *    (One can use a standard mono mini-jack to one RCA plugs cable.
+ *     or one can use a standard stereo mini-jack to two RCA plugs cable.
+ *     Plug one of the RCA plugs into the Coax input of the external decoder/receiver.)
+ *    ( In theory one could output 3 different AC3 streams at once, to 3 different SPDIF outputs. )
+ *    Notes on how to capture sound:
+ *      The AC97 is used in the PLAYBACK direction.
+ *      The output from the AC97 chip, instead of reaching the speakers, is fed into the Philips 1361T ADC.
+ *      So, to record from the MIC, set the MIC Playback volume to max,
+ *      unmute the MIC and turn up the MASTER Playback volume.
+ *      So, to prevent feedback when capturing, minimise the "Capture feedback into Playback" volume.
+ *   
+ *    The only playback controls that currently do anything are: -
+ *    Analog Front
+ *    Analog Rear
+ *    Analog Center/LFE
+ *    SPDIF Front
+ *    SPDIF Rear
+ *    SPDIF Center/LFE
+ *   
+ *    For capture from Mic in or Line in.
+ *    Digital/Analog ( switch must be in Analog mode for CAPTURE. )
+ * 
+ *    CAPTURE feedback into PLAYBACK
+ * 
+ *  Changelog:
+ *    Support interrupts per period.
+ *    Removed noise from Center/LFE channel when in Analog mode.
+ *    Rename and remove mixer controls.
+ *  0.0.6
+ *    Use separate card based DMA buffer for periods table list.
+ *  0.0.7
+ *    Change remove and rename ctrls into lists.
+ *  0.0.8
+ *    Try to fix capture sources.
+ *  0.0.9
+ *    Fix AC3 output.
+ *    Enable S32_LE format support.
+ *  0.0.10
+ *    Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)
+ *  0.0.11
+ *    Add Model name recognition.
+ *  0.0.12
+ *    Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.
+ *    Remove redundent "voice" handling.
+ *  0.0.13
+ *    Single trigger call for multi channels.
+ *  0.0.14
+ *    Set limits based on what the sound card hardware can do.
+ *    playback periods_min=2, periods_max=8
+ *    capture hw constraints require period_size = n * 64 bytes.
+ *    playback hw constraints require period_size = n * 64 bytes.
+ *  0.0.15
+ *    Minor updates.
+ *  0.0.16
+ *    Implement 192000 sample rate.
+ *  0.0.17
+ *    Add support for SB0410 and SB0413.
+ *  0.0.18
+ *    Modified Copyright message.
+ *  0.0.19
+ *    Finally fix support for SB Live 24 bit. SB0410 and SB0413.
+ *    The output codec needs resetting, otherwise all output is muted.
+ *  0.0.20
+ *    Merge "pci_disable_device(pci);" fixes.
+ *  0.0.21
+ *    Add 4 capture channels. (SPDIF only comes in on channel 0. )
+ *    Add SPDIF capture using optional digital I/O module for SB Live 24bit. (Analog capture does not yet work.)
+ *
+ *  BUGS:
+ *    Some stability problems when unloading the snd-ca0106 kernel module.
+ *    --
+ *
+ *  TODO:
+ *    4 Capture channels, only one implemented so far.
+ *    Other capture rates apart from 48khz not implemented.
+ *    MIDI
+ *    --
+ *  GENERAL INFO:
+ *    Model: SB0310
+ *    P17 Chip: CA0106-DAT
+ *    AC97 Codec: STAC 9721
+ *    ADC: Philips 1361T (Stereo 24bit)
+ *    DAC: WM8746EDS (6-channel, 24bit, 192Khz)
+ *
+ *  GENERAL INFO:
+ *    Model: SB0410
+ *    P17 Chip: CA0106-DAT
+ *    AC97 Codec: None
+ *    ADC: WM8775EDS (4 Channel)
+ *    DAC: CS4382 (114 dB, 24-Bit, 192 kHz, 8-Channel D/A Converter with DSD Support)
+ *    SPDIF Out control switches between Mic in and SPDIF out.
+ *    No sound out or mic input working yet.
+ * 
+ *  GENERAL INFO:
+ *    Model: SB0413
+ *    P17 Chip: CA0106-DAT
+ *    AC97 Codec: None.
+ *    ADC: Unknown
+ *    DAC: Unknown
+ *    Trying to handle it like the SB0410.
+ *
+ *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/info.h>
+
+MODULE_AUTHOR("James Courtier-Dutton <James@superbug.demon.co.uk>");
+MODULE_DESCRIPTION("CA0106");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Creative,SB CA0106 chip}}");
+
+// module parameters (see "Module Parameters")
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for the CA0106 soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for the CA0106 soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable the CA0106 soundcard.");
+
+#include "ca0106.h"
+
+typedef struct {
+	u32 serial;
+	char * name;
+} ca0106_names_t;
+
+static ca0106_names_t ca0106_chip_names[] = {
+	 { 0x10021102, "AudigyLS [SB0310]"} , 
+	 { 0x10051102, "AudigyLS [SB0310b]"} , /* Unknown AudigyLS that also says SB0310 on it */
+	 { 0x10061102, "Live! 7.1 24bit [SB0410]"} , /* New Sound Blaster Live! 7.1 24bit. This does not have an AC97. 53SB041000001 */
+	 { 0x10071102, "Live! 7.1 24bit [SB0413]"} , /* New Dell Sound Blaster Live! 7.1 24bit. This does not have an AC97.  */
+	 { 0, "AudigyLS [Unknown]" }
+};
+
+/* hardware definition */
+static snd_pcm_hardware_t snd_ca0106_playback_hw = {
+	.info =			(SNDRV_PCM_INFO_MMAP | 
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,
+	.rates =		SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000,
+	.rate_min =		48000,
+	.rate_max =		192000,
+	.channels_min =		2,  //1,
+	.channels_max =		2,  //6,
+	.buffer_bytes_max =	(32*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(16*1024),
+	.periods_min =		2,
+	.periods_max =		8,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_ca0106_capture_hw = {
+	.info =			(SNDRV_PCM_INFO_MMAP | 
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(32*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(16*1024),
+	.periods_min =		2,
+	.periods_max =		2,
+	.fifo_size =		0,
+};
+
+unsigned int snd_ca0106_ptr_read(ca0106_t * emu, 
+					  unsigned int reg, 
+					  unsigned int chn)
+{
+	unsigned long flags;
+	unsigned int regptr, val;
+  
+	regptr = (reg << 16) | chn;
+
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outl(regptr, emu->port + PTR);
+	val = inl(emu->port + DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+	return val;
+}
+
+void snd_ca0106_ptr_write(ca0106_t *emu, 
+				   unsigned int reg, 
+				   unsigned int chn, 
+				   unsigned int data)
+{
+	unsigned int regptr;
+	unsigned long flags;
+
+	regptr = (reg << 16) | chn;
+
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outl(regptr, emu->port + PTR);
+	outl(data, emu->port + DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+static void snd_ca0106_intr_enable(ca0106_t *emu, unsigned int intrenb)
+{
+	unsigned long flags;
+	unsigned int enable;
+  
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	enable = inl(emu->port + INTE) | intrenb;
+	outl(enable, emu->port + INTE);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+static void snd_ca0106_pcm_free_substream(snd_pcm_runtime_t *runtime)
+{
+	ca0106_pcm_t *epcm = runtime->private_data;
+  
+	if (epcm) {
+		kfree(epcm);
+	}
+}
+
+/* open_playback callback */
+static int snd_ca0106_pcm_open_playback_channel(snd_pcm_substream_t *substream, int channel_id)
+{
+	ca0106_t *chip = snd_pcm_substream_chip(substream);
+        ca0106_channel_t *channel = &(chip->playback_channels[channel_id]);
+	ca0106_pcm_t *epcm;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	epcm = kcalloc(1, sizeof(*epcm), GFP_KERNEL);
+
+	if (epcm == NULL)
+		return -ENOMEM;
+	epcm->emu = chip;
+	epcm->substream = substream;
+        epcm->channel_id=channel_id;
+  
+	runtime->private_data = epcm;
+	runtime->private_free = snd_ca0106_pcm_free_substream;
+  
+	runtime->hw = snd_ca0106_playback_hw;
+
+        channel->emu = chip;
+        channel->number = channel_id;
+
+        channel->use=1;
+        //printk("open:channel_id=%d, chip=%p, channel=%p\n",channel_id, chip, channel);
+        //channel->interrupt = snd_ca0106_pcm_channel_interrupt;
+        channel->epcm=epcm;
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+                return err;
+	if ((err = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64)) < 0)
+                return err;
+	return 0;
+}
+
+/* close callback */
+static int snd_ca0106_pcm_close_playback(snd_pcm_substream_t *substream)
+{
+	ca0106_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+        ca0106_pcm_t *epcm = runtime->private_data;
+        chip->playback_channels[epcm->channel_id].use=0;
+/* FIXME: maybe zero others */
+	return 0;
+}
+
+static int snd_ca0106_pcm_open_playback_front(snd_pcm_substream_t *substream)
+{
+	return snd_ca0106_pcm_open_playback_channel(substream, PCM_FRONT_CHANNEL);
+}
+
+static int snd_ca0106_pcm_open_playback_center_lfe(snd_pcm_substream_t *substream)
+{
+	return snd_ca0106_pcm_open_playback_channel(substream, PCM_CENTER_LFE_CHANNEL);
+}
+
+static int snd_ca0106_pcm_open_playback_unknown(snd_pcm_substream_t *substream)
+{
+	return snd_ca0106_pcm_open_playback_channel(substream, PCM_UNKNOWN_CHANNEL);
+}
+
+static int snd_ca0106_pcm_open_playback_rear(snd_pcm_substream_t *substream)
+{
+	return snd_ca0106_pcm_open_playback_channel(substream, PCM_REAR_CHANNEL);
+}
+
+/* open_capture callback */
+static int snd_ca0106_pcm_open_capture_channel(snd_pcm_substream_t *substream, int channel_id)
+{
+	ca0106_t *chip = snd_pcm_substream_chip(substream);
+        ca0106_channel_t *channel = &(chip->capture_channels[channel_id]);
+	ca0106_pcm_t *epcm;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	epcm = kcalloc(1, sizeof(*epcm), GFP_KERNEL);
+	if (epcm == NULL) {
+                snd_printk("open_capture_channel: failed epcm alloc\n");
+		return -ENOMEM;
+        }
+	epcm->emu = chip;
+	epcm->substream = substream;
+        epcm->channel_id=channel_id;
+  
+	runtime->private_data = epcm;
+	runtime->private_free = snd_ca0106_pcm_free_substream;
+  
+	runtime->hw = snd_ca0106_capture_hw;
+
+        channel->emu = chip;
+        channel->number = channel_id;
+
+        channel->use=1;
+        //printk("open:channel_id=%d, chip=%p, channel=%p\n",channel_id, chip, channel);
+        //channel->interrupt = snd_ca0106_pcm_channel_interrupt;
+        channel->epcm=epcm;
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+                return err;
+	//snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_capture_period_sizes);
+	if ((err = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64)) < 0)
+                return err;
+	return 0;
+}
+
+/* close callback */
+static int snd_ca0106_pcm_close_capture(snd_pcm_substream_t *substream)
+{
+	ca0106_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+        ca0106_pcm_t *epcm = runtime->private_data;
+        chip->capture_channels[epcm->channel_id].use=0;
+/* FIXME: maybe zero others */
+	return 0;
+}
+
+static int snd_ca0106_pcm_open_0_capture(snd_pcm_substream_t *substream)
+{
+	return snd_ca0106_pcm_open_capture_channel(substream, 0);
+}
+
+static int snd_ca0106_pcm_open_1_capture(snd_pcm_substream_t *substream)
+{
+	return snd_ca0106_pcm_open_capture_channel(substream, 1);
+}
+
+static int snd_ca0106_pcm_open_2_capture(snd_pcm_substream_t *substream)
+{
+	return snd_ca0106_pcm_open_capture_channel(substream, 2);
+}
+
+static int snd_ca0106_pcm_open_3_capture(snd_pcm_substream_t *substream)
+{
+	return snd_ca0106_pcm_open_capture_channel(substream, 3);
+}
+
+/* hw_params callback */
+static int snd_ca0106_pcm_hw_params_playback(snd_pcm_substream_t *substream,
+				      snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+/* hw_free callback */
+static int snd_ca0106_pcm_hw_free_playback(snd_pcm_substream_t *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/* hw_params callback */
+static int snd_ca0106_pcm_hw_params_capture(snd_pcm_substream_t *substream,
+				      snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+/* hw_free callback */
+static int snd_ca0106_pcm_hw_free_capture(snd_pcm_substream_t *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/* prepare playback callback */
+static int snd_ca0106_pcm_prepare_playback(snd_pcm_substream_t *substream)
+{
+	ca0106_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	ca0106_pcm_t *epcm = runtime->private_data;
+	int channel = epcm->channel_id;
+	u32 *table_base = (u32 *)(emu->buffer.area+(8*16*channel));
+	u32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);
+	u32 hcfg_mask = HCFG_PLAYBACK_S32_LE;
+	u32 hcfg_set = 0x00000000;
+	u32 hcfg;
+	u32 reg40_mask = 0x30000 << (channel<<1);
+	u32 reg40_set = 0;
+	u32 reg40;
+	/* FIXME: Depending on mixer selection of SPDIF out or not, select the spdif rate or the DAC rate. */
+	u32 reg71_mask = 0x03030000 ; /* Global. Set SPDIF rate. We only support 44100 to spdif, not to DAC. */
+	u32 reg71_set = 0;
+	u32 reg71;
+	int i;
+	
+        //snd_printk("prepare:channel_number=%d, rate=%d, format=0x%x, channels=%d, buffer_size=%ld, period_size=%ld, periods=%u, frames_to_bytes=%d\n",channel, runtime->rate, runtime->format, runtime->channels, runtime->buffer_size, runtime->period_size, runtime->periods, frames_to_bytes(runtime, 1));
+        //snd_printk("dma_addr=%x, dma_area=%p, table_base=%p\n",runtime->dma_addr, runtime->dma_area, table_base);
+	//snd_printk("dma_addr=%x, dma_area=%p, dma_bytes(size)=%x\n",emu->buffer.addr, emu->buffer.area, emu->buffer.bytes);
+	/* Rate can be set per channel. */
+	/* reg40 control host to fifo */
+	/* reg71 controls DAC rate. */
+	switch (runtime->rate) {
+	case 44100:
+		reg40_set = 0x10000 << (channel<<1);
+		reg71_set = 0x01010000; 
+		break;
+        case 48000:
+		reg40_set = 0;
+		reg71_set = 0; 
+		break;
+	case 96000:
+		reg40_set = 0x20000 << (channel<<1);
+		reg71_set = 0x02020000; 
+		break;
+	case 192000:
+		reg40_set = 0x30000 << (channel<<1);
+		reg71_set = 0x03030000; 
+		break;
+	default:
+		reg40_set = 0;
+		reg71_set = 0; 
+		break;
+	}
+	/* Format is a global setting */
+	/* FIXME: Only let the first channel accessed set this. */
+	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		hcfg_set = 0;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		hcfg_set = HCFG_PLAYBACK_S32_LE;
+		break;
+	default:
+		hcfg_set = 0;
+		break;
+	}
+	hcfg = inl(emu->port + HCFG) ;
+	hcfg = (hcfg & ~hcfg_mask) | hcfg_set;
+	outl(hcfg, emu->port + HCFG);
+	reg40 = snd_ca0106_ptr_read(emu, 0x40, 0);
+	reg40 = (reg40 & ~reg40_mask) | reg40_set;
+	snd_ca0106_ptr_write(emu, 0x40, 0, reg40);
+	reg71 = snd_ca0106_ptr_read(emu, 0x71, 0);
+	reg71 = (reg71 & ~reg71_mask) | reg71_set;
+	snd_ca0106_ptr_write(emu, 0x71, 0, reg71);
+
+	/* FIXME: Check emu->buffer.size before actually writing to it. */
+        for(i=0; i < runtime->periods; i++) {
+		table_base[i*2]=runtime->dma_addr+(i*period_size_bytes);
+		table_base[(i*2)+1]=period_size_bytes<<16;
+	}
+ 
+	snd_ca0106_ptr_write(emu, PLAYBACK_LIST_ADDR, channel, emu->buffer.addr+(8*16*channel));
+	snd_ca0106_ptr_write(emu, PLAYBACK_LIST_SIZE, channel, (runtime->periods - 1) << 19);
+	snd_ca0106_ptr_write(emu, PLAYBACK_LIST_PTR, channel, 0);
+	snd_ca0106_ptr_write(emu, PLAYBACK_DMA_ADDR, channel, runtime->dma_addr);
+	snd_ca0106_ptr_write(emu, PLAYBACK_PERIOD_SIZE, channel, frames_to_bytes(runtime, runtime->period_size)<<16); // buffer size in bytes
+	snd_ca0106_ptr_write(emu, PLAYBACK_POINTER, channel, 0);
+	snd_ca0106_ptr_write(emu, 0x07, channel, 0x0);
+	snd_ca0106_ptr_write(emu, 0x08, channel, 0);
+        snd_ca0106_ptr_write(emu, PLAYBACK_MUTE, 0x0, 0x0); /* Unmute output */
+#if 0
+	snd_ca0106_ptr_write(emu, SPCS0, 0,
+			       SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+			       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |
+			       SPCS_GENERATIONSTATUS | 0x00001200 |
+			       0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT );
+	}
+#endif
+
+	return 0;
+}
+
+/* prepare capture callback */
+static int snd_ca0106_pcm_prepare_capture(snd_pcm_substream_t *substream)
+{
+	ca0106_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	ca0106_pcm_t *epcm = runtime->private_data;
+	int channel = epcm->channel_id;
+        //printk("prepare:channel_number=%d, rate=%d, format=0x%x, channels=%d, buffer_size=%ld, period_size=%ld, frames_to_bytes=%d\n",channel, runtime->rate, runtime->format, runtime->channels, runtime->buffer_size, runtime->period_size,  frames_to_bytes(runtime, 1));
+	snd_ca0106_ptr_write(emu, 0x13, channel, 0);
+	snd_ca0106_ptr_write(emu, CAPTURE_DMA_ADDR, channel, runtime->dma_addr);
+	snd_ca0106_ptr_write(emu, CAPTURE_BUFFER_SIZE, channel, frames_to_bytes(runtime, runtime->buffer_size)<<16); // buffer size in bytes
+	snd_ca0106_ptr_write(emu, CAPTURE_POINTER, channel, 0);
+
+	return 0;
+}
+
+/* trigger_playback callback */
+static int snd_ca0106_pcm_trigger_playback(snd_pcm_substream_t *substream,
+				    int cmd)
+{
+	ca0106_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime;
+	ca0106_pcm_t *epcm;
+	int channel;
+	int result = 0;
+	struct list_head *pos;
+        snd_pcm_substream_t *s;
+	u32 basic = 0;
+	u32 extended = 0;
+	int running=0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		running=1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	default:
+		running=0;
+		break;
+	}
+        snd_pcm_group_for_each(pos, substream) {
+                s = snd_pcm_group_substream_entry(pos);
+		runtime = s->runtime;
+		epcm = runtime->private_data;
+		channel = epcm->channel_id;
+		//snd_printk("channel=%d\n",channel);
+		epcm->running = running;
+		basic |= (0x1<<channel);
+		extended |= (0x10<<channel);
+                snd_pcm_trigger_done(s, substream);
+        }
+	//snd_printk("basic=0x%x, extended=0x%x\n",basic, extended);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		snd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0) | (extended));
+		snd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0)|(basic));
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		snd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0) & ~(basic));
+		snd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0) & ~(extended));
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+	return result;
+}
+
+/* trigger_capture callback */
+static int snd_ca0106_pcm_trigger_capture(snd_pcm_substream_t *substream,
+				    int cmd)
+{
+	ca0106_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	ca0106_pcm_t *epcm = runtime->private_data;
+	int channel = epcm->channel_id;
+	int result = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		snd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0) | (0x110000<<channel));
+		snd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0)|(0x100<<channel));
+		epcm->running = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		snd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0) & ~(0x100<<channel));
+		snd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0) & ~(0x110000<<channel));
+		epcm->running = 0;
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+	return result;
+}
+
+/* pointer_playback callback */
+static snd_pcm_uframes_t
+snd_ca0106_pcm_pointer_playback(snd_pcm_substream_t *substream)
+{
+	ca0106_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	ca0106_pcm_t *epcm = runtime->private_data;
+	snd_pcm_uframes_t ptr, ptr1, ptr2,ptr3,ptr4 = 0;
+	int channel = epcm->channel_id;
+
+	if (!epcm->running)
+		return 0;
+
+	ptr3 = snd_ca0106_ptr_read(emu, PLAYBACK_LIST_PTR, channel);
+	ptr1 = snd_ca0106_ptr_read(emu, PLAYBACK_POINTER, channel);
+	ptr4 = snd_ca0106_ptr_read(emu, PLAYBACK_LIST_PTR, channel);
+	if (ptr3 != ptr4) ptr1 = snd_ca0106_ptr_read(emu, PLAYBACK_POINTER, channel);
+	ptr2 = bytes_to_frames(runtime, ptr1);
+	ptr2+= (ptr4 >> 3) * runtime->period_size;
+	ptr=ptr2;
+        if (ptr >= runtime->buffer_size)
+		ptr -= runtime->buffer_size;
+	//printk("ptr1 = 0x%lx, ptr2=0x%lx, ptr=0x%lx, buffer_size = 0x%x, period_size = 0x%x, bits=%d, rate=%d\n", ptr1, ptr2, ptr, (int)runtime->buffer_size, (int)runtime->period_size, (int)runtime->frame_bits, (int)runtime->rate);
+
+	return ptr;
+}
+
+/* pointer_capture callback */
+static snd_pcm_uframes_t
+snd_ca0106_pcm_pointer_capture(snd_pcm_substream_t *substream)
+{
+	ca0106_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	ca0106_pcm_t *epcm = runtime->private_data;
+	snd_pcm_uframes_t ptr, ptr1, ptr2 = 0;
+	int channel = channel=epcm->channel_id;
+
+	if (!epcm->running)
+		return 0;
+
+	ptr1 = snd_ca0106_ptr_read(emu, CAPTURE_POINTER, channel);
+	ptr2 = bytes_to_frames(runtime, ptr1);
+	ptr=ptr2;
+        if (ptr >= runtime->buffer_size)
+		ptr -= runtime->buffer_size;
+	//printk("ptr1 = 0x%lx, ptr2=0x%lx, ptr=0x%lx, buffer_size = 0x%x, period_size = 0x%x, bits=%d, rate=%d\n", ptr1, ptr2, ptr, (int)runtime->buffer_size, (int)runtime->period_size, (int)runtime->frame_bits, (int)runtime->rate);
+
+	return ptr;
+}
+
+/* operators */
+static snd_pcm_ops_t snd_ca0106_playback_front_ops = {
+	.open =        snd_ca0106_pcm_open_playback_front,
+	.close =       snd_ca0106_pcm_close_playback,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   snd_ca0106_pcm_hw_params_playback,
+	.hw_free =     snd_ca0106_pcm_hw_free_playback,
+	.prepare =     snd_ca0106_pcm_prepare_playback,
+	.trigger =     snd_ca0106_pcm_trigger_playback,
+	.pointer =     snd_ca0106_pcm_pointer_playback,
+};
+
+static snd_pcm_ops_t snd_ca0106_capture_0_ops = {
+	.open =        snd_ca0106_pcm_open_0_capture,
+	.close =       snd_ca0106_pcm_close_capture,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   snd_ca0106_pcm_hw_params_capture,
+	.hw_free =     snd_ca0106_pcm_hw_free_capture,
+	.prepare =     snd_ca0106_pcm_prepare_capture,
+	.trigger =     snd_ca0106_pcm_trigger_capture,
+	.pointer =     snd_ca0106_pcm_pointer_capture,
+};
+
+static snd_pcm_ops_t snd_ca0106_capture_1_ops = {
+	.open =        snd_ca0106_pcm_open_1_capture,
+	.close =       snd_ca0106_pcm_close_capture,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   snd_ca0106_pcm_hw_params_capture,
+	.hw_free =     snd_ca0106_pcm_hw_free_capture,
+	.prepare =     snd_ca0106_pcm_prepare_capture,
+	.trigger =     snd_ca0106_pcm_trigger_capture,
+	.pointer =     snd_ca0106_pcm_pointer_capture,
+};
+
+static snd_pcm_ops_t snd_ca0106_capture_2_ops = {
+	.open =        snd_ca0106_pcm_open_2_capture,
+	.close =       snd_ca0106_pcm_close_capture,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   snd_ca0106_pcm_hw_params_capture,
+	.hw_free =     snd_ca0106_pcm_hw_free_capture,
+	.prepare =     snd_ca0106_pcm_prepare_capture,
+	.trigger =     snd_ca0106_pcm_trigger_capture,
+	.pointer =     snd_ca0106_pcm_pointer_capture,
+};
+
+static snd_pcm_ops_t snd_ca0106_capture_3_ops = {
+	.open =        snd_ca0106_pcm_open_3_capture,
+	.close =       snd_ca0106_pcm_close_capture,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   snd_ca0106_pcm_hw_params_capture,
+	.hw_free =     snd_ca0106_pcm_hw_free_capture,
+	.prepare =     snd_ca0106_pcm_prepare_capture,
+	.trigger =     snd_ca0106_pcm_trigger_capture,
+	.pointer =     snd_ca0106_pcm_pointer_capture,
+};
+
+static snd_pcm_ops_t snd_ca0106_playback_center_lfe_ops = {
+        .open =         snd_ca0106_pcm_open_playback_center_lfe,
+        .close =        snd_ca0106_pcm_close_playback,
+        .ioctl =        snd_pcm_lib_ioctl,
+        .hw_params =    snd_ca0106_pcm_hw_params_playback,
+        .hw_free =      snd_ca0106_pcm_hw_free_playback,
+        .prepare =      snd_ca0106_pcm_prepare_playback,     
+        .trigger =      snd_ca0106_pcm_trigger_playback,  
+        .pointer =      snd_ca0106_pcm_pointer_playback, 
+};
+
+static snd_pcm_ops_t snd_ca0106_playback_unknown_ops = {
+        .open =         snd_ca0106_pcm_open_playback_unknown,
+        .close =        snd_ca0106_pcm_close_playback,
+        .ioctl =        snd_pcm_lib_ioctl,
+        .hw_params =    snd_ca0106_pcm_hw_params_playback,
+        .hw_free =      snd_ca0106_pcm_hw_free_playback,
+        .prepare =      snd_ca0106_pcm_prepare_playback,     
+        .trigger =      snd_ca0106_pcm_trigger_playback,  
+        .pointer =      snd_ca0106_pcm_pointer_playback, 
+};
+
+static snd_pcm_ops_t snd_ca0106_playback_rear_ops = {
+        .open =         snd_ca0106_pcm_open_playback_rear,
+        .close =        snd_ca0106_pcm_close_playback,
+        .ioctl =        snd_pcm_lib_ioctl,
+        .hw_params =    snd_ca0106_pcm_hw_params_playback,
+		.hw_free =      snd_ca0106_pcm_hw_free_playback,
+        .prepare =      snd_ca0106_pcm_prepare_playback,     
+        .trigger =      snd_ca0106_pcm_trigger_playback,  
+        .pointer =      snd_ca0106_pcm_pointer_playback, 
+};
+
+
+static unsigned short snd_ca0106_ac97_read(ac97_t *ac97,
+					     unsigned short reg)
+{
+	ca0106_t *emu = ac97->private_data;
+	unsigned long flags;
+	unsigned short val;
+
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outb(reg, emu->port + AC97ADDRESS);
+	val = inw(emu->port + AC97DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+	return val;
+}
+
+static void snd_ca0106_ac97_write(ac97_t *ac97,
+				    unsigned short reg, unsigned short val)
+{
+	ca0106_t *emu = ac97->private_data;
+	unsigned long flags;
+  
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outb(reg, emu->port + AC97ADDRESS);
+	outw(val, emu->port + AC97DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+static int snd_ca0106_ac97(ca0106_t *chip)
+{
+	ac97_bus_t *pbus;
+	ac97_template_t ac97;
+	int err;
+	static ac97_bus_ops_t ops = {
+		.write = snd_ca0106_ac97_write,
+		.read = snd_ca0106_ac97_read,
+	};
+  
+	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
+		return err;
+	pbus->no_vra = 1; /* we don't need VRA */
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+	return snd_ac97_mixer(pbus, &ac97, &chip->ac97);
+}
+
+static int snd_ca0106_free(ca0106_t *chip)
+{
+	if (chip->res_port != NULL) {    /* avoid access to already used hardware */
+		// disable interrupts
+		snd_ca0106_ptr_write(chip, BASIC_INTERRUPT, 0, 0);
+		outl(0, chip->port + INTE);
+		snd_ca0106_ptr_write(chip, EXTENDED_INT_MASK, 0, 0);
+		udelay(1000);
+		// disable audio
+		//outl(HCFG_LOCKSOUNDCACHE, chip->port + HCFG);
+		outl(0, chip->port + HCFG);
+		/* FIXME: We need to stop and DMA transfers here.
+		 *        But as I am not sure how yet, we cannot from the dma pages.
+		 * So we can fix: snd-malloc: Memory leak?  pages not freed = 8
+		 */
+	}
+	// release the data
+#if 1
+	if (chip->buffer.area)
+		snd_dma_free_pages(&chip->buffer);
+#endif
+
+	// release the i/o port
+	if (chip->res_port) {
+		release_resource(chip->res_port);
+		kfree_nocheck(chip->res_port);
+	}
+	// release the irq
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
+	pci_disable_device(chip->pci);
+	kfree(chip);
+	return 0;
+}
+
+static int snd_ca0106_dev_free(snd_device_t *device)
+{
+	ca0106_t *chip = device->device_data;
+	return snd_ca0106_free(chip);
+}
+
+static irqreturn_t snd_ca0106_interrupt(int irq, void *dev_id,
+					  struct pt_regs *regs)
+{
+	unsigned int status;
+
+	ca0106_t *chip = dev_id;
+	int i;
+	int mask;
+        unsigned int stat76;
+	ca0106_channel_t *pchannel;
+
+	spin_lock(&chip->emu_lock);
+
+	status = inl(chip->port + IPR);
+
+	// call updater, unlock before it
+	spin_unlock(&chip->emu_lock);
+  
+	if (! status)
+		return IRQ_NONE;
+
+        stat76 = snd_ca0106_ptr_read(chip, EXTENDED_INT, 0);
+	//snd_printk("interrupt status = 0x%08x, stat76=0x%08x\n", status, stat76);
+	//snd_printk("ptr=0x%08x\n",snd_ca0106_ptr_read(chip, PLAYBACK_POINTER, 0));
+        mask = 0x11; /* 0x1 for one half, 0x10 for the other half period. */
+	for(i = 0; i < 4; i++) {
+		pchannel = &(chip->playback_channels[i]);
+		if(stat76 & mask) {
+/* FIXME: Select the correct substream for period elapsed */
+			if(pchannel->use) {
+                          snd_pcm_period_elapsed(pchannel->epcm->substream);
+	                //printk(KERN_INFO "interrupt [%d] used\n", i);
+                        }
+		}
+	        //printk(KERN_INFO "channel=%p\n",pchannel);
+	        //printk(KERN_INFO "interrupt stat76[%d] = %08x, use=%d, channel=%d\n", i, stat76, pchannel->use, pchannel->number);
+		mask <<= 1;
+	}
+        mask = 0x110000; /* 0x1 for one half, 0x10 for the other half period. */
+	for(i = 0; i < 4; i++) {
+		pchannel = &(chip->capture_channels[i]);
+		if(stat76 & mask) {
+/* FIXME: Select the correct substream for period elapsed */
+			if(pchannel->use) {
+                          snd_pcm_period_elapsed(pchannel->epcm->substream);
+	                //printk(KERN_INFO "interrupt [%d] used\n", i);
+                        }
+		}
+	        //printk(KERN_INFO "channel=%p\n",pchannel);
+	        //printk(KERN_INFO "interrupt stat76[%d] = %08x, use=%d, channel=%d\n", i, stat76, pchannel->use, pchannel->number);
+		mask <<= 1;
+	}
+
+        snd_ca0106_ptr_write(chip, EXTENDED_INT, 0, stat76);
+	spin_lock(&chip->emu_lock);
+	// acknowledge the interrupt if necessary
+	outl(status, chip->port+IPR);
+
+	spin_unlock(&chip->emu_lock);
+
+	return IRQ_HANDLED;
+}
+
+static void snd_ca0106_pcm_free(snd_pcm_t *pcm)
+{
+	ca0106_t *emu = pcm->private_data;
+	emu->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_ca0106_pcm(ca0106_t *emu, int device, snd_pcm_t **rpcm)
+{
+	snd_pcm_t *pcm;
+	snd_pcm_substream_t *substream;
+	int err;
+  
+	if (rpcm)
+		*rpcm = NULL;
+	if ((err = snd_pcm_new(emu->card, "ca0106", device, 1, 1, &pcm)) < 0)
+		return err;
+  
+	pcm->private_data = emu;
+	pcm->private_free = snd_ca0106_pcm_free;
+
+	switch (device) {
+	case 0:
+	  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_front_ops);
+	  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_0_ops);
+          break;
+	case 1:
+	  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_rear_ops);
+	  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_1_ops);
+          break;
+	case 2:
+	  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_center_lfe_ops);
+	  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_2_ops);
+          break;
+	case 3:
+	  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_unknown_ops);
+	  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_3_ops);
+          break;
+        }
+
+	pcm->info_flags = 0;
+	pcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;
+	strcpy(pcm->name, "CA0106");
+	emu->pcm = pcm;
+
+	for(substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; 
+	    substream; 
+	    substream = substream->next) {
+		if ((err = snd_pcm_lib_preallocate_pages(substream, 
+							 SNDRV_DMA_TYPE_DEV, 
+							 snd_dma_pci_data(emu->pci), 
+							 64*1024, 64*1024)) < 0) /* FIXME: 32*1024 for sound buffer, between 32and64 for Periods table. */
+			return err;
+	}
+
+	for (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream; 
+	      substream; 
+	      substream = substream->next) {
+ 		if ((err = snd_pcm_lib_preallocate_pages(substream, 
+	                                           SNDRV_DMA_TYPE_DEV, 
+	                                           snd_dma_pci_data(emu->pci), 
+	                                           64*1024, 64*1024)) < 0)
+			return err;
+	}
+  
+	if (rpcm)
+		*rpcm = pcm;
+  
+	return 0;
+}
+
+static int __devinit snd_ca0106_create(snd_card_t *card,
+					 struct pci_dev *pci,
+					 ca0106_t **rchip)
+{
+	ca0106_t *chip;
+	int err;
+	int ch;
+	static snd_device_ops_t ops = {
+		.dev_free = snd_ca0106_dev_free,
+	};
+  
+	*rchip = NULL;
+  
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	if (pci_set_dma_mask(pci, 0xffffffffUL) < 0 ||
+	    pci_set_consistent_dma_mask(pci, 0xffffffffUL) < 0) {
+		printk(KERN_ERR "error to set 32bit mask DMA\n");
+		pci_disable_device(pci);
+		return -ENXIO;
+	}
+  
+	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+  
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+
+	spin_lock_init(&chip->emu_lock);
+  
+	chip->port = pci_resource_start(pci, 0);
+	if ((chip->res_port = request_region(chip->port, 0x20,
+					     "snd_ca0106")) == NULL) { 
+		snd_ca0106_free(chip);
+		printk(KERN_ERR "cannot allocate the port\n");
+		return -EBUSY;
+	}
+
+	if (request_irq(pci->irq, snd_ca0106_interrupt,
+			SA_INTERRUPT|SA_SHIRQ, "snd_ca0106",
+			(void *)chip)) {
+		snd_ca0106_free(chip);
+		printk(KERN_ERR "cannot grab irq\n");
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+  
+ 	/* This stores the periods table. */ 
+	if(snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci), 1024, &chip->buffer) < 0) {
+		snd_ca0106_free(chip);
+		return -ENOMEM;
+	}
+
+	pci_set_master(pci);
+	/* read revision & serial */
+	pci_read_config_byte(pci, PCI_REVISION_ID, (char *)&chip->revision);
+	pci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);
+	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);
+#if 1
+	printk(KERN_INFO "Model %04x Rev %08x Serial %08x\n", chip->model,
+	       chip->revision, chip->serial);
+#endif
+
+	outl(0, chip->port + INTE);
+
+	/*
+	 *  Init to 0x02109204 :
+	 *  Clock accuracy    = 0     (1000ppm)
+	 *  Sample Rate       = 2     (48kHz)
+	 *  Audio Channel     = 1     (Left of 2)
+	 *  Source Number     = 0     (Unspecified)
+	 *  Generation Status = 1     (Original for Cat Code 12)
+	 *  Cat Code          = 12    (Digital Signal Mixer)
+	 *  Mode              = 0     (Mode 0)
+	 *  Emphasis          = 0     (None)
+	 *  CP                = 1     (Copyright unasserted)
+	 *  AN                = 0     (Audio data)
+	 *  P                 = 0     (Consumer)
+	 */
+	snd_ca0106_ptr_write(chip, SPCS0, 0,
+				chip->spdif_bits[0] =
+				SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+				SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |
+				SPCS_GENERATIONSTATUS | 0x00001200 |
+				0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);
+	/* Only SPCS1 has been tested */
+	snd_ca0106_ptr_write(chip, SPCS1, 0,
+				chip->spdif_bits[1] =
+				SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+				SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |
+				SPCS_GENERATIONSTATUS | 0x00001200 |
+				0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);
+	snd_ca0106_ptr_write(chip, SPCS2, 0,
+				chip->spdif_bits[2] =
+				SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+				SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |
+				SPCS_GENERATIONSTATUS | 0x00001200 |
+				0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);
+	snd_ca0106_ptr_write(chip, SPCS3, 0,
+				chip->spdif_bits[3] =
+				SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+				SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |
+				SPCS_GENERATIONSTATUS | 0x00001200 |
+				0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);
+
+        snd_ca0106_ptr_write(chip, PLAYBACK_MUTE, 0, 0x00fc0000);
+        snd_ca0106_ptr_write(chip, CAPTURE_MUTE, 0, 0x00fc0000);
+
+        /* Write 0x8000 to AC97_REC_GAIN to mute it. */
+        outb(AC97_REC_GAIN, chip->port + AC97ADDRESS);
+        outw(0x8000, chip->port + AC97DATA);
+#if 0
+	snd_ca0106_ptr_write(chip, SPCS0, 0, 0x2108006);
+	snd_ca0106_ptr_write(chip, 0x42, 0, 0x2108006);
+	snd_ca0106_ptr_write(chip, 0x43, 0, 0x2108006);
+	snd_ca0106_ptr_write(chip, 0x44, 0, 0x2108006);
+#endif
+
+	//snd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0xf0f003f); /* OSS drivers set this. */
+	/* Analog or Digital output */
+	snd_ca0106_ptr_write(chip, SPDIF_SELECT1, 0, 0xf);
+	snd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0x000b0000); /* 0x0b000000 for digital, 0x000b0000 for analog, from win2000 drivers */
+	chip->spdif_enable = 0; /* Set digital SPDIF output off */
+	chip->capture_source = 3; /* Set CAPTURE_SOURCE */
+	//snd_ca0106_ptr_write(chip, 0x45, 0, 0); /* Analogue out */
+	//snd_ca0106_ptr_write(chip, 0x45, 0, 0xf00); /* Digital out */
+
+	snd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 0, 0x40c81000); /* goes to 0x40c80000 when doing SPDIF IN/OUT */
+	snd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 1, 0xffffffff); /* (Mute) CAPTURE feedback into PLAYBACK volume. Only lower 16 bits matter. */
+	snd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 2, 0x30300000); /* SPDIF IN Volume */
+	snd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 3, 0x00700000); /* SPDIF IN Volume, 0x70 = (vol & 0x3f) | 0x40 */
+	snd_ca0106_ptr_write(chip, PLAYBACK_ROUTING1, 0, 0x32765410);
+	snd_ca0106_ptr_write(chip, PLAYBACK_ROUTING2, 0, 0x76767676);
+	snd_ca0106_ptr_write(chip, CAPTURE_ROUTING1, 0, 0x32765410);
+	snd_ca0106_ptr_write(chip, CAPTURE_ROUTING2, 0, 0x76767676);
+	for(ch = 0; ch < 4; ch++) {
+		snd_ca0106_ptr_write(chip, CAPTURE_VOLUME1, ch, 0x30303030); /* Only high 16 bits matter */
+		snd_ca0106_ptr_write(chip, CAPTURE_VOLUME2, ch, 0x30303030);
+		//snd_ca0106_ptr_write(chip, PLAYBACK_VOLUME1, ch, 0x40404040); /* Mute */
+		//snd_ca0106_ptr_write(chip, PLAYBACK_VOLUME2, ch, 0x40404040); /* Mute */
+		snd_ca0106_ptr_write(chip, PLAYBACK_VOLUME1, ch, 0xffffffff); /* Mute */
+		snd_ca0106_ptr_write(chip, PLAYBACK_VOLUME2, ch, 0xffffffff); /* Mute */
+	}
+        snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4); /* Select MIC, Line in, TAD in, AUX in */
+	chip->capture_source = 3; /* Set CAPTURE_SOURCE */
+
+        if ((chip->serial == 0x10061102) || (chip->serial == 0x10071102) ) { /* The SB0410 and SB0413 use GPIO differently. */
+		/* FIXME: Still need to find out what the other GPIO bits do. E.g. For digital spdif out. */
+		outl(0x0, chip->port+GPIO);
+		//outl(0x00f0e000, chip->port+GPIO); /* Analog */
+		outl(0x005f4300, chip->port+GPIO); /* Analog */
+	} else {
+		outl(0x0, chip->port+GPIO);
+		outl(0x005f03a3, chip->port+GPIO); /* Analog */
+		//outl(0x005f02a2, chip->port+GPIO);   /* SPDIF */
+	}
+	snd_ca0106_intr_enable(chip, 0x105); /* Win2000 uses 0x1e0 */
+
+	//outl(HCFG_LOCKSOUNDCACHE|HCFG_AUDIOENABLE, chip->port+HCFG);
+	//outl(0x00001409, chip->port+HCFG); /* 0x1000 causes AC3 to fails. Maybe it effects 24 bit output. */
+	//outl(0x00000009, chip->port+HCFG);
+	outl(HCFG_AC97 | HCFG_AUDIOENABLE, chip->port+HCFG); /* AC97 2.0, Enable outputs. */
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
+				  chip, &ops)) < 0) {
+		snd_ca0106_free(chip);
+		return err;
+	}
+	*rchip = chip;
+	return 0;
+}
+
+static int __devinit snd_ca0106_probe(struct pci_dev *pci,
+					const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	ca0106_t *chip;
+	ca0106_names_t *c;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	if ((err = snd_ca0106_create(card, pci, &chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_ca0106_pcm(chip, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_ca0106_pcm(chip, 1, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_ca0106_pcm(chip, 2, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_ca0106_pcm(chip, 3, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+        if ((chip->serial != 0x10061102) && (chip->serial != 0x10071102) ) { /* The SB0410 and SB0413 do not have an ac97 chip. */
+		if ((err = snd_ca0106_ac97(chip)) < 0) {
+			snd_card_free(card);
+			return err;
+		}
+	}
+	if ((err = snd_ca0106_mixer(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	snd_ca0106_proc_init(chip);
+
+	strcpy(card->driver, "CA0106");
+	strcpy(card->shortname, "CA0106");
+
+	for (c=ca0106_chip_names; c->serial; c++) {
+		if (c->serial == chip->serial) break;
+	}
+	sprintf(card->longname, "%s at 0x%lx irq %i",
+		c->name, chip->port, chip->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_ca0106_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+// PCI IDs
+static struct pci_device_id snd_ca0106_ids[] = {
+	{ 0x1102, 0x0007, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* Audigy LS or Live 24bit */
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, snd_ca0106_ids);
+
+// pci_driver definition
+static struct pci_driver driver = {
+	.name = "CA0106",
+	.id_table = snd_ca0106_ids,
+	.probe = snd_ca0106_probe,
+	.remove = __devexit_p(snd_ca0106_remove),
+};
+
+// initialization of the module
+static int __init alsa_card_ca0106_init(void)
+{
+	int err;
+
+	if ((err = pci_module_init(&driver)) > 0)
+		return err;
+
+	return 0;
+}
+
+// clean up the module
+static void __exit alsa_card_ca0106_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_ca0106_init)
+module_exit(alsa_card_ca0106_exit)
diff -uNr a/sound/pci/ca0106/ca0106_mixer.c b/sound/pci/ca0106/ca0106_mixer.c
--- a/sound/pci/ca0106/ca0106_mixer.c	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/pci/ca0106/ca0106_mixer.c	2005-01-14 22:28:25.673455472 +0100
@@ -0,0 +1,634 @@
+/*
+ *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
+ *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
+ *  Version: 0.0.16
+ *
+ *  FEATURES currently supported:
+ *    See ca0106_main.c for features.
+ * 
+ *  Changelog:
+ *    Support interrupts per period.
+ *    Removed noise from Center/LFE channel when in Analog mode.
+ *    Rename and remove mixer controls.
+ *  0.0.6
+ *    Use separate card based DMA buffer for periods table list.
+ *  0.0.7
+ *    Change remove and rename ctrls into lists.
+ *  0.0.8
+ *    Try to fix capture sources.
+ *  0.0.9
+ *    Fix AC3 output.
+ *    Enable S32_LE format support.
+ *  0.0.10
+ *    Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)
+ *  0.0.11
+ *    Add Model name recognition.
+ *  0.0.12
+ *    Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.
+ *    Remove redundent "voice" handling.
+ *  0.0.13
+ *    Single trigger call for multi channels.
+ *  0.0.14
+ *    Set limits based on what the sound card hardware can do.
+ *    playback periods_min=2, periods_max=8
+ *    capture hw constraints require period_size = n * 64 bytes.
+ *    playback hw constraints require period_size = n * 64 bytes.
+ *  0.0.15
+ *    Separated ca0106.c into separate functional .c files.
+ *  0.0.16
+ *    Modified Copyright message.
+ *
+ *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/info.h>
+
+#include "ca0106.h"
+
+static int snd_ca0106_shared_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_ca0106_shared_spdif_get(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = emu->spdif_enable;
+	return 0;
+}
+
+static int snd_ca0106_shared_spdif_put(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change = 0;
+	u32 mask;
+
+	val = ucontrol->value.enumerated.item[0] ;
+	change = (emu->spdif_enable != val);
+	if (change) {
+		emu->spdif_enable = val;
+		if (val == 1) {
+			/* Digital */
+			snd_ca0106_ptr_write(emu, SPDIF_SELECT1, 0, 0xf);
+			snd_ca0106_ptr_write(emu, SPDIF_SELECT2, 0, 0x0b000000);
+			snd_ca0106_ptr_write(emu, CAPTURE_CONTROL, 0,
+				snd_ca0106_ptr_read(emu, CAPTURE_CONTROL, 0) & ~0x1000);
+			mask = inl(emu->port + GPIO) & ~0x101;
+			outl(mask, emu->port + GPIO);
+
+		} else {
+			/* Analog */
+			snd_ca0106_ptr_write(emu, SPDIF_SELECT1, 0, 0xf);
+			snd_ca0106_ptr_write(emu, SPDIF_SELECT2, 0, 0x000b0000);
+			snd_ca0106_ptr_write(emu, CAPTURE_CONTROL, 0,
+				snd_ca0106_ptr_read(emu, CAPTURE_CONTROL, 0) | 0x1000);
+			mask = inl(emu->port + GPIO) | 0x101;
+			outl(mask, emu->port + GPIO);
+		}
+	}
+        return change;
+}
+
+static snd_kcontrol_new_t snd_ca0106_shared_spdif __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"SPDIF Out",
+	.info =		snd_ca0106_shared_spdif_info,
+	.get =		snd_ca0106_shared_spdif_get,
+	.put =		snd_ca0106_shared_spdif_put
+};
+
+static int snd_ca0106_capture_source_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[6] = { "SPDIF out", "i2s mixer out", "SPDIF in", "i2s in", "AC97 in", "SRC out" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 6;
+	if (uinfo->value.enumerated.item > 5)
+                uinfo->value.enumerated.item = 5;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_ca0106_capture_source_get(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = emu->capture_source;
+	return 0;
+}
+
+static int snd_ca0106_capture_source_put(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change = 0;
+	u32 mask;
+	u32 source;
+
+	val = ucontrol->value.enumerated.item[0] ;
+	change = (emu->capture_source != val);
+	if (change) {
+		emu->capture_source = val;
+		source = (val << 28) | (val << 24) | (val << 20) | (val << 16);
+		mask = snd_ca0106_ptr_read(emu, CAPTURE_SOURCE, 0) & 0xffff;
+		snd_ca0106_ptr_write(emu, CAPTURE_SOURCE, 0, source | mask);
+	}
+        return change;
+}
+
+static snd_kcontrol_new_t snd_ca0106_capture_source __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Capture Source",
+	.info =		snd_ca0106_capture_source_info,
+	.get =		snd_ca0106_capture_source_get,
+	.put =		snd_ca0106_capture_source_put
+};
+
+static int snd_ca0106_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_ca0106_spdif_get(snd_kcontrol_t * kcontrol,
+                                 snd_ctl_elem_value_t * ucontrol)
+{
+	ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+
+	ucontrol->value.iec958.status[0] = (emu->spdif_bits[idx] >> 0) & 0xff;
+	ucontrol->value.iec958.status[1] = (emu->spdif_bits[idx] >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (emu->spdif_bits[idx] >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (emu->spdif_bits[idx] >> 24) & 0xff;
+        return 0;
+}
+
+static int snd_ca0106_spdif_get_mask(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = 0xff;
+	ucontrol->value.iec958.status[1] = 0xff;
+	ucontrol->value.iec958.status[2] = 0xff;
+	ucontrol->value.iec958.status[3] = 0xff;
+        return 0;
+}
+
+static int snd_ca0106_spdif_put(snd_kcontrol_t * kcontrol,
+                                 snd_ctl_elem_value_t * ucontrol)
+{
+	ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	int change;
+	unsigned int val;
+
+	val = (ucontrol->value.iec958.status[0] << 0) |
+	      (ucontrol->value.iec958.status[1] << 8) |
+	      (ucontrol->value.iec958.status[2] << 16) |
+	      (ucontrol->value.iec958.status[3] << 24);
+	change = val != emu->spdif_bits[idx];
+	if (change) {
+		snd_ca0106_ptr_write(emu, SPCS0 + idx, 0, val);
+		emu->spdif_bits[idx] = val;
+	}
+        return change;
+}
+
+static snd_kcontrol_new_t snd_ca0106_spdif_mask_control =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+	.count =	4,
+        .info =         snd_ca0106_spdif_info,
+        .get =          snd_ca0106_spdif_get_mask
+};
+
+static snd_kcontrol_new_t snd_ca0106_spdif_control =
+{
+        .iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.count =	4,
+        .info =         snd_ca0106_spdif_info,
+        .get =          snd_ca0106_spdif_get,
+        .put =          snd_ca0106_spdif_put
+};
+
+static int snd_ca0106_volume_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+        uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+        uinfo->count = 2;
+        uinfo->value.integer.min = 0;
+        uinfo->value.integer.max = 255;
+        return 0;
+}
+
+static int snd_ca0106_volume_get(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol, int reg, int channel_id)
+{
+        ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+        unsigned int value;
+
+        value = snd_ca0106_ptr_read(emu, reg, channel_id);
+        ucontrol->value.integer.value[0] = 0xff - ((value >> 24) & 0xff); /* Left */
+        ucontrol->value.integer.value[1] = 0xff - ((value >> 16) & 0xff); /* Right */
+        return 0;
+}
+
+static int snd_ca0106_volume_get_spdif_front(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_FRONT_CHANNEL;
+	int reg = PLAYBACK_VOLUME1;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+
+static int snd_ca0106_volume_get_spdif_center_lfe(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_CENTER_LFE_CHANNEL;
+	int reg = PLAYBACK_VOLUME1;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_get_spdif_unknown(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_UNKNOWN_CHANNEL;
+	int reg = PLAYBACK_VOLUME1;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_get_spdif_rear(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_REAR_CHANNEL;
+	int reg = PLAYBACK_VOLUME1;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_get_analog_front(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_FRONT_CHANNEL;
+	int reg = PLAYBACK_VOLUME2;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+
+static int snd_ca0106_volume_get_analog_center_lfe(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_CENTER_LFE_CHANNEL;
+	int reg = PLAYBACK_VOLUME2;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_get_analog_unknown(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_UNKNOWN_CHANNEL;
+	int reg = PLAYBACK_VOLUME2;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_get_analog_rear(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_REAR_CHANNEL;
+	int reg = PLAYBACK_VOLUME2;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+
+static int snd_ca0106_volume_get_feedback(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = 1;
+	int reg = CAPTURE_CONTROL;
+        return snd_ca0106_volume_get(kcontrol, ucontrol, reg, channel_id);
+}
+                                                                                                                           
+static int snd_ca0106_volume_put(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol, int reg, int channel_id)
+{
+        ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+        unsigned int value;
+        //value = snd_ca0106_ptr_read(emu, reg, channel_id);
+        //value = value & 0xffff;
+        value = ((0xff - ucontrol->value.integer.value[0]) << 24) | ((0xff - ucontrol->value.integer.value[1]) << 16);
+        value = value | ((0xff - ucontrol->value.integer.value[0]) << 8) | ((0xff - ucontrol->value.integer.value[1]) );
+        snd_ca0106_ptr_write(emu, reg, channel_id, value);
+        return 1;
+}
+static int snd_ca0106_volume_put_spdif_front(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_FRONT_CHANNEL;
+	int reg = PLAYBACK_VOLUME1;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_put_spdif_center_lfe(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_CENTER_LFE_CHANNEL;
+	int reg = PLAYBACK_VOLUME1;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_put_spdif_unknown(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_UNKNOWN_CHANNEL;
+	int reg = PLAYBACK_VOLUME1;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_put_spdif_rear(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_REAR_CHANNEL;
+	int reg = PLAYBACK_VOLUME1;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_put_analog_front(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_FRONT_CHANNEL;
+	int reg = PLAYBACK_VOLUME2;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_put_analog_center_lfe(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_CENTER_LFE_CHANNEL;
+	int reg = PLAYBACK_VOLUME2;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_put_analog_unknown(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_UNKNOWN_CHANNEL;
+	int reg = PLAYBACK_VOLUME2;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+static int snd_ca0106_volume_put_analog_rear(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = CONTROL_REAR_CHANNEL;
+	int reg = PLAYBACK_VOLUME2;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+
+static int snd_ca0106_volume_put_feedback(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+	int channel_id = 1;
+	int reg = CAPTURE_CONTROL;
+        return snd_ca0106_volume_put(kcontrol, ucontrol, reg, channel_id);
+}
+
+static snd_kcontrol_new_t snd_ca0106_volume_control_analog_front =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "Analog Front Volume",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_analog_front,
+        .put =          snd_ca0106_volume_put_analog_front
+};
+static snd_kcontrol_new_t snd_ca0106_volume_control_analog_center_lfe =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "Analog Center/LFE Volume",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_analog_center_lfe,
+        .put =          snd_ca0106_volume_put_analog_center_lfe
+};
+static snd_kcontrol_new_t snd_ca0106_volume_control_analog_unknown =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "Analog Unknown Volume",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_analog_unknown,
+        .put =          snd_ca0106_volume_put_analog_unknown
+};
+static snd_kcontrol_new_t snd_ca0106_volume_control_analog_rear =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "Analog Rear Volume",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_analog_rear,
+        .put =          snd_ca0106_volume_put_analog_rear
+};
+static snd_kcontrol_new_t snd_ca0106_volume_control_spdif_front =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "SPDIF Front Volume",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_spdif_front,
+        .put =          snd_ca0106_volume_put_spdif_front
+};
+static snd_kcontrol_new_t snd_ca0106_volume_control_spdif_center_lfe =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "SPDIF Center/LFE Volume",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_spdif_center_lfe,
+        .put =          snd_ca0106_volume_put_spdif_center_lfe
+};
+static snd_kcontrol_new_t snd_ca0106_volume_control_spdif_unknown =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "SPDIF Unknown Volume",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_spdif_unknown,
+        .put =          snd_ca0106_volume_put_spdif_unknown
+};
+static snd_kcontrol_new_t snd_ca0106_volume_control_spdif_rear =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "SPDIF Rear Volume",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_spdif_rear,
+        .put =          snd_ca0106_volume_put_spdif_rear
+};
+
+static snd_kcontrol_new_t snd_ca0106_volume_control_feedback =
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name =         "CAPTURE feedback into PLAYBACK",
+        .info =         snd_ca0106_volume_info,
+        .get =          snd_ca0106_volume_get_feedback,
+        .put =          snd_ca0106_volume_put_feedback
+};
+
+
+static int remove_ctl(snd_card_t *card, const char *name)
+{
+	snd_ctl_elem_id_t id;
+	memset(&id, 0, sizeof(id));
+	strcpy(id.name, name);
+	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	return snd_ctl_remove_id(card, &id);
+}
+
+static snd_kcontrol_t *ctl_find(snd_card_t *card, const char *name)
+{
+	snd_ctl_elem_id_t sid;
+	memset(&sid, 0, sizeof(sid));
+	/* FIXME: strcpy is bad. */
+	strcpy(sid.name, name);
+	sid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	return snd_ctl_find_id(card, &sid);
+}
+
+static int rename_ctl(snd_card_t *card, const char *src, const char *dst)
+{
+	snd_kcontrol_t *kctl = ctl_find(card, src);
+	if (kctl) {
+		strcpy(kctl->id.name, dst);
+		return 0;
+	}
+	return -ENOENT;
+}
+
+int __devinit snd_ca0106_mixer(ca0106_t *emu)
+{
+        int err;
+        snd_kcontrol_t *kctl;
+        snd_card_t *card = emu->card;
+	char **c;
+	static char *ca0106_remove_ctls[] = {
+		"Master Mono Playback Switch",
+		"Master Mono Playback Volume",
+		"3D Control - Switch",
+		"3D Control Sigmatel - Depth",
+		"PCM Playback Switch",
+		"PCM Playback Volume",
+		"CD Playback Switch",
+		"CD Playback Volume",
+		"Phone Playback Switch",
+		"Phone Playback Volume",
+		"Video Playback Switch",
+		"Video Playback Volume",
+		"PC Speaker Playback Switch",
+		"PC Speaker Playback Volume",
+		"Mono Output Select",
+		"Capture Source",
+		"Capture Switch",
+		"Capture Volume",
+		"External Amplifier",
+		"Sigmatel 4-Speaker Stereo Playback Switch",
+		"Sigmatel Surround Phase Inversion Playback ",
+		NULL
+	};
+	static char *ca0106_rename_ctls[] = {
+		"Master Playback Switch", "Capture Switch",
+		"Master Playback Volume", "Capture Volume",
+		"Line Playback Switch", "AC97 Line Capture Switch",
+		"Line Playback Volume", "AC97 Line Capture Volume",
+		"Aux Playback Switch", "AC97 Aux Capture Switch",
+		"Aux Playback Volume", "AC97 Aux Capture Volume",
+		"Mic Playback Switch", "AC97 Mic Capture Switch",
+		"Mic Playback Volume", "AC97 Mic Capture Volume",
+		"Mic Select", "AC97 Mic Select",
+		"Mic Boost (+20dB)", "AC97 Mic Boost (+20dB)",
+		NULL
+	};
+#if 1
+	for (c=ca0106_remove_ctls; *c; c++)
+		remove_ctl(card, *c);
+	for (c=ca0106_rename_ctls; *c; c += 2)
+		rename_ctl(card, c[0], c[1]);
+#endif
+
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_analog_front, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_analog_rear, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_analog_center_lfe, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_analog_unknown, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_spdif_front, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_spdif_rear, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_spdif_center_lfe, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_spdif_unknown, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+        if ((kctl = snd_ctl_new1(&snd_ca0106_volume_control_feedback, emu)) == NULL)
+                return -ENOMEM;
+        if ((err = snd_ctl_add(card, kctl)))
+                return err;
+	if ((kctl = snd_ctl_new1(&snd_ca0106_spdif_mask_control, emu)) == NULL)
+		return -ENOMEM;
+	if ((err = snd_ctl_add(card, kctl)))
+		return err;
+	if ((kctl = snd_ctl_new1(&snd_ca0106_shared_spdif, emu)) == NULL)
+		return -ENOMEM;
+	if ((err = snd_ctl_add(card, kctl)))
+		return err;
+	if ((kctl = snd_ctl_new1(&snd_ca0106_capture_source, emu)) == NULL)
+		return -ENOMEM;
+	if ((err = snd_ctl_add(card, kctl)))
+		return err;
+	if ((kctl = ctl_find(card, SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT))) != NULL) {
+		/* already defined by ac97, remove it */
+		/* FIXME: or do we need both controls? */
+		remove_ctl(card, SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT));
+	}
+	if ((kctl = snd_ctl_new1(&snd_ca0106_spdif_control, emu)) == NULL)
+		return -ENOMEM;
+	if ((err = snd_ctl_add(card, kctl)))
+		return err;
+        return 0;
+}
+
diff -uNr a/sound/pci/ca0106/ca0106_proc.c b/sound/pci/ca0106/ca0106_proc.c
--- a/sound/pci/ca0106/ca0106_proc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/pci/ca0106/ca0106_proc.c	2005-01-14 22:28:25.677454864 +0100
@@ -0,0 +1,436 @@
+/*
+ *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
+ *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
+ *  Version: 0.0.17
+ *
+ *  FEATURES currently supported:
+ *    See ca0106_main.c for features.
+ * 
+ *  Changelog:
+ *    Support interrupts per period.
+ *    Removed noise from Center/LFE channel when in Analog mode.
+ *    Rename and remove mixer controls.
+ *  0.0.6
+ *    Use separate card based DMA buffer for periods table list.
+ *  0.0.7
+ *    Change remove and rename ctrls into lists.
+ *  0.0.8
+ *    Try to fix capture sources.
+ *  0.0.9
+ *    Fix AC3 output.
+ *    Enable S32_LE format support.
+ *  0.0.10
+ *    Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)
+ *  0.0.11
+ *    Add Model name recognition.
+ *  0.0.12
+ *    Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.
+ *    Remove redundent "voice" handling.
+ *  0.0.13
+ *    Single trigger call for multi channels.
+ *  0.0.14
+ *    Set limits based on what the sound card hardware can do.
+ *    playback periods_min=2, periods_max=8
+ *    capture hw constraints require period_size = n * 64 bytes.
+ *    playback hw constraints require period_size = n * 64 bytes.
+ *  0.0.15
+ *    Separate ca0106.c into separate functional .c files.
+ *  0.0.16
+ *    Modified Copyright message.
+ *  0.0.17
+ *    Add iec958 file in proc file system to show status of SPDIF in.
+ *    
+ *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/info.h>
+#include <sound/asoundef.h>
+
+#include "ca0106.h"
+
+
+struct snd_ca0106_category_str {
+	int val;
+	const char *name;
+};
+
+static struct snd_ca0106_category_str snd_ca0106_con_category[] = {
+	{ IEC958_AES1_CON_DAT, "DAT" },
+	{ IEC958_AES1_CON_VCR, "VCR" },
+	{ IEC958_AES1_CON_MICROPHONE, "microphone" },
+	{ IEC958_AES1_CON_SYNTHESIZER, "synthesizer" },
+	{ IEC958_AES1_CON_RATE_CONVERTER, "rate converter" },
+	{ IEC958_AES1_CON_MIXER, "mixer" },
+	{ IEC958_AES1_CON_SAMPLER, "sampler" },
+	{ IEC958_AES1_CON_PCM_CODER, "PCM coder" },
+	{ IEC958_AES1_CON_IEC908_CD, "CD" },
+	{ IEC958_AES1_CON_NON_IEC908_CD, "non-IEC908 CD" },
+	{ IEC958_AES1_CON_GENERAL, "general" },
+};
+
+
+void snd_ca0106_proc_dump_iec958( snd_info_buffer_t *buffer, u32 value)
+{
+	int i;
+	u32 status[4];
+	status[0] = value & 0xff;
+	status[1] = (value >> 8) & 0xff;
+	status[2] = (value >> 16)  & 0xff;
+	status[3] = (value >> 24)  & 0xff;
+	
+	if (! (status[0] & IEC958_AES0_PROFESSIONAL)) {
+		/* consumer */
+		snd_iprintf(buffer, "Mode: consumer\n");
+		snd_iprintf(buffer, "Data: ");
+		if (!(status[0] & IEC958_AES0_NONAUDIO)) {
+			snd_iprintf(buffer, "audio\n");
+		} else {
+			snd_iprintf(buffer, "non-audio\n");
+		}
+		snd_iprintf(buffer, "Rate: ");
+		switch (status[3] & IEC958_AES3_CON_FS) {
+		case IEC958_AES3_CON_FS_44100:
+			snd_iprintf(buffer, "44100 Hz\n");
+			break;
+		case IEC958_AES3_CON_FS_48000:
+			snd_iprintf(buffer, "48000 Hz\n");
+			break;
+		case IEC958_AES3_CON_FS_32000:
+			snd_iprintf(buffer, "32000 Hz\n");
+			break;
+		default:
+			snd_iprintf(buffer, "unknown\n");
+			break;
+		}
+		snd_iprintf(buffer, "Copyright: ");
+		if (status[0] & IEC958_AES0_CON_NOT_COPYRIGHT) {
+			snd_iprintf(buffer, "permitted\n");
+		} else {
+			snd_iprintf(buffer, "protected\n");
+		}
+		snd_iprintf(buffer, "Emphasis: ");
+		if ((status[0] & IEC958_AES0_CON_EMPHASIS) != IEC958_AES0_CON_EMPHASIS_5015) {
+			snd_iprintf(buffer, "none\n");
+		} else {
+			snd_iprintf(buffer, "50/15us\n");
+		}
+		snd_iprintf(buffer, "Category: ");
+		for (i = 0; i < ARRAY_SIZE(snd_ca0106_con_category); i++) {
+			if ((status[1] & IEC958_AES1_CON_CATEGORY) == snd_ca0106_con_category[i].val) {
+				snd_iprintf(buffer, "%s\n", snd_ca0106_con_category[i].name);
+				break;
+			}
+		}
+		if (i >= ARRAY_SIZE(snd_ca0106_con_category)) {
+			snd_iprintf(buffer, "unknown 0x%x\n", status[1] & IEC958_AES1_CON_CATEGORY);
+		}
+		snd_iprintf(buffer, "Original: ");
+		if (status[1] & IEC958_AES1_CON_ORIGINAL) {
+			snd_iprintf(buffer, "original\n");
+		} else {
+			snd_iprintf(buffer, "1st generation\n");
+		}
+		snd_iprintf(buffer, "Clock: ");
+		switch (status[3] & IEC958_AES3_CON_CLOCK) {
+		case IEC958_AES3_CON_CLOCK_1000PPM:
+			snd_iprintf(buffer, "1000 ppm\n");
+			break;
+		case IEC958_AES3_CON_CLOCK_50PPM:
+			snd_iprintf(buffer, "50 ppm\n");
+			break;
+		case IEC958_AES3_CON_CLOCK_VARIABLE:
+			snd_iprintf(buffer, "variable pitch\n");
+			break;
+		default:
+			snd_iprintf(buffer, "unknown\n");
+			break;
+		}
+	} else {
+		snd_iprintf(buffer, "Mode: professional\n");
+		snd_iprintf(buffer, "Data: ");
+		if (!(status[0] & IEC958_AES0_NONAUDIO)) {
+			snd_iprintf(buffer, "audio\n");
+		} else {
+			snd_iprintf(buffer, "non-audio\n");
+		}
+		snd_iprintf(buffer, "Rate: ");
+		switch (status[0] & IEC958_AES0_PRO_FS) {
+		case IEC958_AES0_PRO_FS_44100:
+			snd_iprintf(buffer, "44100 Hz\n");
+			break;
+		case IEC958_AES0_PRO_FS_48000:
+			snd_iprintf(buffer, "48000 Hz\n");
+			break;
+		case IEC958_AES0_PRO_FS_32000:
+			snd_iprintf(buffer, "32000 Hz\n");
+			break;
+		default:
+			snd_iprintf(buffer, "unknown\n");
+			break;
+		}
+		snd_iprintf(buffer, "Rate Locked: ");
+		if (status[0] & IEC958_AES0_PRO_FREQ_UNLOCKED)
+			snd_iprintf(buffer, "no\n");
+		else
+			snd_iprintf(buffer, "yes\n");
+		snd_iprintf(buffer, "Emphasis: ");
+		switch (status[0] & IEC958_AES0_PRO_EMPHASIS) {
+		case IEC958_AES0_PRO_EMPHASIS_CCITT:
+			snd_iprintf(buffer, "CCITT J.17\n");
+			break;
+		case IEC958_AES0_PRO_EMPHASIS_NONE:
+			snd_iprintf(buffer, "none\n");
+			break;
+		case IEC958_AES0_PRO_EMPHASIS_5015:
+			snd_iprintf(buffer, "50/15us\n");
+			break;
+		case IEC958_AES0_PRO_EMPHASIS_NOTID:
+		default:
+			snd_iprintf(buffer, "unknown\n");
+			break;
+		}
+		snd_iprintf(buffer, "Stereophonic: ");
+		if ((status[1] & IEC958_AES1_PRO_MODE) == IEC958_AES1_PRO_MODE_STEREOPHONIC) {
+			snd_iprintf(buffer, "stereo\n");
+		} else {
+			snd_iprintf(buffer, "not indicated\n");
+		}
+		snd_iprintf(buffer, "Userbits: ");
+		switch (status[1] & IEC958_AES1_PRO_USERBITS) {
+		case IEC958_AES1_PRO_USERBITS_192:
+			snd_iprintf(buffer, "192bit\n");
+			break;
+		case IEC958_AES1_PRO_USERBITS_UDEF:
+			snd_iprintf(buffer, "user-defined\n");
+			break;
+		default:
+			snd_iprintf(buffer, "unkown\n");
+			break;
+		}
+		snd_iprintf(buffer, "Sample Bits: ");
+		switch (status[2] & IEC958_AES2_PRO_SBITS) {
+		case IEC958_AES2_PRO_SBITS_20:
+			snd_iprintf(buffer, "20 bit\n");
+			break;
+		case IEC958_AES2_PRO_SBITS_24:
+			snd_iprintf(buffer, "24 bit\n");
+			break;
+		case IEC958_AES2_PRO_SBITS_UDEF:
+			snd_iprintf(buffer, "user defined\n");
+			break;
+		default:
+			snd_iprintf(buffer, "unknown\n");
+			break;
+		}
+		snd_iprintf(buffer, "Word Length: ");
+		switch (status[2] & IEC958_AES2_PRO_WORDLEN) {
+		case IEC958_AES2_PRO_WORDLEN_22_18:
+			snd_iprintf(buffer, "22 bit or 18 bit\n");
+			break;
+		case IEC958_AES2_PRO_WORDLEN_23_19:
+			snd_iprintf(buffer, "23 bit or 19 bit\n");
+			break;
+		case IEC958_AES2_PRO_WORDLEN_24_20:
+			snd_iprintf(buffer, "24 bit or 20 bit\n");
+			break;
+		case IEC958_AES2_PRO_WORDLEN_20_16:
+			snd_iprintf(buffer, "20 bit or 16 bit\n");
+			break;
+		default:
+			snd_iprintf(buffer, "unknown\n");
+			break;
+		}
+	}
+}
+
+static void snd_ca0106_proc_iec958(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+	u32 value;
+
+        value = snd_ca0106_ptr_read(emu, SAMPLE_RATE_TRACKER_STATUS, 0);
+	snd_iprintf(buffer, "Status: %s, %s, %s\n",
+		  (value & 0x100000) ? "Rate Locked" : "Not Rate Locked",
+		  (value & 0x200000) ? "SPDIF Locked" : "No SPDIF Lock",
+		  (value & 0x400000) ? "Audio Valid" : "No valid audio" );
+	snd_iprintf(buffer, "Estimated sample rate: %u\n", 
+		  ((value & 0xfffff) * 48000) / 0x8000 );
+	if (value & 0x200000) {
+		snd_iprintf(buffer, "IEC958/SPDIF input status:\n");
+        	value = snd_ca0106_ptr_read(emu, SPDIF_INPUT_STATUS, 0);
+		snd_ca0106_proc_dump_iec958(buffer, value);
+	}
+
+	snd_iprintf(buffer, "\n");
+}
+
+static void snd_ca0106_proc_reg_write32(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+	unsigned long flags;
+        char line[64];
+        u32 reg, val;
+        while (!snd_info_get_line(buffer, line, sizeof(line))) {
+                if (sscanf(line, "%x %x", &reg, &val) != 2)
+                        continue;
+                if ((reg < 0x40) && (reg >=0) && (val <= 0xffffffff) ) {
+			spin_lock_irqsave(&emu->emu_lock, flags);
+			outl(val, emu->port + (reg & 0xfffffffc));
+			spin_unlock_irqrestore(&emu->emu_lock, flags);
+		}
+        }
+}
+
+static void snd_ca0106_proc_reg_read32(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+	unsigned long value;
+	unsigned long flags;
+	int i;
+	snd_iprintf(buffer, "Registers:\n\n");
+	for(i = 0; i < 0x20; i+=4) {
+		spin_lock_irqsave(&emu->emu_lock, flags);
+		value = inl(emu->port + i);
+		spin_unlock_irqrestore(&emu->emu_lock, flags);
+		snd_iprintf(buffer, "Register %02X: %08lX\n", i, value);
+	}
+}
+
+static void snd_ca0106_proc_reg_read16(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+        unsigned int value;
+	unsigned long flags;
+	int i;
+	snd_iprintf(buffer, "Registers:\n\n");
+	for(i = 0; i < 0x20; i+=2) {
+		spin_lock_irqsave(&emu->emu_lock, flags);
+		value = inw(emu->port + i);
+		spin_unlock_irqrestore(&emu->emu_lock, flags);
+		snd_iprintf(buffer, "Register %02X: %04X\n", i, value);
+	}
+}
+
+static void snd_ca0106_proc_reg_read8(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+	unsigned int value;
+	unsigned long flags;
+	int i;
+	snd_iprintf(buffer, "Registers:\n\n");
+	for(i = 0; i < 0x20; i+=1) {
+		spin_lock_irqsave(&emu->emu_lock, flags);
+		value = inb(emu->port + i);
+		spin_unlock_irqrestore(&emu->emu_lock, flags);
+		snd_iprintf(buffer, "Register %02X: %02X\n", i, value);
+	}
+}
+
+static void snd_ca0106_proc_reg_read1(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+	unsigned long value;
+	int i,j;
+
+	snd_iprintf(buffer, "Registers\n");
+	for(i = 0; i < 0x40; i++) {
+		snd_iprintf(buffer, "%02X: ",i);
+		for (j = 0; j < 4; j++) {
+                  value = snd_ca0106_ptr_read(emu, i, j);
+		  snd_iprintf(buffer, "%08lX ", value);
+                }
+	        snd_iprintf(buffer, "\n");
+	}
+}
+
+static void snd_ca0106_proc_reg_read2(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+	unsigned long value;
+	int i,j;
+
+	snd_iprintf(buffer, "Registers\n");
+	for(i = 0x40; i < 0x80; i++) {
+		snd_iprintf(buffer, "%02X: ",i);
+		for (j = 0; j < 4; j++) {
+                  value = snd_ca0106_ptr_read(emu, i, j);
+		  snd_iprintf(buffer, "%08lX ", value);
+                }
+	        snd_iprintf(buffer, "\n");
+	}
+}
+
+static void snd_ca0106_proc_reg_write(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+        char line[64];
+        unsigned int reg, channel_id , val;
+        while (!snd_info_get_line(buffer, line, sizeof(line))) {
+                if (sscanf(line, "%x %x %x", &reg, &channel_id, &val) != 3)
+                        continue;
+                if ((reg < 0x80) && (reg >=0) && (val <= 0xffffffff) && (channel_id >=0) && (channel_id <= 3) )
+                        snd_ca0106_ptr_write(emu, reg, channel_id, val);
+        }
+}
+
+
+int __devinit snd_ca0106_proc_init(ca0106_t * emu)
+{
+	snd_info_entry_t *entry;
+	
+	if(! snd_card_proc_new(emu->card, "iec958", &entry))
+		snd_info_set_text_ops(entry, emu, 1024, snd_ca0106_proc_iec958);
+	if(! snd_card_proc_new(emu->card, "ca0106_reg32", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_ca0106_proc_reg_read32);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_ca0106_proc_reg_write32;
+	}
+	if(! snd_card_proc_new(emu->card, "ca0106_reg16", &entry))
+		snd_info_set_text_ops(entry, emu, 1024, snd_ca0106_proc_reg_read16);
+	if(! snd_card_proc_new(emu->card, "ca0106_reg8", &entry))
+		snd_info_set_text_ops(entry, emu, 1024, snd_ca0106_proc_reg_read8);
+	if(! snd_card_proc_new(emu->card, "ca0106_regs1", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_ca0106_proc_reg_read1);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_ca0106_proc_reg_write;
+//		entry->private_data = emu;
+	}
+	if(! snd_card_proc_new(emu->card, "ca0106_regs2", &entry)) 
+		snd_info_set_text_ops(entry, emu, 1024, snd_ca0106_proc_reg_read2);
+	return 0;
+}
+
diff -uNr a/sound/pci/ca0106/Makefile b/sound/pci/ca0106/Makefile
--- a/sound/pci/ca0106/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/pci/ca0106/Makefile	2005-01-14 22:28:12.088520696 +0100
@@ -0,0 +1,3 @@
+snd-ca0106-objs := ca0106_main.o ca0106_proc.o ca0106_mixer.o
+
+obj-$(CONFIG_SND_CA0106) += snd-ca0106.o
diff -uNr a/sound/pci/cmipci.c b/sound/pci/cmipci.c
--- a/sound/pci/cmipci.c	2004-12-24 22:35:01.000000000 +0100
+++ b/sound/pci/cmipci.c	2005-01-14 22:28:12.097519328 +0100
@@ -2608,8 +2608,8 @@
 
 	if (request_irq(pci->irq, snd_cmipci_interrupt, SA_INTERRUPT|SA_SHIRQ, card->driver, (void *)cm)) {
 		snd_printk("unable to grab IRQ %d\n", pci->irq);
-		err = -EBUSY;
-		goto __error;
+		snd_cmipci_free(cm);
+		return -EBUSY;
 	}
 	cm->irq = pci->irq;
 
@@ -2662,6 +2662,11 @@
 		break;
 	}
 
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, cm, &ops)) < 0) {
+		snd_cmipci_free(cm);
+		return err;
+	}
+
 	/* set MPU address */
 	switch (iomidi) {
 	case 0x320: val = CM_VMPU_320; break;
@@ -2717,22 +2722,22 @@
 	/* create pcm devices */
 	pcm_index = pcm_spdif_index = 0;
 	if ((err = snd_cmipci_pcm_new(cm, pcm_index)) < 0)
-		goto __error;
+		return err;
 	pcm_index++;
 	if (cm->has_dual_dac) {
 		if ((err = snd_cmipci_pcm2_new(cm, pcm_index)) < 0)
-			goto __error;
+			return err;
 		pcm_index++;
 	}
 	if (cm->can_ac3_hw || cm->can_ac3_sw) {
 		pcm_spdif_index = pcm_index;
 		if ((err = snd_cmipci_pcm_spdif_new(cm, pcm_index)) < 0)
-			goto __error;
+			return err;
 	}
 
 	/* create mixer interface & switches */
 	if ((err = snd_cmipci_mixer_new(cm, pcm_spdif_index)) < 0)
-		goto __error;
+		return err;
 
 	if (iomidi > 0) {
 		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,
@@ -2742,10 +2747,6 @@
 		}
 	}
 
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, cm, &ops)) < 0) {
-		snd_cmipci_free(cm);
-		return err;
-	}
 #ifdef USE_VAR48KRATE
 	for (val = 0; val < ARRAY_SIZE(rates); val++)
 		snd_cmipci_set_pll(cm, rates[val], val);
@@ -2785,10 +2786,6 @@
 
 	*rcmipci = cm;
 	return 0;
-
- __error:
-	snd_cmipci_free(cm);
-	return err;
 }
 
 /*
diff -uNr a/sound/pci/cs4281.c b/sound/pci/cs4281.c
--- a/sound/pci/cs4281.c	2004-12-24 22:35:29.000000000 +0100
+++ b/sound/pci/cs4281.c	2005-01-14 22:28:12.102518568 +0100
@@ -1439,15 +1439,15 @@
 		return tmp;
 	}
 
-	snd_cs4281_proc_init(chip);
-
-	snd_card_set_pm_callback(card, cs4281_suspend, cs4281_resume, chip);
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_cs4281_free(chip);
 		return err;
 	}
 
+	snd_cs4281_proc_init(chip);
+
+	snd_card_set_pm_callback(card, cs4281_suspend, cs4281_resume, chip);
+
 	snd_card_set_dev(card, &pci->dev);
 
 	*rchip = chip;
@@ -2079,7 +2079,6 @@
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
 
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -2112,7 +2111,6 @@
 	ulCLK &= ~CLKCR1_CKRA;
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
diff -uNr a/sound/pci/cs46xx/cs46xx_lib.c b/sound/pci/cs46xx/cs46xx_lib.c
--- a/sound/pci/cs46xx/cs46xx_lib.c	2004-12-24 22:33:51.000000000 +0100
+++ b/sound/pci/cs46xx/cs46xx_lib.c	2005-01-14 22:28:12.117516288 +0100
@@ -68,6 +68,20 @@
 
 static void amp_voyetra(cs46xx_t *chip, int change);
 
+#ifdef CONFIG_SND_CS46XX_NEW_DSP
+static snd_pcm_ops_t snd_cs46xx_playback_rear_ops;
+static snd_pcm_ops_t snd_cs46xx_playback_indirect_rear_ops;
+static snd_pcm_ops_t snd_cs46xx_playback_clfe_ops;
+static snd_pcm_ops_t snd_cs46xx_playback_indirect_clfe_ops;
+static snd_pcm_ops_t snd_cs46xx_playback_iec958_ops;
+static snd_pcm_ops_t snd_cs46xx_playback_indirect_iec958_ops;
+#endif
+
+static snd_pcm_ops_t snd_cs46xx_playback_ops;
+static snd_pcm_ops_t snd_cs46xx_playback_indirect_ops;
+static snd_pcm_ops_t snd_cs46xx_capture_ops;
+static snd_pcm_ops_t snd_cs46xx_capture_indirect_ops;
+
 static unsigned short snd_cs46xx_codec_read(cs46xx_t *chip,
 					    unsigned short reg,
 					    int codec_index)
@@ -99,7 +113,7 @@
 	if ((tmp & ACCTL_VFRM) == 0) {
 		snd_printk(KERN_WARNING  "cs46xx: ACCTL_VFRM not set 0x%x\n",tmp);
 		snd_cs46xx_pokeBA0(chip, BA0_ACCTL, (tmp & (~ACCTL_ESYN)) | ACCTL_VFRM );
-		mdelay(50);
+		msleep(50);
 		tmp = snd_cs46xx_peekBA0(chip, BA0_ACCTL + offset);
 		snd_cs46xx_pokeBA0(chip, BA0_ACCTL, tmp | ACCTL_ESYN | ACCTL_VFRM );
 
@@ -1446,7 +1460,7 @@
 }
 
 #ifdef CONFIG_SND_CS46XX_NEW_DSP
-snd_pcm_ops_t snd_cs46xx_playback_rear_ops = {
+static snd_pcm_ops_t snd_cs46xx_playback_rear_ops = {
 	.open =			snd_cs46xx_playback_open_rear,
 	.close =		snd_cs46xx_playback_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1457,7 +1471,7 @@
 	.pointer =		snd_cs46xx_playback_direct_pointer,
 };
 
-snd_pcm_ops_t snd_cs46xx_playback_indirect_rear_ops = {
+static snd_pcm_ops_t snd_cs46xx_playback_indirect_rear_ops = {
 	.open =			snd_cs46xx_playback_open_rear,
 	.close =		snd_cs46xx_playback_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1469,7 +1483,7 @@
 	.ack =			snd_cs46xx_playback_transfer,
 };
 
-snd_pcm_ops_t snd_cs46xx_playback_clfe_ops = {
+static snd_pcm_ops_t snd_cs46xx_playback_clfe_ops = {
 	.open =			snd_cs46xx_playback_open_clfe,
 	.close =		snd_cs46xx_playback_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1480,7 +1494,7 @@
 	.pointer =		snd_cs46xx_playback_direct_pointer,
 };
 
-snd_pcm_ops_t snd_cs46xx_playback_indirect_clfe_ops = {
+static snd_pcm_ops_t snd_cs46xx_playback_indirect_clfe_ops = {
 	.open =			snd_cs46xx_playback_open_clfe,
 	.close =		snd_cs46xx_playback_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1492,7 +1506,7 @@
 	.ack =			snd_cs46xx_playback_transfer,
 };
 
-snd_pcm_ops_t snd_cs46xx_playback_iec958_ops = {
+static snd_pcm_ops_t snd_cs46xx_playback_iec958_ops = {
 	.open =			snd_cs46xx_playback_open_iec958,
 	.close =		snd_cs46xx_playback_close_iec958,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1503,7 +1517,7 @@
 	.pointer =		snd_cs46xx_playback_direct_pointer,
 };
 
-snd_pcm_ops_t snd_cs46xx_playback_indirect_iec958_ops = {
+static snd_pcm_ops_t snd_cs46xx_playback_indirect_iec958_ops = {
 	.open =			snd_cs46xx_playback_open_iec958,
 	.close =		snd_cs46xx_playback_close_iec958,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1517,7 +1531,7 @@
 
 #endif
 
-snd_pcm_ops_t snd_cs46xx_playback_ops = {
+static snd_pcm_ops_t snd_cs46xx_playback_ops = {
 	.open =			snd_cs46xx_playback_open,
 	.close =		snd_cs46xx_playback_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1528,7 +1542,7 @@
 	.pointer =		snd_cs46xx_playback_direct_pointer,
 };
 
-snd_pcm_ops_t snd_cs46xx_playback_indirect_ops = {
+static snd_pcm_ops_t snd_cs46xx_playback_indirect_ops = {
 	.open =			snd_cs46xx_playback_open,
 	.close =		snd_cs46xx_playback_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1540,7 +1554,7 @@
 	.ack =			snd_cs46xx_playback_transfer,
 };
 
-snd_pcm_ops_t snd_cs46xx_capture_ops = {
+static snd_pcm_ops_t snd_cs46xx_capture_ops = {
 	.open =			snd_cs46xx_capture_open,
 	.close =		snd_cs46xx_capture_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -1551,7 +1565,7 @@
 	.pointer =		snd_cs46xx_capture_direct_pointer,
 };
 
-snd_pcm_ops_t snd_cs46xx_capture_indirect_ops = {
+static snd_pcm_ops_t snd_cs46xx_capture_indirect_ops = {
 	.open =			snd_cs46xx_capture_open,
 	.close =		snd_cs46xx_capture_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -2305,6 +2319,36 @@
 };
 
 #ifdef CONFIG_SND_CS46XX_NEW_DSP
+/* set primary cs4294 codec into Extended Audio Mode */
+static int snd_cs46xx_front_dup_get(snd_kcontrol_t *kcontrol, 
+				    snd_ctl_elem_value_t *ucontrol)
+{
+	cs46xx_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned short val;
+	val = snd_ac97_read(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX], AC97_CSR_ACMODE);
+	ucontrol->value.integer.value[0] = (val & 0x200) ? 0 : 1;
+	return 0;
+}
+
+static int snd_cs46xx_front_dup_put(snd_kcontrol_t *kcontrol, 
+				    snd_ctl_elem_value_t *ucontrol)
+{
+	cs46xx_t *chip = snd_kcontrol_chip(kcontrol);
+	return snd_ac97_update_bits(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX],
+				    AC97_CSR_ACMODE, 0x200,
+				    ucontrol->value.integer.value[0] ? 0 : 0x200);
+}
+
+static snd_kcontrol_new_t snd_cs46xx_front_dup_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Duplicate Front",
+	.info = snd_mixer_boolean_info,
+	.get = snd_cs46xx_front_dup_get,
+	.put = snd_cs46xx_front_dup_put,
+};
+#endif
+
+#ifdef CONFIG_SND_CS46XX_NEW_DSP
 /* Only available on the Hercules Game Theater XP soundcard */
 static snd_kcontrol_new_t snd_hercules_controls[] __devinitdata = {
 {
@@ -2451,10 +2495,11 @@
 	if (chip->nr_ac97_codecs == 1) {
 		unsigned int id2 = chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]->id & 0xffff;
 		if (id2 == 0x592b || id2 == 0x592d) {
-			/* set primary cs4294 codec into Extended Audio Mode */
-			snd_printdd("setting EAM bit on cs4294 CODEC\n");
-			snd_cs46xx_codec_write(chip, AC97_CSR_ACMODE, 0x200,
-					       CS46XX_PRIMARY_CODEC_INDEX);
+			err = snd_ctl_add(card, snd_ctl_new1(&snd_cs46xx_front_dup_ctl, chip));
+			if (err < 0)
+				return err;
+			snd_ac97_write_cache(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX],
+					     AC97_CSR_ACMODE, 0x200);
 		}
 	}
 	/* do soundcard specific mixer setup */
@@ -3680,7 +3725,6 @@
 	chip->active_ctrl(chip, -chip->amplifier);
 	chip->amplifier = amp_saved; /* restore the status */
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -3717,7 +3761,6 @@
 	else
 		chip->active_ctrl(chip, -1); /* disable CLKRUN */
 	chip->amplifier = amp_saved;
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -3866,15 +3909,15 @@
 		return err;
 	}
 
-	snd_cs46xx_proc_init(card, chip);
-
-	snd_card_set_pm_callback(card, snd_cs46xx_suspend, snd_cs46xx_resume, chip);
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_cs46xx_free(chip);
 		return err;
 	}
 	
+	snd_cs46xx_proc_init(card, chip);
+
+	snd_card_set_pm_callback(card, snd_cs46xx_suspend, snd_cs46xx_resume, chip);
+
 	chip->active_ctrl(chip, -1); /* disable CLKRUN */
 
 	snd_card_set_dev(card, &pci->dev);
diff -uNr a/sound/pci/cs46xx/cs46xx_lib.h b/sound/pci/cs46xx/cs46xx_lib.h
--- a/sound/pci/cs46xx/cs46xx_lib.h	2004-12-24 22:34:01.000000000 +0100
+++ b/sound/pci/cs46xx/cs46xx_lib.h	2005-01-14 22:28:12.120515832 +0100
@@ -53,18 +53,6 @@
 #define BA1_DWORD_SIZE		(13 * 1024 + 512)
 #define BA1_MEMORY_COUNT	3
 
-extern snd_pcm_ops_t snd_cs46xx_playback_ops;
-extern snd_pcm_ops_t snd_cs46xx_playback_indirect_ops;
-extern snd_pcm_ops_t snd_cs46xx_capture_ops;
-extern snd_pcm_ops_t snd_cs46xx_capture_indirect_ops;
-extern snd_pcm_ops_t snd_cs46xx_playback_rear_ops;
-extern snd_pcm_ops_t snd_cs46xx_playback_indirect_rear_ops;
-extern snd_pcm_ops_t snd_cs46xx_playback_iec958_ops;
-extern snd_pcm_ops_t snd_cs46xx_playback_indirect_iec958_ops;
-extern snd_pcm_ops_t snd_cs46xx_playback_clfe_ops;
-extern snd_pcm_ops_t snd_cs46xx_playback_indirect_clfe_ops;
-
-
 /*
  *  common I/O routines
  */
@@ -99,11 +87,9 @@
 void                   cs46xx_dsp_spos_destroy (cs46xx_t * chip);
 int                    cs46xx_dsp_load_module (cs46xx_t * chip,dsp_module_desc_t * module);
 symbol_entry_t *       cs46xx_dsp_lookup_symbol (cs46xx_t * chip,char * symbol_name,int symbol_type);
-symbol_entry_t *       cs46xx_dsp_lookup_symbol_addr (cs46xx_t * chip,u32 address,int symbol_type);
 int                    cs46xx_dsp_proc_init (snd_card_t * card, cs46xx_t *chip);
 int                    cs46xx_dsp_proc_done (cs46xx_t *chip);
 int                    cs46xx_dsp_scb_and_task_init (cs46xx_t *chip);
-int                    cs46xx_dsp_async_init (cs46xx_t *chip,dsp_scb_descriptor_t * fg_entry);
 int                    snd_cs46xx_download (cs46xx_t *chip,u32 *src,unsigned long offset,
                                             unsigned long len);
 int                    snd_cs46xx_clear_BA1(cs46xx_t *chip,unsigned long offset,unsigned long len);
@@ -120,8 +106,6 @@
 dsp_scb_descriptor_t * cs46xx_dsp_create_scb (cs46xx_t *chip,char * name, u32 * scb_data,u32 dest);
 void                   cs46xx_dsp_proc_free_scb_desc (dsp_scb_descriptor_t * scb);
 void                   cs46xx_dsp_proc_register_scb_desc (cs46xx_t *chip,dsp_scb_descriptor_t * scb);
-dsp_task_descriptor_t * cs46xx_dsp_create_task_tree (cs46xx_t *chip,char * name, 
-                                                     u32 * task_data,u32 dest,int size);
 dsp_scb_descriptor_t * cs46xx_dsp_create_timing_master_scb (cs46xx_t *chip);
 dsp_scb_descriptor_t * cs46xx_dsp_create_codec_out_scb(cs46xx_t * chip,char * codec_name,
                                                        u16 channel_disp,u16 fifo_addr,
@@ -136,21 +120,11 @@
                                                       dsp_scb_descriptor_t * parent_scb,
                                                       int scb_child_type);
 void                   cs46xx_dsp_remove_scb (cs46xx_t *chip,dsp_scb_descriptor_t * scb);
-dsp_scb_descriptor_t * cs46xx_dsp_create_generic_scb (cs46xx_t *chip,char * name, 
-                                                      u32 * scb_data,u32 dest,
-                                                      char * task_entry_name,
-                                                      dsp_scb_descriptor_t * parent_scb,
-                                                      int scb_child_type);
 dsp_scb_descriptor_t *  cs46xx_dsp_create_codec_in_scb(cs46xx_t * chip,char * codec_name,
                                                        u16 channel_disp,u16 fifo_addr,
                                                        u16 sample_buffer_addr,
                                                        u32 dest,dsp_scb_descriptor_t * parent_scb,
                                                        int scb_child_type);
-dsp_scb_descriptor_t * cs46xx_dsp_create_pcm_reader_scb(cs46xx_t * chip,char * scb_name,
-                                                        u16 sample_buffer_addr,u32 dest,
-                                                        int virtual_channel,u32 playback_hw_addr,
-                                                        dsp_scb_descriptor_t * parent_scb,
-                                                        int scb_child_type);
 dsp_scb_descriptor_t *  cs46xx_dsp_create_src_task_scb(cs46xx_t * chip,char * scb_name,
 						       int sample_rate,
                                                        u16 src_buffer_addr,
@@ -169,15 +143,6 @@
                                                             u32 dest,
                                                             dsp_scb_descriptor_t * parent_scb,
                                                             int scb_child_type);
-dsp_scb_descriptor_t *  cs46xx_dsp_create_pcm_serial_input_scb(cs46xx_t * chip,char * scb_name,u32 dest,
-                                                               dsp_scb_descriptor_t * input_scb,
-                                                               dsp_scb_descriptor_t * parent_scb,
-                                                               int scb_child_type);
-dsp_scb_descriptor_t * cs46xx_dsp_create_asynch_fg_tx_scb(cs46xx_t * chip,char * scb_name,u32 dest,
-                                                          u16 hfg_scb_address,
-                                                          u16 asynch_buffer_address,
-                                                          dsp_scb_descriptor_t * parent_scb,
-                                                          int scb_child_type);
 dsp_scb_descriptor_t * cs46xx_dsp_create_asynch_fg_rx_scb(cs46xx_t * chip,char * scb_name,u32 dest,
                                                           u16 hfg_scb_address,
                                                           u16 asynch_buffer_address,
@@ -190,11 +155,6 @@
                                                              u16 mix_buffer_addr,u16 writeback_spb,u32 dest,
                                                              dsp_scb_descriptor_t * parent_scb,
                                                              int scb_child_type);
-dsp_scb_descriptor_t *  cs46xx_dsp_create_output_snoop_scb(cs46xx_t * chip,char * scb_name,u32 dest,
-                                                           u16 snoop_buffer_address,
-                                                           dsp_scb_descriptor_t * snoop_scb,
-                                                           dsp_scb_descriptor_t * parent_scb,
-                                                           int scb_child_type);
 dsp_scb_descriptor_t *  cs46xx_dsp_create_magic_snoop_scb(cs46xx_t * chip,char * scb_name,u32 dest,
                                                           u16 snoop_buffer_address,
                                                           dsp_scb_descriptor_t * snoop_scb,
diff -uNr a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
--- a/sound/pci/cs46xx/dsp_spos.c	2004-12-24 22:36:01.000000000 +0100
+++ b/sound/pci/cs46xx/dsp_spos.c	2005-01-14 22:28:12.125515072 +0100
@@ -37,6 +37,8 @@
 #include "cs46xx_lib.h"
 #include "dsp_spos.h"
 
+static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entry);
+
 static wide_opcode_t wide_opcodes[] = { 
 	WIDE_FOR_BEGIN_LOOP,
 	WIDE_FOR_BEGIN_LOOP2,
@@ -289,15 +291,9 @@
 		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );
 	}
 
-	if (ins->code.data)
-		kfree(ins->code.data);
-
-	if (ins->symbol_table.symbols)
-		vfree(ins->symbol_table.symbols);
-
-	if (ins->modules)
-		kfree(ins->modules);
-	
+	kfree(ins->code.data);
+	vfree(ins->symbol_table.symbols);
+	kfree(ins->modules);
 	kfree(ins);
 	up(&chip->spos_mutex);
 }
@@ -439,7 +435,7 @@
 }
 
 
-symbol_entry_t * cs46xx_dsp_lookup_symbol_addr (cs46xx_t * chip, u32 address, int symbol_type)
+static symbol_entry_t * cs46xx_dsp_lookup_symbol_addr (cs46xx_t * chip, u32 address, int symbol_type)
 {
 	int i;
 	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
@@ -914,7 +910,7 @@
 	int i;
 
 	for (i = 0; i < size; ++i) {
-		if (debug_tree) printk ("addr %p, val %08x\n", spdst,task_data[i]);
+		if (debug_tree) printk ("addr %p, val %08x\n",spdst,task_data[i]);
 		writel(task_data[i],spdst);
 		spdst += sizeof(u32);
 	}
@@ -928,7 +924,7 @@
 	int i;
 
 	for (i = 0; i < 0x10; ++i) {
-		if (debug_scb) printk ("addr %p, val %08x\n", spdst,scb_data[i]);
+		if (debug_scb) printk ("addr %p, val %08x\n",spdst,scb_data[i]);
 		writel(scb_data[i],spdst);
 		spdst += sizeof(u32);
 	}
@@ -1019,7 +1015,7 @@
 }
 
 
-dsp_task_descriptor_t *  cs46xx_dsp_create_task_tree (cs46xx_t *chip,char * name, u32 * task_data,u32 dest,int size)
+static dsp_task_descriptor_t *  cs46xx_dsp_create_task_tree (cs46xx_t *chip,char * name, u32 * task_data,u32 dest,int size)
 {
 	dsp_task_descriptor_t * desc;
 
@@ -1452,7 +1448,7 @@
 	return -EINVAL;
 }
 
-int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entry)
+static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entry)
 {
 	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
 	symbol_entry_t * s16_async_codec_input_task;
diff -uNr a/sound/pci/cs46xx/dsp_spos_scb_lib.c b/sound/pci/cs46xx/dsp_spos_scb_lib.c
--- a/sound/pci/cs46xx/dsp_spos_scb_lib.c	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/pci/cs46xx/dsp_spos_scb_lib.c	2005-01-14 22:28:12.132514008 +0100
@@ -342,7 +342,7 @@
 	return scb;
 }
 
-dsp_scb_descriptor_t * 
+static dsp_scb_descriptor_t * 
 cs46xx_dsp_create_generic_scb (cs46xx_t *chip,char * name, u32 * scb_data,u32 dest,
                                char * task_entry_name,
                                dsp_scb_descriptor_t * parent_scb,
@@ -481,7 +481,7 @@
 }
 
 
-dsp_scb_descriptor_t * 
+static dsp_scb_descriptor_t * 
 cs46xx_dsp_create_pcm_reader_scb(cs46xx_t * chip,char * scb_name,
                                  u16 sample_buffer_addr,u32 dest,
                                  int virtual_channel, u32 playback_hw_addr,
@@ -687,6 +687,7 @@
 	return scb;
 }
 
+#if 0 /* not used */
 dsp_scb_descriptor_t * 
 cs46xx_dsp_create_filter_scb(cs46xx_t * chip,char * scb_name,
 			     u16 buffer_addr,u32 dest,
@@ -735,6 +736,7 @@
 
  	return scb;
 }
+#endif /* not used */
 
 dsp_scb_descriptor_t * 
 cs46xx_dsp_create_mix_only_scb(cs46xx_t * chip,char * scb_name,
@@ -874,7 +876,7 @@
 }
 
 
-dsp_scb_descriptor_t * 
+static dsp_scb_descriptor_t * 
 cs46xx_dsp_create_pcm_serial_input_scb(cs46xx_t * chip,char * scb_name,u32 dest,
                                        dsp_scb_descriptor_t * input_scb,
                                        dsp_scb_descriptor_t * parent_scb,
@@ -917,7 +919,7 @@
 }
 
 
-dsp_scb_descriptor_t * 
+static dsp_scb_descriptor_t * 
 cs46xx_dsp_create_asynch_fg_tx_scb(cs46xx_t * chip,char * scb_name,u32 dest,
                                    u16 hfg_scb_address,
                                    u16 asynch_buffer_address,
@@ -1013,6 +1015,7 @@
 }
 
 
+#if 0 /* not used */
 dsp_scb_descriptor_t * 
 cs46xx_dsp_create_output_snoop_scb(cs46xx_t * chip,char * scb_name,u32 dest,
                                    u16 snoop_buffer_address,
@@ -1052,6 +1055,7 @@
 					    scb_child_type);
 	return scb;
 }
+#endif /* not used */
 
 
 dsp_scb_descriptor_t * 
diff -uNr a/sound/pci/cs46xx/imgs/cwcdma.h b/sound/pci/cs46xx/imgs/cwcdma.h
--- a/sound/pci/cs46xx/imgs/cwcdma.h	2004-12-24 22:34:31.000000000 +0100
+++ b/sound/pci/cs46xx/imgs/cwcdma.h	2005-01-14 22:28:12.136513400 +0100
@@ -3,7 +3,7 @@
 #ifndef __HEADER_cwcdma_H__
 #define __HEADER_cwcdma_H__
 
-symbol_entry_t cwcdma_symbols[] = {
+static symbol_entry_t cwcdma_symbols[] = {
   { 0x8000, "EXECCHILD",0x03 },
   { 0x8001, "EXECCHILD_98",0x03 },
   { 0x8003, "EXECCHILD_PUSH1IND",0x03 },
@@ -33,7 +33,7 @@
   { 0x0018, "#CODE_END",0x00 },
 }; /* cwcdma symbols */
 
-u32 cwcdma_code[] = {
+static u32 cwcdma_code[] = {
 /* OVERLAYBEGINADDRESS */
 /* 0000 */ 0x00002731,0x00001400,0x0004c108,0x000e5044,
 /* 0002 */ 0x0005f608,0x00000000,0x000007ae,0x000be300,
@@ -51,11 +51,11 @@
 
 /* #CODE_END */
 
-segment_desc_t cwcdma_segments[] = {
+static segment_desc_t cwcdma_segments[] = {
   { SEGTYPE_SP_PROGRAM, 0x00000000, 0x00000030, cwcdma_code },
 };
 
-dsp_module_desc_t cwcdma_module = {
+static dsp_module_desc_t cwcdma_module = {
   "cwcdma",
   {
     27,
diff -uNr a/sound/pci/emu10k1/emu10k1.c b/sound/pci/emu10k1/emu10k1.c
--- a/sound/pci/emu10k1/emu10k1.c	2004-12-24 22:33:48.000000000 +0100
+++ b/sound/pci/emu10k1/emu10k1.c	2005-01-14 22:28:12.167508688 +0100
@@ -2,6 +2,9 @@
  *  The driver for the EMU10K1 (SB Live!) based soundcards
  *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
  *
+ *  Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>
+ *      Added support for Audigy 2 Value.
+ *
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -17,6 +20,7 @@
  *   along with this program; if not, write to the Free Software
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  *
+ * 
  */
 
 #include <sound/driver.h>
@@ -68,12 +72,27 @@
 module_param_array(enable_ir, bool, NULL, 0444);
 MODULE_PARM_DESC(enable_ir, "Enable IR.");
 
+/*
+ * Class 0401: 1102:0008 (rev 00) Subsystem: 1102:1001 -> Audigy2 Value  Model:SB0400
+ */
 static struct pci_device_id snd_emu10k1_ids[] = {
 	{ 0x1102, 0x0002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* EMU10K1 */
 	{ 0x1102, 0x0004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },	/* Audigy */
+	{ 0x1102, 0x0008, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },	/* Audigy 2 Value SB0400 */
 	{ 0, }
 };
 
+/*
+ * Audigy 2 Value notes:
+ * A_IOCFG Input (GPIO)
+ * 0x400  = Front analog jack plugged in. (Green socket)
+ * 0x1000 = Read analog jack plugged in. (Black socket)
+ * 0x2000 = Center/LFE analog jack plugged in. (Orange socket)
+ * A_IOCFG Output (GPIO)
+ * 0x60 = Sound out of front Left.
+ * Win sets it to 0xXX61
+ */
+
 MODULE_DEVICE_TABLE(pci, snd_emu10k1_ids);
 
 static int __devinit snd_card_emu10k1_probe(struct pci_dev *pci,
@@ -124,6 +143,12 @@
 		snd_card_free(card);
 		return err;
 	}
+	
+	if ((err = snd_emu10k1_timer(emu, 0)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
 	if (emu->audigy) {
 		if ((err = snd_emu10k1_audigy_midi(emu)) < 0) {
 			snd_card_free(card);
@@ -155,7 +180,10 @@
 	}
 #endif
  
-	if (emu->audigy && (emu->revision == 4) ) {
+	if (emu->audigy && (emu->serial == 0x10011102) ) {
+		strcpy(card->driver, "Audigy2");
+		strcpy(card->shortname, "Sound Blaster Audigy2_Value");
+	} else if (emu->audigy && (emu->revision == 4) ) {
 		strcpy(card->driver, "Audigy2");
 		strcpy(card->shortname, "Sound Blaster Audigy2");
 	} else if (emu->audigy) {
@@ -168,7 +196,7 @@
 		strcpy(card->driver, "EMU10K1");
 		strcpy(card->shortname, "Sound Blaster Live!");
 	}
-	sprintf(card->longname, "%s (rev.%d) at 0x%lx, irq %i", card->shortname, emu->revision, emu->port, emu->irq);
+	sprintf(card->longname, "%s (rev.%d, serial:0x%x) at 0x%lx, irq %i", card->shortname, emu->revision, emu->serial, emu->port, emu->irq);
 
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
diff -uNr a/sound/pci/emu10k1/emu10k1_main.c b/sound/pci/emu10k1/emu10k1_main.c
--- a/sound/pci/emu10k1/emu10k1_main.c	2004-12-24 22:35:39.000000000 +0100
+++ b/sound/pci/emu10k1/emu10k1_main.c	2005-01-14 22:28:12.170508232 +0100
@@ -3,6 +3,10 @@
  *                   Creative Labs, Inc.
  *  Routines for control of EMU10K1 chips
  *
+ *  Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>
+ *      Added support for Audigy 2 Value.
+ *
+ *
  *  BUGS:
  *    --
  *
@@ -183,6 +187,26 @@
 		outl(0x6E0000, emu->port + 0x20);
 		outl(0xFF00FF00, emu->port + 0x24);
 	}
+	if (emu->audigy && (emu->serial == 0x10011102) ) { /* audigy2 Value */
+		/* Hacks for Alice3 to work independent of haP16V driver */
+		u32 tmp;
+
+		snd_printk(KERN_ERR "Audigy2 value:Special config.\n");
+		//Setup SRCMulti_I2S SamplingRate
+		tmp = snd_emu10k1_ptr_read(emu, A_SPDIF_SAMPLERATE, 0);
+		tmp &= 0xfffff1ff;
+		tmp |= (0x2<<9);
+		snd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, 0, tmp);
+
+		/* Setup SRCSel (Enable Spdif,I2S SRCMulti) */
+		outl(0x600000, emu->port + 0x20);
+		outl(0x14, emu->port + 0x24);
+
+		/* Setup SRCMulti Input Audio Enable */
+		outl(0x7b0000, emu->port + 0x20);
+		outl(0xFF000000, emu->port + 0x24);
+	}
+
 
 	/*
 	 *  Clear page with silence & setup all pointers to this page
@@ -267,6 +291,9 @@
 			 * This has to be done after init ALice3 I2SOut beyond 48KHz.
 			 * So, sequence is important. */
 			outl(inl(emu->port + A_IOCFG) | 0x0040, emu->port + A_IOCFG);
+		} else if (emu->serial == 0x10011102) { /* audigy2 value */
+			/* Unmute Analog now. */
+			outl(inl(emu->port + A_IOCFG) | 0x0060, emu->port + A_IOCFG);
 		} else {
 			/* Disable routing from AC97 line out to Front speakers */
 			outl(inl(emu->port + A_IOCFG) | 0x0080, emu->port + A_IOCFG);
@@ -553,10 +580,8 @@
 		snd_dma_free_pages(&emu->silent_page);
 	if (emu->ptb_pages.area)
 		snd_dma_free_pages(&emu->ptb_pages);
-	if (emu->page_ptr_table)
-		vfree(emu->page_ptr_table);
-	if (emu->page_addr_table)
-		vfree(emu->page_addr_table);
+	vfree(emu->page_ptr_table);
+	vfree(emu->page_addr_table);
 	if (emu->irq >= 0)
 		free_irq(emu->irq, (void *)emu);
 	if (emu->port)
@@ -590,7 +615,7 @@
 	*remu = NULL;
 
 	// is_audigy = (int)pci->driver_data;
-	is_audigy = (pci->device == 0x0004);
+	is_audigy = (pci->device == 0x0004) || ( (pci->device == 0x0008) );
 
 	/* enable PCI device */
 	if ((err = pci_enable_device(pci)) < 0)
@@ -689,7 +714,7 @@
 		emu->no_ac97 = 1;	
 	}
 	
-	if (emu->revision == 4 && emu->model == 0x2002) {
+	if (emu->revision == 4 && (emu->model == 0x2001 || emu->model == 0x2002)) {
 		/* Audigy 2 ZS */
 		snd_printdd(KERN_INFO "Audigy2 ZS is detected. setting 7.1 mode.\n");
 		emu->spk71 = 1;
diff -uNr a/sound/pci/emu10k1/emu10k1_synth.c b/sound/pci/emu10k1/emu10k1_synth.c
--- a/sound/pci/emu10k1/emu10k1_synth.c	2004-12-24 22:34:26.000000000 +0100
+++ b/sound/pci/emu10k1/emu10k1_synth.c	2005-01-14 22:28:12.173507776 +0100
@@ -28,7 +28,7 @@
 /*
  * create a new hardware dependent device for Emu10k1
  */
-int snd_emu10k1_synth_new_device(snd_seq_device_t *dev)
+static int snd_emu10k1_synth_new_device(snd_seq_device_t *dev)
 {
 	snd_emux_t *emu;
 	emu10k1_t *hw;
@@ -76,7 +76,7 @@
 	return 0;
 }
 
-int snd_emu10k1_synth_delete_device(snd_seq_device_t *dev)
+static int snd_emu10k1_synth_delete_device(snd_seq_device_t *dev)
 {
 	snd_emux_t *emu;
 	emu10k1_t *hw;
diff -uNr a/sound/pci/emu10k1/emu10k1x.c b/sound/pci/emu10k1/emu10k1x.c
--- a/sound/pci/emu10k1/emu10k1x.c	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/pci/emu10k1/emu10k1x.c	2005-01-14 22:28:12.181506560 +0100
@@ -0,0 +1,1644 @@
+/*
+ *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
+ *  Driver EMU10K1X chips
+ *
+ *  Parts of this code were adapted from audigyls.c driver which is
+ *  Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>
+ *
+ *  BUGS:
+ *    --
+ *
+ *  TODO:
+ *
+ *  Chips (SB0200 model):
+ *    - EMU10K1X-DBQ
+ *    - STAC 9708T
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/info.h>
+#include <sound/rawmidi.h>
+
+MODULE_AUTHOR("Francisco Moraes <fmoraes@nc.rr.com>");
+MODULE_DESCRIPTION("EMU10K1X");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Dell Creative Labs,SB Live!}");
+
+// module parameters (see "Module Parameters")
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for the EMU10K1X soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for the EMU10K1X soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable the EMU10K1X soundcard.");
+
+
+// some definitions were borrowed from emu10k1 driver as they seem to be the same
+/************************************************************************************************/
+/* PCI function 0 registers, address = <val> + PCIBASE0						*/
+/************************************************************************************************/
+
+#define PTR			0x00		/* Indexed register set pointer register	*/
+						/* NOTE: The CHANNELNUM and ADDRESS words can	*/
+						/* be modified independently of each other.	*/
+
+#define DATA			0x04		/* Indexed register set data register		*/
+
+#define IPR			0x08		/* Global interrupt pending register		*/
+						/* Clear pending interrupts by writing a 1 to	*/
+						/* the relevant bits and zero to the other bits	*/
+#define IPR_MIDITRANSBUFEMPTY   0x00000001	/* MIDI UART transmit buffer empty		*/
+#define IPR_MIDIRECVBUFEMPTY    0x00000002	/* MIDI UART receive buffer empty		*/
+#define IPR_CH_0_LOOP           0x00000800      /* Channel 0 loop                               */
+#define IPR_CH_0_HALF_LOOP      0x00000100      /* Channel 0 half loop                          */
+#define IPR_CAP_0_LOOP          0x00080000      /* Channel capture loop                         */
+#define IPR_CAP_0_HALF_LOOP     0x00010000      /* Channel capture half loop                    */
+
+#define INTE			0x0c		/* Interrupt enable register			*/
+#define INTE_MIDITXENABLE       0x00000001	/* Enable MIDI transmit-buffer-empty interrupts	*/
+#define INTE_MIDIRXENABLE       0x00000002	/* Enable MIDI receive-buffer-empty interrupts	*/
+#define INTE_CH_0_LOOP          0x00000800      /* Channel 0 loop                               */
+#define INTE_CH_0_HALF_LOOP     0x00000100      /* Channel 0 half loop                          */
+#define INTE_CAP_0_LOOP         0x00080000      /* Channel capture loop                         */
+#define INTE_CAP_0_HALF_LOOP    0x00010000      /* Channel capture half loop                    */
+
+#define HCFG			0x14		/* Hardware config register			*/
+
+#define HCFG_LOCKSOUNDCACHE	0x00000008	/* 1 = Cancel bustmaster accesses to soundcache */
+						/* NOTE: This should generally never be used.  	*/
+#define HCFG_AUDIOENABLE	0x00000001	/* 0 = CODECs transmit zero-valued samples	*/
+						/* Should be set to 1 when the EMU10K1 is	*/
+						/* completely initialized.			*/
+#define GPIO			0x18		/* Defaults: 00001080-Analog, 00001000-SPDIF.   */
+
+
+#define AC97DATA		0x1c		/* AC97 register set data register (16 bit)	*/
+
+#define AC97ADDRESS		0x1e		/* AC97 register set address register (8 bit)	*/
+
+/********************************************************************************************************/
+/* Emu10k1x pointer-offset register set, accessed through the PTR and DATA registers			*/
+/********************************************************************************************************/
+#define PLAYBACK_LIST_ADDR	0x00		/* Base DMA address of a list of pointers to each period/size */
+						/* One list entry: 4 bytes for DMA address, 
+						 * 4 bytes for period_size << 16.
+						 * One list entry is 8 bytes long.
+						 * One list entry for each period in the buffer.
+						 */
+#define PLAYBACK_LIST_SIZE	0x01		/* Size of list in bytes << 16. E.g. 8 periods -> 0x00380000  */
+#define PLAYBACK_LIST_PTR	0x02		/* Pointer to the current period being played */
+#define PLAYBACK_DMA_ADDR	0x04		/* Playback DMA addresss */
+#define PLAYBACK_PERIOD_SIZE	0x05		/* Playback period size */
+#define PLAYBACK_POINTER	0x06		/* Playback period pointer. Sample currently in DAC */
+#define PLAYBACK_UNKNOWN1       0x07
+#define PLAYBACK_UNKNOWN2       0x08
+
+/* Only one capture channel supported */
+#define CAPTURE_DMA_ADDR	0x10		/* Capture DMA address */
+#define CAPTURE_BUFFER_SIZE	0x11		/* Capture buffer size */
+#define CAPTURE_POINTER		0x12		/* Capture buffer pointer. Sample currently in ADC */
+#define CAPTURE_UNKNOWN         0x13
+
+/* From 0x20 - 0x3f, last samples played on each channel */
+
+#define TRIGGER_CHANNEL         0x40            /* Trigger channel playback                     */
+#define TRIGGER_CHANNEL_0       0x00000001      /* Trigger channel 0                            */
+#define TRIGGER_CHANNEL_1       0x00000002      /* Trigger channel 1                            */
+#define TRIGGER_CHANNEL_2       0x00000004      /* Trigger channel 2                            */
+#define TRIGGER_CAPTURE         0x00000100      /* Trigger capture channel                      */
+
+#define ROUTING                 0x41            /* Setup sound routing ?                        */
+#define ROUTING_FRONT_LEFT      0x00000001
+#define ROUTING_FRONT_RIGHT     0x00000002
+#define ROUTING_REAR_LEFT       0x00000004
+#define ROUTING_REAR_RIGHT      0x00000008
+#define ROUTING_CENTER_LFE      0x00010000
+
+#define SPCS0			0x42		/* SPDIF output Channel Status 0 register	*/
+
+#define SPCS1			0x43		/* SPDIF output Channel Status 1 register	*/
+
+#define SPCS2			0x44		/* SPDIF output Channel Status 2 register	*/
+
+#define SPCS_CLKACCYMASK	0x30000000	/* Clock accuracy				*/
+#define SPCS_CLKACCY_1000PPM	0x00000000	/* 1000 parts per million			*/
+#define SPCS_CLKACCY_50PPM	0x10000000	/* 50 parts per million				*/
+#define SPCS_CLKACCY_VARIABLE	0x20000000	/* Variable accuracy				*/
+#define SPCS_SAMPLERATEMASK	0x0f000000	/* Sample rate					*/
+#define SPCS_SAMPLERATE_44	0x00000000	/* 44.1kHz sample rate				*/
+#define SPCS_SAMPLERATE_48	0x02000000	/* 48kHz sample rate				*/
+#define SPCS_SAMPLERATE_32	0x03000000	/* 32kHz sample rate				*/
+#define SPCS_CHANNELNUMMASK	0x00f00000	/* Channel number				*/
+#define SPCS_CHANNELNUM_UNSPEC	0x00000000	/* Unspecified channel number			*/
+#define SPCS_CHANNELNUM_LEFT	0x00100000	/* Left channel					*/
+#define SPCS_CHANNELNUM_RIGHT	0x00200000	/* Right channel				*/
+#define SPCS_SOURCENUMMASK	0x000f0000	/* Source number				*/
+#define SPCS_SOURCENUM_UNSPEC	0x00000000	/* Unspecified source number			*/
+#define SPCS_GENERATIONSTATUS	0x00008000	/* Originality flag (see IEC-958 spec)		*/
+#define SPCS_CATEGORYCODEMASK	0x00007f00	/* Category code (see IEC-958 spec)		*/
+#define SPCS_MODEMASK		0x000000c0	/* Mode (see IEC-958 spec)			*/
+#define SPCS_EMPHASISMASK	0x00000038	/* Emphasis					*/
+#define SPCS_EMPHASIS_NONE	0x00000000	/* No emphasis					*/
+#define SPCS_EMPHASIS_50_15	0x00000008	/* 50/15 usec 2 channel				*/
+#define SPCS_COPYRIGHT		0x00000004	/* Copyright asserted flag -- do not modify	*/
+#define SPCS_NOTAUDIODATA	0x00000002	/* 0 = Digital audio, 1 = not audio		*/
+#define SPCS_PROFESSIONAL	0x00000001	/* 0 = Consumer (IEC-958), 1 = pro (AES3-1992)	*/
+
+#define SPDIF_SELECT		0x45		/* Enables SPDIF or Analogue outputs 0-Analogue, 0x700-SPDIF */
+
+/* This is the MPU port on the card                      					*/
+#define MUDATA		0x47
+#define MUCMD		0x48
+#define MUSTAT		MUCMD
+
+/* From 0x50 - 0x5f, last samples captured */
+
+/**
+ * The hardware has 3 channels for playback and 1 for capture.
+ *  - channel 0 is the front channel
+ *  - channel 1 is the rear channel
+ *  - channel 2 is the center/lfe chanel
+ * Volume is controlled by the AC97 for the front and rear channels by
+ * the PCM Playback Volume, Sigmatel Surround Playback Volume and 
+ * Surround Playback Volume. The Sigmatel 4-Speaker Stereo switch affects
+ * the front/rear channel mixing in the REAR OUT jack. When using the
+ * 4-Speaker Stereo, both front and rear channels will be mixed in the
+ * REAR OUT.
+ * The center/lfe channel has no volume control and cannot be muted during
+ * playback.
+ */
+
+typedef struct snd_emu10k1x_voice emu10k1x_voice_t;
+typedef struct snd_emu10k1x emu10k1x_t;
+typedef struct snd_emu10k1x_pcm emu10k1x_pcm_t;
+
+struct snd_emu10k1x_voice {
+	emu10k1x_t *emu;
+	int number;
+	int use;
+  
+	emu10k1x_pcm_t *epcm;
+};
+
+struct snd_emu10k1x_pcm {
+	emu10k1x_t *emu;
+	snd_pcm_substream_t *substream;
+	emu10k1x_voice_t *voice;
+	unsigned short running;
+};
+
+typedef struct {
+	struct snd_emu10k1x *emu;
+	snd_rawmidi_t *rmidi;
+	snd_rawmidi_substream_t *substream_input;
+	snd_rawmidi_substream_t *substream_output;
+	unsigned int midi_mode;
+	spinlock_t input_lock;
+	spinlock_t output_lock;
+	spinlock_t open_lock;
+	int tx_enable, rx_enable;
+	int port;
+	int ipr_tx, ipr_rx;
+	void (*interrupt)(emu10k1x_t *emu, unsigned int status);
+} emu10k1x_midi_t;
+
+// definition of the chip-specific record
+struct snd_emu10k1x {
+	snd_card_t *card;
+	struct pci_dev *pci;
+
+	unsigned long port;
+	struct resource *res_port;
+	int irq;
+
+	unsigned int revision;		/* chip revision */
+	unsigned int serial;            /* serial number */
+	unsigned short model;		/* subsystem id */
+
+	spinlock_t emu_lock;
+	spinlock_t voice_lock;
+
+	ac97_t *ac97;
+	snd_pcm_t *pcm;
+
+	emu10k1x_voice_t voices[3];
+	emu10k1x_voice_t capture_voice;
+	u32 spdif_bits[3]; // SPDIF out setup
+
+	struct snd_dma_buffer dma_buffer;
+
+	emu10k1x_midi_t midi;
+};
+
+/* hardware definition */
+static snd_pcm_hardware_t snd_emu10k1x_playback_hw = {
+	.info =			(SNDRV_PCM_INFO_MMAP | 
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(32*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(16*1024),
+	.periods_min =		2,
+	.periods_max =		8,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_emu10k1x_capture_hw = {
+	.info =			(SNDRV_PCM_INFO_MMAP | 
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(32*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(16*1024),
+	.periods_min =		2,
+	.periods_max =		2,
+	.fifo_size =		0,
+};
+
+static unsigned int snd_emu10k1x_ptr_read(emu10k1x_t * emu, 
+					  unsigned int reg, 
+					  unsigned int chn)
+{
+	unsigned long flags;
+	unsigned int regptr, val;
+  
+	regptr = (reg << 16) | chn;
+
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outl(regptr, emu->port + PTR);
+	val = inl(emu->port + DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+	return val;
+}
+
+static void snd_emu10k1x_ptr_write(emu10k1x_t *emu, 
+				   unsigned int reg, 
+				   unsigned int chn, 
+				   unsigned int data)
+{
+	unsigned int regptr;
+	unsigned long flags;
+
+	regptr = (reg << 16) | chn;
+
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outl(regptr, emu->port + PTR);
+	outl(data, emu->port + DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+static void snd_emu10k1x_intr_enable(emu10k1x_t *emu, unsigned int intrenb)
+{
+	unsigned long flags;
+	unsigned int enable;
+  
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	enable = inl(emu->port + INTE) | intrenb;
+	outl(enable, emu->port + INTE);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+static void snd_emu10k1x_intr_disable(emu10k1x_t *emu, unsigned int intrenb)
+{
+	unsigned long flags;
+	unsigned int enable;
+  
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	enable = inl(emu->port + INTE) & ~intrenb;
+	outl(enable, emu->port + INTE);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+static void snd_emu10k1x_gpio_write(emu10k1x_t *emu, unsigned int value)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outl(value, emu->port + GPIO);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+static void snd_emu10k1x_pcm_free_substream(snd_pcm_runtime_t *runtime)
+{
+	emu10k1x_pcm_t *epcm = runtime->private_data;
+  
+	if (epcm)
+		kfree(epcm);
+}
+
+static void snd_emu10k1x_pcm_interrupt(emu10k1x_t *emu, emu10k1x_voice_t *voice)
+{
+	emu10k1x_pcm_t *epcm;
+
+	if ((epcm = voice->epcm) == NULL)
+		return;
+	if (epcm->substream == NULL)
+		return;
+#if 0
+	snd_printk(KERN_INFO "IRQ: position = 0x%x, period = 0x%x, size = 0x%x\n",
+		   epcm->substream->ops->pointer(epcm->substream),
+		   snd_pcm_lib_period_bytes(epcm->substream),
+		   snd_pcm_lib_buffer_bytes(epcm->substream));
+#endif
+	snd_pcm_period_elapsed(epcm->substream);
+}
+
+/* open callback */
+static int snd_emu10k1x_playback_open(snd_pcm_substream_t *substream)
+{
+	emu10k1x_t *chip = snd_pcm_substream_chip(substream);
+	emu10k1x_pcm_t *epcm;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0) {
+		return err;
+	}
+	if ((err = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64)) < 0)
+                return err;
+
+	epcm = kcalloc(1, sizeof(*epcm), GFP_KERNEL);
+	if (epcm == NULL)
+		return -ENOMEM;
+	epcm->emu = chip;
+	epcm->substream = substream;
+  
+	runtime->private_data = epcm;
+	runtime->private_free = snd_emu10k1x_pcm_free_substream;
+  
+	runtime->hw = snd_emu10k1x_playback_hw;
+
+	return 0;
+}
+
+/* close callback */
+static int snd_emu10k1x_playback_close(snd_pcm_substream_t *substream)
+{
+	return 0;
+}
+
+/* hw_params callback */
+static int snd_emu10k1x_pcm_hw_params(snd_pcm_substream_t *substream,
+				      snd_pcm_hw_params_t * hw_params)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	emu10k1x_pcm_t *epcm = runtime->private_data;
+
+	if (! epcm->voice) {
+		epcm->voice = &epcm->emu->voices[substream->pcm->device];
+		epcm->voice->use = 1;
+		epcm->voice->epcm = epcm;
+	}
+
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+/* hw_free callback */
+static int snd_emu10k1x_pcm_hw_free(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	emu10k1x_pcm_t *epcm;
+
+	if (runtime->private_data == NULL)
+		return 0;
+	
+	epcm = runtime->private_data;
+
+	if (epcm->voice) {
+		epcm->voice->use = 0;
+		epcm->voice->epcm = NULL;
+		epcm->voice = NULL;
+	}
+
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/* prepare callback */
+static int snd_emu10k1x_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	emu10k1x_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	emu10k1x_pcm_t *epcm = runtime->private_data;
+	int voice = epcm->voice->number;
+	u32 *table_base = (u32 *)(emu->dma_buffer.area+1024*voice);
+	u32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);
+	int i;
+	
+	for(i=0; i < runtime->periods; i++) {
+		*table_base++=runtime->dma_addr+(i*period_size_bytes);
+		*table_base++=period_size_bytes<<16;
+	}
+
+	snd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_ADDR, voice, emu->dma_buffer.addr+1024*voice);
+	snd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_SIZE, voice, (runtime->periods - 1) << 19);
+	snd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_PTR, voice, 0);
+	snd_emu10k1x_ptr_write(emu, PLAYBACK_POINTER, voice, 0);
+	snd_emu10k1x_ptr_write(emu, PLAYBACK_UNKNOWN1, voice, 0);
+	snd_emu10k1x_ptr_write(emu, PLAYBACK_UNKNOWN2, voice, 0);
+	snd_emu10k1x_ptr_write(emu, PLAYBACK_DMA_ADDR, voice, runtime->dma_addr);
+
+	snd_emu10k1x_ptr_write(emu, PLAYBACK_PERIOD_SIZE, voice, frames_to_bytes(runtime, runtime->period_size)<<16);
+
+	return 0;
+}
+
+/* trigger callback */
+static int snd_emu10k1x_pcm_trigger(snd_pcm_substream_t *substream,
+				    int cmd)
+{
+	emu10k1x_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	emu10k1x_pcm_t *epcm = runtime->private_data;
+	int channel = epcm->voice->number;
+	int result = 0;
+
+//	snd_printk(KERN_INFO "trigger - emu10k1x = 0x%x, cmd = %i, pointer = %d\n", (int)emu, cmd, (int)substream->ops->pointer(substream));
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if(runtime->periods == 2)
+			snd_emu10k1x_intr_enable(emu, (INTE_CH_0_LOOP | INTE_CH_0_HALF_LOOP) << channel);
+		else
+			snd_emu10k1x_intr_enable(emu, INTE_CH_0_LOOP << channel);
+		epcm->running = 1;
+		snd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0)|(TRIGGER_CHANNEL_0<<channel));
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		epcm->running = 0;
+		snd_emu10k1x_intr_disable(emu, (INTE_CH_0_LOOP | INTE_CH_0_HALF_LOOP) << channel);
+		snd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0) & ~(TRIGGER_CHANNEL_0<<channel));
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+	return result;
+}
+
+/* pointer callback */
+static snd_pcm_uframes_t
+snd_emu10k1x_pcm_pointer(snd_pcm_substream_t *substream)
+{
+	emu10k1x_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	emu10k1x_pcm_t *epcm = runtime->private_data;
+	int channel = epcm->voice->number;
+	snd_pcm_uframes_t ptr = 0, ptr1 = 0, ptr2= 0,ptr3 = 0,ptr4 = 0;
+
+	if (!epcm->running)
+		return 0;
+
+	ptr3 = snd_emu10k1x_ptr_read(emu, PLAYBACK_LIST_PTR, channel);
+	ptr1 = snd_emu10k1x_ptr_read(emu, PLAYBACK_POINTER, channel);
+	ptr4 = snd_emu10k1x_ptr_read(emu, PLAYBACK_LIST_PTR, channel);
+
+	if(ptr4 == 0 && ptr1 == frames_to_bytes(runtime, runtime->buffer_size))
+		return 0;
+	
+	if (ptr3 != ptr4) 
+		ptr1 = snd_emu10k1x_ptr_read(emu, PLAYBACK_POINTER, channel);
+	ptr2 = bytes_to_frames(runtime, ptr1);
+	ptr2 += (ptr4 >> 3) * runtime->period_size;
+	ptr = ptr2;
+
+	if (ptr >= runtime->buffer_size)
+		ptr -= runtime->buffer_size;
+
+	return ptr;
+}
+
+/* operators */
+static snd_pcm_ops_t snd_emu10k1x_playback_ops = {
+	.open =        snd_emu10k1x_playback_open,
+	.close =       snd_emu10k1x_playback_close,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   snd_emu10k1x_pcm_hw_params,
+	.hw_free =     snd_emu10k1x_pcm_hw_free,
+	.prepare =     snd_emu10k1x_pcm_prepare,
+	.trigger =     snd_emu10k1x_pcm_trigger,
+	.pointer =     snd_emu10k1x_pcm_pointer,
+};
+
+/* open_capture callback */
+static int snd_emu10k1x_pcm_open_capture(snd_pcm_substream_t *substream)
+{
+	emu10k1x_t *chip = snd_pcm_substream_chip(substream);
+	emu10k1x_pcm_t *epcm;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+                return err;
+	if ((err = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64)) < 0)
+                return err;
+
+	epcm = kcalloc(1, sizeof(*epcm), GFP_KERNEL);
+	if (epcm == NULL)
+		return -ENOMEM;
+
+	epcm->emu = chip;
+	epcm->substream = substream;
+
+	runtime->private_data = epcm;
+	runtime->private_free = snd_emu10k1x_pcm_free_substream;
+
+	runtime->hw = snd_emu10k1x_capture_hw;
+
+	return 0;
+}
+
+/* close callback */
+static int snd_emu10k1x_pcm_close_capture(snd_pcm_substream_t *substream)
+{
+	return 0;
+}
+
+/* hw_params callback */
+static int snd_emu10k1x_pcm_hw_params_capture(snd_pcm_substream_t *substream,
+					      snd_pcm_hw_params_t * hw_params)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	emu10k1x_pcm_t *epcm = runtime->private_data;
+
+	if (! epcm->voice) {
+		if (epcm->emu->capture_voice.use)
+			return -EBUSY;
+		epcm->voice = &epcm->emu->capture_voice;
+		epcm->voice->epcm = epcm;
+		epcm->voice->use = 1;
+	}
+
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+/* hw_free callback */
+static int snd_emu10k1x_pcm_hw_free_capture(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	emu10k1x_pcm_t *epcm;
+
+	if (runtime->private_data == NULL)
+		return 0;
+	epcm = runtime->private_data;
+
+	if (epcm->voice) {
+		epcm->voice->use = 0;
+		epcm->voice->epcm = NULL;
+		epcm->voice = NULL;
+	}
+
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/* prepare capture callback */
+static int snd_emu10k1x_pcm_prepare_capture(snd_pcm_substream_t *substream)
+{
+	emu10k1x_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_emu10k1x_ptr_write(emu, CAPTURE_DMA_ADDR, 0, runtime->dma_addr);
+	snd_emu10k1x_ptr_write(emu, CAPTURE_BUFFER_SIZE, 0, frames_to_bytes(runtime, runtime->buffer_size)<<16); // buffer size in bytes
+	snd_emu10k1x_ptr_write(emu, CAPTURE_POINTER, 0, 0);
+	snd_emu10k1x_ptr_write(emu, CAPTURE_UNKNOWN, 0, 0);
+
+	return 0;
+}
+
+/* trigger_capture callback */
+static int snd_emu10k1x_pcm_trigger_capture(snd_pcm_substream_t *substream,
+					    int cmd)
+{
+	emu10k1x_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	emu10k1x_pcm_t *epcm = runtime->private_data;
+	int result = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		snd_emu10k1x_intr_enable(emu, INTE_CAP_0_LOOP | 
+					 INTE_CAP_0_HALF_LOOP);
+		snd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0)|TRIGGER_CAPTURE);
+		epcm->running = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		epcm->running = 0;
+		snd_emu10k1x_intr_disable(emu, INTE_CAP_0_LOOP | 
+					  INTE_CAP_0_HALF_LOOP);
+		snd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0) & ~(TRIGGER_CAPTURE));
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+	return result;
+}
+
+/* pointer_capture callback */
+static snd_pcm_uframes_t
+snd_emu10k1x_pcm_pointer_capture(snd_pcm_substream_t *substream)
+{
+	emu10k1x_t *emu = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	emu10k1x_pcm_t *epcm = runtime->private_data;
+	snd_pcm_uframes_t ptr;
+
+	if (!epcm->running)
+		return 0;
+
+	ptr = bytes_to_frames(runtime, snd_emu10k1x_ptr_read(emu, CAPTURE_POINTER, 0));
+	if (ptr >= runtime->buffer_size)
+		ptr -= runtime->buffer_size;
+
+	return ptr;
+}
+
+static snd_pcm_ops_t snd_emu10k1x_capture_ops = {
+	.open =        snd_emu10k1x_pcm_open_capture,
+	.close =       snd_emu10k1x_pcm_close_capture,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   snd_emu10k1x_pcm_hw_params_capture,
+	.hw_free =     snd_emu10k1x_pcm_hw_free_capture,
+	.prepare =     snd_emu10k1x_pcm_prepare_capture,
+	.trigger =     snd_emu10k1x_pcm_trigger_capture,
+	.pointer =     snd_emu10k1x_pcm_pointer_capture,
+};
+
+static unsigned short snd_emu10k1x_ac97_read(ac97_t *ac97,
+					     unsigned short reg)
+{
+	emu10k1x_t *emu = ac97->private_data;
+	unsigned long flags;
+	unsigned short val;
+  
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outb(reg, emu->port + AC97ADDRESS);
+	val = inw(emu->port + AC97DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+	return val;
+}
+
+static void snd_emu10k1x_ac97_write(ac97_t *ac97,
+				    unsigned short reg, unsigned short val)
+{
+	emu10k1x_t *emu = ac97->private_data;
+	unsigned long flags;
+  
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outb(reg, emu->port + AC97ADDRESS);
+	outw(val, emu->port + AC97DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+static int snd_emu10k1x_ac97(emu10k1x_t *chip)
+{
+	ac97_bus_t *pbus;
+	ac97_template_t ac97;
+	int err;
+	static ac97_bus_ops_t ops = {
+		.write = snd_emu10k1x_ac97_write,
+		.read = snd_emu10k1x_ac97_read,
+	};
+  
+	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
+		return err;
+	pbus->no_vra = 1; /* we don't need VRA */
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+	return snd_ac97_mixer(pbus, &ac97, &chip->ac97);
+}
+
+static int snd_emu10k1x_free(emu10k1x_t *chip)
+{
+	snd_emu10k1x_ptr_write(chip, TRIGGER_CHANNEL, 0, 0);
+	// disable interrupts
+	outl(0, chip->port + INTE);
+	// disable audio
+	outl(HCFG_LOCKSOUNDCACHE, chip->port + HCFG);
+
+	// release the i/o port
+	if (chip->res_port) {
+		release_resource(chip->res_port);
+		kfree_nocheck(chip->res_port);
+	}
+	// release the irq
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
+
+	// release the DMA
+	if (chip->dma_buffer.area) {
+		snd_dma_free_pages(&chip->dma_buffer);
+	}
+
+	pci_disable_device(chip->pci);
+
+	// release the data
+	kfree(chip);
+	return 0;
+}
+
+static int snd_emu10k1x_dev_free(snd_device_t *device)
+{
+	emu10k1x_t *chip = device->device_data;
+	return snd_emu10k1x_free(chip);
+}
+
+static irqreturn_t snd_emu10k1x_interrupt(int irq, void *dev_id,
+					  struct pt_regs *regs)
+{
+	unsigned int status;
+
+	emu10k1x_t *chip = dev_id;
+	emu10k1x_voice_t *pvoice = chip->voices;
+	int i;
+	int mask;
+
+	status = inl(chip->port + IPR);
+
+	if(status) {
+		// capture interrupt
+		if(status & (IPR_CAP_0_LOOP | IPR_CAP_0_HALF_LOOP)) {
+			emu10k1x_voice_t *pvoice = &chip->capture_voice;
+			if(pvoice->use)
+				snd_emu10k1x_pcm_interrupt(chip, pvoice);
+			else
+				snd_emu10k1x_intr_disable(chip, 
+							  INTE_CAP_0_LOOP |
+							  INTE_CAP_0_HALF_LOOP);
+		}
+		
+		mask = IPR_CH_0_LOOP|IPR_CH_0_HALF_LOOP;
+		for(i = 0; i < 3; i++) {
+			if(status & mask) {
+				if(pvoice->use)
+					snd_emu10k1x_pcm_interrupt(chip, pvoice);
+				else 
+					snd_emu10k1x_intr_disable(chip, mask);
+			}
+			pvoice++;
+			mask <<= 1;
+		}
+		
+		if (status & (IPR_MIDITRANSBUFEMPTY|IPR_MIDIRECVBUFEMPTY)) {
+			if (chip->midi.interrupt)
+				chip->midi.interrupt(chip, status);
+			else
+				snd_emu10k1x_intr_disable(chip, INTE_MIDITXENABLE|INTE_MIDIRXENABLE);
+		}
+		
+		// acknowledge the interrupt if necessary
+		if(status)
+			outl(status, chip->port+IPR);
+
+//		snd_printk(KERN_INFO "interrupt %08x\n", status);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void snd_emu10k1x_pcm_free(snd_pcm_t *pcm)
+{
+	emu10k1x_t *emu = pcm->private_data;
+	emu->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_emu10k1x_pcm(emu10k1x_t *emu, int device, snd_pcm_t **rpcm)
+{
+	snd_pcm_t *pcm;
+	int err;
+	int capture = 0;
+  
+	if (rpcm)
+		*rpcm = NULL;
+	if (device == 0)
+		capture = 1;
+	
+	if ((err = snd_pcm_new(emu->card, "emu10k1x", device, 1, capture, &pcm)) < 0)
+		return err;
+  
+	pcm->private_data = emu;
+	pcm->private_free = snd_emu10k1x_pcm_free;
+	
+	switch(device) {
+	case 0:
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1x_playback_ops);
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1x_capture_ops);
+		break;
+	case 1:
+	case 2:
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1x_playback_ops);
+		break;
+	}
+
+	pcm->info_flags = 0;
+	pcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;
+	switch(device) {
+	case 0:
+		strcpy(pcm->name, "EMU10K1X Front");
+		break;
+	case 1:
+		strcpy(pcm->name, "EMU10K1X Rear");
+		break;
+	case 2:
+		strcpy(pcm->name, "EMU10K1X Center/LFE");
+		break;
+	}
+	emu->pcm = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(emu->pci), 
+					      32*1024, 32*1024);
+  
+	if (rpcm)
+		*rpcm = pcm;
+  
+	return 0;
+}
+
+static int __devinit snd_emu10k1x_create(snd_card_t *card,
+					 struct pci_dev *pci,
+					 emu10k1x_t **rchip)
+{
+	emu10k1x_t *chip;
+	int err;
+	int ch;
+	static snd_device_ops_t ops = {
+		.dev_free = snd_emu10k1x_dev_free,
+	};
+  
+	*rchip = NULL;
+  
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
+	    pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
+		snd_printk(KERN_ERR "error to set 28bit mask DMA\n");
+		pci_disable_device(pci);
+		return -ENXIO;
+	}
+  
+	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+  
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+
+	spin_lock_init(&chip->emu_lock);
+	spin_lock_init(&chip->voice_lock);
+  
+	chip->port = pci_resource_start(pci, 0);
+	if ((chip->res_port = request_region(chip->port, 8,
+					     "EMU10K1X")) == NULL) { 
+		snd_printk(KERN_ERR "emu10k1x: cannot allocate the port 0x%lx\n", chip->port);
+		snd_emu10k1x_free(chip);
+		return -EBUSY;
+	}
+
+	if (request_irq(pci->irq, snd_emu10k1x_interrupt,
+			SA_INTERRUPT|SA_SHIRQ, "EMU10K1X",
+			(void *)chip)) {
+		snd_printk(KERN_ERR "emu10k1x: cannot grab irq %d\n", pci->irq);
+		snd_emu10k1x_free(chip);
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+  
+	if(snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+			       4 * 1024, &chip->dma_buffer) < 0) {
+		snd_emu10k1x_free(chip);
+		return -ENOMEM;
+	}
+
+	pci_set_master(pci);
+	/* read revision & serial */
+	pci_read_config_byte(pci, PCI_REVISION_ID, (char *)&chip->revision);
+	pci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);
+	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);
+	snd_printk(KERN_INFO "Model %04x Rev %08x Serial %08x\n", chip->model,
+		   chip->revision, chip->serial);
+
+	outl(0, chip->port + INTE);	
+
+	for(ch = 0; ch < 3; ch++) {
+		chip->voices[ch].emu = chip;
+		chip->voices[ch].number = ch;
+	}
+
+	/*
+	 *  Init to 0x02109204 :
+	 *  Clock accuracy    = 0     (1000ppm)
+	 *  Sample Rate       = 2     (48kHz)
+	 *  Audio Channel     = 1     (Left of 2)
+	 *  Source Number     = 0     (Unspecified)
+	 *  Generation Status = 1     (Original for Cat Code 12)
+	 *  Cat Code          = 12    (Digital Signal Mixer)
+	 *  Mode              = 0     (Mode 0)
+	 *  Emphasis          = 0     (None)
+	 *  CP                = 1     (Copyright unasserted)
+	 *  AN                = 0     (Audio data)
+	 *  P                 = 0     (Consumer)
+	 */
+	snd_emu10k1x_ptr_write(chip, SPCS0, 0,
+			       chip->spdif_bits[0] = 
+			       SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+			       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |
+			       SPCS_GENERATIONSTATUS | 0x00001200 |
+			       0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);
+	snd_emu10k1x_ptr_write(chip, SPCS1, 0,
+			       chip->spdif_bits[1] = 
+			       SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+			       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |
+			       SPCS_GENERATIONSTATUS | 0x00001200 |
+			       0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);
+	snd_emu10k1x_ptr_write(chip, SPCS2, 0,
+			       chip->spdif_bits[2] = 
+			       SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+			       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |
+			       SPCS_GENERATIONSTATUS | 0x00001200 |
+			       0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);
+
+	snd_emu10k1x_ptr_write(chip, SPDIF_SELECT, 0, 0x700); // disable SPDIF
+	snd_emu10k1x_ptr_write(chip, ROUTING, 0, 0x1003F); // routing
+	snd_emu10k1x_gpio_write(chip, 0x1080); // analog mode
+
+	outl(HCFG_LOCKSOUNDCACHE|HCFG_AUDIOENABLE, chip->port+HCFG);
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
+				  chip, &ops)) < 0) {
+		snd_emu10k1x_free(chip);
+		return err;
+	}
+	*rchip = chip;
+	return 0;
+}
+
+static void snd_emu10k1x_proc_reg_read(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	emu10k1x_t *emu = entry->private_data;
+	unsigned long value,value1,value2;
+	unsigned long flags;
+	int i;
+
+	snd_iprintf(buffer, "Registers:\n\n");
+	for(i = 0; i < 0x20; i+=4) {
+		spin_lock_irqsave(&emu->emu_lock, flags);
+		value = inl(emu->port + i);
+		spin_unlock_irqrestore(&emu->emu_lock, flags);
+		snd_iprintf(buffer, "Register %02X: %08lX\n", i, value);
+	}
+	snd_iprintf(buffer, "\nRegisters\n\n");
+	for(i = 0; i <= 0x48; i++) {
+		value = snd_emu10k1x_ptr_read(emu, i, 0);
+		if(i < 0x10 || (i >= 0x20 && i < 0x40)) {
+			value1 = snd_emu10k1x_ptr_read(emu, i, 1);
+			value2 = snd_emu10k1x_ptr_read(emu, i, 2);
+			snd_iprintf(buffer, "%02X: %08lX %08lX %08lX\n", i, value, value1, value2);
+		} else {
+			snd_iprintf(buffer, "%02X: %08lX\n", i, value);
+		}
+	}
+}
+
+static void snd_emu10k1x_proc_reg_write(snd_info_entry_t *entry, 
+					snd_info_buffer_t *buffer)
+{
+	emu10k1x_t *emu = entry->private_data;
+	char line[64];
+	unsigned int reg, channel_id , val;
+
+	while (!snd_info_get_line(buffer, line, sizeof(line))) {
+		if (sscanf(line, "%x %x %x", &reg, &channel_id, &val) != 3)
+			continue;
+
+		if ((reg < 0x49) && (reg >=0) && (val <= 0xffffffff) 
+		    && (channel_id >=0) && (channel_id <= 2) )
+			snd_emu10k1x_ptr_write(emu, reg, channel_id, val);
+	}
+}
+
+static int __devinit snd_emu10k1x_proc_init(emu10k1x_t * emu)
+{
+	snd_info_entry_t *entry;
+	
+	if(! snd_card_proc_new(emu->card, "emu10k1x_regs", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_emu10k1x_proc_reg_read);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_emu10k1x_proc_reg_write;
+		entry->private_data = emu;
+	}
+	
+	return 0;
+}
+
+static int snd_emu10k1x_shared_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_emu10k1x_shared_spdif_get(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	emu10k1x_t *emu = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] = (snd_emu10k1x_ptr_read(emu, SPDIF_SELECT, 0) == 0x700) ? 0 : 1;
+
+	return 0;
+}
+
+static int snd_emu10k1x_shared_spdif_put(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	emu10k1x_t *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change = 0;
+
+	val = ucontrol->value.integer.value[0] ;
+
+	if (val) {
+		// enable spdif output
+		snd_emu10k1x_ptr_write(emu, SPDIF_SELECT, 0, 0x000);
+		snd_emu10k1x_ptr_write(emu, ROUTING, 0, 0x700);
+		snd_emu10k1x_gpio_write(emu, 0x1000);
+	} else {
+		// disable spdif output
+		snd_emu10k1x_ptr_write(emu, SPDIF_SELECT, 0, 0x700);
+		snd_emu10k1x_ptr_write(emu, ROUTING, 0, 0x1003F);
+		snd_emu10k1x_gpio_write(emu, 0x1080);
+	}
+	return change;
+}
+
+static snd_kcontrol_new_t snd_emu10k1x_shared_spdif __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Analog/Digital Output Jack",
+	.info =		snd_emu10k1x_shared_spdif_info,
+	.get =		snd_emu10k1x_shared_spdif_get,
+	.put =		snd_emu10k1x_shared_spdif_put
+};
+
+static int snd_emu10k1x_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_emu10k1x_spdif_get(snd_kcontrol_t * kcontrol,
+				  snd_ctl_elem_value_t * ucontrol)
+{
+	emu10k1x_t *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+
+	ucontrol->value.iec958.status[0] = (emu->spdif_bits[idx] >> 0) & 0xff;
+	ucontrol->value.iec958.status[1] = (emu->spdif_bits[idx] >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (emu->spdif_bits[idx] >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (emu->spdif_bits[idx] >> 24) & 0xff;
+	return 0;
+}
+
+static int snd_emu10k1x_spdif_get_mask(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = 0xff;
+	ucontrol->value.iec958.status[1] = 0xff;
+	ucontrol->value.iec958.status[2] = 0xff;
+	ucontrol->value.iec958.status[3] = 0xff;
+	return 0;
+}
+
+static int snd_emu10k1x_spdif_put(snd_kcontrol_t * kcontrol,
+				  snd_ctl_elem_value_t * ucontrol)
+{
+	emu10k1x_t *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	int change;
+	unsigned int val;
+
+	val = (ucontrol->value.iec958.status[0] << 0) |
+		(ucontrol->value.iec958.status[1] << 8) |
+		(ucontrol->value.iec958.status[2] << 16) |
+		(ucontrol->value.iec958.status[3] << 24);
+	change = val != emu->spdif_bits[idx];
+	if (change) {
+		snd_emu10k1x_ptr_write(emu, SPCS0 + idx, 0, val);
+		emu->spdif_bits[idx] = val;
+	}
+	return change;
+}
+
+static snd_kcontrol_new_t snd_emu10k1x_spdif_mask_control =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+	.count =	3,
+	.info =         snd_emu10k1x_spdif_info,
+	.get =          snd_emu10k1x_spdif_get_mask
+};
+
+static snd_kcontrol_new_t snd_emu10k1x_spdif_control =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.count =	3,
+	.info =         snd_emu10k1x_spdif_info,
+	.get =          snd_emu10k1x_spdif_get,
+	.put =          snd_emu10k1x_spdif_put
+};
+
+static int __devinit snd_emu10k1x_mixer(emu10k1x_t *emu)
+{
+	int err;
+	snd_kcontrol_t *kctl;
+	snd_card_t *card = emu->card;
+
+	if ((kctl = snd_ctl_new1(&snd_emu10k1x_spdif_mask_control, emu)) == NULL)
+		return -ENOMEM;
+	if ((err = snd_ctl_add(card, kctl)))
+		return err;
+	if ((kctl = snd_ctl_new1(&snd_emu10k1x_shared_spdif, emu)) == NULL)
+		return -ENOMEM;
+	if ((err = snd_ctl_add(card, kctl)))
+		return err;
+	if ((kctl = snd_ctl_new1(&snd_emu10k1x_spdif_control, emu)) == NULL)
+		return -ENOMEM;
+	if ((err = snd_ctl_add(card, kctl)))
+		return err;
+
+	return 0;
+}
+
+#define EMU10K1X_MIDI_MODE_INPUT	(1<<0)
+#define EMU10K1X_MIDI_MODE_OUTPUT	(1<<1)
+
+static inline unsigned char mpu401_read(emu10k1x_t *emu, emu10k1x_midi_t *mpu, int idx)
+{
+	return (unsigned char)snd_emu10k1x_ptr_read(emu, mpu->port + idx, 0);
+}
+
+static inline void mpu401_write(emu10k1x_t *emu, emu10k1x_midi_t *mpu, int data, int idx)
+{
+	snd_emu10k1x_ptr_write(emu, mpu->port + idx, 0, data);
+}
+
+#define mpu401_write_data(emu, mpu, data)	mpu401_write(emu, mpu, data, 0)
+#define mpu401_write_cmd(emu, mpu, data)	mpu401_write(emu, mpu, data, 1)
+#define mpu401_read_data(emu, mpu)		mpu401_read(emu, mpu, 0)
+#define mpu401_read_stat(emu, mpu)		mpu401_read(emu, mpu, 1)
+
+#define mpu401_input_avail(emu,mpu)	(!(mpu401_read_stat(emu,mpu) & 0x80))
+#define mpu401_output_ready(emu,mpu)	(!(mpu401_read_stat(emu,mpu) & 0x40))
+
+#define MPU401_RESET		0xff
+#define MPU401_ENTER_UART	0x3f
+#define MPU401_ACK		0xfe
+
+static void mpu401_clear_rx(emu10k1x_t *emu, emu10k1x_midi_t *mpu)
+{
+	int timeout = 100000;
+	for (; timeout > 0 && mpu401_input_avail(emu, mpu); timeout--)
+		mpu401_read_data(emu, mpu);
+#ifdef CONFIG_SND_DEBUG
+	if (timeout <= 0)
+		snd_printk(KERN_ERR "cmd: clear rx timeout (status = 0x%x)\n", mpu401_read_stat(emu, mpu));
+#endif
+}
+
+/*
+
+ */
+
+static void do_emu10k1x_midi_interrupt(emu10k1x_t *emu, emu10k1x_midi_t *midi, unsigned int status)
+{
+	unsigned char byte;
+
+	if (midi->rmidi == NULL) {
+		snd_emu10k1x_intr_disable(emu, midi->tx_enable | midi->rx_enable);
+		return;
+	}
+
+	spin_lock(&midi->input_lock);
+	if ((status & midi->ipr_rx) && mpu401_input_avail(emu, midi)) {
+		if (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {
+			mpu401_clear_rx(emu, midi);
+		} else {
+			byte = mpu401_read_data(emu, midi);
+			spin_unlock(&midi->input_lock);
+			if (midi->substream_input)
+				snd_rawmidi_receive(midi->substream_input, &byte, 1);
+			spin_lock(&midi->input_lock);
+		}
+	}
+	spin_unlock(&midi->input_lock);
+
+	spin_lock(&midi->output_lock);
+	if ((status & midi->ipr_tx) && mpu401_output_ready(emu, midi)) {
+		if (midi->substream_output &&
+		    snd_rawmidi_transmit(midi->substream_output, &byte, 1) == 1) {
+			mpu401_write_data(emu, midi, byte);
+		} else {
+			snd_emu10k1x_intr_disable(emu, midi->tx_enable);
+		}
+	}
+	spin_unlock(&midi->output_lock);
+}
+
+static void snd_emu10k1x_midi_interrupt(emu10k1x_t *emu, unsigned int status)
+{
+	do_emu10k1x_midi_interrupt(emu, &emu->midi, status);
+}
+
+static void snd_emu10k1x_midi_cmd(emu10k1x_t * emu, emu10k1x_midi_t *midi, unsigned char cmd, int ack)
+{
+	unsigned long flags;
+	int timeout, ok;
+
+	spin_lock_irqsave(&midi->input_lock, flags);
+	mpu401_write_data(emu, midi, 0x00);
+	/* mpu401_clear_rx(emu, midi); */
+
+	mpu401_write_cmd(emu, midi, cmd);
+	if (ack) {
+		ok = 0;
+		timeout = 10000;
+		while (!ok && timeout-- > 0) {
+			if (mpu401_input_avail(emu, midi)) {
+				if (mpu401_read_data(emu, midi) == MPU401_ACK)
+					ok = 1;
+			}
+		}
+		if (!ok && mpu401_read_data(emu, midi) == MPU401_ACK)
+			ok = 1;
+	} else {
+		ok = 1;
+	}
+	spin_unlock_irqrestore(&midi->input_lock, flags);
+	if (!ok)
+		snd_printk(KERN_ERR "midi_cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)!!!\n",
+			   cmd, emu->port,
+			   mpu401_read_stat(emu, midi),
+			   mpu401_read_data(emu, midi));
+}
+
+static int snd_emu10k1x_midi_input_open(snd_rawmidi_substream_t * substream)
+{
+	emu10k1x_t *emu;
+	emu10k1x_midi_t *midi = (emu10k1x_midi_t *)substream->rmidi->private_data;
+	unsigned long flags;
+	
+	emu = midi->emu;
+	snd_assert(emu, return -ENXIO);
+	spin_lock_irqsave(&midi->open_lock, flags);
+	midi->midi_mode |= EMU10K1X_MIDI_MODE_INPUT;
+	midi->substream_input = substream;
+	if (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT)) {
+		spin_unlock_irqrestore(&midi->open_lock, flags);
+		snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 1);
+		snd_emu10k1x_midi_cmd(emu, midi, MPU401_ENTER_UART, 1);
+	} else {
+		spin_unlock_irqrestore(&midi->open_lock, flags);
+	}
+	return 0;
+}
+
+static int snd_emu10k1x_midi_output_open(snd_rawmidi_substream_t * substream)
+{
+	emu10k1x_t *emu;
+	emu10k1x_midi_t *midi = (emu10k1x_midi_t *)substream->rmidi->private_data;
+	unsigned long flags;
+
+	emu = midi->emu;
+	snd_assert(emu, return -ENXIO);
+	spin_lock_irqsave(&midi->open_lock, flags);
+	midi->midi_mode |= EMU10K1X_MIDI_MODE_OUTPUT;
+	midi->substream_output = substream;
+	if (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {
+		spin_unlock_irqrestore(&midi->open_lock, flags);
+		snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 1);
+		snd_emu10k1x_midi_cmd(emu, midi, MPU401_ENTER_UART, 1);
+	} else {
+		spin_unlock_irqrestore(&midi->open_lock, flags);
+	}
+	return 0;
+}
+
+static int snd_emu10k1x_midi_input_close(snd_rawmidi_substream_t * substream)
+{
+	emu10k1x_t *emu;
+	emu10k1x_midi_t *midi = (emu10k1x_midi_t *)substream->rmidi->private_data;
+	unsigned long flags;
+
+	emu = midi->emu;
+	snd_assert(emu, return -ENXIO);
+	spin_lock_irqsave(&midi->open_lock, flags);
+	snd_emu10k1x_intr_disable(emu, midi->rx_enable);
+	midi->midi_mode &= ~EMU10K1X_MIDI_MODE_INPUT;
+	midi->substream_input = NULL;
+	if (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT)) {
+		spin_unlock_irqrestore(&midi->open_lock, flags);
+		snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 0);
+	} else {
+		spin_unlock_irqrestore(&midi->open_lock, flags);
+	}
+	return 0;
+}
+
+static int snd_emu10k1x_midi_output_close(snd_rawmidi_substream_t * substream)
+{
+	emu10k1x_t *emu;
+	emu10k1x_midi_t *midi = (emu10k1x_midi_t *)substream->rmidi->private_data;
+	unsigned long flags;
+
+	emu = midi->emu;
+	snd_assert(emu, return -ENXIO);
+	spin_lock_irqsave(&midi->open_lock, flags);
+	snd_emu10k1x_intr_disable(emu, midi->tx_enable);
+	midi->midi_mode &= ~EMU10K1X_MIDI_MODE_OUTPUT;
+	midi->substream_output = NULL;
+	if (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {
+		spin_unlock_irqrestore(&midi->open_lock, flags);
+		snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 0);
+	} else {
+		spin_unlock_irqrestore(&midi->open_lock, flags);
+	}
+	return 0;
+}
+
+static void snd_emu10k1x_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	emu10k1x_t *emu;
+	emu10k1x_midi_t *midi = (emu10k1x_midi_t *)substream->rmidi->private_data;
+	emu = midi->emu;
+	snd_assert(emu, return);
+
+	if (up)
+		snd_emu10k1x_intr_enable(emu, midi->rx_enable);
+	else
+		snd_emu10k1x_intr_disable(emu, midi->rx_enable);
+}
+
+static void snd_emu10k1x_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	emu10k1x_t *emu;
+	emu10k1x_midi_t *midi = (emu10k1x_midi_t *)substream->rmidi->private_data;
+	unsigned long flags;
+
+	emu = midi->emu;
+	snd_assert(emu, return);
+
+	if (up) {
+		int max = 4;
+		unsigned char byte;
+	
+		/* try to send some amount of bytes here before interrupts */
+		spin_lock_irqsave(&midi->output_lock, flags);
+		while (max > 0) {
+			if (mpu401_output_ready(emu, midi)) {
+				if (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT) ||
+				    snd_rawmidi_transmit(substream, &byte, 1) != 1) {
+					/* no more data */
+					spin_unlock_irqrestore(&midi->output_lock, flags);
+					return;
+				}
+				mpu401_write_data(emu, midi, byte);
+				max--;
+			} else {
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&midi->output_lock, flags);
+		snd_emu10k1x_intr_enable(emu, midi->tx_enable);
+	} else {
+		snd_emu10k1x_intr_disable(emu, midi->tx_enable);
+	}
+}
+
+/*
+
+ */
+
+static snd_rawmidi_ops_t snd_emu10k1x_midi_output =
+{
+	.open =		snd_emu10k1x_midi_output_open,
+	.close =	snd_emu10k1x_midi_output_close,
+	.trigger =	snd_emu10k1x_midi_output_trigger,
+};
+
+static snd_rawmidi_ops_t snd_emu10k1x_midi_input =
+{
+	.open =		snd_emu10k1x_midi_input_open,
+	.close =	snd_emu10k1x_midi_input_close,
+	.trigger =	snd_emu10k1x_midi_input_trigger,
+};
+
+static void snd_emu10k1x_midi_free(snd_rawmidi_t *rmidi)
+{
+	emu10k1x_midi_t *midi = (emu10k1x_midi_t *)rmidi->private_data;
+	midi->interrupt = NULL;
+	midi->rmidi = NULL;
+}
+
+static int __devinit emu10k1x_midi_init(emu10k1x_t *emu, emu10k1x_midi_t *midi, int device, char *name)
+{
+	snd_rawmidi_t *rmidi;
+	int err;
+
+	if ((err = snd_rawmidi_new(emu->card, name, device, 1, 1, &rmidi)) < 0)
+		return err;
+	midi->emu = emu;
+	spin_lock_init(&midi->open_lock);
+	spin_lock_init(&midi->input_lock);
+	spin_lock_init(&midi->output_lock);
+	strcpy(rmidi->name, name);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_emu10k1x_midi_output);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_emu10k1x_midi_input);
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
+	                     SNDRV_RAWMIDI_INFO_INPUT |
+	                     SNDRV_RAWMIDI_INFO_DUPLEX;
+	rmidi->private_data = midi;
+	rmidi->private_free = snd_emu10k1x_midi_free;
+	midi->rmidi = rmidi;
+	return 0;
+}
+
+static int __devinit snd_emu10k1x_midi(emu10k1x_t *emu)
+{
+	emu10k1x_midi_t *midi = &emu->midi;
+	int err;
+
+	if ((err = emu10k1x_midi_init(emu, midi, 0, "EMU10K1X MPU-401 (UART)")) < 0)
+		return err;
+
+	midi->tx_enable = INTE_MIDITXENABLE;
+	midi->rx_enable = INTE_MIDIRXENABLE;
+	midi->port = MUDATA;
+	midi->ipr_tx = IPR_MIDITRANSBUFEMPTY;
+	midi->ipr_rx = IPR_MIDIRECVBUFEMPTY;
+	midi->interrupt = snd_emu10k1x_midi_interrupt;
+	return 0;
+}
+
+static int __devinit snd_emu10k1x_probe(struct pci_dev *pci,
+					const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	emu10k1x_t *chip;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	if ((err = snd_emu10k1x_create(card, pci, &chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_emu10k1x_pcm(chip, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_emu10k1x_pcm(chip, 1, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_emu10k1x_pcm(chip, 2, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_emu10k1x_ac97(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_emu10k1x_mixer(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	
+	if ((err = snd_emu10k1x_midi(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	snd_emu10k1x_proc_init(chip);
+
+	strcpy(card->driver, "EMU10K1X");
+	strcpy(card->shortname, "Dell Sound Blaster Live!");
+	sprintf(card->longname, "%s at 0x%lx irq %i",
+		card->shortname, chip->port, chip->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_emu10k1x_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+// PCI IDs
+static struct pci_device_id snd_emu10k1x_ids[] = {
+	{ 0x1102, 0x0006, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* Dell OEM version (EMU10K1) */
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, snd_emu10k1x_ids);
+
+// pci_driver definition
+static struct pci_driver driver = {
+	.name = "EMU10K1X",
+	.id_table = snd_emu10k1x_ids,
+	.probe = snd_emu10k1x_probe,
+	.remove = __devexit_p(snd_emu10k1x_remove),
+};
+
+// initialization of the module
+static int __init alsa_card_emu10k1x_init(void)
+{
+	int err;
+
+	if ((err = pci_module_init(&driver)) > 0)
+		return err;
+
+	return 0;
+}
+
+// clean up the module
+static void __exit alsa_card_emu10k1x_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_emu10k1x_init)
+module_exit(alsa_card_emu10k1x_exit)
diff -uNr a/sound/pci/emu10k1/emufx.c b/sound/pci/emu10k1/emufx.c
--- a/sound/pci/emu10k1/emufx.c	2004-12-24 22:34:57.000000000 +0100
+++ b/sound/pci/emu10k1/emufx.c	2005-01-14 22:28:12.147511728 +0100
@@ -437,7 +437,7 @@
 }
 
 int snd_emu10k1_fx8010_unregister_irq_handler(emu10k1_t *emu,
-						     snd_emu10k1_fx8010_irq_t *irq)
+					      snd_emu10k1_fx8010_irq_t *irq)
 {
 	snd_emu10k1_fx8010_irq_t *tmp;
 	unsigned long flags;
@@ -470,8 +470,8 @@
 {
 	snd_assert(*ptr < 512, return);
 	set_bit(*ptr, icode->code_valid);
-	icode->code[*ptr    ][0] = ((x & 0x3ff) << 10) | (y & 0x3ff);
-	icode->code[(*ptr)++][1] = ((op & 0x0f) << 20) | ((r & 0x3ff) << 10) | (a & 0x3ff);
+	icode->code[(*ptr)   * 2 + 0] = ((x & 0x3ff) << 10) | (y & 0x3ff);
+	icode->code[(*ptr)++ * 2 + 1] = ((op & 0x0f) << 20) | ((r & 0x3ff) << 10) | (a & 0x3ff);
 }
 
 #define OP(icode, ptr, op, r, a, x, y) \
@@ -482,14 +482,14 @@
 {
 	snd_assert(*ptr < 1024, return);
 	set_bit(*ptr, icode->code_valid);
-	icode->code[*ptr    ][0] = ((x & 0x7ff) << 12) | (y & 0x7ff);
-	icode->code[(*ptr)++][1] = ((op & 0x0f) << 24) | ((r & 0x7ff) << 12) | (a & 0x7ff);
+	icode->code[(*ptr)   * 2 + 0] = ((x & 0x7ff) << 12) | (y & 0x7ff);
+	icode->code[(*ptr)++ * 2 + 1] = ((op & 0x0f) << 24) | ((r & 0x7ff) << 12) | (a & 0x7ff);
 }
 
 #define A_OP(icode, ptr, op, r, a, x, y) \
 	snd_emu10k1_audigy_write_op(icode, ptr, op, r, a, x, y)
 
-void snd_emu10k1_efx_write(emu10k1_t *emu, unsigned int pc, unsigned int data)
+static void snd_emu10k1_efx_write(emu10k1_t *emu, unsigned int pc, unsigned int data)
 {
 	pc += emu->audigy ? A_MICROCODEBASE : MICROCODEBASE;
 	snd_emu10k1_ptr_write(emu, pc, 0, data);
@@ -501,83 +501,108 @@
 	return snd_emu10k1_ptr_read(emu, pc, 0);
 }
 
-static void snd_emu10k1_gpr_poke(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
+static int snd_emu10k1_gpr_poke(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
 {
 	int gpr;
+	u32 val;
 
 	for (gpr = 0; gpr < (emu->audigy ? 0x200 : 0x100); gpr++) {
 		if (!test_bit(gpr, icode->gpr_valid))
 			continue;
-		snd_emu10k1_ptr_write(emu, emu->gpr_base + gpr, 0, icode->gpr_map[gpr]);
+		if (get_user(val, &icode->gpr_map[gpr]))
+			return -EFAULT;
+		snd_emu10k1_ptr_write(emu, emu->gpr_base + gpr, 0, val);
 	}
+	return 0;
 }
 
-static void snd_emu10k1_gpr_peek(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
+static int snd_emu10k1_gpr_peek(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
 {
 	int gpr;
+	u32 val;
 
 	for (gpr = 0; gpr < (emu->audigy ? 0x200 : 0x100); gpr++) {
 		set_bit(gpr, icode->gpr_valid);
-		icode->gpr_map[gpr] = snd_emu10k1_ptr_read(emu, emu->gpr_base + gpr, 0);
+		val = snd_emu10k1_ptr_read(emu, emu->gpr_base + gpr, 0);
+		if (put_user(val, &icode->gpr_map[gpr]))
+			return -EFAULT;
 	}
+	return 0;
 }
 
-static void snd_emu10k1_tram_poke(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
+static int snd_emu10k1_tram_poke(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
 {
 	int tram;
+	u32 addr, val;
 
 	for (tram = 0; tram < (emu->audigy ? 0x100 : 0xa0); tram++) {
 		if (!test_bit(tram, icode->tram_valid))
 			continue;
-		snd_emu10k1_ptr_write(emu, TANKMEMDATAREGBASE + tram, 0, icode->tram_data_map[tram]);
-		if (!emu->audigy)
-			snd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, icode->tram_addr_map[tram]);
-		else {
-			snd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, icode->tram_addr_map[tram] << 12);
-			snd_emu10k1_ptr_write(emu, A_TANKMEMCTLREGBASE + tram, 0, icode->tram_addr_map[tram] >> 20);
+		if (get_user(val, &icode->tram_data_map[tram]) ||
+		    get_user(addr, &icode->tram_addr_map[tram]))
+			return -EFAULT;
+		snd_emu10k1_ptr_write(emu, TANKMEMDATAREGBASE + tram, 0, val);
+		if (!emu->audigy) {
+			snd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, addr);
+		} else {
+			snd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, addr << 12);
+			snd_emu10k1_ptr_write(emu, A_TANKMEMCTLREGBASE + tram, 0, addr >> 20);
 		}
 	}
+	return 0;
 }
 
-static void snd_emu10k1_tram_peek(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
+static int snd_emu10k1_tram_peek(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
 {
 	int tram;
+	u32 val, addr;
 
 	memset(icode->tram_valid, 0, sizeof(icode->tram_valid));
 	for (tram = 0; tram < (emu->audigy ? 0x100 : 0xa0); tram++) {
 		set_bit(tram, icode->tram_valid);
-		icode->tram_data_map[tram] = snd_emu10k1_ptr_read(emu, TANKMEMDATAREGBASE + tram, 0);
-		if (!emu->audigy)
-			icode->tram_addr_map[tram] = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0);
-		else {
-			icode->tram_addr_map[tram] = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0) >> 12;
-			icode->tram_addr_map[tram] |= snd_emu10k1_ptr_read(emu, A_TANKMEMCTLREGBASE + tram, 0) << 20;
+		val = snd_emu10k1_ptr_read(emu, TANKMEMDATAREGBASE + tram, 0);
+		if (!emu->audigy) {
+			addr = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0);
+		} else {
+			addr = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0) >> 12;
+			addr |= snd_emu10k1_ptr_read(emu, A_TANKMEMCTLREGBASE + tram, 0) << 20;
 		}
+		if (put_user(val, &icode->tram_data_map[tram]) ||
+		    put_user(addr, &icode->tram_addr_map[tram]))
+			return -EFAULT;
 	}
+	return 0;
 }
 
-static void snd_emu10k1_code_poke(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
+static int snd_emu10k1_code_poke(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
 {
-	u32 pc;
+	u32 pc, lo, hi;
 
-	for (pc = 0; pc < (emu->audigy ? 1024 : 512); pc++) {
-		if (!test_bit(pc, icode->code_valid))
+	for (pc = 0; pc < (emu->audigy ? 2*1024 : 2*512); pc += 2) {
+		if (!test_bit(pc / 2, icode->code_valid))
 			continue;
-		snd_emu10k1_efx_write(emu, pc * 2, icode->code[pc][0]);
-		snd_emu10k1_efx_write(emu, pc * 2 + 1, icode->code[pc][1]);
+		if (get_user(lo, &icode->code[pc + 0]) ||
+		    get_user(hi, &icode->code[pc + 1]))
+			return -EFAULT;
+		snd_emu10k1_efx_write(emu, pc + 0, lo);
+		snd_emu10k1_efx_write(emu, pc + 1, hi);
 	}
+	return 0;
 }
 
-static void snd_emu10k1_code_peek(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
+static int snd_emu10k1_code_peek(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
 {
 	u32 pc;
 
 	memset(icode->code_valid, 0, sizeof(icode->code_valid));
-	for (pc = 0; pc < (emu->audigy ? 1024 : 512); pc++) {
-		set_bit(pc, icode->code_valid);
-		icode->code[pc][0] = snd_emu10k1_efx_read(emu, pc * 2);
-		icode->code[pc][1] = snd_emu10k1_efx_read(emu, pc * 2 + 1);
+	for (pc = 0; pc < (emu->audigy ? 2*1024 : 2*512); pc += 2) {
+		set_bit(pc / 2, icode->code_valid);
+		if (put_user(snd_emu10k1_efx_read(emu, pc + 0), &icode->code[pc + 0]))
+			return -EFAULT;
+		if (put_user(snd_emu10k1_efx_read(emu, pc + 1), &icode->code[pc + 1]))
+			return -EFAULT;
 	}
+	return 0;
 }
 
 static snd_emu10k1_fx8010_ctl_t *snd_emu10k1_look_for_ctl(emu10k1_t *emu, snd_ctl_elem_id_t *id)
@@ -647,7 +672,7 @@
 	kfree(ctl);
 }
 
-static void snd_emu10k1_add_controls(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
+static int snd_emu10k1_add_controls(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
 {
 	unsigned int i, j;
 	emu10k1_fx8010_control_gpr_t __user *_gctl;
@@ -656,17 +681,20 @@
 	snd_kcontrol_new_t knew;
 	snd_kcontrol_t *kctl;
 	snd_ctl_elem_value_t *val;
+	int err = 0;
 
 	val = (snd_ctl_elem_value_t *)kmalloc(sizeof(*val), GFP_KERNEL);
 	if (!val)
-		return;
+		return -ENOMEM;
 	for (i = 0, _gctl = icode->gpr_add_controls;
 	     i < icode->gpr_add_control_count; i++, _gctl++) {
-		if (copy_from_user(&gctl, _gctl, sizeof(gctl)))
-			break;
+		if (copy_from_user(&gctl, _gctl, sizeof(gctl))) {
+			err = -EFAULT;
+			goto __error;
+		}
 		snd_runtime_check(gctl.id.iface == SNDRV_CTL_ELEM_IFACE_MIXER ||
-		                  gctl.id.iface == SNDRV_CTL_ELEM_IFACE_PCM, continue);
-		snd_runtime_check(gctl.id.name[0] != '\0', continue);
+		                  gctl.id.iface == SNDRV_CTL_ELEM_IFACE_PCM, err = -EINVAL; goto __error);
+		snd_runtime_check(gctl.id.name[0] != '\0', err = -EINVAL; goto __error);
 		ctl = snd_emu10k1_look_for_ctl(emu, &gctl.id);
 		memset(&knew, 0, sizeof(knew));
 		knew.iface = gctl.id.iface;
@@ -694,9 +722,9 @@
 				continue;
 			knew.private_value = (unsigned long)ctl;
 			memcpy(ctl, &nctl, sizeof(nctl));
-			if (snd_ctl_add(emu->card, kctl = snd_ctl_new1(&knew, emu)) < 0) {
+			if ((err = snd_ctl_add(emu->card, kctl = snd_ctl_new1(&knew, emu))) < 0) {
 				kfree(ctl);
-				continue;
+				goto __error;
 			}
 			kctl->private_free = snd_emu10k1_ctl_private_free;
 			ctl->kcontrol = kctl;
@@ -711,10 +739,12 @@
 		}
 		snd_emu10k1_gpr_ctl_put(ctl->kcontrol, val);
 	}
+      __error:
 	kfree(val);
+	return err;
 }
 
-static void snd_emu10k1_del_controls(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
+static int snd_emu10k1_del_controls(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
 {
 	unsigned int i;
 	snd_ctl_elem_id_t id;
@@ -724,13 +754,14 @@
 	
 	for (i = 0, _id = icode->gpr_del_controls;
 	     i < icode->gpr_del_control_count; i++, _id++) {
-	     	snd_runtime_check(copy_from_user(&id, _id, sizeof(id)) == 0, continue);
+	     	snd_runtime_check(copy_from_user(&id, _id, sizeof(id)) == 0, return -EFAULT);
 		down_write(&card->controls_rwsem);
 		ctl = snd_emu10k1_look_for_ctl(emu, &id);
 		if (ctl)
 			snd_ctl_remove(card, ctl->kcontrol);
 		up_write(&card->controls_rwsem);
 	}
+	return 0;
 }
 
 static int snd_emu10k1_list_controls(emu10k1_t *emu, emu10k1_fx8010_code_t *icode)
@@ -789,11 +820,12 @@
 	else
 		snd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg | EMU10K1_DBG_SINGLE_STEP);
 	/* ok, do the main job */
-	snd_emu10k1_del_controls(emu, icode);
-	snd_emu10k1_gpr_poke(emu, icode);
-	snd_emu10k1_tram_poke(emu, icode);
-	snd_emu10k1_code_poke(emu, icode);
-	snd_emu10k1_add_controls(emu, icode);
+	if ((err = snd_emu10k1_del_controls(emu, icode)) < 0 ||
+	    (err = snd_emu10k1_gpr_poke(emu, icode)) < 0 ||
+	    (err = snd_emu10k1_tram_poke(emu, icode)) < 0 ||
+	    (err = snd_emu10k1_code_poke(emu, icode)) < 0 ||
+	    (err = snd_emu10k1_add_controls(emu, icode)) < 0)
+		goto __error;
 	/* start FX processor when the DSP code is updated */
 	if (emu->audigy)
 		snd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg);
@@ -811,10 +843,13 @@
 	down(&emu->fx8010.lock);
 	strlcpy(icode->name, emu->fx8010.name, sizeof(icode->name));
 	/* ok, do the main job */
-	snd_emu10k1_gpr_peek(emu, icode);
-	snd_emu10k1_tram_peek(emu, icode);
-	snd_emu10k1_code_peek(emu, icode);
-	err = snd_emu10k1_list_controls(emu, icode);
+	err = snd_emu10k1_gpr_peek(emu, icode);
+	if (err >= 0)
+		err = snd_emu10k1_tram_peek(emu, icode);
+	if (err >= 0)
+		err = snd_emu10k1_code_peek(emu, icode);
+	if (err >= 0)
+		err = snd_emu10k1_list_controls(emu, icode);
 	up(&emu->fx8010.lock);
 	return err;
 }
@@ -957,20 +992,24 @@
 	const int stereo_mix = capture + 2;
 	const int tmp = 0x88;
 	u32 ptr;
-	emu10k1_fx8010_code_t *icode;
-	emu10k1_fx8010_control_gpr_t *controls, *ctl;
+	emu10k1_fx8010_code_t *icode = NULL;
+	emu10k1_fx8010_control_gpr_t *controls = NULL, *ctl;
 	mm_segment_t seg;
 
 	spin_lock_init(&emu->fx8010.irq_lock);
 	INIT_LIST_HEAD(&emu->fx8010.gpr_ctl);
 
-	if ((icode = kcalloc(1, sizeof(*icode), GFP_KERNEL)) == NULL)
-		return -ENOMEM;
-	if ((controls = kcalloc(SND_EMU10K1_GPR_CONTROLS, sizeof(*controls), GFP_KERNEL)) == NULL) {
-		kfree(icode);
-		return -ENOMEM;
+	if ((icode = kcalloc(1, sizeof(*icode), GFP_KERNEL)) == NULL ||
+	    (icode->gpr_map = kcalloc(512 + 256 + 256 + 2 * 1024, sizeof(u_int32_t), GFP_KERNEL)) == NULL ||
+	    (controls = kcalloc(SND_EMU10K1_GPR_CONTROLS, sizeof(*controls), GFP_KERNEL)) == NULL) {
+		err = -ENOMEM;
+		goto __err;
 	}
 
+	icode->tram_data_map = icode->gpr_map + 512;
+	icode->tram_addr_map = icode->tram_data_map + 256;
+	icode->code = icode->tram_addr_map + 256;
+
 	/* clear free GPRs */
 	for (i = 0; i < 512; i++)
 		set_bit(i, icode->gpr_valid);
@@ -1312,8 +1351,12 @@
 	A_PUT_OUTPUT(A_EXTOUT_LFE, playback+5 + SND_EMU10K1_PLAYBACK_CHANNELS);
 
 	/* ADC buffer */
+#ifdef EMU10K1_CAPTURE_DIGITAL_OUT
+	A_PUT_STEREO_OUTPUT(A_EXTOUT_ADC_CAP_L, A_EXTOUT_ADC_CAP_R, playback + SND_EMU10K1_PLAYBACK_CHANNELS);
+#else
 	A_PUT_OUTPUT(A_EXTOUT_ADC_CAP_L, capture);
 	A_PUT_OUTPUT(A_EXTOUT_ADC_CAP_R, capture+1);
+#endif
 
 	/*
 	 * ok, set up done..
@@ -1335,8 +1378,13 @@
 	snd_leave_user(seg);
 
  __err:
-	kfree(controls);
-	kfree(icode);
+ 	if (controls != NULL)
+		kfree(controls);
+	if (icode != NULL) {
+		if (icode->gpr_map != NULL)
+			kfree(icode->gpr_map);
+		kfree(icode);
+	}
 	return err;
 }
 
@@ -1398,8 +1446,8 @@
 	int err, i, z, gpr, tmp, playback, capture;
 	u32 ptr;
 	emu10k1_fx8010_code_t *icode;
-	emu10k1_fx8010_pcm_t *ipcm;
-	emu10k1_fx8010_control_gpr_t *controls, *ctl;
+	emu10k1_fx8010_pcm_t *ipcm = NULL;
+	emu10k1_fx8010_control_gpr_t *controls = NULL, *ctl;
 	mm_segment_t seg;
 
 	spin_lock_init(&emu->fx8010.irq_lock);
@@ -1407,15 +1455,16 @@
 
 	if ((icode = kcalloc(1, sizeof(*icode), GFP_KERNEL)) == NULL)
 		return -ENOMEM;
-	if ((controls = kcalloc(SND_EMU10K1_GPR_CONTROLS, sizeof(emu10k1_fx8010_control_gpr_t), GFP_KERNEL)) == NULL) {
-		kfree(icode);
-		return -ENOMEM;
-	}
-	if ((ipcm = kcalloc(1, sizeof(*ipcm), GFP_KERNEL)) == NULL) {
-		kfree(controls);
-		kfree(icode);
-		return -ENOMEM;
+	if ((icode->gpr_map = kcalloc(256 + 160 + 160 + 2 * 512, sizeof(u_int32_t), GFP_KERNEL)) == NULL ||
+            (controls = kcalloc(SND_EMU10K1_GPR_CONTROLS, sizeof(emu10k1_fx8010_control_gpr_t), GFP_KERNEL)) == NULL ||
+	    (ipcm = kcalloc(1, sizeof(*ipcm), GFP_KERNEL)) == NULL) {
+		err = -ENOMEM;
+		goto __err;
 	}
+
+	icode->tram_data_map = icode->gpr_map + 256;
+	icode->tram_addr_map = icode->tram_data_map + 160;
+	icode->code = icode->tram_addr_map + 160;
 	
 	/* clear free GPRs */
 	for (i = 0; i < 256; i++)
@@ -1906,9 +1955,15 @@
 	if (err >= 0)
 		err = snd_emu10k1_ipcm_poke(emu, ipcm);
       __err:
-	kfree(ipcm);
-	kfree(controls);
-	kfree(icode);
+      	if (ipcm != NULL)
+		kfree(ipcm);
+	if (controls != NULL)
+		kfree(controls);
+	if (icode != NULL) {
+		if (icode->gpr_map != NULL)
+			kfree(icode->gpr_map);
+		kfree(icode);
+	}
 	return err;
 }
 
@@ -1959,7 +2014,7 @@
 		}
 		size = 0x2000 << size_reg;
 	}
-	if (emu->fx8010.etram_pages.bytes == size)
+	if ((emu->fx8010.etram_pages.bytes / 2) == size)
 		return 0;
 	spin_lock_irq(&emu->emu_lock);
 	outl(HCFG_LOCKTANKCACHE_MASK | inl(emu->port + HCFG), emu->port + HCFG);
diff -uNr a/sound/pci/emu10k1/emumixer.c b/sound/pci/emu10k1/emumixer.c
--- a/sound/pci/emu10k1/emumixer.c	2004-12-24 22:35:25.000000000 +0100
+++ b/sound/pci/emu10k1/emumixer.c	2005-01-14 22:28:12.157510208 +0100
@@ -54,7 +54,7 @@
 	ucontrol->value.iec958.status[2] = (emu->spdif_bits[idx] >> 16) & 0xff;
 	ucontrol->value.iec958.status[3] = (emu->spdif_bits[idx] >> 24) & 0xff;
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return 0;
+	return 0;
 }
 
 static int snd_emu10k1_spdif_get_mask(snd_kcontrol_t * kcontrol,
@@ -64,7 +64,7 @@
 	ucontrol->value.iec958.status[1] = 0xff;
 	ucontrol->value.iec958.status[2] = 0xff;
 	ucontrol->value.iec958.status[3] = 0xff;
-        return 0;
+	return 0;
 }
 
 static int snd_emu10k1_spdif_put(snd_kcontrol_t * kcontrol,
@@ -87,27 +87,27 @@
 		emu->spdif_bits[idx] = val;
 	}
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return change;
+	return change;
 }
 
 static snd_kcontrol_new_t snd_emu10k1_spdif_mask_control =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
-        .name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+	.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
 	.count =	4,
-        .info =         snd_emu10k1_spdif_info,
-        .get =          snd_emu10k1_spdif_get_mask
+	.info =         snd_emu10k1_spdif_info,
+	.get =          snd_emu10k1_spdif_get_mask
 };
 
 static snd_kcontrol_new_t snd_emu10k1_spdif_control =
 {
-        .iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
-        .name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
 	.count =	4,
-        .info =         snd_emu10k1_spdif_info,
-        .get =          snd_emu10k1_spdif_get,
-        .put =          snd_emu10k1_spdif_put
+	.info =         snd_emu10k1_spdif_info,
+	.get =          snd_emu10k1_spdif_get,
+	.put =          snd_emu10k1_spdif_put
 };
 
 
@@ -165,7 +165,7 @@
 			ucontrol->value.integer.value[(voice * num_efx) + idx] = 
 				mix->send_routing[voice][idx] & mask;
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return 0;
+	return 0;
 }
 
 static int snd_emu10k1_send_routing_put(snd_kcontrol_t * kcontrol,
@@ -199,18 +199,18 @@
 		}
 	}
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return change;
+	return change;
 }
 
 static snd_kcontrol_new_t snd_emu10k1_send_routing_control =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
-        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
-        .name =         "EMU10K1 PCM Send Routing",
+	.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "EMU10K1 PCM Send Routing",
 	.count =	32,
-        .info =         snd_emu10k1_send_routing_info,
-        .get =          snd_emu10k1_send_routing_get,
-        .put =          snd_emu10k1_send_routing_put
+	.info =         snd_emu10k1_send_routing_info,
+	.get =          snd_emu10k1_send_routing_get,
+	.put =          snd_emu10k1_send_routing_put
 };
 
 static int snd_emu10k1_send_volume_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
@@ -236,7 +236,7 @@
 	for (idx = 0; idx < 3*num_efx; idx++)
 		ucontrol->value.integer.value[idx] = mix->send_volume[idx/num_efx][idx%num_efx];
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return 0;
+	return 0;
 }
 
 static int snd_emu10k1_send_volume_put(snd_kcontrol_t * kcontrol,
@@ -268,18 +268,18 @@
 		}
 	}
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return change;
+	return change;
 }
 
 static snd_kcontrol_new_t snd_emu10k1_send_volume_control =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
-        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
-        .name =         "EMU10K1 PCM Send Volume",
+	.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "EMU10K1 PCM Send Volume",
 	.count =	32,
-        .info =         snd_emu10k1_send_volume_info,
-        .get =          snd_emu10k1_send_volume_get,
-        .put =          snd_emu10k1_send_volume_put
+	.info =         snd_emu10k1_send_volume_info,
+	.get =          snd_emu10k1_send_volume_get,
+	.put =          snd_emu10k1_send_volume_put
 };
 
 static int snd_emu10k1_attn_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
@@ -303,7 +303,7 @@
 	for (idx = 0; idx < 3; idx++)
 		ucontrol->value.integer.value[idx] = mix->attn[idx];
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return 0;
+	return 0;
 }
 
 static int snd_emu10k1_attn_put(snd_kcontrol_t * kcontrol,
@@ -331,18 +331,18 @@
 		}
 	}
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return change;
+	return change;
 }
 
 static snd_kcontrol_new_t snd_emu10k1_attn_control =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
-        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
-        .name =         "EMU10K1 PCM Volume",
+	.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "EMU10K1 PCM Volume",
 	.count =	32,
-        .info =         snd_emu10k1_attn_info,
-        .get =          snd_emu10k1_attn_get,
-        .put =          snd_emu10k1_attn_put
+	.info =         snd_emu10k1_attn_info,
+	.get =          snd_emu10k1_attn_get,
+	.put =          snd_emu10k1_attn_put
 };
 
 static int snd_emu10k1_shared_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
@@ -363,7 +363,7 @@
 		ucontrol->value.integer.value[0] = inl(emu->port + A_IOCFG) & A_IOCFG_GPOUT0 ? 1 : 0;
 	else
 		ucontrol->value.integer.value[0] = inl(emu->port + HCFG) & HCFG_GPOUT0 ? 1 : 0;
-        return 0;
+	return 0;
 }
 
 static int snd_emu10k1_shared_spdif_put(snd_kcontrol_t * kcontrol,
@@ -394,7 +394,7 @@
 		outl(reg | val, emu->port + HCFG);
 	}
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
-        return change;
+	return change;
 }
 
 static snd_kcontrol_new_t snd_emu10k1_shared_spdif __devinitdata =
@@ -519,6 +519,7 @@
 
 		if ((err = snd_ac97_bus(emu->card, 0, &ops, NULL, &pbus)) < 0)
 			return err;
+		pbus->no_vra = 1; /* we don't need VRA */
 		
 		memset(&ac97, 0, sizeof(ac97));
 		ac97.private_data = emu;
diff -uNr a/sound/pci/emu10k1/emupcm.c b/sound/pci/emu10k1/emupcm.c
--- a/sound/pci/emu10k1/emupcm.c	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/pci/emu10k1/emupcm.c	2005-01-14 22:28:12.161509600 +0100
@@ -267,6 +267,7 @@
 		send_routing[3] = 3;
 		memset(send_amount, 0, sizeof(send_amount));
 	} else {
+		/* mono, left, right (master voice = left) */
 		tmp = stereo ? (master ? 1 : 2) : 0;
 		memcpy(send_routing, &mix->send_routing[tmp][0], 8);
 		memcpy(send_amount, &mix->send_volume[tmp][0], 8);
@@ -292,15 +293,9 @@
 	// setup routing
 	if (emu->audigy) {
 		snd_emu10k1_ptr_write(emu, A_FXRT1, voice,
-				      ((unsigned int)send_routing[3] << 24) |
-				      ((unsigned int)send_routing[2] << 16) |
-				      ((unsigned int)send_routing[1] << 8) |
-				      (unsigned int)send_routing[0]);
+				      snd_emu10k1_compose_audigy_fxrt1(send_routing));
 		snd_emu10k1_ptr_write(emu, A_FXRT2, voice,
-				      ((unsigned int)send_routing[7] << 24) |
-				      ((unsigned int)send_routing[6] << 16) |
-				      ((unsigned int)send_routing[5] << 8) |
-				      (unsigned int)send_routing[4]);
+				      snd_emu10k1_compose_audigy_fxrt2(send_routing));
 		snd_emu10k1_ptr_write(emu, A_SENDAMOUNTS, voice,
 				      ((unsigned int)send_amount[4] << 24) |
 				      ((unsigned int)send_amount[5] << 16) |
@@ -777,8 +772,7 @@
 {
 	emu10k1_pcm_t *epcm = runtime->private_data;
 
-	if (epcm)
-		kfree(epcm);
+	kfree(epcm);
 }
 
 static int snd_emu10k1_playback_open(snd_pcm_substream_t * substream)
diff -uNr a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c
--- a/sound/pci/emu10k1/emuproc.c	2004-12-24 22:34:31.000000000 +0100
+++ b/sound/pci/emu10k1/emuproc.c	2005-01-14 22:28:12.165508992 +0100
@@ -175,32 +175,45 @@
 	};
 
 	emu10k1_t *emu = entry->private_data;
-	unsigned int val;
+	unsigned int val, val1;
 	int nefx = emu->audigy ? 64 : 32;
 	char **outputs = emu->audigy ? audigy_outs : creative_outs;
 	int idx;
 	
 	snd_iprintf(buffer, "EMU10K1\n\n");
-	val = emu->audigy ?
-		snd_emu10k1_ptr_read(emu, A_FXRT1, 0) :
-		snd_emu10k1_ptr_read(emu, FXRT, 0);
 	snd_iprintf(buffer, "Card                  : %s\n",
 		    emu->audigy ? "Audigy" : (emu->APS ? "EMU APS" : "Creative"));
 	snd_iprintf(buffer, "Internal TRAM (words) : 0x%x\n", emu->fx8010.itram_size);
 	snd_iprintf(buffer, "External TRAM (words) : 0x%x\n", (int)emu->fx8010.etram_pages.bytes);
 	snd_iprintf(buffer, "\n");
-	if (emu->audigy) {
-		snd_iprintf(buffer, "Effect Send Routing   : A=%i, B=%i, C=%i, D=%i\n",
-			    val & 0x3f,
-			    (val >> 8) & 0x3f,
-			    (val >> 16) & 0x3f,
-			    (val >> 24) & 0x3f);
-	} else {
-		snd_iprintf(buffer, "Effect Send Routing   : A=%i, B=%i, C=%i, D=%i\n",
-			    (val >> 16) & 0x0f,
-			    (val >> 20) & 0x0f,
-			    (val >> 24) & 0x0f,
-			    (val >> 28) & 0x0f);
+	snd_iprintf(buffer, "Effect Send Routing   :\n");
+	for (idx = 0; idx < NUM_G; idx++) {
+		val = emu->audigy ?
+			snd_emu10k1_ptr_read(emu, A_FXRT1, idx) :
+			snd_emu10k1_ptr_read(emu, FXRT, idx);
+		val1 = emu->audigy ?
+			snd_emu10k1_ptr_read(emu, A_FXRT2, idx) :
+			0;
+		if (emu->audigy) {
+			snd_iprintf(buffer, "Ch%i: A=%i, B=%i, C=%i, D=%i, ",
+				idx,
+				val & 0x3f,
+				(val >> 8) & 0x3f,
+				(val >> 16) & 0x3f,
+				(val >> 24) & 0x3f);
+			snd_iprintf(buffer, "E=%i, F=%i, G=%i, H=%i\n",
+				val1 & 0x3f,
+				(val1 >> 8) & 0x3f,
+				(val1 >> 16) & 0x3f,
+				(val1 >> 24) & 0x3f);
+		} else {
+			snd_iprintf(buffer, "Ch%i: A=%i, B=%i, C=%i, D=%i\n",
+				idx,
+				(val >> 16) & 0x0f,
+				(val >> 20) & 0x0f,
+				(val >> 24) & 0x0f,
+				(val >> 28) & 0x0f);
+		}
 	}
 	snd_iprintf(buffer, "\nCaptured FX Outputs   :\n");
 	for (idx = 0; idx < nefx; idx++) {
@@ -309,6 +322,152 @@
 	return 0;
 }
 
+#ifdef CONFIG_SND_DEBUG
+static void snd_emu_proc_io_reg_read(snd_info_entry_t *entry,
+				     snd_info_buffer_t * buffer)
+{
+	emu10k1_t *emu = entry->private_data;
+	unsigned long value;
+	unsigned long flags;
+	int i;
+	snd_iprintf(buffer, "IO Registers:\n\n");
+	for(i = 0; i < 0x40; i+=4) {
+		spin_lock_irqsave(&emu->emu_lock, flags);
+		value = inl(emu->port + i);
+		spin_unlock_irqrestore(&emu->emu_lock, flags);
+		snd_iprintf(buffer, "%02X: %08lX\n", i, value);
+	}
+}
+
+static void snd_emu_proc_io_reg_write(snd_info_entry_t *entry,
+                                      snd_info_buffer_t * buffer)
+{
+	emu10k1_t *emu = entry->private_data;
+	unsigned long flags;
+	char line[64];
+	u32 reg, val;
+	while (!snd_info_get_line(buffer, line, sizeof(line))) {
+		if (sscanf(line, "%x %x", &reg, &val) != 2)
+			continue;
+		if ((reg < 0x40) && (reg >=0) && (val <= 0xffffffff) ) {
+			spin_lock_irqsave(&emu->emu_lock, flags);
+			outl(val, emu->port + (reg & 0xfffffffc));
+			spin_unlock_irqrestore(&emu->emu_lock, flags);
+		}
+	}
+}
+
+static unsigned int snd_ptr_read(emu10k1_t * emu,
+				 unsigned int iobase,
+				 unsigned int reg,
+				 unsigned int chn)
+{
+	unsigned long flags;
+	unsigned int regptr, val;
+
+	regptr = (reg << 16) | chn;
+
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outl(regptr, emu->port + iobase + PTR);
+	val = inl(emu->port + iobase + DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+	return val;
+}
+
+static void snd_ptr_write(emu10k1_t *emu,
+			  unsigned int iobase,
+			  unsigned int reg,
+			  unsigned int chn,
+			  unsigned int data)
+{
+	unsigned int regptr;
+	unsigned long flags;
+
+	regptr = (reg << 16) | chn;
+
+	spin_lock_irqsave(&emu->emu_lock, flags);
+	outl(regptr, emu->port + iobase + PTR);
+	outl(data, emu->port + iobase + DATA);
+	spin_unlock_irqrestore(&emu->emu_lock, flags);
+}
+
+
+static void snd_emu_proc_ptr_reg_read(snd_info_entry_t *entry,
+				      snd_info_buffer_t * buffer, int iobase, int offset, int length)
+{
+	emu10k1_t *emu = entry->private_data;
+	unsigned long value;
+	int i,j;
+	if (offset+length > 0x80) {
+		snd_iprintf(buffer, "Input values out of range\n");
+		return;
+	}
+	snd_iprintf(buffer, "Registers 0x%x\n", iobase);
+	for(i = offset; i < offset+length; i++) {
+		snd_iprintf(buffer, "%02X: ",i);
+		for (j = 0; j < 4; j++) {
+			if(iobase == 0)
+                		value = snd_ptr_read(emu, 0, i, j);
+			else
+                		value = snd_ptr_read(emu, 0x20, i, j);
+			snd_iprintf(buffer, "%08lX ", value);
+		}
+		snd_iprintf(buffer, "\n");
+	}
+}
+
+static void snd_emu_proc_ptr_reg_write(snd_info_entry_t *entry,
+				       snd_info_buffer_t * buffer, int iobase)
+{
+	emu10k1_t *emu = entry->private_data;
+	char line[64];
+	unsigned int reg, channel_id , val;
+	while (!snd_info_get_line(buffer, line, sizeof(line))) {
+		if (sscanf(line, "%x %x %x", &reg, &channel_id, &val) != 3)
+			continue;
+		if ((reg < 0x80) && (reg >=0) && (val <= 0xffffffff) && (channel_id >=0) && (channel_id <= 3) )
+			snd_ptr_write(emu, iobase, reg, channel_id, val);
+	}
+}
+
+static void snd_emu_proc_ptr_reg_write00(snd_info_entry_t *entry,
+					 snd_info_buffer_t * buffer)
+{
+	snd_emu_proc_ptr_reg_write(entry, buffer, 0);
+}
+
+static void snd_emu_proc_ptr_reg_write20(snd_info_entry_t *entry,
+					 snd_info_buffer_t * buffer)
+{
+	snd_emu_proc_ptr_reg_write(entry, buffer, 0x20);
+}
+	
+
+static void snd_emu_proc_ptr_reg_read00a(snd_info_entry_t *entry,
+					 snd_info_buffer_t * buffer)
+{
+	snd_emu_proc_ptr_reg_read(entry, buffer, 0, 0, 0x40);
+}
+
+static void snd_emu_proc_ptr_reg_read00b(snd_info_entry_t *entry,
+					 snd_info_buffer_t * buffer)
+{
+	snd_emu_proc_ptr_reg_read(entry, buffer, 0, 0x40, 0x40);
+}
+
+static void snd_emu_proc_ptr_reg_read20a(snd_info_entry_t *entry,
+					 snd_info_buffer_t * buffer)
+{
+	snd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0, 0x40);
+}
+
+static void snd_emu_proc_ptr_reg_read20b(snd_info_entry_t *entry,
+					 snd_info_buffer_t * buffer)
+{
+	snd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0x40, 0x40);
+}
+#endif
+
 static struct snd_info_entry_ops snd_emu10k1_proc_ops_fx8010 = {
 	.read = snd_emu10k1_fx8010_read,
 };
@@ -316,9 +475,36 @@
 int __devinit snd_emu10k1_proc_init(emu10k1_t * emu)
 {
 	snd_info_entry_t *entry;
+#ifdef CONFIG_SND_DEBUG
+	if (! snd_card_proc_new(emu->card, "io_regs", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_emu_proc_io_reg_read);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_emu_proc_io_reg_write;
+	}
+	if (! snd_card_proc_new(emu->card, "ptr_regs00a", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_emu_proc_ptr_reg_read00a);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_emu_proc_ptr_reg_write00;
+	}
+	if (! snd_card_proc_new(emu->card, "ptr_regs00b", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_emu_proc_ptr_reg_read00b);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_emu_proc_ptr_reg_write00;
+	}
+	if (! snd_card_proc_new(emu->card, "ptr_regs20a", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_emu_proc_ptr_reg_read20a);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_emu_proc_ptr_reg_write20;
+	}
+	if (! snd_card_proc_new(emu->card, "ptr_regs20b", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_emu_proc_ptr_reg_read20b);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_emu_proc_ptr_reg_write20;
+	}
+#endif
 	
 	if (! snd_card_proc_new(emu->card, "emu10k1", &entry))
-		snd_info_set_text_ops(entry, emu, 1024, snd_emu10k1_proc_read);
+		snd_info_set_text_ops(entry, emu, 2048, snd_emu10k1_proc_read);
 
 	if (! snd_card_proc_new(emu->card, "fx8010_gpr", &entry)) {
 		entry->content = SNDRV_INFO_CONTENT_DATA;
diff -uNr a/sound/pci/emu10k1/io.c b/sound/pci/emu10k1/io.c
--- a/sound/pci/emu10k1/io.c	2004-12-24 22:34:30.000000000 +0100
+++ b/sound/pci/emu10k1/io.c	2005-01-14 22:28:12.185505952 +0100
@@ -313,28 +313,3 @@
 	return 0;		/* Should never reach this point */
 }
 
-/*
- *  Returns an attenuation based upon a cumulative volume value
- *  Algorithm calculates 0x200 - 0x10 log2 (input)
- */
- 
-unsigned char snd_emu10k1_sum_vol_attn(unsigned int value)
-{
-	unsigned short count = 16, ans;
-
-	if (value == 0)
-		return 0xFF;
-
-	/* Find first SET bit. This is the integer part of the value */
-	while ((value & 0x10000) == 0) {
-		value <<= 1;
-		count--;
-	}
-
-	/* The REST of the data is the fractional part. */
-	ans = (unsigned short) (0x110 - ((count << 4) + ((value & 0x0FFFFL) >> 12)));
-	if (ans > 0xFF)
-		ans = 0xFF;
-
-	return (unsigned char) ans;
-}
diff -uNr a/sound/pci/emu10k1/irq.c b/sound/pci/emu10k1/irq.c
--- a/sound/pci/emu10k1/irq.c	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/pci/emu10k1/irq.c	2005-01-14 22:28:12.187505648 +0100
@@ -112,8 +112,8 @@
 			status &= ~(IPR_A_MIDITRANSBUFEMPTY2|IPR_A_MIDIRECVBUFEMPTY2);
 		}
 		if (status & IPR_INTERVALTIMER) {
-			if (emu->timer_interrupt)
-				emu->timer_interrupt(emu);
+			if (emu->timer)
+				snd_timer_interrupt(emu->timer, emu->timer->sticks);
 			else
 				snd_emu10k1_intr_disable(emu, INTE_INTERVALTIMERENB);
 			status &= ~IPR_INTERVALTIMER;
diff -uNr a/sound/pci/emu10k1/Makefile b/sound/pci/emu10k1/Makefile
--- a/sound/pci/emu10k1/Makefile	2004-12-24 22:34:32.000000000 +0100
+++ b/sound/pci/emu10k1/Makefile	2005-01-14 22:28:12.188505496 +0100
@@ -5,8 +5,9 @@
 
 snd-emu10k1-objs := emu10k1.o emu10k1_main.o \
 		    irq.o memory.o voice.o emumpu401.o emupcm.o io.o \
-		    emuproc.o emumixer.o emufx.o
+		    emuproc.o emumixer.o emufx.o timer.o
 snd-emu10k1-synth-objs := emu10k1_synth.o emu10k1_callback.o emu10k1_patch.o
+snd-emu10k1x-objs := emu10k1x.o
 
 #
 # this function returns:
@@ -19,3 +20,4 @@
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_EMU10K1) += snd-emu10k1.o
 obj-$(call sequencer,$(CONFIG_SND_EMU10K1)) += snd-emu10k1-synth.o
+obj-$(CONFIG_SND_EMU10K1X) += snd-emu10k1x.o
diff -uNr a/sound/pci/emu10k1/timer.c b/sound/pci/emu10k1/timer.c
--- a/sound/pci/emu10k1/timer.c	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/pci/emu10k1/timer.c	2005-01-14 22:28:12.190505192 +0100
@@ -0,0 +1,99 @@
+/*
+ *  Copyright (c) by Lee Revell <rlrevell@joe-job.com>
+ *  
+ *  Routines for control of EMU10K1 chips
+ *
+ *  Copied from similar code by Clemens Ladisch in the ymfpci driver
+ * 
+ *  BUGS:
+ *    --
+ *
+ *  TODO:
+ *    --
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/time.h>
+#include <sound/core.h>
+#include <sound/emu10k1.h>
+
+static int snd_emu10k1_timer_start(snd_timer_t *timer)
+{
+	emu10k1_t *emu;
+	unsigned long flags;
+	unsigned int delay;
+
+	emu = snd_timer_chip(timer);
+	delay = timer->sticks - 1;
+	if (delay < 5 ) /* minimum time is 5 ticks */
+		delay = 5;
+	spin_lock_irqsave(&emu->reg_lock, flags);
+	snd_emu10k1_intr_enable(emu, INTE_INTERVALTIMERENB);
+	outw(delay & TIMER_RATE_MASK, emu->port + TIMER);
+	spin_unlock_irqrestore(&emu->reg_lock, flags);
+	return 0;
+}
+
+static int snd_emu10k1_timer_stop(snd_timer_t *timer)
+{
+	emu10k1_t *emu;
+	unsigned long flags;
+
+	emu = snd_timer_chip(timer);
+	spin_lock_irqsave(&emu->reg_lock, flags);
+	snd_emu10k1_intr_disable(emu, INTE_INTERVALTIMERENB);
+	spin_unlock_irqrestore(&emu->reg_lock, flags);
+	return 0;
+}
+
+static int snd_emu10k1_timer_precise_resolution(snd_timer_t *timer,
+					       unsigned long *num, unsigned long *den)
+{
+	*num = 1;
+	*den = 48000;
+	return 0;
+}
+
+static struct _snd_timer_hardware snd_emu10k1_timer_hw = {
+	.flags = SNDRV_TIMER_HW_AUTO,
+	.resolution = 20833, /* 1 sample @ 48KHZ = 20.833...us */
+	.ticks = 1024,
+	.start = snd_emu10k1_timer_start,
+	.stop = snd_emu10k1_timer_stop,
+	.precise_resolution = snd_emu10k1_timer_precise_resolution,
+};
+
+int __devinit snd_emu10k1_timer(emu10k1_t *emu, int device)
+{
+	snd_timer_t *timer = NULL;
+	snd_timer_id_t tid;
+	int err;
+
+	tid.dev_class = SNDRV_TIMER_CLASS_CARD;
+	tid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;
+	tid.card = emu->card->number;
+	tid.device = device;
+	tid.subdevice = 0;
+	if ((err = snd_timer_new(emu->card, "EMU10K1", &tid, &timer)) >= 0) {
+		strcpy(timer->name, "EMU10K1 timer");
+		timer->private_data = emu;
+		timer->hw = snd_emu10k1_timer_hw;
+	}
+	emu->timer = timer;
+	return err;
+}
diff -uNr a/sound/pci/ens1370.c b/sound/pci/ens1370.c
--- a/sound/pci/ens1370.c	2004-12-24 22:35:24.000000000 +0100
+++ b/sound/pci/ens1370.c	2005-01-14 22:28:12.202503368 +0100
@@ -573,24 +573,18 @@
 				   unsigned short reg, unsigned short val)
 {
 	ensoniq_t *ensoniq = ak4531->private_data;
-	unsigned long flags;
 	unsigned long end_time = jiffies + HZ / 10;
 
 #if 0
 	printk("CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\n", reg, val, ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
 #endif
 	do {
-		spin_lock_irqsave(&ensoniq->reg_lock, flags);
 		if (!(inl(ES_REG(ensoniq, STATUS)) & ES_1370_CSTAT)) {
 			outw(ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
-			spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 			return;
 		}
-		spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
-#if 0
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(1);
-#endif
 	} while (time_after(end_time, jiffies));
 	snd_printk("codec write timeout, status = 0x%x\n", inl(ES_REG(ensoniq, STATUS)));
 }
@@ -603,11 +597,10 @@
 				   unsigned short reg, unsigned short val)
 {
 	ensoniq_t *ensoniq = ac97->private_data;
-	unsigned long flags;
 	unsigned int t, x;
 
+	down(&ensoniq->src_mutex);
 	for (t = 0; t < POLL_COUNT; t++) {
-		spin_lock_irqsave(&ensoniq->reg_lock, flags);
 		if (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {
 			/* save the current state for latter */
 			x = snd_es1371_wait_src_ready(ensoniq);
@@ -629,11 +622,11 @@
 			/* restore SRC reg */
 			snd_es1371_wait_src_ready(ensoniq);
 			outl(x, ES_REG(ensoniq, 1371_SMPRATE));
-			spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
+			up(&ensoniq->src_mutex);
 			return;
 		}
-		spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 	}
+	up(&ensoniq->src_mutex);
 	snd_printk("codec write timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 }
 
@@ -641,12 +634,11 @@
 					    unsigned short reg)
 {
 	ensoniq_t *ensoniq = ac97->private_data;
-	unsigned long flags;
 	unsigned int t, x, fail = 0;
 
       __again:
+	down(&ensoniq->src_mutex);
 	for (t = 0; t < POLL_COUNT; t++) {
-		spin_lock_irqsave(&ensoniq->reg_lock, flags);
 		if (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {
 			/* save the current state for latter */
 			x = snd_es1371_wait_src_ready(ensoniq);
@@ -676,19 +668,19 @@
 			/* now wait for the stinkin' data (RDY) */
 			for (t = 0; t < POLL_COUNT; t++) {
 				if ((x = inl(ES_REG(ensoniq, 1371_CODEC))) & ES_1371_CODEC_RDY) {
-					spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
+					up(&ensoniq->src_mutex);
 					return ES_1371_CODEC_READ(x);
 				}
 			}
-			spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
+			up(&ensoniq->src_mutex);
 			if (++fail > 10) {
 				snd_printk("codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), reg, inl(ES_REG(ensoniq, 1371_CODEC)));
 				return 0;
 			}
 			goto __again;
 		}
-		spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 	}
+	up(&ensoniq->src_mutex);
 	snd_printk("es1371: codec read timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 	return 0;
 }
@@ -1635,8 +1627,10 @@
 		if (err < 0)
 			return err;
 	}
-	if ((ensoniq->subsystem_vendor_id == 0x1274) &&
-	    (ensoniq->subsystem_device_id == 0x2000)) { /* GA-7DXR */
+	if (((ensoniq->subsystem_vendor_id == 0x1274) &&
+	    (ensoniq->subsystem_device_id == 0x2000)) || /* GA-7DXR */
+	    ((ensoniq->subsystem_vendor_id == 0x1458) &&
+	    (ensoniq->subsystem_device_id == 0xa000))) { /* GA-8IEXP */
 		 err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line, ensoniq));
 		 if (err < 0)
 			 return err;
@@ -1930,7 +1924,6 @@
 	ensoniq->subsystem_vendor_id = cmdw;
 	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &cmdw);
 	ensoniq->subsystem_device_id = cmdw;
-	snd_ensoniq_proc_init(ensoniq);
 #ifdef CHIP1370
 #if 0
 	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE | ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));
@@ -2023,6 +2016,8 @@
 		return err;
 	}
 
+	snd_ensoniq_proc_init(ensoniq);
+
 	snd_card_set_dev(card, &pci->dev);
 
 	*rensoniq = ensoniq;
diff -uNr a/sound/pci/es1938.c b/sound/pci/es1938.c
--- a/sound/pci/es1938.c	2004-12-24 22:35:18.000000000 +0100
+++ b/sound/pci/es1938.c	2005-01-14 22:28:12.208502456 +0100
@@ -1395,7 +1395,6 @@
 	outb(0x00, SLIO_REG(chip, IRQCONTROL)); /* disable irqs */
 
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1415,7 +1414,6 @@
 			snd_es1938_write(chip, *s, *d);
 	}
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1424,8 +1422,9 @@
 {
 	/* disable irqs */
 	outb(0x00, SLIO_REG(chip, IRQCONTROL));
-	/*if (chip->rmidi)
-	  snd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0);*/
+	if (chip->rmidi)
+		snd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0);
+
 #if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
 	if (chip->gameport.io)
 		gameport_unregister_port(&chip->gameport);
@@ -1576,6 +1575,9 @@
 
 	/* MPU401 */
 	if (status & 0x80) {
+		// the following line is evil! It switches off MIDI interrupt handling after the first interrupt received.
+		// replacing the last 0 by 0x40 works for ESS-Solo1, but just doing nothing works as well!
+		// andreas@flying-snail.de
 		// snd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0); /* ack? */
 		if (chip->rmidi) {
 			handled = 1;
@@ -1690,8 +1692,11 @@
 	if (snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
 				chip->mpu_port, 1, chip->irq, 0, &chip->rmidi) < 0) {
 		printk(KERN_ERR "es1938: unable to initialize MPU-401\n");
-	} /*else
-	    snd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0x40);*/
+	} else {
+		// this line is vital for MIDI interrupt handling on ess-solo1
+		// andreas@flying-snail.de
+		snd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0x40);
+	}
 
 #if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
 	chip->gameport.io = chip->game_port;
diff -uNr a/sound/pci/es1968.c b/sound/pci/es1968.c
--- a/sound/pci/es1968.c	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/pci/es1968.c	2005-01-14 22:28:12.216501240 +0100
@@ -584,7 +584,7 @@
 	snd_rawmidi_t *rmidi;
 
 	spinlock_t reg_lock;
-	struct semaphore ac97_mutex;	/* ac97 lock */
+	spinlock_t ac97_lock;
 	struct tasklet_struct hwvol_tq;
 
 	/* Maestro Stuff */
@@ -686,35 +686,36 @@
 static void snd_es1968_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
 {
 	es1968_t *chip = ac97->private_data;
+	unsigned long flags;
 
-	down(&chip->ac97_mutex);
 	snd_es1968_ac97_wait(chip);
 
 	/* Write the bus */
+	spin_lock_irqsave(&chip->ac97_lock, flags);
 	outw(val, chip->io_port + ESM_AC97_DATA);
-	msleep(1);
+	/*msleep(1);*/
 	outb(reg, chip->io_port + ESM_AC97_INDEX);
-	msleep(1);
-
-	up(&chip->ac97_mutex);
+	/*msleep(1);*/
+	spin_unlock_irqrestore(&chip->ac97_lock, flags);
 }
 
 static unsigned short snd_es1968_ac97_read(ac97_t *ac97, unsigned short reg)
 {
 	u16 data = 0;
 	es1968_t *chip = ac97->private_data;
+	unsigned long flags;
 
-	down(&chip->ac97_mutex);
 	snd_es1968_ac97_wait(chip);
 
+	spin_lock_irqsave(&chip->ac97_lock, flags);
 	outb(reg | 0x80, chip->io_port + ESM_AC97_INDEX);
-	msleep(1);
+	/*msleep(1);*/
 
 	if (! snd_es1968_ac97_wait(chip)) {
 		data = inw(chip->io_port + ESM_AC97_DATA);
-		msleep(1);
+		/*msleep(1);*/
 	}
-	up(&chip->ac97_mutex);
+	spin_unlock_irqrestore(&chip->ac97_lock, flags);
 
 	return data;
 }
@@ -837,23 +838,19 @@
 static void snd_es1968_bob_stop(es1968_t *chip)
 {
 	u16 reg;
-	unsigned long flags;
 
-	spin_lock_irqsave(&chip->reg_lock, flags);
 	reg = __maestro_read(chip, 0x11);
 	reg &= ~ESM_BOB_ENABLE;
 	__maestro_write(chip, 0x11, reg);
 	reg = __maestro_read(chip, 0x17);
 	reg &= ~ESM_BOB_START;
 	__maestro_write(chip, 0x17, reg);
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
 static void snd_es1968_bob_start(es1968_t *chip)
 {
 	int prescale;
 	int divide;
-	unsigned long flags;
 
 	/* compute ideal interrupt frequency for buffer size & play rate */
 	/* first, find best prescaler value to match freq */
@@ -882,13 +879,11 @@
 	} else if (divide > 1)
 		divide--;
 
-	spin_lock_irqsave(&chip->reg_lock, flags);
 	__maestro_write(chip, 6, 0x9000 | (prescale << 5) | divide);	/* set reg */
 
 	/* Now set IDR 11/17 */
 	__maestro_write(chip, 0x11, __maestro_read(chip, 0x11) | 1);
 	__maestro_write(chip, 0x17, __maestro_read(chip, 0x17) | 1);
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
 /* call with substream spinlock */
@@ -1931,6 +1926,7 @@
 {
 	es1968_t *chip = (es1968_t *) private_data;
 	int x, val;
+	unsigned long flags;
 
 	/* Figure out which volume control button was pushed,
 	   based on differences from the default register
@@ -1945,11 +1941,15 @@
 	if (! chip->master_switch || ! chip->master_volume)
 		return;
 
-	/* FIXME: more clean up is needed.. */
+	/* FIXME: we can't call snd_ac97_* functions since here is in tasklet. */
+	spin_lock_irqsave(&chip->ac97_lock, flags);
 	val = chip->ac97->regs[AC97_MASTER];
 	if (x & 1) {
 		/* mute */
-		snd_ac97_write_cache(chip->ac97, AC97_MASTER, val ^ 0x8000);
+		val ^= 0x8000;
+		chip->ac97->regs[AC97_MASTER] = val;
+		outw(val, chip->io_port + ESM_AC97_DATA);
+		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
 		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->master_switch->id);
 	} else {
@@ -1967,10 +1967,13 @@
 			if ((val & 0xff00) < 0x1f00)
 				val += 0x0100;
 		}
-		snd_ac97_write_cache(chip->ac97, AC97_MASTER, val);
+		chip->ac97->regs[AC97_MASTER] = val;
+		outw(val, chip->io_port + ESM_AC97_DATA);
+		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
 		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->master_volume->id);
 	}
+	spin_unlock_irqrestore(&chip->ac97_lock, flags);
 }
 
 /*
@@ -2034,6 +2037,7 @@
 
 	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
 		return err;
+	pbus->no_vra = 1; /* ES1968 doesn't need VRA */
 
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
@@ -2412,7 +2416,6 @@
 	snd_es1968_bob_stop(chip);
 	snd_es1968_set_acpi(chip, ACPI_D3);
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -2443,7 +2446,6 @@
 	if (chip->bobclient)
 		snd_es1968_bob_start(chip);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2537,7 +2539,7 @@
 	spin_lock_init(&chip->substream_lock);
 	INIT_LIST_HEAD(&chip->buf_list);
 	INIT_LIST_HEAD(&chip->substream_list);
-	init_MUTEX(&chip->ac97_mutex);
+	spin_lock_init(&chip->ac97_lock);
 	init_MUTEX(&chip->memory_mutex);
 	tasklet_init(&chip->hwvol_tq, es1968_update_hw_volume, (unsigned long)chip);
 	chip->card = card;
diff -uNr a/sound/pci/fm801.c b/sound/pci/fm801.c
--- a/sound/pci/fm801.c	2004-12-24 22:35:24.000000000 +0100
+++ b/sound/pci/fm801.c	2005-01-14 22:28:12.220500632 +0100
@@ -208,15 +208,16 @@
 				 unsigned short mask, unsigned short value)
 {
 	int change;
+	unsigned long flags;
 	unsigned short old, new;
 
-	spin_lock(&chip->reg_lock);
+	spin_lock_irqsave(&chip->reg_lock, flags);
 	old = inw(chip->port + reg);
 	new = (old & ~mask) | value;
 	change = old != new;
 	if (change)
 		outw(new, chip->port + reg);
-	spin_unlock(&chip->reg_lock);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
 	return change;
 }
 
@@ -415,13 +416,12 @@
 
 static int snd_fm801_playback_prepare(snd_pcm_substream_t * substream)
 {
-	unsigned long flags;
 	fm801_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
 
 	chip->ply_size = snd_pcm_lib_buffer_bytes(substream);
 	chip->ply_count = snd_pcm_lib_period_bytes(substream);
-	spin_lock_irqsave(&chip->reg_lock, flags);
+	spin_lock_irq(&chip->reg_lock);
 	chip->ply_ctrl &= ~(FM801_START | FM801_16BIT |
 			     FM801_STEREO | FM801_RATE_MASK |
 			     FM801_CHANNELS_MASK);
@@ -442,19 +442,18 @@
 	chip->ply_pos = 0;
 	outl(chip->ply_buffer, FM801_REG(chip, PLY_BUF1));
 	outl(chip->ply_buffer + (chip->ply_count % chip->ply_size), FM801_REG(chip, PLY_BUF2));
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	spin_unlock_irq(&chip->reg_lock);
 	return 0;
 }
 
 static int snd_fm801_capture_prepare(snd_pcm_substream_t * substream)
 {
-	unsigned long flags;
 	fm801_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
 
 	chip->cap_size = snd_pcm_lib_buffer_bytes(substream);
 	chip->cap_count = snd_pcm_lib_period_bytes(substream);
-	spin_lock_irqsave(&chip->reg_lock, flags);
+	spin_lock_irq(&chip->reg_lock);
 	chip->cap_ctrl &= ~(FM801_START | FM801_16BIT |
 			     FM801_STEREO | FM801_RATE_MASK);
 	if (snd_pcm_format_width(runtime->format) == 16)
@@ -469,7 +468,7 @@
 	chip->cap_pos = 0;
 	outl(chip->cap_buffer, FM801_REG(chip, CAP_BUF1));
 	outl(chip->cap_buffer + (chip->cap_count % chip->cap_size), FM801_REG(chip, CAP_BUF2));
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	spin_unlock_irq(&chip->reg_lock);
 	return 0;
 }
 
diff -uNr a/sound/pci/ice1712/ak4xxx.c b/sound/pci/ice1712/ak4xxx.c
--- a/sound/pci/ice1712/ak4xxx.c	2004-12-24 22:33:48.000000000 +0100
+++ b/sound/pci/ice1712/ak4xxx.c	2005-01-14 22:28:12.223500176 +0100
@@ -151,8 +151,7 @@
 		return;
 	for (akidx = 0; akidx < ice->akm_codecs; akidx++) {
 		akm4xxx_t *ak = &ice->akm[akidx];
-		if (ak->private_value[0])
-			kfree((void *)ak->private_value[0]);
+		kfree((void*)ak->private_value[0]);
 	}
 	kfree(ice->akm);
 }
diff -uNr a/sound/pci/ice1712/aureon.c b/sound/pci/ice1712/aureon.c
--- a/sound/pci/ice1712/aureon.c	2004-12-24 22:35:50.000000000 +0100
+++ b/sound/pci/ice1712/aureon.c	2005-01-14 22:28:12.230499112 +0100
@@ -27,18 +27,10 @@
  *   both controls in the future, once if wm codecs are reused in
  *   many boards.
  *
- * - writing over SPI is implemented but reading is not yet.
- *   the SPDIF-in channel status, etc. can be read from CS chip.
- *
  * - DAC digital volumes are not implemented in the mixer.
  *   if they show better response than DAC analog volumes, we can use them
  *   instead.
  *
- * - Aureon boards are equipped with AC97 codec, too.  it's used to do
- *   the analog mixing but not easily controllable (it's not connected
- *   directly from envy24ht chip).  so let's leave it as it is.
- *
- *
  *   Lowlevel functions for AudioTrak Prodigy 7.1 (and possibly 192) cards
  *      Copyright (c) 2003 Dimitromanolakis Apostolos <apostol@cs.utoronto.ca>
  *
@@ -53,10 +45,6 @@
  *                    we have no digital output, no capture, pretty bad clicks and poops
  *                    on mixer switch and other coll stuff.
  *
- * - Prodigy boards are equipped with AC97 STAC9744 chip , too.  it's used to do
- *   the analog mixing but not easily controllable (it's not connected
- *   directly from envy24ht chip).  so let's leave it as it is.
- *
  */      
 
 #include <sound/driver.h>
@@ -89,6 +77,14 @@
 #define WM_OUT_MUX2		0x1e	/* output MUX */
 #define WM_RESET		0x1f	/* software reset */
 
+/* CS8415A registers */
+#define CS8415_CTRL1	0x01
+#define CS8415_CTRL2	0x02
+#define CS8415_QSUB		0x14
+#define CS8415_RATIO	0x1E
+#define CS8415_C_BUFFER	0x20
+#define CS8415_ID		0x7F
+
 static void aureon_ac97_write(ice1712_t *ice, unsigned short reg, unsigned short val) {
 	unsigned int tmp;
 
@@ -325,47 +321,109 @@
 static void aureon_spi_write(ice1712_t *ice, unsigned int cs, unsigned int data, int bits)
 {
 	unsigned int tmp;
-	unsigned int cscs;
 	int i;
 
 	tmp = snd_ice1712_gpio_read(ice);
 
-	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71)
-		cscs = PRODIGY_CS8415_CS;
-	else
-		cscs = AUREON_CS8415_CS;
-
-	snd_ice1712_gpio_set_mask(ice, ~(AUREON_WM_RW|AUREON_WM_DATA|AUREON_WM_CLK|
-					 AUREON_WM_CS|cscs));
+	snd_ice1712_gpio_set_mask(ice, ~(AUREON_WM_RW|AUREON_SPI_MOSI|AUREON_SPI_CLK|
+					 AUREON_WM_CS|AUREON_CS8415_CS));
 	tmp |= AUREON_WM_RW;
 	tmp &= ~cs;
 	snd_ice1712_gpio_write(ice, tmp);
 	udelay(1);
 
 	for (i = bits - 1; i >= 0; i--) {
-		tmp &= ~AUREON_WM_CLK;
+		tmp &= ~AUREON_SPI_CLK;
 		snd_ice1712_gpio_write(ice, tmp);
 		udelay(1);
 		if (data & (1 << i))
-			tmp |= AUREON_WM_DATA;
+			tmp |= AUREON_SPI_MOSI;
 		else
-			tmp &= ~AUREON_WM_DATA;
+			tmp &= ~AUREON_SPI_MOSI;
 		snd_ice1712_gpio_write(ice, tmp);
 		udelay(1);
-		tmp |= AUREON_WM_CLK;
+		tmp |= AUREON_SPI_CLK;
 		snd_ice1712_gpio_write(ice, tmp);
 		udelay(1);
 	}
 
-	tmp &= ~AUREON_WM_CLK;
+	tmp &= ~AUREON_SPI_CLK;
 	tmp |= cs;
 	snd_ice1712_gpio_write(ice, tmp);
 	udelay(1);
-	tmp |= AUREON_WM_CLK;
+	tmp |= AUREON_SPI_CLK;
+	snd_ice1712_gpio_write(ice, tmp);
+	udelay(1);
+}
+
+/*
+ * Read data in SPI mode
+ */
+static void aureon_spi_read(ice1712_t *ice, unsigned int cs, unsigned int data, int bits, unsigned char *buffer, int size) {
+	int i, j;
+	unsigned int tmp;
+
+	tmp = (snd_ice1712_gpio_read(ice) & ~AUREON_SPI_CLK) | AUREON_CS8415_CS|AUREON_WM_CS;
+	snd_ice1712_gpio_write(ice, tmp);
+	tmp &= ~cs;
 	snd_ice1712_gpio_write(ice, tmp);
 	udelay(1);
+
+	for (i=bits-1; i>=0; i--) {
+		if (data & (1 << i))
+			tmp |= AUREON_SPI_MOSI;
+		else
+			tmp &= ~AUREON_SPI_MOSI;
+		snd_ice1712_gpio_write(ice, tmp);
+		udelay(1);
+
+		tmp |= AUREON_SPI_CLK;
+		snd_ice1712_gpio_write(ice, tmp);
+		udelay(1);
+
+		tmp &= ~AUREON_SPI_CLK;
+		snd_ice1712_gpio_write(ice, tmp);
+		udelay(1);
+	}
+
+	for (j=0; j<size; j++) {
+		unsigned char outdata = 0;
+		for (i=7; i>=0; i--) {
+			tmp = snd_ice1712_gpio_read(ice);
+			outdata <<= 1;
+			outdata |= (tmp & AUREON_SPI_MISO) ? 1 : 0;
+			udelay(1);
+
+			tmp |= AUREON_SPI_CLK;
+			snd_ice1712_gpio_write(ice, tmp);
+			udelay(1);
+
+			tmp &= ~AUREON_SPI_CLK;
+			snd_ice1712_gpio_write(ice, tmp);
+			udelay(1);
+		}
+		buffer[j] = outdata;
+	}
+
+	tmp |= cs;
+	snd_ice1712_gpio_write(ice, tmp);
+}
+
+static unsigned char aureon_cs8415_get(ice1712_t *ice, int reg) {
+	unsigned char val;
+	aureon_spi_write(ice, AUREON_CS8415_CS, 0x2000 | reg, 16);
+	aureon_spi_read(ice, AUREON_CS8415_CS, 0x21, 8, &val, 1);
+	return val;
+}
+
+static void aureon_cs8415_read(ice1712_t *ice, int reg, unsigned char *buffer, int size) {
+	aureon_spi_write(ice, AUREON_CS8415_CS, 0x2000 | reg, 16);
+	aureon_spi_read(ice, AUREON_CS8415_CS, 0x21, 8, buffer, size);
+}
+
+static void aureon_cs8415_put(ice1712_t *ice, int reg, unsigned char val) {
+	aureon_spi_write(ice, AUREON_CS8415_CS, 0x200000 | (reg << 8) | val, 24);
 }
-     
 
 /*
  * get the current register value of WM codec
@@ -845,12 +903,32 @@
 		"Mic",		//AIN4
 		"AC97"		//AIN5
 	};
+	static char *universe_texts[] = {
+		"Aux1",		//AIN1
+		"CD",		//AIN2
+		"Phono",	//AIN3
+		"Line",		//AIN4
+		"Aux2",		//AIN5
+		"Mic",		//AIN6
+		"Aux3",		//AIN7
+		"AC97"		//AIN8
+	};
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 2;
-	uinfo->value.enumerated.items = 5;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON71_UNIVERSE) {
+		uinfo->value.enumerated.items = 8;
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name, universe_texts[uinfo->value.enumerated.item]);
+	}
+	else {
+		uinfo->value.enumerated.items = 5;
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	}
 	return 0;
 }
 
@@ -886,6 +964,154 @@
 }
 
 /*
+ * CS8415 Input mux
+ */
+static int aureon_cs8415_mux_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	static char *aureon_texts[] = {
+		"CD",		//RXP0
+		"Optical"	//RXP1
+	};
+	static char *prodigy_texts[] = {
+		"CD",
+		"Coax"
+	};
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71)
+		strcpy(uinfo->value.enumerated.name, prodigy_texts[uinfo->value.enumerated.item]);
+	else
+		strcpy(uinfo->value.enumerated.name, aureon_texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int aureon_cs8415_mux_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+
+	//snd_ice1712_save_gpio_status(ice);
+	//val = aureon_cs8415_get(ice, CS8415_CTRL2);
+	ucontrol->value.integer.value[0] = ice->spec.aureon.cs8415_mux;
+	//snd_ice1712_restore_gpio_status(ice);
+	return 0;
+}
+
+static int aureon_cs8415_mux_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	unsigned short oval, nval;
+	int change;
+
+	snd_ice1712_save_gpio_status(ice);
+	oval = aureon_cs8415_get(ice, CS8415_CTRL2);
+	nval = oval & ~0x07;
+	nval |= ucontrol->value.integer.value[0] & 7;
+	change = (oval != nval);
+	if (change)
+		aureon_cs8415_put(ice, CS8415_CTRL2, nval);
+	snd_ice1712_restore_gpio_status(ice);
+	ice->spec.aureon.cs8415_mux = ucontrol->value.integer.value[0];
+	return change;
+}
+
+static int aureon_cs8415_rate_info (snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 192000;
+	return 0;
+}
+
+static int aureon_cs8415_rate_get (snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char ratio;
+	ratio = aureon_cs8415_get(ice, CS8415_RATIO);
+	ucontrol->value.integer.value[0] = (int)((unsigned int)ratio * 750);
+	return 0;
+}
+
+/*
+ * CS8415A Mute
+ */
+static int aureon_cs8415_mute_info (snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int aureon_cs8415_mute_get (snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	snd_ice1712_save_gpio_status(ice);
+	ucontrol->value.integer.value[0] = (aureon_cs8415_get(ice, CS8415_CTRL1) & 0x20) ? 0 : 1;
+	snd_ice1712_restore_gpio_status(ice);
+	return 0;
+}
+
+static int aureon_cs8415_mute_put (snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char oval, nval;
+	int change;
+	snd_ice1712_save_gpio_status(ice);
+	oval = aureon_cs8415_get(ice, CS8415_CTRL1);
+	if (ucontrol->value.integer.value[0])
+		nval = oval & ~0x20;
+	else
+		nval = oval | 0x20;
+	if ((change = (oval != nval)))
+		aureon_cs8415_put(ice, CS8415_CTRL1, nval);
+	snd_ice1712_restore_gpio_status(ice);
+	return change;
+}
+
+/*
+ * CS8415A Q-Sub info
+ */
+static int aureon_cs8415_qsub_info (snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo) {
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = 10;
+	return 0;
+}
+
+static int aureon_cs8415_qsub_get (snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol) {
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	
+	snd_ice1712_save_gpio_status(ice);
+	aureon_cs8415_read(ice, CS8415_QSUB, ucontrol->value.bytes.data, 10);
+	snd_ice1712_restore_gpio_status(ice);
+
+	return 0;
+}
+
+static int aureon_cs8415_spdif_info (snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo) {
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int aureon_cs8415_mask_get (snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol) {
+	memset(ucontrol->value.iec958.status, 0xFF, 24);
+	return 0;
+}
+
+static int aureon_cs8415_spdif_get (snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol) {
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+
+	snd_ice1712_save_gpio_status(ice);
+	aureon_cs8415_read(ice, CS8415_C_BUFFER, ucontrol->value.iec958.status, 24);
+	snd_ice1712_restore_gpio_status(ice);
+	return 0;
+}
+
+/*
  * Headphone Amplifier
  */
 static int aureon_set_headphone_amp(ice1712_t *ice, int enable)
@@ -1142,7 +1368,7 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "Headphone Amplifier Switch",
+		.name = "External Amplifier",
 		.info = aureon_hpamp_info,
 		.get = aureon_hpamp_get,
 		.put = aureon_hpamp_put
@@ -1160,7 +1386,7 @@
 		.info = aureon_oversampling_info,
 		.get = aureon_oversampling_get,
 		.put = aureon_oversampling_put
-	},
+	}
 };
 
 static snd_kcontrol_new_t ac97_controls[] __devinitdata = {
@@ -1246,12 +1472,165 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
- 		.name = "Mic Boost",
+ 		.name = "Mic Boost (+20dB)",
+ 		.info = aureon_ac97_micboost_info,
+ 		.get = aureon_ac97_micboost_get,
+ 		.put = aureon_ac97_micboost_put
+ 	}
+};
+
+static snd_kcontrol_new_t universe_ac97_controls[] __devinitdata = {
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "AC97 Playback Switch",
+		.info = aureon_ac97_mmute_info,
+		.get = aureon_ac97_mmute_get,
+		.put = aureon_ac97_mmute_put,
+		.private_value = AC97_MASTER
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "AC97 Playback Volume",
+ 		.info = aureon_ac97_vol_info,
+ 		.get = aureon_ac97_vol_get,
+ 		.put = aureon_ac97_vol_put,
+ 		.private_value = AC97_MASTER|AUREON_AC97_STEREO
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "CD Playback Switch",
+ 		.info = aureon_ac97_mute_info,
+ 		.get = aureon_ac97_mute_get,
+ 		.put = aureon_ac97_mute_put,
+ 		.private_value = AC97_AUX
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "CD Playback Volume",
+ 		.info = aureon_ac97_vol_info,
+ 		.get = aureon_ac97_vol_get,
+ 		.put = aureon_ac97_vol_put,
+ 		.private_value = AC97_AUX|AUREON_AC97_STEREO
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Phono Playback Switch",
+ 		.info = aureon_ac97_mute_info,
+ 		.get = aureon_ac97_mute_get,
+ 		.put = aureon_ac97_mute_put,
+ 		.private_value = AC97_CD,
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Phono Playback Volume",
+ 		.info = aureon_ac97_vol_info,
+ 		.get = aureon_ac97_vol_get,
+ 		.put = aureon_ac97_vol_put,
+ 		.private_value = AC97_CD|AUREON_AC97_STEREO
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Line Playback Switch",
+ 		.info = aureon_ac97_mute_info,
+ 		.get = aureon_ac97_mute_get,
+ 		.put = aureon_ac97_mute_put,
+ 		.private_value = AC97_LINE
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Line Playback Volume",
+ 		.info = aureon_ac97_vol_info,
+ 		.get = aureon_ac97_vol_get,
+ 		.put = aureon_ac97_vol_put,
+ 		.private_value = AC97_LINE|AUREON_AC97_STEREO
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Mic Playback Switch",
+ 		.info = aureon_ac97_mute_info,
+ 		.get = aureon_ac97_mute_get,
+ 		.put = aureon_ac97_mute_put,
+ 		.private_value = AC97_MIC
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Mic Playback Volume",
+ 		.info = aureon_ac97_vol_info,
+ 		.get = aureon_ac97_vol_get,
+ 		.put = aureon_ac97_vol_put,
+ 		.private_value = AC97_MIC
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Mic Boost (+20dB)",
  		.info = aureon_ac97_micboost_info,
  		.get = aureon_ac97_micboost_get,
  		.put = aureon_ac97_micboost_put
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Aux Playback Switch",
+ 		.info = aureon_ac97_mute_info,
+ 		.get = aureon_ac97_mute_get,
+ 		.put = aureon_ac97_mute_put,
+ 		.private_value = AC97_VIDEO,
+ 	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "Aux Playback Volume",
+ 		.info = aureon_ac97_vol_info,
+ 		.get = aureon_ac97_vol_get,
+ 		.put = aureon_ac97_vol_put,
+ 		.private_value = AC97_VIDEO|AUREON_AC97_STEREO
  	}
 };
+
+	
+static snd_kcontrol_new_t cs8415_controls[] __devinitdata = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH),
+		.info = aureon_cs8415_mute_info,
+		.get = aureon_cs8415_mute_get,
+		.put = aureon_cs8415_mute_put
+	},
+ 	{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = SNDRV_CTL_NAME_IEC958("",CAPTURE,NONE) "Source",
+		.info = aureon_cs8415_mux_info,
+		.get = aureon_cs8415_mux_get,
+		.put = aureon_cs8415_mux_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Q-subcode ",CAPTURE,DEFAULT),
+		.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = aureon_cs8415_qsub_info,
+		.get = aureon_cs8415_qsub_get,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("",CAPTURE,MASK),
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.info = aureon_cs8415_spdif_info,
+		.get = aureon_cs8415_mask_get
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("",CAPTURE,DEFAULT),
+		.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = aureon_cs8415_spdif_info,
+		.get = aureon_cs8415_spdif_get
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("",CAPTURE,NONE) "Rate",
+		.access =SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = aureon_cs8415_rate_info,
+		.get = aureon_cs8415_rate_get
+	}
+};
+
  
 static int __devinit aureon_add_controls(ice1712_t *ice)
 {
@@ -1273,10 +1652,40 @@
 			return err;
 	}
 	
-	for (i = 0; i < ARRAY_SIZE(ac97_controls); i++) {
-		err = snd_ctl_add(ice->card, snd_ctl_new1(&ac97_controls[i], ice));
-		if (err < 0)
-			return err;
+	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON71_UNIVERSE) {
+		for (i = 0; i < ARRAY_SIZE(universe_ac97_controls); i++) {
+			err = snd_ctl_add(ice->card, snd_ctl_new1(&universe_ac97_controls[i], ice));
+			if (err < 0)
+				return err;
+		}
+	}
+	else {
+		for (i = 0; i < ARRAY_SIZE(ac97_controls); i++) {
+			err = snd_ctl_add(ice->card, snd_ctl_new1(&ac97_controls[i], ice));
+			if (err < 0)
+				return err;
+		}
+	}
+
+	{
+		unsigned char id;
+		snd_ice1712_save_gpio_status(ice);
+		id = aureon_cs8415_get(ice, CS8415_ID);
+		if (id != 0x41)
+			snd_printk("No CS8415 chip. Skipping CS8415 controls.\n");
+		else if ((id & 0x0F) != 0x01)
+			snd_printk("Detected unsupported CS8415 rev. (%c)\n", (char)((id & 0x0F) + 'A' - 1));
+		else {
+			for (i = 0; i< ARRAY_SIZE(cs8415_controls); i++) {
+				snd_kcontrol_t *kctl;
+				err = snd_ctl_add(ice->card, (kctl = snd_ctl_new1(&cs8415_controls[i], ice)));
+				if (err < 0)
+					return err;
+				if (i > 1)
+					kctl->id.device = ice->pcm->device;
+			}
+		}
+		snd_ice1712_restore_gpio_status(ice);
 	}
 	
 	return 0;
@@ -1290,9 +1699,9 @@
 {
 	static unsigned short wm_inits_aureon[] = {
 		/* These come first to reduce init pop noise */
-		0x1b, 0x005,		/* ADC Mux (AC'97 source) */
-		0x1c, 0x00B,		/* Out Mux1 (VOUT1 = ADC+AUX, VOUT2 = ADC) */
-		0x1d, 0x009,		/* Out Mux2 (VOUT2 = ADC, VOUT3 = ADC) */
+		0x1b, 0x044,		/* ADC Mux (AC'97 source) */
+		0x1c, 0x00B,		/* Out Mux1 (VOUT1 = DAC+AUX, VOUT2 = DAC) */
+		0x1d, 0x009,		/* Out Mux2 (VOUT2 = DAC, VOUT3 = DAC) */
 
 		0x18, 0x000,		/* All power-up */
 
@@ -1375,7 +1784,6 @@
 	};
 	unsigned int tmp;
 	unsigned short *p;
-	unsigned int cscs;
 	int err, i;
 
 	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON51_SKY) {
@@ -1396,23 +1804,17 @@
 	if ((err = aureon_ac97_init(ice)) != 0)
 		return err;
 
-	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71)
-		cscs = PRODIGY_CS8415_CS;
-	else
-		cscs = AUREON_CS8415_CS;
-
 	snd_ice1712_gpio_set_dir(ice, 0x5fffff); /* fix this for the time being */
 
 	/* reset the wm codec as the SPI mode */
 	snd_ice1712_save_gpio_status(ice);
-	snd_ice1712_gpio_set_mask(ice, ~(AUREON_WM_RESET|AUREON_WM_CS|
-					 cscs|AUREON_HP_SEL));
+	snd_ice1712_gpio_set_mask(ice, ~(AUREON_WM_RESET|AUREON_WM_CS|AUREON_CS8415_CS|AUREON_HP_SEL));
 
 	tmp = snd_ice1712_gpio_read(ice);
 	tmp &= ~AUREON_WM_RESET;
 	snd_ice1712_gpio_write(ice, tmp);
 	udelay(1);
-	tmp |= AUREON_WM_CS | cscs;
+	tmp |= AUREON_WM_CS | AUREON_CS8415_CS;
 	snd_ice1712_gpio_write(ice, tmp);
 	udelay(1);
 	tmp |= AUREON_WM_RESET;
@@ -1429,8 +1831,8 @@
 
 	/* initialize CS8415A codec */
 	for (p = cs_inits; *p != (unsigned short)-1; p++)
-		aureon_spi_write(ice, cscs,
-				 *p | 0x200000, 24);
+		aureon_spi_write(ice, AUREON_CS8415_CS, *p | 0x200000, 24);
+	ice->spec.aureon.cs8415_mux = 1;
 
 	aureon_set_headphone_amp(ice, 1);
 
@@ -1525,12 +1927,12 @@
  	{
  		.subvendor = VT1724_SUBDEVICE_AUREON71_UNIVERSE,
  		.name = "Terratec Aureon 7.1-Universe",
-		/* model not needed - identical with 7.1-Space */
+		.model = "universe",
  		.chip_init = aureon_init,
  		.build_controls = aureon_add_controls,
  		.eeprom_size = sizeof(aureon71_eeprom),
  		.eeprom_data = aureon71_eeprom,
-		.driver = "Aureon71",
+		.driver = "Aureon71Universe",
 	},
 	{
 		.subvendor = VT1724_SUBDEVICE_PRODIGY71,
diff -uNr a/sound/pci/ice1712/aureon.h b/sound/pci/ice1712/aureon.h
--- a/sound/pci/ice1712/aureon.h	2004-12-24 22:35:40.000000000 +0100
+++ b/sound/pci/ice1712/aureon.h	2005-01-14 22:28:12.233498656 +0100
@@ -38,10 +38,10 @@
 
 /* GPIO bits */
 #define AUREON_CS8415_CS	(1 << 22)
-#define AUREON_CS8415_CDTO	(1 << 21)
+#define AUREON_SPI_MISO		(1 << 21)
 #define AUREON_WM_RESET		(1 << 20)
-#define AUREON_WM_CLK		(1 << 19)
-#define AUREON_WM_DATA		(1 << 18)
+#define AUREON_SPI_CLK		(1 << 19)
+#define AUREON_SPI_MOSI		(1 << 18)
 #define AUREON_WM_RW		(1 << 17)
 #define AUREON_AC97_RESET	(1 << 16)
 #define AUREON_DIGITAL_SEL1	(1 << 15)
@@ -53,8 +53,4 @@
 #define AUREON_AC97_DATA_HIGH	(1 << 8)
 #define AUREON_AC97_DATA_MASK	0xFF
 
-/* Prodigy has different pin assignment for chip select */
-#define PRODIGY_CS8415_CS	(1 << 23)
-#define PRODIGY_CS8415_CDTO	(1 << 22)
-
 #endif /* __SOUND_AUREON_H */
diff -uNr a/sound/pci/ice1712/delta.c b/sound/pci/ice1712/delta.c
--- a/sound/pci/ice1712/delta.c	2004-12-24 22:33:59.000000000 +0100
+++ b/sound/pci/ice1712/delta.c	2005-01-14 22:28:12.236498200 +0100
@@ -530,6 +530,9 @@
 		ice->num_total_dacs = 8;
 		ice->num_total_adcs = 8;
 		break;
+	case ICE1712_SUBDEVICE_DELTADIO2496:
+		ice->num_total_dacs = 4;	/* two AK4324 codecs */
+		break;
 	case ICE1712_SUBDEVICE_VX442:
 		ice->num_total_dacs = 4;
 		ice->num_total_adcs = 4;
diff -uNr a/sound/pci/ice1712/ice1712.h b/sound/pci/ice1712/ice1712.h
--- a/sound/pci/ice1712/ice1712.h	2004-12-24 22:33:50.000000000 +0100
+++ b/sound/pci/ice1712/ice1712.h	2005-01-14 22:28:12.243497136 +0100
@@ -365,6 +365,7 @@
 		/* AC97 register cache for Aureon */
 		struct aureon_spec {
 			unsigned short stac9744[64];
+			unsigned int cs8415_mux;
 			unsigned short master[2];
 			unsigned short vol[8];
 		} aureon;
diff -uNr a/sound/pci/ice1712/ice1724.c b/sound/pci/ice1712/ice1724.c
--- a/sound/pci/ice1712/ice1724.c	2004-12-24 22:34:44.000000000 +0100
+++ b/sound/pci/ice1712/ice1724.c	2005-01-14 22:28:12.252495768 +0100
@@ -1814,7 +1814,7 @@
 
 static snd_kcontrol_new_t snd_vt1724_mixer_pro_spdif_route __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	.name = "IEC958 Playback Route",
+	.name = SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "Route",
 	.info = snd_vt1724_pro_route_info,
 	.get = snd_vt1724_pro_route_spdif_get,
 	.put = snd_vt1724_pro_route_spdif_put,
diff -uNr a/sound/pci/intel8x0.c b/sound/pci/intel8x0.c
--- a/sound/pci/intel8x0.c	2004-12-24 22:35:00.000000000 +0100
+++ b/sound/pci/intel8x0.c	2005-01-14 22:28:25.682454104 +0100
@@ -66,7 +66,7 @@
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int ac97_clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
-static int ac97_quirk[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = AC97_TUNE_DEFAULT};
+static char *ac97_quirk[SNDRV_CARDS];
 static int buggy_irq[SNDRV_CARDS];
 static int xbox[SNDRV_CARDS];
 
@@ -82,7 +82,7 @@
 MODULE_PARM_DESC(enable, "Enable Intel i8x0 soundcard.");
 module_param_array(ac97_clock, int, NULL, 0444);
 MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (0 = auto-detect).");
-module_param_array(ac97_quirk, int, NULL, 0444);
+module_param_array(ac97_quirk, charp, NULL, 0444);
 MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
 module_param_array(buggy_irq, bool, NULL, 0444);
 MODULE_PARM_DESC(buggy_irq, "Enable workaround for buggy interrupts on some motherboards.");
@@ -380,6 +380,7 @@
 	unsigned int ali_slot;			/* ALI DMA slot */
 	struct ac97_pcm *pcm;
 	int pcm_open_flag;
+	unsigned int page_attr_changed: 1;
 } ichdev_t;
 
 typedef struct _snd_intel8x0 intel8x0_t;
@@ -421,7 +422,6 @@
 	unsigned int ac97_sdin[3];
 
 	spinlock_t reg_lock;
-	spinlock_t ac97_lock;
 	
 	u32 bdbars_count;
 	struct snd_dma_buffer bdbars;
@@ -589,13 +589,11 @@
 {
 	intel8x0_t *chip = ac97->private_data;
 	
-	spin_lock(&chip->ac97_lock);
 	if (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {
 		if (! chip->in_ac97_init)
 			snd_printk("codec_write %d: semaphore is not ready for register 0x%x\n", ac97->num, reg);
 	}
 	iaputword(chip, reg + ac97->num * 0x80, val);
-	spin_unlock(&chip->ac97_lock);
 }
 
 static unsigned short snd_intel8x0_codec_read(ac97_t *ac97,
@@ -605,7 +603,6 @@
 	unsigned short res;
 	unsigned int tmp;
 
-	spin_lock(&chip->ac97_lock);
 	if (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {
 		if (! chip->in_ac97_init)
 			snd_printk("codec_read %d: semaphore is not ready for register 0x%x\n", ac97->num, reg);
@@ -620,7 +617,6 @@
 			res = 0xffff;
 		}
 	}
-	spin_unlock(&chip->ac97_lock);
 	return res;
 }
 
@@ -628,7 +624,6 @@
 {
 	unsigned int tmp;
 
-	spin_lock(&chip->ac97_lock);
 	if (snd_intel8x0_codec_semaphore(chip, codec) >= 0) {
 		iagetword(chip, codec * 0x80);
 		if ((tmp = igetdword(chip, ICHREG(GLOB_STA))) & ICH_RCS) {
@@ -636,7 +631,6 @@
 			iputdword(chip, ICHREG(GLOB_STA), tmp & ~(ICH_SRI|ICH_PRI|ICH_TRI|ICH_GSCI));
 		}
 	}
-	spin_unlock(&chip->ac97_lock);
 }
 
 /*
@@ -669,7 +663,6 @@
 	intel8x0_t *chip = ac97->private_data;
 	unsigned short data = 0xffff;
 
-	spin_lock(&chip->ac97_lock);
 	if (snd_intel8x0_ali_codec_semaphore(chip))
 		goto __err;
 	reg |= ALI_CPR_ADDR_READ;
@@ -680,7 +673,6 @@
 		goto __err;
 	data = igetword(chip, ICHREG(ALI_SPR));
  __err:
-	spin_unlock(&chip->ac97_lock);
 	return data;
 }
 
@@ -688,17 +680,13 @@
 {
 	intel8x0_t *chip = ac97->private_data;
 
-	spin_lock(&chip->ac97_lock);
-	if (snd_intel8x0_ali_codec_semaphore(chip)) {
-		spin_unlock(&chip->ac97_lock);
+	if (snd_intel8x0_ali_codec_semaphore(chip))
 		return;
-	}
 	iputword(chip, ICHREG(ALI_CPR), val);
 	if (ac97->num)
 		reg |= ALI_CPR_ADDR_SECONDARY;
 	iputword(chip, ICHREG(ALI_CPR_ADDR), reg);
 	snd_intel8x0_ali_codec_ready(chip, ALI_CSPSR_WRITE_OK);
-	spin_unlock(&chip->ac97_lock);
 }
 
 
@@ -942,17 +930,22 @@
 	intel8x0_t *chip = snd_pcm_substream_chip(substream);
 	ichdev_t *ichdev = get_ichdev(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
-	size_t size = params_buffer_bytes(hw_params);
 	int dbl = params_rate(hw_params) > 48000;
 	int err;
 
-	if (chip->fix_nocache && runtime->dma_area && runtime->dma_bytes < size)
+	if (chip->fix_nocache && ichdev->page_attr_changed) {
 		fill_nocache(runtime->dma_area, runtime->dma_bytes, 0); /* clear */
+		ichdev->page_attr_changed = 0;
+	}
 	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 	if (err < 0)
 		return err;
-	if (chip->fix_nocache && err > 0)
-		fill_nocache(runtime->dma_area, runtime->dma_bytes, 1);
+	if (chip->fix_nocache) {
+		if (runtime->dma_area && ! ichdev->page_attr_changed) {
+			fill_nocache(runtime->dma_area, runtime->dma_bytes, 1);
+			ichdev->page_attr_changed = 1;
+		}
+	}
 	if (ichdev->pcm_open_flag) {
 		snd_ac97_pcm_close(ichdev->pcm);
 		ichdev->pcm_open_flag = 0;
@@ -978,8 +971,10 @@
 		snd_ac97_pcm_close(ichdev->pcm);
 		ichdev->pcm_open_flag = 0;
 	}
-	if (chip->fix_nocache && substream->runtime->dma_area)
+	if (chip->fix_nocache && ichdev->page_attr_changed) {
 		fill_nocache(substream->runtime->dma_area, substream->runtime->dma_bytes, 0);
+		ichdev->page_attr_changed = 0;
+	}
 	return snd_pcm_lib_free_pages(substream);
 }
 
@@ -1729,6 +1724,12 @@
 		.name = "Compaq Evo D510C",
 		.type = AC97_TUNE_HP_ONLY
 	},
+        {
+		.vendor = 0x0e11,
+		.device = 0x0860,
+		.name = "HP/Compaq nx7010",
+		.type = AC97_TUNE_MUTE_LED
+        },
 	{
 		.vendor = 0x1014,
 		.device = 0x1f00,
@@ -1743,6 +1744,12 @@
 	},
 	{
 		.vendor = 0x1028,
+		.device = 0x010d,
+		.name = "Dell",	/* which model?  AD1885 */
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
+		.vendor = 0x1028,
 		.device = 0x0126,
 		.name = "Dell Optiplex GX260",	/* AD1981A */
 		.type = AC97_TUNE_HP_ONLY
@@ -1753,20 +1760,50 @@
 		.name = "Dell Precision 450",	/* AD1981B*/
 		.type = AC97_TUNE_HP_ONLY
 	},
+	{
+		.vendor = 0x1028,
+		.device = 0x0147,
+		.name = "Dell",	/* which model?  AD1981B*/
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
+		.vendor = 0x103c,
+		.device = 0x006d,
+		.name = "HP zv5000",
+		.type = AC97_TUNE_MUTE_LED	/*AD1981B*/
+	},
 	{	/* FIXME: which codec? */
 		.vendor = 0x103c,
 		.device = 0x00c3,
-		.name = "Hewlett-Packard onboard",
+		.name = "HP xw6000",
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
+		.vendor = 0x103c,
+		.device = 0x129d,
+		.name = "HP xw8000",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
 		.vendor = 0x103c,
+		.device = 0x0890,
+		.name = "HP NC6000",
+		.type = AC97_TUNE_MUTE_LED
+	},
+	{
+		.vendor = 0x103c,
 		.device = 0x12f1,
 		.name = "HP xw8200",	/* AD1981B*/
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
 		.vendor = 0x103c,
+		.device = 0x12f2,
+		.name = "HP xw6200",
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
+		.vendor = 0x103c,
 		.device = 0x3008,
 		.name = "HP xw4200",	/* AD1981B*/
 		.type = AC97_TUNE_HP_ONLY
@@ -1883,7 +1920,7 @@
 	{ } /* terminator */
 };
 
-static int __devinit snd_intel8x0_mixer(intel8x0_t *chip, int ac97_clock, int ac97_quirk)
+static int __devinit snd_intel8x0_mixer(intel8x0_t *chip, int ac97_clock, const char *quirk_override)
 {
 	ac97_bus_t *pbus;
 	ac97_template_t ac97;
@@ -1979,7 +2016,7 @@
 		}
 	}
 	/* tune up the primary codec */
-	snd_ac97_tune_hardware(chip->ac97[0], ac97_quirks, ac97_quirk);
+	snd_ac97_tune_hardware(chip->ac97[0], ac97_quirks, quirk_override);
 	/* enable separate SDINs for ICH4 */
 	if (chip->device_type == DEVICE_INTEL_ICH4)
 		pbus->isdin = 1;
@@ -2279,11 +2316,21 @@
 
 	for (i = 0; i < chip->pcm_devs; i++)
 		snd_pcm_suspend_all(chip->pcm[i]);
+	/* clear nocache */
+	if (chip->fix_nocache) {
+		for (i = 0; i < chip->bdbars_count; i++) {
+			ichdev_t *ichdev = &chip->ichd[i];
+			if (ichdev->substream && ichdev->page_attr_changed) {
+				snd_pcm_runtime_t *runtime = ichdev->substream->runtime;
+				if (runtime->dma_area)
+					fill_nocache(runtime->dma_area, runtime->dma_bytes, 0);
+			}
+		}
+	}
 	for (i = 0; i < 3; i++)
 		if (chip->ac97[i])
 			snd_ac97_suspend(chip->ac97[i]);
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -2308,7 +2355,7 @@
 	if (chip->fix_nocache) {
 		for (i = 0; i < chip->bdbars_count; i++) {
 			ichdev_t *ichdev = &chip->ichd[i];
-			if (ichdev->substream) {
+			if (ichdev->substream && ichdev->page_attr_changed) {
 				snd_pcm_runtime_t *runtime = ichdev->substream->runtime;
 				if (runtime->dma_area)
 					fill_nocache(runtime->dma_area, runtime->dma_bytes, 1);
@@ -2316,7 +2363,6 @@
 		}
 	}
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2505,7 +2551,6 @@
 		return -ENOMEM;
 	}
 	spin_lock_init(&chip->reg_lock);
-	spin_lock_init(&chip->ac97_lock);
 	chip->device_type = device_type;
 	chip->card = card;
 	chip->pci = pci;
@@ -2765,11 +2810,7 @@
 
 static int __init alsa_card_intel8x0_init(void)
 {
-	int err;
-
-        if ((err = pci_module_init(&driver)) < 0)
-                return err;
-        return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_intel8x0_exit(void)
diff -uNr a/sound/pci/intel8x0m.c b/sound/pci/intel8x0m.c
--- a/sound/pci/intel8x0m.c	2004-12-24 22:34:57.000000000 +0100
+++ b/sound/pci/intel8x0m.c	2005-01-14 22:28:12.268493336 +0100
@@ -253,7 +253,6 @@
 	ac97_t *ac97;
 
 	spinlock_t reg_lock;
-	spinlock_t ac97_lock;
 	
 	struct snd_dma_buffer bdbars;
 	u32 bdbars_count;
@@ -411,13 +410,11 @@
 {
 	intel8x0_t *chip = ac97->private_data;
 	
-	spin_lock(&chip->ac97_lock);
 	if (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {
 		if (! chip->in_ac97_init)
 			snd_printk("codec_write %d: semaphore is not ready for register 0x%x\n", ac97->num, reg);
 	}
 	iaputword(chip, reg + ac97->num * 0x80, val);
-	spin_unlock(&chip->ac97_lock);
 }
 
 static unsigned short snd_intel8x0_codec_read(ac97_t *ac97,
@@ -427,7 +424,6 @@
 	unsigned short res;
 	unsigned int tmp;
 
-	spin_lock(&chip->ac97_lock);
 	if (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {
 		if (! chip->in_ac97_init)
 			snd_printk("codec_read %d: semaphore is not ready for register 0x%x\n", ac97->num, reg);
@@ -442,7 +438,6 @@
 			res = 0xffff;
 		}
 	}
-	spin_unlock(&chip->ac97_lock);
 	return res;
 }
 
@@ -1093,7 +1088,6 @@
 	if (chip->ac97)
 		snd_ac97_suspend(chip->ac97);
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1106,7 +1100,6 @@
 	if (chip->ac97)
 		snd_ac97_resume(chip->ac97);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1179,7 +1172,6 @@
 		return -ENOMEM;
 	}
 	spin_lock_init(&chip->reg_lock);
-	spin_lock_init(&chip->ac97_lock);
 	chip->device_type = device_type;
 	chip->card = card;
 	chip->pci = pci;
diff -uNr a/sound/pci/Kconfig b/sound/pci/Kconfig
--- a/sound/pci/Kconfig	2004-12-24 22:34:31.000000000 +0100
+++ b/sound/pci/Kconfig	2005-01-14 22:28:12.270493032 +0100
@@ -106,8 +106,9 @@
         depends on SND
 	select SND_PCM
         help
-	  Say Y here to include support for recording audio from TV
-	  cards based on Brooktree Bt878/Bt879 chips.
+	  If you want to record audio from TV cards based on
+	  Brooktree Bt878/Bt879 chips, say Y here and read
+	  <file:Documentation/sound/alsa/Bt87x.txt>.
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-bt87x.
@@ -171,6 +172,29 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-emu10k1.
 
+config SND_EMU10K1X
+	tristate "Emu10k1X (Dell OEM Version)"
+	depends on SND
+	select SND_AC97_CODEC
+	select SND_RAWMIDI
+	help
+	  Say Y here to include support for the Dell OEM version of the
+	  Sound Blaster Live!.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-emu10k1x.
+
+config SND_CA0106
+	tristate "SB Audigy LS / Live 24bit"
+	depends on SND
+	select SND_AC97_CODEC
+	help
+	  Say Y here to include support for the Sound Blaster Audigy LS
+	  and Live 24bit.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ca0106.
+
 config SND_KORG1212
 	tristate "Korg 1212 IO"
 	depends on SND
@@ -469,6 +493,17 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-via82xx.
 
+config SND_VIA82XX_MODEM
+	tristate "VIA 82C686A/B, 8233 based Modems"
+	depends on SND
+	select SND_AC97_CODEC
+	help
+	  Say Y here to include support for the integrated MC97 modem on
+	  motherboards with VIA chipsets.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-via82xx-modem.
+
 config SND_VX222
 	tristate "Digigram VX222"
 	depends on SND
diff -uNr a/sound/pci/korg1212/korg1212.c b/sound/pci/korg1212/korg1212.c
--- a/sound/pci/korg1212/korg1212.c	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/pci/korg1212/korg1212.c	2005-01-14 22:28:12.278491816 +0100
@@ -472,7 +472,8 @@
                         "SPDIF-R",
 };
 
-u16 ClockSourceSelector[] = {0x8000,   // selects source as ADAT at 44.1 kHz
+static u16 ClockSourceSelector[] =
+                            {0x8000,   // selects source as ADAT at 44.1 kHz
                              0x0000,   // selects source as ADAT at 48 kHz
                              0x8001,   // selects source as S/PDIF at 44.1 kHz
                              0x0001,   // selects source as S/PDIF at 48 kHz
@@ -2411,14 +2412,17 @@
 	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Reboot Card - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
+        if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, korg1212, &ops)) < 0) {
+                snd_korg1212_free(korg1212);
+                return err;
+        }
+        
 	snd_korg1212_EnableCardInterrupts(korg1212);
 
 	mdelay(CARD_BOOT_DELAY_IN_MS);
 
-        if (snd_korg1212_downloadDSPCode(korg1212)) {
-                snd_korg1212_free(korg1212);
+        if (snd_korg1212_downloadDSPCode(korg1212))
         	return -EBUSY;
-	}
 
 	printk(KERN_INFO "dspMemPhy       = %08x U[%08x]\n"
                "PlayDataPhy     = %08x L[%08x]\n"
@@ -2433,10 +2437,8 @@
                korg1212->RoutingTablePhy, LowerWordSwap(korg1212->RoutingTablePhy),
                korg1212->AdatTimeCodePhy, LowerWordSwap(korg1212->AdatTimeCodePhy));
 
-        if ((err = snd_pcm_new(korg1212->card, "korg1212", 0, 1, 1, &korg1212->pcm)) < 0) {
-                snd_korg1212_free(korg1212);
+        if ((err = snd_pcm_new(korg1212->card, "korg1212", 0, 1, 1, &korg1212->pcm)) < 0)
                 return err;
-	}
 
 	korg1212->pcm->private_data = korg1212;
         korg1212->pcm->private_free = snd_korg1212_free_pcm;
@@ -2453,19 +2455,12 @@
 
         for (i = 0; i < ARRAY_SIZE(snd_korg1212_controls); i++) {
                 err = snd_ctl_add(korg1212->card, snd_ctl_new1(&snd_korg1212_controls[i], korg1212));
-                if (err < 0) {
-			snd_korg1212_free(korg1212);
+                if (err < 0)
                         return err;
-		}
         }
 
         snd_korg1212_proc_init(korg1212);
         
-        if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, korg1212, &ops)) < 0) {
-                snd_korg1212_free(korg1212);
-                return err;
-        }
-        
 	snd_card_set_dev(card, &pci->dev);
 
         * rchip = korg1212;
diff -uNr a/sound/pci/maestro3.c b/sound/pci/maestro3.c
--- a/sound/pci/maestro3.c	2004-12-24 22:35:00.000000000 +0100
+++ b/sound/pci/maestro3.c	2005-01-14 22:28:12.286490600 +0100
@@ -1835,34 +1835,24 @@
 snd_m3_ac97_read(ac97_t *ac97, unsigned short reg)
 {
 	m3_t *chip = ac97->private_data;
-	unsigned short ret = 0;
-	unsigned long flags;
 
-	spin_lock_irqsave(&chip->reg_lock, flags);
 	if (snd_m3_ac97_wait(chip))
-		goto __error;
-	snd_m3_outb(chip, 0x80 | (reg & 0x7f), 0x30);
+		return 0xffff;
+	snd_m3_outb(chip, 0x80 | (reg & 0x7f), CODEC_COMMAND);
 	if (snd_m3_ac97_wait(chip))
-		goto __error;
-	ret = snd_m3_inw(chip, 0x32);
-__error:
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
-	return ret;
+		return 0xffff;
+	return snd_m3_inw(chip, CODEC_DATA);
 }
 
 static void
 snd_m3_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
 {
 	m3_t *chip = ac97->private_data;
-	unsigned long flags;
 
-	spin_lock_irqsave(&chip->reg_lock, flags);
 	if (snd_m3_ac97_wait(chip))
-		goto __error;
-	snd_m3_outw(chip, val, 0x32);
-	snd_m3_outb(chip, reg & 0x7f, 0x30);
-__error:
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
+		return;
+	snd_m3_outw(chip, val, CODEC_DATA);
+	snd_m3_outb(chip, reg & 0x7f, CODEC_COMMAND);
 }
 
 
@@ -2374,8 +2364,7 @@
 	}
 
 #ifdef CONFIG_PM
-	if (chip->suspend_mem)
-		vfree(chip->suspend_mem);
+	vfree(chip->suspend_mem);
 #endif
 
 	if (chip->irq >= 0) {
@@ -2425,7 +2414,6 @@
 	snd_m3_outw(chip, 0xffff, 0x56);
 
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -2468,7 +2456,6 @@
 	snd_m3_enable_ints(chip);
 	snd_m3_amp_enable(chip, 1);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2577,26 +2564,7 @@
 
 	snd_m3_assp_init(chip);
 	snd_m3_amp_enable(chip, 1);
-    
-	if ((err = snd_m3_mixer(chip)) < 0) {
-		snd_m3_free(chip);
-		return err;
-	}
 
-	for (i = 0; i < chip->num_substreams; i++) {
-		m3_dma_t *s = &chip->substreams[i];
-		s->chip = chip;
-		if ((err = snd_m3_assp_client_init(chip, s, i)) < 0) {
-			snd_m3_free(chip);
-			return err;
-		}
-	}
-    
-	if ((err = snd_m3_pcm(chip, 0)) < 0) {
-		snd_m3_free(chip);
-		return err;
-	}
-    
 	if (request_irq(pci->irq, snd_m3_interrupt, SA_INTERRUPT|SA_SHIRQ,
 			card->driver, (void *)chip)) {
 		snd_printk("unable to grab IRQ %d\n", pci->irq);
@@ -2618,6 +2586,19 @@
 		return err;
 	}
 
+	if ((err = snd_m3_mixer(chip)) < 0)
+		return err;
+
+	for (i = 0; i < chip->num_substreams; i++) {
+		m3_dma_t *s = &chip->substreams[i];
+		s->chip = chip;
+		if ((err = snd_m3_assp_client_init(chip, s, i)) < 0)
+			return err;
+	}
+
+	if ((err = snd_m3_pcm(chip, 0)) < 0)
+		return err;
+    
 	snd_m3_enable_ints(chip);
 	snd_m3_assp_continue(chip);
 
diff -uNr a/sound/pci/Makefile b/sound/pci/Makefile
--- a/sound/pci/Makefile	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/pci/Makefile	2005-01-14 22:28:12.288490296 +0100
@@ -22,6 +22,7 @@
 snd-rme96-objs := rme96.o
 snd-sonicvibes-objs := sonicvibes.o
 snd-via82xx-objs := via82xx.o
+snd-via82xx-modem-objs := via82xx_modem.o
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_ALS4000) += snd-als4000.o
@@ -43,11 +44,13 @@
 obj-$(CONFIG_SND_RME96) += snd-rme96.o
 obj-$(CONFIG_SND_SONICVIBES) += snd-sonicvibes.o
 obj-$(CONFIG_SND_VIA82XX) += snd-via82xx.o
+obj-$(CONFIG_SND_VIA82XX_MODEM) += snd-via82xx-modem.o
 
 obj-$(CONFIG_SND) += \
 	ac97/ \
 	ali5451/ \
 	au88x0/ \
+	ca0106/ \
 	cs46xx/ \
 	emu10k1/ \
 	ice1712/ \
diff -uNr a/sound/pci/mixart/mixart.c b/sound/pci/mixart/mixart.c
--- a/sound/pci/mixart/mixart.c	2004-12-24 22:35:14.000000000 +0100
+++ b/sound/pci/mixart/mixart.c	2005-01-14 22:28:25.688453192 +0100
@@ -526,11 +526,11 @@
 		stream_param.sample_type = ST_INTEGER_24BE;
 		stream_param.sample_size = 24;
 		break;
-	case SNDRV_PCM_FMTBIT_FLOAT_LE:
+	case SNDRV_PCM_FORMAT_FLOAT_LE:
 		stream_param.sample_type = ST_FLOATING_POINT_32LE;
 		stream_param.sample_size = 32;
 		break;
-	case  SNDRV_PCM_FMTBIT_FLOAT_BE:
+	case  SNDRV_PCM_FORMAT_FLOAT_BE:
 		stream_param.sample_type = ST_FLOATING_POINT_32BE;
 		stream_param.sample_size = 32;
 		break;
@@ -1019,13 +1019,6 @@
 		return err;
 	}
 
-	if (idx == 0) {
-		/* create a DSP loader only on first cardX*/
-		err = snd_mixart_hwdep_new(mgr);
-		if (err < 0)
-			return err;
-	}
-
 	snd_card_set_dev(card, &mgr->pci->dev);
 
 	return 0;
@@ -1359,7 +1352,7 @@
 			idx = index[dev];
 		else
 			idx = index[dev] + i;
-		snprintf(tmpid, sizeof(tmpid), "%s-%d", id[dev], i);
+		snprintf(tmpid, sizeof(tmpid), "%s-%d", id[dev] ? id[dev] : "MIXART", i);
 		card = snd_card_new(idx, tmpid, THIS_MODULE, 0);
 
 		if (! card) {
@@ -1411,6 +1404,13 @@
 	/* init bufferinfo_array */
 	memset(mgr->bufferinfo.area, 0, size);
 
+	/* set up firmware */
+	err = snd_mixart_setup_firmware(mgr);
+	if (err < 0) {
+		snd_mixart_free(mgr);
+		return err;
+	}
+
 	pci_set_drvdata(pci, mgr);
 	dev++;
 	return 0;
diff -uNr a/sound/pci/mixart/mixart_core.c b/sound/pci/mixart/mixart_core.c
--- a/sound/pci/mixart/mixart_core.c	2004-12-24 22:35:39.000000000 +0100
+++ b/sound/pci/mixart/mixart_core.c	2005-01-14 22:28:12.299488624 +0100
@@ -72,9 +72,12 @@
 static int get_msg(mixart_mgr_t *mgr, mixart_msg_t *resp, u32 msg_frame_address )
 {
 	unsigned long flags;
-	u32  headptr, i;
+	u32  headptr;
 	u32  size;
 	int  err;
+#ifndef __BIG_ENDIAN
+	unsigned int i;
+#endif
 
 	spin_lock_irqsave(&mgr->msg_lock, flags);
 	err = 0;
diff -uNr a/sound/pci/mixart/mixart_hwdep.c b/sound/pci/mixart/mixart_hwdep.c
--- a/sound/pci/mixart/mixart_hwdep.c	2004-12-24 22:35:50.000000000 +0100
+++ b/sound/pci/mixart/mixart_hwdep.c	2005-01-14 22:28:12.303488016 +0100
@@ -1,7 +1,7 @@
 /*
  * Driver for Digigram miXart soundcards
  *
- * hwdep device manager
+ * DSP firmware management
  *
  * Copyright (c) 2003 by Digigram <alsa@digigram.com>
  *
@@ -22,6 +22,8 @@
 
 #include <sound/driver.h>
 #include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/firmware.h>
 #include <asm/io.h>
 #include <sound/core.h>
 #include "mixart.h"
@@ -30,19 +32,6 @@
 #include "mixart_hwdep.h"
 
 
-/* miXart hwdep interface id string */
-#define SND_MIXART_HWDEP_ID       "miXart Loader"
-
-static int mixart_hwdep_open(snd_hwdep_t *hw, struct file *file)
-{
-	return 0;
-}
-
-static int mixart_hwdep_release(snd_hwdep_t *hw, struct file *file)
-{
-	return 0;
-}
-
 /**
  * wait for a value on a peudo register, exit with a timeout
  *
@@ -109,34 +98,30 @@
 	u32     p_align;
 };
 
-static int mixart_load_elf(mixart_mgr_t *mgr, snd_hwdep_dsp_image_t *dsp )
+static int mixart_load_elf(mixart_mgr_t *mgr, const struct firmware *dsp )
 {
 	char                    elf32_magic_number[4] = {0x7f,'E','L','F'};
-	snd_mixart_elf32_ehdr_t elf_header;
+	snd_mixart_elf32_ehdr_t *elf_header;
 	int                     i;
 
-	if ( copy_from_user(&elf_header, dsp->image , sizeof(snd_mixart_elf32_ehdr_t)) )
-		return -EFAULT;
-
+	elf_header = (snd_mixart_elf32_ehdr_t *)dsp->data;
 	for( i=0; i<4; i++ )
-		if ( elf32_magic_number[i] != elf_header.e_ident[i] )
+		if ( elf32_magic_number[i] != elf_header->e_ident[i] )
 			return -EINVAL;
 
-	if( elf_header.e_phoff != 0 ) {
+	if( elf_header->e_phoff != 0 ) {
 		snd_mixart_elf32_phdr_t     elf_programheader;
 
-		for( i=0; i < be16_to_cpu(elf_header.e_phnum); i++ ) {
-			u32 pos = be32_to_cpu(elf_header.e_phoff) + (u32)(i * be16_to_cpu(elf_header.e_phentsize));
+		for( i=0; i < be16_to_cpu(elf_header->e_phnum); i++ ) {
+			u32 pos = be32_to_cpu(elf_header->e_phoff) + (u32)(i * be16_to_cpu(elf_header->e_phentsize));
 
-			if( copy_from_user( &elf_programheader, dsp->image + pos, sizeof(elf_programheader) ) )
-				return -EFAULT;
+			memcpy( &elf_programheader, dsp->data + pos, sizeof(elf_programheader) );
 
 			if(elf_programheader.p_type != 0) {
 				if( elf_programheader.p_filesz != 0 ) {
-					if(copy_from_user_toio( MIXART_MEM( mgr, be32_to_cpu(elf_programheader.p_vaddr)),
-								dsp->image + be32_to_cpu( elf_programheader.p_offset ),
-								be32_to_cpu( elf_programheader.p_filesz )))
-						return -EFAULT;
+					memcpy_toio( MIXART_MEM( mgr, be32_to_cpu(elf_programheader.p_vaddr)),
+						     dsp->data + be32_to_cpu( elf_programheader.p_offset ),
+						     be32_to_cpu( elf_programheader.p_filesz ));
 				}
 			}
 		}
@@ -144,20 +129,6 @@
 	return 0;
 }
 
-static int mixart_hwdep_dsp_status(snd_hwdep_t *hw, snd_hwdep_dsp_status_t *info)
-{
-	mixart_mgr_t *mgr = hw->private_data;
-
-	strcpy(info->id, "miXart");
-        info->num_dsps = MIXART_HARDW_FILES_MAX_INDEX;
-
-	if (mgr->hwdep->dsp_loaded & (1 <<  MIXART_MOTHERBOARD_ELF_INDEX))
-		info->chip_ready = 1;
-
-	info->version = MIXART_DRIVER_VERSION;
-	return 0;
-}
-
 /*
  * get basic information and init miXart
  */
@@ -344,9 +315,8 @@
 /* firmware base addresses (when hard coded) */
 #define MIXART_MOTHERBOARD_XLX_BASE_ADDRESS   0x00600000
 
-static int mixart_hwdep_dsp_load(snd_hwdep_t *hw, snd_hwdep_dsp_image_t *dsp)
+static int mixart_dsp_load(mixart_mgr_t* mgr, int index, const struct firmware *dsp)
 {
-	mixart_mgr_t* mgr = hw->private_data;
 	int           err, card_index;
 	u32           status_xilinx, status_elf, status_daught;
 	u32           val;
@@ -364,7 +334,7 @@
 		return -EAGAIN; /* try again later */
 	}
 
-	switch (dsp->index)   {
+	switch (index)   {
 	case MIXART_MOTHERBOARD_XLX_INDEX:
 
 		/* xilinx already loaded ? */ 
@@ -379,8 +349,8 @@
 		}
 
 		/* check xilinx validity */
-		snd_assert(((u32*)(dsp->image))[0]==0xFFFFFFFF, return -EINVAL);
-		snd_assert(dsp->length % 4 == 0, return -EINVAL);
+		snd_assert(((u32*)(dsp->data))[0]==0xFFFFFFFF, return -EINVAL);
+		snd_assert(dsp->size % 4 == 0, return -EINVAL);
 
 		/* set xilinx status to copying */
 		writel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_STATUS_OFFSET ));
@@ -388,11 +358,10 @@
 		/* setup xilinx base address */
 		writel_be( MIXART_MOTHERBOARD_XLX_BASE_ADDRESS, MIXART_MEM( mgr,MIXART_PSEUDOREG_MXLX_BASE_ADDR_OFFSET ));
 		/* setup code size for xilinx file */
-		writel_be( dsp->length, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_SIZE_OFFSET ));
+		writel_be( dsp->size, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_SIZE_OFFSET ));
 
 		/* copy xilinx code */
-		if (copy_from_user_toio(  MIXART_MEM( mgr, MIXART_MOTHERBOARD_XLX_BASE_ADDRESS),  dsp->image,  dsp->length))
-			return -EFAULT;
+		memcpy_toio(  MIXART_MEM( mgr, MIXART_MOTHERBOARD_XLX_BASE_ADDRESS),  dsp->data,  dsp->size);
     
 		/* set xilinx status to copy finished */
 		writel_be( 2, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_STATUS_OFFSET ));
@@ -428,7 +397,7 @@
 		writel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_ELF_STATUS_OFFSET ));
 
 		/* process the copying of the elf packets */
-		err = mixart_load_elf( mgr, dsp);
+		err = mixart_load_elf( mgr, dsp );
 		if (err < 0) return err;
 
 		/* set elf status to copy finished */
@@ -479,11 +448,11 @@
 		}
  
 		/* check daughterboard xilinx validity */
-		snd_assert(((u32*)(dsp->image))[0]==0xFFFFFFFF, return -EINVAL);
-		snd_assert(dsp->length % 4 == 0, return -EINVAL);
+		snd_assert(((u32*)(dsp->data))[0]==0xFFFFFFFF, return -EINVAL);
+		snd_assert(dsp->size % 4 == 0, return -EINVAL);
 
 		/* inform mixart about the size of the file */
-		writel_be( dsp->length, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_SIZE_OFFSET ));
+		writel_be( dsp->size, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_SIZE_OFFSET ));
 
 		/* set daughterboard status to 1 */
 		writel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET ));
@@ -500,8 +469,7 @@
 		snd_assert(val != 0, return -EINVAL);
 
 		/* copy daughterboard xilinx code */
-		if (copy_from_user_toio(  MIXART_MEM( mgr, val),  dsp->image,  dsp->length))
-			return -EFAULT;
+		memcpy_toio(  MIXART_MEM( mgr, val),  dsp->data,  dsp->size);
 
 		/* set daughterboard status to 4 */
 		writel_be( 4, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET ));
@@ -549,7 +517,92 @@
 }
 
 
-int snd_mixart_hwdep_new(mixart_mgr_t *mgr)
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+#if !defined(CONFIG_USE_MIXARTLOADER) && !defined(CONFIG_SND_MIXART) /* built-in kernel */
+#define SND_MIXART_FW_LOADER	/* use the standard firmware loader */
+#endif
+#endif
+
+#ifdef SND_MIXART_FW_LOADER
+
+int snd_mixart_setup_firmware(mixart_mgr_t *mgr)
+{
+	static char *fw_files[3] = {
+		"miXart8.xlx", "miXart8.elf", "miXart8AES.xlx"
+	};
+	char path[32];
+
+	const struct firmware *fw_entry;
+	int i, err;
+
+	for (i = 0; i < 3; i++) {
+		sprintf(path, "mixart/%s", fw_files[i]);
+		if (request_firmware(&fw_entry, path, &mgr->pci->dev)) {
+			snd_printk(KERN_ERR "miXart: can't load firmware %s\n", path);
+			return -ENOENT;
+		}
+		/* fake hwdep dsp record */
+		err = mixart_dsp_load(mgr, i, fw_entry);
+		release_firmware(fw_entry);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+
+#else /* old style firmware loading */
+
+/* miXart hwdep interface id string */
+#define SND_MIXART_HWDEP_ID       "miXart Loader"
+
+static int mixart_hwdep_open(snd_hwdep_t *hw, struct file *file)
+{
+	return 0;
+}
+
+static int mixart_hwdep_release(snd_hwdep_t *hw, struct file *file)
+{
+	return 0;
+}
+
+static int mixart_hwdep_dsp_status(snd_hwdep_t *hw, snd_hwdep_dsp_status_t *info)
+{
+	mixart_mgr_t *mgr = hw->private_data;
+
+	strcpy(info->id, "miXart");
+        info->num_dsps = MIXART_HARDW_FILES_MAX_INDEX;
+
+	if (mgr->hwdep->dsp_loaded & (1 <<  MIXART_MOTHERBOARD_ELF_INDEX))
+		info->chip_ready = 1;
+
+	info->version = MIXART_DRIVER_VERSION;
+	return 0;
+}
+
+static int mixart_hwdep_dsp_load(snd_hwdep_t *hw, snd_hwdep_dsp_image_t *dsp)
+{
+	mixart_mgr_t* mgr = hw->private_data;
+	struct firmware fw;
+	int err;
+
+	fw.size = dsp->length;
+	fw.data = vmalloc(dsp->length);
+	if (! fw.data) {
+		snd_printk(KERN_ERR "miXart: cannot allocate image size %d\n",
+			   (int)dsp->length);
+		return -ENOMEM;
+	}
+	if (copy_from_user(fw.data, dsp->image, dsp->length)) {
+		vfree(fw.data);
+		return -EFAULT;
+	}
+	err = mixart_dsp_load(mgr, dsp->index, &fw);
+	vfree(fw.data);
+	return err;
+}
+
+int snd_mixart_setup_firmware(mixart_mgr_t *mgr)
 {
 	int err;
 	snd_hwdep_t *hw;
@@ -568,5 +621,8 @@
 	sprintf(hw->name,  SND_MIXART_HWDEP_ID);
 	mgr->hwdep = hw;
 	mgr->hwdep->dsp_loaded = 0;
-	return 0;
+
+	return snd_card_register(mgr->chip[0]->card);
 }
+
+#endif /* SND_MIXART_FW_LOADER */
diff -uNr a/sound/pci/mixart/mixart_hwdep.h b/sound/pci/mixart/mixart_hwdep.h
--- a/sound/pci/mixart/mixart_hwdep.h	2004-12-24 22:35:39.000000000 +0100
+++ b/sound/pci/mixart/mixart_hwdep.h	2005-01-14 22:28:12.307487408 +0100
@@ -140,7 +140,6 @@
 #define MIXART_OIDI                             0x008   /* 0000 0000 1000 */
 
 
-/* exported */
-int snd_mixart_hwdep_new(mixart_mgr_t *mgr);
+int snd_mixart_setup_firmware(mixart_mgr_t *mgr);
 
 #endif /* __SOUND_MIXART_HWDEP_H */
diff -uNr a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
--- a/sound/pci/nm256/nm256.c	2004-12-24 22:35:25.000000000 +0100
+++ b/sound/pci/nm256/nm256.c	2005-01-14 22:28:12.311486800 +0100
@@ -1130,7 +1130,7 @@
 		return 0;
 	res = snd_nm256_readw(chip, chip->mixer_base + reg);
 	/* Magic delay.  Bleah yucky.  */
-	udelay(1000);
+	msleep(1);
 	return res;
 }
 
@@ -1151,7 +1151,7 @@
 	/* Wait for the write to take, too. */
 	while (tries-- > 0) {
 		snd_nm256_writew(chip, base + reg, val);
-		udelay(1000);  /* a little delay here seems better.. */
+		msleep(1);  /* a little delay here seems better.. */
 		if (snd_nm256_ac97_ready(chip))
 			return;
 	}
@@ -1275,7 +1275,6 @@
 	snd_ac97_suspend(chip->ac97);
 	chip->coeffs_current = 0;
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1290,7 +1289,6 @@
 	/* restore ac97 */
 	snd_ac97_resume(chip->ac97);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1488,12 +1486,6 @@
 
 	snd_nm256_init_chip(chip);
 
-	if ((err = snd_nm256_pcm(chip, 0)) < 0)
-		goto __error;
-	
-	if ((err = snd_nm256_mixer(chip)) < 0)
-		goto __error;
-
 	// pci_set_master(pci); /* needed? */
 	
 	snd_card_set_pm_callback(card, nm256_suspend, nm256_resume, chip);
@@ -1614,6 +1606,12 @@
 		chip->reset_workaround = 1;
 	}
 
+	if ((err = snd_nm256_pcm(chip, 0)) < 0 ||
+	    (err = snd_nm256_mixer(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
 	sprintf(card->shortname, "NeoMagic %s", card->driver);
 	sprintf(card->longname, "%s at 0x%lx & 0x%lx, irq %d",
 		card->shortname,
diff -uNr a/sound/pci/rme32.c b/sound/pci/rme32.c
--- a/sound/pci/rme32.c	2004-12-24 22:35:40.000000000 +0100
+++ b/sound/pci/rme32.c	2005-01-14 22:28:12.317485888 +0100
@@ -1916,21 +1916,21 @@
 		.private_value = IEC958_AES0_PROFESSIONAL | IEC958_AES0_PRO_EMPHASIS
 	},
 	{
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name =	"Input Connector",
 		.info =	snd_rme32_info_inputtype_control,
 		.get =	snd_rme32_get_inputtype_control,
 		.put =	snd_rme32_put_inputtype_control
 	},
 	{
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name =	"Loopback Input",
 		.info =	snd_rme32_info_loopback_control,
 		.get =	snd_rme32_get_loopback_control,
 		.put =	snd_rme32_put_loopback_control
 	},
 	{
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name =	"Sample Clock Source",
 		.info =	snd_rme32_info_clockmode_control,
 		.get =	snd_rme32_get_clockmode_control,
diff -uNr a/sound/pci/rme9652/hdsp.c b/sound/pci/rme9652/hdsp.c
--- a/sound/pci/rme9652/hdsp.c	2004-12-24 22:34:30.000000000 +0100
+++ b/sound/pci/rme9652/hdsp.c	2005-01-14 22:28:12.337482848 +0100
@@ -27,6 +27,7 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/pci.h>
+#include <linux/firmware.h>
 #include <linux/moduleparam.h>
 
 #include <sound/core.h>
@@ -399,6 +400,13 @@
 #define HDSP_DMA_AREA_BYTES ((HDSP_MAX_CHANNELS+1) * HDSP_CHANNEL_BUFFER_BYTES)
 #define HDSP_DMA_AREA_KILOBYTES (HDSP_DMA_AREA_BYTES/1024)
 
+/* use hotplug firmeare loader? */
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+#ifndef HDSP_USE_HWDEP_LOADER
+#define HDSP_FW_LOADER
+#endif
+#endif
+
 typedef struct _hdsp             hdsp_t;
 typedef struct _hdsp_midi        hdsp_midi_t;
 typedef struct _hdsp_9632_meters hdsp_9632_meters_t;
@@ -585,8 +593,8 @@
 MODULE_DEVICE_TABLE(pci, snd_hdsp_ids);
 
 /* prototypes */
-static int __devinit snd_hdsp_create_alsa_devices(snd_card_t *card, hdsp_t *hdsp);
-static int __devinit snd_hdsp_create_pcm(snd_card_t *card, hdsp_t *hdsp);
+static int snd_hdsp_create_alsa_devices(snd_card_t *card, hdsp_t *hdsp);
+static int snd_hdsp_create_pcm(snd_card_t *card, hdsp_t *hdsp);
 static int snd_hdsp_enable_io (hdsp_t *hdsp);
 static void snd_hdsp_initialize_midi_flush (hdsp_t *hdsp);
 static void snd_hdsp_initialize_channels (hdsp_t *hdsp);
@@ -934,6 +942,7 @@
 	}
 
 	position &= HDSP_BufferPositionMask;
+	position /= 4;
 	position &= (hdsp->period_bytes/2) - 1;
 	return position;
 }
@@ -1443,14 +1452,14 @@
 	return 0;
 }
 
-snd_rawmidi_ops_t snd_hdsp_midi_output =
+static snd_rawmidi_ops_t snd_hdsp_midi_output =
 {
 	.open =		snd_hdsp_midi_output_open,
 	.close =	snd_hdsp_midi_output_close,
 	.trigger =	snd_hdsp_midi_output_trigger,
 };
 
-snd_rawmidi_ops_t snd_hdsp_midi_input =
+static snd_rawmidi_ops_t snd_hdsp_midi_input =
 {
 	.open =		snd_hdsp_midi_input_open,
 	.close =	snd_hdsp_midi_input_close,
@@ -2728,7 +2737,7 @@
 {
 	hdsp_t *hdsp = snd_kcontrol_chip(kcontrol);
 	
-	ucontrol->value.enumerated.item[0] = hdsp_pref_sync_ref(hdsp);
+	ucontrol->value.enumerated.item[0] = hdsp_autosync_ref(hdsp);
 	return 0;
 }
 
@@ -3137,7 +3146,7 @@
 static snd_kcontrol_new_t snd_hdsp_96xx_aeb = HDSP_AEB("Analog Extension Board", 0);
 static snd_kcontrol_new_t snd_hdsp_adat_sync_check = HDSP_ADAT_SYNC_CHECK;
 
-int snd_hdsp_create_controls(snd_card_t *card, hdsp_t *hdsp)
+static int snd_hdsp_create_controls(snd_card_t *card, hdsp_t *hdsp)
 {
 	unsigned int idx;
 	int err;
@@ -3651,7 +3660,7 @@
 	return 0;
 }
 
-void hdsp_midi_tasklet(unsigned long arg)
+static void hdsp_midi_tasklet(unsigned long arg)
 {
 	hdsp_t *hdsp = (hdsp_t *)arg;
 	
@@ -4652,6 +4661,7 @@
 		}
 		break;
 	}
+#ifndef HDSP_FW_LOADER
 	case SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE: {
 		hdsp_firmware_t __user *firmware;
 		u32 __user *firmware_data;
@@ -4661,6 +4671,9 @@
 		/* SNDRV_HDSP_IOCTL_GET_VERSION must have been called */
 		if (hdsp->io_type == Undefined) return -EINVAL;
 
+		if (hdsp->state & (HDSP_FirmwareCached | HDSP_FirmwareLoaded))
+			return -EBUSY;
+
 		snd_printk("initializing firmware upload\n");
 		firmware = (hdsp_firmware_t __user *)argp;
 
@@ -4694,6 +4707,7 @@
 		}
 		break;
 	}
+#endif
 	case SNDRV_HDSP_IOCTL_GET_MIXER: {
 		hdsp_mixer_t __user *mixer = (hdsp_mixer_t __user *)argp;
 		if (copy_to_user(mixer->matrix, hdsp->mixer_matrix, sizeof(unsigned short)*HDSP_MATRIX_MIXER_SIZE))
@@ -4749,8 +4763,7 @@
 	return 0;
 }
 
-static int __devinit snd_hdsp_create_pcm(snd_card_t *card,
-					 hdsp_t *hdsp)
+static int snd_hdsp_create_pcm(snd_card_t *card, hdsp_t *hdsp)
 {
 	snd_pcm_t *pcm;
 	int err;
@@ -4841,7 +4854,7 @@
 	snd_hdsp_flush_midi_input (hdsp, 1);
 }
 
-static int __devinit snd_hdsp_create_alsa_devices(snd_card_t *card, hdsp_t *hdsp)
+static int snd_hdsp_create_alsa_devices(snd_card_t *card, hdsp_t *hdsp)
 {
 	int err;
 	
@@ -4894,6 +4907,86 @@
 	return 0;
 }
 
+#ifdef HDSP_FW_LOADER
+/* load firmware via hotplug fw loader */
+static int __devinit hdsp_request_fw_loader(hdsp_t *hdsp)
+{
+	const char *fwfile;
+	const struct firmware *fw;
+	int err;
+		
+	if (hdsp->io_type == H9652 || hdsp->io_type == H9632)
+		return 0;
+	if (hdsp->io_type == Undefined) {
+		if ((err = hdsp_get_iobox_version(hdsp)) < 0)
+			return err;
+		if (hdsp->io_type == H9652 || hdsp->io_type == H9632)
+			return 0;
+	}
+	if (hdsp_check_for_iobox (hdsp))
+		return -EIO;
+
+	/* caution: max length of firmware filename is 30! */
+	switch (hdsp->io_type) {
+	case Multiface:
+		if (hdsp->firmware_rev == 0xa)
+			fwfile = "multiface_firmware.bin";
+		else
+			fwfile = "multiface_firmware_rev11.bin";
+		break;
+	case Digiface:
+		if (hdsp->firmware_rev == 0xa)
+			fwfile = "digiface_firmware.bin";
+		else
+			fwfile = "digiface_firmware_rev11.bin";
+		break;
+	default:
+		snd_printk(KERN_ERR "hdsp: invalid io_type %d\n", hdsp->io_type);
+		return -EINVAL;
+	}
+
+	if (request_firmware(&fw, fwfile, &hdsp->pci->dev)) {
+		snd_printk(KERN_ERR "hdsp: cannot load firmware %s\n", fwfile);
+		return -ENOENT;
+	}
+	if (fw->size < sizeof(hdsp->firmware_cache)) {
+		snd_printk(KERN_ERR "hdsp: too short firmware size %d (expected %d)\n",
+			   (int)fw->size, (int)sizeof(hdsp->firmware_cache));
+		release_firmware(fw);
+		return -EINVAL;
+	}
+#ifdef SNDRV_BIG_ENDIAN
+	{
+		int i;
+		u32 *src = fw->data;
+		for (i = 0; i < ARRAY_SIZE(hdsp->firmware_cache); i++, src++)
+			hdsp->firmware_cache[i] = ((*src & 0x000000ff) << 16) |
+				((*src & 0x0000ff00) << 8)  |
+				((*src & 0x00ff0000) >> 8)  |
+				((*src & 0xff000000) >> 16);
+	}
+#else
+	memcpy(hdsp->firmware_cache, fw->data, sizeof(hdsp->firmware_cache));
+#endif
+	release_firmware(fw);
+	
+	hdsp->state |= HDSP_FirmwareCached;
+
+	if ((err = snd_hdsp_load_firmware_from_cache(hdsp)) < 0)
+		return err;
+		
+	if (!(hdsp->state & HDSP_InitializationComplete)) {
+		snd_hdsp_initialize_channels(hdsp);
+		snd_hdsp_initialize_midi_flush(hdsp);
+		if ((err = snd_hdsp_create_alsa_devices(hdsp->card, hdsp)) < 0) {
+			snd_printk("error creating alsa devices\n");
+			return err;
+		}
+	}
+	return 0;
+}
+#endif
+
 static int __devinit snd_hdsp_create(snd_card_t *card,
 				     hdsp_t *hdsp,
 				     int precise_ptr)
@@ -5002,11 +5095,16 @@
 	}
 	
 	if ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {
+#ifdef HDSP_FW_LOADER
+		if ((err = hdsp_request_fw_loader(hdsp)) < 0)
+			return err;
+#else
 		snd_printk("card initialization pending : waiting for firmware\n");
 		if ((err = snd_hdsp_create_hwdep(card, hdsp)) < 0) {
 			return err;
 		}
 		return 0;
+#endif
 	} 
 	
 	snd_printk("Firmware already loaded, initializing card.\n");
diff -uNr a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
--- a/sound/pci/rme9652/rme9652.c	2004-12-24 22:34:33.000000000 +0100
+++ b/sound/pci/rme9652/rme9652.c	2005-01-14 22:28:12.352480568 +0100
@@ -1584,7 +1584,7 @@
 static snd_kcontrol_new_t snd_rme9652_adat1_input =
 RME9652_ADAT1_IN("ADAT1 Input Source", 0);
 
-int snd_rme9652_create_controls(snd_card_t *card, rme9652_t *rme9652)
+static int snd_rme9652_create_controls(snd_card_t *card, rme9652_t *rme9652)
 {
 	unsigned int idx;
 	int err;
diff -uNr a/sound/pci/rme96.c b/sound/pci/rme96.c
--- a/sound/pci/rme96.c	2004-12-24 22:34:31.000000000 +0100
+++ b/sound/pci/rme96.c	2005-01-14 22:28:12.323484976 +0100
@@ -2285,35 +2285,35 @@
 			IEC958_AES0_PRO_EMPHASIS
 },
 {
-        .iface =        SNDRV_CTL_ELEM_IFACE_PCM,
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Input Connector",
 	.info =         snd_rme96_info_inputtype_control, 
 	.get =          snd_rme96_get_inputtype_control,
 	.put =          snd_rme96_put_inputtype_control 
 },
 {
-        .iface =        SNDRV_CTL_ELEM_IFACE_PCM,
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Loopback Input",
 	.info =         snd_rme96_info_loopback_control,
 	.get =          snd_rme96_get_loopback_control,
 	.put =          snd_rme96_put_loopback_control
 },
 {
-        .iface =        SNDRV_CTL_ELEM_IFACE_PCM,
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Sample Clock Source",
 	.info =         snd_rme96_info_clockmode_control, 
 	.get =          snd_rme96_get_clockmode_control,
 	.put =          snd_rme96_put_clockmode_control
 },
 {
-        .iface =        SNDRV_CTL_ELEM_IFACE_PCM,
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Monitor Tracks",
 	.info =         snd_rme96_info_montracks_control, 
 	.get =          snd_rme96_get_montracks_control,
 	.put =          snd_rme96_put_montracks_control
 },
 {
-        .iface =        SNDRV_CTL_ELEM_IFACE_PCM,
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Attenuation",
 	.info =         snd_rme96_info_attenuation_control, 
 	.get =          snd_rme96_get_attenuation_control,
diff -uNr a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
--- a/sound/pci/sonicvibes.c	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/pci/sonicvibes.c	2005-01-14 22:28:12.358479656 +0100
@@ -357,8 +357,8 @@
 	return value;
 }
 
-#ifdef CONFIG_SND_DEBUG
-void snd_sonicvibes_debug(sonicvibes_t * sonic)
+#if 0
+static void snd_sonicvibes_debug(sonicvibes_t * sonic)
 {
 	printk("SV REGS:          INDEX = 0x%02x  ", inb(SV_REG(sonic, INDEX)));
 	printk("                 STATUS = 0x%02x\n", inb(SV_REG(sonic, STATUS)));
@@ -1333,13 +1333,14 @@
 #endif
 	sonic->revision = snd_sonicvibes_in(sonic, SV_IREG_REVISION);
 	snd_ctl_add(card, snd_ctl_new1(&snd_sonicvibes_game_control, sonic));
-	snd_sonicvibes_proc_init(sonic);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, sonic, &ops)) < 0) {
 		snd_sonicvibes_free(sonic);
 		return err;
 	}
 
+	snd_sonicvibes_proc_init(sonic);
+
 	snd_card_set_dev(card, &pci->dev);
 
 	*rsonic = sonic;
diff -uNr a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
--- a/sound/pci/trident/trident_main.c	2004-12-24 22:35:01.000000000 +0100
+++ b/sound/pci/trident/trident_main.c	2005-01-14 22:28:12.368478136 +0100
@@ -53,6 +53,9 @@
 #endif
 static int snd_trident_sis_reset(trident_t *trident);
 
+static void snd_trident_clear_voices(trident_t * trident, unsigned short v_min, unsigned short v_max);
+static int snd_trident_free(trident_t *trident);
+
 /*
  *  common I/O routines
  */
@@ -632,7 +635,7 @@
    Returns:     Delta value.
   
   ---------------------------------------------------------------------------*/
-unsigned int snd_trident_convert_rate(unsigned int rate)
+static unsigned int snd_trident_convert_rate(unsigned int rate)
 {
 	unsigned int delta;
 
@@ -692,7 +695,7 @@
    Returns:     Delta value.
   
   ---------------------------------------------------------------------------*/
-unsigned int snd_trident_spurious_threshold(unsigned int rate, unsigned int period_size)
+static unsigned int snd_trident_spurious_threshold(unsigned int rate, unsigned int period_size)
 {
 	unsigned int res = (rate * period_size) / 48000;
 	if (res < 64)
@@ -713,7 +716,7 @@
    Returns:     Control value.
   
   ---------------------------------------------------------------------------*/
-unsigned int snd_trident_control_mode(snd_pcm_substream_t *substream)
+static unsigned int snd_trident_control_mode(snd_pcm_substream_t *substream)
 {
 	unsigned int CTRL;
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -770,8 +773,8 @@
   
   ---------------------------------------------------------------------------*/
 
-int snd_trident_allocate_pcm_mem(snd_pcm_substream_t * substream,
-				 snd_pcm_hw_params_t * hw_params)
+static int snd_trident_allocate_pcm_mem(snd_pcm_substream_t * substream,
+					snd_pcm_hw_params_t * hw_params)
 {
 	trident_t *trident = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -804,8 +807,8 @@
   
   ---------------------------------------------------------------------------*/
 
-int snd_trident_allocate_evoice(snd_pcm_substream_t * substream,
-				snd_pcm_hw_params_t * hw_params)
+static int snd_trident_allocate_evoice(snd_pcm_substream_t * substream,
+				       snd_pcm_hw_params_t * hw_params)
 {
 	trident_t *trident = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -3611,10 +3614,13 @@
 		return err;
 	}
 
-	if ((err = snd_trident_mixer(trident, pcm_spdif_device)) < 0) {
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, trident, &ops)) < 0) {
 		snd_trident_free(trident);
 		return err;
 	}
+
+	if ((err = snd_trident_mixer(trident, pcm_spdif_device)) < 0)
+		return err;
 	
 	/* initialise synth voices */
 	for (i = 0; i < 64; i++) {
@@ -3635,12 +3641,7 @@
 
 	
 	snd_card_set_pm_callback(card, snd_trident_suspend, snd_trident_resume, trident);
-
 	snd_trident_proc_init(trident);
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, trident, &ops)) < 0) {
-		snd_trident_free(trident);
-		return err;
-	}
 	snd_card_set_dev(card, &pci->dev);
 	*rtrident = trident;
 	return 0;
@@ -3650,7 +3651,7 @@
    snd_trident_free
   
    Description: This routine will free the device specific class for
-            q    the 4DWave card. 
+                the 4DWave card. 
                 
    Paramters:   trident  - device specific private data for 4DWave card
 
@@ -3658,7 +3659,7 @@
   
   ---------------------------------------------------------------------------*/
 
-int snd_trident_free(trident_t *trident)
+static int snd_trident_free(trident_t *trident)
 {
 #if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
 	if (trident->gameport) {
@@ -3679,8 +3680,7 @@
 			snd_util_memhdr_free(trident->tlb.memhdr);
 		if (trident->tlb.silent_page.area)
 			snd_dma_free_pages(&trident->tlb.silent_page);
-		if (trident->tlb.shadow_entries)
-			vfree(trident->tlb.shadow_entries);
+		vfree(trident->tlb.shadow_entries);
 		snd_dma_free_pages(&trident->tlb.buffer);
 	}
 	if (trident->irq >= 0)
@@ -3807,9 +3807,9 @@
 }
 
 /*---------------------------------------------------------------------------
-   snd_trident_attach_synthesizer, snd_trident_detach_synthesizer
+   snd_trident_attach_synthesizer
   
-   Description: Attach/detach synthesizer hooks
+   Description: Attach synthesizer hooks
                 
    Paramters:   trident  - device specific private data for 4DWave card
 
@@ -3828,17 +3828,6 @@
 	return 0;
 }
 
-int snd_trident_detach_synthesizer(trident_t *trident)
-{
-#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
-	if (trident->seq_dev) {
-		snd_device_free(trident->card, trident->seq_dev);
-		trident->seq_dev = NULL;
-	}
-#endif
-	return 0;
-}
-
 snd_trident_voice_t *snd_trident_alloc_voice(trident_t * trident, int type, int client, int port)
 {
 	snd_trident_voice_t *pvoice;
@@ -3911,7 +3900,7 @@
 		private_free(voice);
 }
 
-void snd_trident_clear_voices(trident_t * trident, unsigned short v_min, unsigned short v_max)
+static void snd_trident_clear_voices(trident_t * trident, unsigned short v_min, unsigned short v_max)
 {
 	unsigned int i, val, mask[2] = { 0, 0 };
 
@@ -3955,7 +3944,6 @@
 		break;
 	}
 	pci_disable_device(trident->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -3990,7 +3978,6 @@
 
 	snd_trident_enable_eso(trident);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	trident->in_suspend = 0;
 	return 0;
 }
@@ -4001,9 +3988,7 @@
 EXPORT_SYMBOL(snd_trident_start_voice);
 EXPORT_SYMBOL(snd_trident_stop_voice);
 EXPORT_SYMBOL(snd_trident_write_voice_regs);
-EXPORT_SYMBOL(snd_trident_clear_voices);
 /* trident_memory.c symbols */
 EXPORT_SYMBOL(snd_trident_synth_alloc);
 EXPORT_SYMBOL(snd_trident_synth_free);
-EXPORT_SYMBOL(snd_trident_synth_bzero);
 EXPORT_SYMBOL(snd_trident_synth_copy_from_user);
diff -uNr a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
--- a/sound/pci/trident/trident_memory.c	2004-12-24 22:35:15.000000000 +0100
+++ b/sound/pci/trident/trident_memory.c	2005-01-14 22:28:12.372477528 +0100
@@ -450,29 +450,6 @@
 }
 
 /*
- * bzero(blk + offset, size)
- */
-int snd_trident_synth_bzero(trident_t *trident, snd_util_memblk_t *blk, int offset, int size)
-{
-	int page, nextofs, end_offset, temp, temp1;
-
-	offset += blk->offset;
-	end_offset = offset + size;
-	page = get_aligned_page(offset) + 1;
-	do {
-		nextofs = aligned_page_offset(page);
-		temp = nextofs - offset;
-		temp1 = end_offset - offset;
-		if (temp1 < temp)
-			temp = temp1;
-		memset(offset_ptr(trident, offset), 0, temp);
-		offset = nextofs;
-		page++;
-	} while (offset < end_offset);
-	return 0;
-}
-
-/*
  * copy_from_user(blk + offset, data, size)
  */
 int snd_trident_synth_copy_from_user(trident_t *trident, snd_util_memblk_t *blk, int offset, const char __user *data, int size)
diff -uNr a/sound/pci/trident/trident_synth.c b/sound/pci/trident/trident_synth.c
--- a/sound/pci/trident/trident_synth.c	2004-12-24 22:34:32.000000000 +0100
+++ b/sound/pci/trident/trident_synth.c	2005-01-14 22:28:12.376476920 +0100
@@ -618,7 +618,7 @@
 	instr = snd_seq_instr_find(trident->synth.ilist, &v->instr, 0, 1);
 	if (instr != NULL) {
 		if (instr->ops) {
-			if (instr->ops->instr_type == snd_seq_simple_id)
+			if (!strcmp(instr->ops->instr_type, SNDRV_SEQ_INSTR_ID_SIMPLE))
 				snd_trident_simple_init(v);
 		}
 		snd_seq_instr_free_use(trident->synth.ilist, instr);
@@ -811,7 +811,7 @@
 	snd_seq_instr_list_free_cond(p->trident->synth.ilist, &ifree, client, 0);
 }
 
-int snd_trident_synth_event_input(snd_seq_event_t * ev, int direct, void *private_data, int atomic, int hop)
+static int snd_trident_synth_event_input(snd_seq_event_t * ev, int direct, void *private_data, int atomic, int hop)
 {
 	snd_trident_port_t *p = (snd_trident_port_t *) private_data;
 
diff -uNr a/sound/pci/via82xx.c b/sound/pci/via82xx.c
--- a/sound/pci/via82xx.c	2004-12-24 22:35:24.000000000 +0100
+++ b/sound/pci/via82xx.c	2005-01-14 22:28:12.383475856 +0100
@@ -81,7 +81,7 @@
 static int joystick[SNDRV_CARDS];
 #endif
 static int ac97_clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 48000};
-static int ac97_quirk[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = AC97_TUNE_DEFAULT};
+static char *ac97_quirk[SNDRV_CARDS];
 static int dxs_support[SNDRV_CARDS];
 
 module_param_array(index, int, NULL, 0444);
@@ -98,7 +98,7 @@
 #endif
 module_param_array(ac97_clock, int, NULL, 0444);
 MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (default 48000Hz).");
-module_param_array(ac97_quirk, int, NULL, 0444);
+module_param_array(ac97_quirk, charp, NULL, 0444);
 MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
 module_param_array(dxs_support, int, NULL, 0444);
 MODULE_PARM_DESC(dxs_support, "Support for DXS channels (0 = auto, 1 = enable, 2 = disable, 3 = 48k only, 4 = no VRA)");
@@ -332,6 +332,7 @@
 	struct snd_via_sg_table *idx_table;
 	/* for recovery from the unexpected pointer */
 	unsigned int lastpos;
+	unsigned int fragsize;
 	unsigned int bufsize;
 	unsigned int bufsize2;
 };
@@ -390,7 +391,6 @@
 	unsigned int ac97_secondary;	/* secondary AC'97 codec is present */
 
 	spinlock_t reg_lock;
-	spinlock_t ac97_lock;
 	snd_info_entry_t *proc_entry;
 
 #ifdef SUPPORT_JOYSTICK
@@ -478,6 +478,7 @@
 	dev->tbl_entries = idx;
 	dev->bufsize = periods * fragsize;
 	dev->bufsize2 = dev->bufsize / 2;
+	dev->fragsize = fragsize;
 	return 0;
 }
 
@@ -562,10 +563,8 @@
 	xval <<= VIA_REG_AC97_CODEC_ID_SHIFT;
 	xval |= reg << VIA_REG_AC97_CMD_SHIFT;
 	xval |= val << VIA_REG_AC97_DATA_SHIFT;
-	spin_lock(&chip->ac97_lock);
 	snd_via82xx_codec_xwrite(chip, xval);
 	snd_via82xx_codec_ready(chip, ac97->num);
-	spin_unlock(&chip->ac97_lock);
 }
 
 static unsigned short snd_via82xx_codec_read(ac97_t *ac97, unsigned short reg)
@@ -578,10 +577,8 @@
 	xval |= ac97->num ? VIA_REG_AC97_SECONDARY_VALID : VIA_REG_AC97_PRIMARY_VALID;
 	xval |= VIA_REG_AC97_READ;
 	xval |= (reg & 0x7f) << VIA_REG_AC97_CMD_SHIFT;
-	spin_lock(&chip->ac97_lock);
       	while (1) {
       		if (again++ > 3) {
-		        spin_unlock(&chip->ac97_lock);
 			snd_printk(KERN_ERR "codec_read: codec %i is not valid [0x%x]\n", ac97->num, snd_via82xx_codec_xread(chip));
 		      	return 0xffff;
 		}
@@ -593,7 +590,6 @@
 			break;
 		}
 	}
-	spin_unlock(&chip->ac97_lock);
 	return val & 0xffff;
 }
 
@@ -706,29 +702,34 @@
 
 static inline unsigned int calc_linear_pos(viadev_t *viadev, unsigned int idx, unsigned int count)
 {
-	unsigned int size, res;
+	unsigned int size, base, res;
 
 	size = viadev->idx_table[idx].size;
-	res = viadev->idx_table[idx].offset + size - count;
+	base = viadev->idx_table[idx].offset;
+	res = base + size - count;
 
 	/* check the validity of the calculated position */
 	if (size < count) {
 		snd_printd(KERN_ERR "invalid via82xx_cur_ptr (size = %d, count = %d)\n", (int)size, (int)count);
 		res = viadev->lastpos;
-	} else if (check_invalid_pos(viadev, res)) {
+	} else {
+		if (! count) {
+			/* Some mobos report count = 0 on the DMA boundary,
+			 * i.e. count = size indeed.
+			 * Let's check whether this step is above the expected size.
+			 */
+			int delta = res - viadev->lastpos;
+			if (delta < 0)
+				delta += viadev->bufsize;
+			if ((unsigned int)delta > viadev->fragsize)
+				res = base;
+		}
+		if (check_invalid_pos(viadev, res)) {
 #ifdef POINTER_DEBUG
-		printk("fail: idx = %i/%i, lastpos = 0x%x, bufsize2 = 0x%x, offsize = 0x%x, size = 0x%x, count = 0x%x\n", idx, viadev->tbl_entries, viadev->lastpos, viadev->bufsize2, viadev->idx_table[idx].offset, viadev->idx_table[idx].size, count);
+			printk(KERN_DEBUG "fail: idx = %i/%i, lastpos = 0x%x, bufsize2 = 0x%x, offsize = 0x%x, size = 0x%x, count = 0x%x\n", idx, viadev->tbl_entries, viadev->lastpos, viadev->bufsize2, viadev->idx_table[idx].offset, viadev->idx_table[idx].size, count);
 #endif
-		if (count && size < count) {
-			snd_printd(KERN_ERR "invalid via82xx_cur_ptr, using last valid pointer\n");
-			res = viadev->lastpos;
-		} else {
-			if (! count)
-				/* bogus count 0 on the DMA boundary? */
-				res = viadev->idx_table[idx].offset;
-			else
-				/* count register returns full size when end of buffer is reached */
-				res = viadev->idx_table[idx].offset + size;
+			/* count register returns full size when end of buffer is reached */
+			res = base + size;
 			if (check_invalid_pos(viadev, res)) {
 				snd_printd(KERN_ERR "invalid via82xx_cur_ptr (2), using last valid pointer\n");
 				res = viadev->lastpos;
@@ -778,12 +779,20 @@
 	via82xx_t *chip = snd_pcm_substream_chip(substream);
 	viadev_t *viadev = (viadev_t *)substream->runtime->private_data;
 	unsigned int idx, count, res;
+	int timeout = 5000;
 	
 	snd_assert(viadev->tbl_entries, return 0);
 	if (!(inb(VIADEV_REG(viadev, OFFSET_STATUS)) & VIA_REG_STAT_ACTIVE))
 		return 0;
 	spin_lock(&chip->reg_lock);
-	count = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT));
+	do {
+		count = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT));
+		/* some mobos read 0 count */
+		if ((count & 0xffffff) || ! viadev->running)
+			break;
+	} while (--timeout);
+	if (! timeout)
+		snd_printd(KERN_ERR "zero position is read\n");
 	idx = count >> 24;
 	if (idx >= viadev->tbl_entries) {
 #ifdef POINTER_DEBUG
@@ -1593,7 +1602,7 @@
 	{ } /* terminator */
 };
 
-static int __devinit snd_via82xx_mixer_new(via82xx_t *chip, int ac97_quirk)
+static int __devinit snd_via82xx_mixer_new(via82xx_t *chip, const char *quirk_override)
 {
 	ac97_template_t ac97;
 	int err;
@@ -1616,7 +1625,7 @@
 	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
 		return err;
 
-	snd_ac97_tune_hardware(chip->ac97, ac97_quirks, ac97_quirk);
+	snd_ac97_tune_hardware(chip->ac97, ac97_quirks, quirk_override);
 
 	if (chip->chip_type != TYPE_VIA686) {
 		/* use slot 10/11 */
@@ -1635,8 +1644,6 @@
 	int i, err, caps;
 	unsigned char val;
 
-	pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE,
-			      chip->old_legacy & ~(VIA_FUNC_ENABLE_SB|VIA_FUNC_ENABLE_FM));
 	caps = chip->chip_type == TYPE_VIA8233A ? 1 : 2;
 	for (i = 0; i < caps; i++) {
 		snd_via8233_capture_source.index = i;
@@ -1673,7 +1680,6 @@
 	legacy_cfg = chip->old_legacy_cfg;
 	legacy |= VIA_FUNC_MIDI_IRQMASK;	/* FIXME: correct? (disable MIDI) */
 	legacy &= ~VIA_FUNC_ENABLE_GAME;	/* disable joystick */
-	legacy &= ~(VIA_FUNC_ENABLE_SB|VIA_FUNC_ENABLE_FM);	/* diable SB & FM */
 	if (chip->revision >= VIA_REV_686_H) {
 		rev_h = 1;
 		if (mpu_port[dev] >= 0x200) {	/* force MIDI */
@@ -1911,7 +1917,6 @@
 
 	pci_set_power_state(chip->pci, 3);
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1946,7 +1951,6 @@
 	for (i = 0; i < chip->num_devs; i++)
 		snd_via82xx_channel_reset(chip, &chip->devs[i]);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2016,7 +2020,6 @@
 	chip->revision = revision;
 
 	spin_lock_init(&chip->reg_lock);
-	spin_lock_init(&chip->ac97_lock);
 	spin_lock_init(&chip->rates[0].lock);
 	spin_lock_init(&chip->rates[1].lock);
 	chip->card = card;
@@ -2025,6 +2028,8 @@
 
 	pci_read_config_byte(pci, VIA_FUNC_ENABLE, &chip->old_legacy);
 	pci_read_config_byte(pci, VIA_PNP_CONTROL, &chip->old_legacy_cfg);
+	pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE,
+			      chip->old_legacy & ~(VIA_FUNC_ENABLE_SB|VIA_FUNC_ENABLE_FM));
 
 	if ((err = pci_request_regions(pci, card->driver)) < 0) {
 		kfree(chip);
@@ -2107,11 +2112,14 @@
 		{ .vendor = 0x1297, .device = 0xa232, .action = VIA_DXS_ENABLE }, /* Shuttle ?? */
 		{ .vendor = 0x1297, .device = 0xc160, .action = VIA_DXS_ENABLE }, /* Shuttle SK41G */
 		{ .vendor = 0x1458, .device = 0xa002, .action = VIA_DXS_ENABLE }, /* Gigabyte GA-7VAXP */
-		{ .vendor = 0x147b, .device = 0x1401, .action = VIA_DXS_ENABLE }, /* ABIT KD7(-RAID) */
-		{ .vendor = 0x14ff, .device = 0x0403, .action = VIA_DXS_ENABLE }, /* Twinhead mobo */
 		{ .vendor = 0x1462, .device = 0x3800, .action = VIA_DXS_ENABLE }, /* MSI KT266 */
-		{ .vendor = 0x1462, .device = 0x7120, .action = VIA_DXS_ENABLE }, /* MSI KT4V */
 		{ .vendor = 0x1462, .device = 0x5901, .action = VIA_DXS_NO_VRA }, /* MSI KT6 Delta-SR */
+		{ .vendor = 0x1462, .device = 0x7120, .action = VIA_DXS_ENABLE }, /* MSI KT4V */
+		{ .vendor = 0x147b, .device = 0x1401, .action = VIA_DXS_ENABLE }, /* ABIT KD7(-RAID) */
+		{ .vendor = 0x147b, .device = 0x1411, .action = VIA_DXS_ENABLE }, /* ABIT VA-20 */
+		{ .vendor = 0x147b, .device = 0x1413, .action = VIA_DXS_ENABLE }, /* ABIT KV8 Pro */
+		{ .vendor = 0x147b, .device = 0x1415, .action = VIA_DXS_NO_VRA }, /* Abit AV8 */
+		{ .vendor = 0x14ff, .device = 0x0403, .action = VIA_DXS_ENABLE }, /* Twinhead mobo */
 		{ .vendor = 0x1584, .device = 0x8120, .action = VIA_DXS_ENABLE }, /* Gericom/Targa/Vobis/Uniwill laptop */
 		{ .vendor = 0x1584, .device = 0x8123, .action = VIA_DXS_NO_VRA }, /* Uniwill (Targa Visionary XP-210) */
 		{ .vendor = 0x161f, .device = 0x202b, .action = VIA_DXS_NO_VRA }, /* Amira Note book */
diff -uNr a/sound/pci/via82xx_modem.c b/sound/pci/via82xx_modem.c
--- a/sound/pci/via82xx_modem.c	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/pci/via82xx_modem.c	2005-01-14 22:28:12.394474184 +0100
@@ -0,0 +1,1256 @@
+/*
+ *   ALSA modem driver for VIA VT82xx (South Bridge)
+ *
+ *   VT82C686A/B/C, VT8233A/C, VT8235
+ *
+ *	Copyright (c) 2000 Jaroslav Kysela <perex@suse.cz>
+ *	                   Tjeerd.Mulder <Tjeerd.Mulder@fujitsu-siemens.com>
+ *                    2002 Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * Changes:
+ *
+ * Sep. 2,  2004  Sasha Khapyorsky <sashak@smlink.com>
+ *      Modified from original audio driver 'via82xx.c' to support AC97
+ *      modems.
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/info.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+
+#if 0
+#define POINTER_DEBUG
+#endif
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("VIA VT82xx modem");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{VIA,VT82C686A/B/C modem,pci}}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int ac97_clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 48000};
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for VIA 82xx bridge.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for VIA 82xx bridge.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable modem part of VIA 82xx bridge.");
+module_param_array(ac97_clock, int, NULL, 0444);
+MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (default 48000Hz).");
+
+
+/*
+ *  Direct registers
+ */
+
+#define VIAREG(via, x) ((via)->port + VIA_REG_##x)
+#define VIADEV_REG(viadev, x) ((viadev)->port + VIA_REG_##x)
+
+/* common offsets */
+#define VIA_REG_OFFSET_STATUS		0x00	/* byte - channel status */
+#define   VIA_REG_STAT_ACTIVE		0x80	/* RO */
+#define   VIA_REG_STAT_PAUSED		0x40	/* RO */
+#define   VIA_REG_STAT_TRIGGER_QUEUED	0x08	/* RO */
+#define   VIA_REG_STAT_STOPPED		0x04	/* RWC */
+#define   VIA_REG_STAT_EOL		0x02	/* RWC */
+#define   VIA_REG_STAT_FLAG		0x01	/* RWC */
+#define VIA_REG_OFFSET_CONTROL		0x01	/* byte - channel control */
+#define   VIA_REG_CTRL_START		0x80	/* WO */
+#define   VIA_REG_CTRL_TERMINATE	0x40	/* WO */
+#define   VIA_REG_CTRL_AUTOSTART	0x20
+#define   VIA_REG_CTRL_PAUSE		0x08	/* RW */
+#define   VIA_REG_CTRL_INT_STOP		0x04		
+#define   VIA_REG_CTRL_INT_EOL		0x02
+#define   VIA_REG_CTRL_INT_FLAG		0x01
+#define   VIA_REG_CTRL_RESET		0x01	/* RW - probably reset? undocumented */
+#define   VIA_REG_CTRL_INT (VIA_REG_CTRL_INT_FLAG | VIA_REG_CTRL_INT_EOL | VIA_REG_CTRL_AUTOSTART)
+#define VIA_REG_OFFSET_TYPE		0x02	/* byte - channel type (686 only) */
+#define   VIA_REG_TYPE_AUTOSTART	0x80	/* RW - autostart at EOL */
+#define   VIA_REG_TYPE_16BIT		0x20	/* RW */
+#define   VIA_REG_TYPE_STEREO		0x10	/* RW */
+#define   VIA_REG_TYPE_INT_LLINE	0x00
+#define   VIA_REG_TYPE_INT_LSAMPLE	0x04
+#define   VIA_REG_TYPE_INT_LESSONE	0x08
+#define   VIA_REG_TYPE_INT_MASK		0x0c
+#define   VIA_REG_TYPE_INT_EOL		0x02
+#define   VIA_REG_TYPE_INT_FLAG		0x01
+#define VIA_REG_OFFSET_TABLE_PTR	0x04	/* dword - channel table pointer */
+#define VIA_REG_OFFSET_CURR_PTR		0x04	/* dword - channel current pointer */
+#define VIA_REG_OFFSET_STOP_IDX		0x08	/* dword - stop index, channel type, sample rate */
+#define VIA_REG_OFFSET_CURR_COUNT	0x0c	/* dword - channel current count (24 bit) */
+#define VIA_REG_OFFSET_CURR_INDEX	0x0f	/* byte - channel current index (for via8233 only) */
+
+#define DEFINE_VIA_REGSET(name,val) \
+enum {\
+	VIA_REG_##name##_STATUS		= (val),\
+	VIA_REG_##name##_CONTROL	= (val) + 0x01,\
+	VIA_REG_##name##_TYPE		= (val) + 0x02,\
+	VIA_REG_##name##_TABLE_PTR	= (val) + 0x04,\
+	VIA_REG_##name##_CURR_PTR	= (val) + 0x04,\
+	VIA_REG_##name##_STOP_IDX	= (val) + 0x08,\
+	VIA_REG_##name##_CURR_COUNT	= (val) + 0x0c,\
+}
+
+/* modem block */
+DEFINE_VIA_REGSET(MO, 0x40);
+DEFINE_VIA_REGSET(MI, 0x50);
+
+/* AC'97 */
+#define VIA_REG_AC97			0x80	/* dword */
+#define   VIA_REG_AC97_CODEC_ID_MASK	(3<<30)
+#define   VIA_REG_AC97_CODEC_ID_SHIFT	30
+#define   VIA_REG_AC97_CODEC_ID_PRIMARY	0x00
+#define   VIA_REG_AC97_CODEC_ID_SECONDARY 0x01
+#define   VIA_REG_AC97_SECONDARY_VALID	(1<<27)
+#define   VIA_REG_AC97_PRIMARY_VALID	(1<<25)
+#define   VIA_REG_AC97_BUSY		(1<<24)
+#define   VIA_REG_AC97_READ		(1<<23)
+#define   VIA_REG_AC97_CMD_SHIFT	16
+#define   VIA_REG_AC97_CMD_MASK		0x7e
+#define   VIA_REG_AC97_DATA_SHIFT	0
+#define   VIA_REG_AC97_DATA_MASK	0xffff
+
+#define VIA_REG_SGD_SHADOW		0x84	/* dword */
+#define   VIA_REG_SGD_STAT_PB_FLAG	(1<<0)
+#define   VIA_REG_SGD_STAT_CP_FLAG	(1<<1)
+#define   VIA_REG_SGD_STAT_FM_FLAG	(1<<2)
+#define   VIA_REG_SGD_STAT_PB_EOL	(1<<4)
+#define   VIA_REG_SGD_STAT_CP_EOL	(1<<5)
+#define   VIA_REG_SGD_STAT_FM_EOL	(1<<6)
+#define   VIA_REG_SGD_STAT_PB_STOP	(1<<8)
+#define   VIA_REG_SGD_STAT_CP_STOP	(1<<9)
+#define   VIA_REG_SGD_STAT_FM_STOP	(1<<10)
+#define   VIA_REG_SGD_STAT_PB_ACTIVE	(1<<12)
+#define   VIA_REG_SGD_STAT_CP_ACTIVE	(1<<13)
+#define   VIA_REG_SGD_STAT_FM_ACTIVE	(1<<14)
+#define   VIA_REG_SGD_STAT_MR_FLAG      (1<<16)
+#define   VIA_REG_SGD_STAT_MW_FLAG      (1<<17)
+#define   VIA_REG_SGD_STAT_MR_EOL       (1<<20)
+#define   VIA_REG_SGD_STAT_MW_EOL       (1<<21)
+#define   VIA_REG_SGD_STAT_MR_STOP      (1<<24)
+#define   VIA_REG_SGD_STAT_MW_STOP      (1<<25)
+#define   VIA_REG_SGD_STAT_MR_ACTIVE    (1<<28)
+#define   VIA_REG_SGD_STAT_MW_ACTIVE    (1<<29)
+
+#define VIA_REG_GPI_STATUS		0x88
+#define VIA_REG_GPI_INTR		0x8c
+
+#define VIA_TBL_BIT_FLAG	0x40000000
+#define VIA_TBL_BIT_EOL		0x80000000
+
+/* pci space */
+#define VIA_ACLINK_STAT		0x40
+#define  VIA_ACLINK_C11_READY	0x20
+#define  VIA_ACLINK_C10_READY	0x10
+#define  VIA_ACLINK_C01_READY	0x04 /* secondary codec ready */
+#define  VIA_ACLINK_LOWPOWER	0x02 /* low-power state */
+#define  VIA_ACLINK_C00_READY	0x01 /* primary codec ready */
+#define VIA_ACLINK_CTRL		0x41
+#define  VIA_ACLINK_CTRL_ENABLE	0x80 /* 0: disable, 1: enable */
+#define  VIA_ACLINK_CTRL_RESET	0x40 /* 0: assert, 1: de-assert */
+#define  VIA_ACLINK_CTRL_SYNC	0x20 /* 0: release SYNC, 1: force SYNC hi */
+#define  VIA_ACLINK_CTRL_SDO	0x10 /* 0: release SDO, 1: force SDO hi */
+#define  VIA_ACLINK_CTRL_VRA	0x08 /* 0: disable VRA, 1: enable VRA */
+#define  VIA_ACLINK_CTRL_PCM	0x04 /* 0: disable PCM, 1: enable PCM */
+#define  VIA_ACLINK_CTRL_FM	0x02 /* via686 only */
+#define  VIA_ACLINK_CTRL_SB	0x01 /* via686 only */
+#define  VIA_ACLINK_CTRL_INIT	(VIA_ACLINK_CTRL_ENABLE|\
+				 VIA_ACLINK_CTRL_RESET|\
+				 VIA_ACLINK_CTRL_PCM)
+#define VIA_FUNC_ENABLE		0x42
+#define  VIA_FUNC_MIDI_PNP	0x80 /* FIXME: it's 0x40 in the datasheet! */
+#define  VIA_FUNC_MIDI_IRQMASK	0x40 /* FIXME: not documented! */
+#define  VIA_FUNC_RX2C_WRITE	0x20
+#define  VIA_FUNC_SB_FIFO_EMPTY	0x10
+#define  VIA_FUNC_ENABLE_GAME	0x08
+#define  VIA_FUNC_ENABLE_FM	0x04
+#define  VIA_FUNC_ENABLE_MIDI	0x02
+#define  VIA_FUNC_ENABLE_SB	0x01
+#define VIA_PNP_CONTROL		0x43
+#define VIA_MC97_CTRL		0x44
+#define  VIA_MC97_CTRL_ENABLE   0x80
+#define  VIA_MC97_CTRL_SECONDARY 0x40
+#define  VIA_MC97_CTRL_INIT     (VIA_MC97_CTRL_ENABLE|\
+                                 VIA_MC97_CTRL_SECONDARY)
+
+
+typedef struct _snd_via82xx_modem via82xx_t;
+typedef struct via_dev viadev_t;
+
+/*
+ * pcm stream
+ */
+
+struct snd_via_sg_table {
+	unsigned int offset;
+	unsigned int size;
+} ;
+
+#define VIA_TABLE_SIZE	255
+
+struct via_dev {
+	unsigned int reg_offset;
+	unsigned long port;
+	int direction;	/* playback = 0, capture = 1 */
+        snd_pcm_substream_t *substream;
+	int running;
+	unsigned int tbl_entries; /* # descriptors */
+	struct snd_dma_buffer table;
+	struct snd_via_sg_table *idx_table;
+	/* for recovery from the unexpected pointer */
+	unsigned int lastpos;
+	unsigned int bufsize;
+	unsigned int bufsize2;
+};
+
+enum { TYPE_CARD_VIA82XX_MODEM = 1 };
+
+#define VIA_MAX_MODEM_DEVS	2
+
+struct _snd_via82xx_modem {
+	int irq;
+
+	unsigned long port;
+
+	unsigned int intr_mask; /* SGD_SHADOW mask to check interrupts */
+
+	struct pci_dev *pci;
+	snd_card_t *card;
+
+	unsigned int num_devs;
+	unsigned int playback_devno, capture_devno;
+	viadev_t devs[VIA_MAX_MODEM_DEVS];
+
+	snd_pcm_t *pcms[2];
+
+	ac97_bus_t *ac97_bus;
+	ac97_t *ac97;
+	unsigned int ac97_clock;
+	unsigned int ac97_secondary;	/* secondary AC'97 codec is present */
+
+	spinlock_t reg_lock;
+	snd_info_entry_t *proc_entry;
+};
+
+static struct pci_device_id snd_via82xx_modem_ids[] = {
+	{ 0x1106, 0x3068, PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPE_CARD_VIA82XX_MODEM, },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_via82xx_modem_ids);
+
+/*
+ */
+
+/*
+ * allocate and initialize the descriptor buffers
+ * periods = number of periods
+ * fragsize = period size in bytes
+ */
+static int build_via_table(viadev_t *dev, snd_pcm_substream_t *substream,
+			   struct pci_dev *pci,
+			   unsigned int periods, unsigned int fragsize)
+{
+	unsigned int i, idx, ofs, rest;
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_sg_buf *sgbuf = snd_pcm_substream_sgbuf(substream);
+
+	if (dev->table.area == NULL) {
+		/* the start of each lists must be aligned to 8 bytes,
+		 * but the kernel pages are much bigger, so we don't care
+		 */
+		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
+					PAGE_ALIGN(VIA_TABLE_SIZE * 2 * 8),
+					&dev->table) < 0)
+			return -ENOMEM;
+	}
+	if (! dev->idx_table) {
+		dev->idx_table = kmalloc(sizeof(*dev->idx_table) * VIA_TABLE_SIZE, GFP_KERNEL);
+		if (! dev->idx_table)
+			return -ENOMEM;
+	}
+
+	/* fill the entries */
+	idx = 0;
+	ofs = 0;
+	for (i = 0; i < periods; i++) {
+		rest = fragsize;
+		/* fill descriptors for a period.
+		 * a period can be split to several descriptors if it's
+		 * over page boundary.
+		 */
+		do {
+			unsigned int r;
+			unsigned int flag;
+
+			if (idx >= VIA_TABLE_SIZE) {
+				snd_printk(KERN_ERR "via82xx: too much table size!\n");
+				return -EINVAL;
+			}
+			((u32 *)dev->table.area)[idx << 1] = cpu_to_le32((u32)snd_pcm_sgbuf_get_addr(sgbuf, ofs));
+			r = PAGE_SIZE - (ofs % PAGE_SIZE);
+			if (rest < r)
+				r = rest;
+			rest -= r;
+			if (! rest) {
+				if (i == periods - 1)
+					flag = VIA_TBL_BIT_EOL; /* buffer boundary */
+				else
+					flag = VIA_TBL_BIT_FLAG; /* period boundary */
+			} else
+				flag = 0; /* period continues to the next */
+			// printk("via: tbl %d: at %d  size %d (rest %d)\n", idx, ofs, r, rest);
+			((u32 *)dev->table.area)[(idx<<1) + 1] = cpu_to_le32(r | flag);
+			dev->idx_table[idx].offset = ofs;
+			dev->idx_table[idx].size = r;
+			ofs += r;
+			idx++;
+		} while (rest > 0);
+	}
+	dev->tbl_entries = idx;
+	dev->bufsize = periods * fragsize;
+	dev->bufsize2 = dev->bufsize / 2;
+	return 0;
+}
+
+
+static int clean_via_table(viadev_t *dev, snd_pcm_substream_t *substream,
+			   struct pci_dev *pci)
+{
+	if (dev->table.area) {
+		snd_dma_free_pages(&dev->table);
+		dev->table.area = NULL;
+	}
+	if (dev->idx_table) {
+		kfree(dev->idx_table);
+		dev->idx_table = NULL;
+	}
+	return 0;
+}
+
+/*
+ *  Basic I/O
+ */
+
+static inline unsigned int snd_via82xx_codec_xread(via82xx_t *chip)
+{
+	return inl(VIAREG(chip, AC97));
+}
+ 
+static inline void snd_via82xx_codec_xwrite(via82xx_t *chip, unsigned int val)
+{
+	outl(val, VIAREG(chip, AC97));
+}
+ 
+static int snd_via82xx_codec_ready(via82xx_t *chip, int secondary)
+{
+	unsigned int timeout = 1000;	/* 1ms */
+	unsigned int val;
+	
+	while (timeout-- > 0) {
+		udelay(1);
+		if (!((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_BUSY))
+			return val & 0xffff;
+	}
+	snd_printk(KERN_ERR "codec_ready: codec %i is not ready [0x%x]\n", secondary, snd_via82xx_codec_xread(chip));
+	return -EIO;
+}
+ 
+static int snd_via82xx_codec_valid(via82xx_t *chip, int secondary)
+{
+	unsigned int timeout = 1000;	/* 1ms */
+	unsigned int val, val1;
+	unsigned int stat = !secondary ? VIA_REG_AC97_PRIMARY_VALID :
+					 VIA_REG_AC97_SECONDARY_VALID;
+	
+	while (timeout-- > 0) {
+		val = snd_via82xx_codec_xread(chip);
+		val1 = val & (VIA_REG_AC97_BUSY | stat);
+		if (val1 == stat)
+			return val & 0xffff;
+		udelay(1);
+	}
+	return -EIO;
+}
+ 
+static void snd_via82xx_codec_wait(ac97_t *ac97)
+{
+	via82xx_t *chip = ac97->private_data;
+	int err;
+	err = snd_via82xx_codec_ready(chip, ac97->num);
+	/* here we need to wait fairly for long time.. */
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ/2);
+}
+
+static void snd_via82xx_codec_write(ac97_t *ac97,
+				    unsigned short reg,
+				    unsigned short val)
+{
+	via82xx_t *chip = ac97->private_data;
+	unsigned int xval;
+	
+	xval = !ac97->num ? VIA_REG_AC97_CODEC_ID_PRIMARY : VIA_REG_AC97_CODEC_ID_SECONDARY;
+	xval <<= VIA_REG_AC97_CODEC_ID_SHIFT;
+	xval |= reg << VIA_REG_AC97_CMD_SHIFT;
+	xval |= val << VIA_REG_AC97_DATA_SHIFT;
+	snd_via82xx_codec_xwrite(chip, xval);
+	snd_via82xx_codec_ready(chip, ac97->num);
+}
+
+static unsigned short snd_via82xx_codec_read(ac97_t *ac97, unsigned short reg)
+{
+	via82xx_t *chip = ac97->private_data;
+	unsigned int xval, val = 0xffff;
+	int again = 0;
+
+	xval = ac97->num << VIA_REG_AC97_CODEC_ID_SHIFT;
+	xval |= ac97->num ? VIA_REG_AC97_SECONDARY_VALID : VIA_REG_AC97_PRIMARY_VALID;
+	xval |= VIA_REG_AC97_READ;
+	xval |= (reg & 0x7f) << VIA_REG_AC97_CMD_SHIFT;
+      	while (1) {
+      		if (again++ > 3) {
+			snd_printk(KERN_ERR "codec_read: codec %i is not valid [0x%x]\n", ac97->num, snd_via82xx_codec_xread(chip));
+		      	return 0xffff;
+		}
+		snd_via82xx_codec_xwrite(chip, xval);
+		udelay (20);
+		if (snd_via82xx_codec_valid(chip, ac97->num) >= 0) {
+			udelay(25);
+			val = snd_via82xx_codec_xread(chip);
+			break;
+		}
+	}
+	return val & 0xffff;
+}
+
+static void snd_via82xx_channel_reset(via82xx_t *chip, viadev_t *viadev)
+{
+	outb(VIA_REG_CTRL_PAUSE | VIA_REG_CTRL_TERMINATE | VIA_REG_CTRL_RESET,
+	     VIADEV_REG(viadev, OFFSET_CONTROL));
+	inb(VIADEV_REG(viadev, OFFSET_CONTROL));
+	udelay(50);
+	/* disable interrupts */
+	outb(0x00, VIADEV_REG(viadev, OFFSET_CONTROL));
+	/* clear interrupts */
+	outb(0x03, VIADEV_REG(viadev, OFFSET_STATUS));
+	outb(0x00, VIADEV_REG(viadev, OFFSET_TYPE)); /* for via686 */
+	// outl(0, VIADEV_REG(viadev, OFFSET_CURR_PTR));
+	viadev->lastpos = 0;
+}
+
+
+/*
+ *  Interrupt handler
+ */
+
+static irqreturn_t snd_via82xx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	via82xx_t *chip = dev_id;
+	unsigned int status;
+	unsigned int i;
+
+	status = inl(VIAREG(chip, SGD_SHADOW));
+	if (! (status & chip->intr_mask)) {
+		return IRQ_NONE;
+	}
+// _skip_sgd:
+
+	/* check status for each stream */
+	spin_lock(&chip->reg_lock);
+	for (i = 0; i < chip->num_devs; i++) {
+		viadev_t *viadev = &chip->devs[i];
+		unsigned char c_status = inb(VIADEV_REG(viadev, OFFSET_STATUS));
+		c_status &= (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG|VIA_REG_STAT_STOPPED);
+		if (! c_status)
+			continue;
+		if (viadev->substream && viadev->running) {
+			spin_unlock(&chip->reg_lock);
+			snd_pcm_period_elapsed(viadev->substream);
+			spin_lock(&chip->reg_lock);
+		}
+		outb(c_status, VIADEV_REG(viadev, OFFSET_STATUS)); /* ack */
+	}
+	spin_unlock(&chip->reg_lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ *  PCM callbacks
+ */
+
+/*
+ * trigger callback
+ */
+static int snd_via82xx_pcm_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	viadev_t *viadev = (viadev_t *)substream->runtime->private_data;
+	unsigned char val = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		val |= VIA_REG_CTRL_START;
+		viadev->running = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		val = VIA_REG_CTRL_TERMINATE;
+		viadev->running = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		val |= VIA_REG_CTRL_PAUSE;
+		viadev->running = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		viadev->running = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	outb(val, VIADEV_REG(viadev, OFFSET_CONTROL));
+	if (cmd == SNDRV_PCM_TRIGGER_STOP)
+		snd_via82xx_channel_reset(chip, viadev);
+	return 0;
+}
+
+static int snd_via82xx_modem_pcm_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	unsigned int val = 0;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		val = snd_ac97_read(chip->ac97, AC97_GPIO_STATUS);
+		outl(val|AC97_GPIO_LINE1_OH, VIAREG(chip, GPI_STATUS));
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		val = snd_ac97_read(chip->ac97, AC97_GPIO_STATUS);
+		outl(val&~AC97_GPIO_LINE1_OH, VIAREG(chip, GPI_STATUS));
+		break;
+	default:
+		break;
+	}
+	return snd_via82xx_pcm_trigger(substream, cmd);
+}
+
+/*
+ * pointer callbacks
+ */
+
+/*
+ * calculate the linear position at the given sg-buffer index and the rest count
+ */
+
+#define check_invalid_pos(viadev,pos) \
+	((pos) < viadev->lastpos && ((pos) >= viadev->bufsize2 || viadev->lastpos < viadev->bufsize2))
+
+static inline unsigned int calc_linear_pos(viadev_t *viadev, unsigned int idx, unsigned int count)
+{
+	unsigned int size, res;
+
+	size = viadev->idx_table[idx].size;
+	res = viadev->idx_table[idx].offset + size - count;
+
+	/* check the validity of the calculated position */
+	if (size < count) {
+		snd_printd(KERN_ERR "invalid via82xx_cur_ptr (size = %d, count = %d)\n", (int)size, (int)count);
+		res = viadev->lastpos;
+	} else if (check_invalid_pos(viadev, res)) {
+#ifdef POINTER_DEBUG
+		printk("fail: idx = %i/%i, lastpos = 0x%x, bufsize2 = 0x%x, offsize = 0x%x, size = 0x%x, count = 0x%x\n", idx, viadev->tbl_entries, viadev->lastpos, viadev->bufsize2, viadev->idx_table[idx].offset, viadev->idx_table[idx].size, count);
+#endif
+		if (count && size < count) {
+			snd_printd(KERN_ERR "invalid via82xx_cur_ptr, using last valid pointer\n");
+			res = viadev->lastpos;
+		} else {
+			if (! count)
+				/* bogus count 0 on the DMA boundary? */
+				res = viadev->idx_table[idx].offset;
+			else
+				/* count register returns full size when end of buffer is reached */
+				res = viadev->idx_table[idx].offset + size;
+			if (check_invalid_pos(viadev, res)) {
+				snd_printd(KERN_ERR "invalid via82xx_cur_ptr (2), using last valid pointer\n");
+				res = viadev->lastpos;
+			}
+		}
+	}
+	viadev->lastpos = res; /* remember the last position */
+	if (res >= viadev->bufsize)
+		res -= viadev->bufsize;
+	return res;
+}
+
+/*
+ * get the current pointer on via686
+ */
+static snd_pcm_uframes_t snd_via686_pcm_pointer(snd_pcm_substream_t *substream)
+{
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	viadev_t *viadev = (viadev_t *)substream->runtime->private_data;
+	unsigned int idx, ptr, count, res;
+
+	snd_assert(viadev->tbl_entries, return 0);
+	if (!(inb(VIADEV_REG(viadev, OFFSET_STATUS)) & VIA_REG_STAT_ACTIVE))
+		return 0;
+
+	spin_lock(&chip->reg_lock);
+	count = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT)) & 0xffffff;
+	/* The via686a does not have the current index register,
+	 * so we need to calculate the index from CURR_PTR.
+	 */
+	ptr = inl(VIADEV_REG(viadev, OFFSET_CURR_PTR));
+	if (ptr <= (unsigned int)viadev->table.addr)
+		idx = 0;
+	else /* CURR_PTR holds the address + 8 */
+		idx = ((ptr - (unsigned int)viadev->table.addr) / 8 - 1) % viadev->tbl_entries;
+	res = calc_linear_pos(viadev, idx, count);
+	spin_unlock(&chip->reg_lock);
+
+	return bytes_to_frames(substream->runtime, res);
+}
+
+/*
+ * hw_params callback:
+ * allocate the buffer and build up the buffer description table
+ */
+static int snd_via82xx_hw_params(snd_pcm_substream_t * substream,
+				 snd_pcm_hw_params_t * hw_params)
+{
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	viadev_t *viadev = (viadev_t *)substream->runtime->private_data;
+	int err;
+
+	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+	if (err < 0)
+		return err;
+	err = build_via_table(viadev, substream, chip->pci,
+			      params_periods(hw_params),
+			      params_period_bytes(hw_params));
+	if (err < 0)
+		return err;
+
+	snd_ac97_write(chip->ac97, AC97_LINE1_RATE, params_rate(hw_params));
+	snd_ac97_write(chip->ac97, AC97_LINE1_LEVEL, 0);
+
+	return 0;
+}
+
+/*
+ * hw_free callback:
+ * clean up the buffer description table and release the buffer
+ */
+static int snd_via82xx_hw_free(snd_pcm_substream_t * substream)
+{
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	viadev_t *viadev = (viadev_t *)substream->runtime->private_data;
+
+	clean_via_table(viadev, substream, chip->pci);
+	snd_pcm_lib_free_pages(substream);
+	return 0;
+}
+
+
+/*
+ * set up the table pointer
+ */
+static void snd_via82xx_set_table_ptr(via82xx_t *chip, viadev_t *viadev)
+{
+	snd_via82xx_codec_ready(chip, chip->ac97_secondary);
+	outl((u32)viadev->table.addr, VIADEV_REG(viadev, OFFSET_TABLE_PTR));
+	udelay(20);
+	snd_via82xx_codec_ready(chip, chip->ac97_secondary);
+}
+
+/*
+ * prepare callback for playback and capture
+ */
+static int snd_via82xx_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	viadev_t *viadev = (viadev_t *)substream->runtime->private_data;
+
+	snd_via82xx_channel_reset(chip, viadev);
+	/* this must be set after channel_reset */
+	snd_via82xx_set_table_ptr(chip, viadev);
+	outb(VIA_REG_TYPE_AUTOSTART|VIA_REG_TYPE_INT_EOL|VIA_REG_TYPE_INT_FLAG,
+	     VIADEV_REG(viadev, OFFSET_TYPE));
+	return 0;
+}
+
+/*
+ * pcm hardware definition, identical for both playback and capture
+ */
+static snd_pcm_hardware_t snd_via82xx_hw =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_RESUME |
+				 SNDRV_PCM_INFO_PAUSE),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_KNOT,
+	.rate_min =		8000,
+	.rate_max =		16000,
+	.channels_min =		1,
+	.channels_max =		1,
+	.buffer_bytes_max =	128 * 1024,
+	.period_bytes_min =	32,
+	.period_bytes_max =	128 * 1024,
+	.periods_min =		2,
+	.periods_max =		VIA_TABLE_SIZE / 2,
+	.fifo_size =		0,
+};
+
+
+/*
+ * open callback skeleton
+ */
+static int snd_via82xx_modem_pcm_open(via82xx_t *chip, viadev_t *viadev, snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+        static unsigned int rates[] = { 8000,  9600, 12000, 16000 };
+        static snd_pcm_hw_constraint_list_t hw_constraints_rates = {
+                .count = ARRAY_SIZE(rates),
+                .list = rates,
+                .mask = 0,
+        };
+
+	runtime->hw = snd_via82xx_hw;
+	
+        if ((err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates)) < 0)
+                return err;
+
+	/* we may remove following constaint when we modify table entries
+	   in interrupt */
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+
+	runtime->private_data = viadev;
+	viadev->substream = substream;
+
+	return 0;
+}
+
+
+/*
+ * open callback for playback
+ */
+static int snd_via82xx_playback_open(snd_pcm_substream_t * substream)
+{
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	viadev_t *viadev = &chip->devs[chip->playback_devno + substream->number];
+
+	return snd_via82xx_modem_pcm_open(chip, viadev, substream);
+}
+
+/*
+ * open callback for capture
+ */
+static int snd_via82xx_capture_open(snd_pcm_substream_t * substream)
+{
+	via82xx_t *chip = snd_pcm_substream_chip(substream);
+	viadev_t *viadev = &chip->devs[chip->capture_devno + substream->pcm->device];
+
+	return snd_via82xx_modem_pcm_open(chip, viadev, substream);
+}
+
+/*
+ * close callback
+ */
+static int snd_via82xx_pcm_close(snd_pcm_substream_t * substream)
+{
+	viadev_t *viadev = (viadev_t *)substream->runtime->private_data;
+
+	viadev->substream = NULL;
+	return 0;
+}
+
+
+/* via686 playback callbacks */
+static snd_pcm_ops_t snd_via686_playback_ops = {
+	.open =		snd_via82xx_playback_open,
+	.close =	snd_via82xx_pcm_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_via82xx_hw_params,
+	.hw_free =	snd_via82xx_hw_free,
+	.prepare =	snd_via82xx_pcm_prepare,
+	.trigger =	snd_via82xx_modem_pcm_trigger,
+	.pointer =	snd_via686_pcm_pointer,
+	.page =		snd_pcm_sgbuf_ops_page,
+};
+
+/* via686 capture callbacks */
+static snd_pcm_ops_t snd_via686_capture_ops = {
+	.open =		snd_via82xx_capture_open,
+	.close =	snd_via82xx_pcm_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_via82xx_hw_params,
+	.hw_free =	snd_via82xx_hw_free,
+	.prepare =	snd_via82xx_pcm_prepare,
+	.trigger =	snd_via82xx_modem_pcm_trigger,
+	.pointer =	snd_via686_pcm_pointer,
+	.page =		snd_pcm_sgbuf_ops_page,
+};
+
+
+static void init_viadev(via82xx_t *chip, int idx, unsigned int reg_offset, int direction)
+{
+	chip->devs[idx].reg_offset = reg_offset;
+	chip->devs[idx].direction = direction;
+	chip->devs[idx].port = chip->port + reg_offset;
+}
+
+/*
+ * create a pcm instance for via686a/b
+ */
+static int __devinit snd_via686_pcm_new(via82xx_t *chip)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	chip->playback_devno = 0;
+	chip->capture_devno = 1;
+	chip->num_devs = 2;
+	chip->intr_mask = 0x330000; /* FLAGS | EOL for MR, MW */
+
+	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via686_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via686_capture_ops);
+	pcm->private_data = chip;
+	strcpy(pcm->name, chip->card->shortname);
+	chip->pcms[0] = pcm;
+	init_viadev(chip, 0, VIA_REG_MO_STATUS, 0);
+	init_viadev(chip, 1, VIA_REG_MI_STATUS, 1);
+
+	if ((err = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
+							 snd_dma_pci_data(chip->pci), 64*1024, 128*1024)) < 0)
+		return err;
+
+	return 0;
+}
+
+
+/*
+ *  Mixer part
+ */
+
+
+static void snd_via82xx_mixer_free_ac97_bus(ac97_bus_t *bus)
+{
+	via82xx_t *chip = bus->private_data;
+	chip->ac97_bus = NULL;
+}
+
+static void snd_via82xx_mixer_free_ac97(ac97_t *ac97)
+{
+	via82xx_t *chip = ac97->private_data;
+	chip->ac97 = NULL;
+}
+
+
+static int __devinit snd_via82xx_mixer_new(via82xx_t *chip)
+{
+	ac97_template_t ac97;
+	int err;
+	static ac97_bus_ops_t ops = {
+		.write = snd_via82xx_codec_write,
+		.read = snd_via82xx_codec_read,
+		.wait = snd_via82xx_codec_wait,
+	};
+
+	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)
+		return err;
+	chip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;
+	chip->ac97_bus->clock = chip->ac97_clock;
+	chip->ac97_bus->shared_type = AC97_SHARED_TYPE_VIA;
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+	ac97.private_free = snd_via82xx_mixer_free_ac97;
+	ac97.pci = chip->pci;
+	ac97.scaps = AC97_SCAP_SKIP_AUDIO;
+	ac97.num = chip->ac97_secondary;
+
+	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
+		return err;
+
+	return 0;
+}
+
+
+/*
+ * proc interface
+ */
+static void snd_via82xx_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	via82xx_t *chip = entry->private_data;
+	int i;
+	
+	snd_iprintf(buffer, "%s\n\n", chip->card->longname);
+	for (i = 0; i < 0xa0; i += 4) {
+		snd_iprintf(buffer, "%02x: %08x\n", i, inl(chip->port + i));
+	}
+}
+
+static void __devinit snd_via82xx_proc_init(via82xx_t *chip)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(chip->card, "via82xx", &entry))
+		snd_info_set_text_ops(entry, chip, 1024, snd_via82xx_proc_read);
+}
+
+/*
+ *
+ */
+
+static int __devinit snd_via82xx_chip_init(via82xx_t *chip)
+{
+	ac97_t ac97;
+	unsigned int val;
+	int max_count;
+	unsigned char pval;
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+
+	pci_read_config_byte(chip->pci, VIA_MC97_CTRL, &pval);
+	if((pval & VIA_MC97_CTRL_INIT) != VIA_MC97_CTRL_INIT) {
+		pci_write_config_byte(chip->pci, 0x44, pval|VIA_MC97_CTRL_INIT);
+		udelay(100);
+	}
+
+	pci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);
+	if (! (pval & VIA_ACLINK_C00_READY)) { /* codec not ready? */
+		/* deassert ACLink reset, force SYNC */
+		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,
+				      VIA_ACLINK_CTRL_ENABLE |
+				      VIA_ACLINK_CTRL_RESET |
+				      VIA_ACLINK_CTRL_SYNC);
+		udelay(100);
+#if 1 /* FIXME: should we do full reset here for all chip models? */
+		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, 0x00);
+		udelay(100);
+#else
+		/* deassert ACLink reset, force SYNC (warm AC'97 reset) */
+		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,
+				      VIA_ACLINK_CTRL_RESET|VIA_ACLINK_CTRL_SYNC);
+		udelay(2);
+#endif
+		/* ACLink on, deassert ACLink reset, VSR, SGD data out */
+		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);
+		udelay(100);
+	}
+	
+	pci_read_config_byte(chip->pci, VIA_ACLINK_CTRL, &pval);
+	if ((pval & VIA_ACLINK_CTRL_INIT) != VIA_ACLINK_CTRL_INIT) {
+		/* ACLink on, deassert ACLink reset, VSR, SGD data out */
+		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);
+		udelay(100);
+	}
+
+	/* wait until codec ready */
+	max_count = ((3 * HZ) / 4) + 1;
+	do {
+		pci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);
+		if (pval & VIA_ACLINK_C00_READY) /* primary codec ready */
+			break;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while (--max_count > 0);
+
+	if ((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_BUSY)
+		snd_printk("AC'97 codec is not ready [0x%x]\n", val);
+
+	/* and then reset codec.. */
+#if 0 /* do we need it? when? */
+	snd_via82xx_codec_ready(chip, 0);
+	snd_via82xx_codec_write(&ac97, AC97_RESET, 0x0000);
+	snd_via82xx_codec_read(&ac97, 0);
+#endif
+
+	snd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |
+				 VIA_REG_AC97_SECONDARY_VALID |
+				 (VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));
+	max_count = ((3 * HZ) / 4) + 1;
+	snd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |
+				 VIA_REG_AC97_SECONDARY_VALID |
+				 (VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));
+	do {
+		if ((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_SECONDARY_VALID) {
+			chip->ac97_secondary = 1;
+			goto __ac97_ok2;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+	} while (--max_count > 0);
+	/* This is ok, the most of motherboards have only one codec */
+
+      __ac97_ok2:
+
+	/* route FM trap to IRQ, disable FM trap */
+	// pci_write_config_byte(chip->pci, VIA_FM_NMI_CTRL, 0);
+	/* disable all GPI interrupts */
+	outl(0, VIAREG(chip, GPI_INTR));
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*
+ * power management
+ */
+static int snd_via82xx_suspend(snd_card_t *card, unsigned int state)
+{
+	via82xx_t *chip = card->pm_private_data;
+	int i;
+
+	for (i = 0; i < 2; i++)
+		if (chip->pcms[i])
+			snd_pcm_suspend_all(chip->pcms[i]);
+	for (i = 0; i < chip->num_devs; i++)
+		snd_via82xx_channel_reset(chip, &chip->devs[i]);
+	synchronize_irq(chip->irq);
+	snd_ac97_suspend(chip->ac97);
+	pci_set_power_state(chip->pci, 3);
+	pci_disable_device(chip->pci);
+	return 0;
+}
+
+static int snd_via82xx_resume(snd_card_t *card, unsigned int state)
+{
+	via82xx_t *chip = card->pm_private_data;
+	int i;
+
+	pci_enable_device(chip->pci);
+	pci_set_power_state(chip->pci, 0);
+	pci_set_master(chip->pci);
+
+	snd_via82xx_chip_init(chip);
+
+	snd_ac97_resume(chip->ac97);
+
+	for (i = 0; i < chip->num_devs; i++)
+		snd_via82xx_channel_reset(chip, &chip->devs[i]);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static int snd_via82xx_free(via82xx_t *chip)
+{
+	unsigned int i;
+
+	if (chip->irq < 0)
+		goto __end_hw;
+	/* disable interrupts */
+	for (i = 0; i < chip->num_devs; i++)
+		snd_via82xx_channel_reset(chip, &chip->devs[i]);
+	synchronize_irq(chip->irq);
+      __end_hw:
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+	kfree(chip);
+	return 0;
+}
+
+static int snd_via82xx_dev_free(snd_device_t *device)
+{
+	via82xx_t *chip = device->device_data;
+	return snd_via82xx_free(chip);
+}
+
+static int __devinit snd_via82xx_create(snd_card_t * card,
+					struct pci_dev *pci,
+					int chip_type,
+					int revision,
+					unsigned int ac97_clock,
+					via82xx_t ** r_via)
+{
+	via82xx_t *chip;
+	int err;
+        static snd_device_ops_t ops = {
+		.dev_free =	snd_via82xx_dev_free,
+        };
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	if ((chip = kcalloc(1, sizeof(*chip), GFP_KERNEL)) == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&chip->reg_lock);
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+
+	if ((err = pci_request_regions(pci, card->driver)) < 0) {
+		kfree(chip);
+		pci_disable_device(pci);
+		return err;
+	}
+	chip->port = pci_resource_start(pci, 0);
+	if (request_irq(pci->irq, snd_via82xx_interrupt, SA_INTERRUPT|SA_SHIRQ,
+			card->driver, (void *)chip)) {
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_via82xx_free(chip);
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+	if (ac97_clock >= 8000 && ac97_clock <= 48000)
+		chip->ac97_clock = ac97_clock;
+	synchronize_irq(chip->irq);
+
+	if ((err = snd_via82xx_chip_init(chip)) < 0) {
+		snd_via82xx_free(chip);
+		return err;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
+		snd_via82xx_free(chip);
+		return err;
+	}
+
+	/* The 8233 ac97 controller does not implement the master bit
+	 * in the pci command register. IMHO this is a violation of the PCI spec.
+	 * We call pci_set_master here because it does not hurt. */
+	pci_set_master(pci);
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*r_via = chip;
+	return 0;
+}
+
+
+static int __devinit snd_via82xx_probe(struct pci_dev *pci,
+				       const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	via82xx_t *chip;
+	unsigned char revision;
+	int chip_type = 0, card_type;
+	unsigned int i;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	card_type = pci_id->driver_data;
+	pci_read_config_byte(pci, PCI_REVISION_ID, &revision);
+	switch (card_type) {
+	case TYPE_CARD_VIA82XX_MODEM:
+		strcpy(card->driver, "VIA82XX-MODEM");
+		sprintf(card->shortname, "VIA 82XX modem");
+		break;
+	default:
+		snd_printk(KERN_ERR "invalid card type %d\n", card_type);
+		err = -EINVAL;
+		goto __error;
+	}
+		
+	if ((err = snd_via82xx_create(card, pci, chip_type, revision, ac97_clock[dev], &chip)) < 0)
+		goto __error;
+	if ((err = snd_via82xx_mixer_new(chip)) < 0)
+		goto __error;
+
+	if ((err = snd_via686_pcm_new(chip)) < 0 )
+		goto __error;
+
+	snd_card_set_pm_callback(card, snd_via82xx_suspend, snd_via82xx_resume, chip);
+
+	/* disable interrupts */
+	for (i = 0; i < chip->num_devs; i++)
+		snd_via82xx_channel_reset(chip, &chip->devs[i]);
+
+	sprintf(card->longname, "%s at 0x%lx, irq %d",
+		card->shortname, chip->port, chip->irq);
+
+	snd_via82xx_proc_init(chip);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+
+ __error:
+	snd_card_free(card);
+	return err;
+}
+
+static void __devexit snd_via82xx_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "VIA 82xx Modem",
+	.id_table = snd_via82xx_modem_ids,
+	.probe = snd_via82xx_probe,
+	.remove = __devexit_p(snd_via82xx_remove),
+	SND_PCI_PM_CALLBACKS
+};
+
+static int __init alsa_card_via82xx_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_via82xx_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_via82xx_init)
+module_exit(alsa_card_via82xx_exit)
diff -uNr a/sound/pci/vx222/vx222.c b/sound/pci/vx222/vx222.c
--- a/sound/pci/vx222/vx222.c	2004-12-24 22:34:57.000000000 +0100
+++ b/sound/pci/vx222/vx222.c	2005-01-14 22:28:12.398473576 +0100
@@ -61,8 +61,8 @@
 };
 
 static struct pci_device_id snd_vx222_ids[] = {
-	{ 0x10b5, 0x9050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VX_PCI_VX222_OLD, },   /* PLX */
-	{ 0x10b5, 0x9030, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VX_PCI_VX222_NEW, },   /* PLX */
+	{ 0x10b5, 0x9050, 0x1369, PCI_ANY_ID, 0, 0, VX_PCI_VX222_OLD, },   /* PLX */
+	{ 0x10b5, 0x9030, 0x1369, PCI_ANY_ID, 0, 0, VX_PCI_VX222_NEW, },   /* PLX */
 	{ 0, }
 };
 
@@ -225,7 +225,11 @@
 	snd_printdd("%s at 0x%lx & 0x%lx, irq %i\n",
 		    card->shortname, vx->port[0], vx->port[1], vx->core.irq);
 
-	if ((err = snd_vx_hwdep_new(&vx->core)) < 0) {
+#ifdef SND_VX_FW_LOADER
+	vx->core.dev = &pci->dev;
+#endif
+
+	if ((err = snd_vx_setup_firmware(&vx->core)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
@@ -251,6 +255,7 @@
 	.id_table = snd_vx222_ids,
 	.probe = snd_vx222_probe,
 	.remove = __devexit_p(snd_vx222_remove),
+	SND_PCI_PM_CALLBACKS
 };
 
 static int __init alsa_card_vx222_init(void)
diff -uNr a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
--- a/sound/pci/vx222/vx222_ops.c	2004-12-24 22:33:48.000000000 +0100
+++ b/sound/pci/vx222/vx222_ops.c	2005-01-14 22:28:12.403472816 +0100
@@ -22,6 +22,7 @@
 
 #include <sound/driver.h>
 #include <linux/delay.h>
+#include <linux/firmware.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <asm/io.h>
@@ -351,12 +352,11 @@
 /*
  * load the xilinx image
  */
-static int vx2_load_xilinx_binary(vx_core_t *chip, const snd_hwdep_dsp_image_t *xilinx)
+static int vx2_load_xilinx_binary(vx_core_t *chip, const struct firmware *xilinx)
 {
 	unsigned int i;
 	unsigned int port;
-	unsigned char data;
-	unsigned char __user *image;
+	unsigned char *image;
 
 	/* XILINX reset (wait at least 1 milisecond between reset on and off). */
 	vx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE | VX_XILINX_RESET_MASK);
@@ -371,10 +371,9 @@
 	else
 		port = VX_GPIOC; /* VX222 V2 and VX222_MIC_BOARD with new PLX9030 use this register */
 
-	image = xilinx->image;
-	for (i = 0; i < xilinx->length; i++, image++) {
-		__get_user(data, image);
-		if (put_xilinx_data(chip, port, 8, data) < 0)
+	image = xilinx->data;
+	for (i = 0; i < xilinx->size; i++, image++) {
+		if (put_xilinx_data(chip, port, 8, *image) < 0)
 			return -EINVAL;
 		/* don't take too much time in this loop... */
 		cond_resched();
@@ -400,25 +399,22 @@
 /*
  * load the boot/dsp images
  */
-static int vx2_load_dsp(vx_core_t *vx, const snd_hwdep_dsp_image_t *dsp)
+static int vx2_load_dsp(vx_core_t *vx, int index, const struct firmware *dsp)
 {
 	int err;
 
-	if (*dsp->name)
-		snd_printdd("loading dsp [%d] %s, size = %Zd\n",
-			dsp->index, dsp->name, dsp->length);
-	switch (dsp->index) {
-	case 0:
+	switch (index) {
+	case 1:
 		/* xilinx image */
 		if ((err = vx2_load_xilinx_binary(vx, dsp)) < 0)
 			return err;
 		if ((err = vx2_test_xilinx(vx)) < 0)
 			return err;
 		return 0;
-	case 1:
+	case 2:
 		/* DSP boot */
 		return snd_vx_dsp_boot(vx, dsp);
-	case 2:
+	case 3:
 		/* DSP image */
 		return snd_vx_dsp_load(vx, dsp);
 	default:
diff -uNr a/sound/pci/ymfpci/ymfpci_main.c b/sound/pci/ymfpci/ymfpci_main.c
--- a/sound/pci/ymfpci/ymfpci_main.c	2004-12-24 22:35:25.000000000 +0100
+++ b/sound/pci/ymfpci/ymfpci_main.c	2005-01-14 22:28:12.410471752 +0100
@@ -258,7 +258,7 @@
 	return -ENOMEM;
 }
 
-int snd_ymfpci_voice_alloc(ymfpci_t *chip, ymfpci_voice_type_t type, int pair, ymfpci_voice_t **rvoice)
+static int snd_ymfpci_voice_alloc(ymfpci_t *chip, ymfpci_voice_type_t type, int pair, ymfpci_voice_t **rvoice)
 {
 	unsigned long flags;
 	int result;
@@ -278,7 +278,7 @@
 	return result;		
 }
 
-int snd_ymfpci_voice_free(ymfpci_t *chip, ymfpci_voice_t *pvoice)
+static int snd_ymfpci_voice_free(ymfpci_t *chip, ymfpci_voice_t *pvoice)
 {
 	unsigned long flags;
 	
@@ -831,8 +831,7 @@
 {
 	ymfpci_pcm_t *ypcm = runtime->private_data;
 	
-	if (ypcm)
-		kfree(ypcm);
+	kfree(ypcm);
 }
 
 static int snd_ymfpci_playback_open_1(snd_pcm_substream_t * substream)
@@ -1714,6 +1713,7 @@
 	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)
 		return err;
 	chip->ac97_bus->private_free = snd_ymfpci_mixer_free_ac97_bus;
+	chip->ac97_bus->no_vra = 1; /* YMFPCI doesn't need VRA */
 
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
@@ -1721,6 +1721,10 @@
 	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
 		return err;
 
+	/* to be sure */
+	snd_ac97_update_bits(chip->ac97, AC97_EXTENDED_STATUS,
+			     AC97_EA_VRA|AC97_EA_VRM, 0);
+
 	for (idx = 0; idx < ARRAY_SIZE(snd_ymfpci_controls); idx++) {
 		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_ymfpci_controls[idx], chip))) < 0)
 			return err;
@@ -2065,8 +2069,7 @@
 #endif
 
 #ifdef CONFIG_PM
-	if (chip->saved_regs)
-		vfree(chip->saved_regs);
+	vfree(chip->saved_regs);
 #endif
 	if (chip->mpu_res) {
 		release_resource(chip->mpu_res);
@@ -2155,7 +2158,6 @@
 	snd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0);
 	snd_ymfpci_disable_dsp(chip);
 	pci_disable_device(chip->pci);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -2183,7 +2185,6 @@
 		chip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT);
 		spin_unlock_irq(&chip->reg_lock);
 	}
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2265,13 +2266,13 @@
 	snd_card_set_pm_callback(card, snd_ymfpci_suspend, snd_ymfpci_resume, chip);
 #endif
 
-	snd_ymfpci_proc_init(card, chip);
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_ymfpci_free(chip);
 		return err;
 	}
 
+	snd_ymfpci_proc_init(card, chip);
+
 	snd_card_set_dev(card, &pci->dev);
 
 	*rchip = chip;
diff -uNr a/sound/pcmcia/pdaudiocf/pdaudiocf_core.c b/sound/pcmcia/pdaudiocf/pdaudiocf_core.c
--- a/sound/pcmcia/pdaudiocf/pdaudiocf_core.c	2004-12-24 22:34:27.000000000 +0100
+++ b/sound/pcmcia/pdaudiocf/pdaudiocf_core.c	2005-01-14 22:28:12.412471448 +0100
@@ -28,7 +28,7 @@
 /*
  *
  */
-unsigned char pdacf_ak4117_read(void *private_data, unsigned char reg)
+static unsigned char pdacf_ak4117_read(void *private_data, unsigned char reg)
 {
 	pdacf_t *chip = private_data;
 	unsigned long timeout;
@@ -60,7 +60,7 @@
 	return res;
 }
 
-void pdacf_ak4117_write(void *private_data, unsigned char reg, unsigned char val)
+static void pdacf_ak4117_write(void *private_data, unsigned char reg, unsigned char val)
 {
 	pdacf_t *chip = private_data;
 	unsigned long timeout;
@@ -267,7 +267,6 @@
 	outw(val, chip->port + PDAUDIOCF_REG_IER);
 	chip->chip_status |= PDAUDIOCF_STAT_IS_SUSPENDED;	/* ignore interrupts from now */
 	snd_pdacf_powerdown(chip);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -287,7 +286,6 @@
 	       (snd_ak4117_external_rate(chip->ak4117) <= 0 || !check_signal(chip)))
 		mdelay(1);
 	chip->chip_status &= ~PDAUDIOCF_STAT_IS_SUSPENDED;
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif
diff -uNr a/sound/pcmcia/pdaudiocf/pdaudiocf.h b/sound/pcmcia/pdaudiocf/pdaudiocf.h
--- a/sound/pcmcia/pdaudiocf/pdaudiocf.h	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/pcmcia/pdaudiocf/pdaudiocf.h	2005-01-14 22:28:12.414471144 +0100
@@ -130,8 +130,6 @@
 	return inw(chip->port + reg);
 }
 
-unsigned char pdacf_ak4117_read(void *private_data, unsigned char reg);
-void pdacf_ak4117_write(void *private_data, unsigned char reg, unsigned char val);
 pdacf_t *snd_pdacf_create(snd_card_t *card);
 int snd_pdacf_ak4117_create(pdacf_t *pdacf);
 void snd_pdacf_powerdown(pdacf_t *chip);
diff -uNr a/sound/pcmcia/vx/vx_entry.c b/sound/pcmcia/vx/vx_entry.c
--- a/sound/pcmcia/vx/vx_entry.c	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/pcmcia/vx/vx_entry.c	2005-01-14 22:28:12.418470536 +0100
@@ -68,7 +68,10 @@
 	if (hw)
 		hw->card_list[vxp->index] = NULL;
 	chip->card = NULL;
+	if (chip->dev)
+		kfree(chip->dev);
 
+	snd_vx_free_firmware(chip);
 	kfree(chip);
 	return 0;
 }
@@ -120,6 +123,19 @@
 	if (! chip)
 		return NULL;
 
+#ifdef SND_VX_FW_LOADER
+	/* fake a device here since pcmcia doesn't give a valid device... */
+	chip->dev = kcalloc(1, sizeof(*chip->dev), GFP_KERNEL);
+	if (! chip->dev) {
+		snd_printk(KERN_ERR "vxp: can't malloc chip->dev\n");
+		kfree(chip);
+		snd_card_free(card);
+		return NULL;
+	}
+	device_initialize(chip->dev);
+	sprintf(chip->dev->bus_id, "vxpocket%d", i);
+#endif
+
 	if (snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops) < 0) {
 		kfree(chip);
 		snd_card_free(card);
@@ -156,11 +172,8 @@
 	link->conf.ConfigIndex = 1;
 	link->conf.Present = PRESENT_OPTION;
 
-	/* Chain drivers */
-	link->next = hw->dev_list;
-	hw->dev_list = link;
-
 	/* Register with Card Services */
+	memset(&client_reg, 0, sizeof(client_reg));
 	client_reg.dev_info = hw->dev_info;
 	client_reg.Attributes = INFO_IO_CLIENT | INFO_CARD_SHARE;
 	client_reg.EventMask = 
@@ -177,10 +190,16 @@
 	ret = pcmcia_register_client(&link->handle, &client_reg);
 	if (ret != CS_SUCCESS) {
 		cs_error(link->handle, RegisterClient, ret);
-		snd_vxpocket_detach(hw, link);
+		snd_card_free(card);
 		return NULL;
 	}
 
+	/* Chain drivers */
+	link->next = hw->dev_list;
+	hw->dev_list = link;
+
+	/* snd_card_set_pm_callback(card, snd_vxpocket_suspend, snd_vxpocket_resume, chip); */
+
 	return link;
 }
 
@@ -208,12 +227,9 @@
 	sprintf(card->longname, "%s at 0x%x, irq %i",
 		card->shortname, port, irq);
 
-	if ((err = snd_vx_hwdep_new(chip)) < 0)
-		return err;
-
 	chip->irq = irq;
 
-	if ((err = snd_card_register(chip->card)) < 0)
+	if ((err = snd_vx_setup_firmware(chip)) < 0)
 		return err;
 
 	return 0;
@@ -226,7 +242,12 @@
  */
 void snd_vxpocket_detach(struct snd_vxp_entry *hw, dev_link_t *link)
 {
-	vx_core_t *chip = link->priv;
+	vx_core_t *chip;
+
+	if (! link)
+		return;
+
+	chip = link->priv;
 
 	snd_printdd(KERN_DEBUG "vxpocket_detach called\n");
 	/* Remove the interface data from the linked list */
@@ -234,10 +255,10 @@
 		dev_link_t **linkp;
 		/* Locate device structure */
 		for (linkp = &hw->dev_list; *linkp; linkp = &(*linkp)->next)
-			if (*linkp == link)
+			if (*linkp == link) {
+				*linkp = link->next;
 				break;
-		if (*linkp)
-			*linkp = link->next;
+			}
 	}
 	chip->chip_status |= VX_STAT_IS_STALE; /* to be sure */
 	snd_card_disconnect(chip->card);
@@ -266,13 +287,16 @@
 	vx_core_t *chip = link->priv;
 	struct snd_vxpocket *vxp = (struct snd_vxpocket *)chip;
 	tuple_t tuple;
-	cisparse_t parse;
-	config_info_t conf;
+	cisparse_t *parse = NULL;
 	u_short buf[32];
 	int last_fn, last_ret;
 
 	snd_printdd(KERN_DEBUG "vxpocket_config called\n");
-	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
+	parse = kmalloc(sizeof(*parse), GFP_KERNEL);
+	if (! parse) {
+		snd_printk(KERN_ERR "vx: cannot allocate\n");
+		return;
+	}
 	tuple.Attributes = 0;
 	tuple.TupleData = (cisdata_t *)buf;
 	tuple.TupleDataMax = sizeof(buf);
@@ -280,12 +304,9 @@
 	tuple.DesiredTuple = CISTPL_CONFIG;
 	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
 	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
-	CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
-	link->conf.ConfigBase = parse.config.base;
-	link->conf.ConfigIndex = 1;
-
-	CS_CHECK(GetConfigurationInfo, pcmcia_get_configuration_info(handle, &conf));
-	link->conf.Vcc = conf.Vcc;
+	CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, parse));
+	link->conf.ConfigBase = parse->config.base;
+	link->conf.Present = parse->config.rmask[0];
 
 	/* Configure card */
 	link->state |= DEV_CONFIG;
@@ -299,6 +320,7 @@
 
 	link->dev = &vxp->node;
 	link->state &= ~DEV_CONFIG_PENDING;
+	kfree(parse);
 	return;
 
 cs_failed:
@@ -307,6 +329,8 @@
 	pcmcia_release_configuration(link->handle);
 	pcmcia_release_io(link->handle, &link->io);
 	pcmcia_release_irq(link->handle, &link->irq);
+	link->state &= ~DEV_CONFIG;
+	kfree(parse);
 }
 
 
@@ -328,16 +352,16 @@
 		break;
 	case CS_EVENT_CARD_INSERTION:
 		snd_printdd(KERN_DEBUG "CARD_INSERTION..\n");
-		link->state |= DEV_PRESENT;
+		link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
 		vxpocket_config(link);
 		break;
 #ifdef CONFIG_PM
 	case CS_EVENT_PM_SUSPEND:
 		snd_printdd(KERN_DEBUG "SUSPEND\n");
 		link->state |= DEV_SUSPEND;
-		if (chip) {
+		if (chip && chip->card->pm_suspend) {
 			snd_printdd(KERN_DEBUG "snd_vx_suspend calling\n");
-			snd_vx_suspend(chip);
+			chip->card->pm_suspend(chip->card, 0);
 		}
 		/* Fall through... */
 	case CS_EVENT_RESET_PHYSICAL:
@@ -355,9 +379,9 @@
 			//struct snd_vxpocket *vxp = (struct snd_vxpocket *)chip;
 			snd_printdd(KERN_DEBUG "requestconfig...\n");
 			pcmcia_request_configuration(link->handle, &link->conf);
-			if (chip) {
+			if (chip && chip->card->pm_resume) {
 				snd_printdd(KERN_DEBUG "calling snd_vx_resume\n");
-				snd_vx_resume(chip);
+				chip->card->pm_resume(chip->card, 0);
 			}
 		}
 		snd_printdd(KERN_DEBUG "resume done!\n");
diff -uNr a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
--- a/sound/pcmcia/vx/vxp_ops.c	2004-12-24 22:34:26.000000000 +0100
+++ b/sound/pcmcia/vx/vxp_ops.c	2005-01-14 22:28:12.422469928 +0100
@@ -22,6 +22,7 @@
 
 #include <sound/driver.h>
 #include <linux/delay.h>
+#include <linux/firmware.h>
 #include <sound/core.h>
 #include <asm/io.h>
 #include "vxpocket.h"
@@ -144,13 +145,13 @@
  * vx_load_xilinx_binary - load the xilinx binary image
  * the binary image is the binary array converted from the bitstream file.
  */
-static int vxp_load_xilinx_binary(vx_core_t *_chip, const snd_hwdep_dsp_image_t *xilinx)
+static int vxp_load_xilinx_binary(vx_core_t *_chip, const struct firmware *fw)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 	unsigned int i;
 	int c;
 	int regCSUER, regRUER;
-	unsigned char __user *image;
+	unsigned char *image;
 	unsigned char data;
 
 	/* Switch to programmation mode */
@@ -171,9 +172,9 @@
 
 	/* set HF1 for loading xilinx binary */
 	vx_outb(chip, ICR, ICR_HF1);
-	image = xilinx->image;
-	for (i = 0; i < xilinx->length; i++, image++) {
-		__get_user(data, image);
+	image = fw->data;
+	for (i = 0; i < fw->size; i++, image++) {
+		data = *image;
 		if (vx_wait_isr_bit(_chip, ISR_TX_EMPTY) < 0)
 			goto _error;
 		vx_outb(chip, TXL, data);
@@ -200,7 +201,7 @@
 	c |= (int)vx_inb(chip, RXM) << 8;
 	c |= vx_inb(chip, RXL);
 
-	snd_printdd(KERN_DEBUG "xilinx: dsp size received 0x%x, orig 0x%x\n", c, xilinx->length);
+	snd_printdd(KERN_DEBUG "xilinx: dsp size received 0x%x, orig 0x%x\n", c, fw->size);
 
 	vx_outb(chip, ICR, ICR_HF0);
 
@@ -242,30 +243,27 @@
 /*
  * vxp_load_dsp - load_dsp callback
  */
-static int vxp_load_dsp(vx_core_t *vx, const snd_hwdep_dsp_image_t *dsp)
+static int vxp_load_dsp(vx_core_t *vx, int index, const struct firmware *fw)
 {
 	int err;
 
-	if (*dsp->name)
-		snd_printdd("loading dsp [%d] %s, size = %d\n", dsp->index, dsp->name, dsp->length);
-
-	switch (dsp->index) {
+	switch (index) {
 	case 0:
 		/* xilinx boot */
 		if ((err = vx_check_magic(vx)) < 0)
 			return err;
-		if ((err = snd_vx_load_boot_image(vx, dsp)) < 0)
+		if ((err = snd_vx_load_boot_image(vx, fw)) < 0)
 			return err;
 		return 0;
 	case 1:
 		/* xilinx image */
-		return vxp_load_xilinx_binary(vx, dsp);
+		return vxp_load_xilinx_binary(vx, fw);
 	case 2:
 		/* DSP boot */
-		return snd_vx_dsp_boot(vx, dsp);
+		return snd_vx_dsp_boot(vx, fw);
 	case 3:
 		/* DSP image */
-		return snd_vx_dsp_load(vx, dsp);
+		return snd_vx_dsp_load(vx, fw);
 	default:
 		snd_BUG();
 		return -EINVAL;
diff -uNr a/sound/ppc/pmac.c b/sound/ppc/pmac.c
--- a/sound/ppc/pmac.c	2004-12-24 22:35:49.000000000 +0100
+++ b/sound/ppc/pmac.c	2005-01-14 22:28:12.426469320 +0100
@@ -71,7 +71,7 @@
 
 static void snd_pmac_dbdma_free(pmac_dbdma_t *rec)
 {
-	if (rec && rec->space)
+	if (rec)
 		kfree(rec->space);
 }
 
@@ -318,7 +318,8 @@
 	stat = ld_le16(&cp->xfer_status);
 	if (stat & (ACTIVE|DEAD)) {
 		count = in_le16(&cp->res_count);
-		count = rec->period_size - count;
+		if (count)
+			count = rec->period_size - count;
 	}
 #endif
 	count += rec->cur_period * rec->period_size;
@@ -425,10 +426,10 @@
 	.rate_max =		44100,
 	.channels_min =		2,
 	.channels_max =		2,
-	.buffer_bytes_max =	32768,
+	.buffer_bytes_max =	131072,
 	.period_bytes_min =	256,
 	.period_bytes_max =	16384,
-	.periods_min =		1,
+	.periods_min =		3,
 	.periods_max =		PMAC_MAX_FRAGS,
 };
 
@@ -444,10 +445,10 @@
 	.rate_max =		44100,
 	.channels_min =		2,
 	.channels_max =		2,
-	.buffer_bytes_max =	32768,
+	.buffer_bytes_max =	131072,
 	.period_bytes_min =	256,
 	.period_bytes_max =	16384,
-	.periods_min =		1,
+	.periods_min =		3,
 	.periods_max =		PMAC_MAX_FRAGS,
 };
 
@@ -550,6 +551,8 @@
 	if (chip->can_duplex)
 		snd_pcm_set_sync(subs);
 
+	/* constraints to fix choppy sound */
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
 	return 0;
 }
 
@@ -1248,7 +1251,6 @@
 	if (chip->rx_irq >= 0)
 		disable_irq(chip->rx_irq);
 	snd_pmac_sound_feature(chip, 0);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
 
@@ -1275,7 +1277,6 @@
 	if (chip->rx_irq >= 0)
 		enable_irq(chip->rx_irq);
 
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 
diff -uNr a/sound/sparc/cs4231.c b/sound/sparc/cs4231.c
--- a/sound/sparc/cs4231.c	2004-12-24 22:33:50.000000000 +0100
+++ b/sound/sparc/cs4231.c	2005-01-14 22:28:12.433468256 +0100
@@ -390,7 +390,7 @@
  *  Basic I/O functions
  */
 
-void snd_cs4231_outm(cs4231_t *chip, unsigned char reg,
+static void snd_cs4231_outm(cs4231_t *chip, unsigned char reg,
 		     unsigned char mask, unsigned char value)
 {
 	int timeout;
@@ -473,9 +473,9 @@
 	return ret;
 }
 
-#ifdef CONFIG_SND_DEBUG
+#if 0
 
-void snd_cs4231_debug(cs4231_t *chip)
+static void snd_cs4231_debug(cs4231_t *chip)
 {
 	printk("CS4231 REGS:      INDEX = 0x%02x  ",
 	       __cs4231_readb(chip, CS4231P(chip, REGSEL)));
@@ -560,7 +560,6 @@
 {
 	unsigned long flags;
 	int timeout;
-	signed long time;
 
 	spin_lock_irqsave(&chip->lock, flags);
 	snd_cs4231_busy_wait(chip);
@@ -594,29 +593,29 @@
 #if 0
 	printk("(2) timeout = %i, jiffies = %li\n", timeout, jiffies);
 #endif
-	time = HZ / 4;
+	/* in 10ms increments, check condition, up to 250ms */
+	timeout = 25;
 	while (snd_cs4231_in(chip, CS4231_TEST_INIT) & CS4231_CALIB_IN_PROGRESS) {
 		spin_unlock_irqrestore(&chip->lock, flags);
-		if (time <= 0) {
+		if (--timeout < 0) {
 			snd_printk("mce_down - auto calibration time out (2)\n");
 			return;
 		}
-		set_current_state(TASK_INTERRUPTIBLE);
-		time = schedule_timeout(time);
+		msleep(10);
 		spin_lock_irqsave(&chip->lock, flags);
 	}
 #if 0
 	printk("(3) jiffies = %li\n", jiffies);
 #endif
-	time = HZ / 10;
+	/* in 10ms increments, check condition, up to 100ms */
+	timeout = 10;
 	while (__cs4231_readb(chip, CS4231P(chip, REGSEL)) & CS4231_INIT) {
 		spin_unlock_irqrestore(&chip->lock, flags);
-		if (time <= 0) {
+		if (--timeout < 0) {
 			snd_printk("mce_down - auto calibration time out (3)\n");
 			return;
 		}
-		set_current_state(TASK_INTERRUPTIBLE);		
-		time = schedule_timeout(time);
+		msleep(10);
 		spin_lock_irqsave(&chip->lock, flags);
 	}
 	spin_unlock_irqrestore(&chip->lock, flags);
diff -uNr a/sound/synth/emux/emux.c b/sound/synth/emux/emux.c
--- a/sound/synth/emux/emux.c	2004-12-24 22:34:45.000000000 +0100
+++ b/sound/synth/emux/emux.c	2005-01-14 22:28:12.435467952 +0100
@@ -137,12 +137,8 @@
 	if (emu->sflist)
 		snd_sf_free(emu->sflist);
 
-	if (emu->voices)
-		kfree(emu->voices);
-
-	if (emu->name)
-		kfree(emu->name);
-
+	kfree(emu->voices);
+	kfree(emu->name);
 	kfree(emu);
 	return 0;
 }
diff -uNr a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
--- a/sound/synth/emux/emux_seq.c	2004-12-24 22:35:50.000000000 +0100
+++ b/sound/synth/emux/emux_seq.c	2005-01-14 22:28:12.445466432 +0100
@@ -197,8 +197,7 @@
 #ifdef SNDRV_EMUX_USE_RAW_EFFECT
 		snd_emux_delete_effect(p);
 #endif
-		if (p->chset.channels)
-			kfree(p->chset.channels);
+		kfree(p->chset.channels);
 		kfree(p);
 	}
 }
diff -uNr a/sound/synth/emux/emux_synth.c b/sound/synth/emux/emux_synth.c
--- a/sound/synth/emux/emux_synth.c	2004-12-24 22:34:33.000000000 +0100
+++ b/sound/synth/emux/emux_synth.c	2005-01-14 22:28:12.448465976 +0100
@@ -363,16 +363,6 @@
 
 
 /*
- * for Emu10k1 - release at least 1 voice currently using
- */
-int
-snd_emux_release_voice(snd_emux_t *emu)
-{
-	return 0;
-}
-
-
-/*
  * terminate note - if free flag is true, free the terminated voice
  */
 static void
diff -uNr a/sound/synth/emux/soundfont.c b/sound/synth/emux/soundfont.c
--- a/sound/synth/emux/soundfont.c	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/synth/emux/soundfont.c	2005-01-14 22:28:12.453465216 +0100
@@ -1460,11 +1460,3 @@
 	return 0;
 }
 
-/*
- * Return the used memory size (in words)
- */
-int
-snd_soundfont_mem_used(snd_sf_list_t *sflist)
-{
-	return sflist->mem_used;
-}
diff -uNr a/sound/usb/Kconfig b/sound/usb/Kconfig
--- a/sound/usb/Kconfig	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/usb/Kconfig	2005-01-14 22:28:12.456464760 +0100
@@ -17,7 +17,7 @@
 
 config SND_USB_USX2Y
 	tristate "Tascam US-122, US-224 and US-428 USB driver"
-	depends on SND && USB
+	depends on SND && USB && (X86 || PPC || ALPHA)
 	select SND_HWDEP
 	select SND_RAWMIDI
 	select SND_PCM
diff -uNr a/sound/usb/usbaudio.c b/sound/usb/usbaudio.c
--- a/sound/usb/usbaudio.c	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/usb/usbaudio.c	2005-01-14 22:28:12.464463544 +0100
@@ -725,7 +725,7 @@
 	subs->running = 0;
 
 	if (!force && subs->stream->chip->shutdown) /* to be sure... */
-		return 0;
+		return -EBADFD;
 
 	async = !can_sleep && async_unlink;
 
@@ -770,6 +770,9 @@
 	unsigned int i;
 	int err;
 
+	if (subs->stream->chip->shutdown)
+		return -EBADFD;
+
 	for (i = 0; i < subs->nurbs; i++) {
 		snd_assert(subs->dataurb[i].urb, return -EINVAL);
 		if (subs->ops.prepare(subs, runtime, subs->dataurb[i].urb) < 0) {
@@ -2063,8 +2066,7 @@
 		return; /* not initialized */
 	list_for_each_safe(p, n, &subs->fmt_list) {
 		struct audioformat *fp = list_entry(p, struct audioformat, list);
-		if (fp->rate_table)
-			kfree(fp->rate_table);
+		kfree(fp->rate_table);
 		kfree(fp);
 	}
 }
@@ -2550,8 +2552,7 @@
 
 		/* ok, let's parse further... */
 		if (parse_audio_format(dev, fp, format, fmt, stream) < 0) {
-			if (fp->rate_table)
-				kfree(fp->rate_table);
+			kfree(fp->rate_table);
 			kfree(fp);
 			continue;
 		}
@@ -2559,8 +2560,7 @@
 		snd_printdd(KERN_INFO "%d:%u:%d: add audio endpoint 0x%x\n", dev->devnum, iface_no, i, fp->endpoint);
 		err = add_audio_endpoint(chip, stream, fp);
 		if (err < 0) {
-			if (fp->rate_table)
-				kfree(fp->rate_table);
+			kfree(fp->rate_table);
 			kfree(fp);
 			return err;
 		}
@@ -2693,15 +2693,13 @@
 	err = add_audio_endpoint(chip, stream, fp);
 	if (err < 0) {
 		kfree(fp);
-		if (rate_table)
-			kfree(rate_table);
+		kfree(rate_table);
 		return err;
 	}
 	if (fp->iface != get_iface_desc(&iface->altsetting[0])->bInterfaceNumber ||
 	    fp->altset_idx >= iface->num_altsetting) {
 		kfree(fp);
-		if (rate_table)
-			kfree(rate_table);
+		kfree(rate_table);
 		return -EINVAL;
 	}
 	alts = &iface->altsetting[fp->altset_idx];
diff -uNr a/sound/usb/usbmidi.c b/sound/usb/usbmidi.c
--- a/sound/usb/usbmidi.c	2004-12-24 22:35:27.000000000 +0100
+++ b/sound/usb/usbmidi.c	2005-01-14 22:28:12.468462936 +0100
@@ -504,8 +504,7 @@
 static void snd_usbmidi_in_endpoint_delete(snd_usb_midi_in_endpoint_t* ep)
 {
 	if (ep->urb) {
-		if (ep->urb->transfer_buffer)
-			kfree(ep->urb->transfer_buffer);
+		kfree(ep->urb->transfer_buffer);
 		usb_free_urb(ep->urb);
 	}
 	kfree(ep);
@@ -632,8 +631,7 @@
 	if (ep->tasklet.func)
 		tasklet_kill(&ep->tasklet);
 	if (ep->urb) {
-		if (ep->urb->transfer_buffer)
-			kfree(ep->urb->transfer_buffer);
+		kfree(ep->urb->transfer_buffer);
 		usb_free_urb(ep->urb);
 	}
 	kfree(ep);
diff -uNr a/sound/usb/usbmixer.c b/sound/usb/usbmixer.c
--- a/sound/usb/usbmixer.c	2004-12-24 22:34:30.000000000 +0100
+++ b/sound/usb/usbmixer.c	2005-01-14 22:28:12.473462176 +0100
@@ -374,7 +374,7 @@
 static int check_matrix_bitmap(unsigned char *bmap, int ich, int och, int num_outs)
 {
 	int idx = ich * num_outs + och;
-	return bmap[-(idx >> 3)] & (0x80 >> (idx & 7));
+	return bmap[idx >> 3] & (0x80 >> (idx & 7));
 }
 
 
@@ -573,7 +573,7 @@
 static void usb_mixer_elem_free(snd_kcontrol_t *kctl)
 {
 	if (kctl->private_data) {
-		kfree((void *)kctl->private_data);
+		kfree(kctl->private_data);
 		kctl->private_data = NULL;
 	}
 }
@@ -931,14 +931,14 @@
  */
 
 static void build_mixer_unit_ctl(mixer_build_t *state, unsigned char *desc,
-				 int in_ch, int unitid)
+				 int in_pin, int in_ch, int unitid,
+				 usb_audio_term_t *iterm)
 {
 	usb_mixer_elem_info_t *cval;
-	unsigned int num_ins = desc[4];
-	unsigned int num_outs = desc[5 + num_ins];
+	unsigned int input_pins = desc[4];
+	unsigned int num_outs = desc[5 + input_pins];
 	unsigned int i, len;
 	snd_kcontrol_t *kctl;
-	usb_audio_term_t iterm;
 
 	if (check_ignored_ctl(state, unitid, 0))
 		return;
@@ -947,16 +947,13 @@
 	if (! cval)
 		return;
 
-	if (check_input_term(state, desc[5 + in_ch], &iterm) < 0)
-		return;
-
 	cval->chip = state->chip;
 	cval->ctrlif = state->ctrlif;
 	cval->id = unitid;
 	cval->control = in_ch + 1; /* based on 1 */
 	cval->val_type = USB_MIXER_S16;
 	for (i = 0; i < num_outs; i++) {
-		if (check_matrix_bitmap(desc + 9 + num_ins, in_ch, i, num_outs)) {
+		if (check_matrix_bitmap(desc + 9 + input_pins, in_ch, i, num_outs)) {
 			cval->cmask |= (1 << i);
 			cval->channels++;
 		}
@@ -975,9 +972,9 @@
 
 	len = check_mapped_name(state, unitid, 0, kctl->id.name, sizeof(kctl->id.name));
 	if (! len)
-		len = get_term_name(state, &iterm, kctl->id.name, sizeof(kctl->id.name), 0);
+		len = get_term_name(state, iterm, kctl->id.name, sizeof(kctl->id.name), 0);
 	if (! len)
-		len = sprintf(kctl->id.name, "Mixer Source %d", in_ch);
+		len = sprintf(kctl->id.name, "Mixer Source %d", in_ch + 1);
 	strlcat(kctl->id.name + len, " Volume", sizeof(kctl->id.name));
 
 	snd_printdd(KERN_INFO "[%d] MU [%s] ch = %d, val = %d/%d\n",
@@ -991,17 +988,44 @@
  */
 static int parse_audio_mixer_unit(mixer_build_t *state, int unitid, unsigned char *desc)
 {
-	int num_ins, num_outs;
-	int i, err;
-	if (desc[0] < 12 || ! (num_ins = desc[4]) || ! (num_outs = desc[5 + num_ins]))
+	usb_audio_term_t iterm;
+	int input_pins, num_ins, num_outs;
+	int pin, ich, err;
+
+	if (desc[0] < 11 || ! (input_pins = desc[4]) || ! (num_outs = desc[5 + input_pins])) {
+		snd_printk(KERN_ERR "invalid MIXER UNIT descriptor %d\n", unitid);
 		return -EINVAL;
+	}
+	/* no bmControls field (e.g. Maya44) -> ignore */
+	if (desc[0] <= 10 + input_pins) {
+		snd_printdd(KERN_INFO "MU %d has no bmControls field\n", unitid);
+		return 0;
+	}
 
-	for (i = 0; i < num_ins; i++) {
-		err = parse_audio_unit(state, desc[5 + i]);
+	num_ins = 0;
+	ich = 0;
+	for (pin = 0; pin < input_pins; pin++) {
+		err = parse_audio_unit(state, desc[5 + pin]);
+		if (err < 0)
+			return err;
+		err = check_input_term(state, desc[5 + pin], &iterm);
 		if (err < 0)
 			return err;
-		if (check_matrix_bitmap(desc + 9 + num_ins, i, 0, num_outs))
-			build_mixer_unit_ctl(state, desc, i, unitid);
+		num_ins += iterm.channels;
+		for (; ich < num_ins; ++ich) {
+			int och, ich_has_controls = 0;
+
+			for (och = 0; och < num_outs; ++och) {
+				if (check_matrix_bitmap(desc + 9 + input_pins,
+							ich, och, num_outs)) {
+					ich_has_controls = 1;
+					break;
+				}
+			}
+			if (ich_has_controls)
+				build_mixer_unit_ctl(state, desc, pin, ich,
+						     unitid, &iterm);
+		}
 	}
 	return 0;
 }
diff -uNr a/sound/usb/usx2y/Makefile b/sound/usb/usx2y/Makefile
--- a/sound/usb/usx2y/Makefile	2004-12-24 22:34:57.000000000 +0100
+++ b/sound/usb/usx2y/Makefile	2005-01-14 22:28:12.476461720 +0100
@@ -1,3 +1,3 @@
-snd-usb-usx2y-objs := usbusx2y.o usbusx2yaudio.o usX2Yhwdep.o
+snd-usb-usx2y-objs := usbusx2y.o usX2Yhwdep.o usx2yhwdeppcm.o
 
 obj-$(CONFIG_SND_USB_USX2Y) += snd-usb-usx2y.o
diff -uNr a/sound/usb/usx2y/usbusx2yaudio.c b/sound/usb/usx2y/usbusx2yaudio.c
--- a/sound/usb/usx2y/usbusx2yaudio.c	2004-12-24 22:34:45.000000000 +0100
+++ b/sound/usb/usx2y/usbusx2yaudio.c	2005-01-14 22:28:12.483460656 +0100
@@ -1,10 +1,9 @@
 /*
- *   US-428 AUDIO
-
- *   Copyright (c) 2002-2003 by Karsten Wiese
- 
+ *   US-X2Y AUDIO
+ *   Copyright (c) 2002-2004 by Karsten Wiese
+ *
  *   based on
-
+ *
  *   (Tentative) USB Audio Driver for ALSA
  *
  *   Main and PCM part
@@ -42,34 +41,30 @@
 #include "usx2y.h"
 #include "usbusx2y.h"
 
-
-struct snd_usX2Y_substream {
-	usX2Ydev_t	*usX2Y;
-	snd_pcm_substream_t *pcm_substream;
-
-	unsigned char		endpoint;		
-	unsigned int		datapipe;  		/* the data i/o pipe */
-	unsigned int		maxpacksize;		/* max packet size in bytes */
-
-	char			prepared,
-				running,
-				stalled;
-
-	int			hwptr;			/* free frame position in the buffer (only for playback) */
-	int			hwptr_done;		/* processed frame position in the buffer */
-	int			transfer_done;		/* processed frames since last period update */
-
-	struct urb		*urb[NRURBS];	/* data urb table */
-	int			next_urb_complete;
-	struct urb		*completed_urb;
-	char			*tmpbuf;			/* temporary buffer for playback */
-	volatile int		submitted_urbs;
-	wait_queue_head_t	wait_queue;
-};
-
-
-
-
+#define USX2Y_NRPACKS 4			/* Default value used for nr of packs per urb.
+					  1 to 4 have been tested ok on uhci.
+					  To use 3 on ohci, you'd need a patch:
+					  look for "0000425-linux-2.6.9-rc4-mm1_ohci-hcd.patch.gz" on
+					  "https://bugtrack.alsa-project.org/alsa-bug/bug_view_page.php?bug_id=0000425"
+					  .
+					  1, 2 and 4 work out of the box on ohci, if I recall correctly.
+					  Bigger is safer operation,
+					  smaller gives lower latencies.
+					*/
+#define USX2Y_NRPACKS_VARIABLE y	/* If your system works ok with this module's parameter
+					   nrpacks set to 1, you might as well comment 
+					   this #define out, and thereby produce smaller, faster code.
+					   You'd also set USX2Y_NRPACKS to 1 then.
+					*/
+
+#ifdef USX2Y_NRPACKS_VARIABLE
+ static int nrpacks = USX2Y_NRPACKS; /* number of packets per urb */
+ #define  nr_of_packs() nrpacks
+ module_param(nrpacks, int, 0444);
+ MODULE_PARM_DESC(nrpacks, "Number of packets per URB.");
+#else
+ #define nr_of_packs() USX2Y_NRPACKS
+#endif
 
 
 static int usX2Y_urb_capt_retire(snd_usX2Y_substream_t *subs)
@@ -80,15 +75,15 @@
 	int 		i, len, lens = 0, hwptr_done = subs->hwptr_done;
 	usX2Ydev_t	*usX2Y = subs->usX2Y;
 
-	for (i = 0; i < NRPACKS; i++) {
+	for (i = 0; i < nr_of_packs(); i++) {
 		cp = (unsigned char*)urb->transfer_buffer + urb->iso_frame_desc[i].offset;
 		if (urb->iso_frame_desc[i].status) { /* active? hmm, skip this */
-			snd_printdd("activ frame status %i\n", urb->iso_frame_desc[i].status);
+			snd_printk("activ frame status %i. Most propably some hardware problem.\n", urb->iso_frame_desc[i].status);
 			return urb->iso_frame_desc[i].status;
 		}
 		len = urb->iso_frame_desc[i].actual_length / usX2Y->stride;
 		if (! len) {
-			snd_printk("0 == len ERROR!\n");
+			snd_printd("0 == len ERROR!\n");
 			continue;
 		}
 
@@ -134,7 +129,7 @@
 	snd_pcm_runtime_t *runtime = subs->pcm_substream->runtime;
 
 	count = 0;
-	for (pack = 0; pack < NRPACKS; pack++) {
+	for (pack = 0; pack <  nr_of_packs(); pack++) {
 		/* calculate the size of a packet */
 		counts = cap_urb->iso_frame_desc[pack].actual_length / usX2Y->stride;
 		count += counts;
@@ -142,28 +137,32 @@
 			snd_printk("should not be here with counts=%i\n", counts);
 			return -EPIPE;
 		}
-
 		/* set up descriptor */
-		urb->iso_frame_desc[pack].offset = pack ? urb->iso_frame_desc[pack - 1].offset + urb->iso_frame_desc[pack - 1].length : 0;
-		urb->iso_frame_desc[pack].length = counts * usX2Y->stride;
-	}
-	if (subs->hwptr + count > runtime->buffer_size) {
-		/* err, the transferred area goes over buffer boundary.
-		 * copy the data to the temp buffer.
-		 */
-		int len;
-		len = runtime->buffer_size - subs->hwptr;
-		urb->transfer_buffer = subs->tmpbuf;
-		memcpy(subs->tmpbuf, runtime->dma_area + subs->hwptr * usX2Y->stride, len * usX2Y->stride);
-		memcpy(subs->tmpbuf + len * usX2Y->stride, runtime->dma_area, (count - len) * usX2Y->stride);
-		subs->hwptr += count;
-		subs->hwptr -= runtime->buffer_size;
-	} else {
-		/* set the buffer pointer */
-		urb->transfer_buffer = runtime->dma_area + subs->hwptr * usX2Y->stride;
-		if ((subs->hwptr += count) >= runtime->buffer_size)
+		urb->iso_frame_desc[pack].offset = pack ?
+			urb->iso_frame_desc[pack - 1].offset + urb->iso_frame_desc[pack - 1].length :
+			0;
+		urb->iso_frame_desc[pack].length = cap_urb->iso_frame_desc[pack].actual_length;
+	}
+	if (atomic_read(&subs->state) >= state_PRERUNNING)
+		if (subs->hwptr + count > runtime->buffer_size) {
+			/* err, the transferred area goes over buffer boundary.
+			 * copy the data to the temp buffer.
+			 */
+			int len;
+			len = runtime->buffer_size - subs->hwptr;
+			urb->transfer_buffer = subs->tmpbuf;
+			memcpy(subs->tmpbuf, runtime->dma_area + subs->hwptr * usX2Y->stride, len * usX2Y->stride);
+			memcpy(subs->tmpbuf + len * usX2Y->stride, runtime->dma_area, (count - len) * usX2Y->stride);
+			subs->hwptr += count;
+			subs->hwptr -= runtime->buffer_size;
+		} else {
+			/* set the buffer pointer */
+			urb->transfer_buffer = runtime->dma_area + subs->hwptr * usX2Y->stride;
+			if ((subs->hwptr += count) >= runtime->buffer_size)
 			subs->hwptr -= runtime->buffer_size;			
-	}
+		}
+	else
+		urb->transfer_buffer = subs->tmpbuf;
 	urb->transfer_buffer_length = count * usX2Y->stride;
 	return 0;
 }
@@ -173,14 +172,10 @@
  *
  * update the current position and call callback if a period is processed.
  */
-inline static int usX2Y_urb_play_retire(snd_usX2Y_substream_t *subs, struct urb *urb)
+static void usX2Y_urb_play_retire(snd_usX2Y_substream_t *subs, struct urb *urb)
 {
 	snd_pcm_runtime_t *runtime = subs->pcm_substream->runtime;
-	int		len = (urb->iso_frame_desc[0].actual_length
-#if NRPACKS > 1
-			       + urb->iso_frame_desc[1].actual_length
-#endif
-		               ) / subs->usX2Y->stride;
+	int		len = urb->actual_length / subs->usX2Y->stride;
 
 	subs->transfer_done += len;
 	subs->hwptr_done +=  len;
@@ -190,224 +185,206 @@
 		subs->transfer_done -= runtime->period_size;
 		snd_pcm_period_elapsed(subs->pcm_substream);
 	}
-	return 0;
 }
 
-inline static int usX2Y_urb_submit(snd_usX2Y_substream_t *subs, struct urb *urb, int frame)
+static int usX2Y_urb_submit(snd_usX2Y_substream_t *subs, struct urb *urb, int frame)
 {
 	int err;
 	if (!urb)
 		return -ENODEV;
-	urb->start_frame = (frame + NRURBS*NRPACKS) & (1024 - 1);
+	urb->start_frame = (frame + NRURBS * nr_of_packs());  // let hcd do rollover sanity checks
 	urb->hcpriv = NULL;
 	urb->dev = subs->usX2Y->chip.dev; /* we need to set this at each time */
 	if ((err = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
-		snd_printk("%i\n", err);
+		snd_printk("usb_submit_urb() returned %i\n", err);
 		return err;
-	} else {
-		subs->submitted_urbs++;
-		if (subs->next_urb_complete < 0) 
-			subs->next_urb_complete = 0;
 	}
 	return 0;
 }
 
-
-static inline int frame_distance(int from, int to)
+static inline int usX2Y_usbframe_complete(snd_usX2Y_substream_t *capsubs, snd_usX2Y_substream_t *playbacksubs, int frame)
 {
-	int distance = to - from;
-	if (distance < -512)
-		distance += 1024;
-	else
-		if (distance > 511)
-			distance -= 1024;
-	return distance;
-}
+	int err, state;
+	{
+		struct urb *urb = playbacksubs->completed_urb;
 
+		state = atomic_read(&playbacksubs->state);
+		if (NULL != urb) {
+			if (state == state_RUNNING)
+				usX2Y_urb_play_retire(playbacksubs, urb);
+			else
+				if (state >= state_PRERUNNING) {
+					atomic_inc(&playbacksubs->state);
+				}
+		} else {
+			switch (state) {
+			case state_STARTING1:
+				urb = playbacksubs->urb[0];
+				atomic_inc(&playbacksubs->state);
+				break;
+			case state_STARTING2:
+				urb = playbacksubs->urb[1];
+				atomic_inc(&playbacksubs->state);
+				break;
+			}
+		}
+		if (urb) {
+			if ((err = usX2Y_urb_play_prepare(playbacksubs, capsubs->completed_urb, urb)) ||
+			    (err = usX2Y_urb_submit(playbacksubs, urb, frame))) {
+				return err;
+			}
+		}
 
-static void usX2Y_subs_set_next_urb_complete(snd_usX2Y_substream_t *subs)
-{
-	int next_urb_complete = subs->next_urb_complete + 1;
-	int distance;
-	if (next_urb_complete >= NRURBS)
-		next_urb_complete = 0;
-	distance = frame_distance(subs->completed_urb->start_frame,
-				  subs->urb[next_urb_complete]->start_frame);
-	if (1 == distance) {
-		subs->next_urb_complete = next_urb_complete;
-	} else {
-		snd_printdd("distance %i not set_nuc %i %i %i \n", distance, subs->endpoint, next_urb_complete, subs->urb[next_urb_complete]->status);
-		subs->next_urb_complete = -1;
+		playbacksubs->completed_urb = NULL;
 	}
+	state = atomic_read(&capsubs->state);
+	if (state >= state_PREPARED) {
+		if (state == state_RUNNING) {
+			if ((err = usX2Y_urb_capt_retire(capsubs)))
+				return err;
+		} else
+			if (state >= state_PRERUNNING) {
+				atomic_inc(&capsubs->state);
+			}
+		if ((err = usX2Y_urb_submit(capsubs, capsubs->completed_urb, frame)))
+			return err;
+	}
+	capsubs->completed_urb = NULL;
+	return 0;
 }
 
 
-static inline void usX2Y_usbframe_complete(snd_usX2Y_substream_t *capsubs, snd_usX2Y_substream_t *playbacksubs, int frame)
+static void usX2Y_clients_stop(usX2Ydev_t *usX2Y)
 {
-	{
-		struct urb *urb;
-		if ((urb = playbacksubs->completed_urb)) {
-			if (playbacksubs->prepared)
-				usX2Y_urb_play_retire(playbacksubs, urb);
-			usX2Y_subs_set_next_urb_complete(playbacksubs);
+	int s, u;
+	for (s = 0; s < 4; s++) {
+		snd_usX2Y_substream_t *subs = usX2Y->subs[s];
+		if (subs) {
+			snd_printdd("%i %p state=%i\n", s, subs, atomic_read(&subs->state));
+			atomic_set(&subs->state, state_STOPPED);
 		}
-		if (playbacksubs->running) {
-			if (NULL == urb)
-				urb = playbacksubs->urb[playbacksubs->next_urb_complete + 1];
-			if (urb && 0 == usX2Y_urb_play_prepare(playbacksubs,
-							       capsubs->completed_urb,
-							       urb)) {
-				if (usX2Y_urb_submit(playbacksubs, urb, frame) < 0)
-					return;
-			} else
-				snd_pcm_stop(playbacksubs->pcm_substream, SNDRV_PCM_STATE_XRUN);
+	}
+	for (s = 0; s < 4; s++) {
+		snd_usX2Y_substream_t *subs = usX2Y->subs[s];
+		if (subs) {
+			if (atomic_read(&subs->state) >= state_PRERUNNING) {
+				snd_pcm_stop(subs->pcm_substream, SNDRV_PCM_STATE_XRUN);
+			}
+			for (u = 0; u < NRURBS; u++) {
+				struct urb *urb = subs->urb[u];
+				if (NULL != urb)
+					snd_printdd("%i status=%i start_frame=%i\n", u, urb->status, urb->start_frame);
+			}
 		}
-		playbacksubs->completed_urb = NULL;
 	}
-	if (capsubs->running)
-		usX2Y_urb_capt_retire(capsubs);
-	usX2Y_subs_set_next_urb_complete(capsubs);
-	if (capsubs->prepared)
-		usX2Y_urb_submit(capsubs, capsubs->completed_urb, frame);
-	capsubs->completed_urb = NULL;
+	usX2Y->prepare_subs = NULL;
+	wake_up(&usX2Y->prepare_wait_queue);
 }
 
-
-static void usX2Y_clients_stop(snd_usX2Y_substream_t *subs)
+static void usX2Y_error_urb_status(usX2Ydev_t *usX2Y, snd_usX2Y_substream_t *subs, struct urb *urb)
 {
-	usX2Ydev_t *usX2Y = subs->usX2Y;
-	int i;
-	for (i = 0; i < 4; i++) {
-		snd_usX2Y_substream_t *substream = usX2Y->substream[i];
-		if (substream && substream->running)
-			snd_pcm_stop(substream->pcm_substream, SNDRV_PCM_STATE_XRUN);
-	}
+	snd_printk("ep=%i stalled with status=%i\n", subs->endpoint, urb->status);
+	urb->status = 0;
+	usX2Y_clients_stop(usX2Y);
 }
 
+static void usX2Y_error_sequence(usX2Ydev_t *usX2Y, snd_usX2Y_substream_t *subs, struct urb *urb)
+{
+	snd_printk("Sequence Error!(hcd_frame=%i ep=%i%s;wait=%i,frame=%i).\n"
+		   "Most propably some urb of usb-frame %i is still missing.\n"
+		   "Cause could be too long delays in usb-hcd interrupt handling.\n",
+		   usb_get_current_frame_number(usX2Y->chip.dev),
+		   subs->endpoint, usb_pipein(urb->pipe) ? "in" : "out", usX2Y->wait_iso_frame, urb->start_frame, usX2Y->wait_iso_frame);
+	usX2Y_clients_stop(usX2Y);
+}
 
 static void i_usX2Y_urb_complete(struct urb *urb, struct pt_regs *regs)
 {
 	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t*)urb->context;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
 
-	subs->submitted_urbs--;
-	if (urb->status) {
-		snd_printk("ep=%i stalled with status=%i\n", subs->endpoint, urb->status);
-		subs->stalled = 1;
-		usX2Y_clients_stop(subs);
-		urb->status = 0;
+	if (unlikely(atomic_read(&subs->state) < state_PREPARED)) {
+		snd_printdd("hcd_frame=%i ep=%i%s status=%i start_frame=%i\n", usb_get_current_frame_number(usX2Y->chip.dev), subs->endpoint, usb_pipein(urb->pipe) ? "in" : "out", urb->status, urb->start_frame);
+		return;
+	}
+	if (unlikely(urb->status)) {
+		usX2Y_error_urb_status(usX2Y, subs, urb);
 		return;
 	}
-	if (urb == subs->urb[subs->next_urb_complete]) {
+	if (likely((0xFFFF & urb->start_frame) == usX2Y->wait_iso_frame))
 		subs->completed_urb = urb;
-	} else {
-		snd_printk("Sequence Error!(ep=%i;nuc=%i,frame=%i)\n",
-			   subs->endpoint, subs->next_urb_complete, urb->start_frame);
-		subs->stalled = 1;
-		usX2Y_clients_stop(subs);
+	else {
+		usX2Y_error_sequence(usX2Y, subs, urb);
 		return;
 	}
-	if (waitqueue_active(&subs->wait_queue))
-		wake_up(&subs->wait_queue);
 	{
-		snd_usX2Y_substream_t *capsubs = subs->usX2Y->substream[SNDRV_PCM_STREAM_CAPTURE],
-			*playbacksubs = subs->usX2Y->substream[SNDRV_PCM_STREAM_PLAYBACK];
-		if (capsubs->completed_urb &&
-		    (playbacksubs->completed_urb ||
-		     !playbacksubs->prepared ||
-		     (playbacksubs->prepared && (playbacksubs->next_urb_complete < 0 ||	// not started yet
-						 frame_distance(capsubs->completed_urb->start_frame,
-								playbacksubs->urb[playbacksubs->next_urb_complete]->start_frame)
-						 > 0 ||					// other expected later
-						 playbacksubs->stalled))))
-			usX2Y_usbframe_complete(capsubs, playbacksubs, urb->start_frame);
+		snd_usX2Y_substream_t *capsubs = usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE],
+			*playbacksubs = usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];
+		if (capsubs->completed_urb && atomic_read(&capsubs->state) >= state_PREPARED &&
+		    (playbacksubs->completed_urb || atomic_read(&playbacksubs->state) < state_PREPARED)) {
+			if (!usX2Y_usbframe_complete(capsubs, playbacksubs, urb->start_frame)) {
+				if (nr_of_packs() <= urb->start_frame &&
+				    urb->start_frame <= (2 * nr_of_packs() - 1))	// uhci and ohci
+					usX2Y->wait_iso_frame = urb->start_frame - nr_of_packs();
+				else
+					usX2Y->wait_iso_frame +=  nr_of_packs();
+			} else {
+				snd_printdd("\n");
+				usX2Y_clients_stop(usX2Y);
+			}
+		}
 	}
 }
 
-
-static int usX2Y_urbs_capt_start(snd_usX2Y_substream_t *subs)
+static void usX2Y_urbs_set_complete(usX2Ydev_t * usX2Y, void (*complete)(struct urb *, struct pt_regs *))
 {
-	int i, err;
-
-	for (i = 0; i < NRURBS; i++) {
-		unsigned long pack;
-		struct urb *urb = subs->urb[i];
-		urb->dev = subs->usX2Y->chip.dev;
-		urb->transfer_flags = URB_ISO_ASAP;
-		for (pack = 0; pack < NRPACKS; pack++) {
-			urb->iso_frame_desc[pack].offset = subs->maxpacksize * pack;
-			urb->iso_frame_desc[pack].length = subs->maxpacksize;
-		}
-		urb->transfer_buffer_length = subs->maxpacksize * NRPACKS; 
-		if ((err = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
-			snd_printk (KERN_ERR "cannot submit datapipe for urb %d, err = %d\n", i, err);
-			return -EPIPE;
-		} else {
-			subs->submitted_urbs++;
-		}
-		urb->transfer_flags = 0;
+	int s, u;
+	for (s = 0; s < 4; s++) {
+		snd_usX2Y_substream_t *subs = usX2Y->subs[s];
+		if (NULL != subs)
+			for (u = 0; u < NRURBS; u++) {
+				struct urb * urb = subs->urb[u];
+				if (NULL != urb)
+					urb->complete = complete;
+			}
 	}
-	subs->stalled = 0;
-	subs->next_urb_complete = 0;
-	subs->prepared = 1;
-	return 0;
 }
 
-/* 
- *  wait until all urbs are processed.
- */
-static int usX2Y_urbs_wait_clear(snd_usX2Y_substream_t *subs)
+static void usX2Y_subs_startup_finish(usX2Ydev_t * usX2Y)
 {
-	int timeout = HZ;
-
-	do {
-		if (0 == subs->submitted_urbs)
-			break;
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		snd_printdd("snd_usX2Y_urbs_wait_clear waiting\n");
-		schedule_timeout(1);
-	} while (--timeout > 0);
-	if (subs->submitted_urbs)
-		snd_printk(KERN_ERR "timeout: still %d active urbs..\n", subs->submitted_urbs);
-	return 0;
+	usX2Y_urbs_set_complete(usX2Y, i_usX2Y_urb_complete);
+	usX2Y->prepare_subs = NULL;
 }
-/*
- * return the current pcm pointer.  just return the hwptr_done value.
- */
-static snd_pcm_uframes_t snd_usX2Y_pcm_pointer(snd_pcm_substream_t *substream)
-{
-	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)substream->runtime->private_data;
-	return subs->hwptr_done;
-}
-/*
- * start/stop substream
- */
-static int snd_usX2Y_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
+
+static void i_usX2Y_subs_startup(struct urb *urb, struct pt_regs *regs)
 {
-	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)substream->runtime->private_data;
+	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t*)urb->context;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+	snd_usX2Y_substream_t *prepare_subs = usX2Y->prepare_subs;
+	if (NULL != prepare_subs)
+		if (urb->start_frame == prepare_subs->urb[0]->start_frame) {
+			usX2Y_subs_startup_finish(usX2Y);
+			atomic_inc(&prepare_subs->state);
+			wake_up(&usX2Y->prepare_wait_queue);
+		}
 
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		snd_printdd("snd_usX2Y_pcm_trigger(START)\n");
-		if (subs->usX2Y->substream[SNDRV_PCM_STREAM_CAPTURE]->stalled)
-			return -EPIPE;
-		else
-			subs->running = 1;
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		snd_printdd("snd_usX2Y_pcm_trigger(STOP)\n");
-		subs->running = 0;
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
+	i_usX2Y_urb_complete(urb, regs);
 }
 
+static void usX2Y_subs_prepare(snd_usX2Y_substream_t *subs)
+{
+	snd_printdd("usX2Y_substream_prepare(%p) ep=%i urb0=%p urb1=%p\n", subs, subs->endpoint, subs->urb[0], subs->urb[1]);
+	/* reset the pointer */
+	subs->hwptr = 0;
+	subs->hwptr_done = 0;
+	subs->transfer_done = 0;
+}
 
 
 static void usX2Y_urb_release(struct urb** urb, int free_tb)
 {
 	if (*urb) {
+		usb_kill_urb(*urb);
 		if (free_tb)
 			kfree((*urb)->transfer_buffer);
 		usb_free_urb(*urb);
@@ -415,97 +392,179 @@
 	}
 }
 /*
- * release a substream
+ * release a substreams urbs
  */
 static void usX2Y_urbs_release(snd_usX2Y_substream_t *subs)
 {
 	int i;
-	snd_printdd("snd_usX2Y_urbs_release() %i\n", subs->endpoint);
-	usX2Y_urbs_wait_clear(subs);
+	snd_printdd("usX2Y_urbs_release() %i\n", subs->endpoint);
 	for (i = 0; i < NRURBS; i++)
-		usX2Y_urb_release(subs->urb + i, subs != subs->usX2Y->substream[SNDRV_PCM_STREAM_PLAYBACK]);
+		usX2Y_urb_release(subs->urb + i, subs != subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK]);
 
 	if (subs->tmpbuf) {
 		kfree(subs->tmpbuf);
 		subs->tmpbuf = NULL;
 	}
 }
-
-static void usX2Y_substream_prepare(snd_usX2Y_substream_t *subs)
-{
-	snd_printdd("usX2Y_substream_prepare() ep=%i urb0=%p urb1=%p\n", subs->endpoint, subs->urb[0], subs->urb[1]);
-	/* reset the pointer */
-	subs->hwptr = 0;
-	subs->hwptr_done = 0;
-	subs->transfer_done = 0;
-}
-
-
 /*
  * initialize a substream's urbs
  */
 static int usX2Y_urbs_allocate(snd_usX2Y_substream_t *subs)
 {
 	int i;
-	int is_playback = subs == subs->usX2Y->substream[SNDRV_PCM_STREAM_PLAYBACK];
+	unsigned int pipe;
+	int is_playback = subs == subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];
 	struct usb_device *dev = subs->usX2Y->chip.dev;
 
-	snd_assert(!subs->prepared, return 0);
+	pipe = is_playback ? usb_sndisocpipe(dev, subs->endpoint) :
+			usb_rcvisocpipe(dev, subs->endpoint);
+	subs->maxpacksize = usb_maxpacket(dev, pipe, is_playback);
+	if (!subs->maxpacksize)
+		return -EINVAL;
 
-	if (is_playback) {	/* allocate a temporary buffer for playback */
-		subs->datapipe = usb_sndisocpipe(dev, subs->endpoint);
-		subs->maxpacksize = dev->epmaxpacketout[subs->endpoint];
+	if (is_playback && NULL == subs->tmpbuf) {	/* allocate a temporary buffer for playback */
+		subs->tmpbuf = kcalloc(nr_of_packs(), subs->maxpacksize, GFP_KERNEL);
 		if (NULL == subs->tmpbuf) {
-			subs->tmpbuf = kcalloc(NRPACKS, subs->maxpacksize, GFP_KERNEL);
-			if (NULL == subs->tmpbuf) {
-				snd_printk(KERN_ERR "cannot malloc tmpbuf\n");
-				return -ENOMEM;
-			}
+			snd_printk(KERN_ERR "cannot malloc tmpbuf\n");
+			return -ENOMEM;
 		}
-	} else {
-		subs->datapipe = usb_rcvisocpipe(dev, subs->endpoint);
-		subs->maxpacksize = dev->epmaxpacketin[subs->endpoint];
 	}
-
 	/* allocate and initialize data urbs */
 	for (i = 0; i < NRURBS; i++) {
 		struct urb** purb = subs->urb + i;
-		if (*purb)
+		if (*purb) {
+			usb_kill_urb(*purb);
 			continue;
-		*purb = usb_alloc_urb(NRPACKS, GFP_KERNEL);
+		}
+		*purb = usb_alloc_urb(nr_of_packs(), GFP_KERNEL);
 		if (NULL == *purb) {
 			usX2Y_urbs_release(subs);
 			return -ENOMEM;
 		}
 		if (!is_playback && !(*purb)->transfer_buffer) {
 			/* allocate a capture buffer per urb */
-			(*purb)->transfer_buffer = kmalloc(subs->maxpacksize*NRPACKS, GFP_KERNEL);
+			(*purb)->transfer_buffer = kmalloc(subs->maxpacksize * nr_of_packs(), GFP_KERNEL);
 			if (NULL == (*purb)->transfer_buffer) {
 				usX2Y_urbs_release(subs);
 				return -ENOMEM;
 			}
 		}
 		(*purb)->dev = dev;
-		(*purb)->pipe = subs->datapipe;
-		(*purb)->number_of_packets = NRPACKS;
+		(*purb)->pipe = pipe;
+		(*purb)->number_of_packets = nr_of_packs();
 		(*purb)->context = subs;
 		(*purb)->interval = 1;
-		(*purb)->complete = snd_usb_complete_callback(i_usX2Y_urb_complete);
+		(*purb)->complete = i_usX2Y_subs_startup;
 	}
 	return 0;
 }
 
-static void i_usX2Y_04Int(struct urb* urb, struct pt_regs *regs)
+static void usX2Y_subs_startup(snd_usX2Y_substream_t *subs)
 {
-	usX2Ydev_t*	usX2Y = urb->context;
-	
-	if (urb->status) {
-		snd_printk("snd_usX2Y_04Int() urb->status=%i\n", urb->status);
-		return;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+	usX2Y->prepare_subs = subs;
+	subs->urb[0]->start_frame = -1;
+	wmb();
+	usX2Y_urbs_set_complete(usX2Y, i_usX2Y_subs_startup);
+}
+
+static int usX2Y_urbs_start(snd_usX2Y_substream_t *subs)
+{
+	int i, err;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+
+	if ((err = usX2Y_urbs_allocate(subs)) < 0)
+		return err;
+	subs->completed_urb = NULL;
+	for (i = 0; i < 4; i++) {
+		snd_usX2Y_substream_t *subs = usX2Y->subs[i];
+		if (subs != NULL && atomic_read(&subs->state) >= state_PREPARED)
+			goto start;
 	}
-	if (0 == --usX2Y->US04->len)
-		wake_up(&usX2Y->In04WaitQueue);
+	usX2Y->wait_iso_frame = -1;
+ start:
+	{
+		usX2Y_subs_startup(subs);
+		for (i = 0; i < NRURBS; i++) {
+			struct urb *urb = subs->urb[i];
+			if (usb_pipein(urb->pipe)) {
+				unsigned long pack;
+				if (0 == i)
+					atomic_set(&subs->state, state_STARTING3);
+				urb->dev = usX2Y->chip.dev;
+				urb->transfer_flags = URB_ISO_ASAP;
+				for (pack = 0; pack < nr_of_packs(); pack++) {
+					urb->iso_frame_desc[pack].offset = subs->maxpacksize * pack;
+					urb->iso_frame_desc[pack].length = subs->maxpacksize;
+				}
+				urb->transfer_buffer_length = subs->maxpacksize * nr_of_packs(); 
+				if ((err = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
+					snd_printk (KERN_ERR "cannot submit datapipe for urb %d, err = %d\n", i, err);
+					err = -EPIPE;
+					goto cleanup;
+				} else {
+					if (0 > usX2Y->wait_iso_frame)
+						usX2Y->wait_iso_frame = urb->start_frame;
+				}
+				urb->transfer_flags = 0;
+			} else {
+				atomic_set(&subs->state, state_STARTING1);
+				break;
+			}
+		}
+		err = 0;
+		wait_event(usX2Y->prepare_wait_queue, NULL == usX2Y->prepare_subs);
+		if (atomic_read(&subs->state) != state_PREPARED) {
+			err = -EPIPE;
+		}
+
+	cleanup:
+		if (err) {
+			usX2Y_subs_startup_finish(usX2Y);
+			usX2Y_clients_stop(usX2Y);		// something is completely wroong > stop evrything
+		}
+	}
+	return err;
+}
+
+/*
+ * return the current pcm pointer.  just return the hwptr_done value.
+ */
+static snd_pcm_uframes_t snd_usX2Y_pcm_pointer(snd_pcm_substream_t *substream)
+{
+	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)substream->runtime->private_data;
+	return subs->hwptr_done;
+}
+/*
+ * start/stop substream
+ */
+static int snd_usX2Y_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)substream->runtime->private_data;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		snd_printdd("snd_usX2Y_pcm_trigger(START)\n");
+		if (atomic_read(&subs->state) == state_PREPARED &&
+		    atomic_read(&subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE]->state) >= state_PREPARED) {
+			atomic_set(&subs->state, state_PRERUNNING);
+		} else {
+			snd_printdd("\n");
+			return -EPIPE;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		snd_printdd("snd_usX2Y_pcm_trigger(STOP)\n");
+		if (atomic_read(&subs->state) >= state_PRERUNNING)
+			atomic_set(&subs->state, state_PREPARED);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
 }
+
+
 /*
  * allocate a buffer, setup samplerate
  *
@@ -592,76 +651,74 @@
 };
 #define NOOF_SETRATE_URBS ARRAY_SIZE(SetRate48000)
 
+static void i_usX2Y_04Int(struct urb* urb, struct pt_regs *regs)
+{
+	usX2Ydev_t*	usX2Y = urb->context;
+	
+	if (urb->status) {
+		snd_printk("snd_usX2Y_04Int() urb->status=%i\n", urb->status);
+	}
+	if (0 == --usX2Y->US04->len)
+		wake_up(&usX2Y->In04WaitQueue);
+}
+
 static int usX2Y_rate_set(usX2Ydev_t *usX2Y, int rate)
 {
 	int			err = 0, i;
 	snd_usX2Y_urbSeq_t	*us = NULL;
 	int			*usbdata = NULL;
-	DECLARE_WAITQUEUE(wait, current);
 	struct s_c2		*ra = rate == 48000 ? SetRate48000 : SetRate44100;
 
 	if (usX2Y->rate != rate) {
-		do {
-			us = kmalloc(sizeof(*us) + sizeof(struct urb*) * NOOF_SETRATE_URBS, GFP_KERNEL);
-			if (NULL == us) {
-				err = -ENOMEM;
-				break;
-			}
-			memset(us, 0, sizeof(*us) + sizeof(struct urb*) * NOOF_SETRATE_URBS); 
-			usbdata = kmalloc(sizeof(int)*NOOF_SETRATE_URBS, GFP_KERNEL);
-			if (NULL == usbdata) {
+		us = kmalloc(sizeof(*us) + sizeof(struct urb*) * NOOF_SETRATE_URBS, GFP_KERNEL);
+		if (NULL == us) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		memset(us, 0, sizeof(*us) + sizeof(struct urb*) * NOOF_SETRATE_URBS); 
+		usbdata = kmalloc(sizeof(int)*NOOF_SETRATE_URBS, GFP_KERNEL);
+		if (NULL == usbdata) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		for (i = 0; i < NOOF_SETRATE_URBS; ++i) {
+			if (NULL == (us->urb[i] = usb_alloc_urb(0, GFP_KERNEL))) {
 				err = -ENOMEM;
-				break;
+				goto cleanup;
 			}
-			for (i = 0; i < NOOF_SETRATE_URBS; ++i) {
-				if (NULL == (us->urb[i] = usb_alloc_urb(0, GFP_KERNEL))) {
-					err = -ENOMEM;
-					break;
-				}
-				((char*)(usbdata + i))[0] = ra[i].c1;
-				((char*)(usbdata + i))[1] = ra[i].c2;
-				usb_fill_bulk_urb(us->urb[i], usX2Y->chip.dev, usb_sndbulkpipe(usX2Y->chip.dev, 4),
-						  usbdata + i, 2, i_usX2Y_04Int, usX2Y);
+			((char*)(usbdata + i))[0] = ra[i].c1;
+			((char*)(usbdata + i))[1] = ra[i].c2;
+			usb_fill_bulk_urb(us->urb[i], usX2Y->chip.dev, usb_sndbulkpipe(usX2Y->chip.dev, 4),
+					  usbdata + i, 2, i_usX2Y_04Int, usX2Y);
 #ifdef OLD_USB
-				us->urb[i]->transfer_flags = USB_QUEUE_BULK;
+			us->urb[i]->transfer_flags = USB_QUEUE_BULK;
 #endif
-			}
-			if (err)
-				break;
-
-			add_wait_queue(&usX2Y->In04WaitQueue, &wait);
-			set_current_state(TASK_INTERRUPTIBLE);
-			us->submitted =	0;
-			us->len =	NOOF_SETRATE_URBS;
-			usX2Y->US04 =	us;
-		
-			do {
-				signed long	timeout = schedule_timeout(HZ/2);
-                	
-				if (signal_pending(current)) {
-					err = -ERESTARTSYS;
-					break;
-				}
-				if (0 == timeout) {
-					err = -ENODEV;
-					break;
-				}
-				usX2Y->rate = rate;
-				usX2Y->refframes = rate == 48000 ? 47 : 44;
-			} while (0);
-		
-			remove_wait_queue(&usX2Y->In04WaitQueue, &wait);
-		} while (0);
-
+		}
+		us->submitted =	0;
+		us->len =	NOOF_SETRATE_URBS;
+		usX2Y->US04 =	us;
+		wait_event_timeout(usX2Y->In04WaitQueue, 0 == us->len, HZ);
+		usX2Y->US04 =	NULL;
+		if (us->len)
+			err = -ENODEV;
+	cleanup:
 		if (us) {
 			us->submitted =	2*NOOF_SETRATE_URBS;
 			for (i = 0; i < NOOF_SETRATE_URBS; ++i) {
-				usb_kill_urb(us->urb[i]);
-				usb_free_urb(us->urb[i]);
+				struct urb *urb = us->urb[i];
+				if (urb->status) {
+					if (!err)
+						err = -ENODEV;
+					usb_kill_urb(urb);
+				}
+				usb_free_urb(urb);
 			}
 			usX2Y->US04 = NULL;
 			kfree(usbdata);
 			kfree(us);
+			if (!err) {
+				usX2Y->rate = rate;
+			}
 		}
 	}
 
@@ -745,27 +802,28 @@
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)runtime->private_data;
+	down(&subs->usX2Y->prepare_mutex);
 	snd_printdd("snd_usX2Y_hw_free(%p)\n", substream);
 
 	if (SNDRV_PCM_STREAM_PLAYBACK == substream->stream) {
-		snd_usX2Y_substream_t *cap_subs = subs->usX2Y->substream[SNDRV_PCM_STREAM_CAPTURE];
-		subs->prepared = 0;
+		snd_usX2Y_substream_t *cap_subs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];
+		atomic_set(&subs->state, state_STOPPED);
 		usX2Y_urbs_release(subs);
 		if (!cap_subs->pcm_substream ||
 		    !cap_subs->pcm_substream->runtime ||
 		    !cap_subs->pcm_substream->runtime->status ||
 		    cap_subs->pcm_substream->runtime->status->state < SNDRV_PCM_STATE_PREPARED) {
-			cap_subs->prepared = 0;
+			atomic_set(&cap_subs->state, state_STOPPED);
 			usX2Y_urbs_release(cap_subs);
 		}
 	} else {
-		snd_usX2Y_substream_t *playback_subs = subs->usX2Y->substream[SNDRV_PCM_STREAM_PLAYBACK];
-		if (!playback_subs->prepared) {
-			subs->prepared = 0;
+		snd_usX2Y_substream_t *playback_subs = subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];
+		if (atomic_read(&playback_subs->state) < state_PREPARED) {
+			atomic_set(&subs->state, state_STOPPED);
 			usX2Y_urbs_release(subs);
 		}
 	}
-
+	up(&subs->usX2Y->prepare_mutex);
 	return snd_pcm_lib_free_pages(substream);
 }
 /*
@@ -777,71 +835,32 @@
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)runtime->private_data;
-	snd_usX2Y_substream_t *capsubs = subs->usX2Y->substream[SNDRV_PCM_STREAM_CAPTURE];
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+	snd_usX2Y_substream_t *capsubs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];
 	int err = 0;
 	snd_printdd("snd_usX2Y_pcm_prepare(%p)\n", substream);
 
+	down(&usX2Y->prepare_mutex);
+	usX2Y_subs_prepare(subs);
 // Start hardware streams
 // SyncStream first....
-	if (! capsubs->prepared) {
-		if (subs->usX2Y->format != runtime->format)
-			if ((err = usX2Y_format_set(subs->usX2Y, runtime->format)) < 0)
-				return err;
-		if (subs->usX2Y->rate != runtime->rate)
-			if ((err = usX2Y_rate_set(subs->usX2Y, runtime->rate)) < 0)
-				return err;
-		snd_printdd("starting capture pipe for playpipe\n");
-		usX2Y_urbs_allocate(capsubs);
-		capsubs->completed_urb = NULL;
-		{
-			DECLARE_WAITQUEUE(wait, current);
-			add_wait_queue(&capsubs->wait_queue, &wait);
-			if (0 <= (err = usX2Y_urbs_capt_start(capsubs))) {
-				signed long timeout;
-				set_current_state(TASK_INTERRUPTIBLE);
-				timeout = schedule_timeout(HZ/4);
-				if (signal_pending(current))
-					err = -ERESTARTSYS;
-				else {
-					snd_printdd("%li\n", HZ/4 - timeout);
-					if (0 == timeout)
-						err = -EPIPE;
-				}
-			}
-			remove_wait_queue(&capsubs->wait_queue, &wait);
-			if (0 > err)
-				return err;
-		}
+	if (atomic_read(&capsubs->state) < state_PREPARED) {
+		if (usX2Y->format != runtime->format)
+			if ((err = usX2Y_format_set(usX2Y, runtime->format)) < 0)
+				goto up_prepare_mutex;
+		if (usX2Y->rate != runtime->rate)
+			if ((err = usX2Y_rate_set(usX2Y, runtime->rate)) < 0)
+				goto up_prepare_mutex;
+		snd_printdd("starting capture pipe for %s\n", subs == capsubs ? "self" : "playpipe");
+		if (0 > (err = usX2Y_urbs_start(capsubs)))
+			goto up_prepare_mutex;
 	}
 
-	if (subs != capsubs) {
-		int u;
-		if (!subs->prepared) {
-			if ((err = usX2Y_urbs_allocate(subs)) < 0)
-				return err;
-			subs->prepared = 1;
-		}
-		while (subs->submitted_urbs)
-			for (u = 0; u < NRURBS; u++) {
-				snd_printdd("%i\n", subs->urb[u]->status);
-				while(subs->urb[u]->status  ||  NULL != subs->urb[u]->hcpriv) {
-					signed long timeout;
-					snd_printdd("ep=%i waiting for urb=%p status=%i hcpriv=%p\n",
-						    subs->endpoint, subs->urb[u],
-						    subs->urb[u]->status, subs->urb[u]->hcpriv);
-					set_current_state(TASK_INTERRUPTIBLE);
-					timeout = schedule_timeout(HZ/10);
-					if (signal_pending(current)) {
-						return -ERESTARTSYS;
-					}
-				}
-			}
-		subs->completed_urb = NULL;
-		subs->next_urb_complete = -1;
-		subs->stalled = 0;
-	}
+	if (subs != capsubs && atomic_read(&subs->state) < state_PREPARED)
+		err = usX2Y_urbs_start(subs);
 
-	usX2Y_substream_prepare(subs);
+ up_prepare_mutex:
+	up(&usX2Y->prepare_mutex);
 	return err;
 }
 
@@ -872,6 +891,9 @@
 					 snd_pcm_substream_chip(substream))[substream->stream];
 	snd_pcm_runtime_t	*runtime = substream->runtime;
 
+	if (subs->usX2Y->chip_status & USX2Y_STAT_CHIP_MMAP_PCM_URBS)
+		return -EBUSY;
+
 	runtime->hw = snd_usX2Y_2c;
 	runtime->private_data = subs;
 	subs->pcm_substream = substream;
@@ -933,7 +955,7 @@
 	snd_pcm_t *pcm;
 	int err, i;
 	snd_usX2Y_substream_t **usX2Y_substream =
-		usX2Y(card)->substream + 2 * usX2Y(card)->chip.pcm_devs;
+		usX2Y(card)->subs + 2 * usX2Y(card)->chip.pcm_devs;
 
 	for (i = playback_endpoint ? SNDRV_PCM_STREAM_PLAYBACK : SNDRV_PCM_STREAM_CAPTURE;
 	     i <= SNDRV_PCM_STREAM_CAPTURE; ++i) {
@@ -942,7 +964,6 @@
 			snd_printk(KERN_ERR "cannot malloc\n");
 			return -ENOMEM;
 		}
-		init_waitqueue_head(&usX2Y_substream[i]->wait_queue);
 		usX2Y_substream[i]->usX2Y = usX2Y(card);
 	}
 
@@ -986,34 +1007,14 @@
 }
 
 /*
- * free the chip instance
- *
- * here we have to do not much, since pcm and controls are already freed
- *
- */
-static int snd_usX2Y_device_dev_free(snd_device_t *device)
-{
-	return 0;
-}
-
-
-/*
  * create a chip instance and set its names.
  */
 int usX2Y_audio_create(snd_card_t* card)
 {
 	int err = 0;
-	static snd_device_ops_t ops = {
-		.dev_free = snd_usX2Y_device_dev_free,
-	};
 	
 	INIT_LIST_HEAD(&usX2Y(card)->chip.pcm_list);
 
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, usX2Y(card), &ops)) < 0) {
-//		snd_usX2Y_audio_free(usX2Y(card));
-		return err;
-	}
-
 	if (0 > (err = usX2Y_audio_stream_new(card, 0xA, 0x8)))
 		return err;
 	if (usX2Y(card)->chip.dev->descriptor.idProduct == USB_ID_US428)
diff -uNr a/sound/usb/usx2y/usbusx2y.c b/sound/usb/usx2y/usbusx2y.c
--- a/sound/usb/usx2y/usbusx2y.c	2004-12-24 22:34:00.000000000 +0100
+++ b/sound/usb/usx2y/usbusx2y.c	2005-01-14 22:28:12.486460200 +0100
@@ -1,6 +1,30 @@
 /*
- * usbus428.c - ALSA USB US-428 Driver
+ * usbusy2y.c - ALSA USB US-428 Driver
  *
+2004-12-14 Karsten Wiese
+	Version 0.8.7.1:
+	snd_pcm_open for rawusb pcm-devices now returns -EBUSY if called without rawusb's hwdep device being open.
+
+2004-12-02 Karsten Wiese
+	Version 0.8.7:
+	Use macro usb_maxpacket() for portability.
+
+2004-10-26 Karsten Wiese
+	Version 0.8.6:
+	wake_up() process waiting in usX2Y_urbs_start() on error.
+
+2004-10-21 Karsten Wiese
+	Version 0.8.5:
+	nrpacks is runtime or compiletime configurable now with tested values from 1 to 4.
+
+2004-10-03 Karsten Wiese
+	Version 0.8.2:
+	Avoid any possible racing while in prepare callback.
+
+2004-09-30 Karsten Wiese
+	Version 0.8.0:
+	Simplified things and made ohci work again.
+
 2004-09-20 Karsten Wiese
 	Version 0.7.3:
 	Use usb_kill_urb() instead of deprecated (kernel 2.6.9) usb_unlink_urb().
@@ -84,7 +108,7 @@
 	Version 0.0.2: midi works with snd-usb-midi, audio (only fullduplex now) with i.e. bristol.
 	The firmware has been sniffed from win2k us-428 driver 3.09.
 
- *   Copyright (c) 2002 Karsten Wiese
+ *   Copyright (c) 2002 - 2004 Karsten Wiese
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -119,7 +143,7 @@
 
 
 MODULE_AUTHOR("Karsten Wiese <annabellesgarden@yahoo.de>");
-MODULE_DESCRIPTION("TASCAM "NAME_ALLCAPS" Version 0.7.3");
+MODULE_DESCRIPTION("TASCAM "NAME_ALLCAPS" Version 0.8.7.1");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{TASCAM(0x1604), "NAME_ALLCAPS"(0x8001)(0x8005)(0x8007) }}");
 
@@ -285,8 +309,7 @@
 			S->urb[i] = NULL;
 		}
 	}
-	if (S->buffer)
-		kfree(S->buffer);
+	kfree(S->buffer);
 }
 
 
@@ -325,7 +348,8 @@
 	card->private_free = snd_usX2Y_card_private_free;
 	usX2Y(card)->chip.dev = device;
 	usX2Y(card)->chip.card = card;
-	init_MUTEX (&usX2Y(card)->open_mutex);
+	init_waitqueue_head(&usX2Y(card)->prepare_wait_queue);
+	init_MUTEX (&usX2Y(card)->prepare_mutex);
 	INIT_LIST_HEAD(&usX2Y(card)->chip.midi_list);
 	strcpy(card->driver, "USB "NAME_ALLCAPS"");
 	sprintf(card->shortname, "TASCAM "NAME_ALLCAPS"");
@@ -389,8 +413,7 @@
 
 static void snd_usX2Y_card_private_free(snd_card_t *card)
 {
-	if (usX2Y(card)->In04Buf)
-		kfree(usX2Y(card)->In04Buf);
+	kfree(usX2Y(card)->In04Buf);
 	usb_free_urb(usX2Y(card)->In04urb);
 	if (usX2Y(card)->us428ctls_sharedmem)
 		snd_free_pages(usX2Y(card)->us428ctls_sharedmem, sizeof(*usX2Y(card)->us428ctls_sharedmem));
diff -uNr a/sound/usb/usx2y/usbusx2y.h b/sound/usb/usx2y/usbusx2y.h
--- a/sound/usb/usx2y/usbusx2y.h	2004-12-24 22:35:23.000000000 +0100
+++ b/sound/usb/usx2y/usbusx2y.h	2005-01-14 22:28:12.492459288 +0100
@@ -3,15 +3,8 @@
 #include "../usbaudio.h"
 #include "usbus428ctldefs.h" 
 
-#define NRURBS	        2	/* */
-#define NRPACKS		1	/* FIXME: Currently only 1 works.
-				   usb-frames/ms per urb: 1 and 2 are supported.
-				   setting to 2 will PERHAPS make it easier for slow machines.
-				   Jitter will be higher though.
-				   On my PIII 500Mhz Laptop setting to 1 is the only way to go 
-				   for PLAYING synths. i.e. Jack & Aeolus sound quit nicely 
-				   at 4 periods 64 frames. 
-				*/
+#define NRURBS	        2	
+
 
 #define URBS_AsyncSeq 10
 #define URB_DataLen_AsyncSeq 32
@@ -27,6 +20,7 @@
 } snd_usX2Y_urbSeq_t;
 
 typedef struct snd_usX2Y_substream snd_usX2Y_substream_t;
+#include "usx2yhwdeppcm.h"
 
 typedef struct {
 	snd_usb_audio_t 	chip;
@@ -40,15 +34,44 @@
 	snd_usX2Y_AsyncSeq_t	AS04;
 	unsigned int		rate,
 				format;
-	int			refframes;
 	int			chip_status;
-	struct semaphore	open_mutex;
+	struct semaphore	prepare_mutex;
 	us428ctls_sharedmem_t	*us428ctls_sharedmem;
+	int			wait_iso_frame;
 	wait_queue_head_t	us428ctls_wait_queue_head;
-	snd_usX2Y_substream_t	*substream[4];
+	snd_usX2Y_hwdep_pcm_shm_t	*hwdep_pcm_shm;
+	snd_usX2Y_substream_t	*subs[4];
+	snd_usX2Y_substream_t	* volatile  prepare_subs;
+	wait_queue_head_t	prepare_wait_queue;
 } usX2Ydev_t;
 
 
+struct snd_usX2Y_substream {
+	usX2Ydev_t	*usX2Y;
+	snd_pcm_substream_t *pcm_substream;
+
+	int			endpoint;		
+	unsigned int		maxpacksize;		/* max packet size in bytes */
+
+	atomic_t		state;
+#define state_STOPPED	0
+#define state_STARTING1 1
+#define state_STARTING2 2
+#define state_STARTING3 3
+#define state_PREPARED	4
+#define state_PRERUNNING  6
+#define state_RUNNING	8
+
+	int			hwptr;			/* free frame position in the buffer (only for playback) */
+	int			hwptr_done;		/* processed frame position in the buffer */
+	int			transfer_done;		/* processed frames since last period update */
+
+	struct urb		*urb[NRURBS];	/* data urb table */
+	struct urb		*completed_urb;
+	char			*tmpbuf;			/* temporary buffer for playback */
+};
+
+
 #define usX2Y(c) ((usX2Ydev_t*)(c)->private_data)
 
 int usX2Y_audio_create(snd_card_t* card);
diff -uNr a/sound/usb/usx2y/usx2y.h b/sound/usb/usx2y/usx2y.h
--- a/sound/usb/usx2y/usx2y.h	2004-12-24 22:35:28.000000000 +0100
+++ b/sound/usb/usx2y/usx2y.h	2005-01-14 22:28:12.494458984 +0100
@@ -27,6 +27,7 @@
 
 /* hwdep id string */
 #define SND_USX2Y_LOADER_ID		"USX2Y Loader"
+#define SND_USX2Y_USBPCM_ID		"USX2Y USBPCM"
 
 /* hardware type */
 enum {
@@ -42,8 +43,9 @@
 
 /* chip status */
 enum {
-	USX2Y_STAT_CHIP_INIT	= (1 << 0),	/* all operational */
-	USX2Y_STAT_CHIP_HUP	= (1 << 31),	/* all operational */
+	USX2Y_STAT_CHIP_INIT	=	(1 << 0),	/* all operational */
+	USX2Y_STAT_CHIP_MMAP_PCM_URBS = (1 << 1),	/* pcm transport over mmaped urbs */
+	USX2Y_STAT_CHIP_HUP	=	(1 << 31),	/* all operational */
 };
 
 #endif /* __SOUND_USX2Y_COMMON_H */
diff -uNr a/sound/usb/usx2y/usX2Yhwdep.c b/sound/usb/usx2y/usX2Yhwdep.c
--- a/sound/usb/usx2y/usX2Yhwdep.c	2004-12-24 22:33:49.000000000 +0100
+++ b/sound/usb/usx2y/usX2Yhwdep.c	2005-01-14 22:28:12.497458528 +0100
@@ -31,6 +31,8 @@
 #include "usbusx2y.h"
 #include "usX2Yhwdep.h"
 
+int usX2Y_hwdep_pcm_new(snd_card_t* card);
+
 
 static struct page * snd_us428ctls_vm_nopage(struct vm_area_struct *area, unsigned long address, int *type)
 {
@@ -95,20 +97,14 @@
 {
 	unsigned int	mask = 0;
 	usX2Ydev_t	*us428 = (usX2Ydev_t*)hw->private_data;
-	static unsigned	LastN;
-
+	us428ctls_sharedmem_t *shm = us428->us428ctls_sharedmem;
 	if (us428->chip_status & USX2Y_STAT_CHIP_HUP)
 		return POLLHUP;
 
 	poll_wait(file, &us428->us428ctls_wait_queue_head, wait);
 
-	down(&us428->open_mutex);
-	if (us428->us428ctls_sharedmem
-	    && us428->us428ctls_sharedmem->CtlSnapShotLast != LastN) {
+	if (shm != NULL && shm->CtlSnapShotLast != shm->CtlSnapShotRed)
 		mask |= POLLIN;
-		LastN = us428->us428ctls_sharedmem->CtlSnapShotLast;
-	}
-	up(&us428->open_mutex);
 
 	return mask;
 }
@@ -202,6 +198,8 @@
 		}
 		if ((err = usX2Y_audio_create(card)) < 0) 
 			break;
+		if ((err = usX2Y_hwdep_pcm_new(card)) < 0)
+			break;
 		if ((err = snd_card_register(card)) < 0)
 			break;
 	} while (0);
diff -uNr a/sound/usb/usx2y/usx2yhwdeppcm.c b/sound/usb/usx2y/usx2yhwdeppcm.c
--- a/sound/usb/usx2y/usx2yhwdeppcm.c	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/usb/usx2y/usx2yhwdeppcm.c	2005-01-14 22:28:12.502457768 +0100
@@ -0,0 +1,807 @@
+/*
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/* USX2Y "rawusb" aka hwdep_pcm implementation
+
+ Its usb's unableness to atomically handle power of 2 period sized data chuncs
+ at standard samplerates,
+ what led to this part of the usx2y module: 
+ It provides the alsa kernel half of the usx2y-alsa-jack driver pair.
+ The pair uses a hardware dependant alsa-device for mmaped pcm transport.
+ Advantage achieved:
+         The usb_hc moves pcm data from/into memory via DMA.
+         That memory is mmaped by jack's usx2y driver.
+         Jack's usx2y driver is the first/last to read/write pcm data.
+         Read/write is a combination of power of 2 period shaping and
+         float/int conversation.
+         Compared to mainline alsa/jack we leave out power of 2 period shaping inside
+         snd-usb-usx2y which needs memcpy() and additional buffers.
+         As a side effect possible unwanted pcm-data coruption resulting of
+         standard alsa's snd-usb-usx2y period shaping scheme falls away.
+         Result is sane jack operation at buffering schemes down to 128frames,
+         2 periods.
+         plain usx2y alsa mode is able to achieve 64frames, 4periods, but only at the
+         cost of easier triggered i.e. aeolus xruns (128 or 256frames,
+         2periods works but is useless cause of crackling).
+ 
+ This is a first "proof of concept" implementation.
+ Later, funcionalities should migrate to more apropriate places:
+ Userland:
+ - The jackd could mmap its float-pcm buffers directly from alsa-lib.
+ - alsa-lib could provide power of 2 period sized shaping combined with int/float
+   conversation.
+   Currently the usx2y jack driver provides above 2 services.
+ Kernel:
+ - rawusb dma pcm buffer transport should go to snd-usb-lib, so also snd-usb-audio
+   devices can use it.
+   Currently rawusb dma pcm buffer transport (this file) is only available to snd-usb-usx2y. 
+*/
+
+#include "usbusx2yaudio.c"
+
+#if defined(USX2Y_NRPACKS_VARIABLE) || (!defined(USX2Y_NRPACKS_VARIABLE) &&  USX2Y_NRPACKS == 1)
+
+#include <sound/hwdep.h>
+
+
+static int usX2Y_usbpcm_urb_capt_retire(snd_usX2Y_substream_t *subs)
+{
+	struct urb	*urb = subs->completed_urb;
+	snd_pcm_runtime_t *runtime = subs->pcm_substream->runtime;
+	int 		i, lens = 0, hwptr_done = subs->hwptr_done;
+	usX2Ydev_t	*usX2Y = subs->usX2Y;
+	if (0 > usX2Y->hwdep_pcm_shm->capture_iso_start) { //FIXME
+		int head = usX2Y->hwdep_pcm_shm->captured_iso_head + 1;
+		if (head >= ARRAY_SIZE(usX2Y->hwdep_pcm_shm->captured_iso))
+			head = 0;
+		usX2Y->hwdep_pcm_shm->capture_iso_start = head;
+		snd_printdd("cap start %i\n", head);
+	}
+	for (i = 0; i < nr_of_packs(); i++) {
+		if (urb->iso_frame_desc[i].status) { /* active? hmm, skip this */
+			snd_printk("activ frame status %i. Most propably some hardware problem.\n", urb->iso_frame_desc[i].status);
+			return urb->iso_frame_desc[i].status;
+		}
+		lens += urb->iso_frame_desc[i].actual_length / usX2Y->stride;
+	}
+	if ((hwptr_done += lens) >= runtime->buffer_size)
+		hwptr_done -= runtime->buffer_size;
+	subs->hwptr_done = hwptr_done;
+	subs->transfer_done += lens;
+	/* update the pointer, call callback if necessary */
+	if (subs->transfer_done >= runtime->period_size) {
+		subs->transfer_done -= runtime->period_size;
+		snd_pcm_period_elapsed(subs->pcm_substream);
+	}
+	return 0;
+}
+
+static inline int usX2Y_iso_frames_per_buffer(snd_pcm_runtime_t *runtime, usX2Ydev_t * usX2Y)
+{
+	return (runtime->buffer_size * 1000) / usX2Y->rate + 1;	//FIXME: so far only correct period_size == 2^x ?
+}
+
+/*
+ * prepare urb for playback data pipe
+ *
+ * we copy the data directly from the pcm buffer.
+ * the current position to be copied is held in hwptr field.
+ * since a urb can handle only a single linear buffer, if the total
+ * transferred area overflows the buffer boundary, we cannot send
+ * it directly from the buffer.  thus the data is once copied to
+ * a temporary buffer and urb points to that.
+ */
+static int usX2Y_hwdep_urb_play_prepare(snd_usX2Y_substream_t *subs,
+				  struct urb *urb)
+{
+	int count, counts, pack;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+	struct snd_usX2Y_hwdep_pcm_shm *shm = usX2Y->hwdep_pcm_shm;
+	snd_pcm_runtime_t *runtime = subs->pcm_substream->runtime;
+
+	if (0 > shm->playback_iso_start) {
+		shm->playback_iso_start = shm->captured_iso_head -
+			usX2Y_iso_frames_per_buffer(runtime, usX2Y);
+		if (0 > shm->playback_iso_start)
+			shm->playback_iso_start += ARRAY_SIZE(shm->captured_iso);
+		shm->playback_iso_head = shm->playback_iso_start;
+	}
+
+	count = 0;
+	for (pack = 0; pack < nr_of_packs(); pack++) {
+		/* calculate the size of a packet */
+		counts = shm->captured_iso[shm->playback_iso_head].length / usX2Y->stride;
+		if (counts < 43 || counts > 50) {
+			snd_printk("should not be here with counts=%i\n", counts);
+			return -EPIPE;
+		}
+		/* set up descriptor */
+		urb->iso_frame_desc[pack].offset = shm->captured_iso[shm->playback_iso_head].offset;
+		urb->iso_frame_desc[pack].length = shm->captured_iso[shm->playback_iso_head].length;
+		if (atomic_read(&subs->state) != state_RUNNING)
+			memset((char *)urb->transfer_buffer + urb->iso_frame_desc[pack].offset, 0,
+			       urb->iso_frame_desc[pack].length);
+		if (++shm->playback_iso_head >= ARRAY_SIZE(shm->captured_iso))
+			shm->playback_iso_head = 0;
+		count += counts;
+	}
+	urb->transfer_buffer_length = count * usX2Y->stride;
+	return 0;
+}
+
+
+static inline void usX2Y_usbpcm_urb_capt_iso_advance(snd_usX2Y_substream_t *subs, struct urb *urb)
+{
+	int pack;
+	for (pack = 0; pack < nr_of_packs(); ++pack) {
+		struct usb_iso_packet_descriptor *desc = urb->iso_frame_desc + pack;
+		if (NULL != subs) {
+			snd_usX2Y_hwdep_pcm_shm_t *shm = subs->usX2Y->hwdep_pcm_shm;
+			int head = shm->captured_iso_head + 1;
+			if (head >= ARRAY_SIZE(shm->captured_iso))
+				head = 0;
+			shm->captured_iso[head].frame = urb->start_frame + pack;
+			shm->captured_iso[head].offset = desc->offset;
+			shm->captured_iso[head].length = desc->actual_length;
+			shm->captured_iso_head = head;
+			shm->captured_iso_frames++;
+		}
+		if ((desc->offset += desc->length * NRURBS*nr_of_packs()) +
+		    desc->length >= SSS)
+			desc->offset -= (SSS - desc->length);
+	}
+}
+
+static inline int usX2Y_usbpcm_usbframe_complete(snd_usX2Y_substream_t *capsubs,
+					   snd_usX2Y_substream_t *capsubs2,
+					   snd_usX2Y_substream_t *playbacksubs, int frame)
+{
+	int err, state;
+	struct urb *urb = playbacksubs->completed_urb;
+
+	state = atomic_read(&playbacksubs->state);
+	if (NULL != urb) {
+		if (state == state_RUNNING)
+			usX2Y_urb_play_retire(playbacksubs, urb);
+		else
+			if (state >= state_PRERUNNING) {
+				atomic_inc(&playbacksubs->state);
+			}
+	} else {
+		switch (state) {
+		case state_STARTING1:
+			urb = playbacksubs->urb[0];
+			atomic_inc(&playbacksubs->state);
+			break;
+		case state_STARTING2:
+			urb = playbacksubs->urb[1];
+			atomic_inc(&playbacksubs->state);
+			break;
+		}
+	}
+	if (urb) {
+		if ((err = usX2Y_hwdep_urb_play_prepare(playbacksubs, urb)) ||
+		    (err = usX2Y_urb_submit(playbacksubs, urb, frame))) {
+			return err;
+		}
+	}
+	
+	playbacksubs->completed_urb = NULL;
+
+	state = atomic_read(&capsubs->state);
+	if (state >= state_PREPARED) {
+		if (state == state_RUNNING) {
+			if ((err = usX2Y_usbpcm_urb_capt_retire(capsubs)))
+				return err;
+		} else {
+			if (state >= state_PRERUNNING)
+				atomic_inc(&capsubs->state);
+		}
+		usX2Y_usbpcm_urb_capt_iso_advance(capsubs, capsubs->completed_urb);
+		if (NULL != capsubs2)
+			usX2Y_usbpcm_urb_capt_iso_advance(NULL, capsubs2->completed_urb);
+		if ((err = usX2Y_urb_submit(capsubs, capsubs->completed_urb, frame)))
+			return err;
+		if (NULL != capsubs2)
+			if ((err = usX2Y_urb_submit(capsubs2, capsubs2->completed_urb, frame)))
+				return err;
+	}
+	capsubs->completed_urb = NULL;
+	if (NULL != capsubs2)
+		capsubs2->completed_urb = NULL;
+	return 0;
+}
+
+
+static void i_usX2Y_usbpcm_urb_complete(struct urb *urb, struct pt_regs *regs)
+{
+	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t*)urb->context;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+	snd_usX2Y_substream_t *capsubs, *capsubs2, *playbacksubs;
+
+	if (unlikely(atomic_read(&subs->state) < state_PREPARED)) {
+		snd_printdd("hcd_frame=%i ep=%i%s status=%i start_frame=%i\n", usb_get_current_frame_number(usX2Y->chip.dev), subs->endpoint, usb_pipein(urb->pipe) ? "in" : "out", urb->status, urb->start_frame);
+		return;
+	}
+	if (unlikely(urb->status)) {
+		usX2Y_error_urb_status(usX2Y, subs, urb);
+		return;
+	}
+	if (likely((0xFFFF & urb->start_frame) == usX2Y->wait_iso_frame))
+		subs->completed_urb = urb;
+	else {
+		usX2Y_error_sequence(usX2Y, subs, urb);
+		return;
+	}
+
+	capsubs = usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];
+	capsubs2 = usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];
+	playbacksubs = usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];
+	if (capsubs->completed_urb && atomic_read(&capsubs->state) >= state_PREPARED &&
+	    (NULL == capsubs2 || capsubs2->completed_urb) &&
+	    (playbacksubs->completed_urb || atomic_read(&playbacksubs->state) < state_PREPARED)) {
+		if (!usX2Y_usbpcm_usbframe_complete(capsubs, capsubs2, playbacksubs, urb->start_frame)) {
+			if (nr_of_packs() <= urb->start_frame &&
+			    urb->start_frame <= (2 * nr_of_packs() - 1))	// uhci and ohci
+				usX2Y->wait_iso_frame = urb->start_frame - nr_of_packs();
+			else
+				usX2Y->wait_iso_frame +=  nr_of_packs();
+		} else {
+			snd_printdd("\n");
+			usX2Y_clients_stop(usX2Y);
+		}
+	}
+}
+
+
+static void usX2Y_hwdep_urb_release(struct urb** urb)
+{
+	usb_kill_urb(*urb);
+	usb_free_urb(*urb);
+	*urb = NULL;
+}
+
+/*
+ * release a substream
+ */
+static void usX2Y_usbpcm_urbs_release(snd_usX2Y_substream_t *subs)
+{
+	int i;
+	snd_printdd("snd_usX2Y_urbs_release() %i\n", subs->endpoint);
+	for (i = 0; i < NRURBS; i++)
+		usX2Y_hwdep_urb_release(subs->urb + i);
+}
+
+static void usX2Y_usbpcm_subs_startup_finish(usX2Ydev_t * usX2Y)
+{
+	usX2Y_urbs_set_complete(usX2Y, i_usX2Y_usbpcm_urb_complete);
+	usX2Y->prepare_subs = NULL;
+}
+
+static void i_usX2Y_usbpcm_subs_startup(struct urb *urb, struct pt_regs *regs)
+{
+	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t*)urb->context;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+	snd_usX2Y_substream_t *prepare_subs = usX2Y->prepare_subs;
+	if (NULL != prepare_subs &&
+	    urb->start_frame == prepare_subs->urb[0]->start_frame) {
+		atomic_inc(&prepare_subs->state);
+		if (prepare_subs == usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE]) {
+			snd_usX2Y_substream_t *cap_subs2 = usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];
+			if (cap_subs2 != NULL)
+				atomic_inc(&cap_subs2->state);
+		}
+		usX2Y_usbpcm_subs_startup_finish(usX2Y);
+		wake_up(&usX2Y->prepare_wait_queue);
+	}
+
+	i_usX2Y_usbpcm_urb_complete(urb, regs);
+}
+
+/*
+ * initialize a substream's urbs
+ */
+static int usX2Y_usbpcm_urbs_allocate(snd_usX2Y_substream_t *subs)
+{
+	int i;
+	unsigned int pipe;
+	int is_playback = subs == subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];
+	struct usb_device *dev = subs->usX2Y->chip.dev;
+
+	pipe = is_playback ? usb_sndisocpipe(dev, subs->endpoint) :
+			usb_rcvisocpipe(dev, subs->endpoint);
+	subs->maxpacksize = usb_maxpacket(dev, pipe, is_playback);
+	if (!subs->maxpacksize)
+		return -EINVAL;
+
+	/* allocate and initialize data urbs */
+	for (i = 0; i < NRURBS; i++) {
+		struct urb** purb = subs->urb + i;
+		if (*purb) {
+			usb_kill_urb(*purb);
+			continue;
+		}
+		*purb = usb_alloc_urb(nr_of_packs(), GFP_KERNEL);
+		if (NULL == *purb) {
+			usX2Y_usbpcm_urbs_release(subs);
+			return -ENOMEM;
+		}
+		(*purb)->transfer_buffer = is_playback ?
+			subs->usX2Y->hwdep_pcm_shm->playback : (
+				subs->endpoint == 0x8 ?
+				subs->usX2Y->hwdep_pcm_shm->capture0x8 :
+				subs->usX2Y->hwdep_pcm_shm->capture0xA);
+
+		(*purb)->dev = dev;
+		(*purb)->pipe = pipe;
+		(*purb)->number_of_packets = nr_of_packs();
+		(*purb)->context = subs;
+		(*purb)->interval = 1;
+		(*purb)->complete = i_usX2Y_usbpcm_subs_startup;
+	}
+	return 0;
+}
+
+/*
+ * free the buffer
+ */
+static int snd_usX2Y_usbpcm_hw_free(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)runtime->private_data,
+		*cap_subs2 = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];
+	down(&subs->usX2Y->prepare_mutex);
+	snd_printdd("snd_usX2Y_usbpcm_hw_free(%p)\n", substream);
+
+	if (SNDRV_PCM_STREAM_PLAYBACK == substream->stream) {
+		snd_usX2Y_substream_t *cap_subs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];
+		atomic_set(&subs->state, state_STOPPED);
+		usX2Y_usbpcm_urbs_release(subs);
+		if (!cap_subs->pcm_substream ||
+		    !cap_subs->pcm_substream->runtime ||
+		    !cap_subs->pcm_substream->runtime->status ||
+		    cap_subs->pcm_substream->runtime->status->state < SNDRV_PCM_STATE_PREPARED) {
+			atomic_set(&cap_subs->state, state_STOPPED);
+			if (NULL != cap_subs2)
+				atomic_set(&cap_subs2->state, state_STOPPED);
+			usX2Y_usbpcm_urbs_release(cap_subs);
+			if (NULL != cap_subs2)
+				usX2Y_usbpcm_urbs_release(cap_subs2);
+		}
+	} else {
+		snd_usX2Y_substream_t *playback_subs = subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];
+		if (atomic_read(&playback_subs->state) < state_PREPARED) {
+			atomic_set(&subs->state, state_STOPPED);
+			if (NULL != cap_subs2)
+				atomic_set(&cap_subs2->state, state_STOPPED);
+			usX2Y_usbpcm_urbs_release(subs);
+			if (NULL != cap_subs2)
+				usX2Y_usbpcm_urbs_release(cap_subs2);
+		}
+	}
+	up(&subs->usX2Y->prepare_mutex);
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static void usX2Y_usbpcm_subs_startup(snd_usX2Y_substream_t *subs)
+{
+	usX2Ydev_t * usX2Y = subs->usX2Y;
+	usX2Y->prepare_subs = subs;
+	subs->urb[0]->start_frame = -1;
+	smp_wmb();	// Make shure above modifications are seen by i_usX2Y_subs_startup()
+	usX2Y_urbs_set_complete(usX2Y, i_usX2Y_usbpcm_subs_startup);
+}
+
+static int usX2Y_usbpcm_urbs_start(snd_usX2Y_substream_t *subs)
+{
+	int	p, u, err,
+		stream = subs->pcm_substream->stream;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+
+	if (SNDRV_PCM_STREAM_CAPTURE == stream) {
+		usX2Y->hwdep_pcm_shm->captured_iso_head = -1;
+		usX2Y->hwdep_pcm_shm->captured_iso_frames = 0;
+	}
+
+	for (p = 0; 3 >= (stream + p); p += 2) {
+		snd_usX2Y_substream_t *subs = usX2Y->subs[stream + p];
+		if (subs != NULL) {
+			if ((err = usX2Y_usbpcm_urbs_allocate(subs)) < 0)
+				return err;
+			subs->completed_urb = NULL;
+		}
+	}
+
+	for (p = 0; p < 4; p++) {
+		snd_usX2Y_substream_t *subs = usX2Y->subs[p];
+		if (subs != NULL && atomic_read(&subs->state) >= state_PREPARED)
+			goto start;
+	}
+	usX2Y->wait_iso_frame = -1;
+
+ start:
+	usX2Y_usbpcm_subs_startup(subs);
+	for (u = 0; u < NRURBS; u++) {
+		for (p = 0; 3 >= (stream + p); p += 2) {
+			snd_usX2Y_substream_t *subs = usX2Y->subs[stream + p];
+			if (subs != NULL) {
+				struct urb *urb = subs->urb[u];
+				if (usb_pipein(urb->pipe)) {
+					unsigned long pack;
+					if (0 == u)
+						atomic_set(&subs->state, state_STARTING3);
+					urb->dev = usX2Y->chip.dev;
+					urb->transfer_flags = URB_ISO_ASAP;
+					for (pack = 0; pack < nr_of_packs(); pack++) {
+						urb->iso_frame_desc[pack].offset = subs->maxpacksize * (pack + u * nr_of_packs());
+						urb->iso_frame_desc[pack].length = subs->maxpacksize;
+					}
+					urb->transfer_buffer_length = subs->maxpacksize * nr_of_packs(); 
+					if ((err = usb_submit_urb(urb, GFP_KERNEL)) < 0) {
+						snd_printk (KERN_ERR "cannot usb_submit_urb() for urb %d, err = %d\n", u, err);
+						err = -EPIPE;
+						goto cleanup;
+					}  else {
+						snd_printdd("%i\n", urb->start_frame);
+						if (0 > usX2Y->wait_iso_frame)
+							usX2Y->wait_iso_frame = urb->start_frame;
+					}
+					urb->transfer_flags = 0;
+				} else {
+					atomic_set(&subs->state, state_STARTING1);
+					break;
+				}			
+			}
+		}
+	}
+	err = 0;
+	wait_event(usX2Y->prepare_wait_queue, NULL == usX2Y->prepare_subs);
+	if (atomic_read(&subs->state) != state_PREPARED)
+		err = -EPIPE;
+		
+ cleanup:
+	if (err) {
+		usX2Y_subs_startup_finish(usX2Y);	// Call it now
+		usX2Y_clients_stop(usX2Y);		// something is completely wroong > stop evrything			
+	}
+	return err;
+}
+
+/*
+ * prepare callback
+ *
+ * set format and initialize urbs
+ */
+static int snd_usX2Y_usbpcm_prepare(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)runtime->private_data;
+	usX2Ydev_t *usX2Y = subs->usX2Y;
+	snd_usX2Y_substream_t *capsubs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];
+	int err = 0;
+	snd_printdd("snd_usX2Y_pcm_prepare(%p)\n", substream);
+
+	if (NULL == usX2Y->hwdep_pcm_shm) {
+		if (NULL == (usX2Y->hwdep_pcm_shm = snd_malloc_pages(sizeof(snd_usX2Y_hwdep_pcm_shm_t), GFP_KERNEL)))
+			return -ENOMEM;
+		memset(usX2Y->hwdep_pcm_shm, 0, sizeof(snd_usX2Y_hwdep_pcm_shm_t));
+	}
+
+	down(&usX2Y->prepare_mutex);
+	usX2Y_subs_prepare(subs);
+// Start hardware streams
+// SyncStream first....
+	if (atomic_read(&capsubs->state) < state_PREPARED) {
+		if (usX2Y->format != runtime->format)
+			if ((err = usX2Y_format_set(usX2Y, runtime->format)) < 0)
+				goto up_prepare_mutex;
+		if (usX2Y->rate != runtime->rate)
+			if ((err = usX2Y_rate_set(usX2Y, runtime->rate)) < 0)
+				goto up_prepare_mutex;
+		snd_printdd("starting capture pipe for %s\n", subs == capsubs ? "self" : "playpipe");
+		if (0 > (err = usX2Y_usbpcm_urbs_start(capsubs)))
+			goto up_prepare_mutex;
+	}
+
+	if (subs != capsubs) {
+		usX2Y->hwdep_pcm_shm->playback_iso_start = -1;
+		if (atomic_read(&subs->state) < state_PREPARED) {
+			while (usX2Y_iso_frames_per_buffer(runtime, usX2Y) > usX2Y->hwdep_pcm_shm->captured_iso_frames) {
+				signed long timeout;
+				snd_printd("Wait: iso_frames_per_buffer=%i,captured_iso_frames=%i\n", usX2Y_iso_frames_per_buffer(runtime, usX2Y), usX2Y->hwdep_pcm_shm->captured_iso_frames);
+				set_current_state(TASK_INTERRUPTIBLE);
+				timeout = schedule_timeout(HZ/100 + 1);
+				if (signal_pending(current)) {
+					err = -ERESTARTSYS;
+					goto up_prepare_mutex;
+				}
+			} 
+			if (0 > (err = usX2Y_usbpcm_urbs_start(subs)))
+				goto up_prepare_mutex;
+		}
+		snd_printd("Ready: iso_frames_per_buffer=%i,captured_iso_frames=%i\n", usX2Y_iso_frames_per_buffer(runtime, usX2Y), usX2Y->hwdep_pcm_shm->captured_iso_frames);
+	} else
+		usX2Y->hwdep_pcm_shm->capture_iso_start = -1;
+
+ up_prepare_mutex:
+	up(&usX2Y->prepare_mutex);
+	return err;
+}
+
+static snd_pcm_hardware_t snd_usX2Y_4c =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =                 SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
+	.rates =                   SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+	.rate_min =                44100,
+	.rate_max =                48000,
+	.channels_min =            2,
+	.channels_max =            4,
+	.buffer_bytes_max =	(2*128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		1024,
+	.fifo_size =              0
+};
+
+
+
+static int snd_usX2Y_usbpcm_open(snd_pcm_substream_t *substream)
+{
+	snd_usX2Y_substream_t	*subs = ((snd_usX2Y_substream_t **)
+					 snd_pcm_substream_chip(substream))[substream->stream];
+	snd_pcm_runtime_t	*runtime = substream->runtime;
+
+	if (!(subs->usX2Y->chip_status & USX2Y_STAT_CHIP_MMAP_PCM_URBS))
+		return -EBUSY;
+
+	runtime->hw = SNDRV_PCM_STREAM_PLAYBACK == substream->stream ? snd_usX2Y_2c :
+		(subs->usX2Y->subs[3] ? snd_usX2Y_4c : snd_usX2Y_2c);
+	runtime->private_data = subs;
+	subs->pcm_substream = substream;
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME, 1000, 200000);
+	return 0;
+}
+
+
+static int snd_usX2Y_usbpcm_close(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_usX2Y_substream_t *subs = (snd_usX2Y_substream_t *)runtime->private_data;
+	int err = 0;
+	snd_printd("\n");
+	subs->pcm_substream = NULL;
+	return err;
+}
+
+
+static snd_pcm_ops_t snd_usX2Y_usbpcm_ops = 
+{
+	.open =		snd_usX2Y_usbpcm_open,
+	.close =	snd_usX2Y_usbpcm_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_usX2Y_pcm_hw_params,
+	.hw_free =	snd_usX2Y_usbpcm_hw_free,
+	.prepare =	snd_usX2Y_usbpcm_prepare,
+	.trigger =	snd_usX2Y_pcm_trigger,
+	.pointer =	snd_usX2Y_pcm_pointer,
+};
+
+
+static int usX2Y_pcms_lock_check(snd_card_t *card)
+{
+	struct list_head *list;
+	snd_device_t *dev;
+	snd_pcm_t *pcm;
+	int err = 0;
+	list_for_each(list, &card->devices) {
+		dev = snd_device(list);
+		if (dev->type != SNDRV_DEV_PCM)
+			continue;
+		pcm = dev->device_data;
+		down(&pcm->open_mutex);
+	}
+	list_for_each(list, &card->devices) {
+		int s;
+		dev = snd_device(list);
+		if (dev->type != SNDRV_DEV_PCM)
+			continue;
+		pcm = dev->device_data;
+		for (s = 0; s < 2; ++s) {
+			snd_pcm_substream_t *substream;
+			substream = pcm->streams[s].substream;
+			if (substream && substream->open_flag)
+				err = -EBUSY;
+		}
+	}
+	return err;
+}
+
+
+static void usX2Y_pcms_unlock(snd_card_t *card)
+{
+	struct list_head *list;
+	snd_device_t *dev;
+	snd_pcm_t *pcm;
+	list_for_each(list, &card->devices) {
+		dev = snd_device(list);
+		if (dev->type != SNDRV_DEV_PCM)
+			continue;
+		pcm = dev->device_data;
+		up(&pcm->open_mutex);
+	}
+}
+
+
+static int snd_usX2Y_hwdep_pcm_open(snd_hwdep_t *hw, struct file *file)
+{
+	// we need to be the first 
+	snd_card_t *card = hw->card;
+	int err = usX2Y_pcms_lock_check(card);
+	if (0 == err)
+		usX2Y(card)->chip_status |= USX2Y_STAT_CHIP_MMAP_PCM_URBS;
+	usX2Y_pcms_unlock(card);
+	return err;
+}
+
+
+static int snd_usX2Y_hwdep_pcm_release(snd_hwdep_t *hw, struct file *file)
+{
+	snd_card_t *card = hw->card;
+	int err = usX2Y_pcms_lock_check(card);
+	if (0 == err)
+		usX2Y(hw->card)->chip_status &= ~USX2Y_STAT_CHIP_MMAP_PCM_URBS;
+	usX2Y_pcms_unlock(card);
+	return err;
+}
+
+
+static void snd_usX2Y_hwdep_pcm_vm_open(struct vm_area_struct *area)
+{
+}
+
+
+static void snd_usX2Y_hwdep_pcm_vm_close(struct vm_area_struct *area)
+{
+}
+
+
+static struct page * snd_usX2Y_hwdep_pcm_vm_nopage(struct vm_area_struct *area, unsigned long address, int *type)
+{
+	unsigned long offset;
+	struct page *page;
+	void *vaddr;
+
+	offset = area->vm_pgoff << PAGE_SHIFT;
+	offset += address - area->vm_start;
+	snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_OOM);
+	vaddr = (char*)((usX2Ydev_t*)area->vm_private_data)->hwdep_pcm_shm + offset;
+	page = virt_to_page(vaddr);
+
+	if (type)
+		*type = VM_FAULT_MINOR;
+
+	return page;
+}
+
+
+static struct vm_operations_struct snd_usX2Y_hwdep_pcm_vm_ops = {
+	.open = snd_usX2Y_hwdep_pcm_vm_open,
+	.close = snd_usX2Y_hwdep_pcm_vm_close,
+	.nopage = snd_usX2Y_hwdep_pcm_vm_nopage,
+};
+
+
+static int snd_usX2Y_hwdep_pcm_mmap(snd_hwdep_t * hw, struct file *filp, struct vm_area_struct *area)
+{
+	unsigned long	size = (unsigned long)(area->vm_end - area->vm_start);
+	usX2Ydev_t	*usX2Y = (usX2Ydev_t*)hw->private_data;
+
+	if (!(((usX2Ydev_t*)hw->private_data)->chip_status & USX2Y_STAT_CHIP_INIT))
+		return -EBUSY;
+
+	/* if userspace tries to mmap beyond end of our buffer, fail */ 
+	if (size > PAGE_ALIGN(sizeof(snd_usX2Y_hwdep_pcm_shm_t))) {
+		snd_printd("%lu > %lu\n", size, (unsigned long)sizeof(snd_usX2Y_hwdep_pcm_shm_t)); 
+		return -EINVAL;
+	}
+
+	if (!usX2Y->hwdep_pcm_shm) {
+		return -ENODEV;
+	}
+	area->vm_ops = &snd_usX2Y_hwdep_pcm_vm_ops;
+	area->vm_flags |= VM_RESERVED;
+	snd_printd("vm_flags=0x%lX\n", area->vm_flags);
+	area->vm_private_data = hw->private_data;
+	return 0;
+}
+
+
+static void snd_usX2Y_hwdep_pcm_private_free(snd_hwdep_t *hwdep)
+{
+	usX2Ydev_t *usX2Y = (usX2Ydev_t *)hwdep->private_data;
+	if (NULL != usX2Y->hwdep_pcm_shm)
+		snd_free_pages(usX2Y->hwdep_pcm_shm, sizeof(snd_usX2Y_hwdep_pcm_shm_t));
+}
+
+
+static void snd_usX2Y_usbpcm_private_free(snd_pcm_t *pcm)
+{
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+
+int usX2Y_hwdep_pcm_new(snd_card_t* card)
+{
+	int err;
+	snd_hwdep_t *hw;
+	snd_pcm_t *pcm;
+	struct usb_device *dev = usX2Y(card)->chip.dev;
+	if (1 != nr_of_packs())
+		return 0;
+
+	if ((err = snd_hwdep_new(card, SND_USX2Y_USBPCM_ID, 1, &hw)) < 0) {
+		snd_printd("\n");
+		return err;
+	}
+	hw->iface = SNDRV_HWDEP_IFACE_USX2Y_PCM;
+	hw->private_data = usX2Y(card);
+	hw->private_free = snd_usX2Y_hwdep_pcm_private_free;
+	hw->ops.open = snd_usX2Y_hwdep_pcm_open;
+	hw->ops.release = snd_usX2Y_hwdep_pcm_release;
+	hw->ops.mmap = snd_usX2Y_hwdep_pcm_mmap;
+	hw->exclusive = 1;
+	sprintf(hw->name, "/proc/bus/usb/%03d/%03d/hwdeppcm", dev->bus->busnum, dev->devnum);
+
+	err = snd_pcm_new(card, NAME_ALLCAPS" hwdep Audio", 2, 1, 1, &pcm);
+	if (err < 0) {
+		return err;
+	}
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_usX2Y_usbpcm_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_usX2Y_usbpcm_ops);
+
+	pcm->private_data = usX2Y(card)->subs;
+	pcm->private_free = snd_usX2Y_usbpcm_private_free;
+	pcm->info_flags = 0;
+
+	sprintf(pcm->name, NAME_ALLCAPS" hwdep Audio");
+	if (0 > (err = snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream,
+						     SNDRV_DMA_TYPE_CONTINUOUS,
+						     snd_dma_continuous_data(GFP_KERNEL),
+						     64*1024, 128*1024)) ||
+	    0 > (err = snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,
+	    					     SNDRV_DMA_TYPE_CONTINUOUS,
+	    					     snd_dma_continuous_data(GFP_KERNEL),
+						     64*1024, 128*1024))) {
+		snd_usX2Y_usbpcm_private_free(pcm);
+		return err;
+	}
+
+
+	return 0;
+}
+
+#else
+
+int usX2Y_hwdep_pcm_new(snd_card_t* card)
+{
+	return 0;
+}
+
+#endif
diff -uNr a/sound/usb/usx2y/usx2yhwdeppcm.h b/sound/usb/usx2y/usx2yhwdeppcm.h
--- a/sound/usb/usx2y/usx2yhwdeppcm.h	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/usb/usx2y/usx2yhwdeppcm.h	2005-01-14 22:28:12.504457464 +0100
@@ -0,0 +1,21 @@
+#define MAXPACK 50
+#define MAXBUFFERMS 100
+#define MAXSTRIDE 3
+
+#define SSS (((MAXPACK*MAXBUFFERMS*MAXSTRIDE + 4096) / 4096) * 4096)
+struct snd_usX2Y_hwdep_pcm_shm {
+	char playback[SSS];
+	char capture0x8[SSS];
+	char capture0xA[SSS];
+	volatile int playback_iso_head;
+	int playback_iso_start;
+	struct {
+		int	frame,
+			offset,
+			length;
+	} captured_iso[128];
+	volatile int captured_iso_head;
+	volatile unsigned captured_iso_frames;
+	int capture_iso_start;
+};
+typedef struct snd_usX2Y_hwdep_pcm_shm snd_usX2Y_hwdep_pcm_shm_t;
