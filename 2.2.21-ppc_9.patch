diff -urN linux.orig/arch/ppc/boot/Makefile linux/arch/ppc/boot/Makefile
--- linux.orig/arch/ppc/boot/Makefile	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/boot/Makefile	Thu Jul 11 15:43:29 2002
@@ -9,6 +9,7 @@
 # Adapted for PowerPC by Gary Thomas
 # modified by Cort (cort@cs.nmt.edu)
 #
+#
 .c.s:
 	$(CC) $(CFLAGS) -I$(HPATH) -S -o $*.s $<
 .s.o:
@@ -69,7 +70,7 @@
 zvmlinux.initrd: zvmlinux
 	$(LD) $(ZLINKFLAGS) -o zvmlinux.initrd.tmp $(OBJECTS)
 	$(OBJCOPY) $(OBJCOPY_ARGS) -R .comment \
-		--add-section=initrd=../coffboot/ramdisk.image.gz \
+		--add-section=initrd=ramdisk.image.gz \
 		--add-section=image=../coffboot/vmlinux.gz \
 		zvmlinux.initrd.tmp zvmlinux.initrd
 	$(CC) $(CFLAGS) -DINITRD_OFFSET=`sh offset $(OBJDUMP) zvmlinux.initrd initrd` \
@@ -79,7 +80,7 @@
 		-c -o misc.o misc.c
 	$(LD) $(ZLINKFLAGS) -o zvmlinux.initrd.tmp $(OBJECTS)
 	$(OBJCOPY) $(OBJCOPY_ARGS) -R .comment \
-		--add-section=initrd=../coffboot/ramdisk.image.gz \
+		--add-section=initrd=ramdisk.image.gz \
 		--add-section=image=../coffboot/vmlinux.gz \
 		zvmlinux.initrd.tmp $@
 	rm zvmlinux.initrd.tmp
diff -urN linux.orig/arch/ppc/boot/vreset.c linux/arch/ppc/boot/vreset.c
--- linux.orig/arch/ppc/boot/vreset.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/boot/vreset.c	Thu Jul 11 15:43:29 2002
@@ -15,7 +15,7 @@
  * Adapted for IBM portables by:
  *                                      Takeshi Ishimoto
  * Multi-console support:
- *                                      Terje Malmedal <terje.malmedal@usit.uio.no>
+ *
  */
 
 #include "iso_font.h"
diff -urN linux.orig/arch/ppc/chrpboot/main.c linux/arch/ppc/chrpboot/main.c
--- linux.orig/arch/ppc/chrpboot/main.c	Sun Mar 25 18:31:50 2001
+++ linux/arch/ppc/chrpboot/main.c	Thu Jul 11 15:43:29 2002
@@ -17,16 +17,15 @@
 #define get_32be(x)	(*(unsigned *)(x))
 
 #define RAM_START	0x00000000
-#define RAM_END		(64<<20)
+#define RAM_END		(8<<20)
 
-#define BOOT_START	((unsigned long)_start)
-#define BOOT_END	((unsigned long)(_end + 0xFFF) & ~0xFFF)
+#define RAM_FREE	((unsigned long)(_end+0x1000)&~0xFFF)
 #define PROG_START	0x00010000
 
 char *avail_ram;
 char *end_avail;
 
-extern char _start[], _end[];
+extern char _end[];
 extern char image_data[];
 extern int image_len;
 extern char initrd_data[];
@@ -40,31 +39,26 @@
     void *dst;
     unsigned char *im;
     unsigned initrd_start, initrd_size;
-
-    printf("chrpboot starting: loaded at 0x%x\n\r", _start);
+    extern char _start;
+    
+    printf("chrpboot starting: loaded at 0x%x\n\r", &_start);
 
     if (initrd_len) {
 	initrd_size = initrd_len;
 	initrd_start = (RAM_END - initrd_size) & ~0xFFF;
 	a1 = initrd_start;
 	a2 = initrd_size;
-	claim(initrd_start, RAM_END - initrd_start, 0);
-	printf("initial ramdisk moving 0x%x <- 0x%x (%x bytes)\n",
-	       initrd_start, initrd_data, initrd_size);
+	printf("initial ramdisk moving 0x%x <- 0x%x (%x bytes)\n\r", initrd_start,
+	       initrd_data,initrd_size);
 	memcpy((char *)initrd_start, initrd_data, initrd_size);
-    }
+	end_avail = (char *)initrd_start;
+    } else
+	end_avail = (char *) RAM_END;
     im = image_data;
     len = image_len;
-    /* try and claim our text/data in case of OF bugs */
-    claim(BOOT_START, BOOT_END - BOOT_START, 0);
-    /* claim 4MB starting at PROG_START */
-    claim(PROG_START, (4<<20) - PROG_START, 0);
     dst = (void *) PROG_START;
     if (im[0] == 0x1f && im[1] == 0x8b) {
-	/* claim 512kB for scratch space */
-	avail_ram = (char *) claim(0, 512 << 10, 0x10);
-	end_avail = avail_ram + (512 << 10);
-	printf("avail_ram = %x\n", avail_ram);
+	avail_ram = (char *)RAM_FREE;
 	printf("gunzipping (0x%x <- 0x%x:0x%0x)...", dst, im, im+len);
 	gunzip(dst, 0x400000, im, &len);
 	printf("done %u bytes\n\r", len);
diff -urN linux.orig/arch/ppc/chrpboot/misc.S linux/arch/ppc/chrpboot/misc.S
--- linux.orig/arch/ppc/chrpboot/misc.S	Sun Mar 25 18:31:50 2001
+++ linux/arch/ppc/chrpboot/misc.S	Thu Jul 11 15:43:29 2002
@@ -9,7 +9,7 @@
 	.text
 
 /*
- * Use the BAT0 registers to map the 1st 8 or 64MB of RAM to 0x90000000.
+ * Use the BAT0 registers to map the 1st 8MB of RAM to 0x90000000.
  */
 	.globl	setup_bats
 setup_bats:
@@ -21,7 +21,7 @@
 	ori	4,4,4			/* set up BAT registers for 601 */
 	li	5,0x7f
 	b	5f
-4:	ori	4,4,0x7ff		/* set up BAT registers for 604 */
+4:	ori	4,4,0xff		/* set up BAT registers for 604 */
 	li	5,2
 	mtdbatu	3,4
 	mtdbatl	3,5
diff -urN linux.orig/arch/ppc/chrpboot/start.c linux/arch/ppc/chrpboot/start.c
--- linux.orig/arch/ppc/chrpboot/start.c	Sun Mar 25 18:31:50 2001
+++ linux/arch/ppc/chrpboot/start.c	Thu Jul 11 15:43:29 2002
@@ -131,29 +131,6 @@
     return args.phandle;
 }
 
-void *
-claim(unsigned int virt, unsigned int size, unsigned int align)
-{
-    struct prom_args {
-	char *service;
-	int nargs;
-	int nret;
-	unsigned int virt;
-	unsigned int size;
-	unsigned int align;
-	void *ret;
-    } args;
-
-    args.service = "claim";
-    args.nargs = 3;
-    args.nret = 1;
-    args.virt = virt;
-    args.size = size;
-    args.align = align;
-    (*prom)(&args);
-    return args.ret;
-}
-
 int
 getprop(void *phandle, const char *name, void *buf, int buflen)
 {
diff -urN linux.orig/arch/ppc/coffboot/Makefile linux/arch/ppc/coffboot/Makefile
--- linux.orig/arch/ppc/coffboot/Makefile	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/Makefile	Thu Jul 11 15:43:29 2002
@@ -9,13 +9,12 @@
 LD	= $(CROSS_COMPILE)ld
 CFLAGS	= $(CPPFLAGS) -O -fno-builtin -I$(HPATH)
 OBJCOPY = $(CROSS_COMPILE)objcopy
-OBJCOPY_ARGS = -O aixcoff-rs6000 -R .stab -R .stabstr -R .comment
-COFF_LD_ARGS = -e _start -T ld.script -Ttext 500000 -Tdata 510000 -Bstatic
-CHRP_LD_ARGS = -Ttext 0x01000000
+OBJCOPY_ARGS = -O aixcoff-rs6000 -R .stab -R .stabstr -R .comment \
+	--add-section=image=vmlinux.gz
+LD_ARGS = -e _start -T ld.script -Ttext 500000 -Tdata 510000 -Bstatic
 GZ = gzip -9
 
-COFFOBJS = coffcrt0.o start.o coffmain.o misc.o string.o zlib.o image.o
-CHRPOBJS = crt0.o start.o chrpmain.o misc.o string.o zlib.o image.o
+OBJS = crt0.o start.o main.o misc.o string.o zlib.o
 LIBS = $(TOPDIR)/lib/lib.a
 
 ifeq ($(CONFIG_PPC64),y)
@@ -34,81 +33,39 @@
 hack-coff: hack-coff.c
 	$(HOSTCC) $(HOSTCFLAGS) -o hack-coff hack-coff.c
 
-znetboot: vmlinux.coff zImage vmlinux.elf
-	cp vmlinux.coff $(TFTPIMAGE)
-	cp vmlinux.elf $(TFTPIMAGE).elf
-
-znetboot.initrd: vmlinux.coff.initrd vmlinux.elf.initrd
-	cp vmlinux.coff.initrd $(TFTPIMAGE)
-	cp vmlinux.elf.initrd $(TFTPIMAGE).elf
-
 floppy: zImage
 #	mount -t hfs /dev/fd0 /mnt
 #	cp vmlinux.coff /mnt
 #	umount /mnt
 
-coffboot: $(COFFOBJS) no_initrd.o ld.script
-	$(LD) -o $@ $(COFF_LD_ARGS) $(COFFOBJS) no_initrd.o $(LIBS)
-
-coffboot.initrd: $(COFFOBJS) initrd.o ld.script
-	$(LD) -o $@ $(COFF_LD_ARGS) $(COFFOBJS) initrd.o $(LIBS)
+znetboot: vmlinux.coff
+	cp vmlinux.coff $(TFTPIMAGE)
 
-piggyback: piggyback.c
-	$(HOSTCC) $(HOSTCFLAGS) -DKERNELBASE=$(KERNELBASE) -o piggyback piggyback.c
+znetboot.initrd: vmlinux.coff.initrd
+	cp vmlinux.coff.initrd $(TFTPIMAGE)
 
-mknote: mknote.c
-	$(HOSTCC) $(HOSTCFLAGS) -o mknote mknote.c
+coffboot: $(OBJS) ld.script
+	$(LD) -o coffboot $(LD_ARGS) $(OBJS) $(LIBS)
 
-image.o: piggyback vmlinux.gz
-	./piggyback image < vmlinux.gz | $(AS) -o image.o
+zImage: vmlinux.coff
 
-initrd.o: ramdisk.image.gz piggyback
-	./piggyback initrd < ramdisk.image.gz | $(AS) -o initrd.o
+zImage.initrd: vmlinux.coff.initrd
 
-vmlinux.coff: coffboot hack-coff
+vmlinux.coff: coffboot hack-coff vmlinux.gz
 	$(OBJCOPY) $(OBJCOPY_ARGS) coffboot $@
 	./hack-coff $@
 	ln -sf vmlinux.coff zImage
 
-vmlinux.coff.initrd: coffboot.initrd hack-coff
-	$(OBJCOPY) $(OBJCOPY_ARGS) coffboot.initrd $@
+vmlinux.coff.initrd: coffboot hack-coff vmlinux.gz ramdisk.image.gz
+	$(OBJCOPY) $(OBJCOPY_ARGS) --add-section=initrd=ramdisk.image.gz \
+		coffboot $@
 	./hack-coff $@
 
-vmlinux.elf: $(CHRPOBJS) no_initrd.o mknote
-	$(LD) $(CHRP_LD_ARGS) -o $@ $(CHRPOBJS) no_initrd.o $(LIBS)
-	./mknote > note
-	$(OBJCOPY) $@ $@ --add-section=.note=note -R .comment
-
-vmlinux.elf.initrd: $(CHRPOBJS) initrd.o mknote
-	$(LD) $(CHRP_LD_ARGS) -o $@ $(CHRPOBJS) initrd.o $(LIBS)
-	./mknote > note
-	$(OBJCOPY) $@ $@ --add-section=.note=note -R .comment
-
-micoffboot: dummy.o
-	$(LD) -o $@ $(COFF_LD_ARGS) dummy.o $(LIBS)
-
-miboot.image: micoffboot hack-coff vmlinux.gz
-	$(OBJCOPY) $(OBJCOPY_ARGS) --add-section=image=vmlinux.gz micoffboot $@
-	./hack-coff $@
-
-miboot.image.initrd: micoffboot hack-coff vmlinux.gz ramdisk.image.gz
-	$(OBJCOPY) $(OBJCOPY_ARGS) --add-section=image=vmlinux.gz \
-	--add-section=initrd=ramdisk.image.gz micoffboot $@
-	./hack-coff $@
-
-zImage: vmlinux.coff vmlinux.elf miboot.image
-
-zImage.initrd: vmlinux.coff.initrd vmlinux.elf.initrd miboot.image.initrd
-
 else
 znetboot: vmlinux.gz
 
 znetboot.initrd: vmlinux.gz
 
-miboot.image: vmlinux.gz
-
-miboot.image.initrd: vmlinux.gz
-
 coffboot: vmlinux.gz
 
 zImage: vmlinux.gz
@@ -129,7 +86,5 @@
 
 clean:
 	rm -f hack-coff coffboot zImage vmlinux.coff vmlinux.gz
-	rm -f mknote piggyback vmlinux.elf note
-	rm -f micoffboot miboot.image
 
 fastdep:
diff -urN linux.orig/arch/ppc/coffboot/chrpmain.c linux/arch/ppc/coffboot/chrpmain.c
--- linux.orig/arch/ppc/coffboot/chrpmain.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/chrpmain.c	Thu Jan  1 01:00:00 1970
@@ -1,252 +0,0 @@
-/*
- * Copyright (C) Paul Mackerras 1997.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- */
-#include "nonstdio.h"
-#include "zlib.h"
-
-extern void *finddevice(const char *);
-extern int getprop(void *, const char *, void *, int);
-void gunzip(void *, int, unsigned char *, int *);
-void stop_imac_ethernet(void);
-void stop_imac_usb(void);
-
-#define get_16be(x)	(*(unsigned short *)(x))
-#define get_32be(x)	(*(unsigned *)(x))
-
-#define RAM_END		(16 << 20)
-
-#define PROG_START	0x00010000
-#define PROG_SIZE	0x003f0000
-
-#define SCRATCH_SIZE	(128 << 10)
-
-char *avail_ram;
-char *begin_avail, *end_avail;
-char *avail_high;
-unsigned int heap_use;
-unsigned int heap_max;
-
-extern char _end[];
-extern char image_data[];
-extern int image_len;
-extern char initrd_data[];
-extern int initrd_len;
-
-
-boot(int a1, int a2, void *prom)
-{
-    int ns, oh, i;
-    unsigned sa, len;
-    void *dst;
-    unsigned char *im;
-    unsigned initrd_start, initrd_size;
-    extern char _start;
-    
-    printf("chrpboot starting: loaded at 0x%x\n", &_start);
-    if (initrd_len) {
-	initrd_size = initrd_len;
-	initrd_start = (RAM_END - initrd_size) & ~0xFFF;
-	a1 = initrd_start;
-	a2 = initrd_size;
-	claim(initrd_start, RAM_END - initrd_start, 0);
-	printf("initial ramdisk moving 0x%x <- 0x%x (%x bytes)\n",
-	       initrd_start, initrd_data, initrd_size);
-	memcpy((char *)initrd_start, initrd_data, initrd_size);
-    }
-    im = image_data;
-    len = image_len;
-    /* claim 3MB starting at PROG_START */
-    claim(PROG_START, PROG_SIZE, 0);
-    dst = (void *) PROG_START;
-    if (im[0] == 0x1f && im[1] == 0x8b) {
-	/* claim some memory for scratch space */
-	avail_ram = (char *) claim(0, SCRATCH_SIZE, 0x10);
-	begin_avail = avail_high = avail_ram;
-	end_avail = avail_ram + SCRATCH_SIZE;
-	printf("heap at 0x%x\n", avail_ram);
-	printf("gunzipping (0x%x <- 0x%x:0x%0x)...", dst, im, im+len);
-	gunzip(dst, PROG_SIZE, im, &len);
-	printf("done %u bytes\n", len);
-	printf("%u bytes of heap consumed, max in use %u\n",
-	       avail_high - begin_avail, heap_max);
-    } else {
-	memmove(dst, im, len);
-    }
-
-    flush_cache(dst, len);
-#if 0
-    stop_imac_ethernet();
-    stop_imac_usb();
-#endif
-
-    sa = (unsigned long)PROG_START;
-    printf("start address = 0x%x\n", sa);
-
-    (*(void (*)())sa)(a1, a2, prom);
-
-    printf("returned?\n");
-
-    pause();
-}
-
-#if 0
-#define eieio()	asm volatile("eieio");
-
-void stop_imac_ethernet(void)
-{
-    void *macio, *enet;
-    unsigned int macio_addr[5], enet_reg[6];
-    int len;
-    volatile unsigned int *dbdma;
-
-    macio = finddevice("/pci/mac-io");
-    enet = finddevice("/pci/mac-io/ethernet");
-    if (macio == NULL || enet == NULL)
-	return;
-    len = getprop(macio, "assigned-addresses", macio_addr, sizeof(macio_addr));
-    if (len != sizeof(macio_addr))
-	return;
-    len = getprop(enet, "reg", enet_reg, sizeof(enet_reg));
-    if (len != sizeof(enet_reg))
-	return;
-    printf("macio base %x, dma at %x & %x\n",
-	   macio_addr[2], enet_reg[2], enet_reg[4]);
-
-    /* hope this is mapped... */
-    dbdma = (volatile unsigned int *) (macio_addr[2] + enet_reg[2]);
-    *dbdma = 0x80;	/* clear the RUN bit */
-    eieio();
-    dbdma = (volatile unsigned int *) (macio_addr[2] + enet_reg[4]);
-    *dbdma = 0x80;	/* clear the RUN bit */
-    eieio();
-}
-
-void stop_imac_usb(void)
-{
-    void *usb;
-    unsigned int usb_addr[5];
-    int len;
-    volatile unsigned int *usb_ctrl;
-
-    usb = finddevice("/pci/usb");
-    if (usb == NULL)
-	return;
-    len = getprop(usb, "assigned-addresses", usb_addr, sizeof(usb_addr));
-    if (len != sizeof(usb_addr))
-	return;
-    printf("usb base %x\n", usb_addr[2]);
-
-    usb_ctrl = (volatile unsigned int *) (usb_addr[2] + 8);
-    *usb_ctrl = 0x01000000;	/* cpu_to_le32(1) */
-    eieio();
-}
-#endif
-
-struct memchunk {
-    unsigned int size;
-    struct memchunk *next;
-};
-
-static struct memchunk *freechunks;
-
-void *zalloc(void *x, unsigned items, unsigned size)
-{
-    void *p;
-    struct memchunk **mpp, *mp;
-
-    size *= items;
-    size = (size + 7) & -8;
-    heap_use += size;
-    if (heap_use > heap_max)
-	heap_max = heap_use;
-    for (mpp = &freechunks; (mp = *mpp) != 0; mpp = &mp->next) {
-	if (mp->size == size) {
-	    *mpp = mp->next;
-	    return mp;
-	}
-    }
-    p = avail_ram;
-    avail_ram += size;
-    if (avail_ram > avail_high)
-	avail_high = avail_ram;
-    if (avail_ram > end_avail) {
-	printf("oops... out of memory\n");
-	pause();
-    }
-    return p;
-}
-
-void zfree(void *x, void *addr, unsigned nb)
-{
-    struct memchunk *mp = addr;
-
-    nb = (nb + 7) & -8;
-    heap_use -= nb;
-    if (avail_ram == addr + nb) {
-	avail_ram = addr;
-	return;
-    }
-    mp->size = nb;
-    mp->next = freechunks;
-    freechunks = mp;
-}
-
-#define HEAD_CRC	2
-#define EXTRA_FIELD	4
-#define ORIG_NAME	8
-#define COMMENT		0x10
-#define RESERVED	0xe0
-
-#define DEFLATED	8
-
-void gunzip(void *dst, int dstlen, unsigned char *src, int *lenp)
-{
-    z_stream s;
-    int r, i, flags;
-
-    /* skip header */
-    i = 10;
-    flags = src[3];
-    if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
-	printf("bad gzipped data\n");
-	exit();
-    }
-    if ((flags & EXTRA_FIELD) != 0)
-	i = 12 + src[10] + (src[11] << 8);
-    if ((flags & ORIG_NAME) != 0)
-	while (src[i++] != 0)
-	    ;
-    if ((flags & COMMENT) != 0)
-	while (src[i++] != 0)
-	    ;
-    if ((flags & HEAD_CRC) != 0)
-	i += 2;
-    if (i >= *lenp) {
-	printf("gunzip: ran out of data in header\n");
-	exit();
-    }
-
-    s.zalloc = zalloc;
-    s.zfree = zfree;
-    r = inflateInit2(&s, -MAX_WBITS);
-    if (r != Z_OK) {
-	printf("inflateInit2 returned %d\n", r);
-	exit();
-    }
-    s.next_in = src + i;
-    s.avail_in = *lenp - i;
-    s.next_out = dst;
-    s.avail_out = dstlen;
-    r = inflate(&s, Z_FINISH);
-    if (r != Z_OK && r != Z_STREAM_END) {
-	printf("inflate returned %d msg: %s\n", r, s.msg);
-	exit();
-    }
-    *lenp = s.next_out - (unsigned char *) dst;
-    inflateEnd(&s);
-}
diff -urN linux.orig/arch/ppc/coffboot/coffcrt0.S linux/arch/ppc/coffboot/coffcrt0.S
--- linux.orig/arch/ppc/coffboot/coffcrt0.S	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/coffcrt0.S	Thu Jan  1 01:00:00 1970
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) Paul Mackerras 1997.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- */
-	.text
-	.globl	_start
-_start:
-	.long	__start,0,0
-
-	.globl	__start
-__start:
-	lis	9,_start@h
-	lis	8,_etext@ha
-	addi	8,8,_etext@l
-1:	dcbf	0,9
-	icbi	0,9
-	addi	9,9,0x20
-	cmplwi	0,9,8
-	blt	1b
-	b	start
diff -urN linux.orig/arch/ppc/coffboot/coffmain.c linux/arch/ppc/coffboot/coffmain.c
--- linux.orig/arch/ppc/coffboot/coffmain.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/coffmain.c	Thu Jan  1 01:00:00 1970
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) Paul Mackerras 1997.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- */
-#include "nonstdio.h"
-#include "zlib.h"
-
-extern void *finddevice(const char *);
-extern int getprop(void *, const char *, void *, int);
-extern char *claim(unsigned, unsigned, unsigned);
-void gunzip(void *, int, unsigned char *, int *);
-
-#define get_16be(x)	(*(unsigned short *)(x))
-#define get_32be(x)	(*(unsigned *)(x))
-
-#define RAM_START	0xc0000000
-#define PROG_START	RAM_START
-#define RAM_END		(RAM_START + 0x800000)	/* only 8M mapped with BATs */
-
-char *avail_ram;
-char *end_avail;
-
-extern char _start[], _end[];
-extern char image_data[];
-extern int image_len;
-extern char initrd_data[];
-extern int initrd_len;
-
-
-boot(int a1, int a2, void *prom)
-{
-    int ns, oh, i;
-    unsigned sa, len;
-    void *dst;
-    unsigned char *im;
-    unsigned initrd_start, initrd_size;
-    
-    printf("coffboot starting: loaded at 0x%x\n", _start);
-    setup_bats(RAM_START);
-    if (initrd_len) {
-	initrd_size = initrd_len;
-	initrd_start = (RAM_END - initrd_size) & ~0xFFF;
-	a1 = initrd_start;
-	a2 = initrd_size;
-	claim(initrd_start - RAM_START, RAM_END - initrd_start, 0);
-	printf("initial ramdisk moving 0x%x <- 0x%x (%x bytes)\n",
-	       initrd_start, initrd_data, initrd_size);
-	memcpy((char *)initrd_start, initrd_data, initrd_size);
-    }
-    im = image_data;
-    len = image_len;
-    /* claim 3MB starting at 0 */
-    claim(0, 3 << 20, 0);
-    dst = (void *) RAM_START;
-    if (im[0] == 0x1f && im[1] == 0x8b) {
-	/* claim 512kB for scratch space */
-	avail_ram = claim(0, 512 << 10, 0x10) + RAM_START;
-	end_avail = avail_ram + (512 << 10);
-	printf("avail_ram = %x\n", avail_ram);
-	printf("gunzipping (0x%x <- 0x%x:0x%0x)...", dst, im, im+len);
-	gunzip(dst, 3 << 20, im, &len);
-	printf("done %u bytes\n", len);
-    } else {
-	memmove(dst, im, len);
-    }
-
-    flush_cache(dst, len);
-    
-    sa = (unsigned long)PROG_START;
-    printf("start address = 0x%x\n", sa);
-
-#if 0
-    pause();
-#endif
-    (*(void (*)())sa)(a1, a2, prom);
-
-    printf("returned?\n");
-
-    pause();
-}
-
-void *zalloc(void *x, unsigned items, unsigned size)
-{
-    void *p = avail_ram;
-
-    size *= items;
-    size = (size + 7) & -8;
-    avail_ram += size;
-    if (avail_ram > end_avail) {
-	printf("oops... out of memory\n");
-	pause();
-    }
-    return p;
-}
-
-void zfree(void *x, void *addr, unsigned nb)
-{
-}
-
-#define HEAD_CRC	2
-#define EXTRA_FIELD	4
-#define ORIG_NAME	8
-#define COMMENT		0x10
-#define RESERVED	0xe0
-
-#define DEFLATED	8
-
-void gunzip(void *dst, int dstlen, unsigned char *src, int *lenp)
-{
-    z_stream s;
-    int r, i, flags;
-
-    /* skip header */
-    i = 10;
-    flags = src[3];
-    if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
-	printf("bad gzipped data\n");
-	exit();
-    }
-    if ((flags & EXTRA_FIELD) != 0)
-	i = 12 + src[10] + (src[11] << 8);
-    if ((flags & ORIG_NAME) != 0)
-	while (src[i++] != 0)
-	    ;
-    if ((flags & COMMENT) != 0)
-	while (src[i++] != 0)
-	    ;
-    if ((flags & HEAD_CRC) != 0)
-	i += 2;
-    if (i >= *lenp) {
-	printf("gunzip: ran out of data in header\n");
-	exit();
-    }
-
-    s.zalloc = zalloc;
-    s.zfree = zfree;
-    r = inflateInit2(&s, -MAX_WBITS);
-    if (r != Z_OK) {
-	printf("inflateInit2 returned %d\n", r);
-	exit();
-    }
-    s.next_in = src + i;
-    s.avail_in = *lenp - i;
-    s.next_out = dst;
-    s.avail_out = dstlen;
-    r = inflate(&s, Z_FINISH);
-    if (r != Z_OK && r != Z_STREAM_END) {
-	printf("inflate returned %d msg: %s\n", r, s.msg);
-	exit();
-    }
-    *lenp = s.next_out - (unsigned char *) dst;
-    inflateEnd(&s);
-}
diff -urN linux.orig/arch/ppc/coffboot/crt0.S linux/arch/ppc/coffboot/crt0.S
--- linux.orig/arch/ppc/coffboot/crt0.S	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/crt0.S	Thu Jul 11 15:43:29 2002
@@ -9,6 +9,10 @@
 	.text
 	.globl	_start
 _start:
+	.long	__start,0,0
+
+	.globl	__start
+__start:
 	lis	9,_start@h
 	lis	8,_etext@ha
 	addi	8,8,_etext@l
diff -urN linux.orig/arch/ppc/coffboot/dummy.c linux/arch/ppc/coffboot/dummy.c
--- linux.orig/arch/ppc/coffboot/dummy.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/dummy.c	Thu Jan  1 01:00:00 1970
@@ -1,4 +0,0 @@
-int main(void)
-{
-	return 0;
-}
diff -urN linux.orig/arch/ppc/coffboot/misc.S linux/arch/ppc/coffboot/misc.S
--- linux.orig/arch/ppc/coffboot/misc.S	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/misc.S	Thu Jul 11 15:43:29 2002
@@ -14,26 +14,23 @@
  */
 	.globl	setup_bats
 setup_bats:
-	mfpvr	5
-	rlwinm	5,5,16,16,31		/* r3 = 1 for 601, 4 for 604 */
-	cmpi	0,5,1
-	li	0,0
+	mr	4,3
+	mfpvr	3
+	rlwinm	3,3,16,16,31		/* r3 = 1 for 601, 4 for 604 */
+	cmpi	0,3,1
 	bne	4f
-	mtibatl	3,0			/* invalidate BAT first */
-	ori	3,3,4			/* set up BAT registers for 601 */
-	li	4,0x7f
-	mtibatu	3,3
-	mtibatl	3,4
-	b	5f
-4:	mtdbatu	3,0			/* invalidate BATs first */
-	mtibatu	3,0
-	ori	3,3,0xff		/* set up BAT registers for 604 */
-	li	4,2
-	mtdbatl	3,4
-	mtdbatu	3,3
-	mtibatl	3,4
-	mtibatu	3,3
-5:	sync
+	ori	4,4,4			/* set up BAT registers for 601 */
+	li	5,0x7f
+	mtibatu	3,4
+	mtibatl	3,5
+	isync
+	blr
+4:	ori	4,4,0xfe		/* set up BAT registers for 604 */
+	li	5,2
+	mtdbatl	3,5
+	mtdbatu	3,4
+	mtibatl	3,5
+	mtibatu	3,4
 	isync
 	blr
 
diff -urN linux.orig/arch/ppc/coffboot/mknote.c linux/arch/ppc/coffboot/mknote.c
--- linux.orig/arch/ppc/coffboot/mknote.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/mknote.c	Thu Jan  1 01:00:00 1970
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) Cort Dougan 1999.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- * Generate a note section as per the CHRP specification.
- *
- */
-
-#include <stdio.h>
-
-#define PL(x) printf("%c%c%c%c", ((x)>>24)&0xff, ((x)>>16)&0xff, ((x)>>8)&0xff, (x)&0xff );
-
-int main(void)
-{
-/* header */
-	/* namesz */
-	PL(strlen("PowerPC")+1);
-	/* descrsz */
-	PL(6*4);
-	/* type */
-	PL(0x1275);
-	/* name */
-	printf("PowerPC"); printf("%c", 0);
-	
-/* descriptor */
-	/* real-mode */
-	PL(0xffffffff);
-	/* real-base */
-	PL(0x00c00000);
-	/* real-size */
-	PL(0xffffffff);
-	/* virt-base */
-	PL(0xffffffff);
-	/* virt-size */
-	PL(0xffffffff);
-	/* load-base */
-	PL(0x4000);
-	return 0;
-}
diff -urN linux.orig/arch/ppc/coffboot/no_initrd.c linux/arch/ppc/coffboot/no_initrd.c
--- linux.orig/arch/ppc/coffboot/no_initrd.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/no_initrd.c	Thu Jan  1 01:00:00 1970
@@ -1,2 +0,0 @@
-char initrd_data[1];
-int initrd_len = 0;
diff -urN linux.orig/arch/ppc/coffboot/piggyback.c linux/arch/ppc/coffboot/piggyback.c
--- linux.orig/arch/ppc/coffboot/piggyback.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/piggyback.c	Thu Jan  1 01:00:00 1970
@@ -1,65 +0,0 @@
-#include <stdio.h>
-
-extern long ce_exec_config[];
-
-main(int argc, char *argv[])
-{
-	int i, cnt, pos, len;
-	unsigned int cksum, val;
-	unsigned char *lp;
-	unsigned char buf[8192];
-	if (argc != 2)
-	{
-		fprintf(stderr, "usage: %s name <in-file >out-file\n",
-			argv[0]);
-		exit(1);
-	}
-	fprintf(stdout, "#\n");
-	fprintf(stdout, "# Miscellaneous data structures:\n");
-	fprintf(stdout, "# WARNING - this file is automatically generated!\n");
-	fprintf(stdout, "#\n");
-	fprintf(stdout, "\n");
-	fprintf(stdout, "\t.data\n");
-	fprintf(stdout, "\t.globl %s_data\n", argv[1]);
-	fprintf(stdout, "%s_data:\n", argv[1]);
-	pos = 0;
-	cksum = 0;
-	while ((len = read(0, buf, sizeof(buf))) > 0)
-	{
-		cnt = 0;
-		lp = (unsigned char *)buf;
-		len = (len + 3) & ~3;  /* Round up to longwords */
-		for (i = 0;  i < len;  i += 4)
-		{
-			if (cnt == 0)
-			{
-				fprintf(stdout, "\t.long\t");
-			}
-			fprintf(stdout, "0x%02X%02X%02X%02X", lp[0], lp[1], lp[2], lp[3]);
-			val = *(unsigned long *)lp;
-			cksum ^= val;
-			lp += 4;
-			if (++cnt == 4)
-			{
-				cnt = 0;
-				fprintf(stdout, " # %x \n", pos+i-12);
-				fflush(stdout);
-			} else
-			{
-				fprintf(stdout, ",");
-			}
-		}
-		if (cnt)
-		{
-			fprintf(stdout, "0\n");
-		}
-		pos += len;
-	}
-	fprintf(stdout, "\t.globl %s_len\n", argv[1]);
-	fprintf(stdout, "%s_len:\t.long\t0x%x\n", argv[1], pos);
-	fflush(stdout);
-	fclose(stdout);
-	fprintf(stderr, "cksum = %x\n", cksum);
-	exit(0);
-}
-
diff -urN linux.orig/arch/ppc/coffboot/start.c linux/arch/ppc/coffboot/start.c
--- linux.orig/arch/ppc/coffboot/start.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/coffboot/start.c	Thu Jul 11 15:43:29 2002
@@ -33,7 +33,7 @@
     if (getprop(chosen_handle, "stdin", &stdin, sizeof(stdin)) != 4)
 	exit();
 
-    boot(a1, a2, promptr);
+    coffboot(a1, a2, promptr);
     for (;;)
 	exit();
 }
@@ -62,25 +62,6 @@
     return args.actual;
 }
 
-int writestring(void *f, char *ptr, int nb)
-{
-	int w = 0, i;
-	char *ret = "\r";
-
-	for (i = 0; i < nb; ++i) {
-		if (ptr[i] == '\n') {
-			if (i > w) {
-				write(f, ptr + w, i - w);
-				w = i;
-			}
-			write(f, ret, 1);
-		}
-	}
-	if (w < nb)
-		write(f, ptr + w, nb - w);
-	return nb;
-}
-
 int
 read(void *handle, void *ptr, int nb)
 {
@@ -149,29 +130,6 @@
     return args.phandle;
 }
 
-void *
-claim(unsigned int virt, unsigned int size, unsigned int align)
-{
-    struct prom_args {
-	char *service;
-	int nargs;
-	int nret;
-	unsigned int virt;
-	unsigned int size;
-	unsigned int align;
-	void *ret;
-    } args;
-
-    args.service = "claim";
-    args.nargs = 3;
-    args.nret = 1;
-    args.virt = virt;
-    args.size = size;
-    args.align = align;
-    (*prom)(&args);
-    return args.ret;
-}
-
 int
 getprop(void *phandle, const char *name, void *buf, int buflen)
 {
@@ -203,7 +161,9 @@
 {
     char ch = c;
 
-    return writestring(f, &ch, 1) == 1? c: -1;
+    if (c == '\n')
+	putc('\r', f);
+    return write(f, &ch, 1) == 1? c: -1;
 }
 
 int
@@ -217,7 +177,7 @@
 {
     int n = strlen(str);
 
-    return writestring(f, str, n) == n? 0: -1;
+    return write(f, str, n) == n? 0: -1;
 }
 
 int
@@ -230,7 +190,7 @@
 	case 1:
 	    return ch;
 	case -1:
-	    printk("read(stdin) returned -1\n");
+	    printk("read(stdin) returned -1\r\n");
 	    return -1;
 	}
     }
@@ -304,7 +264,7 @@
 	va_start(args, fmt);
 	n = vsprintf(sprint_buf, fmt, args);
 	va_end(args);
-	writestring(stdout, sprint_buf, n);
+	write(stdout, sprint_buf, n);
 }
 
 int
@@ -316,6 +276,6 @@
 	va_start(args, fmt);
 	n = vsprintf(sprint_buf, fmt, args);
 	va_end(args);
-	writestring(stdout, sprint_buf, n);
+	write(stdout, sprint_buf, n);
 	return n;
 }
diff -urN linux.orig/arch/ppc/common_defconfig linux/arch/ppc/common_defconfig
--- linux.orig/arch/ppc/common_defconfig	Sun Mar 25 18:31:50 2001
+++ linux/arch/ppc/common_defconfig	Thu Jul 11 15:43:29 2002
@@ -1,5 +1,5 @@
 #
-# Automatically generated make config: don't edit
+# Automatically generated by make menuconfig: don't edit
 #
 
 #
@@ -16,7 +16,6 @@
 # CONFIG_GEMINI is not set
 # CONFIG_MBX is not set
 # CONFIG_SMP is not set
-CONFIG_ALTIVEC=y
 CONFIG_6xx=y
 
 #
@@ -24,7 +23,7 @@
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_MODULES=y
-# CONFIG_MODVERSIONS is not set
+CONFIG_MODVERSIONS=y
 CONFIG_KMOD=y
 CONFIG_PCI=y
 # CONFIG_PCI_QUIRKS is not set
@@ -35,17 +34,17 @@
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_BINFMT_ELF=y
 CONFIG_KERNEL_ELF=y
-CONFIG_BINFMT_MISC=y
+# CONFIG_BINFMT_MISC is not set
 # CONFIG_BINFMT_JAVA is not set
-CONFIG_PARPORT=m
-# CONFIG_PARPORT_PC is not set
+# CONFIG_PARPORT is not set
 CONFIG_VGA_CONSOLE=y
 CONFIG_FB=y
+CONFIG_FB_COMPAT_XPMAC=y
 CONFIG_PMAC_PBOOK=y
 CONFIG_MAC_KEYBOARD=y
 CONFIG_MAC_FLOPPY=y
 CONFIG_MAC_SERIAL=y
-# CONFIG_PPC_RTC is not set
+# CONFIG_SERIAL_CONSOLE is not set
 CONFIG_ADBMOUSE=y
 CONFIG_PROC_DEVICETREE=y
 # CONFIG_TOTALMP is not set
@@ -63,10 +62,6 @@
 #
 CONFIG_BLK_DEV_FD=y
 CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
 # CONFIG_BLK_DEV_HD_IDE is not set
 CONFIG_BLK_DEV_IDEDISK=y
 CONFIG_BLK_DEV_IDECD=y
@@ -75,35 +70,21 @@
 # CONFIG_BLK_DEV_IDESCSI is not set
 # CONFIG_BLK_DEV_CMD640 is not set
 # CONFIG_BLK_DEV_RZ1000 is not set
-CONFIG_BLK_DEV_IDEPCI=y
-CONFIG_BLK_DEV_IDEDMA=y
-# CONFIG_BLK_DEV_OFFBOARD is not set
-CONFIG_IDEDMA_AUTO=y
-# CONFIG_BLK_DEV_OPTI621 is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_VIA82C586 is not set
-CONFIG_BLK_DEV_CMD646=y
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_SL82C105 is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_SL82C105=y
 CONFIG_BLK_DEV_IDE_PMAC=y
 CONFIG_BLK_DEV_IDEDMA_PMAC=y
 CONFIG_BLK_DEV_IDEDMA=y
 CONFIG_PMAC_IDEDMA_AUTO=y
 # CONFIG_IDE_CHIPSETS is not set
-
-#
-# Additional Block Devices
-#
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_MD is not set
 CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
 # CONFIG_BLK_DEV_XD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
-CONFIG_PARIDE_PARPORT=m
+CONFIG_PARIDE_PARPORT=y
 # CONFIG_PARIDE is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -115,44 +96,22 @@
 CONFIG_NETLINK=y
 # CONFIG_RTNETLINK is not set
 # CONFIG_NETLINK_DEV is not set
-CONFIG_FIREWALL=y
+# CONFIG_FIREWALL is not set
 # CONFIG_FILTER is not set
 CONFIG_UNIX=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
 # CONFIG_IP_PNP is not set
-CONFIG_IP_FIREWALL=y
-# CONFIG_IP_FIREWALL_NETLINK is not set
-CONFIG_IP_TRANSPARENT_PROXY=y
-CONFIG_IP_MASQUERADE=y
-
-#
-# Protocol-specific masquerading support will be built as modules.
-#
-# CONFIG_IP_MASQUERADE_ICMP is not set
-
-#
-# Protocol-specific masquerading support will be built as modules.
-#
-# CONFIG_IP_MASQUERADE_MOD is not set
 # CONFIG_IP_ROUTER is not set
 # CONFIG_NET_IPIP is not set
 # CONFIG_NET_IPGRE is not set
 # CONFIG_IP_MROUTE is not set
 CONFIG_IP_ALIAS=y
 CONFIG_SYN_COOKIES=y
-
-#
-# (it is safe to leave these untouched)
-#
 CONFIG_INET_RARP=y
 CONFIG_SKB_LARGE=y
 # CONFIG_IPV6 is not set
-
-#
-#  
-#
 # CONFIG_IPX is not set
 CONFIG_ATALK=m
 # CONFIG_X25 is not set
@@ -174,19 +133,11 @@
 # SCSI support
 #
 CONFIG_SCSI=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
 CONFIG_BLK_DEV_SD=y
 CONFIG_CHR_DEV_ST=y
 CONFIG_BLK_DEV_SR=y
 CONFIG_BLK_DEV_SR_VENDOR=y
-# CONFIG_CHR_DEV_SG is not set
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
+CONFIG_CHR_DEV_SG=y
 # CONFIG_SCSI_MULTI_LUN is not set
 CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
@@ -194,7 +145,6 @@
 #
 # SCSI low-level drivers
 #
-# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
 # CONFIG_SCSI_7000FASST is not set
 # CONFIG_SCSI_ACARD is not set
 # CONFIG_SCSI_AHA152X is not set
@@ -220,13 +170,11 @@
 # CONFIG_SCSI_GENERIC_NCR5380 is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_PPA is not set
-# CONFIG_SCSI_IMM is not set
 # CONFIG_SCSI_NCR53C406A is not set
 # CONFIG_SCSI_SYM53C416 is not set
 # CONFIG_SCSI_SIM710 is not set
 # CONFIG_SCSI_NCR53C7xx is not set
-CONFIG_SCSI_NCR53C8XX=y
+# CONFIG_SCSI_NCR53C8XX is not set
 CONFIG_SCSI_SYM53C8XX=y
 CONFIG_SCSI_NCR53C8XX_DEFAULT_TAGS=8
 CONFIG_SCSI_NCR53C8XX_MAX_TAGS=32
@@ -234,7 +182,7 @@
 # CONFIG_SCSI_NCR53C8XX_PROFILE is not set
 # CONFIG_SCSI_NCR53C8XX_IOMAPPED is not set
 # CONFIG_SCSI_NCR53C8XX_PQS_PDS is not set
-CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT=y
+# CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT is not set
 # CONFIG_SCSI_PAS16 is not set
 # CONFIG_SCSI_PCI2000 is not set
 # CONFIG_SCSI_PCI2220I is not set
@@ -262,7 +210,6 @@
 #
 # CONFIG_ARCNET is not set
 # CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_ETHERTAP is not set
 # CONFIG_NET_SB1000 is not set
@@ -272,25 +219,24 @@
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MACE=y
-# CONFIG_MACE_AAUI_PORT is not set
 CONFIG_BMAC=y
-CONFIG_GMAC=y
 # CONFIG_NCR885E is not set
 # CONFIG_NET_VENDOR_3COM is not set
 # CONFIG_LANCE is not set
 # CONFIG_NET_VENDOR_SMC is not set
 # CONFIG_NET_VENDOR_RACAL is not set
 # CONFIG_RTL8139 is not set
+# CONFIG_YELLOWFIN is not set
 # CONFIG_NET_ISA is not set
 CONFIG_NET_EISA=y
 CONFIG_PCNET32=y
+# CONFIG_ACENIC is not set
 # CONFIG_AC3200 is not set
 # CONFIG_APRICOT is not set
 # CONFIG_CS89x0 is not set
 # CONFIG_DM9102 is not set
 CONFIG_DE4X5=y
 # CONFIG_DEC_ELCP is not set
-# CONFIG_DEC_ELCP_OLD is not set
 # CONFIG_DGRS is not set
 # CONFIG_EEXPRESS_PRO100 is not set
 # CONFIG_LNE390 is not set
@@ -303,14 +249,6 @@
 # CONFIG_EPIC100 is not set
 # CONFIG_ZNET is not set
 # CONFIG_NET_POCKET is not set
-
-#
-# Ethernet (1000 Mbit)
-#
-# CONFIG_ACENIC is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_SK98LIN is not set
 # CONFIG_FDDI is not set
 # CONFIG_HIPPI is not set
 
@@ -320,12 +258,7 @@
 # CONFIG_LTPC is not set
 # CONFIG_COPS is not set
 # CONFIG_IPDDP is not set
-# CONFIG_PLIP is not set
 CONFIG_PPP=y
-
-#
-# CCP compressors for PPP are only built as modules.
-#
 # CONFIG_SLIP is not set
 # CONFIG_NET_RADIO is not set
 
@@ -343,10 +276,7 @@
 # CONFIG_HOSTESS_SV11 is not set
 # CONFIG_COSA is not set
 # CONFIG_SEALEVEL_4021 is not set
-# CONFIG_SYNCLINK_SYNCPPP is not set
-# CONFIG_LANMEDIA is not set
 # CONFIG_COMX is not set
-# CONFIG_HDLC is not set
 # CONFIG_DLCI is not set
 # CONFIG_SBNI is not set
 
@@ -356,11 +286,6 @@
 # CONFIG_HAMRADIO is not set
 
 #
-# IrDA (infrared) support
-#
-# CONFIG_IRDA is not set
-
-#
 # ISDN subsystem
 #
 # CONFIG_ISDN is not set
@@ -375,7 +300,6 @@
 #
 CONFIG_DUMMY_CONSOLE=y
 # CONFIG_FB_PM2 is not set
-CONFIG_FB_ATY=y
 CONFIG_FB_OF=y
 CONFIG_FB_CONTROL=y
 CONFIG_FB_PLATINUM=y
@@ -383,12 +307,12 @@
 CONFIG_FB_IMSTT=y
 CONFIG_FB_CT65550=y
 # CONFIG_FB_S3TRIO is not set
-CONFIG_FB_COMPAT_XPMAC=y
 CONFIG_FB_MATROX=y
-CONFIG_FB_MATROX_MILLENIUM=y
+# CONFIG_FB_MATROX_MILLENIUM is not set
 CONFIG_FB_MATROX_MYSTIQUE=y
 CONFIG_FB_MATROX_G100=y
-CONFIG_FB_MATROX_MULTIHEAD=y
+# CONFIG_FB_MATROX_MULTIHEAD is not set
+CONFIG_FB_ATY=y
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FBCON_ADVANCED is not set
 CONFIG_FBCON_CFB8=y
@@ -415,7 +339,6 @@
 # CONFIG_SERIAL_NONSTANDARD is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
-# CONFIG_PRINTER is not set
 CONFIG_MOUSE=y
 
 #
@@ -427,11 +350,6 @@
 CONFIG_PSMOUSE=y
 # CONFIG_82C710_MOUSE is not set
 # CONFIG_PC110_PAD is not set
-
-#
-# Joysticks
-#
-# CONFIG_JOYSTICK is not set
 # CONFIG_QIC02_TAPE is not set
 # CONFIG_WATCHDOG is not set
 CONFIG_NVRAM=y
@@ -441,16 +359,20 @@
 # Video For Linux
 #
 # CONFIG_VIDEO_DEV is not set
+
+#
+# Joystick support
+#
+# CONFIG_JOYSTICK is not set
 # CONFIG_DTLK is not set
 
 #
 # Ftape, the floppy tape device driver
 #
 # CONFIG_FTAPE is not set
-# CONFIG_TOSHIBA is not set
 
 #
-# Support for USB
+# USB drivers - not for the faint of heart
 #
 # CONFIG_USB is not set
 
@@ -462,10 +384,10 @@
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 CONFIG_HFS_FS=y
-CONFIG_FAT_FS=m
-CONFIG_MSDOS_FS=m
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
 # CONFIG_UMSDOS_FS is not set
-CONFIG_VFAT_FS=m
+CONFIG_VFAT_FS=y
 CONFIG_ISO9660_FS=y
 # CONFIG_JOLIET is not set
 # CONFIG_MINIX_FS is not set
@@ -505,7 +427,6 @@
 #
 # Native Language Support
 #
-CONFIG_NLS_DEFAULT="cp437"
 CONFIG_NLS_CODEPAGE_437=y
 # CONFIG_NLS_CODEPAGE_737 is not set
 # CONFIG_NLS_CODEPAGE_775 is not set
@@ -522,10 +443,6 @@
 # CONFIG_NLS_CODEPAGE_866 is not set
 # CONFIG_NLS_CODEPAGE_869 is not set
 # CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
 # CONFIG_NLS_ISO8859_1 is not set
 # CONFIG_NLS_ISO8859_2 is not set
 # CONFIG_NLS_ISO8859_3 is not set
@@ -536,17 +453,55 @@
 # CONFIG_NLS_ISO8859_8 is not set
 # CONFIG_NLS_ISO8859_9 is not set
 # CONFIG_NLS_ISO8859_14 is not set
-CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_ISO8859_15 is not set
 # CONFIG_NLS_KOI8_R is not set
 
 #
 # Sound
 #
-# CONFIG_SOUND is not set
+CONFIG_SOUND=y
+CONFIG_DMASOUND=y
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+CONFIG_SOUND_OSS=y
+# CONFIG_SOUND_DMAP is not set
+# CONFIG_SOUND_PAS is not set
+# CONFIG_SOUND_SB is not set
+# CONFIG_SOUND_GUS is not set
+# CONFIG_SOUND_MPU401 is not set
+# CONFIG_SOUND_PSS is not set
+# CONFIG_SOUND_MSS is not set
+# CONFIG_SOUND_SSCAPE is not set
+# CONFIG_SOUND_TRIX is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_SOUND_MAD16 is not set
+# CONFIG_SOUND_WAVEFRONT is not set
+CONFIG_SOUND_CS4232=m
+# CONFIG_SOUND_OPL3SA2 is not set
+# CONFIG_SOUND_MAUI is not set
+# CONFIG_SOUND_SGALAXY is not set
+# CONFIG_SOUND_AD1816 is not set
+# CONFIG_SOUND_OPL3SA1 is not set
+# CONFIG_SOUND_SOFTOSS is not set
+# CONFIG_SOUND_YM3812 is not set
+# CONFIG_SOUND_VMIDI is not set
+# CONFIG_SOUND_UART6850 is not set
+# CONFIG_SOUND_NM256 is not set
+
+#
+# Additional low level sound drivers
+#
+# CONFIG_LOWLEVEL_SOUND is not set
 
 #
 # Kernel hacking
 #
-CONFIG_MAGIC_SYSRQ=y
+# CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_KGDB is not set
 # CONFIG_XMON is not set
diff -urN linux.orig/arch/ppc/config.in linux/arch/ppc/config.in
--- linux.orig/arch/ppc/config.in	Fri Nov  2 17:39:05 2001
+++ linux/arch/ppc/config.in	Thu Jul 11 15:43:29 2002
@@ -22,10 +22,6 @@
 
 bool 'Symmetric multi-processing support' CONFIG_SMP
 
-if [ "$CONFIG_6xx" = "y" ]; then
-  bool 'Altivec (G4) support' CONFIG_ALTIVEC
-fi
-
 if [ "$CONFIG_ALL_PPC" != "y" ]; then
   define_bool CONFIG_MACH_SPECIFIC y
 fi
diff -urN linux.orig/arch/ppc/defconfig linux/arch/ppc/defconfig
--- linux.orig/arch/ppc/defconfig	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/defconfig	Thu Jul 11 15:43:29 2002
@@ -1,5 +1,5 @@
 #
-# Automatically generated make config: don't edit
+# Automatically generated by make menuconfig: don't edit
 #
 
 #
@@ -7,16 +7,15 @@
 #
 CONFIG_PPC=y
 CONFIG_6xx=y
-# CONFIG_PPC64 is not set
 # CONFIG_8xx is not set
-CONFIG_PMAC=y
+# CONFIG_PMAC is not set
 # CONFIG_PREP is not set
 # CONFIG_CHRP is not set
-# CONFIG_ALL_PPC is not set
+CONFIG_ALL_PPC=y
 # CONFIG_APUS is not set
+# CONFIG_GEMINI is not set
 # CONFIG_MBX is not set
 # CONFIG_SMP is not set
-CONFIG_MACH_SPECIFIC=y
 CONFIG_6xx=y
 
 #
@@ -24,7 +23,7 @@
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_MODULES=y
-# CONFIG_MODVERSIONS is not set
+CONFIG_MODVERSIONS=y
 CONFIG_KMOD=y
 CONFIG_PCI=y
 # CONFIG_PCI_QUIRKS is not set
@@ -35,11 +34,10 @@
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_BINFMT_ELF=y
 CONFIG_KERNEL_ELF=y
-CONFIG_BINFMT_MISC=m
+# CONFIG_BINFMT_MISC is not set
 # CONFIG_BINFMT_JAVA is not set
-CONFIG_PARPORT=m
-# CONFIG_PARPORT_PC is not set
-# CONFIG_VGA_CONSOLE is not set
+# CONFIG_PARPORT is not set
+CONFIG_VGA_CONSOLE=y
 CONFIG_FB=y
 CONFIG_FB_COMPAT_XPMAC=y
 CONFIG_PMAC_PBOOK=y
@@ -52,6 +50,7 @@
 # CONFIG_TOTALMP is not set
 CONFIG_BOOTX_TEXT=y
 # CONFIG_MOTOROLA_HOTSWAP is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Plug and Play support
@@ -61,12 +60,8 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_FD=y
 CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
 # CONFIG_BLK_DEV_HD_IDE is not set
 CONFIG_BLK_DEV_IDEDISK=y
 CONFIG_BLK_DEV_IDECD=y
@@ -75,25 +70,13 @@
 # CONFIG_BLK_DEV_IDESCSI is not set
 # CONFIG_BLK_DEV_CMD640 is not set
 # CONFIG_BLK_DEV_RZ1000 is not set
-CONFIG_BLK_DEV_IDEPCI=y
-CONFIG_BLK_DEV_IDEDMA=y
-# CONFIG_BLK_DEV_OFFBOARD is not set
-CONFIG_IDEDMA_AUTO=y
-# CONFIG_BLK_DEV_OPTI621 is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_VIA82C586 is not set
-CONFIG_BLK_DEV_CMD646=y
-# CONFIG_BLK_DEV_SL82C105 is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_SL82C105=y
 CONFIG_BLK_DEV_IDE_PMAC=y
 CONFIG_BLK_DEV_IDEDMA_PMAC=y
 CONFIG_BLK_DEV_IDEDMA=y
 CONFIG_PMAC_IDEDMA_AUTO=y
 # CONFIG_IDE_CHIPSETS is not set
-
-#
-# Additional Block Devices
-#
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_MD is not set
@@ -101,7 +84,7 @@
 CONFIG_BLK_DEV_INITRD=y
 # CONFIG_BLK_DEV_XD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
-CONFIG_PARIDE_PARPORT=m
+CONFIG_PARIDE_PARPORT=y
 # CONFIG_PARIDE is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -125,18 +108,10 @@
 # CONFIG_NET_IPGRE is not set
 # CONFIG_IP_MROUTE is not set
 CONFIG_IP_ALIAS=y
-# CONFIG_SYN_COOKIES is not set
-
-#
-# (it is safe to leave these untouched)
-#
+CONFIG_SYN_COOKIES=y
 CONFIG_INET_RARP=y
 CONFIG_SKB_LARGE=y
 # CONFIG_IPV6 is not set
-
-#
-#  
-#
 # CONFIG_IPX is not set
 CONFIG_ATALK=m
 # CONFIG_X25 is not set
@@ -158,19 +133,11 @@
 # SCSI support
 #
 CONFIG_SCSI=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
 CONFIG_BLK_DEV_SD=y
 CONFIG_CHR_DEV_ST=y
 CONFIG_BLK_DEV_SR=y
 CONFIG_BLK_DEV_SR_VENDOR=y
-# CONFIG_CHR_DEV_SG is not set
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
+CONFIG_CHR_DEV_SG=y
 # CONFIG_SCSI_MULTI_LUN is not set
 CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
@@ -188,6 +155,7 @@
 CONFIG_AIC7XXX_CMDS_PER_DEVICE=8
 CONFIG_AIC7XXX_PROC_STATS=y
 CONFIG_AIC7XXX_RESET_DELAY=15
+# CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_IN2000 is not set
 # CONFIG_SCSI_AM53C974 is not set
@@ -202,12 +170,11 @@
 # CONFIG_SCSI_GENERIC_NCR5380 is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_PPA is not set
-# CONFIG_SCSI_IMM is not set
 # CONFIG_SCSI_NCR53C406A is not set
 # CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_SIM710 is not set
 # CONFIG_SCSI_NCR53C7xx is not set
-CONFIG_SCSI_NCR53C8XX=y
+# CONFIG_SCSI_NCR53C8XX is not set
 CONFIG_SCSI_SYM53C8XX=y
 CONFIG_SCSI_NCR53C8XX_DEFAULT_TAGS=8
 CONFIG_SCSI_NCR53C8XX_MAX_TAGS=32
@@ -215,7 +182,7 @@
 # CONFIG_SCSI_NCR53C8XX_PROFILE is not set
 # CONFIG_SCSI_NCR53C8XX_IOMAPPED is not set
 # CONFIG_SCSI_NCR53C8XX_PQS_PDS is not set
-CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT=y
+# CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT is not set
 # CONFIG_SCSI_PAS16 is not set
 # CONFIG_SCSI_PCI2000 is not set
 # CONFIG_SCSI_PCI2220I is not set
@@ -253,21 +220,21 @@
 CONFIG_NET_ETHERNET=y
 CONFIG_MACE=y
 CONFIG_BMAC=y
-CONFIG_GMAC=y
+# CONFIG_NCR885E is not set
 # CONFIG_NET_VENDOR_3COM is not set
 # CONFIG_LANCE is not set
 # CONFIG_NET_VENDOR_SMC is not set
 # CONFIG_NET_VENDOR_RACAL is not set
 # CONFIG_RTL8139 is not set
-# CONFIG_SIS900 is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_NET_ISA is not set
 CONFIG_NET_EISA=y
-# CONFIG_PCNET32 is not set
+CONFIG_PCNET32=y
 # CONFIG_ACENIC is not set
 # CONFIG_AC3200 is not set
 # CONFIG_APRICOT is not set
 # CONFIG_CS89x0 is not set
+# CONFIG_DM9102 is not set
 CONFIG_DE4X5=y
 # CONFIG_DEC_ELCP is not set
 # CONFIG_DGRS is not set
@@ -277,6 +244,7 @@
 # CONFIG_NE2K_PCI is not set
 # CONFIG_TLAN is not set
 # CONFIG_VIA_RHINE is not set
+# CONFIG_SIS900 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_EPIC100 is not set
 # CONFIG_ZNET is not set
@@ -290,12 +258,7 @@
 # CONFIG_LTPC is not set
 # CONFIG_COPS is not set
 # CONFIG_IPDDP is not set
-# CONFIG_PLIP is not set
 CONFIG_PPP=y
-
-#
-# CCP compressors for PPP are only built as modules.
-#
 # CONFIG_SLIP is not set
 # CONFIG_NET_RADIO is not set
 
@@ -313,7 +276,9 @@
 # CONFIG_HOSTESS_SV11 is not set
 # CONFIG_COSA is not set
 # CONFIG_SEALEVEL_4021 is not set
+# CONFIG_COMX is not set
 # CONFIG_DLCI is not set
+# CONFIG_SBNI is not set
 
 #
 # Amateur Radio support
@@ -339,12 +304,14 @@
 CONFIG_FB_CONTROL=y
 CONFIG_FB_PLATINUM=y
 CONFIG_FB_VALKYRIE=y
-CONFIG_FB_ATY=y
-CONFIG_FB_ATY128=y
 CONFIG_FB_IMSTT=y
 CONFIG_FB_CT65550=y
 # CONFIG_FB_S3TRIO is not set
-# CONFIG_FB_MATROX is not set
+CONFIG_FB_MATROX=y
+# CONFIG_FB_MATROX_MILLENIUM is not set
+CONFIG_FB_MATROX_MYSTIQUE=y
+CONFIG_FB_MATROX_G100=y
+# CONFIG_FB_MATROX_MULTIHEAD is not set
 CONFIG_FB_ATY=y
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FBCON_ADVANCED is not set
@@ -367,13 +334,22 @@
 #
 CONFIG_VT=y
 CONFIG_VT_CONSOLE=y
-# CONFIG_SERIAL is not set
+CONFIG_SERIAL=m
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
-# CONFIG_PRINTER is not set
-# CONFIG_MOUSE is not set
+CONFIG_MOUSE=y
+
+#
+# Mice
+#
+# CONFIG_ATIXL_BUSMOUSE is not set
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MS_BUSMOUSE is not set
+CONFIG_PSMOUSE=y
+# CONFIG_82C710_MOUSE is not set
+# CONFIG_PC110_PAD is not set
 # CONFIG_QIC02_TAPE is not set
 # CONFIG_WATCHDOG is not set
 CONFIG_NVRAM=y
@@ -408,10 +384,10 @@
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 CONFIG_HFS_FS=y
-CONFIG_FAT_FS=m
-CONFIG_MSDOS_FS=m
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
 # CONFIG_UMSDOS_FS is not set
-CONFIG_VFAT_FS=m
+CONFIG_VFAT_FS=y
 CONFIG_ISO9660_FS=y
 # CONFIG_JOLIET is not set
 # CONFIG_MINIX_FS is not set
@@ -477,7 +453,7 @@
 # CONFIG_NLS_ISO8859_8 is not set
 # CONFIG_NLS_ISO8859_9 is not set
 # CONFIG_NLS_ISO8859_14 is not set
-CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_ISO8859_15 is not set
 # CONFIG_NLS_KOI8_R is not set
 
 #
@@ -485,13 +461,43 @@
 #
 CONFIG_SOUND=y
 CONFIG_DMASOUND=y
+# CONFIG_SOUND_CMPCI is not set
 # CONFIG_SOUND_ES1370 is not set
 # CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_MAESTRO is not set
 # CONFIG_SOUND_ESSSOLO1 is not set
 # CONFIG_SOUND_SONICVIBES is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
-# CONFIG_SOUND_OSS is not set
+CONFIG_SOUND_OSS=y
+# CONFIG_SOUND_DMAP is not set
+# CONFIG_SOUND_PAS is not set
+# CONFIG_SOUND_SB is not set
+# CONFIG_SOUND_GUS is not set
+# CONFIG_SOUND_MPU401 is not set
+# CONFIG_SOUND_PSS is not set
+# CONFIG_SOUND_MSS is not set
+# CONFIG_SOUND_SSCAPE is not set
+# CONFIG_SOUND_TRIX is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_SOUND_MAD16 is not set
+# CONFIG_SOUND_WAVEFRONT is not set
+CONFIG_SOUND_CS4232=m
+# CONFIG_SOUND_OPL3SA2 is not set
+# CONFIG_SOUND_MAUI is not set
+# CONFIG_SOUND_SGALAXY is not set
+# CONFIG_SOUND_AD1816 is not set
+# CONFIG_SOUND_OPL3SA1 is not set
+# CONFIG_SOUND_SOFTOSS is not set
+# CONFIG_SOUND_YM3812 is not set
+# CONFIG_SOUND_VMIDI is not set
+# CONFIG_SOUND_UART6850 is not set
+# CONFIG_SOUND_NM256 is not set
+
+#
+# Additional low level sound drivers
+#
+# CONFIG_LOWLEVEL_SOUND is not set
 
 #
 # Kernel hacking
diff -urN linux.orig/arch/ppc/kernel/Makefile linux/arch/ppc/kernel/Makefile
--- linux.orig/arch/ppc/kernel/Makefile	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/kernel/Makefile	Thu Jul 11 15:43:29 2002
@@ -7,13 +7,8 @@
 #
 # Note 2! The CFLAGS definitions are now in the main makefile...
 
-# Once a gas that groks -mvec is generally available, we'll use it...
 .S.o:
-#ifdef CONFIG_ALTIVEC
-#	$(CC) $(CFLAGS) -D__ASSEMBLY__ -Wa,-mvec -c $< -o $*.o
-#else
 	$(CC) $(CFLAGS) -D__ASSEMBLY__ -c $< -o $*.o
-#endif
 
 O_TARGET := kernel.o
 OX_OBJS := ppc_ksyms.o setup.o
@@ -36,40 +31,20 @@
 
 ifeq ($(CONFIG_MBX),y)
 O_OBJS += mbx_setup.o mbx_pci.o softemu8xx.o i8259.o ppc8xx_pic.o
-endif
+else
 ifeq ($(CONFIG_APUS),y)
 O_OBJS += apus_setup.o prom.o openpic.o
+else
+ifneq ($(CONFIG_MBX),y)
+O_OBJS += prep_time.o pmac_time.o chrp_time.o \
+	  pmac_setup.o pmac_support.o \
+	  prep_pci.o pmac_pci.o chrp_pci.o \
+	  residual.o prom.o openpic.o feature.o \
+	  prep_nvram.o open_pic.o i8259.o pmac_pic.o indirect_pci.o \
+	  gemini_pci.o gemini_prom.o gemini_setup.o
+OX_OBJS += chrp_setup.o prep_setup.o
+endif
 endif
-
-PMAC_OBJS = pmac_time.o pmac_setup.o pmac_support.o pmac_pci.o pmac_pic.o \
-	feature.o openpic.o open_pic.o prom.o
-CHRP_OBJS = $(PMAC_OBJS) chrp_time.o chrp_pci.o i8259.o indirect_pci.o
-CHRPX_OBJS = chrp_setup.o
-PREP_OBJS = prep_time.o prep_pci.o residual.o prep_nvram.o i8259.o \
-	indirect_pci.o openpic.o open_pic.o prom.o
-PREPX_OBJS = prep_setup.o
-
-ifeq ($(CONFIG_ALL_PPC),y)
-O_OBJS += $(sort $(PMAC_OBJS) $(PREP_OBJS) $(CHRP_OBJS))
-OX_OBJS += $(PMACX_OBJS) $(PREPX_OBJS) $(CHRPX_OBJS)
-endif
-ifeq ($(CONFIG_PMAC),y)
-O_OBJS += $(PMAC_OBJS)
-OX_OBJS += $(PMACX_OBJS)
-endif
-ifeq ($(CONFIG_PREP),y)
-O_OBJS += $(PREP_OBJS)
-OX_OBJS += $(PREPX_OBJS)
-endif
-ifeq ($(CONFIG_CHRP),y)
-O_OBJS += $(CHRP_OBJS)
-OX_OBJS += $(CHRPX_OBJS)
-endif
-
-GEMINI_OBJS = $(PREP_OBJS) gemini_pci.o gemini_prom.o gemini_setup.o
-ifeq ($(CONFIG_GEMINI),y)
-O_OBJS += $(GEMINI_OBJS)
-OX_OBJS += $(PREPX_OBJS)
 endif
 
 ifdef CONFIG_SMP
@@ -87,15 +62,14 @@
 		$(TOPDIR)/include/asm/ptrace.h
 	$(CC) ${CFLAGS} -S mk_defs.c
 	cp ppc_defs.head ppc_defs.h
-	chmod 755 ppc_defs.h
-	grep '^#define' mk_defs.s >> ppc_defs.h
+	grep '^#define' mk_defs.s >>ppc_defs.h
 	rm mk_defs.s
 
 find_name : find_name.c
 	$(HOSTCC) -o find_name find_name.c
 
 checks: checks.c
-	$(HOSTCC) ${CFLAGS} -D__KERNEL__ -I../../../include -o checks checks.c
+	$(HOSTCC) ${CFLAGS} -D__KERNEL__ -o checks checks.c
 	./checks
 
 include $(TOPDIR)/Rules.make
diff -urN linux.orig/arch/ppc/kernel/apus_setup.c linux/arch/ppc/kernel/apus_setup.c
--- linux.orig/arch/ppc/kernel/apus_setup.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/apus_setup.c	Thu Jul 11 15:43:29 2002
@@ -42,7 +42,7 @@
 #include <asm/machdep.h>
 #include <asm/ide.h>
 
-#include <asm/time.h>
+#include "time.h"
 #include "local_irq.h"
 
 unsigned long apus_get_rtc_time(void);
@@ -624,7 +624,7 @@
 	ppc_md.kbd_unexpected_up = NULL;
 	ppc_md.kbd_leds          = NULL;
 	ppc_md.kbd_init_hw       = NULL;
-	ppc_md.sysrq_xlate	 = NULL;
+	ppc_md.kbd_sysrq_xlate	 = NULL;
 
 #if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
         ppc_ide_md.insw = apus_ide_insw;
diff -urN linux.orig/arch/ppc/kernel/checks.c linux/arch/ppc/kernel/checks.c
--- linux.orig/arch/ppc/kernel/checks.c	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/kernel/checks.c	Thu Jul 11 15:43:29 2002
@@ -1,4 +1,3 @@
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
diff -urN linux.orig/arch/ppc/kernel/chrp_pci.c linux/arch/ppc/kernel/chrp_pci.c
--- linux.orig/arch/ppc/kernel/chrp_pci.c	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/kernel/chrp_pci.c	Thu Jul 11 15:43:29 2002
@@ -12,6 +12,7 @@
 #include <asm/io.h>
 #include <asm/pgtable.h>
 #include <asm/irq.h>
+#include <asm/irq-compat.h>
 #include <asm/hydra.h>
 #include <asm/prom.h>
 #include <asm/gg2.h>
@@ -19,7 +20,6 @@
 #include <asm/machdep.h>
 
 #include "pci.h"
-#include "open_pic.h"
 
 /* LongTrail */
 #define pci_config_addr(bus, dev, offset) \
@@ -287,7 +287,7 @@
 	for( dev=pci_devices ; dev; dev=dev->next )
 	{
 		if ( dev->irq )
-			dev->irq = dev->irq + open_pic.irq_offset;
+			dev->irq = openpic_to_irq( dev->irq );
 		/* these need to be absolute addrs for OF and Matrox FB -- Cort */
 		if ( dev->vendor == PCI_VENDOR_ID_MATROX )
 		{
diff -urN linux.orig/arch/ppc/kernel/chrp_setup.c linux/arch/ppc/kernel/chrp_setup.c
--- linux.orig/arch/ppc/kernel/chrp_setup.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/chrp_setup.c	Thu Jul 11 16:22:09 2002
@@ -33,7 +33,6 @@
 #include <linux/pci.h>
 #include <linux/openpic.h>
 #include <linux/version.h>
-#include <linux/delay.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
@@ -46,11 +45,12 @@
 #include <asm/dma.h>
 #include <asm/machdep.h>
 #include <asm/irq.h>
+#include <asm/irq-compat.h>
 #include <asm/adb.h>
 #include <asm/hydra.h>
 #include <asm/keyboard.h>
 
-#include <asm/time.h>
+#include "time.h"
 #include "local_irq.h"
 #include "i8259.h"
 #include "open_pic.h"
@@ -69,7 +69,7 @@
 int chrp_set_rtc_time(unsigned long nowtime);
 unsigned long rtas_event_scan_rate = 0, rtas_event_scan_ct = 0;
 void chrp_calibrate_decr(void);
-long chrp_time_init(void);
+void chrp_time_init(void);
 
 void chrp_setup_pci_ptrs(void);
 
@@ -359,6 +359,81 @@
 	}
 }
 
+void
+chrp_do_IRQ(struct pt_regs *regs,
+	    int            cpu,
+            int            isfake)
+{
+        int irq;
+        unsigned long bits = 0;
+        int openpic_eoi_done = 0;
+
+#ifdef __SMP__
+        {
+                unsigned int loops = 1000000;
+                while (test_bit(0, &global_irq_lock)) {
+                        if (smp_processor_id() == global_irq_holder) {
+                                printk("uh oh, interrupt while we hold global irq lock!\n");
+#ifdef CONFIG_XMON
+                                xmon(0);
+#endif
+                                break;
+                        }
+                        if (loops-- == 0) {
+                                printk("do_IRQ waiting for irq lock (holder=%d)\n", global_irq_holder);
+#ifdef CONFIG_XMON
+                                xmon(0);
+#endif
+                        }
+                }
+        }
+#endif /* __SMP__ */
+	
+        irq = openpic_irq(smp_processor_id());
+        if (irq == IRQ_8259_CASCADE)
+        {
+                /*
+                 * This magic address generates a PCI IACK cycle.
+                 *
+                 * This should go in the above mask/ack code soon. -- Cort
+                 */
+		if ( chrp_int_ack_special )
+			irq = *chrp_int_ack_special;
+		else
+			irq = i8259_irq(0);
+                /*
+                 * Acknowledge as soon as possible to allow i8259
+                 * interrupt nesting                         */
+                openpic_eoi(smp_processor_id());
+                openpic_eoi_done = 1;
+        }
+        if (irq == OPENPIC_VEC_SPURIOUS)
+        {
+                /*
+                 * Spurious interrupts should never be
+                 * acknowledged
+                 */
+                ppc_spurious_interrupts++;
+                openpic_eoi_done = 1;
+		goto out;
+        }
+        bits = 1UL << irq;
+
+        if (irq < 0)
+        {
+                printk(KERN_DEBUG "Bogus interrupt %d from PC = %lx\n",
+                       irq, regs->nip);
+                ppc_spurious_interrupts++;
+        }
+	else
+        {
+		ppc_irq_dispatch_handler( regs, irq );
+	}
+out:
+        if (!openpic_eoi_done)
+                openpic_eoi(smp_processor_id());
+}
+
 __initfunc(void
 	   chrp_init_IRQ(void))
 {
@@ -373,7 +448,7 @@
 			(*(unsigned long *)get_property(np,
 							"8259-interrupt-acknowledge", NULL));
 	}
-	open_pic.irq_offset = NUM_8259_INTERRUPTS;
+	open_pic.irq_offset = 16;
 	for ( i = 16 ; i < NR_IRQS ; i++ )
 		irq_desc[i].ctl = &open_pic;
 	openpic_init(1);
@@ -381,7 +456,7 @@
 		irq_desc[i].ctl = &i8259_pic;
 	i8259_init();
 #ifdef CONFIG_XMON
-	request_irq(HYDRA_INT_ADB_NMI+open_pic.irq_offset,
+	request_irq(openpic_to_irq(HYDRA_INT_ADB_NMI),
 		    xmon_irq, 0, "NMI", 0);
 #endif	/* CONFIG_XMON */
 #ifdef __SMP__
@@ -570,7 +645,7 @@
 	ppc_md.get_cpuinfo    = chrp_get_cpuinfo;
 	ppc_md.irq_cannonicalize = chrp_irq_cannonicalize;
 	ppc_md.init_IRQ       = chrp_init_IRQ;
-	ppc_md.do_IRQ         = open_pic_do_IRQ;
+	ppc_md.do_IRQ         = chrp_do_IRQ;
 		
 	ppc_md.init           = chrp_init2;
 
@@ -612,8 +687,3 @@
 	while ( *s )
 		call_rtas( "display-character", 1, 1, NULL, *s++ );
 }
-
-void chrp_indicator(int x)
-{
-	call_rtas("set-indicator", 3, 1, NULL, 6, 0, x);
-}
diff -urN linux.orig/arch/ppc/kernel/chrp_time.c linux/arch/ppc/kernel/chrp_time.c
--- linux.orig/arch/ppc/kernel/chrp_time.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/chrp_time.c	Thu Jul 11 15:43:29 2002
@@ -25,25 +25,24 @@
 #include <asm/processor.h>
 #include <asm/nvram.h>
 #include <asm/prom.h>
-#include <asm/time.h>
+#include "time.h"
 
 static int nvram_as1 = NVRAM_AS1;
 static int nvram_as0 = NVRAM_AS0;
 static int nvram_data = NVRAM_DATA;
 
-__initfunc(long chrp_time_init(void))
+__initfunc(void chrp_time_init(void))
 {
 	struct device_node *rtcs;
 	int base;
 
 	rtcs = find_compatible_devices("rtc", "pnpPNP,b00");
 	if (rtcs == NULL || rtcs->addrs == NULL)
-		return 0;
+		return;
 	base = rtcs->addrs[0].address;
 	nvram_as1 = 0;
 	nvram_as0 = base;
 	nvram_data = base + 1;
-	return 0;
 }
 
 int chrp_cmos_clock_read(int addr)
diff -urN linux.orig/arch/ppc/kernel/gemini_setup.c linux/arch/ppc/kernel/gemini_setup.c
--- linux.orig/arch/ppc/kernel/gemini_setup.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/gemini_setup.c	Thu Jul 11 15:45:25 2002
@@ -21,7 +21,6 @@
 #include <linux/blk.h>
 #include <linux/console.h>
 #include <linux/openpic.h>
-#include <linux/delay.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -30,9 +29,8 @@
 #include <asm/io.h>
 #include <asm/m48t35.h>
 #include <asm/gemini.h>
-#include <asm/processor.h>
 
-#include <asm/time.h>
+#include "time.h"
 #include "local_irq.h"
 #include "open_pic.h"
 
@@ -168,6 +166,8 @@
 	ioremap( GEMINI_MPIC_ADDR, sizeof( struct OpenPIC ));
 }
 
+
+extern unsigned long loops_per_jiffy;
 extern int root_mountflags;
 extern char cmd_line[];
 
@@ -258,6 +258,14 @@
 	return clock;
 }
 
+
+#define L2CR_PIPE_LATEWR   (0x01800000)   /* late-write SRAM */
+#define L2CR_L2CTL         (0x00100000)   /* RAM control */
+#define L2CR_INST_DISABLE  (0x00400000)   /* disable for insn's */
+#define L2CR_L2I           (0x00200000)   /* global invalidate */
+#define L2CR_L2E           (0x80000000)   /* enable */
+#define L2CR_L2WT          (0x00080000)   /* write-through */
+
 void __init gemini_init_l2(void)
 {
 	unsigned char reg;
@@ -331,7 +339,8 @@
 			cache |= L2CR_L2WT;
 #endif
 		cache |= L2CR_PIPE_LATEWR|L2CR_L2CTL|L2CR_INST_DISABLE;
-		_set_L2CR(cache|L2CR_L2E);
+		_set_L2CR(0);
+		_set_L2CR(cache|L2CR_L2I|L2CR_L2E);
 	}
 }
 
@@ -381,7 +390,7 @@
 #define gemini_rtc_write(val,x)  (writeb((val),(GEMINI_RTC+(x))))
 
 /* ensure that the RTC is up and running */
-long __init gemini_time_init(void)
+void __init gemini_time_init(void)
 {
 	unsigned char reg;
 
@@ -392,7 +401,6 @@
 		gemini_rtc_write((reg & ~(M48T35_RTC_STOPPED)), M48T35_RTC_CONTROL);
 		gemini_rtc_write((reg | M48T35_RTC_SET), M48T35_RTC_CONTROL);
 	}
-	return 0;
 }
 
 #undef DEBUG_RTC
diff -urN linux.orig/arch/ppc/kernel/head.S linux/arch/ppc/kernel/head.S
--- linux.orig/arch/ppc/kernel/head.S	Fri Nov  2 17:39:05 2001
+++ linux/arch/ppc/kernel/head.S	Thu Jul 11 15:43:29 2002
@@ -13,7 +13,6 @@
  *    Copyright (C) 1996 Paul Mackerras.
  *  MPC8xx modifications Copyright (C) 1997 Dan Malek (dmalek@jlc.net).
  *  Amiga/APUS changes by Jesper Skov (jskov@cygnus.co.uk).
- *  AltiVec additions by Kumar Gala (kumar.gala@motorola.com).
  *
  *  This file contains the low-level support and setup for the
  *  PowerPC platform, including trap and interrupt dispatch.
@@ -23,10 +22,6 @@
  *  modify it under the terms of the GNU General Public License
  *  as published by the Free Software Foundation; either version
  *  2 of the License, or (at your option) any later version.
- *
- *  2000-04-10.
- *  Add sys_rt_sigreturn in DoSyscall Handler.
- *  Giovanna Ambrosini (ambrosini@lightning.ch).
  *	
  */
 
@@ -87,28 +82,6 @@
 #define REST_16FPRS(n, base)	REST_8FPRS(n, base); REST_8FPRS(n+8, base)
 #define REST_32FPRS(n, base)	REST_16FPRS(n, base); REST_16FPRS(n+16, base)
 
-/*
- * Once a version of gas that understands the AltiVec instructions
- * is freely available, we can do this the normal way...  - paulus
- */
-#define LVX(r,a,b)	.long	(31<<26)+((r)<<21)+((a)<<16)+((b)<<11)+(103<<1)
-#define STVX(r,a,b)	.long	(31<<26)+((r)<<21)+((a)<<16)+((b)<<11)+(231<<1)
-#define MFVSCR(r)	.long	(4<<26)+((r)<<11)+(770<<1)
-#define MTVSCR(r)	.long	(4<<26)+((r)<<11)+(802<<1)
-
-#define SAVE_VR(n,b,base)	li b,TSS_VR0+(16*(n)); STVX(n,b,base)
-#define SAVE_2VR(n,b,base)	SAVE_VR(n,b,base); SAVE_VR(n+1,b,base) 
-#define SAVE_4VR(n,b,base)	SAVE_2VR(n,b,base); SAVE_2VR(n+2,b,base) 
-#define SAVE_8VR(n,b,base)	SAVE_4VR(n,b,base); SAVE_4VR(n+4,b,base) 
-#define SAVE_16VR(n,b,base)	SAVE_8VR(n,b,base); SAVE_8VR(n+8,b,base)
-#define SAVE_32VR(n,b,base)	SAVE_16VR(n,b,base); SAVE_16VR(n+16,b,base)
-#define REST_VR(n,b,base)	li b,TSS_VR0+(16*(n)); LVX(n,b,base)
-#define REST_2VR(n,b,base)	REST_VR(n,b,base); REST_VR(n+1,b,base) 
-#define REST_4VR(n,b,base)	REST_2VR(n,b,base); REST_2VR(n+2,b,base) 
-#define REST_8VR(n,b,base)	REST_4VR(n,b,base); REST_4VR(n+4,b,base) 
-#define REST_16VR(n,b,base)	REST_8VR(n,b,base); REST_8VR(n+8,b,base) 
-#define REST_32VR(n,b,base)	REST_16VR(n,b,base); REST_16VR(n+16,b,base)
-
 #define SYNC \
 	sync; \
 	isync
@@ -262,15 +235,66 @@
 __secondary_start:
 /* Switch MMU off, clear BATs and flush TLB */
  	bl	mmu_off
-mmu_off_return:
 	bl	clear_bats
 	bl	flush_tlbs
-	bl	setup_init_bats
-#ifndef CONFIG_APUS
-#ifdef CONFIG_BOOTX_TEXT
-	bl	setup_disp_bat
-#endif
+
+/* Use the first pair of BAT registers to map the 1st 16MB
+ * of RAM to KERNELBASE.  From this point on we can't safely
+ * call OF any more.
+ */
+	lis	r11,KERNELBASE@h
+	mfspr	r9,PVR
+	rlwinm	r9,r9,16,16,31		/* r9 = 1 for 601, 4 for 604 */
+	cmpi	0,r9,1
+	bne	4f
+	ori	r11,r11,4		/* set up BAT registers for 601 */
+	li	r8,0x7f			/* valid, block length = 8MB */
+	oris	r9,r11,0x800000@h	/* set up BAT reg for 2nd 8M */
+	oris	r10,r8,0x800000@h	/* set up BAT reg for 2nd 8M */
+	mtspr	IBAT0U,r11		/* N.B. 601 has valid bit in */
+	mtspr	IBAT0L,r8		/* lower BAT register */
+	mtspr	IBAT1U,r9
+	mtspr	IBAT1L,r10
+	b	5f
+4:
+#ifdef CONFIG_APUS
+	ori	r11,r11,BL_8M<<2|0x2	/* set up an 8MB mapping */
+	ori	r11,r11,0xfe		/* set up an 8MB mapping */
+	lis	r8,CYBERBASEp@h
+	lwz	r8,0(r8)
+	addis	r8,r8,KERNELBASE@h
+	addi	r8,r8,2
+#else	
+	ori	r11,r11,BL_256M<<2|0x2	/* set up BAT registers for 604 */
+	li	r8,2			/* R/W access */
+	/*
+	 * If the MMU is off clear the bats.  See clear_bat() -- Cort
+	 */
+#ifndef CONFIG_GEMINI	
+	/* 
+	 * allow secondary cpus to get at all of ram in early bootup
+	 * since their init_task may be up there -- Cort
+	 */
+	oris	r18,r8,0x10000000@h
+	oris	r21,r11,(KERNELBASE+0x10000000)@h
+	mtspr	DBAT1L,r18		/* N.B. 6xx (not 601) have valid */
+	mtspr	DBAT1U,r21		/* bit in upper BAT register */
+	mtspr	IBAT1L,r18
+	mtspr	IBAT1U,r21
+	
+	oris	r18,r8,0x20000000@h
+	oris	r21,r11,(KERNELBASE+0x20000000)@h
+	mtspr	DBAT2L,r18		/* N.B. 6xx (not 601) have valid */
+	mtspr	DBAT2U,r21		/* bit in upper BAT register */
+	mtspr	IBAT2L,r18
+	mtspr	IBAT2U,r21
+#endif /* ndef CONFIG_GEMINI */	
 #endif
+	mtspr	DBAT0L,r8		/* N.B. 6xx (not 601) have valid */
+	mtspr	DBAT0U,r11		/* bit in upper BAT register */
+	mtspr	IBAT0L,r8
+	mtspr	IBAT0U,r11
+5:	isync
 #ifdef CONFIG_APUS
 	/* Unfortunately the APUS specific instructions bloat the
 	 * code so it cannot fit in the 0x100 bytes available. We have
@@ -396,15 +420,6 @@
 #endif /* CONFIG_8xx */
 	b	turn_on_mmu
 
-/* Hack for sleep on Core99 machines
- */
-#ifdef CONFIG_POWERMAC
-	. = 0x80
-SleepVector:
-	.long	0
-	.long	0	
-#endif /* CONFIG_POWERMAC */
-
 /*
  * GCC sometimes accesses words at negative offsets from the stack
  * pointer, although the SysV ABI says it shouldn't.  To cope with
@@ -477,7 +492,7 @@
 #endif /* CONFIG_GEMINI */
 #else
 	STD_EXCEPTION(0x100, Reset, UnknownException)
-#endif
+#endif	
 
 /* Machine check */
 	STD_EXCEPTION(0x200, MachineCheck, MachineCheckException)
@@ -636,26 +651,7 @@
 	STD_EXCEPTION(0xd00, SingleStep, SingleStepException)
 
 	STD_EXCEPTION(0xe00, Trap_0e, UnknownException)
-
-#ifndef CONFIG_ALTIVEC
 	STD_EXCEPTION(0xf00, Trap_0f, UnknownException)
-#else
-/*
- * The Altivec unavailable trap is at 0x0f20.  Foo.
- * We effectively remap it to 0x3000.
- */
-	. = 0xf00
-	b	Trap_0f
-trap_0f_cont:
-	addi	r3,r1,STACK_FRAME_OVERHEAD
-	li	r20,MSR_KERNEL
-	bl	transfer_to_handler
-	.long	UnknownException
-	.long	int_return
-
-	. = 0xf20
-	b	AltiVecUnavailable
-#endif /* CONFIG_ALTIVEC */
 
 #ifndef CONFIG_8xx
 /*
@@ -1173,24 +1169,9 @@
 	STD_EXCEPTION(0x2f00, Trap_2f, UnknownException)
 
 	. = 0x3000
-#ifdef CONFIG_ALTIVEC
-AltiVecUnavailable:
-	EXCEPTION_PROLOG
-	bne	load_up_altivec		/* if from user, just load it up */
-	li	r20,MSR_KERNEL
-	bl	transfer_to_handler	/* if from kernel, take a trap */
-	.long	KernelAltiVec
-	.long	int_return
-
-/* here are the bits of trap 0xf00 which got displaced */
-Trap_0f:
-	EXCEPTION_PROLOG
-	b	trap_0f_cont
-#endif /* CONFIG_ALTIVEC */
-
-#else /* CONFIG_8xx */
+#else
 	. = 0x2000
-#endif /* CONFIG_8xx */
+#endif
 
 /*
  * This code finishes saving the registers to the exception frame
@@ -1345,7 +1326,11 @@
 	/* Construct the high word of the PPC-style PTE */
 	mfsrin	r5,r3			/* get segment reg for segment */
 	rlwinm	r5,r5,7,1,24		/* put VSID in 0x7fffff80 bits */
+	
+#ifndef __SMP__				/* do this later for SMP */
 	oris	r5,r5,0x8000		/* set V (valid) bit */
+#endif
+	
 	rlwimi	r5,r3,10,26,31		/* put in API (abbrev page index) */
 	/* Get the address of the primary PTE group in the hash table */
 	.globl	hash_page_patch_A
@@ -1457,7 +1442,6 @@
  */
 found_empty:
 found_slot:
-	clrlwi	r5,r5,1		/* clear valid bit (0x80000000) */
 	stw	r5,0(r3)	/* clear V (valid) bit in PTE */
 	sync
 	tlbsync
@@ -1509,7 +1493,6 @@
 	REST_GPR(20, r21)
 	REST_2GPRS(22, r21)
 	lwz	r21,GPR21(r21)
-	sync
 	rfi
 	
 #ifdef __SMP__
@@ -1649,145 +1632,24 @@
 #endif /* __SMP__ */
 	blr
 
-#ifdef CONFIG_ALTIVEC
-/* Note that the AltiVec support is closely modeled after the FP
- * support.  Changes to one are likely to be applicable to the
- * other!  */
-load_up_altivec:
-/*
- * Disable AltiVec for the task which had AltiVec previously,
- * and save its AltiVec registers in its thread_struct.
- * Enables AltiVec for use in the kernel on return.
- * On SMP we know the AltiVec units are free, since we give it up every
- * switch.  -- Kumar
- */
-	mfmsr	r5
-	oris	r5,r5,MSR_VEC@h
-	SYNC
-	mtmsr	r5			/* enable use of AltiVec now */
-	SYNC
-/*
- * For SMP, we don't do lazy AltiVec switching because it just gets too
- * horrendously complex, especially when a task switches from one CPU
- * to another.  Instead we call giveup_altivec in switch_to.
- */
-#ifndef __SMP__
-#ifndef CONFIG_APUS
-	lis	r6,-KERNELBASE@h
-#else
-	lis	r6,CYBERBASEp@h
-	lwz	r6,0(r6)
-#endif
-	addis	r3,r6,last_task_used_altivec@ha
-	lwz	r4,last_task_used_altivec@l(r3)
-	cmpi	0,r4,0
-	beq	1f
-	add	r4,r4,r6
-	addi	r4,r4,TSS	/* want TSS of last_task_used_altivec */
-	SAVE_32VR(0,r20,r4)
-	MFVSCR(vr0)
-	li	r20,TSS_VSCR
-	STVX(vr0,r20,r4)
-	lwz	r5,PT_REGS(r4)
-	add	r5,r5,r6
-	lwz	r4,_MSR-STACK_FRAME_OVERHEAD(r5)
-	lis	r20,MSR_VEC@h
-	andc	r4,r4,r20	/* disable altivec for previous task */
-	stw	r4,_MSR-STACK_FRAME_OVERHEAD(r5)
-1:
-#endif /* __SMP__ */
-	/* enable use of AltiVec after return */
-	oris	r23,r23,MSR_VEC@h
-	mfspr	r5,SPRG3		/* current task's TSS (phys) */
-	li	r20,TSS_VSCR
-	LVX(vr0,r20,r5)
-	MTVSCR(vr0)
-	REST_32VR(0,r20,r5)
-#ifndef __SMP__
-	subi	r4,r5,TSS
-	sub	r4,r4,r6
-	stw	r4,last_task_used_altivec@l(r3)
-#endif /* __SMP__ */
-	/* restore registers and return */
-	lwz	r3,_CCR(r21)
-	lwz	r4,_LINK(r21)
-	mtcrf	0xff,r3
-	mtlr	r4
-	REST_GPR(1, r21)
-	REST_4GPRS(3, r21)
-	/* we haven't used ctr or xer */
-	mtspr	SRR1,r23
-	mtspr	SRR0,r22
-	REST_GPR(20, r21)
-	REST_2GPRS(22, r21)
-	lwz	r21,GPR21(r21)
-	SYNC
-	rfi
-
-/*
- * AltiVec unavailable trap from kernel - print a message, but let
- * the task use AltiVec in the kernel until it returns to user mode.
- */
-KernelAltiVec:
-	lwz	r3,_MSR(r1)
-	oris	r3,r3,MSR_VEC@h
-	stw	r3,_MSR(r1)	/* enable use of AltiVec after return */
-	lis	r3,87f@h
-	ori	r3,r3,87f@l
-	mr	r4,r2		/* current */
-	lwz	r5,_NIP(r1)
-	bl	printk
-	b	int_return
-87:	.string	"AltiVec used in kernel  (task=%p, pc=%x)  \n"
-	.align	4
-
-/*
- * giveup_altivec(tsk)
- * Disable AltiVec for the task given as the argument,
- * and save the AltiVec registers in its thread_struct.
- * Enables AltiVec for use in the kernel on return.
- */
-
-	.globl	giveup_altivec
-giveup_altivec:
-	mfmsr	r5
-	oris	r5,r5,MSR_VEC@h
-	SYNC
-	mtmsr	r5			/* enable use of AltiVec now */
-	SYNC
-	cmpi	0,r3,0
-	beqlr-				/* if no previous owner, done */
-	addi	r3,r3,TSS		/* want TSS of task */
-	lwz	r5,PT_REGS(r3)
-	cmpi	0,r5,0
-	SAVE_32VR(0, r4, r3)
-	MFVSCR(vr0)
-	li	r4,TSS_VSCR
-	STVX(vr0, r4, r3)
-	beq	1f
-	lwz	r4,_MSR-STACK_FRAME_OVERHEAD(r5)
-	lis	r3,MSR_VEC@h
-	andc	r4,r4,r3		/* disable AltiVec for previous task */
-	stw	r4,_MSR-STACK_FRAME_OVERHEAD(r5)
-1:
-#ifndef __SMP__
-	li	r5,0
-	lis	r4,last_task_used_altivec@ha
-	stw	r5,last_task_used_altivec@l(r4)
-#endif /* __SMP__ */
+#else  /* CONFIG_8xx */
+	.globl	giveup_fpu
+giveup_fpu:
 	blr
-#endif /* CONFIG_ALTIVEC */
+#endif /* CONFIG_8xx */
 
 mmu_off:
- 	addi	r4, r3, mmu_off_return - _start
+ 	addi	r4, r3, __secondary_start - _start
 	mfmsr	r3
 	andi.	r0,r3,MSR_DR|MSR_IR		/* MMU enabled? */
-	beqlr
-	andc	r3,r3,r0
+	beq	1f
+	ori	r3,r3,MSR_DR|MSR_IR
+	xori	r3,r3,MSR_DR|MSR_IR
 	mtspr	SRR0,r4
 	mtspr	SRR1,r3
-	SYNC
+	sync
 	rfi
+1:	blr
 
 /*
  * This code is jumped to from the startup code to copy
@@ -1798,6 +1660,10 @@
 	addi	r9,r9,0x6f58		/* translate source addr */
 	cmpw	r31,r9			/* (we have to on chrp) */
 	beq	7f
+#if 0 // still needed ? breaks on me if I don't disable this
+	rlwinm	r4,r4,0,8,31		/* translate source address */
+	add	r4,r4,r3		/* to region mapped with BATs */
+#endif	
 7:	addis	r9,r26,klimit@ha	/* fetch klimit */
 	lwz	r25,klimit@l(r9)
 	addis	r25,r25,-KERNELBASE@h
@@ -1845,12 +1711,6 @@
 	. = 0x4000
 #endif
 
-#else  /* CONFIG_8xx */
-	.globl	giveup_fpu
-giveup_fpu:
-	blr
-#endif /* CONFIG_8xx */
-
 turn_on_mmu:
 	mfmsr	r0
 	ori	r1,r0,MSR_DR|MSR_IR
@@ -1913,7 +1773,7 @@
 	mfspr	r9,PVR
 	rlwinm	r9,r9,16,16,31
 	cmpi	0,r9,1
-	beq	6f			/* not needed for 601 */
+	beq	4f			/* not needed for 601 */
 	mfspr	r11,HID0
 	andi.	r0,r11,HID0_DCE
 	ori	r11,r11,HID0_ICE|HID0_DCE
@@ -1930,24 +1790,14 @@
 	cmpi	0,r9,4			/* check for 604 */
 	cmpi	1,r9,9			/* or 604e */
 	cmpi	2,r9,10			/* or mach5 */
-	cmpi	3,r9,8			/* check for 750 (G3) */
-	cmpi	4,r9,12			/* or 7400 (G4) */
 	cror	2,2,6
 	cror	2,2,10
 	bne	4f
 	ori	r11,r11,HID0_SIED|HID0_BHTE /* for 604[e], enable */
 	bne	2,5f
 	ori	r11,r11,HID0_BTCD
-	b	5f
-4:
-	cror	14,14,18
-	bne	3,6f
-	ori	r11,r11,HID0_SGE|HID0_BHTE|HID0_BTIC|HID0_ABE /* for g3/g4, enable */
-	rlwinm	r11,r11,0,23,21		/* clear HID0_SPD */
- 	li	r3,0
- 	mtspr	ICTC,r3
 5:	mtspr	HID0,r11		/* superscalar exec & br history tbl */
-6:
+4:
 #endif /* CONFIG_8xx */
 #ifdef __SMP__
 	/* if we're the second cpu stack and r2 are different
@@ -2028,10 +1878,10 @@
 	li	r3,MSR_KERNEL & ~(MSR_IR|MSR_DR)
 	mtspr	SRR0,r4
 	mtspr	SRR1,r3
-	SYNC
 	rfi
 /* Load up the kernel context */
 2:
+	SYNC			/* Force all PTE updates to finish */
 	tlbia			/* Clear all TLB entries */
 	sync			/* wait for tlbia/tlbie to finish */
 #ifdef __SMP__
@@ -2088,7 +1938,6 @@
 #endif /* __SMP__ */
 	mtspr	SRR0,r3
 	mtspr	SRR1,r4
-	SYNC
 	rfi			/* enable MMU and jump to start_kernel */
 
 /*
@@ -2126,11 +1975,9 @@
 1:
 #endif /* SHOW_SYSCALLS */
 	cmpi	0,r0,0x7777	/* Special case for 'sys_sigreturn' */
-        cmpi    1,r0,0x6666     /* Special case for 'sys_rt_sigreturn' */
 	beq-	10f
-        beq-    cr1,16f
-	lwz	r10,TASK_PTRACE(r2)
-	andi.	r10,r10,PT_TRACESYS
+	lwz	r10,TASK_FLAGS(r2)
+	andi.	r10,r10,PF_TRACESYS
 	bne-	50f
 	cmpli	0,r0,NR_syscalls
 	bge-	66f
@@ -2175,12 +2022,6 @@
 /* sys_sigreturn */
 10:	addi	r3,r1,STACK_FRAME_OVERHEAD
 	bl	sys_sigreturn
-        cmpi    0,r3,0          /* Check for restarted system call */
-        bge     int_return
-        b       20b
-/* sys_rt_sigreturn */
-16:     addi    r3,r1,STACK_FRAME_OVERHEAD
-        bl      sys_rt_sigreturn
 	cmpi	0,r3,0		/* Check for restarted system call */
 	bge	int_return
 	b	20b
@@ -2273,9 +2114,6 @@
 	mflr	r20		/* Return to switch caller */
 	mfmsr	r22
 	li	r0,MSR_FP	/* Disable floating-point */
-#ifdef CONFIG_ALTIVEC
-	oris	r0,r0,MSR_VEC@h
-#endif /* CONFIG_ALTIVEC */
 	andc	r22,r22,r0
 	stw	r20,_NIP(r1)
 	stw	r22,_MSR(r1)
@@ -2589,38 +2427,6 @@
 	blr
 
 /*
- * Copy a whole page.  We use the dcbz instruction on the destination
- * to reduce memory traffic (it eliminates the unnecessary reads of
- * the destination into cache).  This requires that the destination
- * is cacheable.
- */
-_GLOBAL(copy_page)
-	li	r0,4096/CACHE_LINE_SIZE
-	mtctr	r0
-	addi	r3,r3,-4
-	addi	r4,r4,-4
-	li	r5,4
-1:	dcbz	r5,r3
-	lwz	r6,4(r4)
-	lwz	r7,8(r4)
-	lwz	r8,12(r4)
-	lwzu	r9,16(r4)
-	stw	r6,4(r3)
-	stw	r7,8(r3)
-	stw	r8,12(r3)
-	stwu	r9,16(r3)
-	lwz	r6,4(r4)
-	lwz	r7,8(r4)
-	lwz	r8,12(r4)
-	lwzu	r9,16(r4)
-	stw	r6,4(r3)
-	stw	r7,8(r3)
-	stw	r8,12(r3)
-	stwu	r9,16(r3)
-	bdnz	1b
-	blr
-
-/*
  * Flush entries from the hash table with VSIDs in the range
  * given.
  */
@@ -2798,6 +2604,7 @@
 	stw	r0,20(r1)
 	lis	r4,rtas_data@ha
 	lwz	r4,rtas_data@l(r4)
+	addis	r4,r4,-KERNELBASE@h
 	lis	r6,1f@ha	/* physical return address for rtas */
 	addi	r6,r6,1f@l
 	addis	r6,r6,-KERNELBASE@h
@@ -2817,7 +2624,6 @@
 	mtspr	SPRG2,r7
 	mtspr	SRR0,r8
 	mtspr	SRR1,r9
-	SYNC
 	rfi
 1:	addis	r9,r1,-KERNELBASE@h
 	lwz	r8,20(r9)	/* get return address */
@@ -2826,7 +2632,6 @@
 	mtspr	SPRG2,r0
 	mtspr	SRR0,r8
 	mtspr	SRR1,r9
-	SYNC
 	rfi			/* return to caller */
 #endif /* CONFIG_8xx */
 
@@ -2851,6 +2656,30 @@
        mtlr    r4
        blr
 #endif /* CONFIG_8xx */
+	
+/*
+ * We put a few things here that have to be page-aligned.
+ * This stuff goes at the beginning of the data segment,
+ * which is page-aligned.
+ */
+	.data
+	.globl	sdata
+sdata:
+	.globl	empty_zero_page
+empty_zero_page:
+	.space	4096
+
+	.globl	swapper_pg_dir
+swapper_pg_dir:
+	.space	4096	
+
+/*
+ * This space gets a copy of optional info passed to us by the bootstrap
+ * Used to pass parameters into the kernel like root=/dev/sda1, etc.
+ */	
+	.globl	cmd_line
+cmd_line:
+	.space	512
 
 /* 
  * An undocumented "feature" of 604e requires that the v bit
@@ -2895,117 +2724,4 @@
 	blt	1b
 	sync
 	blr
-
-/* Use the first pair of BAT registers to map the 1st 16MB
- * of RAM to KERNELBASE.  From this point on we can't safely
- * call OF any more.
- */
-setup_init_bats:
-	lis	r11,KERNELBASE@h
-	mfspr	r9,PVR
-	rlwinm	r9,r9,16,16,31		/* r9 = 1 for 601, 4 for 604 */
-	cmpi	0,r9,1
-	bne	4f
-	ori	r11,r11,4		/* set up BAT registers for 601 */
-	li	r8,0x7f			/* valid, block length = 8MB */
-	oris	r9,r11,0x800000@h	/* set up BAT reg for 2nd 8M */
-	oris	r10,r8,0x800000@h	/* set up BAT reg for 2nd 8M */
-	mtspr	IBAT0U,r11		/* N.B. 601 has valid bit in */
-	mtspr	IBAT0L,r8		/* lower BAT register */
-	mtspr	IBAT1U,r9
-	mtspr	IBAT1L,r10
-	b	5f
-4:
-#ifdef CONFIG_APUS
-	ori	r11,r11,BL_8M<<2|0x2	/* set up an 8MB mapping */
-	ori	r11,r11,0xfe		/* set up an 8MB mapping */
-	lis	r8,CYBERBASEp@h
-	lwz	r8,0(r8)
-	addis	r8,r8,KERNELBASE@h
-	addi	r8,r8,2
-#else	
-	ori	r11,r11,BL_256M<<2|0x2	/* set up BAT registers for 604 */
-	li	r8,2			/* R/W access */
-	/*
-	 * If the MMU is off clear the bats.  See clear_bat() -- Cort
-	 */
-#ifndef CONFIG_GEMINI	
-	/* 
-	 * allow secondary cpus to get at all of ram in early bootup
-	 * since their init_task may be up there -- Cort
-	 */
-	oris	r18,r8,0x10000000@h
-	oris	r21,r11,(KERNELBASE+0x10000000)@h
-	mtspr	DBAT1L,r18		/* N.B. 6xx (not 601) have valid */
-	mtspr	DBAT1U,r21		/* bit in upper BAT register */
-	mtspr	IBAT1L,r18
-	mtspr	IBAT1U,r21
 	
-	oris	r18,r8,0x20000000@h
-	oris	r21,r11,(KERNELBASE+0x20000000)@h
-	mtspr	DBAT2L,r18		/* N.B. 6xx (not 601) have valid */
-	mtspr	DBAT2U,r21		/* bit in upper BAT register */
-	mtspr	IBAT2L,r18
-	mtspr	IBAT2U,r21
-#endif /* ndef CONFIG_GEMINI */	
-#endif
-	mtspr	DBAT0L,r8		/* N.B. 6xx (not 601) have valid */
-	mtspr	DBAT0U,r11		/* bit in upper BAT register */
-	mtspr	IBAT0L,r8
-	mtspr	IBAT0U,r11
-5:	isync
-	blr
-	
-#ifdef CONFIG_BOOTX_TEXT
-setup_disp_bat:
-	/*
-	 * setup the display bat prepared for us in prom.c
-	 */
-	mflr	r8
-	bl	reloc_offset
-	mtlr	r8
-	lis	r8, disp_BATL@h
-	ori	r8, r8, disp_BATL@l
-	add	r8, r3, r8
-	lwz	r8, 0(r8)
-	lis	r11, disp_BATU@h
-	ori	r11, r11, disp_BATU@l
-	add	r11, r3, r11
-	lwz	r11, 0(r11)
-	mtspr	IBAT3L,r8
-	mtspr	IBAT3U,r11
-	mfspr	r9,PVR
-	rlwinm	r9,r9,16,16,31		/* r9 = 1 for 601, 4 for 604 */
-	cmpi	0,r9,1
-	beq	1f
-	mtspr	DBAT3L,r8
-	mtspr	DBAT3U,r11
-1:		
-	blr
-#endif
-	
-/*
- * We put a few things here that have to be page-aligned.
- * This stuff goes at the beginning of the data segment,
- * which is page-aligned.
- */
-	.data
-	.globl	sdata
-sdata:
-	.globl	empty_zero_page
-empty_zero_page:
-	.space	4096
-
-	.globl	swapper_pg_dir
-swapper_pg_dir:
-	.space	4096	
-
-/*
- * This space gets a copy of optional info passed to us by the bootstrap
- * Used to pass parameters into the kernel like root=/dev/sda1, etc.
- */	
-	.globl	cmd_line
-cmd_line:
-	.space	512
-
-
diff -urN linux.orig/arch/ppc/kernel/irq.c linux/arch/ppc/kernel/irq.c
--- linux.orig/arch/ppc/kernel/irq.c	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/kernel/irq.c	Thu Jul 11 15:43:29 2002
@@ -61,9 +61,7 @@
 
 #include "local_irq.h"
 
-extern atomic_t ipi_recv;
-extern atomic_t ipi_sent;
-void enable_irq(unsigned int irq_nr);
+extern volatile unsigned long ipi_count;
 void enable_irq(unsigned int irq_nr);
 void disable_irq(unsigned int irq_nr);
 
@@ -139,21 +137,20 @@
 	if (!handler)
 	{
 		/* Free */
-		p = &irq_desc[irq].action;
-		while ((action = *p) != NULL && action->dev_id != dev_id)
-			p = &action->next;
-		if (action == NULL)
-			return -ENOENT;
-
-		/* Found it - now free it */
-		save_flags(flags);
-		cli();
-		*p = action->next;
-		if (irq_desc[irq].action == NULL)
-			disable_irq(irq);
-		restore_flags(flags);
-		irq_kfree(action);
-		return 0;
+		for (p = &irq_desc[irq].action; (action = *p) != NULL; p = &action->next)
+		{
+			if (action->dev_id == dev_id)
+			{
+				/* Found it - now free it */
+				save_flags(flags);
+				cli();
+				*p = action->next;
+				restore_flags(flags);
+				irq_kfree(action);
+				return 0;
+			}
+		}
+		return -ENOENT;
 	}
 	
 	action = (struct irqaction *)
@@ -244,10 +241,8 @@
 	}
 #ifdef __SMP__
 	/* should this be per processor send/receive? */
-  	/* should this be per processor send/receive? */
- 	len += sprintf(buf+len, "IPI: (recv/sent) %10lu/%lu\n",
- 			atomic_read(&ipi_recv), atomic_read(&ipi_sent));
-#endif /* __SMP__ */		
+	len += sprintf(buf+len, "IPI: %10lu\n", ipi_count);
+#endif		
 	len += sprintf(buf+len, "BAD: %10u\n", ppc_spurious_interrupts);
 	return len;
 }
@@ -322,14 +317,10 @@
 atomic_t global_bh_count;
 atomic_t global_bh_lock;
 
-extern unsigned long *_get_SP(void);
-
 static void show(char * str)
 {
-#if 0
 	int i;
 	unsigned long *stack;
-#endif
 	int cpu = smp_processor_id();
 
 	printk("\n%s, CPU %d:\n", str, cpu);
@@ -341,10 +332,6 @@
 	       atomic_read(&global_bh_count),
 	       ppc_local_bh_count[0],
 	       ppc_local_bh_count[1]);
-#if 1
-	printk(" CPU: %d last CPU: %d\n", current->processor,current->last_processor);
-	print_backtrace (_get_SP());
-#else
 	stack = (unsigned long *) &str;
 	for (i = 40; i ; i--) {
 		unsigned long x = *++stack;
@@ -352,7 +339,6 @@
 			printk("<[%08lx]> ", x);
 		}
 	}
-#endif
 }
 
 static inline void wait_on_bh(void)
diff -urN linux.orig/arch/ppc/kernel/local_irq.h linux/arch/ppc/kernel/local_irq.h
--- linux.orig/arch/ppc/kernel/local_irq.h	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/local_irq.h	Thu Jul 11 15:43:29 2002
@@ -26,7 +26,6 @@
 struct irqdesc {
 	struct irqaction *action;
 	struct hw_interrupt_type *ctl;
-	int level;
 };
 
 extern struct irqdesc irq_desc[NR_IRQS];
diff -urN linux.orig/arch/ppc/kernel/mbx_pci.c linux/arch/ppc/kernel/mbx_pci.c
--- linux.orig/arch/ppc/kernel/mbx_pci.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/mbx_pci.c	Thu Jul 11 15:43:29 2002
@@ -17,9 +17,7 @@
 
 #include <asm/io.h>
 #include <asm/mbx.h>
-#include <asm/machdep.h>
 
-#include "pci.h"
 
 /*
  * This blows......The MBX uses the Tundra QSpan PCI bridge.  When
diff -urN linux.orig/arch/ppc/kernel/mbx_setup.c linux/arch/ppc/kernel/mbx_setup.c
--- linux.orig/arch/ppc/kernel/mbx_setup.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/mbx_setup.c	Thu Jul 11 15:43:29 2002
@@ -31,7 +31,6 @@
 #include <linux/init.h>
 #include <linux/blk.h>
 #include <linux/ioport.h>
-#include <linux/delay.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
@@ -41,25 +40,14 @@
 #include <asm/ide.h>
 #include <asm/mbx.h>
 #include <asm/machdep.h>
-#include <asm/keyboard.h>
-#include <asm/8xx_immap.h>
-#include <asm/time.h>
 
+#include "time.h"
 #include "local_irq.h"
 
 static int mbx_set_rtc_time(unsigned long time);
 unsigned long mbx_get_rtc_time(void);
 void mbx_calibrate_decr(void);
 
-extern int pckbd_setkeycode(unsigned int scancode, unsigned int keycode);
-extern int pckbd_getkeycode(unsigned int scancode);
-extern int pckbd_translate(unsigned char scancode, unsigned char *keycode,
-			   char raw_mode);
-extern char pckbd_unexpected_up(unsigned char keycode);
-extern void pckbd_leds(unsigned char leds);
-extern void pckbd_init_hw(void);
-extern unsigned char pckbd_sysrq_xlate[128];
-
 extern int mackbd_setkeycode(unsigned int scancode, unsigned int keycode);
 extern int mackbd_getkeycode(unsigned int scancode);
 extern int mackbd_translate(unsigned char scancode, unsigned char *keycode,
@@ -68,6 +56,8 @@
 extern void mackbd_leds(unsigned char leds);
 extern void mackbd_init_hw(void);
 
+extern unsigned long loops_per_jiffy;
+
 unsigned long empty_zero_page[1024];
 
 #ifdef CONFIG_BLK_DEV_RAM
@@ -463,7 +453,7 @@
 	ppc_md.kbd_leds          = pckbd_leds;
 	ppc_md.kbd_init_hw       = pckbd_init_hw;
 #ifdef CONFIG_MAGIC_SYSRQ
-	ppc_md.sysrq_xlate	 = pckbd_sysrq_xlate;
+	ppc_md.kbd_sysrq_xlate	 = pckbd_sysrq_xlate;
 	SYSRQ_KEY		 = 0x54;
 #endif
 
diff -urN linux.orig/arch/ppc/kernel/misc.S linux/arch/ppc/kernel/misc.S
--- linux.orig/arch/ppc/kernel/misc.S	Sun Mar 25 18:37:30 2001
+++ linux/arch/ppc/kernel/misc.S	Thu Jul 11 15:43:29 2002
@@ -125,33 +125,12 @@
  * Flush MMU TLB
  */
 _GLOBAL(_tlbia)
-#if defined(CONFIG_SMP)
-	mfmsr	r10
-	sync
-	rlwinm	r0,r10,0,17,15		/* clear bit 16 (MSR_EE) */
-	mtmsr	r0
-	SYNC
-	lis	r9,hash_table_lock@h
-	ori	r9,r9,hash_table_lock@l
-	lwz	r8,PROCESSOR(r2)
-	oris	r8,r8,10
-10:	lwarx	r7,0,r9
-	cmpi	0,r7,0
-	bne-	10b
-	stwcx.	r8,0,r9
-	bne-	10b
-	eieio
-#endif /* CONFIG_SMP */
 	sync
 	tlbia
 	sync
 #ifdef __SMP__
 	tlbsync
 	sync
-	li	r0,0
-	stw	r0,0(r9)		/* clear hash_table_lock */
-	mtmsr	r10
-	SYNC
 #endif
 	blr	
 
@@ -159,32 +138,11 @@
  * Flush MMU TLB for a particular address
  */
 _GLOBAL(_tlbie)
-#if defined(CONFIG_SMP)
-	mfmsr	r10
-	sync
-	rlwinm	r0,r10,0,17,15		/* clear bit 16 (MSR_EE) */
-	mtmsr	r0
-	SYNC
-	lis	r9,hash_table_lock@h
-	ori	r9,r9,hash_table_lock@l
-	lwz	r8,PROCESSOR(r2)
-	oris	r8,r8,11
-10:	lwarx	r7,0,r9
-	cmpi	0,r7,0
-	bne-	10b
-	stwcx.	r8,0,r9
-	bne-	10b
-	eieio
-#endif /* CONFIG_SMP */
 	tlbie	r3
 	sync
-#ifdef CONFIG_SMP
+#ifdef __SMP__
 	tlbsync
 	sync
-	li	r0,0
-	stw	r0,0(r9)		/* clear hash_table_lock */
-	mtmsr	r10
-	SYNC
 #endif
 	blr
 
@@ -317,8 +275,10 @@
 	stwcx.	r5,0,r3		/* Update with new value */
 	bne-	10b		/* Retry if "reservation" (i.e. lock) lost */
 	SMP_MB
-	cntlzw	r3,r5
-	srwi	r3,r3,5
+	cmpi	0,r5,0		/* Return 'true' IFF 0 */
+	li	r3,1
+	beqlr
+	li	r3,0
 	blr
 _GLOBAL(atomic_clear_mask)
 	SMP_WMB			/* wmb() */
@@ -354,10 +314,8 @@
  * The *_ns versions don't do byte-swapping.
  */
 _GLOBAL(_insb)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,1
-	blelr-
 00:	lbz	r5,0(r3)
 	eieio
 	stbu	r5,1(r4)
@@ -365,10 +323,8 @@
 	blr
 
 _GLOBAL(_outsb)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,1
-	blelr-
 00:	lbzu	r5,1(r4)
 	stb	r5,0(r3)
 	eieio
@@ -376,10 +332,8 @@
 	blr	
 
 _GLOBAL(_insw)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,2
-	blelr-
 00:	lhbrx	r5,0,r3
 	eieio
 	sthu	r5,2(r4)
@@ -387,10 +341,8 @@
 	blr
 
 _GLOBAL(_outsw)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,2
-	blelr-
 00:	lhzu	r5,2(r4)
 	eieio
 	sthbrx	r5,0,r3	
@@ -398,10 +350,8 @@
 	blr	
 
 _GLOBAL(_insl)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,4
-	blelr-
 00:	lwbrx	r5,0,r3
 	eieio
 	stwu	r5,4(r4)
@@ -409,10 +359,8 @@
 	blr
 
 _GLOBAL(_outsl)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,4
-	blelr-
 00:	lwzu	r5,4(r4)
 	stwbrx	r5,0,r3
 	eieio
@@ -421,10 +369,8 @@
 
 _GLOBAL(ide_insw)
 _GLOBAL(_insw_ns)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,2
-	blelr-
 00:	lhz	r5,0(r3)
 	eieio
 	sthu	r5,2(r4)
@@ -433,10 +379,8 @@
 
 _GLOBAL(ide_outsw)
 _GLOBAL(_outsw_ns)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,2
-	blelr-
 00:	lhzu	r5,2(r4)
 	sth	r5,0(r3)
 	eieio
@@ -444,10 +388,8 @@
 	blr	
 
 _GLOBAL(_insl_ns)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,4
-	blelr-
 00:	lwz	r5,0(r3)
 	eieio
 	stwu	r5,4(r4)
@@ -455,10 +397,8 @@
 	blr
 
 _GLOBAL(_outsl_ns)
-	cmpwi	0,r5,0
 	mtctr	r5
 	subi	r4,r4,4
-	blelr-
 00:	lwzu	r5,4(r4)
 	stw	r5,0(r3)
 	eieio
@@ -466,59 +406,48 @@
 	blr	
 
 /*
- * Extended precision shifts.
- * 
- * Updated to be valid for shift counts from 0 to 63 inclusive.
- * -- Gabriel
+ * Extended precision shifts
  *
  * R3/R4 has 64 bit value
  * R5    has shift count
  * result in R3/R4
  *
- *  ashrdi3: arithmetic right shift (sign propagation)	    
- *  lshrdi3: logical right shift	
- *  ashldi3: left shift
+ *  ashrdi3:     XXXYYY/ZZZAAA -> SSSXXX/YYYZZZ
+ *  ashldi3:     XXXYYY/ZZZAAA -> YYYZZZ/AAA000
+ *  lshrdi3:     XXXYYY/ZZZAAA -> 000XXX/YYYZZZ
  */
 _GLOBAL(__ashrdi3)
-	subfic	r6,r5,32	
-	srw	r4,r4,r5	# LSW = count > 31 ? 0 : LSW >> count
-	addi	r7,r5,32	# could be xori, or addi with -32
-	slw	r6,r3,r6	# t1 = count > 31 ? 0 : MSW << (32-count)
-	rlwinm	r8,r7,0,32	# t3 = (count < 32) ? 32 : 0
-	sraw	r7,r3,r7	# t2 = MSW >> (count-32)
-	or	r4,r4,r6	# LSW |= t1
-	slw	r7,r7,r8	# t2 = (count < 32) ? 0 : t2
-	sraw	r3,r3,r5	# MSW = MSW >> count
-	or	r4,r4,r7	# LSW |= t2
+	li	r6,32
+	sub	r6,r6,r5
+	slw	r7,r3,r6	/* isolate YYY */
+	srw	r4,r4,r5	/* isolate ZZZ */
+	or	r4,r4,r7	/* YYYZZZ */
+	sraw	r3,r3,r5	/* SSSXXX */
 	blr
 
 _GLOBAL(__ashldi3)
-	subfic	r6,r5,32	
-	slw	r3,r3,r5	# MSW = count > 31 ? 0 : MSW << count
-	addi	r7,r5,32	# could be xori, or addi with -32
-	srw	r6,r4,r6	# t1 = count > 31 ? 0 : LSW >> (32-count)
-	slw	r7,r4,r7	# t2 = count < 32 ? 0 : LSW << (count-32)
-	or	r3,r3,r6	# MSW |= t1
-	slw	r4,r4,r5	# LSW = LSW << count
-	or	r3,r3,r7	# MSW |= t2
+	li	r6,32
+	sub	r6,r6,r5
+	srw	r7,r4,r6	/* isolate ZZZ */
+	slw	r4,r4,r5	/* AAA000 */
+	slw	r3,r3,r5	/* YYY--- */
+	or	r3,r3,r7	/* YYYZZZ */
 	blr
 
 _GLOBAL(__lshrdi3)
-	subfic	r6,r5,32	
-	srw	r4,r4,r5	# LSW = count > 31 ? 0 : LSW >> count
-	addi	r7,r5,32	# could be xori, or addi with -32
-	slw	r6,r3,r6	# t1 = count > 31 ? 0 : MSW << (32-count)
-	srw	r7,r3,r7	# t2 = count < 32 ? 0 : MSW >> (count-32)
-	or	r4,r4,r6	# LSW |= t1
-	srw	r3,r3,r5	# MSW = MSW >> count
-	or	r4,r4,r7	# LSW |= t2 
+	li	r6,32
+	sub	r6,r6,r5
+	slw	r7,r3,r6        /* isolate YYY */
+	srw	r4,r4,r5        /* isolate ZZZ */
+	or	r4,r4,r7        /* YYYZZZ */
+	srw	r3,r3,r5        /* 000XXX */
 	blr
 
 _GLOBAL(abs)
-	srawi	r4,r3,31
-	xor	r3,r3,r4
-	sub	r3,r3,r4
-	blr
+	cmpi	0,r3,0
+	bge	10f
+	neg	r3,r3
+10:	blr
 
 _GLOBAL(_get_SP)
 	mr	r3,r1		/* Close enough */
@@ -563,14 +492,6 @@
 	isync /* Handle erratas in some cases */
 	blr
 
-_GLOBAL(_get_ICTC)
-       mfspr   r3,ICTC
-       blr
-
-_GLOBAL(_set_ICTC)
-       mtspr   ICTC,r3
-       blr
-
 /*
 	L2CR functions
 	Copyright  1997-1998 by PowerLogix R & D, Inc.
@@ -592,17 +513,6 @@
 /*
 	Thur, Dec. 12, 1998.
 	- First public release, contributed by PowerLogix.
-	***********
-	Sat, Aug. 7, 1999.
-	- Terry: Made sure code disabled interrupts before running. (Previously
-			it was assumed interrupts were already disabled).
-	- Terry: Updated for tentative G4 support.  4MB of memory is now flushed
-			instead of 2MB.  (Prob. only 3 is necessary).
-	- Terry: Updated for workaround to HID0[DPM] processor bug
-			during global invalidates.
-	***********
-	Thu, July 13, 2000.
-	- Terry: Added isync to correct for an errata.
 	
 	Author:	Terry Greeniaus (tgree@phys.ualberta.ca)
 	Please e-mail updates to this file to me, thanks!
@@ -641,94 +551,80 @@
 	causes cache pushes from the L1 cache to go to the L2 cache
 	instead of to main memory.
 */
-/*
- * Summary: this procedure ignores the L2I bit in the value passed in,
- * flushes the cache if it was already enabled, always invalidates the
- * cache, then enables the cache if the L2E bit is set in the value
- * passed in.
- *   -- paulus.
- */
+
 _GLOBAL(_set_L2CR)
-	/* Make sure this is a 750 or 7400 chip */
+	/* Make sure this is a 750 chip */
 	mfspr	r4,PVR
 	rlwinm	r4,r4,16,16,31
-	cmpwi	r4,0x0008
-	cmpwi	cr1,r4,0x000c
-	cror	2,2,4*cr1+2
-	bne	99f
-
-	/* Turn off interrupts and data relocation. */
-	mfmsr	r7		/* Save MSR in r7 */
-	rlwinm	r4,r7,0,17,15
-	rlwinm	r4,r4,0,28,26	/* Turn off DR bit */
+	cmplwi	r4,0x0008
+	beq	thisIs750
+	li	r3,-1
+	blr
+	
+thisIs750:
+	/* Get the current enable bit of the L2CR into r4 */
+	mfspr	r4,L2CR
+	mfmsr	r7
+	
+	/* See if we want to perform a global inval this time. */
+	rlwinm	r6,r3,0,10,10	/* r6 contains the new invalidate bit */
+	rlwinm.	r5,r3,0,0,0	/* r5 contains the new enable bit */
+	rlwinm	r3,r3,0,11,9	/* Turn off the invalidate bit */
+	rlwimi	r3,r4,0,0,0	/* Keep the enable bit the same as it was. */
+	bne	dontDisableCache /* Only disable the cache if L2CRApply
+				    has the enable bit off */
+
+disableCache:
+	/* Disable the cache.  First, we turn off interrupts.
+	   An interrupt while we are flushing the cache could bring
+	   in data which may not get properly flushed. */
+	rlwinm	r4,r7,0,17,15	/* Turn off EE bit */
 	sync
 	mtmsr	r4
 	sync
-
-	/* Get the current enable bit of the L2CR into r4 */
-	mfspr	r4,L2CR
 	
-	/* Tweak some bits */
-	rlwinm	r5,r3,0,0,0		/* r5 contains the new enable bit */
-	rlwinm	r3,r3,0,11,9		/* Turn off the invalidate bit */
-	rlwinm	r3,r3,0,1,31		/* Turn off the enable bit */
-
-	/* Check to see if we need to flush */
-	rlwinm.	r4,r4,0,0,0
-	beq	2f
-
-	/* Flush the cache. First, read the first 4MB of memory (physical) to
-	 * put new data in the cache.  (Actually we only need
-	 * the size of the L2 cache plus the size of the L1 cache, but 4MB will
-	 * cover everything just to be safe).
-	 */
-		
-	 /**** Might be a good idea to set L2DO here - to prevent instructions
-	       from getting into the cache.  But since we invalidate
-	       the next time we enable the cache it doesn't really matter.
-	  ****/
-
-	lis	r4,0x0002
+/*
+	Now, read the first 2MB of memory to put new data in the cache.
+	(Actually we only need the size of the L2 cache plus the size
+	of the L1 cache, but 2MB will cover everything just to be safe).
+*/
+	lis	r4,0x0001
 	mtctr	r4
-	li	r4,0
-1:
-	lwzx	r0,r0,r4
-	addi	r4,r4,32		/* Go to start of next cache line */
+	lis	r4,KERNELBASE@h
+1:	lwzx	r0,r0,r4
+	addi	r4,r4,0x0020		/* Go to start of next cache line */
 	bdnz	1b
 	
-	/* Now, flush the first 4MB of memory */
-	lis	r4,0x0002
+	/* Now, flush the first 2MB of memory */
+	lis	r4,0x0001
 	mtctr	r4
-	li	r4,0
+	lis	r4,KERNELBASE@h
 	sync
-1:
-	dcbf	r0,r4
-	addi	r4,r4,32		/* Go to start of next cache line */
-	bdnz	1b
-
-2:
-	/* Set up the L2CR configuration bits (and switch L2 off) */
+2:	dcbf	r0,r4
+	addi	r4,r4,0x0020	/* Go to start of next cache line */
+	bdnz	2b
+	
+	/* Turn off the L2CR enable bit. */
+	rlwinm	r3,r3,0,1,31
+	
+dontDisableCache:
+	/* Set up the L2CR configuration bits */
 	sync
 	mtspr	L2CR,r3
 	sync
 
-	/* Before we perform the global invalidation, we must disable dynamic
-	 * power management via HID0[DPM] to work around a processor bug where
-	 * DPM can possibly interfere with the state machine in the processor
-	 * that invalidates the L2 cache tags.
-	 */
-	mfspr	r8,HID0			/* Save HID0 in r8 */
-	rlwinm	r4,r8,0,12,10		/* Turn off HID0[DPM] */
-	sync
-	mtspr	HID0,r4			/* Disable DPM */
+	/* Reenable interrupts if necessary. */
+	mtmsr	r7
 	sync
-
+	
+	cmplwi	r6,0
+	beq	noInval
+	
 	/* Perform a global invalidation */
 	oris	r3,r3,0x0020
 	sync
 	mtspr	L2CR,r3
 	sync
-	isync				/* For errata */
 
 	/* Wait for the invalidation to complete */
 3:	mfspr	r3,L2CR
@@ -740,38 +636,25 @@
 	mtspr	L2CR,r3
 	sync
 	
-	/* Restore HID0[DPM] to whatever it was before */
-	sync
-	mtspr	1008,r8
-	sync
-
+noInval:
 	/* See if we need to enable the cache */
 	cmplwi	r5,0
-	beq	4f
+	beqlr
 
 	/* Enable the cache */
 	oris	r3,r3,0x8000
 	mtspr	L2CR,r3
 	sync
-
-	/* Restore MSR (restores EE and DR bits to original state) */
-4:	sync
-	mtmsr	r7
-	sync
-	blr
-
-99:	li	r3,-1
 	blr
 
 _GLOBAL(_get_L2CR)
 	/* Make sure this is a 750 chip */
 	mfspr	r3,PVR
-	srwi	r3,r3,16
-	cmpwi	r3,0x0008
-	cmpwi	cr1,r3,0x000c
+	rlwinm	r3,r3,16,16,31
+	cmplwi	r3,0x0008
 	li	r3,0
-	cror	2,2,4*cr1+2
 	bnelr
+	
 	/* Return the L2CR contents */
 	mfspr	r3,L2CR
 	blr
@@ -779,6 +662,16 @@
 /* --- End of PowerLogix code ---
  */
 
+/*
+_GLOBAL(_get_L2CR)
+	mfspr	r3,L2CR
+	blr
+
+_GLOBAL(_set_L2CR)
+	mtspr	L2CR,r3
+	blr
+		
+*/
 
 /*
  * These are used in the alignment trap handler when emulating
@@ -1036,7 +929,11 @@
 	.long sys_getresuid	/* 165 */
 	.long sys_query_module
 	.long sys_poll
+#ifdef CONFIG_NFSD
 	.long sys_nfsservctl
+#else
+	.long sys_ni_syscall
+#endif		
 	.long sys_setresgid
 	.long sys_getresgid	/* 170 */
 	.long sys_prctl
@@ -1058,18 +955,4 @@
 	.long sys_ni_syscall		/* streams1 */
 	.long sys_ni_syscall		/* streams2 */
 	.long sys_vfork
-	.long sys_ni_syscall		/* 190 */	/* MacOnLinux - old */
-	.long sys_ni_syscall		/* 191 */	/* Unused */
-	.long sys_ni_syscall		/* 192 - reserved - mmap2 */
-	.long sys_ni_syscall		/* 193 - reserved - truncate64 */
-	.long sys_ni_syscall		/* 194 - reserved - ftruncate64 */
-	.long sys_ni_syscall		/* 195 - reserved - stat64 */
-	.long sys_ni_syscall		/* 196 - reserved - lstat64 */
-	.long sys_ni_syscall		/* 197 - reserved - fstat64 */
-	.long sys_pciconfig_read	/* 198 */
-	.long sys_pciconfig_write 	/* 199 */
-	.long sys_pciconfig_iobase 	/* 200 */
-	.long sys_ni_syscall		/* 201 - reserved - MacOnLinux - new */
-	.rept NR_syscalls-201
-		.long sys_ni_syscall
-	.endr
+	.space (NR_syscalls-183)*4
diff -urN linux.orig/arch/ppc/kernel/mk_defs.c linux/arch/ppc/kernel/mk_defs.c
--- linux.orig/arch/ppc/kernel/mk_defs.c	Fri Nov  2 17:39:05 2001
+++ linux/arch/ppc/kernel/mk_defs.c	Thu Jul 11 15:43:29 2002
@@ -8,7 +8,7 @@
  * #defines from the assembly-language output.
  */
 
-#include <linux/config.h>
+#include <stddef.h>
 #include <linux/signal.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
@@ -22,6 +22,7 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/processor.h>
+#include <asm/pf-compat.h>
 
 #define DEFINE(sym, val) \
 	asm volatile("\n#define\t" #sym "\t%0" : : "i" (val))
@@ -43,18 +44,11 @@
 	DEFINE(PGD, offsetof(struct mm_struct, pgd));
 	DEFINE(LAST_SYSCALL, offsetof(struct thread_struct, last_syscall));
 	DEFINE(PT_REGS, offsetof(struct thread_struct, regs));
-	DEFINE(PT_TRACESYS, PT_TRACESYS);
+	DEFINE(PF_TRACESYS, PF_TRACESYS);
 	DEFINE(TASK_FLAGS, offsetof(struct task_struct, flags));
-	DEFINE(TASK_PTRACE, offsetof(struct task_struct, ptrace));
 	DEFINE(NEED_RESCHED, offsetof(struct task_struct, need_resched));
 	DEFINE(TSS_FPR0, offsetof(struct thread_struct, fpr[0]));
 	DEFINE(TSS_FPSCR, offsetof(struct thread_struct, fpscr));
-#ifdef CONFIG_ALTIVEC
-	DEFINE(TSS_VR0, offsetof(struct thread_struct, vr[0]));
-	DEFINE(TSS_VRSAVE, offsetof(struct thread_struct, vrsave));
-	DEFINE(TSS_VSCR, offsetof(struct thread_struct, vscr));
-#endif /* CONFIG_ALTIVEC */
-
 	/* Interrupt register frame */
 	DEFINE(TASK_UNION_SIZE, sizeof(union task_union));
 	DEFINE(STACK_FRAME_OVERHEAD, STACK_FRAME_OVERHEAD);
diff -urN linux.orig/arch/ppc/kernel/open_pic.c linux/arch/ppc/kernel/open_pic.c
--- linux.orig/arch/ppc/kernel/open_pic.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/open_pic.c	Thu Jul 11 15:43:29 2002
@@ -1,126 +1,48 @@
-/*
- * open_pic.c
- *
- * Common support routines for platforms with an OpenPIC interrupt controller
- *
- */
-
 #include <linux/stddef.h>
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/signal.h>
 #include <linux/openpic.h>
 #include <asm/irq.h>
-#include <asm/processor.h>
 #include "open_pic.h"
 #include "i8259.h"
 
-extern volatile unsigned char *chrp_int_ack_special;
-
-void open_pic_do_IRQ(struct pt_regs *regs, int cpu, int isfake)
-{
-	int irq;
-        int openpic_eoi_done = 0;
-
 #ifdef __SMP__
-        {
-                unsigned int loops = 1000000;
-                while (test_bit(0, &global_irq_lock)) {
-                        if (smp_processor_id() == global_irq_holder) {
-                                printk("uh oh, interrupt while we hold global irq lock!\n");
-#ifdef CONFIG_XMON
-                                xmon(0);
-#endif
-                                break;
-                        }
-                        if (loops-- == 0) {
-                                printk("do_IRQ waiting for irq lock (holder=%d)\n", global_irq_holder);
-#ifdef CONFIG_XMON
-                                xmon(0);
-#endif
-                        }
-                }
-        }
+void openpic_ipi_action(int cpl, void *dev_id, struct pt_regs *regs)
+{
+	smp_message_recv(cpl-OPENPIC_VEC_IPI);
+}
 #endif /* __SMP__ */
-	
-        irq = openpic_irq(smp_processor_id());
-	/* make sure open_pic.irq_offset is set to something!
-	 * do we really need the _MACH_Pmac test??
-	 */
-        if (!(_machine == _MACH_Pmac) && (irq == open_pic.irq_offset))
-        {
-                /*
-                 * This magic address generates a PCI IACK cycle.
-                 *
-                 * This should go in the above mask/ack code soon. -- Cort
-                 */
-		if ( chrp_int_ack_special )
-			irq = *chrp_int_ack_special;
-#ifndef CONFIG_PMAC
-		else
-			irq = i8259_irq(0);
-#endif
-                /*
-                 * Acknowledge as soon as possible to allow i8259
-                 * interrupt nesting                         */
-                openpic_eoi(smp_processor_id());
-                openpic_eoi_done = 1;
-        }
-        if (irq == OPENPIC_VEC_SPURIOUS)
-        {
-                /*
-                 * Spurious interrupts should never be
-                 * acknowledged
-                 */
-                ppc_spurious_interrupts++;
-                openpic_eoi_done = 1;
-		goto out;
-        }
 
-        if (irq < 0)
-        {
-                printk(KERN_DEBUG "Bogus interrupt %d from PC = %lx\n",
-                       irq, regs->nip);
-                ppc_spurious_interrupts++;
-        }
-	else
-        {
-		ppc_irq_dispatch_handler( regs, irq );
-	}
-out:
-        if (!openpic_eoi_done)
-                openpic_eoi(smp_processor_id());
+void chrp_mask_and_ack_irq(unsigned int irq_nr)
+{
+	if ((_machine != _MACH_gemini) && is_8259_irq(irq_nr))
+		i8259_pic.mask_and_ack(irq_nr);
 }
 
-#ifdef __SMP__
-void openpic_ipi_action(int cpl, void *dev_id, struct pt_regs *regs)
+static void chrp_mask_irq(unsigned int irq_nr)
 {
-	smp_message_recv(cpl-OPENPIC_VEC_IPI);
+	if ((_machine != _MACH_gemini) && is_8259_irq(irq_nr))
+		i8259_pic.disable(irq_nr);
+	else
+		openpic_disable_irq(irq_nr-open_pic.irq_offset);
 }
-#endif /* __SMP__ */
 
+static void chrp_unmask_irq(unsigned int irq_nr)
+{
+	if ((_machine != _MACH_gemini) && is_8259_irq(irq_nr))
+		i8259_pic.enable(irq_nr);
+	else
+		openpic_enable_irq(irq_nr-open_pic.irq_offset);
+}
 
 struct hw_interrupt_type open_pic = {
 	" OpenPIC  ",
 	NULL,
 	NULL,
 	NULL,
-	openpic_enable_irq,
-	openpic_disable_irq,
-	/* Theorically, the mask&ack should be NULL for OpenPIC. However, doing
-	 * so shows tons of bogus interrupts coming in.
-	 * This problem is apparently due to the common code always calling
-	 * unmask(). I apparently (need more test) fixed it in the 2.4 new IRQ
-	 * management by cleanly implementing the handler's end() function, so
-	 * neither mask nor unmask are needed. In the meantime, the fix below will
-	 * work for 2.2 -Benh
-	 *
-	 * Hopefully this will fix my bogus interrups on MTX
-	 * I merged everthing together so we don't have the same code in three
-	 * places. This might cause stability problems, but I'd rather
-	 * get it right once than three different times because someone forgot
-	 * to make the same change to PReP or something --Troy
-	 */
-	openpic_disable_irq,
+	chrp_unmask_irq,
+	chrp_mask_irq,
+	chrp_mask_and_ack_irq,
 	0
 };
diff -urN linux.orig/arch/ppc/kernel/open_pic.h linux/arch/ppc/kernel/open_pic.h
--- linux.orig/arch/ppc/kernel/open_pic.h	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/open_pic.h	Thu Jul 11 15:43:29 2002
@@ -6,7 +6,6 @@
 
 extern struct hw_interrupt_type open_pic;
 
-void open_pic_do_IRQ(struct pt_regs *regs, int cpu, int isfake);
 void openpic_ipi_action(int cpl, void *dev_id, struct pt_regs *regs);
 void openpic_enable_IPI(u_int ipi);
 void do_openpic_setup_cpu(void);
diff -urN linux.orig/arch/ppc/kernel/openpic.c linux/arch/ppc/kernel/openpic.c
--- linux.orig/arch/ppc/kernel/openpic.c	Fri Nov  2 17:39:05 2001
+++ linux/arch/ppc/kernel/openpic.c	Thu Jul 11 15:43:29 2002
@@ -5,11 +5,6 @@
  *
  *  Fixed up IPI and restructured a bit
  *    Cort Dougan <cort@ppc.kernel.org>
- *
- *  Added initialisation code for Apple Core99 machines, tweaked a few things
- *  to avoid bogus interrupts and to make sure the disable function exits with
- *  the interrupt actually masked. --BenH
- *  Todo: map interrupts to all available CPUs after the ack round
  * 
  *  This file is subject to the terms and conditions of the GNU General Public
  *  License.  See the file COPYING in the main directory of this archive
@@ -26,16 +21,11 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include "open_pic.h"
-#ifdef __powerpc__
-#include <asm/prom.h>
-#endif
 
 #define REGISTER_DEBUG
 #undef REGISTER_DEBUG
 
-#ifdef __powerpc__
-extern int use_of_interrupt_tree;
-#endif
+#define OPENPIC_SENSE_POLARITY			0x00800000	/* Undoc'd */
 
 volatile struct OpenPIC *OpenPIC = NULL;
 u_int OpenPIC_NumInitSenses __initdata = 0;
@@ -92,7 +82,7 @@
  *  I/O functions
  */
 #ifdef __i386__
-static inline u_int in_le32(volatile u_int *addr)
+static inline u_int ld_le32(volatile u_int *addr)
 {
 	return *addr;
 }
@@ -107,7 +97,7 @@
 {
 	u_int val;
 
-	val = in_le32(addr);
+	val = ld_le32(addr);
 #ifdef REGISTER_DEBUG
 	printk("openpic_read(0x%08x) = 0x%08x\n", (u_int)addr, val);
 #endif
@@ -154,9 +144,6 @@
 {
 	openpic_setfield(addr, OPENPIC_MASK);
 	/* wait until it's not in use */
-	/* BenH: Is this code really enough ? I would rather check the result
-	 *       and eventually retry ...
-	 */
 	while (openpic_read(addr) & OPENPIC_ACTIVITY);
 	openpic_writefield(addr, mask | OPENPIC_MASK, field | OPENPIC_MASK);
 }
@@ -164,20 +151,7 @@
 /*
  *  Initialize the OpenPIC
  */
-
-/* PoweMac note:
- *
- * With BootX, we consider the controller as beeing already initialized by MacOS
- * and we only mask out interrupts.
- * With OF booting, we initialize the interrupts that we find in the device tree,
- * other ones are just masked out.
- * Note: We might want to adjust priorities too.
- */
-
-/* Not an init func, called on pbook wakeup --BenH */
-void
-__init
-openpic_init(int main_pic)
+__initfunc(void openpic_init(int main_pic))
 {
 	u_int t, i;
 	u_int timerfreq;
@@ -207,16 +181,13 @@
 		      OPENPIC_FEATURE_LAST_SOURCE_SHIFT) + 1;
 	printk("OpenPIC Version %s (%d CPUs and %d IRQ sources) at %p\n", version,
 	       NumProcessors, NumSources, OpenPIC);
-	/* Apple's OpenPIC is an IBM MPIC without the timer. */
-	if (_machine != _MACH_Pmac) {
-		timerfreq = openpic_read(&OpenPIC->Global.Timer_Frequency);
-		printk("OpenPIC timer frequency is ");
-		if (timerfreq)
-			printk("%d Hz\n", timerfreq);
-		else
-			printk("not set\n");
-	}
-	
+	timerfreq = openpic_read(&OpenPIC->Global.Timer_Frequency);
+	printk("OpenPIC timer frequency is ");
+	if (timerfreq)
+		printk("%d Hz\n", timerfreq);
+	else
+		printk("not set\n");
+
 	if ( main_pic )
 	{
 		/* Initialize timer interrupts */
@@ -229,60 +200,24 @@
 	    
 		/* Initialize IPI interrupts */
 		for (i = 0; i < OPENPIC_NUM_IPI; i++) {
-			openpic_initipi(i, 10+i, OPENPIC_VEC_IPI+i);
+			openpic_initipi(i, 10, OPENPIC_VEC_IPI+i);
 		}
 	    
-		if (_machine != _MACH_Pmac) {
-			/* Initialize external interrupts */
-			for (i = 0; i < NumSources; i++) {
-			    /* Enabled, Priority 8 */
-			    openpic_initirq(i, 8, open_pic.irq_offset+i, 0,
-				i < OpenPIC_NumInitSenses ? OpenPIC_InitSenses[i] : 1);
-			    /* Processor 0 */
-			    openpic_mapirq(i, 1<<0);
-			}
-		} else {
-			/* Prevent any interrupt from occurring during initialisation.
-			 * Hum... I believe this is not necessary, Apple does that in
-			 * Darwin's PowerExpress code.
-			 */
-			openpic_set_priority(0, 0xf);
-
-			/* First disable all interrupts and map them to CPU 0 */
-			for (i = 0; i < NumSources; i++) {
-				openpic_disable_irq(i);
-				openpic_mapirq(i, 1<<0);
-			}
-			
-			/* If we use the device tree, then lookup all interrupts and
-			 * initialize them according to sense infos found in the tree
-			 */
-			if (use_of_interrupt_tree) {
-				struct device_node* np = find_all_nodes();
-			    	while(np) {
-				    int j, pri;
-				    pri = strcmp(np->name, "programmer-switch") ? 2 : 7;
-				    for (j=0;j<np->n_intrs;j++) {
-    				    	openpic_initirq(	np->intrs[j].line,
-    				    				pri,
-    				    				np->intrs[j].line,
-    				    				0,
-    				    				np->intrs[j].sense);
-    				    	irq_desc[np->intrs[j].line].level = np->intrs[j].sense;
-    				    }
-				    np = np->next;
-				}
-			} else {
-				/* Fixme: read level value from controller */
-				printk("openpic: WARNING, openpic running without interrupt tree\n");
-			}
+		/* Initialize external interrupts */
+		for (i = 0; i < NumSources; i++) {
+			/* Enabled, Priority 8 */
+			openpic_initirq(i, 8, open_pic.irq_offset+i, 0,
+					i < OpenPIC_NumInitSenses ? OpenPIC_InitSenses[i] : 1);
+			/* Processor 0 */
+			openpic_mapirq(i, 1<<0);
 		}
-
+	    
 		/* Initialize the spurious interrupt */
 		openpic_set_spurious(OPENPIC_VEC_SPURIOUS);
 
 		/* Gemini has no i8259 */
-		if (( _machine != _MACH_gemini ) && (_machine != _MACH_Pmac)) {
+		if ( _machine != _MACH_gemini )
+		{
 			/* SIOint (8259 cascade) is special */
 			openpic_initirq(0, 8, open_pic.irq_offset, 1, 1);
 			openpic_mapirq(0, 1<<0);
@@ -292,14 +227,6 @@
 		}
 		openpic_set_priority(0, 0);
 		openpic_disable_8259_pass_through();
-
-		/* We ack pending interrupts to avoid blocking them */
-		if (_machine == _MACH_Pmac) {
-			for (i = 0; i < NumSources; i++) {
-				(void)openpic_irq(0);
-				openpic_eoi(0);
-			}
-		}
 	}
 }
 
@@ -311,10 +238,6 @@
 {
 	openpic_setfield(&OpenPIC->Global.Global_Configuration0,
 			 OPENPIC_CONFIG_RESET);
-	/* Wait for reset to complete */
-	while(openpic_readfield(&OpenPIC->Global.Global_Configuration0,
-    			OPENPIC_CONFIG_RESET))
-    		;
 }
 
 
@@ -360,7 +283,6 @@
 {
 	check_arg_cpu(cpu);
 	openpic_write(&OpenPIC->THIS_CPU.EOI, 0);
-	(void)openpic_read(&OpenPIC->THIS_CPU.EOI);
 }
 
 
@@ -465,12 +387,12 @@
 	
 	for ( i = 0; i < OPENPIC_NUM_IPI ; i++ )
 		  openpic_enable_IPI(i);
-
+#if 0	
 	/* let the openpic know we want intrs */
 	for ( i = 0; i < NumSources ; i++ )
 		openpic_mapirq(i, openpic_read(&OpenPIC->Source[i].Destination)
 			       | (1<<smp_processor_id()) );
-
+#endif	
 	openpic_set_priority(smp_processor_id(), 0);
 }    
 
@@ -506,43 +428,14 @@
  */
 void openpic_enable_irq(u_int irq)
 {
-	/* on SMP, we get IPI vector numbers here, we should handle them
-	 * or at least ignore them.
-	 */
-	if (irq < 0 || irq >= NumSources)
-		return;
+	check_arg_irq(irq);
 	openpic_clearfield(&OpenPIC->Source[irq].Vector_Priority, OPENPIC_MASK);
-	/* make sure mask gets to controller before we return to user */
-	do {
-		mb();
-	} while(openpic_readfield(&OpenPIC->Source[irq].Vector_Priority,
-			OPENPIC_MASK));
-}
-
-u_int openpic_get_enable(u_int irq)
-{
-	if (irq < 0 || irq >= NumSources)
-		return 0;
-	return !openpic_readfield(&OpenPIC->Source[irq].Vector_Priority,
-			OPENPIC_MASK);
 }
 
 void openpic_disable_irq(u_int irq)
 {
-	u32 vp;
-	
-	/* on SMP, we get IPI vector numbers here, we should handle them
-	 * or at least ignore them.
-	 */
-	if (irq < 0 || irq >= NumSources)
-		return;
+	check_arg_irq(irq);
 	openpic_setfield(&OpenPIC->Source[irq].Vector_Priority, OPENPIC_MASK);
-	/* make sure mask gets to controller before we return to user */
-	do {
-		mb();  /* sync is probably useless here */
-		vp = openpic_readfield(&OpenPIC->Source[irq].Vector_Priority,
-    			OPENPIC_MASK | OPENPIC_ACTIVITY);
-	} while((vp & OPENPIC_ACTIVITY) && !(vp & OPENPIC_MASK));
 }
 
 /*
@@ -561,11 +454,10 @@
 	check_arg_vec(vec);
 	openpic_safe_writefield(&OpenPIC->Source[irq].Vector_Priority,
 				OPENPIC_PRIORITY_MASK | OPENPIC_VECTOR_MASK |
-				OPENPIC_POLARITY_MASK | OPENPIC_SENSE_MASK,
+				OPENPIC_SENSE_POLARITY | OPENPIC_SENSE_LEVEL,
 				(pri << OPENPIC_PRIORITY_SHIFT) | vec |
-				(pol ? OPENPIC_POLARITY_POSITIVE :
-			    		OPENPIC_POLARITY_NEGATIVE) |
-				(sense ? OPENPIC_SENSE_LEVEL : OPENPIC_SENSE_EDGE));
+				(pol ? OPENPIC_SENSE_POLARITY : 0) |
+				(sense ? OPENPIC_SENSE_LEVEL : 0));
 }
 
 /*
@@ -589,7 +481,6 @@
 				OPENPIC_SENSE_LEVEL,
 				(sense ? OPENPIC_SENSE_LEVEL : 0));
 }
-
 #ifdef CONFIG_PMAC_PBOOK
 static u32 save_ipi_vp[OPENPIC_NUM_IPI];
 static u32 save_irq_src_vp[OPENPIC_MAX_SOURCES];
diff -urN linux.orig/arch/ppc/kernel/pci.c linux/arch/ppc/kernel/pci.c
--- linux.orig/arch/ppc/kernel/pci.c	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/kernel/pci.c	Thu Jul 11 15:43:29 2002
@@ -10,20 +10,15 @@
 #include <linux/init.h>
 #include <linux/config.h>
 #include <linux/openpic.h>
-#include <linux/capability.h>
-#include <linux/sched.h>
-#include <linux/errno.h>
 
 #include <asm/processor.h>
 #include <asm/io.h>
 #include <asm/prom.h>
 #include <asm/pci-bridge.h>
-#include <asm/pci.h>
 #include <asm/residual.h>
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/gg2.h>
-#include <asm/uaccess.h>
 
 #include "pci.h"
 
@@ -98,7 +93,7 @@
 
 	for (; node != 0;node = node->sibling) {
 		class_code = (unsigned int *) get_property(node, "class-code", 0);
-		if(class_code && (*class_code >> 8) == PCI_CLASS_BRIDGE_PCI)
+		if((*class_code >> 8) == PCI_CLASS_BRIDGE_PCI)
 			fix_intr(node->child, dev);
 		reg = (unsigned int *) get_property(node, "reg", 0);
 		if (reg == 0 || ((reg[0] >> 8) & 0xff) != dev->devfn)
@@ -110,156 +105,3 @@
 	}
 }
 #endif
-
-
-void *
-pci_dev_io_base(unsigned char bus, unsigned char devfn, int physical)
-{
-	if (!ppc_md.pci_dev_io_base) {
-		/* Please, someone fix this for non-pmac machines, we
-		 * need either the virtual or physical PCI IO base
-		 */
-		return 0;
-	}
-	return ppc_md.pci_dev_io_base(bus, devfn, physical);
-}
-
-void *
-pci_dev_mem_base(unsigned char bus, unsigned char devfn)
-{
-	/* Default memory base is 0 (1:1 mapping) */
-	if (!ppc_md.pci_dev_mem_base) {
-		/* Please, someone fix this for non-pmac machines.*/
-		return 0;
-	}
-	return ppc_md.pci_dev_mem_base(bus, devfn);
-}
-
-/* Returns the root-bridge number (Uni-N number) of a device */
-int
-pci_dev_root_bridge(unsigned char bus, unsigned char devfn)
-{
-	/* Defaults to 0 */
-	if (!ppc_md.pci_dev_root_bridge)
-		return 0;
-	return ppc_md.pci_dev_root_bridge(bus, devfn);
-}
-
-/*
- * Those syscalls are derived from the Alpha versions, they
- * allow userland apps to retreive the per-device iobase and
- * mem-base. They also provide wrapper for userland to do
- * config space accesses.
- * The "host_number" returns the number of the Uni-N sub bridge
- */
-
-asmlinkage int
-sys_pciconfig_read(unsigned long bus, unsigned long dfn,
-		   unsigned long off, unsigned long len,
-		   unsigned char *buf)
-{
-	unsigned char ubyte;
-	unsigned short ushort;
-	unsigned int uint;
-	long err = 0;
-
-	if (!capable(CAP_SYS_ADMIN))
-		return -EPERM;
-	if (!pcibios_present())
-		return -ENOSYS;
-	
-	switch (len) {
-	case 1:
-		err = pcibios_read_config_byte(bus, dfn, off, &ubyte);
-		put_user(ubyte, buf);
-		break;
-	case 2:
-		err = pcibios_read_config_word(bus, dfn, off, &ushort);
-		put_user(ushort, (unsigned short *)buf);
-		break;
-	case 4:
-		err = pcibios_read_config_dword(bus, dfn, off, &uint);
-		put_user(uint, (unsigned int *)buf);
-		break;
-	default:
-		err = -EINVAL;
-		break;
-	}
-	return err;
-}
-
-asmlinkage int
-sys_pciconfig_write(unsigned long bus, unsigned long dfn,
-		    unsigned long off, unsigned long len,
-		    unsigned char *buf)
-{
-	unsigned char ubyte;
-	unsigned short ushort;
-	unsigned int uint;
-	long err = 0;
-
-	if (!capable(CAP_SYS_ADMIN))
-		return -EPERM;
-	if (!pcibios_present())
-		return -ENOSYS;
-
-	switch (len) {
-	case 1:
-		err = get_user(ubyte, buf);
-		if (err)
-			break;
-		err = pcibios_write_config_byte(bus, dfn, off, ubyte);
-		if (err != PCIBIOS_SUCCESSFUL) {
-			err = -EFAULT;
-		}
-		break;
-	case 2:
-		err = get_user(ushort, (unsigned short *)buf);
-		if (err)
-			break;
-		err = pcibios_write_config_word(bus, dfn, off, ushort);
-		if (err != PCIBIOS_SUCCESSFUL) {
-			err = -EFAULT;
-		}
-		break;
-	case 4:
-		err = get_user(uint, (unsigned int *)buf);
-		if (err)
-			break;
-		err = pcibios_write_config_dword(bus, dfn, off, uint);
-		if (err != PCIBIOS_SUCCESSFUL) {
-			err = -EFAULT;
-		}
-		break;
-	default:
-		err = -EINVAL;
-		break;
-	}
-	return err;
-}
-
-/* Provide information on locations of various I/O regions in physical
- * memory.  Do this on a per-card basis so that we choose the right
- * root bridge.
- * Note that the returned IO or memory base is a physical address
- */
-
-asmlinkage long
-sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn)
-{
-	long result = -EOPNOTSUPP;
-	
-	switch (which) {
-	case IOBASE_BRIDGE_NUMBER:
-		return (long)pci_dev_root_bridge(bus, devfn);
-	case IOBASE_MEMORY:
-		return (long)pci_dev_mem_base(bus, devfn);
-	case IOBASE_IO:
-		result = (long)pci_dev_io_base(bus, devfn, 1);
-		if (result == 0)
-			result = -EOPNOTSUPP;
-		break;
-	}
-
-	return result;
-}
diff -urN linux.orig/arch/ppc/kernel/pmac_pci.c linux/arch/ppc/kernel/pmac_pci.c
--- linux.orig/arch/ppc/kernel/pmac_pci.c	Fri Nov  2 17:39:05 2001
+++ linux/arch/ppc/kernel/pmac_pci.c	Thu Jul 11 15:43:29 2002
@@ -28,20 +28,6 @@
 struct bridge_data **bridges, *bridge_list;
 static int max_bus;
 
-struct uninorth_data {
-	struct device_node*	node;
-	volatile unsigned int*	cfg_addr;
-	volatile unsigned int*	cfg_data;
-	void*			iobase;
-	void*			iobase_phys;
-};
-
-static struct uninorth_data uninorth_bridges[3];
-static int uninorth_count;
-static int uninorth_default = -1;
- 
-
-
 static void add_bridges(struct device_node *dev, unsigned long *mem_ptr);
 
 /*
@@ -85,208 +71,6 @@
 	return 0;
 }
 
-/* This routines figures out on which root bridge a given PCI device
- * is attached.
- * 
- * WARNING: When passed the address of the bridge itself (11), it must
- *          return the AGP bus. Currently, it returns 0, which is by
- *          chance the AGP one. We may have to improve that however...
- */
-__pmac
-int
-pmac_pci_dev_root_bridge(unsigned char bus, unsigned char dev_fn)
-{
-	struct device_node *node, *bridge_node;
-	int bridge = uninorth_default;
-
-	if (uninorth_count == 0)
-		return 0;
-	if (bus == 0 && PCI_SLOT(dev_fn) < 11)
-		return 0;
-	
-	/* We look for the OF device corresponding to this bus/devfn pair. If we
-	 * don't find it, we default to the external PCI */
-	bridge_node = NULL;
-	node = find_pci_device_OFnode(bus, dev_fn & 0xf8);
-	if (node) {
-	    /* note: we don't stop on the first occurrence since we need to go
-             * up to the root bridge */
-	    do {
-		if (node->type && !strcmp(node->type, "pci") 
-			&& device_is_compatible(node, "uni-north"))
-			bridge_node = node;
-		node=node->parent;
-	    } while (node);
-	}
-	if (bridge_node) {
-	    int i;
-	    for (i=0;i<uninorth_count;i++)
-		if (uninorth_bridges[i].node == bridge_node) {
-		    bridge = i;
-		    break;
-		}
-	}
-
-	if (bridge == -1) {
-		printk(KERN_WARNING "pmac_pci: no default bridge !\n");
-		return 0;
-	}
-
-	return bridge;	
-}
-
-__pmac
-void *
-pmac_pci_dev_io_base(unsigned char bus, unsigned char devfn, int physical)
-{
-	int bridge = -1;
-	if (uninorth_count != 0)
-		bridge = pmac_pci_dev_root_bridge(bus, devfn);
-	if (bridge == -1) {
-		struct bridge_data *bp;
-
-		if (bus > max_bus || (bp = bridges[bus]) == 0)
-			return 0;
-		return physical ? bp->io_base_phys : bp->io_base;
-	}
-	return physical ? uninorth_bridges[bridge].iobase_phys
-		: uninorth_bridges[bridge].iobase;
-}
-
-__pmac
-void *
-pmac_pci_dev_mem_base(unsigned char bus, unsigned char devfn)
-{
-	return 0;
-}
-
-/* This function only works for bus 0, uni-N uses a different mecanism for
- * other busses (see below)
- */
-#define UNI_N_CFA0(devfn, off)	\
-	((1 << (unsigned long)PCI_SLOT(dev_fn)) \
-	| (((unsigned long)PCI_FUNC(dev_fn)) << 8) \
-	| (((unsigned long)(off)) & 0xFCUL))
-
-/* This one is for type 1 config accesses */
-#define UNI_N_CFA1(bus, devfn, off)	\
-	((((unsigned long)(bus)) << 16) \
-	|(((unsigned long)(devfn)) << 8) \
-	|(((unsigned long)(off)) & 0xFCUL) \
-	|1UL)
-	
-
-__pmac static
-unsigned int
-uni_north_access_data(unsigned char bus, unsigned char dev_fn,
-				unsigned char offset)
-{
-	int bridge;
-	unsigned int caddr;
-
-	bridge = pmac_pci_dev_root_bridge(bus, dev_fn);
-	if (bus == 0)
-		caddr = UNI_N_CFA0(dev_fn, offset);
-	else
-		caddr = UNI_N_CFA1(bus, dev_fn, offset);
-	
-	if (bridge == -1) {
-		printk(KERN_WARNING "pmac_pci: no default bridge !\n");
-		return 0;
-	}
-		
-	/* Uninorth will return garbage if we don't read back the value ! */
-	out_le32(uninorth_bridges[bridge].cfg_addr, caddr);
-	(void)in_le32(uninorth_bridges[bridge].cfg_addr);
-	/* Yes, offset is & 7, not & 3 ! */
-	return (unsigned int)(uninorth_bridges[bridge].cfg_data) + (offset & 0x07);
-}
-
-__pmac
-int uni_pcibios_read_config_byte(unsigned char bus, unsigned char dev_fn,
-				  unsigned char offset, unsigned char *val)
-{
-	unsigned int addr;
-	
-	*val = 0xff;
-	addr = uni_north_access_data(bus, dev_fn, offset);
-	if (!addr)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	*val = in_8((volatile unsigned char*)addr);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-__pmac
-int uni_pcibios_read_config_word(unsigned char bus, unsigned char dev_fn,
-				  unsigned char offset, unsigned short *val)
-{
-	unsigned int addr;
-	
-	*val = 0xffff;
-	addr = uni_north_access_data(bus, dev_fn, offset);
-	if (!addr)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	*val = in_le16((volatile unsigned short*)addr);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-__pmac
-int uni_pcibios_read_config_dword(unsigned char bus, unsigned char dev_fn,
-				   unsigned char offset, unsigned int *val)
-{
-	unsigned int addr;
-	
-	*val = 0xffff;
-	addr = uni_north_access_data(bus, dev_fn, offset);
-	if (!addr)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	*val = in_le32((volatile unsigned int*)addr);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-__pmac
-int uni_pcibios_write_config_byte(unsigned char bus, unsigned char dev_fn,
-				   unsigned char offset, unsigned char val)
-{
-	unsigned int addr;
-	
-	addr = uni_north_access_data(bus, dev_fn, offset);
-	if (!addr)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	out_8((volatile unsigned char *)addr, val);
-	(void)in_8((volatile unsigned char *)addr);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-__pmac
-int uni_pcibios_write_config_word(unsigned char bus, unsigned char dev_fn,
-				   unsigned char offset, unsigned short val)
-{
-	unsigned int addr;
-	
-	addr = uni_north_access_data(bus, dev_fn, offset);
-	if (!addr)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	out_le16((volatile unsigned short *)addr, val);
-	(void)in_le16((volatile unsigned short *)addr);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-__pmac
-int uni_pcibios_write_config_dword(unsigned char bus, unsigned char dev_fn,
-				    unsigned char offset, unsigned int val)
-{
-	unsigned int addr;
-	
-	addr = uni_north_access_data(bus, dev_fn, offset);
-	if (!addr)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	out_le32((volatile unsigned int *)addr, val);
-	(void)in_le32((volatile unsigned int *)addr);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-
 __pmac
 int pmac_pcibios_read_config_byte(unsigned char bus, unsigned char dev_fn,
 				  unsigned char offset, unsigned char *val)
@@ -576,80 +360,6 @@
 	       bp->io_base);
 }
 
-#define GRACKLE_PICR1_STG		0x00000040
-#define GRACKLE_PICR1_LOOPSNOOP		0x00000010
-
-/* N.B. this is called before bridges is initialized, so we can't
-   use grackle_pcibios_{read,write}_config_dword. */
-static inline void grackle_set_stg(struct bridge_data *bp, int enable)
-{
-	unsigned int val;
-
-	out_be32(bp->cfg_addr, GRACKLE_CFA(0, 0, 0xa8));
-	val = in_le32((volatile unsigned int *)bp->cfg_data);
-	val = enable? (val | GRACKLE_PICR1_STG) :
-		(val & ~GRACKLE_PICR1_STG);
-	out_be32(bp->cfg_addr, GRACKLE_CFA(0, 0, 0xa8));
-	out_le32((volatile unsigned int *)bp->cfg_data, val);
-}
-
-static inline void grackle_set_loop_snoop(struct bridge_data *bp, int enable)
-{
-	unsigned int val;
-
-	out_be32(bp->cfg_addr, GRACKLE_CFA(0, 0, 0xa8));
-	val = in_le32((volatile unsigned int *)bp->cfg_data);
-	val = enable? (val | GRACKLE_PICR1_LOOPSNOOP) :
-		(val & ~GRACKLE_PICR1_LOOPSNOOP);
-	out_be32(bp->cfg_addr, GRACKLE_CFA(0, 0, 0xa8));
-	out_le32((volatile unsigned int *)bp->cfg_data, val);
-}
-
-static int __init
-fixup_one_level_bus_range(struct device_node *node, int higher)
-{
-	for (; node != 0;node = node->sibling) {
-		int * bus_range;
-		unsigned int *class_code;			
-		int len;
-
-		/* For PCI<->PCI bridges or CardBus bridges, we go down */
-		class_code = (unsigned int *) get_property(node, "class-code", 0);
-		if (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&
-			(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))
-			continue;
-		bus_range = (int *) get_property(node, "bus-range", &len);
-		if (bus_range != NULL && len > 2 * sizeof(int)) {
-			if (bus_range[1] > higher)
-				higher = bus_range[1];
-		}
-		higher = fixup_one_level_bus_range(node->child, higher);
-	}
-	return higher;
-}
-
-/* This routine fixes the "bus-range" property of all bridges in the
- * system since they tend to have their "last" member wrong on macs
- * 
- * Note that the bus numbers manipulated here are OF bus numbers, they
- * are not Linux bus numbers.
- */
-static void __init
-fixup_bus_range(struct device_node *bridge)
-{
-	int * bus_range;
-	int len;
-	
-	/* Lookup the "bus-range" property for the hose */		
-	bus_range = (int *) get_property(bridge, "bus-range", &len);
-	if (bus_range == NULL || len < 2 * sizeof(int)) {
-		printk(KERN_WARNING "Can't get bus-range for %s\n",
-			       bridge->full_name);
-		return;
-	}
-	bus_range[1] = fixup_one_level_bus_range(bridge->child, bus_range[1]);
-}
-
 __initfunc(unsigned long pmac_find_bridges(unsigned long mem_start, unsigned long mem_end))
 {
 	int bus;
@@ -689,7 +399,6 @@
 			       dev->full_name);
 			continue;
 		}
-		fixup_bus_range(dev);
 		bus_range = (int *) get_property(dev, "bus-range", &len);
 		if (bus_range == NULL || len < 2 * sizeof(int)) {
 			printk(KERN_WARNING "Can't get bus-range for %s\n",
@@ -702,54 +411,21 @@
 			printk(KERN_INFO "PCI buses %d..%d", bus_range[0],
 			       bus_range[1]);
 		printk(" controlled by %s at %x\n", dev->name, addr->address);
-		if (device_is_compatible(dev, "uni-north")) {
-			int i = uninorth_count++;
-			uninorth_bridges[i].cfg_addr = ioremap(addr->address + 0x800000, 0x1000);
-			uninorth_bridges[i].cfg_data = ioremap(addr->address + 0xc00000, 0x1000);
-			uninorth_bridges[i].node = dev;
-			uninorth_bridges[i].iobase_phys = (void *)addr->address;
-			/* is 0x10000 enough for io space ? */
-			uninorth_bridges[i].iobase = (void *)ioremap(addr->address, 0x10000);
-			/* XXX This is the bridge with the PCI expansion bus. This is also the
-			 * address of the bus that will receive type 1 config accesses and io
-			 * accesses. Appears to be correct for iMac DV and G4 Sawtooth too.
-			 * That means that we cannot do io cycles on the AGP bus nor the internal
-			 * ethernet/fw bus. Fortunately, they appear not to be needed on iMac DV
-			 * and G4 neither.
-			 */
-			if (addr->address == 0xf2000000)
-				uninorth_default = i;
-			else
-				continue;
-		}
 		bp = (struct bridge_data *) *mem_ptr;
 		*mem_ptr += sizeof(struct bridge_data);
-		if (device_is_compatible(dev, "uni-north")) {
-			bp->cfg_addr = 0;
-			bp->cfg_data = 0;
-			bp->io_base = uninorth_bridges[uninorth_count-1].iobase;
-			bp->io_base_phys = uninorth_bridges[uninorth_count-1].iobase_phys;
-		} else if (strcmp(dev->name, "pci") == 0) {
-			/* XXX assume this is a mpc106 (grackle) */
-			bp->cfg_addr = (volatile unsigned int *)
-				ioremap(0xfec00000, 0x1000);
-			bp->cfg_data = (volatile unsigned char *)
-				ioremap(0xfee00000, 0x1000);
-                        bp->io_base = (void *) ioremap(0xfe000000, 0x20000);
-                        bp->io_base_phys = (void *)0xfe000000;
-                        if (machine_is_compatible("AAPL,PowerBook1998"))
-                        	grackle_set_loop_snoop(bp, 1);
-#if 0 			/* Disabled for now, HW problems ??? */
-			grackle_set_stg(bp, 1);
-#endif
-		} else {
-			/* a `bandit' or `chaos' bridge */
+		if (strcmp(dev->name, "pci") != 0) {
 			bp->cfg_addr = (volatile unsigned int *)
 				ioremap(addr->address + 0x800000, 0x1000);
 			bp->cfg_data = (volatile unsigned char *)
 				ioremap(addr->address + 0xc00000, 0x1000);
 			bp->io_base = (void *) ioremap(addr->address, 0x10000);
-			bp->io_base_phys = (void *)addr->address;
+		} else {
+			/* XXX */
+			bp->cfg_addr = (volatile unsigned int *)
+				ioremap(0xfec00000, 0x1000);
+			bp->cfg_data = (volatile unsigned char *)
+				ioremap(0xfee00000, 0x1000);
+                        bp->io_base = (void *) ioremap(0xfe000000, 0x20000);
 		}
 		if (isa_io_base == 0)
 			isa_io_base = (unsigned long) bp->io_base;
@@ -792,13 +468,7 @@
 		if (pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin) ||
 		    !pin)
 			continue; /* No interrupt generated -> no fixup */
-		/* We iterate all instances of uninorth for now */	
-		if (uninorth_count && dev->bus->number == 0) {
-			int i;
-			for (i=0;i<uninorth_count;i++)
-				fix_intr(uninorth_bridges[i].node->child, dev);
-		} else
-                	fix_intr(bp->node->child, dev);
+                fix_intr(bp->node->child, dev);
 	}
 }
 
@@ -806,17 +476,9 @@
 void
 pmac_setup_pci_ptrs(void))
 {
-	struct device_node* np;
-
-	np = find_devices("pci");
-	if (np != 0) {
-		if (device_is_compatible(np, "uni-north")) {
-			/* looks like an Core99 powermac */
-			set_config_access_method(uni);
-		} else {
-			/* looks like a G3 powermac */
-			set_config_access_method(grackle);
-		}
+	if (find_devices("pci") != 0) {
+		/* looks like a G3 powermac */
+		set_config_access_method(grackle);
 	} else {
 		set_config_access_method(pmac);
 	}
diff -urN linux.orig/arch/ppc/kernel/pmac_pic.c linux/arch/ppc/kernel/pmac_pic.c
--- linux.orig/arch/ppc/kernel/pmac_pic.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/pmac_pic.c	Thu Jul 11 15:43:29 2002
@@ -4,13 +4,11 @@
 #include <linux/sched.h>
 #include <linux/signal.h>
 #include <linux/pci.h>
-#include <linux/openpic.h>
 #include <asm/pci-bridge.h>
 #include <asm/io.h>
 #include <asm/smp.h>
 #include <asm/prom.h>
 #include "pmac_pic.h"
-#include "open_pic.h"
 
 struct pmac_irq_hw {
         unsigned int    flag;
@@ -30,8 +28,6 @@
 static int max_irqs;
 static int max_real_irqs;
 
-extern u_int openpic_read(volatile u_int *addr);
-
 #define MAXCOUNT 10000000
 
 #define GATWICK_IRQ_POOL_SIZE        10
@@ -158,8 +154,6 @@
 	    int            cpu,
             int            isfake)
 {
-	extern void psurge_smp_message_recv(void);
-
 	int irq;
 	unsigned long bits = 0;
 
@@ -174,7 +168,7 @@
                         if (xmon_2nd)
                                 xmon(regs);
 #endif
-                        psurge_smp_message_recv();
+                        pmac_smp_message_recv();
                         goto out;
                 }
                 /* could be here due to a do_fake_interrupt call but we don't
@@ -356,58 +350,6 @@
         struct device_node *irqctrler;
         volatile struct pmac_irq_hw *addr;
 	int second_irq;
-	u_int t;
-	int nr_irq;
-
-	/* We first try to detect Apple's new Core99 chipset, since mac-io
-	 * is quite different on those machines and contains an IBM MPIC2.
-	 */
-	irqctrler = find_type_devices("open-pic");
-	if (irqctrler != NULL) {
-	    printk("PowerMac using OpenPIC irq controller\n");
-	    if (irqctrler->n_addrs > 0) {
-#ifdef CONFIG_XMON
-		struct device_node* pswitch;
-#endif /* CONFIG_XMON */	
-		OpenPIC = (volatile struct OpenPIC *)
-			ioremap(irqctrler->addrs[0].address,
-			irqctrler->addrs[0].size);
-		/* from openpic.c code... --Troy
-		 * dynamically figure out how many interrupts 
-		 * We should really do something like panic
-		 * if nr_irq >= OPENPIC_VEC_IPI
-		 */
-		t = openpic_read(&OpenPIC->Global.Feature_Reporting0);
-                nr_irq = ((t & OPENPIC_FEATURE_LAST_SOURCE_MASK) >>
-                                OPENPIC_FEATURE_LAST_SOURCE_SHIFT) + 1;
-		
-		for ( i = 0 ; i < nr_irq ; i++ ) {
-		    irq_desc[i].ctl = &open_pic;
-		    irq_desc[i].level = 0;
-		}
-		ppc_md.do_IRQ = open_pic_do_IRQ;
-		open_pic.irq_offset = 0;
-		openpic_init(1);
-#ifdef CONFIG_XMON
-		pswitch = find_devices("programmer-switch");
-		if (pswitch && pswitch->n_intrs)
-			request_irq(pswitch->intrs[0].line, xmon_irq, 0,	
-				"NMI - XMON", 0);
-#endif	/* CONFIG_XMON */
-#ifdef __SMP__
-		request_irq(OPENPIC_VEC_IPI, openpic_ipi_action,
-			    0, "IPI0", 0);
-		request_irq(OPENPIC_VEC_IPI+1, openpic_ipi_action,
-			    0, "IPI1 (invalidate TLB)", 0);
-		request_irq(OPENPIC_VEC_IPI+2, openpic_ipi_action,
-			    0, "IPI2 (stop CPU)", 0);
-		request_irq(OPENPIC_VEC_IPI+3, openpic_ipi_action,
-			    0, "IPI3 (reschedule)", 0);
-#endif	/* __SMP__ */
-		return;
-	    }
-	    irqctrler = NULL;
-	}
 
 	/*
 	 * G3 powermacs and 1999 G3 PowerBooks have 64 interrupts,
@@ -487,8 +429,6 @@
  * sleep_save_intrs() saves the states of all interrupt enables
  * and disables all interupts except for the nominated one.
  * sleep_restore_intrs() restores the states of all interrupt enables.
- * 
- * TODO: Those should be sleep notifiers with high priority.
  */
 unsigned int sleep_save_mask[2];
 
@@ -499,8 +439,7 @@
 	sleep_save_mask[1] = ppc_cached_irq_mask[1];
 	ppc_cached_irq_mask[0] = 0;
 	ppc_cached_irq_mask[1] = 0;
-	if (viaint > 0)
-		set_bit(viaint, ppc_cached_irq_mask);
+	set_bit(viaint, ppc_cached_irq_mask);
 	out_le32(&pmac_irq_hw[0]->enable, ppc_cached_irq_mask[0]);
 	if (max_real_irqs > 32)
 		out_le32(&pmac_irq_hw[1]->enable, ppc_cached_irq_mask[1]);
@@ -513,7 +452,6 @@
 {
 	int i;
 
-
 	out_le32(&pmac_irq_hw[0]->enable, 0);
 	if (max_real_irqs > 32)
 		out_le32(&pmac_irq_hw[1]->enable, 0);
diff -urN linux.orig/arch/ppc/kernel/pmac_setup.c linux/arch/ppc/kernel/pmac_setup.c
--- linux.orig/arch/ppc/kernel/pmac_setup.c	Sun Mar 25 18:37:30 2001
+++ linux/arch/ppc/kernel/pmac_setup.c	Thu Jul 11 15:46:22 2002
@@ -57,20 +57,18 @@
 #include <asm/feature.h>
 #include <asm/ide.h>
 #include <asm/machdep.h>
-#include <asm/keyboard.h>
-#include <asm/time.h>
 
+#include "time.h"
 #include "local_irq.h"
 #include "pmac_pic.h"
 
 #undef SHOW_GATWICK_IRQS
 
-extern long pmac_time_init(void);
-extern unsigned long pmac_get_rtc_time(void);
-extern int pmac_set_rtc_time(unsigned long nowtime);
-extern void pmac_read_rtc_time(void);
-extern void pmac_calibrate_decr(void);
-extern void pmac_setup_pci_ptrs(void);
+unsigned long pmac_get_rtc_time(void);
+int pmac_set_rtc_time(unsigned long nowtime);
+void pmac_read_rtc_time(void);
+void pmac_calibrate_decr(void);
+void pmac_setup_pci_ptrs(void);
 
 extern int mackbd_setkeycode(unsigned int scancode, unsigned int keycode);
 extern int mackbd_getkeycode(unsigned int scancode);
@@ -80,59 +78,29 @@
 extern void mackbd_leds(unsigned char leds);
 extern void mackbd_init_hw(void);
 #ifdef CONFIG_MAGIC_SYSRQ
-extern unsigned char mackbd_sysrq_xlate[128];
-extern unsigned char mac_hid_kbd_sysrq_xlate[128];
-extern unsigned char pckbd_sysrq_xlate[128];
+unsigned char mackbd_sysrq_xlate[128];
 #endif /* CONFIG_MAGIC_SYSRQ */
-extern int keyboard_sends_linux_keycodes;
-extern int mac_hid_kbd_translate(unsigned char scancode,
-				 unsigned char *keycode, char raw_mode);
-extern char mac_hid_kbd_unexpected_up(unsigned char keycode);
-extern void mac_hid_init_hw(void);
-
-extern void pmac_nvram_update(void);
-
-extern void *pmac_pci_dev_io_base(unsigned char bus, unsigned char devfn);
-extern void *pmac_pci_dev_mem_base(unsigned char bus, unsigned char devfn);
-extern int pmac_pci_dev_root_bridge(unsigned char bus, unsigned char devfn);
+extern int pckbd_setkeycode(unsigned int scancode, unsigned int keycode);
+extern int pckbd_getkeycode(unsigned int scancode);
+extern int pckbd_translate(unsigned char scancode, unsigned char *keycode,
+			   char raw_mode);
+extern char pckbd_unexpected_up(unsigned char keycode);
+extern void pckbd_leds(unsigned char leds);
+extern void pckbd_init_hw(void);
 
 unsigned char drive_info;
 
 int ppc_override_l2cr = 0;
 int ppc_override_l2cr_value;
 
-static int current_root_goodness = -1;
-
 extern char saved_command_line[];
 
-extern int pmac_newworld;
-
 #define DEFAULT_ROOT_DEVICE 0x0801	/* sda1 - slightly silly choice */
 
 extern void zs_kgdb_hook(int tty_num);
 static void ohare_init(void);
 static void init_p2pbridge(void);
 
-#ifdef CONFIG_SMP
-volatile static long int core99_l2_cache;
-void core99_init_l2(void)
-{
- 	int cpu = smp_processor_id();
- 
-	if ( (_get_PVR() >> 16) != 8 && (_get_PVR() >> 16) != 12 )
-		return;
-
- 	if (cpu == 0){
- 		core99_l2_cache = _get_L2CR();
- 		printk("CPU0: L2CR is %lx\n", core99_l2_cache);
- 	} else {
- 		printk("CPU%d: L2CR was %lx\n", cpu, _get_L2CR());
- 		_set_L2CR(core99_l2_cache);
- 		printk("CPU%d: L2CR set to %lx\n", cpu, core99_l2_cache);
- 	}
-}
-#endif /* CONFIG_SMP */
-
 __pmac
 int
 pmac_get_cpuinfo(char *buffer)
@@ -219,10 +187,6 @@
 			len += sprintf(buffer+len, "l2cr override\t: 0x%x\n", *l2cr);
 		}
 	}
-
-	/* Indicate newworld/oldworld */
-	len += sprintf(buffer+len, "pmac-generation\t: %s\n",
-		pmac_newworld ? "NewWorld" : "OldWorld");		
 	
 	return len;
 }
@@ -282,18 +246,16 @@
 		if (fp != 0) {
 			switch (_get_PVR() >> 16) {
 			case 4:		/* 604 */
-			case 8:		/* G3 */
 			case 9:		/* 604e */
 			case 10:	/* mach V (604ev5) */
-			case 12:	/* G4 */
 			case 20:	/* 620 */
 				loops_per_jiffy = *fp / HZ;
 				break;
 			default:	/* 601, 603, etc. */
-				loops_per_jiffy = *fp / (2*HZ);
+				loops_per_jiffy = *fp / (2/HZ);
 			}
 		} else
-			loops_per_jiffy = 50000000 / HZ;
+			loops_per_jiffy = 50000000/HZ;
 	}
 
 	/* this area has the CPU identification register
@@ -304,11 +266,9 @@
 
 	*memory_start_p = pmac_find_bridges(*memory_start_p, *memory_end_p);
 	init_p2pbridge();
-	
-	/* Checks "l2cr-value" property in the registry
-	 * And enable G3/G4 Dynamic Power Management
-	 */
-	if ( (_get_PVR() >> 16) == 8 || (_get_PVR() >> 16) == 12 ) {
+
+	/* Checks "l2cr-value" property in the registry */
+	if ( (_get_PVR() >> 16) == 8) {
 		struct device_node *np = find_devices("cpus");		
 		if (np == 0)
 			np = find_type_devices("cpu");		
@@ -319,22 +279,17 @@
 				ppc_override_l2cr = 1;
 				ppc_override_l2cr_value = *l2cr;
 				_set_L2CR(0);
-				if (ppc_override_l2cr_value)
-					_set_L2CR(ppc_override_l2cr_value);
+				_set_L2CR(ppc_override_l2cr_value);
 			}
 		}
-		_set_HID0(_get_HID0() | HID0_DPM);
 	}
 
 	if (ppc_override_l2cr)
 		printk(KERN_INFO "L2CR overriden (0x%x), backside cache is %s\n",
 			ppc_override_l2cr_value, (ppc_override_l2cr_value & 0x80000000)
 				? "enabled" : "disabled");
-	feature_init();
 
-#ifdef CONFIG_SMP
-	core99_init_l2();
-#endif
+	feature_init();
 
 #ifdef CONFIG_KGDB
 	zs_kgdb_hook(0);
@@ -343,8 +298,6 @@
 	find_via_cuda();
 	find_via_pmu();
 
-	pmac_nvram_init();
-
 #ifdef CONFIG_DUMMY_CONSOLE
 	conswitchp = &dummy_con;
 #endif
@@ -413,6 +366,7 @@
 pmac_init2(void))
 {
 	adb_init();
+	pmac_nvram_init();
 	media_bay_init();
 }
 
@@ -493,14 +447,13 @@
 
 /* can't be initfunc - can be called whenever a disk is first accessed */
 __pmac
-void note_bootable_part(kdev_t dev, int part, int goodness)
+void note_bootable_part(kdev_t dev, int part)
 {
 	static int found_boot = 0;
 	char *p;
 
 	/* Do nothing if the root has been set already. */
-	if ((goodness < current_root_goodness) &&
-		(ROOT_DEV != to_kdev_t(DEFAULT_ROOT_DEVICE)))
+	if (ROOT_DEV != to_kdev_t(DEFAULT_ROOT_DEVICE))
 		return;
 	p = strstr(saved_command_line, "root=");
 	if (p != NULL && (p == saved_command_line || p[-1] == ' '))
@@ -513,7 +466,7 @@
 	if (boot_dev == 0 || dev == boot_dev) {
 		ROOT_DEV = MKDEV(MAJOR(dev), MINOR(dev) + part);
 		boot_dev = NODEV;
-		current_root_goodness = goodness;
+		printk(" (root)");
 	}
 }
 
@@ -522,8 +475,6 @@
 {
 	struct adb_request req;
 
-	pmac_nvram_update();
-	
 	switch (adb_hardware) {
 	case ADB_VIACUDA:
 		cuda_request(&req, NULL, 2, CUDA_PACKET,
@@ -544,8 +495,6 @@
 {
 	struct adb_request req;
 
-	pmac_nvram_update();
-	
 	switch (adb_hardware) {
 	case ADB_VIACUDA:
 		cuda_request(&req, NULL, 2, CUDA_PACKET,
@@ -564,6 +513,7 @@
 void
 pmac_halt(void)
 {
+   pmac_power_off();
 }
 
 
@@ -663,17 +613,12 @@
 	ppc_md.power_off      = pmac_power_off;
 	ppc_md.halt           = pmac_halt;
 
-	ppc_md.time_init      = pmac_time_init;
+	ppc_md.time_init      = NULL;
 	ppc_md.set_rtc_time   = pmac_set_rtc_time;
 	ppc_md.get_rtc_time   = pmac_get_rtc_time;
 	ppc_md.calibrate_decr = pmac_calibrate_decr;
 
-	ppc_md.pci_dev_root_bridge	= pmac_pci_dev_root_bridge;
-	ppc_md.pci_dev_mem_base		= pmac_pci_dev_mem_base;
-	ppc_md.pci_dev_io_base		= pmac_pci_dev_io_base;
-
-#ifdef CONFIG_VT
-#ifdef CONFIG_MAC_KEYBOARD
+#if defined(CONFIG_VT) && defined(CONFIG_MAC_KEYBOARD)
 	ppc_md.kbd_setkeycode    = mackbd_setkeycode;
 	ppc_md.kbd_getkeycode    = mackbd_getkeycode;
 	ppc_md.kbd_translate     = mackbd_translate;
@@ -684,27 +629,7 @@
 	ppc_md.sysrq_xlate	 = mackbd_sysrq_xlate;
 	SYSRQ_KEY		 = 0x69;
 #endif
-#elif defined(CONFIG_INPUT_ADBHID)
-	ppc_md.kbd_setkeycode    = 0;
-	ppc_md.kbd_getkeycode    = 0;
-	ppc_md.kbd_translate     = mac_hid_kbd_translate;
-	ppc_md.kbd_unexpected_up = mac_hid_kbd_unexpected_up;
-	ppc_md.kbd_leds          = 0;
-	ppc_md.kbd_init_hw       = mac_hid_init_hw;
-#ifdef CONFIG_MAGIC_SYSRQ
-#ifdef CONFIG_MAC_ADBKEYCODES
-	if (!keyboard_sends_linux_keycodes) {
-		ppc_md.sysrq_xlate = mac_hid_kbd_sysrq_xlate;
-		SYSRQ_KEY = 0x69;
-	} else
-#endif /* CONFIG_MAC_ADBKEYCODES */
-	{
-		ppc_md.sysrq_xlate = pckbd_sysrq_xlate;
-		SYSRQ_KEY = 0x54;
-	}
 #endif
-#endif /* CONFIG_MAC_KEYBOARD */
-#endif /* CONFIG_VT */
 
 #if defined(CONFIG_BLK_DEV_IDE_PMAC)
         ppc_ide_md.insw = pmac_ide_insw;
diff -urN linux.orig/arch/ppc/kernel/pmac_support.c linux/arch/ppc/kernel/pmac_support.c
--- linux.orig/arch/ppc/kernel/pmac_support.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/pmac_support.c	Thu Jul 11 15:43:29 2002
@@ -1,19 +1,10 @@
 /*
  * Miscellaneous procedures for dealing with the PowerMac hardware.
- * Contains support for the nvram.
- * 
- *   Copyright (C) 2000 Paul Mackerras
- *   Copyright (C) 2000 Benjamin Herrenschmidt
- *
- * ToDo: Handle type 0 and type 1 "NameRegistry" NVRAM properties. Those
- *       contain, among other things, the brightness, video mode, etc...
  */
 #include <linux/kernel.h>
 #include <linux/stddef.h>
 #include <linux/reboot.h>
 #include <linux/nvram.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
 #include <asm/init.h>
 #include <asm/ptrace.h>
 #include <asm/io.h>
@@ -22,49 +13,16 @@
 #include <asm/prom.h>
 #include <asm/adb.h>
 #include <asm/pmu.h>
-#include <asm/machdep.h>
 #include <asm/nvram.h>
 #include <asm/backlight.h>
 
-#undef DEBUG
-
-#define NVRAM_SIZE		0x2000	/* 8kB of non-volatile RAM */
-
-#define CORE99_SIGNATURE	0x5a
-#define CORE99_ADLER_START	0x14
-
-/* Core99 nvram is a flash */
-#define CORE99_FLASH_STATUS_DONE	0x80
-#define CORE99_FLASH_STATUS_ERR		0x38
-#define CORE99_FLASH_CMD_ERASE_CONFIRM	0xd0
-#define CORE99_FLASH_CMD_ERASE_SETUP	0x20
-#define CORE99_FLASH_CMD_RESET		0xff
-#define CORE99_FLASH_CMD_WRITE_SETUP	0x40
-
-/* CHRP NVRAM header */
-struct chrp_header {
-	u8	signature;
-	u8	cksum;
-	u16	len;
-	char    name[12];
-	u8	data[0];
-};
-
-struct core99_header {
-	struct chrp_header hdr;
-	u32	adler;
-	u32	generation;
-	u32	reserved[2];
-};
-
 /*
  * Read and write the non-volatile RAM on PowerMacs and CHRP machines.
  */
 static int nvram_naddrs;
 static volatile unsigned char *nvram_addr;
 static volatile unsigned char *nvram_data;
-static int nvram_mult, is_core_99;
-static int core99_bank = 0;
+static int nvram_mult;
 static int nvram_partitions[3];
 
 static struct backlight_controller *backlighter = NULL;
@@ -73,213 +31,22 @@
 static int backlight_level = BACKLIGHT_MAX;
 static int backlight_enabled = 1;
 
-/* FIXME: kmalloc fails to allocate the image now that I had to move it
- *        before time_init(). For now, I allocate a static buffer here
- *        but it's a waste of space on all but core99 machines
- */
-#if 0
-static char* nvram_image;
-#else
-static char nvram_image[NVRAM_SIZE];
-#endif
-
-extern int pmac_newworld;
-
-static u8 __pmac
-chrp_checksum(struct chrp_header* hdr)
-{
-	u8 *ptr;
-	u16 sum = hdr->signature;
-	for (ptr = (u8 *)&hdr->len; ptr < hdr->data; ptr++)
-		sum += *ptr;
-	while (sum > 0xFF)
-		sum = (sum & 0xFF) + (sum>>8);
-	return sum;
-}
-
-static u32 __pmac
-core99_calc_adler(u8 *buffer)
-{
-	int cnt;
-	u32 low, high;
-
-   	buffer += CORE99_ADLER_START;
-	low = 1;
-	high = 0;
-	for (cnt=0; cnt<(NVRAM_SIZE-CORE99_ADLER_START); cnt++) {
-		if ((cnt % 5000) == 0) {
-			high  %= 65521UL;
-			high %= 65521UL;
-		}
-		low += buffer[cnt];
-		high += low;
-	}
-	low  %= 65521UL;
-	high %= 65521UL;
-  
-	return (high << 16) | low;
-}
-
-static u32 __pmac
-core99_check(u8* datas)
-{
-	struct core99_header* hdr99 = (struct core99_header*)datas;
+#define NVRAM_SIZE	0x2000	/* 8kB of non-volatile RAM */
 
-	if (hdr99->hdr.signature != CORE99_SIGNATURE) {
-#ifdef DEBUG
-		printk("Invalid signature\n");
-#endif		
-		return 0;
-	}
-	if (hdr99->hdr.cksum != chrp_checksum(&hdr99->hdr)) {
-#ifdef DEBUG
-		printk("Invalid checksum\n");
-#endif
-		return 0;
-	}
-	if (hdr99->adler != core99_calc_adler(datas)) {
-#ifdef DEBUG
-		printk("Invalid adler\n");
-#endif
-		return 0;
-	}
-	return hdr99->generation;
-}
-
-static int __pmac
-core99_erase_bank(int bank)
-{
-	int stat, i;
-	
-	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
-	
-	out_8(base, CORE99_FLASH_CMD_ERASE_SETUP);
-	out_8(base, CORE99_FLASH_CMD_ERASE_CONFIRM);
-	do { stat = in_8(base); }
-	while(!(stat & CORE99_FLASH_STATUS_DONE));
-	out_8(base, CORE99_FLASH_CMD_RESET);
-	if (stat & CORE99_FLASH_STATUS_ERR) {
-		printk("nvram: flash error 0x%02x on erase !\n", stat);
-		return -ENXIO;
-	}
-	for (i=0; i<NVRAM_SIZE; i++)
-		if (base[i] != 0xff) {
-			printk("nvram: flash erase failed !\n");
-			return -ENXIO;
-		}
-	return 0;
-}
-
-static int __pmac
-core99_write_bank(int bank, u8* datas)
-{
-	int i, stat = 0;
-	
-	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
-	
-	for (i=0; i<NVRAM_SIZE; i++) {
-		out_8(base+i, CORE99_FLASH_CMD_WRITE_SETUP);
-		out_8(base+i, datas[i]);
-		do { stat = in_8(base); }
-		while(!(stat & CORE99_FLASH_STATUS_DONE));
-		if (stat & CORE99_FLASH_STATUS_ERR)
-			break;
-	}
-	out_8(base, CORE99_FLASH_CMD_RESET);
-	if (stat & CORE99_FLASH_STATUS_ERR) {
-		printk("nvram: flash error 0x%02x on write !\n", stat);
-		return -ENXIO;
-	}
-	for (i=0; i<NVRAM_SIZE; i++)
-		if (base[i] != datas[i]) {
-			printk("nvram: flash write failed !\n");
-			return -ENXIO;
-		}
-	return 0;	
-}
-
-static void __pmac
-lookup_partitions(void)
-{
-	u8 buffer[17];
-	int i, offset;
-	struct chrp_header* hdr;
-
-	if (pmac_newworld) {
-		nvram_partitions[pmac_nvram_OF] = -1;
-		nvram_partitions[pmac_nvram_XPRAM] = -1;
-		nvram_partitions[pmac_nvram_NR] = -1;
-		hdr = (struct chrp_header *)buffer;
-	
-		offset = 0;
-		buffer[16] = 0;
-		do {
-			for (i=0;i<16;i++)
-				buffer[i] = nvram_read_byte(offset+i);
-			if (!strcmp(hdr->name, "common"))
-				nvram_partitions[pmac_nvram_OF] = offset + 0x10;
-			if (!strcmp(hdr->name, "APL,MacOS75")) {
-				nvram_partitions[pmac_nvram_XPRAM] = offset + 0x10;
-				nvram_partitions[pmac_nvram_NR] = offset + 0x110;
-			}
-			offset += (hdr->len * 0x10);
-		} while(offset < NVRAM_SIZE);
-	} else {
-		nvram_partitions[pmac_nvram_OF] = 0x1800;
-		nvram_partitions[pmac_nvram_XPRAM] = 0x1300;
-		nvram_partitions[pmac_nvram_NR] = 0x1400;
-	}	
-#ifdef DEBUG
-	printk("nvram: OF partition at 0x%x\n", nvram_partitions[pmac_nvram_OF]);
-	printk("nvram: XP partition at 0x%x\n", nvram_partitions[pmac_nvram_XPRAM]);
-	printk("nvram: NR partition at 0x%x\n", nvram_partitions[pmac_nvram_NR]);
-#endif	
-}
 
 __init
 void pmac_nvram_init(void)
 {
 	struct device_node *dp;
 
-	nvram_naddrs = 0;
-
 	dp = find_devices("nvram");
 	if (dp == NULL) {
 		printk(KERN_ERR "Can't find NVRAM device\n");
+		nvram_naddrs = 0;
 		return;
 	}
 	nvram_naddrs = dp->n_addrs;
-	is_core_99 = device_is_compatible(dp, "nvram,flash");
-	printk("pmac nvram is core99: %d\n", is_core_99);
-	if (is_core_99) {
-		int i;
-		u32 gen_bank0, gen_bank1;
-		
-		if (nvram_naddrs < 1) {
-			printk(KERN_ERR "nvram: no address\n");
-			return;
-		}
-#if 0
-		nvram_image = kmalloc(NVRAM_SIZE, GFP_KERNEL);
-		if (!nvram_image) {
-			printk(KERN_ERR "nvram: can't allocate image\n");
-			return;
-		}
-#endif		
-		nvram_data = ioremap(dp->addrs[0].address, NVRAM_SIZE*2);
-#ifdef DEBUG
-		printk("nvram: Checking bank 0...\n");
-#endif
-		gen_bank0 = core99_check((u8 *)nvram_data);
-		gen_bank1 = core99_check((u8 *)nvram_data + NVRAM_SIZE);
-		core99_bank = (gen_bank0 < gen_bank1) ? 1 : 0;
-#ifdef DEBUG
-		printk("nvram: gen0=%d, gen1=%d\n", gen_bank0, gen_bank1);
-		printk("nvram: Active bank is: %d\n", core99_bank);
-#endif
-		for (i=0; i<NVRAM_SIZE; i++)
-			nvram_image[i] = nvram_data[i + core99_bank*NVRAM_SIZE];
-	} else if (_machine == _MACH_chrp && nvram_naddrs == 1) {
+	if (_machine == _MACH_chrp && nvram_naddrs == 1) {
 		nvram_data = ioremap(dp->addrs[0].address, dp->addrs[0].size);
 		nvram_mult = 1;
 	} else if (nvram_naddrs == 1) {
@@ -288,45 +55,15 @@
 	} else if (nvram_naddrs == 2) {
 		nvram_addr = ioremap(dp->addrs[0].address, dp->addrs[0].size);
 		nvram_data = ioremap(dp->addrs[1].address, dp->addrs[1].size);
-	} else if (nvram_naddrs == 0 && adb_controller &&
-		adb_controller->kind == ADB_VIAPMU) {
+	} else if (nvram_naddrs == 0 && adb_hardware == ADB_VIAPMU) {
 		nvram_naddrs = -1;
 	} else {
 		printk(KERN_ERR "Don't know how to access NVRAM with %d addresses\n",
 		       nvram_naddrs);
 	}
-	lookup_partitions();
 }
 
-void __pmac
-pmac_nvram_update(void)
-{
-	struct core99_header* hdr99;
-	
-	if (!is_core_99 || !nvram_data || !nvram_image)
-		return;
-	if (!memcmp(nvram_image, (u8*)nvram_data + core99_bank*NVRAM_SIZE,
-		NVRAM_SIZE))
-		return;
-#ifdef DEBUG
-	printk("Updating nvram...\n");
-#endif
-	hdr99 = (struct core99_header*)nvram_image;
-	hdr99->generation++;
-	hdr99->hdr.signature = CORE99_SIGNATURE;
-	hdr99->hdr.cksum = chrp_checksum(&hdr99->hdr);
-	hdr99->adler = core99_calc_adler(nvram_image);
-	core99_bank = core99_bank ? 0 : 1;
-	if (core99_erase_bank(core99_bank)) {
-		printk("nvram: Error erasing bank %d\n", core99_bank);
-		return;
-	}
-	if (core99_write_bank(core99_bank, nvram_image))
-		printk("nvram: Error writing bank %d\n", core99_bank);
-}
-
-unsigned char __pmac
-nvram_read_byte(int addr)
+unsigned char nvram_read_byte(int addr)
 {
 	struct adb_request req;
 
@@ -339,8 +76,6 @@
 			pmu_poll();
 		return req.reply[1];
 	case 1:
-		if (is_core_99)
-			return nvram_image ? nvram_image[addr] : 0;
 		return nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult];
 	case 2:
 		*nvram_addr = addr >> 5;
@@ -350,8 +85,7 @@
 	return 0;
 }
 
-void __pmac
-nvram_write_byte(unsigned char val, int addr)
+void nvram_write_byte(unsigned char val, int addr)
 {
 	struct adb_request req;
 
@@ -364,12 +98,6 @@
 			pmu_poll();
 		break;
 	case 1:
-		if (is_core_99) {
-			if (!nvram_image)
-				return;
-			nvram_image[addr] = val;
-			break;
-		}
 		nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult] = val;
 		break;
 	case 2:
diff -urN linux.orig/arch/ppc/kernel/pmac_time.c linux/arch/ppc/kernel/pmac_time.c
--- linux.orig/arch/ppc/kernel/pmac_time.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/pmac_time.c	Thu Jul 11 15:43:29 2002
@@ -22,9 +22,8 @@
 #include <asm/system.h>
 #include <asm/io.h>
 #include <asm/pgtable.h>
-#include <asm/nvram.h>
 
-#include <asm/time.h>
+#include "time.h"
 
 /* Apparently the RTC stores seconds since 1 Jan 1904 */
 #define RTC_OFFSET	2082844800
@@ -50,26 +49,8 @@
 /* Bits in IFR and IER */
 #define T1_INT		0x40		/* Timer 1 interrupt */
 
-extern struct timezone sys_tz;
-
-__init
-long pmac_time_init(void)
-{
-	s32 delta = 0;
-	int dst;
-	
-	delta = ((s32)pmac_xpram_read(PMAC_XPRAM_MACHINE_LOC + 0x9)) << 16;
-	delta |= ((s32)pmac_xpram_read(PMAC_XPRAM_MACHINE_LOC + 0xa)) << 8;
-	delta |= pmac_xpram_read(PMAC_XPRAM_MACHINE_LOC + 0xb);
-	if (delta & 0x00800000UL)
-		delta |= 0xFF000000UL;
-	dst = ((pmac_xpram_read(PMAC_XPRAM_MACHINE_LOC + 0x8) & 0x80) != 0);
-	printk("GMT Delta read from XPRAM: %d minutes, DST: %s\n", delta/60,
-		dst ? "on" : "off");
-	return -delta;
-}
-
 __pmac
+
 unsigned long pmac_get_rtc_time(void)
 {
 	struct adb_request req;
@@ -109,42 +90,7 @@
 
 int pmac_set_rtc_time(unsigned long nowtime)
 {
-	struct adb_request req;
-	int dst, delta;
-
-	nowtime += RTC_OFFSET;
-
-	/* Set the time in the RTC */
-	if (adb_controller == 0)
-		return 0;
-	/* adb_controller->kind, not adb_hardware, since that doesn't
-	   get set until we call adb_init - paulus. */
-	switch (adb_controller->kind) {
-	case ADB_VIACUDA:
-		if (cuda_request(&req, NULL, 6, CUDA_PACKET, CUDA_SET_TIME,
-				 nowtime >> 24, nowtime >> 16, nowtime >> 8, nowtime) < 0)
-			return 0;
-		while (!req.complete)
-			cuda_poll();
-//		if (req.reply_len != 7)
-			printk(KERN_ERR "pmac_set_rtc_time: got %d byte reply\n",
-			       req.reply_len);
-		break;
-	case ADB_VIAPMU:
-		if (pmu_request(&req, NULL, 5, PMU_SET_RTC,
-				nowtime >> 24, nowtime >> 16, nowtime >> 8, nowtime) < 0)
-			return 0;
-		while (!req.complete)
-			pmu_poll();
-		if (req.reply_len != 5)
-			printk(KERN_ERR "pmac_set_rtc_time: got %d byte reply\n",
-			       req.reply_len);
-		break;
-	default:
-		return 0;
-	}
-
-	return 1;
+	return 0;
 }
 
 /*
diff -urN linux.orig/arch/ppc/kernel/ppc-stub.c linux/arch/ppc/kernel/ppc-stub.c
--- linux.orig/arch/ppc/kernel/ppc-stub.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/ppc-stub.c	Thu Jul 11 15:43:29 2002
@@ -351,7 +351,7 @@
 
 static inline void set_msr(int msr)
 {
-	asm volatile("mtmsr %0" : : "r" (msr));
+	asm volatile("mfmsr %0" : : "r" (msr));
 }
 
 /* Set up exception handlers for tracing and breakpoints
diff -urN linux.orig/arch/ppc/kernel/ppc_asm.tmpl linux/arch/ppc/kernel/ppc_asm.tmpl
--- linux.orig/arch/ppc/kernel/ppc_asm.tmpl	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/kernel/ppc_asm.tmpl	Thu Jul 11 15:43:29 2002
@@ -64,36 +64,3 @@
 #define	fr29	29
 #define	fr30	30
 #define	fr31	31
-
-#define	vr0	0
-#define	vr1	1
-#define	vr2	2
-#define	vr3	3
-#define	vr4	4
-#define	vr5	5
-#define	vr6	6
-#define	vr7	7
-#define	vr8	8
-#define	vr9	9
-#define	vr10	10
-#define	vr11	11
-#define	vr12	12
-#define	vr13	13
-#define	vr14	14
-#define	vr15	15
-#define	vr16	16
-#define	vr17	17
-#define	vr18	18
-#define	vr19	19
-#define	vr20	20
-#define	vr21	21
-#define	vr22	22
-#define	vr23	23
-#define	vr24	24
-#define	vr25	25
-#define	vr26	26
-#define	vr27	27
-#define	vr28	28
-#define	vr29	29
-#define	vr30	30
-#define	vr31	31
diff -urN linux.orig/arch/ppc/kernel/ppc_htab.c linux/arch/ppc/kernel/ppc_htab.c
--- linux.orig/arch/ppc/kernel/ppc_htab.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/ppc_htab.c	Thu Jul 11 15:43:29 2002
@@ -547,8 +547,7 @@
 		"0.5", "1.0", "(reserved2)", "(reserved3)"
 	};
 
-	if ( ((_get_PVR() >> 16) != 8) && ((_get_PVR() >> 16) != 12))
-		return -EFAULT;
+	if ( (_get_PVR() >> 16) != 8) return -EFAULT;
 	
 	if ( /*!table->maxlen ||*/ (filp->f_pos && !write)) {
 		*lenp = 0;
@@ -587,8 +586,9 @@
 			buffer += len;
 			left -= len;
 			_set_L2CR(0);
-			if (val)
-				_set_L2CR(val);
+			_set_L2CR(val);
+			while ( _get_L2CR() & 0x1 )
+				/* wait for invalidate to finish */;
 			  
 		} else {
 			p = buf;
diff -urN linux.orig/arch/ppc/kernel/ppc_ksyms.c linux/arch/ppc/kernel/ppc_ksyms.c
--- linux.orig/arch/ppc/kernel/ppc_ksyms.c	Tue Jun 11 19:39:18 2002
+++ linux/arch/ppc/kernel/ppc_ksyms.c	Thu Jul 11 18:49:10 2002
@@ -5,26 +5,31 @@
 #include <linux/sched.h>
 #include <linux/string.h>
 #include <linux/interrupt.h>
-#include <linux/smp_lock.h>
 #include <linux/vt_kern.h>
 #include <linux/nvram.h>
 
+#include <asm/page.h>
 #include <asm/semaphore.h>
 #include <asm/processor.h>
 #include <asm/uaccess.h>
+#include <asm/io.h>
+#include <linux/ide.h>
 #include <asm/ide.h>
+#include <asm/atomic.h>
+#include <asm/bitops.h>
 #include <asm/checksum.h>
 #include <asm/pgtable.h>
 #include <asm/adb.h>
 #include <asm/cuda.h>
 #include <asm/pmu.h>
 #include <asm/prom.h>
+#include <asm/system.h>
 #include <asm/pci-bridge.h>
 #include <asm/irq.h>
 #include <asm/feature.h>
+#include <asm/spinlock.h>
 #include <asm/dma.h>
-#include <asm/nvram.h>
-#include <asm/time.h>
+#include <asm/machdep.h>
 
 /* Tell string.h we don't want memcpy etc. as cpp defines */
 #define EXPORT_SYMTAB_STROPS
@@ -45,10 +50,10 @@
                             unsigned int, unsigned int, unsigned int);
 extern void to_tm(int tim, struct rtc_time * tm);
 
-long long __ashrdi3(long long, int);
-long long __ashldi3(long long, int);
-long long __lshrdi3(long long, int);
-int abs(int);
+asmlinkage long long __ashrdi3(long long, int);
+asmlinkage long long __ashldi3(long long, int);
+asmlinkage long long __lshrdi3(long long, int);
+asmlinkage int abs(int);
 
 EXPORT_SYMBOL(clear_page);
 EXPORT_SYMBOL(do_signal);
@@ -73,12 +78,10 @@
 EXPORT_SYMBOL(isa_mem_base);
 EXPORT_SYMBOL(pci_dram_offset);
 EXPORT_SYMBOL(ISA_DMA_THRESHOLD);
-EXPORT_SYMBOL_NOVERS(DMA_MODE_READ);
+EXPORT_SYMBOL(DMA_MODE_READ);
 EXPORT_SYMBOL(DMA_MODE_WRITE);
-#if defined(CONFIG_PREP) || defined(CONFIG_ALL_PPC)
 EXPORT_SYMBOL(_prep_type);
 EXPORT_SYMBOL(ucSystemType);
-#endif
 
 EXPORT_SYMBOL(atomic_add);
 EXPORT_SYMBOL(atomic_sub);
@@ -167,16 +170,11 @@
 EXPORT_SYMBOL(enable_kernel_fp);
 EXPORT_SYMBOL(flush_icache_range);
 EXPORT_SYMBOL(xchg_u32);
-
-#ifdef CONFIG_ALTIVEC
-EXPORT_SYMBOL(giveup_altivec);
-#endif
-
 #ifdef __SMP__
-EXPORT_SYMBOL(cpu_data);
-EXPORT_SYMBOL(kernel_flag);
-EXPORT_SYMBOL(cpu_number_map);
-EXPORT_SYMBOL(smp_num_cpus);
+EXPORT_SYMBOL(__global_cli);
+EXPORT_SYMBOL(__global_sti);
+EXPORT_SYMBOL(__global_save_flags);
+EXPORT_SYMBOL(__global_restore_flags);
 EXPORT_SYMBOL(_spin_lock);
 EXPORT_SYMBOL(_spin_unlock);
 EXPORT_SYMBOL(spin_trylock);
@@ -184,35 +182,11 @@
 EXPORT_SYMBOL(_read_unlock);
 EXPORT_SYMBOL(_write_lock);
 EXPORT_SYMBOL(_write_unlock);
-
-/* Global SMP irq stuff */
-EXPORT_SYMBOL(synchronize_irq);
-EXPORT_SYMBOL(synchronize_bh);
-EXPORT_SYMBOL(global_bh_count);
-EXPORT_SYMBOL(global_bh_lock);
-EXPORT_SYMBOL(global_irq_holder);
-EXPORT_SYMBOL(__global_cli);
-EXPORT_SYMBOL(__global_sti);
-EXPORT_SYMBOL(__global_save_flags);
-EXPORT_SYMBOL(__global_restore_flags);
-#endif /* __SMP__ */
+#endif
 
 EXPORT_SYMBOL(_machine);
 EXPORT_SYMBOL(ppc_md);
-EXPORT_SYMBOL(abort);
 
-#ifndef CONFIG_MBX
-EXPORT_SYMBOL(find_devices);
-EXPORT_SYMBOL(find_type_devices);
-EXPORT_SYMBOL(find_compatible_devices);
-EXPORT_SYMBOL(find_path_device);
-EXPORT_SYMBOL(find_phandle);
-EXPORT_SYMBOL(device_is_compatible);
-EXPORT_SYMBOL(machine_is_compatible);
-EXPORT_SYMBOL(find_pci_device_OFnode);
-EXPORT_SYMBOL(find_all_nodes);
-EXPORT_SYMBOL(get_property);
-#endif /* CONFIG_MBX */
 #ifdef CONFIG_POWERMAC
 EXPORT_SYMBOL(adb_request);
 EXPORT_SYMBOL(adb_register);
@@ -227,21 +201,25 @@
 EXPORT_SYMBOL(pmu_enable_irled);
 #endif /* CONFIG_PMAC_PBOOK */
 #ifdef CONFIG_POWERMAC
+EXPORT_SYMBOL(abort);
+EXPORT_SYMBOL(find_devices);
+EXPORT_SYMBOL(find_type_devices);
+EXPORT_SYMBOL(find_compatible_devices);
+EXPORT_SYMBOL(find_path_device);
+EXPORT_SYMBOL(find_phandle);
+EXPORT_SYMBOL(device_is_compatible);
+EXPORT_SYMBOL(machine_is_compatible);
+EXPORT_SYMBOL(find_pci_device_OFnode);
+EXPORT_SYMBOL(get_property);
 EXPORT_SYMBOL(pci_io_base);
-EXPORT_SYMBOL(pci_dev_io_base);
-EXPORT_SYMBOL(pci_dev_mem_base);
 EXPORT_SYMBOL(pci_device_loc);
 EXPORT_SYMBOL(feature_set);
 EXPORT_SYMBOL(feature_clear);
 EXPORT_SYMBOL(feature_test);
 EXPORT_SYMBOL(feature_set_gmac_power);
 EXPORT_SYMBOL(feature_set_gmac_phy_reset);
-EXPORT_SYMBOL(feature_set_usb_power);
-EXPORT_SYMBOL(feature_set_firewire_power);
 EXPORT_SYMBOL(nvram_read_byte);
 EXPORT_SYMBOL(nvram_write_byte);
-EXPORT_SYMBOL(pmac_xpram_read);
-EXPORT_SYMBOL(pmac_xpram_write);
 #ifdef CONFIG_SCSI
 EXPORT_SYMBOL(note_scsi_host);
 #endif /* CONFIG_SCSI */
diff -urN linux.orig/arch/ppc/kernel/prep_pci.c linux/arch/ppc/kernel/prep_pci.c
--- linux.orig/arch/ppc/kernel/prep_pci.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/prep_pci.c	Thu Jul 11 15:43:29 2002
@@ -8,7 +8,6 @@
  */
 
 #include <linux/types.h>
-#include <linux/string.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -22,10 +21,10 @@
 #include <asm/residual.h>
 #include <asm/processor.h>
 #include <asm/irq.h>
+#include <asm/irq-compat.h>
 #include <asm/machdep.h>
 
 #include "pci.h"
-#include "open_pic.h"
 
 #define MAX_DEVNR 22
 
@@ -38,11 +37,13 @@
 unsigned char *Motherboard_routes;
 void (*Motherboard_non0)(struct pci_dev *);
 
-void Powerplus_Map_Non0(struct pci_dev *);
+void Mesquite_Map_Non0(struct pci_dev *);
 
 /* Used for Motorola to store system config register */
 static unsigned long	*ProcInfo;
 
+extern void chrp_do_IRQ(struct pt_regs *,int , int);
+
 /* Tables for known hardware */   
 
 /* Motorola PowerStackII - Utah */
@@ -508,51 +509,6 @@
         13      /* Line 4 */
 };
 
-/* Motorola PowerPlus architecture PCI IRQ tables */
-/* Interrupt line values for INTA-D on primary/secondary MPIC inputs */
-
-struct powerplus_irq_list
-{
-	unsigned char primary[4];	/* INT A-D */
-	unsigned char secondary[4];	/* INT A-D */
-};
-
-/*
- * For standard PowerPlus boards, bus 0 PCI INTs A-D are routed to
- * OpenPIC inputs 9-12.  PCI INTs A-D from the on board P2P bridge
- * are routed to OpenPIC inputs 5-8.  These values are offset by 
- * 16 in the table to reflect the Linux kernel interrupt value.
- */
-struct powerplus_irq_list Powerplus_pci_IRQ_list =
-{
-	{25, 26, 27, 28},
-	{21, 22, 23, 24}
-};
-
-/* 
- * For the MCP750 (system slot board), bus 0 PCI INTs A-D are routed
- * to OpenPIC inputs 8-11.  PCI INTs A-D from the on board P2P bridge
- * are routed to OpenPIC inputs 12-15.  These values are offset by 16
- * in the table to reflect the Linux kernel interrupt value.
- */
-struct powerplus_irq_list Mesquite_pci_IRQ_list =
-{
-	{24, 25, 26, 27},
-	{28, 29, 30, 31}
-};
-
-/*
- * This table represents the standard PCI swizzle defined in the
- * PCI bus specification.
- */ 
-static unsigned char prep_pci_intpins[4][4] =
-{
-        { 1, 2, 3, 4},  /* Buses 0, 4, 8, ... */
-        { 2, 3, 4, 1},  /* Buses 1, 5, 9, ... */
-        { 3, 4, 1, 2},  /* Buses 2, 6, 10 ... */
-        { 4, 1, 2, 3},  /* Buses 3, 7, 11 ... */
-};
-
 /* We have to turn on LEVEL mode for changed IRQ's */
 /* All PCI IRQ's need to be level mode, so this should be something
  * other than hard-coded as well... IRQ's are individually mappable
@@ -730,7 +686,8 @@
 #define MOT_RAVEN_PRESENT	0x1
 #define MOT_HAWK_PRESENT	0x2
 
-int mot_entry = -1;
+/* Keyboard present flag */
+int prep_kbd_present = 1;   /* Keyboard present by default */
 
 int MotMPIC = 0;
 int mot_multi = 0;
@@ -783,7 +740,7 @@
 	OpenPIC_InitSenses = mvme2600_openpic_initsenses;
 	OpenPIC_NumInitSenses = sizeof(mvme2600_openpic_initsenses);
 
-	ppc_md.do_IRQ = open_pic_do_IRQ;
+	ppc_md.do_IRQ = chrp_do_IRQ;
 	
 	/* If raven is present on Motorola store the system config register
 	 * for later use.
@@ -795,17 +752,13 @@
 		mot_multi = 1;
 	}
 
-	/*
-	 * If a Motorola MVME2300, 2400, or MCPN750 board is detected
-	 * disable keyboard controller initialization to avoid system
-	 * hangs.
+	/* This is a hack.  If this is a 2300 or 2400 mot board then there is
+	 * no keyboard controller and we have to indicate that.
 	 */
 	base_mod = inb(MOTOROLA_BASETYPE_REG);
 	if ((MotMPIC == MOT_HAWK_PRESENT) || (base_mod == 0xF9) ||
-	    (base_mod == 0xFA) || (base_mod == 0xE1)) {
-		ppc_md.kbd_leds	= NULL; 
-		ppc_md.kbd_init_hw = NULL; 
-	}
+	    (base_mod == 0xFA) || (base_mod == 0xE1))
+		prep_kbd_present = 0;
 
 	return 1;
 }
@@ -819,35 +772,33 @@
 	unsigned char	*map;
 	unsigned char	*routes;
 	void		(*map_non0_bus)(struct pci_dev *);	/* For boards with more than bus 0 devices. */
-	struct powerplus_irq_list *pci_irq_list; /* List of PCI MPIC inputs */
-	unsigned char	secondary_bridge_devfn;	/* devfn of secondary bus transparent bridge */
 } mot_info[] = {
-	{0x300, 0x00, 0x00, "MVME 2400",			Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x010, 0x00, 0x00, "Genesis",				Genesis_pci_IRQ_map,	Genesis_pci_IRQ_routes, Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x020, 0x00, 0x00, "Powerstack (Series E)",		Comet_pci_IRQ_map,	Comet_pci_IRQ_routes,	NULL, NULL, 0x00},
-	{0x040, 0x00, 0x00, "Blackhawk (Powerstack)",		Blackhawk_pci_IRQ_map,	Blackhawk_pci_IRQ_routes, NULL, NULL, 0x00},
-	{0x050, 0x00, 0x00, "Omaha (PowerStack II Pro3000)",	Omaha_pci_IRQ_map,	Omaha_pci_IRQ_routes,	NULL, NULL, 0x00},
-	{0x060, 0x00, 0x00, "Utah (Powerstack II Pro4000)",	Utah_pci_IRQ_map,	Utah_pci_IRQ_routes,	NULL, NULL, 0x00},
-	{0x0A0, 0x00, 0x00, "Powerstack (Series EX)",		Comet2_pci_IRQ_map,	Comet2_pci_IRQ_routes,	NULL, NULL, 0x00},
-	{0x1E0, 0xE0, 0x00, "Mesquite cPCI (MCP750)",		Mesquite_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Mesquite_pci_IRQ_list, 0x00},
-	{0x1E0, 0xE1, 0x00, "Sitka cPCI (MCPN750)",		Sitka_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xE2, 0x00, "Mesquite cPCI (MCP750) w/ HAC",	Mesquite_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Mesquite_pci_IRQ_list, 0xC0},
-	{0x1E0, 0xF6, 0x80, "MTX Plus",				MTXplus_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0xA0},
-	{0x1E0, 0xF6, 0x81, "Dual MTX Plus",			MTXplus_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0xA0},
-	{0x1E0, 0xF7, 0x80, "MTX wo/ Parallel Port",		MTX_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xF7, 0x81, "Dual MTX wo/ Parallel Port",	MTX_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xF8, 0x80, "MTX w/ Parallel Port",		MTX_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xF8, 0x81, "Dual MTX w/ Parallel Port",	MTX_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xF9, 0x00, "MVME 2300",			Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xFA, 0x00, "MVME 2300SC/2600",			Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xFB, 0x00, "MVME 2600 with MVME712M",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xFC, 0x00, "MVME 2600/2700 with MVME761",	Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xFD, 0x80, "MVME 3600 with MVME712M",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xFD, 0x81, "MVME 4600 with MVME712M",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xFE, 0x80, "MVME 3600 with MVME761",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xFE, 0x81, "MVME 4600 with MVME761",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	Powerplus_Map_Non0, &Powerplus_pci_IRQ_list, 0x00},
-	{0x1E0, 0xFF, 0x00, "MVME 1600-001 or 1600-011",	Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL, NULL, 0x00},
-	{0x000, 0x00, 0x00, "",					NULL,			NULL,	NULL, 0x00}
+	{0x300, 0x00, 0x00, "MVME 2400",			Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x010, 0x00, 0x00, "Genesis",				Genesis_pci_IRQ_map,	Genesis_pci_IRQ_routes, NULL},
+	{0x020, 0x00, 0x00, "Powerstack (Series E)",		Comet_pci_IRQ_map,	Comet_pci_IRQ_routes,	NULL},
+	{0x040, 0x00, 0x00, "Blackhawk (Powerstack)",		Blackhawk_pci_IRQ_map,	Blackhawk_pci_IRQ_routes, NULL},
+	{0x050, 0x00, 0x00, "Omaha (PowerStack II Pro3000)",	Omaha_pci_IRQ_map,	Omaha_pci_IRQ_routes,	NULL},
+	{0x060, 0x00, 0x00, "Utah (Powerstack II Pro4000)",	Utah_pci_IRQ_map,	Utah_pci_IRQ_routes,	NULL},
+	{0x0A0, 0x00, 0x00, "Powerstack (Series EX)",		Comet2_pci_IRQ_map,	Comet2_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xE0, 0x00, "Mesquite cPCI (MCP750)",		Mesquite_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xE1, 0x00, "Sitka cPCI (MCPN750)",		Sitka_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xE2, 0x00, "Mesquite cPCI (MCP750) w/ HAC",	Mesquite_pci_IRQ_map,	Raven_pci_IRQ_routes,	Mesquite_Map_Non0},
+	{0x1E0, 0xF6, 0x80, "MTX Plus",				MTXplus_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xF6, 0x81, "Dual MTX Plus",			MTXplus_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xF7, 0x80, "MTX wo/ Parallel Port",		MTX_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xF7, 0x81, "Dual MTX wo/ Parallel Port",	MTX_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xF8, 0x80, "MTX w/ Parallel Port",		MTX_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xF8, 0x81, "Dual MTX w/ Parallel Port",	MTX_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xF9, 0x00, "MVME 2300",			Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xFA, 0x00, "MVME 2300SC/2600",			Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xFB, 0x00, "MVME 2600 with MVME712M",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xFC, 0x00, "MVME 2600/2700 with MVME761",	Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xFD, 0x80, "MVME 3600 with MVME712M",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xFD, 0x81, "MVME 4600 with MVME712M",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xFE, 0x80, "MVME 3600 with MVME761",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xFE, 0x81, "MVME 4600 with MVME761",		Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x1E0, 0xFF, 0x00, "MVME 1600-001 or 1600-011",	Genesis2_pci_IRQ_map,	Raven_pci_IRQ_routes,	NULL},
+	{0x000, 0x00, 0x00, "",					NULL,			NULL,	NULL}
 };
 
 __initfunc(unsigned long prep_route_pci_interrupts(void))
@@ -862,6 +813,7 @@
 		unsigned char  cpu_type;
 		unsigned char  base_mod;
 		int	       entry;
+		int	       mot_entry = -1;
 
 		cpu_type = inb(MOTOROLA_CPUTYPE_REG) & 0xF0;
 		base_mod = inb(MOTOROLA_BASETYPE_REG);
@@ -1038,91 +990,91 @@
 	return 0;
 }
 
-/*
- * Remove a device from the kernel PCI device list based on its 
- * devfn identifier.
- */
-__initfunc(
-void
-prep_exclude_pci_device(unsigned char devfn)
-)
+static unsigned int pci_localpirqs[4] =
 {
-	struct pci_dev *dev, *pdev = NULL;
+	24,
+	25,
+	26,
+	27
+};
 
-	/* Walk the pci device list */
-	for(dev=pci_devices; dev; dev=dev->next) {
-		if (dev->devfn == devfn)
-		{
-			/*
-			 * If we find a matching device, adjust
-			 * the list to remove the device.
-			 */
-			if (pdev != NULL)
-				pdev->next = dev->next;
-			else
-				pci_devices = dev->next;
+static unsigned int pci_remotepirqs[4] =
+{
+	28,
+	29,
+	30,
+	31
+};
 
-			break;
-		}
-		pdev = dev;
-	}
-}
+static unsigned int pci_remotedev = 0xc0;
 
 void
-Powerplus_Map_Non0(struct pci_dev *dev)
+Mesquite_Map_Non0(struct pci_dev *pdev)
 {
-	struct pci_bus  *pbus;          /* Parent bus structure pointer */
-	struct pci_dev	*tdev;		/* Temporary device structure */
-        unsigned int    devnum;         /* Accumulated device number */
-        unsigned char   intline;        /* Linux interrupt value */
-	unsigned char	intpin;		/* PCI interrupt pin */
- 
-	/* Check for valid PCI dev pointer */
-	if (dev == NULL) return;
-
-	/* Fill our temporary device, and get the device number */
-	*tdev = *dev;
-	devnum = PCI_SLOT(tdev->devfn);
-
-	/* Read the interrupt pin of the device and adjust for indexing */
-	pcibios_read_config_byte(tdev->bus->number, tdev->devfn,
-				PCI_INTERRUPT_PIN, &intpin);
+	struct pci_bus  *pbus;          /* Parent Bus Structure Pointer */
+	unsigned int    devnum;         /* Accumulated Device Number */
+	unsigned int    irq;            /* IRQ Value */
 
-	/* If device doesn't request an interrupt, return */
-	if ( (intpin < 1) || (intpin > 4) )
-		return;
+	/*
+	**    Device Interrupt Line register initialization.
+	**    The IRQ line number will be generated after
+	**    taking into account all the PCI-2-PCI bridge
+	**    devices between the device and the Host Bridge.
+	*/
+	devnum = PCI_SLOT(pdev->devfn);
+	pbus = pdev->bus;
+
+	while ((pbus->parent)->primary != (pbus->parent)->secondary)
+	{
+	    devnum += PCI_SLOT((pbus->self)->devfn);
+
+	    pbus = pbus->parent;
+	}
+
+	devnum &= 0x03;
+
+	/*
+	**    By default, get the PCI local domain IRQ value.
+	*/
+	irq = pci_localpirqs[devnum];
+
+	/*
+	**    Determine if the device is located in the
+	**    remote domain or not. We must find the
+	**    domain's bridge device located on bus 0.
+	*/
+	pbus = pdev->bus;
+
+	while (pbus->primary != 0)
+	    pbus = pbus->parent;
 
-	intpin--;
+	/*
+	**    Check the device/function of domain's bridge
+	**    device against the remote device/function.
+	**    If the same, then the device is located in
+	**    the remote domain. Thus, get the PCI remote
+	**    domain IRQ value.
+	*/
+	if ((pbus->self)->devfn == pci_remotedev)
+        irq = pci_remotepirqs[devnum];
 
-	/* Walk up to bus 0, adjusting the interrupt pin for the standard
-	   PCI bus swizzle. */
-	do {
-		intpin = (prep_pci_intpins[devnum % 4][intpin]) - 1;
-		pbus = tdev->bus;        /* up one level */
-		tdev = pbus->self;
-		devnum = PCI_SLOT(tdev->devfn);
-	} while(tdev->bus->number);
-
-	/* Use the primary interrupt inputs by default */
-	intline = mot_info[mot_entry].pci_irq_list->primary[intpin];
-
-	/* If the board has secondary interrupt inputs, walk the bus and
-	   note the devfn of the bridge from bus 0.  If it is the same as
-	   the devfn of the bus bridge with secondary inputs, use those. */
-	if (mot_info[mot_entry].secondary_bridge_devfn)
+	/*
+	**    Validate the IRQ number.
+	*/
+	if (irq <= 255)
 	{
-		pbus = dev->bus;
- 
-		while (pbus->primary != 0)
-			pbus = pbus->parent;
- 
-		if ((pbus->self)->devfn == mot_info[mot_entry].secondary_bridge_devfn)
-			intline = mot_info[mot_entry].pci_irq_list->secondary[intpin];
+	    /*
+	    **    Set the device's Interrupt Line register
+	    **    to the IRQ number and save it in the
+	    **    device's structure.
+	    */
+
+	    pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, (u8)irq);
+
+	    pdev->irq = irq;
+
 	}
-	
-	/* Write calculated interrupt value to header and device list */
-	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, (u8)intline);
-	dev->irq = intline;
+	return;
 }
 
 int motopenpic_to_irq(int n)
@@ -1130,7 +1082,7 @@
        if (n & 0xF0) {
                return (n & 0x0F);
        } else {
-               return(n+open_pic.irq_offset);
+               return(openpic_to_irq(n));
        }
 }
 
@@ -1169,17 +1121,6 @@
 					dev->devfn, 0x44, short_reg);
 		}
 	}
-	if ((dev = pci_find_device(PCI_VENDOR_ID_WINBOND,
-				   PCI_DEVICE_ID_WINBOND_82C105, dev))){
-		if (OpenPIC){
-			/* Disable LEGIRQ mode so PCI INTs are routed to
-			   the 8259 */
-			pci_write_config_dword(dev, 0x40, 0x10ff00a1);
-		} else {
-			/* Enable LEGIRQ for PCI INT -> 8259 IRQ routing */
-			pci_write_config_dword(dev, 0x40, 0x10ff08a1);
-		}
-	}
 }
 __initfunc(
 void
@@ -1197,15 +1138,6 @@
 
 	prep_route_pci_interrupts();
 
-	/*
-	 * If MTX+, exclude the SL82C105 IDE controller so the driver
-	 * doesn't hang.
-	 */
-	if ( _prep_type == _PREP_Motorola )
-		if ( strstr(mot_info[mot_entry].name, "MTX Plus") )
-			/* On MTX+, SL82C105 is at IDSEL 0xb function 0x1 */
-			prep_exclude_pci_device(PCI_DEVFN(0xb, 0x1));
-
 	prep_pib_init();
 
 	printk("Setting PCI interrupts for a \"%s\"\n", Motherboard_map_name);
@@ -1219,7 +1151,7 @@
 		       motopenpic_to_irq(Motherboard_map[PCI_SLOT(dev->devfn)]);
 
 		    pcibios_write_config_byte(dev->bus->number, dev->devfn, 
-					      PCI_INTERRUPT_LINE, dev->irq);
+					      PCI_INTERRUPT_PIN, dev->irq);
 		} else {
 			if (Motherboard_non0 != NULL)
 				Motherboard_non0(dev);
diff -urN linux.orig/arch/ppc/kernel/prep_setup.c linux/arch/ppc/kernel/prep_setup.c
--- linux.orig/arch/ppc/kernel/prep_setup.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/prep_setup.c	Thu Jul 11 15:46:34 2002
@@ -33,12 +33,12 @@
 #include <linux/timex.h>
 #include <linux/pci.h>
 #include <linux/openpic.h>
-#include <linux/delay.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
 #include <asm/residual.h>
 #include <asm/io.h>
+#include <asm/irq-compat.h>
 #include <asm/pgtable.h>
 #include <asm/ide.h>
 #include <asm/cache.h>
@@ -48,9 +48,9 @@
 #include <asm/prep_nvram.h>
 #include <asm/raven.h>
 #include <asm/keyboard.h>
-#include <asm/time.h>
-#include <asm/vga.h>
 
+
+#include "time.h"
 #include "local_irq.h"
 #include "i8259.h"
 #include "open_pic.h"
@@ -102,12 +102,16 @@
 extern PTE *Hash, *Hash_end;
 extern unsigned long Hash_size, Hash_mask;
 extern int probingmem;
+extern unsigned long loops_per_jiffy;
 
 #ifdef CONFIG_BLK_DEV_RAM
 extern int rd_doload;		/* 1 = load ramdisk, 0 = don't load */
 extern int rd_prompt;		/* 1 = prompt for ramdisk, 0 = don't prompt */
 extern int rd_image_start;	/* starting block # of image */
 #endif
+#ifdef CONFIG_VGA_CONSOLE
+unsigned long vgacon_remap_base;
+#endif
 
 __prep
 int
@@ -605,7 +609,6 @@
 	int i;
 
 	if (OpenPIC != NULL) {
-		open_pic.irq_offset = 16;
 		for ( i = 16 ; i < 36 ; i++ )
 			irq_desc[i].ctl = &open_pic;
 		openpic_init(1);
@@ -615,14 +618,8 @@
                 irq_desc[i].ctl = &i8259_pic;
         i8259_init();
 #ifdef __SMP__
-	request_irq(OPENPIC_VEC_IPI, openpic_ipi_action,
+	request_irq(openpic_to_irq(OPENPIC_VEC_SPURIOUS), openpic_ipi_action,
 		    0, "IPI0", 0);
-	request_irq(OPENPIC_VEC_IPI+1, openpic_ipi_action,
-		    0, "IPI1 (invalidate TLB)", 0);
-	request_irq(OPENPIC_VEC_IPI+2, openpic_ipi_action,
-		    0, "IPI2 (stop CPU)", 0);
-	request_irq(OPENPIC_VEC_IPI+3, openpic_ipi_action,
-		    0, "IPI3 (reschedule)", 0);
 #endif /* __SMP__ */
 }
 
diff -urN linux.orig/arch/ppc/kernel/prep_time.c linux/arch/ppc/kernel/prep_time.c
--- linux.orig/arch/ppc/kernel/prep_time.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/prep_time.c	Thu Jul 11 15:43:29 2002
@@ -26,7 +26,7 @@
 #include <asm/prep_nvram.h>
 #include <asm/mk48t59.h>
 
-#include <asm/time.h>
+#include "time.h"
 
 /*
  * The motorola uses the m48t18 rtc (includes DS1643) whose registers
diff -urN linux.orig/arch/ppc/kernel/process.c linux/arch/ppc/kernel/process.c
--- linux.orig/arch/ppc/kernel/process.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/process.c	Thu Jul 11 15:43:29 2002
@@ -43,11 +43,9 @@
 #include <asm/mmu_context.h>
 
 int dump_fpu(struct pt_regs *regs, elf_fpregset_t *fpregs);
-int dump_altivec(struct pt_regs *regs, elf_vrregset_t *vrregs);
 extern unsigned long _get_SP(void);
 
 struct task_struct *last_task_used_math = NULL;
-struct task_struct *last_task_used_altivec = NULL;
 static struct vm_area_struct init_mmap = INIT_MMAP;
 static struct fs_struct init_fs = INIT_FS;
 static struct files_struct init_files = INIT_FILES;
@@ -81,31 +79,6 @@
 	return 1;
 }
 
-#ifdef CONFIG_ALTIVEC
-int
-dump_altivec(struct pt_regs *regs, elf_vrregset_t *vrregs)
-{
-	if (regs->msr & MSR_VEC)
-		giveup_altivec(current);
-	memcpy(vrregs, &current->tss.vr[0], sizeof(*vrregs));
-	return 1;
-}
-
-void 
-enable_kernel_altivec(void)
-{
-#ifdef __SMP__
-	if (current->tss.regs && (current->tss.regs->msr & MSR_VEC))
-		giveup_altivec(current);
-	else
-		giveup_altivec(NULL);	/* just enable AltiVec for kernel - force */
-#else
-	giveup_altivec(last_task_used_altivec);
-#endif /* __SMP __ */
-	printk("MSR_VEC in enable_altivec_kernel\n");
-}
-#endif /* CONFIG_ALTIVEC */
-
 void
 enable_kernel_fp(void)
 {
@@ -221,53 +194,22 @@
 	_enable_interrupts(s);
 }
 
-struct bits {
-	const char *name;
-	unsigned int bit;
-};
-
-void print_bits(unsigned int val, struct bits *bits)
-{
-	const char *sep = "";
-
-	printk("[");
-	for (; bits->bit != 0; ++bits) {
-		if (val & bits->bit) {
-			printk("%s%s", sep, bits->name);
-			sep = ", ";
-		}
-	}
-	printk("]");
-}
-
-struct bits msr_bits[] = {
-	{"VEC", MSR_VEC},
-	{"EE", MSR_EE},
-	{"PR", MSR_PR},
-	{"FP", MSR_FP},
-	{"IR", MSR_IR},
-	{"DR", MSR_DR},
-	{"ME", MSR_ME},
-	{0, 0}
-};
-
-void show_regs(struct pt_regs *regs)
+void show_regs(struct pt_regs * regs)
 {
 	int i;
 
 	printk("NIP: %08lX XER: %08lX LR: %08lX REGS: %p TRAP: %04lx\n",
 	       regs->nip, regs->xer, regs->link, regs,regs->trap);
-	printk("MSR: %08lx ", regs->msr);
-	print_bits(regs->msr, msr_bits);
-	printk("\n");
+	printk("MSR: %08lx EE: %01x PR: %01x FP: %01x ME: %01x IR/DR: %01x%01x\n",
+	       regs->msr, regs->msr&MSR_EE ? 1 : 0, regs->msr&MSR_PR ? 1 : 0,
+	       regs->msr & MSR_FP ? 1 : 0,regs->msr&MSR_ME ? 1 : 0,
+	       regs->msr&MSR_IR ? 1 : 0,
+	       regs->msr&MSR_DR ? 1 : 0);
 	printk("TASK = %p[%d] '%s' mm->pgd %p ",
 	       current, current->pid, current->comm, current->mm->pgd);
 	printk("Last syscall: %ld ", current->tss.last_syscall);
-	if (last_task_used_math)
-		printk("\nlast math %p", last_task_used_math);
-	if (last_task_used_altivec)
-		printk("\nlast altivec %p", last_task_used_altivec);
-
+	printk("\nlast math %p", last_task_used_math);
+	
 #ifdef __SMP__	
 	printk(" CPU: %d last CPU: %d", current->processor,current->last_processor);
 #endif /* __SMP__ */
@@ -314,16 +256,12 @@
 {
 	if (last_task_used_math == current)
 		last_task_used_math = NULL;
-	if (last_task_used_altivec == current)
-		last_task_used_altivec = NULL;
 }
 
 void flush_thread(void)
 {
 	if (last_task_used_math == current)
 		last_task_used_math = NULL;
-	if (last_task_used_altivec == current)
-		last_task_used_altivec = NULL;
 }
 
 void
@@ -381,19 +319,6 @@
 	if (regs->msr & MSR_FP)
 		giveup_fpu(current);
 
-#ifdef CONFIG_ALTIVEC
-	/*
-	 * copy altiVec info - assume lazy altiVec switch
-	 * - kumar
-	 */
-	if (regs->msr & MSR_VEC)
-		giveup_altivec(current);
-
-	memcpy(&p->tss.vr, &current->tss.vr, sizeof(p->tss.vr));
-	p->tss.vscr = current->tss.vscr;
-	childregs->msr &= ~MSR_VEC;
-#endif /* CONFIG_ALTIVEC */
-
 	memcpy(&p->tss.fpr, &current->tss.fpr, sizeof(p->tss.fpr));
 	p->tss.fpscr = current->tss.fpscr;
 	childregs->msr &= ~MSR_FP;
@@ -455,8 +380,6 @@
 	shove_aux_table(sp);
 	if (last_task_used_math == current)
 		last_task_used_math = 0;
-	if (last_task_used_altivec == current)
-		last_task_used_altivec = 0;
 	current->tss.fpscr = 0;
 }
 
@@ -516,10 +439,6 @@
 		goto out;
 	if (regs->msr & MSR_FP)
 		giveup_fpu(current);
-#ifdef CONFIG_ALTIVEC
-	if (regs->msr & MSR_VEC)
-		giveup_altivec(current);
-#endif /* CONFIG_ALTIVEC */ 
 	error = do_execve(filename, (char **) a1, (char **) a2, regs);
 	putname(filename);
 out:
diff -urN linux.orig/arch/ppc/kernel/prom.c linux/arch/ppc/kernel/prom.c
--- linux.orig/arch/ppc/kernel/prom.c	Sun Mar 25 18:37:30 2001
+++ linux/arch/ppc/kernel/prom.c	Thu Jul 11 15:43:29 2002
@@ -16,29 +16,24 @@
 #include <linux/string.h>
 #include <linux/init.h>
 #include <linux/version.h>
-#include <linux/fs.h>
-#include <linux/console.h>
 #include <asm/spinlock.h>
 #include <asm/prom.h>
 #include <asm/page.h>
 #include <asm/processor.h>
 #include <asm/irq.h>
+#include <asm/irq-compat.h>
 #include <asm/io.h>
 #include <asm/smp.h>
 #include <asm/bootx.h>
 #include <asm/system.h>
 #include <asm/gemini.h>
-#include <asm/linux_logo.h>
-#include <asm/mmu.h>
-#include <asm/pgtable.h>
-#include <asm/adb.h>
-#include <asm/pmu.h>
 
 /*
  * Properties whose value is longer than this get excluded from our
  * copy of the device tree.  This way we don't waste space storing
  * things like "driver,AAPL,MacOS,PowerPC" properties.
  */
+
 #define MAX_PROPERTY_LENGTH	1024
 
 struct prom_args {
@@ -95,77 +90,45 @@
 char *of_stdout_device = 0;
 
 prom_entry prom = 0;
-ihandle prom_chosen = 0, prom_stdout = 0, prom_disp_node = 0;
+ihandle prom_chosen = 0, prom_stdout = 0;
 int prom_version = 0;
 
 extern char *klimit;
 char *bootpath = 0;
 char *bootdevice = 0;
 
-unsigned int rtas_data = 0;   /* physical pointer */
+unsigned int rtas_data = 0;   /* virtual pointer */
 unsigned int rtas_entry = 0;  /* physical pointer */
 unsigned int rtas_size = 0;
 unsigned int old_rtas = 0;
 
-/* Set for a newworld machine */
-int use_of_interrupt_tree = 0;
-int pmac_newworld = 0;
-
 static struct device_node *allnodes = 0;
 
-#ifdef CONFIG_BOOTX_TEXT
-
-/*
- * The VGA font is in the _pmac section. Can't this cause problems with CHRP
- * using some of the prom_xxxx functions ?
- * All this need to be moved in a separate source file anyway
- */
-
 static void clearscreen(void);
 static void flushscreen(void);
 
+#ifdef CONFIG_BOOTX_TEXT
+
 void drawchar(char c);
 void drawstring(const char *c);
-void drawhex(unsigned long v);
+static void drawhex(unsigned long v);
 static void scrollscreen(void);
-static void prepare_disp_BAT(void);
-static void boot_console_write(struct console *co, const char *s,
-				 unsigned count);
 
 static void draw_byte(unsigned char c, long locX, long locY);
-static void draw_byte_32(unsigned char *bits, unsigned long *base, int rb);
-static void draw_byte_16(unsigned char *bits, unsigned long *base, int rb);
-static void draw_byte_8(unsigned char *bits, unsigned long *base, int rb);
-
-/* We want those in the data section */
-static long				g_loc_X = 0;
-static long				g_loc_Y = 0;
-static long				g_max_loc_X = 0;
-static long				g_max_loc_Y = 0; 
-
-unsigned long disp_BATL = 0;
-unsigned long disp_BATU = 0;
+static void draw_byte_32(unsigned char *bits, unsigned long *base);
+static void draw_byte_16(unsigned char *bits, unsigned long *base);
+static void draw_byte_8(unsigned char *bits, unsigned long *base);
+
+static long				g_loc_X;
+static long				g_loc_Y;
+static long				g_max_loc_X;
+static long				g_max_loc_Y;
 
 #define cmapsz	(16*256)
 
 static unsigned char vga_font[cmapsz];
 
-static struct console boot_cons = {
-	"boot",
-	boot_console_write,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	CON_PRINTBUFFER,
-	0,
-	0,
-	NULL
-};
-static int boot_cons_registered = 0;
-
-#endif /* CONFIG_BOOTX_TEXT */
+#endif
 
 
 static void *call_prom(const char *service, int nargs, int nret, ...);
@@ -175,25 +138,15 @@
 				  unsigned long, struct device_node ***);
 static unsigned long finish_node(struct device_node *, unsigned long,
 				 interpret_func *);
-static unsigned long finish_node_interrupts(struct device_node *, unsigned long);
 static unsigned long check_display(unsigned long);
 static int prom_next_node(phandle *);
 static void *early_get_property(unsigned long, unsigned long, char *);
 
-#ifdef CONFIG_BOOTX_TEXT
-static void setup_disp_fake_bi(ihandle dp);
-static void prom_welcome(boot_infos_t* bi, unsigned long phys);
-#endif
-
 extern void enter_rtas(void *);
 extern unsigned long reloc_offset(void);
 
 extern char cmd_line[512];	/* XXX */
 boot_infos_t *boot_infos = 0;	/* init it so it's in data segment not bss */
-#ifdef CONFIG_BOOTX_TEXT
-boot_infos_t *disp_bi = 0;
-boot_infos_t fake_bi = {0,};
-#endif
 
 /*
  * prom_init() is called very early on, before the kernel text
@@ -276,7 +229,7 @@
 	return prom_args.args[nargs];
 }
 
-/*__init*/
+__init
 void
 prom_print(const char *msg)
 {
@@ -286,7 +239,7 @@
 	if (RELOC(prom_stdout) == 0)
 	{
 #ifdef CONFIG_BOOTX_TEXT
-		if (RELOC(disp_bi) != 0)
+		if (RELOC(boot_infos) != 0)
 			drawstring(msg);
 #endif
 		return;
@@ -307,22 +260,6 @@
 	}
 }
 
-void
-prom_print_hex(unsigned int v)
-{
-	char buf[16];
-	int i, c;
-
-	for (i = 0; i < 8; ++i) {
-		c = (v >> ((7-i)*4)) & 0xf;
-		c += (c >= 10)? ('a' - 10): '0';
-		buf[i] = c;
-	}
-	buf[i] = ' ';
-	buf[i+1] = 0;
-	prom_print(buf);
-}
-
 unsigned long smp_ibm_chrp_hack __initdata = 0;
 
 /*
@@ -338,7 +275,6 @@
 	phandle node;
 	char type[16], *path;
 #endif	
-	int chrp = 0;
 	unsigned long mem;
 	ihandle prom_rtas, prom_mmu, prom_op;
 	unsigned long offset = reloc_offset();
@@ -365,19 +301,22 @@
 		unsigned long space;
 		unsigned long ptr, x;
 		char *model;
+#ifdef CONFIG_BOOTX_TEXT
+		unsigned long flags;
+#endif		
 
 		RELOC(boot_infos) = PTRUNRELOC(bi);
 		if (!BOOT_INFO_IS_V2_COMPATIBLE(bi))
 			bi->logicalDisplayBase = 0;
+
+		clearscreen();
+
 #ifdef CONFIG_BOOTX_TEXT
 		RELOC(g_loc_X) = 0;
 		RELOC(g_loc_Y) = 0;
 		RELOC(g_max_loc_X) = (bi->dispDeviceRect[2] - bi->dispDeviceRect[0]) / 8;
 		RELOC(g_max_loc_Y) = (bi->dispDeviceRect[3] - bi->dispDeviceRect[1]) / 16;
-		RELOC(disp_bi) = PTRUNRELOC(bi);
 		
-		clearscreen();
-
 		/* Test if boot-info is compatible. Done only in config CONFIG_BOOTX_TEXT since
 		   there is nothing much we can do with an incompatible version, except display
 		   a message and eventually hang the processor...
@@ -388,10 +327,24 @@
 		if (!BOOT_INFO_IS_COMPATIBLE(bi))
 			prom_print(RELOC(" !!! WARNING - Incompatible version of BootX !!!\n\n\n"));
 		
-		prom_welcome(bi, phys);
+		prom_print(RELOC("Welcome to Linux, kernel " UTS_RELEASE "\n"));
+		prom_print(RELOC("\nstarted at       : 0x"));
+		drawhex(reloc_offset() + KERNELBASE);
+		prom_print(RELOC("\nlinked at        : 0x"));
+		drawhex(KERNELBASE);
+		prom_print(RELOC("\nframe buffer at  : 0x"));
+		drawhex((unsigned long)bi->dispDeviceBase);
+		prom_print(RELOC(" (phys), 0x"));
+		drawhex((unsigned long)bi->logicalDisplayBase);
+		prom_print(RELOC(" (log)"));
+		prom_print(RELOC("\nMSR              : 0x"));
+		__asm__ __volatile__ ("mfmsr %0" : "=r" ((flags)) : : "memory");
+		drawhex(flags);
+		prom_print(RELOC("\n\n"));
+#endif
+		/* Out of the #if/#endif since it flushes the clearscreen too */
 		flushscreen();
-#endif /* CONFIG_BOOTX_TEXT */
-
+		
 		/* New BootX enters kernel with MMU off, i/os are not allowed
 		   here. This hack will have been done by the boostrap anyway.
 		 */
@@ -432,7 +385,6 @@
 		}
 		
 #ifdef CONFIG_BOOTX_TEXT
-		prepare_disp_BAT();
 		prom_print(RELOC("booting...\n"));
 		flushscreen();
 #endif
@@ -470,15 +422,12 @@
 	    int sz;
 	    sz = (int)call_prom(RELOC("getprop"), 4, 1, prom_op, RELOC("model"), model, 64);
 	    if (sz > 0) {
-		if ( strncmp(model,RELOC("IBM"),3) ) {
-	    	    char *c;
-		    for (c = model; *c; c++)
-		        if (*c >= '0' && *c <= '9') {
-			    RELOC(prom_version) = *c - '0';
-			    break;
-		        }
-		} else
-		    chrp = 1;
+	    	char *c;
+		for (c = model; *c; c++)
+		    if (*c >= '0' && *c <= '9') {
+			RELOC(prom_version) = *c - '0';
+			break;
+		    }
 	    }
 	}
 	if (RELOC(prom_version) >= 3)
@@ -498,6 +447,15 @@
 		RELOC(bootdevice) = PTRUNRELOC(d);
 		mem = ALIGN(mem + strlen(d) + 1);
 	}
+
+	mem = check_display(mem);
+
+	prom_print(RELOC("copying OF device tree..."));
+	mem = copy_device_tree(mem, mem + (1<<20));
+	prom_print(RELOC("done\n"));
+
+
+	RELOC(klimit) = (char *) (mem - offset);
 	
 	prom_rtas = call_prom(RELOC("finddevice"), 1, 1, RELOC("/rtas"));
 	if (prom_rtas != (void *) -1) {
@@ -509,14 +467,18 @@
 			RELOC(rtas_data) = 0;
 		} else {
 			/*
-			 * Ask OF for some space for RTAS.
+			 * We do _not_ want the rtas_data inside the klimit
+			 * boundry since it'll be squashed when we do the
+			 * relocate of the kernel on chrp right after prom_init()
+			 * in head.S.  So, we just pick a spot in memory.
+			 * -- Cort
 			 */
-			RELOC(rtas_data) = (unsigned int)
-				call_prom(RELOC("claim"), 3, 1, 0,
-					  RELOC(rtas_size), 0x1000);
-			prom_print(RELOC("rtas at "));
-			prom_print_hex(RELOC(rtas_data));
-			prom_print(RELOC("\n"));
+#if 0
+			mem = (mem + 4095) & -4096;
+			RELOC(rtas_data) = mem + KERNELBASE;
+			mem += RELOC(rtas_size);
+#endif
+			RELOC(rtas_data) = (6<<20) + KERNELBASE;
 		}
 		prom_rtas = call_prom(RELOC("open"), 1, 1, RELOC("/rtas"));
 		{
@@ -528,7 +490,7 @@
 			prom_args.nret = 2;
 			prom_args.args[0] = RELOC("instantiate-rtas");
 			prom_args.args[1] = prom_rtas;
-			prom_args.args[2] = (void *) RELOC(rtas_data);
+			prom_args.args[2] = ((void *)(RELOC(rtas_data)-KERNELBASE));
 			RELOC(prom)(&prom_args);
 			if (prom_args.args[nargs] != 0)
 				i = 0;
@@ -542,15 +504,6 @@
 			prom_print(RELOC(" done\n"));
 	}
 
-	mem = check_display(mem);
-
-	prom_print(RELOC("copying OF device tree..."));
-	/* N.B. do this *after* any claims */
-	mem = copy_device_tree(mem, mem + (1<<20));
-	prom_print(RELOC("done\n"));
-
-	RELOC(klimit) = (char *) (mem - offset);
-
 	/* If we are already running at 0xc0000000, we assume we were loaded by
 	 * an OF bootloader which did set a BAT for us. This breaks OF translate
 	 * so we force phys to be 0
@@ -582,11 +535,6 @@
 	    }
 	}
 	    
-#ifdef CONFIG_BOOTX_TEXT
-	if (RELOC(prom_disp_node) != 0)
-		setup_disp_fake_bi(RELOC(prom_disp_node));
-#endif
-
 #ifdef CONFIG_SMP
 	/*
 	 * With CHRP SMP we need to use the OF to start the other
@@ -607,11 +555,7 @@
 	 * is in its holding pattern code.
 	 *
 	 * -- Cort
-	 * 
-	 * This code crashes on some pmacs since the memory at 8M is not
-	 * claim'ed and so can be unmapped. -- BenH
 	 */
-	if (chrp)
 	{
 		extern void __secondary_hold(void);
 		unsigned long i;
@@ -637,7 +581,7 @@
 	}
 
 	/* look for cpus */
-	for (node = 0; chrp && prom_next_node(&node);)
+	for (node = 0; prom_next_node(&node);)
 	{
 		type[0] = 0;
 		call_prom(RELOC("getprop"), 4, 1, node, RELOC("device_type"),
@@ -666,132 +610,19 @@
 		else
 			prom_print(RELOC("...failed\n"));
 	}
+#endif /* CONFIG_SMP */
 	
-#endif	
-	/* If PowerMac, then use quiesce call */
-	if (!chrp) {
+	/* If OpenFirmware version >= 3, then use quiesce call */
+	if (RELOC(prom_version) >= 3) {
 	    prom_print(RELOC("Calling quiesce ...\n"));
 	    call_prom(RELOC("quiesce"), 0, 0);
 	    offset = reloc_offset();
 	    phys = offset + KERNELBASE;
 	}
 
-#ifdef CONFIG_BOOTX_TEXT
-	if (!chrp && RELOC(disp_bi)) {
-		RELOC(prom_stdout) = 0;
-		clearscreen();
-		prepare_disp_BAT();
-		prom_welcome(PTRRELOC(RELOC(disp_bi)), phys);
-	}
-#endif
-
-	prom_print(RELOC("booting...\n"));
 	return phys;
 }
 
-#ifdef CONFIG_BOOTX_TEXT
-__init static void
-prom_welcome(boot_infos_t* bi, unsigned long phys)
-{
-	unsigned long offset = reloc_offset();
-	unsigned long flags;
-	unsigned long pvr;
-	
-	prom_print(RELOC("Welcome to Linux, kernel " UTS_RELEASE "\n"));
-	prom_print(RELOC("\nstarted at       : 0x"));
-	drawhex(phys);
-	prom_print(RELOC("\nlinked at        : 0x"));
-	drawhex(KERNELBASE);
-	prom_print(RELOC("\nframe buffer at  : 0x"));
-	drawhex((unsigned long)bi->dispDeviceBase);
-	prom_print(RELOC(" (phys), 0x"));
-	drawhex((unsigned long)bi->logicalDisplayBase);
-	prom_print(RELOC(" (log)"));
-	prom_print(RELOC("\nMSR              : 0x"));
-	__asm__ __volatile__ ("mfmsr %0" : "=r" (flags));
-	drawhex(flags);
-	__asm__ __volatile__ ("mfspr %0, 287" : "=r" (pvr));
-	pvr >>= 16;
-	if (pvr > 1) {
-	    prom_print(RELOC("\nHID0             : 0x"));
-	    __asm__ __volatile__ ("mfspr %0, 1008" : "=r" (flags));
-	    drawhex(flags);
-	}
-	if (pvr == 8 || pvr == 12) {
-	    prom_print(RELOC("\nICTC             : 0x"));
-	    __asm__ __volatile__ ("mfspr %0, 1019" : "=r" (flags));
-	    drawhex(flags);
-	}
-	prom_print(RELOC("\n\n"));
-}
-
-void showvalue(char *str, unsigned long val)
-{
-	drawstring(str);
-	drawhex(val);
-	drawstring("\n");
-}
-
-/* Calc BAT values for mapping the display and store them
- * in disp_BATH and disp_BATL. Those values are then used
- * from head.S to map the display during identify_machine()
- * and MMU_Init()
- * 
- * For now, the display is mapped in place (1:1). This should
- * be changed if the display physical address overlaps
- * KERNELBASE, which is fortunately not the case on any machine
- * I know of. This mapping is temporary and will disappear as
- * soon as the setup done by MMU_Init() is applied
- * 
- * For now, we align the BAT and then map 8Mb on 601 and 16Mb
- * on other PPCs. This may cause trouble if the framebuffer
- * is really badly aligned, but I didn't encounter this case
- * yet.
- */
-__init
-static void
-prepare_disp_BAT(void)
-{
-	unsigned long offset = reloc_offset();
-	boot_infos_t* bi = PTRRELOC(RELOC(disp_bi));
-	unsigned long addr = (unsigned long)bi->dispDeviceBase;
-	
-	if ((_get_PVR() >> 16) != 1) {
-		/* 603, 604, G3, G4, ... */
-		addr &= 0xFF000000UL;
-		RELOC(disp_BATU) = addr | (BL_16M<<2) | 2;
-		RELOC(disp_BATL) = addr | (_PAGE_NO_CACHE | _PAGE_GUARDED | BPP_RW);		
-	} else {
-		/* 601 */
-		addr &= 0xFF800000UL;
-		RELOC(disp_BATU) = addr | (_PAGE_NO_CACHE | PP_RWXX) | 4;
-		RELOC(disp_BATL) = addr | BL_8M | 0x40;
-	}
-	bi->logicalDisplayBase = bi->dispDeviceBase;
-}
-
-#endif
-
-__init
-static int
-prom_set_color(ihandle ih, int i, int r, int g, int b)
-{
-	struct prom_args prom_args;
-	unsigned long offset = reloc_offset();
-
-	prom_args.service = RELOC("call-method");
-	prom_args.nargs = 6;
-	prom_args.nret = 1;
-	prom_args.args[0] = RELOC("color!");
-	prom_args.args[1] = ih;
-	prom_args.args[2] = (void *) i;
-	prom_args.args[3] = (void *) b;
-	prom_args.args[4] = (void *) g;
-	prom_args.args[5] = (void *) r;
-	RELOC(prom)(&prom_args);
-	return (int) prom_args.args[6];
-}
-
 /*
  * If we have a display that we don't know how to drive,
  * we will want to try to execute OF's open method for it
@@ -804,32 +635,11 @@
 static unsigned long
 check_display(unsigned long mem)
 {
-#ifdef CONFIG_FB
 	phandle node;
 	ihandle ih;
 	int i;
 	unsigned long offset = reloc_offset();
-	char type[16], *path, name[32];
-	static unsigned char default_colors[] = {
-		0x00, 0x00, 0x00,
-		0x00, 0x00, 0xaa,
-		0x00, 0xaa, 0x00,
-		0x00, 0xaa, 0xaa,
-		0xaa, 0x00, 0x00,
-		0xaa, 0x00, 0xaa,
-		0xaa, 0xaa, 0x00,
-		0xaa, 0xaa, 0xaa,
-		0x55, 0x55, 0x55,
-		0x55, 0x55, 0xff,
-		0x55, 0xff, 0x55,
-		0x55, 0xff, 0xff,
-		0xff, 0x55, 0x55,
-		0xff, 0x55, 0xff,
-		0xff, 0xff, 0x55,
-		0xff, 0xff, 0xff
-	};
-
-	RELOC(prom_disp_node) = 0;
+	char type[16], *path;
 
 	for (node = 0; prom_next_node(&node); ) {
 		type[0] = 0;
@@ -837,12 +647,6 @@
 			  type, sizeof(type));
 		if (strcmp(type, RELOC("display")) != 0)
 			continue;
-		name[0] = 0;
-		call_prom(RELOC("getprop"), 4, 1, node, RELOC("name"),
-			  name, sizeof(name));
-		if (!strcmp(name, RELOC("offscreen-display")))
-	    		continue;
-
 		/* It seems OF doesn't null-terminate the path :-( */
 		path = (char *) mem;
 		memset(path, 0, 256);
@@ -858,24 +662,6 @@
 		}
 		prom_print(RELOC("... ok\n"));
 
-		if (RELOC(prom_disp_node) == 0)
-			RELOC(prom_disp_node) = node;
-
-		/* Setup a useable color table when the appropriate
-		 * method is available. Should update this to set-colors */
-		for (i = 0; i < 32; i++)
-			if (prom_set_color(ih, i, RELOC(default_colors)[i*3],
-					   RELOC(default_colors)[i*3+1],
-					   RELOC(default_colors)[i*3+2]) != 0)
-				break;
-
-		for (i = 0; i < LINUX_LOGO_COLORS; i++)
-			if (prom_set_color(ih, i + 32,
-					   RELOC(linux_logo_red)[i],
-					   RELOC(linux_logo_green)[i],
-					   RELOC(linux_logo_blue)[i]) != 0)
-				break;
-
 		/*
 		 * If this display is the device that OF is using for stdout,
 		 * move it to the front of the list.
@@ -892,85 +678,9 @@
 		if (RELOC(prom_num_displays) >= FB_MAX)
 			break;
 	}
-#endif /* CONFIG_FB */
 	return ALIGN(mem);
 }
 
-/* This function will enable the early boot text when doing OF booting. This
- * way, xmon output should work too
- */
-#ifdef CONFIG_BOOTX_TEXT
-__init
-static void
-setup_disp_fake_bi(ihandle dp)
-{
-	unsigned int len;
-	int width = 640, height = 480, depth = 8, pitch;
-	unsigned  address;
-	boot_infos_t* bi;
-	unsigned long offset = reloc_offset();
-	
-	prom_print(RELOC("Initing fake screen\n"));
-
-	len = 0;
-	call_prom(RELOC("getprop"), 4, 1, dp, RELOC("depth"), &len, sizeof(len));
-	if (len == 0)
-		prom_print(RELOC("Warning: assuming display depth = 8\n"));
-	else
-		depth = len;
-	width = len = 0;
-	call_prom(RELOC("getprop"), 4, 1, dp, RELOC("width"), &len, sizeof(len));
-	width = len;
-	if (width == 0) {
-		prom_print(RELOC("Failed to get width\n"));
-		return;
-	}
-	height = len = 0;
-	call_prom(RELOC("getprop"), 4, 1, dp, RELOC("height"), &len, sizeof(len));
-	height = len;
-	if (height == 0) {
-		prom_print(RELOC("Failed to get height\n"));
-		return;
-	}
-	pitch = len = 0;
-	call_prom(RELOC("getprop"), 4, 1, dp, RELOC("linebytes"), &len, sizeof(len));
-	pitch = len;
-	if (pitch == 0) {
-		prom_print(RELOC("Failed to get pitch\n"));
-		return;
-	}
-	if (pitch == 1)
-		pitch = 0x1000;
-	address = len = 0;
-	len = 0xfa000000;
-	call_prom(RELOC("getprop"), 4, 1, dp, RELOC("address"), &len, sizeof(len));
-	address = len;
-	if (address == 0) {
-		prom_print(RELOC("Failed to get address\n"));
-		return;
-	}
-#if 0
-	/* kludge for valkyrie */
-	if (strcmp(dp->name, "valkyrie") == 0) 
-	    address += 0x1000;
-#endif
- 
-	RELOC(disp_bi) = &fake_bi;
-	bi = PTRRELOC((&fake_bi));
-	RELOC(g_loc_X) = 0;
-	RELOC(g_loc_Y) = 0;
-	RELOC(g_max_loc_X) = width / 8;
-	RELOC(g_max_loc_Y) = height / 16;
-	bi->logicalDisplayBase = (unsigned char *)address;
-	bi->dispDeviceBase = (unsigned char *)address;
-	bi->dispDeviceRowBytes = pitch;
-	bi->dispDeviceDepth = depth;
-	bi->dispDeviceRect[0] = bi->dispDeviceRect[1] = 0;
-	bi->dispDeviceRect[2] = width;
-	bi->dispDeviceRect[3] = height;
-}
-#endif
-
 __init
 static int
 prom_next_node(phandle *nodep)
@@ -1106,18 +816,6 @@
 {
 	unsigned long mem = (unsigned long) klimit;
 
-	/* All newworld machines and CHRP now use the interrupt tree */
-	struct device_node *np = allnodes;
-	while(np && (_machine == _MACH_Pmac)) {
-		if (get_property(np, "interrupt-parent", 0)) {
-			pmac_newworld = 1;
-			break;
-		}
-		np = np->allnext;
-	}
-	if ((_machine == _MACH_chrp) || (boot_infos == 0 && pmac_newworld))
-		use_of_interrupt_tree = 1;
-
 	mem = finish_node(allnodes, mem, NULL);
 	printk(KERN_INFO "device tree used %lu bytes\n",
 	       mem - (unsigned long) allnodes);
@@ -1158,9 +856,6 @@
 	if (ifunc != NULL) {
 		mem_start = ifunc(np, mem_start);
 	}
-	if (use_of_interrupt_tree) {
-		mem_start = finish_node_interrupts(np, mem_start);
-	}
 
 	/* the f50 sets the name to 'display' and 'compatible' to what we
 	 * expect for the name -- Cort
@@ -1207,151 +902,6 @@
 	return mem_start;
 }
 
-/* This routine walks the interrupt tree for a given device node and gather 
- * all necessary informations according to the draft interrupt mapping
- * for CHRP. The current version was only tested on Apple "Core99" machines
- * and may not handle cascaded controllers correctly.
- */
-__init
-static unsigned long
-finish_node_interrupts(struct device_node *np, unsigned long mem_start)
-{
-	/* Finish this node */
-	unsigned int *isizep, *asizep, *interrupts, *map, *map_mask, *reg;
-	phandle *parent;
-	struct device_node *node, *parent_node;
-	int l, isize, ipsize, asize, map_size, regpsize;
-
-	/* Currently, we don't look at all nodes with no "interrupts" property */
-	interrupts = (unsigned int *)get_property(np, "interrupts", &l);
-	if (interrupts == NULL)
-		return mem_start;
-	ipsize = l>>2;
-
-	reg = (unsigned int *)get_property(np, "reg", &l);
-	regpsize = l>>2;
-
-	/* We assume default interrupt cell size is 1 (bugus ?) */
-	isize = 1;
-	node = np;
-	
-	do {
-	    /* We adjust the cell size if the current parent contains an #interrupt-cells
-	     * property */
-	    isizep = (unsigned int *)get_property(node, "#interrupt-cells", &l);
-	    if (isizep)
-	    	isize = *isizep;
-
-	    /* We don't do interrupt cascade (ISA) for now, we stop on the first 
-	     * controller found
-	     */
-	    if (get_property(node, "interrupt-controller", &l)) {
-	    	int i,j;
-	    	np->intrs = (struct interrupt_info *) mem_start;
-		np->n_intrs = ipsize / isize;
-		mem_start += np->n_intrs * sizeof(struct interrupt_info);
-		for (i = 0; i < np->n_intrs; ++i) {
-		    np->intrs[i].line = *interrupts++;
-		    np->intrs[i].sense = 0;
-		    if (isize > 1)
-		        np->intrs[i].sense = *interrupts++;
-		    for (j=2; j<isize; j++)
-		    	interrupts++;
-		}
-		/*
-		 *  On the CHRP LongTrail, ISA interrupts are cascaded through
-		 *  the OpenPIC. For compatibility reasons, ISA interrupts are
-		 *  numbered 0-15 and OpenPIC interrupts start at 16.
-		 *  Hence we have to fixup the interrupt numbers for sources
-		 *  that are attached to the OpenPIC and thus have an
-		 *  interrupt-controller named `open-pic'.
-		 *
-		 *  FIXME: The name of the interrupt-controller node for the
-		 *         `ide' node has no name, although its parent is
-		 *         correctly specified in interrupt-map, so we check
-		 *         for a NULL name as well.
-		 */
-		if (_machine == _MACH_chrp &&
-		    ((node->name && !strcmp(node->name, "open-pic")) ||
-		     !node->name)) {
-		    for (i = 0; i < np->n_intrs; ++i)
-			np->intrs[i].line = np->intrs[i].line + NUM_8259_INTERRUPTS;
-		}
-		return mem_start;
-	    }
-	    /* We lookup for an interrupt-map. This code can only handle one interrupt
-	     * per device in the map. We also don't handle #address-cells in the parent
-	     * I skip the pci node itself here, may not be necessary but I don't like it's
-	     * reg property.
-	     */
-	    if (np != node)
-	        map = (unsigned int *)get_property(node, "interrupt-map", &l);
-	     else
-	     	map = NULL;
-	    if (map && l) {
-	    	int i, found, temp_isize;
-	        map_size = l>>2;
-	        map_mask = (unsigned int *)get_property(node, "interrupt-map-mask", &l);
-	        asizep = (unsigned int *)get_property(node, "#address-cells", &l);
-	        if (asizep && l == sizeof(unsigned int))
-	            asize = *asizep;
-	        else
-	            asize = 0;
-	        found = 0;
-	        while(map_size>0 && !found) {
-	            found = 1;
-	            for (i=0; i<asize; i++) {
-	            	unsigned int mask = map_mask ? map_mask[i] : 0xffffffff;
-	            	if (!reg || (i>=regpsize) || ((mask & *map) != (mask & reg[i])))
-	           	    found = 0;
-	           	map++;
-	           	map_size--;
-	            }
-	            for (i=0; i<isize; i++) {
-	            	unsigned int mask = map_mask ? map_mask[i+asize] : 0xffffffff;
-	            	if ((mask & *map) != (mask & interrupts[i]))
-	            	    found = 0;
-	            	map++;
-	            	map_size--;
-	            }
-	            parent = *((phandle *)(map));
-	            map+=1; map_size-=1;
-	            parent_node = find_phandle(parent);
-	            temp_isize = isize;
-	            if (parent_node) {
-			isizep = (unsigned int *)get_property(parent_node, "#interrupt-cells", &l);
-	    		if (isizep)
-	    		    temp_isize = *isizep;
-	            }
-	            if (!found) {
-	            	map += temp_isize;
-	            	map_size-=temp_isize;
-	            }
-	        }
-	        if (found) {
-	            node = parent_node;
-	            reg = NULL;
-	            regpsize = 0;
-	            interrupts = (unsigned int *)map;
-	            ipsize = temp_isize*1;
-		    continue;
-	        }
-	    }
-	    /* We look for an explicit interrupt-parent.
-	     */
-	    parent = (phandle *)get_property(node, "interrupt-parent", &l);
-	    if (parent && (l == sizeof(phandle)) &&
-	    	(parent_node = find_phandle(*parent))) {
-	    	node = parent_node;
-	    	continue;
-	    }
-	    /* Default, get real parent */
-	    node = node->parent;
-	} while(node);
-
-	return mem_start;
-}
-
 /*
  * When BootX makes a copy of the device tree from the MacOS
  * Name Registry, it is in the format we use but all of the pointers
@@ -1410,9 +960,6 @@
 		mem_start += i * sizeof(struct address_range);
 	}
 
-	if (use_of_interrupt_tree)
-		return mem_start;
-
 	/*
 	 * If the pci host bridge has an interrupt-map property,
 	 * look for our node in it.
@@ -1422,28 +969,14 @@
 		get_property(np->parent, "interrupt-map", &ml)) != 0
 	    && (ip = (int *) get_property(np, "interrupts", &l)) != 0) {
 		unsigned int devfn = pci_addrs[0].addr.a_hi & 0xff00;
-		unsigned int cell_size;
-		struct device_node* np2;
-		/* This is hackish, but is only used for BootX booting */
-		cell_size = sizeof(struct pci_intr_map);
-		np2 = np->parent;
-		while(np2) {
-			if (device_is_compatible(np2, "uni-north")) {
-				cell_size += 4;
-				break;
-			}
-			np2 = np2->parent;
-		}
 		np->n_intrs = 0;
 		np->intrs = (struct interrupt_info *) mem_start;
-		for (i = 0; (ml -= cell_size) >= 0; ++i) {
-			if (imp->addr.a_hi == devfn) {
-				np->intrs[np->n_intrs].line = imp->intr;
-				np->intrs[np->n_intrs].sense = 0; /* FIXME */
+		for (i = 0; (ml -= sizeof(struct pci_intr_map)) >= 0; ++i) {
+			if (imp[i].addr.a_hi == devfn) {
+				np->intrs[np->n_intrs].line = imp[i].intr;
+				np->intrs[np->n_intrs].sense = 0;
 				++np->n_intrs;
 			}
-			imp = (struct pci_intr_map *)(((unsigned int)imp)
-				+ cell_size);
 		}
 		if (np->n_intrs == 0)
 			np->intrs = 0;
@@ -1500,9 +1033,6 @@
 		mem_start += i * sizeof(struct address_range);
 	}
 
-	if (use_of_interrupt_tree)
-		return mem_start;
-
 	ip = (int *) get_property(np, "AAPL,interrupts", &l);
 	if (ip == 0)
 		ip = (int *) get_property(np, "interrupts", &l);
@@ -1526,14 +1056,13 @@
 	struct reg_property *rp;
 	struct address_range *adr;
 	unsigned long base_address;
-	int i, l, keylargo, *ip;
+	int i, l, *ip;
 	struct device_node *db;
 
 	base_address = 0;
 	for (db = np->parent; db != NULL; db = db->parent) {
 		if (!strcmp(db->type, "mac-io") && db->n_addrs != 0) {
 			base_address = db->addrs[0].address;
-			keylargo = device_is_compatible(db, "Keylargo");
 			break;
 		}
 	}
@@ -1553,9 +1082,6 @@
 		mem_start += i * sizeof(struct address_range);
 	}
 
-	if (use_of_interrupt_tree)
-		return mem_start;
-
 	ip = (int *) get_property(np, "interrupts", &l);
 	if (ip == 0)
 		ip = (int *) get_property(np, "AAPL,interrupts", &l);
@@ -1564,21 +1090,15 @@
 		if (_machine == _MACH_Pmac) {
 			/* for the iMac */
 			np->n_intrs = l / sizeof(int);
-			/* Hack for BootX on Core99 */
-			if (keylargo)
-				np->n_intrs = np->n_intrs/2;
 			for (i = 0; i < np->n_intrs; ++i) {
 				np->intrs[i].line = *ip++;
-				if (keylargo)
-					np->intrs[i].sense = *ip++;
-				else
-					np->intrs[i].sense = 0;
+				np->intrs[i].sense = 0;
 			}
 		} else {
 			/* CHRP machines */
 			np->n_intrs = l / (2 * sizeof(int));
 			for (i = 0; i < np->n_intrs; ++i) {
-				np->intrs[i].line = (*ip++) + NUM_8259_INTERRUPTS;
+				np->intrs[i].line = openpic_to_irq(*ip++);
 				np->intrs[i].sense = *ip++;
 			}
 		}
@@ -1612,9 +1132,6 @@
 		mem_start += i * sizeof(struct address_range);
 	}
 
-	if (use_of_interrupt_tree)
-		return mem_start;
- 
 	ip = (int *) get_property(np, "interrupts", &l);
 	if (ip != 0) {
 		np->intrs = (struct interrupt_info *) mem_start;
@@ -1652,9 +1169,6 @@
 		mem_start += i * sizeof(struct address_range);
 	}
 
-	if (use_of_interrupt_tree)
-		return mem_start;
-
 	ip = (int *) get_property(np, "AAPL,interrupts", &l);
 	if (ip == 0)
 		ip = (int *) get_property(np, "interrupts", &l);
@@ -1711,57 +1225,6 @@
 	return head;
 }
 
-/* Finds a device node given its PCI bus number, device number
- * and function number
- */
-__openfirmware
-struct device_node *
-find_pci_device_OFnode(unsigned char bus, unsigned char dev_fn)
-{
-	struct device_node* np;
-	unsigned int *reg;
-	int l;
-	
-	for (np = allnodes; np != 0; np = np->allnext) {
-		int in_macio = 0;
-		struct device_node* parent = np->parent;
-		while(parent) {
-			char *pname = (char *)get_property(parent, "name", &l);
-			if (pname && strcmp(pname, "mac-io") == 0) {
-				in_macio = 1;
-				break;
-			}
-			parent = parent->parent;
-		}
-		if (in_macio)
-			continue;
-		reg = (unsigned int *) get_property(np, "reg", &l);
-		if (reg == 0 || l < sizeof(struct reg_property))
-			continue;
-		if (((reg[0] >> 8) & 0xff) == dev_fn && ((reg[0] >> 16) & 0xff) == bus)
-			break;
-	}
-	return np;
-}
-
-/*
- * Returns all nodes linked together
- */
-__openfirmware
-struct device_node *
-find_all_nodes(void)
-{
-	struct device_node *head, **prevp, *np;
-
-	prevp = &head;
-	for (np = allnodes; np != 0; np = np->allnext) {
-		*prevp = np;
-		prevp = &np->next;
-	}
-	*prevp = 0;
-	return head;
-}
-
 /* Checks if the given "compat" string matches one of the strings in
  * the device's "compatible" property
  */
@@ -1851,7 +1314,7 @@
 	struct property *pp;
 
 	for (pp = np->properties; pp != 0; pp = pp->next)
-		if (pp->name && strcmp(pp->name, name) == 0) {
+		if (strcmp(pp->name, name) == 0) {
 			if (lenp != 0)
 				*lenp = pp->length;
 			return pp->value;
@@ -1963,63 +1426,18 @@
 	prom_exit();
 }
 
-/* Indicates whether the root node has a given value in its
- * compatible property.
- */
-__openfirmware
-int
-machine_is_compatible(const char *compat)
-{
-	struct device_node *root;
-	
-	root = find_path_device("/");
-	if (root == 0)
-		return 0;
-	return device_is_compatible(root, compat);
-}
-
-
-#ifdef CONFIG_BOOTX_TEXT
-
-/* Here's a small text engine to use during early boot or for debugging purposes
- * 
- * todo:
- * 
- *  - build some kind of vgacon with it to enable early printk
- *  - move to a separate file
- *  - add a few video driver hooks to keep in sync with display
- *    changes.
- */
-
+#ifdef CONFIG_XMON
 __init
 void
 map_bootx_text(void)
 {
-	unsigned long base, offset, size;
-	if (disp_bi == 0)
+	if (boot_infos == 0)
 		return;
-	base = ((unsigned long) disp_bi->dispDeviceBase) & 0xFFFFF000UL;
-	offset = ((unsigned long) disp_bi->dispDeviceBase) - base;
-	size = disp_bi->dispDeviceRowBytes * disp_bi->dispDeviceRect[3] + offset
-		+ disp_bi->dispDeviceRect[0];
-	disp_bi->logicalDisplayBase = ioremap(base, size) + offset;
-}
-
-__init
-void
-install_boot_console(void)
-{
-	register_console(&boot_cons);
-	boot_cons_registered = 1;
-}
-
-void
-remove_boot_console(void)
-{
-	if (boot_cons_registered)
-		unregister_console(&boot_cons);
-	boot_cons_registered = 0;
+	boot_infos->logicalDisplayBase =
+		ioremap((unsigned long) boot_infos->dispDeviceBase,
+			boot_infos->dispDeviceRowBytes * boot_infos->dispDeviceRect[3]);
 }
+#endif /* CONFIG_XMON */
 
 /* Calc the base address of a given point (x,y) */
 __pmac
@@ -2041,7 +1459,7 @@
 clearscreen(void)
 {
 	unsigned long offset	= reloc_offset();
-	boot_infos_t* bi	= PTRRELOC(RELOC(disp_bi));
+	boot_infos_t* bi	= PTRRELOC(RELOC(boot_infos));
 	unsigned long *base	= (unsigned long *)calc_base(bi, 0, 0);
 	unsigned long width 	= ((bi->dispDeviceRect[2] - bi->dispDeviceRect[0]) *
 					(bi->dispDeviceDepth >> 3)) >> 2;
@@ -2066,7 +1484,7 @@
 flushscreen(void)
 {
 	unsigned long offset	= reloc_offset();
-	boot_infos_t* bi	= PTRRELOC(RELOC(disp_bi));
+	boot_infos_t* bi	= PTRRELOC(RELOC(boot_infos));
 	unsigned long *base	= (unsigned long *)calc_base(bi, 0, 0);
 	unsigned long width 	= ((bi->dispDeviceRect[2] - bi->dispDeviceRect[0]) *
 					(bi->dispDeviceDepth >> 3)) >> 2;
@@ -2083,22 +1501,68 @@
 	}
 }
 
+/* Indicates whether the root node has a given value in its
+ * compatible property.
+ */
+__openfirmware
+int
+machine_is_compatible(const char *compat)
+{
+	struct device_node *root;
+	
+	root = find_path_device("/");
+	if (root == 0)
+		return 0;
+	return device_is_compatible(root, compat);
+}
+
+/* Finds a device node given its PCI bus number, device number
+ * and function number
+ */
+__openfirmware
+struct device_node *
+find_pci_device_OFnode(unsigned char bus, unsigned char dev_fn)
+{
+	struct device_node* np;
+	unsigned int *reg;
+	int l;
+	
+	for (np = allnodes; np != 0; np = np->allnext) {
+		int in_macio = 0;
+		struct device_node* parent = np->parent;
+		while(parent) {
+			char *pname = (char *)get_property(parent, "name", &l);
+			if (pname && strcmp(pname, "mac-io") == 0) {
+				in_macio = 1;
+				break;
+			}
+			parent = parent->parent;
+		}
+		if (in_macio)
+			continue;
+		reg = (unsigned int *) get_property(np, "reg", &l);
+		if (reg == 0 || l < sizeof(struct reg_property))
+			continue;
+		if (((reg[0] >> 8) & 0xff) == dev_fn && ((reg[0] >> 16) & 0xff) == bus)
+			break;
+	}
+	return np;
+}
+
+#ifdef CONFIG_BOOTX_TEXT
+
 __pmac
 static void
 scrollscreen(void)
 {
 	unsigned long offset		= reloc_offset();
-	boot_infos_t* bi		= PTRRELOC(RELOC(disp_bi));
+	boot_infos_t* bi		= PTRRELOC(RELOC(boot_infos));
 	unsigned long *src		= (unsigned long *)calc_base(bi,0,16);
 	unsigned long *dst		= (unsigned long *)calc_base(bi,0,0);
 	unsigned long width		= ((bi->dispDeviceRect[2] - bi->dispDeviceRect[0]) *
 						(bi->dispDeviceDepth >> 3)) >> 2;
 	int i,j;
-
-#ifdef CONFIG_POWERMAC
-	pmu_suspend();
-#endif
-
+	
 	for (i=0; i<(bi->dispDeviceRect[3] - bi->dispDeviceRect[1] - 16); i++)
 	{
 		unsigned long *src_ptr = src;
@@ -2115,10 +1579,6 @@
 			*(dst_ptr++) = 0;
 		dst += (bi->dispDeviceRowBytes >> 2);
 	}
-
-#ifdef CONFIG_POWERMAC
-	pmu_resume();
-#endif
 }
 
 __pmac
@@ -2163,18 +1623,8 @@
 		drawchar(*c++);
 }
 
-#ifdef CONFIG_BOOTX_TEXT
-__pmac
-static void boot_console_write(struct console *co, const char *s,
-				 unsigned count)
-{
-	while(count--)
-		drawchar(*s++);
-}
-#endif
-
 __pmac
-void
+static void
 drawhex(unsigned long v)
 {
 	static char hex_table[] = "0123456789abcdef";
@@ -2196,20 +1646,19 @@
 draw_byte(unsigned char c, long locX, long locY)
 {
 	unsigned long offset	= reloc_offset();
-	boot_infos_t* bi	= PTRRELOC(RELOC(disp_bi));
+	boot_infos_t* bi	= PTRRELOC(RELOC(boot_infos));
 	unsigned char *base	= calc_base(bi, locX << 3, locY << 4);
 	unsigned char *font	= &RELOC(vga_font)[((unsigned long)c) * 16];
-	int rb			= bi->dispDeviceRowBytes;
 	
 	switch(bi->dispDeviceDepth) {
 		case 32:
-			draw_byte_32(font, (unsigned long *)base, rb);
+			draw_byte_32(font, (unsigned long *)base);
 			break;
 		case 16:
-			draw_byte_16(font, (unsigned long *)base, rb);
+			draw_byte_16(font, (unsigned long *)base);
 			break;
 		case 8:
-			draw_byte_8(font, (unsigned long *)base, rb);
+			draw_byte_8(font, (unsigned long *)base);
 			break;
 		default:
 			break;
@@ -2247,8 +1696,10 @@
 
 __pmac
 static void
-draw_byte_32(unsigned char *font, unsigned long *base, int rb)
+draw_byte_32(unsigned char *font, unsigned long *base)
 {
+	unsigned long offset = reloc_offset();
+	boot_infos_t* bi		= PTRRELOC(RELOC(boot_infos));
 	int l, bits;	
 	int fg = 0xFFFFFFFFUL;
 	int bg = 0x00000000UL;
@@ -2265,18 +1716,19 @@
 		base[5] = (-((bits >> 2) & 1) & fg) ^ bg;
 		base[6] = (-((bits >> 1) & 1) & fg) ^ bg;
 		base[7] = (-(bits & 1) & fg) ^ bg;
-		base = (unsigned long *) ((char *)base + rb);
+		base = (unsigned long *) ((char *)base + bi->dispDeviceRowBytes);
 	}
 }
 
 __pmac
 static void
-draw_byte_16(unsigned char *font, unsigned long *base, int rb)
+draw_byte_16(unsigned char *font, unsigned long *base)
 {
+	unsigned long offset = reloc_offset();
+	boot_infos_t* bi		= PTRRELOC(RELOC(boot_infos));
 	int l, bits;	
 	int fg = 0xFFFFFFFFUL;
 	int bg = 0x00000000UL;
-	unsigned long offset = reloc_offset();
 	unsigned long *eb = RELOC(expand_bits_16);
 
 	for (l = 0; l < 16; ++l)
@@ -2286,18 +1738,19 @@
 		base[1] = (eb[(bits >> 4) & 3] & fg) ^ bg;
 		base[2] = (eb[(bits >> 2) & 3] & fg) ^ bg;
 		base[3] = (eb[bits & 3] & fg) ^ bg;
-		base = (unsigned long *) ((char *)base + rb);
+		base = (unsigned long *) ((char *)base + bi->dispDeviceRowBytes);
 	}
 }
 
 __pmac
 static void
-draw_byte_8(unsigned char *font, unsigned long *base, int rb)
+draw_byte_8(unsigned char *font, unsigned long *base)
 {
+	unsigned long offset = reloc_offset();
+	boot_infos_t* bi		= PTRRELOC(RELOC(boot_infos));
 	int l, bits;	
 	int fg = 0x0F0F0F0FUL;
 	int bg = 0x00000000UL;
-	unsigned long offset = reloc_offset();
 	unsigned long *eb = RELOC(expand_bits_8);
 
 	for (l = 0; l < 16; ++l)
@@ -2305,7 +1758,7 @@
 		bits = *font++;
 		base[0] = (eb[bits >> 4] & fg) ^ bg;
 		base[1] = (eb[bits & 0xf] & fg) ^ bg;
-		base = (unsigned long *) ((char *)base + rb);
+		base = (unsigned long *) ((char *)base + bi->dispDeviceRowBytes);
 	}
 }
 
diff -urN linux.orig/arch/ppc/kernel/ptrace.c linux/arch/ppc/kernel/ptrace.c
--- linux.orig/arch/ppc/kernel/ptrace.c	Fri Nov  2 17:39:05 2001
+++ linux/arch/ppc/kernel/ptrace.c	Thu Jul 11 15:43:29 2002
@@ -29,6 +29,7 @@
 #include <asm/uaccess.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
+#include <asm/pf-compat.h>
 #include <asm/system.h>
 
 /*
@@ -341,10 +342,10 @@
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
-		if (current->ptrace & PT_PTRACED)
+		if (current->flags & PF_PTRACED)
 			goto out;
 		/* set the ptrace bit in the process flags. */
-		current->ptrace |= PT_PTRACED;
+		current->flags |= PF_PTRACED;
 		ret = 0;
 		goto out;
 	}
@@ -370,9 +371,9 @@
 	 	    (current->gid != child->gid)) && !capable(CAP_SYS_PTRACE))
 			goto out;
 		/* the same process cannot be attached many times */
-		if (child->ptrace & PT_PTRACED)
+		if (child->flags & PF_PTRACED)
 			goto out;
-		child->ptrace |= PT_PTRACED;
+		child->flags |= PF_PTRACED;
 
 		write_lock_irqsave(&tasklist_lock, flags);
 		if (child->p_pptr != current) {
@@ -387,7 +388,7 @@
 		goto out;
 	}
 	ret = -ESRCH;
-	if (!(child->ptrace & PT_PTRACED))
+	if (!(child->flags & PF_PTRACED))
 		goto out;
 	if (child->state != TASK_STOPPED) {
 		if (request != PTRACE_KILL)
@@ -472,9 +473,9 @@
 			if ((unsigned long) data > _NSIG)
 				goto out;
 			if (request == PTRACE_SYSCALL)
-				child->ptrace |= PT_TRACESYS;
+				child->flags |= PF_TRACESYS;
 			else
-				child->ptrace &= ~PT_TRACESYS;
+				child->flags &= ~PF_TRACESYS;
 			child->exit_code = data;
 			/* make sure the single step bit is not set. */
 			clear_single_step(child);
@@ -503,7 +504,7 @@
 			ret = -EIO;
 			if ((unsigned long) data > _NSIG)
 				goto out;
-			child->ptrace &= ~PT_TRACESYS;
+			child->flags &= ~PF_TRACESYS;
 			set_single_step(child);
 			child->exit_code = data;
 			/* give it a chance to run. */
@@ -516,7 +517,7 @@
 			ret = -EIO;
 			if ((unsigned long) data > _NSIG)
 				goto out;
-			child->ptrace &= ~(PT_PTRACED|PT_TRACESYS);
+			child->flags &= ~(PF_PTRACED|PF_TRACESYS);
 			child->exit_code = data;
 			write_lock_irqsave(&tasklist_lock, flags);
 			REMOVE_LINKS(child);
@@ -541,8 +542,8 @@
 
 asmlinkage void syscall_trace(void)
 {
-	if ((current->ptrace & (PT_PTRACED|PT_TRACESYS))
-			!= (PT_PTRACED|PT_TRACESYS))
+	if ((current->flags & (PF_PTRACED|PF_TRACESYS))
+			!= (PF_PTRACED|PF_TRACESYS))
 		return;
 	current->exit_code = SIGTRAP;
 	current->state = TASK_STOPPED;
diff -urN linux.orig/arch/ppc/kernel/setup.c linux/arch/ppc/kernel/setup.c
--- linux.orig/arch/ppc/kernel/setup.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/setup.c	Thu Jul 11 15:47:12 2002
@@ -31,7 +31,6 @@
 #endif
 #include <asm/bootx.h>
 #include <asm/machdep.h>
-#include <asm/uaccess.h>
 
 extern void pmac_init(unsigned long r3,
                       unsigned long r4,
@@ -69,10 +68,6 @@
                       unsigned long r6,
                       unsigned long r7);
 
-#ifdef CONFIG_XMON
-extern void xmon_map_scc(void);
-#endif
-
 extern boot_infos_t *boot_infos;
 extern char cmd_line[512];
 char saved_command_line[256];
@@ -80,6 +75,10 @@
 
 struct ide_machdep_calls ppc_ide_md;
 
+#ifdef CONFIG_MAGIC_SYSRQ
+unsigned long SYSRQ_KEY;
+#endif /* CONFIG_MAGIC_SYSRQ */
+
 unsigned long ISA_DMA_THRESHOLD;
 unsigned long DMA_MODE_READ, DMA_MODE_WRITE;
 
@@ -96,12 +95,6 @@
 
 struct machdep_calls ppc_md;
 
-#ifdef CONFIG_MAGIC_SYSRQ
-unsigned long SYSRQ_KEY;
-#endif /* CONFIG_MAGIC_SYSRQ */
-#ifdef CONFIG_VGA_CONSOLE
-unsigned long vgacon_remap_base;
-#endif
 
 /* copy of the residual data */
 #ifndef CONFIG_MBX
@@ -267,9 +260,6 @@
 		case 10:
 			len += sprintf(len+buffer, "604ev5 (MachV)\n");
 			break;
-		case 12:
-			len += sprintf(len+buffer, "7400 (G4)\n");
-			break;
 		case 50:
 			len += sprintf(len+buffer, "821\n");
 		case 80:
@@ -322,6 +312,14 @@
 		bogosum += CD(loops_per_jiffy);
 	}
 
+#ifdef __SMP__
+	if ( i )
+		len += sprintf(buffer+len, "\n");
+	len += sprintf(buffer+len,"total bogomips\t: %lu.%02lu\n",
+		       (bogosum+2500)/500000,
+		       (bogosum+2500)/5000 % 100);
+#endif /* __SMP__ */
+
 	/*
 	 * Ooh's and aah's info about zero'd pages in idle task
 	 */ 
@@ -486,21 +484,15 @@
 
 	switch (_machine)
 	{
-#ifdef CONFIG_POWERMAC
 	case _MACH_Pmac:
                 pmac_init(r3, r4, r5, r6, r7);
 		break;
-#endif
-#if defined(CONFIG_ALL_PPC) || defined(CONFIG_PREP)
 	case _MACH_prep:
                 prep_init(r3, r4, r5, r6, r7);
 		break;
-#endif
-#if defined(CONFIG_ALL_PPC) || defined(CONFIG_CHRP)
 	case _MACH_chrp:
                 chrp_init(r3, r4, r5, r6, r7);
 		break;
-#endif
 #ifdef CONFIG_APUS
 	case _MACH_apus:
                 apus_init(r3, r4, r5, r6, r7);
@@ -554,13 +546,12 @@
 /* Checks "l2cr=xxxx" command-line option */
 void ppc_setup_l2cr(char *str, int *ints)
 {
-	if ( ((_get_PVR() >> 16) == 8) || ((_get_PVR() >> 16) == 12) )
+	if ( (_get_PVR() >> 16) == 8)
 	{
 		unsigned long val = simple_strtoul(str, NULL, 0);
 		printk(KERN_INFO "l2cr set to %lx\n", val);
 		_set_L2CR(0);
-		if (val)
-			_set_L2CR(val);
+		_set_L2CR(val);
 	}
 }
 
@@ -581,16 +572,14 @@
 	extern unsigned long find_available_memory(void);
 	extern unsigned long *end_of_DRAM;
 
-
 #ifdef CONFIG_XMON
-	{
-		char *p;
+	extern void xmon_map_scc(void);
+	char *p;
 
-		xmon_map_scc();
-		p = strstr(cmd_line, "xmon");
-		if (p != NULL && (p == cmd_line || p[-1] == ' '))
-			xmon(0);
-	}
+	xmon_map_scc();
+	p = strstr(cmd_line, "xmon");
+	if (p != NULL && (p == cmd_line || p[-1] == ' '))
+		xmon(0);
 #endif /* CONFIG_XMON */
  
 	/* reboot on panic */	
@@ -610,15 +599,7 @@
 	*memory_end_p = (unsigned long) end_of_DRAM;
 
 	ppc_md.setup_arch(memory_start_p, memory_end_p);
-
-	sort_exception_table();
-}
-
-#ifndef CONFIG_POWERMAC
-void note_bootable_part(kdev_t dev, int part, int goodness)
-{
 }
-#endif
 
 void ppc_generic_ide_fix_driveid(struct hd_driveid *id)
 {
diff -urN linux.orig/arch/ppc/kernel/signal.c linux/arch/ppc/kernel/signal.c
--- linux.orig/arch/ppc/kernel/signal.c	Fri Nov  2 17:39:05 2001
+++ linux/arch/ppc/kernel/signal.c	Thu Jul 11 15:43:29 2002
@@ -14,16 +14,6 @@
  *  modify it under the terms of the GNU General Public License
  *  as published by the Free Software Foundation; either version
  *  2 of the License, or (at your option) any later version.
- *
- *
- * 2000-04-7.
- * Define a real-time signal frame with siginfo and ucontext
- * structures (setup_rt_frame()).
- * Stuck up a real-time signal frame when setting the signal
- * frame with SA_SIGINFO flags.
- * Add sys_rt_sigreturn() to undo the signal stack.
- *
- * Giovanna Ambrosini (ambrosini@lightning.ch)
  */
 
 #include <linux/sched.h>
@@ -41,6 +31,7 @@
 #include <asm/ucontext.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
+#include <asm/pf-compat.h>
 
 #define DEBUG_SIG 0
 
@@ -131,6 +122,13 @@
 }
 
 
+asmlinkage int sys_rt_sigreturn(unsigned long __unused)
+{
+	printk("sys_rt_sigreturn(): %s/%d not yet implemented.\n",
+	       current->comm,current->pid);
+	do_exit(SIGSEGV);
+}
+
 asmlinkage int
 sys_sigaltstack(const stack_t *uss, stack_t *uoss)
 {
@@ -174,11 +172,13 @@
  * When we have signals to deliver, we set up on the
  * user stack, going down from the original stack pointer:
  *	a sigregs struct
- * one or more sigcontext structs with
+ *	one or more sigcontext structs
  *	a gap of __SIGNAL_FRAMESIZE bytes
  *
  * Each of these things must be a multiple of 16 bytes in size.
  *
+ * XXX ultimately we will have to stack up a siginfo and ucontext
+ * for each rt signal.
  */
 struct sigregs {
 	elf_gregset_t	gp_regs;
@@ -189,15 +189,6 @@
 	int		abigap[56];
 };
 
-struct rt_sigframe
-{
- unsigned long _unused[2];
- struct siginfo *pinfo;
- void *puc;
- struct siginfo info;
- struct ucontext uc;
-};
-
 /*
  * Do a signal return; undo the signal stack.
  */
@@ -230,10 +221,6 @@
 		sr = (struct sigregs *) sigctx.regs;
 		if (regs->msr & MSR_FP )
 			giveup_fpu(current);
-#ifdef CONFIG_ALTIVEC
-		if (regs->msr & MSR_VEC)
-			giveup_altivec(current);
-#endif /* CONFIG_ALTIVEC */
 		if (copy_from_user(saved_regs, &sr->gp_regs,
 				   sizeof(sr->gp_regs)))
 			goto badframe;
@@ -269,91 +256,6 @@
 	do_exit(SIGSEGV);
 }	
 
-
-/*
- *  When we have rt signals to deliver, we set up on the
- *  user stack, going down from the original stack pointer:
- *    a sigregs struct
- *    one rt_sigframe struct (siginfo + ucontext)
- *    a gap of __SIGNAL_FRAMESIZE bytes
- *
- *  Each of these things must be a multiple of 16 bytes in size.
- *
- */
-asmlinkage int sys_rt_sigreturn(struct pt_regs *regs)
-{
- struct rt_sigframe *rt_sf;
- struct sigcontext_struct sigctx;
- struct sigregs *sr;
- int ret;
- elf_gregset_t saved_regs;  /* an array of ELF_NGREG unsigned longs */
- sigset_t set;
- stack_t st;
- unsigned long prevsp;
-
- rt_sf = (struct rt_sigframe *)(regs->gpr[1] + __SIGNAL_FRAMESIZE);
- if (copy_from_user(&sigctx, &rt_sf->uc.uc_mcontext, sizeof(sigctx))
-     || copy_from_user(&set, &rt_sf->uc.uc_sigmask, sizeof(set))
-     || copy_from_user(&st, &rt_sf->uc.uc_stack, sizeof(st)))
-  goto badframe;
- sigdelsetmask(&set, ~_BLOCKABLE);
- spin_lock_irq(&current->sigmask_lock);
- current->blocked = set;
- recalc_sigpending(current);
- spin_unlock_irq(&current->sigmask_lock);
-
- rt_sf++;   /* Look at next rt_sigframe */
- if (rt_sf == (struct rt_sigframe *)(sigctx.regs)) {
-  /* Last stacked signal - restore registers -
-   * sigctx is initialized to point to the
-   * preamble frame (where registers are stored)
-   * see handle_signal()
-   */
-  sr = (struct sigregs *) sigctx.regs;
-  if (regs->msr & MSR_FP )
-   giveup_fpu(current);
-  if (copy_from_user(saved_regs, &sr->gp_regs,
-       sizeof(sr->gp_regs)))
-   goto badframe;
-  saved_regs[PT_MSR] = (regs->msr & ~MSR_USERCHANGE)
-   | (saved_regs[PT_MSR] & MSR_USERCHANGE);
-  memcpy(regs, saved_regs, GP_REGS_SIZE);
-  if (copy_from_user(current->tss.fpr, &sr->fp_regs,
-       sizeof(sr->fp_regs)))
-   goto badframe;
-  /* This function sets back the stack flags into
-     the current task structure.  */
-  sys_sigaltstack(&st, NULL);
-
-  ret = regs->result;
- } else {
-  /* More signals to go */
-  /* Set up registers for next signal handler */
-  regs->gpr[1] = (unsigned long)rt_sf - __SIGNAL_FRAMESIZE;
-  if (copy_from_user(&sigctx, &rt_sf->uc.uc_mcontext, sizeof(sigctx)))
-   goto badframe;
-  sr = (struct sigregs *) sigctx.regs;
-  regs->gpr[3] = ret = sigctx.signal;
-  /* Get the siginfo   */
-  get_user(regs->gpr[4], (unsigned long *)&rt_sf->pinfo);
-  /* Get the ucontext */
-  get_user(regs->gpr[5], (unsigned long *)&rt_sf->puc);
-  regs->gpr[6] = (unsigned long) rt_sf;
-
-  regs->link = (unsigned long) &sr->tramp;
-  regs->nip = sigctx.handler;
-  if (get_user(prevsp, &sr->gp_regs[PT_R1])
-      || put_user(prevsp, (unsigned long *) regs->gpr[1]))
-   goto badframe;
- }
- return ret;
-
-badframe:
- lock_kernel();
- do_exit(SIGSEGV);
-}
-
-
 /*
  * Set up a signal frame.
  */
@@ -367,10 +269,6 @@
 		goto badframe;
 	if (regs->msr & MSR_FP)
 		giveup_fpu(current);
-#ifdef CONFIG_ALTIVEC
-	if (regs->msr & MSR_VEC)
-		giveup_altivec(current);
-#endif /* CONFIG_ALTIVEC */
 	if (__copy_to_user(&frame->gp_regs, regs, GP_REGS_SIZE)
 	    || __copy_to_user(&frame->fp_regs, current->tss.fpr,
 			      ELF_NFPREG * sizeof(double))
@@ -400,57 +298,6 @@
 	do_exit(SIGSEGV);
 }
 
-
-static void
-setup_rt_frame(struct pt_regs *regs, struct sigregs *frame,
-        signed long newsp)
-{
- struct rt_sigframe *rt_sf = (struct rt_sigframe *) newsp;
-
- /* Set up preamble frame */
- if (verify_area(VERIFY_WRITE, frame, sizeof(*frame)))
-  goto badframe;
- if (regs->msr & MSR_FP)
-  giveup_fpu(current);
- if (__copy_to_user(&frame->gp_regs, regs, GP_REGS_SIZE)
-     || __copy_to_user(&frame->fp_regs, current->tss.fpr,
-         ELF_NFPREG * sizeof(double))
- /* Set up to return from user space.
-    It calls the sc exception at offset 0x9999
-    for sys_rt_sigreturn().
- */
-     || __put_user(0x38006666UL, &frame->tramp[0]) /* li r0,0x6666 */
-     || __put_user(0x44000002UL, &frame->tramp[1])) /* sc */
-  goto badframe;
- flush_icache_range((unsigned long) &frame->tramp[0],
-      (unsigned long) &frame->tramp[2]);
-
- /* Retrieve rt_sigframe from stack and
-    set up registers for signal handler
- */
- newsp -= __SIGNAL_FRAMESIZE;
- if (put_user(regs->gpr[1], (unsigned long *)newsp)
-     || get_user(regs->nip, &rt_sf->uc.uc_mcontext.handler)
-     || get_user(regs->gpr[3], &rt_sf->uc.uc_mcontext.signal)
-     || get_user(regs->gpr[4], (unsigned long *)&rt_sf->pinfo)
-     || get_user(regs->gpr[5], (unsigned long *)&rt_sf->puc))
-  goto badframe;
-
- regs->gpr[1] = newsp;
- regs->gpr[6] = (unsigned long) rt_sf;
- regs->link = (unsigned long) frame->tramp;
-
- return;
-
-badframe:
-#if DEBUG_SIG
- printk("badframe in setup_rt_frame, regs=%p frame=%p newsp=%lx\n",
-        regs, frame, newsp);
-#endif
- lock_kernel();
- do_exit(SIGSEGV);
-}
-
 /*
  * OK, we're invoking a handler
  */
@@ -460,7 +307,6 @@
 	      unsigned long *newspp, unsigned long frame)
 {
 	struct sigcontext_struct *sc;
- struct rt_sigframe *rt_sf;
 
 	if (regs->trap == 0x0C00 /* System Call! */
 	    && ((int)regs->result == -ERESTARTNOHAND ||
@@ -468,47 +314,20 @@
 		 !(ka->sa.sa_flags & SA_RESTART))))
 		regs->result = -EINTR;
 
- /* Set up Signal Frame */
- if (ka->sa.sa_flags & SA_SIGINFO) {
-  /* Put a Real Time Context onto stack */
-  *newspp -= sizeof(*rt_sf);
-  rt_sf = (struct rt_sigframe *) *newspp;
-  if (verify_area(VERIFY_WRITE, rt_sf, sizeof(*rt_sf)))
-   goto badframe;
-
-  if (__put_user((unsigned long) ka->sa.sa_handler, &rt_sf->uc.uc_mcontext.handler)
-      || __put_user(&rt_sf->info, &rt_sf->pinfo)
-      || __put_user(&rt_sf->uc, &rt_sf->puc)
-      /* Put the siginfo */
-      || __copy_to_user(&rt_sf->info, info, sizeof(*info))
-      /* Create the ucontext */
-      || __put_user(0, &rt_sf->uc.uc_flags)
-      || __put_user(0, &rt_sf->uc.uc_link)
-      || __put_user(current->sas_ss_sp, &rt_sf->uc.uc_stack.ss_sp)
-      || __put_user(sas_ss_flags(regs->gpr[1]),
-      &rt_sf->uc.uc_stack.ss_flags)
-      || __put_user(current->sas_ss_size, &rt_sf->uc.uc_stack.ss_size)
-      || __copy_to_user(&rt_sf->uc.uc_sigmask, oldset, sizeof(*oldset))
-      /* mcontext.regs points to preamble register frame */
-      || __put_user((struct pt_regs *)frame, &rt_sf->uc.uc_mcontext.regs)
-      || __put_user(sig, &rt_sf->uc.uc_mcontext.signal))
-   goto badframe;
- } else {
-  /* Put another sigcontext on the stack */
-  *newspp -= sizeof(*sc);
-  sc = (struct sigcontext_struct *) *newspp;
-  if (verify_area(VERIFY_WRITE, sc, sizeof(*sc)))
-   goto badframe;
+	/* Put another sigcontext on the stack */
+	*newspp -= sizeof(*sc);
+	sc = (struct sigcontext_struct *) *newspp;
+	if (verify_area(VERIFY_WRITE, sc, sizeof(*sc)))
+		goto badframe;
 
-  if (__put_user((unsigned long) ka->sa.sa_handler, &sc->handler)
-      || __put_user(oldset->sig[0], &sc->oldmask)
+	if (__put_user((unsigned long) ka->sa.sa_handler, &sc->handler)
+	    || __put_user(oldset->sig[0], &sc->oldmask)
 #if _NSIG_WORDS > 1
-      || __put_user(oldset->sig[1], &sc->_unused[3])
+	    || __put_user(oldset->sig[1], &sc->_unused[3])
 #endif
-      || __put_user((struct pt_regs *)frame, &sc->regs)
-      || __put_user(sig, &sc->signal))
-   goto badframe;
- }
+	    || __put_user((struct pt_regs *)frame, &sc->regs)
+	    || __put_user(sig, &sc->signal))
+		goto badframe;
 
 	if (ka->sa.sa_flags & SA_ONESHOT)
 		ka->sa.sa_handler = SIG_DFL;
@@ -558,7 +377,7 @@
 		if (!signr)
 			break;
 
-		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
+		if ((current->flags & PF_PTRACED) && signr != SIGKILL) {
 			/* Let the debugger run.  */
 			current->exit_code = signr;
 			current->state = TASK_STOPPED;
@@ -664,10 +483,7 @@
 	if (newsp == frame)
 		return 0;		/* no signals delivered */
 
- if (ka->sa.sa_flags & SA_SIGINFO)
-  setup_rt_frame(regs, (struct sigregs *) frame, newsp);
- else
-  setup_frame(regs, (struct sigregs *) frame, newsp);
+	setup_frame(regs, (struct sigregs *) frame, newsp);
 	return 1;
 
 }
diff -urN linux.orig/arch/ppc/kernel/sleep.S linux/arch/ppc/kernel/sleep.S
--- linux.orig/arch/ppc/kernel/sleep.S	Sun Mar 25 18:37:30 2001
+++ linux/arch/ppc/kernel/sleep.S	Thu Jul 11 15:43:29 2002
@@ -1,6 +1,6 @@
 /*
  * This file contains sleep low-level functions for PowerBook G3.
- *    Copyright (C) 1999 Benjamin Herrenschmidt (benh@kernel.crashing.org)
+ *    Copyright (C) 1999 Benjamin Herrenschmidt (bh40@calva.net)
  *    and Paul Mackerras (paulus@cs.anu.edu.au).
  *
  * This program is free software; you can redistribute it and/or
@@ -113,8 +113,8 @@
 	stw	r4,SL_HID0(r1)
 
 	/* Set up stuff at address 0 */
-	lis	r5,grackle_wake_up@ha
-	addi	r5,r5,grackle_wake_up@l
+	lis	r5,wake_up@ha
+	addi	r5,r5,wake_up@l
 	tophys(r5,r5)
 	stw	r5,SL_PC(r1)
 	lis	r4,KERNELBASE@h
@@ -124,28 +124,22 @@
 	addi	r6,r6,MAGIC@l
 	stw	r5,0(r4)
 	stw	r6,4(r4)
-	/* Setup stuffs at 0x80-0x84 for Core99 */
-	lis	r3,core99_wake_up@ha
-	addi	r3,r3,core99_wake_up@l
-	tophys(r3,r3)
-	stw	r3,0x80(r4)
-	stw	r5,0x84(r4)
 
 /*
- * Flush the L1 data cache by reading the first 128kB of RAM
+ * Flush the L1 data cache by reading the first 64kB of RAM
  * and then flushing the same area with the dcbf instruction.
  * The L2 cache has already been disabled.
  */
-	li	r4,0x1000	/* 128kB / 32B */
+	li	r4,0x0800	/* 64kB / 32B */
 	mtctr	r4
 	lis	r4,KERNELBASE@h
 1:
 	lwz	r0,0(r4)
-	addi	r4,r4,0x0020	/* Go to start of next cache line */
+	addi	r4,r4,0x0020		/* Go to start of next cache line */
 	bdnz	1b
 	sync
 	
-	li	r4,0x1000	/* 128kB / 32B */
+	li	r4,0x0800	/* 64k */
 	mtctr	r4
 	lis	r4,KERNELBASE@h
 1:
@@ -154,14 +148,6 @@
 	bdnz	1b
 	sync
 
-/* Turn off L1 (necessary ?) */
-	mfspr	r3,HID0
-	ori	r3,r3, HID0_ICE|HID0_DCE
-	xori	r3,r3, HID0_ICE|HID0_DCE
-	mtspr	HID0,r3
-	sync
-	isync
-
 /*
  * Set the HID0 and MSR for sleep.
  */
@@ -177,50 +163,20 @@
 1:	sync
 	mtmsr	r2
 	isync
-	b	1b		
+	b	1b
 
-	
 /* 
  * Here is the resume code.
- * Core99 machines resume here
- * r4 has the physical address of SL_PC(sp).
- */
-
-core99_wake_up:
-	mr	r1,r4
-	mfspr	r3,HID0
-	/* use rlwinm ... */
-	oris	r3,r3,HID0_SLEEP@h
-	xoris	r3,r3,HID0_SLEEP@h
-	mtspr	HID0,r3
-	sync
-	isync
-	
-	/* sanitize MSR */
-	mfmsr	r3
-	ori	r3,r3,MSR_EE|MSR_IP
-	xori	r3,r3,MSR_EE|MSR_IP
-	mtmsr	r3
-	sync
-	isync
-		
-/* 
- * Here is the resume code for older machines.
  * r1 has the physical address of SL_PC(sp).
  */
 	
-grackle_wake_up:
-	/* Enable and then Flash inval the instruction cache */
+wake_up:
+	/* Flash inval the instruction cache */
 	mfspr	r3,HID0
-	ori	r3,r3, HID0_ICE|HID0_ICFI|HID0_DCE|HID0_DCI
-	sync
-	isync
-	mtspr	HID0,r3
-	xori	r3,r3, HID0_ICFI|HID0_DCI
+	ori	r3,r3, HID0_ICFI
 	mtspr	HID0,r3
-	sync
-	
-	/* Restore the remaining bits of the HID0 register. */
+	isync
+	/* Restore the HID0 register.  This turns on the L1 caches. */
 	subi	r1,r1,SL_PC
 	lwz	r3,SL_HID0(r1)
 	sync
@@ -283,13 +239,6 @@
 	lwz	r4,SL_IBAT3+4(r1)
 	mtibatl	3,r4
 
-	/* Flush all TLBs */
-	lis	r4, 0x1000
-1:	addic.	r4, r4, -0x1000
-	tlbie	r4
-	blt	1b
-	sync
-
 	/* restore the MSR and turn on the MMU */
 	lwz	r3,SL_MSR(r1)
 	bl	turn_on_mmu	
@@ -298,8 +247,6 @@
 	tovirt(r1,r1)
 
 	/* Restore TB */
-	lis r3,0
-	mttbl	r3
 	lwz	r3,SL_TB(r1)
 	lwz	r4,SL_TB+4(r1)
 	mttbu	r3
@@ -320,4 +267,3 @@
 	mtsrr1	r3
 	sync
 	rfi
-	sync
diff -urN linux.orig/arch/ppc/kernel/smp.c linux/arch/ppc/kernel/smp.c
--- linux.orig/arch/ppc/kernel/smp.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/smp.c	Thu Jul 11 16:28:25 2002
@@ -7,9 +7,7 @@
  * deal of code from the sparc and intel versions.
  *
  * Support for PReP (Motorola MTX/MVME) SMP by Troy Benjegerdes
- * (troy@blacklablinux.com, hozer@drgw.net)
- * Support for PReP (Motorola MTX/MVME) and Macintosh G4 SMP 
- * by Troy Benjegerdes (hozer@drgw.net)
+ * (troy@microux.com, hozer@drgw.net)
  */
 
 #include <linux/kernel.h>
@@ -38,8 +36,8 @@
 #include <asm/prom.h>
 #include <asm/gemini.h>
 #include <asm/residual.h>
-#include <asm/time.h>
-#include <asm/feature.h>
+
+#include "time.h"
 #include "open_pic.h"
 
 int first_cpu_booted = 0;
@@ -49,8 +47,7 @@
 struct cpuinfo_PPC cpu_data[NR_CPUS];
 struct klock_info_struct klock_info = { KLOCK_CLEAR, 0 };
 volatile unsigned char active_kernel_processor = NO_PROC_ID;	/* Processor holding kernel spinlock		*/
-atomic_t ipi_recv;
-atomic_t ipi_sent;
+volatile unsigned long ipi_count;
 spinlock_t kernel_flag = SPIN_LOCK_UNLOCKED;
 unsigned int prof_multiplier[NR_CPUS];
 unsigned int prof_counter[NR_CPUS];
@@ -68,9 +65,6 @@
 extern unsigned long *MotSave_SmpIar;
 extern unsigned char *MotSave_CpusState[2];
 
-/* l2 cache stuff for dual G4 macs */
-extern void core99_init_l2(void);
- 
 /* register for interrupting the secondary processor on the powersurge */
 #define PSURGE_INTR	((volatile unsigned *)0xf80000c0)
 
@@ -121,7 +115,7 @@
 
 void smp_message_recv(int msg)
 {
- 	atomic_inc(&ipi_recv);
+	ipi_count++;
 	
 	switch( msg )
 	{
@@ -143,7 +137,6 @@
 	}
 }
 
-#ifdef CONFIG_POWERMAC
 /*
  * As it is now, if we're sending two message at the same time
  * we have race conditions on Pmac.  The PowerSurge doesn't easily
@@ -155,10 +148,10 @@
  * rather than this.
  *  -- Cort
  */
-int psurge_smp_message[NR_CPUS];
-void psurge_smp_message_recv(void)
+int pmac_smp_message[NR_CPUS];
+void pmac_smp_message_recv(void)
 {
-	int msg = psurge_smp_message[smp_processor_id()];
+	int msg = pmac_smp_message[smp_processor_id()];
 
 	/* clear interrupt */
 	out_be32(PSURGE_INTR, ~0);
@@ -169,9 +162,9 @@
 	smp_message_recv(msg);
 
 	/* reset message */
-	psurge_smp_message[smp_processor_id()] = -1;
+	pmac_smp_message[smp_processor_id()] = -1;
 }
-#endif /* powermac */
+
 
 /*
  * 750's don't broadcast tlb invalidates so
@@ -203,65 +196,49 @@
 	smp_message_pass(MSG_ALL_BUT_SELF, MSG_STOP_CPU, 0, 0);
 }
 
-#ifdef CONFIG_POWERMAC
-static void psurge_message_pass(int target, int msg, unsigned long data, int wait)
+void smp_message_pass(int target, int msg, unsigned long data, int wait)
 {
 	int i;
 	
-	/*
-	 * IPI's on the Pmac are a hack but without reasonable
-	 * IPI hardware SMP on Pmac is a hack.
-	 *
-	 * We assume here that the msg is not -1.  If it is,
-	 * the recipient won't know the message was destined
-	 * for it. -- Cort
-	 */
-	for ( i = 0; i <= smp_num_cpus ; i++ )
-		psurge_smp_message[i] = -1;
-	switch( target )
-	{
-	case MSG_ALL:
-		psurge_smp_message[smp_processor_id()] = msg;
-		/* fall through */
-	case MSG_ALL_BUT_SELF:
-		for ( i = 0 ; i < smp_num_cpus ; i++ )
-			if ( i != smp_processor_id () )
-				psurge_smp_message[i] = msg;
-		break;
-	default:
-		psurge_smp_message[target] = msg;
-		break;
-	}
-	/* interrupt secondary processor */
-	out_be32(PSURGE_INTR, ~0);
-	out_be32(PSURGE_INTR, 0);
-	/*
-	 * Assume for now that the secondary doesn't send
-	 * IPI's -- Cort
-	 * Could be fixed with 2.4 code from Paulus -- BenH
-	 */
-	/* interrupt primary */
-	/**(volatile unsigned long *)(0xf3019000);*/
-}
-#endif /* powermac */
-
-void smp_message_pass(int target, int msg, unsigned long data, int wait)
-{
- 	atomic_inc(&ipi_sent);
-
 	if ( !(_machine & (_MACH_Pmac|_MACH_chrp|_MACH_prep|_MACH_gemini)) )
 		return;
 
 	switch (_machine) {
-#ifdef CONFIG_POWERMAC
 	case _MACH_Pmac:
-		/* Hack, 2.4 does it cleanly */
-		if (OpenPIC == NULL) {
-			psurge_message_pass(target, msg, data, wait);
+		/*
+		 * IPI's on the Pmac are a hack but without reasonable
+		 * IPI hardware SMP on Pmac is a hack.
+		 *
+		 * We assume here that the msg is not -1.  If it is,
+		 * the recipient won't know the message was destined
+		 * for it. -- Cort
+		 */
+		for ( i = 0; i <= smp_num_cpus ; i++ )
+			pmac_smp_message[i] = -1;
+		switch( target )
+		{
+		case MSG_ALL:
+			pmac_smp_message[smp_processor_id()] = msg;
+			/* fall through */
+		case MSG_ALL_BUT_SELF:
+			for ( i = 0 ; i < smp_num_cpus ; i++ )
+				if ( i != smp_processor_id () )
+					pmac_smp_message[i] = msg;
 			break;
-		} 
-		/* else fall through and do something sane --Troy */
-#endif
+		default:
+			pmac_smp_message[target] = msg;
+			break;
+		}
+		/* interrupt secondary processor */
+		out_be32(PSURGE_INTR, ~0);
+		out_be32(PSURGE_INTR, 0);
+		/*
+		 * Assume for now that the secondary doesn't send
+		 * IPI's -- Cort
+		 */
+		/* interrupt primary */
+		/**(volatile unsigned long *)(0xf3019000);*/
+		break;
 	case _MACH_chrp:
 	case _MACH_prep:
 	case _MACH_gemini:
@@ -285,52 +262,6 @@
 	}
 }
 
-#ifdef CONFIG_POWERMAC
-static void pmac_core99_kick_cpu(int nr)
-{
-	extern void __secondary_start_psurge(void);
-
-	unsigned long save_int;
-	unsigned long flags;
-	volatile unsigned long *vector
-		 = ((volatile unsigned long *)(KERNELBASE+0x500));
-
-	if (nr != 1)
-		return;
-
-	__save_flags(flags);
-	__cli();
-	
-	/* Save EE vector */
-	save_int = *vector;
-	
-	/* Setup fake EE vector that does	  
-	 *   b __secondary_start_psurge - KERNELBASE
-	 */   
-	*vector = 0x48000002 +
-		((unsigned long)__secondary_start_psurge - KERNELBASE);
-	
-	/* flush data cache and inval instruction cache */
-	flush_icache_range((unsigned long) vector, (unsigned long) vector + 4);
-
-	/* Put some life in our friend */
-	feature_core99_kick_cpu1();
-	
-	/* FIXME: We wait a bit for the CPU to take the exception, I should
-	 * instead wait for the entry code to set something for me. Well,
-	 * ideally, all that crap will be done in prom.c and the CPU left
-	 * in a RAM-based wait loop like CHRP.
-	 */
-	mdelay(1);
-	
-	/* Restore our exception vector */
-	*vector = save_int;
-	flush_icache_range((unsigned long) vector, (unsigned long) vector + 4);
-
-	__restore_flags(flags);
-}
-#endif /* powermac */
-
 void __init smp_boot_cpus(void)
 {
 	extern struct task_struct *current_set[NR_CPUS];
@@ -367,21 +298,15 @@
 
 	switch ( _machine )
 	{
-#ifdef CONFIG_POWERMAC
 	case _MACH_Pmac:
-		/* assum e powersurge board - 2 processors -- Cort */
-		/* or a dual G4 -- Troy */
+		/* assume powersurge board - 2 processors -- Cort */
 		cpu_nr = 2;
 		break;
-#endif
-#if defined(CONFIG_ALL_PPC) || defined(CONFIG_CHRP)
 	case _MACH_chrp:
 		cpu_nr = ((openpic_read(&OpenPIC->Global.Feature_Reporting0)
 				 & OPENPIC_FEATURE_LAST_PROCESSOR_MASK) >>
 				OPENPIC_FEATURE_LAST_PROCESSOR_SHIFT)+1;
 		break;
-#endif
-#if defined(CONFIG_ALL_PPC) || defined(CONFIG_PREP)
  	case _MACH_prep:
  		/* assume 2 for now == fix later -- Johnnie */
 		if ( mot_multi )
@@ -389,13 +314,10 @@
 			cpu_nr = 2;
 			break;
 		}
-#endif
-#ifdef CONFIG_GEMINI
 	case _MACH_gemini:
                 cpu_nr = (readb(GEMINI_CPUSTAT) & GEMINI_CPU_COUNT_MASK)>>2;
                 cpu_nr = (cpu_nr == 0) ? 4 : cpu_nr;
 		break;
-#endif
 	default:
 		printk("SMP not supported on this machine.\n");
 		return;
@@ -426,41 +348,30 @@
 		/* wake up cpus */
 		switch ( _machine )
 		{
-#ifdef CONFIG_POWERMAC
 		case _MACH_Pmac:
-			if (OpenPIC == NULL) {
-				/* setup entry point of secondary processor */
-				*(volatile unsigned long *)(0xf2800000) =
-					(unsigned long)__secondary_start_psurge-KERNELBASE;
-				eieio();
-				/* interrupt secondary to begin executing code */
-				out_be32(PSURGE_INTR, ~0);
-				out_be32(PSURGE_INTR, 0);
-			} else
-				pmac_core99_kick_cpu(i);
+			/* setup entry point of secondary processor */
+			*(volatile unsigned long *)(0xf2800000) =
+				(unsigned long)__secondary_start_psurge-KERNELBASE;
+			eieio();
+			/* interrupt secondary to begin executing code */
+			out_be32(PSURGE_INTR, ~0);
+			out_be32(PSURGE_INTR, 0);
 			break;
-#endif
-#if defined(CONFIG_ALL_PPC) || defined(CONFIG_CHRP)
 		case _MACH_chrp:
 			*(unsigned long *)KERNELBASE = i;
 			asm volatile("dcbf 0,%0"::"r"(KERNELBASE):"memory");
 			break;
-#endif
-#if defined(CONFIG_ALL_PPC) || defined(CONFIG_PREP)
 		case _MACH_prep:
 			*MotSave_SmpIar = (unsigned long)__secondary_start_psurge - KERNELBASE;
 			*MotSave_CpusState[1] = CPU_GOOD;
 			printk("CPU1 reset, waiting\n");
 			break;
-#endif
-#ifdef CONFIG_GEMINI
 		case _MACH_gemini:
 			openpic_init_processor( 1<<i );
 			openpic_init_processor( 0 );
 			break;
-#endif
 		}
-
+		
 		/*
 		 * wait to see if the cpu made a callin (is actually up).
 		 * use this value that I found through experimentation.
@@ -481,9 +392,9 @@
 		}
 	}
 	
-	if (OpenPIC)
+	if ( _machine & (_MACH_gemini|_MACH_chrp|_MACH_prep) )
 		do_openpic_setup_cpu();
-	else if ( _machine == _MACH_Pmac )
+	if ( _machine == _MACH_Pmac )
 	{
 		/* reset the entry point so if we get another intr we won't
 		 * try to startup again */
@@ -529,17 +440,10 @@
 	 * place to stick it for now.
 	 *  -- Cort
 	 */
-	if (OpenPIC) {
+	if ( _machine & (_MACH_gemini|_MACH_chrp|_MACH_prep) )
 		do_openpic_setup_cpu();
-#ifdef CONFIG_POWERMAC
- 		if ( _machine == _MACH_Pmac )
- 			core99_init_l2();
-#endif
- 	}
-#ifdef CONFIG_GEMINI
 	if ( _machine == _MACH_gemini )
 	        gemini_init_l2();
-#endif
 	while(!smp_commenced)
 		barrier();
 	__sti();
diff -urN linux.orig/arch/ppc/kernel/syscalls.c linux/arch/ppc/kernel/syscalls.c
--- linux.orig/arch/ppc/kernel/syscalls.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/syscalls.c	Thu Jul 11 15:43:29 2002
@@ -199,7 +199,6 @@
 	struct file * file = NULL;
 	int ret = -EBADF;
 
-	down(&current->mm->mmap_sem);
 	lock_kernel();
 	if (!(flags & MAP_ANONYMOUS)) {
 		if (fd >= NR_OPEN || !(file = current->files->fd[fd]))
@@ -210,7 +209,6 @@
 	ret = do_mmap(file, addr, len, prot, flags, offset);
 out:
 	unlock_kernel();
-	up(&current->mm->mmap_sem);
 	return ret;
 }
 
@@ -248,14 +246,9 @@
 
 asmlinkage int sys_uname(struct old_utsname * name)
 {
-	int err;
-	
-	if (!name)
-		return -EFAULT;
-	down(&uts_sem);
-	err = copy_to_user(name, &system_utsname, sizeof (*name));
-	up(&uts_sem);
-	return err ? -EFAULT : 0;
+	if (name && !copy_to_user(name, &system_utsname, sizeof (*name)))
+		return 0;
+	return -EFAULT;
 }
 
 asmlinkage int sys_olduname(struct oldold_utsname * name)
@@ -267,7 +260,6 @@
 	if (!access_ok(VERIFY_WRITE,name,sizeof(struct oldold_utsname)))
 		return -EFAULT;
   
-  	down(&uts_sem);
 	error = __copy_to_user(&name->sysname,&system_utsname.sysname,__OLD_UTS_LEN);
 	error -= __put_user(0,name->sysname+__OLD_UTS_LEN);
 	error -= __copy_to_user(&name->nodename,&system_utsname.nodename,__OLD_UTS_LEN);
@@ -279,18 +271,6 @@
 	error -= __copy_to_user(&name->machine,&system_utsname.machine,__OLD_UTS_LEN);
 	error = __put_user(0,name->machine+__OLD_UTS_LEN);
 	error = error ? -EFAULT : 0;
-	up(&uts_sem);
 
 	return error;
 }
-
-#ifndef CONFIG_PCI
-/*
- * Those are normally defined in arch/ppc/kernel/pci.c. But when CONFIG_PCI is
- * not defined, this file is not linked at all, so here are the "empty" versions
- */
-asmlinkage int sys_pciconfig_read() { return -ENOSYS; }
-asmlinkage int sys_pciconfig_write() { return -ENOSYS; }
-asmlinkage long sys_pciconfig_iobase() { return -ENOSYS; }
-#endif
-
diff -urN linux.orig/arch/ppc/kernel/time.c linux/arch/ppc/kernel/time.c
--- linux.orig/arch/ppc/kernel/time.c	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/kernel/time.c	Thu Jul 11 15:43:29 2002
@@ -46,7 +46,7 @@
 #endif
 #include <asm/machdep.h>
 
-#include <asm/time.h>
+#include "time.h"
 
 void smp_local_timer_interrupt(struct pt_regs *);
 
@@ -71,7 +71,7 @@
 {
 	int dval, d;
 	unsigned long cpu = smp_processor_id();
-
+	
 	hardirq_enter(cpu);
 #ifdef __SMP__
 	{
@@ -106,13 +106,6 @@
 		if ( !smp_processor_id() )
 		{
 			do_timer(regs);
-#if 0
-	/* -- BenH -- I'm removing this for now since it can cause various
-	 *            troubles with local-time RTCs. Now that we have a
-	 *            /dev/rtc that uses ppc_md.set_rtc_time() on mac, it
-	 *            should be possible to program the RTC from userland
-	 *            in all cases.
-	 */
 			/*
 			 * update the rtc when needed
 			 */
@@ -126,7 +119,6 @@
 					/* do it again in 60 s */
 					last_rtc_update = xtime.tv_sec;
 			}
-#endif			
 		}
 	}
 #ifdef __SMP__
@@ -192,10 +184,10 @@
 
 __initfunc(void time_init(void))
 {
-	long time_offset = 0;
-
         if (ppc_md.time_init != NULL)
-                time_offset = ppc_md.time_init();
+        {
+                ppc_md.time_init();
+        }
 
 	if ((_get_PVR() >> 16) == 1) {
 		/* 601 processor: dec counts down by 128 every 128ns */
@@ -208,12 +200,6 @@
 
         xtime.tv_sec = ppc_md.get_rtc_time();
         xtime.tv_usec = 0;
-        if (time_offset) {
-        	struct timezone tz;
-        	tz.tz_minuteswest = time_offset/60;
-        	tz.tz_dsttime = 0; /* Not handled correctly by the kernel anyway */
-        	do_sys_settimeofday(NULL, &tz);
-        }
 
 	set_dec(decrementer_count);
 	/* allow updates right away */
diff -urN linux.orig/arch/ppc/kernel/time.h linux/arch/ppc/kernel/time.h
--- linux.orig/arch/ppc/kernel/time.h	Thu Jan  1 01:00:00 1970
+++ linux/arch/ppc/kernel/time.h	Thu Jul 11 15:43:29 2002
@@ -0,0 +1,34 @@
+/*
+ * $Id$
+ * Common time prototypes and such for all ppc machines.
+ *
+ * Written by Cort Dougan (cort@cs.nmt.edu) to merge
+ * Paul Mackerras' version and mine for PReP and Pmac.
+ */
+
+#include <linux/mc146818rtc.h>
+
+/* time.c */
+extern unsigned decrementer_count;
+extern unsigned count_period_num;
+extern unsigned count_period_den;
+extern unsigned long mktime(unsigned int, unsigned int, unsigned int,
+			    unsigned int, unsigned int, unsigned int);
+extern void to_tm(int tim, struct rtc_time * tm);
+extern time_t last_rtc_update;
+
+int via_calibrate_decr(void);
+
+/* Accessor functions for the decrementer register. */
+static __inline__ unsigned int get_dec(void)
+{
+	unsigned int ret;
+
+	asm volatile("mfspr %0,22" : "=r" (ret) :);
+	return ret;
+}
+
+static __inline__ void set_dec(unsigned int val)
+{
+	asm volatile("mtspr 22,%0" : : "r" (val));
+}
diff -urN linux.orig/arch/ppc/kernel/traps.c linux/arch/ppc/kernel/traps.c
--- linux.orig/arch/ppc/kernel/traps.c	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/kernel/traps.c	Thu Jul 11 15:43:29 2002
@@ -100,27 +100,26 @@
 			return;
 		}
 #endif
-		printk("Machine check in kernel mode.  (regs at %p)\n", regs);
-		printk("Caused by (from srr1): ");
-		switch( regs->msr & 0x001F0000) {
-		case 0x100000:
-			printk("L2 data cache parity error\n");
+		printk("Machine check in kernel mode.\n");
+		printk("Caused by (from msr): ");
+		printk("regs %p ",regs);
+		switch( regs->msr & 0x0000F000)
+		{
+		case (1<<12) :
+			printk("Machine check signal - probably due to mm fault\n"
+				"with mmu off\n");
 			break;
-		case 0x80000:
-			printk("Machine check signal\n");
-			printk("(probably due to access of bad physical address\n");
-			break;
-		case 0x40000:
+		case (1<<13) :
 			printk("Transfer error ack signal\n");
 			break;
-		case 0x20000:
+		case (1<<14) :
 			printk("Data parity signal\n");
 			break;
-		case 0x10000:
+		case (1<<15) :
 			printk("Address parity signal\n");
 			break;
 		default:
-			printk("Unknown values in srr1\n");
+			printk("Unknown values in msr\n");
 		}
 		show_regs(regs);
 #if defined(CONFIG_XMON) || defined(CONFIG_KGDB)
@@ -156,52 +155,9 @@
 	_exception(SIGTRAP, regs);	
 }
 
-/* Illegal instruction emulation support.  Originally written to
- * provide the PVR to user applications using the mfspr rd, PVR.
- * Return non-zero if we can't emulate, or EFAULT if the associated
- * memory access caused an access fault.  Return zero on success.
- *
- * There are a couple of ways to do this, either "decode" the instruction
- * or directly match lots of bits.  In this case, matching lots of
- * bits is faster and easier.
- *
- */
-#define INST_MFSPR_PVR		0x7c1f42a6
-#define INST_MFSPR_PVR_MASK	0xfc1fffff
-
-static int
-emulate_instruction(struct pt_regs *regs)
-{
-	uint    instword;
-	uint    rd;
-	int    retval;
-
-	retval = EINVAL;
-	if (!user_mode(regs))
-		return retval;
-
-	retval = EFAULT;
-	if (get_user(instword, (uint *)(regs->nip)))
-		return retval;
-
-	/* Emulate the mfspr rD, PVR.
-	 */
-	retval = EINVAL;
-	if ((instword & INST_MFSPR_PVR_MASK) == INST_MFSPR_PVR) {
-		rd = (instword >> 21) & 0x1f;
-		regs->gpr[rd] = _get_PVR();
-		retval = 0;
-	}
-	if (retval == 0)
-		regs->nip += 4;
-	return(retval);
-}
-
 void
 ProgramCheckException(struct pt_regs *regs)
 {
-	int errcode;
-
 	if (regs->msr & 0x100000) {
 		/* IEEE FP exception */
 		_exception(SIGFPE, regs);
@@ -213,13 +169,7 @@
 #endif
 		_exception(SIGTRAP, regs);
 	} else {
-		/* Try to emulate it if we should. */
-		if ((errcode = emulate_instruction(regs))) {
-			if (errcode == EFAULT)
-				_exception(SIGBUS, regs);
-			else
-				_exception(SIGILL, regs);
-		}
+		_exception(SIGILL, regs);
 	}
 }
 
diff -urN linux.orig/arch/ppc/lib/string.S linux/arch/ppc/lib/string.S
--- linux.orig/arch/ppc/lib/string.S	Sun Mar 25 18:31:49 2001
+++ linux/arch/ppc/lib/string.S	Thu Jul 11 15:43:29 2002
@@ -12,11 +12,6 @@
 #include <asm/processor.h>
 #include <asm/errno.h>
 
-CACHELINE_BYTES = 32
-LG_CACHELINE_BYTES = 5
-CACHELINE_MASK = 0x1f
-CACHELINE_WORDS = 8
-
 	.globl	strcpy
 strcpy:
 	addi	r5,r3,-1
@@ -87,35 +82,7 @@
 	andi.	r0,r6,3
 	add	r5,r0,r5
 	subf	r6,r0,r6
-#if 0	/* Clever, but breaks fb stuff -- paulus */
-/*
- * Use dcbz on the complete cache lines in the destination if
- * we are setting to zero.  This requires that the destination
- * area is cacheable.  -- paulus
- */
-	cmpwi	0,r4,0
-	bne	2f
-	clrlwi	r7,r6,32-LG_CACHELINE_BYTES
-	add	r8,r7,r5
-	srwi	r9,r8,LG_CACHELINE_BYTES
-	addic.	r9,r9,-1	/* total number of complete cachelines */
-	ble	2f
-	xori	r0,r7,CACHELINE_MASK & ~3
-	srwi.	r0,r0,2
-	beq	3f
-	mtctr	r0
-4:	stwu	r4,4(r6)
-	bdnz	4b
-3:	mtctr	r9
-	li	r7,4
-10:	dcbz	r7,r6
-	addi	r6,r6,CACHELINE_BYTES
-	bdnz	10b
-	clrlwi	r5,r8,32-LG_CACHELINE_BYTES
-	addi	r5,r5,4
-2:
-#endif
-	srwi	r0,r5,2
+	rlwinm	r0,r5,32-2,2,31
 	mtctr	r0
 	bdz	6f
 1:	stwu	r4,4(r6)
@@ -140,94 +107,11 @@
 memmove:
 	cmplw	0,r3,r4
 	bgt	backwards_memcpy
-	b	forwards_memcpy
+	/* fall through */
 
 	.globl	memcpy
 memcpy:
-#if 0	/* Clever, but will probably break fb stuff -- paulus */
-/*
- * This version uses dcbz on the complete cache lines in the
- * destination area to reduce memory traffic.  This requires that
- * the destination area is cacheable.
- * We only use this version if the source and dest don't overlap.
- * -- paulus.
- */
-	add	r7,r3,r5		/* test if the src & dst overlap */
-	add	r8,r4,r5
-	cmplw	0,r4,r7
-	cmplw	1,r3,r8
-	crand	0,0,4			/* cr0.lt &= cr1.lt */
-	blt	forwards_memcpy		/* if regions overlap */
-
-	addi	r4,r4,-4
-	addi	r6,r3,-4
-	neg	r0,r3
-	andi.	r0,r0,CACHELINE_MASK	/* # bytes to start of cache line */
-	beq	58f
-
-	cmplw	0,r5,r0			/* is this more than total to do? */
-	blt	63f			/* if not much to do */
-	andi.	r8,r0,3			/* get it word-aligned first */
-	subf	r5,r0,r5
-	mtctr	r8
-	beq+	61f
-70:	lbz	r9,4(r4)		/* do some bytes */
-	stb	r9,4(r6)
-	addi	r4,r4,1
-	addi	r6,r6,1
-	bdnz	70b
-61:	srwi.	r0,r0,2
-	mtctr	r0
-	beq	58f
-72:	lwzu	r9,4(r4)		/* do some words */
-	stwu	r9,4(r6)
-	bdnz	72b
-
-58:	srwi.	r0,r5,LG_CACHELINE_BYTES /* # complete cachelines */
-	clrlwi	r5,r5,32-LG_CACHELINE_BYTES
-	li	r11,4
-	mtctr	r0
-	beq	63f
-53:	dcbz	r11,r6
-	lwz	r7,4(r4)
-	lwz	r8,8(r4)
-	lwz	r9,12(r4)
-	lwzu	r10,16(r4)
-	stw	r7,4(r6)
-	stw	r8,8(r6)
-	stw	r9,12(r6)
-	stwu	r10,16(r6)
-	lwz	r7,4(r4)
-	lwz	r8,8(r4)
-	lwz	r9,12(r4)
-	lwzu	r10,16(r4)
-	stw	r7,4(r6)
-	stw	r8,8(r6)
-	stw	r9,12(r6)
-	stwu	r10,16(r6)
-	bdnz	53b
-
-63:	srwi.	r0,r5,2
-	mtctr	r0
-	beq	64f
-30:	lwzu	r0,4(r4)
-	stwu	r0,4(r6)
-	bdnz	30b
-
-64:	andi.	r0,r5,3
-	mtctr	r0
-	beq+	65f
-40:	lbz	r0,4(r4)
-	stb	r0,4(r6)
-	addi	r4,r4,1
-	addi	r6,r6,1
-	bdnz	40b
-65:	blr
-#endif
-
-	.global	forwards_memcpy
-forwards_memcpy:
-	srwi.	r7,r5,3
+	rlwinm.	r7,r5,32-3,3,31		/* r0 = r5 >> 3 */
 	addi	r6,r3,-4
 	addi	r4,r4,-4
 	beq	2f			/* if less than 8 bytes to do */
@@ -334,167 +218,106 @@
 
 	.globl	__copy_tofrom_user
 __copy_tofrom_user:
-	addi	r4,r4,-4
+	srwi.	r7,r5,3
 	addi	r6,r3,-4
-	neg	r0,r3
-	andi.	r0,r0,CACHELINE_MASK	/* # bytes to start of cache line */
-	beq	58f
-
-	cmplw	0,r5,r0			/* is this more than total to do? */
-	blt	63f			/* if not much to do */
-	andi.	r8,r0,3			/* get it word-aligned first */
-	mtctr	r8
-	beq+	61f
-70:	lbz	r9,4(r4)		/* do some bytes */
-71:	stb	r9,4(r6)
-	addi	r4,r4,1
-	addi	r6,r6,1
-	bdnz	70b
-61:	subf	r5,r0,r5
-	srwi.	r0,r0,2
-	mtctr	r0
-	beq	58f
-72:	lwzu	r9,4(r4)		/* do some words */
-73:	stwu	r9,4(r6)
-	bdnz	72b
-
-58:	srwi.	r0,r5,LG_CACHELINE_BYTES /* # complete cachelines */
-	clrlwi	r5,r5,32-LG_CACHELINE_BYTES
-	li	r11,4
-	mtctr	r0
-	beq	63f
-53:	dcbz	r11,r6
-10:	lwz	r7,4(r4)
-11:	lwz	r8,8(r4)
-12:	lwz	r9,12(r4)
-13:	lwzu	r10,16(r4)
-14:	stw	r7,4(r6)
-15:	stw	r8,8(r6)
-16:	stw	r9,12(r6)
-17:	stwu	r10,16(r6)
-20:	lwz	r7,4(r4)
-21:	lwz	r8,8(r4)
-22:	lwz	r9,12(r4)
-23:	lwzu	r10,16(r4)
-24:	stw	r7,4(r6)
-25:	stw	r8,8(r6)
-26:	stw	r9,12(r6)
-27:	stwu	r10,16(r6)
-	bdnz	53b
-
-63:	srwi.	r0,r5,2
-	mtctr	r0
-	beq	64f
-30:	lwzu	r0,4(r4)
-31:	stwu	r0,4(r6)
-	bdnz	30b
-
-64:	andi.	r0,r5,3
-	mtctr	r0
-	beq+	65f
-40:	lbz	r0,4(r4)
-41:	stb	r0,4(r6)
+	addi	r4,r4,-4
+	li	r3,0		/* success return value */
+	beq	2f		/* if less than 8 bytes to do */
+	andi.	r0,r6,3		/* get dest word aligned */
+	mtctr	r7
+	bne	5f
+1:	lwz	r7,4(r4)
+11:	lwzu	r8,8(r4)
+12:	stw	r7,4(r6)
+13:	stwu	r8,8(r6)
+	bdnz	1b
+	andi.	r5,r5,7
+2:	cmplwi	0,r5,4
+	blt	3f
+14:	lwzu	r0,4(r4)
+	addi	r5,r5,-4
+15:	stwu	r0,4(r6)
+3:	cmpwi	0,r5,0		/* do 1 byte at a time for the remainder */
+	beqlr
+	mtctr	r5
+	addi	r4,r4,3
+	addi	r6,r6,3
+4:	lbzu	r0,1(r4)
+16:	stbu	r0,1(r6)
+	bdnz	4b
+	blr
+5:	subfic	r0,r0,4		/* copy bytes until we have the */
+	mtctr	r0		/* destination 4-byte aligned */
+	subf	r5,r0,r5
+6:	lbz	r7,4(r4)
 	addi	r4,r4,1
+17:	stb	r7,4(r6)
 	addi	r6,r6,1
-	bdnz	40b
-65:	li	r3,0
-	blr
-
-/* read fault, initial single-byte copy */
-100:	li	r4,0
-	b	90f
-/* write fault, initial single-byte copy */
-101:	li	r4,1
-90:	subf	r5,r8,r5
-	li	r3,0
-	b	99f
-/* read fault, initial word copy */
-102:	li	r4,0
-	b	91f
-/* write fault, initial word copy */
-103:	li	r4,1
-91:	li	r3,2
-	b	99f
-/* read fault in 2nd half of cacheline loop */
-106:	addi	r5,r5,-16
-/* read fault in 1st half of cacheline loop */
-104:	li	r4,0
-	b	92f
-/* write fault in 2nd half of cacheline loop */
-107:	addi	r5,r5,-16
-/* fault on dcbz (effectively a write fault) */
-/* or write fault in 1st half of cacheline loop */
-105:	li	r4,1
-92:	li	r3,LG_CACHELINE_BYTES
-	b	99f
-/* read fault in final word loop */
-108:	li	r4,0
-	b	93f
-/* write fault in final word loop */
-109:	li	r4,1
-93:	andi.	r5,r5,3
-	li	r3,2
-	b	99f
-/* read fault in final byte loop */
-110:	li	r4,0
-	b	94f
-/* write fault in final byte loop */
-111:	li	r4,1
-94:	li	r5,0
-	li	r3,0
-/*
- * At this stage the number of bytes not copied is
- * r5 + (ctr << r3), and r4 is 0 for read or 1 for write.
- */
-99:	mfctr	r0
-	slw	r3,r0,r3
+	bdnz	6b
+	srwi.	r7,r5,3
+	beq	2b
+	mtctr	r7
+	b	1b
+/* we come here on a fault in the 8-byte-at-a-time loop */
+88:	subi	r4,r4,8		/* compensate for the lwzu */
+98:	mfctr	r0
+	rlwimi	r5,r0,3,0,28	/* use the byte-at-a-time loop to */
+	b	3b		/* copy up to the byte at fault */
+/* here on a write fault in the single-word copy */
+96:	subi	r4,r4,4
+	b	3b
+/* here on a read fault in the initial single-byte copy */
+90:	mfctr	r3
 	add	r3,r3,r5
-	cmpwi	0,r4,0
-	bne	120f
-/* for read fault, clear out the destination: r3 bytes starting at 4(r6) */
-	srwi.	r0,r3,2
-	li	r9,0
-	mtctr	r0
-	beq	113f
-112:	stwu	r9,4(r6)
-	bdnz	112b
-113:	andi.	r0,r3,3
-	mtctr	r0
-	beq	120f
-114:	stb	r9,4(r6)
+	b	70f
+/* here on a read fault in the final single-byte copy */
+99:	mfctr	r3
+	subi	r6,r6,3
+/* clear out the rest of the destination: r3 bytes starting at 4(r6) */
+70:	li	r0,0
+	mr.	r5,r3
+	beq	76f
+71:	andi.	r4,r6,3
+	beq	72f
+77:	stb	r0,4(r6)
 	addi	r6,r6,1
-	bdnz	114b
-120:	blr
+	addic.	r5,r5,-1
+	bne	71b
+72:	srwi.	r7,r5,2
+	beq	73f
+	mtctr	r7
+74:	stwu	r0,4(r6)
+	bdnz	74b
+73:	andi.	r5,r5,3
+	beq	76f
+	mtctr	r5
+	addi	r6,r6,3
+75:	stbu	r0,1(r6)
+	bdnz	75b
+76:	blr
+/* here on a write fault in the initial single-byte copy */
+80:	mfctr	r3
+	add	r3,r3,r5
+	blr
+/* here on a write fault in the final single-byte copy */
+81:	mfctr	r3
+	blr
 
 .section __ex_table,"a"
 	.align	2
-	.long	70b,100b
-	.long	71b,101b
-	.long	72b,102b
-	.long	73b,103b
-	.long	53b,105b
-	.long	10b,104b
-	.long	11b,104b
-	.long	12b,104b
-	.long	13b,104b
-	.long	14b,105b
-	.long	15b,105b
-	.long	16b,105b
-	.long	17b,105b
-	.long	20b,106b
-	.long	21b,106b
-	.long	22b,106b
-	.long	23b,106b
-	.long	24b,107b
-	.long	25b,107b
-	.long	26b,107b
-	.long	27b,107b
-	.long	30b,108b
-	.long	31b,109b
-	.long	40b,110b
-	.long	41b,111b
-	.long	112b,120b
-	.long	114b,120b
+	.long	1b,98b
+	.long	11b,98b
+	.long	12b,88b
+	.long	13b,88b
+	.long	14b,3b
+	.long	15b,96b
+	.long	4b,99b
+	.long	16b,81b
+	.long	6b,90b
+	.long	17b,80b
+	.long	77b,76b
+	.long	74b,76b
+	.long	75b,76b
 .text
 
 	.globl	__clear_user
@@ -511,6 +334,7 @@
 	andi.	r0,r6,3
 	add	r4,r0,r4
 	subf	r6,r0,r6
+	/*rlwinm	r0,r4,32-2,2,31*/
 	srwi	r0,r4,2
 	mtctr	r0
 	bdz	6f
diff -urN linux.orig/arch/ppc/mm/extable.c linux/arch/ppc/mm/extable.c
--- linux.orig/arch/ppc/mm/extable.c	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/mm/extable.c	Thu Jul 11 15:43:29 2002
@@ -7,43 +7,8 @@
 #include <linux/module.h>
 #include <asm/uaccess.h>
 
-extern struct exception_table_entry __start___ex_table[];
-extern struct exception_table_entry __stop___ex_table[];
-
-/*
- * The exception table needs to be sorted because we use the macros
- * which put things into the exception table in a variety of segments
- * such as the prep, pmac, chrp, etc. segments as well as the init
- * segment and the main kernel text segment.
- */
-static inline void
-sort_ex_table(struct exception_table_entry *start,
-	      struct exception_table_entry *finish)
-{
-	struct exception_table_entry el, *p, *q;
-
-	/* insertion sort */
-	for (p = start + 1; p < finish; ++p) {
-		/* start .. p-1 is sorted */
-		if (p[0].insn < p[-1].insn) {
-			/* move element p down to its right place */
-			el = *p;
-			q = p;
-			do {
-				/* el comes before q[-1], move q[-1] up one */
-				q[0] = q[-1];
-				--q;
-			} while (q > start && el.insn < q[-1].insn);
-			*q = el;
-		}
-	}
-}
-
-void
-sort_exception_table(void)
-{
-	sort_ex_table(__start___ex_table, __stop___ex_table);
-}
+extern const struct exception_table_entry __start___ex_table[];
+extern const struct exception_table_entry __stop___ex_table[];
 
 static inline unsigned long
 search_one_table(const struct exception_table_entry *first,
@@ -71,7 +36,7 @@
 {
 	unsigned long ret;
 
-#ifndef CONFIG_MODULES
+#if 1 /*ndef CONFIG_MODULES*/
 	/* There is only the kernel to search.  */
 	ret = search_one_table(__start___ex_table, __stop___ex_table-1, addr);
 	if (ret) return ret;
diff -urN linux.orig/arch/ppc/mm/fault.c linux/arch/ppc/mm/fault.c
--- linux.orig/arch/ppc/mm/fault.c	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/mm/fault.c	Thu Jul 11 15:43:29 2002
@@ -71,10 +71,7 @@
 	       (error_code&0x80000000)?"I/O ":"",
 	       (regs->trap == 0x400)?"instr":"data"
 	       );*/
-
-	if (regs->trap == 0x400)
-		error_code &= 0x48200000;
-
+	       
 #if defined(CONFIG_XMON) || defined(CONFIG_KGDB)
 	if (debugger_fault_handler && regs->trap == 0x300) {
 		debugger_fault_handler(regs);
diff -urN linux.orig/arch/ppc/mm/init.c linux/arch/ppc/mm/init.c
--- linux.orig/arch/ppc/mm/init.c	Sun Mar 25 18:31:48 2001
+++ linux/arch/ppc/mm/init.c	Thu Jul 11 15:43:30 2002
@@ -416,12 +416,7 @@
 
 void iounmap(void *addr)
 {
-	/* For support of dynamic hot swap on the cPCI bus this routine
-	   is now necessary.  This has been well tested on a Motorola
-	   MPC750 (Mesquite) processor board.  Johnnie Peters
-	*/
-	if (addr > high_memory && (unsigned long) addr < ioremap_bot)
-		return vfree((void *) (PAGE_MASK & (unsigned long) addr));
+	/* XXX todo */
 }
 
 unsigned long iopa(unsigned long addr)
@@ -933,21 +928,15 @@
 				/* On the powerpc, no user access
 				   forces R/W kernel access */
 				f |= _PAGE_USER;
-			map_page(v, p, f);
-			v += PAGE_SIZE;
-			p += PAGE_SIZE;
-		}
-	}
-
 #else	/* CONFIG_8xx */
-	for (i = 0; i < phys_mem.n_regions; ++i) {
-		v = (ulong)__va(phys_mem.regions[i].address);
-		p = phys_mem.regions[i].address;
-		for (s = 0; s < phys_mem.regions[i].size; s += PAGE_SIZE) {
+            for (i = 0; i < phys_mem.n_regions; ++i) {
+                    v = (ulong)__va(phys_mem.regions[i].address);
+                    p = phys_mem.regions[i].address;
+                    for (s = 0; s < phys_mem.regions[i].size; s += PAGE_SIZE) {
                         /* On the MPC8xx, we want the page shared so we
                          * don't get ASID compares on kernel space.
                          */
-			f = _PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_SHARED;
+                            f = _PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_SHARED;
 
                         /* I don't really need the rest of this code, but
                          * I grabbed it because I think the line:
@@ -957,14 +946,14 @@
                          * the MPC8xx, the PAGE_DIRTY takes care of that
                          * for us (along with the RW software state).
                          */
-			if ((char *) v < _stext || (char *) v >= etext)
-				f |= _PAGE_RW | _PAGE_DIRTY | _PAGE_HWWRITE;
+                            if ((char *) v < _stext || (char *) v >= etext)
+                                    f |= _PAGE_RW | _PAGE_DIRTY | _PAGE_HWWRITE;
+#endif /* CONFIG_8xx */
 			map_page(v, p, f);
 			v += PAGE_SIZE;
 			p += PAGE_SIZE;
 		}
-	}
-#endif /* CONFIG_8xx */
+	}	    
 }
 
 /* This can get called from ioremap, so don't make it an initfunc, OK? */
@@ -1044,9 +1033,6 @@
  * still be merged.
  * -- Cort
  */
-#ifdef CONFIG_BOOTX_TEXT
-extern boot_infos_t *disp_bi;
-#endif
 __initfunc(void MMU_init(void))
 {
 #ifdef __SMP__
@@ -1066,6 +1052,7 @@
 #endif /* CONFIG_GEMINI	*/
 	else /* prep */
 		end_of_DRAM = prep_find_end_of_memory();
+*(unsigned long *)(KERNELBASE) = 0xdeadbeef;	
         hash_init();
         _SDR1 = __pa(Hash) | (Hash_mask >> 10);
 	ioremap_base = 0xf8000000;
@@ -1095,13 +1082,7 @@
 			struct device_node *macio = find_devices("mac-io");
 			if (macio && macio->n_addrs)
 				base = macio->addrs[0].address;
-			/* Hrm... we have it at 0x80000000 on some machines
-			 * and this is covered by the userland segment
-			 * registers. Isn't that bad ? Well, the BAT takes
-			 * precedence, but I don't like it. --BenH
-			 */
-			if (base >= 0xf0000000)
-				setbat(0, base, base, 0x100000, IO_PAGE);
+			setbat(0, base, base, 0x100000, IO_PAGE);
 			ioremap_base = 0xf0000000;
 		}
 		break;
@@ -1140,10 +1121,6 @@
         ioremap(0x80000000, 0x4000);
         ioremap(0x81000000, 0x4000);
 #endif /* CONFIG_8xx */
-#ifdef CONFIG_BOOTX_TEXT
-	if (_machine == _MACH_Pmac)
-		map_bootx_text();
-#endif
 }
 
 /*
@@ -1275,8 +1252,8 @@
 #endif /* CONFIG_BLK_DEV_INITRD */
 #ifndef CONFIG_8xx		  
 			if ( !rtas_data ||
-			     addr < (rtas_data + KERNELBASE) ||
-			     addr >= (rtas_data + KERNELBASE + rtas_size))
+			     addr < (rtas_data & PAGE_MASK) ||
+			     addr >= (rtas_data+rtas_size))
 #endif /* CONFIG_8xx */
 				free_page(addr);
 	}
@@ -1337,7 +1314,6 @@
 	return ret;
 }
 #endif /* CONFIG_MBX */
-
 #ifndef CONFIG_8xx
 /*
  * On systems with Open Firmware, collect information about
@@ -1404,7 +1380,6 @@
 	if (boot_infos == 0) {
 		/* record which bits the prom is using */
 		get_mem_prop("available", &phys_avail);
-		remove_mem_piece(&phys_avail, __max_memory, ~__max_memory, 0);
 		prom_mem = phys_mem;
 		for (i = 0; i < phys_avail.n_regions; ++i)
 			remove_mem_piece(&prom_mem,
diff -urN linux.orig/arch/ppc/pmac_defconfig linux/arch/ppc/pmac_defconfig
--- linux.orig/arch/ppc/pmac_defconfig	Sun Mar 25 18:31:50 2001
+++ linux/arch/ppc/pmac_defconfig	Thu Jul 11 15:43:30 2002
@@ -253,7 +253,6 @@
 CONFIG_NET_ETHERNET=y
 CONFIG_MACE=y
 CONFIG_BMAC=y
-CONFIG_GMAC=y
 # CONFIG_NET_VENDOR_3COM is not set
 # CONFIG_LANCE is not set
 # CONFIG_NET_VENDOR_SMC is not set
@@ -340,7 +339,6 @@
 CONFIG_FB_PLATINUM=y
 CONFIG_FB_VALKYRIE=y
 CONFIG_FB_ATY=y
-CONFIG_FB_ATY128=y
 CONFIG_FB_IMSTT=y
 CONFIG_FB_CT65550=y
 # CONFIG_FB_S3TRIO is not set
diff -urN linux.orig/arch/ppc/xmon/start.c linux/arch/ppc/xmon/start.c
--- linux.orig/arch/ppc/xmon/start.c	Sun Mar 25 18:31:50 2001
+++ linux/arch/ppc/xmon/start.c	Thu Jul 11 15:43:30 2002
@@ -11,30 +11,16 @@
 #include <asm/prom.h>
 #include <asm/bootx.h>
 #include <asm/pmu.h>
-#include <asm/feature.h>
 
 static volatile unsigned char *sccc, *sccd;
 unsigned long TXRDY, RXRDY;
 extern void xmon_printf(const char *fmt, ...);
+extern void map_bootx_text(void);
 extern void drawchar(char);
 extern void drawstring(const char *str);
-static int xmon_expect(const char *str, unsigned int timeout);
 
 static int console = 0;
 static int use_screen = 0;
-static int via_modem = 0;
-static int xmon_use_sccb = 0;
-static struct device_node *macio_node;
-
-#define TB_SPEED	25000000
-
-static inline unsigned int readtb(void)
-{
-	unsigned int ret;
-
-	asm volatile("mftb %0" : "=r" (ret) :);
-	return ret;
-}
 
 void buf_access(void)
 {
@@ -50,18 +36,17 @@
 	if ( _machine == _MACH_Pmac )
 	{
 		struct device_node *np;
+		extern boot_infos_t *boot_infos;
 		unsigned long addr;
-#ifdef CONFIG_BOOTX_TEXT
-		extern boot_infos_t *disp_bi;
 
-		/* needs to be hacked if xmon_printk is to be used
- 		   from within find_via_pmu() */
-		if (!via_modem && disp_bi && find_via_pmu()) {
+#ifdef CONFIG_BOOTX_TEXT
+		if (boot_infos != 0 && find_via_pmu()) {
 			printk(KERN_INFO "xmon uses screen and keyboard\n");
 			use_screen = 1;
+			map_bootx_text();
+			return;
 		}
 #endif
-
 #ifdef CHRP_ESCC
 		addr = 0xc1013020;
 #else
@@ -72,13 +57,18 @@
 		
 		np = find_devices("mac-io");
 		if (np && np->n_addrs) {
-			macio_node = np;
-			addr = np->addrs[0].address + 0x13020;
+			addr = np->addrs[0].address + 0x13000;
+			/* use the B channel on the iMac, A channel on others */
+			if (addr >= 0xf0000000)
+				addr += 0x20; /* use A channel */
 		}
-		base = (volatile unsigned char *)
-			ioremap(addr & PAGE_MASK, PAGE_SIZE);
+		base = (volatile unsigned char *) ioremap(addr & PAGE_MASK, PAGE_SIZE);
 		sccc = base + (addr & ~PAGE_MASK);
-		sccd = sccc + 0x10;
+#ifdef CHRP_ESCC
+		sccd = sccc + (0xc1013030 - 0xc1013020);
+#else
+		sccd = sccc + (0xf3013030 - 0xf3013020);
+#endif
 	}
 	else
 	{
@@ -99,7 +89,7 @@
 xmon_write(void *handle, void *ptr, int nb)
 {
     char *p = ptr;
-    int i, c, ct;
+    int i, ct;
 
 #ifdef CONFIG_BOOTX_TEXT
     if (use_screen) {
@@ -111,23 +101,19 @@
 #endif
     if (!scc_initialized)
 	xmon_init_scc();
-    ct = 0;
     for (i = 0; i < nb; ++i) {
 	while ((*sccc & TXRDY) == 0)
 	    if (adb_hardware == ADB_VIAPMU)
 		pmu_poll();
-	c = p[i];
-	if (c == '\n' && !ct) {
-	    c = '\r';
-	    ct = 1;
-	    --i;
-	} else {
-	    if (console)
-		printk("%c", c);
-	    ct = 0;
-	}
 	buf_access();
-	*sccd = c;
+	if ( console && (*p != '\r'))
+		printk("%c", *p);
+	ct = 0;
+	if ( *p == '\n')
+		ct = 1;
+	*sccd = *p++;
+	if ( ct )
+		xmon_write(handle, "\r", 1);
     }
     return i;
 }
@@ -213,30 +199,23 @@
 	    if (adb_hardware == ADB_VIAPMU)
 		pmu_poll();
 	buf_access();
-	*p++ = *sccd;
+#if 0	
+	if ( 0/*console*/ )
+		*p++ = ppc_md.kbd_getkeycode();
+	else
+#endif		
+		*p++ = *sccd;
     }
     return i;
 }
 
-int
-xmon_read_poll(void)
-{
-	if ((*sccc & RXRDY) == 0) {
-		if (adb_hardware == ADB_VIAPMU)
-			pmu_poll();
-		return -1;
-	}
-	buf_access();
-	return *sccd;
-}
-
 static unsigned char scc_inittab[] = {
     13, 0,		/* set baud rate divisor */
     12, 1,
     14, 1,		/* baud rate gen enable, src=rtxc */
     11, 0x50,		/* clocks = br gen */
-    5,  0xea,		/* tx 8 bits, assert DTR & RTS */
-    4,  0x46,		/* x16 clock, 1 stop */
+    5,  0x6a,		/* tx 8 bits, assert RTS */
+    4,  0x44,		/* x16 clock, 1 stop */
     3,  0xc1,		/* rx enable, 8 bits */
 };
 
@@ -256,21 +235,6 @@
 	{
 		int i, x;
 
-		if (macio_node != 0) {
-			unsigned int t0;
-
-			feature_set(macio_node, FEATURE_Serial_enable);
-			if (via_modem) {
-				feature_set(macio_node, FEATURE_Modem_power);
-				t0 = readtb();
-				while (readtb() - t0 < 3*TB_SPEED)
-					eieio();
-			}
-		}
-		if (xmon_use_sccb) {
-			sccc -= 0x20;
-			sccd -= 0x20;
-		}
 		for (i = 20000; i != 0; --i) {
 			x = *sccc; eieio();
 		}
@@ -282,18 +246,6 @@
 		}
 	}
 	scc_initialized = 1;
-	if (via_modem) {
-		for (;;) {
-			xmon_write(0, "ATE1V1\r", 7);
-			if (xmon_expect("OK", 5)) {
-				xmon_write(0, "ATA\r", 4);
-				if (xmon_expect("CONNECT", 40))
-					break;
-			}
-			xmon_write(0, "+++", 3);
-			xmon_expect("OK", 3);
-		}
-	}
 }
 
 #if 0
@@ -366,35 +318,6 @@
 static char *lineptr;
 static int lineleft;
 
-int xmon_expect(const char *str, unsigned int timeout)
-{
-	int c;
-	unsigned int t0;
-
-	timeout *= TB_SPEED;
-	t0 = readtb();
-	do {
-		lineptr = line;
-		for (;;) {
-			c = xmon_read_poll();
-			if (c == -1) {
-				if (readtb() - t0 > timeout) {
-					printk("timeout\n");
-					return 0;
-				}
-				continue;
-			}
-			if (c == '\n')
-				break;
-			printk("%c", c);
-			if (c != '\r' && lineptr < &line[sizeof(line) - 1])
-				*lineptr++ = c;
-		}
-		*lineptr = 0;
-	} while (strstr(line, str) == NULL);
-	return 1;
-}
-
 int
 xmon_getchar(void)
 {
@@ -467,15 +390,3 @@
     *p = 0;
     return str;
 }
-
-void
-xmon_enter(void)
-{
-	pmu_suspend();
-}
-
-void
-xmon_leave(void)
-{
-	pmu_resume();
-}
diff -urN linux.orig/arch/ppc/xmon/xmon.c linux/arch/ppc/xmon/xmon.c
--- linux.orig/arch/ppc/xmon/xmon.c	Sun Mar 25 18:31:50 2001
+++ linux/arch/ppc/xmon/xmon.c	Thu Jul 11 15:43:30 2002
@@ -86,9 +86,6 @@
 extern int setjmp(u_int *);
 extern void longjmp(u_int *, int);
 
-extern void xmon_enter(void);
-extern void xmon_leave(void);
-
 #define GETWORD(v)	(((v)[0] << 24) + ((v)[1] << 16) + ((v)[2] << 8) + (v)[3])
 
 static char *help_string = "\
@@ -142,7 +139,6 @@
 	msr = get_msr();
 	set_msr(msr & ~0x8000);	/* disable interrupts */
 	remove_bpts();
-	xmon_enter();
 	excprint(excp);
 	cmd = cmds(excp);
 	if (cmd == 's') {
@@ -155,7 +151,6 @@
 		xmon_trace = 0;
 		insert_bpts();
 	}
-	xmon_leave();
 	set_msr(msr);		/* restore interrupt enable */
 }
 
diff -urN linux.orig/include/asm-ppc/irq-compat.h linux/include/asm-ppc/irq-compat.h
--- linux.orig/include/asm-ppc/irq-compat.h	Thu Jan  1 01:00:00 1970
+++ linux/include/asm-ppc/irq-compat.h	Thu Jul 11 15:43:30 2002
@@ -0,0 +1,8 @@
+#include <asm/irq.h>
+
+//#define NUM_8259_INTERRUPTS	16
+//#define NUM_OPENPIC_INTERRUPTS	20
+//#define is_8259_irq(n)		((n) < NUM_8259_INTERRUPTS)
+#define openpic_to_irq(n)	((n)+NUM_8259_INTERRUPTS)
+//#define irq_to_openpic(n)	((n)-NUM_8259_INTERRUPTS)
+//#define IRQ_8259_CASCADE	NUM_8259_INTERRUPTS
diff -urN linux.orig/include/asm-ppc/ohare-compat.h linux/include/asm-ppc/ohare-compat.h
--- linux.orig/include/asm-ppc/ohare-compat.h	Thu Jan  1 01:00:00 1970
+++ linux/include/asm-ppc/ohare-compat.h	Thu Jul 11 15:43:30 2002
@@ -0,0 +1,7 @@
+#define OH_BAY_RESET		2	/* a guess */
+#define OH_IDE_ENABLE		0x20
+#define OH_IDE_POWER		0x40	/* a guess */
+#define OH_BAY_ENABLE		0x80
+#define OH_IDE_RESET		0x100	/* 0-based, a guess */
+#define OH_VIA_ENABLE		0x10000
+#define OH_IDECD_POWER		0x800000
diff -urN linux.orig/include/asm-ppc/page.h linux/include/asm-ppc/page.h
--- linux.orig/include/asm-ppc/page.h	Sun Mar 25 18:37:39 2001
+++ linux/include/asm-ppc/page.h	Thu Jul 11 15:43:30 2002
@@ -77,7 +77,7 @@
 #define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
 
 extern void clear_page(unsigned long page);
-extern void copy_page(unsigned long to, unsigned long from);
+#define copy_page(to,from)	memcpy((void *)(to), (void *)(from), PAGE_SIZE)
 
 /* map phys->virtual and virtual->phys for RAM pages */
 #ifdef CONFIG_APUS
diff -urN linux.orig/include/asm-ppc/pf-compat.h linux/include/asm-ppc/pf-compat.h
--- linux.orig/include/asm-ppc/pf-compat.h	Thu Jan  1 01:00:00 1970
+++ linux/include/asm-ppc/pf-compat.h	Thu Jul 11 15:43:30 2002
@@ -0,0 +1,2 @@
+#define PF_TRACESYS	0x00000020	/* tracing system calls */
+#define PF_PTRACED	0x00000010	/* set if ptrace (0) has been called */
