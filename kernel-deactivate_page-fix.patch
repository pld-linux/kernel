diff -urN linux/include/linux/swap.h linux-2.4.14-patched/include/linux/swap.h
--- linux/include/linux/swap.h  Mon Nov  5 21:42:13 2001
+++ linux-2.4.14-patched/include/linux/swap.h   Wed Nov  7 13:17:48 2001
@@ -105,6 +105,7 @@
 extern void FASTCALL(__lru_cache_del(struct page *));
 extern void FASTCALL(lru_cache_del(struct page *));
 
+extern void FASTCALL(deactivate_page(struct page *));
 extern void FASTCALL(activate_page(struct page *));
 
 extern void swap_setup(void);
diff -urN linux/mm/swap.c linux-2.4.14-patched/mm/swap.c
--- linux/mm/swap.c     Sun Nov  4 19:29:49 2001
+++ linux-2.4.14-patched/mm/swap.c      Wed Nov  7 13:17:26 2001
@@ -33,6 +33,32 @@
        8,      /* do swap I/O in clusters of this size */
 };
 
+/**
+ * (de)activate_page - move pages from/to active and inactive lists
+ * @page: the page we want to move
+ * @nolock - are we already holding the pagemap_lru_lock?
+ *
+ * Deactivate_page will move an active page to the right
+ * inactive list, while activate_page will move a page back
+ * from one of the inactive lists to the active list. If
+ * called on a page which is not on any of the lists, the
+ * page is left alone.
+ */
+static inline void deactivate_page_nolock(struct page * page)
+{
+       if (PageActive(page)) {
+               del_page_from_active_list(page);
+               add_page_to_inactive_list(page);
+       }
+}
+
+void deactivate_page(struct page * page)
+{
+       spin_lock(&pagemap_lru_lock);
+       deactivate_page_nolock(page);
+       spin_unlock(&pagemap_lru_lock);                                       
+}
+
 /*
  * Move an inactive page to the active list.
  */                                                                          

