diff -Nru a/arch/i386/kernel/acpi/wakeup.S b/arch/i386/kernel/acpi/wakeup.S
--- a/arch/i386/kernel/acpi/wakeup.S	2005-04-19 01:34:14 -04:00
+++ b/arch/i386/kernel/acpi/wakeup.S	2005-04-19 01:34:14 -04:00
@@ -74,8 +74,9 @@
 	movw	%ax,%fs
 	movw	$0x0e00 + 'i', %fs:(0x12)
 	
-	# need a gdt
-	lgdt	real_save_gdt - wakeup_code
+	# need a gdt -- use lgdtl to force 32-bit operands, in case
+	# the GDT is located past 16 megabytes.
+	lgdtl	real_save_gdt - wakeup_code
 
 	movl	real_save_cr0 - wakeup_code, %eax
 	movl	%eax, %cr0
diff -Nru a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
--- a/drivers/acpi/Kconfig	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/Kconfig	2005-04-19 01:34:14 -04:00
@@ -49,7 +49,6 @@
 
 config ACPI_INTERPRETER
 	bool
-	depends on !IA64_SGI_SN
 	default y
 
 if ACPI_INTERPRETER
@@ -80,6 +79,14 @@
 	depends on ACPI_SLEEP && PROC_FS
 	default y
 
+config ACPI_SLEEP_PROC_SLEEP
+	bool "/proc/acpi/sleep (deprecated)"
+	depends on ACPI_SLEEP_PROC_FS
+	default n
+	---help---
+	  Create /proc/acpi/sleep
+	  Deprecated by /sys/power/state
+
 config ACPI_AC
 	tristate "AC Adapter"
 	depends on X86
@@ -100,7 +107,6 @@
 
 config ACPI_BUTTON
 	tristate "Button"
-	depends on !IA64_SGI_SN
 	default m
 	help
 	  This driver registers for events based on buttons, such as the
@@ -112,7 +118,6 @@
 config ACPI_VIDEO
 	tristate "Video"
 	depends on EXPERIMENTAL
-	depends on !IA64_SGI_SN
 	default m
 	help
 	  This driver implement the ACPI Extensions For Display Adapters
@@ -125,7 +130,6 @@
 
 config ACPI_FAN
 	tristate "Fan"
-	depends on !IA64_SGI_SN
 	default m
 	help
 	  This driver adds support for ACPI fan devices, allowing user-mode 
@@ -133,7 +137,6 @@
 
 config ACPI_PROCESSOR
 	tristate "Processor"
-	depends on !IA64_SGI_SN
 	default m
 	help
 	  This driver installs ACPI as the idle handler for Linux, and uses
@@ -143,7 +146,6 @@
 config ACPI_HOTPLUG_CPU
 	bool "Processor Hotplug (EXPERIMENTAL)"
 	depends on ACPI_PROCESSOR && HOTPLUG_CPU && EXPERIMENTAL
-	depends on !IA64_SGI_SN
 	select ACPI_CONTAINER
 	default n
 	 ---help---
@@ -263,7 +265,6 @@
 
 config ACPI_DEBUG
 	bool "Debug Statements"
-	depends on !IA64_SGI_SN
 	default n
 	help
 	  The ACPI driver can optionally report errors with a great deal
@@ -272,7 +273,6 @@
 
 config ACPI_BUS
 	bool
-	depends on !IA64_SGI_SN
 	default y
 
 config ACPI_EC
@@ -286,17 +286,14 @@
 
 config ACPI_POWER
 	bool
-	depends on !IA64_SGI_SN
 	default y
 
 config ACPI_PCI
 	bool
-	depends on !IA64_SGI_SN
 	default PCI
 
 config ACPI_SYSTEM
 	bool
-	depends on !IA64_SGI_SN
 	default y
 	help
 	  This driver will enable your system to shut down using ACPI, and
@@ -328,8 +325,13 @@
 	depends on EXPERIMENTAL
 	default (ACPI_HOTPLUG_MEMORY || ACPI_HOTPLUG_CPU || ACPI_HOTPLUG_IO)
 	 ---help---
-	 	This is the ACPI generic container driver which supports
-		ACPI0004, PNP0A05 and PNP0A06 devices
+	  This allows _physical_ insertion and removal of CPUs and memory.
+	  This can be useful, for example, on NUMA machines that support
+	  ACPI based physical hotplug of nodes, or non-NUMA machines that
+	  support physical cpu/memory hot-plug.
+
+	  If one selects "m", this driver can be loaded with
+	  "modprobe acpi_container".
 
 config ACPI_HOTPLUG_MEMORY
 	tristate "Memory Hotplug"
diff -Nru a/drivers/acpi/button.c b/drivers/acpi/button.c
--- a/drivers/acpi/button.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/button.c	2005-04-19 01:34:14 -04:00
@@ -26,9 +26,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
@@ -36,9 +33,6 @@
 #define ACPI_BUTTON_COMPONENT		0x00080000
 #define ACPI_BUTTON_DRIVER_NAME		"ACPI Button Driver"
 #define ACPI_BUTTON_CLASS		"button"
-#define ACPI_BUTTON_FILE_INFO		"info"
-#define ACPI_BUTTON_FILE_STATE		"state"
-#define ACPI_BUTTON_TYPE_UNKNOWN	0x00
 #define ACPI_BUTTON_NOTIFY_STATUS	0x80
 
 #define ACPI_BUTTON_SUBCLASS_POWER	"power"
@@ -70,8 +64,6 @@
 
 static int acpi_button_add (struct acpi_device *device);
 static int acpi_button_remove (struct acpi_device *device, int type);
-static int acpi_button_info_open_fs(struct inode *inode, struct file *file);
-static int acpi_button_state_open_fs(struct inode *inode, struct file *file);
 
 static struct acpi_driver acpi_button_driver = {
 	.name =		ACPI_BUTTON_DRIVER_NAME,
@@ -90,191 +82,6 @@
 	unsigned long		pushed;
 };
 
-static struct file_operations acpi_button_info_fops = {
-	.open		= acpi_button_info_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static struct file_operations acpi_button_state_fops = {
-	.open		= acpi_button_state_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-static struct proc_dir_entry	*acpi_button_dir;
-
-static int acpi_button_info_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_button	*button = (struct acpi_button *) seq->private;
-
-	ACPI_FUNCTION_TRACE("acpi_button_info_seq_show");
-
-	if (!button || !button->device)
-		return_VALUE(0);
-
-	seq_printf(seq, "type:                    %s\n", 
-		acpi_device_name(button->device));
-
-	return_VALUE(0);
-}
-
-static int acpi_button_info_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_button_info_seq_show, PDE(inode)->data);
-}
-	
-static int acpi_button_state_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_button	*button = (struct acpi_button *) seq->private;
-	acpi_status		status;
-	unsigned long		state;
-
-	ACPI_FUNCTION_TRACE("acpi_button_state_seq_show");
-
-	if (!button || !button->device)
-		return_VALUE(0);
-
-	status = acpi_evaluate_integer(button->handle,"_LID",NULL,&state);
-	if (ACPI_FAILURE(status)) {
-		seq_printf(seq, "state:      unsupported\n");
-	}
-	else{
-		seq_printf(seq, "state:      %s\n", (state ? "open" : "closed")); 
-	}
-
-	return_VALUE(0);
-}
-
-static int acpi_button_state_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_button_state_seq_show, PDE(inode)->data);
-}
-
-static int
-acpi_button_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-	struct acpi_button	*button = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_button_add_fs");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	button = acpi_driver_data(device);
-
-	switch (button->type) {
-	case ACPI_BUTTON_TYPE_POWER:
-	case ACPI_BUTTON_TYPE_POWERF:
-			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_POWER, 
-				acpi_button_dir);
-		break;
-	case ACPI_BUTTON_TYPE_SLEEP:
-	case ACPI_BUTTON_TYPE_SLEEPF:
-			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_SLEEP, 
-				acpi_button_dir);
-		break;
-	case ACPI_BUTTON_TYPE_LID:
-			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_LID, 
-				acpi_button_dir);
-		break;
-	}
-
-	if (!entry)
-		return_VALUE(-ENODEV);
-	entry->owner = THIS_MODULE;
-
-	acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device), entry);
-	if (!acpi_device_dir(device))
-		return_VALUE(-ENODEV);
-	acpi_device_dir(device)->owner = THIS_MODULE;
-
-	/* 'info' [R] */
-	entry = create_proc_entry(ACPI_BUTTON_FILE_INFO,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BUTTON_FILE_INFO));
-	else {
-		entry->proc_fops = &acpi_button_info_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
-	/* show lid state [R] */
-	if (button->type == ACPI_BUTTON_TYPE_LID) {
-		entry = create_proc_entry(ACPI_BUTTON_FILE_STATE,
-			S_IRUGO, acpi_device_dir(device));
-		if (!entry)
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				"Unable to create '%s' fs entry\n",
-				ACPI_BUTTON_FILE_INFO));
-		else {
-			entry->proc_fops = &acpi_button_state_fops;
-			entry->data = acpi_driver_data(device);
-			entry->owner = THIS_MODULE;
-		}
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_button_remove_fs (
-	struct acpi_device	*device)
-{
-	struct acpi_button	*button = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_button_remove_fs");
-
-	button = acpi_driver_data(device);
-	if (acpi_device_dir(device)) {
-		if (button->type == ACPI_BUTTON_TYPE_LID)
-			remove_proc_entry(ACPI_BUTTON_FILE_STATE,
-					     acpi_device_dir(device));
-		remove_proc_entry(ACPI_BUTTON_FILE_INFO,
-				     acpi_device_dir(device));
-
-		remove_proc_entry(acpi_device_bid(device),
-				     acpi_device_dir(device)->parent);
-
-
-		switch (button->type) {
-			case ACPI_BUTTON_TYPE_POWER:
-			case ACPI_BUTTON_TYPE_POWERF:
-				remove_proc_entry(ACPI_BUTTON_SUBCLASS_POWER, 
-					acpi_button_dir);
-				break;
-			case ACPI_BUTTON_TYPE_SLEEP:
-			case ACPI_BUTTON_TYPE_SLEEPF:
-				remove_proc_entry(ACPI_BUTTON_SUBCLASS_SLEEP, 
-					acpi_button_dir);
-				break;
-			case ACPI_BUTTON_TYPE_LID:
-				remove_proc_entry(ACPI_BUTTON_SUBCLASS_LID, 
-					acpi_button_dir);
-				break;
-		}
-		acpi_device_dir(device) = NULL;
-	}
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                Driver Interface
-   -------------------------------------------------------------------------- */
-
 static void
 acpi_button_notify (
 	acpi_handle		handle,
@@ -310,8 +117,7 @@
 	
 	ACPI_FUNCTION_TRACE("acpi_button_notify_fixed");
 
-	if (!button)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	BUG_ON(!button);
 
 	acpi_button_notify(button->handle, ACPI_BUTTON_NOTIFY_STATUS, button);
 
@@ -327,10 +133,6 @@
 	acpi_status		status = AE_OK;
 	struct acpi_button	*button = NULL;
 
-	static struct acpi_device *power_button;
-	static struct acpi_device *sleep_button;
-	static struct acpi_device *lid_button;
-
 	ACPI_FUNCTION_TRACE("acpi_button_add");
 
 	if (!device)
@@ -391,42 +193,6 @@
 		goto end;
 	}
 
-	/*
-	 * Ensure only one button of each type is used.
-	 */
-	switch (button->type) {
-	case ACPI_BUTTON_TYPE_POWER:
-	case ACPI_BUTTON_TYPE_POWERF:
-		if (!power_button)
-			power_button = device;
-		else {
-			kfree(button);
-			return_VALUE(-ENODEV);
-		}
-		break;
-	case ACPI_BUTTON_TYPE_SLEEP:
-	case ACPI_BUTTON_TYPE_SLEEPF:
-		if (!sleep_button)
-			sleep_button = device;
-		else {
-			kfree(button);
-			return_VALUE(-ENODEV);
-		}
-		break;
-	case ACPI_BUTTON_TYPE_LID:
-		if (!lid_button)
-			lid_button = device;
-		else {
-			kfree(button);
-			return_VALUE(-ENODEV);
-		}
-		break;
-	}
-
-	result = acpi_button_add_fs(device);
-	if (result)
-		goto end;
-
 	switch (button->type) {
 	case ACPI_BUTTON_TYPE_POWERF:
 		status = acpi_install_fixed_event_handler (
@@ -470,7 +236,6 @@
 
 end:
 	if (result) {
-		acpi_button_remove_fs(device);
 		kfree(button);
 	}
 
@@ -511,8 +276,6 @@
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
 			"Error removing notify handler\n"));
 
-	acpi_button_remove_fs(device);	
-
 	kfree(button);
 
 	return_VALUE(0);
@@ -526,21 +289,14 @@
 
 	ACPI_FUNCTION_TRACE("acpi_button_init");
 
-	acpi_button_dir = proc_mkdir(ACPI_BUTTON_CLASS, acpi_root_dir);
-	if (!acpi_button_dir)
-		return_VALUE(-ENODEV);
-	acpi_button_dir->owner = THIS_MODULE;
-
 	result = acpi_bus_register_driver(&acpi_button_driver);
 	if (result < 0) {
-		remove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);
 		return_VALUE(-ENODEV);
 	}
 
 	return_VALUE(0);
 }
 
-
 static void __exit
 acpi_button_exit (void)
 {
@@ -548,11 +304,8 @@
 
 	acpi_bus_unregister_driver(&acpi_button_driver);
 
-	remove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);
-
 	return_VOID;
 }
-
 
 module_init(acpi_button_init);
 module_exit(acpi_button_exit);
diff -Nru a/drivers/acpi/dispatcher/dsfield.c b/drivers/acpi/dispatcher/dsfield.c
--- a/drivers/acpi/dispatcher/dsfield.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dsfield.c	2005-04-19 01:34:14 -04:00
@@ -53,13 +53,20 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsfield")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ds_get_field_names (
+	struct acpi_create_field_info   *info,
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *arg);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_create_buffer_field
  *
- * PARAMETERS:  Opcode              - The opcode to be executed
- *              Operands            - List of operands for the opcode
+ * PARAMETERS:  Op                  - Current parse op (create_xXField)
  *              walk_state          - Current state
  *
  * RETURN:      Status
@@ -70,7 +77,7 @@
  *              create_word_field_op,
  *              create_dword_field_op,
  *              create_qword_field_op,
- *              create_field_op     (all of which define fields in buffers)
+ *              create_field_op     (all of which define a field in a buffer)
  *
  ******************************************************************************/
 
@@ -119,7 +126,8 @@
 			flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE;
 		}
 		else {
-			flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND;
+			flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
+					ACPI_NS_ERROR_IF_FOUND;
 		}
 
 		/*
@@ -134,16 +142,16 @@
 		}
 	}
 
-	/* We could put the returned object (Node) on the object stack for later, but
-	 * for now, we will put it in the "op" object that the parser uses, so we
-	 * can get it again at the end of this scope
+	/* We could put the returned object (Node) on the object stack for later,
+	 * but for now, we will put it in the "op" object that the parser uses,
+	 * so we can get it again at the end of this scope
 	 */
 	op->common.node = node;
 
 	/*
-	 * If there is no object attached to the node, this node was just created and
-	 * we need to create the field object.  Otherwise, this was a lookup of an
-	 * existing node and we don't want to create the field object again.
+	 * If there is no object attached to the node, this node was just created
+	 * and we need to create the field object.  Otherwise, this was a lookup
+	 * of an existing node and we don't want to create the field object again.
 	 */
 	obj_desc = acpi_ns_get_attached_object (node);
 	if (obj_desc) {
@@ -205,7 +213,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_get_field_names (
 	struct acpi_create_field_info   *info,
 	struct acpi_walk_state          *walk_state,
@@ -238,7 +246,8 @@
 					 + (acpi_integer) arg->common.value.size;
 
 			if (position > ACPI_UINT32_MAX) {
-				ACPI_REPORT_ERROR (("Bit offset within field too large (> 0xFFFFFFFF)\n"));
+				ACPI_REPORT_ERROR ((
+					"Bit offset within field too large (> 0xFFFFFFFF)\n"));
 				return_ACPI_STATUS (AE_SUPPORT);
 			}
 
@@ -250,12 +259,15 @@
 
 			/*
 			 * Get a new access_type and access_attribute -- to be used for all
-			 * field units that follow, until field end or another access_as keyword.
+			 * field units that follow, until field end or another access_as
+			 * keyword.
 			 *
-			 * In field_flags, preserve the flag bits other than the ACCESS_TYPE bits
+			 * In field_flags, preserve the flag bits other than the
+			 * ACCESS_TYPE bits
 			 */
-			info->field_flags = (u8) ((info->field_flags & ~(AML_FIELD_ACCESS_TYPE_MASK)) |
-					  ((u8) ((u32) arg->common.value.integer >> 8)));
+			info->field_flags = (u8)
+				((info->field_flags & ~(AML_FIELD_ACCESS_TYPE_MASK)) |
+				((u8) ((u32) arg->common.value.integer >> 8)));
 
 			info->attribute = (u8) (arg->common.value.integer);
 			break;
@@ -267,7 +279,8 @@
 
 			status = acpi_ns_lookup (walk_state->scope_info,
 					  (char *) &arg->named.name,
-					  info->field_type, ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
+					  info->field_type, ACPI_IMODE_EXECUTE,
+					  ACPI_NS_DONT_OPEN_SCOPE,
 					  walk_state, &info->field_node);
 			if (ACPI_FAILURE (status)) {
 				ACPI_REPORT_NSERROR ((char *) &arg->named.name, status);
@@ -295,8 +308,9 @@
 					 + (acpi_integer) arg->common.value.size;
 
 			if (position > ACPI_UINT32_MAX) {
-				ACPI_REPORT_ERROR (("Field [%4.4s] bit offset too large (> 0xFFFFFFFF)\n",
-						(char *) &info->field_node->name));
+				ACPI_REPORT_ERROR ((
+					"Field [%4.4s] bit offset too large (> 0xFFFFFFFF)\n",
+					(char *) &info->field_node->name));
 				return_ACPI_STATUS (AE_SUPPORT);
 			}
 
@@ -306,7 +320,8 @@
 
 		default:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid opcode in field list: %X\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Invalid opcode in field list: %X\n",
 				arg->common.aml_opcode));
 			return_ACPI_STATUS (AE_AML_BAD_OPCODE);
 		}
@@ -435,7 +450,8 @@
 			status = acpi_ns_lookup (walk_state->scope_info,
 					  (char *) &arg->named.name,
 					  type, ACPI_IMODE_LOAD_PASS1,
-					  ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND,
+					  ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
+					  ACPI_NS_ERROR_IF_FOUND,
 					  walk_state, &node);
 			if (ACPI_FAILURE (status)) {
 				ACPI_REPORT_NSERROR ((char *) &arg->named.name, status);
diff -Nru a/drivers/acpi/dispatcher/dsinit.c b/drivers/acpi/dispatcher/dsinit.c
--- a/drivers/acpi/dispatcher/dsinit.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dsinit.c	2005-04-19 01:34:14 -04:00
@@ -49,12 +49,21 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsinit")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ds_init_one_object (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_init_one_object
  *
- * PARAMETERS:  obj_handle      - Node
+ * PARAMETERS:  obj_handle      - Node for the object
  *              Level           - Current nesting level
  *              Context         - Points to a init info struct
  *              return_value    - Not used
@@ -70,7 +79,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_init_one_object (
 	acpi_handle                     obj_handle,
 	u32                             level,
@@ -105,7 +114,8 @@
 
 		status = acpi_ds_initialize_region (obj_handle);
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Region %p [%4.4s] - Init failure, %s\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Region %p [%4.4s] - Init failure, %s\n",
 				obj_handle, acpi_ut_get_node_name (obj_handle),
 				acpi_format_exception (status)));
 		}
@@ -118,8 +128,10 @@
 
 		info->method_count++;
 
-		/* Print a dot for each method unless we are going to print the entire pathname */
-
+		/*
+		 * Print a dot for each method unless we are going to print
+		 * the entire pathname
+		 */
 		if (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {
 			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "."));
 		}
@@ -140,7 +152,8 @@
 		 */
 		status = acpi_ds_parse_method (obj_handle);
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Method %p [%4.4s] - parse failure, %s\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Method %p [%4.4s] - parse failure, %s\n",
 				obj_handle, acpi_ut_get_node_name (obj_handle),
 				acpi_format_exception (status)));
 
@@ -154,7 +167,8 @@
 		 * for every execution since there isn't much overhead
 		 */
 		acpi_ns_delete_namespace_subtree (obj_handle);
-		acpi_ns_delete_namespace_by_owner (((struct acpi_namespace_node *) obj_handle)->object->method.owning_id);
+		acpi_ns_delete_namespace_by_owner (
+			((struct acpi_namespace_node *) obj_handle)->object->method.owning_id);
 		break;
 
 
diff -Nru a/drivers/acpi/dispatcher/dsmethod.c b/drivers/acpi/dispatcher/dsmethod.c
--- a/drivers/acpi/dispatcher/dsmethod.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dsmethod.c	2005-04-19 01:34:14 -04:00
@@ -153,12 +153,11 @@
 	/*
 	 * Parse the method, first pass
 	 *
-	 * The first pass load is where newly declared named objects are
-	 * added into the namespace.  Actual evaluation of
-	 * the named objects (what would be called a "second
-	 * pass") happens during the actual execution of the
-	 * method so that operands to the named objects can
-	 * take on dynamic run-time values.
+	 * The first pass load is where newly declared named objects are added into
+	 * the namespace.  Actual evaluation of the named objects (what would be
+	 * called a "second pass") happens during the actual execution of the
+	 * method so that operands to the named objects can take on dynamic
+	 * run-time values.
 	 */
 	status = acpi_ps_parse_aml (walk_state);
 	if (ACPI_FAILURE (status)) {
diff -Nru a/drivers/acpi/dispatcher/dsmthdat.c b/drivers/acpi/dispatcher/dsmthdat.c
--- a/drivers/acpi/dispatcher/dsmthdat.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dsmthdat.c	2005-04-19 01:34:14 -04:00
@@ -52,6 +52,29 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsmthdat")
 
+/* Local prototypes */
+
+static void
+acpi_ds_method_data_delete_value (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+
+static acpi_status
+acpi_ds_method_data_set_value (
+	u16                             opcode,
+	u32                             index,
+	union acpi_operand_object       *object,
+	struct acpi_walk_state          *walk_state);
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+acpi_object_type
+acpi_ds_method_data_get_type (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+#endif
+
 
 /*******************************************************************************
  *
@@ -62,8 +85,8 @@
  * RETURN:      Status
  *
  * DESCRIPTION: Initialize the data structures that hold the method's arguments
- *              and locals.  The data struct is an array of NTEs for each.
- *              This allows ref_of and de_ref_of to work properly for these
+ *              and locals.  The data struct is an array of namespace nodes for
+ *              each - this allows ref_of and de_ref_of to work properly for these
  *              special data types.
  *
  * NOTES:       walk_state fields are initialized to zero by the
@@ -92,7 +115,8 @@
 		walk_state->arguments[i].name.integer |= (i << 24);
 		walk_state->arguments[i].descriptor   = ACPI_DESC_TYPE_NAMED;
 		walk_state->arguments[i].type         = ACPI_TYPE_ANY;
-		walk_state->arguments[i].flags        = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_ARG;
+		walk_state->arguments[i].flags        = ANOBJ_END_OF_PEER_LIST |
+				  ANOBJ_METHOD_ARG;
 	}
 
 	/* Init the method locals */
@@ -104,7 +128,8 @@
 		walk_state->local_variables[i].name.integer |= (i << 24);
 		walk_state->local_variables[i].descriptor  = ACPI_DESC_TYPE_NAMED;
 		walk_state->local_variables[i].type        = ACPI_TYPE_ANY;
-		walk_state->local_variables[i].flags       = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_LOCAL;
+		walk_state->local_variables[i].flags       = ANOBJ_END_OF_PEER_LIST |
+				 ANOBJ_METHOD_LOCAL;
 	}
 
 	return_VOID;
@@ -198,15 +223,18 @@
 		return_ACPI_STATUS (AE_OK);
 	}
 
-	/* Copy passed parameters into the new method stack frame  */
+	/* Copy passed parameters into the new method stack frame */
 
-	while ((index < ACPI_METHOD_NUM_ARGS) && (index < max_param_count) && params[index]) {
+	while ((index < ACPI_METHOD_NUM_ARGS) &&
+		   (index < max_param_count)      &&
+			params[index]) {
 		/*
 		 * A valid parameter.
 		 * Store the argument in the method/walk descriptor.
 		 * Do not copy the arg in order to implement call by reference
 		 */
-		status = acpi_ds_method_data_set_value (AML_ARG_OP, index, params[index], walk_state);
+		status = acpi_ds_method_data_set_value (AML_ARG_OP, index,
+				 params[index], walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -224,11 +252,13 @@
  * FUNCTION:    acpi_ds_method_data_get_node
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - which local_var or argument whose type
- *                                      to get
+ *              Index               - Which Local or Arg whose type to get
  *              walk_state          - Current walk state object
+ *              Node                - Where the node is returned.
  *
- * RETURN:      Get the Node associated with a local or arg.
+ * RETURN:      Status and node
+ *
+ * DESCRIPTION: Get the Node associated with a local or arg.
  *
  ******************************************************************************/
 
@@ -249,7 +279,8 @@
 	case AML_LOCAL_OP:
 
 		if (index > ACPI_METHOD_MAX_LOCAL) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Local index %d is invalid (max %d)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Local index %d is invalid (max %d)\n",
 				index, ACPI_METHOD_MAX_LOCAL));
 			return_ACPI_STATUS (AE_AML_INVALID_INDEX);
 		}
@@ -262,7 +293,8 @@
 	case AML_ARG_OP:
 
 		if (index > ACPI_METHOD_MAX_ARG) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Arg index %d is invalid (max %d)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Arg index %d is invalid (max %d)\n",
 				index, ACPI_METHOD_MAX_ARG));
 			return_ACPI_STATUS (AE_AML_INVALID_INDEX);
 		}
@@ -286,7 +318,7 @@
  * FUNCTION:    acpi_ds_method_data_set_value
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - which local_var or argument to get
+ *              Index               - Which Local or Arg to get
  *              Object              - Object to be inserted into the stack entry
  *              walk_state          - Current walk state object
  *
@@ -297,7 +329,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_method_data_set_value (
 	u16                             opcode,
 	u32                             index,
@@ -340,68 +372,16 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ds_method_data_get_type
- *
- * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - which local_var or argument whose type
- *                                      to get
- *              walk_state          - Current walk state object
- *
- * RETURN:      Data type of current value of the selected Arg or Local
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-acpi_object_type
-acpi_ds_method_data_get_type (
-	u16                             opcode,
-	u32                             index,
-	struct acpi_walk_state          *walk_state)
-{
-	acpi_status                     status;
-	struct acpi_namespace_node      *node;
-	union acpi_operand_object       *object;
-
-
-	ACPI_FUNCTION_TRACE ("ds_method_data_get_type");
-
-
-	/* Get the namespace node for the arg/local */
-
-	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
-	if (ACPI_FAILURE (status)) {
-		return_VALUE ((ACPI_TYPE_NOT_FOUND));
-	}
-
-	/* Get the object */
-
-	object = acpi_ns_get_attached_object (node);
-	if (!object) {
-		/* Uninitialized local/arg, return TYPE_ANY */
-
-		return_VALUE (ACPI_TYPE_ANY);
-	}
-
-	/* Get the object type */
-
-	return_VALUE (ACPI_GET_OBJECT_TYPE (object));
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ds_method_data_get_value
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
  *              Index               - which local_var or argument to get
  *              walk_state          - Current walk state object
- *              *dest_desc          - Ptr to Descriptor into which selected Arg
- *                                    or Local value should be copied
+ *              dest_desc           - Where Arg or Local value is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Retrieve value of selected Arg or Local from the method frame
- *              at the current top of the method stack.
+ * DESCRIPTION: Retrieve value of selected Arg or Local for this method
  *              Used only in acpi_ex_resolve_to_value().
  *
  ******************************************************************************/
@@ -467,14 +447,16 @@
 		else switch (opcode) {
 		case AML_ARG_OP:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Uninitialized Arg[%d] at node %p\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Uninitialized Arg[%d] at node %p\n",
 				index, node));
 
 			return_ACPI_STATUS (AE_AML_UNINITIALIZED_ARG);
 
 		case AML_LOCAL_OP:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Uninitialized Local[%d] at node %p\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Uninitialized Local[%d] at node %p\n",
 				index, node));
 
 			return_ACPI_STATUS (AE_AML_UNINITIALIZED_LOCAL);
@@ -506,12 +488,12 @@
  *
  * RETURN:      None
  *
- * DESCRIPTION: Delete the entry at Opcode:Index on the method stack.  Inserts
+ * DESCRIPTION: Delete the entry at Opcode:Index.  Inserts
  *              a null into the stack slot after the object is deleted.
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ds_method_data_delete_value (
 	u16                             opcode,
 	u32                             index,
@@ -562,7 +544,7 @@
  * FUNCTION:    acpi_ds_store_object_to_local
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - which local_var or argument to set
+ *              Index               - Which Local or Arg to set
  *              obj_desc            - Value to be stored
  *              walk_state          - Current walk state
  *
@@ -651,19 +633,20 @@
 		 */
 		if (opcode == AML_ARG_OP) {
 			/*
-			 * Make sure that the object is the correct type.  This may be overkill, but
-			 * it is here because references were NS nodes in the past.  Now they are
-			 * operand objects of type Reference.
+			 * Make sure that the object is the correct type.  This may be
+			 * overkill, butit is here because references were NS nodes in
+			 *  the past.  Now they are operand objects of type Reference.
 			 */
 			if (ACPI_GET_DESCRIPTOR_TYPE (current_obj_desc) != ACPI_DESC_TYPE_OPERAND) {
-				ACPI_REPORT_ERROR (("Invalid descriptor type while storing to method arg: [%s]\n",
-						acpi_ut_get_descriptor_name (current_obj_desc)));
+				ACPI_REPORT_ERROR ((
+					"Invalid descriptor type while storing to method arg: [%s]\n",
+					acpi_ut_get_descriptor_name (current_obj_desc)));
 				return_ACPI_STATUS (AE_AML_INTERNAL);
 			}
 
 			/*
-			 * If we have a valid reference object that came from ref_of(), do the
-			 * indirect store
+			 * If we have a valid reference object that came from ref_of(),
+			 * do the indirect store
 			 */
 			if ((current_obj_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE) &&
 				(current_obj_desc->reference.opcode == AML_REF_OF_OP)) {
@@ -711,5 +694,57 @@
 
 	return_ACPI_STATUS (status);
 }
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_get_type
+ *
+ * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
+ *              Index               - Which Local or Arg whose type to get
+ *              walk_state          - Current walk state object
+ *
+ * RETURN:      Data type of current value of the selected Arg or Local
+ *
+ * DESCRIPTION: Get the type of the object stored in the Local or Arg
+ *
+ ******************************************************************************/
+
+acpi_object_type
+acpi_ds_method_data_get_type (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
+{
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	union acpi_operand_object       *object;
+
+
+	ACPI_FUNCTION_TRACE ("ds_method_data_get_type");
+
+
+	/* Get the namespace node for the arg/local */
+
+	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
+	if (ACPI_FAILURE (status)) {
+		return_VALUE ((ACPI_TYPE_NOT_FOUND));
+	}
+
+	/* Get the object */
+
+	object = acpi_ns_get_attached_object (node);
+	if (!object) {
+		/* Uninitialized local/arg, return TYPE_ANY */
+
+		return_VALUE (ACPI_TYPE_ANY);
+	}
+
+	/* Get the object type */
+
+	return_VALUE (ACPI_GET_OBJECT_TYPE (object));
+}
+#endif
 
 
diff -Nru a/drivers/acpi/dispatcher/dsobject.c b/drivers/acpi/dispatcher/dsobject.c
--- a/drivers/acpi/dispatcher/dsobject.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dsobject.c	2005-04-19 01:34:14 -04:00
@@ -52,9 +52,15 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsobject")
 
+static acpi_status
+acpi_ds_build_internal_object (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	union acpi_operand_object       **obj_desc_ptr);
+
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_build_internal_object
  *
@@ -67,9 +73,9 @@
  * DESCRIPTION: Translate a parser Op object to the equivalent namespace object
  *              Simple objects are any objects other than a package object!
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_build_internal_object (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op,
@@ -90,9 +96,11 @@
 		 * Otherwise, go ahead and look it up now
 		 */
 		if (!op->common.node) {
-			status = acpi_ns_lookup (walk_state->scope_info, op->common.value.string,
+			status = acpi_ns_lookup (walk_state->scope_info,
+					  op->common.value.string,
 					  ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-					  ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL,
+					  ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+					  NULL,
 					  (struct acpi_namespace_node **) &(op->common.node));
 
 			if (ACPI_FAILURE (status)) {
@@ -104,12 +112,14 @@
 
 	/* Create and init the internal ACPI object */
 
-	obj_desc = acpi_ut_create_internal_object ((acpi_ps_get_opcode_info (op->common.aml_opcode))->object_type);
+	obj_desc = acpi_ut_create_internal_object (
+			 (acpi_ps_get_opcode_info (op->common.aml_opcode))->object_type);
 	if (!obj_desc) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	status = acpi_ds_init_object_from_op (walk_state, op, op->common.aml_opcode, &obj_desc);
+	status = acpi_ds_init_object_from_op (walk_state, op, op->common.aml_opcode,
+			 &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		acpi_ut_remove_reference (obj_desc);
 		return_ACPI_STATUS (status);
@@ -120,7 +130,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_build_internal_buffer_obj
  *
@@ -134,7 +144,7 @@
  * DESCRIPTION: Translate a parser Op package object to the equivalent
  *              namespace object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_build_internal_buffer_obj (
@@ -229,7 +239,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_build_internal_package_obj
  *
@@ -243,7 +253,7 @@
  * DESCRIPTION: Translate a parser Op package object to the equivalent
  *              namespace object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_build_internal_package_obj (
@@ -331,11 +341,12 @@
 		if (arg->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
 			/* Object (package or buffer) is already built */
 
-			obj_desc->package.elements[i] = ACPI_CAST_PTR (union acpi_operand_object, arg->common.node);
+			obj_desc->package.elements[i] =
+				ACPI_CAST_PTR (union acpi_operand_object, arg->common.node);
 		}
 		else {
 			status = acpi_ds_build_internal_object (walk_state, arg,
-					  &obj_desc->package.elements[i]);
+					 &obj_desc->package.elements[i]);
 		}
 
 		i++;
@@ -348,7 +359,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_create_node
  *
@@ -360,7 +371,7 @@
  *
  * DESCRIPTION: Create the object to be associated with a namespace node
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_create_node (
@@ -392,7 +403,8 @@
 
 	/* Build an internal object for the argument(s) */
 
-	status = acpi_ds_build_internal_object (walk_state, op->common.value.arg, &obj_desc);
+	status = acpi_ds_build_internal_object (walk_state, op->common.value.arg,
+			 &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -414,7 +426,7 @@
 #endif /* ACPI_NO_METHOD_EXECUTION */
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_init_object_from_op
  *
@@ -429,7 +441,7 @@
  *              associated arguments.  The namespace object is a more compact
  *              representation of the Op and its arguments.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_init_object_from_op (
@@ -462,7 +474,8 @@
 		/*
 		 * Defer evaluation of Buffer term_arg operand
 		 */
-		obj_desc->buffer.node     = (struct acpi_namespace_node *) walk_state->operands[0];
+		obj_desc->buffer.node     = (struct acpi_namespace_node *)
+				   walk_state->operands[0];
 		obj_desc->buffer.aml_start = op->named.data;
 		obj_desc->buffer.aml_length = op->named.length;
 		break;
@@ -473,7 +486,8 @@
 		/*
 		 * Defer evaluation of Package term_arg operand
 		 */
-		obj_desc->package.node     = (struct acpi_namespace_node *) walk_state->operands[0];
+		obj_desc->package.node     = (struct acpi_namespace_node *)
+				   walk_state->operands[0];
 		obj_desc->package.aml_start = op->named.data;
 		obj_desc->package.aml_length = op->named.length;
 		break;
@@ -486,9 +500,10 @@
 			/*
 			 * Resolve AML Constants here - AND ONLY HERE!
 			 * All constants are integers.
-			 * We mark the integer with a flag that indicates that it started life
-			 * as a constant -- so that stores to constants will perform as expected (noop).
-			 * (zero_op is used as a placeholder for optional target operands.)
+			 * We mark the integer with a flag that indicates that it started
+			 * life as a constant -- so that stores to constants will perform
+			 * as expected (noop). zero_op is used as a placeholder for optional
+			 * target operands.
 			 */
 			obj_desc->common.flags = AOPOBJ_AML_CONSTANT;
 
@@ -521,7 +536,8 @@
 
 			default:
 
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown constant opcode %X\n", opcode));
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Unknown constant opcode %X\n", opcode));
 				status = AE_AML_OPERAND_TYPE;
 				break;
 			}
@@ -535,7 +551,8 @@
 
 
 		default:
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Integer type %X\n", op_info->type));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Integer type %X\n",
+				op_info->type));
 			status = AE_AML_OPERAND_TYPE;
 			break;
 		}
@@ -570,8 +587,10 @@
 			obj_desc->reference.offset = opcode - AML_LOCAL_OP;
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-			status = acpi_ds_method_data_get_node (AML_LOCAL_OP, obj_desc->reference.offset,
-					 walk_state, (struct acpi_namespace_node **) &obj_desc->reference.object);
+			status = acpi_ds_method_data_get_node (AML_LOCAL_OP,
+					 obj_desc->reference.offset,
+					 walk_state,
+					 (struct acpi_namespace_node **) &obj_desc->reference.object);
 #endif
 			break;
 
@@ -584,8 +603,10 @@
 			obj_desc->reference.offset = opcode - AML_ARG_OP;
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-			status = acpi_ds_method_data_get_node (AML_ARG_OP, obj_desc->reference.offset,
-					 walk_state, (struct acpi_namespace_node **) &obj_desc->reference.object);
+			status = acpi_ds_method_data_get_node (AML_ARG_OP,
+					 obj_desc->reference.offset,
+					 walk_state,
+					 (struct acpi_namespace_node **) &obj_desc->reference.object);
 #endif
 			break;
 
diff -Nru a/drivers/acpi/dispatcher/dsopcode.c b/drivers/acpi/dispatcher/dsopcode.c
--- a/drivers/acpi/dispatcher/dsopcode.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dsopcode.c	2005-04-19 01:34:14 -04:00
@@ -54,12 +54,31 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsopcode")
 
+/* Local prototypes */
 
-/*****************************************************************************
+static acpi_status
+acpi_ds_execute_arguments (
+	struct acpi_namespace_node      *node,
+	struct acpi_namespace_node      *scope_node,
+	u32                             aml_length,
+	u8                              *aml_start);
+
+static acpi_status
+acpi_ds_init_buffer_field (
+	u16                             aml_opcode,
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       *buffer_desc,
+	union acpi_operand_object       *offset_desc,
+	union acpi_operand_object       *length_desc,
+	union acpi_operand_object       *result_desc);
+
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_execute_arguments
  *
- * PARAMETERS:  Node                - Parent NS node
+ * PARAMETERS:  Node                - Object NS node
+ *              scope_node          - Parent NS node
  *              aml_length          - Length of executable AML
  *              aml_start           - Pointer to the AML
  *
@@ -67,9 +86,9 @@
  *
  * DESCRIPTION: Late (deferred) execution of region or field arguments
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_execute_arguments (
 	struct acpi_namespace_node      *node,
 	struct acpi_namespace_node      *scope_node,
@@ -162,7 +181,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_get_buffer_field_arguments
  *
@@ -173,7 +192,7 @@
  * DESCRIPTION: Get buffer_field Buffer and Index. This implements the late
  *              evaluation of these field attributes.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_get_buffer_field_arguments (
@@ -208,7 +227,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_get_buffer_arguments
  *
@@ -219,7 +238,7 @@
  * DESCRIPTION: Get Buffer length and initializer byte list.  This implements
  *              the late evaluation of these attributes.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_get_buffer_arguments (
@@ -255,7 +274,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_get_package_arguments
  *
@@ -266,7 +285,7 @@
  * DESCRIPTION: Get Package length and initializer byte list.  This implements
  *              the late evaluation of these attributes.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_get_package_arguments (
@@ -353,17 +372,17 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_initialize_region
  *
- * PARAMETERS:  Op              - A valid region Op object
+ * PARAMETERS:  obj_handle      - Region namespace node
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Front end to ev_initialize_region
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_initialize_region (
@@ -382,7 +401,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_init_buffer_field
  *
@@ -390,16 +409,16 @@
  *              obj_desc        - buffer_field object
  *              buffer_desc     - Host Buffer
  *              offset_desc     - Offset into buffer
- *              Length          - Length of field (CREATE_FIELD_OP only)
- *              Result          - Where to store the result
+ *              length_desc     - Length of field (CREATE_FIELD_OP only)
+ *              result_desc     - Where to store the result
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Perform actual initialization of a buffer field
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_init_buffer_field (
 	u16                             aml_opcode,
 	union acpi_operand_object       *obj_desc,
@@ -435,8 +454,10 @@
 	 * after resolution in acpi_ex_resolve_operands().
 	 */
 	if (ACPI_GET_DESCRIPTOR_TYPE (result_desc) != ACPI_DESC_TYPE_NAMED) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) destination not a NS Node [%s]\n",
-				acpi_ps_get_opcode_name (aml_opcode), acpi_ut_get_descriptor_name (result_desc)));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"(%s) destination not a NS Node [%s]\n",
+				acpi_ps_get_opcode_name (aml_opcode),
+				acpi_ut_get_descriptor_name (result_desc)));
 
 		status = AE_AML_OPERAND_TYPE;
 		goto cleanup;
@@ -452,9 +473,18 @@
 
 		/* Offset is in bits, count is in bits */
 
+		field_flags = AML_FIELD_ACCESS_BYTE;
 		bit_offset = offset;
 		bit_count  = (u32) length_desc->integer.value;
-		field_flags = AML_FIELD_ACCESS_BYTE;
+
+		/* Must have a valid (>0) bit count */
+
+		if (bit_count == 0) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Attempt to create_field of length 0\n"));
+			status = AE_AML_OPERAND_VALUE;
+			goto cleanup;
+		}
 		break;
 
 	case AML_CREATE_BIT_FIELD_OP:
@@ -527,7 +557,8 @@
 
 	/*
 	 * Initialize areas of the field object that are common to all fields
-	 * For field_flags, use LOCK_RULE = 0 (NO_LOCK), UPDATE_RULE = 0 (UPDATE_PRESERVE)
+	 * For field_flags, use LOCK_RULE = 0 (NO_LOCK),
+	 * UPDATE_RULE = 0 (UPDATE_PRESERVE)
 	 */
 	status = acpi_ex_prep_common_field_object (obj_desc, field_flags, 0,
 			  bit_offset, bit_count);
@@ -539,8 +570,8 @@
 
 	/* Reference count for buffer_desc inherits obj_desc count */
 
-	buffer_desc->common.reference_count = (u16) (buffer_desc->common.reference_count +
-			  obj_desc->common.reference_count);
+	buffer_desc->common.reference_count = (u16)
+		(buffer_desc->common.reference_count + obj_desc->common.reference_count);
 
 
 cleanup:
@@ -569,7 +600,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_eval_buffer_field_operands
  *
@@ -581,7 +612,7 @@
  * DESCRIPTION: Get buffer_field Buffer and Index
  *              Called from acpi_ds_exec_end_op during buffer_field parse tree walk
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_eval_buffer_field_operands (
@@ -656,7 +687,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_eval_region_operands
  *
@@ -668,7 +699,7 @@
  * DESCRIPTION: Get region address and length
  *              Called from acpi_ds_exec_end_op during op_region parse tree walk
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_eval_region_operands (
@@ -686,7 +717,8 @@
 
 
 	/*
-	 * This is where we evaluate the address and length fields of the op_region declaration
+	 * This is where we evaluate the address and length fields of the
+	 * op_region declaration
 	 */
 	node =  op->common.node;
 
@@ -707,7 +739,8 @@
 
 	/* Resolve the length and address operands to numbers */
 
-	status = acpi_ex_resolve_operands (op->common.aml_opcode, ACPI_WALK_OPERANDS, walk_state);
+	status = acpi_ex_resolve_operands (op->common.aml_opcode,
+			 ACPI_WALK_OPERANDS, walk_state);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -736,7 +769,8 @@
 	 */
 	operand_desc = walk_state->operands[walk_state->num_operands - 2];
 
-	obj_desc->region.address = (acpi_physical_address) operand_desc->integer.value;
+	obj_desc->region.address = (acpi_physical_address)
+			  operand_desc->integer.value;
 	acpi_ut_remove_reference (operand_desc);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "rgn_obj %p Addr %8.8X%8.8X Len %X\n",
@@ -752,7 +786,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_eval_data_object_operands
  *
@@ -765,7 +799,7 @@
  * DESCRIPTION: Get the operands and complete the following data object types:
  *              Buffer, Package.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_eval_data_object_operands (
@@ -830,7 +864,7 @@
 
 	if (ACPI_SUCCESS (status)) {
 		/*
-		 * Return the object in the walk_state, unless the parent is a package --
+		 * Return the object in the walk_state, unless the parent is a package -
 		 * in this case, the return object will be stored in the parse tree
 		 * for the package.
 		 */
@@ -988,7 +1022,8 @@
 			status = AE_CTRL_PENDING;
 		}
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[WHILE_OP] termination! Op=%p\n", op));
+		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+			"[WHILE_OP] termination! Op=%p\n",op));
 
 		/* Pop this control state and free it */
 
diff -Nru a/drivers/acpi/dispatcher/dsutils.c b/drivers/acpi/dispatcher/dsutils.c
--- a/drivers/acpi/dispatcher/dsutils.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dsutils.c	2005-04-19 01:34:14 -04:00
@@ -100,7 +100,6 @@
 
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_do_implicit_return
@@ -205,7 +204,7 @@
 	 * NOTE: this is optional because the ASL language does not actually
 	 * support this behavior.
 	 */
-	acpi_ds_do_implicit_return (walk_state->result_obj, walk_state, TRUE);
+	(void) acpi_ds_do_implicit_return (walk_state->result_obj, walk_state, TRUE);
 
 	/*
 	 * Now determine if the parent will use the result
@@ -219,8 +218,9 @@
 		(op->common.parent->common.aml_opcode == AML_SCOPE_OP)) {
 		/* No parent, the return value cannot possibly be used */
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "At Method level, result of [%s] not used\n",
-				acpi_ps_get_opcode_name (op->common.aml_opcode)));
+		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+			"At Method level, result of [%s] not used\n",
+			acpi_ps_get_opcode_name (op->common.aml_opcode)));
 		return_VALUE (FALSE);
 	}
 
@@ -228,7 +228,8 @@
 
 	parent_info = acpi_ps_get_opcode_info (op->common.parent->common.aml_opcode);
 	if (parent_info->class == AML_CLASS_UNKNOWN) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown parent opcode. Op=%p\n", op));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Unknown parent opcode. Op=%p\n", op));
 		return_VALUE (FALSE);
 	}
 
@@ -309,17 +310,19 @@
 
 
 result_used:
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Result of [%s] used by Parent [%s] Op=%p\n",
-			acpi_ps_get_opcode_name (op->common.aml_opcode),
-			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+		"Result of [%s] used by Parent [%s] Op=%p\n",
+		acpi_ps_get_opcode_name (op->common.aml_opcode),
+		acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
 
 	return_VALUE (TRUE);
 
 
 result_not_used:
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Result of [%s] not used by Parent [%s] Op=%p\n",
-			acpi_ps_get_opcode_name (op->common.aml_opcode),
-			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+		"Result of [%s] not used by Parent [%s] Op=%p\n",
+		acpi_ps_get_opcode_name (op->common.aml_opcode),
+		acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
 
 	return_VALUE (FALSE);
 }
@@ -522,7 +525,8 @@
 		if ((walk_state->deferred_node) &&
 			(walk_state->deferred_node->type == ACPI_TYPE_BUFFER_FIELD) &&
 			(arg_index != 0)) {
-			obj_desc = ACPI_CAST_PTR (union acpi_operand_object, walk_state->deferred_node);
+			obj_desc = ACPI_CAST_PTR (
+					 union acpi_operand_object, walk_state->deferred_node);
 			status = AE_OK;
 		}
 		else    /* All other opcodes */ {
@@ -565,7 +569,8 @@
 					 * indicate this to the interpreter, set the
 					 * object to the root
 					 */
-					obj_desc = ACPI_CAST_PTR (union acpi_operand_object, acpi_gbl_root_node);
+					obj_desc = ACPI_CAST_PTR (
+							 union acpi_operand_object, acpi_gbl_root_node);
 					status = AE_OK;
 				}
 				else {
@@ -612,7 +617,8 @@
 			 */
 			opcode = AML_ZERO_OP;       /* Has no arguments! */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Null namepath: Arg=%p\n", arg));
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+				"Null namepath: Arg=%p\n", arg));
 		}
 		else {
 			opcode = arg->common.aml_opcode;
@@ -642,7 +648,8 @@
 				 * Only error is underflow, and this indicates
 				 * a missing or null operand!
 				 */
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Missing or null operand, %s\n",
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Missing or null operand, %s\n",
 					acpi_format_exception (status)));
 				return_ACPI_STATUS (status);
 			}
@@ -657,8 +664,8 @@
 
 			/* Initialize the new object */
 
-			status = acpi_ds_init_object_from_op (walk_state, arg,
-					 opcode, &obj_desc);
+			status = acpi_ds_init_object_from_op (
+					 walk_state, arg, opcode, &obj_desc);
 			if (ACPI_FAILURE (status)) {
 				acpi_ut_delete_object_desc (obj_desc);
 				return_ACPI_STATUS (status);
diff -Nru a/drivers/acpi/dispatcher/dswexec.c b/drivers/acpi/dispatcher/dswexec.c
--- a/drivers/acpi/dispatcher/dswexec.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dswexec.c	2005-04-19 01:34:14 -04:00
@@ -73,11 +73,13 @@
 			  acpi_ex_opcode_3A_1T_1R,
 			  acpi_ex_opcode_6A_0T_1R};
 
+
 /*****************************************************************************
  *
  * FUNCTION:    acpi_ds_get_predicate_value
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              result_obj      - if non-zero, pop result from result stack
  *
  * RETURN:      Status
  *
@@ -124,7 +126,8 @@
 	}
 
 	if (!obj_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No predicate obj_desc=%p State=%p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"No predicate obj_desc=%p State=%p\n",
 			obj_desc, walk_state));
 
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
@@ -197,7 +200,7 @@
  * FUNCTION:    acpi_ds_exec_begin_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              out_op          - Return op if a new one is created
+ *              out_op          - Where to return op if a new one is created
  *
  * RETURN:      Status
  *
@@ -233,7 +236,8 @@
 		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 
 		if (acpi_ns_opens_scope (walk_state->op_info->object_type)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s) Popping scope for Op %p\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+				"(%s) Popping scope for Op %p\n",
 				acpi_ut_get_type_name (walk_state->op_info->object_type), op));
 
 			status = acpi_ds_scope_stack_pop (walk_state);
@@ -297,11 +301,10 @@
 
 		if (walk_state->walk_type == ACPI_WALK_METHOD) {
 			/*
-			 * Found a named object declaration during method
-			 * execution;  we must enter this object into the
-			 * namespace.  The created object is temporary and
-			 * will be deleted upon completion of the execution
-			 * of this method.
+			 * Found a named object declaration during method execution;
+			 * we must enter this object into the namespace.  The created
+			 * object is temporary and will be deleted upon completion of
+			 * the execution of this method.
 			 */
 			status = acpi_ds_load2_begin_op (walk_state, NULL);
 		}
@@ -338,8 +341,6 @@
  * FUNCTION:    acpi_ds_exec_end_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been completed in the
- *                                walk;  Arguments have now been evaluated.
  *
  * RETURN:      Status
  *
@@ -389,7 +390,7 @@
 	/* Decode the Opcode Class */
 
 	switch (op_class) {
-	case AML_CLASS_ARGUMENT:    /* constants, literals, etc. -- do nothing */
+	case AML_CLASS_ARGUMENT:    /* constants, literals, etc. - do nothing */
 		break;
 
 
@@ -417,12 +418,12 @@
 			/* Resolve all operands */
 
 			status = acpi_ex_resolve_operands (walk_state->opcode,
-					  &(walk_state->operands [walk_state->num_operands -1]),
-					  walk_state);
+					 &(walk_state->operands [walk_state->num_operands -1]),
+					 walk_state);
 			if (ACPI_SUCCESS (status)) {
 				ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
-						  acpi_ps_get_opcode_name (walk_state->opcode),
-						  walk_state->num_operands, "after ex_resolve_operands");
+					acpi_ps_get_opcode_name (walk_state->opcode),
+					walk_state->num_operands, "after ex_resolve_operands");
 			}
 		}
 
@@ -506,7 +507,8 @@
 			if ((op->asl.parent) &&
 			   ((op->asl.parent->asl.aml_opcode == AML_PACKAGE_OP) ||
 				(op->asl.parent->asl.aml_opcode == AML_VAR_PACKAGE_OP))) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Method Reference in a Package, Op=%p\n", op));
+				ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+					"Method Reference in a Package, Op=%p\n", op));
 				op->common.node = (struct acpi_namespace_node *) op->asl.value.arg->asl.node->object;
 				acpi_ut_add_reference (op->asl.value.arg->asl.node->object);
 				return_ACPI_STATUS (AE_OK);
@@ -583,13 +585,15 @@
 			case AML_NAME_OP:
 
 				/*
-				 * Put the Node on the object stack (Contains the ACPI Name of
-				 * this object)
+				 * Put the Node on the object stack (Contains the ACPI Name
+				 * of this object)
 				 */
 				walk_state->operands[0] = (void *) op->common.parent->common.node;
 				walk_state->num_operands = 1;
 
-				status = acpi_ds_create_node (walk_state, op->common.parent->common.node, op->common.parent);
+				status = acpi_ds_create_node (walk_state,
+						 op->common.parent->common.node,
+						 op->common.parent);
 				if (ACPI_FAILURE (status)) {
 					break;
 				}
@@ -600,7 +604,7 @@
 			case AML_INT_EVAL_SUBTREE_OP:
 
 				status = acpi_ds_eval_data_object_operands (walk_state, op,
-						  acpi_ns_get_attached_object (op->common.parent->common.node));
+						 acpi_ns_get_attached_object (op->common.parent->common.node));
 				break;
 
 			default:
@@ -609,7 +613,7 @@
 				break;
 			}
 
-			/* Done with this result state (Now that operand stack is built) */
+			/* Done with result state (Now that operand stack is built) */
 
 			status = acpi_ds_result_stack_pop (walk_state);
 			if (ACPI_FAILURE (status)) {
@@ -620,8 +624,7 @@
 			 * If a result object was returned from above, push it on the
 			 * current result stack
 			 */
-			if (ACPI_SUCCESS (status) &&
-				walk_state->result_obj) {
+			if (walk_state->result_obj) {
 				status = acpi_ds_result_push (walk_state->result_obj, walk_state);
 			}
 			break;
@@ -654,7 +657,8 @@
 
 		case AML_TYPE_UNDEFINED:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Undefined opcode type Op=%p\n", op));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Undefined opcode type Op=%p\n", op));
 			return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
 
 
@@ -709,13 +713,14 @@
 		status = acpi_gbl_exception_handler (status,
 				 walk_state->method_node->name.integer, walk_state->opcode,
 				 walk_state->aml_offset, NULL);
-		acpi_ex_enter_interpreter ();
+		(void) acpi_ex_enter_interpreter ();
 	}
 
 	if (walk_state->result_obj) {
 		/* Break to debugger to display result */
 
-		ACPI_DEBUGGER_EXEC (acpi_db_display_result_object (walk_state->result_obj, walk_state));
+		ACPI_DEBUGGER_EXEC (acpi_db_display_result_object (walk_state->result_obj,
+				 walk_state));
 
 		/*
 		 * Delete the result op if and only if:
diff -Nru a/drivers/acpi/dispatcher/dswload.c b/drivers/acpi/dispatcher/dswload.c
--- a/drivers/acpi/dispatcher/dswload.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dswload.c	2005-04-19 01:34:14 -04:00
@@ -79,20 +79,23 @@
 
 	switch (pass_number) {
 	case 1:
-		walk_state->parse_flags       = ACPI_PARSE_LOAD_PASS1 | ACPI_PARSE_DELETE_TREE;
+		walk_state->parse_flags       = ACPI_PARSE_LOAD_PASS1 |
+				   ACPI_PARSE_DELETE_TREE;
 		walk_state->descending_callback = acpi_ds_load1_begin_op;
 		walk_state->ascending_callback = acpi_ds_load1_end_op;
 		break;
 
 	case 2:
-		walk_state->parse_flags       = ACPI_PARSE_LOAD_PASS1 | ACPI_PARSE_DELETE_TREE;
+		walk_state->parse_flags       = ACPI_PARSE_LOAD_PASS1 |
+				   ACPI_PARSE_DELETE_TREE;
 		walk_state->descending_callback = acpi_ds_load2_begin_op;
 		walk_state->ascending_callback = acpi_ds_load2_end_op;
 		break;
 
 	case 3:
 #ifndef ACPI_NO_METHOD_EXECUTION
-		walk_state->parse_flags      |= ACPI_PARSE_EXECUTE  | ACPI_PARSE_DELETE_TREE;
+		walk_state->parse_flags      |= ACPI_PARSE_EXECUTE  |
+				   ACPI_PARSE_DELETE_TREE;
 		walk_state->descending_callback = acpi_ds_exec_begin_op;
 		walk_state->ascending_callback = acpi_ds_exec_end_op;
 #endif
@@ -111,8 +114,7 @@
  * FUNCTION:    acpi_ds_load1_begin_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been reached in the
- *                                walk;  Arguments have not been evaluated yet.
+ *              out_op          - Where to return op if a new one is created
  *
  * RETURN:      Status
  *
@@ -146,7 +148,8 @@
 #if 0
 			if ((walk_state->op_info->class == AML_CLASS_EXECUTE) ||
 				(walk_state->op_info->class == AML_CLASS_CONTROL)) {
-				acpi_os_printf ("\n\n***EXECUTABLE OPCODE %s***\n\n", walk_state->op_info->name);
+				acpi_os_printf ("\n\n***EXECUTABLE OPCODE %s***\n\n",
+					walk_state->op_info->name);
 				*out_op = op;
 				return (AE_CTRL_SKIP);
 			}
@@ -191,7 +194,8 @@
 			 */
 			acpi_dm_add_to_external_list (path);
 			status = acpi_ns_lookup (walk_state->scope_info, path, object_type,
-					   ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+					   ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT,
+					   walk_state, &(node));
 		}
 #endif
 		if (ACPI_FAILURE (status)) {
@@ -224,10 +228,12 @@
 			 *  Name (DEB, 0)
 			 *  Scope (DEB) { ... }
 			 *
-			 * Note: silently change the type here.  On the second pass, we will report a warning
+			 * Note: silently change the type here.  On the second pass, we will report
+			 * a warning
 			 */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+				"Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
 				path, acpi_ut_get_type_name (node->type)));
 
 			node->type = ACPI_TYPE_ANY;
@@ -238,7 +244,8 @@
 
 			/* All other types are an error */
 
-			ACPI_REPORT_ERROR (("Invalid type (%s) for target of Scope operator [%4.4s] (Cannot override)\n",
+			ACPI_REPORT_ERROR ((
+				"Invalid type (%s) for target of Scope operator [%4.4s] (Cannot override)\n",
 				acpi_ut_get_type_name (node->type), path));
 
 			return (AE_AML_OPERAND_TYPE);
@@ -249,7 +256,8 @@
 	default:
 
 		/*
-		 * For all other named opcodes, we will enter the name into the namespace.
+		 * For all other named opcodes, we will enter the name into
+		 * the namespace.
 		 *
 		 * Setup the search flags.
 		 * Since we are entering a name into the namespace, we do not want to
@@ -279,14 +287,16 @@
 					acpi_ut_get_type_name (object_type)));
 		}
 		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[%s] Both Find or Create allowed\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+				"[%s] Both Find or Create allowed\n",
 					acpi_ut_get_type_name (object_type)));
 		}
 
 		/*
 		 * Enter the named type into the internal namespace.  We enter the name
-		 * as we go downward in the parse tree.  Any necessary subobjects that involve
-		 * arguments to the opcode must be created as we go back up the parse tree later.
+		 * as we go downward in the parse tree.  Any necessary subobjects that
+		 * involve arguments to the opcode must be created as we go back up the
+		 * parse tree later.
 		 */
 		status = acpi_ns_lookup (walk_state->scope_info, path, object_type,
 				  ACPI_IMODE_LOAD_PASS1, flags, walk_state, &(node));
@@ -335,8 +345,6 @@
  * FUNCTION:    acpi_ds_load1_end_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been completed in the
- *                                walk;  Arguments have now been evaluated.
  *
  * RETURN:      Status
  *
@@ -383,7 +391,9 @@
 
 	if (op->common.aml_opcode == AML_REGION_OP) {
 		status = acpi_ex_create_region (op->named.data, op->named.length,
-				   (acpi_adr_space_type) ((op->common.value.arg)->common.value.integer), walk_state);
+				   (acpi_adr_space_type)
+						 ((op->common.value.arg)->common.value.integer),
+						 walk_state);
 		if (ACPI_FAILURE (status)) {
 			return (status);
 		}
@@ -394,7 +404,8 @@
 		/* For Name opcode, get the object type from the argument */
 
 		if (op->common.value.arg) {
-			object_type = (acpi_ps_get_opcode_info ((op->common.value.arg)->common.aml_opcode))->object_type;
+			object_type = (acpi_ps_get_opcode_info (
+				(op->common.value.arg)->common.aml_opcode))->object_type;
 			op->common.node->type = (u8) object_type;
 		}
 	}
@@ -448,8 +459,7 @@
  * FUNCTION:    acpi_ds_load2_begin_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been reached in the
- *                                walk;  Arguments have not been evaluated yet.
+ *              out_op          - Wher to return op if a new one is created
  *
  * RETURN:      Status
  *
@@ -478,14 +488,20 @@
 	if (op) {
 		/* We only care about Namespace opcodes here */
 
-		if ((!(walk_state->op_info->flags & AML_NSOPCODE) && (walk_state->opcode != AML_INT_NAMEPATH_OP)) ||
+		if ((!(walk_state->op_info->flags & AML_NSOPCODE) &&
+			  (walk_state->opcode != AML_INT_NAMEPATH_OP)) ||
 			(!(walk_state->op_info->flags & AML_NAMED))) {
+			if ((walk_state->op_info->class == AML_CLASS_EXECUTE) ||
+				(walk_state->op_info->class == AML_CLASS_CONTROL)) {
+				ACPI_REPORT_WARNING ((
+					"Encountered executable code at module level, [%s]\n",
+					acpi_ps_get_opcode_name (walk_state->opcode)));
+			}
 			return_ACPI_STATUS (AE_OK);
 		}
 
-		/*
-		 * Get the name we are going to enter or lookup in the namespace
-		 */
+		/* Get the name we are going to enter or lookup in the namespace */
+
 		if (walk_state->opcode == AML_INT_NAMEPATH_OP) {
 			/* For Namepath op, get the path string */
 
@@ -528,21 +544,25 @@
 	case AML_INT_NAMEPATH_OP:
 
 		/*
-		 * The name_path is an object reference to an existing object. Don't enter the
-		 * name into the namespace, but look it up for use later
+		 * The name_path is an object reference to an existing object.
+		 * Don't enter the name into the namespace, but look it up
+		 * for use later.
 		 */
 		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
-				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+				  walk_state, &(node));
 		break;
 
 	case AML_SCOPE_OP:
 
 		/*
-		 * The Path is an object reference to an existing object.  Don't enter the
-		 * name into the namespace, but look it up for use later
+		 * The Path is an object reference to an existing object.
+		 * Don't enter the name into the namespace, but look it up
+		 * for use later.
 		 */
 		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
-				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+				  walk_state, &(node));
 		if (ACPI_FAILURE (status)) {
 #ifdef _ACPI_ASL_COMPILER
 			if (status == AE_NOT_FOUND) {
@@ -582,7 +602,8 @@
 			 *  Scope (DEB) { ... }
 			 */
 
-			ACPI_REPORT_WARNING (("Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
+			ACPI_REPORT_WARNING ((
+				"Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
 				buffer_ptr, acpi_ut_get_type_name (node->type)));
 
 			node->type = ACPI_TYPE_ANY;
@@ -593,7 +614,8 @@
 
 			/* All other types are an error */
 
-			ACPI_REPORT_ERROR (("Invalid type (%s) for target of Scope operator [%4.4s]\n",
+			ACPI_REPORT_ERROR ((
+				"Invalid type (%s) for target of Scope operator [%4.4s]\n",
 				acpi_ut_get_type_name (node->type), buffer_ptr));
 
 			return (AE_AML_OPERAND_TYPE);
@@ -621,8 +643,9 @@
 
 		/*
 		 * Enter the named type into the internal namespace.  We enter the name
-		 * as we go downward in the parse tree.  Any necessary subobjects that involve
-		 * arguments to the opcode must be created as we go back up the parse tree later.
+		 * as we go downward in the parse tree.  Any necessary subobjects that
+		 * involve arguments to the opcode must be created as we go back up the
+		 * parse tree later.
 		 *
 		 * Note: Name may already exist if we are executing a deferred opcode.
 		 */
@@ -635,7 +658,8 @@
 		}
 
 		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
-				  ACPI_IMODE_EXECUTE, ACPI_NS_NO_UPSEARCH, walk_state, &(node));
+				  ACPI_IMODE_EXECUTE, ACPI_NS_NO_UPSEARCH,
+				  walk_state, &(node));
 		break;
 	}
 
@@ -678,8 +702,6 @@
  * FUNCTION:    acpi_ds_load2_end_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been completed in the
- *                                walk;  Arguments have now been evaluated.
  *
  * RETURN:      Status
  *
@@ -738,7 +760,8 @@
 
 	/* Pop the scope stack */
 
-	if (acpi_ns_opens_scope (object_type) && (op->common.aml_opcode != AML_INT_METHODCALL_OP)) {
+	if (acpi_ns_opens_scope (object_type) &&
+	   (op->common.aml_opcode != AML_INT_METHODCALL_OP)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s) Popping scope for Op %p\n",
 			acpi_ut_get_type_name (object_type), op));
 
@@ -803,7 +826,7 @@
 		case AML_INDEX_FIELD_OP:
 
 			status = acpi_ds_create_index_field (op, (acpi_handle) arg->common.node,
-					   walk_state);
+					 walk_state);
 			break;
 
 		case AML_BANK_FIELD_OP:
@@ -884,14 +907,16 @@
 #ifndef ACPI_NO_METHOD_EXECUTION
 		case AML_REGION_OP:
 			/*
-			 * The op_region is not fully parsed at this time. Only valid argument is the space_id.
-			 * (We must save the address of the AML of the address and length operands)
+			 * The op_region is not fully parsed at this time. Only valid
+			 * argument is the space_id. (We must save the address of the
+			 * AML of the address and length operands)
 			 */
 			/*
 			 * If we have a valid region, initialize it
 			 * Namespace is NOT locked at this point.
 			 */
-			status = acpi_ev_initialize_region (acpi_ns_get_attached_object (node), FALSE);
+			status = acpi_ev_initialize_region (acpi_ns_get_attached_object (node),
+					 FALSE);
 			if (ACPI_FAILURE (status)) {
 				/*
 				 *  If AE_NOT_EXIST is returned, it is not fatal
@@ -942,15 +967,16 @@
 		if (ACPI_SUCCESS (status)) {
 			/*
 			 * Make sure that what we found is indeed a method
-			 * We didn't search for a method on purpose, to see if the name would resolve
+			 * We didn't search for a method on purpose, to see if the name
+			 * would resolve
 			 */
 			if (new_node->type != ACPI_TYPE_METHOD) {
 				status = AE_AML_OPERAND_TYPE;
 			}
 
-			/* We could put the returned object (Node) on the object stack for later, but
-			 * for now, we will put it in the "op" object that the parser uses, so we
-			 * can get it again at the end of this scope
+			/* We could put the returned object (Node) on the object stack for
+			 * later, but for now, we will put it in the "op" object that the
+			 * parser uses, so we can get it again at the end of this scope
 			 */
 			op->common.node = new_node;
 		}
diff -Nru a/drivers/acpi/dispatcher/dswscope.c b/drivers/acpi/dispatcher/dswscope.c
--- a/drivers/acpi/dispatcher/dswscope.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dswscope.c	2005-04-19 01:34:14 -04:00
@@ -50,14 +50,13 @@
 	 ACPI_MODULE_NAME    ("dswscope")
 
 
-#define STACK_POP(head) head
-
-
 /****************************************************************************
  *
  * FUNCTION:    acpi_ds_scope_stack_clear
  *
- * PARAMETERS:  None
+ * PARAMETERS:  walk_state      - Current state
+ *
+ * RETURN:      None
  *
  * DESCRIPTION: Pop (and free) everything on the scope stack except the
  *              root scope object (which remains at the stack top.)
@@ -80,7 +79,8 @@
 		walk_state->scope_info = scope_info->scope.next;
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-			"Popped object type (%s)\n", acpi_ut_get_type_name (scope_info->common.value)));
+			"Popped object type (%s)\n",
+			acpi_ut_get_type_name (scope_info->common.value)));
 		acpi_ut_delete_generic_state (scope_info);
 	}
 }
@@ -90,8 +90,11 @@
  *
  * FUNCTION:    acpi_ds_scope_stack_push
  *
- * PARAMETERS:  *Node,              - Name to be made current
- *              Type,               - Type of frame being pushed
+ * PARAMETERS:  Node            - Name to be made current
+ *              Type            - Type of frame being pushed
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
  *
  * DESCRIPTION: Push the current scope on the scope stack, and make the
  *              passed Node current.
@@ -121,7 +124,8 @@
 	/* Make sure object type is valid */
 
 	if (!acpi_ut_valid_object_type (type)) {
-		ACPI_REPORT_WARNING (("ds_scope_stack_push: Invalid object type: 0x%X\n", type));
+		ACPI_REPORT_WARNING ((
+			"ds_scope_stack_push: Invalid object type: 0x%X\n", type));
 	}
 
 	/* Allocate a new scope object */
@@ -170,16 +174,11 @@
  *
  * FUNCTION:    acpi_ds_scope_stack_pop
  *
- * PARAMETERS:  Type                - The type of frame to be found
+ * PARAMETERS:  walk_state      - Current state
  *
- * DESCRIPTION: Pop the scope stack until a frame of the requested type
- *              is found.
+ * RETURN:      Status
  *
- * RETURN:      Count of frames popped.  If no frame of the requested type
- *              was found, the count is returned as a negative number and
- *              the scope stack is emptied (which sets the current scope
- *              to the root).  If the scope stack was empty at entry, the
- *              function is a no-op and returns 0.
+ * DESCRIPTION: Pop the scope stack once.
  *
  ***************************************************************************/
 
diff -Nru a/drivers/acpi/dispatcher/dswstate.c b/drivers/acpi/dispatcher/dswstate.c
--- a/drivers/acpi/dispatcher/dswstate.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/dispatcher/dswstate.c	2005-04-19 01:34:14 -04:00
@@ -50,67 +50,31 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dswstate")
 
+/* Local prototypes */
 
-#ifdef ACPI_FUTURE_USAGE
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ds_result_insert
- *
- * PARAMETERS:  Object              - Object to push
- *              Index               - Where to insert the object
- *              walk_state          - Current Walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Insert an object onto this walk's result stack
- *
- ******************************************************************************/
-
+#ifdef ACPI_OBSOLETE_FUNCTIONS
 acpi_status
 acpi_ds_result_insert (
 	void                            *object,
 	u32                             index,
-	struct acpi_walk_state          *walk_state)
-{
-	union acpi_generic_state        *state;
-
+	struct acpi_walk_state          *walk_state);
 
-	ACPI_FUNCTION_NAME ("ds_result_insert");
-
-
-	state = walk_state->results;
-	if (!state) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result object pushed! State=%p\n",
-			walk_state));
-		return (AE_NOT_EXIST);
-	}
-
-	if (index >= ACPI_OBJ_NUM_OPERANDS) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Index out of range: %X Obj=%p State=%p Num=%X\n",
-			index, object, walk_state, state->results.num_results));
-		return (AE_BAD_PARAMETER);
-	}
-
-	if (!object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Null Object! Index=%X Obj=%p State=%p Num=%X\n",
-			index, object, walk_state, state->results.num_results));
-		return (AE_BAD_PARAMETER);
-	}
-
-	state->results.obj_desc [index] = object;
-	state->results.num_results++;
+acpi_status
+acpi_ds_obj_stack_delete_all (
+	struct acpi_walk_state          *walk_state);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-		"Obj=%p [%s] State=%p Num=%X Cur=%X\n",
-		object, object ? acpi_ut_get_object_type_name ((union acpi_operand_object *) object) : "NULL",
-		walk_state, state->results.num_results, walk_state->current_result));
+acpi_status
+acpi_ds_obj_stack_pop_object (
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state);
 
-	return (AE_OK);
-}
+void *
+acpi_ds_obj_stack_get_value (
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+#endif
 
+#ifdef ACPI_FUTURE_USAGE
 
 /*******************************************************************************
  *
@@ -178,7 +142,6 @@
 
 #endif  /*  ACPI_FUTURE_USAGE  */
 
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_result_pop
@@ -227,15 +190,18 @@
 			*object = state->results.obj_desc [index -1];
 			state->results.obj_desc [index -1] = NULL;
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] Index=%X State=%p Num=%X\n",
-				*object, (*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+				"Obj=%p [%s] Index=%X State=%p Num=%X\n",
+				*object,
+				(*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
 				(u32) index -1, walk_state, state->results.num_results));
 
 			return (AE_OK);
 		}
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result objects! State=%p\n", walk_state));
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+		"No result objects! State=%p\n", walk_state));
 	return (AE_AML_NO_RETURN_VALUE);
 }
 
@@ -274,7 +240,8 @@
 	}
 
 	if (!state->results.num_results) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result objects! State=%p\n", walk_state));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result objects! State=%p\n",
+			walk_state));
 		return (AE_AML_NO_RETURN_VALUE);
 	}
 
@@ -293,7 +260,8 @@
 	/* Check for a valid result object */
 
 	if (!*object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null operand! State=%p #Ops=%X, Index=%X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Null operand! State=%p #Ops=%X, Index=%X\n",
 			walk_state, state->results.num_results, (u32) index));
 		return (AE_AML_NO_RETURN_VALUE);
 	}
@@ -344,7 +312,8 @@
 	}
 
 	if (!object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null Object! Obj=%p State=%p Num=%X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Null Object! Obj=%p State=%p Num=%X\n",
 			object, walk_state, state->results.num_results));
 		return (AE_BAD_PARAMETER);
 	}
@@ -439,43 +408,6 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ds_obj_stack_delete_all
- *
- * PARAMETERS:  walk_state          - Current Walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Clear the object stack by deleting all objects that are on it.
- *              Should be used with great care, if at all!
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ds_obj_stack_delete_all (
-	struct acpi_walk_state          *walk_state)
-{
-	u32                             i;
-
-
-	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_delete_all", walk_state);
-
-
-	/* The stack size is configurable, but fixed */
-
-	for (i = 0; i < ACPI_OBJ_NUM_OPERANDS; i++) {
-		if (walk_state->operands[i]) {
-			acpi_ut_remove_reference (walk_state->operands[i]);
-			walk_state->operands[i] = NULL;
-		}
-	}
-
-	return_ACPI_STATUS (AE_OK);
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ds_obj_stack_push
  *
  * PARAMETERS:  Object              - Object to push
@@ -517,67 +449,6 @@
 }
 
 
-#if 0
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ds_obj_stack_pop_object
- *
- * PARAMETERS:  pop_count           - Number of objects/entries to pop
- *              walk_state          - Current Walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Pop this walk's object stack.  Objects on the stack are NOT
- *              deleted by this routine.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ds_obj_stack_pop_object (
-	union acpi_operand_object       **object,
-	struct acpi_walk_state          *walk_state)
-{
-	ACPI_FUNCTION_NAME ("ds_obj_stack_pop_object");
-
-
-	/* Check for stack underflow */
-
-	if (walk_state->num_operands == 0) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Missing operand/stack empty! State=%p #Ops=%X\n",
-			walk_state, walk_state->num_operands));
-		*object = NULL;
-		return (AE_AML_NO_OPERAND);
-	}
-
-	/* Pop the stack */
-
-	walk_state->num_operands--;
-
-	/* Check for a valid operand */
-
-	if (!walk_state->operands [walk_state->num_operands]) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Null operand! State=%p #Ops=%X\n",
-			walk_state, walk_state->num_operands));
-		*object = NULL;
-		return (AE_AML_NO_OPERAND);
-	}
-
-	/* Get operand and set stack entry to null */
-
-	*object = walk_state->operands [walk_state->num_operands];
-	walk_state->operands [walk_state->num_operands] = NULL;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] State=%p #Ops=%X\n",
-			  *object, acpi_ut_get_object_type_name (*object),
-			  walk_state, walk_state->num_operands));
-
-	return (AE_OK);
-}
-#endif
-
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_obj_stack_pop
@@ -680,48 +551,6 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ds_obj_stack_get_value
- *
- * PARAMETERS:  Index               - Stack index whose value is desired.  Based
- *                                    on the top of the stack (index=0 == top)
- *              walk_state          - Current Walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Retrieve an object from this walk's object stack.  Index must
- *              be within the range of the current stack pointer.
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-void *
-acpi_ds_obj_stack_get_value (
-	u32                             index,
-	struct acpi_walk_state          *walk_state)
-{
-
-	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_get_value", walk_state);
-
-
-	/* Can't do it if the stack is empty */
-
-	if (walk_state->num_operands == 0) {
-		return_PTR (NULL);
-	}
-
-	/* or if the index is past the top of the stack */
-
-	if (index > (walk_state->num_operands - (u32) 1)) {
-		return_PTR (NULL);
-	}
-
-	return_PTR (walk_state->operands[(acpi_native_uint)(walk_state->num_operands - 1) -
-			  index]);
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ds_get_current_walk_state
  *
  * PARAMETERS:  Thread          - Get current active state for this Thread
@@ -757,11 +586,11 @@
  * FUNCTION:    acpi_ds_push_walk_state
  *
  * PARAMETERS:  walk_state      - State to push
- *              walk_list       - The list that owns the walk stack
+ *              Thread          - Thread state object
  *
  * RETURN:      None
  *
- * DESCRIPTION: Place the walk_state at the head of the state list.
+ * DESCRIPTION: Place the Thread state at the head of the state list.
  *
  ******************************************************************************/
 
@@ -784,9 +613,9 @@
  *
  * FUNCTION:    acpi_ds_pop_walk_state
  *
- * PARAMETERS:  walk_list       - The list that owns the walk stack
+ * PARAMETERS:  Thread      - Current thread state
  *
- * RETURN:      A walk_state object popped from the stack
+ * RETURN:      A walk_state object popped from the thread's stack
  *
  * DESCRIPTION: Remove and return the walkstate object that is at the head of
  *              the walk stack for the given walk list.  NULL indicates that
@@ -814,7 +643,7 @@
 		/*
 		 * Don't clear the NEXT field, this serves as an indicator
 		 * that there is a parent WALK STATE
-		 *     NO: walk_state->Next = NULL;
+		 * Do Not: walk_state->Next = NULL;
 		 */
 	}
 
@@ -826,7 +655,9 @@
  *
  * FUNCTION:    acpi_ds_create_walk_state
  *
- * PARAMETERS:  Origin          - Starting point for this walk
+ * PARAMETERS:  owner_id        - ID for object creation
+ *              Origin          - Starting point for this walk
+ *              mth_desc        - Method object
  *              Thread          - Current thread state
  *
  * RETURN:      Pointer to the new walk state.
@@ -896,8 +727,7 @@
  *              method_node     - Control method NS node, if any
  *              aml_start       - Start of AML
  *              aml_length      - Length of AML
- *              Params          - Method args, if any
- *              return_obj_desc - Where to store a return object, if any
+ *              Info            - Method info block (params, etc.)
  *              pass_number     - 1, 2, or 3
  *
  * RETURN:      Status
@@ -931,7 +761,7 @@
 
 	/* The next_op of the next_walk will be the beginning of the method */
 
-	walk_state->next_op             = NULL;
+	walk_state->next_op = NULL;
 
 	if (info) {
 		if (info->parameter_type == ACPI_PARAM_GPE) {
@@ -939,8 +769,8 @@
 					   info->parameters);
 		}
 		else {
-			walk_state->params              = info->parameters;
-			walk_state->caller_return_desc  = &info->return_object;
+			walk_state->params          = info->parameters;
+			walk_state->caller_return_desc = &info->return_object;
 		}
 	}
 
@@ -964,7 +794,8 @@
 
 		/* Init the method arguments */
 
-		status = acpi_ds_method_data_init_args (walk_state->params, ACPI_METHOD_NUM_ARGS, walk_state);
+		status = acpi_ds_method_data_init_args (walk_state->params,
+				 ACPI_METHOD_NUM_ARGS, walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -1031,12 +862,14 @@
 	}
 
 	if (walk_state->data_type != ACPI_DESC_TYPE_WALK) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p is not a valid walk state\n", walk_state));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p is not a valid walk state\n",
+			walk_state));
 		return;
 	}
 
 	if (walk_state->parser_state.scope) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p walk still has a scope list\n", walk_state));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p walk still has a scope list\n",
+			walk_state));
 	}
 
 	/* Always must free any linked control states */
@@ -1078,7 +911,7 @@
  *
  * PARAMETERS:  None
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Purge the global state object cache.  Used during subsystem
  *              termination.
@@ -1094,6 +927,203 @@
 
 	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_WALK);
 	return_VOID;
+}
+#endif
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_result_insert
+ *
+ * PARAMETERS:  Object              - Object to push
+ *              Index               - Where to insert the object
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Insert an object onto this walk's result stack
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_result_insert (
+	void                            *object,
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
+{
+	union acpi_generic_state        *state;
+
+
+	ACPI_FUNCTION_NAME ("ds_result_insert");
+
+
+	state = walk_state->results;
+	if (!state) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result object pushed! State=%p\n",
+			walk_state));
+		return (AE_NOT_EXIST);
+	}
+
+	if (index >= ACPI_OBJ_NUM_OPERANDS) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Index out of range: %X Obj=%p State=%p Num=%X\n",
+			index, object, walk_state, state->results.num_results));
+		return (AE_BAD_PARAMETER);
+	}
+
+	if (!object) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Null Object! Index=%X Obj=%p State=%p Num=%X\n",
+			index, object, walk_state, state->results.num_results));
+		return (AE_BAD_PARAMETER);
+	}
+
+	state->results.obj_desc [index] = object;
+	state->results.num_results++;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+		"Obj=%p [%s] State=%p Num=%X Cur=%X\n",
+		object, object ? acpi_ut_get_object_type_name ((union acpi_operand_object *) object) : "NULL",
+		walk_state, state->results.num_results, walk_state->current_result));
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_delete_all
+ *
+ * PARAMETERS:  walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear the object stack by deleting all objects that are on it.
+ *              Should be used with great care, if at all!
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_obj_stack_delete_all (
+	struct acpi_walk_state          *walk_state)
+{
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_delete_all", walk_state);
+
+
+	/* The stack size is configurable, but fixed */
+
+	for (i = 0; i < ACPI_OBJ_NUM_OPERANDS; i++) {
+		if (walk_state->operands[i]) {
+			acpi_ut_remove_reference (walk_state->operands[i]);
+			walk_state->operands[i] = NULL;
+		}
+	}
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_pop_object
+ *
+ * PARAMETERS:  Object              - Where to return the popped object
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Pop this walk's object stack.  Objects on the stack are NOT
+ *              deleted by this routine.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_obj_stack_pop_object (
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state)
+{
+	ACPI_FUNCTION_NAME ("ds_obj_stack_pop_object");
+
+
+	/* Check for stack underflow */
+
+	if (walk_state->num_operands == 0) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Missing operand/stack empty! State=%p #Ops=%X\n",
+			walk_state, walk_state->num_operands));
+		*object = NULL;
+		return (AE_AML_NO_OPERAND);
+	}
+
+	/* Pop the stack */
+
+	walk_state->num_operands--;
+
+	/* Check for a valid operand */
+
+	if (!walk_state->operands [walk_state->num_operands]) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Null operand! State=%p #Ops=%X\n",
+			walk_state, walk_state->num_operands));
+		*object = NULL;
+		return (AE_AML_NO_OPERAND);
+	}
+
+	/* Get operand and set stack entry to null */
+
+	*object = walk_state->operands [walk_state->num_operands];
+	walk_state->operands [walk_state->num_operands] = NULL;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] State=%p #Ops=%X\n",
+			  *object, acpi_ut_get_object_type_name (*object),
+			  walk_state, walk_state->num_operands));
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_get_value
+ *
+ * PARAMETERS:  Index               - Stack index whose value is desired.  Based
+ *                                    on the top of the stack (index=0 == top)
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Pointer to the requested operand
+ *
+ * DESCRIPTION: Retrieve an object from this walk's operand stack.  Index must
+ *              be within the range of the current stack pointer.
+ *
+ ******************************************************************************/
+
+void *
+acpi_ds_obj_stack_get_value (
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
+{
+
+	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_get_value", walk_state);
+
+
+	/* Can't do it if the stack is empty */
+
+	if (walk_state->num_operands == 0) {
+		return_PTR (NULL);
+	}
+
+	/* or if the index is past the top of the stack */
+
+	if (index > (walk_state->num_operands - (u32) 1)) {
+		return_PTR (NULL);
+	}
+
+	return_PTR (walk_state->operands[(acpi_native_uint)(walk_state->num_operands - 1) -
+			  index]);
 }
 #endif
 
diff -Nru a/drivers/acpi/events/evevent.c b/drivers/acpi/events/evevent.c
--- a/drivers/acpi/events/evevent.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evevent.c	2005-04-19 01:34:14 -04:00
@@ -47,6 +47,16 @@
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evevent")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ev_fixed_event_initialize (
+	void);
+
+static u32
+acpi_ev_fixed_event_dispatch (
+	u32                             event);
+
 
 /*******************************************************************************
  *
@@ -56,7 +66,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize global data structures for events.
+ * DESCRIPTION: Initialize global data structures for ACPI events (Fixed, GPE)
  *
  ******************************************************************************/
 
@@ -78,9 +88,9 @@
 	}
 
 	/*
-	 * Initialize the Fixed and General Purpose Events. This is
-	 * done prior to enabling SCIs to prevent interrupts from
-	 * occurring before handers are installed.
+	 * Initialize the Fixed and General Purpose Events. This is done prior to
+	 * enabling SCIs to prevent interrupts from occurring before the handlers are
+	 * installed.
 	 */
 	status = acpi_ev_fixed_event_initialize ();
 	if (ACPI_FAILURE (status)) {
@@ -161,7 +171,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ev_fixed_event_initialize (
 	void)
 {
@@ -180,7 +190,8 @@
 		/* Enable the fixed event */
 
 		if (acpi_gbl_fixed_event_info[i].enable_register_id != 0xFF) {
-			status = acpi_set_register (acpi_gbl_fixed_event_info[i].enable_register_id,
+			status = acpi_set_register (
+					 acpi_gbl_fixed_event_info[i].enable_register_id,
 					 0, ACPI_MTX_LOCK);
 			if (ACPI_FAILURE (status)) {
 				return (status);
@@ -200,7 +211,7 @@
  *
  * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
  *
- * DESCRIPTION: Checks the PM status register for fixed events
+ * DESCRIPTION: Checks the PM status register for active fixed events
  *
  ******************************************************************************/
 
@@ -221,8 +232,10 @@
 	 * Read the fixed feature status and enable registers, as all the cases
 	 * depend on their values.  Ignore errors here.
 	 */
-	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS, &fixed_status);
-	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_ENABLE, &fixed_enable);
+	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS,
+			 &fixed_status);
+	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_ENABLE,
+			 &fixed_enable);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
 		"Fixed Event Block: Enable %08X Status %08X\n",
@@ -259,7 +272,7 @@
  *
  ******************************************************************************/
 
-u32
+static u32
 acpi_ev_fixed_event_dispatch (
 	u32                             event)
 {
diff -Nru a/drivers/acpi/events/evgpe.c b/drivers/acpi/events/evgpe.c
--- a/drivers/acpi/events/evgpe.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evgpe.c	2005-04-19 01:34:14 -04:00
@@ -48,6 +48,12 @@
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evgpe")
 
+/* Local prototypes */
+
+static void ACPI_SYSTEM_XFACE
+acpi_ev_asynch_execute_gpe_method (
+	void                            *context);
+
 
 /*******************************************************************************
  *
@@ -335,8 +341,10 @@
 			gpe_block = acpi_gbl_gpe_fadt_blocks[i];
 			if (gpe_block) {
 				if ((gpe_number >= gpe_block->block_base_number) &&
-					(gpe_number < gpe_block->block_base_number + (gpe_block->register_count * 8))) {
-					return (&gpe_block->event_info[gpe_number - gpe_block->block_base_number]);
+					(gpe_number < gpe_block->block_base_number +
+						(gpe_block->register_count * 8))) {
+					return (&gpe_block->event_info[gpe_number -
+						gpe_block->block_base_number]);
 				}
 			}
 		}
@@ -437,7 +445,7 @@
 				"Read GPE Register at GPE%X: Status=%02X, Enable=%02X\n",
 				gpe_register_info->base_gpe_number, status_reg, enable_reg));
 
-			/* First check if there is anything active at all in this register */
+			/* Check if there is anything active at all in this register */
 
 			enabled_status_byte = (u8) (status_reg & enable_reg);
 			if (!enabled_status_byte) {
@@ -457,8 +465,8 @@
 					 * or method.
 					 */
 					int_status |= acpi_ev_gpe_dispatch (
-							  &gpe_block->event_info[(i * ACPI_GPE_REGISTER_WIDTH) + j],
-							  (u32) j + gpe_register_info->base_gpe_number);
+						&gpe_block->event_info[(i * ACPI_GPE_REGISTER_WIDTH) + j],
+						(u32) j + gpe_register_info->base_gpe_number);
 				}
 			}
 		}
@@ -523,7 +531,8 @@
 	 * Take a snapshot of the GPE info for this level - we copy the
 	 * info to prevent a race condition with remove_handler/remove_block.
 	 */
-	ACPI_MEMCPY (&local_gpe_event_info, gpe_event_info, sizeof (struct acpi_gpe_event_info));
+	ACPI_MEMCPY (&local_gpe_event_info, gpe_event_info,
+		sizeof (struct acpi_gpe_event_info));
 
 	status = acpi_ut_release_mutex (ACPI_MTX_EVENTS);
 	if (ACPI_FAILURE (status)) {
@@ -534,7 +543,8 @@
 	 * Must check for control method type dispatch one more
 	 * time to avoid race with ev_gpe_install_handler
 	 */
-	if ((local_gpe_event_info.flags & ACPI_GPE_DISPATCH_MASK) == ACPI_GPE_DISPATCH_METHOD) {
+	if ((local_gpe_event_info.flags & ACPI_GPE_DISPATCH_MASK) ==
+			ACPI_GPE_DISPATCH_METHOD) {
 		/*
 		 * Invoke the GPE Method (_Lxx, _Exx) i.e., evaluate the _Lxx/_Exx
 		 * control method that corresponds to this GPE
@@ -553,7 +563,8 @@
 		}
 	}
 
-	if ((local_gpe_event_info.flags & ACPI_GPE_XRUPT_TYPE_MASK) == ACPI_GPE_LEVEL_TRIGGERED) {
+	if ((local_gpe_event_info.flags & ACPI_GPE_XRUPT_TYPE_MASK) ==
+			ACPI_GPE_LEVEL_TRIGGERED) {
 		/*
 		 * GPE is level-triggered, we clear the GPE status bit after
 		 * handling the event.
@@ -575,7 +586,7 @@
  *
  * FUNCTION:    acpi_ev_gpe_dispatch
  *
- * PARAMETERS:  gpe_event_info  - info for this GPE
+ * PARAMETERS:  gpe_event_info  - Info for this GPE
  *              gpe_number      - Number relative to the parent GPE block
  *
  * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
@@ -602,10 +613,12 @@
 	 * If edge-triggered, clear the GPE status bit now.  Note that
 	 * level-triggered events are cleared after the GPE is serviced.
 	 */
-	if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) == ACPI_GPE_EDGE_TRIGGERED) {
+	if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==
+			ACPI_GPE_EDGE_TRIGGERED) {
 		status = acpi_hw_clear_gpe (gpe_event_info);
 		if (ACPI_FAILURE (status)) {
-			ACPI_REPORT_ERROR (("acpi_ev_gpe_dispatch: %s, Unable to clear GPE[%2X]\n",
+			ACPI_REPORT_ERROR ((
+				"acpi_ev_gpe_dispatch: %s, Unable to clear GPE[%2X]\n",
 				acpi_format_exception (status), gpe_number));
 			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
 		}
@@ -639,7 +652,8 @@
 
 		/* It is now safe to clear level-triggered events. */
 
-		if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) == ACPI_GPE_LEVEL_TRIGGERED) {
+		if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==
+				ACPI_GPE_LEVEL_TRIGGERED) {
 			status = acpi_hw_clear_gpe (gpe_event_info);
 			if (ACPI_FAILURE (status)) {
 				ACPI_REPORT_ERROR ((
@@ -704,7 +718,6 @@
 
 
 #ifdef ACPI_GPE_NOTIFY_CHECK
-
 /*******************************************************************************
  * TBD: NOT USED, PROTOTYPE ONLY AND WILL PROBABLY BE REMOVED
  *
diff -Nru a/drivers/acpi/events/evgpeblk.c b/drivers/acpi/events/evgpeblk.c
--- a/drivers/acpi/events/evgpeblk.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evgpeblk.c	2005-04-19 01:34:14 -04:00
@@ -48,6 +48,39 @@
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evgpeblk")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ev_save_method_info (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *obj_desc,
+	void                            **return_value);
+
+static acpi_status
+acpi_ev_match_prw_and_gpe (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *info,
+	void                            **return_value);
+
+static struct acpi_gpe_xrupt_info *
+acpi_ev_get_gpe_xrupt_block (
+	u32                             interrupt_level);
+
+static acpi_status
+acpi_ev_delete_gpe_xrupt (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt);
+
+static acpi_status
+acpi_ev_install_gpe_block (
+	struct acpi_gpe_block_info      *gpe_block,
+	u32                             interrupt_level);
+
+static acpi_status
+acpi_ev_create_gpe_info_blocks (
+	struct acpi_gpe_block_info      *gpe_block);
+
 
 /*******************************************************************************
  *
@@ -155,7 +188,7 @@
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ev_delete_gpe_handlers
  *
@@ -190,7 +223,8 @@
 		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
 			gpe_event_info = &gpe_block->event_info[(i * ACPI_GPE_REGISTER_WIDTH) + j];
 
-			if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) == ACPI_GPE_DISPATCH_HANDLER) {
+			if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+					ACPI_GPE_DISPATCH_HANDLER) {
 				ACPI_MEM_FREE (gpe_event_info->dispatch.handler);
 				gpe_event_info->dispatch.handler = NULL;
 				gpe_event_info->flags &= ~ACPI_GPE_DISPATCH_MASK;
@@ -471,7 +505,7 @@
 	ACPI_FUNCTION_TRACE ("ev_get_gpe_xrupt_block");
 
 
-	/* No need for spin lock since we are not changing any list elements here */
+	/* No need for lock since we are not changing any list elements here */
 
 	next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
 	while (next_gpe_xrupt) {
@@ -619,7 +653,7 @@
 		goto unlock_and_exit;
 	}
 
-	/* Install the new block at the end of the list for this interrupt with lock */
+	/* Install the new block at the end of the list with lock */
 
 	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
 	if (gpe_xrupt_block->gpe_block_list_head) {
@@ -756,10 +790,12 @@
 	 * per register.  Initialization to zeros is sufficient.
 	 */
 	gpe_event_info = ACPI_MEM_CALLOCATE (
-			   ((acpi_size) gpe_block->register_count * ACPI_GPE_REGISTER_WIDTH) *
+			   ((acpi_size) gpe_block->register_count *
+			   ACPI_GPE_REGISTER_WIDTH) *
 			   sizeof (struct acpi_gpe_event_info));
 	if (!gpe_event_info) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not allocate the gpe_event_info table\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Could not allocate the gpe_event_info table\n"));
 		status = AE_NO_MEMORY;
 		goto error_exit;
 	}
@@ -899,7 +935,8 @@
 	gpe_block->block_base_number = gpe_block_base_number;
 	gpe_block->node           = gpe_device;
 
-	ACPI_MEMCPY (&gpe_block->block_address, gpe_block_address, sizeof (struct acpi_generic_address));
+	ACPI_MEMCPY (&gpe_block->block_address, gpe_block_address,
+		sizeof (struct acpi_generic_address));
 
 	/* Create the register_info and event_info sub-structures */
 
@@ -1061,8 +1098,9 @@
 
 		/* Install GPE Block 0 */
 
-		status = acpi_ev_create_gpe_block (acpi_gbl_fadt_gpe_device, &acpi_gbl_FADT->xgpe0_blk,
-				 register_count0, 0, acpi_gbl_FADT->sci_int, &acpi_gbl_gpe_fadt_blocks[0]);
+		status = acpi_ev_create_gpe_block (acpi_gbl_fadt_gpe_device,
+				 &acpi_gbl_FADT->xgpe0_blk, register_count0, 0,
+				 acpi_gbl_FADT->sci_int, &acpi_gbl_gpe_fadt_blocks[0]);
 
 		if (ACPI_FAILURE (status)) {
 			ACPI_REPORT_ERROR ((
@@ -1094,8 +1132,9 @@
 		else {
 			/* Install GPE Block 1 */
 
-			status = acpi_ev_create_gpe_block (acpi_gbl_fadt_gpe_device, &acpi_gbl_FADT->xgpe1_blk,
-					 register_count1, acpi_gbl_FADT->gpe1_base,
+			status = acpi_ev_create_gpe_block (acpi_gbl_fadt_gpe_device,
+					 &acpi_gbl_FADT->xgpe1_blk, register_count1,
+					 acpi_gbl_FADT->gpe1_base,
 					 acpi_gbl_FADT->sci_int, &acpi_gbl_gpe_fadt_blocks[1]);
 
 			if (ACPI_FAILURE (status)) {
@@ -1109,7 +1148,7 @@
 			 * space. However, GPE0 always starts at GPE number zero.
 			 */
 			gpe_number_max = acpi_gbl_FADT->gpe1_base +
-					   ((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);
+					  ((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);
 		}
 	}
 
diff -Nru a/drivers/acpi/events/evmisc.c b/drivers/acpi/events/evmisc.c
--- a/drivers/acpi/events/evmisc.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evmisc.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,35 @@
 	 ACPI_MODULE_NAME    ("evmisc")
 
 
+#ifdef ACPI_DEBUG_OUTPUT
+static const char                *acpi_notify_value_names[] =
+{
+	"Bus Check",
+	"Device Check",
+	"Device Wake",
+	"Eject request",
+	"Device Check Light",
+	"Frequency Mismatch",
+	"Bus Mode Mismatch",
+	"Power Fault"
+};
+#endif
+
+/* Local prototypes */
+
+static void ACPI_SYSTEM_XFACE
+acpi_ev_notify_dispatch (
+	void                            *context);
+
+static void ACPI_SYSTEM_XFACE
+acpi_ev_global_lock_thread (
+	void                            *context);
+
+static u32
+acpi_ev_global_lock_handler (
+	void                            *context);
+
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_is_notify_object
@@ -98,20 +127,6 @@
  *
  ******************************************************************************/
 
-#ifdef ACPI_DEBUG_OUTPUT
-static const char                *acpi_notify_value_names[] =
-{
-	"Bus Check",
-	"Device Check",
-	"Device Wake",
-	"Eject request",
-	"Device Check Light",
-	"Frequency Mismatch",
-	"Bus Mode Mismatch",
-	"Power Fault"
-};
-#endif
-
 acpi_status
 acpi_ev_queue_notify_request (
 	struct acpi_namespace_node      *node,
@@ -128,9 +143,10 @@
 
 	/*
 	 * For value 3 (Ejection Request), some device method may need to be run.
-	 * For value 2 (Device Wake) if _PRW exists, the _PS0 method may need to be run.
+	 * For value 2 (Device Wake) if _PRW exists, the _PS0 method may need
+	 *   to be run.
 	 * For value 0x80 (Status Change) on the power button or sleep button,
-	 * initiate soft-off or sleep operation?
+	 *   initiate soft-off or sleep operation?
 	 */
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 		"Dispatching Notify(%X) on node %p\n", notify_value, node));
@@ -140,8 +156,9 @@
 				acpi_notify_value_names[notify_value]));
 	}
 	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Notify value: 0x%2.2X **Device Specific**\n",
-				notify_value));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			"Notify value: 0x%2.2X **Device Specific**\n",
+			notify_value));
 	}
 
 	/* Get the notify object attached to the NS Node */
@@ -210,7 +227,7 @@
  *
  * FUNCTION:    acpi_ev_notify_dispatch
  *
- * PARAMETERS:  Context         - To be passsed to the notify handler
+ * PARAMETERS:  Context         - To be passed to the notify handler
  *
  * RETURN:      None.
  *
@@ -219,7 +236,7 @@
  *
  ******************************************************************************/
 
-void ACPI_SYSTEM_XFACE
+static void ACPI_SYSTEM_XFACE
 acpi_ev_notify_dispatch (
 	void                            *context)
 {
@@ -234,7 +251,8 @@
 
 	/*
 	 * We will invoke a global notify handler if installed.
-	 * This is done _before_ we invoke the per-device handler attached to the device.
+	 * This is done _before_ we invoke the per-device handler attached
+	 * to the device.
 	 */
 	if (notify_info->notify.value <= ACPI_MAX_SYS_NOTIFY) {
 		/* Global system notification handler */
@@ -256,15 +274,17 @@
 	/* Invoke the system handler first, if present */
 
 	if (global_handler) {
-		global_handler (notify_info->notify.node, notify_info->notify.value, global_context);
+		global_handler (notify_info->notify.node, notify_info->notify.value,
+			global_context);
 	}
 
 	/* Now invoke the per-device handler, if present */
 
 	handler_obj = notify_info->notify.handler_obj;
 	if (handler_obj) {
-		handler_obj->notify.handler (notify_info->notify.node, notify_info->notify.value,
-				  handler_obj->notify.context);
+		handler_obj->notify.handler (notify_info->notify.node,
+			notify_info->notify.value,
+			handler_obj->notify.context);
 	}
 
 	/* All done with the info object */
@@ -370,7 +390,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ev_init_global_lock_handler (void)
+acpi_ev_init_global_lock_handler (
+	void)
 {
 	acpi_status                     status;
 
@@ -380,7 +401,7 @@
 
 	acpi_gbl_global_lock_present = TRUE;
 	status = acpi_install_fixed_event_handler (ACPI_EVENT_GLOBAL,
-			  acpi_ev_global_lock_handler, NULL);
+			 acpi_ev_global_lock_handler, NULL);
 
 	/*
 	 * If the global lock does not exist on this platform, the attempt
@@ -433,8 +454,10 @@
 
 	acpi_gbl_global_lock_thread_count++;
 
-	/* If we (OS side vs. BIOS side) have the hardware lock already, we are done */
-
+	/*
+	 * If we (OS side vs. BIOS side) have the hardware lock already,
+	 * we are done
+	 */
 	if (acpi_gbl_global_lock_acquired) {
 		return_ACPI_STATUS (AE_OK);
 	}
@@ -480,7 +503,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ev_release_global_lock (void)
+acpi_ev_release_global_lock (
+	void)
 {
 	u8                              pending = FALSE;
 	acpi_status                     status = AE_OK;
@@ -490,7 +514,8 @@
 
 
 	if (!acpi_gbl_global_lock_thread_count) {
-		ACPI_REPORT_WARNING(("Cannot release HW Global Lock, it has not been acquired\n"));
+		ACPI_REPORT_WARNING((
+			"Cannot release HW Global Lock, it has not been acquired\n"));
 		return_ACPI_STATUS (AE_NOT_ACQUIRED);
 	}
 
@@ -515,7 +540,8 @@
 	 * register
 	 */
 	if (pending) {
-		status = acpi_set_register (ACPI_BITREG_GLOBAL_LOCK_RELEASE, 1, ACPI_MTX_LOCK);
+		status = acpi_set_register (ACPI_BITREG_GLOBAL_LOCK_RELEASE,
+				 1, ACPI_MTX_LOCK);
 	}
 
 	return_ACPI_STATUS (status);
@@ -535,7 +561,8 @@
  ******************************************************************************/
 
 void
-acpi_ev_terminate (void)
+acpi_ev_terminate (
+	void)
 {
 	acpi_native_uint                i;
 	acpi_status                     status;
@@ -555,7 +582,8 @@
 		for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
 			status = acpi_disable_event ((u32) i, 0);
 			if (ACPI_FAILURE (status)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not disable fixed event %d\n", (u32) i));
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Could not disable fixed event %d\n", (u32) i));
 			}
 		}
 
@@ -567,7 +595,8 @@
 
 		status = acpi_ev_remove_sci_handler ();
 		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not remove SCI handler\n"));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not remove SCI handler\n"));
 		}
 	}
 
diff -Nru a/drivers/acpi/events/evregion.c b/drivers/acpi/events/evregion.c
--- a/drivers/acpi/events/evregion.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evregion.c	2005-04-19 01:34:14 -04:00
@@ -58,6 +58,22 @@
 			 ACPI_ADR_SPACE_PCI_CONFIG,
 			 ACPI_ADR_SPACE_DATA_TABLE};
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ev_reg_run (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+static acpi_status
+acpi_ev_install_handler (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
 
 /*******************************************************************************
  *
@@ -179,8 +195,8 @@
  *
  * FUNCTION:    acpi_ev_execute_reg_method
  *
- * PARAMETERS:  region_obj          - Object structure
- *              Function            - Passed to _REG:  On (1) or Off (0)
+ * PARAMETERS:  region_obj          - Region object
+ *              Function            - Passed to _REG: On (1) or Off (0)
  *
  * RETURN:      Status
  *
@@ -323,14 +339,16 @@
 		if (!region_setup) {
 			/* No initialization routine, exit with error */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No init routine for region(%p) [%s]\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"No init routine for region(%p) [%s]\n",
 				region_obj, acpi_ut_get_region_name (region_obj->region.space_id)));
 			return_ACPI_STATUS (AE_NOT_EXIST);
 		}
 
 		/*
-		 * We must exit the interpreter because the region setup will potentially
-		 * execute control methods (e.g., _REG method for this region)
+		 * We must exit the interpreter because the region
+		 * setup will potentially execute control methods
+		 * (e.g., _REG method for this region)
 		 */
 		acpi_ex_exit_interpreter ();
 
@@ -621,7 +639,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ev_install_handler (
 	acpi_handle                     obj_handle,
 	u32                             level,
@@ -848,7 +866,8 @@
 				if (handler_obj->address_space.handler == handler) {
 					/*
 					 * It is (relatively) OK to attempt to install the SAME
-					 * handler twice. This can easily happen with PCI_Config space.
+					 * handler twice. This can easily happen
+					 * with PCI_Config space.
 					 */
 					status = AE_SAME_HANDLER;
 					goto unlock_and_exit;
@@ -1011,7 +1030,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ev_reg_run (
 	acpi_handle                     obj_handle,
 	u32                             level,
diff -Nru a/drivers/acpi/events/evrgnini.c b/drivers/acpi/events/evrgnini.c
--- a/drivers/acpi/events/evrgnini.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evrgnini.c	2005-04-19 01:34:14 -04:00
@@ -61,7 +61,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling, a nop for now
+ * DESCRIPTION: Setup a system_memory operation region
  *
  ******************************************************************************/
 
@@ -115,7 +115,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Setup a IO operation region
  *
  ******************************************************************************/
 
@@ -144,14 +144,14 @@
  *
  * FUNCTION:    acpi_ev_pci_config_region_setup
  *
- * PARAMETERS:  Handle             - Region we are interested in
+ * PARAMETERS:  Handle              - Region we are interested in
  *              Function            - Start or stop
  *              handler_context     - Address space handler context
  *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Setup a PCI_Config operation region
  *
  * MUTEX:       Assumes namespace is not locked
  *
@@ -324,7 +324,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Setup a pci_bAR operation region
  *
  * MUTEX:       Assumes namespace is not locked
  *
@@ -355,7 +355,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Setup a CMOS operation region
  *
  * MUTEX:       Assumes namespace is not locked
  *
@@ -386,7 +386,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Default region initialization
  *
  ******************************************************************************/
 
diff -Nru a/drivers/acpi/events/evsci.c b/drivers/acpi/events/evsci.c
--- a/drivers/acpi/events/evsci.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evsci.c	2005-04-19 01:34:14 -04:00
@@ -49,6 +49,12 @@
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evsci")
 
+/* Local prototypes */
+
+static u32 ACPI_SYSTEM_XFACE
+acpi_ev_sci_xrupt_handler (
+	void                            *context);
+
 
 /*******************************************************************************
  *
@@ -146,7 +152,8 @@
  ******************************************************************************/
 
 u32
-acpi_ev_install_sci_handler (void)
+acpi_ev_install_sci_handler (
+	void)
 {
 	u32                             status = AE_OK;
 
@@ -180,7 +187,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ev_remove_sci_handler (void)
+acpi_ev_remove_sci_handler (
+	void)
 {
 	acpi_status                     status;
 
diff -Nru a/drivers/acpi/events/evxface.c b/drivers/acpi/events/evxface.c
--- a/drivers/acpi/events/evxface.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evxface.c	2005-04-19 01:34:14 -04:00
@@ -64,6 +64,7 @@
  * DESCRIPTION: Saves the pointer to the handler function
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_install_exception_handler (
@@ -457,7 +458,8 @@
 	/* Root Object */
 
 	if (device == ACPI_ROOT_OBJECT) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing notify handler for ROOT object.\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			"Removing notify handler for ROOT object.\n"));
 
 		if (((handler_type & ACPI_SYSTEM_NOTIFY) &&
 			  !acpi_gbl_system_notify.handler)      ||
@@ -564,8 +566,9 @@
  *
  * FUNCTION:    acpi_install_gpe_handler
  *
- * PARAMETERS:  gpe_number      - The GPE number within the GPE block
- *              gpe_block       - GPE block (NULL == FADT GPEs)
+ * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
+ *                                defined GPEs)
+ *              gpe_number      - The GPE number within the GPE block
  *              Type            - Whether this GPE should be treated as an
  *                                edge- or level-triggered interrupt.
  *              Address         - Address of the handler
@@ -662,8 +665,9 @@
  *
  * FUNCTION:    acpi_remove_gpe_handler
  *
- * PARAMETERS:  gpe_number      - The event to remove a handler
- *              gpe_block       - GPE block (NULL == FADT GPEs)
+ * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
+ *                                defined GPEs)
+ *              gpe_number      - The event to remove a handler
  *              Address         - Address of the handler
  *
  * RETURN:      Status
@@ -766,7 +770,8 @@
  * FUNCTION:    acpi_acquire_global_lock
  *
  * PARAMETERS:  Timeout         - How long the caller is willing to wait
- *              out_handle      - A handle to the lock if acquired
+ *              Handle          - Where the handle to the lock is returned
+ *                                (if acquired)
  *
  * RETURN:      Status
  *
@@ -812,7 +817,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Release the ACPI Global Lock
+ * DESCRIPTION: Release the ACPI Global Lock. The handle must be valid.
  *
  ******************************************************************************/
 
diff -Nru a/drivers/acpi/events/evxfevnt.c b/drivers/acpi/events/evxfevnt.c
--- a/drivers/acpi/events/evxfevnt.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/events/evxfevnt.c	2005-04-19 01:34:14 -04:00
@@ -64,7 +64,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_enable (void)
+acpi_enable (
+	void)
 {
 	acpi_status                     status = AE_OK;
 
@@ -91,7 +92,8 @@
 			return_ACPI_STATUS (status);
 		}
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "Transition to ACPI mode successful\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
+			"Transition to ACPI mode successful\n"));
 	}
 
 	return_ACPI_STATUS (status);
@@ -106,12 +108,13 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Transfers the system into LEGACY mode.
+ * DESCRIPTION: Transfers the system into LEGACY (non-ACPI) mode.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_disable (void)
+acpi_disable (
+	void)
 {
 	acpi_status                     status = AE_OK;
 
@@ -125,7 +128,8 @@
 	}
 
 	if (acpi_hw_get_mode() == ACPI_SYS_MODE_LEGACY) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "System is already in legacy (non-ACPI) mode\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
+			"System is already in legacy (non-ACPI) mode\n"));
 	}
 	else {
 		/* Transition to LEGACY mode */
@@ -133,7 +137,8 @@
 		status = acpi_hw_set_mode (ACPI_SYS_MODE_LEGACY);
 
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not exit ACPI mode to legacy mode"));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not exit ACPI mode to legacy mode"));
 			return_ACPI_STATUS (status);
 		}
 
@@ -214,7 +219,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable an ACPI event (general purpose)
+ * DESCRIPTION: Set the type of an individual GPE
  *
  ******************************************************************************/
 
@@ -519,13 +524,12 @@
 
 
 #ifdef ACPI_FUTURE_USAGE
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_get_event_status
  *
  * PARAMETERS:  Event           - The fixed event
- *              Event Status    - Where the current status of the event will
+ *              event_status    - Where the current status of the event will
  *                                be returned
  *
  * RETURN:      Status
@@ -571,7 +575,7 @@
  * PARAMETERS:  gpe_device      - Parent GPE Device
  *              gpe_number      - GPE level within the GPE block
  *              Flags           - Called from an ISR or not
- *              Event Status    - Where the current status of the event will
+ *              event_status    - Where the current status of the event will
  *                                be returned
  *
  * RETURN:      Status
@@ -775,4 +779,5 @@
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS (status);
 }
+
 EXPORT_SYMBOL(acpi_remove_gpe_block);
diff -Nru a/drivers/acpi/executer/exconfig.c b/drivers/acpi/executer/exconfig.c
--- a/drivers/acpi/executer/exconfig.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exconfig.c	2005-04-19 01:34:14 -04:00
@@ -54,6 +54,14 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exconfig")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ex_add_table (
+	struct acpi_table_header        *table,
+	struct acpi_namespace_node      *parent_node,
+	union acpi_operand_object       **ddb_handle);
+
 
 /*******************************************************************************
  *
@@ -70,7 +78,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_add_table (
 	struct acpi_table_header        *table,
 	struct acpi_namespace_node      *parent_node,
@@ -95,10 +103,10 @@
 
 	ACPI_MEMSET (&table_info, 0, sizeof (struct acpi_table_desc));
 
-	table_info.type        = ACPI_TABLE_SSDT;
-	table_info.pointer     = table;
-	table_info.length      = (acpi_size) table->length;
-	table_info.allocation  = ACPI_MEM_ALLOCATED;
+	table_info.type      = ACPI_TABLE_SSDT;
+	table_info.pointer   = table;
+	table_info.length    = (acpi_size) table->length;
+	table_info.allocation = ACPI_MEM_ALLOCATED;
 
 	status = acpi_tb_install_table (&table_info);
 	if (ACPI_FAILURE (status)) {
@@ -226,11 +234,10 @@
 			start_node = parent_node;
 		}
 
-		/*
-		 * Find the node referenced by the parameter_path_string
-		 */
+		/* Find the node referenced by the parameter_path_string */
+
 		status = acpi_ns_get_node_by_path (operand[4]->string.pointer, start_node,
-				   ACPI_NS_SEARCH_PARENT, &parameter_node);
+				 ACPI_NS_SEARCH_PARENT, &parameter_node);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -248,7 +255,8 @@
 	if (parameter_node) {
 		/* Store the parameter data into the optional parameter object */
 
-		status = acpi_ex_store (operand[5], ACPI_CAST_PTR (union acpi_operand_object, parameter_node),
+		status = acpi_ex_store (operand[5],
+				 ACPI_CAST_PTR (union acpi_operand_object, parameter_node),
 				 walk_state);
 		if (ACPI_FAILURE (status)) {
 			(void) acpi_ex_unload_table (ddb_handle);
@@ -371,7 +379,8 @@
 			goto cleanup;
 		}
 
-		table_ptr = ACPI_CAST_PTR (struct acpi_table_header, buffer_desc->buffer.pointer);
+		table_ptr = ACPI_CAST_PTR (struct acpi_table_header,
+				  buffer_desc->buffer.pointer);
 
 		 /* Sanity check the table length */
 
diff -Nru a/drivers/acpi/executer/exconvrt.c b/drivers/acpi/executer/exconvrt.c
--- a/drivers/acpi/executer/exconvrt.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exconvrt.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,15 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exconvrt")
 
+/* Local prototypes */
+
+static u32
+acpi_ex_convert_to_ascii (
+	acpi_integer                    integer,
+	u16                             base,
+	u8                              *string,
+	u8                              max_length);
+
 
 /*******************************************************************************
  *
@@ -115,9 +124,8 @@
 	 */
 	result = 0;
 
-	/*
-	 * String conversion is different than Buffer conversion
-	 */
+	/* String conversion is different than Buffer conversion */
+
 	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_STRING:
 
@@ -168,9 +176,8 @@
 		break;
 	}
 
-	/*
-	 * Create a new integer
-	 */
+	/* Create a new integer */
+
 	return_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 	if (!return_desc) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
@@ -251,7 +258,8 @@
 		 * ASL/AML code that depends on the null being transferred to the new
 		 * buffer.
 		 */
-		return_desc = acpi_ut_create_buffer_object ((acpi_size) obj_desc->string.length + 1);
+		return_desc = acpi_ut_create_buffer_object (
+				  (acpi_size) obj_desc->string.length + 1);
 		if (!return_desc) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
@@ -291,7 +299,7 @@
  *
  ******************************************************************************/
 
-u32
+static u32
 acpi_ex_convert_to_ascii (
 	acpi_integer                    integer,
 	u16                             base,
@@ -357,8 +365,9 @@
 
 	case 16:
 
-		hex_length = ACPI_MUL_2 (data_width); /* 2 ascii hex chars per data byte */
+		/* hex_length: 2 ascii hex chars per data byte */
 
+		hex_length = ACPI_MUL_2 (data_width);
 		for (i = 0, j = (hex_length-1); i < hex_length; i++, j--) {
 			/* Get one hex digit, most significant digits first */
 
@@ -475,7 +484,7 @@
 		/* Setup string length, base, and separator */
 
 		switch (type) {
-		case ACPI_EXPLICIT_CONVERT_DECIMAL: /* Used by to_decimal_string operator */
+		case ACPI_EXPLICIT_CONVERT_DECIMAL: /* Used by to_decimal_string */
 			/*
 			 * From ACPI: "If Data is a buffer, it is converted to a string of
 			 * decimal values separated by commas."
@@ -509,7 +518,7 @@
 			string_length = (obj_desc->buffer.length * 3);
 			break;
 
-		case ACPI_EXPLICIT_CONVERT_HEX:     /* Used by to_hex_string operator */
+		case ACPI_EXPLICIT_CONVERT_HEX:     /* Used by to_hex_string */
 			/*
 			 * From ACPI: "If Data is a buffer, it is converted to a string of
 			 * hexadecimal values separated by commas."
@@ -530,9 +539,8 @@
 			return_ACPI_STATUS (AE_AML_STRING_LIMIT);
 		}
 
-		/*
-		 * Create a new string object and string buffer
-		 */
+		/* Create a new string object and string buffer */
+
 		return_desc = acpi_ut_create_string_object ((acpi_size) string_length);
 		if (!return_desc) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
@@ -551,8 +559,10 @@
 			*new_buf++ = separator; /* each separated by a comma or space */
 		}
 
-		/* Null terminate the string (overwrites final comma/space from above) */
-
+		/*
+		 * Null terminate the string
+		 * (overwrites final comma/space from above)
+		 */
 		new_buf--;
 		*new_buf = 0;
 		break;
@@ -645,7 +655,6 @@
 
 
 		case ACPI_TYPE_STRING:
-
 			/*
 			 * The operand must be a String.  We can convert an
 			 * Integer or Buffer if necessary
@@ -656,7 +665,6 @@
 
 
 		case ACPI_TYPE_BUFFER:
-
 			/*
 			 * The operand must be a Buffer.  We can convert an
 			 * Integer or String if necessary
diff -Nru a/drivers/acpi/executer/excreate.c b/drivers/acpi/executer/excreate.c
--- a/drivers/acpi/executer/excreate.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/excreate.c	2005-04-19 01:34:14 -04:00
@@ -55,7 +55,7 @@
 
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_alias
  *
@@ -65,7 +65,7 @@
  *
  * DESCRIPTION: Create a new named alias
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_alias (
@@ -140,8 +140,7 @@
 		 * target node or the alias Node
 		 */
 		status = acpi_ns_attach_object (alias_node,
-				 acpi_ns_get_attached_object (target_node),
-				 target_node->type);
+				 acpi_ns_get_attached_object (target_node), target_node->type);
 		break;
 	}
 
@@ -151,7 +150,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_event
  *
@@ -161,7 +160,7 @@
  *
  * DESCRIPTION: Create a new event object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_event (
@@ -185,7 +184,7 @@
 	 * that the event is created in an unsignalled state
 	 */
 	status = acpi_os_create_semaphore (ACPI_NO_UNIT_LIMIT, 0,
-			   &obj_desc->event.semaphore);
+			 &obj_desc->event.semaphore);
 	if (ACPI_FAILURE (status)) {
 		goto cleanup;
 	}
@@ -193,7 +192,7 @@
 	/* Attach object to the Node */
 
 	status = acpi_ns_attach_object ((struct acpi_namespace_node *) walk_state->operands[0],
-			   obj_desc, ACPI_TYPE_EVENT);
+			 obj_desc, ACPI_TYPE_EVENT);
 
 cleanup:
 	/*
@@ -205,7 +204,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_mutex
  *
@@ -217,7 +216,7 @@
  *
  *              Mutex (Name[0], sync_level[1])
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_mutex (
@@ -267,20 +266,20 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_region
  *
  * PARAMETERS:  aml_start           - Pointer to the region declaration AML
  *              aml_length          - Max length of the declaration AML
- *              Operands            - List of operands for the opcode
+ *              region_space        - space_iD for the region
  *              walk_state          - Current state
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Create a new operation region object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_region (
@@ -321,7 +320,7 @@
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Region Type - %s (%X)\n",
-			  acpi_ut_get_region_name (region_space), region_space));
+		acpi_ut_get_region_name (region_space), region_space));
 
 	/* Create the region descriptor */
 
@@ -360,7 +359,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_table_region
  *
@@ -370,7 +369,7 @@
  *
  * DESCRIPTION: Create a new data_table_region object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_table_region (
@@ -455,7 +454,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_processor
  *
@@ -467,7 +466,7 @@
  *
  *              Processor (Name[0], cpu_iD[1], pblock_addr[2], pblock_length[3])
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_processor (
@@ -488,9 +487,8 @@
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	/*
-	 * Initialize the processor object from the operands
-	 */
+	/* Initialize the processor object from the operands */
+
 	obj_desc->processor.proc_id = (u8)          operand[1]->integer.value;
 	obj_desc->processor.address = (acpi_io_address) operand[2]->integer.value;
 	obj_desc->processor.length = (u8)           operand[3]->integer.value;
@@ -507,7 +505,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_power_resource
  *
@@ -519,7 +517,7 @@
  *
  *              power_resource (Name[0], system_level[1], resource_order[2])
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_power_resource (
@@ -555,10 +553,10 @@
 	acpi_ut_remove_reference (obj_desc);
 	return_ACPI_STATUS (status);
 }
-
 #endif
 
-/*****************************************************************************
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_method
  *
@@ -570,7 +568,7 @@
  *
  * DESCRIPTION: Create a new method object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_method (
diff -Nru a/drivers/acpi/executer/exdump.c b/drivers/acpi/executer/exdump.c
--- a/drivers/acpi/executer/exdump.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exdump.c	2005-04-19 01:34:14 -04:00
@@ -51,23 +51,48 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exdump")
 
+/* Local prototypes */
+
+#ifdef ACPI_FUTURE_USAGE
+static void
+acpi_ex_out_string (
+	char                            *title,
+	char                            *value);
+
+static void
+acpi_ex_out_pointer (
+	char                            *title,
+	void                            *value);
+
+static void
+acpi_ex_out_integer (
+	char                            *title,
+	u32                             value);
+
+static void
+acpi_ex_out_address (
+	char                            *title,
+	acpi_physical_address           value);
+#endif	/* ACPI_FUTURE_USAGE */
+
 
 /*
  * The following routines are used for debug output only
  */
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_dump_operand
  *
- * PARAMETERS:  *obj_desc         - Pointer to entry to be dumped
+ * PARAMETERS:  *obj_desc       - Pointer to entry to be dumped
+ *              Depth           - Current nesting depth
  *
  * RETURN:      None
  *
  * DESCRIPTION: Dump an operand object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ex_dump_operand (
@@ -86,9 +111,8 @@
 	}
 
 	if (!obj_desc) {
-		/*
-		 * This could be a null element of a package
-		 */
+		/* This could be a null element of a package */
+
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Null Object Descriptor\n"));
 		return;
 	}
@@ -117,6 +141,8 @@
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p ", obj_desc));
 	}
 
+	/* Decode object type */
+
 	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_LOCAL_REFERENCE:
 
@@ -274,7 +300,9 @@
 	case ACPI_TYPE_STRING:
 
 		acpi_os_printf ("String length %X @ %p ",
-			obj_desc->string.length, obj_desc->string.pointer);
+			obj_desc->string.length,
+			obj_desc->string.pointer);
+
 		acpi_ut_print_string (obj_desc->string.pointer, ACPI_UINT8_MAX);
 		acpi_os_printf ("\n");
 		break;
@@ -290,10 +318,13 @@
 
 		acpi_os_printf (
 			"region_field: Bits=%X acc_width=%X Lock=%X Update=%X at byte=%X bit=%X of below:\n",
-			obj_desc->field.bit_length, obj_desc->field.access_byte_width,
+			obj_desc->field.bit_length,
+			obj_desc->field.access_byte_width,
 			obj_desc->field.field_flags & AML_FIELD_LOCK_RULE_MASK,
 			obj_desc->field.field_flags & AML_FIELD_UPDATE_RULE_MASK,
-			obj_desc->field.base_byte_offset, obj_desc->field.start_field_bit_offset);
+			obj_desc->field.base_byte_offset,
+			obj_desc->field.start_field_bit_offset);
+
 		acpi_ex_dump_operand (obj_desc->field.region_obj, depth+1);
 		break;
 
@@ -308,13 +339,15 @@
 
 		acpi_os_printf (
 			"buffer_field: %X bits at byte %X bit %X of \n",
-			obj_desc->buffer_field.bit_length, obj_desc->buffer_field.base_byte_offset,
+			obj_desc->buffer_field.bit_length,
+			obj_desc->buffer_field.base_byte_offset,
 			obj_desc->buffer_field.start_field_bit_offset);
 
 		if (!obj_desc->buffer_field.buffer_obj) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "*NULL* \n"));
 		}
-		else if (ACPI_GET_OBJECT_TYPE (obj_desc->buffer_field.buffer_obj) != ACPI_TYPE_BUFFER) {
+		else if (ACPI_GET_OBJECT_TYPE (obj_desc->buffer_field.buffer_obj) !=
+				 ACPI_TYPE_BUFFER) {
 			acpi_os_printf ("*not a Buffer* \n");
 		}
 		else {
@@ -331,10 +364,10 @@
 
 	case ACPI_TYPE_METHOD:
 
-		acpi_os_printf (
-			"Method(%X) @ %p:%X\n",
+		acpi_os_printf ("Method(%X) @ %p:%X\n",
 			obj_desc->method.param_count,
-			obj_desc->method.aml_start, obj_desc->method.aml_length);
+			obj_desc->method.aml_start,
+			obj_desc->method.aml_length);
 		break;
 
 
@@ -379,7 +412,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_dump_operands
  *
@@ -393,7 +426,7 @@
  *
  * DESCRIPTION: Dump the object stack
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ex_dump_operands (
@@ -441,10 +474,9 @@
 
 
 #ifdef ACPI_FUTURE_USAGE
-
-/*****************************************************************************
+/*******************************************************************************
  *
- * FUNCTION:    acpi_ex_out*
+ * FUNCTION:    acpi_ex_out* functions
  *
  * PARAMETERS:  Title               - Descriptive text
  *              Value               - Value to be displayed
@@ -453,9 +485,9 @@
  *              reduce the number of format strings required and keeps them
  *              all in one place for easy modification.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-void
+static void
 acpi_ex_out_string (
 	char                            *title,
 	char                            *value)
@@ -463,7 +495,7 @@
 	acpi_os_printf ("%20s : %s\n", title, value);
 }
 
-void
+static void
 acpi_ex_out_pointer (
 	char                            *title,
 	void                            *value)
@@ -471,7 +503,7 @@
 	acpi_os_printf ("%20s : %p\n", title, value);
 }
 
-void
+static void
 acpi_ex_out_integer (
 	char                            *title,
 	u32                             value)
@@ -479,7 +511,7 @@
 	acpi_os_printf ("%20s : %X\n", title, value);
 }
 
-void
+static void
 acpi_ex_out_address (
 	char                            *title,
 	acpi_physical_address           value)
@@ -493,16 +525,16 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_dump_node
  *
  * PARAMETERS:  *Node               - Descriptor to dump
- *              Flags               - Force display
+ *              Flags               - Force display if TRUE
  *
  * DESCRIPTION: Dumps the members of the given.Node
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ex_dump_node (
@@ -531,16 +563,16 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_dump_object_descriptor
  *
  * PARAMETERS:  *Object             - Descriptor to dump
- *              Flags               - Force display
+ *              Flags               - Force display if TRUE
  *
  * DESCRIPTION: Dumps the members of the object descriptor given.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ex_dump_object_descriptor (
@@ -553,6 +585,10 @@
 	ACPI_FUNCTION_TRACE ("ex_dump_object_descriptor");
 
 
+	if (!obj_desc) {
+		return_VOID;
+	}
+
 	if (!flags) {
 		if (!((ACPI_LV_OBJECTS & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer))) {
 			return_VOID;
@@ -747,11 +783,17 @@
 	case ACPI_TYPE_LOCAL_REFERENCE:
 
 		acpi_ex_out_integer ("target_type", obj_desc->reference.target_type);
-		acpi_ex_out_string ("Opcode",       (acpi_ps_get_opcode_info (obj_desc->reference.opcode))->name);
+		acpi_ex_out_string ("Opcode",       (acpi_ps_get_opcode_info (
+				  obj_desc->reference.opcode))->name);
 		acpi_ex_out_integer ("Offset",      obj_desc->reference.offset);
 		acpi_ex_out_pointer ("obj_desc",    obj_desc->reference.object);
 		acpi_ex_out_pointer ("Node",        obj_desc->reference.node);
 		acpi_ex_out_pointer ("Where",       obj_desc->reference.where);
+
+		if (obj_desc->reference.object) {
+			acpi_os_printf ("\nReferenced Object:\n");
+			acpi_ex_dump_object_descriptor (obj_desc->reference.object, flags);
+		}
 		break;
 
 
@@ -788,6 +830,5 @@
 }
 
 #endif  /*  ACPI_FUTURE_USAGE  */
-
 #endif
 
diff -Nru a/drivers/acpi/executer/exfield.c b/drivers/acpi/executer/exfield.c
--- a/drivers/acpi/executer/exfield.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exfield.c	2005-04-19 01:34:14 -04:00
@@ -120,8 +120,8 @@
 		 * Note: Smbus protocol value is passed in upper 16-bits of Function
 		 */
 		status = acpi_ex_access_region (obj_desc, 0,
-				  ACPI_CAST_PTR (acpi_integer, buffer_desc->buffer.pointer),
-				  ACPI_READ | (obj_desc->field.attribute << 16));
+				 ACPI_CAST_PTR (acpi_integer, buffer_desc->buffer.pointer),
+				 ACPI_READ | (obj_desc->field.attribute << 16));
 		acpi_ex_release_global_lock (locked);
 		goto exit;
 	}
@@ -196,6 +196,7 @@
  *
  * PARAMETERS:  source_desc         - Contains data to write
  *              obj_desc            - The named field
+ *              result_desc         - Where the return value is returned, if any
  *
  * RETURN:      Status
  *
@@ -250,12 +251,15 @@
 		if (ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_BUFFER) {
 			ACPI_REPORT_ERROR (("SMBus write requires Buffer, found type %s\n",
 				acpi_ut_get_object_type_name (source_desc)));
+
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
 		if (source_desc->buffer.length < ACPI_SMBUS_BUFFER_SIZE) {
-			ACPI_REPORT_ERROR (("SMBus write requires Buffer of length %X, found length %X\n",
+			ACPI_REPORT_ERROR ((
+				"SMBus write requires Buffer of length %X, found length %X\n",
 				ACPI_SMBUS_BUFFER_SIZE, source_desc->buffer.length));
+
 			return_ACPI_STATUS (AE_AML_BUFFER_LIMIT);
 		}
 
@@ -265,14 +269,16 @@
 		}
 
 		buffer = buffer_desc->buffer.pointer;
-		ACPI_MEMCPY (buffer, source_desc->buffer.pointer, ACPI_SMBUS_BUFFER_SIZE);
+		ACPI_MEMCPY (buffer, source_desc->buffer.pointer,
+			ACPI_SMBUS_BUFFER_SIZE);
 
 		/* Lock entire transaction if requested */
 
 		locked = acpi_ex_acquire_global_lock (obj_desc->common_field.field_flags);
 
 		/*
-		 * Perform the write (returns status and perhaps data in the same buffer)
+		 * Perform the write (returns status and perhaps data in the
+		 * same buffer)
 		 * Note: SMBus protocol type is passed in upper 16-bits of Function.
 		 */
 		status = acpi_ex_access_region (obj_desc, 0,
@@ -284,9 +290,8 @@
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Get a pointer to the data to be written
-	 */
+	/* Get a pointer to the data to be written */
+
 	switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
 	case ACPI_TYPE_INTEGER:
 		buffer = &source_desc->integer.value;
@@ -314,7 +319,8 @@
 	 * the ACPI specification.
 	 */
 	new_buffer = NULL;
-	required_length = ACPI_ROUND_BITS_UP_TO_BYTES (obj_desc->common_field.bit_length);
+	required_length = ACPI_ROUND_BITS_UP_TO_BYTES (
+			   obj_desc->common_field.bit_length);
 
 	if (length < required_length) {
 		/* We need to create a new buffer */
@@ -338,6 +344,7 @@
 		"field_write [FROM]: Obj %p (%s:%X), Buf %p, byte_len %X\n",
 		source_desc, acpi_ut_get_type_name (ACPI_GET_OBJECT_TYPE (source_desc)),
 		ACPI_GET_OBJECT_TYPE (source_desc), buffer, length));
+
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 		"field_write [TO]:  Obj %p (%s:%X), bit_len %X, bit_off %X, byte_off %X\n",
 		obj_desc, acpi_ut_get_type_name (ACPI_GET_OBJECT_TYPE (obj_desc)),
diff -Nru a/drivers/acpi/executer/exfldio.c b/drivers/acpi/executer/exfldio.c
--- a/drivers/acpi/executer/exfldio.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exfldio.c	2005-04-19 01:34:14 -04:00
@@ -52,12 +52,31 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exfldio")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ex_field_datum_io (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset,
+	acpi_integer                    *value,
+	u32                             read_write);
+
+static u8
+acpi_ex_register_overflow (
+	union acpi_operand_object       *obj_desc,
+	acpi_integer                    value);
+
+static acpi_status
+acpi_ex_setup_region (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ex_setup_region
  *
- * PARAMETERS:  *obj_desc               - Field to be read or written
+ * PARAMETERS:  obj_desc                - Field to be read or written
  *              field_datum_byte_offset - Byte offset of this datum within the
  *                                        parent field
  *
@@ -69,7 +88,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_setup_region (
 	union acpi_operand_object       *obj_desc,
 	u32                             field_datum_byte_offset)
@@ -127,9 +146,9 @@
 	 * length of one field datum (access width) must fit within the region.
 	 * (Region length is specified in bytes)
 	 */
-	if (rgn_desc->region.length < (obj_desc->common_field.base_byte_offset
-			   + field_datum_byte_offset
-			   + obj_desc->common_field.access_byte_width)) {
+	if (rgn_desc->region.length < (obj_desc->common_field.base_byte_offset +
+			   field_datum_byte_offset +
+			   obj_desc->common_field.access_byte_width)) {
 		if (acpi_gbl_enable_interpreter_slack) {
 			/*
 			 * Slack mode only:  We will go ahead and allow access to this
@@ -155,7 +174,8 @@
 				"Field [%4.4s] access width (%d bytes) too large for region [%4.4s] (length %X)\n",
 				acpi_ut_get_node_name (obj_desc->common_field.node),
 				obj_desc->common_field.access_byte_width,
-				acpi_ut_get_node_name (rgn_desc->region.node), rgn_desc->region.length));
+				acpi_ut_get_node_name (rgn_desc->region.node),
+				rgn_desc->region.length));
 		}
 
 		/*
@@ -167,7 +187,8 @@
 			acpi_ut_get_node_name (obj_desc->common_field.node),
 			obj_desc->common_field.base_byte_offset,
 			field_datum_byte_offset, obj_desc->common_field.access_byte_width,
-			acpi_ut_get_node_name (rgn_desc->region.node), rgn_desc->region.length));
+			acpi_ut_get_node_name (rgn_desc->region.node),
+			rgn_desc->region.length));
 
 		return_ACPI_STATUS (AE_AML_REGION_LIMIT);
 	}
@@ -180,10 +201,10 @@
  *
  * FUNCTION:    acpi_ex_access_region
  *
- * PARAMETERS:  *obj_desc               - Field to be read
+ * PARAMETERS:  obj_desc                - Field to be read
  *              field_datum_byte_offset - Byte offset of this datum within the
  *                                        parent field
- *              *Value                  - Where to store value (must at least
+ *              Value                   - Where to store value (must at least
  *                                        the size of acpi_integer)
  *              Function                - Read or Write flag plus other region-
  *                                        dependent flags
@@ -226,9 +247,9 @@
 	 * 3) The current offset into the field
 	 */
 	rgn_desc = obj_desc->common_field.region_obj;
-	address = rgn_desc->region.address
-			 + obj_desc->common_field.base_byte_offset
-			 + field_datum_byte_offset;
+	address = rgn_desc->region.address +
+			 obj_desc->common_field.base_byte_offset +
+			 field_datum_byte_offset;
 
 	if ((function & ACPI_IO_MASK) == ACPI_READ) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "[READ]"));
@@ -249,7 +270,8 @@
 	/* Invoke the appropriate address_space/op_region handler */
 
 	status = acpi_ev_address_space_dispatch (rgn_desc, function,
-			  address, ACPI_MUL_8 (obj_desc->common_field.access_byte_width), value);
+			 address,
+			 ACPI_MUL_8 (obj_desc->common_field.access_byte_width), value);
 
 	if (ACPI_FAILURE (status)) {
 		if (status == AE_NOT_IMPLEMENTED) {
@@ -274,7 +296,7 @@
  *
  * FUNCTION:    acpi_ex_register_overflow
  *
- * PARAMETERS:  *obj_desc               - Register(Field) to be written
+ * PARAMETERS:  obj_desc                - Register(Field) to be written
  *              Value                   - Value to be stored
  *
  * RETURN:      TRUE if value overflows the field, FALSE otherwise
@@ -287,7 +309,7 @@
  *
  ******************************************************************************/
 
-u8
+static u8
 acpi_ex_register_overflow (
 	union acpi_operand_object       *obj_desc,
 	acpi_integer                    value)
@@ -319,10 +341,10 @@
  *
  * FUNCTION:    acpi_ex_field_datum_io
  *
- * PARAMETERS:  *obj_desc               - Field to be read
+ * PARAMETERS:  obj_desc                - Field to be read
  *              field_datum_byte_offset - Byte offset of this datum within the
  *                                        parent field
- *              *Value                  - Where to store value (must be 64 bits)
+ *              Value                   - Where to store value (must be 64 bits)
  *              read_write              - Read or Write flag
  *
  * RETURN:      Status
@@ -333,7 +355,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_field_datum_io (
 	union acpi_operand_object       *obj_desc,
 	u32                             field_datum_byte_offset,
@@ -350,7 +372,9 @@
 	if (read_write == ACPI_READ) {
 		if (!value) {
 			local_value = 0;
-			value = &local_value; /* To support reads without saving return value */
+
+			/* To support reads without saving return value */
+			value = &local_value;
 		}
 
 		/* Clear the entire return buffer first, [Very Important!] */
@@ -363,8 +387,10 @@
 	 *
 	 * buffer_field - Read/write from/to a Buffer
 	 * region_field - Read/write from/to a Operation Region.
-	 * bank_field  - Write to a Bank Register, then read/write from/to an op_region
-	 * index_field - Write to an Index Register, then read/write from/to a Data Register
+	 * bank_field  - Write to a Bank Register, then read/write from/to an
+	 *               operation_region
+	 * index_field - Write to an Index Register, then read/write from/to a
+	 *               Data Register
 	 */
 	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_BUFFER_FIELD:
@@ -384,19 +410,20 @@
 			 * Copy the data from the source buffer.
 			 * Length is the field width in bytes.
 			 */
-			ACPI_MEMCPY (value, (obj_desc->buffer_field.buffer_obj)->buffer.pointer
-					  + obj_desc->buffer_field.base_byte_offset
-					  + field_datum_byte_offset,
-					  obj_desc->common_field.access_byte_width);
+			ACPI_MEMCPY (value,
+				(obj_desc->buffer_field.buffer_obj)->buffer.pointer +
+					obj_desc->buffer_field.base_byte_offset +
+					field_datum_byte_offset,
+				obj_desc->common_field.access_byte_width);
 		}
 		else {
 			/*
 			 * Copy the data to the target buffer.
 			 * Length is the field width in bytes.
 			 */
-			ACPI_MEMCPY ((obj_desc->buffer_field.buffer_obj)->buffer.pointer
-					+ obj_desc->buffer_field.base_byte_offset
-					+ field_datum_byte_offset,
+			ACPI_MEMCPY ((obj_desc->buffer_field.buffer_obj)->buffer.pointer +
+					obj_desc->buffer_field.base_byte_offset +
+					field_datum_byte_offset,
 					value, obj_desc->common_field.access_byte_width);
 		}
 
@@ -406,8 +433,10 @@
 
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
 
-		/* Ensure that the bank_value is not beyond the capacity of the register */
-
+		/*
+		 * Ensure that the bank_value is not beyond the capacity of
+		 * the register
+		 */
 		if (acpi_ex_register_overflow (obj_desc->bank_field.bank_obj,
 				  (acpi_integer) obj_desc->bank_field.value)) {
 			return_ACPI_STATUS (AE_AML_REGISTER_LIMIT);
@@ -445,8 +474,10 @@
 	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
 
-		/* Ensure that the index_value is not beyond the capacity of the register */
-
+		/*
+		 * Ensure that the index_value is not beyond the capacity of
+		 * the register
+		 */
 		if (acpi_ex_register_overflow (obj_desc->index_field.index_obj,
 				  (acpi_integer) obj_desc->index_field.value)) {
 			return_ACPI_STATUS (AE_AML_REGISTER_LIMIT);
@@ -496,14 +527,16 @@
 
 	if (ACPI_SUCCESS (status)) {
 		if (read_write == ACPI_READ) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Value Read %8.8X%8.8X, Width %d\n",
-					   ACPI_FORMAT_UINT64 (*value),
-					   obj_desc->common_field.access_byte_width));
+			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+				"Value Read %8.8X%8.8X, Width %d\n",
+				ACPI_FORMAT_UINT64 (*value),
+				obj_desc->common_field.access_byte_width));
 		}
 		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Value Written %8.8X%8.8X, Width %d\n",
-					   ACPI_FORMAT_UINT64 (*value),
-					   obj_desc->common_field.access_byte_width));
+			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+				"Value Written %8.8X%8.8X, Width %d\n",
+				ACPI_FORMAT_UINT64 (*value),
+				obj_desc->common_field.access_byte_width));
 		}
 	}
 
@@ -515,8 +548,10 @@
  *
  * FUNCTION:    acpi_ex_write_with_update_rule
  *
- * PARAMETERS:  *obj_desc           - Field to be set
- *              Value               - Value to store
+ * PARAMETERS:  obj_desc                - Field to be written
+ *              Mask                    - bitmask within field datum
+ *              field_value             - Value to write
+ *              field_datum_byte_offset - Offset of datum within field
  *
  * RETURN:      Status
  *
@@ -689,7 +724,8 @@
 		/* Merge with previous datum if necessary */
 
 		merged_datum |= raw_datum <<
-			(obj_desc->common_field.access_bit_width - obj_desc->common_field.start_field_bit_offset);
+			(obj_desc->common_field.access_bit_width -
+				obj_desc->common_field.start_field_bit_offset);
 
 		if (i == datum_count) {
 			break;
@@ -707,7 +743,8 @@
 
 	/* Mask off any extra bits in the last datum */
 
-	buffer_tail_bits = obj_desc->common_field.bit_length % obj_desc->common_field.access_bit_width;
+	buffer_tail_bits = obj_desc->common_field.bit_length %
+			   obj_desc->common_field.access_bit_width;
 	if (buffer_tail_bits) {
 		merged_datum &= ACPI_MASK_BITS_ABOVE (buffer_tail_bits);
 	}
@@ -791,7 +828,8 @@
 		/* Write merged datum to the target field */
 
 		merged_datum &= mask;
-		status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum, field_offset);
+		status = acpi_ex_write_with_update_rule (obj_desc, mask,
+				 merged_datum, field_offset);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -800,7 +838,8 @@
 
 		field_offset += obj_desc->common_field.access_byte_width;
 		merged_datum = raw_datum >>
-			(obj_desc->common_field.access_bit_width - obj_desc->common_field.start_field_bit_offset);
+			(obj_desc->common_field.access_bit_width -
+				obj_desc->common_field.start_field_bit_offset);
 		mask = ACPI_INTEGER_MAX;
 
 		if (i == datum_count) {
@@ -819,7 +858,8 @@
 	/* Mask off any extra bits in the last datum */
 
 	buffer_tail_bits = (obj_desc->common_field.bit_length +
-			obj_desc->common_field.start_field_bit_offset) % obj_desc->common_field.access_bit_width;
+			obj_desc->common_field.start_field_bit_offset) %
+				obj_desc->common_field.access_bit_width;
 	if (buffer_tail_bits) {
 		mask &= ACPI_MASK_BITS_ABOVE (buffer_tail_bits);
 	}
@@ -827,7 +867,8 @@
 	/* Write the last datum to the field */
 
 	merged_datum &= mask;
-	status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum, field_offset);
+	status = acpi_ex_write_with_update_rule (obj_desc,
+			 mask, merged_datum, field_offset);
 
 	return_ACPI_STATUS (status);
 }
diff -Nru a/drivers/acpi/executer/exmisc.c b/drivers/acpi/executer/exmisc.c
--- a/drivers/acpi/executer/exmisc.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exmisc.c	2005-04-19 01:34:14 -04:00
@@ -139,8 +139,9 @@
 	reference_obj->reference.object = referenced_obj;
 	*return_desc = reference_obj;
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Object %p Type [%s], returning Reference %p\n",
-			obj_desc, acpi_ut_get_object_type_name (obj_desc), *return_desc));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+		"Object %p Type [%s], returning Reference %p\n",
+		obj_desc, acpi_ut_get_object_type_name (obj_desc), *return_desc));
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -456,7 +457,7 @@
 		return (integer0 * integer1);
 
 
-	case AML_SHIFT_LEFT_OP:         /* shift_left (Operand, shift_count, Result) */
+	case AML_SHIFT_LEFT_OP:         /* shift_left (Operand, shift_count, Result)*/
 
 		return (integer0 << integer1);
 
diff -Nru a/drivers/acpi/executer/exmutex.c b/drivers/acpi/executer/exmutex.c
--- a/drivers/acpi/executer/exmutex.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exmutex.c	2005-04-19 01:34:14 -04:00
@@ -49,6 +49,13 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exmutex")
 
+/* Local prototypes */
+
+static void
+acpi_ex_link_mutex (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_thread_state        *thread);
+
 
 /*******************************************************************************
  *
@@ -56,7 +63,7 @@
  *
  * PARAMETERS:  obj_desc            - The mutex to be unlinked
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Remove a mutex from the "acquired_mutex" list
  *
@@ -92,16 +99,16 @@
  *
  * FUNCTION:    acpi_ex_link_mutex
  *
- * PARAMETERS:  obj_desc            - The mutex to be linked
- *              list_head           - head of the "acquired_mutex" list
+ * PARAMETERS:  obj_desc        - The mutex to be linked
+ *              Thread          - Current executing thread object
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Add a mutex to the "acquired_mutex" list for this walk
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ex_link_mutex (
 	union acpi_operand_object       *obj_desc,
 	struct acpi_thread_state        *thread)
@@ -132,8 +139,9 @@
  *
  * FUNCTION:    acpi_ex_acquire_mutex
  *
- * PARAMETERS:  time_desc           - The 'time to delay' object descriptor
- *              obj_desc            - The object descriptor for this op
+ * PARAMETERS:  time_desc           - Timeout integer
+ *              obj_desc            - Mutex object
+ *              walk_state          - Current method execution state
  *
  * RETURN:      Status
  *
@@ -161,7 +169,7 @@
 
 	if (!walk_state->thread) {
 		ACPI_REPORT_ERROR (("Cannot acquire Mutex [%4.4s], null thread info\n",
-				acpi_ut_get_node_name (obj_desc->mutex.node)));
+			acpi_ut_get_node_name (obj_desc->mutex.node)));
 		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
@@ -170,8 +178,9 @@
 	 * mutex.  This mechanism provides some deadlock prevention
 	 */
 	if (walk_state->thread->current_sync_level > obj_desc->mutex.sync_level) {
-		ACPI_REPORT_ERROR (("Cannot acquire Mutex [%4.4s], incorrect sync_level\n",
-				acpi_ut_get_node_name (obj_desc->mutex.node)));
+		ACPI_REPORT_ERROR ((
+			"Cannot acquire Mutex [%4.4s], incorrect sync_level\n",
+			acpi_ut_get_node_name (obj_desc->mutex.node)));
 		return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
 	}
 
@@ -180,8 +189,10 @@
 	if (obj_desc->mutex.owner_thread) {
 		/* Special case for Global Lock, allow all threads */
 
-		if ((obj_desc->mutex.owner_thread->thread_id == walk_state->thread->thread_id) ||
-			(obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore)) {
+		if ((obj_desc->mutex.owner_thread->thread_id ==
+				walk_state->thread->thread_id)      ||
+			(obj_desc->mutex.semaphore ==
+				acpi_gbl_global_lock_semaphore)) {
 			/*
 			 * The mutex is already owned by this thread,
 			 * just increment the acquisition depth
@@ -221,6 +232,7 @@
  * FUNCTION:    acpi_ex_release_mutex
  *
  * PARAMETERS:  obj_desc            - The object descriptor for this op
+ *              walk_state          - Current method execution state
  *
  * RETURN:      Status
  *
@@ -278,8 +290,9 @@
 	 * equal to the current sync level
 	 */
 	if (obj_desc->mutex.sync_level > walk_state->thread->current_sync_level) {
-		ACPI_REPORT_ERROR (("Cannot release Mutex [%4.4s], incorrect sync_level\n",
-				acpi_ut_get_node_name (obj_desc->mutex.node)));
+		ACPI_REPORT_ERROR ((
+			"Cannot release Mutex [%4.4s], incorrect sync_level\n",
+			acpi_ut_get_node_name (obj_desc->mutex.node)));
 		return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
 	}
 
@@ -313,11 +326,11 @@
  *
  * FUNCTION:    acpi_ex_release_all_mutexes
  *
- * PARAMETERS:  mutex_list            - Head of the mutex list
+ * PARAMETERS:  Thread          - Current executing thread object
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Release all mutexes in the list
+ * DESCRIPTION: Release all mutexes held by this thread
  *
  ******************************************************************************/
 
diff -Nru a/drivers/acpi/executer/exnames.c b/drivers/acpi/executer/exnames.c
--- a/drivers/acpi/executer/exnames.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exnames.c	2005-04-19 01:34:14 -04:00
@@ -50,13 +50,17 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exnames")
 
+/* Local prototypes */
 
-/* AML Package Length encodings */
+static char *
+acpi_ex_allocate_name_string (
+	u32                             prefix_count,
+	u32                             num_name_segs);
 
-#define ACPI_AML_PACKAGE_TYPE1   0x40
-#define ACPI_AML_PACKAGE_TYPE2   0x4000
-#define ACPI_AML_PACKAGE_TYPE3   0x400000
-#define ACPI_AML_PACKAGE_TYPE4   0x40000000
+static acpi_status
+acpi_ex_name_segment (
+	u8                              **in_aml_address,
+	char                            *name_string);
 
 
 /*******************************************************************************
@@ -64,7 +68,7 @@
  * FUNCTION:    acpi_ex_allocate_name_string
  *
  * PARAMETERS:  prefix_count        - Count of parent levels. Special cases:
- *                                    (-1) = root,  0 = none
+ *                                    (-1)==root,  0==none
  *              num_name_segs       - count of 4-character name segments
  *
  * RETURN:      A pointer to the allocated string segment.  This segment must
@@ -75,7 +79,7 @@
  *
  ******************************************************************************/
 
-char *
+static char *
 acpi_ex_allocate_name_string (
 	u32                             prefix_count,
 	u32                             num_name_segs)
@@ -88,7 +92,7 @@
 
 
 	/*
-	 * Allow room for all \ and ^ prefixes, all segments, and a multi_name_prefix.
+	 * Allow room for all \ and ^ prefixes, all segments and a multi_name_prefix.
 	 * Also, one byte for the null terminator.
 	 * This may actually be somewhat longer than needed.
 	 */
@@ -107,7 +111,8 @@
 	 */
 	name_string = ACPI_MEM_ALLOCATE (size_needed);
 	if (!name_string) {
-		ACPI_REPORT_ERROR (("ex_allocate_name_string: Could not allocate size %d\n", size_needed));
+		ACPI_REPORT_ERROR ((
+			"ex_allocate_name_string: Could not allocate size %d\n", size_needed));
 		return_PTR (NULL);
 	}
 
@@ -152,15 +157,17 @@
  *
  * FUNCTION:    acpi_ex_name_segment
  *
- * PARAMETERS:  interpreter_mode    - Current running mode (load1/Load2/Exec)
+ * PARAMETERS:  in_aml_address  - Pointer to the name in the AML code
+ *              name_string     - Where to return the name. The name is appended
+ *                                to any existing string to form a namepath
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Execute a name segment (4 bytes)
+ * DESCRIPTION: Extract an ACPI name (4 bytes) from the AML byte stream
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_name_segment (
 	u8                              **in_aml_address,
 	char                            *name_string)
@@ -223,10 +230,13 @@
 		status = AE_CTRL_PENDING;
 	}
 	else {
-		/* Segment started with one or more valid characters, but fewer than 4 */
-
+		/*
+		 * Segment started with one or more valid characters, but fewer than
+		 * the required 4
+		 */
 		status = AE_AML_BAD_NAME;
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Bad character %02x in name, at %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Bad character %02x in name, at %p\n",
 			*aml_address, aml_address));
 	}
 
@@ -239,11 +249,16 @@
  *
  * FUNCTION:    acpi_ex_get_name_string
  *
- * PARAMETERS:  data_type           - Data type to be associated with this name
+ * PARAMETERS:  data_type           - Object type to be associated with this
+ *                                    name
+ *              in_aml_address      - Pointer to the namestring in the AML code
+ *              out_name_string     - Where the namestring is returned
+ *              out_name_length     - Length of the returned string
  *
- * RETURN:      Status
+ * RETURN:      Status, namestring and length
  *
- * DESCRIPTION: Get a name, including any prefixes.
+ * DESCRIPTION: Extract a full namepath from the AML byte stream,
+ *              including any prefixes.
  *
  ******************************************************************************/
 
@@ -286,7 +301,8 @@
 		switch (*aml_address) {
 		case AML_ROOT_PREFIX:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "root_prefix(\\) at %p\n", aml_address));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "root_prefix(\\) at %p\n",
+				aml_address));
 
 			/*
 			 * Remember that we have a root_prefix --
@@ -303,7 +319,8 @@
 			/* Increment past possibly multiple parent prefixes */
 
 			do {
-				ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "parent_prefix (^) at %p\n", aml_address));
+				ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "parent_prefix (^) at %p\n",
+					aml_address));
 
 				aml_address++;
 				prefix_count++;
@@ -321,13 +338,13 @@
 			break;
 		}
 
-
 		/* Examine first character of name for name segment prefix operator */
 
 		switch (*aml_address) {
 		case AML_DUAL_NAME_PREFIX:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "dual_name_prefix at %p\n", aml_address));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "dual_name_prefix at %p\n",
+				aml_address));
 
 			aml_address++;
 			name_string = acpi_ex_allocate_name_string (prefix_count, 2);
@@ -349,7 +366,8 @@
 
 		case AML_MULTI_NAME_PREFIX_OP:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "multi_name_prefix at %p\n", aml_address));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "multi_name_prefix at %p\n",
+				aml_address));
 
 			/* Fetch count of segments remaining in name path */
 
@@ -368,7 +386,8 @@
 			has_prefix = TRUE;
 
 			while (num_segments &&
-					(status = acpi_ex_name_segment (&aml_address, name_string)) == AE_OK) {
+					(status = acpi_ex_name_segment (&aml_address, name_string)) ==
+						AE_OK) {
 				num_segments--;
 			}
 
@@ -380,7 +399,8 @@
 			/* null_name valid as of 8-12-98 ASL/AML Grammar Update */
 
 			if (prefix_count == ACPI_UINT32_MAX) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "name_seg is \"\\\" followed by NULL\n"));
+				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+					"name_seg is \"\\\" followed by NULL\n"));
 			}
 
 			/* Consume the NULL byte */
diff -Nru a/drivers/acpi/executer/exoparg1.c b/drivers/acpi/executer/exoparg1.c
--- a/drivers/acpi/executer/exoparg1.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exoparg1.c	2005-04-19 01:34:14 -04:00
@@ -97,7 +97,8 @@
 	union acpi_operand_object       *return_desc = NULL;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_0A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_0A_0T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -161,7 +162,8 @@
 	acpi_status                     status = AE_OK;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_0R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -236,7 +238,8 @@
 	union acpi_operand_object       **operand = &walk_state->operands[0];
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_0R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -289,7 +292,8 @@
 	acpi_integer                    digit;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -409,8 +413,10 @@
 			for (i = 0; (i < acpi_gbl_integer_nybble_width) && (digit > 0); i++) {
 				(void) acpi_ut_short_divide (digit, 10, &digit, &temp32);
 
-				/* Insert the BCD digit that resides in the remainder from above */
-
+				/*
+				 * Insert the BCD digit that resides in the
+				 * remainder from above
+				 */
 				return_desc->integer.value |= (((acpi_integer) temp32) <<
 						   ACPI_MUL_4 (i));
 			}
@@ -445,7 +451,8 @@
 
 			/* Get the object reference, store it, and remove our reference */
 
-			status = acpi_ex_get_object_reference (operand[0], &return_desc2, walk_state);
+			status = acpi_ex_get_object_reference (operand[0],
+					 &return_desc2, walk_state);
 			if (ACPI_FAILURE (status)) {
 				goto cleanup;
 			}
@@ -482,10 +489,10 @@
 
 		if (!walk_state->result_obj) {
 			/*
-			 * Normally, we would remove a reference on the Operand[0] parameter;
-			 * But since it is being used as the internal return object
-			 * (meaning we would normally increment it), the two cancel out,
-			 * and we simply don't do anything.
+			 * Normally, we would remove a reference on the Operand[0]
+			 * parameter; But since it is being used as the internal return
+			 * object (meaning we would normally increment it), the two
+			 * cancel out, and we simply don't do anything.
 			 */
 			walk_state->result_obj = operand[0];
 			walk_state->operands[0] = NULL; /* Prevent deletion */
@@ -549,9 +556,8 @@
 	case AML_SHIFT_LEFT_BIT_OP:     /* shift_left_bit (Source, bit_num) */
 	case AML_SHIFT_RIGHT_BIT_OP:    /* shift_right_bit (Source, bit_num) */
 
-		/*
-		 * These are two obsolete opcodes
-		 */
+		/* These are two obsolete opcodes */
+
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"%s is obsolete and not implemented\n",
 			acpi_ps_get_opcode_name (walk_state->opcode)));
@@ -568,9 +574,8 @@
 	}
 
 	if (ACPI_SUCCESS (status)) {
-		/*
-		 * Store the return value computed above into the target object
-		 */
+		/* Store the return value computed above into the target object */
+
 		status = acpi_ex_store (return_desc, operand[1], walk_state);
 	}
 
@@ -615,7 +620,8 @@
 	acpi_integer                    value;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -706,9 +712,9 @@
 
 		/*
 		 * Note: The operand is not resolved at this point because we want to
-		 * get the associated object, not its value.  For example, we don't want
-		 * to resolve a field_unit to its value, we want the actual field_unit
-		 * object.
+		 * get the associated object, not its value.  For example, we don't
+		 * want to resolve a field_unit to its value, we want the actual
+		 * field_unit object.
 		 */
 
 		/* Get the type of the base object */
@@ -738,7 +744,8 @@
 
 		/* Get the base object */
 
-		status = acpi_ex_resolve_multiple (walk_state, operand[0], &type, &temp_desc);
+		status = acpi_ex_resolve_multiple (walk_state,
+				 operand[0], &type, &temp_desc);
 		if (ACPI_FAILURE (status)) {
 			goto cleanup;
 		}
@@ -818,8 +825,10 @@
 
 					/* Set Operand[0] to the value of the local/arg */
 
-					status = acpi_ds_method_data_get_value (operand[0]->reference.opcode,
-							 operand[0]->reference.offset, walk_state, &temp_desc);
+					status = acpi_ds_method_data_get_value (
+							 operand[0]->reference.opcode,
+							 operand[0]->reference.offset,
+							 walk_state, &temp_desc);
 					if (ACPI_FAILURE (status)) {
 						goto cleanup;
 					}
@@ -852,21 +861,26 @@
 			case ACPI_TYPE_STRING:
 
 				/*
-				 * This is a deref_of (String). The string is a reference to a named ACPI object.
+				 * This is a deref_of (String). The string is a reference
+				 * to a named ACPI object.
 				 *
 				 * 1) Find the owning Node
-				 * 2) Dereference the node to an actual object.  Could be a Field, so we nee
-				 *    to resolve the node to a value.
+				 * 2) Dereference the node to an actual object.  Could be a
+				 *    Field, so we need to resolve the node to a value.
 				 */
 				status = acpi_ns_get_node_by_path (operand[0]->string.pointer,
-						  walk_state->scope_info->scope.node, ACPI_NS_SEARCH_PARENT,
-						  ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &return_desc));
+						 walk_state->scope_info->scope.node,
+						 ACPI_NS_SEARCH_PARENT,
+						 ACPI_CAST_INDIRECT_PTR (
+								struct acpi_namespace_node, &return_desc));
 				if (ACPI_FAILURE (status)) {
 					goto cleanup;
 				}
 
 				status = acpi_ex_resolve_node_to_value (
-						  ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &return_desc), walk_state);
+						  ACPI_CAST_INDIRECT_PTR (
+								 struct acpi_namespace_node, &return_desc),
+								walk_state);
 				goto cleanup;
 
 
@@ -883,14 +897,16 @@
 			/*
 			 * This is a deref_of (object_reference)
 			 * Get the actual object from the Node (This is the dereference).
-			 * -- This case may only happen when a local_x or arg_x is dereferenced above.
+			 * This case may only happen when a local_x or arg_x is
+			 * dereferenced above.
 			 */
-			return_desc = acpi_ns_get_attached_object ((struct acpi_namespace_node *) operand[0]);
+			return_desc = acpi_ns_get_attached_object (
+					  (struct acpi_namespace_node *) operand[0]);
 		}
 		else {
 			/*
-			 * This must be a reference object produced by either the Index() or
-			 * ref_of() operator
+			 * This must be a reference object produced by either the
+			 * Index() or ref_of() operator
 			 */
 			switch (operand[0]->reference.opcode) {
 			case AML_INDEX_OP:
@@ -931,8 +947,8 @@
 				case ACPI_TYPE_PACKAGE:
 
 					/*
-					 * Return the referenced element of the package.  We must add
-					 * another reference to the referenced object, however.
+					 * Return the referenced element of the package.  We must
+					 * add another reference to the referenced object, however.
 					 */
 					return_desc = *(operand[0]->reference.where);
 					if (!return_desc) {
@@ -967,9 +983,11 @@
 
 				return_desc = operand[0]->reference.object;
 
-				if (ACPI_GET_DESCRIPTOR_TYPE (return_desc) == ACPI_DESC_TYPE_NAMED) {
+				if (ACPI_GET_DESCRIPTOR_TYPE (return_desc) ==
+						ACPI_DESC_TYPE_NAMED) {
 
-					return_desc = acpi_ns_get_attached_object ((struct acpi_namespace_node *) return_desc);
+					return_desc = acpi_ns_get_attached_object (
+							  (struct acpi_namespace_node *) return_desc);
 				}
 
 				/* Add another reference to the object! */
diff -Nru a/drivers/acpi/executer/exoparg2.c b/drivers/acpi/executer/exoparg2.c
--- a/drivers/acpi/executer/exoparg2.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exoparg2.c	2005-04-19 01:34:14 -04:00
@@ -118,7 +118,7 @@
 
 		value = (u32) operand[1]->integer.value;
 
-		/* Notifies allowed on this object? */
+		/* Are notifies allowed on this object? */
 
 		if (!acpi_ev_is_notify_object (node)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
@@ -203,11 +203,12 @@
 		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	/*
-	 * Execute the opcode
-	 */
+	/* Execute the opcode */
+
 	switch (walk_state->opcode) {
-	case AML_DIVIDE_OP:             /* Divide (Dividend, Divisor, remainder_result quotient_result) */
+	case AML_DIVIDE_OP:
+
+		/* Divide (Dividend, Divisor, remainder_result quotient_result) */
 
 		return_desc1 = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 		if (!return_desc1) {
@@ -241,7 +242,6 @@
 		goto cleanup;
 	}
 
-
 	/* Store the results to the target reference operands */
 
 	status = acpi_ex_store (return_desc2, operand[2], walk_state);
@@ -295,7 +295,7 @@
 {
 	union acpi_operand_object       **operand = &walk_state->operands[0];
 	union acpi_operand_object       *return_desc = NULL;
-	u32                             index;
+	acpi_integer                    index;
 	acpi_status                     status = AE_OK;
 	acpi_size                       length;
 
@@ -304,9 +304,8 @@
 		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	/*
-	 * Execute the opcode
-	 */
+	/* Execute the opcode */
+
 	if (walk_state->op_info->flags & AML_MATH) {
 		/* All simple math opcodes (add, etc.) */
 
@@ -322,9 +321,8 @@
 		goto store_result_to_target;
 	}
 
-
 	switch (walk_state->opcode) {
-	case AML_MOD_OP:                /* Mod (Dividend, Divisor, remainder_result (ACPI 2.0) */
+	case AML_MOD_OP: /* Mod (Dividend, Divisor, remainder_result (ACPI 2.0) */
 
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 		if (!return_desc) {
@@ -341,18 +339,19 @@
 		break;
 
 
-	case AML_CONCAT_OP:             /* Concatenate (Data1, Data2, Result) */
+	case AML_CONCAT_OP: /* Concatenate (Data1, Data2, Result) */
 
 		status = acpi_ex_do_concatenate (operand[0], operand[1],
 				 &return_desc, walk_state);
 		break;
 
 
-	case AML_TO_STRING_OP:          /* to_string (Buffer, Length, Result) (ACPI 2.0) */
+	case AML_TO_STRING_OP: /* to_string (Buffer, Length, Result) (ACPI 2.0) */
 
 		/*
 		 * Input object is guaranteed to be a buffer at this point (it may have
-		 * been converted.)  Copy the raw buffer data to a new object of type String.
+		 * been converted.)  Copy the raw buffer data to a new object of
+		 * type String.
 		 */
 
 		/*
@@ -383,14 +382,16 @@
 			goto cleanup;
 		}
 
-		/* Copy the raw buffer data with no transform. NULL terminated already. */
+		/* Copy the raw buffer data with no transform. NULL terminated already*/
 
 		ACPI_MEMCPY (return_desc->string.pointer,
 			operand[0]->buffer.pointer, length);
 		break;
 
 
-	case AML_CONCAT_RES_OP:         /* concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */
+	case AML_CONCAT_RES_OP:
+
+		/* concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */
 
 		status = acpi_ex_concat_template (operand[0], operand[1],
 				 &return_desc, walk_state);
@@ -407,33 +408,33 @@
 			goto cleanup;
 		}
 
-		index = (u32) operand[1]->integer.value;
+		index = operand[1]->integer.value;
+
+		/* At this point, the Source operand is a Package, Buffer, or String */
 
-		/*
-		 * At this point, the Source operand is a Package, Buffer, or String
-		 */
 		if (ACPI_GET_OBJECT_TYPE (operand[0]) == ACPI_TYPE_PACKAGE) {
 			/* Object to be indexed is a Package */
 
 			if (index >= operand[0]->package.count) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Index value (%X) beyond package end (%X)\n",
-					index, operand[0]->package.count));
+					"Index value (%X%8.8X) beyond package end (%X)\n",
+					ACPI_FORMAT_UINT64 (index), operand[0]->package.count));
 				status = AE_AML_PACKAGE_LIMIT;
 				goto cleanup;
 			}
 
 			return_desc->reference.target_type = ACPI_TYPE_PACKAGE;
 			return_desc->reference.object    = operand[0];
-			return_desc->reference.where     = &operand[0]->package.elements [index];
+			return_desc->reference.where     = &operand[0]->package.elements [
+					  index];
 		}
 		else {
 			/* Object to be indexed is a Buffer/String */
 
 			if (index >= operand[0]->buffer.length) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Index value (%X) beyond end of buffer (%X)\n",
-					index, operand[0]->buffer.length));
+					"Index value (%X%8.8X) beyond end of buffer (%X)\n",
+					ACPI_FORMAT_UINT64 (index), operand[0]->buffer.length));
 				status = AE_AML_BUFFER_LIMIT;
 				goto cleanup;
 			}
@@ -451,7 +452,7 @@
 		/* Complete the Index reference object */
 
 		return_desc->reference.opcode    = AML_INDEX_OP;
-		return_desc->reference.offset    = index;
+		return_desc->reference.offset    = (u32) index;
 
 		/* Store the reference to the Target */
 
@@ -536,21 +537,23 @@
 		goto cleanup;
 	}
 
-	/*
-	 * Execute the Opcode
-	 */
-	if (walk_state->op_info->flags & AML_LOGICAL_NUMERIC) /* logical_op (Operand0, Operand1) */ {
+	/* Execute the Opcode */
+
+	if (walk_state->op_info->flags & AML_LOGICAL_NUMERIC) {
+		/* logical_op (Operand0, Operand1) */
+
 		status = acpi_ex_do_logical_numeric_op (walk_state->opcode,
 				  operand[0]->integer.value, operand[1]->integer.value,
 				  &logical_result);
 		goto store_logical_result;
 	}
-	else if (walk_state->op_info->flags & AML_LOGICAL)  /* logical_op (Operand0, Operand1) */ {
+	else if (walk_state->op_info->flags & AML_LOGICAL) {
+		/* logical_op (Operand0, Operand1) */
+
 		status = acpi_ex_do_logical_op (walk_state->opcode, operand[0],
 				 operand[1], &logical_result);
 		goto store_logical_result;
 	}
-
 
 	switch (walk_state->opcode) {
 	case AML_ACQUIRE_OP:            /* Acquire (mutex_object, Timeout) */
diff -Nru a/drivers/acpi/executer/exoparg3.c b/drivers/acpi/executer/exoparg3.c
--- a/drivers/acpi/executer/exoparg3.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exoparg3.c	2005-04-19 01:34:14 -04:00
@@ -97,11 +97,12 @@
 	acpi_status                     status = AE_OK;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_0T_0R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
-	case AML_FATAL_OP:          /* Fatal (fatal_type fatal_code fatal_arg)   */
+	case AML_FATAL_OP:          /* Fatal (fatal_type fatal_code fatal_arg) */
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 			"fatal_op: Type %X Code %X Arg %X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
@@ -116,9 +117,8 @@
 			fatal->argument = (u32) operand[2]->integer.value;
 		}
 
-		/*
-		 * Always signal the OS!
-		 */
+		/* Always signal the OS! */
+
 		status = acpi_os_signal (ACPI_SIGNAL_FATAL, fatal);
 
 		/* Might return while OS is shutting down, just continue */
@@ -162,21 +162,23 @@
 	union acpi_operand_object       *return_desc = NULL;
 	char                            *buffer;
 	acpi_status                     status = AE_OK;
-	acpi_native_uint                index;
+	acpi_integer                    index;
 	acpi_size                       length;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_1T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
-	case AML_MID_OP:        /* Mid  (Source[0], Index[1], Length[2], Result[3]) */
+	case AML_MID_OP:    /* Mid (Source[0], Index[1], Length[2], Result[3]) */
 
 		/*
 		 * Create the return object.  The Source operand is guaranteed to be
 		 * either a String or a Buffer, so just use its type.
 		 */
-		return_desc = acpi_ut_create_internal_object (ACPI_GET_OBJECT_TYPE (operand[0]));
+		return_desc = acpi_ut_create_internal_object (
+				  ACPI_GET_OBJECT_TYPE (operand[0]));
 		if (!return_desc) {
 			status = AE_NO_MEMORY;
 			goto cleanup;
@@ -184,7 +186,7 @@
 
 		/* Get the Integer values from the objects */
 
-		index = (acpi_native_uint) operand[1]->integer.value;
+		index = operand[1]->integer.value;
 		length = (acpi_size) operand[2]->integer.value;
 
 		/*
@@ -197,7 +199,8 @@
 
 			if ((index + length) >
 				operand[0]->string.length) {
-				length = (acpi_size) operand[0]->string.length - index;
+				length = (acpi_size) operand[0]->string.length -
+						 (acpi_size) index;
 			}
 
 			/* Allocate a new buffer for the String/Buffer */
diff -Nru a/drivers/acpi/executer/exoparg6.c b/drivers/acpi/executer/exoparg6.c
--- a/drivers/acpi/executer/exoparg6.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exoparg6.c	2005-04-19 01:34:14 -04:00
@@ -75,6 +75,14 @@
  * fully resolved operands.
 !*/
 
+/* Local prototypes */
+
+static u8
+acpi_ex_do_match (
+	u32                             match_op,
+	union acpi_operand_object       *package_obj,
+	union acpi_operand_object       *match_obj);
+
 
 /*******************************************************************************
  *
@@ -92,7 +100,7 @@
  *
  ******************************************************************************/
 
-u8
+static u8
 acpi_ex_do_match (
 	u32                             match_op,
 	union acpi_operand_object       *package_obj,
@@ -216,11 +224,12 @@
 	union acpi_operand_object       **operand = &walk_state->operands[0];
 	union acpi_operand_object       *return_desc = NULL;
 	acpi_status                     status = AE_OK;
-	u32                             index;
+	acpi_integer                    index;
 	union acpi_operand_object       *this_element;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_6A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_6A_0T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
@@ -241,9 +250,11 @@
 
 		/* Get the package start_index, validate against the package length */
 
-		index = (u32) operand[5]->integer.value;
-		if (index >= (u32) operand[0]->package.count) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Index beyond package end\n"));
+		index = operand[5]->integer.value;
+		if (index >= operand[0]->package.count) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Index (%X%8.8X) beyond package end (%X)\n",
+				ACPI_FORMAT_UINT64 (index), operand[0]->package.count));
 			status = AE_AML_PACKAGE_LIMIT;
 			goto cleanup;
 		}
@@ -314,12 +325,11 @@
 
 	default:
 
-		ACPI_REPORT_ERROR (("acpi_ex_opcode_3A_0T_0R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_6A_0T_1R: Unknown opcode %X\n",
 				walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
-
 
 	walk_state->result_obj = return_desc;
 
diff -Nru a/drivers/acpi/executer/exprep.c b/drivers/acpi/executer/exprep.c
--- a/drivers/acpi/executer/exprep.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exprep.c	2005-04-19 01:34:14 -04:00
@@ -52,8 +52,23 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exprep")
 
+/* Local prototypes */
+
+static u32
+acpi_ex_decode_field_access (
+	union acpi_operand_object       *obj_desc,
+	u8                              field_flags,
+	u32                             *return_byte_alignment);
+
 
 #ifdef ACPI_UNDER_DEVELOPMENT
+
+static u32
+acpi_ex_generate_access (
+	u32                             field_bit_offset,
+	u32                             field_bit_length,
+	u32                             region_length);
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ex_generate_access
@@ -99,12 +114,14 @@
 	/* Round Field start offset and length to "minimal" byte boundaries */
 
 	field_byte_offset  = ACPI_DIV_8 (ACPI_ROUND_DOWN (field_bit_offset, 8));
-	field_byte_end_offset = ACPI_DIV_8 (ACPI_ROUND_UP (field_bit_length + field_bit_offset, 8));
+	field_byte_end_offset = ACPI_DIV_8 (ACPI_ROUND_UP (field_bit_length +
+			   field_bit_offset, 8));
 	field_byte_length  = field_byte_end_offset - field_byte_offset;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 			"Bit length %d, Bit offset %d\n",
 			field_bit_length, field_bit_offset));
+
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 			"Byte Length %d, Byte Offset %d, End Offset %d\n",
 			field_byte_length, field_byte_offset, field_byte_end_offset));
@@ -117,20 +134,26 @@
 	 */
 	for (access_byte_width = 1; access_byte_width <= 8; access_byte_width <<= 1) {
 		/*
-		 * 1) Round end offset up to next access boundary and make sure that this
-		 *    does not go beyond the end of the parent region.
-		 * 2) When the Access width is greater than the field_byte_length, we are done.
-		 *    (This does not optimize for the perfectly aligned case yet).
+		 * 1) Round end offset up to next access boundary and make sure that
+		 *    this does not go beyond the end of the parent region.
+		 * 2) When the Access width is greater than the field_byte_length, we
+		 *    are done. (This does not optimize for the perfectly aligned
+		 *    case yet).
 		 */
 		if (ACPI_ROUND_UP (field_byte_end_offset, access_byte_width) <= region_length) {
-			field_start_offset = ACPI_ROUND_DOWN (field_byte_offset, access_byte_width) /
-					  access_byte_width;
-			field_end_offset = ACPI_ROUND_UP   ((field_byte_length + field_byte_offset),
-					  access_byte_width) / access_byte_width;
-			accesses         = field_end_offset - field_start_offset;
+			field_start_offset =
+				ACPI_ROUND_DOWN (field_byte_offset, access_byte_width) /
+				access_byte_width;
+
+			field_end_offset =
+				ACPI_ROUND_UP ((field_byte_length + field_byte_offset),
+					access_byte_width) / access_byte_width;
+
+			accesses = field_end_offset - field_start_offset;
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 					"access_width %d end is within region\n", access_byte_width));
+
 			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 					"Field Start %d, Field End %d -- requires %d accesses\n",
 					field_start_offset, field_end_offset, accesses));
@@ -139,8 +162,8 @@
 
 			if (accesses <= 1) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-						"Entire field can be accessed with one operation of size %d\n",
-						access_byte_width));
+					"Entire field can be accessed with one operation of size %d\n",
+					access_byte_width));
 				return_VALUE (access_byte_width);
 			}
 
@@ -155,15 +178,20 @@
 		}
 		else {
 			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-					"access_width %d end is NOT within region\n", access_byte_width));
+				"access_width %d end is NOT within region\n", access_byte_width));
 			if (access_byte_width == 1) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 						"Field goes beyond end-of-region!\n"));
-				return_VALUE (0);     /* Field does not fit in the region at all */
-			}
 
-			/* This width goes beyond the end-of-region, back off to previous access */
+				/* Field does not fit in the region at all */
 
+				return_VALUE (0);
+			}
+
+			/*
+			 * This width goes beyond the end-of-region, back off to
+			 * previous access
+			 */
 			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 					"Backing off to previous optimal access width of %d\n",
 					minimum_access_width));
@@ -171,8 +199,10 @@
 		}
 	}
 
-	/* Could not read/write field with one operation, just use max access width */
-
+	/*
+	 * Could not read/write field with one operation,
+	 * just use max access width
+	 */
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 			"Cannot access field in one operation, using width 8\n"));
 	return_VALUE (8);
@@ -184,8 +214,9 @@
  *
  * FUNCTION:    acpi_ex_decode_field_access
  *
- * PARAMETERS:  Access          - Encoded field access bits
- *              Length          - Field length.
+ * PARAMETERS:  obj_desc            - Field object
+ *              field_flags         - Encoded fieldflags (contains access bits)
+ *              return_byte_alignment - Where the byte alignment is returned
  *
  * RETURN:      Field granularity (8, 16, 32 or 64) and
  *              byte_alignment (1, 2, 3, or 4)
@@ -214,9 +245,10 @@
 	case AML_FIELD_ACCESS_ANY:
 
 #ifdef ACPI_UNDER_DEVELOPMENT
-		byte_alignment = acpi_ex_generate_access (obj_desc->common_field.start_field_bit_offset,
-				 obj_desc->common_field.bit_length,
-				 0xFFFFFFFF /* Temp until we pass region_length as param */);
+		byte_alignment =
+			acpi_ex_generate_access (obj_desc->common_field.start_field_bit_offset,
+				obj_desc->common_field.bit_length,
+				0xFFFFFFFF /* Temp until we pass region_length as parameter */);
 		bit_length = byte_alignment * 8;
 #endif
 
@@ -276,6 +308,7 @@
  *              field_flags         - Access, lock_rule, and update_rule.
  *                                    The format of a field_flag is described
  *                                    in the ACPI specification
+ *              field_attribute     - Special attributes (not used)
  *              field_bit_position  - Field start position
  *              field_bit_length    - Field length in number of bits
  *
@@ -337,7 +370,7 @@
 	/* Setup width (access granularity) fields */
 
 	obj_desc->common_field.access_byte_width = (u8)
-			ACPI_DIV_8 (access_bit_width); /* 1, 2, 4,  8 */
+			ACPI_DIV_8 (access_bit_width);          /* 1,  2,  4,  8 */
 
 	obj_desc->common_field.access_bit_width = (u8) access_bit_width;
 
@@ -380,11 +413,7 @@
  *
  * FUNCTION:    acpi_ex_prep_field_value
  *
- * PARAMETERS:  Node                - Owning Node
- *              region_node         - Region in which field is being defined
- *              field_flags         - Access, lock_rule, and update_rule.
- *              field_bit_position  - Field start position
- *              field_bit_length    - Field length in number of bits
+ * PARAMETERS:  Info    - Contains all field creation info
  *
  * RETURN:      Status
  *
@@ -445,7 +474,7 @@
 	switch (info->field_type) {
 	case ACPI_TYPE_LOCAL_REGION_FIELD:
 
-		obj_desc->field.region_obj   = acpi_ns_get_attached_object (info->region_node);
+		obj_desc->field.region_obj = acpi_ns_get_attached_object (info->region_node);
 
 		/* An additional reference for the container */
 
@@ -461,8 +490,10 @@
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
 
 		obj_desc->bank_field.value   = info->bank_value;
-		obj_desc->bank_field.region_obj = acpi_ns_get_attached_object (info->region_node);
-		obj_desc->bank_field.bank_obj = acpi_ns_get_attached_object (info->register_node);
+		obj_desc->bank_field.region_obj = acpi_ns_get_attached_object (
+				 info->region_node);
+		obj_desc->bank_field.bank_obj = acpi_ns_get_attached_object (
+				 info->register_node);
 
 		/* An additional reference for the attached objects */
 
@@ -481,10 +512,13 @@
 
 	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-		obj_desc->index_field.index_obj = acpi_ns_get_attached_object (info->register_node);
-		obj_desc->index_field.data_obj = acpi_ns_get_attached_object (info->data_register_node);
+		obj_desc->index_field.index_obj = acpi_ns_get_attached_object (
+				 info->register_node);
+		obj_desc->index_field.data_obj = acpi_ns_get_attached_object (
+				 info->data_register_node);
 		obj_desc->index_field.value  = (u32)
-			(info->field_bit_position / ACPI_MUL_8 (obj_desc->field.access_byte_width));
+			(info->field_bit_position / ACPI_MUL_8 (
+					  obj_desc->field.access_byte_width));
 
 		if (!obj_desc->index_field.data_obj || !obj_desc->index_field.index_obj) {
 			ACPI_REPORT_ERROR (("Null Index Object during field prep\n"));
diff -Nru a/drivers/acpi/executer/exregion.c b/drivers/acpi/executer/exregion.c
--- a/drivers/acpi/executer/exregion.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exregion.c	2005-04-19 01:34:14 -04:00
@@ -115,7 +115,6 @@
 		return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
 	}
 
-
 #ifndef ACPI_MISALIGNED_TRANSFERS
 	/*
 	 * Hardware does not support non-aligned data transfers, we must verify
@@ -134,7 +133,8 @@
 	 */
 	if ((address < mem_info->mapped_physical_address) ||
 		(((acpi_integer) address + length) >
-			((acpi_integer) mem_info->mapped_physical_address + mem_info->mapped_length))) {
+			((acpi_integer)
+			mem_info->mapped_physical_address + mem_info->mapped_length))) {
 		/*
 		 * The request cannot be resolved by the current memory mapping;
 		 * Delete the existing mapping and create a new one.
@@ -150,7 +150,9 @@
 		 * Don't attempt to map memory beyond the end of the region, and
 		 * constrain the maximum mapping size to something reasonable.
 		 */
-		window_size = (acpi_size) ((mem_info->address + mem_info->length) - address);
+		window_size = (acpi_size)
+			((mem_info->address + mem_info->length) - address);
+
 		if (window_size > ACPI_SYSMEM_REGION_WINDOW_SIZE) {
 			window_size = ACPI_SYSMEM_REGION_WINDOW_SIZE;
 		}
@@ -160,8 +162,9 @@
 		status = acpi_os_map_memory (address, window_size,
 				  (void **) &mem_info->mapped_logical_address);
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not map memory at %8.8X%8.8X, size %X\n",
-					ACPI_FORMAT_UINT64 (address), (u32) window_size));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not map memory at %8.8X%8.8X, size %X\n",
+				ACPI_FORMAT_UINT64 (address), (u32) window_size));
 			mem_info->mapped_length = 0;
 			return_ACPI_STATUS (status);
 		}
@@ -177,10 +180,12 @@
 	 * access
 	 */
 	logical_addr_ptr = mem_info->mapped_logical_address +
-			  ((acpi_integer) address - (acpi_integer) mem_info->mapped_physical_address);
+			   ((acpi_integer) address -
+					  (acpi_integer) mem_info->mapped_physical_address);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"system_memory %d (%d width) Address=%8.8X%8.8X\n", function, bit_width,
+			"system_memory %d (%d width) Address=%8.8X%8.8X\n",
+			function, bit_width,
 			ACPI_FORMAT_UINT64 (address)));
 
    /*
@@ -298,13 +303,15 @@
 	switch (function) {
 	case ACPI_READ:
 
-		status = acpi_os_read_port ((acpi_io_address) address, &value32, bit_width);
+		status = acpi_os_read_port ((acpi_io_address) address,
+				 &value32, bit_width);
 		*value = value32;
 		break;
 
 	case ACPI_WRITE:
 
-		status = acpi_os_write_port ((acpi_io_address) address, (u32) *value, bit_width);
+		status = acpi_os_write_port ((acpi_io_address) address,
+				 (u32) *value, bit_width);
 		break;
 
 	default:
@@ -375,12 +382,14 @@
 	case ACPI_READ:
 
 		*value = 0;
-		status = acpi_os_read_pci_configuration (pci_id, pci_register, value, bit_width);
+		status = acpi_os_read_pci_configuration (pci_id, pci_register,
+				 value, bit_width);
 		break;
 
 	case ACPI_WRITE:
 
-		status = acpi_os_write_pci_configuration (pci_id, pci_register, *value, bit_width);
+		status = acpi_os_write_pci_configuration (pci_id, pci_register,
+				 *value, bit_width);
 		break;
 
 	default:
@@ -505,8 +514,7 @@
 
 	logical_addr_ptr = ACPI_PHYSADDR_TO_PTR (address);
 
-
-   /* Perform the memory read or write */
+	/* Perform the memory read or write */
 
 	switch (function) {
 	case ACPI_READ:
diff -Nru a/drivers/acpi/executer/exresnte.c b/drivers/acpi/executer/exresnte.c
--- a/drivers/acpi/executer/exresnte.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exresnte.c	2005-04-19 01:34:14 -04:00
@@ -210,15 +210,15 @@
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
 	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "field_read Node=%p source_desc=%p Type=%X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"field_read Node=%p source_desc=%p Type=%X\n",
 			node, source_desc, entry_type));
 
 		status = acpi_ex_read_data_from_field (walk_state, source_desc, &obj_desc);
 		break;
 
-	/*
-	 * For these objects, just return the object attached to the Node
-	 */
+	/* For these objects, just return the object attached to the Node */
+
 	case ACPI_TYPE_MUTEX:
 	case ACPI_TYPE_METHOD:
 	case ACPI_TYPE_POWER:
@@ -233,12 +233,12 @@
 		acpi_ut_add_reference (obj_desc);
 		break;
 
-
 	/* TYPE_ANY is untyped, and thus there is no object associated with it */
 
 	case ACPI_TYPE_ANY:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Untyped entry %p, no attached object!\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Untyped entry %p, no attached object!\n",
 			node));
 
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);  /* Cannot be AE_TYPE */
@@ -259,7 +259,8 @@
 		default:
 			/* No named references are allowed here */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unsupported Reference opcode %X (%s)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Unsupported Reference opcode %X (%s)\n",
 				source_desc->reference.opcode,
 				acpi_ps_get_opcode_name (source_desc->reference.opcode)));
 
@@ -268,11 +269,12 @@
 		break;
 
 
-	/* Default case is for unknown types */
-
 	default:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Node %p - Unknown object type %X\n",
+		/* Default case is for unknown types */
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Node %p - Unknown object type %X\n",
 			node, entry_type));
 
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
@@ -280,7 +282,7 @@
 	} /* switch (entry_type) */
 
 
-	/* Put the object descriptor on the stack */
+	/* Return the object descriptor */
 
 	*object_ptr = (void *) obj_desc;
 	return_ACPI_STATUS (status);
diff -Nru a/drivers/acpi/executer/exresolv.c b/drivers/acpi/executer/exresolv.c
--- a/drivers/acpi/executer/exresolv.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exresolv.c	2005-04-19 01:34:14 -04:00
@@ -54,6 +54,13 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exresolv")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ex_resolve_object_to_value (
+	union acpi_operand_object       **stack_ptr,
+	struct acpi_walk_state          *walk_state);
+
 
 /*******************************************************************************
  *
@@ -96,6 +103,11 @@
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
+
+		if (!*stack_ptr) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - null pointer\n"));
+			return_ACPI_STATUS (AE_AML_NO_OPERAND);
+		}
 	}
 
 	/*
@@ -120,18 +132,17 @@
  *
  * FUNCTION:    acpi_ex_resolve_object_to_value
  *
- * PARAMETERS:  stack_ptr       - Pointer to a stack location that contains a
- *                                ptr to an internal object.
+ * PARAMETERS:  stack_ptr       - Pointer to an internal object
  *              walk_state      - Current method state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Retrieve the value from an internal object.  The Reference type
+ * DESCRIPTION: Retrieve the value from an internal object. The Reference type
  *              uses the associated AML opcode to determine the value.
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_resolve_object_to_value (
 	union acpi_operand_object       **stack_ptr,
 	struct acpi_walk_state          *walk_state)
@@ -159,7 +170,7 @@
 		case AML_NAME_OP:
 
 			/*
-			 * Convert indirect name ptr to a direct name ptr.
+			 * Convert name reference to a namespace node
 			 * Then, acpi_ex_resolve_node_to_value can be used to get the value
 			 */
 			temp_node = stack_desc->reference.object;
@@ -168,7 +179,7 @@
 
 			acpi_ut_remove_reference (stack_desc);
 
-			/* Put direct name pointer onto stack and exit */
+			/* Return the namespace node */
 
 			(*stack_ptr) = temp_node;
 			break;
@@ -255,10 +266,19 @@
 
 			break;
 
+		case AML_INT_NAMEPATH_OP:   /* Reference to a named object */
+
+			/* Get the object pointed to by the namespace node */
+
+			*stack_ptr = (stack_desc->reference.node)->object;
+			acpi_ut_add_reference (*stack_ptr);
+			acpi_ut_remove_reference (stack_desc);
+			break;
 
 		default:
 
-			ACPI_REPORT_ERROR (("During resolve, Unknown Reference opcode %X (%s) in %p\n",
+			ACPI_REPORT_ERROR ((
+				"During resolve, Unknown Reference opcode %X (%s) in %p\n",
 				opcode, acpi_ps_get_opcode_name (opcode), stack_desc));
 			status = AE_AML_INTERNAL;
 			break;
@@ -278,9 +298,8 @@
 		break;
 
 
-	/*
-	 * These cases may never happen here, but just in case..
-	 */
+	/* These cases may never happen here, but just in case.. */
+
 	case ACPI_TYPE_BUFFER_FIELD:
 	case ACPI_TYPE_LOCAL_REGION_FIELD:
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
@@ -333,9 +352,8 @@
 	ACPI_FUNCTION_TRACE ("acpi_ex_resolve_multiple");
 
 
-	/*
-	 * Operand can be either a namespace node or an operand descriptor
-	 */
+	/* Operand can be either a namespace node or an operand descriptor */
+
 	switch (ACPI_GET_DESCRIPTOR_TYPE (obj_desc)) {
 	case ACPI_DESC_TYPE_OPERAND:
 		type = obj_desc->common.type;
@@ -357,10 +375,8 @@
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 	}
 
+	/* If type is anything other than a reference, we are done */
 
-	/*
-	 * If type is anything other than a reference, we are done
-	 */
 	if (type != ACPI_TYPE_LOCAL_REFERENCE) {
 		goto exit;
 	}
@@ -382,8 +398,9 @@
 			/* All "References" point to a NS node */
 
 			if (ACPI_GET_DESCRIPTOR_TYPE (node) != ACPI_DESC_TYPE_NAMED) {
-				ACPI_REPORT_ERROR (("acpi_ex_resolve_multiple: Not a NS node %p [%s]\n",
-						node, acpi_ut_get_descriptor_name (node)));
+				ACPI_REPORT_ERROR ((
+					"acpi_ex_resolve_multiple: Not a NS node %p [%s]\n",
+					node, acpi_ut_get_descriptor_name (node)));
 				return_ACPI_STATUS (AE_AML_INTERNAL);
 			}
 
@@ -440,8 +457,9 @@
 			/* All "References" point to a NS node */
 
 			if (ACPI_GET_DESCRIPTOR_TYPE (node) != ACPI_DESC_TYPE_NAMED) {
-				ACPI_REPORT_ERROR (("acpi_ex_resolve_multiple: Not a NS node %p [%s]\n",
-						node, acpi_ut_get_descriptor_name (node)));
+				ACPI_REPORT_ERROR ((
+					"acpi_ex_resolve_multiple: Not a NS node %p [%s]\n",
+					node, acpi_ut_get_descriptor_name (node)));
 			   return_ACPI_STATUS (AE_AML_INTERNAL);
 			}
 
@@ -468,7 +486,7 @@
 
 			if (return_desc) {
 				status = acpi_ds_method_data_get_value (obj_desc->reference.opcode,
-						  obj_desc->reference.offset, walk_state, &obj_desc);
+						 obj_desc->reference.offset, walk_state, &obj_desc);
 				if (ACPI_FAILURE (status)) {
 					return_ACPI_STATUS (status);
 				}
@@ -500,7 +518,8 @@
 
 		default:
 
-			ACPI_REPORT_ERROR (("acpi_ex_resolve_multiple: Unknown Reference subtype %X\n",
+			ACPI_REPORT_ERROR ((
+				"acpi_ex_resolve_multiple: Unknown Reference subtype %X\n",
 				obj_desc->reference.opcode));
 			return_ACPI_STATUS (AE_AML_INTERNAL);
 		}
diff -Nru a/drivers/acpi/executer/exresop.c b/drivers/acpi/executer/exresop.c
--- a/drivers/acpi/executer/exresop.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exresop.c	2005-04-19 01:34:14 -04:00
@@ -52,6 +52,14 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exresop")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ex_check_object_type (
+	acpi_object_type                type_needed,
+	acpi_object_type                this_type,
+	void                            *object);
+
 
 /*******************************************************************************
  *
@@ -67,7 +75,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_check_object_type (
 	acpi_object_type                type_needed,
 	acpi_object_type                this_type,
@@ -142,6 +150,7 @@
 	const struct acpi_opcode_info   *op_info;
 	u32                             this_arg_type;
 	acpi_object_type                type_needed;
+	u16                             target_op = 0;
 
 
 	ACPI_FUNCTION_TRACE_U32 ("ex_resolve_operands", opcode);
@@ -160,7 +169,8 @@
 		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Opcode %X [%s] required_operand_types=%8.8X \n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+		"Opcode %X [%s] required_operand_types=%8.8X \n",
 		opcode, op_info->name, arg_types));
 
 	/*
@@ -187,7 +197,7 @@
 		switch (ACPI_GET_DESCRIPTOR_TYPE (obj_desc)) {
 		case ACPI_DESC_TYPE_NAMED:
 
-			/* Node */
+			/* Namespace Node */
 
 			object_type = ((struct acpi_namespace_node *) obj_desc)->type;
 			break;
@@ -202,16 +212,16 @@
 			/* Check for bad acpi_object_type */
 
 			if (!acpi_ut_valid_object_type (object_type)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Bad operand object type [%X]\n",
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Bad operand object type [%X]\n",
 					object_type));
 
 				return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 			}
 
 			if (object_type == (u8) ACPI_TYPE_LOCAL_REFERENCE) {
-				/*
-				 * Decode the Reference
-				 */
+				/* Decode the Reference */
+
 				op_info = acpi_ps_get_opcode_info (opcode);
 				if (op_info->class == AML_CLASS_UNKNOWN) {
 					return_ACPI_STATUS (AE_AML_BAD_OPCODE);
@@ -219,12 +229,17 @@
 
 				switch (obj_desc->reference.opcode) {
 				case AML_DEBUG_OP:
+					target_op = AML_DEBUG_OP;
+
+					/*lint -fallthrough */
+
 				case AML_NAME_OP:
 				case AML_INDEX_OP:
 				case AML_REF_OF_OP:
 				case AML_ARG_OP:
 				case AML_LOCAL_OP:
-				case AML_LOAD_OP:   /* ddb_handle from LOAD_OP or LOAD_TABLE_OP */
+				case AML_LOAD_OP: /* ddb_handle from LOAD_OP or LOAD_TABLE_OP */
+				case AML_INT_NAMEPATH_OP: /* Reference to a named object */
 
 					ACPI_DEBUG_ONLY_MEMBERS (ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 						"Operand is a Reference, ref_opcode [%s]\n",
@@ -254,10 +269,8 @@
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
+		/* Get one argument type, point to the next */
 
-		/*
-		 * Get one argument type, point to the next
-		 */
 		this_arg_type = GET_CURRENT_ARG_TYPE (arg_types);
 		INCREMENT_ARG_LIST (arg_types);
 
@@ -271,26 +284,31 @@
 			if ((ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_OPERAND) &&
 				(ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_STRING)) {
 				/*
-				 * String found - the string references a named object and must be
-				 * resolved to a node
+				 * String found - the string references a named object and
+				 * must be resolved to a node
 				 */
 				goto next_operand;
 			}
 
-			/* Else not a string - fall through to the normal Reference case below */
+			/*
+			 * Else not a string - fall through to the normal Reference
+			 * case below
+			 */
 			/*lint -fallthrough */
 
 		case ARGI_REFERENCE:            /* References: */
 		case ARGI_INTEGER_REF:
 		case ARGI_OBJECT_REF:
 		case ARGI_DEVICE_REF:
-		case ARGI_TARGETREF:            /* Allows implicit conversion rules before store */
-		case ARGI_FIXED_TARGET:         /* No implicit conversion before store to target */
-		case ARGI_SIMPLE_TARGET:        /* Name, Local, or Arg - no implicit conversion  */
-
-			/* Need an operand of type ACPI_TYPE_LOCAL_REFERENCE */
+		case ARGI_TARGETREF:     /* Allows implicit conversion rules before store */
+		case ARGI_FIXED_TARGET:  /* No implicit conversion before store to target */
+		case ARGI_SIMPLE_TARGET: /* Name, Local, or Arg - no implicit conversion  */
 
-			if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) /* Node (name) ptr OK as-is */ {
+			/*
+			 * Need an operand of type ACPI_TYPE_LOCAL_REFERENCE
+			 * A Namespace Node is OK as-is
+			 */
+			if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) {
 				goto next_operand;
 			}
 
@@ -300,11 +318,9 @@
 				return_ACPI_STATUS (status);
 			}
 
-			if (AML_NAME_OP == obj_desc->reference.opcode) {
-				/*
-				 * Convert an indirect name ptr to direct name ptr and put
-				 * it on the stack
-				 */
+			if (obj_desc->reference.opcode == AML_NAME_OP) {
+				/* Convert a named reference to the actual named object */
+
 				temp_node = obj_desc->reference.object;
 				acpi_ut_remove_reference (obj_desc);
 				(*stack_ptr) = temp_node;
@@ -332,7 +348,6 @@
 			break;
 		}
 
-
 		/*
 		 * Resolve this object to a value
 		 */
@@ -392,7 +407,7 @@
 		/*
 		 * The more complex cases allow multiple resolved object types
 		 */
-		case ARGI_INTEGER:   /* Number */
+		case ARGI_INTEGER:
 
 			/*
 			 * Need an operand of type ACPI_TYPE_INTEGER,
@@ -563,7 +578,7 @@
 
 		case ARGI_REGION_OR_FIELD:
 
-			/* Need an operand of type ACPI_TYPE_REGION or a FIELD in a region */
+			/* Need an operand of type REGION or a FIELD in a region */
 
 			switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 			case ACPI_TYPE_REGION:
@@ -614,6 +629,12 @@
 					break;
 				}
 
+				if (target_op == AML_DEBUG_OP) {
+					/* Allow store of any object to the Debug object */
+
+					break;
+				}
+
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 					"Needed Integer/Buffer/String/Package/Ref/Ddb], found [%s] %p\n",
 					acpi_ut_get_object_type_name (obj_desc), obj_desc));
@@ -652,8 +673,7 @@
 		if (GET_CURRENT_ARG_TYPE (arg_types)) {
 			stack_ptr--;
 		}
-
-	}   /* while (*Types) */
+	}
 
 	return_ACPI_STATUS (status);
 }
diff -Nru a/drivers/acpi/executer/exstore.c b/drivers/acpi/executer/exstore.c
--- a/drivers/acpi/executer/exstore.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exstore.c	2005-04-19 01:34:14 -04:00
@@ -48,11 +48,171 @@
 #include <acpi/acinterp.h>
 #include <acpi/amlcode.h>
 #include <acpi/acnamesp.h>
+#include <acpi/acparser.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exstore")
 
+/* Local prototypes */
+
+static void
+acpi_ex_do_debug_object (
+	union acpi_operand_object       *source_desc,
+	u32                             level,
+	u32                             index);
+
+static acpi_status
+acpi_ex_store_object_to_index (
+	union acpi_operand_object       *val_desc,
+	union acpi_operand_object       *dest_desc,
+	struct acpi_walk_state          *walk_state);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_debug_object
+ *
+ * PARAMETERS:  source_desc         - Value to be stored
+ *              Level               - Indentation level (used for packages)
+ *              Index               - Current package element, zero if not pkg
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Handles stores to the Debug Object.
+ *
+ ******************************************************************************/
+
+static void
+acpi_ex_do_debug_object (
+	union acpi_operand_object       *source_desc,
+	u32                             level,
+	u32                             index)
+{
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ex_do_debug_object", source_desc);
+
+
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[ACPI Debug] %*s",
+		level, " "));
+
+	/* Display index for package output only */
+
+	if (index > 0) {
+	   ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT,
+		   "(%.2u) ", index -1));
+	}
+
+	if (!source_desc) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "<Null Object>\n"));
+		return_VOID;
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE (source_desc) == ACPI_DESC_TYPE_OPERAND) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%s: ",
+			acpi_ut_get_object_type_name (source_desc)));
+
+		if (!acpi_ut_valid_internal_object (source_desc)) {
+		   ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT,
+			   "%p, Invalid Internal Object!\n", source_desc));
+		   return_VOID;
+		}
+	}
+	else if (ACPI_GET_DESCRIPTOR_TYPE (source_desc) == ACPI_DESC_TYPE_NAMED) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%s: %p\n",
+			acpi_ut_get_type_name (((struct acpi_namespace_node *) source_desc)->type),
+			source_desc));
+		return_VOID;
+	}
+	else {
+		return_VOID;
+	}
+
+	switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
+	case ACPI_TYPE_INTEGER:
+
+		/* Output correct integer width */
+
+		if (acpi_gbl_integer_byte_width == 4) {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%8.8X\n",
+				(u32) source_desc->integer.value));
+		}
+		else {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%8.8X%8.8X\n",
+				ACPI_FORMAT_UINT64 (source_desc->integer.value)));
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X]",
+			(u32) source_desc->buffer.length));
+		ACPI_DUMP_BUFFER (source_desc->buffer.pointer,
+			(source_desc->buffer.length < 32) ? source_desc->buffer.length : 32);
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X] \"%s\"\n",
+			source_desc->string.length, source_desc->string.pointer));
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X Elements]\n",
+			source_desc->package.count));
+
+		/* Output the entire contents of the package */
+
+		for (i = 0; i < source_desc->package.count; i++) {
+			acpi_ex_do_debug_object (source_desc->package.elements[i],
+				level+4, i+1);
+		}
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		if (source_desc->reference.opcode == AML_INDEX_OP) {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[%s, 0x%X]\n",
+				acpi_ps_get_opcode_name (source_desc->reference.opcode),
+				source_desc->reference.offset));
+		}
+		else {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[%s]\n",
+				acpi_ps_get_opcode_name (source_desc->reference.opcode)));
+		}
+
+
+		if (source_desc->reference.object) {
+			if (ACPI_GET_DESCRIPTOR_TYPE (source_desc->reference.object) ==
+					ACPI_DESC_TYPE_NAMED) {
+				acpi_ex_do_debug_object (((struct acpi_namespace_node *)
+					source_desc->reference.object)->object,
+					level+4, 0);
+			}
+			else {
+				acpi_ex_do_debug_object (source_desc->reference.object, level+4, 0);
+			}
+		}
+		else if (source_desc->reference.node) {
+			acpi_ex_do_debug_object ((source_desc->reference.node)->object,
+				level+4, 0);
+		}
+		break;
+
+	default:
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%p %s\n",
+			source_desc, acpi_ut_get_object_type_name (source_desc)));
+		break;
+	}
+
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC, "\n"));
+	return_VOID;
+}
+
 
 /*******************************************************************************
  *
@@ -154,8 +314,9 @@
 
 		/* Storing an object into a Name "container" */
 
-		status = acpi_ex_store_object_to_node (source_desc, ref_desc->reference.object,
-				  walk_state, ACPI_IMPLICIT_CONVERSION);
+		status = acpi_ex_store_object_to_node (source_desc,
+				 ref_desc->reference.object,
+				 walk_state, ACPI_IMPLICIT_CONVERSION);
 		break;
 
 
@@ -173,7 +334,7 @@
 		/* Store to a method local/arg  */
 
 		status = acpi_ds_store_object_to_local (ref_desc->reference.opcode,
-				  ref_desc->reference.offset, source_desc, walk_state);
+				 ref_desc->reference.offset, source_desc, walk_state);
 		break;
 
 
@@ -187,60 +348,7 @@
 			"**** Write to Debug Object: Object %p %s ****:\n\n",
 			source_desc, acpi_ut_get_object_type_name (source_desc)));
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[ACPI Debug] %s: ",
-			acpi_ut_get_object_type_name (source_desc)));
-
-		if (!acpi_ut_valid_internal_object (source_desc)) {
-		   ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT,
-			   "%p, Invalid Internal Object!\n", source_desc));
-		   break;
-		}
-
-		switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
-		case ACPI_TYPE_INTEGER:
-
-			if (acpi_gbl_integer_byte_width == 4) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%8.8X\n",
-					(u32) source_desc->integer.value));
-			}
-			else {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%8.8X%8.8X\n",
-					ACPI_FORMAT_UINT64 (source_desc->integer.value)));
-			}
-			break;
-
-
-		case ACPI_TYPE_BUFFER:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X]",
-				(u32) source_desc->buffer.length));
-			ACPI_DUMP_BUFFER (source_desc->buffer.pointer,
-				(source_desc->buffer.length < 32) ? source_desc->buffer.length : 32);
-			break;
-
-
-		case ACPI_TYPE_STRING:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X] \"%s\"\n",
-				source_desc->string.length, source_desc->string.pointer));
-			break;
-
-
-		case ACPI_TYPE_PACKAGE:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X] Elements Ptr - %p\n",
-				source_desc->package.count, source_desc->package.elements));
-			break;
-
-
-		default:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%p\n",
-				source_desc));
-			break;
-		}
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC, "\n"));
+		acpi_ex_do_debug_object (source_desc, 0, 0);
 		break;
 
 
@@ -272,7 +380,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_store_object_to_index (
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       *index_desc,
@@ -313,16 +421,22 @@
 		if (obj_desc) {
 			/* Decrement reference count by the ref count of the parent package */
 
-			for (i = 0; i < ((union acpi_operand_object *) index_desc->reference.object)->common.reference_count; i++) {
+			for (i = 0;
+				 i < ((union acpi_operand_object *)
+						index_desc->reference.object)->common.reference_count;
+				 i++) {
 				acpi_ut_remove_reference (obj_desc);
 			}
 		}
 
 		*(index_desc->reference.where) = new_desc;
 
-		/* Increment reference count by the ref count of the parent package -1 */
+		/* Increment ref count by the ref count of the parent package-1 */
 
-		for (i = 1; i < ((union acpi_operand_object *) index_desc->reference.object)->common.reference_count; i++) {
+		for (i = 1;
+			 i < ((union acpi_operand_object *)
+					index_desc->reference.object)->common.reference_count;
+			 i++) {
 			acpi_ut_add_reference (new_desc);
 		}
 
@@ -440,9 +554,8 @@
 	ACPI_FUNCTION_TRACE_PTR ("ex_store_object_to_node", source_desc);
 
 
-	/*
-	 * Get current type of the node, and object attached to Node
-	 */
+	/* Get current type of the node, and object attached to Node */
+
 	target_type = acpi_ns_get_type (node);
 	target_desc = acpi_ns_get_attached_object (node);
 
@@ -467,19 +580,18 @@
 		target_type = ACPI_TYPE_ANY;
 	}
 
-	/*
-	 * Do the actual store operation
-	 */
+	/* Do the actual store operation */
+
 	switch (target_type) {
 	case ACPI_TYPE_BUFFER_FIELD:
 	case ACPI_TYPE_LOCAL_REGION_FIELD:
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
 	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-		/*
-		 * For fields, copy the source data to the target field.
-		 */
-		status = acpi_ex_write_data_to_field (source_desc, target_desc, &walk_state->result_obj);
+		/* For fields, copy the source data to the target field. */
+
+		status = acpi_ex_write_data_to_field (source_desc, target_desc,
+				 &walk_state->result_obj);
 		break;
 
 
@@ -493,7 +605,8 @@
 		 *
 		 * Copy and/or convert the source object to a new target object
 		 */
-		status = acpi_ex_store_object_to_object (source_desc, target_desc, &new_desc, walk_state);
+		status = acpi_ex_store_object_to_object (source_desc, target_desc,
+				 &new_desc, walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -526,7 +639,8 @@
 
 		/* No conversions for all other types.  Just attach the source object */
 
-		status = acpi_ns_attach_object (node, source_desc, ACPI_GET_OBJECT_TYPE (source_desc));
+		status = acpi_ns_attach_object (node, source_desc,
+				 ACPI_GET_OBJECT_TYPE (source_desc));
 		break;
 	}
 
diff -Nru a/drivers/acpi/executer/exstoren.c b/drivers/acpi/executer/exstoren.c
--- a/drivers/acpi/executer/exstoren.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exstoren.c	2005-04-19 01:34:14 -04:00
@@ -81,9 +81,8 @@
 	ACPI_FUNCTION_TRACE ("ex_resolve_object");
 
 
-	/*
-	 * Ensure we have a Target that can be stored to
-	 */
+	/* Ensure we have a Target that can be stored to */
+
 	switch (target_type) {
 	case ACPI_TYPE_BUFFER_FIELD:
 	case ACPI_TYPE_LOCAL_REGION_FIELD:
@@ -118,16 +117,14 @@
 			break;
 		}
 
-		/*
-		 * Must have a Integer, Buffer, or String
-		 */
+		/* Must have a Integer, Buffer, or String */
+
 		if ((ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_INTEGER)   &&
 			(ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_BUFFER)    &&
 			(ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_STRING)    &&
 			!((ACPI_GET_OBJECT_TYPE (source_desc) == ACPI_TYPE_LOCAL_REFERENCE) && (source_desc->reference.opcode == AML_LOAD_OP))) {
-			/*
-			 * Conversion successful but still not a valid type
-			 */
+			/* Conversion successful but still not a valid type */
+
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Cannot assign type %s to %s (must be type Int/Str/Buf)\n",
 				acpi_ut_get_object_type_name (source_desc),
@@ -140,9 +137,8 @@
 	case ACPI_TYPE_LOCAL_ALIAS:
 	case ACPI_TYPE_LOCAL_METHOD_ALIAS:
 
-		/*
-		 * Aliases are resolved by acpi_ex_prep_operands
-		 */
+		/* Aliases are resolved by acpi_ex_prep_operands */
+
 		ACPI_REPORT_ERROR (("Store into Alias - should never happen\n"));
 		status = AE_AML_INTERNAL;
 		break;
diff -Nru a/drivers/acpi/executer/exstorob.c b/drivers/acpi/executer/exstorob.c
--- a/drivers/acpi/executer/exstorob.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exstorob.c	2005-04-19 01:34:14 -04:00
@@ -128,7 +128,8 @@
 	else {
 		/* Truncate the source, copy only what will fit */
 
-		ACPI_MEMCPY (target_desc->buffer.pointer, buffer, target_desc->buffer.length);
+		ACPI_MEMCPY (target_desc->buffer.pointer, buffer,
+			target_desc->buffer.length);
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 			"Truncating source buffer from %X to %X\n",
@@ -183,7 +184,8 @@
 		 * String will fit in existing non-static buffer.
 		 * Clear old string and copy in the new one
 		 */
-		ACPI_MEMSET (target_desc->string.pointer, 0, (acpi_size) target_desc->string.length + 1);
+		ACPI_MEMSET (target_desc->string.pointer, 0,
+			(acpi_size) target_desc->string.length + 1);
 		ACPI_MEMCPY (target_desc->string.pointer, buffer, length);
 	}
 	else {
@@ -198,7 +200,8 @@
 			ACPI_MEM_FREE (target_desc->string.pointer);
 		}
 
-		target_desc->string.pointer = ACPI_MEM_CALLOCATE ((acpi_size) length + 1);
+		target_desc->string.pointer = ACPI_MEM_CALLOCATE (
+				   (acpi_size) length + 1);
 		if (!target_desc->string.pointer) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
diff -Nru a/drivers/acpi/executer/exsystem.c b/drivers/acpi/executer/exsystem.c
--- a/drivers/acpi/executer/exsystem.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exsystem.c	2005-04-19 01:34:14 -04:00
@@ -55,8 +55,8 @@
  *
  * FUNCTION:    acpi_ex_system_wait_semaphore
  *
- * PARAMETERS:  Semaphore           - OSD semaphore to wait on
- *              Timeout             - Max time to wait
+ * PARAMETERS:  Semaphore       - Semaphore to wait on
+ *              Timeout         - Max time to wait
  *
  * RETURN:      Status
  *
@@ -90,7 +90,8 @@
 
 		status = acpi_os_wait_semaphore (semaphore, 1, timeout);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "*** Thread awake after blocking, %s\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"*** Thread awake after blocking, %s\n",
 			acpi_format_exception (status)));
 
 		/* Reacquire the interpreter */
@@ -111,8 +112,8 @@
  *
  * FUNCTION:    acpi_ex_system_do_stall
  *
- * PARAMETERS:  how_long            - The amount of time to stall,
- *                                    in microseconds
+ * PARAMETERS:  how_long        - The amount of time to stall,
+ *                                in microseconds
  *
  * RETURN:      Status
  *
@@ -141,7 +142,8 @@
 		 * (ACPI specifies 100 usec as max, but this gives some slack in
 		 * order to support existing BIOSs)
 		 */
-		ACPI_REPORT_ERROR (("Stall: Time parameter is too large (%d)\n", how_long));
+		ACPI_REPORT_ERROR (("Stall: Time parameter is too large (%d)\n",
+			how_long));
 		status = AE_AML_OPERAND_VALUE;
 	}
 	else {
@@ -156,8 +158,8 @@
  *
  * FUNCTION:    acpi_ex_system_do_suspend
  *
- * PARAMETERS:  how_long            - The amount of time to suspend,
- *                                    in milliseconds
+ * PARAMETERS:  how_long        - The amount of time to suspend,
+ *                                in milliseconds
  *
  * RETURN:      None
  *
@@ -192,8 +194,8 @@
  *
  * FUNCTION:    acpi_ex_system_acquire_mutex
  *
- * PARAMETERS:  *time_desc          - The 'time to delay' object descriptor
- *              *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  time_desc       - The 'time to delay' object descriptor
+ *              obj_desc        - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -218,16 +220,15 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Support for the _GL_ Mutex object -- go get the global lock
-	 */
+	/* Support for the _GL_ Mutex object -- go get the global lock */
+
 	if (obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore) {
 		status = acpi_ev_acquire_global_lock ((u16) time_desc->integer.value);
 		return_ACPI_STATUS (status);
 	}
 
 	status = acpi_ex_system_wait_semaphore (obj_desc->mutex.semaphore,
-			  (u16) time_desc->integer.value);
+			 (u16) time_desc->integer.value);
 	return_ACPI_STATUS (status);
 }
 
@@ -236,7 +237,7 @@
  *
  * FUNCTION:    acpi_ex_system_release_mutex
  *
- * PARAMETERS:  *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  obj_desc        - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -261,9 +262,8 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Support for the _GL_ Mutex object -- release the global lock
-	 */
+	/* Support for the _GL_ Mutex object -- release the global lock */
+
 	if (obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore) {
 		status = acpi_ev_release_global_lock ();
 		return_ACPI_STATUS (status);
@@ -278,9 +278,9 @@
  *
  * FUNCTION:    acpi_ex_system_signal_event
  *
- * PARAMETERS:  *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  obj_desc        - The object descriptor for this op
  *
- * RETURN:      AE_OK
+ * RETURN:      Status
  *
  * DESCRIPTION: Provides an access point to perform synchronization operations
  *              within the AML.
@@ -309,8 +309,8 @@
  *
  * FUNCTION:    acpi_ex_system_wait_event
  *
- * PARAMETERS:  *time_desc          - The 'time to delay' object descriptor
- *              *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  time_desc       - The 'time to delay' object descriptor
+ *              obj_desc        - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -333,7 +333,7 @@
 
 	if (obj_desc) {
 		status = acpi_ex_system_wait_semaphore (obj_desc->event.semaphore,
-				  (u16) time_desc->integer.value);
+				 (u16) time_desc->integer.value);
 	}
 
 	return_ACPI_STATUS (status);
@@ -344,7 +344,7 @@
  *
  * FUNCTION:    acpi_ex_system_reset_event
  *
- * PARAMETERS:  *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  obj_desc        - The object descriptor for this op
  *
  * RETURN:      Status
  *
diff -Nru a/drivers/acpi/executer/exutils.c b/drivers/acpi/executer/exutils.c
--- a/drivers/acpi/executer/exutils.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/executer/exutils.c	2005-04-19 01:34:14 -04:00
@@ -67,22 +67,31 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exutils")
 
+/* Local prototypes */
 
-#ifndef ACPI_NO_METHOD_EXECUTION
+static u32
+acpi_ex_digits_needed (
+	acpi_integer                    value,
+	u32                             base);
 
+
+#ifndef ACPI_NO_METHOD_EXECUTION
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ex_enter_interpreter
  *
  * PARAMETERS:  None
  *
+ * RETURN:      Status
+ *
  * DESCRIPTION: Enter the interpreter execution region.  Failure to enter
  *              the interpreter region is a fatal system error
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ex_enter_interpreter (void)
+acpi_ex_enter_interpreter (
+	void)
 {
 	acpi_status                     status;
 
@@ -104,6 +113,8 @@
  *
  * PARAMETERS:  None
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Exit the interpreter execution region
  *
  * Cases where the interpreter is unlocked:
@@ -119,7 +130,8 @@
  ******************************************************************************/
 
 void
-acpi_ex_exit_interpreter (void)
+acpi_ex_exit_interpreter (
+	void)
 {
 	acpi_status                     status;
 
@@ -212,7 +224,8 @@
 			locked = TRUE;
 		}
 		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not acquire Global Lock, %s\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not acquire Global Lock, %s\n",
 				acpi_format_exception (status)));
 		}
 	}
@@ -228,7 +241,7 @@
  * PARAMETERS:  locked_by_me    - Return value from corresponding call to
  *                                acquire_global_lock.
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Release the global lock if it is locked.
  *
@@ -269,11 +282,14 @@
  * PARAMETERS:  Value           - Value to be represented
  *              Base            - Base of representation
  *
- * RETURN:      the number of digits needed to represent Value in Base
+ * RETURN:      The number of digits.
+ *
+ * DESCRIPTION: Calculate the number of digits needed to represent the Value
+ *              in the given Base (Radix)
  *
  ******************************************************************************/
 
-u32
+static u32
 acpi_ex_digits_needed (
 	acpi_integer                    value,
 	u32                             base)
@@ -312,6 +328,8 @@
  * PARAMETERS:  numeric_id      - EISA ID to be converted
  *              out_string      - Where to put the converted string (8 bytes)
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Convert a numeric EISA ID to string representation
  *
  ******************************************************************************/
@@ -349,7 +367,10 @@
  * PARAMETERS:  Value           - Value to be converted
  *              out_string      - Where to put the converted string (8 bytes)
  *
- * RETURN:      Convert a number to string representation
+ * RETURN:      None, string
+ *
+ * DESCRIPTOIN: Convert a number to string representation. Assumes string
+ *              buffer is large enough to hold the string.
  *
  ******************************************************************************/
 
diff -Nru a/drivers/acpi/hardware/hwacpi.c b/drivers/acpi/hardware/hwacpi.c
--- a/drivers/acpi/hardware/hwacpi.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/hardware/hwacpi.c	2005-04-19 01:34:14 -04:00
@@ -58,7 +58,8 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize and validate various ACPI registers
+ * DESCRIPTION: Initialize and validate the various ACPI registers defined in
+ *              the FADT.
  *
  ******************************************************************************/
 
@@ -75,7 +76,7 @@
 	/* We must have the ACPI tables by the time we get here */
 
 	if (!acpi_gbl_FADT) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "A FADT is not loaded\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No FADT is present\n"));
 
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
@@ -131,7 +132,8 @@
 	 * transitions are not supported.
 	 */
 	if (!acpi_gbl_FADT->acpi_enable && !acpi_gbl_FADT->acpi_disable) {
-		ACPI_REPORT_ERROR (("No ACPI mode transition supported in this system (enable/disable both zero)\n"));
+		ACPI_REPORT_ERROR ((
+			"No ACPI mode transition supported in this system (enable/disable both zero)\n"));
 		return_ACPI_STATUS (AE_OK);
 	}
 
@@ -162,7 +164,8 @@
 	}
 
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not write mode change, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Could not write mode change, %s\n",
+			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
@@ -173,7 +176,8 @@
 	retry = 3000;
 	while (retry) {
 		if (acpi_hw_get_mode() == mode) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n", mode));
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n",
+				mode));
 			return_ACPI_STATUS (AE_OK);
 		}
 		acpi_os_stall(1000);
@@ -185,7 +189,7 @@
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_hw_get_mode
  *
@@ -199,7 +203,8 @@
  ******************************************************************************/
 
 u32
-acpi_hw_get_mode (void)
+acpi_hw_get_mode (
+	void)
 {
 	acpi_status                     status;
 	u32                             value;
diff -Nru a/drivers/acpi/hardware/hwgpe.c b/drivers/acpi/hardware/hwgpe.c
--- a/drivers/acpi/hardware/hwgpe.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/hardware/hwgpe.c	2005-04-19 01:34:14 -04:00
@@ -48,6 +48,13 @@
 #define _COMPONENT          ACPI_HARDWARE
 	 ACPI_MODULE_NAME    ("hwgpe")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_hw_enable_wakeup_gpe_block (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block);
+
 
 /******************************************************************************
  *
@@ -135,6 +142,7 @@
  * DESCRIPTION: Return the status of a single GPE.
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_hw_get_gpe_status (
@@ -206,7 +214,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Disable all GPEs within a GPE block
+ * DESCRIPTION: Disable all GPEs within a single GPE block
  *
  ******************************************************************************/
 
@@ -244,7 +252,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Clear status bits for all GPEs within a GPE block
+ * DESCRIPTION: Clear status bits for all GPEs within a single GPE block
  *
  ******************************************************************************/
 
@@ -282,8 +290,8 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable all "runtime" GPEs within a GPE block. (Includes
- *              combination wake/run GPEs.)
+ * DESCRIPTION: Enable all "runtime" GPEs within a single GPE block. Includes
+ *              combination wake/run GPEs.
  *
  ******************************************************************************/
 
@@ -327,12 +335,12 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable all "wake" GPEs within a GPE block.  (Includes
- *              combination wake/run GPEs.)
+ * DESCRIPTION: Enable all "wake" GPEs within a single GPE block. Includes
+ *              combination wake/run GPEs.
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_hw_enable_wakeup_gpe_block (
 	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
 	struct acpi_gpe_block_info      *gpe_block)
@@ -350,7 +358,8 @@
 
 		/* Enable all "wake" GPEs in this register */
 
-		status = acpi_hw_low_level_write (8, gpe_block->register_info[i].enable_for_wake,
+		status = acpi_hw_low_level_write (8,
+				 gpe_block->register_info[i].enable_for_wake,
 				 &gpe_block->register_info[i].enable_address);
 		if (ACPI_FAILURE (status)) {
 			return (status);
@@ -369,7 +378,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Disable and clear all GPEs
+ * DESCRIPTION: Disable and clear all GPEs in all GPE blocks
  *
  ******************************************************************************/
 
@@ -397,7 +406,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable all GPEs of the given type
+ * DESCRIPTION: Enable all "runtime" GPEs, in all GPE blocks
  *
  ******************************************************************************/
 
@@ -424,7 +433,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable all GPEs of the given type
+ * DESCRIPTION: Enable all "wakeup" GPEs, in all GPE blocks
  *
  ******************************************************************************/
 
diff -Nru a/drivers/acpi/hardware/hwregs.c b/drivers/acpi/hardware/hwregs.c
--- a/drivers/acpi/hardware/hwregs.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/hardware/hwregs.c	2005-04-19 01:34:14 -04:00
@@ -87,8 +87,9 @@
 		}
 	}
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS,
-			  ACPI_BITMASK_ALL_FIXED_STATUS);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1_STATUS,
+			 ACPI_BITMASK_ALL_FIXED_STATUS);
 	if (ACPI_FAILURE (status)) {
 		goto unlock_and_exit;
 	}
@@ -138,28 +139,30 @@
 {
 	acpi_status                     status = AE_OK;
 	struct acpi_parameter_info      info;
+	char                            *sleep_state_name;
 
 
 	ACPI_FUNCTION_TRACE ("acpi_get_sleep_type_data");
 
 
-	/*
-	 * Validate parameters
-	 */
+	/* Validate parameters */
+
 	if ((sleep_state > ACPI_S_STATES_MAX) ||
 		!sleep_type_a || !sleep_type_b) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Evaluate the namespace object containing the values for this state
-	 */
+	/* Evaluate the namespace object containing the values for this state */
+
 	info.parameters = NULL;
-	status = acpi_ns_evaluate_by_name ((char *) acpi_gbl_sleep_state_names[sleep_state],
-			  &info);
+	info.return_object = NULL;
+	sleep_state_name = (char *) acpi_gbl_sleep_state_names[sleep_state];
+
+	status = acpi_ns_evaluate_by_name (sleep_state_name, &info);
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s while evaluating sleep_state [%s]\n",
-			acpi_format_exception (status), acpi_gbl_sleep_state_names[sleep_state]));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"%s while evaluating sleep_state [%s]\n",
+			acpi_format_exception (status), sleep_state_name));
 
 		return_ACPI_STATUS (status);
 	}
@@ -167,45 +170,57 @@
 	/* Must have a return object */
 
 	if (!info.return_object) {
-		ACPI_REPORT_ERROR (("Missing Sleep State object\n"));
+		ACPI_REPORT_ERROR (("No Sleep State object returned from [%s]\n",
+			sleep_state_name));
 		status = AE_NOT_EXIST;
 	}
 
 	/* It must be of type Package */
 
 	else if (ACPI_GET_OBJECT_TYPE (info.return_object) != ACPI_TYPE_PACKAGE) {
-		ACPI_REPORT_ERROR (("Sleep State object not a Package\n"));
+		ACPI_REPORT_ERROR (("Sleep State return object is not a Package\n"));
 		status = AE_AML_OPERAND_TYPE;
 	}
 
-	/* The package must have at least two elements */
-
+	/*
+	 * The package must have at least two elements.  NOTE (March 2005): This
+	 * goes against the current ACPI spec which defines this object as a
+	 * package with one encoded DWORD element.  However, existing practice
+	 * by BIOS vendors seems to be to have 2 or more elements, at least
+	 * one per sleep type (A/B).
+	 */
 	else if (info.return_object->package.count < 2) {
-		ACPI_REPORT_ERROR (("Sleep State package does not have at least two elements\n"));
+		ACPI_REPORT_ERROR ((
+			"Sleep State return package does not have at least two elements\n"));
 		status = AE_AML_NO_OPERAND;
 	}
 
 	/* The first two elements must both be of type Integer */
 
-	else if ((ACPI_GET_OBJECT_TYPE (info.return_object->package.elements[0]) != ACPI_TYPE_INTEGER) ||
-			 (ACPI_GET_OBJECT_TYPE (info.return_object->package.elements[1]) != ACPI_TYPE_INTEGER)) {
-		ACPI_REPORT_ERROR (("Sleep State package elements are not both Integers (%s, %s)\n",
+	else if ((ACPI_GET_OBJECT_TYPE (info.return_object->package.elements[0])
+			 != ACPI_TYPE_INTEGER) ||
+			 (ACPI_GET_OBJECT_TYPE (info.return_object->package.elements[1])
+				!= ACPI_TYPE_INTEGER)) {
+		ACPI_REPORT_ERROR ((
+			"Sleep State return package elements are not both Integers (%s, %s)\n",
 			acpi_ut_get_object_type_name (info.return_object->package.elements[0]),
 			acpi_ut_get_object_type_name (info.return_object->package.elements[1])));
 		status = AE_AML_OPERAND_TYPE;
 	}
 	else {
-		/*
-		 * Valid _Sx_ package size, type, and value
-		 */
-		*sleep_type_a = (u8) (info.return_object->package.elements[0])->integer.value;
-		*sleep_type_b = (u8) (info.return_object->package.elements[1])->integer.value;
+		/* Valid _Sx_ package size, type, and value */
+
+		*sleep_type_a = (u8)
+			(info.return_object->package.elements[0])->integer.value;
+		*sleep_type_b = (u8)
+			(info.return_object->package.elements[1])->integer.value;
 	}
 
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"While evaluating sleep_state [%s], bad Sleep object %p type %s\n",
-			acpi_gbl_sleep_state_names[sleep_state], info.return_object,
+			"%s While evaluating sleep_state [%s], bad Sleep object %p type %s\n",
+			acpi_format_exception (status),
+			sleep_state_name, info.return_object,
 			acpi_ut_get_object_type_name (info.return_object)));
 	}
 
@@ -221,9 +236,9 @@
  *
  * PARAMETERS:  register_id         - Index of ACPI Register to access
  *
- * RETURN:      The bit mask to be used when accessing the register
+ * RETURN:      The bitmask to be used when accessing the register
  *
- * DESCRIPTION: Map register_id into a register bit mask.
+ * DESCRIPTION: Map register_id into a register bitmask.
  *
  ******************************************************************************/
 
@@ -359,7 +374,7 @@
 	/* Always do a register read first so we can insert the new bits  */
 
 	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
-			  bit_reg_info->parent_register, &register_value);
+			 bit_reg_info->parent_register, &register_value);
 	if (ACPI_FAILURE (status)) {
 		goto unlock_and_exit;
 	}
@@ -396,7 +411,7 @@
 				bit_reg_info->access_bit_mask, value);
 
 		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
-				  ACPI_REGISTER_PM1_ENABLE, (u16) register_value);
+				 ACPI_REGISTER_PM1_ENABLE, (u16) register_value);
 		break;
 
 
@@ -413,7 +428,7 @@
 				bit_reg_info->access_bit_mask, value);
 
 		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
-				  ACPI_REGISTER_PM1_CONTROL, (u16) register_value);
+				 ACPI_REGISTER_PM1_CONTROL, (u16) register_value);
 		break;
 
 
@@ -427,17 +442,19 @@
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "PM2 control: Read %X from %8.8X%8.8X\n",
 			register_value,
-			ACPI_FORMAT_UINT64 (acpi_gbl_FADT->xpm2_cnt_blk.address)));
+			ACPI_FORMAT_UINT64 (
+				acpi_gbl_FADT->xpm2_cnt_blk.address)));
 
 		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position,
 				bit_reg_info->access_bit_mask, value);
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "About to write %4.4X to %8.8X%8.8X\n",
 			register_value,
-			ACPI_FORMAT_UINT64 (acpi_gbl_FADT->xpm2_cnt_blk.address)));
+			ACPI_FORMAT_UINT64 (
+				acpi_gbl_FADT->xpm2_cnt_blk.address)));
 
 		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
-				   ACPI_REGISTER_PM2_CONTROL, (u8) (register_value));
+				 ACPI_REGISTER_PM2_CONTROL, (u8) (register_value));
 		break;
 
 
@@ -454,7 +471,9 @@
 
 	/* Normalize the value that was read */
 
-	ACPI_DEBUG_EXEC (register_value = ((register_value & bit_reg_info->access_bit_mask) >> bit_reg_info->bit_position));
+	ACPI_DEBUG_EXEC (register_value =
+		((register_value & bit_reg_info->access_bit_mask) >>
+			bit_reg_info->bit_position));
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Set bits: %8.8X actual %8.8X register %X\n",
 			value, register_value, bit_reg_info->parent_register));
@@ -469,7 +488,7 @@
  *
  * PARAMETERS:  use_lock            - Mutex hw access
  *              register_id         - register_iD + Offset
- *              return_value        - Value that was read from the register
+ *              return_value        - Where the register value is returned
  *
  * RETURN:      Status and the value read.
  *
@@ -557,7 +576,8 @@
 		break;
 
 	default:
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Register ID: %X\n", register_id));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Register ID: %X\n",
+			register_id));
 		status = AE_BAD_PARAMETER;
 		break;
 	}
@@ -763,10 +783,11 @@
 		return (AE_BAD_PARAMETER);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Read:  %8.8X width %2d from %8.8X%8.8X (%s)\n",
-			*value, width,
-			ACPI_FORMAT_UINT64 (address),
-			acpi_ut_get_region_name (reg->address_space_id)));
+	ACPI_DEBUG_PRINT ((ACPI_DB_IO,
+		"Read:  %8.8X width %2d from %8.8X%8.8X (%s)\n",
+		*value, width,
+		ACPI_FORMAT_UINT64 (address),
+		acpi_ut_get_region_name (reg->address_space_id)));
 
 	return (status);
 }
@@ -841,10 +862,11 @@
 		return (AE_BAD_PARAMETER);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Wrote: %8.8X width %2d   to %8.8X%8.8X (%s)\n",
-			value, width,
-			ACPI_FORMAT_UINT64 (address),
-			acpi_ut_get_region_name (reg->address_space_id)));
+	ACPI_DEBUG_PRINT ((ACPI_DB_IO,
+		"Wrote: %8.8X width %2d   to %8.8X%8.8X (%s)\n",
+		value, width,
+		ACPI_FORMAT_UINT64 (address),
+		acpi_ut_get_region_name (reg->address_space_id)));
 
 	return (status);
 }
diff -Nru a/drivers/acpi/hardware/hwsleep.c b/drivers/acpi/hardware/hwsleep.c
--- a/drivers/acpi/hardware/hwsleep.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/hardware/hwsleep.c	2005-04-19 01:34:14 -04:00
@@ -43,27 +43,13 @@
  */
 
 #include <linux/module.h>
-
 #include <acpi/acpi.h>
 
 #define _COMPONENT          ACPI_HARDWARE
 	 ACPI_MODULE_NAME    ("hwsleep")
 
 
-#define METHOD_NAME__BFS        "\\_BFS"
-#define METHOD_NAME__GTS        "\\_GTS"
-#define METHOD_NAME__PTS        "\\_PTS"
-#define METHOD_NAME__SST        "\\_SI._SST"
-#define METHOD_NAME__WAK        "\\_WAK"
-
-#define ACPI_SST_INDICATOR_OFF  0
-#define ACPI_SST_WORKING        1
-#define ACPI_SST_WAKING         2
-#define ACPI_SST_SLEEPING       3
-#define ACPI_SST_SLEEP_CONTEXT  4
-
-
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_set_firmware_waking_vector
  *
@@ -72,7 +58,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: access function for d_firmware_waking_vector field in FACS
+ * DESCRIPTION: Access function for the firmware_waking_vector field in FACS
  *
  ******************************************************************************/
 
@@ -99,19 +85,20 @@
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_get_firmware_waking_vector
  *
- * PARAMETERS:  *physical_address   - Output buffer where contents of
+ * PARAMETERS:  *physical_address   - Where the contents of
  *                                    the firmware_waking_vector field of
- *                                    the FACS will be stored.
+ *                                    the FACS will be returned.
  *
- * RETURN:      Status
+ * RETURN:      Status, vector
  *
- * DESCRIPTION: Access function for firmware_waking_vector field in FACS
+ * DESCRIPTION: Access function for the firmware_waking_vector field in FACS
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_get_firmware_waking_vector (
@@ -141,7 +128,7 @@
 #endif
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_enter_sleep_state_prep
  *
@@ -215,7 +202,7 @@
 		break;
 
 	default:
-		arg.integer.value = ACPI_SST_INDICATOR_OFF; /* Default is indicator off */
+		arg.integer.value = ACPI_SST_INDICATOR_OFF; /* Default is off */
 		break;
 	}
 
@@ -223,14 +210,15 @@
 
 	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		 ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
+		 ACPI_REPORT_ERROR (("Method _SST failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	return_ACPI_STATUS (AE_OK);
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_enter_sleep_state
  *
@@ -299,15 +287,18 @@
 
 	/* Get current value of PM1A control */
 
-	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_CONTROL, &PM1Acontrol);
+	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1_CONTROL, &PM1Acontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
-	ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "Entering sleep state [S%d]\n", sleep_state));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
+		"Entering sleep state [S%d]\n", sleep_state));
 
 	/* Clear SLP_EN and SLP_TYP fields */
 
-	PM1Acontrol &= ~(sleep_type_reg_info->access_bit_mask | sleep_enable_reg_info->access_bit_mask);
+	PM1Acontrol &= ~(sleep_type_reg_info->access_bit_mask |
+			   sleep_enable_reg_info->access_bit_mask);
 	PM1Bcontrol = PM1Acontrol;
 
 	/* Insert SLP_TYP bits */
@@ -322,12 +313,14 @@
 
 	/* Write #1: fill in SLP_TYP data */
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -341,22 +334,25 @@
 
 	ACPI_FLUSH_CPU_CACHE ();
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
 	if (sleep_state > ACPI_STATE_S3) {
 		/*
-		 * We wanted to sleep > S3, but it didn't happen (by virtue of the fact that
-		 * we are still executing!)
+		 * We wanted to sleep > S3, but it didn't happen (by virtue of the
+		 * fact that we are still executing!)
 		 *
-		 * Wait ten seconds, then try again. This is to get S4/S5 to work on all machines.
+		 * Wait ten seconds, then try again. This is to get S4/S5 to work on
+		 * all machines.
 		 *
 		 * We wait so long to allow chipsets that poll this reg very slowly to
 		 * still read the right value. Ideally, this block would go
@@ -364,7 +360,8 @@
 		 */
 		acpi_os_stall (10000000);
 
-		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_CONTROL,
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+				 ACPI_REGISTER_PM1_CONTROL,
 				 sleep_enable_reg_info->access_bit_mask);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
@@ -374,7 +371,8 @@
 	/* Wait until we enter sleep state */
 
 	do {
-		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value, ACPI_MTX_DO_NOT_LOCK);
+		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value,
+			ACPI_MTX_DO_NOT_LOCK);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -388,7 +386,7 @@
 EXPORT_SYMBOL(acpi_enter_sleep_state);
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_enter_sleep_state_s4bios
  *
@@ -439,11 +437,13 @@
 
 	ACPI_FLUSH_CPU_CACHE ();
 
-	status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd, (u32) acpi_gbl_FADT->S4bios_req, 8);
+	status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd,
+			 (u32) acpi_gbl_FADT->S4bios_req, 8);
 
 	do {
 		acpi_os_stall(1000);
-		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value, ACPI_MTX_DO_NOT_LOCK);
+		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value,
+			ACPI_MTX_DO_NOT_LOCK);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -454,7 +454,7 @@
 EXPORT_SYMBOL(acpi_enter_sleep_state_s4bios);
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_leave_sleep_state
  *
@@ -534,18 +534,21 @@
 	arg.integer.value = ACPI_SST_WAKING;
 	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Method _SST failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	arg.integer.value = sleep_state;
 	status = acpi_evaluate_object (NULL, METHOD_NAME__BFS, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		ACPI_REPORT_ERROR (("Method _BFS failed, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Method _BFS failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	status = acpi_evaluate_object (NULL, METHOD_NAME__WAK, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		ACPI_REPORT_ERROR (("Method _WAK failed, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Method _WAK failed, %s\n",
+			acpi_format_exception (status)));
 	}
 	/* TBD: _WAK "sometimes" returns stuff - do we want to look at it? */
 
@@ -567,15 +570,19 @@
 
 	/* Enable power button */
 
-	(void) acpi_set_register(acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].enable_register_id,
+	(void) acpi_set_register(
+			acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].enable_register_id,
 			1, ACPI_MTX_DO_NOT_LOCK);
-	(void) acpi_set_register(acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].status_register_id,
+
+	(void) acpi_set_register(
+			acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].status_register_id,
 			1, ACPI_MTX_DO_NOT_LOCK);
 
 	arg.integer.value = ACPI_SST_WORKING;
 	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Method _SST failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	return_ACPI_STATUS (status);
diff -Nru a/drivers/acpi/hardware/hwtimer.c b/drivers/acpi/hardware/hwtimer.c
--- a/drivers/acpi/hardware/hwtimer.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/hardware/hwtimer.c	2005-04-19 01:34:14 -04:00
@@ -43,7 +43,6 @@
  */
 
 #include <linux/module.h>
-
 #include <acpi/acpi.h>
 
 #define _COMPONENT          ACPI_HARDWARE
@@ -90,7 +89,7 @@
  *
  * PARAMETERS:  Ticks               - Where the timer value is returned
  *
- * RETURN:      Status and current ticks
+ * RETURN:      Status and current timer value (ticks)
  *
  * DESCRIPTION: Obtains current value of ACPI PM Timer (in ticks).
  *
@@ -199,5 +198,6 @@
 	*time_elapsed = (u32) quotient;
 	return_ACPI_STATUS (status);
 }
+
 EXPORT_SYMBOL(acpi_get_timer_duration);
 
diff -Nru a/drivers/acpi/namespace/nsaccess.c b/drivers/acpi/namespace/nsaccess.c
--- a/drivers/acpi/namespace/nsaccess.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsaccess.c	2005-04-19 01:34:14 -04:00
@@ -67,7 +67,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ns_root_initialize (void)
+acpi_ns_root_initialize (
+	void)
 {
 	acpi_status                         status;
 	const struct acpi_predefined_names *init_val = NULL;
@@ -265,7 +266,7 @@
  *
  * FUNCTION:    acpi_ns_lookup
  *
- * PARAMETERS:  prefix_node     - Search scope if name is not fully qualified
+ * PARAMETERS:  scope_info      - Current scope info block
  *              Pathname        - Search pathname, in internal format
  *                                (as represented in the AML stream)
  *              Type            - Type associated with name
diff -Nru a/drivers/acpi/namespace/nsalloc.c b/drivers/acpi/namespace/nsalloc.c
--- a/drivers/acpi/namespace/nsalloc.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsalloc.c	2005-04-19 01:34:14 -04:00
@@ -49,14 +49,20 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsalloc")
 
+/* Local prototypes */
+
+static void
+acpi_ns_remove_reference (
+	struct acpi_namespace_node      *node);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_create_node
  *
- * PARAMETERS:  acpi_name       - Name of the new node
+ * PARAMETERS:  Name            - Name of the new node (4 char ACPI name)
  *
- * RETURN:      None
+ * RETURN:      New namespace node (Null on failure)
  *
  * DESCRIPTION: Create a namespace node
  *
@@ -145,7 +151,6 @@
 		}
 	}
 
-
 	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].total_freed++);
 
 	/*
@@ -157,57 +162,6 @@
 }
 
 
-#ifdef ACPI_ALPHABETIC_NAMESPACE
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ns_compare_names
- *
- * PARAMETERS:  Name1           - First name to compare
- *              Name2           - Second name to compare
- *
- * RETURN:      value from strncmp
- *
- * DESCRIPTION: Compare two ACPI names.  Names that are prefixed with an
- *              underscore are forced to be alphabetically first.
- *
- ******************************************************************************/
-
-int
-acpi_ns_compare_names (
-	char                            *name1,
-	char                            *name2)
-{
-	char                            reversed_name1[ACPI_NAME_SIZE];
-	char                            reversed_name2[ACPI_NAME_SIZE];
-	u32                             i;
-	u32                             j;
-
-
-	/*
-	 * Replace all instances of "underscore" with a value that is smaller so
-	 * that all names that are prefixed with underscore(s) are alphabetically
-	 * first.
-	 *
-	 * Reverse the name bytewise so we can just do a 32-bit compare instead
-	 * of a strncmp.
-	 */
-	for (i = 0, j= (ACPI_NAME_SIZE - 1); i < ACPI_NAME_SIZE; i++, j--) {
-		reversed_name1[j] = name1[i];
-		if (name1[i] == '_') {
-			reversed_name1[j] = '*';
-		}
-
-		reversed_name2[j] = name2[i];
-		if (name2[i] == '_') {
-			reversed_name2[j] = '*';
-		}
-	}
-
-	return (*(int *) reversed_name1 - *(int *) reversed_name2);
-}
-#endif
-
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_install_node
@@ -271,7 +225,8 @@
 		 * alphabetic placement.
 		 */
 		previous_child_node = NULL;
-		while (acpi_ns_compare_names (acpi_ut_get_node_name (child_node), acpi_ut_get_node_name (node)) < 0) {
+		while (acpi_ns_compare_names (acpi_ut_get_node_name (child_node),
+				 acpi_ut_get_node_name (node)) < 0) {
 			if (child_node->flags & ANOBJ_END_OF_PEER_LIST) {
 				/* Last peer;  Clear end-of-list flag */
 
@@ -429,7 +384,8 @@
 		/* There should be only one reference remaining on this node */
 
 		if (child_node->reference_count != 1) {
-			ACPI_REPORT_WARNING (("Existing references (%d) on node being deleted (%p)\n",
+			ACPI_REPORT_WARNING ((
+				"Existing references (%d) on node being deleted (%p)\n",
 				child_node->reference_count, child_node));
 		}
 
@@ -548,7 +504,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ns_remove_reference (
 	struct acpi_namespace_node      *node)
 {
@@ -681,5 +637,56 @@
 
 	return_VOID;
 }
+
+
+#ifdef ACPI_ALPHABETIC_NAMESPACE
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_compare_names
+ *
+ * PARAMETERS:  Name1           - First name to compare
+ *              Name2           - Second name to compare
+ *
+ * RETURN:      value from strncmp
+ *
+ * DESCRIPTION: Compare two ACPI names.  Names that are prefixed with an
+ *              underscore are forced to be alphabetically first.
+ *
+ ******************************************************************************/
+
+int
+acpi_ns_compare_names (
+	char                            *name1,
+	char                            *name2)
+{
+	char                            reversed_name1[ACPI_NAME_SIZE];
+	char                            reversed_name2[ACPI_NAME_SIZE];
+	u32                             i;
+	u32                             j;
+
+
+	/*
+	 * Replace all instances of "underscore" with a value that is smaller so
+	 * that all names that are prefixed with underscore(s) are alphabetically
+	 * first.
+	 *
+	 * Reverse the name bytewise so we can just do a 32-bit compare instead
+	 * of a strncmp.
+	 */
+	for (i = 0, j= (ACPI_NAME_SIZE - 1); i < ACPI_NAME_SIZE; i++, j--) {
+		reversed_name1[j] = name1[i];
+		if (name1[i] == '_') {
+			reversed_name1[j] = '*';
+		}
+
+		reversed_name2[j] = name2[i];
+		if (name2[i] == '_') {
+			reversed_name2[j] = '*';
+		}
+	}
+
+	return (*(int *) reversed_name1 - *(int *) reversed_name2);
+}
+#endif
 
 
diff -Nru a/drivers/acpi/namespace/nsdump.c b/drivers/acpi/namespace/nsdump.c
--- a/drivers/acpi/namespace/nsdump.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsdump.c	2005-04-19 01:34:14 -04:00
@@ -50,16 +50,32 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsdump")
 
+/* Local prototypes */
 
-#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+void
+acpi_ns_dump_root_devices (
+	void);
 
+static acpi_status
+acpi_ns_dump_one_device (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+#endif
+
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_print_pathname
  *
- * PARAMETERS:  num_segment         - Number of ACPI name segments
+ * PARAMETERS:  num_segments        - Number of ACPI name segments
  *              Pathname            - The compressed (internal) path
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Print an object's full namespace pathname
  *
  ******************************************************************************/
@@ -103,6 +119,8 @@
  *              Level               - Desired debug level
  *              Component           - Caller's component ID
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Print an object's full namespace pathname
  *              Manages allocation/freeing of a pathname buffer
  *
@@ -137,9 +155,12 @@
  *
  * FUNCTION:    acpi_ns_dump_one_object
  *
- * PARAMETERS:  Handle              - Node to be dumped
+ * PARAMETERS:  obj_handle          - Node to be dumped
  *              Level               - Nesting level of the handle
  *              Context             - Passed into walk_namespace
+ *              return_value        - Not used
+ *
+ * RETURN:      Status
  *
  * DESCRIPTION: Dump a single Node
  *              This procedure is a user_function called by acpi_ns_walk_namespace.
@@ -394,8 +415,7 @@
 			return (AE_OK);
 		}
 
-		acpi_os_printf ("(R%d)",
-				obj_desc->common.reference_count);
+		acpi_os_printf ("(R%d)", obj_desc->common.reference_count);
 
 		switch (type) {
 		case ACPI_TYPE_METHOD:
@@ -551,18 +571,20 @@
 
 
 #ifdef ACPI_FUTURE_USAGE
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_dump_objects
  *
  * PARAMETERS:  Type                - Object type to be dumped
+ *              display_type        - 0 or ACPI_DISPLAY_SUMMARY
  *              max_depth           - Maximum depth of dump. Use ACPI_UINT32_MAX
  *                                    for an effectively unlimited depth.
  *              owner_id            - Dump only objects owned by this ID.  Use
  *                                    ACPI_UINT32_MAX to match all owners.
  *              start_handle        - Where in namespace to start/end search
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Dump typed objects within the loaded namespace.
  *              Uses acpi_ns_walk_namespace in conjunction with acpi_ns_dump_one_object.
  *
@@ -590,10 +612,44 @@
 			 ACPI_NS_WALK_NO_UNLOCK, acpi_ns_dump_one_object,
 			 (void *) &info, NULL);
 }
+#endif	/* ACPI_FUTURE_USAGE */
 
 
 /*******************************************************************************
  *
+ * FUNCTION:    acpi_ns_dump_entry
+ *
+ * PARAMETERS:  Handle              - Node to be dumped
+ *              debug_level         - Output level
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump a single Node
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_dump_entry (
+	acpi_handle                     handle,
+	u32                             debug_level)
+{
+	struct acpi_walk_info           info;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	info.debug_level = debug_level;
+	info.owner_id = ACPI_UINT32_MAX;
+	info.display_type = ACPI_DISPLAY_SUMMARY;
+
+	(void) acpi_ns_dump_one_object (handle, 1, &info, NULL);
+}
+
+
+#ifdef _ACPI_ASL_COMPILER
+/*******************************************************************************
+ *
  * FUNCTION:    acpi_ns_dump_tables
  *
  * PARAMETERS:  search_base         - Root of subtree to be dumped, or
@@ -601,6 +657,8 @@
  *              max_depth           - Maximum depth of dump.  Use INT_MAX
  *                                    for an effectively unlimited depth.
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Dump the name space, or a portion of it.
  *
  ******************************************************************************/
@@ -626,7 +684,7 @@
 	}
 
 	if (ACPI_NS_ALL == search_base) {
-		/*  entire namespace    */
+		/* Entire namespace */
 
 		search_handle = acpi_gbl_root_node;
 		ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "\\\n"));
@@ -636,38 +694,5 @@
 			ACPI_UINT32_MAX, search_handle);
 	return_VOID;
 }
-
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ns_dump_entry
- *
- * PARAMETERS:  Handle              - Node to be dumped
- *              debug_level         - Output level
- *
- * DESCRIPTION: Dump a single Node
- *
- ******************************************************************************/
-
-void
-acpi_ns_dump_entry (
-	acpi_handle                     handle,
-	u32                             debug_level)
-{
-	struct acpi_walk_info           info;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	info.debug_level = debug_level;
-	info.owner_id = ACPI_UINT32_MAX;
-	info.display_type = ACPI_DISPLAY_SUMMARY;
-
-	(void) acpi_ns_dump_one_object (handle, 1, &info, NULL);
-}
-
-#endif
-
+#endif	/* _ACPI_ASL_COMPILER */
+#endif	/* defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER) */
diff -Nru a/drivers/acpi/namespace/nsdumpdv.c b/drivers/acpi/namespace/nsdumpdv.c
--- a/drivers/acpi/namespace/nsdumpdv.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsdumpdv.c	2005-04-19 01:34:14 -04:00
@@ -43,15 +43,18 @@
 
 
 #include <acpi/acpi.h>
-#include <acpi/acnamesp.h>
 
 
+/* TBD: This entire module is apparently obsolete and should be removed */
+
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsdumpdv")
 
-
+#ifdef ACPI_OBSOLETE_FUNCTIONS
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
+#include <acpi/acnamesp.h>
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_dump_one_device
@@ -59,13 +62,16 @@
  * PARAMETERS:  Handle              - Node to be dumped
  *              Level               - Nesting level of the handle
  *              Context             - Passed into walk_namespace
+ *              return_value        - Not used
+ *
+ * RETURN:      Status
  *
  * DESCRIPTION: Dump a single Node that represents a device
  *              This procedure is a user_function called by acpi_ns_walk_namespace.
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_dump_one_device (
 	acpi_handle                     obj_handle,
 	u32                             level,
@@ -108,12 +114,15 @@
  *
  * PARAMETERS:  None
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Dump all objects of type "device"
  *
  ******************************************************************************/
 
 void
-acpi_ns_dump_root_devices (void)
+acpi_ns_dump_root_devices (
+	void)
 {
 	acpi_handle                     sys_bus_handle;
 	acpi_status                     status;
@@ -141,6 +150,7 @@
 			 acpi_ns_dump_one_device, NULL, NULL);
 }
 
+#endif
 #endif
 
 
diff -Nru a/drivers/acpi/namespace/nseval.c b/drivers/acpi/namespace/nseval.c
--- a/drivers/acpi/namespace/nseval.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nseval.c	2005-04-19 01:34:14 -04:00
@@ -52,19 +52,33 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nseval")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ns_execute_control_method (
+	struct acpi_parameter_info      *info);
+
+static acpi_status
+acpi_ns_get_object_value (
+	struct acpi_parameter_info      *info);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_evaluate_relative
  *
- * PARAMETERS:  Pathname            - Name of method to execute, If NULL, the
- *                                    handle is the object to execute
- *              Info                - Method info block
+ * PARAMETERS:  Pathname        - Name of method to execute, If NULL, the
+ *                                handle is the object to execute
+ *              Info            - Method info block, contains:
+ *                  return_object   - Where to put method's return value (if
+ *                                    any).  If NULL, no value is returned.
+ *                  Params          - List of parameters to pass to the method,
+ *                                    terminated by NULL.  Params itself may be
+ *                                    NULL if no parameters are being passed.
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Find and execute the requested method using the handle as a
- *              scope
+ * DESCRIPTION: Evaluate the object or find and execute the requested method
  *
  * MUTEX:       Locks Namespace
  *
@@ -157,8 +171,8 @@
  *
  * FUNCTION:    acpi_ns_evaluate_by_name
  *
- * PARAMETERS:  Pathname            - Fully qualified pathname to the object
- *              Info                - Contains:
+ * PARAMETERS:  Pathname        - Fully qualified pathname to the object
+ *              Info                - Method info block, contains:
  *                  return_object   - Where to put method's return value (if
  *                                    any).  If NULL, no value is returned.
  *                  Params          - List of parameters to pass to the method,
@@ -167,8 +181,8 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Find and execute the requested method passing the given
- *              parameters
+ * DESCRIPTION: Evaluate the object or rind and execute the requested method
+ *              passing the given parameters
  *
  * MUTEX:       Locks Namespace
  *
@@ -241,17 +255,21 @@
  *
  * FUNCTION:    acpi_ns_evaluate_by_handle
  *
- * PARAMETERS:  Handle              - Method Node to execute
- *              Params              - List of parameters to pass to the method,
- *                                    terminated by NULL.  Params itself may be
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Method/Object Node to execute
+ *                  Parameters      - List of parameters to pass to the method,
+ *                                    terminated by NULL. Params itself may be
  *                                    NULL if no parameters are being passed.
- *              param_type          - Type of Parameter list
- *              return_object       - Where to put method's return value (if
- *                                    any).  If NULL, no value is returned.
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  parameter_type  - Type of Parameter list
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Execute the requested method passing the given parameters
+ * DESCRIPTION: Evaluate object or execute the requested method passing the
+ *              given parameters
  *
  * MUTEX:       Locks Namespace
  *
@@ -345,7 +363,16 @@
  *
  * FUNCTION:    acpi_ns_execute_control_method
  *
- * PARAMETERS:  Info            - Method info block (w/params)
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Method Node to execute
+ *                  Parameters      - List of parameters to pass to the method,
+ *                                    terminated by NULL. Params itself may be
+ *                                    NULL if no parameters are being passed.
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  parameter_type  - Type of Parameter list
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
  *
  * RETURN:      Status
  *
@@ -355,7 +382,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_execute_control_method (
 	struct acpi_parameter_info      *info)
 {
@@ -414,7 +441,10 @@
  *
  * FUNCTION:    acpi_ns_get_object_value
  *
- * PARAMETERS:  Info            - Method info block (w/params)
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Object's NS node
+ *                  return_object   - Where to put object value (if
+ *                                    any). If NULL, no value is returned.
  *
  * RETURN:      Status
  *
@@ -424,7 +454,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_get_object_value (
 	struct acpi_parameter_info      *info)
 {
diff -Nru a/drivers/acpi/namespace/nsinit.c b/drivers/acpi/namespace/nsinit.c
--- a/drivers/acpi/namespace/nsinit.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsinit.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,22 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsinit")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ns_init_one_object (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+static acpi_status
+acpi_ns_init_one_device (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
 
 /*******************************************************************************
  *
@@ -191,7 +207,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_init_one_object (
 	acpi_handle                     obj_handle,
 	u32                             level,
@@ -331,7 +347,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_init_one_device (
 	acpi_handle                     obj_handle,
 	u32                             nesting_level,
@@ -374,7 +390,8 @@
 	/*
 	 * Run _STA to determine if we can run _INI on the device.
 	 */
-	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD, pinfo.node, "_STA"));
+	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD,
+			   pinfo.node, METHOD_NAME__STA));
 	status = acpi_ut_execute_STA (pinfo.node, &flags);
 
 	if (ACPI_FAILURE (status)) {
@@ -399,8 +416,9 @@
 	/*
 	 * The device is present. Run _INI.
 	 */
-	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD, pinfo.node, "_INI"));
-	status = acpi_ns_evaluate_relative ("_INI", &pinfo);
+	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD,
+			   pinfo.node, METHOD_NAME__INI));
+	status = acpi_ns_evaluate_relative (METHOD_NAME__INI, &pinfo);
 	if (ACPI_FAILURE (status)) {
 		/* No _INI (AE_NOT_FOUND) means device requires no initialization */
 
diff -Nru a/drivers/acpi/namespace/nsload.c b/drivers/acpi/namespace/nsload.c
--- a/drivers/acpi/namespace/nsload.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsload.c	2005-04-19 01:34:14 -04:00
@@ -50,9 +50,24 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsload")
 
+/* Local prototypes */
 
-#ifndef ACPI_NO_METHOD_EXECUTION
+static acpi_status
+acpi_ns_load_table_by_type (
+	acpi_table_type                 table_type);
+
+#ifdef ACPI_FUTURE_IMPLEMENTATION
+acpi_status
+acpi_ns_unload_namespace (
+	acpi_handle                     handle);
+
+static acpi_status
+acpi_ns_delete_subtree (
+	acpi_handle                     start_handle);
+#endif
 
+
+#ifndef ACPI_NO_METHOD_EXECUTION
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_load_table
@@ -159,7 +174,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_load_table_by_type (
 	acpi_table_type                 table_type)
 {
@@ -321,8 +336,7 @@
 }
 
 
-#ifdef ACPI_FUTURE_USAGE
-
+#ifdef ACPI_FUTURE_IMPLEMENTATION
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_delete_subtree
@@ -339,7 +353,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_delete_subtree (
 	acpi_handle                     start_handle)
 {
@@ -453,8 +467,6 @@
 
 	return_ACPI_STATUS (status);
 }
-
-#endif  /*  ACPI_FUTURE_USAGE  */
-
+#endif
 #endif
 
diff -Nru a/drivers/acpi/namespace/nsnames.c b/drivers/acpi/namespace/nsnames.c
--- a/drivers/acpi/namespace/nsnames.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsnames.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,14 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsnames")
 
+/* Local prototypes */
+
+static void
+acpi_ns_build_external_path (
+	struct acpi_namespace_node      *node,
+	acpi_size                       size,
+	char                            *name_buffer);
+
 
 /*******************************************************************************
  *
@@ -66,7 +74,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ns_build_external_path (
 	struct acpi_namespace_node      *node,
 	acpi_size                       size,
@@ -126,7 +134,7 @@
  *
  * FUNCTION:    acpi_ns_get_external_pathname
  *
- * PARAMETERS:  Node            - NS node whose pathname is needed
+ * PARAMETERS:  Node            - Namespace node whose pathname is needed
  *
  * RETURN:      Pointer to storage containing the fully qualified name of
  *              the node, In external format (name segments separated by path
diff -Nru a/drivers/acpi/namespace/nsobject.c b/drivers/acpi/namespace/nsobject.c
--- a/drivers/acpi/namespace/nsobject.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsobject.c	2005-04-19 01:34:14 -04:00
@@ -60,6 +60,8 @@
  *              Type                - Type of object, or ACPI_TYPE_ANY if not
  *                                    known
  *
+ * RETURN:      Status
+ *
  * DESCRIPTION: Record the given object as the value associated with the
  *              name whose acpi_handle is passed.  If Object is NULL
  *              and Type is ACPI_TYPE_ANY, set the name as having no value.
@@ -97,7 +99,8 @@
 	if (!object && (ACPI_TYPE_ANY != type)) {
 		/* Null object */
 
-		ACPI_REPORT_ERROR (("ns_attach_object: Null object, but type not ACPI_TYPE_ANY\n"));
+		ACPI_REPORT_ERROR ((
+			"ns_attach_object: Null object, but type not ACPI_TYPE_ANY\n"));
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
@@ -112,7 +115,8 @@
 	/* Check if this object is already attached */
 
 	if (node->object == object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj %p already installed in name_obj %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"Obj %p already installed in name_obj %p\n",
 			object, node));
 
 		return_ACPI_STATUS (AE_OK);
@@ -192,7 +196,7 @@
  *
  * FUNCTION:    acpi_ns_detach_object
  *
- * PARAMETERS:  Node           - An node whose object will be detached
+ * PARAMETERS:  Node           - A Namespace node whose object will be detached
  *
  * RETURN:      None.
  *
@@ -248,7 +252,7 @@
  *
  * FUNCTION:    acpi_ns_get_attached_object
  *
- * PARAMETERS:  Node             - Parent Node to be examined
+ * PARAMETERS:  Node             - Namespace node
  *
  * RETURN:      Current value of the object field from the Node whose
  *              handle is passed
@@ -284,7 +288,7 @@
  *
  * FUNCTION:    acpi_ns_get_secondary_object
  *
- * PARAMETERS:  Node             - Parent Node to be examined
+ * PARAMETERS:  Node             - Namespace node
  *
  * RETURN:      Current value of the object field from the Node whose
  *              handle is passed.
diff -Nru a/drivers/acpi/namespace/nssearch.c b/drivers/acpi/namespace/nssearch.c
--- a/drivers/acpi/namespace/nssearch.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nssearch.c	2005-04-19 01:34:14 -04:00
@@ -49,15 +49,24 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nssearch")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ns_search_parent_tree (
+	u32                             target_name,
+	struct acpi_namespace_node      *node,
+	acpi_object_type                type,
+	struct acpi_namespace_node      **return_node);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_search_node
  *
- * PARAMETERS:  *target_name        - Ascii ACPI name to search for
- *              *Node               - Starting node where search will begin
- *              Type                - Object type to match
- *              **return_node       - Where the matched Named obj is returned
+ * PARAMETERS:  target_name     - Ascii ACPI name to search for
+ *              Node            - Starting node where search will begin
+ *              Type            - Object type to match
+ *              return_node     - Where the matched Named obj is returned
  *
  * RETURN:      Status
  *
@@ -163,10 +172,10 @@
  *
  * FUNCTION:    acpi_ns_search_parent_tree
  *
- * PARAMETERS:  *target_name        - Ascii ACPI name to search for
- *              *Node               - Starting node where search will begin
- *              Type                - Object type to match
- *              **return_node       - Where the matched Node is returned
+ * PARAMETERS:  target_name     - Ascii ACPI name to search for
+ *              Node            - Starting node where search will begin
+ *              Type            - Object type to match
+ *              return_node     - Where the matched Node is returned
  *
  * RETURN:      Status
  *
@@ -257,12 +266,12 @@
  *
  * PARAMETERS:  target_name         - Ascii ACPI name to search for (4 chars)
  *              walk_state          - Current state of the walk
- *              *Node               - Starting node where search will begin
+ *              Node                - Starting node where search will begin
  *              interpreter_mode    - Add names only in ACPI_MODE_LOAD_PASS_x.
  *                                    Otherwise,search only.
  *              Type                - Object type to match
  *              Flags               - Flags describing the search restrictions
- *              **return_node       - Where the Node is returned
+ *              return_node         - Where the Node is returned
  *
  * RETURN:      Status
  *
diff -Nru a/drivers/acpi/namespace/nsutils.c b/drivers/acpi/namespace/nsutils.c
--- a/drivers/acpi/namespace/nsutils.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsutils.c	2005-04-19 01:34:14 -04:00
@@ -51,6 +51,18 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsutils")
 
+/* Local prototypes */
+
+static u8
+acpi_ns_valid_path_separator (
+	char                            sep);
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+acpi_name
+acpi_ns_find_parent_name (
+	struct acpi_namespace_node      *node_to_search);
+#endif
+
 
 /*******************************************************************************
  *
@@ -59,7 +71,8 @@
  * PARAMETERS:  module_name         - Caller's module name (for error output)
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
+ *              internal_name       - Name or path of the namespace node
+ *              lookup_status       - Exception code from NS lookup
  *
  * RETURN:      None
  *
@@ -121,6 +134,9 @@
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
  *              Message             - Error message to use on failure
+ *              prefix_node         - Prefix relative to the path
+ *              Path                - Path to the node
+ *              method_status       - Execution status
  *
  * RETURN:      None
  *
@@ -161,8 +177,8 @@
  *
  * FUNCTION:    acpi_ns_print_node_pathname
  *
- * PARAMETERS:  Node                - Object
- *              Msg                 - Prefix message
+ * PARAMETERS:  Node            - Object
+ *              Message         - Prefix message
  *
  * DESCRIPTION: Print an object's full namespace pathname
  *              Manages allocation/freeing of a pathname buffer
@@ -172,7 +188,7 @@
 void
 acpi_ns_print_node_pathname (
 	struct acpi_namespace_node      *node,
-	char                            *msg)
+	char                            *message)
 {
 	struct acpi_buffer              buffer;
 	acpi_status                     status;
@@ -189,8 +205,8 @@
 
 	status = acpi_ns_handle_to_pathname (node, &buffer);
 	if (ACPI_SUCCESS (status)) {
-		if (msg) {
-			acpi_os_printf ("%s ", msg);
+		if (message) {
+			acpi_os_printf ("%s ", message);
 		}
 
 		acpi_os_printf ("[%s] (Node %p)", (char *) buffer.pointer, node);
@@ -224,7 +240,7 @@
  *
  * FUNCTION:    acpi_ns_valid_path_separator
  *
- * PARAMETERS:  Sep              - Character to be checked
+ * PARAMETERS:  Sep         - Character to be checked
  *
  * RETURN:      TRUE if a valid path separator
  *
@@ -232,7 +248,7 @@
  *
  ******************************************************************************/
 
-u8
+static u8
 acpi_ns_valid_path_separator (
 	char                            sep)
 {
@@ -245,10 +261,12 @@
  *
  * FUNCTION:    acpi_ns_get_type
  *
- * PARAMETERS:  Handle              - Parent Node to be examined
+ * PARAMETERS:  Node        - Parent Node to be examined
  *
  * RETURN:      Type field from Node whose handle is passed
  *
+ * DESCRIPTION: Return the type of a Namespace node
+ *
  ******************************************************************************/
 
 acpi_object_type
@@ -271,11 +289,13 @@
  *
  * FUNCTION:    acpi_ns_local
  *
- * PARAMETERS:  Type            - A namespace object type
+ * PARAMETERS:  Type        - A namespace object type
  *
  * RETURN:      LOCAL if names must be found locally in objects of the
  *              passed type, 0 if enclosing scopes should be searched
  *
+ * DESCRIPTION: Returns scope rule for the given object type.
+ *
  ******************************************************************************/
 
 u32
@@ -303,7 +323,7 @@
  * PARAMETERS:  Info            - Info struct initialized with the
  *                                external name pointer.
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Calculate the length of the internal (AML) namestring
  *              corresponding to the external (ASL) namestring.
@@ -551,14 +571,16 @@
  *
  * FUNCTION:    acpi_ns_externalize_name
  *
- * PARAMETERS:  *internal_name         - Internal representation of name
- *              **converted_name       - Where to return the resulting
- *                                       external representation of name
+ * PARAMETERS:  internal_name_length - Lenth of the internal name below
+ *              internal_name       - Internal representation of name
+ *              converted_name_length - Where the length is returned
+ *              converted_name      - Where the resulting external name
+ *                                    is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Convert internal name (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)
- *              to its external form (e.g. "\_PR_.CPU0")
+ *              to its external (printable) form (e.g. "\_PR_.CPU0")
  *
  ******************************************************************************/
 
@@ -717,8 +739,9 @@
  *
  * DESCRIPTION: Convert a namespace handle to a real Node
  *
- * Note: Real integer handles allow for more verification
- *       and keep all pointers within this subsystem.
+ * Note: Real integer handles would allow for more verification
+ *       and keep all pointers within this subsystem - however this introduces
+ *       more (and perhaps unnecessary) overhead.
  *
  ******************************************************************************/
 
@@ -775,7 +798,7 @@
 	return ((acpi_handle) node);
 
 
-/* ---------------------------------------------------
+/* Example future implementation ---------------------
 
 	if (!Node)
 	{
@@ -801,12 +824,13 @@
  *
  * RETURN:      none
  *
- * DESCRIPTION: free memory allocated for table storage.
+ * DESCRIPTION: free memory allocated for namespace and ACPI table storage.
  *
  ******************************************************************************/
 
 void
-acpi_ns_terminate (void)
+acpi_ns_terminate (
+	void)
 {
 	union acpi_operand_object       *obj_desc;
 
@@ -940,7 +964,6 @@
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 
 cleanup:
-	/* Cleanup */
 	if (internal_path) {
 		ACPI_MEM_FREE (internal_path);
 	}
@@ -950,55 +973,6 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ns_find_parent_name
- *
- * PARAMETERS:  *child_node            - Named Obj whose name is to be found
- *
- * RETURN:      The ACPI name
- *
- * DESCRIPTION: Search for the given obj in its parent scope and return the
- *              name segment, or "????" if the parent name can't be found
- *              (which "should not happen").
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-acpi_name
-acpi_ns_find_parent_name (
-	struct acpi_namespace_node      *child_node)
-{
-	struct acpi_namespace_node      *parent_node;
-
-
-	ACPI_FUNCTION_TRACE ("ns_find_parent_name");
-
-
-	if (child_node) {
-		/* Valid entry.  Get the parent Node */
-
-		parent_node = acpi_ns_get_parent_node (child_node);
-		if (parent_node) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-				"Parent of %p [%4.4s] is %p [%4.4s]\n",
-				child_node, acpi_ut_get_node_name (child_node),
-				parent_node, acpi_ut_get_node_name (parent_node)));
-
-			if (parent_node->name.integer) {
-				return_VALUE ((acpi_name) parent_node->name.integer);
-			}
-		}
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-			"Unable to find parent of %p (%4.4s)\n",
-			child_node, acpi_ut_get_node_name (child_node)));
-	}
-
-	return_VALUE (ACPI_UNKNOWN_NAME);
-}
-#endif
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ns_get_parent_node
  *
  * PARAMETERS:  Node       - Current table entry
@@ -1009,7 +983,6 @@
  *
  ******************************************************************************/
 
-
 struct acpi_namespace_node *
 acpi_ns_get_parent_node (
 	struct acpi_namespace_node      *node)
@@ -1030,7 +1003,6 @@
 		node = node->peer;
 	}
 
-
 	return (node->peer);
 }
 
@@ -1049,7 +1021,6 @@
  *
  ******************************************************************************/
 
-
 struct acpi_namespace_node *
 acpi_ns_get_next_valid_node (
 	struct acpi_namespace_node      *node)
@@ -1065,5 +1036,55 @@
 
 	return (node->peer);
 }
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_find_parent_name
+ *
+ * PARAMETERS:  *child_node            - Named Obj whose name is to be found
+ *
+ * RETURN:      The ACPI name
+ *
+ * DESCRIPTION: Search for the given obj in its parent scope and return the
+ *              name segment, or "????" if the parent name can't be found
+ *              (which "should not happen").
+ *
+ ******************************************************************************/
+
+acpi_name
+acpi_ns_find_parent_name (
+	struct acpi_namespace_node      *child_node)
+{
+	struct acpi_namespace_node      *parent_node;
+
+
+	ACPI_FUNCTION_TRACE ("ns_find_parent_name");
+
+
+	if (child_node) {
+		/* Valid entry.  Get the parent Node */
+
+		parent_node = acpi_ns_get_parent_node (child_node);
+		if (parent_node) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+				"Parent of %p [%4.4s] is %p [%4.4s]\n",
+				child_node, acpi_ut_get_node_name (child_node),
+				parent_node, acpi_ut_get_node_name (parent_node)));
+
+			if (parent_node->name.integer) {
+				return_VALUE ((acpi_name) parent_node->name.integer);
+			}
+		}
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"Unable to find parent of %p (%4.4s)\n",
+			child_node, acpi_ut_get_node_name (child_node)));
+	}
+
+	return_VALUE (ACPI_UNKNOWN_NAME);
+}
+#endif
 
 
diff -Nru a/drivers/acpi/namespace/nswalk.c b/drivers/acpi/namespace/nswalk.c
--- a/drivers/acpi/namespace/nswalk.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nswalk.c	2005-04-19 01:34:14 -04:00
@@ -56,7 +56,7 @@
  *
  * PARAMETERS:  Type                - Type of node to be searched for
  *              parent_node         - Parent node whose children we are
- *                                     getting
+ *                                    getting
  *              child_node          - Previous child that was found.
  *                                    The NEXT child will be returned
  *
diff -Nru a/drivers/acpi/namespace/nsxfeval.c b/drivers/acpi/namespace/nsxfeval.c
--- a/drivers/acpi/namespace/nsxfeval.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsxfeval.c	2005-04-19 01:34:14 -04:00
@@ -58,11 +58,11 @@
  * FUNCTION:    acpi_evaluate_object_typed
  *
  * PARAMETERS:  Handle              - Object handle (optional)
- *              *Pathname           - Object pathname (optional)
- *              **external_params   - List of parameters to pass to method,
+ *              Pathname            - Object pathname (optional)
+ *              external_params     - List of parameters to pass to method,
  *                                    terminated by NULL.  May be NULL
  *                                    if no parameters are being passed.
- *              *return_buffer      - Where to put method's return value (if
+ *              return_buffer       - Where to put method's return value (if
  *                                    any).  If NULL, no value is returned.
  *              return_type         - Expected type of return object
  *
@@ -73,6 +73,7 @@
  *              be valid (non-null)
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_evaluate_object_typed (
@@ -307,7 +308,8 @@
 				if (ACPI_SUCCESS (status)) {
 					/* Validate/Allocate/Clear caller buffer */
 
-					status = acpi_ut_initialize_buffer (return_buffer, buffer_space_needed);
+					status = acpi_ut_initialize_buffer (return_buffer,
+							  buffer_space_needed);
 					if (ACPI_FAILURE (status)) {
 						/*
 						 * Caller's buffer is too small or a new one can't be allocated
@@ -423,7 +425,8 @@
 		return_ACPI_STATUS (status);
 	}
 
-	status = acpi_ns_walk_namespace (type, start_object, max_depth, ACPI_NS_WALK_UNLOCK,
+	status = acpi_ns_walk_namespace (type, start_object, max_depth,
+			  ACPI_NS_WALK_UNLOCK,
 			  user_function, context, return_value);
 
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
@@ -525,7 +528,8 @@
 		}
 	}
 
-	status = info->user_function (obj_handle, nesting_level, info->context, return_value);
+	status = info->user_function (obj_handle, nesting_level, info->context,
+			 return_value);
 	return (status);
 }
 
diff -Nru a/drivers/acpi/namespace/nsxfname.c b/drivers/acpi/namespace/nsxfname.c
--- a/drivers/acpi/namespace/nsxfname.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsxfname.c	2005-04-19 01:34:14 -04:00
@@ -57,9 +57,9 @@
  * FUNCTION:    acpi_get_handle
  *
  * PARAMETERS:  Parent          - Object to search under (search scope).
- *              path_name       - Pointer to an asciiz string containing the
- *                                  name
- *              ret_handle      - Where the return handle is placed
+ *              Pathname        - Pointer to an asciiz string containing the
+ *                                name
+ *              ret_handle      - Where the return handle is returned
  *
  * RETURN:      Status
  *
@@ -220,7 +220,7 @@
  * FUNCTION:    acpi_get_object_info
  *
  * PARAMETERS:  Handle          - Object Handle
- *              Info            - Where the info is returned
+ *              Buffer          - Where the info is returned
  *
  * RETURN:      Status
  *
diff -Nru a/drivers/acpi/namespace/nsxfobj.c b/drivers/acpi/namespace/nsxfobj.c
--- a/drivers/acpi/namespace/nsxfobj.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/namespace/nsxfobj.c	2005-04-19 01:34:14 -04:00
@@ -56,7 +56,7 @@
  * FUNCTION:    acpi_get_type
  *
  * PARAMETERS:  Handle          - Handle of object whose type is desired
- *              *ret_type       - Where the type will be placed
+ *              ret_type        - Where the type will be placed
  *
  * RETURN:      Status
  *
@@ -258,5 +258,5 @@
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return (status);
 }
-EXPORT_SYMBOL(acpi_get_next_object);
 
+EXPORT_SYMBOL(acpi_get_next_object);
diff -Nru a/drivers/acpi/parser/psargs.c b/drivers/acpi/parser/psargs.c
--- a/drivers/acpi/parser/psargs.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/parser/psargs.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,16 @@
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("psargs")
 
+/* Local prototypes */
+
+static u32
+acpi_ps_get_next_package_length (
+	struct acpi_parse_state         *parser_state);
+
+static union acpi_parse_object *
+acpi_ps_get_next_field (
+	struct acpi_parse_state         *parser_state);
+
 
 /*******************************************************************************
  *
@@ -64,7 +74,7 @@
  *
  ******************************************************************************/
 
-u32
+static u32
 acpi_ps_get_next_package_length (
 	struct acpi_parse_state         *parser_state)
 {
@@ -78,7 +88,6 @@
 	encoded_length = (u32) ACPI_GET8 (parser_state->aml);
 	parser_state->aml++;
 
-
 	switch (encoded_length >> 6) /* bits 6-7 contain encoding scheme */ {
 	case 0: /* 1-byte encoding (bits 0-5) */
 
@@ -287,13 +296,14 @@
 		 * parent tree, but don't open a new scope -- we just want to lookup the
 		 * object  (MUST BE mode EXECUTE to perform upsearch)
 		 */
-		status = acpi_ns_lookup (&scope_info, path, ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL, &node);
+		status = acpi_ns_lookup (&scope_info, path, ACPI_TYPE_ANY,
+				 ACPI_IMODE_EXECUTE,
+				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+				 NULL, &node);
 		if (ACPI_SUCCESS (status) && method_call) {
 			if (node->type == ACPI_TYPE_METHOD) {
-				/*
-				 * This name is actually a control method invocation
-				 */
+				/* This name is actually a control method invocation */
+
 				method_desc = acpi_ns_get_attached_object (node);
 				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
 					"Control Method - %p Desc %p Path=%p\n",
@@ -360,7 +370,7 @@
 				/*
 				 * We got a NOT_FOUND during table load or we encountered
 				 * a cond_ref_of(x) where the target does not exist.
-				 * -- either case is ok
+				 * Either case is ok
 				 */
 				status = AE_OK;
 			}
@@ -486,12 +496,13 @@
  *
  ******************************************************************************/
 
-union acpi_parse_object *
+static union acpi_parse_object *
 acpi_ps_get_next_field (
 	struct acpi_parse_state         *parser_state)
 {
-	u32                             aml_offset = (u32) ACPI_PTR_DIFF (parser_state->aml,
-			 parser_state->aml_start);
+	u32                             aml_offset = (u32)
+			  ACPI_PTR_DIFF (parser_state->aml,
+					   parser_state->aml_start);
 	union acpi_parse_object         *field;
 	u16                             opcode;
 	u32                             name;
@@ -500,7 +511,7 @@
 	ACPI_FUNCTION_TRACE ("ps_get_next_field");
 
 
-	/* determine field type */
+	/* Determine field type */
 
 	switch (ACPI_GET8 (parser_state->aml)) {
 	default:
@@ -521,7 +532,6 @@
 		break;
 	}
 
-
 	/* Allocate a new field op */
 
 	field = acpi_ps_alloc_op (opcode);
@@ -582,10 +592,10 @@
  *
  * FUNCTION:    acpi_ps_get_next_arg
  *
- * PARAMETERS:  parser_state        - Current parser state object
+ * PARAMETERS:  walk_state          - Current state
+ *              parser_state        - Current parser state object
  *              arg_type            - The argument type (AML_*_ARG)
- *              arg_count           - If the argument points to a control method
- *                                    the method's argument is returned here.
+ *              return_arg          - Where the next arg is returned
  *
  * RETURN:      Status, and an op object containing the next argument.
  *
@@ -619,7 +629,7 @@
 	case ARGP_NAME:
 	case ARGP_NAMESTRING:
 
-		/* constants, strings, and namestrings are all the same size */
+		/* Constants, strings, and namestrings are all the same size */
 
 		arg = acpi_ps_alloc_op (AML_BYTE_OP);
 		if (!arg) {
@@ -654,7 +664,6 @@
 				else {
 					arg = field;
 				}
-
 				prev = field;
 			}
 
@@ -677,8 +686,8 @@
 
 			/* Fill in bytelist data */
 
-			arg->common.value.size = (u32) ACPI_PTR_DIFF (parser_state->pkg_end,
-					  parser_state->aml);
+			arg->common.value.size = (u32)
+				ACPI_PTR_DIFF (parser_state->pkg_end, parser_state->aml);
 			arg->named.data = parser_state->aml;
 
 			/* Skip to End of byte data */
@@ -706,7 +715,7 @@
 			status = acpi_ps_get_next_namepath (walk_state, parser_state, arg, 0);
 		}
 		else {
-			/* single complex argument, nothing returned */
+			/* Single complex argument, nothing returned */
 
 			walk_state->arg_count = 1;
 		}
@@ -716,7 +725,7 @@
 	case ARGP_DATAOBJ:
 	case ARGP_TERMARG:
 
-		/* single complex argument, nothing returned */
+		/* Single complex argument, nothing returned */
 
 		walk_state->arg_count = 1;
 		break;
@@ -727,7 +736,7 @@
 	case ARGP_OBJLIST:
 
 		if (parser_state->aml < parser_state->pkg_end) {
-			/* non-empty list of variable arguments, nothing returned */
+			/* Non-empty list of variable arguments, nothing returned */
 
 			walk_state->arg_count = ACPI_VAR_ARGS;
 		}
diff -Nru a/drivers/acpi/parser/psopcode.c b/drivers/acpi/parser/psopcode.c
--- a/drivers/acpi/parser/psopcode.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/parser/psopcode.c	2005-04-19 01:34:14 -04:00
@@ -44,6 +44,7 @@
 
 #include <acpi/acpi.h>
 #include <acpi/acparser.h>
+#include <acpi/acopcode.h>
 #include <acpi/amlcode.h>
 
 
@@ -51,23 +52,6 @@
 	 ACPI_MODULE_NAME    ("psopcode")
 
 
-#define _UNK                        0x6B
-/*
- * Reserved ASCII characters.  Do not use any of these for
- * internal opcodes, since they are used to differentiate
- * name strings from AML opcodes
- */
-#define _ASC                        0x6C
-#define _NAM                        0x6C
-#define _PFX                        0x6D
-#define _UNKNOWN_OPCODE             0x02    /* An example unknown opcode */
-
-#define MAX_EXTENDED_OPCODE         0x88
-#define NUM_EXTENDED_OPCODE         (MAX_EXTENDED_OPCODE + 1)
-#define MAX_INTERNAL_OPCODE
-#define NUM_INTERNAL_OPCODE         (MAX_INTERNAL_OPCODE + 1)
-
-
 /*******************************************************************************
  *
  * NAME:        acpi_gbl_aml_op_info
@@ -79,274 +63,9 @@
  *
  ******************************************************************************/
 
-
-/*
- * All AML opcodes and the parse-time arguments for each.  Used by the AML parser  Each list is compressed
- * into a 32-bit number and stored in the master opcode table at the end of this file.
- */
-
-
-#define ARGP_ACCESSFIELD_OP             ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_ACQUIRE_OP                 ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_WORDDATA)
-#define ARGP_ADD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_ALIAS_OP                   ARGP_LIST2 (ARGP_NAMESTRING, ARGP_NAME)
-#define ARGP_ARG0                       ARG_NONE
-#define ARGP_ARG1                       ARG_NONE
-#define ARGP_ARG2                       ARG_NONE
-#define ARGP_ARG3                       ARG_NONE
-#define ARGP_ARG4                       ARG_NONE
-#define ARGP_ARG5                       ARG_NONE
-#define ARGP_ARG6                       ARG_NONE
-#define ARGP_BANK_FIELD_OP              ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_FIELDLIST)
-#define ARGP_BIT_AND_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BIT_NAND_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BIT_NOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BIT_NOT_OP                 ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_BIT_OR_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BIT_XOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BREAK_OP                   ARG_NONE
-#define ARGP_BREAK_POINT_OP             ARG_NONE
-#define ARGP_BUFFER_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_BYTELIST)
-#define ARGP_BYTE_OP                    ARGP_LIST1 (ARGP_BYTEDATA)
-#define ARGP_BYTELIST_OP                ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_CONCAT_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_CONCAT_RES_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_COND_REF_OF_OP             ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SUPERNAME)
-#define ARGP_CONTINUE_OP                ARG_NONE
-#define ARGP_COPY_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SIMPLENAME)
-#define ARGP_CREATE_BIT_FIELD_OP        ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_CREATE_BYTE_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_CREATE_DWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_CREATE_FIELD_OP            ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_NAME)
-#define ARGP_CREATE_QWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_CREATE_WORD_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_DATA_REGION_OP             ARGP_LIST4 (ARGP_NAME,       ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG)
-#define ARGP_DEBUG_OP                   ARG_NONE
-#define ARGP_DECREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_DEREF_OF_OP                ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_DEVICE_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
-#define ARGP_DIVIDE_OP                  ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET,    ARGP_TARGET)
-#define ARGP_DWORD_OP                   ARGP_LIST1 (ARGP_DWORDDATA)
-#define ARGP_ELSE_OP                    ARGP_LIST2 (ARGP_PKGLENGTH,  ARGP_TERMLIST)
-#define ARGP_EVENT_OP                   ARGP_LIST1 (ARGP_NAME)
-#define ARGP_FATAL_OP                   ARGP_LIST3 (ARGP_BYTEDATA,   ARGP_DWORDDATA,     ARGP_TERMARG)
-#define ARGP_FIELD_OP                   ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_BYTEDATA,  ARGP_FIELDLIST)
-#define ARGP_FIND_SET_LEFT_BIT_OP       ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_FIND_SET_RIGHT_BIT_OP      ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_FROM_BCD_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_IF_OP                      ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
-#define ARGP_INCREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_INDEX_FIELD_OP             ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_BYTEDATA,  ARGP_FIELDLIST)
-#define ARGP_INDEX_OP                   ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_LAND_OP                    ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LEQUAL_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LGREATER_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LGREATEREQUAL_OP           ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LLESS_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LLESSEQUAL_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LNOT_OP                    ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_LNOTEQUAL_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LOAD_OP                    ARGP_LIST2 (ARGP_NAMESTRING, ARGP_SUPERNAME)
-#define ARGP_LOAD_TABLE_OP              ARGP_LIST6 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG,  ARGP_TERMARG,   ARGP_TERMARG)
-#define ARGP_LOCAL0                     ARG_NONE
-#define ARGP_LOCAL1                     ARG_NONE
-#define ARGP_LOCAL2                     ARG_NONE
-#define ARGP_LOCAL3                     ARG_NONE
-#define ARGP_LOCAL4                     ARG_NONE
-#define ARGP_LOCAL5                     ARG_NONE
-#define ARGP_LOCAL6                     ARG_NONE
-#define ARGP_LOCAL7                     ARG_NONE
-#define ARGP_LOR_OP                     ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_MATCH_OP                   ARGP_LIST6 (ARGP_TERMARG,    ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_TERMARG,   ARGP_TERMARG)
-#define ARGP_METHOD_OP                  ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_TERMLIST)
-#define ARGP_METHODCALL_OP              ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_MID_OP                     ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TARGET)
-#define ARGP_MOD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_MULTIPLY_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_MUTEX_OP                   ARGP_LIST2 (ARGP_NAME,       ARGP_BYTEDATA)
-#define ARGP_NAME_OP                    ARGP_LIST2 (ARGP_NAME,       ARGP_DATAOBJ)
-#define ARGP_NAMEDFIELD_OP              ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_NAMEPATH_OP                ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_NOOP_OP                    ARG_NONE
-#define ARGP_NOTIFY_OP                  ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
-#define ARGP_ONE_OP                     ARG_NONE
-#define ARGP_ONES_OP                    ARG_NONE
-#define ARGP_PACKAGE_OP                 ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_BYTEDATA,      ARGP_DATAOBJLIST)
-#define ARGP_POWER_RES_OP               ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_WORDDATA,  ARGP_OBJLIST)
-#define ARGP_PROCESSOR_OP               ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_DWORDDATA, ARGP_BYTEDATA,  ARGP_OBJLIST)
-#define ARGP_QWORD_OP                   ARGP_LIST1 (ARGP_QWORDDATA)
-#define ARGP_REF_OF_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_REGION_OP                  ARGP_LIST4 (ARGP_NAME,       ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_TERMARG)
-#define ARGP_RELEASE_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_RESERVEDFIELD_OP           ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_RESET_OP                   ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_RETURN_OP                  ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_REVISION_OP                ARG_NONE
-#define ARGP_SCOPE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_TERMLIST)
-#define ARGP_SHIFT_LEFT_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_SHIFT_RIGHT_OP             ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_SIGNAL_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_SIZE_OF_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_SLEEP_OP                   ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_STALL_OP                   ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_STATICSTRING_OP            ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_STORE_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_SUPERNAME)
-#define ARGP_STRING_OP                  ARGP_LIST1 (ARGP_CHARLIST)
-#define ARGP_SUBTRACT_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_THERMAL_ZONE_OP            ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
-#define ARGP_TIMER_OP                   ARG_NONE
-#define ARGP_TO_BCD_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_BUFFER_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_DEC_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_HEX_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_INTEGER_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_STRING_OP               ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_TYPE_OP                    ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_UNLOAD_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_VAR_PACKAGE_OP             ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_DATAOBJLIST)
-#define ARGP_WAIT_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
-#define ARGP_WHILE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
-#define ARGP_WORD_OP                    ARGP_LIST1 (ARGP_WORDDATA)
-#define ARGP_ZERO_OP                    ARG_NONE
-
-
-/*
- * All AML opcodes and the runtime arguments for each.  Used by the AML interpreter  Each list is compressed
- * into a 32-bit number and stored in the master opcode table at the end of this file.
- *
- * (Used by prep_operands procedure and the ASL Compiler)
- */
-
-
-#define ARGI_ACCESSFIELD_OP             ARGI_INVALID_OPCODE
-#define ARGI_ACQUIRE_OP                 ARGI_LIST2 (ARGI_MUTEX,      ARGI_INTEGER)
-#define ARGI_ADD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_ALIAS_OP                   ARGI_INVALID_OPCODE
-#define ARGI_ARG0                       ARG_NONE
-#define ARGI_ARG1                       ARG_NONE
-#define ARGI_ARG2                       ARG_NONE
-#define ARGI_ARG3                       ARG_NONE
-#define ARGI_ARG4                       ARG_NONE
-#define ARGI_ARG5                       ARG_NONE
-#define ARGI_ARG6                       ARG_NONE
-#define ARGI_BANK_FIELD_OP              ARGI_INVALID_OPCODE
-#define ARGI_BIT_AND_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BIT_NAND_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BIT_NOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BIT_NOT_OP                 ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
-#define ARGI_BIT_OR_OP                  ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BIT_XOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BREAK_OP                   ARG_NONE
-#define ARGI_BREAK_POINT_OP             ARG_NONE
-#define ARGI_BUFFER_OP                  ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_BYTE_OP                    ARGI_INVALID_OPCODE
-#define ARGI_BYTELIST_OP                ARGI_INVALID_OPCODE
-#define ARGI_CONCAT_OP                  ARGI_LIST3 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA,   ARGI_TARGETREF)
-#define ARGI_CONCAT_RES_OP              ARGI_LIST3 (ARGI_BUFFER,     ARGI_BUFFER,        ARGI_TARGETREF)
-#define ARGI_COND_REF_OF_OP             ARGI_LIST2 (ARGI_OBJECT_REF, ARGI_TARGETREF)
-#define ARGI_CONTINUE_OP                ARGI_INVALID_OPCODE
-#define ARGI_COPY_OP                    ARGI_LIST2 (ARGI_ANYTYPE,    ARGI_SIMPLE_TARGET)
-#define ARGI_CREATE_BIT_FIELD_OP        ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_CREATE_BYTE_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_CREATE_DWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_CREATE_FIELD_OP            ARGI_LIST4 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_INTEGER,      ARGI_REFERENCE)
-#define ARGI_CREATE_QWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_CREATE_WORD_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_DATA_REGION_OP             ARGI_LIST3 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING)
-#define ARGI_DEBUG_OP                   ARG_NONE
-#define ARGI_DECREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
-#define ARGI_DEREF_OF_OP                ARGI_LIST1 (ARGI_REF_OR_STRING)
-#define ARGI_DEVICE_OP                  ARGI_INVALID_OPCODE
-#define ARGI_DIVIDE_OP                  ARGI_LIST4 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF,    ARGI_TARGETREF)
-#define ARGI_DWORD_OP                   ARGI_INVALID_OPCODE
-#define ARGI_ELSE_OP                    ARGI_INVALID_OPCODE
-#define ARGI_EVENT_OP                   ARGI_INVALID_OPCODE
-#define ARGI_FATAL_OP                   ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_INTEGER)
-#define ARGI_FIELD_OP                   ARGI_INVALID_OPCODE
-#define ARGI_FIND_SET_LEFT_BIT_OP       ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
-#define ARGI_FIND_SET_RIGHT_BIT_OP      ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
-#define ARGI_FROM_BCD_OP                ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
-#define ARGI_IF_OP                      ARGI_INVALID_OPCODE
-#define ARGI_INCREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
-#define ARGI_INDEX_FIELD_OP             ARGI_INVALID_OPCODE
-#define ARGI_INDEX_OP                   ARGI_LIST3 (ARGI_COMPLEXOBJ, ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_LAND_OP                    ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
-#define ARGI_LEQUAL_OP                  ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
-#define ARGI_LGREATER_OP                ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
-#define ARGI_LGREATEREQUAL_OP           ARGI_INVALID_OPCODE
-#define ARGI_LLESS_OP                   ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
-#define ARGI_LLESSEQUAL_OP              ARGI_INVALID_OPCODE
-#define ARGI_LNOT_OP                    ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_LNOTEQUAL_OP               ARGI_INVALID_OPCODE
-#define ARGI_LOAD_OP                    ARGI_LIST2 (ARGI_REGION_OR_FIELD,ARGI_TARGETREF)
-#define ARGI_LOAD_TABLE_OP              ARGI_LIST6 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING,       ARGI_STRING,    ARGI_STRING, ARGI_ANYTYPE)
-#define ARGI_LOCAL0                     ARG_NONE
-#define ARGI_LOCAL1                     ARG_NONE
-#define ARGI_LOCAL2                     ARG_NONE
-#define ARGI_LOCAL3                     ARG_NONE
-#define ARGI_LOCAL4                     ARG_NONE
-#define ARGI_LOCAL5                     ARG_NONE
-#define ARGI_LOCAL6                     ARG_NONE
-#define ARGI_LOCAL7                     ARG_NONE
-#define ARGI_LOR_OP                     ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
-#define ARGI_MATCH_OP                   ARGI_LIST6 (ARGI_PACKAGE,    ARGI_INTEGER,   ARGI_COMPUTEDATA,      ARGI_INTEGER,ARGI_COMPUTEDATA,ARGI_INTEGER)
-#define ARGI_METHOD_OP                  ARGI_INVALID_OPCODE
-#define ARGI_METHODCALL_OP              ARGI_INVALID_OPCODE
-#define ARGI_MID_OP                     ARGI_LIST4 (ARGI_BUFFER_OR_STRING,ARGI_INTEGER,  ARGI_INTEGER,      ARGI_TARGETREF)
-#define ARGI_MOD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_MULTIPLY_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_MUTEX_OP                   ARGI_INVALID_OPCODE
-#define ARGI_NAME_OP                    ARGI_INVALID_OPCODE
-#define ARGI_NAMEDFIELD_OP              ARGI_INVALID_OPCODE
-#define ARGI_NAMEPATH_OP                ARGI_INVALID_OPCODE
-#define ARGI_NOOP_OP                    ARG_NONE
-#define ARGI_NOTIFY_OP                  ARGI_LIST2 (ARGI_DEVICE_REF, ARGI_INTEGER)
-#define ARGI_ONE_OP                     ARG_NONE
-#define ARGI_ONES_OP                    ARG_NONE
-#define ARGI_PACKAGE_OP                 ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_POWER_RES_OP               ARGI_INVALID_OPCODE
-#define ARGI_PROCESSOR_OP               ARGI_INVALID_OPCODE
-#define ARGI_QWORD_OP                   ARGI_INVALID_OPCODE
-#define ARGI_REF_OF_OP                  ARGI_LIST1 (ARGI_OBJECT_REF)
-#define ARGI_REGION_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
-#define ARGI_RELEASE_OP                 ARGI_LIST1 (ARGI_MUTEX)
-#define ARGI_RESERVEDFIELD_OP           ARGI_INVALID_OPCODE
-#define ARGI_RESET_OP                   ARGI_LIST1 (ARGI_EVENT)
-#define ARGI_RETURN_OP                  ARGI_INVALID_OPCODE
-#define ARGI_REVISION_OP                ARG_NONE
-#define ARGI_SCOPE_OP                   ARGI_INVALID_OPCODE
-#define ARGI_SHIFT_LEFT_OP              ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_SHIFT_RIGHT_OP             ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_SIGNAL_OP                  ARGI_LIST1 (ARGI_EVENT)
-#define ARGI_SIZE_OF_OP                 ARGI_LIST1 (ARGI_DATAOBJECT)
-#define ARGI_SLEEP_OP                   ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_STALL_OP                   ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_STATICSTRING_OP            ARGI_INVALID_OPCODE
-#define ARGI_STORE_OP                   ARGI_LIST2 (ARGI_DATAREFOBJ, ARGI_TARGETREF)
-#define ARGI_STRING_OP                  ARGI_INVALID_OPCODE
-#define ARGI_SUBTRACT_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_THERMAL_ZONE_OP            ARGI_INVALID_OPCODE
-#define ARGI_TIMER_OP                   ARG_NONE
-#define ARGI_TO_BCD_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_FIXED_TARGET)
-#define ARGI_TO_BUFFER_OP               ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
-#define ARGI_TO_DEC_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
-#define ARGI_TO_HEX_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
-#define ARGI_TO_INTEGER_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
-#define ARGI_TO_STRING_OP               ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_FIXED_TARGET)
-#define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_ANYTYPE)
-#define ARGI_UNLOAD_OP                  ARGI_LIST1 (ARGI_DDBHANDLE)
-#define ARGI_VAR_PACKAGE_OP             ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_WAIT_OP                    ARGI_LIST2 (ARGI_EVENT,      ARGI_INTEGER)
-#define ARGI_WHILE_OP                   ARGI_INVALID_OPCODE
-#define ARGI_WORD_OP                    ARGI_INVALID_OPCODE
-#define ARGI_ZERO_OP                    ARG_NONE
-
-
 /*
  * Summary of opcode types/flags
- */
-
-/******************************************************************************
+ *
 
  Opcodes that have associated namespace objects (AML_NSOBJECT flag)
 
@@ -460,14 +179,13 @@
 	AML_CREATE_DWORD_FIELD_OP
 	AML_CREATE_QWORD_FIELD_OP
 
-******************************************************************************/
+ ******************************************************************************/
 
 
 /*
- * Master Opcode information table.  A summary of everything we know about each opcode, all in one place.
+ * Master Opcode information table.  A summary of everything we know about each
+ * opcode, all in one place.
  */
-
-
 const struct acpi_opcode_info     acpi_gbl_aml_op_info[AML_NUM_OPCODES] =
 {
 /*! [Begin] no source code translation */
@@ -693,8 +411,7 @@
  *
  * PARAMETERS:  Opcode              - The AML opcode
  *
- * RETURN:      A pointer to the info about the opcode.  NULL if the opcode was
- *              not found in the table.
+ * RETURN:      A pointer to the info about the opcode.
  *
  * DESCRIPTION: Find AML opcode description based on the opcode.
  *              NOTE: This procedure must ALWAYS return a valid pointer!
@@ -731,7 +448,8 @@
 
 	default:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown AML opcode [%4.4X]\n", opcode));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Unknown AML opcode [%4.4X]\n", opcode));
 		break;
 	}
 
diff -Nru a/drivers/acpi/parser/psparse.c b/drivers/acpi/parser/psparse.c
--- a/drivers/acpi/parser/psparse.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/parser/psparse.c	2005-04-19 01:34:14 -04:00
@@ -64,6 +64,23 @@
 
 static u32                          acpi_gbl_depth = 0;
 
+/* Local prototypes */
+
+static void
+acpi_ps_complete_this_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+static acpi_status
+acpi_ps_next_parse_state (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	acpi_status                     callback_status);
+
+static acpi_status
+acpi_ps_parse_loop (
+	struct acpi_walk_state          *walk_state);
+
 
 /*******************************************************************************
  *
@@ -100,7 +117,7 @@
  *
  * PARAMETERS:  parser_state        - A parser state object
  *
- * RETURN:      Status
+ * RETURN:      Next AML opcode
  *
  * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)
  *
@@ -117,7 +134,6 @@
 	aml = parser_state->aml;
 	opcode = (u16) ACPI_GET8 (aml);
 
-
 	if (opcode == AML_EXTOP) {
 		/* Extended opcode */
 
@@ -142,7 +158,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ps_complete_this_op (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op)
@@ -272,7 +288,6 @@
 					next = NULL;
 				}
 			}
-
 			prev = next;
 		}
 	}
@@ -280,7 +295,7 @@
 
 cleanup:
 
-	/* Now we can actually delete the subtree rooted at op */
+	/* Now we can actually delete the subtree rooted at Op */
 
 	acpi_ps_delete_parse_tree (op);
 	return_VOID;
@@ -291,7 +306,9 @@
  *
  * FUNCTION:    acpi_ps_next_parse_state
  *
- * PARAMETERS:  parser_state        - Current parser state object
+ * PARAMETERS:  walk_state          - Current state
+ *              Op                  - Current parse op
+ *              callback_status     - Status from previous operation
  *
  * RETURN:      Status
  *
@@ -300,7 +317,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ps_next_parse_state (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op,
@@ -382,9 +399,8 @@
 
 	case AE_CTRL_TRANSFER:
 
-		/*
-		 * A method call (invocation) -- transfer control
-		 */
+		/* A method call (invocation) -- transfer control */
+
 		status = AE_CTRL_TRANSFER;
 		walk_state->prev_op = op;
 		walk_state->method_call_op = op;
@@ -397,6 +413,7 @@
 
 
 	default:
+
 		status = callback_status;
 		if ((callback_status & AE_CODE_MASK) == AE_CODE_CONTROL) {
 			status = AE_OK;
@@ -412,7 +429,7 @@
  *
  * FUNCTION:    acpi_ps_parse_loop
  *
- * PARAMETERS:  parser_state        - Current parser state object
+ * PARAMETERS:  walk_state          - Current state
  *
  * RETURN:      Status
  *
@@ -421,7 +438,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ps_parse_loop (
 	struct acpi_walk_state          *walk_state)
 {
@@ -443,6 +460,7 @@
 	walk_state->arg_types = 0;
 
 #if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))
+
 	if (walk_state->walk_type & ACPI_WALK_METHOD_RESTART) {
 		/* We are restarting a preempted control method */
 
@@ -471,7 +489,8 @@
 							acpi_format_exception (status)));
 
 					}
-					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "get_predicate Failed, %s\n",
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+						"get_predicate Failed, %s\n",
 						acpi_format_exception (status)));
 					return_ACPI_STATUS (status);
 				}
@@ -492,16 +511,15 @@
 	}
 #endif
 
-	/*
-	 * Iterative parsing loop, while there is more aml to process:
-	 */
+	/* Iterative parsing loop, while there is more AML to process: */
+
 	while ((parser_state->aml < parser_state->aml_end) || (op)) {
 		aml_op_start = parser_state->aml;
 		if (!op) {
 			/* Get the next opcode from the AML stream */
 
 			walk_state->aml_offset = (u32) ACPI_PTR_DIFF (parser_state->aml,
-					   parser_state->aml_start);
+					  parser_state->aml_start);
 			walk_state->opcode   = acpi_ps_peek_opcode (parser_state);
 
 			/*
@@ -578,8 +596,10 @@
 					INCREMENT_ARG_LIST (walk_state->arg_types);
 				}
 
-				/* Make sure that we found a NAME and didn't run out of arguments */
-
+				/*
+				 * Make sure that we found a NAME and didn't run out of
+				 * arguments
+				 */
 				if (!GET_CURRENT_ARG_TYPE (walk_state->arg_types)) {
 					status = AE_AML_NO_OPERAND;
 					goto close_this_op;
@@ -597,12 +617,13 @@
 
 				status = walk_state->descending_callback (walk_state, &op);
 				if (ACPI_FAILURE (status)) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "During name lookup/catalog, %s\n",
-							acpi_format_exception (status)));
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+						"During name lookup/catalog, %s\n",
+						acpi_format_exception (status)));
 					goto close_this_op;
 				}
 
-				if (op == NULL) {
+				if (!op) {
 					continue;
 				}
 
@@ -659,7 +680,7 @@
 
 				if ((walk_state->descending_callback != NULL)) {
 					/*
-					 * Find the object.  This will either insert the object into
+					 * Find the object. This will either insert the object into
 					 * the namespace or simply look it up
 					 */
 					walk_state->op = op;
@@ -688,11 +709,15 @@
 		}
 
 
-		/* Start arg_count at zero because we don't know if there are any args yet */
-
+		/*
+		 * Start arg_count at zero because we don't know if there are
+		 * any args yet
+		 */
 		walk_state->arg_count = 0;
 
-		if (walk_state->arg_types) /* Are there any arguments that must be processed? */ {
+		/* Are there any arguments that must be processed? */
+
+		if (walk_state->arg_types) {
 			/* Get arguments */
 
 			switch (op->common.aml_opcode) {
@@ -720,14 +745,18 @@
 
 			default:
 
-				/* Op is not a constant or string, append each argument to the Op */
-
+				/*
+				 * Op is not a constant or string, append each argument
+				 * to the Op
+				 */
 				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) &&
 						!walk_state->arg_count) {
-					walk_state->aml_offset = (u32) ACPI_PTR_DIFF (parser_state->aml,
-							   parser_state->aml_start);
+					walk_state->aml_offset = (u32)
+						ACPI_PTR_DIFF (parser_state->aml, parser_state->aml_start);
+
 					status = acpi_ps_get_next_arg (walk_state, parser_state,
-							 GET_CURRENT_ARG_TYPE (walk_state->arg_types), &arg);
+							 GET_CURRENT_ARG_TYPE (walk_state->arg_types),
+							 &arg);
 					if (ACPI_FAILURE (status)) {
 						goto close_this_op;
 					}
@@ -752,7 +781,8 @@
 					 * Save the length and address of the body
 					 */
 					op->named.data   = parser_state->aml;
-					op->named.length = (u32) (parser_state->pkg_end - parser_state->aml);
+					op->named.length = (u32) (parser_state->pkg_end -
+							   parser_state->aml);
 
 					/* Skip body of method */
 
@@ -773,7 +803,8 @@
 						 * to parse them correctly.
 						 */
 						op->named.data   = aml_op_start;
-						op->named.length = (u32) (parser_state->pkg_end - aml_op_start);
+						op->named.length = (u32) (parser_state->pkg_end -
+								   aml_op_start);
 
 						/* Skip body */
 
@@ -785,7 +816,8 @@
 				case AML_WHILE_OP:
 
 					if (walk_state->control_state) {
-						walk_state->control_state->control.package_end = parser_state->pkg_end;
+						walk_state->control_state->control.package_end =
+							parser_state->pkg_end;
 					}
 					break;
 
@@ -801,8 +833,10 @@
 		/* Check for arguments that need to be processed */
 
 		if (walk_state->arg_count) {
-			/* There are arguments (complex ones), push Op and prepare for argument */
-
+			/*
+			 * There are arguments (complex ones), push Op and
+			 * prepare for argument
+			 */
 			status = acpi_ps_push_scope (parser_state, op,
 					 walk_state->arg_types, walk_state->arg_count);
 			if (ACPI_FAILURE (status)) {
@@ -812,8 +846,10 @@
 			continue;
 		}
 
-		/* All arguments have been processed -- Op is complete, prepare for next */
-
+		/*
+		 * All arguments have been processed -- Op is complete,
+		 * prepare for next
+		 */
 		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 		if (walk_state->op_info->flags & AML_NAMED) {
 			if (acpi_gbl_depth) {
@@ -880,9 +916,8 @@
 
 		case AE_CTRL_TRANSFER:
 
-			/*
-			 * We are about to transfer to a called method.
-			 */
+			/* We are about to transfer to a called method. */
+
 			walk_state->prev_op = op;
 			walk_state->prev_arg_types = walk_state->arg_types;
 			return_ACPI_STATUS (status);
@@ -1051,10 +1086,7 @@
  *
  * FUNCTION:    acpi_ps_parse_aml
  *
- * PARAMETERS:  start_scope     - The starting point of the parse.  Becomes the
- *                                root of the parsed op tree.
- *              Aml             - Pointer to the raw AML code to parse
- *              aml_size        - Length of the AML to parse
+ * PARAMETERS:  walk_state      - Current state
  *
  *
  * RETURN:      Status
@@ -1076,8 +1108,10 @@
 
 	ACPI_FUNCTION_TRACE ("ps_parse_aml");
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Entered with walk_state=%p Aml=%p size=%X\n",
-		walk_state, walk_state->parser_state.aml, walk_state->parser_state.aml_size));
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+		"Entered with walk_state=%p Aml=%p size=%X\n",
+		walk_state, walk_state->parser_state.aml,
+		walk_state->parser_state.aml_size));
 
 
 	/* Create and initialize a new thread state */
@@ -1142,9 +1176,10 @@
 			if ((status == AE_ALREADY_EXISTS) &&
 				(!walk_state->method_desc->method.semaphore)) {
 				/*
-				 * This method is marked not_serialized, but it tried to create a named
-				 * object, causing the second thread entrance to fail.  We will workaround
-				 * this by marking the method permanently as Serialized.
+				 * This method is marked not_serialized, but it tried to create
+				 * a named object, causing the second thread entrance to fail.
+				 * We will workaround this by marking the method permanently
+				 * as Serialized.
 				 */
 				walk_state->method_desc->method.method_flags |= AML_METHOD_SERIALIZED;
 				walk_state->method_desc->method.concurrency = 1;
@@ -1187,7 +1222,8 @@
 
 		previous_walk_state = walk_state;
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "return_value=%p, implicit_value=%p State=%p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+			"return_value=%p, implicit_value=%p State=%p\n",
 			walk_state->return_desc, walk_state->implicit_return_obj, walk_state));
 
 		/* Check if we have restarted a preempted walk */
@@ -1231,12 +1267,14 @@
 		 */
 		else if (previous_walk_state->caller_return_desc) {
 			if (previous_walk_state->implicit_return_obj) {
-				*(previous_walk_state->caller_return_desc) = previous_walk_state->implicit_return_obj;
+				*(previous_walk_state->caller_return_desc) =
+					previous_walk_state->implicit_return_obj;
 			}
 			else {
 				 /* NULL if no return value */
 
-				*(previous_walk_state->caller_return_desc) = previous_walk_state->return_desc;
+				*(previous_walk_state->caller_return_desc) =
+					previous_walk_state->return_desc;
 			}
 		}
 		else {
diff -Nru a/drivers/acpi/parser/psscope.c b/drivers/acpi/parser/psscope.c
--- a/drivers/acpi/parser/psscope.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/parser/psscope.c	2005-04-19 01:34:14 -04:00
@@ -65,6 +65,7 @@
 acpi_ps_get_parent_scope (
 	struct acpi_parse_state         *parser_state)
 {
+
 	return (parser_state->scope->parse_scope.op);
 }
 
@@ -87,8 +88,10 @@
 acpi_ps_has_completed_scope (
 	struct acpi_parse_state         *parser_state)
 {
-	return ((u8) ((parser_state->aml >= parser_state->scope->parse_scope.arg_end ||
-			   !parser_state->scope->parse_scope.arg_count)));
+
+	return ((u8)
+			((parser_state->aml >= parser_state->scope->parse_scope.arg_end ||
+			 !parser_state->scope->parse_scope.arg_count)));
 }
 
 
@@ -167,23 +170,23 @@
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	scope->common.data_type        = ACPI_DESC_TYPE_STATE_PSCOPE;
-	scope->parse_scope.op          = op;
-	scope->parse_scope.arg_list    = remaining_args;
-	scope->parse_scope.arg_count   = arg_count;
-	scope->parse_scope.pkg_end     = parser_state->pkg_end;
+	scope->common.data_type    = ACPI_DESC_TYPE_STATE_PSCOPE;
+	scope->parse_scope.op      = op;
+	scope->parse_scope.arg_list = remaining_args;
+	scope->parse_scope.arg_count = arg_count;
+	scope->parse_scope.pkg_end = parser_state->pkg_end;
 
 	/* Push onto scope stack */
 
 	acpi_ut_push_generic_state (&parser_state->scope, scope);
 
 	if (arg_count == ACPI_VAR_ARGS) {
-		/* multiple arguments */
+		/* Multiple arguments */
 
 		scope->parse_scope.arg_end = parser_state->pkg_end;
 	}
 	else {
-		/* single argument */
+		/* Single argument */
 
 		scope->parse_scope.arg_end = ACPI_TO_POINTER (ACPI_MAX_PTR);
 	}
@@ -221,18 +224,17 @@
 	ACPI_FUNCTION_TRACE ("ps_pop_scope");
 
 
-	/*
-	 * Only pop the scope if there is in fact a next scope
-	 */
+	/* Only pop the scope if there is in fact a next scope */
+
 	if (scope->common.next) {
 		scope = acpi_ut_pop_generic_state (&parser_state->scope);
 
 		/* return to parsing previous op */
 
-		*op                     = scope->parse_scope.op;
-		*arg_list               = scope->parse_scope.arg_list;
-		*arg_count              = scope->parse_scope.arg_count;
-		parser_state->pkg_end   = scope->parse_scope.pkg_end;
+		*op                 = scope->parse_scope.op;
+		*arg_list           = scope->parse_scope.arg_list;
+		*arg_count          = scope->parse_scope.arg_count;
+		parser_state->pkg_end = scope->parse_scope.pkg_end;
 
 		/* All done with this scope state structure */
 
@@ -241,12 +243,13 @@
 	else {
 		/* empty parse stack, prepare to fetch next opcode */
 
-		*op                     = NULL;
-		*arg_list               = 0;
-		*arg_count              = 0;
+		*op       = NULL;
+		*arg_list = 0;
+		*arg_count = 0;
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped Op %p Args %X\n", *op, *arg_count));
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+		"Popped Op %p Args %X\n", *op, *arg_count));
 	return_VOID;
 }
 
@@ -257,7 +260,7 @@
  *
  * PARAMETERS:  parser_state        - Current parser state object
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Destroy available list, remaining stack levels, and return
  *              root scope
diff -Nru a/drivers/acpi/parser/pstree.c b/drivers/acpi/parser/pstree.c
--- a/drivers/acpi/parser/pstree.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/parser/pstree.c	2005-04-19 01:34:14 -04:00
@@ -49,6 +49,14 @@
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("pstree")
 
+/* Local prototypes */
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+union acpi_parse_object *
+acpi_ps_get_child (
+	union acpi_parse_object         *op);
+#endif
+
 
 /*******************************************************************************
  *
@@ -57,7 +65,7 @@
  * PARAMETERS:  Op              - Get an argument for this op
  *              Argn            - Nth argument to get
  *
- * RETURN:      The argument (as an Op object).  NULL if argument does not exist
+ * RETURN:      The argument (as an Op object). NULL if argument does not exist
  *
  * DESCRIPTION: Get the specified op's argument.
  *
@@ -152,7 +160,6 @@
 		return;
 	}
 
-
 	/* Append the argument to the linked argument list */
 
 	if (op->common.value.arg) {
@@ -164,14 +171,12 @@
 		}
 		prev_arg->common.next = arg;
 	}
-
 	else {
 		/* No argument list, this will be the first argument */
 
 		op->common.value.arg = arg;
 	}
 
-
 	/* Set the parent in this arg and any args linked after it */
 
 	while (arg) {
@@ -182,73 +187,6 @@
 
 
 #ifdef ACPI_FUTURE_USAGE
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ps_get_child
- *
- * PARAMETERS:  Op              - Get the child of this Op
- *
- * RETURN:      Child Op, Null if none is found.
- *
- * DESCRIPTION: Get op's children or NULL if none
- *
- ******************************************************************************/
-union acpi_parse_object *
-acpi_ps_get_child (
-	union acpi_parse_object         *op)
-{
-	union acpi_parse_object         *child = NULL;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	switch (op->common.aml_opcode) {
-	case AML_SCOPE_OP:
-	case AML_ELSE_OP:
-	case AML_DEVICE_OP:
-	case AML_THERMAL_ZONE_OP:
-	case AML_INT_METHODCALL_OP:
-
-		child = acpi_ps_get_arg (op, 0);
-		break;
-
-
-	case AML_BUFFER_OP:
-	case AML_PACKAGE_OP:
-	case AML_METHOD_OP:
-	case AML_IF_OP:
-	case AML_WHILE_OP:
-	case AML_FIELD_OP:
-
-		child = acpi_ps_get_arg (op, 1);
-		break;
-
-
-	case AML_POWER_RES_OP:
-	case AML_INDEX_FIELD_OP:
-
-		child = acpi_ps_get_arg (op, 2);
-		break;
-
-
-	case AML_PROCESSOR_OP:
-	case AML_BANK_FIELD_OP:
-
-		child = acpi_ps_get_arg (op, 3);
-		break;
-
-
-	default:
-		/* All others have no children */
-		break;
-	}
-
-	return (child);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ps_get_depth_next
@@ -280,21 +218,21 @@
 		return (NULL);
 	}
 
-	/* look for an argument or child */
+	/* Look for an argument or child */
 
 	next = acpi_ps_get_arg (op, 0);
 	if (next) {
 		return (next);
 	}
 
-	/* look for a sibling */
+	/* Look for a sibling */
 
 	next = op->common.next;
 	if (next) {
 		return (next);
 	}
 
-	/* look for a sibling of parent */
+	/* Look for a sibling of parent */
 
 	parent = op->common.parent;
 
@@ -305,13 +243,13 @@
 		}
 
 		if (arg == origin) {
-			/* reached parent of origin, end search */
+			/* Reached parent of origin, end search */
 
 			return (NULL);
 		}
 
 		if (parent->common.next) {
-			/* found sibling of parent */
+			/* Found sibling of parent */
 
 			return (parent->common.next);
 		}
@@ -322,6 +260,75 @@
 
 	return (next);
 }
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_child
+ *
+ * PARAMETERS:  Op              - Get the child of this Op
+ *
+ * RETURN:      Child Op, Null if none is found.
+ *
+ * DESCRIPTION: Get op's children or NULL if none
+ *
+ ******************************************************************************/
+
+union acpi_parse_object *
+acpi_ps_get_child (
+	union acpi_parse_object         *op)
+{
+	union acpi_parse_object         *child = NULL;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	switch (op->common.aml_opcode) {
+	case AML_SCOPE_OP:
+	case AML_ELSE_OP:
+	case AML_DEVICE_OP:
+	case AML_THERMAL_ZONE_OP:
+	case AML_INT_METHODCALL_OP:
+
+		child = acpi_ps_get_arg (op, 0);
+		break;
+
+
+	case AML_BUFFER_OP:
+	case AML_PACKAGE_OP:
+	case AML_METHOD_OP:
+	case AML_IF_OP:
+	case AML_WHILE_OP:
+	case AML_FIELD_OP:
+
+		child = acpi_ps_get_arg (op, 1);
+		break;
+
+
+	case AML_POWER_RES_OP:
+	case AML_INDEX_FIELD_OP:
+
+		child = acpi_ps_get_arg (op, 2);
+		break;
+
+
+	case AML_PROCESSOR_OP:
+	case AML_BANK_FIELD_OP:
+
+		child = acpi_ps_get_arg (op, 3);
+		break;
+
+
+	default:
+		/* All others have no children */
+		break;
+	}
+
+	return (child);
+}
+#endif
 
 #endif  /*  ACPI_FUTURE_USAGE  */
 
diff -Nru a/drivers/acpi/parser/psutils.c b/drivers/acpi/parser/psutils.c
--- a/drivers/acpi/parser/psutils.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/parser/psutils.c	2005-04-19 01:34:14 -04:00
@@ -45,7 +45,6 @@
 #include <acpi/acpi.h>
 #include <acpi/acparser.h>
 #include <acpi/amlcode.h>
-#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("psutils")
@@ -57,7 +56,7 @@
  *
  * PARAMETERS:  None
  *
- * RETURN:      scope_op
+ * RETURN:      A new Scope object, null on failure
  *
  * DESCRIPTION: Create a Scope and associated namepath op with the root name
  *
@@ -75,7 +74,6 @@
 		return (NULL);
 	}
 
-
 	scope_op->named.name = ACPI_ROOT_NAME;
 	return (scope_op);
 }
@@ -88,10 +86,9 @@
  * PARAMETERS:  Op              - A newly allocated Op object
  *              Opcode          - Opcode to store in the Op
  *
- * RETURN:      Status
+ * RETURN:      None
  *
- * DESCRIPTION: Allocate an acpi_op, choose op type (and thus size) based on
- *              opcode
+ * DESCRIPTION: Initialize a parse (Op) object
  *
  ******************************************************************************/
 
@@ -107,7 +104,8 @@
 	op->common.aml_opcode = opcode;
 
 	ACPI_DISASM_ONLY_MEMBERS (ACPI_STRNCPY (op->common.aml_op_name,
-			(acpi_ps_get_opcode_info (opcode))->name, sizeof (op->common.aml_op_name)));
+			(acpi_ps_get_opcode_info (opcode))->name,
+				sizeof (op->common.aml_op_name)));
 }
 
 
@@ -117,7 +115,7 @@
  *
  * PARAMETERS:  Opcode          - Opcode that will be stored in the new Op
  *
- * RETURN:      Pointer to the new Op.
+ * RETURN:      Pointer to the new Op, null on failure
  *
  * DESCRIPTION: Allocate an acpi_op, choose op type (and thus size) based on
  *              opcode.  A cache of opcodes is available for the pure
@@ -274,7 +272,6 @@
 acpi_ps_get_name (
 	union acpi_parse_object         *op)
 {
-
 
 	/* The "generic" object has no name associated with it */
 
diff -Nru a/drivers/acpi/parser/pswalk.c b/drivers/acpi/parser/pswalk.c
--- a/drivers/acpi/parser/pswalk.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/parser/pswalk.c	2005-04-19 01:34:14 -04:00
@@ -90,17 +90,15 @@
 			}
 		}
 
-		/*
-		 * No more children, this Op is complete.
-		 */
+		/* No more children, this Op is complete. */
+
 		next = op->common.next;
 		parent = op->common.parent;
 
 		acpi_ps_free_op (op);
 
-		/*
-		 * If we are back to the starting point, the walk is complete.
-		 */
+		/* If we are back to the starting point, the walk is complete. */
+
 		if (op == subtree_root) {
 			return_VOID;
 		}
@@ -111,5 +109,6 @@
 			op = parent;
 		}
 	}
+
 	return_VOID;
 }
diff -Nru a/drivers/acpi/parser/psxface.c b/drivers/acpi/parser/psxface.c
--- a/drivers/acpi/parser/psxface.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/parser/psxface.c	2005-04-19 01:34:14 -04:00
@@ -57,13 +57,16 @@
  *
  * FUNCTION:    acpi_psx_execute
  *
- * PARAMETERS:  Info->Node          - A method object containing both the AML
- *                                    address and length.
- *              **Params            - List of parameters to pass to method,
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Method Node to execute
+ *                  Parameters      - List of parameters to pass to the method,
  *                                    terminated by NULL. Params itself may be
  *                                    NULL if no parameters are being passed.
- *              **return_obj_desc   - Return object from execution of the
- *                                    method.
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  parameter_type  - Type of Parameter list
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
  *
  * RETURN:      Status
  *
@@ -196,9 +199,8 @@
 		goto cleanup3;
 	}
 
-	/*
-	 * The walk of the parse tree is where we actually execute the method
-	 */
+	/* The walk of the parse tree is where we actually execute the method */
+
 	status = acpi_ps_parse_aml (walk_state);
 	goto cleanup2; /* Walk state already deleted */
 
@@ -217,7 +219,8 @@
 		for (i = 0; info->parameters[i]; i++) {
 			/* Ignore errors, just do them all */
 
-			(void) acpi_ut_update_object_reference (info->parameters[i], REF_DECREMENT);
+			(void) acpi_ut_update_object_reference (
+					 info->parameters[i], REF_DECREMENT);
 		}
 	}
 
diff -Nru a/drivers/acpi/resources/rsaddr.c b/drivers/acpi/resources/rsaddr.c
--- a/drivers/acpi/resources/rsaddr.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rsaddr.c	2005-04-19 01:34:14 -04:00
@@ -77,21 +77,21 @@
 	u8                              **output_buffer,
 	acpi_size                       *structure_size)
 {
-	u8                              *buffer = byte_stream_buffer;
-	struct acpi_resource            *output_struct = (void *) *output_buffer;
-	u8                              *temp_ptr;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address16);
 	u32                             index;
 	u16                             temp16;
 	u8                              temp8;
+	u8                              *temp_ptr;
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_address16);
 
 
 	ACPI_FUNCTION_TRACE ("rs_address16_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -104,9 +104,8 @@
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_ADDRESS16;
 
-	/*
-	 * Get the Resource Type (Byte3)
-	 */
+	/* Get the Resource Type (Byte3) */
+
 	buffer += 2;
 	temp8 = *buffer;
 
@@ -118,9 +117,8 @@
 
 	output_struct->data.address16.resource_type = temp8;
 
-	/*
-	 * Get the General Flags (Byte4)
-	 */
+	/* Get the General Flags (Byte4) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -140,9 +138,8 @@
 
 	output_struct->data.address16.max_address_fixed = (temp8 >> 3) & 0x01;
 
-	/*
-	 * Get the Type Specific Flags (Byte5)
-	 */
+	/* Get the Type Specific Flags (Byte5) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -165,39 +162,34 @@
 		}
 	}
 
-	/*
-	 * Get Granularity (Bytes 6-7)
-	 */
+	/* Get Granularity (Bytes 6-7) */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.granularity, buffer);
 
-	/*
-	 * Get min_address_range (Bytes 8-9)
-	 */
+	/* Get min_address_range (Bytes 8-9) */
+
 	buffer += 2;
 	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.min_address_range, buffer);
 
-	/*
-	 * Get max_address_range (Bytes 10-11)
-	 */
+	/* Get max_address_range (Bytes 10-11) */
+
 	buffer += 2;
 	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.max_address_range, buffer);
 
-	/*
-	 * Get address_translation_offset (Bytes 12-13)
-	 */
+	/* Get address_translation_offset (Bytes 12-13) */
+
 	buffer += 2;
-	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.address_translation_offset, buffer);
+	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.address_translation_offset,
+		buffer);
+
+	/* Get address_length (Bytes 14-15) */
 
-	/*
-	 * Get address_length (Bytes 14-15)
-	 */
 	buffer += 2;
 	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.address_length, buffer);
 
-	/*
-	 * Resource Source Index (if present)
-	 */
+	/* Resource Source Index (if present) */
+
 	buffer += 2;
 
 	/*
@@ -225,7 +217,8 @@
 		output_struct->data.address16.resource_source.string_ptr =
 				(char *)((u8 * )output_struct + struct_size);
 
-		temp_ptr = (u8 *) output_struct->data.address16.resource_source.string_ptr;
+		temp_ptr = (u8 *)
+			output_struct->data.address16.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -239,9 +232,8 @@
 			index += 1;
 		}
 
-		/*
-		 * Add the terminating null
-		 */
+		/* Add the terminating null */
+
 		*temp_ptr = 0x00;
 
 		output_struct->data.address16.resource_source.string_length = index + 1;
@@ -260,14 +252,12 @@
 		output_struct->data.address16.resource_source.string_ptr = NULL;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -305,28 +295,24 @@
 	ACPI_FUNCTION_TRACE ("rs_address16_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x88;
 	buffer += 1;
 
-	/*
-	 * Save a pointer to the Length field - to be filled in later
-	 */
+	/* Save a pointer to the Length field - to be filled in later */
+
 	length_field = buffer;
 	buffer += 2;
 
-	/*
-	 * Set the Resource Type (Memory, Io, bus_number)
-	 */
+	/* Set the Resource Type (Memory, Io, bus_number) */
+
 	temp8 = (u8) (linked_list->data.address16.resource_type & 0x03);
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the general flags
-	 */
+	/* Set the general flags */
+
 	temp8 = (u8) (linked_list->data.address16.producer_consumer & 0x01);
 
 	temp8 |= (linked_list->data.address16.decode & 0x01) << 1;
@@ -336,9 +322,8 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the type specific flags
-	 */
+	/* Set the type specific flags */
+
 	temp8 = 0;
 
 	if (ACPI_MEMORY_RANGE == linked_list->data.address16.resource_type) {
@@ -362,39 +347,34 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the address space granularity
-	 */
+	/* Set the address space granularity */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.granularity);
 	buffer += 2;
 
-	/*
-	 * Set the address range minimum
-	 */
+	/* Set the address range minimum */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.min_address_range);
 	buffer += 2;
 
-	/*
-	 * Set the address range maximum
-	 */
+	/* Set the address range maximum */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.max_address_range);
 	buffer += 2;
 
-	/*
-	 * Set the address translation offset
-	 */
-	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.address_translation_offset);
+	/* Set the address translation offset */
+
+	ACPI_MOVE_32_TO_16 (buffer,
+		&linked_list->data.address16.address_translation_offset);
 	buffer += 2;
 
-	/*
-	 * Set the address length
-	 */
+	/* Set the address length */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.address_length);
 	buffer += 2;
 
-	/*
-	 * Resource Source Index and Resource Source are optional
-	 */
+	/* Resource Source Index and Resource Source are optional */
+
 	if (0 != linked_list->data.address16.resource_source.string_length) {
 		temp8 = (u8) linked_list->data.address16.resource_source.index;
 
@@ -403,9 +383,8 @@
 
 		temp_pointer = (char *) buffer;
 
-		/*
-		 * Copy the string
-		 */
+		/* Copy the string */
+
 		ACPI_STRCPY (temp_pointer,
 				linked_list->data.address16.resource_source.string_ptr);
 
@@ -413,12 +392,12 @@
 		 * Buffer needs to be set to the length of the sting + one for the
 		 * terminating null
 		 */
-		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address16.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (
+				 linked_list->data.address16.resource_source.string_ptr) + 1);
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	actual_bytes = ACPI_PTR_DIFF (buffer, *output_buffer);
 	*bytes_consumed = actual_bytes;
 
@@ -475,9 +454,8 @@
 	buffer = byte_stream_buffer;
 	struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address32);
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -490,9 +468,8 @@
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_ADDRESS32;
 
-	/*
-	 * Get the Resource Type (Byte3)
-	 */
+	/* Get the Resource Type (Byte3) */
+
 	buffer += 2;
 	temp8 = *buffer;
 
@@ -504,35 +481,29 @@
 
 	output_struct->data.address32.resource_type = temp8;
 
-	/*
-	 * Get the General Flags (Byte4)
-	 */
+	/* Get the General Flags (Byte4) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
-	/*
-	 * Producer / Consumer
-	 */
+	/* Producer / Consumer */
+
 	output_struct->data.address32.producer_consumer = temp8 & 0x01;
 
-	/*
-	 * Decode
-	 */
+	/* Decode */
+
 	output_struct->data.address32.decode = (temp8 >> 1) & 0x01;
 
-	/*
-	 * Min Address Fixed
-	 */
+	/* Min Address Fixed */
+
 	output_struct->data.address32.min_address_fixed = (temp8 >> 2) & 0x01;
 
-	/*
-	 * Max Address Fixed
-	 */
+	/* Max Address Fixed */
+
 	output_struct->data.address32.max_address_fixed = (temp8 >> 3) & 0x01;
 
-	/*
-	 * Get the Type Specific Flags (Byte5)
-	 */
+	/* Get the Type Specific Flags (Byte5) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -556,39 +527,34 @@
 		}
 	}
 
-	/*
-	 * Get Granularity (Bytes 6-9)
-	 */
+	/* Get Granularity (Bytes 6-9) */
+
 	buffer += 1;
 	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.granularity, buffer);
 
-	/*
-	 * Get min_address_range (Bytes 10-13)
-	 */
+	/* Get min_address_range (Bytes 10-13) */
+
 	buffer += 4;
 	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.min_address_range, buffer);
 
-	/*
-	 * Get max_address_range (Bytes 14-17)
-	 */
+	/* Get max_address_range (Bytes 14-17) */
+
 	buffer += 4;
 	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.max_address_range, buffer);
 
-	/*
-	 * Get address_translation_offset (Bytes 18-21)
-	 */
+	/* Get address_translation_offset (Bytes 18-21) */
+
 	buffer += 4;
-	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.address_translation_offset, buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.address_translation_offset,
+		buffer);
+
+	/* Get address_length (Bytes 22-25) */
 
-	/*
-	 * Get address_length (Bytes 22-25)
-	 */
 	buffer += 4;
 	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.address_length, buffer);
 
-	/*
-	 * Resource Source Index (if present)
-	 */
+	/* Resource Source Index (if present) */
+
 	buffer += 4;
 
 	/*
@@ -615,7 +581,8 @@
 		output_struct->data.address32.resource_source.string_ptr =
 				(char *)((u8 *)output_struct + struct_size);
 
-		temp_ptr = (u8 *) output_struct->data.address32.resource_source.string_ptr;
+		temp_ptr = (u8 *)
+			output_struct->data.address32.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -628,9 +595,8 @@
 			index += 1;
 		}
 
-		/*
-		 * Add the terminating null
-		 */
+		/* Add the terminating null */
+
 		*temp_ptr = 0x00;
 		output_struct->data.address32.resource_source.string_length = index + 1;
 
@@ -648,14 +614,12 @@
 		output_struct->data.address32.resource_source.string_ptr = NULL;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -694,29 +658,25 @@
 
 	buffer = *output_buffer;
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x87;
 	buffer += 1;
 
-	/*
-	 * Set a pointer to the Length field - to be filled in later
-	 */
+	/* Set a pointer to the Length field - to be filled in later */
+
 	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
-	/*
-	 * Set the Resource Type (Memory, Io, bus_number)
-	 */
+	/* Set the Resource Type (Memory, Io, bus_number) */
+
 	temp8 = (u8) (linked_list->data.address32.resource_type & 0x03);
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the general flags
-	 */
+	/* Set the general flags */
+
 	temp8 = (u8) (linked_list->data.address32.producer_consumer & 0x01);
 	temp8 |= (linked_list->data.address32.decode & 0x01) << 1;
 	temp8 |= (linked_list->data.address32.min_address_fixed & 0x01) << 2;
@@ -725,9 +685,8 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the type specific flags
-	 */
+	/* Set the type specific flags */
+
 	temp8 = 0;
 
 	if (ACPI_MEMORY_RANGE == linked_list->data.address32.resource_type) {
@@ -751,39 +710,34 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the address space granularity
-	 */
+	/* Set the address space granularity */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.granularity);
 	buffer += 4;
 
-	/*
-	 * Set the address range minimum
-	 */
+	/* Set the address range minimum */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.min_address_range);
 	buffer += 4;
 
-	/*
-	 * Set the address range maximum
-	 */
+	/* Set the address range maximum */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.max_address_range);
 	buffer += 4;
 
-	/*
-	 * Set the address translation offset
-	 */
-	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.address_translation_offset);
+	/* Set the address translation offset */
+
+	ACPI_MOVE_32_TO_32 (buffer,
+		&linked_list->data.address32.address_translation_offset);
 	buffer += 4;
 
-	/*
-	 * Set the address length
-	 */
+	/* Set the address length */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.address_length);
 	buffer += 4;
 
-	/*
-	 * Resource Source Index and Resource Source are optional
-	 */
+	/* Resource Source Index and Resource Source are optional */
+
 	if (0 != linked_list->data.address32.resource_source.string_length) {
 		temp8 = (u8) linked_list->data.address32.resource_source.index;
 
@@ -792,9 +746,8 @@
 
 		temp_pointer = (char *) buffer;
 
-		/*
-		 * Copy the string
-		 */
+		/* Copy the string */
+
 		ACPI_STRCPY (temp_pointer,
 			linked_list->data.address32.resource_source.string_ptr);
 
@@ -802,12 +755,12 @@
 		 * Buffer needs to be set to the length of the sting + one for the
 		 *  terminating null
 		 */
-		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address32.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (
+				 linked_list->data.address32.resource_source.string_ptr) + 1);
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
@@ -864,9 +817,8 @@
 	struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address64);
 	resource_type = *buffer;
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -879,9 +831,8 @@
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_ADDRESS64;
 
-	/*
-	 * Get the Resource Type (Byte3)
-	 */
+	/* Get the Resource Type (Byte3) */
+
 	buffer += 2;
 	temp8 = *buffer;
 
@@ -893,35 +844,29 @@
 
 	output_struct->data.address64.resource_type = temp8;
 
-	/*
-	 * Get the General Flags (Byte4)
-	 */
+	/* Get the General Flags (Byte4) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
-	/*
-	 * Producer / Consumer
-	 */
+	/* Producer / Consumer */
+
 	output_struct->data.address64.producer_consumer = temp8 & 0x01;
 
-	/*
-	 * Decode
-	 */
+	/* Decode */
+
 	output_struct->data.address64.decode = (temp8 >> 1) & 0x01;
 
-	/*
-	 * Min Address Fixed
-	 */
+	/* Min Address Fixed */
+
 	output_struct->data.address64.min_address_fixed = (temp8 >> 2) & 0x01;
 
-	/*
-	 * Max Address Fixed
-	 */
+	/* Max Address Fixed */
+
 	output_struct->data.address64.max_address_fixed = (temp8 >> 3) & 0x01;
 
-	/*
-	 * Get the Type Specific Flags (Byte5)
-	 */
+	/* Get the Type Specific Flags (Byte5) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -951,33 +896,29 @@
 		buffer += 2;
 	}
 
-	/*
-	 * Get Granularity (Bytes 6-13) or (Bytes 8-15)
-	 */
+	/* Get Granularity (Bytes 6-13) or (Bytes 8-15) */
+
 	buffer += 1;
 	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.granularity, buffer);
 
-	/*
-	 * Get min_address_range (Bytes 14-21) or (Bytes 16-23)
-	 */
+	/* Get min_address_range (Bytes 14-21) or (Bytes 16-23) */
+
 	buffer += 8;
 	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.min_address_range, buffer);
 
-	/*
-	 * Get max_address_range (Bytes 22-29) or (Bytes 24-31)
-	 */
+	/* Get max_address_range (Bytes 22-29) or (Bytes 24-31) */
+
 	buffer += 8;
 	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.max_address_range, buffer);
 
-	/*
-	 * Get address_translation_offset (Bytes 30-37) or (Bytes 32-39)
-	 */
+	/* Get address_translation_offset (Bytes 30-37) or (Bytes 32-39) */
+
 	buffer += 8;
-	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.address_translation_offset, buffer);
+	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.address_translation_offset,
+		buffer);
+
+	/* Get address_length (Bytes 38-45) or (Bytes 40-47) */
 
-	/*
-	 * Get address_length (Bytes 38-45) or (Bytes 40-47)
-	 */
 	buffer += 8;
 	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.address_length, buffer);
 
@@ -989,14 +930,15 @@
 		/* Get type_specific_attribute (Bytes 48-55) */
 
 		buffer += 8;
-		ACPI_MOVE_64_TO_64 (&output_struct->data.address64.type_specific_attributes, buffer);
+		ACPI_MOVE_64_TO_64 (
+			&output_struct->data.address64.type_specific_attributes,
+			buffer);
 	}
 	else {
 		output_struct->data.address64.type_specific_attributes = 0;
 
-		/*
-		 * Resource Source Index (if present)
-		 */
+		/* Resource Source Index (if present) */
+
 		buffer += 8;
 
 		/*
@@ -1025,7 +967,8 @@
 			output_struct->data.address64.resource_source.string_ptr =
 					(char *)((u8 *)output_struct + struct_size);
 
-			temp_ptr = (u8 *) output_struct->data.address64.resource_source.string_ptr;
+			temp_ptr = (u8 *)
+				output_struct->data.address64.resource_source.string_ptr;
 
 			/* Copy the string into the buffer */
 
@@ -1042,7 +985,8 @@
 			 * Add the terminating null
 			 */
 			*temp_ptr = 0x00;
-			output_struct->data.address64.resource_source.string_length = index + 1;
+			output_struct->data.address64.resource_source.string_length =
+				index + 1;
 
 			/*
 			 * In order for the struct_size to fall on a 32-bit boundary,
@@ -1054,14 +998,12 @@
 		}
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -1100,29 +1042,25 @@
 
 	buffer = *output_buffer;
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x8A;
 	buffer += 1;
 
-	/*
-	 * Set a pointer to the Length field - to be filled in later
-	 */
+	/* Set a pointer to the Length field - to be filled in later */
+
 	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
-	/*
-	 * Set the Resource Type (Memory, Io, bus_number)
-	 */
+	/* Set the Resource Type (Memory, Io, bus_number) */
+
 	temp8 = (u8) (linked_list->data.address64.resource_type & 0x03);
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the general flags
-	 */
+	/* Set the general flags */
+
 	temp8 = (u8) (linked_list->data.address64.producer_consumer & 0x01);
 	temp8 |= (linked_list->data.address64.decode & 0x01) << 1;
 	temp8 |= (linked_list->data.address64.min_address_fixed & 0x01) << 2;
@@ -1131,9 +1069,8 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the type specific flags
-	 */
+	/* Set the type specific flags */
+
 	temp8 = 0;
 
 	if (ACPI_MEMORY_RANGE == linked_list->data.address64.resource_type) {
@@ -1157,39 +1094,34 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the address space granularity
-	 */
+	/* Set the address space granularity */
+
 	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.granularity);
 	buffer += 8;
 
-	/*
-	 * Set the address range minimum
-	 */
+	/* Set the address range minimum */
+
 	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.min_address_range);
 	buffer += 8;
 
-	/*
-	 * Set the address range maximum
-	 */
+	/* Set the address range maximum */
+
 	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.max_address_range);
 	buffer += 8;
 
-	/*
-	 * Set the address translation offset
-	 */
-	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.address_translation_offset);
+	/* Set the address translation offset */
+
+	ACPI_MOVE_64_TO_64 (buffer,
+		&linked_list->data.address64.address_translation_offset);
 	buffer += 8;
 
-	/*
-	 * Set the address length
-	 */
+	/* Set the address length */
+
 	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.address_length);
 	buffer += 8;
 
-	/*
-	 * Resource Source Index and Resource Source are optional
-	 */
+	/* Resource Source Index and Resource Source are optional */
+
 	if (0 != linked_list->data.address64.resource_source.string_length) {
 		temp8 = (u8) linked_list->data.address64.resource_source.index;
 
@@ -1198,21 +1130,21 @@
 
 		temp_pointer = (char *) buffer;
 
-		/*
-		 * Copy the string
-		 */
-		ACPI_STRCPY (temp_pointer, linked_list->data.address64.resource_source.string_ptr);
+		/* Copy the string */
+
+		ACPI_STRCPY (temp_pointer,
+			linked_list->data.address64.resource_source.string_ptr);
 
 		/*
 		 * Buffer needs to be set to the length of the sting + one for the
 		 * terminating null
 		 */
-		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address64.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (
+				 linked_list->data.address64.resource_source.string_ptr) + 1);
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
diff -Nru a/drivers/acpi/resources/rscalc.c b/drivers/acpi/resources/rscalc.c
--- a/drivers/acpi/resources/rscalc.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rscalc.c	2005-04-19 01:34:14 -04:00
@@ -81,9 +81,8 @@
 
 
 	while (!done) {
-		/*
-		 * Init the variable that will hold the size to add to the total.
-		 */
+		/* Init the variable that will hold the size to add to the total. */
+
 		segment_size = 0;
 
 		switch (linked_list->id) {
@@ -196,7 +195,8 @@
 			segment_size = 16;
 
 			if (linked_list->data.address16.resource_source.string_ptr) {
-				segment_size += linked_list->data.address16.resource_source.string_length;
+				segment_size +=
+					linked_list->data.address16.resource_source.string_length;
 				segment_size++;
 			}
 			break;
@@ -212,7 +212,8 @@
 			segment_size = 26;
 
 			if (linked_list->data.address32.resource_source.string_ptr) {
-				segment_size += linked_list->data.address32.resource_source.string_length;
+				segment_size +=
+					linked_list->data.address32.resource_source.string_length;
 				segment_size++;
 			}
 			break;
@@ -227,7 +228,8 @@
 			segment_size = 46;
 
 			if (linked_list->data.address64.resource_source.string_ptr) {
-				segment_size += linked_list->data.address64.resource_source.string_length;
+				segment_size +=
+					linked_list->data.address64.resource_source.string_length;
 				segment_size++;
 			}
 			break;
@@ -241,38 +243,36 @@
 			 * Index + the length of the null terminated string
 			 * Resource Source + 1 for the null.
 			 */
-			segment_size = 9 +
-				(((acpi_size) linked_list->data.extended_irq.number_of_interrupts - 1) * 4);
+			segment_size = 9 + (((acpi_size)
+				linked_list->data.extended_irq.number_of_interrupts - 1) * 4);
 
 			if (linked_list->data.extended_irq.resource_source.string_ptr) {
-				segment_size += linked_list->data.extended_irq.resource_source.string_length;
+				segment_size +=
+					linked_list->data.extended_irq.resource_source.string_length;
 				segment_size++;
 			}
 			break;
 
 		default:
-			/*
-			 * If we get here, everything is out of sync, exit with error
-			 */
+
+			/* If we get here, everything is out of sync, exit with error */
+
 			return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
 
 		} /* switch (linked_list->Id) */
 
-		/*
-		 * Update the total
-		 */
+		/* Update the total */
+
 		byte_stream_size_needed += segment_size;
 
-		/*
-		 * Point to the next object
-		 */
+		/* Point to the next object */
+
 		linked_list = ACPI_PTR_ADD (struct acpi_resource,
 				  linked_list, linked_list->length);
 	}
 
-	/*
-	 * This is the data the caller needs
-	 */
+	/* This is the data the caller needs */
+
 	*size_needed = byte_stream_size_needed;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -320,9 +320,8 @@
 
 
 	while (bytes_parsed < byte_stream_buffer_length) {
-		/*
-		 * The next byte in the stream is the resource type
-		 */
+		/* The next byte in the stream is the resource type */
+
 		resource_type = acpi_rs_get_resource_type (*byte_stream_buffer);
 
 		switch (resource_type) {
@@ -346,9 +345,8 @@
 			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 			bytes_consumed = temp16 + 3;
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp16 = (u16) ACPI_ROUND_UP_to_32_bITS (temp16);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor) +
@@ -416,9 +414,8 @@
 				temp8 = 0;
 			}
 
-			/*
-			 * Ensure a 64-bit boundary for the structure
-			 */
+			/* Ensure a 64-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_64_bITS (temp8);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address64) +
@@ -452,9 +449,8 @@
 				temp8 = 0;
 			}
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address32) +
@@ -488,9 +484,8 @@
 				temp8 = 0;
 			}
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address16) +
@@ -537,9 +532,8 @@
 				temp8 = 0;
 			}
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_ext_irq) +
@@ -567,9 +561,8 @@
 
 			++buffer;
 
-			/*
-			 * Look at the number of bits set
-			 */
+			/* Look at the number of bits set */
+
 			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 			for (index = 0; index < 16; index++) {
@@ -596,9 +589,8 @@
 
 			++buffer;
 
-			/*
-			 * Look at the number of bits set
-			 */
+			/* Look at the number of bits set */
+
 			temp8 = *buffer;
 
 			for(index = 0; index < 8; index++) {
@@ -670,9 +662,8 @@
 			temp8 = (u8) (temp8 & 0x7);
 			bytes_consumed = temp8 + 1;
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor) +
 					   (temp8 * sizeof (u8));
@@ -697,21 +688,18 @@
 			return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
 		}
 
-		/*
-		 * Update the return value and counter
-		 */
+		/* Update the return value and counter */
+
 		buffer_size += (u32) ACPI_ALIGN_RESOURCE_SIZE (structure_size);
 		bytes_parsed += bytes_consumed;
 
-		/*
-		 * Set the byte stream to point to the next resource
-		 */
+		/* Set the byte stream to point to the next resource */
+
 		byte_stream_buffer += bytes_consumed;
 	}
 
-	/*
-	 * This is the data the caller needs
-	 */
+	/* This is the data the caller needs */
+
 	*size_needed = buffer_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -767,9 +755,8 @@
 	top_object_list = package_object->package.elements;
 
 	for (index = 0; index < number_of_elements; index++) {
-		/*
-		 * Dereference the sub-package
-		 */
+		/* Dereference the sub-package */
+
 		package_element = *top_object_list;
 
 		/*
@@ -778,37 +765,40 @@
 		 */
 		sub_object_list = package_element->package.elements;
 
-		/*
-		 * Scan the irq_table_elements for the Source Name String
-		 */
+		/* Scan the irq_table_elements for the Source Name String */
+
 		name_found = FALSE;
 
 		for (table_index = 0; table_index < 4 && !name_found; table_index++) {
-			if ((ACPI_TYPE_STRING == ACPI_GET_OBJECT_TYPE (*sub_object_list)) ||
-				((ACPI_TYPE_LOCAL_REFERENCE == ACPI_GET_OBJECT_TYPE (*sub_object_list)) &&
-					((*sub_object_list)->reference.opcode == AML_INT_NAMEPATH_OP))) {
+			if ((ACPI_TYPE_STRING ==
+					ACPI_GET_OBJECT_TYPE (*sub_object_list)) ||
+
+				((ACPI_TYPE_LOCAL_REFERENCE ==
+					ACPI_GET_OBJECT_TYPE (*sub_object_list)) &&
+
+					((*sub_object_list)->reference.opcode ==
+						AML_INT_NAMEPATH_OP))) {
 				name_found = TRUE;
 			}
 			else {
-				/*
-				 * Look at the next element
-				 */
+				/* Look at the next element */
+
 				sub_object_list++;
 			}
 		}
 
 		temp_size_needed += (sizeof (struct acpi_pci_routing_table) - 4);
 
-		/*
-		 * Was a String type found?
-		 */
+		/* Was a String type found? */
+
 		if (name_found) {
 			if (ACPI_GET_OBJECT_TYPE (*sub_object_list) == ACPI_TYPE_STRING) {
 				/*
 				 * The length String.Length field does not include the
 				 * terminating NULL, add 1
 				 */
-				temp_size_needed += ((acpi_size) (*sub_object_list)->string.length + 1);
+				temp_size_needed += ((acpi_size)
+					(*sub_object_list)->string.length + 1);
 			}
 			else {
 				temp_size_needed += acpi_ns_get_pathname_length (
@@ -827,14 +817,14 @@
 
 		temp_size_needed = ACPI_ROUND_UP_to_64_bITS (temp_size_needed);
 
-		/*
-		 * Point to the next union acpi_operand_object
-		 */
+		/* Point to the next union acpi_operand_object */
+
 		top_object_list++;
 	}
 
 	/*
-	 * Adding an extra element to the end of the list, essentially a NULL terminator
+	 * Adding an extra element to the end of the list, essentially a
+	 * NULL terminator
 	 */
 	*buffer_size_needed = temp_size_needed + sizeof (struct acpi_pci_routing_table);
 	return_ACPI_STATUS (AE_OK);
diff -Nru a/drivers/acpi/resources/rscreate.c b/drivers/acpi/resources/rscreate.c
--- a/drivers/acpi/resources/rscreate.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rscreate.c	2005-04-19 01:34:14 -04:00
@@ -87,9 +87,8 @@
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "byte_stream_buffer = %p\n",
 		byte_stream_buffer));
 
-	/*
-	 * Params already validated, so we don't re-validate here
-	 */
+	/* Params already validated, so we don't re-validate here */
+
 	byte_stream_buffer_length = byte_stream_buffer->buffer.length;
 	byte_stream_start = byte_stream_buffer->buffer.pointer;
 
@@ -171,9 +170,8 @@
 
 	/* Params already validated, so we don't re-validate here */
 
-	/*
-	 * Get the required buffer length
-	 */
+	/* Get the required buffer length */
+
 	status = acpi_rs_get_pci_routing_table_length (package_object,
 			 &buffer_size_needed);
 	if (ACPI_FAILURE (status)) {
@@ -217,9 +215,8 @@
 		 */
 		user_prt->length = (sizeof (struct acpi_pci_routing_table) - 4);
 
-		/*
-		 * Each element of the top-level package must also be a package
-		 */
+		/* Each element of the top-level package must also be a package */
+
 		if (ACPI_GET_OBJECT_TYPE (*top_object_list) != ACPI_TYPE_PACKAGE) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"(PRT[%X]) Need sub-package, found %s\n",
@@ -243,9 +240,8 @@
 		 */
 		sub_object_list = (*top_object_list)->package.elements;
 
-		/*
-		 * 1) First subobject: Dereference the PRT.Address
-		 */
+		/* 1) First subobject: Dereference the PRT.Address */
+
 		obj_desc = sub_object_list[0];
 		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
 			user_prt->address = obj_desc->integer.value;
@@ -257,9 +253,8 @@
 			return_ACPI_STATUS (AE_BAD_DATA);
 		}
 
-		/*
-		 * 2) Second subobject: Dereference the PRT.Pin
-		 */
+		/* 2) Second subobject: Dereference the PRT.Pin */
+
 		obj_desc = sub_object_list[1];
 		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
 			user_prt->pin = (u32) obj_desc->integer.value;
@@ -271,9 +266,8 @@
 			return_ACPI_STATUS (AE_BAD_DATA);
 		}
 
-		/*
-		 * 3) Third subobject: Dereference the PRT.source_name
-		 */
+		/* 3) Third subobject: Dereference the PRT.source_name */
+
 		obj_desc = sub_object_list[2];
 		switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 		case ACPI_TYPE_LOCAL_REFERENCE:
@@ -296,7 +290,9 @@
 
 			status = acpi_ns_handle_to_pathname ((acpi_handle) node, &path_buffer);
 
-			user_prt->length += (u32) ACPI_STRLEN (user_prt->source) + 1; /* include null terminator */
+			/* +1 to include null terminator */
+
+			user_prt->length += (u32) ACPI_STRLEN (user_prt->source) + 1;
 			break;
 
 
@@ -304,8 +300,10 @@
 
 			ACPI_STRCPY (user_prt->source, obj_desc->string.pointer);
 
-			/* Add to the Length field the length of the string (add 1 for terminator) */
-
+			/*
+			 * Add to the Length field the length of the string
+			 * (add 1 for terminator)
+			 */
 			user_prt->length += obj_desc->string.length + 1;
 			break;
 
@@ -333,9 +331,8 @@
 
 		user_prt->length = (u32) ACPI_ROUND_UP_to_64_bITS (user_prt->length);
 
-		/*
-		 * 4) Fourth subobject: Dereference the PRT.source_index
-		 */
+		/* 4) Fourth subobject: Dereference the PRT.source_index */
+
 		obj_desc = sub_object_list[3];
 		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
 			user_prt->source_index = (u32) obj_desc->integer.value;
diff -Nru a/drivers/acpi/resources/rsdump.c b/drivers/acpi/resources/rsdump.c
--- a/drivers/acpi/resources/rsdump.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rsdump.c	2005-04-19 01:34:14 -04:00
@@ -48,9 +48,62 @@
 #define _COMPONENT          ACPI_RESOURCES
 	 ACPI_MODULE_NAME    ("rsdump")
 
+/* Local prototypes */
 
-#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+static void
+acpi_rs_dump_irq (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_address16 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_address32 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_address64 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_dma (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_io (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_extended_irq (
+	union acpi_resource_data        *data);
 
+static void
+acpi_rs_dump_fixed_io (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_fixed_memory32 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_memory24 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_memory32 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_start_depend_fns (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_vendor_specific (
+	union acpi_resource_data        *data);
+
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 /*******************************************************************************
  *
  * FUNCTION:    acpi_rs_dump_irq
@@ -63,7 +116,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_irq (
 	union acpi_resource_data        *data)
 {
@@ -77,13 +130,13 @@
 	acpi_os_printf ("IRQ Resource\n");
 
 	acpi_os_printf ("  %s Triggered\n",
-			 ACPI_LEVEL_SENSITIVE == irq_data->edge_level ? "Level" : "Edge");
+		ACPI_LEVEL_SENSITIVE == irq_data->edge_level ? "Level" : "Edge");
 
 	acpi_os_printf ("  Active %s\n",
-			 ACPI_ACTIVE_LOW == irq_data->active_high_low ? "Low" : "High");
+		ACPI_ACTIVE_LOW == irq_data->active_high_low ? "Low" : "High");
 
 	acpi_os_printf ("  %s\n",
-			 ACPI_SHARED == irq_data->shared_exclusive ? "Shared" : "Exclusive");
+		ACPI_SHARED == irq_data->shared_exclusive ? "Shared" : "Exclusive");
 
 	acpi_os_printf ("  %X Interrupts ( ", irq_data->number_of_interrupts);
 
@@ -108,7 +161,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_dma (
 	union acpi_resource_data        *data)
 {
@@ -144,7 +197,7 @@
 	}
 
 	acpi_os_printf ("  %sBus Master\n",
-			 ACPI_BUS_MASTER == dma_data->bus_master ? "" : "Not a ");
+		ACPI_BUS_MASTER == dma_data->bus_master ? "" : "Not a ");
 
 
 	switch (dma_data->transfer) {
@@ -165,7 +218,8 @@
 		break;
 	}
 
-	acpi_os_printf ("  Number of Channels: %X ( ", dma_data->number_of_channels);
+	acpi_os_printf ("  Number of Channels: %X ( ",
+		dma_data->number_of_channels);
 
 	for (index = 0; index < dma_data->number_of_channels; index++) {
 		acpi_os_printf ("%X ", dma_data->channels[index]);
@@ -188,7 +242,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_start_depend_fns (
 	union acpi_resource_data        *data)
 {
@@ -232,8 +286,7 @@
 		break;
 
 	default:
-		acpi_os_printf ("  Invalid performance "
-				  "robustness preference\n");
+		acpi_os_printf ("  Invalid performance robustness preference\n");
 		break;
 	}
 
@@ -253,7 +306,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_io (
 	union acpi_resource_data        *data)
 {
@@ -266,19 +319,15 @@
 	acpi_os_printf ("Io Resource\n");
 
 	acpi_os_printf ("  %d bit decode\n",
-			 ACPI_DECODE_16 == io_data->io_decode ? 16 : 10);
+		ACPI_DECODE_16 == io_data->io_decode ? 16 : 10);
 
-	acpi_os_printf ("  Range minimum base: %08X\n",
-			 io_data->min_base_address);
+	acpi_os_printf ("  Range minimum base: %08X\n", io_data->min_base_address);
 
-	acpi_os_printf ("  Range maximum base: %08X\n",
-			 io_data->max_base_address);
+	acpi_os_printf ("  Range maximum base: %08X\n", io_data->max_base_address);
 
-	acpi_os_printf ("  Alignment: %08X\n",
-			 io_data->alignment);
+	acpi_os_printf ("  Alignment: %08X\n", io_data->alignment);
 
-	acpi_os_printf ("  Range Length: %08X\n",
-			 io_data->range_length);
+	acpi_os_printf ("  Range Length: %08X\n", io_data->range_length);
 
 	return;
 }
@@ -296,7 +345,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_fixed_io (
 	union acpi_resource_data        *data)
 {
@@ -307,11 +356,9 @@
 
 
 	acpi_os_printf ("Fixed Io Resource\n");
-	acpi_os_printf ("  Range base address: %08X",
-			 fixed_io_data->base_address);
+	acpi_os_printf ("  Range base address: %08X", fixed_io_data->base_address);
 
-	acpi_os_printf ("  Range length: %08X",
-			 fixed_io_data->range_length);
+	acpi_os_printf ("  Range length: %08X", fixed_io_data->range_length);
 
 	return;
 }
@@ -329,7 +376,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_vendor_specific (
 	union acpi_resource_data        *data)
 {
@@ -346,7 +393,7 @@
 
 	for (index = 0; index < vendor_data->length; index++) {
 		acpi_os_printf ("  Byte %X: %08X\n",
-				 index, vendor_data->reserved[index]);
+			index, vendor_data->reserved[index]);
 	}
 
 	return;
@@ -365,7 +412,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_memory24 (
 	union acpi_resource_data        *data)
 {
@@ -378,21 +425,19 @@
 	acpi_os_printf ("24-Bit Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 ACPI_READ_WRITE_MEMORY ==
-			 memory24_data->read_write_attribute ?
-			 "/Write" : " only");
+		ACPI_READ_WRITE_MEMORY ==
+			memory24_data->read_write_attribute ?
+			"/Write" : " only");
 
 	acpi_os_printf ("  Range minimum base: %08X\n",
-			 memory24_data->min_base_address);
+		memory24_data->min_base_address);
 
 	acpi_os_printf ("  Range maximum base: %08X\n",
-			 memory24_data->max_base_address);
+		memory24_data->max_base_address);
 
-	acpi_os_printf ("  Alignment: %08X\n",
-			 memory24_data->alignment);
+	acpi_os_printf ("  Alignment: %08X\n", memory24_data->alignment);
 
-	acpi_os_printf ("  Range length: %08X\n",
-			 memory24_data->range_length);
+	acpi_os_printf ("  Range length: %08X\n", memory24_data->range_length);
 
 	return;
 }
@@ -410,7 +455,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_memory32 (
 	union acpi_resource_data        *data)
 {
@@ -423,21 +468,19 @@
 	acpi_os_printf ("32-Bit Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 ACPI_READ_WRITE_MEMORY ==
-			 memory32_data->read_write_attribute ?
-			 "/Write" : " only");
+		ACPI_READ_WRITE_MEMORY ==
+			memory32_data->read_write_attribute ?
+			"/Write" : " only");
 
 	acpi_os_printf ("  Range minimum base: %08X\n",
-			 memory32_data->min_base_address);
+		memory32_data->min_base_address);
 
 	acpi_os_printf ("  Range maximum base: %08X\n",
-			 memory32_data->max_base_address);
+		memory32_data->max_base_address);
 
-	acpi_os_printf ("  Alignment: %08X\n",
-			 memory32_data->alignment);
+	acpi_os_printf ("  Alignment: %08X\n", memory32_data->alignment);
 
-	acpi_os_printf ("  Range length: %08X\n",
-			 memory32_data->range_length);
+	acpi_os_printf ("  Range length: %08X\n", memory32_data->range_length);
 
 	return;
 }
@@ -455,11 +498,12 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_fixed_memory32 (
 	union acpi_resource_data            *data)
 {
-	struct acpi_resource_fixed_mem32    *fixed_memory32_data = (struct acpi_resource_fixed_mem32 *) data;
+	struct acpi_resource_fixed_mem32    *fixed_memory32_data =
+			   (struct acpi_resource_fixed_mem32 *) data;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -468,15 +512,14 @@
 	acpi_os_printf ("32-Bit Fixed Location Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 ACPI_READ_WRITE_MEMORY ==
-			 fixed_memory32_data->read_write_attribute ?
-			 "/Write" : " Only");
+		ACPI_READ_WRITE_MEMORY ==
+			fixed_memory32_data->read_write_attribute ? "/Write" : " Only");
 
 	acpi_os_printf ("  Range base address: %08X\n",
-			 fixed_memory32_data->range_base_address);
+		fixed_memory32_data->range_base_address);
 
 	acpi_os_printf ("  Range length: %08X\n",
-			 fixed_memory32_data->range_length);
+		fixed_memory32_data->range_length);
 
 	return;
 }
@@ -494,7 +537,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_address16 (
 	union acpi_resource_data        *data)
 {
@@ -514,35 +557,30 @@
 
 		switch (address16_data->attribute.memory.cache_attribute) {
 		case ACPI_NON_CACHEABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Noncacheable memory\n");
+			acpi_os_printf ("  Type Specific: Noncacheable memory\n");
 			break;
 
 		case ACPI_CACHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Cacheable memory\n");
+			acpi_os_printf ("  Type Specific: Cacheable memory\n");
 			break;
 
 		case ACPI_WRITE_COMBINING_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Write-combining memory\n");
+			acpi_os_printf ("  Type Specific: Write-combining memory\n");
 			break;
 
 		case ACPI_PREFETCHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Prefetchable memory\n");
+			acpi_os_printf ("  Type Specific: Prefetchable memory\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid cache attribute\n");
+			acpi_os_printf ("  Type Specific: Invalid cache attribute\n");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
 			ACPI_READ_WRITE_MEMORY ==
-			address16_data->attribute.memory.read_write_attribute ?
-			"/Write" : " Only");
+				address16_data->attribute.memory.read_write_attribute ?
+				"/Write" : " Only");
 		break;
 
 	case ACPI_IO_RANGE:
@@ -551,30 +589,26 @@
 
 		switch (address16_data->attribute.io.range_attribute) {
 		case ACPI_NON_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "Non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: Non-ISA Io Addresses\n");
 			break;
 
 		case ACPI_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA Io Addresses\n");
 			break;
 
 		case ACPI_ENTIRE_RANGE:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA and non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA and non-ISA Io Addresses\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid range attribute\n");
+			acpi_os_printf ("  Type Specific: Invalid range attribute\n");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: %s Translation\n",
 			ACPI_SPARSE_TRANSLATION ==
-			address16_data->attribute.io.translation_attribute ?
-			"Sparse" : "Dense");
+				address16_data->attribute.io.translation_attribute ?
+				"Sparse" : "Dense");
 		break;
 
 	case ACPI_BUS_NUMBER_RANGE:
@@ -589,41 +623,42 @@
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			ACPI_CONSUMER == address16_data->producer_consumer ?
+		ACPI_CONSUMER == address16_data->producer_consumer ?
 			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 ACPI_SUB_DECODE == address16_data->decode ?
-			 "Subtractive" : "Positive");
+		ACPI_SUB_DECODE == address16_data->decode ?
+			"Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address16_data->min_address_fixed ?
-			 "" : "not");
+		ACPI_ADDRESS_FIXED == address16_data->min_address_fixed ?
+			"" : "not");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address16_data->max_address_fixed ?
-			 "" : "not");
+		ACPI_ADDRESS_FIXED == address16_data->max_address_fixed ?
+			"" : "not");
 
 	acpi_os_printf ("  Granularity: %08X\n",
-			 address16_data->granularity);
+		address16_data->granularity);
 
 	acpi_os_printf ("  Address range min: %08X\n",
-			 address16_data->min_address_range);
+		address16_data->min_address_range);
 
 	acpi_os_printf ("  Address range max: %08X\n",
-			 address16_data->max_address_range);
+		address16_data->max_address_range);
 
 	acpi_os_printf ("  Address translation offset: %08X\n",
-			 address16_data->address_translation_offset);
+		address16_data->address_translation_offset);
 
 	acpi_os_printf ("  Address Length: %08X\n",
-			 address16_data->address_length);
+		address16_data->address_length);
 
 	if (0xFF != address16_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X\n",
-				 address16_data->resource_source.index);
+			address16_data->resource_source.index);
+
 		acpi_os_printf ("  Resource Source: %s\n",
-				 address16_data->resource_source.string_ptr);
+			address16_data->resource_source.string_ptr);
 	}
 
 	return;
@@ -642,7 +677,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_address32 (
 	union acpi_resource_data        *data)
 {
@@ -661,35 +696,30 @@
 
 		switch (address32_data->attribute.memory.cache_attribute) {
 		case ACPI_NON_CACHEABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Noncacheable memory\n");
+			acpi_os_printf ("  Type Specific: Noncacheable memory\n");
 			break;
 
 		case ACPI_CACHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Cacheable memory\n");
+			acpi_os_printf ("  Type Specific: Cacheable memory\n");
 			break;
 
 		case ACPI_WRITE_COMBINING_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Write-combining memory\n");
+			acpi_os_printf ("  Type Specific: Write-combining memory\n");
 			break;
 
 		case ACPI_PREFETCHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Prefetchable memory\n");
+			acpi_os_printf ("  Type Specific: Prefetchable memory\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid cache attribute\n");
+			acpi_os_printf ("  Type Specific: Invalid cache attribute\n");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
 			ACPI_READ_WRITE_MEMORY ==
-			address32_data->attribute.memory.read_write_attribute ?
-			"/Write" : " Only");
+				address32_data->attribute.memory.read_write_attribute ?
+				"/Write" : " Only");
 		break;
 
 	case ACPI_IO_RANGE:
@@ -698,30 +728,26 @@
 
 		switch (address32_data->attribute.io.range_attribute) {
 		case ACPI_NON_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "Non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: Non-ISA Io Addresses\n");
 			break;
 
 		case ACPI_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA Io Addresses\n");
 			break;
 
 		case ACPI_ENTIRE_RANGE:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA and non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA and non-ISA Io Addresses\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid Range attribute");
+			acpi_os_printf ("  Type Specific: Invalid Range attribute");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: %s Translation\n",
 			ACPI_SPARSE_TRANSLATION ==
-			address32_data->attribute.io.translation_attribute ?
-			"Sparse" : "Dense");
+				address32_data->attribute.io.translation_attribute ?
+				"Sparse" : "Dense");
 		break;
 
 	case ACPI_BUS_NUMBER_RANGE:
@@ -731,46 +757,48 @@
 
 	default:
 
-		acpi_os_printf ("  Resource Type: 0x%2.2X\n", address32_data->resource_type);
+		acpi_os_printf ("  Resource Type: 0x%2.2X\n",
+			address32_data->resource_type);
 		break;
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			 ACPI_CONSUMER == address32_data->producer_consumer ?
-			 "Consumer" : "Producer");
+		ACPI_CONSUMER == address32_data->producer_consumer ?
+			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 ACPI_SUB_DECODE == address32_data->decode ?
-			 "Subtractive" : "Positive");
+		ACPI_SUB_DECODE == address32_data->decode ?
+			"Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address32_data->min_address_fixed ?
-			 "" : "not ");
+		ACPI_ADDRESS_FIXED == address32_data->min_address_fixed ?
+			"" : "not ");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address32_data->max_address_fixed ?
-			 "" : "not ");
+		ACPI_ADDRESS_FIXED == address32_data->max_address_fixed ?
+			"" : "not ");
 
 	acpi_os_printf ("  Granularity: %08X\n",
-			 address32_data->granularity);
+		address32_data->granularity);
 
 	acpi_os_printf ("  Address range min: %08X\n",
-			 address32_data->min_address_range);
+		address32_data->min_address_range);
 
 	acpi_os_printf ("  Address range max: %08X\n",
-			 address32_data->max_address_range);
+		address32_data->max_address_range);
 
 	acpi_os_printf ("  Address translation offset: %08X\n",
-			 address32_data->address_translation_offset);
+		address32_data->address_translation_offset);
 
 	acpi_os_printf ("  Address Length: %08X\n",
-			 address32_data->address_length);
+		address32_data->address_length);
 
 	if(0xFF != address32_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X\n",
-				 address32_data->resource_source.index);
+			address32_data->resource_source.index);
+
 		acpi_os_printf ("  Resource Source: %s\n",
-				 address32_data->resource_source.string_ptr);
+			address32_data->resource_source.string_ptr);
 	}
 
 	return;
@@ -789,7 +817,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_address64 (
 	union acpi_resource_data        *data)
 {
@@ -808,35 +836,30 @@
 
 		switch (address64_data->attribute.memory.cache_attribute) {
 		case ACPI_NON_CACHEABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Noncacheable memory\n");
+			acpi_os_printf ("  Type Specific: Noncacheable memory\n");
 			break;
 
 		case ACPI_CACHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Cacheable memory\n");
+			acpi_os_printf ("  Type Specific: Cacheable memory\n");
 			break;
 
 		case ACPI_WRITE_COMBINING_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Write-combining memory\n");
+			acpi_os_printf ("  Type Specific: Write-combining memory\n");
 			break;
 
 		case ACPI_PREFETCHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Prefetchable memory\n");
+			acpi_os_printf ("  Type Specific: Prefetchable memory\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid cache attribute\n");
+			acpi_os_printf ("  Type Specific: Invalid cache attribute\n");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
 			ACPI_READ_WRITE_MEMORY ==
-			address64_data->attribute.memory.read_write_attribute ?
-			"/Write" : " Only");
+				address64_data->attribute.memory.read_write_attribute ?
+				"/Write" : " Only");
 		break;
 
 	case ACPI_IO_RANGE:
@@ -845,30 +868,26 @@
 
 		switch (address64_data->attribute.io.range_attribute) {
 		case ACPI_NON_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "Non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: Non-ISA Io Addresses\n");
 			break;
 
 		case ACPI_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA Io Addresses\n");
 			break;
 
 		case ACPI_ENTIRE_RANGE:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA and non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA and non-ISA Io Addresses\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid Range attribute");
+			acpi_os_printf ("  Type Specific: Invalid Range attribute");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: %s Translation\n",
 			ACPI_SPARSE_TRANSLATION ==
-			address64_data->attribute.io.translation_attribute ?
-			"Sparse" : "Dense");
+				address64_data->attribute.io.translation_attribute ?
+				"Sparse" : "Dense");
 		break;
 
 	case ACPI_BUS_NUMBER_RANGE:
@@ -878,49 +897,51 @@
 
 	default:
 
-		acpi_os_printf ("  Resource Type: 0x%2.2X\n", address64_data->resource_type);
+		acpi_os_printf ("  Resource Type: 0x%2.2X\n",
+			address64_data->resource_type);
 		break;
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			 ACPI_CONSUMER == address64_data->producer_consumer ?
-			 "Consumer" : "Producer");
+		ACPI_CONSUMER == address64_data->producer_consumer ?
+			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 ACPI_SUB_DECODE == address64_data->decode ?
-			 "Subtractive" : "Positive");
+		ACPI_SUB_DECODE == address64_data->decode ?
+			"Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address64_data->min_address_fixed ?
-			 "" : "not ");
+		ACPI_ADDRESS_FIXED == address64_data->min_address_fixed ?
+			"" : "not ");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address64_data->max_address_fixed ?
-			 "" : "not ");
+		ACPI_ADDRESS_FIXED == address64_data->max_address_fixed ?
+			"" : "not ");
 
 	acpi_os_printf ("  Granularity: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->granularity));
+		ACPI_FORMAT_UINT64 (address64_data->granularity));
 
 	acpi_os_printf ("  Address range min: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->min_address_range));
+		ACPI_FORMAT_UINT64 (address64_data->min_address_range));
 
 	acpi_os_printf ("  Address range max: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->max_address_range));
+		ACPI_FORMAT_UINT64 (address64_data->max_address_range));
 
 	acpi_os_printf ("  Address translation offset: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->address_translation_offset));
+		ACPI_FORMAT_UINT64 (address64_data->address_translation_offset));
 
 	acpi_os_printf ("  Address Length: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->address_length));
+		ACPI_FORMAT_UINT64 (address64_data->address_length));
 
 	acpi_os_printf ("  Type Specific Attributes: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->type_specific_attributes));
+		ACPI_FORMAT_UINT64 (address64_data->type_specific_attributes));
 
 	if (0xFF != address64_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X\n",
-				 address64_data->resource_source.index);
+			address64_data->resource_source.index);
+
 		acpi_os_printf ("  Resource Source: %s\n",
-				 address64_data->resource_source.string_ptr);
+			address64_data->resource_source.string_ptr);
 	}
 
 	return;
@@ -939,7 +960,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_extended_irq (
 	union acpi_resource_data        *data)
 {
@@ -953,23 +974,22 @@
 	acpi_os_printf ("Extended IRQ Resource\n");
 
 	acpi_os_printf ("  Resource %s\n",
-			 ACPI_CONSUMER == ext_irq_data->producer_consumer ?
-			 "Consumer" : "Producer");
+		ACPI_CONSUMER == ext_irq_data->producer_consumer ?
+			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s\n",
-			 ACPI_LEVEL_SENSITIVE == ext_irq_data->edge_level ?
-			 "Level" : "Edge");
+		ACPI_LEVEL_SENSITIVE == ext_irq_data->edge_level ?
+			"Level" : "Edge");
 
 	acpi_os_printf ("  Active %s\n",
-			 ACPI_ACTIVE_LOW == ext_irq_data->active_high_low ?
-			 "low" : "high");
+		ACPI_ACTIVE_LOW == ext_irq_data->active_high_low ?
+			"low" : "high");
 
 	acpi_os_printf ("  %s\n",
-			 ACPI_SHARED == ext_irq_data->shared_exclusive ?
-			 "Shared" : "Exclusive");
+		ACPI_SHARED == ext_irq_data->shared_exclusive ?
+			"Shared" : "Exclusive");
 
-	acpi_os_printf ("  Interrupts : %X ( ",
-			 ext_irq_data->number_of_interrupts);
+	acpi_os_printf ("  Interrupts : %X ( ", ext_irq_data->number_of_interrupts);
 
 	for (index = 0; index < ext_irq_data->number_of_interrupts; index++) {
 		acpi_os_printf ("%X ", ext_irq_data->interrupts[index]);
@@ -979,9 +999,10 @@
 
 	if(0xFF != ext_irq_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X",
-				 ext_irq_data->resource_source.index);
+			ext_irq_data->resource_source.index);
+
 		acpi_os_printf ("  Resource Source: %s",
-				 ext_irq_data->resource_source.string_ptr);
+			ext_irq_data->resource_source.string_ptr);
 	}
 
 	return;
@@ -992,7 +1013,7 @@
  *
  * FUNCTION:    acpi_rs_dump_resource_list
  *
- * PARAMETERS:  Data            - pointer to the resource structure to dump.
+ * PARAMETERS:  Resource        - pointer to the resource structure to dump.
  *
  * RETURN:      None
  *
@@ -1096,7 +1117,7 @@
  *
  * FUNCTION:    acpi_rs_dump_irq_list
  *
- * PARAMETERS:  Data            - pointer to the routing table to dump.
+ * PARAMETERS:  route_table     - pointer to the routing table to dump.
  *
  * RETURN:      None
  *
@@ -1124,20 +1145,17 @@
 			acpi_os_printf ("PCI IRQ Routing Table structure %X.\n", count++);
 
 			acpi_os_printf ("  Address: %8.8X%8.8X\n",
-					 ACPI_FORMAT_UINT64 (prt_element->address));
+				ACPI_FORMAT_UINT64 (prt_element->address));
 
 			acpi_os_printf ("  Pin: %X\n", prt_element->pin);
 
 			acpi_os_printf ("  Source: %s\n", prt_element->source);
 
-			acpi_os_printf ("  source_index: %X\n",
-					 prt_element->source_index);
+			acpi_os_printf ("  source_index: %X\n", prt_element->source_index);
 
 			buffer += prt_element->length;
-
 			prt_element = ACPI_CAST_PTR (struct acpi_pci_routing_table, buffer);
-
-			if(0 == prt_element->length) {
+			if (0 == prt_element->length) {
 				done = TRUE;
 			}
 		}
diff -Nru a/drivers/acpi/resources/rsio.c b/drivers/acpi/resources/rsio.c
--- a/drivers/acpi/resources/rsio.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rsio.c	2005-04-19 01:34:14 -04:00
@@ -81,67 +81,60 @@
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_io);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_io);
 
 
 	ACPI_FUNCTION_TRACE ("rs_io_resource");
 
 
-	/*
-	 * The number of bytes consumed are Constant
-	 */
+	/* The number of bytes consumed are Constant */
+
 	*bytes_consumed = 8;
 
 	output_struct->id = ACPI_RSTYPE_IO;
 
-	/*
-	 * Check Decode
-	 */
+	/* Check Decode */
+
 	buffer += 1;
 	temp8 = *buffer;
 
 	output_struct->data.io.io_decode = temp8 & 0x01;
 
-	/*
-	 * Check min_base Address
-	 */
+	/* Check min_base Address */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.io.min_base_address = temp16;
 
-	/*
-	 * Check max_base Address
-	 */
+	/* Check max_base Address */
+
 	buffer += 2;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.io.max_base_address = temp16;
 
-	/*
-	 * Check Base alignment
-	 */
+	/* Check Base alignment */
+
 	buffer += 2;
 	temp8 = *buffer;
 
 	output_struct->data.io.alignment = temp8;
 
-	/*
-	 * Check range_length
-	 */
+	/* Check range_length */
+
 	buffer += 1;
 	temp8 = *buffer;
 
 	output_struct->data.io.range_length = temp8;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -179,43 +172,39 @@
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_fixed_io);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_fixed_io);
 
 
 	ACPI_FUNCTION_TRACE ("rs_fixed_io_resource");
 
 
-	/*
-	 * The number of bytes consumed are Constant
-	 */
+	/* The number of bytes consumed are Constant */
+
 	*bytes_consumed = 4;
 
 	output_struct->id = ACPI_RSTYPE_FIXED_IO;
 
-	/*
-	 * Check Range Base Address
-	 */
+	/* Check Range Base Address */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.fixed_io.base_address = temp16;
 
-	/*
-	 * Check range_length
-	 */
+	/* Check range_length */
+
 	buffer += 2;
 	temp8 = *buffer;
 
 	output_struct->data.fixed_io.range_length = temp8;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -251,55 +240,48 @@
 	ACPI_FUNCTION_TRACE ("rs_io_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x47;
 	buffer += 1;
 
-	/*
-	 * Io Information Byte
-	 */
+	/* Io Information Byte */
+
 	temp8 = (u8) (linked_list->data.io.io_decode & 0x01);
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Range minimum base address
-	 */
+	/* Set the Range minimum base address */
+
 	temp16 = (u16) linked_list->data.io.min_base_address;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the Range maximum base address
-	 */
+	/* Set the Range maximum base address */
+
 	temp16 = (u16) linked_list->data.io.max_base_address;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the base alignment
-	 */
+	/* Set the base alignment */
+
 	temp8 = (u8) linked_list->data.io.alignment;
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	temp8 = (u8) linked_list->data.io.range_length;
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -335,32 +317,28 @@
 	ACPI_FUNCTION_TRACE ("rs_fixed_io_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x4B;
 
 	buffer += 1;
 
-	/*
-	 * Set the Range base address
-	 */
+	/* Set the Range base address */
+
 	temp16 = (u16) linked_list->data.fixed_io.base_address;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	temp8 = (u8) linked_list->data.fixed_io.range_length;
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -399,21 +377,20 @@
 	u8                              temp8 = 0;
 	u8                              index;
 	u8                              i;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_dma);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_dma);
 
 
 	ACPI_FUNCTION_TRACE ("rs_dma_resource");
 
 
-	/*
-	 * The number of bytes consumed are Constant
-	 */
+	/* The number of bytes consumed are Constant */
+
 	*bytes_consumed = 3;
 	output_struct->id = ACPI_RSTYPE_DMA;
 
-	/*
-	 * Point to the 8-bits of Byte 1
-	 */
+	/* Point to the 8-bits of Byte 1 */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -430,46 +407,40 @@
 
 	output_struct->data.dma.number_of_channels = i;
 	if (i > 0) {
-		/*
-		 * Calculate the structure size based upon the number of interrupts
-		 */
+		/* Calculate the structure size based upon the number of interrupts */
+
 		struct_size += ((acpi_size) i - 1) * 4;
 	}
 
-	/*
-	 * Point to Byte 2
-	 */
+	/* Point to Byte 2 */
+
 	buffer += 1;
 	temp8 = *buffer;
 
-	/*
-	 * Check for transfer preference (Bits[1:0])
-	 */
+	/* Check for transfer preference (Bits[1:0]) */
+
 	output_struct->data.dma.transfer = temp8 & 0x03;
 
 	if (0x03 == output_struct->data.dma.transfer) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid DMA.Transfer preference (3)\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Invalid DMA.Transfer preference (3)\n"));
 		return_ACPI_STATUS (AE_BAD_DATA);
 	}
 
-	/*
-	 * Get bus master preference (Bit[2])
-	 */
+	/* Get bus master preference (Bit[2]) */
+
 	output_struct->data.dma.bus_master = (temp8 >> 2) & 0x01;
 
-	/*
-	 * Get channel speed support (Bits[6:5])
-	 */
+	/* Get channel speed support (Bits[6:5]) */
+
 	output_struct->data.dma.type = (temp8 >> 5) & 0x03;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -506,16 +477,14 @@
 	ACPI_FUNCTION_TRACE ("rs_dma_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x2A;
 	buffer += 1;
 	temp8 = 0;
 
-	/*
-	 * Loop through all of the Channels and set the mask bits
-	 */
+	/* Loop through all of the Channels and set the mask bits */
+
 	for (index = 0;
 		 index < linked_list->data.dma.number_of_channels;
 		 index++) {
@@ -526,9 +495,8 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the DMA Info
-	 */
+	/* Set the DMA Info */
+
 	temp8 = (u8) ((linked_list->data.dma.type & 0x03) << 5);
 	temp8 |= ((linked_list->data.dma.bus_master & 0x01) << 2);
 	temp8 |= (linked_list->data.dma.transfer & 0x03);
@@ -536,9 +504,8 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
diff -Nru a/drivers/acpi/resources/rsirq.c b/drivers/acpi/resources/rsirq.c
--- a/drivers/acpi/resources/rsirq.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rsirq.c	2005-04-19 01:34:14 -04:00
@@ -83,7 +83,8 @@
 	u8                              temp8 = 0;
 	u8                              index;
 	u8                              i;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_irq);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_irq);
 
 
 	ACPI_FUNCTION_TRACE ("rs_irq_resource");
@@ -91,15 +92,14 @@
 
 	/*
 	 * The number of bytes consumed are contained in the descriptor
-	 *  (Bits:0-1)
+	 * (Bits:0-1)
 	 */
 	temp8 = *buffer;
 	*bytes_consumed = (temp8 & 0x03) + 1;
 	output_struct->id = ACPI_RSTYPE_IRQ;
 
-	/*
-	 * Point to the 16-bits of Bytes 1 and 2
-	 */
+	/* Point to the 16-bits of Bytes 1 and 2 */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -118,22 +118,19 @@
 
 	output_struct->data.irq.number_of_interrupts = i;
 	if (i > 0) {
-		/*
-		 * Calculate the structure size based upon the number of interrupts
-		 */
+		/* Calculate the structure size based upon the number of interrupts */
+
 		struct_size += ((acpi_size) i - 1) * 4;
 	}
 
-	/*
-	 * Point to Byte 3 if it is used
-	 */
+	/* Point to Byte 3 if it is used */
+
 	if (4 == *bytes_consumed) {
 		buffer += 2;
 		temp8 = *buffer;
 
-		/*
-		 * Check for HE, LL interrupts
-		 */
+		/* Check for HE, LL interrupts */
+
 		switch (temp8 & 0x09) {
 		case 0x01: /* HE */
 			output_struct->data.irq.edge_level = ACPI_EDGE_SENSITIVE;
@@ -152,13 +149,13 @@
 			 * so 0x00 and 0x09 are illegal.
 			 */
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Invalid interrupt polarity/trigger in resource list, %X\n", temp8));
+				"Invalid interrupt polarity/trigger in resource list, %X\n",
+				temp8));
 			return_ACPI_STATUS (AE_BAD_DATA);
 		}
 
-		/*
-		 * Check for sharable
-		 */
+		/* Check for sharable */
+
 		output_struct->data.irq.shared_exclusive = (temp8 >> 3) & 0x01;
 	}
 	else {
@@ -171,14 +168,12 @@
 		output_struct->data.irq.shared_exclusive = ACPI_EXCLUSIVE;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -234,9 +229,8 @@
 	buffer += 1;
 	temp16 = 0;
 
-	/*
-	 * Loop through all of the interrupts and set the mask bits
-	 */
+	/* Loop through all of the interrupts and set the mask bits */
+
 	for(index = 0;
 		index < linked_list->data.irq.number_of_interrupts;
 		index++) {
@@ -247,9 +241,8 @@
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the IRQ Info byte if needed.
-	 */
+	/* Set the IRQ Info byte if needed. */
+
 	if (IRqinfo_byte_needed) {
 		temp8 = 0;
 		temp8 = (u8) ((linked_list->data.irq.shared_exclusive &
@@ -267,9 +260,8 @@
 		buffer += 1;
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -309,15 +301,15 @@
 	u8                              temp8 = 0;
 	u8                              *temp_ptr;
 	u8                              index;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_ext_irq);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_ext_irq);
 
 
 	ACPI_FUNCTION_TRACE ("rs_extended_irq_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -330,9 +322,8 @@
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_EXT_IRQ;
 
-	/*
-	 * Point to the Byte3
-	 */
+	/* Point to the Byte3 */
+
 	buffer += 2;
 	temp8 = *buffer;
 
@@ -347,21 +338,18 @@
 	 * - Edge/Level are defined opposite in the table vs the headers
 	 */
 	output_struct->data.extended_irq.edge_level =
-			   (temp8 & 0x2) ? ACPI_EDGE_SENSITIVE : ACPI_LEVEL_SENSITIVE;
+		(temp8 & 0x2) ? ACPI_EDGE_SENSITIVE : ACPI_LEVEL_SENSITIVE;
+
+	/* Check Interrupt Polarity */
 
-	/*
-	 * Check Interrupt Polarity
-	 */
 	output_struct->data.extended_irq.active_high_low = (temp8 >> 2) & 0x1;
 
-	/*
-	 * Check for sharable
-	 */
+	/* Check for sharable */
+
 	output_struct->data.extended_irq.shared_exclusive = (temp8 >> 3) & 0x01;
 
-	/*
-	 * Point to Byte4 (IRQ Table length)
-	 */
+	/* Point to Byte4 (IRQ Table length) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -379,14 +367,12 @@
 	 */
 	struct_size += (temp8 - 1) * 4;
 
-	/*
-	 * Point to Byte5 (First IRQ Number)
-	 */
+	/* Point to Byte5 (First IRQ Number) */
+
 	buffer += 1;
 
-	/*
-	 * Cycle through every IRQ in the table
-	 */
+	/* Cycle through every IRQ in the table */
+
 	for (index = 0; index < temp8; index++) {
 		ACPI_MOVE_32_TO_32 (
 			&output_struct->data.extended_irq.interrupts[index], buffer);
@@ -407,7 +393,8 @@
 	 * we add 1 to the length.
 	 */
 	if (*bytes_consumed >
-		((acpi_size) output_struct->data.extended_irq.number_of_interrupts * 4) + (5 + 1)) {
+		((acpi_size) output_struct->data.extended_irq.number_of_interrupts * 4) +
+		(5 + 1)) {
 		/* Dereference the Index */
 
 		temp8 = *buffer;
@@ -417,13 +404,13 @@
 
 		buffer += 1;
 
-		/*
-		 * Point the String pointer to the end of this structure.
-		 */
+		/* Point the String pointer to the end of this structure. */
+
 		output_struct->data.extended_irq.resource_source.string_ptr =
 				(char *)((char *) output_struct + struct_size);
 
-		temp_ptr = (u8 *) output_struct->data.extended_irq.resource_source.string_ptr;
+		temp_ptr = (u8 *)
+			output_struct->data.extended_irq.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -436,9 +423,8 @@
 			index += 1;
 		}
 
-		/*
-		 * Add the terminating null
-		 */
+		/* Add the terminating null */
+
 		*temp_ptr = 0x00;
 		output_struct->data.extended_irq.resource_source.string_length = index + 1;
 
@@ -456,14 +442,12 @@
 		output_struct->data.extended_irq.resource_source.string_ptr = NULL;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -501,21 +485,18 @@
 	ACPI_FUNCTION_TRACE ("rs_extended_irq_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x89;
 	buffer += 1;
 
-	/*
-	 * Set a pointer to the Length field - to be filled in later
-	 */
+	/* Set a pointer to the Length field - to be filled in later */
+
 	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
-	/*
-	 * Set the Interrupt vector flags
-	 */
+	/* Set the Interrupt vector flags */
+
 	temp8 = (u8)(linked_list->data.extended_irq.producer_consumer & 0x01);
 	temp8 |= ((linked_list->data.extended_irq.shared_exclusive & 0x01) << 3);
 
@@ -532,17 +513,15 @@
 		temp8 |= 0x2;
 	}
 
-	/*
-	 * Set the Interrupt Polarity
-	 */
+	/* Set the Interrupt Polarity */
+
 	temp8 |= ((linked_list->data.extended_irq.active_high_low & 0x1) << 2);
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Interrupt table length
-	 */
+	/* Set the Interrupt table length */
+
 	temp8 = (u8) linked_list->data.extended_irq.number_of_interrupts;
 
 	*buffer = temp8;
@@ -555,18 +534,16 @@
 		buffer += 4;
 	}
 
-	/*
-	 * Resource Source Index and Resource Source are optional
-	 */
+	/* Resource Source Index and Resource Source are optional */
+
 	if (0 != linked_list->data.extended_irq.resource_source.string_length) {
 		*buffer = (u8) linked_list->data.extended_irq.resource_source.index;
 		buffer += 1;
 
 		temp_pointer = (char *) buffer;
 
-		/*
-		 * Copy the string
-		 */
+		/* Copy the string */
+
 		ACPI_STRCPY (temp_pointer,
 			linked_list->data.extended_irq.resource_source.string_ptr);
 
@@ -574,12 +551,12 @@
 		 * Buffer needs to be set to the length of the sting + one for the
 		 * terminating null
 		 */
-		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.extended_irq.resource_source.string_ptr) + 1);
+		buffer += (acpi_size) (ACPI_STRLEN (
+			linked_list->data.extended_irq.resource_source.string_ptr) + 1);
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
diff -Nru a/drivers/acpi/resources/rslist.c b/drivers/acpi/resources/rslist.c
--- a/drivers/acpi/resources/rslist.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rslist.c	2005-04-19 01:34:14 -04:00
@@ -55,7 +55,7 @@
  *
  * PARAMETERS:  resource_start_byte     - Byte 0 of a resource descriptor
  *
- * RETURN:      The Resource Type (Name) with no extraneous bits
+ * RETURN:      The Resource Type with no extraneous bits
  *
  * DESCRIPTION: Extract the Resource Type/Name from the first byte of
  *              a resource descriptor.
@@ -70,28 +70,25 @@
 	ACPI_FUNCTION_ENTRY ();
 
 
-	/*
-	 * Determine if this is a small or large resource
-	 */
+	/* Determine if this is a small or large resource */
+
 	switch (resource_start_byte & ACPI_RDESC_TYPE_MASK) {
 	case ACPI_RDESC_TYPE_SMALL:
 
-		/*
-		 * Small Resource Type -- Only bits 6:3 are valid
-		 */
+		/* Small Resource Type -- Only bits 6:3 are valid */
+
 		return ((u8) (resource_start_byte & ACPI_RDESC_SMALL_MASK));
 
 
 	case ACPI_RDESC_TYPE_LARGE:
 
-		/*
-		 * Large Resource Type -- All bits are valid
-		 */
+		/* Large Resource Type -- All bits are valid */
+
 		return (resource_start_byte);
 
 
 	default:
-		/* No other types of resource descriptor */
+		/* Invalid type */
 		break;
 	}
 
@@ -135,9 +132,8 @@
 
 	while (bytes_parsed < byte_stream_buffer_length &&
 			!end_tag_processed) {
-		/*
-		 * The next byte in the stream is the resource type
-		 */
+		/* The next byte in the stream is the resource type */
+
 		resource_type = acpi_rs_get_resource_type (*byte_stream_buffer);
 
 		switch (resource_type) {
@@ -299,28 +295,23 @@
 			return_ACPI_STATUS (status);
 		}
 
-		/*
-		 * Update the return value and counter
-		 */
+		/* Update the return value and counter */
+
 		bytes_parsed += bytes_consumed;
 
-		/*
-		 * Set the byte stream to point to the next resource
-		 */
+		/* Set the byte stream to point to the next resource */
+
 		byte_stream_buffer += bytes_consumed;
 
-		/*
-		 * Set the Buffer to the next structure
-		 */
+		/* Set the Buffer to the next structure */
+
 		resource = ACPI_CAST_PTR (struct acpi_resource, buffer);
 		resource->length = (u32) ACPI_ALIGN_RESOURCE_SIZE (resource->length);
 		buffer += ACPI_ALIGN_RESOURCE_SIZE (structure_size);
+	}
 
-	} /*  end while */
+	/* Check the reason for exiting the while loop */
 
-	/*
-	 * Check the reason for exiting the while loop
-	 */
 	if (!end_tag_processed) {
 		return_ACPI_STATUS (AE_AML_NO_RESOURCE_END_TAG);
 	}
@@ -424,9 +415,8 @@
 			 */
 			status = acpi_rs_end_tag_stream (linked_list, &buffer, &bytes_consumed);
 
-			/*
-			 * An End Tag indicates the end of the Resource Template
-			 */
+			/* An End Tag indicates the end of the Resource Template */
+
 			done = TRUE;
 			break;
 
@@ -488,27 +478,25 @@
 		default:
 			/*
 			 * If we get here, everything is out of sync,
-			 *  so exit with an error
+			 * so exit with an error
 			 */
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid descriptor type (%X) in resource list\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Invalid descriptor type (%X) in resource list\n",
 				linked_list->id));
 			status = AE_BAD_DATA;
 			break;
-
-		} /* switch (linked_list->Id) */
+		}
 
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 
-		/*
-		 * Set the Buffer to point to the open byte
-		 */
+		/* Set the Buffer to point to the open byte */
+
 		buffer += bytes_consumed;
 
-		/*
-		 * Point to the next object
-		 */
+		/* Point to the next object */
+
 		linked_list = ACPI_PTR_ADD (struct acpi_resource,
 				  linked_list, linked_list->length);
 	}
diff -Nru a/drivers/acpi/resources/rsmemory.c b/drivers/acpi/resources/rsmemory.c
--- a/drivers/acpi/resources/rsmemory.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rsmemory.c	2005-04-19 01:34:14 -04:00
@@ -81,15 +81,15 @@
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_mem24);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_mem24);
 
 
 	ACPI_FUNCTION_TRACE ("rs_memory24_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
@@ -97,48 +97,41 @@
 	*bytes_consumed = (acpi_size) temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_MEM24;
 
-	/*
-	 * Check Byte 3 the Read/Write bit
-	 */
+	/* Check Byte 3 the Read/Write bit */
+
 	temp8 = *buffer;
 	buffer += 1;
 	output_struct->data.memory24.read_write_attribute = temp8 & 0x01;
 
-	/*
-	 * Get min_base_address (Bytes 4-5)
-	 */
+	/* Get min_base_address (Bytes 4-5) */
+
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.min_base_address = temp16;
 
-	/*
-	 * Get max_base_address (Bytes 6-7)
-	 */
+	/* Get max_base_address (Bytes 6-7) */
+
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.max_base_address = temp16;
 
-	/*
-	 * Get Alignment (Bytes 8-9)
-	 */
+	/* Get Alignment (Bytes 8-9) */
+
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.alignment = temp16;
 
-	/*
-	 * Get range_length (Bytes 10-11)
-	 */
+	/* Get range_length (Bytes 10-11) */
+
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	output_struct->data.memory24.range_length = temp16;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -174,53 +167,45 @@
 	ACPI_FUNCTION_TRACE ("rs_memory24_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x81;
 	buffer += 1;
 
-	/*
-	 * The length field is static
-	 */
+	/* The length field is static */
+
 	temp16 = 0x09;
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the Information Byte
-	 */
+	/* Set the Information Byte */
+
 	temp8 = (u8) (linked_list->data.memory24.read_write_attribute & 0x01);
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Range minimum base address
-	 */
+	/* Set the Range minimum base address */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.min_base_address);
 	buffer += 2;
 
-	/*
-	 * Set the Range maximum base address
-	 */
+	/* Set the Range maximum base address */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.max_base_address);
 	buffer += 2;
 
-	/*
-	 * Set the base alignment
-	 */
+	/* Set the base alignment */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.alignment);
 	buffer += 2;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.range_length);
 	buffer += 2;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -258,15 +243,15 @@
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_mem32);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_mem32);
 
 
 	ACPI_FUNCTION_TRACE ("rs_memory32_range_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
@@ -285,45 +270,38 @@
 	 *  4 * sizeof(RESOURCE_DATA) instead of 4 * sizeof(u8)
 	 */
 
-	/*
-	 * Check Byte 3 the Read/Write bit
-	 */
+	/* Check Byte 3 the Read/Write bit */
+
 	temp8 = *buffer;
 	buffer += 1;
 
 	output_struct->data.memory32.read_write_attribute = temp8 & 0x01;
 
-	/*
-	 * Get min_base_address (Bytes 4-7)
-	 */
+	/* Get min_base_address (Bytes 4-7) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.min_base_address, buffer);
 	buffer += 4;
 
-	/*
-	 * Get max_base_address (Bytes 8-11)
-	 */
+	/* Get max_base_address (Bytes 8-11) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.max_base_address, buffer);
 	buffer += 4;
 
-	/*
-	 * Get Alignment (Bytes 12-15)
-	 */
+	/* Get Alignment (Bytes 12-15) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.alignment, buffer);
 	buffer += 4;
 
-	/*
-	 * Get range_length (Bytes 16-19)
-	 */
+	/* Get range_length (Bytes 16-19) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.range_length, buffer);
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -361,15 +339,15 @@
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_fixed_mem32);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_fixed_mem32);
 
 
 	ACPI_FUNCTION_TRACE ("rs_fixed_memory32_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -378,32 +356,28 @@
 
 	output_struct->id = ACPI_RSTYPE_FIXED_MEM32;
 
-	/*
-	 * Check Byte 3 the Read/Write bit
-	 */
+	/* Check Byte 3 the Read/Write bit */
+
 	temp8 = *buffer;
 	buffer += 1;
 	output_struct->data.fixed_memory32.read_write_attribute = temp8 & 0x01;
 
-	/*
-	 * Get range_base_address (Bytes 4-7)
-	 */
-	ACPI_MOVE_32_TO_32 (&output_struct->data.fixed_memory32.range_base_address, buffer);
+	/* Get range_base_address (Bytes 4-7) */
+
+	ACPI_MOVE_32_TO_32 (&output_struct->data.fixed_memory32.range_base_address,
+		buffer);
 	buffer += 4;
 
-	/*
-	 * Get range_length (Bytes 8-11)
-	 */
+	/* Get range_length (Bytes 8-11) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.fixed_memory32.range_length, buffer);
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -439,54 +413,46 @@
 	ACPI_FUNCTION_TRACE ("rs_memory32_range_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x85;
 	buffer += 1;
 
-	/*
-	 * The length field is static
-	 */
+	/* The length field is static */
+
 	temp16 = 0x11;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the Information Byte
-	 */
+	/* Set the Information Byte */
+
 	temp8 = (u8) (linked_list->data.memory32.read_write_attribute & 0x01);
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Range minimum base address
-	 */
+	/* Set the Range minimum base address */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.min_base_address);
 	buffer += 4;
 
-	/*
-	 * Set the Range maximum base address
-	 */
+	/* Set the Range maximum base address */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.max_base_address);
 	buffer += 4;
 
-	/*
-	 * Set the base alignment
-	 */
+	/* Set the base alignment */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.alignment);
 	buffer += 4;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.range_length);
 	buffer += 4;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -522,44 +488,38 @@
 	ACPI_FUNCTION_TRACE ("rs_fixed_memory32_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x86;
 	buffer += 1;
 
-	/*
-	 * The length field is static
-	 */
+	/* The length field is static */
+
 	temp16 = 0x09;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the Information Byte
-	 */
+	/* Set the Information Byte */
+
 	temp8 = (u8) (linked_list->data.fixed_memory32.read_write_attribute & 0x01);
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Range base address
-	 */
+	/* Set the Range base address */
+
 	ACPI_MOVE_32_TO_32 (buffer,
-			 &linked_list->data.fixed_memory32.range_base_address);
+		&linked_list->data.fixed_memory32.range_base_address);
 	buffer += 4;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	ACPI_MOVE_32_TO_32 (buffer,
-			 &linked_list->data.fixed_memory32.range_length);
+		&linked_list->data.fixed_memory32.range_length);
 	buffer += 4;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
diff -Nru a/drivers/acpi/resources/rsmisc.c b/drivers/acpi/resources/rsmisc.c
--- a/drivers/acpi/resources/rsmisc.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rsmisc.c	2005-04-19 01:34:14 -04:00
@@ -84,24 +84,20 @@
 	ACPI_FUNCTION_TRACE ("rs_end_tag_resource");
 
 
-	/*
-	 * The number of bytes consumed is static
-	 */
+	/* The number of bytes consumed is static */
+
 	*bytes_consumed = 2;
 
-	/*
-	 *  Fill out the structure
-	 */
+	/*  Fill out the structure */
+
 	output_struct->id = ACPI_RSTYPE_END_TAG;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = 0;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -136,9 +132,8 @@
 	ACPI_FUNCTION_TRACE ("rs_end_tag_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x79;
 	buffer += 1;
 
@@ -151,9 +146,8 @@
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -192,21 +186,20 @@
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
 	u8                              index;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_vendor);
 
 
 	ACPI_FUNCTION_TRACE ("rs_vendor_resource");
 
 
-	/*
-	 * Dereference the Descriptor to find if this is a large or small item.
-	 */
+	/* Dereference the Descriptor to find if this is a large or small item. */
+
 	temp8 = *buffer;
 
 	if (temp8 & 0x80) {
-		/*
-		 * Large Item, point to the length field
-		 */
+		/* Large Item, point to the length field */
+
 		buffer += 1;
 
 		/* Dereference */
@@ -222,9 +215,8 @@
 		buffer += 2;
 	}
 	else {
-		/*
-		 * Small Item, dereference the size
-		 */
+		/* Small Item, dereference the size */
+
 		temp16 = (u8)(*buffer & 0x07);
 
 		/* Calculate bytes consumed */
@@ -251,14 +243,12 @@
 	 */
 	struct_size += ACPI_ROUND_UP_to_32_bITS (temp16);
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -295,13 +285,11 @@
 	ACPI_FUNCTION_TRACE ("rs_vendor_stream");
 
 
-	/*
-	 * Dereference the length to find if this is a large or small item.
-	 */
+	/* Dereference the length to find if this is a large or small item. */
+
 	if(linked_list->data.vendor_specific.length > 7) {
-		/*
-		 * Large Item, Set the descriptor field and length bytes
-		 */
+		/* Large Item, Set the descriptor field and length bytes */
+
 		*buffer = 0x84;
 		buffer += 1;
 
@@ -311,9 +299,8 @@
 		buffer += 2;
 	}
 	else {
-		/*
-		 * Small Item, Set the descriptor field
-		 */
+		/* Small Item, Set the descriptor field */
+
 		temp8 = 0x70;
 		temp8 |= (u8) linked_list->data.vendor_specific.length;
 
@@ -321,9 +308,8 @@
 		buffer += 1;
 	}
 
-	/*
-	 * Loop through all of the Vendor Specific fields
-	 */
+	/* Loop through all of the Vendor Specific fields */
+
 	for (index = 0; index < linked_list->data.vendor_specific.length; index++) {
 		temp8 = linked_list->data.vendor_specific.reserved[index];
 
@@ -331,9 +317,8 @@
 		buffer += 1;
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -370,40 +355,37 @@
 	u8                              *buffer = byte_stream_buffer;
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_start_dpf);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_start_dpf);
 
 
 	ACPI_FUNCTION_TRACE ("rs_start_depend_fns_resource");
 
 
-	/*
-	 * The number of bytes consumed are contained in the descriptor (Bits:0-1)
-	 */
+	/* The number of bytes consumed are found in the descriptor (Bits:0-1) */
+
 	temp8 = *buffer;
 
 	*bytes_consumed = (temp8 & 0x01) + 1;
 
 	output_struct->id = ACPI_RSTYPE_START_DPF;
 
-	/*
-	 * Point to Byte 1 if it is used
-	 */
+	/* Point to Byte 1 if it is used */
+
 	if (2 == *bytes_consumed) {
 		buffer += 1;
 		temp8 = *buffer;
 
-		/*
-		 * Check Compatibility priority
-		 */
+		/* Check Compatibility priority */
+
 		output_struct->data.start_dpf.compatibility_priority = temp8 & 0x03;
 
 		if (3 == output_struct->data.start_dpf.compatibility_priority) {
 			return_ACPI_STATUS (AE_AML_BAD_RESOURCE_VALUE);
 		}
 
-		/*
-		 * Check Performance/Robustness preference
-		 */
+		/* Check Performance/Robustness preference */
+
 		output_struct->data.start_dpf.performance_robustness = (temp8 >> 2) & 0x03;
 
 		if (3 == output_struct->data.start_dpf.performance_robustness) {
@@ -412,20 +394,18 @@
 	}
 	else {
 		output_struct->data.start_dpf.compatibility_priority =
-				ACPI_ACCEPTABLE_CONFIGURATION;
+			ACPI_ACCEPTABLE_CONFIGURATION;
 
 		output_struct->data.start_dpf.performance_robustness =
-				ACPI_ACCEPTABLE_CONFIGURATION;
+			ACPI_ACCEPTABLE_CONFIGURATION;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -466,24 +446,20 @@
 	ACPI_FUNCTION_TRACE ("rs_end_depend_fns_resource");
 
 
-	/*
-	 * The number of bytes consumed is static
-	 */
+	/* The number of bytes consumed is static */
+
 	*bytes_consumed = 1;
 
-	/*
-	 *  Fill out the structure
-	 */
+	/*  Fill out the structure */
+
 	output_struct->id = ACPI_RSTYPE_END_DPF;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -533,9 +509,8 @@
 		*buffer = 0x31;
 		buffer += 1;
 
-		/*
-		 * Set the Priority Byte Definition
-		 */
+		/* Set the Priority Byte Definition */
+
 		temp8 = 0;
 		temp8 = (u8) ((linked_list->data.start_dpf.performance_robustness &
 				   0x03) << 2);
@@ -546,9 +521,8 @@
 
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -582,15 +556,13 @@
 	ACPI_FUNCTION_TRACE ("rs_end_depend_fns_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x38;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
diff -Nru a/drivers/acpi/resources/rsutils.c b/drivers/acpi/resources/rsutils.c
--- a/drivers/acpi/resources/rsutils.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rsutils.c	2005-04-19 01:34:14 -04:00
@@ -83,10 +83,10 @@
 
 	/* Parameters guaranteed valid by caller */
 
-	/*
-	 * Execute the method, no parameters
-	 */
-	status = acpi_ut_evaluate_object (handle, "_PRT", ACPI_BTYPE_PACKAGE, &obj_desc);
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object (handle, METHOD_NAME__PRT,
+			 ACPI_BTYPE_PACKAGE, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -136,10 +136,10 @@
 
 	/* Parameters guaranteed valid by caller */
 
-	/*
-	 * Execute the method, no parameters
-	 */
-	status = acpi_ut_evaluate_object (handle, "_CRS", ACPI_BTYPE_BUFFER, &obj_desc);
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object (handle, METHOD_NAME__CRS,
+			 ACPI_BTYPE_BUFFER, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -175,6 +175,7 @@
  *              and the contents of the callers buffer is undefined.
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_rs_get_prs_method_data (
@@ -190,10 +191,10 @@
 
 	/* Parameters guaranteed valid by caller */
 
-	/*
-	 * Execute the method, no parameters
-	 */
-	status = acpi_ut_evaluate_object (handle, "_PRS", ACPI_BTYPE_BUFFER, &obj_desc);
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object (handle, METHOD_NAME__PRS,
+			 ACPI_BTYPE_BUFFER, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -218,6 +219,7 @@
  * FUNCTION:    acpi_rs_get_method_data
  *
  * PARAMETERS:  Handle          - a handle to the containing object
+ *              Path            - Path to method, relative to Handle
  *              ret_buffer      - a pointer to a buffer structure for the
  *                                  results
  *
@@ -246,9 +248,8 @@
 
 	/* Parameters guaranteed valid by caller */
 
-	/*
-	 * Execute the method, no parameters
-	 */
+	/* Execute the method, no parameters */
+
 	status = acpi_ut_evaluate_object (handle, path, ACPI_BTYPE_BUFFER, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -314,18 +315,16 @@
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Init the param object
-	 */
+	/* Init the param object */
+
 	params[0] = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
 	if (!params[0]) {
 		acpi_os_free (buffer.pointer);
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	/*
-	 * Set up the parameter object
-	 */
+	/* Set up the parameter object */
+
 	params[0]->buffer.length  = (u32) buffer.length;
 	params[0]->buffer.pointer = buffer.pointer;
 	params[0]->common.flags   = AOPOBJ_DATA_VALID;
@@ -335,10 +334,9 @@
 	info.parameters = params;
 	info.parameter_type = ACPI_PARAM_ARGS;
 
-	/*
-	 * Execute the method, no return value
-	 */
-	status = acpi_ns_evaluate_relative ("_SRS", &info);
+	/* Execute the method, no return value */
+
+	status = acpi_ns_evaluate_relative (METHOD_NAME__SRS, &info);
 	if (ACPI_SUCCESS (status)) {
 		/* Delete any return object (especially if implicit_return is enabled) */
 
@@ -347,9 +345,8 @@
 		}
 	}
 
-	/*
-	 * Clean up and return the status from acpi_ns_evaluate_relative
-	 */
+	/* Clean up and return the status from acpi_ns_evaluate_relative */
+
 	acpi_ut_remove_reference (params[0]);
 	return_ACPI_STATUS (status);
 }
diff -Nru a/drivers/acpi/resources/rsxface.c b/drivers/acpi/resources/rsxface.c
--- a/drivers/acpi/resources/rsxface.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/resources/rsxface.c	2005-04-19 01:34:14 -04:00
@@ -49,6 +49,23 @@
 #define _COMPONENT          ACPI_RESOURCES
 	 ACPI_MODULE_NAME    ("rsxface")
 
+/* Local macros for 16,32-bit to 64-bit conversion */
+
+#define ACPI_COPY_FIELD(out, in, field)  ((out)->field = (in)->field)
+#define ACPI_COPY_ADDRESS(out, in)                      \
+	ACPI_COPY_FIELD(out, in, resource_type);             \
+	ACPI_COPY_FIELD(out, in, producer_consumer);         \
+	ACPI_COPY_FIELD(out, in, decode);                    \
+	ACPI_COPY_FIELD(out, in, min_address_fixed);         \
+	ACPI_COPY_FIELD(out, in, max_address_fixed);         \
+	ACPI_COPY_FIELD(out, in, attribute);                 \
+	ACPI_COPY_FIELD(out, in, granularity);               \
+	ACPI_COPY_FIELD(out, in, min_address_range);         \
+	ACPI_COPY_FIELD(out, in, max_address_range);         \
+	ACPI_COPY_FIELD(out, in, address_translation_offset); \
+	ACPI_COPY_FIELD(out, in, address_length);            \
+	ACPI_COPY_FIELD(out, in, resource_source);
+
 
 /*******************************************************************************
  *
@@ -180,6 +197,7 @@
  *              and the value of ret_buffer is undefined.
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_get_possible_resources (
@@ -346,9 +364,8 @@
 	ACPI_FUNCTION_TRACE ("acpi_set_current_resources");
 
 
-	/*
-	 * Must have a valid handle and buffer
-	 */
+	/* Must have a valid handle and buffer */
+
 	if ((!device_handle)      ||
 		(!in_buffer)          ||
 		(!in_buffer->pointer) ||
@@ -362,21 +379,6 @@
 EXPORT_SYMBOL(acpi_set_current_resources);
 
 
-#define ACPI_COPY_FIELD(out, in, field)  ((out)->field = (in)->field)
-#define ACPI_COPY_ADDRESS(out, in)                      \
-	ACPI_COPY_FIELD(out, in, resource_type);             \
-	ACPI_COPY_FIELD(out, in, producer_consumer);         \
-	ACPI_COPY_FIELD(out, in, decode);                    \
-	ACPI_COPY_FIELD(out, in, min_address_fixed);         \
-	ACPI_COPY_FIELD(out, in, max_address_fixed);         \
-	ACPI_COPY_FIELD(out, in, attribute);                 \
-	ACPI_COPY_FIELD(out, in, granularity);               \
-	ACPI_COPY_FIELD(out, in, min_address_range);         \
-	ACPI_COPY_FIELD(out, in, max_address_range);         \
-	ACPI_COPY_FIELD(out, in, address_translation_offset); \
-	ACPI_COPY_FIELD(out, in, address_length);            \
-	ACPI_COPY_FIELD(out, in, resource_source);
-
 /******************************************************************************
  *
  * FUNCTION:    acpi_resource_to_address64
@@ -408,14 +410,14 @@
 	case ACPI_RSTYPE_ADDRESS16:
 
 		address16 = (struct acpi_resource_address16 *) &resource->data;
-		ACPI_COPY_ADDRESS(out, address16);
+		ACPI_COPY_ADDRESS (out, address16);
 		break;
 
 
 	case ACPI_RSTYPE_ADDRESS32:
 
 		address32 = (struct acpi_resource_address32 *) &resource->data;
-		ACPI_COPY_ADDRESS(out, address32);
+		ACPI_COPY_ADDRESS (out, address32);
 		break;
 
 
@@ -434,4 +436,3 @@
 	return (AE_OK);
 }
 EXPORT_SYMBOL(acpi_resource_to_address64);
-
diff -Nru a/drivers/acpi/sleep/proc.c b/drivers/acpi/sleep/proc.c
--- a/drivers/acpi/sleep/proc.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/sleep/proc.c	2005-04-19 01:34:14 -04:00
@@ -13,13 +13,17 @@
 
 #include "sleep.h"
 
+#ifdef	CONFIG_ACPI_SLEEP_PROC_SLEEP
 #define ACPI_SYSTEM_FILE_SLEEP		"sleep"
+#endif
+
 #define ACPI_SYSTEM_FILE_ALARM		"alarm"
 #define ACPI_SYSTEM_FILE_WAKEUP_DEVICE   "wakeup"
 
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME		("sleep")
 
+#ifdef	CONFIG_ACPI_SLEEP_PROC_SLEEP
 
 static int acpi_system_sleep_seq_show(struct seq_file *seq, void *offset)
 {
@@ -78,6 +82,7 @@
  Done:
 	return error ? error : count;
 }
+#endif	/* CONFIG_ACPI_SLEEP_PROC_SLEEP */
 
 static int acpi_system_alarm_seq_show(struct seq_file *seq, void *offset)
 {
@@ -452,6 +457,7 @@
 	.release	= single_release,
 };
 
+#ifdef	CONFIG_ACPI_SLEEP_PROC_SLEEP
 static struct file_operations acpi_system_sleep_fops = {
 	.open		= acpi_system_sleep_open_fs,
 	.read		= seq_read,
@@ -459,6 +465,7 @@
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
+#endif	/* CONFIG_ACPI_SLEEP_PROC_SLEEP */
 
 static struct file_operations acpi_system_alarm_fops = {
 	.open		= acpi_system_alarm_open_fs,
@@ -484,11 +491,13 @@
 	if (acpi_disabled)
 		return 0;
  
+#ifdef	CONFIG_ACPI_SLEEP_PROC_SLEEP
 	/* 'sleep' [R/W]*/
 	entry = create_proc_entry(ACPI_SYSTEM_FILE_SLEEP,
 				  S_IFREG|S_IRUGO|S_IWUSR, acpi_root_dir);
 	if (entry)
 		entry->proc_fops = &acpi_system_sleep_fops;
+#endif
 
 	/* 'alarm' [R/W] */
 	entry = create_proc_entry(ACPI_SYSTEM_FILE_ALARM,
diff -Nru a/drivers/acpi/tables/tbconvrt.c b/drivers/acpi/tables/tbconvrt.c
--- a/drivers/acpi/tables/tbconvrt.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/tables/tbconvrt.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,24 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbconvrt")
 
+/* Local prototypes */
+
+static void
+acpi_tb_init_generic_address (
+	struct acpi_generic_address     *new_gas_struct,
+	u8                              register_bit_width,
+	acpi_physical_address           address);
+
+static void
+acpi_tb_convert_fadt1 (
+	struct fadt_descriptor_rev2    *local_fadt,
+	struct fadt_descriptor_rev1    *original_fadt);
+
+static void
+acpi_tb_convert_fadt2 (
+	struct fadt_descriptor_rev2    *local_fadt,
+	struct fadt_descriptor_rev2    *original_fadt);
+
 
 u8 acpi_fadt_is_v1;
 EXPORT_SYMBOL(acpi_fadt_is_v1);
@@ -142,11 +160,13 @@
 	for (i = 0; i < acpi_gbl_rsdt_table_count; i++) {
 		if (acpi_gbl_RSDP->revision < 2) {
 			ACPI_STORE_ADDRESS (new_table->table_offset_entry[i],
-				(ACPI_CAST_PTR (struct rsdt_descriptor_rev1, table_info->pointer))->table_offset_entry[i]);
+				(ACPI_CAST_PTR (struct rsdt_descriptor_rev1,
+					table_info->pointer))->table_offset_entry[i]);
 		}
 		else {
 			new_table->table_offset_entry[i] =
-				(ACPI_CAST_PTR (XSDT_DESCRIPTOR, table_info->pointer))->table_offset_entry[i];
+				(ACPI_CAST_PTR (XSDT_DESCRIPTOR,
+					table_info->pointer))->table_offset_entry[i];
 		}
 	}
 
@@ -164,7 +184,7 @@
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_tb_init_generic_address
  *
@@ -201,7 +221,7 @@
  * PARAMETERS:  local_fadt      - Pointer to new FADT
  *              original_fadt   - Pointer to old FADT
  *
- * RETURN:      Populates local_fadt
+ * RETURN:      None, populates local_fadt
  *
  * DESCRIPTION: Convert an ACPI 1.0 FADT to common internal format
  *
@@ -213,7 +233,6 @@
 	struct fadt_descriptor_rev1    *original_fadt)
 {
 
-
 	/* ACPI 1.0 FACS */
 	/* The BIOS stored FADT should agree with Revision 1.0 */
 	acpi_fadt_is_v1 = 1;
@@ -232,7 +251,8 @@
 	ACPI_STORE_ADDRESS (local_fadt->Xdsdt, local_fadt->V1_dsdt);
 
 	/*
-	 * System Interrupt Model isn't used in ACPI 2.0 (local_fadt->Reserved1 = 0;)
+	 * System Interrupt Model isn't used in ACPI 2.0
+	 * (local_fadt->Reserved1 = 0;)
 	 */
 
 	/*
@@ -269,7 +289,8 @@
 		 * that immediately follows.
 		 */
 		ACPI_MEMCPY (&local_fadt->reset_register,
-			&(ACPI_CAST_PTR (struct fadt_descriptor_rev2_minus, original_fadt))->reset_register,
+			&(ACPI_CAST_PTR (struct fadt_descriptor_rev2_minus,
+				original_fadt))->reset_register,
   			sizeof (struct acpi_generic_address) + 1);
 	}
 	else {
@@ -304,7 +325,8 @@
 
 	acpi_tb_init_generic_address (&acpi_gbl_xpm1a_enable,
 		 (u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
-		 (acpi_physical_address) (local_fadt->xpm1a_evt_blk.address +
+		 (acpi_physical_address)
+			(local_fadt->xpm1a_evt_blk.address +
 			ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
 
 	/* PM1B is optional; leave null if not present */
@@ -312,7 +334,8 @@
 	if (local_fadt->xpm1b_evt_blk.address) {
 		acpi_tb_init_generic_address (&acpi_gbl_xpm1b_enable,
 			 (u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
-			 (acpi_physical_address) (local_fadt->xpm1b_evt_blk.address +
+			 (acpi_physical_address)
+				(local_fadt->xpm1b_evt_blk.address +
 				ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
 	}
 }
@@ -325,7 +348,7 @@
  * PARAMETERS:  local_fadt      - Pointer to new FADT
  *              original_fadt   - Pointer to old FADT
  *
- * RETURN:      Populates local_fadt
+ * RETURN:      None, populates local_fadt
  *
  * DESCRIPTION: Convert an ACPI 2.0 FADT to common internal format.
  *              Handles optional "X" fields.
@@ -348,7 +371,8 @@
 	 * is zero.
 	 */
 	if (!(local_fadt->xfirmware_ctrl)) {
-		ACPI_STORE_ADDRESS (local_fadt->xfirmware_ctrl, local_fadt->V1_firmware_ctrl);
+		ACPI_STORE_ADDRESS (local_fadt->xfirmware_ctrl,
+			local_fadt->V1_firmware_ctrl);
 	}
 
 	if (!(local_fadt->Xdsdt)) {
@@ -357,32 +381,38 @@
 
 	if (!(local_fadt->xpm1a_evt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm1a_evt_blk,
-			local_fadt->pm1_evt_len, (acpi_physical_address) local_fadt->V1_pm1a_evt_blk);
+			local_fadt->pm1_evt_len,
+			(acpi_physical_address) local_fadt->V1_pm1a_evt_blk);
 	}
 
 	if (!(local_fadt->xpm1b_evt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm1b_evt_blk,
-			local_fadt->pm1_evt_len, (acpi_physical_address) local_fadt->V1_pm1b_evt_blk);
+			local_fadt->pm1_evt_len,
+			(acpi_physical_address) local_fadt->V1_pm1b_evt_blk);
 	}
 
 	if (!(local_fadt->xpm1a_cnt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm1a_cnt_blk,
-			local_fadt->pm1_cnt_len, (acpi_physical_address) local_fadt->V1_pm1a_cnt_blk);
+			local_fadt->pm1_cnt_len,
+			(acpi_physical_address) local_fadt->V1_pm1a_cnt_blk);
 	}
 
 	if (!(local_fadt->xpm1b_cnt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm1b_cnt_blk,
-			local_fadt->pm1_cnt_len, (acpi_physical_address) local_fadt->V1_pm1b_cnt_blk);
+			local_fadt->pm1_cnt_len,
+			(acpi_physical_address) local_fadt->V1_pm1b_cnt_blk);
 	}
 
 	if (!(local_fadt->xpm2_cnt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm2_cnt_blk,
-			local_fadt->pm2_cnt_len, (acpi_physical_address) local_fadt->V1_pm2_cnt_blk);
+			local_fadt->pm2_cnt_len,
+			(acpi_physical_address) local_fadt->V1_pm2_cnt_blk);
 	}
 
 	if (!(local_fadt->xpm_tmr_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm_tmr_blk,
-			local_fadt->pm_tm_len, (acpi_physical_address) local_fadt->V1_pm_tmr_blk);
+			local_fadt->pm_tm_len,
+			(acpi_physical_address) local_fadt->V1_pm_tmr_blk);
 	}
 
 	if (!(local_fadt->xgpe0_blk.address)) {
@@ -399,18 +429,24 @@
 
 	acpi_tb_init_generic_address (&acpi_gbl_xpm1a_enable,
 		(u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
-		(acpi_physical_address) (local_fadt->xpm1a_evt_blk.address +
+		(acpi_physical_address)
+			(local_fadt->xpm1a_evt_blk.address +
 			ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
-	acpi_gbl_xpm1a_enable.address_space_id = local_fadt->xpm1a_evt_blk.address_space_id;
+
+	acpi_gbl_xpm1a_enable.address_space_id =
+		local_fadt->xpm1a_evt_blk.address_space_id;
 
 	/* PM1B is optional; leave null if not present */
 
 	if (local_fadt->xpm1b_evt_blk.address) {
 		acpi_tb_init_generic_address (&acpi_gbl_xpm1b_enable,
 			(u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
-			(acpi_physical_address) (local_fadt->xpm1b_evt_blk.address +
+			(acpi_physical_address)
+				(local_fadt->xpm1b_evt_blk.address +
 				ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
-		acpi_gbl_xpm1b_enable.address_space_id = local_fadt->xpm1b_evt_blk.address_space_id;
+
+		acpi_gbl_xpm1b_enable.address_space_id =
+			local_fadt->xpm1b_evt_blk.address_space_id;
 	}
 }
 
@@ -432,7 +468,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_tb_convert_table_fadt (void)
+acpi_tb_convert_table_fadt (
+	void)
 {
 	struct fadt_descriptor_rev2    *local_fadt;
 	struct acpi_table_desc         *table_desc;
@@ -446,7 +483,8 @@
 	 * at least as long as the version 1.0 FADT
 	 */
 	if (acpi_gbl_FADT->length < sizeof (struct fadt_descriptor_rev1)) {
-		ACPI_REPORT_ERROR (("FADT is invalid, too short: 0x%X\n", acpi_gbl_FADT->length));
+		ACPI_REPORT_ERROR (("FADT is invalid, too short: 0x%X\n",
+			acpi_gbl_FADT->length));
 		return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
 	}
 
@@ -461,8 +499,9 @@
 		if (acpi_gbl_FADT->length < sizeof (struct fadt_descriptor_rev2)) {
 			/* Length is too short to be a V2.0 table */
 
-			ACPI_REPORT_WARNING (("Inconsistent FADT length (0x%X) and revision (0x%X), using FADT V1.0 portion of table\n",
-					 acpi_gbl_FADT->length, acpi_gbl_FADT->revision));
+			ACPI_REPORT_WARNING ((
+				"Inconsistent FADT length (0x%X) and revision (0x%X), using FADT V1.0 portion of table\n",
+				acpi_gbl_FADT->length, acpi_gbl_FADT->revision));
 
 			acpi_tb_convert_fadt1 (local_fadt, (void *) acpi_gbl_FADT);
 		}
@@ -478,9 +517,8 @@
 		acpi_tb_convert_fadt1 (local_fadt, (void *) acpi_gbl_FADT);
 	}
 
-	/*
-	 * Global FADT pointer will point to the new common V2.0 FADT
-	 */
+	/* Global FADT pointer will point to the new common V2.0 FADT */
+
 	acpi_gbl_FADT = local_fadt;
 	acpi_gbl_FADT->length = sizeof (FADT_DESCRIPTOR);
 
@@ -508,7 +546,7 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_convert_table_facs
+ * FUNCTION:    acpi_tb_build_common_facs
  *
  * PARAMETERS:  table_info      - Info for currently installed FACS
  *
@@ -530,12 +568,14 @@
 	/* Absolute minimum length is 24, but the ACPI spec says 64 */
 
 	if (acpi_gbl_FACS->length < 24) {
-		ACPI_REPORT_ERROR (("Invalid FACS table length: 0x%X\n", acpi_gbl_FACS->length));
+		ACPI_REPORT_ERROR (("Invalid FACS table length: 0x%X\n",
+			acpi_gbl_FACS->length));
 		return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
 	}
 
 	if (acpi_gbl_FACS->length < 64) {
-		ACPI_REPORT_WARNING (("FACS is shorter than the ACPI specification allows: 0x%X, using anyway\n",
+		ACPI_REPORT_WARNING ((
+			"FACS is shorter than the ACPI specification allows: 0x%X, using anyway\n",
 			acpi_gbl_FACS->length));
 	}
 
@@ -548,7 +588,8 @@
 		(!(acpi_gbl_FACS->xfirmware_waking_vector))) {
 		/* ACPI 1.0 FACS or short table or optional X_ field is zero */
 
-		acpi_gbl_common_fACS.firmware_waking_vector = ACPI_CAST_PTR (u64, &(acpi_gbl_FACS->firmware_waking_vector));
+		acpi_gbl_common_fACS.firmware_waking_vector = ACPI_CAST_PTR (u64,
+				&(acpi_gbl_FACS->firmware_waking_vector));
 		acpi_gbl_common_fACS.vector_width = 32;
 	}
 	else {
diff -Nru a/drivers/acpi/tables/tbget.c b/drivers/acpi/tables/tbget.c
--- a/drivers/acpi/tables/tbget.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/tables/tbget.c	2005-04-19 01:34:14 -04:00
@@ -49,6 +49,19 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbget")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_tb_get_this_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info);
+
+static acpi_status
+acpi_tb_table_override (
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info);
+
 
 /*******************************************************************************
  *
@@ -76,9 +89,8 @@
 	ACPI_FUNCTION_TRACE ("tb_get_table");
 
 
-	/*
-	 * Get the header in order to get signature and table size
-	 */
+	/* Get the header in order to get signature and table size */
+
 	status = acpi_tb_get_table_header (address, &header);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -127,8 +139,8 @@
 
 
 	/*
-	 * Flags contains the current processor mode (Virtual or Physical addressing)
-	 * The pointer_type is either Logical or Physical
+	 * Flags contains the current processor mode (Virtual or Physical
+	 * addressing) The pointer_type is either Logical or Physical
 	 */
 	switch (address->pointer_type) {
 	case ACPI_PHYSMODE_PHYSPTR:
@@ -136,7 +148,8 @@
 
 		/* Pointer matches processor mode, copy the header */
 
-		ACPI_MEMCPY (return_header, address->pointer.logical, sizeof (struct acpi_table_header));
+		ACPI_MEMCPY (return_header, address->pointer.logical,
+			sizeof (struct acpi_table_header));
 		break;
 
 
@@ -144,10 +157,11 @@
 
 		/* Create a logical address for the physical pointer*/
 
-		status = acpi_os_map_memory (address->pointer.physical, sizeof (struct acpi_table_header),
-				  (void *) &header);
+		status = acpi_os_map_memory (address->pointer.physical,
+				 sizeof (struct acpi_table_header), (void *) &header);
 		if (ACPI_FAILURE (status)) {
-			ACPI_REPORT_ERROR (("Could not map memory at %8.8X%8.8X for length %X\n",
+			ACPI_REPORT_ERROR ((
+				"Could not map memory at %8.8X%8.8X for length %X\n",
 				ACPI_FORMAT_UINT64 (address->pointer.physical),
 				sizeof (struct acpi_table_header)));
 			return_ACPI_STATUS (status);
@@ -210,9 +224,8 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Attempt table override.
-	 */
+	/* Attempt table override. */
+
 	status = acpi_tb_table_override (header, table_info);
 	if (ACPI_SUCCESS (status)) {
 		/* Table was overridden by the host OS */
@@ -241,7 +254,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_table_override (
 	struct acpi_table_header        *header,
 	struct acpi_table_desc          *table_info)
@@ -315,7 +328,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_get_this_table (
 	struct acpi_pointer             *address,
 	struct acpi_table_header        *header,
@@ -330,8 +343,8 @@
 
 
 	/*
-	 * Flags contains the current processor mode (Virtual or Physical addressing)
-	 * The pointer_type is either Logical or Physical
+	 * Flags contains the current processor mode (Virtual or Physical
+	 * addressing) The pointer_type is either Logical or Physical
 	 */
 	switch (address->pointer_type) {
 	case ACPI_PHYSMODE_PHYSPTR:
@@ -341,7 +354,8 @@
 
 		full_table = ACPI_MEM_ALLOCATE (header->length);
 		if (!full_table) {
-			ACPI_REPORT_ERROR (("Could not allocate table memory for [%4.4s] length %X\n",
+			ACPI_REPORT_ERROR ((
+				"Could not allocate table memory for [%4.4s] length %X\n",
 				header->signature, header->length));
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
@@ -362,12 +376,14 @@
 		 * Just map the table's physical memory
 		 * into our address space.
 		 */
-		status = acpi_os_map_memory (address->pointer.physical, (acpi_size) header->length,
-				  (void *) &full_table);
+		status = acpi_os_map_memory (address->pointer.physical,
+				 (acpi_size) header->length, (void *) &full_table);
 		if (ACPI_FAILURE (status)) {
-			ACPI_REPORT_ERROR (("Could not map memory for table [%4.4s] at %8.8X%8.8X for length %X\n",
+			ACPI_REPORT_ERROR ((
+				"Could not map memory for table [%4.4s] at %8.8X%8.8X for length %X\n",
 				header->signature,
-				ACPI_FORMAT_UINT64 (address->pointer.physical), header->length));
+				ACPI_FORMAT_UINT64 (address->pointer.physical),
+				header->length));
 			return (status);
 		}
 
@@ -465,9 +481,8 @@
 		return_ACPI_STATUS (AE_OK);
 	}
 
-	/*
-	 * Check for instance out of range
-	 */
+	/* Check for instance out of range */
+
 	if (instance > acpi_gbl_table_lists[table_type].count) {
 		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
diff -Nru a/drivers/acpi/tables/tbgetall.c b/drivers/acpi/tables/tbgetall.c
--- a/drivers/acpi/tables/tbgetall.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/tables/tbgetall.c	2005-04-19 01:34:14 -04:00
@@ -49,6 +49,19 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbgetall")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_tb_get_primary_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_desc          *table_info);
+
+static acpi_status
+acpi_tb_get_secondary_table (
+	struct acpi_pointer             *address,
+	acpi_string                     signature,
+	struct acpi_table_desc          *table_info);
+
 
 /*******************************************************************************
  *
@@ -63,7 +76,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_get_primary_table (
 	struct acpi_pointer             *address,
 	struct acpi_table_desc          *table_info)
@@ -81,9 +94,8 @@
 		return_ACPI_STATUS (AE_OK);
 	}
 
-	/*
-	 * Get the header in order to get signature and table size
-	 */
+	/* Get the header in order to get signature and table size */
+
 	status = acpi_tb_get_table_header (address, &header);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -130,7 +142,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_get_secondary_table (
 	struct acpi_pointer             *address,
 	acpi_string                     signature,
@@ -153,7 +165,8 @@
 	/* Signature must match request */
 
 	if (ACPI_STRNCMP (header.signature, signature, ACPI_NAME_SIZE)) {
-		ACPI_REPORT_ERROR (("Incorrect table signature - wanted [%s] found [%4.4s]\n",
+		ACPI_REPORT_ERROR ((
+			"Incorrect table signature - wanted [%s] found [%4.4s]\n",
 			signature, header.signature));
 		return_ACPI_STATUS (AE_BAD_SIGNATURE);
 	}
@@ -230,7 +243,8 @@
 	for (i = 0; i < acpi_gbl_rsdt_table_count; i++) {
 		/* Get the table address from the common internal XSDT */
 
-		address.pointer.value = acpi_gbl_XSDT->table_offset_entry[i];
+		address.pointer.value =
+				  acpi_gbl_XSDT->table_offset_entry[i];
 
 		/*
 		 * Get the tables needed by this subsystem (FADT and any SSDTs).
@@ -252,18 +266,18 @@
 	}
 
 	/*
-	 * Convert the FADT to a common format.  This allows earlier revisions of the
-	 * table to coexist with newer versions, using common access code.
+	 * Convert the FADT to a common format.  This allows earlier revisions of
+	 * the table to coexist with newer versions, using common access code.
 	 */
 	status = acpi_tb_convert_table_fadt ();
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not convert FADT to internal common format\n"));
+		ACPI_REPORT_ERROR ((
+			"Could not convert FADT to internal common format\n"));
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Get the FACS (Pointed to by the FADT)
-	 */
+	/* Get the FACS (Pointed to by the FADT) */
+
 	address.pointer.value = acpi_gbl_FADT->xfirmware_ctrl;
 
 	status = acpi_tb_get_secondary_table (&address, FACS_SIG, &table_info);
@@ -282,9 +296,8 @@
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Get/install the DSDT (Pointed to by the FADT)
-	 */
+	/* Get/install the DSDT (Pointed to by the FADT) */
+
 	address.pointer.value = acpi_gbl_FADT->Xdsdt;
 
 	status = acpi_tb_get_secondary_table (&address, DSDT_SIG, &table_info);
diff -Nru a/drivers/acpi/tables/tbinstal.c b/drivers/acpi/tables/tbinstal.c
--- a/drivers/acpi/tables/tbinstal.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/tables/tbinstal.c	2005-04-19 01:34:14 -04:00
@@ -49,6 +49,14 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbinstal")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_tb_match_signature (
+	char                            *signature,
+	struct acpi_table_desc          *table_info,
+	u8                              search_type);
+
 
 /*******************************************************************************
  *
@@ -56,6 +64,7 @@
  *
  * PARAMETERS:  Signature           - Table signature to match
  *              table_info          - Return data
+ *              search_type         - Table type to match (primary/secondary)
  *
  * RETURN:      Status
  *
@@ -64,7 +73,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_match_signature (
 	char                            *signature,
 	struct acpi_table_desc          *table_info,
@@ -76,9 +85,8 @@
 	ACPI_FUNCTION_TRACE ("tb_match_signature");
 
 
-	/*
-	 * Search for a signature match among the known table types
-	 */
+	/* Search for a signature match among the known table types */
+
 	for (i = 0; i < NUM_ACPI_TABLE_TYPES; i++) {
 		if (!(acpi_gbl_table_data[i].flags & search_type)) {
 			continue;
@@ -161,6 +169,7 @@
  * FUNCTION:    acpi_tb_recognize_table
  *
  * PARAMETERS:  table_info          - Return value from acpi_tb_get_table_body
+ *              search_type         - Table type to match (primary/secondary)
  *
  * RETURN:      Status
  *
@@ -203,7 +212,8 @@
 	 * This can be any one of many valid ACPI tables, it just isn't one of
 	 * the tables that is consumed by the core subsystem
 	 */
-	status = acpi_tb_match_signature (table_header->signature, table_info, search_type);
+	status = acpi_tb_match_signature (table_header->signature,
+			 table_info, search_type);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -253,9 +263,8 @@
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	/*
-	 * Install the table into the global data structure
-	 */
+	/* Install the table into the global data structure */
+
 	list_head = &acpi_gbl_table_lists[table_type];
 
 	/*
@@ -316,7 +325,8 @@
 	table_desc->aml_start           = (u8 *) (table_desc->pointer + 1),
 	table_desc->aml_length          = (u32) (table_desc->length -
 			 (u32) sizeof (struct acpi_table_header));
-	table_desc->table_id            = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_TABLE);
+	table_desc->table_id            = acpi_ut_allocate_owner_id (
+			 ACPI_OWNER_TYPE_TABLE);
 	table_desc->loaded_into_namespace = FALSE;
 
 	/*
@@ -349,7 +359,8 @@
  ******************************************************************************/
 
 void
-acpi_tb_delete_all_tables (void)
+acpi_tb_delete_all_tables (
+	void)
 {
 	acpi_table_type                 type;
 
diff -Nru a/drivers/acpi/tables/tbrsdt.c b/drivers/acpi/tables/tbrsdt.c
--- a/drivers/acpi/tables/tbrsdt.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/tables/tbrsdt.c	2005-04-19 01:34:14 -04:00
@@ -84,8 +84,9 @@
 		/*
 		 * Obtain access to the RSDP structure
 		 */
-		status = acpi_os_map_memory (address->pointer.physical, sizeof (struct rsdp_descriptor),
-				  (void *) &rsdp);
+		status = acpi_os_map_memory (address->pointer.physical,
+				 sizeof (struct rsdp_descriptor),
+						   (void *) &rsdp);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -154,9 +155,9 @@
  *
  * FUNCTION:    acpi_tb_get_rsdt_address
  *
- * PARAMETERS:  None
+ * PARAMETERS:  out_address         - Where the address is returned
  *
- * RETURN:      RSDT physical address
+ * RETURN:      None, Address
  *
  * DESCRIPTION: Extract the address of the RSDT or XSDT, depending on the
  *              version of the RSDP
@@ -181,7 +182,8 @@
 		out_address->pointer.value = acpi_gbl_RSDP->rsdt_physical_address;
 	}
 	else {
-		out_address->pointer.value = acpi_gbl_RSDP->xsdt_physical_address;
+		out_address->pointer.value =
+			acpi_gbl_RSDP->xsdt_physical_address;
 	}
 }
 
@@ -224,7 +226,8 @@
 	if (no_match) {
 		/* Invalid RSDT or XSDT signature */
 
-		ACPI_REPORT_ERROR (("Invalid signature where RSDP indicates RSDT/XSDT should be located\n"));
+		ACPI_REPORT_ERROR ((
+			"Invalid signature where RSDP indicates RSDT/XSDT should be located\n"));
 
 		ACPI_DUMP_BUFFER (acpi_gbl_RSDP, 20);
 
@@ -282,6 +285,7 @@
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not get the RSDT/XSDT, %s\n",
 			acpi_format_exception (status)));
+
 		return_ACPI_STATUS (status);
 	}
 
@@ -299,7 +303,8 @@
 
 	/* Get the number of tables defined in the RSDT or XSDT */
 
-	acpi_gbl_rsdt_table_count = acpi_tb_get_table_count (acpi_gbl_RSDP, table_info.pointer);
+	acpi_gbl_rsdt_table_count = acpi_tb_get_table_count (acpi_gbl_RSDP,
+			  table_info.pointer);
 
 	/* Convert and/or copy to an XSDT structure */
 
diff -Nru a/drivers/acpi/tables/tbutils.c b/drivers/acpi/tables/tbutils.c
--- a/drivers/acpi/tables/tbutils.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/tables/tbutils.c	2005-04-19 01:34:14 -04:00
@@ -49,48 +49,14 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbutils")
 
+/* Local prototypes */
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_handle_to_object
- *
- * PARAMETERS:  table_id            - Id for which the function is searching
- *              table_desc          - Pointer to return the matching table
- *                                      descriptor.
- *
- * RETURN:      Search the tables to find one with a matching table_id and
- *              return a pointer to that table descriptor.
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
+#ifdef ACPI_OBSOLETE_FUNCTIONS
 acpi_status
 acpi_tb_handle_to_object (
 	u16                             table_id,
-	struct acpi_table_desc          **return_table_desc)
-{
-	u32                             i;
-	struct acpi_table_desc          *table_desc;
-
-
-	ACPI_FUNCTION_NAME ("tb_handle_to_object");
-
-
-	for (i = 0; i < ACPI_TABLE_MAX; i++) {
-		table_desc = acpi_gbl_table_lists[i].next;
-		while (table_desc) {
-			if (table_desc->table_id == table_id) {
-				*return_table_desc = table_desc;
-				return (AE_OK);
-			}
-
-			table_desc = table_desc->next;
-		}
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "table_id=%X does not exist\n", table_id));
-	return (AE_BAD_PARAMETER);
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
+	struct acpi_table_desc          **table_desc);
+#endif
 
 
 /*******************************************************************************
@@ -128,6 +94,7 @@
 	if (!acpi_os_readable (table_header, sizeof (struct acpi_table_header))) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Cannot read table header at %p\n", table_header));
+
 		return (AE_BAD_ADDRESS);
 	}
 
@@ -141,6 +108,7 @@
 
 		ACPI_REPORT_WARNING (("Invalid table signature found: [%4.4s]\n",
 			(char *) &signature));
+
 		ACPI_DUMP_BUFFER (table_header, sizeof (struct acpi_table_header));
 		return (AE_BAD_SIGNATURE);
 	}
@@ -154,6 +122,7 @@
 
 		ACPI_REPORT_WARNING (("Invalid table header length (0x%X) found\n",
 			(u32) table_header->length));
+
 		ACPI_DUMP_BUFFER (table_header, sizeof (struct acpi_table_header));
 		return (AE_BAD_HEADER);
 	}
@@ -193,8 +162,10 @@
 	/* Return the appropriate exception */
 
 	if (checksum) {
-		ACPI_REPORT_WARNING (("Invalid checksum in table [%4.4s] (%02X, sum %02X is not zero)\n",
-			table_header->signature, (u32) table_header->checksum, (u32) checksum));
+		ACPI_REPORT_WARNING ((
+			"Invalid checksum in table [%4.4s] (%02X, sum %02X is not zero)\n",
+			table_header->signature, (u32) table_header->checksum,
+			(u32) checksum));
 
 		status = AE_BAD_CHECKSUM;
 	}
@@ -209,7 +180,7 @@
  * PARAMETERS:  Buffer              - Buffer to checksum
  *              Length              - Size of the buffer
  *
- * RETURNS      8 bit checksum of buffer
+ * RETURN:      8 bit checksum of buffer
  *
  * DESCRIPTION: Computes an 8 bit checksum of the buffer(length) and returns it.
  *
@@ -236,5 +207,49 @@
 	}
 	return (sum);
 }
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_handle_to_object
+ *
+ * PARAMETERS:  table_id            - Id for which the function is searching
+ *              table_desc          - Pointer to return the matching table
+ *                                      descriptor.
+ *
+ * RETURN:      Search the tables to find one with a matching table_id and
+ *              return a pointer to that table descriptor.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_handle_to_object (
+	u16                             table_id,
+	struct acpi_table_desc          **return_table_desc)
+{
+	u32                             i;
+	struct acpi_table_desc          *table_desc;
+
+
+	ACPI_FUNCTION_NAME ("tb_handle_to_object");
+
+
+	for (i = 0; i < ACPI_TABLE_MAX; i++) {
+		table_desc = acpi_gbl_table_lists[i].next;
+		while (table_desc) {
+			if (table_desc->table_id == table_id) {
+				*return_table_desc = table_desc;
+				return (AE_OK);
+			}
+
+			table_desc = table_desc->next;
+		}
+	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "table_id=%X does not exist\n", table_id));
+	return (AE_BAD_PARAMETER);
+}
+#endif
 
 
diff -Nru a/drivers/acpi/tables/tbxface.c b/drivers/acpi/tables/tbxface.c
--- a/drivers/acpi/tables/tbxface.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/tables/tbxface.c	2005-04-19 01:34:14 -04:00
@@ -67,7 +67,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_load_tables (void)
+acpi_load_tables (
+	void)
 {
 	struct acpi_pointer             rsdp_address;
 	acpi_status                     status;
@@ -82,7 +83,7 @@
 			  &rsdp_address);
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("acpi_load_tables: Could not get RSDP, %s\n",
-				  acpi_format_exception (status)));
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
@@ -93,7 +94,7 @@
 	status = acpi_tb_verify_rsdp (&rsdp_address);
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("acpi_load_tables: RSDP Failed validation: %s\n",
-				  acpi_format_exception (status)));
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
@@ -102,7 +103,7 @@
 	status = acpi_tb_get_table_rsdt ();
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("acpi_load_tables: Could not load RSDT: %s\n",
-				  acpi_format_exception (status)));
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
@@ -110,20 +111,20 @@
 
 	status = acpi_tb_get_required_tables ();
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("acpi_load_tables: Error getting required tables (DSDT/FADT/FACS): %s\n",
-				  acpi_format_exception (status)));
+		ACPI_REPORT_ERROR ((
+			"acpi_load_tables: Error getting required tables (DSDT/FADT/FACS): %s\n",
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "ACPI Tables successfully acquired\n"));
 
-
 	/* Load the namespace from the tables */
 
 	status = acpi_ns_load_namespace ();
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("acpi_load_tables: Could not load namespace: %s\n",
-				  acpi_format_exception (status)));
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
@@ -139,7 +140,6 @@
 
 
 #ifdef ACPI_FUTURE_USAGE
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_load_table
@@ -250,7 +250,6 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* Find all tables of the requested type */
 
 	table_desc = acpi_gbl_table_lists[table_type].next;
@@ -321,7 +320,6 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* Get a pointer to the entire table */
 
 	status = acpi_tb_get_table_ptr (table_type, instance, &tbl_ptr);
@@ -329,23 +327,20 @@
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * The function will return a NULL pointer if the table is not loaded
-	 */
+	/* The function will return a NULL pointer if the table is not loaded */
+
 	if (tbl_ptr == NULL) {
 		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
-	/*
-	 * Copy the header to the caller's buffer
-	 */
+	/* Copy the header to the caller's buffer */
+
 	ACPI_MEMCPY ((void *) out_table_header, (void *) tbl_ptr,
-			 sizeof (struct acpi_table_header));
+		sizeof (struct acpi_table_header));
 
 	return_ACPI_STATUS (status);
 }
 
-
 #endif  /*  ACPI_FUTURE_USAGE  */
 
 /*******************************************************************************
@@ -404,7 +399,6 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* Get a pointer to the entire table */
 
 	status = acpi_tb_get_table_ptr (table_type, instance, &tbl_ptr);
@@ -423,9 +417,8 @@
 	/* Get the table length */
 
 	if (table_type == ACPI_TABLE_RSDP) {
-		/*
-		 *  RSD PTR is the only "table" without a header
-		 */
+		/* RSD PTR is the only "table" without a header */
+
 		table_length = sizeof (struct rsdp_descriptor);
 	}
 	else {
diff -Nru a/drivers/acpi/tables/tbxfroot.c b/drivers/acpi/tables/tbxfroot.c
--- a/drivers/acpi/tables/tbxfroot.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/tables/tbxfroot.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,18 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbxfroot")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_tb_find_rsdp (
+	struct acpi_table_desc          *table_info,
+	u32                             flags);
+
+static u8 *
+acpi_tb_scan_memory_for_rsdp (
+	u8                              *start_address,
+	u32                             length);
+
 
 /*******************************************************************************
  *
@@ -57,7 +69,8 @@
  *
  * PARAMETERS:  Signature           - String with ACPI table signature
  *              oem_id              - String with the table OEM ID
- *              oem_table_id        - String with the OEM Table ID.
+ *              oem_table_id        - String with the OEM Table ID
+ *              table_ptr           - Where the table pointer is returned
  *
  * RETURN:      Status
  *
@@ -99,14 +112,13 @@
 		if (!acpi_gbl_DSDT) {
 			return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 		}
-
 		table = acpi_gbl_DSDT;
 	}
 	else {
 		/* Find the table */
 
 		status = acpi_get_firmware_table (signature, 1,
-				   ACPI_LOGICAL_ADDRESSING, &table);
+				 ACPI_LOGICAL_ADDRESSING, &table);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -114,14 +126,19 @@
 
 	/* Check oem_id and oem_table_id */
 
-	if ((oem_id[0]     && ACPI_STRNCMP (
-			 oem_id, table->oem_id, sizeof (table->oem_id))) ||
+	if ((oem_id[0] && ACPI_STRNCMP (
+			   oem_id, table->oem_id,
+			   sizeof (table->oem_id))) ||
+
 		(oem_table_id[0] && ACPI_STRNCMP (
-				   oem_table_id, table->oem_table_id, sizeof (table->oem_table_id)))) {
+				   oem_table_id, table->oem_table_id,
+				   sizeof (table->oem_table_id)))) {
 		return_ACPI_STATUS (AE_AML_NAME_NOT_FOUND);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "Found table [%4.4s]\n", table->signature));
+	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "Found table [%4.4s]\n",
+		table->signature));
+
 	*table_ptr = table;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -191,8 +208,8 @@
 		/* Map and validate the RSDP */
 
 		if ((flags & ACPI_MEMORY_MODE) == ACPI_LOGICAL_ADDRESSING) {
-			status = acpi_os_map_memory (address.pointer.physical, sizeof (struct rsdp_descriptor),
-					  (void *) &acpi_gbl_RSDP);
+			status = acpi_os_map_memory (address.pointer.physical,
+					 sizeof (struct rsdp_descriptor), (void *) &acpi_gbl_RSDP);
 			if (ACPI_FAILURE (status)) {
 				return_ACPI_STATUS (status);
 			}
@@ -203,7 +220,8 @@
 
 		/* The signature and checksum must both be correct */
 
-		if (ACPI_STRNCMP ((char *) acpi_gbl_RSDP, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
+		if (ACPI_STRNCMP ((char *) acpi_gbl_RSDP, RSDP_SIG,
+				sizeof (RSDP_SIG)-1) != 0) {
 			/* Nope, BAD Signature */
 
 			return_ACPI_STATUS (AE_BAD_SIGNATURE);
@@ -313,7 +331,8 @@
 
 
 cleanup:
-	acpi_os_unmap_memory (rsdt_info->pointer, (acpi_size) rsdt_info->pointer->length);
+	acpi_os_unmap_memory (rsdt_info->pointer,
+		(acpi_size) rsdt_info->pointer->length);
 	ACPI_MEM_FREE (rsdt_info);
 
 	if (header) {
@@ -335,8 +354,8 @@
  *
  * FUNCTION:    acpi_find_root_pointer
  *
- * PARAMETERS:  **rsdp_address          - Where to place the RSDP address
- *              Flags                   - Logical/Physical addressing
+ * PARAMETERS:  Flags                   - Logical/Physical addressing
+ *              rsdp_address            - Where to place the RSDP address
  *
  * RETURN:      Status, Physical address of the RSDP
  *
@@ -363,6 +382,7 @@
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"RSDP structure not found, %s Flags=%X\n",
 			acpi_format_exception (status), flags));
+
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
 
@@ -385,7 +405,7 @@
  *
  ******************************************************************************/
 
-u8 *
+static u8 *
 acpi_tb_scan_memory_for_rsdp (
 	u8                              *start_address,
 	u32                             length)
@@ -406,7 +426,8 @@
 		 mem_rover += ACPI_RSDP_SCAN_STEP) {
 		/* The signature and checksum must both be correct */
 
-		if (ACPI_STRNCMP ((char *) mem_rover, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
+		if (ACPI_STRNCMP ((char *) mem_rover,
+				RSDP_SIG, sizeof (RSDP_SIG) - 1) != 0) {
 			/* No signature match, keep looking */
 
 			continue;
@@ -450,7 +471,7 @@
  *
  * FUNCTION:    acpi_tb_find_rsdp
  *
- * PARAMETERS:  *table_info             - Where the table info is returned
+ * PARAMETERS:  table_info              - Where the table info is returned
  *              Flags                   - Current memory mode (logical vs.
  *                                        physical addressing)
  *
@@ -468,7 +489,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_find_rsdp (
 	struct acpi_table_desc          *table_info,
 	u32                             flags)
@@ -483,43 +504,49 @@
 
 
 	/*
-	 * Scan supports either 1) Logical addressing or 2) Physical addressing
+	 * Scan supports either logical addressing or physical addressing
 	 */
 	if ((flags & ACPI_MEMORY_MODE) == ACPI_LOGICAL_ADDRESSING) {
-		/*
-		 * 1a) Get the location of the EBDA
-		 */
-		status = acpi_os_map_memory ((acpi_physical_address) ACPI_EBDA_PTR_LOCATION,
-				  ACPI_EBDA_PTR_LENGTH,
-				  (void *) &table_ptr);
+		/* 1a) Get the location of the Extended BIOS Data Area (EBDA) */
+
+		status = acpi_os_map_memory (
+				 (acpi_physical_address) ACPI_EBDA_PTR_LOCATION,
+				 ACPI_EBDA_PTR_LENGTH, (void *) &table_ptr);
 		if (ACPI_FAILURE (status)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Could not map memory at %8.8X for length %X\n",
 				ACPI_EBDA_PTR_LOCATION, ACPI_EBDA_PTR_LENGTH));
+
 			return_ACPI_STATUS (status);
 		}
 
 		ACPI_MOVE_16_TO_32 (&physical_address, table_ptr);
-		physical_address <<= 4;                 /* Convert segment to physical address */
+
+		/* Convert segment part to physical address */
+
+		physical_address <<= 4;
 		acpi_os_unmap_memory (table_ptr, ACPI_EBDA_PTR_LENGTH);
 
 		/* EBDA present? */
 
 		if (physical_address > 0x400) {
 			/*
-			 * 1b) Search EBDA paragraphs (EBDa is required to be a minimum of 1_k length)
+			 * 1b) Search EBDA paragraphs (EBDa is required to be a
+			 *     minimum of 1_k length)
 			 */
-			status = acpi_os_map_memory ((acpi_physical_address) physical_address,
-					  ACPI_EBDA_WINDOW_SIZE,
-					  (void *) &table_ptr);
+			status = acpi_os_map_memory (
+					 (acpi_physical_address) physical_address,
+					 ACPI_EBDA_WINDOW_SIZE, (void *) &table_ptr);
 			if (ACPI_FAILURE (status)) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 					"Could not map memory at %8.8X for length %X\n",
 					physical_address, ACPI_EBDA_WINDOW_SIZE));
+
 				return_ACPI_STATUS (status);
 			}
 
-			mem_rover = acpi_tb_scan_memory_for_rsdp (table_ptr, ACPI_EBDA_WINDOW_SIZE);
+			mem_rover = acpi_tb_scan_memory_for_rsdp (table_ptr,
+					  ACPI_EBDA_WINDOW_SIZE);
 			acpi_os_unmap_memory (table_ptr, ACPI_EBDA_WINDOW_SIZE);
 
 			if (mem_rover) {
@@ -527,7 +554,8 @@
 
 				physical_address += ACPI_PTR_DIFF (mem_rover, table_ptr);
 
-				table_info->physical_address = (acpi_physical_address) physical_address;
+				table_info->physical_address =
+					(acpi_physical_address) physical_address;
 				return_ACPI_STATUS (AE_OK);
 			}
 		}
@@ -535,13 +563,15 @@
 		/*
 		 * 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh
 		 */
-		status = acpi_os_map_memory ((acpi_physical_address) ACPI_HI_RSDP_WINDOW_BASE,
-				  ACPI_HI_RSDP_WINDOW_SIZE,
-				  (void *) &table_ptr);
+		status = acpi_os_map_memory (
+				 (acpi_physical_address) ACPI_HI_RSDP_WINDOW_BASE,
+				 ACPI_HI_RSDP_WINDOW_SIZE, (void *) &table_ptr);
+
 		if (ACPI_FAILURE (status)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Could not map memory at %8.8X for length %X\n",
 				ACPI_HI_RSDP_WINDOW_BASE, ACPI_HI_RSDP_WINDOW_SIZE));
+
 			return_ACPI_STATUS (status);
 		}
 
@@ -551,9 +581,11 @@
 		if (mem_rover) {
 			/* Found it, return the physical address */
 
-			physical_address = ACPI_HI_RSDP_WINDOW_BASE + ACPI_PTR_DIFF (mem_rover, table_ptr);
+			physical_address =
+				ACPI_HI_RSDP_WINDOW_BASE + ACPI_PTR_DIFF (mem_rover, table_ptr);
 
-			table_info->physical_address = (acpi_physical_address) physical_address;
+			table_info->physical_address =
+				(acpi_physical_address) physical_address;
 			return_ACPI_STATUS (AE_OK);
 		}
 	}
@@ -562,9 +594,8 @@
 	 * Physical addressing
 	 */
 	else {
-		/*
-		 * 1a) Get the location of the EBDA
-		 */
+		/* 1a) Get the location of the EBDA */
+
 		ACPI_MOVE_16_TO_32 (&physical_address, ACPI_EBDA_PTR_LOCATION);
 		physical_address <<= 4;     /* Convert segment to physical address */
 
@@ -572,9 +603,11 @@
 
 		if (physical_address > 0x400) {
 			/*
-			 * 1b) Search EBDA paragraphs (EBDa is required to be a minimum of 1_k length)
+			 * 1b) Search EBDA paragraphs (EBDa is required to be a minimum of
+			 *     1_k length)
 			 */
-			mem_rover = acpi_tb_scan_memory_for_rsdp (ACPI_PHYSADDR_TO_PTR (physical_address),
+			mem_rover = acpi_tb_scan_memory_for_rsdp (
+					  ACPI_PHYSADDR_TO_PTR (physical_address),
 					  ACPI_EBDA_WINDOW_SIZE);
 			if (mem_rover) {
 				/* Found it, return the physical address */
@@ -584,10 +617,10 @@
 			}
 		}
 
-		/*
-		 * 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh
-		 */
-		mem_rover = acpi_tb_scan_memory_for_rsdp (ACPI_PHYSADDR_TO_PTR (ACPI_HI_RSDP_WINDOW_BASE),
+		/* 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh */
+
+		mem_rover = acpi_tb_scan_memory_for_rsdp (
+				  ACPI_PHYSADDR_TO_PTR (ACPI_HI_RSDP_WINDOW_BASE),
 				  ACPI_HI_RSDP_WINDOW_SIZE);
 		if (mem_rover) {
 			/* Found it, return the physical address */
diff -Nru a/drivers/acpi/toshiba_acpi.c b/drivers/acpi/toshiba_acpi.c
--- a/drivers/acpi/toshiba_acpi.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/toshiba_acpi.c	2005-04-19 01:34:14 -04:00
@@ -263,6 +263,9 @@
 	 * destination so that sscanf can be used on it safely.
 	 */
 	tmp_buffer = kmalloc(count + 1, GFP_KERNEL);
+	if(!tmp_buffer)
+		return -ENOMEM;
+
 	if (copy_from_user(tmp_buffer, buffer, count)) {
 		result = -EFAULT;
 	}
diff -Nru a/drivers/acpi/utilities/utalloc.c b/drivers/acpi/utilities/utalloc.c
--- a/drivers/acpi/utilities/utalloc.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utalloc.c	2005-04-19 01:34:14 -04:00
@@ -47,8 +47,35 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utalloc")
 
+/* Local prototypes */
 
-/******************************************************************************
+#ifdef	ACPI_DBG_TRACK_ALLOCATIONS
+static struct acpi_debug_mem_block *
+acpi_ut_find_allocation (
+	u32                             list_id,
+	void                            *allocation);
+
+static acpi_status
+acpi_ut_track_allocation (
+	u32                             list_id,
+	struct acpi_debug_mem_block     *address,
+	acpi_size                       size,
+	u8                              alloc_type,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+
+static acpi_status
+acpi_ut_remove_allocation (
+	u32                             list_id,
+	struct acpi_debug_mem_block     *address,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+#endif	/* ACPI_DBG_TRACK_ALLOCATIONS */
+
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_release_to_cache
  *
@@ -98,7 +125,8 @@
 
 		/* Put the object at the head of the cache list */
 
-		* (ACPI_CAST_INDIRECT_PTR (char, &(((char *) object)[cache_info->link_offset]))) = cache_info->list_head;
+		* (ACPI_CAST_INDIRECT_PTR (char,
+			&(((char *) object)[cache_info->link_offset]))) = cache_info->list_head;
 		cache_info->list_head = object;
 		cache_info->cache_depth++;
 
@@ -115,7 +143,7 @@
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_acquire_from_cache
  *
@@ -156,7 +184,8 @@
 		/* There is an object available, use it */
 
 		object = cache_info->list_head;
-		cache_info->list_head = *(ACPI_CAST_INDIRECT_PTR (char, &(((char *) object)[cache_info->link_offset])));
+		cache_info->list_head = *(ACPI_CAST_INDIRECT_PTR (char,
+				 &(((char *) object)[cache_info->link_offset])));
 
 		ACPI_MEM_TRACKING (cache_info->cache_hits++);
 		cache_info->cache_depth--;
@@ -201,7 +230,7 @@
 
 
 #ifdef ACPI_ENABLE_OBJECT_CACHE
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_delete_generic_cache
  *
@@ -228,7 +257,8 @@
 	while (cache_info->list_head) {
 		/* Delete one cached state object */
 
-		next = *(ACPI_CAST_INDIRECT_PTR (char, &(((char *) cache_info->list_head)[cache_info->link_offset])));
+		next = *(ACPI_CAST_INDIRECT_PTR (char,
+				 &(((char *) cache_info->list_head)[cache_info->link_offset])));
 		ACPI_MEM_FREE (cache_info->list_head);
 
 		cache_info->list_head = next;
@@ -497,8 +527,8 @@
 	acpi_status                     status;
 
 
-	allocation = acpi_ut_allocate (size + sizeof (struct acpi_debug_mem_header), component,
-			  module, line);
+	allocation = acpi_ut_allocate (size + sizeof (struct acpi_debug_mem_header),
+			  component, module, line);
 	if (!allocation) {
 		return (NULL);
 	}
@@ -543,8 +573,8 @@
 	acpi_status                     status;
 
 
-	allocation = acpi_ut_callocate (size + sizeof (struct acpi_debug_mem_header), component,
-			  module, line);
+	allocation = acpi_ut_callocate (size + sizeof (struct acpi_debug_mem_header),
+			  component, module, line);
 	if (!allocation) {
 		/* Report allocation error */
 
@@ -637,7 +667,7 @@
  *
  ******************************************************************************/
 
-struct acpi_debug_mem_block *
+static struct acpi_debug_mem_block *
 acpi_ut_find_allocation (
 	u32                             list_id,
 	void                            *allocation)
@@ -686,7 +716,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_track_allocation (
 	u32                             list_id,
 	struct acpi_debug_mem_block     *allocation,
@@ -721,10 +751,12 @@
 
 	element = acpi_ut_find_allocation (list_id, allocation);
 	if (element) {
-		ACPI_REPORT_ERROR (("ut_track_allocation: Allocation already present in list! (%p)\n",
+		ACPI_REPORT_ERROR ((
+			"ut_track_allocation: Allocation already present in list! (%p)\n",
 			allocation));
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Element %p Address %p\n", element, allocation));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Element %p Address %p\n",
+			element, allocation));
 
 		goto unlock_and_exit;
 	}
@@ -773,7 +805,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_remove_allocation (
 	u32                             list_id,
 	struct acpi_debug_mem_block     *allocation,
@@ -797,7 +829,7 @@
 		/* No allocations! */
 
 		_ACPI_REPORT_ERROR (module, line, component,
-				("ut_remove_allocation: Empty allocation list, nothing to free!\n"));
+			("ut_remove_allocation: Empty allocation list, nothing to free!\n"));
 
 		return_ACPI_STATUS (AE_OK);
 	}
@@ -824,7 +856,8 @@
 
 	ACPI_MEMSET (&allocation->user_space, 0xEA, allocation->size);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Freeing size 0%X\n", allocation->size));
+	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Freeing size 0%X\n",
+		allocation->size));
 
 	status = acpi_ut_release_mutex (ACPI_MTX_MEMORY);
 	return_ACPI_STATUS (status);
@@ -842,6 +875,7 @@
  * DESCRIPTION: Print some info about the outstanding allocations.
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 void
 acpi_ut_dump_allocation_info (
@@ -884,7 +918,8 @@
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
 			  ("%30s: %4d (%3d Kb)\n", "Max Nodes",
 			  acpi_gbl_max_concurrent_node_count,
-			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count * sizeof (struct acpi_namespace_node)))));
+			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *
+					 sizeof (struct acpi_namespace_node)))));
 */
 	return_VOID;
 }
@@ -933,26 +968,26 @@
 			descriptor = ACPI_CAST_PTR (union acpi_descriptor, &element->user_space);
 			if (descriptor->descriptor_id != ACPI_DESC_TYPE_CACHED) {
 				acpi_os_printf ("%p Len %04X %9.9s-%d [%s] ",
-						 descriptor, element->size, element->module,
-						 element->line, acpi_ut_get_descriptor_name (descriptor));
+					descriptor, element->size, element->module,
+					element->line, acpi_ut_get_descriptor_name (descriptor));
 
 				/* Most of the elements will be Operand objects. */
 
 				switch (ACPI_GET_DESCRIPTOR_TYPE (descriptor)) {
 				case ACPI_DESC_TYPE_OPERAND:
 					acpi_os_printf ("%12.12s R%hd",
-							acpi_ut_get_type_name (descriptor->object.common.type),
-							descriptor->object.common.reference_count);
+						acpi_ut_get_type_name (descriptor->object.common.type),
+						descriptor->object.common.reference_count);
 					break;
 
 				case ACPI_DESC_TYPE_PARSER:
 					acpi_os_printf ("aml_opcode %04hX",
-							descriptor->op.asl.aml_opcode);
+						descriptor->op.asl.aml_opcode);
 					break;
 
 				case ACPI_DESC_TYPE_NAMED:
 					acpi_os_printf ("%4.4s",
-							acpi_ut_get_node_name (&descriptor->node));
+						acpi_ut_get_node_name (&descriptor->node));
 					break;
 
 				default:
@@ -982,7 +1017,6 @@
 
 	return_VOID;
 }
-
 
 #endif  /* #ifdef ACPI_DBG_TRACK_ALLOCATIONS */
 
diff -Nru a/drivers/acpi/utilities/utcopy.c b/drivers/acpi/utilities/utcopy.c
--- a/drivers/acpi/utilities/utcopy.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utcopy.c	2005-04-19 01:34:14 -04:00
@@ -49,21 +49,69 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utcopy")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ut_copy_isimple_to_esimple (
+	union acpi_operand_object       *internal_object,
+	union acpi_object               *external_object,
+	u8                              *data_space,
+	acpi_size                       *buffer_space_used);
+
+static acpi_status
+acpi_ut_copy_ielement_to_ielement (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
+static acpi_status
+acpi_ut_copy_ipackage_to_epackage (
+	union acpi_operand_object       *internal_object,
+	u8                              *buffer,
+	acpi_size                       *space_used);
+
+static acpi_status
+acpi_ut_copy_esimple_to_isimple(
+	union acpi_object               *user_obj,
+	union acpi_operand_object       **return_obj);
+
+static acpi_status
+acpi_ut_copy_simple_object (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *dest_desc);
+
+static acpi_status
+acpi_ut_copy_ielement_to_eelement (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
+static acpi_status
+acpi_ut_copy_ipackage_to_ipackage (
+	union acpi_operand_object       *source_obj,
+	union acpi_operand_object       *dest_obj,
+	struct acpi_walk_state          *walk_state);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_copy_isimple_to_esimple
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are examining
- *              *Buffer             - Where the object is returned
- *              *space_used         - Where the data length is returned
+ * PARAMETERS:  internal_object     - Source object to be copied
+ *              external_object     - Where to return the copied object
+ *              data_space          - Where object data is returned (such as
+ *                                    buffer and string data)
+ *              buffer_space_used   - Length of data_space that was used
  *
  * RETURN:      Status
  *
- * DESCRIPTION: This function is called to place a simple object in a user
- *              buffer.
+ * DESCRIPTION: This function is called to copy a simple internal object to
+ *              an external object.
  *
- *              The buffer is assumed to have sufficient space for the object.
+ *              The data_space buffer is assumed to have sufficient space for
+ *              the object.
  *
  ******************************************************************************/
 
@@ -107,10 +155,12 @@
 
 		external_object->string.pointer = (char *) data_space;
 		external_object->string.length = internal_object->string.length;
-		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD ((acpi_size) internal_object->string.length + 1);
+		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (
+				   (acpi_size) internal_object->string.length + 1);
 
-		ACPI_MEMCPY ((void *) data_space, (void *) internal_object->string.pointer,
-				 (acpi_size) internal_object->string.length + 1);
+		ACPI_MEMCPY ((void *) data_space,
+			(void *) internal_object->string.pointer,
+			(acpi_size) internal_object->string.length + 1);
 		break;
 
 
@@ -118,10 +168,12 @@
 
 		external_object->buffer.pointer = data_space;
 		external_object->buffer.length = internal_object->buffer.length;
-		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (internal_object->string.length);
+		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (
+				   internal_object->string.length);
 
-		ACPI_MEMCPY ((void *) data_space, (void *) internal_object->buffer.pointer,
-				 internal_object->buffer.length);
+		ACPI_MEMCPY ((void *) data_space,
+			(void *) internal_object->buffer.pointer,
+			internal_object->buffer.length);
 		break;
 
 
@@ -194,7 +246,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_ielement_to_eelement (
 	u8                              object_type,
 	union acpi_operand_object       *source_object,
@@ -213,7 +265,7 @@
 
 	this_index   = state->pkg.index;
 	target_object = (union acpi_object *)
-			  &((union acpi_object *)(state->pkg.dest_object))->package.elements[this_index];
+		&((union acpi_object *)(state->pkg.dest_object))->package.elements[this_index];
 
 	switch (object_type) {
 	case ACPI_COPY_TYPE_SIMPLE:
@@ -236,7 +288,8 @@
 		 */
 		target_object->type             = ACPI_TYPE_PACKAGE;
 		target_object->package.count    = source_object->package.count;
-		target_object->package.elements = ACPI_CAST_PTR (union acpi_object, info->free_space);
+		target_object->package.elements =
+			ACPI_CAST_PTR (union acpi_object, info->free_space);
 
 		/*
 		 * Pass the new package object back to the package walk routine
@@ -248,7 +301,8 @@
 		 * update the buffer length counter
 		 */
 		object_space = ACPI_ROUND_UP_TO_NATIVE_WORD (
-				   (acpi_size) target_object->package.count * sizeof (union acpi_object));
+				   (acpi_size) target_object->package.count *
+				   sizeof (union acpi_object));
 		break;
 
 
@@ -266,9 +320,9 @@
  *
  * FUNCTION:    acpi_ut_copy_ipackage_to_epackage
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are returning
- *              *Buffer             - Where the object is returned
- *              *space_used         - Where the object length is returned
+ * PARAMETERS:  internal_object     - Pointer to the object we are returning
+ *              Buffer              - Where the object is returned
+ *              space_used          - Where the object length is returned
  *
  * RETURN:      Status
  *
@@ -304,13 +358,15 @@
 	 * Free space begins right after the first package
 	 */
 	info.length      = ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object));
-	info.free_space  = buffer + ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object));
+	info.free_space  = buffer + ACPI_ROUND_UP_TO_NATIVE_WORD (
+			   sizeof (union acpi_object));
 	info.object_space = 0;
 	info.num_packages = 1;
 
 	external_object->type            = ACPI_GET_OBJECT_TYPE (internal_object);
 	external_object->package.count   = internal_object->package.count;
-	external_object->package.elements = ACPI_CAST_PTR (union acpi_object, info.free_space);
+	external_object->package.elements = ACPI_CAST_PTR (union acpi_object,
+			  info.free_space);
 
 	/*
 	 * Leave room for an array of ACPI_OBJECTS in the buffer
@@ -333,8 +389,8 @@
  *
  * FUNCTION:    acpi_ut_copy_iobject_to_eobject
  *
- * PARAMETERS:  *internal_object    - The internal object to be converted
- *              *buffer_ptr         - Where the object is returned
+ * PARAMETERS:  internal_object     - The internal object to be converted
+ *              buffer_ptr          - Where the object is returned
  *
  * RETURN:      Status
  *
@@ -367,10 +423,10 @@
 		 * Build a simple object (no nested objects)
 		 */
 		status = acpi_ut_copy_isimple_to_esimple (internal_object,
-				  (union acpi_object *) ret_buffer->pointer,
-				  ((u8 *) ret_buffer->pointer +
-				  ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object))),
-				  &ret_buffer->length);
+				 (union acpi_object *) ret_buffer->pointer,
+				 ((u8 *) ret_buffer->pointer +
+				 ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object))),
+				 &ret_buffer->length);
 		/*
 		 * build simple does not include the object size in the length
 		 * so we add it in here
@@ -386,8 +442,8 @@
  *
  * FUNCTION:    acpi_ut_copy_esimple_to_isimple
  *
- * PARAMETERS:  *external_object   - The external object to be converted
- *              *internal_object   - Where the internal object is returned
+ * PARAMETERS:  external_object     - The external object to be converted
+ *              ret_internal_object - Where the internal object is returned
  *
  * RETURN:      Status
  *
@@ -398,7 +454,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_esimple_to_isimple (
 	union acpi_object               *external_object,
 	union acpi_operand_object       **ret_internal_object)
@@ -417,7 +473,8 @@
 	case ACPI_TYPE_BUFFER:
 	case ACPI_TYPE_INTEGER:
 
-		internal_object = acpi_ut_create_internal_object ((u8) external_object->type);
+		internal_object = acpi_ut_create_internal_object (
+				   (u8) external_object->type);
 		if (!internal_object) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
@@ -486,7 +543,6 @@
 
 
 #ifdef ACPI_FUTURE_IMPLEMENTATION
-
 /* Code to convert packages that are parameters to control methods */
 
 /*******************************************************************************
@@ -614,7 +670,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_simple_object (
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       *dest_desc)
@@ -724,7 +780,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_ielement_to_ielement (
 	u8                              object_type,
 	union acpi_operand_object       *source_object,
@@ -837,7 +893,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_ipackage_to_ipackage (
 	union acpi_operand_object       *source_obj,
 	union acpi_operand_object       *dest_obj,
diff -Nru a/drivers/acpi/utilities/utdebug.c b/drivers/acpi/utilities/utdebug.c
--- a/drivers/acpi/utilities/utdebug.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utdebug.c	2005-04-19 01:34:14 -04:00
@@ -56,7 +56,7 @@
 static char     *acpi_gbl_fn_exit_str = "----Exit-";
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_init_stack_ptr_trace
  *
@@ -64,9 +64,9 @@
  *
  * RETURN:      None
  *
- * DESCRIPTION: Save the current stack pointer
+ * DESCRIPTION: Save the current CPU stack pointer at subsystem startup
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_init_stack_ptr_trace (
@@ -79,7 +79,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_track_stack_ptr
  *
@@ -87,9 +87,9 @@
  *
  * RETURN:      None
  *
- * DESCRIPTION: Save the current stack pointer
+ * DESCRIPTION: Save the current CPU stack pointer
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_track_stack_ptr (
@@ -110,16 +110,16 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_debug_print
  *
- * PARAMETERS:  debug_level         - Requested debug print level
- *              proc_name           - Caller's procedure name
- *              module_name         - Caller's module name (for error output)
+ * PARAMETERS:  requested_debug_level - Requested debug print level
  *              line_number         - Caller's line number (for error output)
- *              component_id        - Caller's component ID (for error output)
- *
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *              Format              - Printf format field
  *              ...                 - Optional printf arguments
  *
@@ -128,7 +128,7 @@
  * DESCRIPTION: Print error message with prefix consisting of the module name,
  *              line number, and component ID.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void  ACPI_INTERNAL_VAR_XFACE
 acpi_ut_debug_print (
@@ -157,7 +157,8 @@
 
 	if (thread_id != acpi_gbl_prev_thread_id) {
 		if (ACPI_LV_THREADS & acpi_dbg_level) {
-			acpi_os_printf ("\n**** Context Switch from TID %X to TID %X ****\n\n",
+			acpi_os_printf (
+				"\n**** Context Switch from TID %X to TID %X ****\n\n",
 				acpi_gbl_prev_thread_id, thread_id);
 		}
 
@@ -174,15 +175,16 @@
 		acpi_os_printf ("[%04lX] ", thread_id);
 	}
 
-	acpi_os_printf ("[%02ld] %-22.22s: ", acpi_gbl_nesting_level, dbg_info->proc_name);
+	acpi_os_printf ("[%02ld] %-22.22s: ",
+		acpi_gbl_nesting_level, dbg_info->proc_name);
 
 	va_start (args, format);
 	acpi_os_vprintf (format, args);
 }
-EXPORT_SYMBOL(acpi_ut_debug_print);
 
+EXPORT_SYMBOL(acpi_ut_debug_print);
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_debug_print_raw
  *
@@ -200,7 +202,7 @@
  * DESCRIPTION: Print message with no headers.  Has same interface as
  *              debug_print so that the same macros can be used.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void  ACPI_INTERNAL_VAR_XFACE
 acpi_ut_debug_print_raw (
@@ -224,7 +226,7 @@
 EXPORT_SYMBOL(acpi_ut_debug_print_raw);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_trace
  *
@@ -239,7 +241,7 @@
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_trace (
@@ -256,7 +258,7 @@
 EXPORT_SYMBOL(acpi_ut_trace);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_trace_ptr
  *
@@ -272,7 +274,7 @@
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_trace_ptr (
@@ -288,7 +290,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_trace_str
  *
@@ -304,7 +306,7 @@
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_trace_str (
@@ -321,7 +323,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_trace_u32
  *
@@ -337,7 +339,7 @@
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_trace_u32 (
@@ -354,7 +356,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_exit
  *
@@ -369,7 +371,7 @@
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_exit (
@@ -385,7 +387,7 @@
 EXPORT_SYMBOL(acpi_ut_exit);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_status_exit
  *
@@ -401,7 +403,7 @@
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level. Prints exit status also.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_status_exit (
@@ -426,7 +428,7 @@
 EXPORT_SYMBOL(acpi_ut_status_exit);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_value_exit
  *
@@ -442,7 +444,7 @@
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level. Prints exit value also.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_value_exit (
@@ -460,7 +462,7 @@
 EXPORT_SYMBOL(acpi_ut_value_exit);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_ptr_exit
  *
@@ -469,14 +471,14 @@
  *                  proc_name           - Caller's procedure name
  *                  module_name         - Caller's module name
  *                  component_id        - Caller's component ID
- *              Value               - Value to be printed with exit msg
+ *              Ptr                 - Pointer to display
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level. Prints exit value also.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_ptr_exit (
@@ -494,7 +496,7 @@
 #endif
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_dump_buffer
  *
@@ -507,7 +509,7 @@
  *
  * DESCRIPTION: Generic dump buffer in both hex and ascii.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_dump_buffer (
@@ -533,34 +535,28 @@
 		display = DB_BYTE_DISPLAY;
 	}
 
-	acpi_os_printf ("\nOffset Value\n");
+	/* Nasty little dump buffer routine! */
 
-	/*
-	 * Nasty little dump buffer routine!
-	 */
 	while (i < count) {
 		/* Print current offset */
 
-		acpi_os_printf ("%05X  ", (u32) i);
+		acpi_os_printf ("%6.4X: ", (u32) i);
 
 		/* Print 16 hex chars */
 
 		for (j = 0; j < 16;) {
 			if (i + j >= count) {
-				acpi_os_printf ("\n");
-				return;
-			}
+				/* Dump fill spaces */
 
-			/* Make sure that the s8 doesn't get sign-extended! */
+				acpi_os_printf ("%*s", ((display * 2) + 1), " ");
+				j += display;
+				continue;
+			}
 
 			switch (display) {
-			/* Default is BYTE display */
-
-			default:
+			default:    /* Default is BYTE display */
 
-				acpi_os_printf ("%02X ",
-						*((u8 *) &buffer[i + j]));
-				j += 1;
+				acpi_os_printf ("%02X ", buffer[i + j]);
 				break;
 
 
@@ -568,7 +564,6 @@
 
 				ACPI_MOVE_16_TO_32 (&temp32, &buffer[i + j]);
 				acpi_os_printf ("%04X ", temp32);
-				j += 2;
 				break;
 
 
@@ -576,7 +571,6 @@
 
 				ACPI_MOVE_32_TO_32 (&temp32, &buffer[i + j]);
 				acpi_os_printf ("%08X ", temp32);
-				j += 4;
 				break;
 
 
@@ -587,15 +581,17 @@
 
 				ACPI_MOVE_32_TO_32 (&temp32, &buffer[i + j + 4]);
 				acpi_os_printf ("%08X ", temp32);
-				j += 8;
 				break;
 			}
+
+			j += display;
 		}
 
 		/*
 		 * Print the ASCII equivalent characters
 		 * But watch out for the bad unprintable ones...
 		 */
+		acpi_os_printf (" ");
 		for (j = 0; j < 16; j++) {
 			if (i + j >= count) {
 				acpi_os_printf ("\n");
diff -Nru a/drivers/acpi/utilities/utdelete.c b/drivers/acpi/utilities/utdelete.c
--- a/drivers/acpi/utilities/utdelete.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utdelete.c	2005-04-19 01:34:14 -04:00
@@ -51,12 +51,23 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utdelete")
 
+/* Local prototypes */
+
+static void
+acpi_ut_delete_internal_obj (
+	union acpi_operand_object       *object);
+
+static void
+acpi_ut_update_ref_count (
+	union acpi_operand_object       *object,
+	u32                             action);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_delete_internal_obj
  *
- * PARAMETERS:  *Object        - Pointer to the list to be deleted
+ * PARAMETERS:  Object         - Object to be deleted
  *
  * RETURN:      None
  *
@@ -65,7 +76,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ut_delete_internal_obj (
 	union acpi_operand_object       *object)
 {
@@ -152,7 +163,8 @@
 
 	case ACPI_TYPE_MUTEX:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Mutex %p, Semaphore %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Mutex %p, Semaphore %p\n",
 			object, object->mutex.semaphore));
 
 		acpi_ex_unlink_mutex (object);
@@ -162,7 +174,8 @@
 
 	case ACPI_TYPE_EVENT:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Event %p, Semaphore %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Event %p, Semaphore %p\n",
 			object, object->event.semaphore));
 
 		(void) acpi_os_delete_semaphore (object->event.semaphore);
@@ -172,7 +185,8 @@
 
 	case ACPI_TYPE_METHOD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Method %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Method %p\n", object));
 
 		/* Delete the method semaphore if it exists */
 
@@ -185,7 +199,8 @@
 
 	case ACPI_TYPE_REGION:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Region %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Region %p\n", object));
 
 		second_desc = acpi_ns_get_secondary_object (object);
 		if (second_desc) {
@@ -212,7 +227,8 @@
 
 	case ACPI_TYPE_BUFFER_FIELD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Buffer Field %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Buffer Field %p\n", object));
 
 		second_desc = acpi_ns_get_secondary_object (object);
 		if (second_desc) {
@@ -247,7 +263,7 @@
  *
  * FUNCTION:    acpi_ut_delete_internal_object_list
  *
- * PARAMETERS:  *obj_list       - Pointer to the list to be deleted
+ * PARAMETERS:  obj_list        - Pointer to the list to be deleted
  *
  * RETURN:      None
  *
@@ -283,7 +299,7 @@
  *
  * FUNCTION:    acpi_ut_update_ref_count
  *
- * PARAMETERS:  *Object         - Object whose ref count is to be updated
+ * PARAMETERS:  Object          - Object whose ref count is to be updated
  *              Action          - What to do
  *
  * RETURN:      New ref count
@@ -312,7 +328,8 @@
 	new_count = count;
 
 	/*
-	 * Perform the reference count action (increment, decrement, or force delete)
+	 * Perform the reference count action
+	 * (increment, decrement, or force delete)
 	 */
 	switch (action) {
 
@@ -321,7 +338,8 @@
 		new_count++;
 		object->common.reference_count = new_count;
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, [Incremented]\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"Obj %p Refs=%X, [Incremented]\n",
 			object, new_count));
 		break;
 
@@ -329,7 +347,8 @@
 	case REF_DECREMENT:
 
 		if (count < 1) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, can't decrement! (Set to 0)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+				"Obj %p Refs=%X, can't decrement! (Set to 0)\n",
 				object, new_count));
 
 			new_count = 0;
@@ -337,12 +356,14 @@
 		else {
 			new_count--;
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, [Decremented]\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+				"Obj %p Refs=%X, [Decremented]\n",
 				object, new_count));
 		}
 
 		if (ACPI_GET_OBJECT_TYPE (object) == ACPI_TYPE_METHOD) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Method Obj %p Refs=%X, [Decremented]\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+				"Method Obj %p Refs=%X, [Decremented]\n",
 				object, new_count));
 		}
 
@@ -356,7 +377,8 @@
 
 	case REF_FORCE_DELETE:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, Force delete! (Set to 0)\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"Obj %p Refs=%X, Force delete! (Set to 0)\n",
 			object, count));
 
 		new_count = 0;
@@ -390,7 +412,7 @@
  *
  * FUNCTION:    acpi_ut_update_object_reference
  *
- * PARAMETERS:  *Object             - Increment ref count for this object
+ * PARAMETERS:  Object              - Increment ref count for this object
  *                                    and all sub-objects
  *              Action              - Either REF_INCREMENT or REF_DECREMENT or
  *                                    REF_FORCE_DELETE
@@ -431,7 +453,8 @@
 	/* Make sure that this isn't a namespace handle */
 
 	if (ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_NAMED) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Object %p is NS handle\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"Object %p is NS handle\n", object));
 		return_ACPI_STATUS (AE_OK);
 	}
 
@@ -614,8 +637,8 @@
  *
  * FUNCTION:    acpi_ut_add_reference
  *
- * PARAMETERS:  *Object        - Object whose reference count is to be
- *                                  incremented
+ * PARAMETERS:  Object          - Object whose reference count is to be
+ *                                incremented
  *
  * RETURN:      None
  *
@@ -652,7 +675,7 @@
  *
  * FUNCTION:    acpi_ut_remove_reference
  *
- * PARAMETERS:  *Object        - Object whose ref count will be decremented
+ * PARAMETERS:  Object         - Object whose ref count will be decremented
  *
  * RETURN:      None
  *
diff -Nru a/drivers/acpi/utilities/uteval.c b/drivers/acpi/utilities/uteval.c
--- a/drivers/acpi/utilities/uteval.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/uteval.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,19 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("uteval")
 
+/* Local prototypes */
+
+static void
+acpi_ut_copy_id_string (
+	char                            *destination,
+	char                            *source,
+	acpi_size                       max_length);
+
+static acpi_status
+acpi_ut_translate_one_cid (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_compatible_id       *one_cid);
+
 
 /*******************************************************************************
  *
@@ -237,9 +250,9 @@
  *
  * FUNCTION:    acpi_ut_evaluate_numeric_object
  *
- * PARAMETERS:  *object_name        - Object name to be evaluated
+ * PARAMETERS:  object_name         - Object name to be evaluated
  *              device_node         - Node for the device
- *              *Address            - Where the value is returned
+ *              Address             - Where the value is returned
  *
  * RETURN:      Status
  *
@@ -303,7 +316,6 @@
 	acpi_size                       max_length)
 {
 
-
 	/*
 	 * Workaround for ID strings that have a leading asterisk. This construct
 	 * is not allowed by the ACPI specification  (ID strings must be
@@ -325,7 +337,7 @@
  * FUNCTION:    acpi_ut_execute_HID
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Hid                - Where the HID is returned
+ *              Hid                 - Where the HID is returned
  *
  * RETURN:      Status
  *
@@ -429,7 +441,7 @@
  * FUNCTION:    acpi_ut_execute_CID
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Cid                - Where the CID is returned
+ *              return_cid_list     - Where the CID list is returned
  *
  * RETURN:      Status
  *
@@ -488,10 +500,10 @@
 	cid_list->size = size;
 
 	/*
-	 *  A _CID can return either a single compatible ID or a package of compatible
-	 *  IDs.  Each compatible ID can be one of the following:
-	 *  -- Number (32 bit compressed EISA ID) or
-	 *  -- String (PCI ID format, e.g. "PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss").
+	 *  A _CID can return either a single compatible ID or a package of
+	 *  compatible IDs.  Each compatible ID can be one of the following:
+	 *  1) Integer (32 bit compressed EISA ID) or
+	 *  2) String (PCI ID format, e.g. "PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss")
 	 */
 
 	/* The _CID object can be either a single CID or a package (list) of CIDs */
@@ -534,7 +546,7 @@
  * FUNCTION:    acpi_ut_execute_UID
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Uid                - Where the UID is returned
+ *              Uid                 - Where the UID is returned
  *
  * RETURN:      Status
  *
@@ -587,7 +599,7 @@
  * FUNCTION:    acpi_ut_execute_STA
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Flags              - Where the status flags are returned
+ *              Flags               - Where the status flags are returned
  *
  * RETURN:      Status
  *
@@ -641,7 +653,7 @@
  * FUNCTION:    acpi_ut_execute_Sxds
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Flags              - Where the status flags are returned
+ *              Flags               - Where the status flags are returned
  *
  * RETURN:      Status
  *
diff -Nru a/drivers/acpi/utilities/utglobal.c b/drivers/acpi/utilities/utglobal.c
--- a/drivers/acpi/utilities/utglobal.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utglobal.c	2005-04-19 01:34:14 -04:00
@@ -44,7 +44,6 @@
 #define DEFINE_ACPI_GLOBALS
 
 #include <linux/module.h>
-
 #include <acpi/acpi.h>
 #include <acpi/acnamesp.h>
 
@@ -52,13 +51,14 @@
 	 ACPI_MODULE_NAME    ("utglobal")
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_format_exception
  *
  * PARAMETERS:  Status       - The acpi_status code to be formatted
  *
- * RETURN:      A string containing the exception  text
+ * RETURN:      A string containing the exception text. A valid pointer is
+ *              always returned.
  *
  * DESCRIPTION: This function translates an ACPI exception into an ASCII string.
  *
@@ -68,8 +68,8 @@
 acpi_format_exception (
 	acpi_status                     status)
 {
-	const char                      *exception = "UNKNOWN_STATUS_CODE";
 	acpi_status                     sub_status;
+	const char                      *exception = NULL;
 
 
 	ACPI_FUNCTION_NAME ("format_exception");
@@ -82,57 +82,55 @@
 
 		if (sub_status <= AE_CODE_ENV_MAX) {
 			exception = acpi_gbl_exception_names_env [sub_status];
-			break;
 		}
-		goto unknown;
+		break;
 
 	case AE_CODE_PROGRAMMER:
 
 		if (sub_status <= AE_CODE_PGM_MAX) {
 			exception = acpi_gbl_exception_names_pgm [sub_status -1];
-			break;
 		}
-		goto unknown;
+		break;
 
 	case AE_CODE_ACPI_TABLES:
 
 		if (sub_status <= AE_CODE_TBL_MAX) {
 			exception = acpi_gbl_exception_names_tbl [sub_status -1];
-			break;
 		}
-		goto unknown;
+		break;
 
 	case AE_CODE_AML:
 
 		if (sub_status <= AE_CODE_AML_MAX) {
 			exception = acpi_gbl_exception_names_aml [sub_status -1];
-			break;
 		}
-		goto unknown;
+		break;
 
 	case AE_CODE_CONTROL:
 
 		if (sub_status <= AE_CODE_CTRL_MAX) {
 			exception = acpi_gbl_exception_names_ctrl [sub_status -1];
-			break;
 		}
-		goto unknown;
+		break;
 
 	default:
-		goto unknown;
+		break;
 	}
 
+	if (!exception) {
+		/* Exception code was not recognized */
 
-	return ((const char *) exception);
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Unknown exception code: 0x%8.8X\n", status));
 
-unknown:
+		return ((const char *) "UNKNOWN_STATUS_CODE");
+	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown exception code: 0x%8.8X\n", status));
 	return ((const char *) exception);
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * Static global variable initialization.
  *
@@ -212,13 +210,12 @@
 };
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * Namespace globals
  *
  ******************************************************************************/
 
-
 /*
  * Predefined ACPI Names (Built-in to the Interpreter)
  *
@@ -241,9 +238,11 @@
 #if !defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
 	{"_OSI",    ACPI_TYPE_METHOD,           (char *) 1},
 #endif
-	{NULL,      ACPI_TYPE_ANY,              NULL}              /* Table terminator */
-};
 
+	/* Table terminator */
+
+	{NULL,      ACPI_TYPE_ANY,              NULL}
+};
 
 /*
  * Properties of the ACPI Object Types, both internal and external.
@@ -288,22 +287,25 @@
 /* Hex to ASCII conversion table */
 
 static const char                   acpi_gbl_hex_to_ascii[] =
-			  {'0','1','2','3','4','5','6','7',
-					 '8','9','A','B','C','D','E','F'};
+{
+	'0','1','2','3','4','5','6','7',
+	'8','9','A','B','C','D','E','F'
+};
+
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_hex_to_ascii_char
  *
  * PARAMETERS:  Integer             - Contains the hex digit
  *              Position            - bit position of the digit within the
- *                                    integer
+ *                                    integer (multiple of 4)
  *
- * RETURN:      Ascii character
+ * RETURN:      The converted Ascii character
  *
- * DESCRIPTION: Convert a hex digit to an ascii character
+ * DESCRIPTION: Convert a hex digit to an Ascii character
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 char
 acpi_ut_hex_to_ascii_char (
@@ -315,7 +317,7 @@
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * Table name globals
  *
@@ -324,7 +326,7 @@
  * that are not used by the subsystem are simply ignored.
  *
  * Do NOT add any table to this list that is not consumed directly by this
- * subsystem.
+ * subsystem (No MADT, ECDT, SBST, etc.)
  *
  ******************************************************************************/
 
@@ -391,7 +393,7 @@
 	/* ACPI_EVENT_RTC           */  {ACPI_BITREG_RT_CLOCK_STATUS,       ACPI_BITREG_RT_CLOCK_ENABLE,     ACPI_BITMASK_RT_CLOCK_STATUS,       ACPI_BITMASK_RT_CLOCK_ENABLE},
 };
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_region_name
  *
@@ -401,7 +403,7 @@
  *
  * DESCRIPTION: Translate a Space ID into a name string (Debug only)
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 /* Region type decoding */
 
@@ -429,7 +431,6 @@
 	{
 		return ("user_defined_region");
 	}
-
 	else if (space_id >= ACPI_NUM_PREDEFINED_REGIONS)
 	{
 		return ("invalid_space_id");
@@ -439,7 +440,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_event_name
  *
@@ -449,7 +450,7 @@
  *
  * DESCRIPTION: Translate a Event ID into a name string (Debug only)
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 /* Event type decoding */
 
@@ -477,7 +478,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_type_name
  *
@@ -487,20 +488,21 @@
  *
  * DESCRIPTION: Translate a Type ID into a name string (Debug only)
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 /*
  * Elements of acpi_gbl_ns_type_names below must match
  * one-to-one with values of acpi_object_type
  *
- * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching; when
- * stored in a table it really means that we have thus far seen no evidence to
- * indicate what type is actually going to be stored for this entry.
+ * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching;
+ * when stored in a table it really means that we have thus far seen no
+ * evidence to indicate what type is actually going to be stored for this entry.
  */
 static const char                   acpi_gbl_bad_type[] = "UNDEFINED";
-#define TYPE_NAME_LENGTH    12                           /* Maximum length of each string */
 
-static const char                   *acpi_gbl_ns_type_names[] = /* printable names of ACPI types */
+/* Printable names of the ACPI object types */
+
+static const char                   *acpi_gbl_ns_type_names[] =
 {
 	/* 00 */ "Untyped",
 	/* 01 */ "Integer",
@@ -564,7 +566,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_node_name
  *
@@ -574,7 +576,7 @@
  *
  * DESCRIPTION: Validate the node and return the node's ACPI name.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 char *
 acpi_ut_get_node_name (
@@ -618,7 +620,7 @@
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_descriptor_name
  *
@@ -628,9 +630,11 @@
  *
  * DESCRIPTION: Validate object and return the descriptor type
  *
- ****************************************************************************/
+ ******************************************************************************/
+
+/* Printable names of object descriptor types */
 
-static const char                   *acpi_gbl_desc_type_names[] = /* printable names of descriptor types */
+static const char                   *acpi_gbl_desc_type_names[] =
 {
 	/* 00 */ "Invalid",
 	/* 01 */ "Cached",
@@ -676,17 +680,18 @@
  * Strings and procedures used for debug only
  */
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_mutex_name
  *
- * PARAMETERS:  None.
+ * PARAMETERS:  mutex_id        - The predefined ID for this mutex.
  *
- * RETURN:      Status
+ * RETURN:      String containing the name of the mutex. Always returns a valid
+ *              pointer.
  *
  * DESCRIPTION: Translate a mutex ID into a name string (Debug only)
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 char *
 acpi_ut_get_mutex_name (
@@ -700,21 +705,20 @@
 
 	return (acpi_gbl_mutex_names[mutex_id]);
 }
-
 #endif
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_valid_object_type
  *
  * PARAMETERS:  Type            - Object type to be validated
  *
- * RETURN:      TRUE if valid object type
+ * RETURN:      TRUE if valid object type, FALSE otherwise
  *
  * DESCRIPTION: Validate an object type
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 u8
 acpi_ut_valid_object_type (
@@ -732,7 +736,7 @@
 }
 
 
-/****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_allocate_owner_id
  *
@@ -740,7 +744,10 @@
  *
  * DESCRIPTION: Allocate a table or method owner id
  *
- ***************************************************************************/
+ * NOTE: this algorithm has a wraparound problem at 64_k method invocations, and
+ *       should be revisited (TBD)
+ *
+ ******************************************************************************/
 
 acpi_owner_id
 acpi_ut_allocate_owner_id (
@@ -796,16 +803,18 @@
 }
 
 
-/****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_init_globals
  *
- * PARAMETERS:  none
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
  *
  * DESCRIPTION: Init library globals.  All globals that require specific
  *              initialization should be initialized here!
  *
- ***************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_init_globals (
diff -Nru a/drivers/acpi/utilities/utinit.c b/drivers/acpi/utilities/utinit.c
--- a/drivers/acpi/utilities/utinit.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utinit.c	2005-04-19 01:34:14 -04:00
@@ -49,19 +49,29 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utinit")
 
+/* Local prototypes */
+
+static void
+acpi_ut_fadt_register_error (
+	char                            *register_name,
+	u32                             value,
+	acpi_size                       offset);
+
+static void acpi_ut_terminate (
+	void);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_fadt_register_error
  *
- * PARAMETERS:  *register_name          - Pointer to string identifying register
+ * PARAMETERS:  register_name           - Pointer to string identifying register
  *              Value                   - Actual register contents value
- *              acpi_test_spec_section  - TDS section containing assertion
- *              acpi_assertion          - Assertion number being tested
+ *              Offset                  - Byte offset in the FADT
  *
  * RETURN:      AE_BAD_VALUE
  *
- * DESCRIPTION: Display failure message and link failure to TDS assertion
+ * DESCRIPTION: Display failure message
  *
  ******************************************************************************/
 
@@ -166,12 +176,13 @@
  *
  * RETURN:      none
  *
- * DESCRIPTION: free global memory
+ * DESCRIPTION: Free global memory
  *
  ******************************************************************************/
 
-void
-acpi_ut_terminate (void)
+static void
+acpi_ut_terminate (
+	void)
 {
 	struct acpi_gpe_block_info      *gpe_block;
 	struct acpi_gpe_block_info      *next_gpe_block;
@@ -183,8 +194,6 @@
 
 
 	/* Free global tables, etc. */
-
-
 	/* Free global GPE blocks and related info structures */
 
 	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
@@ -221,7 +230,8 @@
  ******************************************************************************/
 
 void
-acpi_ut_subsystem_shutdown (void)
+acpi_ut_subsystem_shutdown (
+	void)
 {
 
 	ACPI_FUNCTION_TRACE ("ut_subsystem_shutdown");
@@ -229,14 +239,16 @@
 	/* Just exit if subsystem is already shutdown */
 
 	if (acpi_gbl_shutdown) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "ACPI Subsystem is already terminated\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"ACPI Subsystem is already terminated\n"));
 		return_VOID;
 	}
 
 	/* Subsystem appears active, go ahead and shut it down */
 
 	acpi_gbl_shutdown = TRUE;
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Shutting down ACPI Subsystem...\n"));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"Shutting down ACPI Subsystem...\n"));
 
 	/* Close the acpi_event Handling */
 
diff -Nru a/drivers/acpi/utilities/utmath.c b/drivers/acpi/utilities/utmath.c
--- a/drivers/acpi/utilities/utmath.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utmath.c	2005-04-19 01:34:14 -04:00
@@ -259,6 +259,8 @@
  *
  * FUNCTION:    acpi_ut_short_divide, acpi_ut_divide
  *
+ * PARAMETERS:  See function headers above
+ *
  * DESCRIPTION: Native versions of the ut_divide functions. Use these if either
  *              1) The target is a 64-bit platform and therefore 64-bit
  *                 integer math is supported directly by the machine.
diff -Nru a/drivers/acpi/utilities/utmisc.c b/drivers/acpi/utilities/utmisc.c
--- a/drivers/acpi/utilities/utmisc.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utmisc.c	2005-04-19 01:34:14 -04:00
@@ -49,12 +49,57 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utmisc")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ut_create_mutex (
+	acpi_mutex_handle               mutex_id);
+
+static acpi_status
+acpi_ut_delete_mutex (
+	acpi_mutex_handle               mutex_id);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strupr (strupr)
+ *
+ * PARAMETERS:  src_string      - The source string to convert
+ *
+ * RETURN:      Converted src_string (same as input pointer)
+ *
+ * DESCRIPTION: Convert string to uppercase
+ *
+ * NOTE: This is not a POSIX function, so it appears here, not in utclib.c
+ *
+ ******************************************************************************/
+
+char *
+acpi_ut_strupr (
+	char                            *src_string)
+{
+	char                            *string;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	/* Walk entire string, uppercasing the letters */
+
+	for (string = src_string; *string; string++) {
+		*string = (char) ACPI_TOUPPER (*string);
+	}
+
+	return (src_string);
+}
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_print_string
  *
  * PARAMETERS:  String          - Null terminated ASCII string
+ *              max_length      - Maximum output length
  *
  * RETURN:      None
  *
@@ -148,6 +193,8 @@
  *
  * PARAMETERS:  Value           - Value to be converted
  *
+ * RETURN:      u32 integer with bytes swapped
+ *
  * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
  *
  ******************************************************************************/
@@ -160,7 +207,6 @@
 		u32                         value;
 		u8                          bytes[4];
 	} out;
-
 	union {
 		u32                         value;
 		u8                          bytes[4];
@@ -219,7 +265,8 @@
  *
  * FUNCTION:    acpi_ut_display_init_pathname
  *
- * PARAMETERS:  obj_handle          - Handle whose pathname will be displayed
+ * PARAMETERS:  Type                - Object type of the node
+ *              obj_handle          - Handle whose pathname will be displayed
  *              Path                - Additional path string to be appended.
  *                                      (NULL if no extra path)
  *
@@ -270,7 +317,8 @@
 
 	/* Print the object type and pathname */
 
-	acpi_os_printf ("%-12s %s", acpi_ut_get_type_name (type), (char *) buffer.pointer);
+	acpi_os_printf ("%-12s %s",
+		acpi_ut_get_type_name (type), (char *) buffer.pointer);
 
 	/* Extra path is used to append names like _STA, _INI, etc. */
 
@@ -288,9 +336,9 @@
  *
  * FUNCTION:    acpi_ut_valid_acpi_name
  *
- * PARAMETERS:  Character           - The character to be examined
+ * PARAMETERS:  Name            - The name to be examined
  *
- * RETURN:      1 if Character may appear in a name, else 0
+ * RETURN:      TRUE if the name is valid, FALSE otherwise
  *
  * DESCRIPTION: Check for a valid ACPI name.  Each character must be one of:
  *              1) Upper case alpha
@@ -495,40 +543,6 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ut_strupr
- *
- * PARAMETERS:  src_string      - The source string to convert to
- *
- * RETURN:      src_string
- *
- * DESCRIPTION: Convert string to uppercase
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-char *
-acpi_ut_strupr (
-	char                            *src_string)
-{
-	char                            *string;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	/* Walk entire string, uppercasing the letters */
-
-	for (string = src_string; *string; ) {
-		*string = (char) ACPI_TOUPPER (*string);
-		string++;
-	}
-
-	return (src_string);
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ut_mutex_initialize
  *
  * PARAMETERS:  None.
@@ -611,7 +625,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_create_mutex (
 	acpi_mutex_handle               mutex_id)
 {
@@ -648,7 +662,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_delete_mutex (
 	acpi_mutex_handle               mutex_id)
 {
@@ -715,16 +729,16 @@
 			if (acpi_gbl_mutex_info[i].owner_id == this_thread_id) {
 				if (i == mutex_id) {
 					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-							"Mutex [%s] already acquired by this thread [%X]\n",
-							acpi_ut_get_mutex_name (mutex_id), this_thread_id));
+						"Mutex [%s] already acquired by this thread [%X]\n",
+						acpi_ut_get_mutex_name (mutex_id), this_thread_id));
 
 					return (AE_ALREADY_ACQUIRED);
 				}
 
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-						"Invalid acquire order: Thread %X owns [%s], wants [%s]\n",
-						this_thread_id, acpi_ut_get_mutex_name (i),
-						acpi_ut_get_mutex_name (mutex_id)));
+					"Invalid acquire order: Thread %X owns [%s], wants [%s]\n",
+					this_thread_id, acpi_ut_get_mutex_name (i),
+					acpi_ut_get_mutex_name (mutex_id)));
 
 				return (AE_ACQUIRE_DEADLOCK);
 			}
@@ -733,22 +747,23 @@
 #endif
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX,
-			 "Thread %X attempting to acquire Mutex [%s]\n",
-			 this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
+		"Thread %X attempting to acquire Mutex [%s]\n",
+		this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
 
 	status = acpi_os_wait_semaphore (acpi_gbl_mutex_info[mutex_id].mutex,
 			   1, ACPI_WAIT_FOREVER);
 	if (ACPI_SUCCESS (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %X acquired Mutex [%s]\n",
-				 this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
+			this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
 
 		acpi_gbl_mutex_info[mutex_id].use_count++;
 		acpi_gbl_mutex_info[mutex_id].owner_id = this_thread_id;
 	}
 	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Thread %X could not acquire Mutex [%s] %s\n",
-				 this_thread_id, acpi_ut_get_mutex_name (mutex_id),
-				 acpi_format_exception (status)));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Thread %X could not acquire Mutex [%s] %s\n",
+				this_thread_id, acpi_ut_get_mutex_name (mutex_id),
+				acpi_format_exception (status)));
 	}
 
 	return (status);
@@ -793,8 +808,8 @@
 	 */
 	if (acpi_gbl_mutex_info[mutex_id].owner_id == ACPI_MUTEX_NOT_ACQUIRED) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Mutex [%s] is not acquired, cannot release\n",
-				acpi_ut_get_mutex_name (mutex_id)));
+			"Mutex [%s] is not acquired, cannot release\n",
+			acpi_ut_get_mutex_name (mutex_id)));
 
 		return (AE_NOT_ACQUIRED);
 	}
@@ -812,8 +827,8 @@
 			}
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Invalid release order: owns [%s], releasing [%s]\n",
-					acpi_ut_get_mutex_name (i), acpi_ut_get_mutex_name (mutex_id)));
+				"Invalid release order: owns [%s], releasing [%s]\n",
+				acpi_ut_get_mutex_name (i), acpi_ut_get_mutex_name (mutex_id)));
 
 			return (AE_RELEASE_DEADLOCK);
 		}
@@ -826,13 +841,14 @@
 	status = acpi_os_signal_semaphore (acpi_gbl_mutex_info[mutex_id].mutex, 1);
 
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Thread %X could not release Mutex [%s] %s\n",
-				 this_thread_id, acpi_ut_get_mutex_name (mutex_id),
-				 acpi_format_exception (status)));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Thread %X could not release Mutex [%s] %s\n",
+			this_thread_id, acpi_ut_get_mutex_name (mutex_id),
+			acpi_format_exception (status)));
 	}
 	else {
 		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %X released Mutex [%s]\n",
-				 this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
+			this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
 	}
 
 	return (status);
@@ -843,11 +859,11 @@
  *
  * FUNCTION:    acpi_ut_create_update_state_and_push
  *
- * PARAMETERS:  *Object         - Object to be added to the new state
+ * PARAMETERS:  Object          - Object to be added to the new state
  *              Action          - Increment/Decrement
  *              state_list      - List the state will be added to
  *
- * RETURN:      None
+ * RETURN:      Status
  *
  * DESCRIPTION: Create a new state and push it
  *
@@ -885,15 +901,16 @@
  *
  * FUNCTION:    acpi_ut_create_pkg_state_and_push
  *
- * PARAMETERS:  *Object         - Object to be added to the new state
+ * PARAMETERS:  Object          - Object to be added to the new state
  *              Action          - Increment/Decrement
  *              state_list      - List the state will be added to
  *
- * RETURN:      None
+ * RETURN:      Status
  *
  * DESCRIPTION: Create a new state and push it
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_ut_create_pkg_state_and_push (
@@ -925,7 +942,7 @@
  * PARAMETERS:  list_head           - Head of the state stack
  *              State               - State object to push
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Push a state object onto a state stack
  *
@@ -954,7 +971,7 @@
  *
  * PARAMETERS:  list_head           - Head of the state stack
  *
- * RETURN:      Status
+ * RETURN:      The popped state object
  *
  * DESCRIPTION: Pop a state object from a state stack
  *
@@ -989,7 +1006,7 @@
  *
  * PARAMETERS:  None
  *
- * RETURN:      Status
+ * RETURN:      The new state object. NULL on failure.
  *
  * DESCRIPTION: Create a generic state object.  Attempt to obtain one from
  *              the global state cache;  If none available, create a new one.
@@ -997,7 +1014,8 @@
  ******************************************************************************/
 
 union acpi_generic_state *
-acpi_ut_create_generic_state (void)
+acpi_ut_create_generic_state (
+	void)
 {
 	union acpi_generic_state        *state;
 
@@ -1023,7 +1041,7 @@
  *
  * PARAMETERS:  None
  *
- * RETURN:      Thread State
+ * RETURN:      New Thread State. NULL on failure
  *
  * DESCRIPTION: Create a "Thread State" - a flavor of the generic state used
  *              to track per-thread info during method execution
@@ -1060,11 +1078,10 @@
  *
  * FUNCTION:    acpi_ut_create_update_state
  *
- * PARAMETERS:  Object              - Initial Object to be installed in the
- *                                    state
- *              Action              - Update action to be performed
+ * PARAMETERS:  Object          - Initial Object to be installed in the state
+ *              Action          - Update action to be performed
  *
- * RETURN:      Status
+ * RETURN:      New state object, null on failure
  *
  * DESCRIPTION: Create an "Update State" - a flavor of the generic state used
  *              to update reference counts and delete complex objects such
@@ -1104,11 +1121,10 @@
  *
  * FUNCTION:    acpi_ut_create_pkg_state
  *
- * PARAMETERS:  Object              - Initial Object to be installed in the
- *                                    state
- *              Action              - Update action to be performed
+ * PARAMETERS:  Object          - Initial Object to be installed in the state
+ *              Action          - Update action to be performed
  *
- * RETURN:      Status
+ * RETURN:      New state object, null on failure
  *
  * DESCRIPTION: Create a "Package State"
  *
@@ -1151,7 +1167,7 @@
  *
  * PARAMETERS:  None
  *
- * RETURN:      Status
+ * RETURN:      New state object, null on failure
  *
  * DESCRIPTION: Create a "Control State" - a flavor of the generic state used
  *              to support nested IF/WHILE constructs in the AML.
@@ -1190,7 +1206,7 @@
  *
  * PARAMETERS:  State               - The state object to be deleted
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Put a state object back into the global state cache.  The object
  *              is not actually freed at this time.
@@ -1216,7 +1232,7 @@
  *
  * PARAMETERS:  None
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Purge the global state object cache.  Used during subsystem
  *              termination.
@@ -1240,7 +1256,10 @@
  *
  * FUNCTION:    acpi_ut_walk_package_tree
  *
- * PARAMETERS:  obj_desc        - The Package object on which to resolve refs
+ * PARAMETERS:  source_object       - The package to walk
+ *              target_object       - Target object (if package is being copied)
+ *              walk_callback       - Called once for each package element
+ *              Context             - Passed to the callback function
  *
  * RETURN:      Status
  *
@@ -1359,7 +1378,7 @@
  * PARAMETERS:  Buffer          - Buffer to be scanned
  *              Length          - number of bytes to examine
  *
- * RETURN:      checksum
+ * RETURN:      The generated checksum
  *
  * DESCRIPTION: Generate a checksum on a raw buffer
  *
@@ -1442,7 +1461,6 @@
  * PARAMETERS:  module_name         - Caller's module name (for error output)
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
  *
  * RETURN:      None
  *
@@ -1457,7 +1475,6 @@
 	u32                             component_id)
 {
 
-
 	acpi_os_printf ("%8s-%04d: *** Error: ", module_name, line_number);
 }
 
@@ -1469,7 +1486,6 @@
  * PARAMETERS:  module_name         - Caller's module name (for error output)
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
  *
  * RETURN:      None
  *
@@ -1495,7 +1511,6 @@
  * PARAMETERS:  module_name         - Caller's module name (for error output)
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
  *
  * RETURN:      None
  *
diff -Nru a/drivers/acpi/utilities/utobject.c b/drivers/acpi/utilities/utobject.c
--- a/drivers/acpi/utilities/utobject.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utobject.c	2005-04-19 01:34:14 -04:00
@@ -50,6 +50,25 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utobject")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ut_get_simple_object_size (
+	union acpi_operand_object       *obj,
+	acpi_size                       *obj_length);
+
+static acpi_status
+acpi_ut_get_package_object_size (
+	union acpi_operand_object       *obj,
+	acpi_size                       *obj_length);
+
+static acpi_status
+acpi_ut_get_element_length (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
 
 /*******************************************************************************
  *
@@ -60,7 +79,7 @@
  *              component_id        - Component type of caller
  *              Type                - ACPI Type of the new object
  *
- * RETURN:      Object              - The new object.  Null on failure
+ * RETURN:      A new internal object, null on failure
  *
  * DESCRIPTION: Create and initialize a new internal object.
  *
@@ -83,7 +102,8 @@
 	union acpi_operand_object       *second_object;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ut_create_internal_object_dbg", acpi_ut_get_type_name (type));
+	ACPI_FUNCTION_TRACE_STR ("ut_create_internal_object_dbg",
+		acpi_ut_get_type_name (type));
 
 
 	/* Allocate the raw object descriptor */
@@ -99,7 +119,8 @@
 
 		/* These types require a secondary object */
 
-		second_object = acpi_ut_allocate_object_desc_dbg (module_name, line_number, component_id);
+		second_object = acpi_ut_allocate_object_desc_dbg (module_name,
+				   line_number, component_id);
 		if (!second_object) {
 			acpi_ut_delete_object_desc (object);
 			return_PTR (NULL);
@@ -138,7 +159,7 @@
  *
  * PARAMETERS:  buffer_size            - Size of buffer to be created
  *
- * RETURN:      Pointer to a new Buffer object
+ * RETURN:      Pointer to a new Buffer object, null on failure
  *
  * DESCRIPTION: Create a fully initialized buffer object
  *
@@ -192,9 +213,9 @@
  *
  * FUNCTION:    acpi_ut_create_string_object
  *
- * PARAMETERS:  string_size            - Size of string to be created.  Does not
- *                                       include NULL terminator, this is added
- *                                       automatically.
+ * PARAMETERS:  string_size         - Size of string to be created. Does not
+ *                                    include NULL terminator, this is added
+ *                                    automatically.
  *
  * RETURN:      Pointer to a new String object
  *
@@ -249,7 +270,9 @@
  *
  * PARAMETERS:  Object              - Object to be validated
  *
- * RETURN:      Validate a pointer to be an union acpi_operand_object
+ * RETURN:      TRUE if object is valid, FALSE otherwise
+ *
+ * DESCRIPTION: Validate a pointer to be an union acpi_operand_object
  *
  ******************************************************************************/
 
@@ -399,8 +422,8 @@
  *
  * FUNCTION:    acpi_ut_get_simple_object_size
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are examining
- *              *obj_length         - Where the length is returned
+ * PARAMETERS:  internal_object    - An ACPI operand object
+ *              obj_length         - Where the length is returned
  *
  * RETURN:      Status
  *
@@ -412,7 +435,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_get_simple_object_size (
 	union acpi_operand_object       *internal_object,
 	acpi_size                       *obj_length)
@@ -424,8 +447,10 @@
 	ACPI_FUNCTION_TRACE_PTR ("ut_get_simple_object_size", internal_object);
 
 
-	/* Handle a null object (Could be a uninitialized package element -- which is legal) */
-
+	/*
+	 * Handle a null object (Could be a uninitialized package
+	 * element -- which is legal)
+	 */
 	if (!internal_object) {
 		*obj_length = 0;
 		return_ACPI_STATUS (AE_OK);
@@ -480,7 +505,8 @@
 			 * Get the actual length of the full pathname to this object.
 			 * The reference will be converted to the pathname to the object
 			 */
-			length += ACPI_ROUND_UP_TO_NATIVE_WORD (acpi_ns_get_pathname_length (internal_object->reference.node));
+			length += ACPI_ROUND_UP_TO_NATIVE_WORD (
+					 acpi_ns_get_pathname_length (internal_object->reference.node));
 			break;
 
 		default:
@@ -530,7 +556,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_get_element_length (
 	u8                              object_type,
 	union acpi_operand_object       *source_object,
@@ -582,8 +608,8 @@
  *
  * FUNCTION:    acpi_ut_get_package_object_size
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are examining
- *              *obj_length         - Where the length is returned
+ * PARAMETERS:  internal_object     - An ACPI internal object
+ *              obj_length          - Where the length is returned
  *
  * RETURN:      Status
  *
@@ -595,7 +621,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_get_package_object_size (
 	union acpi_operand_object       *internal_object,
 	acpi_size                       *obj_length)
@@ -636,8 +662,8 @@
  *
  * FUNCTION:    acpi_ut_get_object_size
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are examining
- *              *obj_length         - Where the length will be returned
+ * PARAMETERS:  internal_object     - An ACPI internal object
+ *              obj_length          - Where the length will be returned
  *
  * RETURN:      Status
  *
@@ -647,7 +673,7 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ut_get_object_size(
+acpi_ut_get_object_size (
 	union acpi_operand_object       *internal_object,
 	acpi_size                       *obj_length)
 {
diff -Nru a/drivers/acpi/utilities/utxface.c b/drivers/acpi/utilities/utxface.c
--- a/drivers/acpi/utilities/utxface.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/utilities/utxface.c	2005-04-19 01:34:14 -04:00
@@ -73,6 +73,7 @@
 {
 	acpi_status                     status;
 
+
 	ACPI_FUNCTION_TRACE ("acpi_initialize_subsystem");
 
 
@@ -105,7 +106,6 @@
 	 * Initialize the namespace manager and
 	 * the root of the namespace tree
 	 */
-
 	status = acpi_ns_root_initialize ();
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("Namespace initialization failure, %s\n",
@@ -113,7 +113,6 @@
 		return_ACPI_STATUS (status);
 	}
 
-
 	/* If configured, initialize the AML debugger */
 
 	ACPI_DEBUGGER_EXEC (status = acpi_db_initialize ());
@@ -150,7 +149,8 @@
 	 * The values from the FADT are validated here.
 	 */
 	if (!(flags & ACPI_NO_HARDWARE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI hardware\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Initializing ACPI hardware\n"));
 
 		status = acpi_hw_initialize ();
 		if (ACPI_FAILURE (status)) {
@@ -178,7 +178,8 @@
 	 * install_address_space_handler interface.
 	 */
 	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Installing default address space handlers\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Installing default address space handlers\n"));
 
 		status = acpi_ev_install_region_handlers ();
 		if (ACPI_FAILURE (status)) {
@@ -189,12 +190,14 @@
 	/*
 	 * Initialize ACPI Event handling (Fixed and General Purpose)
 	 *
-	 * NOTE: We must have the hardware AND events initialized before we can execute
-	 * ANY control methods SAFELY.  Any control method can require ACPI hardware
-	 * support, so the hardware MUST be initialized before execution!
+	 * NOTE: We must have the hardware AND events initialized before we can
+	 * execute ANY control methods SAFELY.  Any control method can require
+	 * ACPI hardware support, so the hardware MUST be initialized before
+	 * execution!
 	 */
 	if (!(flags & ACPI_NO_EVENT_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI events\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Initializing ACPI events\n"));
 
 		status = acpi_ev_initialize_events ();
 		if (ACPI_FAILURE (status)) {
@@ -205,7 +208,8 @@
 	/* Install the SCI handler and Global Lock handler */
 
 	if (!(flags & ACPI_NO_HANDLER_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Installing SCI/GL handlers\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Installing SCI/GL handlers\n"));
 
 		status = acpi_ev_install_xrupt_handlers ();
 		if (ACPI_FAILURE (status)) {
@@ -247,7 +251,8 @@
 	 * contain executable AML (see call to acpi_ns_initialize_objects below).
 	 */
 	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Executing _REG op_region methods\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Executing _REG op_region methods\n"));
 
 		status = acpi_ev_initialize_op_regions ();
 		if (ACPI_FAILURE (status)) {
@@ -261,7 +266,8 @@
 	 * objects: operation_regions, buffer_fields, Buffers, and Packages.
 	 */
 	if (!(flags & ACPI_NO_OBJECT_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Completing Initialization of ACPI Objects\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Completing Initialization of ACPI Objects\n"));
 
 		status = acpi_ns_initialize_objects ();
 		if (ACPI_FAILURE (status)) {
@@ -274,7 +280,8 @@
 	 * This runs the _STA and _INI methods.
 	 */
 	if (!(flags & ACPI_NO_DEVICE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI Devices\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Initializing ACPI Devices\n"));
 
 		status = acpi_ns_initialize_devices ();
 		if (ACPI_FAILURE (status)) {
@@ -307,7 +314,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_terminate (void)
+acpi_terminate (
+	void)
 {
 	acpi_status                 status;
 
@@ -344,8 +352,7 @@
 
 
 #ifdef ACPI_FUTURE_USAGE
-
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_subsystem_status
  *
@@ -354,14 +361,16 @@
  * RETURN:      Status of the ACPI subsystem
  *
  * DESCRIPTION: Other drivers that use the ACPI subsystem should call this
- *              before making any other calls, to ensure the subsystem initial-
- *              ized successfully.
+ *              before making any other calls, to ensure the subsystem
+ *              initialized successfully.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
-acpi_subsystem_status (void)
+acpi_subsystem_status (
+	void)
 {
+
 	if (acpi_gbl_startup_flags & ACPI_INITIALIZED_OK) {
 		return (AE_OK);
 	}
@@ -371,13 +380,12 @@
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_get_system_info
  *
- * PARAMETERS:  out_buffer      - a pointer to a buffer to receive the
- *                                resources for the device
- *              buffer_length   - the number of bytes available in the buffer
+ * PARAMETERS:  out_buffer      - A buffer to receive the resources for the
+ *                                device
  *
  * RETURN:      Status          - the status of the call
  *
@@ -395,8 +403,8 @@
 	struct acpi_buffer              *out_buffer)
 {
 	struct acpi_system_info         *info_ptr;
-	u32                             i;
 	acpi_status                     status;
+	u32                             i;
 
 
 	ACPI_FUNCTION_TRACE ("acpi_get_system_info");
@@ -466,6 +474,7 @@
  * FUNCTION:    acpi_install_initialization_handler
  *
  * PARAMETERS:  Handler             - Callback procedure
+ *              Function            - Not (currently) used, see below
  *
  * RETURN:      Status
  *
@@ -495,7 +504,6 @@
 
 #endif  /*  ACPI_FUTURE_USAGE  */
 
-
 /*****************************************************************************
  *
  * FUNCTION:    acpi_purge_cached_objects
@@ -509,7 +517,8 @@
  ****************************************************************************/
 
 acpi_status
-acpi_purge_cached_objects (void)
+acpi_purge_cached_objects (
+	void)
 {
 	ACPI_FUNCTION_TRACE ("acpi_purge_cached_objects");
 
diff -Nru a/drivers/acpi/video.c b/drivers/acpi/video.c
--- a/drivers/acpi/video.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/acpi/video.c	2005-04-19 01:34:14 -04:00
@@ -564,12 +564,13 @@
 		int count = 0;
 		union acpi_object *o;
 		
-		br = kmalloc(sizeof &br, GFP_KERNEL);
+		br = kmalloc(sizeof(*br), GFP_KERNEL);
 		if (!br) {
 			printk(KERN_ERR "can't allocate memory\n");
 		} else {
-			memset(br, 0, sizeof &br);
-			br->levels = kmalloc(obj->package.count * sizeof &br->levels, GFP_KERNEL);
+			memset(br, 0, sizeof(*br));
+			br->levels = kmalloc(obj->package.count *
+					sizeof *(br->levels), GFP_KERNEL);
 			if (!br->levels)
 				goto out;
 
@@ -584,8 +585,7 @@
 			}
 out:
 			if (count < 2) {
-				if (br->levels)
-					kfree(br->levels);
+				kfree(br->levels);
 				kfree(br);
 			} else {
 				br->count = count;
@@ -595,8 +595,7 @@
 		}
 	}
 
-	if (obj)
-		kfree(obj);
+	kfree(obj);
 
 	return_VOID;
 }
@@ -1585,7 +1584,7 @@
 	ACPI_FUNCTION_TRACE("acpi_video_switch_output");
 
 	list_for_each_safe(node, next, &video->video_device_list) {
-		struct acpi_video_device * dev = container_of(node, struct acpi_video_device, entry);
+		dev = container_of(node, struct acpi_video_device, entry);
 		status = acpi_video_device_get_state(dev, &state);
 		if (state & 0x2){
 			dev_next = container_of(node->next, struct acpi_video_device, entry);
diff -Nru a/drivers/pnp/pnpacpi/rsparser.c b/drivers/pnp/pnpacpi/rsparser.c
--- a/drivers/pnp/pnpacpi/rsparser.c	2005-04-19 01:34:14 -04:00
+++ b/drivers/pnp/pnpacpi/rsparser.c	2005-04-19 01:34:14 -04:00
@@ -444,6 +444,7 @@
 
 struct acpipnp_parse_option_s {
 	struct pnp_option *option;
+	struct pnp_option *option_independent;
 	struct pnp_dev *dev;
 };
 
@@ -507,7 +508,14 @@
 			parse_data->option = option;	
 			break;
 		case ACPI_RSTYPE_END_DPF:
-			return AE_CTRL_TERMINATE;
+			/*only one EndDependentFn is allowed*/
+			if (!parse_data->option_independent) {
+				pnp_warn("PnPACPI: more than one EndDependentFn");
+				return AE_ERROR;
+			}
+			parse_data->option = parse_data->option_independent;
+			parse_data->option_independent = NULL;
+			break;
 		default:
 			pnp_warn("PnPACPI: unknown resource type %d", res->id);
 			return AE_ERROR;
@@ -525,6 +533,7 @@
 	parse_data.option = pnp_register_independent_option(dev);
 	if (!parse_data.option)
 		return AE_ERROR;
+	parse_data.option_independent = parse_data.option;
 	parse_data.dev = dev;
 	status = acpi_walk_resources(handle, METHOD_NAME__PRS, 
 		pnpacpi_option_resource, &parse_data);
diff -Nru a/include/acpi/acconfig.h b/include/acpi/acconfig.h
--- a/include/acpi/acconfig.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acconfig.h	2005-04-19 01:34:14 -04:00
@@ -64,7 +64,7 @@
 
 /* Version string */
 
-#define ACPI_CA_VERSION                 0x20050309
+#define ACPI_CA_VERSION                 0x20050408
 
 /*
  * OS name, used for the _OS object.  The _OS object is essentially obsolete,
@@ -130,9 +130,8 @@
 #define ACPI_MAX_GPE_BLOCKS             2
 #define ACPI_GPE_REGISTER_WIDTH         8
 
-/*
- * Method info (in WALK_STATE), containing local variables and argumetns
- */
+/* Method info (in WALK_STATE), containing local variables and argumetns */
+
 #define ACPI_METHOD_NUM_LOCALS          8
 #define ACPI_METHOD_MAX_LOCAL           7
 
diff -Nru a/include/acpi/acdebug.h b/include/acpi/acdebug.h
--- a/include/acpi/acdebug.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acdebug.h	2005-04-19 01:34:14 -04:00
@@ -61,9 +61,7 @@
 
 
 #define PARAM_LIST(pl)                  pl
-
 #define DBTEST_OUTPUT_LEVEL(lvl)        if (acpi_gbl_db_opt_verbose)
-
 #define VERBOSE_PRINT(fp)               DBTEST_OUTPUT_LEVEL(lvl) {\
 			  acpi_os_printf PARAM_LIST(fp);}
 
@@ -71,13 +69,9 @@
 #define EX_SINGLE_STEP                  2
 
 
-/* Prototypes */
-
-
 /*
  * dbxface - external debugger interfaces
  */
-
 acpi_status
 acpi_db_initialize (
 	void);
@@ -92,20 +86,10 @@
 	union acpi_parse_object         *op,
 	u32                             op_type);
 
-acpi_status
-acpi_db_start_command (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *op);
-
-void
-acpi_db_method_end (
-	struct acpi_walk_state          *walk_state);
-
 
 /*
  * dbcmds - debug commands and output routines
  */
-
 acpi_status
 acpi_db_disassemble_method (
 	char                            *name);
@@ -177,57 +161,30 @@
 	char                            *object_arg);
 
 void
-acpi_db_display_locks (void);
-
+acpi_db_display_locks (
+	void);
 
 void
 acpi_db_display_resources (
 	char                            *object_arg);
 
 void
-acpi_db_display_gpes (void);
+acpi_db_display_gpes (
+	void);
 
 void
 acpi_db_check_integrity (
 	void);
 
-acpi_status
-acpi_db_integrity_walk (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
-acpi_status
-acpi_db_walk_and_match_name (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
-acpi_status
-acpi_db_walk_for_references (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
-acpi_status
-acpi_db_walk_for_specific_objects (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
 void
 acpi_db_generate_gpe (
 	char                            *gpe_arg,
 	char                            *block_arg);
 
+
 /*
  * dbdisply - debug display commands
  */
-
 void
 acpi_db_display_method_info (
 	union acpi_parse_object         *op);
@@ -271,19 +228,10 @@
 	union acpi_operand_object       *obj_desc,
 	struct acpi_walk_state          *walk_state);
 
-void
-acpi_db_dump_parser_descriptor (
-	union acpi_parse_object         *op);
-
-void *
-acpi_db_get_pointer (
-	void                            *target);
-
 
 /*
  * dbexec - debugger control method execution
  */
-
 void
 acpi_db_execute (
 	char                            *name,
@@ -296,44 +244,15 @@
 	char                            *num_loops_arg,
 	char                            *method_name_arg);
 
-acpi_status
-acpi_db_execute_method (
-	struct acpi_db_method_info      *info,
-	struct acpi_buffer              *return_obj);
-
-void
-acpi_db_execute_setup (
-	struct acpi_db_method_info      *info);
-
-u32
-acpi_db_get_outstanding_allocations (
-	void);
-
-void ACPI_SYSTEM_XFACE
-acpi_db_method_thread (
-	void                            *context);
-
-acpi_status
-acpi_db_execution_walk (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
 
 /*
  * dbfileio - Debugger file I/O commands
  */
-
 acpi_object_type
 acpi_db_match_argument (
 	char                            *user_argument,
 	struct argument_info            *arguments);
 
-acpi_status
-ae_local_load_table (
-	struct acpi_table_header        *table_ptr);
-
 void
 acpi_db_close_debug_file (
 	void);
@@ -356,16 +275,17 @@
 	char                            *filename,
 	struct acpi_table_header        **table);
 
+
 /*
  * dbhistry - debugger HISTORY command
  */
-
 void
 acpi_db_add_to_history (
 	char                            *command_line);
 
 void
-acpi_db_display_history (void);
+acpi_db_display_history (
+	void);
 
 char *
 acpi_db_get_from_history (
@@ -375,7 +295,6 @@
 /*
  * dbinput - user front-end to the AML debugger
  */
-
 acpi_status
 acpi_db_command_dispatch (
 	char                            *input_buffer,
@@ -386,71 +305,28 @@
 acpi_db_execute_thread (
 	void                            *context);
 
-void
-acpi_db_display_help (
-	char                            *help_type);
-
-char *
-acpi_db_get_next_token (
-	char                            *string,
-	char                            **next);
-
-u32
-acpi_db_get_line (
-	char                            *input_buffer);
-
-u32
-acpi_db_match_command (
-	char                            *user_command);
-
-void
-acpi_db_single_thread (
-	void);
-
 
 /*
  * dbstats - Generation and display of ACPI table statistics
  */
-
 void
 acpi_db_generate_statistics (
 	union acpi_parse_object         *root,
 	u8                              is_method);
 
-
 acpi_status
 acpi_db_display_statistics (
 	char                            *type_arg);
 
-acpi_status
-acpi_db_classify_one_object (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
-void
-acpi_db_count_namespace_objects (
-	void);
-
-void
-acpi_db_enumerate_object (
-	union acpi_operand_object       *obj_desc);
-
 
 /*
  * dbutils - AML debugger utilities
  */
-
 void
 acpi_db_set_output_destination (
 	u32                             where);
 
 void
-acpi_db_dump_buffer (
-	u32                             address);
-
-void
 acpi_db_dump_object (
 	union acpi_object               *obj_desc,
 	u32                             level);
@@ -459,14 +335,8 @@
 acpi_db_prep_namestring (
 	char                            *name);
 
-
-acpi_status
-acpi_db_second_pass_parse (
-	union acpi_parse_object         *root);
-
 struct acpi_namespace_node *
 acpi_db_local_ns_lookup (
 	char                            *name);
-
 
 #endif  /* __ACDEBUG_H__ */
diff -Nru a/include/acpi/acdisasm.h b/include/acpi/acdisasm.h
--- a/include/acpi/acdisasm.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acdisasm.h	2005-04-19 01:34:14 -04:00
@@ -102,58 +102,16 @@
 /*
  * dmwalk
  */
-
-void
-acpi_dm_walk_parse_tree (
-	union acpi_parse_object         *op,
-	asl_walk_callback               descending_callback,
-	asl_walk_callback               ascending_callback,
-	void                            *context);
-
-acpi_status
-acpi_dm_descending_op (
-	union acpi_parse_object         *op,
-	u32                             level,
-	void                            *context);
-
-acpi_status
-acpi_dm_ascending_op (
-	union acpi_parse_object         *op,
-	u32                             level,
-	void                            *context);
-
-
-/*
- * dmopcode
- */
-
-void
-acpi_dm_validate_name (
-	char                            *name,
-	union acpi_parse_object         *op);
-
-u32
-acpi_dm_dump_name (
-	char                            *name);
-
-void
-acpi_dm_unicode (
-	union acpi_parse_object         *op);
-
 void
 acpi_dm_disassemble (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *origin,
 	u32                             num_opcodes);
 
-void
-acpi_dm_namestring (
-	char                            *name);
-
-void
-acpi_dm_display_path (
-	union acpi_parse_object         *op);
 
+/*
+ * dmopcode
+ */
 void
 acpi_dm_disassemble_one_op (
 	struct acpi_walk_state          *walk_state,
@@ -165,18 +123,9 @@
 	union acpi_operand_object       *obj_desc);
 
 u32
-acpi_dm_block_type (
-	union acpi_parse_object         *op);
-
-u32
 acpi_dm_list_type (
 	union acpi_parse_object         *op);
 
-acpi_status
-acpi_ps_display_object_pathname (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *op);
-
 void
 acpi_dm_method_flags (
 	union acpi_parse_object         *op);
@@ -197,10 +146,6 @@
 acpi_dm_match_op (
 	union acpi_parse_object         *op);
 
-void
-acpi_dm_match_keyword (
-	union acpi_parse_object         *op);
-
 u8
 acpi_dm_comma_if_list_member (
 	union acpi_parse_object         *op);
@@ -211,13 +156,25 @@
 
 
 /*
- * dmobject
+ * dmnames
  */
+u32
+acpi_dm_dump_name (
+	char                            *name);
+
+acpi_status
+acpi_ps_display_object_pathname (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
 
 void
-acpi_dm_decode_node (
-	struct acpi_namespace_node      *node);
+acpi_dm_namestring (
+	char                            *name);
+
 
+/*
+ * dmobject
+ */
 void
 acpi_dm_display_internal_object (
 	union acpi_operand_object       *obj_desc,
@@ -241,6 +198,16 @@
 /*
  * dmbuffer
  */
+void
+acpi_dm_disasm_byte_list (
+	u32                             level,
+	u8                              *byte_data,
+	u32                             byte_count);
+
+void
+acpi_dm_byte_list (
+	struct acpi_op_walk_info        *info,
+	union acpi_parse_object         *op);
 
 void
 acpi_is_eisa_id (
@@ -262,18 +229,6 @@
 /*
  * dmresrc
  */
-
-void
-acpi_dm_disasm_byte_list (
-	u32                             level,
-	u8                              *byte_data,
-	u32                             byte_count);
-
-void
-acpi_dm_byte_list (
-	struct acpi_op_walk_info        *info,
-	union acpi_parse_object         *op);
-
 void
 acpi_dm_resource_descriptor (
 	struct acpi_op_walk_info        *info,
@@ -296,19 +251,10 @@
 acpi_dm_decode_attribute (
 	u8                              attribute);
 
+
 /*
  * dmresrcl
  */
-
-void
-acpi_dm_io_flags (
-		u8                          flags);
-
-void
-acpi_dm_memory_flags (
-	u8                              flags,
-	u8                              specific_flags);
-
 void
 acpi_dm_word_descriptor (
 	struct asl_word_address_desc    *resource,
@@ -373,7 +319,6 @@
 /*
  * dmresrcs
  */
-
 void
 acpi_dm_irq_descriptor (
 	struct asl_irq_format_desc      *resource,
@@ -420,7 +365,6 @@
 /*
  * dmutils
  */
-
 void
 acpi_dm_add_to_external_list (
 	char                            *path);
diff -Nru a/include/acpi/acdispat.h b/include/acpi/acdispat.h
--- a/include/acpi/acdispat.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acdispat.h	2005-04-19 01:34:14 -04:00
@@ -50,40 +50,9 @@
 #define NAMEOF_ARG_NTE      "__A0"
 
 
-/* Common interfaces */
-
-acpi_status
-acpi_ds_obj_stack_push (
-	void                            *object,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
-acpi_ds_obj_stack_pop (
-	u32                             pop_count,
-	struct acpi_walk_state          *walk_state);
-
-#ifdef ACPI_FUTURE_USAGE
-void *
-acpi_ds_obj_stack_get_value (
-	u32                             index,
-	struct acpi_walk_state          *walk_state);
-#endif
-
-acpi_status
-acpi_ds_obj_stack_pop_object (
-	union acpi_operand_object       **object,
-	struct acpi_walk_state          *walk_state);
-
-
-/* dsopcode - support for late evaluation */
-
-acpi_status
-acpi_ds_execute_arguments (
-	struct acpi_namespace_node      *node,
-	struct acpi_namespace_node      *scope_node,
-	u32                             aml_length,
-	u8                              *aml_start);
-
+/*
+ * dsopcode - support for late evaluation
+ */
 acpi_status
 acpi_ds_get_buffer_field_arguments (
 	union acpi_operand_object       *obj_desc);
@@ -101,15 +70,6 @@
 	union acpi_operand_object       *obj_desc);
 
 acpi_status
-acpi_ds_init_buffer_field (
-	u16                             aml_opcode,
-	union acpi_operand_object       *obj_desc,
-	union acpi_operand_object       *buffer_desc,
-	union acpi_operand_object       *offset_desc,
-	union acpi_operand_object       *length_desc,
-	union acpi_operand_object       *result_desc);
-
-acpi_status
 acpi_ds_eval_buffer_field_operands (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op);
@@ -130,9 +90,9 @@
 	acpi_handle                     obj_handle);
 
 
-/* dsctrl - Parser/Interpreter interface, control stack routines */
-
-
+/*
+ * dsctrl - Parser/Interpreter interface, control stack routines
+ */
 acpi_status
 acpi_ds_exec_begin_control_op (
 	struct acpi_walk_state          *walk_state,
@@ -144,9 +104,9 @@
 	union acpi_parse_object         *op);
 
 
-/* dsexec - Parser/Interpreter interface, method execution callbacks */
-
-
+/*
+ * dsexec - Parser/Interpreter interface, method execution callbacks
+ */
 acpi_status
 acpi_ds_get_predicate_value (
 	struct acpi_walk_state          *walk_state,
@@ -162,14 +122,9 @@
 	struct acpi_walk_state          *state);
 
 
-/* dsfield - Parser/Interpreter interface for AML fields */
-
-acpi_status
-acpi_ds_get_field_names (
-	struct acpi_create_field_info   *info,
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *arg);
-
+/*
+ * dsfield - Parser/Interpreter interface for AML fields
+ */
 acpi_status
 acpi_ds_create_field (
 	union acpi_parse_object         *op,
@@ -199,8 +154,9 @@
 	struct acpi_walk_state          *walk_state);
 
 
-/* dsload - Parser/Interpreter interface, namespace load callbacks */
-
+/*
+ * dsload - Parser/Interpreter interface, namespace load callbacks
+ */
 acpi_status
 acpi_ds_load1_begin_op (
 	struct acpi_walk_state          *walk_state,
@@ -225,9 +181,9 @@
 	u32                             pass_number);
 
 
-/* dsmthdat - method data (locals/args) */
-
-
+/*
+ * dsmthdat - method data (locals/args)
+ */
 acpi_status
 acpi_ds_store_object_to_local (
 	u16                             opcode,
@@ -250,14 +206,6 @@
 acpi_ds_is_method_value (
 	union acpi_operand_object       *obj_desc);
 
-#ifdef ACPI_FUTURE_USAGE
-acpi_object_type
-acpi_ds_method_data_get_type (
-	u16                             opcode,
-	u32                             index,
-	struct acpi_walk_state          *walk_state);
-#endif
-
 acpi_status
 acpi_ds_method_data_get_value (
 	u16                             opcode,
@@ -265,12 +213,6 @@
 	struct acpi_walk_state          *walk_state,
 	union acpi_operand_object       **dest_desc);
 
-void
-acpi_ds_method_data_delete_value (
-	u16                             opcode,
-	u32                             index,
-	struct acpi_walk_state          *walk_state);
-
 acpi_status
 acpi_ds_method_data_init_args (
 	union acpi_operand_object       **params,
@@ -288,16 +230,10 @@
 acpi_ds_method_data_init (
 	struct acpi_walk_state          *walk_state);
 
-acpi_status
-acpi_ds_method_data_set_value (
-	u16                             opcode,
-	u32                             index,
-	union acpi_operand_object       *object,
-	struct acpi_walk_state          *walk_state);
-
-
-/* dsmethod - Parser/Interpreter interface - control method parsing */
 
+/*
+ * dsmethod - Parser/Interpreter interface - control method parsing
+ */
 acpi_status
 acpi_ds_parse_method (
 	acpi_handle                     obj_handle);
@@ -324,20 +260,18 @@
 	struct acpi_namespace_node      *calling_method_node);
 
 
-/* dsobj - Parser/Interpreter interface - object initialization and conversion */
-
-acpi_status
-acpi_ds_init_one_object (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
-
+/*
+ * dsinit
+ */
 acpi_status
 acpi_ds_initialize_objects (
 	struct acpi_table_desc          *table_desc,
 	struct acpi_namespace_node      *start_node);
 
+
+/*
+ * dsobject - Parser/Interpreter interface - object initialization and conversion
+ */
 acpi_status
 acpi_ds_build_internal_buffer_obj (
 	struct acpi_walk_state          *walk_state,
@@ -353,12 +287,6 @@
 	union acpi_operand_object       **obj_desc);
 
 acpi_status
-acpi_ds_build_internal_object (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *op,
-	union acpi_operand_object       **obj_desc_ptr);
-
-acpi_status
 acpi_ds_init_object_from_op (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op,
@@ -372,8 +300,9 @@
 	union acpi_parse_object         *op);
 
 
-/* dsutils - Parser/Interpreter interface utility routines */
-
+/*
+ * dsutils - Parser/Interpreter interface utility routines
+ */
 void
 acpi_ds_clear_implicit_return (
 	struct acpi_walk_state          *walk_state);
@@ -418,7 +347,6 @@
 /*
  * dswscope - Scope Stack manipulation
  */
-
 acpi_status
 acpi_ds_scope_stack_push (
 	struct acpi_namespace_node      *node,
@@ -435,7 +363,18 @@
 	struct acpi_walk_state          *walk_state);
 
 
-/* dswstate - parser WALK_STATE management routines */
+/*
+ * dswstate - parser WALK_STATE management routines
+ */
+acpi_status
+acpi_ds_obj_stack_push (
+	void                            *object,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_obj_stack_pop (
+	u32                             pop_count,
+	struct acpi_walk_state          *walk_state);
 
 struct acpi_walk_state *
 acpi_ds_create_walk_state (
@@ -454,12 +393,6 @@
 	struct acpi_parameter_info      *info,
 	u32                             pass_number);
 
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ds_obj_stack_delete_all (
-	struct acpi_walk_state          *walk_state);
-#endif
-
 acpi_status
 acpi_ds_obj_stack_pop_and_delete (
 	u32                             pop_count,
@@ -494,20 +427,8 @@
 acpi_ds_get_current_walk_state (
 	struct acpi_thread_state        *thread);
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-void
-acpi_ds_delete_walk_state_cache (
-	void);
-#endif
-
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
-acpi_ds_result_insert (
-	void                            *object,
-	u32                             index,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
 acpi_ds_result_remove (
 	union acpi_operand_object       **object,
 	u32                             index,
@@ -528,5 +449,11 @@
 acpi_ds_result_pop_from_bottom (
 	union acpi_operand_object       **object,
 	struct acpi_walk_state          *walk_state);
+
+#ifdef ACPI_ENABLE_OBJECT_CACHE
+void
+acpi_ds_delete_walk_state_cache (
+	void);
+#endif
 
 #endif /* _ACDISPAT_H_ */
diff -Nru a/include/acpi/acevents.h b/include/acpi/acevents.h
--- a/include/acpi/acevents.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acevents.h	2005-04-19 01:34:14 -04:00
@@ -45,6 +45,9 @@
 #define __ACEVENTS_H__
 
 
+/*
+ * evevent
+ */
 acpi_status
 acpi_ev_initialize_events (
 	void);
@@ -53,28 +56,14 @@
 acpi_ev_install_xrupt_handlers (
 	void);
 
-
-/*
- * Evfixed - Fixed event handling
- */
-
-acpi_status
-acpi_ev_fixed_event_initialize (
-	void);
-
 u32
 acpi_ev_fixed_event_detect (
 	void);
 
-u32
-acpi_ev_fixed_event_dispatch (
-	u32                             event);
-
 
 /*
- * Evmisc
+ * evmisc
  */
-
 u8
 acpi_ev_is_notify_object (
 	struct acpi_namespace_node      *node);
@@ -100,24 +89,10 @@
 	struct acpi_namespace_node      *node,
 	u32                             notify_value);
 
-void ACPI_SYSTEM_XFACE
-acpi_ev_notify_dispatch (
-	void                            *context);
-
 
 /*
- * Evgpe - GPE handling and dispatch
+ * evgpe - GPE handling and dispatch
  */
-
-acpi_status
-acpi_ev_walk_gpe_list (
-	ACPI_GPE_CALLBACK       gpe_walk_callback,
-	u32                             flags);
-
-u8
-acpi_ev_valid_gpe_event (
-	struct acpi_gpe_event_info      *gpe_event_info);
-
 acpi_status
 acpi_ev_update_gpe_enable_masks (
 	struct acpi_gpe_event_info      *gpe_event_info,
@@ -137,9 +112,23 @@
 	acpi_handle                     gpe_device,
 	u32                             gpe_number);
 
+
+/*
+ * evgpeblk
+ */
+u8
+acpi_ev_valid_gpe_event (
+	struct acpi_gpe_event_info      *gpe_event_info);
+
 acpi_status
-acpi_ev_gpe_initialize (
-	void);
+acpi_ev_walk_gpe_list (
+	ACPI_GPE_CALLBACK       gpe_walk_callback,
+	u32                             flags);
+
+acpi_status
+acpi_ev_delete_gpe_handlers (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block);
 
 acpi_status
 acpi_ev_create_gpe_block (
@@ -154,11 +143,6 @@
 acpi_ev_delete_gpe_block (
 	struct acpi_gpe_block_info      *gpe_block);
 
-acpi_status
-acpi_ev_delete_gpe_handlers (
-	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
-	struct acpi_gpe_block_info      *gpe_block);
-
 u32
 acpi_ev_gpe_dispatch (
 	struct acpi_gpe_event_info      *gpe_event_info,
@@ -177,10 +161,14 @@
 acpi_ev_check_for_wake_only_gpe (
 	struct acpi_gpe_event_info      *gpe_event_info);
 
+acpi_status
+acpi_ev_gpe_initialize (
+	void);
+
+
 /*
- * Evregion - Address Space handling
+ * evregion - Address Space handling
  */
-
 acpi_status
 acpi_ev_install_region_handlers (
 	void);
@@ -198,13 +186,6 @@
 	void                            *value);
 
 acpi_status
-acpi_ev_install_handler (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
-
-acpi_status
 acpi_ev_attach_region (
 	union acpi_operand_object       *handler_obj,
 	union acpi_operand_object       *region_obj,
@@ -233,17 +214,10 @@
 	union acpi_operand_object      *region_obj,
 	u32                             function);
 
-acpi_status
-acpi_ev_reg_run (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
 
 /*
- * Evregini - Region initialization and setup
+ * evregini - Region initialization and setup
  */
-
 acpi_status
 acpi_ev_system_memory_region_setup (
 	acpi_handle                     handle,
@@ -293,9 +267,8 @@
 
 
 /*
- * Evsci - SCI (System Control Interrupt) handling/dispatch
+ * evsci - SCI (System Control Interrupt) handling/dispatch
  */
-
 u32 ACPI_SYSTEM_XFACE
 acpi_ev_gpe_xrupt_handler (
 	void                            *context);
diff -Nru a/include/acpi/acexcep.h b/include/acpi/acexcep.h
--- a/include/acpi/acexcep.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acexcep.h	2005-04-19 01:34:14 -04:00
@@ -48,7 +48,6 @@
 /*
  * Exceptions returned by external ACPI interfaces
  */
-
 #define AE_CODE_ENVIRONMENTAL           0x0000
 #define AE_CODE_PROGRAMMER              0x1000
 #define AE_CODE_ACPI_TABLES             0x2000
@@ -99,6 +98,7 @@
 
 #define AE_CODE_ENV_MAX                 0x001E
 
+
 /*
  * Programmer exceptions
  */
@@ -168,6 +168,7 @@
 
 #define AE_CODE_AML_MAX                 0x0021
 
+
 /*
  * Internal exceptions used for control
  */
@@ -188,6 +189,7 @@
 
 #ifdef DEFINE_ACPI_GLOBALS
 
+
 /*
  * String versions of the exception codes above
  * These strings must match the corresponding defines exactly
@@ -303,6 +305,5 @@
 };
 
 #endif /* ACPI GLOBALS */
-
 
 #endif /* __ACEXCEP_H__ */
diff -Nru a/include/acpi/acglobal.h b/include/acpi/acglobal.h
--- a/include/acpi/acglobal.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acglobal.h	2005-04-19 01:34:14 -04:00
@@ -146,15 +146,15 @@
 ACPI_EXTERN FACS_DESCRIPTOR            *acpi_gbl_FACS;
 ACPI_EXTERN struct acpi_common_facs             acpi_gbl_common_fACS;
 /*
- * Since there may be multiple SSDTs and PSDTS, a single pointer is not
+ * Since there may be multiple SSDTs and PSDTs, a single pointer is not
  * sufficient; Therefore, there isn't one!
  */
 
 
 /*
- * Handle both ACPI 1.0 and ACPI 2.0 Integer widths
- * If we are running a method that exists in a 32-bit ACPI table.
- * Use only 32 bits of the Integer for conversion.
+ * Handle both ACPI 1.0 and ACPI 2.0 Integer widths:
+ * If we are executing a method that exists in a 32-bit ACPI table,
+ * use only the lower 32 bits of the (internal) 64-bit Integer.
  */
 ACPI_EXTERN u8                                  acpi_gbl_integer_bit_width;
 ACPI_EXTERN u8                                  acpi_gbl_integer_byte_width;
@@ -246,6 +246,7 @@
 ACPI_EXTERN u32                                 acpi_gbl_deepest_nesting;
 #endif
 
+
 /*****************************************************************************
  *
  * Interpreter globals
@@ -268,6 +269,7 @@
 
 ACPI_EXTERN union acpi_parse_object            *acpi_gbl_parsed_namespace_root;
 
+
 /*****************************************************************************
  *
  * Hardware globals
@@ -298,7 +300,6 @@
  *
  ****************************************************************************/
 
-
 ACPI_EXTERN u8                                  acpi_gbl_db_output_flags;
 
 #ifdef ACPI_DISASSEMBLER
@@ -352,6 +353,5 @@
 ACPI_EXTERN u32                                 acpi_gbl_size_of_acpi_objects;
 
 #endif /* ACPI_DEBUGGER */
-
 
 #endif /* __ACGLOBAL_H__ */
diff -Nru a/include/acpi/achware.h b/include/acpi/achware.h
--- a/include/acpi/achware.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/achware.h	2005-04-19 01:34:14 -04:00
@@ -46,22 +46,26 @@
 
 
 /* PM Timer ticks per second (HZ) */
+
 #define PM_TIMER_FREQUENCY  3579545
 
+/* Values for the _SST reserved method */
 
-/* Prototypes */
+#define ACPI_SST_INDICATOR_OFF  0
+#define ACPI_SST_WORKING        1
+#define ACPI_SST_WAKING         2
+#define ACPI_SST_SLEEPING       3
+#define ACPI_SST_SLEEP_CONTEXT  4
 
 
-acpi_status
-acpi_hw_initialize (
-	void);
+/* Prototypes */
 
-acpi_status
-acpi_hw_shutdown (
-	void);
 
+/*
+ * hwacpi - high level functions
+ */
 acpi_status
-acpi_hw_initialize_system_info (
+acpi_hw_initialize (
 	void);
 
 acpi_status
@@ -72,12 +76,10 @@
 acpi_hw_get_mode (
 	void);
 
-u32
-acpi_hw_get_mode_capabilities (
-	void);
-
-/* Register I/O Prototypes */
 
+/*
+ * hwregs - ACPI Register I/O
+ */
 struct acpi_bit_register_info *
 acpi_hw_get_bit_register_info (
 	u32                             register_id);
@@ -111,8 +113,9 @@
 	u32                             flags);
 
 
-/* GPE support */
-
+/*
+ * hwgpe - GPE support
+ */
 acpi_status
 acpi_hw_write_gpe_enable_reg (
 	struct acpi_gpe_event_info      *gpe_event_info);
@@ -131,12 +134,12 @@
 	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
 	struct acpi_gpe_block_info      *gpe_block);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 acpi_status
 acpi_hw_get_gpe_status (
 	struct acpi_gpe_event_info      *gpe_event_info,
 	acpi_event_status               *event_status);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 acpi_status
 acpi_hw_disable_all_gpes (
@@ -155,15 +158,11 @@
 	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
 	struct acpi_gpe_block_info      *gpe_block);
 
-acpi_status
-acpi_hw_enable_wakeup_gpe_block (
-	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
-	struct acpi_gpe_block_info      *gpe_block);
-
 
-/* ACPI Timer prototypes */
-
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
+/*
+ * hwtimer - ACPI Timer prototypes
+ */
 acpi_status
 acpi_get_timer_resolution (
 	u32                             *resolution);
@@ -177,6 +176,7 @@
 	u32                             start_ticks,
 	u32                             end_ticks,
 	u32                             *time_elapsed);
-#endif  /*  ACPI_FUTURE_USAGE  */
+#endif	/* ACPI_FUTURE_USAGE */
+
 
 #endif /* __ACHWARE_H__ */
diff -Nru a/include/acpi/acinterp.h b/include/acpi/acinterp.h
--- a/include/acpi/acinterp.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acinterp.h	2005-04-19 01:34:14 -04:00
@@ -48,37 +48,9 @@
 #define ACPI_WALK_OPERANDS       (&(walk_state->operands [walk_state->num_operands -1]))
 
 
-acpi_status
-acpi_ex_resolve_operands (
-	u16                             opcode,
-	union acpi_operand_object       **stack_ptr,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
-acpi_ex_check_object_type (
-	acpi_object_type                type_needed,
-	acpi_object_type                this_type,
-	void                            *object);
-
-/*
- * exxface - External interpreter interfaces
- */
-
-acpi_status
-acpi_ex_load_table (
-	acpi_table_type                 table_id);
-
-acpi_status
-acpi_ex_execute_method (
-	struct acpi_namespace_node      *method_node,
-	union acpi_operand_object       **params,
-	union acpi_operand_object       **return_obj_desc);
-
-
 /*
  * exconvrt - object conversion
  */
-
 acpi_status
 acpi_ex_convert_to_integer (
 	union acpi_operand_object       *obj_desc,
@@ -110,17 +82,10 @@
 	union acpi_operand_object       **result_desc,
 	struct acpi_walk_state          *walk_state);
 
-u32
-acpi_ex_convert_to_ascii (
-	acpi_integer                    integer,
-	u16                             base,
-	u8                              *string,
-	u8                              max_length);
 
 /*
  * exfield - ACPI AML (p-code) execution - field manipulation
  */
-
 acpi_status
 acpi_ex_common_buffer_setup (
 	union acpi_operand_object       *obj_desc,
@@ -128,42 +93,6 @@
 	u32                             *datum_count);
 
 acpi_status
-acpi_ex_extract_from_field (
-	union acpi_operand_object       *obj_desc,
-	void                            *buffer,
-	u32                             buffer_length);
-
-acpi_status
-acpi_ex_insert_into_field (
-	union acpi_operand_object       *obj_desc,
-	void                            *buffer,
-	u32                             buffer_length);
-
-acpi_status
-acpi_ex_setup_region (
-	union acpi_operand_object       *obj_desc,
-	u32                             field_datum_byte_offset);
-
-acpi_status
-acpi_ex_access_region (
-	union acpi_operand_object       *obj_desc,
-	u32                             field_datum_byte_offset,
-	acpi_integer                    *value,
-	u32                             read_write);
-
-u8
-acpi_ex_register_overflow (
-	union acpi_operand_object       *obj_desc,
-	acpi_integer                    value);
-
-acpi_status
-acpi_ex_field_datum_io (
-	union acpi_operand_object       *obj_desc,
-	u32                             field_datum_byte_offset,
-	acpi_integer                    *value,
-	u32                             read_write);
-
-acpi_status
 acpi_ex_write_with_update_rule (
 	union acpi_operand_object       *obj_desc,
 	acpi_integer                    mask,
@@ -198,28 +127,33 @@
 	union acpi_operand_object       *obj_desc,
 	union acpi_operand_object       **result_desc);
 
+
 /*
- * exmisc - ACPI AML (p-code) execution - specific opcodes
+ * exfldio - low level field I/O
  */
-
 acpi_status
-acpi_ex_opcode_3A_0T_0R (
-	struct acpi_walk_state          *walk_state);
+acpi_ex_extract_from_field (
+	union acpi_operand_object       *obj_desc,
+	void                            *buffer,
+	u32                             buffer_length);
 
 acpi_status
-acpi_ex_opcode_3A_1T_1R (
-	struct acpi_walk_state          *walk_state);
+acpi_ex_insert_into_field (
+	union acpi_operand_object       *obj_desc,
+	void                            *buffer,
+	u32                             buffer_length);
 
 acpi_status
-acpi_ex_opcode_6A_0T_1R (
-	struct acpi_walk_state          *walk_state);
+acpi_ex_access_region (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset,
+	acpi_integer                    *value,
+	u32                             read_write);
 
-u8
-acpi_ex_do_match (
-	u32                             match_op,
-	union acpi_operand_object       *package_obj,
-	union acpi_operand_object       *match_obj);
 
+/*
+ * exmisc - misc support routines
+ */
 acpi_status
 acpi_ex_get_object_reference (
 	union acpi_operand_object       *obj_desc,
@@ -227,13 +161,6 @@
 	struct acpi_walk_state          *walk_state);
 
 acpi_status
-acpi_ex_resolve_multiple (
-	struct acpi_walk_state          *walk_state,
-	union acpi_operand_object       *operand,
-	acpi_object_type                *return_type,
-	union acpi_operand_object       **return_desc);
-
-acpi_status
 acpi_ex_concat_template (
 	union acpi_operand_object       *obj_desc,
 	union acpi_operand_object       *obj_desc2,
@@ -308,13 +235,6 @@
 /*
  * exconfig - dynamic table load/unload
  */
-
-acpi_status
-acpi_ex_add_table (
-	struct acpi_table_header        *table,
-	struct acpi_namespace_node      *parent_node,
-	union acpi_operand_object       **ddb_handle);
-
 acpi_status
 acpi_ex_load_op (
 	union acpi_operand_object       *obj_desc,
@@ -334,7 +254,6 @@
 /*
  * exmutex - mutex support
  */
-
 acpi_status
 acpi_ex_acquire_mutex (
 	union acpi_operand_object       *time_desc,
@@ -354,15 +273,10 @@
 acpi_ex_unlink_mutex (
 	union acpi_operand_object       *obj_desc);
 
-void
-acpi_ex_link_mutex (
-	union acpi_operand_object       *obj_desc,
-	struct acpi_thread_state        *thread);
 
 /*
- * exprep - ACPI AML (p-code) execution - prep utilities
+ * exprep - ACPI AML execution - prep utilities
  */
-
 acpi_status
 acpi_ex_prep_common_field_object (
 	union acpi_operand_object       *obj_desc,
@@ -375,10 +289,10 @@
 acpi_ex_prep_field_value (
 	struct acpi_create_field_info   *info);
 
+
 /*
  * exsystem - Interface to OS services
  */
-
 acpi_status
 acpi_ex_system_do_notify_op (
 	union acpi_operand_object       *value,
@@ -421,9 +335,8 @@
 
 
 /*
- * exmonadic - ACPI AML (p-code) execution, monadic operators
+ * exoparg1 - ACPI AML execution, 1 operand
  */
-
 acpi_status
 acpi_ex_opcode_0A_0T_1R (
 	struct acpi_walk_state          *walk_state);
@@ -445,9 +358,8 @@
 	struct acpi_walk_state          *walk_state);
 
 /*
- * exdyadic - ACPI AML (p-code) execution, dyadic operators
+ * exoparg2 - ACPI AML execution, 2 operands
  */
-
 acpi_status
 acpi_ex_opcode_2A_0T_0R (
 	struct acpi_walk_state          *walk_state);
@@ -466,21 +378,56 @@
 
 
 /*
- * exresolv  - Object resolution and get value functions
+ * exoparg3 - ACPI AML execution, 3 operands
+ */
+acpi_status
+acpi_ex_opcode_3A_0T_0R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_3A_1T_1R (
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * exoparg6 - ACPI AML execution, 6 operands
  */
+acpi_status
+acpi_ex_opcode_6A_0T_1R (
+	struct acpi_walk_state          *walk_state);
+
 
+/*
+ * exresolv - Object resolution and get value functions
+ */
 acpi_status
 acpi_ex_resolve_to_value (
 	union acpi_operand_object       **stack_ptr,
 	struct acpi_walk_state          *walk_state);
 
 acpi_status
+acpi_ex_resolve_multiple (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *operand,
+	acpi_object_type                *return_type,
+	union acpi_operand_object       **return_desc);
+
+
+/*
+ * exresnte - resolve namespace node
+ */
+acpi_status
 acpi_ex_resolve_node_to_value (
 	struct acpi_namespace_node      **stack_ptr,
 	struct acpi_walk_state          *walk_state);
 
+
+/*
+ * exresop - resolve operand to value
+ */
 acpi_status
-acpi_ex_resolve_object_to_value (
+acpi_ex_resolve_operands (
+	u16                             opcode,
 	union acpi_operand_object       **stack_ptr,
 	struct acpi_walk_state          *walk_state);
 
@@ -488,7 +435,6 @@
 /*
  * exdump - Interpreter debug output routines
  */
-
 void
 acpi_ex_dump_operand (
 	union acpi_operand_object       *obj_desc,
@@ -504,7 +450,7 @@
 	char                            *module_name,
 	u32                             line_number);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_ex_dump_object_descriptor (
 	union acpi_operand_object       *object,
@@ -514,46 +460,12 @@
 acpi_ex_dump_node (
 	struct acpi_namespace_node      *node,
 	u32                             flags);
+#endif	/* ACPI_FUTURE_USAGE */
 
-void
-acpi_ex_out_string (
-	char                            *title,
-	char                            *value);
-
-void
-acpi_ex_out_pointer (
-	char                            *title,
-	void                            *value);
-
-void
-acpi_ex_out_integer (
-	char                            *title,
-	u32                             value);
-
-void
-acpi_ex_out_address (
-	char                            *title,
-	acpi_physical_address           value);
-#endif  /*  ACPI_FUTURE_USAGE  */
 
 /*
- * exnames - interpreter/scanner name load/execute
+ * exnames - AML namestring support
  */
-
-char *
-acpi_ex_allocate_name_string (
-	u32                             prefix_count,
-	u32                             num_name_segs);
-
-u32
-acpi_ex_good_char (
-	u32                             character);
-
-acpi_status
-acpi_ex_name_segment (
-	u8                              **in_aml_address,
-	char                            *name_string);
-
 acpi_status
 acpi_ex_get_name_string (
 	acpi_object_type                data_type,
@@ -561,16 +473,10 @@
 	char                            **out_name_string,
 	u32                             *out_name_length);
 
-acpi_status
-acpi_ex_do_name (
-	acpi_object_type                data_type,
-	acpi_interpreter_mode           load_exec_mode);
-
 
 /*
  * exstore - Object store support
  */
-
 acpi_status
 acpi_ex_store (
 	union acpi_operand_object       *val_desc,
@@ -578,12 +484,6 @@
 	struct acpi_walk_state          *walk_state);
 
 acpi_status
-acpi_ex_store_object_to_index (
-	union acpi_operand_object       *val_desc,
-	union acpi_operand_object       *dest_desc,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
 acpi_ex_store_object_to_node (
 	union acpi_operand_object       *source_desc,
 	struct acpi_namespace_node      *node,
@@ -593,10 +493,10 @@
 #define ACPI_IMPLICIT_CONVERSION        TRUE
 #define ACPI_NO_IMPLICIT_CONVERSION     FALSE
 
+
 /*
- * exstoren
+ * exstoren - resolve/store object
  */
-
 acpi_status
 acpi_ex_resolve_object (
 	union acpi_operand_object       **source_desc_ptr,
@@ -612,9 +512,8 @@
 
 
 /*
- * excopy - object copy
+ * exstorob - store object - buffer/string
  */
-
 acpi_status
 acpi_ex_store_buffer_to_buffer (
 	union acpi_operand_object       *source_desc,
@@ -625,6 +524,10 @@
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       *target_desc);
 
+
+/*
+ * excopy - object copy
+ */
 acpi_status
 acpi_ex_copy_integer_to_index_field (
 	union acpi_operand_object       *source_desc,
@@ -645,10 +548,10 @@
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       *target_desc);
 
+
 /*
  * exutils - interpreter/scanner utilities
  */
-
 acpi_status
 acpi_ex_enter_interpreter (
 	void);
@@ -669,11 +572,6 @@
 acpi_ex_release_global_lock (
 	u8                              locked);
 
-u32
-acpi_ex_digits_needed (
-	acpi_integer                    value,
-	u32                             base);
-
 void
 acpi_ex_eisa_id_to_string (
 	u32                             numeric_id,
@@ -688,7 +586,6 @@
 /*
  * exregion - default op_region handlers
  */
-
 acpi_status
 acpi_ex_system_memory_space_handler (
 	u32                             function,
diff -Nru a/include/acpi/aclocal.h b/include/acpi/aclocal.h
--- a/include/acpi/aclocal.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/aclocal.h	2005-04-19 01:34:14 -04:00
@@ -72,7 +72,6 @@
  *
  * NOTE: any changes here must be reflected in the acpi_gbl_mutex_names table also!
  */
-
 #define ACPI_MTX_EXECUTE                0
 #define ACPI_MTX_INTERPRETER            1
 #define ACPI_MTX_PARSER                 2
@@ -151,13 +150,13 @@
 #define ACPI_FIELD_DWORD_GRANULARITY    4
 #define ACPI_FIELD_QWORD_GRANULARITY    8
 
+
 /*****************************************************************************
  *
  * Namespace typedefs and structs
  *
  ****************************************************************************/
 
-
 /* Operational modes of the AML interpreter/scanner */
 
 typedef enum
@@ -176,7 +175,6 @@
  * data_type is used to differentiate between internal descriptors, and MUST
  * be the first byte in this structure.
  */
-
 union acpi_name_union
 {
 	u32                                 integer;
@@ -415,7 +413,6 @@
  *
  ****************************************************************************/
 
-
 #define ACPI_CONTROL_NORMAL                  0xC0
 #define ACPI_CONTROL_CONDITIONAL_EXECUTING   0xC1
 #define ACPI_CONTROL_PREDICATE_EXECUTING     0xC2
@@ -424,6 +421,7 @@
 
 
 /* Forward declarations */
+
 struct acpi_walk_state        ;
 struct acpi_obj_mutex;
 union acpi_parse_object        ;
@@ -601,7 +599,6 @@
 	u8                                  type;           /* Opcode type */
 };
 
-
 union acpi_parse_value
 {
 	acpi_integer                        integer;        /* Integer constant (Up to 64 bits) */
@@ -613,7 +610,6 @@
 	union acpi_parse_object             *arg;           /* arguments and contained ops */
 };
 
-
 #define ACPI_PARSE_COMMON \
 	u8                                  data_type;      /* To differentiate various internal objs */\
 	u8                                  flags;          /* Type of Op */\
@@ -691,7 +687,6 @@
 	char                                parse_op_name[12];
 };
 
-
 union acpi_parse_object
 {
 	struct acpi_parse_obj_common        common;
@@ -833,7 +828,6 @@
  * Resource descriptors
  *
  ****************************************************************************/
-
 
 /* resource_type values */
 
diff -Nru a/include/acpi/acmacros.h b/include/acpi/acmacros.h
--- a/include/acpi/acmacros.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acmacros.h	2005-04-19 01:34:14 -04:00
@@ -539,11 +539,6 @@
 
 
 #define ACPI_DUMP_ENTRY(a,b)            acpi_ns_dump_entry (a,b)
-
-#ifdef ACPI_FUTURE_USAGE
-#define ACPI_DUMP_TABLES(a,b)           acpi_ns_dump_tables(a,b)
-#endif
-
 #define ACPI_DUMP_PATHNAME(a,b,c,d)     acpi_ns_dump_pathname(a,b,c,d)
 #define ACPI_DUMP_RESOURCE_LIST(a)      acpi_rs_dump_resource_list(a)
 #define ACPI_DUMP_BUFFER(a,b)           acpi_ut_dump_buffer((u8 *)a,b,DB_BYTE_DISPLAY,_COMPONENT)
@@ -596,11 +591,6 @@
 #define ACPI_DUMP_STACK_ENTRY(a)
 #define ACPI_DUMP_OPERANDS(a,b,c,d,e)
 #define ACPI_DUMP_ENTRY(a,b)
-
-#ifdef ACPI_FUTURE_USAGE
-#define ACPI_DUMP_TABLES(a,b)
-#endif
-
 #define ACPI_DUMP_PATHNAME(a,b,c,d)
 #define ACPI_DUMP_RESOURCE_LIST(a)
 #define ACPI_DUMP_BUFFER(a,b)
diff -Nru a/include/acpi/acnames.h b/include/acpi/acnames.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/include/acpi/acnames.h	2005-04-19 01:34:14 -04:00
@@ -0,0 +1,84 @@
+/******************************************************************************
+ *
+ * Name: acnames.h - Global names and strings
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2005, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACNAMES_H__
+#define __ACNAMES_H__
+
+/* Method names - these methods can appear anywhere in the namespace */
+
+#define METHOD_NAME__HID        "_HID"
+#define METHOD_NAME__CID        "_CID"
+#define METHOD_NAME__UID        "_UID"
+#define METHOD_NAME__ADR        "_ADR"
+#define METHOD_NAME__INI        "_INI"
+#define METHOD_NAME__STA        "_STA"
+#define METHOD_NAME__REG        "_REG"
+#define METHOD_NAME__SEG        "_SEG"
+#define METHOD_NAME__BBN        "_BBN"
+#define METHOD_NAME__PRT        "_PRT"
+#define METHOD_NAME__CRS        "_CRS"
+#define METHOD_NAME__PRS        "_PRS"
+#define METHOD_NAME__PRW        "_PRW"
+#define METHOD_NAME__SRS        "_SRS"
+
+/* Method names - these methods must appear at the namespace root */
+
+#define METHOD_NAME__BFS        "\\_BFS"
+#define METHOD_NAME__GTS        "\\_GTS"
+#define METHOD_NAME__PTS        "\\_PTS"
+#define METHOD_NAME__SST        "\\_SI._SST"
+#define METHOD_NAME__WAK        "\\_WAK"
+
+/* Definitions of the predefined namespace names  */
+
+#define ACPI_UNKNOWN_NAME       (u32) 0x3F3F3F3F     /* Unknown name is  "????" */
+#define ACPI_ROOT_NAME          (u32) 0x5F5F5F5C     /* Root name is     "\___" */
+#define ACPI_SYS_BUS_NAME       (u32) 0x5F53425F     /* Sys bus name is  "_SB_" */
+
+#define ACPI_NS_ROOT_PATH       "\\"
+#define ACPI_NS_SYSTEM_BUS      "_SB_"
+
+
+#endif  /* __ACNAMES_H__  */
+
+
diff -Nru a/include/acpi/acnamesp.h b/include/acpi/acnamesp.h
--- a/include/acpi/acnamesp.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acnamesp.h	2005-04-19 01:34:14 -04:00
@@ -57,17 +57,6 @@
 #define ACPI_NS_NEWSCOPE            1   /* a definition of this type opens a name scope */
 #define ACPI_NS_LOCAL               2   /* suppress search of enclosing scopes */
 
-
-/* Definitions of the predefined namespace names  */
-
-#define ACPI_UNKNOWN_NAME           (u32) 0x3F3F3F3F     /* Unknown name is  "????" */
-#define ACPI_ROOT_NAME              (u32) 0x5F5F5F5C     /* Root name is     "\___" */
-#define ACPI_SYS_BUS_NAME           (u32) 0x5F53425F     /* Sys bus name is  "_SB_" */
-
-#define ACPI_NS_ROOT_PATH           "\\"
-#define ACPI_NS_SYSTEM_BUS          "_SB_"
-
-
 /* Flags for acpi_ns_lookup, acpi_ns_search_and_enter */
 
 #define ACPI_NS_NO_UPSEARCH         0
@@ -80,10 +69,9 @@
 #define ACPI_NS_WALK_NO_UNLOCK      FALSE
 
 
-acpi_status
-acpi_ns_load_namespace (
-	void);
-
+/*
+ * nsinit - Namespace initialization
+ */
 acpi_status
 acpi_ns_initialize_objects (
 	void);
@@ -93,23 +81,22 @@
 	void);
 
 
-/* Namespace init - nsxfinit */
-
+/*
+ * nsload -  Namespace loading
+ */
 acpi_status
-acpi_ns_init_one_device (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
+acpi_ns_load_namespace (
+	void);
 
 acpi_status
-acpi_ns_init_one_object (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
+acpi_ns_load_table (
+	struct acpi_table_desc          *table_desc,
+	struct acpi_namespace_node      *node);
 
 
+/*
+ * nswalk - walk the namespace
+ */
 acpi_status
 acpi_ns_walk_namespace (
 	acpi_object_type                type,
@@ -126,37 +113,24 @@
 	struct acpi_namespace_node      *parent,
 	struct acpi_namespace_node      *child);
 
-void
-acpi_ns_delete_namespace_by_owner (
-	u16                             table_id);
-
-
-/* Namespace loading - nsload */
-
-acpi_status
-acpi_ns_one_complete_parse (
-	u32                             pass_number,
-	struct acpi_table_desc          *table_desc);
 
+/*
+ * nsparse - table parsing
+ */
 acpi_status
 acpi_ns_parse_table (
 	struct acpi_table_desc          *table_desc,
 	struct acpi_namespace_node      *scope);
 
 acpi_status
-acpi_ns_load_table (
-	struct acpi_table_desc          *table_desc,
-	struct acpi_namespace_node      *node);
-
-acpi_status
-acpi_ns_load_table_by_type (
-	acpi_table_type                 table_type);
+acpi_ns_one_complete_parse (
+	u32                             pass_number,
+	struct acpi_table_desc          *table_desc);
 
 
 /*
- * Top-level namespace access - nsaccess
+ * nsaccess - Top-level namespace access
  */
-
 acpi_status
 acpi_ns_root_initialize (
 	void);
@@ -173,9 +147,8 @@
 
 
 /*
- * Named object allocation/deallocation - nsalloc
+ * nsalloc - Named object allocation/deallocation
  */
-
 struct acpi_namespace_node *
 acpi_ns_create_node (
 	u32                             name);
@@ -189,6 +162,10 @@
 	struct acpi_namespace_node      *parent_handle);
 
 void
+acpi_ns_delete_namespace_by_owner (
+	u16                             table_id);
+
+void
 acpi_ns_detach_object (
 	struct acpi_namespace_node      *node);
 
@@ -201,36 +178,16 @@
 	char                            *name1,
 	char                            *name2);
 
-void
-acpi_ns_remove_reference (
-	struct acpi_namespace_node      *node);
-
 
 /*
- * Namespace modification - nsmodify
+ * nsdump - Namespace dump/print utilities
  */
-
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ns_unload_namespace (
-	acpi_handle                     handle);
-
-acpi_status
-acpi_ns_delete_subtree (
-	acpi_handle                     start_handle);
-#endif
-
-
-/*
- * Namespace dump/print utilities - nsdump
- */
-
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_ns_dump_tables (
 	acpi_handle                     search_base,
 	u32                             max_depth);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 void
 acpi_ns_dump_entry (
@@ -249,19 +206,6 @@
 	u32                             num_segments,
 	char                            *pathname);
 
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ns_dump_one_device (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
-
-void
-acpi_ns_dump_root_devices (
-	void);
-#endif  /*  ACPI_FUTURE_USAGE  */
-
 acpi_status
 acpi_ns_dump_one_object (
 	acpi_handle                     obj_handle,
@@ -269,7 +213,7 @@
 	void                            *context,
 	void                            **return_value);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_ns_dump_objects (
 	acpi_object_type                type,
@@ -277,13 +221,12 @@
 	u32                             max_depth,
 	u32                             ownder_id,
 	acpi_handle                     start_handle);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 
 /*
- * Namespace evaluation functions - nseval
+ * nseval - Namespace evaluation functions
  */
-
 acpi_status
 acpi_ns_evaluate_by_handle (
 	struct acpi_parameter_info      *info);
@@ -298,40 +241,14 @@
 	char                            *pathname,
 	struct acpi_parameter_info      *info);
 
-acpi_status
-acpi_ns_execute_control_method (
-	struct acpi_parameter_info      *info);
-
-acpi_status
-acpi_ns_get_object_value (
-	struct acpi_parameter_info      *info);
-
-
-/*
- * Parent/Child/Peer utility functions
- */
-
-#ifdef ACPI_FUTURE_USAGE
-acpi_name
-acpi_ns_find_parent_name (
-	struct acpi_namespace_node      *node_to_search);
-#endif
-
 
 /*
- * Name and Scope manipulation - nsnames
+ * nsnames - Name and Scope manipulation
  */
-
 u32
 acpi_ns_opens_scope (
 	acpi_object_type                type);
 
-void
-acpi_ns_build_external_path (
-	struct acpi_namespace_node      *node,
-	acpi_size                       size,
-	char                            *name_buffer);
-
 char *
 acpi_ns_get_external_pathname (
 	struct acpi_namespace_node      *node);
@@ -363,9 +280,8 @@
 
 
 /*
- * Object management for namespace nodes - nsobject
+ * nsobject - Object management for namespace nodes
  */
-
 acpi_status
 acpi_ns_attach_object (
 	struct acpi_namespace_node      *node,
@@ -399,9 +315,8 @@
 
 
 /*
- * Namespace searching and entry - nssearch
+ * nssearch - Namespace searching and entry
  */
-
 acpi_status
 acpi_ns_search_and_enter (
 	u32                             entry_name,
@@ -428,17 +343,12 @@
 
 
 /*
- * Utility functions - nsutils
+ * nsutils - Utility functions
  */
-
 u8
 acpi_ns_valid_root_prefix (
 	char                            prefix);
 
-u8
-acpi_ns_valid_path_separator (
-	char                            sep);
-
 acpi_object_type
 acpi_ns_get_type (
 	struct acpi_namespace_node      *node);
@@ -510,6 +420,5 @@
 struct acpi_namespace_node *
 acpi_ns_get_next_valid_node (
 	struct acpi_namespace_node      *node);
-
 
 #endif /* __ACNAMESP_H__ */
diff -Nru a/include/acpi/acobject.h b/include/acpi/acobject.h
--- a/include/acpi/acobject.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acobject.h	2005-04-19 01:34:14 -04:00
@@ -133,6 +133,7 @@
 	acpi_integer                            value;
 };
 
+
 /*
  * Note: The String and Buffer object must be identical through the Pointer
  * element.  There is code that depends on this.
@@ -467,7 +468,6 @@
  * union acpi_descriptor - objects that share a common descriptor identifier
  *
  *****************************************************************************/
-
 
 /* Object descriptor types */
 
diff -Nru a/include/acpi/acopcode.h b/include/acpi/acopcode.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/include/acpi/acopcode.h	2005-04-19 01:34:14 -04:00
@@ -0,0 +1,325 @@
+/******************************************************************************
+ *
+ * Name: acopcode.h - AML opcode information for the AML parser and interpreter
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2005, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACOPCODE_H__
+#define __ACOPCODE_H__
+
+#define MAX_EXTENDED_OPCODE         0x88
+#define NUM_EXTENDED_OPCODE         (MAX_EXTENDED_OPCODE + 1)
+#define MAX_INTERNAL_OPCODE
+#define NUM_INTERNAL_OPCODE         (MAX_INTERNAL_OPCODE + 1)
+
+/* Used for non-assigned opcodes */
+
+#define _UNK                        0x6B
+
+/*
+ * Reserved ASCII characters.  Do not use any of these for
+ * internal opcodes, since they are used to differentiate
+ * name strings from AML opcodes
+ */
+#define _ASC                        0x6C
+#define _NAM                        0x6C
+#define _PFX                        0x6D
+
+
+/*
+ * All AML opcodes and the parse-time arguments for each.  Used by the AML
+ * parser  Each list is compressed into a 32-bit number and stored in the
+ * master opcode table (in psopcode.c).
+ */
+#define ARGP_ACCESSFIELD_OP             ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_ACQUIRE_OP                 ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_WORDDATA)
+#define ARGP_ADD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_ALIAS_OP                   ARGP_LIST2 (ARGP_NAMESTRING, ARGP_NAME)
+#define ARGP_ARG0                       ARG_NONE
+#define ARGP_ARG1                       ARG_NONE
+#define ARGP_ARG2                       ARG_NONE
+#define ARGP_ARG3                       ARG_NONE
+#define ARGP_ARG4                       ARG_NONE
+#define ARGP_ARG5                       ARG_NONE
+#define ARGP_ARG6                       ARG_NONE
+#define ARGP_BANK_FIELD_OP              ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_BIT_AND_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NAND_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NOT_OP                 ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_BIT_OR_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_XOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BREAK_OP                   ARG_NONE
+#define ARGP_BREAK_POINT_OP             ARG_NONE
+#define ARGP_BUFFER_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_BYTELIST)
+#define ARGP_BYTE_OP                    ARGP_LIST1 (ARGP_BYTEDATA)
+#define ARGP_BYTELIST_OP                ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_CONCAT_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_CONCAT_RES_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_COND_REF_OF_OP             ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SUPERNAME)
+#define ARGP_CONTINUE_OP                ARG_NONE
+#define ARGP_COPY_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SIMPLENAME)
+#define ARGP_CREATE_BIT_FIELD_OP        ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_BYTE_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_DWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_FIELD_OP            ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_NAME)
+#define ARGP_CREATE_QWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_WORD_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_DATA_REGION_OP             ARGP_LIST4 (ARGP_NAME,       ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_DEBUG_OP                   ARG_NONE
+#define ARGP_DECREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_DEREF_OF_OP                ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_DEVICE_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
+#define ARGP_DIVIDE_OP                  ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET,    ARGP_TARGET)
+#define ARGP_DWORD_OP                   ARGP_LIST1 (ARGP_DWORDDATA)
+#define ARGP_ELSE_OP                    ARGP_LIST2 (ARGP_PKGLENGTH,  ARGP_TERMLIST)
+#define ARGP_EVENT_OP                   ARGP_LIST1 (ARGP_NAME)
+#define ARGP_FATAL_OP                   ARGP_LIST3 (ARGP_BYTEDATA,   ARGP_DWORDDATA,     ARGP_TERMARG)
+#define ARGP_FIELD_OP                   ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_FIND_SET_LEFT_BIT_OP       ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_FIND_SET_RIGHT_BIT_OP      ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_FROM_BCD_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_IF_OP                      ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
+#define ARGP_INCREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_INDEX_FIELD_OP             ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_INDEX_OP                   ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_LAND_OP                    ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LEQUAL_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LGREATER_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LGREATEREQUAL_OP           ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LLESS_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LLESSEQUAL_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LNOT_OP                    ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_LNOTEQUAL_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LOAD_OP                    ARGP_LIST2 (ARGP_NAMESTRING, ARGP_SUPERNAME)
+#define ARGP_LOAD_TABLE_OP              ARGP_LIST6 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG,  ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_LOCAL0                     ARG_NONE
+#define ARGP_LOCAL1                     ARG_NONE
+#define ARGP_LOCAL2                     ARG_NONE
+#define ARGP_LOCAL3                     ARG_NONE
+#define ARGP_LOCAL4                     ARG_NONE
+#define ARGP_LOCAL5                     ARG_NONE
+#define ARGP_LOCAL6                     ARG_NONE
+#define ARGP_LOCAL7                     ARG_NONE
+#define ARGP_LOR_OP                     ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_MATCH_OP                   ARGP_LIST6 (ARGP_TERMARG,    ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_METHOD_OP                  ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_TERMLIST)
+#define ARGP_METHODCALL_OP              ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_MID_OP                     ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TARGET)
+#define ARGP_MOD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_MULTIPLY_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_MUTEX_OP                   ARGP_LIST2 (ARGP_NAME,       ARGP_BYTEDATA)
+#define ARGP_NAME_OP                    ARGP_LIST2 (ARGP_NAME,       ARGP_DATAOBJ)
+#define ARGP_NAMEDFIELD_OP              ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_NAMEPATH_OP                ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_NOOP_OP                    ARG_NONE
+#define ARGP_NOTIFY_OP                  ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
+#define ARGP_ONE_OP                     ARG_NONE
+#define ARGP_ONES_OP                    ARG_NONE
+#define ARGP_PACKAGE_OP                 ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_BYTEDATA,      ARGP_DATAOBJLIST)
+#define ARGP_POWER_RES_OP               ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_WORDDATA,  ARGP_OBJLIST)
+#define ARGP_PROCESSOR_OP               ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_DWORDDATA, ARGP_BYTEDATA,  ARGP_OBJLIST)
+#define ARGP_QWORD_OP                   ARGP_LIST1 (ARGP_QWORDDATA)
+#define ARGP_REF_OF_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_REGION_OP                  ARGP_LIST4 (ARGP_NAME,       ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_RELEASE_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_RESERVEDFIELD_OP           ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_RESET_OP                   ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_RETURN_OP                  ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_REVISION_OP                ARG_NONE
+#define ARGP_SCOPE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_TERMLIST)
+#define ARGP_SHIFT_LEFT_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_SHIFT_RIGHT_OP             ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_SIGNAL_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_SIZE_OF_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_SLEEP_OP                   ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_STALL_OP                   ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_STATICSTRING_OP            ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_STORE_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_SUPERNAME)
+#define ARGP_STRING_OP                  ARGP_LIST1 (ARGP_CHARLIST)
+#define ARGP_SUBTRACT_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_THERMAL_ZONE_OP            ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
+#define ARGP_TIMER_OP                   ARG_NONE
+#define ARGP_TO_BCD_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_BUFFER_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_DEC_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_HEX_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_INTEGER_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_STRING_OP               ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_TYPE_OP                    ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_UNLOAD_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_VAR_PACKAGE_OP             ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_DATAOBJLIST)
+#define ARGP_WAIT_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
+#define ARGP_WHILE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
+#define ARGP_WORD_OP                    ARGP_LIST1 (ARGP_WORDDATA)
+#define ARGP_ZERO_OP                    ARG_NONE
+
+
+/*
+ * All AML opcodes and the runtime arguments for each.  Used by the AML
+ * interpreter  Each list is compressed into a 32-bit number and stored
+ * in the master opcode table (in psopcode.c).
+ *
+ * (Used by prep_operands procedure and the ASL Compiler)
+ */
+#define ARGI_ACCESSFIELD_OP             ARGI_INVALID_OPCODE
+#define ARGI_ACQUIRE_OP                 ARGI_LIST2 (ARGI_MUTEX,      ARGI_INTEGER)
+#define ARGI_ADD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_ALIAS_OP                   ARGI_INVALID_OPCODE
+#define ARGI_ARG0                       ARG_NONE
+#define ARGI_ARG1                       ARG_NONE
+#define ARGI_ARG2                       ARG_NONE
+#define ARGI_ARG3                       ARG_NONE
+#define ARGI_ARG4                       ARG_NONE
+#define ARGI_ARG5                       ARG_NONE
+#define ARGI_ARG6                       ARG_NONE
+#define ARGI_BANK_FIELD_OP              ARGI_INVALID_OPCODE
+#define ARGI_BIT_AND_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NAND_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NOT_OP                 ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_BIT_OR_OP                  ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_XOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BREAK_OP                   ARG_NONE
+#define ARGI_BREAK_POINT_OP             ARG_NONE
+#define ARGI_BUFFER_OP                  ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_BYTE_OP                    ARGI_INVALID_OPCODE
+#define ARGI_BYTELIST_OP                ARGI_INVALID_OPCODE
+#define ARGI_CONCAT_OP                  ARGI_LIST3 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA,   ARGI_TARGETREF)
+#define ARGI_CONCAT_RES_OP              ARGI_LIST3 (ARGI_BUFFER,     ARGI_BUFFER,        ARGI_TARGETREF)
+#define ARGI_COND_REF_OF_OP             ARGI_LIST2 (ARGI_OBJECT_REF, ARGI_TARGETREF)
+#define ARGI_CONTINUE_OP                ARGI_INVALID_OPCODE
+#define ARGI_COPY_OP                    ARGI_LIST2 (ARGI_ANYTYPE,    ARGI_SIMPLE_TARGET)
+#define ARGI_CREATE_BIT_FIELD_OP        ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_BYTE_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_DWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_FIELD_OP            ARGI_LIST4 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_INTEGER,      ARGI_REFERENCE)
+#define ARGI_CREATE_QWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_WORD_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_DATA_REGION_OP             ARGI_LIST3 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING)
+#define ARGI_DEBUG_OP                   ARG_NONE
+#define ARGI_DECREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
+#define ARGI_DEREF_OF_OP                ARGI_LIST1 (ARGI_REF_OR_STRING)
+#define ARGI_DEVICE_OP                  ARGI_INVALID_OPCODE
+#define ARGI_DIVIDE_OP                  ARGI_LIST4 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF,    ARGI_TARGETREF)
+#define ARGI_DWORD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_ELSE_OP                    ARGI_INVALID_OPCODE
+#define ARGI_EVENT_OP                   ARGI_INVALID_OPCODE
+#define ARGI_FATAL_OP                   ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_INTEGER)
+#define ARGI_FIELD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_FIND_SET_LEFT_BIT_OP       ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_FIND_SET_RIGHT_BIT_OP      ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_FROM_BCD_OP                ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_IF_OP                      ARGI_INVALID_OPCODE
+#define ARGI_INCREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
+#define ARGI_INDEX_FIELD_OP             ARGI_INVALID_OPCODE
+#define ARGI_INDEX_OP                   ARGI_LIST3 (ARGI_COMPLEXOBJ, ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_LAND_OP                    ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_LEQUAL_OP                  ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LGREATER_OP                ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LGREATEREQUAL_OP           ARGI_INVALID_OPCODE
+#define ARGI_LLESS_OP                   ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LLESSEQUAL_OP              ARGI_INVALID_OPCODE
+#define ARGI_LNOT_OP                    ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_LNOTEQUAL_OP               ARGI_INVALID_OPCODE
+#define ARGI_LOAD_OP                    ARGI_LIST2 (ARGI_REGION_OR_FIELD,ARGI_TARGETREF)
+#define ARGI_LOAD_TABLE_OP              ARGI_LIST6 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING,       ARGI_STRING,    ARGI_STRING, ARGI_ANYTYPE)
+#define ARGI_LOCAL0                     ARG_NONE
+#define ARGI_LOCAL1                     ARG_NONE
+#define ARGI_LOCAL2                     ARG_NONE
+#define ARGI_LOCAL3                     ARG_NONE
+#define ARGI_LOCAL4                     ARG_NONE
+#define ARGI_LOCAL5                     ARG_NONE
+#define ARGI_LOCAL6                     ARG_NONE
+#define ARGI_LOCAL7                     ARG_NONE
+#define ARGI_LOR_OP                     ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_MATCH_OP                   ARGI_LIST6 (ARGI_PACKAGE,    ARGI_INTEGER,   ARGI_COMPUTEDATA,      ARGI_INTEGER,ARGI_COMPUTEDATA,ARGI_INTEGER)
+#define ARGI_METHOD_OP                  ARGI_INVALID_OPCODE
+#define ARGI_METHODCALL_OP              ARGI_INVALID_OPCODE
+#define ARGI_MID_OP                     ARGI_LIST4 (ARGI_BUFFER_OR_STRING,ARGI_INTEGER,  ARGI_INTEGER,      ARGI_TARGETREF)
+#define ARGI_MOD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_MULTIPLY_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_MUTEX_OP                   ARGI_INVALID_OPCODE
+#define ARGI_NAME_OP                    ARGI_INVALID_OPCODE
+#define ARGI_NAMEDFIELD_OP              ARGI_INVALID_OPCODE
+#define ARGI_NAMEPATH_OP                ARGI_INVALID_OPCODE
+#define ARGI_NOOP_OP                    ARG_NONE
+#define ARGI_NOTIFY_OP                  ARGI_LIST2 (ARGI_DEVICE_REF, ARGI_INTEGER)
+#define ARGI_ONE_OP                     ARG_NONE
+#define ARGI_ONES_OP                    ARG_NONE
+#define ARGI_PACKAGE_OP                 ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_POWER_RES_OP               ARGI_INVALID_OPCODE
+#define ARGI_PROCESSOR_OP               ARGI_INVALID_OPCODE
+#define ARGI_QWORD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_REF_OF_OP                  ARGI_LIST1 (ARGI_OBJECT_REF)
+#define ARGI_REGION_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_RELEASE_OP                 ARGI_LIST1 (ARGI_MUTEX)
+#define ARGI_RESERVEDFIELD_OP           ARGI_INVALID_OPCODE
+#define ARGI_RESET_OP                   ARGI_LIST1 (ARGI_EVENT)
+#define ARGI_RETURN_OP                  ARGI_INVALID_OPCODE
+#define ARGI_REVISION_OP                ARG_NONE
+#define ARGI_SCOPE_OP                   ARGI_INVALID_OPCODE
+#define ARGI_SHIFT_LEFT_OP              ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_SHIFT_RIGHT_OP             ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_SIGNAL_OP                  ARGI_LIST1 (ARGI_EVENT)
+#define ARGI_SIZE_OF_OP                 ARGI_LIST1 (ARGI_DATAOBJECT)
+#define ARGI_SLEEP_OP                   ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_STALL_OP                   ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_STATICSTRING_OP            ARGI_INVALID_OPCODE
+#define ARGI_STORE_OP                   ARGI_LIST2 (ARGI_DATAREFOBJ, ARGI_TARGETREF)
+#define ARGI_STRING_OP                  ARGI_INVALID_OPCODE
+#define ARGI_SUBTRACT_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_THERMAL_ZONE_OP            ARGI_INVALID_OPCODE
+#define ARGI_TIMER_OP                   ARG_NONE
+#define ARGI_TO_BCD_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_FIXED_TARGET)
+#define ARGI_TO_BUFFER_OP               ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_DEC_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_HEX_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_INTEGER_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_STRING_OP               ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_FIXED_TARGET)
+#define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_ANYTYPE)
+#define ARGI_UNLOAD_OP                  ARGI_LIST1 (ARGI_DDBHANDLE)
+#define ARGI_VAR_PACKAGE_OP             ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_WAIT_OP                    ARGI_LIST2 (ARGI_EVENT,      ARGI_INTEGER)
+#define ARGI_WHILE_OP                   ARGI_INVALID_OPCODE
+#define ARGI_WORD_OP                    ARGI_INVALID_OPCODE
+#define ARGI_ZERO_OP                    ARG_NONE
+
+#endif /* __ACOPCODE_H__ */
diff -Nru a/include/acpi/acparser.h b/include/acpi/acparser.h
--- a/include/acpi/acparser.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acparser.h	2005-04-19 01:34:14 -04:00
@@ -64,8 +64,17 @@
 
 #define ACPI_PARSE_DEFERRED_OP          0x0100
 
-/* Parser external interfaces */
 
+/******************************************************************************
+ *
+ * Parser interfaces
+ *
+ *****************************************************************************/
+
+
+/*
+ * psxface - Parser external interfaces
+ */
 acpi_status
 acpi_psx_load_table (
 	u8                              *pcode_addr,
@@ -76,23 +85,13 @@
 	struct acpi_parameter_info      *info);
 
 
-/******************************************************************************
- *
- * Parser interfaces
- *
- *****************************************************************************/
-
-
-/* psargs - Parse AML opcode arguments */
-
+/*
+ * psargs - Parse AML opcode arguments
+ */
 u8 *
 acpi_ps_get_next_package_end (
 	struct acpi_parse_state         *parser_state);
 
-u32
-acpi_ps_get_next_package_length (
-	struct acpi_parse_state         *parser_state);
-
 char *
 acpi_ps_get_next_namestring (
 	struct acpi_parse_state         *parser_state);
@@ -110,10 +109,6 @@
 	union acpi_parse_object         *arg,
 	u8                              method_call);
 
-union acpi_parse_object *
-acpi_ps_get_next_field (
-	struct acpi_parse_state         *parser_state);
-
 acpi_status
 acpi_ps_get_next_arg (
 	struct acpi_walk_state          *walk_state,
@@ -122,8 +117,9 @@
 	union acpi_parse_object         **return_arg);
 
 
-/* psfind */
-
+/*
+ * psfind
+ */
 union acpi_parse_object *
 acpi_ps_find_name (
 	union acpi_parse_object         *scope,
@@ -135,8 +131,9 @@
 	union acpi_parse_object         *op);
 
 
-/* psopcode - AML Opcode information */
-
+/*
+ * psopcode - AML Opcode information
+ */
 const struct acpi_opcode_info *
 acpi_ps_get_opcode_info (
 	u16                             opcode);
@@ -146,56 +143,25 @@
 	u16                             opcode);
 
 
-/* psparse - top level parsing routines */
-
-u32
-acpi_ps_get_opcode_size (
-	u32                             opcode);
-
-void
-acpi_ps_complete_this_op (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *op);
-
-acpi_status
-acpi_ps_next_parse_state (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *op,
-	acpi_status                     callback_status);
-
-acpi_status
-acpi_ps_find_object (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         **out_op);
-
-void
-acpi_ps_delete_parse_tree (
-	union acpi_parse_object         *root);
-
-acpi_status
-acpi_ps_parse_loop (
-	struct acpi_walk_state          *walk_state);
-
+/*
+ * psparse - top level parsing routines
+ */
 acpi_status
 acpi_ps_parse_aml (
 	struct acpi_walk_state          *walk_state);
 
-acpi_status
-acpi_ps_parse_table (
-	u8                              *aml,
-	u32                             aml_size,
-	acpi_parse_downwards            descending_callback,
-	acpi_parse_upwards              ascending_callback,
-	union acpi_parse_object         **root_object);
+u32
+acpi_ps_get_opcode_size (
+	u32                             opcode);
 
 u16
 acpi_ps_peek_opcode (
 	struct acpi_parse_state         *state);
 
 
-/* psscope - Scope stack management routines */
-
-
+/*
+ * psscope - Scope stack management routines
+ */
 acpi_status
 acpi_ps_init_scope (
 	struct acpi_parse_state         *parser_state,
@@ -228,8 +194,9 @@
 	struct acpi_parse_state         *state);
 
 
-/* pstree - parse tree manipulation routines */
-
+/*
+ * pstree - parse tree manipulation routines
+ */
 void
 acpi_ps_append_arg(
 	union acpi_parse_object         *op,
@@ -247,20 +214,17 @@
 	union acpi_parse_object         *op,
 	u32                              argn);
 
-#ifdef ACPI_FUTURE_USAGE
-union acpi_parse_object *
-acpi_ps_get_child (
-	union acpi_parse_object         *op);
-
+#ifdef	ACPI_FUTURE_USAGE
 union acpi_parse_object *
 acpi_ps_get_depth_next (
 	union acpi_parse_object         *origin,
 	union acpi_parse_object         *op);
-#endif  /*  ACPI_FUTURE_USAGE  */
-
+#endif	/* ACPI_FUTURE_USAGE */
 
-/* pswalk - parse tree walk routines */
 
+/*
+ * pswalk - parse tree walk routines
+ */
 acpi_status
 acpi_ps_walk_parsed_aml (
 	union acpi_parse_object         *start_op,
@@ -283,9 +247,14 @@
 acpi_ps_delete_completed_op (
 	struct acpi_walk_state          *walk_state);
 
+void
+acpi_ps_delete_parse_tree (
+	union acpi_parse_object         *root);
 
-/* psutils - parser utilities */
 
+/*
+ * psutils - parser utilities
+ */
 union acpi_parse_object *
 acpi_ps_create_scope_op (
 	void);
@@ -303,12 +272,6 @@
 acpi_ps_free_op (
 	union acpi_parse_object         *op);
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-void
-acpi_ps_delete_parse_cache (
-	void);
-#endif
-
 u8
 acpi_ps_is_leading_char (
 	u32                             c);
@@ -317,20 +280,27 @@
 acpi_ps_is_prefix_char (
 	u32                             c);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 u32
 acpi_ps_get_name(
 	union acpi_parse_object         *op);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 void
 acpi_ps_set_name(
 	union acpi_parse_object         *op,
 	u32                             name);
 
+#ifdef ACPI_ENABLE_OBJECT_CACHE
+void
+acpi_ps_delete_parse_cache (
+	void);
+#endif
 
-/* psdump - display parser tree */
 
+/*
+ * psdump - display parser tree
+ */
 u32
 acpi_ps_sprint_path (
 	char                            *buffer_start,
diff -Nru a/include/acpi/acpi.h b/include/acpi/acpi.h
--- a/include/acpi/acpi.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acpi.h	2005-04-19 01:34:14 -04:00
@@ -49,6 +49,7 @@
  * We put them here because we don't want to duplicate them
  * in the rest of the source code again and again.
  */
+#include "acnames.h"            /* Global ACPI names and strings */
 #include "acconfig.h"           /* Configuration constants */
 #include "platform/acenv.h"     /* Target environment specific items */
 #include "actypes.h"            /* Fundamental common data types */
diff -Nru a/include/acpi/acpiosxf.h b/include/acpi/acpiosxf.h
--- a/include/acpi/acpiosxf.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acpiosxf.h	2005-04-19 01:34:14 -04:00
@@ -79,7 +79,6 @@
 /*
  * OSL Initialization and shutdown primitives
  */
-
 acpi_status
 acpi_os_initialize (
 	void);
@@ -92,7 +91,6 @@
 /*
  * ACPI Table interfaces
  */
-
 acpi_status
 acpi_os_get_root_pointer (
 	u32                             flags,
@@ -112,7 +110,6 @@
 /*
  * Synchronization primitives
  */
-
 acpi_status
 acpi_os_create_semaphore (
 	u32                             max_units,
@@ -156,7 +153,6 @@
 /*
  * Memory allocation and mapping
  */
-
 void *
 acpi_os_allocate (
 	acpi_size                       size);
@@ -187,7 +183,6 @@
 /*
  * Interrupt handlers
  */
-
 acpi_status
 acpi_os_install_interrupt_handler (
 	u32                             gsi,
@@ -203,7 +198,6 @@
 /*
  * Threads and Scheduling
  */
-
 u32
 acpi_os_get_thread_id (
 	void);
@@ -234,7 +228,6 @@
 /*
  * Platform and hardware-independent I/O interfaces
  */
-
 acpi_status
 acpi_os_read_port (
 	acpi_io_address                 address,
@@ -251,7 +244,6 @@
 /*
  * Platform and hardware-independent physical memory interfaces
  */
-
 acpi_status
 acpi_os_read_memory (
 	acpi_physical_address           address,
@@ -270,7 +262,6 @@
  * Note: Can't use "Register" as a parameter, changed to "Reg" --
  * certain compilers complain.
  */
-
 acpi_status
 acpi_os_read_pci_configuration (
 	struct acpi_pci_id              *pci_id,
@@ -288,7 +279,6 @@
 /*
  * Interim function needed for PCI IRQ routing
  */
-
 void
 acpi_os_derive_pci_id(
 	acpi_handle                     rhandle,
@@ -298,7 +288,6 @@
 /*
  * Miscellaneous
  */
-
 u8
 acpi_os_readable (
 	void                            *pointer,
@@ -323,7 +312,6 @@
 /*
  * Debug print routines
  */
-
 void ACPI_INTERNAL_VAR_XFACE
 acpi_os_printf (
 	const char                      *format,
@@ -339,11 +327,10 @@
 	void                            *destination);
 
 
+#ifdef ACPI_FUTURE_USAGE
 /*
  * Debug input
  */
-
-#ifdef ACPI_FUTURE_USAGE
 u32
 acpi_os_get_line (
 	char                            *buffer);
@@ -353,7 +340,6 @@
 /*
  * Directory manipulation
  */
-
 void *
 acpi_os_open_directory (
 	char                            *pathname,
@@ -377,13 +363,11 @@
 /*
  * Debug
  */
-
 void
 acpi_os_dbg_assert(
 	void                            *failed_assertion,
 	void                            *file_name,
 	u32                             line_number,
 	char                            *message);
-
 
 #endif /* __ACPIOSXF_H__ */
diff -Nru a/include/acpi/acpixf.h b/include/acpi/acpixf.h
--- a/include/acpi/acpixf.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acpixf.h	2005-04-19 01:34:14 -04:00
@@ -50,10 +50,9 @@
 #include "actbl.h"
 
 
- /*
+/*
  * Global interfaces
  */
-
 acpi_status
 acpi_initialize_subsystem (
 	void);
@@ -106,9 +105,8 @@
 #endif
 
 /*
- * ACPI Memory manager
+ * ACPI Memory managment
  */
-
 void *
 acpi_allocate (
 	u32                             size);
@@ -125,7 +123,6 @@
 /*
  * ACPI table manipulation interfaces
  */
-
 acpi_status
 acpi_find_root_pointer (
 	u32                             flags,
@@ -168,7 +165,6 @@
 /*
  * Namespace and name interfaces
  */
-
 acpi_status
 acpi_walk_namespace (
 	acpi_object_type                type,
@@ -218,7 +214,6 @@
 /*
  * Object manipulation and enumeration
  */
-
 acpi_status
 acpi_evaluate_object (
 	acpi_handle                     object,
@@ -262,7 +257,6 @@
 /*
  * Event handler interfaces
  */
-
 acpi_status
 acpi_install_fixed_event_handler (
 	u32                             acpi_event,
@@ -319,7 +313,6 @@
 /*
  * Event interfaces
  */
-
 acpi_status
 acpi_acquire_global_lock (
 	u16                             timeout,
@@ -404,7 +397,6 @@
 /*
  * Resource interfaces
  */
-
 typedef
 acpi_status (*ACPI_WALK_RESOURCE_CALLBACK) (
 	struct acpi_resource            *resource,
@@ -448,7 +440,6 @@
 /*
  * Hardware (ACPI device) interfaces
  */
-
 acpi_status
 acpi_get_register (
 	u32                             register_id,
diff -Nru a/include/acpi/acresrc.h b/include/acpi/acresrc.h
--- a/include/acpi/acresrc.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acresrc.h	2005-04-19 01:34:14 -04:00
@@ -48,7 +48,6 @@
 /*
  *  Function prototypes called from Acpi* APIs
  */
-
 acpi_status
 acpi_rs_get_prt_method_data (
 	acpi_handle                     handle,
@@ -60,12 +59,12 @@
 	acpi_handle                     handle,
 	struct acpi_buffer              *ret_buffer);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 acpi_status
 acpi_rs_get_prs_method_data (
 	acpi_handle                     handle,
 	struct acpi_buffer              *ret_buffer);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 acpi_status
 acpi_rs_get_method_data (
@@ -95,61 +94,9 @@
 
 
 /*
- * Function prototypes called from acpi_rs_create*
+ * rsdump
  */
-#ifdef ACPI_FUTURE_USAGE
-void
-acpi_rs_dump_irq (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_address16 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_address32 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_address64 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_dma (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_io (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_extended_irq (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_fixed_io (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_fixed_memory32 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_memory24 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_memory32 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_start_depend_fns (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_vendor_specific (
-	union acpi_resource_data        *data);
-
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_rs_dump_resource_list (
 	struct acpi_resource            *resource);
@@ -157,8 +104,12 @@
 void
 acpi_rs_dump_irq_list (
 	u8                              *route_table);
-#endif  /*  ACPI_FUTURE_USAGE  */
+#endif	/* ACPI_FUTURE_USAGE */
 
+
+/*
+ * rscalc
+ */
 acpi_status
 acpi_rs_get_byte_stream_start (
 	u8                              *byte_stream_buffer,
diff -Nru a/include/acpi/acstruct.h b/include/acpi/acstruct.h
--- a/include/acpi/acstruct.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acstruct.h	2005-04-19 01:34:14 -04:00
@@ -56,7 +56,6 @@
  * Walk state - current state of a parse tree walk.  Used for both a leisurely stroll through
  * the tree (for whatever reason), and for control method execution.
  */
-
 #define ACPI_NEXT_OP_DOWNWARD       1
 #define ACPI_NEXT_OP_UPWARD         2
 
diff -Nru a/include/acpi/actables.h b/include/acpi/actables.h
--- a/include/acpi/actables.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/actables.h	2005-04-19 01:34:14 -04:00
@@ -50,17 +50,9 @@
 #define SIZE_IN_HEADER          0
 
 
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_tb_handle_to_object (
-	u16                             table_id,
-	struct acpi_table_desc          **table_desc);
-#endif
-
 /*
  * tbconvrt - Table conversion routines
  */
-
 acpi_status
 acpi_tb_convert_to_xsdt (
 	struct acpi_table_desc          *table_info);
@@ -78,10 +70,10 @@
 	struct rsdp_descriptor          *RSDP,
 	struct acpi_table_header        *RSDT);
 
+
 /*
  * tbget - Table "get" routines
  */
-
 acpi_status
 acpi_tb_get_table (
 	struct acpi_pointer             *address,
@@ -99,17 +91,6 @@
 	struct acpi_table_desc          *table_info);
 
 acpi_status
-acpi_tb_get_this_table (
-	struct acpi_pointer             *address,
-	struct acpi_table_header        *header,
-	struct acpi_table_desc          *table_info);
-
-acpi_status
-acpi_tb_table_override (
-	struct acpi_table_header        *header,
-	struct acpi_table_desc          *table_info);
-
-acpi_status
 acpi_tb_get_table_ptr (
 	acpi_table_type                 table_type,
 	u32                             instance,
@@ -127,36 +108,23 @@
 acpi_tb_validate_rsdt (
 	struct acpi_table_header        *table_ptr);
 
+
+/*
+ * tbgetall - get multiple required tables
+ */
 acpi_status
 acpi_tb_get_required_tables (
 	void);
 
-acpi_status
-acpi_tb_get_primary_table (
-	struct acpi_pointer             *address,
-	struct acpi_table_desc          *table_info);
-
-acpi_status
-acpi_tb_get_secondary_table (
-	struct acpi_pointer             *address,
-	acpi_string                     signature,
-	struct acpi_table_desc          *table_info);
 
 /*
  * tbinstall - Table installation
  */
-
 acpi_status
 acpi_tb_install_table (
 	struct acpi_table_desc          *table_info);
 
 acpi_status
-acpi_tb_match_signature (
-	char                            *signature,
-	struct acpi_table_desc          *table_info,
-	u8                              search_type);
-
-acpi_status
 acpi_tb_recognize_table (
 	struct acpi_table_desc          *table_info,
 	u8                              search_type);
@@ -170,7 +138,6 @@
 /*
  * tbremove - Table removal and deletion
  */
-
 void
 acpi_tb_delete_all_tables (
 	void);
@@ -189,35 +156,23 @@
 
 
 /*
- * tbrsd - RSDP, RSDT utilities
+ * tbxfroot - RSDP, RSDT utilities
  */
+acpi_status
+acpi_tb_find_table (
+	char                            *signature,
+	char                            *oem_id,
+	char                            *oem_table_id,
+	struct acpi_table_header        **table_ptr);
 
 acpi_status
 acpi_tb_get_table_rsdt (
 	void);
 
-u8 *
-acpi_tb_scan_memory_for_rsdp (
-	u8                              *start_address,
-	u32                             length);
-
-acpi_status
-acpi_tb_find_rsdp (
-	struct acpi_table_desc          *table_info,
-	u32                             flags);
-
 
 /*
  * tbutils - common table utilities
  */
-
-acpi_status
-acpi_tb_find_table (
-	char                            *signature,
-	char                            *oem_id,
-	char                            *oem_table_id,
-	struct acpi_table_header        **table_ptr);
-
 acpi_status
 acpi_tb_verify_table_checksum (
 	struct acpi_table_header        *table_header);
@@ -230,6 +185,5 @@
 acpi_status
 acpi_tb_validate_table_header (
 	struct acpi_table_header        *table_header);
-
 
 #endif /* __ACTABLES_H__ */
diff -Nru a/include/acpi/actbl.h b/include/acpi/actbl.h
--- a/include/acpi/actbl.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/actbl.h	2005-04-19 01:34:14 -04:00
@@ -133,7 +133,6 @@
 #define DUAL_PIC                0
 #define MULTIPLE_APIC           1
 
-
 /* Master MADT */
 
 struct multiple_apic_table
@@ -143,7 +142,6 @@
 	u32                             PCATcompat      : 1;    /* A one indicates system also has dual 8259s */
 	u32                             reserved1       : 31;
 };
-
 
 /* Values for Type in APIC_HEADER_DEF */
 
diff -Nru a/include/acpi/actypes.h b/include/acpi/actypes.h
--- a/include/acpi/actypes.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/actypes.h	2005-04-19 01:34:14 -04:00
@@ -478,7 +478,6 @@
 #define ACPI_TYPE_INVALID               0x1E
 #define ACPI_TYPE_NOT_FOUND             0xFF
 
-
 /*
  * Bitmapped ACPI types.  Used internally only
  */
@@ -803,7 +802,6 @@
 /*
  * Types specific to the OS service interfaces
  */
-
 typedef u32
 (ACPI_SYSTEM_XFACE *acpi_osd_handler) (
 	void                            *context);
diff -Nru a/include/acpi/acutils.h b/include/acpi/acutils.h
--- a/include/acpi/acutils.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/acutils.h	2005-04-19 01:34:14 -04:00
@@ -52,13 +52,6 @@
 	union acpi_generic_state        *state,
 	void                            *context);
 
-acpi_status
-acpi_ut_walk_package_tree (
-	union acpi_operand_object       *source_object,
-	void                            *target_object,
-	acpi_pkg_callback               walk_callback,
-	void                            *context);
-
 struct acpi_pkg_info
 {
 	u8                              *free_space;
@@ -79,37 +72,13 @@
 #define DB_QWORD_DISPLAY    8
 
 
-/* Global initialization interfaces */
-
-void
-acpi_ut_init_globals (
-	void);
-
-void
-acpi_ut_terminate (
-	void);
-
-
 /*
- * ut_init - miscellaneous initialization and shutdown
+ * utglobal - Global data structures and procedures
  */
-
-acpi_status
-acpi_ut_hardware_initialize (
-	void);
-
 void
-acpi_ut_subsystem_shutdown (
-	void);
-
-acpi_status
-acpi_ut_validate_fadt (
+acpi_ut_init_globals (
 	void);
 
-/*
- * ut_global - Global data structures and procedures
- */
-
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
 char *
@@ -157,9 +126,24 @@
 
 
 /*
- * ut_clib - Local implementations of C library functions
+ * utinit - miscellaneous initialization and shutdown
  */
+acpi_status
+acpi_ut_hardware_initialize (
+	void);
+
+void
+acpi_ut_subsystem_shutdown (
+	void);
 
+acpi_status
+acpi_ut_validate_fadt (
+	void);
+
+
+/*
+ * utclib - Local implementations of C library functions
+ */
 #ifndef ACPI_USE_SYSTEM_CLIBRARY
 
 acpi_size
@@ -260,10 +244,10 @@
 
 #endif /* ACPI_USE_SYSTEM_CLIBRARY */
 
+
 /*
- * ut_copy - Object construction and conversion interfaces
+ * utcopy - Object construction and conversion interfaces
  */
-
 acpi_status
 acpi_ut_build_simple_object(
 	union acpi_operand_object       *obj,
@@ -278,30 +262,11 @@
 	u32                             *space_used);
 
 acpi_status
-acpi_ut_copy_ielement_to_eelement (
-	u8                              object_type,
-	union acpi_operand_object       *source_object,
-	union acpi_generic_state        *state,
-	void                            *context);
-
-acpi_status
-acpi_ut_copy_ielement_to_ielement (
-	u8                              object_type,
-	union acpi_operand_object       *source_object,
-	union acpi_generic_state        *state,
-	void                            *context);
-
-acpi_status
 acpi_ut_copy_iobject_to_eobject (
 	union acpi_operand_object       *obj,
 	struct acpi_buffer              *ret_buffer);
 
 acpi_status
-acpi_ut_copy_esimple_to_isimple(
-	union acpi_object               *user_obj,
-	union acpi_operand_object       **return_obj);
-
-acpi_status
 acpi_ut_copy_eobject_to_iobject (
 	union acpi_object               *obj,
 	union acpi_operand_object       **internal_obj);
@@ -312,17 +277,6 @@
 	union acpi_operand_object       *dest_obj);
 
 acpi_status
-acpi_ut_copy_ipackage_to_ipackage (
-	union acpi_operand_object       *source_obj,
-	union acpi_operand_object       *dest_obj,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
-acpi_ut_copy_simple_object (
-	union acpi_operand_object       *source_desc,
-	union acpi_operand_object       *dest_desc);
-
-acpi_status
 acpi_ut_copy_iobject_to_iobject (
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       **dest_desc,
@@ -330,9 +284,8 @@
 
 
 /*
- * ut_create - Object creation
+ * utcreate - Object creation
  */
-
 acpi_status
 acpi_ut_update_object_reference (
 	union acpi_operand_object       *object,
@@ -340,9 +293,8 @@
 
 
 /*
- * ut_debug - Debug interfaces
+ * utdebug - Debug interfaces
  */
-
 void
 acpi_ut_init_stack_ptr_trace (
 	void);
@@ -440,11 +392,14 @@
 
 
 /*
- * ut_delete - Object deletion
+ * utdelete - Object deletion and reference counts
  */
+void
+acpi_ut_add_reference (
+	union acpi_operand_object       *object);
 
 void
-acpi_ut_delete_internal_obj (
+acpi_ut_remove_reference (
 	union acpi_operand_object       *object);
 
 void
@@ -461,25 +416,8 @@
 
 
 /*
- * ut_eval - object evaluation
+ * uteval - object evaluation
  */
-
-/* Method name strings */
-
-#define METHOD_NAME__HID        "_HID"
-#define METHOD_NAME__CID        "_CID"
-#define METHOD_NAME__UID        "_UID"
-#define METHOD_NAME__ADR        "_ADR"
-#define METHOD_NAME__STA        "_STA"
-#define METHOD_NAME__REG        "_REG"
-#define METHOD_NAME__SEG        "_SEG"
-#define METHOD_NAME__BBN        "_BBN"
-#define METHOD_NAME__PRT        "_PRT"
-#define METHOD_NAME__CRS        "_CRS"
-#define METHOD_NAME__PRS        "_PRS"
-#define METHOD_NAME__PRW        "_PRW"
-
-
 acpi_status
 acpi_ut_osi_implementation (
 	struct acpi_walk_state          *walk_state);
@@ -522,39 +460,10 @@
 	struct acpi_namespace_node      *device_node,
 	u8                              *highest);
 
-/*
- * ut_mutex - mutual exclusion interfaces
- */
-
-acpi_status
-acpi_ut_mutex_initialize (
-	void);
-
-void
-acpi_ut_mutex_terminate (
-	void);
-
-acpi_status
-acpi_ut_create_mutex (
-	acpi_mutex_handle               mutex_id);
-
-acpi_status
-acpi_ut_delete_mutex (
-	acpi_mutex_handle               mutex_id);
-
-acpi_status
-acpi_ut_acquire_mutex (
-	acpi_mutex_handle               mutex_id);
-
-acpi_status
-acpi_ut_release_mutex (
-	acpi_mutex_handle               mutex_id);
-
 
 /*
- * ut_object - internal object create/delete/cache routines
+ * utobject - internal object create/delete/cache routines
  */
-
 union acpi_operand_object    *
 acpi_ut_create_internal_object_dbg (
 	char                            *module_name,
@@ -587,50 +496,15 @@
 acpi_ut_create_string_object (
 	acpi_size                       string_size);
 
-
-/*
- * ut_ref_cnt - Object reference count management
- */
-
-void
-acpi_ut_add_reference (
-	union acpi_operand_object       *object);
-
-void
-acpi_ut_remove_reference (
-	union acpi_operand_object       *object);
-
-/*
- * ut_size - Object size routines
- */
-
-acpi_status
-acpi_ut_get_simple_object_size (
-	union acpi_operand_object       *obj,
-	acpi_size                       *obj_length);
-
-acpi_status
-acpi_ut_get_package_object_size (
-	union acpi_operand_object       *obj,
-	acpi_size                       *obj_length);
-
 acpi_status
 acpi_ut_get_object_size(
 	union acpi_operand_object       *obj,
 	acpi_size                       *obj_length);
 
-acpi_status
-acpi_ut_get_element_length (
-	u8                              object_type,
-	union acpi_operand_object       *source_object,
-	union acpi_generic_state        *state,
-	void                            *context);
-
 
 /*
- * ut_state - Generic state creation/cache routines
+ * utstate - Generic state creation/cache routines
  */
-
 void
 acpi_ut_push_generic_state (
 	union acpi_generic_state        **list_head,
@@ -666,14 +540,14 @@
 	u16                             action,
 	union acpi_generic_state        **state_list);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 acpi_status
 acpi_ut_create_pkg_state_and_push (
 	void                            *internal_object,
 	void                            *external_object,
 	u16                             index,
 	union acpi_generic_state        **state_list);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 union acpi_generic_state *
 acpi_ut_create_control_state (
@@ -693,15 +567,10 @@
 	void);
 #endif
 
+
 /*
- * utmisc
+ * utmath
  */
-
-void
-acpi_ut_print_string (
-	char                            *string,
-	u8                              max_length);
-
 acpi_status
 acpi_ut_divide (
 	acpi_integer                    in_dividend,
@@ -716,6 +585,25 @@
 	acpi_integer                    *out_quotient,
 	u32                             *out_remainder);
 
+/*
+ * utmisc
+ */
+acpi_status
+acpi_ut_walk_package_tree (
+	union acpi_operand_object       *source_object,
+	void                            *target_object,
+	acpi_pkg_callback               walk_callback,
+	void                            *context);
+
+char *
+acpi_ut_strupr (
+	char                            *src_string);
+
+void
+acpi_ut_print_string (
+	char                            *string,
+	u8                              max_length);
+
 u8
 acpi_ut_valid_acpi_name (
 	u32                             name);
@@ -734,11 +622,21 @@
 
 #define ACPI_ANY_BASE        0
 
-#ifdef ACPI_FUTURE_USAGE
-char *
-acpi_ut_strupr (
-	char                            *src_string);
-#endif
+acpi_status
+acpi_ut_mutex_initialize (
+	void);
+
+void
+acpi_ut_mutex_terminate (
+	void);
+
+acpi_status
+acpi_ut_acquire_mutex (
+	acpi_mutex_handle               mutex_id);
+
+acpi_status
+acpi_ut_release_mutex (
+	acpi_mutex_handle               mutex_id);
 
 u8 *
 acpi_ut_get_resource_end_tag (
@@ -768,9 +666,8 @@
 
 
 /*
- * Utalloc - memory allocation and object caching
+ * utalloc - memory allocation and object caching
  */
-
 void *
 acpi_ut_acquire_from_cache (
 	u32                             list_id);
@@ -795,9 +692,6 @@
 	struct acpi_buffer              *buffer,
 	acpi_size                       required_length);
 
-
-/* Memory allocation functions */
-
 void *
 acpi_ut_allocate (
 	acpi_size                       size,
@@ -812,9 +706,7 @@
 	char                            *module,
 	u32                             line);
 
-
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
-
 void *
 acpi_ut_allocate_and_track (
 	acpi_size                       size,
@@ -836,40 +728,16 @@
 	char                            *module,
 	u32                             line);
 
-struct acpi_debug_mem_block *
-acpi_ut_find_allocation (
-	u32                             list_id,
-	void                            *allocation);
-
-acpi_status
-acpi_ut_track_allocation (
-	u32                             list_id,
-	struct acpi_debug_mem_block     *address,
-	acpi_size                       size,
-	u8                              alloc_type,
-	u32                             component,
-	char                            *module,
-	u32                             line);
-
-acpi_status
-acpi_ut_remove_allocation (
-	u32                             list_id,
-	struct acpi_debug_mem_block     *address,
-	u32                             component,
-	char                            *module,
-	u32                             line);
-
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_ut_dump_allocation_info (
 	void);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 void
 acpi_ut_dump_allocations (
 	u32                             component,
 	char                            *module);
 #endif
-
 
 #endif /* _ACUTILS_H */
diff -Nru a/include/acpi/amlcode.h b/include/acpi/amlcode.h
--- a/include/acpi/amlcode.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/amlcode.h	2005-04-19 01:34:14 -04:00
@@ -146,8 +146,7 @@
 
 /* prefixed opcodes */
 
-#define AML_EXTOP                   (u16) 0x005b
-
+#define AML_EXTOP                   (u16) 0x005b     /* prefix for 2-byte opcodes */
 
 #define AML_MUTEX_OP                (u16) 0x5b01
 #define AML_EVENT_OP                (u16) 0x5b02
@@ -194,7 +193,6 @@
  * Use only "Unknown" AML opcodes, don't attempt to use
  * any valid ACPI ASCII values (A-Z, 0-9, '-')
  */
-
 #define AML_INT_NAMEPATH_OP         (u16) 0x002d
 #define AML_INT_NAMEDFIELD_OP       (u16) 0x0030
 #define AML_INT_RESERVEDFIELD_OP    (u16) 0x0031
@@ -214,7 +212,6 @@
  * There can be up to 31 unique argument types
  * Zero is reserved as end-of-list indicator
  */
-
 #define ARGP_BYTEDATA               0x01
 #define ARGP_BYTELIST               0x02
 #define ARGP_CHARLIST               0x03
@@ -295,7 +292,6 @@
 /*
  * opcode groups and types
  */
-
 #define OPGRP_NAMED                 0x01
 #define OPGRP_FIELD                 0x02
 #define OPGRP_BYTELIST              0x04
@@ -381,6 +377,12 @@
 #define AML_TYPE_UNDEFINED          0x19
 #define AML_TYPE_BOGUS              0x1A
 
+/* AML Package Length encodings */
+
+#define ACPI_AML_PACKAGE_TYPE1      0x40
+#define ACPI_AML_PACKAGE_TYPE2      0x4000
+#define ACPI_AML_PACKAGE_TYPE3      0x400000
+#define ACPI_AML_PACKAGE_TYPE4      0x40000000
 
 /*
  * Opcode classes
diff -Nru a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h
--- a/include/acpi/platform/acenv.h	2005-04-19 01:34:14 -04:00
+++ b/include/acpi/platform/acenv.h	2005-04-19 01:34:14 -04:00
@@ -198,6 +198,7 @@
 #endif
 #endif /* !DEBUGGER_THREADING */
 
+
 /******************************************************************************
  *
  * C library configuration
@@ -209,7 +210,6 @@
  * Use the standard C library headers.
  * We want to keep these to a minimum.
  */
-
 #ifdef ACPI_USE_STANDARD_HEADERS
 /*
  * Use the standard headers from the standard locations
@@ -224,14 +224,8 @@
 /*
  * We will be linking to the standard Clib functions
  */
-
 #define ACPI_STRSTR(s1,s2)      strstr((s1), (s2))
 #define ACPI_STRCHR(s1,c)       strchr((s1), (c))
-
-#ifdef ACPI_FUTURE_USAGE
-#define ACPI_STRUPR(s)          (void) acpi_ut_strupr ((s))
-#endif
-
 #define ACPI_STRLEN(s)          (acpi_size) strlen((s))
 #define ACPI_STRCPY(d,s)        (void) strcpy((d), (s))
 #define ACPI_STRNCPY(d,s,n)     (void) strncpy((d), (s), (acpi_size)(n))
@@ -254,14 +248,15 @@
 #define ACPI_IS_ALPHA           isalpha
 #define ACPI_IS_ASCII           isascii
 
+#else
+
 /******************************************************************************
  *
  * Not using native C library, use local implementations
  *
  *****************************************************************************/
-#else
 
-/*
+ /*
  * Use local definitions of C library macros and functions
  * NOTE: The function implementations may not be as efficient
  * as an inline or assembly code implementation provided by a
@@ -278,14 +273,12 @@
 /*
  * Storage alignment properties
  */
-
 #define  _AUPBND                (sizeof (acpi_native_int) - 1)
 #define  _ADNBND                (sizeof (acpi_native_int) - 1)
 
 /*
  * Variable argument list macro definitions
  */
-
 #define _bnd(X, bnd)            (((sizeof (X)) + (bnd)) & (~(bnd)))
 #define va_arg(ap, T)           (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))
 #define va_end(ap)              (void) 0
@@ -296,11 +289,6 @@
 
 #define ACPI_STRSTR(s1,s2)      acpi_ut_strstr ((s1), (s2))
 #define ACPI_STRCHR(s1,c)       acpi_ut_strchr ((s1), (c))
-
-#ifdef ACPI_FUTURE_USAGE
-#define ACPI_STRUPR(s)          (void) acpi_ut_strupr ((s))
-#endif
-
 #define ACPI_STRLEN(s)          (acpi_size) acpi_ut_strlen ((s))
 #define ACPI_STRCPY(d,s)        (void) acpi_ut_strcpy ((d), (s))
 #define ACPI_STRNCPY(d,s,n)     (void) acpi_ut_strncpy ((d), (s), (acpi_size)(n))
