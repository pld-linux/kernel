# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2005/01/05 23:56:52-05:00 torvalds@evo.osdl.org 
#   acpi video device enumeration: fix incorrect device list allocation
#   
#   It didn't allocate space for the final terminating entry,
#   which caused it to overwrite the next slab entry, which in turn
#   sometimes ended up being a slab array cache pointer. End result:
#   total slab cache corruption at a random time afterwards. Very
#   nasty.
# 
# drivers/acpi/video.c
#   2005/01/05 23:54:25-05:00 torvalds@evo.osdl.org +1 -1
#   acpi video device enumeration: fix incorrect device list allocation
#   
#   It didn't allocate space for the final terminating entry,
#   which caused it to overwrite the next slab entry, which in turn
#   sometimes ended up being a slab array cache pointer. End result:
#   total slab cache corruption at a random time afterwards. Very
#   nasty.
# 
# ChangeSet
#   2004/12/24 00:03:49-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/26-stable-dev
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# drivers/acpi/pci_irq.c
#   2004/12/24 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/hardware/hwsleep.c
#   2004/12/24 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/23 23:43:30-05:00 len.brown@intel.com 
#   [ACPI] Fix suspend/resume lockup issue
#   by leaving Bus Master Arbitration enabled.
#   The ACPI spec mandates it be disabled only for C3.
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=3599
#   
#   Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/hardware/hwsleep.c
#   2004/12/16 23:21:28-05:00 len.brown@intel.com +0 -16
#   Fix suspend/resume lockup issue
#   by leaving Bus Master Arbitration enabled.
# 
# ChangeSet
#   2004/12/23 23:38:32-05:00 len.brown@intel.com 
#   [ACPI] apply via_interrupt_line_quirk in ACPI mode
#   the same way it is applied in legacy mode.
#   Delete redundant quirks.
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=3319
#   
#   Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/pci/quirks.c
#   2004/12/23 23:38:24-05:00 len.brown@intel.com +5 -24
#   via_interrupt_line_quirk
# 
# drivers/acpi/pci_irq.c
#   2004/12/23 23:38:24-05:00 len.brown@intel.com +4 -0
#   via_interrupt_line_quirk
# 
# arch/i386/pci/irq.c
#   2004/12/23 23:38:24-05:00 len.brown@intel.com +2 -2
#   via_interrupt_line_quirk
# 
# ChangeSet
#   2004/12/23 23:11:56-05:00 len.brown@intel.com 
#   [ACPI] another fix to the stack-audit patch
#   http://bugzilla.kernel.org/show_bug.cgi?id=2901
#     
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/pci_irq.c
#   2004/12/23 23:11:50-05:00 len.brown@intel.com +2 -5
#   another fix to the stack-audit patch
# 
# ChangeSet
#   2004/12/23 15:10:05-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/26-stable-dev
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# drivers/acpi/thermal.c
#   2004/12/23 15:10:01-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/pci_bind.c
#   2004/12/23 15:10:01-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/23 15:07:34-05:00 len.brown@intel.com 
#   [ACPI] two fixups where promotion and demotion were mixed up
#   
#   Signed-off-by: Dominik Brodowski <linux@brodo.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_idle.c
#   2004/12/23 08:39:58-05:00 len.brown@intel.com +2 -2
#   two fixups where promotion and demotion were mixed up
# 
# ChangeSet
#   2004/12/23 14:39:34-05:00 len.brown@intel.com 
#   [ACPI] fix to the stack-audit patch
#   http://bugzilla.kernel.org/show_bug.cgi?id=2901
#   
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/thermal.c
#   2004/12/23 14:39:26-05:00 len.brown@intel.com +1 -1
#   fix stack-audit patch
# 
# drivers/acpi/pci_bind.c
#   2004/12/23 14:39:26-05:00 len.brown@intel.com +1 -1
#   fix stack-audit patch
# 
# ChangeSet
#   2004/12/23 14:20:02-05:00 len.brown@intel.com 
#   [ACPI] add "processor.nocst" parameter
#   which blocks _CST parsing and always uses FADT info instead.
#   
#   Signed-off-by: Dominik Brodowski <linux@brodo.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_idle.c
#   2004/12/23 08:25:32-05:00 len.brown@intel.com +10 -3
#   add "processor.nocst" parameter
# 
# ChangeSet
#   2004/12/23 14:18:22-05:00 len.brown@intel.com 
#   [ACPI] Let C4 demote to C3, not directly to C2.
#   
#   Signed-off-by: Dominik Brodowski <linux@brodo.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_idle.c
#   2004/12/23 08:25:29-05:00 len.brown@intel.com +1 -4
#   Let C4 demote to C3, not directly to C2.
# 
# ChangeSet
#   2004/12/23 14:13:35-05:00 len.brown@intel.com 
#   
#   [ACPI] tweak /proc/acpi/processor/CPU0/power format
#   Current policy is to name both C-state-types and the actual C-States
#   "C[0-n]". Follow this rule...
#   
#   Signed-off-by: Dominik Brodowski <linux@brodo.de
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_idle.c
#   2004/12/23 08:25:24-05:00 len.brown@intel.com +7 -7
#   tweak /proc/acpi/processor/CPU0/power format
# 
# ChangeSet
#   2004/12/23 13:16:18-05:00 len.brown@intel.com 
#   [ACPI] max_cstate shall limit C-states not C-state-types.
#   
#   Signed-off-by: Dominik Brodowski <linux@brodo.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_idle.c
#   2004/12/23 08:24:13-05:00 len.brown@intel.com +6 -4
#   max_cstate shall limit C-states not C-state types.
# 
# drivers/acpi/osl.c
#   2004/12/23 08:09:11-05:00 len.brown@intel.com +2 -1
#   max_cstate shall limit C-states not C-state types.
# 
# ChangeSet
#   2004/12/22 02:14:30-05:00 len.brown@intel.com 
#   [ACPI] Export /sys/module/processor/parameters/max_cstate
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_idle.c
#   2004/12/14 07:19:52-05:00 len.brown@intel.com +1 -1
#   Import patch acpi-16-max-cstate-in-sysfs
# 
# ChangeSet
#   2004/12/22 01:03:07-05:00 len.brown@intel.com 
#   [ACPI] Consolidate code in processor_idle().
#   Only symbols "exported" are _init(), _exit() and _cst_has_changed()
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/processor.h
#   2004/12/14 07:14:54-05:00 len.brown@intel.com +4 -6
#   Import patch acpi-15-power-only-init-modify-exit
# 
# drivers/acpi/processor_idle.c
#   2004/12/14 07:14:54-05:00 len.brown@intel.com +109 -8
#   Import patch acpi-15-power-only-init-modify-exit
# 
# drivers/acpi/processor_core.c
#   2004/12/14 07:14:54-05:00 len.brown@intel.com +2 -67
#   Import patch acpi-15-power-only-init-modify-exit
# 
# ChangeSet
#   2004/12/22 00:54:22-05:00 len.brown@intel.com 
#   [ACPI] Notify the BIOS that Linux can handle _CST.
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1958
#   
#   Signed-off-by: Bruno Ducrot <ducrot@poupinou.org>
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_core.c
#   2004/12/14 07:14:15-05:00 len.brown@intel.com +8 -0
#   Notify the BIOS that Linux can handle _CST.
# 
# ChangeSet
#   2004/12/22 00:48:28-05:00 len.brown@intel.com 
#   [ACPI] Handle _CST change notifications
#   
#   It is necessary to unload the processor idle handle for
#   a short period of time to avoid for nasty races --
#   and we don't want to grab too many locks
#   so that the idle handler continues to be speedy.
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1958
#   
#   Signed-off-by: Bruno Ducrot <ducrot@poupinou.org>
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/processor.h
#   2004/12/14 07:13:36-05:00 len.brown@intel.com +1 -0
#   Handle _CST change notifications
# 
# drivers/acpi/processor_idle.c
#   2004/12/14 07:13:36-05:00 len.brown@intel.com +27 -0
#   Handle _CST change notifications
# 
# drivers/acpi/processor_core.c
#   2004/12/14 07:13:36-05:00 len.brown@intel.com +1 -1
#   Handle _CST change notifications
# 
# ChangeSet
#   2004/12/22 00:45:13-05:00 len.brown@intel.com 
#   [ACPI] Add _CST parsing
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1958
#   
#   Signed-off-by: Bruno Ducrot <ducrot@poupinou.org>
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/processor.h
#   2004/12/14 07:12:57-05:00 len.brown@intel.com +14 -1
#   Add _CST parsing
# 
# drivers/acpi/processor_idle.c
#   2004/12/14 07:12:57-05:00 len.brown@intel.com +149 -10
#   Add _CST parsing
# 
# ChangeSet
#   2004/12/22 00:26:58-05:00 len.brown@intel.com 
#   [ACPI] make the c-state policy decisions of demotion and promotion
#   independent of the assumption "one state per type."
#   make the state a pointer inside struct acpi_processor_cx_policy.
#   make max_cstate aware of c-state types instead of c-state number.
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1958
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/processor.h
#   2004/12/14 07:12:12-05:00 len.brown@intel.com +3 -1
#   Import patch acpi-11-power-policy-independent-of-states
# 
# drivers/acpi/processor_idle.c
#   2004/12/14 07:11:00-05:00 len.brown@intel.com +71 -66
#   Import patch acpi-11-power-policy-independent-of-states
# 
# ChangeSet
#   2004/12/22 00:16:32-05:00 len.brown@intel.com 
#   [ACPI] make power.state a pointer
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1958
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/processor.h
#   2004/12/14 07:08:31-05:00 len.brown@intel.com +1 -1
#   make power.state a pointer
# 
# drivers/acpi/processor_idle.c
#   2004/12/14 07:09:32-05:00 len.brown@intel.com +32 -18
#   make power.state a pointer
# 
# ChangeSet
#   2004/12/22 00:12:13-05:00 len.brown@intel.com 
#   [ACPI] deleted unused default c-state
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1958
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_idle.c
#   2004/12/13 19:29:47-05:00 len.brown@intel.com +0 -3
#   deleted unused default c-state
# 
# ChangeSet
#   2004/12/22 00:05:34-05:00 len.brown@intel.com 
#   [ACPI] Split up the extraction of information from the FADT
#   and the pblk_address (acpi_processor_get_power_info_fadt())
#   and the validation whether the state is indeed available
#   (acpi_processor_power_verify()).
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1958
#   
#   Signed-off-by: Bruno Ducrot <ducrot@poupinou.org>
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/processor.h
#   2004/12/13 19:24:07-05:00 len.brown@intel.com +1 -0
#   acpi_processor_get_power_info_fadt() & acpi_processor_power_verify()
# 
# drivers/acpi/processor_idle.c
#   2004/12/13 19:28:33-05:00 len.brown@intel.com +162 -118
#   acpi_processor_get_power_info_fadt() & acpi_processor_power_verify()
# 
# drivers/acpi/processor_core.c
#   2004/12/13 19:24:07-05:00 len.brown@intel.com +2 -4
#   acpi_processor_get_power_info_fadt() & acpi_processor_power_verify()
# 
# ChangeSet
#   2004/12/21 23:53:22-05:00 len.brown@intel.com 
#   [ACPI] Differentiate between C-States and C-state type.
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1958
#   
#   Signed-off-by: Bruno Ducrot <ducrot@poupinou.org>
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/processor.h
#   2004/12/13 19:22:59-05:00 len.brown@intel.com +1 -0
#   C-state type
# 
# drivers/acpi/processor_idle.c
#   2004/12/13 19:23:33-05:00 len.brown@intel.com +42 -17
#   C-state type
# 
# ChangeSet
#   2004/12/21 22:58:56-05:00 len.brown@intel.com 
#   [ACPI] Shorten the times IRQs are disabled in throttling.
#   During calculations no disabling is necessary.
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_throttling.c
#   2004/11/27 10:29:36-05:00 len.brown@intel.com +4 -4
#   Shorten the times IRQs are disabled in throttling.
# 
# ChangeSet
#   2004/12/21 22:57:16-05:00 len.brown@intel.com 
#   [ACPI] Finalize the splitting of processor.c by moving the rest to processor_core.c
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_core.c
#   2004/12/13 19:21:31-05:00 len.brown@intel.com +26 -28
#   Finalize the splitting of processor.c by moving the rest to processor_core.c
# 
# drivers/acpi/Makefile
#   2004/12/13 19:20:38-05:00 len.brown@intel.com +4 -4
#   Finalize the splitting of processor.c by moving the rest to processor_core.c
# 
# ChangeSet
#   2004/12/21 22:54:46-05:00 len.brown@intel.com 
#   [ACPI] Split the ACPI Processor passive cooling code into a different file
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_thermal.c
#   2004/12/13 19:20:03-05:00 len.brown@intel.com +406 -0
#   Split the ACPI Processor passive cooling code into a different file
# 
# include/acpi/processor.h
#   2004/12/13 19:20:03-05:00 len.brown@intel.com +19 -0
#   Split the ACPI Processor passive cooling code into a different file
# 
# drivers/acpi/processor_thermal.c
#   2004/12/13 19:20:03-05:00 len.brown@intel.com +0 -0
#   BitKeeper file /home/lenb/src/26-latest-dev/drivers/acpi/processor_thermal.c
# 
# drivers/acpi/processor.c
#   2004/12/13 19:20:03-05:00 len.brown@intel.com +2 -360
#   Split the ACPI Processor passive cooling code into a different file
# 
# drivers/acpi/Makefile
#   2004/12/13 19:20:03-05:00 len.brown@intel.com +2 -1
#   Split the ACPI Processor passive cooling code into a different file
# 
# ChangeSet
#   2004/12/21 22:53:35-05:00 len.brown@intel.com 
#   [ACPI] Split the ACPI Processor C-States handling into a different file
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_idle.c
#   2004/12/13 19:37:33-05:00 len.brown@intel.com +637 -0
#   Split the ACPI Processor C-States handling into a different file
# 
# include/acpi/processor.h
#   2004/12/13 19:37:21-05:00 len.brown@intel.com +8 -0
#   Split the ACPI Processor C-States handling into a different file
# 
# drivers/acpi/processor_idle.c
#   2004/12/13 19:37:33-05:00 len.brown@intel.com +0 -0
#   BitKeeper file /home/lenb/src/26-latest-dev/drivers/acpi/processor_idle.c
# 
# drivers/acpi/processor.c
#   2004/12/13 19:37:21-05:00 len.brown@intel.com +3 -588
#   Split the ACPI Processor C-States handling into a different file
# 
# drivers/acpi/Makefile
#   2004/12/13 19:37:21-05:00 len.brown@intel.com +2 -2
#   Split the ACPI Processor C-States handling into a different file
# 
# ChangeSet
#   2004/12/21 22:51:57-05:00 len.brown@intel.com 
#   [ACPI] Split the ACPI Processor T-States handling into a different file
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/processor.h
#   2004/12/13 19:09:37-05:00 len.brown@intel.com +22 -0
#   Split the ACPI Processor T-States handling into a different file
# 
# drivers/acpi/processor_throttling.c
#   2004/12/13 19:09:37-05:00 len.brown@intel.com +351 -0
#   Split the ACPI Processor T-States handling into a different file
# 
# drivers/acpi/processor.c
#   2004/12/13 19:09:56-05:00 len.brown@intel.com +1 -313
#   Split the ACPI Processor T-States handling into a different file
# 
# drivers/acpi/Makefile
#   2004/12/13 19:09:37-05:00 len.brown@intel.com +1 -1
#   Split the ACPI Processor T-States handling into a different file
# 
# drivers/acpi/processor_throttling.c
#   2004/12/13 19:09:37-05:00 len.brown@intel.com +0 -0
#   BitKeeper file /home/lenb/src/26-latest-dev/drivers/acpi/processor_throttling.c
# 
# ChangeSet
#   2004/12/21 22:47:29-05:00 len.brown@intel.com 
#   [ACPI] Split the ACPI Processor P-States library into a different file
#   
#   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/processor_perflib.c
#   2004/12/13 19:08:55-05:00 len.brown@intel.com +666 -0
#   Split the ACPI Processor P-States library into a different file
# 
# include/acpi/processor.h
#   2004/12/13 19:04:00-05:00 len.brown@intel.com +25 -0
#   Split the ACPI Processor P-States library into a different file
# 
# drivers/acpi/processor_perflib.c
#   2004/12/13 19:08:55-05:00 len.brown@intel.com +0 -0
#   BitKeeper file /home/lenb/src/26-latest-dev/drivers/acpi/processor_perflib.c
# 
# drivers/acpi/processor.c
#   2004/12/13 19:07:47-05:00 len.brown@intel.com +3 -641
#   Split the ACPI Processor P-States library into a different file
# 
# drivers/acpi/Makefile
#   2004/12/13 19:04:00-05:00 len.brown@intel.com +6 -1
#   Split the ACPI Processor P-States library into a different file
# 
# ChangeSet
#   2004/12/21 22:08:59-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/26-stable-dev
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# drivers/acpi/tables/tbconvrt.c
#   2004/12/21 22:08:55-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/pci_link.c
#   2004/12/21 22:08:55-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/osl.c
#   2004/12/21 22:08:55-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/21 16:57:44-05:00 len.brown@intel.com 
#   [ACPI] ACPICA 20041210 from Bob Moore
#   
#   ACPI 3.0 support is nearing completion in both the iASL
#   compiler and the ACPI CA core subsystem.
#   
#   Fixed a problem in the ToDecimalString operator where the
#   resulting string length was incorrectly calculated. The
#   length is now calculated exactly, eliminating incorrect
#   AE_STRING_LIMIT exceptions.
#   
#   Fixed a problem in the ToHexString operator to allow a
#   maximum 200 character string to be produced.
#   
#   Fixed a problem in the internal string-to-buffer and
#   buffer-to-buffer copy routine where the length of the
#   resulting buffer was not truncated to the new size (if
#   the target buffer already existed).
#   
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/amlresrc.h
#   2004/12/21 16:41:33-05:00 len.brown@intel.com +25 -1
#   ACPICA 20041210
# 
# include/acpi/actbl2.h
#   2004/12/21 16:41:34-05:00 len.brown@intel.com +1 -1
#   ACPICA 20041210
# 
# include/acpi/aclocal.h
#   2004/12/21 16:41:34-05:00 len.brown@intel.com +1 -1
#   ACPICA 20041210
# 
# include/acpi/acdisasm.h
#   2004/12/21 16:41:34-05:00 len.brown@intel.com +6 -0
#   ACPICA 20041210
# 
# include/acpi/acconfig.h
#   2004/12/21 16:41:34-05:00 len.brown@intel.com +2 -2
#   ACPICA 20041210
# 
# drivers/acpi/tables/tbconvrt.c
#   2004/12/21 16:41:37-05:00 len.brown@intel.com +2 -2
#   ACPICA 20041210
# 
# drivers/acpi/executer/exstorob.c
#   2004/12/21 16:41:38-05:00 len.brown@intel.com +10 -9
#   ACPICA 20041210
# 
# drivers/acpi/executer/exconvrt.c
#   2004/12/21 16:41:38-05:00 len.brown@intel.com +56 -40
#   ACPICA 20041210
# 
# ChangeSet
#   2004/12/21 12:54:09-05:00 len.brown@intel.com 
#   [ACPI] fix return syntax
#   
#   Signed-off-by: Pavel Machek <pavel@suse.cz>
#   Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
# 
# drivers/acpi/toshiba_acpi.c
#   2004/12/20 17:46:15-05:00 len.brown@intel.com +2 -2
#   fix return syntax
# 
# drivers/acpi/pci_link.c
#   2004/12/20 17:42:13-05:00 len.brown@intel.com +2 -2
#   fix return syntax
# 
# drivers/acpi/osl.c
#   2004/12/20 17:40:29-05:00 len.brown@intel.com +3 -3
#   fix return syntax
# 
# drivers/acpi/asus_acpi.c
#   2004/12/20 17:35:32-05:00 len.brown@intel.com +9 -9
#   fix return syntax
# 
# ChangeSet
#   2004/12/20 21:58:46-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/26-stable-dev
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# include/asm-i386/acpi.h
#   2004/12/20 21:58:42-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/20 12:40:03-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/bk/26-latest-ref
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# Documentation/kernel-parameters.txt
#   2004/12/20 12:39:59-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/08 00:40:23-05:00 len.brown@intel.com 
#   [ACPI] fix polarity of CONFIG_X86_SPEEDSTEP_CENTRINO_ACPI message
#   
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
#   2004/12/08 00:36:27-05:00 len.brown@intel.com +1 -1
#   complain about CONFIG_X86_SPEEDSTEP_CENTRINO_ACPI missing only when it is missing
# 
# ChangeSet
#   2004/12/08 00:33:06-05:00 len.brown@intel.com 
#   [ACPI] remove duplicate _PDC #defines resulting from mis-merge
#   
#   Signed-off-by: Zhenyu Z. Wang <zhenyu.z.wang@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/asm-i386/acpi.h
#   2004/12/08 00:32:58-05:00 len.brown@intel.com +0 -6
#   remove duplicate #defines resulting from mis-merge
# 
# ChangeSet
#   2004/12/06 17:23:23-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/26-stable-dev
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# drivers/acpi/tables/tbxfroot.c
#   2004/12/06 17:23:20-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/06 17:12:37-05:00 len.brown@intel.com 
#   [ACPI] ACPICA 20041203 from Bob Moore and Alexey Starikovskiy
#   
#   The low-level field insertion/extraction code (exfldio)
#   has been completely rewritten to eliminate unnecessary
#   complexity, bugs, and boundary conditions.
#   
#   Fixed a problem in the ToInteger, ToBuffer, ToHexString,
#   and ToDecimalString operators where the input operand could
#   be inadvertently deleted if no conversion was necessary
#   (e.g., if the input to ToInteger was an Integer object.)
#   
#   Fixed a problem with the ToDecimalString and ToHexString
#   where an incorrect exception code was returned if the
#   resulting string would be > 200 chars.  AE_STRING_LIMIT is
#   now returned.
#   
#   Fixed a problem with the Concatenate operator where AE_OK
#   was always returned, even if the operation failed.
#   
#   Fixed a problem in oswinxf (used by AcpiExec and iASL)
#   to allow > 128 semaphores to be allocated.
#   
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/amlcode.h
#   2004/12/06 16:15:20-05:00 len.brown@intel.com +1 -0
#   ACPICA 20041203
# 
# include/acpi/acobject.h
#   2004/12/06 16:15:20-05:00 len.brown@intel.com +1 -3
#   ACPICA 20041203
# 
# include/acpi/acmacros.h
#   2004/12/06 16:15:21-05:00 len.brown@intel.com +1 -0
#   ACPICA 20041203
# 
# include/acpi/acconfig.h
#   2004/12/06 16:15:21-05:00 len.brown@intel.com +1 -1
#   ACPICA 20041203
# 
# drivers/acpi/parser/psopcode.c
#   2004/12/06 16:15:25-05:00 len.brown@intel.com +4 -4
#   ACPICA 20041203
# 
# drivers/acpi/executer/exprep.c
#   2004/12/06 16:15:26-05:00 len.brown@intel.com +2 -22
#   ACPICA 20041203
# 
# drivers/acpi/executer/exoparg1.c
#   2004/12/06 16:15:26-05:00 len.brown@intel.com +22 -4
#   ACPICA 20041203
# 
# drivers/acpi/executer/exmisc.c
#   2004/12/06 16:15:26-05:00 len.brown@intel.com +1 -1
#   ACPICA 20041203
# 
# drivers/acpi/executer/exfldio.c
#   2004/12/06 16:15:26-05:00 len.brown@intel.com +114 -432
#   ACPICA 20041203
# 
# drivers/acpi/executer/exdump.c
#   2004/12/06 16:15:26-05:00 len.brown@intel.com +0 -3
#   ACPICA 20041203
# 
# drivers/acpi/events/evgpe.c
#   2004/12/06 16:15:25-05:00 len.brown@intel.com +13 -13
#   ACPICA 20041203
# 
# drivers/acpi/dispatcher/dswexec.c
#   2004/12/06 16:15:25-05:00 len.brown@intel.com +16 -8
#   ACPICA 20041203
# 
# drivers/acpi/dispatcher/dsopcode.c
#   2004/12/06 16:15:25-05:00 len.brown@intel.com +2 -3
#   ACPICA 20041203
# 
# ChangeSet
#   2004/12/06 16:57:17-05:00 len.brown@intel.com 
#   [ACPI] ACPICA 20041119 from Bob Moore
#   
#   Fixed a problem in acpi_ex_convert_to_integer
#   where new integers were not truncated to 32 bits for
#   32-bit ACPI tables. This routine converts buffers and
#   strings to integers.
#   
#   Implemented support to store a value to an Index() on a
#   String object.  This is an ACPI 2.0 feature that had not
#   yet been implemented.
#   
#   Implemented new behavior for storing objects to individual
#   package elements (via the Index() operator). The
#   previous behavior was to invoke the implicit conversion
#   rules if an object was already present at the index.
#   The new behavior is to simply delete any existing object
#   and directly store the new object. Although the ACPI
#   specification seems unclear on this subject, other ACPI
#   implementations behave in this manner.  (This is the root
#   of the AE_BAD_HEX_CONSTANT issue.)
#   
#   Modified the RSDP memory scan mechanism to support the
#   extended checksum for ACPI 2.0 (and above) RSDPs. Note
#   that the search continues until a valid RSDP signature is
#   found with a valid checksum.
#   
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/acoutput.h
#   2004/12/06 16:02:10-05:00 len.brown@intel.com +1 -1
#   ACPICA 20041119
# 
# include/acpi/acmacros.h
#   2004/12/06 16:02:10-05:00 len.brown@intel.com +12 -12
#   ACPICA 20041119
# 
# include/acpi/acconfig.h
#   2004/12/06 16:02:10-05:00 len.brown@intel.com +1 -1
#   ACPICA 20041119
# 
# drivers/acpi/tables/tbxfroot.c
#   2004/12/06 16:02:13-05:00 len.brown@intel.com +34 -11
#   ACPICA 20041119
# 
# drivers/acpi/tables/tbrsdt.c
#   2004/12/06 16:02:13-05:00 len.brown@intel.com +1 -0
#   ACPICA 20041119
# 
# drivers/acpi/executer/exstore.c
#   2004/12/06 16:02:13-05:00 len.brown@intel.com +26 -36
#   ACPICA 20041119
# 
# drivers/acpi/executer/exoparg2.c
#   2004/12/06 16:02:13-05:00 len.brown@intel.com +2 -2
#   ACPICA 20041119
# 
# drivers/acpi/executer/exdump.c
#   2004/12/06 16:56:20-05:00 len.brown@intel.com +5 -3
#   ACPICA 20041119
# 
# drivers/acpi/executer/exconvrt.c
#   2004/12/06 16:02:13-05:00 len.brown@intel.com +9 -7
#   ACPICA 20041119
# 
# drivers/acpi/executer/exconfig.c
#   2004/12/06 16:02:13-05:00 len.brown@intel.com +1 -1
#   ACPICA 20041119
# 
# ChangeSet
#   2004/12/06 15:58:53-05:00 len.brown@intel.com 
#   merge
# 
# drivers/acpi/processor.c
#   2004/12/06 15:58:46-05:00 len.brown@intel.com +1 -1
#   merge
# 
# include/linux/acpi.h
#   2004/12/06 15:23:34-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/pci_irq.c
#   2004/12/06 15:23:34-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/pci_bind.c
#   2004/12/06 15:23:34-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/bus.c
#   2004/12/06 15:23:33-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/06 15:00:40-05:00 len.brown@intel.com 
#   build fix
# 
# include/acpi/acpixf.h
#   2004/12/06 15:00:29-05:00 len.brown@intel.com +1 -1
#   build fix
# 
# ChangeSet
#   2004/12/06 01:43:31-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/26-stable-dev
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# drivers/acpi/ec.c
#   2004/12/06 01:43:27-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/06 01:40:07-05:00 len.brown@intel.com 
#   [ACPI] 32-bit EC access
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1744
#   
#   Signed-off-by: Luming Yu <luming.yu@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/ec.c
#   2004/12/01 08:46:15-05:00 len.brown@intel.com +24 -0
#   32-bit EC access
# 
# ChangeSet
#   2004/12/06 00:09:58-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/26-stable-dev
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# drivers/acpi/events/evxfevnt.c
#   2004/12/06 00:09:54-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/06 00:08:27-05:00 len.brown@intel.com 
#   build fix
# 
# drivers/acpi/events/evxfevnt.c
#   2004/12/06 00:08:18-05:00 len.brown@intel.com +1 -2
#   build fix
# 
# ChangeSet
#   2004/12/06 00:03:42-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/26-stable-dev
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# drivers/acpi/thermal.c
#   2004/12/06 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/sleep/proc.c
#   2004/12/06 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/pci_link.c
#   2004/12/06 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/pci_irq.c
#   2004/12/06 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/ec.c
#   2004/12/06 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/bus.c
#   2004/12/06 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# Documentation/kernel-parameters.txt
#   2004/12/06 00:03:38-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/05 23:40:35-05:00 len.brown@intel.com 
#   [ACPI] fixes from stack consumption audit
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=2901
#   
#   Signed-off-by: Luming Yu <luming.yu@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/video.c
#   2004/12/01 06:31:48-05:00 len.brown@intel.com +7 -6
#   stack consumption audit
# 
# drivers/acpi/thermal.c
#   2004/12/01 06:49:30-05:00 len.brown@intel.com +22 -5
#   stack consumption audit
# 
# drivers/acpi/pci_link.c
#   2004/12/01 06:42:40-05:00 len.brown@intel.com +36 -26
#   stack consumption audit
# 
# drivers/acpi/pci_irq.c
#   2004/12/01 06:31:47-05:00 len.brown@intel.com +12 -2
#   stack consumption audit
# 
# drivers/acpi/pci_bind.c
#   2004/12/01 06:31:47-05:00 len.brown@intel.com +30 -7
#   stack consumption audit
# 
# ChangeSet
#   2004/12/05 23:38:12-05:00 len.brown@intel.com 
#   [ACPI] handle GPE sharing between button and lid
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=3518
#   
#   Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/sleep/proc.c
#   2004/12/05 23:38:04-05:00 len.brown@intel.com +17 -0
#   sharing GPE w/ button and LID
# 
# ChangeSet
#   2004/12/05 23:23:53-05:00 len.brown@intel.com 
#   [ACPI] add "acpi_fake_ecdt" workaround for Gateway:
#   ex_access_region Region EmbeddedControl(3) has no handler
#   
#   http://bugzilla.kernel.org/show_bug.cgi?id=1690
#   
#   Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/ec.c
#   2004/12/05 23:23:45-05:00 len.brown@intel.com +107 -4
#   "acpi_fake_ecdt"
# 
# Documentation/kernel-parameters.txt
#   2004/12/05 23:23:45-05:00 len.brown@intel.com +2 -0
#   "acpi_fake_ecdt"
# 
# ChangeSet
#   2004/12/05 23:10:31-05:00 len.brown@intel.com 
#   [ACPI] fix "Error getting context for object" warning
#   http://bugzilla.kernel.org/show_bug.cgi?id=3805
#   
#   Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/pnp/pnpacpi/core.c
#   2004/11/25 20:28:37-05:00 len.brown@intel.com +3 -3
#   fix "Error getting context for object" warning
# 
# drivers/acpi/bus.c
#   2004/11/25 20:09:42-05:00 len.brown@intel.com +1 -1
#   fix "Error getting context for object" warning
# 
# ChangeSet
#   2004/12/05 22:52:35-05:00 len.brown@intel.com 
#   [ACPI] S3 resume using RTC
#   http://bugzilla.kernel.org/show_bug.cgi?id=1320
#   
#   By: Patrick Mochel, Karol Kozimor, Shaohua Li
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/sleep/proc.c
#   2004/11/22 22:02:27-05:00 len.brown@intel.com +36 -25
#   wake on RTC
# 
# ChangeSet
#   2004/12/03 22:40:32-05:00 len.brown@intel.com 
#   [ACPI] fix VIA IRQ issue by enabling VIA quirk
#   http://bugzilla.kernel.org/show_bug.cgi?id=3319
#   
#   Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/pci/quirks.c
#   2004/12/02 20:01:29-05:00 len.brown@intel.com +1 -0
#   yet another example of VIA quirk
# 
# ChangeSet
#   2004/12/01 23:50:22-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/bk/26-latest-ref
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# arch/ia64/kernel/process.c
#   2004/12/01 23:50:18-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/12/01 19:21:17-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/bk/26-latest-ref
#   into intel.com:/home/lenb/src/26-latest-dev
# 
# arch/ia64/kernel/process.c
#   2004/12/01 19:21:13-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/11/30 17:38:34-05:00 len.brown@intel.com 
#   merge
# 
# drivers/acpi/scan.c
#   2004/11/30 17:38:27-05:00 len.brown@intel.com +0 -2
#   merge
# 
# BitKeeper/deleted/.del-acpi_ksyms.c~3e52a41ca5aed029
#   2004/11/30 17:15:57-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/pci_irq.c
#   2004/11/30 17:15:57-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/pci_bind.c
#   2004/11/30 17:15:57-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/bus.c
#   2004/11/30 17:15:57-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/Makefile
#   2004/11/30 17:15:57-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# arch/i386/kernel/acpi/boot.c
#   2004/11/30 17:15:57-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# BitKeeper/deleted/.del-acpi_ksyms.c~3e52a41ca5aed029
#   2004/11/30 17:15:57-05:00 len.brown@intel.com +0 -0
#   Merge rename: drivers/acpi/acpi_ksyms.c -> BitKeeper/deleted/.del-acpi_ksyms.c~3e52a41ca5aed029
# 
# ChangeSet
#   2004/11/11 02:56:38-05:00 len.brown@intel.com 
#   [ACPI] CPU hotplug, use kobject_hotplug(), kobject_register()
#   
#   Signed-off-by: Anil S. Keshavamurthy <anil.s.keshavamurthy@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/scan.c
#   2004/11/11 02:56:31-05:00 len.brown@intel.com +1 -2
#   Use kobject_register()
# 
# drivers/acpi/processor.c
#   2004/11/11 02:56:31-05:00 len.brown@intel.com +4 -54
#   Use kobject_hotplug()
# 
# drivers/acpi/container.c
#   2004/11/11 02:56:31-05:00 len.brown@intel.com +3 -49
#   Use kobject_hotplug()
# 
# ChangeSet
#   2004/11/11 02:44:40-05:00 len.brown@intel.com 
#   merge
# 
# include/linux/acpi.h
#   2004/11/11 02:44:32-05:00 len.brown@intel.com +0 -0
#   merge
# 
# drivers/acpi/scan.c
#   2004/11/11 02:44:32-05:00 len.brown@intel.com +0 -0
#   merge
# 
# drivers/acpi/processor.c
#   2004/11/11 02:44:32-05:00 len.brown@intel.com +5 -4
#   merge
# 
# drivers/acpi/pci_irq.c
#   2004/11/10 23:16:23-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/bus.c
#   2004/11/10 23:16:23-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# arch/i386/kernel/acpi/boot.c
#   2004/11/10 23:16:17-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/10/31 01:14:20-05:00 len.brown@intel.com 
#   [ACPI] fix mis-merge in processor.c
# 
# drivers/acpi/processor.c
#   2004/10/31 01:14:09-05:00 len.brown@intel.com +2 -60
#   delete dupe acpi_processor_start() definition
# 
# ChangeSet
#   2004/10/28 05:00:02-04:00 len.brown@intel.com 
#   merge
# 
# include/acpi/acpi_bus.h
#   2004/10/28 04:59:55-04:00 len.brown@intel.com +0 -0
#   merge
# 
# drivers/acpi/processor.c
#   2004/10/28 04:59:55-04:00 len.brown@intel.com +66 -2
#   merge
# 
# include/linux/acpi.h
#   2004/10/28 04:45:11-04:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/acpi/scan.c
#   2004/10/28 04:45:11-04:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/10/28 04:01:25-04:00 len.brown@intel.com 
#   [ACPI] Initial container driver to support hotplug notifications
#   on ACPI0004, PNP0A05 and PNP0A06 devices.
#   
#   Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/container.h
#   2004/09/24 18:26:34-04:00 len.brown@intel.com +13 -0
#   Import patch container_drv.patch
# 
# drivers/acpi/container.c
#   2004/09/24 18:26:34-04:00 len.brown@intel.com +344 -0
#   Import patch container_drv.patch
# 
# include/acpi/container.h
#   2004/09/24 18:26:34-04:00 len.brown@intel.com +0 -0
#   BitKeeper file /home/lenb/src/26-latest-hotplug/include/acpi/container.h
# 
# drivers/acpi/container.c
#   2004/09/24 18:26:34-04:00 len.brown@intel.com +0 -0
#   BitKeeper file /home/lenb/src/26-latest-hotplug/drivers/acpi/container.c
# 
# drivers/acpi/Makefile
#   2004/09/24 18:26:34-04:00 len.brown@intel.com +1 -0
#   Import patch container_drv.patch
# 
# drivers/acpi/Kconfig
#   2004/09/24 18:26:34-04:00 len.brown@intel.com +9 -1
#   Import patch container_drv.patch
# 
# ChangeSet
#   2004/10/28 03:55:03-04:00 len.brown@intel.com 
#   [ACPI] Extend processor driver to support ACPI-based Physical CPU hotplug
#   
#   Signed-off-by Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
#   Signed-off-by: Len Brown <len.brown2intel.com>
# 
# drivers/acpi/processor.c
#   2004/10/28 03:54:49-04:00 len.brown@intel.com +414 -66
#   Import patch processor_drv.patch
# 
# drivers/acpi/Kconfig
#   2004/09/24 18:26:31-04:00 len.brown@intel.com +8 -0
#   Import patch processor_drv.patch
# 
# ChangeSet
#   2004/10/28 03:41:43-04:00 len.brown@intel.com 
#   IA64 CPU hotplug topology
#   
#   Extend support for dynamic registration and unregistration of the cpu,
#   by implementing and exporting arch_register_cpu()/arch_unregister_cpu().
#   Also combine multiple implementation of topology_init() functions to
#   single topology_init() in case of ia64 architecture.
#   
#   Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/linux/cpu.h
#   2004/09/24 18:26:27-04:00 len.brown@intel.com +3 -0
#   Import patch topology.patch
# 
# include/asm-ia64/cpu.h
#   2004/09/24 18:26:27-04:00 len.brown@intel.com +5 -0
#   Import patch topology.patch
# 
# include/asm-i386/cpu.h
#   2004/09/24 18:26:27-04:00 len.brown@intel.com +4 -13
#   Import patch topology.patch
# 
# drivers/base/cpu.c
#   2004/09/24 18:26:27-04:00 len.brown@intel.com +18 -2
#   Import patch topology.patch
# 
# arch/ia64/mm/numa.c
#   2004/10/28 03:36:29-04:00 len.brown@intel.com +0 -36
#   Import patch topology.patch
# 
# arch/ia64/kernel/topology.c
#   2004/09/24 18:26:27-04:00 len.brown@intel.com +70 -23
#   Import patch topology.patch
# 
# arch/ia64/kernel/Makefile
#   2004/09/24 18:26:27-04:00 len.brown@intel.com +2 -1
#   Import patch topology.patch
# 
# arch/ia64/dig/Makefile
#   2004/09/24 18:26:27-04:00 len.brown@intel.com +0 -5
#   Import patch topology.patch
# 
# arch/i386/mach-default/topology.c
#   2004/09/24 18:26:27-04:00 len.brown@intel.com +31 -0
#   Import patch topology.patch
# 
# ChangeSet
#   2004/10/28 03:28:17-04:00 len.brown@intel.com 
#   [ACPI] IA64-specific support for mapping lsapic to cpu array.
#   analogous i386 and x86_64 code TBD
#   
#   Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/linux/acpi.h
#   2004/09/27 12:55:27-04:00 len.brown@intel.com +14 -0
#   Import patch acpi_hotplug_arch.patch
# 
# include/asm-ia64/acpi.h
#   2004/09/27 13:00:17-04:00 len.brown@intel.com +1 -1
#   Import patch acpi_hotplug_arch.patch
# 
# drivers/acpi/numa.c
#   2004/09/27 13:04:23-04:00 len.brown@intel.com +20 -1
#   Import patch acpi_hotplug_arch.patch
# 
# arch/ia64/kernel/acpi.c
#   2004/10/28 03:26:31-04:00 len.brown@intel.com +106 -2
#   Import patch acpi_hotplug_arch.patch
# 
# arch/i386/kernel/acpi/boot.c
#   2004/09/27 12:55:27-04:00 len.brown@intel.com +22 -0
#   Import patch acpi_hotplug_arch.patch
# 
# ChangeSet
#   2004/10/28 03:14:52-04:00 len.brown@intel.com 
#   [ACPI] create ACPI hotplug eject interface
#   
#   The kernel when it receives an hardware sci eject request it simply passes this
#   to user mode agent and the agent in turn will offline all the child devices and
#   then echo's 1 onto the eject file for that acpi device.
#   
#   This patch provides the sysfs "eject" interface for the user mode agent
#   to notify the core acpi so that the core acpi can trim its bus which 
#   causes .remove function to be called for all child devices.
#   
#   For example for LSB0 which is an ejectable device, we will see
#   /sys/firmware/acpi/namespace/ACPI/_SB/LSB/eject.
#   
#   Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# drivers/acpi/scan.c
#   2004/09/24 18:26:20-04:00 len.brown@intel.com +153 -0
#   Import patch acpi_core_eject.patch
# 
# ChangeSet
#   2004/10/28 02:59:39-04:00 len.brown@intel.com 
#   [ACPI] Provide core hotplug support in ACPI
#   
#   Create acpi_bus_trim(), acpi_bus_remove() and acpi_pci_unbind(),
#   The reverse of of acpi_bus_scan(), acpi_bus_add() and acpi_pci_bind()
#   
#   Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
#   Signed-off-by: Len Brown <len.brown@intel.com>
# 
# include/acpi/acpi_drivers.h
#   2004/09/24 18:26:17-04:00 len.brown@intel.com +2 -0
#   Import patch acpi_core.patch
# 
# include/acpi/acpi_bus.h
#   2004/10/28 02:59:06-04:00 len.brown@intel.com +9 -1
#   Import patch acpi_core.patch
# 
# drivers/acpi/scan.c
#   2004/09/24 18:26:17-04:00 len.brown@intel.com +122 -9
#   Import patch acpi_core.patch
# 
# drivers/acpi/pci_irq.c
#   2004/09/24 18:26:17-04:00 len.brown@intel.com +39 -3
#   Import patch acpi_core.patch
# 
# drivers/acpi/pci_bind.c
#   2004/09/24 18:26:17-04:00 len.brown@intel.com +45 -0
#   Import patch acpi_core.patch
# 
# drivers/acpi/bus.c
#   2004/09/24 18:26:17-04:00 len.brown@intel.com +0 -4
#   Import patch acpi_core.patch
# 
# drivers/acpi/acpi_ksyms.c
#   2004/09/24 18:26:17-04:00 len.brown@intel.com +3 -0
#   Import patch acpi_core.patch
# 
diff -Nru a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
--- a/Documentation/kernel-parameters.txt	2005-01-06 15:06:41 -05:00
+++ b/Documentation/kernel-parameters.txt	2005-01-06 15:06:41 -05:00
@@ -150,6 +150,8 @@
 			debugging. After system has booted up, it can be set
 			via /proc/acpi/debug_level.
 
+	acpi_fake_ecdt	[HW,ACPI] Workaround failure due to BIOS lacking ECDT
+
 	ad1816=		[HW,OSS]
 			Format: <io>,<irq>,<dma>,<dma2>
 			See also Documentation/sound/oss/AD1816.
diff -Nru a/arch/i386/kernel/acpi/boot.c b/arch/i386/kernel/acpi/boot.c
--- a/arch/i386/kernel/acpi/boot.c	2005-01-06 15:06:41 -05:00
+++ b/arch/i386/kernel/acpi/boot.c	2005-01-06 15:06:41 -05:00
@@ -484,6 +484,28 @@
 }
 EXPORT_SYMBOL(acpi_register_gsi);
 
+/*
+ *  ACPI based hotplug support for CPU
+ */
+#ifdef CONFIG_ACPI_HOTPLUG_CPU
+int
+acpi_map_lsapic(acpi_handle handle, int *pcpu)
+{
+	/* TBD */
+	return -EINVAL;
+}
+EXPORT_SYMBOL(acpi_map_lsapic);
+
+
+int
+acpi_unmap_lsapic(int cpu)
+{
+	/* TBD */
+	return -EINVAL;
+}
+EXPORT_SYMBOL(acpi_unmap_lsapic);
+#endif /* CONFIG_ACPI_HOTPLUG_CPU */
+
 static unsigned long __init
 acpi_scan_rsdp (
 	unsigned long		start,
diff -Nru a/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c b/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
--- a/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c	2005-01-06 15:06:41 -05:00
+++ b/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c	2005-01-06 15:06:41 -05:00
@@ -249,7 +249,7 @@
 		/* Matched a non-match */
 		printk(KERN_INFO PFX "no table support for CPU model \"%s\": \n",
 		       cpu->x86_model_id);
-#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_ACPI
+#ifndef CONFIG_X86_SPEEDSTEP_CENTRINO_ACPI
 		printk(KERN_INFO PFX "try compiling with CONFIG_X86_SPEEDSTEP_CENTRINO_ACPI enabled\n");
 #endif
 		return -ENOENT;
diff -Nru a/arch/i386/mach-default/topology.c b/arch/i386/mach-default/topology.c
--- a/arch/i386/mach-default/topology.c	2005-01-06 15:06:41 -05:00
+++ b/arch/i386/mach-default/topology.c	2005-01-06 15:06:41 -05:00
@@ -32,6 +32,37 @@
 
 struct i386_cpu cpu_devices[NR_CPUS];
 
+int arch_register_cpu(int num){
+	struct node *parent = NULL;
+	
+#ifdef CONFIG_NUMA
+	int node = cpu_to_node(num);
+	if (node_online(node))
+		parent = &node_devices[node].node;
+#endif /* CONFIG_NUMA */
+
+	return register_cpu(&cpu_devices[num].cpu, num, parent);
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+
+void arch_unregister_cpu(int num) {
+	struct node *parent = NULL;
+
+#ifdef CONFIG_NUMA
+	int node = cpu_to_node(num);
+	if (node_online(node))
+		parent = &node_devices[node].node;
+#endif /* CONFIG_NUMA */
+
+	return unregister_cpu(&cpu_devices[num].cpu, parent);
+}
+EXPORT_SYMBOL(arch_register_cpu);
+EXPORT_SYMBOL(arch_unregister_cpu);
+#endif /*CONFIG_HOTPLUG_CPU*/
+
+
+
 #ifdef CONFIG_NUMA
 #include <linux/mmzone.h>
 #include <asm/node.h>
diff -Nru a/arch/i386/pci/irq.c b/arch/i386/pci/irq.c
--- a/arch/i386/pci/irq.c	2005-01-06 15:06:41 -05:00
+++ b/arch/i386/pci/irq.c	2005-01-06 15:06:41 -05:00
@@ -1022,7 +1022,7 @@
 int pirq_enable_irq(struct pci_dev *dev)
 {
 	u8 pin;
-	extern int interrupt_line_quirk;
+	extern int via_interrupt_line_quirk;
 	struct pci_dev *temp_dev;
 
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
@@ -1080,7 +1080,7 @@
 	}
 	/* VIA bridges use interrupt line for apic/pci steering across
 	   the V-Link */
-	else if (interrupt_line_quirk)
+	else if (via_interrupt_line_quirk)
 		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq & 15);
 	return 0;
 }
diff -Nru a/arch/ia64/dig/Makefile b/arch/ia64/dig/Makefile
--- a/arch/ia64/dig/Makefile	2005-01-06 15:06:41 -05:00
+++ b/arch/ia64/dig/Makefile	2005-01-06 15:06:41 -05:00
@@ -6,9 +6,4 @@
 #
 
 obj-y := setup.o
-
-ifndef CONFIG_NUMA
-obj-$(CONFIG_IA64_DIG) += topology.o
-endif
-
 obj-$(CONFIG_IA64_GENERIC) += machvec.o
diff -Nru a/arch/ia64/dig/topology.c b/arch/ia64/dig/topology.c
--- a/arch/ia64/dig/topology.c	2005-01-06 15:06:41 -05:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,43 +0,0 @@
-/*
- * arch/ia64/dig/topology.c
- *	Popuate driverfs with topology information.
- *	Derived entirely from i386/mach-default.c
- *  Intel Corporation - Ashok Raj
- */
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/cpumask.h>
-#include <linux/percpu.h>
-#include <linux/notifier.h>
-#include <linux/cpu.h>
-#include <asm/cpu.h>
-
-static DEFINE_PER_CPU(struct ia64_cpu, cpu_devices);
-
-/*
- * First Pass: simply borrowed code for now. Later should hook into
- * hotplug notification for node/cpu/memory as applicable
- */
-
-static int arch_register_cpu(int num)
-{
-	struct node *parent = NULL;
-
-#ifdef CONFIG_NUMA
-	//parent = &node_devices[cpu_to_node(num)].node;
-#endif
-
-	return register_cpu(&per_cpu(cpu_devices,num).cpu, num, parent);
-}
-
-static int __init topology_init(void)
-{
-    int i;
-
-    for_each_cpu(i) {
-        arch_register_cpu(i);
-	}
-    return 0;
-}
-
-subsys_initcall(topology_init);
diff -Nru a/arch/ia64/kernel/Makefile b/arch/ia64/kernel/Makefile
--- a/arch/ia64/kernel/Makefile	2005-01-06 15:06:41 -05:00
+++ b/arch/ia64/kernel/Makefile	2005-01-06 15:06:41 -05:00
@@ -6,7 +6,8 @@
 
 obj-y := acpi.o entry.o efi.o efi_stub.o gate-data.o fsys.o ia64_ksyms.o irq.o irq_ia64.o	\
 	 irq_lsapic.o ivt.o machvec.o pal.o patch.o process.o perfmon.o ptrace.o sal.o		\
-	 salinfo.o semaphore.o setup.o signal.o sys_ia64.o time.o traps.o unaligned.o unwind.o mca.o mca_asm.o
+	 salinfo.o semaphore.o setup.o signal.o sys_ia64.o time.o traps.o unaligned.o \
+	 unwind.o mca.o mca_asm.o topology.o
 
 obj-$(CONFIG_IA64_BRL_EMU)	+= brl_emu.o
 obj-$(CONFIG_IA64_GENERIC)	+= acpi-ext.o
diff -Nru a/arch/ia64/kernel/acpi.c b/arch/ia64/kernel/acpi.c
--- a/arch/ia64/kernel/acpi.c	2005-01-06 15:06:41 -05:00
+++ b/arch/ia64/kernel/acpi.c	2005-01-06 15:06:41 -05:00
@@ -355,11 +355,11 @@
 #define PXM_FLAG_LEN ((MAX_PXM_DOMAINS + 1)/32)
 
 static int __initdata srat_num_cpus;			/* number of cpus */
-static u32 __initdata pxm_flag[PXM_FLAG_LEN];
+static u32 __devinitdata pxm_flag[PXM_FLAG_LEN];
 #define pxm_bit_set(bit)	(set_bit(bit,(void *)pxm_flag))
 #define pxm_bit_test(bit)	(test_bit(bit,(void *)pxm_flag))
 /* maps to convert between proximity domain and logical node ID */
-int __initdata pxm_to_nid_map[MAX_PXM_DOMAINS];
+int __devinitdata pxm_to_nid_map[MAX_PXM_DOMAINS];
 int __initdata nid_to_pxm_map[MAX_NUMNODES];
 static struct acpi_table_slit __initdata *slit_table;
 
@@ -651,6 +651,110 @@
 	}
 	return 0;
 }
+
+/*
+ *  ACPI based hotplug CPU support
+ */
+#ifdef CONFIG_ACPI_HOTPLUG_CPU
+static
+int
+acpi_map_cpu2node(acpi_handle handle, int cpu, long physid)
+{
+#ifdef CONFIG_ACPI_NUMA
+	int 			pxm_id;
+
+	pxm_id = acpi_get_pxm(handle);
+
+	/*
+	 * Assuming that the container driver would have set the proximity
+	 * domain and would have initialized pxm_to_nid_map[pxm_id] && pxm_flag
+	 */
+	node_cpuid[cpu].nid = (pxm_id < 0) ? 0:
+			pxm_to_nid_map[pxm_id];
+
+	node_cpuid[cpu].phys_id =  physid;
+#endif
+	return(0);
+}
+
+
+int
+acpi_map_lsapic(acpi_handle handle, int *pcpu)
+{
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object *obj;
+	struct acpi_table_lsapic *lsapic;
+	cpumask_t tmp_map;
+	long physid;
+	int cpu;
+ 
+	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_MAT", NULL, &buffer)))
+		return -EINVAL;
+
+	if (!buffer.length ||  !buffer.pointer)
+		return -EINVAL;
+ 
+	obj = buffer.pointer;
+	if (obj->type != ACPI_TYPE_BUFFER ||
+	    obj->buffer.length < sizeof(*lsapic)) {
+		acpi_os_free(buffer.pointer);
+		return -EINVAL;
+	}
+
+	lsapic = (struct acpi_table_lsapic *)obj->buffer.pointer;
+
+	if ((lsapic->header.type != ACPI_MADT_LSAPIC) ||
+	    (!lsapic->flags.enabled)) {
+		acpi_os_free(buffer.pointer);
+		return -EINVAL;
+	}
+
+	physid = ((lsapic->id <<8) | (lsapic->eid));
+
+	acpi_os_free(buffer.pointer);
+	buffer.length = ACPI_ALLOCATE_BUFFER;
+	buffer.pointer = NULL;
+
+	cpus_complement(tmp_map, cpu_present_map);
+	cpu = first_cpu(tmp_map);
+	if(cpu >= NR_CPUS)
+		return -EINVAL;
+
+	acpi_map_cpu2node(handle, cpu, physid);
+
+ 	cpu_set(cpu, cpu_present_map);
+	ia64_cpu_to_sapicid[cpu] = physid;
+	ia64_acpiid_to_sapicid[lsapic->acpi_id] = ia64_cpu_to_sapicid[cpu];
+
+	*pcpu = cpu;
+	return(0);
+}
+EXPORT_SYMBOL(acpi_map_lsapic);
+
+
+int
+acpi_unmap_lsapic(int cpu)
+{
+	int i;
+
+	for (i=0; i<MAX_SAPICS; i++) {
+ 		if (ia64_acpiid_to_sapicid[i] == ia64_cpu_to_sapicid[cpu]) {
+ 			ia64_acpiid_to_sapicid[i] = -1;
+ 			break;
+ 		}
+ 	}
+	ia64_cpu_to_sapicid[cpu] = -1;
+	cpu_clear(cpu,cpu_present_map);
+
+#ifdef CONFIG_ACPI_NUMA
+	/* NUMA specific cleanup's */
+#endif
+
+	return(0);
+}
+EXPORT_SYMBOL(acpi_unmap_lsapic);
+#endif /* CONFIG_ACPI_HOTPLUG_CPU */
+ 
 
 #ifdef CONFIG_NUMA
 acpi_status __init
diff -Nru a/arch/ia64/kernel/topology.c b/arch/ia64/kernel/topology.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/arch/ia64/kernel/topology.c	2005-01-06 15:06:41 -05:00
@@ -0,0 +1,90 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * This file contains NUMA specific variables and functions which can
+ * be split away from DISCONTIGMEM and are used on NUMA machines with
+ * contiguous memory.
+ * 		2002/08/07 Erich Focht <efocht@ess.nec.de>
+ * Populate cpu entries in sysfs for non-numa systems as well
+ *  	Intel Corporation - Ashok Raj
+ */
+
+#include <linux/config.h>
+#include <linux/cpu.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/node.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+#include <asm/mmzone.h>
+#include <asm/numa.h>
+#include <asm/cpu.h>
+
+#ifdef CONFIG_NUMA
+static struct node *sysfs_nodes;
+#endif
+static struct ia64_cpu *sysfs_cpus;
+
+int arch_register_cpu(int num)
+{
+	struct node *parent = NULL;
+	
+#ifdef CONFIG_NUMA
+	parent = &sysfs_nodes[cpu_to_node(num)];
+#endif /* CONFIG_NUMA */
+
+	return register_cpu(&sysfs_cpus[num].cpu, num, parent);
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+
+void arch_unregister_cpu(int num)
+{
+	struct node *parent = NULL;
+
+#ifdef CONFIG_NUMA
+	int node = cpu_to_node(num);
+	parent = &sysfs_nodes[node];
+#endif /* CONFIG_NUMA */
+
+	return unregister_cpu(&sysfs_cpus[num].cpu, parent);
+}
+EXPORT_SYMBOL(arch_register_cpu);
+EXPORT_SYMBOL(arch_unregister_cpu);
+#endif /*CONFIG_HOTPLUG_CPU*/
+
+
+static int __init topology_init(void)
+{
+	int i, err = 0;
+
+#ifdef CONFIG_NUMA
+	sysfs_nodes = kmalloc(sizeof(struct node) * MAX_NUMNODES, GFP_KERNEL);
+	if (!sysfs_nodes) {
+		err = -ENOMEM;
+		goto out;
+	}
+	memset(sysfs_nodes, 0, sizeof(struct node) * MAX_NUMNODES);
+
+	for (i = 0; i < numnodes; i++)
+		if ((err = register_node(&sysfs_nodes[i], i, 0)))
+			goto out;
+#endif
+
+	sysfs_cpus = kmalloc(sizeof(struct ia64_cpu) * NR_CPUS, GFP_KERNEL);
+	if (!sysfs_cpus) {
+		err = -ENOMEM;
+		goto out;
+	}
+	memset(sysfs_cpus, 0, sizeof(struct ia64_cpu) * NR_CPUS);
+
+	for_each_present_cpu(i)
+		if((err = arch_register_cpu(i)))
+			goto out;
+out:
+	return err;
+}
+
+__initcall(topology_init);
diff -Nru a/arch/ia64/mm/numa.c b/arch/ia64/mm/numa.c
--- a/arch/ia64/mm/numa.c	2005-01-06 15:06:41 -05:00
+++ b/arch/ia64/mm/numa.c	2005-01-06 15:06:41 -05:00
@@ -20,8 +20,6 @@
 #include <asm/mmzone.h>
 #include <asm/numa.h>
 
-static struct node *sysfs_nodes;
-static struct cpu *sysfs_cpus;
 
 /*
  * The following structures are usually initialized by ACPI or
@@ -49,37 +47,3 @@
 
 	return (i < num_node_memblks) ? node_memblk[i].nid : (num_node_memblks ? -1 : 0);
 }
-
-static int __init topology_init(void)
-{
-	int i, err = 0;
-
-	sysfs_nodes = kmalloc(sizeof(struct node) * numnodes, GFP_KERNEL);
-	if (!sysfs_nodes) {
-		err = -ENOMEM;
-		goto out;
-	}
-	memset(sysfs_nodes, 0, sizeof(struct node) * numnodes);
-
-	sysfs_cpus = kmalloc(sizeof(struct cpu) * NR_CPUS, GFP_KERNEL);
-	if (!sysfs_cpus) {
-		kfree(sysfs_nodes);
-		err = -ENOMEM;
-		goto out;
-	}
-	memset(sysfs_cpus, 0, sizeof(struct cpu) * NR_CPUS);
-
-	for (i = 0; i < numnodes; i++)
-		if ((err = register_node(&sysfs_nodes[i], i, NULL)))
-			goto out;
-
-	for (i = 0; i < NR_CPUS; i++)
-		if (cpu_online(i))
-			if((err = register_cpu(&sysfs_cpus[i], i,
-					       &sysfs_nodes[cpu_to_node(i)])))
-				goto out;
- out:
-	return err;
-}
-
-__initcall(topology_init);
diff -Nru a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
--- a/drivers/acpi/Kconfig	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/Kconfig	2005-01-06 15:06:41 -05:00
@@ -144,6 +144,15 @@
 	  ACPI C2 and C3 processor states to save power, on systems that
 	  support it.
 
+config ACPI_HOTPLUG_CPU
+	bool "Processor Hotplug (EXPERIMENTAL)"
+	depends on ACPI_PROCESSOR && HOTPLUG_CPU && EXPERIMENTAL
+	depends on !IA64_SGI_SN
+	select ACPI_CONTAINER
+	default n
+	 ---help---
+	 Select this option if your platform support physical CPU hotplug.
+
 config ACPI_THERMAL
 	tristate "Thermal Zone"
 	depends on ACPI_PROCESSOR
@@ -325,5 +334,12 @@
 	  kernel logs, and/or you are using this on a notebook which
 	  does not yet have an HPET, you should say "Y" here.
 
-endmenu
+config ACPI_CONTAINER
+	tristate "ACPI0004,PNP0A05 and PNP0A06 Container Driver (EXPERIMENTAL)"
+	depends on ACPI && EXPERIMENTAL
+	default (ACPI_HOTPLUG_MEMORY || ACPI_HOTPLUG_CPU || ACPI_HOTPLUG_IO)
+	 ---help---
+	 	This is the ACPI generic container driver which supports
+		ACPI0004, PNP0A05 and PNP0A06 devices
 
+endmenu
diff -Nru a/drivers/acpi/Makefile b/drivers/acpi/Makefile
--- a/drivers/acpi/Makefile	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/Makefile	2005-01-06 15:06:41 -05:00
@@ -29,6 +29,12 @@
 #
 # ACPI Bus and Device Drivers
 #
+processor-objs	+= processor_core.o processor_throttling.o \
+				processor_idle.o processor_thermal.o
+ifdef CONFIG_CPU_FREQ
+processor-objs	+= processor_perflib.o			
+endif
+
 obj-$(CONFIG_ACPI_BUS)		+= sleep/
 obj-$(CONFIG_ACPI_BUS)		+= bus.o
 obj-$(CONFIG_ACPI_AC) 		+= ac.o
@@ -40,6 +46,7 @@
 obj-$(CONFIG_ACPI_PCI)		+= pci_root.o pci_link.o pci_irq.o pci_bind.o
 obj-$(CONFIG_ACPI_POWER)	+= power.o
 obj-$(CONFIG_ACPI_PROCESSOR)	+= processor.o
+obj-$(CONFIG_ACPI_CONTAINER)	+= container.o
 obj-$(CONFIG_ACPI_THERMAL)	+= thermal.o
 obj-$(CONFIG_ACPI_SYSTEM)	+= system.o event.o
 obj-$(CONFIG_ACPI_DEBUG)	+= debug.o
diff -Nru a/drivers/acpi/asus_acpi.c b/drivers/acpi/asus_acpi.c
--- a/drivers/acpi/asus_acpi.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/asus_acpi.c	2005-01-06 15:06:41 -05:00
@@ -866,7 +866,7 @@
 
 	acpi_device_dir(device) = asus_proc_dir;
 	if (!acpi_device_dir(device))
-		return(-ENODEV);
+		return -ENODEV;
 
 	proc = create_proc_entry(PROC_INFO, mode, acpi_device_dir(device));
 	if (proc) {
@@ -1098,16 +1098,16 @@
 
 	result = acpi_bus_get_status(hotk->device);
 	if (result)
-		return(result);
+		return result;
 
 	if (hotk->device->status.present) {
 		result = asus_hotk_get_info();
 	} else {
 		printk(KERN_ERR "  Hotkey device not present, aborting\n");
-		return(-EINVAL);
+		return -EINVAL;
 	}
 
-	return(result);
+	return result;
 }
 
 
@@ -1117,7 +1117,7 @@
 	int result;
 
 	if (!device)
-		return(-EINVAL);
+		return -EINVAL;
 
 	printk(KERN_NOTICE "Asus Laptop ACPI Extras version %s\n",
 	       ASUS_ACPI_VERSION);
@@ -1125,7 +1125,7 @@
 	hotk =
 	    (struct asus_hotk *) kmalloc(sizeof(struct asus_hotk), GFP_KERNEL);
 	if (!hotk)
-		return(-ENOMEM);
+		return -ENOMEM;
 	memset(hotk, 0, sizeof(struct asus_hotk));
 
 	hotk->handle = device->handle;
@@ -1173,7 +1173,7 @@
 		kfree(hotk);
 	}
 
-	return(result);
+	return result;
 }
 
 
@@ -1182,7 +1182,7 @@
 	acpi_status status = 0;
 
 	if (!device || !acpi_driver_data(device))
-		return(-EINVAL);
+		return -EINVAL;
 
 	status = acpi_remove_notify_handler(hotk->handle, ACPI_SYSTEM_NOTIFY,
 					    asus_hotk_notify);
@@ -1193,7 +1193,7 @@
 
 	kfree(hotk);
 
-	return(0);
+	return 0;
 }
 
 
diff -Nru a/drivers/acpi/bus.c b/drivers/acpi/bus.c
--- a/drivers/acpi/bus.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/bus.c	2005-01-06 15:06:41 -05:00
@@ -57,10 +57,6 @@
                                 Device Management
    -------------------------------------------------------------------------- */
 
-extern void acpi_bus_data_handler (
-	acpi_handle		handle,
-	u32			function,
-	void			*context);
 int
 acpi_bus_get_device (
 	acpi_handle		handle,
@@ -77,7 +73,7 @@
 
 	status = acpi_get_data(handle, acpi_bus_data_handler, (void**) device);
 	if (ACPI_FAILURE(status) || !*device) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context for object [%p]\n",
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "No context for object [%p]\n",
 			handle));
 		return_VALUE(-ENODEV);
 	}
diff -Nru a/drivers/acpi/container.c b/drivers/acpi/container.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/acpi/container.c	2005-01-06 15:06:41 -05:00
@@ -0,0 +1,298 @@
+/*
+ * acpi_container.c  - ACPI Generic Container Driver
+ * ($Revision: )
+ *
+ * Copyright (C) 2004 Anil S Keshavamurthy (anil.s.keshavamurthy@intel.com)
+ * Copyright (C) 2004 Keiichiro Tokunaga (tokunaga.keiich@jp.fujitsu.com)
+ * Copyright (C) 2004 Motoyuki Ito (motoyuki@soft.fujitsu.com)
+ * Copyright (C) 2004 Intel Corp.
+ * Copyright (C) 2004 FUJITSU LIMITED
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/container.h>
+
+#define ACPI_CONTAINER_DRIVER_NAME	"ACPI container driver"
+#define ACPI_CONTAINER_DEVICE_NAME	"ACPI container device"
+#define ACPI_CONTAINER_CLASS		"container"
+
+#define INSTALL_NOTIFY_HANDLER		1
+#define UNINSTALL_NOTIFY_HANDLER	2
+
+#define ACPI_CONTAINER_COMPONENT	0x01000000
+#define _COMPONENT			ACPI_CONTAINER_COMPONENT
+ACPI_MODULE_NAME			("acpi_container")
+
+MODULE_AUTHOR("Anil S Keshavamurthy");
+MODULE_DESCRIPTION(ACPI_CONTAINER_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define ACPI_STA_PRESENT		(0x00000001)
+
+static int acpi_container_add(struct acpi_device *device);
+static int acpi_container_remove(struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_container_driver = {
+	.name =		ACPI_CONTAINER_DRIVER_NAME,
+	.class =	ACPI_CONTAINER_CLASS,
+	.ids =		"ACPI0004,PNP0A05,PNP0A06",
+	.ops =		{
+				.add =		acpi_container_add,
+				.remove =	acpi_container_remove,
+			},
+};
+
+
+/*******************************************************************/
+
+static int
+is_device_present(acpi_handle handle)
+{
+	acpi_handle		temp;
+	acpi_status		status;
+	unsigned long	sta;
+
+	ACPI_FUNCTION_TRACE("is_device_present");
+
+	status = acpi_get_handle(handle, "_STA", &temp);
+	if (ACPI_FAILURE(status))
+		return_VALUE(1); /* _STA not found, assmue device present */
+
+	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
+	if (ACPI_FAILURE(status))
+		return_VALUE(0); /* Firmware error */
+
+	return_VALUE((sta & ACPI_STA_PRESENT) == ACPI_STA_PRESENT);
+}
+
+/*******************************************************************/
+static int
+acpi_container_add(struct acpi_device *device)
+{
+	struct acpi_container *container;
+
+	ACPI_FUNCTION_TRACE("acpi_container_add");
+
+	if (!device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "device is NULL\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	container = kmalloc(sizeof(struct acpi_container), GFP_KERNEL);
+	if(!container)
+		return_VALUE(-ENOMEM);
+	
+	memset(container, 0, sizeof(struct acpi_container));
+	container->handle = device->handle;
+	strcpy(acpi_device_name(device), ACPI_CONTAINER_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_CONTAINER_CLASS);
+	acpi_driver_data(device) = container;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device <%s> bid <%s>\n",	\
+		acpi_device_name(device), acpi_device_bid(device)));
+
+
+	return_VALUE(0);
+}
+
+static int
+acpi_container_remove(struct acpi_device *device, int type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_container	*pc = NULL;
+	pc = (struct acpi_container*) acpi_driver_data(device);
+
+	if (pc)
+		kfree(pc);
+
+	return status;
+}
+
+
+static int
+container_device_add(struct acpi_device **device, acpi_handle handle)
+{
+	acpi_handle phandle;
+	struct acpi_device *pdev;
+	int result;
+
+	ACPI_FUNCTION_TRACE("container_device_add");
+
+	if (acpi_get_parent(handle, &phandle)) {
+		return_VALUE(-ENODEV);
+	}
+
+	if (acpi_bus_get_device(phandle, &pdev)) {
+		return_VALUE(-ENODEV);
+	}
+
+	if (acpi_bus_add(device, pdev, handle, ACPI_BUS_TYPE_DEVICE)) {
+		return_VALUE(-ENODEV);
+	}
+
+	result = acpi_bus_scan(*device);
+
+	return_VALUE(result);
+}
+
+static void
+container_notify_cb(acpi_handle handle, u32 type, void *context)
+{
+	struct acpi_device		*device = NULL;
+	int result;
+	int present;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE("container_notify_cb");
+
+	present = is_device_present(handle);
+	
+	switch (type) {
+	case ACPI_NOTIFY_BUS_CHECK:
+		/* Fall through */
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		printk("Container driver received %s event\n",
+			(type == ACPI_NOTIFY_BUS_CHECK)?
+			"ACPI_NOTIFY_BUS_CHECK":"ACPI_NOTIFY_DEVICE_CHECK");
+		if (present) {
+			status = acpi_bus_get_device(handle, &device);
+			if (ACPI_FAILURE(status) || !device) {
+				result = container_device_add(&device, handle);
+				if (!result)
+					kobject_hotplug(&device->kobj, KOBJ_ONLINE);
+			} else {
+				/* device exist and this is a remove request */
+				kobject_hotplug(&device->kobj, KOBJ_OFFLINE);
+			}
+		}
+		break;
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		if (!acpi_bus_get_device(handle, &device) && device) {
+			kobject_hotplug(&device->kobj, KOBJ_OFFLINE);
+		}
+		break;
+	default:
+		break;
+	}
+	return_VOID;
+}
+
+static acpi_status
+container_walk_namespace_cb(acpi_handle handle,
+	u32 lvl,
+	void *context,
+	void **rv)
+{
+	char 				*hid = NULL;
+	struct acpi_buffer 		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_device_info 	*info;
+	acpi_status 			status;
+	int 				*action = context;
+
+	ACPI_FUNCTION_TRACE("container_walk_namespace_cb");
+
+	status = acpi_get_object_info(handle, &buffer);
+	if (ACPI_FAILURE(status) || !buffer.pointer) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	info = buffer.pointer;
+	if (info->valid & ACPI_VALID_HID)
+		hid = info->hardware_id.value;
+
+	if (hid == NULL) {
+		goto end;
+	}
+
+	if (strcmp(hid, "ACPI0004") && strcmp(hid, "PNP0A05") &&
+			strcmp(hid, "PNP0A06")) {
+		goto end;
+	}
+
+	switch(*action) {
+	case INSTALL_NOTIFY_HANDLER:
+		acpi_install_notify_handler(handle,
+			ACPI_SYSTEM_NOTIFY,
+			container_notify_cb,
+			NULL);
+		break;
+	case UNINSTALL_NOTIFY_HANDLER:
+		acpi_remove_notify_handler(handle,
+			ACPI_SYSTEM_NOTIFY,
+			container_notify_cb);
+		break;
+	default:
+		break;
+	}
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+
+int __init
+acpi_container_init(void)
+{
+	int	result = 0;
+	int	action = INSTALL_NOTIFY_HANDLER;
+
+	result = acpi_bus_register_driver(&acpi_container_driver);
+	if (result < 0) {
+		return(result);
+	}
+
+	/* register notify handler to every container device */
+	acpi_walk_namespace(ACPI_TYPE_DEVICE,
+				     ACPI_ROOT_OBJECT,
+				     ACPI_UINT32_MAX,
+				     container_walk_namespace_cb,
+				     &action, NULL);
+
+	return(0);
+}
+
+void __exit
+acpi_container_exit(void)
+{
+	int			action = UNINSTALL_NOTIFY_HANDLER;
+
+	ACPI_FUNCTION_TRACE("acpi_container_exit");
+
+	acpi_walk_namespace(ACPI_TYPE_DEVICE,
+				     ACPI_ROOT_OBJECT,
+				     ACPI_UINT32_MAX,
+				     container_walk_namespace_cb,
+				     &action, NULL);
+
+	acpi_bus_unregister_driver(&acpi_container_driver);
+
+	return_VOID;
+}
+
+module_init(acpi_container_init);
+module_exit(acpi_container_exit);
diff -Nru a/drivers/acpi/dispatcher/dsopcode.c b/drivers/acpi/dispatcher/dsopcode.c
--- a/drivers/acpi/dispatcher/dsopcode.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/dispatcher/dsopcode.c	2005-01-06 15:06:41 -05:00
@@ -762,9 +762,8 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Get the operands and complete the following data objec types:
- *              Buffer
- *              Package
+ * DESCRIPTION: Get the operands and complete the following data object types:
+ *              Buffer, Package.
  *
  ****************************************************************************/
 
diff -Nru a/drivers/acpi/dispatcher/dswexec.c b/drivers/acpi/dispatcher/dswexec.c
--- a/drivers/acpi/dispatcher/dswexec.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/dispatcher/dswexec.c	2005-01-06 15:06:41 -05:00
@@ -399,16 +399,24 @@
 			goto cleanup;
 		}
 
-		/* Resolve all operands */
+		/*
+		 * All opcodes require operand resolution, with the only exceptions
+		 * being the object_type and size_of operators.
+		 */
+		if (!(walk_state->op_info->flags & AML_NO_OPERAND_RESOLVE)) {
+			/* Resolve all operands */
 
-		status = acpi_ex_resolve_operands (walk_state->opcode,
-				  &(walk_state->operands [walk_state->num_operands -1]),
-				  walk_state);
-		if (ACPI_SUCCESS (status)) {
-			ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
-					  acpi_ps_get_opcode_name (walk_state->opcode),
-					  walk_state->num_operands, "after ex_resolve_operands");
+			status = acpi_ex_resolve_operands (walk_state->opcode,
+					  &(walk_state->operands [walk_state->num_operands -1]),
+					  walk_state);
+			if (ACPI_SUCCESS (status)) {
+				ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
+						  acpi_ps_get_opcode_name (walk_state->opcode),
+						  walk_state->num_operands, "after ex_resolve_operands");
+			}
+		}
 
+		if (ACPI_SUCCESS (status)) {
 			/*
 			 * Dispatch the request to the appropriate interpreter handler
 			 * routine.  There is one routine per opcode "type" based upon the
diff -Nru a/drivers/acpi/ec.c b/drivers/acpi/ec.c
--- a/drivers/acpi/ec.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/ec.c	2005-01-06 15:06:41 -05:00
@@ -442,6 +442,8 @@
 	int			result = 0;
 	struct acpi_ec		*ec = NULL;
 	u32			temp = 0;
+	acpi_integer		f_v = 0;
+	int 			i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_ec_space_handler");
 
@@ -456,6 +458,7 @@
 
 	ec = (struct acpi_ec *) handler_context;
 
+next_byte:
 	switch (function) {
 	case ACPI_READ:
 		result = acpi_ec_read(ec, (u8) address, &temp);
@@ -466,9 +469,29 @@
 		break;
 	default:
 		result = -EINVAL;
+		goto out;
 		break;
 	}
 
+	bit_width -= 8;
+	if(bit_width){
+
+		if(function == ACPI_READ)
+			f_v |= (acpi_integer) (*value) << 8*i;
+		if(function == ACPI_WRITE)
+			(*value) >>=8; 
+		i++;
+		goto next_byte;
+	}
+
+
+	if(function == ACPI_READ){
+		f_v |= (acpi_integer) (*value) << 8*i;
+		*value = f_v;
+	}
+
+		
+out:
 	switch (result) {
 	case -EINVAL:
 		return_VALUE(AE_BAD_PARAMETER);
@@ -482,6 +505,7 @@
 	default:
 		return_VALUE(AE_OK);
 	}
+	
 
 }
 
@@ -787,9 +811,81 @@
 	return_VALUE(0);
 }
 
+static acpi_status __init
+acpi_fake_ecdt_callback (
+	acpi_handle	handle,
+	u32		Level,
+	void		*context,
+	void		**retval)
+{
+	acpi_status	status;
 
-int __init
-acpi_ec_ecdt_probe (void)
+	status = acpi_walk_resources(handle, METHOD_NAME__CRS,
+		acpi_ec_io_ports, ec_ecdt);
+	if (ACPI_FAILURE(status))
+		return status;
+	ec_ecdt->status_addr = ec_ecdt->command_addr;
+
+	ec_ecdt->uid = -1;
+	acpi_evaluate_integer(handle, "_UID", NULL, &ec_ecdt->uid);
+
+	status = acpi_evaluate_integer(handle, "_GPE", NULL, &ec_ecdt->gpe_bit);
+	if (ACPI_FAILURE(status))
+		return status;
+	ec_ecdt->lock = SPIN_LOCK_UNLOCKED;
+	ec_ecdt->global_lock = TRUE;
+	ec_ecdt->handle = handle;
+
+	printk(KERN_INFO PREFIX  "GPE=0x%02x, ports=0x%2x, 0x%2x\n",
+		(u32) ec_ecdt->gpe_bit, (u32) ec_ecdt->command_addr.address,
+		(u32) ec_ecdt->data_addr.address);
+
+	return AE_CTRL_TERMINATE;
+}
+
+/*
+ * Some BIOS (such as some from Gateway laptops) access EC region very early
+ * such as in BAT0._INI or EC._INI before an EC device is found and
+ * do not provide an ECDT. According to ACPI spec, ECDT isn't mandatorily
+ * required, but if EC regison is accessed early, it is required.
+ * The routine tries to workaround the BIOS bug by pre-scan EC device
+ * It assumes that _CRS, _HID, _GPE, _UID methods of EC don't touch any
+ * op region (since _REG isn't invoked yet). The assumption is true for
+ * all systems found.
+ */
+static int __init
+acpi_ec_fake_ecdt(void)
+{
+	acpi_status	status;
+	int		ret = 0;
+
+	printk(KERN_INFO PREFIX "Try to make an fake ECDT\n");
+
+	ec_ecdt = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
+	if (!ec_ecdt) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	memset(ec_ecdt, 0, sizeof(struct acpi_ec));
+
+	status = acpi_get_devices (ACPI_EC_HID,
+				acpi_fake_ecdt_callback,
+				NULL,
+				NULL);
+	if (ACPI_FAILURE(status)) {
+		kfree(ec_ecdt);
+		ec_ecdt = NULL;
+		ret = -ENODEV;
+		goto error;
+	}
+	return 0;
+error:
+	printk(KERN_ERR PREFIX "Can't make an fake ECDT\n");
+	return ret;
+}
+
+static int __init
+acpi_ec_get_real_ecdt(void)
 {
 	acpi_status		status;
 	struct acpi_table_ecdt 	*ecdt_ptr;
@@ -797,11 +893,11 @@
 	status = acpi_get_firmware_table("ECDT", 1, ACPI_LOGICAL_ADDRESSING, 
 		(struct acpi_table_header **) &ecdt_ptr);
 	if (ACPI_FAILURE(status))
-		return 0;
+		return -ENODEV;
 
 	printk(KERN_INFO PREFIX "Found ECDT\n");
 
-	 /*
+	/*
 	 * Generate a temporary ec context to use until the namespace is scanned
 	 */
 	ec_ecdt = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
@@ -823,6 +919,31 @@
 		goto error;
 	}
 
+	return 0;
+error:
+	printk(KERN_ERR PREFIX "Could not use ECDT\n");
+	kfree(ec_ecdt);
+	ec_ecdt = NULL;
+
+	return -ENODEV;
+}
+
+static int __initdata acpi_fake_ecdt_enabled;
+int __init
+acpi_ec_ecdt_probe (void)
+{
+	acpi_status		status;
+	int			ret;
+
+	ret = acpi_ec_get_real_ecdt();
+	/* Try to make a fake ECDT */
+	if (ret && acpi_fake_ecdt_enabled) {
+		ret = acpi_ec_fake_ecdt();
+	}
+
+	if (ret)
+		return 0;
+
 	/*
 	 * Install GPE handler
 	 */
@@ -895,3 +1016,9 @@
 }
 #endif /* 0 */
 
+static int __init acpi_fake_ecdt_setup(char *str)
+{
+	acpi_fake_ecdt_enabled = 1;
+	return 0;
+}
+__setup("acpi_fake_ecdt", acpi_fake_ecdt_setup);
diff -Nru a/drivers/acpi/events/evgpe.c b/drivers/acpi/events/evgpe.c
--- a/drivers/acpi/events/evgpe.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/events/evgpe.c	2005-01-06 15:06:41 -05:00
@@ -605,8 +605,8 @@
 	if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) == ACPI_GPE_EDGE_TRIGGERED) {
 		status = acpi_hw_clear_gpe (gpe_event_info);
 		if (ACPI_FAILURE (status)) {
-			ACPI_REPORT_ERROR (("acpi_ev_gpe_dispatch: Unable to clear GPE[%2X]\n",
-				gpe_number));
+			ACPI_REPORT_ERROR (("acpi_ev_gpe_dispatch: %s, Unable to clear GPE[%2X]\n",
+				acpi_format_exception (status), gpe_number));
 			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
 		}
 	}
@@ -643,8 +643,8 @@
 			status = acpi_hw_clear_gpe (gpe_event_info);
 			if (ACPI_FAILURE (status)) {
 				ACPI_REPORT_ERROR ((
-					"acpi_ev_gpe_dispatch: Unable to clear GPE[%2X]\n",
-					gpe_number));
+					"acpi_ev_gpe_dispatch: %s, Unable to clear GPE[%2X]\n",
+					acpi_format_exception (status), gpe_number));
 				return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
 			}
 		}
@@ -659,8 +659,8 @@
 		status = acpi_ev_disable_gpe (gpe_event_info);
 		if (ACPI_FAILURE (status)) {
 			ACPI_REPORT_ERROR ((
-				"acpi_ev_gpe_dispatch: Unable to disable GPE[%2X]\n",
-				gpe_number));
+				"acpi_ev_gpe_dispatch: %s, Unable to disable GPE[%2X]\n",
+				acpi_format_exception (status), gpe_number));
 			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
 		}
 
@@ -668,12 +668,12 @@
 		 * Execute the method associated with the GPE
 		 * NOTE: Level-triggered GPEs are cleared after the method completes.
 		 */
-		if (ACPI_FAILURE (acpi_os_queue_for_execution (OSD_PRIORITY_GPE,
-				 acpi_ev_asynch_execute_gpe_method,
-				 gpe_event_info))) {
+		status = acpi_os_queue_for_execution (OSD_PRIORITY_GPE,
+				 acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+		if (ACPI_FAILURE (status)) {
 			ACPI_REPORT_ERROR ((
-				"acpi_ev_gpe_dispatch: Unable to queue handler for GPE[%2X], event is disabled\n",
-				gpe_number));
+				"acpi_ev_gpe_dispatch: %s, Unable to queue handler for GPE[%2X] - event disabled\n",
+				acpi_format_exception (status), gpe_number));
 		}
 		break;
 
@@ -692,8 +692,8 @@
 		status = acpi_ev_disable_gpe (gpe_event_info);
 		if (ACPI_FAILURE (status)) {
 			ACPI_REPORT_ERROR ((
-				"acpi_ev_gpe_dispatch: Unable to disable GPE[%2X]\n",
-				gpe_number));
+				"acpi_ev_gpe_dispatch: %s, Unable to disable GPE[%2X]\n",
+				acpi_format_exception (status), gpe_number));
 			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
 		}
 		break;
diff -Nru a/drivers/acpi/events/evxfevnt.c b/drivers/acpi/events/evxfevnt.c
--- a/drivers/acpi/events/evxfevnt.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/events/evxfevnt.c	2005-01-06 15:06:41 -05:00
@@ -435,7 +435,7 @@
  * DESCRIPTION: Clear an ACPI event (fixed)
  *
  ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
+
 acpi_status
 acpi_clear_event (
 	u32                             event)
@@ -462,7 +462,6 @@
 	return_ACPI_STATUS (status);
 }
 EXPORT_SYMBOL(acpi_clear_event);
-#endif  /*  ACPI_FUTURE_USAGE  */
 
 
 /*******************************************************************************
diff -Nru a/drivers/acpi/executer/exconfig.c b/drivers/acpi/executer/exconfig.c
--- a/drivers/acpi/executer/exconfig.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exconfig.c	2005-01-06 15:06:41 -05:00
@@ -95,7 +95,7 @@
 
 	ACPI_MEMSET (&table_info, 0, sizeof (struct acpi_table_desc));
 
-	table_info.type        = 5;
+	table_info.type        = ACPI_TABLE_SSDT;
 	table_info.pointer     = table;
 	table_info.length      = (acpi_size) table->length;
 	table_info.allocation  = ACPI_MEM_ALLOCATED;
diff -Nru a/drivers/acpi/executer/exconvrt.c b/drivers/acpi/executer/exconvrt.c
--- a/drivers/acpi/executer/exconvrt.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exconvrt.c	2005-01-06 15:06:41 -05:00
@@ -115,12 +115,6 @@
 	 */
 	result = 0;
 
-	/* Transfer no more than an integer's worth of data */
-
-	if (count > acpi_gbl_integer_byte_width) {
-		count = acpi_gbl_integer_byte_width;
-	}
-
 	/*
 	 * String conversion is different than Buffer conversion
 	 */
@@ -142,6 +136,12 @@
 
 	case ACPI_TYPE_BUFFER:
 
+		/* Transfer no more than an integer's worth of data */
+
+		if (count > acpi_gbl_integer_byte_width) {
+			count = acpi_gbl_integer_byte_width;
+		}
+
 		/*
 		 * Convert buffer to an integer - we simply grab enough raw data
 		 * from the buffer to fill an integer
@@ -173,6 +173,7 @@
 	/* Save the Result */
 
 	return_desc->integer.value = result;
+	acpi_ex_truncate_for32bit_table (return_desc);
 	*result_desc = return_desc;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -398,9 +399,9 @@
 {
 	union acpi_operand_object       *return_desc;
 	u8                              *new_buf;
+	u32                             i;
 	u32                             string_length = 0;
 	u16                             base = 16;
-	u32                             i;
 	u8                              separator = ',';
 
 
@@ -460,6 +461,8 @@
 
 	case ACPI_TYPE_BUFFER:
 
+		/* Setup string length, base, and separator */
+
 		switch (type) {
 		case ACPI_EXPLICIT_CONVERT_DECIMAL: /* Used by to_decimal_string operator */
 			/*
@@ -467,9 +470,23 @@
 			 * decimal values separated by commas."
 			 */
 			base = 10;
-			string_length = obj_desc->buffer.length; /* 4 chars for each decimal */
 
-			/*lint -fallthrough */
+			/*
+			 * Calculate the final string length.  Individual string values
+			 * are variable length (include separator for each)
+			 */
+			for (i = 0; i < obj_desc->buffer.length; i++) {
+				if (obj_desc->buffer.pointer[i] >= 100) {
+					string_length += 4;
+				}
+				else if (obj_desc->buffer.pointer[i] >= 10) {
+					string_length += 3;
+				}
+				else {
+					string_length += 2;
+				}
+			}
+			break;
 
 		case ACPI_IMPLICIT_CONVERT_HEX:
 			/*
@@ -477,55 +494,56 @@
 			 *"The entire contents of the buffer are converted to a string of
 			 * two-character hexadecimal numbers, each separated by a space."
 			 */
-			if (type == ACPI_IMPLICIT_CONVERT_HEX) {
-				separator = ' ';
-			}
-
-			/*lint -fallthrough */
+			separator = ' ';
+			string_length = (obj_desc->buffer.length * 3);
+			break;
 
 		case ACPI_EXPLICIT_CONVERT_HEX:     /* Used by to_hex_string operator */
 			/*
 			 * From ACPI: "If Data is a buffer, it is converted to a string of
 			 * hexadecimal values separated by commas."
 			 */
-			string_length += (obj_desc->buffer.length * 3);
-			if (string_length > ACPI_MAX_STRING_CONVERSION) /* ACPI limit */ {
-				return_ACPI_STATUS (AE_AML_STRING_LIMIT);
-			}
-
-			/* Create a new string object and string buffer */
-
-			return_desc = acpi_ut_create_string_object ((acpi_size) string_length -1);
-			if (!return_desc) {
-				return_ACPI_STATUS (AE_NO_MEMORY);
-			}
+			string_length = (obj_desc->buffer.length * 3);
+			break;
 
-			new_buf = return_desc->buffer.pointer;
+		default:
+			return_ACPI_STATUS (AE_BAD_PARAMETER);
+		}
 
-			/*
-			 * Convert buffer bytes to hex or decimal values
-			 * (separated by commas)
-			 */
-			for (i = 0; i < obj_desc->buffer.length; i++) {
-				new_buf += acpi_ex_convert_to_ascii (
-						 (acpi_integer) obj_desc->buffer.pointer[i], base,
-						 new_buf, 1);
-				*new_buf++ = separator; /* each separated by a comma or space */
-			}
+		/*
+		 * Perform the conversion.
+		 * (-1 because of extra separator included in string_length from above)
+		 */
+		string_length--;
+		if (string_length > ACPI_MAX_STRING_CONVERSION) /* ACPI limit */ {
+			return_ACPI_STATUS (AE_AML_STRING_LIMIT);
+		}
 
-			/* Null terminate the string (overwrites final comma from above) */
+		/*
+		 * Create a new string object and string buffer
+		 */
+		return_desc = acpi_ut_create_string_object ((acpi_size) string_length);
+		if (!return_desc) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
 
-			new_buf--;
-			*new_buf = 0;
+		new_buf = return_desc->buffer.pointer;
 
-			/* Recalculate length */
+		/*
+		 * Convert buffer bytes to hex or decimal values
+		 * (separated by commas or spaces)
+		 */
+		for (i = 0; i < obj_desc->buffer.length; i++) {
+			new_buf += acpi_ex_convert_to_ascii (
+					 (acpi_integer) obj_desc->buffer.pointer[i], base,
+					 new_buf, 1);
+			*new_buf++ = separator; /* each separated by a comma or space */
+		}
 
-			return_desc->string.length = ACPI_STRLEN (return_desc->string.pointer);
-			break;
+		/* Null terminate the string (overwrites final comma/space from above) */
 
-		default:
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
-		}
+		new_buf--;
+		*new_buf = 0;
 		break;
 
 	default:
diff -Nru a/drivers/acpi/executer/exdump.c b/drivers/acpi/executer/exdump.c
--- a/drivers/acpi/executer/exdump.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exdump.c	2005-01-06 15:06:41 -05:00
@@ -110,10 +110,12 @@
 	/* obj_desc is a valid object */
 
 	if (depth > 0) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC, "%*s[%u] ", depth, " ", depth));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%*s[%u] %p ",
+			depth, " ", depth, obj_desc));
+	}
+	else {
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p ", obj_desc));
 	}
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC, "%p ", obj_desc));
-
 
 	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_LOCAL_REFERENCE:
@@ -712,9 +714,6 @@
 		acpi_ex_out_integer ("bit_length",  obj_desc->common_field.bit_length);
 		acpi_ex_out_integer ("fld_bit_offset", obj_desc->common_field.start_field_bit_offset);
 		acpi_ex_out_integer ("base_byte_offset", obj_desc->common_field.base_byte_offset);
-		acpi_ex_out_integer ("datum_valid_bits", obj_desc->common_field.datum_valid_bits);
-		acpi_ex_out_integer ("end_fld_valid_bits",obj_desc->common_field.end_field_valid_bits);
-		acpi_ex_out_integer ("end_buf_valid_bits",obj_desc->common_field.end_buffer_valid_bits);
 		acpi_ex_out_pointer ("parent_node", obj_desc->common_field.node);
 
 		switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
diff -Nru a/drivers/acpi/executer/exfldio.c b/drivers/acpi/executer/exfldio.c
--- a/drivers/acpi/executer/exfldio.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exfldio.c	2005-01-06 15:06:41 -05:00
@@ -612,210 +612,6 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ex_get_buffer_datum
- *
- * PARAMETERS:  Datum               - Where the Datum is returned
- *              Buffer              - Raw field buffer
- *              buffer_length       - Entire length (used for big-endian only)
- *              byte_granularity    - 1/2/4/8 Granularity of the field
- *                                    (aka Datum Size)
- *              buffer_offset       - Datum offset into the buffer
- *
- * RETURN:      none
- *
- * DESCRIPTION: Get a datum from the buffer according to the buffer field
- *              byte granularity
- *
- ******************************************************************************/
-
-void
-acpi_ex_get_buffer_datum (
-	acpi_integer                    *datum,
-	void                            *buffer,
-	u32                             buffer_length,
-	u32                             byte_granularity,
-	u32                             buffer_offset)
-{
-	u32                             index;
-
-
-	ACPI_FUNCTION_TRACE_U32 ("ex_get_buffer_datum", byte_granularity);
-
-
-	/* Get proper index into buffer (handles big/little endian) */
-
-	index = ACPI_BUFFER_INDEX (buffer_length, buffer_offset, byte_granularity);
-
-	/* Move the requested number of bytes */
-
-	switch (byte_granularity) {
-	case ACPI_FIELD_BYTE_GRANULARITY:
-
-		*datum = ((u8 *) buffer) [index];
-		break;
-
-	case ACPI_FIELD_WORD_GRANULARITY:
-
-		ACPI_MOVE_16_TO_64 (datum, &(((u16 *) buffer) [index]));
-		break;
-
-	case ACPI_FIELD_DWORD_GRANULARITY:
-
-		ACPI_MOVE_32_TO_64 (datum, &(((u32 *) buffer) [index]));
-		break;
-
-	case ACPI_FIELD_QWORD_GRANULARITY:
-
-		ACPI_MOVE_64_TO_64 (datum, &(((u64 *) buffer) [index]));
-		break;
-
-	default:
-		/* Should not get here */
-		break;
-	}
-
-	return_VOID;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ex_set_buffer_datum
- *
- * PARAMETERS:  merged_datum        - Value to store
- *              Buffer              - Receiving buffer
- *              buffer_length       - Entire length (used for big-endian only)
- *              byte_granularity    - 1/2/4/8 Granularity of the field
- *                                    (aka Datum Size)
- *              buffer_offset       - Datum offset into the buffer
- *
- * RETURN:      none
- *
- * DESCRIPTION: Store the merged datum to the buffer according to the
- *              byte granularity
- *
- ******************************************************************************/
-
-void
-acpi_ex_set_buffer_datum (
-	acpi_integer                    merged_datum,
-	void                            *buffer,
-	u32                             buffer_length,
-	u32                             byte_granularity,
-	u32                             buffer_offset)
-{
-	u32                             index;
-
-
-	ACPI_FUNCTION_TRACE_U32 ("ex_set_buffer_datum", byte_granularity);
-
-
-	/* Get proper index into buffer (handles big/little endian) */
-
-	index = ACPI_BUFFER_INDEX (buffer_length, buffer_offset, byte_granularity);
-
-	/* Move the requested number of bytes */
-
-	switch (byte_granularity) {
-	case ACPI_FIELD_BYTE_GRANULARITY:
-
-		((u8 *) buffer) [index] = (u8) merged_datum;
-		break;
-
-	case ACPI_FIELD_WORD_GRANULARITY:
-
-		ACPI_MOVE_64_TO_16 (&(((u16 *) buffer)[index]), &merged_datum);
-		break;
-
-	case ACPI_FIELD_DWORD_GRANULARITY:
-
-		ACPI_MOVE_64_TO_32 (&(((u32 *) buffer)[index]), &merged_datum);
-		break;
-
-	case ACPI_FIELD_QWORD_GRANULARITY:
-
-		ACPI_MOVE_64_TO_64 (&(((u64 *) buffer)[index]), &merged_datum);
-		break;
-
-	default:
-		/* Should not get here */
-		break;
-	}
-
-	return_VOID;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ex_common_buffer_setup
- *
- * PARAMETERS:  obj_desc            - Field object
- *              buffer_length       - Length of caller's buffer
- *              datum_count         - Where the datum_count is returned
- *
- * RETURN:      Status, datum_count
- *
- * DESCRIPTION: Common code to validate the incoming buffer size and compute
- *              the number of field "datums" that must be read or written.
- *              A "datum" is the smallest unit that can be read or written
- *              to the field, it is either 1,2,4, or 8 bytes.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ex_common_buffer_setup (
-	union acpi_operand_object       *obj_desc,
-	u32                             buffer_length,
-	u32                             *datum_count)
-{
-	u32                             byte_field_length;
-	u32                             actual_byte_field_length;
-
-
-	ACPI_FUNCTION_TRACE ("ex_common_buffer_setup");
-
-
-	/*
-	 * Incoming buffer must be at least as long as the field, we do not
-	 * allow "partial" field reads/writes.  We do not care if the buffer is
-	 * larger than the field, this typically happens when an integer is
-	 * read/written to a field that is actually smaller than an integer.
-	 */
-	byte_field_length = ACPI_ROUND_BITS_UP_TO_BYTES (
-			 obj_desc->common_field.bit_length);
-	if (byte_field_length > buffer_length) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-			"Field size %X (bytes) is too large for buffer (%X)\n",
-			byte_field_length, buffer_length));
-
-		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
-	}
-
-	/*
-	 * Create "actual" field byte count (minimum number of bytes that
-	 * must be read), then convert to datum count (minimum number
-	 * of datum-sized units that must be read)
-	 */
-	actual_byte_field_length = ACPI_ROUND_BITS_UP_TO_BYTES (
-			  obj_desc->common_field.start_field_bit_offset +
-			  obj_desc->common_field.bit_length);
-
-
-	*datum_count = ACPI_ROUND_UP_TO (actual_byte_field_length,
-			   obj_desc->common_field.access_byte_width);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-		"buffer_bytes %X, actual_bytes %X, Datums %X, byte_gran %X\n",
-		byte_field_length, actual_byte_field_length,
-		*datum_count, obj_desc->common_field.access_byte_width));
-
-	return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ex_extract_from_field
  *
  * PARAMETERS:  obj_desc            - Field to be read
@@ -835,128 +631,92 @@
 	u32                             buffer_length)
 {
 	acpi_status                     status;
-	u32                             field_datum_byte_offset;
-	u32                             buffer_datum_offset;
-	acpi_integer                    previous_raw_datum = 0;
-	acpi_integer                    this_raw_datum = 0;
-	acpi_integer                    merged_datum = 0;
+	acpi_integer                    raw_datum;
+	acpi_integer                    merged_datum;
+	u32                             field_offset = 0;
+	u32                             buffer_offset = 0;
+	u32                             buffer_tail_bits;
 	u32                             datum_count;
+	u32                             field_datum_count;
 	u32                             i;
 
 
 	ACPI_FUNCTION_TRACE ("ex_extract_from_field");
 
 
-	/* Validate buffer, compute number of datums */
+	/* Validate target buffer and clear it */
 
-	status = acpi_ex_common_buffer_setup (obj_desc, buffer_length, &datum_count);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+	if (buffer_length < ACPI_ROUND_BITS_UP_TO_BYTES (
+			 obj_desc->common_field.bit_length)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Field size %X (bits) is too large for buffer (%X)\n",
+			obj_desc->common_field.bit_length, buffer_length));
 
-	/*
-	 * Clear the caller's buffer (the whole buffer length as given)
-	 * This is very important, especially in the cases where the buffer
-	 * is longer than the size of the field.
-	 */
+		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
+	}
 	ACPI_MEMSET (buffer, 0, buffer_length);
 
-	field_datum_byte_offset = 0;
-	buffer_datum_offset= 0;
-
-	/* Read the entire field */
+	/* Compute the number of datums (access width data items) */
 
-	for (i = 0; i < datum_count; i++) {
-		status = acpi_ex_field_datum_io (obj_desc, field_datum_byte_offset,
-				  &this_raw_datum, ACPI_READ);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
+	datum_count = ACPI_ROUND_UP_TO (
+			   obj_desc->common_field.bit_length,
+			   obj_desc->common_field.access_bit_width);
+	field_datum_count = ACPI_ROUND_UP_TO (
+			   obj_desc->common_field.bit_length +
+			   obj_desc->common_field.start_field_bit_offset,
+			   obj_desc->common_field.access_bit_width);
 
-		/* We might actually be done if the request fits in one datum */
+	/* Priming read from the field */
 
-		if ((datum_count == 1) &&
-			(obj_desc->common_field.flags & AOPOBJ_SINGLE_DATUM)) {
-			/* 1) Shift the valid data bits down to start at bit 0 */
+	status = acpi_ex_field_datum_io (obj_desc, field_offset, &raw_datum, ACPI_READ);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+	merged_datum = raw_datum >> obj_desc->common_field.start_field_bit_offset;
 
-			merged_datum = (this_raw_datum >> obj_desc->common_field.start_field_bit_offset);
+	/* Read the rest of the field */
 
-			/* 2) Mask off any upper unused bits (bits not part of the field) */
+	for (i = 1; i < field_datum_count; i++) {
+		/* Get next input datum from the field */
 
-			if (obj_desc->common_field.end_buffer_valid_bits) {
-				merged_datum &= ACPI_MASK_BITS_ABOVE (obj_desc->common_field.end_buffer_valid_bits);
-			}
+		field_offset += obj_desc->common_field.access_byte_width;
+		status = acpi_ex_field_datum_io (obj_desc, field_offset,
+				  &raw_datum, ACPI_READ);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 
-			/* Store the datum to the caller buffer */
+		/* Merge with previous datum if necessary */
 
-			acpi_ex_set_buffer_datum (merged_datum, buffer, buffer_length,
-					obj_desc->common_field.access_byte_width, buffer_datum_offset);
+		merged_datum |= raw_datum <<
+			(obj_desc->common_field.access_bit_width - obj_desc->common_field.start_field_bit_offset);
 
-			return_ACPI_STATUS (AE_OK);
+		if (i == datum_count) {
+			break;
 		}
 
-		/* Special handling for the last datum to ignore extra bits */
+		/* Write merged datum to target buffer */
 
-		if ((i >= (datum_count -1))          &&
-			(obj_desc->common_field.end_field_valid_bits)) {
-			/*
-			 * This is the last iteration of the loop.  We need to clear
-			 * any unused bits (bits that are not part of this field) before
-			 * we store the final merged datum into the caller buffer.
-			 */
-			this_raw_datum &=
-				ACPI_MASK_BITS_ABOVE (obj_desc->common_field.end_field_valid_bits);
-		}
+		ACPI_MEMCPY (((char *) buffer) + buffer_offset, &merged_datum,
+			ACPI_MIN(obj_desc->common_field.access_byte_width,
+					 buffer_length - buffer_offset));
 
-		/*
-		 * Create the (possibly) merged datum to be stored to the caller buffer
-		 */
-		if (obj_desc->common_field.start_field_bit_offset == 0) {
-			/* Field is not skewed and we can just copy the datum */
-
-			acpi_ex_set_buffer_datum (this_raw_datum, buffer, buffer_length,
-					obj_desc->common_field.access_byte_width, buffer_datum_offset);
-			buffer_datum_offset++;
-		}
-		else {
-			/* Not aligned -- on the first iteration, just save the datum */
+		buffer_offset += obj_desc->common_field.access_byte_width;
+		merged_datum = raw_datum >> obj_desc->common_field.start_field_bit_offset;
+	}
 
-			if (i != 0) {
-				/*
-				 * Put together the appropriate bits of the two raw data to make a
-				 * single complete field datum
-				 *
-				 * 1) Normalize the first datum down to bit 0
-				 */
-				merged_datum = (previous_raw_datum >> obj_desc->common_field.start_field_bit_offset);
-
-				/* 2) Insert the second datum "above" the first datum */
-
-				merged_datum |= (this_raw_datum << obj_desc->common_field.datum_valid_bits);
-
-				acpi_ex_set_buffer_datum (merged_datum, buffer, buffer_length,
-						obj_desc->common_field.access_byte_width, buffer_datum_offset);
-				buffer_datum_offset++;
-			}
-
-			/*
-			 * Save the raw datum that was just acquired since it may contain bits
-			 * of the *next* field datum
-			 */
-			previous_raw_datum = this_raw_datum;
-		}
+	/* Mask off any extra bits in the last datum */
 
-		field_datum_byte_offset += obj_desc->common_field.access_byte_width;
+	buffer_tail_bits = obj_desc->common_field.bit_length % obj_desc->common_field.access_bit_width;
+	if (buffer_tail_bits) {
+		merged_datum &= ACPI_MASK_BITS_ABOVE (buffer_tail_bits);
 	}
 
-	/* For non-aligned case, there is one last datum to insert */
-
-	if (obj_desc->common_field.start_field_bit_offset != 0) {
-		merged_datum = (this_raw_datum >> obj_desc->common_field.start_field_bit_offset);
+	/* Write the last datum to the buffer */
 
-		acpi_ex_set_buffer_datum (merged_datum, buffer, buffer_length,
-				obj_desc->common_field.access_byte_width, buffer_datum_offset);
-	}
+	ACPI_MEMCPY (((char *) buffer) + buffer_offset, &merged_datum,
+		ACPI_MIN(obj_desc->common_field.access_byte_width,
+				 buffer_length - buffer_offset));
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -983,169 +743,91 @@
 	u32                             buffer_length)
 {
 	acpi_status                     status;
-	u32                             field_datum_byte_offset;
-	u32                             datum_offset;
 	acpi_integer                    mask;
 	acpi_integer                    merged_datum;
-	acpi_integer                    previous_raw_datum;
-	acpi_integer                    this_raw_datum;
+	acpi_integer                    raw_datum = 0;
+	u32                             field_offset = 0;
+	u32                             buffer_offset = 0;
+	u32                             buffer_tail_bits;
 	u32                             datum_count;
+	u32                             field_datum_count;
+	u32                             i;
 
 
 	ACPI_FUNCTION_TRACE ("ex_insert_into_field");
 
 
-	/* Validate buffer, compute number of datums */
+	/* Validate input buffer */
 
-	status = acpi_ex_common_buffer_setup (obj_desc, buffer_length, &datum_count);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+	if (buffer_length < ACPI_ROUND_BITS_UP_TO_BYTES (
+			 obj_desc->common_field.bit_length)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Field size %X (bits) is too large for buffer (%X)\n",
+			obj_desc->common_field.bit_length, buffer_length));
+
+		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
 	}
 
-	/*
-	 * Break the request into up to three parts (similar to an I/O request):
-	 * 1) non-aligned part at start
-	 * 2) aligned part in middle
-	 * 3) non-aligned part at the end
-	 */
-	field_datum_byte_offset = 0;
-	datum_offset= 0;
-
-	/* Get a single datum from the caller's buffer */
-
-	acpi_ex_get_buffer_datum (&previous_raw_datum, buffer, buffer_length,
-			obj_desc->common_field.access_byte_width, datum_offset);
-
-	/*
-	 * Part1:
-	 * Write a partial field datum if field does not begin on a datum boundary
-	 * Note: The code in this section also handles the aligned case
-	 *
-	 * Construct Mask with 1 bits where the field is, 0 bits elsewhere
-	 * (Only the bottom 5 bits of bit_length are valid for a shift operation)
-	 *
-	 * Mask off bits that are "below" the field (if any)
-	 */
+	/* Compute the number of datums (access width data items) */
+
 	mask = ACPI_MASK_BITS_BELOW (obj_desc->common_field.start_field_bit_offset);
+	datum_count = ACPI_ROUND_UP_TO (obj_desc->common_field.bit_length,
+			  obj_desc->common_field.access_bit_width);
+	field_datum_count = ACPI_ROUND_UP_TO (obj_desc->common_field.bit_length +
+			   obj_desc->common_field.start_field_bit_offset,
+			   obj_desc->common_field.access_bit_width);
 
-	/* If the field fits in one datum, may need to mask upper bits */
+	/* Get initial Datum from the input buffer */
 
-	if ((obj_desc->common_field.flags & AOPOBJ_SINGLE_DATUM) &&
-		 obj_desc->common_field.end_field_valid_bits) {
-		/* There are bits above the field, mask them off also */
+	ACPI_MEMCPY (&raw_datum, buffer,
+		ACPI_MIN(obj_desc->common_field.access_byte_width,
+				 buffer_length - buffer_offset));
 
-		mask &= ACPI_MASK_BITS_ABOVE (obj_desc->common_field.end_field_valid_bits);
-	}
+	merged_datum = raw_datum << obj_desc->common_field.start_field_bit_offset;
 
-	/* Shift and mask the value into the field position */
+	/* Write the entire field */
 
-	merged_datum = (previous_raw_datum << obj_desc->common_field.start_field_bit_offset);
-	merged_datum &= mask;
+	for (i = 1; i < field_datum_count; i++) {
+		/* Write merged datum to the target field */
 
-	/* Apply the update rule (if necessary) and write the datum to the field */
+		merged_datum &= mask;
+		status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum, field_offset);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 
-	status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum,
-			   field_datum_byte_offset);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+		/* Start new output datum by merging with previous input datum */
 
-	/* We just wrote the first datum */
+		field_offset += obj_desc->common_field.access_byte_width;
+		merged_datum = raw_datum >>
+			(obj_desc->common_field.access_bit_width - obj_desc->common_field.start_field_bit_offset);
+		mask = ACPI_INTEGER_MAX;
 
-	datum_offset++;
+		if (i == datum_count) {
+			break;
+		}
 
-	/* If the entire field fits within one datum, we are done. */
+		/* Get the next input datum from the buffer */
 
-	if ((datum_count == 1) &&
-	   (obj_desc->common_field.flags & AOPOBJ_SINGLE_DATUM)) {
-		return_ACPI_STATUS (AE_OK);
+		buffer_offset += obj_desc->common_field.access_byte_width;
+		ACPI_MEMCPY (&raw_datum, ((char *) buffer) + buffer_offset,
+			ACPI_MIN(obj_desc->common_field.access_byte_width,
+					 buffer_length - buffer_offset));
+		merged_datum |= raw_datum << obj_desc->common_field.start_field_bit_offset;
 	}
 
-	/*
-	 * Part2:
-	 * Write the aligned data.
-	 *
-	 * We don't need to worry about the update rule for these data, because
-	 * all of the bits in each datum are part of the field.
-	 *
-	 * The last datum must be special cased because it might contain bits
-	 * that are not part of the field -- therefore the "update rule" must be
-	 * applied in Part3 below.
-	 */
-	while (datum_offset < datum_count) {
-		field_datum_byte_offset += obj_desc->common_field.access_byte_width;
-
-		/*
-		 * Get the next raw buffer datum.  It may contain bits of the previous
-		 * field datum
-		 */
-		acpi_ex_get_buffer_datum (&this_raw_datum, buffer, buffer_length,
-				obj_desc->common_field.access_byte_width, datum_offset);
-
-		/* Create the field datum based on the field alignment */
-
-		if (obj_desc->common_field.start_field_bit_offset != 0) {
-			/*
-			 * Put together appropriate bits of the two raw buffer data to make
-			 * a single complete field datum
-			 */
-			merged_datum =
-				(previous_raw_datum >> obj_desc->common_field.datum_valid_bits) |
-				(this_raw_datum << obj_desc->common_field.start_field_bit_offset);
-		}
-		else {
-			/* Field began aligned on datum boundary */
-
-			merged_datum = this_raw_datum;
-		}
+	/* Mask off any extra bits in the last datum */
 
-		/*
-		 * Special handling for the last datum if the field does NOT end on
-		 * a datum boundary.  Update Rule must be applied to the bits outside
-		 * the field.
-		 */
-		datum_offset++;
-		if ((datum_offset == datum_count) &&
-			(obj_desc->common_field.end_field_valid_bits)) {
-			/*
-			 * If there are dangling non-aligned bits, perform one more merged write
-			 * Else - field is aligned at the end, no need for any more writes
-			 */
-
-			/*
-			 * Part3:
-			 * This is the last datum and the field does not end on a datum boundary.
-			 * Build the partial datum and write with the update rule.
-			 *
-			 * Mask off the unused bits above (after) the end-of-field
-			 */
-			mask = ACPI_MASK_BITS_ABOVE (obj_desc->common_field.end_field_valid_bits);
-			merged_datum &= mask;
-
-			/* Write the last datum with the update rule */
-
-			status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum,
-					   field_datum_byte_offset);
-			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
-			}
-		}
-		else {
-			/* Normal (aligned) case -- write the completed datum */
+	buffer_tail_bits = (obj_desc->common_field.bit_length +
+			obj_desc->common_field.start_field_bit_offset) % obj_desc->common_field.access_bit_width;
+	if (buffer_tail_bits) {
+		mask &= ACPI_MASK_BITS_ABOVE (buffer_tail_bits);
+	}
 
-			status = acpi_ex_field_datum_io (obj_desc, field_datum_byte_offset,
-					  &merged_datum, ACPI_WRITE);
-			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
-			}
-		}
+	/* Write the last datum to the field */
 
-		/*
-		 * Save the most recent datum since it may contain bits of the *next*
-		 * field datum.  Update current byte offset.
-		 */
-		previous_raw_datum = this_raw_datum;
-	}
+	merged_datum &= mask;
+	status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum, field_offset);
 
 	return_ACPI_STATUS (status);
 }
diff -Nru a/drivers/acpi/executer/exmisc.c b/drivers/acpi/executer/exmisc.c
--- a/drivers/acpi/executer/exmisc.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exmisc.c	2005-01-06 15:06:41 -05:00
@@ -389,7 +389,7 @@
 	if (local_operand1 != operand1) {
 		acpi_ut_remove_reference (local_operand1);
 	}
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS (status);
 }
 
 
diff -Nru a/drivers/acpi/executer/exoparg1.c b/drivers/acpi/executer/exoparg1.c
--- a/drivers/acpi/executer/exoparg1.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exoparg1.c	2005-01-06 15:06:41 -05:00
@@ -507,6 +507,10 @@
 
 		status = acpi_ex_convert_to_string (operand[0], &return_desc,
 				 ACPI_EXPLICIT_CONVERT_DECIMAL);
+		if (return_desc == operand[0]) {
+			/* No conversion performed, add ref to handle return value */
+			acpi_ut_add_reference (return_desc);
+		}
 		break;
 
 
@@ -514,12 +518,20 @@
 
 		status = acpi_ex_convert_to_string (operand[0], &return_desc,
 				 ACPI_EXPLICIT_CONVERT_HEX);
+		if (return_desc == operand[0]) {
+			/* No conversion performed, add ref to handle return value */
+			acpi_ut_add_reference (return_desc);
+		}
 		break;
 
 
 	case AML_TO_BUFFER_OP:          /* to_buffer (Data, Result) */
 
 		status = acpi_ex_convert_to_buffer (operand[0], &return_desc);
+		if (return_desc == operand[0]) {
+			/* No conversion performed, add ref to handle return value */
+			acpi_ut_add_reference (return_desc);
+		}
 		break;
 
 
@@ -527,6 +539,10 @@
 
 		status = acpi_ex_convert_to_integer (operand[0], &return_desc,
 				 ACPI_ANY_BASE);
+		if (return_desc == operand[0]) {
+			/* No conversion performed, add ref to handle return value */
+			acpi_ut_add_reference (return_desc);
+		}
 		break;
 
 
@@ -551,10 +567,12 @@
 		goto cleanup;
 	}
 
-	/*
-	 * Store the return value computed above into the target object
-	 */
-	status = acpi_ex_store (return_desc, operand[1], walk_state);
+	if (ACPI_SUCCESS (status)) {
+		/*
+		 * Store the return value computed above into the target object
+		 */
+		status = acpi_ex_store (return_desc, operand[1], walk_state);
+	}
 
 
 cleanup:
diff -Nru a/drivers/acpi/executer/exoparg2.c b/drivers/acpi/executer/exoparg2.c
--- a/drivers/acpi/executer/exoparg2.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exoparg2.c	2005-01-06 15:06:41 -05:00
@@ -410,7 +410,7 @@
 		index = (u32) operand[1]->integer.value;
 
 		/*
-		 * At this point, the Source operand is either a Package or a Buffer
+		 * At this point, the Source operand is a Package, Buffer, or String
 		 */
 		if (ACPI_GET_OBJECT_TYPE (operand[0]) == ACPI_TYPE_PACKAGE) {
 			/* Object to be indexed is a Package */
@@ -428,7 +428,7 @@
 			return_desc->reference.where     = &operand[0]->package.elements [index];
 		}
 		else {
-			/* Object to be indexed is a Buffer */
+			/* Object to be indexed is a Buffer/String */
 
 			if (index >= operand[0]->buffer.length) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
diff -Nru a/drivers/acpi/executer/exprep.c b/drivers/acpi/executer/exprep.c
--- a/drivers/acpi/executer/exprep.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exprep.c	2005-01-06 15:06:41 -05:00
@@ -339,6 +339,8 @@
 	obj_desc->common_field.access_byte_width = (u8)
 			ACPI_DIV_8 (access_bit_width); /* 1, 2, 4,  8 */
 
+	obj_desc->common_field.access_bit_width = (u8) access_bit_width;
+
 	/*
 	 * base_byte_offset is the address of the start of the field within the
 	 * region.  It is the byte address of the first *datum* (field-width data
@@ -360,28 +362,6 @@
 	 */
 	obj_desc->common_field.start_field_bit_offset = (u8)
 		(field_bit_position - ACPI_MUL_8 (obj_desc->common_field.base_byte_offset));
-
-	/*
-	 * Valid bits -- the number of bits that compose a partial datum,
-	 * 1) At the end of the field within the region (arbitrary starting bit
-	 *    offset)
-	 * 2) At the end of a buffer used to contain the field (starting offset
-	 *    always zero)
-	 */
-	obj_desc->common_field.end_field_valid_bits = (u8)
-		((obj_desc->common_field.start_field_bit_offset + field_bit_length) %
-				  access_bit_width);
-	/* start_buffer_bit_offset always = 0 */
-
-	obj_desc->common_field.end_buffer_valid_bits = (u8)
-		(field_bit_length % access_bit_width);
-
-	/*
-	 * datum_valid_bits is the number of valid field bits in the first
-	 * field datum.
-	 */
-	obj_desc->common_field.datum_valid_bits  = (u8)
-		(access_bit_width - obj_desc->common_field.start_field_bit_offset);
 
 	/*
 	 * Does the entire field fit within a single field access element? (datum)
diff -Nru a/drivers/acpi/executer/exstore.c b/drivers/acpi/executer/exstore.c
--- a/drivers/acpi/executer/exstore.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exstore.c	2005-01-06 15:06:41 -05:00
@@ -295,56 +295,45 @@
 	switch (index_desc->reference.target_type) {
 	case ACPI_TYPE_PACKAGE:
 		/*
-		 * Storing to a package element is not simple.  The source must be
-		 * evaluated and converted to the type of the destination and then the
-		 * source is copied into the destination - we can't just point to the
-		 * source object.
-		 */
-		/*
+		 * Storing to a package element. Copy the object and replace
+		 * any existing object with the new object. No implicit
+		 * conversion is performed.
+		 *
 		 * The object at *(index_desc->Reference.Where) is the
 		 * element within the package that is to be modified.
 		 * The parent package object is at index_desc->Reference.Object
 		 */
 		obj_desc = *(index_desc->reference.where);
 
-		/* Do the conversion/store */
-
-		status = acpi_ex_store_object_to_object (source_desc, obj_desc, &new_desc,
-				  walk_state);
+		status = acpi_ut_copy_iobject_to_iobject (source_desc, &new_desc, walk_state);
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Could not store object to indexed package element\n"));
 			return_ACPI_STATUS (status);
 		}
 
-		/*
-		 * If a new object was created, we must install it as the new
-		 * package element
-		 */
-		if (new_desc != obj_desc) {
-			acpi_ut_remove_reference (obj_desc);
-			*(index_desc->reference.where) = new_desc;
-
-			/* If same as the original source, add a reference */
+		if (obj_desc) {
+			/* Decrement reference count by the ref count of the parent package */
 
-			if (new_desc == source_desc) {
-				acpi_ut_add_reference (new_desc);
+			for (i = 0; i < ((union acpi_operand_object *) index_desc->reference.object)->common.reference_count; i++) {
+				acpi_ut_remove_reference (obj_desc);
 			}
+		}
 
-			/* Increment reference count by the ref count of the parent package -1 */
+		*(index_desc->reference.where) = new_desc;
 
-			for (i = 1; i < ((union acpi_operand_object *) index_desc->reference.object)->common.reference_count; i++) {
-				acpi_ut_add_reference (new_desc);
-			}
+		/* Increment reference count by the ref count of the parent package -1 */
+
+		for (i = 1; i < ((union acpi_operand_object *) index_desc->reference.object)->common.reference_count; i++) {
+			acpi_ut_add_reference (new_desc);
 		}
+
 		break;
 
 
 	case ACPI_TYPE_BUFFER_FIELD:
 
 		/*
-		 * Store into a Buffer (not actually a real buffer_field) at a
-		 * location defined by an Index.
+		 * Store into a Buffer or String (not actually a real buffer_field)
+		 * at a location defined by an Index.
 		 *
 		 * The first 8-bit element of the source object is written to the
 		 * 8-bit Buffer location defined by the Index destination object,
@@ -352,10 +341,13 @@
 		 */
 
 		/*
-		 * Make sure the target is a Buffer
+		 * Make sure the target is a Buffer or String. An error should
+		 * not happen here, since the reference_object was constructed
+		 * by the INDEX_OP code.
 		 */
 		obj_desc = index_desc->reference.object;
-		if (ACPI_GET_OBJECT_TYPE (obj_desc) != ACPI_TYPE_BUFFER) {
+		if ((ACPI_GET_OBJECT_TYPE (obj_desc) != ACPI_TYPE_BUFFER) &&
+			(ACPI_GET_OBJECT_TYPE (obj_desc) != ACPI_TYPE_STRING)) {
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
@@ -372,13 +364,11 @@
 			break;
 
 		case ACPI_TYPE_BUFFER:
-
-			value = source_desc->buffer.pointer[0];
-			break;
-
 		case ACPI_TYPE_STRING:
 
-			value = (u8) source_desc->string.pointer[0];
+			/* Note: Takes advantage of common string/buffer fields */
+
+			value = source_desc->buffer.pointer[0];
 			break;
 
 		default:
diff -Nru a/drivers/acpi/executer/exstorob.c b/drivers/acpi/executer/exstorob.c
--- a/drivers/acpi/executer/exstorob.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/executer/exstorob.c	2005-01-06 15:06:41 -05:00
@@ -93,34 +93,35 @@
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		target_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;
 		target_desc->buffer.length = length;
 	}
 
-	/*
-	 * Buffer is a static allocation,
-	 * only place what will fit in the buffer.
-	 */
+	/* Copy source buffer to target buffer */
+
 	if (length <= target_desc->buffer.length) {
 		/* Clear existing buffer and copy in the new one */
 
 		ACPI_MEMSET (target_desc->buffer.pointer, 0, target_desc->buffer.length);
 		ACPI_MEMCPY (target_desc->buffer.pointer, buffer, length);
+
+		/* Set the new length of the target */
+
+		target_desc->buffer.length = length;
 	}
 	else {
-		/*
-		 * Truncate the source, copy only what will fit
-		 */
+		/* Truncate the source, copy only what will fit */
+
 		ACPI_MEMCPY (target_desc->buffer.pointer, buffer, target_desc->buffer.length);
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"Truncating src buffer from %X to %X\n",
+			"Truncating source buffer from %X to %X\n",
 			length, target_desc->buffer.length));
 	}
 
 	/* Copy flags */
 
 	target_desc->buffer.flags = source_desc->buffer.flags;
+	target_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -Nru a/drivers/acpi/hardware/hwsleep.c b/drivers/acpi/hardware/hwsleep.c
--- a/drivers/acpi/hardware/hwsleep.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/hardware/hwsleep.c	2005-01-06 15:06:41 -05:00
@@ -282,15 +282,6 @@
 		return_ACPI_STATUS (status);
 	}
 
-	if (sleep_state != ACPI_STATE_S5) {
-		/* Disable BM arbitration */
-
-		status = acpi_set_register (ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
-	}
-
 	/*
 	 * 1) Disable/Clear all GPEs
 	 * 2) Enable all wakeup GPEs
@@ -580,13 +571,6 @@
 			1, ACPI_MTX_DO_NOT_LOCK);
 	(void) acpi_set_register(acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].status_register_id,
 			1, ACPI_MTX_DO_NOT_LOCK);
-
-	/* Enable BM arbitration */
-
-	status = acpi_set_register (ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_LOCK);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
 
 	arg.integer.value = ACPI_SST_WORKING;
 	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
diff -Nru a/drivers/acpi/numa.c b/drivers/acpi/numa.c
--- a/drivers/acpi/numa.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/numa.c	2005-01-06 15:06:41 -05:00
@@ -22,7 +22,7 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  */
-
+#include <linux/module.h>
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -199,3 +199,22 @@
 	acpi_numa_arch_fixup();
 	return 0;
 }
+
+int
+acpi_get_pxm(acpi_handle h)
+{
+	unsigned long pxm;
+	acpi_status status;
+	acpi_handle handle;
+	acpi_handle phandle = h;
+
+	do {
+		handle = phandle;
+		status = acpi_evaluate_integer(handle, "_PXM", NULL, &pxm);
+		if (ACPI_SUCCESS(status))
+			return (int)pxm;
+		status = acpi_get_parent(handle, &phandle);
+	} while(ACPI_SUCCESS(status));
+	return -1;
+}
+EXPORT_SYMBOL(acpi_get_pxm);
diff -Nru a/drivers/acpi/osl.c b/drivers/acpi/osl.c
--- a/drivers/acpi/osl.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/osl.c	2005-01-06 15:06:41 -05:00
@@ -40,6 +40,7 @@
 #include <acpi/acpi.h>
 #include <asm/io.h>
 #include <acpi/acpi_bus.h>
+#include <acpi/processor.h>
 #include <asm/uaccess.h>
 
 #include <linux/efi.h>
@@ -356,7 +357,7 @@
 	if (!t)
 		printk(KERN_ERR PREFIX "acpi_os_get_timer() TBD\n");
 
-	return(++t);
+	return ++t;
 }
 
 acpi_status
@@ -635,7 +636,7 @@
 	acpi_integer		value,
 	u32			width)
 {
-	return (AE_SUPPORT);
+	return AE_SUPPORT;
 }
 
 acpi_status
@@ -645,7 +646,7 @@
 	void			*value,
 	u32			width)
 {
-	return (AE_SUPPORT);
+	return AE_SUPPORT;
 }
 
 void
@@ -1155,7 +1156,7 @@
  * max_cstate is defined in the base kernel so modules can
  * change it w/o depending on the state of the processor module.
  */
-unsigned int max_cstate = ACPI_C_STATES_MAX;
+unsigned int max_cstate = ACPI_PROCESSOR_MAX_POWER;
 
 
 EXPORT_SYMBOL(max_cstate);
diff -Nru a/drivers/acpi/parser/psopcode.c b/drivers/acpi/parser/psopcode.c
--- a/drivers/acpi/parser/psopcode.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/parser/psopcode.c	2005-01-06 15:06:41 -05:00
@@ -318,7 +318,7 @@
 #define ARGI_SHIFT_LEFT_OP              ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
 #define ARGI_SHIFT_RIGHT_OP             ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
 #define ARGI_SIGNAL_OP                  ARGI_LIST1 (ARGI_EVENT)
-#define ARGI_SIZE_OF_OP                 ARGI_LIST1 (ARGI_REFERENCE) /* Force delay of operand resolution */
+#define ARGI_SIZE_OF_OP                 ARGI_LIST1 (ARGI_DATAOBJECT)
 #define ARGI_SLEEP_OP                   ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_STALL_OP                   ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_STATICSTRING_OP            ARGI_INVALID_OPCODE
@@ -333,7 +333,7 @@
 #define ARGI_TO_HEX_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
 #define ARGI_TO_INTEGER_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
 #define ARGI_TO_STRING_OP               ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_FIXED_TARGET)
-#define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_REFERENCE) /* Force delay of operand resolution */
+#define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_ANYTYPE)
 #define ARGI_UNLOAD_OP                  ARGI_LIST1 (ARGI_DDBHANDLE)
 #define ARGI_VAR_PACKAGE_OP             ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_WAIT_OP                    ARGI_LIST2 (ARGI_EVENT,      ARGI_INTEGER)
@@ -521,14 +521,14 @@
 /* 2D */ ACPI_OP ("FindSetRightBit",    ARGP_FIND_SET_RIGHT_BIT_OP,ARGI_FIND_SET_RIGHT_BIT_OP, ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
 /* 2E */ ACPI_OP ("DerefOf",            ARGP_DEREF_OF_OP,          ARGI_DEREF_OF_OP,           ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
 /* 2F */ ACPI_OP ("Notify",             ARGP_NOTIFY_OP,            ARGI_NOTIFY_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_0R,   AML_FLAGS_EXEC_2A_0T_0R),
-/* 30 */ ACPI_OP ("SizeOf",             ARGP_SIZE_OF_OP,           ARGI_SIZE_OF_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
+/* 30 */ ACPI_OP ("SizeOf",             ARGP_SIZE_OF_OP,           ARGI_SIZE_OF_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_NO_OPERAND_RESOLVE),
 /* 31 */ ACPI_OP ("Index",              ARGP_INDEX_OP,             ARGI_INDEX_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
 /* 32 */ ACPI_OP ("Match",              ARGP_MATCH_OP,             ARGI_MATCH_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_6A_0T_1R,   AML_FLAGS_EXEC_6A_0T_1R | AML_CONSTANT),
 /* 33 */ ACPI_OP ("CreateDWordField",   ARGP_CREATE_DWORD_FIELD_OP,ARGI_CREATE_DWORD_FIELD_OP, ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 34 */ ACPI_OP ("CreateWordField",    ARGP_CREATE_WORD_FIELD_OP, ARGI_CREATE_WORD_FIELD_OP,  ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 35 */ ACPI_OP ("CreateByteField",    ARGP_CREATE_BYTE_FIELD_OP, ARGI_CREATE_BYTE_FIELD_OP,  ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 36 */ ACPI_OP ("CreateBitField",     ARGP_CREATE_BIT_FIELD_OP,  ARGI_CREATE_BIT_FIELD_OP,   ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
-/* 37 */ ACPI_OP ("ObjectType",         ARGP_TYPE_OP,              ARGI_TYPE_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
+/* 37 */ ACPI_OP ("ObjectType",         ARGP_TYPE_OP,              ARGI_TYPE_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_NO_OPERAND_RESOLVE),
 /* 38 */ ACPI_OP ("LAnd",               ARGP_LAND_OP,              ARGI_LAND_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL_NUMERIC | AML_CONSTANT),
 /* 39 */ ACPI_OP ("LOr",                ARGP_LOR_OP,               ARGI_LOR_OP,                ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL_NUMERIC | AML_CONSTANT),
 /* 3A */ ACPI_OP ("LNot",               ARGP_LNOT_OP,              ARGI_LNOT_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
diff -Nru a/drivers/acpi/pci_bind.c b/drivers/acpi/pci_bind.c
--- a/drivers/acpi/pci_bind.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/pci_bind.c	2005-01-06 15:06:41 -05:00
@@ -126,8 +126,8 @@
 	acpi_status		status = AE_OK;
 	struct acpi_pci_data	*data = NULL;
 	struct acpi_pci_data	*pdata = NULL;
-	char			pathname[ACPI_PATHNAME_MAX] = {0};
-	struct acpi_buffer	buffer = {ACPI_PATHNAME_MAX, pathname};
+	char			*pathname = NULL;
+	struct acpi_buffer	buffer = {0, NULL};
 	acpi_handle		handle = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_bind");
@@ -135,9 +135,18 @@
 	if (!device || !device->parent)
 		return_VALUE(-EINVAL);
 
+	pathname = kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
+	if(!pathname)
+		return_VALUE(-ENOMEM);
+	memset(pathname, 0, ACPI_PATHNAME_MAX);
+	buffer.length = ACPI_PATHNAME_MAX;
+	buffer.pointer = pathname;
+
 	data = kmalloc(sizeof(struct acpi_pci_data), GFP_KERNEL);
-	if (!data)
+	if (!data){
+		kfree (pathname);
 		return_VALUE(-ENOMEM);
+	}
 	memset(data, 0, sizeof(struct acpi_pci_data));
 
 	acpi_get_name(device->handle, ACPI_FULL_PATHNAME, &buffer);
@@ -216,6 +225,7 @@
 			data->id.device, data->id.function));
 		data->bus = data->dev->subordinate;
 		device->ops.bind = acpi_pci_bind;
+		device->ops.unbind = acpi_pci_unbind;
 	}
 
 	/*
@@ -253,12 +263,56 @@
 	}
 
 end:
+	kfree(pathname);
 	if (result)
 		kfree(data);
 
 	return_VALUE(result);
 }
 
+int acpi_pci_unbind(
+	struct acpi_device      *device)
+{
+	int                     result = 0;
+	acpi_status             status = AE_OK;
+	struct acpi_pci_data    *data = NULL;
+	char                    pathname[ACPI_PATHNAME_MAX] = {0};
+	struct acpi_buffer      buffer = {ACPI_PATHNAME_MAX, pathname};
+
+	ACPI_FUNCTION_TRACE("acpi_pci_unbind");
+
+	if (!device || !device->parent)
+		return_VALUE(-EINVAL);
+
+	acpi_get_name(device->handle, ACPI_FULL_PATHNAME, &buffer);
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Unbinding PCI device [%s]...\n",
+		pathname));
+
+	status = acpi_get_data(device->handle, acpi_pci_data_handler, (void**)&data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to get data from device %s\n",
+			acpi_device_bid(device)));
+		result = -ENODEV;
+		goto end;
+	}
+
+	status = acpi_detach_data(device->handle, acpi_pci_data_handler);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to detach data from device %s\n",
+			acpi_device_bid(device)));
+		result = -ENODEV;
+		goto end;
+	}
+	if (data->dev->subordinate) {
+		acpi_pci_irq_del_prt(data->id.segment, data->bus->number);
+	}
+	kfree(data);
+
+end:
+	return_VALUE(result);
+}
 
 int 
 acpi_pci_bind_root (
@@ -269,22 +323,35 @@
 	int			result = 0;
 	acpi_status		status = AE_OK;
 	struct acpi_pci_data	*data = NULL;
-	char			pathname[ACPI_PATHNAME_MAX] = {0};
-	struct acpi_buffer	buffer = {ACPI_PATHNAME_MAX, pathname};
+	char			*pathname = NULL;
+	struct acpi_buffer	buffer = {0, NULL};
 
 	ACPI_FUNCTION_TRACE("acpi_pci_bind_root");
 
-	if (!device || !id || !bus)
+	pathname = (char *)kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
+	if(!pathname)
+		return_VALUE(-ENOMEM);
+	memset(pathname, 0, ACPI_PATHNAME_MAX);
+
+	buffer.length = ACPI_PATHNAME_MAX;
+	buffer.pointer = pathname;
+
+	if (!device || !id || !bus){
+		kfree(pathname);
 		return_VALUE(-EINVAL);
+	}
 
 	data = kmalloc(sizeof(struct acpi_pci_data), GFP_KERNEL);
-	if (!data)
+	if (!data){
+		kfree(pathname);
 		return_VALUE(-ENOMEM);
+	}
 	memset(data, 0, sizeof(struct acpi_pci_data));
 
 	data->id = *id;
 	data->bus = bus;
 	device->ops.bind = acpi_pci_bind;
+	device->ops.unbind = acpi_pci_unbind;
 
 	acpi_get_name(device->handle, ACPI_FULL_PATHNAME, &buffer);
 
@@ -301,6 +368,7 @@
 	}
 
 end:
+	kfree(pathname);
 	if (result != 0)
 		kfree(data);
 
diff -Nru a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
--- a/drivers/acpi/pci_irq.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/pci_irq.c	2005-01-06 15:06:41 -05:00
@@ -43,7 +43,7 @@
 ACPI_MODULE_NAME		("pci_irq")
 
 struct acpi_prt_list		acpi_prt;
-
+spinlock_t acpi_prt_lock = SPIN_LOCK_UNLOCKED;
 
 /* --------------------------------------------------------------------------
                          PCI IRQ Routing Table (PRT) Support
@@ -68,18 +68,20 @@
 	 * Parse through all PRT entries looking for a match on the specified
 	 * PCI device's segment, bus, device, and pin (don't care about func).
 	 *
-	 * TBD: Acquire/release lock
 	 */
+	spin_lock(&acpi_prt_lock);
 	list_for_each(node, &acpi_prt.entries) {
 		entry = list_entry(node, struct acpi_prt_entry, node);
 		if ((segment == entry->id.segment) 
 			&& (bus == entry->id.bus) 
 			&& (device == entry->id.device)
 			&& (pin == entry->pin)) {
+			spin_unlock(&acpi_prt_lock);
 			return_PTR(entry);
 		}
 	}
 
+	spin_unlock(&acpi_prt_lock);
 	return_PTR(NULL);
 }
 
@@ -141,14 +143,29 @@
 		entry->id.segment, entry->id.bus, entry->id.device, 
 		('A' + entry->pin), prt->source, entry->link.index));
 
-	/* TBD: Acquire/release lock */
+	spin_lock(&acpi_prt_lock);
 	list_add_tail(&entry->node, &acpi_prt.entries);
 	acpi_prt.count++;
+	spin_unlock(&acpi_prt_lock);
 
 	return_VALUE(0);
 }
 
 
+static void
+acpi_pci_irq_del_entry (
+	int				segment,
+	int				bus,
+	struct acpi_prt_entry		*entry)
+{
+	if (segment == entry->id.segment && bus == entry->id.bus){
+		acpi_prt.count--;
+		list_del(&entry->node);
+		kfree(entry);
+	}
+}
+
+
 int
 acpi_pci_irq_add_prt (
 	acpi_handle		handle,
@@ -156,7 +173,7 @@
 	int			bus)
 {
 	acpi_status			status = AE_OK;
-	char				pathname[ACPI_PATHNAME_MAX] = {0};
+	char				*pathname = NULL;
 	struct acpi_buffer		buffer = {0, NULL};
 	struct acpi_pci_routing_table	*prt = NULL;
 	struct acpi_pci_routing_table	*entry = NULL;
@@ -164,6 +181,11 @@
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_prt");
 
+	pathname = (char *) kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
+	if(!pathname)
+		return_VALUE(-ENOMEM);
+	memset(pathname, 0, ACPI_PATHNAME_MAX);
+
 	if (first_time) {
 		acpi_prt.count = 0;
 		INIT_LIST_HEAD(&acpi_prt.entries);
@@ -175,7 +197,7 @@
 	 *       (either a PCI root bridge or PCI-PCI bridge).
 	 */
 
-	buffer.length = sizeof(pathname);
+	buffer.length = ACPI_PATHNAME_MAX;
 	buffer.pointer = pathname;
 	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 
@@ -188,6 +210,7 @@
 
 	buffer.length = 0;
 	buffer.pointer = NULL;
+	kfree(pathname);
 	status = acpi_get_irq_routing_table(handle, &buffer);
 	if (status != AE_BUFFER_OVERFLOW) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
@@ -196,8 +219,9 @@
 	}
 
 	prt = kmalloc(buffer.length, GFP_KERNEL);
-	if (!prt)
+	if (!prt){
 		return_VALUE(-ENOMEM);
+	}
 	memset(prt, 0, buffer.length);
 	buffer.pointer = prt;
 
@@ -222,7 +246,26 @@
 	return_VALUE(0);
 }
 
+void
+acpi_pci_irq_del_prt (int segment, int bus)
+{
+	struct list_head        *node = NULL, *n = NULL;
+	struct acpi_prt_entry   *entry = NULL;
+
+	if (!acpi_prt.count)    {
+		return;
+	}
+
+	printk(KERN_DEBUG "ACPI: Delete PCI Interrupt Routing Table for %x:%x\n",
+		segment, bus);
+	spin_lock(&acpi_prt_lock);
+	list_for_each_safe(node, n, &acpi_prt.entries) {
+		entry = list_entry(node, struct acpi_prt_entry, node);
 
+		acpi_pci_irq_del_entry(segment, bus, entry);
+	}
+	spin_unlock(&acpi_prt_lock);
+}
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
@@ -345,6 +388,7 @@
 	u8			pin = 0;
 	int			edge_level = ACPI_LEVEL_SENSITIVE;
 	int			active_high_low = ACPI_ACTIVE_LOW;
+	extern int		via_interrupt_line_quirk;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_enable");
 
@@ -393,6 +437,9 @@
 			return_VALUE(0);
 		}
  	}
+
+	if (via_interrupt_line_quirk)
+		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq & 15);
 
 	dev->irq = acpi_register_gsi(irq, edge_level, active_high_low);
 
diff -Nru a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
--- a/drivers/acpi/pci_link.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/pci_link.c	2005-01-06 15:06:41 -05:00
@@ -307,50 +307,57 @@
 	struct {
 		struct acpi_resource	res;
 		struct acpi_resource	end;
-	}                       resource;
-	struct acpi_buffer	buffer = {sizeof(resource)+1, &resource};
+	}    *resource;
+	struct acpi_buffer	buffer = {0, NULL};
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_set");
 
 	if (!link || !irq)
 		return_VALUE(-EINVAL);
 
-	memset(&resource, 0, sizeof(resource));
+	resource = kmalloc( sizeof(*resource)+1, GFP_KERNEL);
+	if(!resource)
+		return_VALUE(-ENOMEM);
+
+	memset(resource, 0, sizeof(*resource)+1);
+	buffer.length = sizeof(*resource) +1;
+	buffer.pointer = resource;
 
 	switch(link->irq.resource_type) {
 	case ACPI_RSTYPE_IRQ:
-		resource.res.id = ACPI_RSTYPE_IRQ;
-		resource.res.length = sizeof(struct acpi_resource);
-		resource.res.data.irq.edge_level = link->irq.edge_level;
-		resource.res.data.irq.active_high_low = link->irq.active_high_low;
+		resource->res.id = ACPI_RSTYPE_IRQ;
+		resource->res.length = sizeof(struct acpi_resource);
+		resource->res.data.irq.edge_level = link->irq.edge_level;
+		resource->res.data.irq.active_high_low = link->irq.active_high_low;
 		if (link->irq.edge_level == ACPI_EDGE_SENSITIVE)
-			resource.res.data.irq.shared_exclusive = ACPI_EXCLUSIVE;
+			resource->res.data.irq.shared_exclusive = ACPI_EXCLUSIVE;
 		else
-			resource.res.data.irq.shared_exclusive = ACPI_SHARED;
-		resource.res.data.irq.number_of_interrupts = 1;
-		resource.res.data.irq.interrupts[0] = irq;
+			resource->res.data.irq.shared_exclusive = ACPI_SHARED;
+		resource->res.data.irq.number_of_interrupts = 1;
+		resource->res.data.irq.interrupts[0] = irq;
 		break;
 	   
 	case ACPI_RSTYPE_EXT_IRQ:
-		resource.res.id = ACPI_RSTYPE_EXT_IRQ;
-		resource.res.length = sizeof(struct acpi_resource);
-		resource.res.data.extended_irq.producer_consumer = ACPI_CONSUMER;
-		resource.res.data.extended_irq.edge_level = link->irq.edge_level;
-		resource.res.data.extended_irq.active_high_low = link->irq.active_high_low;
+		resource->res.id = ACPI_RSTYPE_EXT_IRQ;
+		resource->res.length = sizeof(struct acpi_resource);
+		resource->res.data.extended_irq.producer_consumer = ACPI_CONSUMER;
+		resource->res.data.extended_irq.edge_level = link->irq.edge_level;
+		resource->res.data.extended_irq.active_high_low = link->irq.active_high_low;
 		if (link->irq.edge_level == ACPI_EDGE_SENSITIVE)
-			resource.res.data.irq.shared_exclusive = ACPI_EXCLUSIVE;
+			resource->res.data.irq.shared_exclusive = ACPI_EXCLUSIVE;
 		else
-			resource.res.data.irq.shared_exclusive = ACPI_SHARED;
-		resource.res.data.extended_irq.number_of_interrupts = 1;
-		resource.res.data.extended_irq.interrupts[0] = irq;
+			resource->res.data.irq.shared_exclusive = ACPI_SHARED;
+		resource->res.data.extended_irq.number_of_interrupts = 1;
+		resource->res.data.extended_irq.interrupts[0] = irq;
 		/* ignore resource_source, it's optional */
 		break;
 	default:
 		printk("ACPI BUG: resource_type %d\n", link->irq.resource_type);
-		return_VALUE(-EINVAL);
+		result = -EINVAL;
+		goto end;
 
 	}
-	resource.end.id = ACPI_RSTYPE_END_TAG;
+	resource->end.id = ACPI_RSTYPE_END_TAG;
 
 	/* Attempt to set the resource */
 	status = acpi_set_current_resources(link->handle, &buffer);
@@ -358,14 +365,15 @@
 	/* check for total failure */
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SRS\n"));
-		return_VALUE(-ENODEV);
+		result = -ENODEV;
+		goto end;
 	}
 
 	/* Query _STA, set device->status */
 	result = acpi_bus_get_status(link->device);
 	if (result) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
-		return_VALUE(result);
+		goto end;
 	}
 	if (!link->device->status.enabled) {
 		printk(KERN_WARNING PREFIX
@@ -377,7 +385,7 @@
 	/* Query _CRS, set link->irq.active */
 	result = acpi_pci_link_get_current(link);
 	if (result) {
-		return_VALUE(result);
+		goto end;
 	}
 
 	/*
@@ -399,7 +407,9 @@
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Set IRQ %d\n", link->irq.active));
 	
-	return_VALUE(0);
+end:
+	kfree(resource);
+	return_VALUE(result);
 }
 
 
@@ -810,7 +820,7 @@
  */
 static int __init acpi_irq_isa(char *str)
 {
-	return(acpi_irq_penalty_update(str, 1));
+	return acpi_irq_penalty_update(str, 1);
 }
 __setup("acpi_irq_isa=", acpi_irq_isa);
 
@@ -821,7 +831,7 @@
  */
 static int __init acpi_irq_pci(char *str)
 {
-	return(acpi_irq_penalty_update(str, 0));
+	return acpi_irq_penalty_update(str, 0);
 }
 __setup("acpi_irq_pci=", acpi_irq_pci);
 
diff -Nru a/drivers/acpi/processor.c b/drivers/acpi/processor.c
--- a/drivers/acpi/processor.c	2005-01-06 15:06:41 -05:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,2644 +0,0 @@
-/*
- * acpi_processor.c - ACPI Processor Driver ($Revision$)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *  TBD:
- *	1. Make # power states dynamic.
- *	2. Support duty_cycle values that span bit 4.
- *	3. Optimize by having scheduler determine business instead of
- *	   having us try to calculate it here.
- *	4. Need C1 timing -- must modify kernel (IRQ handler) to get this.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/pm.h>
-#include <linux/cpufreq.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/dmi.h>
-#include <linux/moduleparam.h>
-
-#include <asm/io.h>
-#include <asm/system.h>
-#include <asm/delay.h>
-#include <asm/uaccess.h>
-#include <asm/processor.h>
-#include <asm/smp.h>
-#include <asm/acpi.h>
-
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
-#include <acpi/processor.h>
-
-
-#define ACPI_PROCESSOR_COMPONENT	0x01000000
-#define ACPI_PROCESSOR_CLASS		"processor"
-#define ACPI_PROCESSOR_DRIVER_NAME	"ACPI Processor Driver"
-#define ACPI_PROCESSOR_DEVICE_NAME	"Processor"
-#define ACPI_PROCESSOR_FILE_INFO	"info"
-#define ACPI_PROCESSOR_FILE_POWER	"power"
-#define ACPI_PROCESSOR_FILE_THROTTLING	"throttling"
-#define ACPI_PROCESSOR_FILE_LIMIT	"limit"
-#define ACPI_PROCESSOR_FILE_PERFORMANCE	"performance"
-#define ACPI_PROCESSOR_NOTIFY_PERFORMANCE 0x80
-#define ACPI_PROCESSOR_NOTIFY_POWER	0x81
-
-#define US_TO_PM_TIMER_TICKS(t)		((t * (PM_TIMER_FREQUENCY/1000)) / 1000)
-#define C2_OVERHEAD			4	/* 1us (3.579 ticks per us) */
-#define C3_OVERHEAD			4	/* 1us (3.579 ticks per us) */
-
-
-#define ACPI_PROCESSOR_LIMIT_USER	0
-#define ACPI_PROCESSOR_LIMIT_THERMAL	1
-
-#define _COMPONENT		ACPI_PROCESSOR_COMPONENT
-ACPI_MODULE_NAME		("acpi_processor")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_PROCESSOR_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-
-static int acpi_processor_add (struct acpi_device *device);
-static int acpi_processor_remove (struct acpi_device *device, int type);
-static int acpi_processor_info_open_fs(struct inode *inode, struct file *file);
-static int acpi_processor_throttling_open_fs(struct inode *inode, struct file *file);
-static int acpi_processor_power_open_fs(struct inode *inode, struct file *file);
-static int acpi_processor_limit_open_fs(struct inode *inode, struct file *file);
-static int acpi_processor_get_limit_info(struct acpi_processor *pr);
-
-static struct acpi_driver acpi_processor_driver = {
-	.name =		ACPI_PROCESSOR_DRIVER_NAME,
-	.class =	ACPI_PROCESSOR_CLASS,
-	.ids =		ACPI_PROCESSOR_HID,
-	.ops =		{
-				.add =		acpi_processor_add,
-				.remove =	acpi_processor_remove,
-			},
-};
-
-
-struct acpi_processor_errata {
-	u8			smp;
-	struct {
-		u8			throttle:1;
-		u8			fdma:1;
-		u8			reserved:6;
-		u32			bmisx;
-	}			piix4;
-};
-
-static struct file_operations acpi_processor_info_fops = {
-	.open 		= acpi_processor_info_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static struct file_operations acpi_processor_power_fops = {
-	.open 		= acpi_processor_power_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static struct file_operations acpi_processor_throttling_fops = {
-	.open 		= acpi_processor_throttling_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static struct file_operations acpi_processor_limit_fops = {
-	.open 		= acpi_processor_limit_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static struct acpi_processor	*processors[NR_CPUS];
-static struct acpi_processor_errata errata;
-static void (*pm_idle_save)(void);
-
-
-/* --------------------------------------------------------------------------
-                                Errata Handling
-   -------------------------------------------------------------------------- */
-
-int
-acpi_processor_errata_piix4 (
-	struct pci_dev		*dev)
-{
-	u8			rev = 0;
-	u8			value1 = 0;
-	u8			value2 = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_errata_piix4");
-
-	if (!dev)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * Note that 'dev' references the PIIX4 ACPI Controller.
-	 */
-
-	pci_read_config_byte(dev, PCI_REVISION_ID, &rev);
-
-	switch (rev) {
-	case 0:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 A-step\n"));
-		break;
-	case 1:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 B-step\n"));
-		break;
-	case 2:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4E\n"));
-		break;
-	case 3:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4M\n"));
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unknown PIIX4\n"));
-		break;
-	}
-
-	switch (rev) {
-
-	case 0:		/* PIIX4 A-step */
-	case 1:		/* PIIX4 B-step */
-		/*
-		 * See specification changes #13 ("Manual Throttle Duty Cycle")
-		 * and #14 ("Enabling and Disabling Manual Throttle"), plus
-		 * erratum #5 ("STPCLK# Deassertion Time") from the January 
-		 * 2002 PIIX4 specification update.  Applies to only older 
-		 * PIIX4 models.
-		 */
-		errata.piix4.throttle = 1;
-
-	case 2:		/* PIIX4E */
-	case 3:		/* PIIX4M */
-		/*
-		 * See erratum #18 ("C3 Power State/BMIDE and Type-F DMA 
-		 * Livelock") from the January 2002 PIIX4 specification update.
-		 * Applies to all PIIX4 models.
-		 */
-
-		/* 
-		 * BM-IDE
-		 * ------
-		 * Find the PIIX4 IDE Controller and get the Bus Master IDE 
-		 * Status register address.  We'll use this later to read 
-		 * each IDE controller's DMA status to make sure we catch all
-		 * DMA activity.
-		 */
-		dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,
-		           PCI_DEVICE_ID_INTEL_82371AB, 
-                           PCI_ANY_ID, PCI_ANY_ID, NULL);
-		if (dev) {
-			errata.piix4.bmisx = pci_resource_start(dev, 4);
-			pci_dev_put(dev);
-		}
-
-		/* 
-		 * Type-F DMA
-		 * ----------
-		 * Find the PIIX4 ISA Controller and read the Motherboard
-		 * DMA controller's status to see if Type-F (Fast) DMA mode
-		 * is enabled (bit 7) on either channel.  Note that we'll 
-		 * disable C3 support if this is enabled, as some legacy 
-		 * devices won't operate well if fast DMA is disabled.
-		 */
-		dev = pci_get_subsys(PCI_VENDOR_ID_INTEL, 
-			PCI_DEVICE_ID_INTEL_82371AB_0, 
-			PCI_ANY_ID, PCI_ANY_ID, NULL);
-		if (dev) {
-			pci_read_config_byte(dev, 0x76, &value1);
-			pci_read_config_byte(dev, 0x77, &value2);
-			if ((value1 & 0x80) || (value2 & 0x80))
-				errata.piix4.fdma = 1;
-			pci_dev_put(dev);
-		}
-
-		break;
-	}
-
-	if (errata.piix4.bmisx)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Bus master activity detection (BM-IDE) erratum enabled\n"));
-	if (errata.piix4.fdma)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Type-F DMA livelock erratum (C3 disabled)\n"));
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_processor_errata (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-	struct pci_dev		*dev = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_errata");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * PIIX4
-	 */
-	dev = pci_get_subsys(PCI_VENDOR_ID_INTEL, 
-		PCI_DEVICE_ID_INTEL_82371AB_3, PCI_ANY_ID, PCI_ANY_ID, NULL);
-	if (dev) {
-		result = acpi_processor_errata_piix4(dev);
-		pci_dev_put(dev);
-	}
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                                Power Management
-   -------------------------------------------------------------------------- */
-
-static inline u32
-ticks_elapsed (
-	u32			t1,
-	u32			t2)
-{
-	if (t2 >= t1)
-		return (t2 - t1);
-	else if (!acpi_fadt.tmr_val_ext)
-		return (((0x00FFFFFF - t1) + t2) & 0x00FFFFFF);
-	else
-		return ((0xFFFFFFFF - t1) + t2);
-}
-
-
-static void
-acpi_processor_power_activate (
-	struct acpi_processor	*pr,
-	int			state)
-{
-	if (!pr)
-		return;
-
-	pr->power.states[pr->power.state].promotion.count = 0;
-	pr->power.states[pr->power.state].demotion.count = 0;
-
-	/* Cleanup from old state. */
-	switch (pr->power.state) {
-	case ACPI_STATE_C3:
-		/* Disable bus master reload */
-		acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 0, ACPI_MTX_DO_NOT_LOCK);
-		break;
-	}
-
-	/* Prepare to use new state. */
-	switch (state) {
-	case ACPI_STATE_C3:
-		/* Enable bus master reload */
-		acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 1, ACPI_MTX_DO_NOT_LOCK);
-		break;
-	}
-
-	pr->power.state = state;
-
-	return;
-}
-
-
-static void
-acpi_processor_idle (void)
-{
-	struct acpi_processor	*pr = NULL;
-	struct acpi_processor_cx *cx = NULL;
-	unsigned int			next_state = 0;
-	unsigned int		sleep_ticks = 0;
-	u32			t1, t2 = 0;
-
-	pr = processors[smp_processor_id()];
-	if (!pr)
-		return;
-
-	/*
-	 * Interrupts must be disabled during bus mastering calculations and
-	 * for C2/C3 transitions.
-	 */
-	local_irq_disable();
-
-	/*
-	 * Check whether we truly need to go idle, or should
-	 * reschedule:
-	 */
-	if (unlikely(need_resched())) {
-		local_irq_enable();
-		return;
-	}
-
-	cx = &(pr->power.states[pr->power.state]);
-
-	/*
-	 * Check BM Activity
-	 * -----------------
-	 * Check for bus mastering activity (if required), record, and check
-	 * for demotion.
-	 */
-	if (pr->flags.bm_check) {
-		u32		bm_status = 0;
-
-		pr->power.bm_activity <<= 1;
-
-		acpi_get_register(ACPI_BITREG_BUS_MASTER_STATUS, 
-			&bm_status, ACPI_MTX_DO_NOT_LOCK);
-		if (bm_status) {
-			pr->power.bm_activity++;
-			acpi_set_register(ACPI_BITREG_BUS_MASTER_STATUS,
-				1, ACPI_MTX_DO_NOT_LOCK);
-		}
-		/*
-		 * PIIX4 Erratum #18: Note that BM_STS doesn't always reflect
-		 * the true state of bus mastering activity; forcing us to 
-		 * manually check the BMIDEA bit of each IDE channel.
-		 */
-		else if (errata.piix4.bmisx) {
-			if ((inb_p(errata.piix4.bmisx + 0x02) & 0x01) 
-				|| (inb_p(errata.piix4.bmisx + 0x0A) & 0x01))
-				pr->power.bm_activity++;
-		}
-		/*
-		 * Apply bus mastering demotion policy.  Automatically demote
-		 * to avoid a faulty transition.  Note that the processor 
-		 * won't enter a low-power state during this call (to this 
-		 * funciton) but should upon the next.
-		 *
-		 * TBD: A better policy might be to fallback to the demotion 
-		 *      state (use it for this quantum only) istead of 
-		 *      demoting -- and rely on duration as our sole demotion
-		 *      qualification.  This may, however, introduce DMA 
-		 *      issues (e.g. floppy DMA transfer overrun/underrun).
-		 */
-		if (pr->power.bm_activity & cx->demotion.threshold.bm) {
-			local_irq_enable();
-			next_state = cx->demotion.state;
-			goto end;
-		}
-	}
-
-	cx->usage++;
-
-	/*
-	 * Sleep:
-	 * ------
-	 * Invoke the current Cx state to put the processor to sleep.
-	 */
-	switch (pr->power.state) {
-
-	case ACPI_STATE_C1:
-		/*
-		 * Invoke C1.
-		 * Use the appropriate idle routine, the one that would
-		 * be used without acpi C-states.
-		 */
-		if (pm_idle_save)
-			pm_idle_save();
-		else
-			safe_halt();
-		/*
-                 * TBD: Can't get time duration while in C1, as resumes
-		 *      go to an ISR rather than here.  Need to instrument
-		 *      base interrupt handler.
-		 */
-		sleep_ticks = 0xFFFFFFFF;
-		break;
-
-	case ACPI_STATE_C2:
-		/* Get start time (ticks) */
-		t1 = inl(acpi_fadt.xpm_tmr_blk.address);
-		/* Invoke C2 */
-		inb(pr->power.states[ACPI_STATE_C2].address);
-		/* Dummy op - must do something useless after P_LVL2 read */
-		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
-		/* Get end time (ticks) */
-		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
-		/* Re-enable interrupts */
-		local_irq_enable();
-		/* Compute time (ticks) that we were actually asleep */
-		sleep_ticks = ticks_elapsed(t1, t2) - cx->latency_ticks - C2_OVERHEAD;
-		break;
-
-	case ACPI_STATE_C3:
-		/* Disable bus master arbitration */
-		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
-		/* Get start time (ticks) */
-		t1 = inl(acpi_fadt.xpm_tmr_blk.address);
-		/* Invoke C3 */
-		inb(pr->power.states[ACPI_STATE_C3].address);
-		/* Dummy op - must do something useless after P_LVL3 read */
-		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
-		/* Get end time (ticks) */
-		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
-		/* Enable bus master arbitration */
-		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_DO_NOT_LOCK);
-		/* Re-enable interrupts */
-		local_irq_enable();
-		/* Compute time (ticks) that we were actually asleep */
-		sleep_ticks = ticks_elapsed(t1, t2) - cx->latency_ticks - C3_OVERHEAD;
-		break;
-
-	default:
-		local_irq_enable();
-		return;
-	}
-
-	next_state = pr->power.state;
-
-	/*
-	 * Promotion?
-	 * ----------
-	 * Track the number of longs (time asleep is greater than threshold)
-	 * and promote when the count threshold is reached.  Note that bus
-	 * mastering activity may prevent promotions.
-	 * Do not promote above max_cstate.
-	 */
-	if (cx->promotion.state && (cx->promotion.state <= max_cstate)) {
-		if (sleep_ticks > cx->promotion.threshold.ticks) {
-			cx->promotion.count++;
- 			cx->demotion.count = 0;
-			if (cx->promotion.count >= cx->promotion.threshold.count) {
-				if (pr->flags.bm_check) {
-					if (!(pr->power.bm_activity & cx->promotion.threshold.bm)) {
-						next_state = cx->promotion.state;
-						goto end;
-					}
-				}
-				else {
-					next_state = cx->promotion.state;
-					goto end;
-				}
-			}
-		}
-	}
-
-	/*
-	 * Demotion?
-	 * ---------
-	 * Track the number of shorts (time asleep is less than time threshold)
-	 * and demote when the usage threshold is reached.
-	 */
-	if (cx->demotion.state) {
-		if (sleep_ticks < cx->demotion.threshold.ticks) {
-			cx->demotion.count++;
-			cx->promotion.count = 0;
-			if (cx->demotion.count >= cx->demotion.threshold.count) {
-				next_state = cx->demotion.state;
-				goto end;
-			}
-		}
-	}
-
-end:
-	/*
-	 * Demote if current state exceeds max_cstate
-	 */
-	if (pr->power.state > max_cstate) {
-		next_state = max_cstate;
-	}
-
-	/*
-	 * New Cx State?
-	 * -------------
-	 * If we're going to start using a new Cx state we must clean up
-	 * from the previous and prepare to use the new.
-	 */
-	if (next_state != pr->power.state)
-		acpi_processor_power_activate(pr, next_state);
-
-	return;
-}
-
-
-static int
-acpi_processor_set_power_policy (
-	struct acpi_processor	*pr)
-{
-	ACPI_FUNCTION_TRACE("acpi_processor_set_power_policy");
-
-	/*
-	 * This function sets the default Cx state policy (OS idle handler).
-	 * Our scheme is to promote quickly to C2 but more conservatively
-	 * to C3.  We're favoring C2  for its characteristics of low latency
-	 * (quick response), good power savings, and ability to allow bus
-	 * mastering activity.  Note that the Cx state policy is completely
-	 * customizable and can be altered dynamically.
-	 */
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * C0/C1
-	 * -----
-	 */
-	pr->power.state = ACPI_STATE_C1;
-	pr->power.default_state = ACPI_STATE_C1;
-
-	/*
-	 * C1/C2
-	 * -----
-	 * Set the default C1 promotion and C2 demotion policies, where we
-	 * promote from C1 to C2 after several (10) successive C1 transitions,
-	 * as we cannot (currently) measure the time spent in C1. Demote from
-	 * C2 to C1 anytime we experience a 'short' (time spent in C2 is less
-	 * than the C2 transtion latency).  Note the simplifying assumption 
-	 * that the 'cost' of a transition is amortized when we sleep for at
-	 * least as long as the transition's latency (thus the total transition
-	 * time is two times the latency).
-	 *
-	 * TBD: Measure C1 sleep times by instrumenting the core IRQ handler.
-	 * TBD: Demote to default C-State after long periods of activity.
-	 * TBD: Investigate policy's use of CPU utilization -vs- sleep duration.
-	 */
-	if (pr->power.states[ACPI_STATE_C2].valid) {
-		pr->power.states[ACPI_STATE_C1].promotion.threshold.count = 10;
-		pr->power.states[ACPI_STATE_C1].promotion.threshold.ticks =
-			pr->power.states[ACPI_STATE_C2].latency_ticks;
-		pr->power.states[ACPI_STATE_C1].promotion.state = ACPI_STATE_C2;
-
-		pr->power.states[ACPI_STATE_C2].demotion.threshold.count = 1;
-		pr->power.states[ACPI_STATE_C2].demotion.threshold.ticks =
-			pr->power.states[ACPI_STATE_C2].latency_ticks;
-		pr->power.states[ACPI_STATE_C2].demotion.state = ACPI_STATE_C1;
-	}
-
-	/*
-	 * C2/C3
-	 * -----
-	 * Set default C2 promotion and C3 demotion policies, where we promote
-	 * from C2 to C3 after several (4) cycles of no bus mastering activity
-	 * while maintaining sleep time criteria.  Demote immediately on a
-	 * short or whenever bus mastering activity occurs.
-	 */
-	if ((pr->power.states[ACPI_STATE_C2].valid) &&
-		(pr->power.states[ACPI_STATE_C3].valid)) {
-		pr->power.states[ACPI_STATE_C2].promotion.threshold.count = 4;
-		pr->power.states[ACPI_STATE_C2].promotion.threshold.ticks =
-			pr->power.states[ACPI_STATE_C3].latency_ticks;
-		pr->power.states[ACPI_STATE_C2].promotion.threshold.bm = 0x0F;
-		pr->power.states[ACPI_STATE_C2].promotion.state = ACPI_STATE_C3;
-
-		pr->power.states[ACPI_STATE_C3].demotion.threshold.count = 1;
-		pr->power.states[ACPI_STATE_C3].demotion.threshold.ticks =
-			pr->power.states[ACPI_STATE_C3].latency_ticks;
-		pr->power.states[ACPI_STATE_C3].demotion.threshold.bm = 0x0F;
-		pr->power.states[ACPI_STATE_C3].demotion.state = ACPI_STATE_C2;
-	}
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_processor_get_power_info (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-		"lvl2[0x%08x] lvl3[0x%08x]\n",
-		pr->power.states[ACPI_STATE_C2].address,
-		pr->power.states[ACPI_STATE_C3].address));
-
-	/* TBD: Support ACPI 2.0 objects */
-
-	/*
-	 * C0
-	 * --
-	 * This state exists only as filler in our array.
-	 */
-	pr->power.states[ACPI_STATE_C0].valid = 1;
-
-	/*
-	 * C1
-	 * --
-	 * ACPI requires C1 support for all processors.
-	 *
-	 * TBD: What about PROC_C1?
-	 */
-	pr->power.states[ACPI_STATE_C1].valid = 1;
-
-	/*
-	 * C2
-	 * --
-	 * We're (currently) only supporting C2 on UP systems.
-	 *
-	 * TBD: Support for C2 on MP (P_LVL2_UP).
-	 */
-	if (pr->power.states[ACPI_STATE_C2].address) {
-
-		pr->power.states[ACPI_STATE_C2].latency = acpi_fadt.plvl2_lat;
-
-		/*
-		 * C2 latency must be less than or equal to 100 microseconds.
-		 */
-		if (acpi_fadt.plvl2_lat > ACPI_PROCESSOR_MAX_C2_LATENCY)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C2 latency too large [%d]\n",
-				acpi_fadt.plvl2_lat));
-		/*
-		 * Only support C2 on UP systems (see TBD above).
-		 */
-		else if (errata.smp)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C2 not supported in SMP mode\n"));
-		/*
-		 * Otherwise we've met all of our C2 requirements.
-		 * Normalize the C2 latency to expidite policy.
-		 */
-		else {
-			pr->power.states[ACPI_STATE_C2].valid = 1;
-			pr->power.states[ACPI_STATE_C2].latency_ticks = 
-				US_TO_PM_TIMER_TICKS(acpi_fadt.plvl2_lat);
-		}
-	}
-
-	/*
-	 * C3
-	 * --
-	 * TBD: Investigate use of WBINVD on UP/SMP system in absence of
-	 *	bm_control.
-	 */
-	if (pr->power.states[ACPI_STATE_C3].address) {
-
-		pr->power.states[ACPI_STATE_C3].latency = acpi_fadt.plvl3_lat;
-
-		/*
-		 * C3 latency must be less than or equal to 1000 microseconds.
-		 */
-		if (acpi_fadt.plvl3_lat > ACPI_PROCESSOR_MAX_C3_LATENCY)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C3 latency too large [%d]\n", 
-				acpi_fadt.plvl3_lat));
-		/*
-		 * Only support C3 when bus mastering arbitration control
-		 * is present (able to disable bus mastering to maintain
-		 * cache coherency while in C3).
-		 */
-		else if (!pr->flags.bm_control)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C3 support requires bus mastering control\n"));
-		/*
-		 * Only support C3 on UP systems, as bm_control is only viable
-		 * on a UP system and flushing caches (e.g. WBINVD) is simply 
-		 * too costly (at this time).
-		 */
-		else if (errata.smp)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C3 not supported in SMP mode\n"));
-		/*
-		 * PIIX4 Erratum #18: We don't support C3 when Type-F (fast) 
-		 * DMA transfers are used by any ISA device to avoid livelock.
-		 * Note that we could disable Type-F DMA (as recommended by
-		 * the erratum), but this is known to disrupt certain ISA 
-		 * devices thus we take the conservative approach.
-		 */
-		else if (errata.piix4.fdma) {
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C3 not supported on PIIX4 with Type-F DMA\n"));
-		}
-		/*
-		 * Otherwise we've met all of our C3 requirements.  
-		 * Normalize the C2 latency to expidite policy.  Enable
-		 * checking of bus mastering status (bm_check) so we can 
-		 * use this in our C3 policy.
-		 */
-		else {
-			pr->power.states[ACPI_STATE_C3].valid = 1;
-			pr->power.states[ACPI_STATE_C3].latency_ticks = 
-				US_TO_PM_TIMER_TICKS(acpi_fadt.plvl3_lat);
-			pr->flags.bm_check = 1;
-		}
-	}
-
-	/*
-	 * Set Default Policy
-	 * ------------------
-	 * Now that we know which state are supported, set the default
-	 * policy.  Note that this policy can be changed dynamically
-	 * (e.g. encourage deeper sleeps to conserve battery life when
-	 * not on AC).
-	 */
-	result = acpi_processor_set_power_policy(pr);
-	if (result)
-		return_VALUE(result);
-
-	/*
-	 * If this processor supports C2 or C3 we denote it as being 'power
-	 * manageable'.  Note that there's really no policy involved for
-	 * when only C1 is supported.
-	 */
-	if (pr->power.states[ACPI_STATE_C2].valid 
-		|| pr->power.states[ACPI_STATE_C3].valid)
-		pr->flags.power = 1;
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                              Performance Management
-   -------------------------------------------------------------------------- */
-#ifdef CONFIG_CPU_FREQ
-
-static DECLARE_MUTEX(performance_sem);
-
-/*
- * _PPC support is implemented as a CPUfreq policy notifier: 
- * This means each time a CPUfreq driver registered also with
- * the ACPI core is asked to change the speed policy, the maximum
- * value is adjusted so that it is within the platform limit.
- * 
- * Also, when a new platform limit value is detected, the CPUfreq
- * policy is adjusted accordingly.
- */
-
-#define PPC_REGISTERED   1
-#define PPC_IN_USE       2
-
-static int acpi_processor_ppc_status = 0;
-
-static int acpi_processor_ppc_notifier(struct notifier_block *nb, 
-	unsigned long event,
-	void *data)
-{
-	struct cpufreq_policy *policy = data;
-	struct acpi_processor *pr;
-	unsigned int ppc = 0;
-
-	down(&performance_sem);
-
-	if (event != CPUFREQ_INCOMPATIBLE)
-		goto out;
-
-	pr = processors[policy->cpu];
-	if (!pr || !pr->performance)
-		goto out;
-
-	ppc = (unsigned int) pr->performance_platform_limit;
-	if (!ppc)
-		goto out;
-
-	if (ppc > pr->performance->state_count)
-		goto out;
-
-	cpufreq_verify_within_limits(policy, 0, 
-		pr->performance->states[ppc].core_frequency * 1000);
-
- out:
-	up(&performance_sem);
-
-	return 0;
-}
-
-
-static struct notifier_block acpi_ppc_notifier_block = {
-	.notifier_call = acpi_processor_ppc_notifier,
-};
-
-
-static int
-acpi_processor_get_platform_limit (
-	struct acpi_processor*	pr)
-{
-	acpi_status		status = 0;
-	unsigned long		ppc = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_platform_limit");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * _PPC indicates the maximum state currently supported by the platform
-	 * (e.g. 0 = states 0..n; 1 = states 1..n; etc.
-	 */
-	status = acpi_evaluate_integer(pr->handle, "_PPC", NULL, &ppc);
-
-	if (status != AE_NOT_FOUND)
-		acpi_processor_ppc_status |= PPC_IN_USE;
-
-	if(ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PPC\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	pr->performance_platform_limit = (int) ppc;
-	
-	return_VALUE(0);
-}
-
-
-static int acpi_processor_ppc_has_changed(
-	struct acpi_processor *pr)
-{
-	int ret = acpi_processor_get_platform_limit(pr);
-	if (ret < 0)
-		return (ret);
-	else
-		return cpufreq_update_policy(pr->id);
-}
-
-
-static void acpi_processor_ppc_init(void) {
-	if (!cpufreq_register_notifier(&acpi_ppc_notifier_block, CPUFREQ_POLICY_NOTIFIER))
-		acpi_processor_ppc_status |= PPC_REGISTERED;
-	else
-		printk(KERN_DEBUG "Warning: Processor Platform Limit not supported.\n");
-}
-
-
-static void acpi_processor_ppc_exit(void) {
-	if (acpi_processor_ppc_status & PPC_REGISTERED)
-		cpufreq_unregister_notifier(&acpi_ppc_notifier_block, CPUFREQ_POLICY_NOTIFIER);
-
-	acpi_processor_ppc_status &= ~PPC_REGISTERED;
-}
-
-/*
- * when registering a cpufreq driver with this ACPI processor driver, the
- * _PCT and _PSS structures are read out and written into struct
- * acpi_processor_performance.
- */
-static int acpi_processor_set_pdc (struct acpi_processor *pr)
-{
-	acpi_status             status = AE_OK;
-	u32			arg0_buf[3];
-	union acpi_object	arg0 = {ACPI_TYPE_BUFFER};
-	struct acpi_object_list no_object = {1, &arg0};
-	struct acpi_object_list *pdc;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_set_pdc");
-	
-	arg0.buffer.length = 12;
-	arg0.buffer.pointer = (u8 *) arg0_buf;
-	arg0_buf[0] = ACPI_PDC_REVISION_ID;
-	arg0_buf[1] = 0;
-	arg0_buf[2] = 0;
-
-	pdc = (pr->performance->pdc) ? pr->performance->pdc : &no_object;
-
-	status = acpi_evaluate_object(pr->handle, "_PDC", pdc, NULL);
-
-	if ((ACPI_FAILURE(status)) && (pr->performance->pdc))
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Error evaluating _PDC, using legacy perf. control...\n"));
-
-	return_VALUE(status);
-}
-
-
-static int 
-acpi_processor_get_performance_control (
-	struct acpi_processor *pr)
-{
-	int			result = 0;
-	acpi_status		status = 0;
-	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	union acpi_object	*pct = NULL;
-	union acpi_object	obj = {0};
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_control");
-
-	status = acpi_evaluate_object(pr->handle, "_PCT", NULL, &buffer);
-	if(ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PCT\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	pct = (union acpi_object *) buffer.pointer;
-	if (!pct || (pct->type != ACPI_TYPE_PACKAGE) 
-		|| (pct->package.count != 2)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PCT data\n"));
-		result = -EFAULT;
-		goto end;
-	}
-
-	/*
-	 * control_register
-	 */
-
-	obj = pct->package.elements[0];
-
-	if ((obj.type != ACPI_TYPE_BUFFER) 
-		|| (obj.buffer.length < sizeof(struct acpi_pct_register)) 
-		|| (obj.buffer.pointer == NULL)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Invalid _PCT data (control_register)\n"));
-		result = -EFAULT;
-		goto end;
-	}
-	memcpy(&pr->performance->control_register, obj.buffer.pointer, sizeof(struct acpi_pct_register));
-
-
-	/*
-	 * status_register
-	 */
-
-	obj = pct->package.elements[1];
-
-	if ((obj.type != ACPI_TYPE_BUFFER) 
-		|| (obj.buffer.length < sizeof(struct acpi_pct_register)) 
-		|| (obj.buffer.pointer == NULL)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Invalid _PCT data (status_register)\n"));
-		result = -EFAULT;
-		goto end;
-	}
-
-	memcpy(&pr->performance->status_register, obj.buffer.pointer, sizeof(struct acpi_pct_register));
-
-end:
-	acpi_os_free(buffer.pointer);
-
-	return_VALUE(result);
-}
-
-
-static int 
-acpi_processor_get_performance_states (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	struct acpi_buffer	format = {sizeof("NNNNNN"), "NNNNNN"};
-	struct acpi_buffer	state = {0, NULL};
-	union acpi_object 	*pss = NULL;
-	unsigned int		i;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_states");
-
-	status = acpi_evaluate_object(pr->handle, "_PSS", NULL, &buffer);
-	if(ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PSS\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	pss = (union acpi_object *) buffer.pointer;
-	if (!pss || (pss->type != ACPI_TYPE_PACKAGE)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
-		result = -EFAULT;
-		goto end;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d performance states\n", 
-		pss->package.count));
-
-	pr->performance->state_count = pss->package.count;
-	pr->performance->states = kmalloc(sizeof(struct acpi_processor_px) * pss->package.count, GFP_KERNEL);
-	if (!pr->performance->states) {
-		result = -ENOMEM;
-		goto end;
-	}
-
-	for (i = 0; i < pr->performance->state_count; i++) {
-
-		struct acpi_processor_px *px = &(pr->performance->states[i]);
-
-		state.length = sizeof(struct acpi_processor_px);
-		state.pointer = px;
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));
-
-		status = acpi_extract_package(&(pss->package.elements[i]), 
-			&format, &state);
-		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
-			result = -EFAULT;
-			kfree(pr->performance->states);
-			goto end;
-		}
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"State [%d]: core_frequency[%d] power[%d] transition_latency[%d] bus_master_latency[%d] control[0x%x] status[0x%x]\n",
-			i, 
-			(u32) px->core_frequency, 
-			(u32) px->power, 
-			(u32) px->transition_latency, 
-			(u32) px->bus_master_latency,
-			(u32) px->control, 
-			(u32) px->status));
-
-		if (!px->core_frequency) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data: freq is zero\n"));
-			result = -EFAULT;
-			kfree(pr->performance->states);
-			goto end;
-		}
-	}
-
-end:
-	acpi_os_free(buffer.pointer);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_processor_get_performance_info (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	acpi_handle		handle = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_info");
-
-	if (!pr || !pr->performance || !pr->handle)
-		return_VALUE(-EINVAL);
-
-	acpi_processor_set_pdc(pr);
-
-	status = acpi_get_handle(pr->handle, "_PCT", &handle);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"ACPI-based processor performance control unavailable\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	result = acpi_processor_get_performance_control(pr);
-	if (result)
-		return_VALUE(result);
-
-	result = acpi_processor_get_performance_states(pr);
-	if (result)
-		return_VALUE(result);
-
-	result = acpi_processor_get_platform_limit(pr);
-	if (result)
-		return_VALUE(result);
-
-	return_VALUE(0);
-}
-
-
-int acpi_processor_notify_smm(struct module *calling_module) {
-	acpi_status		status;
-	static int		is_done = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_notify_smm");
-
-	if (!(acpi_processor_ppc_status & PPC_REGISTERED))
-		return_VALUE(-EBUSY);
-
-	if (!try_module_get(calling_module))
-		return_VALUE(-EINVAL);
-
-	/* is_done is set to negative if an error occured,
-	 * and to postitive if _no_ error occured, but SMM
-	 * was already notified. This avoids double notification
-	 * which might lead to unexpected results...
-	 */
-	if (is_done > 0) {
-		module_put(calling_module);
-		return_VALUE(0);
-	}
-	else if (is_done < 0) {
-		module_put(calling_module);
-		return_VALUE(is_done);
-	}
-
-	is_done = -EIO;
-
-	/* Can't write pstate_cnt to smi_cmd if either value is zero */
-	if ((!acpi_fadt.smi_cmd) ||
-	    (!acpi_fadt.pstate_cnt)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"No SMI port or pstate_cnt\n"));
-		module_put(calling_module);
-		return_VALUE(0);
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Writing pstate_cnt [0x%x] to smi_cmd [0x%x]\n", acpi_fadt.pstate_cnt, acpi_fadt.smi_cmd));
-
-	/* FADT v1 doesn't support pstate_cnt, many BIOS vendors use
-	 * it anyway, so we need to support it... */
-	if (acpi_fadt_is_v1) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Using v1.0 FADT reserved value for pstate_cnt\n"));
-	}
-
-	status = acpi_os_write_port (acpi_fadt.smi_cmd,
-				     (u32) acpi_fadt.pstate_cnt, 8);
-	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Failed to write pstate_cnt [0x%x] to "
-				  "smi_cmd [0x%x]\n", acpi_fadt.pstate_cnt, acpi_fadt.smi_cmd));
-		module_put(calling_module);
-		return_VALUE(status);
-	}
-
-	/* Success. If there's no _PPC, we need to fear nothing, so
-	 * we can allow the cpufreq driver to be rmmod'ed. */
-	is_done = 1;
-
-	if (!(acpi_processor_ppc_status & PPC_IN_USE))
-		module_put(calling_module);
-
-	return_VALUE(0);
-}
-EXPORT_SYMBOL(acpi_processor_notify_smm);
-
-
-#ifdef CONFIG_X86_ACPI_CPUFREQ_PROC_INTF
-/* /proc/acpi/processor/../performance interface (DEPRECATED) */
-
-static int acpi_processor_perf_open_fs(struct inode *inode, struct file *file);
-static struct file_operations acpi_processor_perf_fops = {
-	.open 		= acpi_processor_perf_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int acpi_processor_perf_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
-	unsigned int		i;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_perf_seq_show");
-
-	if (!pr)
-		goto end;
-
-	if (!pr->performance) {
-		seq_puts(seq, "<not supported>\n");
-		goto end;
-	}
-
-	seq_printf(seq, "state count:             %d\n"
-			"active state:            P%d\n",
-			pr->performance->state_count,
-			pr->performance->state);
-
-	seq_puts(seq, "states:\n");
-	for (i = 0; i < pr->performance->state_count; i++)
-		seq_printf(seq, "   %cP%d:                  %d MHz, %d mW, %d uS\n",
-			(i == pr->performance->state?'*':' '), i,
-			(u32) pr->performance->states[i].core_frequency,
-			(u32) pr->performance->states[i].power,
-			(u32) pr->performance->states[i].transition_latency);
-
-end:
-	return_VALUE(0);
-}
-
-static int acpi_processor_perf_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_processor_perf_seq_show,
-						PDE(inode)->data);
-}
-
-static ssize_t
-acpi_processor_write_performance (
-        struct file		*file,
-        const char		__user *buffer,
-        size_t			count,
-        loff_t			*data)
-{
-	int			result = 0;
-	struct seq_file		*m = (struct seq_file *) file->private_data;
-	struct acpi_processor	*pr = (struct acpi_processor *) m->private;
-	struct acpi_processor_performance *perf;
-	char			state_string[12] = {'\0'};
-	unsigned int            new_state = 0;
-	struct cpufreq_policy   policy;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_write_performance");
-
-	if (!pr || (count > sizeof(state_string) - 1))
-		return_VALUE(-EINVAL);
-
-	perf = pr->performance;
-	if (!perf)
-		return_VALUE(-EINVAL);
-	
-	if (copy_from_user(state_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	state_string[count] = '\0';
-	new_state = simple_strtoul(state_string, NULL, 0);
-
-	if (new_state >= perf->state_count)
-		return_VALUE(-EINVAL);
-
-	cpufreq_get_policy(&policy, pr->id);
-
-	policy.cpu = pr->id;
-	policy.min = perf->states[new_state].core_frequency * 1000;
-	policy.max = perf->states[new_state].core_frequency * 1000;
-
-	result = cpufreq_set_policy(&policy);
-	if (result)
-		return_VALUE(result);
-
-	return_VALUE(count);
-}
-
-static void
-acpi_cpufreq_add_file (
-	struct acpi_processor *pr)
-{
-	struct proc_dir_entry	*entry = NULL;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_cpufreq_addfile");
-
-	if (acpi_bus_get_device(pr->handle, &device))
-		return_VOID;
-
-	/* add file 'performance' [R/W] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_PERFORMANCE,
-		  S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_PERFORMANCE));
-	else {
-		entry->proc_fops = &acpi_processor_perf_fops;
-		entry->proc_fops->write = acpi_processor_write_performance;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-	return_VOID;
-}
-
-static void
-acpi_cpufreq_remove_file (
-	struct acpi_processor *pr)
-{
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_cpufreq_addfile");
-
-	if (acpi_bus_get_device(pr->handle, &device))
-		return_VOID;
-
-	/* remove file 'performance' */
-	remove_proc_entry(ACPI_PROCESSOR_FILE_PERFORMANCE,
-		  acpi_device_dir(device));
-
-	return_VOID;
-}
-
-#else
-static void acpi_cpufreq_add_file (struct acpi_processor *pr) { return; }
-static void acpi_cpufreq_remove_file (struct acpi_processor *pr) { return; }
-#endif /* CONFIG_X86_ACPI_CPUFREQ_PROC_INTF */
-
-
-int 
-acpi_processor_register_performance (
-	struct acpi_processor_performance * performance,
-	unsigned int cpu)
-{
-	struct acpi_processor *pr;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_register_performance");
-
-	if (!(acpi_processor_ppc_status & PPC_REGISTERED))
-		return_VALUE(-EINVAL);
-
-	down(&performance_sem);
-
-	pr = processors[cpu];
-	if (!pr) {
-		up(&performance_sem);
-		return_VALUE(-ENODEV);
-	}
-
-	if (pr->performance) {
-		up(&performance_sem);
-		return_VALUE(-EBUSY);
-	}
-
-	pr->performance = performance;
-
-	if (acpi_processor_get_performance_info(pr)) {
-		pr->performance = NULL;
-		up(&performance_sem);
-		return_VALUE(-EIO);
-	}
-
-	acpi_cpufreq_add_file(pr);
-
-	up(&performance_sem);
-	return_VALUE(0);
-}
-EXPORT_SYMBOL(acpi_processor_register_performance);
-
-
-void 
-acpi_processor_unregister_performance (
-	struct acpi_processor_performance * performance,
-	unsigned int cpu)
-{
-	struct acpi_processor *pr;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_unregister_performance");
-
-	down(&performance_sem);
-
-	pr = processors[cpu];
-	if (!pr) {
-		up(&performance_sem);
-		return_VOID;
-	}
-
-	kfree(pr->performance->states);
-	pr->performance = NULL;
-
-	acpi_cpufreq_remove_file(pr);
-
-	up(&performance_sem);
-
-	return_VOID;
-}
-EXPORT_SYMBOL(acpi_processor_unregister_performance);
-
-
-/* for the rest of it, check arch/i386/kernel/cpu/cpufreq/acpi.c */
-
-#else  /* !CONFIG_CPU_FREQ */
-
-static void acpi_processor_ppc_init(void) { return; }
-static void acpi_processor_ppc_exit(void) { return; }
-
-static int acpi_processor_ppc_has_changed(struct acpi_processor *pr) {
-	static unsigned int printout = 1;
-	if (printout) {
-		printk(KERN_WARNING "Warning: Processor Platform Limit event detected, but not handled.\n");
-		printk(KERN_WARNING "Consider compiling CPUfreq support into your kernel.\n");
-		printout = 0;
-	}
-	return 0;
-}
-
-#endif /* CONFIG_CPU_FREQ */
-
-/* --------------------------------------------------------------------------
-                              Throttling Control
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_processor_get_throttling (
-	struct acpi_processor	*pr)
-{
-	int			state = 0;
-	u32			value = 0;
-	u32			duty_mask = 0;
-	u32			duty_value = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if (!pr->flags.throttling)
-		return_VALUE(-ENODEV);
-
-	pr->throttling.state = 0;
-
-	local_irq_disable();
-
-	duty_mask = pr->throttling.state_count - 1;
-
-	duty_mask <<= pr->throttling.duty_offset;
-
-	value = inl(pr->throttling.address);
-
-	/*
-	 * Compute the current throttling state when throttling is enabled
-	 * (bit 4 is on).
-	 */
-	if (value & 0x10) {
-		duty_value = value & duty_mask;
-		duty_value >>= pr->throttling.duty_offset;
-
-		if (duty_value)
-			state = pr->throttling.state_count-duty_value;
-	}
-
-	pr->throttling.state = state;
-
-	local_irq_enable();
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Throttling state is T%d (%d%% throttling applied)\n",
-		state, pr->throttling.states[state].performance));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_processor_set_throttling (
-	struct acpi_processor	*pr,
-	int			state)
-{
-	u32                     value = 0;
-	u32                     duty_mask = 0;
-	u32                     duty_value = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_set_throttling");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if ((state < 0) || (state > (pr->throttling.state_count - 1)))
-		return_VALUE(-EINVAL);
-
-	if (!pr->flags.throttling)
-		return_VALUE(-ENODEV);
-
-	if (state == pr->throttling.state)
-		return_VALUE(0);
-
-	local_irq_disable();
-
-	/*
-	 * Calculate the duty_value and duty_mask.
-	 */
-	if (state) {
-		duty_value = pr->throttling.state_count - state;
-
-		duty_value <<= pr->throttling.duty_offset;
-
-		/* Used to clear all duty_value bits */
-		duty_mask = pr->throttling.state_count - 1;
-
-		duty_mask <<= acpi_fadt.duty_offset;
-		duty_mask = ~duty_mask;
-	}
-
-	/*
-	 * Disable throttling by writing a 0 to bit 4.  Note that we must
-	 * turn it off before you can change the duty_value.
-	 */
-	value = inl(pr->throttling.address);
-	if (value & 0x10) {
-		value &= 0xFFFFFFEF;
-		outl(value, pr->throttling.address);
-	}
-
-	/*
-	 * Write the new duty_value and then enable throttling.  Note
-	 * that a state value of 0 leaves throttling disabled.
-	 */
-	if (state) {
-		value &= duty_mask;
-		value |= duty_value;
-		outl(value, pr->throttling.address);
-
-		value |= 0x00000010;
-		outl(value, pr->throttling.address);
-	}
-
-	pr->throttling.state = state;
-
-	local_irq_enable();
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Throttling state set to T%d (%d%%)\n", state, 
-		(pr->throttling.states[state].performance?pr->throttling.states[state].performance/10:0)));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_processor_get_throttling_info (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-	int			step = 0;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling_info");
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-		"pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\n",
-		pr->throttling.address,
-		pr->throttling.duty_offset,
-		pr->throttling.duty_width));
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	/* TBD: Support ACPI 2.0 objects */
-
-	if (!pr->throttling.address) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling register\n"));
-		return_VALUE(0);
-	}
-	else if (!pr->throttling.duty_width) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling states\n"));
-		return_VALUE(0);
-	}
-	/* TBD: Support duty_cycle values that span bit 4. */
-	else if ((pr->throttling.duty_offset
-		+ pr->throttling.duty_width) > 4) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "duty_cycle spans bit 4\n"));
-		return_VALUE(0);
-	}
-
-	/*
-	 * PIIX4 Errata: We don't support throttling on the original PIIX4.
-	 * This shouldn't be an issue as few (if any) mobile systems ever
-	 * used this part.
-	 */
-	if (errata.piix4.throttle) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Throttling not supported on PIIX4 A- or B-step\n"));
-		return_VALUE(0);
-	}
-
-	pr->throttling.state_count = 1 << acpi_fadt.duty_width;
-
-	/*
-	 * Compute state values. Note that throttling displays a linear power/
-	 * performance relationship (at 50% performance the CPU will consume
-	 * 50% power).  Values are in 1/10th of a percent to preserve accuracy.
-	 */
-
-	step = (1000 / pr->throttling.state_count);
-
-	for (i=0; i<pr->throttling.state_count; i++) {
-		pr->throttling.states[i].performance = step * i;
-		pr->throttling.states[i].power = step * i;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d throttling states\n", 
-		pr->throttling.state_count));
-
-	pr->flags.throttling = 1;
-
-	/*
-	 * Disable throttling (if enabled).  We'll let subsequent policy (e.g. 
-	 * thermal) decide to lower performance if it so chooses, but for now 
-	 * we'll crank up the speed.
-	 */
-
-	result = acpi_processor_get_throttling(pr);
-	if (result)
-		goto end;
-
-	if (pr->throttling.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Disabling throttling (was T%d)\n", 
-			pr->throttling.state));
-		result = acpi_processor_set_throttling(pr, 0);
-		if (result)
-			goto end;
-	}
-
-end:
-	if (result)
-		pr->flags.throttling = 0;
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Limit Interface
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_processor_apply_limit (
-	struct acpi_processor* 	pr)
-{
-	int			result = 0;
-	u16			px = 0;
-	u16			tx = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_apply_limit");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if (!pr->flags.limit)
-		return_VALUE(-ENODEV);
-
-	if (pr->flags.throttling) {
-		if (pr->limit.user.tx > tx)
-			tx = pr->limit.user.tx;
-		if (pr->limit.thermal.tx > tx)
-			tx = pr->limit.thermal.tx;
-
-		result = acpi_processor_set_throttling(pr, tx);
-		if (result)
-			goto end;
-	}
-
-	pr->limit.state.px = px;
-	pr->limit.state.tx = tx;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d] limit set to (P%d:T%d)\n",
-		pr->id,
-		pr->limit.state.px,
-		pr->limit.state.tx));
-
-end:
-	if (result)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to set limit\n"));
-
-	return_VALUE(result);
-}
-
-
-#ifdef CONFIG_CPU_FREQ
-
-/* If a passive cooling situation is detected, primarily CPUfreq is used, as it
- * offers (in most cases) voltage scaling in addition to frequency scaling, and
- * thus a cubic (instead of linear) reduction of energy. Also, we allow for
- * _any_ cpufreq driver and not only the acpi-cpufreq driver.
- */
-
-static unsigned int cpufreq_thermal_reduction_pctg[NR_CPUS];
-static unsigned int acpi_thermal_cpufreq_is_init = 0;
-
-
-static int cpu_has_cpufreq(unsigned int cpu)
-{
-	struct cpufreq_policy policy;
-	if (!acpi_thermal_cpufreq_is_init)
-		return -ENODEV;
-	if (!cpufreq_get_policy(&policy, cpu))
-		return -ENODEV;
-	return 0;
-}
-
-
-static int acpi_thermal_cpufreq_increase(unsigned int cpu)
-{
-	if (!cpu_has_cpufreq(cpu))
-		return -ENODEV;
-
-	if (cpufreq_thermal_reduction_pctg[cpu] < 60) {
-		cpufreq_thermal_reduction_pctg[cpu] += 20;
-		cpufreq_update_policy(cpu);
-		return 0;
-	}
-
-	return -ERANGE;
-}
-
-
-static int acpi_thermal_cpufreq_decrease(unsigned int cpu)
-{
-	if (!cpu_has_cpufreq(cpu))
-		return -ENODEV;
-
-	if (cpufreq_thermal_reduction_pctg[cpu] >= 20) {
-		cpufreq_thermal_reduction_pctg[cpu] -= 20;
-		cpufreq_update_policy(cpu);
-		return 0;
-	}
-
-	return -ERANGE;
-}
-
-
-static int acpi_thermal_cpufreq_notifier(
-	struct notifier_block *nb,
-	unsigned long event,
-	void *data)
-{
-	struct cpufreq_policy *policy = data;
-	unsigned long max_freq = 0;
-
-	if (event != CPUFREQ_ADJUST)
-		goto out;
-
-	max_freq = (policy->cpuinfo.max_freq * (100 - cpufreq_thermal_reduction_pctg[policy->cpu])) / 100;
-
-	cpufreq_verify_within_limits(policy, 0, max_freq);
-
- out:
-	return 0;
-}
-
-
-static struct notifier_block acpi_thermal_cpufreq_notifier_block = {
-	.notifier_call = acpi_thermal_cpufreq_notifier,
-};
-
-
-static void acpi_thermal_cpufreq_init(void) {
-	int i;
-
-	for (i=0; i<NR_CPUS; i++)
-		cpufreq_thermal_reduction_pctg[i] = 0;
-
-	i = cpufreq_register_notifier(&acpi_thermal_cpufreq_notifier_block, CPUFREQ_POLICY_NOTIFIER);
-	if (!i)
-		acpi_thermal_cpufreq_is_init = 1;
-}
-
-static void acpi_thermal_cpufreq_exit(void) {
-	if (acpi_thermal_cpufreq_is_init)
-		cpufreq_unregister_notifier(&acpi_thermal_cpufreq_notifier_block, CPUFREQ_POLICY_NOTIFIER);
-
-	acpi_thermal_cpufreq_is_init = 0;
-}
-
-#else /* ! CONFIG_CPU_FREQ */
-
-static void acpi_thermal_cpufreq_init(void) { return; }
-static void acpi_thermal_cpufreq_exit(void) { return; }
-static int acpi_thermal_cpufreq_increase(unsigned int cpu) { return -ENODEV; }
-static int acpi_thermal_cpufreq_decrease(unsigned int cpu) { return -ENODEV; }
-
-
-#endif
-
-
-int
-acpi_processor_set_thermal_limit (
-	acpi_handle		handle,
-	int			type)
-{
-	int			result = 0;
-	struct acpi_processor	*pr = NULL;
-	struct acpi_device	*device = NULL;
-	int			tx = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_set_thermal_limit");
-
-	if ((type < ACPI_PROCESSOR_LIMIT_NONE) 
-		|| (type > ACPI_PROCESSOR_LIMIT_DECREMENT))
-		return_VALUE(-EINVAL);
-
-	result = acpi_bus_get_device(handle, &device);
-	if (result)
-		return_VALUE(result);
-
-	pr = (struct acpi_processor *) acpi_driver_data(device);
-	if (!pr)
-		return_VALUE(-ENODEV);
-
-	/* Thermal limits are always relative to the current Px/Tx state. */
-	if (pr->flags.throttling)
-		pr->limit.thermal.tx = pr->throttling.state;
-
-	/*
-	 * Our default policy is to only use throttling at the lowest
-	 * performance state.
-	 */
-
-	tx = pr->limit.thermal.tx;
-
-	switch (type) {
-
-	case ACPI_PROCESSOR_LIMIT_NONE:
-		do {
-			result = acpi_thermal_cpufreq_decrease(pr->id);
-		} while (!result);
-		tx = 0;
-		break;
-
-	case ACPI_PROCESSOR_LIMIT_INCREMENT:
-		/* if going up: P-states first, T-states later */
-
-		result = acpi_thermal_cpufreq_increase(pr->id);
-		if (!result)
-			goto end;
-		else if (result == -ERANGE)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"At maximum performance state\n"));
-
-		if (pr->flags.throttling) {
-			if (tx == (pr->throttling.state_count - 1))
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"At maximum throttling state\n"));
-			else
-				tx++;
-		}
-		break;
-
-	case ACPI_PROCESSOR_LIMIT_DECREMENT:
-		/* if going down: T-states first, P-states later */
-
-		if (pr->flags.throttling) {
-			if (tx == 0)
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"At minimum throttling state\n"));
-			else {
-				tx--;
-				goto end;
-			}
-		}
-
-		result = acpi_thermal_cpufreq_decrease(pr->id);
-		if (result == -ERANGE)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"At minimum performance state\n"));
-
-		break;
-	}
-
-end:
-	if (pr->flags.throttling) {
-		pr->limit.thermal.px = 0;
-		pr->limit.thermal.tx = tx;
-
-		result = acpi_processor_apply_limit(pr);
-		if (result)
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-					  "Unable to set thermal limit\n"));
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Thermal limit now (P%d:T%d)\n",
-				  pr->limit.thermal.px,
-				  pr->limit.thermal.tx));
-	} else
-		result = 0;
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_processor_get_limit_info (
-	struct acpi_processor	*pr)
-{
-	ACPI_FUNCTION_TRACE("acpi_processor_get_limit_info");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if (pr->flags.throttling)
-		pr->flags.limit = 1;
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-struct proc_dir_entry		*acpi_processor_dir = NULL;
-
-static int acpi_processor_info_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_info_seq_show");
-
-	if (!pr)
-		goto end;
-
-	seq_printf(seq, "processor id:            %d\n"
-			"acpi id:                 %d\n"
-			"bus mastering control:   %s\n"
-			"power management:        %s\n"
-			"throttling control:      %s\n"
-			"limit interface:         %s\n",
-			pr->id,
-			pr->acpi_id,
-			pr->flags.bm_control ? "yes" : "no",
-			pr->flags.power ? "yes" : "no",
-			pr->flags.throttling ? "yes" : "no",
-			pr->flags.limit ? "yes" : "no");
-
-end:
-	return_VALUE(0);
-}
-
-static int acpi_processor_info_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_processor_info_seq_show,
-						PDE(inode)->data);
-}
-
-static int acpi_processor_power_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
-	unsigned int		i;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_power_seq_show");
-
-	if (!pr)
-		goto end;
-
-	seq_printf(seq, "active state:            C%d\n"
-			"default state:           C%d\n"
-			"max_cstate:              C%d\n"
-			"bus master activity:     %08x\n",
-			pr->power.state,
-			pr->power.default_state,
-			max_cstate,
-			pr->power.bm_activity);
-
-	seq_puts(seq, "states:\n");
-
-	for (i = 1; i < ACPI_C_STATE_COUNT; i++) {
-		seq_printf(seq, "   %cC%d:                  ", 
-			(i == pr->power.state?'*':' '), i);
-
-		if (!pr->power.states[i].valid) {
-			seq_puts(seq, "<not supported>\n");
-			continue;
-		}
-
-		if (pr->power.states[i].promotion.state)
-			seq_printf(seq, "promotion[C%d] ",
-				pr->power.states[i].promotion.state);
-		else
-			seq_puts(seq, "promotion[--] ");
-
-		if (pr->power.states[i].demotion.state)
-			seq_printf(seq, "demotion[C%d] ",
-				pr->power.states[i].demotion.state);
-		else
-			seq_puts(seq, "demotion[--] ");
-
-		seq_printf(seq, "latency[%03d] usage[%08d]\n",
-			pr->power.states[i].latency,
-			pr->power.states[i].usage);
-	}
-
-end:
-	return_VALUE(0);
-}
-
-static int acpi_processor_power_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_processor_power_seq_show,
-						PDE(inode)->data);
-}
-
-static int acpi_processor_throttling_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
-	int			i = 0;
-	int                     result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_throttling_seq_show");
-
-	if (!pr)
-		goto end;
-
-	if (!(pr->throttling.state_count > 0)) {
-		seq_puts(seq, "<not supported>\n");
-		goto end;
-	}
-
-	result = acpi_processor_get_throttling(pr);
-
-	if (result) {
-		seq_puts(seq, "Could not determine current throttling state.\n");
-		goto end;
-	}
-
-	seq_printf(seq, "state count:             %d\n"
-			"active state:            T%d\n",
-			pr->throttling.state_count,
-			pr->throttling.state);
-
-	seq_puts(seq, "states:\n");
-	for (i = 0; i < pr->throttling.state_count; i++)
-		seq_printf(seq, "   %cT%d:                  %02d%%\n",
-			(i == pr->throttling.state?'*':' '), i,
-			(pr->throttling.states[i].performance?pr->throttling.states[i].performance/10:0));
-
-end:
-	return_VALUE(0);
-}
-
-static int acpi_processor_throttling_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_processor_throttling_seq_show,
-						PDE(inode)->data);
-}
-
-static ssize_t
-acpi_processor_write_throttling (
-        struct file		*file,
-        const char		__user *buffer,
-        size_t			count,
-        loff_t			*data)
-{
-	int			result = 0;
-        struct seq_file 	*m = (struct seq_file *)file->private_data;
-	struct acpi_processor	*pr = (struct acpi_processor *)m->private;
-	char			state_string[12] = {'\0'};
-
-	ACPI_FUNCTION_TRACE("acpi_processor_write_throttling");
-
-	if (!pr || (count > sizeof(state_string) - 1))
-		return_VALUE(-EINVAL);
-	
-	if (copy_from_user(state_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	state_string[count] = '\0';
-	
-	result = acpi_processor_set_throttling(pr, 
-		simple_strtoul(state_string, NULL, 0));
-	if (result)
-		return_VALUE(result);
-
-	return_VALUE(count);
-}
-
-static int acpi_processor_limit_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_limit_seq_show");
-
-	if (!pr)
-		goto end;
-
-	if (!pr->flags.limit) {
-		seq_puts(seq, "<not supported>\n");
-		goto end;
-	}
-
-	seq_printf(seq, "active limit:            P%d:T%d\n"
-			"user limit:              P%d:T%d\n"
-			"thermal limit:           P%d:T%d\n",
-			pr->limit.state.px, pr->limit.state.tx,
-			pr->limit.user.px, pr->limit.user.tx,
-			pr->limit.thermal.px, pr->limit.thermal.tx);
-
-end:
-	return_VALUE(0);
-}
-
-static int acpi_processor_limit_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_processor_limit_seq_show,
-						PDE(inode)->data);
-}
-
-static ssize_t
-acpi_processor_write_limit (
-	struct file		*file,
-	const char		__user *buffer,
-	size_t			count,
-	loff_t			*data)
-{
-	int			result = 0;
-        struct seq_file 	*m = (struct seq_file *)file->private_data;
-	struct acpi_processor	*pr = (struct acpi_processor *)m->private;
-	char			limit_string[25] = {'\0'};
-	int			px = 0;
-	int			tx = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_write_limit");
-
-	if (!pr || (count > sizeof(limit_string) - 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
-		return_VALUE(-EINVAL);
-	}
-	
-	if (copy_from_user(limit_string, buffer, count)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
-		return_VALUE(-EFAULT);
-	}
-	
-	limit_string[count] = '\0';
-
-	if (sscanf(limit_string, "%d:%d", &px, &tx) != 2) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
-		return_VALUE(-EINVAL);
-	}
-
-	if (pr->flags.throttling) {
-		if ((tx < 0) || (tx > (pr->throttling.state_count - 1))) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid tx\n"));
-			return_VALUE(-EINVAL);
-		}
-		pr->limit.user.tx = tx;
-	}
-
-	result = acpi_processor_apply_limit(pr);
-
-	return_VALUE(count);
-}
-
-
-static int
-acpi_processor_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_add_fs");
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_processor_dir);
-		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
-	}
-	acpi_device_dir(device)->owner = THIS_MODULE;
-
-	/* 'info' [R] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_INFO,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_INFO));
-	else {
-		entry->proc_fops = &acpi_processor_info_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
-	/* 'power' [R] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_POWER,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_POWER));
-	else {
-		entry->proc_fops = &acpi_processor_power_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
-	/* 'throttling' [R/W] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_THROTTLING,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_THROTTLING));
-	else {
-		entry->proc_fops = &acpi_processor_throttling_fops;
-		entry->proc_fops->write = acpi_processor_write_throttling;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
-	/* 'limit' [R/W] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_LIMIT,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_LIMIT));
-	else {
-		entry->proc_fops = &acpi_processor_limit_fops;
-		entry->proc_fops->write = acpi_processor_write_limit;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_processor_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_processor_remove_fs");
-
-	if (acpi_device_dir(device)) {
-		remove_proc_entry(ACPI_PROCESSOR_FILE_INFO,acpi_device_dir(device));
-		remove_proc_entry(ACPI_PROCESSOR_FILE_POWER,acpi_device_dir(device));
-		remove_proc_entry(ACPI_PROCESSOR_FILE_THROTTLING,
-			acpi_device_dir(device));
-		remove_proc_entry(ACPI_PROCESSOR_FILE_LIMIT,acpi_device_dir(device));
-		remove_proc_entry(acpi_device_bid(device), acpi_processor_dir);
-		acpi_device_dir(device) = NULL;
-	}
-
-	return_VALUE(0);
-}
-
-/* Use the acpiid in MADT to map cpus in case of SMP */
-#ifndef CONFIG_SMP
-#define convert_acpiid_to_cpu(acpi_id) (0xff)
-#else
-
-#ifdef CONFIG_IA64
-#define arch_acpiid_to_apicid 	ia64_acpiid_to_sapicid
-#define arch_cpu_to_apicid 	ia64_cpu_to_sapicid
-#define ARCH_BAD_APICID		(0xffff)
-#else
-#define arch_acpiid_to_apicid 	x86_acpiid_to_apicid
-#define arch_cpu_to_apicid 	x86_cpu_to_apicid
-#define ARCH_BAD_APICID		(0xff)
-#endif
-
-static u8 convert_acpiid_to_cpu(u8 acpi_id)
-{
-	u16 apic_id;
-	int i;
-	
-	apic_id = arch_acpiid_to_apicid[acpi_id];
-	if (apic_id == ARCH_BAD_APICID)
-		return -1;
-
-	for (i = 0; i < NR_CPUS; i++) {
-		if (arch_cpu_to_apicid[i] == apic_id)
-			return i;
-	}
-	return -1;
-}
-#endif
-
-/* --------------------------------------------------------------------------
-                                 Driver Interface
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_processor_get_info (
-	struct acpi_processor	*pr)
-{
-	acpi_status		status = 0;
-	union acpi_object	object = {0};
-	struct acpi_buffer	buffer = {sizeof(union acpi_object), &object};
-	u8			cpu_index;
-	static int		cpu0_initialized;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_info");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if (num_online_cpus() > 1)
-		errata.smp = TRUE;
-
-	acpi_processor_errata(pr);
-
-	/*
-	 * Check to see if we have bus mastering arbitration control.  This
-	 * is required for proper C3 usage (to maintain cache coherency).
-	 */
-	if (acpi_fadt.V1_pm2_cnt_blk && acpi_fadt.pm2_cnt_len) {
-		pr->flags.bm_control = 1;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Bus mastering arbitration control present\n"));
-	}
-	else
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"No bus mastering arbitration control\n"));
-
-	/*
-	 * Evalute the processor object.  Note that it is common on SMP to
-	 * have the first (boot) processor with a valid PBLK address while
-	 * all others have a NULL address.
-	 */
-	status = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error evaluating processor object\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	/*
-	 * TBD: Synch processor ID (via LAPIC/LSAPIC structures) on SMP.
-	 *	>>> 'acpi_get_processor_id(acpi_id, &id)' in arch/xxx/acpi.c
-	 */
-	pr->acpi_id = object.processor.proc_id;
-
-	cpu_index = convert_acpiid_to_cpu(pr->acpi_id);
-
-	if ( !cpu0_initialized && (cpu_index == 0xff)) {
-		/* Handle UP system running SMP kernel, with no LAPIC in MADT */
-		cpu_index = 0;
-	} else if (cpu_index > num_online_cpus()) {
-		/*
-		 *  Extra Processor objects may be enumerated on MP systems with
-		 *  less than the max # of CPUs. They should be ignored.
-		 */
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error getting cpuindex for acpiid 0x%x\n",
-			pr->acpi_id));
-		return_VALUE(-ENODEV);
-	}
-	cpu0_initialized = 1;
-
-	pr->id = cpu_index;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d:%d]\n", pr->id, 
-		pr->acpi_id));
-
-	if (!object.processor.pblk_address)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No PBLK (NULL address)\n"));
-	else if (object.processor.pblk_length != 6)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid PBLK length [%d]\n",
-			object.processor.pblk_length));
-	else {
-		pr->throttling.address = object.processor.pblk_address;
-		pr->throttling.duty_offset = acpi_fadt.duty_offset;
-		pr->throttling.duty_width = acpi_fadt.duty_width;
-		pr->power.states[ACPI_STATE_C2].address =
-			object.processor.pblk_address + 4;
-		pr->power.states[ACPI_STATE_C3].address =
-			object.processor.pblk_address + 5;
-
-		/*
-		 * We don't care about error returns - we just try to mark
-		 * these reserved so that nobody else is confused into thinking
-		 * that this region might be unused..
-		 *
-		 * (In particular, allocating the IO range for Cardbus)
-		 */
-		request_region(pr->throttling.address, 6, "ACPI CPU throttle");
-	}
-
-	acpi_processor_get_power_info(pr);
-#ifdef CONFIG_CPU_FREQ
-	acpi_processor_ppc_has_changed(pr);
-#endif
-	acpi_processor_get_throttling_info(pr);
-	acpi_processor_get_limit_info(pr);
-
-	return_VALUE(0);
-}
-
-
-static void
-acpi_processor_notify (
-	acpi_handle		handle,
-	u32			event,
-	void			*data)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_notify");
-
-	if (!pr)
-		return_VOID;
-
-	if (acpi_bus_get_device(pr->handle, &device))
-		return_VOID;
-
-	switch (event) {
-	case ACPI_PROCESSOR_NOTIFY_PERFORMANCE:
-		acpi_processor_ppc_has_changed(pr);
-		acpi_bus_generate_event(device, event, 
-			pr->performance_platform_limit);
-		break;
-	case ACPI_PROCESSOR_NOTIFY_POWER:
-		/* TBD */
-		acpi_bus_generate_event(device, event, 0);
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Unsupported event [0x%x]\n", event));
-		break;
-	}
-
-	return_VOID;
-}
-
-
-static int
-acpi_processor_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_processor	*pr = NULL;
-	u32			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	pr = kmalloc(sizeof(struct acpi_processor), GFP_KERNEL);
-	if (!pr)
-		return_VALUE(-ENOMEM);
-	memset(pr, 0, sizeof(struct acpi_processor));
-
-	pr->handle = device->handle;
-	strcpy(acpi_device_name(device), ACPI_PROCESSOR_DEVICE_NAME);
-	strcpy(acpi_device_class(device), ACPI_PROCESSOR_CLASS);
-	acpi_driver_data(device) = pr;
-
-	result = acpi_processor_get_info(pr);
-	if (result)
-		goto end;
-
-	result = acpi_processor_add_fs(device);
-	if (result)
-		goto end;
-
-	status = acpi_install_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY, 
-		acpi_processor_notify, pr);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Error installing notify handler\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	processors[pr->id] = pr;
-
-	/*
-	 * Install the idle handler if processor power management is supported.
-	 * Note that we use previously set idle handler will be used on 
-	 * platforms that only support C1.
-	 */
-	if ((pr->flags.power) && (!boot_option_idle_override)) {
-		printk(KERN_INFO PREFIX "%s [%s] (supports",
-			acpi_device_name(device), acpi_device_bid(device));
-		for (i = 1; i < ACPI_C_STATE_COUNT; i++)
-			if (pr->power.states[i].valid)
-				printk(" C%d", i);
-		printk(")\n");
-		if (pr->id == 0) {
-			pm_idle_save = pm_idle;
-			pm_idle = acpi_processor_idle;
-		}
-	}
-	
-	if (pr->flags.throttling) {
-		printk(KERN_INFO PREFIX "%s [%s] (supports",
-			acpi_device_name(device), acpi_device_bid(device));
-		printk(" %d throttling states", pr->throttling.state_count);
-		printk(")\n");
-	}
-
-end:
-	if (result) {
-		acpi_processor_remove_fs(device);
-		kfree(pr);
-	}
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_processor_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	acpi_status		status = AE_OK;
-	struct acpi_processor	*pr = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	pr = (struct acpi_processor *) acpi_driver_data(device);
-
-	/* Unregister the idle handler when processor #0 is removed. */
-	if (pr->id == 0) {
-		pm_idle = pm_idle_save;
-		/*
-		 * We are about to unload the current idle thread pm callback
-		 * (pm_idle), Wait for all processors to update cached/local
-		 * copies of pm_idle before proceeding.
-		 */
-		synchronize_kernel();
-	}
-
-	status = acpi_remove_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY, 
-		acpi_processor_notify);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Error removing notify handler\n"));
-	}
-
-	acpi_processor_remove_fs(device);
-
-	processors[pr->id] = NULL;
-
-	kfree(pr);
-
-	return_VALUE(0);
-}
-
-/*
- * IBM ThinkPad R40e crashes mysteriously when going into C2 or C3. 
- * For now disable this. Probably a bug somewhere else.
- *
- * To skip this limit, boot/load with a large max_cstate limit.
- */
-static int no_c2c3(struct dmi_system_id *id)
-{
-	if (max_cstate > ACPI_C_STATES_MAX)
-		return 0;
-
-	printk(KERN_NOTICE PREFIX "%s detected - C2,C3 disabled."
-		" Override with \"processor.max_cstate=9\"\n", id->ident);
-
-	max_cstate = 1;
-
-	return 0;
-}
-
-static struct dmi_system_id __initdata processor_dmi_table[] = { 
-	{ no_c2c3, "IBM ThinkPad R40e", {
-	  DMI_MATCH(DMI_BIOS_VENDOR,"IBM"),
-	  DMI_MATCH(DMI_BIOS_VERSION,"1SET60WW") }},
-	{ no_c2c3, "Medion 41700", {
-	  DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
-	  DMI_MATCH(DMI_BIOS_VERSION,"R01-A1J") }},
-	{},
-};
-
-/* We keep the driver loaded even when ACPI is not running. 
-   This is needed for the powernow-k8 driver, that works even without
-   ACPI, but needs symbols from this driver */
-
-static int __init
-acpi_processor_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_init");
-
-	memset(&processors, 0, sizeof(processors));
-	memset(&errata, 0, sizeof(errata));
-
-	acpi_processor_dir = proc_mkdir(ACPI_PROCESSOR_CLASS, acpi_root_dir);
-	if (!acpi_processor_dir)
-		return_VALUE(0);
-	acpi_processor_dir->owner = THIS_MODULE;
-
-	result = acpi_bus_register_driver(&acpi_processor_driver);
-	if (result < 0) {
-		remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
-		return_VALUE(0);
-	}
-
-	acpi_thermal_cpufreq_init();
-
-	acpi_processor_ppc_init();
-
-	dmi_check_system(processor_dmi_table); 
-
-	if (max_cstate < ACPI_C_STATES_MAX)
-		printk(KERN_NOTICE "ACPI: processor limited to max C-state %d\n", max_cstate);
-
-	return_VALUE(0);
-}
-
-
-static void __exit
-acpi_processor_exit (void)
-{
-	ACPI_FUNCTION_TRACE("acpi_processor_exit");
-
-	acpi_processor_ppc_exit();
-
-	acpi_thermal_cpufreq_exit();
-
-	acpi_bus_unregister_driver(&acpi_processor_driver);
-
-	remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
-
-	return_VOID;
-}
-
-
-module_init(acpi_processor_init);
-module_exit(acpi_processor_exit);
-module_param_named(max_cstate, max_cstate, uint, 0);
-
-EXPORT_SYMBOL(acpi_processor_set_thermal_limit);
diff -Nru a/drivers/acpi/processor_core.c b/drivers/acpi/processor_core.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/acpi/processor_core.c	2005-01-06 15:06:41 -05:00
@@ -0,0 +1,989 @@
+/*
+ * acpi_processor.c - ACPI Processor Driver ($Revision$)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>
+ *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
+ *  			- Added processor hotplug support
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  TBD:
+ *	1. Make # power states dynamic.
+ *	2. Support duty_cycle values that span bit 4.
+ *	3. Optimize by having scheduler determine business instead of
+ *	   having us try to calculate it here.
+ *	4. Need C1 timing -- must modify kernel (IRQ handler) to get this.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/dmi.h>
+#include <linux/moduleparam.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/cpu.h>
+#include <asm/delay.h>
+#include <asm/uaccess.h>
+#include <asm/processor.h>
+#include <asm/smp.h>
+#include <asm/acpi.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/processor.h>
+
+
+#define ACPI_PROCESSOR_COMPONENT	0x01000000
+#define ACPI_PROCESSOR_CLASS		"processor"
+#define ACPI_PROCESSOR_DRIVER_NAME	"ACPI Processor Driver"
+#define ACPI_PROCESSOR_DEVICE_NAME	"Processor"
+#define ACPI_PROCESSOR_FILE_INFO	"info"
+#define ACPI_PROCESSOR_FILE_THROTTLING	"throttling"
+#define ACPI_PROCESSOR_FILE_LIMIT	"limit"
+#define ACPI_PROCESSOR_NOTIFY_PERFORMANCE 0x80
+#define ACPI_PROCESSOR_NOTIFY_POWER	0x81
+
+#define ACPI_PROCESSOR_LIMIT_USER	0
+#define ACPI_PROCESSOR_LIMIT_THERMAL	1
+
+#define ACPI_STA_PRESENT 0x00000001
+
+#define _COMPONENT		ACPI_PROCESSOR_COMPONENT
+ACPI_MODULE_NAME		("acpi_processor")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_PROCESSOR_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+
+static int acpi_processor_add (struct acpi_device *device);
+static int acpi_processor_start (struct acpi_device *device);
+static int acpi_processor_remove (struct acpi_device *device, int type);
+static int acpi_processor_info_open_fs(struct inode *inode, struct file *file);
+static void acpi_processor_notify ( acpi_handle	handle, u32 event, void *data);
+static acpi_status acpi_processor_hotadd_init(acpi_handle handle, int *p_cpu);
+static int acpi_processor_handle_eject(struct acpi_processor *pr);
+
+static struct acpi_driver acpi_processor_driver = {
+	.name =		ACPI_PROCESSOR_DRIVER_NAME,
+	.class =	ACPI_PROCESSOR_CLASS,
+	.ids =		ACPI_PROCESSOR_HID,
+	.ops =		{
+				.add =		acpi_processor_add,
+				.remove =	acpi_processor_remove,
+				.start	= 	acpi_processor_start,
+			},
+};
+
+#define INSTALL_NOTIFY_HANDLER		1
+#define UNINSTALL_NOTIFY_HANDLER	2
+
+
+struct file_operations acpi_processor_info_fops = {
+	.open 		= acpi_processor_info_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+
+struct acpi_processor	*processors[NR_CPUS];
+struct acpi_processor_errata errata;
+
+
+/* --------------------------------------------------------------------------
+                                Errata Handling
+   -------------------------------------------------------------------------- */
+
+int
+acpi_processor_errata_piix4 (
+	struct pci_dev		*dev)
+{
+	u8			rev = 0;
+	u8			value1 = 0;
+	u8			value2 = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_errata_piix4");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * Note that 'dev' references the PIIX4 ACPI Controller.
+	 */
+
+	pci_read_config_byte(dev, PCI_REVISION_ID, &rev);
+
+	switch (rev) {
+	case 0:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 A-step\n"));
+		break;
+	case 1:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 B-step\n"));
+		break;
+	case 2:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4E\n"));
+		break;
+	case 3:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4M\n"));
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unknown PIIX4\n"));
+		break;
+	}
+
+	switch (rev) {
+
+	case 0:		/* PIIX4 A-step */
+	case 1:		/* PIIX4 B-step */
+		/*
+		 * See specification changes #13 ("Manual Throttle Duty Cycle")
+		 * and #14 ("Enabling and Disabling Manual Throttle"), plus
+		 * erratum #5 ("STPCLK# Deassertion Time") from the January
+		 * 2002 PIIX4 specification update.  Applies to only older
+		 * PIIX4 models.
+		 */
+		errata.piix4.throttle = 1;
+
+	case 2:		/* PIIX4E */
+	case 3:		/* PIIX4M */
+		/*
+		 * See erratum #18 ("C3 Power State/BMIDE and Type-F DMA
+		 * Livelock") from the January 2002 PIIX4 specification update.
+		 * Applies to all PIIX4 models.
+		 */
+
+		/*
+		 * BM-IDE
+		 * ------
+		 * Find the PIIX4 IDE Controller and get the Bus Master IDE
+		 * Status register address.  We'll use this later to read
+		 * each IDE controller's DMA status to make sure we catch all
+		 * DMA activity.
+		 */
+		dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,
+		           PCI_DEVICE_ID_INTEL_82371AB,
+                           PCI_ANY_ID, PCI_ANY_ID, NULL);
+		if (dev) {
+			errata.piix4.bmisx = pci_resource_start(dev, 4);
+			pci_dev_put(dev);
+		}
+
+		/*
+		 * Type-F DMA
+		 * ----------
+		 * Find the PIIX4 ISA Controller and read the Motherboard
+		 * DMA controller's status to see if Type-F (Fast) DMA mode
+		 * is enabled (bit 7) on either channel.  Note that we'll
+		 * disable C3 support if this is enabled, as some legacy
+		 * devices won't operate well if fast DMA is disabled.
+		 */
+		dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,
+			PCI_DEVICE_ID_INTEL_82371AB_0,
+			PCI_ANY_ID, PCI_ANY_ID, NULL);
+		if (dev) {
+			pci_read_config_byte(dev, 0x76, &value1);
+			pci_read_config_byte(dev, 0x77, &value2);
+			if ((value1 & 0x80) || (value2 & 0x80))
+				errata.piix4.fdma = 1;
+			pci_dev_put(dev);
+		}
+
+		break;
+	}
+
+	if (errata.piix4.bmisx)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Bus master activity detection (BM-IDE) erratum enabled\n"));
+	if (errata.piix4.fdma)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Type-F DMA livelock erratum (C3 disabled)\n"));
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_processor_errata (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	struct pci_dev		*dev = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_errata");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * PIIX4
+	 */
+	dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,
+		PCI_DEVICE_ID_INTEL_82371AB_3, PCI_ANY_ID, PCI_ANY_ID, NULL);
+	if (dev) {
+		result = acpi_processor_errata_piix4(dev);
+		pci_dev_put(dev);
+	}
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+struct proc_dir_entry		*acpi_processor_dir = NULL;
+
+static int acpi_processor_info_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_info_seq_show");
+
+	if (!pr)
+		goto end;
+
+	seq_printf(seq, "processor id:            %d\n"
+			"acpi id:                 %d\n"
+			"bus mastering control:   %s\n"
+			"power management:        %s\n"
+			"throttling control:      %s\n"
+			"limit interface:         %s\n",
+			pr->id,
+			pr->acpi_id,
+			pr->flags.bm_control ? "yes" : "no",
+			pr->flags.power ? "yes" : "no",
+			pr->flags.throttling ? "yes" : "no",
+			pr->flags.limit ? "yes" : "no");
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_processor_info_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_processor_info_seq_show,
+						PDE(inode)->data);
+}
+
+
+static int
+acpi_processor_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_add_fs");
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_processor_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+	acpi_device_dir(device)->owner = THIS_MODULE;
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_INFO));
+	else {
+		entry->proc_fops = &acpi_processor_info_fops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	/* 'throttling' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_THROTTLING,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_THROTTLING));
+	else {
+		entry->proc_fops = &acpi_processor_throttling_fops;
+		entry->proc_fops->write = acpi_processor_write_throttling;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	/* 'limit' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_LIMIT,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_LIMIT));
+	else {
+		entry->proc_fops = &acpi_processor_limit_fops;
+		entry->proc_fops->write = acpi_processor_write_limit;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(ACPI_PROCESSOR_FILE_INFO,acpi_device_dir(device));
+		remove_proc_entry(ACPI_PROCESSOR_FILE_THROTTLING,
+			acpi_device_dir(device));
+		remove_proc_entry(ACPI_PROCESSOR_FILE_LIMIT,acpi_device_dir(device));
+		remove_proc_entry(acpi_device_bid(device), acpi_processor_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+/* Use the acpiid in MADT to map cpus in case of SMP */
+#ifndef CONFIG_SMP
+#define convert_acpiid_to_cpu(acpi_id) (0xff)
+#else
+
+#ifdef CONFIG_IA64
+#define arch_acpiid_to_apicid 	ia64_acpiid_to_sapicid
+#define arch_cpu_to_apicid 	ia64_cpu_to_sapicid
+#define ARCH_BAD_APICID		(0xffff)
+#else
+#define arch_acpiid_to_apicid 	x86_acpiid_to_apicid
+#define arch_cpu_to_apicid 	x86_cpu_to_apicid
+#define ARCH_BAD_APICID		(0xff)
+#endif
+
+static u8 convert_acpiid_to_cpu(u8 acpi_id)
+{
+	u16 apic_id;
+	int i;
+
+	apic_id = arch_acpiid_to_apicid[acpi_id];
+	if (apic_id == ARCH_BAD_APICID)
+		return -1;
+
+	for (i = 0; i < NR_CPUS; i++) {
+		if (arch_cpu_to_apicid[i] == apic_id)
+			return i;
+	}
+	return -1;
+}
+#endif
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_get_info (
+	struct acpi_processor	*pr)
+{
+	acpi_status		status = 0;
+	union acpi_object	object = {0};
+	struct acpi_buffer	buffer = {sizeof(union acpi_object), &object};
+	u8			cpu_index;
+	static int		cpu0_initialized;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (num_online_cpus() > 1)
+		errata.smp = TRUE;
+
+	acpi_processor_errata(pr);
+
+	/*
+	 * Check to see if we have bus mastering arbitration control.  This
+	 * is required for proper C3 usage (to maintain cache coherency).
+	 */
+	if (acpi_fadt.V1_pm2_cnt_blk && acpi_fadt.pm2_cnt_len) {
+		pr->flags.bm_control = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Bus mastering arbitration control present\n"));
+	}
+	else
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"No bus mastering arbitration control\n"));
+
+	/*
+	 * Evalute the processor object.  Note that it is common on SMP to
+	 * have the first (boot) processor with a valid PBLK address while
+	 * all others have a NULL address.
+	 */
+	status = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error evaluating processor object\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * TBD: Synch processor ID (via LAPIC/LSAPIC structures) on SMP.
+	 *	>>> 'acpi_get_processor_id(acpi_id, &id)' in arch/xxx/acpi.c
+	 */
+	pr->acpi_id = object.processor.proc_id;
+
+	cpu_index = convert_acpiid_to_cpu(pr->acpi_id);
+
+  	/* Handle UP system running SMP kernel, with no LAPIC in MADT */
+  	if ( !cpu0_initialized && (cpu_index == 0xff) &&
+  		       	(num_online_cpus() == 1)) {
+   		cpu_index = 0;
+   	}
+
+   	cpu0_initialized = 1;
+
+   	pr->id = cpu_index;
+
+  	/*
+  	 *  Extra Processor objects may be enumerated on MP systems with
+  	 *  less than the max # of CPUs. They should be ignored _iff
+  	 *  they are physically not present.
+  	 */
+   	if (cpu_index >=  NR_CPUS) {
+   		if (ACPI_FAILURE(acpi_processor_hotadd_init(pr->handle, &pr->id))) {
+   			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+   				"Error getting cpuindex for acpiid 0x%x\n",
+   				pr->acpi_id));
+   			return_VALUE(-ENODEV);
+   		}
+    	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d:%d]\n", pr->id,
+		pr->acpi_id));
+
+	if (!object.processor.pblk_address)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No PBLK (NULL address)\n"));
+	else if (object.processor.pblk_length != 6)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid PBLK length [%d]\n",
+			object.processor.pblk_length));
+	else {
+		pr->throttling.address = object.processor.pblk_address;
+		pr->throttling.duty_offset = acpi_fadt.duty_offset;
+		pr->throttling.duty_width = acpi_fadt.duty_width;
+
+		pr->pblk = object.processor.pblk_address;
+
+		/*
+		 * We don't care about error returns - we just try to mark
+		 * these reserved so that nobody else is confused into thinking
+		 * that this region might be unused..
+		 *
+		 * (In particular, allocating the IO range for Cardbus)
+		 */
+		request_region(pr->throttling.address, 6, "ACPI CPU throttle");
+	}
+
+#ifdef CONFIG_CPU_FREQ
+	acpi_processor_ppc_has_changed(pr);
+#endif
+	acpi_processor_get_throttling_info(pr);
+	acpi_processor_get_limit_info(pr);
+
+	return_VALUE(0);
+}
+
+static int
+acpi_processor_start(
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_processor	*pr;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_start");
+
+	pr = acpi_driver_data(device);
+
+	result = acpi_processor_get_info(pr);
+	if (result) {
+		/* Processor is physically not present */
+		return_VALUE(0);
+	}
+
+	BUG_ON((pr->id >= NR_CPUS) || (pr->id < 0));
+
+	processors[pr->id] = pr;
+
+	result = acpi_processor_add_fs(device);
+	if (result)
+		goto end;
+
+	status = acpi_install_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY,
+		acpi_processor_notify, pr);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing device notify handler\n"));
+	}
+
+	acpi_processor_power_init(pr, device);
+
+	if (pr->flags.throttling) {
+		printk(KERN_INFO PREFIX "%s [%s] (supports",
+			acpi_device_name(device), acpi_device_bid(device));
+		printk(" %d throttling states", pr->throttling.state_count);
+		printk(")\n");
+	}
+
+end:
+
+	return_VALUE(result);
+}
+
+
+
+static void
+acpi_processor_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_notify");
+
+	if (!pr)
+		return_VOID;
+
+	if (acpi_bus_get_device(pr->handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_PROCESSOR_NOTIFY_PERFORMANCE:
+		acpi_processor_ppc_has_changed(pr);
+		acpi_bus_generate_event(device, event,
+			pr->performance_platform_limit);
+		break;
+	case ACPI_PROCESSOR_NOTIFY_POWER:
+		acpi_processor_cst_has_changed(pr);
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_processor_add (
+	struct acpi_device	*device)
+{
+	struct acpi_processor	*pr = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	pr = kmalloc(sizeof(struct acpi_processor), GFP_KERNEL);
+	if (!pr)
+		return_VALUE(-ENOMEM);
+	memset(pr, 0, sizeof(struct acpi_processor));
+
+	pr->handle = device->handle;
+	strcpy(acpi_device_name(device), ACPI_PROCESSOR_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_PROCESSOR_CLASS);
+	acpi_driver_data(device) = pr;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_processor	*pr = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	pr = (struct acpi_processor *) acpi_driver_data(device);
+
+	if (pr->id >= NR_CPUS) {
+		kfree(pr);
+		return_VALUE(0);
+	}
+
+	if (type == ACPI_BUS_REMOVAL_EJECT) {
+		if (acpi_processor_handle_eject(pr))
+			return_VALUE(-EINVAL);
+	}
+
+	acpi_processor_power_exit(pr, device);
+
+	status = acpi_remove_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY,
+		acpi_processor_notify);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+	}
+
+	acpi_processor_remove_fs(device);
+
+	processors[pr->id] = NULL;
+
+	kfree(pr);
+
+	return_VALUE(0);
+}
+
+#ifdef CONFIG_ACPI_HOTPLUG_CPU
+/****************************************************************************
+ * 	Acpi processor hotplug support 				       	    *
+ ****************************************************************************/
+
+static int is_processor_present(acpi_handle handle);
+
+static int
+is_processor_present(
+	acpi_handle handle)
+{
+	acpi_status 		status;
+	unsigned long		sta = 0;
+
+	ACPI_FUNCTION_TRACE("is_processor_present");
+
+	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
+	if (ACPI_FAILURE(status) || !(sta & ACPI_STA_PRESENT)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Processor Device is not present\n"));
+		return_VALUE(0);
+	}
+	return_VALUE(1);
+}
+
+
+static
+int acpi_processor_device_add(
+	acpi_handle	handle,
+	struct acpi_device **device)
+{
+	acpi_handle		phandle;
+	struct acpi_device 	*pdev;
+	struct acpi_processor	*pr;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_device_add");
+
+	if (acpi_get_parent(handle, &phandle)) {
+		return_VALUE(-ENODEV);
+	}
+
+	if (acpi_bus_get_device(phandle, &pdev)) {
+		return_VALUE(-ENODEV);
+	}
+
+	if (acpi_bus_add(device, pdev, handle, ACPI_BUS_TYPE_PROCESSOR)) {
+		return_VALUE(-ENODEV);
+	}
+
+	acpi_bus_scan(*device);
+
+	pr = acpi_driver_data(*device);
+	if (!pr)
+		return_VALUE(-ENODEV);
+
+	if ((pr->id >=0) && (pr->id < NR_CPUS)) {
+		kobject_hotplug(&(*device)->kobj, KOBJ_ONLINE);
+	}
+	return_VALUE(0);
+}
+
+
+static void
+acpi_processor_hotplug_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_processor	*pr;
+	struct acpi_device	*device = NULL;
+	int result;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_hotplug_notify");
+
+	switch (event) {
+	case ACPI_NOTIFY_BUS_CHECK:
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		printk("Processor driver received %s event\n",
+			(event==ACPI_NOTIFY_BUS_CHECK)?
+			"ACPI_NOTIFY_BUS_CHECK":"ACPI_NOTIFY_DEVICE_CHECK");
+
+		if (!is_processor_present(handle))
+			break;
+
+		if (acpi_bus_get_device(handle, &device)) {
+			result = acpi_processor_device_add(handle, &device);
+			if (result)
+				ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					"Unable to add the device\n"));
+			break;
+		}
+
+		pr = acpi_driver_data(device);
+		if (!pr) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				"Driver data is NULL\n"));
+			break;
+		}
+
+		if (pr->id >= 0 && (pr->id < NR_CPUS)) {
+			kobject_hotplug(&device->kobj, KOBJ_OFFLINE);
+			break;
+		}
+
+		result = acpi_processor_start(device);
+		if ((!result) && ((pr->id >=0) && (pr->id < NR_CPUS))) {
+			kobject_hotplug(&device->kobj, KOBJ_ONLINE);
+		} else {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				"Device [%s] failed to start\n",
+				acpi_device_bid(device)));
+		}
+	break;
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,"received ACPI_NOTIFY_EJECT_REQUEST\n"));
+
+		if (acpi_bus_get_device(handle, &device)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,"Device don't exist, dropping EJECT\n"));
+			break;
+		}
+		pr = acpi_driver_data(device);
+		if (!pr) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,"Driver data is NULL, dropping EJECT\n"));
+			return_VOID;
+		}
+
+		if ((pr->id < NR_CPUS) && (cpu_present(pr->id)))
+			kobject_hotplug(&device->kobj, KOBJ_OFFLINE);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+static acpi_status
+processor_walk_namespace_cb(acpi_handle handle,
+	u32 lvl,
+	void *context,
+	void **rv)
+{
+	acpi_status 			status;
+	int *action = context;
+	acpi_object_type	type = 0;
+
+	status = acpi_get_type(handle, &type);
+	if (ACPI_FAILURE(status))
+		return(AE_OK);
+
+	if (type != ACPI_TYPE_PROCESSOR)
+		return(AE_OK);
+
+	switch(*action) {
+	case INSTALL_NOTIFY_HANDLER:
+		acpi_install_notify_handler(handle,
+			ACPI_SYSTEM_NOTIFY,
+			acpi_processor_hotplug_notify,
+			NULL);
+		break;
+	case UNINSTALL_NOTIFY_HANDLER:
+		acpi_remove_notify_handler(handle,
+			ACPI_SYSTEM_NOTIFY,
+			acpi_processor_hotplug_notify);
+		break;
+	default:
+		break;
+	}
+
+	return(AE_OK);
+}
+
+
+static acpi_status
+acpi_processor_hotadd_init(
+	acpi_handle		handle,
+	int			*p_cpu)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_hotadd_init");
+
+	if (!is_processor_present(handle)) {
+		return_VALUE(AE_ERROR);
+	}
+
+	if (acpi_map_lsapic(handle, p_cpu))
+		return_VALUE(AE_ERROR);
+
+	if (arch_register_cpu(*p_cpu)) {
+		acpi_unmap_lsapic(*p_cpu);
+		return_VALUE(AE_ERROR);
+	}
+
+	return_VALUE(AE_OK);
+}
+
+
+static int
+acpi_processor_handle_eject(struct acpi_processor *pr)
+{
+	if (cpu_online(pr->id)) {
+		return(-EINVAL);
+	}
+	arch_unregister_cpu(pr->id);
+	acpi_unmap_lsapic(pr->id);
+	return(0);
+}
+#else
+static acpi_status
+acpi_processor_hotadd_init(
+	acpi_handle		handle,
+	int			*p_cpu)
+{
+	return AE_ERROR;
+}
+static int
+acpi_processor_handle_eject(struct acpi_processor *pr)
+{
+	return(-EINVAL);
+}
+#endif
+
+
+static
+void acpi_processor_install_hotplug_notify(void)
+{
+#ifdef CONFIG_ACPI_HOTPLUG_CPU
+	int action = INSTALL_NOTIFY_HANDLER;
+	acpi_walk_namespace(ACPI_TYPE_PROCESSOR,
+				     ACPI_ROOT_OBJECT,
+				     ACPI_UINT32_MAX,
+				     processor_walk_namespace_cb,
+				     &action, NULL);
+#endif
+}
+
+
+static
+void acpi_processor_uninstall_hotplug_notify(void)
+{
+#ifdef CONFIG_ACPI_HOTPLUG_CPU
+	int action = UNINSTALL_NOTIFY_HANDLER;
+	acpi_walk_namespace(ACPI_TYPE_PROCESSOR,
+				     ACPI_ROOT_OBJECT,
+				     ACPI_UINT32_MAX,
+				     processor_walk_namespace_cb,
+				     &action, NULL);
+#endif
+}
+
+/*
+ * We keep the driver loaded even when ACPI is not running.
+ * This is needed for the powernow-k8 driver, that works even without
+ * ACPI, but needs symbols from this driver
+ */
+
+static int __init
+acpi_processor_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_init");
+
+	memset(&processors, 0, sizeof(processors));
+	memset(&errata, 0, sizeof(errata));
+
+	acpi_processor_dir = proc_mkdir(ACPI_PROCESSOR_CLASS, acpi_root_dir);
+	if (!acpi_processor_dir)
+		return_VALUE(0);
+	acpi_processor_dir->owner = THIS_MODULE;
+
+	result = acpi_bus_register_driver(&acpi_processor_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
+		return_VALUE(0);
+	}
+
+	acpi_processor_install_hotplug_notify();
+
+	acpi_thermal_cpufreq_init();
+
+	acpi_processor_ppc_init();
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_processor_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_exit");
+
+	acpi_processor_ppc_exit();
+
+	acpi_thermal_cpufreq_exit();
+
+	acpi_processor_uninstall_hotplug_notify();
+
+	acpi_bus_unregister_driver(&acpi_processor_driver);
+
+	remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_processor_init);
+module_exit(acpi_processor_exit);
+
+EXPORT_SYMBOL(acpi_processor_set_thermal_limit);
+
+MODULE_ALIAS("processor");
diff -Nru a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/acpi/processor_idle.c	2005-01-06 15:06:41 -05:00
@@ -0,0 +1,995 @@
+/*
+ * processor_idle - idle state submodule to the ACPI processor driver
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>
+ *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
+ *  			- Added processor hotplug support
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+#include <linux/moduleparam.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/processor.h>
+
+#define ACPI_PROCESSOR_COMPONENT        0x01000000
+#define ACPI_PROCESSOR_CLASS            "processor"
+#define ACPI_PROCESSOR_DRIVER_NAME      "ACPI Processor Driver"
+#define _COMPONENT              ACPI_PROCESSOR_COMPONENT
+ACPI_MODULE_NAME                ("acpi_processor")
+
+#define ACPI_PROCESSOR_FILE_POWER	"power"
+
+#define US_TO_PM_TIMER_TICKS(t)		((t * (PM_TIMER_FREQUENCY/1000)) / 1000)
+#define C2_OVERHEAD			4	/* 1us (3.579 ticks per us) */
+#define C3_OVERHEAD			4	/* 1us (3.579 ticks per us) */
+
+static void (*pm_idle_save)(void);
+module_param(max_cstate, uint, 0644);
+
+static unsigned int nocst = 0;
+module_param(nocst, uint, 0000);
+
+/* --------------------------------------------------------------------------
+                                Power Management
+   -------------------------------------------------------------------------- */
+
+/*
+ * IBM ThinkPad R40e crashes mysteriously when going into C2 or C3.
+ * For now disable this. Probably a bug somewhere else.
+ *
+ * To skip this limit, boot/load with a large max_cstate limit.
+ */
+static int no_c2c3(struct dmi_system_id *id)
+{
+	if (max_cstate > ACPI_PROCESSOR_MAX_POWER)
+		return 0;
+
+	printk(KERN_NOTICE PREFIX "%s detected - C2,C3 disabled."
+		" Override with \"processor.max_cstate=%d\"\n", id->ident,
+	       ACPI_PROCESSOR_MAX_POWER + 1);
+
+	max_cstate = 1;
+
+	return 0;
+}
+
+
+
+
+static struct dmi_system_id __initdata processor_power_dmi_table[] = {
+	{ no_c2c3, "IBM ThinkPad R40e", {
+	  DMI_MATCH(DMI_BIOS_VENDOR,"IBM"),
+	  DMI_MATCH(DMI_BIOS_VERSION,"1SET60WW") }},
+	{ no_c2c3, "Medion 41700", {
+	  DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
+	  DMI_MATCH(DMI_BIOS_VERSION,"R01-A1J") }},
+	{},
+};
+
+
+static inline u32
+ticks_elapsed (
+	u32			t1,
+	u32			t2)
+{
+	if (t2 >= t1)
+		return (t2 - t1);
+	else if (!acpi_fadt.tmr_val_ext)
+		return (((0x00FFFFFF - t1) + t2) & 0x00FFFFFF);
+	else
+		return ((0xFFFFFFFF - t1) + t2);
+}
+
+
+static void
+acpi_processor_power_activate (
+	struct acpi_processor	*pr,
+	struct acpi_processor_cx  *new)
+{
+	struct acpi_processor_cx  *old;
+
+	if (!pr || !new)
+		return;
+
+	old = pr->power.state;
+
+	if (old)
+		old->promotion.count = 0;
+ 	new->demotion.count = 0;
+
+	/* Cleanup from old state. */
+	if (old) {
+		switch (old->type) {
+		case ACPI_STATE_C3:
+			/* Disable bus master reload */
+			if (new->type != ACPI_STATE_C3)
+				acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 0, ACPI_MTX_DO_NOT_LOCK);
+			break;
+		}
+	}
+
+	/* Prepare to use new state. */
+	switch (new->type) {
+	case ACPI_STATE_C3:
+		/* Enable bus master reload */
+		if (old->type != ACPI_STATE_C3)
+			acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 1, ACPI_MTX_DO_NOT_LOCK);
+		break;
+	}
+
+	pr->power.state = new;
+
+	return;
+}
+
+
+static void acpi_processor_idle (void)
+{
+	struct acpi_processor	*pr = NULL;
+	struct acpi_processor_cx *cx = NULL;
+	struct acpi_processor_cx *next_state = NULL;
+	int			sleep_ticks = 0;
+	u32			t1, t2 = 0;
+
+	pr = processors[smp_processor_id()];
+	if (!pr)
+		return;
+
+	/*
+	 * Interrupts must be disabled during bus mastering calculations and
+	 * for C2/C3 transitions.
+	 */
+	local_irq_disable();
+
+	/*
+	 * Check whether we truly need to go idle, or should
+	 * reschedule:
+	 */
+	if (unlikely(need_resched())) {
+		local_irq_enable();
+		return;
+	}
+
+	cx = pr->power.state;
+	if (!cx)
+		goto easy_out;
+
+	/*
+	 * Check BM Activity
+	 * -----------------
+	 * Check for bus mastering activity (if required), record, and check
+	 * for demotion.
+	 */
+	if (pr->flags.bm_check) {
+		u32		bm_status = 0;
+
+		pr->power.bm_activity <<= 1;
+
+		acpi_get_register(ACPI_BITREG_BUS_MASTER_STATUS,
+			&bm_status, ACPI_MTX_DO_NOT_LOCK);
+		if (bm_status) {
+			pr->power.bm_activity++;
+			acpi_set_register(ACPI_BITREG_BUS_MASTER_STATUS,
+				1, ACPI_MTX_DO_NOT_LOCK);
+		}
+		/*
+		 * PIIX4 Erratum #18: Note that BM_STS doesn't always reflect
+		 * the true state of bus mastering activity; forcing us to
+		 * manually check the BMIDEA bit of each IDE channel.
+		 */
+		else if (errata.piix4.bmisx) {
+			if ((inb_p(errata.piix4.bmisx + 0x02) & 0x01)
+				|| (inb_p(errata.piix4.bmisx + 0x0A) & 0x01))
+				pr->power.bm_activity++;
+		}
+		/*
+		 * Apply bus mastering demotion policy.  Automatically demote
+		 * to avoid a faulty transition.  Note that the processor
+		 * won't enter a low-power state during this call (to this
+		 * funciton) but should upon the next.
+		 *
+		 * TBD: A better policy might be to fallback to the demotion
+		 *      state (use it for this quantum only) istead of
+		 *      demoting -- and rely on duration as our sole demotion
+		 *      qualification.  This may, however, introduce DMA
+		 *      issues (e.g. floppy DMA transfer overrun/underrun).
+		 */
+		if (pr->power.bm_activity & cx->demotion.threshold.bm) {
+			local_irq_enable();
+			next_state = cx->demotion.state;
+			goto end;
+		}
+	}
+
+	cx->usage++;
+
+	/*
+	 * Sleep:
+	 * ------
+	 * Invoke the current Cx state to put the processor to sleep.
+	 */
+	switch (cx->type) {
+
+	case ACPI_STATE_C1:
+		/*
+		 * Invoke C1.
+		 * Use the appropriate idle routine, the one that would
+		 * be used without acpi C-states.
+		 */
+		if (pm_idle_save)
+			pm_idle_save();
+		else
+			safe_halt();
+		/*
+                 * TBD: Can't get time duration while in C1, as resumes
+		 *      go to an ISR rather than here.  Need to instrument
+		 *      base interrupt handler.
+		 */
+		sleep_ticks = 0xFFFFFFFF;
+		break;
+
+	case ACPI_STATE_C2:
+		/* Get start time (ticks) */
+		t1 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Invoke C2 */
+		inb(cx->address);
+		/* Dummy op - must do something useless after P_LVL2 read */
+		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Get end time (ticks) */
+		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Re-enable interrupts */
+		local_irq_enable();
+		/* Compute time (ticks) that we were actually asleep */
+		sleep_ticks = ticks_elapsed(t1, t2) - cx->latency_ticks - C2_OVERHEAD;
+		break;
+
+	case ACPI_STATE_C3:
+		/* Disable bus master arbitration */
+		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+		/* Get start time (ticks) */
+		t1 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Invoke C3 */
+		inb(cx->address);
+		/* Dummy op - must do something useless after P_LVL3 read */
+		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Get end time (ticks) */
+		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Enable bus master arbitration */
+		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_DO_NOT_LOCK);
+		/* Re-enable interrupts */
+		local_irq_enable();
+		/* Compute time (ticks) that we were actually asleep */
+		sleep_ticks = ticks_elapsed(t1, t2) - cx->latency_ticks - C3_OVERHEAD;
+		break;
+
+	default:
+		local_irq_enable();
+		return;
+	}
+
+	next_state = pr->power.state;
+
+	/*
+	 * Promotion?
+	 * ----------
+	 * Track the number of longs (time asleep is greater than threshold)
+	 * and promote when the count threshold is reached.  Note that bus
+	 * mastering activity may prevent promotions.
+	 * Do not promote above max_cstate.
+	 */
+	if (cx->promotion.state &&
+	    ((cx->promotion.state - pr->power.states) <= max_cstate)) {
+		if (sleep_ticks > cx->promotion.threshold.ticks) {
+			cx->promotion.count++;
+ 			cx->demotion.count = 0;
+			if (cx->promotion.count >= cx->promotion.threshold.count) {
+				if (pr->flags.bm_check) {
+					if (!(pr->power.bm_activity & cx->promotion.threshold.bm)) {
+						next_state = cx->promotion.state;
+						goto end;
+					}
+				}
+				else {
+					next_state = cx->promotion.state;
+					goto end;
+				}
+			}
+		}
+	}
+
+	/*
+	 * Demotion?
+	 * ---------
+	 * Track the number of shorts (time asleep is less than time threshold)
+	 * and demote when the usage threshold is reached.
+	 */
+	if (cx->demotion.state) {
+		if (sleep_ticks < cx->demotion.threshold.ticks) {
+			cx->demotion.count++;
+			cx->promotion.count = 0;
+			if (cx->demotion.count >= cx->demotion.threshold.count) {
+				next_state = cx->demotion.state;
+				goto end;
+			}
+		}
+	}
+
+end:
+	/*
+	 * Demote if current state exceeds max_cstate
+	 */
+	if ((pr->power.state - pr->power.states) > max_cstate) {
+		if (cx->demotion.state)
+			next_state = cx->demotion.state;
+	}
+
+	/*
+	 * New Cx State?
+	 * -------------
+	 * If we're going to start using a new Cx state we must clean up
+	 * from the previous and prepare to use the new.
+	 */
+	if (next_state != pr->power.state)
+		acpi_processor_power_activate(pr, next_state);
+
+	return;
+
+ easy_out:
+	/* do C1 instead of busy loop */
+	if (pm_idle_save)
+		pm_idle_save();
+	else
+		safe_halt();
+	return;
+}
+
+
+static int
+acpi_processor_set_power_policy (
+	struct acpi_processor	*pr)
+{
+	unsigned int i;
+	unsigned int state_is_set = 0;
+	struct acpi_processor_cx *lower = NULL;
+	struct acpi_processor_cx *higher = NULL;
+	struct acpi_processor_cx *cx;
+
+ 	ACPI_FUNCTION_TRACE("acpi_processor_set_power_policy");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * This function sets the default Cx state policy (OS idle handler).
+	 * Our scheme is to promote quickly to C2 but more conservatively
+	 * to C3.  We're favoring C2  for its characteristics of low latency
+	 * (quick response), good power savings, and ability to allow bus
+	 * mastering activity.  Note that the Cx state policy is completely
+	 * customizable and can be altered dynamically.
+	 */
+
+	/* startup state */
+	for (i=1; i < ACPI_PROCESSOR_MAX_POWER; i++) {
+		cx = &pr->power.states[i];
+		if (!cx->valid)
+			continue;
+
+		if (!state_is_set)
+			pr->power.state = cx;
+		state_is_set++;
+		break;
+ 	}
+
+	if (!state_is_set)
+		return_VALUE(-ENODEV);
+
+	/* demotion */
+	for (i=1; i < ACPI_PROCESSOR_MAX_POWER; i++) {
+		cx = &pr->power.states[i];
+		if (!cx->valid)
+			continue;
+
+		if (lower) {
+			cx->demotion.state = lower;
+			cx->demotion.threshold.ticks = cx->latency_ticks;
+			cx->demotion.threshold.count = 1;
+			if (cx->type == ACPI_STATE_C3)
+				cx->demotion.threshold.bm = 0x0F;
+		}
+
+		lower = cx;
+	}
+
+	/* promotion */
+	for (i = (ACPI_PROCESSOR_MAX_POWER - 1); i > 0; i--) {
+		cx = &pr->power.states[i];
+		if (!cx->valid)
+			continue;
+
+		if (higher) {
+			cx->promotion.state  = higher;
+			cx->promotion.threshold.ticks = cx->latency_ticks;
+			if (cx->type >= ACPI_STATE_C2)
+				cx->promotion.threshold.count = 4;
+			else
+				cx->promotion.threshold.count = 10;
+			if (higher->type == ACPI_STATE_C3)
+				cx->promotion.threshold.bm = 0x0F;
+		}
+
+		higher = cx;
+	}
+
+ 	return_VALUE(0);
+}
+
+
+static int acpi_processor_get_power_info_fadt (struct acpi_processor *pr)
+{
+	int i;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info_fadt");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->pblk)
+		return_VALUE(-ENODEV);
+
+	for (i = 0; i < ACPI_PROCESSOR_MAX_POWER; i++)
+		memset(pr->power.states, 0, sizeof(struct acpi_processor_cx));
+
+	/* if info is obtained from pblk/fadt, type equals state */
+	pr->power.states[ACPI_STATE_C1].type = ACPI_STATE_C1;
+	pr->power.states[ACPI_STATE_C2].type = ACPI_STATE_C2;
+	pr->power.states[ACPI_STATE_C3].type = ACPI_STATE_C3;
+
+	/* the C0 state only exists as a filler in our array,
+	 * and all processors need to support C1 */
+	pr->power.states[ACPI_STATE_C0].valid = 1;
+	pr->power.states[ACPI_STATE_C1].valid = 1;
+
+	/* determine C2 and C3 address from pblk */
+	pr->power.states[ACPI_STATE_C2].address = pr->pblk + 4;
+	pr->power.states[ACPI_STATE_C3].address = pr->pblk + 5;
+
+	/* determine latencies from FADT */
+	pr->power.states[ACPI_STATE_C2].latency = acpi_fadt.plvl2_lat;
+	pr->power.states[ACPI_STATE_C3].latency = acpi_fadt.plvl3_lat;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "lvl2[0x%08x] lvl3[0x%08x]\n",
+			  pr->power.states[ACPI_STATE_C2].address,
+			  pr->power.states[ACPI_STATE_C3].address));
+
+	return_VALUE(0);
+}
+
+
+static int acpi_processor_get_power_info_cst (struct acpi_processor *pr)
+{
+	acpi_status		status = 0;
+	acpi_integer		count;
+	int			i;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object	*cst;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info_cst");
+
+	if (errata.smp)
+		return_VALUE(-ENODEV);
+
+	if (nocst)
+		return_VALUE(-ENODEV);
+
+	pr->power.count = 0;
+	for (i = 0; i < ACPI_PROCESSOR_MAX_POWER; i++)
+		memset(pr->power.states, 0, sizeof(struct acpi_processor_cx));
+
+	status = acpi_evaluate_object(pr->handle, "_CST", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No _CST, giving up\n"));
+		return_VALUE(-ENODEV);
+ 	}
+
+	cst = (union acpi_object *) buffer.pointer;
+
+	/* There must be at least 2 elements */
+	if (!cst || (cst->type != ACPI_TYPE_PACKAGE) || cst->package.count < 2) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "not enough elements in _CST\n"));
+		status = -EFAULT;
+		goto end;
+	}
+
+	count = cst->package.elements[0].integer.value;
+
+	/* Validate number of power states. */
+	if (count < 1 || count != cst->package.count - 1) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "count given by _CST is not valid\n"));
+		status = -EFAULT;
+		goto end;
+	}
+
+	/* We support up to ACPI_PROCESSOR_MAX_POWER. */
+	if (count > ACPI_PROCESSOR_MAX_POWER) {
+		printk(KERN_WARNING "Limiting number of power states to max (%d)\n", ACPI_PROCESSOR_MAX_POWER);
+		printk(KERN_WARNING "Please increase ACPI_PROCESSOR_MAX_POWER if needed.\n");
+		count = ACPI_PROCESSOR_MAX_POWER;
+	}
+
+	/* Tell driver that at least _CST is supported. */
+	pr->flags.has_cst = 1;
+
+	for (i = 1; i <= count; i++) {
+		union acpi_object *element;
+		union acpi_object *obj;
+		struct acpi_power_register *reg;
+		struct acpi_processor_cx cx;
+
+		memset(&cx, 0, sizeof(cx));
+
+		element = (union acpi_object *) &(cst->package.elements[i]);
+		if (element->type != ACPI_TYPE_PACKAGE)
+			continue;
+
+		if (element->package.count != 4)
+			continue;
+
+		obj = (union acpi_object *) &(element->package.elements[0]);
+
+		if (obj->type != ACPI_TYPE_BUFFER)
+			continue;
+
+		reg = (struct acpi_power_register *) obj->buffer.pointer;
+
+		if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO &&
+			(reg->space_id != ACPI_ADR_SPACE_FIXED_HARDWARE))
+			continue;
+
+		cx.address = (reg->space_id == ACPI_ADR_SPACE_FIXED_HARDWARE) ?
+			0 : reg->address;
+
+		/* There should be an easy way to extract an integer... */
+		obj = (union acpi_object *) &(element->package.elements[1]);
+		if (obj->type != ACPI_TYPE_INTEGER)
+			continue;
+
+		cx.type = obj->integer.value;
+
+		if ((cx.type != ACPI_STATE_C1) &&
+		    (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO))
+			continue;
+
+		if ((cx.type < ACPI_STATE_C1) ||
+		    (cx.type > ACPI_STATE_C3))
+			continue;
+
+		obj = (union acpi_object *) &(element->package.elements[2]);
+		if (obj->type != ACPI_TYPE_INTEGER)
+			continue;
+
+		cx.latency = obj->integer.value;
+
+		obj = (union acpi_object *) &(element->package.elements[3]);
+		if (obj->type != ACPI_TYPE_INTEGER)
+			continue;
+
+		cx.power = obj->integer.value;
+
+		(pr->power.count)++;
+		memcpy(&(pr->power.states[pr->power.count]), &cx, sizeof(cx));
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d power states\n", pr->power.count));
+
+	/* Validate number of power states discovered */
+	if (pr->power.count < 2)
+		status = -ENODEV;
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	return_VALUE(status);
+}
+
+
+static void acpi_processor_power_verify_c2(struct acpi_processor_cx *cx)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_get_power_verify_c2");
+
+	if (!cx->address)
+		return_VOID;
+
+	/*
+	 * C2 latency must be less than or equal to 100
+	 * microseconds.
+	 */
+	else if (cx->latency > ACPI_PROCESSOR_MAX_C2_LATENCY) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "latency too large [%d]\n",
+				  cx->latency));
+		return_VOID;
+	}
+
+	/* We're (currently) only supporting C2 on UP */
+	else if (errata.smp) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "C2 not supported in SMP mode\n"));
+		return_VOID;
+	}
+
+	/*
+	 * Otherwise we've met all of our C2 requirements.
+	 * Normalize the C2 latency to expidite policy
+	 */
+	cx->valid = 1;
+	cx->latency_ticks = US_TO_PM_TIMER_TICKS(cx->latency);
+
+	return_VOID;
+}
+
+
+static void acpi_processor_power_verify_c3(
+	struct acpi_processor *pr,
+	struct acpi_processor_cx *cx)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_get_power_verify_c3");
+
+	if (!cx->address)
+		return_VOID;
+
+	/*
+	 * C3 latency must be less than or equal to 1000
+	 * microseconds.
+	 */
+	else if (cx->latency > ACPI_PROCESSOR_MAX_C3_LATENCY) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "latency too large [%d]\n",
+				  cx->latency));
+		return_VOID;
+	}
+
+	/* bus mastering control is necessary */
+	else if (!pr->flags.bm_control) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "C3 support requires bus mastering control\n"));
+		return_VOID;
+	}
+
+	/* We're (currently) only supporting C2 on UP */
+	else if (errata.smp) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "C3 not supported in SMP mode\n"));
+		return_VOID;
+	}
+
+	/*
+	 * PIIX4 Erratum #18: We don't support C3 when Type-F (fast)
+	 * DMA transfers are used by any ISA device to avoid livelock.
+	 * Note that we could disable Type-F DMA (as recommended by
+	 * the erratum), but this is known to disrupt certain ISA
+	 * devices thus we take the conservative approach.
+	 */
+	else if (errata.piix4.fdma) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"C3 not supported on PIIX4 with Type-F DMA\n"));
+		return_VOID;
+	}
+
+	/*
+	 * Otherwise we've met all of our C3 requirements.
+	 * Normalize the C3 latency to expidite policy.  Enable
+	 * checking of bus mastering status (bm_check) so we can
+	 * use this in our C3 policy
+	 */
+	cx->valid = 1;
+	cx->latency_ticks = US_TO_PM_TIMER_TICKS(cx->latency);
+	pr->flags.bm_check = 1;
+
+	return_VOID;
+}
+
+
+static int acpi_processor_power_verify(struct acpi_processor *pr)
+{
+	unsigned int i;
+	unsigned int working = 0;
+
+	for (i=1; i < ACPI_PROCESSOR_MAX_POWER; i++) {
+		struct acpi_processor_cx *cx = &pr->power.states[i];
+
+		switch (cx->type) {
+		case ACPI_STATE_C1:
+			cx->valid = 1;
+			break;
+
+		case ACPI_STATE_C2:
+			acpi_processor_power_verify_c2(cx);
+			break;
+
+		case ACPI_STATE_C3:
+			acpi_processor_power_verify_c3(pr, cx);
+			break;
+		}
+
+		if (cx->valid)
+			working++;
+	}
+
+	return (working);
+}
+
+static int acpi_processor_get_power_info (
+	struct acpi_processor	*pr)
+{
+	unsigned int i;
+	int result;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info");
+
+	/* NOTE: the idle thread may not be running while calling
+	 * this function */
+
+	result = acpi_processor_get_power_info_cst(pr);
+	if ((result) || (acpi_processor_power_verify(pr) < 2)) {
+		result = acpi_processor_get_power_info_fadt(pr);
+		if (result)
+			return_VALUE(result);
+
+		if (acpi_processor_power_verify(pr) < 2)
+			return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * Set Default Policy
+	 * ------------------
+	 * Now that we know which states are supported, set the default
+	 * policy.  Note that this policy can be changed dynamically
+	 * (e.g. encourage deeper sleeps to conserve battery life when
+	 * not on AC).
+	 */
+	result = acpi_processor_set_power_policy(pr);
+	if (result)
+		return_VALUE(result);
+
+	/*
+	 * if one state of type C2 or C3 is available, mark this
+	 * CPU as being "idle manageable"
+	 */
+	for (i = 1; i < ACPI_PROCESSOR_MAX_POWER; i++) {
+		if (pr->power.states[i].valid)
+			pr->power.count = i;
+		if ((pr->power.states[i].valid) &&
+		    (pr->power.states[i].type >= ACPI_STATE_C2))
+			pr->flags.power = 1;
+	}
+
+	return_VALUE(0);
+}
+
+int acpi_processor_cst_has_changed (struct acpi_processor *pr)
+{
+ 	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_cst_has_changed");
+
+	if (!pr)
+ 		return_VALUE(-EINVAL);
+
+	if (errata.smp || nocst) {
+		return_VALUE(-ENODEV);
+	}
+
+	if (!pr->flags.power_setup_done)
+		return_VALUE(-ENODEV);
+
+	/* Fall back to the default idle loop */
+	pm_idle = pm_idle_save;
+	synchronize_kernel();
+
+	pr->flags.power = 0;
+	result = acpi_processor_get_power_info(pr);
+	if ((pr->flags.power == 1) && (pr->flags.power_setup_done))
+		pm_idle = acpi_processor_idle;
+
+	return_VALUE(result);
+}
+
+/* proc interface */
+
+static int acpi_processor_power_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
+	unsigned int		i;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_power_seq_show");
+
+	if (!pr)
+		goto end;
+
+	seq_printf(seq, "active state:            C%d\n"
+			"max_cstate:              C%d\n"
+			"bus master activity:     %08x\n",
+			pr->power.state ? pr->power.state - pr->power.states : 0,
+			max_cstate,
+			pr->power.bm_activity);
+
+	seq_puts(seq, "states:\n");
+
+	for (i = 1; i <= pr->power.count; i++) {
+		seq_printf(seq, "   %cC%d:                  ",
+			(&pr->power.states[i] == pr->power.state?'*':' '), i);
+
+		if (!pr->power.states[i].valid) {
+			seq_puts(seq, "<not supported>\n");
+			continue;
+		}
+
+		switch (pr->power.states[i].type) {
+		case ACPI_STATE_C1:
+			seq_printf(seq, "type[C1] ");
+			break;
+		case ACPI_STATE_C2:
+			seq_printf(seq, "type[C2] ");
+			break;
+		case ACPI_STATE_C3:
+			seq_printf(seq, "type[C3] ");
+			break;
+		default:
+			seq_printf(seq, "type[--] ");
+			break;
+		}
+
+		if (pr->power.states[i].promotion.state)
+			seq_printf(seq, "promotion[C%d] ",
+				(pr->power.states[i].promotion.state -
+				 pr->power.states));
+		else
+			seq_puts(seq, "promotion[--] ");
+
+		if (pr->power.states[i].demotion.state)
+			seq_printf(seq, "demotion[C%d] ",
+				(pr->power.states[i].demotion.state -
+				 pr->power.states));
+		else
+			seq_puts(seq, "demotion[--] ");
+
+		seq_printf(seq, "latency[%03d] usage[%08d]\n",
+			pr->power.states[i].latency,
+			pr->power.states[i].usage);
+	}
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_processor_power_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_processor_power_seq_show,
+						PDE(inode)->data);
+}
+
+static struct file_operations acpi_processor_power_fops = {
+	.open 		= acpi_processor_power_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+
+int acpi_processor_power_init(struct acpi_processor *pr, struct acpi_device *device)
+{
+	acpi_status		status = 0;
+	static int		first_run = 0;
+	struct proc_dir_entry	*entry = NULL;
+	unsigned int i;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_power_init");
+
+	if (!first_run) {
+		dmi_check_system(processor_power_dmi_table);
+		if (max_cstate < ACPI_C_STATES_MAX)
+			printk(KERN_NOTICE "ACPI: processor limited to max C-state %d\n", max_cstate);
+		first_run++;
+	}
+
+	if (!errata.smp && (pr->id == 0) && acpi_fadt.cst_cnt && !nocst) {
+		status = acpi_os_write_port(acpi_fadt.smi_cmd, acpi_fadt.cst_cnt, 8);
+		if (ACPI_FAILURE(status)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					  "Notifying BIOS of _CST ability failed\n"));
+		}
+	}
+
+	acpi_processor_get_power_info(pr);
+
+	/*
+	 * Install the idle handler if processor power management is supported.
+	 * Note that we use previously set idle handler will be used on
+	 * platforms that only support C1.
+	 */
+	if ((pr->flags.power) && (!boot_option_idle_override)) {
+		printk(KERN_INFO PREFIX "CPU%d (power states:", pr->id);
+		for (i = 1; i <= pr->power.count; i++)
+			if (pr->power.states[i].valid)
+				printk(" C%d[C%d]", i, pr->power.states[i].type);
+		printk(")\n");
+
+		if (pr->id == 0) {
+			pm_idle_save = pm_idle;
+			pm_idle = acpi_processor_idle;
+		}
+	}
+
+	/* 'power' [R] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_POWER,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_POWER));
+	else {
+		entry->proc_fops = &acpi_processor_power_fops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	pr->flags.power_setup_done = 1;
+
+	return_VALUE(0);
+}
+
+int acpi_processor_power_exit(struct acpi_processor *pr, struct acpi_device *device)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_power_exit");
+
+	pr->flags.power_setup_done = 0;
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(ACPI_PROCESSOR_FILE_POWER,acpi_device_dir(device));
+
+	/* Unregister the idle handler when processor #0 is removed. */
+	if (pr->id == 0) {
+		pm_idle = pm_idle_save;
+
+		/*
+		 * We are about to unload the current idle thread pm callback
+		 * (pm_idle), Wait for all processors to update cached/local
+		 * copies of pm_idle before proceeding.
+		 */
+		synchronize_kernel();
+	}
+
+	return_VALUE(0);
+}
diff -Nru a/drivers/acpi/processor_perflib.c b/drivers/acpi/processor_perflib.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/acpi/processor_perflib.c	2005-01-06 15:06:41 -05:00
@@ -0,0 +1,666 @@
+/*
+ * processor_perflib.c - ACPI Processor P-States Library ($Revision$)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>
+ *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
+ *  			- Added processor hotplug support
+ *
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+
+#ifdef CONFIG_X86_ACPI_CPUFREQ_PROC_INTF
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include <asm/uaccess.h>
+#endif
+
+#include <acpi/acpi_bus.h>
+#include <acpi/processor.h>
+
+
+#define ACPI_PROCESSOR_COMPONENT	0x01000000
+#define ACPI_PROCESSOR_CLASS		"processor"
+#define ACPI_PROCESSOR_DRIVER_NAME	"ACPI Processor Driver"
+#define ACPI_PROCESSOR_FILE_PERFORMANCE	"performance"
+#define _COMPONENT		ACPI_PROCESSOR_COMPONENT
+ACPI_MODULE_NAME		("acpi_processor")
+
+
+static DECLARE_MUTEX(performance_sem);
+
+/*
+ * _PPC support is implemented as a CPUfreq policy notifier:
+ * This means each time a CPUfreq driver registered also with
+ * the ACPI core is asked to change the speed policy, the maximum
+ * value is adjusted so that it is within the platform limit.
+ *
+ * Also, when a new platform limit value is detected, the CPUfreq
+ * policy is adjusted accordingly.
+ */
+
+#define PPC_REGISTERED   1
+#define PPC_IN_USE       2
+
+static int acpi_processor_ppc_status = 0;
+
+static int acpi_processor_ppc_notifier(struct notifier_block *nb,
+	unsigned long event,
+	void *data)
+{
+	struct cpufreq_policy *policy = data;
+	struct acpi_processor *pr;
+	unsigned int ppc = 0;
+
+	down(&performance_sem);
+
+	if (event != CPUFREQ_INCOMPATIBLE)
+		goto out;
+
+	pr = processors[policy->cpu];
+	if (!pr || !pr->performance)
+		goto out;
+
+	ppc = (unsigned int) pr->performance_platform_limit;
+	if (!ppc)
+		goto out;
+
+	if (ppc > pr->performance->state_count)
+		goto out;
+
+	cpufreq_verify_within_limits(policy, 0,
+		pr->performance->states[ppc].core_frequency * 1000);
+
+ out:
+	up(&performance_sem);
+
+	return 0;
+}
+
+
+static struct notifier_block acpi_ppc_notifier_block = {
+	.notifier_call = acpi_processor_ppc_notifier,
+};
+
+
+static int
+acpi_processor_get_platform_limit (
+	struct acpi_processor*	pr)
+{
+	acpi_status		status = 0;
+	unsigned long		ppc = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_platform_limit");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * _PPC indicates the maximum state currently supported by the platform
+	 * (e.g. 0 = states 0..n; 1 = states 1..n; etc.
+	 */
+	status = acpi_evaluate_integer(pr->handle, "_PPC", NULL, &ppc);
+
+	if (status != AE_NOT_FOUND)
+		acpi_processor_ppc_status |= PPC_IN_USE;
+
+	if(ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PPC\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pr->performance_platform_limit = (int) ppc;
+
+	return_VALUE(0);
+}
+
+
+int acpi_processor_ppc_has_changed(
+	struct acpi_processor *pr)
+{
+	int ret = acpi_processor_get_platform_limit(pr);
+	if (ret < 0)
+		return (ret);
+	else
+		return cpufreq_update_policy(pr->id);
+}
+
+
+void acpi_processor_ppc_init(void) {
+	if (!cpufreq_register_notifier(&acpi_ppc_notifier_block, CPUFREQ_POLICY_NOTIFIER))
+		acpi_processor_ppc_status |= PPC_REGISTERED;
+	else
+		printk(KERN_DEBUG "Warning: Processor Platform Limit not supported.\n");
+}
+
+
+void acpi_processor_ppc_exit(void) {
+	if (acpi_processor_ppc_status & PPC_REGISTERED)
+		cpufreq_unregister_notifier(&acpi_ppc_notifier_block, CPUFREQ_POLICY_NOTIFIER);
+
+	acpi_processor_ppc_status &= ~PPC_REGISTERED;
+}
+
+/*
+ * when registering a cpufreq driver with this ACPI processor driver, the
+ * _PCT and _PSS structures are read out and written into struct
+ * acpi_processor_performance.
+ */
+static int acpi_processor_set_pdc (struct acpi_processor *pr)
+{
+	acpi_status             status = AE_OK;
+	u32			arg0_buf[3];
+	union acpi_object	arg0 = {ACPI_TYPE_BUFFER};
+	struct acpi_object_list no_object = {1, &arg0};
+	struct acpi_object_list *pdc;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_pdc");
+
+	arg0.buffer.length = 12;
+	arg0.buffer.pointer = (u8 *) arg0_buf;
+	arg0_buf[0] = ACPI_PDC_REVISION_ID;
+	arg0_buf[1] = 0;
+	arg0_buf[2] = 0;
+
+	pdc = (pr->performance->pdc) ? pr->performance->pdc : &no_object;
+
+	status = acpi_evaluate_object(pr->handle, "_PDC", pdc, NULL);
+
+	if ((ACPI_FAILURE(status)) && (pr->performance->pdc))
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Error evaluating _PDC, using legacy perf. control...\n"));
+
+	return_VALUE(status);
+}
+
+
+static int
+acpi_processor_get_performance_control (
+	struct acpi_processor *pr)
+{
+	int			result = 0;
+	acpi_status		status = 0;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object	*pct = NULL;
+	union acpi_object	obj = {0};
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_control");
+
+	status = acpi_evaluate_object(pr->handle, "_PCT", NULL, &buffer);
+	if(ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PCT\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pct = (union acpi_object *) buffer.pointer;
+	if (!pct || (pct->type != ACPI_TYPE_PACKAGE)
+		|| (pct->package.count != 2)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PCT data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	/*
+	 * control_register
+	 */
+
+	obj = pct->package.elements[0];
+
+	if ((obj.type != ACPI_TYPE_BUFFER)
+		|| (obj.buffer.length < sizeof(struct acpi_pct_register))
+		|| (obj.buffer.pointer == NULL)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Invalid _PCT data (control_register)\n"));
+		result = -EFAULT;
+		goto end;
+	}
+	memcpy(&pr->performance->control_register, obj.buffer.pointer, sizeof(struct acpi_pct_register));
+
+
+	/*
+	 * status_register
+	 */
+
+	obj = pct->package.elements[1];
+
+	if ((obj.type != ACPI_TYPE_BUFFER)
+		|| (obj.buffer.length < sizeof(struct acpi_pct_register))
+		|| (obj.buffer.pointer == NULL)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Invalid _PCT data (status_register)\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	memcpy(&pr->performance->status_register, obj.buffer.pointer, sizeof(struct acpi_pct_register));
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_processor_get_performance_states (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer	format = {sizeof("NNNNNN"), "NNNNNN"};
+	struct acpi_buffer	state = {0, NULL};
+	union acpi_object 	*pss = NULL;
+	int			i;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_states");
+
+	status = acpi_evaluate_object(pr->handle, "_PSS", NULL, &buffer);
+	if(ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PSS\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pss = (union acpi_object *) buffer.pointer;
+	if (!pss || (pss->type != ACPI_TYPE_PACKAGE)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d performance states\n",
+		pss->package.count));
+
+	pr->performance->state_count = pss->package.count;
+	pr->performance->states = kmalloc(sizeof(struct acpi_processor_px) * pss->package.count, GFP_KERNEL);
+	if (!pr->performance->states) {
+		result = -ENOMEM;
+		goto end;
+	}
+
+	for (i = 0; i < pr->performance->state_count; i++) {
+
+		struct acpi_processor_px *px = &(pr->performance->states[i]);
+
+		state.length = sizeof(struct acpi_processor_px);
+		state.pointer = px;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));
+
+		status = acpi_extract_package(&(pss->package.elements[i]),
+			&format, &state);
+		if (ACPI_FAILURE(status)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
+			result = -EFAULT;
+			kfree(pr->performance->states);
+			goto end;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"State [%d]: core_frequency[%d] power[%d] transition_latency[%d] bus_master_latency[%d] control[0x%x] status[0x%x]\n",
+			i,
+			(u32) px->core_frequency,
+			(u32) px->power,
+			(u32) px->transition_latency,
+			(u32) px->bus_master_latency,
+			(u32) px->control,
+			(u32) px->status));
+
+		if (!px->core_frequency) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data: freq is zero\n"));
+			result = -EFAULT;
+			kfree(pr->performance->states);
+			goto end;
+		}
+	}
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_processor_get_performance_info (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_info");
+
+	if (!pr || !pr->performance || !pr->handle)
+		return_VALUE(-EINVAL);
+
+	acpi_processor_set_pdc(pr);
+
+	status = acpi_get_handle(pr->handle, "_PCT", &handle);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"ACPI-based processor performance control unavailable\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	result = acpi_processor_get_performance_control(pr);
+	if (result)
+		return_VALUE(result);
+
+	result = acpi_processor_get_performance_states(pr);
+	if (result)
+		return_VALUE(result);
+
+	result = acpi_processor_get_platform_limit(pr);
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(0);
+}
+
+
+int acpi_processor_notify_smm(struct module *calling_module) {
+	acpi_status		status;
+	static int		is_done = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_notify_smm");
+
+	if (!(acpi_processor_ppc_status & PPC_REGISTERED))
+		return_VALUE(-EBUSY);
+
+	if (!try_module_get(calling_module))
+		return_VALUE(-EINVAL);
+
+	/* is_done is set to negative if an error occured,
+	 * and to postitive if _no_ error occured, but SMM
+	 * was already notified. This avoids double notification
+	 * which might lead to unexpected results...
+	 */
+	if (is_done > 0) {
+		module_put(calling_module);
+		return_VALUE(0);
+	}
+	else if (is_done < 0) {
+		module_put(calling_module);
+		return_VALUE(is_done);
+	}
+
+	is_done = -EIO;
+
+	/* Can't write pstate_cnt to smi_cmd if either value is zero */
+	if ((!acpi_fadt.smi_cmd) ||
+	    (!acpi_fadt.pstate_cnt)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"No SMI port or pstate_cnt\n"));
+		module_put(calling_module);
+		return_VALUE(0);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Writing pstate_cnt [0x%x] to smi_cmd [0x%x]\n", acpi_fadt.pstate_cnt, acpi_fadt.smi_cmd));
+
+	/* FADT v1 doesn't support pstate_cnt, many BIOS vendors use
+	 * it anyway, so we need to support it... */
+	if (acpi_fadt_is_v1) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Using v1.0 FADT reserved value for pstate_cnt\n"));
+	}
+
+	status = acpi_os_write_port (acpi_fadt.smi_cmd,
+				     (u32) acpi_fadt.pstate_cnt, 8);
+	if (ACPI_FAILURE (status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Failed to write pstate_cnt [0x%x] to "
+				  "smi_cmd [0x%x]\n", acpi_fadt.pstate_cnt, acpi_fadt.smi_cmd));
+		module_put(calling_module);
+		return_VALUE(status);
+	}
+
+	/* Success. If there's no _PPC, we need to fear nothing, so
+	 * we can allow the cpufreq driver to be rmmod'ed. */
+	is_done = 1;
+
+	if (!(acpi_processor_ppc_status & PPC_IN_USE))
+		module_put(calling_module);
+
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_processor_notify_smm);
+
+
+#ifdef CONFIG_X86_ACPI_CPUFREQ_PROC_INTF
+/* /proc/acpi/processor/../performance interface (DEPRECATED) */
+
+static int acpi_processor_perf_open_fs(struct inode *inode, struct file *file);
+static struct file_operations acpi_processor_perf_fops = {
+	.open 		= acpi_processor_perf_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int acpi_processor_perf_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
+	int			i;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_perf_seq_show");
+
+	if (!pr)
+		goto end;
+
+	if (!pr->performance) {
+		seq_puts(seq, "<not supported>\n");
+		goto end;
+	}
+
+	seq_printf(seq, "state count:             %d\n"
+			"active state:            P%d\n",
+			pr->performance->state_count,
+			pr->performance->state);
+
+	seq_puts(seq, "states:\n");
+	for (i = 0; i < pr->performance->state_count; i++)
+		seq_printf(seq, "   %cP%d:                  %d MHz, %d mW, %d uS\n",
+			(i == pr->performance->state?'*':' '), i,
+			(u32) pr->performance->states[i].core_frequency,
+			(u32) pr->performance->states[i].power,
+			(u32) pr->performance->states[i].transition_latency);
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_processor_perf_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_processor_perf_seq_show,
+						PDE(inode)->data);
+}
+
+static ssize_t
+acpi_processor_write_performance (
+        struct file		*file,
+        const char		__user *buffer,
+        size_t			count,
+        loff_t			*data)
+{
+	int			result = 0;
+	struct seq_file		*m = (struct seq_file *) file->private_data;
+	struct acpi_processor	*pr = (struct acpi_processor *) m->private;
+	struct acpi_processor_performance *perf;
+	char			state_string[12] = {'\0'};
+	unsigned int            new_state = 0;
+	struct cpufreq_policy   policy;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_performance");
+
+	if (!pr || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+
+	perf = pr->performance;
+	if (!perf)
+		return_VALUE(-EINVAL);
+
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+
+	state_string[count] = '\0';
+	new_state = simple_strtoul(state_string, NULL, 0);
+
+	if (new_state >= perf->state_count)
+		return_VALUE(-EINVAL);
+
+	cpufreq_get_policy(&policy, pr->id);
+
+	policy.cpu = pr->id;
+	policy.min = perf->states[new_state].core_frequency * 1000;
+	policy.max = perf->states[new_state].core_frequency * 1000;
+
+	result = cpufreq_set_policy(&policy);
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+static void
+acpi_cpufreq_add_file (
+	struct acpi_processor *pr)
+{
+	struct proc_dir_entry	*entry = NULL;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_cpufreq_addfile");
+
+	if (acpi_bus_get_device(pr->handle, &device))
+		return_VOID;
+
+	/* add file 'performance' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_PERFORMANCE,
+		  S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_PERFORMANCE));
+	else {
+		entry->proc_fops = &acpi_processor_perf_fops;
+		entry->proc_fops->write = acpi_processor_write_performance;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+	return_VOID;
+}
+
+static void
+acpi_cpufreq_remove_file (
+	struct acpi_processor *pr)
+{
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_cpufreq_addfile");
+
+	if (acpi_bus_get_device(pr->handle, &device))
+		return_VOID;
+
+	/* remove file 'performance' */
+	remove_proc_entry(ACPI_PROCESSOR_FILE_PERFORMANCE,
+		  acpi_device_dir(device));
+
+	return_VOID;
+}
+
+#else
+static void acpi_cpufreq_add_file (struct acpi_processor *pr) { return; }
+static void acpi_cpufreq_remove_file (struct acpi_processor *pr) { return; }
+#endif /* CONFIG_X86_ACPI_CPUFREQ_PROC_INTF */
+
+
+int
+acpi_processor_register_performance (
+	struct acpi_processor_performance * performance,
+	unsigned int cpu)
+{
+	struct acpi_processor *pr;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_register_performance");
+
+	if (!(acpi_processor_ppc_status & PPC_REGISTERED))
+		return_VALUE(-EINVAL);
+
+	down(&performance_sem);
+
+	pr = processors[cpu];
+	if (!pr) {
+		up(&performance_sem);
+		return_VALUE(-ENODEV);
+	}
+
+	if (pr->performance) {
+		up(&performance_sem);
+		return_VALUE(-EBUSY);
+	}
+
+	pr->performance = performance;
+
+	if (acpi_processor_get_performance_info(pr)) {
+		pr->performance = NULL;
+		up(&performance_sem);
+		return_VALUE(-EIO);
+	}
+
+	acpi_cpufreq_add_file(pr);
+
+	up(&performance_sem);
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_processor_register_performance);
+
+
+void
+acpi_processor_unregister_performance (
+	struct acpi_processor_performance * performance,
+	unsigned int cpu)
+{
+	struct acpi_processor *pr;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_unregister_performance");
+
+	down(&performance_sem);
+
+	pr = processors[cpu];
+	if (!pr) {
+		up(&performance_sem);
+		return_VOID;
+	}
+
+	kfree(pr->performance->states);
+	pr->performance = NULL;
+
+	acpi_cpufreq_remove_file(pr);
+
+	up(&performance_sem);
+
+	return_VOID;
+}
+EXPORT_SYMBOL(acpi_processor_unregister_performance);
diff -Nru a/drivers/acpi/processor_thermal.c b/drivers/acpi/processor_thermal.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/acpi/processor_thermal.c	2005-01-06 15:06:41 -05:00
@@ -0,0 +1,406 @@
+/*
+ * processor_thermal.c - Passive cooling submodule of the ACPI processor driver
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>
+ *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
+ *  			- Added processor hotplug support
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include <asm/uaccess.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/processor.h>
+#include <acpi/acpi_drivers.h>
+
+#define ACPI_PROCESSOR_COMPONENT        0x01000000
+#define ACPI_PROCESSOR_CLASS            "processor"
+#define ACPI_PROCESSOR_DRIVER_NAME      "ACPI Processor Driver"
+#define _COMPONENT              ACPI_PROCESSOR_COMPONENT
+ACPI_MODULE_NAME                ("acpi_processor")
+
+
+/* --------------------------------------------------------------------------
+                                 Limit Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_apply_limit (
+	struct acpi_processor* 	pr)
+{
+	int			result = 0;
+	u16			px = 0;
+	u16			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_apply_limit");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.limit)
+		return_VALUE(-ENODEV);
+
+	if (pr->flags.throttling) {
+		if (pr->limit.user.tx > tx)
+			tx = pr->limit.user.tx;
+		if (pr->limit.thermal.tx > tx)
+			tx = pr->limit.thermal.tx;
+
+		result = acpi_processor_set_throttling(pr, tx);
+		if (result)
+			goto end;
+	}
+
+	pr->limit.state.px = px;
+	pr->limit.state.tx = tx;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d] limit set to (P%d:T%d)\n",
+		pr->id,
+		pr->limit.state.px,
+		pr->limit.state.tx));
+
+end:
+	if (result)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to set limit\n"));
+
+	return_VALUE(result);
+}
+
+
+#ifdef CONFIG_CPU_FREQ
+
+/* If a passive cooling situation is detected, primarily CPUfreq is used, as it
+ * offers (in most cases) voltage scaling in addition to frequency scaling, and
+ * thus a cubic (instead of linear) reduction of energy. Also, we allow for
+ * _any_ cpufreq driver and not only the acpi-cpufreq driver.
+ */
+
+static unsigned int cpufreq_thermal_reduction_pctg[NR_CPUS];
+static unsigned int acpi_thermal_cpufreq_is_init = 0;
+
+
+static int cpu_has_cpufreq(unsigned int cpu)
+{
+	struct cpufreq_policy policy;
+	if (!acpi_thermal_cpufreq_is_init)
+		return -ENODEV;
+	if (!cpufreq_get_policy(&policy, cpu))
+		return -ENODEV;
+	return 0;
+}
+
+
+static int acpi_thermal_cpufreq_increase(unsigned int cpu)
+{
+	if (!cpu_has_cpufreq(cpu))
+		return -ENODEV;
+
+	if (cpufreq_thermal_reduction_pctg[cpu] < 60) {
+		cpufreq_thermal_reduction_pctg[cpu] += 20;
+		cpufreq_update_policy(cpu);
+		return 0;
+	}
+
+	return -ERANGE;
+}
+
+
+static int acpi_thermal_cpufreq_decrease(unsigned int cpu)
+{
+	if (!cpu_has_cpufreq(cpu))
+		return -ENODEV;
+
+	if (cpufreq_thermal_reduction_pctg[cpu] >= 20) {
+		cpufreq_thermal_reduction_pctg[cpu] -= 20;
+		cpufreq_update_policy(cpu);
+		return 0;
+	}
+
+	return -ERANGE;
+}
+
+
+static int acpi_thermal_cpufreq_notifier(
+	struct notifier_block *nb,
+	unsigned long event,
+	void *data)
+{
+	struct cpufreq_policy *policy = data;
+	unsigned long max_freq = 0;
+
+	if (event != CPUFREQ_ADJUST)
+		goto out;
+
+	max_freq = (policy->cpuinfo.max_freq * (100 - cpufreq_thermal_reduction_pctg[policy->cpu])) / 100;
+
+	cpufreq_verify_within_limits(policy, 0, max_freq);
+
+ out:
+	return 0;
+}
+
+
+static struct notifier_block acpi_thermal_cpufreq_notifier_block = {
+	.notifier_call = acpi_thermal_cpufreq_notifier,
+};
+
+
+void acpi_thermal_cpufreq_init(void) {
+	int i;
+
+	for (i=0; i<NR_CPUS; i++)
+		cpufreq_thermal_reduction_pctg[i] = 0;
+
+	i = cpufreq_register_notifier(&acpi_thermal_cpufreq_notifier_block, CPUFREQ_POLICY_NOTIFIER);
+	if (!i)
+		acpi_thermal_cpufreq_is_init = 1;
+}
+
+void acpi_thermal_cpufreq_exit(void) {
+	if (acpi_thermal_cpufreq_is_init)
+		cpufreq_unregister_notifier(&acpi_thermal_cpufreq_notifier_block, CPUFREQ_POLICY_NOTIFIER);
+
+	acpi_thermal_cpufreq_is_init = 0;
+}
+
+#else /* ! CONFIG_CPU_FREQ */
+
+static int acpi_thermal_cpufreq_increase(unsigned int cpu) { return -ENODEV; }
+static int acpi_thermal_cpufreq_decrease(unsigned int cpu) { return -ENODEV; }
+
+
+#endif
+
+
+int
+acpi_processor_set_thermal_limit (
+	acpi_handle		handle,
+	int			type)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = NULL;
+	struct acpi_device	*device = NULL;
+	int			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_thermal_limit");
+
+	if ((type < ACPI_PROCESSOR_LIMIT_NONE)
+		|| (type > ACPI_PROCESSOR_LIMIT_DECREMENT))
+		return_VALUE(-EINVAL);
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	pr = (struct acpi_processor *) acpi_driver_data(device);
+	if (!pr)
+		return_VALUE(-ENODEV);
+
+	/* Thermal limits are always relative to the current Px/Tx state. */
+	if (pr->flags.throttling)
+		pr->limit.thermal.tx = pr->throttling.state;
+
+	/*
+	 * Our default policy is to only use throttling at the lowest
+	 * performance state.
+	 */
+
+	tx = pr->limit.thermal.tx;
+
+	switch (type) {
+
+	case ACPI_PROCESSOR_LIMIT_NONE:
+		do {
+			result = acpi_thermal_cpufreq_decrease(pr->id);
+		} while (!result);
+		tx = 0;
+		break;
+
+	case ACPI_PROCESSOR_LIMIT_INCREMENT:
+		/* if going up: P-states first, T-states later */
+
+		result = acpi_thermal_cpufreq_increase(pr->id);
+		if (!result)
+			goto end;
+		else if (result == -ERANGE)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"At maximum performance state\n"));
+
+		if (pr->flags.throttling) {
+			if (tx == (pr->throttling.state_count - 1))
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"At maximum throttling state\n"));
+			else
+				tx++;
+		}
+		break;
+
+	case ACPI_PROCESSOR_LIMIT_DECREMENT:
+		/* if going down: T-states first, P-states later */
+
+		if (pr->flags.throttling) {
+			if (tx == 0)
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"At minimum throttling state\n"));
+			else {
+				tx--;
+				goto end;
+			}
+		}
+
+		result = acpi_thermal_cpufreq_decrease(pr->id);
+		if (result == -ERANGE)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"At minimum performance state\n"));
+
+		break;
+	}
+
+end:
+	if (pr->flags.throttling) {
+		pr->limit.thermal.px = 0;
+		pr->limit.thermal.tx = tx;
+
+		result = acpi_processor_apply_limit(pr);
+		if (result)
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					  "Unable to set thermal limit\n"));
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Thermal limit now (P%d:T%d)\n",
+				  pr->limit.thermal.px,
+				  pr->limit.thermal.tx));
+	} else
+		result = 0;
+
+	return_VALUE(result);
+}
+
+
+int
+acpi_processor_get_limit_info (
+	struct acpi_processor	*pr)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_get_limit_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (pr->flags.throttling)
+		pr->flags.limit = 1;
+
+	return_VALUE(0);
+}
+
+
+/* /proc interface */
+
+static int acpi_processor_limit_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_limit_seq_show");
+
+	if (!pr)
+		goto end;
+
+	if (!pr->flags.limit) {
+		seq_puts(seq, "<not supported>\n");
+		goto end;
+	}
+
+	seq_printf(seq, "active limit:            P%d:T%d\n"
+			"user limit:              P%d:T%d\n"
+			"thermal limit:           P%d:T%d\n",
+			pr->limit.state.px, pr->limit.state.tx,
+			pr->limit.user.px, pr->limit.user.tx,
+			pr->limit.thermal.px, pr->limit.thermal.tx);
+
+end:
+	return_VALUE(0);
+}
+
+int acpi_processor_limit_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_processor_limit_seq_show,
+						PDE(inode)->data);
+}
+
+ssize_t acpi_processor_write_limit (
+	struct file		*file,
+	const char		__user *buffer,
+	size_t			count,
+	loff_t			*data)
+{
+	int			result = 0;
+        struct seq_file 	*m = (struct seq_file *)file->private_data;
+	struct acpi_processor	*pr = (struct acpi_processor *)m->private;
+	char			limit_string[25] = {'\0'};
+	int			px = 0;
+	int			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_limit");
+
+	if (!pr || (count > sizeof(limit_string) - 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	if (copy_from_user(limit_string, buffer, count)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
+		return_VALUE(-EFAULT);
+	}
+
+	limit_string[count] = '\0';
+
+	if (sscanf(limit_string, "%d:%d", &px, &tx) != 2) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	if (pr->flags.throttling) {
+		if ((tx < 0) || (tx > (pr->throttling.state_count - 1))) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid tx\n"));
+			return_VALUE(-EINVAL);
+		}
+		pr->limit.user.tx = tx;
+	}
+
+	result = acpi_processor_apply_limit(pr);
+
+	return_VALUE(count);
+}
+
+
+struct file_operations acpi_processor_limit_fops = {
+	.open 		= acpi_processor_limit_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
diff -Nru a/drivers/acpi/processor_throttling.c b/drivers/acpi/processor_throttling.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/acpi/processor_throttling.c	2005-01-06 15:06:41 -05:00
@@ -0,0 +1,351 @@
+/*
+ * processor_throttling.c - Throttling submodule of the ACPI processor driver
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>
+ *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
+ *  			- Added processor hotplug support
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/processor.h>
+
+#define ACPI_PROCESSOR_COMPONENT        0x01000000
+#define ACPI_PROCESSOR_CLASS            "processor"
+#define ACPI_PROCESSOR_DRIVER_NAME      "ACPI Processor Driver"
+#define _COMPONENT              ACPI_PROCESSOR_COMPONENT
+ACPI_MODULE_NAME                ("acpi_processor")
+
+
+/* --------------------------------------------------------------------------
+                              Throttling Control
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_get_throttling (
+	struct acpi_processor	*pr)
+{
+	int			state = 0;
+	u32			value = 0;
+	u32			duty_mask = 0;
+	u32			duty_value = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.throttling)
+		return_VALUE(-ENODEV);
+
+	pr->throttling.state = 0;
+
+	duty_mask = pr->throttling.state_count - 1;
+
+	duty_mask <<= pr->throttling.duty_offset;
+
+	local_irq_disable();
+
+	value = inl(pr->throttling.address);
+
+	/*
+	 * Compute the current throttling state when throttling is enabled
+	 * (bit 4 is on).
+	 */
+	if (value & 0x10) {
+		duty_value = value & duty_mask;
+		duty_value >>= pr->throttling.duty_offset;
+
+		if (duty_value)
+			state = pr->throttling.state_count-duty_value;
+	}
+
+	pr->throttling.state = state;
+
+	local_irq_enable();
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"Throttling state is T%d (%d%% throttling applied)\n",
+		state, pr->throttling.states[state].performance));
+
+	return_VALUE(0);
+}
+
+
+int acpi_processor_set_throttling (
+	struct acpi_processor	*pr,
+	int			state)
+{
+	u32                     value = 0;
+	u32                     duty_mask = 0;
+	u32                     duty_value = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_throttling");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if ((state < 0) || (state > (pr->throttling.state_count - 1)))
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.throttling)
+		return_VALUE(-ENODEV);
+
+	if (state == pr->throttling.state)
+		return_VALUE(0);
+
+	/*
+	 * Calculate the duty_value and duty_mask.
+	 */
+	if (state) {
+		duty_value = pr->throttling.state_count - state;
+
+		duty_value <<= pr->throttling.duty_offset;
+
+		/* Used to clear all duty_value bits */
+		duty_mask = pr->throttling.state_count - 1;
+
+		duty_mask <<= acpi_fadt.duty_offset;
+		duty_mask = ~duty_mask;
+	}
+
+	local_irq_disable();
+
+	/*
+	 * Disable throttling by writing a 0 to bit 4.  Note that we must
+	 * turn it off before you can change the duty_value.
+	 */
+	value = inl(pr->throttling.address);
+	if (value & 0x10) {
+		value &= 0xFFFFFFEF;
+		outl(value, pr->throttling.address);
+	}
+
+	/*
+	 * Write the new duty_value and then enable throttling.  Note
+	 * that a state value of 0 leaves throttling disabled.
+	 */
+	if (state) {
+		value &= duty_mask;
+		value |= duty_value;
+		outl(value, pr->throttling.address);
+
+		value |= 0x00000010;
+		outl(value, pr->throttling.address);
+	}
+
+	pr->throttling.state = state;
+
+	local_irq_enable();
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"Throttling state set to T%d (%d%%)\n", state,
+		(pr->throttling.states[state].performance?pr->throttling.states[state].performance/10:0)));
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_processor_get_throttling_info (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	int			step = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling_info");
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\n",
+		pr->throttling.address,
+		pr->throttling.duty_offset,
+		pr->throttling.duty_width));
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/* TBD: Support ACPI 2.0 objects */
+
+	if (!pr->throttling.address) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling register\n"));
+		return_VALUE(0);
+	}
+	else if (!pr->throttling.duty_width) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling states\n"));
+		return_VALUE(0);
+	}
+	/* TBD: Support duty_cycle values that span bit 4. */
+	else if ((pr->throttling.duty_offset
+		+ pr->throttling.duty_width) > 4) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "duty_cycle spans bit 4\n"));
+		return_VALUE(0);
+	}
+
+	/*
+	 * PIIX4 Errata: We don't support throttling on the original PIIX4.
+	 * This shouldn't be an issue as few (if any) mobile systems ever
+	 * used this part.
+	 */
+	if (errata.piix4.throttle) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Throttling not supported on PIIX4 A- or B-step\n"));
+		return_VALUE(0);
+	}
+
+	pr->throttling.state_count = 1 << acpi_fadt.duty_width;
+
+	/*
+	 * Compute state values. Note that throttling displays a linear power/
+	 * performance relationship (at 50% performance the CPU will consume
+	 * 50% power).  Values are in 1/10th of a percent to preserve accuracy.
+	 */
+
+	step = (1000 / pr->throttling.state_count);
+
+	for (i=0; i<pr->throttling.state_count; i++) {
+		pr->throttling.states[i].performance = step * i;
+		pr->throttling.states[i].power = step * i;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d throttling states\n",
+		pr->throttling.state_count));
+
+	pr->flags.throttling = 1;
+
+	/*
+	 * Disable throttling (if enabled).  We'll let subsequent policy (e.g.
+	 * thermal) decide to lower performance if it so chooses, but for now
+	 * we'll crank up the speed.
+	 */
+
+	result = acpi_processor_get_throttling(pr);
+	if (result)
+		goto end;
+
+	if (pr->throttling.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Disabling throttling (was T%d)\n",
+			pr->throttling.state));
+		result = acpi_processor_set_throttling(pr, 0);
+		if (result)
+			goto end;
+	}
+
+end:
+	if (result)
+		pr->flags.throttling = 0;
+
+	return_VALUE(result);
+}
+
+
+/* proc interface */
+
+static int acpi_processor_throttling_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
+	int			i = 0;
+	int                     result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_throttling_seq_show");
+
+	if (!pr)
+		goto end;
+
+	if (!(pr->throttling.state_count > 0)) {
+		seq_puts(seq, "<not supported>\n");
+		goto end;
+	}
+
+	result = acpi_processor_get_throttling(pr);
+
+	if (result) {
+		seq_puts(seq, "Could not determine current throttling state.\n");
+		goto end;
+	}
+
+	seq_printf(seq, "state count:             %d\n"
+			"active state:            T%d\n",
+			pr->throttling.state_count,
+			pr->throttling.state);
+
+	seq_puts(seq, "states:\n");
+	for (i = 0; i < pr->throttling.state_count; i++)
+		seq_printf(seq, "   %cT%d:                  %02d%%\n",
+			(i == pr->throttling.state?'*':' '), i,
+			(pr->throttling.states[i].performance?pr->throttling.states[i].performance/10:0));
+
+end:
+	return_VALUE(0);
+}
+
+int acpi_processor_throttling_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_processor_throttling_seq_show,
+						PDE(inode)->data);
+}
+
+ssize_t acpi_processor_write_throttling (
+        struct file		*file,
+        const char		__user *buffer,
+        size_t			count,
+        loff_t			*data)
+{
+	int			result = 0;
+        struct seq_file 	*m = (struct seq_file *)file->private_data;
+	struct acpi_processor	*pr = (struct acpi_processor *)m->private;
+	char			state_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_throttling");
+
+	if (!pr || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+
+	state_string[count] = '\0';
+
+	result = acpi_processor_set_throttling(pr,
+		simple_strtoul(state_string, NULL, 0));
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+struct file_operations acpi_processor_throttling_fops = {
+	.open 		= acpi_processor_throttling_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
diff -Nru a/drivers/acpi/scan.c b/drivers/acpi/scan.c
--- a/drivers/acpi/scan.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/scan.c	2005-01-06 15:06:41 -05:00
@@ -2,9 +2,9 @@
  * scan.c - support for transforming the ACPI namespace into individual objects
  */
 
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/acpi.h>
-#include <linux/module.h>
 
 #include <acpi/acpi_drivers.h>
 #include <acpi/acinterp.h>	/* for acpi_ex_eisa_id_to_string() */
@@ -35,7 +35,49 @@
 	kfree(dev);
 }
 
+struct acpi_device_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct acpi_device *, char *);
+	ssize_t (*store)(struct acpi_device *, const char *, size_t);
+};
+
+typedef void acpi_device_sysfs_files(struct kobject *,
+				const struct attribute *);
+
+static void setup_sys_fs_device_files(struct acpi_device *dev,
+		acpi_device_sysfs_files *func);
+
+#define create_sysfs_device_files(dev)	\
+	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_create_file)
+#define remove_sysfs_device_files(dev)	\
+	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_remove_file)
+
+
+#define to_acpi_device(n) container_of(n, struct acpi_device, kobj)
+#define to_handle_attr(n) container_of(n, struct acpi_device_attribute, attr);
+
+static ssize_t acpi_device_attr_show(struct kobject *kobj,
+		struct attribute *attr, char *buf)
+{
+	struct acpi_device *device = to_acpi_device(kobj);
+	struct acpi_device_attribute *attribute = to_handle_attr(attr);
+	return attribute->show ? attribute->show(device, buf) : 0;
+}
+static ssize_t acpi_device_attr_store(struct kobject *kobj,
+		struct attribute *attr, const char *buf, size_t len)
+{
+	struct acpi_device *device = to_acpi_device(kobj);
+	struct acpi_device_attribute *attribute = to_handle_attr(attr);
+	return attribute->store ? attribute->store(device, buf, len) : len;
+}
+
+static struct sysfs_ops acpi_device_sysfs_ops = {
+	.show	= acpi_device_attr_show,
+	.store	= acpi_device_attr_store,
+};
+
 static struct kobj_type ktype_acpi_ns = {
+	.sysfs_ops	= &acpi_device_sysfs_ops,
 	.release	= acpi_device_release,
 };
 
@@ -58,6 +100,7 @@
 	INIT_LIST_HEAD(&device->children);
 	INIT_LIST_HEAD(&device->node);
 	INIT_LIST_HEAD(&device->g_list);
+	INIT_LIST_HEAD(&device->wakeup_list);
 
 	spin_lock(&acpi_device_lock);
 	if (device->parent) {
@@ -65,15 +108,17 @@
 		list_add_tail(&device->g_list,&device->parent->g_list);
 	} else
 		list_add_tail(&device->g_list,&acpi_device_list);
+	if (device->wakeup.flags.valid)
+		list_add_tail(&device->wakeup_list,&acpi_wakeup_device_list);
 	spin_unlock(&acpi_device_lock);
 
-	kobject_init(&device->kobj);
 	strlcpy(device->kobj.name,device->pnp.bus_id,KOBJ_NAME_LEN);
 	if (parent)
 		device->kobj.parent = &parent->kobj;
 	device->kobj.ktype = &ktype_acpi_ns;
 	device->kobj.kset = &acpi_namespace_kset;
-	kobject_add(&device->kobj);
+	kobject_register(&device->kobj);
+	create_sysfs_device_files(device);
 }
 
 static int
@@ -81,6 +126,19 @@
 	struct acpi_device	*device, 
 	int			type)
 {
+	spin_lock(&acpi_device_lock);
+	if (device->parent) {
+		list_del(&device->node);
+		list_del(&device->g_list);
+	} else
+		list_del(&device->g_list);
+
+	list_del(&device->wakeup_list);
+
+	spin_unlock(&acpi_device_lock);
+
+	acpi_detach_data(device->handle, acpi_bus_data_handler);
+	remove_sysfs_device_files(device);
 	kobject_unregister(&device->kobj);
 	return 0;
 }
@@ -272,12 +330,6 @@
 	if (!acpi_match_ids(device, "PNP0C0D,PNP0C0C,PNP0C0E"))
 		device->wakeup.flags.run_wake = 1;
 
-	/* TBD: lock */
-	INIT_LIST_HEAD(&device->wakeup_list);
-	spin_lock(&acpi_device_lock);
-	list_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);
-	spin_unlock(&acpi_device_lock);
-
 end:
 	if (ACPI_FAILURE(status))
 		device->flags.wake_capable = 0;
@@ -285,6 +337,114 @@
 }
 
 /* --------------------------------------------------------------------------
+		ACPI hotplug sysfs device file support
+   -------------------------------------------------------------------------- */
+static ssize_t acpi_eject_store(struct acpi_device *device, 
+		const char *buf, size_t count);
+
+#define ACPI_DEVICE_ATTR(_name,_mode,_show,_store) \
+static struct acpi_device_attribute acpi_device_attr_##_name = \
+		__ATTR(_name, _mode, _show, _store)
+
+ACPI_DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
+
+/**
+ * setup_sys_fs_device_files - sets up the device files under device namespace
+ * @@dev:	acpi_device object
+ * @@func:	function pointer to create or destroy the device file
+ */
+static void
+setup_sys_fs_device_files (
+	struct acpi_device *dev,
+	acpi_device_sysfs_files *func)
+{
+	if (dev->flags.ejectable == 1)
+		(*(func))(&dev->kobj,&acpi_device_attr_eject.attr);
+}
+
+static int
+acpi_eject_operation(acpi_handle handle, int lockable)
+{
+	struct acpi_object_list arg_list;
+	union acpi_object arg;
+	acpi_status status = AE_OK;
+
+	/*
+	 * TBD: evaluate _PS3?
+	 */
+
+	if (lockable) {
+		arg_list.count = 1;
+		arg_list.pointer = &arg;
+		arg.type = ACPI_TYPE_INTEGER;
+		arg.integer.value = 0;
+		acpi_evaluate_object(handle, "_LCK", &arg_list, NULL);
+	}
+
+	arg_list.count = 1;
+	arg_list.pointer = &arg;
+	arg.type = ACPI_TYPE_INTEGER;
+	arg.integer.value = 1;
+
+	/*
+	 * TBD: _EJD support.
+	 */
+
+	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
+	if (ACPI_FAILURE(status)) {
+		return(-ENODEV);
+	}
+
+	return(0);
+}
+
+
+static ssize_t
+acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
+{
+	int	result;
+	int	ret = count;
+	int	islockable;
+	acpi_status	status;
+	acpi_handle	handle;
+	acpi_object_type	type = 0;
+
+	if ((!count) || (buf[0] != '1')) {
+		return -EINVAL;
+	}
+
+#ifndef FORCE_EJECT
+	if (device->driver == NULL) {
+		ret = -ENODEV;
+		goto err;
+	}
+#endif
+	status = acpi_get_type(device->handle, &type);
+	if (ACPI_FAILURE(status) || (!device->flags.ejectable) ) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	islockable = device->flags.lockable;
+	handle = device->handle;
+
+	if (type == ACPI_TYPE_PROCESSOR)
+		result = acpi_bus_trim(device, 0);
+	else
+		result = acpi_bus_trim(device, 1);
+
+	if (!result)
+		result = acpi_eject_operation(handle, islockable);
+
+	if (result) {
+		ret = -EBUSY;
+	}
+err:
+	return ret;
+}
+
+
+/* --------------------------------------------------------------------------
                               Performance Management
    -------------------------------------------------------------------------- */
 
@@ -727,7 +887,7 @@
 #ifdef CONFIG_ACPI_DEBUG_OUTPUT
 	char		*type_string = NULL;
 	char		name[80] = {'?','\0'};
-	acpi_buffer	buffer = {sizeof(name), name};
+	struct acpi_buffer	buffer = {sizeof(name), name};
 
 	switch (type) {
 	case ACPI_BUS_TYPE_DEVICE:
@@ -764,7 +924,55 @@
 #endif /*CONFIG_ACPI_DEBUG_OUTPUT*/
 }
 
-int 
+
+int
+acpi_bus_remove (
+	struct acpi_device *dev,
+	int rmdevice)
+{
+	int 			result = 0;
+	struct acpi_driver	*driver;
+	
+	ACPI_FUNCTION_TRACE("acpi_bus_remove");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	driver = dev->driver;
+
+	if ((driver) && (driver->ops.remove)) {
+
+		if (driver->ops.stop) {
+			result = driver->ops.stop(dev, ACPI_BUS_REMOVAL_EJECT);
+			if (result)
+				return_VALUE(result);
+		}
+
+		result = dev->driver->ops.remove(dev, ACPI_BUS_REMOVAL_EJECT);
+		if (result) {
+			return_VALUE(result);
+		}
+
+		atomic_dec(&dev->driver->references);
+		dev->driver = NULL;
+		acpi_driver_data(dev) = NULL;
+	}
+
+	if (!rmdevice)
+		return_VALUE(0);
+
+	if (dev->flags.bus_address) {
+		if ((dev->parent) && (dev->parent->ops.unbind))
+			dev->parent->ops.unbind(dev);
+	}
+	
+	acpi_device_unregister(dev, ACPI_BUS_REMOVAL_EJECT);
+
+	return_VALUE(0);
+}
+
+
+int
 acpi_bus_add (
 	struct acpi_device	**child,
 	struct acpi_device	*parent,
@@ -911,7 +1119,7 @@
 EXPORT_SYMBOL(acpi_bus_add);
 
 
-static int acpi_bus_scan (struct acpi_device	*start)
+int acpi_bus_scan (struct acpi_device	*start)
 {
 	acpi_status		status = AE_OK;
 	struct acpi_device	*parent = NULL;
@@ -1014,6 +1222,62 @@
 }
 EXPORT_SYMBOL(acpi_bus_scan);
 
+
+int
+acpi_bus_trim(struct acpi_device	*start,
+		int rmdevice)
+{
+	acpi_status		status;
+	struct acpi_device	*parent, *child;
+	acpi_handle		phandle, chandle;
+	acpi_object_type	type;
+	u32			level = 1;
+	int			err = 0;
+
+	parent  = start;
+	phandle = start->handle;
+	child = chandle = NULL;
+
+	while ((level > 0) && parent && (!err)) {
+		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
+			chandle, &chandle);
+
+		/*
+		 * If this scope is exhausted then move our way back up.
+		 */
+		if (ACPI_FAILURE(status)) {
+			level--;
+			chandle = phandle;
+			acpi_get_parent(phandle, &phandle);
+			child = parent;
+			parent = parent->parent;
+
+			if (level == 0)
+				err = acpi_bus_remove(child, rmdevice);
+			else
+				err = acpi_bus_remove(child, 1);
+
+			continue;
+		}
+
+		status = acpi_get_type(chandle, &type);
+		if (ACPI_FAILURE(status)) {
+			continue;
+		}
+		/*
+		 * If there is a device corresponding to chandle then
+		 * parse it (depth-first).
+		 */
+		if (acpi_bus_get_device(chandle, &child) == 0) {
+			level++;
+			phandle = chandle;
+			chandle = NULL;
+			parent = child;
+		}
+		continue;
+	}
+	return err;
+}
 
 static int
 acpi_bus_scan_fixed (
diff -Nru a/drivers/acpi/sleep/proc.c b/drivers/acpi/sleep/proc.c
--- a/drivers/acpi/sleep/proc.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/sleep/proc.c	2005-01-06 15:06:41 -05:00
@@ -83,6 +83,7 @@
 {
 	u32			sec, min, hr;
 	u32			day, mo, yr;
+	unsigned char		rtc_control = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_system_alarm_seq_show");
 
@@ -91,10 +92,12 @@
 	sec = CMOS_READ(RTC_SECONDS_ALARM);
 	min = CMOS_READ(RTC_MINUTES_ALARM);
 	hr = CMOS_READ(RTC_HOURS_ALARM);
+	rtc_control = CMOS_READ(RTC_CONTROL);
 
-#if 0	/* If we ever get an FACP with proper values... */
+	/* If we ever get an FACP with proper values... */
 	if (acpi_gbl_FADT->day_alrm)
-		day = CMOS_READ(acpi_gbl_FADT->day_alrm);
+		/* ACPI spec: only low 6 its should be cared */
+		day = CMOS_READ(acpi_gbl_FADT->day_alrm) & 0x3F;
 	else
 		day =  CMOS_READ(RTC_DAY_OF_MONTH);
 	if (acpi_gbl_FADT->mon_alrm)
@@ -105,24 +108,20 @@
 		yr = CMOS_READ(acpi_gbl_FADT->century) * 100 + CMOS_READ(RTC_YEAR);
 	else
 		yr = CMOS_READ(RTC_YEAR);
-#else
-	day = CMOS_READ(RTC_DAY_OF_MONTH);
-	mo = CMOS_READ(RTC_MONTH);
-	yr = CMOS_READ(RTC_YEAR);
-#endif
 
 	spin_unlock(&rtc_lock);
 
-	BCD_TO_BIN(sec);
-	BCD_TO_BIN(min);
-	BCD_TO_BIN(hr);
-	BCD_TO_BIN(day);
-	BCD_TO_BIN(mo);
-	BCD_TO_BIN(yr);
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		BCD_TO_BIN(sec);
+		BCD_TO_BIN(min);
+		BCD_TO_BIN(hr);
+		BCD_TO_BIN(day);
+		BCD_TO_BIN(mo);
+		BCD_TO_BIN(yr);
+	}
 
-#if 0
 	/* we're trusting the FADT (see above)*/
-#else
+	if (!acpi_gbl_FADT->century)
 	/* If we're not trusting the FADT, we should at least make it
 	 * right for _this_ century... ehm, what is _this_ century?
 	 *
@@ -141,8 +140,7 @@
 	 *        s/2000/2100
 	 *
 	 */
-	yr += 2000;
-#endif
+		yr += 2000;
 
 	seq_printf(seq,"%4.4u-", yr);
 	(mo > 12)  ? seq_puts(seq, "**-")  : seq_printf(seq, "%2.2u-", mo);
@@ -316,6 +314,13 @@
 	}
 
 	spin_lock_irq(&rtc_lock);
+	/*
+	 * Disable alarm interrupt before setting alarm timer or else
+	 * when ACPI_EVENT_RTC is enabled, a spurious ACPI interrupt occurs
+	 */
+	rtc_control &= ~RTC_AIE;
+	CMOS_WRITE(rtc_control, RTC_CONTROL);
+	CMOS_READ(RTC_INTR_FLAGS);
 
 	/* write the fields the rtc knows about */
 	CMOS_WRITE(hr, RTC_HOURS_ALARM);
@@ -327,24 +332,21 @@
 	 * offsets into the CMOS RAM here -- which for some reason are pointing
 	 * to the RTC area of memory.
 	 */
-#if 0
 	if (acpi_gbl_FADT->day_alrm)
 		CMOS_WRITE(day, acpi_gbl_FADT->day_alrm);
 	if (acpi_gbl_FADT->mon_alrm)
 		CMOS_WRITE(mo, acpi_gbl_FADT->mon_alrm);
 	if (acpi_gbl_FADT->century)
 		CMOS_WRITE(yr/100, acpi_gbl_FADT->century);
-#endif
 	/* enable the rtc alarm interrupt */
-	if (!(rtc_control & RTC_AIE)) {
-		rtc_control |= RTC_AIE;
-		CMOS_WRITE(rtc_control,RTC_CONTROL);
-		CMOS_READ(RTC_INTR_FLAGS);
-	}
+	rtc_control |= RTC_AIE;
+	CMOS_WRITE(rtc_control, RTC_CONTROL);
+	CMOS_READ(RTC_INTR_FLAGS);
 
 	spin_unlock_irq(&rtc_lock);
 
-	acpi_set_register(ACPI_BITREG_RT_CLOCK_ENABLE, 1, ACPI_MTX_LOCK);
+	acpi_clear_event(ACPI_EVENT_RTC);
+	acpi_enable_event(ACPI_EVENT_RTC, 0);
 
 	*ppos += count;
 
@@ -395,6 +397,7 @@
 	char		strbuf[5];
 	char		str[5] = "";
 	int 		len = count;
+	struct acpi_device *found_dev = NULL;
 
 	if (len > 4) len = 4;
 
@@ -411,9 +414,25 @@
 
 		if (!strncmp(dev->pnp.bus_id, str, 4)) {
 			dev->wakeup.state.enabled = dev->wakeup.state.enabled ? 0:1;
+			found_dev = dev;
 			break;
 		}
 	}
+	if (found_dev) {
+		list_for_each_safe(node, next, &acpi_wakeup_device_list) {
+			struct acpi_device * dev = container_of(node,
+				struct acpi_device, wakeup_list);
+
+			if ((dev != found_dev) &&
+				(dev->wakeup.gpe_number == found_dev->wakeup.gpe_number) &&
+				(dev->wakeup.gpe_device == found_dev->wakeup.gpe_device)) {
+				printk(KERN_WARNING "ACPI: '%s' and '%s' have the same GPE, "
+					"can't disable/enable one seperately\n",
+					dev->pnp.bus_id, found_dev->pnp.bus_id);
+				dev->wakeup.state.enabled = found_dev->wakeup.state.enabled;
+			}
+		}
+	}
 	spin_unlock(&acpi_device_lock);
 	return count;
 }
@@ -449,6 +468,14 @@
 };
 
 
+static u32 rtc_handler(void * context)
+{
+	acpi_clear_event(ACPI_EVENT_RTC);
+	acpi_disable_event(ACPI_EVENT_RTC, 0);
+
+	return ACPI_INTERRUPT_HANDLED;
+}
+
 static int acpi_sleep_proc_init(void)
 {
 	struct proc_dir_entry	*entry = NULL;
@@ -474,6 +501,7 @@
 	if (entry)
 		entry->proc_fops = &acpi_system_wakeup_device_fops;
 
+	acpi_install_fixed_event_handler(ACPI_EVENT_RTC, rtc_handler, NULL);
 	return 0;
 }
 
diff -Nru a/drivers/acpi/tables/tbconvrt.c b/drivers/acpi/tables/tbconvrt.c
--- a/drivers/acpi/tables/tbconvrt.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/tables/tbconvrt.c	2005-01-06 15:06:41 -05:00
@@ -190,7 +190,7 @@
 	new_gas_struct->address_space_id = ACPI_ADR_SPACE_SYSTEM_IO;
 	new_gas_struct->register_bit_width = register_bit_width;
 	new_gas_struct->register_bit_offset = 0;
-	new_gas_struct->reserved        = 0;
+	new_gas_struct->access_width    = 0;
 }
 
 
@@ -510,7 +510,7 @@
  *
  * FUNCTION:    acpi_tb_convert_table_facs
  *
- * PARAMETERS:  table_info      - Info for currently installad FACS
+ * PARAMETERS:  table_info      - Info for currently installed FACS
  *
  * RETURN:      Status
  *
diff -Nru a/drivers/acpi/tables/tbrsdt.c b/drivers/acpi/tables/tbrsdt.c
--- a/drivers/acpi/tables/tbrsdt.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/tables/tbrsdt.c	2005-01-06 15:06:41 -05:00
@@ -277,6 +277,7 @@
 
 	acpi_tb_get_rsdt_address (&address);
 
+	table_info.type = ACPI_TABLE_XSDT;
 	status = acpi_tb_get_table (&address, &table_info);
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not get the RSDT/XSDT, %s\n",
diff -Nru a/drivers/acpi/tables/tbxfroot.c b/drivers/acpi/tables/tbxfroot.c
--- a/drivers/acpi/tables/tbxfroot.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/tables/tbxfroot.c	2005-01-06 15:06:41 -05:00
@@ -387,35 +387,58 @@
 	u8                              *start_address,
 	u32                             length)
 {
-	u32                             offset;
 	u8                              *mem_rover;
+	u8                              *end_address;
+	u8                              checksum;
 
 
 	ACPI_FUNCTION_TRACE ("tb_scan_memory_for_rsdp");
 
 
-	/* Search from given start addr for the requested length  */
+	end_address = start_address + length;
 
-	for (offset = 0, mem_rover = start_address;
-		 offset < length;
-		 offset += ACPI_RSDP_SCAN_STEP, mem_rover += ACPI_RSDP_SCAN_STEP) {
+	/* Search from given start address for the requested length */
 
+	for (mem_rover = start_address; mem_rover < end_address;
+		 mem_rover += ACPI_RSDP_SCAN_STEP) {
 		/* The signature and checksum must both be correct */
 
-		if (ACPI_STRNCMP ((char *) mem_rover,
-				RSDP_SIG, sizeof (RSDP_SIG)-1) == 0 &&
-			acpi_tb_checksum (mem_rover, ACPI_RSDP_CHECKSUM_LENGTH) == 0) {
-			/* If so, we have found the RSDP */
+		if (ACPI_STRNCMP ((char *) mem_rover, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
+			/* No signature match, keep looking */
+
+			continue;
+		}
+
+		/* Signature matches, check the appropriate checksum */
+
+		if (((struct rsdp_descriptor *) mem_rover)->revision < 2) {
+			/* ACPI version 1.0 */
+
+			checksum = acpi_tb_checksum (mem_rover, ACPI_RSDP_CHECKSUM_LENGTH);
+		}
+		else {
+			/* Post ACPI 1.0, use extended_checksum */
+
+			checksum = acpi_tb_checksum (mem_rover, ACPI_RSDP_XCHECKSUM_LENGTH);
+		}
+
+		if (checksum == 0) {
+			/* Checksum valid, we have found a valid RSDP */
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-				"RSDP located at physical address %p\n",mem_rover));
+				"RSDP located at physical address %p\n", mem_rover));
 			return_PTR (mem_rover);
 		}
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			"Found an RSDP at physical address %p, but it has a bad checksum\n",
+			mem_rover));
 	}
 
 	/* Searched entire block, no RSDP was found */
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,"Searched entire block, no RSDP was found.\n"));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"Searched entire block, no valid RSDP was found.\n"));
 	return_PTR (NULL);
 }
 
diff -Nru a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
--- a/drivers/acpi/thermal.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/thermal.c	2005-01-06 15:06:41 -05:00
@@ -64,6 +64,7 @@
 #define ACPI_THERMAL_PATH_POWEROFF	"/sbin/poweroff"
 
 #define ACPI_THERMAL_MAX_ACTIVE	10
+#define ACPI_THERMAL_MAX_LIMIT_STR_LEN 65
 
 #define KELVIN_TO_CELSIUS(t)    (long)(((long)t-2732>=0) ? ((long)t-2732+5)/10 : ((long)t-2732-5)/10)
 #define CELSIUS_TO_KELVIN(t)	((t+273)*10)
@@ -899,21 +900,33 @@
 	struct seq_file		*m = (struct seq_file *)file->private_data;
 	struct acpi_thermal	*tz = (struct acpi_thermal *)m->private;
 
-	char			limit_string[65] = {'\0'};
+	char			*limit_string; 
 	int			num, critical, hot, passive;
-	int			active[ACPI_THERMAL_MAX_ACTIVE];
+	int			*active; 
 	int			i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_write_trip_points");
 
-	if (!tz || (count > sizeof(limit_string) - 1)) {
+	limit_string = kmalloc(ACPI_THERMAL_MAX_LIMIT_STR_LEN, GFP_KERNEL);
+	if(!limit_string)
+		return_VALUE(-ENOMEM);
+
+	memset(limit_string, 0, ACPI_THERMAL_MAX_LIMIT_STR_LEN);
+
+	active = kmalloc(ACPI_THERMAL_MAX_ACTIVE *sizeof(int), GFP_KERNEL);
+	if(!active)
+		return_VALUE(-ENOMEM);
+
+	if (!tz || (count > ACPI_THERMAL_MAX_LIMIT_STR_LEN - 1)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
-		return_VALUE(-EINVAL);
+		count = -EINVAL;
+		goto end;
 	}
 	
 	if (copy_from_user(limit_string, buffer, count)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
-		return_VALUE(-EFAULT);
+		count = -EFAULT;
+		goto end;
 	}
 	
 	limit_string[count] = '\0';
@@ -924,7 +937,8 @@
 				&active[5], &active[6], &active[7], &active[8], &active[9]);
 	if(!(num >=5 && num < (ACPI_THERMAL_MAX_ACTIVE + 3))) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
-		return_VALUE(-EINVAL);
+		count = -EINVAL;
+		goto end;
 	}
 
 	tz->trips.critical.temperature = CELSIUS_TO_KELVIN(critical);
@@ -936,6 +950,9 @@
 		tz->trips.active[i].temperature = CELSIUS_TO_KELVIN(active[i]);
 	}
 	
+end:
+	kfree(active);
+	kfree(limit_string);
 	return_VALUE(count);
 }
 
diff -Nru a/drivers/acpi/toshiba_acpi.c b/drivers/acpi/toshiba_acpi.c
--- a/drivers/acpi/toshiba_acpi.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/toshiba_acpi.c	2005-01-06 15:06:41 -05:00
@@ -508,7 +508,7 @@
 			proc->write_proc = (write_proc_t*)dispatch_write;
 	}
 
-	return(AE_OK);
+	return AE_OK;
 }
 
 static acpi_status __exit
@@ -518,7 +518,7 @@
 
 	for (item = proc_items; item->name; ++item)
 		remove_proc_entry(item->name, toshiba_proc_dir);
-	return(AE_OK);
+	return AE_OK;
 }
 
 static int __init
diff -Nru a/drivers/acpi/video.c b/drivers/acpi/video.c
--- a/drivers/acpi/video.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/acpi/video.c	2005-01-06 15:06:41 -05:00
@@ -242,6 +242,13 @@
 	.release	= single_release,
 };
 
+static char	device_decode[][30] = {
+	"motherboard VGA device",
+	"PCI VGA device",
+	"AGP VGA device",
+	"UNKNOWN",
+};
+
 static void acpi_video_device_notify ( acpi_handle handle, u32 event, void *data);
 static void acpi_video_device_rebind( struct acpi_video_bus *video);
 static void acpi_video_device_bind( struct acpi_video_bus *video, struct acpi_video_device *device);
@@ -1117,12 +1124,6 @@
 	struct acpi_video_bus	*video = (struct acpi_video_bus *) seq->private;
 	int			status;
 	unsigned long		id;
-	char			device_decode[][30] = {
-					"motherboard VGA device",
-					"PCI VGA device",
-					"AGP VGA device",
-					"UNKNOWN",
-	};
 
 	ACPI_FUNCTION_TRACE("acpi_video_bus_POST_seq_show");
 
@@ -1523,7 +1524,7 @@
 		dod->package.count));
 
 	active_device_list= kmalloc(
- 		dod->package.count*sizeof(struct acpi_video_enumerated_device),
+ 		(1+dod->package.count)*sizeof(struct acpi_video_enumerated_device),
 	       	GFP_KERNEL);
 
 	if (!active_device_list) {
diff -Nru a/drivers/base/cpu.c b/drivers/base/cpu.c
--- a/drivers/base/cpu.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/base/cpu.c	2005-01-06 15:06:41 -05:00
@@ -48,10 +48,23 @@
 }
 static SYSDEV_ATTR(online, 0600, show_online, store_online);
 
-static void __init register_cpu_control(struct cpu *cpu)
+static void __devinit register_cpu_control(struct cpu *cpu)
 {
 	sysdev_create_file(&cpu->sysdev, &attr_online);
 }
+void unregister_cpu(struct cpu *cpu, struct node *root)
+{
+
+	if (root)
+		sysfs_remove_link(&root->sysdev.kobj,
+				  kobject_name(&cpu->sysdev.kobj));
+	sysdev_remove_file(&cpu->sysdev, &attr_online);
+
+	sysdev_unregister(&cpu->sysdev);
+
+	return;
+}
+EXPORT_SYMBOL(unregister_cpu);
 #else /* ... !CONFIG_HOTPLUG_CPU */
 static inline void register_cpu_control(struct cpu *cpu)
 {
@@ -66,7 +79,7 @@
  *
  * Initialize and register the CPU device.
  */
-int __init register_cpu(struct cpu *cpu, int num, struct node *root)
+int __devinit register_cpu(struct cpu *cpu, int num, struct node *root)
 {
 	int error;
 
@@ -83,6 +96,9 @@
 		register_cpu_control(cpu);
 	return error;
 }
+#ifdef CONFIG_HOTPLUG_CPU
+EXPORT_SYMBOL(register_cpu);
+#endif
 
 
 
diff -Nru a/drivers/pci/quirks.c b/drivers/pci/quirks.c
--- a/drivers/pci/quirks.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/pci/quirks.c	2005-01-06 15:06:41 -05:00
@@ -479,26 +479,6 @@
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_3,	quirk_via_acpi );
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_4,	quirk_via_acpi );
 
-static void quirk_via_irqpic(struct pci_dev *dev)
-{
-	u8 irq, new_irq = dev->irq & 0xf;
-
-	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);
-
-	if (new_irq != irq) {
-		printk(KERN_INFO "PCI: Via IRQ fixup for %s, from %d to %d\n",
-		       pci_name(dev), irq, new_irq);
-
-		udelay(15);
-		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, new_irq);
-	}
-}
-DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_2,	quirk_via_irqpic );
-DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_5,	quirk_via_irqpic );
-DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_6,	quirk_via_irqpic );
-DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8233_5,	quirk_via_irqpic );
-
-
 /*
  * PIIX3 USB: We have to disable USB interrupts that are
  * hardwired to PIRQD# and may be shared with an
@@ -691,12 +671,14 @@
 /*
  *	VIA northbridges care about PCI_INTERRUPT_LINE
  */
-int interrupt_line_quirk;
+int via_interrupt_line_quirk;
 
 static void __devinit quirk_via_bridge(struct pci_dev *pdev)
 {
-	if(pdev->devfn == 0)
-		interrupt_line_quirk = 1;
+	if(pdev->devfn == 0) {
+		printk(KERN_INFO "PCI: Via IRQ fixup\n");
+		via_interrupt_line_quirk = 1;
+	}
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_ANY_ID,                     quirk_via_bridge );
 
diff -Nru a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
--- a/drivers/pnp/pnpacpi/core.c	2005-01-06 15:06:41 -05:00
+++ b/drivers/pnp/pnpacpi/core.c	2005-01-06 15:06:41 -05:00
@@ -236,6 +236,8 @@
 
 	if (!acpi_bus_get_device(handle, &device))
 		pnpacpi_add_device(device);
+	else
+		return AE_CTRL_DEPTH;
 	return AE_OK;
 }
 
@@ -247,9 +249,7 @@
 	}
 	pnp_info("PnP ACPI init");
 	pnp_register_protocol(&pnpacpi_protocol);
-	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
-			ACPI_UINT32_MAX, pnpacpi_add_device_handler,
-			NULL, NULL);
+	acpi_get_devices(NULL, pnpacpi_add_device_handler, NULL, NULL);
 	pnp_info("PnP ACPI: found %d devices", num);
 	return 0;
 }
diff -Nru a/include/acpi/acconfig.h b/include/acpi/acconfig.h
--- a/include/acpi/acconfig.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/acconfig.h	2005-01-06 15:06:41 -05:00
@@ -64,7 +64,7 @@
 
 /* Version string */
 
-#define ACPI_CA_VERSION                 0x20041105
+#define ACPI_CA_VERSION                 0x20041210
 
 /*
  * OS name, used for the _OS object.  The _OS object is essentially obsolete,
@@ -99,7 +99,7 @@
 
 /* Version of ACPI supported */
 
-#define ACPI_CA_SUPPORT_LEVEL           2
+#define ACPI_CA_SUPPORT_LEVEL           3
 
 /* String size constants */
 
diff -Nru a/include/acpi/acdisasm.h b/include/acpi/acdisasm.h
--- a/include/acpi/acdisasm.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/acdisasm.h	2005-01-06 15:06:41 -05:00
@@ -317,6 +317,12 @@
 	u32                             level);
 
 void
+acpi_dm_extended_descriptor (
+	struct asl_extended_address_desc   *resource,
+	u32                             length,
+	u32                             level);
+
+void
 acpi_dm_qword_descriptor (
 	struct asl_qword_address_desc   *resource,
 	u32                             length,
diff -Nru a/include/acpi/aclocal.h b/include/acpi/aclocal.h
--- a/include/acpi/aclocal.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/aclocal.h	2005-01-06 15:06:41 -05:00
@@ -862,7 +862,6 @@
 /*
  * Large resource descriptor types
  */
-
 #define ACPI_RDESC_TYPE_MEMORY_24               0x81
 #define ACPI_RDESC_TYPE_GENERAL_REGISTER        0x82
 #define ACPI_RDESC_TYPE_LARGE_VENDOR            0x84
@@ -872,6 +871,7 @@
 #define ACPI_RDESC_TYPE_WORD_ADDRESS_SPACE      0x88
 #define ACPI_RDESC_TYPE_EXTENDED_XRUPT          0x89
 #define ACPI_RDESC_TYPE_QWORD_ADDRESS_SPACE     0x8A
+#define ACPI_RDESC_TYPE_EXTENDED_ADDRESS_SPACE  0x8B
 
 
 /*****************************************************************************
diff -Nru a/include/acpi/acmacros.h b/include/acpi/acmacros.h
--- a/include/acpi/acmacros.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/acmacros.h	2005-01-06 15:06:41 -05:00
@@ -55,6 +55,7 @@
 
 #define ACPI_SET_BIT(target,bit)        ((target) |= (bit))
 #define ACPI_CLEAR_BIT(target,bit)      ((target) &= ~(bit))
+#define ACPI_MIN(a,b)                   (((a)<(b))?(a):(b))
 
 
 #if ACPI_MACHINE_WIDTH == 16
@@ -487,19 +488,19 @@
  * The first parameter should be the procedure name as a quoted string.  This is declared
  * as a local string ("_proc_name) so that it can be also used by the function exit macros below.
  */
-#define ACPI_FUNCTION_NAME(a)               struct acpi_debug_print_info _dbg; \
-												_dbg.component_id = _COMPONENT; \
-												_dbg.proc_name   = a; \
-												_dbg.module_name = _THIS_MODULE;
+#define ACPI_FUNCTION_NAME(a)               struct acpi_debug_print_info _debug_info; \
+												_debug_info.component_id = _COMPONENT; \
+												_debug_info.proc_name  = a; \
+												_debug_info.module_name = _THIS_MODULE;
 
 #define ACPI_FUNCTION_TRACE(a)              ACPI_FUNCTION_NAME(a) \
-												acpi_ut_trace(__LINE__,&_dbg)
+												acpi_ut_trace(__LINE__,&_debug_info)
 #define ACPI_FUNCTION_TRACE_PTR(a,b)        ACPI_FUNCTION_NAME(a) \
-												acpi_ut_trace_ptr(__LINE__,&_dbg,(void *)b)
+												acpi_ut_trace_ptr(__LINE__,&_debug_info,(void *)b)
 #define ACPI_FUNCTION_TRACE_U32(a,b)        ACPI_FUNCTION_NAME(a) \
-												acpi_ut_trace_u32(__LINE__,&_dbg,(u32)b)
+												acpi_ut_trace_u32(__LINE__,&_debug_info,(u32)b)
 #define ACPI_FUNCTION_TRACE_STR(a,b)        ACPI_FUNCTION_NAME(a) \
-												acpi_ut_trace_str(__LINE__,&_dbg,(char *)b)
+												acpi_ut_trace_str(__LINE__,&_debug_info,(char *)b)
 
 #define ACPI_FUNCTION_ENTRY()               acpi_ut_track_stack_ptr()
 
@@ -516,10 +517,10 @@
 #define ACPI_DO_WHILE0(a)               a
 #endif
 
-#define return_VOID                     ACPI_DO_WHILE0 ({acpi_ut_exit(__LINE__,&_dbg);return;})
-#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({acpi_ut_status_exit(__LINE__,&_dbg,(s));return((s));})
-#define return_VALUE(s)                 ACPI_DO_WHILE0 ({acpi_ut_value_exit(__LINE__,&_dbg,(acpi_integer)(s));return((s));})
-#define return_PTR(s)                   ACPI_DO_WHILE0 ({acpi_ut_ptr_exit(__LINE__,&_dbg,(u8 *)(s));return((s));})
+#define return_VOID                     ACPI_DO_WHILE0 ({acpi_ut_exit(__LINE__,&_debug_info);return;})
+#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({acpi_ut_status_exit(__LINE__,&_debug_info,(s));return((s));})
+#define return_VALUE(s)                 ACPI_DO_WHILE0 ({acpi_ut_value_exit(__LINE__,&_debug_info,(acpi_integer)(s));return((s));})
+#define return_PTR(s)                   ACPI_DO_WHILE0 ({acpi_ut_ptr_exit(__LINE__,&_debug_info,(u8 *)(s));return((s));})
 
 /* Conditional execution */
 
diff -Nru a/include/acpi/acobject.h b/include/acpi/acobject.h
--- a/include/acpi/acobject.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/acobject.h	2005-01-06 15:06:41 -05:00
@@ -94,9 +94,7 @@
 	u32                                     bit_length;         /* Length of field in bits */\
 	u32                                     base_byte_offset;   /* Byte offset within containing object */\
 	u8                                      start_field_bit_offset;/* Bit offset within first field datum (0-63) */\
-	u8                                      datum_valid_bits;   /* Valid bit in first "Field datum" */\
-	u8                                      end_field_valid_bits; /* Valid bits in the last "field datum" */\
-	u8                                      end_buffer_valid_bits; /* Valid bits in the last "buffer datum" */\
+	u8                                      access_bit_width;   /* Read/Write size in bits (8-64) */\
 	u32                                     value;              /* Value to store into the Bank or Index register */\
 	struct acpi_namespace_node              *node;              /* Link back to parent node */
 
diff -Nru a/include/acpi/acoutput.h b/include/acpi/acoutput.h
--- a/include/acpi/acoutput.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/acoutput.h	2005-01-06 15:06:41 -05:00
@@ -136,7 +136,7 @@
 /*
  * Debug level macros that are used in the DEBUG_PRINT macros
  */
-#define ACPI_DEBUG_LEVEL(dl)        (u32) dl,__LINE__,&_dbg
+#define ACPI_DEBUG_LEVEL(dl)        (u32) dl,__LINE__,&_debug_info
 
 /* Exception level -- used in the global "debug_level" */
 
diff -Nru a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
--- a/include/acpi/acpi_bus.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/acpi_bus.h	2005-01-06 15:06:41 -05:00
@@ -104,6 +104,7 @@
 typedef int (*acpi_op_resume)	(struct acpi_device *device, int state);
 typedef int (*acpi_op_scan)	(struct acpi_device *device);
 typedef int (*acpi_op_bind)	(struct acpi_device *device);
+typedef int (*acpi_op_unbind)	(struct acpi_device *device);
 typedef int (*acpi_op_match)	(struct acpi_device *device,
 				 struct acpi_driver *driver);
 
@@ -117,6 +118,7 @@
 	acpi_op_resume		resume;
 	acpi_op_scan		scan;
 	acpi_op_bind		bind;
+	acpi_op_unbind		unbind;
 	acpi_op_match		match;
 };
 
@@ -316,7 +318,8 @@
  * External Functions
  */
 
-int acpi_bus_get_device(acpi_handle, struct acpi_device **device);
+int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device);
+void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context);
 int acpi_bus_get_status (struct acpi_device *device);
 int acpi_bus_get_power (acpi_handle handle, int *state);
 int acpi_bus_set_power (acpi_handle handle, int state);
@@ -324,6 +327,11 @@
 int acpi_bus_receive_event (struct acpi_bus_event *event);
 int acpi_bus_register_driver (struct acpi_driver *driver);
 int acpi_bus_unregister_driver (struct acpi_driver *driver);
+int acpi_bus_scan (struct acpi_device *start);
+int acpi_bus_trim(struct acpi_device *start, int rmdevice);
+int acpi_bus_add (struct acpi_device **child, struct acpi_device *parent,
+		acpi_handle handle, int type);
+
 
 int acpi_match_ids (struct acpi_device	*device, char	*ids);
 int acpi_create_dir(struct acpi_device *);
diff -Nru a/include/acpi/acpi_drivers.h b/include/acpi/acpi_drivers.h
--- a/include/acpi/acpi_drivers.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/acpi_drivers.h	2005-01-06 15:06:41 -05:00
@@ -61,12 +61,14 @@
 /* ACPI PCI Interrupt Routing (pci_irq.c) */
 
 int acpi_pci_irq_add_prt (acpi_handle handle, int segment, int bus);
+void acpi_pci_irq_del_prt (int segment, int bus);
 
 /* ACPI PCI Device Binding (pci_bind.c) */
 
 struct pci_bus;
 
 int acpi_pci_bind (struct acpi_device *device);
+int acpi_pci_unbind (struct acpi_device *device);
 int acpi_pci_bind_root (struct acpi_device *device, struct acpi_pci_id *id, struct pci_bus *bus);
 
 /* Arch-defined function to add a bus to the system */
diff -Nru a/include/acpi/acpixf.h b/include/acpi/acpixf.h
--- a/include/acpi/acpixf.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/acpixf.h	2005-01-06 15:06:41 -05:00
@@ -345,11 +345,11 @@
 	u32                             event,
 	u32                             flags);
 
-#ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_clear_event (
 	u32                             event);
 
+#ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_get_event_status (
 	u32                             event,
diff -Nru a/include/acpi/actbl2.h b/include/acpi/actbl2.h
--- a/include/acpi/actbl2.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/actbl2.h	2005-01-06 15:06:41 -05:00
@@ -115,7 +115,7 @@
 	u8                              address_space_id;       /* Address space where struct or register exists. */
 	u8                              register_bit_width;     /* Size in bits of given register */
 	u8                              register_bit_offset;    /* Bit offset within the register */
-	u8                              reserved;               /* Must be 0 */
+	u8                              access_width;           /* Minimum Access size (ACPI 3.0) */
 	u64                             address;                /* 64-bit address of struct or register */
 };
 
diff -Nru a/include/acpi/amlcode.h b/include/acpi/amlcode.h
--- a/include/acpi/amlcode.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/amlcode.h	2005-01-06 15:06:41 -05:00
@@ -320,6 +320,7 @@
 #define AML_HAS_TARGET              0x0800
 #define AML_HAS_ARGS                0x1000
 #define AML_CONSTANT                0x2000
+#define AML_NO_OPERAND_RESOLVE      0x4000
 
 /* Convenient flag groupings */
 
diff -Nru a/include/acpi/amlresrc.h b/include/acpi/amlresrc.h
--- a/include/acpi/amlresrc.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/amlresrc.h	2005-01-06 15:06:41 -05:00
@@ -50,6 +50,8 @@
 #define ASL_RESNAME_ADDRESS                     "_ADR"
 #define ASL_RESNAME_ALIGNMENT                   "_ALN"
 #define ASL_RESNAME_ADDRESSSPACE                "_ASI"
+#define ASL_RESNAME_ACCESSSIZE                  "_ASZ"
+#define ASL_RESNAME_TYPESPECIFICATTRIBUTES      "_ATT"
 #define ASL_RESNAME_BASEADDRESS                 "_BAS"
 #define ASL_RESNAME_BUSMASTER                   "_BM_"  /* Master(1), Slave(0) */
 #define ASL_RESNAME_DECODE                      "_DEC"
@@ -223,6 +225,27 @@
 };
 
 
+struct asl_extended_address_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  resource_type;
+	u8                                  flags;
+	u8                                  specific_flags;
+	u8                                  revision_iD;
+	u8                                  reserved;
+	u64                                 granularity;
+	u64                                 address_min;
+	u64                                 address_max;
+	u64                                 translation_offset;
+	u64                                 address_length;
+	u64                                 type_specific_attributes;
+	u8                                  optional_fields[2]; /* Used for length calculation only */
+};
+
+#define ASL_EXTENDED_ADDRESS_DESC_REVISION          1       /* ACPI 3.0 */
+
+
 struct asl_qword_address_desc
 {
 	u8                                  descriptor_type;
@@ -289,7 +312,7 @@
 	u8                                  address_space_id;
 	u8                                  bit_width;
 	u8                                  bit_offset;
-	u8                                  reserved;
+	u8                                  access_size; /* ACPI 3.0, was Reserved */
 	u64                                 address;
 };
 
@@ -317,6 +340,7 @@
 	struct asl_qword_address_desc       qas;
 	struct asl_dword_address_desc       das;
 	struct asl_word_address_desc        was;
+	struct asl_extended_address_desc    eas;
 	struct asl_extended_xrupt_desc      exx;
 	struct asl_general_register_desc    grg;
 	u32                                 u32_item;
diff -Nru a/include/acpi/container.h b/include/acpi/container.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/include/acpi/container.h	2005-01-06 15:06:41 -05:00
@@ -0,0 +1,13 @@
+#ifndef __ACPI_CONTAINER_H
+#define __ACPI_CONTAINER_H
+
+#include <linux/kernel.h>
+
+struct acpi_container {
+	acpi_handle handle;
+	unsigned long sun;
+	int state;
+};
+
+#endif /* __ACPI_CONTAINER_H */
+
diff -Nru a/include/acpi/processor.h b/include/acpi/processor.h
--- a/include/acpi/processor.h	2005-01-06 15:06:41 -05:00
+++ b/include/acpi/processor.h	2005-01-06 15:06:41 -05:00
@@ -2,10 +2,11 @@
 #define __ACPI_PROCESSOR_H
 
 #include <linux/kernel.h>
+#include <linux/config.h>
 
 #define ACPI_PROCESSOR_BUSY_METRIC	10
 
-#define ACPI_PROCESSOR_MAX_POWER	ACPI_C_STATE_COUNT
+#define ACPI_PROCESSOR_MAX_POWER	8
 #define ACPI_PROCESSOR_MAX_C2_LATENCY	100
 #define ACPI_PROCESSOR_MAX_C3_LATENCY	1000
 
@@ -15,9 +16,22 @@
 
 /* Power Management */
 
+struct acpi_processor_cx;
+
+struct acpi_power_register {
+	u8			descriptor;
+	u16			length;
+	u8			space_id;
+	u8			bit_width;
+	u8			bit_offset;
+	u8			reserved;
+	u64			address;
+} __attribute__ ((packed));
+
+
 struct acpi_processor_cx_policy {
 	u32			count;
-	u32			state;
+	struct acpi_processor_cx *state;
 	struct {
 		u32			time;
 		u32			ticks;
@@ -28,6 +42,7 @@
 
 struct acpi_processor_cx {
 	u8			valid;
+	u8			type;
 	u32			address;
 	u32			latency;
 	u32			latency_ticks;
@@ -38,9 +53,10 @@
 };
 
 struct acpi_processor_power {
-	u32			state;
+	struct acpi_processor_cx *state;
 	u32			default_state;
 	u32			bm_activity;
+	int			count;
 	struct acpi_processor_cx states[ACPI_PROCESSOR_MAX_POWER];
 };
 
@@ -118,13 +134,15 @@
 	u8			limit:1;
 	u8			bm_control:1;
 	u8			bm_check:1;
-	u8			reserved:2;
+	u8			has_cst:1;
+	u8			power_setup_done:1;
 };
 
 struct acpi_processor {
 	acpi_handle		handle;
 	u32			acpi_id;
 	u32			id;
+	u32			pblk;
 	int			performance_platform_limit;
 	struct acpi_processor_flags flags;
 	struct acpi_processor_power power;
@@ -133,6 +151,16 @@
 	struct acpi_processor_limit limit;
 };
 
+struct acpi_processor_errata {
+	u8			smp;
+	struct {
+		u8			throttle:1;
+		u8			fdma:1;
+		u8			reserved:6;
+		u32			bmisx;
+	}			piix4;
+};
+
 extern int acpi_processor_register_performance (
 	struct acpi_processor_performance * performance,
 	unsigned int cpu);
@@ -143,5 +171,67 @@
 /* note: this locks both the calling module and the processor module
          if a _PPC object exists, rmmod is disallowed then */
 int acpi_processor_notify_smm(struct module *calling_module);
+
+
+
+/* for communication between multiple parts of the processor kernel module */
+extern struct acpi_processor	*processors[NR_CPUS];
+extern struct acpi_processor_errata errata;
+
+
+/* in processor_perflib.c */
+#ifdef CONFIG_CPU_FREQ
+void acpi_processor_ppc_init(void);
+void acpi_processor_ppc_exit(void);
+int acpi_processor_ppc_has_changed(struct acpi_processor *pr);
+#else
+static inline void acpi_processor_ppc_init(void) { return; }
+static inline void acpi_processor_ppc_exit(void) { return; }
+static inline int acpi_processor_ppc_has_changed(struct acpi_processor *pr) {
+	static unsigned int printout = 1;
+	if (printout) {
+		printk(KERN_WARNING "Warning: Processor Platform Limit event detected, but not handled.\n");
+		printk(KERN_WARNING "Consider compiling CPUfreq support into your kernel.\n");
+		printout = 0;
+	}
+	return 0;
+}
+#endif /* CONFIG_CPU_FREQ */
+
+/* in processor_throttling.c */
+int acpi_processor_get_throttling_info (struct acpi_processor *pr);
+int acpi_processor_set_throttling (struct acpi_processor *pr, int state);
+int acpi_processor_throttling_open_fs(struct inode *inode, struct file *file);
+ssize_t acpi_processor_write_throttling (
+        struct file		*file,
+        const char		__user *buffer,
+        size_t			count,
+        loff_t			*data);
+extern struct file_operations acpi_processor_throttling_fops;
+
+/* in processor_idle.c */
+int acpi_processor_power_init(struct acpi_processor *pr, struct acpi_device *device);
+int acpi_processor_cst_has_changed (struct acpi_processor *pr);
+int acpi_processor_power_exit(struct acpi_processor *pr, struct acpi_device *device);
+
+
+/* in processor_thermal.c */
+int acpi_processor_get_limit_info (struct acpi_processor *pr);
+int acpi_processor_limit_open_fs(struct inode *inode, struct file *file);
+ssize_t acpi_processor_write_limit (
+	struct file		*file,
+	const char		__user *buffer,
+	size_t			count,
+	loff_t			*data);
+extern struct file_operations acpi_processor_limit_fops;
+
+#ifdef CONFIG_CPU_FREQ
+void acpi_thermal_cpufreq_init(void);
+void acpi_thermal_cpufreq_exit(void);
+#else
+static inline void acpi_thermal_cpufreq_init(void) { return; }
+static inline void acpi_thermal_cpufreq_exit(void) { return; }
+#endif
+
 
 #endif
diff -Nru a/include/asm-i386/acpi.h b/include/asm-i386/acpi.h
--- a/include/asm-i386/acpi.h	2005-01-06 15:06:41 -05:00
+++ b/include/asm-i386/acpi.h	2005-01-06 15:06:41 -05:00
@@ -104,12 +104,6 @@
 /*
  * Refer Intel ACPI _PDC support document for bit definitions
  */
-#define ACPI_PDC_EST_CAPABILITY_SMP	0xa
-#define ACPI_PDC_EST_CAPABILITY_MSR	0x1
-
-/*
- * Refer Intel ACPI _PDC support document for bit definitions
- */
 #define ACPI_PDC_EST_CAPABILITY_SMP 	0xa
 #define ACPI_PDC_EST_CAPABILITY_MSR	0x1
 
diff -Nru a/include/asm-i386/cpu.h b/include/asm-i386/cpu.h
--- a/include/asm-i386/cpu.h	2005-01-06 15:06:41 -05:00
+++ b/include/asm-i386/cpu.h	2005-01-06 15:06:41 -05:00
@@ -12,18 +12,9 @@
 	struct cpu cpu;
 };
 extern struct i386_cpu cpu_devices[NR_CPUS];
-
-
-static inline int arch_register_cpu(int num){
-	struct node *parent = NULL;
-	
-#ifdef CONFIG_NUMA
-	int node = cpu_to_node(num);
-	if (node_online(node))
-		parent = &node_devices[node].node;
-#endif /* CONFIG_NUMA */
-
-	return register_cpu(&cpu_devices[num].cpu, num, parent);
-}
+extern int arch_register_cpu(int num);
+#ifdef CONFIG_HOTPLUG_CPU
+extern void arch_unregister_cpu(int);
+#endif
 
 #endif /* _ASM_I386_CPU_H_ */
diff -Nru a/include/asm-ia64/acpi.h b/include/asm-ia64/acpi.h
--- a/include/asm-ia64/acpi.h	2005-01-06 15:06:41 -05:00
+++ b/include/asm-ia64/acpi.h	2005-01-06 15:06:41 -05:00
@@ -101,7 +101,7 @@
 #ifdef CONFIG_ACPI_NUMA
 /* Proximity bitmap length; _PXM is at most 255 (8 bit)*/
 #define MAX_PXM_DOMAINS (256)
-extern int __initdata pxm_to_nid_map[MAX_PXM_DOMAINS];
+extern int __devinitdata pxm_to_nid_map[MAX_PXM_DOMAINS];
 extern int __initdata nid_to_pxm_map[MAX_NUMNODES];
 #endif
 
diff -Nru a/include/asm-ia64/cpu.h b/include/asm-ia64/cpu.h
--- a/include/asm-ia64/cpu.h	2005-01-06 15:06:41 -05:00
+++ b/include/asm-ia64/cpu.h	2005-01-06 15:06:41 -05:00
@@ -14,4 +14,9 @@
 
 DECLARE_PER_CPU(int, cpu_state);
 
+extern int arch_register_cpu(int num);
+#ifdef CONFIG_HOTPLUG_CPU
+extern void arch_unregister_cpu(int);
+#endif
+
 #endif /* _ASM_IA64_CPU_H_ */
diff -Nru a/include/linux/acpi.h b/include/linux/acpi.h
--- a/include/linux/acpi.h	2005-01-06 15:06:41 -05:00
+++ b/include/linux/acpi.h	2005-01-06 15:06:41 -05:00
@@ -396,6 +396,12 @@
 void acpi_numa_memory_affinity_init (struct acpi_table_memory_affinity *ma);
 void acpi_numa_arch_fixup(void);
 
+#ifdef CONFIG_ACPI_HOTPLUG_CPU
+/* Arch dependent functions for cpu hotplug support */
+int acpi_map_lsapic(acpi_handle handle, int *pcpu);
+int acpi_unmap_lsapic(int cpu);
+#endif /* CONFIG_ACPI_HOTPLUG_CPU */
+
 extern int acpi_mp_config;
 
 extern u32 pci_mmcfg_base_addr;
@@ -499,4 +505,12 @@
 static inline void acpi_set_cstate_limit(unsigned int new_limit) { return; }
 #endif
 
+#ifdef CONFIG_ACPI_NUMA
+int acpi_get_pxm(acpi_handle handle);
+#else
+static inline int acpi_get_pxm(acpi_handle handle)
+{
+	return 0;
+}
+#endif
 #endif /*_LINUX_ACPI_H*/
diff -Nru a/include/linux/cpu.h b/include/linux/cpu.h
--- a/include/linux/cpu.h	2005-01-06 15:06:41 -05:00
+++ b/include/linux/cpu.h	2005-01-06 15:06:41 -05:00
@@ -32,6 +32,9 @@
 };
 
 extern int register_cpu(struct cpu *, int, struct node *);
+#ifdef CONFIG_HOTPLUG_CPU
+extern void unregister_cpu(struct cpu *, struct node *);
+#endif
 struct notifier_block;
 
 #ifdef CONFIG_SMP
