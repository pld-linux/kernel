diff -urN orig/drivers/video/Config.in linux/drivers/video/Config.in
--- orig/drivers/video/Config.in	Mon Sep  4 13:39:22 2000
+++ linux/drivers/video/Config.in	Mon Oct  2 16:23:19 2000
@@ -6,7 +6,7 @@
   define_bool CONFIG_DUMMY_CONSOLE y
   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
     if [ "$CONFIG_AMIGA" = "y" -o "$CONFIG_PCI" = "y" ]; then
-      bool 'Permedia2 support (experimental)' CONFIG_FB_PM2
+      tristate 'Permedia2 support (experimental)' CONFIG_FB_PM2
       if [ "$CONFIG_FB_PM2" = "y" ]; then
         if [ "$CONFIG_PCI" = "y" ]; then
           bool '  enable FIFO disconnect feature' CONFIG_FB_PM2_FIFO_DISCONNECT
@@ -51,7 +51,7 @@
     bool 'Atari native chipset support' CONFIG_FB_ATARI
   fi
   if [ "$CONFIG_ATARI" = "y" -o "$CONFIG_PCI" != "n" ]; then
-    bool 'ATI Mach64 display support' CONFIG_FB_ATY
+    tristate 'ATI Mach64 display support' CONFIG_FB_ATY
   fi
   if [ "$CONFIG_PPC" = "y" ]; then
     bool 'Open Firmware frame buffer device support' CONFIG_FB_OF
@@ -84,7 +84,7 @@
     define_bool CONFIG_BUS_I2C y
   fi
   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-    if [ "$CONFIG_PCI" != "n" ]; then
+    if [ "$CONFIG_PCI" != "n" -a "$ARCH" != "sparc" -a "$ARCH" != "sparc64" ]; then
       tristate 'Matrox acceleration' CONFIG_FB_MATROX
       if  [ "$CONFIG_FB_MATROX" != "n" ]; then
         bool '  Millennium I/II support' CONFIG_FB_MATROX_MILLENIUM
diff -urN orig/drivers/video/atyfb.c linux/drivers/video/atyfb.c
--- orig/drivers/video/atyfb.c	Mon Sep  4 13:39:22 2000
+++ linux/drivers/video/atyfb.c	Mon Oct  2 16:21:33 2000
@@ -394,7 +394,7 @@
      *  Interface used by the world
      */
 
-void atyfb_init(void);
+int atyfb_init(void);
 #ifdef CONFIG_FB_OF
 void atyfb_of_init(struct device_node *dp);
 #endif
@@ -2880,7 +2880,7 @@
     return 1;
 }
 
-__initfunc(void atyfb_init(void))
+int __init atyfb_init(void)
 {
 #if defined(CONFIG_FB_OF)
     /* We don't want to be called like this. */
@@ -2900,7 +2900,7 @@
 
     /* Do not attach when we have a serial console. */
     if (!con_is_present())
-	return;
+	return 0;
 #else
     u16 tmp;
 #endif
@@ -2912,7 +2912,7 @@
 	    info = kmalloc(sizeof(struct fb_info_aty), GFP_ATOMIC);
 	    if (!info) {
 		printk("atyfb_init: can't alloc fb_info_aty\n");
-		return;
+		return 0;
 	    }
 	    memset(info, 0, sizeof(struct fb_info_aty));
 
@@ -2948,7 +2948,7 @@
 	    if (!info->mmap_map) {
 		printk("atyfb_init: can't alloc mmap_map\n");
 		kfree(info);
-		return;
+		return 0;
 	    }
 	    memset(info->mmap_map, 0, j * sizeof(*info->mmap_map));
 
@@ -3133,7 +3133,7 @@
 
 	    if(!info->ati_regbase) {
 		    kfree(info);
-		    return;
+		    return 0;
 	    }
 
 	    info->ati_regbase_phys += 0xc00;
@@ -3160,7 +3160,7 @@
 
 	    if(!info->frame_buffer) {
 		    kfree(info);
-		    return;
+		    return 0;
 	    }
 
 #endif /* __sparc__ */
@@ -3169,7 +3169,7 @@
 		if (info->mmap_map)
 		    kfree(info->mmap_map);
 		kfree(info);
-		return;
+		return 0;
 	    }
 
 #ifdef __sparc__
@@ -3207,7 +3207,7 @@
 	info = kmalloc(sizeof(struct fb_info_aty), GFP_ATOMIC);
 	if (!info) {
 	    printk("atyfb_init: can't alloc fb_info_aty\n");
-	    return;
+	    return 0;
 	}
 	memset(info, 0, sizeof(struct fb_info_aty));
 
@@ -3223,10 +3223,11 @@
 	if (!aty_init(info, "ISA bus")) {
 	    kfree(info);
 	    /* This is insufficient! kernel_map has added two large chunks!! */
-	    return;
+	    return 0;
 	}
     }
 #endif
+    return 1;
 }
 
 #ifdef CONFIG_FB_OF
@@ -4213,3 +4214,46 @@
 	return result;
 }
 #endif /* CONFIG_PMAC_PBOOK */
+
+#ifdef MODULE
+
+int blink = 1;
+static u32 vram = 0;
+static int pll = 0;
+static int mclk = 0;
+#if defined(CONFIG_PPC)
+static int vmode = VMODE_NVRAM;
+static int cmode = CMODE_NVRAM;
+#endif
+
+MODULE_PARM(noaccel, "i");
+MODULE_PARM_DESC(noaccel, "Do not use accelerating engine (0 or 1=disabled) (default=0)");
+MODULE_PARM(blink, "i");
+MODULE_PARM_DESC(blink, "Enables hardware cursor blinking (0 or 1) (default=1)");
+#ifdef CONFIG_PPC
+MODULE_PARM(vmode, "i");
+MODULE_PARM_DESC(vmode, "Specify the vmode mode number that should be used (640x480 default)");
+MODULE_PARM(cmode, "i");
+MODULE_PARM_DESC(cmode, "Specify the video depth that should be used (8bit default)");
+#endif
+
+int init_module(void)
+{
+	curblink = blink;
+	default_vram = vram;
+	default_pll = pll;
+	default_mclk = mclk;
+#ifdef CONFIG_PPC
+	default_vmode = vmode;
+	default_cmode = cmode;
+#endif
+	if (!atyfb_init())
+		return -ENXIO;
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+void cleanup_module(void)
+{
+}
+#endif	/* MODULE */
diff -urN orig/drivers/video/pm2fb.c linux/drivers/video/pm2fb.c
--- orig/drivers/video/pm2fb.c	Mon Sep  4 13:39:22 2000
+++ linux/drivers/video/pm2fb.c	Mon Oct  2 16:21:33 2000
@@ -2041,12 +2041,12 @@
 		board_table[i->board].cleanup(i);
 }
 
-__initfunc(void pm2fb_init(void)) {
+int __init pm2fb_init(void) {
 
 	memset(&fb_info, 0, sizeof(fb_info));
 	memcpy(&fb_info.current_par, &pm2fb_options.user_mode, sizeof(fb_info.current_par));
 	if (!pm2fb_conf(&fb_info))
-		return;
+		return 0;
 	pm2fb_reset(&fb_info);
 	fb_info.disp.scrollmode=SCROLL_YNOMOVE;
 	fb_info.gen.parsize=sizeof(struct pm2fb_par);
@@ -2065,7 +2065,7 @@
 	fbgen_install_cmap(0, &fb_info.gen);
 	if (register_framebuffer(&fb_info.gen.info)<0) {
 		printk("pm2fb: unable to register.\n");
-		return;
+		return 0;
 	}
 	printk("fb%d: %s (%s), using %uK of video memory.\n",
 				GET_FB_IDX(fb_info.gen.info.node),
@@ -2073,6 +2073,7 @@
 				permedia2_name,
 				(u32 )(fb_info.regions.fb_size>>10));
 	MOD_INC_USE_COUNT;
+	return 1;
 }
 
 static void __init pm2fb_mode_setup(char* options) {
@@ -2127,7 +2128,8 @@
 
 int init_module(void) {
 	if (mode) pm2fb_mode_setup(mode);
-  	pm2fb_init();
+	if (!pm2fb_init())
+		return -ENXIO;
 }
 
 void cleanup_module(void) {
