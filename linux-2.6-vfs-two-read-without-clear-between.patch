Subject: [PATCH] VFS bugfix: two read_inode() calls without
                             clear_inode() call between
From: "Artem B. Bityuckiy" <dedekind@infradead.org>

Here is a patch which causes JFFS2 failures on SMP.
The following are links where the problem was discussed:
http://lkml.org/lkml/2005/4/27/84
http://lkml.org/lkml/2005/4/18/77

Problem description:
~~~~~~~~~~~~~~~~~~~~~~
prune_icache() removes inodes from the inode hash (inode->i_hash) and
drops the node_lock spinlock. If at that moment iget() is called, we end
up with the situation when VFS calls ->read_inode() twice for the same
inode without calling ->clear_inode() between. This happens despite of
the I_FREEING inode state because the inode is already removed from the
hash by the time find_inode_fast() is invoked.

The fix is: do not remove the inode from the hash too early.

The following patch fixes the problem. It was tested with JFFS2 (only)
and works perfectly.

Signed-off-by: Artem B. Bityuckiy <dedekind@infradead.org>

--- linux-2.6.11.8/fs/inode.c.orig	2005-05-03 10:32:41.000000000 +0200
+++ linux-2.6.11.8/fs/inode.c	2005-05-03 10:51:24.000000000 +0200
@@ -291,6 +291,12 @@ static void dispose_list(struct list_hea
 		if (inode->i_data.nrpages)
 			truncate_inode_pages(&inode->i_data, 0);
 		clear_inode(inode);
+
+		spin_lock(&inode_lock);
+		hlist_del_init(&inode->i_hash);
+		list_del_init(&inode->i_sb_list);
+		spin_unlock(&inode_lock);
+
 		destroy_inode(inode);
 		nr_disposed++;
 	}
@@ -326,8 +332,6 @@ static int invalidate_list(struct list_h
 		inode = list_entry(tmp, struct inode, i_sb_list);
 		invalidate_inode_buffers(inode);
 		if (!atomic_read(&inode->i_count)) {
-			hlist_del_init(&inode->i_hash);
-			list_del(&inode->i_sb_list);
 			list_move(&inode->i_list, dispose);
 			inode->i_state |= I_FREEING;
 			count++;
@@ -463,8 +467,6 @@ static void prune_icache(int nr_to_scan)
 			if (!can_unuse(inode))
 				continue;
 		}
-		hlist_del_init(&inode->i_hash);
-		list_del_init(&inode->i_sb_list);
 		list_move(&inode->i_list, &freeable);
 		inode->i_state |= I_FREEING;
 		nr_pruned++;
