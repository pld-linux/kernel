diff -uNr linux-2.6.10-rc1.orig/arch/i386/Kconfig linux-2.6.10-rc1/arch/i386/Kconfig
--- linux-2.6.10-rc1.orig/arch/i386/Kconfig	2004-10-22 23:38:39.000000000 +0200
+++ linux-2.6.10-rc1/arch/i386/Kconfig	2004-10-29 00:38:36.995282608 +0200
@@ -630,6 +630,9 @@
 	  Say Y if you intend to run this kernel on a Dell Inspiron 8000.
 	  Say N otherwise.
 
+config OMNIBOOK
+	tristate "HP Omnibook Support"
+
 config MICROCODE
 	tristate "/dev/cpu/microcode - Intel IA32 CPU microcode support"
 	---help---
diff -uNr linux-2.6.10-rc1.orig/arch/i386/kernel/apm.c linux-2.6.10-rc1/arch/i386/kernel/apm.c
--- linux-2.6.10-rc1.orig/arch/i386/kernel/apm.c	2004-10-29 00:40:22.789199488 +0200
+++ linux-2.6.10-rc1/arch/i386/kernel/apm.c	2004-10-29 00:20:26.706031768 +0200
@@ -2028,6 +2028,11 @@
 			DMI_MATCH(DMI_BIOS_VERSION, "A12"),
 			DMI_MATCH(DMI_BIOS_DATE, "02/04/2002"), },
 	},
+	{	/* Handle problems with APM on HP OmniBook XE3 GF */
+		broken_apm_power, "HP OmniBook XE3 GF",
+		{	DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "HP OmniBook XE3 GF"), },
+	},
 	{	/* APM crashes */
 		apm_is_horked, "Dell Dimension 4100",
 		{	DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
diff -uNr linux-2.6.10-rc1.orig/drivers/char/Makefile linux-2.6.10-rc1/drivers/char/Makefile
--- linux-2.6.10-rc1.orig/drivers/char/Makefile	2004-10-22 23:40:28.000000000 +0200
+++ linux-2.6.10-rc1/drivers/char/Makefile	2004-10-28 20:39:26.000000000 +0200
@@ -71,6 +71,7 @@
 endif
 obj-$(CONFIG_TOSHIBA) += toshiba.o
 obj-$(CONFIG_I8K) += i8k.o
+obj-$(CONFIG_OMNIBOOK) += omnibook/
 obj-$(CONFIG_DS1620) += ds1620.o
 obj-$(CONFIG_HW_RANDOM) += hw_random.o
 obj-$(CONFIG_QIC02_TAPE) += tpqic02.o
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/ac.c linux-2.6.10-rc1/drivers/char/omnibook/ac.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/ac.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/ac.c	2004-05-02 05:57:22.000000000 +0200
@@ -0,0 +1,138 @@
+/*
+ * ac.c -- AC adapter related functions
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_ac;
+
+int omnibook_get_ac(void)
+{
+	u8 ac;
+	int retval;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		if ((retval = omnibook_ec_read(XE3GF_ADP, &ac)))
+			return retval;
+		retval = (ac & XE3GF_ADP_MASK) ? 1 : 0;
+		break;
+	case XE3GC:
+	case AMILOD:
+		if ((retval = omnibook_ec_read(XE3GC_STA1, &ac)))
+			return retval;
+		retval = (ac & XE3GC_ADP_MASK) ? 1 : 0;
+		break;
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+		if ((retval = omnibook_ec_read(OB500_STA2, &ac)))
+			return retval;
+		retval = (ac & OB500_ADP_MASK) ? 1 : 0;
+		break;
+	case OB4150:
+		if ((retval = omnibook_ec_read(OB4150_ADP, &ac)))
+			return retval;
+		retval = (ac & OB4150_ADP_MASK) ? 1 : 0;
+		break;
+	case XE2:
+		if ((retval = omnibook_ec_read(XE2_STA1, &ac)))
+			return retval;
+		retval = (ac & XE2_ADP_MASK) ? 1 : 0;
+		break;
+	default:
+		printk(KERN_INFO "%s: AC adapter status monitoring is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+	return retval;
+}
+
+static int omnibook_proc_ac(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+	int ac;
+
+	ac = omnibook_get_ac();
+	if (ac < 0)
+		return ac;
+
+	b += sprintf(b, "AC %s\n", (ac) ? "on-line" : "off-line");
+	
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+int __init omnibook_ac_init(void)
+{
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+	case OB4150:
+	case XE2:
+	case AMILOD:
+	case TSP10:
+		pmode = S_IFREG | S_IRUGO;
+		proc_ac = create_proc_read_entry("ac", pmode, omnibook_proc_root, omnibook_proc_ac, NULL);
+		break;
+	default:
+		printk(KERN_INFO "%s: AC adapter status monitoring is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	if (! proc_ac) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/ac.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	printk(KERN_INFO "%s: AC adapter status monitoring is enabled.\n", OMNIBOOK_MODULE_NAME);
+	return 0;
+}
+
+void __exit omnibook_ac_cleanup(void)
+{
+	if (proc_ac)
+		remove_proc_entry("ac", omnibook_proc_root);
+}
+
+EXPORT_SYMBOL(omnibook_get_ac);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/apmemu.c linux-2.6.10-rc1/drivers/char/omnibook/apmemu.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/apmemu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/apmemu.c	2004-05-02 05:46:23.000000000 +0200
@@ -0,0 +1,188 @@
+/*
+ * apmemu.c -- /proc/apm emulation
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#ifdef CONFIG_APM
+#include <linux/apm_bios.h>
+#endif
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "apmemu.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_apmemu;
+
+/* Arguments, with symbols from linux/apm_bios.h.  Information is
+   from the Get Power Status (0x0a) call unless otherwise noted.
+   0) Linux driver version (this will change if format changes)
+   1) APM BIOS Version.  Usually 1.0, 1.1 or 1.2.
+   2) APM flags from APM Installation Check (0x00):
+      bit 0: APM_16_BIT_SUPPORT
+      bit 1: APM_32_BIT_SUPPORT
+      bit 2: APM_IDLE_SLOWS_CLOCK
+      bit 3: APM_BIOS_DISABLED
+      bit 4: APM_BIOS_DISENGAGED
+   3) AC line status
+      0x00: Off-line
+      0x01: On-line
+      0x02: On backup power (BIOS >= 1.1 only)
+      0xff: Unknown
+   4) Battery status
+      0x00: High
+      0x01: Low
+      0x02: Critical
+      0x03: Charging
+      0x04: Selected battery not present (BIOS >= 1.2 only)
+      0xff: Unknown
+   5) Battery flag
+      bit 0: High
+      bit 1: Low
+      bit 2: Critical
+      bit 3: Charging
+      bit 7: No system battery
+      0xff: Unknown
+   6) Remaining battery life (percentage of charge):
+      0-100: valid
+      -1: Unknown
+   7) Remaining battery life (time units):
+      Number of remaining minutes or seconds
+      -1: Unknown
+   8) min = minutes; sec = seconds */
+
+static int omnibook_proc_apmemu(char *buffer, char **start, off_t off, int count)
+{
+	int retval;
+	char *b = buffer;
+
+	int ac;
+	struct omnibook_battery_status battstat;
+	
+	struct apm_features {
+		char *drvver;
+		char *apmver;
+		u8 apmflags;
+		u8 ac;
+		u8 battstat;
+		u8 battflags;
+		u8 gauge;
+		int time;
+		char *units;
+	};
+
+	struct apm_features apm = {
+		APMEMU_DRIVER_VERSION,
+		APMEMU_APM_VERSION,
+		APMEMU_32_BIT_SUPPORT | APMEMU_BIOS_DISABLED,
+		APMEMU_AC_UNKNOWN,
+		APMEMU_BATTSTAT_UNKN,
+		0x00,
+		APMEMU_BATTLIFE_UNKN,
+		APMEMU_BATTLIFE_UNKN,
+		"?"
+	};
+
+	ac = omnibook_get_ac();
+	apm.ac = (ac) ? APMEMU_AC_ONLINE : APMEMU_AC_OFFLINE;
+	/* Asking for Battery 0 as APM does */
+	retval = omnibook_get_battery_status(0, &battstat);
+	if (retval == 0)
+		apm.gauge = battstat.gauge;
+	if (apm.gauge >= APMEMU_BATTERY_LOW) {
+		apm.battflags = apm.battflags | APMEMU_BATTFLAG_HIGH;
+		apm.battstat = APMEMU_BATTSTAT_HIGH;
+	} else {
+		apm.battflags = apm.battflags | APMEMU_BATTFLAG_LOW;
+		apm.battstat = APMEMU_BATTSTAT_LOW;
+	}
+	if (battstat.status == OMNIBOOK_BATTSTAT_CHARGING) {
+		apm.battflags = apm.battflags | APMEMU_BATTFLAG_CHR;
+		apm.battstat = APMEMU_BATTSTAT_CHR;
+	}
+	if (battstat.status == OMNIBOOK_BATTSTAT_CRITICAL) {
+		apm.battflags = apm.battflags | APMEMU_BATTFLAG_CRIT;
+		apm.battstat = APMEMU_BATTSTAT_CRIT;
+	}
+
+	b += sprintf(b, "%s %s 0x%02x 0x%02x 0x%02x 0x%02x %d%% %d %s\n",
+			apm.drvver,
+			apm.apmver,
+			apm.apmflags,
+			apm.ac,
+			apm.battstat,
+			apm.battflags,
+			apm.gauge,
+			apm.time,
+			apm.units
+	);
+
+	return b - buffer;
+}
+
+int __init omnibook_apmemu_init(void)
+{
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case TSP10:
+#ifdef CONFIG_APM
+		if (! apm_info.disabled) {
+			printk(KERN_NOTICE "%s: Real APM support is present, emulation is not necessary.\n", OMNIBOOK_MODULE_NAME);
+			return 0;
+		}
+#endif
+		pmode = S_IFREG | S_IRUGO;
+		proc_apmemu = create_proc_info_entry("apm", pmode, NULL, omnibook_proc_apmemu);
+		break;
+	default:
+		printk(KERN_INFO "%s: /proc/apm emulation is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	if (! proc_apmemu) {
+		printk(KERN_ERR "%s: Unable to create /proc/apm.\n", OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	printk(KERN_INFO "%s: /proc/apm emulation enabled.\n", OMNIBOOK_MODULE_NAME);
+	return 0;
+}
+
+void __exit omnibook_apmemu_cleanup(void)
+{
+	if (proc_apmemu) {
+		remove_proc_entry("apm", NULL);
+		printk(KERN_INFO "%s: /proc/apm emulation disabled.\n", OMNIBOOK_MODULE_NAME);
+	}
+}
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/apmemu.h linux-2.6.10-rc1/drivers/char/omnibook/apmemu.h
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/apmemu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/apmemu.h	2004-01-14 20:15:19.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ * apmemu.c -- code to emulate /proc/apm
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#define APMEMU_DRIVER_VERSION	"1.16"
+#define APMEMU_APM_VERSION 	"1.2"
+
+#define APMEMU_BATTERY_LOW	30	/* Battery low threshold */
+
+#define APMEMU_16_BIT_SUPPORT	0x01	/* 16 bit APM BIOS */
+#define APMEMU_32_BIT_SUPPORT	0x02	/* 32 bit APM BIOS */
+#define APMEMU_IDLE_SLOWS_CLOCK	0x04
+#define APMEMU_BIOS_DISABLED	0x08	/* APM BIOS disabled */
+#define APMEMU_BIOS_DISENGAGED	0x10	/* APM BIOS disengaged */
+
+#define APMEMU_AC_OFFLINE	0x00	/* AC offline */
+#define APMEMU_AC_ONLINE	0x01	/* AC online */
+#define APMEMU_AC_BACKUP	0x02	/* On backup power */
+#define APMEMU_AC_UNKNOWN	0xFF	/* Unkonwn status */
+
+#define APMEMU_BATTSTAT_HIGH	0x00	/* Remaining battery capacity is high */
+#define APMEMU_BATTSTAT_LOW	0x01	/* Remaining battery capacity is low */
+#define APMEMU_BATTSTAT_CRIT	0x02	/* Battery status is critical */
+#define APMEMU_BATTSTAT_CHR	0x03	/* Battery is charging */
+#define APMEMU_BATTSTAT_MISS	0x04	/* Battery is not present */
+
+#define APMEMU_BATTFLAG_HIGH	0x01	/* Remaining battery capacity is high bit */
+#define APMEMU_BATTFLAG_LOW	0x02	/* Remaining battery capacity is low bit */
+#define APMEMU_BATTFLAG_CRIT	0x04	/* Battery status is critical bit */
+#define APMEMU_BATTFLAG_CHR	0x08	/* Battery is charging bit */
+#define APMEMU_BATTFLAG_MISS	0x80	/* Battery is not present bit */
+
+#define APMEMU_BATTSTAT_UNKN	0xff	/* Status is unknown */
+
+#define APMEMU_BATTLIFE_UNKN	-1	/* Remaining battery capacity is unknown */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/battery.c linux-2.6.10-rc1/drivers/char/omnibook/battery.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/battery.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/battery.c	2004-05-02 05:58:30.000000000 +0200
@@ -0,0 +1,485 @@
+/*
+ * battery.c -- battery related functions
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_battery;
+
+int omnibook_battery_present(int num)
+{
+	int retval;
+	int i;
+	u8 bat;
+	u8 mask = 0;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		if (num >= 2)
+			return -EINVAL;
+		if ((retval = omnibook_ec_read(XE3GF_BAL, &bat)))
+			return retval;
+		mask = XE3GF_BAL0_MASK;
+		for (i = 0; i < num; i++)
+			mask = mask << 1;
+		break;
+	case XE3GC:
+	case AMILOD:
+		if (num >= 2)
+			return -EINVAL;
+		if ((retval = omnibook_ec_read(XE3GC_BAT, &bat)))
+			return retval;
+		mask = XE3GC_BAT0_MASK;
+		for (i = 0; i < num; i++)
+			mask = mask << 1;
+		break;
+	}
+	return (bat & mask) ? 1 : 0;
+}
+
+/*
+ * Get static battery information
+ * All info have to be reread every time because battery sould be cahnged
+ * when laptop is on AC power 
+ * return values:
+ *  < 0 - ERROR
+ *    0 - OK
+ *    1 - Battery is not present
+ *    2 - Not supported
+ */
+int omnibook_get_battery_info(int num, struct omnibook_battery_info *battinfo)
+{
+	int retval;
+	u32 offset;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		offset = 0x10;
+		retval = omnibook_battery_present(num);
+		if (retval < 0)
+			return retval;
+		if (retval) {
+			if ((retval = omnibook_ec_read(XE3GF_BTY0 + (offset * num), &(*battinfo).type)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GF_BSN0 + (offset * num), &(*battinfo).sn)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GF_BDV0 + (offset * num), &(*battinfo).dv)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GF_BDC0 + (offset * num), &(*battinfo).dc)))
+				return retval;
+
+			(*battinfo).type = ((*battinfo).type & XE3GF_BTY_MASK) ? 1 : 0;
+		} else
+			return 1;
+		break;
+	case XE3GC:
+		offset = 0x10;
+		retval = omnibook_battery_present(num);
+		if (retval < 0)
+			return retval;
+		if (retval) {
+			if ((retval = omnibook_ec_read16(XE3GC_BDV0 + (offset * num), &(*battinfo).dv)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GC_BDC0 + (offset * num), &(*battinfo).dc)))
+				return retval;
+			if ((retval = omnibook_ec_read(XE3GC_BTY0 + (offset * num), &(*battinfo).type)))
+				return retval;
+
+			(*battinfo).type = ((*battinfo).type & XE3GC_BTY_MASK) ? 1 : 0;
+			(*battinfo).sn = 0; /* Unknown */
+		} else
+			return 1;
+		break;
+	case AMILOD:
+		offset = 0x10;
+		retval = omnibook_battery_present(num);
+		if (retval < 0)
+			return retval;
+		if (retval) {
+			if ((retval = omnibook_ec_read16(AMILOD_BDV0 + (offset * num), &(*battinfo).dv)))
+				return retval;
+			if ((retval = omnibook_ec_read16(AMILOD_BDC0 + (offset * num), &(*battinfo).dc)))
+				return retval;
+			if ((retval = omnibook_ec_read(AMILOD_BTY0 + (offset * num), &(*battinfo).type)))
+				return retval;
+
+			(*battinfo).type = ((*battinfo).type & AMILOD_BTY_MASK) ? 1 : 0;
+			(*battinfo).sn = 0; /* Unknown */
+		} else
+			return 1;
+		break;
+	/* FIXME */
+	case OB500:
+	case OB510:
+		switch (num) {
+		case 0:
+			break;
+		case 1:
+			break;
+		case 2:
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case OB6000:
+	case OB6100:
+	case XE4500:
+		switch (num) {
+		case 0:
+			break;
+		case 1:
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return 2;
+	}
+	return 0;
+}
+
+/*
+ * Get battery status
+ * return values:
+ *  < 0 - ERROR
+ *    0 - OK
+ *    1 - Battery is not present
+ *    2 - Not supported
+ */
+int omnibook_get_battery_status(int num, struct omnibook_battery_status *battstat)
+{
+	int retval;
+	u8 status;
+	u16 dc;
+	int gauge;
+	u8 offset;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		offset = 0x10;
+		retval = omnibook_battery_present(num);
+		if (retval < 0)
+			return retval;
+		if (retval) {
+			if ((retval = omnibook_ec_read(XE3GF_BST0 + (offset * num), &status)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GF_BRC0 + (offset * num), &(*battstat).rc)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GF_BPV0 + (offset * num), &(*battstat).pv)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GF_BFC0 + (offset * num), &(*battstat).lc)))
+				return retval;
+			if ((retval = omnibook_ec_read(XE3GF_GAU0 + (offset * num), &(*battstat).gauge)))
+				return retval;
+
+			if (status & XE3GF_BST_MASK_CRT)
+				(*battstat).status = OMNIBOOK_BATTSTAT_CRITICAL;
+			else if (status & XE3GF_BST_MASK_CHR)
+				(*battstat).status = OMNIBOOK_BATTSTAT_CHARGING;
+			else if (status & XE3GF_BST_MASK_DSC)
+				(*battstat).status = OMNIBOOK_BATTSTAT_DISCHARGING;
+			else if (status & (XE3GF_BST_MASK_CHR | XE3GF_BST_MASK_DSC))
+				(*battstat).status = OMNIBOOK_BATTSTAT_UNKNOWN;
+			else {
+				(*battstat).status = OMNIBOOK_BATTSTAT_CHARGED;
+			}
+		} else
+			return 1;
+		break;
+	case XE3GC:
+		offset = 0x10;
+		retval = omnibook_battery_present(num);
+		if (retval < 0)
+			return retval;
+		if (retval) {
+			if ((retval = omnibook_ec_read(XE3GC_BST0 + (offset * num), &status)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GC_BRC0 + (offset * num), &(*battstat).rc)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GC_BPV0 + (offset * num), &(*battstat).pv)))
+				return retval;
+			if ((retval = omnibook_ec_read16(XE3GC_BDC0 + (offset * num), &dc)))
+				return retval;
+
+			if (status & XE3GC_BST_MASK_CRT)
+				(*battstat).status = OMNIBOOK_BATTSTAT_CRITICAL;
+			else if (status & XE3GC_BST_MASK_CHR)
+				(*battstat).status = OMNIBOOK_BATTSTAT_CHARGING;
+			else if (status & XE3GC_BST_MASK_DSC)
+				(*battstat).status = OMNIBOOK_BATTSTAT_DISCHARGING;
+			else if (status & (XE3GC_BST_MASK_CHR | XE3GC_BST_MASK_DSC))
+				(*battstat).status = OMNIBOOK_BATTSTAT_UNKNOWN;
+			else {
+				(*battstat).status = OMNIBOOK_BATTSTAT_CHARGED;
+			}
+			gauge = ((*battstat).rc * 100) / dc;
+			(*battstat).gauge = gauge;
+			(*battstat).lc = 0; /* Unknown */
+		} else
+			return 1;
+		break;
+	case AMILOD:
+		offset = 0x10;
+		retval = omnibook_battery_present(num);
+		if (retval < 0)
+			return retval;
+		if (retval) {
+			if ((retval = omnibook_ec_read(AMILOD_BST0 + (offset * num), &status)))
+				return retval;
+			if ((retval = omnibook_ec_read16(AMILOD_BRC0 + (offset * num), &(*battstat).rc)))
+				return retval;
+			if ((retval = omnibook_ec_read16(AMILOD_BPV0 + (offset * num), &(*battstat).pv)))
+				return retval;
+			if ((retval = omnibook_ec_read16(AMILOD_BDC0 + (offset * num), &dc)))
+				return retval;
+
+			if (status & AMILOD_BST_MASK_CRT)
+				(*battstat).status = OMNIBOOK_BATTSTAT_CRITICAL;
+			else if (status & AMILOD_BST_MASK_CHR)
+				(*battstat).status = OMNIBOOK_BATTSTAT_CHARGING;
+			else if (status & AMILOD_BST_MASK_DSC)
+				(*battstat).status = OMNIBOOK_BATTSTAT_DISCHARGING;
+			else if (status & (AMILOD_BST_MASK_CHR | AMILOD_BST_MASK_DSC))
+				(*battstat).status = OMNIBOOK_BATTSTAT_UNKNOWN;
+			else {
+				(*battstat).status = OMNIBOOK_BATTSTAT_CHARGED;
+			}
+			gauge = ((*battstat).rc * 100) / dc;
+			(*battstat).gauge = gauge;
+			(*battstat).lc = 0; /* Unknown */
+		} else
+			return 1;
+		break;
+	case OB500:
+	case OB510:
+		switch (num) {
+		case 0:
+			if ((retval = omnibook_ec_read(OB500_BT1S, &status)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT1C, &(*battstat).rc)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT1V, &(*battstat).pv)))
+				return retval;
+			break;
+		case 1:
+			if ((retval = omnibook_ec_read(OB500_BT2S, &status)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT2C, &(*battstat).rc)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT2V, &(*battstat).pv)))
+				return retval;
+			break;
+		case 2:
+			if ((retval = omnibook_ec_read(OB500_BT3S, &status)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT3C, &(*battstat).rc)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT3V, &(*battstat).pv)))
+				return retval;
+			break;
+		default:
+			return -EINVAL;
+		}
+		if (status & OB500_BST_MASK_CRT)
+			(*battstat).status = OMNIBOOK_BATTSTAT_CRITICAL;
+		else if (status & OB500_BST_MASK_CHR)
+			(*battstat).status = OMNIBOOK_BATTSTAT_CHARGING;
+		else if (status & OB500_BST_MASK_DSC)
+			(*battstat).status = OMNIBOOK_BATTSTAT_DISCHARGING;
+		else if (status & (OB500_BST_MASK_CHR | OB500_BST_MASK_DSC))
+			(*battstat).status = OMNIBOOK_BATTSTAT_UNKNOWN;
+		else {
+			(*battstat).status = OMNIBOOK_BATTSTAT_CHARGED;
+		}
+		break;
+	case OB6000:
+	case OB6100:
+	case XE4500:
+		switch (num) {
+		case 0:
+			if ((retval = omnibook_ec_read(OB500_BT1S, &status)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT1C, &(*battstat).rc)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT1V, &(*battstat).pv)))
+				return retval;
+			break;
+		case 1:
+			if ((retval = omnibook_ec_read(OB500_BT3S, &status)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT3C, &(*battstat).rc)))
+				return retval;
+			if ((retval = omnibook_ec_read16(OB500_BT3V, &(*battstat).pv)))
+				return retval;
+			break;
+		default:
+			return -EINVAL;
+		}
+		if (status & OB500_BST_MASK_CRT)
+			(*battstat).status = OMNIBOOK_BATTSTAT_CRITICAL;
+		else if (status & OB500_BST_MASK_CHR)
+			(*battstat).status = OMNIBOOK_BATTSTAT_CHARGING;
+		else if (status & OB500_BST_MASK_DSC)
+			(*battstat).status = OMNIBOOK_BATTSTAT_DISCHARGING;
+		else if (status & (OB500_BST_MASK_CHR | OB500_BST_MASK_DSC))
+			(*battstat).status = OMNIBOOK_BATTSTAT_UNKNOWN;
+		else {
+			(*battstat).status = OMNIBOOK_BATTSTAT_CHARGED;
+		}
+		break;
+	default:
+		return 2;
+	}
+	return 0;
+}
+
+static int omnibook_proc_battery(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *statustr;
+	char *typestr;
+	int max = 0;
+	int num = 0; 
+	int retval;
+	char *b = buffer;
+	int i;
+	struct omnibook_battery_info battinfo;
+	struct omnibook_battery_status battstat;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+	case AMILOD:
+	case TSP10:
+		max = 2;
+		break;
+	case OB500:
+	case OB510:
+		max = 3;
+		break;
+	}
+	
+	for (i = 0; i < max; i++) {
+		retval = omnibook_get_battery_info(i, &battinfo);
+		if (retval == 0) {
+			num++;
+			omnibook_get_battery_status(i, &battstat);
+			typestr = (battinfo.type) ? "Li-Ion" : "NiMH";
+			switch (battstat.status) {
+			case OMNIBOOK_BATTSTAT_CHARGED:
+				statustr = "charged";
+				break;
+			case OMNIBOOK_BATTSTAT_DISCHARGING:
+				statustr = "discharging";
+				break;
+			case OMNIBOOK_BATTSTAT_CHARGING:
+				statustr = "charging";
+				break;
+			case OMNIBOOK_BATTSTAT_CRITICAL:
+				statustr = "critical";
+				break;
+			default:
+				statustr = "unknown";
+			}
+
+			b += sprintf(b, "Battery:            %11d\n", i);
+			b += sprintf(b, "Type:               %11s\n", typestr);
+			if (battinfo.sn)
+				b += sprintf(b, "Serial Number:      %11d\n", battinfo.sn);
+			b += sprintf(b, "Present Voltage:    %11d mV\n", battstat.pv);
+			b += sprintf(b, "Design Voltage:     %11d mV\n", battinfo.dv);
+			b += sprintf(b, "Remaining Capacity: %11d mAh\n", battstat.rc);
+			if (battstat.lc)
+				b += sprintf(b, "Last Full Capacity: %11d mAh\n", battstat.lc);
+			b += sprintf(b, "Design Capacity:    %11d mAh\n", battinfo.dc);
+			b += sprintf(b, "Gauge:              %11d %%\n", battstat.gauge);
+			b += sprintf(b, "Status:             %11s\n", statustr);
+			b += sprintf(b, "\n");
+		}
+	}
+	if (num == 0)
+		b += sprintf(b, "No battery present\n");
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+int __init omnibook_battery_init(void)
+{
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	/* FIXME */
+//	case OB500:
+//	case OB510:
+//	case OB6000:
+//	case OB6100:
+//	case XE4500:
+	case AMILOD:
+	case TSP10:
+		pmode = S_IFREG | S_IRUGO;
+		proc_battery = create_proc_read_entry("battery", pmode, omnibook_proc_root, omnibook_proc_battery, NULL);
+		break;
+	default:
+		printk(KERN_INFO "%s: Battery status monitoring is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	if (! proc_battery) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/battery.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	printk(KERN_INFO "%s: Battery status monitoring is enabled.\n", OMNIBOOK_MODULE_NAME);
+	return 0;
+}
+
+void __exit omnibook_battery_cleanup(void)
+{
+	if (proc_battery)
+		remove_proc_entry("battery", omnibook_proc_root);
+}
+
+EXPORT_SYMBOL(omnibook_battery_present);
+EXPORT_SYMBOL(omnibook_get_battery_info);
+EXPORT_SYMBOL(omnibook_get_battery_status);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/blank.c linux-2.6.10-rc1/drivers/char/omnibook/blank.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/blank.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/blank.c	2004-05-02 05:59:07.000000000 +0200
@@ -0,0 +1,212 @@
+/*
+ * blank.c -- blanking lcd console
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_blank;
+int omnibook_console_blank_enabled = 0;
+
+extern int (*console_blank_hook)(int);
+
+/*
+ * Turn LCD display off at console blanking if APM does not do it
+ * (e.g. using ACPI).
+ */
+
+int omnibook_lcd_blank(int blank)
+{
+	int retval = 0;
+#ifdef CONFIG_VT
+	u8 cmd;
+	
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case AMILOD:
+	case TSP10:
+		cmd = blank ? OMNIBOOK_KBC_CMD_LCD_OFF : OMNIBOOK_KBC_CMD_LCD_ON;
+		if ((retval = omnibook_kbc_command(OMNIBOOK_KBC_CONTROL_CMD, cmd)))
+			return retval;
+		break;
+	case OB500:
+	case OB6000:
+	case XE2:
+		if ((retval = omnibook_io_read(OB500_GPO1, &cmd)))
+			return retval;
+		cmd = blank ? cmd & ~OB500_BKLT_MASK : cmd | OB500_BKLT_MASK;
+		if ((retval = omnibook_io_write(OB500_GPO1, cmd)))
+			return retval;
+		break;
+	case OB510:
+	case OB6100:
+		if ((retval = omnibook_io_read(OB510_GPO2, &cmd)))
+			return retval;
+		cmd = blank ? cmd & ~OB510_BKLT_MASK : cmd | OB510_BKLT_MASK;
+		if ((retval = omnibook_io_write(OB510_GPO2, cmd)))
+			return retval;
+		break;
+	default:
+		printk(KERN_INFO "%s: LCD console blanking is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+#endif
+	return retval;
+}
+
+int omnibook_console_blank_enable(void)
+{
+#ifdef CONFIG_VT
+	if (omnibook_console_blank_enabled == 0) {
+		if (console_blank_hook == NULL) {
+			console_blank_hook = omnibook_lcd_blank;
+			printk(KERN_INFO "%s: LCD backlight turn off at console blanking is enabled.\n", OMNIBOOK_MODULE_NAME);
+			omnibook_console_blank_enabled = 1;
+		} else {
+			printk(KERN_INFO "%s: There is a console blanking solution already registered.\n", OMNIBOOK_MODULE_NAME);
+		}
+	}
+#endif
+	return 0;
+}
+	
+int omnibook_console_blank_disable(void)
+{
+#ifdef CONFIG_VT
+	if (console_blank_hook == omnibook_lcd_blank) {
+		console_blank_hook = NULL;
+		printk(KERN_INFO "%s: LCD backlight turn off at console blanking is disabled.\n", OMNIBOOK_MODULE_NAME);
+		omnibook_console_blank_enabled = 0;
+	} else if (console_blank_hook) {
+		printk(KERN_WARNING "%s: You can not disable another console blanking solution.\n", OMNIBOOK_MODULE_NAME);
+		return -EBUSY;
+	} else {
+		printk(KERN_INFO "%s: Console blanking already disabled.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+#endif
+	return 0;
+}
+
+static int omnibook_console_blank_status(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+
+	b += sprintf(b, "LCD console blanking is %s\n", (omnibook_console_blank_enabled) ? "enabled" : "disabled");
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+static int omnibook_console_blank_set(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	char status[1] = {'\0'};
+	int retval;
+
+	if ((retval = copy_from_user(status, buffer, 1)))
+		return retval;
+	switch (*status) {
+	case '0':
+		if ((retval = omnibook_console_blank_disable()))
+			return retval;
+		break;
+	case '1':
+		if ((retval = omnibook_console_blank_enable()))
+			return retval;
+		break;
+	default:
+		count = -EINVAL;
+	}
+	return count;
+}
+
+int __init omnibook_console_blank_init(void)
+{
+#ifdef CONFIG_VT
+	mode_t pmode;
+	int retval;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE2:
+	case AMILOD:
+	case TSP10:
+		if ((retval = omnibook_console_blank_enable()))
+			return retval;
+		pmode = S_IFREG | S_IWUSR | S_IRUGO;
+		if (omnibook_userset)
+			pmode = pmode | S_IWUGO;
+		proc_blank = create_proc_entry("blank", pmode, omnibook_proc_root);
+		break;
+	default:
+		printk(KERN_INFO "%s: LCD console blanking is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	
+	if (proc_blank) {
+		proc_blank->read_proc = omnibook_console_blank_status;
+		proc_blank->write_proc = omnibook_console_blank_set;
+	} else {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/blank.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	return 0;
+#else
+	printk(KERN_ERR "%s: Virtual terminal support is not compiled into your kernel.\n", OMNIBOOK_MODULE_NAME);
+	return -ENODEV;
+#endif
+}
+
+void __exit omnibook_console_blank_cleanup(void)
+{
+#ifdef CONFIG_VT
+	if (proc_blank) {
+		remove_proc_entry("blank", omnibook_proc_root);
+		omnibook_console_blank_disable();
+	}
+#endif
+}
+
+EXPORT_SYMBOL(omnibook_console_blank_enabled);
+EXPORT_SYMBOL(omnibook_lcd_blank);
+EXPORT_SYMBOL(omnibook_console_blank_enable);
+EXPORT_SYMBOL(omnibook_console_blank_disable);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/BUGS linux-2.6.10-rc1/drivers/char/omnibook/BUGS
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/BUGS	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/BUGS	2003-11-10 18:08:40.000000000 +0100
@@ -0,0 +1,47 @@
+Bugs and problems in omnibook module code
+=========================================
+
+* Unloading causes kernel Oops on 2.6 series kernels.
+* You can use /proc/apm emulation for battery status monitoring only.
+* Volume Control buttons do not generate scancodes on XE3GC style models.
+  Scancode emulation needs intensive testing to be reliable.
+* Scancode emulation may cause packet loss on serial interfaces. It caused
+  by spinlocks during polling.
+* Volume Control buttons on machine (not on docking station) do not generate
+  scancodes on OB500 style models. It is unhandled yet.
+* Sometimes (I assume when the embedded controller is busy) the procfs
+  interface displays fake values.
+* Setting the LCD brightness on HP OmniBook XE3 GF via /proc/omnibook/lcd
+  is working if you press one of the brightness control keys once after
+  writing the value into /proc/omnibook/lcd.
+* After reenable the touchpad via /proc/omnibook/touchpad you may restart
+  X / gpm.
+* DMI code in kernel available at boot time only so I need to reuse it to
+  identify the machine in an independent module.
+* Early boot time workarounds could not be added to a module because of it
+  loaded later.
+* I'm not a native English speaker so text corrections are welcome.
+
+Problems with OmniBook machines running Linux
+=============================================
+
+* If you use APM there are a lot of mysterious hangs at suspend/resume on
+  the new models. The OmniBooks use ACPI not APM but ACPI for Linux does not
+  provide reliable power management functions yet. Use swsusp instead.
+* In some cases the touchpad in XE3 GF models can freeze the laptop after
+  disabling and reenabling it with the disable button and doing a tap
+  action when neither gpm nor X is running. It seems to be a BIOS or
+  firmware bug.
+  Please report if you can reproduce it.
+* On XE3 GC models Fn-s key combination try to suspend to ram which freezes
+  the machine completely.
+* The ESS winmodem in XE3 (and other) machines is not working with Linux.
+  There are binary only drivers but those have a lot of problems (eg. lock
+  up the machine at disconnect etc.)
+  The divers can be downloaded from the URLs below:
+  HP OmniBook XE3 GF:
+  http://andrew.cait.org/ess/ES2839_4Linux2_4_18-2mdk.zip
+  HP OmniBook XE3 GC:
+  http://luftstrom.bastun.net/ess-modem-1989.tar.gz
+* The 3Com winmodem in OmniBook 5xx (and other) laptops is unsupported by
+  Linux.
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/ChangeLog linux-2.6.10-rc1/drivers/char/omnibook/ChangeLog
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/ChangeLog	2004-09-16 09:19:27.000000000 +0200
@@ -0,0 +1,309 @@
+Changelog file for omnibook package:
+------------------------------------
+
+2004-09-16 Soós Péter <sp@osb.hu>
+* Added INSTALL-2.6 file
+* Little spelling fixes in documentation
+* Little bugfixes
+* Added Compal ACL10
+
+2004-07-01 Soós Péter <sp@osb.hu>
+* Added new technology codes
+* Added some new HP nx9000 detection string
+* Added Toshiba Satellite P20
+
+2004-06-07 Chris Green <cmg@dok.org>
+* Added Toshiba Satellite P15
+
+2004-06-01 Soós Péter <sp@osb.hu>
+* Added Toshiba Satellite 1955
+* Added Toshiba Satellite 2435
+* Added Toshiba Satellite P10 (new ectype)
+* Acer Aspire 1350
+
+2004-01-23 Soós Péter <sp@osb.hu>
+* Added HP Pavilion ze8500 (HP nx9010)
+* fixed PM handler for OneTouch keys and touchpad
+
+2004-01-20 Soós Péter <sp@osb.hu>
+* Only fan status supported on HP OmniBook 4150, XE2 and
+  Fujitsu-Siemens Amilo D, fan control is unsupported
+* #include fixes in ec.c
+
+2004-01-16 Soós Péter <sp@osb.hu>
+* Added fan support for Fujitsu-Siemens Amilo D series laptops
+
+2004-01-14 Soós Péter <sp@osb.hu>
+* Fixed Makefile for kernels 2.6
+* Added Fujitsu-Siemens Amilo D series laptops (new ectype)
+
+2003-12-08 Soós Péter <sp@osb.hu>
+
+* Fixed tecnology code detection
+* Added HP/Compaq nx9005
+* Fixed Makefile for kernel 2.4
+
+2003-11-12 Soós Péter <sp@osb.hu>
+
+* Fixed KERNEL_WARNING in init.c
+
+2003-11-10 Soós Péter <sp@osb.hu>
+
+* Fixed timeout bugs in ec.c
+* Fixed touchpad dependency code for kernel 2.6
+* Added Compaq nx9000
+
+2003-11-10 Mark Chappell <mark@nslm.fsnet.co.uk>
+
+* Added kernel 2.6 support to Makefile
+
+2003-10-23 Soós Péter <sp@osb.hu>
+
+* Totally removed key polling code for kernels >= 2.5.0 but 2.5/2.6 kernels
+  is unsuported yet
+* proc_battery is static
+* Added HP OmniBook 900 B support
+* Added HP OmniBook XE2 support (added new ectype value for it)
+* Added Compaq nx9010
+* Reversed ChangeLog
+* Some documentation changes
+
+2003-08-28 Soós Péter <sp@osb.hu>
+
+* Added Toshiba Satellite 2430
+* Documentation enhancements
+
+2003-04-03 Soós Péter <sp@osb.hu>
+
+* Really fixed __init bug in user parameter code
+* Fixed omnibook_dmi_ident (it was static)
+
+2003-03-31 Soós Péter <sp@osb.hu>
+
+* Fixed HP technology code detection
+* Key polling is disabled by default on XE3GC style machines
+* Fixed PM code in polling.c
+* Added util.c
+* Fixed __init bug in user parameter code
+* Cleaned up ec.h
+* Added Toshiba Satellite 1950 detection
+* Documentation enhancements
+
+2003-03-13 Soós Péter <sp@osb.hu>
+
+* Added HP Pavilion ZU1155 and ZU1175 detection
+
+2003-03-11 Soós Péter <sp@osb.hu>
+
+* Fixed bogus version information
+
+2003-03-06 Ducrot Bruno <ducrot@poupinou.org>
+
+* Fan off hack for XE3GF style machines
+
+2003-03-04 Ducrot Bruno <ducrot@poupinou.org>
+
+* Fixed spinlock problem
+
+2003-02-28 Soós Péter <sp@osb.hu>
+
+* Added /proc/omnibook/version
+* Added OMNIBOOK_ prefix to MODULE_NAME and MODULE_VERSION definitions
+* Fixed bugs in lcd.c (thanks to Bernhard Kaindl <bernhard.kaindl@gmx.de>)
+* Some code tuning and cosmetic changes
+* Fixed OmniBook 4150 support
+
+2003-02-26 Soós Péter <sp@osb.hu>
+
+* Fixed kernel Oops in technology code identification
+* Some minor changes in logging
+
+2003-02-25 Soós Péter <sp@osb.hu>
+
+* Try to identify HP laptops by technology code if machine is unsupported
+* Fixed dmi identification code
+
+2003-02-14 Soós Péter <sp@osb.hu>
+
+* Added HP Pavilion ze4100 support
+* Added HP Pavilion ze4200 support
+* Fixed HP Pavilion xt155 detection
+* Added Acer Aspire 1400 series laptop support
+* Fixed APM status detection bug
+* Cleaned up dmi identification code
+* Removed "Asset Tag:" field from dmi string structure
+
+2003-01-27 Soós Péter <sp@osb.hu>
+
+* Added HP Pavilion N5430 support
+* EC functions are work even if boot parameter acpi=off is given
+* Improved error handling in externally callable functions
+* Fixed kernel integration patch
+* Removed unreliable undocking feature for OB500
+* Fixed HP Pavilion N5415 support
+* Added new format hotkeys sample files
+
+2003-01-09 Ducrot Bruno <ducrot@poupinou.org>
+
+* Added to use ACPI_EC if available
+
+2003-01-09 Soós Péter <sp@osb.hu>
+
+* Fixed reverse console blanking bug on OB5xx and OB6xxx
+* Disabled unreliable undocking feature on OB500
+
+2003-01-08 Ducrot Bruno <ducrot@poupinou.org>
+
+* Added Toshiba Satellite 3000, 3005, 1000, 1005, 1110, 1115, 1900, 1905
+  support
+
+2003-01-08 Soós Péter <sp@osb.hu>
+
+* The ectype values changed again! See the README!
+* Fixed new ectypes detection bug
+* Added OmniBook xe4400 support
+* Added LCD display turn off at console blanking on OB5xx and OB6xxx
+* Documentation fixes
+
+2003-01-07 Soós Péter <sp@osb.hu>
+
+* Fixed bit level negation bug in fan.c
+* Added turn fan on for Toshiba 3000
+* Corrected OmniBook 4150 support code
+
+2003-01-06 Soós Péter <sp@osb.hu>
+
+* Changed ectype values! See the README!
+* Fixed some bugs in obtest utility
+* Fixed second battery status bug in battery.c
+* Added textual descriptions to some functions in /proc/omnibook
+* Fix APM emulation to work when APM support is present but APM power
+  status reporting flagged broken
+* Added docking station support
+* Added fan support
+* Added module parameter: user
+* Added OmniBook xe155, xe4100 and ze4125 support
+* Fan policy moved to /proc/omnibook/fan_policy
+* Reorganized scancode emulation code for XE3 GC
+* Polling of volume buttons on XE3CG style models can be enabled/disabled
+  via /proc/omnibook/key_polling
+* Finished abstraction layer
+* Some minor changes in Rick's model detection code
+* New kernel integration code
+
+2002-12-22 Rick Richardson <rickr@mn.rr.com>
+
+* Added on and off as valid input to /proc/omnibook/lcd, to turn
+  the LCD backlight on and off.
+
+2002-12-15 Rick Richardson <rickr@mn.rr.com>
+
+* Reimplemented model detection so you only have to modify one file
+  to add a new model. features.h is now deprecated.
+* Added the Toshiba Satellite 1115/S103 to the supported models
+* Fixed bug in apmemu.c which caused /proc/apm to report the battery
+  status as critical when the battery was charging.
+
+2002-10-16 Soós Péter <sp@osb.hu>
+
+* Added HP Pavilion N5415 support
+* Corrected HP Pavilion N5441 support
+* Fix values of OB500 type machines in ec.h
+* LCD brightness support added for XE3GC and XE3GF style machines
+* Added HP OmniBook 510 FB support
+* AC adapter status monitoring is working on all machines
+* External display status monitoring is working on all machines
+* CPU temperature monitoring is working on all machines
+* __init functions gone to init.h
+* Added an abstraction layer between the low level, hardware dependent
+  functions and the applications (not yet finished). See omnibook.h for
+  details.
+
+2002-09-20 Soós Péter <sp@osb.hu>
+
+* Using save_flags()/cli() instead spinlocks in ec.c because of laptops do
+  not have more than one CPU (yet ;)). This improves performance and
+  eliminates packet loss in ppp stack
+* The previous version of XE3 GC scancode emulation was buggy: it worked only
+  when ACPI enabled. Current version is working ACPI independent way
+
+2002-09-05 Soós Péter <sp@osb.hu>
+
+* Added secondary battery support (untested, please report!)
+* Added ectype module parameter to specify the type of embedded
+  controller firmware
+* Added some OmniBook XE3 GC support code
+* Added some OmniBook 500 style embedded controller firmware support code
+  (OmniBook 5xx, 6xxx and some Pavilions)
+* Reorganized features matrix (again): the features depends on the embedded
+  controller firmware, not the model
+* Added external display status monitoring on some machine
+* Added scancode emulation on OmniBook XE3 GC
+
+2002-08-14 Soós Péter <sp@osb.hu>
+
+* Added HP OmniBook 6000 EA support (OneTouch only)
+* Added HP OmniBook 6100 EB support (OneTouch only)
+* Fixed Toshiba Satellite 3000-100 detection
+* Fixed timeout and locking bugs in ec.c
+* Added HP Pavilion Notebook ZT1141
+* Reorganized the feature matrix and parameter detection code to make easy
+  to add new features differents machine by machine
+
+2002-08-11 Soós Péter <sp@osb.hu>
+
+* Fixed removing of procfs entries
+* Fixed APM detection
+* Added kernel source integration
+* Fixed __initdata bugs
+* Handling difference between untesed and unsupported features
+
+2002-08-09 Soós Péter <sp@osb.hu>
+
+* Added Compal ACL00 laptop support
+* Updated documentation
+* Added touchpad support
+* Some bugfixes
+* /proc/apm emulation added
+
+2002-08-06 Soós Péter <sp@osb.hu>
+
+* Corrected full charged battery info
+* Added OneTouch handling via procfs
+* Added console blank handling via procfs
+* Added temperature policy handling via procfs
+* Corrected the bug in DMI code to report the serial number
+* Added module parameter support
+* Added HP Pavilion Notebook N5490, ZT1195 (and probably other Pavilions)
+
+2002-07-17 Soós Péter <sp@osb.hu>
+
+* Improved error handling
+* Some text corrections
+* Added Toshiba Satellite 3000-100 support
+* Some code tuning
+* Added omnibook prefix for variables and functions to prevent conflicts
+  with another code
+* Added /proc filesystem support
+* Added battery status monitoring
+* Added CPU temperature monitoring
+
+2002-06-03 Soós Péter <sp@osb.hu>
+
+* Some code tuning
+
+2002-05-07 Soós Péter <sp@osb.hu>
+
+* Added missing #include <linux/sched.h> to main.c
+* Some text corrections
+* Added HP OmniBook 500 FA support (OneTouch only)
+
+2002-05-06 Soós Péter <sp@osb.hu>
+
+* LCD display turn off at console blanking added
+* Code cleanup
+
+2002-05-02 Soós Péter <sp@osb.hu>
+
+* The first release of omnibook module
+* OneTouch button support
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/CREDITS linux-2.6.10-rc1/drivers/char/omnibook/CREDITS
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/CREDITS	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/CREDITS	2004-07-13 15:27:33.000000000 +0200
@@ -0,0 +1,39 @@
+The module is written by
+
+* Soós Péter <sp@osb.hu>
+
+Special thanks to the following persons and/or organisations (without
+particular order):
+
+* Al Stone <ahs3@fc.hp.com> and Linux Systems Operation at HP for lending
+  an HP OmniBook 500 for the project purposes.
+* Pavel Mihaylov <bin@bash.info> for his omke project discovering a lot of
+  OmniBook features, providing some code for XE3 GC machines and testing.
+* Ducrot Bruno <ducrot@poupinou.org> sharing lots of information about
+  embedded controller and related code, added lots of Toshiba support,
+  writing tosh3k code, sending patches etc.
+
+Thanks to the following people (without particular order):
+
+* Al Stone <ahs3@fc.hp.com> for sharing some programming information.
+* Guido Guenther <agx@sigxcpu.org> for initial OneTouch enabling code.
+* Jens Thoms Toerring <Jens.Toerring@physik.fu-berlin.de> for initial
+  OneTouch power management code.
+* Maciek Gorniak <mago@acn.waw.pl> for initial HP Pavilion N5415 detecting
+  code and initial lcd brighness code.
+* Rick Richardson <rickr@mn.rr.com> for some bugfixes and useful patches.
+* Bob McElrath <mcelrath@draal.physics.wisc.edu> for initial Compal ACL00
+  code.
+* Luisimi Moya <luismimoya@eresmas.net> for Acer Aspire 1400 support.
+* Bernhard Kaindl <bernhard.kaindl@gmx.de> for bugfixes and patches
+* Gabriele Vivinetto <gabriele.mailing@rvmgroup.it> for documentation
+  enhancements and testing.
+* Mark Chappell <nslm@nslm.fsnet.co.uk> for building on kernel 2.6.
+* Massimo Dal Zotto <dz@debian.org> for his i8k code.
+* Jonathan A. Buzzard <jonathan@buzzard.org.uk> for his toshiba code.
+* Some others on OmniBook mailing list at
+  http://zurich.ai.mit.edu/mailman/listinfo/omnibook
+  for providing information and testing.
+
+Last but not least thanks to Linus Torvald and more for creating and
+maintaining the Linux kernel.
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/display.c linux-2.6.10-rc1/drivers/char/omnibook/display.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/display.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/display.c	2004-05-02 05:59:33.000000000 +0200
@@ -0,0 +1,139 @@
+/*
+ * display.c -- external display related functions
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_display;
+
+int omnibook_get_display(void)
+{
+	int retval = 0;
+#ifdef CONFIG_VT
+	u8 sta;
+	
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		if ((retval = omnibook_ec_read(XE3GF_STA1, &sta)))
+			return retval;
+		retval = (sta & XE3GF_SHDD_MASK) ? 1 : 0;
+		break;
+	case XE3GC:
+		if ((retval = omnibook_ec_read(XE3GC_STA1, &sta)))
+			return retval;
+		retval = (sta & XE3GC_CRTI_MASK) ? 1 : 0;
+		break;
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+		if ((retval = omnibook_ec_read(OB500_STA1, &sta)))
+			return retval;
+		retval = (sta & OB500_CRTS_MASK) ? 1 : 0;
+		break;
+	case OB4150:
+		if ((retval = omnibook_ec_read(OB4150_STA2, &sta)))
+			return retval;
+		retval = (sta & OB4150_CRST_MASK) ? 1 : 0;
+		break;
+	default:
+		printk(KERN_INFO "%s: External display status monitoring is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+#endif
+	return retval;
+}
+
+static int omnibook_proc_display(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+	int display;
+
+	display = omnibook_get_display();
+	if (display < 0)
+		return display;
+
+	b += sprintf(b, "External display is %s\n", (display) ? "present" : "not present");
+	
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+int __init omnibook_display_init(void)
+{
+#ifdef CONFIG_VT
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+	case OB4150:
+	case TSP10:
+		pmode = S_IFREG | S_IRUGO;
+		proc_display = create_proc_read_entry("display", pmode, omnibook_proc_root, omnibook_proc_display, NULL);
+		break;
+	default:
+		printk(KERN_INFO "%s: External display status monitoring is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	if (! proc_display) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/display.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	printk(KERN_INFO "%s: External display status monitoring is enabled.\n", OMNIBOOK_MODULE_NAME);
+	return 0;
+#else
+	printk(KERN_ERR "%s: Virtual terminal support is not compiled into your kernel.\n", OMNIBOOK_MODULE_NAME);
+	return -ENODEV;
+#endif
+}
+
+void __exit omnibook_display_cleanup(void)
+{
+#ifdef CONFIG_VT
+	if (proc_display)
+		remove_proc_entry("display", omnibook_proc_root);
+#endif
+}
+
+EXPORT_SYMBOL(omnibook_get_display);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/dmi.c linux-2.6.10-rc1/drivers/char/omnibook/dmi.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/dmi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/dmi.c	2003-09-29 10:50:34.000000000 +0200
@@ -0,0 +1,205 @@
+/*
+ * dmi.c -- to get DMI information
+ *
+ * This code originally came from file arch/i386/kernel/dmi_scan.c from 
+ * Linux kernel version 2.4.18
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/apm_bios.h>
+#include <linux/slab.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "dmi.h"
+
+struct dmi_header
+{
+	u8	type;
+	u8	length;
+	u16	handle;
+};
+
+static char * __init dmi_string(struct dmi_header *dm, u8 s)
+{
+	u8 *bp=(u8 *)dm;
+	bp+=dm->length;
+	if(!s)
+		return "";
+	s--;
+	while(s>0 && *bp)
+	{
+		bp+=strlen(bp);
+		bp++;
+		s--;
+	}
+	return bp;
+}
+
+/*
+ *	We have to be cautious here. We have seen BIOSes with DMI pointers
+ *	pointing to completely the wrong place for example
+ */
+ 
+static int __init dmi_table(u32 base, int len, int num, void (*decode)(struct dmi_header *))
+{
+	u8 *buf;
+	struct dmi_header *dm;
+	u8 *data;
+	int i=0;
+		
+	buf = ioremap(base, len);
+	if(buf==NULL)
+		return -1;
+
+	data = buf;
+
+	/*
+ 	 *	Stop when we see all the items the table claimed to have
+ 	 *	OR we run off the end of the table (also happens)
+ 	 */
+ 
+	while(i<num && data-buf+sizeof(struct dmi_header)<=len)
+	{
+		dm=(struct dmi_header *)data;
+		/*
+		 *  We want to know the total length (formated area and strings)
+		 *  before decoding to make sure we won't run off the table in
+		 *  dmi_decode or dmi_string
+		 */
+		data+=dm->length;
+		while(data-buf<len-1 && (data[0] || data[1]))
+			data++;
+		if(data-buf<len-1)
+			decode(dm);
+		data+=2;
+		i++;
+	}
+	iounmap(buf);
+	return 0;
+}
+
+inline static int __init dmi_checksum(u8 *buf)
+{
+	u8 sum=0;
+	int a;
+
+	for(a=0; a<15; a++)
+		sum+=buf[a];
+	return (sum==0);
+}
+
+static int __init dmi_iterate(void (*decode)(struct dmi_header *))
+{
+	u8 buf[15];
+	u32 fp=0xF0000;
+
+#ifdef CONFIG_SIMNOW
+	/*
+	 *      Skip on x86/64 with simnow. Will eventually go away
+	 *      If you see this ifdef in 2.6pre mail me !
+	 */
+	return -1;
+#endif
+
+	while( fp < 0xFFFFF)
+	{
+		isa_memcpy_fromio(buf, fp, 15);
+		if(memcmp(buf, "_DMI_", 5)==0 && dmi_checksum(buf))
+		{
+			u16 num=buf[13]<<8|buf[12];
+			u16 len=buf[7]<<8|buf[6];
+			u32 base=buf[11]<<24|buf[10]<<16|buf[9]<<8|buf[8];
+
+			if(dmi_table(base,len,num,decode)==0)
+				return 0;
+		}
+		fp+=16;
+	}
+	return -1;
+}
+
+char *omnibook_dmi_ident[OMNIBOOK_STRING_MAX];
+
+/*
+ *	Save a DMI string
+ */
+ 
+static void __init dmi_save_ident(struct dmi_header *dm, int slot, int string)
+{
+	char *d = (char*)dm;
+	char *p = dmi_string(dm, d[string]);
+	if(p==NULL || *p == 0)
+		return;
+	if (omnibook_dmi_ident[slot])
+		return;
+	omnibook_dmi_ident[slot] = kmalloc(strlen(p)+1, GFP_KERNEL);
+	if(omnibook_dmi_ident[slot])
+		strcpy(omnibook_dmi_ident[slot], p);
+	else
+		printk(KERN_ERR "%s: dmi_save_ident: out of memory.\n", OMNIBOOK_MODULE_NAME);
+}
+
+/*
+ *	Process a DMI table entry. Right now all we care about are the BIOS
+ *	and machine entries. For 2.5 we should pull the smbus controller info
+ *	out of here.
+ */
+
+static void __init dmi_decode(struct dmi_header *dm)
+{
+	switch(dm->type)
+	{
+		case  0:
+			dmi_save_ident(dm, OMNIBOOK_BIOS_VENDOR, 4);
+			dmi_save_ident(dm, OMNIBOOK_BIOS_VERSION, 5);
+			dmi_save_ident(dm, OMNIBOOK_BIOS_DATE, 8);
+			break;
+			
+		case 1:
+			dmi_save_ident(dm, OMNIBOOK_SYS_VENDOR, 4);
+			dmi_save_ident(dm, OMNIBOOK_PRODUCT_NAME, 5);
+			dmi_save_ident(dm, OMNIBOOK_PRODUCT_VERSION, 6);
+			dmi_save_ident(dm, OMNIBOOK_SERIAL_NUMBER, 7);
+			break;
+		case 2:
+			dmi_save_ident(dm, OMNIBOOK_BOARD_VENDOR, 4);
+			dmi_save_ident(dm, OMNIBOOK_BOARD_NAME, 5);
+			dmi_save_ident(dm, OMNIBOOK_BOARD_VERSION, 6);
+			break;
+	}
+}
+
+int __init omnibook_dmi_scan_machine(void)
+{
+	int err = dmi_iterate(dmi_decode);
+	return err;
+}
+
+EXPORT_SYMBOL(omnibook_dmi_ident);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/dmi.h linux-2.6.10-rc1/drivers/char/omnibook/dmi.h
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/dmi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/dmi.h	2003-03-03 11:04:39.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ * dmi.h -- code to get DMI information
+ *
+ * This code originally came from file arch/i386/kernel/dmi_scan.c from 
+ * Linux kernel version 2.4.18
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+enum
+{
+	OMNIBOOK_BIOS_VENDOR,
+	OMNIBOOK_BIOS_VERSION,
+	OMNIBOOK_BIOS_DATE,
+	OMNIBOOK_SYS_VENDOR,
+	OMNIBOOK_PRODUCT_NAME,
+	OMNIBOOK_PRODUCT_VERSION,
+	OMNIBOOK_SERIAL_NUMBER,
+	OMNIBOOK_BOARD_VENDOR,
+	OMNIBOOK_BOARD_NAME,
+	OMNIBOOK_BOARD_VERSION,
+	OMNIBOOK_STRING_MAX
+};
+
+extern char *omnibook_dmi_ident[OMNIBOOK_STRING_MAX];
+
+extern int __init omnibook_dmi_scan_machine(void);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/dock.c linux-2.6.10-rc1/drivers/char/omnibook/dock.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/dock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/dock.c	2004-01-14 20:15:58.000000000 +0100
@@ -0,0 +1,123 @@
+/*
+ * dock.c -- docking station/port replicator support
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_dock;
+
+int omnibook_get_dock(void)
+{
+	u8 dock;
+	int retval;
+	
+	switch (omnibook_ectype) {
+	case XE3GF:
+		if ((retval = omnibook_ec_read(XE3GF_CSPR, &dock)))
+			return retval;
+		retval = (dock & XE3GF_CSPR_MASK) ? 1 : 0;
+		break;
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+		if ((retval = omnibook_ec_read(OB500_STA1, &dock)))
+			return retval;
+		retval = (dock & OB500_DCKS_MASK) ? 1 : 0;
+		break;
+	case OB4150:
+		if ((retval = omnibook_ec_read(OB4150_DCID, &dock)))
+			return retval;
+		retval = (dock) ? 1 : 0;
+		break;
+	default:
+		printk(KERN_INFO "%s: Docking station handling is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+
+	return retval;
+}
+	
+static int omnibook_dock_status(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+	int dock;
+
+	dock = omnibook_get_dock();
+	if (dock < 0)
+		return dock;
+
+	b += sprintf(b, "Laptop is %s\n", (dock) ? "docked" : "undocked");
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+int __init omnibook_dock_init(void)
+{
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case OB4150:
+		pmode = S_IFREG | S_IRUGO;
+		proc_dock = create_proc_read_entry("dock", pmode, omnibook_proc_root, omnibook_dock_status, NULL);
+		break;
+	default:
+		printk(KERN_INFO "%s: Docking station status monitoring is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	
+	if (! proc_dock) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/dock.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	printk(KERN_INFO "%s: Docking station status monitoring is enabled.\n", OMNIBOOK_MODULE_NAME);
+	return 0;
+}
+
+void __exit omnibook_dock_cleanup(void)
+{
+	if (proc_dock)
+		remove_proc_entry("dock", omnibook_proc_root);
+}
+
+EXPORT_SYMBOL(omnibook_get_dock);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/ec.c linux-2.6.10-rc1/drivers/char/omnibook/ec.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/ec.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/ec.c	2004-01-19 09:38:16.000000000 +0100
@@ -0,0 +1,343 @@
+/*
+ * ec.c -- low level functions to access Embedded Conrtroller,
+ *         Keyboard Controller and system I/O ports or memory
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#ifdef CONFIG_ACPI_EC
+#include <linux/acpi.h>
+#ifdef ACPI_CA_VERSION
+#if ACPI_CA_VERSION > 0x20021121
+#define USE_ACPI_EC
+#endif
+#endif
+#endif
+
+#include <asm/io.h>
+
+#include "ec.h"
+
+/*
+ *	Interrupt control
+ */
+
+#ifdef CONFIG_SMP /* Are you ready for SMP laptops? Coming soon... ;) */
+static spinlock_t omnibook_ec_lock = SPIN_LOCK_UNLOCKED;
+#include <linux/spinlock.h>
+#define omnibook_save_flags(x)		spin_lock_irqsave(&omnibook_ec_lock, x)
+#define omnibook_restore_flags(x)	spin_unlock_irqrestore(&omnibook_ec_lock, x)
+#else
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,28))
+#define omnibook_save_flags(x)		do { save_flags(x); cli(); } while (0)
+#define omnibook_restore_flags(x)	restore_flags(x)
+#else
+#define omnibook_save_flags(x)		local_irq_save(x)
+#define omnibook_restore_flags(x)	local_irq_restore(x)
+#endif
+#endif /* CONFIG_SMP */
+
+/*
+ * Timeout in ms for sending to controller
+ */
+
+#define OMNIBOOK_TIMEOUT		250
+
+/*
+ * Registers of the embedded controller
+ */
+
+#define OMNIBOOK_EC_DATA		0x62
+#define OMNIBOOK_EC_SC			0x66
+
+/*
+ * Embedded controller status register bits
+ */
+
+#define OMNIBOOK_EC_STAT_OBF		0x01    /* Output buffer full */
+#define OMNIBOOK_EC_STAT_IBF		0x02    /* Input buffer full */
+#define OMNIBOOK_EC_STAT_CMD		0x08    /* Last write was a command write (0=data) */
+
+/*
+ * Embedded controller commands
+ */
+
+#define OMNIBOOK_EC_CMD_READ		0x80
+#define OMNIBOOK_EC_CMD_WRITE		0x81
+#define OMNIBOOK_EC_CMD_QUERY		0x84
+
+/*
+ * Wait for embedded controller buffer
+ */
+
+static int omnibook_ec_wait(u8 event)
+{
+	int timeout = OMNIBOOK_TIMEOUT;
+
+	switch (event) {
+	case OMNIBOOK_EC_STAT_OBF:
+		while (!(inb(OMNIBOOK_EC_SC) & event) && timeout--)
+			mdelay(1);
+		break;
+	case OMNIBOOK_EC_STAT_IBF:
+		while ((inb(OMNIBOOK_EC_SC) & event) && timeout--)
+			mdelay(1);
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (timeout>0)
+		return 0;
+	return -ETIME;
+}
+
+/*
+ * Read from the embedded controller
+ */
+
+int omnibook_ec_read(u8 addr, u8 *data)
+{
+	unsigned long flags;
+	int retval;
+	
+#ifdef USE_ACPI_EC
+	retval = ec_read(addr, data);
+	if (!retval)
+		return retval;
+#endif
+	omnibook_save_flags(flags);
+	retval = omnibook_ec_wait(OMNIBOOK_EC_STAT_IBF);
+	if (retval)
+		goto end;
+	outb(OMNIBOOK_EC_CMD_READ, OMNIBOOK_EC_SC);
+	retval = omnibook_ec_wait(OMNIBOOK_EC_STAT_IBF);
+	if (retval)
+		goto end;
+	outb(addr, OMNIBOOK_EC_DATA);
+	retval = omnibook_ec_wait(OMNIBOOK_EC_STAT_OBF);
+	if (retval)
+		goto end;
+	*data = inb(OMNIBOOK_EC_DATA);
+end:
+	omnibook_restore_flags(flags);
+	return retval;
+}
+
+/*
+ * Write to the embedded controller
+ */
+
+int omnibook_ec_write(u8 addr, u8 data)
+{
+
+	unsigned long flags;
+	int retval;
+	
+#ifdef USE_ACPI_EC
+	retval = ec_write(addr, data);
+	if (!retval)
+		return retval;
+#endif
+	omnibook_save_flags(flags);
+	retval = omnibook_ec_wait(OMNIBOOK_EC_STAT_IBF);
+	if (retval)
+		goto end;
+	outb(OMNIBOOK_EC_CMD_WRITE, OMNIBOOK_EC_SC);
+	retval = omnibook_ec_wait(OMNIBOOK_EC_STAT_IBF);
+	if (retval)
+		goto end;
+	outb(addr, OMNIBOOK_EC_DATA);
+	retval = omnibook_ec_wait(OMNIBOOK_EC_STAT_IBF);
+	if (retval)
+		goto end;
+	outb(data, OMNIBOOK_EC_DATA);
+end:
+	omnibook_restore_flags(flags);
+	return retval;
+}
+
+int omnibook_ec_read16(u8 addr, u16 *data)
+{
+	int retval;
+	u8 high;
+	u8 low;
+	u16 result;
+
+	retval = omnibook_ec_read(addr, &low);
+	if (retval)
+		return retval;
+	retval = omnibook_ec_read(addr + 0x01, &high);
+	result = ((high << 8) + low);
+	*data = result;
+	return retval;
+}
+
+/*
+ * Registers of the keyboard controller
+ */
+
+#define OMNIBOOK_KBC_DATA		0x60
+#define OMNIBOOK_KBC_SC			0x64
+
+/*
+ * Keyboard controller status register bits
+ */
+
+#define OMNIBOOK_KBC_STAT_OBF		0x01    /* Output buffer full */
+#define OMNIBOOK_KBC_STAT_IBF		0x02    /* Input buffer full */
+#define OMNIBOOK_KBC_STAT_CMD		0x08    /* Last write was a command write (0=data) */
+
+/*
+ * Wait for keyboard buffer
+ */
+
+static int omnibook_kbc_wait(u8 event)
+{
+	int timeout = OMNIBOOK_TIMEOUT;
+
+	switch (event) {
+	case OMNIBOOK_KBC_STAT_OBF:
+		while (!(inb(OMNIBOOK_KBC_SC) & event) && timeout--)
+			mdelay(1);
+		break;
+	case OMNIBOOK_KBC_STAT_IBF:
+		while ((inb(OMNIBOOK_KBC_SC) & event) && timeout--)
+			mdelay(1);
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (timeout>0)
+		return 0;
+	return -ETIME;
+}
+
+/*
+ * Write to the keyboard command register
+ */
+
+static int omnibook_kbc_write_command(u8 cmd)
+{
+	unsigned long flags;
+	int retval;
+	
+	omnibook_save_flags(flags);
+	retval = omnibook_kbc_wait(OMNIBOOK_KBC_STAT_IBF);
+	if (retval)
+		goto end;
+	outb(cmd, OMNIBOOK_KBC_SC);
+	retval = omnibook_kbc_wait(OMNIBOOK_KBC_STAT_IBF);
+end:
+	omnibook_restore_flags(flags);
+	return retval;
+}
+
+/*
+ * Write to the keyboard data register
+ */
+
+static int omnibook_kbc_write_data(u8 data)
+{
+	unsigned long flags;
+	int retval;
+	
+	omnibook_save_flags(flags);
+	retval = omnibook_kbc_wait(OMNIBOOK_KBC_STAT_IBF);
+	if (retval)
+		goto end;;
+	outb(data, OMNIBOOK_KBC_DATA);
+	retval = omnibook_kbc_wait(OMNIBOOK_KBC_STAT_IBF);
+end:
+	omnibook_restore_flags(flags);
+	return retval;
+}
+
+/*
+ * Send a command to keyboard controller
+ */
+
+int omnibook_kbc_command(u8 cmd, u8 data)
+{
+	int retval;
+	
+	retval = omnibook_kbc_write_command(cmd);
+	if (retval)
+		return retval;
+	retval = omnibook_kbc_write_data(data);
+	return retval;
+}
+
+/*
+ * Read a value from a system I/O address
+ */
+
+int omnibook_io_read(u32 addr, u8 *data)
+{
+	unsigned long flags;
+
+	omnibook_save_flags(flags);
+	*data = inb(addr);
+	omnibook_restore_flags(flags);
+	return 0;
+}
+
+/*
+ * Write a value to a system I/O address
+ */
+
+int omnibook_io_write(u32 addr, u8 data)
+{
+	unsigned long flags;
+
+	omnibook_save_flags(flags);
+	outb(data, addr);
+	omnibook_restore_flags(flags);
+	return 0;
+}
+
+/*
+ * Read a value from a system memory address
+ */
+
+int omnibook_mem_read(u32 addr, u8 *data)
+{
+	char *base = ioremap(addr, 1);
+
+	*data = readb(base);
+	iounmap(base);
+	return 0;
+}
+
+/*
+ * Write a value to a system memory address
+ */
+
+int omnibook_mem_write(u32 addr, u8 data)
+{
+	char *base = ioremap(addr, 1);
+
+	writeb(data, base);
+	iounmap(base);
+	return 0;
+}
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/ec.h linux-2.6.10-rc1/drivers/char/omnibook/ec.h
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/ec.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/ec.h	2004-01-14 20:16:09.000000000 +0100
@@ -0,0 +1,307 @@
+/*
+ * ec.h -- low level definitions to access Embedded Conrtroller
+ *         and Keyboard Controller and system I/O ports or memory
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+extern int omnibook_ec_read(u8 addr, u8 *data);
+extern int omnibook_ec_read16(u8 addr, u16 *data);
+extern int omnibook_ec_write(u8 addr, u8 data);
+extern int omnibook_kbc_command(u8 cmd, u8 data);
+extern int omnibook_io_read(u32 addr, u8 *data);
+extern int omnibook_io_write(u32 addr, u8 data);
+extern int omnibook_mem_read(u32 addr, u8 *data);
+extern int omnibook_mem_write(u32 addr, u8 data);
+
+/*
+ *	Embedded controller adresses
+ */
+
+#define XE3GF_CHGM				0x90	/* , 16 bit */
+#define XE3GF_CHGS				0x92	/* , 16 bit */
+#define XE3GF_CHGC				0x94	/* Current charge of board, 16 bit */
+#define XE3GF_CHGV				0x96	/* Current voltage, 16 bit */
+#define XE3GF_CHGA				0x98	/* Current intensity, 16 bit */
+#define XE3GF_BAL				0x9A	/* Battery present status */
+#define XE3GF_STA1				0x9C	/* Various status bits*/
+#define XE3GF_CSPR				0xA1	/* Port replicator status, 1 bit */
+#define XE3GF_ADP				0xA3	/* AC acapter status, 1 bit */
+#define XE3GF_FOT				0xA5	/* Fan off temperature, 8 bit */
+#define XE3GF_FSD1				0xA6	/* Fan on temperature, 8 bit */
+#define XE3GF_FSD2				0xA7	/* Fan level 2 temperature, 8 bit */
+#define XE3GF_FSD3				0xA8	/* Fan level 3 temperature, 8 bit */
+#define XE3GF_FSD4				0xA9	/* Fan level 4 temperature, 8 bit */
+#define XE3GF_FSD5				0xAA	/* Fan level 5 temperature, 8 bit */
+#define XE3GF_FSD6				0xAB	/* Fan level 6 temperature, 8 bit */
+#define XE3GF_FSD7				0xAC	/* Fan level 7 temperature, 8 bit */
+#define XE3GF_FSRD				0xAD	/* Fan status, 8 bit */
+#define XE3GF_CTMP				0xB0	/* CPU tempetature, 8 bit */
+#define XE3GF_BRTS				0xB9	/* LCD brightness, 4 bit */
+#define XE3GF_BTY0				0xC0	/* Battery 0 type, 1 bit */
+#define XE3GF_BST0				0xC1	/* Battery 0 status, 3 bit */
+#define XE3GF_BRC0				0xC2	/* Battery 0 remaining capacity, 16 bit */
+#define XE3GF_BSN0				0xC4	/* Battery 0 serial number 16 bit */
+#define XE3GF_BPV0				0xC6	/* Battery 0 present voltage, 16 bit */
+#define XE3GF_BDV0				0xC8	/* Battery 0 design voltage 16 bit */
+#define XE3GF_BDC0				0xCA	/* Battery 0 design capacity 16 bit */
+#define XE3GF_BFC0				0xCC	/* Battery 0 last full capacity 16 bit */
+#define XE3GF_GAU0				0xCE	/* Battery 0 gauge, 8 bit */
+#define XE3GF_BTY1				0xD0	/* Battery 1 type, 1 bit */
+#define XE3GF_BST1				0xD1	/* Battery 1 status, 3 bit */
+#define XE3GF_BRC1				0xD2	/* Battery 1 remaining capacity, 16 bit */
+#define XE3GF_BSN1				0xD4	/* Battery 1 serial number, 16 bit */
+#define XE3GF_BPV1				0xD6	/* Battery 1 present voltage, 16 bit */
+#define XE3GF_BDV1				0xD8	/* Battery 1 design voltage 16 bit */
+#define XE3GF_BDC1				0xDA	/* Battery 1 design capacity 16 bit */
+#define XE3GF_BFC1				0xDC	/* Battery 1 last full capacity 16 bit */
+#define XE3GF_GAU1				0xDE	/* Battery 1 gauge, 8 bit */
+
+/*
+ * Bitmasks for sub byte values
+ */
+
+#define XE3GF_SHDD_MASK				0x40	/* External display status */
+#define XE3GF_CSPR_MASK				0x01	/* Port replicator status */
+#define XE3GF_ADP_MASK				0x20	/* AC acapter status */
+#define XE3GF_BAL0_MASK				0x01	/* Battery 0 present */
+#define XE3GF_BAL1_MASK				0x02	/* Battery 1 present */
+#define XE3GF_BMF_MASK				0x70	/* Model code */
+#define XE3GF_BTY_MASK				0x80	/* Type: Ni-MH or Li-Ion */
+#define XE3GF_BST_MASK_DSC			0x01	/* Discarging */
+#define XE3GF_BST_MASK_CHR			0x02	/* Charging */
+#define XE3GF_BST_MASK_CRT			0x04	/* Critical */
+#define XE3GF_FSRD_MASK_S1			0x01	/* Fan level 1 */
+#define XE3GF_FSRD_MASK_S2			0x02	/* Fan level 2 */
+#define XE3GF_FSRD_MASK_S3			0x04	/* Fan level 3 */
+#define XE3GF_FSRD_MASK_S4			0x08	/* Fan level 4 */
+#define XE3GF_FSRD_MASK_S5			0x10	/* Fan level 5 */
+#define XE3GF_FSRD_MASK_S6			0x20	/* Fan level 6 */
+#define XE3GF_FSRD_MASK_S7			0x40	/* Fan level 7 */
+#define XE3GF_BRTS_MASK				0x0F	/* LCD brightness */
+
+#define XE3GF_FAN_ON_MASK			0x02	/* Fan on */
+
+/*
+ * OmniBook XE3 GC values
+ */
+
+#define XE3GC_CTMP				0x28	/* CPU tempetature, 8 bit */
+#define XE3GC_STA1				0x30	/* Various status bits */
+#define XE3GC_Q0A				0x31	/* Various status bits */
+#define XE3GC_CCUR				0x38	/* Current charge of board, 16 bit ? */
+#define XE3GC_CVOL				0x3A	/* Current voltage, 16 bit ? */
+#define XE3GC_CARM				0x3C	/* Current intensity, 16 bit ? */
+#define XE3GC_BAT				0x3E	/* Battery present status */
+#define XE3GC_BST0				0x40	/* Battery 0 status, 3 bit */
+#define XE3GC_BPR0				0x41	/* Battery 0 present rate, 16 bit ? */
+#define XE3GC_BRC0				0x43	/* Battery 0 remaining capacity, 16 bit */
+#define XE3GC_BPV0				0x45	/* Battery 0 present voltage, 16 bit */
+#define XE3GC_BDV0				0x47	/* Battery 0 design voltage 16 bit */
+#define XE3GC_BDC0				0x49	/* Battery 0 design capacity 16 bit */
+#define XE3GC_BTY0				0x4A	/* Battery 0 type, 1 bit ?*/
+#define XE3GC_BTP0				0x4B	/* Battery 0 ?, 1 bit */
+#define XE3GC_BSN0				0x4C	/* Battery 0 serial number, 8 bit ?*/
+#define XE3GC_BMF0				0x4D	/* Battery 0 ?,8 bit */
+#define XE3GC_BST1				0x50	/* Battery 1 status, 3 bit */
+#define XE3GC_BPR1				0x51	/* Battery 1 present rate, 16 bit ? */
+#define XE3GC_BRC1				0x53	/* Battery 1 remaining capacity, 16 bit */
+#define XE3GC_BPV1				0x55	/* Battery 1 present voltage, 16 bit */
+#define XE3GC_BDV1				0x57	/* Battery 1 design voltage 16 bit */
+#define XE3GC_BDC1				0x59	/* Battery 1 design capacity 16 bit */
+#define XE3GC_BTY1				0x5A	/* Battery 1 type, 1 bit ?*/
+#define XE3GC_BTP1				0x5B	/* Battery 1 ?, 1 bit */
+#define XE3GC_BSN1				0x5C	/* Battery 1 serial number, 8 bit ?*/
+#define XE3GC_BMF1				0x5D	/* Battery 1 ?,8 bit */
+#define XE3GC_STA2				0x61	/* Various status bits */
+#define XE3GC_BTVL				0x6A	/* LCD brightness, 4 bit */
+
+/*
+ * Bitmasks for sub byte values
+ */
+
+#define XE3GC_ADP_MASK				0x40	/* AC acapter status */
+#define XE3GC_BAT0_MASK				0x01	/* Battery 0 present */
+#define XE3GC_BAT1_MASK				0x02	/* Battery 1 present */
+#define XE3GC_BTY_MASK				0x01	/* Type: Ni-MH or Li-Ion */
+#define XE3GC_BST_MASK_DSC			0x01	/* Discarging */
+#define XE3GC_BST_MASK_CHR			0x02	/* Charging */
+#define XE3GC_BST_MASK_CRT			0x04	/* Critical */
+#define XE3GC_CRTI_MASK				0x04	/* External display status */
+#define XE3GC_SLPB_MASK				0x01	/* Sleep button pressed */
+#define XE3GC_F5_MASK				0x02	/* Fn-F5 - LCD/CRT switch pressed */
+#define XE3GC_VOLD_MASK				0x04	/* Fn-down arrow or Volume down pressed */
+#define XE3GC_VOLU_MASK				0x08	/* Fn-up arrow or Volume up pressed */
+#define XE3GC_MUTE_MASK				0x10	/* Fn+F7 - Volume mute pressed */
+#define XE3GC_CNTR_MASK				0x20	/* Fn+F3/Fn+F4 - Contrast up or down pressed */
+#define XE3GC_BRGT_MASK				0x40	/* Fn+F1/Fn+F2 - Brightness up or down pressed */
+#define XE3GC_BTVL_MASK				0x0F	/* LCD brightness */
+
+/*
+ * Emulated scancodes
+ */
+
+#define XE3GC_VOLD_SCAN				0x2E	/* Volume down button scancode */
+#define XE3GC_VOLU_SCAN				0x30	/* Volume up button scancode */
+#define XE3GC_MUTE_SCAN				0x20	/* Volume up button scancode */
+
+/*
+ * Fujitsu Amilo D values
+ */
+
+#define AMILOD_TMP				0x28	/* CPU tempetature, 8 bit */
+#define AMILOD_STA1				0x30	/* Various status bits */
+#define AMILOD_BAT				0x3E	/* Battery present status */
+#define AMILOD_BDC0				0x40	/* Battery 0 design capacity 16 bit */
+#define AMILOD_BDV0				0x42	/* Battery 0 design voltage 16 bit */
+#define AMILOD_BTY0				0x44	/* Battery 0 type, 1 bit ?*/
+#define AMILOD_BST0				0x45	/* Battery 0 status, 3 bit */
+#define AMILOD_BPR0				0x46	/* Battery 0 present rate, 16 bit ? */
+#define AMILOD_BRC0				0x48	/* Battery 0 remaining capacity, 16 bit */
+#define AMILOD_BPV0				0x4A	/* Battery 0 present voltage, 16 bit */
+#define AMILOD_BTP0				0x4C	/* Battery 0 ?, 1 bit */
+#define AMILOD_BDC1				0x50	/* Battery 1 design capacity 16 bit */
+#define AMILOD_BDV1				0x52	/* Battery 1 design voltage 16 bit */
+#define AMILOD_BTY1				0x54	/* Battery 1 type, 1 bit ?*/
+#define AMILOD_BST1				0x55	/* Battery 1 status, 3 bit */
+#define AMILOD_BPR1				0x56	/* Battery 1 present rate, 16 bit ? */
+#define AMILOD_BRC1				0x58	/* Battery 1 remaining capacity, 16 bit */
+#define AMILOD_BPV1				0x5A	/* Battery 1 present voltage, 16 bit */
+#define AMILOD_BTP1				0x5C	/* Battery 1 ?, 1 bit */
+#define AMILOD_CBRG				0x6F	/* LCD brightness, 4 bit */
+
+/*
+ * Bitmasks for sub byte values
+ */
+
+#define AMILOD_ADP_MASK				0x40	/* AC acapter status */
+#define AMILOD_BAT0_MASK			0x01	/* Battery 0 present */
+#define AMILOD_BAT1_MASK			0x02	/* Battery 1 present */
+#define AMILOD_BTY_MASK				0x01	/* Type: Ni-MH or Li-Ion */
+#define AMILOD_BST_MASK_DSC			0x01	/* Discarging */
+#define AMILOD_BST_MASK_CHR			0x02	/* Charging */
+#define AMILOD_BST_MASK_CRT			0x04	/* Critical */
+#define AMILOD_CBRG_MASK			0x0F	/* LCD brightness */
+
+/*
+ * OmniBook 500, 510, 6000, 6100, XE2 values
+ */
+
+#define OB500_STA1				0x44	/* Various status bits */
+#define OB500_STA2				0x50	/* Various status bits */
+#define OB500_CTMP				0x55	/* CPU tempetature, 8 bit */
+#define OB500_BT1I				0x58	/* Battery 1 ? 16 bit */
+#define OB500_BT1C				0x5A	/* Battery 1 remaining capacity 16 bit ? */
+#define OB500_BT1V				0x5C	/* Battery 1 present voltage 16 bit ? */
+#define OB500_BT1S				0x5E	/* Battery 1 status 3 bit ? */
+#define OB500_BT2I				0x6A	/* Battery 2 ? 16 bit */
+#define OB500_BT2C				0x6C	/* Battery 2 remaining capacity 16 bit ? */
+#define OB500_BT2V				0x6E	/* Battery 2 present voltage 16 bit ? */
+#define OB500_BT2S				0x70	/* Battery 2 status 3 bit ? */
+#define OB500_BT3I				0x5F	/* Battery 3 ? 16 bit */
+#define OB500_BT3C				0x61	/* Battery 3 remaining capacity 16 bit ? */
+#define OB500_BT3V				0x63	/* Battery 3 present voltage 16 bit ? */
+#define OB500_BT3S				0x65	/* Battery 3 status 3 bit ? */
+
+#define OB6000_STA1				0x77	/* Various status bits */
+
+#define XE2_STA1				0x50	/* Various status bits */
+
+/*
+ * Bitmasks for sub byte values
+ */
+
+#define OB500_LIDS_MASK				0x01	/* LID status */
+#define OB500_CRTS_MASK				0x20	/* External display status */
+#define OB500_SLPS_MASK				0x40	/* Sleep button status */
+#define OB500_DCKS_MASK				0x80	/* Docking status */
+#define OB500_ADP_MASK				0x02	/* AC acapter status */
+#define OB500_BST_MASK_DSC			0x01	/* Discarging */
+#define OB500_BST_MASK_CHR			0x02	/* Charging */
+#define OB500_BST_MASK_CRT			0x04	/* Critical */
+
+#define OB6000_FAN_MASK				0x10	/* Fan status */
+
+#define XE2_ADP_MASK				0x02	/* AC acapter status */
+
+/*
+ * OmniBook 4150
+ */
+
+#define OB4150_TMP				0x28	/* CPU tempetature, 8 bit */
+#define OB4150_STA1				0x2E	/* Various status bits */
+#define OB4150_STA2				0x2F	/* Various status bits */
+#define OB4150_ADP				0x30	/* AC acapter status, 1 bit */
+#define OB4150_DCID				0x2C	/* Port replicator */
+
+/*
+ * Bitmasks for sub byte values
+ */
+
+#define OB4150_FAN_MASK				0x01	/* Fan status */
+#define OB4150_ADP_MASK				0x40	/* AC acapter status */
+#define OB4150_CRST_MASK			0x20	/* External display status */
+
+/*
+ *	Keyboard controller command for some laptop functions
+ */
+
+#define OMNIBOOK_KBC_CONTROL_CMD		0x59
+
+/*
+ *	Keyboard controller command parameters for functions available via kbc
+ */
+
+#define OMNIBOOK_KBC_CMD_ONETOUCH_ENABLE	0x90	/* Enables OneTouch buttons */
+#define OMNIBOOK_KBC_CMD_ONETOUCH_DISABLE	0x91	/* Disables OneTouch buttons */
+#define OMNIBOOK_KBC_CMD_TOUCHPAD_ENABLE	0xAA	/* Enables toucpad */
+#define OMNIBOOK_KBC_CMD_TOUCHPAD_DISABLE	0xA9	/* Disables toucpad */
+#define OMNIBOOK_KBC_CMD_LCD_ON			0xE1	/* Turns LCD display on */
+#define OMNIBOOK_KBC_CMD_LCD_OFF		0xE2	/* Turns LCD display off */
+#define OMNIBOOK_KBC_CMD_AC_POWER_ENABLE	0xC2	/* Enable AC power */
+#define OMNIBOOK_KBC_CMD_AC_POWER_DISABLE	0xC1	/* Disable AC power */
+
+/*
+ * Other I/O ports
+ */
+
+#define ACL00_AC_STAT				0x11B9	/* AC adapter status on ACL00 */
+#define ACL00_AC_MASK				0x04	/* Bitmask for AC adapter status on ACL00 */
+#define TOSH3K_AC_STAT				0x102D	/* AC adapter status on Toshiba 3000 */
+#define TOSH3K_AC_MASK				0x08	/* Bitmask for AC adapter status on Toshiba 3000 */
+#define XE3GF_AC_STAT				0x11B9	/* AC adapter status on XE3 GF */
+#define XE3GF_AC_MASK				0x04	/* Bitmask for AC adapter status on XE3 GF */
+#define XE3GF_LID_STAT				0x11AD	/* LID switch status on XE3 GF */
+#define XE3GF_LID_MASK				0x20	/* Bitmask for LID switch status on XE3 GF */
+#define XE3GC_SMIC				0xFE00
+
+#define OB500_GPO1				0x8034  /* Fan control */
+#define OB510_GPO2				0x11B9  /* LCD backlight */
+#define OB510_GPIO				0x118F  /* Fan control */
+
+#define OB500_FAN_ON_MASK			0x0A	/* Turn fan on with zero bits */
+#define OB500_FAN_OFF_MASK			0x08	/* Fan status/off */
+#define OB500_BKLT_MASK				0x40	/* LCD backlight */
+#define OB510_FAN_ON_MASK			0x18	/* Turn fan on with zero bits */
+#define OB510_FAN_OFF_MASK			0x10	/* Turn fan on */
+#define OB510_BKLT_MASK				0x01	/* LCD backlight */
+
+#define XE2_FAN_MASK				0x02	/* Turn fan on with zero bit */
+
+/*
+ * Memory adresses
+ */
+
+#define XE3GC_BCMD				0xFFFFEBC
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/fan.c linux-2.6.10-rc1/drivers/char/omnibook/fan.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/fan.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/fan.c	2004-05-02 06:00:31.000000000 +0200
@@ -0,0 +1,306 @@
+/*
+ * fan.c -- fan status/control
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_fan;
+
+int omnibook_get_fan(void)
+{
+	u8 fan;
+	int retval;
+	
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		if ((retval = omnibook_ec_read(XE3GF_FSRD, &fan)))
+			return retval;
+		retval = fan;
+		break;
+	case OB500:
+		if ((retval = omnibook_io_read(OB500_GPO1, &fan)))
+			return retval;
+		retval = (fan & OB500_FAN_OFF_MASK) ? 0 : 1;
+		break;
+	case OB510:
+		if ((retval = omnibook_io_read(OB510_GPIO, &fan)))
+			return retval;
+		retval = (fan & OB510_FAN_OFF_MASK) ? 0 : 1;
+		break;
+	case OB6000:
+	case OB6100:
+		if ((retval = omnibook_ec_read(OB6000_STA1, &fan)))
+			return retval;
+		retval = (fan & OB6000_FAN_MASK) ? 1 : 0;
+		break;
+	case OB4150:
+	case AMILOD:
+		if ((retval = omnibook_ec_read(OB4150_STA1, &fan)))
+			return retval;
+		retval = (fan & OB4150_FAN_MASK) ? 1 : 0;
+		break;
+	case XE2:
+		if ((retval = omnibook_io_read(OB500_GPO1, &fan)))
+			return retval;
+		retval = (fan & XE2_FAN_MASK) ? 0 : 1;
+		break;
+	default:
+		printk(KERN_INFO "%s: Fan status monitoring is unsupported on this machie.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+
+	return retval;
+}
+	
+int omnibook_fan_on(void)
+{
+	u8 fan;
+	int retval;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		if ((retval = omnibook_ec_read(XE3GF_FSRD, &fan)))
+			return retval;
+		if ((retval = omnibook_ec_write(XE3GF_FSRD, fan | XE3GF_FAN_ON_MASK)))
+			return retval;
+		break;
+	case OB500:
+		if ((retval = omnibook_io_read(OB500_GPO1, &fan)))
+			return retval;
+		if ((retval = omnibook_io_write(OB500_GPO1, fan & ~OB500_FAN_ON_MASK)))
+			return retval;
+		break;
+	case OB510:
+		if ((retval = omnibook_io_read(OB510_GPIO, &fan)))
+			return retval;
+		if ((retval = omnibook_io_write(OB510_GPIO, fan & ~OB510_FAN_ON_MASK)))
+			return retval;
+		break;
+	case OB6000:
+	case OB6100:
+		if ((retval = omnibook_ec_read(OB6000_STA1, &fan)))
+			return retval;
+		if ((retval = omnibook_ec_write(OB6000_STA1, fan | OB6000_FAN_MASK)))
+			return retval;
+		break;
+	case OB4150:
+	case AMILOD:
+		if ((retval = omnibook_ec_read(OB4150_STA1, &fan)))
+			return retval;
+		if ((retval = omnibook_ec_write(OB4150_STA1, fan | OB4150_FAN_MASK)))
+			return retval;
+		break;
+	case XE2:
+		if ((retval = omnibook_io_read(OB500_GPO1, &fan)))
+			return retval;
+		if ((retval = omnibook_io_write(OB500_GPO1, fan & ~XE2_FAN_MASK)))
+			return retval;
+		break;
+	default:
+		printk(KERN_INFO "%s: Direct fan control is unsupported on this machie.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+
+	return retval;
+}
+
+int omnibook_fan_off(void)
+{
+	u8 fan;
+	int retval;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		{
+			u8 fot, temp;
+			if ((retval = omnibook_ec_read(XE3GF_FSRD, &fan)))
+				return retval;
+
+			/* fan is already off */
+			if (!fan)
+				return 0;
+
+			/* now we set FOT to current temp, then reset to initial value */
+			if ((retval = omnibook_ec_read(XE3GF_FOT, &fot)))
+				return retval;
+			if ((retval = omnibook_ec_read(XE3GF_CTMP, &temp)))
+				return retval;
+			
+			do {
+				omnibook_ec_write(XE3GF_FOT, temp);
+				mdelay(1);
+			} while (omnibook_get_fan() != 0);
+
+			omnibook_ec_write(XE3GF_FOT, fot);
+		}
+		break;
+	case OB500:
+		if ((retval = omnibook_io_read(OB500_GPO1, &fan)))
+			return retval;
+		if ((retval = omnibook_io_write(OB500_GPO1, fan | OB500_FAN_OFF_MASK)))
+			return retval;
+		break;
+	case OB510:
+		if ((retval = omnibook_io_read(OB510_GPIO, &fan)))
+			return retval;
+		if ((retval = omnibook_io_write(OB510_GPIO, fan | OB510_FAN_OFF_MASK)))
+			return retval;
+		break;
+	case OB6000:
+	case OB6100:
+		if ((retval = omnibook_ec_read(OB6000_STA1, &fan)))
+			return retval;
+		if ((retval = omnibook_ec_write(OB6000_STA1, fan & ~OB6000_FAN_MASK)))
+			return retval;
+		break;
+	case OB4150:
+	case AMILOD:
+		if ((retval = omnibook_ec_read(OB4150_STA1, &fan)))
+			return retval;
+		if ((retval = omnibook_ec_write(OB4150_STA1, fan & ~OB4150_FAN_MASK)))
+			return retval;
+		break;
+	case XE2:
+		if ((retval = omnibook_io_read(OB500_GPO1, &fan)))
+			return retval;
+		if ((retval = omnibook_io_write(OB500_GPO1, fan | XE2_FAN_MASK)))
+			return retval;
+		break;
+	default:
+		printk(KERN_INFO "%s: Direct fan control is unsupported on this machie.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+
+	return retval;
+}
+
+static int omnibook_fan_status(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	int fan;
+	char *b = buffer;
+	char *str;
+
+	fan = omnibook_get_fan();
+	if (fan < 0)
+		return fan;
+	str = (fan) ? "on" : "off";
+
+	if (fan > 1)
+		b += sprintf(b, "Fan is %s (level %d)\n", str, fan);
+	else
+		b += sprintf(b, "Fan is %s\n", str);
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);;
+}
+
+static int omnibook_fan_set(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	char status[1] = {'\0'};
+
+	if (copy_from_user(status, buffer, 1))
+		return -EFAULT;
+	switch (*status) {
+	case '0':
+		omnibook_fan_off();
+		break;
+	case '1':
+		omnibook_fan_on();
+		break;
+	default:
+		count = -EINVAL;
+	}
+	
+	return count;
+}
+
+int __init omnibook_fan_init(void)
+{
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case TSP10:
+		pmode = S_IFREG | S_IWUSR | S_IRUGO;
+		if (omnibook_userset)
+			pmode = pmode | S_IWUGO;
+		proc_fan = create_proc_entry("fan", pmode, omnibook_proc_root);
+		if (proc_fan) {
+			proc_fan->read_proc = omnibook_fan_status;
+			proc_fan->write_proc = omnibook_fan_set;
+			printk(KERN_INFO "%s: Fan status monitor and control is enabled.\n", OMNIBOOK_MODULE_NAME);
+		}
+		break;
+	case OB4150:
+	case XE2:
+	case AMILOD:
+		pmode = S_IFREG | S_IRUGO;
+		proc_fan = create_proc_read_entry("fan", pmode, omnibook_proc_root, omnibook_fan_status, NULL);
+		if (proc_fan) {
+			printk(KERN_INFO "%s: Fan status monitor is enabled.\n", OMNIBOOK_MODULE_NAME);
+			printk(KERN_INFO "%s: Fan control is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		}
+		break;
+	default:
+		printk(KERN_INFO "%s: Fan status monitor and control is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	if (! proc_fan) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/fan.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	
+	return 0;
+}
+
+void __exit omnibook_fan_cleanup(void)
+{
+	if (proc_fan)
+		remove_proc_entry("fan", omnibook_proc_root);
+}
+
+EXPORT_SYMBOL(omnibook_get_fan);
+EXPORT_SYMBOL(omnibook_fan_on);
+EXPORT_SYMBOL(omnibook_fan_off);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/fan_policy.c linux-2.6.10-rc1/drivers/char/omnibook/fan_policy.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/fan_policy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/fan_policy.c	2004-01-14 20:16:23.000000000 +0100
@@ -0,0 +1,227 @@
+/*
+ * fan_policy.c -- fan policy support
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_fan_policy;
+
+u8 omnibook_fan_policy[OMNIBOOK_FAN_LEVELS];
+
+int omnibook_get_fan_policy(void)
+{
+	int retval = 0;
+	int i;
+	u8 tmp;
+	
+	switch (omnibook_ectype) {
+	case XE3GF:
+		for (i = 0; i <= OMNIBOOK_FAN_LEVELS; i++) {
+			if ((retval = omnibook_ec_read(XE3GF_FOT + i, &tmp)))
+				return retval;
+			omnibook_fan_policy[i] = tmp;
+		}
+		break;
+	default:
+		printk(KERN_INFO "%s: Fan policy is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+
+	return retval;
+}
+
+int omnibook_set_fan_policy(void)
+{
+	int retval;
+	int i;
+	
+	switch (omnibook_ectype) {
+	case XE3GF:
+		if (omnibook_fan_policy[0] > OMNIBOOK_FOT_MAX)
+			return -EINVAL;
+		for (i = 0; i < OMNIBOOK_FAN_LEVELS; i++) {
+			if ((omnibook_fan_policy[i] > omnibook_fan_policy[i + 1]) || (omnibook_fan_policy[i] < OMNIBOOK_FAN_MIN) || (omnibook_fan_policy[i] > OMNIBOOK_FAN_MAX))
+				return -EINVAL;
+			if (omnibook_fan_policy[i + 1] > OMNIBOOK_FAN_MAX)
+				return -EINVAL;
+		}
+		for (i = 0; i <= OMNIBOOK_FAN_LEVELS; i++) {
+			if ((retval = omnibook_ec_write(XE3GF_FOT + i, omnibook_fan_policy[i])))
+				return retval;
+		}
+		break;
+	default:
+		printk(KERN_INFO "%s: Fan policy is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+
+	return retval;
+}
+
+int omnibook_set_fan_policy_defaults(void)
+{
+	int retval;
+	int i;
+	u8 fan_defaults[] = {
+		OMNIBOOK_FOT_DEFAULT,
+		OMNIBOOK_FAN1_DEFAULT,
+		OMNIBOOK_FAN2_DEFAULT,
+		OMNIBOOK_FAN3_DEFAULT,
+		OMNIBOOK_FAN4_DEFAULT,
+		OMNIBOOK_FAN5_DEFAULT,
+		OMNIBOOK_FAN6_DEFAULT,
+		OMNIBOOK_FAN7_DEFAULT,
+	};
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+		for (i = 0; i <= OMNIBOOK_FAN_LEVELS; i++) {
+			if ((retval = omnibook_ec_write(XE3GF_FOT + i, fan_defaults[i])))
+				return retval;
+		}
+		break;
+	default:
+		printk(KERN_INFO "%s: Fan policy is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+
+	return retval;
+}
+
+static int omnibook_proc_fan_policy_status(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	int retval;
+	char *b = buffer;
+	u8 i;
+	
+	if ((retval = omnibook_get_fan_policy()))
+		return retval;
+
+	b += sprintf(b, "Fan off temperature:        %2d C\n", omnibook_fan_policy[0]);
+	b += sprintf(b, "Fan on temperature:         %2d C\n", omnibook_fan_policy[1]);
+	for (i = 2; i <= OMNIBOOK_FAN_LEVELS; i++) {
+		b += sprintf(b, "Fan level %1d temperature:    %2d C\n", i, omnibook_fan_policy[i]);
+	}
+	b += sprintf(b, "Minimal temperature to set: %2d C\n", OMNIBOOK_FAN_MIN);
+	b += sprintf(b, "Maximal temperature to set: %2d C\n", OMNIBOOK_FAN_MAX);
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+static int omnibook_proc_fan_policy_set(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int len = (count < OMNIBOOK_FAN_POLICY_STRING) ? count : OMNIBOOK_FAN_POLICY_STRING;
+	char status[OMNIBOOK_FAN_POLICY_STRING] = {'\0'};
+	char *b;
+	char *prev;
+	u8 n;
+	u8 c;
+	int retval;
+
+	if ((retval = omnibook_get_fan_policy()))
+		return retval;
+
+	if (copy_from_user(status, buffer, len))
+		return -EFAULT;
+	status[len] = 0;
+	b = status;
+	n = 0;
+	c = 0;
+	prev = NULL;
+	do {
+		printk(KERN_INFO "%s: c=%d\n", OMNIBOOK_MODULE_NAME, c);
+		if (n > OMNIBOOK_FAN_LEVELS)
+			return -EINVAL;
+		if (*b >= '0' && *b <= '9')
+			c = c * 10 + (*b - '0');
+		else if (((*b == ' ') || (*b == '\0') || (*b == '\n')) && (*prev >= '0') && (*prev <= '9')) {
+			omnibook_fan_policy[n] = c;
+			n++;
+			c = 0;
+		} else {
+			return -EINVAL;
+		}
+		prev = b;
+		b++;
+	} while ((*prev != '\n') && (*prev != '\0'));
+
+	/* A zero value set the defaults */ 
+	if ((omnibook_fan_policy[0] == 0) && (n == 1)) {
+		if ((retval = omnibook_set_fan_policy_defaults()))
+			return retval;
+	} else
+		omnibook_set_fan_policy();
+
+	return count;
+}
+
+int __init omnibook_fan_policy_init(void)
+{
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+		pmode = S_IFREG | S_IWUSR | S_IRUGO;
+		if (omnibook_userset)
+			pmode = pmode | S_IWUGO;
+		proc_fan_policy = create_proc_entry("fan_policy", pmode, omnibook_proc_root);
+		break;
+	default:
+		printk(KERN_INFO "%s: Fan policy is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	if (proc_fan_policy) {
+			proc_fan_policy->read_proc = omnibook_proc_fan_policy_status;
+			proc_fan_policy->write_proc = omnibook_proc_fan_policy_set;
+	} else {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/fan_policy.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	printk(KERN_INFO "%s: Fan policy setting is enabled.\n", OMNIBOOK_MODULE_NAME);
+	return 0;
+}
+
+void __exit omnibook_fan_policy_cleanup(void)
+{
+	if (proc_fan_policy)
+		remove_proc_entry("fan_policy", omnibook_proc_root);
+}
+
+EXPORT_SYMBOL(omnibook_fan_policy);
+EXPORT_SYMBOL(omnibook_get_fan_policy);
+EXPORT_SYMBOL(omnibook_set_fan_policy);
+EXPORT_SYMBOL(omnibook_set_fan_policy_defaults);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/init.c linux-2.6.10-rc1/drivers/char/omnibook/init.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/init.c	2004-09-16 09:18:38.000000000 +0200
@@ -0,0 +1,509 @@
+/*
+ * init.c -- module initialization code
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "dmi.h"
+#include "init.h"
+#include "util.h"
+
+int omnibook_ectype;
+int omnibook_userset;
+
+struct proc_dir_entry *omnibook_proc_root __initdata = NULL;
+static struct proc_dir_entry *proc_version;
+static struct proc_dir_entry *proc_dmi;
+
+/*
+ * Module parameters
+ *  0 disables the feature
+ * >1 enables the feature
+ * All feature enabled by default
+ */
+
+static int ectype __initdata = NONE;
+static int ac __initdata = 1;
+static int battery __initdata = 1;
+static int blank __initdata = 1;
+static int display __initdata = 1;
+static int dmi __initdata = 1;
+static int fan __initdata = 1;
+static int fan_policy __initdata = 1;
+static int onetouch __initdata = 1;
+static int lcd __initdata = 1;
+static int temperature __initdata = 1;
+static int touchpad __initdata = 1;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+static int key_polling __initdata = 1;
+#endif
+
+static int apmemu __initdata = 0;
+static int dock __initdata = 0;
+static int user __initdata = 0;
+
+static int omnibook_proc_version(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+
+	b += sprintf(b, "%s\n", OMNIBOOK_MODULE_VERSION);
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+static int omnibook_proc_dmi(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+
+	b += sprintf(b, "BIOS Vendor:   %s\n", omnibook_dmi_ident[OMNIBOOK_BIOS_VENDOR]);
+	b += sprintf(b, "BIOS Version:  %s\n", omnibook_dmi_ident[OMNIBOOK_BIOS_VERSION]);
+	b += sprintf(b, "BIOS Release:  %s\n", omnibook_dmi_ident[OMNIBOOK_BIOS_DATE]);
+	b += sprintf(b, "System Vendor: %s\n", omnibook_dmi_ident[OMNIBOOK_SYS_VENDOR]);
+	b += sprintf(b, "Product Name:  %s\n", omnibook_dmi_ident[OMNIBOOK_PRODUCT_NAME]);
+	b += sprintf(b, "Version:       %s\n", omnibook_dmi_ident[OMNIBOOK_PRODUCT_VERSION]);
+	b += sprintf(b, "Serial Number: %s\n", omnibook_dmi_ident[OMNIBOOK_SERIAL_NUMBER]);
+	b += sprintf(b, "Board Vendor:  %s\n", omnibook_dmi_ident[OMNIBOOK_BOARD_VENDOR]);
+	b += sprintf(b, "Board Name:    %s\n", omnibook_dmi_ident[OMNIBOOK_BOARD_NAME]);
+	b += sprintf(b, "Board Version: %s\n", omnibook_dmi_ident[OMNIBOOK_BOARD_VERSION]);
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+#define HP_SIGNATURE	"Hewlett-Packard"
+
+struct omnibook_models_t {
+	/* DMI field matchers (table inputs) */
+	char	*sys_vendor;
+	char	*product_name;
+	char	*product_version;
+	char	*board_name;
+
+	/* Table outputs */
+	char	*syslog_name;		/* Name which will appear in the syslog */
+	int	ectype;			/* Type of the embedded controller firmware, see omnibook.h and README */
+};
+
+static struct omnibook_models_t omnibook_models[] __initdata = {
+  /* sys_vendor product_name                 product_version                   board_name syslog_name                  ectype */
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook XE3 GF*",            NULL,    NULL,                          XE3GF },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook XT1000*",            NULL,    NULL,                          XE3GF },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook XE2 DC*",            NULL,    NULL,                          XE2 },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook XE3 GC*",            NULL,    NULL,                          XE3GC },
+  /* HP Pavilion N5430 */
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook XE3 GD*",            NULL,    NULL,                          XE3GC },
+  /* HP Pavilion N5415 */
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook XE3 GE*",            NULL,    NULL,                          XE3GC },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook 500 FA*",            NULL,    NULL,                          OB500 },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook 510 FB*",            NULL,    NULL,                          OB510 },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook 4150*",              NULL,    NULL,                          OB4150 },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook 900 B*",             NULL,    NULL,                          OB4150 },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook 6000 EA*",           NULL,    NULL,                          OB6000 },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook 6100 EB*",           NULL,    NULL,                          OB6100 },
+  /* HP OmniBook xe4100 */
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook xe4000*",            NULL,    NULL,                          XE4500 },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook xe4400*",            NULL,    NULL,                          XE4500 },
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook xe4500*",            NULL,    NULL,                          XE4500 },
+  /* HP OmniBook vt6200 and xt6200 */
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook 6200 EG*",           NULL,    NULL,                          XE4500 },
+  /* There are no model specific strings of some HP OmniBook XT1500 */
+  { NULL,       "HP OmniBook PC*",           "HP OmniBook*",                   NULL,    NULL,                          XE3GF },
+  /* HP Pavilion ze4125 */
+  { NULL,       "HP NoteBook PC*",           "HP NoteBook ze4000*",            NULL,    NULL,                          XE4500 },
+  /* There are no model specific strings of some HP Pavilion xt155 and some HP Pavilion ze4100 */
+  { NULL,       "HP NoteBook PC*",           "HP NoteBook PC*",                NULL,    NULL,                          XE4500 },
+  /* There are no model specific strings of some HP nx9000 */
+  { NULL,       "HP Notebook PC*",           "HP Notebook PC*",                NULL,    NULL,                          XE4500 },
+  /* HP Pavilion ZU1155 and ZU1175 */
+  { NULL,       "HP Pavilion Notebook PC*",  "HP Pavilion ZU1000 FA*",         NULL,    NULL,                          OB500 },
+  /* HP Pavilion N5290 */
+  { NULL,       "HP Pavilion Notebook PC*",  "HP Pavilion Notebook XE3 GC*",   NULL,    NULL,                          XE3GC },
+  /* HP Pavilion N5441 */
+  { NULL,       "HP Pavilion Notebook PC*",  "HP Pavilion Notebook Model GD*", NULL,    NULL,                          XE3GC },
+  /* HP Pavilion XH545 */
+  { NULL,       "HP Pavilion Notebook PC*",  "HP Pavilion Notebook Model GE*", NULL,    NULL,                          XE3GC },
+  /* HP Pavilion ZT1141 */
+  { NULL,       "HP Pavilion Notebook PC*",  "HP Pavilion Notebook ZT1000*",   NULL,    NULL,                          XE3GF },
+  /* There are no model specific strings of some HP Pavilion ZT1175 and ZT1195 notebooks */
+  { NULL,       "HP Pavilion Notebook PC*",  "HP Pavilion Notebook*",          NULL,    NULL,                          XE3GF },
+  { NULL,       "Pavilion ze4200*",          NULL,                             NULL,    "HP Pavilion ze4200 series",   XE4500 },
+  /* Compaq nx9000 */
+  { NULL,       "HP nx9000*",                NULL,                             NULL,    "HP Compaq nx9000",            XE4500 },
+  /* Compaq nx9005 */
+  { NULL,       "HP nx9005*",                NULL,                             NULL,    "HP Compaq nx9005",            XE4500 },
+  /* Compaq nx9010 */
+  { NULL,       "HP nx9010*",                NULL,                             NULL,    "HP Compaq nx9010",            XE4500 },
+  { NULL,       "Pavilion ze8500*",          NULL,                             NULL,    "HP Pavilion ze8500",          XE4500 },
+  { "TOSHIBA",  "S1000*",                    NULL,                             NULL,    "Toshiba Satellite 1000",      XE3GF },
+  { "TOSHIBA",  "S1005*",                    NULL,                             NULL,    "Toshiba Satellite 1005",      XE3GF },
+  { "TOSHIBA",  "S1110*",                    NULL,                             NULL,    "Toshiba Satellite 1110",      XE3GF },
+  { "TOSHIBA",  "S1115*",                    NULL,                             NULL,    "Toshiba Satellite 1115",      XE3GF },
+  { "TOSHIBA",  "S1900*",                    NULL,                             NULL,    "Toshiba Satellite 1900",      XE3GF },
+  { "TOSHIBA",  "S1905*",                    NULL,                             NULL,    "Toshiba Satellite 1905",      XE3GF },
+  { "TOSHIBA",  "S1950*",                    NULL,                             NULL,    "Toshiba Satellite 1950",      XE3GF },
+  { "TOSHIBA",  "S1955*",                    NULL,                             NULL,    "Toshiba Satellite 1955",      XE3GF },
+  { "TOSHIBA",  "S2430*",                    NULL,                             NULL,    "Toshiba Satellite 2430",      XE3GF },
+  { "TOSHIBA",  "S2435*",                    NULL,                             NULL,    "Toshiba Satellite 2435",      XE3GF },
+  { "TOSHIBA",  "S3000*",                    NULL,                             NULL,    "Toshiba Satellite 3000",      XE3GF },
+  { "TOSHIBA",  "S3005*",                    NULL,                             NULL,    "Toshiba Satellite 3005",      XE3GF },
+  { "TOSHIBA",  "Satellite 1000*",           NULL,                             NULL,    "Toshiba Satellite 1000",      XE3GF },
+  { "TOSHIBA",  "Satellite 1005*",           NULL,                             NULL,    "Toshiba Satellite 1005",      XE3GF },
+  { "TOSHIBA",  "Satellite 1110*",           NULL,                             NULL,    "Toshiba Satellite 1110",      XE3GF },
+  { "TOSHIBA",  "Satellite 1115*",           NULL,                             NULL,    "Toshiba Satellite 1115",      XE3GF },
+  { "TOSHIBA",  "Satellite 1900*",           NULL,                             NULL,    "Toshiba Satellite 1900",      XE3GF },
+  { "TOSHIBA",  "Satellite 1905*",           NULL,                             NULL,    "Toshiba Satellite 1905",      XE3GF },
+  { "TOSHIBA",  "Satellite 1950*",           NULL,                             NULL,    "Toshiba Satellite 1950",      XE3GF },
+  { "TOSHIBA",  "Satellite 1955*",           NULL,                             NULL,    "Toshiba Satellite 1955",      XE3GF },
+  { "TOSHIBA",  "Satellite 2430*",           NULL,                             NULL,    "Toshiba Satellite 2430",      XE3GF },
+  { "TOSHIBA",  "Satellite 2435*",           NULL,                             NULL,    "Toshiba Satellite 2435",      XE3GF },
+  { "TOSHIBA",  "Satellite 3000*",           NULL,                             NULL,    "Toshiba Satellite 3000",      XE3GF },
+  { "TOSHIBA",  "Satellite 3005*",           NULL,                             NULL,    "Toshiba Satellite 3005",      XE3GF },
+  { "TOSHIBA",  "Satellite P10*",            NULL,                             NULL,    "Toshiba Satellite P10",       TSP10 },
+  { "TOSHIBA",  "Satellite P15*",            NULL,                             NULL,    "Toshiba Satellite P15",       TSP10 },
+  { "TOSHIBA",  "Satellite P20*",            NULL,                             NULL,    "Toshiba Satellite P20",       TSP10 },
+  { "COMPAL",   NULL,                        NULL,                             "ACL00", "Compal ACL00",                XE3GF },
+  { "COMPAL",   NULL,                        NULL,                             "ACL10", "Compal ACL10",                XE3GF },
+  { "Acer",     "Aspire 1400 series*",       NULL,                             NULL,    "Acer Aspire 1400 series",     XE3GF },
+  { "Acer",     "Aspire 1350*",              NULL,                             NULL,    "Acer Aspire 1350",            XE4500 },
+  { "FUJITSU SIEMENS", "Amilo D-Series*",    NULL,                             NULL,    "Fujitsu-Siemens Amilo D series", AMILOD },
+  /* This sentinel at the end catches all unsupported models */
+  { NULL, NULL, NULL, NULL, NONE }
+};
+
+struct omnibook_tc_t {
+	char	*tc;
+	int	ectype;
+};
+
+/* HP technology codes */
+static struct omnibook_tc_t omnibook_tc[] __initdata = {
+  /* technology code		ectype */
+	{ "CI.",		OB4150 },
+	{ "CL.",		OB4150 },
+	{ "DC.",		XE2 },
+	{ "EA.",		OB6000 },
+	{ "EB.",		OB6100 },
+	{ "EG.",		XE4500 },
+	{ "FA.",		OB500 },
+	{ "FB.",		OB510 },
+	{ "GC.",		XE3GC },
+	{ "GD.",		XE3GC },
+	{ "GE.",		XE3GC },
+	{ "GF.",		XE3GF },
+	{ "IB.",		XE3GF },
+	{ "IC.",		XE3GF },
+	{ "ID.",		XE3GF },
+	{ "KA.",		XE4500 },
+	{ "KB.",		XE4500 },
+	{ "KC.",		XE4500 },
+	{ "KD.",		XE4500 },
+	{ "KE.",		XE4500 },
+	{ "KE_KG.",		XE4500 },
+	{ "KF_KH.",		XE4500 },
+	{ NULL,			NONE }
+};
+
+/*
+ * Compare the saved DMI info at "index" with a string.
+ * A '*' at the end of the string will match anything.
+ * Returns 0 for a match.
+ * 
+ * This preserves the semantics of the old omnibook_features[]
+ * table.  I don't know if its generally useful or not.
+ */
+static int __init cmp_with_glob(int index, char *str)
+{
+	int retval = 0;
+	char *glob;
+	unsigned int len;
+
+	if (str) {
+		glob = strchr(str, '*');
+		len = glob ? glob - str : strlen(str);
+		retval = strncmp(omnibook_dmi_ident[index], str, len);
+	}
+
+	return retval;
+}
+
+static int __init omnibook_ident(void)
+{
+	struct omnibook_models_t *mp;
+
+	for (mp = omnibook_models; mp->ectype != NONE; ++mp) {
+		/* Check all fields for a match */
+		if (cmp_with_glob(OMNIBOOK_SYS_VENDOR, mp->sys_vendor))
+			continue;
+		if (cmp_with_glob(OMNIBOOK_PRODUCT_NAME, mp->product_name))
+			continue;
+		if (cmp_with_glob(OMNIBOOK_PRODUCT_VERSION, mp->product_version))
+			continue;
+		if (cmp_with_glob(OMNIBOOK_BOARD_NAME, mp->board_name))
+			continue;
+
+		/* All required fields matched */
+		break;
+	}
+
+	return (mp - omnibook_models);
+}
+
+static int __init omnibook_get_tc(void)
+{	
+	struct omnibook_tc_t *tc;
+
+	for (tc = omnibook_tc; tc->ectype != NONE; ++tc) {
+		/*
+		 * Technology code appears in the first two chracters of BIOS version string
+		 * ended by a dot, but it prefixed a space character on some models and BIOS
+		 * versions.
+		 * New HP/Compaq models use more characters (eg. KF_KH.).
+		 */
+		if (strstr(omnibook_dmi_ident[OMNIBOOK_BIOS_VERSION], tc->tc))
+			break;
+	}
+
+	return (tc - omnibook_tc);
+}
+
+static int __init omnibook_init(void)
+{
+	int retval;
+	int model = 0;
+	int tc = 0;
+	char *syslog_name;
+	char *glob;
+	mode_t pmode;
+
+	omnibook_userset = user;
+
+#ifdef MODULE
+	printk(KERN_INFO "%s: module version %s.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_VERSION);
+#else
+	printk(KERN_INFO "%s: driver version %s.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_VERSION);
+#endif
+
+	/* saving DMI information */
+	if (omnibook_dmi_scan_machine() != 0)
+		return  -ENODEV;
+
+	if (ectype != NONE)
+		printk(KERN_WARNING "%s: Forced load with EC firmware type %d.\n", OMNIBOOK_MODULE_NAME, ectype);
+	else {
+		model = omnibook_ident();
+		if (omnibook_models[model].ectype != NONE) {
+			ectype = omnibook_models[model].ectype;
+			syslog_name = omnibook_models[model].syslog_name;
+			if (!syslog_name) {
+				syslog_name = omnibook_models[model].product_version;
+				glob = strchr(syslog_name, '*');
+				if (glob)
+					*glob = '\0';
+			}
+			printk(KERN_INFO "%s: %s detected.\n", OMNIBOOK_MODULE_NAME, syslog_name);
+		} else {
+			/* Without explicite informations try chechking for technology code of HP laptops */
+			tc = omnibook_get_tc();
+			if ((strncmp(omnibook_dmi_ident[OMNIBOOK_SYS_VENDOR], HP_SIGNATURE, strlen(HP_SIGNATURE)) == 0) &&
+				(omnibook_tc[tc].ectype != NONE)) {
+				ectype = omnibook_tc[tc].ectype;
+				printk(KERN_INFO "%s: HP tecnology code %s detected.\n", OMNIBOOK_MODULE_NAME, omnibook_tc[tc].tc);
+			} else {
+				printk(KERN_INFO "%s: Unknown model detected.\n", OMNIBOOK_MODULE_NAME);
+				ac = 0;
+				apmemu = 0;
+				battery = 0;
+				blank = 0;
+				display = 0;
+				dock = 0;
+				fan = 0;
+				fan_policy = 0;
+				lcd = 0;
+				onetouch = 0;
+				temperature = 0;
+				touchpad = 0;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+				key_polling = 0;
+#endif
+			}
+		}
+	}
+	omnibook_ectype = ectype;
+
+	omnibook_proc_root = proc_mkdir(OMNIBOOK_MODULE_NAME, NULL);
+	if (! omnibook_proc_root) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+
+	pmode = S_IFREG | S_IRUGO;
+	proc_version = create_proc_read_entry("version", pmode, omnibook_proc_root, omnibook_proc_version, NULL);
+	if (! proc_version) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/version.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+
+	if (dmi) {
+		pmode = S_IFREG | S_IRUGO;
+		proc_dmi = create_proc_read_entry("dmi", pmode, omnibook_proc_root, omnibook_proc_dmi, NULL);
+		if (! proc_dmi) {
+			printk(KERN_ERR "%s: Unable to create /proc/%s/dmi.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+			return -ENOENT;
+		}
+	}
+
+	if ((retval = (ac ? omnibook_ac_init() : 0)))
+		return retval;
+	ac = (retval ? 0 : 1);
+
+	if ((retval = (battery ? omnibook_battery_init() : 0)))
+		return retval;
+	battery = (retval ? 0 : 1);
+
+	/* /proc/apm emulation needs to read battery and AC adapter status */
+	if (ac && battery && apmemu) {
+		if ((retval = omnibook_apmemu_init()))
+			return retval;
+	}
+
+	if ((retval = (blank ? omnibook_console_blank_init() : 0)))
+		return retval;
+
+	if ((retval = (display ? omnibook_display_init() : 0)))
+		return retval;
+
+	if ((retval = (dock ? omnibook_dock_init() : 0)))
+		return retval;
+
+	if ((retval = (fan ? omnibook_fan_init() : 0)))
+		return retval;
+
+	if ((retval = (fan_policy ? omnibook_fan_policy_init() : 0)))
+		return retval;
+
+	if ((retval = (lcd ? omnibook_brightness_init() : 0)))
+		return retval;
+
+	if ((retval = (onetouch ? omnibook_onetouch_init() : 0)))
+		return retval;
+
+	if ((retval = (temperature ? omnibook_temperature_init() : 0)))
+		return retval;
+
+	if ((retval = (touchpad ? omnibook_touchpad_init() : 0)))
+		return retval;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	if ((retval = (key_polling ? omnibook_key_polling_init() : 0)))
+		return retval;
+#else
+	printk(KERN_WARNING "%s: module unloading does not work yet on 2.6 kernel.\n", OMNIBOOK_MODULE_NAME);
+#endif
+
+	return 0;
+}
+
+static void __exit omnibook_cleanup(void)
+{
+	omnibook_apmemu_cleanup();
+	omnibook_ac_cleanup();
+	omnibook_battery_cleanup();
+	omnibook_brightness_cleanup();
+	omnibook_console_blank_cleanup();
+	omnibook_display_cleanup();
+	omnibook_dock_cleanup();
+	omnibook_fan_cleanup();
+	omnibook_fan_policy_cleanup();
+	omnibook_onetouch_cleanup();
+	omnibook_temperature_cleanup();
+	omnibook_touchpad_cleanup();
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	omnibook_key_polling_cleanup();
+#endif
+	if (proc_version)
+		remove_proc_entry("version", omnibook_proc_root);
+	if (proc_dmi)
+		remove_proc_entry("dmi", omnibook_proc_root);
+	if (omnibook_proc_root)
+		remove_proc_entry("omnibook", NULL);
+	printk(KERN_INFO "%s: module is unloaded.\n", OMNIBOOK_MODULE_NAME);
+}
+
+module_init(omnibook_init);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+module_exit(omnibook_cleanup);
+#endif
+
+EXPORT_SYMBOL(omnibook_ectype);
+EXPORT_SYMBOL(omnibook_proc_root);
+
+MODULE_AUTHOR("Soós Péter <sp@osb.hu>");
+MODULE_DESCRIPTION("Kernel interface for HP OmniBook, HP Pavilion, Toshiba Satellite, Acer Aspire and Compal ACL00 laptops");
+MODULE_LICENSE("GPL");
+MODULE_PARM(ectype, "i");
+MODULE_PARM(ac, "i");
+MODULE_PARM(apmemu, "i");
+MODULE_PARM(battery, "i");
+MODULE_PARM(blank, "i");
+MODULE_PARM(display, "i");
+MODULE_PARM(dock, "i");
+MODULE_PARM(dmi, "i");
+MODULE_PARM(fan, "i");
+MODULE_PARM(fan_policy, "i");
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+MODULE_PARM(key_polling, "i");
+#endif
+MODULE_PARM(lcd, "i");
+MODULE_PARM(onetouch, "i");
+MODULE_PARM(temperature, "i");
+MODULE_PARM(touchpad, "i");
+MODULE_PARM(user, "i");
+MODULE_PARM_DESC(ectype, "Type of embedded controller firmware");
+MODULE_PARM_DESC(ac, "Use 0 to disable, 1 to enable AC adapter status monitoring");
+MODULE_PARM_DESC(apmemu, "Use 0 to disable, 1 to enable /proc/apm emulation");
+MODULE_PARM_DESC(battery, "Use 0 to disable, 1 to enable battery status monitoring");
+MODULE_PARM_DESC(blank, "Use 0 to disable, 1 to enable lcd console blanking");
+MODULE_PARM_DESC(display, "Use 0 to disable, 1 to enable display status handling");
+MODULE_PARM_DESC(dock, "Use 0 to disable, 1 to enable docking station support");
+MODULE_PARM_DESC(dmi, "Use 0 to disable, 1 to enable /proc/omnibook/dmi");
+MODULE_PARM_DESC(fan, "Use 0 to disable, 1 to enable fan status monitor and control");
+MODULE_PARM_DESC(fan_policy, "Use 0 to disable, 1 to enable fan control policy support");
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+MODULE_PARM_DESC(key_polling, "Use 0 to disable, 1 to enable to scancode emulation for volume keys");
+#endif
+MODULE_PARM_DESC(lcd, "Use 0 to disable, 1 to enable to LCD brightness support");
+MODULE_PARM_DESC(onetouch, "Use 0 to disable, 1 to enable onetouch handling");
+MODULE_PARM_DESC(temperature, "Use 0 to disable, 1 to enable thermal status and policy support");
+MODULE_PARM_DESC(touchpad, "Use 0 to disable, 1 to enable touchpad handling");
+MODULE_PARM_DESC(user, "Use 0 to disable, 1 to enable users to set parameters");
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/init.h linux-2.6.10-rc1/drivers/char/omnibook/init.h
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/init.h	2004-01-14 20:16:33.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * init.h -- initialization and cleanup functions
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+extern int __init omnibook_ac_init(void);
+extern void __exit omnibook_ac_cleanup(void);
+extern int __init omnibook_apmemu_init(void);
+extern void __exit omnibook_apmemu_cleanup(void);
+extern int __init omnibook_battery_init(void);
+extern void __exit omnibook_battery_cleanup(void);
+extern int __init omnibook_console_blank_init(void);
+extern void __exit omnibook_console_blank_cleanup(void);
+extern int __init omnibook_display_init(void);
+extern void __exit omnibook_display_cleanup(void);
+extern int __init omnibook_dock_init(void);
+extern void __exit omnibook_dock_cleanup(void);
+extern int __init omnibook_fan_init(void);
+extern void __exit omnibook_fan_cleanup(void);
+extern int __init omnibook_fan_policy_init(void);
+extern void __exit omnibook_fan_policy_cleanup(void);
+extern int __init omnibook_onetouch_init(void);
+extern void __exit omnibook_onetouch_cleanup(void);
+extern int __init omnibook_key_polling_init(void);
+extern void __exit omnibook_key_polling_cleanup(void);
+extern int __init omnibook_touchpad_init(void);
+extern void __exit omnibook_touchpad_cleanup(void);
+extern int __init omnibook_temperature_init(void);
+extern void __exit omnibook_temperature_cleanup(void);
+extern int __init omnibook_brightness_init(void);
+extern void __exit omnibook_brightness_cleanup(void);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/lcd.c linux-2.6.10-rc1/drivers/char/omnibook/lcd.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/lcd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/lcd.c	2004-05-02 06:00:55.000000000 +0200
@@ -0,0 +1,196 @@
+/*
+ * lcd.c -- LCD brightness and on/off
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Maciek Górniak <mago@acn.waw.pl>, 2002
+ * Modified by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_brightness;
+
+int omnibook_get_lcd_brightness(void)
+{
+	int retval = 0;
+	u8 brgt;
+#ifdef CONFIG_VT
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		if ((retval = omnibook_ec_read(XE3GF_BRTS, &brgt)))
+			return retval;
+		retval = brgt &= XE3GF_BRTS_MASK;
+		break;
+	case XE3GC:
+		if ((retval = omnibook_ec_read(XE3GC_BTVL, &brgt)))
+			return retval;
+		retval = brgt &= XE3GC_BTVL_MASK;
+		break;
+	case AMILOD:
+		if ((retval = omnibook_ec_read(AMILOD_CBRG, &brgt)))
+			return retval;
+		retval = brgt &= AMILOD_CBRG_MASK;
+		break;
+	default:
+		printk(KERN_INFO "%s: LCD brightness handling is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+
+#endif
+	return retval;
+}
+
+int omnibook_set_lcd_brightness(u8 brgt)
+{
+	int retval = 0;
+#ifdef CONFIG_VT
+	
+	brgt = (brgt > 10) ? 10 : brgt;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		if ((retval = omnibook_ec_write(XE3GF_BRTS, brgt)))
+			return retval;
+		break;
+	case XE3GC:
+		if ((retval = omnibook_ec_write(XE3GC_BTVL, brgt)))
+			return retval;
+		break;
+	case AMILOD:
+		if ((retval = omnibook_ec_write(AMILOD_CBRG, brgt)))
+			return retval;
+		break;
+	default:
+		printk(KERN_INFO "%s: LCD brightness handling is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV;
+	}
+#endif
+	return retval;	
+}
+
+static int omnibook_proc_brightness_status(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+	int brgt;
+
+	brgt = omnibook_get_lcd_brightness();
+	if (brgt < 0)
+		return brgt;
+
+	b += sprintf(b, "LCD brightness: %2d\n", brgt);
+	
+	return omnibook_proc_len(buffer, start, off, count, eof, b);;
+}
+
+static int omnibook_proc_brightness_set(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	char value[4+1];
+	int brgt = 0;
+	int i;
+	unsigned int len;
+	
+	len = sizeof(value) - 1;
+	if (count < len)
+		len = count;
+	if (copy_from_user(value, buffer, len))
+		return -EFAULT;
+	value[len] = 0;
+
+	if (strcmp(value, "off\n") == 0)
+		omnibook_lcd_blank(1);
+	else if (strcmp(value, "on\n") == 0)
+		omnibook_lcd_blank(0);
+	else
+	{
+		for (i = 0; (value[i] != '\0') && (value[i] != '\n'); i++)
+			if ((value[i] >= '0') && (value[i] <= '9'))
+				brgt = brgt * 10 + value[i] - '0';
+			else
+				return -EINVAL;
+
+		if ((brgt >= 0) && (brgt <= 10))
+			omnibook_set_lcd_brightness(brgt);
+		else
+			return -EINVAL;
+	}
+
+	return count;
+}
+
+int __init omnibook_brightness_init(void)
+{
+#ifdef CONFIG_VT
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case AMILOD:
+	case TSP10:
+		pmode = S_IFREG | S_IWUSR | S_IRUGO;
+		if (omnibook_userset)
+			pmode = pmode | S_IWUGO;
+		proc_brightness = create_proc_entry("lcd", pmode, omnibook_proc_root);
+		break;
+	default:
+		printk(KERN_INFO "%s: LCD brightness handling is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	if (! proc_brightness) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/lcd.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	} else {
+		proc_brightness->read_proc = omnibook_proc_brightness_status;
+		proc_brightness->write_proc = omnibook_proc_brightness_set;
+	}
+	printk(KERN_INFO "%s: LCD brightness handling is enabled.\n", OMNIBOOK_MODULE_NAME);
+	return 0;
+#else
+	printk(KERN_ERR "%s: Virtual terminal support is not compiled into your kernel.\n", OMNIBOOK_MODULE_NAME);
+	return -ENODEV;
+#endif
+}
+
+void __exit omnibook_brightness_cleanup(void)
+{
+#ifdef CONFIG_VT
+	if (proc_brightness)
+		remove_proc_entry("lcd", omnibook_proc_root);
+#endif
+}
+
+EXPORT_SYMBOL(omnibook_get_lcd_brightness);
+EXPORT_SYMBOL(omnibook_set_lcd_brightness);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/Makefile linux-2.6.10-rc1/drivers/char/omnibook/Makefile
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/Makefile	2004-10-29 00:29:53.477869352 +0200
@@ -0,0 +1,5 @@
+obj-$(CONFIG_OMNIBOOK)		+= omnibook.o
+
+omnibook-objs 	:=	ac.o apmemu.o battery.o blank.o dmi.o display.o \
+			dock.o ec.o fan.o fan_policy.o init.o lcd.o onetouch.o \
+			temperature.o touchpad.o util.o
diff -uNr linux-2.6.10-rc1.orig/include/linux/omnibook.h linux-2.6.10-rc1/include/linux/omnibook.h
--- linux-2.6.10-rc1.orig/include/linux/omnibook.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/include/linux/omnibook.h	2004-09-16 09:28:52.000000000 +0200
@@ -0,0 +1,133 @@
+/*
+ * omnibook.h -- High level data structures and functions of omnibook
+ *               support code
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+/*
+ * Module informations
+ */
+
+#define OMNIBOOK_MODULE_NAME		"omnibook"
+#define OMNIBOOK_MODULE_VERSION		"2004-09-16"
+
+/*
+ * EC types
+ */
+
+extern int omnibook_ectype;
+enum {
+	NONE,
+	XE3GF,	/* HP OmniBook XE3 GF, most Toshiba Satellites and more*/
+	XE3GC,  /* HP OmniBook XE3 GC, GD, GE and compatible */
+	OB500,	/* HP OmniBook 500 and compatible */
+	OB510,	/* HP OmniBook 510 */
+	OB6000,	/* HP OmniBook 6000 */
+	OB6100, /* HP OmniBook 6100 */
+	XE4500,	/* HP OmniBook xe4500 and compatible */
+	OB4150,	/* HP OmniBook 4150 */
+	XE2,	/* HP OmniBook XE2 */
+	AMILOD,	/* Fujitsu Amilo D */
+	TSP10	/* Toshiba Sattelite P10 */
+};
+
+extern struct __init proc_dir_entry *omnibook_proc_root;
+extern int omnibook_userset;
+
+extern int omnibook_get_ac(void);
+
+struct omnibook_battery_info {
+	u8 type;	/* 1 - Li-Ion, 2 NiMH */
+	u16 sn;		/* Serial number */
+	u16 dv;		/* Design Voltage */
+	u16 dc;		/* Design Capacity */
+};
+struct omnibook_battery_status {
+	u16 pv;		/* Present Voltage */
+	u16 rc;		/* Remaining Capacity */
+	u16 lc;		/* Last Full Capacity */
+	u8 gauge;	/* Gauge in % */
+	u8 status;	/* 0 - unknown, 1 - charged, 2 - discharging, 3 - charging, 4 - critical) */
+};
+enum {
+	OMNIBOOK_BATTSTAT_UNKNOWN,
+	OMNIBOOK_BATTSTAT_CHARGED,
+	OMNIBOOK_BATTSTAT_DISCHARGING,
+	OMNIBOOK_BATTSTAT_CHARGING,
+	OMNIBOOK_BATTSTAT_CRITICAL
+};
+
+extern int omnibook_battery_present(int num);
+extern int omnibook_get_battery_info(int num, struct omnibook_battery_info *battinfo);
+extern int omnibook_get_battery_status(int num, struct omnibook_battery_status *battstat);
+
+extern int omnibook_console_blank_enabled;
+extern int omnibook_lcd_blank(int blank);
+extern int omnibook_console_blank_enable(void);
+extern int omnibook_console_blank_disable(void);
+
+extern int omnibook_get_display(void);
+
+extern int omnibook_get_dock(void);
+
+extern int omnibook_get_fan(void);
+extern int omnibook_fan_on(void);
+extern int omnibook_fan_off(void);
+
+/*
+ * Default temperature limits.
+ * Danger! You may overheat your CPU!
+ * Do not change these values unless you exactly know what you do.
+ */
+
+#define OMNIBOOK_FAN_LEVELS			7
+#define OMNIBOOK_FAN_MIN			25	/* Minimal value of fan off temperature */
+#define OMNIBOOK_FOT_MAX			75	/* Maximal value of fan off temperature */
+#define OMNIBOOK_FAN_MAX			95	/* Maximal value of fan on temperature */
+#define OMNIBOOK_FOT_DEFAULT			60	/* Default value of fan off temperature */
+#define OMNIBOOK_FAN1_DEFAULT			75	/* Default value of fan on temperature */
+#define OMNIBOOK_FAN2_DEFAULT			85	/* Default value of fan level 2 temperature */
+#define OMNIBOOK_FAN3_DEFAULT			90	/* Default value of fan level 3 temperature */
+#define OMNIBOOK_FAN4_DEFAULT			95	/* Default value of fan level 4 temperature */
+#define OMNIBOOK_FAN5_DEFAULT			95	/* Default value of fan level 5 temperature */
+#define OMNIBOOK_FAN6_DEFAULT			95	/* Default value of fan level 6 temperature */
+#define OMNIBOOK_FAN7_DEFAULT			95	/* Default value of fan level 7 temperature */
+#define OMNIBOOK_FAN_POLICY_STRING		32	/* Maximal length of temperature policy control string */
+
+extern u8 omnibook_fan_policy[OMNIBOOK_FAN_LEVELS];
+
+extern int omnibook_get_fan_policy(void);
+extern int omnibook_set_fan_policy(void);
+extern int omnibook_set_fan_policy_defaults(void);
+
+extern int omnibook_get_lcd_brightness(void);
+extern int omnibook_set_lcd_brightness(u8 brgt);
+
+extern int omnibook_onetouch_enabled;
+extern int omnibook_onetouch_enable(void);
+extern int omnibook_onetouch_disable(void);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+extern int omnibook_key_polling_enabled;
+extern int omnibook_key_polling_enable(void);
+extern int omnibook_key_polling_disable(void);
+#endif
+
+extern int omnibook_get_cpu_temp(void);
+
+extern int omnibook_touchpad_enabled;
+extern int omnibook_touchpad_enable(void);
+extern int omnibook_touchpad_disable(void);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/onetouch.c linux-2.6.10-rc1/drivers/char/omnibook/onetouch.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/onetouch.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/onetouch.c	2004-05-02 05:56:02.000000000 +0200
@@ -0,0 +1,245 @@
+/*
+ * onetouch.c -- code to handling OneTouch buttons
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct pm_dev *pm_onetouch;
+static pm_callback pm_onetouch_callback = NULL;
+
+static struct proc_dir_entry *proc_onetouch;
+
+/* There is no information about reading OneTouch status */
+int omnibook_onetouch_enabled = 0;
+
+static int omnibook_onetouch_on(void)
+{
+	if (omnibook_kbc_command(OMNIBOOK_KBC_CONTROL_CMD, OMNIBOOK_KBC_CMD_ONETOUCH_ENABLE)) {
+		printk(KERN_ERR "%s: failed OneTouch enable command.\n", OMNIBOOK_MODULE_NAME);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int omnibook_onetouch_off(void)
+{
+	if (omnibook_kbc_command(OMNIBOOK_KBC_CONTROL_CMD, OMNIBOOK_KBC_CMD_ONETOUCH_DISABLE)) {
+		printk(KERN_ERR "%s: failed OneTouch disable command.\n", OMNIBOOK_MODULE_NAME);
+		return -EIO;
+	}
+	return 0;
+}
+
+/*
+ * Power management handler: on resume it reenables the OneTouch buttons it they were enabled previously
+ */
+
+static int pm_onetouch_handler(struct pm_dev *dev, pm_request_t rqst, void *data)
+{
+	switch (rqst) {
+	case PM_RESUME:
+		if (omnibook_onetouch_enabled)
+			return omnibook_onetouch_on();
+		break;
+	case PM_SUSPEND:
+		if (omnibook_onetouch_enabled)
+			return omnibook_onetouch_off();
+		break;
+	}
+	return 0;
+}
+
+static int omnibook_onetouch_register(void)
+{
+		pm_onetouch_callback = pm_onetouch_handler;
+		pm_onetouch = pm_register(PM_SYS_DEV, PM_SYS_KBC, pm_onetouch_callback);
+		return (pm_onetouch ? 0 : -EFAULT);
+}
+
+static void omnibook_onetouch_unregister(void)
+{
+		pm_unregister(pm_onetouch);
+		pm_onetouch_callback = NULL;
+}
+
+int omnibook_onetouch_enable(void)
+{
+#ifdef CONFIG_VT
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+	case AMILOD:
+	case TSP10:
+		if (! omnibook_onetouch_enabled) {
+			if (omnibook_onetouch_on())
+				return -EIO;
+			omnibook_onetouch_enabled = 1;
+			printk(KERN_INFO "%s: OneTouch buttons (if any) are enabled.\n", OMNIBOOK_MODULE_NAME);
+		}
+		break;
+	default:
+		omnibook_onetouch_enabled = 0;
+		return -ENODEV;
+	}
+#endif
+	return 0;
+}
+
+int omnibook_onetouch_disable(void)
+{
+#ifdef CONFIG_VT
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+	case AMILOD:
+	case TSP10:
+		if (omnibook_onetouch_enabled) {
+			if (omnibook_onetouch_off()) {
+				return -EIO;
+			}
+			omnibook_onetouch_enabled = 0;
+			printk(KERN_INFO "%s: OneTouch buttons (if any) are disabled.\n", OMNIBOOK_MODULE_NAME);
+		}
+		break;
+	default:
+		omnibook_onetouch_enabled = 0;
+		return -ENODEV;
+	}
+#endif
+	return 0;
+}
+
+static int omnibook_onetouch_status(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+
+	b += sprintf(b, "OneTouch buttons are %s\n", (omnibook_onetouch_enabled) ? "enabled" : "disabled");
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+static int omnibook_onetouch_set(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	char status[1] = {'\0'};
+
+	if (copy_from_user(status, buffer, 1))
+		return -EFAULT;
+	switch (*status) {
+	case '0':
+		omnibook_onetouch_disable();
+		break;
+	case '1':
+		omnibook_onetouch_enable();
+		break;
+	default:
+		count = -EINVAL;
+	}
+	return count;
+}
+
+int __init omnibook_onetouch_init(void)
+{
+#ifdef CONFIG_VT
+	int retval;
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+	case AMILOD:
+	case TSP10:
+		pmode = S_IFREG | S_IWUSR | S_IRUGO;
+		if (omnibook_userset)
+			pmode = pmode | S_IWUGO;
+		proc_onetouch = create_proc_entry("onetouch", pmode, omnibook_proc_root);
+		break;
+	default:
+		printk(KERN_INFO "%s: OneTouch button handling is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		omnibook_onetouch_enabled = 0;
+		return 0;
+	}
+	if (proc_onetouch) {
+		proc_onetouch->read_proc = omnibook_onetouch_status;
+		proc_onetouch->write_proc = omnibook_onetouch_set;
+	} else {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/onetouch.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	if ((retval = omnibook_onetouch_register()))
+		return retval;
+	if ((retval = omnibook_onetouch_enable()))
+		return retval;
+
+	return 0;
+#else
+	printk(KERN_ERR "%s: Virtual terminal support is not compiled into your kernel.\n", OMNIBOOK_MODULE_NAME);
+//	return -ENODEV;
+	return 0;
+#endif
+}
+
+void __exit omnibook_onetouch_cleanup(void)
+{
+#ifdef CONFIG_VT
+	if (proc_onetouch)
+		remove_proc_entry("onetouch", omnibook_proc_root);
+	if (pm_onetouch)
+		omnibook_onetouch_unregister();
+	
+	omnibook_onetouch_disable();
+#endif
+}
+
+EXPORT_SYMBOL(omnibook_onetouch_enabled);
+EXPORT_SYMBOL(omnibook_onetouch_enable);
+EXPORT_SYMBOL(omnibook_onetouch_disable);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/README linux-2.6.10-rc1/drivers/char/omnibook/README
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/README	2004-09-16 09:28:29.000000000 +0200
@@ -0,0 +1,526 @@
+Kernel Support for HP OmniBooks, Pavilions, Toshiba Satellites,
+                   Acer Aspire and Compal ACL00
+===============================================================
+
+
+This package intended to provide Linux kernel support for HP OmniBook
+and Pavilion machines. The state of this code is experimental but it
+wants to be a framework to extend the Linux support for HP OmniBook
+and Pavilion, Toshiba Satellite, Acer Aspire and Compal ACL00 laptops
+manufactured by Compal Electronics, Inc as ODM.
+
+There is a similar project for Toshiba Satellite laptops wich supports
+some HP OmniBooks too at ftp://ftp.poupinou.org/tosh_3000/.
+
+How does it work?
+-----------------
+   Some features of HP OmniBooks can be controlled via the keyboard control
+   and data registers. Commands and parameters were discovered by Pavel
+   Mihaylov.
+
+   Some other features available via /proc/omnibook/* provided by the
+   Embedded Controller or other I/O registers of your laptop. Informations
+   comes from DSDT ACPI table of HP OmniBook XE3 GF dissassembled by Ducrot
+   Bruno and others or discovered by me.
+
+   Note: You do not have to enable APM or ACPI to use this driver.
+
+   All supported models seems to have same keyboard and embedded controller:
+   National Semiconductor PC87570 Keyboard and ACPI Embedded Controller or
+   compatible, but with different types of firmware.
+   See http://www.national.com/pf/PC/PC87570.html for more info.
+
+   It seems there is more types of firmware (only the tested models are
+   listed):
+    1. HP OmniBook XE3 GF
+       HP OmniBook XT1000
+       HP Pavilion ZT1141
+       HP Pavilion ZT1175
+       HP Pavilion ZT1195
+       Toshiba Satellite 1000
+       Toshiba Satellite 1005
+       Toshiba Satellite 1110
+       Toshiba Satellite 1115
+       Toshiba Satellite 1900
+       Toshiba Satellite 1905
+       Toshiba Satellite 1950
+       Toshiba Satellite 1955
+       Toshiba Satellite 3000
+       Toshiba Satellite 3005
+       Compal ACL00
+       Compal ACL10
+       Acer Aspire 1406 LC
+    2. HP OmniBook XE3 GC
+       HP OmniBook XE3 GD
+       HP OmniBook XE3 GE
+       HP Pavilion N5290
+       HP Pavilion N5415
+       HP Pavilion N5430
+       HP Pavilion N5441
+       HP Pavilion XH545
+    3. HP OmniBook 500
+       HP Pavilion ZU1155
+       HP Pavilion ZU1175
+    4. HP OmniBook 510
+    5. HP OmniBook 6000
+    6. HP OmniBook 6100
+    7. HP OmniBook xe4100
+       HP OmniBook xe4400
+       HP OmniBook xe4500
+       HP OmniBook vt6200
+       HP OmniBook xt6200
+       HP Pavilion xt155
+       HP Pavilion ze4125
+       HP/Compaq nx9000
+       HP/Compaq nx9010
+       Acer Aspire 1350
+    8. HP OmniBook 4150
+       HP OmniBook 900B
+    9. HP OmniBook XE2
+   10. Fujitsu-Siemens Amilo D (CY23)
+
+   If your model is not listed above you may try to load the module. If it
+   have same DMI identification strigs as a supported machine it may works
+   out of the box. Please report it.
+   Only the /proc/omnibook/dmi and /proc/omnibook/version are working when
+   you load the module on an unsupported machine.
+   In this case you may load the module with ectype parameter to force using
+   a certain EC firmware type or see how became you machine supported at the
+   end of this documet.
+
+What is working?
+----------------
+ 1. Enabling OneTouch buttons. See README-OneTouch for details.
+    You may enable or disable it via /proc/omnibook/onetouch.
+    There is a power management handler for reenabling the buttons at resume
+    if they were enabled previously.
+    On some (XE3 GC style) models the volume buttons do not generate
+    scancodes, so emulation is necessary.
+
+ 2. Console (LCD display) blanking if APM does not do it (e.g. using ACPI).
+    It turns off the backlight of LCD display for more intensive power
+    saving when your console is idle.
+    You may enable or disable it via /proc/omnibook/blank.
+
+ 3. Battery status monitoring via /proc/omnibook/battery.
+
+ 4. Fan and fan policy support via /proc/omnibook/fan and
+    /proc/omnibook/fan_policy.
+
+ 5. You may enable or disable touchpad via /proc/omnibook/touchpad.
+    There is a power management handler for redisabling the touchpad
+    at resume if it was disabled previously.
+
+ 6. Emulate /proc/apm battery status monitoring. On my HP OmniBook XE3 GF the
+    APM subsystem unable to monitor the battery but there are many status
+    monitoring application using /proc/apm to get info. So I disable APM and
+    use this module and I'm happy :).
+    Note: this is working only if you have AC adapter and battery status
+    monitoring enabled (see ac and battery module parameters).
+
+ 7. AC Adapter status monitoring via /proc/omnibook/ac.
+
+ 8. Display status monitoring /proc/omnibook/display.
+
+ 9. LCD brightness setting and monitoring.
+
+10. Docking station/port replicator support.
+
+How to use?
+-----------
+ 1. The OneTouch buttons are enabled by default by this module.
+    To disable it use the command:
+
+	echo 0 > /proc/omnibook/onetouch
+
+    The command
+
+	echo 1 > /proc/omnibook/onetouch
+
+    enables OneTouch buttons.
+
+    On some XE3 GC style models there is scancode emulation for volume
+    buttons on 2.4 series kernels, but it is disabled by default because
+    of not all machines need it. For example volume buttons of
+    HP Pavilion XH545 generate scancodes, so enable this feature if you
+    really need it.
+
+    To enable it use the command:
+
+	echo 1 > /proc/omnibook/key_polling
+
+    The command
+
+	echo 0 > /proc/omnibook/key_polling
+
+    disables the polling of the volume buttons and emulating scancodes for
+    them.
+
+    Note: Polling function may cause slow down and packet loss on serial
+          interfaces in certain configurations. If you experience this you
+          may disable polling while you use the serial interface.
+          Yes, polling is very expensive way and spin_locks during every
+          poll is more expensive, but there is no other solution for volume
+          key support without ACPI. If you use ACPI you may use acpid to
+          support volume keys, because of pressing these keys causes ACPI
+          events appear in /proc/acpi/events.
+
+ 2. Console (LCD display) blanking is enabled by this module on machines that
+    support it. It only enabled if another blanking solution
+    (e.g. CONFIG_APM_DISPLAY_BLANK) is not used.
+    To disable this behavior use command:
+
+	echo 0 > /proc/omnibook/blank
+
+    To enable this behavior use command:
+
+	echo 1 > /proc/omnibook/blank
+
+ 3. To see the battery status use
+
+	cat /proc/omnibook/battery
+
+    command. It produce similar output to that you can see below.
+
+	Battery:                      0
+	Type:                    Li-Ion
+	Serial Number:            20722
+	Present Voltage:          12668 mV
+	Design Voltage:           11100 mV
+	Remaining Capacity:        4859 mAh
+	Last Full Capacity:        4933 mAh
+	Design Capacity:           5400 mAh
+	Gauge:                       98 %
+	Status:                charging
+
+    On some models (e.g. HP OmniBook XE3 GF) /proc/apm does not work, even
+    apm is enabled, but via this file you can monitor your battery
+    independently from apm code.
+
+    Current ACPI driver reports some bad value about battery at least on my
+    machine:
+
+	$cat /proc/acpi/battery/BAT1/info
+	present:                 yes
+	design capacity:         5400 mAh
+	last full capacity:      5400 mAh
+	battery technology:      rechargeable
+	design voltage:          8191 mV
+	design capacity warning: 540 mAh
+	design capacity low:     162 mAh
+	capacity granularity 1:  264 mAh
+	capacity granularity 2:  3780 mAh
+	model number:            LIP9071
+	serial number:
+	battery type:            LiON
+	OEM info:                HP
+
+	This is because the methods used for batteries in the DSDT do
+	not give correct informations. If you want to fix it you may
+	have to change methods in the DSDT.
+	See http://www.intel.com/technology/iapc/acpi/bios_override.htm
+	for details.
+
+ 4. The /proc/omnibook/fan file provides information about fan status:
+
+	$ cat /proc/omnibook/fan
+	Fan is off
+
+    or
+
+	$ cat /proc/omnibook/fan
+	Fan is on
+
+    On certain machines you may turn on the fan by
+
+	echo 1 > /proc/omnibook/fan
+
+    command and turn off by issuing
+
+	echo 0 > /proc/omnibook/fan
+
+    command.
+
+    Note: On XE3 GF style machines direct fan control works only if the CPU
+          temperature is between fan on and fan off temperature (see below).
+
+    The /proc/omnibook/fan_policy file provides information about fan control 
+    policy of your machine. Currently it is available on XE3 GF style models
+    because ot these machines have easily available hardware fan policy
+    support. On other machines fan policy can be available via ACPI. To see
+    the fan policy settings see the file /proc/omnibook/fan_policy:
+
+	$ cat /proc/omnibook/fan_policy
+	Fan off temperature:        60 C
+	Fan on temperature:         75 C
+	Fan level 2 temperature:    85 C
+	Fan level 3 temperature:    90 C
+	Fan level 4 temperature:    95 C
+	Fan level 5 temperature:    95 C
+	Fan level 6 temperature:    95 C
+	Fan level 7 temperature:    95 C
+	Minimal temperature to set: 25 C
+	Maximal temperature to set: 95 C
+
+    The important values:
+
+    Fan off temperature:        If fan is cooling the CPU and reaches this
+                                temperature it will be switched off.
+    Fan on temperature:         If fan is off and the CPU temperature
+                                reaches this value the fan turns on.
+    Fan level n temperature:    Fan will be run at level n when CPU
+                                temperature reaches this value. These are
+                                informational values only expect the 7th
+                                level. When CPU temperature reaches the 7th
+                                value, the laptop (at least mine) turns off
+                                so use it carefully.
+
+    To set the fan policy write the proper values into the
+    /proc/omnibook/fan_policy file. Each value must be greater than or
+    equal to the prvious one. You do not have to write all values.
+    For example you may set fan off temperature to 60 C, fan on temperature
+    to 70 C and fan level 2 temperature to 80 C by
+
+	echo 60 70 80 > /proc/omnibook/fan_policy
+
+    command.
+    A zero value (echo 0 > /proc/omnibook/fan_policy) sets the default
+    values (60 75 85 90 95 95 95 95) of omnibook module.
+
+    Note: These default values are not the hardware defaults. You may get
+          hardware defaults after resetting your machine (removing both
+          AC power and battery).
+
+    Note: If you prefer the direct fan control on XE3 GF style machines
+          set the fan off temperature low and fan on temperature high and
+          use /proc/omnibook/fan to control the fan directly.
+          Warning: You may overheat your CPU.
+
+ 5. The touchpad is enabled by default by the BIOS.
+    To disable it use the command:
+
+	echo 0 > /proc/omnibook/touchpad
+
+    The command
+
+	echo 1 > /proc/omnibook/touchpad
+
+    enables the touchpad.
+
+ 6. The /proc/apm emulation is disabled by default on all machines. You have
+    to enable it explicit way by module parameter apmemu. To enable it use:
+
+	insmod omnibook apmemu=1
+
+    You can enable it by /etc/modules.conf with the following entry:
+
+	options omnibook apmemu=1
+
+    If your kernel have APM support, but the /proc/apm reports buggy values,
+    you may boot your kernel without apm support, and try to load omnibook
+    module with APM emulation.
+
+    Note: This works only if battery and AC adapter monitoring is supported
+          on you machine.
+
+ 7. To see the AC adapter status use
+
+	cat /proc/omnibook/ac
+
+    command. It produce similar output to that you can see below.
+
+	$ cat /proc/omnibook/ac
+	AC on-line
+
+    Or if you are on battery power:
+
+	$ cat /proc/omnibook/ac
+	AC off-line
+
+ 8. To see the display status use
+
+	cat /proc/omnibook/display
+
+    command. It produce similar output to that you can see below.
+
+	$ cat /proc/omnibook/display
+	External display is not present
+
+    Or if you have external monitor installed:
+
+	$ cat /proc/omnibook/display
+	External display is present
+
+ 9. To see the LCD brightness use
+
+	cat /proc/omnibook/lcd
+
+    command. It produce similar output to that you can see below.
+
+	$ cat /proc/omnibook/lcd
+	LCD brightness: 7
+
+    To set it use similar command to that you can see below.
+
+	echo 10 > /proc/omnibook/lcd
+
+    The value of LCD brightness must be betwenn 0 and 10.
+
+    Note: Setting the LCD brightness on HP OmniBook XE3 GF via
+          /proc/omnibook/lcd is working if you press one of the
+          brightness control keys once after writing the value
+          into /proc/omnibook/lcd. I'll try to fix it, but I have
+          no idea about reason yet.
+
+    To turn off the LCD backlight use
+
+	echo off > /proc/omnibook/lcd
+
+    To turn it back on use
+
+	echo on > /proc/omnibook/lcd
+
+    This is useful if you have an X server, such as the ATI Radeon,
+    that does not know how to turn off the LCD backlight.  Use a
+    long-running perl script which monitors xscreensaver activity
+    such as the one below:
+
+	open(XS,"/usr/X11R6/bin/xscreensaver-command -watch|") or die;
+	while(<XS>) {
+	   if(/^BLANK/i) {
+	      system("echo off > /proc/omnibook/lcd");
+	   } elsif(/^UNBLANK/i) {
+	      system("echo on > /proc/omnibook/lcd");
+	   }
+	}
+
+	Note: You have to enable users to set values in /proc/omnibook
+              (See the user parameter below).
+
+10. To check that your laptop is docked in a docking station or port
+    replicator use
+
+	cat /proc/omnibook/dock
+
+    command. It produce similar output to that you can see below.
+
+	$ cat /proc/omnibook/dock
+	Laptop is undocked
+
+    or
+
+	$ cat /proc/omnibook/dock
+	Laptop is docked
+
+    Note: docking station support is disabled by default on all machines.
+    You have to enable it explicit way by module parameter dock. To enable
+    it use:
+
+        insmod omnibook dock=1
+
+    You can enable it by /etc/modules.conf with the following entry:
+
+	options omnibook dock=1
+
+You may enable features above via the proper module parameters. See the 
+output of
+
+	modinfo omnibook
+
+command.
+
+Usually you have to be root to change anything via files in /proc/omnibook.
+If you want to do it as ordinary user, and you trust the other (e.g.
+networked) users or you are the only user of the laptop you may load the
+module with the parameter user to enable non-root accounts to set omnibook
+paremeters as follows:
+
+	insmod omnibook user=1
+
+You can enable users to set parameters by /etc/modules.conf with the
+following entry:
+
+	options omnibook user=1
+
+Graphical frontends
+-------------------
+There are at least two graphical frontends for omnibook kernel module:
+
+1. wmtemp from Ducrot Bruno <ducrot@poupinou.org> is a WindowMaker dockapp
+   to monitor the CPU temperature and control the fan. It is available from
+   http://sf.net/projects/omnibook.
+2. komnibook from Guilherme Fortunato <guilherme@linksat.com.br> is a KDE
+   frontend that would stay in the tray and display/set status information
+   of the laptop. It is available from http://sf.net/projects/omnibook.
+
+How can your laptop be supported?
+---------------------------------
+If your model is unsupported and you want it to be supported I need four
+things:
+
+1. Test your machine with Pavel's omke.pl and report the result. You
+   should include that a feature works or not and details if any
+   (eg. OneTouch keycodes in hex as appears in syslog after enabling
+    them by omke.pl etc.).
+
+2. Force the module to load with an embedded controller firmware type
+   detailed above. For example if you want to test that your machine
+   is an XE3GF style model, use the following command:
+
+	insmod omnibook ectype=1
+
+   then test the features are working properly, and send me the result.
+
+   Warning!!! Forced load on an unsupported machine may cause
+   unpredictable result. You have been warned...
+
+3. Send me DMI strings of your machine (/proc/omnibook/dmi after
+   loading omnibook module on any machine).
+
+4. If possible send me the DSDT of your machine. If your kernel is 
+   configured for ACPI you can found it at /proc/acpi/dsdt. Use the
+   following command to get the DSDT AML file.
+
+	cat /proc/acpi/dsdt > my_model_name.aml
+
+   If your kernel does not support ACPI you can get DSDT by pmtools
+   can be found on Intel's developer site at
+   http://www.intel.com/technology/IAPC/acpi/downloads.htm.
+   Compile it and issue command similar to below to create the DSDT AML
+   file.
+
+	acpidmp DSDT > my_model_name.aml
+
+   Please send me the AML file. Note: it is binary file.
+
+This code was written without any documentation from HP or Compal so it
+is provided as is without any warranty.
+
+Contributions, bug reports and text corrections are welcome.
+
+If you experience any problems after using this module try to reboot your
+computer. If it does not help (eg. the laptop reboots in edless loop) turn
+off the machine and remove the battery and the AC power cord for some
+minutes. It it does not help too, remove the battery, plug in the AC power
+cord, turn on the machine and unplug the AC power cord. It will reset your
+laptop.
+
+Unfortunately the official HP technical support refusing to share any
+information with similar messages (in 2002):
+
+> Thank you for contacting Hewlett Packard laptop email support.
+> 
+> I'm sorry, but I won't be able to help you with that. HP does not
+> recommend or support the installation of any version of Linux on any of
+> our notebook products.
+
+Compal Electronics, Inc. does not response to information requests at all.
+
+Meanwhile (in 2002) Compaq and HP merged and as I know Compaq will the
+supplier of the new laptop models in the merged company.
+
+For more information you can see the OmniBook mailing list at
+http://zurich.ai.mit.edu/mailman/listinfo/omnibook
+
+You can find actual version of this code at
+http://sourceforge.net/projects/omke
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/README-OneTouch linux-2.6.10-rc1/drivers/char/omnibook/README-OneTouch
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/README-OneTouch	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/README-OneTouch	2004-04-19 10:31:52.000000000 +0200
@@ -0,0 +1,194 @@
+Kernel Support for OneTouch buttons of HP OmniBooks
+===================================================
+
+Some HP OmniBook (and other) laptops have special multimedia keys
+(aka OneTouch buttons). These or some of them are disabled by default
+and need to be enabled.
+
+Note: these buttons are enabled by kernel series 2.5/2.6 at startup without
+      this module, but sometimes it is useful to disable them e.g. if you
+      travel with your laptop, and want to prevent accidental pressing
+      buttons on front/side of your laptop.
+
+This module try to detect your HP OmniBook and enable OneTouch buttons
+to generate scancodes.
+Look in syslog messages for "keyboard: unknown scancode e0 xx" messages to
+identify the scancode assigned to button. Use setkeycodes from console-tools
+package to assign keycodes to them.
+
+The scancodes are different on different models:
+
+HP OmniBook XE3 GC, GD, GE and HP Pavilion N5xxx
+------------------------------------------------
+
+WWW button:			e073
+Mail button:			e074
+Presentation button:		e072
+Help button:			e071
+
+Previous Track button:		e010
+Play / Pause button:		e022
+Stop / Eject button:		e024
+Next Track button:		e019
+
+
+HP OmniBook XE3 GF
+------------------
+
+WWW button:                     e032
+Mail button:                    e06c
+Presentation button:            e074
+Help button:                    e073
+
+Previous Track button:          e010
+Play / Pause button:            e022
+Stop / Eject button:            e024
+Next Track button:              e019
+
+Volume down (& Fn-Down arrow):	e02e
+Volume up (& Fn-Up arrow):	e030
+Mute / Unmute (Fn-F7):          e020
+
+
+HP OmniBook xe4xxx and ze4xxx
+-----------------------------
+
+Mail button:                    e06c
+Presentation button:            e073
+WWW button:                     e032
+Lock button:                    e071
+Help button:                    e070
+
+Volume down button:             e02e
+Volume up button:               e030
+Mute / Unmute button:           e020
+
+
+HP OmniBook xt155
+-----------------
+
+Mail button:                    e06c
+Presentation button:            e073
+WWW button:                     e032
+Lock button:                    e071
+Help button:                    e070
+
+
+HP OmniBook XT1000 and ZT11xx
+-----------------------------
+
+Mail button:                    e06c
+Presentation button:            e074
+WWW button:                     e032
+Lock button:                    e073
+Help button:                    e072
+
+MP3 button:                     e071
+Previous Track button:          e010
+Play / Pause button:            e022
+Stop / Eject button:            e024
+Next Track button:              e019
+
+Volume down button:             e02e
+Volume up button:               e030
+Mute / Unmute button:           e020
+
+
+HP OmniBook 5xx
+---------------
+
+Presentation button:		e074
+Help button:			e073
+
+Previous Track button:          e010 (*)
+Play / Pause button:            e022 (*)
+Stop / Eject button:            e024 (*)
+Next Track button:              e019 (*)
+
+Volume down button:             e02e (*)
+Volume up button:               e030 (*)
+
+(*) On the docking station
+
+
+Toshiba Satellite 3000-100
+--------------------------
+
+WWW button:			e071
+Mail button:			e073
+
+DVD button:			e006
+CD button:			e013
+
+Stop / Eject button:		e024
+Previous Track button:		e010
+Next Track button:		e019
+Play / Pause button:		e022
+
+Volume up button:		e075
+Volume down button:		e076
+
+
+HP/Compaq nx9000
+----------------
+
+Mail button:                    e06c
+Search button:                  e073
+Information button:             e032
+Lock button:                    e071
+Help button:                    e070
+
+Volume down button:             e02e
+Volume up button:               e030
+Mute / Unmute button:           e020
+
+
+Fujitsu-Siemens Amilo D
+-----------------------
+
+User 1 / Stop / Eject button:   e071
+User 1 / Play / Pause button:   e072
+Email / Previous Track button:  e074
+WWW / Next Track button:        e073
+
+Volume up button:               e075
+Volume down button:             e076
+
+
+Acer Aspire 1350
+----------------
+
+Bluetooth			e058
+Wifi				e056
+
+
+There are programs specifically designed for such application keys (e.g.
+hotkeys: http://ypwong.org/hotkeys/) or kernel level support for such
+keys at http://rick.vanrein.org/linux/funkey/.
+
+XE3L machines are same as XE3 models but they have application launcher
+buttons only but do not have multimedia (CD and volume control) buttons.
+
+The extra buttons near the touchpad are not OneTouch buttons. You need
+driver for touchpad to use them. If you have Synaptics touchpad you may
+try the driver can be found at http://www.mobilix.org/touchpad_driver.html.
+Newer version can be found at
+http://w1.894.telia.com/~u89404340/touchpad/index.html
+
+The ("Big Blue") Sleep button also not a OneTouch button, it usually
+handled by APM or ACPI stuff depending on your BIOS implementation.
+
+Unfortunately the volume control buttons on XE3GC and OB5xx style models are
+implemented in different way and do not generates scancodes. On XE3GC style
+models scancodes can be emulated but there is no publically available
+technical information about implementing them on OmniBook 5xx. Neither
+Compal Electronics, Inc. (the manufacturer of HP OmniBook, some Toshiba
+Satellites and probably other machines) nor Dritek System, Inc.
+(the vendor of the Windows software for OneTouch buttons) send any response
+to information requests.
+
+Additional info: the volume control buttons on the right side of OB5xx and
+OB6xxxx wired into the sound chip. You may ask the maintainer of sound chip
+driver to implement the support of these buttons.
+The volume control buttons on the docking station of OB500 are real OneTouch
+buttons (see above).
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/temperature.c linux-2.6.10-rc1/drivers/char/omnibook/temperature.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/temperature.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/temperature.c	2004-05-02 05:56:28.000000000 +0200
@@ -0,0 +1,134 @@
+/*
+ * temperature.c -- CPU temprature monitoring
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct proc_dir_entry *proc_temperature;
+
+int omnibook_get_cpu_temp(void)
+{
+	u8 temp = 0;
+	int retval;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case TSP10:
+		if ((retval = omnibook_ec_read(XE3GF_CTMP, &temp)))
+			return retval;
+		retval = temp;
+		break;
+	case XE3GC:
+	case AMILOD:
+		if ((retval = omnibook_ec_read(XE3GC_CTMP, &temp)))
+			return retval;
+		retval = temp;
+		break;
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+	case XE2:
+		if ((retval = omnibook_ec_read(OB500_CTMP, &temp)))
+			return retval;
+		retval = temp;
+		break;
+	case OB4150:
+		if ((retval = omnibook_ec_read(OB4150_TMP, &temp)))
+			return retval;
+		retval = temp;
+		break;
+	default:
+		printk(KERN_INFO "%s: Temperature monitoring is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		retval = -ENODEV ;
+	}
+	return retval;
+}
+
+static int omnibook_proc_temperature(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+	int cpu_temp;
+
+	cpu_temp = omnibook_get_cpu_temp();
+	if (cpu_temp < 0)
+		return cpu_temp;
+
+	b += sprintf(b, "CPU temperature:            %2d C\n", cpu_temp);
+
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+int __init omnibook_temperature_init(void)
+{
+	mode_t pmode;
+
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case OB500:
+	case OB510:
+	case OB6000:
+	case OB6100:
+	case XE4500:
+	case OB4150:
+	case XE2:
+	case AMILOD:
+	case TSP10:
+		pmode = S_IFREG | S_IRUGO;
+		proc_temperature = create_proc_read_entry("temperature", pmode, omnibook_proc_root, omnibook_proc_temperature, NULL);
+		break;
+	default:
+		printk(KERN_INFO "%s: Temperature monitoring is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		return 0;
+	}
+	if (! proc_temperature) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/temperature.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	printk(KERN_INFO "%s: Temperature monitoring is enabled.\n", OMNIBOOK_MODULE_NAME);
+	return 0;
+}
+
+void __exit omnibook_temperature_cleanup(void)
+{
+	if (proc_temperature)
+		remove_proc_entry("temperature", omnibook_proc_root);
+}
+
+EXPORT_SYMBOL(omnibook_get_cpu_temp);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/TODO linux-2.6.10-rc1/drivers/char/omnibook/TODO
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/TODO	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/TODO	2003-11-10 18:07:34.000000000 +0100
@@ -0,0 +1,11 @@
+TODO
+====
+
+* Fix LCD brighness handling on XE3GF style machines
+* Fully support OB5xx, OB6xxx and XE4500 style machines
+* Volume key support for OB5xx style machines
+* Battery support for OB5xx, OB6xxx and XE4500 style machines
+* Adding more features of embedded controller
+* Adding misc device interface support
+* Support more machines
+* Prevent kernel Oops when unloading on 2.6
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/touchpad.c linux-2.6.10-rc1/drivers/char/omnibook/touchpad.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/touchpad.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/touchpad.c	2004-07-13 15:17:18.000000000 +0200
@@ -0,0 +1,248 @@
+/*
+ * touchpad.c -- enable/disable touchpad
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2002-2004
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+
+#include <asm/system.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef OMNIBOOK_STANDALONE
+#include "omnibook.h"
+#else
+#include <linux/omnibook.h>
+#endif
+
+#include "ec.h"
+#include "util.h"
+
+static struct pm_dev *pm_touchpad;
+static pm_callback pm_touchpad_callback = NULL;
+
+static struct proc_dir_entry *proc_touchpad;
+
+#ifdef CONFIG_MOUSE_PS2
+#define OMNIBOOK_TOUCHPAD
+#endif
+
+#ifdef CONFIG_MOUSE_PS2_SYNAPTICS
+#define OMNIBOOK_TOUCHPAD
+#endif
+
+#ifdef CONFIG_PSMOUSE
+#define OMNIBOOK_TOUCHPAD
+#endif
+
+#ifdef OMNIBOOK_TOUCHPAD
+/* Touchpad is enabled by default */
+int omnibook_touchpad_enabled = 1;
+#else
+int omnibook_touchpad_enabled = 0;
+#endif
+
+static int omnibook_touchpad_on(void)
+{
+	if (omnibook_kbc_command(OMNIBOOK_KBC_CONTROL_CMD, OMNIBOOK_KBC_CMD_TOUCHPAD_ENABLE)) {
+		printk(KERN_ERR "%s: failed touchpad enable command.\n", OMNIBOOK_MODULE_NAME);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int omnibook_touchpad_off(void)
+{
+	if (omnibook_kbc_command(OMNIBOOK_KBC_CONTROL_CMD, OMNIBOOK_KBC_CMD_TOUCHPAD_DISABLE)) {
+		printk(KERN_ERR "%s: failed touchpad disable command.\n", OMNIBOOK_MODULE_NAME);
+		return -EIO;
+	}
+	return 0;
+}
+
+/*
+ * Power management handler: on resume it redisables the touchpad if it was disabled previously
+ */
+
+static int pm_touchpad_handler(struct pm_dev *dev, pm_request_t rqst, void *data)
+{
+	switch (rqst) {
+	case PM_RESUME:
+		if (! omnibook_touchpad_enabled)
+			return omnibook_touchpad_off();
+		break;
+	}
+	return 0;
+}
+
+static int omnibook_touchpad_register(void)
+{
+		pm_touchpad_callback = pm_touchpad_handler;
+		pm_touchpad = pm_register(PM_SYS_DEV, PM_SYS_KBC, pm_touchpad_callback);
+		return (pm_touchpad ? 0 : -EFAULT);
+}
+
+static void omnibook_touchpad_unregister(void)
+{
+		pm_touchpad_callback = NULL;
+		pm_unregister(pm_touchpad);
+}
+
+int omnibook_touchpad_enable(void)
+{
+#ifdef OMNIBOOK_TOUCHPAD
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case TSP10:
+		if (! omnibook_touchpad_enabled) {
+			if (omnibook_touchpad_on())
+				return -EIO;
+			omnibook_touchpad_enabled = 1;
+			printk(KERN_INFO "%s: Touchpad is enabled.\n", OMNIBOOK_MODULE_NAME);
+		}
+		break;
+        /* These models have stickpointer, not touchpad */
+	case OB500:
+	case OB510:
+		omnibook_touchpad_enabled = 0;
+		return -ENODEV;
+		break;
+	default:
+		omnibook_touchpad_enabled = 1;
+		return -ENODEV;
+	}
+#endif
+	return 0;
+}
+
+int omnibook_touchpad_disable(void)
+{
+#ifdef OMNIBOOK_TOUCHPAD
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case TSP10:
+		if (omnibook_touchpad_enabled) {
+			if (omnibook_touchpad_off()) {
+				return -EIO;
+			}
+			omnibook_touchpad_enabled = 0;
+			printk(KERN_INFO "%s: Touchpad is disabled.\n", OMNIBOOK_MODULE_NAME);
+		}
+		break;
+        /* These models have stickpointer, not touchpad */
+	case OB500:
+	case OB510:
+		omnibook_touchpad_enabled = 0;
+		return -ENODEV;
+		break;
+	default:
+		omnibook_touchpad_enabled = 1;
+		return -ENODEV;
+	}
+#endif
+	return 0;
+}
+
+static int omnibook_touchpad_status(char *buffer, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *b = buffer;
+
+        b += sprintf(b, "Touchpad is %s\n", (omnibook_touchpad_enabled) ? "enabled" : "disabled");
+	
+	return omnibook_proc_len(buffer, start, off, count, eof, b);
+}
+
+static int omnibook_touchpad_set(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	char status[1] = {'\0'};
+
+	if (copy_from_user(status, buffer, 1))
+		return -EFAULT;
+	switch (*status) {
+	case '0':
+		omnibook_touchpad_disable();
+		break;
+	case '1':
+		omnibook_touchpad_enable();
+		break;
+	default:
+		count = -EINVAL;
+	}
+	return count;
+}
+
+int __init omnibook_touchpad_init(void)
+{
+#ifdef OMNIBOOK_TOUCHPAD
+	int retval;
+	mode_t pmode;
+	
+	switch (omnibook_ectype) {
+	case XE3GF:
+	case XE3GC:
+	case TSP10:
+		pmode = S_IFREG | S_IWUSR | S_IRUGO;
+		if (omnibook_userset)
+			pmode = pmode | S_IWUGO;
+		proc_touchpad = create_proc_entry("touchpad", pmode, omnibook_proc_root);
+		break;
+	default:
+		printk(KERN_INFO "%s: Touchpad handling is unsupported on this machine.\n", OMNIBOOK_MODULE_NAME);
+		omnibook_touchpad_enabled = 1;
+		return 0;
+	}
+	if (proc_touchpad) {
+		proc_touchpad->read_proc = omnibook_touchpad_status;
+		proc_touchpad->write_proc = omnibook_touchpad_set;
+	} else {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/touchpad.\n", OMNIBOOK_MODULE_NAME, OMNIBOOK_MODULE_NAME);
+		return -ENOENT;
+	}
+	if ((retval = omnibook_touchpad_register()))
+		return retval;
+
+	return 0;
+#else
+	printk(KERN_ERR "%s: PS/2 mouse support is not compiled into your kernel.\n", OMNIBOOK_MODULE_NAME);
+//	return -ENODEV;
+	return 0;
+#endif
+}
+
+void __exit omnibook_touchpad_cleanup(void)
+{
+#ifdef OMNIBOOK_TOUCHPAD
+	if (proc_touchpad)
+		remove_proc_entry("touchpad", omnibook_proc_root);
+	if (pm_touchpad)
+		omnibook_touchpad_unregister();
+	omnibook_touchpad_enable();
+#endif
+}
+
+EXPORT_SYMBOL(omnibook_touchpad_enabled);
+EXPORT_SYMBOL(omnibook_touchpad_enable);
+EXPORT_SYMBOL(omnibook_touchpad_disable);
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/util.c linux-2.6.10-rc1/drivers/char/omnibook/util.c
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/util.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/util.c	2004-01-14 20:17:16.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ * util.c -- utility functions
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2003-2004
+ */
+
+#include <linux/types.h>
+
+int omnibook_proc_len(char *buffer, char **start, off_t off, int count, int *eof, char *b)
+{
+	unsigned int len;
+
+	len = b - buffer;
+	if (len < off + count)
+		*eof = 1;
+	*start = buffer + off;
+		len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+/* End of file */
diff -uNr linux-2.6.10-rc1.orig/drivers/char/omnibook/util.h linux-2.6.10-rc1/drivers/char/omnibook/util.h
--- linux-2.6.10-rc1.orig/drivers/char/omnibook/util.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-rc1/drivers/char/omnibook/util.h	2004-01-14 20:17:25.000000000 +0100
@@ -0,0 +1,19 @@
+/*
+ * util.h -- Utility declarations
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Written by Soós Péter <sp@osb.hu>, 2003-2004
+ */
+
+extern int omnibook_proc_len(char *buffer, char **start, off_t off, int count, int *eof, char *b);
+
+/* End of file */
