--- kernel-grsec_full.patch.org	2011-08-24 09:32:29.113836788 +0200
+++ kernel-grsec_full.patch	2011-08-24 10:43:17.023101342 +0200
@@ -11175,9 +11175,9 @@
 @@ -186,7 +186,7 @@ void dump_stack(void)
  
  	bp = stack_frame(current, NULL);
- 	printk("Pid: %d, comm: %.20s %s %s %.*s\n",
--		current->pid, current->comm, print_tainted(),
-+		task_pid_nr(current), current->comm, print_tainted(),
+ 	printk("Pid: %d, comm: %.20s xid: #%u %s %s %.*s\n",
+-		current->pid, current->comm, current->xid, print_tainted(),
++		task_pid_nr(current), current->comm, current->xid, print_tainted(),
  		init_utsname()->release,
  		(int)strcspn(init_utsname()->version, " "),
  		init_utsname()->version);
@@ -14211,9 +14211,9 @@
 @@ -106,7 +123,7 @@ void show_regs_common(void)
  
  	printk(KERN_CONT "\n");
- 	printk(KERN_DEFAULT "Pid: %d, comm: %.20s %s %s %.*s",
--		current->pid, current->comm, print_tainted(),
-+		task_pid_nr(current), current->comm, print_tainted(),
+ 	printk(KERN_DEFAULT "Pid: %d, xid: #%u, comm: %.20s %s %s %.*s",
+-		current->pid, current->xid, current->comm, print_tainted(),
++		task_pid_nr(current), current->xid, current->comm, print_tainted(),
  		init_utsname()->release,
  		(int)strcspn(init_utsname()->version, " "),
  		init_utsname()->version);
@@ -37570,9 +37570,9 @@
  #include <linux/slab.h>
  #include <linux/fs_struct.h>
 +#include <linux/grsecurity.h>
+ #include <linux/vserver/global.h>
  #include "internal.h"
  
- static inline void path_get_longterm(struct path *path)
 @@ -31,6 +32,7 @@ void set_fs_root(struct fs_struct *fs, s
  	old_root = fs->root;
  	fs->root = *path;
@@ -39661,9 +39661,9 @@
  #endif
  #ifdef CONFIG_SCHEDSTATS
 @@ -2857,6 +2972,9 @@ static const struct pid_entry tgid_base_
- #ifdef CONFIG_HARDWALL
  	INF("hardwall",   S_IRUGO, proc_pid_hardwall),
  #endif
+ 	ONE("nsproxy",	S_IRUGO, proc_pid_nsproxy),
 +#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
 +	INF("ipaddr",	  S_IRUSR, proc_pid_ipaddr),
 +#endif
@@ -39733,11 +39733,11 @@
 +	rcu_read_unlock();
 +#endif
  		filp->f_pos = iter.tgid + TGID_OFFSET;
+ 		if (!vx_proc_task_visible(iter.task))
+ 			continue;
 -		if (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {
 +		if (proc_pid_fill_cache(filp, dirent, __filldir, iter) < 0) {
  			put_task_struct(iter.task);
- 			goto out;
- 		}
 @@ -3141,7 +3294,7 @@ static const struct pid_entry tid_base_s
  	REG("sched",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),
  #endif
@@ -39815,9 +39815,9 @@
 +#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
 +extern int proc_pid_ipaddr(struct task_struct *task, char *buffer);
 +#endif
- extern loff_t mem_lseek(struct file *file, loff_t offset, int orig);
+ extern int proc_pid_nsproxy(struct seq_file *m, struct pid_namespace *ns,
+ 				struct pid *pid, struct task_struct *task);
  
- extern const struct file_operations proc_maps_operations;
 diff -urNp linux-3.0.3/fs/proc/Kconfig linux-3.0.3/fs/proc/Kconfig
 --- linux-3.0.3/fs/proc/Kconfig	2011-07-21 22:17:23.000000000 -0400
 +++ linux-3.0.3/fs/proc/Kconfig	2011-08-23 21:48:14.000000000 -0400
@@ -53625,10 +53625,10 @@
  static inline struct proc_dir_entry *create_proc_read_entry(const char *name,
  	mode_t mode, struct proc_dir_entry *base, 
  	read_proc_t *read_proc, void * data)
-@@ -258,7 +271,7 @@ union proc_op {
- 	int (*proc_show)(struct seq_file *m,
- 		struct pid_namespace *ns, struct pid *pid,
- 		struct task_struct *task);
+@@ -278,7 +278,7 @@ union proc_op {
+ 	int (*proc_vs_read)(char *page);
+ 	int (*proc_vxi_read)(struct vx_info *vxi, char *page);
+ 	int (*proc_nxi_read)(struct nx_info *nxi, char *page);
 -};
 +} __no_const;
  
@@ -55990,15 +55990,15 @@
  	new = kmem_cache_zalloc(cred_jar, GFP_KERNEL);
  	if (!new)
  		return NULL;
-@@ -287,6 +295,8 @@ struct cred *prepare_creds(void)
- 	const struct cred *old;
+@@ -268,6 +268,8 @@ struct cred *__prepare_creds(const struc
+ {
  	struct cred *new;
  
 +	pax_track_stack();
 +
- 	validate_process_creds();
- 
  	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);
+ 	if (!new)
+ 		return NULL;
 @@ -333,6 +343,8 @@ struct cred *prepare_exec_creds(void)
  	struct thread_group_cred *tgcred = NULL;
  	struct cred *new;
@@ -56607,13 +56607,15 @@
  	return 0;
  }
  
-@@ -1104,10 +1142,13 @@ static struct task_struct *copy_process(
- 	DEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);
- #endif
- 	retval = -EAGAIN;
-+
+@@ -1156,13 +1156,15 @@ static struct task_struct *copy_process(
+ 	init_vx_info(&p->vx_info, current_vx_info());
+ 	init_nx_info(&p->nx_info, current_nx_info());
+ 
 +	gr_learn_resource(p, RLIMIT_NPROC, atomic_read(&p->real_cred->user->processes), 0);
 +
+ 	retval = -EAGAIN;
+ 	if (!vx_nproc_avail(1))
+ 		goto bad_fork_free;
  	if (atomic_read(&p->real_cred->user->processes) >=
  			task_rlimit(p, RLIMIT_NPROC)) {
 -		if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&
@@ -58032,8 +58034,8 @@
 +	struct task_struct *task;
 +
  	rcu_lockdep_assert(rcu_read_lock_held());
--	return pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
-+	task = pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
+-	return pid_task(find_pid_ns(vx_rmap_pid(nr), ns), PIDTYPE_PID);
++	task = pid_task(find_pid_ns(vx_rmap_pid(nr), ns), PIDTYPE_PID);
 +
 +	if (gr_pid_is_chrooted(task))
 +		return NULL;
@@ -58249,7 +58251,7 @@
 diff -urNp linux-3.0.3/kernel/printk.c linux-3.0.3/kernel/printk.c
 --- linux-3.0.3/kernel/printk.c	2011-07-21 22:17:23.000000000 -0400
 +++ linux-3.0.3/kernel/printk.c	2011-08-23 21:48:14.000000000 -0400
-@@ -313,12 +313,17 @@ static int check_syslog_permissions(int 
+@@ -314,12 +314,17 @@ static int check_syslog_permissions(int
  	if (from_file && type != SYSLOG_ACTION_OPEN)
  		return 0;
  
@@ -58259,7 +58261,7 @@
 +#endif
 +
  	if (syslog_action_restricted(type)) {
- 		if (capable(CAP_SYSLOG))
+ 		if (vx_capable(CAP_SYSLOG, VXC_SYSLOG))
  			return 0;
  		/* For historical reasons, accept CAP_SYS_ADMIN too, with a warning */
  		if (capable(CAP_SYS_ADMIN)) {
@@ -58918,7 +58920,7 @@
 -	if (increment < 0 && !can_nice(current, nice))
 +	if (increment < 0 && (!can_nice(current, nice) ||
 +			      gr_handle_chroot_nice()))
- 		return -EPERM;
+ 		return vx_flags(VXF_IGNEG_NICE, 0) ? 0 : -EPERM;
  
  	retval = security_task_setnice(current, nice);
 @@ -5111,6 +5116,7 @@ recheck:
@@ -58987,10 +58989,11 @@
  	if (is_global_init(tsk))
  		return 1;
  	if (handler != SIG_IGN && handler != SIG_DFL)
-@@ -770,6 +773,13 @@ static int check_kill_permission(int sig
- 		}
+@@ -797,6 +797,14 @@
+ 			sig, info, t, vx_task_xid(t), t->pid, current->xid);
+ 		return error;
  	}
- 
++
 +	/* allow glibc communication via tgkill to other threads in our
 +	   thread group */
 +	if ((info == SEND_SIG_NOINFO || info->si_code != SI_TKILL ||
@@ -58998,9 +59001,9 @@
 +	    && gr_handle_signal(t, sig))
 +		return -EPERM;
 +
+ /* skip: */
  	return security_task_kill(t, info, sig, 0);
  }
- 
 @@ -1092,7 +1102,7 @@ __group_send_sig_info(int sig, struct si
  	return send_signal(sig, info, p, 1);
  }
@@ -65122,6 +65125,7 @@
  
  #include <net/inet_connection_sock.h>
  #include <net/inet_hashtables.h>
+ #include <net/route.h>
  #include <net/secure_seq.h>
  #include <net/ip.h>
  
@@ -65129,7 +65133,6 @@
 +
  /*
   * Allocate and initialize a new local port bind bucket.
-  * The bindhash mutex for snum's hash chain must be held here.
 @@ -530,6 +533,8 @@ ok:
  			twrefcnt += inet_twsk_bind_unhash(tw, hinfo);
  		spin_unlock(&head->lock);
@@ -65875,9 +65878,9 @@
 +extern int grsec_enable_blackhole;
 +#endif
 +
- int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)
+ int ipv6_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2)
  {
- 	const struct in6_addr *sk_rcv_saddr6 = &inet6_sk(sk)->rcv_saddr;
+ 	const struct in6_addr *sk1_rcv_saddr6 = &inet6_sk(sk1)->rcv_saddr;
 @@ -548,7 +552,7 @@ int udpv6_queue_rcv_skb(struct sock * sk
  
  	return 0;
