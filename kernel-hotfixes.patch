
 arch/alpha/kernel/alpha_ksyms.c        |    3 +++
 arch/alpha/kernel/process.c            |    2 ++
 arch/i386/mm/init.c                    |    1 +
 arch/ppc/kernel/setup.c                |    1 +
 drivers/char/rocket.c                  |   10 ++++------
 drivers/media/video/bt819.c            |    3 ++-
 drivers/scsi/megaraid/Kconfig.megaraid |    2 --
 drivers/usb/gadget/serial.c            |    8 ++------
 fs/afs/main.c                          |   32 ++++++++++++++------------------
 include/asm-alpha/spinlock.h           |    2 ++
 include/linux/spinlock.h               |    2 +-
 mm/mmap.c                              |    2 +-
 net/ipv4/netfilter/ipt_hashlimit.c     |    2 +-
 net/rxrpc/main.c                       |   10 +++-------
 14 files changed, 37 insertions(+), 43 deletions(-)

--- a/include/linux/spinlock.h	2004-09-05 02:05:53.243858818 -0500
+++ b/include/linux/spinlock.h	2004-09-05 02:06:06.177805993 -0500
@@ -38,7 +38,7 @@
 #ifdef CONFIG_SMP
 #include <asm/spinlock.h>
 
-#define __lockfunc fastcall __attribute__((section(".spinlock.text")))
+#define __lockfunc fastcall __attribute__((section(".lock.text")))
 
 int __lockfunc _spin_trylock(spinlock_t *lock);
 int __lockfunc _write_trylock(rwlock_t *lock);
--- a/arch/i386/mm/init.c	2004-09-26 03:43:57.944613000 +1000
+++ b/arch/i386/mm/init.c	2004-09-28 02:37:21.787922000 +1000
@@ -41,6 +41,7 @@
 #include <asm/sections.h>
 
 unsigned int __VMALLOC_RESERVE = 128 << 20;
+EXPORT_SYMBOL(__VMALLOC_RESERVE);
 
 DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
 unsigned long highstart_pfn, highend_pfn;
--- a/drivers/scsi/megaraid/Kconfig.megaraid	2004-12-24 22:34:01.000000000 +0100
+++ b/drivers/scsi/megaraid/Kconfig.megaraid	2005-01-30 12:48:22.248759048 +0100
@@ -63,7 +63,6 @@
 	To compile this driver as a module, choose M here: the
 	module will be called megaraid_mbox
 
-if MEGARAID_NEWGEN=n
 config MEGARAID_LEGACY
 	tristate "LSI Logic Legacy MegaRAID Driver"
 	depends on PCI && SCSI
@@ -74,4 +73,3 @@
 
 	To compile this driver as a module, choose M here: the
 	module will be called megaraid
-endif
--- a/arch/ppc/kernel/setup.c	2004-12-24 22:35:28.000000000 +0100
+++ b/arch/ppc/kernel/setup.c	2005-02-02 10:09:21.763162752 +0100
@@ -84,6 +84,7 @@
 
 #ifdef CONFIG_VGA_CONSOLE
 unsigned long vgacon_remap_base;
+EXPORT_SYMBOL(vgacon_remap_base);
 #endif
 
 struct machdep_calls ppc_md;
--- a/drivers/usb/gadget/serial.c	2004-12-24 22:35:24.000000000 +0100
+++ b/drivers/usb/gadget/serial.c	2005-02-15 09:39:48.408315792 +0100
@@ -329,10 +329,6 @@
 
 /* Functions */
 
-/* module */
-static int __init gs_module_init(void);
-static void __exit gs_module_exit(void);
-
 /* tty driver */
 static int gs_open(struct tty_struct *tty, struct file *file);
 static void gs_close(struct tty_struct *tty, struct file *file);
@@ -712,8 +708,6 @@
 module_param(use_acm, uint, S_IRUGO);
 MODULE_PARM_DESC(use_acm, "Use CDC ACM, 0=no, 1=yes, default=no");
 
-module_init(gs_module_init);
-module_exit(gs_module_exit);
 
 /*
 *  gs_module_init
@@ -761,6 +755,7 @@
 	printk(KERN_INFO "gs_module_init: %s %s loaded\n", GS_LONG_NAME, GS_VERSION_STR);
 	return 0;
 }
+module_init(gs_module_init);
 
 /*
 * gs_module_exit
@@ -775,6 +770,7 @@
 
 	printk(KERN_INFO "gs_module_exit: %s %s unloaded\n", GS_LONG_NAME, GS_VERSION_STR);
 }
+module_exit(gs_module_exit);
 
 /* TTY Driver */
 
--- a/fs/afs/main.c	2004-12-24 22:34:27.000000000 +0100
+++ b/fs/afs/main.c	2005-02-15 09:42:09.761826792 +0100
@@ -29,29 +29,11 @@
 
 struct rxrpc_transport *afs_transport;
 
-static int afs_init(void);
-static void afs_exit(void);
 static int afs_adding_peer(struct rxrpc_peer *peer);
 static void afs_discarding_peer(struct rxrpc_peer *peer);
 
-/* XXX late_initcall is kludgy, but the only alternative seems to create
- * a transport upon the first mount, which is worse. Or is it?
- */
-/* module_init(afs_init); */
-late_initcall(afs_init);	/* must be called after net/ to create socket */
-
-module_exit(afs_exit);
-
-MODULE_DESCRIPTION("AFS Client File System");
-MODULE_AUTHOR("Red Hat, Inc.");
-MODULE_LICENSE("GPL");
-
 static char *rootcell;
 
-module_param(rootcell, charp, 0);
-MODULE_PARM_DESC(rootcell, "root AFS cell name and VL server IP addr list");
-
-
 static struct rxrpc_peer_ops afs_peer_ops = {
 	.adding		= afs_adding_peer,
 	.discarding	= afs_discarding_peer,
@@ -287,3 +269,17 @@
                     );
 }
 #endif
+
+/* XXX late_initcall is kludgy, but the only alternative seems to create
+ * a transport upon the first mount, which is worse. Or is it?
+ */
+/* module_init(afs_init); */
+late_initcall(afs_init);	/* must be called after net/ to create socket */
+module_exit(afs_exit);
+
+module_param(rootcell, charp, 0);
+MODULE_PARM_DESC(rootcell, "root AFS cell name and VL server IP addr list");
+
+MODULE_DESCRIPTION("AFS Client File System");
+MODULE_AUTHOR("Red Hat, Inc.");
+MODULE_LICENSE("GPL");
--- a/net/rxrpc/main.c	2004-12-24 22:35:25.000000000 +0100
+++ b/net/rxrpc/main.c	2005-02-15 09:45:12.420058520 +0100
@@ -22,12 +22,6 @@
 #include <rxrpc/message.h>
 #include "internal.h"
 
-static int rxrpc_initialise(void);
-static void rxrpc_cleanup(void);
-
-module_init(rxrpc_initialise);
-module_exit(rxrpc_cleanup);
-
 MODULE_DESCRIPTION("Rx RPC implementation");
 MODULE_AUTHOR("Red Hat, Inc.");
 MODULE_LICENSE("GPL");
@@ -38,7 +32,7 @@
 /*
  * initialise the Rx module
  */
-static int rxrpc_initialise(void)
+static int __init rxrpc_initialise(void)
 {
 	int ret;
 
@@ -92,6 +86,7 @@
 #endif
 	return ret;
 } /* end rxrpc_initialise() */
+module_init(rxrpc_initialise);
 
 /*****************************************************************************/
 /*
@@ -135,6 +130,7 @@
 
 	kleave("");
 } /* end rxrpc_cleanup() */
+module_exit(rxrpc_cleanup);
 
 /*****************************************************************************/
 /*
--- a/drivers/char/rocket.c	2004-12-24 22:35:21.000000000 +0100
+++ b/drivers/char/rocket.c	2005-02-15 09:48:39.050645896 +0100
@@ -210,11 +210,6 @@
 module_param_array(pc104_4, ulong, NULL, 0);
 MODULE_PARM_DESC(pc104_4, "set interface types for ISA(PC104) board #4 (e.g. pc104_4=232,232,485,485,...");
 
-int rp_init(void);
-static void rp_cleanup_module(void);
-
-module_init(rp_init);
-module_exit(rp_cleanup_module);
 
 #endif
 
@@ -2422,10 +2417,11 @@
 
 	return 0;
 }
+module_init(rp_init);
 
 #ifdef MODULE
 
-static void rp_cleanup_module(void)
+static void __exit rp_cleanup_module(void)
 {
 	int retval;
 	int i;
@@ -2451,6 +2447,8 @@
 	if (controller)
 		release_region(controller, 4);
 }
+module_exit(rp_cleanup_module);
+
 #endif
 
 #ifndef TRUE
--- a/net/ipv4/netfilter/ipt_hashlimit.c	2005-03-15 20:37:04.000000000 +0100
+++ b/net/ipv4/netfilter/ipt_hashlimit.c	2005-03-15 20:37:08.000000000 +0100
@@ -113,7 +113,7 @@
 static inline u_int32_t
 hash_dst(const struct ipt_hashlimit_htable *ht, const struct dsthash_dst *dst)
 {
-	return (jhash_3words(dst->dst_ip, (dst->dst_port<<16 & dst->src_port), 
+	return (jhash_3words(dst->dst_ip, (dst->dst_port<<16 | dst->src_port), 
 			     dst->src_ip, ht->rnd) % ht->cfg.size);
 }
 
--- a/include/asm-alpha/spinlock.h	2005-03-19 07:34:59.000000000 +0100
+++ b/include/asm-alpha/spinlock.h	2005-03-22 18:26:26.000000000 +0100
@@ -153,6 +153,8 @@
 }
 #endif /* CONFIG_DEBUG_RWLOCK */
 
+#define _raw_read_trylock(lock) generic_raw_read_trylock(lock)
+
 static inline int _raw_write_trylock(rwlock_t * lock)
 {
 	long regx;
--- a/arch/alpha/kernel/alpha_ksyms.c	2005-03-13 07:44:05.000000000 +0100
+++ b/arch/alpha/kernel/alpha_ksyms.c	2005-03-15 23:20:00.405832368 +0100
@@ -67,6 +67,9 @@
 EXPORT_SYMBOL(alpha_using_srm);
 #endif /* CONFIG_ALPHA_GENERIC */
 
+#include <linux/pm.h>
+EXPORT_SYMBOL(pm_power_off);
+
 /* platform dependent support */
 EXPORT_SYMBOL(strcat);
 EXPORT_SYMBOL(strcmp);
--- a/arch/alpha/kernel/process.c	2005-03-13 07:44:40.000000000 +0100
+++ b/arch/alpha/kernel/process.c	2005-03-15 23:28:15.687538104 +0100
@@ -183,6 +183,8 @@
 
 EXPORT_SYMBOL(machine_power_off);
 
+void (*pm_power_off)(void) = machine_power_off;
+
 /* Used by sysrq-p, among others.  I don't believe r9-r15 are ever
    saved in the context it's used.  */
 
--- a/drivers/media/video/bt819.c	2005-03-19 07:34:51.000000000 +0100
+++ b/drivers/media/video/bt819.c	2005-03-23 12:53:28.000000000 +0100
@@ -236,7 +236,8 @@
 	init[0x07 * 2 - 1] = timing->hactive & 0xff;
 	init[0x08 * 2 - 1] = timing->hscale >> 8;
 	init[0x09 * 2 - 1] = timing->hscale & 0xff;
-	init[0x19*2-1] = decoder->norm == 0 ? 115 : 93;	/* Chroma burst delay */
+	/* 0x15 in array is address 0x19 */
+	init[0x15 * 2 - 1] = (decoder->norm == 0) ? 115 : 93;	/* Chroma burst delay */
 	/* reset */
 	bt819_write(client, 0x1f, 0x00);
 	mdelay(1);
--- a/mm/mmap.c	2005-03-23 12:57:29.000000000 +0100
+++ b/mm/mmap.c	2005-03-23 13:54:53.000000000 +0100
@@ -971,7 +971,7 @@
 
 	/* offset overflow? */
 	if ((pgoff + (len >> PAGE_SHIFT)) < pgoff)
-		return -EINVAL;
+		return -EOVERFLOW;
 
 	/* Too many mappings? */
 	if (mm->map_count > sysctl_max_map_count)
