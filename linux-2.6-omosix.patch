diff -Naur linux-2.6.11/arch/i386/Kconfig linux-2.6.11-om/arch/i386/Kconfig
--- linux-2.6.11/arch/i386/Kconfig	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/arch/i386/Kconfig	2005-05-15 23:18:04.000000000 +0200
@@ -1200,6 +1200,14 @@
 
 source "fs/Kconfig.binfmt"
 
+config TRAP_BAD_SYSCALL_EXITS
+	bool "Debug bad system call exits"
+	depends on KGDB
+	help
+	  If you say Y here the kernel will check for system calls which
+	  return without clearing preempt.
+        default n
+
 endmenu
 
 source "drivers/Kconfig"
@@ -1214,6 +1222,8 @@
 
 source "crypto/Kconfig"
 
+source "hpc/Kconfig"
+
 source "lib/Kconfig"
 
 #
diff -Naur linux-2.6.11/arch/i386/Kconfig.debug linux-2.6.11-om/arch/i386/Kconfig.debug
--- linux-2.6.11/arch/i386/Kconfig.debug	2005-03-02 08:38:09.000000000 +0100
+++ linux-2.6.11-om/arch/i386/Kconfig.debug	2005-05-15 23:18:04.000000000 +0200
@@ -65,4 +65,6 @@
 	depends on X86_LOCAL_APIC && !X86_VISWS
 	default y
 
+source "arch/i386/Kconfig.kgdb"
+
 endmenu
diff -Naur linux-2.6.11/arch/i386/Kconfig.kgdb linux-2.6.11-om/arch/i386/Kconfig.kgdb
--- linux-2.6.11/arch/i386/Kconfig.kgdb	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/arch/i386/Kconfig.kgdb	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,170 @@
+config KGDB
+	bool "Include kgdb kernel debugger"
+	depends on DEBUG_KERNEL && !KPROBES
+	help
+	  If you say Y here, the system will be compiled with the debug
+	  option (-g) and a debugging stub will be included in the
+	  kernel.  This stub communicates with gdb on another (host)
+	  computer via a serial port.  The host computer should have
+	  access to the kernel binary file (vmlinux) and a serial port
+	  that is connected to the target machine.  Gdb can be made to
+	  configure the serial port or you can use stty and setserial to
+	  do this. See the 'target' command in gdb. This option also
+	  configures in the ability to request a breakpoint early in the
+	  boot process.  To request the breakpoint just include 'kgdb'
+	  as a boot option when booting the target machine.  The system
+	  will then break as soon as it looks at the boot options.  This
+	  option also installs a breakpoint in panic and sends any
+	  kernel faults to the debugger. For more information see the
+	  Documentation/i386/kgdb/kgdb.txt file.
+
+choice
+	depends on KGDB
+    	prompt "Debug serial port BAUD"
+	default KGDB_115200BAUD
+	help
+	  Gdb and the kernel stub need to agree on the baud rate to be
+	  used.  Some systems (x86 family at this writing) allow this to
+	  be configured.
+
+config KGDB_9600BAUD
+	bool "9600"
+
+config KGDB_19200BAUD
+	bool "19200"
+
+config KGDB_38400BAUD
+	bool "38400"
+
+config KGDB_57600BAUD
+	bool "57600"
+
+config KGDB_115200BAUD
+	bool "115200"
+endchoice
+
+config KGDB_PORT
+	hex "hex I/O port address of the debug serial port"
+	depends on KGDB
+	default  3f8
+	help
+	  Some systems (x86 family at this writing) allow the port
+	  address to be configured.  The number entered is assumed to be
+	  hex, don't put 0x in front of it.  The standard address are:
+	  COM1 3f8 , irq 4 and COM2 2f8 irq 3.  Setserial /dev/ttySx
+	  will tell you what you have.  It is good to test the serial
+	  connection with a live system before trying to debug.
+
+config KGDB_IRQ
+	int "IRQ of the debug serial port"
+	depends on KGDB
+	default 4
+	help
+	  This is the irq for the debug port.  If everything is working
+	  correctly and the kernel has interrupts on a control C to the
+	  port should cause a break into the kernel debug stub.
+
+config KGDB_MORE
+	bool "Add any additional compile options"
+	depends on KGDB
+	default n
+	help
+	  Saying yes here turns on the ability to enter additional
+	  compile options.
+
+
+config KGDB_OPTIONS
+	depends on KGDB_MORE
+	string "Additional compile arguments"
+	default "-O1"
+	help
+	  This option allows you enter additional compile options for
+	  the whole kernel compile.  Each platform will have a default
+	  that seems right for it.  For example on PPC "-ggdb -O1", and
+	  for i386 "-O1".  Note that by configuring KGDB "-g" is already
+	  turned on.  In addition, on i386 platforms
+	  "-fomit-frame-pointer" is deleted from the standard compile
+	  options.
+
+config NO_KGDB_CPUS
+	int "Number of CPUs"
+	depends on KGDB && SMP
+	default NR_CPUS
+	help
+
+	  This option sets the number of cpus for kgdb ONLY.  It is used
+	  to prune some internal structures so they look "nice" when
+	  displayed with gdb.  This is to overcome possibly larger
+	  numbers that may have been entered above.  Enter the real
+	  number to get nice clean kgdb_info displays.
+
+config KGDB_TS
+	bool "Enable kgdb time stamp macros?"
+	depends on KGDB
+	default n
+	help
+	  Kgdb event macros allow you to instrument your code with calls
+	  to the kgdb event recording function.  The event log may be
+	  examined with gdb at a break point.  Turning on this
+	  capability also allows you to choose how many events to
+	  keep. Kgdb always keeps the lastest events.
+
+choice
+	depends on KGDB_TS
+	prompt "Max number of time stamps to save?"
+	default KGDB_TS_128
+
+config KGDB_TS_64
+	bool "64"
+
+config KGDB_TS_128
+	bool "128"
+
+config KGDB_TS_256
+	bool "256"
+
+config KGDB_TS_512
+	bool "512"
+
+config KGDB_TS_1024
+	bool "1024"
+
+endchoice
+
+config STACK_OVERFLOW_TEST
+	bool "Turn on kernel stack overflow testing?"
+	depends on KGDB
+	default n
+	help
+	  This option enables code in the front line interrupt handlers
+	  to check for kernel stack overflow on interrupts and system
+	  calls.  This is part of the kgdb code on x86 systems.
+
+config KGDB_CONSOLE
+	bool "Enable serial console thru kgdb port"
+	depends on KGDB
+	default n
+	help
+	  This option enables the command line "console=kgdb" option.
+	  When the system is booted with this option in the command line
+	  all kernel printk output is sent to gdb (as well as to other
+	  consoles).  For this to work gdb must be connected.  For this
+	  reason, this command line option will generate a breakpoint if
+	  gdb has not yet connected.  After the gdb continue command is
+	  given all pent up console output will be printed by gdb on the
+	  host machine.  Neither this option, nor KGDB require the
+	  serial driver to be configured.
+
+config KGDB_SYSRQ
+	bool "Turn on SysRq 'G' command to do a break?"
+	depends on KGDB
+	default y
+	help
+	  This option includes an option in the SysRq code that allows
+	  you to enter SysRq G which generates a breakpoint to the KGDB
+	  stub.  This will work if the keyboard is alive and can
+	  interrupt the system.  Because of constraints on when the
+	  serial port interrupt can be enabled, this code may allow you
+	  to interrupt the system before the serial port control C is
+	  available.  Just say yes here.
+
diff -Naur linux-2.6.11/arch/i386/kernel/asm-offsets.c linux-2.6.11-om/arch/i386/kernel/asm-offsets.c
--- linux-2.6.11/arch/i386/kernel/asm-offsets.c	2005-03-02 08:38:00.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/asm-offsets.c	2005-05-15 23:18:04.000000000 +0200
@@ -12,6 +12,7 @@
 #include <asm/fixmap.h>
 #include <asm/processor.h>
 #include <asm/thread_info.h>
+#include <hpc/task.h>
 
 #define DEFINE(sym, val) \
         asm volatile("\n->" #sym " %0 " #val : : "i" (val))
@@ -63,4 +64,13 @@
 
 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
 	DEFINE(VSYSCALL_BASE, __fix_to_virt(FIX_VSYSCALL));
+
+#ifdef CONFIG_OPENMOSIX
+	OFFSET(TASK_om, task_struct, om);
+	OFFSET(OM_dflags, openmosix_task, dflags);
+	BLANK();
+
+	DEFINE(DDEPUTY, DDEPUTY);
+	DEFINE(DREMOTE, DREMOTE);
+#endif /* CONFIG_OPENMOSIX */
 }
diff -Naur linux-2.6.11/arch/i386/kernel/entry.S linux-2.6.11-om/arch/i386/kernel/entry.S
--- linux-2.6.11/arch/i386/kernel/entry.S	2005-03-02 08:37:51.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/entry.S	2005-05-15 23:18:04.000000000 +0200
@@ -49,6 +49,23 @@
 #include <asm/page.h>
 #include <asm/desc.h>
 #include "irq_vectors.h"
+        /* We do not recover from a stack overflow, but at least
+         * we know it happened and should be able to track it down.
+         */
+#ifdef CONFIG_STACK_OVERFLOW_TEST
+#define STACK_OVERFLOW_TEST \
+        testl $(THREAD_SIZE - 512),%esp;    \
+        jnz   10f;            \
+        call  stack_overflow; \
+10:
+#else
+#define STACK_OVERFLOW_TEST
+#endif
+
+#ifdef CONFIG_OPENMOSIX
+#include <asm/asm_offsets.h>
+#include "omasm.h"
+#endif /* CONFIG_OPENMOSIX */
 
 #define nr_syscalls ((syscall_table_size)/4)
 
@@ -95,7 +112,8 @@
 	pushl %ebx; \
 	movl $(__USER_DS), %edx; \
 	movl %edx, %ds; \
-	movl %edx, %es;
+	movl %edx, %es; \
+	STACK_OVERFLOW_TEST
 
 #define RESTORE_INT_REGS \
 	popl %ebx;	\
@@ -130,6 +148,19 @@
 	popl %eax
 	jmp syscall_exit
 
+#ifdef CONFIG_OPENMOSIX
+ENTRY(ret_from_deputy_fork)
+	pushl %eax
+	call schedule_tail
+	GET_THREAD_INFO(%ebp)
+	popl %eax
+	jmp syscall_exit
+
+ENTRY(ret_from_kickstart)
+	GET_THREAD_INFO(%ebp)
+	jmp syscall_exit
+#endif /* CONFIG OPENMOSIX */
+
 /*
  * Return to user mode is not as complex as all this looks,
  * but we want the default path for a system call return to
@@ -155,6 +186,9 @@
 	andl $_TIF_WORK_MASK, %ecx	# is there any work to be done on
 					# int/exception return?
 	jne work_pending
+#ifdef CONFIG_OPENMOSIX
+	call openmosix_pre_usermode
+#endif /* CONFIG_OPENMOSIX */
 	jmp restore_all
 
 #ifdef CONFIG_PREEMPT
@@ -178,6 +212,7 @@
 	# sysenter call handler stub
 ENTRY(sysenter_entry)
 	movl TSS_sysenter_esp0(%esp),%esp
+	.globl sysenter_past_esp
 sysenter_past_esp:
 	sti
 	pushl $(__USER_DS)
@@ -206,8 +241,23 @@
 	jnz syscall_trace_entry
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
+#ifdef CONFIG_OPENMOSIX
+remote_or_local_sysenter:
+	movl TI_task(%ebp), %ebp
+	testl $DREMOTE, TASK_om+OM_dflags(%ebp)	# is this a DREMOTE task ?
+	jz sysenter_syscall_call
+sysenter_remote_syscall_call:
+	call *remote_sys_call_table(,%eax,4)
+	movl %eax,EAX(%esp)		# store the return value
+	jmp sysenter_exit
+sysenter_syscall_call:
+#endif /* CONFIG_OPENMOSIX */
 	call *sys_call_table(,%eax,4)
 	movl %eax,EAX(%esp)
+#ifdef CONFIG_OPENMOSIX
+sysenter_exit:
+	GET_THREAD_INFO(%ebp)
+#endif /* CONFIG_OPENMOSIX */
 	cli
 	movl TI_flags(%ebp), %ecx
 	testw $_TIF_ALLWORK_MASK, %cx
@@ -239,10 +289,21 @@
 	jnz syscall_trace_entry
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
+#ifdef CONFIG_OPENMOSIX
+remote_or_local_syscall:
+	movl TI_task(%ebp), %ebp
+	testl $DREMOTE, TASK_om+OM_dflags(%ebp)	# is this a DREMOTE task ?
+	jz syscall_call
+remote_syscall_call:
+	call *remote_sys_call_table(,%eax,4)
+	movl %eax,EAX(%esp)		# store the return value
+	jmp syscall_exit
+#endif /* CONFIG_OPENMOSIX */
 syscall_call:
 	call *sys_call_table(,%eax,4)
 	movl %eax,EAX(%esp)		# store the return value
 syscall_exit:
+	GET_THREAD_INFO(%ebp)
 	cli				# make sure we don't miss an interrupt
 					# setting need_resched or sigpending
 					# between sampling and the iret
@@ -255,6 +316,16 @@
 #endif
 
 restore_all:
+#ifdef CONFIG_TRAP_BAD_SYSCALL_EXITS
+	movl EFLAGS(%esp), %eax		# mix EFLAGS and CS
+	movb CS(%esp), %al
+	testl $(VM_MASK | 3), %eax
+	jz resume_kernelX		# returning to kernel or vm86-space
+	cmpl $0,TI_preempt_count(%ebp)  # non-zero preempt_count ?
+	jz resume_kernelX
+	int $3
+resume_kernelX:
+#endif
 	movl EFLAGS(%esp), %eax		# mix EFLAGS, SS and CS
 	movb OLDSS(%esp), %ah
 	movb CS(%esp), %al
diff -Naur linux-2.6.11/arch/i386/kernel/i387.c linux-2.6.11-om/arch/i386/kernel/i387.c
--- linux-2.6.11/arch/i386/kernel/i387.c	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/i387.c	2005-05-15 23:18:04.000000000 +0200
@@ -95,7 +95,7 @@
  * FPU tag word conversions.
  */
 
-static inline unsigned short twd_i387_to_fxsr( unsigned short twd )
+OM_NSTATIC inline unsigned short twd_i387_to_fxsr( unsigned short twd )
 {
 	unsigned int tmp; /* to avoid 16 bit prefixes in the code */
  
@@ -109,7 +109,7 @@
         return tmp;
 }
 
-static inline unsigned long twd_fxsr_to_i387( struct i387_fxsave_struct *fxsave )
+OM_NSTATIC inline unsigned long twd_fxsr_to_i387( struct i387_fxsave_struct *fxsave )
 {
 	struct _fpxreg *st = NULL;
 	unsigned long tos = (fxsave->swd >> 11) & 7;
@@ -536,6 +536,13 @@
 	return fpvalid;
 }
 
+#ifdef CONFIG_OPENMOSIX
+int cpu_feature_has_fxsr(void)
+{
+	return cpu_has_fxsr;
+}
+#endif /* CONFIG_OPENMOSIX */
+
 int dump_task_extended_fpu(struct task_struct *tsk, struct user_fxsr_struct *fpu)
 {
 	int fpvalid = tsk_used_math(tsk) && cpu_has_fxsr;
diff -Naur linux-2.6.11/arch/i386/kernel/irq.c linux-2.6.11-om/arch/i386/kernel/irq.c
--- linux-2.6.11/arch/i386/kernel/irq.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/irq.c	2005-05-15 23:18:04.000000000 +0200
@@ -103,6 +103,8 @@
 
 	irq_exit();
 
+	kgdb_process_breakpoint();
+
 	return 1;
 }
 
diff -Naur linux-2.6.11/arch/i386/kernel/kgdb_stub.c linux-2.6.11-om/arch/i386/kernel/kgdb_stub.c
--- linux-2.6.11/arch/i386/kernel/kgdb_stub.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/kgdb_stub.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,2454 @@
+/*
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * General Public License for more details.
+ *
+ */
+
+/*
+ * Copyright (c) 2000 VERITAS Software Corporation.
+ *
+ */
+/****************************************************************************
+ *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
+ *
+ *  Module name: remcom.c $
+ *  Revision: 1.34 $
+ *  Date: 91/03/09 12:29:49 $
+ *  Contributor:     Lake Stevens Instrument Division$
+ *
+ *  Description:     low level support for gdb debugger. $
+ *
+ *  Considerations:  only works on target hardware $
+ *
+ *  Written by:	     Glenn Engel $
+ *  Updated by:	     David Grothe <dave@gcom.com>
+ *  Updated by:	     Robert Walsh <rjwalsh@durables.org>
+ *  Updated by:	     wangdi <wangdi@clusterfs.com>
+ *  ModuleState:     Experimental $
+ *
+ *  NOTES:	     See Below $
+ *
+ *  Modified for 386 by Jim Kingdon, Cygnus Support.
+ *  Compatibility with 2.1.xx kernel by David Grothe <dave@gcom.com>
+ *
+ *  Changes to allow auto initilization.  All that is needed is that it
+ *  be linked with the kernel and a break point (int 3) be executed.
+ *  The header file <asm/kgdb.h> defines BREAKPOINT to allow one to do
+ *  this. It should also be possible, once the interrupt system is up, to
+ *  call putDebugChar("+").  Once this is done, the remote debugger should
+ *  get our attention by sending a ^C in a packet. George Anzinger
+ *  <george@mvista.com>
+ *  Integrated into 2.2.5 kernel by Tigran Aivazian <tigran@sco.com>
+ *  Added thread support, support for multiple processors,
+ *	support for ia-32(x86) hardware debugging.
+ *	Amit S. Kale ( akale@veritas.com )
+ *
+ *  Modified to support debugging over ethernet by Robert Walsh
+ *  <rjwalsh@durables.org> and wangdi <wangdi@clusterfs.com>, based on
+ *  code by San Mehat.
+ *
+ *
+ *  To enable debugger support, two things need to happen.  One, a
+ *  call to set_debug_traps() is necessary in order to allow any breakpoints
+ *  or error conditions to be properly intercepted and reported to gdb.
+ *  Two, a breakpoint needs to be generated to begin communication.  This
+ *  is most easily accomplished by a call to breakpoint().  Breakpoint()
+ *  simulates a breakpoint by executing an int 3.
+ *
+ *************
+ *
+ *    The following gdb commands are supported:
+ *
+ * command	    function				   Return value
+ *
+ *    g		    return the value of the CPU registers  hex data or ENN
+ *    G		    set the value of the CPU registers	   OK or ENN
+ *
+ *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA	   hex data or ENN
+ *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA	   OK or ENN
+ *
+ *    c		    Resume at current address		   SNN	 ( signal NN)
+ *    cAA..AA	    Continue at address AA..AA		   SNN
+ *
+ *    s		    Step one instruction		   SNN
+ *    sAA..AA	    Step one instruction from AA..AA	   SNN
+ *
+ *    k		    kill
+ *
+ *    ?		    What was the last sigval ?		   SNN	 (signal NN)
+ *
+ * All commands and responses are sent with a packet which includes a
+ * checksum.  A packet consists of
+ *
+ * $<packet info>#<checksum>.
+ *
+ * where
+ * <packet info> :: <characters representing the command or response>
+ * <checksum>	 :: < two hex digits computed as modulo 256 sum of <packetinfo>>
+ *
+ * When a packet is received, it is first acknowledged with either '+' or '-'.
+ * '+' indicates a successful transfer.	 '-' indicates a failed transfer.
+ *
+ * Example:
+ *
+ * Host:		  Reply:
+ * $m0,10#2a		   +$00010203040506070809101112131415#42
+ *
+ ****************************************************************************/
+#define KGDB_VERSION "<20030915.1651.33>"
+#include <linux/config.h>
+#include <linux/types.h>
+#include <asm/string.h>		/* for strcpy */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <asm/vm86.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>		/* for linux pt_regs struct */
+#include <asm/kgdb_local.h>
+#include <linux/list.h>
+#include <asm/atomic.h>
+#include <asm/processor.h>
+#include <linux/irq.h>
+#include <asm/desc.h>
+#include <linux/inet.h>
+#include <linux/netpoll.h>
+
+/************************************************************************
+ *
+ * external low-level support routines
+ */
+typedef void (*Function) (void);	/* pointer to a function */
+
+/* Thread reference */
+typedef unsigned char threadref[8];
+
+extern int tty_putDebugChar(int);     /* write a single character      */
+extern int tty_getDebugChar(void);    /* read and return a single char */
+extern void tty_flushDebugChar(void); /* flush pending characters      */
+extern int eth_putDebugChar(int);     /* write a single character      */
+extern int eth_getDebugChar(void);    /* read and return a single char */
+extern void eth_flushDebugChar(void); /* flush pending characters      */
+
+/************************************************************************/
+/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
+/* at least NUMREGBYTES*2 are needed for register packets */
+/* Longer buffer is needed to list all threads */
+#define BUFMAX 400
+
+char *kgdb_version = KGDB_VERSION;
+
+/*  debug >  0 prints ill-formed commands in valid packets & checksum errors */
+int debug_regs = 0;		/* set to non-zero to print registers */
+
+/* filled in by an external module */
+char *gdb_module_offsets;
+
+static const char hexchars[] = "0123456789abcdef";
+
+/* Number of bytes of registers.  */
+#define NUMREGBYTES 64
+/*
+ * Note that this register image is in a different order than
+ * the register image that Linux produces at interrupt time.
+ *
+ * Linux's register image is defined by struct pt_regs in ptrace.h.
+ * Just why GDB uses a different order is a historical mystery.
+ */
+enum regnames { _EAX,		/* 0 */
+	_ECX,			/* 1 */
+	_EDX,			/* 2 */
+	_EBX,			/* 3 */
+	_ESP,			/* 4 */
+	_EBP,			/* 5 */
+	_ESI,			/* 6 */
+	_EDI,			/* 7 */
+	_PC /* 8 also known as eip */ ,
+	_PS /* 9 also known as eflags */ ,
+	_CS,			/* 10 */
+	_SS,			/* 11 */
+	_DS,			/* 12 */
+	_ES,			/* 13 */
+	_FS,			/* 14 */
+	_GS			/* 15 */
+};
+
+/***************************  ASSEMBLY CODE MACROS *************************/
+/*
+ * Put the error code here just in case the user cares.
+ * Likewise, the vector number here (since GDB only gets the signal
+ * number through the usual means, and that's not very specific).
+ * The called_from is the return address so he can tell how we entered kgdb.
+ * This will allow him to seperate out the various possible entries.
+ */
+#define REMOTE_DEBUG 0		/* set != to turn on printing (also available in info) */
+
+#define PID_MAX PID_MAX_DEFAULT
+
+#ifdef CONFIG_SMP
+void smp_send_nmi_allbutself(void);
+#define IF_SMP(x) x
+#undef MAX_NO_CPUS
+#ifndef CONFIG_NO_KGDB_CPUS
+#define CONFIG_NO_KGDB_CPUS 2
+#endif
+#if CONFIG_NO_KGDB_CPUS > NR_CPUS
+#define MAX_NO_CPUS NR_CPUS
+#else
+#define MAX_NO_CPUS CONFIG_NO_KGDB_CPUS
+#endif
+#define hold_init hold_on_sstep: 1,
+#define MAX_CPU_MASK (unsigned long)((1LL << MAX_NO_CPUS) - 1LL)
+#define NUM_CPUS num_online_cpus()
+#else
+#define IF_SMP(x)
+#define hold_init
+#undef MAX_NO_CPUS
+#define MAX_NO_CPUS 1
+#define NUM_CPUS 1
+#endif
+#define NOCPU (struct task_struct *)0xbad1fbad
+/* *INDENT-OFF*	 */
+struct kgdb_info {
+	int used_malloc;
+	void *called_from;
+	long long entry_tsc;
+	int errcode;
+	int vector;
+	int print_debug_info;
+#ifdef CONFIG_SMP
+	int hold_on_sstep;
+	struct {
+		volatile struct task_struct *task;
+		int pid;
+		int hold;
+		struct pt_regs *regs;
+	} cpus_waiting[MAX_NO_CPUS];
+#endif
+} kgdb_info = {hold_init print_debug_info:REMOTE_DEBUG, vector:-1};
+
+/* *INDENT-ON*	*/
+
+#define used_m kgdb_info.used_malloc
+/*
+ * This is little area we set aside to contain the stack we
+ * need to build to allow gdb to call functions.  We use one
+ * per cpu to avoid locking issues.  We will do all this work
+ * with interrupts off so that should take care of the protection
+ * issues.
+ */
+#define LOOKASIDE_SIZE 200	/* should be more than enough */
+#define MALLOC_MAX   200	/* Max malloc size */
+struct {
+	unsigned int esp;
+	int array[LOOKASIDE_SIZE];
+} fn_call_lookaside[MAX_NO_CPUS];
+
+static int trap_cpu;
+static unsigned int OLD_esp;
+
+#define END_OF_LOOKASIDE  &fn_call_lookaside[trap_cpu].array[LOOKASIDE_SIZE]
+#define IF_BIT 0x200
+#define TF_BIT 0x100
+
+#define MALLOC_ROUND 8-1
+
+static char malloc_array[MALLOC_MAX];
+IF_SMP(static void to_gdb(const char *mess));
+void *
+malloc(int size)
+{
+
+	if (size <= (MALLOC_MAX - used_m)) {
+		int old_used = used_m;
+		used_m += ((size + MALLOC_ROUND) & (~MALLOC_ROUND));
+		return &malloc_array[old_used];
+	} else {
+		return NULL;
+	}
+}
+
+/*
+ * I/O dispatch functions...
+ * Based upon kgdboe, either call the ethernet
+ * handler or the serial one..
+ */
+void
+putDebugChar(int c)
+{
+	if (!kgdboe) {
+		tty_putDebugChar(c);
+	} else {
+		eth_putDebugChar(c);
+	}
+}
+
+int
+getDebugChar(void)
+{
+	if (!kgdboe) {
+		return tty_getDebugChar();
+	} else {
+		return eth_getDebugChar();
+	}
+}
+
+void
+flushDebugChar(void)
+{
+	if (!kgdboe) {
+		tty_flushDebugChar();
+	} else {
+		eth_flushDebugChar();
+	}
+}
+
+/*
+ * Gdb calls functions by pushing agruments, including a return address
+ * on the stack and the adjusting EIP to point to the function.	 The
+ * whole assumption in GDB is that we are on a different stack than the
+ * one the "user" i.e. code that hit the break point, is on.  This, of
+ * course is not true in the kernel.  Thus various dodges are needed to
+ * do the call without directly messing with EIP (which we can not change
+ * as it is just a location and not a register.	 To adjust it would then
+ * require that we move every thing below EIP up or down as needed.  This
+ * will not work as we may well have stack relative pointer on the stack
+ * (such as the pointer to regs, for example).
+
+ * So here is what we do:
+ * We detect gdb attempting to store into the stack area and instead, store
+ * into the fn_call_lookaside.array at the same relative location as if it
+ * were the area ESP pointed at.  We also trap ESP modifications
+ * and uses these to adjust fn_call_lookaside.esp.  On entry
+ * fn_call_lookaside.esp will be set to point at the last entry in
+ * fn_call_lookaside.array.  This allows us to check if it has changed, and
+ * if so, on exit, we add the registers we will use to do the move and a
+ * trap/ interrupt return exit sequence.  We then adjust the eflags in the
+ * regs array (remember we now have a copy in the fn_call_lookaside.array) to
+ * kill the interrupt bit, AND we change EIP to point at our set up stub.
+ * As part of the register set up we preset the registers to point at the
+ * begining and end of the fn_call_lookaside.array, so all the stub needs to
+ * do is move words from the array to the stack until ESP= the desired value
+ * then do the rti.  This will then transfer to the desired function with
+ * all the correct registers.  Nifty huh?
+ */
+extern asmlinkage void fn_call_stub(void);
+extern asmlinkage void fn_rtn_stub(void);
+/*					   *INDENT-OFF*	 */
+__asm__("fn_rtn_stub:\n\t"
+	"movl %eax,%esp\n\t"
+	"fn_call_stub:\n\t"
+	"1:\n\t"
+	"addl $-4,%ebx\n\t"
+	"movl (%ebx), %eax\n\t"
+	"pushl %eax\n\t"
+	"cmpl %esp,%ecx\n\t"
+	"jne  1b\n\t"
+	"popl %eax\n\t"
+	"popl %ebx\n\t"
+	"popl %ecx\n\t"
+	"iret \n\t");
+/*					     *INDENT-ON*  */
+#define gdb_i386vector	kgdb_info.vector
+#define gdb_i386errcode kgdb_info.errcode
+#define waiting_cpus	kgdb_info.cpus_waiting
+#define remote_debug	kgdb_info.print_debug_info
+#define hold_cpu(cpu)	kgdb_info.cpus_waiting[cpu].hold
+/* gdb locks */
+
+#ifdef CONFIG_SMP
+static int in_kgdb_called;
+static spinlock_t waitlocks[MAX_NO_CPUS] =
+    {[0 ... MAX_NO_CPUS - 1] = SPIN_LOCK_UNLOCKED };
+/*
+ * The following array has the thread pointer of each of the "other"
+ * cpus.  We make it global so it can be seen by gdb.
+ */
+volatile int in_kgdb_entry_log[MAX_NO_CPUS];
+volatile struct pt_regs *in_kgdb_here_log[MAX_NO_CPUS];
+/*
+static spinlock_t continuelocks[MAX_NO_CPUS];
+*/
+spinlock_t kgdb_spinlock = SPIN_LOCK_UNLOCKED;
+/* waiters on our spinlock plus us */
+static atomic_t spinlock_waiters = ATOMIC_INIT(1);
+static int spinlock_count = 0;
+static int spinlock_cpu = 0;
+/*
+ * Note we use nested spin locks to account for the case where a break
+ * point is encountered when calling a function by user direction from
+ * kgdb. Also there is the memory exception recursion to account for.
+ * Well, yes, but this lets other cpus thru too.  Lets add a
+ * cpu id to the lock.
+ */
+#define KGDB_SPIN_LOCK(x) if( spinlock_count == 0 || \
+			      spinlock_cpu != smp_processor_id()){\
+				      atomic_inc(&spinlock_waiters); \
+				      while (! spin_trylock(x)) {\
+					    in_kgdb(&regs);\
+				      }\
+				      atomic_dec(&spinlock_waiters); \
+				      spinlock_count = 1; \
+				      spinlock_cpu = smp_processor_id(); \
+			  }else{  \
+				      spinlock_count++; \
+			  }
+#define KGDB_SPIN_UNLOCK(x) if( --spinlock_count == 0) spin_unlock(x)
+#else
+unsigned kgdb_spinlock = 0;
+#define KGDB_SPIN_LOCK(x) --*x
+#define KGDB_SPIN_UNLOCK(x) ++*x
+#endif
+
+int
+hex(char ch)
+{
+	if ((ch >= 'a') && (ch <= 'f'))
+		return (ch - 'a' + 10);
+	if ((ch >= '0') && (ch <= '9'))
+		return (ch - '0');
+	if ((ch >= 'A') && (ch <= 'F'))
+		return (ch - 'A' + 10);
+	return (-1);
+}
+
+/* scan for the sequence $<data>#<checksum>	*/
+void
+getpacket(char *buffer)
+{
+	unsigned char checksum;
+	unsigned char xmitcsum;
+	int i;
+	int count;
+	char ch;
+
+	do {
+		/* wait around for the start character, ignore all other characters */
+		while ((ch = (getDebugChar() & 0x7f)) != '$') ;
+		checksum = 0;
+		xmitcsum = -1;
+
+		count = 0;
+
+		/* now, read until a # or end of buffer is found */
+		while (count < BUFMAX) {
+			ch = getDebugChar() & 0x7f;
+			if (ch == '#')
+				break;
+			checksum = checksum + ch;
+			buffer[count] = ch;
+			count = count + 1;
+		}
+		buffer[count] = 0;
+
+		if (ch == '#') {
+			xmitcsum = hex(getDebugChar() & 0x7f) << 4;
+			xmitcsum += hex(getDebugChar() & 0x7f);
+			if ((remote_debug) && (checksum != xmitcsum)) {
+				printk
+				    ("bad checksum.	My count = 0x%x, sent=0x%x. buf=%s\n",
+				     checksum, xmitcsum, buffer);
+			}
+
+			if (checksum != xmitcsum)
+				putDebugChar('-');	/* failed checksum */
+			else {
+				putDebugChar('+');	/* successful transfer */
+				/* if a sequence char is present, reply the sequence ID */
+				if (buffer[2] == ':') {
+					putDebugChar(buffer[0]);
+					putDebugChar(buffer[1]);
+					/* remove sequence chars from buffer */
+					count = strlen(buffer);
+					for (i = 3; i <= count; i++)
+						buffer[i - 3] = buffer[i];
+				}
+			}
+		}
+	} while (checksum != xmitcsum);
+
+	if (remote_debug)
+		printk("R:%s\n", buffer);
+	flushDebugChar();
+}
+
+/* send the packet in buffer.  */
+
+void
+putpacket(char *buffer)
+{
+	unsigned char checksum;
+	int count;
+	char ch;
+
+	/*  $<packet info>#<checksum>. */
+
+	if (!kgdboe) {
+		do {
+			if (remote_debug)
+				printk("T:%s\n", buffer);
+			putDebugChar('$');
+			checksum = 0;
+			count = 0;
+
+			while ((ch = buffer[count])) {
+				putDebugChar(ch);
+				checksum += ch;
+				count += 1;
+			}
+
+			putDebugChar('#');
+			putDebugChar(hexchars[checksum >> 4]);
+			putDebugChar(hexchars[checksum % 16]);
+			flushDebugChar();
+
+		} while ((getDebugChar() & 0x7f) != '+');
+	} else {
+		/*
+		 * For udp, we can not transfer too much bytes once.
+		 * We only transfer MAX_SEND_COUNT size bytes each time
+		 */
+
+#define MAX_SEND_COUNT 30
+
+		int send_count = 0, i = 0;
+		char send_buf[MAX_SEND_COUNT];
+
+		do {
+			if (remote_debug)
+				printk("T:%s\n", buffer);
+			putDebugChar('$');
+			checksum = 0;
+			count = 0;
+			send_count = 0;
+			while ((ch = buffer[count])) {
+				if (send_count >= MAX_SEND_COUNT) {
+					for(i = 0; i < MAX_SEND_COUNT; i++) {
+						putDebugChar(send_buf[i]);
+					}
+					flushDebugChar();
+					send_count = 0;
+				} else {
+					send_buf[send_count] = ch;
+					checksum += ch;
+					count ++;
+					send_count++;
+				}
+			}
+			for(i = 0; i < send_count; i++)
+				putDebugChar(send_buf[i]);
+			putDebugChar('#');
+			putDebugChar(hexchars[checksum >> 4]);
+			putDebugChar(hexchars[checksum % 16]);
+			flushDebugChar();
+		} while ((getDebugChar() & 0x7f) != '+');
+	}
+}
+
+static char remcomInBuffer[BUFMAX];
+static char remcomOutBuffer[BUFMAX];
+static short error;
+
+void
+debug_error(char *format, char *parm)
+{
+	if (remote_debug)
+		printk(format, parm);
+}
+
+static void
+print_regs(struct pt_regs *regs)
+{
+	printk("EAX=%08lx ", regs->eax);
+	printk("EBX=%08lx ", regs->ebx);
+	printk("ECX=%08lx ", regs->ecx);
+	printk("EDX=%08lx ", regs->edx);
+	printk("\n");
+	printk("ESI=%08lx ", regs->esi);
+	printk("EDI=%08lx ", regs->edi);
+	printk("EBP=%08lx ", regs->ebp);
+	printk("ESP=%08lx ", (long) &regs->esp);
+	printk("\n");
+	printk(" DS=%08x ", regs->xds);
+	printk(" ES=%08x ", regs->xes);
+	printk(" SS=%08x ", __KERNEL_DS);
+	printk(" FL=%08lx ", regs->eflags);
+	printk("\n");
+	printk(" CS=%08x ", regs->xcs);
+	printk(" IP=%08lx ", regs->eip);
+#if 0
+	printk(" FS=%08x ", regs->fs);
+	printk(" GS=%08x ", regs->gs);
+#endif
+	printk("\n");
+
+}				/* print_regs */
+
+#define NEW_esp fn_call_lookaside[trap_cpu].esp
+
+static void
+regs_to_gdb_regs(int *gdb_regs, struct pt_regs *regs)
+{
+	gdb_regs[_EAX] = regs->eax;
+	gdb_regs[_EBX] = regs->ebx;
+	gdb_regs[_ECX] = regs->ecx;
+	gdb_regs[_EDX] = regs->edx;
+	gdb_regs[_ESI] = regs->esi;
+	gdb_regs[_EDI] = regs->edi;
+	gdb_regs[_EBP] = regs->ebp;
+	gdb_regs[_DS] = regs->xds;
+	gdb_regs[_ES] = regs->xes;
+	gdb_regs[_PS] = regs->eflags;
+	gdb_regs[_CS] = regs->xcs;
+	gdb_regs[_PC] = regs->eip;
+	/* Note, as we are a debugging the kernel, we will always
+	 * trap in kernel code, this means no priviledge change,
+	 * and so the pt_regs structure is not completely valid.  In a non
+	 * privilege change trap, only EFLAGS, CS and EIP are put on the stack,
+	 * SS and ESP are not stacked, this means that the last 2 elements of
+	 * pt_regs is not valid (they would normally refer to the user stack)
+	 * also, using regs+1 is no good because you end up will a value that is
+	 * 2 longs (8) too high.  This used to cause stepping over functions
+	 * to fail, so my fix is to use the address of regs->esp, which
+	 * should point at the end of the stack frame.	Note I have ignored
+	 * completely exceptions that cause an error code to be stacked, such
+	 * as double fault.  Stuart Hughes, Zentropix.
+	 * original code: gdb_regs[_ESP] =  (int) (regs + 1) ;
+
+	 * this is now done on entry and moved to OLD_esp (as well as NEW_esp).
+	 */
+	gdb_regs[_ESP] = NEW_esp;
+	gdb_regs[_SS] = __KERNEL_DS;
+	gdb_regs[_FS] = 0xFFFF;
+	gdb_regs[_GS] = 0xFFFF;
+}				/* regs_to_gdb_regs */
+
+static void
+gdb_regs_to_regs(int *gdb_regs, struct pt_regs *regs)
+{
+	regs->eax = gdb_regs[_EAX];
+	regs->ebx = gdb_regs[_EBX];
+	regs->ecx = gdb_regs[_ECX];
+	regs->edx = gdb_regs[_EDX];
+	regs->esi = gdb_regs[_ESI];
+	regs->edi = gdb_regs[_EDI];
+	regs->ebp = gdb_regs[_EBP];
+	regs->xds = gdb_regs[_DS];
+	regs->xes = gdb_regs[_ES];
+	regs->eflags = gdb_regs[_PS];
+	regs->xcs = gdb_regs[_CS];
+	regs->eip = gdb_regs[_PC];
+	NEW_esp = gdb_regs[_ESP];	/* keep the value */
+#if 0				/* can't change these */
+	regs->esp = gdb_regs[_ESP];
+	regs->xss = gdb_regs[_SS];
+	regs->fs = gdb_regs[_FS];
+	regs->gs = gdb_regs[_GS];
+#endif
+
+}				/* gdb_regs_to_regs */
+
+int thread_list = 0;
+
+void
+get_gdb_regs(struct task_struct *p, struct pt_regs *regs, int *gdb_regs)
+{
+	unsigned long stack_page;
+	int count = 0;
+	IF_SMP(int i);
+	if (!p || p == current) {
+		regs_to_gdb_regs(gdb_regs, regs);
+		return;
+	}
+#ifdef CONFIG_SMP
+	for (i = 0; i < MAX_NO_CPUS; i++) {
+		if (p == kgdb_info.cpus_waiting[i].task) {
+			regs_to_gdb_regs(gdb_regs,
+					 kgdb_info.cpus_waiting[i].regs);
+			gdb_regs[_ESP] =
+			    (int) &kgdb_info.cpus_waiting[i].regs->esp;
+
+			return;
+		}
+	}
+#endif
+	memset(gdb_regs, 0, NUMREGBYTES);
+	gdb_regs[_ESP] = p->thread.esp;
+	gdb_regs[_PC] = p->thread.eip;
+	gdb_regs[_EBP] = *(int *) gdb_regs[_ESP];
+	gdb_regs[_EDI] = *(int *) (gdb_regs[_ESP] + 4);
+	gdb_regs[_ESI] = *(int *) (gdb_regs[_ESP] + 8);
+
+/*
+ * This code is to give a more informative notion of where a process
+ * is waiting.	It is used only when the user asks for a thread info
+ * list.  If he then switches to the thread, s/he will find the task
+ * is in schedule, but a back trace should show the same info we come
+ * up with.  This code was shamelessly purloined from process.c.  It was
+ * then enhanced to provide more registers than simply the program
+ * counter.
+ */
+
+	if (!thread_list) {
+		return;
+	}
+
+	if (p->state == TASK_RUNNING)
+		return;
+	stack_page = (unsigned long) p->thread_info;
+	if (gdb_regs[_ESP] < stack_page || gdb_regs[_ESP] >
+	    THREAD_SIZE - sizeof(long) + stack_page)
+		return;
+	/* include/asm-i386/system.h:switch_to() pushes ebp last. */
+	do {
+		if (gdb_regs[_EBP] < stack_page ||
+		    gdb_regs[_EBP] > THREAD_SIZE - 2*sizeof(long) + stack_page)
+			return;
+		gdb_regs[_PC] = *(unsigned long *) (gdb_regs[_EBP] + 4);
+		gdb_regs[_ESP] = gdb_regs[_EBP] + 8;
+		gdb_regs[_EBP] = *(unsigned long *) gdb_regs[_EBP];
+		if (!in_sched_functions(gdb_regs[_PC]))
+			return;
+	} while (count++ < 16);
+	return;
+}
+
+/* Indicate to caller of mem2hex or hex2mem that there has been an
+   error.  */
+static volatile int mem_err = 0;
+static volatile int mem_err_expected = 0;
+static volatile int mem_err_cnt = 0;
+static int garbage_loc = -1;
+
+int
+get_char(char *addr)
+{
+	return *addr;
+}
+
+void
+set_char(char *addr, int val, int may_fault)
+{
+	/*
+	 * This code traps references to the area mapped to the kernel
+	 * stack as given by the regs and, instead, stores to the
+	 * fn_call_lookaside[cpu].array
+	 */
+	if (may_fault &&
+	    (unsigned int) addr < OLD_esp &&
+	    ((unsigned int) addr > (OLD_esp - (unsigned int) LOOKASIDE_SIZE))) {
+		addr = (char *) END_OF_LOOKASIDE - ((char *) OLD_esp - addr);
+	}
+	*addr = val;
+}
+
+/* convert the memory pointed to by mem into hex, placing result in buf */
+/* return a pointer to the last char put in buf (null) */
+/* If MAY_FAULT is non-zero, then we should set mem_err in response to
+   a fault; if zero treat a fault like any other fault in the stub.  */
+char *
+mem2hex(char *mem, char *buf, int count, int may_fault)
+{
+	int i;
+	unsigned char ch;
+
+	if (may_fault) {
+		mem_err_expected = 1;
+		mem_err = 0;
+	}
+	for (i = 0; i < count; i++) {
+		/* printk("%lx = ", mem) ; */
+
+		ch = get_char(mem++);
+
+		/* printk("%02x\n", ch & 0xFF) ; */
+		if (may_fault && mem_err) {
+			if (remote_debug)
+				printk("Mem fault fetching from addr %lx\n",
+				       (long) (mem - 1));
+			*buf = 0;	/* truncate buffer */
+			return (buf);
+		}
+		*buf++ = hexchars[ch >> 4];
+		*buf++ = hexchars[ch % 16];
+	}
+	*buf = 0;
+	if (may_fault)
+		mem_err_expected = 0;
+	return (buf);
+}
+
+/* convert the hex array pointed to by buf into binary to be placed in mem */
+/* return a pointer to the character AFTER the last byte written */
+/* NOTE: We use the may fault flag to also indicate if the write is to
+ * the registers (0) or "other" memory (!=0)
+ */
+char *
+hex2mem(char *buf, char *mem, int count, int may_fault)
+{
+	int i;
+	unsigned char ch;
+
+	if (may_fault) {
+		mem_err_expected = 1;
+		mem_err = 0;
+	}
+	for (i = 0; i < count; i++) {
+		ch = hex(*buf++) << 4;
+		ch = ch + hex(*buf++);
+		set_char(mem++, ch, may_fault);
+
+		if (may_fault && mem_err) {
+			if (remote_debug)
+				printk("Mem fault storing to addr %lx\n",
+				       (long) (mem - 1));
+			return (mem);
+		}
+	}
+	if (may_fault)
+		mem_err_expected = 0;
+	return (mem);
+}
+
+/**********************************************/
+/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
+/* RETURN NUMBER OF CHARS PROCESSED	      */
+/**********************************************/
+int
+hexToInt(char **ptr, int *intValue)
+{
+	int numChars = 0;
+	int hexValue;
+
+	*intValue = 0;
+
+	while (**ptr) {
+		hexValue = hex(**ptr);
+		if (hexValue >= 0) {
+			*intValue = (*intValue << 4) | hexValue;
+			numChars++;
+		} else
+			break;
+
+		(*ptr)++;
+	}
+
+	return (numChars);
+}
+
+#define stubhex(h) hex(h)
+#ifdef old_thread_list
+
+static int
+stub_unpack_int(char *buff, int fieldlength)
+{
+	int nibble;
+	int retval = 0;
+
+	while (fieldlength) {
+		nibble = stubhex(*buff++);
+		retval |= nibble;
+		fieldlength--;
+		if (fieldlength)
+			retval = retval << 4;
+	}
+	return retval;
+}
+#endif
+static char *
+pack_hex_byte(char *pkt, int byte)
+{
+	*pkt++ = hexchars[(byte >> 4) & 0xf];
+	*pkt++ = hexchars[(byte & 0xf)];
+	return pkt;
+}
+
+#define BUF_THREAD_ID_SIZE 16
+
+static char *
+pack_threadid(char *pkt, threadref * id)
+{
+	char *limit;
+	unsigned char *altid;
+
+	altid = (unsigned char *) id;
+	limit = pkt + BUF_THREAD_ID_SIZE;
+	while (pkt < limit)
+		pkt = pack_hex_byte(pkt, *altid++);
+	return pkt;
+}
+
+#ifdef old_thread_list
+static char *
+unpack_byte(char *buf, int *value)
+{
+	*value = stub_unpack_int(buf, 2);
+	return buf + 2;
+}
+
+static char *
+unpack_threadid(char *inbuf, threadref * id)
+{
+	char *altref;
+	char *limit = inbuf + BUF_THREAD_ID_SIZE;
+	int x, y;
+
+	altref = (char *) id;
+
+	while (inbuf < limit) {
+		x = stubhex(*inbuf++);
+		y = stubhex(*inbuf++);
+		*altref++ = (x << 4) | y;
+	}
+	return inbuf;
+}
+#endif
+void
+int_to_threadref(threadref * id, int value)
+{
+	unsigned char *scan;
+
+	scan = (unsigned char *) id;
+	{
+		int i = 4;
+		while (i--)
+			*scan++ = 0;
+	}
+	*scan++ = (value >> 24) & 0xff;
+	*scan++ = (value >> 16) & 0xff;
+	*scan++ = (value >> 8) & 0xff;
+	*scan++ = (value & 0xff);
+}
+int
+int_to_hex_v(unsigned char * id, int value)
+{
+	unsigned char *start = id;
+	int shift;
+	int ch;
+
+	for (shift = 28; shift >= 0; shift -= 4) {
+		if ((ch = (value >> shift) & 0xf) || (id != start)) {
+			*id = hexchars[ch];
+			id++;
+		}
+	}
+	if (id == start)
+		*id++ = '0';
+	return id - start;
+}
+#ifdef old_thread_list
+
+static int
+threadref_to_int(threadref * ref)
+{
+	int i, value = 0;
+	unsigned char *scan;
+
+	scan = (char *) ref;
+	scan += 4;
+	i = 4;
+	while (i-- > 0)
+		value = (value << 8) | ((*scan++) & 0xff);
+	return value;
+}
+#endif
+static int
+cmp_str(char *s1, char *s2, int count)
+{
+	while (count--) {
+		if (*s1++ != *s2++)
+			return 0;
+	}
+	return 1;
+}
+
+#if 1				/* this is a hold over from 2.4 where O(1) was "sometimes" */
+extern struct task_struct *kgdb_get_idle(int cpu);
+#define idle_task(cpu) kgdb_get_idle(cpu)
+#else
+#define idle_task(cpu) init_tasks[cpu]
+#endif
+
+extern int kgdb_pid_init_done;
+
+struct task_struct *
+getthread(int pid)
+{
+	struct task_struct *thread;
+	if (pid >= PID_MAX && pid <= (PID_MAX + MAX_NO_CPUS)) {
+
+		return idle_task(pid - PID_MAX);
+	} else {
+		/*
+		 * find_task_by_pid is relatively safe all the time
+		 * Other pid functions require lock downs which imply
+		 * that we may be interrupting them (as we get here
+		 * in the middle of most any lock down).
+		 * Still we don't want to call until the table exists!
+		 */
+		if (kgdb_pid_init_done){
+			thread = find_task_by_pid(pid);
+			if (thread) {
+				return thread;
+			}
+		}
+	}
+	return NULL;
+}
+/* *INDENT-OFF*	 */
+struct hw_breakpoint {
+	unsigned enabled;
+	unsigned type;
+	unsigned len;
+	unsigned addr;
+} breakinfo[4] = { {enabled:0},
+		   {enabled:0},
+		   {enabled:0},
+		   {enabled:0}};
+/* *INDENT-ON*	*/
+unsigned hw_breakpoint_status;
+void
+correct_hw_break(void)
+{
+	int breakno;
+	int correctit;
+	int breakbit;
+	unsigned dr7;
+
+	asm volatile ("movl %%db7, %0\n":"=r" (dr7)
+		      :);
+	/* *INDENT-OFF*	 */
+	do {
+		unsigned addr0, addr1, addr2, addr3;
+		asm volatile ("movl %%db0, %0\n"
+			      "movl %%db1, %1\n"
+			      "movl %%db2, %2\n"
+			      "movl %%db3, %3\n"
+			      :"=r" (addr0), "=r"(addr1),
+			      "=r"(addr2), "=r"(addr3)
+			      :);
+	} while (0);
+	/* *INDENT-ON*	*/
+	correctit = 0;
+	for (breakno = 0; breakno < 3; breakno++) {
+		breakbit = 2 << (breakno << 1);
+		if (!(dr7 & breakbit) && breakinfo[breakno].enabled) {
+			correctit = 1;
+			dr7 |= breakbit;
+			dr7 &= ~(0xf0000 << (breakno << 2));
+			dr7 |= (((breakinfo[breakno].len << 2) |
+				 breakinfo[breakno].type) << 16) <<
+			    (breakno << 2);
+			switch (breakno) {
+			case 0:
+				asm volatile ("movl %0, %%dr0\n"::"r"
+					      (breakinfo[breakno].addr));
+				break;
+
+			case 1:
+				asm volatile ("movl %0, %%dr1\n"::"r"
+					      (breakinfo[breakno].addr));
+				break;
+
+			case 2:
+				asm volatile ("movl %0, %%dr2\n"::"r"
+					      (breakinfo[breakno].addr));
+				break;
+
+			case 3:
+				asm volatile ("movl %0, %%dr3\n"::"r"
+					      (breakinfo[breakno].addr));
+				break;
+			}
+		} else if ((dr7 & breakbit) && !breakinfo[breakno].enabled) {
+			correctit = 1;
+			dr7 &= ~breakbit;
+			dr7 &= ~(0xf0000 << (breakno << 2));
+		}
+	}
+	if (correctit) {
+		asm volatile ("movl %0, %%db7\n"::"r" (dr7));
+	}
+}
+
+int
+remove_hw_break(unsigned breakno)
+{
+	if (!breakinfo[breakno].enabled) {
+		return -1;
+	}
+	breakinfo[breakno].enabled = 0;
+	return 0;
+}
+
+int
+set_hw_break(unsigned breakno, unsigned type, unsigned len, unsigned addr)
+{
+	if (breakinfo[breakno].enabled) {
+		return -1;
+	}
+	breakinfo[breakno].enabled = 1;
+	breakinfo[breakno].type = type;
+	breakinfo[breakno].len = len;
+	breakinfo[breakno].addr = addr;
+	return 0;
+}
+
+#ifdef CONFIG_SMP
+static int in_kgdb_console = 0;
+
+int
+in_kgdb(struct pt_regs *regs)
+{
+	unsigned flags;
+	int cpu = smp_processor_id();
+	in_kgdb_called = 1;
+	if (!spin_is_locked(&kgdb_spinlock)) {
+		if (in_kgdb_here_log[cpu] ||	/* we are holding this cpu */
+		    in_kgdb_console) {	/* or we are doing slow i/o */
+			return 1;
+		}
+		return 0;
+	}
+
+	/* As I see it the only reason not to let all cpus spin on
+	 * the same spin_lock is to allow selected ones to proceed.
+	 * This would be a good thing, so we leave it this way.
+	 * Maybe someday....  Done !
+
+	 * in_kgdb() is called from an NMI so we don't pretend
+	 * to have any resources, like printk() for example.
+	 */
+
+	kgdb_local_irq_save(flags);	/* only local here, to avoid hanging */
+	/*
+	 * log arival of this cpu
+	 * The NMI keeps on ticking.  Protect against recurring more
+	 * than once, and ignor the cpu that has the kgdb lock
+	 */
+	in_kgdb_entry_log[cpu]++;
+	in_kgdb_here_log[cpu] = regs;
+	if (cpu == spinlock_cpu || waiting_cpus[cpu].task)
+		goto exit_in_kgdb;
+
+	/*
+	 * For protection of the initilization of the spin locks by kgdb
+	 * it locks the kgdb spinlock before it gets the wait locks set
+	 * up.	We wait here for the wait lock to be taken.  If the
+	 * kgdb lock goes away first??	Well, it could be a slow exit
+	 * sequence where the wait lock is removed prior to the kgdb lock
+	 * so if kgdb gets unlocked, we just exit.
+	 */
+
+	while (spin_is_locked(&kgdb_spinlock) &&
+	       !spin_is_locked(waitlocks + cpu)) ;
+	if (!spin_is_locked(&kgdb_spinlock))
+		goto exit_in_kgdb;
+
+	waiting_cpus[cpu].task = current;
+	waiting_cpus[cpu].pid = (current->pid) ? : (PID_MAX + cpu);
+	waiting_cpus[cpu].regs = regs;
+
+	spin_unlock_wait(waitlocks + cpu);
+
+	/*
+	 * log departure of this cpu
+	 */
+	waiting_cpus[cpu].task = 0;
+	waiting_cpus[cpu].pid = 0;
+	waiting_cpus[cpu].regs = 0;
+	correct_hw_break();
+      exit_in_kgdb:
+	in_kgdb_here_log[cpu] = 0;
+	kgdb_local_irq_restore(flags);
+	return 1;
+	/*
+	   spin_unlock(continuelocks + smp_processor_id());
+	 */
+}
+
+void
+smp__in_kgdb(struct pt_regs regs)
+{
+	ack_APIC_irq();
+	in_kgdb(&regs);
+}
+#else
+int
+in_kgdb(struct pt_regs *regs)
+{
+	return (kgdb_spinlock);
+}
+#endif
+
+void
+printexceptioninfo(int exceptionNo, int errorcode, char *buffer)
+{
+	unsigned dr6;
+	int i;
+	switch (exceptionNo) {
+	case 1:		/* debug exception */
+		break;
+	case 3:		/* breakpoint */
+		sprintf(buffer, "Software breakpoint");
+		return;
+	default:
+		sprintf(buffer, "Details not available");
+		return;
+	}
+	asm volatile ("movl %%db6, %0\n":"=r" (dr6)
+		      :);
+	if (dr6 & 0x4000) {
+		sprintf(buffer, "Single step");
+		return;
+	}
+	for (i = 0; i < 4; ++i) {
+		if (dr6 & (1 << i)) {
+			sprintf(buffer, "Hardware breakpoint %d", i);
+			return;
+		}
+	}
+	sprintf(buffer, "Unknown trap");
+	return;
+}
+
+/*
+ * This function does all command procesing for interfacing to gdb.
+ *
+ * NOTE:  The INT nn instruction leaves the state of the interrupt
+ *	  enable flag UNCHANGED.  That means that when this routine
+ *	  is entered via a breakpoint (INT 3) instruction from code
+ *	  that has interrupts enabled, then interrupts will STILL BE
+ *	  enabled when this routine is entered.	 The first thing that
+ *	  we do here is disable interrupts so as to prevent recursive
+ *	  entries and bothersome serial interrupts while we are
+ *	  trying to run the serial port in polled mode.
+ *
+ * For kernel version 2.1.xx the kgdb_cli() actually gets a spin lock so
+ * it is always necessary to do a restore_flags before returning
+ * so as to let go of that lock.
+ */
+int
+kgdb_handle_exception(int exceptionVector,
+		      int signo, int err_code, struct pt_regs *linux_regs)
+{
+	struct task_struct *usethread = NULL;
+	struct task_struct *thread_list_start = 0, *thread = NULL;
+	int addr, length;
+	int breakno, breaktype;
+	char *ptr;
+	int newPC;
+	threadref thref;
+	int threadid;
+	int thread_min = PID_MAX + MAX_NO_CPUS;
+#ifdef old_thread_list
+	int maxthreads;
+#endif
+	int nothreads;
+	unsigned long flags;
+	int gdb_regs[NUMREGBYTES / 4];
+	int dr6;
+	IF_SMP(int entry_state = 0);	/* 0, ok, 1, no nmi, 2 sync failed */
+#define NO_NMI 1
+#define NO_SYNC 2
+#define	regs	(*linux_regs)
+#define NUMREGS NUMREGBYTES/4
+	/*
+	 * If the entry is not from the kernel then return to the Linux
+	 * trap handler and let it process the interrupt normally.
+	 */
+	if ((linux_regs->eflags & VM_MASK) || (3 & linux_regs->xcs)) {
+		printk("ignoring non-kernel exception\n");
+		print_regs(&regs);
+		return (0);
+	}
+	/*
+	 * If we're using eth mode, set the 'mode' in the netdevice.
+	 */
+
+	if (kgdboe)
+		netpoll_set_trap(1);
+
+	kgdb_local_irq_save(flags);
+
+	/* Get kgdb spinlock */
+
+	KGDB_SPIN_LOCK(&kgdb_spinlock);
+	rdtscll(kgdb_info.entry_tsc);
+	/*
+	 * We depend on this spinlock and the NMI watch dog to control the
+	 * other cpus.	They will arrive at "in_kgdb()" as a result of the
+	 * NMI and will wait there for the following spin locks to be
+	 * released.
+	 */
+#ifdef CONFIG_SMP
+
+#if 0
+	if (cpu_callout_map & ~MAX_CPU_MASK) {
+		printk("kgdb : too many cpus, possibly not mapped"
+		       " in contiguous space, change MAX_NO_CPUS"
+		       " in kgdb_stub and make new kernel.\n"
+		       " cpu_callout_map is %lx\n", cpu_callout_map);
+		goto exit_just_unlock;
+	}
+#endif
+	if (spinlock_count == 1) {
+		int time = 0, end_time, dum = 0;
+		int i;
+		int cpu_logged_in[MAX_NO_CPUS] = {[0 ... MAX_NO_CPUS - 1] = (0)
+		};
+		if (remote_debug) {
+			printk("kgdb : cpu %d entry, syncing others\n",
+			       smp_processor_id());
+		}
+		for (i = 0; i < MAX_NO_CPUS; i++) {
+			/*
+			 * Use trylock as we may already hold the lock if
+			 * we are holding the cpu.  Net result is all
+			 * locked.
+			 */
+			spin_trylock(&waitlocks[i]);
+		}
+		for (i = 0; i < MAX_NO_CPUS; i++)
+			cpu_logged_in[i] = 0;
+		/*
+		 * Wait for their arrival.  We know the watch dog is active if
+		 * in_kgdb() has ever been called, as it is always called on a
+		 * watchdog tick.
+		 */
+		rdtsc(dum, time);
+		end_time = time + 2;	/* Note: we use the High order bits! */
+		i = 1;
+		if (num_online_cpus() > 1) {
+			int me_in_kgdb = in_kgdb_entry_log[smp_processor_id()];
+			smp_send_nmi_allbutself();
+
+			while (i < num_online_cpus() && time != end_time) {
+				int j;
+				for (j = 0; j < MAX_NO_CPUS; j++) {
+					if (waiting_cpus[j].task &&
+					    waiting_cpus[j].task != NOCPU &&
+					    !cpu_logged_in[j]) {
+						i++;
+						cpu_logged_in[j] = 1;
+						if (remote_debug) {
+							printk
+							    ("kgdb : cpu %d arrived at kgdb\n",
+							     j);
+						}
+						break;
+					} else if (!waiting_cpus[j].task &&
+						   !cpu_online(j)) {
+						waiting_cpus[j].task = NOCPU;
+						cpu_logged_in[j] = 1;
+						waiting_cpus[j].hold = 1;
+						break;
+					}
+					if (!waiting_cpus[j].task &&
+					    in_kgdb_here_log[j]) {
+
+						int wait = 100000;
+						while (wait--) ;
+						if (!waiting_cpus[j].task &&
+						    in_kgdb_here_log[j]) {
+							printk
+							    ("kgdb : cpu %d stall"
+							     " in in_kgdb\n",
+							     j);
+							i++;
+							cpu_logged_in[j] = 1;
+							waiting_cpus[j].task =
+							    (struct task_struct
+							     *) 1;
+						}
+					}
+				}
+
+				if (in_kgdb_entry_log[smp_processor_id()] >
+				    (me_in_kgdb + 10)) {
+					break;
+				}
+
+				rdtsc(dum, time);
+			}
+			if (i < num_online_cpus()) {
+				printk
+				    ("kgdb : time out, proceeding without sync\n");
+#if 0
+				printk("kgdb : Waiting_cpus: 0 = %d, 1 = %d\n",
+				       waiting_cpus[0].task != 0,
+				       waiting_cpus[1].task != 0);
+				printk("kgdb : Cpu_logged in: 0 = %d, 1 = %d\n",
+				       cpu_logged_in[0], cpu_logged_in[1]);
+				printk
+				    ("kgdb : in_kgdb_here_log in: 0 = %d, 1 = %d\n",
+				     in_kgdb_here_log[0] != 0,
+				     in_kgdb_here_log[1] != 0);
+#endif
+				entry_state = NO_SYNC;
+			} else {
+#if 0
+				int ent =
+				    in_kgdb_entry_log[smp_processor_id()] -
+				    me_in_kgdb;
+				printk("kgdb : sync after %d entries\n", ent);
+#endif
+			}
+		} else {
+			if (remote_debug) {
+				printk
+				    ("kgdb : %d cpus, but watchdog not active\n"
+				     "proceeding without locking down other cpus\n",
+				     num_online_cpus());
+				entry_state = NO_NMI;
+			}
+		}
+	}
+#endif
+
+	if (remote_debug) {
+		unsigned long *lp = (unsigned long *) &linux_regs;
+
+		printk("handle_exception(exceptionVector=%d, "
+		       "signo=%d, err_code=%d, linux_regs=%p)\n",
+		       exceptionVector, signo, err_code, linux_regs);
+		if (debug_regs) {
+			print_regs(&regs);
+			printk("Stk: %8lx %8lx %8lx %8lx"
+			       "  %8lx %8lx %8lx %8lx\n",
+			       lp[0], lp[1], lp[2], lp[3],
+			       lp[4], lp[5], lp[6], lp[7]);
+			printk("     %8lx %8lx %8lx %8lx"
+			       "  %8lx %8lx %8lx %8lx\n",
+			       lp[8], lp[9], lp[10], lp[11],
+			       lp[12], lp[13], lp[14], lp[15]);
+			printk("     %8lx %8lx %8lx %8lx  "
+			       "%8lx %8lx %8lx %8lx\n",
+			       lp[16], lp[17], lp[18], lp[19],
+			       lp[20], lp[21], lp[22], lp[23]);
+			printk("     %8lx %8lx %8lx %8lx  "
+			       "%8lx %8lx %8lx %8lx\n",
+			       lp[24], lp[25], lp[26], lp[27],
+			       lp[28], lp[29], lp[30], lp[31]);
+		}
+	}
+
+	/* Disable hardware debugging while we are in kgdb */
+	/* Get the debug register status register */
+/*				       *INDENT-OFF*  */
+      __asm__("movl %0,%%db7"
+	      :	/* no output */
+	      :"r"(0));
+
+	asm volatile ("movl %%db6, %0\n"
+		      :"=r" (hw_breakpoint_status)
+		      :);
+
+/*				       *INDENT-ON*  */
+	switch (exceptionVector) {
+	case 0:		/* divide error */
+	case 1:		/* debug exception */
+	case 2:		/* NMI */
+	case 3:		/* breakpoint */
+	case 4:		/* overflow */
+	case 5:		/* bounds check */
+	case 6:		/* invalid opcode */
+	case 7:		/* device not available */
+	case 8:		/* double fault (errcode) */
+	case 10:		/* invalid TSS (errcode) */
+	case 12:		/* stack fault (errcode) */
+	case 16:		/* floating point error */
+	case 17:		/* alignment check (errcode) */
+	default:		/* any undocumented */
+		break;
+	case 11:		/* segment not present (errcode) */
+	case 13:		/* general protection (errcode) */
+	case 14:		/* page fault (special errcode) */
+	case 19:		/* cache flush denied */
+		if (mem_err_expected) {
+			/*
+			 * This fault occured because of the
+			 * get_char or set_char routines.  These
+			 * two routines use either eax of edx to
+			 * indirectly reference the location in
+			 * memory that they are working with.
+			 * For a page fault, when we return the
+			 * instruction will be retried, so we
+			 * have to make sure that these
+			 * registers point to valid memory.
+			 */
+			mem_err = 1;	/* set mem error flag */
+			mem_err_expected = 0;
+			mem_err_cnt++;	/* helps in debugging */
+			/* make valid address */
+			regs.eax = (long) &garbage_loc;
+			/* make valid address */
+			regs.edx = (long) &garbage_loc;
+			if (remote_debug)
+				printk("Return after memory error: "
+				       "mem_err_cnt=%d\n", mem_err_cnt);
+			if (debug_regs)
+				print_regs(&regs);
+			goto exit_kgdb;
+		}
+		break;
+	}
+	if (remote_debug)
+		printk("kgdb : entered kgdb on cpu %d\n", smp_processor_id());
+
+	gdb_i386vector = exceptionVector;
+	gdb_i386errcode = err_code;
+	kgdb_info.called_from = __builtin_return_address(0);
+#ifdef CONFIG_SMP
+	/*
+	 * OK, we can now communicate, lets tell gdb about the sync.
+	 * but only if we had a problem.
+	 */
+	switch (entry_state) {
+	case NO_NMI:
+		to_gdb("NMI not active, other cpus not stopped\n");
+		break;
+	case NO_SYNC:
+		to_gdb("Some cpus not stopped, see 'kgdb_info' for details\n");
+	default:;
+	}
+
+#endif
+/*
+ * Set up the gdb function call area.
+ */
+	trap_cpu = smp_processor_id();
+	OLD_esp = NEW_esp = (int) (&linux_regs->esp);
+
+      IF_SMP(once_again:)
+	    /* reply to host that an exception has occurred */
+	    remcomOutBuffer[0] = 'S';
+	remcomOutBuffer[1] = hexchars[signo >> 4];
+	remcomOutBuffer[2] = hexchars[signo % 16];
+	remcomOutBuffer[3] = 0;
+
+	putpacket(remcomOutBuffer);
+
+	while (1 == 1) {
+		error = 0;
+		remcomOutBuffer[0] = 0;
+		getpacket(remcomInBuffer);
+		switch (remcomInBuffer[0]) {
+		case '?':
+			remcomOutBuffer[0] = 'S';
+			remcomOutBuffer[1] = hexchars[signo >> 4];
+			remcomOutBuffer[2] = hexchars[signo % 16];
+			remcomOutBuffer[3] = 0;
+			break;
+		case 'd':
+			remote_debug = !(remote_debug);	/* toggle debug flag */
+			printk("Remote debug %s\n",
+			       remote_debug ? "on" : "off");
+			break;
+		case 'g':	/* return the value of the CPU registers */
+			get_gdb_regs(usethread, &regs, gdb_regs);
+			mem2hex((char *) gdb_regs,
+				remcomOutBuffer, NUMREGBYTES, 0);
+			break;
+		case 'G':	/* set the value of the CPU registers - return OK */
+			hex2mem(&remcomInBuffer[1],
+				(char *) gdb_regs, NUMREGBYTES, 0);
+			if (!usethread || usethread == current) {
+				gdb_regs_to_regs(gdb_regs, &regs);
+				strcpy(remcomOutBuffer, "OK");
+			} else {
+				strcpy(remcomOutBuffer, "E00");
+			}
+			break;
+
+		case 'P':{	/* set the value of a single CPU register -
+				   return OK */
+				/*
+				 * For some reason, gdb wants to talk about psudo
+				 * registers (greater than 15).	 These may have
+				 * meaning for ptrace, but for us it is safe to
+				 * ignor them.	We do this by dumping them into
+				 * _GS which we also ignor, but do have memory for.
+				 */
+				int regno;
+
+				ptr = &remcomInBuffer[1];
+				regs_to_gdb_regs(gdb_regs, &regs);
+				if ((!usethread || usethread == current) &&
+				    hexToInt(&ptr, &regno) &&
+				    *ptr++ == '=' && (regno >= 0)) {
+					regno =
+					    (regno >= NUMREGS ? _GS : regno);
+					hex2mem(ptr, (char *) &gdb_regs[regno],
+						4, 0);
+					gdb_regs_to_regs(gdb_regs, &regs);
+					strcpy(remcomOutBuffer, "OK");
+					break;
+				}
+				strcpy(remcomOutBuffer, "E01");
+				break;
+			}
+
+			/* mAA..AA,LLLL	 Read LLLL bytes at address AA..AA */
+		case 'm':
+			/* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
+			ptr = &remcomInBuffer[1];
+			if (hexToInt(&ptr, &addr) &&
+			    (*(ptr++) == ',') && (hexToInt(&ptr, &length))) {
+				ptr = 0;
+				/*
+				 * hex doubles the byte count
+				 */
+				if (length > (BUFMAX / 2))
+					length = BUFMAX / 2;
+				mem2hex((char *) addr,
+					remcomOutBuffer, length, 1);
+				if (mem_err) {
+					strcpy(remcomOutBuffer, "E03");
+					debug_error("memory fault\n", NULL);
+				}
+			}
+
+			if (ptr) {
+				strcpy(remcomOutBuffer, "E01");
+				debug_error
+				    ("malformed read memory command: %s\n",
+				     remcomInBuffer);
+			}
+			break;
+
+			/* MAA..AA,LLLL:
+			   Write LLLL bytes at address AA.AA return OK */
+		case 'M':
+			/* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
+			ptr = &remcomInBuffer[1];
+			if (hexToInt(&ptr, &addr) &&
+			    (*(ptr++) == ',') &&
+			    (hexToInt(&ptr, &length)) && (*(ptr++) == ':')) {
+				hex2mem(ptr, (char *) addr, length, 1);
+
+				if (mem_err) {
+					strcpy(remcomOutBuffer, "E03");
+					debug_error("memory fault\n", NULL);
+				} else {
+					strcpy(remcomOutBuffer, "OK");
+				}
+
+				ptr = 0;
+			}
+			if (ptr) {
+				strcpy(remcomOutBuffer, "E02");
+				debug_error
+				    ("malformed write memory command: %s\n",
+				     remcomInBuffer);
+			}
+			break;
+		case 'S':
+			remcomInBuffer[0] = 's';
+		case 'C':
+			/* Csig;AA..AA where ;AA..AA is optional
+			 * continue with signal
+			 * Since signals are meaning less to us, delete that
+			 * part and then fall into the 'c' code.
+			 */
+			ptr = &remcomInBuffer[1];
+			length = 2;
+			while (*ptr && *ptr != ';') {
+				length++;
+				ptr++;
+			}
+			if (*ptr) {
+				do {
+					ptr++;
+					*(ptr - length++) = *ptr;
+				} while (*ptr);
+			} else {
+				remcomInBuffer[1] = 0;
+			}
+
+			/* cAA..AA  Continue at address AA..AA(optional) */
+			/* sAA..AA  Step one instruction from AA..AA(optional) */
+			/* D	    detach, reply OK and then continue */
+		case 'c':
+		case 's':
+		case 'D':
+
+			/* try to read optional parameter,
+			   pc unchanged if no parm */
+			ptr = &remcomInBuffer[1];
+			if (hexToInt(&ptr, &addr)) {
+				if (remote_debug)
+					printk("Changing EIP to 0x%x\n", addr);
+
+				regs.eip = addr;
+			}
+
+			newPC = regs.eip;
+
+			/* clear the trace bit */
+			regs.eflags &= 0xfffffeff;
+
+			/* set the trace bit if we're stepping */
+			if (remcomInBuffer[0] == 's')
+				regs.eflags |= 0x100;
+
+			/* detach is a friendly version of continue. Note that
+			   debugging is still enabled (e.g hit control C)
+			 */
+			if (remcomInBuffer[0] == 'D') {
+				strcpy(remcomOutBuffer, "OK");
+				putpacket(remcomOutBuffer);
+			}
+
+			if (remote_debug) {
+				printk("Resuming execution\n");
+				print_regs(&regs);
+			}
+			asm volatile ("movl %%db6, %0\n":"=r" (dr6)
+				      :);
+			if (!(dr6 & 0x4000)) {
+				for (breakno = 0; breakno < 4; ++breakno) {
+					if (dr6 & (1 << breakno) &&
+					    (breakinfo[breakno].type == 0)) {
+						/* Set restore flag */
+						regs.eflags |= 0x10000;
+						break;
+					}
+				}
+			}
+
+			if (kgdboe)
+				netpoll_set_trap(0);
+
+			correct_hw_break();
+			asm volatile ("movl %0, %%db6\n"::"r" (0));
+			goto exit_kgdb;
+
+			/* kill the program */
+		case 'k':	/* do nothing */
+			break;
+
+			/* query */
+		case 'q':
+			nothreads = 0;
+			switch (remcomInBuffer[1]) {
+			case 'f':
+				threadid = 1;
+				thread_list = 2;
+				thread_list_start = (usethread ? : current);
+			case 's':
+				if (!cmp_str(&remcomInBuffer[2],
+					     "ThreadInfo", 10))
+					break;
+
+				remcomOutBuffer[nothreads++] = 'm';
+				for (; threadid < PID_MAX + MAX_NO_CPUS;
+				     threadid++) {
+					thread = getthread(threadid);
+					if (thread) {
+						nothreads += int_to_hex_v(
+							&remcomOutBuffer[
+								nothreads],
+							threadid);
+						if (thread_min > threadid)
+							thread_min = threadid;
+						remcomOutBuffer[
+							nothreads] = ',';
+						nothreads++;
+						if (nothreads > BUFMAX - 10)
+							break;
+					}
+				}
+				if (remcomOutBuffer[nothreads - 1] == 'm') {
+					remcomOutBuffer[nothreads - 1] = 'l';
+				} else {
+					nothreads--;
+				}
+				remcomOutBuffer[nothreads] = 0;
+				break;
+
+#ifdef old_thread_list /* Old thread info request */
+			case 'L':
+				/* List threads */
+				thread_list = 2;
+				thread_list_start = (usethread ? : current);
+				unpack_byte(remcomInBuffer + 3, &maxthreads);
+				unpack_threadid(remcomInBuffer + 5, &thref);
+				do {
+					int buf_thread_limit =
+					    (BUFMAX - 22) / BUF_THREAD_ID_SIZE;
+					if (maxthreads > buf_thread_limit) {
+						maxthreads = buf_thread_limit;
+					}
+				} while (0);
+				remcomOutBuffer[0] = 'q';
+				remcomOutBuffer[1] = 'M';
+				remcomOutBuffer[4] = '0';
+				pack_threadid(remcomOutBuffer + 5, &thref);
+
+				threadid = threadref_to_int(&thref);
+				for (nothreads = 0;
+				     nothreads < maxthreads &&
+				     threadid < PID_MAX + MAX_NO_CPUS;
+				     threadid++) {
+					thread = getthread(threadid);
+					if (thread) {
+						int_to_threadref(&thref,
+								 threadid);
+						pack_threadid(remcomOutBuffer +
+							      21 +
+							      nothreads * 16,
+							      &thref);
+						nothreads++;
+						if (thread_min > threadid)
+							thread_min = threadid;
+					}
+				}
+
+				if (threadid == PID_MAX + MAX_NO_CPUS) {
+					remcomOutBuffer[4] = '1';
+				}
+				pack_hex_byte(remcomOutBuffer + 2, nothreads);
+				remcomOutBuffer[21 + nothreads * 16] = '\0';
+				break;
+#endif
+			case 'C':
+				/* Current thread id */
+				remcomOutBuffer[0] = 'Q';
+				remcomOutBuffer[1] = 'C';
+				threadid = current->pid;
+				if (!threadid) {
+					/*
+					 * idle thread
+					 */
+					for (threadid = PID_MAX;
+					     threadid < PID_MAX + MAX_NO_CPUS;
+					     threadid++) {
+						if (current ==
+						    idle_task(threadid -
+							      PID_MAX))
+							break;
+					}
+				}
+				int_to_threadref(&thref, threadid);
+				pack_threadid(remcomOutBuffer + 2, &thref);
+				remcomOutBuffer[18] = '\0';
+				break;
+
+			case 'E':
+				/* Print exception info */
+				printexceptioninfo(exceptionVector,
+						   err_code, remcomOutBuffer);
+				break;
+			case 'T':{
+				char * nptr;
+				/* Thread extra info */
+				if (!cmp_str(&remcomInBuffer[2],
+					    "hreadExtraInfo,", 15)) {
+					break;
+				}
+				ptr = &remcomInBuffer[17];
+				hexToInt(&ptr, &threadid);
+				thread = getthread(threadid);
+				nptr = &thread->comm[0];
+				length = 0;
+				ptr = &remcomOutBuffer[0];
+				do {
+					length++;
+					ptr = pack_hex_byte(ptr, *nptr++);
+				 } while (*nptr && length < 16);
+				/*
+				 * would like that 16 to be the size of
+				 * task_struct.comm but don't know the
+				 * syntax..
+				 */
+				*ptr = 0;
+			}
+			}
+			break;
+
+			/* task related */
+		case 'H':
+			switch (remcomInBuffer[1]) {
+			case 'g':
+				ptr = &remcomInBuffer[2];
+				hexToInt(&ptr, &threadid);
+				thread = getthread(threadid);
+				if (!thread) {
+					remcomOutBuffer[0] = 'E';
+					remcomOutBuffer[1] = '\0';
+					break;
+				}
+				/*
+				 * Just in case I forget what this is all about,
+				 * the "thread info" command to gdb causes it
+				 * to ask for a thread list.  It then switches
+				 * to each thread and asks for the registers.
+				 * For this (and only this) usage, we want to
+				 * fudge the registers of tasks not on the run
+				 * list (i.e. waiting) to show the routine that
+				 * called schedule. Also, gdb, is a minimalist
+				 * in that if the current thread is the last
+				 * it will not re-read the info when done.
+				 * This means that in this case we must show
+				 * the real registers. So here is how we do it:
+				 * Each entry we keep track of the min
+				 * thread in the list (the last that gdb will)
+				 * get info for.  We also keep track of the
+				 * starting thread.
+				 * "thread_list" is cleared when switching back
+				 * to the min thread if it is was current, or
+				 * if it was not current, thread_list is set
+				 * to 1.  When the switch to current comes,
+				 * if thread_list is 1, clear it, else do
+				 * nothing.
+				 */
+				usethread = thread;
+				if ((thread_list == 1) &&
+				    (thread == thread_list_start)) {
+					thread_list = 0;
+				}
+				if (thread_list && (threadid == thread_min)) {
+					if (thread == thread_list_start) {
+						thread_list = 0;
+					} else {
+						thread_list = 1;
+					}
+				}
+				/* follow through */
+			case 'c':
+				remcomOutBuffer[0] = 'O';
+				remcomOutBuffer[1] = 'K';
+				remcomOutBuffer[2] = '\0';
+				break;
+			}
+			break;
+
+			/* Query thread status */
+		case 'T':
+			ptr = &remcomInBuffer[1];
+			hexToInt(&ptr, &threadid);
+			thread = getthread(threadid);
+			if (thread) {
+				remcomOutBuffer[0] = 'O';
+				remcomOutBuffer[1] = 'K';
+				remcomOutBuffer[2] = '\0';
+				if (thread_min > threadid)
+					thread_min = threadid;
+			} else {
+				remcomOutBuffer[0] = 'E';
+				remcomOutBuffer[1] = '\0';
+			}
+			break;
+
+		case 'Y': /* set up a hardware breakpoint */
+			ptr = &remcomInBuffer[1];
+			hexToInt(&ptr, &breakno);
+			ptr++;
+			hexToInt(&ptr, &breaktype);
+			ptr++;
+			hexToInt(&ptr, &length);
+			ptr++;
+			hexToInt(&ptr, &addr);
+			if (set_hw_break(breakno & 0x3,
+					 breaktype & 0x3,
+					 length & 0x3, addr) == 0) {
+				strcpy(remcomOutBuffer, "OK");
+			} else {
+				strcpy(remcomOutBuffer, "ERROR");
+			}
+			break;
+
+			/* Remove hardware breakpoint */
+		case 'y':
+			ptr = &remcomInBuffer[1];
+			hexToInt(&ptr, &breakno);
+			if (remove_hw_break(breakno & 0x3) == 0) {
+				strcpy(remcomOutBuffer, "OK");
+			} else {
+				strcpy(remcomOutBuffer, "ERROR");
+			}
+			break;
+
+		case 'r':	/* reboot */
+			strcpy(remcomOutBuffer, "OK");
+			putpacket(remcomOutBuffer);
+			/*to_gdb("Rebooting\n"); */
+			/* triplefault	 no return from here */
+			{
+				static long no_idt[2];
+				__asm__ __volatile__("lidt %0"::"m"(no_idt[0]));
+				BREAKPOINT;
+			}
+
+		}		/* switch */
+
+		/* reply to the request */
+		putpacket(remcomOutBuffer);
+	}			/* while(1==1) */
+	/*
+	 *  reached by goto only.
+	 */
+      exit_kgdb:
+	/*
+	 * Here is where we set up to trap a gdb function call.	 NEW_esp
+	 * will be changed if we are trying to do this.	 We handle both
+	 * adding and subtracting, thus allowing gdb to put grung on
+	 * the stack which it removes later.
+	 */
+	if (NEW_esp != OLD_esp) {
+		int *ptr = END_OF_LOOKASIDE;
+		if (NEW_esp < OLD_esp)
+			ptr -= (OLD_esp - NEW_esp) / sizeof (int);
+		*--ptr = linux_regs->eflags;
+		*--ptr = linux_regs->xcs;
+		*--ptr = linux_regs->eip;
+		*--ptr = linux_regs->ecx;
+		*--ptr = linux_regs->ebx;
+		*--ptr = linux_regs->eax;
+		linux_regs->ecx = NEW_esp - (sizeof (int) * 6);
+		linux_regs->ebx = (unsigned int) END_OF_LOOKASIDE;
+		if (NEW_esp < OLD_esp) {
+			linux_regs->eip = (unsigned int) fn_call_stub;
+		} else {
+			linux_regs->eip = (unsigned int) fn_rtn_stub;
+			linux_regs->eax = NEW_esp;
+		}
+		linux_regs->eflags &= ~(IF_BIT | TF_BIT);
+	}
+#ifdef CONFIG_SMP
+	/*
+	 * Release gdb wait locks
+	 * Sanity check time.  Must have at least one cpu to run.  Also single
+	 * step must not be done if the current cpu is on hold.
+	 */
+	if (spinlock_count == 1) {
+		int ss_hold = (regs.eflags & 0x100) && kgdb_info.hold_on_sstep;
+		int cpu_avail = 0;
+		int i;
+
+		for (i = 0; i < MAX_NO_CPUS; i++) {
+			if (!cpu_online(i))
+				break;
+			if (!hold_cpu(i)) {
+				cpu_avail = 1;
+			}
+		}
+		/*
+		 * Early in the bring up there will be NO cpus on line...
+		 */
+		if (!cpu_avail && !cpus_empty(cpu_online_map)) {
+			to_gdb("No cpus unblocked, see 'kgdb_info.hold_cpu'\n");
+			goto once_again;
+		}
+		if (hold_cpu(smp_processor_id()) && (regs.eflags & 0x100)) {
+			to_gdb
+			    ("Current cpu must be unblocked to single step\n");
+			goto once_again;
+		}
+		if (!(ss_hold)) {
+			int i;
+			for (i = 0; i < MAX_NO_CPUS; i++) {
+				if (!hold_cpu(i)) {
+					spin_unlock(&waitlocks[i]);
+				}
+			}
+		} else {
+			spin_unlock(&waitlocks[smp_processor_id()]);
+		}
+		/* Release kgdb spinlock */
+		KGDB_SPIN_UNLOCK(&kgdb_spinlock);
+		/*
+		 * If this cpu is on hold, this is where we
+		 * do it.  Note, the NMI will pull us out of here,
+		 * but will return as the above lock is not held.
+		 * We will stay here till another cpu releases the lock for us.
+		 */
+		spin_unlock_wait(waitlocks + smp_processor_id());
+		kgdb_local_irq_restore(flags);
+		return (0);
+	}
+#if 0
+exit_just_unlock:
+#endif
+#endif
+	/* Release kgdb spinlock */
+	KGDB_SPIN_UNLOCK(&kgdb_spinlock);
+	kgdb_local_irq_restore(flags);
+	return (0);
+}
+
+/* this function is used to set up exception handlers for tracing and
+ * breakpoints.
+ * This function is not needed as the above line does all that is needed.
+ * We leave it for backward compatitability...
+ */
+void
+set_debug_traps(void)
+{
+	/*
+	 * linux_debug_hook is defined in traps.c.  We store a pointer
+	 * to our own exception handler into it.
+
+	 * But really folks, every hear of labeled common, an old Fortran
+	 * concept.  Lots of folks can reference it and it is define if
+	 * anyone does.	 Only one can initialize it at link time.  We do
+	 * this with the hook.	See the statement above.  No need for any
+	 * executable code and it is ready as soon as the kernel is
+	 * loaded.  Very desirable in kernel debugging.
+
+	 linux_debug_hook = handle_exception ;
+	 */
+
+	/* In case GDB is started before us, ack any packets (presumably
+	   "$?#xx") sitting there.
+	   putDebugChar ('+');
+
+	   initialized = 1;
+	 */
+}
+
+/* This function will generate a breakpoint exception.	It is used at the
+   beginning of a program to sync up with a debugger and can be used
+   otherwise as a quick means to stop program execution and "break" into
+   the debugger. */
+/* But really, just use the BREAKPOINT macro.  We will handle the int stuff
+ */
+
+#ifdef later
+/*
+ * possibly we should not go thru the traps.c code at all?  Someday.
+ */
+void
+do_kgdb_int3(struct pt_regs *regs, long error_code)
+{
+	kgdb_handle_exception(3, 5, error_code, regs);
+	return;
+}
+#endif
+#undef regs
+#ifdef CONFIG_TRAP_BAD_SYSCALL_EXITS
+asmlinkage void
+bad_sys_call_exit(int stuff)
+{
+	struct pt_regs *regs = (struct pt_regs *) &stuff;
+	printk("Sys call %d return with %x preempt_count\n",
+	       (int) regs->orig_eax, preempt_count());
+}
+#endif
+#ifdef CONFIG_STACK_OVERFLOW_TEST
+#include <asm/kgdb.h>
+asmlinkage void
+stack_overflow(void)
+{
+#ifdef BREAKPOINT
+	BREAKPOINT;
+#else
+	printk("Kernel stack overflow, looping forever\n");
+#endif
+	while (1) {
+	}
+}
+#endif
+
+#if defined(CONFIG_SMP) || defined(CONFIG_KGDB_CONSOLE)
+char gdbconbuf[BUFMAX];
+
+static void
+kgdb_gdb_message(const char *s, unsigned count)
+{
+	int i;
+	int wcount;
+	char *bufptr;
+	/*
+	 * This takes care of NMI while spining out chars to gdb
+	 */
+	IF_SMP(in_kgdb_console = 1);
+	gdbconbuf[0] = 'O';
+	bufptr = gdbconbuf + 1;
+	while (count > 0) {
+		if ((count << 1) > (BUFMAX - 2)) {
+			wcount = (BUFMAX - 2) >> 1;
+		} else {
+			wcount = count;
+		}
+		count -= wcount;
+		for (i = 0; i < wcount; i++) {
+			bufptr = pack_hex_byte(bufptr, s[i]);
+		}
+		*bufptr = '\0';
+		s += wcount;
+
+		putpacket(gdbconbuf);
+
+	}
+	IF_SMP(in_kgdb_console = 0);
+}
+#endif
+#ifdef CONFIG_SMP
+static void
+to_gdb(const char *s)
+{
+	int count = 0;
+	while (s[count] && (count++ < BUFMAX)) ;
+	kgdb_gdb_message(s, count);
+}
+#endif
+#ifdef CONFIG_KGDB_CONSOLE
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+
+void
+kgdb_console_write(struct console *co, const char *s, unsigned count)
+{
+
+	if (gdb_i386vector == -1) {
+		/*
+		 * We have not yet talked to gdb.  What to do...
+		 * lets break, on continue we can do the write.
+		 * But first tell him whats up. Uh, well no can do,
+		 * as this IS the console.  Oh well...
+		 * We do need to wait or the messages will be lost.
+		 * Other option would be to tell the above code to
+		 * ignore this breakpoint and do an auto return,
+		 * but that might confuse gdb.	Also this happens
+		 * early enough in boot up that we don't have the traps
+		 * set up yet, so...
+		 */
+		breakpoint();
+	}
+	kgdb_gdb_message(s, count);
+}
+
+/*
+ * ------------------------------------------------------------
+ * Serial KGDB driver
+ * ------------------------------------------------------------
+ */
+
+static struct console kgdbcons = {
+	name:"kgdb",
+	write:kgdb_console_write,
+#ifdef CONFIG_KGDB_USER_CONSOLE
+	device:kgdb_console_device,
+#endif
+	flags:CON_PRINTBUFFER | CON_ENABLED,
+	index:-1,
+};
+
+/*
+ * The trick here is that this file gets linked before printk.o
+ * That means we get to peer at the console info in the command
+ * line before it does.	 If we are up, we register, otherwise,
+ * do nothing.	By returning 0, we allow printk to look also.
+ */
+static int kgdb_console_enabled;
+
+int __init
+kgdb_console_init(char *str)
+{
+	if ((strncmp(str, "kgdb", 4) == 0) || (strncmp(str, "gdb", 3) == 0)) {
+		register_console(&kgdbcons);
+		kgdb_console_enabled = 1;
+	}
+	return 0;		/* let others look at the string */
+}
+
+__setup("console=", kgdb_console_init);
+
+#ifdef CONFIG_KGDB_USER_CONSOLE
+static kdev_t kgdb_console_device(struct console *c);
+/* This stuff sort of works, but it knocks out telnet devices
+ * we are leaving it here in case we (or you) find time to figure it out
+ * better..
+ */
+
+/*
+ * We need a real char device as well for when the console is opened for user
+ * space activities.
+ */
+
+static int
+kgdb_consdev_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t
+kgdb_consdev_write(struct file *file, const char *buf,
+		   size_t count, loff_t * ppos)
+{
+	int size, ret = 0;
+	static char kbuf[128];
+	static DECLARE_MUTEX(sem);
+
+	/* We are not reentrant... */
+	if (down_interruptible(&sem))
+		return -ERESTARTSYS;
+
+	while (count > 0) {
+		/* need to copy the data from user space */
+		size = count;
+		if (size > sizeof (kbuf))
+			size = sizeof (kbuf);
+		if (copy_from_user(kbuf, buf, size)) {
+			ret = -EFAULT;
+			break;;
+		}
+		kgdb_console_write(&kgdbcons, kbuf, size);
+		count -= size;
+		ret += size;
+		buf += size;
+	}
+
+	up(&sem);
+
+	return ret;
+}
+
+struct file_operations kgdb_consdev_fops = {
+	open:kgdb_consdev_open,
+	write:kgdb_consdev_write
+};
+static kdev_t
+kgdb_console_device(struct console *c)
+{
+	return MKDEV(TTYAUX_MAJOR, 1);
+}
+
+/*
+ * This routine gets called from the serial stub in the i386/lib
+ * This is so it is done late in bring up (just before the console open).
+ */
+void
+kgdb_console_finit(void)
+{
+	if (kgdb_console_enabled) {
+		char *cptr = cdevname(MKDEV(TTYAUX_MAJOR, 1));
+		char *cp = cptr;
+		while (*cptr && *cptr != '(')
+			cptr++;
+		*cptr = 0;
+		unregister_chrdev(TTYAUX_MAJOR, cp);
+		register_chrdev(TTYAUX_MAJOR, "kgdb", &kgdb_consdev_fops);
+	}
+}
+#endif
+#endif
+#ifdef CONFIG_KGDB_TS
+#include <asm/msr.h>		/* time stamp code */
+#include <asm/hardirq.h>	/* in_interrupt */
+#ifdef CONFIG_KGDB_TS_64
+#define DATA_POINTS 64
+#endif
+#ifdef CONFIG_KGDB_TS_128
+#define DATA_POINTS 128
+#endif
+#ifdef CONFIG_KGDB_TS_256
+#define DATA_POINTS 256
+#endif
+#ifdef CONFIG_KGDB_TS_512
+#define DATA_POINTS 512
+#endif
+#ifdef CONFIG_KGDB_TS_1024
+#define DATA_POINTS 1024
+#endif
+#ifndef DATA_POINTS
+#define DATA_POINTS 128		/* must be a power of two */
+#endif
+#define INDEX_MASK (DATA_POINTS - 1)
+#if (INDEX_MASK & DATA_POINTS)
+#error "CONFIG_KGDB_TS_COUNT must be a power of 2"
+#endif
+struct kgdb_and_then_struct {
+#ifdef CONFIG_SMP
+	int on_cpu;
+#endif
+	struct task_struct *task;
+	long long at_time;
+	int from_ln;
+	char *in_src;
+	void *from;
+	int *with_shpf;
+	int data0;
+	int data1;
+};
+struct kgdb_and_then_struct2 {
+#ifdef CONFIG_SMP
+	int on_cpu;
+#endif
+	struct task_struct *task;
+	long long at_time;
+	int from_ln;
+	char *in_src;
+	void *from;
+	int *with_shpf;
+	struct task_struct *t1;
+	struct task_struct *t2;
+};
+struct kgdb_and_then_struct kgdb_data[DATA_POINTS];
+
+struct kgdb_and_then_struct *kgdb_and_then = &kgdb_data[0];
+int kgdb_and_then_count;
+
+void
+kgdb_tstamp(int line, char *source, int data0, int data1)
+{
+	static spinlock_t ts_spin = SPIN_LOCK_UNLOCKED;
+	int flags;
+	kgdb_local_irq_save(flags);
+	spin_lock(&ts_spin);
+	rdtscll(kgdb_and_then->at_time);
+#ifdef CONFIG_SMP
+	kgdb_and_then->on_cpu = smp_processor_id();
+#endif
+	kgdb_and_then->task = current;
+	kgdb_and_then->from_ln = line;
+	kgdb_and_then->in_src = source;
+	kgdb_and_then->from = __builtin_return_address(0);
+	kgdb_and_then->with_shpf = (int *) (((flags & IF_BIT) >> 9) |
+					    (preempt_count() << 8));
+	kgdb_and_then->data0 = data0;
+	kgdb_and_then->data1 = data1;
+	kgdb_and_then = &kgdb_data[++kgdb_and_then_count & INDEX_MASK];
+	spin_unlock(&ts_spin);
+	kgdb_local_irq_restore(flags);
+#ifdef CONFIG_PREEMPT
+
+#endif
+	return;
+}
+#endif
+typedef int gdb_debug_hook(int exceptionVector,
+			   int signo, int err_code, struct pt_regs *linux_regs);
+gdb_debug_hook *linux_debug_hook = &kgdb_handle_exception;	/* histerical reasons... */
+
+static int kgdb_need_breakpoint[NR_CPUS];
+
+void kgdb_schedule_breakpoint(void)
+{
+	kgdb_need_breakpoint[smp_processor_id()] = 1;
+}
+
+void kgdb_process_breakpoint(void)
+{
+	/*
+	 * Handle a breakpoint queued from inside network driver code
+         * to avoid reentrancy issues
+	 */
+	if (kgdb_need_breakpoint[smp_processor_id()]) {
+		kgdb_need_breakpoint[smp_processor_id()] = 0;
+		BREAKPOINT;
+	}
+}
+
diff -Naur linux-2.6.11/arch/i386/kernel/Makefile linux-2.6.11-om/arch/i386/kernel/Makefile
--- linux-2.6.11/arch/i386/kernel/Makefile	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/Makefile	2005-05-15 23:18:04.000000000 +0200
@@ -14,6 +14,7 @@
 obj-$(CONFIG_ACPI_BOOT)		+= acpi/
 obj-$(CONFIG_X86_BIOS_REBOOT)	+= reboot.o
 obj-$(CONFIG_MCA)		+= mca.o
+obj-$(CONFIG_KGDB)		+= kgdb_stub.o
 obj-$(CONFIG_X86_MSR)		+= msr.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
 obj-$(CONFIG_MICROCODE)		+= microcode.o
diff -Naur linux-2.6.11/arch/i386/kernel/nmi.c linux-2.6.11-om/arch/i386/kernel/nmi.c
--- linux-2.6.11/arch/i386/kernel/nmi.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/nmi.c	2005-05-15 23:18:04.000000000 +0200
@@ -34,7 +34,17 @@
 
 #include "mach_traps.h"
 
+#ifdef CONFIG_KGDB
+#include <asm/kgdb.h>
+#ifdef CONFIG_SMP
+unsigned int nmi_watchdog = NMI_IO_APIC;
+#else
+unsigned int nmi_watchdog = NMI_LOCAL_APIC;
+#endif
+#else
 unsigned int nmi_watchdog = NMI_NONE;
+#endif
+
 extern int unknown_nmi_panic;
 static unsigned int nmi_hz = HZ;
 static unsigned int nmi_perfctr_msr;	/* the MSR to reset in NMI handler */
@@ -470,6 +480,9 @@
 	for (i = 0; i < NR_CPUS; i++)
 		alert_counter[i] = 0;
 }
+#ifdef CONFIG_KGDB
+int tune_watchdog = 5*HZ;
+#endif
 
 extern void die_nmi(struct pt_regs *, const char *msg);
 
@@ -485,12 +498,24 @@
 
 	sum = irq_stat[cpu].apic_timer_irqs;
 
+#ifdef CONFIG_KGDB
+	if (!in_kgdb(regs) && last_irq_sums[cpu] == sum) {
+
+#else
 	if (last_irq_sums[cpu] == sum) {
+#endif
 		/*
 		 * Ayiee, looks like this CPU is stuck ...
 		 * wait a few IRQs (5 seconds) before doing the oops ...
 		 */
 		alert_counter[cpu]++;
+#ifdef CONFIG_KGDB
+		if (alert_counter[cpu] == tune_watchdog) {
+			kgdb_handle_exception(2, SIGPWR, 0, regs);
+			last_irq_sums[cpu] = sum;
+			alert_counter[cpu] = 0;
+		}
+#endif
 		if (alert_counter[cpu] == 5*nmi_hz)
 			die_nmi(regs, "NMI Watchdog detected LOCKUP");
 	} else {
diff -Naur linux-2.6.11/arch/i386/kernel/omasm.h linux-2.6.11-om/arch/i386/kernel/omasm.h
--- linux-2.6.11/arch/i386/kernel/omasm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/omasm.h	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,296 @@
+.data
+
+ENTRY(remote_sys_call_table)
+	.long om_sys_remote		/* 0 - old "setup()" system call, used for restarting */
+	.long om_sys_remote		/* sys_exit */
+	.long om_sys_fork		/* sys_fork */
+	.long om_sys_remote		/* sys_read */
+	.long om_sys_remote		/* sys_write */
+	.long om_sys_remote		/* sys_open */
+	.long om_sys_remote		/* sys_close */
+	.long om_sys_remote		/* sys_waitpid */
+	.long om_sys_remote		/* sys_creat */
+	.long om_sys_remote		/* sys_link */
+	.long om_sys_remote		/* sys_unlink */
+	.long om_sys_remote		/* sys_execve */
+	.long om_sys_remote		/* sys_chdir */
+	.long om_sys_remote		/* sys_time */
+	.long om_sys_remote		/* sys_mknod */
+	.long om_sys_remote		/* sys_chmod */
+	.long om_sys_remote		/* sys_lchown16 */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_stat */
+	.long om_sys_remote		/* sys_lseek */
+	.long om_sys_getpid		/* sys_getpid */
+	.long om_sys_remote		/* sys_mount */
+	.long om_sys_remote		/* sys_oldumount */
+	.long om_sys_local		/* sys_setuid16 */
+	.long om_sys_local		/* sys_getuid16 */
+	.long om_sys_remote		/* sys_stime */
+	.long om_sys_remote		/* sys_ptrace */
+	.long om_sys_remote		/* sys_alarm */
+	.long om_sys_remote		/* sys_fstat */
+	.long om_sys_local		/* sys_pause */
+	.long om_sys_remote		/* sys_utime */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_access */
+	.long om_sys_remote		/* sys_nice */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_sync */
+	.long om_sys_remote		/* sys_kill */
+	.long om_sys_remote		/* sys_rename */
+	.long om_sys_remote		/* sys_mkdir */
+	.long om_sys_remote		/* sys_rmdir */
+	.long om_sys_remote		/* sys_dup */
+	.long om_sys_remote		/* sys_pipe */
+	.long om_sys_remote		/* sys_times */
+	.long sys_ni_syscall
+	.long om_sys_local		/* sys_brk */
+	.long om_sys_local		/* sys_setgid16 */
+	.long om_sys_local		/* sys_getgid16 */
+	.long om_sys_local		/* sys_signal */
+	.long om_sys_local		/* sys_geteuid16 */
+	.long om_sys_local		/* sys_getegid16 */
+	.long om_sys_remote		/* sys_acct */
+	.long om_sys_remote		/* sys_umount */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_ioctl */
+	.long om_sys_remote		/* sys_fcntl */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_setpgid */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_olduname */
+	.long om_sys_remote		/* sys_umask */
+	.long om_sys_remote		/* sys_chroot */
+	.long om_sys_remote		/* sys_ustat */
+	.long om_sys_remote		/* sys_dup2 */
+	.long om_sys_remote		/* sys_getppid */
+	.long om_sys_remote		/* sys_getpgrp */
+	.long om_sys_remote		/* sys_setsid */
+	.long om_sys_local		/* sys_sigaction */
+	.long om_sys_remote		/* sys_sgetmask */
+	.long om_sys_remote		/* sys_ssetmask */
+	.long om_sys_local		/* sys_setreuid16 */
+	.long om_sys_local		/* sys_setregid16 */
+	.long om_sys_local		/* sys_sigsuspend */
+	.long om_sys_local		/* sys_sigpending */
+	.long om_sys_remote		/* sys_sethostname */
+	.long om_sys_remote		/* sys_setrlimit */
+	.long om_sys_remote		/* sys_old_getrlimit */
+	.long om_sys_remote		/* sys_getrusage */
+	.long om_sys_remote		/* sys_gettimeofday */
+	.long om_sys_remote		/* sys_settimeofday */
+	.long om_sys_remote		/* sys_getgroups16 */
+	.long om_sys_remote		/* sys_setgroups16 */
+	.long om_sys_remote		/* old_select */
+	.long om_sys_remote		/* sys_symlink */
+	.long om_sys_remote		/* sys_lstat */
+	.long om_sys_remote		/* sys_readlink */
+	.long om_sys_remote		/* sys_uselib */
+	.long om_sys_remote		/* sys_swapon */
+	.long om_sys_remote		/* sys_reboot */
+	.long om_sys_remote		/* old_readdir */
+	.long om_sys_local		/* old_mmap */
+	.long om_sys_local		/* sys_munmap */
+	.long om_sys_remote		/* sys_truncate */
+	.long om_sys_remote		/* sys_ftruncate */
+	.long om_sys_remote		/* sys_fchmod */
+	.long om_sys_remote		/* sys_fchown16 */
+	.long om_sys_remote		/* sys_getpriority */
+	.long om_sys_remote		/* sys_setpriority */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_statfs */
+	.long om_sys_remote		/* sys_fstatfs */
+	.long om_sys_remote		/* sys_ioperm */
+	.long om_sys_remote		/* sys_socketcall */
+	.long om_sys_remote		/* sys_syslog */
+	.long om_sys_remote		/* sys_setitimer */
+	.long om_sys_remote		/* sys_getitimer */
+	.long om_sys_remote		/* sys_newstat */
+	.long om_sys_remote		/* sys_newlstat */
+	.long om_sys_remote		/* sys_newfstat */
+	.long om_sys_remote		/* sys_uname */
+	.long om_sys_remote		/* sys_iopl */
+	.long om_sys_remote		/* sys_vhangup */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_vm86old */
+	.long om_sys_remote		/* sys_wait4 */
+	.long om_sys_remote		/* sys_swapoff */
+	.long om_sys_remote		/* sys_sysinfo */
+	.long om_sys_remote		/* sys_ipc */
+	.long om_sys_remote		/* sys_fsync */
+	.long om_sys_local		/* sys_sigreturn */
+	.long om_sys_clone		/* sys_clone */
+	.long om_sys_remote		/* sys_setdomainname */
+	.long om_sys_remote		/* sys_newuname */
+	.long om_sys_local		/* sys_modify_ldt */
+	.long om_sys_remote		/* sys_adjtimex */
+	.long om_sys_local		/* sys_mprotect */
+	.long om_sys_local		/* sys_sigprocmask */
+	.long sys_ni_syscall 
+	.long om_sys_remote		/* sys_init_module */
+	.long om_sys_remote		/* sys_delete_module */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_quotactl */
+	.long om_sys_remote		/* sys_getpgid */
+	.long om_sys_remote		/* sys_fchdir */
+	.long om_sys_remote		/* sys_bdflush */
+	.long om_sys_remote		/* sys_sysfs */
+	.long om_sys_remote		/* sys_personality */
+	.long sys_ni_syscall
+	.long om_sys_local		/* sys_setfsuid16 */
+	.long om_sys_local		/* sys_setfsgid16 */
+	.long om_sys_remote		/* sys_llseek */
+	.long om_sys_remote		/* sys_getdents */
+	.long om_sys_remote		/* sys_select */
+	.long om_sys_remote		/* sys_flock */
+	.long om_sys_remote		/* sys_msync */
+	.long om_sys_remote		/* sys_readv */
+	.long om_sys_remote		/* sys_writev */
+	.long om_sys_local		/* sys_getsid */
+	.long om_sys_remote		/* sys_fdatasync */
+	.long om_sys_remote		/* sys_sysctl */
+	.long om_sys_remote		/* sys_mlock */
+	.long om_sys_remote		/* sys_munlock */
+	.long om_sys_remote		/* sys_mlockall */
+	.long om_sys_remote		/* sys_munlockall */
+	.long om_sys_remote		/* sys_sched_setparam */
+	.long om_sys_remote		/* sys_sched_getparam */
+	.long om_sys_remote		/* sys_sched_setscheduler */
+	.long om_sys_remote		/* sys_sched_getscheduler */
+	.long om_sys_local		/* sys_sched_yield */
+	.long om_sys_remote		/* sys_sched_get_priority_max */
+	.long om_sys_remote		/* sys_sched_get_priority_min */
+	.long om_sys_remote		/* sys_sched_rr_get_interval */
+	.long om_sys_local		/* sys_nanosleep */
+	.long om_sys_local		/* sys_mremap */
+	.long om_sys_local		/* sys_setresuid16 */
+	.long om_sys_local		/* sys_getresuid16 */
+	.long om_sys_remote		/* sys_vm86 */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_poll */
+	.long om_sys_remote		/* sys_nfsservctl */
+	.long om_sys_local		/* sys_setresgid16 */
+	.long om_sys_local		/* sys_getresgid16 */
+	.long om_sys_remote		/* sys_prctl */
+	.long om_sys_local		/* sys_rt_sigreturn */
+	.long om_sys_local		/* sys_rt_sigaction */
+	.long om_sys_local		/* sys_rt_sigprocmask */
+	.long om_sys_local		/* sys_rt_sigpending */
+	.long om_sys_local		/* sys_rt_sigtimedwait */
+	.long om_sys_local		/* sys_rt_sigqueueinfo */
+	.long om_sys_local		/* sys_rt_sigsuspend */
+	.long om_sys_remote		/* sys_pread64 */
+	.long om_sys_remote		/* sys_pwrite64 */
+	.long om_sys_remote		/* sys_chown16 */
+	.long om_sys_remote		/* sys_getcwd */
+	.long om_sys_remote		/* sys_capget */
+	.long om_sys_remote		/* sys_capset */
+	.long om_sys_local		/* sys_sigaltstack */
+	.long om_sys_remote		/* sys_sendfile */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_vfork */
+	.long om_sys_remote		/* sys_getrlimit */
+	.long om_sys_local		/* sys_mmap2 */
+	.long om_sys_remote		/* sys_truncate64 */
+	.long om_sys_remote		/* sys_ftruncate64 */
+	.long om_sys_remote		/* sys_stat64 */
+	.long om_sys_remote		/* sys_lstat64 */
+	.long om_sys_remote		/* sys_fstat64 */
+	.long om_sys_remote		/* sys_lchown */
+	.long om_sys_local		/* sys_getuid */
+	.long om_sys_local		/* sys_getgid */
+	.long om_sys_local		/* sys_geteuid */
+	.long om_sys_local		/* sys_getegid */
+	.long om_sys_local		/* sys_setreuid */
+	.long om_sys_local		/* sys_setregid */
+	.long om_sys_remote		/* sys_getgroups */
+	.long om_sys_remote		/* sys_setgroups */
+	.long om_sys_remote		/* sys_fchown */
+	.long om_sys_local		/* sys_setresuid */
+	.long om_sys_local		/* sys_getresuid */
+	.long om_sys_local		/* sys_setresgid */
+	.long om_sys_local		/* sys_getresgid */
+	.long om_sys_remote		/* sys_chown */
+	.long om_sys_local		/* sys_setuid */
+	.long om_sys_local		/* sys_setgid */
+	.long om_sys_local		/* sys_setfsuid */
+	.long om_sys_local		/* sys_setfsgid */
+	.long om_sys_remote		/* sys_pivot_root */
+	.long om_sys_local		/* sys_mincore */
+	.long om_sys_local		/* sys_madvise */
+	.long om_sys_remote		/* sys_getdents64 */
+	.long om_sys_remote		/* sys_fcntl64 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long om_sys_gettid		/* sys_gettid */
+	.long om_sys_remote		/* sys_readahead */
+	.long om_sys_remote		/* sys_setxattr */
+	.long om_sys_remote		/* sys_lsetxattr */
+	.long om_sys_remote		/* sys_fsetxattr */
+	.long om_sys_remote		/* sys_getxattr */
+	.long om_sys_remote		/* sys_lgetxattr */
+	.long om_sys_remote		/* sys_fgetxattr */
+	.long om_sys_remote		/* sys_listxattr */
+	.long om_sys_remote		/* sys_llistxattr */
+	.long om_sys_remote		/* sys_flistxattr */
+	.long om_sys_remote		/* sys_removexattr */
+	.long om_sys_remote		/* sys_lremovexattr */
+	.long om_sys_remote		/* sys_fremovexattr */
+	.long om_sys_remote		/* sys_tkill */
+	.long om_sys_remote		/* sys_sendfile64 */
+	.long om_sys_local		/* sys_futex */
+	.long om_sys_remote		/* sys_sched_setaffinity */
+	.long om_sys_remote		/* sys_sched_getaffinity */
+	.long om_sys_remote		/* sys_set_thread_area */
+	.long om_sys_remote		/* sys_get_thread_area */
+	.long om_sys_remote		/* sys_io_setup */
+	.long om_sys_remote		/* sys_io_destroy */
+	.long om_sys_remote		/* sys_io_getevents */
+	.long om_sys_remote		/* sys_io_submit */
+	.long om_sys_remote		/* sys_io_cancel */
+	.long om_sys_remote		/* sys_fadvise64 */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_exit_group */
+	.long om_sys_remote		/* sys_lookup_dcookie */
+	.long om_sys_remote		/* sys_epoll_create */
+	.long om_sys_remote		/* sys_epoll_ctl */
+	.long om_sys_remote		/* sys_epoll_wait */
+	.long om_sys_remote		/* sys_remap_file_pages */
+	.long om_sys_remote		/* sys_set_tid_address */
+	.long om_sys_remote		/* sys_timer_create */
+	.long om_sys_remote		/* sys_timer_settime */
+	.long om_sys_remote		/* sys_timer_gettime */
+	.long om_sys_remote		/* sys_timer_getoverrun */
+	.long om_sys_remote		/* sys_timer_delete */
+	.long om_sys_remote		/* sys_clock_settime */
+	.long om_sys_remote		/* sys_clock_gettime */
+	.long om_sys_remote		/* sys_clock_getres */
+	.long om_sys_remote		/* sys_clock_nanosleep */
+	.long om_sys_remote		/* sys_statfs64 */
+	.long om_sys_remote		/* sys_fstatfs64 */	
+	.long om_sys_remote		/* sys_tgkill */
+	.long om_sys_remote		/* sys_utimes */
+	.long om_sys_remote		/* sys_fadvise64_64 */
+	.long sys_ni_syscall
+	.long om_sys_local		/* sys_mbind */
+	.long om_sys_remote		/* sys_get_mempolicy */
+	.long om_sys_remote		/* sys_set_mempolicy */
+	.long om_sys_remote		/* sys_mq_open */
+	.long om_sys_remote		/* sys_mq_unlink */
+	.long om_sys_remote		/* sys_mq_timedsend */
+	.long om_sys_remote		/* sys_mq_timedreceive */
+	.long om_sys_remote		/* sys_mq_notify */
+	.long om_sys_remote		/* sys_mq_getsetattr */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_waitid */
+	.long sys_ni_syscall
+	.long om_sys_remote		/* sys_add_key */
+	.long om_sys_remote		/* sys_request_key */
+	.long om_sys_remote		/* sys_keyctl */
+
+remote_syscall_table_size=(.-remote_sys_call_table)
+.text
+
diff -Naur linux-2.6.11/arch/i386/kernel/process.c linux-2.6.11-om/arch/i386/kernel/process.c
--- linux-2.6.11/arch/i386/kernel/process.c	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/process.c	2005-05-15 23:18:04.000000000 +0200
@@ -53,7 +53,10 @@
 #include <linux/irq.h>
 #include <linux/err.h>
 
+#include <linux/hpc.h>
+
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
+asmlinkage void ret_from_deputy_fork(void) __asm__("ret_from_deputy_fork");
 
 int hlt_counter;
 
@@ -283,6 +286,10 @@
 extern void kernel_thread_helper(void);
 __asm__(".section .text\n"
 	".align 4\n"
+#ifdef CONFIG_OPENMOSIX
+	"user_thread_helper:\n\t"
+	"subl $60,%esp\n\t"
+#endif
 	"kernel_thread_helper:\n\t"
 	"movl %edx,%eax\n\t"
 	"pushl %edx\n\t"
@@ -314,6 +321,32 @@
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
+#ifdef CONFIG_OPENMOSIX
+extern void user_thread_helper(void);
+/*
+ * Create an user thread
+ * difference from kernel_thread are: no CLONE_VM, SIGCHLD, and leave space
+ * on the stack for user registers pt_regs.
+ */
+int user_thread(int (*fn)(void *), void * arg, unsigned long flags)
+{
+	struct pt_regs regs;
+
+	memset(&regs, 0, sizeof(regs));
+	regs.ebx = (unsigned long) fn;
+	regs.edx = (unsigned long) arg;
+	regs.xds = __USER_DS;
+	regs.xes = __USER_DS;
+	regs.orig_eax = -1;
+	regs.eip = (unsigned long) user_thread_helper;
+	regs.xcs = __KERNEL_CS;
+	regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2;
+	
+	/* Ok, create the new process.. */
+	return do_fork(flags | SIGCHLD | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+}
+#endif /* CONFIG_OPENMOSIX */
+
 /*
  * Free current thread data structures etc..
  */
@@ -396,6 +429,10 @@
 	p->thread.esp0 = (unsigned long) (childregs+1);
 
 	p->thread.eip = (unsigned long) ret_from_fork;
+#ifdef CONFIG_OPENMOSIX
+	if (task_test_dflags(current, DDEPUTY))
+		p->thread.eip = (unsigned long) ret_from_deputy_fork;
+#endif /* CONFIG_OPENMOSIX */
 
 	savesegment(fs,p->thread.fs);
 	savesegment(gs,p->thread.gs);
diff -Naur linux-2.6.11/arch/i386/kernel/smp.c linux-2.6.11-om/arch/i386/kernel/smp.c
--- linux-2.6.11/arch/i386/kernel/smp.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/smp.c	2005-05-15 23:18:04.000000000 +0200
@@ -466,7 +466,17 @@
 {
 	on_each_cpu(do_flush_tlb_all, NULL, 1, 1);
 }
-
+#ifdef CONFIG_KGDB
+/*
+ * By using the NMI code instead of a vector we just sneak thru the
+ * word generator coming out with just what we want.  AND it does
+ * not matter if clustered_apic_mode is set or not.
+ */
+void smp_send_nmi_allbutself(void)
+{
+	send_IPI_allbutself(APIC_DM_NMI);
+}
+#endif
 /*
  * this function sends a 'reschedule' IPI to another CPU.
  * it goes straight through and wastes no time serializing
diff -Naur linux-2.6.11/arch/i386/kernel/sys_i386.c linux-2.6.11-om/arch/i386/kernel/sys_i386.c
--- linux-2.6.11/arch/i386/kernel/sys_i386.c	2005-03-02 08:38:32.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/sys_i386.c	2005-05-15 23:18:04.000000000 +0200
@@ -23,6 +23,8 @@
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 
+#include <linux/hpc.h>
+
 /*
  * sys_pipe() is the normal C calling standard for creating
  * a pipe. It's not the way Unix traditionally does this, though.
@@ -51,6 +53,10 @@
 
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
+#ifdef CONFIG_OPENMOSIX
+		if (task_test_dflags(current, DREMOTE))
+			return remote_do_mmap(addr, len, prot, flags, fd, pgoff);
+#endif
 		file = fget(fd);
 		if (!file)
 			goto out;
diff -Naur linux-2.6.11/arch/i386/kernel/traps.c linux-2.6.11-om/arch/i386/kernel/traps.c
--- linux-2.6.11/arch/i386/kernel/traps.c	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/traps.c	2005-05-15 23:18:04.000000000 +0200
@@ -105,6 +105,39 @@
 	return err;
 }
 
+#ifdef CONFIG_KGDB
+extern void sysenter_past_esp(void);
+#include <asm/kgdb.h>
+#include <linux/init.h>
+void set_intr_gate(unsigned int n, void *addr);
+static void set_intr_usr_gate(unsigned int n, void *addr);
+/*
+ * Should be able to call this breakpoint() very early in
+ * bring up.  Just hard code the call where needed.
+ * The breakpoint() code is here because set_?_gate() functions
+ * are local (static) to trap.c.  They need be done only once,
+ * but it does not hurt to do them over.
+ */
+void breakpoint(void)
+{
+	set_intr_usr_gate(3,&int3); /* disable ints on trap */
+	set_intr_gate(1,&debug);
+	set_intr_gate(14,&page_fault);
+
+        BREAKPOINT;
+}
+#define	CHK_REMOTE_DEBUG(trapnr,signr,error_code,regs,after)		\
+    {									\
+	if (!user_mode(regs)  ) \
+	{								\
+		kgdb_handle_exception(trapnr, signr, error_code, regs);	\
+		after;							\
+	} else if ((trapnr == 3) && (regs->eflags &0x200)) local_irq_enable(); \
+    }
+#else
+#define	CHK_REMOTE_DEBUG(trapnr,signr,error_code,regs,after)
+#endif
+
 static inline int valid_stack_ptr(struct thread_info *tinfo, void *p)
 {
 	return	p > (void *)tinfo &&
@@ -332,6 +365,15 @@
 #endif
 		if (nl)
 			printk("\n");
+#ifdef CONFIG_KGDB
+	/* This is about the only place we want to go to kgdb even if in
+	 * user mode.  But we must go in via a trap so within kgdb we will
+	 * always be in kernel mode.
+	 */
+		if (user_mode(regs))
+			BREAKPOINT;
+#endif
+	 	CHK_REMOTE_DEBUG(0,SIGTRAP,err,regs,)
 	notify_die(DIE_OOPS, (char *)str, regs, err, 255, SIGSEGV);
 		show_registers(regs);
   	} else
@@ -397,6 +439,7 @@
 #define DO_ERROR(trapnr, signr, str, name) \
 fastcall void do_##name(struct pt_regs * regs, long error_code) \
 { \
+	CHK_REMOTE_DEBUG(trapnr,signr,error_code,regs,) \
 	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) \
 						== NOTIFY_STOP) \
 		return; \
@@ -420,6 +463,7 @@
 #define DO_VM86_ERROR(trapnr, signr, str, name) \
 fastcall void do_##name(struct pt_regs * regs, long error_code) \
 { \
+	CHK_REMOTE_DEBUG(trapnr, signr, error_code,regs, return) \
 	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) \
 						== NOTIFY_STOP) \
 		return; \
@@ -503,6 +547,7 @@
 
 gp_in_kernel:
 	if (!fixup_exception(regs)) {
+ 		CHK_REMOTE_DEBUG(13,SIGSEGV,error_code,regs,)
 		if (notify_die(DIE_GPF, "general protection fault", regs,
 				error_code, 13, SIGSEGV) == NOTIFY_STOP)
 			return;
@@ -716,8 +761,19 @@
 		 * check for kernel mode by just checking the CPL
 		 * of CS.
 		 */
+#ifdef CONFIG_KGDB
+		/*
+		 * I think this is the only "real" case of a TF in the kernel
+		 * that really belongs to user space.  Others are
+		 * "Ours all ours!"
+		 */
+		if (((regs->xcs & 3) == 0) &&
+				((void *)regs->eip == sysenter_past_esp))
+			goto clear_TF_reenable;
+#else
 		if ((regs->xcs & 3) == 0)
 			goto clear_TF_reenable;
+#endif
 
 		if (likely(tsk->ptrace & PT_DTRACE)) {
 			tsk->ptrace &= ~PT_DTRACE;
@@ -725,6 +781,19 @@
 		}
 	}
 
+#ifdef CONFIG_KGDB
+	/*
+	 * If this is a kernel mode trap, we need to reset db7 to allow us
+	 * to continue sanely ALSO skip the signal delivery
+	 */
+	if ((regs->xcs & 3) == 0)
+		goto clear_dr7;
+
+	/* if not kernel, allow ints but only if they were on */
+	if (regs->eflags & 0x200)
+		local_irq_enable();
+#endif
+
 	/* Ok, finally something we can handle */
 	send_sigtrap(tsk, regs, error_code);
 
@@ -735,6 +804,7 @@
 	__asm__("movl %0,%%db7"
 		: /* no output */
 		: "r" (0));
+	CHK_REMOTE_DEBUG(1,SIGTRAP,error_code,regs,)
 	return;
 
 debug_vm86:
@@ -990,6 +1060,12 @@
 {
 	_set_gate(idt_table+n,5,0,0,(gdt_entry<<3));
 }
+#ifdef CONFIG_KGDB
+void set_intr_usr_gate(unsigned int n, void *addr)
+{
+	_set_gate(idt_table+n,14,3,addr,__KERNEL_CS);
+}
+#endif
 
 
 void __init trap_init(void)
@@ -1009,7 +1085,11 @@
 	set_trap_gate(0,&divide_error);
 	set_intr_gate(1,&debug);
 	set_intr_gate(2,&nmi);
+#ifndef CONFIG_KGDB
 	set_system_intr_gate(3, &int3); /* int3-5 can be called from all */
+#else
+	set_intr_usr_gate(3,&int3);	/* int3-5 can be called from all */
+#endif
 	set_system_gate(4,&overflow);
 	set_system_gate(5,&bounds);
 	set_trap_gate(6,&invalid_op);
diff -Naur linux-2.6.11/arch/i386/kernel/vm86.c linux-2.6.11-om/arch/i386/kernel/vm86.c
--- linux-2.6.11/arch/i386/kernel/vm86.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.11-om/arch/i386/kernel/vm86.c	2005-05-15 23:18:04.000000000 +0200
@@ -48,6 +48,8 @@
 #include <asm/tlbflush.h>
 #include <asm/irq.h>
 
+#include <linux/hpc.h>
+
 /*
  * Known problems:
  *
@@ -131,6 +133,11 @@
 	loadsegment(fs, current->thread.saved_fs);
 	loadsegment(gs, current->thread.saved_gs);
 	ret = KVM86->regs32;
+#ifdef CONFIG_OPENMOSIX
+	task_lock(current);
+	task_clear_stay(current, DSTAY_86);
+	task_unlock(current);
+#endif /* CONFIG_OPENMOSIX */
 	return ret;
 }
 
@@ -197,6 +204,13 @@
 	struct task_struct *tsk;
 	int tmp, ret = -EPERM;
 
+#ifdef CONFIG_OPENMOSIX
+	ret = -ENOMEM;
+	if (!task_go_home_for_reason(current, DSTAY_86))
+		goto out;
+	ret = -EPERM;
+#endif /* CONFIG_OPENMOSIX */
+
 	tsk = current;
 	if (tsk->thread.saved_esp0)
 		goto out;
@@ -256,6 +270,11 @@
 	ret = -EFAULT;
 	if (tmp)
 		goto out;
+#ifdef CONFIG_OPENMOSIX
+	ret = -ENOMEM;
+	if (!task_go_home_for_reason(current, DSTAY_86))
+		goto out;
+#endif /* CONFIG_OPENMOSIX */
 	info.regs32 = &regs;
 	info.vm86plus.is_vm86pus = 1;
 	tsk->thread.vm86_info = (struct vm86_struct __user *)v86;
@@ -338,6 +357,11 @@
 
 	regs32 = save_v86_state(regs16);
 	regs32->eax = retval;
+#ifdef CONFIG_OPENMOSIX
+	task_lock(current); 
+	task_clear_stay(current, DSTAY_86);
+	task_unlock(current);
+#endif /* CONFIG_OPENMOSIX */
 	__asm__ __volatile__("movl %0,%%esp\n\t"
 		"movl %1,%%ebp\n\t"
 		"jmp resume_userspace"
diff -Naur linux-2.6.11/arch/i386/lib/kgdb_serial.c linux-2.6.11-om/arch/i386/lib/kgdb_serial.c
--- linux-2.6.11/arch/i386/lib/kgdb_serial.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/arch/i386/lib/kgdb_serial.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,499 @@
+/*
+ * Serial interface GDB stub
+ *
+ * Written (hacked together) by David Grothe (dave@gcom.com)
+ * Modified to allow invokation early in boot see also
+ * kgdb.h for instructions by George Anzinger(george@mvista.com)
+ * Modified to handle debugging over ethernet by Robert Walsh
+ * <rjwalsh@durables.org> and wangdi <wangdi@clusterfs.com>, based on
+ * code by San Mehat.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_reg.h>
+#include <linux/config.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/highmem.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/segment.h>
+#include <asm/bitops.h>
+#include <asm/system.h>
+#include <asm/kgdb_local.h>
+#ifdef CONFIG_KGDB_USER_CONSOLE
+extern void kgdb_console_finit(void);
+#endif
+#define PRNT_off
+#define TEST_EXISTANCE
+#ifdef PRNT
+#define dbprintk(s) printk s
+#else
+#define dbprintk(s)
+#endif
+#define TEST_INTERRUPT_off
+#ifdef TEST_INTERRUPT
+#define intprintk(s) printk s
+#else
+#define intprintk(s)
+#endif
+
+#define IRQ_T(info) ((info->flags & ASYNC_SHARE_IRQ) ? SA_SHIRQ : SA_INTERRUPT)
+
+#define	GDB_BUF_SIZE	512	/* power of 2, please */
+
+static char gdb_buf[GDB_BUF_SIZE];
+static int gdb_buf_in_inx;
+static atomic_t gdb_buf_in_cnt;
+static int gdb_buf_out_inx;
+
+struct async_struct *gdb_async_info;
+static int gdb_async_irq;
+
+#define outb_px(a,b) outb_p(b,a)
+
+static void program_uart(struct async_struct *info);
+static void write_char(struct async_struct *info, int chr);
+/*
+ * Get a byte from the hardware data buffer and return it
+ */
+static int
+read_data_bfr(struct async_struct *info)
+{
+	char it = inb_p(info->port + UART_LSR);
+
+	if (it & UART_LSR_DR)
+		return (inb_p(info->port + UART_RX));
+	/*
+	 * If we have a framing error assume somebody messed with
+	 * our uart.  Reprogram it and send '-' both ways...
+	 */
+	if (it & 0xc) {
+		program_uart(info);
+		write_char(info, '-');
+		return ('-');
+	}
+	return (-1);
+
+}				/* read_data_bfr */
+
+/*
+ * Get a char if available, return -1 if nothing available.
+ * Empty the receive buffer first, then look at the interface hardware.
+
+ * Locking here is a bit of a problem.	We MUST not lock out communication
+ * if we are trying to talk to gdb about a kgdb entry.	ON the other hand
+ * we can loose chars in the console pass thru if we don't lock.  It is also
+ * possible that we could hold the lock or be waiting for it when kgdb
+ * NEEDS to talk.  Since kgdb locks down the world, it does not need locks.
+ * We do, of course have possible issues with interrupting a uart operation,
+ * but we will just depend on the uart status to help keep that straight.
+
+ */
+static spinlock_t uart_interrupt_lock = SPIN_LOCK_UNLOCKED;
+#ifdef CONFIG_SMP
+extern spinlock_t kgdb_spinlock;
+#endif
+
+static int
+read_char(struct async_struct *info)
+{
+	int chr;
+	unsigned long flags;
+	local_irq_save(flags);
+#ifdef CONFIG_SMP
+	if (!spin_is_locked(&kgdb_spinlock)) {
+		spin_lock(&uart_interrupt_lock);
+	}
+#endif
+	if (atomic_read(&gdb_buf_in_cnt) != 0) {	/* intr routine has q'd chars */
+		chr = gdb_buf[gdb_buf_out_inx++];
+		gdb_buf_out_inx &= (GDB_BUF_SIZE - 1);
+		atomic_dec(&gdb_buf_in_cnt);
+	} else {
+		chr = read_data_bfr(info);
+	}
+#ifdef CONFIG_SMP
+	if (!spin_is_locked(&kgdb_spinlock)) {
+		spin_unlock(&uart_interrupt_lock);
+	}
+#endif
+	local_irq_restore(flags);
+	return (chr);
+}
+
+/*
+ * Wait until the interface can accept a char, then write it.
+ */
+static void
+write_char(struct async_struct *info, int chr)
+{
+	while (!(inb_p(info->port + UART_LSR) & UART_LSR_THRE)) ;
+
+	outb_p(chr, info->port + UART_TX);
+
+}				/* write_char */
+
+/*
+ * Mostly we don't need a spinlock, but since the console goes
+ * thru here with interrutps on, well, we need to catch those
+ * chars.
+ */
+/*
+ * This is the receiver interrupt routine for the GDB stub.
+ * It will receive a limited number of characters of input
+ * from the gdb  host machine and save them up in a buffer.
+ *
+ * When the gdb stub routine tty_getDebugChar() is called it
+ * draws characters out of the buffer until it is empty and
+ * then reads directly from the serial port.
+ *
+ * We do not attempt to write chars from the interrupt routine
+ * since the stubs do all of that via tty_putDebugChar() which
+ * writes one byte after waiting for the interface to become
+ * ready.
+ *
+ * The debug stubs like to run with interrupts disabled since,
+ * after all, they run as a consequence of a breakpoint in
+ * the kernel.
+ *
+ * Perhaps someone who knows more about the tty driver than I
+ * care to learn can make this work for any low level serial
+ * driver.
+ */
+static irqreturn_t
+gdb_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct async_struct *info;
+	unsigned long flags;
+
+	info = gdb_async_info;
+	if (!info || !info->tty || irq != gdb_async_irq)
+		return IRQ_NONE;
+
+	local_irq_save(flags);
+	spin_lock(&uart_interrupt_lock);
+	do {
+		int chr = read_data_bfr(info);
+		intprintk(("Debug char on int: %x hex\n", chr));
+		if (chr < 0)
+			continue;
+
+		if (chr == 3) {	/* Ctrl-C means remote interrupt */
+			BREAKPOINT;
+			continue;
+		}
+
+		if (atomic_read(&gdb_buf_in_cnt) >= GDB_BUF_SIZE) {
+			/* buffer overflow tosses early char */
+			read_char(info);
+		}
+		gdb_buf[gdb_buf_in_inx++] = chr;
+		gdb_buf_in_inx &= (GDB_BUF_SIZE - 1);
+	} while (inb_p(info->port + UART_IIR) & UART_IIR_RDI);
+	spin_unlock(&uart_interrupt_lock);
+	local_irq_restore(flags);
+	return IRQ_HANDLED;
+}				/* gdb_interrupt */
+
+/*
+ * Just a NULL routine for testing.
+ */
+void
+gdb_null(void)
+{
+}				/* gdb_null */
+
+/* These structure are filled in with values defined in asm/kgdb_local.h
+ */
+static struct serial_state state = SB_STATE;
+static struct async_struct local_info = SB_INFO;
+static int ok_to_enable_ints = 0;
+static void kgdb_enable_ints_now(void);
+
+extern char *kgdb_version;
+/*
+ * Hook an IRQ for KGDB.
+ *
+ * This routine is called from tty_putDebugChar, below.
+ */
+static int ints_disabled = 1;
+int
+gdb_hook_interrupt(struct async_struct *info, int verb)
+{
+	struct serial_state *state = info->state;
+	unsigned long flags;
+	int port;
+#ifdef TEST_EXISTANCE
+	int scratch, scratch2;
+#endif
+
+	/* The above fails if memory managment is not set up yet.
+	 * Rather than fail the set up, just keep track of the fact
+	 * and pick up the interrupt thing later.
+	 */
+	gdb_async_info = info;
+	port = gdb_async_info->port;
+	gdb_async_irq = state->irq;
+	if (verb) {
+		printk("kgdb %s : port =%x, IRQ=%d, divisor =%d\n",
+		       kgdb_version,
+		       port,
+		       gdb_async_irq, gdb_async_info->state->custom_divisor);
+	}
+	local_irq_save(flags);
+#ifdef TEST_EXISTANCE
+	/* Existance test */
+	/* Should not need all this, but just in case.... */
+
+	scratch = inb_p(port + UART_IER);
+	outb_px(port + UART_IER, 0);
+	outb_px(0xff, 0x080);
+	scratch2 = inb_p(port + UART_IER);
+	outb_px(port + UART_IER, scratch);
+	if (scratch2) {
+		printk
+		    ("gdb_hook_interrupt: Could not clear IER, not a UART!\n");
+		local_irq_restore(flags);
+		return 1;	/* We failed; there's nothing here */
+	}
+	scratch2 = inb_p(port + UART_LCR);
+	outb_px(port + UART_LCR, 0xBF);	/* set up for StarTech test */
+	outb_px(port + UART_EFR, 0);	/* EFR is the same as FCR */
+	outb_px(port + UART_LCR, 0);
+	outb_px(port + UART_FCR, UART_FCR_ENABLE_FIFO);
+	scratch = inb_p(port + UART_IIR) >> 6;
+	if (scratch == 1) {
+		printk("gdb_hook_interrupt: Undefined UART type!"
+		       "  Not a UART! \n");
+		local_irq_restore(flags);
+		return 1;
+	} else {
+		dbprintk(("gdb_hook_interrupt: UART type "
+			  "is %d where 0=16450, 2=16550 3=16550A\n", scratch));
+	}
+	scratch = inb_p(port + UART_MCR);
+	outb_px(port + UART_MCR, UART_MCR_LOOP | scratch);
+	outb_px(port + UART_MCR, UART_MCR_LOOP | 0x0A);
+	scratch2 = inb_p(port + UART_MSR) & 0xF0;
+	outb_px(port + UART_MCR, scratch);
+	if (scratch2 != 0x90) {
+		printk("gdb_hook_interrupt: "
+		       "Loop back test failed! Not a UART!\n");
+		local_irq_restore(flags);
+		return scratch2 + 1000;	/* force 0 to fail */
+	}
+#endif				/* test existance */
+	program_uart(info);
+	local_irq_restore(flags);
+
+	return (0);
+
+}				/* gdb_hook_interrupt */
+
+static void
+program_uart(struct async_struct *info)
+{
+	int port = info->port;
+
+	(void) inb_p(port + UART_RX);
+	outb_px(port + UART_IER, 0);
+
+	(void) inb_p(port + UART_RX);	/* serial driver comments say */
+	(void) inb_p(port + UART_IIR);	/* this clears the interrupt regs */
+	(void) inb_p(port + UART_MSR);
+	outb_px(port + UART_LCR, UART_LCR_WLEN8 | UART_LCR_DLAB);
+	outb_px(port + UART_DLL, info->state->custom_divisor & 0xff);	/* LS */
+	outb_px(port + UART_DLM, info->state->custom_divisor >> 8);	/* MS  */
+	outb_px(port + UART_MCR, info->MCR);
+
+	outb_px(port + UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1 | UART_FCR_CLEAR_XMIT | UART_FCR_CLEAR_RCVR);	/* set fcr */
+	outb_px(port + UART_LCR, UART_LCR_WLEN8);	/* reset DLAB */
+	outb_px(port + UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1);	/* set fcr */
+	if (!ints_disabled) {
+		intprintk(("KGDB: Sending %d to port %x offset %d\n",
+			   gdb_async_info->IER,
+			   (int) gdb_async_info->port, UART_IER));
+		outb_px(gdb_async_info->port + UART_IER, gdb_async_info->IER);
+	}
+	return;
+}
+
+/*
+ * tty_getDebugChar
+ *
+ * This is a GDB stub routine.	It waits for a character from the
+ * serial interface and then returns it.  If there is no serial
+ * interface connection then it returns a bogus value which will
+ * almost certainly cause the system to hang.  In the
+ */
+int kgdb_in_isr = 0;
+int kgdb_in_lsr = 0;
+extern spinlock_t kgdb_spinlock;
+
+/* Caller takes needed protections */
+
+int
+tty_getDebugChar(void)
+{
+	volatile int chr, dum, time, end_time;
+
+	dbprintk(("tty_getDebugChar(port %x): ", gdb_async_info->port));
+
+	if (gdb_async_info == NULL) {
+		gdb_hook_interrupt(&local_info, 0);
+	}
+	/*
+	 * This trick says if we wait a very long time and get
+	 * no char, return the -1 and let the upper level deal
+	 * with it.
+	 */
+	rdtsc(dum, time);
+	end_time = time + 2;
+	while (((chr = read_char(gdb_async_info)) == -1) &&
+	       (end_time - time) > 0) {
+		rdtsc(dum, time);
+	};
+	/*
+	 * This covers our butts if some other code messes with
+	 * our uart, hay, it happens :o)
+	 */
+	if (chr == -1)
+		program_uart(gdb_async_info);
+
+	dbprintk(("%c\n", chr > ' ' && chr < 0x7F ? chr : ' '));
+	return (chr);
+
+}				/* tty_getDebugChar */
+
+static int count = 3;
+static spinlock_t one_at_atime = SPIN_LOCK_UNLOCKED;
+
+static int __init
+kgdb_enable_ints(void)
+{
+	if (kgdboe) {
+		return 0;
+	}
+	if (gdb_async_info == NULL) {
+		gdb_hook_interrupt(&local_info, 1);
+	}
+	ok_to_enable_ints = 1;
+	kgdb_enable_ints_now();
+#ifdef CONFIG_KGDB_USER_CONSOLE
+	kgdb_console_finit();
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_SERIAL_8250
+void shutdown_for_kgdb(struct async_struct *gdb_async_info);
+#endif
+
+#ifdef CONFIG_DISCONTIGMEM
+static inline int kgdb_mem_init_done(void)
+{
+	return totalram_pages != 0;
+}
+#else
+static inline int kgdb_mem_init_done(void)
+{
+	return max_mapnr != 0;
+}
+#endif
+
+static void
+kgdb_enable_ints_now(void)
+{
+	if (!spin_trylock(&one_at_atime))
+		return;
+	if (!ints_disabled)
+		goto exit;
+	if (kgdb_mem_init_done() &&
+			ints_disabled) {	/* don't try till mem init */
+#ifdef CONFIG_SERIAL_8250
+		/*
+		 * The ifdef here allows the system to be configured
+		 * without the serial driver.
+		 * Don't make it a module, however, it will steal the port
+		 */
+		shutdown_for_kgdb(gdb_async_info);
+#endif
+		ints_disabled = request_irq(gdb_async_info->state->irq,
+					    gdb_interrupt,
+					    IRQ_T(gdb_async_info),
+					    "KGDB-stub", NULL);
+		intprintk(("KGDB: request_irq returned %d\n", ints_disabled));
+	}
+	if (!ints_disabled) {
+		intprintk(("KGDB: Sending %d to port %x offset %d\n",
+			   gdb_async_info->IER,
+			   (int) gdb_async_info->port, UART_IER));
+		outb_px(gdb_async_info->port + UART_IER, gdb_async_info->IER);
+	}
+      exit:
+	spin_unlock(&one_at_atime);
+}
+
+/*
+ * tty_putDebugChar
+ *
+ * This is a GDB stub routine.	It waits until the interface is ready
+ * to transmit a char and then sends it.  If there is no serial
+ * interface connection then it simply returns to its caller, having
+ * pretended to send the char.	Caller takes needed protections.
+ */
+void
+tty_putDebugChar(int chr)
+{
+	dbprintk(("tty_putDebugChar(port %x): chr=%02x '%c', ints_on=%d\n",
+		  gdb_async_info->port,
+		  chr,
+		  chr > ' ' && chr < 0x7F ? chr : ' ', ints_disabled ? 0 : 1));
+
+	if (gdb_async_info == NULL) {
+		gdb_hook_interrupt(&local_info, 0);
+	}
+
+	write_char(gdb_async_info, chr);	/* this routine will wait */
+	count = (chr == '#') ? 0 : count + 1;
+	if ((count == 2)) {	/* try to enable after */
+		if (ints_disabled & ok_to_enable_ints)
+			kgdb_enable_ints_now();	/* try to enable after */
+
+		/* We do this a lot because, well we really want to get these
+		 * interrupts.	The serial driver will clear these bits when it
+		 * initializes the chip.  Every thing else it does is ok,
+		 * but this.
+		 */
+		if (!ints_disabled) {
+			outb_px(gdb_async_info->port + UART_IER,
+				gdb_async_info->IER);
+		}
+	}
+
+}				/* tty_putDebugChar */
+
+/*
+ * This does nothing for the serial port, since it doesn't buffer.
+ */
+
+void tty_flushDebugChar(void)
+{
+}
+
+module_init(kgdb_enable_ints);
diff -Naur linux-2.6.11/arch/i386/lib/Makefile linux-2.6.11-om/arch/i386/lib/Makefile
--- linux-2.6.11/arch/i386/lib/Makefile	2005-03-02 08:38:34.000000000 +0100
+++ linux-2.6.11-om/arch/i386/lib/Makefile	2005-05-15 23:18:04.000000000 +0200
@@ -8,3 +8,4 @@
 
 lib-$(CONFIG_X86_USE_3DNOW) += mmx.o
 lib-$(CONFIG_HAVE_DEC_LOCK) += dec_and_lock.o
+lib-$(CONFIG_KGDB) += kgdb_serial.o
diff -Naur linux-2.6.11/arch/i386/lib/usercopy.c linux-2.6.11-om/arch/i386/lib/usercopy.c
--- linux-2.6.11/arch/i386/lib/usercopy.c	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.11-om/arch/i386/lib/usercopy.c	2005-05-15 23:18:04.000000000 +0200
@@ -193,7 +193,10 @@
 	unsigned long res, tmp;
 
 	might_sleep();
-
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_strnlen_user(s, n);
+#endif
 	__asm__ __volatile__(
 		"	testl %0, %0\n"
 		"	jz 3f\n"
diff -Naur linux-2.6.11/arch/i386/Makefile linux-2.6.11-om/arch/i386/Makefile
--- linux-2.6.11/arch/i386/Makefile	2005-03-02 08:37:58.000000000 +0100
+++ linux-2.6.11-om/arch/i386/Makefile	2005-05-15 23:18:04.000000000 +0200
@@ -99,6 +99,9 @@
 # default subarch .h files
 mflags-y += -Iinclude/asm-i386/mach-default
 
+mflags-$(CONFIG_KGDB) += -gdwarf-2
+mflags-$(CONFIG_KGDB_MORE) += $(shell echo $(CONFIG_KGDB_OPTIONS) | sed -e 's/"//g')
+
 head-y := arch/i386/kernel/head.o arch/i386/kernel/init_task.o
 
 libs-y 					+= arch/i386/lib/
diff -Naur linux-2.6.11/arch/i386/mm/fault.c linux-2.6.11-om/arch/i386/mm/fault.c
--- linux-2.6.11/arch/i386/mm/fault.c	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.11-om/arch/i386/mm/fault.c	2005-05-15 23:18:04.000000000 +0200
@@ -428,6 +428,12 @@
  * Oops. The kernel tried to access some bad page. We'll have to
  * terminate things with extreme prejudice.
  */
+#ifdef CONFIG_KGDB
+        if (!user_mode(regs)){
+                kgdb_handle_exception(14,SIGBUS, error_code, regs);
+                return;
+        }
+#endif
 
 	bust_spinlocks(1);
 
diff -Naur linux-2.6.11/arch/ppc/Kconfig linux-2.6.11-om/arch/ppc/Kconfig
--- linux-2.6.11/arch/ppc/Kconfig	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.11-om/arch/ppc/Kconfig	2005-05-15 23:18:04.000000000 +0200
@@ -1294,3 +1294,5 @@
 source "security/Kconfig"
 
 source "crypto/Kconfig"
+
+source "hpc/Kconfig"
diff -Naur linux-2.6.11/arch/ppc/kernel/asm-offsets.c linux-2.6.11-om/arch/ppc/kernel/asm-offsets.c
--- linux-2.6.11/arch/ppc/kernel/asm-offsets.c	2005-03-02 08:38:09.000000000 +0100
+++ linux-2.6.11-om/arch/ppc/kernel/asm-offsets.c	2005-05-15 23:18:04.000000000 +0200
@@ -24,6 +24,7 @@
 #include <asm/processor.h>
 #include <asm/cputable.h>
 #include <asm/thread_info.h>
+#include <hpc/task.h>
 
 #define DEFINE(sym, val) \
 	asm volatile("\n->" #sym " %0 " #val : : "i" (val))
@@ -137,5 +138,12 @@
 	DEFINE(TI_PREEMPT, offsetof(struct thread_info, preempt_count));
 
 	DEFINE(NUM_USER_SEGMENTS, TASK_SIZE>>28);
+#ifdef CONFIG_OPENMOSIX
+	DEFINE(TASK_om, offsetof(struct task_struct, om));
+	DEFINE(OM_dflags, offsetof(struct openmosix_task, dflags));
+	BLANK();
+	DEFINE(DDEPUTY, DDEPUTY);
+	DEFINE(DREMOTE, DREMOTE);
+#endif /* CONFIG_OPENMOSIX */
 	return 0;
 }
diff -Naur linux-2.6.11/arch/ppc/kernel/entry.S linux-2.6.11-om/arch/ppc/kernel/entry.S
--- linux-2.6.11/arch/ppc/kernel/entry.S	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.11-om/arch/ppc/kernel/entry.S	2005-05-15 23:18:04.000000000 +0200
@@ -208,11 +208,25 @@
 	andi.	r11,r11,_TIF_SYSCALL_TRACE
 	bne-	syscall_dotrace
 syscall_dotrace_cont:
+#ifdef CONFIG_OPENMOSIX
+	lwz	r11, TASK_om+OM_dflags(r2)
+	andi.	r11, r11, DREMOTE
+	beq	local_syscall_load
+remote_syscall_load:
+	cmplwi	0,r0,NR_syscalls
+	lis	r10,remote_sys_call_table@h
+	ori	r10,r10,remote_sys_call_table@l
+	slwi	r0,r0,2
+	bge-	66f
+	b	fetch_syscall
+local_syscall_load:
+#endif /* CONFIG_OPENMOSIX */
 	cmplwi	0,r0,NR_syscalls
 	lis	r10,sys_call_table@h
 	ori	r10,r10,sys_call_table@l
 	slwi	r0,r0,2
 	bge-	66f
+fetch_syscall:
 	lwzx	r10,r10,r0	/* Fetch system call handler [ptr] */
 	mtlr	r10
 	addi	r9,r1,STACK_FRAME_OVERHEAD
@@ -275,6 +289,12 @@
 	li	r3,0
 	b	ret_from_syscall
 
+#ifdef CONFIG_OPENMOSIX
+	.globl	ret_from_kickstart
+ret_from_kickstart:
+	b	ret_from_syscall
+#endif /* CONFIG_OPENMOSIX */
+
 /* Traced system call support */
 syscall_dotrace:
 	SAVE_NVGPRS(r1)
@@ -601,6 +621,9 @@
 	bne	do_work
 
 restore_user:
+#ifdef CONFIG_OPENMOSIX
+	bl	openmosix_pre_usermode
+#endif /* CONFIG_OPENMOSIX */
 #if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)
 	/* Check whether this process has its own DBCR0 value.  The single
 	   step bit tells us that dbcr0 should be loaded. */
diff -Naur linux-2.6.11/arch/ppc/kernel/misc.S linux-2.6.11-om/arch/ppc/kernel/misc.S
--- linux-2.6.11/arch/ppc/kernel/misc.S	2005-03-02 08:38:26.000000000 +0100
+++ linux-2.6.11-om/arch/ppc/kernel/misc.S	2005-05-15 23:18:04.000000000 +0200
@@ -25,6 +25,11 @@
 #include <asm/thread_info.h>
 #include <asm/offsets.h>
 
+#ifdef CONFIG_OPENMOSIX
+/* FIXME */
+#define SIGCHLD 17
+#endif /* CONFIG_OPENMOSIX */
+
 	.text
 
 	.align	5
@@ -1156,6 +1161,39 @@
 	addi	r1,r1,16
 	blr
 
+#ifdef CONFIG_OPENMOSIX
+/*
+ * Create an user thread
+ *   user_thread(fn, arg, flags)
+ */
+_GLOBAL(user_thread)
+	stwu	r1,-16(r1)
+	stw	r30,8(r1)
+	stw	r31,12(r1)
+	mr	r30,r3		/* function */
+	mr	r31,r4		/* argument */
+	ori	r3,r5,SIGCHLD	/* flags */
+	oris	r3,r3,CLONE_UNTRACED>>16
+	li	r4,0		/* new sp (unused) */
+	li	r0,__NR_clone
+	sc
+	cmpi	0,r3,0		/* parent or child? */
+	bne	1f		/* return if parent */
+	li	r0,0		/* make top-level stack frame */
+	stwu	r0,-16(r1)
+	addi	r1,r1,-172	/* substract sizeof pt_regs to stack */
+	mtlr	r30		/* fn addr in lr */
+	mr	r3,r31		/* load arg and call fn */
+	blrl
+	li	r0,__NR_exit	/* exit if function returns */
+	li	r3,0
+	sc
+1:	lwz	r30,8(r1)
+	lwz	r31,12(r1)
+	addi	r1,r1,16
+	blr
+#endif /* CONFIG_OPENMOSIX */
+
 /*
  * This routine is just here to keep GCC happy - sigh...
  */
@@ -1450,3 +1488,280 @@
 	.long sys_add_key
 	.long sys_request_key		/* 270 */
 	.long sys_keyctl
+	
+#ifdef CONFIG_OPENMOSIX
+_GLOBAL(remote_sys_call_table)
+	.long om_sys_remote	/* sys_restart_syscall */
+	.long om_sys_remote	/* sys_exit */
+	.long om_sys_remote	/* ppc_fork */
+	.long om_sys_remote	/* sys_read */
+	.long om_sys_remote	/* sys_write */
+	.long om_sys_remote	/* sys_open */
+	.long om_sys_remote	/* sys_close */
+	.long om_sys_remote	/* sys_waitpid */
+	.long om_sys_remote	/* sys_creat */
+	.long om_sys_remote	/* sys_link */
+	.long om_sys_remote	/* sys_unlink */
+	.long om_sys_remote	/* sys_execve */
+	.long om_sys_remote	/* sys_chdir */
+	.long om_sys_remote	/* sys_time */
+	.long om_sys_remote	/* sys_mknod */
+	.long om_sys_remote	/* sys_chmod */
+	.long om_sys_remote	/* sys_lchown */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_stat */
+	.long om_sys_remote	/* sys_lseek */
+	.long om_sys_getpid	/* sys_getpid */
+	.long om_sys_remote	/* sys_mount */
+	.long om_sys_remote	/* sys_oldumount */
+	.long om_sys_local	/* sys_setuid */
+	.long om_sys_local	/* sys_getuid */
+	.long om_sys_remote	/* sys_stime */
+	.long om_sys_remote	/* sys_ptrace */
+	.long om_sys_remote	/* sys_alarm */
+	.long om_sys_remote	/* sys_fstat */
+	.long om_sys_local	/* sys_pause */
+	.long om_sys_remote	/* sys_utime */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_access */
+	.long om_sys_remote	/* sys_nice */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_sync */
+	.long om_sys_remote	/* sys_kill */
+	.long om_sys_remote	/* sys_rename */
+	.long om_sys_remote	/* sys_mkdir */
+	.long om_sys_remote	/* sys_rmdir */
+	.long om_sys_remote	/* sys_dup */
+	.long om_sys_remote	/* sys_pipe */
+	.long om_sys_remote	/* sys_times */
+	.long sys_ni_syscall
+	.long om_sys_local	/* sys_brk */
+	.long om_sys_local	/* sys_setgid */
+	.long om_sys_local	/* sys_getgid */
+	.long om_sys_remote	/* sys_signal */
+	.long om_sys_local	/* sys_geteuid */
+	.long om_sys_local	/* sys_getegid */
+	.long om_sys_remote	/* sys_acct */
+	.long om_sys_remote	/* sys_umount  recycled never used phys()  */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_ioctl */
+	.long om_sys_remote	/* sys_fcntl */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_setpgid */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_olduname */
+	.long om_sys_remote	/* sys_umask */
+	.long om_sys_remote	/* sys_chroot */
+	.long om_sys_remote	/* sys_ustat */
+	.long om_sys_remote	/* sys_dup2 */
+	.long om_sys_remote	/* sys_getppid */
+	.long om_sys_remote	/* sys_getpgrp */
+	.long om_sys_remote	/* sys_setsid */
+	.long om_sys_remote	/* sys_sigaction */
+	.long om_sys_remote	/* sys_sgetmask */
+	.long om_sys_remote	/* sys_ssetmask */
+	.long om_sys_remote	/* sys_setreuid */
+	.long om_sys_remote	/* sys_setregid */
+	.long om_sys_remote	/* ppc_sigsuspend */
+	.long om_sys_remote	/* sys_sigpending */
+	.long om_sys_remote	/* sys_sethostname */
+	.long om_sys_remote	/* sys_setrlimit */
+	.long om_sys_remote	/* sys_old_getrlimit */
+	.long om_sys_remote	/* sys_getrusage */
+	.long om_sys_remote	/* sys_gettimeofday */
+	.long om_sys_remote	/* sys_settimeofday */
+	.long om_sys_remote	/* sys_getgroups */
+	.long om_sys_remote	/* sys_setgroups */
+	.long om_sys_remote	/* ppc_select */
+	.long om_sys_remote	/* sys_symlink */
+	.long om_sys_remote	/* sys_lstat */
+	.long om_sys_remote	/* sys_readlink */
+	.long om_sys_remote	/* sys_uselib */
+	.long om_sys_remote	/* sys_swapon */
+	.long om_sys_remote	/* sys_reboot */
+	.long om_sys_remote	/* old_readdir */
+	.long om_sys_local	/* sys_mmap */
+	.long om_sys_local	/* sys_munmap */
+	.long om_sys_remote	/* sys_truncate */
+	.long om_sys_remote	/* sys_ftruncate */
+	.long om_sys_remote	/* sys_fchmod */
+	.long om_sys_remote	/* sys_fchown */
+	.long om_sys_remote	/* sys_getpriority */
+	.long om_sys_remote	/* sys_setpriority */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_statfs */
+	.long om_sys_remote	/* sys_fstatfs */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_socketcall */
+	.long om_sys_remote	/* sys_syslog */
+	.long om_sys_remote	/* sys_setitimer */
+	.long om_sys_remote	/* sys_getitimer */
+	.long om_sys_remote	/* sys_newstat */
+	.long om_sys_remote	/* sys_newlstat */
+	.long om_sys_remote	/* sys_newfstat */
+	.long om_sys_remote	/* sys_uname */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_vhangup */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_wait4 */
+	.long om_sys_remote	/* sys_swapoff */
+	.long om_sys_remote	/* sys_sysinfo */
+	.long om_sys_remote	/* sys_ipc */
+	.long om_sys_remote	/* sys_fsync */
+	.long om_sys_remote	/* sys_sigreturn */
+	.long om_sys_remote	/* ppc_clone */
+	.long om_sys_remote	/* sys_setdomainname */
+	.long om_sys_remote	/* sys_newuname */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_adjtimex */
+	.long om_sys_remote	/* sys_mprotect */
+	.long om_sys_remote	/* sys_sigprocmask */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_init_module */
+	.long om_sys_remote	/* sys_delete_module */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_quotactl */
+	.long om_sys_remote	/* sys_getpgid */
+	.long om_sys_remote	/* sys_fchdir */
+	.long om_sys_remote	/* sys_bdflush */
+	.long om_sys_remote	/* sys_sysfs */
+	.long om_sys_remote	/* sys_personality */
+	.long sys_ni_syscall
+	.long om_sys_local	/* sys_setfsuid */
+	.long om_sys_local	/* sys_setfsgid */
+	.long om_sys_remote	/* sys_llseek */
+	.long om_sys_remote	/* sys_getdents */
+	.long om_sys_remote	/* ppc_select */
+	.long om_sys_remote	/* sys_flock */
+	.long om_sys_local	/* sys_msync */
+	.long om_sys_remote	/* sys_readv */
+	.long om_sys_remote	/* sys_writev */
+	.long om_sys_remote	/* sys_getsid */
+	.long om_sys_remote	/* sys_fdatasync */
+	.long om_sys_remote	/* sys_sysctl */
+	.long om_sys_remote	/* sys_mlock */
+	.long om_sys_remote	/* sys_munlock */
+	.long om_sys_remote	/* sys_mlockall */
+	.long om_sys_remote	/* sys_munlockall */
+	.long om_sys_remote	/* sys_sched_setparam */
+	.long om_sys_remote	/* sys_sched_getparam */
+	.long om_sys_remote	/* sys_sched_setscheduler */
+	.long om_sys_remote	/* sys_sched_getscheduler */
+	.long om_sys_local	/* sys_sched_yield */
+	.long om_sys_remote	/* sys_sched_get_priority_max */
+	.long om_sys_remote	/* sys_sched_get_priority_min */
+	.long om_sys_remote	/* sys_sched_rr_get_interval */
+	.long om_sys_local	/* sys_nanosleep */
+	.long om_sys_local	/* sys_mremap */
+	.long om_sys_local	/* sys_setresuid */
+	.long om_sys_local	/* sys_getresuid */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_poll */
+	.long om_sys_remote	/* sys_nfsservctl */
+	.long om_sys_local	/* sys_setresgid */
+	.long om_sys_local	/* sys_getresgid */
+	.long om_sys_remote	/* sys_prctl */
+	.long om_sys_remote	/* sys_rt_sigreturn */
+	.long om_sys_remote	/* sys_rt_sigaction */
+	.long om_sys_remote	/* sys_rt_sigprocmask */
+	.long om_sys_remote	/* sys_rt_sigpending */
+	.long om_sys_remote	/* sys_rt_sigtimedwait */
+	.long om_sys_remote	/* sys_rt_sigqueueinfo */
+	.long om_sys_remote	/* ppc_rt_sigsuspend */
+	.long om_sys_remote	/* sys_pread64 */
+	.long om_sys_remote	/* sys_pwrite64 */
+	.long om_sys_remote	/* sys_chown */
+	.long om_sys_remote	/* sys_getcwd */
+	.long om_sys_remote	/* sys_capget */
+	.long om_sys_remote	/* sys_capset */
+	.long om_sys_remote	/* sys_sigaltstack */
+	.long om_sys_remote	/* sys_sendfile */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long om_sys_remote	/* ppc_vfork */
+	.long om_sys_remote	/* sys_getrlimit */
+	.long om_sys_remote	/* sys_readahead */
+	.long om_sys_local	/* sys_mmap2 */
+	.long om_sys_remote	/* sys_truncate64 */
+	.long om_sys_remote	/* sys_ftruncate64 */
+	.long om_sys_remote	/* sys_stat64 */
+	.long om_sys_remote	/* sys_lstat64 */
+	.long om_sys_remote	/* sys_fstat64 */
+	.long om_sys_remote	/* sys_pciconfig_read */
+	.long om_sys_remote	/* sys_pciconfig_write */
+	.long om_sys_remote	/* sys_pciconfig_iobase */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_getdents64 */
+	.long om_sys_remote	/* sys_pivot_root */
+	.long om_sys_remote	/* sys_fcntl64 */
+	.long om_sys_local	/* sys_madvise */
+	.long om_sys_local	/* sys_mincore */
+	.long om_sys_gettid	/* sys_gettid */
+	.long om_sys_remote	/* sys_tkill */
+	.long om_sys_remote	/* sys_setxattr */
+	.long om_sys_remote	/* sys_lsetxattr */
+	.long om_sys_remote	/* sys_fsetxattr */
+	.long om_sys_remote	/* sys_getxattr */
+	.long om_sys_remote	/* sys_lgetxattr */
+	.long om_sys_remote	/* sys_fgetxattr */
+	.long om_sys_remote	/* sys_listxattr */
+	.long om_sys_remote	/* sys_llistxattr */
+	.long om_sys_remote	/* sys_flistxattr */
+	.long om_sys_remote	/* sys_removexattr */
+	.long om_sys_remote	/* sys_lremovexattr */
+	.long om_sys_remote	/* sys_fremovexattr */
+	.long om_sys_remote	/* sys_futex */
+	.long om_sys_remote	/* sys_sched_setaffinity */
+	.long om_sys_remote	/* sys_sched_getaffinity */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_sendfile64 */
+	.long om_sys_remote	/* sys_io_setup */
+	.long om_sys_remote	/* sys_io_destroy */
+	.long om_sys_remote	/* sys_io_getevents */
+	.long om_sys_remote	/* sys_io_submit */
+	.long om_sys_remote	/* sys_io_cancel */
+	.long om_sys_remote	/* sys_set_tid_address */
+	.long om_sys_remote	/* sys_fadvise64 */
+	.long om_sys_remote	/* sys_exit_group */
+	.long om_sys_remote	/* sys_lookup_dcookie */
+	.long om_sys_remote	/* sys_epoll_create */
+	.long om_sys_remote	/* sys_epoll_ctl */
+	.long om_sys_remote	/* sys_epoll_wait */
+	.long om_sys_remote	/* sys_remap_file_pages */
+	.long om_sys_remote	/* sys_timer_create */
+	.long om_sys_remote	/* sys_timer_settime */
+	.long om_sys_remote	/* sys_timer_gettime */
+	.long om_sys_remote	/* sys_timer_getoverrun */
+	.long om_sys_remote	/* sys_timer_delete */
+	.long om_sys_remote	/* sys_clock_settime */
+	.long om_sys_remote	/* sys_clock_gettime */
+	.long om_sys_remote	/* sys_clock_getres */
+	.long om_sys_remote	/* sys_clock_nanosleep */
+	.long om_sys_remote	/* ppc_swapcontext */
+	.long om_sys_remote	/* sys_tgkill */
+	.long om_sys_remote	/* sys_utimes */
+	.long om_sys_remote	/* sys_statfs64 */
+	.long om_sys_remote	/* sys_fstatfs64 */
+	.long om_sys_remote	/* ppc_fadvise64_64 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_mq_open */
+	.long om_sys_remote	/* sys_mq_unlink */
+	.long om_sys_remote	/* sys_mq_timedsend */
+	.long om_sys_remote	/* sys_mq_timedreceive */
+	.long om_sys_remote	/* sys_mq_notify */
+	.long om_sys_remote	/* sys_mq_getsetattr */
+	.long sys_ni_syscall
+	.long om_sys_remote	/* sys_add_key */
+	.long om_sys_remote	/* sys_request_key */
+	.long om_sys_remote	/* sys_keyctl */
+
+#endif /* CONFIG_OPENMOSIX */
diff -Naur linux-2.6.11/arch/x86_64/Kconfig linux-2.6.11-om/arch/x86_64/Kconfig
--- linux-2.6.11/arch/x86_64/Kconfig	2005-03-02 08:38:18.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/Kconfig	2005-05-15 23:18:04.000000000 +0200
@@ -456,4 +456,6 @@
 
 source "crypto/Kconfig"
 
+source "hpc/Kconfig"
+
 source "lib/Kconfig"
diff -Naur linux-2.6.11/arch/x86_64/Kconfig.debug linux-2.6.11-om/arch/x86_64/Kconfig.debug
--- linux-2.6.11/arch/x86_64/Kconfig.debug	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/Kconfig.debug	2005-05-15 23:18:04.000000000 +0200
@@ -51,7 +51,6 @@
          Add a simple leak tracer to the IOMMU code. This is useful when you
 	 are debugging a buggy device driver that leaks IOMMU mappings.
 
-#config X86_REMOTE_DEBUG
-#       bool "kgdb debugging stub"
+source "arch/x86_64/Kconfig.kgdb"
 
 endmenu
diff -Naur linux-2.6.11/arch/x86_64/Kconfig.kgdb linux-2.6.11-om/arch/x86_64/Kconfig.kgdb
--- linux-2.6.11/arch/x86_64/Kconfig.kgdb	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/Kconfig.kgdb	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,171 @@
+config KGDB
+	bool "Include kgdb kernel debugger"
+	depends on DEBUG_KERNEL
+	select DEBUG_INFO
+	help
+	  If you say Y here, the system will be compiled with the debug
+	  option (-g) and a debugging stub will be included in the
+	  kernel.  This stub communicates with gdb on another (host)
+	  computer via a serial port.  The host computer should have
+	  access to the kernel binary file (vmlinux) and a serial port
+	  that is connected to the target machine.  Gdb can be made to
+	  configure the serial port or you can use stty and setserial to
+	  do this. See the 'target' command in gdb. This option also
+	  configures in the ability to request a breakpoint early in the
+	  boot process.  To request the breakpoint just include 'kgdb'
+	  as a boot option when booting the target machine.  The system
+	  will then break as soon as it looks at the boot options.  This
+	  option also installs a breakpoint in panic and sends any
+	  kernel faults to the debugger. For more information see the
+	  Documentation/i386/kgdb.txt file.
+
+choice
+	depends on KGDB
+    	prompt "Debug serial port BAUD"
+	default KGDB_115200BAUD
+	help
+	  Gdb and the kernel stub need to agree on the baud rate to be
+	  used.  Some systems (x86 family at this writing) allow this to
+	  be configured.
+
+config KGDB_9600BAUD
+	bool "9600"
+
+config KGDB_19200BAUD
+	bool "19200"
+
+config KGDB_38400BAUD
+	bool "38400"
+
+config KGDB_57600BAUD
+	bool "57600"
+
+config KGDB_115200BAUD
+	bool "115200"
+endchoice
+
+config KGDB_PORT
+	hex "hex I/O port address of the debug serial port"
+	depends on KGDB
+	default  3f8
+	help
+	  Some systems (x86 family at this writing) allow the port
+	  address to be configured.  The number entered is assumed to be
+	  hex, don't put 0x in front of it.  The standard address are:
+	  COM1 3f8 , irq 4 and COM2 2f8 irq 3.  Setserial /dev/ttySx
+	  will tell you what you have.  It is good to test the serial
+	  connection with a live system before trying to debug.
+
+config KGDB_IRQ
+	int "IRQ of the debug serial port"
+	depends on KGDB
+	default 4
+	help
+	  This is the irq for the debug port.  If everything is working
+	  correctly and the kernel has interrupts on a control C to the
+	  port should cause a break into the kernel debug stub.
+
+config KGDB_MORE
+	bool "Add any additional compile options"
+	depends on KGDB
+	default n
+	help
+	  Saying yes here turns on the ability to enter additional
+	  compile options.
+
+
+config KGDB_OPTIONS
+	depends on KGDB_MORE
+	string "Additional compile arguments"
+	default "-O1"
+	help
+	  This option allows you enter additional compile options for
+	  the whole kernel compile.  Each platform will have a default
+	  that seems right for it.  For example on PPC "-ggdb -O1", and
+	  for i386 "-O1".  Note that by configuring KGDB "-g" is already
+	  turned on.  In addition, on i386 platforms
+	  "-fomit-frame-pointer" is deleted from the standard compile
+	  options.
+
+config NO_KGDB_CPUS
+	int "Number of CPUs"
+	depends on KGDB && SMP
+	default NR_CPUS
+	help
+
+	  This option sets the number of cpus for kgdb ONLY.  It is used
+	  to prune some internal structures so they look "nice" when
+	  displayed with gdb.  This is to overcome possibly larger
+	  numbers that may have been entered above.  Enter the real
+	  number to get nice clean kgdb_info displays.
+
+config KGDB_TS
+	bool "Enable kgdb time stamp macros?"
+	depends on KGDB
+	default n
+	help
+	  Kgdb event macros allow you to instrument your code with calls
+	  to the kgdb event recording function.  The event log may be
+	  examined with gdb at a break point.  Turning on this
+	  capability also allows you to choose how many events to
+	  keep. Kgdb always keeps the lastest events.
+
+choice
+	depends on KGDB_TS
+	prompt "Max number of time stamps to save?"
+	default KGDB_TS_128
+
+config KGDB_TS_64
+	bool "64"
+
+config KGDB_TS_128
+	bool "128"
+
+config KGDB_TS_256
+	bool "256"
+
+config KGDB_TS_512
+	bool "512"
+
+config KGDB_TS_1024
+	bool "1024"
+
+endchoice
+
+config STACK_OVERFLOW_TEST
+	bool "Turn on kernel stack overflow testing?"
+	depends on KGDB
+	default n
+	help
+	  This option enables code in the front line interrupt handlers
+	  to check for kernel stack overflow on interrupts and system
+	  calls.  This is part of the kgdb code on x86 systems.
+
+config KGDB_CONSOLE
+	bool "Enable serial console thru kgdb port"
+	depends on KGDB
+	default n
+	help
+	  This option enables the command line "console=kgdb" option.
+	  When the system is booted with this option in the command line
+	  all kernel printk output is sent to gdb (as well as to other
+	  consoles).  For this to work gdb must be connected.  For this
+	  reason, this command line option will generate a breakpoint if
+	  gdb has not yet connected.  After the gdb continue command is
+	  given all pent up console output will be printed by gdb on the
+	  host machine.  Neither this option, nor KGDB require the
+	  serial driver to be configured.
+
+config KGDB_SYSRQ
+	bool "Turn on SysRq 'G' command to do a break?"
+	depends on KGDB
+	default y
+	help
+	  This option includes an option in the SysRq code that allows
+	  you to enter SysRq G which generates a breakpoint to the KGDB
+	  stub.  This will work if the keyboard is alive and can
+	  interrupt the system.  Because of constraints on when the
+	  serial port interrupt can be enabled, this code may allow you
+	  to interrupt the system before the serial port control C is
+	  available.  Just say yes here.
+
diff -Naur linux-2.6.11/arch/x86_64/kernel/asm-offsets.c linux-2.6.11-om/arch/x86_64/kernel/asm-offsets.c
--- linux-2.6.11/arch/x86_64/kernel/asm-offsets.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/asm-offsets.c	2005-05-15 23:18:04.000000000 +0200
@@ -14,6 +14,9 @@
 #include <asm/segment.h>
 #include <asm/thread_info.h>
 #include <asm/ia32.h>
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/task.h>
+#endif
 
 #define DEFINE(sym, val) \
         asm volatile("\n->" #sym " %0 " #val : : "i" (val))
@@ -27,9 +30,13 @@
 	ENTRY(flags); 
 	ENTRY(thread); 
 	ENTRY(pid);
+#ifdef CONFIG_OPENMOSIX
+	DEFINE(TASK_om, offsetof(struct task_struct, om));
+#endif /* CONFIG_OPENMOSIX */
 	BLANK();
 #undef ENTRY
 #define ENTRY(entry) DEFINE(threadinfo_ ## entry, offsetof(struct thread_info, entry))
+	ENTRY(task);
 	ENTRY(flags);
 	ENTRY(addr_limit);
 	ENTRY(preempt_count);
@@ -65,5 +72,11 @@
 	DEFINE(SIZEOF_PBE, sizeof(struct pbe));
 	DEFINE(pbe_address, offsetof(struct pbe, address));
 	DEFINE(pbe_orig_address, offsetof(struct pbe, orig_address));
+#ifdef CONFIG_OPENMOSIX
+	DEFINE(OM_dflags, offsetof(struct openmosix_task, dflags));
+	BLANK();
+	DEFINE(DDEPUTY, DDEPUTY);
+	DEFINE(DREMOTE, DREMOTE);
+#endif /* CONFIG_OPENMOSIX */
 	return 0;
 }
diff -Naur linux-2.6.11/arch/x86_64/kernel/entry.S linux-2.6.11-om/arch/x86_64/kernel/entry.S
--- linux-2.6.11/arch/x86_64/kernel/entry.S	2005-03-02 08:37:58.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/entry.S	2005-05-15 23:18:04.000000000 +0200
@@ -42,6 +42,10 @@
 #include <asm/thread_info.h>
 #include <asm/hw_irq.h>
 
+#ifdef CONFIG_OPENMOSIX
+#include "omasm.h"
+#endif /* CONFIG_OPENMOSIX */
+
 	.code64
 
 #ifdef CONFIG_PREEMPT
@@ -147,6 +151,15 @@
 	jmp rff_action
 	CFI_ENDPROC
 
+#ifdef CONFIG_OPENMOSIX
+ENTRY(ret_from_kickstart)
+	CFI_STARTPROC
+	swapgs
+	RESTORE_ALL 8
+	iretq
+	CFI_ENDPROC
+#endif /* CONFIG OPENMOSIX */
+
 /*
  * System call entry. Upto 6 arguments in registers are supported.
  *
@@ -188,6 +201,20 @@
 	jnz tracesys
 	cmpq $__NR_syscall_max,%rax
 	ja badsys
+#ifdef CONFIG_OPENMOSIX
+remote_or_local_syscall:
+	movq threadinfo_task(%rcx), %rcx
+	testq $DREMOTE, TASK_om+OM_dflags(%rcx) # is this a DREMOTE task ?
+	jz syscall_call
+remote_syscall_call:
+	movq %r10,%rcx
+	subq $6*8, %rsp
+	call *remote_sys_call_table(,%rax,8)
+	addq $6*8, %rsp
+	movq %rax,RAX-ARGOFFSET(%rsp)
+	jmp ret_from_sys_call
+syscall_call:
+#endif /* CONFIG_OPENMOSIX */
 	movq %r10,%rcx
 	call *sys_call_table(,%rax,8)  # XXX:	 rip relative
 	movq %rax,RAX-ARGOFFSET(%rsp)
@@ -324,6 +351,13 @@
  */ 								
 	
 	.macro PTREGSCALL label,func,arg
+#ifdef CONFIG_OPENMOSIX
+	.globl om_\label
+om_\label:
+	leaq	om_\func(%rip),%rax
+	leaq    -ARGOFFSET+8(%rsp),\arg /* 8 for return address */
+	jmp	om_ptregscall_common
+#endif
 	.globl \label
 \label:
 	leaq	\func(%rip),%rax
@@ -354,6 +388,26 @@
 	ret
 	CFI_ENDPROC
 	
+#ifdef CONFIG_OPENMOSIX
+ENTRY(om_ptregscall_common)
+	CFI_STARTPROC
+	addq $6*8, %rsp
+	popq %r11
+	CFI_ADJUST_CFA_OFFSET	-8
+	SAVE_REST
+	movq %r11, %r15
+	FIXUP_TOP_OF_STACK %r11
+	call *%rax
+	RESTORE_TOP_OF_STACK %r11
+	movq %r15, %r11
+	RESTORE_REST
+	pushq %r11
+	subq $6*8, %rsp
+	CFI_ADJUST_CFA_OFFSET	8
+	ret
+	CFI_ENDPROC
+#endif
+
 ENTRY(stub_execve)
 	CFI_STARTPROC
 	popq %r11
@@ -484,6 +538,11 @@
 	bt    $TIF_NEED_RESCHED,%edx
 	jnc   retint_signal
 	sti
+#ifdef CONFIG_OPENMOSIX
+	SAVE_REST
+	call openmosix_pre_usermode
+	RESTORE_REST
+#endif /* CONFIG_OPENMOSIX */
 	pushq %rdi
 	call  schedule
 	popq %rdi		
@@ -762,6 +821,43 @@
 	xorq %rdi, %rdi
 	call do_exit
 
+#ifdef CONFIG_OPENMOSIX
+ENTRY(user_thread)
+	CFI_STARTPROC
+	FAKE_STACK_FRAME $user_child_rip
+	SAVE_ALL
+
+	# rdi: flags, rsi: usp, rdx: will be &pt_regs
+	movq %rdx,%rdi
+	orq  kernel_thread_flags(%rip),%rdi
+	movq $-1, %rsi
+	movq %rsp, %rdx
+
+	xorl %r8d,%r8d
+	xorl %r9d,%r9d
+	
+	# clone now
+	call do_fork
+	movq %rax,RAX(%rsp)
+	xorl %edi,%edi
+
+	/*
+	 * It isn't worth to check for reschedule here,
+	 * so internally to the x86_64 port you can rely on kernel_thread()
+	 * not to reschedule the child before returning, this avoids the need
+	 * of hacks for example to fork off the per-CPU idle tasks.
+         * [Hopefully no generic code relies on the reschedule -AK]	
+	 */
+	RESTORE_ALL
+	UNFAKE_STACK_FRAME
+	ret
+	CFI_ENDPROC
+
+user_child_rip:
+	subq $168, %rsp
+	jmp child_rip
+#endif /* CONFIG_OPENMOSIX */
+
 /*
  * execve(). This function needs to use IRET, not SYSRET, to set up all state properly.
  *
diff -Naur linux-2.6.11/arch/x86_64/kernel/irq.c linux-2.6.11-om/arch/x86_64/kernel/irq.c
--- linux-2.6.11/arch/x86_64/kernel/irq.c	2005-03-02 08:38:07.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/irq.c	2005-05-15 23:18:04.000000000 +0200
@@ -102,7 +102,7 @@
 
 	__do_IRQ(irq, regs);
 	irq_exit();
+	kgdb_process_breakpoint();
 
 	return 1;
 }
-
diff -Naur linux-2.6.11/arch/x86_64/kernel/kgdb_stub.c linux-2.6.11-om/arch/x86_64/kernel/kgdb_stub.c
--- linux-2.6.11/arch/x86_64/kernel/kgdb_stub.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/kgdb_stub.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,2591 @@
+/*
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * General Public License for more details.
+ *
+ */
+
+/*
+ * Copyright (c) 2000 VERITAS Software Corporation.
+ *
+ */
+/****************************************************************************
+ *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
+ *
+ *  Module name: remcom.c $
+ *  Revision: 1.34 $
+ *  Date: 91/03/09 12:29:49 $
+ *  Contributor:     Lake Stevens Instrument Division$
+ *
+ *  Description:     low level support for gdb debugger. $
+ *
+ *  Considerations:  only works on target hardware $
+ *
+ *  Written by:	     Glenn Engel $
+ *  Updated by:	     David Grothe <dave@gcom.com>
+ *  Updated by:	     Robert Walsh <rjwalsh@durables.org>
+ *  Updated by:	     wangdi <wangdi@clusterfs.com>
+ *  ModuleState:     Experimental $
+ *
+ *  NOTES:	     See Below $
+ *
+ *  Modified for 386 by Jim Kingdon, Cygnus Support.
+ *  Compatibility with 2.1.xx kernel by David Grothe <dave@gcom.com>
+ *
+ *  Changes to allow auto initilization.  All that is needed is that it
+ *  be linked with the kernel and a break point (int 3) be executed.
+ *  The header file <asm/kgdb.h> defines BREAKPOINT to allow one to do
+ *  this. It should also be possible, once the interrupt system is up, to
+ *  call putDebugChar("+").  Once this is done, the remote debugger should
+ *  get our attention by sending a ^C in a packet. George Anzinger
+ *  <george@mvista.com>
+ *  Integrated into 2.2.5 kernel by Tigran Aivazian <tigran@sco.com>
+ *  Added thread support, support for multiple processors,
+ *	support for ia-32(x86) hardware debugging.
+ *	Amit S. Kale ( akale@veritas.com )
+ *
+ *  Modified to support debugging over ethernet by Robert Walsh
+ *  <rjwalsh@durables.org> and wangdi <wangdi@clusterfs.com>, based on
+ *  code by San Mehat.
+ *
+ *  X86_64 changes from Andi Kleen's patch merged by Jim Houston
+ * 	(jim.houston@ccur.com).  If it works thank Andi if its broken
+ * 	blame me.
+ *
+ *  To enable debugger support, two things need to happen.  One, a
+ *  call to set_debug_traps() is necessary in order to allow any breakpoints
+ *  or error conditions to be properly intercepted and reported to gdb.
+ *  Two, a breakpoint needs to be generated to begin communication.  This
+ *  is most easily accomplished by a call to breakpoint().  Breakpoint()
+ *  simulates a breakpoint by executing an int 3.
+ *
+ *************
+ *
+ *    The following gdb commands are supported:
+ *
+ * command	    function				   Return value
+ *
+ *    g		    return the value of the CPU registers  hex data or ENN
+ *    G		    set the value of the CPU registers	   OK or ENN
+ *
+ *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA	   hex data or ENN
+ *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA	   OK or ENN
+ *
+ *    c		    Resume at current address		   SNN	 ( signal NN)
+ *    cAA..AA	    Continue at address AA..AA		   SNN
+ *
+ *    s		    Step one instruction		   SNN
+ *    sAA..AA	    Step one instruction from AA..AA	   SNN
+ *
+ *    k		    kill
+ *
+ *    ?		    What was the last sigval ?		   SNN	 (signal NN)
+ *
+ * All commands and responses are sent with a packet which includes a
+ * checksum.  A packet consists of
+ *
+ * $<packet info>#<checksum>.
+ *
+ * where
+ * <packet info> :: <characters representing the command or response>
+ * <checksum>	 :: < two hex digits computed as modulo 256 sum of <packetinfo>>
+ *
+ * When a packet is received, it is first acknowledged with either '+' or '-'.
+ * '+' indicates a successful transfer.	 '-' indicates a failed transfer.
+ *
+ * Example:
+ *
+ * Host:		  Reply:
+ * $m0,10#2a		   +$00010203040506070809101112131415#42
+ *
+ ****************************************************************************/
+#define KGDB_VERSION "<20030915.1651.33>"
+#include <linux/config.h>
+#include <linux/types.h>
+#include <asm/string.h>		/* for strcpy */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>		/* for linux pt_regs struct */
+#include <asm/kgdb_local.h>
+#include <linux/list.h>
+#include <asm/atomic.h>
+#include <asm/processor.h>
+#include <linux/irq.h>
+#include <asm/desc.h>
+#include <linux/inet.h>
+#include <linux/netpoll.h>
+#include <linux/cpumask.h>
+#include <linux/bitops.h>
+#include <linux/notifier.h>
+#include <asm/kdebug.h>
+#include <asm/uaccess.h>
+#include <linux/ptrace.h>
+
+#define Dearly_printk(x...)
+int kgdb_enabled = 0;
+
+/************************************************************************
+ *
+ * external low-level support routines
+ */
+typedef void (*Function) (void);	/* pointer to a function */
+
+/* Thread reference */
+typedef unsigned char threadref[8];
+
+extern int tty_putDebugChar(int);     /* write a single character      */
+extern int tty_getDebugChar(void);    /* read and return a single char */
+extern void tty_flushDebugChar(void); /* flush pending characters      */
+extern int eth_putDebugChar(int);     /* write a single character      */
+extern int eth_getDebugChar(void);    /* read and return a single char */
+extern void eth_flushDebugChar(void); /* flush pending characters      */
+
+/************************************************************************/
+/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
+/* at least NUMREGBYTES*2 are needed for register packets */
+/* Longer buffer is needed to list all threads */
+#define BUFMAX 400
+
+char *kgdb_version = KGDB_VERSION;
+
+/*  debug >  0 prints ill-formed commands in valid packets & checksum errors */
+int debug_regs = 0;		/* set to non-zero to print registers */
+
+/* filled in by an external module */
+char *gdb_module_offsets;
+
+static const char hexchars[] = "0123456789abcdef";
+
+/* Number of bytes of registers.  */
+#define NUMREGBYTES (NUMREGS * sizeof(unsigned long))
+/*
+ * Note that this register image is in a different order than
+ * the register image that Linux produces at interrupt time.
+ *
+ * Linux's register image is defined by struct pt_regs in ptrace.h.
+ * Just why GDB uses a different order is a historical mystery.
+ *
+ * Could add XMM and segment registers here.
+ */
+enum regnames {_RAX,
+	       _RBX,
+	       _RCX,
+	       _RDX,
+	       _RSI,
+	       _RDI,
+	       _RBP,
+	       _RSP,
+	       _R8,
+	       _R9,
+	       _R10,
+	       _R11,
+	       _R12,
+	       _R13,
+	       _R14,
+	       _R15,
+	       _PC,
+	       _PS,
+	       NUMREGS };
+
+
+/***************************  ASSEMBLY CODE MACROS *************************/
+/*
+ * Put the error code here just in case the user cares.
+ * Likewise, the vector number here (since GDB only gets the signal
+ * number through the usual means, and that's not very specific).
+ * The called_from is the return address so he can tell how we entered kgdb.
+ * This will allow him to seperate out the various possible entries.
+ */
+#define REMOTE_DEBUG 0		/* set != to turn on printing (also available in info) */
+
+#define PID_MAX PID_MAX_DEFAULT
+
+#ifdef CONFIG_SMP
+void smp_send_nmi_allbutself(void);
+#define IF_SMP(x) x
+#undef MAX_NO_CPUS
+#ifndef CONFIG_NO_KGDB_CPUS
+#define CONFIG_NO_KGDB_CPUS 2
+#endif
+#if CONFIG_NO_KGDB_CPUS > NR_CPUS
+#define MAX_NO_CPUS NR_CPUS
+#else
+#define MAX_NO_CPUS CONFIG_NO_KGDB_CPUS
+#endif
+#define hold_init hold_on_sstep: 1,
+#define MAX_CPU_MASK (unsigned long)((1LL << MAX_NO_CPUS) - 1LL)
+#define NUM_CPUS num_online_cpus()
+#else
+#define IF_SMP(x)
+#define hold_init
+#undef MAX_NO_CPUS
+#define MAX_NO_CPUS 1
+#define NUM_CPUS 1
+#endif
+#define NOCPU (struct task_struct *)0xbad1fbad
+/* *INDENT-OFF*	 */
+struct kgdb_info {
+	int used_malloc;
+	void *called_from;
+	long long entry_tsc;
+	int errcode;
+	int vector;
+	int print_debug_info;
+#ifdef CONFIG_SMP
+	int hold_on_sstep;
+	struct {
+		volatile struct task_struct *task;
+		int pid;
+		int hold;
+		struct pt_regs *regs;
+	} cpus_waiting[MAX_NO_CPUS];
+#endif
+} kgdb_info = {hold_init print_debug_info:REMOTE_DEBUG, vector:-1};
+
+/* *INDENT-ON*	*/
+
+#define used_m kgdb_info.used_malloc
+/*
+ * This is little area we set aside to contain the stack we
+ * need to build to allow gdb to call functions.  We use one
+ * per cpu to avoid locking issues.  We will do all this work
+ * with interrupts off so that should take care of the protection
+ * issues.
+ */
+#define LOOKASIDE_SIZE 200	/* should be more than enough */
+#define MALLOC_MAX   200	/* Max malloc size */
+struct {
+	unsigned long rsp;
+	unsigned long array[LOOKASIDE_SIZE];
+} fn_call_lookaside[MAX_NO_CPUS];
+
+static int trap_cpu;
+static unsigned long OLD_esp;
+
+#define END_OF_LOOKASIDE  &fn_call_lookaside[trap_cpu].array[LOOKASIDE_SIZE]
+#define IF_BIT 0x200
+#define TF_BIT 0x100
+
+#define MALLOC_ROUND 8-1
+
+static char malloc_array[MALLOC_MAX];
+IF_SMP(static void to_gdb(const char *mess));
+void *
+malloc(int size)
+{
+
+	if (size <= (MALLOC_MAX - used_m)) {
+		int old_used = used_m;
+		used_m += ((size + MALLOC_ROUND) & (~MALLOC_ROUND));
+		return &malloc_array[old_used];
+	} else {
+		return NULL;
+	}
+}
+
+/*
+ * I/O dispatch functions...
+ * Based upon kgdboe, either call the ethernet
+ * handler or the serial one..
+ */
+void
+putDebugChar(int c)
+{
+	if (!kgdboe) {
+		tty_putDebugChar(c);
+	} else {
+		eth_putDebugChar(c);
+	}
+}
+
+int
+getDebugChar(void)
+{
+	if (!kgdboe) {
+		return tty_getDebugChar();
+	} else {
+		return eth_getDebugChar();
+	}
+}
+
+void
+flushDebugChar(void)
+{
+	if (!kgdboe) {
+		tty_flushDebugChar();
+	} else {
+		eth_flushDebugChar();
+	}
+}
+
+/*
+ * Gdb calls functions by pushing agruments, including a return address
+ * on the stack and the adjusting EIP to point to the function.	 The
+ * whole assumption in GDB is that we are on a different stack than the
+ * one the "user" i.e. code that hit the break point, is on.  This, of
+ * course is not true in the kernel.  Thus various dodges are needed to
+ * do the call without directly messing with EIP (which we can not change
+ * as it is just a location and not a register.	 To adjust it would then
+ * require that we move every thing below EIP up or down as needed.  This
+ * will not work as we may well have stack relative pointer on the stack
+ * (such as the pointer to regs, for example).
+
+ * So here is what we do:
+ * We detect gdb attempting to store into the stack area and instead, store
+ * into the fn_call_lookaside.array at the same relative location as if it
+ * were the area ESP pointed at.  We also trap ESP modifications
+ * and uses these to adjust fn_call_lookaside.esp.  On entry
+ * fn_call_lookaside.esp will be set to point at the last entry in
+ * fn_call_lookaside.array.  This allows us to check if it has changed, and
+ * if so, on exit, we add the registers we will use to do the move and a
+ * trap/ interrupt return exit sequence.  We then adjust the eflags in the
+ * regs array (remember we now have a copy in the fn_call_lookaside.array) to
+ * kill the interrupt bit, AND we change EIP to point at our set up stub.
+ * As part of the register set up we preset the registers to point at the
+ * begining and end of the fn_call_lookaside.array, so all the stub needs to
+ * do is move words from the array to the stack until ESP= the desired value
+ * then do the rti.  This will then transfer to the desired function with
+ * all the correct registers.  Nifty huh?
+ */
+extern asmlinkage void fn_call_stub(void);
+extern asmlinkage void fn_rtn_stub(void);
+/*					   *INDENT-OFF*	 */
+__asm__("fn_rtn_stub:\n\t"
+	"movq %rax,%rsp\n\t"
+	"fn_call_stub:\n\t"
+	"1:\n\t"
+	"addq $-8,%rbx\n\t"
+	"movq (%rbx), %rax\n\t"
+	"pushq %rax\n\t"
+	"cmpq %rsp,%rcx\n\t"
+	"jne  1b\n\t"
+	"popq %rax\n\t"
+	"popq %rbx\n\t"
+	"popq %rcx\n\t"
+	"iret \n\t");
+/*					     *INDENT-ON*  */
+#define gdb_i386vector	kgdb_info.vector
+#define gdb_i386errcode kgdb_info.errcode
+#define waiting_cpus	kgdb_info.cpus_waiting
+#define remote_debug	kgdb_info.print_debug_info
+#define hold_cpu(cpu)	kgdb_info.cpus_waiting[cpu].hold
+/* gdb locks */
+
+#ifdef CONFIG_SMP
+static int in_kgdb_called;
+static spinlock_t waitlocks[MAX_NO_CPUS] =
+    {[0 ... MAX_NO_CPUS - 1] = SPIN_LOCK_UNLOCKED };
+/*
+ * The following array has the thread pointer of each of the "other"
+ * cpus.  We make it global so it can be seen by gdb.
+ */
+volatile int in_kgdb_entry_log[MAX_NO_CPUS];
+volatile struct pt_regs *in_kgdb_here_log[MAX_NO_CPUS];
+/*
+static spinlock_t continuelocks[MAX_NO_CPUS];
+*/
+spinlock_t kgdb_spinlock = SPIN_LOCK_UNLOCKED;
+/* waiters on our spinlock plus us */
+static atomic_t spinlock_waiters = ATOMIC_INIT(1);
+static int spinlock_count = 0;
+static int spinlock_cpu = 0;
+/*
+ * Note we use nested spin locks to account for the case where a break
+ * point is encountered when calling a function by user direction from
+ * kgdb. Also there is the memory exception recursion to account for.
+ * Well, yes, but this lets other cpus thru too.  Lets add a
+ * cpu id to the lock.
+ */
+#define KGDB_SPIN_LOCK(x) if( spinlock_count == 0 || \
+			      spinlock_cpu != smp_processor_id()){\
+				      atomic_inc(&spinlock_waiters); \
+				      while (! spin_trylock(x)) {\
+					    in_kgdb(&regs);\
+				      }\
+				      atomic_dec(&spinlock_waiters); \
+				      spinlock_count = 1; \
+				      spinlock_cpu = smp_processor_id(); \
+			  }else{  \
+				      spinlock_count++; \
+			  }
+#define KGDB_SPIN_UNLOCK(x) if( --spinlock_count == 0) spin_unlock(x)
+#else
+unsigned kgdb_spinlock = 0;
+#define KGDB_SPIN_LOCK(x) --*x
+#define KGDB_SPIN_UNLOCK(x) ++*x
+#endif
+
+int
+hex(char ch)
+{
+	if ((ch >= 'a') && (ch <= 'f'))
+		return (ch - 'a' + 10);
+	if ((ch >= '0') && (ch <= '9'))
+		return (ch - '0');
+	if ((ch >= 'A') && (ch <= 'F'))
+		return (ch - 'A' + 10);
+	return (-1);
+}
+
+/* scan for the sequence $<data>#<checksum>	*/
+void
+getpacket(char *buffer)
+{
+	unsigned char checksum;
+	unsigned char xmitcsum;
+	int i;
+	int count;
+	char ch;
+
+	do {
+		/* wait around for the start character, ignore all other characters */
+		while ((ch = (getDebugChar() & 0x7f)) != '$') ;
+		checksum = 0;
+		xmitcsum = -1;
+
+		count = 0;
+
+		/* now, read until a # or end of buffer is found */
+		while (count < BUFMAX) {
+			ch = getDebugChar() & 0x7f;
+			if (ch == '#')
+				break;
+			checksum = checksum + ch;
+			buffer[count] = ch;
+			count = count + 1;
+		}
+		buffer[count] = 0;
+
+		if (ch == '#') {
+			xmitcsum = hex(getDebugChar() & 0x7f) << 4;
+			xmitcsum += hex(getDebugChar() & 0x7f);
+			if ((remote_debug) && (checksum != xmitcsum)) {
+				printk
+				    ("bad checksum.	My count = 0x%x, sent=0x%x. buf=%s\n",
+				     checksum, xmitcsum, buffer);
+			}
+
+			if (checksum != xmitcsum)
+				putDebugChar('-');	/* failed checksum */
+			else {
+				putDebugChar('+');	/* successful transfer */
+				/* if a sequence char is present, reply the sequence ID */
+				if (buffer[2] == ':') {
+					putDebugChar(buffer[0]);
+					putDebugChar(buffer[1]);
+					/* remove sequence chars from buffer */
+					count = strlen(buffer);
+					for (i = 3; i <= count; i++)
+						buffer[i - 3] = buffer[i];
+				}
+			}
+		}
+	} while (checksum != xmitcsum);
+
+	if (remote_debug)
+		printk("R:%s\n", buffer);
+	flushDebugChar();
+}
+
+/* send the packet in buffer.  */
+
+void
+putpacket(char *buffer)
+{
+	unsigned char checksum;
+	int count;
+	char ch;
+
+	/*  $<packet info>#<checksum>. */
+
+	if (!kgdboe) {
+		do {
+			if (remote_debug)
+				printk("T:%s\n", buffer);
+			putDebugChar('$');
+			checksum = 0;
+			count = 0;
+
+			while ((ch = buffer[count])) {
+				putDebugChar(ch);
+				checksum += ch;
+				count += 1;
+			}
+
+			putDebugChar('#');
+			putDebugChar(hexchars[checksum >> 4]);
+			putDebugChar(hexchars[checksum % 16]);
+			flushDebugChar();
+
+		} while ((getDebugChar() & 0x7f) != '+');
+	} else {
+		/*
+		 * For udp, we can not transfer too much bytes once.
+		 * We only transfer MAX_SEND_COUNT size bytes each time
+		 */
+
+#define MAX_SEND_COUNT 30
+
+		int send_count = 0, i = 0;
+		char send_buf[MAX_SEND_COUNT];
+
+		do {
+			if (remote_debug)
+				printk("T:%s\n", buffer);
+			putDebugChar('$');
+			checksum = 0;
+			count = 0;
+			send_count = 0;
+			while ((ch = buffer[count])) {
+				if (send_count >= MAX_SEND_COUNT) {
+					for(i = 0; i < MAX_SEND_COUNT; i++) {
+						putDebugChar(send_buf[i]);
+					}
+					flushDebugChar();
+					send_count = 0;
+				} else {
+					send_buf[send_count] = ch;
+					checksum += ch;
+					count ++;
+					send_count++;
+				}
+			}
+			for(i = 0; i < send_count; i++)
+				putDebugChar(send_buf[i]);
+			putDebugChar('#');
+			putDebugChar(hexchars[checksum >> 4]);
+			putDebugChar(hexchars[checksum % 16]);
+			flushDebugChar();
+		} while ((getDebugChar() & 0x7f) != '+');
+	}
+}
+
+static char remcomInBuffer[BUFMAX];
+static char remcomOutBuffer[BUFMAX];
+static char lbuf[BUFMAX];
+static short error;
+
+void
+debug_error(char *format, char *parm)
+{
+	if (remote_debug)
+		printk(format, parm);
+}
+
+static void
+print_regs(struct pt_regs *regs)
+{
+	printk("RAX=%016lx RBX=%016lx RCX=%016lx\n",
+		regs->rax, regs->rbx, regs->rcx);
+	printk("RDX=%016lx RSI=%016lx RDI=%016lx\n",
+		regs->rdx, regs->rsi, regs->rdi);
+	printk("RBP=%016lx PS=%016lx PC=%016lx\n",
+		regs->rbp, regs->eflags, regs->rip);
+ 	printk("R8=%016lx R9=%016lx R10=%016lx\n",
+		regs->r8, regs->r9, regs->r10);
+	printk("R11=%016lx R12=%016lx R13=%016lx\n",
+		regs->r11, regs->r12, regs->r13);
+	printk("R14=%016lx R15=%016lx RSP=%016lx\n",
+		regs->r14, regs->r15, regs->rsp);
+}
+
+#define NEW_esp fn_call_lookaside[trap_cpu].rsp
+
+static void
+regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)
+{
+	gdb_regs[_RAX] =  regs->rax;
+	gdb_regs[_RBX] =  regs->rbx;
+	gdb_regs[_RCX] =  regs->rcx;
+	gdb_regs[_RDX] =  regs->rdx;
+	gdb_regs[_RSI] =  regs->rsi;
+	gdb_regs[_RDI] =  regs->rdi;
+	gdb_regs[_RBP] =  regs->rbp;
+	gdb_regs[ _PS] =  regs->eflags;
+	gdb_regs[ _PC] =  regs->rip;
+	gdb_regs[ _R8] =  regs->r8;
+	gdb_regs[ _R9] =  regs->r9;
+	gdb_regs[_R10] = regs->r10;
+	gdb_regs[_R11] = regs->r11;
+	gdb_regs[_R12] = regs->r12;
+	gdb_regs[_R13] = regs->r13;
+	gdb_regs[_R14] = regs->r14;
+	gdb_regs[_R15] = regs->r15;
+	gdb_regs[_RSP] =  regs->rsp;
+
+	/* Note, as we are a debugging the kernel, we will always
+	 * trap in kernel code, this means no priviledge change,
+	 * and so the pt_regs structure is not completely valid.  In a non
+	 * privilege change trap, only EFLAGS, CS and EIP are put on the stack,
+	 * SS and ESP are not stacked, this means that the last 2 elements of
+	 * pt_regs is not valid (they would normally refer to the user stack)
+	 * also, using regs+1 is no good because you end up will a value that is
+	 * 2 longs (8) too high.  This used to cause stepping over functions
+	 * to fail, so my fix is to use the address of regs->esp, which
+	 * should point at the end of the stack frame.	Note I have ignored
+	 * completely exceptions that cause an error code to be stacked, such
+	 * as double fault.  Stuart Hughes, Zentropix.
+	 * original code: gdb_regs[_ESP] =  (int) (regs + 1) ;
+
+	 * this is now done on entry and moved to OLD_esp (as well as NEW_esp).
+	 */
+}
+
+static void
+gdb_regs_to_regs(unsigned long *gdb_regs, struct pt_regs *regs)
+{
+	regs->rax	=     gdb_regs[_RAX] ;
+	regs->rbx	=     gdb_regs[_RBX] ;
+	regs->rcx	=     gdb_regs[_RCX] ;
+	regs->rdx	=     gdb_regs[_RDX] ;
+	regs->rsi	=     gdb_regs[_RSI] ;
+	regs->rdi	=     gdb_regs[_RDI] ;
+	regs->rbp	=     gdb_regs[_RBP] ;
+	regs->eflags	=     gdb_regs[ _PS] ;
+	regs->rip	=     gdb_regs[ _PC] ;
+	regs->r8	=     gdb_regs[ _R8] ;
+	regs->r9	=     gdb_regs[ _R9] ;
+	regs->r10	=     gdb_regs[ _R10] ;
+	regs->r11	=     gdb_regs[ _R11] ;
+	regs->r12	=     gdb_regs[ _R12] ;
+	regs->r13	=     gdb_regs[ _R13] ;
+	regs->r14	=     gdb_regs[ _R14] ;
+	regs->r15	=     gdb_regs[ _R15] ;
+ #if 0					/* can't change these */
+	regs->rsp	=     gdb_regs[_RSP] ;
+	regs->ss	=     gdb_regs[ _SS] ;
+	regs->fs = gdb_regs[_FS];
+	regs->gs = gdb_regs[_GS];
+#endif
+}				/* gdb_regs_to_regs */
+
+int thread_list = 0;
+extern void thread_return(void);
+
+void
+get_gdb_regs(struct task_struct *p, struct pt_regs *regs, unsigned long *gdb_regs)
+{
+	unsigned long **rbp, *rsp, *rsp0, pc;
+	int count = 0;
+	IF_SMP(int i);
+	if (!p || p == current) {
+		regs_to_gdb_regs(gdb_regs, regs);
+		return;
+	}
+#ifdef CONFIG_SMP
+	for (i = 0; i < MAX_NO_CPUS; i++) {
+		if (p == kgdb_info.cpus_waiting[i].task) {
+			regs_to_gdb_regs(gdb_regs,
+					 kgdb_info.cpus_waiting[i].regs);
+			gdb_regs[_RSP] =
+			    (unsigned long)&kgdb_info.cpus_waiting[i].regs->rsp;
+
+			return;
+		}
+	}
+#endif
+	memset(gdb_regs, 0, NUMREGBYTES);
+	rsp = (unsigned long *)p->thread.rsp;
+	rbp = (unsigned long **)rsp[0];
+	rsp += 2;
+	gdb_regs[_PC] =  (unsigned long)thread_return;
+	gdb_regs[_RBP] = (unsigned long)rbp;
+	gdb_regs[_RSP] = (unsigned long)rsp;
+
+/*
+ * This code is to give a more informative notion of where a process
+ * is waiting.	It is used only when the user asks for a thread info
+ * list.  If he then switches to the thread, s/he will find the task
+ * is in schedule, but a back trace should show the same info we come
+ * up with.  This code was shamelessly purloined from process.c.  It was
+ * then enhanced to provide more registers than simply the program
+ * counter.
+ */
+
+	if (!thread_list) {
+		return;
+	}
+
+	if (p->state == TASK_RUNNING)
+		return;
+	rsp0 = (unsigned long *)p->thread.rsp0;
+	if (rsp < (unsigned long *) p->thread_info || rsp > rsp0)
+		return;
+	/* include/asm-i386/system.h:switch_to() pushes ebp last. */
+	do {
+		if (*rbp < rsp || *rbp > rsp0)
+			break;
+		rbp = (unsigned long **)*rbp;
+		rsp = (unsigned long *)rbp;
+		pc = rsp[1];
+
+		if (!in_sched_functions(pc))
+			break;
+		gdb_regs[_PC] = (unsigned long)pc;
+		gdb_regs[_RSP] = (unsigned long)rsp;
+		gdb_regs[_RBP] = (unsigned long)rbp;
+	} while (count++ < 16);
+	return;
+}
+
+/* convert the memory pointed to by mem into hex, placing result in buf */
+/* returns nonzero if any memory access fails. */
+int mem2hex( char* mem, char* buf, int   count)
+{
+	int i;
+	unsigned char ch;
+	int ret = 0;
+
+	for (i=0;i<count;i++) {
+		ch = 0;
+		ret |= __get_user(ch, mem);
+		mem++;
+		*buf++ = hexchars[ch >> 4];
+		*buf++ = hexchars[ch % 16];
+	}
+	*buf = 0;
+	if (ret) {
+		Dearly_printk("mem2hex: fault at accessing %p\n", mem);
+	}
+	return(ret);
+}
+
+/* convert the hex array pointed to by buf into binary to be placed in mem */
+/* return nonzero if any memory access fails. */
+int hex2mem( char* buf, char* mem, int count)
+{
+	int i;
+	unsigned char ch;
+	int ret = 0;
+
+	for (i=0;i<count;i++) {
+		ch = hex(*buf++) << 4;
+		ch = ch + hex(*buf++);
+		ret |= __put_user(ch, mem);
+		mem++;
+	}
+	if (ret) {
+		Dearly_printk("hex2mem: fault at %p\n", mem);
+	}
+	return(ret);
+}
+
+#if 0
+/* Indicate to caller of mem2hex or hex2mem that there has been an
+   error.  */
+static volatile int mem_err = 0;
+static volatile int mem_err_expected = 0;
+static volatile int mem_err_cnt = 0;
+static int garbage_loc = -1;
+
+int
+get_char(char *addr)
+{
+	return *addr;
+}
+
+void
+set_char(char *addr, int val, int may_fault)
+{
+	/*
+	 * This code traps references to the area mapped to the kernel
+	 * stack as given by the regs and, instead, stores to the
+	 * fn_call_lookaside[cpu].array
+	 */
+	if (may_fault &&
+	    (unsigned int) addr < OLD_esp &&
+	    ((unsigned int) addr > (OLD_esp - (unsigned int) LOOKASIDE_SIZE))) {
+		addr = (char *) END_OF_LOOKASIDE - ((char *) OLD_esp - addr);
+	}
+	*addr = val;
+}
+
+/* convert the memory pointed to by mem into hex, placing result in buf */
+/* return a pointer to the last char put in buf (null) */
+/* If MAY_FAULT is non-zero, then we should set mem_err in response to
+   a fault; if zero treat a fault like any other fault in the stub.  */
+char *
+mem2hex(char *mem, char *buf, int count, int may_fault)
+{
+	int i;
+	unsigned char ch;
+
+	if (may_fault) {
+		mem_err_expected = 1;
+		mem_err = 0;
+	}
+	for (i = 0; i < count; i++) {
+		/* printk("%lx = ", mem) ; */
+
+		ch = get_char(mem++);
+
+		/* printk("%02x\n", ch & 0xFF) ; */
+		if (may_fault && mem_err) {
+			if (remote_debug)
+				printk("Mem fault fetching from addr %lx\n",
+				       (long) (mem - 1));
+			*buf = 0;	/* truncate buffer */
+			return (buf);
+		}
+		*buf++ = hexchars[ch >> 4];
+		*buf++ = hexchars[ch % 16];
+	}
+	*buf = 0;
+	if (may_fault)
+		mem_err_expected = 0;
+	return (buf);
+}
+
+/* convert the hex array pointed to by buf into binary to be placed in mem */
+/* return a pointer to the character AFTER the last byte written */
+/* NOTE: We use the may fault flag to also indicate if the write is to
+ * the registers (0) or "other" memory (!=0)
+ */
+char *
+hex2mem(char *buf, char *mem, int count, int may_fault)
+{
+	int i;
+	unsigned char ch;
+
+	if (may_fault) {
+		mem_err_expected = 1;
+		mem_err = 0;
+	}
+	for (i = 0; i < count; i++) {
+		ch = hex(*buf++) << 4;
+		ch = ch + hex(*buf++);
+		set_char(mem++, ch, may_fault);
+
+		if (may_fault && mem_err) {
+			if (remote_debug)
+				printk("Mem fault storing to addr %lx\n",
+				       (long) (mem - 1));
+			return (mem);
+		}
+	}
+	if (may_fault)
+		mem_err_expected = 0;
+	return (mem);
+}
+#endif
+
+/**********************************************/
+/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
+/* RETURN NUMBER OF CHARS PROCESSED	      */
+/**********************************************/
+int
+hexToLong(char **ptr, unsigned long *value)
+{
+	int numChars = 0;
+	int hexValue;
+
+	*value = 0;
+
+	while (**ptr) {
+		hexValue = hex(**ptr);
+		if (hexValue >= 0) {
+			*value = (*value << 4) | hexValue;
+			numChars++;
+		} else
+			break;
+
+		(*ptr)++;
+	}
+
+	return (numChars);
+}
+
+#define stubhex(h) hex(h)
+#ifdef old_thread_list
+
+static int
+stub_unpack_int(char *buff, int fieldlength)
+{
+	int nibble;
+	int retval = 0;
+
+	while (fieldlength) {
+		nibble = stubhex(*buff++);
+		retval |= nibble;
+		fieldlength--;
+		if (fieldlength)
+			retval = retval << 4;
+	}
+	return retval;
+}
+#endif
+static char *
+pack_hex_byte(char *pkt, int byte)
+{
+	*pkt++ = hexchars[(byte >> 4) & 0xf];
+	*pkt++ = hexchars[(byte & 0xf)];
+	return pkt;
+}
+
+#define BUF_THREAD_ID_SIZE 16
+
+static char *
+pack_threadid(char *pkt, threadref * id)
+{
+	char *limit;
+	unsigned char *altid;
+
+	altid = (unsigned char *) id;
+	limit = pkt + BUF_THREAD_ID_SIZE;
+	while (pkt < limit)
+		pkt = pack_hex_byte(pkt, *altid++);
+	return pkt;
+}
+
+#ifdef old_thread_list
+static char *
+unpack_byte(char *buf, int *value)
+{
+	*value = stub_unpack_int(buf, 2);
+	return buf + 2;
+}
+
+static char *
+unpack_threadid(char *inbuf, threadref * id)
+{
+	char *altref;
+	char *limit = inbuf + BUF_THREAD_ID_SIZE;
+	int x, y;
+
+	altref = (char *) id;
+
+	while (inbuf < limit) {
+		x = stubhex(*inbuf++);
+		y = stubhex(*inbuf++);
+		*altref++ = (x << 4) | y;
+	}
+	return inbuf;
+}
+#endif
+void
+int_to_threadref(threadref * id, int value)
+{
+	unsigned char *scan;
+
+	scan = (unsigned char *) id;
+	{
+		int i = 4;
+		while (i--)
+			*scan++ = 0;
+	}
+	*scan++ = (value >> 24) & 0xff;
+	*scan++ = (value >> 16) & 0xff;
+	*scan++ = (value >> 8) & 0xff;
+	*scan++ = (value & 0xff);
+}
+int
+int_to_hex_v(unsigned char * id, int value)
+{
+	unsigned char *start = id;
+	int shift;
+	int ch;
+
+	for (shift = 28; shift >= 0; shift -= 4) {
+		if ((ch = (value >> shift) & 0xf) || (id != start)) {
+			*id = hexchars[ch];
+			id++;
+		}
+	}
+	if (id == start)
+		*id++ = '0';
+	return id - start;
+}
+#ifdef old_thread_list
+
+static int
+threadref_to_int(threadref * ref)
+{
+	int i, value = 0;
+	unsigned char *scan;
+
+	scan = (char *) ref;
+	scan += 4;
+	i = 4;
+	while (i-- > 0)
+		value = (value << 8) | ((*scan++) & 0xff);
+	return value;
+}
+#endif
+static int
+cmp_str(char *s1, char *s2, int count)
+{
+	while (count--) {
+		if (*s1++ != *s2++)
+			return 0;
+	}
+	return 1;
+}
+
+#if 1				/* this is a hold over from 2.4 where O(1) was "sometimes" */
+extern struct task_struct *kgdb_get_idle(int cpu);
+#define idle_task(cpu) kgdb_get_idle(cpu)
+#else
+#define idle_task(cpu) init_tasks[cpu]
+#endif
+
+extern int kgdb_pid_init_done;
+
+struct task_struct *
+getthread(int pid)
+{
+	struct task_struct *thread;
+	if (pid >= PID_MAX && pid <= (PID_MAX + MAX_NO_CPUS)) {
+		if (!cpu_online(pid - PID_MAX))
+			return NULL;
+
+		return idle_task(pid - PID_MAX);
+	} else {
+		/*
+		 * find_task_by_pid is relatively safe all the time
+		 * Other pid functions require lock downs which imply
+		 * that we may be interrupting them (as we get here
+		 * in the middle of most any lock down).
+		 * Still we don't want to call until the table exists!
+		 */
+		if (kgdb_pid_init_done){
+			thread = find_task_by_pid(pid);
+			if (thread) {
+				return thread;
+			}
+		}
+	}
+	return NULL;
+}
+/* *INDENT-OFF*	 */
+struct hw_breakpoint {
+	unsigned enabled;
+	unsigned type;
+	unsigned len;
+	unsigned long addr;
+} breakinfo[4] = { {enabled:0},
+		   {enabled:0},
+		   {enabled:0},
+		   {enabled:0}};
+/* *INDENT-ON*	*/
+unsigned long hw_breakpoint_status;
+void
+correct_hw_break(void)
+{
+	int breakno;
+	int correctit;
+	int breakbit;
+	unsigned long dr7;
+
+	asm volatile ("movq %%db7, %0\n":"=r" (dr7)
+		      :);
+	/* *INDENT-OFF*	 */
+	do {
+		unsigned long addr0, addr1, addr2, addr3;
+		asm volatile ("movq %%db0, %0\n"
+			      "movq %%db1, %1\n"
+			      "movq %%db2, %2\n"
+			      "movq %%db3, %3\n"
+			      :"=r" (addr0), "=r"(addr1),
+			      "=r"(addr2), "=r"(addr3)
+			      :);
+	} while (0);
+	/* *INDENT-ON*	*/
+	correctit = 0;
+	for (breakno = 0; breakno < 3; breakno++) {
+		breakbit = 2 << (breakno << 1);
+		if (!(dr7 & breakbit) && breakinfo[breakno].enabled) {
+			correctit = 1;
+			dr7 |= breakbit;
+			dr7 &= ~(0xf0000 << (breakno << 2));
+			dr7 |= (((breakinfo[breakno].len << 2) |
+				 breakinfo[breakno].type) << 16) <<
+			    (breakno << 2);
+			switch (breakno) {
+			case 0:
+				asm volatile ("movq %0, %%dr0\n"::"r"
+					      (breakinfo[breakno].addr));
+				break;
+
+			case 1:
+				asm volatile ("movq %0, %%dr1\n"::"r"
+					      (breakinfo[breakno].addr));
+				break;
+
+			case 2:
+				asm volatile ("movq %0, %%dr2\n"::"r"
+					      (breakinfo[breakno].addr));
+				break;
+
+			case 3:
+				asm volatile ("movq %0, %%dr3\n"::"r"
+					      (breakinfo[breakno].addr));
+				break;
+			}
+		} else if ((dr7 & breakbit) && !breakinfo[breakno].enabled) {
+			correctit = 1;
+			dr7 &= ~breakbit;
+			dr7 &= ~(0xf0000 << (breakno << 2));
+		}
+	}
+	if (correctit) {
+		asm volatile ("movq %0, %%db7\n"::"r" (dr7));
+	}
+}
+
+int
+remove_hw_break(unsigned breakno)
+{
+	if (!breakinfo[breakno].enabled) {
+		return -1;
+	}
+	breakinfo[breakno].enabled = 0;
+	return 0;
+}
+
+int
+set_hw_break(unsigned breakno, unsigned type, unsigned len, unsigned addr)
+{
+	if (breakinfo[breakno].enabled) {
+		return -1;
+	}
+	breakinfo[breakno].enabled = 1;
+	breakinfo[breakno].type = type;
+	breakinfo[breakno].len = len;
+	breakinfo[breakno].addr = addr;
+	return 0;
+}
+
+#ifdef CONFIG_SMP
+static int in_kgdb_console = 0;
+
+int
+in_kgdb(struct pt_regs *regs)
+{
+	unsigned long flags;
+	int cpu;
+	if (!kgdb_enabled)
+		return 0;
+	cpu = smp_processor_id();
+	in_kgdb_called = 1;
+	if (!spin_is_locked(&kgdb_spinlock)) {
+		if (in_kgdb_here_log[cpu] ||	/* we are holding this cpu */
+		    in_kgdb_console) {	/* or we are doing slow i/o */
+			return 1;
+		}
+		return 0;
+	}
+
+	/* As I see it the only reason not to let all cpus spin on
+	 * the same spin_lock is to allow selected ones to proceed.
+	 * This would be a good thing, so we leave it this way.
+	 * Maybe someday....  Done !
+
+	 * in_kgdb() is called from an NMI so we don't pretend
+	 * to have any resources, like printk() for example.
+	 */
+
+	local_irq_save(flags);	/* only local here, to avoid hanging */
+	/*
+	 * log arival of this cpu
+	 * The NMI keeps on ticking.  Protect against recurring more
+	 * than once, and ignor the cpu that has the kgdb lock
+	 */
+	in_kgdb_entry_log[cpu]++;
+	in_kgdb_here_log[cpu] = regs;
+	if (cpu == spinlock_cpu || waiting_cpus[cpu].task)
+		goto exit_in_kgdb;
+
+	/*
+	 * For protection of the initilization of the spin locks by kgdb
+	 * it locks the kgdb spinlock before it gets the wait locks set
+	 * up.	We wait here for the wait lock to be taken.  If the
+	 * kgdb lock goes away first??	Well, it could be a slow exit
+	 * sequence where the wait lock is removed prior to the kgdb lock
+	 * so if kgdb gets unlocked, we just exit.
+	 */
+
+	while (spin_is_locked(&kgdb_spinlock) &&
+	       !spin_is_locked(waitlocks + cpu)) ;
+	if (!spin_is_locked(&kgdb_spinlock))
+		goto exit_in_kgdb;
+
+	waiting_cpus[cpu].task = current;
+	waiting_cpus[cpu].pid = (current->pid) ? : (PID_MAX + cpu);
+	waiting_cpus[cpu].regs = regs;
+
+	spin_unlock_wait(waitlocks + cpu);
+
+	/*
+	 * log departure of this cpu
+	 */
+	waiting_cpus[cpu].task = 0;
+	waiting_cpus[cpu].pid = 0;
+	waiting_cpus[cpu].regs = 0;
+	correct_hw_break();
+      exit_in_kgdb:
+	in_kgdb_here_log[cpu] = 0;
+	local_irq_restore(flags);
+	return 1;
+	/*
+	   spin_unlock(continuelocks + smp_processor_id());
+	 */
+}
+
+void
+smp__in_kgdb(struct pt_regs regs)
+{
+	ack_APIC_irq();
+	in_kgdb(&regs);
+}
+#else
+int
+in_kgdb(struct pt_regs *regs)
+{
+	return (kgdb_spinlock);
+}
+#endif
+
+void
+printexceptioninfo(int exceptionNo, int errorcode, char *buffer)
+{
+	unsigned long dr6;
+	int i;
+	switch (exceptionNo) {
+	case 1:		/* debug exception */
+		break;
+	case 3:		/* breakpoint */
+		sprintf(buffer, "Software breakpoint");
+		return;
+	default:
+		sprintf(buffer, "Details not available");
+		return;
+	}
+	asm volatile ("movq %%db6, %0\n":"=r" (dr6)
+		      :);
+	if (dr6 & 0x4000) {
+		sprintf(buffer, "Single step");
+		return;
+	}
+	for (i = 0; i < 4; ++i) {
+		if (dr6 & (1 << i)) {
+			sprintf(buffer, "Hardware breakpoint %d", i);
+			return;
+		}
+	}
+	sprintf(buffer, "Unknown trap");
+	return;
+}
+
+/*
+ * The ThreadExtraInfo query allows us to pass an arbitrary string
+ * for display with the "info threads" command.
+ */
+
+void
+print_extra_info(task_t *p, char *buf)
+{
+	if (!p) {
+		sprintf(buf, "Invalid thread");
+		return;
+	}
+	sprintf(buf, "0x%p %8d %4d  %c  %s",
+		   (void *)p,  p->parent->pid,
+		   task_cpu(p),
+		   (p->state == 0) ? (task_curr(p)?'R':'r') :
+		     (p->state < 0) ? 'U' :
+		     (p->state & TASK_UNINTERRUPTIBLE) ? 'D' :
+		     (p->state & TASK_STOPPED || p->ptrace & PT_PTRACED) ? 'T' :
+		     (p->state & (EXIT_ZOMBIE | EXIT_DEAD)) ? 'Z' :
+		     (p->state & TASK_INTERRUPTIBLE) ? 'S' : '?',
+		   p->comm);
+}
+
+/*
+ * This function does all command procesing for interfacing to gdb.
+ *
+ * NOTE:  The INT nn instruction leaves the state of the interrupt
+ *	  enable flag UNCHANGED.  That means that when this routine
+ *	  is entered via a breakpoint (INT 3) instruction from code
+ *	  that has interrupts enabled, then interrupts will STILL BE
+ *	  enabled when this routine is entered.	 The first thing that
+ *	  we do here is disable interrupts so as to prevent recursive
+ *	  entries and bothersome serial interrupts while we are
+ *	  trying to run the serial port in polled mode.
+ *
+ * For kernel version 2.1.xx the kgdb_cli() actually gets a spin lock so
+ * it is always necessary to do a restore_flags before returning
+ * so as to let go of that lock.
+ */
+int
+kgdb_handle_exception(int exceptionVector,
+		      int signo, int err_code, struct pt_regs *linux_regs)
+{
+	struct task_struct *usethread = NULL;
+	struct task_struct *thread_list_start = 0, *thread = NULL;
+	struct task_struct *p;
+	unsigned long addr, length;
+	unsigned long breakno, breaktype;
+	char *ptr;
+	unsigned long newPC;
+	threadref thref;
+	unsigned long threadid, tmpid;
+	int thread_min = PID_MAX + MAX_NO_CPUS;
+#ifdef old_thread_list
+	int maxthreads;
+#endif
+	int nothreads;
+	unsigned long flags;
+	unsigned long gdb_regs[NUMREGS];
+	unsigned long dr6;
+	IF_SMP(int entry_state = 0);	/* 0, ok, 1, no nmi, 2 sync failed */
+#define NO_NMI 1
+#define NO_SYNC 2
+#define	regs	(*linux_regs)
+	/*
+	 * If the entry is not from the kernel then return to the Linux
+	 * trap handler and let it process the interrupt normally.
+	 */
+	if ((linux_regs->eflags & VM_MASK) || (3 & linux_regs->cs)) {
+		printk("ignoring non-kernel exception\n");
+		print_regs(&regs);
+		return (0);
+	}
+	/*
+	 * If we're using eth mode, set the 'mode' in the netdevice.
+	 */
+
+	if (kgdboe)
+		netpoll_set_trap(1);
+
+	local_irq_save(flags);
+
+	/* Get kgdb spinlock */
+
+	KGDB_SPIN_LOCK(&kgdb_spinlock);
+	rdtscll(kgdb_info.entry_tsc);
+	/*
+	 * We depend on this spinlock and the NMI watch dog to control the
+	 * other cpus.	They will arrive at "in_kgdb()" as a result of the
+	 * NMI and will wait there for the following spin locks to be
+	 * released.
+	 */
+#ifdef CONFIG_SMP
+
+#if 0
+	if (cpu_callout_map & ~MAX_CPU_MASK) {
+		printk("kgdb : too many cpus, possibly not mapped"
+		       " in contiguous space, change MAX_NO_CPUS"
+		       " in kgdb_stub and make new kernel.\n"
+		       " cpu_callout_map is %lx\n", cpu_callout_map);
+		goto exit_just_unlock;
+	}
+#endif
+	if (spinlock_count == 1) {
+		int time, end_time, dum;
+		int i;
+		int cpu_logged_in[MAX_NO_CPUS] = {[0 ... MAX_NO_CPUS - 1] = (0)
+		};
+		if (remote_debug) {
+			printk("kgdb : cpu %d entry, syncing others\n",
+			       smp_processor_id());
+		}
+		for (i = 0; i < MAX_NO_CPUS; i++) {
+			/*
+			 * Use trylock as we may already hold the lock if
+			 * we are holding the cpu.  Net result is all
+			 * locked.
+			 */
+			spin_trylock(&waitlocks[i]);
+		}
+		for (i = 0; i < MAX_NO_CPUS; i++)
+			cpu_logged_in[i] = 0;
+		/*
+		 * Wait for their arrival.  We know the watch dog is active if
+		 * in_kgdb() has ever been called, as it is always called on a
+		 * watchdog tick.
+		 */
+		rdtsc(dum, time);
+		end_time = time + 2;	/* Note: we use the High order bits! */
+		i = 1;
+		if (num_online_cpus() > 1) {
+			int me_in_kgdb = in_kgdb_entry_log[smp_processor_id()];
+			smp_send_nmi_allbutself();
+
+			while (i < num_online_cpus() && time != end_time) {
+				int j;
+				for (j = 0; j < MAX_NO_CPUS; j++) {
+					if (waiting_cpus[j].task &&
+					    waiting_cpus[j].task != NOCPU &&
+					    !cpu_logged_in[j]) {
+						i++;
+						cpu_logged_in[j] = 1;
+						if (remote_debug) {
+							printk
+							    ("kgdb : cpu %d arrived at kgdb\n",
+							     j);
+						}
+						break;
+					} else if (!waiting_cpus[j].task &&
+						   !cpu_online(j)) {
+						waiting_cpus[j].task = NOCPU;
+						cpu_logged_in[j] = 1;
+						waiting_cpus[j].hold = 1;
+						break;
+					}
+					if (!waiting_cpus[j].task &&
+					    in_kgdb_here_log[j]) {
+
+						int wait = 100000;
+						while (wait--) ;
+						if (!waiting_cpus[j].task &&
+						    in_kgdb_here_log[j]) {
+							printk
+							    ("kgdb : cpu %d stall"
+							     " in in_kgdb\n",
+							     j);
+							i++;
+							cpu_logged_in[j] = 1;
+							waiting_cpus[j].task =
+							    (struct task_struct
+							     *) 1;
+						}
+					}
+				}
+
+				if (in_kgdb_entry_log[smp_processor_id()] >
+				    (me_in_kgdb + 10)) {
+					break;
+				}
+
+				rdtsc(dum, time);
+			}
+			if (i < num_online_cpus()) {
+				printk
+				    ("kgdb : time out, proceeding without sync\n");
+#if 0
+				printk("kgdb : Waiting_cpus: 0 = %d, 1 = %d\n",
+				       waiting_cpus[0].task != 0,
+				       waiting_cpus[1].task != 0);
+				printk("kgdb : Cpu_logged in: 0 = %d, 1 = %d\n",
+				       cpu_logged_in[0], cpu_logged_in[1]);
+				printk
+				    ("kgdb : in_kgdb_here_log in: 0 = %d, 1 = %d\n",
+				     in_kgdb_here_log[0] != 0,
+				     in_kgdb_here_log[1] != 0);
+#endif
+				entry_state = NO_SYNC;
+			} else {
+#if 0
+				int ent =
+				    in_kgdb_entry_log[smp_processor_id()] -
+				    me_in_kgdb;
+				printk("kgdb : sync after %d entries\n", ent);
+#endif
+			}
+		} else {
+			if (remote_debug) {
+				printk
+				    ("kgdb : %d cpus, but watchdog not active\n"
+				     "proceeding without locking down other cpus\n",
+				     (int)num_online_cpus());
+				entry_state = NO_NMI;
+			}
+		}
+	}
+#endif
+
+	if (remote_debug) {
+		unsigned long *lp = (unsigned long *) &linux_regs;
+
+		printk("handle_exception(exceptionVector=%d, "
+		       "signo=%d, err_code=%d, linux_regs=%p)\n",
+		       exceptionVector, signo, err_code, linux_regs);
+		if (debug_regs) {
+			print_regs(&regs);
+			printk("Stk: %8lx %8lx %8lx %8lx"
+			       "  %8lx %8lx %8lx %8lx\n",
+			       lp[0], lp[1], lp[2], lp[3],
+			       lp[4], lp[5], lp[6], lp[7]);
+			printk("     %8lx %8lx %8lx %8lx"
+			       "  %8lx %8lx %8lx %8lx\n",
+			       lp[8], lp[9], lp[10], lp[11],
+			       lp[12], lp[13], lp[14], lp[15]);
+			printk("     %8lx %8lx %8lx %8lx  "
+			       "%8lx %8lx %8lx %8lx\n",
+			       lp[16], lp[17], lp[18], lp[19],
+			       lp[20], lp[21], lp[22], lp[23]);
+			printk("     %8lx %8lx %8lx %8lx  "
+			       "%8lx %8lx %8lx %8lx\n",
+			       lp[24], lp[25], lp[26], lp[27],
+			       lp[28], lp[29], lp[30], lp[31]);
+		}
+	}
+
+	/* Disable hardware debugging while we are in kgdb */
+	/* Get the debug register status register */
+/*				       *INDENT-OFF*  */
+      __asm__("movq %0,%%db7"
+	      :	/* no output */
+	      :"r"(0UL));
+
+	asm volatile ("movq %%db6, %0\n"
+		      :"=r" (hw_breakpoint_status)
+		      :);
+
+#if 0
+/*				       *INDENT-ON*  */
+	switch (exceptionVector) {
+	case 0:		/* divide error */
+	case 1:		/* debug exception */
+	case 2:		/* NMI */
+	case 3:		/* breakpoint */
+	case 4:		/* overflow */
+	case 5:		/* bounds check */
+	case 6:		/* invalid opcode */
+	case 7:		/* device not available */
+	case 8:		/* double fault (errcode) */
+	case 10:		/* invalid TSS (errcode) */
+	case 12:		/* stack fault (errcode) */
+	case 16:		/* floating point error */
+	case 17:		/* alignment check (errcode) */
+	default:		/* any undocumented */
+		break;
+	case 11:		/* segment not present (errcode) */
+	case 13:		/* general protection (errcode) */
+	case 14:		/* page fault (special errcode) */
+	case 19:		/* cache flush denied */
+		if (mem_err_expected) {
+			/*
+			 * This fault occured because of the
+			 * get_char or set_char routines.  These
+			 * two routines use either eax of edx to
+			 * indirectly reference the location in
+			 * memory that they are working with.
+			 * For a page fault, when we return the
+			 * instruction will be retried, so we
+			 * have to make sure that these
+			 * registers point to valid memory.
+			 */
+			mem_err = 1;	/* set mem error flag */
+			mem_err_expected = 0;
+			mem_err_cnt++;	/* helps in debugging */
+			/* make valid address */
+			regs.eax = (long) &garbage_loc;
+			/* make valid address */
+			regs.edx = (long) &garbage_loc;
+			if (remote_debug)
+				printk("Return after memory error: "
+				       "mem_err_cnt=%d\n", mem_err_cnt);
+			if (debug_regs)
+				print_regs(&regs);
+			goto exit_kgdb;
+		}
+		break;
+	}
+#endif
+	if (remote_debug)
+		printk("kgdb : entered kgdb on cpu %d\n", smp_processor_id());
+
+	gdb_i386vector = exceptionVector;
+	gdb_i386errcode = err_code;
+	kgdb_info.called_from = __builtin_return_address(0);
+#ifdef CONFIG_SMP
+	/*
+	 * OK, we can now communicate, lets tell gdb about the sync.
+	 * but only if we had a problem.
+	 */
+	switch (entry_state) {
+	case NO_NMI:
+		to_gdb("NMI not active, other cpus not stopped\n");
+		break;
+	case NO_SYNC:
+		to_gdb("Some cpus not stopped, see 'kgdb_info' for details\n");
+	default:;
+	}
+
+#endif
+/*
+ * Set up the gdb function call area.
+ */
+	trap_cpu = smp_processor_id();
+	OLD_esp = NEW_esp = (unsigned long) (&linux_regs->rsp);
+
+      IF_SMP(once_again:)
+	    /* reply to host that an exception has occurred */
+	    remcomOutBuffer[0] = 'S';
+	remcomOutBuffer[1] = hexchars[signo >> 4];
+	remcomOutBuffer[2] = hexchars[signo % 16];
+	remcomOutBuffer[3] = 0;
+
+	putpacket(remcomOutBuffer);
+
+	while (1 == 1) {
+		error = 0;
+		remcomOutBuffer[0] = 0;
+		getpacket(remcomInBuffer);
+		switch (remcomInBuffer[0]) {
+		case '?':
+			remcomOutBuffer[0] = 'S';
+			remcomOutBuffer[1] = hexchars[signo >> 4];
+			remcomOutBuffer[2] = hexchars[signo % 16];
+			remcomOutBuffer[3] = 0;
+			break;
+		case 'd':
+			remote_debug = !(remote_debug);	/* toggle debug flag */
+			printk("Remote debug %s\n",
+			       remote_debug ? "on" : "off");
+			break;
+		case 'g':	/* return the value of the CPU registers */
+			get_gdb_regs(usethread, &regs, gdb_regs);
+			mem2hex((char *) gdb_regs,
+				remcomOutBuffer, NUMREGBYTES);
+			break;
+		case 'G':	/* set the value of the CPU registers - return OK */
+			hex2mem(&remcomInBuffer[1],
+				(char *) gdb_regs, NUMREGBYTES);
+			if (!usethread || usethread == current) {
+				gdb_regs_to_regs(gdb_regs, &regs);
+				strcpy(remcomOutBuffer, "OK");
+			} else {
+				strcpy(remcomOutBuffer, "E00");
+			}
+			break;
+
+		case 'P':{	/* set the value of a single CPU register -
+				   return OK */
+				/*
+				 * For some reason, gdb wants to talk about psudo
+				 * registers (greater than 15).
+				 */
+				unsigned long regno;
+
+				ptr = &remcomInBuffer[1];
+				regs_to_gdb_regs(gdb_regs, &regs);
+				if ((!usethread || usethread == current) &&
+				    hexToLong(&ptr, &regno) &&
+				    *ptr++ == '=' && (regno >= 0)) {
+					if (regno >= NUMREGS)
+						break;
+					hex2mem(ptr, (char *) &gdb_regs[regno],
+						8);
+					gdb_regs_to_regs(gdb_regs, &regs);
+					strcpy(remcomOutBuffer, "OK");
+					break;
+				}
+				strcpy(remcomOutBuffer, "E01");
+				break;
+			}
+
+			/* mAA..AA,LLLL	 Read LLLL bytes at address AA..AA */
+		case 'm':
+			/* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
+			ptr = &remcomInBuffer[1];
+			if (hexToLong(&ptr, &addr) &&
+			    (*(ptr++) == ',') && (hexToLong(&ptr, &length))) {
+				ptr = 0;
+				/*
+				 * hex doubles the byte count
+				 */
+				if (length > (BUFMAX / 2))
+					length = BUFMAX / 2;
+				if (mem2hex((char *) addr,
+					remcomOutBuffer, length)) {
+					strcpy(remcomOutBuffer, "E03");
+					debug_error("memory fault\n", NULL);
+				}
+			}
+
+			if (ptr) {
+				strcpy(remcomOutBuffer, "E01");
+				debug_error
+				    ("malformed read memory command: %s\n",
+				     remcomInBuffer);
+			}
+			break;
+
+			/* MAA..AA,LLLL:
+			   Write LLLL bytes at address AA.AA return OK */
+		case 'M':
+			/* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
+			ptr = &remcomInBuffer[1];
+			if (hexToLong(&ptr, &addr) &&
+			    (*(ptr++) == ',') &&
+			    (hexToLong(&ptr, &length)) && (*(ptr++) == ':')) {
+				if (hex2mem(ptr, (char *) addr, length)) {
+					strcpy(remcomOutBuffer, "E03");
+					debug_error("memory fault\n", NULL);
+				} else {
+					strcpy(remcomOutBuffer, "OK");
+				}
+
+				ptr = 0;
+			}
+			if (ptr) {
+				strcpy(remcomOutBuffer, "E02");
+				debug_error
+				    ("malformed write memory command: %s\n",
+				     remcomInBuffer);
+			}
+			break;
+		case 'S':
+			remcomInBuffer[0] = 's';
+		case 'C':
+			/* Csig;AA..AA where ;AA..AA is optional
+			 * continue with signal
+			 * Since signals are meaning less to us, delete that
+			 * part and then fall into the 'c' code.
+			 */
+			ptr = &remcomInBuffer[1];
+			length = 2;
+			while (*ptr && *ptr != ';') {
+				length++;
+				ptr++;
+			}
+			if (*ptr) {
+				do {
+					ptr++;
+					*(ptr - length++) = *ptr;
+				} while (*ptr);
+			} else {
+				remcomInBuffer[1] = 0;
+			}
+
+			/* cAA..AA  Continue at address AA..AA(optional) */
+			/* sAA..AA  Step one instruction from AA..AA(optional) */
+			/* D	    detach, reply OK and then continue */
+		case 'c':
+		case 's':
+		case 'D':
+
+			/* try to read optional parameter,
+			   pc unchanged if no parm */
+			ptr = &remcomInBuffer[1];
+			if (hexToLong(&ptr, &addr)) {
+				if (remote_debug)
+					printk("Changing EIP to 0x%lx\n", addr);
+
+				regs.rip = addr;
+			}
+
+			newPC = regs.rip;
+
+			/* clear the trace bit */
+			regs.eflags &= 0xfffffeff;
+
+			/* set the trace bit if we're stepping */
+			if (remcomInBuffer[0] == 's')
+				regs.eflags |= 0x100;
+
+			/* detach is a friendly version of continue. Note that
+			   debugging is still enabled (e.g hit control C)
+			 */
+			if (remcomInBuffer[0] == 'D') {
+				strcpy(remcomOutBuffer, "OK");
+				putpacket(remcomOutBuffer);
+			}
+
+			if (remote_debug) {
+				printk("Resuming execution\n");
+				print_regs(&regs);
+			}
+			asm volatile ("movq %%db6, %0\n":"=r" (dr6)
+				      :);
+			if (!(dr6 & 0x4000)) {
+				for (breakno = 0; breakno < 4; ++breakno) {
+					if (dr6 & (1 << breakno) &&
+					    (breakinfo[breakno].type == 0)) {
+						/* Set restore flag */
+						regs.eflags |= 0x10000;
+						break;
+					}
+				}
+			}
+
+			if (kgdboe)
+				netpoll_set_trap(0);
+
+			correct_hw_break();
+			asm volatile ("movq %0, %%db6\n"::"r" (0UL));
+			goto exit_kgdb;
+
+			/* kill the program */
+		case 'k':	/* do nothing */
+			break;
+
+			/* query */
+		case 'q':
+			nothreads = 0;
+			switch (remcomInBuffer[1]) {
+			case 'f':
+				threadid = 1;
+				thread_list = 2;
+				thread_list_start = (usethread ? : current);
+			case 's':
+				if (!cmp_str(&remcomInBuffer[2],
+					     "ThreadInfo", 10))
+					break;
+
+				remcomOutBuffer[nothreads++] = 'm';
+				for (; threadid < PID_MAX + MAX_NO_CPUS;
+				     threadid++) {
+					thread = getthread(threadid);
+					if (thread) {
+						nothreads += int_to_hex_v(
+							&remcomOutBuffer[
+								nothreads],
+							threadid);
+						if (thread_min > threadid)
+							thread_min = threadid;
+						remcomOutBuffer[
+							nothreads] = ',';
+						nothreads++;
+						if (nothreads > BUFMAX - 10)
+							break;
+					}
+				}
+				if (remcomOutBuffer[nothreads - 1] == 'm') {
+					remcomOutBuffer[nothreads - 1] = 'l';
+				} else {
+					nothreads--;
+				}
+				remcomOutBuffer[nothreads] = 0;
+				break;
+
+#ifdef old_thread_list /* Old thread info request */
+			case 'L':
+				/* List threads */
+				thread_list = 2;
+				thread_list_start = (usethread ? : current);
+				unpack_byte(remcomInBuffer + 3, &maxthreads);
+				unpack_threadid(remcomInBuffer + 5, &thref);
+				do {
+					int buf_thread_limit =
+					    (BUFMAX - 22) / BUF_THREAD_ID_SIZE;
+					if (maxthreads > buf_thread_limit) {
+						maxthreads = buf_thread_limit;
+					}
+				} while (0);
+				remcomOutBuffer[0] = 'q';
+				remcomOutBuffer[1] = 'M';
+				remcomOutBuffer[4] = '0';
+				pack_threadid(remcomOutBuffer + 5, &thref);
+
+				/* If start flag set start at 0. */
+				if (remcomInBuffer[2] == '1')
+					threadid = 0;
+				else
+					threadid = threadref_to_int(&thref);
+				for (nothreads = 0;
+				     nothreads < maxthreads &&
+				     threadid < PID_MAX + MAX_NO_CPUS;
+				     threadid++) {
+					thread = getthread(threadid);
+					if (thread) {
+						int_to_threadref(&thref,
+								 threadid);
+						pack_threadid(remcomOutBuffer +
+							      21 +
+							      nothreads * 16,
+							      &thref);
+						nothreads++;
+						if (thread_min > threadid)
+							thread_min = threadid;
+					}
+				}
+
+				if (threadid == PID_MAX + MAX_NO_CPUS) {
+					remcomOutBuffer[4] = '1';
+				}
+				pack_hex_byte(remcomOutBuffer + 2, nothreads);
+				remcomOutBuffer[21 + nothreads * 16] = '\0';
+				break;
+#endif
+			case 'C':
+				/* Current thread id */
+				remcomOutBuffer[0] = 'Q';
+				remcomOutBuffer[1] = 'C';
+				threadid = current->pid;
+				if (!threadid) {
+					/*
+					 * idle thread
+					 */
+					for (threadid = PID_MAX;
+					     threadid < PID_MAX + MAX_NO_CPUS;
+					     threadid++) {
+						if (current ==
+						    idle_task(threadid -
+							      PID_MAX))
+							break;
+					}
+				}
+				int_to_threadref(&thref, threadid);
+				pack_threadid(remcomOutBuffer + 2, &thref);
+				remcomOutBuffer[18] = '\0';
+				break;
+
+			case 'E':
+				/* Print exception info */
+				printexceptioninfo(exceptionVector,
+						   err_code, remcomOutBuffer);
+				break;
+			case 'T':
+				ptr = &remcomInBuffer[0];
+				if (strncmp(ptr, "qThreadExtraInfo,",
+					strlen("qThreadExtraInfo,")) == 0) {
+					ptr += strlen("qThreadExtraInfo,");
+					hexToLong(&ptr, &tmpid);
+					p = getthread(tmpid);
+					print_extra_info(p, lbuf);
+					mem2hex(lbuf, remcomOutBuffer,
+						strlen(lbuf));
+				}
+				break;
+#if 0
+			case 'T':{
+				char * nptr;
+				/* Thread extra info */
+				if (!cmp_str(&remcomInBuffer[2],
+					    "hreadExtraInfo,", 15)) {
+					break;
+				}
+				ptr = &remcomInBuffer[17];
+				hexToLong(&ptr, &threadid);
+				thread = getthread(threadid);
+				nptr = &thread->comm[0];
+				length = 0;
+				ptr = &remcomOutBuffer[0];
+				do {
+					length++;
+					ptr = pack_hex_byte(ptr, *nptr++);
+				 } while (*nptr && length < 16);
+				/*
+				 * would like that 16 to be the size of
+				 * task_struct.comm but don't know the
+				 * syntax..
+				 */
+				*ptr = 0;
+			}
+#endif
+			}
+			break;
+
+			/* task related */
+		case 'H':
+			switch (remcomInBuffer[1]) {
+			case 'g':
+				ptr = &remcomInBuffer[2];
+				hexToLong(&ptr, &threadid);
+				thread = getthread(threadid);
+				if (!thread) {
+					remcomOutBuffer[0] = 'E';
+					remcomOutBuffer[1] = '\0';
+					break;
+				}
+				/*
+				 * Just in case I forget what this is all about,
+				 * the "thread info" command to gdb causes it
+				 * to ask for a thread list.  It then switches
+				 * to each thread and asks for the registers.
+				 * For this (and only this) usage, we want to
+				 * fudge the registers of tasks not on the run
+				 * list (i.e. waiting) to show the routine that
+				 * called schedule. Also, gdb, is a minimalist
+				 * in that if the current thread is the last
+				 * it will not re-read the info when done.
+				 * This means that in this case we must show
+				 * the real registers. So here is how we do it:
+				 * Each entry we keep track of the min
+				 * thread in the list (the last that gdb will)
+				 * get info for.  We also keep track of the
+				 * starting thread.
+				 * "thread_list" is cleared when switching back
+				 * to the min thread if it is was current, or
+				 * if it was not current, thread_list is set
+				 * to 1.  When the switch to current comes,
+				 * if thread_list is 1, clear it, else do
+				 * nothing.
+				 */
+				usethread = thread;
+				if ((thread_list == 1) &&
+				    (thread == thread_list_start)) {
+					thread_list = 0;
+				}
+				if (thread_list && (threadid == thread_min)) {
+					if (thread == thread_list_start) {
+						thread_list = 0;
+					} else {
+						thread_list = 1;
+					}
+				}
+				/* follow through */
+			case 'c':
+				remcomOutBuffer[0] = 'O';
+				remcomOutBuffer[1] = 'K';
+				remcomOutBuffer[2] = '\0';
+				break;
+			}
+			break;
+
+			/* Query thread status */
+		case 'T':
+			ptr = &remcomInBuffer[1];
+			hexToLong(&ptr, &threadid);
+			thread = getthread(threadid);
+			if (thread) {
+				remcomOutBuffer[0] = 'O';
+				remcomOutBuffer[1] = 'K';
+				remcomOutBuffer[2] = '\0';
+				if (thread_min > threadid)
+					thread_min = threadid;
+			} else {
+				remcomOutBuffer[0] = 'E';
+				remcomOutBuffer[1] = '\0';
+			}
+			break;
+
+		case 'Y': /* set up a hardware breakpoint */
+			ptr = &remcomInBuffer[1];
+			hexToLong(&ptr, &breakno);
+			ptr++;
+			hexToLong(&ptr, &breaktype);
+			ptr++;
+			hexToLong(&ptr, &length);
+			ptr++;
+			hexToLong(&ptr, &addr);
+			if (set_hw_break(breakno & 0x3,
+					 breaktype & 0x3,
+					 length & 0x3, addr) == 0) {
+				strcpy(remcomOutBuffer, "OK");
+			} else {
+				strcpy(remcomOutBuffer, "ERROR");
+			}
+			break;
+
+			/* Remove hardware breakpoint */
+		case 'y':
+			ptr = &remcomInBuffer[1];
+			hexToLong(&ptr, &breakno);
+			if (remove_hw_break(breakno & 0x3) == 0) {
+				strcpy(remcomOutBuffer, "OK");
+			} else {
+				strcpy(remcomOutBuffer, "ERROR");
+			}
+			break;
+
+		case 'r':	/* reboot */
+			strcpy(remcomOutBuffer, "OK");
+			putpacket(remcomOutBuffer);
+			/*to_gdb("Rebooting\n"); */
+			/* triplefault	 no return from here */
+			{
+				static long no_idt[2];
+				__asm__ __volatile__("lidt %0"::"m"(no_idt[0]));
+				BREAKPOINT;
+			}
+
+		}		/* switch */
+
+		/* reply to the request */
+		putpacket(remcomOutBuffer);
+	}			/* while(1==1) */
+	/*
+	 *  reached by goto only.
+	 */
+      exit_kgdb:
+	/*
+	 * Here is where we set up to trap a gdb function call.	 NEW_esp
+	 * will be changed if we are trying to do this.	 We handle both
+	 * adding and subtracting, thus allowing gdb to put grung on
+	 * the stack which it removes later.
+	 */
+	if (NEW_esp != OLD_esp) {
+		unsigned long *ptr = END_OF_LOOKASIDE;
+		if (NEW_esp < OLD_esp)
+			ptr -= (OLD_esp - NEW_esp) / sizeof (unsigned long);
+		*--ptr = linux_regs->eflags;
+		*--ptr = linux_regs->cs;
+		*--ptr = linux_regs->rip;
+		*--ptr = linux_regs->rcx;
+		*--ptr = linux_regs->rbx;
+		*--ptr = linux_regs->rax;
+		linux_regs->rcx = NEW_esp - (sizeof (unsigned long) * 6);
+		linux_regs->rbx = (unsigned long) END_OF_LOOKASIDE;
+		if (NEW_esp < OLD_esp) {
+			linux_regs->rip = (unsigned long) fn_call_stub;
+		} else {
+			linux_regs->rip = (unsigned long) fn_rtn_stub;
+			linux_regs->rax = NEW_esp;
+		}
+		linux_regs->eflags &= ~(IF_BIT | TF_BIT);
+	}
+#ifdef CONFIG_SMP
+	/*
+	 * Release gdb wait locks
+	 * Sanity check time.  Must have at least one cpu to run.  Also single
+	 * step must not be done if the current cpu is on hold.
+	 */
+	if (spinlock_count == 1) {
+		int ss_hold = (regs.eflags & 0x100) && kgdb_info.hold_on_sstep;
+		int cpu_avail = 0;
+		int i;
+
+		for (i = 0; i < MAX_NO_CPUS; i++) {
+			if (!cpu_online(i))
+				break;
+			if (!hold_cpu(i)) {
+				cpu_avail = 1;
+			}
+		}
+		/*
+		 * Early in the bring up there will be NO cpus on line...
+		 */
+		if (!cpu_avail && !cpus_empty(cpu_online_map)) {
+			to_gdb("No cpus unblocked, see 'kgdb_info.hold_cpu'\n");
+			goto once_again;
+		}
+		if (hold_cpu(smp_processor_id()) && (regs.eflags & 0x100)) {
+			to_gdb
+			    ("Current cpu must be unblocked to single step\n");
+			goto once_again;
+		}
+		if (!(ss_hold)) {
+			int i;
+			for (i = 0; i < MAX_NO_CPUS; i++) {
+				if (!hold_cpu(i)) {
+					spin_unlock(&waitlocks[i]);
+				}
+			}
+		} else {
+			spin_unlock(&waitlocks[smp_processor_id()]);
+		}
+		/* Release kgdb spinlock */
+		KGDB_SPIN_UNLOCK(&kgdb_spinlock);
+		/*
+		 * If this cpu is on hold, this is where we
+		 * do it.  Note, the NMI will pull us out of here,
+		 * but will return as the above lock is not held.
+		 * We will stay here till another cpu releases the lock for us.
+		 */
+		spin_unlock_wait(waitlocks + smp_processor_id());
+		local_irq_restore(flags);
+		return (1);
+	}
+#if 0
+exit_just_unlock:
+#endif
+#endif
+	/* Release kgdb spinlock */
+	KGDB_SPIN_UNLOCK(&kgdb_spinlock);
+	local_irq_restore(flags);
+	return (1);
+}
+
+#undef regs
+static int kgdb_notify(struct notifier_block *self, unsigned long cmd, void *ptr)
+{
+	struct die_args *d = ptr;
+
+	if (!kgdb_enabled || (cmd == DIE_DEBUG && user_mode(d->regs)))
+		return NOTIFY_DONE;
+	if (cmd == DIE_NMI_IPI) {
+		if (in_kgdb(d->regs))
+			return NOTIFY_STOP;
+	} else if (kgdb_handle_exception(d->trapnr, d->signr, d->err, d->regs))
+		return NOTIFY_STOP; /* skip */
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block kgdb_notifier = {
+	.notifier_call = kgdb_notify,
+	.priority = 0,
+};
+
+void set_debug_traps(void)
+{
+	static int initialized = 0;
+
+	if (!initialized) {
+		initialized = 1;
+		notifier_chain_register(&die_chain, &kgdb_notifier);
+	}
+}
+
+/*
+ * Provide the command line "gdb" initial break
+ */
+int __init kgdb_initial_break(char * str)
+{
+	if (*str == '\0'){
+		breakpoint();
+		return 1;
+	}
+	return 0;
+}
+__setup("gdb",kgdb_initial_break);
+
+/* This function will generate a breakpoint exception.	It is used at the
+   beginning of a program to sync up with a debugger and can be used
+   otherwise as a quick means to stop program execution and "break" into
+   the debugger. */
+/* But really, just use the BREAKPOINT macro.  We will handle the int stuff
+ */
+
+void breakpoint(void)
+{
+
+	set_debug_traps();
+	kgdb_enabled = 1;
+#if 0
+	/*
+	 * These calls were not enough to allow breakpoint to be
+	 * called before trap_init().  I moved the argument parsing
+	 * after trap_init() and it seems to work.
+	 */
+	set_intr_usr_gate(3,&int3); /* disable ints on trap */
+	set_intr_gate(1,&debug);
+	set_intr_gate(14,&page_fault);
+#endif
+
+        BREAKPOINT;
+}
+
+#ifdef later
+/*
+ * possibly we should not go thru the traps.c code at all?  Someday.
+ */
+void
+do_kgdb_int3(struct pt_regs *regs, long error_code)
+{
+	kgdb_handle_exception(3, 5, error_code, regs);
+	return;
+}
+#endif
+#undef regs
+#ifdef CONFIG_TRAP_BAD_SYSCALL_EXITS
+asmlinkage void
+bad_sys_call_exit(int stuff)
+{
+	struct pt_regs *regs = (struct pt_regs *) &stuff;
+	printk("Sys call %d return with %x preempt_count\n",
+	       (int) regs->orig_eax, preempt_count());
+}
+#endif
+#ifdef CONFIG_STACK_OVERFLOW_TEST
+#include <asm/kgdb.h>
+asmlinkage void
+stack_overflow(void)
+{
+#ifdef BREAKPOINT
+	BREAKPOINT;
+#else
+	printk("Kernel stack overflow, looping forever\n");
+#endif
+	while (1) {
+	}
+}
+#endif
+
+#if defined(CONFIG_SMP) || defined(CONFIG_KGDB_CONSOLE)
+char gdbconbuf[BUFMAX];
+
+static void
+kgdb_gdb_message(const char *s, unsigned count)
+{
+	int i;
+	int wcount;
+	char *bufptr;
+	/*
+	 * This takes care of NMI while spining out chars to gdb
+	 */
+	IF_SMP(in_kgdb_console = 1);
+	gdbconbuf[0] = 'O';
+	bufptr = gdbconbuf + 1;
+	while (count > 0) {
+		if ((count << 1) > (BUFMAX - 2)) {
+			wcount = (BUFMAX - 2) >> 1;
+		} else {
+			wcount = count;
+		}
+		count -= wcount;
+		for (i = 0; i < wcount; i++) {
+			bufptr = pack_hex_byte(bufptr, s[i]);
+		}
+		*bufptr = '\0';
+		s += wcount;
+
+		putpacket(gdbconbuf);
+
+	}
+	IF_SMP(in_kgdb_console = 0);
+}
+#endif
+#ifdef CONFIG_SMP
+static void
+to_gdb(const char *s)
+{
+	int count = 0;
+	while (s[count] && (count++ < BUFMAX)) ;
+	kgdb_gdb_message(s, count);
+}
+#endif
+#ifdef CONFIG_KGDB_CONSOLE
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <asm/semaphore.h>
+
+void
+kgdb_console_write(struct console *co, const char *s, unsigned count)
+{
+
+	if (gdb_i386vector == -1) {
+		/*
+		 * We have not yet talked to gdb.  What to do...
+		 * lets break, on continue we can do the write.
+		 * But first tell him whats up. Uh, well no can do,
+		 * as this IS the console.  Oh well...
+		 * We do need to wait or the messages will be lost.
+		 * Other option would be to tell the above code to
+		 * ignore this breakpoint and do an auto return,
+		 * but that might confuse gdb.	Also this happens
+		 * early enough in boot up that we don't have the traps
+		 * set up yet, so...
+		 */
+		breakpoint();
+	}
+	kgdb_gdb_message(s, count);
+}
+
+/*
+ * ------------------------------------------------------------
+ * Serial KGDB driver
+ * ------------------------------------------------------------
+ */
+
+static struct console kgdbcons = {
+	name:"kgdb",
+	write:kgdb_console_write,
+#ifdef CONFIG_KGDB_USER_CONSOLE
+	device:kgdb_console_device,
+#endif
+	flags:CON_PRINTBUFFER | CON_ENABLED,
+	index:-1,
+};
+
+/*
+ * The trick here is that this file gets linked before printk.o
+ * That means we get to peer at the console info in the command
+ * line before it does.	 If we are up, we register, otherwise,
+ * do nothing.	By returning 0, we allow printk to look also.
+ */
+static int kgdb_console_enabled;
+
+int __init
+kgdb_console_init(char *str)
+{
+	if ((strncmp(str, "kgdb", 4) == 0) || (strncmp(str, "gdb", 3) == 0)) {
+		register_console(&kgdbcons);
+		kgdb_console_enabled = 1;
+	}
+	return 0;		/* let others look at the string */
+}
+
+__setup("console=", kgdb_console_init);
+
+#ifdef CONFIG_KGDB_USER_CONSOLE
+static kdev_t kgdb_console_device(struct console *c);
+/* This stuff sort of works, but it knocks out telnet devices
+ * we are leaving it here in case we (or you) find time to figure it out
+ * better..
+ */
+
+/*
+ * We need a real char device as well for when the console is opened for user
+ * space activities.
+ */
+
+static int
+kgdb_consdev_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t
+kgdb_consdev_write(struct file *file, const char *buf,
+		   size_t count, loff_t * ppos)
+{
+	int size, ret = 0;
+	static char kbuf[128];
+	static DECLARE_MUTEX(sem);
+
+	/* We are not reentrant... */
+	if (down_interruptible(&sem))
+		return -ERESTARTSYS;
+
+	while (count > 0) {
+		/* need to copy the data from user space */
+		size = count;
+		if (size > sizeof (kbuf))
+			size = sizeof (kbuf);
+		if (copy_from_user(kbuf, buf, size)) {
+			ret = -EFAULT;
+			break;;
+		}
+		kgdb_console_write(&kgdbcons, kbuf, size);
+		count -= size;
+		ret += size;
+		buf += size;
+	}
+
+	up(&sem);
+
+	return ret;
+}
+
+struct file_operations kgdb_consdev_fops = {
+	open:kgdb_consdev_open,
+	write:kgdb_consdev_write
+};
+static kdev_t
+kgdb_console_device(struct console *c)
+{
+	return MKDEV(TTYAUX_MAJOR, 1);
+}
+
+/*
+ * This routine gets called from the serial stub in the i386/lib
+ * This is so it is done late in bring up (just before the console open).
+ */
+void
+kgdb_console_finit(void)
+{
+	if (kgdb_console_enabled) {
+		char *cptr = cdevname(MKDEV(TTYAUX_MAJOR, 1));
+		char *cp = cptr;
+		while (*cptr && *cptr != '(')
+			cptr++;
+		*cptr = 0;
+		unregister_chrdev(TTYAUX_MAJOR, cp);
+		register_chrdev(TTYAUX_MAJOR, "kgdb", &kgdb_consdev_fops);
+	}
+}
+#endif
+#endif
+#ifdef CONFIG_KGDB_TS
+#include <asm/msr.h>		/* time stamp code */
+#include <asm/hardirq.h>	/* in_interrupt */
+#ifdef CONFIG_KGDB_TS_64
+#define DATA_POINTS 64
+#endif
+#ifdef CONFIG_KGDB_TS_128
+#define DATA_POINTS 128
+#endif
+#ifdef CONFIG_KGDB_TS_256
+#define DATA_POINTS 256
+#endif
+#ifdef CONFIG_KGDB_TS_512
+#define DATA_POINTS 512
+#endif
+#ifdef CONFIG_KGDB_TS_1024
+#define DATA_POINTS 1024
+#endif
+#ifndef DATA_POINTS
+#define DATA_POINTS 128		/* must be a power of two */
+#endif
+#define INDEX_MASK (DATA_POINTS - 1)
+#if (INDEX_MASK & DATA_POINTS)
+#error "CONFIG_KGDB_TS_COUNT must be a power of 2"
+#endif
+struct kgdb_and_then_struct {
+#ifdef CONFIG_SMP
+	int on_cpu;
+#endif
+	struct task_struct *task;
+	long long at_time;
+	int from_ln;
+	char *in_src;
+	void *from;
+	int *with_shpf;
+	int data0;
+	int data1;
+};
+struct kgdb_and_then_struct2 {
+#ifdef CONFIG_SMP
+	int on_cpu;
+#endif
+	struct task_struct *task;
+	long long at_time;
+	int from_ln;
+	char *in_src;
+	void *from;
+	int *with_shpf;
+	struct task_struct *t1;
+	struct task_struct *t2;
+};
+struct kgdb_and_then_struct kgdb_data[DATA_POINTS];
+
+struct kgdb_and_then_struct *kgdb_and_then = &kgdb_data[0];
+int kgdb_and_then_count;
+
+void
+kgdb_tstamp(int line, char *source, int data0, int data1)
+{
+	static spinlock_t ts_spin = SPIN_LOCK_UNLOCKED;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	spin_lock(&ts_spin);
+	rdtscll(kgdb_and_then->at_time);
+#ifdef CONFIG_SMP
+	kgdb_and_then->on_cpu = smp_processor_id();
+#endif
+	kgdb_and_then->task = current;
+	kgdb_and_then->from_ln = line;
+	kgdb_and_then->in_src = source;
+	kgdb_and_then->from = __builtin_return_address(0);
+	kgdb_and_then->with_shpf = (int *)(long)(((flags & IF_BIT) >> 9) |
+					    (preempt_count() << 8));
+	kgdb_and_then->data0 = data0;
+	kgdb_and_then->data1 = data1;
+	kgdb_and_then = &kgdb_data[++kgdb_and_then_count & INDEX_MASK];
+	spin_unlock(&ts_spin);
+	local_irq_restore(flags);
+#ifdef CONFIG_PREEMPT
+
+#endif
+	return;
+}
+#endif
+typedef int gdb_debug_hook(int exceptionVector,
+			   int signo, int err_code, struct pt_regs *linux_regs);
+gdb_debug_hook *linux_debug_hook = &kgdb_handle_exception;	/* histerical reasons... */
+
+static int kgdb_need_breakpoint[NR_CPUS];
+
+void kgdb_schedule_breakpoint(void)
+{
+	kgdb_need_breakpoint[smp_processor_id()] = 1;
+}
+
+void kgdb_process_breakpoint(void)
+{
+	/*
+	 * Handle a breakpoint queued from inside network driver code
+         * to avoid reentrancy issues
+	 */
+	if (kgdb_need_breakpoint[smp_processor_id()]) {
+		kgdb_need_breakpoint[smp_processor_id()] = 0;
+		kgdb_enabled = 1;
+		BREAKPOINT;
+	}
+}
+
diff -Naur linux-2.6.11/arch/x86_64/kernel/Makefile linux-2.6.11-om/arch/x86_64/kernel/Makefile
--- linux-2.6.11/arch/x86_64/kernel/Makefile	2005-03-02 08:38:17.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/Makefile	2005-05-15 23:18:04.000000000 +0200
@@ -30,6 +30,7 @@
 obj-$(CONFIG_KPROBES)		+= kprobes.o
 
 obj-$(CONFIG_MODULES)		+= module.o
+obj-$(CONFIG_KGDB)		+= kgdb_stub.o
 
 obj-y				+= topology.o
 obj-y				+= intel_cacheinfo.o
diff -Naur linux-2.6.11/arch/x86_64/kernel/omasm.h linux-2.6.11-om/arch/x86_64/kernel/omasm.h
--- linux-2.6.11/arch/x86_64/kernel/omasm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/omasm.h	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,255 @@
+.data
+
+ENTRY(remote_sys_call_table)
+	.quad om_sys_remote		/* 0 sys_read */
+	.quad om_sys_remote		/* 1 sys_write */
+	.quad om_sys_remote		/* 2 sys_open */
+	.quad om_sys_remote		/* 3 sys_close */
+	.quad om_sys_remote		/* 4 sys_newstat */
+	.quad om_sys_remote		/* 5 sys_newfstat */
+	.quad om_sys_remote		/* 6 sys_newlstat */
+	.quad om_sys_remote		/* 7 sys_poll */
+	.quad om_sys_remote		/* 8 sys_lseek */
+	.quad sys_mmap			/* 9 sys_mmap */
+	.quad om_sys_local		/* 10 sys_mprotect */
+	.quad om_sys_local		/* 11 sys_munmap */
+	.quad om_sys_local		/* 12 sys_brk */
+	.quad om_sys_local		/* 13 sys_rt_sigaction */
+	.quad om_sys_local		/* 14 sys_rt_sigprocmask */
+	.quad stub_rt_sigreturn		/* 15 stub_rt_sigreturn */
+	.quad om_sys_remote		/* 16 sys_ioctl */
+	.quad om_sys_remote		/* 17 sys_pread64 */
+	.quad om_sys_remote		/* 18 sys_pwrite64 */
+	.quad om_sys_remote		/* 19 sys_readv */
+	.quad om_sys_remote		/* 20 sys_writev */
+	.quad om_sys_remote		/* 21 sys_access */
+	.quad om_sys_remote		/* 22 sys_pipe */
+	.quad om_sys_remote		/* 23 sys_select */
+	.quad om_sys_remote		/* 24 sys_sched_yield */
+	.quad om_sys_local		/* 25 sys_mremap */
+	.quad om_sys_local		/* 26 sys_msync */
+	.quad om_sys_local		/* 27 sys_mincore */
+	.quad om_sys_local		/* 28 sys_madvise */
+	.quad om_sys_remote		/* 29 sys_shmget */
+	.quad om_sys_remote		/* 30 wrap_sys_shmat */
+	.quad om_sys_remote		/* 31 sys_shmctl */
+	.quad om_sys_remote		/* 32 sys_dup */
+	.quad om_sys_remote		/* 33 sys_dup2 */
+	.quad om_sys_local		/* 34 sys_pause */
+	.quad om_sys_local		/* 35 sys_nanosleep */
+	.quad om_sys_remote		/* 36 sys_getitimer */
+	.quad om_sys_remote		/* 37 sys_alarm */
+	.quad om_sys_remote		/* 38 sys_setitimer */
+	.quad om_sys_getpid		/* 39 sys_getpid */
+	.quad om_sys_remote		/* 40 sys_sendfile64 */
+	.quad om_sys_remote		/* 41 sys_socket */
+	.quad om_sys_remote		/* 42 sys_connect */
+	.quad om_sys_remote		/* 43 sys_accept */
+	.quad om_sys_remote		/* 44 sys_sendto */
+	.quad om_sys_remote		/* 45 sys_recvfrom */
+	.quad om_sys_remote		/* 46 sys_sendmsg */
+	.quad om_sys_remote		/* 47 sys_recvmsg */
+	.quad om_sys_remote		/* 48 sys_shutdown */
+	.quad om_sys_remote		/* 49 sys_bind */
+	.quad om_sys_remote		/* 50 sys_listen */
+	.quad om_sys_remote		/* 51 sys_getsockname */
+	.quad om_sys_remote		/* 52 sys_getpeername */
+	.quad om_sys_remote		/* 53 sys_socketpair */
+	.quad om_sys_remote		/* 54 sys_setsockopt */
+	.quad om_sys_remote		/* 55 sys_getsockopt */
+	.quad om_stub_clone		/* 56 stub_clone */
+	.quad om_stub_fork		/* 57 stub_fork */
+	.quad om_stub_vfork		/* 58 stub_vfork */
+	.quad stub_execve		/* 59 stub_execve */
+	.quad om_sys_remote		/* 60 sys_exit */
+	.quad om_sys_remote		/* 61 sys_wait4 */
+	.quad om_sys_remote		/* 62 sys_kill */
+	.quad om_sys_remote		/* 63 sys_uname */
+	.quad om_sys_remote		/* 64 sys_semget */
+	.quad om_sys_remote		/* 65 sys_semop */
+	.quad om_sys_remote		/* 66 sys_semctl */
+	.quad om_sys_remote		/* 67 sys_shmdt */
+	.quad om_sys_remote		/* 68 sys_msgget */
+	.quad om_sys_remote		/* 69 sys_msgsnd */
+	.quad om_sys_remote		/* 70 sys_msgrcv */
+	.quad om_sys_remote		/* 71 sys_msgctl */
+	.quad om_sys_remote		/* 72 sys_fcntl */
+	.quad om_sys_remote		/* 73 sys_flock */
+	.quad om_sys_remote		/* 74 sys_fsync */
+	.quad om_sys_remote		/* 75 sys_fdatasync */
+	.quad om_sys_remote		/* 76 sys_truncate */
+	.quad om_sys_remote		/* 77 sys_ftruncate */
+	.quad om_sys_remote		/* 78 sys_getdents */
+	.quad om_sys_remote		/* 79 sys_getcwd */
+	.quad om_sys_remote		/* 80 sys_chdir */
+	.quad om_sys_remote		/* 81 sys_fchdir */
+	.quad om_sys_remote		/* 82 sys_rename */
+	.quad om_sys_remote		/* 83 sys_mkdir */
+	.quad om_sys_remote		/* 84 sys_rmdir */
+	.quad om_sys_remote		/* 85 sys_creat */
+	.quad om_sys_remote		/* 86 sys_link */
+	.quad om_sys_remote		/* 87 sys_unlink */
+	.quad om_sys_remote		/* 88 sys_symlink */
+	.quad om_sys_remote		/* 89 sys_readlink */
+	.quad om_sys_remote		/* 90 sys_chmod */
+	.quad om_sys_remote		/* 91 sys_fchmod */
+	.quad om_sys_remote		/* 92 sys_chown */
+	.quad om_sys_remote		/* 93 sys_fchown */
+	.quad om_sys_remote		/* 94 sys_lchown */
+	.quad om_sys_remote		/* 95 sys_umask */
+	.quad om_sys_remote		/* 96 sys_gettimeofday */
+	.quad om_sys_remote		/* 97 sys_getrlimit */
+	.quad om_sys_remote		/* 98 sys_getrusage */
+	.quad om_sys_remote		/* 99 sys_sysinfo */
+	.quad om_sys_remote		/* 100 sys_times */
+	.quad om_sys_remote		/* 101 sys_ptrace */
+	.quad om_sys_remote		/* 102 sys_getuid */
+	.quad om_sys_remote		/* 103 sys_syslog */
+	.quad om_sys_remote		/* 104 sys_getgid */
+	.quad om_sys_remote		/* 105 sys_setuid */
+	.quad om_sys_remote		/* 106 sys_setgid */
+	.quad om_sys_remote		/* 107 sys_geteuid */
+	.quad om_sys_remote		/* 108 sys_getegid */
+	.quad om_sys_remote		/* 109 sys_setpgid */
+	.quad om_sys_remote		/* 110 sys_getppid */
+	.quad om_sys_remote		/* 111 sys_getpgrp */
+	.quad om_sys_remote		/* 112 sys_setsid */
+	.quad om_sys_remote		/* 113 sys_setreuid */
+	.quad om_sys_remote		/* 114 sys_setregid */
+	.quad om_sys_remote		/* 115 sys_getgroups */
+	.quad om_sys_remote		/* 116 sys_setgroups */
+	.quad om_sys_remote		/* 117 sys_setresuid */
+	.quad om_sys_remote		/* 118 sys_getresuid */
+	.quad om_sys_local		/* 119 sys_setresgid */
+	.quad om_sys_local		/* 120 sys_getresgid */
+	.quad om_sys_remote		/* 121 sys_getpgid */
+	.quad om_sys_local		/* 122 sys_setfsuid */
+	.quad om_sys_local		/* 123 sys_setfsgid */
+	.quad om_sys_local		/* 124 sys_getsid */
+	.quad om_sys_remote		/* 125 sys_capget */
+	.quad om_sys_remote		/* 126 sys_capset */
+	.quad om_sys_local		/* 127 sys_rt_sigpending */
+	.quad om_sys_local		/* 128 sys_rt_sigtimedwait */
+	.quad om_sys_local		/* 129 sys_rt_sigqueueinfo */
+	.quad om_stub_rt_sigsuspend	/* 130 stub_rt_sigsuspend */
+	.quad om_stub_sigaltstack	/* 131 stub_sigaltstack */
+	.quad om_sys_remote		/* 132 sys_utime */
+	.quad om_sys_remote		/* 133 sys_mknod */
+	.quad om_sys_remote		/* 134 sys_uselib */
+	.quad om_sys_remote		/* 135 sys_personality */
+	.quad om_sys_remote		/* 136 sys_ustat */
+	.quad om_sys_remote		/* 137 sys_statfs */
+	.quad om_sys_remote		/* 138 sys_fstatfs */
+	.quad om_sys_remote		/* 139 sys_sysfs */
+	.quad om_sys_remote		/* 140 sys_getpriority */
+	.quad om_sys_remote		/* 141 sys_setpriority */
+	.quad om_sys_remote		/* 142 sys_sched_setparam */
+	.quad om_sys_remote		/* 143 sys_sched_getparam */
+	.quad om_sys_remote		/* 144 sys_sched_setscheduler */
+	.quad om_sys_remote		/* 145 sys_sched_getscheduler */
+	.quad om_sys_remote		/* 146 sys_sched_get_priority_max */
+	.quad om_sys_remote		/* 147 sys_sched_get_priority_min */
+	.quad om_sys_remote		/* 148 sys_sched_rr_get_interval */
+	.quad om_sys_remote		/* 149 sys_mlock */
+	.quad om_sys_remote		/* 150 sys_munlock */
+	.quad om_sys_remote		/* 151 sys_mlockall */
+	.quad om_sys_remote		/* 152 sys_munlockall */
+	.quad om_sys_remote		/* 153 sys_vhangup */
+	.quad om_sys_remote		/* 154 sys_modify_ldt */
+	.quad om_sys_remote		/* 155 sys_pivot_root */
+	.quad om_sys_remote		/* 156 sys_sysctl */
+	.quad om_sys_remote		/* 157 sys_prctl */
+	.quad om_sys_remote		/* 158 sys_arch_prctl */
+	.quad om_sys_remote		/* 159 sys_adjtimex */
+	.quad om_sys_remote		/* 160 sys_setrlimit */
+	.quad om_sys_remote		/* 161 sys_chroot */
+	.quad om_sys_remote		/* 162 sys_sync */
+	.quad om_sys_remote		/* 163 sys_acct */
+	.quad om_sys_remote		/* 164 sys_settimeofday */
+	.quad om_sys_remote		/* 165 sys_mount */
+	.quad om_sys_remote		/* 166 sys_umount */
+	.quad om_sys_remote		/* 167 sys_swapon */
+	.quad om_sys_remote		/* 168 sys_swapoff */
+	.quad om_sys_remote		/* 169 sys_reboot */
+	.quad om_sys_remote		/* 170 sys_sethostname */
+	.quad om_sys_remote		/* 171 sys_setdomainname */
+	.quad om_sys_remote		/* 172 stub_iopl */
+	.quad om_sys_remote		/* 173 sys_ioperm */
+	.quad sys_ni_syscall		/* 174 */
+	.quad om_sys_remote		/* 175 sys_init_module */
+	.quad om_sys_remote		/* 176 sys_delete_module */
+	.quad sys_ni_syscall		/* 177 */
+	.quad sys_ni_syscall		/* 178 */
+	.quad om_sys_remote		/* 179 sys_quotactl */
+	.quad om_sys_remote		/* 180 sys_nfsservctl */
+	.quad sys_ni_syscall		/* 181 */
+	.quad sys_ni_syscall		/* 182 */
+	.quad sys_ni_syscall		/* 183 */
+	.quad sys_ni_syscall		/* 184 */
+	.quad sys_ni_syscall		/* 185 */
+	.quad om_sys_gettid		/* 186 sys_gettid */
+	.quad om_sys_remote		/* 187 sys_readahead */
+	.quad om_sys_remote		/* 188 sys_setxattr */
+	.quad om_sys_remote		/* 189 sys_lsetxattr */
+	.quad om_sys_remote		/* 190 sys_fsetxattr */
+	.quad om_sys_remote		/* 191 sys_getxattr */
+	.quad om_sys_remote		/* 192 sys_lgetxattr */
+	.quad om_sys_remote		/* 193 sys_fgetxattr */
+	.quad om_sys_remote		/* 194 sys_listxattr */
+	.quad om_sys_remote		/* 195 sys_llistxattr */
+	.quad om_sys_remote		/* 196 sys_flistxattr */
+	.quad om_sys_remote		/* 197 sys_removexattr */
+	.quad om_sys_remote		/* 198 sys_lremovexattr */
+	.quad om_sys_remote		/* 199 sys_fremovexattr */
+	.quad om_sys_remote		/* 200 sys_tkill */
+	.quad om_sys_remote		/* 201 sys_time64 */
+	.quad om_sys_remote		/* 202 sys_futex */
+	.quad om_sys_remote	 	/* 203 sys_sched_setaffinity */
+	.quad om_sys_remote		/* 204 sys_sched_getaffinity */
+	.quad sys_ni_syscall		/* 205 */
+	.quad om_sys_remote		/* 206 sys_io_setup */
+	.quad om_sys_remote		/* 207 sys_io_destroy */
+	.quad om_sys_remote		/* 208 sys_io_getevents */
+	.quad om_sys_remote		/* 209 sys_io_submit */
+	.quad om_sys_remote		/* 210 sys_io_cancel */
+	.quad sys_ni_syscall		/* 211 */
+	.quad om_sys_remote		/* 212 sys_lookup_dcookie */
+	.quad om_sys_remote		/* 213 sys_epoll_create */
+	.quad sys_ni_syscall		/* 214 */
+	.quad sys_ni_syscall		/* 215 */
+	.quad om_sys_remote		/* 216 sys_remap_file_pages */
+	.quad om_sys_remote		/* 217 sys_getdents64 */
+	.quad om_sys_remote		/* 218 sys_set_tid_address */
+	.quad om_sys_remote		/* 219 sys_restart_syscall */
+	.quad om_sys_remote		/* 220 sys_semtimedop */
+	.quad om_sys_remote		/* 221 sys_fadvise64 */
+	.quad om_sys_remote		/* 222 sys_timer_create */
+	.quad om_sys_remote		/* 223 sys_timer_settime */
+	.quad om_sys_remote		/* 224 sys_timer_gettime */
+	.quad om_sys_remote		/* 225 sys_timer_getoverrun */
+	.quad om_sys_remote		/* 226 sys_timer_delete */
+	.quad om_sys_remote		/* 227 sys_clock_settime */
+	.quad om_sys_remote		/* 228 sys_clock_gettime */
+	.quad om_sys_remote		/* 229 sys_clock_getres */
+	.quad om_sys_remote		/* 230 sys_clock_nanosleep */
+	.quad om_sys_remote		/* 231 sys_exit_group */
+	.quad om_sys_remote		/* 232 sys_epoll_wait */
+	.quad om_sys_remote		/* 233 sys_epoll_ctl */
+	.quad om_sys_remote		/* 234 sys_tgkill */
+	.quad om_sys_remote		/* 235 sys_utimes */
+	.quad sys_ni_syscall		/* 236 */
+	.quad sys_ni_syscall		/* 236 */
+	.quad om_sys_local		/* 237 sys_mbind */
+	.quad om_sys_local		/* 238 sys_set_mempolicy */
+	.quad om_sys_local		/* 239 sys_get_mempolicy */
+	.quad om_sys_remote		/* 240 sys_mq_open */
+	.quad om_sys_remote		/* 241 sys_mq_unlink */
+	.quad om_sys_remote		/* 242 sys_mq_timedsend */
+	.quad om_sys_remote		/* 243 sys_mq_timedreceive */
+	.quad om_sys_remote		/* 244 sys_mq_notify */
+	.quad om_sys_remote		/* 245 sys_mq_getsetattr */
+	.quad om_sys_remote		/* 246 sys_kexec_load */
+	.quad om_sys_remote		/* 247 sys_waitid */
+
+remote_syscall_table_size=(.-remote_sys_call_table)
+.text
diff -Naur linux-2.6.11/arch/x86_64/kernel/smp.c linux-2.6.11-om/arch/x86_64/kernel/smp.c
--- linux-2.6.11/arch/x86_64/kernel/smp.c	2005-03-02 08:38:37.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/smp.c	2005-05-15 23:18:04.000000000 +0200
@@ -265,6 +265,18 @@
 	send_IPI_mask(cpumask_of_cpu(cpu), RESCHEDULE_VECTOR);
 }
 
+#ifdef CONFIG_KGDB
+/*
+ * By using the NMI code instead of a vector we just sneak thru the
+ * word generator coming out with just what we want.  AND it does
+ * not matter if clustered_apic_mode is set or not.
+ */
+void smp_send_nmi_allbutself(void)
+{
+	send_IPI_allbutself(APIC_DM_NMI);
+}
+#endif
+
 /*
  * Structure and data for smp_call_function(). This is designed to minimise
  * static memory requirements. It also looks cleaner.
diff -Naur linux-2.6.11/arch/x86_64/kernel/sys_x86_64.c linux-2.6.11-om/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.6.11/arch/x86_64/kernel/sys_x86_64.c	2005-03-02 08:38:13.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/sys_x86_64.c	2005-05-15 23:18:04.000000000 +0200
@@ -21,6 +21,8 @@
 #include <asm/ipc.h>
 #include <asm/ia32.h>
 
+#include <linux/hpc.h>
+
 /*
  * sys_pipe() is the normal C calling standard for creating
  * a pipe. It's not the way Unix traditionally does this, though.
@@ -52,6 +54,10 @@
 	file = NULL;
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
+#ifdef CONFIG_OPENMOSIX
+		if (task_test_dflags(current, DREMOTE))
+			return remote_do_mmap(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
+#endif
 		file = fget(fd);
 		if (!file)
 			goto out;
diff -Naur linux-2.6.11/arch/x86_64/kernel/traps.c linux-2.6.11-om/arch/x86_64/kernel/traps.c
--- linux-2.6.11/arch/x86_64/kernel/traps.c	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/kernel/traps.c	2005-05-15 23:18:04.000000000 +0200
@@ -46,6 +46,9 @@
 #include <asm/nmi.h>
 
 #include <linux/irq.h>
+#ifdef CONFIG_KGDB
+#include <asm/kgdb.h>
+#endif
 
 
 extern struct gate_struct idt_table[256]; 
diff -Naur linux-2.6.11/arch/x86_64/lib/copy_user.S linux-2.6.11-om/arch/x86_64/lib/copy_user.S
--- linux-2.6.11/arch/x86_64/lib/copy_user.S	2005-03-02 08:38:11.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/lib/copy_user.S	2005-05-15 23:18:04.000000000 +0200
@@ -21,6 +21,15 @@
 	jc  bad_to_user
 	cmpq threadinfo_addr_limit(%rax),%rcx
 	jae bad_to_user
+#ifdef CONFIG_OPENMOSIX
+	/* openmosix_memory_away inlined */
+	cmpq $0xffffffffffffffff,threadinfo_addr_limit(%rax) /* compare to kernel DS */
+	je 2f
+	movq threadinfo_task(%rax), %rax
+	testq $DDEPUTY, TASK_om+OM_dflags(%rax) # is this a DDEPUTY task ?
+	jz 2f
+	jmp deputy_copy_to_user
+#endif
 2:	
 	.byte 0xe9	/* 32bit jump */
 	.long .Lcug-1f
@@ -49,6 +58,16 @@
 	jc  bad_from_user
 	cmpq threadinfo_addr_limit(%rax),%rcx
 	jae  bad_from_user
+#ifdef CONFIG_OPENMOSIX
+	/* openmosix_memory_away inlined */
+	cmpq $0xffffffffffffffff,threadinfo_addr_limit(%rax) /* compare to kernel DS */
+	je 2901f
+	movq threadinfo_task(%rax), %rax
+	testq $DDEPUTY, TASK_om+OM_dflags(%rax) # is this a DDEPUTY task ?
+	jz 2901f
+	jmp deputy_copy_from_user
+2901:
+#endif
 	/* FALL THROUGH to copy_user_generic */
 	
 	.section .fixup,"ax"
diff -Naur linux-2.6.11/arch/x86_64/lib/kgdb_serial.c linux-2.6.11-om/arch/x86_64/lib/kgdb_serial.c
--- linux-2.6.11/arch/x86_64/lib/kgdb_serial.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/lib/kgdb_serial.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,490 @@
+/*
+ * Serial interface GDB stub
+ *
+ * Written (hacked together) by David Grothe (dave@gcom.com)
+ * Modified to allow invokation early in boot see also
+ * kgdb.h for instructions by George Anzinger(george@mvista.com)
+ * Modified to handle debugging over ethernet by Robert Walsh
+ * <rjwalsh@durables.org> and wangdi <wangdi@clusterfs.com>, based on
+ * code by San Mehat.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_reg.h>
+#include <linux/config.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/highmem.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/segment.h>
+#include <asm/bitops.h>
+#include <asm/system.h>
+#include <asm/kgdb_local.h>
+#ifdef CONFIG_KGDB_USER_CONSOLE
+extern void kgdb_console_finit(void);
+#endif
+#define PRNT_off
+#define TEST_EXISTANCE
+#ifdef PRNT
+#define dbprintk(s) printk s
+#else
+#define dbprintk(s)
+#endif
+#define TEST_INTERRUPT_off
+#ifdef TEST_INTERRUPT
+#define intprintk(s) printk s
+#else
+#define intprintk(s)
+#endif
+
+#define IRQ_T(info) ((info->flags & ASYNC_SHARE_IRQ) ? SA_SHIRQ : SA_INTERRUPT)
+
+#define	GDB_BUF_SIZE	512	/* power of 2, please */
+
+static char gdb_buf[GDB_BUF_SIZE];
+static int gdb_buf_in_inx;
+static atomic_t gdb_buf_in_cnt;
+static int gdb_buf_out_inx;
+
+struct async_struct *gdb_async_info;
+static int gdb_async_irq;
+
+#define outb_px(a,b) outb_p(b,a)
+
+static void program_uart(struct async_struct *info);
+static void write_char(struct async_struct *info, int chr);
+/*
+ * Get a byte from the hardware data buffer and return it
+ */
+static int
+read_data_bfr(struct async_struct *info)
+{
+	char it = inb_p(info->port + UART_LSR);
+
+	if (it & UART_LSR_DR)
+		return (inb_p(info->port + UART_RX));
+	/*
+	 * If we have a framing error assume somebody messed with
+	 * our uart.  Reprogram it and send '-' both ways...
+	 */
+	if (it & 0xc) {
+		program_uart(info);
+		write_char(info, '-');
+		return ('-');
+	}
+	return (-1);
+
+}				/* read_data_bfr */
+
+/*
+ * Get a char if available, return -1 if nothing available.
+ * Empty the receive buffer first, then look at the interface hardware.
+
+ * Locking here is a bit of a problem.	We MUST not lock out communication
+ * if we are trying to talk to gdb about a kgdb entry.	ON the other hand
+ * we can loose chars in the console pass thru if we don't lock.  It is also
+ * possible that we could hold the lock or be waiting for it when kgdb
+ * NEEDS to talk.  Since kgdb locks down the world, it does not need locks.
+ * We do, of course have possible issues with interrupting a uart operation,
+ * but we will just depend on the uart status to help keep that straight.
+
+ */
+static spinlock_t uart_interrupt_lock = SPIN_LOCK_UNLOCKED;
+#ifdef CONFIG_SMP
+extern spinlock_t kgdb_spinlock;
+#endif
+
+static int
+read_char(struct async_struct *info)
+{
+	int chr;
+	unsigned long flags;
+	local_irq_save(flags);
+#ifdef CONFIG_SMP
+	if (!spin_is_locked(&kgdb_spinlock)) {
+		spin_lock(&uart_interrupt_lock);
+	}
+#endif
+	if (atomic_read(&gdb_buf_in_cnt) != 0) {	/* intr routine has q'd chars */
+		chr = gdb_buf[gdb_buf_out_inx++];
+		gdb_buf_out_inx &= (GDB_BUF_SIZE - 1);
+		atomic_dec(&gdb_buf_in_cnt);
+	} else {
+		chr = read_data_bfr(info);
+	}
+#ifdef CONFIG_SMP
+	if (!spin_is_locked(&kgdb_spinlock)) {
+		spin_unlock(&uart_interrupt_lock);
+	}
+#endif
+	local_irq_restore(flags);
+	return (chr);
+}
+
+/*
+ * Wait until the interface can accept a char, then write it.
+ */
+static void
+write_char(struct async_struct *info, int chr)
+{
+	while (!(inb_p(info->port + UART_LSR) & UART_LSR_THRE)) ;
+
+	outb_p(chr, info->port + UART_TX);
+
+}				/* write_char */
+
+/*
+ * Mostly we don't need a spinlock, but since the console goes
+ * thru here with interrutps on, well, we need to catch those
+ * chars.
+ */
+/*
+ * This is the receiver interrupt routine for the GDB stub.
+ * It will receive a limited number of characters of input
+ * from the gdb  host machine and save them up in a buffer.
+ *
+ * When the gdb stub routine tty_getDebugChar() is called it
+ * draws characters out of the buffer until it is empty and
+ * then reads directly from the serial port.
+ *
+ * We do not attempt to write chars from the interrupt routine
+ * since the stubs do all of that via tty_putDebugChar() which
+ * writes one byte after waiting for the interface to become
+ * ready.
+ *
+ * The debug stubs like to run with interrupts disabled since,
+ * after all, they run as a consequence of a breakpoint in
+ * the kernel.
+ *
+ * Perhaps someone who knows more about the tty driver than I
+ * care to learn can make this work for any low level serial
+ * driver.
+ */
+static irqreturn_t
+gdb_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct async_struct *info;
+	unsigned long flags;
+
+	info = gdb_async_info;
+	if (!info || !info->tty || irq != gdb_async_irq)
+		return IRQ_NONE;
+
+	local_irq_save(flags);
+	spin_lock(&uart_interrupt_lock);
+	do {
+		int chr = read_data_bfr(info);
+		intprintk(("Debug char on int: %x hex\n", chr));
+		if (chr < 0)
+			continue;
+
+		if (chr == 3) {	/* Ctrl-C means remote interrupt */
+			BREAKPOINT;
+			continue;
+		}
+
+		if (atomic_read(&gdb_buf_in_cnt) >= GDB_BUF_SIZE) {
+			/* buffer overflow tosses early char */
+			read_char(info);
+		}
+		gdb_buf[gdb_buf_in_inx++] = chr;
+		gdb_buf_in_inx &= (GDB_BUF_SIZE - 1);
+	} while (inb_p(info->port + UART_IIR) & UART_IIR_RDI);
+	spin_unlock(&uart_interrupt_lock);
+	local_irq_restore(flags);
+	return IRQ_HANDLED;
+}				/* gdb_interrupt */
+
+/*
+ * Just a NULL routine for testing.
+ */
+void
+gdb_null(void)
+{
+}				/* gdb_null */
+
+/* These structure are filled in with values defined in asm/kgdb_local.h
+ */
+static struct serial_state state = SB_STATE;
+static struct async_struct local_info = SB_INFO;
+static int ok_to_enable_ints = 0;
+static void kgdb_enable_ints_now(void);
+
+extern char *kgdb_version;
+/*
+ * Hook an IRQ for KGDB.
+ *
+ * This routine is called from tty_putDebugChar, below.
+ */
+static int ints_disabled = 1;
+int
+gdb_hook_interrupt(struct async_struct *info, int verb)
+{
+	struct serial_state *state = info->state;
+	unsigned long flags;
+	int port;
+#ifdef TEST_EXISTANCE
+	int scratch, scratch2;
+#endif
+
+	/* The above fails if memory managment is not set up yet.
+	 * Rather than fail the set up, just keep track of the fact
+	 * and pick up the interrupt thing later.
+	 */
+	gdb_async_info = info;
+	port = gdb_async_info->port;
+	gdb_async_irq = state->irq;
+	if (verb) {
+		printk("kgdb %s : port =%x, IRQ=%d, divisor =%d\n",
+		       kgdb_version,
+		       port,
+		       gdb_async_irq, gdb_async_info->state->custom_divisor);
+	}
+	local_irq_save(flags);
+#ifdef TEST_EXISTANCE
+	/* Existance test */
+	/* Should not need all this, but just in case.... */
+
+	scratch = inb_p(port + UART_IER);
+	outb_px(port + UART_IER, 0);
+	outb_px(0xff, 0x080);
+	scratch2 = inb_p(port + UART_IER);
+	outb_px(port + UART_IER, scratch);
+	if (scratch2) {
+		printk
+		    ("gdb_hook_interrupt: Could not clear IER, not a UART!\n");
+		local_irq_restore(flags);
+		return 1;	/* We failed; there's nothing here */
+	}
+	scratch2 = inb_p(port + UART_LCR);
+	outb_px(port + UART_LCR, 0xBF);	/* set up for StarTech test */
+	outb_px(port + UART_EFR, 0);	/* EFR is the same as FCR */
+	outb_px(port + UART_LCR, 0);
+	outb_px(port + UART_FCR, UART_FCR_ENABLE_FIFO);
+	scratch = inb_p(port + UART_IIR) >> 6;
+	if (scratch == 1) {
+		printk("gdb_hook_interrupt: Undefined UART type!"
+		       "  Not a UART! \n");
+		local_irq_restore(flags);
+		return 1;
+	} else {
+		dbprintk(("gdb_hook_interrupt: UART type "
+			  "is %d where 0=16450, 2=16550 3=16550A\n", scratch));
+	}
+	scratch = inb_p(port + UART_MCR);
+	outb_px(port + UART_MCR, UART_MCR_LOOP | scratch);
+	outb_px(port + UART_MCR, UART_MCR_LOOP | 0x0A);
+	scratch2 = inb_p(port + UART_MSR) & 0xF0;
+	outb_px(port + UART_MCR, scratch);
+	if (scratch2 != 0x90) {
+		printk("gdb_hook_interrupt: "
+		       "Loop back test failed! Not a UART!\n");
+		local_irq_restore(flags);
+		return scratch2 + 1000;	/* force 0 to fail */
+	}
+#endif				/* test existance */
+	program_uart(info);
+	local_irq_restore(flags);
+
+	return (0);
+
+}				/* gdb_hook_interrupt */
+
+static void
+program_uart(struct async_struct *info)
+{
+	int port = info->port;
+
+	(void) inb_p(port + UART_RX);
+	outb_px(port + UART_IER, 0);
+
+	(void) inb_p(port + UART_RX);	/* serial driver comments say */
+	(void) inb_p(port + UART_IIR);	/* this clears the interrupt regs */
+	(void) inb_p(port + UART_MSR);
+	outb_px(port + UART_LCR, UART_LCR_WLEN8 | UART_LCR_DLAB);
+	outb_px(port + UART_DLL, info->state->custom_divisor & 0xff);	/* LS */
+	outb_px(port + UART_DLM, info->state->custom_divisor >> 8);	/* MS  */
+	outb_px(port + UART_MCR, info->MCR);
+
+	outb_px(port + UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1 | UART_FCR_CLEAR_XMIT | UART_FCR_CLEAR_RCVR);	/* set fcr */
+	outb_px(port + UART_LCR, UART_LCR_WLEN8);	/* reset DLAB */
+	outb_px(port + UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1);	/* set fcr */
+	if (!ints_disabled) {
+		intprintk(("KGDB: Sending %d to port %x offset %d\n",
+			   gdb_async_info->IER,
+			   (int) gdb_async_info->port, UART_IER));
+		outb_px(gdb_async_info->port + UART_IER, gdb_async_info->IER);
+	}
+	return;
+}
+
+/*
+ * tty_getDebugChar
+ *
+ * This is a GDB stub routine.	It waits for a character from the
+ * serial interface and then returns it.  If there is no serial
+ * interface connection then it returns a bogus value which will
+ * almost certainly cause the system to hang.  In the
+ */
+int kgdb_in_isr = 0;
+int kgdb_in_lsr = 0;
+extern spinlock_t kgdb_spinlock;
+
+/* Caller takes needed protections */
+
+int
+tty_getDebugChar(void)
+{
+	volatile int chr, dum, time, end_time;
+
+	dbprintk(("tty_getDebugChar(port %x): ", gdb_async_info->port));
+
+	if (gdb_async_info == NULL) {
+		gdb_hook_interrupt(&local_info, 0);
+	}
+	/*
+	 * This trick says if we wait a very long time and get
+	 * no char, return the -1 and let the upper level deal
+	 * with it.
+	 */
+	rdtsc(dum, time);
+	end_time = time + 2;
+	while (((chr = read_char(gdb_async_info)) == -1) &&
+	       (end_time - time) > 0) {
+		rdtsc(dum, time);
+	};
+	/*
+	 * This covers our butts if some other code messes with
+	 * our uart, hay, it happens :o)
+	 */
+	if (chr == -1)
+		program_uart(gdb_async_info);
+
+	dbprintk(("%c\n", chr > ' ' && chr < 0x7F ? chr : ' '));
+	return (chr);
+
+}				/* tty_getDebugChar */
+
+static int count = 3;
+static spinlock_t one_at_atime = SPIN_LOCK_UNLOCKED;
+
+static int __init
+kgdb_enable_ints(void)
+{
+	set_debug_traps();
+	if (kgdboe) {
+		return 0;
+	}
+	if (gdb_async_info == NULL) {
+		gdb_hook_interrupt(&local_info, 1);
+	}
+	ok_to_enable_ints = 1;
+	kgdb_enable_ints_now();
+#ifdef CONFIG_KGDB_USER_CONSOLE
+	kgdb_console_finit();
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_SERIAL_8250
+void shutdown_for_kgdb(struct async_struct *gdb_async_info);
+#endif
+
+#define kgdb_mem_init_done()    (1)
+
+static void
+kgdb_enable_ints_now(void)
+{
+	if (!spin_trylock(&one_at_atime))
+		return;
+	if (!ints_disabled)
+		goto exit;
+	if (kgdb_mem_init_done() &&
+			ints_disabled) {	/* don't try till mem init */
+#ifdef CONFIG_SERIAL_8250
+		/*
+		 * The ifdef here allows the system to be configured
+		 * without the serial driver.
+		 * Don't make it a module, however, it will steal the port
+		 */
+		shutdown_for_kgdb(gdb_async_info);
+#endif
+		ints_disabled = request_irq(gdb_async_info->state->irq,
+					    gdb_interrupt,
+					    IRQ_T(gdb_async_info),
+					    "KGDB-stub", NULL);
+		intprintk(("KGDB: request_irq returned %d\n", ints_disabled));
+	}
+	if (!ints_disabled) {
+		intprintk(("KGDB: Sending %d to port %x offset %d\n",
+			   gdb_async_info->IER,
+			   (int) gdb_async_info->port, UART_IER));
+		outb_px(gdb_async_info->port + UART_IER, gdb_async_info->IER);
+	}
+      exit:
+	spin_unlock(&one_at_atime);
+}
+
+/*
+ * tty_putDebugChar
+ *
+ * This is a GDB stub routine.	It waits until the interface is ready
+ * to transmit a char and then sends it.  If there is no serial
+ * interface connection then it simply returns to its caller, having
+ * pretended to send the char.	Caller takes needed protections.
+ */
+void
+tty_putDebugChar(int chr)
+{
+	dbprintk(("tty_putDebugChar(port %x): chr=%02x '%c', ints_on=%d\n",
+		  gdb_async_info->port,
+		  chr,
+		  chr > ' ' && chr < 0x7F ? chr : ' ', ints_disabled ? 0 : 1));
+
+	if (gdb_async_info == NULL) {
+		gdb_hook_interrupt(&local_info, 0);
+	}
+
+	write_char(gdb_async_info, chr);	/* this routine will wait */
+	count = (chr == '#') ? 0 : count + 1;
+	if ((count == 2)) {	/* try to enable after */
+		if (ints_disabled & ok_to_enable_ints)
+			kgdb_enable_ints_now();	/* try to enable after */
+
+		/* We do this a lot because, well we really want to get these
+		 * interrupts.	The serial driver will clear these bits when it
+		 * initializes the chip.  Every thing else it does is ok,
+		 * but this.
+		 */
+		if (!ints_disabled) {
+			outb_px(gdb_async_info->port + UART_IER,
+				gdb_async_info->IER);
+		}
+	}
+
+}				/* tty_putDebugChar */
+
+/*
+ * This does nothing for the serial port, since it doesn't buffer.
+ */
+
+void tty_flushDebugChar(void)
+{
+}
+
+module_init(kgdb_enable_ints);
diff -Naur linux-2.6.11/arch/x86_64/lib/Makefile linux-2.6.11-om/arch/x86_64/lib/Makefile
--- linux-2.6.11/arch/x86_64/lib/Makefile	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/lib/Makefile	2005-05-15 23:18:04.000000000 +0200
@@ -12,3 +12,4 @@
 lib-y += memcpy.o memmove.o memset.o copy_user.o
 
 lib-$(CONFIG_HAVE_DEC_LOCK) += dec_and_lock.o
+lib-$(CONFIG_KGDB) += kgdb_serial.o
diff -Naur linux-2.6.11/arch/x86_64/lib/usercopy.c linux-2.6.11-om/arch/x86_64/lib/usercopy.c
--- linux-2.6.11/arch/x86_64/lib/usercopy.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.11-om/arch/x86_64/lib/usercopy.c	2005-05-15 23:18:04.000000000 +0200
@@ -44,6 +44,10 @@
 __strncpy_from_user(char *dst, const char __user *src, long count)
 {
 	long res;
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_strncpy_from_user(dst, src, count);
+#endif
 	__do_strncpy_from_user(dst, src, count, res);
 	return res;
 }
@@ -52,6 +56,10 @@
 strncpy_from_user(char *dst, const char __user *src, long count)
 {
 	long res = -EFAULT;
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_strncpy_from_user(dst, src, count);
+#endif
 	if (access_ok(VERIFY_READ, src, 1))
 		__do_strncpy_from_user(dst, src, count, res);
 	return res;
@@ -117,6 +125,10 @@
 	if (!access_ok(VERIFY_READ, s, n))
 		return 0;
 
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_strnlen_user(s, n);
+#endif
 	while (1) {
 		if (res>n)
 			return n+1;
@@ -134,6 +146,10 @@
 	long res = 0;
 	char c;
 
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_strnlen_user(s, 0);
+#endif
 	for (;;) {
 		if (get_user(c, s))
 			return 0;
diff -Naur linux-2.6.11/Documentation/i386/kgdb/andthen linux-2.6.11-om/Documentation/i386/kgdb/andthen
--- linux-2.6.11/Documentation/i386/kgdb/andthen	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/andthen	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,100 @@
+
+define	set_andthen
+	set var $thp=0
+	set var $thp=(struct kgdb_and_then_struct *)&kgdb_data[0]
+	set var $at_size = (sizeof kgdb_data)/(sizeof *$thp)
+	set var $at_oc=kgdb_and_then_count
+	set var $at_cc=$at_oc
+end
+
+define andthen_next
+	set var $at_cc=$arg0
+end
+
+define andthen
+	andthen_set_edge
+	if ($at_cc >= $at_oc)
+		printf "Outside window.  Window size is %d\n",($at_oc-$at_low)
+	else
+		printf "%d: ",$at_cc
+		output *($thp+($at_cc++ % $at_size ))
+		printf "\n"
+	end
+end
+define andthen_set_edge
+	set var $at_oc=kgdb_and_then_count
+	set var $at_low = $at_oc - $at_size
+	if ($at_low < 0 )
+		set var $at_low = 0
+	end
+	if (( $at_cc > $at_oc) || ($at_cc < $at_low))
+		printf "Count outside of window, setting count to "
+		if ($at_cc >= $at_oc)
+			set var $at_cc = $at_oc
+		else
+			set var $at_cc = $at_low
+		end
+		printf "%d\n",$at_cc
+	end
+end
+
+define beforethat
+	andthen_set_edge
+	if ($at_cc <= $at_low)
+		printf "Outside window.  Window size is %d\n",($at_oc-$at_low)
+	else
+		printf "%d: ",$at_cc-1
+		output *($thp+(--$at_cc % $at_size ))
+		printf "\n"
+	end
+end
+
+document andthen_next
+	andthen_next <count>
+	.	sets the number of the event to display next. If this event
+	.	is not in the event pool, either andthen or beforethat will
+	.	correct it to the nearest event pool edge.  The event pool
+	.	ends at the last event recorded and begins <number of events>
+	.	prior to that.  If beforethat is used next, it will display
+	.	event <count> -1.
+.
+	andthen commands are: set_andthen, andthen_next, andthen and beforethat
+end
+
+
+document andthen
+	andthen
+.	displays the next event in the list.  <set_andthen> sets up to display
+.	the oldest saved event first.
+.	<count> (optional) count of the event to display.
+.	note the number of events saved is specified at configure time.
+.	if events are saved between calls to andthen the index will change
+.	but the displayed event will be the next one (unless the event buffer
+.	is overrun).
+.
+.	andthen commands are: set_andthen, andthen_next, andthen and beforethat
+end
+
+document set_andthen
+	set_andthen
+.	sets up to use the <andthen> and <beforethat> commands.
+.		if you have defined your own struct, use the above and
+.		then enter the following:
+.		p $thp=(struct kgdb_and_then_structX *)&kgdb_data[0]
+.		where <kgdb_and_then_structX> is the name of your structure.
+.
+.	andthen commands are: set_andthen, andthen_next, andthen and beforethat
+end
+
+document beforethat
+	beforethat
+.	displays the next prior event in the list. <set_andthen> sets up to
+.	display the last occuring event first.
+.
+.	note the number of events saved is specified at configure time.
+.	if events are saved between calls to beforethat the index will change
+.	but the displayed event will be the next one (unless the event buffer
+.	is overrun).
+.
+.	andthen commands are: set_andthen, andthen_next, andthen and beforethat
+end
diff -Naur linux-2.6.11/Documentation/i386/kgdb/debug-nmi.txt linux-2.6.11-om/Documentation/i386/kgdb/debug-nmi.txt
--- linux-2.6.11/Documentation/i386/kgdb/debug-nmi.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/debug-nmi.txt	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,37 @@
+Subject: Debugging with NMI
+Date: Mon, 12 Jul 1999 11:28:31 -0500
+From: David Grothe <dave@gcom.com>
+Organization: Gcom, Inc
+To: David Grothe <dave@gcom.com>
+
+Kernel hackers:
+
+Maybe this is old hat, but it is new to me --
+
+On an ISA bus machine, if you short out the A1 and B1 pins of an ISA
+slot you will generate an NMI to the CPU.  This interrupts even a
+machine that is hung in a loop with interrupts disabled.  Used in
+conjunction with kgdb <
+ftp://ftp.gcom.com/pub/linux/src/kgdb-2.3.35/kgdb-2.3.35.tgz > you can
+gain debugger control of a machine that is hung in the kernel!  Even
+without kgdb the kernel will print a stack trace so you can find out
+where it was hung.
+
+The A1/B1 pins are directly opposite one another and the farthest pins
+towards the bracket end of the ISA bus socket.  You can stick a paper
+clip or multi-meter probe between them to short them out.
+
+I had a spare ISA bus to PC104 bus adapter around.  The PC104 end of the
+board consists of two rows of wire wrap pins.  So I wired a push button
+between the A1/B1 pins and now have an ISA board that I can stick into
+any ISA bus slot for debugger entry.
+
+Microsoft has a circuit diagram of a PCI card at
+http://www.microsoft.com/hwdev/DEBUGGING/DMPSW.HTM.  If you want to
+build one you will have to mail them and ask for the PAL equations.
+Nobody makes one comercially.
+
+[THIS TIP COMES WITH NO WARRANTY WHATSOEVER.  It works for me, but if
+your machine catches fire, it is your problem, not mine.]
+
+-- Dave (the kgdb guy)
diff -Naur linux-2.6.11/Documentation/i386/kgdb/gdb-globals.txt linux-2.6.11-om/Documentation/i386/kgdb/gdb-globals.txt
--- linux-2.6.11/Documentation/i386/kgdb/gdb-globals.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/gdb-globals.txt	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,71 @@
+Sender: akale@veritas.com
+Date: Fri, 23 Jun 2000 19:26:35 +0530
+From: "Amit S. Kale" <akale@veritas.com>
+Organization: Veritas Software (India)
+To: Dave Grothe <dave@gcom.com>, linux-kernel@vger.rutgers.edu
+CC: David Milburn <dmilburn@wirespeed.com>,
+        "Edouard G. Parmelan" <Edouard.Parmelan@quadratec.fr>,
+        ezannoni@cygnus.com, Keith Owens <kaos@ocs.com.au>
+Subject: Re: Module debugging using kgdb
+
+Dave Grothe wrote:
+>
+> Amit:
+>
+> There is a 2.4.0 version of kgdb on our ftp site:
+> ftp://ftp.gcom.com/pub/linux/src/kgdb.  I mirrored your version of gdb
+> and loadmodule.sh there.
+>
+> Have a look at the README file and see if I go it right.  If not, send
+> me some corrections and I will update it.
+>
+> Does your version of gdb solve the global variable problem?
+
+Yes.
+Thanks to Elena Zanoni, gdb (developement version) can now calculate
+correctly addresses  of dynamically loaded object files. I have not been
+following gdb developement for sometime and am not sure when symbol
+address calculation fix is going to appear in a gdb stable version.
+
+Elena, any idea when the fix will make it to a prebuilt gdb from a
+redhat release?
+
+For the time being I have built a gdb developement version. It can be
+used for module debugging with loadmodule.sh script.
+
+The problem with calculating of module addresses with previous versions
+of gdb was as follows:
+gdb did not use base address of a section while calculating address of
+a symbol in the section in an object file loaded via 'add-symbol-file'.
+It used address of .text segment instead. Due to this addresses of
+symbols in .data, .bss etc. (e.g. global variables) were calculated incorrectly.
+
+Above mentioned fix allow gdb to use base address of a segment while
+calculating address of a symbol in it. It adds a parameter '-s' to
+'add-symbol-file' command for specifying base address of a segment.
+
+loadmodule.sh script works as follows.
+
+1. Copy a module file to target machine.
+2. Load the module on the target machine using insmod with -m parameter.
+insmod produces a module load map which contains base addresses of all
+sections in the module and addresses of symbols in the module file.
+3. Find all sections and their base addresses in the module from
+the module map.
+4. Generate a script that loads the module file. The script uses
+'add-symbol-file' and specifies address of text segment followed by
+addresses of all segments in the module.
+
+Here is an example gdb script produced by loadmodule.sh script.
+
+add-symbol-file foo 0xd082c060 -s .text.lock 0xd08cbfb5
+-s .fixup 0xd08cfbdf -s .rodata 0xd08cfde0 -s __ex_table 0xd08e3b38
+-s .data 0xd08e3d00 -s .bss 0xd08ec8c0 -s __ksymtab 0xd08ee838
+
+With this command gdb can calculate addresses of symbols in ANY segment
+in a module file.
+
+Regards.
+--
+Amit Kale
+Veritas Software ( http://www.veritas.com )
diff -Naur linux-2.6.11/Documentation/i386/kgdb/gdbinit linux-2.6.11-om/Documentation/i386/kgdb/gdbinit
--- linux-2.6.11/Documentation/i386/kgdb/gdbinit	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/gdbinit	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,14 @@
+shell echo -e "\003" >/dev/ttyS0
+set remotebaud 38400
+target remote /dev/ttyS0
+define si
+stepi
+printf "EAX=%08x EBX=%08x ECX=%08x EDX=%08x\n", $eax, $ebx, $ecx, $edx
+printf "ESI=%08x EDI=%08x EBP=%08x ESP=%08x\n", $esi, $edi, $ebp, $esp
+x/i $eip
+end
+define ni
+nexti
+printf "EAX=%08x EBX=%08x ECX=%08x EDX=%08x\n", $eax, $ebx, $ecx, $edx
+printf "ESI=%08x EDI=%08x EBP=%08x ESP=%08x\n", $esi, $edi, $ebp, $esp
+x/i $eip
diff -Naur linux-2.6.11/Documentation/i386/kgdb/gdbinit.hw linux-2.6.11-om/Documentation/i386/kgdb/gdbinit.hw
--- linux-2.6.11/Documentation/i386/kgdb/gdbinit.hw	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/gdbinit.hw	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,117 @@
+
+#Using ia-32 hardware breakpoints.
+#
+#4 hardware breakpoints are available in ia-32 processors. These breakpoints
+#do not need code modification. They are set using debug registers.
+#
+#Each hardware breakpoint can be of one of the
+#three types: execution, write, access.
+#1. An Execution breakpoint is triggered when code at the breakpoint address is
+#executed.
+#2. A write breakpoint ( aka watchpoints ) is triggered when memory location
+#at the breakpoint address is written.
+#3. An access breakpoint is triggered when memory location at the breakpoint
+#address is either read or written.
+#
+#As hardware breakpoints are available in limited number, use software
+#breakpoints ( br command in gdb ) instead of execution hardware breakpoints.
+#
+#Length of an access or a write breakpoint defines length of the datatype to
+#be watched. Length is 1 for char, 2 short , 3 int.
+#
+#For placing execution, write and access breakpoints, use commands
+#hwebrk, hwwbrk, hwabrk
+#To remove a breakpoint use hwrmbrk command.
+#
+#These commands take following types of arguments. For arguments associated
+#with each command, use help command.
+#1. breakpointno: 0 to 3
+#2. length: 1 to 3
+#3. address: Memory location in hex ( without 0x ) e.g c015e9bc
+#
+#Use the command exinfo to find which hardware breakpoint occured.
+
+#hwebrk breakpointno address
+define hwebrk
+	maintenance packet Y$arg0,0,0,$arg1
+end
+document hwebrk
+	hwebrk <breakpointno> <address>
+	Places a hardware execution breakpoint
+	<breakpointno> = 0 - 3
+	<address> = Hex digits without leading "0x".
+end
+
+#hwwbrk breakpointno length address
+define hwwbrk
+	maintenance packet Y$arg0,1,$arg1,$arg2
+end
+document hwwbrk
+	hwwbrk <breakpointno> <length> <address>
+	Places a hardware write breakpoint
+	<breakpointno> = 0 - 3
+	<length> = 1 (1 byte), 2 (2 byte), 3 (4 byte)
+	<address> = Hex digits without leading "0x".
+end
+
+#hwabrk breakpointno length address
+define hwabrk
+	maintenance packet Y$arg0,1,$arg1,$arg2
+end
+document hwabrk
+	hwabrk <breakpointno> <length> <address>
+	Places a hardware access breakpoint
+	<breakpointno> = 0 - 3
+	<length> = 1 (1 byte), 2 (2 byte), 3 (4 byte)
+	<address> = Hex digits without leading "0x".
+end
+
+#hwrmbrk breakpointno
+define hwrmbrk
+	maintenance packet y$arg0
+end
+document hwrmbrk
+	hwrmbrk <breakpointno>
+	<breakpointno> = 0 - 3
+	Removes a hardware breakpoint
+end
+
+define reboot
+        maintenance packet r
+end
+#exinfo
+define exinfo
+	maintenance packet qE
+end
+document exinfo
+	exinfo
+	Gives information about a breakpoint.
+end
+define get_th
+	p $th=(struct thread_info *)((int)$esp & ~8191)
+end
+document get_th
+	get_tu
+	Gets and prints the current thread_info pointer, Defines th to be it.
+end
+define get_cu
+	p $cu=((struct thread_info *)((int)$esp & ~8191))->task
+end
+document get_cu
+	get_cu
+	Gets and print the "current" value.  Defines $cu to be it.
+end
+define int_off
+	set var $flags=$eflags
+	set $eflags=$eflags&~0x200
+	end
+define int_on
+	set var $eflags|=$flags&0x200
+	end
+document int_off
+	saves the current interrupt state and clears the processor interrupt
+	flag.  Use int_on to restore the saved flag.
+end
+document int_on
+	Restores the interrupt flag saved by int_off.
+end
diff -Naur linux-2.6.11/Documentation/i386/kgdb/gdbinit-modules linux-2.6.11-om/Documentation/i386/kgdb/gdbinit-modules
--- linux-2.6.11/Documentation/i386/kgdb/gdbinit-modules	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/gdbinit-modules	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,149 @@
+#
+# Usefull GDB user-command to debug Linux Kernel Modules with gdbstub.
+#
+# This don't work for Linux-2.0 or older.
+#
+# Author Edouard G. Parmelan <Edouard.Parmelan@quadratec.fr>
+#
+#
+# Fri Apr 30 20:33:29 CEST 1999
+#   First public release.
+#
+#   Major cleanup after experiment Linux-2.0 kernel without success.
+#   Symbols of a module are not in the correct order, I can't explain
+#   why :(
+#
+# Fri Mar 19 15:41:40 CET 1999
+#   Initial version.
+#
+# Thu Jan  6 16:29:03 CST 2000
+#   A little fixing by Dave Grothe <dave@gcom.com>
+#
+# Mon Jun 19 09:33:13 CDT 2000
+#   Alignment changes from Edouard Parmelan
+#
+# The basic idea is to find where insmod load the module and inform
+# GDB to load the symbol table of the module with the GDB command
+# ``add-symbol-file <object> <address>''.
+#
+# The Linux kernel holds the list of all loaded modules in module_list,
+# this list end with &kernel_module (exactly with module->next == NULL,
+# but the last module is not a real module).
+#
+# Insmod allocates the struct module before the object file.  Since
+# Linux-2.1, this structure contain his size.  The real address of
+# the object file is then (char*)module + module->size_of_struct.
+#
+# You can use three user functions ``mod-list'', ``mod-print-symbols''
+# and ``add-module-symbols''.
+#
+# mod-list list all loaded modules with the format:
+#    <module-address> <module-name>
+#
+# As soon as you have found the address of your module, you can
+# print its exported symbols (mod-print-symbols) or inform GDB to add
+# symbols from your module file (mod-add-symbols).
+#
+# The argument that you give to mod-print-symbols or mod-add-symbols
+# is the <module-address> from the mod-list command.
+#
+# When using the mod-add-symbols command you must also give the full
+# pathname of the modules object code file.
+#
+# The command mod-add-lis is an example of how to make this easier.
+# You can edit this macro to contain the path name of your own
+# favorite module and then use it as a shorthand to load it.  You
+# still need the module-address, however.
+#
+# The internal function ``mod-validate'' set the GDB variable $mod
+# as a ``struct module*'' if the kernel known the module otherwise
+# $mod is set to NULL.  This ensure to not add symbols for a wrong
+# address.
+#
+#
+# Sat Feb 12 20:05:47 CET 2005
+#
+# Adapted to the 2.6.* module data structure.
+# (Getting miffed at gdb for not having "offsetof" in the process :-/ )
+#
+# Autogenerate add-symbol-file statements from the module list instead
+# of relying on a no-longer-working loadmodule.sh program.
+#
+#                                   Matthias Urlichs <smurf@debian.org>
+#
+#
+# Have a nice hacking day !
+#
+#
+define mod-list
+    set $lmod = modules->next
+    # This is a circular data structure
+    while $lmod != &modules
+		set $mod = (struct module *)(((char *)$lmod) - ((int)&(((struct module *)0) -> list)))
+        printf "%p\t%s\n", $mod, $mod->name
+		set $lmod = $lmod->next
+    end
+end
+document mod-list
+mod-list
+List all modules in the form: <module-address> <module-name>
+Use the <module-address> as the argument for the other
+mod-commands: mod-print-symbols, mod-add-symbols.
+end
+
+define mod-list-syms
+    set $lmod = modules->next
+    # This is a circular data structure
+    while $lmod != &modules
+		set $mod = (struct module *)(((char *)$lmod) - ((int)&(((struct module *)0) -> list)))
+        printf "add-symbol-file %s.ko %p\n", $mod->name, $mod->module_core
+		set $lmod = $lmod->next
+    end
+end
+document mod-list-syms
+mod-list-syms
+List all modules in the form: add-symbol-file <module-path> <module-core>
+for adding modules' symbol tables without loadmodule.sh.
+end
+
+define mod-validate
+    set $lmod = modules->next
+	set $mod = (struct module *)(((char *)$lmod) - ((int)&(((struct module *)0) -> list)))
+    while ($lmod != &modules) && ($mod != $arg0)
+        set $lmod = $lmod->next
+	    set $mod = (struct module *)(((char *)$lmod) - ((int)&(((struct module *)0) -> list)))
+    end
+    if $lmod == &modules
+    	set $mod = 0
+        printf "%p is not a module\n", $arg0
+    end
+end
+document mod-validate
+mod-validate <module-address>
+Internal user-command used to validate the module parameter.
+If <module> is a real loaded module, set $mod to it, otherwise set $mod
+to 0.
+end
+
+define mod-print-symbols
+    mod-validate $arg0
+    if $mod != 0
+		set $i = 0
+		while $i < $mod->num_syms
+			set $sym = $mod->syms[$i]
+			printf "%p\t%s\n", $sym->value, $sym->name
+			set $i = $i + 1
+		end
+		set $i = 0
+		while $i < $mod->num_gpl_syms
+			set $sym = $mod->gpl_syms[$i]
+			printf "%p\t%s\n", $sym->value, $sym->name
+			set $i = $i + 1
+		end
+    end
+end
+document mod-print-symbols
+mod-print-symbols <module-address>
+Print all exported symbols of the module.  See mod-list
+end
+
diff -Naur linux-2.6.11/Documentation/i386/kgdb/kgdbeth.txt linux-2.6.11-om/Documentation/i386/kgdb/kgdbeth.txt
--- linux-2.6.11/Documentation/i386/kgdb/kgdbeth.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/kgdbeth.txt	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,92 @@
+KGDB over ethernet
+==================
+
+Authors
+-------
+
+Robert Walsh <rjwalsh@durables.org>  (2.6 port)
+wangdi <wangdi@clusterfs.com>        (2.6 port)
+Matt Mackall <mpm@selenic.com>       (netpoll api)
+San Mehat                            (original 2.4 code)
+
+
+Introduction
+------------
+
+KGDB supports debugging over ethernet (kgdboe) via polling of a given
+network interface. Most cards should be supported automatically.
+Debugging facilities are available as soon as the network driver and
+kgdboe have initialized. Unfortunately, this is too late in the boot
+process for debugging some issues, but works quite well for many
+others. This should not interfere with normal network usage and
+doesn't require a dedicated NIC.
+
+Terminology
+-----------
+
+This document uses the following terms:
+
+  TARGET: the machine being debugged.
+  HOST:   the machine running gdb.
+
+
+Usage
+-----
+
+You need to use the following command-line option on the TARGET kernel:
+
+  kgdboe=[tgt-port]@<tgt-ip>/[dev],[host-port]@<host-ip>/[host-macaddr]
+
+    where
+        tgt-port      source for UDP packets (defaults to 6443)
+        tgt-ip        source IP to use (interface address)
+        dev           network interface (eth0)
+        host-port     HOST UDP port (6442) (not really used)
+        host-ip       IP address for HOST machine
+        host-macaddr  ethernet MAC address for HOST (ff:ff:ff:ff:ff:ff)
+
+  examples:
+
+    kgdboe=7000@192.168.0.1/eth1,7001@192.168.0.2/00:05:3C:04:47:5D
+        this machine is 192.168.0.1 on eth1
+        remote machine is 192.168.0.2 with MAC address 00:05:3C:04:47:5D
+        listen for gdb packets on port 7000
+        send unsolicited gdb packets to port 7001
+
+    kgdboe=@192.168.0.1/,@192.168.0.2/
+        this machine is 192.168.0.1 on default interface eth0
+        remote machine is 192.168.0.2, use default broadcast MAC address
+        listen for gdb packets on default port 6443
+        send unsolicited gdb packets to port 6442
+
+Only packets originating from the configured HOST IP address will be
+accepted by the debugger.
+
+On the HOST side, run gdb as normal and use a remote UDP host as the
+target:
+
+   % gdb ./vmlinux
+   GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)
+   Copyright 2003 Free Software Foundation, Inc.
+   GDB is free software, covered by the GNU General Public License, and you are
+   welcome to change it and/or distribute copies of it under certain conditions.
+   Type "show copying" to see the conditions.
+   There is absolutely no warranty for GDB.  Type "show warranty" for details.
+   This GDB was configured as "i386-redhat-linux-gnu"...
+   (gdb) target remote udp:HOSTNAME:6443
+
+You can now continue as if you were debugging over a serial line.
+
+Limitations
+-----------
+
+The current release of this code is exclusive of using kgdb on a
+serial interface, so you must boot without the kgdboe option to use
+serial debugging. Trying to debug the network driver while using it
+will prove interesting.
+
+Bug reports
+-----------
+
+Send bug reports to Robert Walsh <rjwalsh@durables.org> and Matt
+Mackall <mpm@selenic.com>.
diff -Naur linux-2.6.11/Documentation/i386/kgdb/kgdb.txt linux-2.6.11-om/Documentation/i386/kgdb/kgdb.txt
--- linux-2.6.11/Documentation/i386/kgdb/kgdb.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/kgdb.txt	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,775 @@
+Last edit: <20030806.1637.12>
+This file has information specific to the i386 kgdb option.  Other
+platforms with the kgdb option may behave in a similar fashion.
+
+New features:
+============
+20030806.1557.37
+This version was made against the 2.6.0-test2 kernel. We have made the
+following changes:
+
+- The getthread() code in the stub calls find_task_by_pid().  It fails
+  if we are early in the bring up such that the pid arrays have yet to
+  be allocated.  We have added a line to kernel/pid.c to make
+  "kgdb_pid_init_done" true once the arrays are allocated.  This way the
+  getthread() code knows not to call.  This is only used by the thread
+  debugging stuff and threads will not yet exist at this point in the
+  boot.
+
+- For some reason, gdb was not asking for a new thread list when the
+  "info thread" command was given.  We changed to the newer version of
+  the thread info command and gdb now seems to ask when needed.  Result,
+  we now get all threads in the thread list.
+
+- We now respond to the ThreadExtraInfo request from gdb with the thread
+  name from task_struct .comm.  This then appears in the thread list.
+  Thoughts on additional options for this are welcome.  Things such as
+  "has BKL" and "Preempted" come to mind.  I think we could have a flag
+  word that could enable different bits of info here.
+
+- We now honor, sort of, the C and S commands.  These are continue and
+  single set after delivering a signal.  We ignore the signal and do the
+  requested action.  This only happens when we told gdb that a signal
+  was the reason for entry, which is only done on memory faults.  The
+  result is that you can now continue into the Oops.
+
+- We changed the -g to -gdwarf-2.  This seems to be the same as -ggdb,
+  but it is more exact on what language to use.
+
+- We added two dwarf2 include files and a bit of code at the end of
+  entry.S.  This does not yet work, so it is disabled.  Still we want to
+  keep track of the code and "maybe" someone out there can fix it.
+
+- Randy Dunlap sent some fix ups for this file which are now merged.
+
+- Hugh Dickins sent a fix to a bit of code in traps.c that prevents a
+  compiler warning if CONFIG_KGDB is off (now who would do that :).
+
+- Andrew Morton sent a fix for the serial driver which is now merged.
+
+- Andrew also sent a change to the stub around the cpu managment code
+  which is also merged.
+
+- Andrew also sent a patch to make "f" as well as "g" work as SysRq
+  commands to enter kgdb, merged.
+
+- If CONFIG_KGDB and CONFIG_DEBUG_SPINLOCKS are both set we added a
+  "who" field to the spinlock data struct.  This is filled with
+  "current" when ever the spinlock suceeds.  Useful if you want to know
+  who has the lock.
+
+_ And last, but not least, we fixed the "get_cu" macro to properly get
+  the current value of "current".
+
+New features:
+============
+20030505.1827.27
+We are starting to align with the sourceforge version, at least in
+commands.  To this end, the boot command string to start kgdb at
+boot time has been changed from "kgdb" to "gdb".
+
+Andrew Morton sent a couple of patches which are now included as follows:
+1.) We now return a flag to the interrupt handler.
+2.) We no longer use smp_num_cpus (a conflict with the lock meter).
+3.) And from William Lee Irwin III <wli@holomorphy.com> code to make
+    sure high-mem is set up before we attempt to register our interrupt
+    handler.
+We now include asm/kgdb.h from config.h so you will most likely never
+have to include it.  It also 'NULLS' the kgdb macros you might have in
+your code when CONFIG_KGDB is not defined.  This allows you to just
+turn off CONFIG_KGDB to turn off all the kgdb_ts() calls and such.
+This include is conditioned on the machine being an x86 so as to not
+mess with other archs.
+
+20020801.1129.03
+This is currently the version for the 2.4.18 (and beyond?) kernel.
+
+We have several new "features" beginning with this version:
+
+1.) Kgdb now syncs the "other" CPUs with a cross-CPU NMI.  No more
+    waiting and it will pull that guy out of an IRQ off spin lock :)
+
+2.) We doctored up the code that tells where a task is waiting and
+    included it so that the "info thread" command will show a bit more
+    than "schedule()".  Try it...
+
+3.) Added the ability to call a function from gdb.  All the standard gdb
+    issues apply, i.e. if you hit a breakpoint in the function, you are
+    not allowed to call another (gdb limitation, not kgdb).  To help
+    this capability we added a memory allocation function.  Gdb does not
+    return this memory (it is used for strings that you pass to that function
+    you are calling from gdb) so we fixed up a way to allow you to
+    manually return the memory (see below).
+
+4.) Kgdb time stamps (kgdb_ts()) are enhanced to expand what was the
+    interrupt flag to now also include the preemption count and the
+    "in_interrupt" info.  The flag is now called "with_pif" to indicate
+    the order, preempt_count, in_interrupt, flag.  The preempt_count is
+    shifted left by 4 bits so you can read the count in hex by dropping
+    the low order digit.  In_interrupt is in bit 1, and the flag is in
+    bit 0.
+
+5.) The command: "p kgdb_info" is now expanded and prints something
+    like:
+(gdb) p kgdb_info
+$2 = {used_malloc = 0, called_from = 0xc0107506, entry_tsc = 67468627259,
+  errcode = 0, vector = 3, print_debug_info = 0, hold_on_sstep = 1,
+  cpus_waiting = {{task = 0xc027a000, pid = 32768, hold = 0,
+      regs = 0xc027bf84}, {task = 0x0, pid = 0, hold = 0, regs = 0x0}}}
+
+    Things to note here: a.) used_malloc is the amount of memory that
+    has been malloc'ed to do calls from gdb.  You can reclaim this
+    memory like this: "p kgdb_info.used_malloc=0" Cool, huh?  b.)
+    cpus_waiting is now "sized" by the number of CPUs you enter at
+    configure time in the kgdb configure section.  This is NOT used
+    anywhere else in the system, but it is "nice" here.  c.)  The task's
+    "pid" is now in the structure.  This is the pid you will need to use
+    to decode to the thread id to get gdb to look at that thread.
+    Remember that the "info thread" command prints a list of threads
+    wherein it numbers each thread with its reference number followed
+    by the thread's pid.  Note that the per-CPU idle threads actually
+    have pids of 0 (yes, there is more than one pid 0 in an SMP system).
+    To avoid confusion, kgdb numbers these threads with numbers beyond
+    the MAX_PID.  That is why you see 32768 and above.
+
+6.) A subtle change, we now provide the complete register set for tasks
+    that are active on the other CPUs.  This allows better trace back on
+    those tasks.
+
+    And, let's mention what we could not fix.  Back-trace from all but the
+    thread that we trapped will, most likely, have a bogus entry in it.
+    The problem is that gdb does not recognize the entry code for
+    functions that use "current" near (at all?) the entry.  The compiler
+    is putting the "current" decode as the first two instructions of the
+    function where gdb expects to find %ebp changing code.  Back trace
+    also has trouble with interrupt frames.  I am talking with Daniel
+    Jacobowitz about some way to fix this, but don't hold your breath.
+
+20011220.0050.35
+Major enhancement with this version is the ability to hold one or more
+CPUs in an SMP system while allowing the others to continue.  Also, by
+default only the current CPU is enabled on single-step commands (please
+note that gdb issues single-step commands at times other than when you
+use the si command).
+
+Another change is to collect some useful information in
+a global structure called "kgdb_info".  You should be able to just:
+
+p kgdb_info
+
+although I have seen cases where the first time this is done gdb just
+prints the first member but prints the whole structure if you then enter
+CR (carriage return or enter).  This also works:
+
+p *&kgdb_info
+
+Here is a sample:
+(gdb) p kgdb_info
+$4 = {called_from = 0xc010732c, entry_tsc = 32804123790856, errcode = 0,
+  vector = 3, print_debug_info = 0}
+
+"Called_from" is the return address from the current entry into kgdb.
+Sometimes it is useful to know why you are in kgdb, for example, was
+it an NMI or a real breakpoint?  The simple way to interrogate this
+return address is:
+
+l *0xc010732c
+
+which will print the surrounding few lines of source code.
+
+"Entry_tsc" is the CPU TSC on entry to kgdb (useful to compare to the
+kgdb_ts entries).
+
+"errcode" and "vector" are other entry parameters which may be helpful on
+some traps.
+
+"print_debug_info" is the internal debugging kgdb print enable flag.  Yes,
+you can modify it.
+
+In SMP systems kgdb_info also includes the "cpus_waiting" structure and
+"hold_on_step":
+
+(gdb) p kgdb_info
+$7 = {called_from = 0xc0112739, entry_tsc = 1034936624074, errcode = 0,
+  vector = 2, print_debug_info = 0, hold_on_sstep = 1, cpus_waiting = {{
+      task = 0x0, hold = 0, regs = 0x0}, {task = 0xc71b8000, hold = 0,
+      regs = 0xc71b9f70}, {task = 0x0, hold = 0, regs = 0x0}, {task = 0x0,
+      hold = 0, regs = 0x0}, {task = 0x0, hold = 0, regs = 0x0}, {task = 0x0,
+      hold = 0, regs = 0x0}, {task = 0x0, hold = 0, regs = 0x0}, {task = 0x0,
+      hold = 0, regs = 0x0}}}
+
+"Cpus_waiting" has an entry for each CPU other than the current one that
+has been stopped.  Each entry contains the task_struct address for that
+CPU, the address of the regs for that task and a hold flag.  All these
+have the proper typing so that, for example:
+
+p *kgdb_info.cpus_waiting[1].regs
+
+will print the registers for CPU 1.
+
+"Hold_on_sstep" is a new feature with this version and comes up set or
+true.  What this means is that whenever kgdb is asked to single-step all
+other CPUs are held (i.e. not allowed to execute).  The flag applies to
+all but the current CPU and, again, can be changed:
+
+p kgdb_info.hold_on_sstep=0
+
+restores the old behavior of letting all CPUs run during single-stepping.
+
+Likewise, each CPU has a "hold" flag, which if set, locks that CPU out
+of execution.  Note that this has some risk in cases where the CPUs need
+to communicate with each other.  If kgdb finds no CPU available on exit,
+it will push a message thru gdb and stay in kgdb.  Note that it is legal
+to hold the current CPU as long as at least one CPU can execute.
+
+20010621.1117.09
+This version implements an event queue.  Events are signaled by calling
+a function in the kgdb stub and may be examined from gdb.  See EVENTS
+below for details.  This version also tightens up the interrupt and SMP
+handling to not allow interrupts on the way to kgdb from a breakpoint
+trap.  It is fine to allow these interrupts for user code, but not
+system debugging.
+
+Version
+=======
+
+This version of the kgdb package was developed and tested on
+kernel version 2.4.16.  It will not install on any earlier kernels.
+It is possible that it will continue to work on later versions
+of 2.4 and then versions of 2.5 (I hope).
+
+
+Debugging Setup
+===============
+
+Designate one machine as the "development" machine.  This is the
+machine on which you run your compiles and which has your source
+code for the kernel.  Designate a second machine as the "target"
+machine.  This is the machine that will run your experimental
+kernel.
+
+The two machines will be connected together via a serial line out
+one or the other of the COM ports of the PC.  You will need the
+appropriate modem eliminator (null modem) cable(s) for this.
+
+Decide on which tty port you want the machines to communicate, then
+connect them up back-to-back using the null modem cable.  COM1 is
+/dev/ttyS0 and COM2 is /dev/ttyS1. You should test this connection
+with the two machines prior to trying to debug a kernel.  Once you
+have it working, on the TARGET machine, enter:
+
+setserial /dev/ttyS0 (or what ever tty you are using)
+
+and record the port address and the IRQ number.
+
+On the DEVELOPMENT machine you need to apply the patch for the kgdb
+hooks.  You have probably already done that if you are reading this
+file.
+
+On your DEVELOPMENT machine, go to your kernel source directory and do
+"make Xconfig" where X is one of "x", "menu", or "".  If you are
+configuring in the standard serial driver, it must not be a module.
+Either yes or no is ok, but making the serial driver a module means it
+will initialize after kgdb has set up the UART interrupt code and may
+cause a failure of the control-C option discussed below.  The configure
+question for the serial driver is under the "Character devices" heading
+and is:
+
+"Standard/generic (8250/16550 and compatible UARTs) serial support"
+
+Go down to the kernel debugging menu item and open it up.  Enable the
+kernel kgdb stub code by selecting that item.  You can also choose to
+turn on the "-ggdb -O1" compile options.  The -ggdb causes the compiler
+to put more debug info (like local symbols) in the object file.  On the
+i386 -g and -ggdb are the same so this option just reduces to "O1".  The
+-O1 reduces the optimization level.  This may be helpful in some cases,
+be aware, however, that this may also mask the problem you are looking
+for.
+
+The baud rate.  Default is 115200.  What ever you choose be sure that
+the host machine is set to the same speed.  I recommend the default.
+
+The port.  This is the I/O address of the serial UART that you should
+have gotten using setserial as described above.  The standard COM1 port
+(3f8) using IRQ 4 is default.  COM2 is 2f8 which by convention uses IRQ
+3.
+
+The port IRQ (see above).
+
+Stack overflow test.  This option makes a minor change in the trap,
+system call and interrupt code to detect stack overflow and transfer
+control to kgdb if it happens.  (Some platforms have this in the
+baseline code, but the i386 does not.)
+
+You can also configure the system to recognize the boot option
+"console=kgdb" which if given will cause all console output during
+booting to be put thru gdb as well as other consoles.  This option
+requires that gdb and kgdb be connected prior to sending console output
+so, if they are not, a breakpoint is executed to force the connection.
+This will happen before any kernel output (it is going thru gdb, right),
+and will stall the boot until the connection is made.
+
+You can also configure in a patch to SysRq to enable the kGdb SysRq.
+This request generates a breakpoint.  Since the serial port IRQ line is
+set up after any serial drivers, it is possible that this command will
+work when the control-C will not.
+
+Save and exit the Xconfig program.  Then do "make clean" , "make dep"
+and "make bzImage" (or whatever target you want to make).  This gets the
+kernel compiled with the "-g" option set -- necessary for debugging.
+
+You have just built the kernel on your DEVELOPMENT machine that you
+intend to run on your TARGET machine.
+
+To install this new kernel, use the following installation procedure.
+Remember, you are on the DEVELOPMENT machine patching the kernel source
+for the kernel that you intend to run on the TARGET machine.
+
+Copy this kernel to your target machine using your usual procedures.  I
+usually arrange to copy development:
+/usr/src/linux/arch/i386/boot/bzImage to /vmlinuz on the TARGET machine
+via a LAN based NFS access.  That is, I run the cp command on the target
+and copy from the development machine via the LAN.  Run Lilo (see "man
+lilo" for details on how to set this up) on the new kernel on the target
+machine so that it will boot!  Then boot the kernel on the target
+machine.
+
+On the DEVELOPMENT machine, create a file called .gdbinit in the
+directory /usr/src/linux.  An example .gdbinit file looks like this:
+
+shell echo -e "\003" >/dev/ttyS0
+set remotebaud 38400 (or what ever speed you have chosen)
+target remote /dev/ttyS0
+
+
+Change the "echo" and "target" definition so that it specifies the tty
+port that you intend to use.  Change the "remotebaud" definition to
+match the data rate that you are going to use for the com line.
+
+You are now ready to try it out.
+
+Boot your target machine with "kgdb" in the boot command i.e. something
+like:
+
+lilo> test kgdb
+
+or if you also want console output thru gdb:
+
+lilo> test kgdb console=kgdb
+
+You should see the lilo message saying it has loaded the kernel and then
+all output stops.  The kgdb stub is trying to connect with gdb.  Start
+gdb something like this:
+
+
+On your DEVELOPMENT machine, cd /usr/src/linux and enter "gdb vmlinux".
+When gdb gets the symbols loaded it will read your .gdbinit file and, if
+everything is working correctly, you should see gdb print out a few
+lines indicating that a breakpoint has been taken.  It will actually
+show a line of code in the target kernel inside the kgdb activation
+code.
+
+The gdb interaction should look something like this:
+
+    linux-dev:/usr/src/linux# gdb vmlinux
+    GDB is free software and you are welcome to distribute copies of it
+     under certain conditions; type "show copying" to see the conditions.
+    There is absolutely no warranty for GDB; type "show warranty" for details.
+    GDB 4.15.1 (i486-slackware-linux),
+    Copyright 1995 Free Software Foundation, Inc...
+    breakpoint () at i386-stub.c:750
+    750     }
+    (gdb)
+
+You can now use whatever gdb commands you like to set breakpoints.
+Enter "continue" to start your target machine executing again.  At this
+point the target system will run at full speed until it encounters
+your breakpoint or gets a segment violation in the kernel, or whatever.
+
+If you have the kgdb console enabled when you continue, gdb will print
+out all the console messages.
+
+The above example caused a breakpoint relatively early in the boot
+process.  For the i386 kgdb it is possible to code a break instruction
+as the first C-language point in init/main.c, i.e. as the first instruction
+in start_kernel().  This could be done as follows:
+
+#include <asm/kgdb.h>
+	 breakpoint();
+
+This breakpoint() is really a function that sets up the breakpoint and
+single-step hardware trap cells and then executes a breakpoint.  Any
+early hard coded breakpoint will need to use this function.  Once the
+trap cells are set up they need not be set again, but doing it again
+does not hurt anything, so you don't need to be concerned about which
+breakpoint is hit first.  Once the trap cells are set up (and the kernel
+sets them up in due course even if breakpoint() is never called) the
+macro:
+
+BREAKPOINT;
+
+will generate an inline breakpoint.  This may be more useful as it stops
+the processor at the instruction instead of in a function a step removed
+from the location of interest.  In either case <asm/kgdb.h> must be
+included to define both breakpoint() and BREAKPOINT.
+
+Triggering kgdbstub at other times
+==================================
+
+Often you don't need to enter the debugger until much later in the boot
+or even after the machine has been running for some time.  Once the
+kernel is booted and interrupts are on, you can force the system to
+enter the debugger by sending a control-C to the debug port. This is
+what the first line of the recommended .gdbinit file does.  This allows
+you to start gdb any time after the system is up as well as when the
+system is already at a breakpoint.  (In the case where the system is
+already at a breakpoint the control-C is not needed, however, it will
+be ignored by the target so no harm is done.  Also note the the echo
+command assumes that the port speed is already set.  This will be true
+once gdb has connected, but it is best to set the port speed before you
+run gdb.)
+
+Another simple way to do this is to put the following file in you ~/bin
+directory:
+
+#!/bin/bash
+echo  -e "\003"  > /dev/ttyS0
+
+Here, the ttyS0 should be replaced with what ever port you are using.
+The "\003" is control-C.  Once you are connected with gdb, you can enter
+control-C at the command prompt.
+
+An alternative way to get control to the debugger is to enable the kGdb
+SysRq command.  Then you would enter Alt-SysRq-g (all three keys at the
+same time, but push them down in the order given).  To refresh your
+memory of the available SysRq commands try Alt-SysRq-=.  Actually any
+undefined command could replace the "=", but I like to KNOW that what I
+am pushing will never be defined.
+
+Debugging hints
+===============
+
+You can break into the target machine at any time from the development
+machine by typing ^C (see above paragraph).  If the target machine has
+interrupts enabled this will stop it in the kernel and enter the
+debugger.
+
+There is unfortunately no way of breaking into the kernel if it is
+in a loop with interrupts disabled, so if this happens to you then
+you need to place exploratory breakpoints or printk's into the kernel
+to find out where it is looping.  The exploratory breakpoints can be
+entered either thru gdb or hard coded into the source.  This is very
+handy if you do something like:
+
+if (<it hurts>) BREAKPOINT;
+
+
+There is a copy of an e-mail in the Documentation/i386/kgdb/ directory
+(debug-nmi.txt) which describes how to create an NMI on an ISA bus
+machine using a paper clip.  I have a sophisticated version of this made
+by wiring a push button switch into a PC104/ISA bus adapter card.  The
+adapter card nicely furnishes wire wrap pins for all the ISA bus
+signals.
+
+When you are done debugging the kernel on the target machine it is a
+good idea to leave it in a running state.  This makes reboots faster,
+bypassing the fsck.  So do a gdb "continue" as the last gdb command if
+this is possible.  To terminate gdb itself on the development machine
+and leave the target machine running, first clear all breakpoints and
+continue, then type ^Z to suspend gdb and then kill it with "kill %1" or
+something similar.
+
+If gdbstub Does Not Work
+========================
+
+If it doesn't work, you will have to troubleshoot it.  Do the easy
+things first like double checking your cabling and data rates.  You
+might try some non-kernel based programs to see if the back-to-back
+connection works properly.  Just something simple like cat /etc/hosts
+>/dev/ttyS0 on one machine and cat /dev/ttyS0 on the other will tell you
+if you can send data from one machine to the other.  Make sure it works
+in both directions.  There is no point in tearing out your hair in the
+kernel if the line doesn't work.
+
+All of the real action takes place in the file
+/usr/src/linux/arch/i386/kernel/kgdb_stub.c.  That is the code on the target
+machine that interacts with gdb on the development machine.  In gdb you can
+turn on a debug switch with the following command:
+
+	set remotedebug
+
+This will print out the protocol messages that gdb is exchanging with
+the target machine.
+
+Another place to look is /usr/src/arch/i386/lib/kgdb_serial.c. This is
+the code that talks to the serial port on the target side.  There might
+be a problem there.  In particular there is a section of this code that
+tests the UART which will tell you what UART you have if you define
+"PRNT" (just remove "_off" from the #define PRNT_off).  To view this
+report you will need to boot the system without any beakpoints.  This
+allows the kernel to run to the point where it calls kgdb to set up
+interrupts.  At this time kgdb will test the UART and print out the type
+it finds.  (You need to wait so that the printks are actually being
+printed.  Early in the boot they are cached, waiting for the console to
+be enabled.  Also, if kgdb is entered thru a breakpoint it is possible
+to cause a dead lock by calling printk when the console is locked.  The
+stub thus avoids doing printks from breakpoints, especially in the
+serial code.)  At this time, if the UART fails to do the expected thing,
+kgdb will print out (using printk) information on what failed.  (These
+messages will be buried in all the other boot up messages.  Look for
+lines that start with "gdb_hook_interrupt:".  You may want to use dmesg
+once the system is up to view the log.  If this fails or if you still
+don't connect, review your answers for the port address.  Use:
+
+setserial /dev/ttyS0
+
+to get the current port and IRQ information.  This command will also
+tell you what the system found for the UART type. The stub recognizes
+the following UART types:
+
+16450, 16550, and 16550A
+
+If you are really desperate you can use printk debugging in the
+kgdbstub code in the target kernel until you get it working.  In particular,
+there is a global variable in /usr/src/linux/arch/i386/kernel/kgdb_stub.c
+named "remote_debug".  Compile your kernel with this set to 1, rather
+than 0 and the debug stub will print out lots of stuff as it does
+what it does.  Likewise there are debug printks in the kgdb_serial.c
+code that can be turned on with simple changes in the macro defines.
+
+
+Debugging Loadable Modules
+==========================
+
+This technique comes courtesy of Edouard Parmelan
+<Edouard.Parmelan@quadratec.fr>
+
+When you run gdb, enter the command
+
+source gdbinit-modules
+
+This will read in a file of gdb macros that was installed in your
+kernel source directory when kgdb was installed.  This file implements
+the following commands:
+
+mod-list
+    Lists the loaded modules in the form <module-address> <module-name>
+
+mod-print-symbols <module-address>
+    Prints all the symbols in the indicated module.
+
+mod-add-symbols <module-address> <object-file-path-name>
+    Loads the symbols from the object file and associates them
+    with the indicated module.
+
+After you have loaded the module that you want to debug, use the command
+mod-list to find the <module-address> of your module.  Then use that
+address in the mod-add-symbols command to load your module's symbols.
+From that point onward you can debug your module as if it were a part
+of the kernel.
+
+The file gdbinit-modules also contains a command named mod-add-lis as
+an example of how to construct a command of your own to load your
+favorite module.  The idea is to "can" the pathname of the module
+in the command so you don't have to type so much.
+
+Threads
+=======
+
+Each process in a target machine is seen as a gdb thread. gdb thread
+related commands (info threads, thread n) can be used.
+
+ia-32 hardware breakpoints
+==========================
+
+kgdb stub contains support for hardware breakpoints using debugging features
+of ia-32(x86) processors. These breakpoints do not need code modification.
+They use debugging registers. 4 hardware breakpoints are available in ia-32
+processors.
+
+Each hardware breakpoint can be of one of the following three types.
+
+1. Execution breakpoint - An Execution breakpoint is triggered when code
+	at the breakpoint address is executed.
+
+	As limited number of hardware breakpoints are available, it is
+	advisable to use software breakpoints ( break command ) instead
+	of execution hardware breakpoints, unless modification of code
+	is to be avoided.
+
+2. Write breakpoint - A write breakpoint is triggered when memory
+	location at the breakpoint address is written.
+
+	A write or can be placed for data of variable length. Length of
+	a write breakpoint indicates length of the datatype to be
+	watched. Length is 1 for 1 byte data , 2 for 2 byte data, 3 for
+	4 byte data.
+
+3. Access breakpoint - An access breakpoint is triggered when memory
+	location at the breakpoint address is either read or written.
+
+	Access breakpoints also have lengths similar to write breakpoints.
+
+IO breakpoints in ia-32 are not supported.
+
+Since gdb stub at present does not use the protocol used by gdb for hardware
+breakpoints, hardware breakpoints are accessed through gdb macros. gdb macros
+for hardware breakpoints are described below.
+
+hwebrk	- Places an execution breakpoint
+	hwebrk breakpointno address
+hwwbrk	- Places a write breakpoint
+	hwwbrk breakpointno length address
+hwabrk	- Places an access breakpoint
+	hwabrk breakpointno length address
+hwrmbrk	- Removes a breakpoint
+	hwrmbrk breakpointno
+exinfo	- Tells whether a software or hardware breakpoint has occurred.
+	Prints number of the hardware breakpoint if a hardware breakpoint has
+	occurred.
+
+Arguments required by these commands are as follows
+breakpointno	- 0 to 3
+length		- 1 to 3
+address		- Memory location in hex digits ( without 0x ) e.g c015e9bc
+
+SMP support
+==========
+
+When a breakpoint occurs or user issues a break ( Ctrl + C ) to gdb
+client, all the processors are forced to enter the debugger. Current
+thread corresponds to the thread running on the processor where
+breakpoint occurred.  Threads running on other processor(s) appear
+similar to other non-running threads in the 'info threads' output.
+Within the kgdb stub there is a structure "waiting_cpus" in which kgdb
+records the values of "current" and "regs" for each CPU other than the
+one that hit the breakpoint.  "current" is a pointer to the task
+structure for the task that CPU is running, while "regs" points to the
+saved registers for the task.  This structure can be examined with the
+gdb "p" command.
+
+ia-32 hardware debugging registers on all processors are set to same
+values.  Hence any hardware breakpoints may occur on any processor.
+
+gdb troubleshooting
+===================
+
+1. gdb hangs
+Kill it. restart gdb. Connect to target machine.
+
+2. gdb cannot connect to target machine (after killing a gdb and
+restarting another) If the target machine was not inside debugger when
+you killed gdb, gdb cannot connect because the target machine won't
+respond.  In this case echo "Ctrl+C"(ASCII 3) to the serial line.
+e.g. echo -e "\003" > /dev/ttyS1
+This forces that target machine into the debugger, after which you
+can connect.
+
+3. gdb cannot connect even after echoing Ctrl+C into serial line
+Try changing serial line settings min to 1 and time to 0
+e.g. stty min 1 time 0 < /dev/ttyS1
+Try echoing again
+
+Check serial line speed and set it to correct value if required
+e.g. stty ispeed 115200 ospeed 115200 < /dev/ttyS1
+
+EVENTS
+======
+
+Ever want to know the order of things happening?  Which CPU did what and
+when?  How did the spinlock get the way it is?  Then events are for
+you.  Events are defined by calls to an event collection interface and
+saved for later examination.  In this case, kgdb events are saved by a
+very fast bit of code in kgdb which is fully SMP and interrupt protected
+and they are examined by using gdb to display them.  Kgdb keeps only
+the last N events, where N must be a power of two and is defined at
+configure time.
+
+
+Events are signaled to kgdb by calling:
+
+kgdb_ts(data0,data1)
+
+For each call kgdb records each call in an array along with other info.
+Here is the array definition:
+
+struct kgdb_and_then_struct {
+#ifdef CONFIG_SMP
+	int	on_cpu;
+#endif
+	long long at_time;
+	int  	from_ln;
+	char	* in_src;
+	void	*from;
+        int     with_if;
+	int	data0;
+	int	data1;
+};
+
+For SMP machines the CPU is recorded, for all machines the TSC is
+recorded (gets a time stamp) as well as the line number and source file
+the call was made from.  The address of the (from), the "if" (interrupt
+flag) and the two data items are also recorded.  The macro kgdb_ts casts
+the types to int, so you can put any 32-bit values here.  There is a
+configure option to select the number of events you want to keep.  A
+nice number might be 128, but you can keep up to 1024 if you want.  The
+number must be a power of two.  An "andthen" macro library is provided
+for gdb to help you look at these events.  It is also possible to define
+a different structure for the event storage and cast the data to this
+structure.  For example the following structure is defined in kgdb:
+
+struct kgdb_and_then_struct2 {
+#ifdef CONFIG_SMP
+	int	on_cpu;
+#endif
+	long long at_time;
+	int  	from_ln;
+	char	* in_src;
+	void	*from;
+        int     with_if;
+	struct task_struct *t1;
+	struct task_struct *t2;
+};
+
+If you use this for display, the data elements will be displayed as
+pointers to task_struct entries.  You may want to define your own
+structure to use in casting.  You should only change the last two items
+and you must keep the structure size the same.  Kgdb will handle these
+as 32-bit ints, but within that constraint you can define a structure to
+cast to any 32-bit quantity.  This need only be available to gdb and is
+only used for casting in the display code.
+
+Final Items
+===========
+
+I picked up this code from Amit S. Kale and enhanced it.
+
+If you make some really cool modification to this stuff, or if you
+fix a bug, please let me know.
+
+George Anzinger
+<george@mvista.com>
+
+Amit S. Kale
+<akale@veritas.com>
+
+(First kgdb by David Grothe <dave@gcom.com>)
+
+(modified by Tigran Aivazian <tigran@sco.com>)
+    Putting gdbstub into the kernel config menu.
+
+(modified by Scott Foehner <sfoehner@engr.sgi.com>)
+    Hooks for entering gdbstub at boot time.
+
+(modified by Amit S. Kale <akale@veritas.com>)
+    Threads, ia-32 hw debugging, mp support, console support,
+    nmi watchdog handling.
+
+(modified by George Anzinger <george@mvista.com>)
+    Extended threads to include the idle threads.
+    Enhancements to allow breakpoint() at first C code.
+    Use of module_init() and __setup() to automate the configure.
+    Enhanced the cpu "collection" code to work in early bring-up.
+    Added ability to call functions from gdb
+    Print info thread stuff without going back to schedule()
+    Now collect the "other" cpus with an IPI/ NMI.
diff -Naur linux-2.6.11/Documentation/i386/kgdb/loadmodule.sh linux-2.6.11-om/Documentation/i386/kgdb/loadmodule.sh
--- linux-2.6.11/Documentation/i386/kgdb/loadmodule.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/Documentation/i386/kgdb/loadmodule.sh	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,78 @@
+#/bin/sh
+# This script loads a module on a target machine and generates a gdb script.
+# source generated gdb script to load the module file at appropriate addresses
+# in gdb.
+#
+# Usage:
+# Loading the module on target machine and generating gdb script)
+#	[foo]$ loadmodule.sh <modulename>
+#
+# Loading the module file into gdb
+#	(gdb) source <gdbscriptpath>
+#
+# Modify following variables according to your setup.
+#	TESTMACHINE - Name of the target machine
+#	GDBSCRIPTS - The directory where a gdb script will be generated
+#
+# Author: Amit S. Kale (akale@veritas.com).
+#
+# If you run into problems, please check files pointed to by following
+# variables.
+#	ERRFILE - /tmp/<modulename>.errs contains stderr output of insmod
+#	MAPFILE - /tmp/<modulename>.map contains stdout output of insmod
+#	GDBSCRIPT - $GDBSCRIPTS/load<modulename> gdb script.
+
+TESTMACHINE=foo
+GDBSCRIPTS=/home/bar
+
+if [ $# -lt 1 ] ; then {
+	echo Usage: $0 modulefile
+	exit
+} ; fi
+
+MODULEFILE=$1
+MODULEFILEBASENAME=`basename $1`
+
+if [ $MODULEFILE = $MODULEFILEBASENAME ] ; then {
+	MODULEFILE=`pwd`/$MODULEFILE
+} fi
+
+ERRFILE=/tmp/$MODULEFILEBASENAME.errs
+MAPFILE=/tmp/$MODULEFILEBASENAME.map
+GDBSCRIPT=$GDBSCRIPTS/load$MODULEFILEBASENAME
+
+function findaddr() {
+	local ADDR=0x$(echo "$SEGMENTS" | \
+		grep "$1" | sed 's/^[^ ]*[ ]*[^ ]*[ ]*//' | \
+		sed 's/[ ]*[^ ]*$//')
+	echo $ADDR
+}
+
+function checkerrs() {
+	if [ "`cat $ERRFILE`" != "" ] ; then {
+		cat $ERRFILE
+		exit
+	} fi
+}
+
+#load the module
+echo Copying $MODULEFILE to $TESTMACHINE
+rcp $MODULEFILE root@${TESTMACHINE}:
+
+echo Loading module $MODULEFILE
+rsh -l root $TESTMACHINE  /sbin/insmod -m ./`basename $MODULEFILE` \
+	> $MAPFILE 2> $ERRFILE
+checkerrs
+
+SEGMENTS=`head -n 11 $MAPFILE | tail -n 10`
+TEXTADDR=$(findaddr "\\.text[^.]")
+LOADSTRING="add-symbol-file $MODULEFILE $TEXTADDR"
+SEGADDRS=`echo "$SEGMENTS" | awk '//{
+	if ($1 != ".text" && $1 != ".this" &&
+	    $1 != ".kstrtab" && $1 != ".kmodtab") {
+		print " -s " $1 " 0x" $3 " "
+	}
+}'`
+LOADSTRING="$LOADSTRING $SEGADDRS"
+echo Generating script $GDBSCRIPT
+echo $LOADSTRING > $GDBSCRIPT
diff -Naur linux-2.6.11/drivers/char/keyboard.c linux-2.6.11-om/drivers/char/keyboard.c
--- linux-2.6.11/drivers/char/keyboard.c	2005-03-02 08:38:37.000000000 +0100
+++ linux-2.6.11-om/drivers/char/keyboard.c	2005-05-15 23:18:03.000000000 +0200
@@ -1067,6 +1067,9 @@
 	}
 	if (sysrq_down && down && !rep) {
 		handle_sysrq(kbd_sysrq_xlate[keycode], regs, tty);
+#ifdef CONFIG_KGDB_SYSRQ
+                sysrq_down = 0;        /* in case we miss the "up" event */
+#endif
 		return;
 	}
 #endif
diff -Naur linux-2.6.11/drivers/char/sysrq.c linux-2.6.11-om/drivers/char/sysrq.c
--- linux-2.6.11/drivers/char/sysrq.c	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.11-om/drivers/char/sysrq.c	2005-05-15 23:18:03.000000000 +0200
@@ -35,6 +35,25 @@
 #include <linux/spinlock.h>
 
 #include <asm/ptrace.h>
+#ifdef CONFIG_KGDB_SYSRQ
+
+#define  GDB_OP &kgdb_op
+static void kgdb_sysrq(int key, struct pt_regs *pt_regs, struct tty_struct *tty)
+{
+	printk("kgdb sysrq\n");
+	breakpoint();
+}
+
+static struct sysrq_key_op kgdb_op = {
+	.handler	= kgdb_sysrq,
+	.help_msg	= "kGdb|Fgdb",
+	.action_msg	= "Debug breakpoint\n",
+};
+
+#else
+#define  GDB_OP NULL
+#endif
+
 
 extern void reset_vc(unsigned int);
 
@@ -250,7 +269,7 @@
 /* d */	NULL,
 /* e */	&sysrq_term_op,
 /* f */	NULL,
-/* g */	NULL,
+/* g */	GDB_OP,
 /* h */	NULL,
 /* i */	&sysrq_kill_op,
 /* j */	NULL,
diff -Naur linux-2.6.11/drivers/net/kgdb_eth.c linux-2.6.11-om/drivers/net/kgdb_eth.c
--- linux-2.6.11/drivers/net/kgdb_eth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/drivers/net/kgdb_eth.c	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,132 @@
+/*
+ * Network interface GDB stub
+ *
+ * Written by San Mehat (nettwerk@biodome.org)
+ * Based upon 'gdbserial' by David Grothe (dave@gcom.com)
+ * and Scott Foehner (sfoehner@engr.sgi.com)
+ *
+ * Twiddled for 2.6 by Robert Walsh <rjwalsh@durables.org>
+ * and wangdi <wangdi@clusterfs.com>.
+ *
+ * Refactored for netpoll API by Matt Mackall <mpm@selenic.com>
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/config.h>
+#include <linux/string.h>
+#include <linux/netpoll.h>
+
+#include <asm/system.h>
+#include <asm/kgdb.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/atomic.h>
+
+#define IN_BUF_SIZE 512 /* power of 2, please */
+#define OUT_BUF_SIZE 256
+
+static char in_buf[IN_BUF_SIZE], out_buf[OUT_BUF_SIZE];
+static int in_head, in_tail, out_count;
+static atomic_t in_count;
+int kgdboe = 0; /* Default to tty mode */
+
+extern void set_debug_traps(void);
+extern void breakpoint(void);
+static void rx_hook(struct netpoll *np, int port, char *msg, int len);
+
+static struct netpoll np = {
+	.name = "kgdboe",
+	.dev_name = "eth0",
+	.rx_hook = rx_hook,
+	.local_port = 6443,
+	.remote_port = 6442,
+	.remote_mac = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
+};
+static int configured;
+
+int eth_getDebugChar(void)
+{
+	int chr;
+
+	while (atomic_read(&in_count) == 0)
+		netpoll_poll(&np);
+
+	chr = in_buf[in_tail++];
+	in_tail &= (IN_BUF_SIZE - 1);
+	atomic_dec(&in_count);
+	return chr;
+}
+
+void eth_flushDebugChar(void)
+{
+	if(out_count && np.dev) {
+		netpoll_send_udp(&np, out_buf, out_count);
+		out_count = 0;
+	}
+}
+
+void eth_putDebugChar(int chr)
+{
+	out_buf[out_count++] = chr;
+	if(out_count == OUT_BUF_SIZE)
+		eth_flushDebugChar();
+}
+
+static void rx_hook(struct netpoll *np, int port, char *msg, int len)
+{
+	int i;
+
+	np->remote_port = port;
+
+	/* Is this gdb trying to attach? */
+	if (!netpoll_trap() && len == 8 && !strncmp(msg, "$Hc-1#09", 8))
+		kgdb_schedule_breakpoint();
+
+	for (i = 0; i < len; i++) {
+		if (msg[i] == 3)
+			kgdb_schedule_breakpoint();
+
+		if (atomic_read(&in_count) >= IN_BUF_SIZE) {
+			/* buffer overflow, clear it */
+			in_head = in_tail = 0;
+			atomic_set(&in_count, 0);
+			break;
+		}
+		in_buf[in_head++] = msg[i];
+		in_head &= (IN_BUF_SIZE - 1);
+		atomic_inc(&in_count);
+	}
+}
+
+static int option_setup(char *opt)
+{
+	configured = !netpoll_parse_options(&np, opt);
+	return 0;
+}
+__setup("kgdboe=", option_setup);
+
+static int init_kgdboe(void)
+{
+#ifdef CONFIG_SMP
+	if (num_online_cpus() > CONFIG_NO_KGDB_CPUS) {
+		printk("kgdb: too manu cpus. Cannot enable debugger with more than %d cpus\n", CONFIG_NO_KGDB_CPUS);
+		return -1;
+	}
+#endif
+
+	set_debug_traps();
+
+	if(!configured || netpoll_setup(&np))
+		return 1;
+
+	kgdboe = 1;
+	printk(KERN_INFO "kgdb: debugging over ethernet enabled\n");
+
+	return 0;
+}
+
+module_init(init_kgdboe);
diff -Naur linux-2.6.11/drivers/net/Makefile linux-2.6.11-om/drivers/net/Makefile
--- linux-2.6.11/drivers/net/Makefile	2005-03-02 08:37:52.000000000 +0100
+++ linux-2.6.11-om/drivers/net/Makefile	2005-05-15 23:18:03.000000000 +0200
@@ -196,4 +196,5 @@
 obj-$(CONFIG_IRDA) += irda/
 obj-$(CONFIG_ETRAX_ETHERNET) += cris/
 
+obj-$(CONFIG_KGDB) += kgdb_eth.o
 obj-$(CONFIG_NETCONSOLE) += netconsole.o
diff -Naur linux-2.6.11/drivers/serial/8250.c linux-2.6.11-om/drivers/serial/8250.c
--- linux-2.6.11/drivers/serial/8250.c	2005-03-02 08:37:47.000000000 +0100
+++ linux-2.6.11-om/drivers/serial/8250.c	2005-05-15 23:18:03.000000000 +0200
@@ -1392,12 +1392,22 @@
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
+#ifdef CONFIG_KGDB
+int kgdb_irq = -1;
+EXPORT_SYMBOL(kgdb_irq);
+#endif
+
 static int serial8250_startup(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 	unsigned long flags;
 	int retval;
 
+#ifdef CONFIG_KGDB
+	if (up->port.irq == kgdb_irq)
+		return -EBUSY;
+#endif
+
 	up->capabilities = uart_config[up->port.type].flags;
 	up->mcr = 0;
 
@@ -2478,6 +2488,33 @@
 }
 EXPORT_SYMBOL(serial8250_unregister_port);
 
+#ifdef CONFIG_KGDB
+#include <linux/serialP.h>
+
+/*
+ * Find all the ports using the given irq and shut them down.
+ * Result should be that the irq will be released.
+ */
+void shutdown_for_kgdb(struct async_struct * info)
+{
+        int irq = info->state->irq;
+        struct uart_8250_port *up;
+	int ttyS;
+
+	kgdb_irq = irq;			/* save for later init */
+	for (ttyS = 0; ttyS < UART_NR; ttyS++){
+		up =  &serial8250_ports[ttyS];
+		if (up->port.irq == irq && (irq_lists + irq)->head) {
+#ifdef CONFIG_DEBUG_SPINLOCK   /* ugly business... */
+			if(up->port.lock.magic != SPINLOCK_MAGIC)
+				spin_lock_init(&up->port.lock);
+#endif
+			serial8250_shutdown(&up->port);
+		}
+        }
+}
+#endif	/* CONFIG_KGDB */
+
 static int __init serial8250_init(void)
 {
 	int ret, i;
diff -Naur linux-2.6.11/drivers/serial/serial_core.c linux-2.6.11-om/drivers/serial/serial_core.c
--- linux-2.6.11/drivers/serial/serial_core.c	2005-03-02 08:37:50.000000000 +0100
+++ linux-2.6.11-om/drivers/serial/serial_core.c	2005-05-15 23:18:03.000000000 +0200
@@ -1938,6 +1938,15 @@
 {
 	unsigned int flags;
 
+#ifdef CONFIG_KGDB
+	{
+		extern int kgdb_irq;
+
+		if (port->irq == kgdb_irq)
+			return;
+	}
+#endif
+
 	/*
 	 * If there isn't a port here, don't do anything further.
 	 */
diff -Naur linux-2.6.11/fs/namei.c linux-2.6.11-om/fs/namei.c
--- linux-2.6.11/fs/namei.c	2005-03-02 08:37:55.000000000 +0100
+++ linux-2.6.11-om/fs/namei.c	2005-05-15 23:18:03.000000000 +0200
@@ -139,6 +139,12 @@
 
 	result = ERR_PTR(-ENOMEM);
 	tmp = __getname();
+#ifdef CONFIG_OPENMOSIX
+	if (tmp && openmosix_memory_away()) {
+		deputy_strncpy_from_user(tmp, filename, PATH_MAX);
+		return tmp;
+	}
+#endif
 	if (tmp)  {
 		int retval = do_getname(filename, tmp);
 
diff -Naur linux-2.6.11/fs/proc/base.c linux-2.6.11-om/fs/proc/base.c
--- linux-2.6.11/fs/proc/base.c	2005-03-02 08:38:12.000000000 +0100
+++ linux-2.6.11-om/fs/proc/base.c	2005-05-15 23:18:03.000000000 +0200
@@ -34,6 +34,10 @@
 #include <linux/ptrace.h>
 #include "internal.h"
 
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/hpc.h>
+#endif
+
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
  * Feel free to change the macro below - just keep the range distinct from
@@ -74,6 +78,12 @@
 #ifdef CONFIG_AUDITSYSCALL
 	PROC_TGID_LOGINUID,
 #endif
+#ifdef CONFIG_OPENMOSIX
+	PROC_TGID_OPENMOSIX,
+	PROC_TGID_OPENMOSIX_WHERE,
+	PROC_TGID_OPENMOSIX_STAY,
+	PROC_TGID_OPENMOSIX_DEBUG,
+#endif
 	PROC_TGID_FD_DIR,
 	PROC_TGID_OOM_SCORE,
 	PROC_TGID_OOM_ADJUST,
@@ -105,6 +115,12 @@
 #ifdef CONFIG_AUDITSYSCALL
 	PROC_TID_LOGINUID,
 #endif
+#ifdef CONFIG_OPENMOSIX
+	PROC_TID_OPENMOSIX,
+	PROC_TID_OPENMOSIX_WHERE,
+	PROC_TID_OPENMOSIX_STAY,
+	PROC_TID_OPENMOSIX_DEBUG,
+#endif
 	PROC_TID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
 	PROC_TID_OOM_SCORE,
 	PROC_TID_OOM_ADJUST,
@@ -137,6 +153,9 @@
 #ifdef CONFIG_SECURITY
 	E(PROC_TGID_ATTR,      "attr",    S_IFDIR|S_IRUGO|S_IXUGO),
 #endif
+#ifdef CONFIG_OPENMOSIX
+	E(PROC_TGID_OPENMOSIX, "om",      S_IFDIR|S_IRUGO|S_IXUGO),
+#endif
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TGID_WCHAN,     "wchan",   S_IFREG|S_IRUGO),
 #endif
@@ -167,6 +186,9 @@
 #ifdef CONFIG_SECURITY
 	E(PROC_TID_ATTR,       "attr",    S_IFDIR|S_IRUGO|S_IXUGO),
 #endif
+#ifdef CONFIG_OPENMOSIX
+	E(PROC_TID_OPENMOSIX,  "om",      S_IFDIR|S_IRUGO|S_IXUGO),
+#endif
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TID_WCHAN,      "wchan",   S_IFREG|S_IRUGO),
 #endif
@@ -198,6 +220,21 @@
 };
 #endif
 
+#ifdef CONFIG_OPENMOSIX
+static struct pid_entry tgid_openmosix_stuff[] = {
+	E(PROC_TGID_OPENMOSIX_WHERE, "where",  S_IFREG|S_IRUGO|S_IWUGO),
+	E(PROC_TGID_OPENMOSIX_STAY,  "stay",   S_IFREG|S_IRUGO|S_IWUGO),
+	E(PROC_TGID_OPENMOSIX_DEBUG, "debug",   S_IFREG|S_IRUGO|S_IWUGO),
+	{0,0,NULL,0}
+};
+static struct pid_entry tid_openmosix_stuff[] = {
+	E(PROC_TID_OPENMOSIX_WHERE,  "where",  S_IFREG|S_IRUGO|S_IWUGO),
+	E(PROC_TID_OPENMOSIX_STAY,   "stay",   S_IFREG|S_IRUGO|S_IWUGO),
+	E(PROC_TID_OPENMOSIX_DEBUG,  "debug",   S_IFREG|S_IRUGO|S_IWUGO),
+	{0,0,NULL,0}
+};
+#endif
+
 #undef E
 
 static int proc_fd_link(struct inode *inode, struct dentry **dentry, struct vfsmount **mnt)
@@ -1337,6 +1374,84 @@
 static struct inode_operations proc_tgid_attr_inode_operations;
 #endif
 
+#ifdef CONFIG_OPENMOSIX
+static ssize_t proc_pid_openmosix_read(struct file * file, char * buf,
+				  size_t count, loff_t *ppos)
+{
+	struct inode * inode = file->f_dentry->d_inode;
+	unsigned long page;
+	ssize_t length;
+	ssize_t end;
+	struct task_struct *task = proc_task(inode);
+
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
+	if (!(page = __get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+
+	length = openmosix_proc_pid_getattr(task,
+				      (char*)file->f_dentry->d_name.name,
+				      (void*)page, count);
+	if (length < 0) {
+		free_page(page);
+		return length;
+	}
+	/* Static 4kB (or whatever) block capacity */
+	if (*ppos >= length) {
+		free_page(page);
+		return 0;
+	}
+	if (count + *ppos > length)
+		count = length - *ppos;
+	end = count + *ppos;
+	if (copy_to_user(buf, (char *) page + *ppos, count))
+		count = -EFAULT;
+	else
+		*ppos = end;
+	free_page(page);
+	return count;
+}
+
+static ssize_t proc_pid_openmosix_write(struct file * file, const char * buf,
+				   size_t count, loff_t *ppos)
+{
+	struct inode * inode = file->f_dentry->d_inode;
+	char *page;
+	ssize_t length;
+	struct task_struct *task = proc_task(inode);
+
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
+	if (*ppos != 0) {
+		/* No partial writes. */
+		return -EINVAL;
+	}
+	page = (char*)__get_free_page(GFP_USER);
+	if (!page)
+		return -ENOMEM;
+	length = -EFAULT; 
+	if (copy_from_user(page, buf, count)) 
+		goto out;
+
+	length = openmosix_proc_pid_setattr(task,
+				      (char*)file->f_dentry->d_name.name,
+				      (void*)page, count);
+out:
+	free_page((unsigned long) page);
+	return length;
+} 
+
+static struct file_operations proc_pid_openmosix_operations = {
+	.read		= proc_pid_openmosix_read,
+	.write		= proc_pid_openmosix_write,
+};
+
+static struct file_operations proc_tid_openmosix_operations;
+static struct inode_operations proc_tid_openmosix_inode_operations;
+static struct file_operations proc_tgid_openmosix_operations;
+static struct inode_operations proc_tgid_openmosix_inode_operations;
+#endif /* CONFIG_OPENMOSIX */
+
 /* SMP-safe */
 static struct dentry *proc_pident_lookup(struct inode *dir, 
 					 struct dentry *dentry,
@@ -1469,6 +1584,26 @@
 			inode->i_fop = &proc_pid_attr_operations;
 			break;
 #endif
+#ifdef CONFIG_OPENMOSIX
+		case PROC_TID_OPENMOSIX:
+			inode->i_nlink = 2;
+			inode->i_op = &proc_tid_openmosix_inode_operations;
+			inode->i_fop = &proc_tid_openmosix_operations;
+			break;
+		case PROC_TGID_OPENMOSIX:
+			inode->i_nlink = 2;
+			inode->i_op = &proc_tgid_openmosix_inode_operations;
+			inode->i_fop = &proc_tgid_openmosix_operations;
+			break;
+		case PROC_TID_OPENMOSIX_WHERE:
+		case PROC_TGID_OPENMOSIX_WHERE:
+		case PROC_TID_OPENMOSIX_STAY:
+		case PROC_TGID_OPENMOSIX_STAY:
+		case PROC_TID_OPENMOSIX_DEBUG:
+		case PROC_TGID_OPENMOSIX_DEBUG:
+			inode->i_fop = &proc_pid_openmosix_operations;
+			break;
+#endif
 #ifdef CONFIG_KALLSYMS
 		case PROC_TID_WCHAN:
 		case PROC_TGID_WCHAN:
@@ -1583,6 +1718,54 @@
 };
 #endif
 
+#ifdef CONFIG_OPENMOSIX
+static int proc_tgid_openmosix_readdir(struct file * filp,
+			     void * dirent, filldir_t filldir)
+{
+	return proc_pident_readdir(filp,dirent,filldir,
+				   tgid_openmosix_stuff,
+				   ARRAY_SIZE(tgid_openmosix_stuff));
+}
+
+static int proc_tid_openmosix_readdir(struct file * filp,
+			     void * dirent, filldir_t filldir)
+{
+	return proc_pident_readdir(filp,dirent,filldir,
+				   tid_openmosix_stuff,
+				   ARRAY_SIZE(tid_openmosix_stuff));
+}
+
+static struct file_operations proc_tgid_openmosix_operations = {
+	.read		= generic_read_dir,
+	.readdir	= proc_tgid_openmosix_readdir,
+};
+
+static struct file_operations proc_tid_openmosix_operations = {
+	.read		= generic_read_dir,
+	.readdir	= proc_tid_openmosix_readdir,
+};
+
+static struct dentry *proc_tgid_openmosix_lookup(struct inode *dir,
+				struct dentry *dentry, struct nameidata *nd)
+{
+	return proc_pident_lookup(dir, dentry, tgid_openmosix_stuff);
+}
+
+static struct dentry *proc_tid_openmosix_lookup(struct inode *dir,
+				struct dentry *dentry, struct nameidata *nd)
+{
+	return proc_pident_lookup(dir, dentry, tid_openmosix_stuff);
+}
+
+static struct inode_operations proc_tgid_openmosix_inode_operations = {
+	.lookup		= proc_tgid_openmosix_lookup,
+};
+
+static struct inode_operations proc_tid_openmosix_inode_operations = {
+	.lookup		= proc_tid_openmosix_lookup,
+};
+#endif /* CONFIG_OPENMOSIX */
+
 /*
  * /proc/self:
  */
diff -Naur linux-2.6.11/fs/proc/root.c linux-2.6.11-om/fs/proc/root.c
--- linux-2.6.11/fs/proc/root.c	2005-03-02 08:38:17.000000000 +0100
+++ linux-2.6.11-om/fs/proc/root.c	2005-05-15 23:18:03.000000000 +0200
@@ -18,6 +18,10 @@
 #include <linux/bitops.h>
 #include <linux/smp_lock.h>
 
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/hpc.h>
+#endif
+
 struct proc_dir_entry *proc_net, *proc_net_stat, *proc_bus, *proc_root_fs, *proc_root_driver;
 
 #ifdef CONFIG_SYSCTL
@@ -61,6 +65,9 @@
 #ifdef CONFIG_SYSCTL
 	proc_sys_root = proc_mkdir("sys", NULL);
 #endif
+#ifdef CONFIG_OPENMOSIX
+	openmosix_proc_init();
+#endif
 #if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)
 	proc_mkdir("sys/fs", NULL);
 	proc_mkdir("sys/fs/binfmt_misc", NULL);
diff -Naur linux-2.6.11/hpc/arch-i386.c linux-2.6.11-om/hpc/arch-i386.c
--- linux-2.6.11/hpc/arch-i386.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/arch-i386.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,286 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/kallsyms.h>
+#include <linux/sched.h>
+#include <hpc/debug.h>
+#include <hpc/protocol.h>
+#include <hpc/arch.h>
+#include <hpc/task.h>
+#include <hpc/hpc.h>
+#include <hpc/prototype.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/desc.h>
+#include <asm/i387.h>
+
+unsigned long twd_fxsr_to_i387(struct i387_fxsave_struct *fxsave);
+unsigned short twd_i387_to_fxsr(unsigned short twd);
+
+static void fxsave_to_fsave(union i387_union *from, union i387_union *to)
+{
+	u8 *fcp, *tcp;
+	int i; 
+
+	to->fsave.cwd = from->fxsave.cwd;
+	to->fsave.swd = from->fxsave.swd;
+	to->fsave.twd = twd_fxsr_to_i387(&from->fxsave);
+	to->fsave.fip = from->fxsave.fip;
+	to->fsave.fcs = from->fxsave.fcs;
+	to->fsave.foo = from->fxsave.foo;
+	to->fsave.fos = from->fxsave.fos;
+	to->fxsave.padding[0] = from->fxsave.fop;
+	to->fxsave.padding[1] = from->fxsave.mxcsr;
+
+	fcp = (u8 *) from->fxsave.st_space;
+	tcp = (u8 *) to->fsave.st_space;
+
+	/* 8 registers of 16 bytes to copy to 10 bytes */
+	for (i = 0; i < 8; i++, tcp += 10, fcp += 16)
+		memcpy(tcp, fcp, 10);
+
+	memcpy(to->fxsave.xmm_space, from->fxsave.xmm_space,
+					sizeof(to->fxsave.xmm_space));
+}
+
+static void fsave_to_fxsave(union i387_union *from, union i387_union *to)
+{
+	u8 *fcp, *tcp;
+	int i;
+
+	to->fxsave.cwd = from->fsave.cwd;
+	to->fxsave.swd = from->fsave.swd;
+	to->fxsave.twd = twd_i387_to_fxsr(from->fsave.twd);
+	to->fxsave.fop = from->fxsave.padding[0];
+	to->fxsave.fip = from->fsave.fip;
+	to->fxsave.fcs = from->fsave.fcs;
+	to->fxsave.foo = from->fsave.foo;
+	to->fxsave.mxcsr = from->fxsave.padding[1];
+	to->fxsave.fos = from->fsave.fos;
+
+	fcp = (u8 *) from->fsave.st_space;
+	tcp = (u8 *) to->fxsave.st_space;
+
+	/* 8 registers of 10 bytes to copy to 16 bytes */
+	for (i = 0; i < 8; i++, tcp += 16, fcp += 10)
+		memcpy(tcp, fcp, 10);
+
+	memcpy(to->fxsave.xmm_space, from->fxsave.xmm_space,
+					sizeof(from->fxsave.xmm_space));
+}
+
+
+/*****************************************************************************/
+/* receive part */
+
+int arch_mig_receive_specific(task_t *p, struct omp_mig_arch *m)
+{
+	switch (m->type)
+	{
+		case MIG_ARCH_I386_LDT:
+			printk(KERN_WARNING "oM: mig arch ldt not handle yet.\n");
+			break;
+		default:
+			printk(KERN_ERR "oM: mig arch type not handle.\n");
+			return 1;
+	}
+	return 0;
+}
+
+int arch_mig_receive_proc_context(task_t *p, struct omp_mig_task *m)
+{
+	struct pt_regs *regs;
+	int i;
+
+	/* copy pt_regs */
+	regs = ARCH_TASK_GET_USER_REGS(p);
+	memcpy(regs, &m->regs, sizeof(struct pt_regs));
+
+	/* debugs regs */
+	memcpy((caddr_t) p->thread.debugreg, (caddr_t) m->arch.debugreg,
+						sizeof(m->arch.debugreg));
+
+	/* copy some segmentation registers */
+	p->thread.fs = m->arch.fs;
+	p->thread.gs = m->arch.gs;
+	for (i = 0; i < GDT_ENTRY_TLS_ENTRIES; i++)
+		p->thread.tls_array[i] = m->arch.tls_array[i];
+
+	return 0;
+}
+
+void arch_mig_receive_fp(task_t *p, struct omp_mig_fp *fp)
+{
+	unlazy_fpu(p);
+
+	/* if same kind of cpu we just memcpy the structure */
+	if ((cpu_feature_has_fxsr() && fp->has_fxsr)
+			|| (!cpu_feature_has_fxsr() && !fp->has_fxsr))
+	{
+		memcpy(&p->thread.i387, &fp->data, sizeof(union i387_union));
+		return;
+	}
+
+	if (fp->has_fxsr)
+		fxsave_to_fsave(&fp->data, &p->thread.i387);
+	else
+		fsave_to_fxsave(&fp->data, &p->thread.i387);
+		
+}
+
+/*****************************************************************************/
+/* send part */
+
+void arch_mig_send_pre(task_t *p)
+{
+	if (p->mm->context.ldt)
+		clear_LDT();
+}
+
+void arch_mig_send_post(task_t *p)
+{
+	if (p->mm->context.ldt)
+		load_LDT(&p->mm->context);
+}
+
+int arch_mig_send_specific(task_t *p)
+{
+	mm_context_t *pc = &p->mm->context;
+	
+	if (pc->size)
+		printk(KERN_WARNING "process has specific ldt\n");
+	return 0;
+}
+
+int arch_mig_send_fp(task_t *p, struct omp_mig_fp *fp)
+{
+	unlazy_fpu(p);
+	fp->has_fxsr = cpu_feature_has_fxsr();
+	memcpy(&fp->data, &p->thread.i387, sizeof(p->thread.i387));
+	return 0;
+}
+
+int arch_mig_send_proc_context(task_t *p, struct omp_mig_task *m)
+{
+	struct pt_regs *regs;
+	int i;
+	
+	/* copy pt_regs */
+	regs = ARCH_TASK_GET_USER_REGS(p);
+	memcpy(&m->regs, regs, sizeof(struct pt_regs));
+
+	/* copy some segmentation registers */
+	m->arch.fs = p->thread.fs;
+	m->arch.gs = p->thread.gs;
+
+	for (i = 0; i < GDT_ENTRY_TLS_ENTRIES; i++)
+		m->arch.tls_array[i] = p->thread.tls_array[i];
+	
+	/* copy debugregs */
+	memcpy((caddr_t)m->arch.debugreg, (caddr_t)p->thread.debugreg,
+					sizeof(m->arch.debugreg));
+			
+	if (task_test_dflags(p, DDEPUTY))
+		memcpy(m->arch.features, boot_cpu_data.x86_capability,
+					sizeof(m->arch.features));
+
+	return 0;
+}
+
+
+asmlinkage void ret_from_kickstart(void) __asm__("ret_from_kickstart");
+
+#define loaddebug(tsk,register) \
+		__asm__("movl %0,%%db" #register  \
+			: /* no output */ \
+			:"r" (tsk->thread.debugreg[register]))
+
+NORET_TYPE void arch_kickstart(struct task_struct *p)
+{
+	struct pt_regs *regs;
+	regs = ARCH_TASK_GET_USER_REGS(p);
+	
+	if (p->thread.debugreg[7]) {
+		loaddebug(p, 0);
+		loaddebug(p, 1);
+		loaddebug(p, 2);
+		loaddebug(p, 3);
+		loaddebug(p, 6);
+		loaddebug(p, 7);
+	}
+
+	load_TLS(&p->thread, smp_processor_id());
+	
+	loadsegment(fs, p->thread.fs);
+	loadsegment(gs, p->thread.gs);
+	
+	regs->xcs = __USER_CS;
+
+	/* FIXME: not sure about this one */
+	flush_signals(p);
+	
+	asm(	"movl %0,%%esp\n\t"
+		"jmp ret_from_kickstart\n\t"
+		: /**/ : "r"(regs));
+}
+
+/*****************************************************************************/
+#include <hpc/syscalls.h>
+#include <asm/unistd.h>
+
+long arch_exec_syscall(int n, syscall_parameter_t * args)
+{
+	syscall_func_t fct;
+	extern void * sys_call_table[];
+	
+	OMDEBUG_SYS(4, "exec_sys[%d](%lx, %lx, %lx, %lx, %lx, %lx)\n", n,
+			args->arg[0], args->arg[1], args->arg[2],
+			args->arg[3], args->arg[4], args->arg[5]);
+	fct = (syscall_func_t) sys_call_table[n];
+	return fct(*((syscall_parameter_t *) args));
+}
+
+asmlinkage long om_sys_fork(struct pt_regs regs)
+{
+	return remote_do_fork(SIGCHLD, regs.esp, &regs, 0, NULL, NULL);
+}
+
+asmlinkage long om_sys_clone(struct pt_regs regs)
+{
+	unsigned long clone_flags;
+	unsigned long newsp;
+	int __user *parent_tidptr, *child_tidptr;
+	int retval;
+
+	clone_flags = regs.ebx;
+	newsp = regs.ecx;
+	parent_tidptr = (int __user *)regs.edx;
+	child_tidptr = (int __user *)regs.edi;
+	if (!newsp)
+		newsp = regs.esp;
+	retval = remote_do_fork(clone_flags, newsp, &regs, 0, parent_tidptr, child_tidptr);
+	return retval;
+}
+
+asmlinkage long om_sys_execve(struct pt_regs regs)
+{
+	return remote_do_execve((char __user *) regs.ebx,
+				(char __user * __user *) regs.ecx,
+				(char __user * __user *) regs.edx,
+				&regs);
+}
diff -Naur linux-2.6.11/hpc/arch-ppc.c linux-2.6.11-om/hpc/arch-ppc.c
--- linux-2.6.11/hpc/arch-ppc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/arch-ppc.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,111 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <asm/uaccess.h>
+#include <linux/kallsyms.h>
+#include <linux/sched.h>
+#include <hpc/debug.h>
+#include <asm/ptrace.h>
+#include <hpc/prototype.h>
+#include <asm/processor.h>
+#include <hpc/protocol.h>
+#include <hpc/arch.h>
+
+/*****************************************************************************/
+/* receive part */
+
+int arch_mig_receive_specific(task_t *p, struct omp_mig_arch *m)
+{
+	return 0;
+}
+
+int arch_mig_receive_proc_context(task_t *p, struct omp_mig_task *m)
+{
+	struct pt_regs *regs;
+
+	regs = ARCH_TASK_GET_USER_REGS(p);
+	memcpy(regs, &m->regs, sizeof(struct pt_regs));
+	return 0;
+}
+
+void arch_mig_receive_fp(task_t *p, struct omp_mig_fp *fp)
+{
+	struct thread_struct *th = &p->thread;
+	
+	memcpy(th->fpr, fp->fpr, sizeof(th->fpr));
+
+	th->fpscr_pad = fp->fpscr_pad; /* FIXME: not sure this one is needed */
+	th->fpscr = fp->fpscr;
+	
+}
+
+/*****************************************************************************/
+/* send part */
+
+void arch_mig_send_pre(task_t *p)
+{
+}
+
+void arch_mig_send_post(task_t *p)
+{
+}
+
+int arch_mig_send_specific(task_t *p)
+{
+	return 0;
+}
+
+int arch_mig_send_fp(task_t *p, struct omp_mig_fp *fp)
+{
+	struct thread_struct *th = &p->thread;
+
+	memcpy(fp->fpr, th->fpr, sizeof(fp->fpr));
+
+	fp->fpscr_pad = th->fpscr_pad; /* FIXME: not sure this one is needed */
+	fp->fpscr = th->fpscr;
+	return 0;
+}
+
+int arch_mig_send_proc_context(task_t *p, struct omp_mig_task *m)
+{
+	struct pt_regs *regs;
+
+	regs = ARCH_TASK_GET_USER_REGS(p);
+	memcpy(&m->regs, &regs, sizeof(struct pt_regs));
+	return 0;
+}
+
+
+void arch_kickstart(struct task_struct *p)
+{
+	struct pt_regs *regs;
+
+	regs = ARCH_TASK_GET_USER_REGS(p);
+	asm (	"mr 1, %0\n\t"
+		"b ret_from_kickstart\n\t"
+		: /**/ : "r"(regs));
+}
+
+long arch_exec_syscall(int n, syscall_parameter_t * args)
+{
+	syscall_func_t fct;
+	extern void * sys_call_table[];
+
+	fct = (syscall_func_t) sys_call_table[n];
+	return fct(*((syscall_parameter_t *) args));
+}
diff -Naur linux-2.6.11/hpc/arch-x86_64.c linux-2.6.11-om/hpc/arch-x86_64.c
--- linux-2.6.11/hpc/arch-x86_64.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/arch-x86_64.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,195 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <asm/uaccess.h>
+#include <linux/kallsyms.h>
+#include <linux/sched.h>
+#include <hpc/debug.h>
+#include <asm/ptrace.h>
+#include <asm/desc.h>
+#include <asm/i387.h>
+#include <hpc/protocol.h>
+#include <hpc/arch.h>
+#include <hpc/task.h>
+#include <hpc/syscalls.h>
+#include <hpc/prototype.h>
+
+/*****************************************************************************/
+/* receive part */
+
+int arch_mig_receive_specific(task_t *p, struct omp_mig_arch *m)
+{
+	return 0;
+}
+
+int arch_mig_receive_proc_context(task_t *p, struct omp_mig_task *m)
+{
+	struct pt_regs *regs;
+	int i;
+
+	regs = ARCH_TASK_GET_USER_REGS(p);
+
+	memcpy(regs, &m->regs, sizeof(struct pt_regs));
+
+	/*
+	for (i = 0; i < TLS_SIZE; i++)
+		p->thread.tls_array[i] = m->arch.tls_array[i];
+	*/
+
+	p->thread.ds = m->arch.ds;
+	p->thread.es = m->arch.es;
+	p->thread.fs = m->arch.fs;
+	p->thread.gs = m->arch.gs;
+	p->thread.fsindex = m->arch.fsindex;
+	p->thread.gsindex = m->arch.gsindex;
+	p->thread.userrsp = m->arch.userrsp;
+	write_pda(oldrsp, m->arch.userrsp);
+
+	return 0;
+}
+
+void arch_mig_receive_fp(task_t *p, struct omp_mig_fp *fp)
+{
+	unlazy_fpu(p);
+
+	/* all opterons got same fp feature */
+	memcpy(&p->thread.i387, &fp->data, sizeof(union i387_union));
+}
+
+/*****************************************************************************/
+/* send part */
+
+void arch_mig_send_pre(task_t *p)
+{
+	if (p->mm->context.ldt)
+		clear_LDT();
+}
+
+void arch_mig_send_post(task_t *p)
+{
+	if (p->mm->context.ldt)
+		load_LDT(&p->mm->context);
+}
+
+int arch_mig_send_specific(task_t *p)
+{
+	return 0;
+}
+
+int arch_mig_send_fp(task_t *p, struct omp_mig_fp *fp)
+{
+	unlazy_fpu(p);
+	memcpy(&fp->data, &p->thread.i387, sizeof(p->thread.i387));
+	return 0;
+}
+
+int arch_mig_send_proc_context(task_t *p, struct omp_mig_task *m)
+{
+	struct pt_regs *regs;
+	int i;
+	
+	regs = ARCH_TASK_GET_USER_REGS(p);
+
+	memcpy(&m->regs, regs, sizeof(struct pt_regs));
+
+	for (i = 0; i < TLS_SIZE; i++)
+		m->arch.tls_array[i] = p->thread.tls_array[i];
+
+	m->arch.ds = p->thread.ds;
+	m->arch.es = p->thread.es;
+	m->arch.fs = p->thread.fs;
+	m->arch.gs = p->thread.gs;
+	m->arch.fsindex = p->thread.fsindex;
+	m->arch.gsindex = p->thread.gsindex;
+	m->arch.userrsp = read_pda(oldrsp);
+
+	return 0;
+}
+
+
+asmlinkage void ret_from_kickstart(void) __asm__("ret_from_kickstart");
+
+void arch_kickstart(struct task_struct *p)
+{
+	struct pt_regs *regs;
+	regs = ARCH_TASK_GET_USER_REGS(p);
+	
+	if (p->thread.debugreg7) {
+		__asm__("movq %0,%%db0" : /* */ :"r" (p->thread.debugreg0));
+		__asm__("movq %0,%%db1" : /* */ :"r" (p->thread.debugreg1));
+		__asm__("movq %0,%%db2" : /* */ :"r" (p->thread.debugreg2));
+		__asm__("movq %0,%%db3" : /* */ :"r" (p->thread.debugreg3));
+		__asm__("movq %0,%%db6" : /* */ :"r" (p->thread.debugreg6));
+		__asm__("movq %0,%%db7" : /* */ :"r" (p->thread.debugreg7));
+	}
+	
+	/*
+	load_TLS(&p->thread, smp_processor_id());
+	*/
+
+	if (p->thread.ds)
+		loadsegment(ds, p->thread.ds);
+	if (p->thread.es)
+		loadsegment(es, p->thread.es);
+	if (p->thread.fsindex)
+		loadsegment(fs, p->thread.fsindex);
+	if (p->thread.gsindex)
+		load_gs_index(p->thread.gsindex);
+
+	regs->cs = __USER_CS;
+	regs->ss = __USER_DS;
+	set_fs(USER_DS);
+
+	/* FIXME: not sure about this one */
+	flush_signals(p);
+	
+	asm(	"movq %0,%%rsp\n\t"
+		"jmp ret_from_kickstart\n\t"
+		: /**/ : "r"(regs));
+}
+
+long arch_exec_syscall(int n, syscall_parameter_t * args)
+{
+	long ret;
+
+	asm (	"movq %5, %%r8\n\t"
+		"movq %6, %%r9\n\t"
+		"call *sys_call_table(,%%rax,8)\n\t"
+		: "=a" (ret)
+		: "D" (args->arg[0]), "S" (args->arg[1]), "d" (args->arg[2]),
+		  "c" (args->arg[3]), "g" (args->arg[4]), "g" (args->arg[5]),
+		  "a" (n)
+		: "memory", "r8", "r9");
+
+	return ret;
+}
+
+asmlinkage long om_sys_fork(struct pt_regs regs)
+{
+	return remote_do_fork(SIGCHLD, regs.rsp, &regs, 0, NULL, NULL);
+}
+
+#define NOT_IMPLEMENTED(fct)					\
+asmlinkage long fct(struct pt_regs regs)			\
+{ printk(KERN_ERR #fct "not yet implemented\n"); return -1; }
+
+NOT_IMPLEMENTED(om_sys_iopl)
+NOT_IMPLEMENTED(om_sys_vfork)
+NOT_IMPLEMENTED(om_sys_clone)
+NOT_IMPLEMENTED(om_sys_rt_sigsuspend)
+NOT_IMPLEMENTED(om_sys_sigaltstack)
diff -Naur linux-2.6.11/hpc/comm.c linux-2.6.11-om/hpc/comm.c
--- linux-2.6.11/hpc/comm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/comm.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,555 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+#include <linux/sched.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <linux/net.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+#include <asm/uaccess.h>
+#include <hpc/mig.h>
+#include <hpc/debug.h>
+#include <hpc/comm.h>
+#include <hpc/task.h>
+#include <hpc/prototype.h>
+
+#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)
+
+unsigned long comm_remote_timo = COMM_REMOTE_TIMO;	/* for remote accept */
+unsigned long comm_connect_timo = COMM_CONNECT_TIMO;	/* for connection */
+unsigned long comm_reconn_timo = COMM_RECONN_TIMO;	/* for reconnection */
+
+/**
+ * comm_shutdown - shutdown socket
+ * @mlink:	openMosix link to shutdown
+ **/
+static void comm_shutdown(om_link_t *mlink)
+{
+	struct socket *sock;
+
+	if (!mlink)
+		return;
+	sock = mlink->sock;
+
+	if (sock->ops)
+		sock->ops->shutdown(sock, SEND_SHUTDOWN);
+}
+
+/**
+ * comm_getname - get the name of socket
+ * @mlink:	openMosix link to shutdown
+ * @address:	the sockaddr to fill
+ **/
+int comm_getname(om_link_t *mlink, struct sockaddr *address)
+{
+	struct socket *sock;
+	int val, ret;
+	
+	val = sizeof(struct sockaddr);
+	sock = mlink->sock;
+	if (!sock->ops || !sock->ops->getname)
+		return -1;
+	ret = sock->ops->getname(sock, address, &val, 0);
+	if (ret)
+		return -1;
+	return val;
+}
+
+/**
+ * comm_data_ready - Wake the socket when data are ready
+ * @sk:	socket to wake up
+ * @len:	unneeded
+ **/
+void comm_data_ready(struct sock *sk, int len)
+{
+	wake_up_interruptible(sk->sk_sleep);
+}
+
+static int comm_setup_tcp(struct socket *sock)
+{
+	int val;
+	int error;
+	mm_segment_t oldfs;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	/* old TOADDR/ACCEPT */	
+	val = 1;
+	if ((error = sock_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,
+					(char *) &val, sizeof(val))))
+		goto fail;
+	/* FIXME: check on these, old COMM_MIGD */
+	val = OPENMOSIX_CONNECTION_KEEPALIVE_INTERVAL;
+	if ((error = sock->ops->setsockopt(sock, IPPROTO_TCP,
+				TCP_KEEPINTVL, (char *) &val, sizeof(val))))
+		goto fail;
+
+	val = OPENMOSIX_CONNECTION_KEEPALIVE_MAXTRIES;
+	if ((error = sock->ops->setsockopt(sock, IPPROTO_TCP,
+				TCP_KEEPCNT, (char *) &val, sizeof(val))))
+		goto fail;
+
+	val = OPENMOSIX_CONNECTION_KEEPALIVE_TOTAL;
+	if ((error = sock->ops->setsockopt(sock, IPPROTO_TCP,
+				TCP_KEEPIDLE, (char *) &val, sizeof(val))))
+		goto fail;
+
+	val = 1;
+	if ((error = sock->ops->setsockopt(sock, IPPROTO_TCP,
+				TCP_NODELAY, (char *) &val, sizeof(val))))
+		goto fail;
+	
+fail:
+	set_fs(oldfs);
+	return error;
+}
+
+
+om_link_t * comm_socket(int family, int type, int proto)
+{
+	int error;
+	struct socket *sock;
+	om_link_t *mlink = NULL;
+
+	mlink = kmalloc(sizeof(om_link_t), GFP_KERNEL);
+	if (!mlink) 
+		return NULL;
+
+	error = sock_create(family, type, proto, &sock);
+	if (error < 0)
+		goto out;
+	
+	memset(mlink, 0, sizeof(om_link_t));
+	mlink->sock = sock;
+	
+	return mlink;
+	
+out:
+	kfree(mlink);
+	return NULL;
+}
+
+	
+int comm_bind(struct socket *sock, struct sockaddr *saddr)
+{
+	int error;
+	
+	error = sock->ops->bind(sock, saddr, sizeof(*saddr));
+	if (error == -EADDRINUSE)
+		printk("comm_bind() Already in use\n");
+	
+	return error;
+}
+
+static int comm_listen(struct socket *sock)
+{
+	int error;
+
+	error = sock->ops->listen(sock, SOMAXCONN);
+
+	return error;
+}
+
+
+int comm_connect(om_link_t *mlink, struct sockaddr *saddr, unsigned long timo)
+{
+	struct socket *sock = mlink->sock;
+	int error;
+	DECLARE_WAITQUEUE(wait, current);
+	
+	if (!timo)
+		timo = MAX_SCHEDULE_TIMEOUT;
+	
+	error = sock->ops->connect(sock, saddr, sizeof(*saddr), O_NONBLOCK);
+
+	add_wait_queue(sock->sk->sk_sleep, &wait);
+	while (sock->state != SS_CONNECTED) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		error = sock->ops->connect(sock, saddr, sizeof(*saddr),
+						O_NONBLOCK);
+		if (error != -EALREADY || (error = sock_error(sock->sk)))
+			break;
+
+		timo = schedule_timeout(timo);
+		if (timo <= 0) {
+			error = -EAGAIN;
+			break;
+		}
+	}
+	remove_wait_queue(sock->sk->sk_sleep, &wait);
+	set_current_state(TASK_RUNNING);
+
+	if (error) {
+		OMBUG("failed to connect\n");
+		return error;
+	}
+
+	if (sock->sk->sk_err) {
+		error = sock_error(sock->sk);	/* cleans error.. */
+		OMBUG("sk_err\n");
+		return error;
+	}
+	
+	return 0;
+}
+
+
+/**
+ * comm_close - close an openMosix communication socket
+ * @mlink:	openMosix link
+ **/
+void comm_close(om_link_t *mlink)
+{
+	BUG_ON(!mlink);
+	
+	comm_shutdown(mlink);
+	sock_release(mlink->sock);
+
+	kfree(mlink);
+}
+
+/**
+ * comm_peek - peek the socket looking for data pending 
+ **/
+int comm_peek(struct socket *sock)
+{
+	int mask;
+
+	mask = sock->ops->poll(NULL, sock, NULL);
+	return (mask & POLLIN_SET) ? 1 : 0;
+}
+
+
+/**
+ * comm_poll - wait for a communication event, interrupt or openMosix event
+ * @sock:		socket to poll
+ * @mask:		polling mask
+ * @interruptible:	is the task interruptible
+ * @timo:		timeout (0 = MAX_SCHEDULE_TIMEOUT)
+ * 
+ * Description:
+ * 	returns 1 on communication events, and 0 otherwise
+ */
+static int comm_poll(struct socket *sock, int mask, int interruptible, unsigned long timo)
+{
+	int pollmask;
+	static struct file sighfile = {.f_count = ATOMIC_INIT(1)};
+	DECLARE_WAITQUEUE(wait, current);
+
+	/*
+	 * sighfile: we are required to supply a file to "hold" while we poll.
+	 * a bit ridiculous in this context, but nobody will notice because
+	 * f_count will never drop to 0
+	 */
+	if (!timo)
+		timo = MAX_SCHEDULE_TIMEOUT;
+	add_wait_queue(sock->sk->sk_sleep, &wait);
+	for (;;)
+	{
+		set_current_state(TASK_INTERRUPTIBLE);
+		pollmask = sock->ops->poll(&sighfile, sock, NULL);
+		if ((pollmask & mask) || (interruptible &&
+				 	 (signal_pending(current)
+				 	 || task_test_dreqs(current, ~0))))
+			break;
+
+		timo = schedule_timeout(timo);
+		if (timo <= 0)
+			break;
+	}
+	remove_wait_queue(sock->sk->sk_sleep, &wait);
+	set_current_state(TASK_RUNNING);
+	
+	return (pollmask & mask) ? 1 : 0;
+}
+
+
+/**
+ * comm_wait - wait for a message, or some other openMosix event
+ * 
+ * Description:
+ *	return 1 if there is a message, 0 if another event occured first.
+ **/
+int comm_wait(struct socket *sock)
+{
+	return comm_poll(sock, POLLIN_SET, 1, 0UL);
+}
+
+
+/**
+ * comm_accept - accept a connection on openMosix socket
+ * @ml:		the socket that receive a connection
+ * @mlp:	the new link opened will be assigned here
+ * @saddr:	source address of the connection
+ * @timeout:	timeout (0 = MAX_SCHEDULE_TIMEOUT)
+ **/
+int comm_accept(om_link_t *ml, om_link_t **mlp, struct sockaddr *saddr, 
+		unsigned long timeout)
+{
+	struct socket *sock;
+	om_link_t *newlink;
+	int error = -EMFILE;
+
+	newlink = kmalloc(sizeof(om_link_t), GFP_KERNEL);
+	if (!newlink)
+		return -ENOMEM;
+
+	sock = sock_alloc();
+	if (!sock)
+		goto failed_sock;
+
+	sock->type = ml->sock->type;
+	sock->ops = ml->sock->ops;
+
+	if (timeout && !comm_poll(ml->sock, POLLIN | POLLRDNORM, 0, timeout)) {
+		error = -EAGAIN;
+		goto failed;
+	}
+	
+	error = ml->sock->ops->accept(ml->sock, sock, 0);
+	if (error)
+		goto failed;
+
+	/* configure the link */
+	memset(newlink, 0, sizeof(om_link_t));
+	newlink->sock = sock;
+	
+	/* set up connection options */
+	error = comm_setup_tcp(sock);
+	if (error)
+		goto failed;
+		
+	*mlp = newlink;
+	return error;
+	
+failed:
+	sock_release(sock);
+failed_sock:
+	kfree(newlink);
+	*mlp = NULL;
+	return error;
+}
+
+/**
+ * comm_dorecv - Reliable read data from socket
+ * @sock:	socket to read from
+ * @msg:	fill with data
+ * @len:	lenght of the data
+ *
+ * Description:
+ * 	reliably read data on success, or if 
+ * 	error == -EFAULT: returns number of bytes received otherwise 
+ * 	(any other error): returns negative error.
+ **/
+static int comm_dorecv(struct socket *sock, struct msghdr *msg, int len)
+{
+	int n = 0;
+	int left = len;
+
+	do {
+		n = sock_recvmsg(sock, msg, left, msg->msg_flags);
+		if (n <= 0) {
+			/* if we already got -EFAULT, we must report */
+			if (n == -EFAULT)
+			{
+				for ( ; msg->msg_iovlen; msg->msg_iov++) {
+					msg->msg_iovlen--;
+					len -= msg->msg_iov->iov_len;
+				}
+				return len;
+			}
+
+			/* .. otherwise - it is fatal - return error */
+			if (n < 0) 
+				return n;
+			return -EPIPE;
+		}
+
+		left -= n;
+		if (left) {
+			/* ...->recvmsg() updated iovec, we update msg */
+			while (!msg->msg_iov->iov_len)
+			{
+				msg->msg_iov++;
+				msg->msg_iovlen--;
+			}
+		}
+	} while (left);
+	return len;
+}
+
+
+/**
+ * comm_recv - receive a message of size @len
+ * @mlink:	openmosix_link we're using
+ * @data:	pointer to buffer to write message into
+ * @len:	length of data we want
+ **/
+int comm_recv(om_link_t *mlink, void *data, int len)
+{
+	struct iovec iov;
+	struct msghdr msg = { NULL, 0, &iov, 1, NULL, 0, MSG_WAITALL | MSG_NOSIGNAL };
+	mm_segment_t oldfs;
+	int error = -1;
+
+	BUG_ON(len > PAGE_SIZE);
+	BUG_ON(!mlink);
+	
+	iov.iov_base = data;
+	iov.iov_len = len;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	error = comm_dorecv(mlink->sock, &msg, len);
+	if (error != len) {
+		OMBUG("got %d of %d\n", error, len);
+		if (error >= 0)
+			error = -EFAULT;
+		comm_shutdown(mlink);
+	}	
+
+	set_fs(oldfs);
+	
+	return error;
+}
+
+
+
+/**
+ * comm_send - send data and returns the bytes number of data sent
+ * @mlink:	openmosix_link we're using
+ * @data:	data to send
+ * @len:	length of data
+ **/
+int comm_send(om_link_t *mlink, void *data, int len)
+{
+	struct iovec iov;
+	struct msghdr msg = { NULL, 0, &iov, 1, NULL, 0, MSG_NOSIGNAL };
+	mm_segment_t oldfs;
+	int error;
+
+	BUG_ON(!mlink);
+	
+	iov.iov_base = data;
+	iov.iov_len  = len;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	
+	error = sock_sendmsg(mlink->sock, &msg, len);
+	if (error != len)
+		printk("sock_sendmsg: sent %d of %d\n", error, len);	
+		
+	set_fs(oldfs);
+
+	return error;
+}
+
+/* ---------- openmosix specifics start here ------------ */
+#include <hpc/protocol.h>
+
+void set_our_addr(int type, struct sockaddr *sa, int port)
+{
+	struct sockaddr_in *sa_in;
+	struct sockaddr_in6 *sa_in6;
+	
+	switch (type) {
+	case AF_INET:
+		sa_in = (struct sockaddr_in *) sa;
+		sa_in->sin_family = type;
+		sa_in->sin_addr.s_addr = INADDR_ANY;
+		sa_in->sin_port = port;
+		return;
+	case AF_INET6:
+		sa_in6 = (struct sockaddr_in6 *) sa;
+		return;
+	}
+}
+
+/* lazy helper functions */
+om_link_t * comm_setup_listen(struct sockaddr *sa)
+{
+	om_link_t *link;	
+	int error;
+	
+	link = comm_socket(sa->sa_family, SOCK_STREAM, IPPROTO_TCP);
+	if (!link)
+		return NULL;
+	
+	error = comm_bind(link->sock, sa);
+	if (error < 0)
+		goto fail;
+	
+	error = comm_listen(link->sock);
+	if (error < 0)
+		goto fail;
+
+	return link;
+	
+fail:
+	comm_close(link);	
+	return NULL;
+}
+
+om_link_t * comm_setup_connect(struct sockaddr *sa, int timo)
+{
+	om_link_t *link;
+	
+	link = comm_socket(sa->sa_family, SOCK_STREAM, IPPROTO_TCP);
+	if (!link)
+		return NULL;
+
+	if (comm_connect(link, sa, timo))
+		goto fail;
+	
+	return link;
+	
+fail:
+	comm_close(link);
+	return NULL;
+}
+
+int comm_send_hd(om_link_t *link, int type, void *data, int dlen)
+{
+	struct omp_req req;
+	int error;
+	
+	req.type = type;
+	req.dlen = dlen;
+	
+	error = comm_send(link, &req, sizeof(req));
+	if (error < 0)
+		return -1;
+	
+	error = comm_send(link, data, dlen);
+	if (error < 0)
+		return -1;
+	
+	return 0;
+}
+
+
+int comm_send_req(om_link_t *link, int type)
+{
+	struct omp_req req;
+	req.type = type;
+	return comm_send(link, &req, sizeof(req));
+}
diff -Naur linux-2.6.11/hpc/debug.c linux-2.6.11-om/hpc/debug.c
--- linux-2.6.11/hpc/debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/debug.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <asm/uaccess.h>
+#include <linux/kallsyms.h>
+#include <linux/sched.h>
+#include <linux/config.h>
+#include <hpc/debug.h>
+#include <hpc/protocol.h>
+#include <hpc/comm.h>
+
+void debug_mlink(om_link_t *x)
+{
+	printk("mlink: socket @ = %p\n", x->sock);
+}
+
+
+void debug_page(unsigned long addr)
+{
+	unsigned long digest = 0;
+	char *ptr = (char *) addr;
+	int i;
+
+	for (i = 0; i < 4096; i++)
+		digest += ptr[i] * i;
+
+	printk("sum of 0x%p is %lu\n", (void *) addr, digest);
+}
+
+void debug_vmas(struct mm_struct *mm)
+{
+	struct vm_area_struct *vma;
+
+	if (!mm) {
+		printk(KERN_ERR "debug_vma(): no mm !\n");
+		return;
+	}
+
+	printk(KERN_ERR "======== [LISTING VMA] ========\n");
+	for (vma = mm->mmap; vma; vma = vma->vm_next) {
+		printk(KERN_ERR "vma: [%.8lx:%.8lx]\n", vma->vm_start,
+							vma->vm_end);
+	}
+}
+
+void debug_signals(struct task_struct *p)
+{
+	struct signal_struct *signal;
+
+	signal = p->signal;
+
+	printk(KERN_ERR "=========== [DEBUG SIGNALS] ========\n");
+}
diff -Naur linux-2.6.11/hpc/debug-i386.c linux-2.6.11-om/hpc/debug-i386.c
--- linux-2.6.11/hpc/debug-i386.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/debug-i386.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <asm/uaccess.h>
+#include <linux/kallsyms.h>
+#include <linux/sched.h>
+#include <hpc/debug.h>
+#include <asm/ptrace.h>
+#include <asm/desc.h>
+#include <asm/i387.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <hpc/protocol.h>
+#include <hpc/arch.h>
+#include <hpc/task.h>
+
+void om_debug_regs(struct pt_regs *myreg)
+{
+	struct pt_regs *reg;
+
+	reg = (myreg) ? myreg : ARCH_TASK_GET_USER_REGS(current);
+	
+	printk("pt_regs:\n");
+	printk("ebx: 0x%lx, ecx: 0x%lx, edx: 0x%lx\n", reg->ebx, reg->ecx, reg->edx);
+	printk("esi: 0x%lx, edi: 0x%lx, ebp: 0x%lx\n", reg->esi, reg->edi, reg->ebp);
+	printk("eax: 0x%lx, xds: 0x%x, xes: 0x%x\n", reg->eax, reg->xds, reg->xes);
+	printk("orig_eax: 0x%lx, eip: 0x%lx, xcs: 0x%x\n", reg->orig_eax, reg->eip, reg->xcs);
+        printk("eflags: 0x%lx, esp: 0x%lx, xss: 0x%x\n", reg->eflags, reg->esp, reg->xss);
+}
+
+
+void inline debug_thread(struct thread_struct *t)
+{
+	printk("thread_struct:\n");
+	printk("esp0: 0x%lx, sysenter_cs: 0x%lx\n",t->esp0, t->sysenter_cs);
+	printk("eip: 0x%lx, esp: 0x%lx", t->eip, t->esp);
+
+}
+
+/* shamelessly stolen, this is useful to debug a user space
+ * process when it dies on remote */
+void show_user_registers(task_t *p)
+{
+	int i;
+	unsigned long esp;
+	unsigned short ss;
+	unsigned long prev_code;
+	struct pt_regs *regs;
+		
+	if (!p->mm) {
+		printk(KERN_ERR "show_user_registers(): no mm !\n");
+		return;
+	}
+	regs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p->thread_info)) - 1;
+	
+	esp = regs->esp;
+	ss = regs->xss & 0xffff;
+
+	printk("CPU:    %d\nEIP:    %04x:[<%08lx>]    %s\nEFLAGS: %08lx\n",
+		smp_processor_id(), 0xffff & regs->xcs, regs->eip, print_tainted(), regs->eflags);
+	print_symbol("EIP is at %s\n", regs->eip);
+	printk("eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx\n",
+		regs->eax, regs->ebx, regs->ecx, regs->edx);
+	printk("esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx\n",
+		regs->esi, regs->edi, regs->ebp, esp);
+	printk("ds: %04x   es: %04x   ss: %04x\n",
+		regs->xds & 0xffff, regs->xes & 0xffff, ss);
+	printk("Process %s (pid: %d, BOGUSthreadinfo=%p task=%p)",
+		p->comm, p->pid, current_thread_info(), p);
+
+	printk("\nStack: ");
+	show_stack(NULL, (unsigned long*)esp);
+	
+	prev_code = regs->eip - 20;
+	
+	printk("code before eip: ");
+	for(i = 0; i < 20 ; i++)
+	{
+		unsigned char c;
+		if(__get_user(c, &((unsigned char*)prev_code)[i]))
+			break;
+		printk("%02x ", c);
+	}
+	printk("\n");
+
+
+	printk("Code: ");
+	for(i = 0; i < 20 ; i++)
+	{
+		unsigned char c;
+		if(__get_user(c, &((unsigned char*)regs->eip)[i])) {
+			printk(" Bad EIP value.");
+			break;
+		}
+		printk("%02x ", c);
+	}
+	printk("\n");
+}
+
diff -Naur linux-2.6.11/hpc/debug-ppc.c linux-2.6.11-om/hpc/debug-ppc.c
--- linux-2.6.11/hpc/debug-ppc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/debug-ppc.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <asm/uaccess.h>
+#include <linux/kallsyms.h>
+#include <linux/sched.h>
+#include <hpc/debug.h>
+#include <asm/ptrace.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/processor.h>
+#include <hpc/protocol.h>
+#include <hpc/arch.h>
+
+void om_debug_regs(struct pt_regs * myreg)
+{
+	struct pt_regs *regs;
+	int i;
+
+	regs = (myreg) ? myreg : ARCH_TASK_GET_USER_REGS(current);
+
+	printk("NIP: %08lX LR: %08lX SP: %08lX REGS: %p TRAP: %04lx\n",
+	       regs->nip, regs->link, regs->gpr[1], regs, regs->trap);
+	printk("MSR: %08lx EE: %01x PR: %01x FP: %01x ME: %01x IR/DR: %01x%01x\n",
+	       regs->msr, regs->msr&MSR_EE ? 1 : 0, regs->msr&MSR_PR ? 1 : 0,
+	       regs->msr & MSR_FP ? 1 : 0,regs->msr&MSR_ME ? 1 : 0,
+	       regs->msr & MSR_IR ? 1 : 0,
+	       regs->msr & MSR_DR ? 1 : 0);
+
+	for (i = 0; i < 32; i += 4) {
+		printk(KERN_ERR "GPR%02d: %08lx %08lx %08lx %08lx\n",
+					i, regs->gpr[i], regs->gpr[i + 1],
+					regs->gpr[i + 2], regs->gpr[i + 3]);
+	}
+
+}
+
+
+void inline debug_thread(struct thread_struct *t)
+{
+}
+
+
+/* shamelessly stolen, this is useful to debug a user space
+ * process when it dies on remote */
+void show_user_registers(task_t *p)
+{
+}
diff -Naur linux-2.6.11/hpc/debug-x86_64.c linux-2.6.11-om/hpc/debug-x86_64.c
--- linux-2.6.11/hpc/debug-x86_64.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/debug-x86_64.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <asm/uaccess.h>
+#include <linux/kallsyms.h>
+#include <linux/sched.h>
+#include <hpc/debug.h>
+#include <asm/ptrace.h>
+#include <asm/desc.h>
+#include <asm/i387.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <hpc/protocol.h>
+#include <hpc/arch.h>
+#include <hpc/task.h>
+
+void om_debug_regs(struct pt_regs *myreg)
+{
+	struct pt_regs *reg;
+	reg = (myreg) ? myreg : ARCH_TASK_GET_USER_REGS(current);
+	
+	printk("pt_regs:\n");
+	printk("r15: 0x%lx, r14: 0x%lx, r13: 0x%lx\n", reg->r15, reg->r14, reg->r13);
+	printk("r12: 0x%lx, rbp: 0x%lx, rbx: 0x%lx\n", reg->r12, reg->rbp, reg->rbx);
+	printk("r11: 0x%lx, r10: 0x%lx, r09: 0x%lx\n", reg->r11, reg->r10, reg->r9);
+	printk("r08: 0x%lx, rax: 0x%lx, rcx: 0x%lx\n", reg->r8, reg->rax, reg->rcx);
+	printk("rdx: 0x%lx, rsi: 0x%lx, rdi: 0x%lx\n", reg->rdx, reg->rsi, reg->rdi);
+	printk("orig_rax: 0x%lx, rip: 0x%lx,  cs: 0x%lx\n", reg->orig_rax, reg->rip, reg->cs);
+        printk("eflags: 0x%lx, rsp: 0x%lx,  ss: 0x%lx\n", reg->eflags, reg->rsp, reg->ss);
+}
+
+
+void inline debug_thread(struct thread_struct *t)
+{
+	printk("thread_struct:\n");
+}
+
+
+void show_user_registers(task_t *p)
+{
+}
diff -Naur linux-2.6.11/hpc/deputy.c linux-2.6.11-om/hpc/deputy.c
--- linux-2.6.11/hpc/deputy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/deputy.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,566 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/file.h>
+#include <linux/mount.h>
+#include <hpc/comm.h>
+#include <hpc/task.h>
+#include <hpc/mig.h>
+#include <hpc/arch.h>
+#include <hpc/syscalls.h>
+#include <hpc/debug.h>
+#include <hpc/prototype.h>
+#include <hpc/hpc.h>
+
+NORET_TYPE void deputy_die_on_communication(void)
+{
+	printk(KERN_ERR "deputy communication died.\n");
+	do_exit(SIGKILL);
+}
+
+/**
+ * deputy_do_syscall - process a syscall coming from remote
+ **/
+static int deputy_do_syscall(task_t *p)
+{
+	struct omp_syscall_req s;
+	struct omp_syscall_ret r;
+	int error;
+	
+	error = comm_recv(p->om.contact, &s, sizeof(s));
+	if (error < 0)
+		return -1;
+
+	OMDEBUG_SYS(1, "[deputy] receive syscall %d\n", s.n);
+
+	/* do the syscall and put reply in r */
+	r.ret = arch_exec_syscall(s.n, (syscall_parameter_t *) &s.arg);
+	
+	error = comm_send_hd(p->om.contact, REM_SYSCALL | REPLY, &r, sizeof(r));
+	if (error < 0)
+		return -1;
+
+	OMDEBUG_SYS(2, "[deputy] replied to syscall %d\n", s.n);
+
+	return 0;
+}
+
+/**
+ * deputy_do_fork - process a fork coming from remote
+ **/
+static int deputy_do_fork(task_t *p)
+{
+	int error;
+	struct omp_fork_req m;
+	struct omp_fork_ret r;
+	task_t *child;
+	om_link_t *childsock;
+
+	error = comm_recv(p->om.contact, &m, sizeof(m));
+	if (error < 0)
+		return -1;
+
+	childsock = comm_setup_connect(&m.sockaddr, 0);
+	if (!childsock)
+		return -1;
+
+	r.pid = do_fork(m.clone_flags, m.stack_start, &m.regs, m.stack_size,
+						0, 0);
+
+	child = find_task_by_pid(r.pid);
+	if (!child) {
+		printk(KERN_ERR "error: child %d not found\n", r.pid);
+		return -1;
+	}
+	r.tgid = child->tgid;
+	task_set_comm(child, childsock);
+
+	error = comm_send_hd(p->om.contact, REM_FORK | REPLY, &r, sizeof(r));
+	if (error < 0)
+		return -1;
+
+	return 0;
+}
+
+/**
+ * deputy_do_readpage - process request a specific page
+ **/
+static int deputy_do_readpage(task_t *p)
+{
+	struct omp_page_req m;
+	struct page *page = NULL;
+	struct vm_area_struct vma = { };
+	struct om_held_file *heldfile;
+	void *kmpage;
+	int error;
+
+	error = comm_recv(p->om.contact, &m, sizeof(m));
+	if (error < 0)
+		goto out;
+
+	heldfile = task_heldfiles_find(p, m.file);
+	if (!heldfile) {
+		OMBUG("file not found\n");
+		goto out;
+	}
+		
+	memset(&vma, 0, sizeof(struct vm_area_struct));
+	vma.vm_end = m.offset + PAGE_SIZE;
+	vma.vm_file = (struct file *) m.file;
+
+	page = heldfile->nopage(&vma, m.offset, NULL);
+	kmpage = kmap(page);
+
+	error = comm_send(p->om.contact, kmpage, PAGE_SIZE);
+	if (error < 0)
+		goto out;
+out:
+	if (page) {
+		kunmap(page);
+		__free_page(page);
+	}
+	return error;
+}
+
+/**
+ * deputy_do_mmap_pgoff - really do a mmap on deputy
+ **/
+unsigned long deputy_do_mmap_pgoff(struct file * file, unsigned long addr,
+				unsigned long len, unsigned long prot,
+				unsigned long flags, unsigned long pgoff)
+{
+	int error;
+	struct vm_area_struct *vma;
+
+	vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+	if (!vma) {
+		error = -ENOMEM;
+		goto out;
+	}
+	memset(vma, 0, sizeof(*vma));
+
+	vma->vm_start = addr;
+	vma->vm_end = addr + len;
+	vma->vm_flags = flags;
+	vma->vm_page_prot = protection_map[flags & 0x0f];
+	vma->vm_pgoff = pgoff;
+	vma->vm_file = file;
+
+	error = file->f_op->mmap(file, vma);
+	if (error < 0)
+		goto out_freevma;
+
+	error = task_heldfiles_add(current, file, vma->vm_ops);
+
+out_freevma:
+	kmem_cache_free(vm_area_cachep, vma);
+out:
+	return error;
+}
+
+/**
+ * deputy_do_mmap - process request to mmap a file
+ **/
+static int deputy_do_mmap(task_t *p)
+{
+	struct omp_mmap_req m;
+	struct omp_mmap_ret r;
+	struct file *file;
+	int error;
+
+	error = comm_recv(p->om.contact, &m, sizeof(m));
+	if (error < 0)
+		goto error;
+
+	error = -EBADF;
+	file = fget(m.fd);
+	if (!file)
+		goto out;
+	
+	error = do_mmap_pgoff(file, m.addr, m.len, m.prot, m.flags, m.pgoff);
+	
+	r.file = file;
+	r.isize = file->f_dentry->d_inode->i_size;
+	fput(file);
+out:
+	r.ret = error;
+	
+	error = comm_send(p->om.contact, &r, sizeof(r));
+	if (error < 0)
+		goto error;
+	return 0;
+error:
+	return -1;
+}
+
+/**
+ * deputy_do_execve - process request to execve a new executable
+ **/
+static int deputy_do_execve(task_t *p)
+{
+	struct linux_binprm *bprm = NULL;
+	struct omp_execve_req m;
+	int error;
+	char *filename;
+	struct file *file;
+
+	error = comm_recv(p->om.contact, &m, sizeof(m));
+	if (error < 0)
+		goto error;
+
+	filename = __getname();
+	deputy_strncpy_from_user(filename, m.filename, m.filelen + 1);
+
+	file = open_exec(filename);
+	error = PTR_ERR(file);
+	if (IS_ERR(file))
+		goto error;
+
+	error = -ENOMEM;
+	bprm = kmalloc(sizeof(*bprm), GFP_KERNEL);
+	if (!bprm)
+		goto error;
+	memset(bprm, 0, sizeof(*bprm));
+
+	error = search_binary_handler(bprm, &m.regs);
+error:
+	kfree(bprm);
+	return error;
+}
+
+/**
+ * deputy_do_sigpending - process signal pending
+ **/
+static inline void deputy_do_sigpending(task_t *p)
+{
+	siginfo_t info;
+	struct omp_signal s;
+	int signr, error;
+
+	do_signal(ARCH_TASK_GET_USER_REGS(p), NULL);
+	
+	return;
+	
+	for (;;) {
+		signr = dequeue_signal(p, &p->blocked, &info);
+		if (!signr)
+			break;
+
+		s.signr = signr;
+		memcpy(&s.siginfo, &info, sizeof(siginfo_t));
+
+		error = comm_send_hd(p->om.contact, DEP_SIGNAL, &s, sizeof(s));
+		if (error < 0)
+			OMBUG("error %d\n", error);
+	}
+}
+
+/**
+ * deputy_process_misc - process has receive an interrupt in communication
+ **/
+static void deputy_process_misc(task_t *p)
+{
+	if (task_dreqs_pending(p))
+		task_do_request();
+
+	if (test_tsk_thread_flag(p, TIF_SIGPENDING)) {
+		deputy_do_sigpending(p);
+	}
+}
+
+/**
+ * deputy_process_communication - process has receive communication in deputy
+ **/
+static void deputy_process_communication(task_t *p)
+{
+	struct omp_req req;
+	int error;
+	
+	error = comm_recv(p->om.contact, &req, sizeof(req));
+	if (error < 0)
+		deputy_die_on_communication();
+
+	switch (req.type)
+	{
+	case 0:
+		deputy_die_on_communication();
+		break;
+	case REM_BRING_HOME:
+		error = task_go_home(p);
+		break;
+	case REM_SYSCALL:
+		error = deputy_do_syscall(p);
+		break;
+	case REM_FORK:
+		error = deputy_do_fork(p);
+		break;
+	case REM_PAGE:
+		error = deputy_do_readpage(p);
+		break;
+	case REM_MMAP:
+		error = deputy_do_mmap(p);
+		break;
+	case REM_EXECVE:
+		error = deputy_do_execve(p);
+		break;
+	default:
+		OMBUG("received unexpected [%x]\n", req.type);
+		error = -1;
+	}
+	if (error < 0)
+		deputy_die_on_communication();
+}
+
+/**
+ * deputy_main_loop - process loop when process is deputy
+ **/
+void deputy_main_loop(void)
+{
+	int has_communication;
+	
+	while (task_test_dflags(current, DDEPUTY))
+	{
+		has_communication = comm_wait(current->om.contact->sock);
+		if (has_communication)
+			deputy_process_communication(current);
+		deputy_process_misc(current);
+	}
+}
+
+/**
+ * deputy_copy_from_user - Copy from remote when running on deputy
+ **/
+unsigned long deputy_copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	struct omp_usercopy_req u;
+	int error;
+	
+	u.addr = (unsigned long) from;
+	u.len = n;
+
+	OMDEBUG_CPYUSER(1, "copy user[0x%p]->[0x%p][%ld]\n", from, to, n);
+
+	error = comm_send_hd(current->om.contact, DEP_COPY_FROM_USER, &u, sizeof(u));
+	if (error < 0)
+		goto error;
+
+	error = comm_recv(current->om.contact, to, n); 
+	if (error < 0)
+		goto error;
+
+	return 0;
+error:
+	OMBUG("error %d\n", error);
+	return -1;
+}
+EXPORT_SYMBOL(deputy_copy_from_user);
+
+/**
+ * deputy_strncpy_from_user - strncpy on remote when running on deputy
+ **/
+unsigned long deputy_strncpy_from_user(char *dst, const char __user *src,
+							long count)
+{
+	struct omp_usercopy_req u;
+	int error;
+	
+	OMDEBUG_CPYUSER(1, "strcpy user[0x%p]->[0x%p][%ld]\n", src, dst, count);
+	u.addr = (unsigned long) src;
+	u.len = count;
+	error = comm_send_hd(current->om.contact, DEP_STRNCPY_FROM_USER, &u,
+								sizeof(u));
+	if (error < 0)
+		goto error;
+
+	error = comm_recv(current->om.contact, dst, count); 
+	if (error < 0)
+		goto error;
+
+	return 0;
+error:
+	OMBUG("error %d\n", error);
+	return -1;
+}
+
+/**
+ * deputy_copy_to_user - copy to remote when running on deputy
+ **/
+unsigned long deputy_copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	struct omp_usercopy_req u;
+	int error;
+	
+	OMDEBUG_CPYUSER(1, "copy [0x%p]->user[0x%p][%ld]\n", from, to, n);
+	u.addr = (unsigned long) to;
+	u.len = n;
+
+	error = comm_send_hd(current->om.contact, DEP_COPY_TO_USER, &u,
+							sizeof(u));
+	if (error < 0)
+		goto error;
+
+	error = comm_send(current->om.contact, (void *) from, n); 
+	if (error < 0)
+		goto error;
+
+	return 0;
+error:
+	OMBUG("error %d\n", error);
+	return -1;
+}
+EXPORT_SYMBOL(deputy_copy_to_user);
+
+/**
+ * deputy_strnlen_user - strnlen on remote when running on deputy
+ **/
+unsigned long deputy_strnlen_user(const char *s, long n)
+{
+	struct omp_usercopy_req u;
+	int error;
+	long ret;
+	
+	OMDEBUG_CPYUSER(1, "strlen user[0x%p][%ld]\n", s, n);
+	u.addr = (unsigned long) s;
+	u.len = n;
+
+	error = comm_send_hd(current->om.contact, DEP_STRNLEN_USER, &u, sizeof(u));
+	if (error < 0)
+		goto out;
+
+	error = comm_recv(current->om.contact, &ret, sizeof(ret)); 
+	if (error < 0)
+		goto out;
+
+	return ret;
+out:
+	OMBUG("error %d\n", error);
+	return 0;
+}
+EXPORT_SYMBOL(deputy_strnlen_user);
+
+/**
+ * deputy_put_userX - put a value of 64 bit or less to remote
+ **/
+static inline long deputy_put_userX(s64 value, const void *addr, size_t size)
+{
+	struct omp_usercopy_emb u;
+	int error;
+
+	OMDEBUG_CPYUSER(1, "put (%lld)->user[0x%p][%zd]\n", value, addr, size);
+
+	u.addr = (unsigned long) addr;
+	u.len = size;
+	u.val = value;
+
+	error = comm_send_hd(current->om.contact, DEP_PUT_USER, &u, sizeof(u));
+	if (error < 0)
+		goto out;
+	return 0;
+out:
+	OMBUG("error %d\n", error);
+	return -EFAULT;
+}
+
+/**
+ * deputy_put_user - put a long value to remote
+ **/
+long deputy_put_user(long value, const void *addr, size_t size)
+{
+	BUG_ON(size > sizeof(long));
+	return deputy_put_userX((s64) value, addr, size);
+}
+EXPORT_SYMBOL(deputy_put_user);
+
+#if BITS_PER_LONG < 64 
+/**
+ * deputy_put_user - put a 64 bit value to remote
+ **/
+long deputy_put_user64(s64 value, const void *addr)
+{
+	return deputy_put_userX(value, addr, 8);
+}
+EXPORT_SYMBOL(deputy_put_user64);
+#endif
+
+/**
+ * deputy_get_userX - get a value of 64 bit or less from remote
+ **/
+static inline long deputy_get_userX(s64 *value, const void *addr, size_t size)
+{
+	struct omp_usercopy_req u;
+	int error;
+	s64 ret;
+
+	OMDEBUG_CPYUSER(1, "get user[0x%p][%zd]\n", addr, size);
+	u.addr = (unsigned long) addr;
+	u.len = size;
+
+	error = comm_send_hd(current->om.contact, DEP_GET_USER, &u, sizeof(u));
+	if (error < 0)
+		goto out;
+
+	error = comm_recv(current->om.contact, &ret, sizeof(ret)); 
+	if (error < 0)
+		goto out;
+
+	switch (size) {
+	case 1: { s8 *v = (s8 *) value; *v = (s8) ret; break; }
+	case 2: { s16 *v = (s16 *) value; *v = (s16) ret; break; }
+	case 4: { s32 *v = (s32 *) value; *v = (s32) ret; break; }
+	case 8: *value = ret; break;
+	}
+	return 0;
+out:
+	OMBUG("error %d\n", error);
+	return -EFAULT;
+}
+
+/**
+ * deputy_get_user - get a long value from remote
+ **/
+long deputy_get_user(long *value, const void *addr, size_t size)
+{
+	BUG_ON(size > sizeof(long));
+	return deputy_get_userX((u64 *) value, addr, size);
+}
+EXPORT_SYMBOL(deputy_get_user);
+
+#if BITS_PER_LONG < 64 
+/**
+ * deputy_get_user - get a 64 bit value from remote
+ **/
+long deputy_get_user64(s64 *value, const void *addr)
+{
+	return deputy_get_userX(value, addr, 8);
+}
+EXPORT_SYMBOL(deputy_get_user64);
+#endif
+
+/**
+ * deputy_startup - startup deputy process
+ **/
+void deputy_startup(task_t *p)
+{
+	task_set_dflags(p, DDEPUTY);
+	/* FIXME it should not be necessary, but actually process got a
+	 * SIGKILL on his sigqueue for unknown reasons */
+	flush_signals(p);
+	exit_mm(p);
+}
diff -Naur linux-2.6.11/hpc/files.c linux-2.6.11-om/hpc/files.c
--- linux-2.6.11/hpc/files.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/files.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,283 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/mount.h>
+#include <linux/pagemap.h>
+#include <linux/mm.h>
+#include <hpc/comm.h>
+#include <hpc/prototype.h>
+#include <hpc/debug.h>
+
+struct address_space_operations remote_aops = { .readpage = remote_readpage, };
+struct file_operations remote_file_operations = { .mmap = remote_file_mmap, };
+
+int task_heldfiles_add(task_t *p, struct file *file,
+				struct vm_operations_struct *vm_ops)
+{
+	struct om_held_file *rfile;
+	
+	rfile = kmalloc(sizeof(struct om_held_file), GFP_KERNEL);
+	if (!rfile)
+		return -ENOMEM;
+
+	OMDEBUG_RINO(2, "process [%d] adding file [0x%p], nopage [0x%p]\n",
+			p->pid, file, (void *) vm_ops->nopage);
+	
+	get_file(file);
+	rfile->file = file;
+	rfile->nb = (unsigned long) file; /* FIXME */
+	rfile->nopage = vm_ops->nopage;
+	list_add(&rfile->list, &p->om.rfiles);
+	return 0;	
+}
+
+void task_heldfiles_clear(task_t *p)
+{
+	struct om_held_file *rfile, *next;
+	
+	list_for_each_entry_safe(rfile, next, &p->om.rfiles, list) {
+		fput(rfile->file);
+		kfree(rfile);
+	}
+}
+
+struct om_held_file *task_heldfiles_find(task_t *p, struct file *file)
+{
+	struct om_held_file *heldfile;
+
+	OMDEBUG_RINO(3, "process [%d] searching file [0x%p]\n", p->pid, file);
+	
+	list_for_each_entry(heldfile, &p->om.rfiles, list) {
+		if (heldfile->file == file)
+			return heldfile;
+	}
+	printk(KERN_ERR "heldfile: file not found\n");
+	return NULL;
+}
+
+#if 0
+static struct backing_dev_info remote_backing_dev_info = {
+        .ra_pages       = 0,    /* No readahead */
+        .memory_backed  = 1,    /* Does not contribute to dirty memory */
+};
+#endif
+
+/*****************************************************************************/
+struct om_remote_dentry
+{
+	struct list_head list;
+	struct dentry *dentry;
+};
+
+spinlock_t remote_dentries_lock = SPIN_LOCK_UNLOCKED; 
+struct list_head remote_dentries = LIST_HEAD_INIT(remote_dentries);
+
+int rdentry_delete(struct dentry *dentry)
+{
+	struct list_head *ptr;
+	int ret = -ENOENT;
+	
+	spin_lock(&remote_dentries_lock);
+	list_for_each(ptr, &remote_dentries) {
+		struct om_remote_dentry *rd = list_entry(ptr, struct om_remote_dentry, list);
+		
+		if (rd->dentry == dentry) {
+			list_del(ptr);
+			kfree(rd);
+			ret = 0;
+		}
+	}
+	spin_unlock(&remote_dentries_lock);
+	if (ret)
+		BUG();
+	return ret;
+}
+
+void rdentry_iput(struct dentry *dentry, struct inode *inode)
+{
+	kfree(inode->u.generic_ip);
+	iput(inode);
+}
+
+struct dentry_operations remote_dentry_ops = {
+	.d_delete = rdentry_delete,
+	.d_iput = rdentry_iput,
+};
+
+struct super_operations rfile_dummy_block_ops = { };
+
+struct super_block rfiles_dummy_block =
+{
+	.s_op = &rfile_dummy_block_ops,
+	.s_inodes = LIST_HEAD_INIT(rfiles_dummy_block.s_inodes),
+};
+
+struct vfsmount remote_file_vfsmnt =
+{
+	.mnt_count = ATOMIC_INIT(1),
+	.mnt_hash = LIST_HEAD_INIT(remote_file_vfsmnt.mnt_hash),
+	.mnt_child = LIST_HEAD_INIT(remote_file_vfsmnt.mnt_child),
+	.mnt_mounts = LIST_HEAD_INIT(remote_file_vfsmnt.mnt_mounts),
+	.mnt_list = LIST_HEAD_INIT(remote_file_vfsmnt.mnt_list),
+	.mnt_fslink = LIST_HEAD_INIT(remote_file_vfsmnt.mnt_fslink),
+	.mnt_parent = &remote_file_vfsmnt,
+};
+
+static int rdentry_add_entry(struct dentry *dentry)
+{
+	struct om_remote_dentry *rdentry;
+	
+	rdentry = kmalloc(sizeof(struct om_remote_dentry), GFP_KERNEL);
+	if (!rdentry)
+		return -ENOMEM;
+
+	rdentry->dentry = dentry;
+	spin_lock(&remote_dentries_lock);
+	list_add(&rdentry->list, &remote_dentries);
+	spin_unlock(&remote_dentries_lock);
+	return 0;
+}
+
+static struct dentry * rdentry_create_dentry(struct rfile_inode_data *data)
+{
+	struct dentry *dentry;
+	struct inode *inode;
+	struct rfile_inode_data *tmp;
+
+	inode = new_inode(&rfiles_dummy_block);
+	if (!inode)
+		return NULL;
+	
+	tmp = kmalloc(sizeof(struct rfile_inode_data), GFP_KERNEL);
+	if (!tmp)
+		goto error;
+
+	memcpy(tmp, data, sizeof(struct rfile_inode_data));
+
+	inode->u.generic_ip = tmp;
+	
+	inode->i_mode = S_IFREG;
+	inode->i_size = data->isize;
+	inode->i_fop = &remote_file_operations;
+	inode->i_mapping->a_ops = &remote_aops;
+	
+	dentry = d_alloc(NULL, &(const struct qstr){ .name = "/", .len = 1 });
+	if (!dentry)
+		goto error;
+	
+	dentry->d_inode = inode;
+	dentry->d_parent = dentry;
+
+	rdentry_add_entry(dentry);
+
+	return dentry;
+error:
+	kfree(data);
+	iput(inode);
+	return NULL;
+}
+
+static inline struct rfile_inode_data * rfile_inode_get_data(struct inode *inode)
+{
+	return (struct rfile_inode_data *) inode->u.generic_ip;
+}
+
+struct file * rfiles_inode_get_file(struct inode *inode)
+{
+	return rfile_inode_get_data(inode)->file;
+}
+
+static inline int rfiles_inode_compare(struct inode *inode,
+					struct rfile_inode_data *data)
+{
+	return memcmp(inode->u.generic_ip, data, sizeof(*data)) == 0;
+}
+
+static struct dentry * rdentry_find(struct rfile_inode_data *data)
+{
+	struct om_remote_dentry *ptr;
+	struct dentry *dentry = NULL;
+
+	spin_lock(&remote_dentries_lock);
+	list_for_each_entry(ptr, &remote_dentries, list) {
+		dentry = ptr->dentry;
+
+		if (rfiles_inode_compare(dentry->d_inode, data))
+			break;
+	}
+	spin_unlock(&remote_dentries_lock);
+	return dentry;
+}
+
+static struct file * rdentry_create_file(struct rfile_inode_data *data)
+{
+	struct file *file;
+	struct dentry *dentry;
+
+	file = get_empty_filp();
+	if (!file)
+		return NULL;
+
+	dentry = dget(rdentry_find(data));
+	if (!dentry) {
+		dentry = rdentry_create_dentry(data);
+		if (!dentry)
+			goto error;
+	}
+
+	file->f_mapping = dentry->d_inode->i_mapping;
+	file->f_dentry = dentry;
+	file->f_op = &remote_file_operations;
+	file->f_mode = FMODE_READ;
+	file->f_vfsmnt = &remote_file_vfsmnt;
+
+	return file;
+error:
+	put_filp(file);
+	return NULL;
+}
+
+struct file * task_rfiles_get(task_t *p, struct file *origfile,
+				unsigned long node, loff_t isize)
+{
+	struct vm_area_struct *vma;
+	struct file *file;
+	struct rfile_inode_data rdata;
+
+	rdata.file = origfile;
+	rdata.node = node;
+	rdata.isize = isize;
+
+	for (vma = p->mm->mmap; vma; vma = vma->vm_next)
+	{
+		if (!vma->vm_file)
+			continue;
+		file = vma->vm_file;
+		if (rfiles_inode_compare(file->f_dentry->d_inode, &rdata)) {
+			get_file(file);
+			return file;
+		}
+	}
+	
+	file = rdentry_create_file(&rdata);
+	return file;
+}
diff -Naur linux-2.6.11/hpc/Kconfig linux-2.6.11-om/hpc/Kconfig
--- linux-2.6.11/hpc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/Kconfig	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,43 @@
+#
+# HPC configuration 
+#
+
+menu "HPC options"
+
+config OPENMOSIX
+	bool "Enable OpenMosix clustering"
+	help
+	  Say Y to support process migration within a cluster
+
+config OPENMOSIX_VERBOSE
+	bool "Enable OpenMosix to be more verbose"
+	depends OPENMOSIX
+	default n
+
+config OPENMOSIX_MIGRATION_VERBOSE
+	bool "Add some message when migrating"
+	depends OPENMOSIX_VERBOSE
+	default n
+	help
+	  Say Y will throw message about migration into syslog
+
+config OPENMOSIX_DEBUG
+	bool "Enable OpenMosix debug"
+	depends OPENMOSIX
+	default n
+
+config OPENMOSIX_MIGRATION_DEBUG
+	bool "Add lots of message and print step when migrating"
+	depends OPENMOSIX_DEBUG
+	default n
+	help
+	  Say Y will throw lot of debug message about migration into syslog
+
+config OPENMOSIX_PROC_DEBUG
+	bool "Add debug files on procfs"
+	depends OPENMOSIX_DEBUG
+	default n
+	help
+	  Export some variables through /proc for debugging
+
+endmenu
diff -Naur linux-2.6.11/hpc/kernel.c linux-2.6.11-om/hpc/kernel.c
--- linux-2.6.11/hpc/kernel.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/kernel.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,207 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <asm/mmu_context.h>
+#include <hpc/prototype.h>
+#include <hpc/hpc.h>
+#include <hpc/task.h>
+#include <hpc/comm.h>
+#include <hpc/mig.h>
+
+struct openmosix_options om_opts;
+
+/* kernel calls hooks */
+int openmosix_pre_clone(int flags)
+{
+	task_t *p = current;
+	struct mm_struct *mm = p->mm;
+
+	if (!(flags & CLONE_VM))
+		return 0;
+	if (mm)
+		atomic_inc(&mm->mm_realusers);
+
+	task_set_stay(p, DSTAY_CLONE);
+	return 0;
+}
+
+void openmosix_post_clone(int flags)
+{
+	task_t *p = current;
+	struct mm_struct *mm = p->mm;
+
+	if (!(flags & CLONE_VM))
+		return;
+	if (mm && atomic_read(&mm->mm_realusers) == 1)
+		task_clear_stay(p, DSTAY_CLONE);
+}
+
+/**
+ * task_maps_inode - Check if a task @p maps the inode @ip
+ **/
+int task_maps_inode(struct task_struct *p, struct inode *ip)
+{
+	return 0;
+}
+
+void openmosix_no_longer_monkey(struct inode *ip)
+{
+	task_t *p;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p)
+		if (task_maps_inode(p, ip))
+			task_set_dreqs(p, DREQ_CHECKSTAY);
+	read_unlock(&tasklist_lock);
+}
+
+int stay_me_and_my_clones(int reasons)
+{
+	task_t *p, *me = current;
+	struct mm_struct *mm = me->mm;
+	
+	task_lock(me);
+	task_set_stay(me, reasons);
+	task_unlock(me);
+	if (atomic_read(&mm->mm_realusers) > 1) {
+		read_lock(&tasklist_lock);
+		for_each_process(p) {
+			if (p->mm == mm && p != me) {
+				task_lock(p);
+				task_set_stay(p, reasons);
+				task_unlock(p);
+			}
+		}
+		read_unlock(&tasklist_lock);
+	}
+	return 0;
+}
+
+/**
+ * obtain_mm - obtain an mm context
+ *
+ * Description:
+ * Get an mm_struct and initialize it. Associate
+ * with our process.
+ **/
+int obtain_mm(task_t *p)
+{
+	struct mm_struct *mm, *active_mm;
+	int err;
+
+	if (p->mm && !task_test_dflags(p, DDEPUTY))
+		panic("openmosix: process->mm context had already");
+	/*
+	if (p->mm && task_test_dflags(p, DDEPUTY))
+		exit_mm(p);
+	*/
+	if (!(mm = mm_alloc()))
+		return -ENOMEM;
+	if ((err = init_new_context(p, mm)))
+	{
+		task_unlock(p);
+		mmdrop(mm);
+		return err;
+	}
+
+	spin_lock(&mmlist_lock);
+	list_add(&mm->mmlist, &init_mm.mmlist);
+	spin_unlock(&mmlist_lock);
+
+	task_lock(p);
+	active_mm = p->active_mm;
+	p->mm = mm;
+	p->active_mm = mm;
+	task_unlock(p);
+
+	activate_mm(active_mm, mm);
+	mmdrop(active_mm);
+	return 0;
+}
+
+void unstay_mm(struct mm_struct *mm)
+{
+	task_t *p;
+	
+	if (atomic_read(&mm->mm_realusers) == 1 && mm == current->mm)
+	{
+		task_set_dreqs(current, DREQ_CHECKSTAY);
+		return;
+	}
+	read_lock(&tasklist_lock);
+	for_each_process(p)
+		if (p->mm == mm)
+			task_set_dreqs(p, DREQ_CHECKSTAY);
+	read_unlock(&tasklist_lock);
+}
+
+static inline int remote_pre_usermode(void)
+{
+	task_t *p = current;
+	
+	if (p->om.contact && comm_peek(p->om.contact->sock))
+		remote_do_comm(p);
+	return 0;
+}
+
+static inline int deputy_pre_usermode(void)
+{
+	deputy_main_loop();
+	return 0;
+}
+
+/**
+ * openmosix_pre_usermode - process some pre usermode events for current
+ **/
+asmlinkage int openmosix_pre_usermode(struct pt_regs regs)
+{
+	unsigned long flags;
+	
+	if (task_test_dreqs(current, ~0)) {
+		local_save_flags(flags);
+		local_irq_enable();
+
+		task_do_request();
+
+		local_irq_restore(flags);
+	}
+
+	if (task_test_dflags(current, DMIGRATED)) {
+		local_save_flags(flags);
+		local_irq_enable();
+
+		if (task_test_dflags(current, DREMOTE))
+			return remote_pre_usermode();
+		if (task_test_dflags(current, DDEPUTY))
+			return deputy_pre_usermode();
+
+		local_irq_restore(flags);
+	}
+	return 0;
+}
+
+/**
+ * openmosix_init - Init all global variables and subsystem at boot
+ **/
+void openmosix_init(void)
+{
+	/* kick off the kernel threads: */
+	kernel_thread(openmosix_mig_daemon, NULL, 0);
+}
diff -Naur linux-2.6.11/hpc/Makefile linux-2.6.11-om/hpc/Makefile
--- linux-2.6.11/hpc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/Makefile	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,17 @@
+obj-$(CONFIG_OPENMOSIX)		:= \
+		kernel.o \
+		proc.o \
+		task.o \
+		service.o \
+		comm.o \
+		migrecv.o \
+		migsend.o \
+		migctrl.o \
+		remote.o \
+		deputy.o \
+		files.o \
+		syscalls.o
+
+obj-$(CONFIG_OPENMOSIX)			+= arch-$(ARCH).o
+
+obj-$(CONFIG_OPENMOSIX_DEBUG)       += debug.o debug-$(ARCH).o
diff -Naur linux-2.6.11/hpc/migctrl.c linux-2.6.11-om/hpc/migctrl.c
--- linux-2.6.11/hpc/migctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/migctrl.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,244 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <hpc/comm.h>
+#include <hpc/task.h>
+#include <hpc/hpc.h>
+#include <hpc/debug.h>
+#include <hpc/service.h>
+#include <hpc/prototype.h>
+#include <hpc/mig.h>
+#include <hpc/protocol.h>
+
+/**
+ * task_remote_expel - call from REMOTE to send a task to DEPUTY
+ * @p:		task which will come back
+ **/
+int task_remote_expel(task_t *p)
+{
+	om_link_t *link;
+
+	BUG_ON(!task_test_dflags(p, DREMOTE));
+
+	if (mig_send_hshake(p, p->om.contact, HSHAKE_MIG_REQUEST))
+		goto failed;
+
+	if (mig_do_send(p)) {
+		goto failed;
+	}
+	
+	link = task_set_comm(p, NULL);
+	comm_close(link);
+
+	do_exit(SIGKILL);
+	return 0;
+failed:
+	OMBUG("failed\n");
+	return -1;
+}
+
+/**
+ * task_remote_wait_expel - call from REMOTE to send a task to DEPUTY
+ * @p:		task which will come back
+ **/
+int task_remote_wait_expel(task_t *p)
+{
+	int error;
+	struct omp_req req;
+
+	comm_send_req(p->om.contact, REM_BRING_HOME);
+
+	error = comm_recv(p->om.contact, &req, sizeof(req));
+	if (error < 0)
+		return -1;
+	if (req.type != DEP_COMING_HOME) {
+		OMBUG("!DEP_COMING_HOME\n");
+		return -1;
+	}
+
+	return task_remote_expel(p);
+}
+
+/**
+ * task_local_send - Send a local task to remote
+ * @p:		task to send
+ * @whereto:	destination sockaddr
+ * @reason:	reason to send there (if any)
+ **/
+static int task_local_send(task_t *p, struct sockaddr *whereto, int reason)
+{
+	om_link_t *mlink;
+	int error = 0;
+
+	sockaddr_setup_port(whereto, REMOTE_DAEMON_PORT);
+	mlink = comm_setup_connect(whereto, 0);
+	if (!mlink) {
+		OMBUG("error\n");
+
+		error = -1;
+		goto failed;
+	}
+
+	task_set_comm(p, mlink);
+	task_set_dflags(p, DDEPUTY);
+
+	/* see if other part is with on this */
+	if (mig_send_hshake(p, mlink, HSHAKE_MIG_REQUEST))
+		goto failed;
+
+	if (mig_do_send(p)) {
+		error = -1;
+		goto failed;
+	}
+	
+	deputy_startup(p);
+	return 0;
+
+failed:
+	OMBUG("failed\n");
+	task_clear_dflags(p, DDEPUTY);
+	if (mlink)
+		comm_close(mlink);
+	return error;
+}
+
+
+
+/**
+ * task_local_bring - Receive task back in the deputy stub
+ * @p:		deputy task to receive
+ * @reason:	reason to send (if any)
+ **/
+static int task_local_bring(task_t *p, int reason)
+{
+	int error;
+	om_link_t *link;
+
+	if (obtain_mm(p)) {
+		printk(KERN_ERR "unable to obtain mm\n");
+		goto failed;
+	}
+
+	/* send remote request */
+	comm_send_req(p->om.contact, DEP_COMING_HOME);
+
+	/* see if other part is with on this */
+	if (mig_recv_hshake(p->om.contact))
+		goto failed;
+	
+	/* receive the process back */
+	error = mig_do_receive(p);
+	if (error)
+		goto failed;
+
+	task_clear_dflags(p, DDEPUTY);
+	link = task_set_comm(p, NULL);
+	comm_close(link);
+
+	return 0;
+failed:
+	OMBUG("failed\n");
+	return -1;
+}
+
+/**
+ * task_move_remote2remote - migrate a task from remote to remote
+ * @p:		task to send
+ * @whereto:	whereto
+ * @reason:	reason to send (if any)
+ **/
+static int task_move_remote2remote(task_t *p, struct sockaddr * whereto,
+								int reason)
+{
+	OMBUG("not implemented.\n");
+	return 0;
+}
+
+/**
+ * task_move_to_node - send a task to a node
+ * @p:		task to send
+ * @whereto:	destination sockaddr
+ * @reason:	why
+ **/
+int task_move_to_node(struct task_struct *p, struct sockaddr * whereto,
+								int reason)
+{
+	int error;
+
+	if (task_test_stay(p, DSTAY)) {
+		printk(KERN_DEBUG "oM: Task can't move. check stay reason\n");
+		return -1;
+	}
+
+	task_set_dflags(p, DPASSING);
+	
+	error = (task_test_dflags(p, DREMOTE))
+		? (whereto)
+			? task_move_remote2remote(p, whereto, reason)
+			: task_remote_wait_expel(p)
+		: (whereto)
+			? task_local_send(p, whereto, reason)
+			: task_local_bring(p, reason);
+	
+	task_clear_dflags(p, DPASSING);
+
+	if (error)
+		return -1;
+
+	return 0;
+}
+
+/**
+ * task_go_home - Migrate task to home
+ **/
+int task_go_home(task_t *p)
+{
+	if (!task_test_dflags(p, DMIGRATED)) {
+		printk(KERN_INFO "oM: task %d at home: ignoring request.\n",
+				p->pid);
+		return -1;
+	}
+
+	task_move_to_node(p, NULL, 0);
+
+	if (task_test_dflags(p, DMIGRATED))
+		printk(KERN_ERR "oM: task %d fail to go back home\n", p->pid);
+							
+	return 0;
+}
+
+/**
+ * task_go_home_for_reason - Migrate back a task for a reason
+ **/
+int task_go_home_for_reason(task_t *p, int reason)
+{
+	int ret;
+	
+	if (task_test_stay(p, reason) && task_test_dflags(p, DMIGRATED))
+		printk(KERN_ERR "oM: task should had migrated back earlier\n");
+	task_set_stay(p, reason);
+	
+	ret = task_go_home(p);
+	if (!ret)
+		task_clear_stay(p, reason);
+	return ret;
+}
diff -Naur linux-2.6.11/hpc/migrecv.c linux-2.6.11-om/hpc/migrecv.c
--- linux-2.6.11/hpc/migrecv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/migrecv.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,408 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/rmap.h>
+#include <linux/mman.h>
+#include <linux/stddef.h>
+#include <linux/highmem.h>
+#include <linux/personality.h>
+#include <asm/mmu_context.h>
+#include <asm/tlbflush.h>
+#include <hpc/comm.h>
+#include <hpc/task.h>
+#include <hpc/hpc.h>
+#include <hpc/service.h>
+#include <hpc/mig.h>
+#include <hpc/debug.h>
+#include <hpc/protocol.h>
+#include <hpc/prototype.h>
+#include <hpc/version.h>
+#include <hpc/arch.h>
+
+/* handshake with the remote part */
+int mig_recv_hshake(om_link_t *mlink)
+{
+	int error;
+	struct omp_mig_handshake hshake;
+
+	/* receive request of whatever */
+	error = comm_recv(mlink, &hshake, sizeof(hshake));
+	if (error < 0) {
+		OMBUG("recv failed %d\n", error);
+		return -1;
+	}
+
+	/* FIXME: sanity checks here */
+
+	/* reply of mig_requests */
+	hshake.type = hshake.type | HSHAKE_REPLY;
+	hshake.version = OPENMOSIX_VERSION;
+
+	error = comm_send(mlink, &hshake, sizeof(hshake));
+	if (error < 0) {
+		OMBUG("send failed %d\n", error);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************/
+
+/**
+ * mig_do_receive_mig_mm - Receive some parameters for a mm
+ **/
+static void mig_do_receive_mm(task_t *p, struct omp_mig_mm *s)
+{
+	OMDEBUG_MIG(2, "MIG_MM\n");
+	/* copy all mm's parameter from start_code to env_end */
+	memcpy(&p->mm->start_code, s, sizeof(*s));
+}
+
+/**
+ * mig_do_receive_mm_area - Set up an mmap
+ **/
+static int mig_do_receive_vma(task_t *p, struct omp_mig_vma *a)
+{
+	unsigned long result, prot, flags;
+	struct file *file = NULL;
+	extern asmlinkage long sys_madvise(unsigned long, size_t, int);
+	
+	OMDEBUG_MIG(2, "MIG_VMA [%ld, %ld]\n", a->vm_start, a->vm_size);
+
+	if (a->vm_file) {
+		file = (task_test_dflags(p, DREMOTE))
+			? task_rfiles_get(p, a->vm_file, -1, a->i_size)
+			: a->vm_file;
+	}
+
+	/* unconvert prot+flags: */
+	flags = MAP_FIXED | MAP_PRIVATE;
+	prot = 0;
+	if (a->vm_flags & VM_GROWSDOWN)
+		flags |= MAP_GROWSDOWN;
+	if (a->vm_flags & VM_DENYWRITE)
+		flags |= MAP_DENYWRITE;
+	if (a->vm_flags & VM_EXECUTABLE)
+		flags |= MAP_EXECUTABLE;
+
+	/* copy VM_(READ|WRITE|EXEC) bits to prot */
+	prot |= (a->vm_flags & (VM_READ | VM_WRITE | VM_EXEC));
+
+	/* mmap stuff */
+	result = do_mmap_pgoff(file, a->vm_start, a->vm_size, prot,
+						flags, a->vm_pgoff);
+
+	if (a->vm_flags & VM_READHINTMASK) {
+		int behavior = (a->vm_flags & VM_SEQ_READ)
+				? MADV_RANDOM
+				: MADV_SEQUENTIAL;
+		sys_madvise(a->vm_start, a->vm_size, behavior);
+	}
+	return IS_ERR((const void *) result);
+}
+
+
+/**
+ * mig_do_receive_page - Receive one page
+ **/
+static int mig_do_receive_page(task_t *p, unsigned long addr)
+{
+	struct mm_struct *mm = p->mm;
+	struct vm_area_struct *vma;
+	struct page *recv_page = NULL;
+	void *kmpage; /* kmapped page */
+	int error;
+	pgd_t * pgd;
+	pud_t * pud;
+	pmd_t * pmd;
+	pte_t * pte;
+
+	OMDEBUG_MIG(3, "MIG_PAGE [%lx]\n", addr);
+
+	vma = find_vma(mm, addr);
+	if (!vma) {
+		OMBUG("vma not found (addr: %p)\n", (void *) addr);
+		return -1;
+	}
+
+	/* check if enough memory */
+
+	/* alloc page */
+	recv_page = alloc_page(GFP_HIGHUSER);
+	if (!recv_page) {
+		OMBUG("unable to allocate page\n");
+		return -ENOMEM;
+	}
+
+	kmpage = kmap(recv_page);
+	
+	/* receive the data into the page */
+	error = comm_recv(p->om.contact, kmpage, PAGE_SIZE);
+
+	kunmap(recv_page);
+	if (error < 0) {
+		OMBUG("failed to receive data\n");
+		goto out_alloc;
+	}
+
+	/* add the page at correct place */
+	pgd = pgd_offset(mm, addr);
+	spin_lock(&mm->page_table_lock);
+	if (!(pud = pud_alloc(mm, pgd, addr)))
+		goto out_spinlock;
+	if (!(pmd = pmd_alloc(mm, pud, addr)))
+		goto out_spinlock;
+	if (!(pte = pte_alloc_kernel(mm, pmd, addr)))
+		goto out_spinlock;
+	if (!pte_none(*pte))
+		OMBUG("double page at addr %p\n", (void *) addr);
+
+	set_pte(pte, pte_mkdirty(mk_pte(recv_page, vma->vm_page_prot)));
+	page_dup_rmap(recv_page);
+	mm->rss++;
+	spin_unlock(&mm->page_table_lock);
+	
+	return 0;
+	
+out_spinlock:
+	spin_unlock(&mm->page_table_lock);
+out_alloc:
+	OMBUG("receive page failed at addr %p\n", (void *) addr);
+	__free_page(recv_page);
+	return -1;
+}
+
+/**
+ * mig_do_receive_fp - Receive floating points registers
+ * @p:		task
+ * @fpr:	floating point registers
+ **/
+static void mig_do_receive_fp(task_t *p, struct omp_mig_fp *fp)
+{
+	OMDEBUG_MIG(2, "MIG_FP\n");
+	set_used_math();
+	arch_mig_receive_fp(p, fp);
+}
+
+/**
+ * mig_do_receive_misc - Receive normal registers, limits
+ **/
+static void mig_do_receive_proc_context(task_t *p, struct omp_mig_task *m)
+{
+	OMDEBUG_MIG(1, "MIG_TASK\n");
+	/* arch specific proc receive context */
+	arch_mig_receive_proc_context(p, m);
+
+	/* copy id */
+	p->om.pid = m->pid;
+	p->om.tgid = m->tgid;
+
+	/* copy credentials */
+	p->uid = m->uid;
+	p->euid = m->euid;
+	p->suid = m->suid;
+	p->fsuid = m->fsuid;
+	
+	p->gid = m->gid;
+	p->egid = m->egid;
+	p->sgid = m->sgid;
+	p->fsgid = m->fsgid;
+
+	/* signals stuffs */
+	p->blocked = m->blocked;
+	p->real_blocked = m->real_blocked;
+	p->sas_ss_sp = m->sas_ss_sp;
+	p->sas_ss_size = m->sas_ss_size;
+	memcpy(p->sighand->action, m->sighand, sizeof(struct k_sigaction)
+								* _NSIG);
+
+	/* copy task_t stuff */
+	p->it_prof_incr = m->it_prof_incr;
+	p->it_virt_incr = m->it_virt_incr;
+
+	/* FIXME we don't trust the other node anyway so copy rlimit from node[nr] */
+
+	p->personality = m->personality;
+	arch_pick_mmap_layout(p->mm);
+}
+
+/**
+ * mig_do_receive - Receive all process stuff (mm, pages, fpr, ..)
+ **/
+int mig_do_receive(task_t *p)
+{
+	int error;
+	unsigned int got_not_coming = 0;
+	unsigned long data;
+	struct omp_req req;
+
+	data = __get_free_page(GFP_KERNEL);
+	if (!data)
+		goto fail;
+	
+	task_set_dflags(p, DINCOMING);
+	clear_used_math();
+
+	while (1) {
+		error = comm_recv(p->om.contact, &req, sizeof(req));
+		if (error < 0)
+			goto fail;
+
+		error = comm_recv(p->om.contact, (void *) data, req.dlen);
+		if (error < 0)
+			goto fail;
+
+		switch (req.type) {
+		case MIG_MM:
+			mig_do_receive_mm(p, (struct omp_mig_mm *) data);
+			break;
+		case MIG_VMA:
+			if (mig_do_receive_vma(p, (struct omp_mig_vma *) data))
+				goto fail;
+			break;
+		case MIG_PAGE:
+			if (mig_do_receive_page(p, *((unsigned long *) data)))
+				goto fail;
+			break;
+		case MIG_FP:
+			mig_do_receive_fp(p, (struct omp_mig_fp *) data);
+			break;
+		case MIG_ARCH:
+			if (arch_mig_receive_specific(p, (struct omp_mig_arch *) data))
+				goto fail;
+			break;
+		/* this is the last thing we do in the chain of receiving,
+		 * so return 0 after we're done */
+		case MIG_TASK:
+			mig_do_receive_proc_context(p, (struct omp_mig_task *) data);
+			comm_send_req(p->om.contact, MIG_TASK | REPLY);
+			task_clear_dflags(p, DINCOMING);
+
+			flush_tlb_mm(p->mm); /* for all the new pages */
+			return 0;
+		case MIG_ABORT:
+			printk("mig_do_recv(): got MIG_ABORT\n");
+			got_not_coming = 1;
+			goto fail;
+		default:
+			printk("mig_do_recv(): got default\n");
+			goto fail;
+		}
+	}
+fail:
+	task_clear_dflags(p, DINCOMING);
+	free_page(data);
+
+	OMBUG("failed\n");
+	return -1;
+}
+
+static int mig_handle_migration(void *ptr)
+{
+	task_t *p = current;
+	/* link against the other end */
+	om_link_t *link = (om_link_t *) ptr;
+	int error;
+
+	OM_VERBOSE_MIG("[OM] receiving new process\n");
+
+	task_set_comm(p, link);
+
+	error = obtain_mm(p);
+	if (error)
+		goto fail;
+	if (mig_recv_hshake(link))
+		goto fail;
+
+	error = mig_do_receive(p);
+
+	if (error)
+		goto fail;
+
+	OM_VERBOSE_MIG("[OM] starting process(%d)\n", p->pid);
+	arch_kickstart(p);
+	/*NOTREACHED*/
+
+fail:
+	OMBUG("failed\n");
+	do_exit(SIGKILL);
+	/*NOTREACHED*/
+}
+
+/**
+ * openmosix_mig_daemon - openMosix migration daemon
+ * @nothing:	unused
+ *
+ * Description:
+ * 	start the migration daemon.
+ * 	wait for communication, and if it is a remote request
+ * 	then start a user-thread with the new program to run
+ **/
+int openmosix_mig_daemon(void *nothing)
+{
+	task_t *p = current;
+	int error;
+	om_link_t *mlink;
+	struct sockaddr saddr;
+
+	om_daemonize("omkmigd", 0);
+
+	task_set_dflags(p, DREMOTEDAEMON);
+
+	set_our_addr(AF_INET, &saddr, REMOTE_DAEMON_PORT);
+
+restart:
+	if (!p->om.contact) {
+		p->om.contact = comm_setup_listen(&saddr);
+		if (!p->om.contact) {
+			printk(KERN_WARNING
+				"omkmigd: failed to open mig service\n");
+			flush_signals(p);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ);
+			goto restart;
+		}
+	}
+
+	/* migration daemon loop */
+	while (1)
+	{
+		error = comm_accept(p->om.contact, &mlink, &saddr, 0UL);
+		if (error == -EINTR || error == -ERESTART || error == -EAGAIN
+		   || error == -ERESTARTSYS)
+		{
+			if (sigismember(&(p->pending.signal), SIGCHLD)) {
+				printk("omigd: SIGCHLD caught\n");	
+			}
+			flush_signals(p);
+			continue;
+		} else if (error) {
+			OMBUG("failed to accept\n");
+			comm_close(mlink);
+			goto restart;
+		}
+
+		error = user_thread(mig_handle_migration, (void *) mlink, 0);
+		if (error < 0)
+			comm_close(mlink);
+	}
+}
diff -Naur linux-2.6.11/hpc/migsend.c linux-2.6.11-om/hpc/migsend.c
--- linux-2.6.11/hpc/migsend.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/migsend.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,240 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/stddef.h>
+#include <linux/highmem.h>
+#include <linux/personality.h>
+#include <asm/tlbflush.h>
+#include <asm/mmu_context.h>
+#include <hpc/comm.h>
+#include <hpc/task.h>
+#include <hpc/hpc.h>
+#include <hpc/debug.h>
+#include <hpc/service.h>
+#include <hpc/prototype.h>
+#include <hpc/mig.h>
+#include <hpc/protocol.h>
+#include <hpc/version.h>
+#include <hpc/arch.h>
+
+/* handle sending of migration request, and check answer */
+int mig_send_hshake(task_t *p, om_link_t *mlink, int type)
+{
+	struct omp_mig_handshake hshake, hshake_recv;
+	int error;
+	
+	hshake.type = type;
+	hshake.version = OPENMOSIX_VERSION;
+	hshake.personality = p->personality;
+
+	error = comm_send(mlink, &hshake, sizeof(hshake));
+        if (error < 0) {
+		OMBUG("send failed: %d\n", error);
+		return -1;
+	}
+
+	error = comm_recv(mlink, &hshake_recv, sizeof(hshake_recv));
+        if (error < 0) {
+		OMBUG("recv failed %d\n", error);
+                return -1;
+        }
+
+	if (hshake_recv.type != (hshake.type | HSHAKE_REPLY)) {
+		/* it's a no go ... */
+		OMBUG("no go\n");
+		return -1;
+	}					        
+
+	return 0;
+}
+
+static int mig_send_fp(task_t *p)
+{
+	struct omp_mig_fp m;
+	
+	if (!used_math())
+		return 0;
+
+	arch_mig_send_fp(p, &m);
+	return comm_send_hd(p->om.contact, MIG_FP, &m, sizeof(m));
+}
+
+
+static int mig_send_mm(task_t *p)
+{
+	struct omp_mig_mm s;
+	
+	memcpy(&s, &p->mm->start_code, sizeof(s));
+
+	return comm_send_hd(p->om.contact, MIG_MM, &s, sizeof(s));
+}
+
+static inline void mig_send_vma_file(task_t *p, struct vm_area_struct *vma,
+							struct omp_mig_vma *m)
+{
+	struct inode *inode = vma->vm_file->f_dentry->d_inode;
+
+	m->vm_pgoff = vma->vm_pgoff;
+	m->i_size = inode->i_size;
+
+	if (task_test_dflags(p, DREMOTE)) {
+		struct rfile_inode_data *data;
+
+		data = (struct rfile_inode_data *) inode->u.generic_ip;
+		m->vm_file = data->file;
+	} else {
+		m->vm_file = vma->vm_file;
+		m->f_dentry = vma->vm_file->f_dentry;
+	}
+}
+
+static int mig_send_vmas(task_t *p)
+{
+	struct vm_area_struct *vma;
+	struct omp_mig_vma m;
+	int ret = 0;
+
+	for (vma = p->mm->mmap; vma; vma = vma->vm_next)
+	{
+		m.vm_start= vma->vm_start;
+		m.vm_size = vma->vm_end - vma->vm_start;
+		m.vm_flags = vma->vm_flags;
+		m.vm_file = vma->vm_file;
+		m.vm_pgoff = 0;
+		if (vma->vm_file)
+			mig_send_vma_file(p, vma, &m);
+
+		ret = comm_send_hd(p->om.contact, MIG_VMA, &m, sizeof(m));
+		if (ret < 0) {
+			OMBUG("send vma failed\n");
+			break;
+		}
+		
+	}
+	return ret;
+}
+
+
+static int mig_send_pages(task_t *p)
+{
+	struct vm_area_struct * vma;
+	unsigned long addr;
+	int error;
+
+	for (vma = p->mm->mmap; vma; vma = vma->vm_next)
+	{
+		if (!(vma->vm_flags & VM_READ))
+			continue;
+		for (addr = vma->vm_start; addr < vma->vm_end; addr += PAGE_SIZE)
+		{
+			error = comm_send_hd(p->om.contact, MIG_PAGE, &addr,
+								sizeof(addr));
+			if (error < 0)
+				goto fail;
+
+			error = comm_send(p->om.contact, (void *) addr,
+								PAGE_SIZE);
+			if (error < 0)
+				goto fail;
+		}
+	}
+	return 0;
+fail:
+	OMBUG("failed (addr: %p)\n", (void *) addr);
+	return -1;
+}
+
+
+static int mig_send_proc_context(task_t *p)
+{
+	struct omp_mig_task m;
+	struct omp_req req;
+	int error;
+	
+	m.ptrace = p->ptrace;
+	
+	m.pid = p->pid;
+	m.tgid = p->tgid;
+
+	/* credentials */
+	m.uid = p->uid;
+	m.euid = p->euid;
+	m.suid = p->suid;
+	m.fsuid = p->fsuid;
+
+	m.gid = p->gid;
+	m.egid = p->egid;
+	m.sgid = p->sgid;
+	m.fsgid = p->fsgid;
+	
+	/* signals */
+	m.blocked = p->blocked;
+	m.real_blocked = p->real_blocked;
+	m.sas_ss_sp = p->sas_ss_sp;
+	m.sas_ss_size = p->sas_ss_size;
+	memcpy(m.sighand, p->sighand->action, sizeof(struct k_sigaction)
+								* _NSIG);
+	
+	/* others */
+	m.nice = task_nice(p);
+	m.caps = p->cap_effective;
+	p->om.remote_caps = m.caps;
+	m.it_prof_incr = p->it_prof_incr;
+	m.it_virt_incr = p->it_virt_incr;
+
+	m.personality = p->personality;
+
+	arch_mig_send_proc_context(p, &m);
+
+	error = comm_send_hd(p->om.contact, MIG_TASK, &m, sizeof(m));
+	if (error < 0)
+		goto fail;
+
+	error = comm_recv(p->om.contact, &req, sizeof(req));
+
+	if (req.type == (MIG_TASK | REPLY))
+		return 0; /* commit point */
+
+fail:
+	OMBUG("failed\n");
+	return -1;
+}
+
+int mig_do_send(task_t *p)
+{
+	arch_mig_send_pre(p);
+
+	if (mig_send_mm(p)) goto fail_mig;
+	if (mig_send_vmas(p)) goto fail_mig;
+	if (mig_send_pages(p)) goto fail_mig;
+	if (mig_send_fp(p)) goto fail_mig;
+	if (arch_mig_send_specific(p)) goto fail_mig;
+	if (mig_send_proc_context(p)) goto fail_mig;
+
+	arch_mig_send_post(p);
+
+	return 0;
+fail_mig:
+	OMBUG("failed\n");
+	comm_send_req(p->om.contact, MIG_ABORT);
+	return -1;
+}
diff -Naur linux-2.6.11/hpc/proc.c linux-2.6.11-om/hpc/proc.c
--- linux-2.6.11/hpc/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/proc.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,475 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/socket.h>
+#include <linux/ctype.h>
+#include <asm/uaccess.h>
+#include <hpc/hpc.h>
+#include <hpc/proc.h>
+#include <hpc/version.h>
+#include <hpc/service.h>
+#include <hpc/prototype.h>
+#include <hpc/task.h>
+#include <hpc/debug.h>
+#include <hpc/mig.h>
+
+/*
+ *	PID set/get accessor
+ */
+static int proc_pid_set_where(struct task_struct *p, char *buf, size_t size)
+{
+	int ret;
+	struct sockaddr destination;
+	
+	if (size >= 4 && strnicmp(buf, "home", 4) == 0) {
+		printk("HOME detected\n");
+		ret = task_register_migration(p, NULL);
+	} else {
+		ret = string_to_sockaddr(buf, &destination);
+		if (ret >= 0)
+			task_register_migration(p, &destination);
+	}
+	return size;
+}
+
+static int proc_pid_get_where(struct task_struct *p, char *buf, size_t size)
+{
+	int length;
+	struct sockaddr address;
+
+	if (p->om.contact) {
+		comm_getname(p->om.contact, &address);
+		length = sockaddr_to_string(&address, buf);
+		length += sprintf(buf + length, "\n");
+	} else
+		length = sprintf(buf, "home\n");
+
+	return length;
+}
+
+#ifdef CONFIG_OPENMOSIX_DEBUG
+
+#define proc_debug_get_var(name, fmt, var)			\
+static int proc_debug_get_##name (char *buf, size_t size)	\
+{								\
+	int length;						\
+	length = sprintf(buf, fmt, om_opts.var);		\
+	return length;						\
+}
+
+#define proc_debug_set_var(name, var)				\
+static int proc_debug_set_##name(char *buf, size_t size)	\
+{								\
+	long value;						\
+	char *endp;						\
+	endp = buf + size;					\
+	value = simple_strtoul(buf, &endp, 10);			\
+	if (value >= 0 && value <= 10) {			\
+		om_opts.var = value;				\
+	}							\
+	return size;						\
+}
+
+proc_debug_get_var(migration, "%d\n", debug_mig)
+proc_debug_get_var(syscall, "%d\n", debug_sys)
+proc_debug_get_var(rinode, "%d\n", debug_rino)
+proc_debug_get_var(copyuser, "%d\n", debug_copyuser)
+
+proc_debug_set_var(migration, debug_mig)
+proc_debug_set_var(syscall, debug_sys)
+proc_debug_set_var(rinode, debug_rino)
+proc_debug_set_var(copyuser, debug_copyuser)
+
+#endif /* CONFIG_OPENMOSIX_DEBUG */
+
+static char *stayreason_string[32] = {
+	"monkey",	"mmap_dev",	"VM86_mode",	NULL,
+	"priv_inst",	"mem_lock",	"clone_vm",	"rt_sched",
+	"direct_io",	"system",	NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL,
+	"extern_1",	"extern_2",	"extern_3",	"extern_4",
+	NULL,		NULL,		NULL,		"user_lock"
+};
+
+static int proc_pid_get_stay(struct task_struct *p, char *buf, size_t size)
+{
+	int length, i;
+
+	length = 0;
+	for (i = 0; i < 31; i++)
+		if (task_test_stay(p, 1 << i))
+			length += snprintf(buf + length, size - length,
+					"%s\n", stayreason_string[i]);
+	if (!length)
+		buf[0] = 0;
+	return length;
+}
+
+static int proc_pid_get_debug(struct task_struct *p, char *buf, size_t size)
+{
+	int length;
+	
+	length = sprintf(buf, "debug: dflags: 0x%.8x\n", p->om.dflags);
+	return length;
+}
+
+static int proc_admin_set_bring(char *buf, size_t size)
+{
+	printk(KERN_DEBUG "oM: proc: set bring");
+	return size;
+}
+
+static int proc_admin_set_expel(char *buf, size_t size)
+{
+	printk(KERN_DEBUG "oM: proc: set expel");
+	return size;
+}
+
+static int proc_admin_get_version(char *buf, size_t size)
+{
+	int length;
+	
+	length = sprintf(buf, "openMosix version: %d.%d.%d\n",
+			OPENMOSIX_VERSION_TUPPLE);
+	return length;
+}
+
+/* create /proc/hpc/admin/ entry */
+#define E(name,mode,s,g) {0,sizeof(name)-1,(name),(mode), \
+				proc_admin_set_##s, \
+				proc_admin_get_##g }
+
+static om_proc_entry_t proc_om_entry_admin[] =
+{
+	E("bring", S_IFREG|S_IRUGO|S_IWUGO, bring, 0),
+	E("expel", S_IFREG|S_IRUGO|S_IWUGO, expel, 0),
+	E("version", S_IFREG|S_IRUGO|S_IWUGO, 0, version),
+	{ 0, 0, NULL, 0, NULL, NULL }
+};
+
+#undef E
+
+/* create /proc/${pid}/ entry */
+#define E(name,s,g) {0,sizeof(name)-1,(name),0, \
+			proc_pid_set_##s, \
+			proc_pid_get_##g}
+
+static om_proc_pid_entry_t proc_om_entry_pid[] =
+{
+	E("where", where, where),
+	E("stay", 0, stay),
+	E("debug", 0, debug),
+	{ 0, 0, NULL, 0, NULL, NULL }
+};
+
+#undef E
+
+#ifdef CONFIG_OPENMOSIX_PROC_DEBUG
+/* create /proc/hpc/debug entry */
+
+#define E(name,mode,s,g) {0,sizeof(name)-1,(name),(mode), \
+				proc_debug_set_##s, \
+				proc_debug_get_##g}
+
+static om_proc_entry_t proc_om_entry_debug[] =
+{
+	E("migration", S_IFREG|S_IRUGO|S_IWUGO, migration, migration),
+	E("syscall", S_IFREG|S_IRUGO|S_IWUGO, syscall, syscall),
+	E("rinode", S_IFREG|S_IRUGO|S_IWUGO, rinode, rinode),
+	E("copyuser", S_IFREG|S_IRUGO|S_IWUGO, copyuser, copyuser),
+	{ 0, 0, NULL, 0, NULL, NULL }
+};
+
+#undef E
+#endif /* CONFIG_OPENMOSIX_PROC_DEBUG */
+
+/**
+ * openmosix_proc_pid_getattr - Get attributes from task
+ * @p: the task we want attributes
+ * @name: name of the attributes
+ * @buf: the page to write the value to
+ * @size: unused
+ **/
+int openmosix_proc_pid_getattr(struct task_struct *p,
+			char *name, void *buf, size_t size)
+{
+	int length, i;
+
+	if (!size)
+		return -ERANGE;
+
+	length = -EINVAL;
+	for (i = 0; proc_om_entry_pid[i].name; i++)
+	{
+		om_proc_pid_entry_t * tmpentry = &proc_om_entry_pid[i];
+		if (!strncmp(name, tmpentry->name, tmpentry->len))
+		{
+			length = (tmpentry->get)(p, buf, size);
+			break;
+		}
+	}
+	return length;
+}
+
+/**
+ * openmosix_proc_pid_setattr - Set attributes to task
+ * @p: the task we want attributes
+ * @name: name of the attributes
+ * @buf: the page to get the value from
+ * @size: size bytes to read
+ **/
+int openmosix_proc_pid_setattr(struct task_struct *p,
+			char *name, void *buf, size_t size)
+{
+	int error, i;
+
+	error = -EINVAL;
+	for (i = 0; proc_om_entry_pid[i].name; i++)
+	{
+		om_proc_pid_entry_t * tmpentry = &proc_om_entry_pid[i];
+		if (!strncmp(name, tmpentry->name, tmpentry->len))
+		{
+			error = (tmpentry->set)(p, buf, size);
+			break;
+		}
+	}
+	return error;
+}
+
+/**
+ * proc_callback_read - read an attribute and return to userspace
+ *
+ * Handle page creation and correct verification then call the callback
+ **/
+static ssize_t proc_callback_read(struct file * file, char * buf,
+				  size_t count, loff_t *ppos,
+				  om_proc_entry_t *entry)
+{
+	unsigned long page;
+	ssize_t length;
+	ssize_t end;
+	char *name;
+	int i;
+
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
+	if (!(page = __get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+
+	name = (char *) file->f_dentry->d_name.name;
+
+	length = -EINVAL;
+	/* browse entry to find callback for file name */
+	for (i = 0; entry[i].name; i++)
+	{
+		om_proc_entry_t * tmpentry = &entry[i];
+		if (!strncmp(name, tmpentry->name, tmpentry->len))
+		{
+			length = (tmpentry->get)((char *) page, count);
+			break;
+		}
+	}
+
+	if (length < 0) {
+		free_page(page);
+		return length;
+	}
+	/* Static 4kB (or whatever) block capacity */
+	if (*ppos >= length) {
+		free_page(page);
+		return 0;
+	}
+	if (count + *ppos > length)
+		count = length - *ppos;
+	end = count + *ppos;
+	if (copy_to_user(buf, (char *) page + *ppos, count))
+		count = -EFAULT;
+	else
+		*ppos = end;
+	free_page(page);
+	return count;
+}
+
+/**
+ * proc_callback_write - set an attribute from userspace buf
+ *
+ * Handle page creation and correct verification then call the callback
+ **/
+static ssize_t proc_callback_write(struct file * file, const char * buf,
+				   size_t count, loff_t *ppos,
+				   om_proc_entry_t *entry)
+{
+	char *page, *name;
+	ssize_t length;
+	int i;
+
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
+	if (*ppos != 0) {
+		/* No partial writes. */
+		return -EINVAL;
+	}
+	page = (char*)__get_free_page(GFP_USER);
+	if (!page)
+		return -ENOMEM;
+	length = -EFAULT; 
+	if (copy_from_user(page, buf, count)) 
+		goto out;
+
+	name = (char *) file->f_dentry->d_name.name;
+	
+	/* browse entry to find callback for file name */
+	for (i = 0; entry[i].name; i++)
+	{
+		om_proc_entry_t * tmpentry = &entry[i];
+		if (!strncmp(name, tmpentry->name, tmpentry->len))
+		{
+			length = (tmpentry->set)(page, count);
+			break;
+		}
+	}
+
+out:
+	free_page((unsigned long) page);
+	return length;
+} 
+
+/*
+ * openMosix proc dir file_ops handler
+ */
+#define PROC_OM_SUBSYS_READ(subsys)					\
+	static ssize_t proc_om_read_##subsys(struct file * file,	\
+						char *buf,		\
+						size_t count,		\
+						loff_t *ppos)		\
+	{								\
+		return proc_callback_read(file, buf, count,		\
+				ppos, proc_om_entry_##subsys);		\
+	}
+
+#define PROC_OM_SUBSYS_WRITE(subsys)					\
+	static ssize_t proc_om_write_##subsys(struct file * file,	\
+						const char *buf,	\
+						size_t count,		\
+						loff_t *ppos)		\
+	{								\
+		return proc_callback_write(file, buf, count,		\
+				ppos, proc_om_entry_##subsys);		\
+	}
+
+PROC_OM_SUBSYS_READ(admin)
+PROC_OM_SUBSYS_WRITE(admin)
+
+#ifdef CONFIG_OPENMOSIX_PROC_DEBUG
+PROC_OM_SUBSYS_READ(debug)
+PROC_OM_SUBSYS_WRITE(debug)
+#endif
+
+#undef PROC_OM_SUBSYS_READ
+#undef PROC_OM_SUBSYS_WRITE
+
+static struct file_operations proc_om_admin_operations = {
+	.read = proc_om_read_admin,
+	.write = proc_om_write_admin,
+};
+
+#ifdef CONFIG_OPENMOSIX_PROC_DEBUG
+static struct file_operations proc_om_debug_operations = {
+	.read = proc_om_read_debug,
+	.write = proc_om_write_debug,
+};
+#endif
+
+/**
+ * openmosix_proc_create_entry - create @entry in @dir with their callbacks
+ * @dir:	directory to create the entries into
+ * @entry:	entries to add into directory
+ * @r:		read callback
+ * @w:		write callback
+ */
+static void openmosix_proc_create_entry(struct proc_dir_entry *dir,
+					om_proc_entry_t *entry,
+					struct file_operations *fileops)
+{
+	struct proc_dir_entry *de;
+	int i;
+
+	for (i = 0; entry[i].name; i++)
+	{
+		om_proc_entry_t * tmp = &entry[i];
+		de = create_proc_entry(tmp->name, tmp->mode, dir);
+		if (!de) {
+			OMBUG("unable to create entry\n");
+			continue;
+		}
+		de->proc_fops = fileops;
+	}
+}
+
+/*
+ * init hpc proc debug directory
+ */
+#ifdef CONFIG_OPENMOSIX_PROC_DEBUG
+void openmosix_proc_debug_init(void)
+{
+	struct proc_dir_entry *dir_debug;
+
+	dir_debug = proc_mkdir("hpc/debug", NULL);
+	if (!dir_debug) {
+		OMBUG("unable to create debug directory\n");
+		return;
+	}
+	openmosix_proc_create_entry(dir_debug, proc_om_entry_debug,
+				&proc_om_debug_operations);
+}
+#else
+void openmosix_proc_debug_init(void) { }
+#endif /* CONFIG_OPENMOSIX_PROC_DEBUG */
+
+
+
+/*
+ * init hpc proc directory
+ */
+void openmosix_proc_init(void)
+{
+	struct proc_dir_entry *dir_root, *dir_admin;
+	
+	dir_root = proc_mkdir("hpc", NULL);
+	if (!dir_root) {
+		OMBUG("unable to create root directory\n");
+		return;
+	}
+
+	dir_admin = proc_mkdir("hpc/admin", NULL);
+
+	if (!dir_admin) {
+		OMBUG("unable to create admin directory\n");
+		return;
+	}
+
+	openmosix_proc_create_entry(dir_admin, proc_om_entry_admin,
+					&proc_om_admin_operations);
+
+	openmosix_proc_debug_init();
+}
diff -Naur linux-2.6.11/hpc/remote.c linux-2.6.11-om/hpc/remote.c
--- linux-2.6.11/hpc/remote.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/remote.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,536 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/syscalls.h>
+#include <linux/pagemap.h>
+#include <hpc/protocol.h>
+#include <hpc/mig.h>
+#include <hpc/comm.h>
+#include <hpc/task.h>
+#include <hpc/arch.h>
+#include <hpc/prototype.h>
+#include <hpc/service.h>
+#include <hpc/hpc.h>
+#include <hpc/debug.h>
+
+
+NORET_TYPE void remote_disappear(void)
+{
+	do_exit(SIGKILL);
+	/*NOTREACHED*/
+}
+
+struct vm_operations_struct remote_inode_mmap =
+{
+	.nopage = filemap_nopage,
+};
+
+int remote_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	if (vma->vm_flags & VM_SHARED) {
+		printk(KERN_ERR "remote_file_mmap: VM_SHARED mmaping\n");
+		return -1;
+	}
+	vma->vm_ops = &remote_inode_mmap;
+	return 0;
+}
+
+int remote_readpage(struct file *file, struct page *page)
+{
+	int error;
+	void *kmpage;
+	struct omp_page_req m;
+	
+	kmpage = kmap(page);
+	
+	m.file = rfiles_inode_get_file(file->f_dentry->d_inode);
+	m.offset = page->index << PAGE_CACHE_SHIFT;
+
+	error = comm_send_hd(current->om.contact, REM_PAGE, &m, sizeof(m));
+	if (error < 0)
+		goto error;
+
+	error = comm_recv(current->om.contact, kmpage, PAGE_SIZE);
+	if (error < 0)
+		goto error;
+		
+	SetPageUptodate(page);
+	kunmap(page);
+	return 0;
+error:
+	OMBUG("error %d\n", error);
+	ClearPageUptodate(page);
+	SetPageError(page);
+	return error;
+}
+
+long remote_do_mmap(unsigned long addr, unsigned long len,
+		unsigned long prot, unsigned long flags,
+		unsigned long fd, unsigned long pgoff)
+{
+	struct omp_mmap_req m;
+	struct omp_mmap_ret r;
+	struct file *file;
+	long error;
+
+	m.addr = addr;
+	m.len = len;
+	m.prot = prot;
+	m.flags = flags;
+	m.fd = fd;
+	m.pgoff = pgoff;
+	
+	error = comm_send_hd(current->om.contact, REM_MMAP, &m, sizeof(m));
+	if (error < 0)
+		goto out;
+
+	error = comm_recv(current->om.contact, &r, sizeof(r));
+	if (error < 0)
+		goto out;
+
+	file = task_rfiles_get(current, r.file, -1, r.isize);
+	
+	down_write(&current->mm->mmap_sem);
+	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	up_write(&current->mm->mmap_sem);
+
+out:
+	return error;
+}
+
+/**
+ * remote_wait - wait @expect packet from deputy
+ **/
+int remote_wait(task_t *p, int expect, void *data, int len)
+{
+	int error;
+	struct omp_req req;
+
+	error = comm_recv(p->om.contact, &req, sizeof(req));
+	if (error < 0)
+		goto comm_error;
+	
+	if (req.type != expect) {
+		OMBUG("unexpected [%x] expecting [%x]\n", req.type, expect);
+		return -1;
+	}
+
+	if (req.dlen != len) {
+		OMBUG("unexpected size\n");
+		return -1;
+	}
+
+	error = comm_recv(p->om.contact, data, len);
+	if (error < 0)
+		goto comm_error;
+	return 0;
+comm_error:
+	OMBUG("unexpected error %d\n", error);
+	return -1;
+}
+
+static int remote_do_signal(task_t *p)
+{
+	struct omp_signal s;
+	unsigned long flags;
+	int error;
+
+	error = comm_recv(p->om.contact, &s, sizeof(s));
+	printk("received signal %d\n", s.signr);
+
+	spin_lock_irqsave(&p->sighand->siglock, flags);
+	error = __group_send_sig_info(s.signr, &s.siginfo, p);
+	spin_unlock_irqrestore(&p->sighand->siglock, flags);
+
+	return 0;
+}
+
+/**
+ * remote_do_comm - process a communication
+ **/
+int remote_do_comm(task_t *p)
+{
+	int error;
+	struct omp_req req;
+
+	error = comm_recv(p->om.contact, &req, sizeof(req));
+	if (error < 0)
+		goto fail;
+
+	switch (req.type) {
+	case DEP_SIGNAL:
+		error = remote_do_signal(p);
+		break;
+	case DEP_COMING_HOME:
+		printk("remote_do_comm(): got DEP_COMING_HOME\n");
+		error = task_remote_expel(p);
+		break;
+	default:
+		printk("remote_do_comm(): got default\n");
+		goto fail;
+	}
+
+	return 0;
+fail:
+	OMBUG("failed\n");
+	do_exit(-1);
+	return -1;
+}
+
+/**
+ * remote_copy_user - Copy to or from user for deputy
+ **/
+static int remote_copy_user(task_t *p, int request)
+{
+	struct omp_usercopy_req u;
+	void *buf = NULL;
+	int error;
+
+	error = comm_recv(p->om.contact, &u, sizeof(u));
+	if (error < 0)
+		goto out;
+
+	buf = kmalloc(u.len, GFP_KERNEL);
+	if (!buf)
+		goto out;
+
+	switch (request) {
+	case DEP_COPY_FROM_USER:
+		copy_from_user(buf, (const void __user *) u.addr, u.len);
+
+		error = comm_send(p->om.contact, buf, u.len);
+		if (error < 0)
+			goto out;
+		break;
+	case DEP_COPY_TO_USER:
+		error = comm_recv(p->om.contact, buf, u.len);
+		if (error < 0)
+			goto out;
+
+		copy_to_user((void __user *) u.addr, buf, u.len);
+		break;
+	}
+out:
+	kfree(buf);
+	return error;
+}
+
+/**
+ * remote_strncpy_from_user - strncpy from user for deputy
+ **/
+static int remote_strncpy_from_user(task_t *p)
+{
+	struct omp_usercopy_req u;
+	void *buf = NULL; 
+	int error;
+
+	error = comm_recv(p->om.contact, &u, sizeof(u));
+	if (error < 0)
+		goto out;
+
+	buf = kmalloc(u.len, GFP_KERNEL);
+	if (!buf)
+		goto out;
+
+	strncpy_from_user(buf, (const char __user *) u.addr, u.len);
+
+	error = comm_send(p->om.contact, buf, u.len);
+	if (error < 0)
+		goto out;
+
+out:
+	kfree(buf);
+	return error;
+}
+
+/**
+ * remote_strnlen_from_user - strnlen from user for deputy
+ **/
+static int remote_strnlen_user(task_t *p)
+{
+	struct omp_usercopy_req u;
+	long ret;
+	int error;
+
+	error = comm_recv(p->om.contact, &u, sizeof(u));
+	if (error < 0)
+		goto out;
+
+	ret = (u.len)
+		? strnlen_user((const char __user *) u.addr, u.len)
+		: strlen_user((const char __user *) u.addr);
+
+	error = comm_send(p->om.contact, &ret, sizeof(ret));
+	if (error < 0)
+		goto out;
+out:
+	return error;
+}
+
+/**
+ * remote_put_user - put user for deputy
+ **/
+static int remote_put_user(task_t *p)
+{
+	struct omp_usercopy_emb u;
+	long ret;
+	int error;
+
+	error = comm_recv(p->om.contact, &u, sizeof(u));
+	if (error < 0)
+		goto out;
+
+	switch (u.len) {
+	case 1: ret = put_user(u.val, (u8 *) u.addr); break;
+	case 2: ret = put_user(u.val, (u16 *) u.addr); break;
+	case 4: ret = put_user(u.val, (u32 *) u.addr); break;
+	case 8: ret = put_user(u.val, (u64 *) u.addr); break;
+	default: ret = -EFAULT;
+	}
+	return ret;
+out:
+	return error;
+}
+
+/**
+ * remote_get_user - get user for deputy
+ **/
+static int remote_get_user(task_t *p)
+{
+	struct omp_usercopy_req u;
+	s64 ret;
+	int error;
+
+	error = comm_recv(p->om.contact, &u, sizeof(u));
+	if (error < 0)
+		goto out;
+
+	switch (u.len) {
+	case 1: get_user(ret, (u8 *) u.addr); break;
+	case 2: get_user(ret, (u16 *) u.addr); break;
+	case 4: get_user(ret, (u32 *) u.addr); break;
+#if BITS_PER_LONG == 64
+	case 8: get_user(ret, (u64 *) u.addr); break;
+#endif
+	}
+
+	error = comm_send(p->om.contact, &ret, sizeof(ret));
+	if (error < 0)
+		goto out;
+out:
+	return error;
+}
+
+
+/**
+ * remote_handle_user - Handle user copy until receiving @endtype
+ **/
+static inline int remote_handle_user(task_t *p, int endtype)
+{
+	struct omp_req req;
+	int ret = 1;
+	int error;
+
+	while (ret != 0) {
+		error = comm_recv(p->om.contact, &req, sizeof(req));
+		if (error < 0)
+			return error;
+		if (req.type == endtype) {
+			ret = 0;
+			break;
+		}
+
+		switch (req.type) {
+		case DEP_COPY_FROM_USER:
+		case DEP_COPY_TO_USER:
+			remote_copy_user(p, req.type);
+			break;
+		case DEP_STRNCPY_FROM_USER:
+			remote_strncpy_from_user(p);
+			break;
+		case DEP_STRNLEN_USER:
+			remote_strnlen_user(p);
+			break;
+		case DEP_PUT_USER:
+			remote_put_user(p);
+			break;
+		case DEP_GET_USER:
+			remote_get_user(p);
+			break;
+		default:
+			OMBUG("unexpected type [%x]\n", req.type);
+			remote_disappear();
+			break;
+		}
+	}
+	return ret;
+}
+
+
+/**
+ * remote_do_syscall - process a remote syscall
+ * @n:		the syscall number
+ * @regs:	userspace registers
+ **/
+long remote_do_syscall(int n, struct pt_regs *regs)
+{
+	task_t *p = current;
+	struct omp_syscall_req s;
+	struct omp_syscall_ret r;
+	int error, i;
+
+	OMDEBUG_SYS(1, "[remote] remote syscall %d\n", n);
+
+	s.n = n;
+	for (i = 0; i < NR_MAX_SYSCALL_ARG; i++)
+		s.arg[i] = arch_get_sys_arg(i, regs);
+
+	error = comm_send_hd(p->om.contact, REM_SYSCALL, &s, sizeof(s));
+	if (error < 0)
+		goto error;
+
+	OMDEBUG_SYS(3, "[remote] waiting deputy answer\n");
+	
+	error = remote_handle_user(p, REM_SYSCALL|REPLY);
+	if (error < 0)
+		goto error;
+
+	error = comm_recv(p->om.contact, &r, sizeof(r));
+	if (error < 0)
+		goto error;
+
+	OMDEBUG_SYS(2, "[remote] sys[%d] = %ld\n", n, r.ret);
+
+	return r.ret;
+error:
+	remote_disappear();
+	return -1;
+}
+
+/**
+ * remote_do_fork - Fork a process on remote
+ **/
+long remote_do_fork(unsigned long clone_flags, unsigned long stack_start,
+	      struct pt_regs *regs, unsigned long stack_size,
+	      int __user *parent_tidptr, int __user *child_tidptr)
+{
+	task_t *child;
+	om_link_t *childsock;
+	struct omp_fork_req m;
+	struct omp_fork_ret r;
+	int error, ret;
+	struct sockaddr sa;
+
+	printk(KERN_ERR "[REMOTE] do_fork\n");
+
+	sockaddr_inherit(current->om.contact, &sa);
+
+	m.clone_flags = clone_flags;
+	m.stack_start = stack_start;
+	m.stack_size = stack_size;
+	memcpy(&m.regs, regs, sizeof(struct pt_regs));
+
+	childsock = comm_setup_listen(&sa);
+	if (!childsock)
+		goto fail;
+	
+	if (comm_getname(childsock, &sa) < 0)
+		goto fail;
+
+	memcpy(&m.sockaddr, &sa, sizeof(struct sockaddr));
+	
+	error = comm_send_hd(current->om.contact, REM_FORK, &m, sizeof(m));
+	if (error < 0)
+		goto fail;
+
+	ret = remote_wait(current, REM_FORK | REPLY, &r, sizeof(r));
+	if (ret < 0)
+		goto fail;
+	ret = do_fork(clone_flags, stack_start, regs, stack_size, parent_tidptr,
+								child_tidptr);
+	child = find_task_by_pid(ret);
+	if (!child) {
+		printk(KERN_ERR "error: child %d not found\n", r.pid);
+		return -1;
+	}
+	task_set_comm(child, childsock);
+	
+	return ret;
+fail:
+	OMBUG("failed\n");
+	return -1;
+}
+
+/*
+ * this is a copy of count in fs/exec.c
+ */
+static int count(char __user * __user * argv, int max)
+{
+	int i = 0;
+
+	if (argv != NULL) {
+		for (;;) {
+			char __user * p;
+
+			if (get_user(p, argv))
+				return -EFAULT;
+			if (!p)
+				break;
+			argv++;
+			if(++i > max)
+				return -E2BIG;
+		}
+	}
+	return i;
+}
+
+/**
+ * remote_do_execve - do an execve syscall
+ **/
+long remote_do_execve(char __user * filename, char __user *__user *argv,
+		char __user *__user *envp, struct pt_regs * regs)
+{
+	struct omp_execve_req m;
+	int error;
+
+	m.p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);
+	m.filename = filename;
+	m.filelen = strlen_user(filename);
+
+	error = m.argc = count(argv, m.p / sizeof(void *));
+	if (error < 0)
+		goto error;
+
+	error = m.envc = count(envp, m.p / sizeof(void *));
+	if (error < 0)
+		goto error;
+	
+	memcpy(&m.regs, regs, sizeof(struct pt_regs));
+
+	error = comm_send_hd(current->om.contact, REM_EXECVE, &m, sizeof(m));
+	if (error < 0)
+		goto error;
+	
+	return 0;
+error:
+	return error;
+}
diff -Naur linux-2.6.11/hpc/service.c linux-2.6.11-om/hpc/service.c
--- linux-2.6.11/hpc/service.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/service.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,158 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <hpc/comm.h>
+#include <hpc/comm-ipv4.h>
+#include <hpc/comm-ipv6.h>
+#include <hpc/service.h>
+#include <hpc/task.h>
+#include <hpc/arch.h>
+
+/**
+ * om_daemonize - create an oM daemon
+ * @name:	kernel thread name
+ * @highpri:	is this kernel thread high priority
+ *
+ * Description:
+ * 	Create a kernel thread, and set priority.
+ * 	SCHED_FIFO for high priority, hence stay for realtime
+ **/
+void om_daemonize(char *name, int highpri)
+{
+	task_t *p = current;
+
+	daemonize(name);
+	p->it_real_incr = 0;
+	p->it_prof_incr = 0;
+	p->it_virt_incr = 0;
+	p->it_real_value = 0;
+	p->it_prof_value = 0;
+	p->it_virt_value = 0;
+
+	p->euid = 0;
+	p->suid = 0;
+	p->gid = 0;
+	p->group_info = groups_alloc(0);
+
+	/* clean blocked signal set */
+	spin_lock_irq(&p->sighand->siglock);
+	sigemptyset(&p->blocked);
+	recalc_sigpending_tsk(p);
+	spin_unlock_irq(&p->sighand->siglock);
+
+	/* set priority and stay reason of the task */
+	task_lock(p);
+	if (highpri)
+	{
+		p->policy = SCHED_FIFO;
+		task_set_stay(p, DSTAY_RT);
+		p->rt_priority = 0;
+	}
+	else
+	{
+		p->policy = SCHED_NORMAL;
+		task_clear_stay(p, DSTAY_RT);
+		set_user_nice(p, 0);
+	}
+	task_set_stay(p, DSTAY_SYSTEM);
+	task_unlock(p);
+}
+
+/**
+ * sockaddr_to_string - write an net address to a buffer returning length
+ **/
+int sockaddr_to_string(struct sockaddr *address, char *buf)
+{
+	switch (address->sa_family) {
+	case AF_INET:
+		return inet_to_string((struct sockaddr_in *) address, buf);
+	case AF_INET6:
+		return inet6_to_string((struct sockaddr_in6 *) address, buf);
+	}
+	printk(KERN_ERR "oM: network type not supported\n");
+	return 0;
+}
+
+
+/**
+ * string_to_sockaddr - convert a buffer, to a sockaddr
+ **/
+int string_to_sockaddr(char *buf, struct sockaddr *address)
+{
+	int l;
+	
+	address->sa_family = 0;
+	/* try to parse an ipv4 */
+	l = string_to_inet(buf, (struct sockaddr_in *) address);
+	if (l > 0)
+		return l;
+	/* try to parse an ipv6 */
+	l = string_to_inet6(buf, (struct sockaddr_in6 *) address);
+	if (l > 0)
+		return l;
+	return 0;
+}
+
+/**
+ * sockaddr_setup - configure a socket address
+ **/
+void sockaddr_setup_port(struct sockaddr *sa, int port)
+{
+	switch (sa->sa_family) {
+	case AF_INET:
+		inet_setup_port((struct sockaddr_in *) sa, port);
+		break;
+	case AF_INET6:
+		inet6_setup_port((struct sockaddr_in6 *) sa, port);
+		break;
+	}
+}
+
+/**
+ * sockaddr_inherit - fullfill sa with the same type of mlink
+ **/
+int sockaddr_inherit(om_link_t *mlink, struct sockaddr *sa)
+{
+	struct sockaddr tmp;
+	
+	if (comm_getname(mlink, &tmp) < 0)
+		return -1;
+
+	memset(sa, 0, sizeof(struct sockaddr));
+	sa->sa_family = tmp.sa_family;
+
+	switch (tmp.sa_family) {
+		case AF_INET: {
+			struct sockaddr_in *in = (struct sockaddr_in *) sa;
+			in->sin_addr.s_addr = INADDR_ANY;
+			break;
+		}
+		case AF_INET6: {
+			struct sockaddr_in6 *in6 = (struct sockaddr_in6 *) sa;
+			memset(&in6->sin6_addr, 0, sizeof(struct in6_addr));
+			break;
+		}
+	}
+	return 0;
+}
diff -Naur linux-2.6.11/hpc/syscalls.c linux-2.6.11-om/hpc/syscalls.c
--- linux-2.6.11/hpc/syscalls.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/syscalls.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,55 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/syscalls.h>
+#include <linux/types.h>
+#include <asm/ptrace.h>
+#include <asm/unistd.h>
+#include <hpc/prototype.h>
+#include <hpc/arch.h>
+#include <hpc/syscalls.h>
+#include <hpc/debug.h>
+#include <hpc/hpc.h>
+
+/* generic multiplexer */
+asmlinkage long om_sys_local(struct pt_regs regs)
+{
+	long ret;
+
+	OMDEBUG_SYS(1, "[remote] local syscall %d\n", SYSNB());
+	
+	ret = arch_exec_syscall(SYSNB(), (syscall_parameter_t *) &regs);
+	return ret;
+}
+
+asmlinkage long om_sys_remote(struct pt_regs regs)
+{
+	return remote_do_syscall(SYSNB(), &regs);
+}
+
+/* specific remote syscalls */
+asmlinkage int om_sys_gettid(struct pt_regs regs)
+{
+	return current->om.pid;
+}
+
+asmlinkage int om_sys_getpid(struct pt_regs regs)
+{
+	return current->om.tgid;
+}
diff -Naur linux-2.6.11/hpc/task.c linux-2.6.11-om/hpc/task.c
--- linux-2.6.11/hpc/task.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/hpc/task.c	2005-05-15 23:18:04.000000000 +0200
@@ -0,0 +1,221 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/socket.h>
+#include <net/sock.h>
+#include <hpc/task.h>
+#include <hpc/comm.h>
+#include <hpc/mig.h>
+#include <hpc/prototype.h>
+#include <hpc/hpc.h>
+
+/**
+ * task_set_comm - swap openMosix link for a process (return old one)
+ * @p:		task to swap link
+ * @mlink:	new openMosix link
+ *
+ * Description:
+ * 	Remove old link from task @p
+ * 	Set @p openmosix_link to the new one @mlink
+ **/
+om_link_t * task_set_comm(task_t *p, om_link_t *mlink)
+{
+	om_link_t *oldmlink;
+
+	oldmlink = p->om.contact;
+	p->om.contact = mlink;
+
+	if (mlink && test_bit(SOCK_OOB_IN, &mlink->sock->flags))
+		task_set_dreqs(p, DREQ_URGENT);
+	return oldmlink;
+}
+
+/**
+ * task_file_check_stay - check if task should stay because of file mapping
+ **/
+static int task_file_check_stay(struct vm_area_struct *vma)
+{
+	struct inode *inode;
+	mode_t mode;
+	int stay = 0;
+
+	inode = vma->vm_file->f_dentry->d_inode;
+	if (!inode)
+		return 0;
+
+	mode = inode->i_mode;
+
+	/* FIXME Tab: maybe wrong */
+	if (!(vma->vm_flags & VM_NONLINEAR)) {
+		if (!prio_tree_empty(&inode->i_mapping->i_mmap))
+			stay |= DSTAY_MONKEY;
+	} else {
+		if (!list_empty(&vma->shared.vm_set.list))
+			stay |= DSTAY_MONKEY;
+	}
+	if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))
+		stay |= DSTAY_DEV;
+
+	return stay;
+}
+
+/**
+ * task_request_checkstay - adjust stay reason of a task (considering mm)
+ **/
+void task_request_checkstay(task_t *p)
+{
+	struct mm_struct *mm;
+	int stay;
+	struct vm_area_struct *vma;
+	
+	task_clear_dreqs(p, DREQ_CHECKSTAY);
+
+	printk(KERN_ERR "oM: [%d] do_request: DREQ_CHECKSTAY\n", p->pid);
+
+	/* check if there's a stay reason we can clean, else pass */
+	if (!task_test_stay(p, DSTAY_PER_MM | DSTAY_CLONE))
+		return;
+
+	task_lock(p);
+	mm = p->mm;
+	stay = p->om.stay & ~(DSTAY_PER_MM | DSTAY_CLONE);
+	if (!mm)
+		stay |= DSTAY_CLONE;
+	else {
+		/* FIXME: need verifying KIOBUF */
+		if (atomic_read(&mm->mm_realusers) > 1)
+			stay |= DSTAY_CLONE;
+		if (mm->def_flags & VM_LOCKED)
+			stay |= DSTAY_MLOCK;
+
+		for (vma = mm->mmap; vma; vma = vma->vm_next)
+		{
+			if (vma->vm_file)
+				stay |= task_file_check_stay(vma);
+			if (vma->vm_flags & VM_LOCKED)
+				stay |= DSTAY_MLOCK;
+		}
+	}
+	if (p->om.stay != stay)
+		p->om.stay = stay;
+	task_unlock(p);
+	return;
+}
+
+/**
+ * task_request_move - move a task
+ **/
+void task_request_move(task_t *p)
+{
+	struct sockaddr *addr;
+
+	task_clear_dreqs(p, DREQ_MOVE);
+	addr = p->om.whereto;
+	p->om.whereto = NULL;
+	
+	task_move_to_node(p, addr, 0);
+	kfree(addr);
+}
+
+/**
+ * openmosix_task_init - Init all openMosix structure of a task @p
+ **/
+int openmosix_task_init(task_t *p)
+{
+	task_t *parent = current;
+
+	memset(&p->om, 0, sizeof(om_task_t));
+	
+	if (p->pid == 1)
+		task_set_stay(p, DSTAY_SYSTEM);
+
+	/* if father of task is a DREMOTEDAEMON, then the task is DREMOTE */
+	if (task_test_dflags(parent, DREMOTEDAEMON))
+		task_set_dflags(p, DREMOTE);
+	/* child of a DDEPUTY is a DDEPUTY */
+	if (task_test_dflags(parent, DDEPUTY))
+		task_set_dflags(p, DDEPUTY);
+
+	INIT_LIST_HEAD(&p->om.rfiles);
+	
+	return 0;
+}
+
+/**
+ * openmosix_task_exit - Exit current task
+ **/
+int openmosix_task_exit(void)
+{
+	task_t *p = current;
+	
+	if (!task_test_dflags(p, DDEPUTY | DREMOTE))
+		return 0;
+
+	task_heldfiles_clear(p);
+	
+	comm_close(p->om.contact);
+	return 0;
+}
+
+/**
+ * task_wait_contact - wait until the process got a contact with deputy
+ **/
+static inline void task_wait_contact(task_t *p)
+{
+	DECLARE_WAITQUEUE(wait, p);
+
+	add_wait_queue(&p->om.wait_dist, &wait);
+	while (!p->om.contact)
+	{
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule();
+	}
+	remove_wait_queue(&p->om.wait_dist, &wait);
+	set_current_state(TASK_RUNNING);
+}
+
+/**
+ * task_register_migration - register a migration for this process
+ * @p:		task to migrate
+ * @dest:	destination of the migration (NULL == home)
+ **/
+int task_register_migration(task_t *p, struct sockaddr *dest)
+{
+	if (dest) {
+		p->om.whereto = kmalloc(sizeof(struct sockaddr), GFP_KERNEL);
+		if (!p->om.whereto)
+			return -1;
+		memcpy(p->om.whereto, dest, sizeof(struct sockaddr));
+	}
+	task_set_dreqs(p, DREQ_MOVE);
+	wake_up_process(p);
+	set_ti_thread_flag(p->thread_info, TIF_NEED_RESCHED);
+	return 0;
+}
+
+/**
+ * task_do_request - current task processes requests coming from other tasks
+ **/
+void task_do_request(void)
+{
+	if (task_test_dreqs(current, DREQ_MOVE))
+		task_request_move(current);
+	if (task_test_dreqs(current, DREQ_CHECKSTAY))
+		task_request_checkstay(current);
+}
diff -Naur linux-2.6.11/include/asm-i386/bugs.h linux-2.6.11-om/include/asm-i386/bugs.h
--- linux-2.6.11/include/asm-i386/bugs.h	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/include/asm-i386/bugs.h	2005-05-15 23:18:03.000000000 +0200
@@ -1,11 +1,11 @@
 /*
  *  include/asm-i386/bugs.h
  *
- *  Copyright (C) 1994  Linus Torvalds
+ *  Copyright (C) 1994	Linus Torvalds
  *
  *  Cyrix stuff, June 1998 by:
  *	- Rafael R. Reilova (moved everything from head.S),
- *        <rreilova@ececs.uc.edu>
+ *	  <rreilova@ececs.uc.edu>
  *	- Channing Corn (tests & fixes),
  *	- Andrew D. Balsa (code cleanup).
  *
@@ -25,7 +25,20 @@
 #include <asm/processor.h>
 #include <asm/i387.h>
 #include <asm/msr.h>
-
+#ifdef CONFIG_KGDB
+/*
+ * Provied the command line "gdb" initial break
+ */
+int __init kgdb_initial_break(char * str)
+{
+	if (*str == '\0'){
+		breakpoint();
+		return 1;
+	}
+	return 0;
+}
+__setup("gdb",kgdb_initial_break);
+#endif
 static int __init no_halt(char *s)
 {
 	boot_cpu_data.hlt_works_ok = 0;
@@ -140,7 +153,7 @@
 	  : "ecx", "edi" );
 	/* If this fails, it means that any user program may lock the CPU hard. Too bad. */
 	if (res != 12345678) printk( "Buggy.\n" );
-		        else printk( "OK.\n" );
+			else printk( "OK.\n" );
 #endif
 }
 
diff -Naur linux-2.6.11/include/asm-i386/kgdb.h linux-2.6.11-om/include/asm-i386/kgdb.h
--- linux-2.6.11/include/asm-i386/kgdb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/asm-i386/kgdb.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,69 @@
+#ifndef __KGDB
+#define __KGDB
+
+/*
+ * This file should not include ANY others.  This makes it usable
+ * most anywhere without the fear of include order or inclusion.
+ * Make it so!
+ *
+ * This file may be included all the time.  It is only active if
+ * CONFIG_KGDB is defined, otherwise it stubs out all the macros
+ * and entry points.
+ */
+#if defined(CONFIG_KGDB) && !defined(__ASSEMBLY__)
+
+extern void breakpoint(void);
+#define INIT_KGDB_INTS kgdb_enable_ints()
+
+#ifndef BREAKPOINT
+#define BREAKPOINT   asm("   int $3")
+#endif
+
+extern void kgdb_schedule_breakpoint(void);
+extern void kgdb_process_breakpoint(void);
+
+extern int kgdb_tty_hook(void);
+extern int kgdb_eth_hook(void);
+extern int kgdboe;
+
+/*
+ * GDB debug stub (or any debug stub) can point the 'linux_debug_hook'
+ * pointer to its routine and it will be entered as the first thing
+ * when a trap occurs.
+ *
+ * Return values are, at present, undefined.
+ *
+ * The debug hook routine does not necessarily return to its caller.
+ * It has the register image and thus may choose to resume execution
+ * anywhere it pleases.
+ */
+struct pt_regs;
+
+extern int kgdb_handle_exception(int trapno,
+				 int signo, int err_code, struct pt_regs *regs);
+extern int in_kgdb(struct pt_regs *regs);
+
+#ifdef CONFIG_KGDB_TS
+void kgdb_tstamp(int line, char *source, int data0, int data1);
+/*
+ * This is the time stamp function.  The macro adds the source info and
+ * does a cast on the data to allow most any 32-bit value.
+ */
+
+#define kgdb_ts(data0,data1) kgdb_tstamp(__LINE__,__FILE__,(int)data0,(int)data1)
+#else
+#define kgdb_ts(data0,data1)
+#endif
+#else				/* CONFIG_KGDB  && ! __ASSEMBLY__ ,stubs follow... */
+#ifndef BREAKPOINT
+#define BREAKPOINT
+#endif
+#define kgdb_ts(data0,data1)
+#define in_kgdb
+#define kgdb_handle_exception
+#define breakpoint
+#define INIT_KGDB_INTS
+#define kgdb_process_breakpoint() do {} while(0)
+
+#endif
+#endif				/* __KGDB */
diff -Naur linux-2.6.11/include/asm-i386/kgdb_local.h linux-2.6.11-om/include/asm-i386/kgdb_local.h
--- linux-2.6.11/include/asm-i386/kgdb_local.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/asm-i386/kgdb_local.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,102 @@
+#ifndef __KGDB_LOCAL
+#define ___KGDB_LOCAL
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/spinlock.h>
+#include <asm/processor.h>
+#include <asm/msr.h>
+#include <asm/kgdb.h>
+
+#define PORT 0x3f8
+#ifdef CONFIG_KGDB_PORT
+#undef PORT
+#define PORT CONFIG_KGDB_PORT
+#endif
+#define IRQ 4
+#ifdef CONFIG_KGDB_IRQ
+#undef IRQ
+#define IRQ CONFIG_KGDB_IRQ
+#endif
+#define SB_CLOCK 1843200
+#define SB_BASE (SB_CLOCK/16)
+#define SB_BAUD9600 SB_BASE/9600
+#define SB_BAUD192  SB_BASE/19200
+#define SB_BAUD384  SB_BASE/38400
+#define SB_BAUD576  SB_BASE/57600
+#define SB_BAUD1152 SB_BASE/115200
+#ifdef CONFIG_KGDB_9600BAUD
+#define SB_BAUD SB_BAUD9600
+#endif
+#ifdef CONFIG_KGDB_19200BAUD
+#define SB_BAUD SB_BAUD192
+#endif
+#ifdef CONFIG_KGDB_38400BAUD
+#define SB_BAUD SB_BAUD384
+#endif
+#ifdef CONFIG_KGDB_57600BAUD
+#define SB_BAUD SB_BAUD576
+#endif
+#ifdef CONFIG_KGDB_115200BAUD
+#define SB_BAUD SB_BAUD1152
+#endif
+#ifndef SB_BAUD
+#define SB_BAUD SB_BAUD1152	/* Start with this if not given */
+#endif
+
+#ifndef CONFIG_X86_TSC
+#undef rdtsc
+#define rdtsc(a,b) if (a++ > 10000){a = 0; b++;}
+#undef rdtscll
+#define rdtscll(s) s++
+#endif
+
+#ifdef _raw_read_unlock		/* must use a name that is "define"ed, not an inline */
+#undef spin_lock
+#undef spin_trylock
+#undef spin_unlock
+#define spin_lock	 _raw_spin_lock
+#define spin_trylock	 _raw_spin_trylock
+#define spin_unlock	 _raw_spin_unlock
+#else
+#endif
+#undef spin_unlock_wait
+#define spin_unlock_wait(x)  do { cpu_relax(); barrier();} \
+                                     while(spin_is_locked(x))
+
+#define SB_IER 1
+#define SB_MCR UART_MCR_OUT2 | UART_MCR_DTR | UART_MCR_RTS
+
+#define FLAGS 0
+#define SB_STATE { \
+     magic: SSTATE_MAGIC, \
+     baud_base: SB_BASE,  \
+     port:      PORT,     \
+     irq:       IRQ,      \
+     flags:     FLAGS,    \
+     custom_divisor:SB_BAUD}
+#define SB_INFO  { \
+      magic: SERIAL_MAGIC, \
+      port:  PORT,0,FLAGS, \
+      state: &state,       \
+      tty:   (struct tty_struct *)&state, \
+      IER:   SB_IER,       \
+      MCR:   SB_MCR}
+extern void putDebugChar(int);
+/* RTAI support needs us to really stop/start interrupts */
+
+#define kgdb_sti() __asm__ __volatile__("sti": : :"memory")
+#define kgdb_cli() __asm__ __volatile__("cli": : :"memory")
+#define kgdb_local_save_flags(x) __asm__ __volatile__(\
+                                   "pushfl ; popl %0":"=g" (x): /* no input */)
+#define kgdb_local_irq_restore(x) __asm__ __volatile__(\
+                                   "pushl %0 ; popfl": \
+                                     /* no output */ :"g" (x):"memory", "cc")
+#define kgdb_local_irq_save(x) kgdb_local_save_flags(x); kgdb_cli()
+
+#ifdef CONFIG_SERIAL
+extern void shutdown_for_kgdb(struct async_struct *info);
+#endif
+#define INIT_KDEBUG putDebugChar("+");
+#endif				/* __KGDB_LOCAL */
diff -Naur linux-2.6.11/include/asm-i386/uaccess.h linux-2.6.11-om/include/asm-i386/uaccess.h
--- linux-2.6.11/include/asm-i386/uaccess.h	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/include/asm-i386/uaccess.h	2005-05-15 23:18:03.000000000 +0200
@@ -34,6 +34,8 @@
 
 #define segment_eq(a,b)	((a).seg == (b).seg)
 
+#include <hpc/uaccess.h>
+
 /*
  * movsl can be slow when source and dest are not both 8-byte aligned
  */
@@ -173,6 +175,10 @@
 ({	int __ret_gu;							\
 	unsigned long __val_gu;						\
 	__chk_user_ptr(ptr);						\
+ 	if (openmosix_memory_away()) {					\
+ 		__ret_gu = deputy_get_user((long *) &__val_gu, ptr,	\
+						sizeof (*(ptr)));	\
+ 	} else 								\
 	switch(sizeof (*(ptr))) {					\
 	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
 	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
@@ -204,7 +210,6 @@
 #define put_user(x,ptr)							\
   __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
 
-
 /**
  * __get_user: - Get a simple variable from user space, with less checking.
  * @x:   Variable to store result.
@@ -286,12 +291,32 @@
 		: "=r"(err)					\
 		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err))
 
-#ifdef CONFIG_X86_WP_WORKS_OK
+#ifdef CONFIG_OPENMOSIX
+#define deputy_put_user64_helper(x, addr, ret)			\
+	__asm__ __volatile__(					\
+		"1: pushl %%eax\n"				\
+		"pushl %%edx\n"					\
+		"pushl %2\n"					\
+		"call deputy_put_user64\n"			\
+		"movl %%eax, %0\n"				\
+		"popl %%edx\n"					\
+		"popl %%eax\n"					\
+		: "=r"(ret)					\
+		: "A" (x), "r" (addr), "0"(ret))
+#endif
 
+#ifdef CONFIG_X86_WP_WORKS_OK
 #define __put_user_size(x,ptr,size,retval,errret)			\
 do {									\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
+	if (openmosix_memory_away() && size <= 8) {			\
+		if (size < 8)						\
+			retval = deputy_put_user((long) x, ptr, size);	\
+		else							\
+			deputy_put_user64_helper((__typeof__(*ptr))(x),	\
+						ptr, retval);		\
+	} else								\
 	switch (size) {							\
 	case 1: __put_user_asm(x,ptr,retval,"b","b","iq",errret);break;	\
 	case 2: __put_user_asm(x,ptr,retval,"w","w","ir",errret);break; \
@@ -308,6 +333,13 @@
 	__typeof__(*(ptr)) __pus_tmp = x;				\
 	retval = 0;							\
 									\
+	if (openmosix_memory_away() && size <= 8)			\
+		if (size < 8)						\
+			retval = deputy_put_user((long) x, ptr, size);	\
+		else							\
+			deputy_put_user64_helper((__typeof__(*ptr))(x),	\
+						ptr, retval);		\
+	else								\
 	if(unlikely(__copy_to_user_ll(ptr, &__pus_tmp, size) != 0))	\
 		retval = errret;					\
 } while (0)
@@ -352,6 +384,9 @@
 do {									\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
+ 	if (openmosix_memory_away()) {					\
+ 		retval = deputy_get_user((long *) &x, ptr, size);	\
+ 	} else 								\
 	switch (size) {							\
 	case 1: __get_user_asm(x,ptr,retval,"b","b","=q",errret);break;	\
 	case 2: __get_user_asm(x,ptr,retval,"w","w","=r",errret);break;	\
@@ -406,6 +441,10 @@
 static inline unsigned long __must_check
 __copy_to_user_inatomic(void __user *to, const void *from, unsigned long n)
 {
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_copy_to_user(to, from, n);
+#endif
 	if (__builtin_constant_p(n)) {
 		unsigned long ret;
 
@@ -451,6 +490,10 @@
 static inline unsigned long
 __copy_from_user_inatomic(void *to, const void __user *from, unsigned long n)
 {
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_copy_from_user(to, from, n);
+#endif
 	if (__builtin_constant_p(n)) {
 		unsigned long ret;
 
@@ -498,7 +541,15 @@
  * If there is a limit on the length of a valid string, you may wish to
  * consider using strnlen_user() instead.
  */
-#define strlen_user(str) strnlen_user(str, ~0UL >> 1)
+#define strlen_user_local(str) strnlen_user(str, ~0UL >> 1)
+
+#ifdef CONFIG_OPENMOSIX
+#define strlen_user(str) (openmosix_memory_away())			\
+				? deputy_strnlen_user(str, 0)		\
+				: strlen_user_local(str)
+#else
+#define strlen_user(str) strlen_user_local(str)
+#endif
 
 long strnlen_user(const char __user *str, long n);
 unsigned long __must_check clear_user(void __user *mem, unsigned long len);
diff -Naur linux-2.6.11/include/asm-ppc/atomic.h linux-2.6.11-om/include/asm-ppc/atomic.h
--- linux-2.6.11/include/asm-ppc/atomic.h	2005-03-02 08:37:50.000000000 +0100
+++ linux-2.6.11-om/include/asm-ppc/atomic.h	2005-05-15 23:18:03.000000000 +0200
@@ -14,7 +14,8 @@
 #define atomic_read(v)		((v)->counter)
 #define atomic_set(v,i)		(((v)->counter) = (i))
 
-extern void atomic_clear_mask(unsigned long mask, unsigned long *addr);
+extern void atomic_clear_mask(unsigned long mask, atomic_t *addr);
+extern void atomic_set_mask(unsigned long mask, atomic_t *addr);
 
 #ifdef CONFIG_SMP
 #define SMP_SYNC	"sync"
diff -Naur linux-2.6.11/include/asm-ppc/uaccess.h linux-2.6.11-om/include/asm-ppc/uaccess.h
--- linux-2.6.11/include/asm-ppc/uaccess.h	2005-03-02 08:37:31.000000000 +0100
+++ linux-2.6.11-om/include/asm-ppc/uaccess.h	2005-05-15 23:18:03.000000000 +0200
@@ -37,6 +37,8 @@
 #define access_ok(type, addr, size) \
 	(__chk_user_ptr(addr),__access_ok((unsigned long)(addr),(size)))
 
+#include <hpc/uaccess.h>
+
 extern inline int verify_area(int type, const void __user * addr, unsigned long size)
 {
 	return access_ok(type, addr, size) ? 0 : -EFAULT;
@@ -123,6 +125,9 @@
 #define __put_user_size(x,ptr,size,retval)		\
 do {							\
 	retval = 0;					\
+	if (openmosix_memory_away())			\
+		retval = deputy_put_user((long) x, ptr, size); \
+	else						\
 	switch (size) {					\
 	case 1:						\
 		__put_user_asm(x, ptr, retval, "stb");	\
@@ -225,6 +230,9 @@
 #define __get_user_size(x, ptr, size, retval)			\
 do {								\
 	retval = 0;						\
+ 	if (size <= 4 && openmosix_memory_away())		\
+ 		retval = deputy_get_user((long *) &x, ptr, size); \
+ 	else 							\
 	switch (size) {						\
 	case 1:							\
 		__get_user_asm(x, ptr, retval, "lbz");		\
@@ -243,6 +251,11 @@
 #define __get_user_size64(x, ptr, size, retval)			\
 do {								\
 	retval = 0;						\
+ 	if (size <= 8 && openmosix_memory_away())		\
+		retval = (size == 8)				\
+			? deputy_copy_from_user(&x, ptr, size);	\
+ 			: deputy_get_user((long *) &x, ptr, size); \
+ 	else 							\
 	switch (size) {						\
 	case 1:							\
 		__get_user_asm(x, ptr, retval, "lbz");		\
@@ -310,6 +323,11 @@
 		return __copy_tofrom_user((__force void __user *)to, from, n);
 	if ((unsigned long)from < TASK_SIZE) {
 		over = (unsigned long)from + n - TASK_SIZE;
+#ifdef CONFIG_OPENMOSIX
+		if (openmosix_memory_away())
+			return deputy_copy_from_user(to, from, n - over) + over;
+		else
+#endif
 		return __copy_tofrom_user((__force void __user *)to, from, n - over) + over;
 	}
 	return n;
@@ -324,6 +342,11 @@
 		return __copy_tofrom_user(to, (__force void __user *) from, n);
 	if ((unsigned long)to < TASK_SIZE) {
 		over = (unsigned long)to + n - TASK_SIZE;
+#ifdef CONFIG_OPENMOSIX
+		if (openmosix_memory_away())
+			return deputy_copy_to_user(to, from, n - over) + over;
+		else
+#endif
 		return __copy_tofrom_user(to, (__force void __user *) from, n - over) + over;
 	}
 	return n;
@@ -361,8 +384,14 @@
 extern inline long
 strncpy_from_user(char *dst, const char __user *src, long count)
 {
-	if (access_ok(VERIFY_READ, src, 1))
+	if (access_ok(VERIFY_READ, src, 1)) {
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_strncpy_from_user(dst, src, count);
+	else
+#endif
 		return __strncpy_from_user(dst, src, count);
+	}
 	return -EFAULT;
 }
 
@@ -388,6 +417,10 @@
 
 	if ((unsigned long)str > top)
 		return 0;
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_strnlen_user(str, len);
+#endif
 	return __strnlen_user(str, len, top);
 }
 
diff -Naur linux-2.6.11/include/asm-x86_64/kgdb.h linux-2.6.11-om/include/asm-x86_64/kgdb.h
--- linux-2.6.11/include/asm-x86_64/kgdb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/asm-x86_64/kgdb.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,71 @@
+#ifndef __KGDB
+#define __KGDB
+
+/*
+ * This file should not include ANY others.  This makes it usable
+ * most anywhere without the fear of include order or inclusion.
+ * Make it so!
+ *
+ * This file may be included all the time.  It is only active if
+ * CONFIG_KGDB is defined, otherwise it stubs out all the macros
+ * and entry points.
+ */
+#if defined(CONFIG_KGDB) && !defined(__ASSEMBLY__)
+
+extern void breakpoint(void);
+#define INIT_KGDB_INTS kgdb_enable_ints()
+
+#ifndef BREAKPOINT
+#define BREAKPOINT   asm("   int $3")
+#endif
+
+extern void kgdb_schedule_breakpoint(void);
+extern void kgdb_process_breakpoint(void);
+
+extern int kgdb_tty_hook(void);
+extern int kgdb_eth_hook(void);
+extern int kgdboe;
+
+/*
+ * GDB debug stub (or any debug stub) can point the 'linux_debug_hook'
+ * pointer to its routine and it will be entered as the first thing
+ * when a trap occurs.
+ *
+ * Return values are, at present, undefined.
+ *
+ * The debug hook routine does not necessarily return to its caller.
+ * It has the register image and thus may choose to resume execution
+ * anywhere it pleases.
+ */
+struct pt_regs;
+
+extern int kgdb_handle_exception(int trapno,
+				 int signo, int err_code, struct pt_regs *regs);
+extern int in_kgdb(struct pt_regs *regs);
+
+extern void set_debug_traps(void);
+
+#ifdef CONFIG_KGDB_TS
+void kgdb_tstamp(int line, char *source, int data0, int data1);
+/*
+ * This is the time stamp function.  The macro adds the source info and
+ * does a cast on the data to allow most any 32-bit value.
+ */
+
+#define kgdb_ts(data0,data1) kgdb_tstamp(__LINE__,__FILE__,(int)data0,(int)data1)
+#else
+#define kgdb_ts(data0,data1)
+#endif
+#else				/* CONFIG_KGDB  && ! __ASSEMBLY__ ,stubs follow... */
+#ifndef BREAKPOINT
+#define BREAKPOINT
+#endif
+#define kgdb_ts(data0,data1)
+#define in_kgdb	(0)
+#define kgdb_handle_exception
+#define breakpoint
+#define INIT_KGDB_INTS
+#define kgdb_process_breakpoint() do {} while(0)
+
+#endif
+#endif				/* __KGDB */
diff -Naur linux-2.6.11/include/asm-x86_64/kgdb_local.h linux-2.6.11-om/include/asm-x86_64/kgdb_local.h
--- linux-2.6.11/include/asm-x86_64/kgdb_local.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/asm-x86_64/kgdb_local.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,102 @@
+#ifndef __KGDB_LOCAL
+#define ___KGDB_LOCAL
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/spinlock.h>
+#include <asm/processor.h>
+#include <asm/msr.h>
+#include <asm/kgdb.h>
+
+#define PORT 0x3f8
+#ifdef CONFIG_KGDB_PORT
+#undef PORT
+#define PORT CONFIG_KGDB_PORT
+#endif
+#define IRQ 4
+#ifdef CONFIG_KGDB_IRQ
+#undef IRQ
+#define IRQ CONFIG_KGDB_IRQ
+#endif
+#define SB_CLOCK 1843200
+#define SB_BASE (SB_CLOCK/16)
+#define SB_BAUD9600 SB_BASE/9600
+#define SB_BAUD192  SB_BASE/19200
+#define SB_BAUD384  SB_BASE/38400
+#define SB_BAUD576  SB_BASE/57600
+#define SB_BAUD1152 SB_BASE/115200
+#ifdef CONFIG_KGDB_9600BAUD
+#define SB_BAUD SB_BAUD9600
+#endif
+#ifdef CONFIG_KGDB_19200BAUD
+#define SB_BAUD SB_BAUD192
+#endif
+#ifdef CONFIG_KGDB_38400BAUD
+#define SB_BAUD SB_BAUD384
+#endif
+#ifdef CONFIG_KGDB_57600BAUD
+#define SB_BAUD SB_BAUD576
+#endif
+#ifdef CONFIG_KGDB_115200BAUD
+#define SB_BAUD SB_BAUD1152
+#endif
+#ifndef SB_BAUD
+#define SB_BAUD SB_BAUD1152	/* Start with this if not given */
+#endif
+
+#ifndef CONFIG_X86_TSC
+#undef rdtsc
+#define rdtsc(a,b) if (a++ > 10000){a = 0; b++;}
+#undef rdtscll
+#define rdtscll(s) s++
+#endif
+
+#ifdef _raw_read_unlock		/* must use a name that is "define"ed, not an inline */
+#undef spin_lock
+#undef spin_trylock
+#undef spin_unlock
+#define spin_lock	 _raw_spin_lock
+#define spin_trylock	 _raw_spin_trylock
+#define spin_unlock	 _raw_spin_unlock
+#else
+#endif
+#undef spin_unlock_wait
+#define spin_unlock_wait(x)  do { cpu_relax(); barrier();} \
+                                     while(spin_is_locked(x))
+
+#define SB_IER 1
+#define SB_MCR UART_MCR_OUT2 | UART_MCR_DTR | UART_MCR_RTS
+
+#define FLAGS 0
+#define SB_STATE { \
+     magic: SSTATE_MAGIC, \
+     baud_base: SB_BASE,  \
+     port:      PORT,     \
+     irq:       IRQ,      \
+     flags:     FLAGS,    \
+     custom_divisor:SB_BAUD}
+#define SB_INFO  { \
+      magic: SERIAL_MAGIC, \
+      port:  PORT,0,FLAGS, \
+      state: &state,       \
+      tty:   (struct tty_struct *)&state, \
+      IER:   SB_IER,       \
+      MCR:   SB_MCR}
+extern void putDebugChar(int);
+/* RTAI support needs us to really stop/start interrupts */
+
+#define kgdb_sti() __asm__ __volatile__("sti": : :"memory")
+#define kgdb_cli() __asm__ __volatile__("cli": : :"memory")
+#define kgdb_local_save_flags(x) __asm__ __volatile__(\
+                                   "pushfl ; popl %0":"=g" (x): /* no input */)
+#define kgdb_local_irq_restore(x) __asm__ __volatile__(\
+                                   "pushl %0 ; popfl": \
+                                     /* no output */ :"g" (x):"memory", "cc")
+#define kgdb_local_irq_save(x) kgdb_local_save_flags(x); kgdb_cli()
+
+#ifdef CONFIG_SERIAL
+extern void shutdown_for_kgdb(struct async_struct *info);
+#endif
+#define INIT_KDEBUG putDebugChar("+");
+#endif				/* __KGDB_LOCAL */
diff -Naur linux-2.6.11/include/asm-x86_64/uaccess.h linux-2.6.11-om/include/asm-x86_64/uaccess.h
--- linux-2.6.11/include/asm-x86_64/uaccess.h	2005-03-02 08:38:37.000000000 +0100
+++ linux-2.6.11-om/include/asm-x86_64/uaccess.h	2005-05-15 23:18:03.000000000 +0200
@@ -35,6 +35,8 @@
 
 #define __addr_ok(addr) (!((unsigned long)(addr) & (current_thread_info()->addr_limit.seg)))
 
+#include <hpc/uaccess.h>
+
 /*
  * Uhhuh, this needs 65-bit arithmetic. We have a carry..
  */
@@ -105,6 +107,9 @@
 ({	unsigned long __val_gu;						\
 	int __ret_gu; 							\
 	__chk_user_ptr(ptr);						\
+ 	if (openmosix_memory_away()) {					\
+ 		__ret_gu = deputy_get_user(&__val_gu, ptr, sizeof (*(ptr))); \
+ 	} else 								\
 	switch(sizeof (*(ptr))) {					\
 	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
 	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
@@ -161,6 +166,9 @@
 do {									\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
+	if (openmosix_memory_away()) {					\
+		retval = deputy_put_user((long) x, ptr, size);		\
+	} else								\
 	switch (size) {							\
 	  case 1: __put_user_asm(x,ptr,retval,"b","b","iq",-EFAULT); break;\
 	  case 2: __put_user_asm(x,ptr,retval,"w","w","ir",-EFAULT); break;\
@@ -249,6 +257,10 @@
 static inline int __copy_from_user(void *dst, const void __user *src, unsigned size) 
 { 
        int ret = 0;
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_copy_from_user(dst, src, size);
+#endif
 	if (!__builtin_constant_p(size))
 		return copy_user_generic(dst,(__force void *)src,size);
 	switch (size) { 
@@ -278,6 +290,10 @@
 static inline int __copy_to_user(void __user *dst, const void *src, unsigned size) 
 { 
        int ret = 0;
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_copy_to_user(dst, src, size);
+#endif
 	if (!__builtin_constant_p(size))
 		return copy_user_generic((__force void *)dst,src,size);
 	switch (size) { 
diff -Naur linux-2.6.11/include/hpc/arch.h linux-2.6.11-om/include/hpc/arch.h
--- linux-2.6.11/include/hpc/arch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/arch.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_ARCH_H
+#define _HPC_ARCH_H
+
+#include <hpc/protocol.h>
+
+NORET_TYPE void arch_kickstart(struct task_struct *);
+int arch_mig_receive_proc_context(struct task_struct *, struct omp_mig_task *);
+void arch_mig_receive_fp(struct task_struct *, struct omp_mig_fp *);
+int arch_mig_receive_specific(struct task_struct *, struct omp_mig_arch *);
+
+void arch_mig_send_pre(struct task_struct *);
+void arch_mig_send_post(struct task_struct *);
+int arch_mig_send_fp(task_t *p, struct omp_mig_fp *);
+int arch_mig_send_proc_context(struct task_struct *, struct omp_mig_task *);
+int arch_mig_send_specific(struct task_struct *);
+
+#include <hpc/arch-x86_64.h>
+#include <hpc/arch-i386.h>
+#include <hpc/arch-ppc.h>
+#include <hpc/syscalls.h>
+
+long arch_exec_syscall(int, syscall_parameter_t *);
+
+#endif /* _HPC_ARCH_H */
diff -Naur linux-2.6.11/include/hpc/arch-i386.h linux-2.6.11-om/include/hpc/arch-i386.h
--- linux-2.6.11/include/hpc/arch-i386.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/arch-i386.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_X86
+#ifndef _HPC_ARCH_ARCH_H
+#define _HPC_ARCH_ARCH_H
+
+int cpu_feature_has_fxsr(void);
+
+static inline long arch_get_sys_arg(unsigned int n, struct pt_regs *regs)
+{
+	BUG_ON(n >= 6);
+	return *(((long *) regs) + n);
+}
+
+static inline int arch_get_sys_nb(struct pt_regs *regs)
+{
+	return regs->eax;
+}
+
+#define NR_MAX_SYSCALL_ARG	6
+
+#define ARCH_TASK_GET_USER_REGS(p)				\
+		(((struct pt_regs *) (THREAD_SIZE +		\
+		(unsigned long) p->thread_info)) - 1)
+
+#endif /* _HPC_ARCH_ARCH_H */
+#endif /* CONFIG_X86 */
diff -Naur linux-2.6.11/include/hpc/arch-ppc.h linux-2.6.11-om/include/hpc/arch-ppc.h
--- linux-2.6.11/include/hpc/arch-ppc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/arch-ppc.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_PPC
+#ifndef _HPC_ARCH_ARCH_H
+#define _HPC_ARCH_ARCH_H
+
+static inline long arch_get_sys_arg(unsigned int n, struct pt_regs *regs)
+{
+	BUG_ON(n >= 31);
+	return regs->gpr[n + 1];
+}
+
+static inline int arch_get_sys_nb(struct pt_regs *regs)
+{
+	return regs->gpr[0] >> 2;
+}
+
+#define NR_MAX_SYSCALL_ARG	7
+
+#define ARCH_TASK_GET_USER_REGS(p)				\
+		(((struct pt_regs *) (THREAD_SIZE +		\
+		(unsigned long) p->thread_info)) - 1)
+
+#endif /* _HPC_ARCH_ARCH_H */
+#endif /* CONFIG_PPC */
+
diff -Naur linux-2.6.11/include/hpc/arch-x86_64.h linux-2.6.11-om/include/hpc/arch-x86_64.h
--- linux-2.6.11/include/hpc/arch-x86_64.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/arch-x86_64.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_X86_64
+#ifndef _HPC_ARCH_ARCH_H
+#define _HPC_ARCH_ARCH_H
+
+static inline long arch_get_sys_arg(unsigned int n, struct pt_regs *regs)
+{
+	switch (n) {
+		case 0: return regs->rdi;
+		case 1: return regs->rsi;
+		case 2: return regs->rdx;
+		case 3: return regs->rcx;
+		case 4: return regs->r8;
+		case 5: return regs->r9;
+		default: BUG();
+	}
+	return -1;
+}
+
+static inline int arch_get_sys_nb(struct pt_regs *regs)
+{
+	return (int) (regs->rax & 0xffffffff);
+}
+
+#define NR_MAX_SYSCALL_ARG	6
+
+#define ARCH_TASK_GET_USER_REGS(p)				\
+		(((struct pt_regs *) (THREAD_SIZE + 		\
+		(unsigned long) p->thread_info)) - 1)
+
+#endif /* _HPC_ARCH_ARCH_H */
+#endif /* CONFIG_X86_64 */
diff -Naur linux-2.6.11/include/hpc/comm.h linux-2.6.11-om/include/hpc/comm.h
--- linux-2.6.11/include/hpc/comm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/comm.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_COMM_H
+#define _HPC_COMM_H
+
+#include <net/sock.h>
+#include <hpc/protocol.h>
+
+/* this was put in include/linux/net.h ..., me no like */
+#define	SOCK_INTER_OPENMOSIX	3	/* used internally in kernel-mode */
+#define	SOCK_OOB_IN		5	/* OOB received on openmosix socket */
+
+/* node-disconnection timeout: */
+#define	OPENMOSIX_CONNECTION_KEEPALIVE_INTERVAL	30
+#define	OPENMOSIX_CONNECTION_KEEPALIVE_MAXTRIES	6
+#define	OPENMOSIX_CONNECTION_KEEPALIVE_TOTAL	150 /* changed from 180 */
+
+#define COMM_REMOTE_TIMO	(200L * HZ)
+#define COMM_CONNECT_TIMO	(4L * HZ)
+#define COMM_RECONN_TIMO	(10L * HZ)
+
+/* the ports we use */
+#define MIG_DAEMON_PORT		0x3412
+
+/* Describes an openmosix communication link */
+typedef struct openmosix_link
+{
+	struct socket *sock;	/* socket for communications */
+} om_link_t;
+
+/* external variables that need to be available */
+extern unsigned long comm_remote_timo;
+extern unsigned long comm_connect_timo;
+extern unsigned long comm_reconn_timo;
+
+/* routines inside comm.c */
+void comm_data_ready(struct sock *, int);
+om_link_t * comm_socket(int, int, int);
+int comm_bind(struct socket *, struct sockaddr *);
+int comm_peek(struct socket *);
+void comm_close(om_link_t *);
+int comm_wait(struct socket *);
+int comm_connect(om_link_t *, struct sockaddr *, unsigned long);
+int comm_accept(om_link_t *, om_link_t **, struct sockaddr *, unsigned long);
+int comm_recv(om_link_t *, void *, int);
+int comm_send(om_link_t *, void *, int);
+int comm_getname(om_link_t *, struct sockaddr *);
+
+void set_our_addr(int, struct sockaddr *, int);
+om_link_t * comm_setup_listen(struct sockaddr *);
+om_link_t * comm_setup_connect(struct sockaddr *, int);
+int comm_send_hd(om_link_t *, int, void *, int);
+int comm_send_req(om_link_t *link, int type);
+
+/* FIXME: oM task routines, this really should be in task.h,
+ * but it causes problems there */
+om_link_t * task_set_comm(task_t *, om_link_t *);
+
+#endif /* _HPC_COMM_H */
diff -Naur linux-2.6.11/include/hpc/comm-ipv4.h linux-2.6.11-om/include/hpc/comm-ipv4.h
--- linux-2.6.11/include/hpc/comm-ipv4.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/comm-ipv4.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_COMM_IPV4_H
+#define _HPC_COMM_IPV4_H
+
+#ifdef CONFIG_INET
+#include <linux/in.h>
+
+inline int inet_to_string(struct sockaddr_in *address, char *buffer)
+{
+	return sprintf(buffer, "%u.%u.%u.%u",
+			NIPQUAD(address->sin_addr.s_addr));
+}
+
+int string_to_inet(char *buf, struct sockaddr_in *address)
+{
+	u32 iaddr;
+	unsigned int arr[4], ret;
+	char *endbuf;
+
+	ret = sscanf(buf, "%u.%u.%u.%u", &arr[0], &arr[1], &arr[2], &arr[3]);
+	if (ret != 4 || !(arr[0] < 256 && arr[1] < 256
+			&& arr[2] < 256 && arr[3] < 256))
+		return 0;
+	iaddr = (arr[0] << 24) + (arr[1] << 16) + (arr[2] << 8) + arr[3];
+	address->sin_addr.s_addr = htonl(iaddr);
+	
+	endbuf = buf;
+	while (*endbuf && (*endbuf == '.' || (isdigit(*endbuf))))
+		endbuf++;
+	address->sin_family = AF_INET;
+	return endbuf - buf;
+}
+
+void inet_setup_port(struct sockaddr_in *sa_in, u16 port)
+{
+	sa_in->sin_port = port;
+}
+
+#else
+
+#endif /* CONFIG_INET */
+#endif /* _HPC_COMM_IPV4_H */
diff -Naur linux-2.6.11/include/hpc/comm-ipv6.h linux-2.6.11-om/include/hpc/comm-ipv6.h
--- linux-2.6.11/include/hpc/comm-ipv6.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/comm-ipv6.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_COMM_IPV6_H
+#define _HPC_COMM_IPV6_H
+
+#ifdef CONFIG_IPV6
+
+#include <linux/in6.h>
+
+inline int inet6_to_string(struct sockaddr_in6 *address, char *buffer)
+{
+	return sprintf(buffer, "%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x", 
+			NIP6(address->sin6_addr));
+}
+
+
+int string_to_inet6(char *buf, struct sockaddr_in6 *address)
+{
+	char *endbuf;
+	int arr[8], ret;
+
+	ret = sscanf(buf, "%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x",
+			&arr[0], &arr[1], &arr[2], &arr[3],
+			&arr[4], &arr[5], &arr[6], &arr[7]);
+	if (ret != 8)
+		return 0;
+
+	for (ret = 0; ret < 8; ret++)
+		address->sin6_addr.s6_addr16[ret] = htons(arr[ret]);
+
+	endbuf = buf;
+	while (*endbuf && (*endbuf == ':' || (isxdigit(*endbuf))))
+		endbuf++;
+	address->sin6_family = AF_INET6;
+	return endbuf - buf;
+}
+
+inline void inet6_setup_port(struct sockaddr_in6 *sa_in6, u16 port)
+{
+	sa_in6->sin6_port = port;
+}
+
+#else
+
+#define inet6_to_string(s, c)		-1
+#define string_to_inet6(str, s)		-1
+#define inet6_setup_port(s, i)
+
+#endif /* CONFIG_IPV6 */
+#endif /* _HPC_COMM_IPV6_H */
diff -Naur linux-2.6.11/include/hpc/debug.h linux-2.6.11-om/include/hpc/debug.h
--- linux-2.6.11/include/hpc/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/debug.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,55 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_DEBUG_H
+#define _HPC_DEBUG_H
+
+#include <hpc/protocol.h>
+#include <hpc/comm.h>
+#include <hpc/hpc.h>
+
+int proc_debug_get_loadinfo(char *value, size_t size);
+int proc_debug_get_admin(char *value, size_t size);
+
+int proc_debug_get_lfree_mem(char *value, size_t size);
+int proc_debug_get_pkeep_free(char *value, size_t size);
+
+int proc_debug_get_nodes(char *value, size_t size);
+
+
+/* for packets */
+void om_debug_regs(struct pt_regs *);
+void debug_mlink(om_link_t *);
+
+void debug_page(unsigned long);
+void debug_regs(void);
+void debug_vmas(struct mm_struct *);
+
+#ifdef CONFIG_OPENMOSIX_DEBUG
+#define OMDEBUG(var, lim, fmt...)	{ if (var >= lim) \
+					printk(KERN_DEBUG "[OMDBG] " fmt); }
+#else
+#define OMDEBUG(var, lim, fmt...)	do {} while (0)
+#endif
+
+#define OMDEBUG_MIG(lim, fmt...)	OMDEBUG(om_opts.debug_mig, lim, fmt)
+#define OMDEBUG_SYS(lim, fmt...)	OMDEBUG(om_opts.debug_sys, lim, fmt)
+#define OMDEBUG_RINO(lim, fmt...)	OMDEBUG(om_opts.debug_rino, lim, fmt)
+#define OMDEBUG_CPYUSER(lim, fmt...)	OMDEBUG(om_opts.debug_copyuser, lim, fmt)
+
+#endif /* _HPC_DEBUG_H */
diff -Naur linux-2.6.11/include/hpc/hpc.h linux-2.6.11-om/include/hpc/hpc.h
--- linux-2.6.11/include/hpc/hpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/hpc.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_HPC_H
+#define _HPC_HPC_H
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+
+/* arch specific */
+int user_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+/* init.c */
+void openmosix_init(void);
+void info_startup(void);
+
+/* proc.c */
+int openmosix_proc_pid_getattr(struct task_struct *, char *, void *, size_t);
+int openmosix_proc_pid_setattr(struct task_struct *, char *, void *, size_t);
+void openmosix_proc_init(void);
+
+/* kernel.c */
+int openmosix_pre_clone(int);
+void openmosix_post_clone(int);
+
+int stay_me_and_my_clones(int);
+void openmosix_no_longer_monkey(struct inode *);
+void unstay_mm(struct mm_struct *);
+
+int obtain_mm(task_t *p);
+
+/* task.c */
+int openmosix_task_init(struct task_struct *);
+int openmosix_task_exit(void);
+
+struct openmosix_options
+{
+#ifdef CONFIG_OPENMOSIX_DEBUG
+	int debug_mig;
+	int debug_sys;
+	int debug_rino;
+	int debug_copyuser;
+#endif
+};
+
+extern struct openmosix_options om_opts;
+
+unsigned long	deputy_do_mmap_pgoff(struct file * file, unsigned long addr,
+				unsigned long len, unsigned long prot,
+				unsigned long flags, unsigned long pgoff);
+long		remote_do_mmap(unsigned long addr, unsigned long len,
+				unsigned long prot, unsigned long flags,
+				unsigned long fd, unsigned long pgoff);
+long		remote_do_execve(char __user * filename,
+				char __user *__user *argv,
+				char __user *__user *envp,
+				struct pt_regs * regs);
+
+#endif /* _HPC_HPC_H */
diff -Naur linux-2.6.11/include/hpc/mig.h linux-2.6.11-om/include/hpc/mig.h
--- linux-2.6.11/include/hpc/mig.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/mig.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_MIG_H
+#define _HPC_MIG_H
+
+#include <linux/sched.h>
+#include <net/sock.h>
+#include <hpc/comm.h>
+
+#define REMOTE_DAEMON_PORT  0x3412
+
+/* PROTOTYPES */
+int openmosix_mig_daemon(void *);
+
+int mig_do_receive(task_t *);
+int mig_do_send(task_t *);
+int mig_send_hshake(task_t *, om_link_t *, int);
+int mig_recv_hshake(om_link_t *);
+
+int task_move_to_node(task_t *, struct sockaddr *, int);
+int task_remote_expel(task_t *);
+
+#endif /* _HPC_MIG_H */
diff -Naur linux-2.6.11/include/hpc/omtask.h linux-2.6.11-om/include/hpc/omtask.h
--- linux-2.6.11/include/hpc/omtask.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/omtask.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,47 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_OMTASK_H
+#define _HPC_OMTASK_H
+
+/* temporary fix for ppc */
+#ifndef NCAPINTS
+# define NCAPINTS 1
+#endif
+
+typedef struct openmosix_task {
+	volatile u32 dflags;		/* distributed flags */
+	volatile u32 stay;		/* reasons why process must stay */
+	atomic_t dreqs;			/* bits that others may request */
+	struct openmosix_link *contact;	/* DEPUTY <==> REMOTE connection */
+	struct sockaddr *whereto;	/* sockaddr to send to if DREQ_MOVE */
+
+	wait_queue_head_t wait_dist;	/* misc. wait for process */
+
+	struct list_head rfiles;	/* deputy held files */
+
+	/* the following variables are only use on remote */
+	kernel_cap_t remote_caps;	/* effective capabilities on REMOTE */
+	pid_t pid;			/* original PID */
+	pid_t tgid;			/* original TGID */
+	
+	/* arch dependant */
+	u32 features[NCAPINTS];		/* CPU features on original node */
+} om_task_t;
+
+#endif /* _HPC_OMTASK_H */
diff -Naur linux-2.6.11/include/hpc/proc.h linux-2.6.11-om/include/hpc/proc.h
--- linux-2.6.11/include/hpc/proc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/proc.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_PROC_H
+#define _HPC_PROC_H
+
+int proc_pid_set_0(task_t *p, char *value, size_t size) { return -EINVAL; }
+int proc_pid_get_0(task_t *p, char *value, size_t size) { return -EINVAL; }
+int proc_admin_set_0(char *value, size_t size) { return -EINVAL; }
+int proc_admin_get_0(char *value, size_t size) { return -EINVAL; }
+int proc_info_set_0(char *value, size_t size) { return -EINVAL; }
+int proc_info_get_0(char *value, size_t size) { return -EINVAL; }
+int proc_debug_set_0(char *value, size_t size) { return -EINVAL; }
+int proc_debug_get_0(char *value, size_t size) { return -EINVAL; }
+
+typedef struct om_proc_entry {
+	int type;
+	int len;
+	char *name;
+	mode_t mode;
+	int (*set)(char *dummy, size_t);
+	int (*get)(char *dummy, size_t);
+} om_proc_entry_t;
+
+typedef struct om_proc_pid_entry {
+	int type;
+	int len;
+	char *name;
+	mode_t mode;
+	int (*set)(task_t *t, char *dummy, size_t);
+	int (*get)(task_t *t, char *dummy, size_t);
+} om_proc_pid_entry_t;
+
+#endif /* _HPC_PROC_H */
diff -Naur linux-2.6.11/include/hpc/protocol.h linux-2.6.11-om/include/hpc/protocol.h
--- linux-2.6.11/include/hpc/protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/protocol.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,209 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+#ifndef _HPC_PROTOCOL_H
+#define _HPC_PROTOCOL_H
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <hpc/protocol-x86_64.h>
+#include <hpc/protocol-ppc.h>
+#include <hpc/protocol-i386.h>
+
+/* Migration handshake*/
+struct omp_mig_handshake
+{
+	int type;		/* which type (look below) */
+	long version;		/* openmosix version */
+	int reason;		/* reason for mig or command */
+	int personality;	/* of process to be sent */
+};
+/* handshake types */
+#define HSHAKE_MIG_REQUEST	0x01
+#define HSHAKE_DEPUTY_PROBE	0x02
+#define HSHAKE_REPLY		0x04
+#define HSHAKE_NOTOK		0x08
+
+
+/* main structure for passing messages between 
+ * DEPUTY and REMOTE. Denotes the type of request,
+ * and the length of it */
+struct omp_req
+{
+	int type;
+	int dlen;
+};
+
+#define DEP_FLG		0x100
+#define MIG_FLG		0x200
+#define REM_FLG		0x400
+#define REPLY		0x800
+
+/* commands sent during migration */
+#define MIG_MM		(MIG_FLG | 0x10)
+#define MIG_VMA		(MIG_FLG | 0x11)
+#define MIG_PAGE	(MIG_FLG | 0x12)
+#define MIG_FP		(MIG_FLG | 0x13)
+#define MIG_ARCH	(MIG_FLG | 0x14)
+#define MIG_TASK	(MIG_FLG | 0x15)
+#define MIG_ABORT	(MIG_FLG | 0x16)
+
+/* commands sent by deputy to remote */
+#define DEP_COPY_FROM_USER	(DEP_FLG | 0x01)
+#define DEP_COPY_TO_USER	(DEP_FLG | 0x02)
+#define DEP_STRNCPY_FROM_USER	(DEP_FLG | 0x03)
+#define DEP_STRNLEN_USER	(DEP_FLG | 0x04)
+#define DEP_GET_USER		(DEP_FLG | 0x05)
+#define DEP_PUT_USER		(DEP_FLG | 0x06)
+#define DEP_SIGNAL		(DEP_FLG | 0x07)
+#define DEP_COMING_HOME		(DEP_FLG | 0x10)
+
+/* commands sent by remote to deputy */
+#define REM_BRING_HOME	(REM_FLG | 0x10)
+#define REM_PAGE	(REM_FLG | 0x11)
+#define REM_SYSCALL	(REM_FLG | 0x12)
+#define REM_FORK	(REM_FLG | 0x14)
+#define REM_MMAP	(REM_FLG | 0x15)
+#define REM_EXECVE	(REM_FLG | 0x16)
+
+/* task_struct values that need to be passed */
+struct omp_mig_task
+{
+	unsigned long ptrace;
+	long nice;
+
+	kernel_cap_t caps;
+	unsigned long it_prof_value, it_prof_incr, it_virt_value, it_virt_incr;
+	struct rlimit rlim_cpu, rlim_data, rlim_stack, rlim_rss, rlim_as;
+
+	pid_t pid, tgid;
+	unsigned long personality;
+
+	/* process credentials */
+	uid_t uid, euid, suid, fsuid;
+	gid_t gid, egid, sgid, fsgid;
+
+	/* signals */
+	sigset_t blocked, real_blocked;
+	struct k_sigaction sighand[_NSIG];
+	unsigned long sas_ss_sp;
+	size_t sas_ss_size;
+
+	/* saved user space regs */
+	struct pt_regs regs;
+
+	struct omp_mig_arch_task arch;
+};
+
+/* mm_struct values */
+struct omp_mig_mm
+{
+	unsigned long start_code, end_code, start_data, end_data;
+	unsigned long start_brk, brk, start_stack;
+	unsigned long arg_start, arg_end, env_start, env_end;
+};
+
+struct omp_mig_vma
+{
+	unsigned long vm_start;
+	unsigned long vm_size;
+	unsigned long vm_flags;
+	unsigned long vm_pgoff;
+	struct file *vm_file;
+	struct dentry *f_dentry;
+	loff_t i_size;
+};
+
+struct omp_syscall_req
+{
+	int n;			/* syscall number */
+	unsigned long arg[7];	/* array of arguments */
+};
+
+struct omp_syscall_ret
+{
+	long ret;		/* syscall return value */
+};
+
+struct omp_fork_req
+{
+	unsigned long clone_flags;
+	struct pt_regs regs;
+	struct sockaddr sockaddr;
+	unsigned long stack_start;
+	unsigned long stack_size;
+};
+
+struct omp_fork_ret
+{
+	pid_t pid, tgid;	/* child pid and tgid */
+};
+
+struct omp_usercopy_req
+{
+	unsigned long addr;
+	unsigned long len;
+};
+
+struct omp_usercopy_emb
+{
+	unsigned long addr;
+	unsigned long len;
+	s64 val;
+};
+
+struct omp_page_req
+{
+	struct file * file;
+	unsigned long offset;
+};
+
+struct omp_mmap_req
+{
+	unsigned long addr;
+	unsigned long len;
+	unsigned long flags;
+	unsigned long prot;
+	unsigned long fd;
+	unsigned long pgoff;
+};
+
+struct omp_execve_req
+{
+	unsigned long p;
+	char *filename;
+	int filelen;
+	int argc, envc;
+	struct pt_regs regs;
+};
+
+struct omp_mmap_ret
+{
+	long ret;
+	struct file * file;
+	unsigned long isize;
+};
+
+struct omp_signal
+{
+	int signr;
+	siginfo_t siginfo;
+};
+
+#endif /*  _HPC_PROTOCOL_H */
diff -Naur linux-2.6.11/include/hpc/protocol-i386.h linux-2.6.11-om/include/hpc/protocol-i386.h
--- linux-2.6.11/include/hpc/protocol-i386.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/protocol-i386.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_X86
+#ifndef _HPC_ARCHPROTOCOL_H
+#define _HPC_ARCHPROTOCOL_H
+
+#include <asm/i387.h>
+
+#define MIG_ARCH_I386_LDT	1
+
+struct omp_mig_fp
+{
+	int has_fxsr;
+	union i387_union data;
+};
+
+struct omp_mig_arch
+{
+	int type;
+};
+
+struct omp_mig_arch_task
+{
+	u32 features[NCAPINTS];
+	long debugreg[8];
+	long fs;
+	long gs;
+	struct desc_struct tls_array[GDT_ENTRY_TLS_ENTRIES];
+};
+
+#endif /*  _HPC_ARCHPROTOCOL_H */
+#endif /* CONFIG_X86 */
diff -Naur linux-2.6.11/include/hpc/protocol-ppc.h linux-2.6.11-om/include/hpc/protocol-ppc.h
--- linux-2.6.11/include/hpc/protocol-ppc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/protocol-ppc.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_PPC
+#ifndef _HPC_ARCHPROTOCOL_H
+#define _HPC_ARCHPROTOCOL_H
+struct omp_mig_fp
+{
+	int has_altivec;
+	double fpr[32];
+	unsigned long fpscr_pad;
+	unsigned long fpscr;
+};
+
+struct omp_mig_arch
+{
+};
+
+struct omp_mig_arch_task
+{
+};
+
+#endif /* _HPC_ARCHPROTOCOL_H */
+#endif /* CONFIG_PPC */
diff -Naur linux-2.6.11/include/hpc/protocol-x86_64.h linux-2.6.11-om/include/hpc/protocol-x86_64.h
--- linux-2.6.11/include/hpc/protocol-x86_64.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/protocol-x86_64.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_X86_64
+#ifndef _HPC_ARCHPROTOCOL_H
+#define _HPC_ARCHPROTOCOL_H
+
+#include <asm/i387.h>
+
+struct omp_mig_fp
+{
+	union i387_union data;
+};
+
+struct omp_mig_arch
+{
+	int type;
+};
+
+struct omp_mig_arch_task
+{
+	unsigned long userrsp;
+	unsigned long fs;
+	unsigned long gs;
+	unsigned int es, ds, fsindex, gsindex;
+	u64 tls_array[GDT_ENTRY_TLS_ENTRIES];
+};
+
+#endif /*  _HPC_ARCHPROTOCOL_H */
+#endif /* CONFIG_X86_64 */
diff -Naur linux-2.6.11/include/hpc/prototype.h linux-2.6.11-om/include/hpc/prototype.h
--- linux-2.6.11/include/hpc/prototype.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/prototype.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,85 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_PROTOTYPE_H
+#define _HPC_PROTOTYPE_H
+
+#ifdef CONFIG_OPENMOSIX_MIGRATION_VERBOSE
+#define OM_VERBOSE_MIG(fmt...)	printk(KERN_NOTICE fmt)
+#else
+#define OM_VERBOSE_MIG(fmt...)	do { } while (0)
+#endif
+
+#define OMBUG(f, a...)	printk(KERN_ERR "[OMBUG] %s: " f, __FUNCTION__, ## a)
+
+
+NORET_TYPE void		deputy_die_on_communication(void);
+void			deputy_main_loop(void);
+void			deputy_startup(task_t *p);
+
+/*****************************************************************************/
+
+struct om_held_file
+{
+	struct list_head list;
+	struct file *file;
+	unsigned long nb;
+	struct page *(*nopage)(struct vm_area_struct *, unsigned long, int *);
+};
+
+struct rfile_inode_data
+{
+	struct file *file;
+	unsigned long node;
+	loff_t isize;
+};
+
+struct vm_operations_struct; /* forward declaration */
+
+int			task_heldfiles_add(task_t *p, struct file *file,
+					struct vm_operations_struct *vm_ops);
+void			task_heldfiles_clear(task_t *p);
+struct om_held_file *	task_heldfiles_find(task_t *p, struct file *file);
+
+struct file *		task_rfiles_get(task_t *p, struct file *file,
+					unsigned long node, loff_t isize);
+
+struct file *		rfiles_inode_get_file(struct inode *inode);
+
+/*****************************************************************************/
+
+struct omp_mig_vma; /* forward declaration */
+
+NORET_TYPE void	remote_disappear(void);
+int		remote_mmap(struct omp_mig_vma *, int);
+long		remote_do_syscall(int, struct pt_regs *);
+int		remote_do_comm(task_t *);
+long		remote_do_fork(unsigned long clone_flags,
+				unsigned long stack_start,
+				struct pt_regs *regs,
+				unsigned long stack_size,
+				int __user *parent_tidptr,
+				int __user *child_tidptr);
+long		remote_do_mmap(unsigned long addr, unsigned long len,
+				unsigned long prot, unsigned long flags,
+				unsigned long fd, unsigned long pgoff);
+int		remote_file_mmap(struct file *file,
+				struct vm_area_struct *vma);
+int		remote_readpage(struct file *file, struct page *page);
+
+#endif /* _HPC_PROTOTYPE_H */
diff -Naur linux-2.6.11/include/hpc/service.h linux-2.6.11-om/include/hpc/service.h
--- linux-2.6.11/include/hpc/service.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/service.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+ 
+#ifndef _HPC_SERVICE_H
+#define _HPC_SERVICE_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+struct openmosix_link;
+
+int sockaddr_to_string(struct sockaddr *address, char *buffer);
+int string_to_sockaddr(char *buf, struct sockaddr *address);
+void sockaddr_setup_port(struct sockaddr *, int port);
+int sockaddr_inherit(struct openmosix_link *mlink, struct sockaddr *sa);
+
+void om_daemonize(char *, int);
+
+#endif /* _HPC_SERVICE_H */
diff -Naur linux-2.6.11/include/hpc/syscalls.h linux-2.6.11-om/include/hpc/syscalls.h
--- linux-2.6.11/include/hpc/syscalls.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/syscalls.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,29 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_SYSCALL_H
+#define _HPC_SYSCALL_H
+
+#define SYSARG(n)	arch_get_sys_arg(n, &regs)
+#define SYSNB()		arch_get_sys_nb(&regs)
+
+typedef struct syscall_parameter_t { long arg[NR_MAX_SYSCALL_ARG]; }
+						syscall_parameter_t;
+typedef long (*syscall_func_t)(syscall_parameter_t);
+
+#endif /* _HPC_SYSCALL_H */
diff -Naur linux-2.6.11/include/hpc/task.h linux-2.6.11-om/include/hpc/task.h
--- linux-2.6.11/include/hpc/task.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/task.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,155 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_TASK_H
+#define _HPC_TASK_H
+
+#ifdef CONFIG_OPENMOSIX
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <asm/atomic.h>
+
+#define OPENMOSIX_INIT_TASK(tsk) .om = {	\
+	.dflags = 0,				\
+	.dreqs = ATOMIC_INIT(0),                \
+	.rfiles = LIST_HEAD_INIT(tsk.om.rfiles),\
+}
+
+
+#define OPENMOSIX_INIT_MM()			\
+	.mm_realusers = ATOMIC_INIT(1),		\
+
+/*
+ * distributed flags (dflags):
+ * that are *ONLY* set by the process itself, but may be read by others:
+ */
+#define	DDEPUTY		0x00000001	/* process is a DEPUTY stub */
+#define	DREMOTE		0x00000002	/* process is running remotely */
+#define	DINCOMING	0x00000040	/* process coming here */
+#define	DPASSING	0x00000080	/* process is in migration */
+#define	DFINISHED	0x00000200	/* wants to become zombie */
+#define	DREMOTEDAEMON	0x00000400	/* set DREMOTE on "fork" */
+
+#define	DMIGRATED	(DDEPUTY | DREMOTE) /* if task has been migrated */
+
+/*
+ * distributed request (dreqs):
+ * Thoses flags are set by any process to interact with the process.
+ */
+#define DREQ_MOVE	(1 << 0)	/* the process has to move */
+#define	DREQ_CHECKSTAY	(1 << 1)	/* check whether still stay */
+#define	DREQ_URGENT	(1 << 2)	/* something urgent (R=>D) */
+
+/*
+ * stay reason (dstay):
+ */
+#define	DSTAY_MONKEY	(1 << 0)	/* using monkey vnode */
+#define	DSTAY_DEV	(1 << 1)	/* mapping a device */
+#define	DSTAY_86	(1 << 2)	/* running in 86 mode */
+#define	DSTAY_PRIV	(1 << 4)	/* privilleged inst. access (in/out) */
+#define	DSTAY_MLOCK	(1 << 5)	/* has locked memory */
+#define	DSTAY_CLONE	(1 << 6)	/* shared VM, eliminate this once DSM*/
+#define	DSTAY_RT	(1 << 7)	/* Real-Time scheduling */
+#define	DSTAY_IOPL	(1 << 8)	/* direct I/O permission */
+#define	DSTAY_SYSTEM	(1 << 9)	/* init process */
+#define	DSTAY_OTHER1	(1 << 24)	/* external reason for stay (1) */
+#define	DSTAY_OTHER2	(1 << 25)	/* external reason for stay (2) */
+#define	DSTAY_OTHER3	(1 << 26)	/* external reason for stay (3) */
+#define	DSTAY_OTHER4	(1 << 27)	/* external reason for stay (4) */
+#define	DNOMIGRATE	(1 << 31)	/* user requested no auto-migrations */
+
+#define	DSTAY		(~DNOMIGRATE)
+#define	DSTAY_PER_MM	(DSTAY_MONKEY|DSTAY_DEV|DSTAY_MLOCK)
+
+int task_set_where(struct task_struct *p, int value);
+int task_get_where(struct task_struct *p);
+
+/* dreqs */
+static inline void task_set_dreqs(struct task_struct *p, unsigned int val)
+{
+	atomic_set_mask(val, &p->om.dreqs);
+}
+
+static inline void task_clear_dreqs(struct task_struct *p, unsigned int val)
+{
+	atomic_clear_mask(val, &p->om.dreqs);
+}
+
+static inline int task_test_dreqs(struct task_struct *p, unsigned int val)
+{
+	return atomic_read(&p->om.dreqs) & val;
+}
+
+/* dflags */
+
+static inline void task_set_dflags(struct task_struct *p, unsigned int val)
+{
+	p->om.dflags |= val;
+}
+
+static inline void task_clear_dflags(struct task_struct *p, unsigned int val)
+{
+	p->om.dflags &= ~val;
+}
+
+static inline int task_test_dflags(struct task_struct *p, unsigned int val)
+{
+	return (p->om.dflags & val);
+}
+
+/* stay */
+
+static inline void task_set_stay(struct task_struct *p, unsigned int val)
+{
+	p->om.stay |= val;
+}
+
+static inline void task_clear_stay(struct task_struct *p, unsigned int val)
+{
+	p->om.stay &= ~val;
+}
+
+static inline int task_test_stay(struct task_struct *p, unsigned int val)
+{
+	return (p->om.stay & val);
+}
+
+#define task_dreqs_pending(p)	task_test_dreqs(p, ~0)
+
+void task_add_balance_reason(struct task_struct *p, int w);
+
+int task_go_home(struct task_struct *p);
+int task_go_home_for_reason(struct task_struct *p, int reason);
+
+int task_check_stay(struct task_struct *p);
+void task_do_request(void);
+
+struct sockaddr;
+int task_register_migration(task_t *p, struct sockaddr *);
+
+struct inode;
+int task_maps_inode(task_t *p, struct inode *);
+
+#else
+
+#define OPENMOSIX_INIT_TASK(tsk)	/* */
+#define OPENMOSIX_INIT_MM()		/* */
+
+#endif
+#endif /* _HPC_HPCTASK_H */
diff -Naur linux-2.6.11/include/hpc/uaccess.h linux-2.6.11-om/include/hpc/uaccess.h
--- linux-2.6.11/include/hpc/uaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/uaccess.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_UACCESS_H
+#define _HPC_UACCESS_H
+
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/task.h>
+
+unsigned long	deputy_copy_from_user(void *to,
+					const void __user *from,
+					unsigned long n);
+unsigned long	deputy_copy_to_user(void __user *to,
+					const void *from,
+					unsigned long n);
+unsigned long	deputy_strncpy_from_user(char *dst, const char __user *src,
+							long count);
+unsigned long	deputy_strnlen_user(const char *s, long n);
+
+long		deputy_put_user(long value, const void *addr, size_t size);
+long		deputy_get_user(long *value, const void *addr, size_t size);
+
+#if BITS_PER_LONG < 64 
+long		deputy_get_user64(s64 *value, const void *addr);
+long		deputy_put_user64(s64 value, const void *addr);
+#endif
+
+/**
+ * openmosix_memory_away - Test is memory is here
+ **/
+static inline int openmosix_memory_away(void)
+{
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (task_test_dflags(current, DDEPUTY))
+		return 1;
+	return 0;
+}
+
+#else
+
+#define openmosix_memory_away() 0
+#define deputy_put_user(a, b, c) 0
+#define deputy_get_user(a, b, c) 0
+
+#endif
+
+#endif /* _HPC_UACCESS_H */
diff -Naur linux-2.6.11/include/hpc/version.h linux-2.6.11-om/include/hpc/version.h
--- linux-2.6.11/include/hpc/version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/hpc/version.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_VERSION_H
+#define _HPC_VERSION_H
+
+#define OPENMOSIX_VERSION_MAJOR		0
+#define OPENMOSIX_VERSION_MINOR		0
+#define OPENMOSIX_VERSION_MICRO		0
+
+#define OPENMOSIX_VERSION	(OPENMOSIX_VERSION_MAJOR * 10000) + \
+				(OPENMOSIX_VERSION_MINOR * 100) + \
+				(OPENMOSIX_VERSION_MICRO)
+
+#define OPENMOSIX_VERSION_TUPPLE \
+				OPENMOSIX_VERSION_MAJOR, \
+				OPENMOSIX_VERSION_MINOR, \
+				OPENMOSIX_VERSION_MICRO
+
+/* FIXME : need to create a scheme about version handling */
+#define OPENMOSIX_VERSION_BALANCE	0x1L
+#define OPENMOSIX_VERSION_MIGRATION	0x1L
+
+#endif /* _HPC_VERSION_H */
diff -Naur linux-2.6.11/include/linux/compiler.h linux-2.6.11-om/include/linux/compiler.h
--- linux-2.6.11/include/linux/compiler.h	2005-03-02 08:38:12.000000000 +0100
+++ linux-2.6.11-om/include/linux/compiler.h	2005-05-15 23:18:03.000000000 +0200
@@ -34,6 +34,12 @@
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_OPENMOSIX
+#define OM_NSTATIC
+#else
+#define OM_NSTATIC static
+#endif
+
 #if __GNUC__ > 3
 # include <linux/compiler-gcc+.h>	/* catch-all for GCC 4, 5, etc. */
 #elif __GNUC__ == 3
diff -Naur linux-2.6.11/include/linux/config.h linux-2.6.11-om/include/linux/config.h
--- linux-2.6.11/include/linux/config.h	2005-03-02 08:38:26.000000000 +0100
+++ linux-2.6.11-om/include/linux/config.h	2005-05-15 23:18:03.000000000 +0200
@@ -2,5 +2,8 @@
 #define _LINUX_CONFIG_H
 
 #include <linux/autoconf.h>
+#ifdef CONFIG_X86
+#include <asm/kgdb.h>
+#endif
 
 #endif
diff -Naur linux-2.6.11/include/linux/dwarf2.h linux-2.6.11-om/include/linux/dwarf2.h
--- linux-2.6.11/include/linux/dwarf2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/linux/dwarf2.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,738 @@
+/* Declarations and definitions of codes relating to the DWARF2 symbolic
+   debugging information format.
+   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002
+   Free Software Foundation, Inc.
+
+   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program
+   Office (AJPO), Florida State Unviversity and Silicon Graphics Inc.
+   provided support for this effort -- June 21, 1995.
+
+   Derived from the DWARF 1 implementation written by Ron Guilmette
+   (rfg@netcom.com), November 1990.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 2, or (at your option) any later
+   version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+/* This file is derived from the DWARF specification (a public document)
+   Revision 2.0.0 (July 27, 1993) developed by the UNIX International
+   Programming Languages Special Interest Group (UI/PLSIG) and distributed
+   by UNIX International.  Copies of this specification are available from
+   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.
+
+   This file also now contains definitions from the DWARF 3 specification.  */
+
+/* This file is shared between GCC and GDB, and should not contain
+   prototypes.	*/
+
+#ifndef _ELF_DWARF2_H
+#define _ELF_DWARF2_H
+
+/* Structure found in the .debug_line section.	*/
+#ifndef __ASSEMBLY__
+typedef struct
+{
+  unsigned char li_length	   [4];
+  unsigned char li_version	   [2];
+  unsigned char li_prologue_length [4];
+  unsigned char li_min_insn_length [1];
+  unsigned char li_default_is_stmt [1];
+  unsigned char li_line_base	   [1];
+  unsigned char li_line_range	   [1];
+  unsigned char li_opcode_base	   [1];
+}
+DWARF2_External_LineInfo;
+
+typedef struct
+{
+  unsigned long  li_length;
+  unsigned short li_version;
+  unsigned int	 li_prologue_length;
+  unsigned char  li_min_insn_length;
+  unsigned char  li_default_is_stmt;
+  int		 li_line_base;
+  unsigned char  li_line_range;
+  unsigned char  li_opcode_base;
+}
+DWARF2_Internal_LineInfo;
+
+/* Structure found in .debug_pubnames section.	*/
+typedef struct
+{
+  unsigned char pn_length  [4];
+  unsigned char pn_version [2];
+  unsigned char pn_offset  [4];
+  unsigned char pn_size    [4];
+}
+DWARF2_External_PubNames;
+
+typedef struct
+{
+  unsigned long  pn_length;
+  unsigned short pn_version;
+  unsigned long  pn_offset;
+  unsigned long  pn_size;
+}
+DWARF2_Internal_PubNames;
+
+/* Structure found in .debug_info section.  */
+typedef struct
+{
+  unsigned char  cu_length	  [4];
+  unsigned char  cu_version	  [2];
+  unsigned char  cu_abbrev_offset [4];
+  unsigned char  cu_pointer_size  [1];
+}
+DWARF2_External_CompUnit;
+
+typedef struct
+{
+  unsigned long  cu_length;
+  unsigned short cu_version;
+  unsigned long  cu_abbrev_offset;
+  unsigned char  cu_pointer_size;
+}
+DWARF2_Internal_CompUnit;
+
+typedef struct
+{
+  unsigned char  ar_length	 [4];
+  unsigned char  ar_version	 [2];
+  unsigned char  ar_info_offset  [4];
+  unsigned char  ar_pointer_size [1];
+  unsigned char  ar_segment_size [1];
+}
+DWARF2_External_ARange;
+
+typedef struct
+{
+  unsigned long  ar_length;
+  unsigned short ar_version;
+  unsigned long  ar_info_offset;
+  unsigned char  ar_pointer_size;
+  unsigned char  ar_segment_size;
+}
+DWARF2_Internal_ARange;
+
+#define ENUM(name) enum name {
+#define IF_NOT_ASM(a) a
+#define COMMA ,
+#else
+#define ENUM(name)
+#define IF_NOT_ASM(a)
+#define COMMA
+
+#endif
+
+/* Tag names and codes.  */
+ENUM(dwarf_tag)
+
+    DW_TAG_padding = 0x00 COMMA
+    DW_TAG_array_type = 0x01 COMMA
+    DW_TAG_class_type = 0x02 COMMA
+    DW_TAG_entry_point = 0x03 COMMA
+    DW_TAG_enumeration_type = 0x04 COMMA
+    DW_TAG_formal_parameter = 0x05 COMMA
+    DW_TAG_imported_declaration = 0x08 COMMA
+    DW_TAG_label = 0x0a COMMA
+    DW_TAG_lexical_block = 0x0b COMMA
+    DW_TAG_member = 0x0d COMMA
+    DW_TAG_pointer_type = 0x0f COMMA
+    DW_TAG_reference_type = 0x10 COMMA
+    DW_TAG_compile_unit = 0x11 COMMA
+    DW_TAG_string_type = 0x12 COMMA
+    DW_TAG_structure_type = 0x13 COMMA
+    DW_TAG_subroutine_type = 0x15 COMMA
+    DW_TAG_typedef = 0x16 COMMA
+    DW_TAG_union_type = 0x17 COMMA
+    DW_TAG_unspecified_parameters = 0x18 COMMA
+    DW_TAG_variant = 0x19 COMMA
+    DW_TAG_common_block = 0x1a COMMA
+    DW_TAG_common_inclusion = 0x1b COMMA
+    DW_TAG_inheritance = 0x1c COMMA
+    DW_TAG_inlined_subroutine = 0x1d COMMA
+    DW_TAG_module = 0x1e COMMA
+    DW_TAG_ptr_to_member_type = 0x1f COMMA
+    DW_TAG_set_type = 0x20 COMMA
+    DW_TAG_subrange_type = 0x21 COMMA
+    DW_TAG_with_stmt = 0x22 COMMA
+    DW_TAG_access_declaration = 0x23 COMMA
+    DW_TAG_base_type = 0x24 COMMA
+    DW_TAG_catch_block = 0x25 COMMA
+    DW_TAG_const_type = 0x26 COMMA
+    DW_TAG_constant = 0x27 COMMA
+    DW_TAG_enumerator = 0x28 COMMA
+    DW_TAG_file_type = 0x29 COMMA
+    DW_TAG_friend = 0x2a COMMA
+    DW_TAG_namelist = 0x2b COMMA
+    DW_TAG_namelist_item = 0x2c COMMA
+    DW_TAG_packed_type = 0x2d COMMA
+    DW_TAG_subprogram = 0x2e COMMA
+    DW_TAG_template_type_param = 0x2f COMMA
+    DW_TAG_template_value_param = 0x30 COMMA
+    DW_TAG_thrown_type = 0x31 COMMA
+    DW_TAG_try_block = 0x32 COMMA
+    DW_TAG_variant_part = 0x33 COMMA
+    DW_TAG_variable = 0x34 COMMA
+    DW_TAG_volatile_type = 0x35 COMMA
+    /* DWARF 3.  */
+    DW_TAG_dwarf_procedure = 0x36 COMMA
+    DW_TAG_restrict_type = 0x37 COMMA
+    DW_TAG_interface_type = 0x38 COMMA
+    DW_TAG_namespace = 0x39 COMMA
+    DW_TAG_imported_module = 0x3a COMMA
+    DW_TAG_unspecified_type = 0x3b COMMA
+    DW_TAG_partial_unit = 0x3c COMMA
+    DW_TAG_imported_unit = 0x3d COMMA
+    /* SGI/MIPS Extensions.  */
+    DW_TAG_MIPS_loop = 0x4081 COMMA
+    /* GNU extensions.	*/
+    DW_TAG_format_label = 0x4101 COMMA	/* For FORTRAN 77 and Fortran 90.  */
+    DW_TAG_function_template = 0x4102 COMMA	/* For C++.  */
+    DW_TAG_class_template = 0x4103 COMMA	/* For C++.  */
+    DW_TAG_GNU_BINCL = 0x4104 COMMA
+    DW_TAG_GNU_EINCL = 0x4105 COMMA
+    /* Extensions for UPC.  See: http://upc.gwu.edu/~upc.  */
+    DW_TAG_upc_shared_type = 0x8765 COMMA
+    DW_TAG_upc_strict_type = 0x8766 COMMA
+    DW_TAG_upc_relaxed_type = 0x8767
+IF_NOT_ASM(};)
+
+#define DW_TAG_lo_user	0x4080
+#define DW_TAG_hi_user	0xffff
+
+/* Flag that tells whether entry has a child or not.  */
+#define DW_children_no	 0
+#define	DW_children_yes  1
+
+/* Form names and codes.  */
+ENUM(dwarf_form)
+
+    DW_FORM_addr = 0x01 COMMA
+    DW_FORM_block2 = 0x03 COMMA
+    DW_FORM_block4 = 0x04 COMMA
+    DW_FORM_data2 = 0x05 COMMA
+    DW_FORM_data4 = 0x06 COMMA
+    DW_FORM_data8 = 0x07 COMMA
+    DW_FORM_string = 0x08 COMMA
+    DW_FORM_block = 0x09 COMMA
+    DW_FORM_block1 = 0x0a COMMA
+    DW_FORM_data1 = 0x0b COMMA
+    DW_FORM_flag = 0x0c COMMA
+    DW_FORM_sdata = 0x0d COMMA
+    DW_FORM_strp = 0x0e COMMA
+    DW_FORM_udata = 0x0f COMMA
+    DW_FORM_ref_addr = 0x10 COMMA
+    DW_FORM_ref1 = 0x11 COMMA
+    DW_FORM_ref2 = 0x12 COMMA
+    DW_FORM_ref4 = 0x13 COMMA
+    DW_FORM_ref8 = 0x14 COMMA
+    DW_FORM_ref_udata = 0x15 COMMA
+    DW_FORM_indirect = 0x16
+IF_NOT_ASM(};)
+
+/* Attribute names and codes.  */
+
+ENUM(dwarf_attribute)
+
+    DW_AT_sibling = 0x01 COMMA
+    DW_AT_location = 0x02 COMMA
+    DW_AT_name = 0x03 COMMA
+    DW_AT_ordering = 0x09 COMMA
+    DW_AT_subscr_data = 0x0a COMMA
+    DW_AT_byte_size = 0x0b COMMA
+    DW_AT_bit_offset = 0x0c COMMA
+    DW_AT_bit_size = 0x0d COMMA
+    DW_AT_element_list = 0x0f COMMA
+    DW_AT_stmt_list = 0x10 COMMA
+    DW_AT_low_pc = 0x11 COMMA
+    DW_AT_high_pc = 0x12 COMMA
+    DW_AT_language = 0x13 COMMA
+    DW_AT_member = 0x14 COMMA
+    DW_AT_discr = 0x15 COMMA
+    DW_AT_discr_value = 0x16 COMMA
+    DW_AT_visibility = 0x17 COMMA
+    DW_AT_import = 0x18 COMMA
+    DW_AT_string_length = 0x19 COMMA
+    DW_AT_common_reference = 0x1a COMMA
+    DW_AT_comp_dir = 0x1b COMMA
+    DW_AT_const_value = 0x1c COMMA
+    DW_AT_containing_type = 0x1d COMMA
+    DW_AT_default_value = 0x1e COMMA
+    DW_AT_inline = 0x20 COMMA
+    DW_AT_is_optional = 0x21 COMMA
+    DW_AT_lower_bound = 0x22 COMMA
+    DW_AT_producer = 0x25 COMMA
+    DW_AT_prototyped = 0x27 COMMA
+    DW_AT_return_addr = 0x2a COMMA
+    DW_AT_start_scope = 0x2c COMMA
+    DW_AT_stride_size = 0x2e COMMA
+    DW_AT_upper_bound = 0x2f COMMA
+    DW_AT_abstract_origin = 0x31 COMMA
+    DW_AT_accessibility = 0x32 COMMA
+    DW_AT_address_class = 0x33 COMMA
+    DW_AT_artificial = 0x34 COMMA
+    DW_AT_base_types = 0x35 COMMA
+    DW_AT_calling_convention = 0x36 COMMA
+    DW_AT_count = 0x37 COMMA
+    DW_AT_data_member_location = 0x38 COMMA
+    DW_AT_decl_column = 0x39 COMMA
+    DW_AT_decl_file = 0x3a COMMA
+    DW_AT_decl_line = 0x3b COMMA
+    DW_AT_declaration = 0x3c COMMA
+    DW_AT_discr_list = 0x3d COMMA
+    DW_AT_encoding = 0x3e COMMA
+    DW_AT_external = 0x3f COMMA
+    DW_AT_frame_base = 0x40 COMMA
+    DW_AT_friend = 0x41 COMMA
+    DW_AT_identifier_case = 0x42 COMMA
+    DW_AT_macro_info = 0x43 COMMA
+    DW_AT_namelist_items = 0x44 COMMA
+    DW_AT_priority = 0x45 COMMA
+    DW_AT_segment = 0x46 COMMA
+    DW_AT_specification = 0x47 COMMA
+    DW_AT_static_link = 0x48 COMMA
+    DW_AT_type = 0x49 COMMA
+    DW_AT_use_location = 0x4a COMMA
+    DW_AT_variable_parameter = 0x4b COMMA
+    DW_AT_virtuality = 0x4c COMMA
+    DW_AT_vtable_elem_location = 0x4d COMMA
+    /* DWARF 3 values.	*/
+    DW_AT_allocated	= 0x4e COMMA
+    DW_AT_associated	= 0x4f COMMA
+    DW_AT_data_location = 0x50 COMMA
+    DW_AT_stride	= 0x51 COMMA
+    DW_AT_entry_pc	= 0x52 COMMA
+    DW_AT_use_UTF8	= 0x53 COMMA
+    DW_AT_extension	= 0x54 COMMA
+    DW_AT_ranges	= 0x55 COMMA
+    DW_AT_trampoline	= 0x56 COMMA
+    DW_AT_call_column	= 0x57 COMMA
+    DW_AT_call_file	= 0x58 COMMA
+    DW_AT_call_line	= 0x59 COMMA
+    /* SGI/MIPS extensions.  */
+    DW_AT_MIPS_fde = 0x2001 COMMA
+    DW_AT_MIPS_loop_begin = 0x2002 COMMA
+    DW_AT_MIPS_tail_loop_begin = 0x2003 COMMA
+    DW_AT_MIPS_epilog_begin = 0x2004 COMMA
+    DW_AT_MIPS_loop_unroll_factor = 0x2005 COMMA
+    DW_AT_MIPS_software_pipeline_depth = 0x2006 COMMA
+    DW_AT_MIPS_linkage_name = 0x2007 COMMA
+    DW_AT_MIPS_stride = 0x2008 COMMA
+    DW_AT_MIPS_abstract_name = 0x2009 COMMA
+    DW_AT_MIPS_clone_origin = 0x200a COMMA
+    DW_AT_MIPS_has_inlines = 0x200b COMMA
+    /* GNU extensions.	*/
+    DW_AT_sf_names   = 0x2101 COMMA
+    DW_AT_src_info   = 0x2102 COMMA
+    DW_AT_mac_info   = 0x2103 COMMA
+    DW_AT_src_coords = 0x2104 COMMA
+    DW_AT_body_begin = 0x2105 COMMA
+    DW_AT_body_end   = 0x2106 COMMA
+    DW_AT_GNU_vector = 0x2107 COMMA
+    /* VMS extensions.	*/
+    DW_AT_VMS_rtnbeg_pd_address = 0x2201 COMMA
+    /* UPC extension.  */
+    DW_AT_upc_threads_scaled = 0x3210
+IF_NOT_ASM(};)
+
+#define DW_AT_lo_user	0x2000	/* Implementation-defined range start.	*/
+#define DW_AT_hi_user	0x3ff0	/* Implementation-defined range end.  */
+
+/* Location atom names and codes.  */
+ENUM(dwarf_location_atom)
+
+    DW_OP_addr = 0x03 COMMA
+    DW_OP_deref = 0x06 COMMA
+    DW_OP_const1u = 0x08 COMMA
+    DW_OP_const1s = 0x09 COMMA
+    DW_OP_const2u = 0x0a COMMA
+    DW_OP_const2s = 0x0b COMMA
+    DW_OP_const4u = 0x0c COMMA
+    DW_OP_const4s = 0x0d COMMA
+    DW_OP_const8u = 0x0e COMMA
+    DW_OP_const8s = 0x0f COMMA
+    DW_OP_constu = 0x10 COMMA
+    DW_OP_consts = 0x11 COMMA
+    DW_OP_dup = 0x12 COMMA
+    DW_OP_drop = 0x13 COMMA
+    DW_OP_over = 0x14 COMMA
+    DW_OP_pick = 0x15 COMMA
+    DW_OP_swap = 0x16 COMMA
+    DW_OP_rot = 0x17 COMMA
+    DW_OP_xderef = 0x18 COMMA
+    DW_OP_abs = 0x19 COMMA
+    DW_OP_and = 0x1a COMMA
+    DW_OP_div = 0x1b COMMA
+    DW_OP_minus = 0x1c COMMA
+    DW_OP_mod = 0x1d COMMA
+    DW_OP_mul = 0x1e COMMA
+    DW_OP_neg = 0x1f COMMA
+    DW_OP_not = 0x20 COMMA
+    DW_OP_or = 0x21 COMMA
+    DW_OP_plus = 0x22 COMMA
+    DW_OP_plus_uconst = 0x23 COMMA
+    DW_OP_shl = 0x24 COMMA
+    DW_OP_shr = 0x25 COMMA
+    DW_OP_shra = 0x26 COMMA
+    DW_OP_xor = 0x27 COMMA
+    DW_OP_bra = 0x28 COMMA
+    DW_OP_eq = 0x29 COMMA
+    DW_OP_ge = 0x2a COMMA
+    DW_OP_gt = 0x2b COMMA
+    DW_OP_le = 0x2c COMMA
+    DW_OP_lt = 0x2d COMMA
+    DW_OP_ne = 0x2e COMMA
+    DW_OP_skip = 0x2f COMMA
+    DW_OP_lit0 = 0x30 COMMA
+    DW_OP_lit1 = 0x31 COMMA
+    DW_OP_lit2 = 0x32 COMMA
+    DW_OP_lit3 = 0x33 COMMA
+    DW_OP_lit4 = 0x34 COMMA
+    DW_OP_lit5 = 0x35 COMMA
+    DW_OP_lit6 = 0x36 COMMA
+    DW_OP_lit7 = 0x37 COMMA
+    DW_OP_lit8 = 0x38 COMMA
+    DW_OP_lit9 = 0x39 COMMA
+    DW_OP_lit10 = 0x3a COMMA
+    DW_OP_lit11 = 0x3b COMMA
+    DW_OP_lit12 = 0x3c COMMA
+    DW_OP_lit13 = 0x3d COMMA
+    DW_OP_lit14 = 0x3e COMMA
+    DW_OP_lit15 = 0x3f COMMA
+    DW_OP_lit16 = 0x40 COMMA
+    DW_OP_lit17 = 0x41 COMMA
+    DW_OP_lit18 = 0x42 COMMA
+    DW_OP_lit19 = 0x43 COMMA
+    DW_OP_lit20 = 0x44 COMMA
+    DW_OP_lit21 = 0x45 COMMA
+    DW_OP_lit22 = 0x46 COMMA
+    DW_OP_lit23 = 0x47 COMMA
+    DW_OP_lit24 = 0x48 COMMA
+    DW_OP_lit25 = 0x49 COMMA
+    DW_OP_lit26 = 0x4a COMMA
+    DW_OP_lit27 = 0x4b COMMA
+    DW_OP_lit28 = 0x4c COMMA
+    DW_OP_lit29 = 0x4d COMMA
+    DW_OP_lit30 = 0x4e COMMA
+    DW_OP_lit31 = 0x4f COMMA
+    DW_OP_reg0 = 0x50 COMMA
+    DW_OP_reg1 = 0x51 COMMA
+    DW_OP_reg2 = 0x52 COMMA
+    DW_OP_reg3 = 0x53 COMMA
+    DW_OP_reg4 = 0x54 COMMA
+    DW_OP_reg5 = 0x55 COMMA
+    DW_OP_reg6 = 0x56 COMMA
+    DW_OP_reg7 = 0x57 COMMA
+    DW_OP_reg8 = 0x58 COMMA
+    DW_OP_reg9 = 0x59 COMMA
+    DW_OP_reg10 = 0x5a COMMA
+    DW_OP_reg11 = 0x5b COMMA
+    DW_OP_reg12 = 0x5c COMMA
+    DW_OP_reg13 = 0x5d COMMA
+    DW_OP_reg14 = 0x5e COMMA
+    DW_OP_reg15 = 0x5f COMMA
+    DW_OP_reg16 = 0x60 COMMA
+    DW_OP_reg17 = 0x61 COMMA
+    DW_OP_reg18 = 0x62 COMMA
+    DW_OP_reg19 = 0x63 COMMA
+    DW_OP_reg20 = 0x64 COMMA
+    DW_OP_reg21 = 0x65 COMMA
+    DW_OP_reg22 = 0x66 COMMA
+    DW_OP_reg23 = 0x67 COMMA
+    DW_OP_reg24 = 0x68 COMMA
+    DW_OP_reg25 = 0x69 COMMA
+    DW_OP_reg26 = 0x6a COMMA
+    DW_OP_reg27 = 0x6b COMMA
+    DW_OP_reg28 = 0x6c COMMA
+    DW_OP_reg29 = 0x6d COMMA
+    DW_OP_reg30 = 0x6e COMMA
+    DW_OP_reg31 = 0x6f COMMA
+    DW_OP_breg0 = 0x70 COMMA
+    DW_OP_breg1 = 0x71 COMMA
+    DW_OP_breg2 = 0x72 COMMA
+    DW_OP_breg3 = 0x73 COMMA
+    DW_OP_breg4 = 0x74 COMMA
+    DW_OP_breg5 = 0x75 COMMA
+    DW_OP_breg6 = 0x76 COMMA
+    DW_OP_breg7 = 0x77 COMMA
+    DW_OP_breg8 = 0x78 COMMA
+    DW_OP_breg9 = 0x79 COMMA
+    DW_OP_breg10 = 0x7a COMMA
+    DW_OP_breg11 = 0x7b COMMA
+    DW_OP_breg12 = 0x7c COMMA
+    DW_OP_breg13 = 0x7d COMMA
+    DW_OP_breg14 = 0x7e COMMA
+    DW_OP_breg15 = 0x7f COMMA
+    DW_OP_breg16 = 0x80 COMMA
+    DW_OP_breg17 = 0x81 COMMA
+    DW_OP_breg18 = 0x82 COMMA
+    DW_OP_breg19 = 0x83 COMMA
+    DW_OP_breg20 = 0x84 COMMA
+    DW_OP_breg21 = 0x85 COMMA
+    DW_OP_breg22 = 0x86 COMMA
+    DW_OP_breg23 = 0x87 COMMA
+    DW_OP_breg24 = 0x88 COMMA
+    DW_OP_breg25 = 0x89 COMMA
+    DW_OP_breg26 = 0x8a COMMA
+    DW_OP_breg27 = 0x8b COMMA
+    DW_OP_breg28 = 0x8c COMMA
+    DW_OP_breg29 = 0x8d COMMA
+    DW_OP_breg30 = 0x8e COMMA
+    DW_OP_breg31 = 0x8f COMMA
+    DW_OP_regx = 0x90 COMMA
+    DW_OP_fbreg = 0x91 COMMA
+    DW_OP_bregx = 0x92 COMMA
+    DW_OP_piece = 0x93 COMMA
+    DW_OP_deref_size = 0x94 COMMA
+    DW_OP_xderef_size = 0x95 COMMA
+    DW_OP_nop = 0x96 COMMA
+    /* DWARF 3 extensions.  */
+    DW_OP_push_object_address = 0x97 COMMA
+    DW_OP_call2 = 0x98 COMMA
+    DW_OP_call4 = 0x99 COMMA
+    DW_OP_call_ref = 0x9a COMMA
+    /* GNU extensions.	*/
+    DW_OP_GNU_push_tls_address = 0xe0
+IF_NOT_ASM(};)
+
+#define DW_OP_lo_user	0xe0	/* Implementation-defined range start.	*/
+#define DW_OP_hi_user	0xff	/* Implementation-defined range end.  */
+
+/* Type encodings.  */
+ENUM(dwarf_type)
+
+    DW_ATE_void = 0x0 COMMA
+    DW_ATE_address = 0x1 COMMA
+    DW_ATE_boolean = 0x2 COMMA
+    DW_ATE_complex_float = 0x3 COMMA
+    DW_ATE_float = 0x4 COMMA
+    DW_ATE_signed = 0x5 COMMA
+    DW_ATE_signed_char = 0x6 COMMA
+    DW_ATE_unsigned = 0x7 COMMA
+    DW_ATE_unsigned_char = 0x8 COMMA
+    /* DWARF 3.  */
+    DW_ATE_imaginary_float = 0x9
+IF_NOT_ASM(};)
+
+#define	DW_ATE_lo_user 0x80
+#define	DW_ATE_hi_user 0xff
+
+/* Array ordering names and codes.  */
+ENUM(dwarf_array_dim_ordering)
+
+    DW_ORD_row_major = 0 COMMA
+    DW_ORD_col_major = 1
+IF_NOT_ASM(};)
+
+/* Access attribute.  */
+ENUM(dwarf_access_attribute)
+
+    DW_ACCESS_public = 1 COMMA
+    DW_ACCESS_protected = 2 COMMA
+    DW_ACCESS_private = 3
+IF_NOT_ASM(};)
+
+/* Visibility.	*/
+ENUM(dwarf_visibility_attribute)
+
+    DW_VIS_local = 1 COMMA
+    DW_VIS_exported = 2 COMMA
+    DW_VIS_qualified = 3
+IF_NOT_ASM(};)
+
+/* Virtuality.	*/
+ENUM(dwarf_virtuality_attribute)
+
+    DW_VIRTUALITY_none = 0 COMMA
+    DW_VIRTUALITY_virtual = 1 COMMA
+    DW_VIRTUALITY_pure_virtual = 2
+IF_NOT_ASM(};)
+
+/* Case sensitivity.  */
+ENUM(dwarf_id_case)
+
+    DW_ID_case_sensitive = 0 COMMA
+    DW_ID_up_case = 1 COMMA
+    DW_ID_down_case = 2 COMMA
+    DW_ID_case_insensitive = 3
+IF_NOT_ASM(};)
+
+/* Calling convention.	*/
+ENUM(dwarf_calling_convention)
+
+    DW_CC_normal = 0x1 COMMA
+    DW_CC_program = 0x2 COMMA
+    DW_CC_nocall = 0x3
+IF_NOT_ASM(};)
+
+#define DW_CC_lo_user 0x40
+#define DW_CC_hi_user 0xff
+
+/* Inline attribute.  */
+ENUM(dwarf_inline_attribute)
+
+    DW_INL_not_inlined = 0 COMMA
+    DW_INL_inlined = 1 COMMA
+    DW_INL_declared_not_inlined = 2 COMMA
+    DW_INL_declared_inlined = 3
+IF_NOT_ASM(};)
+
+/* Discriminant lists.	*/
+ENUM(dwarf_discrim_list)
+
+    DW_DSC_label = 0 COMMA
+    DW_DSC_range = 1
+IF_NOT_ASM(};)
+
+/* Line number opcodes.  */
+ENUM(dwarf_line_number_ops)
+
+    DW_LNS_extended_op = 0 COMMA
+    DW_LNS_copy = 1 COMMA
+    DW_LNS_advance_pc = 2 COMMA
+    DW_LNS_advance_line = 3 COMMA
+    DW_LNS_set_file = 4 COMMA
+    DW_LNS_set_column = 5 COMMA
+    DW_LNS_negate_stmt = 6 COMMA
+    DW_LNS_set_basic_block = 7 COMMA
+    DW_LNS_const_add_pc = 8 COMMA
+    DW_LNS_fixed_advance_pc = 9 COMMA
+    /* DWARF 3.  */
+    DW_LNS_set_prologue_end = 10 COMMA
+    DW_LNS_set_epilogue_begin = 11 COMMA
+    DW_LNS_set_isa = 12
+IF_NOT_ASM(};)
+
+/* Line number extended opcodes.  */
+ENUM(dwarf_line_number_x_ops)
+
+    DW_LNE_end_sequence = 1 COMMA
+    DW_LNE_set_address = 2 COMMA
+    DW_LNE_define_file = 3
+IF_NOT_ASM(};)
+
+/* Call frame information.  */
+ENUM(dwarf_call_frame_info)
+
+    DW_CFA_advance_loc = 0x40 COMMA
+    DW_CFA_offset = 0x80 COMMA
+    DW_CFA_restore = 0xc0 COMMA
+    DW_CFA_nop = 0x00 COMMA
+    DW_CFA_set_loc = 0x01 COMMA
+    DW_CFA_advance_loc1 = 0x02 COMMA
+    DW_CFA_advance_loc2 = 0x03 COMMA
+    DW_CFA_advance_loc4 = 0x04 COMMA
+    DW_CFA_offset_extended = 0x05 COMMA
+    DW_CFA_restore_extended = 0x06 COMMA
+    DW_CFA_undefined = 0x07 COMMA
+    DW_CFA_same_value = 0x08 COMMA
+    DW_CFA_register = 0x09 COMMA
+    DW_CFA_remember_state = 0x0a COMMA
+    DW_CFA_restore_state = 0x0b COMMA
+    DW_CFA_def_cfa = 0x0c COMMA
+    DW_CFA_def_cfa_register = 0x0d COMMA
+    DW_CFA_def_cfa_offset = 0x0e COMMA
+
+    /* DWARF 3.  */
+    DW_CFA_def_cfa_expression = 0x0f COMMA
+    DW_CFA_expression = 0x10 COMMA
+    DW_CFA_offset_extended_sf = 0x11 COMMA
+    DW_CFA_def_cfa_sf = 0x12 COMMA
+    DW_CFA_def_cfa_offset_sf = 0x13 COMMA
+
+    /* SGI/MIPS specific.  */
+    DW_CFA_MIPS_advance_loc8 = 0x1d COMMA
+
+    /* GNU extensions.	*/
+    DW_CFA_GNU_window_save = 0x2d COMMA
+    DW_CFA_GNU_args_size = 0x2e COMMA
+    DW_CFA_GNU_negative_offset_extended = 0x2f
+IF_NOT_ASM(};)
+
+#define DW_CIE_ID	  0xffffffff
+#define DW_CIE_VERSION	  1
+
+#define DW_CFA_extended   0
+#define DW_CFA_lo_user	  0x1c
+#define DW_CFA_hi_user	  0x3f
+
+#define DW_CHILDREN_no		     0x00
+#define DW_CHILDREN_yes		     0x01
+
+#define DW_ADDR_none		0
+
+/* Source language names and codes.  */
+ENUM(dwarf_source_language)
+
+    DW_LANG_C89 = 0x0001 COMMA
+    DW_LANG_C = 0x0002 COMMA
+    DW_LANG_Ada83 = 0x0003 COMMA
+    DW_LANG_C_plus_plus = 0x0004 COMMA
+    DW_LANG_Cobol74 = 0x0005 COMMA
+    DW_LANG_Cobol85 = 0x0006 COMMA
+    DW_LANG_Fortran77 = 0x0007 COMMA
+    DW_LANG_Fortran90 = 0x0008 COMMA
+    DW_LANG_Pascal83 = 0x0009 COMMA
+    DW_LANG_Modula2 = 0x000a COMMA
+    DW_LANG_Java = 0x000b COMMA
+    /* DWARF 3.  */
+    DW_LANG_C99 = 0x000c COMMA
+    DW_LANG_Ada95 = 0x000d COMMA
+    DW_LANG_Fortran95 = 0x000e COMMA
+    /* MIPS.  */
+    DW_LANG_Mips_Assembler = 0x8001 COMMA
+    /* UPC.  */
+    DW_LANG_Upc = 0x8765
+IF_NOT_ASM(};)
+
+#define DW_LANG_lo_user 0x8000	/* Implementation-defined range start.	*/
+#define DW_LANG_hi_user 0xffff	/* Implementation-defined range start.	*/
+
+/* Names and codes for macro information.  */
+ENUM(dwarf_macinfo_record_type)
+
+    DW_MACINFO_define = 1 COMMA
+    DW_MACINFO_undef = 2 COMMA
+    DW_MACINFO_start_file = 3 COMMA
+    DW_MACINFO_end_file = 4 COMMA
+    DW_MACINFO_vendor_ext = 255
+IF_NOT_ASM(};)
+
+/* @@@ For use with GNU frame unwind information.  */
+
+#define DW_EH_PE_absptr		0x00
+#define DW_EH_PE_omit		0xff
+
+#define DW_EH_PE_uleb128	0x01
+#define DW_EH_PE_udata2		0x02
+#define DW_EH_PE_udata4		0x03
+#define DW_EH_PE_udata8		0x04
+#define DW_EH_PE_sleb128	0x09
+#define DW_EH_PE_sdata2		0x0A
+#define DW_EH_PE_sdata4		0x0B
+#define DW_EH_PE_sdata8		0x0C
+#define DW_EH_PE_signed		0x08
+
+#define DW_EH_PE_pcrel		0x10
+#define DW_EH_PE_textrel	0x20
+#define DW_EH_PE_datarel	0x30
+#define DW_EH_PE_funcrel	0x40
+#define DW_EH_PE_aligned	0x50
+
+#define DW_EH_PE_indirect	0x80
+
+#endif /* _ELF_DWARF2_H */
diff -Naur linux-2.6.11/include/linux/dwarf2-lang.h linux-2.6.11-om/include/linux/dwarf2-lang.h
--- linux-2.6.11/include/linux/dwarf2-lang.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/linux/dwarf2-lang.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,132 @@
+#ifndef DWARF2_LANG
+#define DWARF2_LANG
+#include <linux/dwarf2.h>
+
+/*
+ * This is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2, or (at your option) any later
+ * version.
+ */
+/*
+ * This file defines macros that allow generation of DWARF debug records
+ * for asm files.  This file is platform independent.  Register numbers
+ * (which are about the only thing that is platform dependent) are to be
+ * supplied by a platform defined file.
+ */
+#define DWARF_preamble()	.section	.debug_frame,"",@progbits
+/*
+ * This macro starts a debug frame section.  The debug_frame describes
+ * where to find the registers that the enclosing function saved on
+ * entry.
+ *
+ * ORD is use by the label generator and should be the same as what is
+ * passed to CFI_postamble.
+ *
+ * pc,	pc register gdb ordinal.
+ *
+ * code_align this is the factor used to define locations or regions
+ * where the given definitions apply.  If you use labels to define these
+ * this should be 1.
+ *
+ * data_align this is the factor used to define register offsets.  If
+ * you use struct offset, this should be the size of the register in
+ * bytes or the negative of that.  This is how it is used: you will
+ * define a register as the reference register, say the stack pointer,
+ * then you will say where a register is located relative to this
+ * reference registers value, say 40 for register 3 (the gdb register
+ * number).  The <40> will be multiplied by <data_align> to define the
+ * byte offset of the given register (3, in this example).  So if your
+ * <40> is the byte offset and the reference register points at the
+ * begining, you would want 1 for the data_offset.  If <40> was the 40th
+ * 4-byte element in that structure you would want 4.  And if your
+ * reference register points at the end of the structure you would want
+ * a negative data_align value(and you would have to do other math as
+ * well).
+ */
+
+#define CFI_preamble(ORD, pc, code_align, data_align)	\
+.section	.debug_frame,"",@progbits ;		\
+frame/**/_/**/ORD:						\
+	.long end/**/_/**/ORD-start/**/_/**/ORD;			\
+start/**/_/**/ORD:						\
+	.long	DW_CIE_ID;				\
+	.byte	DW_CIE_VERSION;			\
+	.byte 0	 ;				\
+	.uleb128 code_align;				\
+	.sleb128 data_align;				\
+	.byte pc;
+
+/*
+ * After the above macro and prior to the CFI_postamble, you need to
+ * define the initial state.  This starts with defining the reference
+ * register and, usually the pc.  Here are some helper macros:
+ */
+
+#define CFA_define_reference(reg, offset)	\
+	.byte DW_CFA_def_cfa;			\
+	.uleb128 reg;				\
+	.uleb128 (offset);
+
+#define CFA_define_offset(reg, offset)		\
+	.byte (DW_CFA_offset + reg);		\
+	.uleb128 (offset);
+
+#define CFI_postamble(ORD)			\
+	.align 4;				\
+end/**/_/**/ORD:
+/*
+ * So now your code pushs stuff on the stack, you need a new location
+ * and the rules for what to do.  This starts a running description of
+ * the call frame.  You need to describe what changes with respect to
+ * the call registers as the location of the pc moves through the code.
+ * The following builds an FDE (fram descriptor entry?).  Like the
+ * above, it has a preamble and a postamble.  It also is tied to the CFI
+ * above.
+ * The first entry after the preamble must be the location in the code
+ * that the call frame is being described for.
+ */
+#define FDE_preamble(ORD, fde_no, initial_address, length)	\
+	.long FDE_end/**/_/**/fde_no-FDE_start/**/_/**/fde_no;		\
+FDE_start/**/_/**/fde_no:						\
+	.long frame/**/_/**/ORD;					\
+	.long initial_address;					\
+	.long length;
+
+#define FDE_postamble(fde_no)			\
+	.align 4;				\
+FDE_end/**/_/**/fde_no:
+/*
+ * That done, you can now add registers, subtract registers, move the
+ * reference and even change the reference.  You can also define a new
+ * area of code the info applies to.  For discontinuous bits you should
+ * start a new FDE.  You may have as many as you like.
+ */
+
+/*
+ * To advance the address by <bytes>
+ */
+
+#define FDE_advance(bytes)			\
+	.byte DW_CFA_advance_loc4		\
+	.long bytes
+
+
+
+/*
+ * With the above you can define all the register locations.  But
+ * suppose the reference register moves... Takes the new offset NOT an
+ * increment.  This is how esp is tracked if it is not saved.
+ */
+
+#define CFA_define_cfa_offset(offset) \
+	.byte $DW_CFA_def_cfa_offset; \
+	.uleb128 (offset);
+/*
+ * Or suppose you want to use a different reference register...
+ */
+#define CFA_define_cfa_register(reg)		\
+	.byte DW_CFA_def_cfa_register;		\
+	.uleb128 reg;
+
+#endif
diff -Naur linux-2.6.11/include/linux/hpc.h linux-2.6.11-om/include/linux/hpc.h
--- linux-2.6.11/include/linux/hpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/include/linux/hpc.h	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez
+ *
+ */
+
+#ifndef _LINUX_HPC_H
+#define _LINUX_HPC_H
+
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/hpc.h>
+#include <hpc/task.h>
+#define OM_MM(task)		(task->mm)
+#else
+#define openmosix_init()	do { } while (0)
+#define OM_MM(task)		(1)
+
+#endif
+
+#endif /* _LINUX_HPC_H */
diff -Naur linux-2.6.11/include/linux/init_task.h linux-2.6.11-om/include/linux/init_task.h
--- linux-2.6.11/include/linux/init_task.h	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.11-om/include/linux/init_task.h	2005-05-15 23:18:03.000000000 +0200
@@ -2,6 +2,7 @@
 #define _LINUX__INIT_TASK_H
 
 #include <linux/file.h>
+#include <hpc/task.h>
 
 #define INIT_FILES \
 { 							\
@@ -42,6 +43,7 @@
 	.mmlist		= LIST_HEAD_INIT(name.mmlist),		\
 	.cpu_vm_mask	= CPU_MASK_ALL,				\
 	.default_kioctx = INIT_KIOCTX(name.default_kioctx, name),	\
+	OPENMOSIX_INIT_MM()					\
 }
 
 #define INIT_SIGNALS(sig) {	\
@@ -114,6 +116,7 @@
 	.journal_info	= NULL,						\
  	.private_pages	= LIST_HEAD_INIT(tsk.private_pages),		\
  	.private_pages_count = 0,					\
+	OPENMOSIX_INIT_TASK(tsk)					\
 }
 
 
diff -Naur linux-2.6.11/include/linux/net.h linux-2.6.11-om/include/linux/net.h
--- linux-2.6.11/include/linux/net.h	2005-03-02 08:38:07.000000000 +0100
+++ linux-2.6.11-om/include/linux/net.h	2005-05-15 23:18:03.000000000 +0200
@@ -176,6 +176,7 @@
 extern int	     sock_wake_async(struct socket *sk, int how, int band);
 extern int	     sock_register(struct net_proto_family *fam);
 extern int	     sock_unregister(int family);
+extern struct socket *sock_alloc(void);
 extern int	     sock_create(int family, int type, int proto,
 				 struct socket **res);
 extern int	     sock_create_kern(int family, int type, int proto,
diff -Naur linux-2.6.11/include/linux/sched.h linux-2.6.11-om/include/linux/sched.h
--- linux-2.6.11/include/linux/sched.h	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.11-om/include/linux/sched.h	2005-05-15 23:18:03.000000000 +0200
@@ -33,6 +33,10 @@
 #include <linux/percpu.h>
 #include <linux/topology.h>
 
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/omtask.h>
+#endif /* CONFIG_OPENMOSIX */
+
 struct exec_domain;
 
 /*
@@ -256,6 +260,9 @@
 
 	unsigned long hiwater_rss;	/* High-water RSS usage */
 	unsigned long hiwater_vm;	/* High-water virtual memory usage */
+#ifdef CONFIG_OPENMOSIX
+	atomic_t mm_realusers;		/* nb of processes that uses this mm */
+#endif /* CONFIG_MOSIX */
 };
 
 struct sighand_struct {
@@ -681,6 +688,9 @@
 	u64 acct_vm_mem1;	/* accumulated virtual memory usage */
 	clock_t acct_stimexpd;	/* clock_t-converted stime since last update */
 #endif
+#ifdef CONFIG_OPENMOSIX
+	om_task_t om;
+#endif /* CONFIG_OPENMOSIX */
 #ifdef CONFIG_NUMA
   	struct mempolicy *mempolicy;
 	short il_next;
diff -Naur linux-2.6.11/include/linux/serial_core.h linux-2.6.11-om/include/linux/serial_core.h
--- linux-2.6.11/include/linux/serial_core.h	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.11-om/include/linux/serial_core.h	2005-05-15 23:18:03.000000000 +0200
@@ -190,7 +190,6 @@
 	unsigned char		x_char;			/* xon/xoff char */
 	unsigned char		regshift;		/* reg offset shift */
 	unsigned char		iotype;			/* io access style */
-
 #define UPIO_PORT		(0)
 #define UPIO_HUB6		(1)
 #define UPIO_MEM		(2)
diff -Naur linux-2.6.11/include/linux/signal.h linux-2.6.11-om/include/linux/signal.h
--- linux-2.6.11/include/linux/signal.h	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/include/linux/signal.h	2005-05-15 23:18:03.000000000 +0200
@@ -211,6 +211,9 @@
 	INIT_LIST_HEAD(&sig->list);
 }
 
+#ifdef CONFIG_OPENMOSIX
+extern int __group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
+#endif
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern long do_sigpending(void __user *, unsigned long);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
diff -Naur linux-2.6.11/include/linux/spinlock.h linux-2.6.11-om/include/linux/spinlock.h
--- linux-2.6.11/include/linux/spinlock.h	2005-03-02 08:38:09.000000000 +0100
+++ linux-2.6.11-om/include/linux/spinlock.h	2005-05-15 23:18:03.000000000 +0200
@@ -15,6 +15,12 @@
 
 #include <asm/processor.h>	/* for cpu relax */
 #include <asm/system.h>
+#ifdef CONFIG_KGDB
+#include <asm/current.h>
+#define SET_WHO(x, him) (x)->who = him;
+#else
+#define SET_WHO(x, him)
+#endif
 
 /*
  * Must define these before including other files, inline functions need them
@@ -98,6 +104,9 @@
 	const char *module;
 	char *owner;
 	int oline;
+#ifdef CONFIG_KGDB
+	struct task_struct *who;
+#endif
 } spinlock_t;
 #define SPIN_LOCK_UNLOCKED (spinlock_t) { SPINLOCK_MAGIC, 0, 10, __FILE__ , NULL, 0}
 
@@ -109,6 +118,7 @@
 		(x)->module = __FILE__; \
 		(x)->owner = NULL; \
 		(x)->oline = 0; \
+                SET_WHO(x, NULL) \
 	} while (0)
 
 #define CHECK_LOCK(x) \
@@ -131,6 +141,7 @@
 		(x)->lock = 1; \
 		(x)->owner = __FILE__; \
 		(x)->oline = __LINE__; \
+                SET_WHO(x, current)       \
 	} while (0)
 
 /* without debugging, spin_is_locked on UP always says
@@ -169,6 +180,7 @@
 		(x)->lock = 1; \
 		(x)->owner = __FILE__; \
 		(x)->oline = __LINE__; \
+                SET_WHO(x, current)       \
 		1; \
 	})
 
diff -Naur linux-2.6.11/init/main.c linux-2.6.11-om/init/main.c
--- linux-2.6.11/init/main.c	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.11-om/init/main.c	2005-05-15 23:18:03.000000000 +0200
@@ -51,6 +51,8 @@
 #include <asm/bugs.h>
 #include <asm/setup.h>
 
+#include <linux/hpc.h>
+
 /*
  * This is one of the first .c files built. Error out early
  * if we have compiler trouble..
@@ -446,13 +448,13 @@
 	preempt_disable();
 	build_all_zonelists();
 	page_alloc_init();
+	trap_init();
 	printk("Kernel command line: %s\n", saved_command_line);
 	parse_early_param();
 	parse_args("Booting kernel", command_line, __start___param,
 		   __stop___param - __start___param,
 		   &unknown_bootoption);
 	sort_main_extable();
-	trap_init();
 	rcu_init();
 	init_IRQ();
 	pidhash_init();
@@ -667,6 +669,9 @@
 	 * initmem segments and start the user-mode stuff..
 	 */
 	free_initmem();
+
+	openmosix_init();
+	
 	unlock_kernel();
 	system_state = SYSTEM_RUNNING;
 	numa_default_policy();
diff -Naur linux-2.6.11/kernel/exit.c linux-2.6.11-om/kernel/exit.c
--- linux-2.6.11/kernel/exit.c	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.11-om/kernel/exit.c	2005-05-15 23:18:03.000000000 +0200
@@ -32,6 +32,8 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#include <linux/hpc.h>
+
 extern void sem_exit (void);
 extern struct task_struct *child_reaper;
 
@@ -476,6 +478,9 @@
 {
 	struct mm_struct *mm = tsk->mm;
 
+#ifdef CONFIG_OPENMOSIX
+	if (!task_test_dflags(tsk, DDEPUTY))
+#endif
 	mm_release(tsk, mm);
 	if (!mm)
 		return;
@@ -808,6 +813,9 @@
 
 	acct_update_integrals();
 	update_mem_hiwater();
+#ifdef CONFIG_OPENMOSIX
+	openmosix_task_exit();
+#endif
 	group_dead = atomic_dec_and_test(&tsk->signal->live);
 	if (group_dead)
 		acct_process(code);
diff -Naur linux-2.6.11/kernel/fork.c linux-2.6.11-om/kernel/fork.c
--- linux-2.6.11/kernel/fork.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.11-om/kernel/fork.c	2005-05-15 23:18:03.000000000 +0200
@@ -48,6 +48,8 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
+#include <linux/hpc.h>
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -292,6 +294,9 @@
 {
 	atomic_set(&mm->mm_users, 1);
 	atomic_set(&mm->mm_count, 1);
+#ifdef CONFIG_OPENMOSIX
+	atomic_set(&mm->mm_realusers, 1);
+#endif /* CONFIG_OPENMOSIX */
 	init_rwsem(&mm->mmap_sem);
 	INIT_LIST_HEAD(&mm->mmlist);
 	mm->core_waiters = 0;
@@ -443,6 +448,9 @@
 
 	if (clone_flags & CLONE_VM) {
 		atomic_inc(&oldmm->mm_users);
+#ifdef CONFIG_OPENMOSIX
+		atomic_inc(&oldmm->mm_realusers);
+#endif /* CONFIG_OPENMOSIX */
 		mm = oldmm;
 		/*
 		 * There are cases where the PTL is held to ensure no
@@ -470,6 +478,9 @@
 	retval = dup_mmap(mm, oldmm);
 	if (retval)
 		goto free_pt;
+#ifdef CONFIG_OPENMOSIX
+	task_clear_stay(tsk, DSTAY_CLONE);
+#endif /* CONFIG_OPENMOSIX */
 
 	mm->hiwater_rss = mm->rss;
 	mm->hiwater_vm = mm->total_vm;
@@ -906,6 +917,10 @@
 		goto bad_fork_cleanup_policy;
 	if ((retval = audit_alloc(p)))
 		goto bad_fork_cleanup_security;
+#ifdef CONFIG_OPENMOSIX
+	if ((retval = openmosix_task_init(p)))
+		goto bad_fork_cleanup_audit;
+#endif /* CONFIG_OPENMOSIX */
 	/* copy all the process information */
 	if ((retval = copy_semundo(clone_flags, p)))
 		goto bad_fork_cleanup_audit;
@@ -1139,6 +1154,9 @@
 		if (trace)
 			clone_flags |= CLONE_PTRACE;
 	}
+#ifdef CONFIG_OPENMOSIX
+	openmosix_pre_clone(clone_flags);
+#endif
 
 	p = copy_process(clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr, pid);
 	/*
@@ -1180,6 +1198,9 @@
 		free_pidmap(pid);
 		pid = PTR_ERR(p);
 	}
+#ifdef CONFIG_OPENMOSIX
+	openmosix_post_clone(clone_flags);
+#endif
 	return pid;
 }
 
diff -Naur linux-2.6.11/kernel/pid.c linux-2.6.11-om/kernel/pid.c
--- linux-2.6.11/kernel/pid.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.11-om/kernel/pid.c	2005-05-15 23:18:03.000000000 +0200
@@ -252,6 +252,9 @@
  * machine.  From a minimum of 16 slots up to 4096 slots at one gigabyte or
  * more.
  */
+#ifdef CONFIG_KGDB
+int kgdb_pid_init_done; /* so we don't call prior to... */
+#endif
 void __init pidhash_init(void)
 {
 	int i, j, pidhash_size;
@@ -273,6 +276,9 @@
 		for (j = 0; j < pidhash_size; j++)
 			INIT_HLIST_HEAD(&pid_hash[i][j]);
 	}
+#ifdef CONFIG_KGDB
+	kgdb_pid_init_done++;
+#endif
 }
 
 void __init pidmap_init(void)
diff -Naur linux-2.6.11/kernel/sched.c linux-2.6.11-om/kernel/sched.c
--- linux-2.6.11/kernel/sched.c	2005-03-02 08:38:19.000000000 +0100
+++ linux-2.6.11-om/kernel/sched.c	2005-05-15 23:18:03.000000000 +0200
@@ -302,7 +302,7 @@
  * interrupts.  Note the ordering: we can safely lookup the task_rq without
  * explicitly disabling preemption.
  */
-static runqueue_t *task_rq_lock(task_t *p, unsigned long *flags)
+OM_NSTATIC runqueue_t *task_rq_lock(task_t *p, unsigned long *flags)
 	__acquires(rq->lock)
 {
 	struct runqueue *rq;
@@ -318,7 +318,7 @@
 	return rq;
 }
 
-static inline void task_rq_unlock(runqueue_t *rq, unsigned long *flags)
+OM_NSTATIC inline void task_rq_unlock(runqueue_t *rq, unsigned long *flags)
 	__releases(rq->lock)
 {
 	spin_unlock_irqrestore(&rq->lock, *flags);
@@ -3273,6 +3273,13 @@
 
 EXPORT_SYMBOL(set_user_nice);
 
+#ifdef CONFIG_KGDB
+struct task_struct *kgdb_get_idle(int this_cpu)
+{
+        return cpu_rq(this_cpu)->idle;
+}
+#endif
+
 #ifdef __ARCH_WANT_SYS_NICE
 
 /*
diff -Naur linux-2.6.11/kernel/signal.c linux-2.6.11-om/kernel/signal.c
--- linux-2.6.11/kernel/signal.c	2005-03-02 08:38:07.000000000 +0100
+++ linux-2.6.11-om/kernel/signal.c	2005-05-15 23:18:03.000000000 +0200
@@ -1036,7 +1036,7 @@
 	return;
 }
 
-static int
+OM_NSTATIC int
 __group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)
 {
 	int ret = 0;
diff -Naur linux-2.6.11/MAINTAINERS linux-2.6.11-om/MAINTAINERS
--- linux-2.6.11/MAINTAINERS	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.11-om/MAINTAINERS	2005-05-15 23:18:03.000000000 +0200
@@ -1284,6 +1284,12 @@
 W:	http://developer.osdl.org/rddunlap/kj-patches/
 S:	Maintained
 
+KGDB FOR I386 PLATFORM
+P:	George Anzinger
+M:	george@mvista.com
+L:	linux-net@vger.kernel.org
+S:	Supported
+
 KERNEL NFSD
 P:	Neil Brown
 M:	neilb@cse.unsw.edu.au
@@ -1673,6 +1679,15 @@
 L:	linux-scsi@vger.kernel.org
 S:	Maintained
 
+OPENMOSIX
+P:	Vincent Hanquez
+M:	tab@snarc.org
+P:	Alexander Nyberg
+M:	alexn@telia.com
+L:	openmosix-general@lists.sourceforge.net
+W:	http://openmosix.sourceforge.net/
+S:	Maintained
+
 OPL3-SA2, SA3, and SAx DRIVER
 P:	Zwane Mwaikambo
 M:	zwane@commfireservices.com
diff -Naur linux-2.6.11/Makefile linux-2.6.11-om/Makefile
--- linux-2.6.11/Makefile	2005-03-02 08:38:13.000000000 +0100
+++ linux-2.6.11-om/Makefile	2005-05-15 23:18:03.000000000 +0200
@@ -505,6 +505,9 @@
 # Defaults vmlinux but it is usually overriden in the arch makefile
 all: vmlinux
 
+unsparse:
+	scripts/unsparse
+
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 CFLAGS		+= -Os
 else
@@ -526,6 +529,7 @@
 
 ifdef CONFIG_DEBUG_INFO
 CFLAGS		+= -g
+AFLAGS		+= -g
 endif
 
 include $(srctree)/arch/$(ARCH)/Makefile
@@ -561,7 +565,7 @@
 
 
 ifeq ($(KBUILD_EXTMOD),)
-core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/
+core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ hpc/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff -Naur linux-2.6.11/mm/mlock.c linux-2.6.11-om/mm/mlock.c
--- linux-2.6.11/mm/mlock.c	2005-03-02 08:37:47.000000000 +0100
+++ linux-2.6.11-om/mm/mlock.c	2005-05-15 23:18:03.000000000 +0200
@@ -9,6 +9,7 @@
 #include <linux/mm.h>
 #include <linux/syscalls.h>
 
+#include <linux/hpc.h>
 
 static int mlock_fixup(struct vm_area_struct * vma, 
 	unsigned long start, unsigned long end, unsigned int newflags)
@@ -123,6 +124,10 @@
 	/* check against resource limits */
 	if ((locked <= lock_limit) || capable(CAP_IPC_LOCK))
 		error = do_mlock(start, len, 1);
+#ifdef CONFIG_OPENMOSIX
+	if (!error) /* FIXME len == 0 shouldn't DSTAY MLOCK current & clones */
+		stay_me_and_my_clones(DSTAY_MLOCK);
+#endif /* CONFIG_OPENMOSIX */
 	up_write(&current->mm->mmap_sem);
 	return error;
 }
@@ -136,6 +141,10 @@
 	start &= PAGE_MASK;
 	ret = do_mlock(start, len, 0);
 	up_write(&current->mm->mmap_sem);
+#ifdef CONFIG_OPENMOSIX
+	if (ret)
+		unstay_mm(current->mm);
+#endif /* CONFIG_OPENMOSIX */
 	return ret;
 }
 
@@ -185,6 +194,10 @@
 	if (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||
 	    capable(CAP_IPC_LOCK))
 		ret = do_mlockall(flags);
+#ifdef CONFIG_OPENMOSIX
+	if (!ret)
+		stay_me_and_my_clones(DSTAY_MLOCK);
+#endif /* CONFIG_OPENMOSIX */
 	up_write(&current->mm->mmap_sem);
 out:
 	return ret;
@@ -197,9 +210,12 @@
 	down_write(&current->mm->mmap_sem);
 	ret = do_mlockall(0);
 	up_write(&current->mm->mmap_sem);
+#ifdef CONFIG_OPENMOSIX
+	if (ret)
+		unstay_mm(current->mm);
+#endif /* CONFIG_OPENMOSIX */
 	return ret;
 }
-
 /*
  * Objects with different lifetime than processes (SHM_LOCK and SHM_HUGETLB
  * shm segments) get accounted against the user_struct instead.
diff -Naur linux-2.6.11/mm/mmap.c linux-2.6.11-om/mm/mmap.c
--- linux-2.6.11/mm/mmap.c	2005-03-02 08:38:12.000000000 +0100
+++ linux-2.6.11-om/mm/mmap.c	2005-05-15 23:18:03.000000000 +0200
@@ -30,6 +30,8 @@
 #include <asm/cacheflush.h>
 #include <asm/tlb.h>
 
+#include <linux/hpc.h>
+
 /*
  * WARNING: the debugging will use recursive algorithms so never enable this
  * unless you know what you are doing.
@@ -167,9 +169,22 @@
 
 	flush_dcache_mmap_lock(mapping);
 	if (unlikely(vma->vm_flags & VM_NONLINEAR))
+	{
 		list_del_init(&vma->shared.vm_set.list);
+#ifdef CONFIG_OPENMOSIX
+		if (list_empty(&vma->shared.vm_set.list))
+			openmosix_no_longer_monkey(file->f_dentry->d_inode);
+#endif /* CONFIG_OPENMOSIX */
+	}
 	else
+	{
 		vma_prio_tree_remove(vma, &mapping->i_mmap);
+#ifdef CONFIG_OPENMOSIX
+		/* FIXME tab: maybe wrong ! */
+		if (vma->shared.vm_set.parent && vma->shared.vm_set.head)
+			openmosix_no_longer_monkey(file->f_dentry->d_inode);
+#endif /* CONFIG_OPENMOSIX */
+	}
 	flush_dcache_mmap_unlock(mapping);
 }
 
@@ -874,6 +889,9 @@
 	struct rb_node ** rb_link, * rb_parent;
 	int accountable = 1;
 	unsigned long charged = 0;
+#ifdef CONFIG_OPENMOSIX
+	int stay_reason = 0;
+#endif /* CONFIG_OPENMOSIX */
 
 	if (file) {
 		if (is_file_hugepages(file))
@@ -909,7 +927,7 @@
 		return -EINVAL;
 
 	/* Too many mappings? */
-	if (mm->map_count > sysctl_max_map_count)
+	if (OM_MM(current) && mm->map_count > sysctl_max_map_count)
 		return -ENOMEM;
 
 	/* Obtain the address to map to. we verify (or select) it and ensure
@@ -924,7 +942,7 @@
 	 * of the memory object, so we don't do any here.
 	 */
 	vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |
-			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
+			(OM_MM(current) ? mm->def_flags : 0) | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
 	if (flags & MAP_LOCKED) {
 		if (!can_do_mlock())
@@ -932,7 +950,7 @@
 		vm_flags |= VM_LOCKED;
 	}
 	/* mlock MCL_FUTURE? */
-	if (vm_flags & VM_LOCKED) {
+	if (OM_MM(current) && vm_flags & VM_LOCKED) {
 		unsigned long locked, lock_limit;
 		locked = mm->locked_vm << PAGE_SHIFT;
 		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
@@ -965,9 +983,19 @@
 			vm_flags |= VM_SHARED | VM_MAYSHARE;
 			if (!(file->f_mode & FMODE_WRITE))
 				vm_flags &= ~(VM_MAYWRITE | VM_SHARED);
+#ifdef CONFIG_OPENMOSIX
+			if (file->f_mode & FMODE_WRITE)
+				stay_reason |= DSTAY_MONKEY;
+#endif /* CONFIG_OPENMOSIX */
 
 			/* fall through */
 		case MAP_PRIVATE:
+#ifdef CONFIG_OPENMOSIX
+			if (inode && inode->i_mapping->i_mmap_writable != 0)
+				stay_reason |= DSTAY_MONKEY;
+			if (S_ISCHR(file->f_dentry->d_inode->i_mode))
+				stay_reason |= DSTAY_DEV;
+#endif /* CONFIG_OPENMOSIX */
 			if (!(file->f_mode & FMODE_READ))
 				return -EACCES;
 			break;
@@ -994,6 +1022,10 @@
 	error = security_file_mmap(file, prot, flags);
 	if (error)
 		return error;
+#ifdef CONFIG_OPENMOSIX
+	if (task_test_dflags(current, DDEPUTY))
+		return deputy_do_mmap_pgoff(file, addr, len, prot, vm_flags, pgoff);
+#endif
 		
 	/* Clear old maps */
 	error = -ENOMEM;
@@ -1115,6 +1147,10 @@
 		mm->locked_vm += len >> PAGE_SHIFT;
 		make_pages_present(addr, addr + len);
 	}
+#ifdef CONFIG_OPENMOSIX
+	if (stay_reason)
+		stay_me_and_my_clones(stay_reason);
+#endif /* CONFIG_OPENMOSIX */
 	if (flags & MAP_POPULATE) {
 		up_write(&mm->mmap_sem);
 		sys_remap_file_pages(addr, len, 0,
@@ -1340,7 +1376,10 @@
 			return -EINVAL;
 		return addr;
 	}
-
+#ifdef CONFIG_OPENMOSIX
+	if (task_test_dflags(current, DDEPUTY))
+		return PAGE_ALIGN(addr);
+#endif
 	if (file && file->f_op && file->f_op->get_unmapped_area)
 		return file->f_op->get_unmapped_area(file, addr, len,
 						pgoff, flags);
diff -Naur linux-2.6.11/net/core/dev.c linux-2.6.11-om/net/core/dev.c
--- linux-2.6.11/net/core/dev.c	2005-03-02 08:38:09.000000000 +0100
+++ linux-2.6.11-om/net/core/dev.c	2005-05-15 23:18:03.000000000 +0200
@@ -1402,7 +1402,6 @@
 }
 #endif
 
-
 /**
  *	netif_rx	-	post buffer to the network code
  *	@skb: buffer to post
@@ -1768,7 +1767,6 @@
 	unsigned long start_time = jiffies;
 	int budget = netdev_max_backlog;
 
-	
 	local_irq_disable();
 
 	while (!list_empty(&queue->poll_list)) {
@@ -1794,6 +1792,10 @@
 			dev_put(dev);
 			local_irq_disable();
 		}
+
+#ifdef CONFIG_KGDBOE
+		kgdb_process_breakpoint();
+#endif
 	}
 out:
 	local_irq_enable();
diff -Naur linux-2.6.11/net/Kconfig linux-2.6.11-om/net/Kconfig
--- linux-2.6.11/net/Kconfig	2005-03-02 08:38:34.000000000 +0100
+++ linux-2.6.11-om/net/Kconfig	2005-05-15 23:18:03.000000000 +0200
@@ -631,18 +631,17 @@
 
 endmenu
 
+config KGDBOE
+	def_bool X86 && KGDB
+
 config NETPOLL
-	def_bool NETCONSOLE
+	def_bool NETCONSOLE || KGDBOE
 
 config NETPOLL_RX
-	bool "Netpoll support for trapping incoming packets"
-	default n
-	depends on NETPOLL
+	def_bool KGDBOE
 
 config NETPOLL_TRAP
-	bool "Netpoll traffic trapping"
-	default n
-	depends on NETPOLL
+	def_bool KGDBOE
 
 config NET_POLL_CONTROLLER
 	def_bool NETPOLL
diff -Naur linux-2.6.11/net/socket.c linux-2.6.11-om/net/socket.c
--- linux-2.6.11/net/socket.c	2005-03-02 08:37:58.000000000 +0100
+++ linux-2.6.11-om/net/socket.c	2005-05-15 23:18:03.000000000 +0200
@@ -273,7 +273,7 @@
 
 static kmem_cache_t * sock_inode_cachep;
 
-static struct inode *sock_alloc_inode(struct super_block *sb)
+struct inode *sock_alloc_inode(struct super_block *sb)
 {
 	struct socket_alloc *ei;
 	ei = (struct socket_alloc *)kmem_cache_alloc(sock_inode_cachep, SLAB_KERNEL);
@@ -459,7 +459,7 @@
  *	NULL is returned.
  */
 
-static struct socket *sock_alloc(void)
+OM_NSTATIC struct socket *sock_alloc(void)
 {
 	struct inode * inode;
 	struct socket * sock;
diff -Naur linux-2.6.11/scripts/unsparse linux-2.6.11-om/scripts/unsparse
--- linux-2.6.11/scripts/unsparse	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-om/scripts/unsparse	2005-05-15 23:18:03.000000000 +0200
@@ -0,0 +1,66 @@
+#!/bin/sh
+
+KMIRROR="http://www.kernel.org/"
+KPATH="pub/linux/kernel/v2.6/"
+
+exit_no_kernel()
+{
+	echo "error: this is not a linux kernel"
+	exit 1
+}
+
+# already unsparsed
+[ -f CREDITS ] && exit 0
+
+[ -f Makefile ] || exit_no_kernel
+
+KVER=$(head -n 3 Makefile | awk '{print $3}' | xargs | sed -e 's/ /./g')
+
+get_kernel()
+{
+	if [ ! -f ~/.ketchup/linux-${KVER}.tar.bz2 ]; then
+		[ ! -d ~/.ketchup/ ] || mkdir ~/.ketchup
+		wget -P ~/.ketchup/ ${KMIRROR}${KPATH}linux-${KVER}.tar.bz2
+	fi
+}
+
+unsparse_directly()
+{
+	# the good trick :)
+	ln -s . linux-${KVER}
+
+	echo "unsparsing tree ..."
+	tar xkjf ~/.ketchup/linux-${KVER}.tar.bz2 2>&1 \
+			| grep -v "Cannot open: File exists" \
+			| grep -v "Error exit delayed from previous errors"
+	rm linux-${KVER}
+}
+
+unsparse_dest()
+{
+	if [ ! -f ${DEST}Makefile ]; then
+		echo "error: \"${DEST}\" do not contain a linux kernel"
+		exit 1
+	fi
+
+	for i in include/hpc/ hpc/ Documentation/i386/kgdb
+	do
+		mkdir ${DEST}$i
+	done
+
+	find -type f -not -regex '.*\.svn.*' -exec rm -f ${DEST}{} \;
+	find -type f -not -regex '.*\.svn.*' -exec cp {} ${DEST}{} \;
+}
+
+case $1 in
+	dest)
+		DEST=$2
+		unsparse_dest
+		;;
+	*)
+		get_kernel
+		unsparse_directly
+		;;
+esac
+
+exit 0
