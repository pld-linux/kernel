--- linux/init/main.c.agphjlfixes	Fri Feb 11 14:49:49 2000
+++ linux/init/main.c	Fri Feb 11 14:51:24 2000
@@ -377,6 +377,11 @@
 extern void md_setup(char *str,int *ints) __init;
 #endif
 
+#ifdef CONFIG_AGP
+extern int agp_initialize (void);
+extern void agp_setup(char *str, int *ints);
+#endif
+
 /*
  * Boot command-line arguments
  */
@@ -975,6 +980,9 @@
 #ifdef CONFIG_BLK_CPQ_DA
 	{ "smart2=", cpqarray_setup },
 #endif
+#ifdef CONFIG_AGP
+	{ "agp_try_unsupported=", agp_setup},
+#endif
 	{ 0, 0 }
 };
 
@@ -1409,6 +1417,9 @@
 #endif
 #ifdef CONFIG_MAC
 	nubus_init();
+#endif
+#ifdef CONFIG_AGP
+	agp_initialize ();
 #endif
 
 	/* Networking initialization needs a process context */ 
--- linux/include/linux/agpgart.h.agphjlfixes	Fri Feb 11 14:50:45 2000
+++ linux/include/linux/agpgart.h	Fri Feb 11 14:51:24 2000
@@ -38,6 +38,7 @@
 #define AGPIOC_DEALLOCATE _IOW (AGPIOC_BASE, 7, int)
 #define AGPIOC_BIND       _IOW (AGPIOC_BASE, 8, agp_bind*)
 #define AGPIOC_UNBIND     _IOW (AGPIOC_BASE, 9, agp_unbind*)
+#define AGPIOC_PAGE_MAP   _IOWR(AGPIOC_BASE, 10, agp_page_map*)
 
 #define AGP_DEVICE      "/dev/agpgart"
 
@@ -104,6 +105,12 @@
 	__u32 priority;		/* priority for paging out      */
 } agp_unbind;
 
+typedef struct _agp_page_map {
+	int index;		/* index in gatt table	*/
+	__u32 type;		/* 0 == normal, other devspec   */
+	off_t physical;		/* physical address */
+} agp_page_map;
+
 #else				/* __KERNEL__ */
 
 #define AGPGART_MINOR 175
@@ -171,6 +178,12 @@
 	int key;		/* tag of allocation            */
 	u32 priority;		/* priority for paging out      */
 } agp_unbind;
+
+typedef struct _agp_page_map {
+	int index;		/* index in gatt table	*/
+	__u32 type;		/* 0 == normal, other devspec   */
+	off_t physical;		/* physical address */
+} agp_page_map;
 
 typedef struct _agp_client {
 	struct _agp_client *next;
--- linux/include/linux/agp_backend.h.agphjlfixes	Fri Feb 11 14:50:45 2000
+++ linux/include/linux/agp_backend.h	Fri Feb 11 14:51:24 2000
@@ -72,6 +72,12 @@
 	int current_memory;
 } agp_kern_info;
 
+typedef struct _agp_kern_page_map {
+	int index;		/* index in gatt table  */
+	__u32 type;		/* 0 == normal, other devspec   */
+	off_t physical;		/* physical address */
+} agp_kern_page_map;
+
 /* 
  * The agp_memory structure has information
  * about the block of agp memory allocated.
@@ -219,6 +225,13 @@
  * by another entity.  (Ensure that all memory
  * it bound is unbound.)
  * 
+ */
+
+extern int agp_get_page_map(agp_kern_page_map *);
+
+/*
+ * Get the physical address of the video memory.
+ * Used by Intel 810 X server.
  */
 
 #endif				/* _AGP_BACKEND_H */
--- linux/drivers/char/agp/agpgart_fe.c.agphjlfixes	Fri Feb 11 14:50:45 2000
+++ linux/drivers/char/agp/agpgart_fe.c	Fri Feb 11 14:51:24 2000
@@ -955,6 +955,22 @@
 	return agp_unbind_memory(memory);
 }
 
+static int agpioc_get_page_map_wrap(agp_file_private * priv, unsigned long arg)
+{
+	agp_page_map page_map;
+
+	if (copy_from_user(&page_map, (void *) arg, sizeof(page_map))) {
+		return -EFAULT;
+	}
+	if (agp_get_page_map ((agp_kern_page_map *) &page_map)) {
+		return -EINVAL;
+	}
+	if (copy_to_user((void *) arg, &page_map, sizeof(page_map))) {
+		return -EFAULT;
+	}
+	return 0;
+}
+
 static int agp_ioctl(struct inode *inode, struct file *file,
 		     unsigned int cmd, unsigned long arg)
 {
@@ -965,19 +981,23 @@
 
 	if ((agp_fe.current_controller == NULL) &&
 	    (cmd != AGPIOC_ACQUIRE)) {
+		AGP_UNLOCK();
 		return -EINVAL;
 	}
 	if ((agp_fe.backend_acquired != TRUE) &&
 	    (cmd != AGPIOC_ACQUIRE)) {
+		AGP_UNLOCK();
 		return -EBUSY;
 	}
 	if (cmd != AGPIOC_ACQUIRE) {
 		if (!(test_bit(AGP_FF_IS_CONTROLLER, &(curr_priv->access_flags)))) {
+			AGP_UNLOCK();
 			return -EPERM;
 		}
 		/* Use the original pid of the controller, in case it's threaded */
 
 		if (agp_fe.current_controller->pid != curr_priv->my_pid) {
+			AGP_UNLOCK();
 			return -EBUSY;
 		}
 	}
@@ -1039,6 +1059,12 @@
 	case AGPIOC_UNBIND:
 		{
 			ret_val = agpioc_unbind_wrap(curr_priv, arg);
+			AGP_UNLOCK();
+			return ret_val;
+		}
+	case AGPIOC_PAGE_MAP:
+		{
+			ret_val = agpioc_get_page_map_wrap(curr_priv, arg);
 			AGP_UNLOCK();
 			return ret_val;
 		}
--- linux/drivers/char/agp/Makefile.agphjlfixes	Fri Feb 11 14:50:45 2000
+++ linux/drivers/char/agp/Makefile	Fri Feb 11 14:51:24 2000
@@ -3,7 +3,9 @@
 # space ioctl interface to use agp memory.  It also adds a kernel interface
 # that other drivers could use to manipulate agp memory.
 
-M_OBJS		:= agpgart.o
+O_TARGET	:= agpgart.o
+O_OBJS		:=
+M_OBJS          := $(O_TARGET)
 
 CFLAGS_agp_backend.o	:=
 
@@ -25,6 +27,9 @@
 ifdef CONFIG_AGP_ALI
 CFLAGS_agp_backend.o	+= -DAGP_BUILD_ALI_M1541
 endif
+
+all: all_targets
+.PHONY: all
 
 include $(TOPDIR)/Rules.make
 
--- linux/drivers/char/agp/agp_backend.c.agphjlfixes	Fri Feb 11 14:50:45 2000
+++ linux/drivers/char/agp/agp_backend.c	Fri Feb 11 14:51:24 2000
@@ -52,18 +52,22 @@
 
 #define CACHE_FLUSH agp_bridge.cache_flush
 
+#ifdef MODULE
 MODULE_AUTHOR("Jeff Hartmann <jhartmann@precisioninsight.com>");
 MODULE_PARM(agp_try_unsupported, "1i");
+#endif
+
 EXPORT_SYMBOL(agp_free_memory);
 EXPORT_SYMBOL(agp_allocate_memory);
 EXPORT_SYMBOL(agp_copy_info);
 EXPORT_SYMBOL(agp_bind_memory);
 EXPORT_SYMBOL(agp_unbind_memory);
+EXPORT_SYMBOL(agp_get_page_map);
 EXPORT_SYMBOL(agp_enable);
 EXPORT_SYMBOL(agp_backend_acquire);
 EXPORT_SYMBOL(agp_backend_release);
 
-static int agp_try_unsupported __initdata = 0;
+static int agp_try_unsupported = 0;
 
 #ifdef __SMP__
 static atomic_t cpus_waiting;
@@ -368,6 +372,14 @@
 	return 0;
 }
 
+int agp_get_page_map(agp_kern_page_map *map)
+{
+	if (!agp_bridge.get_page_map)
+		return -EINVAL;
+	else
+		return agp_bridge.get_page_map (map);
+}
+
 /* End - Routines for handling swapping of agp_memory into the GATT */
 
 /* 
@@ -926,6 +938,20 @@
 	return addr | agp_bridge.masks[type].mask;
 }
 
+static int intel_i810_get_page_map(agp_kern_page_map *map)
+{
+	if (map->index < 0 || map->type < 0
+	    || map->type > AGP_DCACHE_MEMORY
+	    || map->index >=
+	       ((aper_size_info_fixed *) agp_bridge.current_size)->num_entries
+	    || PGE_EMPTY (agp_bridge.gatt_table_real[map->index]))
+		return -EINVAL;
+
+	map->physical = agp_bridge.gatt_table_real[map->index]
+			& ~agp_bridge.masks[map->type].mask;
+	return 0;
+}
+
 static void intel_i810_setup(struct pci_dev *i810_dev)
 {
 	intel_i810_private.i810_dev = i810_dev;
@@ -954,6 +980,7 @@
 	agp_bridge.remove_memory = intel_i810_remove_entries;
 	agp_bridge.alloc_by_type = intel_i810_alloc_by_type;
 	agp_bridge.free_by_type = intel_i810_free_by_type;
+	agp_bridge.get_page_map = intel_i810_get_page_map;
 }
 
 #endif
@@ -1075,6 +1102,7 @@
 	agp_bridge.remove_memory = agp_generic_remove_memory;
 	agp_bridge.alloc_by_type = agp_generic_alloc_by_type;
 	agp_bridge.free_by_type = agp_generic_free_by_type;
+	agp_bridge.get_page_map = NULL;
 }
 
 #endif
@@ -1186,6 +1214,7 @@
 	agp_bridge.remove_memory = agp_generic_remove_memory;
 	agp_bridge.alloc_by_type = agp_generic_alloc_by_type;
 	agp_bridge.free_by_type = agp_generic_free_by_type;
+	agp_bridge.get_page_map = NULL;
 }
 
 #endif
@@ -1291,6 +1320,7 @@
 	agp_bridge.remove_memory = agp_generic_remove_memory;
 	agp_bridge.alloc_by_type = agp_generic_alloc_by_type;
 	agp_bridge.free_by_type = agp_generic_free_by_type;
+	agp_bridge.get_page_map = NULL;
 }
 
 #endif
@@ -1443,6 +1473,7 @@
 	agp_bridge.remove_memory = agp_generic_remove_memory;
 	agp_bridge.alloc_by_type = agp_generic_alloc_by_type;
 	agp_bridge.free_by_type = agp_generic_free_by_type;
+	agp_bridge.get_page_map = NULL;
 }
 
 #endif
@@ -1568,6 +1599,7 @@
 	agp_bridge.remove_memory = agp_generic_remove_memory;
 	agp_bridge.alloc_by_type = agp_generic_alloc_by_type;
 	agp_bridge.free_by_type = agp_generic_free_by_type;
+	agp_bridge.get_page_map = NULL;
 }
 
 #endif
@@ -1953,8 +1985,7 @@
 extern int agp_frontend_initialize(void);
 extern void agp_frontend_cleanup(void);
 
-#ifdef MODULE
-int init_module(void)
+int agp_initialize (void)
 {
 	int ret_val;
 
@@ -1974,10 +2005,21 @@
 	return 0;
 }
 
+#ifdef MODULE
+int init_module(void)
+{
+	return agp_initialize ();
+}
+
 void cleanup_module(void)
 {
 	agp_frontend_cleanup();
 	agp_backend_cleanup();
 }
-
+#else
+__initfunc(void agp_setup(char *str, int *ints))
+{
+	if (!strcmp(str,"agp_try_unsupported"))
+		agp_try_unsupported = ints[1];
+}
 #endif
--- linux/drivers/char/agp/agp_backendP.h.agphjlfixes	Fri Feb 11 14:50:45 2000
+++ linux/drivers/char/agp/agp_backendP.h	Fri Feb 11 14:51:24 2000
@@ -110,6 +110,7 @@
 	int (*remove_memory) (agp_memory *, off_t, int);
 	agp_memory *(*alloc_by_type) (size_t, int);
 	void (*free_by_type) (agp_memory *);
+	int (*get_page_map) (agp_kern_page_map *);
 
 	/* Links to vendor/device specific setup functions */
 #ifdef AGP_BUILD_INTEL_GENERIC
--- linux/drivers/char/Config.in.agphjlfixes	Fri Feb 11 14:50:45 2000
+++ linux/drivers/char/Config.in	Fri Feb 11 14:51:24 2000
@@ -117,8 +117,8 @@
 fi
 
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-   dep_tristate '/dev/agpgart (AGP Support) (EXPERIMENTAL)' CONFIG_AGP m
-   if [ "$CONFIG_AGP" = "m" ]; then
+   tristate '/dev/agpgart (AGP Support) (EXPERIMENTAL)' CONFIG_AGP n
+   if [ "$CONFIG_AGP" != "n" ]; then
       bool '   Intel 440LX/BX/GX support' CONFIG_AGP_INTEL
       bool '   Intel I810/I810 DC100/I810e support' CONFIG_AGP_I810
       bool '   VIA VP3/MVP3/Apollo Pro support' CONFIG_AGP_VIA
--- linux/drivers/char/Makefile.agphjlfixes	Fri Feb 11 14:50:45 2000
+++ linux/drivers/char/Makefile	Fri Feb 11 14:51:24 2000
@@ -352,9 +352,15 @@
   endif
 endif
 
-ifeq ($(CONFIG_AGP), m)
-   ALL_SUB_DIRS += agp
-   MOD_SUB_DIRS += agp
+ifeq ($(CONFIG_AGP),y)
+L_OBJS += agp/agpgart.o
+ALL_SUB_DIRS += agp
+SUB_DIRS += agp
+else
+  ifeq ($(CONFIG_AGP),m)
+  ALL_SUB_DIRS += agp
+  MOD_SUB_DIRS += agp
+  endif
 endif
     
 ifeq ($(CONFIG_VIDEO_DEV),y)
