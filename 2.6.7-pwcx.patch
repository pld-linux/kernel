diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/Kconfig linux-2.6.7-rc3/drivers/usb/media/Kconfig
--- linux-2.6.7-rc3.org/drivers/usb/media/Kconfig	2004-06-09 09:31:57.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/Kconfig	2004-06-09 09:38:59.000000000 +0200
@@ -146,6 +146,10 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called pwc.
 
+config USB_PWCX
+	tristate "PWCX decompressor module"
+	depends on USB_PWC
+
 config USB_SE401
 	tristate "USB SE401 Camera support"
 	depends on USB && VIDEO_DEV
diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/Makefile linux-2.6.7-rc3/drivers/usb/media/Makefile
--- linux-2.6.7-rc3.org/drivers/usb/media/Makefile	2004-06-07 21:13:34.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/Makefile	2004-06-09 09:38:59.000000000 +0200
@@ -3,6 +3,7 @@
 #
 
 pwc-objs	:= pwc-if.o pwc-misc.o pwc-ctrl.o pwc-uncompress.o
+pwcx-objs	:= pwcx-glue.o libpwcx.a
 
 obj-$(CONFIG_USB_DABUSB)	+= dabusb.o
 obj-$(CONFIG_USB_DSBR)		+= dsbr100.o
@@ -10,6 +11,7 @@
 obj-$(CONFIG_USB_KONICAWC)	+= konicawc.o usbvideo.o
 obj-$(CONFIG_USB_OV511)		+= ov511.o
 obj-$(CONFIG_USB_PWC)		+= pwc.o
+obj-$(CONFIG_USB_PWCX)		+= pwcx.o
 obj-$(CONFIG_USB_SE401)		+= se401.o
 obj-$(CONFIG_USB_STV680)	+= stv680.o
 obj-$(CONFIG_USB_VICAM)		+= vicam.o usbvideo.o
diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/pwc-ctrl.c linux-2.6.7-rc3/drivers/usb/media/pwc-ctrl.c
--- linux-2.6.7-rc3.org/drivers/usb/media/pwc-ctrl.c	2004-06-07 21:15:11.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/pwc-ctrl.c	2004-05-07 00:52:23.000000000 +0200
@@ -30,6 +30,7 @@
 #include <asm/uaccess.h> 
 #endif
 #include <asm/errno.h>
+#include <linux/version.h>
  
 #include "pwc.h"
 #include "pwc-ioctl.h"
@@ -267,9 +268,12 @@
 		Debug("Failed to send video command... %d\n", ret);
 		return ret;
 	}
-	if (pEntry->compressed && pdev->decompressor != NULL)
-		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
-		
+	if (pEntry->compressed && pdev->decompressor != 0 && pdev->vpalette != VIDEO_PALETTE_RAW)
+		pdev->decompressor->init(pdev->type, pdev->release, buf, pdev->decompress_data);
+
+	pdev->cmd_len = 3;
+	memcpy(pdev->cmd_buf, buf, 3);
+
 	/* Set various parameters */
 	pdev->vframes = frames;
 	pdev->vsize = size;
@@ -332,9 +336,12 @@
 	if (ret < 0)
 		return ret;
 
-	if (pChoose->bandlength > 0)
-		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
-	
+	if (pChoose->bandlength > 0 && pdev->decompressor != 0 && pdev->vpalette != VIDEO_PALETTE_RAW)
+		pdev->decompressor->init(pdev->type, pdev->release, buf, pdev->decompress_data);
+
+	pdev->cmd_len = 13;
+	memcpy(pdev->cmd_buf, buf, 13);
+
 	/* Set various parameters */
 	pdev->vframes = frames;
 	pdev->vsize = size;
@@ -352,33 +359,54 @@
 
 static inline int set_video_mode_Kiara(struct pwc_device *pdev, int size, int frames, int compression, int snapshot)
 {
-	struct Kiara_table_entry *pChoose;
+	struct Kiara_table_entry *pChoose = 0;
 	int fps, ret;
 	unsigned char buf[12];
-	
+	struct Kiara_table_entry RawEntry = {6, 773, 1272, {0xAD, 0xF4, 0x10, 0x27, 0xB6, 0x24, 0x96, 0x02, 0x30, 0x05, 0x03, 0x80}};
+
 	if (size >= PSZ_MAX || frames < 5 || frames > 30 || compression < 0 || compression > 3)
 		return -EINVAL;
 	if (size == PSZ_VGA && frames > 15)
 		return -EINVAL;
 	fps = (frames / 5) - 1;
-	
-	/* Find a supported framerate with progressively higher compression ratios
-	   if the preferred ratio is not available.
-	*/
-	pChoose = NULL;
-	if (pdev->decompressor == NULL) {
-#if PWC_DEBUG	
-		Debug("Trying to find uncompressed mode.\n");
-#endif		
-		pChoose = &Kiara_table[size][fps][0];
+
+	/* special case: VGA @ 5 fps and snapshot is raw bayer mode */
+	if (size == PSZ_VGA && frames == 5 && snapshot)
+	{
+		/* Only available in case the raw palette is selected or 
+		   we have the decompressor available. This mode is 
+		   only available in compressed form 
+		*/
+		if (pdev->vpalette == VIDEO_PALETTE_RAW || pdev->decompressor != NULL)
+		{
+	                Info("Choosing VGA/5 BAYER mode (%d).\n", pdev->vpalette);
+			pChoose = &RawEntry;
+		}
+		else
+		{
+			Info("VGA/5 BAYER mode _must_ have a decompressor available, or use RAW palette.\n");
+		}
 	}
-	else {
-		while (compression <= 3) {
-			pChoose = &Kiara_table[size][fps][compression];
-			if (pChoose->alternate != 0)
-				break;
-			compression++;	
+	else
+	{
+        	/* Find a supported framerate with progressively higher compression ratios
+		   if the preferred ratio is not available.
+                   Skip this step when using RAW modes.
+		*/
+		if (pdev->decompressor == NULL && pdev->vpalette != VIDEO_PALETTE_RAW) {
+#if PWC_DEBUG
+			Debug("Trying to find uncompressed mode.\n");
+#endif
+			pChoose = &Kiara_table[size][fps][0];
 		}
+		else {
+			while (compression <= 3) {
+				pChoose = &Kiara_table[size][fps][compression];
+				if (pChoose->alternate != 0)
+					break;
+				compression++;
+			}
+   		}
 	}
 	if (pChoose == NULL || pChoose->alternate == 0)
 		return -ENOENT; /* Not supported. */
@@ -393,9 +421,11 @@
 	if (ret < 0)
 		return ret;
 
-	if (pChoose->bandlength > 0)
-		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
-		
+	if (pChoose->bandlength > 0 && pdev->decompressor != 0 && pdev->vpalette != VIDEO_PALETTE_RAW)
+		pdev->decompressor->init(pdev->type, pdev->release, buf, pdev->decompress_data);
+
+	pdev->cmd_len = 12;
+	memcpy(pdev->cmd_buf, buf, 12);
 	/* All set and go */
 	pdev->vframes = frames;
 	pdev->vsize = size;
@@ -403,15 +433,15 @@
 	pdev->valternate = pChoose->alternate;
 	pdev->image = pwc_image_sizes[size];
 	pdev->vbandlength = pChoose->bandlength;
-	if (pChoose->bandlength > 0)
-		pdev->frame_size = (pChoose->bandlength * pdev->image.y) / 4;
-	else 
+	if (pdev->vbandlength > 0)
+		pdev->frame_size = (pdev->vbandlength * pdev->image.y) / 4;
+	else
 		pdev->frame_size = (pdev->image.x * pdev->image.y * 12) / 8;
-	pdev->frame_size += (pdev->frame_header_size + pdev->frame_trailer_size);
 	return 0;
 }
 
 
+
 /**
    @pdev: device structure
    @width: viewport width
@@ -422,14 +452,18 @@
  */
 int pwc_set_video_mode(struct pwc_device *pdev, int width, int height, int frames, int compression, int snapshot)
 {
-	int ret, size;
-	
+
+        int ret, size;
+
+        Trace(TRACE_FLOW, "set_video_mode(%dx%d @ %d, palette %d).\n", width, height, frames, pdev->vpalette);
 	size = pwc_decode_size(pdev, width, height);
 	if (size < 0) {
 		Debug("Could not find suitable size.\n");
 		return -ERANGE;
 	}
-	ret = -EINVAL;	
+	Debug("decode_size = %d.\n", size);
+
+        ret = -EINVAL;
 	switch(pdev->type) {
 	case 645:
 	case 646:
@@ -459,6 +493,7 @@
 	}
 	pdev->view.x = width;
 	pdev->view.y = height;
+	pdev->frame_total_size = pdev->frame_size + pdev->frame_header_size + pdev->frame_trailer_size;
 	pwc_set_image_buffer_size(pdev);
 	Trace(TRACE_SIZE, "Set viewport to %dx%d, image size is %dx%d.\n", width, height, pwc_image_sizes[size].x, pwc_image_sizes[size].y);
 	return 0;
@@ -467,23 +502,33 @@
 
 void pwc_set_image_buffer_size(struct pwc_device *pdev)
 {
-	int factor, i, filler = 0;
+	int i, factor = 0, filler = 0;
 
-	factor = 6;
-	filler = 128;
+	/* for PALETTE_YUV420P */
+	switch(pdev->vpalette)
+	{
+	case VIDEO_PALETTE_YUV420P:
+		factor = 6;
+		filler = 128;
+		break;
+	case VIDEO_PALETTE_RAW:
+		factor = 6; /* can be uncompressed YUV420P */
+		filler = 0;
+		break;
+	}
 
 	/* Set sizes in bytes */
 	pdev->image.size = pdev->image.x * pdev->image.y * factor / 4;
 	pdev->view.size  = pdev->view.x  * pdev->view.y  * factor / 4;
 
 	/* Align offset, or you'll get some very weird results in
-	   YUV420 mode... x must be multiple of 4 (to get the Y's in 
+	   YUV420 mode... x must be multiple of 4 (to get the Y's in
 	   place), and y even (or you'll mixup U & V). This is less of a
 	   problem for YUV420P.
 	 */
 	pdev->offset.x = ((pdev->view.x - pdev->image.x) / 2) & 0xFFFC;
 	pdev->offset.y = ((pdev->view.y - pdev->image.y) / 2) & 0xFFFE;
-	
+
 	/* Fill buffers with gray or black */
 	for (i = 0; i < MAX_IMAGES; i++) {
 		if (pdev->image_ptr[i] != NULL)
@@ -1670,19 +1594,34 @@
  
  	case VIDIOCPWCMPTSTATUS:
  	{
- 		struct pwc_mpt_status *status = arg;
- 	
  		if (pdev->features & FEATURE_MOTOR_PANTILT)
  		{
- 			ret = pwc_mpt_get_status(pdev, status);
+ 			ARG_DEF(struct pwc_mpt_status, status)
+ 			
+ 			ret = pwc_mpt_get_status(pdev, ARGA(status));
+ 			ARG_OUT(status)
  		}
  		else
  		{
  			ret = -ENXIO;
  		}
-  		break;
-  	}
-  	
+ 		break;
+	}
+
+	case VIDIOCPWCGVIDCMD:
+	{
+		ARG_DEF(struct pwc_video_command, cmd);
+		
+                ARGR(cmd).type = pdev->type;
+		ARGR(cmd).release = pdev->release;
+		ARGR(cmd).command_len = pdev->cmd_len;
+		memcpy(&ARGR(cmd).command_buf, pdev->cmd_buf, pdev->cmd_len);
+		ARGR(cmd).bandlength = pdev->vbandlength;
+		ARGR(cmd).frame_size = pdev->frame_size;
+		ARG_OUT(cmd)
+		break;
+	}
+
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/pwc-if.c linux-2.6.7-rc3/drivers/usb/media/pwc-if.c
--- linux-2.6.7-rc3.org/drivers/usb/media/pwc-if.c	2004-06-09 09:31:57.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/pwc-if.c	2004-05-07 00:52:23.000000000 +0200
@@ -90,6 +90,7 @@
 	{ USB_DEVICE(0x041E, 0x400C) }, /* Creative Webcam 5 */
 	{ USB_DEVICE(0x041E, 0x4011) }, /* Creative Webcam Pro Ex */
 	{ USB_DEVICE(0x04CC, 0x8116) }, /* Afina Eye */
+	{ USB_DEVICE(0x06BE, 0x8116) }, /* new Afina Eye */
 	{ USB_DEVICE(0x0d81, 0x1910) }, /* Visionite */
 	{ USB_DEVICE(0x0d81, 0x1900) },
 	{ }
@@ -129,6 +130,7 @@
 
 static int pwc_video_open(struct inode *inode, struct file *file);
 static int pwc_video_close(struct inode *inode, struct file *file);
+static void pwc_video_release(struct video_device *);			  
 static ssize_t pwc_video_read(struct file *file, char *buf,
 			  size_t count, loff_t *ppos);
 static unsigned int pwc_video_poll(struct file *file, poll_table *wait);
@@ -662,8 +664,8 @@
 					pdev->vsync = 2;
 
 					/* ...copy data to frame buffer, if possible */
-					if (flen + fbuf->filled > pdev->frame_size) {
-						Trace(TRACE_FLOW, "Frame buffer overflow (flen = %d, frame_size = %d).\n", flen, pdev->frame_size);
+					if (flen + fbuf->filled > pdev->frame_total_size) {
+						Trace(TRACE_FLOW, "Frame buffer overflow (flen = %d, frame_total_size = %d).\n", flen, pdev->frame_total_size);
 						pdev->vsync = 0; /* Hmm, let's wait for an EOF (end-of-frame) */
 						pdev->vframes_error++;
 					}
@@ -728,7 +730,7 @@
 						pdev->drop_frames--;
 					else {
 						/* Check for underflow first */
-						if (fbuf->filled < pdev->frame_size) {
+						if (fbuf->filled < pdev->frame_total_size) {
 							Trace(TRACE_FLOW, "Frame buffer underflow (%d bytes); discarded.\n", fbuf->filled);
 							pdev->vframes_error++;
 						}
@@ -788,8 +790,7 @@
 	struct urb *urb;
 	int i, j, ret;
 
-	struct usb_interface *intf;
-	struct usb_host_interface *idesc = NULL;
+	struct usb_host_interface *idesc;
 
 	if (pdev == NULL)
 		return -EFAULT;
@@ -801,9 +802,7 @@
 	/* Get the current alternate interface, adjust packet size */
 	if (!udev->actconfig)
 		return -EFAULT;
-	intf = usb_ifnum_to_if(udev, 0);
-	if (intf)
-		idesc = usb_altnum_to_altsetting(intf, pdev->valternate);
+	idesc = &udev->actconfig->interface[0]->altsetting[pdev->valternate];
 	if (!idesc)
 		return -EFAULT;
 
@@ -874,7 +873,7 @@
 		if (ret)
 			Err("isoc_init() submit_urb %d failed with error %d\n", i, ret);
 		else
-			Trace(TRACE_OPEN, "URB 0x%p submitted.\n", pdev->sbuf[i].urb);
+			Trace(TRACE_MEMORY, "URB 0x%p submitted.\n", pdev->sbuf[i].urb);
 	}
 
 	/* All is done... */
@@ -972,24 +971,28 @@
 		Trace(TRACE_OPEN, "Doing first time initialization.\n");
 		pdev->usb_init = 1;
 		
-		if (pwc_trace & TRACE_OPEN) {
+		if (pwc_trace & TRACE_OPEN)
+		{
 			/* Query sensor type */
 			const char *sensor_type = NULL;
+			int ret;
 
-			i = pwc_get_cmos_sensor(pdev);
-			switch(i) {
-			case -1: /* Unknown, show nothing */; break;
-			case 0x00:  sensor_type = "Hyundai CMOS sensor"; break;
-			case 0x20:  sensor_type = "Sony CCD sensor + TDA8787"; break;
-			case 0x2E:  sensor_type = "Sony CCD sensor + Exas 98L59"; break;
-			case 0x2F:  sensor_type = "Sony CCD sensor + ADI 9804"; break;
-			case 0x30:  sensor_type = "Sharp CCD sensor + TDA8787"; break;
-			case 0x3E:  sensor_type = "Sharp CCD sensor + Exas 98L59"; break;
-			case 0x3F:  sensor_type = "Sharp CCD sensor + ADI 9804"; break;
-			case 0x40:  sensor_type = "UPA 1021 sensor"; break;
-			case 0x100: sensor_type = "VGA sensor"; break;
-			case 0x101: sensor_type = "PAL MR sensor"; break;
-			default:    sensor_type = "unknown type of sensor"; break;
+			ret = pwc_get_cmos_sensor(pdev, &i);
+			if (ret >= 0)
+			{
+				switch(i) {
+				case 0x00:  sensor_type = "Hyundai CMOS sensor"; break;
+				case 0x20:  sensor_type = "Sony CCD sensor + TDA8787"; break;
+				case 0x2E:  sensor_type = "Sony CCD sensor + Exas 98L59"; break;
+				case 0x2F:  sensor_type = "Sony CCD sensor + ADI 9804"; break;
+				case 0x30:  sensor_type = "Sharp CCD sensor + TDA8787"; break;
+				case 0x3E:  sensor_type = "Sharp CCD sensor + Exas 98L59"; break;
+				case 0x3F:  sensor_type = "Sharp CCD sensor + ADI 9804"; break;
+				case 0x40:  sensor_type = "UPA 1021 sensor"; break;
+				case 0x100: sensor_type = "VGA sensor"; break;
+				case 0x101: sensor_type = "PAL MR sensor"; break;
+				default:    sensor_type = "unknown type of sensor"; break;
+				}
 			}
 			if (sensor_type != NULL)
 				Info("This %s camera is equipped with a %s (%d).\n", pdev->vdev.name, sensor_type, i);
@@ -1120,6 +1124,12 @@
 	return 0;
 }
 
+static void pwc_video_release(struct video_device *vfd)
+{
+	Trace(TRACE_OPEN, "pwc_video_release() called. Nothing to do here. Honestly.\n");
+}
+		
+
 /*
  *	FIXME: what about two parallel reads ????
  *      ANSWER: Not supported. You can't open the device more than once,
@@ -1139,6 +1149,7 @@
 	struct pwc_device *pdev;
 	int noblock = file->f_flags & O_NONBLOCK;
 	DECLARE_WAITQUEUE(wait, current);
+        int bytes_to_read;
 
 	Trace(TRACE_READ, "video_read(0x%p, %p, %d) called.\n", vdev, buf, count);
 	if (vdev == NULL)
@@ -1175,20 +1186,25 @@
 		}
 		remove_wait_queue(&pdev->frameq, &wait);
 		set_current_state(TASK_RUNNING);
-	                                                                                                                                                                                
+                                                                                                                                                                                
 		/* Decompress and release frame */
 		if (pwc_handle_frame(pdev))
 			return -EFAULT;
 	}
 
 	Trace(TRACE_READ, "Copying data to user space.\n");
+	if (pdev->vpalette == VIDEO_PALETTE_RAW)
+		bytes_to_read = pdev->frame_size;
+	else
+ 		bytes_to_read = pdev->view.size;
+
 	/* copy bytes to user space; we allow for partial reads */
-	if (count + pdev->image_read_pos > pdev->view.size)
-		count = pdev->view.size - pdev->image_read_pos;
+	if (count + pdev->image_read_pos > bytes_to_read)
+		count = bytes_to_read - pdev->image_read_pos;
 	if (copy_to_user(buf, pdev->image_ptr[pdev->fill_image] + pdev->image_read_pos, count))
 		return -EFAULT;
 	pdev->image_read_pos += count;
-	if (pdev->image_read_pos >= pdev->view.size) { /* All data has been read */
+	if (pdev->image_read_pos >= bytes_to_read) { /* All data has been read */
 		pdev->image_read_pos = 0;
 		pwc_next_image(pdev);
 	}
@@ -1278,8 +1294,6 @@
 			struct video_picture *p = arg;
 			int val;
 
-			p->colour = 0x8000;
-			p->hue = 0x8000;
 			val = pwc_get_brightness(pdev);
 			if (val >= 0)
 				p->brightness = val;
@@ -1302,11 +1316,11 @@
 			else
 				p->colour = 0xffff;
 			p->depth = 24;
-			p->palette = VIDEO_PALETTE_YUV420P;
+			p->palette = pdev->vpalette;
 			p->hue = 0xFFFF; /* N/A */
 			break;
 		}
-		
+
 		case VIDIOCSPICT:
 		{
 			struct video_picture *p = arg;
@@ -1318,13 +1332,22 @@
 			                is used exactly once in the uncompress
 			                routine.
 			 */
-			if (p->palette && p->palette != VIDEO_PALETTE_YUV420P) {
-				return -EINVAL;
-			}
 			pwc_set_brightness(pdev, p->brightness);
 			pwc_set_contrast(pdev, p->contrast);
 			pwc_set_gamma(pdev, p->whiteness);
 			pwc_set_saturation(pdev, p->colour);
+			if (p->palette && p->palette != pdev->vpalette) {
+				switch (p->palette) {
+					case VIDEO_PALETTE_YUV420P:
+					case VIDEO_PALETTE_RAW:
+						pdev->vpalette = p->palette;
+						return pwc_try_video_mode(pdev, pdev->image.x, pdev->image.y, pdev->vframes, pdev->vcompression, pdev->vsnapshot);
+						break;
+					default:
+						return -EINVAL;
+						break;
+				}
+			}
 			break;
 		}
 
@@ -1398,13 +1421,23 @@
 			   various palettes... The driver doesn't support
 			   such small images, so I'm working around it.
 			 */
-			if (vm->format && vm->format != VIDEO_PALETTE_YUV420P)
-				return -EINVAL;
-			 
+			if (vm->format)
+			{
+				switch (vm->format)
+				{
+					case VIDEO_PALETTE_YUV420P:
+					case VIDEO_PALETTE_RAW:
+						break;
+					default:
+						return -EINVAL;
+						break;
+				}
+			}
+
 			if ((vm->width != pdev->view.x || vm->height != pdev->view.y) &&
 			    (vm->width >= pdev->view_min.x && vm->height >= pdev->view_min.y)) {
 				int ret;
-				
+
 				Trace(TRACE_OPEN, "VIDIOCMCAPTURE: changing size to please xawtv :-(.\n");
 				ret = pwc_try_video_mode(pdev, vm->width, vm->height, pdev->vframes, pdev->vcompression, pdev->vsnapshot);
 				if (ret)
@@ -1636,12 +1669,12 @@
 			type_id = 690;
 			break;
 		case 0x0310:
-			Info("Philips PCVC730K (ToUCam Fun) USB webcam detected.\n");
+			Info("Philips PCVC730K (ToUCam Fun)/PCVC830 (ToUCam II) USB webcam detected.\n");
 			name = "Philips 730 webcam";
 			type_id = 730;
 			break;
 		case 0x0311:
-			Info("Philips PCVC740K (ToUCam Pro) USB webcam detected.\n");
+			Info("Philips PCVC740K (ToUCam Pro)/PCVC840 (ToUCam II) USB webcam detected.\n");
 			name = "Philips 740 webcam";
 			type_id = 740;
 			break;
@@ -1755,17 +1788,44 @@
 			break;
 		}
 	}
-	else if (vendor_id == 0x04cc) { 
+	else if (vendor_id == 0x04cc) {
 		switch(product_id) {
 		case 0x8116:
 			Info("Sotec Afina Eye USB webcam detected.\n");
 			name = "Sotec Afina Eye";
 			type_id = 730;
-			break;  
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else if (vendor_id == 0x06be) {
+		switch(product_id) {
+		case 0x8116:
+			/* Basicly the same as the Sotec Afina Eye */                
+			Info("AME CU-001 USB webcam detected.\n");
+			name = "AME CU-001";
+			type_id = 730;
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else if (vendor_id == 0x06be) {
+		switch(product_id) {
+		case 0x8116:
+			/* This is essentially the same cam as the Sotec Afina Eye */
+			Info("AME Co. Afina Eye USB webcam detected.\n");
+			name = "AME Co. Afina Eye";
+			type_id = 750;
+			break;
 		default:
 			return -ENODEV;
 			break;
 		}
+	
 	}
 	else if (vendor_id == 0x0d81) {
 		switch(product_id) {
@@ -1815,8 +1875,6 @@
 		pdev->angle_range.pan_max  =  7000;
 		pdev->angle_range.tilt_min = -3000;
 		pdev->angle_range.tilt_max =  2500;
-		pdev->angle_range.zoom_min = -1;
-		pdev->angle_range.zoom_max = -1;
 	}
 
 	init_MUTEX(&pdev->modlock);
@@ -1848,7 +1906,7 @@
 		}
 	}
 
-	pdev->vdev.release = video_device_release;
+	pdev->vdev.release = pwc_video_release;
 	i = video_register_device(&pdev->vdev, VFL_TYPE_GRABBER, video_nr);
 	if (i < 0) {
 		Err("Failed to register as video device (%d).\n", i);
@@ -1971,7 +2029,7 @@
 MODULE_PARM_DESC(dev_hint, "Device node hints");
 
 MODULE_DESCRIPTION("Philips & OEM USB webcam driver");
-MODULE_AUTHOR("Nemosoft Unv. <nemosoft@smcc.demon.nl>");
+MODULE_AUTHOR("Nemosoft Unv. <webcam@smcc.demon.nl>");
 MODULE_LICENSE("GPL");
 
 static int __init usb_pwc_init(void)
@@ -1979,9 +2037,10 @@
 	int i, sz;
 	char *sizenames[PSZ_MAX] = { "sqcif", "qsif", "qcif", "sif", "cif", "vga" };
 
-	Info("Philips PCA645/646 + PCVC675/680/690 + PCVC730/740/750 webcam module version " PWC_VERSION " loaded.\n");
-	Info("Also supports the Askey VC010, various Logitech QuickCams, Samsung MPC-C10 and MPC-C30,\n");
-	Info("the Creative WebCam 5, SOTEC Afina Eye and Visionite VCS-UC300 and VCS-UM100.\n");
+	Info("Philips webcam module version " PWC_VERSION " loaded.\n");
+	Info("Supports Philips PCA645/646, PCVC675/680/690, PCVC720[40]/730/740/750 & PCVC830/840.\n");
+	Info("Also supports the Askey VC010, various Logitech Quickcams, Samsung MPC-C10 and MPC-C30,\n");
+	Info("the Creative WebCam 5 & Pro Ex, SOTEC Afina Eye and Visionite VCS-UC300 and VCS-UM100.\n");
 
 	if (fps) {
 		if (fps < 4 || fps > 30) {
diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/pwc-ioctl.h linux-2.6.7-rc3/drivers/usb/media/pwc-ioctl.h
--- linux-2.6.7-rc3.org/drivers/usb/media/pwc-ioctl.h	2004-06-07 21:14:11.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/pwc-ioctl.h	2004-05-07 00:52:23.000000000 +0200
@@ -18,19 +18,24 @@
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-/*         This is pwc-ioctl.h belonging to PWC 8.10                        */
+/* This is pwc-ioctl.h belonging to PWC 8.12.1
+   It contains structures and defines to communicate from user space
+   directly to the driver.
+ */
 
-/* 
+/*
    Changes
-   2001/08/03  Alvarado   Added ioctl constants to access methods for 
+   2001/08/03  Alvarado   Added ioctl constants to access methods for
                           changing white balance and red/blue gains
    2002/12/15  G. H. Fernandez-Toribio   VIDIOCGREALSIZE
+   2003/12/13  Nemosft Unv. Some modifications to make interfacing to
+               PWCX easier
  */
 
 /* These are private ioctl() commands, specific for the Philips webcams.
    They contain functions not found in other webcams, and settings not
-   specified in the Video4Linux API. 
-   
+   specified in the Video4Linux API.
+
    The #define names are built up like follows:
    VIDIOC		VIDeo IOCtl prefix
          PWC		Philps WebCam
@@ -40,13 +45,21 @@
  */
 
 
+ /* Enumeration of image sizes */
+#define PSZ_SQCIF	0x00
+#define PSZ_QSIF	0x01
+#define PSZ_QCIF	0x02
+#define PSZ_SIF		0x03
+#define PSZ_CIF		0x04
+#define PSZ_VGA		0x05
+#define PSZ_MAX		6
 
 
 /* The frame rate is encoded in the video_window.flags parameter using
    the upper 16 bits, since some flags are defined nowadays. The following
    defines provide a mask and shift to filter out this value.
-   
-   In 'Snapshot' mode the camera freezes its automatic exposure and colour 
+
+   In 'Snapshot' mode the camera freezes its automatic exposure and colour
    balance controls.
  */
 #define PWC_FPS_SHIFT		16
@@ -55,7 +68,15 @@
 #define PWC_FPS_SNAPSHOT	0x00400000
 
 
+/* structure for transfering x & y coordinates */
+struct pwc_coord
+{
+	int x, y;		/* guess what */
+	int size;		/* size, or offset */
+};
+
 
+/* Used with VIDIOCPWCPROBE */
 struct pwc_probe
 {
 	char name[32];
@@ -78,7 +99,6 @@
    otherwise undefined.
    'read_red' and 'read_blue' are read-only.
 */   
-   
 struct pwc_whitebalance
 {
 	int mode;
@@ -117,7 +137,7 @@
 #define PWC_MPT_TILT		0x02
 #define PWC_MPT_TIMEOUT		0x04 /* for status */
 
-/* Set angles; when absolute = 1, the angle is absolute and the 
+/* Set angles; when absolute != 0, the angle is absolute and the 
    driver calculates the relative offset for you. This can only
    be used with VIDIOCPWCSANGLE; VIDIOCPWCGANGLE always returns
    absolute angles.
@@ -127,18 +147,14 @@
 	int absolute;		/* write-only */
 	int pan;		/* degrees * 100 */
 	int tilt;		/* degress * 100 */
-	int zoom;		/* N/A, set to -1 */
 };
 
 /* Range of angles of the camera, both horizontally and vertically.
-   The zoom is not used, maybe in the future...
-
  */
 struct pwc_mpt_range
 {
 	int pan_min, pan_max;		/* degrees * 100 */
 	int tilt_min, tilt_max;
-	int zoom_min, zoom_max;		/* -1, -1 */
 };
 
 struct pwc_mpt_status
@@ -149,6 +165,30 @@
 };
 
 
+/* This is used for out-of-kernel decompression. With it, you can get
+   all the necessary information to initialize and use the decompressor
+   routines in standalone applications.
+ */   
+struct pwc_video_command
+{
+	int type;		/* camera type (645, 675, 730, etc.) */
+	int release;		/* release number */
+
+        int size;		/* one of PSZ_* */
+        int alternate;
+	int command_len;	/* length of USB video command */
+	unsigned char command_buf[13];	/* Actual USB video command */
+	int bandlength;		/* >0 = compressed */
+	int frame_size;		/* Size of one (un)compressed frame */
+};
+
+/* Flags for PWCX subroutines. Not all modules honour all flags. */
+#define PWCX_FLAG_PLANAR	0x0001
+#define PWCX_FLAG_BAYER		0x0008
+
+
+/* IOCTL definitions */
+
  /* Restore user settings */
 #define VIDIOCPWCRUSER		_IO('v', 192)
  /* Save user settings */
@@ -172,13 +212,13 @@
  /* This is a probe function; since so many devices are supported, it
     becomes difficult to include all the names in programs that want to
     check for the enhanced Philips stuff. So in stead, try this PROBE;
-    it returns a structure with the original name, and the corresponding 
+    it returns a structure with the original name, and the corresponding
     Philips type.
     To use, fill the structure with zeroes, call PROBE and if that succeeds,
     compare the name with that returned from VIDIOCGCAP; they should be the
     same. If so, you can be assured it is a Philips (OEM) cam and the type
     is valid.
- */    
+ */
 #define VIDIOCPWCPROBE		_IOR('v', 199, struct pwc_probe)
 
  /* Set AGC (Automatic Gain Control); int < 0 = auto, 0..65535 = fixed */
@@ -225,5 +265,8 @@
 #define VIDIOCPWCMPTSANGLE	_IOW('v', 212, struct pwc_mpt_angles)
 #define VIDIOCPWCMPTGANGLE	_IOR('v', 212, struct pwc_mpt_angles)
 #define VIDIOCPWCMPTSTATUS	_IOR('v', 213, struct pwc_mpt_status)
- 
+
+ /* Get the USB set-video command; needed for initializing libpwcx */
+#define VIDIOCPWCGVIDCMD	_IOR('v', 215, struct pwc_video_command)
+
 #endif
diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/pwc-misc.c linux-2.6.7-rc3/drivers/usb/media/pwc-misc.c
--- linux-2.6.7-rc3.org/drivers/usb/media/pwc-misc.c	2004-06-07 21:14:05.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/pwc-misc.c	2004-05-07 00:52:23.000000000 +0200
@@ -36,11 +36,30 @@
 {
 	int i, find;
 
-	/* Make sure we don't go beyond our max size */
-	if (width > pdev->view_max.x || height > pdev->view_max.y)
-		return -1;
+	/* Make sure we don't go beyond our max size.
+           NB: we have different limits for RAW and normal modes. In case
+           you don't have the decompressor loaded or use RAW mode, 
+           the maximum viewable size is smaller.
+        */
+	if (pdev->vpalette == VIDEO_PALETTE_RAW)
+	{
+		if (width > pdev->abs_max.x || height > pdev->abs_max.y)
+		{
+			Debug("VIDEO_PALETTE_RAW: going beyond abs_max.\n");
+                	return -1;
+                }
+	}
+	else
+	{
+		if (width > pdev->view_max.x || height > pdev->view_max.y)
+		{
+			Debug("VIDEO_PALETTE_ not RAW: going beyond view_max.\n");
+			return -1;
+		}
+	}
+
 	/* Find the largest size supported by the camera that fits into the
-	   requested size. 
+	   requested size.
 	 */
 	find = -1;
 	for (i = 0; i < PSZ_MAX; i++) {
@@ -62,6 +81,8 @@
 		pdev->view_min.y =  96;
 		pdev->view_max.x = 352;
 		pdev->view_max.y = 288;
+                pdev->abs_max.x  = 352;
+                pdev->abs_max.y  = 288;
 		pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QCIF | 1 << PSZ_CIF;
 		pdev->vcinterface = 2;
 		pdev->vendpoint = 4;
@@ -77,13 +98,14 @@
 		if (pdev->decompressor != NULL) {
 			pdev->view_max.x = 640;
 			pdev->view_max.y = 480;
-			pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF | 1 << PSZ_VGA;
 		}
 		else {
 			pdev->view_max.x = 352;
 			pdev->view_max.y = 288;
-			pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF;
 		}
+		pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF | 1 << PSZ_VGA;
+                pdev->abs_max.x = 640;
+                pdev->abs_max.y = 480;
 		pdev->vcinterface = 3;
 		pdev->vendpoint = 4;
 		pdev->frame_header_size = 0;
@@ -99,24 +121,26 @@
 		if (pdev->decompressor != NULL) {
 			pdev->view_max.x = 640;
 			pdev->view_max.y = 480;
-			pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF | 1 << PSZ_VGA;
 		}
 		else {
-			/* Tell CIF, even though SIF really is the maximum, but some tools really need CIF */
+			/* We use CIF, not SIF since some tools really need CIF. So we cheat a bit. */
 			pdev->view_max.x = 352;
 			pdev->view_max.y = 288;
-			pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF;
 		}
+		pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF | 1 << PSZ_VGA;
+                pdev->abs_max.x = 640;
+                pdev->abs_max.y = 480;
 		pdev->vcinterface = 3;
 		pdev->vendpoint = 5;
 		pdev->frame_header_size = TOUCAM_HEADER_SIZE;
 		pdev->frame_trailer_size = TOUCAM_TRAILER_SIZE;
 		break;
 	}
+	pdev->vpalette = VIDEO_PALETTE_YUV420P; /* default */
 	pdev->view_min.size = pdev->view_min.x * pdev->view_min.y;
 	pdev->view_max.size = pdev->view_max.x * pdev->view_max.y;
-	/* length of image, in YUV format */
-	pdev->len_per_image = (pdev->view_max.size * 3) / 2;
+	/* length of image, in YUV format; always allocate enough memory. */
+	pdev->len_per_image = (pdev->abs_max.x * pdev->abs_max.y * 3) / 2;
 }
 
 
diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/pwc-uncompress.c linux-2.6.7-rc3/drivers/usb/media/pwc-uncompress.c
--- linux-2.6.7-rc3.org/drivers/usb/media/pwc-uncompress.c	2004-06-07 21:14:25.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/pwc-uncompress.c	2004-05-07 00:52:23.000000000 +0200
@@ -21,7 +21,9 @@
    themselves. It also has a decompressor wrapper function.
 */
 
+#include <asm/current.h>
 #include <asm/types.h>
+// #include <linux/sched.h>
 
 #include "pwc.h"
 #include "pwc-uncompress.h"
@@ -97,16 +98,24 @@
 	image = pdev->image_ptr[pdev->fill_image];
 	if (!image)
 		return -EFAULT;
-	
+
 	yuv = fbuf->data + pdev->frame_header_size;  /* Skip header */
-	if (pdev->vbandlength == 0) { 
+
+	/* Raw format; that's easy... */
+	if (pdev->vpalette == VIDEO_PALETTE_RAW)
+	{
+		memcpy(image, yuv, pdev->frame_size);
+		return 0;
+	}
+
+	if (pdev->vbandlength == 0) {
 		/* Uncompressed mode. We copy the data into the output buffer,
 		   using the viewport size (which may be larger than the image
 		   size). Unfortunately we have to do a bit of byte stuffing
 		   to get the desired output format/size.
 		 */
-			/* 
-			 * We do some byte shuffling here to go from the 
+			/*
+			 * We do some byte shuffling here to go from the
 			 * native format to YUV420P.
 			 */
 			src = (u16 *)yuv;
@@ -140,15 +149,21 @@
 					dstu += (stride >> 1);
 			}
 	}
-	else { 
-		/* Compressed; the decompressor routines will write the data 
+	else {
+		/* Compressed; the decompressor routines will write the data
 		   in planar format immediately.
 		 */
+		int flags;
+                
+                flags = PWCX_FLAG_PLANAR;
+                if (pdev->vsize == PSZ_VGA && pdev->vframes == 5 && pdev->vsnapshot)
+                	flags |= PWCX_FLAG_BAYER;
+
 		if (pdev->decompressor)
 			pdev->decompressor->decompress(
 				&pdev->image, &pdev->view, &pdev->offset,
 				yuv, image,
-				1,
+				flags,
 				pdev->decompress_data, pdev->vbandlength);
 		else
 			return -ENXIO; /* No such device or address: missing decompressor */
diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/pwc-uncompress.h linux-2.6.7-rc3/drivers/usb/media/pwc-uncompress.h
--- linux-2.6.7-rc3.org/drivers/usb/media/pwc-uncompress.h	2004-06-07 21:14:03.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/pwc-uncompress.h	2004-05-07 00:52:23.000000000 +0200
@@ -24,10 +24,16 @@
 #define PWC_UNCOMPRESS_H
 
 #include <linux/config.h>
+#include <linux/linkage.h>
 #include <linux/list.h>
 
 #include "pwc.h"
 
+/* from pwc-dec.h */
+#define PWCX_FLAG_PLANAR        0x0001
+/* */
+
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -42,10 +48,10 @@
 	int  type;		/* type of camera (645, 680, etc) */
 	int  table_size;	/* memory needed */
 
-	void (* init)(int release, void *buffer, void *table);	/* Initialization routine; should be called after each set_video_mode */
-	void (* exit)(void);	/* Cleanup routine */
-	void (* decompress)(struct pwc_coord *image, struct pwc_coord *view, struct pwc_coord *offset,
-                            void *src, void *dst, int planar,
+	asmlinkage void (* init)(int type, int release, void *buffer, void *table);	/* Initialization routine; should be called after each set_video_mode */
+	asmlinkage void (* exit)(void);	/* Cleanup routine */
+	asmlinkage void (* decompress)(struct pwc_coord *image, struct pwc_coord *view, struct pwc_coord *offset,
+                            void *src, void *dst, int flags,
 	                    void *table, int bandlength);
 	void (* lock)(void);	/* make sure module cannot be unloaded */
 	void (* unlock)(void);	/* release lock on module */
diff -Nur linux-2.6.7-rc3.org/drivers/usb/media/pwc.h linux-2.6.7-rc3/drivers/usb/media/pwc.h
--- linux-2.6.7-rc3.org/drivers/usb/media/pwc.h	2004-06-07 21:14:34.000000000 +0200
+++ linux-2.6.7-rc3/drivers/usb/media/pwc.h	2004-05-07 00:52:23.000000000 +0200
@@ -22,12 +22,11 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
-#include <linux/smp_lock.h>
-#include <linux/spinlock.h>
 #include <linux/usb.h>
+#include <linux/spinlock.h>
 #include <linux/videodev.h>
 #include <linux/wait.h>
-
+#include <linux/smp_lock.h>
 #include <asm/semaphore.h>
 #include <asm/errno.h>
 
@@ -65,9 +64,9 @@
 #define FEATURE_MOTOR_PANTILT		0x0001
 
 /* Version block */
-#define PWC_MAJOR	8
-#define PWC_MINOR	12
-#define PWC_VERSION 	"8.12"
+#define PWC_MAJOR	9
+#define PWC_MINOR	0
+#define PWC_VERSION 	"9.0-BETA-2"
 #define PWC_NAME 	"pwc"
 
 /* Turn certain features on/off */
@@ -90,12 +89,6 @@
 /* Absolute maximum number of buffers available for mmap() */
 #define MAX_IMAGES 		10
 
-struct pwc_coord
-{
-	int x, y;		/* guess what */
-	int size;		/* size, or offset */
-};
-
 /* The following structures were based on cpia.h. Why reinvent the wheel? :-) */
 struct pwc_iso_buf
 {
@@ -137,6 +130,7 @@
    int vcinterface;		/* video control interface */
    int valternate;		/* alternate interface needed */
    int vframes, vsize;		/* frames-per-second & size (see PSZ_*) */
+   int vpalette;		/* palette: 420P, RAW or RGBBAYER */
    int vframe_count;		/* received frames */
    int vframes_dumped; 		/* counter for dumped frames */
    int vframes_error;		/* frames received in error */
@@ -148,6 +142,9 @@
    char vsnapshot;		/* snapshot mode */
    char vsync;			/* used by isoc handler */
    char vmirror;		/* for ToUCaM series */
+   
+   int cmd_len;
+   unsigned char cmd_buf[13];
 
    /* The image acquisition requires 3 to 4 steps:
       1. data is gathered in short packets from the USB controller
@@ -169,8 +166,9 @@
    struct pwc_frame_buf *full_frames, *full_frames_tail;	/* all filled frames */
    struct pwc_frame_buf *fill_frame;	/* frame currently being filled */
    struct pwc_frame_buf *read_frame;	/* frame currently read by user process */
-   int frame_size;
    int frame_header_size, frame_trailer_size;
+   int frame_size;
+   int frame_total_size; /* including header & trailer */
    int drop_frames;
 #if PWC_DEBUG
    int sequence;			/* Debugging aid */
@@ -187,7 +185,8 @@
       a gray or black border. view_min <= image <= view <= view_max;
     */
    int image_mask;			/* bitmask of supported sizes */
-   struct pwc_coord view_min, view_max;	/* minimum and maximum sizes */
+   struct pwc_coord view_min, view_max;	/* minimum and maximum viewable sizes */
+   struct pwc_coord abs_max;            /* maximum supported size with compression */
    struct pwc_coord image, view;	/* image and viewport size */
    struct pwc_coord offset;		/* offset within the viewport */
 
@@ -213,16 +212,6 @@
 #endif
 };
 
-/* Enumeration of image sizes */
-#define PSZ_SQCIF	0x00
-#define PSZ_QSIF	0x01
-#define PSZ_QCIF	0x02
-#define PSZ_SIF		0x03
-#define PSZ_CIF		0x04
-#define PSZ_VGA		0x05
-#define PSZ_MAX		6
-
-
 
 #ifdef __cplusplus
 extern "C" {
@@ -259,7 +248,7 @@
 extern int pwc_set_saturation(struct pwc_device *pdev, int value);
 extern int pwc_set_leds(struct pwc_device *pdev, int on_value, int off_value);
 extern int pwc_get_leds(struct pwc_device *pdev, int *on_value, int *off_value);
-extern int pwc_get_cmos_sensor(struct pwc_device *pdev);
+extern int pwc_get_cmos_sensor(struct pwc_device *pdev, int *sensor);
 
 /* Power down or up the camera; not supported by all models */
 extern int pwc_camera_power(struct pwc_device *pdev, int power);
