 Makefile                        |    2 +-
 drivers/char/isicom.c           |    6 +++---
 drivers/input/mouse/psmouse.h   |    2 ++
 drivers/media/dvb/bt8xx/bt878.h |    6 +++---
 drivers/media/video/bttvp.h     |   21 ++++++++++-----------
 include/linux/generic_serial.h  |    2 --
 include/linux/i2c.h             |   32 ++++++++++++++++----------------
 7 files changed, 35 insertions(+), 36 deletions(-)

--- a/Makefile.orig	2005-03-30 13:10:50.000000000 +0200
+++ b/Makefile	2005-03-30 13:11:15.000000000 +0200
@@ -202,7 +202,7 @@
 
 HOSTCC  	= gcc
 HOSTCXX  	= g++
-HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer $(call cc-option,-Wno-pointer-sign,)
 HOSTCXXFLAGS	= -O2
 
 # 	Decide whether to build built-in, modular, or both.
--- a/include/linux/generic_serial.h.orig	2005-03-16 01:09:11.000000000 +0100
+++ b/include/linux/generic_serial.h	2005-03-16 10:21:23.000000000 +0100
@@ -91,6 +91,4 @@
 int  gs_getserial(struct gs_port *port, struct serial_struct __user *sp);
 void gs_got_break(struct gs_port *port);
 
-extern int gs_debug;
-
 #endif
--- a/include/linux/i2c.h.orig	2004-12-24 22:34:01.000000000 +0100
+++ b/include/linux/i2c.h	2005-02-14 23:35:45.455135464 +0100
@@ -36,7 +36,22 @@
 
 /* --- General options ------------------------------------------------	*/
 
-struct i2c_msg;
+/*
+ * I2C Message - used for pure i2c transaction, also from /dev interface
+ */
+struct i2c_msg {
+	__u16 addr;	/* slave address			*/
+ 	__u16 flags;		
+#define I2C_M_TEN	0x10	/* we have a ten bit chip address	*/
+#define I2C_M_RD	0x01
+#define I2C_M_NOSTART	0x4000
+#define I2C_M_REV_DIR_ADDR	0x2000
+#define I2C_M_IGNORE_NAK	0x1000
+#define I2C_M_NO_RD_ACK		0x0800
+ 	__u16 len;		/* msg length				*/
+ 	__u8 *buf;		/* pointer to msg data			*/
+};
+
 struct i2c_algorithm;
 struct i2c_adapter;
 struct i2c_client;
@@ -379,21 +394,6 @@
 /* Return 1 if adapter supports everything we need, 0 if not. */
 extern int i2c_check_functionality (struct i2c_adapter *adap, u32 func);
 
-/*
- * I2C Message - used for pure i2c transaction, also from /dev interface
- */
-struct i2c_msg {
-	__u16 addr;	/* slave address			*/
- 	__u16 flags;		
-#define I2C_M_TEN	0x10	/* we have a ten bit chip address	*/
-#define I2C_M_RD	0x01
-#define I2C_M_NOSTART	0x4000
-#define I2C_M_REV_DIR_ADDR	0x2000
-#define I2C_M_IGNORE_NAK	0x1000
-#define I2C_M_NO_RD_ACK		0x0800
- 	__u16 len;		/* msg length				*/
- 	__u8 *buf;		/* pointer to msg data			*/
-};
 
 /* To determine what functionality is present */
 
--- a/drivers/char/isicom.c.orig	2005-03-16 01:08:59.000000000 +0100
+++ b/drivers/char/isicom.c	2005-03-16 10:15:56.000000000 +0100
@@ -151,9 +151,6 @@
 static int prev_card = 3;	/*	start servicing isi_card[0]	*/
 static struct tty_driver *isicom_normal;
 
-static struct isi_board isi_card[BOARD_COUNT];
-static struct isi_port  isi_ports[PORT_COUNT];
-
 static struct timer_list tx;
 static char re_schedule = 1;
 #ifdef ISICOM_DEBUG
@@ -210,6 +207,9 @@
 	int			xmit_cnt;
 };
 
+static struct isi_board isi_card[BOARD_COUNT];
+static struct isi_port  isi_ports[PORT_COUNT];
+
 /*
  *	Locking functions for card level locking. We need to own both
  *	the kernel lock for the card and have the card in a position that
--- a/drivers/input/mouse/psmouse.h.orig	2005-03-13 07:44:40.000000000 +0100
+++ b/drivers/input/mouse/psmouse.h	2005-03-13 14:08:06.000000000 +0100
@@ -1,6 +1,8 @@
 #ifndef _PSMOUSE_H
 #define _PSMOUSE_H
 
+#include <linux/libps2.h>
+
 #define PSMOUSE_CMD_SETSCALE11	0x00e6
 #define PSMOUSE_CMD_SETSCALE21	0x00e7
 #define PSMOUSE_CMD_SETRES	0x10e8
--- a/drivers/media/dvb/bt8xx/bt878.h.orig	2004-12-24 22:35:50.000000000 +0100
+++ b/drivers/media/dvb/bt8xx/bt878.h	2005-02-14 23:46:30.575062328 +0100
@@ -88,9 +88,6 @@
 
 #define BT878_RISC_SYNC_MASK	(1 << 15)
 
-extern int bt878_num;
-extern struct bt878 bt878[BT878_MAX];
-
 struct bt878 {
 	struct semaphore  gpio_lock;
 	unsigned int nr;
@@ -124,6 +121,9 @@
 	int shutdown;	
 };
 
+extern int bt878_num;
+extern struct bt878 bt878[BT878_MAX];
+
 void bt878_start(struct bt878 *bt, u32 controlreg, u32 op_sync_orin,
 		u32 irq_err_ignore);
 void bt878_stop(struct bt878 *bt);	     
--- a/drivers/media/video/bttvp.h.orig	2004-12-24 22:35:50.000000000 +0100
+++ b/drivers/media/video/bttvp.h	2005-02-14 23:52:36.512431392 +0100
@@ -250,17 +250,6 @@
 #define dprintk  if (bttv_debug >= 1) printk
 #define d2printk if (bttv_debug >= 2) printk
 
-/* our devices */
-#define BTTV_MAX 16
-extern unsigned int bttv_num;
-extern struct bttv bttvs[BTTV_MAX];
-
-#define BTTV_MAX_FBUF   0x208000
-#define VBIBUF_SIZE     (2048*VBI_MAXLINES*2)
-#define BTTV_TIMEOUT    (HZ/2) /* 0.5 seconds */
-#define BTTV_FREE_IDLE  (HZ)   /* one second */
-
-
 struct bttv_pll_info {
 	unsigned int pll_ifreq;    /* PLL input frequency        */
 	unsigned int pll_ofreq;    /* PLL output frequency       */
@@ -401,6 +390,16 @@
 	struct bttv_fh init;
 };
 
+/* our devices */
+#define BTTV_MAX 16
+extern unsigned int bttv_num;
+extern struct bttv bttvs[BTTV_MAX];
+
+#define BTTV_MAX_FBUF   0x208000
+#define VBIBUF_SIZE     (2048*VBI_MAXLINES*2)
+#define BTTV_TIMEOUT    (HZ/2) /* 0.5 seconds */
+#define BTTV_FREE_IDLE  (HZ)   /* one second */
+
 /* private ioctls */
 #define BTTV_VERSION            _IOR('v' , BASE_VIDIOCPRIVATE+6, int)
 #define BTTV_VBISIZE            _IOR('v' , BASE_VIDIOCPRIVATE+8, int)
