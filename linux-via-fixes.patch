This path contains the following (from the ac patch):

- VIA timer bugfix
- VIA provided workaround for VIA southbridge
- IDE VIA driver update

--- arch/i386/kernel/time.c.orig	Sat Jun  2 16:06:59 2001
+++ arch/i386/kernel/time.c	Sat Jun  2 16:07:20 2001
@@ -178,6 +178,15 @@
  	jiffies_t = jiffies;
 
 	count |= inb_p(0x40) << 8;
+	
+        /* VIA686a test code... reset the latch if count > max + 1 */
+        if (count > LATCH) {
+                outb_p(0x34, 0x43);
+                outb_p(LATCH & 0xff, 0x40);
+                outb(LATCH >> 8, 0x40);
+                count = LATCH - 1;
+        }
+	
 	spin_unlock(&i8253_lock);
 
 	/*
@@ -492,6 +501,24 @@
 
 		count = inb_p(0x40);    /* read the latched count */
 		count |= inb(0x40) << 8;
+		
+
+                /* VIA686a test code... reset the latch if count > max */
+                if (count > LATCH-1) {
+                        static int last_whine;
+                        outb_p(0x34, 0x43);   
+                        outb_p(LATCH & 0xff, 0x40);
+                        outb(LATCH >> 8, 0x40);
+                        count = LATCH - 1;
+                        if(time_after(jiffies, last_whine))
+                        {
+                                printk(KERN_WARNING "probable hardware bug: clock timer configuration lost - probably a VIA686a motherboard.\n");
+                                printk(KERN_WARNING "probable hardware bug: restoring chip configuration.\n");
+                                last_whine = jiffies + HZ;
+                        }                       
+                }                               
+
+		
 		spin_unlock(&i8253_lock);
 
 		count = ((LATCH-1) - count) * TICK_SIZE;
diff -u --new-file --recursive --exclude-from /usr/src/exclude linux.vanilla/Documentation/Configure.help linux.ac/Documentation/Configure.help
--- linux.vanilla/Documentation/Configure.help	Wed Jul  4 12:21:16 2001
+++ linux.ac/Documentation/Configure.help	Mon Jul 16 12:27:43 2001
@@ -979,12 +1186,10 @@
 VIA82CXXX chipset support
 CONFIG_BLK_DEV_VIA82CXXX
   This allows you to configure your chipset for a better use while
-  running (U)DMA: it will allow you to enable efficiently the second
-  channel dma usage, as it may not be set by BIOS. It allows you to
-  pass a kernel command line at boot time in order to set fifo
-  config. If no command line is provided, it will try to set fifo
+  running PIO/(U)DMA, it will allow you to enable efficiently the second
+  channel dma usage, as it may not be set by BIOS. It will try to set fifo
   configuration at its best. It will allow you to get information from
-  /proc/ide/via provided you enabled "proc" support.
+  /proc/ide/via provided you enabled "/proc file system" support.
 
   Please read the comments at the top of drivers/ide/via82cxxx.c
 
@@ -993,11 +1198,17 @@
 
   If unsure, say N.
 
-VIA82CXXX Tuning support (WIP)
-CONFIG_VIA82CXXX_TUNING
-  Please read the comments at the top of drivers/ide/via82cxxx.c
-
-  If unsure, say N.
+VIA 82C686 MIDI
+CONFIG_MIDI_VIA82CXXX
+  Answer Y to use the MIDI interface of the Via686. You may need
+  to enable this in the BIOS before it will work. This is for
+  connection  to external MIDI hardware, and is not required for software
+  playback of MIDI files.
+
+RapIDE interface support
+CONFIG_BLK_DEV_IDE_RAPIDE
+  Say Y here if you want to support the Yellowstone RapIDE controller
+  manufactured for use with Acorn computers.
 
 Other IDE chipset support
 CONFIG_IDE_CHIPSETS
diff -u --new-file --recursive --exclude-from /usr/src/exclude linux.vanilla/drivers/pci/quirks.c linux.ac/drivers/pci/quirks.c
--- linux.vanilla/drivers/pci/quirks.c	Wed Jul  4 12:21:37 2001
+++ linux.ac/drivers/pci/quirks.c	Mon Jul 16 13:28:30 2001
@@ -92,42 +92,58 @@
  *	see PCI Latency Adjust on http://www.viahardware.com/download/viatweak.shtm
  *      Also see http://home.tiscalinet.de/au-ja/review-kt133a-1-en.html for
  *      the info on which Mr Breese based his work.
+ *
+ *	Updated based on further information from the site and also on
+ *	information provided by VIA 
  */
 static void __init quirk_vialatency(struct pci_dev *dev)
 {
-	u8 r70;
+	struct pci_dev *p;
 	u8 rev;
-	struct pci_dev *vt82c686;
-   
-   
-	/* we want to look for a VT82C686 south bridge, and then apply the via latency
-	 * patch if we find that it's a 686B (by revision) <cpbotha@ieee.org>
+	u8 busarb;
+	/* Ok we have a potential problem chipset here. Now see if we have
+	   a buggy southbridge */
+	   
+	p=pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686, NULL);
+	if(p!=NULL)
+	{
+		pci_read_config_byte(p, PCI_CLASS_REVISION, &rev);
+		/* 0x40 - 0x4f == 686B, 0x10 - 0x2f == 686A; thanks Dan Hollis */
+		/* Check for buggy part revisions */
+		if (rev < 0x40 || rev > 0x42) 
+			return;
+	}
+	else
+	{
+		p = pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8231, NULL);
+		if(p==NULL)	/* No problem parts */
+			return;
+		pci_read_config_byte(p, PCI_CLASS_REVISION, &rev);
+		/* Check for buggy part revisions */
+		if (rev < 0x10 || rev > 0x12) 
+			return;
+	}
+	
+	/*
+	 *	Ok we have the problem. Now set the PCI master grant to 
+	 *	occur every master grant. The apparent bug is that under high
+	 *	PCI load (quite common in Linux of course) you can get data
+	 *	loss when the CPU is held off the bus for 3 bus master requests
+	 *	This happens to include the IDE controllers....
+	 *
+	 *	VIA only apply this fix when an SB Live! is present but under
+	 *	both Linux and Windows this isnt enough, and we have seen
+	 *	corruption without SB Live! but with things like 3 UDMA IDE
+	 *	controllers. So we ignore that bit of the VIA recommendation..
 	 */
-	vt82c686 = pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686, NULL);
-	if (vt82c686)   
-     	{
-		pci_read_config_byte(vt82c686, PCI_CLASS_REVISION, &rev);
-        	/* 0x40 - 0x4f == 686B, 0x10 - 0x2f == 686A; thanks Dan Hollis */
-		if (rev >= 0x40 && rev <= 0x4f)
-		{
-        		printk(KERN_INFO "Applying VIA PCI latency patch (found VT82C686B).\n");
-			/*
-	 		 *    In register 0x70, mask off bit 2 (PCI Master read caching)
-	 		 *    and 1 (Delay Transaction)
-	 		 */
-			pci_read_config_byte(dev, 0x70, &r70);
-			r70 &= 0xf9;
-			pci_write_config_byte(dev, 0x70, r70);
-			/*
-	 	 	 *    Turn off PCI Latency timeout (set to 0 clocks)
-	 	 	 */
-			pci_write_config_byte(dev, 0x75, 0x80);
-		}
-		else
-		{
-			printk(KERN_INFO "Found VT82C686A, not applying VIA latency patch.\n");
-		}
-	} /* if (vt82c686) ... */
+
+	pci_read_config_byte(dev, 0x76, &busarb);
+	/* Set bit 4 and bi 5 of byte 76 to 0x01 
+	   "Master priority rotation on every PCI master grant */
+	busarb &= ~(1<<5);
+	busarb |= (1<<4);
+	pci_write_config_byte(dev, 0x76, busarb);
+	printk(KERN_INFO "Applying VIA southbridge workaround.\n");
 }
 
 /*
@@ -416,6 +432,8 @@
 	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_5597,		quirk_nopcipci },
 	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_496,		quirk_nopcipci },
 	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8363_0,	quirk_vialatency },
+	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8371_1,	quirk_vialatency },
+	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	0x3112	/* Not out yet ? */,	quirk_vialatency },
 	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C597_0,	quirk_viaetbf },
 	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C597_0,	quirk_vt82c598_id },
 	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_3,	quirk_vt82c586_acpi },
diff -u --new-file --recursive --exclude-from /usr/src/exclude linux.vanilla/drivers/ide/via82cxxx.c linux.ac/drivers/ide/via82cxxx.c
--- linux.vanilla/drivers/ide/via82cxxx.c	Sat Feb  3 19:27:43 2001
+++ linux.ac/drivers/ide/via82cxxx.c	Tue Apr  3 17:54:42 2001
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 2000-2001 Vojtech Pavlik
  *
@@ -32,14 +32,9 @@
  *   PIO 0-5, MWDMA 0-2, SWDMA 0-2 and UDMA 0-5
  *
  * (this includes UDMA33, 66 and 100) modes. UDMA66 and higher modes are
- * autodetected only in case the BIOS has detected a 80 wire cable. To ignore
- * the BIOS data, use 'ide0=ata66' or 'ide1=ata66' on the kernel command line.
- *
- * For correct operation it's needed to tell the driver the speed of the PCI
- * bus. The default, and most common value is 33 MHz. Most likely, your system
- * is using this value and you don't need to use any command line options. If
- * you run your PCI bus speed at 25, 30, 37, 40 or 42 MHz, use the 'idebus=xx'
- * option of the IDE driver. Note that this has nothing to do with UDMA66.
+ * autoenabled only in case the BIOS has detected a 80 wire cable. To ignore
+ * the BIOS data and assume the cable is present, use 'ide0=ata66' or
+ * 'ide1=ata66' on the kernel command line.
  */
 
 /*
@@ -84,15 +79,16 @@
 #define VIA_ADDRESS_SETUP	0x4c
 #define VIA_UDMA_TIMING		0x50
 
-#define VIA_UDMA		0x07
-#define VIA_UDMA_NONE		0x00
-#define VIA_UDMA_33		0x01
-#define VIA_UDMA_66		0x02
-#define VIA_UDMA_100		0x03
-#define VIA_BAD_PREQ		0x10
-#define VIA_BAD_CLK66		0x20
-#define VIA_SET_FIFO		0x40
-#define VIA_SET_THRESH		0x80
+#define VIA_UDMA		0x007
+#define VIA_UDMA_NONE		0x000
+#define VIA_UDMA_33		0x001
+#define VIA_UDMA_66		0x002
+#define VIA_UDMA_100		0x003
+#define VIA_BAD_PREQ		0x010	/* Crashes if PREQ# till DDACK# set */
+#define VIA_BAD_CLK66		0x020	/* 66 MHz clock doesn't work correctly */
+#define VIA_SET_FIFO		0x040	/* Needs to have FIFO split set */
+#define VIA_SET_THRESH		0x080	/* Needs to have FIFO thresholds set */
+#define VIA_BAD_PIO		0x100	/* Always uses 26 PCICLK/xfer regardles of PIO mode */
 
 /*
  * VIA SouthBridge chips.
@@ -103,13 +99,15 @@
 	unsigned short id;
 	unsigned char rev_min;
 	unsigned char rev_max;
-	unsigned char flags;
+	unsigned short flags;
 } via_isa_bridges[] = {
+#ifdef VIA_NEW_BRIDGES_TESTED
 	{ "vt8233",	PCI_DEVICE_ID_VIA_8233_0,   0x00, 0x2f, VIA_UDMA_100 },
 	{ "vt8231",	PCI_DEVICE_ID_VIA_8231,     0x00, 0x2f, VIA_UDMA_66 },
-	{ "vt82c686b",	PCI_DEVICE_ID_VIA_82C686,   0x40, 0x4f, VIA_UDMA_100 },
+#endif
+	{ "vt82c686b",	PCI_DEVICE_ID_VIA_82C686,   0x40, 0x4f, VIA_UDMA_100 | VIA_BAD_PIO },
 	{ "vt82c686a",	PCI_DEVICE_ID_VIA_82C686,   0x10, 0x2f, VIA_UDMA_66 },
-	{ "vt82c686",	PCI_DEVICE_ID_VIA_82C686,   0x00, 0x0f, VIA_UDMA_66 },
+	{ "vt82c686",	PCI_DEVICE_ID_VIA_82C686,   0x00, 0x0f, VIA_UDMA_33 | VIA_BAD_CLK66 },
 	{ "vt82c596b",	PCI_DEVICE_ID_VIA_82C596,   0x10, 0x2f, VIA_UDMA_66 },
 	{ "vt82c596a",	PCI_DEVICE_ID_VIA_82C596,   0x00, 0x0f, VIA_UDMA_33 | VIA_BAD_CLK66 },
 	{ "vt82c586b",	PCI_DEVICE_ID_VIA_82C586_0, 0x40, 0x4f, VIA_UDMA_33 | VIA_SET_FIFO | VIA_BAD_PREQ },
@@ -123,6 +121,7 @@
 static unsigned char via_enabled;
 static unsigned int via_80w;
 static unsigned int via_clock;
+static char *via_dma[] = { "MWDMA16", "UDMA33", "UDMA66", "UDMA100" };
 
 /*
  * VIA /proc entry.
@@ -145,8 +144,8 @@
 
 static int via_get_info(char *buffer, char **addr, off_t offset, int count)
 {
-	short speed[4], cycle[4], setup[4], active[4],
-		recover[4], uen[4], udma[4], active8b[4], recover8b[4];
+	short speed[4], cycle[4], setup[4], active[4], recover[4], den[4],
+		 uen[4], udma[4], umul[4], active8b[4], recover8b[4];
 	struct pci_dev *dev = bmide_dev;
 	unsigned int v, u, i;
 	unsigned short c, w;
@@ -155,12 +154,13 @@
 
 	via_print("----------VIA BusMastering IDE Configuration----------------");
 
-	via_print("Driver Version:                     3.20");
+	via_print("Driver Version:                     3.23");
 	via_print("South Bridge:                       VIA %s", via_config->name);
 
 	pci_read_config_byte(isa_dev, PCI_REVISION_ID, &t);
 	pci_read_config_byte(dev, PCI_REVISION_ID, &x);
 	via_print("Revision:                           ISA %#x IDE %#x", t, x);
+	via_print("Highest DMA rate:                   %s", via_dma[via_config->flags & VIA_UDMA]);
 
 	via_print("BM-DMA base:                        %#x", via_base);
 	via_print("PCI clock:                          %dMHz", via_clock);
@@ -200,28 +200,43 @@
 	else u = 0;
 
 	for (i = 0; i < 4; i++) {
+
 		setup[i]     = ((t >> ((3 - i) << 1)) & 0x3) + 1;
 		recover8b[i] = ((w >> ((1 - (i >> 1)) << 3)) & 0xf) + 1;
 		active8b[i]  = ((w >> (((1 - (i >> 1)) << 3) + 4)) & 0xf) + 1;
 		active[i]    = ((v >> (((3 - i) << 3) + 4)) & 0xf) + 1;
 		recover[i]   = ((v >> ((3 - i) << 3)) & 0xf) + 1;
 		udma[i]      = ((u >> ((3 - i) << 3)) & 0x7) + 2;
+		umul[i]      = ((u >> (((3 - i) & 2) << 3)) & 0x8) ? 1 : 2;
+		uen[i]       = ((u >> ((3 - i) << 3)) & 0x20);
+		den[i]       = (c & ((i & 1) ? 0x40 : 0x20) << ((i & 2) << 2));
+
+		speed[i] = 20 * via_clock / (active[i] + recover[i]);
+		cycle[i] = 1000 / via_clock * (active[i] + recover[i]);
 
-		if ((via_config->flags & VIA_UDMA) == VIA_UDMA_100) {
-			speed[i] = 2000 / udma[i];
-			cycle[i] = 10 * udma[i];
+		if (!uen[i] || !den[i])
 			continue;
-		}
 
-		uen[i]   = (u >> ((3 - i) << 3)) & 0x20;
-		udma[i] *= ((u >> (((3 - i) & 2) << 3)) & 0x8) ? 1 : 2;
+		switch (via_config->flags & VIA_UDMA) {
+			
+			case VIA_UDMA_100:
+				speed[i] = 2000 / udma[i];
+				cycle[i] = 10 * udma[i];
+				break;
+
+			case VIA_UDMA_66:
+				speed[i] = 40 * via_clock / (udma[i] * umul[i]);
+				cycle[i] = 500 / via_clock * (udma[i] * umul[i]);
+				break;
 
-		speed[i] = 40 * via_clock / (uen[i] ? udma[i] : (active[i] + recover[i]) * 2);
-		cycle[i] = 1000 / via_clock * (uen[i] ? udma[i] : (active[i] + recover[i]) * 2) / 2;
+			case VIA_UDMA_33:
+				speed[i] = 20 * via_clock / udma[i];
+				cycle[i] = 1000 / via_clock * udma[i];
+				break;
+		}
 	}
 
-	via_print_drive("Transfer Mode: ", "%10s",
-			(c & ((i & 1) ? 0x40 : 0x20) << ((i & 2) << 2)) ? (uen[i] ? "UDMA" : "DMA") : "PIO");
+	via_print_drive("Transfer Mode: ", "%10s", den[i] ? (uen[i] ? "UDMA" : "DMA") : "PIO");
 
 	via_print_drive("Address Setup: ", "%8dns", (1000 / via_clock) * setup[i]);
 	via_print_drive("Cmd Active:    ", "%8dns", (1000 / via_clock) * active8b[i]);
@@ -342,12 +357,13 @@
 		short speed = ide_find_best_mode(drive,
 			XFER_PIO | XFER_EPIO | XFER_SWDMA | XFER_MWDMA |
 			(via_config->flags & VIA_UDMA ? XFER_UDMA : 0) |
-			(w80 && (via_config->flags & VIA_UDMA) == VIA_UDMA_66 ? XFER_UDMA_66 : 0) |
-			(w80 && (via_config->flags & VIA_UDMA) == VIA_UDMA_100 ? XFER_UDMA_100 : 0));
-
-		func = ((speed & XFER_MODE) != XFER_PIO) ? ide_dma_on : ide_dma_off_quietly;
+			(w80 && (via_config->flags & VIA_UDMA) >= VIA_UDMA_66 ? XFER_UDMA_66 : 0) |
+			(w80 && (via_config->flags & VIA_UDMA) >= VIA_UDMA_100 ? XFER_UDMA_100 : 0));
 
 		via_set_drive(drive, speed);
+
+		func = (HWIF(drive)->autodma && (speed & XFER_MODE) != XFER_PIO)
+			? ide_dma_on : ide_dma_off_quietly;
 	}
 
 	return ide_dmaproc(func, drive);
@@ -459,11 +475,7 @@
 
 	pci_read_config_byte(isa, PCI_REVISION_ID, &t);
 	printk(KERN_INFO "VP_IDE: VIA %s (rev %02x) IDE %s controller on pci%s\n",
-			via_config->name, t,
-			(via_config->flags & VIA_UDMA) == VIA_UDMA_100 ? "UDMA100" :
-			(via_config->flags & VIA_UDMA) == VIA_UDMA_66 ? "UDMA66" :
-			(via_config->flags & VIA_UDMA) == VIA_UDMA_33 ? "UDMA33" : "MWDMA16",
-			dev->slot_name);
+		via_config->name, t, via_dma[via_config->flags & VIA_UDMA], dev->slot_name);
 
 /*
  * Setup /proc/ide/via entry.
@@ -471,11 +483,11 @@
 
 #ifdef CONFIG_PROC_FS
 	if (!via_proc) {
-		via_proc = 1;
 		via_base = pci_resource_start(dev, 4);
 		bmide_dev = dev;
 		isa_dev = isa;
 		via_display_info = &via_get_info;
+		via_proc = 1;
 	}
 #endif
 
@@ -506,7 +518,8 @@
 	if (hwif->dma_base) {
 		hwif->dmaproc = &via82cxxx_dmaproc;
 #ifdef CONFIG_IDEDMA_AUTO
-		hwif->autodma = 1;
+		if (!noautodma)
+			hwif->autodma = 1;
 #endif
 	}
 #endif /* CONFIG_BLK_DEV_IDEDMA */
