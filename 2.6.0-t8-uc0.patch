diff -Naur linux-2.6.0-test8/arch/m68knommu/Kconfig linux-2.6.0-test8-uc0/arch/m68knommu/Kconfig
--- linux-2.6.0-test8/arch/m68knommu/Kconfig	2003-10-20 09:10:57.875635776 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/Kconfig	2003-10-20 09:11:53.701149008 +1000
@@ -560,6 +560,14 @@
 	help
 	  Enable debuging symbols on kernel build.
 
+config FRAME_POINTER
+	bool "Compile the kernel with frame pointers"
+	help
+	  If you say Y here the resulting kernel image will be slightly larger
+	  and slower, but it will give very useful debugging information.
+	  If you don't debug the kernel, you can say N, but we may not be able
+	  to solve problems without frame pointers.
+
 config MAGIC_SYSRQ
 	bool "Magic SysRq key"
 	help
diff -Naur linux-2.6.0-test8/arch/m68knommu/kernel/comempci.c linux-2.6.0-test8-uc0/arch/m68knommu/kernel/comempci.c
--- linux-2.6.0-test8/arch/m68knommu/kernel/comempci.c	2003-10-20 09:10:57.723658880 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/kernel/comempci.c	2003-10-20 09:11:54.088090184 +1000
@@ -89,7 +89,7 @@
 	int	i;
 
 #ifdef DEBUGPCI
-	printk("pci_resetbus()\n");
+	printk(KERN_DEBUG "pci_resetbus()\n");
 #endif
 
 	*((volatile unsigned short *) (MCF_MBAR+MCFSIM_PADDR)) |= eLIA_PCIRESET;
@@ -113,7 +113,7 @@
 	int			bar;
 
 #ifdef DEBUGPCI
-	printk("pcibios_assign_resource_slot(slot=%x)\n", slot);
+	printk(KERN_INFO "pcibios_assign_resource_slot(slot=%x)\n", slot);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -125,9 +125,9 @@
 		rp[LREG(COMEM_DAHBASE)] = COMEM_DA_CFGRD | idsel;
 		val = rp[LREG(addr)];
 #ifdef DEBUGRES
-		printk("-----------------------------------"
+		printk(KERN_DEBUG "-----------------------------------"
 			"-------------------------------------\n");
-		printk("BAR[%d]: read=%08x ", bar, val);
+		printk(KERN_DEBUG "BAR[%d]: read=%08x ", bar, val);
 #endif
 
 		rp[LREG(COMEM_DAHBASE)] = COMEM_DA_CFGWR | idsel;
@@ -136,11 +136,11 @@
 		rp[LREG(COMEM_DAHBASE)] = COMEM_DA_CFGRD | idsel;
 		val = rp[LREG(addr)];
 #ifdef DEBUGRES
-		printk("write=%08x ", val);
+		printk(KERN_DEBUG "write=%08x ", val);
 #endif
 		if (val == 0) {
 #ifdef DEBUGRES
-			printk("\n");
+			printk(KERN_DEBUG "\n");
 #endif
 			continue;
 		}
@@ -153,7 +153,7 @@
 		}
 
 #ifdef DEBUGRES
-		printk("size=%08x(%d)\n", (0x1 << i), i);
+		printk(KERN_DEBUG "size=%08x(%d)\n", (0x1 << i), i);
 #endif
 		i = 0x1 << i;
 
@@ -162,14 +162,14 @@
 			if (i < PCI_MINIO)
 				i = PCI_MINIO;
 #ifdef DEBUGRES
-			printk("BAR[%d]: IO size=%08x iobase=%08x\n",
+			printk(KERN_DEBUG "BAR[%d]: IO size=%08x iobase=%08x\n",
 				bar, i, pci_iobase);
 #endif
 			if (i > 0xffff) {
 				/* Invalid size?? */
 				val = 0 | PCI_BASE_ADDRESS_SPACE_IO;
 #ifdef DEBUGRES
-				printk("BAR[%d]: too big for IO??\n", bar);
+				printk(KERN_DEBUG "BAR[%d]: too big for IO??\n", bar);
 #endif
 			} else {
 				/* Check for un-alignment */
@@ -182,7 +182,7 @@
 			if (i < PCI_MINMEM)
 				i = PCI_MINMEM;
 #ifdef DEBUGRES
-			printk("BAR[%d]: MEMORY size=%08x membase=%08x\n",
+			printk(KERN_DEBUG "BAR[%d]: MEMORY size=%08x membase=%08x\n",
 				bar, i, pci_membase);
 #endif
 			/* Check for un-alignment */
@@ -196,12 +196,12 @@
 		rp[LREG(COMEM_DAHBASE)] = COMEM_DA_CFGWR | idsel;
 		rp[LREG(addr)] = val;
 #ifdef DEBUGRES
-		printk("BAR[%d]: assigned bar=%08x\n", bar, val);
+		printk(KERN_DEBUG "BAR[%d]: assigned bar=%08x\n", bar, val);
 #endif
 	}
 
 #ifdef DEBUGRES
-	printk("-----------------------------------"
+	printk(KERN_DEBUG "-----------------------------------"
 			"-------------------------------------\n");
 #endif
 
@@ -215,7 +215,7 @@
 		addr = (PCI_INTERRUPT_LINE & 0xfc)+(~PCI_INTERRUPT_LINE & 0x03);
 		ip[addr] = 25;
 #ifdef DEBUGRES
-		printk("IRQ LINE=25\n");
+		printk(KERN_DEBUG "IRQ LINE=25\n");
 #endif
 	}
 
@@ -232,7 +232,7 @@
 	unsigned short		cmd;
 
 #ifdef DEBUGPCI
-	printk("pcibios_enbale_slot(slot=%x)\n", slot);
+	printk(KERN_DEBUG "pcibios_enbale_slot(slot=%x)\n", slot);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -273,7 +273,7 @@
 		rp[LREG(COMEM_PCIBUS)] = 0; /* Clear bus */
 		id = rp[LREG(COMEM_PCIBUS)];
 		if ((id != 0) && ((id & 0xffff0000) != (sel & 0xffff0000))) {
-			printk("PCI: slot=%d id=%08x\n", slot, (int) id);
+			printk(KERN_INFO "PCI: slot=%d id=%08x\n", slot, (int) id);
 			pci_slotmask |= 0x1 << slot;
 			pcibios_assign_resource_slot(slot);
 			pcibios_enable_slot(slot);
@@ -290,7 +290,7 @@
 	int			slot;
 
 #ifdef DEBUGPCI
-	printk("pcibios_init()\n");
+	printk(KERN_DEBUG "pcibios_init()\n");
 #endif
 
 	pci_resetbus();
@@ -302,7 +302,7 @@
 	 */
 	rp = (volatile unsigned long *) COMEM_BASE;
 	if ((rp[LREG(COMEM_LBUSCFG)] & 0xff) != 0x50) {
-		printk("PCI: no PCI bus present\n");
+		printk(KERN_INFO "PCI: no PCI bus present\n");
 		return(0);
 	}
 
@@ -317,11 +317,11 @@
 	rp[LREG(COMEM_PCIBUS)] = 0; /* Clear bus */
 	id = rp[LREG(COMEM_PCIBUS)];
 	if ((id == 0) || ((id & 0xffff0000) == (sel & 0xffff0000))) {
-		printk("PCI: no PCI bus bridge present\n");
+		printk(KERN_INFO "PCI: no PCI bus bridge present\n");
 		return(0);
 	}
 
-	printk("PCI: bridge device at slot=%d id=%08x\n", slot, (int) id);
+	printk(KERN_INFO "PCI: bridge device at slot=%d id=%08x\n", slot, (int) id);
 	pci_slotmask |= 0x1 << slot;
 	pci_shmemaddr = pci_membase;
 	pcibios_assign_resource_slot(slot);
@@ -332,7 +332,7 @@
 
 	/* Get PCI irq for local vectoring */
 	if (request_irq(COMEM_IRQ, pci_interrupt, 0, "PCI bridge", NULL)) {
-		printk("PCI: failed to acquire interrupt %d\n", COMEM_IRQ);
+		printk(KERN_WARNING "PCI: failed to acquire interrupt %d\n", COMEM_IRQ);
 	} else {
 		mcf_autovector(COMEM_IRQ);
 	}
@@ -379,7 +379,7 @@
 
 void pcibios_update_resource(struct pci_dev *dev, struct resource *root, struct resource *r, int resource)
 {
-	printk("%s(%d): no support for changing PCI resources...\n",
+	printk(KERN_WARNING "%s(%d): no support for changing PCI resources...\n",
 		__FILE__, __LINE__);
 }
 
@@ -401,7 +401,7 @@
 	volatile unsigned char	*bp;
 
 #ifdef DEBUGIO
-	printk("pci_outb(val=%02x,addr=%x)\n", val, addr);
+	printk(KERN_DEBUG "pci_outb(val=%02x,addr=%x)\n", val, addr);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -419,7 +419,7 @@
 	volatile unsigned short	*sp;
 
 #ifdef DEBUGIO
-	printk("pci_outw(val=%04x,addr=%x)", val, addr);
+	printk(KERN_DEBUG "pci_outw(val=%04x,addr=%x)", val, addr);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -439,7 +439,7 @@
 	volatile unsigned int	*lp;
 
 #ifdef DEBUGIO
-	printk("pci_outl(val=%08x,addr=%x)\n", val, addr);
+	printk(KERN_DEBUG "pci_outl(val=%08x,addr=%x)\n", val, addr);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -470,7 +470,7 @@
 	unsigned char		val;
 
 #ifdef DEBUGIO
-	printk("pci_inb(addr=%x)", addr);
+	printk(KERN_DEBUG "pci_inb(addr=%x)", addr);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -501,7 +501,7 @@
 	unsigned short		val;
 
 #ifdef DEBUGIO
-	printk("pci_inw(addr=%x)", addr);
+	printk(KERN_DEBUG "pci_inw(addr=%x)", addr);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -514,7 +514,7 @@
 	if (pci_byteswap)
 		val = ((val & 0xff) << 8) | ((val >> 8) & 0xff);
 #ifdef DEBUGIO
-	printk("=%04x\n", val);
+	printk(KERN_DEBUG "=%04x\n", val);
 #endif
 	return(val);
 }
@@ -528,7 +528,7 @@
 	unsigned int		val;
 
 #ifdef DEBUGIO
-	printk("pci_inl(addr=%x)", addr);
+	printk(KERN_DEBUG "pci_inl(addr=%x)", addr);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -541,7 +541,7 @@
 			((val & 0x00ff0000) >> 8) | (val >> 24);
 
 #ifdef DEBUGIO
-	printk("=%08x\n", val);
+	printk(KERN_DEBUG "=%08x\n", val);
 #endif
 	return(val);
 }
@@ -556,7 +556,7 @@
 	unsigned int		a = (unsigned int) addr;
 
 #ifdef DEBUGIO
-	printk("pci_outsb(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
+	printk(KERN_DEBUG "pci_outsb(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -580,7 +580,7 @@
 	unsigned int		a = (unsigned int) addr;
 
 #ifdef DEBUGIO
-	printk("pci_outsw(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
+	printk(KERN_DEBUG "pci_outsw(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -608,7 +608,7 @@
 	unsigned int		a = (unsigned int) addr;
 
 #ifdef DEBUGIO
-	printk("pci_outsl(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
+	printk(KERN_DEBUG "pci_outsl(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -636,7 +636,7 @@
 	unsigned int		a = (unsigned int) addr;
 
 #ifdef DEBUGIO
-	printk("pci_insb(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
+	printk(KERN_DEBUG "pci_insb(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -660,7 +660,7 @@
 	unsigned int		a = (unsigned int) addr;
 
 #ifdef DEBUGIO
-	printk("pci_insw(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
+	printk(KERN_DEBUG "pci_insw(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -688,7 +688,7 @@
 	unsigned int		a = (unsigned int) addr;
 
 #ifdef DEBUGIO
-	printk("pci_insl(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
+	printk(KERN_DEBUG "pci_insl(addr=%x,buf=%x,len=%d)\n", (int)addr, (int)buf, len);
 #endif
 
 	rp = (volatile unsigned long *) COMEM_BASE;
@@ -725,7 +725,7 @@
 	int	i;
 
 #ifdef DEBUGIO
-	printk("pci_request_irq(irq=%d,handler=%x,flags=%x,device=%s,"
+	printk(KERN_DEBUG "pci_request_irq(irq=%d,handler=%x,flags=%x,device=%s,"
 		"dev_id=%x)\n", irq, (int) handler, (int) flags, device,
 		(int) dev_id);
 #endif
@@ -757,7 +757,7 @@
 	int	i;
 
 #ifdef DEBUGIO
-	printk("pci_free_irq(irq=%d,dev_id=%x)\n", irq, (int) dev_id);
+	printk(KERN_DEBUG "pci_free_irq(irq=%d,dev_id=%x)\n", irq, (int) dev_id);
 #endif
 
 	if (dev_id == (void *) NULL)
@@ -781,7 +781,7 @@
 	int	i;
 
 #ifdef DEBUGIO
-	printk("pci_interrupt(irq=%d,id=%x,fp=%x)\n", irq, (int) id, (int) fp);
+	printk(KERN_DEBUG "pci_interrupt(irq=%d,id=%x,fp=%x)\n", irq, (int) id, (int) fp);
 #endif
 
 	for (i = 0; (i < COMEM_MAXPCI); i++) {
@@ -809,7 +809,7 @@
 	int	i, j, nrslots;
 
 #ifdef DEBUGIO
-	printk("pci_bmalloc(size=%d)\n", size);
+	printk(KERN_DEBUG "pci_bmalloc(size=%d)\n", size);
 #endif
 
 	if (size <= 0)
@@ -841,7 +841,7 @@
 	int	i, j, nrslots;
 
 #ifdef DEBUGIO
-	printk("pci_bmfree(mp=%x,size=%d)\n", (int) mp, size);
+	printk(KERN_DEBUG "pci_bmfree(mp=%x,size=%d)\n", (int) mp, size);
 #endif
 
 	nrslots = size / PCI_MEMSLOTSIZE;
@@ -859,12 +859,12 @@
 	unsigned long	l;
 
 #ifdef DEBUGIO
-	printk("pci_virt_to_bus(address=%x)", (int) address);
+	printk(KERN_DEBUG "pci_virt_to_bus(address=%x)", (int) address);
 #endif
 
 	l = ((unsigned long) address) - COMEM_BASE;
 #ifdef DEBUGIO
-	printk("=%x\n", (int) (l+pci_shmemaddr));
+	printk(KERN_DEBUG "=%x\n", (int) (l+pci_shmemaddr));
 #endif
 	return(l + pci_shmemaddr);
 }
@@ -876,12 +876,12 @@
 	unsigned long	l;
 
 #ifdef DEBUGIO
-	printk("pci_bus_to_virt(address=%x)", (int) address);
+	printk(KERN_DEBUG "pci_bus_to_virt(address=%x)", (int) address);
 #endif
 
 	l = address - pci_shmemaddr;
 #ifdef DEBUGIO
-	printk("=%x\n", (int) (address + COMEM_BASE));
+	printk(KERN_DEBUG "=%x\n", (int) (address + COMEM_BASE));
 #endif
 	return((void *) (address + COMEM_BASE));
 }
@@ -895,7 +895,7 @@
 	int		i, j;
 
 #ifdef DEBUGIO
-	printk("pci_bmcpyto(dst=%x,src=%x,len=%d)\n", (int)dst, (int)src, len);
+	printk(KERN_DEBUG "pci_bmcpyto(dst=%x,src=%x,len=%d)\n", (int)dst, (int)src, len);
 #endif
 
 	dp = (unsigned long *) dst;
@@ -903,13 +903,13 @@
 	i = len >> 2;
 
 #if 0
-	printk("DATA:");
+	printk(KERN_INFO "DATA:");
 	scp = (unsigned char *) sp;
 	for (i = 0; (i < len); i++) {
-		if ((i % 16) == 0) printk("\n%04x: ", i);
-		printk("%02x ", *scp++);
+		if ((i % 16) == 0) printk(KERN_INFO "\n%04x: ", i);
+		printk(KERN_INFO "%02x ", *scp++);
 	}
-	printk("\n");
+	printk(KERN_INFO "\n");
 #endif
 
 	for (j = 0; (i >= 0); i--, j++) {
@@ -936,7 +936,7 @@
 	int		i;
 
 #ifdef DEBUGIO
-	printk("pci_bmcpyfrom(dst=%x,src=%x,len=%d)\n",(int)dst,(int)src,len);
+	printk(KERN_DEBUG "pci_bmcpyfrom(dst=%x,src=%x,len=%d)\n",(int)dst,(int)src,len);
 #endif
 
 	dp = (unsigned long *) dst;
@@ -958,13 +958,13 @@
 	}
 
 #if 0
-	printk("DATA:");
+	printk(KERN_INFO "DATA:");
 	dcp = (unsigned char *) dst;
 	for (i = 0; (i < len); i++) {
-		if ((i % 16) == 0) printk("\n%04x: ", i);
-		printk("%02x ", *dcp++);
+		if ((i % 16) == 0) printk(KERN_INFO "\n%04x: ", i);
+		printk(KERN_INFO "%02x ", *dcp++);
 	}
-	printk("\n");
+	printk(KERN_INFO "\n");
 #endif
 }
 
diff -Naur linux-2.6.0-test8/arch/m68knommu/kernel/Makefile linux-2.6.0-test8-uc0/arch/m68knommu/kernel/Makefile
--- linux-2.6.0-test8/arch/m68knommu/kernel/Makefile	2003-10-20 09:10:57.721659184 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/kernel/Makefile	2003-10-20 09:11:54.086090488 +1000
@@ -4,8 +4,8 @@
 
 extra-y := vmlinux.lds.s
 
-obj-y += entry.o init_task.o m68k_ksyms.o process.o ptrace.o \
-	 semaphore.o setup.o signal.o syscalltable.o sys_m68k.o time.o \
-	 traps.o
+obj-y += entry.o init_task.o m68k_ksyms.o process.o ptrace.o semaphore.o \
+	 setup.o signal.o syscalltable.o sys_m68k.o time.o traps.o
 
+obj-$(CONFIG_MODULES)	+= module.o
 obj-$(CONFIG_COMEMPCI)	+= comempci.o
diff -Naur linux-2.6.0-test8/arch/m68knommu/kernel/module.c linux-2.6.0-test8-uc0/arch/m68knommu/kernel/module.c
--- linux-2.6.0-test8/arch/m68knommu/kernel/module.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/kernel/module.c	2003-10-20 09:11:54.095089120 +1000
@@ -0,0 +1,99 @@
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+#if 0
+#define DEBUGP printk
+#else
+#define DEBUGP(fmt...)
+#endif
+
+void *module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+
+/* Free memory returned from module_alloc */
+void module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+	/* FIXME: If module_region == mod->init_region, trim exception
+           table entries. */
+}
+
+/* We don't need anything special. */
+int module_frob_arch_sections(Elf_Ehdr *hdr,
+			      Elf_Shdr *sechdrs,
+			      char *secstrings,
+			      struct module *mod)
+{
+	return 0;
+}
+
+int apply_relocate(Elf32_Shdr *sechdrs,
+		   const char *strtab,
+		   unsigned int symindex,
+		   unsigned int relsec,
+		   struct module *me)
+{
+	unsigned int i;
+	Elf32_Rel *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	uint32_t *location;
+
+	DEBUGP("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to.  Note that all
+		   undefined symbols have been resolved.  */
+		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
+			+ ELF32_R_SYM(rel[i].r_info);
+
+		switch (ELF32_R_TYPE(rel[i].r_info)) {
+		case R_68K_32:
+			/* We add the value into the location given */
+			*location += sym->st_value;
+			break;
+		case R_68K_PC32:
+			/* Add the value, subtract its postition */
+			*location += sym->st_value - (uint32_t)location;
+			break;
+		default:
+			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
+			       me->name, ELF32_R_TYPE(rel[i].r_info));
+			return -ENOEXEC;
+		}
+	}
+	return 0;
+}
+
+int apply_relocate_add(Elf32_Shdr *sechdrs,
+		       const char *strtab,
+		       unsigned int symindex,
+		       unsigned int relsec,
+		       struct module *me)
+{
+	printk(KERN_ERR "module %s: ADD RELOCATION unsupported\n",
+	       me->name);
+	return -ENOEXEC;
+}
+
+int module_finalize(const Elf_Ehdr *hdr,
+		    const Elf_Shdr *sechdrs,
+		    struct module *me)
+{
+	return 0;
+}
+
+void module_arch_cleanup(struct module *mod)
+{
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/kernel/process.c linux-2.6.0-test8-uc0/arch/m68knommu/kernel/process.c
--- linux-2.6.0-test8/arch/m68knommu/kernel/process.c	2003-10-20 09:10:57.720659336 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/kernel/process.c	2003-10-20 09:11:54.102088056 +1000
@@ -95,17 +95,17 @@
 
 void show_regs(struct pt_regs * regs)
 {
-	printk("\n");
-	printk("Format %02x  Vector: %04x  PC: %08lx  Status: %04x    %s\n",
+	printk(KERN_NOTICE "\n");
+	printk(KERN_NOTICE "Format %02x  Vector: %04x  PC: %08lx  Status: %04x    %s\n",
 	       regs->format, regs->vector, regs->pc, regs->sr, print_tainted());
-	printk("ORIG_D0: %08lx  D0: %08lx  A2: %08lx  A1: %08lx\n",
+	printk(KERN_NOTICE "ORIG_D0: %08lx  D0: %08lx  A2: %08lx  A1: %08lx\n",
 	       regs->orig_d0, regs->d0, regs->a2, regs->a1);
-	printk("A0: %08lx  D5: %08lx  D4: %08lx\n",
+	printk(KERN_NOTICE "A0: %08lx  D5: %08lx  D4: %08lx\n",
 	       regs->a0, regs->d5, regs->d4);
-	printk("D3: %08lx  D2: %08lx  D1: %08lx\n",
+	printk(KERN_NOTICE "D3: %08lx  D2: %08lx  D1: %08lx\n",
 	       regs->d3, regs->d2, regs->d1);
 	if (!(regs->sr & PS_S))
-		printk("USP: %08lx\n", rdusp());
+		printk(KERN_NOTICE "USP: %08lx\n", rdusp());
 }
 
 /*
@@ -328,58 +328,58 @@
 	unsigned char	*tp;
 	int		i;
 
-	printk("\nCURRENT PROCESS:\n\n");
-	printk("COMM=%s PID=%d\n", current->comm, current->pid);
+	printk(KERN_EMERG "\nCURRENT PROCESS:\n\n");
+	printk(KERN_EMERG "COMM=%s PID=%d\n", current->comm, current->pid);
 
 	if (current->mm) {
-		printk("TEXT=%08x-%08x DATA=%08x-%08x BSS=%08x-%08x\n",
+		printk(KERN_EMERG "TEXT=%08x-%08x DATA=%08x-%08x BSS=%08x-%08x\n",
 			(int) current->mm->start_code,
 			(int) current->mm->end_code,
 			(int) current->mm->start_data,
 			(int) current->mm->end_data,
 			(int) current->mm->end_data,
 			(int) current->mm->brk);
-		printk("USER-STACK=%08x  KERNEL-STACK=%08x\n\n",
+		printk(KERN_EMERG "USER-STACK=%08x  KERNEL-STACK=%08x\n\n",
 			(int) current->mm->start_stack,
 			(int)(((unsigned long) current) + KTHREAD_SIZE));
 	}
 
-	printk("PC: %08lx\n", fp->pc);
-	printk("SR: %08lx    SP: %08lx\n", (long) fp->sr, (long) fp);
-	printk("d0: %08lx    d1: %08lx    d2: %08lx    d3: %08lx\n",
+	printk(KERN_EMERG "PC: %08lx\n", fp->pc);
+	printk(KERN_EMERG "SR: %08lx    SP: %08lx\n", (long) fp->sr, (long) fp);
+	printk(KERN_EMERG "d0: %08lx    d1: %08lx    d2: %08lx    d3: %08lx\n",
 		fp->d0, fp->d1, fp->d2, fp->d3);
-	printk("d4: %08lx    d5: %08lx    a0: %08lx    a1: %08lx\n",
+	printk(KERN_EMERG "d4: %08lx    d5: %08lx    a0: %08lx    a1: %08lx\n",
 		fp->d4, fp->d5, fp->a0, fp->a1);
-	printk("\nUSP: %08x   TRAPFRAME: %08x\n", (unsigned int) rdusp(),
+	printk(KERN_EMERG "\nUSP: %08x   TRAPFRAME: %08x\n", (unsigned int) rdusp(),
 		(unsigned int) fp);
 
-	printk("\nCODE:");
+	printk(KERN_EMERG "\nCODE:");
 	tp = ((unsigned char *) fp->pc) - 0x20;
 	for (sp = (unsigned long *) tp, i = 0; (i < 0x40);  i += 4) {
 		if ((i % 0x10) == 0)
-			printk("\n%08x: ", (int) (tp + i));
-		printk("%08x ", (int) *sp++);
+			printk(KERN_EMERG "\n%08x: ", (int) (tp + i));
+		printk(KERN_EMERG "%08x ", (int) *sp++);
 	}
-	printk("\n");
+	printk(KERN_EMERG "\n");
 
-	printk("\nKERNEL STACK:");
+	printk(KERN_EMERG "\nKERNEL STACK:");
 	tp = ((unsigned char *) fp) - 0x40;
 	for (sp = (unsigned long *) tp, i = 0; (i < 0xc0); i += 4) {
 		if ((i % 0x10) == 0)
-			printk("\n%08x: ", (int) (tp + i));
-		printk("%08x ", (int) *sp++);
+			printk(KERN_EMERG "\n%08x: ", (int) (tp + i));
+		printk(KERN_EMERG "%08x ", (int) *sp++);
 	}
-	printk("\n");
-	printk("\n");
+	printk(KERN_EMERG "\n");
+	printk(KERN_EMERG "\n");
 
-	printk("\nUSER STACK:");
+	printk(KERN_EMERG "\nUSER STACK:");
 	tp = (unsigned char *) (rdusp() - 0x10);
 	for (sp = (unsigned long *) tp, i = 0; (i < 0x80); i += 4) {
 		if ((i % 0x10) == 0)
-			printk("\n%08x: ", (int) (tp + i));
-		printk("%08x ", (int) *sp++);
+			printk(KERN_EMERG "\n%08x: ", (int) (tp + i));
+		printk(KERN_EMERG "%08x ", (int) *sp++);
 	}
-	printk("\n\n");
+	printk(KERN_EMERG "\n\n");
 }
 
 /*
diff -Naur linux-2.6.0-test8/arch/m68knommu/kernel/setup.c linux-2.6.0-test8-uc0/arch/m68knommu/kernel/setup.c
--- linux-2.6.0-test8/arch/m68knommu/kernel/setup.c	2003-10-20 09:10:57.813645200 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/kernel/setup.c	2003-10-20 09:11:54.104087752 +1000
@@ -59,7 +59,7 @@
 {
 }
 
-void (*mach_sched_init) (void (*handler)(int, void *, struct pt_regs *)) = NULL;
+void (*mach_sched_init) (irqreturn_t (*handler)(int, void *, struct pt_regs *)) = NULL;
 void (*mach_tick)( void ) = NULL;
 /* machine dependent keyboard functions */
 int (*mach_keyb_init) (void) = NULL;
@@ -67,10 +67,7 @@
 void (*mach_kbd_leds) (unsigned int) = NULL;
 /* machine dependent irq functions */
 void (*mach_init_IRQ) (void) = NULL;
-void (*(*mach_default_handler)[]) (int, void *, struct pt_regs *) = NULL;
-int (*mach_request_irq) (unsigned int, void (*)(int, void *, struct pt_regs *),
-                         unsigned long, const char *, void *);
-void (*mach_free_irq) (unsigned int irq, void *dev_id) = NULL;
+irqreturn_t (*(*mach_default_handler)[]) (int, void *, struct pt_regs *) = NULL;
 void (*mach_enable_irq) (unsigned int) = NULL;
 void (*mach_disable_irq) (unsigned int) = NULL;
 int (*mach_get_irq_list) (struct seq_file *, void *) = NULL;
@@ -163,57 +160,57 @@
 
 	config_BSP(&command_line[0], sizeof(command_line));
 
-	printk("\x0F\r\n\nuClinux/" CPU "\n");
+	printk(KERN_INFO "\x0F\r\n\nuClinux/" CPU "\n");
 
 #ifdef CONFIG_UCDIMM
-	printk("uCdimm by Lineo, Inc. <www.lineo.com>\n");
+	printk(KERN_INFO "uCdimm by Lineo, Inc. <www.lineo.com>\n");
 #endif
 #ifdef CONFIG_M68VZ328
-	printk("M68VZ328 support by Evan Stawnyczy <e@lineo.ca>\n");
+	printk(KERN_INFO "M68VZ328 support by Evan Stawnyczy <e@lineo.ca>\n");
 #endif
 #ifdef CONFIG_COLDFIRE
-	printk("COLDFIRE port done by Greg Ungerer, gerg@snapgear.com\n");
+	printk(KERN_INFO "COLDFIRE port done by Greg Ungerer, gerg@snapgear.com\n");
 #ifdef CONFIG_M5307
-	printk("Modified for M5307 by Dave Miller, dmiller@intellistor.com\n");
+	printk(KERN_INFO "Modified for M5307 by Dave Miller, dmiller@intellistor.com\n");
 #endif
 #ifdef CONFIG_ELITE
-	printk("Modified for M5206eLITE by Rob Scott, rscott@mtrob.fdns.net\n");
+	printk(KERN_INFO "Modified for M5206eLITE by Rob Scott, rscott@mtrob.fdns.net\n");
 #endif  
 #ifdef CONFIG_TELOS
-	printk("Modified for Omnia ToolVox by James D. Schettine, james@telos-systems.com\n");
+	printk(KERN_INFO "Modified for Omnia ToolVox by James D. Schettine, james@telos-systems.com\n");
 #endif
 #endif
-	printk("Flat model support (C) 1998,1999 Kenneth Albanowski, D. Jeff Dionne\n");
+	printk(KERN_INFO "Flat model support (C) 1998,1999 Kenneth Albanowski, D. Jeff Dionne\n");
 
 #if defined( CONFIG_PILOT ) && defined( CONFIG_M68328 )
-	printk("TRG SuperPilot FLASH card support <info@trgnet.com>\n");
+	printk(KERN_INFO "TRG SuperPilot FLASH card support <info@trgnet.com>\n");
 #endif
 
 #if defined( CONFIG_PILOT ) && defined( CONFIG_M68EZ328 )
-	printk("PalmV support by Lineo Inc. <jeff@uclinux.com>\n");
+	printk(KERN_INFO "PalmV support by Lineo Inc. <jeff@uclinux.com>\n");
 #endif
 
 #ifdef CONFIG_M68EZ328ADS
-	printk("M68EZ328ADS board support (C) 1999 Vladimir Gurevich <vgurevic@cisco.com>\n");
+	printk(KERN_INFO "M68EZ328ADS board support (C) 1999 Vladimir Gurevich <vgurevic@cisco.com>\n");
 #endif
 
 #ifdef CONFIG_ALMA_ANS
-	printk("Alma Electronics board support (C) 1999 Vladimir Gurevich <vgurevic@cisco.com>\n");
+	printk(KERN_INFO "Alma Electronics board support (C) 1999 Vladimir Gurevich <vgurevic@cisco.com>\n");
 #endif
 #if defined (CONFIG_M68360)
-	printk("QUICC port done by SED Systems <hamilton@sedsystems.ca>,\n");
-	printk("based on 2.0.38 port by Lineo Inc. <mleslie@lineo.com>.\n");
+	printk(KERN_INFO "QUICC port done by SED Systems <hamilton@sedsystems.ca>,\n");
+	printk(KERN_INFO "based on 2.0.38 port by Lineo Inc. <mleslie@lineo.com>.\n");
 #endif
 #ifdef CONFIG_DRAGEN2
-	printk("DragonEngine II board support by Georges Menie\n");
+	printk(KERN_INFO "DragonEngine II board support by Georges Menie\n");
 #endif
 
 #ifdef DEBUG
-	printk("KERNEL -> TEXT=0x%06x-0x%06x DATA=0x%06x-0x%06x "
+	printk(KERN_DEBUG "KERNEL -> TEXT=0x%06x-0x%06x DATA=0x%06x-0x%06x "
 		"BSS=0x%06x-0x%06x\n", (int) &_stext, (int) &_etext,
 		(int) &_sdata, (int) &_edata,
 		(int) &_sbss, (int) &_ebss);
-	printk("KERNEL -> ROMFS=0x%06x-0x%06x MEM=0x%06x-0x%06x "
+	printk(KERN_DEBUG "KERNEL -> ROMFS=0x%06x-0x%06x MEM=0x%06x-0x%06x "
 		"STACK=0x%06x-0x%06x\n",
 #ifdef CAT_ROMARRAY
 		(int) romarray, ((int) romarray) + romarray[2],
@@ -231,7 +228,7 @@
 
 #ifdef DEBUG
 	if (strlen(*cmdline_p)) 
-		printk("Command line: '%s'\n", *cmdline_p);
+		printk(KERN_DEBUG "Command line: '%s'\n", *cmdline_p);
 #endif
 
 #ifdef CONFIG_CONSOLE
diff -Naur linux-2.6.0-test8/arch/m68knommu/kernel/signal.c linux-2.6.0-test8-uc0/arch/m68knommu/kernel/signal.c
--- linux-2.6.0-test8/arch/m68knommu/kernel/signal.c	2003-10-20 09:10:57.800647176 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/kernel/signal.c	2003-10-20 09:11:54.110086840 +1000
@@ -605,7 +605,7 @@
 		struct pt_regs *tregs =
 			(struct pt_regs *)((ulong)regs + regs->stkadj);
 #if DEBUG
-		printk("Performing stackadjust=%04x\n", regs->stkadj);
+		printk(KERN_DEBUG "Performing stackadjust=%04x\n", regs->stkadj);
 #endif
 		/* This must be copied with decreasing addresses to
                    handle overlaps.  */
@@ -674,7 +674,7 @@
 		struct pt_regs *tregs =
 			(struct pt_regs *)((ulong)regs + regs->stkadj);
 #if DEBUG
-		printk("Performing stackadjust=%04x\n", regs->stkadj);
+		printk(KERN_DEBUG "Performing stackadjust=%04x\n", regs->stkadj);
 #endif
 		/* This must be copied with decreasing addresses to
                    handle overlaps.  */
diff -Naur linux-2.6.0-test8/arch/m68knommu/kernel/time.c linux-2.6.0-test8-uc0/arch/m68knommu/kernel/time.c
--- linux-2.6.0-test8/arch/m68knommu/kernel/time.c	2003-10-20 09:10:57.814645048 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/kernel/time.c	2003-10-20 09:11:54.133083344 +1000
@@ -202,4 +202,12 @@
 	return 0;
 }
 
+/*
+ * Scheduler clock - returns current time in nanosec units.
+ */
+unsigned long long sched_clock(void)
+{
+	return (unsigned long long)jiffies * (1000000000 / HZ);
+}
+
 EXPORT_SYMBOL(do_settimeofday);
diff -Naur linux-2.6.0-test8/arch/m68knommu/kernel/traps.c linux-2.6.0-test8-uc0/arch/m68knommu/kernel/traps.c
--- linux-2.6.0-test8/arch/m68knommu/kernel/traps.c	2003-10-20 09:10:57.722659032 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/kernel/traps.c	2003-10-20 09:11:54.134083192 +1000
@@ -72,15 +72,15 @@
 		return;
 
 	console_verbose();
-	printk("%s: %08x\n",str,nr);
-	printk("PC: [<%08lx>]\nSR: %04x  SP: %p  a2: %08lx\n",
+	printk(KERN_EMERG "%s: %08x\n",str,nr);
+	printk(KERN_EMERG "PC: [<%08lx>]\nSR: %04x  SP: %p  a2: %08lx\n",
 	       fp->pc, fp->sr, fp, fp->a2);
-	printk("d0: %08lx    d1: %08lx    d2: %08lx    d3: %08lx\n",
+	printk(KERN_EMERG "d0: %08lx    d1: %08lx    d2: %08lx    d3: %08lx\n",
 	       fp->d0, fp->d1, fp->d2, fp->d3);
-	printk("d4: %08lx    d5: %08lx    a0: %08lx    a1: %08lx\n",
+	printk(KERN_EMERG "d4: %08lx    d5: %08lx    a0: %08lx    a1: %08lx\n",
 	       fp->d4, fp->d5, fp->a0, fp->a1);
 
-	printk("Process %s (pid: %d, stackpage=%08lx)\n",
+	printk(KERN_EMERG "Process %s (pid: %d, stackpage=%08lx)\n",
 		current->comm, current->pid, PAGE_SIZE+(unsigned long)current);
 	show_stack(NULL, (unsigned long *)fp);
 	do_exit(SIGSEGV);
@@ -93,12 +93,12 @@
 		current->thread.esp0 = (unsigned long) fp;
 
 #if DEBUG
-	printk ("*** Bus Error *** Format is %x\n", fp->ptregs.format);
+	printk (KERN_DEBUG "*** Bus Error *** Format is %x\n", fp->ptregs.format);
 #endif
 
 	die_if_kernel("bad frame format",&fp->ptregs,0);
 #if DEBUG
-	printk("Unknown SIGSEGV - 4\n");
+	printk(KERN_DEBUG "Unknown SIGSEGV - 4\n");
 #endif
 	force_sig(SIGSEGV, current);
 }
@@ -119,16 +119,16 @@
 	addr = (unsigned long) esp;
 	endstack = (unsigned long *) PAGE_ALIGN(addr);
 
-	printk("Stack from %08lx:", (unsigned long)stack);
+	printk(KERN_EMERG "Stack from %08lx:", (unsigned long)stack);
 	for (i = 0; i < kstack_depth_to_print; i++) {
 		if (stack + 1 > endstack)
 			break;
 		if (i % 8 == 0)
-			printk("\n       ");
-		printk(" %08lx", *stack++);
+			printk(KERN_EMERG "\n       ");
+		printk(KERN_EMERG " %08lx", *stack++);
 	}
 
-	printk("\nCall Trace:");
+	printk(KERN_EMERG "\nCall Trace:");
 	i = 0;
 	while (stack + 1 <= endstack) {
 		addr = *stack++;
@@ -143,26 +143,26 @@
 		if (((addr >= (unsigned long) &_start) &&
 		     (addr <= (unsigned long) &_etext))) {
 			if (i % 4 == 0)
-				printk("\n       ");
-			printk(" [<%08lx>]", addr);
+				printk(KERN_EMERG "\n       ");
+			printk(KERN_EMERG " [<%08lx>]", addr);
 			i++;
 		}
 	}
-	printk("\n");
+	printk(KERN_EMERG "\n");
 }
 
 void bad_super_trap(struct frame *fp)
 {
 	console_verbose();
 	if (fp->ptregs.vector < 4*sizeof(vec_names)/sizeof(vec_names[0]))
-		printk ("*** %s ***   FORMAT=%X\n",
+		printk (KERN_WARNING "*** %s ***   FORMAT=%X\n",
 			vec_names[(fp->ptregs.vector) >> 2],
 			fp->ptregs.format);
 	else
-		printk ("*** Exception %d ***   FORMAT=%X\n",
+		printk (KERN_WARNING "*** Exception %d ***   FORMAT=%X\n",
 			(fp->ptregs.vector) >> 2, 
 			fp->ptregs.format);
-	printk ("Current process id is %d\n", current->pid);
+	printk (KERN_WARNING "Current process id is %d\n", current->pid);
 	die_if_kernel("BAD KERNEL TRAP", &fp->ptregs, 0);
 }
 
@@ -297,7 +297,7 @@
 
 void show_trace_task(struct task_struct *tsk)
 {
-	printk("STACK ksp=0x%lx, usp=0x%lx\n", tsk->thread.ksp, tsk->thread.usp);
+	printk(KERN_WARNING "STACK ksp=0x%lx, usp=0x%lx\n", tsk->thread.ksp, tsk->thread.usp);
 }
 
 #ifdef CONFIG_M68KFPU_EMU
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/checksum.c linux-2.6.0-test8-uc0/arch/m68knommu/lib/checksum.c
--- linux-2.6.0-test8/arch/m68knommu/lib/checksum.c	2003-10-20 09:10:57.817644592 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/checksum.c	2003-10-20 09:11:53.749141712 +1000
@@ -32,7 +32,6 @@
    of the assembly has to go. */
 
 #include <net/checksum.h>
-#include <net/module.h>
 
 static inline unsigned short from32to16(unsigned long x)
 {
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/cmpdi2.c linux-2.6.0-test8-uc0/arch/m68knommu/lib/cmpdi2.c
--- linux-2.6.0-test8/arch/m68knommu/lib/cmpdi2.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/cmpdi2.c	2003-10-20 09:11:53.758140344 +1000
@@ -0,0 +1,71 @@
+/* cmpdi2.c extracted from gcc-2.95.3/libgcc2.c which is:  */
+/* Copyright (C) 1989, 92-98, 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+
+typedef int word_type __attribute__ ((mode (__word__)));
+
+struct DIstruct {SItype high, low;};
+
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+word_type
+__cmpdi2 (DItype a, DItype b)
+{
+  DIunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if (au.s.high < bu.s.high)
+    return 0;
+  else if (au.s.high > bu.s.high)
+    return 2;
+  if ((USItype) au.s.low < (USItype) bu.s.low)
+    return 0;
+  else if ((USItype) au.s.low > (USItype) bu.s.low)
+    return 2;
+  return 1;
+}
+
+
+word_type
+__ucmpdi2 (DItype a, DItype b)
+{
+  DIunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if ((USItype) au.s.high < (USItype) bu.s.high)
+    return 0;
+  else if ((USItype) au.s.high > (USItype) bu.s.high)
+    return 2;
+  if ((USItype) au.s.low < (USItype) bu.s.low)
+    return 0;
+  else if ((USItype) au.s.low > (USItype) bu.s.low)
+    return 2;
+  return 1;
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/divdi3.c linux-2.6.0-test8-uc0/arch/m68knommu/lib/divdi3.c
--- linux-2.6.0-test8/arch/m68knommu/lib/divdi3.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/divdi3.c	2003-10-20 09:11:53.773138064 +1000
@@ -0,0 +1,66 @@
+/* divdi3.c extracted from gcc-2.95.3/libgcc2.c which is:  */
+/* Copyright (C) 1989, 92-98, 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+
+typedef int word_type __attribute__ ((mode (__word__)));
+
+struct DIstruct {SItype high, low;};
+
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+UDItype __udivmoddi4 (UDItype n, UDItype d, UDItype *rp);
+DItype __negdi2 (DItype u);
+
+DItype
+__divdi3 (DItype u, DItype v)
+{
+  word_type c = 0;
+  DIunion uu, vv;
+  DItype w;
+
+  uu.ll = u;
+  vv.ll = v;
+
+  if (uu.s.high < 0)
+    c = ~c,
+    uu.ll = __negdi2 (uu.ll);
+  if (vv.s.high < 0)
+    c = ~c,
+    vv.ll = __negdi2 (vv.ll);
+
+  w = __udivmoddi4 (uu.ll, vv.ll, (UDItype *) 0);
+  if (c)
+    w = __negdi2 (w);
+
+  return w;
+}
+
+UDItype
+__udivdi3 (UDItype n, UDItype d)
+{
+  return __udivmoddi4 (n, d, (UDItype *) 0);
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/divsi3.S linux-2.6.0-test8-uc0/arch/m68knommu/lib/divsi3.S
--- linux-2.6.0-test8/arch/m68knommu/lib/divsi3.S	2003-10-20 09:10:57.818644440 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/divsi3.S	2003-10-20 09:11:53.781136848 +1000
@@ -97,7 +97,7 @@
 	movel	sp@(12), d1	/* d1 = divisor */
 	jpl	L1
 	negl	d1
-#ifndef __mcf5200__
+#if !(defined(__mcf5200__) || defined(__mcoldfire__))
 	negb	d2		/* change sign because divisor <0  */
 #else
 	negl	d2		/* change sign because divisor <0  */
@@ -105,7 +105,7 @@
 L1:	movel	sp@(8), d0	/* d0 = dividend */
 	jpl	L2
 	negl	d0
-#ifndef __mcf5200__
+#if !(defined(__mcf5200__) || defined(__mcoldfire__))
 	negb	d2
 #else
 	negl	d2
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/gcc_bcmp.c linux-2.6.0-test8-uc0/arch/m68knommu/lib/gcc_bcmp.c
--- linux-2.6.0-test8/arch/m68knommu/lib/gcc_bcmp.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/gcc_bcmp.c	2003-10-20 09:11:53.781136848 +1000
@@ -0,0 +1,38 @@
+/* gcc_bmp.c extracted from gcc-2.95.3/libgcc2.c which is:  */
+/* Copyright (C) 1989, 92-98, 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include <linux/types.h>
+
+/* Like bcmp except the sign is meaningful.
+   Result is negative if S1 is less than S2,
+   positive if S1 is greater, 0 if S1 and S2 are equal.  */
+
+int
+__gcc_bcmp (unsigned char *s1, unsigned char *s2, size_t size)
+{
+  while (size > 0)
+    {
+      unsigned char c1 = *s1++, c2 = *s2++;
+      if (c1 != c2)
+	return c1 - c2;
+      size--;
+    }
+  return 0;
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/Makefile linux-2.6.0-test8-uc0/arch/m68knommu/lib/Makefile
--- linux-2.6.0-test8/arch/m68knommu/lib/Makefile	2003-10-20 09:10:57.816644744 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/Makefile	2003-10-20 09:11:53.730144600 +1000
@@ -4,4 +4,5 @@
 
 lib-y	:= ashldi3.o ashrdi3.o lshrdi3.o \
 	   muldi3.o mulsi3.o divsi3.o udivsi3.o modsi3.o umodsi3.o \
-	   checksum.o semaphore.o memcpy.o memset.o
+	   checksum.o semaphore.o memcpy.o memset.o \
+	   cmpdi2.o divdi3.o negdi2.o moddi3.o udivmoddi4.o gcc_bcmp.o
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/moddi3.c linux-2.6.0-test8-uc0/arch/m68knommu/lib/moddi3.c
--- linux-2.6.0-test8/arch/m68knommu/lib/moddi3.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/moddi3.c	2003-10-20 09:11:53.782136696 +1000
@@ -0,0 +1,69 @@
+/* moddi3.c extracted from gcc-2.95.3/libgcc2.c which is:  */
+/* Copyright (C) 1989, 92-98, 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+
+typedef int word_type __attribute__ ((mode (__word__)));
+
+struct DIstruct {SItype high, low;};
+
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+UDItype __udivmoddi4 (UDItype n, UDItype d, UDItype *rp);
+DItype __negdi2 (DItype u);
+
+DItype
+__moddi3 (DItype u, DItype v)
+{
+  word_type c = 0;
+  DIunion uu, vv;
+  DItype w;
+
+  uu.ll = u;
+  vv.ll = v;
+
+  if (uu.s.high < 0)
+    c = ~c,
+    uu.ll = __negdi2 (uu.ll);
+  if (vv.s.high < 0)
+    vv.ll = __negdi2 (vv.ll);
+
+  (void) __udivmoddi4 (uu.ll, vv.ll, &w);
+  if (c)
+    w = __negdi2 (w);
+
+  return w;
+}
+
+UDItype
+__umoddi3 (UDItype u, UDItype v)
+{
+  UDItype w;
+
+  (void) __udivmoddi4 (u, v, &w);
+
+  return w;
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/modsi3.S linux-2.6.0-test8-uc0/arch/m68knommu/lib/modsi3.S
--- linux-2.6.0-test8/arch/m68knommu/lib/modsi3.S	2003-10-20 09:10:57.815644896 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/modsi3.S	2003-10-20 09:11:53.782136696 +1000
@@ -98,7 +98,7 @@
 	jbsr	SYM (__divsi3)
 	addql	IMM (8), sp
 	movel	sp@(8), d1	/* d1 = divisor */
-#ifndef __mcf5200__
+#if !(defined(__mcf5200__) || defined(__mcoldfire__))
 	movel	d1, sp@-
 	movel	d0, sp@-
 	jbsr	SYM (__mulsi3)	/* d0 = (a/b)*b */
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/mulsi3.S linux-2.6.0-test8-uc0/arch/m68knommu/lib/mulsi3.S
--- linux-2.6.0-test8/arch/m68knommu/lib/mulsi3.S	2003-10-20 09:10:57.865637296 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/mulsi3.S	2003-10-20 09:11:53.783136544 +1000
@@ -95,7 +95,7 @@
 	muluw	sp@(10), d0	/* x0*y1 */
 	movew	sp@(6), d1	/* x1 -> d1 */
 	muluw	sp@(8), d1	/* x1*y0 */
-#ifndef __mcf5200__
+#if !(defined(__mcf5200__) || defined(__mcoldfire__))
 	addw	d1, d0
 #else
 	addl	d1, d0
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/negdi2.c linux-2.6.0-test8-uc0/arch/m68knommu/lib/negdi2.c
--- linux-2.6.0-test8/arch/m68knommu/lib/negdi2.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/negdi2.c	2003-10-20 09:11:53.783136544 +1000
@@ -0,0 +1,47 @@
+/* negdi2.c extracted from gcc-2.95.3/libgcc2.c which is:  */
+/* Copyright (C) 1989, 92-98, 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+
+typedef int word_type __attribute__ ((mode (__word__)));
+
+struct DIstruct {SItype high, low;};
+
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+DItype
+__negdi2 (DItype u)
+{
+  DIunion w;
+  DIunion uu;
+
+  uu.ll = u;
+
+  w.s.low = -uu.s.low;
+  w.s.high = -uu.s.high - ((USItype) w.s.low > 0);
+
+  return w.ll;
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/udivmoddi4.c linux-2.6.0-test8-uc0/arch/m68knommu/lib/udivmoddi4.c
--- linux-2.6.0-test8/arch/m68knommu/lib/udivmoddi4.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/udivmoddi4.c	2003-10-20 09:11:53.784136392 +1000
@@ -0,0 +1,413 @@
+/* udivmoddi4.c extracted from gcc-2.95.3/libgcc2.c 
+ * and gcc-2.95.3/longlong.h which are:  */
+/* Copyright (C) 1989, 92-98, 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#define BITS_PER_UNIT 8
+
+typedef unsigned int UQItype	__attribute__ ((mode (QI)));
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+
+#define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)
+
+struct DIstruct {SItype high, low;};
+
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub%.l %5,%1
+    subx%.l %3,%0"                          \
+       : "=d" ((USItype) (sh)),                 \
+         "=&d" ((USItype) (sl))                 \
+       : "0" ((USItype) (ah)),                  \
+         "d" ((USItype) (bh)),                  \
+         "1" ((USItype) (al)),                  \
+         "g" ((USItype) (bl)))
+
+#if !defined(__mcf5200__)
+/* %/ inserts REGISTER_PREFIX, %# inserts IMMEDIATE_PREFIX.  */
+#define umul_ppmm(xh, xl, a, b) \
+  __asm__ ("| Inlined umul_ppmm
+    move%.l %2,%/d0
+    move%.l %3,%/d1
+    move%.l %/d0,%/d2
+    swap    %/d0
+    move%.l %/d1,%/d3
+    swap    %/d1
+    move%.w %/d2,%/d4
+    mulu    %/d3,%/d4
+    mulu    %/d1,%/d2
+    mulu    %/d0,%/d3
+    mulu    %/d0,%/d1
+    move%.l %/d4,%/d0
+    eor%.w  %/d0,%/d0
+    swap    %/d0
+    add%.l  %/d0,%/d2
+    add%.l  %/d3,%/d2
+    jcc 1f
+    add%.l  %#65536,%/d1
+1:  swap    %/d2
+    moveq   %#0,%/d0
+    move%.w %/d2,%/d0
+    move%.w %/d4,%/d2
+    move%.l %/d2,%1
+    add%.l  %/d1,%/d0
+    move%.l %/d0,%0"                        \
+       : "=g" ((USItype) (xh)),                 \
+         "=g" ((USItype) (xl))                  \
+       : "g" ((USItype) (a)),                   \
+         "g" ((USItype) (b))                    \
+       : "d0", "d1", "d2", "d3", "d4")
+#define UMUL_TIME 100
+#define UDIV_TIME 400
+#endif /* not mcf5200 */
+
+#if !defined (udiv_qrnnd)
+#define UDIV_NEEDS_NORMALIZATION 1
+#define udiv_qrnnd __udiv_qrnnd_c
+#endif
+
+#define __BITS4 (SI_TYPE_SIZE / 4)
+#define __ll_B (1L << (SI_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((USItype) (t) % __ll_B)
+#define __ll_highpart(t) ((USItype) (t) / __ll_B)
+
+#if !defined (count_leading_zeros)
+extern const UQItype __clz_tab[];
+#define count_leading_zeros(count, x) \
+  do {                                  \
+    USItype __xr = (x);                         \
+    USItype __a;                            \
+                                    \
+    if (SI_TYPE_SIZE <= 32)                     \
+      {                                 \
+    __a = __xr < ((USItype)1<<2*__BITS4)                \
+      ? (__xr < ((USItype)1<<__BITS4) ? 0 : __BITS4)        \
+      : (__xr < ((USItype)1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);  \
+      }                                 \
+    else                                \
+      {                                 \
+    for (__a = SI_TYPE_SIZE - 8; __a > 0; __a -= 8)         \
+      if (((__xr >> __a) & 0xff) != 0)              \
+        break;                          \
+      }                                 \
+                                    \
+    (count) = SI_TYPE_SIZE - (__clz_tab[__xr >> __a] + __a);        \
+  } while (0)
+#endif
+
+#define __udiv_qrnnd_c(q, r, n1, n0, d) \
+  do {                                  \
+    USItype __d1, __d0, __q1, __q0;                 \
+    USItype __r1, __r0, __m;                        \
+    __d1 = __ll_highpart (d);                       \
+    __d0 = __ll_lowpart (d);                        \
+                                    \
+    __r1 = (n1) % __d1;                         \
+    __q1 = (n1) / __d1;                         \
+    __m = (USItype) __q1 * __d0;                    \
+    __r1 = __r1 * __ll_B | __ll_highpart (n0);              \
+    if (__r1 < __m)                         \
+      {                                 \
+    __q1--, __r1 += (d);                        \
+    if (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\
+      if (__r1 < __m)                       \
+        __q1--, __r1 += (d);                    \
+      }                                 \
+    __r1 -= __m;                            \
+                                    \
+    __r0 = __r1 % __d1;                         \
+    __q0 = __r1 / __d1;                         \
+    __m = (USItype) __q0 * __d0;                    \
+    __r0 = __r0 * __ll_B | __ll_lowpart (n0);               \
+    if (__r0 < __m)                         \
+      {                                 \
+    __q0--, __r0 += (d);                        \
+    if (__r0 >= (d))                        \
+      if (__r0 < __m)                       \
+        __q0--, __r0 += (d);                    \
+      }                                 \
+    __r0 -= __m;                            \
+                                    \
+    (q) = (USItype) __q1 * __ll_B | __q0;               \
+    (r) = __r0;                             \
+  } while (0)
+
+#if !defined (umul_ppmm)
+#define umul_ppmm(w1, w0, u, v)                     \
+  do {                                  \
+    USItype __x0, __x1, __x2, __x3;                 \
+    USItype __ul, __vl, __uh, __vh;                 \
+                                    \
+    __ul = __ll_lowpart (u);                        \
+    __uh = __ll_highpart (u);                       \
+    __vl = __ll_lowpart (v);                        \
+    __vh = __ll_highpart (v);                       \
+                                    \
+    __x0 = (USItype) __ul * __vl;                   \
+    __x1 = (USItype) __ul * __vh;                   \
+    __x2 = (USItype) __uh * __vl;                   \
+    __x3 = (USItype) __uh * __vh;                   \
+                                    \
+    __x1 += __ll_highpart (__x0);/* this can't give carry */        \
+    __x1 += __x2;       /* but this indeed can */       \
+    if (__x1 < __x2)        /* did we get it? */            \
+      __x3 += __ll_B;       /* yes, add it in the proper pos. */    \
+                                    \
+    (w1) = __x3 + __ll_highpart (__x1);                 \
+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);      \
+  } while (0)
+#endif
+
+
+static const UQItype __clz_tab[] =
+{
+  0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+};
+
+UDItype
+__udivmoddi4 (UDItype n, UDItype d, UDItype *rp)
+{
+  DIunion ww;
+  DIunion nn, dd;
+  DIunion rr;
+  USItype d0, d1, n0, n1, n2;
+  USItype q0, q1;
+  USItype b, bm;
+
+  nn.ll = n;
+  dd.ll = d;
+
+  d0 = dd.s.low;
+  d1 = dd.s.high;
+  n0 = nn.s.low;
+  n1 = nn.s.high;
+
+#if !UDIV_NEEDS_NORMALIZATION
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
+
+	  udiv_qrnnd (q1, n1, 0, n1, d0);
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+
+#else /* UDIV_NEEDS_NORMALIZATION */
+
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  count_leading_zeros (bm, d0);
+
+	  if (bm != 0)
+	    {
+	      /* Normalize, i.e. make the most significant bit of the
+		 denominator set.  */
+
+	      d0 = d0 << bm;
+	      n1 = (n1 << bm) | (n0 >> (SI_TYPE_SIZE - bm));
+	      n0 = n0 << bm;
+	    }
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0 >> bm.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
+
+	  count_leading_zeros (bm, d0);
+
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d0) /\ (the most significant bit of d0 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 leading quotient digit q1 = 1).
+
+		 This special case is necessary, not an optimization.
+		 (Shifts counts of SI_TYPE_SIZE are undefined.)  */
+
+	      n1 -= d0;
+	      q1 = 1;
+	    }
+	  else
+	    {
+	      /* Normalize.  */
+
+	      b = SI_TYPE_SIZE - bm;
+
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q1, n1, n2, n1, d0);
+	    }
+
+	  /* n1 != d0...  */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0 >> bm.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0 >> bm;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+#endif /* UDIV_NEEDS_NORMALIZATION */
+
+  else
+    {
+      if (d1 > n1)
+	{
+	  /* 00 = nn / DD */
+
+	  q0 = 0;
+	  q1 = 0;
+
+	  /* Remainder in n1n0.  */
+	  if (rp != 0)
+	    {
+	      rr.s.low = n0;
+	      rr.s.high = n1;
+	      *rp = rr.ll;
+	    }
+	}
+      else
+	{
+	  /* 0q = NN / dd */
+
+	  count_leading_zeros (bm, d1);
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d1) /\ (the most significant bit of d1 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 quotient digit q0 = 0 or 1).
+
+		 This special case is necessary, not an optimization.  */
+
+	      /* The condition on the next line takes advantage of that
+		 n1 >= d1 (true due to program flow).  */
+	      if (n1 > d1 || n0 >= d0)
+		{
+		  q0 = 1;
+		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
+		}
+	      else
+		q0 = 0;
+
+	      q1 = 0;
+
+	      if (rp != 0)
+		{
+		  rr.s.low = n0;
+		  rr.s.high = n1;
+		  *rp = rr.ll;
+		}
+	    }
+	  else
+	    {
+	      USItype m1, m0;
+	      /* Normalize.  */
+
+	      b = SI_TYPE_SIZE - bm;
+
+	      d1 = (d1 << bm) | (d0 >> b);
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q0, n1, n2, n1, d1);
+	      umul_ppmm (m1, m0, q0, d0);
+
+	      if (m1 > n1 || (m1 == n1 && m0 > n0))
+		{
+		  q0--;
+		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
+		}
+
+	      q1 = 0;
+
+	      /* Remainder in (n1n0 - m1m0) >> bm.  */
+	      if (rp != 0)
+		{
+		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
+		  rr.s.low = (n1 << b) | (n0 >> bm);
+		  rr.s.high = n1 >> bm;
+		  *rp = rr.ll;
+		}
+	    }
+	}
+    }
+
+  ww.s.low = q0;
+  ww.s.high = q1;
+  return ww.ll;
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/udivsi3.S linux-2.6.0-test8-uc0/arch/m68knommu/lib/udivsi3.S
--- linux-2.6.0-test8/arch/m68knommu/lib/udivsi3.S	2003-10-20 09:10:57.864637448 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/udivsi3.S	2003-10-20 09:11:53.784136392 +1000
@@ -91,7 +91,7 @@
 	.proc
 	.globl	SYM (__udivsi3)
 SYM (__udivsi3):
-#ifndef __mcf5200__
+#if !(defined(__mcf5200__) || defined(__mcoldfire__))
 	movel	d2, sp@-
 	movel	sp@(12), d1	/* d1 = divisor */
 	movel	sp@(8), d0	/* d0 = dividend */
@@ -136,7 +136,7 @@
 L6:	movel	sp@+, d2
 	rts
 
-#else /* __mcf5200__ */
+#else /* __mcf5200__ || __mcoldfire__ */
 
 /* Coldfire implementation of non-restoring division algorithm from
    Hennessy & Patterson, Appendix A. */
@@ -158,5 +158,5 @@
 	moveml	sp@,d2-d4	| restore data registers
 	unlk	a6		| and return
 	rts
-#endif /* __mcf5200__ */
+#endif /* __mcf5200__ || __mcoldfire__ */
 
diff -Naur linux-2.6.0-test8/arch/m68knommu/lib/umodsi3.S linux-2.6.0-test8-uc0/arch/m68knommu/lib/umodsi3.S
--- linux-2.6.0-test8/arch/m68knommu/lib/umodsi3.S	2003-10-20 09:10:57.831642464 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/lib/umodsi3.S	2003-10-20 09:11:53.784136392 +1000
@@ -98,7 +98,7 @@
 	jbsr	SYM (__udivsi3)
 	addql	IMM (8), sp
 	movel	sp@(8), d1	/* d1 = divisor */
-#ifndef __mcf5200__
+#if !(defined(__mcf5200__) || defined(__mcoldfire__))
 	movel	d1, sp@-
 	movel	d0, sp@-
 	jbsr	SYM (__mulsi3)	/* d0 = (a/b)*b */
diff -Naur linux-2.6.0-test8/arch/m68knommu/Makefile linux-2.6.0-test8-uc0/arch/m68knommu/Makefile
--- linux-2.6.0-test8/arch/m68knommu/Makefile	2003-10-20 09:10:57.875635776 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/Makefile	2003-10-20 09:11:53.690150680 +1000
@@ -81,7 +81,7 @@
 
 CFLAGS += $(cflags-y)
 CFLAGS += -fno-builtin
-CFLAGS += -O2 -g
+CFLAGS += -Os -g
 CFLAGS += -D__linux__
 CFLAGS += -DUTS_SYSNAME=\"uClinux\"
 
diff -Naur linux-2.6.0-test8/arch/m68knommu/mm/fault.c linux-2.6.0-test8-uc0/arch/m68knommu/mm/fault.c
--- linux-2.6.0-test8/arch/m68knommu/mm/fault.c	2003-10-20 09:10:57.866637144 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/mm/fault.c	2003-10-20 09:11:55.292907024 +1000
@@ -36,7 +36,7 @@
 			      unsigned long error_code)
 {
 #ifdef DEBUG
-	printk ("regs->sr=%#x, regs->pc=%#lx, address=%#lx, %ld\n",
+	printk (KERN_DEBUG "regs->sr=%#x, regs->pc=%#lx, address=%#lx, %ld\n",
 		regs->sr, regs->pc, address, error_code);
 #endif
 
@@ -48,7 +48,7 @@
 		printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference");
 	} else
 		printk(KERN_ALERT "Unable to handle kernel access");
-	printk(" at virtual address %08lx\n",address);
+	printk(KERN_ALERT " at virtual address %08lx\n",address);
 	die_if_kernel("Oops", regs, error_code);
 	do_exit(SIGKILL);
 
diff -Naur linux-2.6.0-test8/arch/m68knommu/mm/init.c linux-2.6.0-test8-uc0/arch/m68knommu/mm/init.c
--- linux-2.6.0-test8/arch/m68knommu/mm/init.c	2003-10-20 09:10:57.874635928 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/mm/init.c	2003-10-20 09:11:55.292907024 +1000
@@ -72,7 +72,7 @@
     int free = 0, total = 0, reserved = 0, shared = 0;
     int cached = 0;
 
-    printk("\nMem-info:\n");
+    printk(KERN_INFO "\nMem-info:\n");
     show_free_areas();
     i = max_mapnr;
     while (i-- > 0) {
@@ -86,11 +86,11 @@
 	else
 	    shared += page_count(mem_map+i) - 1;
     }
-    printk("%d pages of RAM\n",total);
-    printk("%d free pages\n",free);
-    printk("%d reserved pages\n",reserved);
-    printk("%d pages shared\n",shared);
-    printk("%d pages swap cached\n",cached);
+    printk(KERN_INFO "%d pages of RAM\n",total);
+    printk(KERN_INFO "%d free pages\n",free);
+    printk(KERN_INFO "%d reserved pages\n",reserved);
+    printk(KERN_INFO "%d pages shared\n",shared);
+    printk(KERN_INFO "%d pages swap cached\n",cached);
 }
 
 extern unsigned long memory_start;
@@ -114,7 +114,7 @@
 	unsigned long end_mem   = memory_end & PAGE_MASK;
 
 #ifdef DEBUG
-	printk ("start_mem is %#lx\nvirtual_end is %#lx\n",
+	printk (KERN_DEBUG "start_mem is %#lx\nvirtual_end is %#lx\n",
 		start_mem, end_mem);
 #endif
 
@@ -133,9 +133,9 @@
 	set_fs (USER_DS);
 
 #ifdef DEBUG
-	printk ("before free_area_init\n");
+	printk (KERN_DEBUG "before free_area_init\n");
 
-	printk ("free_area_init -> start_mem is %#lx\nvirtual_end is %#lx\n",
+	printk (KERN_DEBUG "free_area_init -> start_mem is %#lx\nvirtual_end is %#lx\n",
 		start_mem, end_mem);
 #endif
 
@@ -162,7 +162,7 @@
 	unsigned long end_mem   = memory_end; /* DAVIDM - this must not include kernel stack at top */
 
 #ifdef DEBUG
-	printk("Mem_init: start=%lx, end=%lx\n", start_mem, end_mem);
+	printk(KERN_DEBUG "Mem_init: start=%lx, end=%lx\n", start_mem, end_mem);
 #endif
 
 	end_mem &= PAGE_MASK;
@@ -179,7 +179,7 @@
 	initk = (&__init_begin - &__init_end) >> 10;
 
 	tmp = nr_free_pages() << PAGE_SHIFT;
-	printk("Memory available: %luk/%luk RAM, %luk/%luk ROM (%dk kernel code, %dk data)\n",
+	printk(KERN_INFO "Memory available: %luk/%luk RAM, %luk/%luk ROM (%dk kernel code, %dk data)\n",
 	       tmp >> 10,
 	       len >> 10,
 	       (rom_length > 0) ? ((rom_length >> 10) - codek) : 0,
@@ -201,7 +201,7 @@
 		totalram_pages++;
 		pages++;
 	}
-	printk ("Freeing initrd memory: %dk freed\n", pages);
+	printk (KERN_NOTICE "Freeing initrd memory: %dk freed\n", pages);
 }
 #endif
 
@@ -223,7 +223,7 @@
 		free_page(addr);
 		totalram_pages++;
 	}
-	printk("Freeing unused kernel memory: %ldk freed (0x%x - 0x%x)\n",
+	printk(KERN_NOTICE "Freeing unused kernel memory: %ldk freed (0x%x - 0x%x)\n",
 			(addr - PAGE_ALIGN((long) &__init_begin)) >> 10,
 			(int)(PAGE_ALIGN((unsigned long)(&__init_begin))),
 			(int)(addr - PAGE_SIZE));
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5206/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5206/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5206/config.c	2003-10-20 09:10:57.718659640 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5206/config.c	2003-10-20 09:11:55.607859144 +1000
@@ -42,6 +42,8 @@
         MCF_MBAR + MCFDMA_BASE1,
 };
 
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
 /***************************************************************************/
 
 void mcf_autovector(unsigned int vec)
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5206e/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5206e/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5206e/config.c	2003-10-20 09:10:57.716659944 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5206e/config.c	2003-10-20 09:11:55.632855344 +1000
@@ -42,6 +42,8 @@
         MCF_MBAR + MCFDMA_BASE1,
 };
 
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
 /***************************************************************************/
 
 void mcf_autovector(unsigned int vec)
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5249/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5249/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5249/config.c	2003-10-20 09:10:57.717659792 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5249/config.c	2003-10-20 09:11:55.616857776 +1000
@@ -43,6 +43,8 @@
         MCF_MBAR + MCFDMA_BASE3,
 };
 
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
 /***************************************************************************/
 
 void mcf_autovector(unsigned int vec)
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5272/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5272/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5272/config.c	2003-10-20 09:10:57.715660096 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5272/config.c	2003-10-20 09:11:55.691846376 +1000
@@ -46,6 +46,8 @@
         MCF_MBAR + MCFDMA_BASE0,
 };
 
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
 /***************************************************************************/
 
 void mcf_disableall(void)
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5282/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5282/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5282/config.c	2003-10-20 09:10:57.664667848 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5282/config.c	2003-10-20 09:11:55.787831784 +1000
@@ -17,6 +17,7 @@
 #include <linux/sched.h>
 #include <linux/param.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <asm/dma.h>
 #include <asm/traps.h>
 #include <asm/machdep.h>
@@ -27,7 +28,7 @@
 /***************************************************************************/
 
 void coldfire_pit_tick(void);
-void coldfire_pit_init(void (*handler)(int, void *, struct pt_regs *));
+void coldfire_pit_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
 unsigned long coldfire_pit_offset(void);
 void coldfire_trap_init(void);
 void coldfire_reset(void);
@@ -41,6 +42,8 @@
         MCF_MBAR + MCFDMA_BASE0,
 };
 
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
 /***************************************************************************/
 
 void mcf_disableall(void)
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5307/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5307/config.c	2003-10-20 09:10:57.694663288 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/config.c	2003-10-20 09:11:55.814827680 +1000
@@ -14,6 +14,7 @@
 #include <linux/sched.h>
 #include <linux/param.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <asm/irq.h>
 #include <asm/dma.h>
 #include <asm/traps.h>
@@ -28,7 +29,7 @@
 /***************************************************************************/
 
 void coldfire_tick(void);
-void coldfire_timer_init(void (*handler)(int, void *, struct pt_regs *));
+void coldfire_timer_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
 unsigned long coldfire_timer_offset(void);
 void coldfire_trap_init(void);
 void coldfire_reset(void);
@@ -49,6 +50,8 @@
         MCF_MBAR + MCFDMA_BASE3,
 };
 
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
 /***************************************************************************/
 
 void mcf_autovector(unsigned int vec)
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5307/entry.S linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/entry.S
--- linux-2.6.0-test8/arch/m68knommu/platform/5307/entry.S	2003-10-20 09:10:57.714660248 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/entry.S	2003-10-20 09:11:55.814827680 +1000
@@ -182,7 +182,7 @@
 	movew   %sp@(LFORMATVEC),%d0	/* put exception # in d0 */
 	andl	#0x03fc,%d0		/* mask out vector only */
 
-	leal	kstat__per_cpu+STAT_IRQ,%a0
+	leal	per_cpu__kstat+STAT_IRQ,%a0
 	addql	#1,%a0@(%d0)
 
 	lsrl	#2,%d0			/* calculate real vector # */
@@ -213,7 +213,7 @@
 	movew   %sp@(LFORMATVEC),%d0
 	andl	#0x03fc,%d0		/* mask out vector only */
 
-	leal	kstat__per_cpu+STAT_IRQ,%a0
+	leal	per_cpu__kstat+STAT_IRQ,%a0
 	addql	#1,%a0@(%d0)
 
 	movel	%sp,%sp@-		/* push regs arg onto stack */
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5307/ints.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/ints.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5307/ints.c	2003-10-20 09:10:57.694663288 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/ints.c	2003-10-20 09:11:55.819826920 +1000
@@ -47,7 +47,7 @@
 static irqreturn_t default_irq_handler(int irq, void *ptr, struct pt_regs *regs)
 {
 #if 1
-	printk("%s(%d): default irq handler vec=%d [0x%x]\n",
+	printk(KERN_INFO "%s(%d): default irq handler vec=%d [0x%x]\n",
 		__FILE__, __LINE__, irq, irq);
 #endif
 	return(IRQ_HANDLED);
@@ -94,7 +94,7 @@
 		if (!node->handler)
 			return node;
 
-	printk("new_irq_node: out of nodes\n");
+	printk(KERN_INFO "new_irq_node: out of nodes\n");
 	return NULL;
 }
 
@@ -106,19 +106,19 @@
 	void *dev_id)
 {
 	if (irq < 0 || irq >= NR_IRQS) {
-		printk("%s: Incorrect IRQ %d from %s\n", __FUNCTION__,
+		printk(KERN_WARNING "%s: Incorrect IRQ %d from %s\n", __FUNCTION__,
 			irq, devname);
 		return -ENXIO;
 	}
 
 	if (!(irq_list[irq].flags & IRQ_FLG_STD)) {
 		if (irq_list[irq].flags & IRQ_FLG_LOCK) {
-			printk("%s: IRQ %d from %s is not replaceable\n",
+			printk(KERN_WARNING "%s: IRQ %d from %s is not replaceable\n",
 			       __FUNCTION__, irq, irq_list[irq].devname);
 			return -EBUSY;
 		}
 		if (flags & IRQ_FLG_REPLACE) {
-			printk("%s: %s can't replace IRQ %d from %s\n",
+			printk(KERN_WARNING "%s: %s can't replace IRQ %d from %s\n",
 			       __FUNCTION__, devname, irq, irq_list[irq].devname);
 			return -EBUSY;
 		}
@@ -142,12 +142,12 @@
 void free_irq(unsigned int irq, void *dev_id)
 {
 	if (irq >= NR_IRQS) {
-		printk("%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
+		printk(KERN_WARNING "%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}
 
 	if (irq_list[irq].dev_id != dev_id)
-		printk("%s: Removing probably wrong IRQ %d from %s\n",
+		printk(KERN_WARNING "%s: Removing probably wrong IRQ %d from %s\n",
 		       __FUNCTION__, irq, irq_list[irq].devname);
 
 	if (irq_list[irq].flags & IRQ_FLG_FAST) {
@@ -173,7 +173,7 @@
                     unsigned long flags, const char *devname, void *dev_id)
 {
 	if (irq > IRQ7) {
-		printk("%s: Incorrect IRQ %d from %s\n",
+		printk(KERN_WARNING "%s: Incorrect IRQ %d from %s\n",
 		       __FUNCTION__, irq, devname);
 		return -ENXIO;
 	}
@@ -181,12 +181,12 @@
 #if 0
 	if (!(irq_list[irq].flags & IRQ_FLG_STD)) {
 		if (irq_list[irq].flags & IRQ_FLG_LOCK) {
-			printk("%s: IRQ %d from %s is not replaceable\n",
+			printk(KERN_WARNING "%s: IRQ %d from %s is not replaceable\n",
 			       __FUNCTION__, irq, irq_list[irq].devname);
 			return -EBUSY;
 		}
 		if (!(flags & IRQ_FLG_REPLACE)) {
-			printk("%s: %s can't replace IRQ %d from %s\n",
+			printk(KERN_WARNING "%s: %s can't replace IRQ %d from %s\n",
 			       __FUNCTION__, devname, irq, irq_list[irq].devname);
 			return -EBUSY;
 		}
@@ -203,12 +203,12 @@
 void sys_free_irq(unsigned int irq, void *dev_id)
 {
 	if (irq > IRQ7) {
-		printk("%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
+		printk(KERN_WARNING "%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}
 
 	if (irq_list[irq].dev_id != dev_id)
-		printk("%s: Removing probably wrong IRQ %d from %s\n",
+		printk(KERN_WARNING "%s: Removing probably wrong IRQ %d from %s\n",
 		       __FUNCTION__, irq, irq_list[irq].devname);
 
 	irq_list[irq].handler = (*mach_default_handler)[irq];
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5307/timers.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/timers.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5307/timers.c	2003-10-20 09:10:57.714660248 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/timers.c	2003-10-20 09:11:55.839823880 +1000
@@ -127,7 +127,7 @@
 
 void coldfire_profile_init(void)
 {
-	printk("PROFILE: lodging TIMER2 @ %dHz as profile timer\n", PROFILEHZ);
+	printk(KERN_INFO "PROFILE: lodging TIMER2 @ %dHz as profile timer\n", PROFILEHZ);
 
 	/* Set up TIMER 2 as high speed profile clock */
 	mcf_proftp = (volatile struct mcftimer *) (MCF_MBAR + MCFTIMER_BASE2);
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5307/vectors.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/vectors.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5307/vectors.c	2003-10-20 09:10:57.713660400 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5307/vectors.c	2003-10-20 09:11:55.840823728 +1000
@@ -32,7 +32,7 @@
 asmlinkage void dbginterrupt_c(struct frame *fp)
 {
 	extern void dump(struct pt_regs *fp);
-	printk("%s(%d): BUS ERROR TRAP\n", __FILE__, __LINE__);
+	printk(KERN_DEBUG "%s(%d): BUS ERROR TRAP\n", __FILE__, __LINE__);
 	dump((struct pt_regs *) fp);
 	asm("halt");
 }
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5407/CLEOPATRA/crt0_ram.S linux-2.6.0-test8-uc0/arch/m68knommu/platform/5407/CLEOPATRA/crt0_ram.S
--- linux-2.6.0-test8/arch/m68knommu/platform/5407/CLEOPATRA/crt0_ram.S	2003-10-20 09:10:57.661668304 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5407/CLEOPATRA/crt0_ram.S	2003-10-20 09:11:56.081787096 +1000
@@ -124,6 +124,7 @@
 	nop
 
 
+#ifdef CONFIG_ROMFS_FS
 	/*
 	 *	Move ROM filesystem above bss :-)
 	 */
@@ -145,6 +146,12 @@
 	cmp.l	%a0, %a2			/* Check if at end */
 	bne	_copy_romfs
 
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
 	/*
 	 *	Zero out the bss region.
 	 */
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5407/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/5407/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/5407/config.c	2003-10-20 09:10:57.623674080 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5407/config.c	2003-10-20 09:11:56.107783144 +1000
@@ -14,6 +14,7 @@
 #include <linux/sched.h>
 #include <linux/param.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <asm/irq.h>
 #include <asm/dma.h>
 #include <asm/traps.h>
@@ -27,7 +28,7 @@
 /***************************************************************************/
 
 void coldfire_tick(void);
-void coldfire_timer_init(void (*handler)(int, void *, struct pt_regs *));
+void coldfire_timer_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
 unsigned long coldfire_timer_offset(void);
 void coldfire_trap_init(void);
 void coldfire_reset(void);
@@ -48,6 +49,8 @@
         MCF_MBAR + MCFDMA_BASE3,
 };
 
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
 /***************************************************************************/
 
 void mcf_autovector(unsigned int vec)
@@ -100,7 +103,13 @@
 void config_BSP(char *commandp, int size)
 {
 	mcf_setimr(MCFSIM_IMR_MASKALL);
+
+#if defined(CONFIG_BOOTPARAM)
+	strncpy(commandp, CONFIG_BOOTPARAM_STRING, size);
+	commandp[size-1] = 0;
+#else
 	memset(commandp, 0, size);
+#endif
 
 #if defined(CONFIG_CLEOPATRA)
 	/* Different timer setup - to prevent device clash */
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/5407/MOTOROLA/crt0_ram.S linux-2.6.0-test8-uc0/arch/m68knommu/platform/5407/MOTOROLA/crt0_ram.S
--- linux-2.6.0-test8/arch/m68knommu/platform/5407/MOTOROLA/crt0_ram.S	2003-10-20 09:10:57.652669672 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/5407/MOTOROLA/crt0_ram.S	2003-10-20 09:11:56.107783144 +1000
@@ -99,10 +99,12 @@
 	movec	%d0, %ACR3
 
 	/* Enable cache */
-	move.l	#0xa4098400, %d0		/* Write buffer, dflt precise */
+	move.l	#0xb6088400, %d0		/* Enable caches */
 	movec	%d0,%CACR
 	nop
 
+
+#ifdef CONFIG_ROMFS_FS
 	/*
 	 *	Move ROM filesystem above bss :-)
 	 */
@@ -124,6 +126,12 @@
 	cmp.l	%a0, %a2			/* Check if at end */
 	bne	_copy_romfs
 
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
 	/*
 	 *	Zero out the bss region.
 	 */
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68328/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68328/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68328/config.c	2003-10-20 09:10:57.693663440 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68328/config.c	2003-10-20 09:11:56.164774480 +1000
@@ -19,6 +19,7 @@
 #include <linux/mm.h>
 #include <linux/tty.h>
 #include <linux/console.h>
+#include <linux/interrupt.h>
 #include <asm/current.h>
 
 #include <asm/setup.h>
@@ -29,7 +30,7 @@
 #include <asm/MC68328.h>
 
 
-void BSP_sched_init(void (*timer_routine)(int, void *, struct pt_regs *))
+void BSP_sched_init(irqreturn_t (*timer_routine)(int, void *, struct pt_regs *))
 {
 
 #ifdef CONFIG_XCOPILOT_BUGS
@@ -111,9 +112,9 @@
 
 void config_BSP(char *command, int len)
 {
-  printk("\n68328 support D. Jeff Dionne <jeff@uclinux.org>\n");
-  printk("68328 support Kenneth Albanowski <kjahds@kjshds.com>\n");
-  printk("68328/Pilot support Bernhard Kuhn <kuhn@lpr.e-technik.tu-muenchen.de>\n");
+  printk(KERN_INFO "\n68328 support D. Jeff Dionne <jeff@uclinux.org>\n");
+  printk(KERN_INFO "68328 support Kenneth Albanowski <kjahds@kjshds.com>\n");
+  printk(KERN_INFO "68328/Pilot support Bernhard Kuhn <kuhn@lpr.e-technik.tu-muenchen.de>\n");
 
   mach_sched_init      = BSP_sched_init;
   mach_tick            = BSP_tick;
@@ -122,4 +123,5 @@
   mach_hwclk           = NULL;
   mach_set_clock_mmss  = NULL;
   mach_reset           = BSP_reset;
+  *command = '\0';
 }
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68328/ints.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68328/ints.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68328/ints.c	2003-10-20 09:10:57.690663896 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68328/ints.c	2003-10-20 09:11:56.184771440 +1000
@@ -63,15 +63,15 @@
 asmlinkage void trap45(void);
 asmlinkage void trap46(void);
 asmlinkage void trap47(void);
-asmlinkage void bad_interrupt(int, void *, struct pt_regs *);
-asmlinkage void inthandler(void);
-asmlinkage void inthandler1(void);
-asmlinkage void inthandler2(void);
-asmlinkage void inthandler3(void);
-asmlinkage void inthandler4(void);
-asmlinkage void inthandler5(void);
-asmlinkage void inthandler6(void);
-asmlinkage void inthandler7(void);
+asmlinkage irqreturn_t bad_interrupt(int, void *, struct pt_regs *);
+asmlinkage irqreturn_t inthandler(void);
+asmlinkage irqreturn_t inthandler1(void);
+asmlinkage irqreturn_t inthandler2(void);
+asmlinkage irqreturn_t inthandler3(void);
+asmlinkage irqreturn_t inthandler4(void);
+asmlinkage irqreturn_t inthandler5(void);
+asmlinkage irqreturn_t inthandler6(void);
+asmlinkage irqreturn_t inthandler7(void);
 
 extern e_vector *_ramvec;
 
@@ -116,17 +116,17 @@
 
 	/* set up the vectors */
 	for (i = 72; i < 256; ++i)
-		_ramvec[i] = (e_vector)bad_interrupt;
+		_ramvec[i] = (e_vector) bad_interrupt;
 
 	_ramvec[32] = system_call;
 
-	_ramvec[65] = inthandler1;
-	_ramvec[66] = inthandler2;
-	_ramvec[67] = inthandler3;
-	_ramvec[68] = inthandler4;
-	_ramvec[69] = inthandler5;
-	_ramvec[70] = inthandler6;
-	_ramvec[71] = inthandler7;
+	_ramvec[65] = (e_vector) inthandler1;
+	_ramvec[66] = (e_vector) inthandler2;
+	_ramvec[67] = (e_vector) inthandler3;
+	_ramvec[68] = (e_vector) inthandler4;
+	_ramvec[69] = (e_vector) inthandler5;
+	_ramvec[70] = (e_vector) inthandler6;
+	_ramvec[71] = (e_vector) inthandler7;
  
 	IVR = 0x40; /* Set DragonBall IVR (interrupt base) to 64 */
 
@@ -142,22 +142,26 @@
 	IMR = ~0;
 }
 
-int request_irq(unsigned int irq, void (*handler)(int, void *, struct pt_regs *),
-                         unsigned long flags, const char *devname, void *dev_id)
+int request_irq(
+	unsigned int irq,
+	irqreturn_t (*handler)(int, void *, struct pt_regs *),
+	unsigned long flags,
+	const char *devname,
+	void *dev_id)
 {
 	if (irq >= NR_IRQS) {
-		printk ("%s: Unknown IRQ %d from %s\n", __FUNCTION__, irq, devname);
+		printk (KERN_ERR "%s: Unknown IRQ %d from %s\n", __FUNCTION__, irq, devname);
 		return -ENXIO;
 	}
 
 	if (!(int_irq_list[irq].flags & IRQ_FLG_STD)) {
 		if (int_irq_list[irq].flags & IRQ_FLG_LOCK) {
-			printk("%s: IRQ %d from %s is not replaceable\n",
+			printk(KERN_ERR "%s: IRQ %d from %s is not replaceable\n",
 			       __FUNCTION__, irq, int_irq_list[irq].devname);
 			return -EBUSY;
 		}
 		if (flags & IRQ_FLG_REPLACE) {
-			printk("%s: %s can't replace IRQ %d from %s\n",
+			printk(KERN_ERR "%s: %s can't replace IRQ %d from %s\n",
 			       __FUNCTION__, devname, irq, int_irq_list[irq].devname);
 			return -EBUSY;
 		}
@@ -178,12 +182,12 @@
 void free_irq(unsigned int irq, void *dev_id)
 {
 	if (irq >= NR_IRQS) {
-		printk ("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
+		printk (KERN_ERR "%s: Unknown IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}
 
 	if (int_irq_list[irq].dev_id != dev_id)
-		printk("%s: removing probably wrong IRQ %d from %s\n",
+		printk(KERN_INFO "%s: removing probably wrong IRQ %d from %s\n",
 		       __FUNCTION__, irq, int_irq_list[irq].devname);
 
 	int_irq_list[irq].handler = bad_interrupt;
@@ -278,7 +282,7 @@
 		if (int_irq_list[irq].handler) {
 			int_irq_list[irq].handler(irq, int_irq_list[irq].dev_id, fp);
 		} else {
-			printk("unregistered interrupt %d!\nTurning it off in the IMR...\n", irq);
+			printk(KERN_ERR "unregistered interrupt %d!\nTurning it off in the IMR...\n", irq);
 			IMR |= mask;
 		}
 		pend &= ~mask;
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68360/commproc.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68360/commproc.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68360/commproc.c	2003-10-20 09:10:57.562683352 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68360/commproc.c	2003-10-20 09:11:56.192770224 +1000
@@ -213,7 +213,7 @@
 	request_irq(vec, handler, IRQ_FLG_LOCK, "timer", dev_id);
 
 /* 	if (cpm_vecs[vec].handler != 0) */
-/* 		printk("CPM interrupt %x replacing %x\n", */
+/* 		printk(KERN_INFO "CPM interrupt %x replacing %x\n", */
 /* 			(uint)handler, (uint)cpm_vecs[vec].handler); */
 /* 	cpm_vecs[vec].handler = handler; */
 /* 	cpm_vecs[vec].dev_id = dev_id; */
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68360/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68360/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68360/config.c	2003-10-20 09:10:57.562683352 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68360/config.c	2003-10-20 09:11:56.199769160 +1000
@@ -181,12 +181,12 @@
      }
   }
 
-  printk("\n68360 QUICC support (C) 2000 Lineo Inc.\n");
+  printk(KERN_INFO "\n68360 QUICC support (C) 2000 Lineo Inc.\n");
 
 #if defined(CONFIG_UCQUICC) && 0
-  printk("uCquicc serial string [%s]\n",getserialnum());
+  printk(KERN_INFO "uCquicc serial string [%s]\n",getserialnum());
   p = scc1_hwaddr = gethwaddr(0);
-  printk("uCquicc hwaddr %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+  printk(KERN_INFO "uCquicc hwaddr %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
          p[0], p[1], p[2], p[3], p[4], p[5]);
 
   p = getbenv("APPEND");
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68360/ints.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68360/ints.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68360/ints.c	2003-10-20 09:10:57.561683504 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68360/ints.c	2003-10-20 09:11:56.200769008 +1000
@@ -36,8 +36,8 @@
 asmlinkage void system_call(void);
 asmlinkage void buserr(void);
 asmlinkage void trap(void);
-asmlinkage void bad_interrupt(void);
-asmlinkage void inthandler(void);
+asmlinkage irqreturn_t bad_interrupt(void);
+asmlinkage irqreturn_t inthandler(void);
 
 extern void *_ramvec[];
 
@@ -141,7 +141,7 @@
 	irq_node_t *cur;
 
 	if (!node->dev_id)
-		printk("%s: Warning: dev_id of %s is zero\n",
+		printk(KERN_INFO "%s: Warning: dev_id of %s is zero\n",
 		       __FUNCTION__, node->devname);
 
 	local_irq_save(flags);
@@ -176,30 +176,34 @@
 		}
 	}
 	local_irq_restore(flags);
-	printk ("%s: tried to remove invalid irq\n", __FUNCTION__);
+	printk (KERN_INFO "%s: tried to remove invalid irq\n", __FUNCTION__);
 }
 #endif
 
-int request_irq(unsigned int irq, void (*handler)(int, void *, struct pt_regs *),
-                unsigned long flags, const char *devname, void *dev_id)
+int request_irq(
+	unsigned int irq,
+	irqreturn_t (*handler)(int, void *, struct pt_regs *),
+	unsigned long flags,
+	const char *devname,
+	void *dev_id)
 {
 	int mask = (1<<irq);
 
 	irq += (CPM_VECTOR_BASE<<4);
 
 	if (irq >= INTERNAL_IRQS) {
-		printk ("%s: Unknown IRQ %d from %s\n", __FUNCTION__, irq, devname);
+		printk (KERN_ERR "%s: Unknown IRQ %d from %s\n", __FUNCTION__, irq, devname);
 		return -ENXIO;
 	}
 
 	if (!(int_irq_list[irq].flags & IRQ_FLG_STD)) {
 		if (int_irq_list[irq].flags & IRQ_FLG_LOCK) {
-			printk("%s: IRQ %d from %s is not replaceable\n",
+			printk(KERN_ERR "%s: IRQ %d from %s is not replaceable\n",
 			       __FUNCTION__, irq, int_irq_list[irq].devname);
 			return -EBUSY;
 		}
 		if (flags & IRQ_FLG_REPLACE) {
-			printk("%s: %s can't replace IRQ %d from %s\n",
+			printk(KERN_ERR "%s: %s can't replace IRQ %d from %s\n",
 			       __FUNCTION__, devname, irq, int_irq_list[irq].devname);
 			return -EBUSY;
 		}
@@ -222,12 +226,12 @@
 void free_irq(unsigned int irq, void *dev_id)
 {
 	if (irq >= INTERNAL_IRQS) {
-		printk ("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
+		printk (KERN_ERR "%s: Unknown IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}
 
 	if (int_irq_list[irq].dev_id != dev_id)
-		printk("%s: removing probably wrong IRQ %d from %s\n",
+		printk(KERN_INFO "%s: removing probably wrong IRQ %d from %s\n",
 		       __FUNCTION__, irq, int_irq_list[irq].devname);
 	int_irq_list[irq].handler = NULL;
 	int_irq_list[irq].flags   = IRQ_FLG_STD;
@@ -250,7 +254,7 @@
 void M68360_enable_irq(unsigned int irq)
 {
 	if (irq >= INTERNAL_IRQS) {
-		printk("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
+		printk(KERN_ERR "%s: Unknown IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}
 
@@ -264,7 +268,7 @@
 void M68360_disable_irq(unsigned int irq)
 {
 	if (irq >= INTERNAL_IRQS) {
-		printk("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
+		printk(KERN_ERR "%s: Unknown IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}
 
@@ -322,9 +326,10 @@
 		kstat_cpu(0).irqs[irq]++;
 		pquicc->intr_cisr = (1 << vec); /* indicate that irq has been serviced */
 	} else {
-		printk("unregistered interrupt %d!\nTurning it off in the CIMR...\n", irq);
+		printk(KERN_ERR "unregistered interrupt %d!\nTurning it off in the CIMR...\n", irq);
 		/* *(volatile unsigned long *)0xfffff304 |= mask; */
 		pquicc->intr_cimr &= ~(1 << vec);
 		num_spurious += 1;
 	}
+	return(IRQ_HANDLED);
 }
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68EZ328/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68EZ328/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68EZ328/config.c	2003-10-20 09:10:57.676666024 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68EZ328/config.c	2003-10-20 09:11:56.234763840 +1000
@@ -106,12 +106,12 @@
 {
   unsigned char *p;
 
-  printk("\n68EZ328 DragonBallEZ support (C) 1999 Rt-Control, Inc\n");
+  printk(KERN_INFO "\n68EZ328 DragonBallEZ support (C) 1999 Rt-Control, Inc\n");
 
 #ifdef CONFIG_UCSIMM
-  printk("uCsimm serial string [%s]\n",getserialnum());
+  printk(KERN_INFO "uCsimm serial string [%s]\n",getserialnum());
   p = cs8900a_hwaddr = gethwaddr(0);
-  printk("uCsimm hwaddr %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+  printk(KERN_INFO "uCsimm hwaddr %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
          p[0], p[1], p[2], p[3], p[4], p[5]);
 
   p = getbenv("APPEND");
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/config.c	2003-10-20 09:10:57.663668000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/config.c	2003-10-20 09:11:56.248761712 +1000
@@ -185,7 +185,7 @@
 
 void config_BSP(char *command, int size)
 {
-	printk("68VZ328 DragonBallVZ support (c) 2001 Lineo, Inc.\n");
+	printk(KERN_INFO "68VZ328 DragonBallVZ support (c) 2001 Lineo, Inc.\n");
 
 #if defined(CONFIG_BOOTPARAM)
 	strncpy(command, CONFIG_BOOTPARAM_STRING, size);
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/crt0_ram.S linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/crt0_ram.S
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/crt0_ram.S	2003-10-20 09:10:57.663668000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/crt0_ram.S	2003-10-20 09:11:56.248761712 +1000
@@ -8,17 +8,21 @@
 #define	MEM_END	0x00800000	/* Memory size 8Mb */
 #endif
 
+#undef CRT_DEBUG
+
+.macro	PUTC CHAR
+#ifdef CRT_DEBUG
+	moveq	#\CHAR, %d7
+	jsr	putc
+#endif
+.endm
+
 	.global	_start
 	.global _rambase
 	.global _ramvec
 	.global	_ramstart
 	.global	_ramend
 	
-.macro	PUTC CHAR
-	moveq	#\CHAR, %d7
-	jsr	putc
-.endm
-
 	.data
 
 /*
@@ -120,6 +124,7 @@
  * Local functions
  */
  
+#ifdef CRT_DEBUG
 putc:
 	moveb	%d7, 0xfffff907
 1:
@@ -127,3 +132,4 @@
 	andw	#0x2000, %d7
 	beq	1b
 	rts
+#endif
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/Makefile linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/Makefile
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/Makefile	2003-10-20 09:10:57.664667848 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/Makefile	2003-10-20 09:11:56.248761712 +1000
@@ -2,11 +2,13 @@
 # Makefile for arch/m68knommu/platform/68VZ328/de2.
 #
 
-obj-y := config.o
+obj-$(CONFIG_DRAGEN2) := config.o
 
-EXTRA_TARGETS := bootlogo.rh crt0_$(MODEL).o
+extra-$(CONFIG_DRAGEN2) := crt0_ram.o
 
-$(obj)/bootlogo.rh: $(src)/../../68EZ328/bootlogo.h
-	perl $(src)/../../68328/bootlogo.pl < $(src)/../../68EZ328/bootlogo.h \
-		> $(obj)/bootlogo.rh
+$(obj)/config.o: $(obj)/screen.h
 
+$(obj)/screen.h: $(src)/screen.xbm $(src)/xbm2lcd.pl
+	perl $(src)/xbm2lcd.pl < $(src)/screen.xbm > $(obj)/screen.h
+
+clean-files := screen.h
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/screen.xbm linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/screen.xbm
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/screen.xbm	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/screen.xbm	2003-10-20 09:11:56.250761408 +1000
@@ -0,0 +1,804 @@
+/* Created with The GIMP */
+#define screen_width 320
+#define screen_height 240
+static unsigned char screen_bits[] = {
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x63, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x34, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x95,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x4f, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6b, 0xa5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x29, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x3f, 0x56, 0xa9, 0xff, 0xff, 0xff, 0x3f, 0xe0, 0xf1, 0xf8, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3,
+   0x7f, 0xe0, 0xff, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0x25, 0x55, 0xff, 0xff, 0xff, 0x0f,
+   0xc0, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xe3, 0x3f, 0xc0, 0xff, 0x01, 0xfe, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x52, 0x95,
+   0xff, 0xff, 0xff, 0x87, 0xcf, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x3f, 0x8f, 0xff, 0x79,
+   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x14, 0x55, 0x55, 0xff, 0x3f, 0x8e, 0xc7, 0xff, 0xf1, 0x78, 0x86,
+   0x8f, 0xe3, 0x78, 0xfe, 0xf1, 0xfc, 0xf0, 0x31, 0x33, 0xfc, 0xe1, 0xe3,
+   0xff, 0x8f, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xbf, 0x6a, 0xaa, 0x4a, 0xff, 0x3f, 0x8e, 0xe3,
+   0xff, 0xf1, 0x78, 0x00, 0x8f, 0xe3, 0x38, 0xfe, 0x71, 0x3c, 0xe0, 0x11,
+   0x03, 0x78, 0xc0, 0xe3, 0xff, 0x8f, 0xff, 0x08, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0x2b, 0x55, 0xa9,
+   0xff, 0x3f, 0x8e, 0xe3, 0xff, 0xf1, 0x78, 0x18, 0x8f, 0xe3, 0x31, 0xff,
+   0x31, 0x3e, 0xc6, 0x01, 0xc3, 0x78, 0x8c, 0xe3, 0xff, 0xc7, 0xff, 0x00,
+   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x57, 0x95, 0x2a, 0x55, 0xff, 0x3f, 0x8e, 0xe3, 0xff, 0xf1, 0x78, 0x1c,
+   0x8f, 0xe3, 0x91, 0xff, 0x11, 0x1f, 0xc7, 0xe1, 0xe3, 0x38, 0x8e, 0xe3,
+   0xff, 0xe1, 0xff, 0x30, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x69, 0x55, 0xa5, 0x12, 0xff, 0x3f, 0x8e, 0xe3,
+   0xff, 0xf1, 0x78, 0x1c, 0x8f, 0xe3, 0xc3, 0xff, 0x81, 0x1f, 0xc0, 0xf1,
+   0xe3, 0x38, 0x80, 0xe3, 0xff, 0xf0, 0xff, 0x78, 0xfc, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x5a, 0xa6, 0x2a, 0x49,
+   0xff, 0x3f, 0x8e, 0xc3, 0xff, 0xf1, 0x78, 0x1c, 0x8f, 0xe3, 0x83, 0xff,
+   0x01, 0x1f, 0xc0, 0xf1, 0xe3, 0x38, 0x80, 0xe3, 0x7f, 0xfc, 0xff, 0x78,
+   0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f,
+   0x4d, 0x51, 0x92, 0x54, 0xff, 0x3f, 0x8e, 0xc7, 0xff, 0xf1, 0x78, 0x1c,
+   0x8f, 0xe3, 0x11, 0xff, 0x11, 0x1e, 0xff, 0xf1, 0xe3, 0x38, 0xfe, 0xe3,
+   0x3f, 0xfe, 0xff, 0x78, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xd7, 0xaa, 0xac, 0x54, 0x25, 0xff, 0x3f, 0x86, 0x07,
+   0xcf, 0xf1, 0x78, 0x1c, 0x8f, 0xe1, 0x19, 0xff, 0x31, 0x1c, 0xce, 0xf1,
+   0xe3, 0x38, 0x9c, 0xe3, 0x3f, 0x80, 0xe3, 0x71, 0xfc, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xab, 0x52, 0x22, 0x25, 0xa9,
+   0xff, 0x3f, 0x80, 0x0f, 0xc0, 0xf1, 0x78, 0x1c, 0x0f, 0xe0, 0x38, 0xfe,
+   0x71, 0x38, 0xc0, 0xf1, 0xe3, 0x78, 0x80, 0xe3, 0x3f, 0x80, 0xe3, 0x01,
+   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6a,
+   0x29, 0x95, 0x94, 0x4a, 0xff, 0x7f, 0x98, 0x3f, 0xf0, 0xf1, 0x78, 0x1c,
+   0x1f, 0xe6, 0x3c, 0xfe, 0xf1, 0xf8, 0xe0, 0xf1, 0xe3, 0xf8, 0xc1, 0xe3,
+   0x3f, 0x80, 0xe3, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x3f, 0x55, 0x55, 0xa9, 0xa2, 0x28, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0x95, 0x54, 0x54, 0x54, 0xca,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xab, 0xa5,
+   0x12, 0x43, 0x15, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x51, 0x49, 0xaa, 0x34, 0xca, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x2e, 0xa9, 0x92, 0x84, 0x29, 0x92,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xa2, 0x4a,
+   0x28, 0xb3, 0xa4, 0x4a, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x87, 0xaa, 0x52, 0x4a, 0x89, 0x96, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0x7f, 0x9e, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xc0, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0x3c, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0x29, 0x09, 0xa5, 0x52, 0x51, 0x69,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0x9e, 0xff, 0xff, 0x9f, 0xe7, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3c,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x50, 0xa4, 0x64,
+   0x35, 0x28, 0x29, 0x2d, 0xff, 0xff, 0xf0, 0x84, 0x3f, 0x98, 0xf0, 0xe1,
+   0x9f, 0xcf, 0xc9, 0xc1, 0x07, 0x1e, 0x9e, 0xf0, 0xfc, 0x84, 0x0f, 0xcc,
+   0x84, 0x0f, 0xff, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x3f, 0x94, 0x2a, 0x15, 0x89, 0xae, 0x94, 0xa2, 0xff, 0x7f, 0xe6, 0x18,
+   0x7f, 0x1e, 0xe3, 0xcc, 0x9f, 0xcf, 0xc9, 0x9f, 0x73, 0xce, 0x1c, 0xe3,
+   0xfc, 0x18, 0xe7, 0xcc, 0x18, 0x67, 0xfe, 0x3c, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x8f, 0x4b, 0x85, 0xa4, 0x55, 0x22, 0x65, 0xbd,
+   0xff, 0x3f, 0xcf, 0x3c, 0x7f, 0x9e, 0x67, 0xce, 0x9f, 0xcf, 0xf1, 0x9f,
+   0x79, 0xe6, 0x99, 0xe7, 0xe0, 0x3c, 0xf3, 0xcc, 0x3c, 0x73, 0xfe, 0x3c,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa7, 0x10, 0x29, 0xa9,
+   0x2a, 0x95, 0x94, 0x02, 0xff, 0x3f, 0xcf, 0x3c, 0x7f, 0x9e, 0x67, 0xc0,
+   0x9f, 0xcf, 0xf9, 0x81, 0x79, 0xe6, 0x99, 0xe7, 0xfc, 0x3c, 0xf3, 0xcc,
+   0x3c, 0x03, 0xfe, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x51, 0xd6, 0x24, 0x51, 0x89, 0xa4, 0xaa, 0xba, 0xff, 0x3f, 0xcf, 0x3c,
+   0x7f, 0x9e, 0x67, 0xfe, 0x9f, 0xcf, 0xf9, 0x9c, 0x79, 0xe6, 0x99, 0xe7,
+   0xfc, 0x3c, 0xf3, 0xcc, 0x3c, 0xf3, 0xff, 0x3c, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0x24, 0x29, 0x4a, 0x26, 0x1b, 0x55, 0x55, 0x55,
+   0xff, 0x3f, 0xcf, 0x3c, 0x7f, 0x9e, 0x67, 0xfe, 0x9f, 0xcf, 0xf9, 0x9c,
+   0x33, 0xe6, 0x99, 0xe7, 0xfc, 0x3c, 0x67, 0xcc, 0x3c, 0xf3, 0xff, 0x3c,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x93, 0x84, 0x52, 0x59,
+   0x51, 0xa5, 0x54, 0x95, 0xff, 0x7f, 0xe6, 0x3c, 0x7f, 0x9e, 0xe7, 0xdc,
+   0x9f, 0xe7, 0xf9, 0x8c, 0x47, 0xce, 0x9c, 0xe7, 0xfc, 0x3c, 0x8f, 0xcc,
+   0x3c, 0xe7, 0xfe, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf,
+   0x48, 0x52, 0x49, 0x95, 0x55, 0x55, 0x55, 0x8a, 0xff, 0xff, 0xf0, 0x3c,
+   0xff, 0x98, 0xe7, 0xe1, 0x1f, 0xf0, 0xf9, 0x11, 0x7f, 0x1e, 0x9e, 0xe7,
+   0xc0, 0x3c, 0xff, 0xcc, 0x3c, 0x0f, 0xff, 0x3c, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xa1, 0x2a, 0x49, 0xa4, 0xaa, 0xac, 0x54, 0x49, 0xe5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0xfe, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x95, 0xa4, 0xaa, 0xa8, 0x8a,
+   0x26, 0xa5, 0x6a, 0x2d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x54,
+   0x22, 0x40, 0x4a, 0x4a, 0x69, 0xa8, 0x2c, 0x55, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x5f, 0x0a, 0x92, 0xae, 0xa9, 0x62, 0xa5, 0x4b, 0xa2, 0x92,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x47, 0xa1, 0x51, 0x89, 0x4c, 0xb5,
+   0x26, 0x24, 0x55, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x25, 0x4a,
+   0x0a, 0x56, 0x55, 0x48, 0x55, 0x55, 0x29, 0x55, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xa8, 0x52, 0xc8, 0x40, 0x65, 0xa5, 0x52, 0x95, 0xaa, 0x92,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x12, 0x29, 0x93, 0xad, 0x28, 0x2a,
+   0x4b, 0xa9, 0x26, 0x29, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x4a, 0x09,
+   0x29, 0x28, 0x44, 0x21, 0xa9, 0x55, 0x52, 0x95, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x17, 0x91, 0xa4, 0x94, 0x45, 0xb9, 0x9c, 0x54, 0x93, 0xaa, 0x52,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0x24, 0x95, 0xc2, 0xb0, 0x5a, 0x45,
+   0x96, 0xaa, 0x92, 0x94, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x88, 0x40,
+   0x54, 0xcb, 0x49, 0xa6, 0x51, 0x25, 0xa9, 0x52, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x3f, 0x88, 0x4a, 0x55, 0x57, 0x08, 0xd5, 0x90, 0x5c, 0xa9, 0x6a, 0x9a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x5f, 0x25, 0x94, 0x4a, 0x82, 0xf2, 0x9a, 0x53,
+   0x25, 0x54, 0xad, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x28, 0x45, 0x50,
+   0xaa, 0x14, 0xd0, 0x51, 0xa2, 0x55, 0x0a, 0x89, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x13, 0x85, 0x10, 0x55, 0x79, 0xc2, 0xef, 0x25, 0x55, 0xa5, 0x6a, 0x52,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0x90, 0xa2, 0xaa, 0xaa, 0x06, 0x69, 0xc8, 0x54,
+   0x2d, 0x6a, 0xaa, 0xab, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x4b, 0x54, 0x48, 0xa5,
+   0xb0, 0x94, 0x8a, 0x24, 0x86, 0x1b, 0x05, 0x52, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
+   0x49, 0x25, 0xaa, 0xa4, 0x8a, 0x56, 0xe5, 0x54, 0xd3, 0x49, 0xe9, 0x4a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x57, 0x24, 0x14, 0x95, 0x52, 0x54, 0x49, 0x6b, 0x25,
+   0x2d, 0x24, 0x15, 0x92, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x93, 0xa4, 0xca, 0x54, 0x2d,
+   0x15, 0xa9, 0x26, 0x91, 0xc5, 0x56, 0xd5, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0,
+   0x12, 0x20, 0x2a, 0x92, 0xa8, 0x4a, 0xb9, 0x56, 0x7a, 0x50, 0x6a, 0x4a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x3f, 0x15, 0x0a, 0x29, 0xb1, 0xd5, 0x66, 0x54, 0x8f, 0x30,
+   0x05, 0x57, 0xab, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xa8, 0xd4, 0x4a, 0x45, 0x53,
+   0x52, 0xd3, 0xb2, 0xaa, 0xd5, 0xa2, 0x4a, 0x55, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x85,
+   0x0a, 0x48, 0x2a, 0xa8, 0x32, 0xaa, 0xa9, 0x4a, 0x54, 0x54, 0xaa, 0x2a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xab, 0x62, 0x50, 0x22, 0x52, 0x55, 0xd9, 0x15, 0x55, 0x29,
+   0x45, 0xf4, 0xb5, 0xca, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x2a, 0x25, 0x92, 0x49, 0x13,
+   0x09, 0xaa, 0x25, 0xba, 0x52, 0x07, 0x48, 0x31, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x59, 0xaa,
+   0x89, 0x20, 0x34, 0xa5, 0xd4, 0xd5, 0xaa, 0x85, 0x3c, 0x52, 0x57, 0x95,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x1f, 0x0a, 0x01, 0xa8, 0x92, 0xaa, 0x94, 0x4a, 0x70, 0xb4, 0x54,
+   0x95, 0x55, 0xa9, 0x54, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0x42, 0xa4, 0x0a, 0x51, 0x09, 0xa5,
+   0x5d, 0x9b, 0x12, 0x25, 0xfb, 0x44, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa3, 0x28, 0x01,
+   0x50, 0x4d, 0x56, 0x91, 0x64, 0x95, 0x52, 0xb5, 0x49, 0xb7, 0x4a, 0xaa,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x15, 0x03, 0xda, 0x0e, 0x62, 0x89, 0xba, 0x09, 0x47, 0xa9, 0x08,
+   0x52, 0x49, 0xaa, 0x52, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x3f, 0x40, 0x51, 0x0b, 0xc1, 0x15, 0xee, 0x90,
+   0xfe, 0x52, 0x15, 0xc5, 0x14, 0x55, 0xd5, 0x8a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x63, 0x00, 0x90,
+   0x2a, 0xa1, 0x15, 0xd6, 0x08, 0x4f, 0xd8, 0xa8, 0xea, 0xaa, 0x2a, 0x00,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xcf, 0x10, 0x00, 0x49, 0x12, 0x2d, 0x63, 0x17, 0xab, 0xa0, 0x12, 0x95,
+   0x12, 0xaa, 0x48, 0x64, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xe7, 0x82, 0x40, 0xa4, 0x86, 0xc8, 0x98, 0x54,
+   0xb5, 0xab, 0xe5, 0x6a, 0xd5, 0xa5, 0x16, 0x18, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x68, 0x90, 0x82,
+   0xd4, 0x25, 0x4a, 0x39, 0x79, 0x10, 0x12, 0x0a, 0x55, 0xb5, 0x06, 0x88,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
+   0x6c, 0x42, 0x20, 0x29, 0x28, 0x50, 0x29, 0x4b, 0x15, 0xb5, 0xd6, 0xaa,
+   0x72, 0x2a, 0xad, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xbf, 0x24, 0x2c, 0x00, 0x50, 0x23, 0x55, 0xfa, 0xff,
+   0x5d, 0x89, 0x52, 0x52, 0x59, 0xb5, 0xff, 0xcd, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0x8b, 0x41, 0x24, 0x5a,
+   0xac, 0x82, 0xfe, 0xff, 0xaf, 0xd5, 0xaa, 0x5a, 0x5d, 0xef, 0x6f, 0x57,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3,
+   0xe4, 0x34, 0x27, 0x8a, 0x12, 0xa8, 0xff, 0xff, 0xff, 0x56, 0xaa, 0x95,
+   0xc4, 0x78, 0x7b, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x35, 0x7d, 0x00, 0x11, 0x42, 0xaa, 0xe5, 0xff, 0xff,
+   0xff, 0x24, 0x51, 0xd4, 0xb2, 0xda, 0x1f, 0xa8, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x08, 0x1f, 0x42, 0x59, 0x28,
+   0xba, 0xf4, 0xff, 0xff, 0xff, 0x5b, 0x2d, 0x53, 0x95, 0xfe, 0x11, 0xa9,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xeb,
+   0x7f, 0xeb, 0xa6, 0x92, 0x14, 0xf9, 0xff, 0xff, 0xff, 0xcf, 0xaa, 0xaa,
+   0xaa, 0xbf, 0x1f, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x17, 0xf8, 0x17, 0x72, 0x02, 0x88, 0xd2, 0xfc, 0xff, 0xff,
+   0xff, 0xef, 0xaa, 0x4a, 0xe9, 0xd5, 0xdf, 0xa5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0xd1, 0x1e, 0x11, 0xb1, 0xa5,
+   0x2a, 0xfe, 0xff, 0xff, 0xff, 0xbf, 0xd4, 0x52, 0xb5, 0xef, 0x25, 0xd4,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x51, 0xff,
+   0x07, 0x94, 0x08, 0xa4, 0x54, 0xff, 0xff, 0xff, 0xcf, 0x7f, 0xb5, 0x54,
+   0xfd, 0x70, 0x55, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x26, 0xff, 0x17, 0x2d, 0xb6, 0x12, 0x0a, 0xff, 0xff, 0xff,
+   0x8f, 0x7f, 0x8d, 0xaa, 0x8a, 0x56, 0x55, 0x49, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xe2, 0x77, 0x2b, 0x37, 0x91, 0x08,
+   0xd5, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xd5, 0xaa, 0xaa, 0x52, 0x4a, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xfd, 0xff,
+   0x81, 0xc1, 0x59, 0xd0, 0xe1, 0xff, 0xff, 0xff, 0x07, 0xff, 0x2a, 0x95,
+   0x54, 0x55, 0x65, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xaf, 0xfd, 0xbd, 0x49, 0x8c, 0x58, 0x8a, 0xd5, 0xff, 0xff, 0xff,
+   0xe7, 0xff, 0x49, 0x51, 0x45, 0x55, 0x4d, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xab, 0xbe, 0x3f, 0xc4, 0xd5, 0x02, 0x79,
+   0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb7, 0x4a, 0xba, 0x52, 0xf9, 0x4a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa5, 0xff, 0x97,
+   0x64, 0x52, 0xda, 0x1c, 0xc9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa5, 0xa8,
+   0x8a, 0x54, 0x15, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xd5, 0xdf, 0x4f, 0x91, 0x22, 0x2d, 0xc2, 0xe5, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x93, 0x56, 0x6a, 0x55, 0xd5, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0xf5, 0xef, 0x25, 0x5c, 0x43, 0x16, 0xaf,
+   0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0x92, 0x2a, 0x2b, 0x55, 0x2a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xdb, 0xfb, 0x43,
+   0x65, 0x21, 0x91, 0x13, 0xe5, 0xff, 0xff, 0xff, 0xff, 0xff, 0x47, 0x49,
+   0x51, 0x52, 0x55, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xb7, 0xf0, 0x7f, 0x00, 0x7b, 0xea, 0x3c, 0xd1, 0xea, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x27, 0x6a, 0x2d, 0x55, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x5b, 0xfc, 0x7d, 0xac, 0xc6, 0x11, 0xe5, 0x46,
+   0xe9, 0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0x95, 0xd2, 0x4a, 0xb2, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2d, 0xfe, 0x0f, 0x82,
+   0xfc, 0x90, 0x54, 0x32, 0xf5, 0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0xd5,
+   0x5a, 0xaa, 0x55, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x17, 0xdf, 0x1e, 0xc2, 0xa9, 0x23, 0xca, 0x46, 0xe5, 0xff, 0xff, 0x3f,
+   0xf8, 0xff, 0x97, 0x2a, 0x55, 0xad, 0x94, 0x5a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0xc5, 0xff, 0x07, 0xd5, 0x6c, 0xab, 0x12, 0x9a,
+   0xe4, 0x0f, 0xff, 0x1f, 0xe0, 0xff, 0x57, 0xa9, 0x55, 0xa5, 0xda, 0xaa,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa1, 0xef, 0xd1, 0xac,
+   0xc6, 0xa5, 0xea, 0x5c, 0xf3, 0x07, 0xfe, 0x0f, 0xc0, 0xff, 0x4f, 0x55,
+   0xaa, 0x5a, 0x55, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf,
+   0xf0, 0xfb, 0xa8, 0xa5, 0xf2, 0x18, 0x56, 0x41, 0xf7, 0x03, 0xfc, 0x07,
+   0x80, 0xff, 0xaf, 0xaa, 0xaa, 0x4a, 0xad, 0x56, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x3f, 0xd0, 0xbf, 0x41, 0x52, 0x0e, 0xc6, 0xaa, 0x68,
+   0xfa, 0x03, 0xfc, 0x07, 0x80, 0xff, 0x9f, 0x52, 0xd5, 0x6a, 0xab, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x17, 0xfd, 0x1d, 0x28, 0x2a,
+   0x51, 0x75, 0x55, 0x4d, 0xe4, 0x03, 0xf8, 0x03, 0x03, 0xff, 0xaf, 0xaa,
+   0x6a, 0xad, 0xaa, 0x4a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3b,
+   0xfc, 0x9f, 0x00, 0x58, 0x92, 0x22, 0x6a, 0xd3, 0xed, 0xf3, 0xf8, 0xc3,
+   0x0f, 0xff, 0xaf, 0xaa, 0xae, 0xaa, 0xaa, 0xda, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x0a, 0xfe, 0x06, 0x7a, 0x4e, 0x52, 0x94, 0x36, 0x4c,
+   0xf6, 0xb9, 0xf9, 0xc3, 0x1b, 0xff, 0x9f, 0xaa, 0x52, 0xaa, 0xaa, 0x6a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0xb6, 0x03, 0x52, 0x93,
+   0x95, 0x52, 0x46, 0x55, 0xf6, 0xb9, 0xf9, 0xe3, 0x17, 0xfe, 0x4f, 0xd5,
+   0xaa, 0xd5, 0xaa, 0xa6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xa1,
+   0xff, 0xa2, 0x2a, 0x31, 0x18, 0xba, 0x92, 0x55, 0xcb, 0x79, 0xf9, 0xe3,
+   0x17, 0xfe, 0x6f, 0x29, 0xad, 0x54, 0xad, 0xb6, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x4f, 0x80, 0x3f, 0x49, 0xa8, 0xef, 0x75, 0x47, 0x2b, 0x53,
+   0xef, 0x79, 0xf9, 0xe3, 0x1f, 0xfe, 0x9f, 0xa4, 0xaa, 0x6a, 0x55, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1b, 0xe0, 0x8d, 0x20, 0x6e, 0x84,
+   0x53, 0xa8, 0x29, 0xb1, 0xeb, 0xf9, 0xf1, 0xe3, 0x1f, 0xfe, 0x5f, 0xb5,
+   0xaa, 0xaa, 0x56, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe0,
+   0x4f, 0x39, 0x42, 0x38, 0x15, 0x55, 0x92, 0x6d, 0xcc, 0xfb, 0x01, 0xe0,
+   0x1f, 0xfe, 0xaf, 0xaa, 0xaa, 0xaa, 0xaa, 0x4a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x45, 0x78, 0xd3, 0x9c, 0x2a, 0x1a, 0x76, 0x11, 0x13, 0xcc,
+   0xed, 0xf3, 0x06, 0xc3, 0x1f, 0xfe, 0xaf, 0xaa, 0xaa, 0xaa, 0xaa, 0x69,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x23, 0xfc, 0xd3, 0x24, 0x8d, 0x60,
+   0x8a, 0x54, 0xd5, 0x78, 0xd2, 0x67, 0x03, 0x80, 0x0f, 0xff, 0x5f, 0x55,
+   0x55, 0x55, 0xb5, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0x01, 0x6e,
+   0x70, 0x10, 0x58, 0x15, 0xa8, 0x4e, 0xcd, 0xa4, 0xca, 0x37, 0x00, 0x00,
+   0xfe, 0xff, 0xaf, 0x54, 0xaa, 0xda, 0x56, 0xd5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x10, 0xbf, 0x35, 0xc9, 0xb1, 0xf7, 0x3a, 0xa9, 0xd1, 0xa8,
+   0xd3, 0x1f, 0x00, 0x00, 0xf8, 0xff, 0x5f, 0x8d, 0xd5, 0x56, 0x55, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x37, 0xc0, 0x16, 0x94, 0x55, 0x92, 0x2a,
+   0x12, 0x5d, 0x9d, 0x4a, 0xd0, 0x07, 0x00, 0x00, 0x80, 0xff, 0x5f, 0xab,
+   0x54, 0xd5, 0x56, 0x75, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x0c, 0x8f,
+   0x20, 0x4b, 0xb7, 0xd4, 0xe2, 0x92, 0x28, 0xa9, 0xf7, 0x03, 0x00, 0x00,
+   0x00, 0xff, 0xbf, 0xa4, 0xae, 0x2a, 0xa9, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x15, 0xc2, 0xa3, 0x9c, 0x4f, 0x91, 0x72, 0x11, 0x57, 0xab, 0x95,
+   0xd3, 0x01, 0x00, 0x00, 0x00, 0xfe, 0xbf, 0x5a, 0x51, 0xab, 0xb5, 0xaa,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xbf, 0x0f, 0xc0, 0x04, 0x51, 0x46, 0xa5, 0x19,
+   0x57, 0x65, 0x32, 0xc9, 0xcd, 0x01, 0x00, 0x00, 0x00, 0xfe, 0x5f, 0x55,
+   0xae, 0xaa, 0xaa, 0xda, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x60, 0x24,
+   0x48, 0x93, 0xa5, 0x28, 0x4a, 0x29, 0x15, 0x45, 0xda, 0x01, 0x00, 0x00,
+   0x30, 0xfe, 0x5f, 0xd5, 0xb2, 0xaa, 0xaa, 0x6a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x01, 0xd0, 0xa5, 0xaa, 0x24, 0xfd, 0xfb, 0xa8, 0xaa, 0xea, 0x67,
+   0xe8, 0x07, 0x00, 0x00, 0x18, 0xff, 0xbf, 0x55, 0x2d, 0x54, 0x55, 0xad,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x5f, 0x00, 0xb0, 0x52, 0x41, 0x95, 0xaa, 0x91,
+   0x5a, 0x8c, 0xd2, 0x74, 0xcb, 0x0f, 0x00, 0x00, 0x0f, 0xff, 0xbf, 0x5a,
+   0xa5, 0xab, 0x55, 0x65, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x7c, 0x73,
+   0xa6, 0x4e, 0x79, 0x8b, 0xb2, 0x52, 0x15, 0x65, 0xee, 0x1f, 0x00, 0xe0,
+   0x81, 0x9f, 0xff, 0xaa, 0x59, 0xb4, 0xaa, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x07, 0x81, 0xbf, 0x55, 0x19, 0x52, 0x25, 0x5f, 0xa0, 0x2a, 0xaf, 0x4e,
+   0xd8, 0x3f, 0x00, 0x3c, 0x80, 0x1f, 0x7f, 0xaa, 0xaa, 0x9b, 0xaa, 0x6a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x97, 0x41, 0xf7, 0x15, 0x46, 0xad, 0xae, 0x14,
+   0x56, 0xa5, 0x54, 0x4d, 0xe5, 0xff, 0xc0, 0x07, 0x98, 0x3f, 0x7c, 0x55,
+   0xb5, 0x54, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x78, 0xbd, 0xda,
+   0x41, 0x14, 0xa2, 0xf2, 0xdb, 0x54, 0x16, 0x5c, 0xb4, 0xff, 0xff, 0x01,
+   0x1e, 0x3f, 0xf8, 0xbd, 0xaa, 0x56, 0x55, 0x2d, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x4f, 0xbd, 0x17, 0x20, 0xce, 0xca, 0x9d, 0x8a, 0x44, 0x32, 0xe9, 0xb6,
+   0xc9, 0x3f, 0x3f, 0x80, 0x0f, 0x7f, 0xf8, 0xa5, 0x55, 0xb9, 0xaa, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0x43, 0xaf, 0xb3, 0x54, 0x21, 0x6c, 0x84, 0x4a,
+   0x76, 0xad, 0xaa, 0x9c, 0xe9, 0x7b, 0x00, 0xe0, 0x01, 0xff, 0xf9, 0xab,
+   0x6a, 0x8b, 0x6a, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbb, 0xd9, 0x32, 0xe7,
+   0x8e, 0x8a, 0xd2, 0x9d, 0xa6, 0x22, 0xd5, 0x54, 0xd2, 0xf3, 0x00, 0xf8,
+   0x00, 0xfe, 0xff, 0xb5, 0x5a, 0x75, 0x55, 0xad, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f,
+   0xbe, 0x7c, 0xb5, 0x32, 0x2c, 0x5c, 0xd4, 0xa4, 0x34, 0xad, 0xe9, 0x1e,
+   0xe9, 0xf3, 0x03, 0x3f, 0x00, 0xfe, 0xff, 0xab, 0xaa, 0x55, 0x5d, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0x25, 0x9c, 0x6a, 0x67, 0xd1, 0x43, 0x6a, 0xb6,
+   0x2a, 0x25, 0x56, 0xf2, 0xeb, 0xe1, 0xff, 0x1f, 0x00, 0xfc, 0xff, 0x57,
+   0xab, 0x56, 0xab, 0xab, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xf7, 0x0f, 0x29, 0xba,
+   0x12, 0xbb, 0x79, 0x2b, 0xb5, 0xaa, 0x33, 0x47, 0xfa, 0xc1, 0xff, 0x0f,
+   0x00, 0xf8, 0xff, 0xd7, 0xda, 0xaa, 0x6a, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f,
+   0xff, 0x3b, 0x1b, 0xd9, 0x4e, 0x20, 0xd9, 0x1a, 0xa5, 0xaa, 0x34, 0xa5,
+   0xfa, 0xc1, 0xff, 0x03, 0x00, 0xf8, 0xff, 0x5f, 0x6b, 0xb5, 0x5d, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xbf, 0xad, 0x05, 0x99, 0xa9, 0x2a, 0xbb, 0x0a, 0xc8,
+   0x6a, 0x55, 0x17, 0x17, 0xfa, 0x80, 0xff, 0x01, 0x00, 0xf0, 0xff, 0xbf,
+   0xaa, 0xad, 0xaa, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x77, 0x4e, 0x3e, 0x6d, 0x4a,
+   0xa6, 0x15, 0xf5, 0x29, 0x29, 0xa5, 0x74, 0xa7, 0xfe, 0x00, 0xff, 0x00,
+   0x00, 0xf0, 0xff, 0x5f, 0xb5, 0x56, 0x6b, 0x55, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xce,
+   0x27, 0x2d, 0x2c, 0x5d, 0x21, 0x8d, 0x2d, 0x45, 0xab, 0x54, 0x97, 0x6b,
+   0x7d, 0x00, 0x1e, 0x00, 0x00, 0xe0, 0xff, 0x7f, 0xab, 0x5a, 0xad, 0xb5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xfb, 0xb5, 0xe6, 0x46, 0x8f, 0x56, 0x59, 0xe3, 0x56,
+   0x55, 0xa9, 0x2a, 0x53, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x7f,
+   0x6a, 0xd7, 0x6a, 0xad, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xfe, 0x38, 0x2b, 0xd1, 0x4d,
+   0x52, 0x55, 0x54, 0x56, 0x69, 0xad, 0xca, 0x89, 0x3f, 0x00, 0x00, 0x00,
+   0x00, 0xc0, 0xff, 0x7f, 0x5b, 0x59, 0xab, 0x56, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
+   0xa6, 0x12, 0x2f, 0xf2, 0x09, 0xc0, 0x40, 0xa9, 0x2e, 0x54, 0x8d, 0xea,
+   0x3f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x7f, 0x6d, 0xd7, 0x5a, 0xa9,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xef, 0xbf, 0xd6, 0x2a, 0x43, 0x6c, 0x29, 0x52, 0x3d, 0x88,
+   0x92, 0x56, 0xd5, 0xa6, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
+   0xaa, 0xd5, 0xaa, 0xad, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 0x37, 0x06, 0xe9, 0x25,
+   0x00, 0xa0, 0x14, 0xa0, 0x5a, 0xa9, 0xca, 0xd4, 0x1f, 0x00, 0x00, 0x00,
+   0x00, 0x80, 0xff, 0xff, 0x55, 0x35, 0xab, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xdf,
+   0x59, 0xc3, 0x2e, 0x36, 0x1e, 0x91, 0x51, 0x50, 0x15, 0x55, 0xc5, 0xea,
+   0x0f, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x2f, 0xd5, 0x56, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xab, 0x21, 0x40, 0x51, 0xa2, 0x8a, 0x80, 0xdd, 0xa5,
+   0xae, 0xac, 0xc6, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff,
+   0xd7, 0xad, 0xaa, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xe4, 0xba, 0x42, 0x65, 0xb5,
+   0x8e, 0xc8, 0xed, 0x70, 0x4b, 0xb5, 0xc6, 0xfa, 0x0f, 0x00, 0x00, 0x00,
+   0x00, 0x80, 0xbf, 0xff, 0xbf, 0x56, 0xd5, 0xb6, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2f, 0x53,
+   0x05, 0x48, 0xa9, 0xb0, 0x56, 0x67, 0x6f, 0xaa, 0xa9, 0x45, 0xed, 0xfc,
+   0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xbf, 0xaa, 0xb5, 0xaa,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xdf, 0xbb, 0x9a, 0x3c, 0x04, 0xf4, 0x99, 0x6b, 0xf0, 0x7f, 0xa9,
+   0xac, 0x54, 0x65, 0xfe, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe,
+   0x5f, 0xab, 0xaa, 0xb5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0xda, 0x3f, 0xb0, 0x79, 0x48,
+   0x17, 0xb8, 0xbf, 0xaa, 0x66, 0xab, 0xe6, 0xfe, 0x1f, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xfe, 0xfd, 0xbf, 0x55, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x6f, 0x5f,
+   0xee, 0x1a, 0x1d, 0xc4, 0xfc, 0xff, 0xab, 0x29, 0xad, 0xa9, 0xf2, 0xff,
+   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfb, 0x7f, 0x55, 0x55, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xfe, 0x8b, 0x6e, 0x77, 0x20, 0x1e, 0xc6, 0xf6, 0xd9, 0xaa, 0xa6,
+   0xad, 0x6a, 0xa7, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xf3,
+   0xff, 0xea, 0xbd, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x2b, 0x97, 0x2b, 0x5e, 0x6f, 0xe0,
+   0x3e, 0x5d, 0x45, 0x4a, 0x56, 0x6d, 0xc5, 0xef, 0x07, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xf8, 0xf7, 0xff, 0x8a, 0xa8, 0xad, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0x6d, 0xeb,
+   0x23, 0x50, 0x42, 0xf3, 0xd7, 0x96, 0x56, 0xa9, 0xb4, 0x52, 0xaa, 0xf7,
+   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xe7, 0xff, 0x6a, 0x57, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xbf, 0x67, 0x9b, 0xe5, 0x91, 0xad, 0x87, 0x78, 0xa1, 0xa2, 0x72, 0x25,
+   0xad, 0x2a, 0xcb, 0xf7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xef,
+   0xff, 0x2b, 0xa9, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0x77, 0x7b, 0x4d, 0xe1, 0x49, 0xfb,
+   0xaf, 0xde, 0xa4, 0x0a, 0x55, 0x95, 0xb5, 0xfb, 0x03, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xf0, 0xcf, 0xff, 0xd5, 0xaa, 0x5a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbb, 0xe8, 0xb9,
+   0x4c, 0x6d, 0xe4, 0xbd, 0xd2, 0xe2, 0x96, 0xa3, 0x5a, 0xd5, 0xd4, 0xff,
+   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xdf, 0xff, 0xd7, 0xaa, 0xad,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x5f, 0x4b, 0xe7, 0x8d, 0x8f, 0x79, 0xf2, 0xaf, 0x2a, 0x29, 0xaa, 0x13,
+   0x4f, 0xa5, 0xea, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x9f,
+   0xff, 0x2b, 0xad, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xf7, 0xfd, 0x72, 0xe4, 0x05, 0x7c, 0xf6, 0x55,
+   0x55, 0xad, 0xb3, 0x48, 0x61, 0x6d, 0xf5, 0xff, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xe0, 0x9f, 0xff, 0xb7, 0xaa, 0x6a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x97, 0xff, 0x74,
+   0xca, 0x6e, 0x76, 0xad, 0xaa, 0xaa, 0x6a, 0xb2, 0x5c, 0x59, 0xe9, 0xff,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0xff, 0x57, 0xab, 0xad,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
+   0xd9, 0xd5, 0x7e, 0x0c, 0x6e, 0xff, 0x07, 0xb0, 0xaa, 0x54, 0x29, 0x53,
+   0xa5, 0x4a, 0xea, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f,
+   0xff, 0x5f, 0xa9, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x6e, 0x3b, 0x90, 0xb5, 0xeb, 0x67, 0x54,
+   0x5d, 0x55, 0x6d, 0xd5, 0x5a, 0xa9, 0xfa, 0x7f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xc0, 0x3f, 0xff, 0x57, 0xdb, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x6f, 0xe7, 0xdf, 0xc9,
+   0xd9, 0x79, 0x7b, 0x56, 0x4a, 0x95, 0xaa, 0x14, 0x2a, 0x55, 0xf5, 0x3f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x7f, 0xfe, 0xdf, 0xaa, 0xd6,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
+   0xb7, 0x9d, 0xfb, 0xc4, 0xdc, 0x7f, 0x7f, 0xaa, 0xaa, 0x6a, 0x25, 0x6d,
+   0xab, 0x4a, 0xfa, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f,
+   0xfe, 0xbf, 0xda, 0x5a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xf7, 0xdd, 0xef, 0xff, 0x74, 0xde, 0xfb, 0x5f, 0xaa,
+   0xaa, 0x56, 0x99, 0xaa, 0xaa, 0xaa, 0xfa, 0x3f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x80, 0x7f, 0xfe, 0x5f, 0x55, 0x6b, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xcf, 0xea, 0x6e, 0x66,
+   0xff, 0xbb, 0x3f, 0x54, 0xad, 0xaa, 0x1a, 0x4d, 0xa5, 0x54, 0xfd, 0x1f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xfe, 0xbf, 0x6d, 0xad,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xed,
+   0xe7, 0xbf, 0x3f, 0xdb, 0xf7, 0xea, 0x0b, 0xa9, 0xaa, 0xaa, 0x5d, 0x75,
+   0xad, 0x52, 0xfd, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
+   0xfe, 0xdf, 0x56, 0xab, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xbf, 0x7f, 0x5f, 0xed, 0x1f, 0x8a, 0x3e, 0xbf, 0xce, 0xab,
+   0x56, 0xb5, 0x4c, 0x95, 0x4a, 0x95, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x80, 0xff, 0xfc, 0x7f, 0xb5, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb7, 0xe5, 0xe6, 0x0b, 0xf3,
+   0xbf, 0xbe, 0x7f, 0xa9, 0xaa, 0xaa, 0x4e, 0x6b, 0x53, 0x52, 0xdf, 0x1f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xfc, 0xbf, 0xd6, 0x56,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef,
+   0x5d, 0xf3, 0x07, 0xfa, 0x5b, 0x47, 0x57, 0xad, 0x5a, 0x75, 0x4a, 0x55,
+   0x49, 0xa9, 0xde, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
+   0xfc, 0x7f, 0x6b, 0xb5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xef, 0x7a, 0x4b, 0x7b, 0x01, 0xfd, 0x4d, 0xf2, 0x53, 0x55,
+   0x57, 0x57, 0x61, 0x5b, 0xad, 0xac, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xff, 0xfc, 0xbf, 0xb5, 0x96, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfd, 0x01, 0xdb,
+   0xae, 0xe5, 0x4a, 0x55, 0x55, 0xb5, 0xaf, 0xa5, 0xaa, 0x22, 0xdf, 0x0f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0xff, 0x5a, 0xfb,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7d, 0x6f,
+   0xf5, 0xbd, 0x40, 0xfc, 0x65, 0x35, 0x35, 0xcd, 0xaa, 0xd5, 0xa5, 0xba,
+   0x4a, 0xaa, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
+   0xfc, 0x7f, 0x4d, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xef, 0xbf, 0x57, 0xf6, 0x41, 0x57, 0x91, 0xca, 0x4a, 0xb5,
+   0x56, 0x55, 0xaa, 0xcd, 0x5a, 0xd5, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xff, 0xfc, 0xff, 0x5a, 0xb7, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xcf, 0x3e, 0x7f, 0x00, 0x60,
+   0x57, 0x6b, 0x75, 0x55, 0xb5, 0xcb, 0xba, 0xd5, 0x2a, 0xc9, 0xdf, 0x0f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x7f, 0xeb, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe6,
+   0x9f, 0x7f, 0x00, 0x68, 0x55, 0x54, 0x95, 0x5a, 0x55, 0xaa, 0x4a, 0x75,
+   0x53, 0xd5, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
+   0xfe, 0xff, 0xad, 0x6a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x7f, 0xef, 0x73, 0xc7, 0xb7, 0xd0, 0x5c, 0xdd, 0xa5, 0xaa, 0x6d,
+   0xaa, 0x6a, 0xea, 0x56, 0x55, 0xf5, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x7f, 0xfe, 0x7f, 0xb5, 0xbe, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfd, 0xed, 0xc7, 0x7d, 0x83, 0x8b,
+   0x2e, 0xd5, 0xaa, 0x2a, 0xb5, 0x5a, 0x5d, 0xdb, 0x56, 0xf5, 0x9f, 0x0f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x7f, 0xdb, 0xa5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xff,
+   0xe3, 0x7f, 0x47, 0xd9, 0xa6, 0x6a, 0xab, 0xd6, 0xaa, 0x2a, 0x55, 0x55,
+   0xaa, 0xe4, 0xbf, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
+   0xff, 0x7f, 0xad, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x37, 0xec, 0xff, 0xf2, 0xbf, 0x83, 0x96, 0x53, 0xa9, 0xaa, 0x55,
+   0xad, 0x56, 0xad, 0xd5, 0x55, 0xeb, 0x3f, 0x0f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x0e, 0xfc, 0x7f, 0x6b, 0xad, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x3e, 0x6d, 0xfb, 0xce, 0xe1, 0x52,
+   0x59, 0xad, 0xaa, 0x9a, 0xaa, 0x5a, 0x6b, 0x5d, 0xaa, 0xea, 0x3f, 0x0f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf1, 0x7f, 0x5d, 0xeb,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5b, 0x3f, 0xfb,
+   0xff, 0xf3, 0x51, 0xcd, 0x56, 0x55, 0xd5, 0x6a, 0xb5, 0x56, 0xb5, 0x56,
+   0xab, 0xea, 0x7f, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
+   0xe7, 0xff, 0xd6, 0x5a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x4f, 0xcf, 0xcf, 0xdd, 0xe7, 0x58, 0x62, 0x52, 0xd5, 0xb6, 0x96,
+   0xaa, 0x55, 0xad, 0x69, 0x55, 0xfb, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x6b, 0x6b, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0x8b, 0xef, 0xc7, 0x7f, 0x21, 0xc4, 0x96,
+   0xad, 0xaa, 0xaa, 0x6a, 0xad, 0xaa, 0x56, 0xaf, 0x31, 0xf5, 0xff, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x7f, 0xb5, 0xb5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xfb, 0xf3,
+   0xdd, 0x61, 0xee, 0xd4, 0x56, 0x6d, 0xd5, 0x2a, 0xb5, 0xd6, 0xda, 0xaa,
+   0x9c, 0x75, 0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
+   0xff, 0xff, 0xae, 0xae, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xe3, 0xab, 0x7b, 0x7f, 0x20, 0xfa, 0x41, 0xd5, 0x52, 0x55, 0xd5,
+   0x56, 0x55, 0x6b, 0x55, 0x6b, 0x15, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x80, 0xff, 0xff, 0xbf, 0xf5, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xbf, 0xe1, 0xf6, 0xff, 0x4f, 0x20, 0xac, 0xb4,
+   0xaa, 0xb6, 0x6d, 0x55, 0x55, 0xab, 0xad, 0xad, 0x34, 0x15, 0xc0, 0x07,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xbf, 0x56, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x63, 0xfb, 0xda,
+   0x37, 0x40, 0x2a, 0xab, 0xb5, 0x5a, 0xb5, 0x55, 0xb5, 0x6a, 0x55, 0x55,
+   0xab, 0x15, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0xff,
+   0xff, 0x4f, 0xdb, 0x6e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xef, 0xf3, 0xfc, 0xff, 0x11, 0x52, 0x55, 0x69, 0xad, 0xaa, 0x96, 0xaa,
+   0xd6, 0xaa, 0x76, 0x5d, 0x55, 0x0d, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x0c, 0xff, 0xff, 0x87, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0xf3, 0x7e, 0xff, 0x19, 0xd2, 0xd1, 0xb5,
+   0x55, 0x55, 0xab, 0xaa, 0xaa, 0xb5, 0x55, 0x53, 0xb5, 0x0a, 0x00, 0x7e,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xff, 0x87, 0xfa, 0xed,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0x38, 0xff, 0xef,
+   0x9e, 0xad, 0xd4, 0x54, 0xd5, 0x76, 0x6d, 0x55, 0x75, 0xd5, 0x56, 0x6d,
+   0x95, 0x0d, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe,
+   0xff, 0x83, 0x2f, 0x35, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x5f, 0xdc, 0xbf, 0xff, 0x01, 0x42, 0xae, 0x5b, 0x6d, 0x55, 0xab, 0x52,
+   0x55, 0xb5, 0xda, 0x96, 0xca, 0x0e, 0x00, 0xf8, 0x01, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x06, 0xfe, 0xff, 0x81, 0xd5, 0xda, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x3d, 0xfe, 0xfb, 0x7b, 0x4d, 0x03, 0xb5, 0xd2,
+   0x55, 0xab, 0x55, 0x55, 0xad, 0xda, 0x56, 0xb3, 0x5a, 0x0d, 0x00, 0xf8,
+   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xfc, 0xff, 0x80, 0x6d, 0xd7,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xe8, 0xdf, 0xef,
+   0xa7, 0x9d, 0xd4, 0x6d, 0xaa, 0xda, 0xaa, 0xaa, 0xd5, 0x56, 0xab, 0xdc,
+   0xd6, 0x0e, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf8,
+   0x7f, 0x80, 0xb6, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x8e, 0xfd, 0xfe, 0xff, 0xd1, 0xdd, 0x75, 0x55, 0xd9, 0x6a, 0x6d, 0x55,
+   0x6d, 0x75, 0xb5, 0xa5, 0xab, 0x07, 0x00, 0xe0, 0x1f, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x06, 0xf0, 0x1f, 0x80, 0xdb, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x4f, 0xf6, 0xff, 0x7d, 0x28, 0xb7, 0x2a, 0xb5,
+   0x6a, 0xad, 0xaa, 0x5a, 0xb5, 0x56, 0xab, 0xba, 0xea, 0x07, 0x00, 0xe0,
+   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xe0, 0x07, 0x80, 0xb5, 0xae,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x23, 0x7e, 0xef, 0x5f,
+   0x38, 0x57, 0x5a, 0x93, 0x56, 0xad, 0xad, 0xaa, 0x5d, 0xab, 0xba, 0xca,
+   0xff, 0x03, 0x00, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
+   0x00, 0x80, 0xdf, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xb2, 0xff, 0xff, 0xfe, 0xe8, 0xb5, 0xca, 0xea, 0xda, 0xb6, 0x6a, 0xad,
+   0x56, 0x75, 0x4b, 0xf5, 0x78, 0x00, 0x00, 0x80, 0xff, 0x01, 0x00, 0x00,
+   0x00, 0x00, 0x06, 0x00, 0x00, 0x80, 0x6b, 0x5f, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xdf, 0xff, 0x53, 0xf7, 0x6f, 0x6a, 0xad, 0xaa, 0xaa,
+   0x6a, 0xd5, 0x56, 0xab, 0xda, 0xae, 0x6a, 0x3d, 0x00, 0x00, 0x00, 0x80,
+   0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x80, 0xb7, 0x6a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8b, 0x7f, 0x3f,
+   0xd3, 0x5a, 0x67, 0x5b, 0x55, 0x55, 0x55, 0x55, 0x57, 0x55, 0x5d, 0x35,
+   0x00, 0x00, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
+   0x00, 0x80, 0xdf, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7,
+   0x6d, 0xc3, 0xff, 0xd3, 0x51, 0xad, 0xba, 0xaa, 0xb6, 0xb6, 0xb6, 0xd5,
+   0xb5, 0xd5, 0x66, 0x35, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0x00, 0x00,
+   0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xd7, 0xd6, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xbf, 0xff, 0xe1, 0xb7, 0xc0, 0xaa, 0xb6, 0x4b, 0xd5,
+   0xda, 0x5a, 0xab, 0xb6, 0xd6, 0xb6, 0xba, 0x3a, 0x00, 0x00, 0x00, 0x00,
+   0xfe, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x7f, 0x75,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0x97, 0xf0, 0xfe, 0x71,
+   0x5c, 0xab, 0x59, 0x5b, 0x55, 0xad, 0xb5, 0xaa, 0x75, 0xb5, 0x56, 0x7b,
+   0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00,
+   0x00, 0x00, 0x7e, 0xb7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf,
+   0x8e, 0xfa, 0xff, 0x32, 0xd6, 0xda, 0x6a, 0x55, 0x5d, 0xd5, 0x5a, 0x5b,
+   0x5b, 0xab, 0x59, 0x7d, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00,
+   0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xfe, 0xad, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xfa, 0x0f, 0xbd, 0x37, 0x9d, 0xd6, 0xd6, 0x5a, 0xad,
+   0xd5, 0xb6, 0xee, 0xea, 0x6d, 0x55, 0xad, 0x75, 0x00, 0x00, 0x00, 0x00,
+   0xf8, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf8, 0xb5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcd, 0x4b, 0xff, 0x1e, 0x95,
+   0x2d, 0xab, 0x66, 0x55, 0xad, 0xaa, 0x55, 0xad, 0xb6, 0xba, 0xd5, 0xea,
+   0x00, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x40, 0x0e, 0x00,
+   0x00, 0x00, 0x80, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xee,
+   0xe7, 0xdf, 0x07, 0x77, 0x75, 0x75, 0x2f, 0xd5, 0xd6, 0x5a, 0xb5, 0xb6,
+   0x55, 0xd5, 0x56, 0xfb, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00,
+   0x00, 0x60, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x6e, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x77, 0xf8, 0xe3, 0x7f, 0x83, 0x4d, 0xaf, 0x55, 0xa5, 0x55,
+   0x55, 0xad, 0x5b, 0xdb, 0x7e, 0x5b, 0x6b, 0xed, 0x00, 0x00, 0x00, 0x00,
+   0xe0, 0x07, 0x00, 0x00, 0x00, 0xf0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xbc,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfe, 0xf0, 0xf6, 0x81, 0xd4,
+   0xe9, 0xb6, 0xaa, 0xd5, 0xb6, 0xb6, 0x6a, 0x55, 0x8b, 0xaa, 0xba, 0xe5,
+   0x01, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xf8, 0x0e, 0x00,
+   0x00, 0x00, 0x00, 0xd8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xdf,
+   0xfd, 0xff, 0x6d, 0xb8, 0xae, 0x6a, 0xd5, 0x56, 0xab, 0xd5, 0xad, 0xed,
+   0x76, 0x75, 0xab, 0xec, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+   0x00, 0xfc, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xb8, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x8b, 0xff, 0xff, 0x3f, 0x61, 0xad, 0x6a, 0x5d, 0x6d, 0xd5,
+   0xda, 0x6e, 0x6d, 0xb5, 0xae, 0x5e, 0xad, 0xe6, 0x01, 0x00, 0x00, 0x00,
+   0x80, 0x01, 0x00, 0x00, 0x00, 0xfe, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xdc,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xed, 0xdd, 0x76, 0x59, 0x55,
+   0xad, 0xd5, 0x96, 0x5e, 0x55, 0xb5, 0xaa, 0xae, 0xa7, 0xaa, 0x65, 0xf3,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x80, 0x7f, 0x0f, 0x00,
+   0x00, 0x00, 0x00, 0xbe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfb, 0xff,
+   0xff, 0xbf, 0x3c, 0xf5, 0x6b, 0x6d, 0x4b, 0x53, 0xdb, 0xd5, 0x6e, 0xb3,
+   0xb5, 0x76, 0x6d, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x00, 0x00,
+   0xc0, 0x7f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xdf, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xfb, 0xef, 0xfe, 0xff, 0x1e, 0x2d, 0xbd, 0x56, 0xab, 0xad,
+   0xad, 0x6e, 0xb5, 0xdd, 0x5d, 0x5b, 0x55, 0xf7, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0xe6, 0x01, 0x00, 0xf0, 0x7f, 0x0f, 0x00, 0x00, 0x00, 0xc0, 0x6f,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfd, 0xfd, 0x77, 0x57, 0xa9, 0xb6,
+   0x4d, 0x6b, 0xad, 0xaa, 0xda, 0xaa, 0x55, 0xd5, 0xa6, 0xd1, 0xdd, 0x72,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x07, 0x00, 0xff, 0x7f, 0x0f, 0x00,
+   0x00, 0x00, 0xf0, 0x6b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff,
+   0xfe, 0x7f, 0xed, 0xd5, 0xd6, 0x9a, 0x6a, 0xb5, 0x5d, 0xdb, 0xde, 0xb6,
+   0xda, 0x5e, 0xab, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0xff, 0xff,
+   0xff, 0x7f, 0x07, 0x00, 0x00, 0x00, 0xfc, 0xb6, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x77, 0xff, 0x6f, 0xbf, 0x3f, 0x35, 0x57, 0xab, 0x6d, 0xad, 0x5a,
+   0x6d, 0x6b, 0x6b, 0xdb, 0xab, 0x54, 0xd5, 0x3a, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x9c, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x00, 0x00, 0x80, 0x7f, 0xdb,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdb, 0xbf, 0xfb, 0x9b, 0xd4, 0xba,
+   0x6d, 0x52, 0x57, 0xad, 0xb5, 0x6a, 0xad, 0xb6, 0x5a, 0xb7, 0xb5, 0x3a,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x00,
+   0x00, 0xf0, 0xd7, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xde, 0xff, 0xdd,
+   0xff, 0xcf, 0xdc, 0xda, 0xea, 0x5b, 0xab, 0xaa, 0xde, 0x5d, 0xeb, 0xda,
+   0xea, 0x5a, 0xad, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0xff, 0xff,
+   0xff, 0x9f, 0x07, 0x00, 0x00, 0xfc, 0x5b, 0xdb, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xf7, 0xfe, 0xb7, 0x7f, 0x77, 0xb7, 0xae, 0x56, 0x6d, 0x55, 0x6d,
+   0xab, 0xaa, 0x5d, 0xaf, 0xad, 0xd6, 0xaa, 0xf6, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0xbc, 0xff, 0xff, 0xff, 0x9f, 0x07, 0x00, 0x00, 0xbf, 0xed, 0xb6,
+   0xff, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0xef, 0xff, 0xbb, 0x7f, 0xdb, 0x56,
+   0x7b, 0x55, 0x55, 0xab, 0xd5, 0xb6, 0xd6, 0xea, 0x6a, 0xab, 0xb6, 0xea,
+   0x07, 0x00, 0x00, 0x00, 0x00, 0xbe, 0xff, 0xff, 0xff, 0x9f, 0x0f, 0x00,
+   0x80, 0xbf, 0x6d, 0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x7f, 0xfd,
+   0xff, 0xdc, 0x6e, 0x77, 0xd5, 0x56, 0x6b, 0x6d, 0x6d, 0xdb, 0x6b, 0xb7,
+   0xb6, 0x5a, 0x55, 0xeb, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xbe, 0xff, 0xff,
+   0xff, 0xbf, 0x0f, 0x00, 0xc0, 0xd7, 0xb6, 0x6d, 0xff, 0xff, 0xff, 0xff,
+   0xef, 0xbd, 0x9f, 0xdd, 0x5d, 0xef, 0xb6, 0xdb, 0x56, 0xaa, 0x5a, 0xb5,
+   0xb6, 0x55, 0xbd, 0xb5, 0xaa, 0xad, 0x6d, 0xad, 0xfe, 0x0f, 0x00, 0x00,
+   0x00, 0xde, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xf0, 0xdf, 0xb6, 0x6d,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xab, 0xfe, 0x7f, 0x56, 0xab, 0xae,
+   0xfa, 0x56, 0xab, 0x56, 0xd5, 0xda, 0xd5, 0xde, 0xdd, 0x56, 0x55, 0x6b,
+   0xd5, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00,
+   0xf8, 0x6b, 0xdb, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xbb, 0xdf, 0x3f, 0x3f,
+   0xbd, 0xb7, 0xb5, 0xab, 0x57, 0x55, 0xd5, 0xea, 0xb6, 0x6a, 0x6d, 0x6b,
+   0xd5, 0xaa, 0xb6, 0xb5, 0x5a, 0xfd, 0x1f, 0x00, 0x00, 0xff, 0x57, 0xf5,
+   0xb6, 0xdd, 0x1f, 0x00, 0xfc, 0xb5, 0xd5, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xde, 0xbf, 0x9e, 0x3f, 0xef, 0x7d, 0xed, 0xd6, 0x5a, 0xb5, 0xaa, 0xae,
+   0x6d, 0xb5, 0xb6, 0x5d, 0x6d, 0x55, 0xab, 0xaa, 0xd6, 0x96, 0xff, 0x01,
+   0x80, 0x7f, 0x55, 0x2b, 0x5b, 0xf5, 0x3f, 0x00, 0xff, 0xda, 0x76, 0xef,
+   0xff, 0xff, 0xff, 0xff, 0xee, 0xcb, 0xe7, 0xd7, 0xaf, 0xaa, 0xb6, 0x55,
+   0x6d, 0x55, 0xad, 0x6a, 0xb5, 0xdd, 0xb6, 0xd6, 0xb6, 0xb6, 0xac, 0xad,
+   0x55, 0x1b, 0xfa, 0x0f, 0xe0, 0x5f, 0x53, 0x6d, 0xe9, 0x76, 0xff, 0xe0,
+   0xdf, 0x56, 0x5b, 0x6b, 0xff, 0xff, 0xff, 0x7f, 0xef, 0xdf, 0xe7, 0xff,
+   0xef, 0xdf, 0x6d, 0xef, 0x55, 0xad, 0x6a, 0xb7, 0x56, 0x55, 0x6d, 0xbb,
+   0x59, 0xab, 0xa5, 0xb6, 0x6a, 0x6d, 0xd5, 0xff, 0xf8, 0xdb, 0xb2, 0x55,
+   0x57, 0xcd, 0xff, 0xff, 0xbf, 0xed, 0xb5, 0xb5, 0xff, 0xff, 0xff, 0xbf,
+   0x7b, 0x6f, 0xf5, 0x7e, 0x75, 0x69, 0xed, 0xb5, 0xb6, 0xd6, 0xaa, 0xd5,
+   0x5b, 0xd5, 0xb6, 0xad, 0x6e, 0xd5, 0xbe, 0xaa, 0xad, 0x35, 0x55, 0xff,
+   0xff, 0x6d, 0x59, 0xb5, 0x75, 0xb7, 0xfe, 0xff, 0xd7, 0xb6, 0xb6, 0xbd,
+   0xff, 0xff, 0xff, 0x7f, 0xff, 0xfb, 0xf5, 0xdb, 0xab, 0x56, 0x5b, 0x6b,
+   0xad, 0x52, 0xed, 0x5a, 0xb5, 0x6d, 0xdb, 0xd6, 0xaa, 0x2a, 0x57, 0xdb,
+   0xb6, 0x5a, 0xd5, 0xfd, 0xff, 0xaa, 0x52, 0x5b, 0xad, 0xda, 0xfe, 0xff,
+   0x7b, 0xdb, 0xea, 0xd6, 0xff, 0xff, 0xff, 0xaf, 0xdd, 0xbf, 0x72, 0x7f,
+   0xdb, 0xfe, 0xed, 0xba, 0x55, 0x55, 0xb5, 0xae, 0xd6, 0xaa, 0x6d, 0xbb,
+   0xae, 0x6d, 0x6d, 0x55, 0xad, 0x75, 0x5b, 0xed, 0xbf, 0xea, 0xa9, 0x69,
+   0xb7, 0x6b, 0xf5, 0xff, 0x55, 0xdb, 0x7e, 0xdb, 0xff, 0xff, 0xff, 0x3b,
+   0xfe, 0xf6, 0xf1, 0xd7, 0xbe, 0x55, 0xbb, 0xae, 0x6a, 0xd7, 0xaa, 0x6a,
+   0x5b, 0x75, 0xab, 0x55, 0x7b, 0x55, 0x55, 0xb7, 0x55, 0xb3, 0xaa, 0xd6,
+   0x5a, 0x55, 0xa5, 0xb6, 0xd5, 0x5a, 0xb5, 0xdb, 0xba, 0x6d, 0xab, 0xb6,
+   0xff, 0xff, 0xff, 0x8f, 0xef, 0xff, 0xb8, 0xfa, 0xdf, 0xd5, 0xde, 0xb5,
+   0xad, 0xda, 0xaa, 0xab, 0x6a, 0x5b, 0x5d, 0xbd, 0x8a, 0xb6, 0xdd, 0xda,
+   0x76, 0xdb, 0xaa, 0xaa, 0xaa, 0x76, 0x55, 0x55, 0x75, 0x55, 0xd5, 0x6a,
+   0xd7, 0xb6, 0x6d, 0xdb, 0xff, 0xff, 0xff, 0xdb, 0x7f, 0xbe, 0xf1, 0x6f,
+   0xab, 0x7d, 0xab, 0x6e, 0xd7, 0x6d, 0x6b, 0xb5, 0xad, 0xaa, 0xab, 0x57,
+   0xb7, 0xaa, 0x6a, 0xab, 0xaa, 0xa2, 0xda, 0xd6, 0x56, 0x55, 0xa5, 0x6d,
+   0x5b, 0xfb, 0x6d, 0xbb, 0x5a, 0xdb, 0xb6, 0xb6, 0xff, 0xff, 0x7f, 0xcf,
+   0x36, 0xf7, 0xb8, 0x77, 0xff, 0xd6, 0xbb, 0xb5, 0x69, 0x35, 0xb5, 0x5d,
+   0x6d, 0xbb, 0xda, 0xad, 0x55, 0x6b, 0xab, 0xda, 0xb5, 0xbd, 0xaa, 0x5a,
+   0xb5, 0xea, 0xaa, 0x55, 0xad, 0x2a, 0x6a, 0xad, 0xd5, 0x6d, 0xb3, 0xdb };
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/xbm2lcd.pl linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/xbm2lcd.pl
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/xbm2lcd.pl	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/xbm2lcd.pl	2003-10-20 09:11:56.250761408 +1000
@@ -0,0 +1,6 @@
+
+$_ = join("", <>);
+
+s/(0x[0-9a-f]{2})/sprintf("0x%.2x",ord(pack("b8",unpack("B8",chr(~hex($1)&0377)))))/gei;
+
+print $_;
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/crt0.S linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/crt0.S
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/crt0.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/crt0.S	2003-10-20 09:11:56.247761864 +1000
@@ -0,0 +1,78 @@
+/*
+ *  linux/arch/m68knommu/platform/MC68VZ328/de2/zimage/crt0.S
+ *
+ *  Copyright (C) 2002 Georges Menie
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+	.title "de2/zimage/crt0.S"
+
+	.extern unzip_image
+	.extern __stack
+	.extern __text_end
+	.extern __data_start
+	.extern __data_end
+	.extern __bss_start
+	.extern __bss_end
+	.extern start_image
+
+	.text
+	.global start
+start:
+
+        /* initialize the stack */
+        move.l  #__stack,%sp
+
+	/* disable interrupts */
+	move.l	#-1,0xfffff304
+	move.b	#0,0xfffff300
+
+        /* initialize the data section */
+	lea.l	__text_end,%a0
+	lea.l	__data_start,%a1
+	lea.l	__data_end,%a2
+1:	cmpa.l  %a1,%a2
+        jbeq	2f
+	move.l	(%a0)+,(%a1)+
+	jbra	1b
+2:
+        /* initialize the bss section */
+        lea.l   __bss_start,%a0
+        lea.l   __bss_end,%a1
+1:	cmpa.l  %a0,%a1
+        jbeq	2f
+	move.l  #0,(%a0)+
+	jbra	1b
+2:
+	
+/*
+ * Unzip the kernel image
+ */
+	jsr	unzip_image
+
+/*
+ * Start the image
+ */
+	movea.l	#start_image,%a0
+	jmp	(%a0)
+
+/*
+ * Infinite loop for exit
+ */
+        .global exit
+exit:
+	bra	exit
+
+/*
+ * Define putc to send a char to the UART1
+ */
+        .global putc
+putc:
+1:	move.w	0xfffff906,%d0
+	and.w	#0x2000,%d0
+	beq	1b
+	move.b	7(%sp),0xfffff907
+	rts
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/image.ld linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/image.ld
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/image.ld	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/image.ld	2003-10-20 09:11:56.247761864 +1000
@@ -0,0 +1,98 @@
+STARTUP(crt0.o)
+OUTPUT_ARCH(m68k)
+SEARCH_DIR(.)
+GROUP(-lc -lgcc)
+__DYNAMIC  =  0;
+
+/*
+
+ To test the decompression use:
+
+   rom (rwx) : ORIGIN = 0x400000, LENGTH = 2M
+
+ download and run the compressed zImage.bin at 0x400000.
+ Depending on the build model (RAM,HIMEM,ROM) and
+ the size of the kernel (either compressed or uncompressed)
+ you might need to change this address.
+ 
+ To generate a flashable compressed image, use:
+
+   rom (rwx) : ORIGIN = <addr_in_flash>, LENGTH = <available space>
+
+ store and run the compressed image at <addr_in_flash>
+
+*/
+
+MEMORY
+{
+  ram (rwx) : ORIGIN =   0x1000, LENGTH = 64k-4k
+  rom (rwx) : ORIGIN = 0x400000, LENGTH = 2M
+}
+
+PROVIDE (__stack = 4k - 4);
+
+SECTIONS
+{
+  .text :
+  {
+    __text_start = .;
+    *(.text)
+
+    . = ALIGN(0x4);
+    *(.rodata)
+
+    . = ALIGN(0x4);
+    *(.gcc_except_table) 
+
+    . = ALIGN(0x4);
+    *(.eh_frame)
+
+    . = ALIGN(0x4);
+    *(.lit)
+
+    . = ALIGN(0x4);
+    input_data = .;
+    image.o
+    input_data_end = .;
+
+    . = ALIGN(0x4);
+    __text_end = .;
+  } > rom
+
+  .data : AT(__text_end)
+   {
+    . = ALIGN (0x4);
+    __data_start = .;
+
+    *(.shdata)
+    *(.data)
+    *(.gcc_exc)
+
+    . = ALIGN (0x4);
+    __data_end = .;
+   } > ram
+
+  .bss :
+  {
+    . = ALIGN(0x4);
+    __bss_start = . ;
+
+    *(.shbss)
+    *(.bss)
+    *(COMMON)
+
+    . = ALIGN(0x4);
+    __bss_end = .;
+    _end = .;
+  } > ram
+
+  .stab 0 (NOLOAD) :
+  {
+    *(.stab)
+  }
+
+  .stabstr 0 (NOLOAD) :
+  {
+    *(.stabstr)
+  }
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/main.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/main.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/main.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/main.c	2003-10-20 09:11:56.247761864 +1000
@@ -0,0 +1,32 @@
+
+/*
+ *  linux/arch/m68knommu/platform/MC68VZ328/de2/zimage/main.c
+ *
+ *  Copyright (C) 2002 Georges Menie
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+extern unsigned char input_data[];
+extern unsigned char input_data_end[];
+extern unsigned char output_data[];
+
+void outstring (char *s)
+{
+	extern void putc (int);
+
+	while (*s)
+		putc (*s++);
+}
+
+void unzip_image (void)
+{
+	void memgunzip (unsigned char *dst, const unsigned char *src,
+					unsigned int sz);
+
+	outstring ("Uncompressing Linux");
+	memgunzip (output_data, input_data, input_data_end - input_data);
+	outstring ("\r\nOk, booting the kernel.\r\n");
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/Makefile linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/Makefile
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/Makefile	2003-10-20 09:11:56.247761864 +1000
@@ -0,0 +1,46 @@
+
+# Runtime parameters
+UNZIP_ADDRESS := $(shell [ -f $(ROOTDIR)/$(LINUXDIR)/System.map ] && grep ' _stext$$' $(ROOTDIR)/$(LINUXDIR)/System.map | cut -d' ' -f1)
+START_ADDRESS := $(shell [ -f $(ROOTDIR)/$(LINUXDIR)/System.map ] && grep ' _start$$' $(ROOTDIR)/$(LINUXDIR)/System.map | cut -d' ' -f1)
+
+# Compiler and associated tools filenames.
+CC = $(CROSS_COMPILE)gcc
+LD = $(CROSS_COMPILE)ld
+OBJCOPY = $(CROSS_COMPILE)objcopy
+
+# Flags.
+AFLAGS = -m68000 -Wall -I$(ROOTDIR)/$(LINUXDIR)/include
+CFLAGS = -m68000 -Wall -O2 --omit-frame-pointer -I$(ROOTDIR)/$(LINUXDIR)/include
+LFLAGS = -m68000 -nostdlib -Wl,-Map=$(basename $@).map
+
+#
+# Targets
+#
+
+OBJECTS = \
+	main.o \
+	misc.o
+
+all: $(IMAGEDIR)/zImage.bin
+
+crt0.o: crt0.S
+	$(CC) $(AFLAGS) -o $@ -c $+
+
+image.o: $(IMAGEDIR)/image.bin
+	tmpimage=_tmp_$$$$image; \
+	cat $+ | gzip -f -9 > $$tmpimage; \
+	$(LD) -r -o $@ -b binary $$tmpimage; \
+	rm -f $$tmpimage
+
+$(IMAGEDIR)/zImage.bin: crt0.o image.o ${OBJECTS}
+	tmpprog=_tmp_$$$$prog; \
+	tmplnk=_tmp_$$$$lnk; \
+	cp image.ld $$tmplnk; \
+	echo "PROVIDE (output_data = 0x$(UNZIP_ADDRESS));" >> $$tmplnk; \
+	echo "PROVIDE (start_image = 0x$(START_ADDRESS));" >> $$tmplnk; \
+	$(CC) $(LFLAGS) -T $$tmplnk -o $$tmpprog ${OBJECTS}; \
+	$(OBJCOPY) -O binary -j .text -j .data $$tmpprog $@; \
+	rm -f $$tmpprog $$tmplnk
+
+clean:
+	rm -f *.o _tmp_*
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/misc.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/misc.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/de2/zimage/misc.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/misc.c	2003-10-20 09:11:56.248761712 +1000
@@ -0,0 +1,151 @@
+
+/*
+ *  linux/arch/m68knommu/platform/MC68VZ328/de2/zimage/misc.c
+ *
+ *  Copyright (C) 2002 Georges Menie
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * gunzip wrapper based on :
+ *
+ * arch/sh/boot/compressed/misc.c
+ * 
+ * This is a collection of several routines from gzip-1.0.3 
+ * adapted for Linux.
+ *
+ * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
+ *
+ * Adapted for SH by Stuart Menefy, Aug 1999
+ *
+ * Modified to use standard LinuxSH BIOS by Greg Banks 7Jul2000
+ */
+
+/*
+ * gzip declarations
+ */
+
+#define NULL 0
+
+#define OF(args)  args
+#define STATIC static
+
+#define memzero(s, n)     memset ((s), 0, (n))
+
+void outstring (const char *);
+void exit (int);
+
+typedef unsigned char uch;
+typedef unsigned short ush;
+typedef unsigned long ulg;
+
+#define WSIZE 0x8000			/* Window size must be at least 32k, */
+								/* and a power of two */
+
+static uch window[WSIZE];		/* Sliding window buffer */
+
+static ulg inptr = 0;			/* index of next byte to be processed in inbuf */
+static ulg outcnt = 0;			/* bytes in output buffer */
+static ulg bytes_out = 0;
+
+/* Diagnostic functions */
+#define Assert(cond,msg)
+#define Trace(x)
+#define Tracev(x)
+#define Tracevv(x)
+#define Tracec(c,x)
+#define Tracecv(c,x)
+
+static void flush_window (void);
+static void *malloc (int size);
+static void free (void *where);
+static void error (char *m);
+static void gzip_mark (void **);
+static void gzip_release (void **);
+
+static const unsigned char *data_in;
+static unsigned char *data_out;
+static unsigned int data_in_len;
+
+#define get_byte() ((inptr < data_in_len)?data_in[inptr++]:(error("ran out of input data\n"),0))
+#define put_byte(c) *data_out++ = c
+
+#include "../../../../../../lib/inflate.c"
+
+#define HEAPSIZE (24*1024)
+static unsigned char heap[HEAPSIZE];
+static unsigned char *free_mem_ptr = heap;
+
+static void *malloc (int size)
+{
+	void *p;
+
+	if (size < 0)
+		error ("Malloc error\n");
+	if (free_mem_ptr == 0)
+		error ("Memory error\n");
+
+	free_mem_ptr = (unsigned char *) (((unsigned long) free_mem_ptr + 3) & ~3);	/* Align */
+
+	p = free_mem_ptr;
+	free_mem_ptr += size;
+
+	if (free_mem_ptr >= &heap[HEAPSIZE])
+		error ("\nOut of memory\n");
+
+	return p;
+}
+
+static void free (void *where)
+{								/* Don't care */
+}
+
+static void gzip_mark (void **ptr)
+{
+	*ptr = free_mem_ptr;
+}
+
+static void gzip_release (void **ptr)
+{
+	free_mem_ptr = *ptr;
+}
+
+/* ===========================================================================
+ * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+ * (Used for the decompressed data only.)
+ */
+static void flush_window (void)
+{
+	ulg c = crc;				/* temporary variable */
+	unsigned n;
+	uch *in, ch;
+
+	in = window;
+	for (n = 0; n < outcnt; n++) {
+		ch = *in++;
+		put_byte (ch);
+		c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
+	}
+	crc = c;
+	bytes_out += outcnt;
+	outcnt = 0;
+	outstring (".");
+}
+
+static void error (char *x)
+{
+	outstring ("\r\n\r\n");
+	outstring (x);
+	outstring ("\r\n\r\n -- System halted\r\n");
+	exit (1);
+}
+
+void memgunzip (unsigned char *dst, const unsigned char *src, unsigned int sz)
+{
+	data_out = dst;
+	data_in = src;
+	data_in_len = sz;
+	makecrc ();
+	gunzip ();
+}
diff -Naur linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/ucdimm/config.c linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/ucdimm/config.c
--- linux-2.6.0-test8/arch/m68knommu/platform/68VZ328/ucdimm/config.c	2003-10-20 09:10:57.662668152 +1000
+++ linux-2.6.0-test8-uc0/arch/m68knommu/platform/68VZ328/ucdimm/config.c	2003-10-20 09:11:56.251761256 +1000
@@ -99,11 +99,11 @@
 {
 	unsigned char *p;
 
-	printk("\n68VZ328 DragonBallVZ support (c) 2001 Lineo, Inc.\n");
+	printk(KERN_INFO "\n68VZ328 DragonBallVZ support (c) 2001 Lineo, Inc.\n");
 
-	printk("uCdimm serial string [%s]\n",getserialnum());
+	printk(KERN_INFO "uCdimm serial string [%s]\n",getserialnum());
 	p = cs8900a_hwaddr = gethwaddr(0);
-	printk("uCdimm hwaddr %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+	printk(KERN_INFO "uCdimm hwaddr %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
 		p[0], p[1], p[2], p[3], p[4], p[5]);
 	p = getbenv("APPEND");
 	if (p) strcpy(p,command);
diff -Naur linux-2.6.0-test8/drivers/mtd/maps/se4000.c linux-2.6.0-test8-uc0/drivers/mtd/maps/se4000.c
--- linux-2.6.0-test8/drivers/mtd/maps/se4000.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.0-test8-uc0/drivers/mtd/maps/se4000.c	2003-10-20 09:12:24.267502216 +1000
@@ -0,0 +1,141 @@
+/****************************************************************************/
+
+/*
+ *	se4000.c -- MTD map driver for SnapGear SE4000 platform
+ *
+ *	(C) Copyright 2003,  Greg Ungerer <gerg@snapgear.com>
+ */
+
+/****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+#include <linux/init.h>
+#include <linux/reboot.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+
+/****************************************************************************/
+
+static struct map_info se4000_map = {
+	.name =		"SnapGear SE4000 Flash",
+	.buswidth = 	2,
+	.phys =		0x50000000,
+	.size =		0x01000000,
+};
+
+static struct mtd_partition *parsed_parts;
+
+/****************************************************************************/
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+/*
+ * Set the Intel flash back to read mode as MTD may leave it in command mode.
+ */
+
+static int se4000_reboot_notifier(
+	struct notifier_block *nb,
+	unsigned long val,
+	void *v)
+{
+	struct cfi_private *cfi = se4000_map.fldrv_priv;
+	int i;
+	
+	for (i = 0; cfi && i < cfi->numchips; i++)
+		cfi_send_gen_cmd(0xff, 0x55, cfi->chips[i].start, &se4000_map,
+			cfi, cfi->device_type, NULL);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block se4000_notifier_block = {
+	se4000_reboot_notifier, NULL, 0
+};
+
+#endif
+
+
+/****************************************************************************/
+
+static struct mtd_info *se4000_mtd;
+static const char *probes[] = { "RedBoot", NULL };
+
+/****************************************************************************/
+
+static void se4000_exit(void)
+{
+    if (se4000_mtd) {
+	del_mtd_partitions(se4000_mtd);
+	map_destroy(se4000_mtd);
+    }
+    if (se4000_map.virt)
+	iounmap((void *)se4000_map.virt);
+  
+    if (parsed_parts)
+	kfree(parsed_parts);
+
+    /* Disable flash write */
+    *IXP425_EXP_CS0 &= ~IXP425_FLASH_WRITABLE;
+}
+
+/****************************************************************************/
+
+static int __init se4000_init(void)
+{
+    int res, npart;
+
+    /* Enable flash write */
+    *IXP425_EXP_CS0 |= IXP425_FLASH_WRITABLE;
+
+    se4000_map.virt = (unsigned long) ioremap(se4000_map.phys, se4000_map.size);
+    if (!se4000_map.virt) {
+	printk(KERN_ERR "SE4000: ioremap(%x) failed\n", (int)se4000_map.phys);
+	res = -EIO;
+	goto Error;
+    }
+
+    /* Probe for the CFI complaint chip */
+    se4000_mtd = do_map_probe("cfi_probe", &se4000_map);
+    if (!se4000_mtd) {
+	res = -ENXIO;
+	goto Error;
+    }
+    se4000_mtd->owner = THIS_MODULE;
+   
+    /* Try to parse RedBoot partitions */
+    npart = parse_mtd_partitions(se4000_mtd, probes, &parsed_parts, 0);
+    if (npart > 0) {
+	/* found "npart" RedBoot partitions */
+	res = add_mtd_partitions(se4000_mtd, parsed_parts, npart);
+    } else {
+	res = -EIO;
+    }
+
+    if (res)
+	goto Error;
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	register_reboot_notifier(&se4000_notifier_block);
+#endif
+
+    return res;
+Error:
+    se4000_exit();
+    return res;
+}
+
+/****************************************************************************/
+
+module_init(se4000_init);
+module_exit(se4000_exit);
+
+MODULE_DESCRIPTION("MTD map driver for SnapGear SE4000");
+
+/****************************************************************************/
diff -Naur linux-2.6.0-test8/drivers/mtd/maps/uclinux.c linux-2.6.0-test8-uc0/drivers/mtd/maps/uclinux.c
--- linux-2.6.0-test8/drivers/mtd/maps/uclinux.c	2003-10-20 09:10:46.000000000 +1000
+++ linux-2.6.0-test8-uc0/drivers/mtd/maps/uclinux.c	2003-10-20 09:12:24.281500088 +1000
@@ -5,7 +5,7 @@
  *
  *	(C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
  *
- * 	$Id$
+ * 	$Id$
  */
 
 /****************************************************************************/
@@ -17,6 +17,7 @@
 #include <linux/kernel.h>
 #include <linux/fs.h>
 #include <linux/major.h>
+#include <linux/root_dev.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
@@ -59,10 +60,16 @@
 	struct mtd_info *mtd;
 	struct map_info *mapp;
 	extern char _ebss;
+	unsigned long addr = (unsigned long) &_ebss;
+
+#ifdef CONFIG_PILOT
+	extern char _etext, _sdata, __init_end;
+	addr = (unsigned long) (&_etext + (&__init_end - &_sdata));
+#endif
 
 	mapp = &uclinux_ram_map;
-	mapp->phys = (unsigned long) &_ebss;
-	mapp->size = PAGE_ALIGN(*((unsigned long *)((&_ebss) + 8)));
+	mapp->phys = addr;
+	mapp->size = PAGE_ALIGN(*((unsigned long *)(addr + 8)));
 	mapp->buswidth = 4;
 
 	printk("uclinux[mtd]: RAM probe address=0x%x size=0x%x\n",
@@ -95,7 +102,6 @@
 	printk("uclinux[mtd]: set %s to be root filesystem\n",
 	     	uclinux_romfs[0].name);
 	ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, 0);
-	put_mtd_device(mtd);
 
 	return(0);
 }
diff -Naur linux-2.6.0-test8/drivers/net/fec.c linux-2.6.0-test8-uc0/drivers/net/fec.c
--- linux-2.6.0-test8/drivers/net/fec.c	2003-10-20 09:10:28.000000000 +1000
+++ linux-2.6.0-test8-uc0/drivers/net/fec.c	2003-10-20 09:12:25.475318600 +1000
@@ -18,7 +18,7 @@
  * Much better multiple PHY support by Magnus Damm.
  * Copyright (c) 2000 Ericsson Radio Systems AB.
  *
- * Support for FEC controller of ColdFire/5272.
+ * Support for FEC controller of ColdFire/5272/5282.
  * Copyrught (c) 2001-2002 Greg Ungerer (gerg@snapgear.com)
  */
 
@@ -46,7 +46,7 @@
 #include <asm/io.h>
 #include <asm/pgtable.h>
 
-#ifdef CONFIG_M5272
+#if defined(CONFIG_M5272) || defined(CONFIG_M5282)
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
 #include "fec.h"
@@ -62,13 +62,16 @@
 /*
  * Define the fixed address of the FEC hardware.
  */
-#ifdef CONFIG_M5272
+#if defined(CONFIG_M5272)
 static volatile fec_t   *fec_hwp = (volatile fec_t *) (MCF_MBAR + 0x840);
 static ushort		my_enet_addr[] = { 0x00d0, 0xcf00, 0x0072 };
+#elif defined(CONFIG_M5282)
+static volatile fec_t   *fec_hwp = (volatile fec_t *) (MCF_MBAR + 0x1000);
+static ushort		my_enet_addr[] = { 0x00d0, 0xcf00, 0x0082 };
 #else
 static volatile fec_t	*fec_hwp = &(((immap_t *)IMAP_ADDR)->im_cpm.cp_fec)
 static ushort		my_enet_addr[3];
-#endif /* CONFIG_M5272 */
+#endif
 
 /*
  * Some hardware gets it MAC address out of local flash memory.
@@ -299,6 +302,24 @@
 	bdp->cbd_bufaddr = __pa(skb->data);
 	bdp->cbd_datlen = skb->len;
 
+#ifdef CONFIG_M5282
+	/*
+	 *	The FEC on the 5282 must have its buffers alligned on
+	 *	4 byte boundaries. Bugger. Copy the skbuf contents in
+	 *	place so they start on a 4 byte boundary.
+	 */
+	if (bdp->cbd_bufaddr & 0x2) {
+		int i;
+		unsigned char *src = (unsigned char *) bdp->cbd_bufaddr;
+		unsigned char *dst = (unsigned char *) bdp->cbd_bufaddr;
+		src += bdp->cbd_datlen;
+		dst += bdp->cbd_datlen + 2;
+		for (i = bdp->cbd_datlen-1; (i >= 0); i--)
+			*--dst = *--src;
+		bdp->cbd_bufaddr = (int) dst;
+	}
+#endif
+
 	/* Save skb pointer.
 	*/
 	fep->tx_skbuff[fep->skb_cur] = skb;
@@ -407,10 +428,13 @@
 	*/
 	while ((int_events = fecp->fec_ievent) != 0) {
 		fecp->fec_ievent = int_events;
+
+#ifndef CONFIG_M5282
 		if ((int_events & (FEC_ENET_HBERR | FEC_ENET_BABR |
 				   FEC_ENET_BABT | FEC_ENET_EBERR)) != 0) {
 			printk("FEC ERROR %x\n", int_events);
 		}
+#endif
 
 		/* Handle receive event in its own function.
 		 */
@@ -1040,14 +1064,15 @@
 
 /* ------------------------------------------------------------------------- */
 
-static void
 #ifdef CONFIG_RPXCLASSIC
+static void
 mii_link_interrupt(void *dev_id);
 #else
+static irqreturn_t
 mii_link_interrupt(int irq, void * dev_id, struct pt_regs * regs);
 #endif
 
-#ifdef CONFIG_M5272
+#if defined(CONFIG_M5272)
 
 /*
  *	Code specific to Coldfire 5272 setup.
@@ -1151,6 +1176,143 @@
 
 /* ------------------------------------------------------------------------- */
 
+#elif defined(CONFIG_M5282)
+
+/*
+ *	Code specific to Coldfire 5282 setup.
+ */
+static void __inline__ fec_request_intrs(struct net_device *dev, volatile fec_t *fecp)
+{
+	/* Setup interrupt handlers. */
+	if (request_irq(64+23, fec_enet_interrupt, 0, "fec(TXF)", dev) != 0)
+		printk("FEC: Could not allocate FEC(TXF) IRQ(64+23)!\n");
+	if (request_irq(64+24, fec_enet_interrupt, 0, "fec(TXB)", dev) != 0)
+		printk("FEC: Could not allocate FEC(TXB) IRQ(64+24)!\n");
+	if (request_irq(64+25, fec_enet_interrupt, 0, "fec(TXFIFO)", dev) != 0)
+		printk("FEC: Could not allocate FEC(TXFIFO) IRQ(64+25)!\n");
+	if (request_irq(64+26, fec_enet_interrupt, 0, "fec(TXCR)", dev) != 0)
+		printk("FEC: Could not allocate FEC(TXCR) IRQ(64+26)!\n");
+
+	if (request_irq(64+27, fec_enet_interrupt, 0, "fec(RXF)", dev) != 0)
+		printk("FEC: Could not allocate FEC(RXF) IRQ(64+27)!\n");
+	if (request_irq(64+28, fec_enet_interrupt, 0, "fec(RXB)", dev) != 0)
+		printk("FEC: Could not allocate FEC(RXB) IRQ(64+28)!\n");
+
+	if (request_irq(64+29, fec_enet_interrupt, 0, "fec(MII)", dev) != 0)
+		printk("FEC: Could not allocate FEC(MII) IRQ(64+29)!\n");
+	if (request_irq(64+30, fec_enet_interrupt, 0, "fec(LC)", dev) != 0)
+		printk("FEC: Could not allocate FEC(LC) IRQ(64+30)!\n");
+	if (request_irq(64+31, fec_enet_interrupt, 0, "fec(HBERR)", dev) != 0)
+		printk("FEC: Could not allocate FEC(HBERR) IRQ(64+31)!\n");
+	if (request_irq(64+32, fec_enet_interrupt, 0, "fec(GRA)", dev) != 0)
+		printk("FEC: Could not allocate FEC(GRA) IRQ(64+32)!\n");
+	if (request_irq(64+33, fec_enet_interrupt, 0, "fec(EBERR)", dev) != 0)
+		printk("FEC: Could not allocate FEC(EBERR) IRQ(64+33)!\n");
+	if (request_irq(64+34, fec_enet_interrupt, 0, "fec(BABT)", dev) != 0)
+		printk("FEC: Could not allocate FEC(BABT) IRQ(64+34)!\n");
+	if (request_irq(64+35, fec_enet_interrupt, 0, "fec(BABR)", dev) != 0)
+		printk("FEC: Could not allocate FEC(BABR) IRQ(64+35)!\n");
+
+	/* Unmask interrupts at ColdFire 5282 interrupt controller */
+	{
+		volatile unsigned char  *icrp;
+		volatile unsigned long  *imrp;
+		int i;
+
+		icrp = (volatile unsigned char *) (MCF_IPSBAR + MCFICM_INTC0 +
+			MCFINTC_ICR0);
+		for (i = 23; (i < 36); i++)
+			icrp[i] = 0x23;
+
+		imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 +
+			MCFINTC_IMRH);
+		*imrp &= ~0x0000000f;
+		imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 +
+			MCFINTC_IMRL);
+		*imrp &= ~0xff800001;
+	}
+
+	/* Set up gpio outputs for MII lines */
+	{
+		volatile unsigned short *gpio_paspar;
+  
+		gpio_paspar = (volatile unsigned short *) (MCF_IPSBAR +
+			0x100056);
+		*gpio_paspar = 0x0f00;
+	}
+}
+
+static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
+{
+	volatile fec_t *fecp;
+	fecp = fec_hwp;
+
+	fecp->fec_r_cntrl = 0x04;
+	fecp->fec_x_cntrl = 0x00;
+
+	/* Set MII speed to 2.5 MHz
+	*/
+	fecp->fec_mii_speed = fep->phy_speed = 0x0e;
+
+	fec_restart(dev, 0);
+}
+
+static void __inline__ fec_get_mac(struct net_device *dev, struct fec_enet_private *fep)
+{
+	volatile fec_t *fecp;
+	unsigned char *eap, *iap, tmpaddr[6];
+	int i;
+
+	fecp = fec_hwp;
+	eap = (unsigned char *) my_enet_addr;
+
+	if (fec_flashmac) {
+		/*
+		 * Get MAC address from FLASH.
+		 * If it is all 1's or 0's, use the default.
+		 */
+		iap = fec_flashmac;
+		if ((iap[0] == 0) && (iap[1] == 0) && (iap[2] == 0) &&
+		    (iap[3] == 0) && (iap[4] == 0) && (iap[5] == 0))
+			iap = eap;
+		if ((iap[0] == 0xff) && (iap[1] == 0xff) && (iap[2] == 0xff) &&
+		    (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
+			iap = eap;
+	} else {
+		*((unsigned long *) &tmpaddr[0]) = fecp->fec_addr_low;
+		*((unsigned short *) &tmpaddr[4]) = (fecp->fec_addr_high >> 16);
+		iap = &tmpaddr[0];
+	}
+
+	for (i=0; i<6; i++)
+		dev->dev_addr[i] = *eap++ = *iap++;
+}
+
+static void __inline__ fec_enable_phy_intr(void)
+{
+}
+
+static void __inline__ fec_disable_phy_intr(void)
+{
+}
+
+static void __inline__ fec_phy_ack_intr(void)
+{
+}
+
+static void __inline__ fec_localhw_setup(void)
+{
+}
+
+/*
+ *	Do not need to make region uncached on 5272.
+ */
+static void __inline__ fec_uncache(unsigned long addr)
+{
+}
+
+/* ------------------------------------------------------------------------- */
+
 #else
 
 /*
@@ -1458,14 +1620,15 @@
 
 /* This interrupt occurs when the PHY detects a link change.
 */
-static void
 #ifdef CONFIG_RPXCLASSIC
+static void
 mii_link_interrupt(void *dev_id)
 #else
+static irqreturn_t
 mii_link_interrupt(int irq, void * dev_id, struct pt_regs * regs)
 #endif
 {
-	struct	net_device *dev = dev_id;
+	struct net_device *dev = dev_id;
 	struct fec_enet_private *fep = dev->priv;
 
 	fec_phy_ack_intr();
@@ -1477,6 +1640,7 @@
 	mii_do_cmd(dev, fep->phy->ack_int);
 	mii_do_cmd(dev, phy_cmd_relink);  /* restart and display status */
 
+	return IRQ_HANDLED;
 }
 
 static int
diff -Naur linux-2.6.0-test8/drivers/net/Kconfig linux-2.6.0-test8-uc0/drivers/net/Kconfig
--- linux-2.6.0-test8/drivers/net/Kconfig	2003-10-20 09:10:30.000000000 +1000
+++ linux-2.6.0-test8-uc0/drivers/net/Kconfig	2003-10-20 09:12:24.802420896 +1000
@@ -722,7 +722,7 @@
 
 config NET_VENDOR_SMC
 	bool "Western Digital/SMC cards"
-	depends on NET_ETHERNET && (ISA || MCA || EISA || MAC)
+	depends on NET_ETHERNET && (ISA || MCA || EISA || MAC || EMBEDDED)
 	help
 	  If you have a network (Ethernet) card belonging to this class, say Y
 	  and read the Ethernet-HOWTO, available from
@@ -794,7 +794,7 @@
 
 config SMC9194
 	tristate "SMC 9194 support"
-	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN)
+	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN || EMBEDDED)
 	select CRC32
 	---help---
 	  This is support for the SMC9xxx based Ethernet cards. Choose this
diff -Naur linux-2.6.0-test8/drivers/net/smc9194.c linux-2.6.0-test8-uc0/drivers/net/smc9194.c
--- linux-2.6.0-test8/drivers/net/smc9194.c	2003-10-20 09:10:30.000000000 +1000
+++ linux-2.6.0-test8-uc0/drivers/net/smc9194.c	2003-10-20 09:12:25.833264184 +1000
@@ -59,9 +59,11 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/fcntl.h>
 #include <linux/interrupt.h>
+#include <linux/ptrace.h>
 #include <linux/ioport.h>
 #include <linux/in.h>
 #include <linux/slab.h>
@@ -72,12 +74,46 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
+#include <linux/delay.h>
 
 #include <asm/bitops.h>
 #include <asm/io.h>
 
 #include "smc9194.h"
 
+#ifdef CONFIG_M68EZ328
+#include <asm/MC68EZ328.h>
+#include <asm/irq.h>
+#include <asm/mcfsmc.h>
+unsigned char	smc_defethaddr[] = { 0x00, 0x10, 0x8b, 0xf1, 0xda, 0x01 };
+#define NO_AUTOPROBE
+#endif
+
+#ifdef CONFIG_COLDFIRE
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfsmc.h>
+
+unsigned char	smc_defethaddr[] = { 0x00, 0xd0, 0xcf, 0x00, 0x00, 0x01 };
+
+#define NO_AUTOPROBE
+#endif
+
+#ifdef CONFIG_SH_KEYWEST
+#include <asm/keywest.h>
+#define NO_AUTOPROBE
+#define PHY_SETUP
+#endif
+
+#ifdef CONFIG_LEDMAN
+#include <linux/ledman.h>
+#endif
+
+#if defined(CONFIG_CPU_H8300H) || defined(CONFIG_CPU_H8S)
+#include <asm/h8300_smsc.h>
+#define NO_AUTOPROBE
+#endif
+
 /*------------------------------------------------------------------------
  .
  . Configuration options, for the experienced user to change.
@@ -88,22 +124,59 @@
  . Do you want to use 32 bit xfers?  This should work on all chips, as
  . the chipset is designed to accommodate them.
 */
-#ifdef __sh__
+#if (defined(__sh__) && !defined(CONFIG_SH_KEYWEST)) || \
+    defined(__H8300H__) || defined(__H8300S__)
 #undef USE_32_BIT
 #else
 #define USE_32_BIT 1
 #endif
 
 /*
+ .A typedef so we can change what IO looks like easily
+*/
+typedef unsigned int smcio_t;
+
+/*
  .the SMC9194 can be at any of the following port addresses.  To change,
  .for a slightly different card, you can add it to the array.  Keep in
  .mind that the array must end in zero.
 */
+
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328) || \
+	defined(CONFIG_SH_KEYWEST)
+
+#ifdef CONFIG_NETtel
+static smcio_t smc_portlist[]      = { 0x30600300, 0x30600000, 0 };
+static unsigned int smc_irqlist[]  = {         29,         27, 0 };
+#elif defined(CONFIG_SH_KEYWEST)
+static smcio_t smc_portlist[]      = { KEYWEST_ETHR, 0 };
+static unsigned int smc_irqlist[]  = { IRQ4_IRQ,     0 };
+#elif defined(CONFIG_M68EZ328)
+/* make sure that you program Port D selects to allow the interrupts! */
+static smcio_t smc_portlist[]      = { 0x2000300,    0x2000320,    0 };
+static unsigned int smc_irqlist[]  = { IRQ1_IRQ_NUM, IRQ2_IRQ_NUM, 0 };
+#elif defined(CONFIG_CLEOPATRA)
+static unsigned int smc_portlist[] = { 0x30600300, 0 };
+static unsigned int smc_irqlist[]  = {         29, 0 };
+#else
+static smcio_t smc_portlist[]      = { 0x30600300, 0 };
+static unsigned int smc_irqlist[]  = {         27, 0 };
+#endif
+
+#elif defined(CONFIG_BOARD_EDOSK2674)
+static smcio_t smc_portlist[]      = { SMSC_BASE, 0 };
+static unsigned int smc_irqlist[]  = { SMSC_IRQ, 0 };
+#else
+
 static unsigned int smc_portlist[] __initdata = { 
 	0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0,
 	0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0, 0
 };
 
+#endif
+
+static unsigned int smc_found[]    = {          0,          0, 0 };
+
 /*
  . Wait time for memory to be free.  This probably shouldn't be
  . tuned that much, as waiting for this means nothing else happens
@@ -257,7 +330,7 @@
  . Test if a given location contains a chip, trying to cause as
  . little damage as possible if it's not a SMC chip.
 */
-static int smc_probe(struct net_device *dev, int ioaddr);
+static int smc_probe(struct net_device *dev, smcio_t ioaddr);
 
 /*
  . A rather simple routine to print out a packet for debugging purposes.
@@ -278,20 +351,31 @@
 static int  smc_wait_to_send_packet( struct sk_buff * skb, struct net_device *dev );
 
 /* this does a soft reset on the device */
-static void smc_reset( int ioaddr );
+static void smc_reset( smcio_t ioaddr );
 
 /* Enable Interrupts, Receive, and Transmit */
-static void smc_enable( int ioaddr );
+static void smc_enable( smcio_t ioaddr );
 
 /* this puts the device in an inactive state */
-static void smc_shutdown( int ioaddr );
+static void smc_shutdown( smcio_t ioaddr );
 
+#ifndef NO_AUTOPROBE
 /* This routine will find the IRQ of the driver if one is not
  . specified in the input to the device.  */
-static int smc_findirq( int ioaddr );
+static int smc_findirq( smcio_t ioaddr );
+#endif
+
+#ifdef PHY_SETUP
+static void clkmdio(smcio_t ioaddr, unsigned int MGMTData);
+static unsigned PHYAccess(smcio_t ioaddr, unsigned char PHYAdd,
+				unsigned char RegAdd, unsigned char OPCode, unsigned wData);
+static unsigned char DetectPHY(smcio_t ioaddr, unsigned long *OUI,
+						unsigned char *Model, unsigned char *Revision);
+static int setup_phy(smcio_t ioaddr);
+#endif
 
 /*
- . Function: smc_reset( int ioaddr )
+ . Function: smc_reset( smcio_t ioaddr )
  . Purpose:
  .  	This sets the SMC91xx chip to its normal state, hopefully from whatever
  . 	mess that any other DOS driver has put it in.
@@ -307,7 +391,7 @@
  .	5.  clear all interrupts
  .
 */
-static void smc_reset( int ioaddr )
+static void smc_reset( smcio_t ioaddr )
 {
 	/* This resets the registers mostly to defaults, but doesn't
 	   affect EEPROM.  That seems unnecessary */
@@ -328,6 +412,10 @@
 	SMC_SELECT_BANK( 1 );
 	outw( inw( ioaddr + CONTROL ) | CTL_AUTO_RELEASE , ioaddr + CONTROL );
 
+#if defined(CONFIG_LEDMAN) && defined(CONFIG_SNAPGEAR)
+	outw( inw( ioaddr + CONTROL ) | CTL_LE_ENABLE , ioaddr + CONTROL );	
+#endif
+
 	/* Reset the MMU */
 	SMC_SELECT_BANK( 2 );
 	outw( MC_RESET, ioaddr + MMU_CMD );
@@ -336,7 +424,7 @@
 	   but this is a place where future chipsets _COULD_ break.  Be wary
  	   of issuing another MMU command right after this */
 
-	outb( 0, ioaddr + INT_MASK );
+	SMC_SET_INT( 0 );
 }
 
 /*
@@ -347,7 +435,7 @@
  .	2.  Enable the receiver
  .	3.  Enable interrupts
 */
-static void smc_enable( int ioaddr )
+static void smc_enable( smcio_t ioaddr )
 {
 	SMC_SELECT_BANK( 0 );
 	/* see the header file for options in TCR/RCR NORMAL*/
@@ -356,7 +444,7 @@
 
 	/* now, enable interrupts */
 	SMC_SELECT_BANK( 2 );
-	outb( SMC_INTERRUPT_MASK, ioaddr + INT_MASK );
+	SMC_SET_INT( SMC_INTERRUPT_MASK );
 }
 
 /*
@@ -373,16 +461,21 @@
  .	the manual says that it will wake up in response to any I/O requests
  .	in the register space.   Empirical results do not show this working.
 */
-static void smc_shutdown( int ioaddr )
+static void smc_shutdown( smcio_t ioaddr )
 {
 	/* no more interrupts for me */
 	SMC_SELECT_BANK( 2 );
-	outb( 0, ioaddr + INT_MASK );
+	SMC_SET_INT( 0 );
 
 	/* and tell the card to stay away from that nasty outside world */
 	SMC_SELECT_BANK( 0 );
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outw( RCR_CLEAR, ioaddr + RCR );
+	outw( TCR_CLEAR, ioaddr + TCR );
+#else
 	outb( RCR_CLEAR, ioaddr + RCR );
 	outb( TCR_CLEAR, ioaddr + TCR );
+#endif /* CONFIG_COLDFIRE */
 #if 0
 	/* finally, shut the chip down */
 	SMC_SELECT_BANK( 1 );
@@ -392,7 +485,7 @@
 
 
 /*
- . Function: smc_setmulticast( int ioaddr, int count, dev_mc_list * adds )
+ . Function: smc_setmulticast( smcio_t ioaddr, int count, dev_mc_list * adds )
  . Purpose:
  .    This sets the internal hardware table to filter out unwanted multicast
  .    packets before they take up memory.
@@ -409,7 +502,7 @@
 */
 
 
-static void smc_setmulticast( int ioaddr, int count, struct dev_mc_list * addrs ) {
+static void smc_setmulticast( smcio_t ioaddr, int count, struct dev_mc_list * addrs ) {
 	int			i;
 	unsigned char		multicast_table[ 8 ];
 	struct dev_mc_list	* cur_addr;
@@ -442,11 +535,18 @@
 	/* now, the table can be loaded into the chipset */
 	SMC_SELECT_BANK( 3 );
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	for ( i = 0; i < 8 ; i += 2 ) {
+		outw(((multicast_table[i+1]<<8)+(multicast_table[i])), ioaddr+MULTICAST1+i );
+	}
+#else
 	for ( i = 0; i < 8 ; i++ ) {
 		outb( multicast_table[i], ioaddr + MULTICAST1 + i );
 	}
+#endif
 }
 
+
 /*
  . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * )
  . Purpose:
@@ -466,7 +566,7 @@
 static int smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * dev )
 {
 	struct smc_local *lp 	= (struct smc_local *)dev->priv;
-	unsigned short ioaddr 	= dev->base_addr;
+	smcio_t ioaddr		= dev->base_addr;
 	word 			length;
 	unsigned short 		numPages;
 	word			time_out;
@@ -481,18 +581,18 @@
 		printk(CARDNAME": Bad Craziness - sent packet while busy.\n" );
 		return 1;
 	}
-	lp->saved_skb = skb;
 
 	length = skb->len;
 
-	if (length < ETH_ZLEN) {
+	if(length < ETH_ZLEN) {
 		skb = skb_padto(skb, ETH_ZLEN);
-		if (skb == NULL) {
+		if(skb == NULL) {
 			netif_wake_queue(dev);
 			return 0;
 		}
 		length = ETH_ZLEN;
 	}
+	lp->saved_skb = skb;
 		
 	/*
 	** The MMU wants the number of pages to be the number of 256 bytes
@@ -538,7 +638,7 @@
 		status = inb( ioaddr + INTERRUPT );
 		if ( status & IM_ALLOC_INT ) {
 			/* acknowledge the interrupt */
-			outb( IM_ALLOC_INT, ioaddr + INTERRUPT );
+			SMC_ACK_INT( IM_ALLOC_INT );
   			break;
 		}
    	} while ( -- time_out );
@@ -580,7 +680,7 @@
 	byte	 		packet_no;
 	struct sk_buff * 	skb = lp->saved_skb;
 	word			length;
-	unsigned short		ioaddr;
+	smcio_t			ioaddr;
 	byte			* buf;
 
 	ioaddr = dev->base_addr;
@@ -604,7 +704,11 @@
 	}
 
 	/* we have a packet address, so tell the card to use it */
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outw( packet_no, ioaddr + PNR_ARR );
+#else
 	outb( packet_no, ioaddr + PNR_ARR );
+#endif
 
 	/* point to the beginning of the packet */
 	outw( PTR_AUTOINC , ioaddr + POINTER );
@@ -616,14 +720,23 @@
 
 	/* send the packet length ( +6 for status, length and ctl byte )
  	   and the status word ( set to zeros ) */
+
 #ifdef USE_32_BIT
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outl(  (length +6 ) , ioaddr + DATA_1 );
+#else
 	outl(  (length +6 ) << 16 , ioaddr + DATA_1 );
+#endif
 #else
 	outw( 0, ioaddr + DATA_1 );
 	/* send the packet length ( +6 for status words, length, and ctl*/
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328) || defined(CONFIG_CPU_H8S)
+	outw( (length+6) & 0xFFFF, ioaddr + DATA_1 );
+#else
 	outb( (length+6) & 0xFF,ioaddr + DATA_1 );
 	outb( (length+6) >> 8 , ioaddr + DATA_1 );
 #endif
+#endif
 
 	/* send the actual data
 	 . I _think_ it's faster to send the longs first, and then
@@ -635,7 +748,11 @@
 #ifdef USE_32_BIT
 	if ( length & 0x2  ) {
 		outsl(ioaddr + DATA_1, buf,  length >> 2 );
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+		outwd( *((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +DATA_1);
+#else
 		outw( *((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +DATA_1);
+#endif
 	}
 	else
 		outsl(ioaddr + DATA_1, buf,  length >> 2 );
@@ -647,8 +764,12 @@
 	if ( (length & 1) == 0 ) {
 		outw( 0, ioaddr + DATA_1 );
 	} else {
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+		outw( buf[length -1 ] | (0x20 << 8), ioaddr + DATA_1);
+#else
 		outb( buf[length -1 ], ioaddr + DATA_1 );
 		outb( 0x20, ioaddr + DATA_1);
+#endif
 	}
 
 	/* enable the interrupts */
@@ -688,7 +809,12 @@
 int __init smc_init(struct net_device *dev)
 {
 	int i;
+#if defined(NO_AUTOPROBE)
 	int base_addr = dev->base_addr;
+#else
+	/*  check for special auto-probe address */
+	int base_addr = (dev && dev->base_addr != 0xffe0) ? dev->base_addr : 0;
+#endif
 
 	SET_MODULE_OWNER(dev);
 
@@ -699,9 +825,22 @@
 		return -ENXIO;
 
 	/* check every ethernet address */
-	for (i = 0; smc_portlist[i]; i++)
-		if (smc_probe(dev, smc_portlist[i]) == 0)
+	for (i = 0; smc_portlist[i]; i++) {
+#ifdef CONFIG_NETtel
+		smc_remap(smc_portlist[i]);
+#endif
+#if defined(NO_AUTOPROBE)
+		dev->irq = smc_irqlist[i];
+		if (smc_found[i])
+			continue;
+#endif
+		if (smc_probe(dev, smc_portlist[i]) == 0) {
+#if defined(NO_AUTOPROBE)
+			smc_found[i] = 1;
+#endif
 			return 0;
+		}
+	}
 
 	/* couldn't find anything */
 	return -ENODEV;
@@ -714,12 +853,20 @@
  . interrupt, so an auto-detect routine can detect it, and find the IRQ,
  ------------------------------------------------------------------------
 */
-int __init smc_findirq( int ioaddr )
+#ifndef NO_AUTOPROBE
+int __init smc_findirq( smcio_t ioaddr )
 {
 	int	timeout = 20;
 	unsigned long cookie;
 
 
+#if 0
+	/* I have to do a STI() here, because this is called from
+	   a routine that does an CLI during this process, making it
+	   rather difficult to get interrupts for auto detection */
+	sti();
+#endif
+
 	cookie = probe_irq_on();
 
 	/*
@@ -731,7 +878,7 @@
 
 	SMC_SELECT_BANK(2);
 	/* enable ALLOCation interrupts ONLY */
-	outb( IM_ALLOC_INT, ioaddr + INT_MASK );
+	SMC_SET_INT( IM_ALLOC_INT );
 
 	/*
  	 . Allocate 512 bytes of memory.  Note that the chip was just
@@ -766,14 +913,21 @@
 	SMC_DELAY();
 
 	/* and disable all interrupts again */
-	outb( 0, ioaddr + INT_MASK );
+	SMC_SET_INT( 0 );
+
+#if 0
+	/* clear hardware interrupts again, because that's how it
+	   was when I was called... */
+	cli();
+#endif
 
 	/* and return what I found */
 	return probe_irq_off(cookie);
 }
+#endif /* NO_AUTOPROBE */
 
 /*----------------------------------------------------------------------
- . Function: smc_probe( int ioaddr )
+ . Function: smc_probe( smcio_t ioaddr )
  .
  . Purpose:
  .	Tests to see if a given ioaddr points to an SMC9xxx chip.
@@ -801,11 +955,17 @@
  . o  GRAB the region
  .-----------------------------------------------------------------
 */
-static int __init smc_probe(struct net_device *dev, int ioaddr)
+static int __init smc_probe(struct net_device *dev, smcio_t ioaddr)
 {
 	int i, memory, retval;
 	static unsigned version_printed;
 	unsigned int bank;
+#if defined(CONFIG_NETtel) || defined(CONFIG_eLIA) || defined(CONFIG_DISKtel) || defined(CONFIG_CLEOPATRA)
+	static int nr = 0;
+#endif
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	unsigned char *ep;
+#endif
 
 	const char *version_string;
 	const char *if_string;
@@ -817,9 +977,18 @@
 	word memory_info_register;
 	word memory_cfg_register;
 
+#if !defined(CONFIG_COLDFIRE) && !defined(CONFIG_M68EZ328) && \
+    !defined(CONFIG_CPU_H8300H) && !defined(CONFIG_CPU_H8S)
 	/* Grab the region so that no one else tries to probe our ioports. */
 	if (!request_region(ioaddr, SMC_IO_EXTENT, dev->name))
 		return -EBUSY;
+#elif defined(CONFIG_COLDFIRE)
+	/*
+	 *	We need to put the SMC into 68k mode.
+	 *	Do a write before anything else.
+	 */
+	outw(0, ioaddr + BANK_SELECT);
+#endif
 
 	/* First, see if the high byte is 0x33 */
 	bank = inw( ioaddr + BANK_SELECT );
@@ -835,12 +1004,14 @@
 		retval = -ENODEV;
 		goto err_out;
 	}
+
 	/* well, we've already written once, so hopefully another time won't
  	   hurt.  This time, I need to switch the bank register to bank 1,
 	   so I can access the base address register */
+#if !defined(CONFIG_CPU_H8300H) && !defined(CONFIG_CPU_H8S)
 	SMC_SELECT_BANK(1);
 	base_address_register = inw( ioaddr + BASE );
-	if ( ioaddr != ( base_address_register >> 3 & 0x3E0 ) )  {
+	if ( (ioaddr & 0x3E0) != ( base_address_register >> 3 & 0x3E0 ) )  {
 		printk(CARDNAME ": IOADDR %x doesn't match configuration (%x)."
 			"Probably not a SMC chip\n",
 			ioaddr, base_address_register >> 3 & 0x3E0 );
@@ -849,6 +1020,7 @@
 		retval = -ENODEV;
 		goto err_out;
 	}
+#endif
 
 	/*  check if the revision register is something that I recognize.
 	    These might need to be added to later, as future revisions
@@ -867,13 +1039,30 @@
 	/* at this point I'll assume that the chip is an SMC9xxx.
 	   It might be prudent to check a listing of MAC addresses
 	   against the hardware address, or do some other tests. */
-
 	if (version_printed++ == 0)
 		printk("%s", version);
 
 	/* fill in some of the fields */
 	dev->base_addr = ioaddr;
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+#if defined(CONFIG_NETtel) || defined(CONFIG_eLIA) || defined(CONFIG_DISKtel) || defined(CONFIG_CLEOPATRA)
+	/*
+	 . MAC address should be in FLASH, check that it is valid.
+	 . If good use it, otherwise use the default.
+	*/
+	ep = (unsigned char *) (0xf0006000 + (nr++ * 6));
+	if ((ep[0] == 0xff) && (ep[1] == 0xff) && (ep[2] == 0xff) &&
+	    (ep[3] == 0xff) && (ep[4] == 0xff) && (ep[5] == 0xff))
+		ep = (unsigned char *) &smc_defethaddr[0];
+	else if ((ep[0] == 0) && (ep[1] == 0) && (ep[2] == 0) &&
+	    (ep[3] == 0) && (ep[4] == 0) && (ep[5] == 0))
+		ep = (unsigned char *) &smc_defethaddr[0];
+#else
+	ep = (unsigned char *) &smc_defethaddr[0];
+#endif
+#endif
+
 	/*
  	 . Get the MAC address ( bank 1, regs 4 - 9 )
 	*/
@@ -881,11 +1070,23 @@
 	for ( i = 0; i < 6; i += 2 ) {
 		word	address;
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+		dev->dev_addr[ i ] = ep[ i ];
+		dev->dev_addr[ i + 1 ] = ep[ i + 1 ];
+		address = (((word) ep[ i ]) << 8) | ep[ i + 1 ];
+		outw( address, ioaddr + ADDR0 + i);
+#else
 		address = inw( ioaddr + ADDR0 + i  );
 		dev->dev_addr[ i + 1] = address >> 8;
-		dev->dev_addr[ i ] = address & 0xFF;
+		dev->dev_addr[ i ] = address & 0xFF;	
+#endif
 	}
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	/* HACK: to support 2 ethernets when using default address! */
+	smc_defethaddr[5]++;
+#endif
+
 	/* get the memory information */
 
 	SMC_SELECT_BANK( 0 );
@@ -938,6 +1139,7 @@
 	 . what (s)he is doing.  No checking is done!!!!
  	 .
 	*/
+#ifndef NO_AUTOPROBE
 	if ( dev->irq < 2 ) {
 		int	trials;
 
@@ -955,6 +1157,13 @@
 		retval = -ENODEV;
 		goto err_out;
 	}
+#else
+	if (dev->irq == 0 ) {
+		printk(CARDNAME
+		": Autoprobing IRQs is not supported for this configuration.\n");
+		return -ENODEV;
+	}
+#endif
 
 	/* now, print out the card info, in a short format.. */
 
@@ -985,14 +1194,23 @@
 	ether_setup(dev);
 
 	/* Grab the IRQ */
-      	retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
-      	if (retval) {
+#ifdef CONFIG_COLDFIRE
+	mcf_autovector(dev->irq);
+    retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
+#elif defined(CONFIG_M68EZ328) && !defined(CONFIG_CWEZ328) && !defined(CONFIG_CWVZ328)
+	retval = request_irq(IRQ_MACHSPEC | dev->irq, &smc_interrupt,
+			IRQ_FLG_STD, dev->name, dev);
+	if (retval) panic("Unable to attach Lan91C96 intr\n");
+#else
+	retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
+#endif
+	if (retval) {
 		printk("%s: unable to get IRQ %d (irqval=%d).\n", dev->name,
 			dev->irq, retval);
 		kfree(dev->priv);
 		dev->priv = NULL;
   	  	goto err_out;
-      	}
+	}
 
 	dev->open		        = smc_open;
 	dev->stop		        = smc_close;
@@ -1002,6 +1220,9 @@
 	dev->get_stats			= smc_query_statistics;
 	dev->set_multicast_list 	= smc_set_multicast_list;
 
+#ifdef PHY_SETUP
+	setup_phy( ioaddr );
+#endif
 	return 0;
 
 err_out:
@@ -1054,7 +1275,7 @@
  */
 static int smc_open(struct net_device *dev)
 {
-	int	ioaddr = dev->base_addr;
+	smcio_t	ioaddr = dev->base_addr;
 
 	int	i;	/* used to set hw ethernet address */
 
@@ -1069,6 +1290,11 @@
 	/* Select which interface to use */
 
 	SMC_SELECT_BANK( 1 );
+#if defined(CONFIG_DISKtel) || defined(CONFIG_SH_KEYWEST)
+	/* Setup to use external PHY on smc91c110 */
+	outw( inw( ioaddr + CONFIG ) | CFG_NO_WAIT | CFG_MII_SELECT,
+		(ioaddr + CONFIG ));
+#else
 	if ( dev->if_port == 1 ) {
 		outw( inw( ioaddr + CONFIG ) & ~CFG_AUI_SELECT,
 			ioaddr + CONFIG );
@@ -1077,6 +1303,7 @@
 		outw( inw( ioaddr + CONFIG ) | CFG_AUI_SELECT,
 			ioaddr + CONFIG );
 	}
+#endif
 
 	/*
   		According to Becker, I have to set the hardware address
@@ -1093,6 +1320,18 @@
 	}
 	
 	netif_start_queue(dev);
+
+#if defined(CONFIG_LEDMAN) && defined(CONFIG_SNAPGEAR)
+	/*
+	 *	fix the link status LED's
+	 */
+	SMC_SELECT_BANK( 0 );
+	ledman_cmd((inw(ioaddr + EPH_STATUS) & ES_LINK_OK) == ES_LINK_OK ?
+			LEDMAN_CMD_ON : LEDMAN_CMD_OFF,
+			strcmp(dev->name, "eth0") ?
+					LEDMAN_LAN2_LINK : LEDMAN_LAN1_LINK);
+#endif
+
 	return 0;
 }
 
@@ -1135,19 +1374,23 @@
 static irqreturn_t smc_interrupt(int irq, void * dev_id,  struct pt_regs * regs)
 {
 	struct net_device *dev 	= dev_id;
-	int ioaddr 		= dev->base_addr;
+	smcio_t ioaddr 		= dev->base_addr;
 	struct smc_local *lp 	= (struct smc_local *)dev->priv;
 
 	byte	status;
 	word	card_stats;
 	byte	mask;
 	int	timeout;
+#ifdef CONFIG_LEDMAN
+	int tx;
+#endif
 	/* state registers */
 	word	saved_bank;
 	word	saved_pointer;
 	int handled = 0;
 
 
+
 	PRINTK3((CARDNAME": SMC interrupt started \n"));
 
 	saved_bank = inw( ioaddr + BANK_SELECT );
@@ -1157,7 +1400,7 @@
 
 	mask = inb( ioaddr + INT_MASK );
 	/* clear all interrupts */
-	outb( 0, ioaddr + INT_MASK );
+	SMC_SET_INT( 0 );
 
 
 	/* set a timeout value, so I don't stay here forever */
@@ -1170,7 +1413,9 @@
 		if (!status )
 			break;
 
-		handled = 1;
+#ifdef CONFIG_LEDMAN
+		tx = 0;
+#endif
 
 		PRINTK3((KERN_WARNING CARDNAME
 			": Handling interrupt status %x \n", status ));
@@ -1184,7 +1429,10 @@
 			PRINTK2((KERN_WARNING CARDNAME
 				": TX ERROR handled\n"));
 			smc_tx(dev);
-			outb(IM_TX_INT, ioaddr + INTERRUPT );
+			SMC_ACK_INT( IM_TX_INT );
+#ifdef CONFIG_LEDMAN
+			tx = 1;
+#endif
 		} else if (status & IM_TX_EMPTY_INT ) {
 			/* update stats */
 			SMC_SELECT_BANK( 0 );
@@ -1200,11 +1448,14 @@
 			SMC_SELECT_BANK( 2 );
 			PRINTK2((KERN_WARNING CARDNAME
 				": TX_BUFFER_EMPTY handled\n"));
-			outb( IM_TX_EMPTY_INT, ioaddr + INTERRUPT );
+			SMC_ACK_INT( IM_TX_EMPTY_INT );
 			mask &= ~IM_TX_EMPTY_INT;
 			lp->stats.tx_packets += lp->packets_waiting;
+			lp->stats.tx_bytes += lp->saved_skb->len;
 			lp->packets_waiting = 0;
-
+#ifdef CONFIG_LEDMAN
+			tx = 1;
+#endif
 		} else if (status & IM_ALLOC_INT ) {
 			PRINTK2((KERN_DEBUG CARDNAME
 				": Allocation interrupt \n"));
@@ -1220,22 +1471,50 @@
 			netif_wake_queue(dev);
 			
 			PRINTK2((CARDNAME": Handoff done successfully.\n"));
+#ifdef CONFIG_LEDMAN
+			tx = 1;
+#endif
 		} else if (status & IM_RX_OVRN_INT ) {
 			lp->stats.rx_errors++;
 			lp->stats.rx_fifo_errors++;
-			outb( IM_RX_OVRN_INT, ioaddr + INTERRUPT );
+			SMC_ACK_INT( IM_RX_OVRN_INT );
 		} else if (status & IM_EPH_INT ) {
+#if defined(CONFIG_LEDMAN) && defined(CONFIG_SNAPGEAR)
+			SMC_SELECT_BANK( 0 );
+			ledman_cmd((inw(ioaddr + EPH_STATUS) & ES_LINK_OK) == ES_LINK_OK ?
+					LEDMAN_CMD_ON : LEDMAN_CMD_OFF,
+					strcmp(dev->name, "eth0")?LEDMAN_LAN2_LINK:LEDMAN_LAN1_LINK);
+			SMC_SELECT_BANK( 1 );
+			/* ACK it */
+			outw(inw(ioaddr + CONTROL) & ~CTL_LE_ENABLE, ioaddr + CONTROL);	
+			outw(inw(ioaddr + CONTROL) | CTL_LE_ENABLE, ioaddr + CONTROL);	
+			SMC_SELECT_BANK( 2 );
+			SMC_ACK_INT( IM_EPH_INT );
+			continue; /* do not turn the TX/RX leds on */
+#else
 			PRINTK((CARDNAME ": UNSUPPORTED: EPH INTERRUPT \n"));
+#endif
 		} else if (status & IM_ERCV_INT ) {
 			PRINTK((CARDNAME ": UNSUPPORTED: ERCV INTERRUPT \n"));
-			outb( IM_ERCV_INT, ioaddr + INTERRUPT );
+			SMC_ACK_INT( IM_ERCV_INT );
+		}
+#ifdef CONFIG_LEDMAN
+		if (tx) {
+			ledman_cmd(LEDMAN_CMD_SET,
+					strcmp(dev->name, "eth0") == 0 ? LEDMAN_LAN1_TX :
+						LEDMAN_LAN2_TX);
+		} else {
+			ledman_cmd(LEDMAN_CMD_SET,
+					strcmp(dev->name, "eth0") == 0 ? LEDMAN_LAN1_RX :
+						LEDMAN_LAN2_RX);
 		}
+#endif
 	} while ( timeout -- );
 
 
 	/* restore state register */
 	SMC_SELECT_BANK( 2 );
-	outb( mask, ioaddr + INT_MASK );
+	SMC_SET_INT( mask );
 
 	PRINTK3(( KERN_WARNING CARDNAME ": MASK is now %x \n", mask ));
 	outw( saved_pointer, ioaddr + POINTER );
@@ -1261,7 +1540,7 @@
 static void smc_rcv(struct net_device *dev)
 {
 	struct smc_local *lp = (struct smc_local *)dev->priv;
-	int 	ioaddr = dev->base_addr;
+	smcio_t ioaddr = dev->base_addr;
 	int 	packet_number;
 	word	status;
 	word	packet_length;
@@ -1281,8 +1560,16 @@
 	outw( PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + POINTER );
 
 	/* First two words are status and packet_length */
+#ifndef CONFIG_SH_KEYWEST
 	status 		= inw( ioaddr + DATA_1 );
 	packet_length 	= inw( ioaddr + DATA_1 );
+#else
+	{
+		unsigned int l = inl( ioaddr + DATA_1 );
+		status         = l & 0xffff;
+		packet_length  = l >> 16;
+	}
+#endif
 
 	packet_length &= 0x07ff;  /* mask off top bits */
 
@@ -1333,9 +1620,17 @@
 			packet_length >> 2, packet_length & 3 ));
 		insl(ioaddr + DATA_1 , data, packet_length >> 2 );
 		/* read the left over bytes */
+#ifndef CONFIG_SH_KEYWEST
 		insb( ioaddr + DATA_1, data + (packet_length & 0xFFFFFC),
 			packet_length & 0x3  );
 #else
+		if (packet_length & 3) {
+			union { unsigned int l; char data[4]; } l;
+			l.l = inl(ioaddr + DATA_1);
+			memcpy(data + (packet_length & ~0x3), l.data, packet_length & 0x3);
+		}
+#endif
+#else
 		PRINTK3((" Reading %d words and %d byte(s) \n",
 			(packet_length >> 1 ), packet_length & 1 ));
 		insw(ioaddr + DATA_1 , data, packet_length >> 1);
@@ -1386,7 +1681,7 @@
  ************************************************************************/
 static void smc_tx( struct net_device * dev )
 {
-	int	ioaddr = dev->base_addr;
+	smcio_t	ioaddr = dev->base_addr;
 	struct smc_local *lp = (struct smc_local *)dev->priv;
 	byte saved_packet;
 	byte packet_no;
@@ -1400,7 +1695,12 @@
 	packet_no &= 0x7F;
 
 	/* select this as the packet to read from */
-	outb( packet_no, ioaddr + PNR_ARR );
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outw( packet_no, ioaddr + PNR_ARR ); 
+#else
+	outb( packet_no, ioaddr + PNR_ARR ); 
+#endif
+	
 
 	/* read the first word from this packet */
 	outw( PTR_AUTOINC | PTR_READ, ioaddr + POINTER );
@@ -1411,8 +1711,10 @@
 	lp->stats.tx_errors++;
 	if ( tx_status & TS_LOSTCAR ) lp->stats.tx_carrier_errors++;
 	if ( tx_status & TS_LATCOL  ) {
+#if 0
 		printk(KERN_DEBUG CARDNAME
 			": Late collision occurred on last xmit.\n");
+#endif
 		lp->stats.tx_window_errors++;
 	}
 #if 0
@@ -1433,7 +1735,11 @@
 	/* one less packet waiting for me */
 	lp->packets_waiting--;
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outw( saved_packet, ioaddr + PNR_ARR );
+#else
 	outb( saved_packet, ioaddr + PNR_ARR );
+#endif
 	return;
 }
 
@@ -1451,6 +1757,11 @@
 	/* clear everything */
 	smc_shutdown( dev->base_addr );
 
+#if defined(CONFIG_LEDMAN) && defined(CONFIG_SNAPGEAR)
+	ledman_cmd(LEDMAN_CMD_OFF,
+		strcmp(dev->name, "eth0")?LEDMAN_LAN2_LINK : LEDMAN_LAN1_LINK);
+#endif
+
 	/* Update the statistics here. */
 	return 0;
 }
@@ -1475,7 +1786,7 @@
 */
 static void smc_set_multicast_list(struct net_device *dev)
 {
-	short ioaddr = dev->base_addr;
+	smcio_t ioaddr = dev->base_addr;
 
 	SMC_SELECT_BANK(0);
 	if ( dev->flags & IFF_PROMISC )
@@ -1522,6 +1833,12 @@
 	}
 }
 
+#ifdef PHY_SETUP
+static int phy_delay1 = 4;
+static int phy_delay2 = 1;
+static int phy_delay3 = 100;
+#endif
+
 #ifdef MODULE
 
 static struct net_device devSMC9194;
@@ -1537,6 +1854,15 @@
 MODULE_PARM_DESC(irq, "SMC 99194 IRQ number");
 MODULE_PARM_DESC(ifport, "SMC 99194 interface port (0-default, 1-TP, 2-AUI)");
 
+#ifdef PHY_SETUP
+MODULE_PARM(phy_delay1, "i");
+MODULE_PARM(phy_delay2, "i");
+MODULE_PARM(phy_delay3, "i");
+MODULE_PARM_DESC(phy_delay1, "Per MII clock delay [4]");
+MODULE_PARM_DESC(phy_delay2, "General delay [1]");
+MODULE_PARM_DESC(phy_delay3, "pre probe delay [100]");
+#endif
+
 int init_module(void)
 {
 	int result;
@@ -1545,6 +1871,10 @@
 		printk(KERN_WARNING
 		CARDNAME": You shouldn't use auto-probing with insmod!\n" );
 
+#ifdef PHY_SETUP
+	printk(CARDNAME ": phy_delays %d %d %d\n", phy_delay1, phy_delay2,
+			phy_delay3);
+#endif
 	/* copy the parameters from insmod into the device structure */
 	devSMC9194.base_addr = io;
 	devSMC9194.irq       = irq;
@@ -1558,6 +1888,7 @@
 
 void cleanup_module(void)
 {
+	/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
 	unregister_netdev(&devSMC9194);
 
 	free_irq(devSMC9194.irq, &devSMC9194);
@@ -1568,3 +1899,437 @@
 }
 
 #endif /* MODULE */
+
+
+#ifdef PHY_SETUP
+/*-----------------------------------------------------------
+ . PHY/MII setup routines
+ .
+*/
+
+#define phy_delay(x) ({ int d; for (d = 0; d < 100; d++) udelay((x) * 10); })
+
+/*
+ *	Ports for talking to the PHY/MII
+ */
+
+#define NV_CONTROL	0x10
+#define MIICTRL		0x30
+#define MIIDATA		0x34
+#define MIICFG		0x38
+
+#define MIIREAD		0x0001
+#define MIIWRITE	0x0002
+
+#define	MDO			0x01		/* MII Register bits */
+#define	MDI			0x02
+#define	MCLK		0x04
+#define	MDOE		0x08
+#define	MALL 		0x0F
+#define	OPWrite		0x01
+#define	OPRead		0x02
+
+
+#define PHY_CR			0		/* PHY Registers and bits */
+#define PHY_CR_Reset	0x8000
+#define PHY_CR_Speed	0x2000
+#define PHY_CR_Duplex	0x0100
+
+#define PHY_SR	1
+#define PHY_ID1	2
+#define PHY_ID2	3
+
+/*
+ *	PHY propietary registers
+ */
+
+#define PHY_NATIONAL_PAR			0x19
+#define PHY_NATIONAL_PAR_DUPLEX		0x0080
+#define PHY_NATIONAL_PAR_SPEED_10	0x0040
+
+#define PHY_TDK_DIAG				0x12
+#define PHY_TDK_DIAG_DUPLEX			0x0800
+#define PHY_TDK_DIAG_RATE			0x0400
+
+#define PHY_QSI_BASETX				0x1F
+#define PHY_QSI_BASETX_OPMODE_MASK	0x001c
+#define PHY_QSI_BASETX_OPMODE_10HD	(2<<0x1)
+#define PHY_QSI_BASETX_OPMODE_100HD	(2<<0x2)
+#define PHY_QSI_BASETX_OPMODE_10FD	(2<<0x5)
+#define PHY_QSI_BASETX_OPMODE_100FD	(2<<0x6)
+
+#define PHY_SEEQ_STATUS_OUTPUT		0x12
+#define PHY_SEEQ_SPD_DET			0x80
+#define PHY_SEEQ_DPLX_DET			0x40
+
+#define PHY_OUI_QSI			0x006051
+#define PHY_OUI_TDK			0x00C039
+#define PHY_OUI_MITELSMSC	0x00A087
+#define PHY_OUI_NATIONAL	0x080017
+#define PHY_OUI_SEEQSMSC	0x0005BE
+
+#define NWAY_TIMEOUT	10
+
+#define MAC_IS_FEAST()	(1)
+#define MAC_IS_EPIC()	(0)
+
+static void
+clkmdio(smcio_t ioaddr, unsigned int MGMTData)
+{
+	outw(MGMTData, ioaddr + MGMT);
+	udelay(phy_delay1);
+	outw(MGMTData | MCLK, ioaddr + MGMT);
+	udelay(phy_delay1);
+}
+
+
+static unsigned
+PHYAccess(
+	smcio_t ioaddr,
+	unsigned char PHYAdd,
+	unsigned char RegAdd,
+	unsigned char OPCode,
+	unsigned wData)
+{
+	int i;
+	unsigned MGMTval;
+
+	// Filter unused bits from input variables.
+
+	PHYAdd &= 0x1F;
+	RegAdd &= 0x1F;
+	OPCode &= 0x03;
+
+	if (MAC_IS_FEAST()) {
+		MGMTval = inw(ioaddr + MGMT) & (MALL ^ 0xFFFF);
+
+		// Output Preamble (32 '1's)
+
+		for (i = 0; i < 32; i++)
+			clkmdio(ioaddr, MGMTval | MDOE | MDO);
+
+		// Output Start of Frame ('01')
+
+		for (i = 0; i < 2; i++)
+			clkmdio(ioaddr, MGMTval | MDOE | i);
+
+		// Output OPCode ('01' for write or '10' for Read)
+
+		for (i = 1; i >= 0; i--)
+			clkmdio(ioaddr, MGMTval | MDOE | ((OPCode>>i) & 0x01) );
+
+		// Output PHY Address
+
+		for (i = 4; i >= 0; i--)
+			clkmdio(ioaddr, MGMTval | MDOE | ((PHYAdd>>i) & 0x01) );
+
+		// Output Register Address
+
+		for (i = 4; i >= 0; i--)
+			clkmdio(ioaddr, MGMTval | MDOE | ((RegAdd>>i) & 0x01) );
+
+		if (OPCode == OPRead) {
+			// Read Operation
+
+			// Implement Turnaround ('Z0')
+
+			clkmdio(ioaddr, MGMTval);
+			// clkmdio(ioaddr, MGMTval | MDOE);
+
+			// Read Data
+
+			wData = 0;
+
+			for (i = 15; i >= 0; i--) {
+				clkmdio(ioaddr, MGMTval);
+				wData |= (((inw(ioaddr + MGMT) & MDI) >> 1) << i);
+			}
+
+			// Add Idle state
+
+			clkmdio(ioaddr, MGMTval);
+
+			return (wData);
+		} else {
+			// Write Operation
+
+			// Implement Turnaround ('10')
+
+			for (i = 1; i >= 0; i--)
+				clkmdio(ioaddr, MGMTval | MDOE | ((2>>i) & 0x01));
+
+			// Write Data
+
+			for (i = 15; i >= 0; i--)
+				clkmdio(ioaddr, MGMTval | MDOE | ((wData>>i) & 0x01));
+
+			// Add Idle state
+
+			clkmdio(ioaddr, MGMTval);
+
+			return (1);
+		}
+	}
+
+	if (MAC_IS_EPIC()) {
+		if (OPCode == OPRead) {
+			// Read Operation
+			outw((((unsigned)PHYAdd)<<9) | (((unsigned)RegAdd)<<4) | MIIREAD,
+					ioaddr + MIICTRL);
+			phy_delay(phy_delay2);
+			wData = inw(MIIDATA);
+			return(wData);
+		} else {
+			// Write Operation
+			outw(wData, ioaddr + MIIDATA);
+			outw((((unsigned)PHYAdd)<<9) | (((unsigned)RegAdd)<<4) | MIIWRITE,
+					ioaddr + MIICTRL);
+			phy_delay(phy_delay2);
+			return(1);
+		}
+	}
+
+	return(1);
+
+}
+
+
+static unsigned char
+DetectPHY(
+	smcio_t ioaddr,
+	unsigned long *OUI,
+	unsigned char *Model,
+	unsigned char *Revision)
+{
+    unsigned int PhyId1, PhyId2;
+    unsigned char PhyAdd=0xff;
+    int Count;
+
+    for (Count=31; Count >= 0; Count--) {
+		PhyId1 = PHYAccess(ioaddr, Count, PHY_ID1, OPRead, 0);
+		PhyId1 = PHYAccess(ioaddr, Count, PHY_ID1, OPRead, 0);
+		PhyId2 = PHYAccess(ioaddr, Count, PHY_ID2, OPRead, 0);
+		PhyId2 = PHYAccess(ioaddr, Count, PHY_ID2, OPRead, 0);
+
+		if (PhyId1 > 0x0000 && PhyId1 < 0xffff && PhyId2 > 0x0000 &&
+			PhyId2 < 0xffff && PhyId1 != 0x8000 && PhyId2 != 0x8000) {
+			PhyAdd = (unsigned char) Count;
+			break;
+		}
+		phy_delay(phy_delay2);
+    }
+
+    *OUI =		(((unsigned long) PhyId1) << 6) | ((PhyId2 & 0xfc00) >> 10);
+    *Model =	(unsigned char) ((PhyId2 & 0x03f0) >> 4);
+    *Revision =	(unsigned char) (PhyId2 & 0x000f);
+
+    return(PhyAdd);
+}
+
+
+static int
+setup_phy(smcio_t ioaddr)
+{
+    int duplex = 0; /* 0 = Half,   !0 = Full */
+    int speed = 0;  /* 0 = 10Mbps, !0 = 100Mbps */
+    char *report = "";
+	unsigned long OUI;
+	unsigned char Model, Revision;
+
+    unsigned int i, PHYConfig, PHYConfig2, data;
+    unsigned char PHYAdd, ositech = 0;
+
+	printk("SMCPHY: ");
+#if 0
+	ositech = 1;
+#endif
+
+	//Setting the AUI Select Bit for 91C110 PCMCIA Design. 11/23/99 PG
+	if (ositech) {
+		SMC_SELECT_BANK( 1 );
+		data = inw(ioaddr + BANK_SELECT);
+		outw(data | 0x0100, ioaddr);
+	}
+
+    if (MAC_IS_FEAST())
+		SMC_SELECT_BANK ( 3 );
+
+	PHYAdd = DetectPHY(ioaddr, &OUI, &Model, &Revision);
+
+	if (PHYAdd > 31) {
+	    printk("UNRECOVERABLE ERROR: PHY is not present or not supported\n");
+	    return(-1);
+	}
+
+	//Setup NV_CONTROL for the cardbus card.
+	if (OUI == PHY_OUI_TDK)
+		outw(0x7c03, ioaddr + NV_CONTROL);
+
+	// Save Register 0.
+
+	if (OUI == PHY_OUI_TDK)
+		PHYAccess(ioaddr, PHYAdd, PHY_CR, OPRead, 0);
+	PHYConfig = PHYAccess(ioaddr, PHYAdd,PHY_CR,OPRead,0);
+
+	if (OUI == PHY_OUI_TDK) {
+		outw(0x0012, ioaddr + MIICFG);	/* Set ENABLE_694 */
+		/* if using EPIC, Hardware Reset the PHY from the MAC */
+		outw(inw(ioaddr + CONTROL) | 0x4000, ioaddr + CONTROL);
+		phy_delay(phy_delay2);
+		outw(inw(ioaddr + CONTROL) & (~0x4000), ioaddr + CONTROL);
+		phy_delay(phy_delay2);
+	}
+
+	/* Reset PHY */
+	PHYAccess(ioaddr, PHYAdd, PHY_CR, OPWrite, PHY_CR_Reset);
+	if (OUI == PHY_OUI_TDK)
+		PHYAccess(ioaddr, PHYAdd, PHY_CR, OPWrite, PHY_CR_Reset);
+
+	for (i = 0; i < 500; i++) {
+		if (OUI == PHY_OUI_TDK)
+			PHYAccess(ioaddr, PHYAdd, PHY_CR, OPRead, 0);
+
+		if (PHYAccess(ioaddr, PHYAdd, PHY_CR, OPRead, 0) & PHY_CR_Reset)
+			phy_delay(phy_delay2);
+		else
+			break;
+	}
+
+	if (i == 500) {
+		printk("UNRECOVERABLE ERROR: Could not reset PHY\n");
+		return(-1);
+	}
+
+	/* Write selected configuration to the PHY and verify it by reading back */
+	/* Set Advertising Register for all 10/100 and Half/Full combinations */
+
+	if (OUI == PHY_OUI_TDK)
+		PHYConfig = PHYAccess(ioaddr, PHYAdd, 4, OPRead, 0);
+	PHYConfig = PHYAccess(ioaddr, PHYAdd, 4, OPRead, 0);
+	PHYConfig |= 0x01e0;
+	PHYAccess(ioaddr, PHYAdd, 4, OPWrite, PHYConfig);
+	if (OUI == PHY_OUI_TDK)
+		PHYAccess(ioaddr, PHYAdd, 4, OPWrite, PHYConfig);
+
+	/* Start 1 */
+
+	/* National PHY requires clear before set 1 enable. */
+	PHYAccess(ioaddr, PHYAdd, 0, OPWrite, 0x0000);
+	PHYAccess(ioaddr, PHYAdd, 0, OPWrite, 0x1200);
+	if (OUI == PHY_OUI_TDK)
+		PHYAccess(ioaddr, PHYAdd, 0, OPWrite, 0x1200);
+
+	/* Wait for completion */
+	for (i = 0; i < NWAY_TIMEOUT * 10; i++) {
+		printk("%c\b", "|/-\\"[i&3]);
+
+		phy_delay(phy_delay3);
+
+		PHYConfig = PHYAccess(ioaddr, PHYAdd, 1, OPRead, 0);
+		PHYConfig2 = PHYAccess(ioaddr, PHYAdd, 1, OPRead, 0);
+
+		if (PHYConfig != PHYConfig2) /* Value is not stable */
+			continue;
+		if (PHYConfig & 0x0010) /* Remote Fault */
+			continue;
+		if ((PHYConfig == 0x0000) || (PHYConfig == 0xffff)) /* invalid value */
+			continue;
+		if (PHYConfig & 0x0020)
+			break;
+	}
+
+	/* Now read the results of the NWAY. */
+
+	if (OUI == PHY_OUI_TDK)
+		PHYConfig = PHYAccess(ioaddr, PHYAdd, 5, OPRead, 0);
+	PHYConfig = PHYAccess(ioaddr, PHYAdd, 5, OPRead, 0);
+
+	if (PHYConfig != 0) {
+		/* Got real NWAY information here */
+		report = "ANLPA";
+		speed = (PHYConfig & 0x0180);
+		duplex = (PHYConfig & 0x0140);
+	} else {
+		/*
+		 * ANLPA was 0 so NWAY did not complete or is not reported fine.
+		 * Get the info from propietary regs or from the control register.
+		 */
+		report = "Prop."; /* Proprietary Status */
+
+		switch (OUI) {
+		case PHY_OUI_NATIONAL:
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, PHY_NATIONAL_PAR, OPRead, 0);
+			duplex = (PHYConfig & PHY_NATIONAL_PAR_DUPLEX);
+			speed = ! (PHYConfig & PHY_NATIONAL_PAR_SPEED_10);
+			break;
+
+		case PHY_OUI_TDK:
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, PHY_TDK_DIAG, OPRead, 0);
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, PHY_TDK_DIAG, OPRead, 0);
+			speed = ((Revision < 7) && ((PHYConfig & 0x300) == 0x300)) ||
+					((Revision >= 7) && (PHYConfig & PHY_TDK_DIAG_RATE));
+			duplex = ((Revision >= 7) && (PHYConfig & PHY_TDK_DIAG_DUPLEX));
+			break;
+
+		case PHY_OUI_QSI:
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, PHY_QSI_BASETX, OPRead, 0);
+			PHYConfig &= PHY_QSI_BASETX_OPMODE_MASK;
+			duplex = (PHYConfig & PHY_QSI_BASETX_OPMODE_10FD) ||
+				(PHYConfig & PHY_QSI_BASETX_OPMODE_100FD);
+			speed = (PHYConfig & PHY_QSI_BASETX_OPMODE_100HD) ||
+				(PHYConfig & PHY_QSI_BASETX_OPMODE_100FD);
+			break;
+
+		case PHY_OUI_SEEQSMSC:
+			PHYConfig=PHYAccess(ioaddr,PHYAdd,PHY_SEEQ_STATUS_OUTPUT,OPRead,0);
+			duplex = (PHYConfig & PHY_SEEQ_DPLX_DET);
+			speed = (PHYConfig & PHY_SEEQ_SPD_DET);
+			break;
+
+		default:
+			report = "Command";
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, 0, OPRead, 0);
+			speed = (PHYConfig & 0x2000);
+			duplex = (PHYConfig & 0x0100);
+			break;
+		}
+	}
+
+	/* Do we need to adjust the Carrier sense on full duplex FEAST issue ?  */
+
+	if (duplex && MAC_IS_FEAST() && (OUI == PHY_OUI_MITELSMSC))
+		PHYAccess(ioaddr, PHYAdd, 0x18, OPWrite,
+				0x0020 | PHYAccess(ioaddr, PHYAdd, 0x18, OPRead, 0));
+
+	/* Display what we learned */
+
+    printk(" %s-duplex %d Mbps ", duplex ? "Full" : "Half", speed ? 100 : 10);
+
+	if (MAC_IS_FEAST())
+		printk("FEAST ");
+	if (MAC_IS_EPIC())
+		printk("EPIC ");
+
+	switch (OUI) {
+	case PHY_OUI_QSI:       printk("QSI");                break;
+	case PHY_OUI_TDK:       printk("TDK");                break;
+	case PHY_OUI_MITELSMSC: printk("MITEL/SMSC180");      break;
+	case PHY_OUI_NATIONAL:  printk("NATIONAL");           break;
+	case PHY_OUI_SEEQSMSC:  printk("SEEQ/SMSC183");       break;
+	default:                printk("%06lX(UNKNOWN)",OUI); break;
+	}
+
+	printk(" Model=%02X Rev=%02X ", Model, Revision);
+#if DEBUG
+	printk("Addr=%02X ", PHYAdd);
+	printk("Conf=%s ", report);
+#endif
+	if (i == NWAY_TIMEOUT)
+		printk("TIMEOUT!\n");
+	else
+		printk("Done.\n");
+	return(0);
+}
+
+/*----------------------------------------------------------- */
+#endif /* PHY_SETUP */
diff -Naur linux-2.6.0-test8/drivers/net/smc9194.h linux-2.6.0-test8-uc0/drivers/net/smc9194.h
--- linux-2.6.0-test8/drivers/net/smc9194.h	2003-10-20 09:10:30.000000000 +1000
+++ linux-2.6.0-test8-uc0/drivers/net/smc9194.h	2003-10-20 09:12:25.833264184 +1000
@@ -96,6 +96,8 @@
 /* BANK 1 */
 #define CONFIG			0
 #define CFG_AUI_SELECT	 	0x100
+#define	CFG_NO_WAIT		0x1000
+#define	CFG_MII_SELECT		0x8000
 #define	BASE			2
 #define	ADDR0			4
 #define	ADDR1			6
@@ -208,6 +210,44 @@
 			inw( ioaddr + RCR );\
 			inw( ioaddr + RCR );  }
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = inb( ioaddr + INT_MASK );\
+		mask |= (x);\
+		outw( mask << 8, ioaddr + INTERRUPT ); \
+}
+
+/* this disables an interrupt from the interrupt mask register */
+
+#define SMC_DISABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = inb( ioaddr + INT_MASK );\
+		mask &= ~(x);\
+		outw( mask << 8, ioaddr + INTERRUPT ); \
+}
+
+/* set the interrupt mask register */
+#define	SMC_SET_INT(x) {\
+		SMC_SELECT_BANK(2);\
+		outw( ((unsigned short) (x)) << 8, ioaddr + INTERRUPT );\
+}
+
+/* acknowledge an interrupt */
+#define	SMC_ACK_INT(x) {\
+		unsigned short val;\
+		/* assume BANK 2 selected */\
+		val = inb( ioaddr + INT_MASK );\
+		val = (val << 8) | (x);\
+		outw( val, ioaddr + INTERRUPT );\
+}
+
+#else
+
 /* this enables an interrupt in the interrupt mask register */
 #define SMC_ENABLE_INT(x) {\
 		unsigned char mask;\
@@ -227,6 +267,17 @@
 		outb( mask, ioaddr + INT_MASK ); \
 }
 
+/* set the interrupt mask register */
+#define	SMC_SET_INT(x) {\
+		SMC_SELECT_BANK(2);\
+		outb( (x), ioaddr + INT_MASK );\
+}
+
+/* acknowledge an interrupt */
+#define	SMC_ACK_INT(x)	outb( (x), ioaddr + INTERRUPT )
+
+#endif
+
 /*----------------------------------------------------------------------
  . Define the interrupts that I want to receive from the card
  . 
diff -Naur linux-2.6.0-test8/drivers/serial/68328serial.c linux-2.6.0-test8-uc0/drivers/serial/68328serial.c
--- linux-2.6.0-test8/drivers/serial/68328serial.c	2003-10-20 09:10:41.000000000 +1000
+++ linux-2.6.0-test8-uc0/drivers/serial/68328serial.c	2003-10-20 09:12:40.942967160 +1000
@@ -4,7 +4,7 @@
  * Copyright (C) 1998       Kenneth Albanowski <kjahds@kjahds.com>
  * Copyright (C) 1998, 1999 D. Jeff Dionne     <jeff@uclinux.org>
  * Copyright (C) 1999       Vladimir Gurevich  <vgurevic@cisco.com>
- * Copyright (C) 2002       David McCullough   <davidm@snapgear.com>
+ * Copyright (C) 2002-2003  David McCullough   <davidm@snapgear.com>
  * Copyright (C) 2002       Greg Ungerer       <gerg@snapgear.com>
  *
  * VZ Support/Fixes             Evan Stawnyczy <e@lineo.ca>
@@ -67,12 +67,12 @@
 #endif
 
 static struct m68k_serial m68k_soft[NR_PORTS];
-struct m86k_serial *IRQ_ports[NR_IRQS];
+struct m68k_serial *IRQ_ports[NR_IRQS];
 
 static unsigned int uart_irqs[NR_PORTS] = UART_IRQ_DEFNS;
 
 /* multiple ports are contiguous in memory */
-m68328_uart *uart_addr = USTCNT_ADDR;
+m68328_uart *uart_addr = (m68328_uart *)USTCNT_ADDR;
 
 struct tty_struct m68k_ttys;
 struct m68k_serial *m68k_consinfo = 0;
@@ -400,7 +400,7 @@
 /*
  * This is the serial driver's generic interrupt routine
  */
-void rs_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+irqreturn_t rs_interrupt(int irq, void *dev_id, struct pt_regs * regs)
 {
 	struct m68k_serial * info;
 	m68328_uart *uart;
@@ -409,7 +409,7 @@
 
 	info = IRQ_ports[irq];
 	if(!info)
-	    return;
+	    return IRQ_NONE;
 
 	uart = &uart_addr[info->line];
 	rx = uart->urx.w;
@@ -422,7 +422,7 @@
 #else
 	receive_chars(info, regs, rx);		
 #endif
-	return;
+	return IRQ_HANDLED;
 }
 
 static void do_softint(void *private)
@@ -777,7 +777,7 @@
 	save_flags(flags);
 	while (1) {
 		cli();		
-		c = min(count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+		c = min_t(int, count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
 				   SERIAL_XMIT_SIZE - info->xmit_head));
 		if (c <= 0)
 			break;
@@ -785,7 +785,7 @@
 		if (from_user) {
 			down(&tmp_buf_sem);
 			copy_from_user(tmp_buf, buf, c);
-			c = min(c, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+			c = min_t(int, c, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
 				       SERIAL_XMIT_SIZE - info->xmit_head));
 			memcpy(info->xmit_buf + info->xmit_head, tmp_buf, c);
 			up(&tmp_buf_sem);
@@ -1056,11 +1056,10 @@
 			send_break(info, arg ? arg*(HZ/10) : HZ/4);
 			return 0;
 		case TIOCGSOFTCAR:
-			error = verify_area(VERIFY_WRITE, (void *) arg,sizeof(long));
+			error = put_user(C_CLOCAL(tty) ? 1 : 0,
+				    (unsigned long *) arg);
 			if (error)
 				return error;
-			put_user(C_CLOCAL(tty) ? 1 : 0,
-				    (unsigned long *) arg);
 			return 0;
 		case TIOCSSOFTCAR:
 			get_user(arg, (unsigned long *) arg);
diff -Naur linux-2.6.0-test8/drivers/serial/mcfserial.c linux-2.6.0-test8-uc0/drivers/serial/mcfserial.c
--- linux-2.6.0-test8/drivers/serial/mcfserial.c	2003-10-20 09:10:41.000000000 +1000
+++ linux-2.6.0-test8-uc0/drivers/serial/mcfserial.c	2003-10-20 09:12:41.033953328 +1000
@@ -10,6 +10,11 @@
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
  * Copyright (C) 1998 TSHG
  * Copyright (c) 1999 Rt-Control Inc. <jeff@uclinux.org>
+ *
+ * Changes:
+ * 08/07/2003    Daniele Bellucci <bellucda@tiscali.it>
+ *               some cleanups in mcfrs_write.
+ * 
  */
  
 #include <linux/module.h>
@@ -31,7 +36,6 @@
 #include <linux/ledman.h>
 #endif
 #include <linux/console.h>
-#include <linux/version.h>
 #include <linux/init.h>
 
 #include <asm/io.h>
@@ -138,6 +142,7 @@
  *	Forware declarations...
  */
 static void	mcfrs_change_speed(struct mcf_serial *info);
+static void	mcfrs_wait_until_sent(struct tty_struct *tty, int timeout);
 
 
 static inline int serial_paranoia_check(struct mcf_serial *info,
@@ -603,6 +608,9 @@
 	unsigned long		flags;
 	unsigned char		mr1, mr2;
 	int			i;
+#ifdef	CONFIG_M5272
+	unsigned int		fraction;
+#endif
 
 	if (!info->tty || !info->tty->termios)
 		return;
@@ -626,7 +634,20 @@
 		mcfrs_setsignals(info, 0, -1);
 		return;
 	}
+
+	/* compute the baudrate clock */
+#ifdef	CONFIG_M5272
+	/*
+	 * For the MCF5272, also compute the baudrate fraction.
+	 */
+	baudclk = (MCF_BUSCLK / mcfrs_baud_table[i]) / 32;
+	fraction = MCF_BUSCLK - (baudclk * 32 * mcfrs_baud_table[i]);
+	fraction *= 16;
+	fraction /= (32 * mcfrs_baud_table[i]);
+#else
 	baudclk = ((MCF_BUSCLK / mcfrs_baud_table[i]) + 16) / 32;
+#endif
+
 	info->baud = mcfrs_baud_table[i];
 
 	mr1 = MCFUART_MR1_RXIRQRDY | MCFUART_MR1_RXERRCHAR;
@@ -690,6 +711,9 @@
 	uartp[MCFUART_UMR] = mr2;
 	uartp[MCFUART_UBG1] = (baudclk & 0xff00) >> 8;	/* set msb byte */
 	uartp[MCFUART_UBG2] = (baudclk & 0xff);		/* set lsb byte */
+#ifdef	CONFIG_M5272
+	uartp[MCFUART_UFPD] = (fraction & 0xf);		/* set fraction */
+#endif
 	uartp[MCFUART_UCSR] = MCFUART_UCSR_RXCLKTIMER | MCFUART_UCSR_TXCLKTIMER;
 	uartp[MCFUART_UCR] = MCFUART_UCR_RXENABLE | MCFUART_UCR_TXENABLE;
 	mcfrs_setsignals(info, 1, -1);
@@ -742,24 +766,26 @@
 		local_irq_disable();		
 		c = min(count, (int) min(((int)SERIAL_XMIT_SIZE) - info->xmit_cnt - 1,
 			((int)SERIAL_XMIT_SIZE) - info->xmit_head));
+		local_irq_restore(flags);
 
-		if (c <= 0) {
-			local_irq_restore(flags);
+		if (c <= 0)
 			break;
-		}
 
 		if (from_user) {
 			down(&mcfrs_tmp_buf_sem);
-			copy_from_user(mcfrs_tmp_buf, buf, c);
-			local_irq_restore(flags);
-			local_irq_disable();
+			if (copy_from_user(mcfrs_tmp_buf, buf, c))
+				return -EFAULT;
+
+			local_irq_disable();		
 			c = min(c, (int) min(((int)SERIAL_XMIT_SIZE) - info->xmit_cnt - 1,
 				       ((int)SERIAL_XMIT_SIZE) - info->xmit_head));
+			local_irq_restore(flags);
 			memcpy(info->xmit_buf + info->xmit_head, mcfrs_tmp_buf, c);
 			up(&mcfrs_tmp_buf_sem);
 		} else
 			memcpy(info->xmit_buf + info->xmit_head, buf, c);
 
+		local_irq_disable();		
 		info->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE-1);
 		info->xmit_cnt += c;
 		local_irq_restore(flags);
@@ -1020,11 +1046,10 @@
 			send_break(info, arg ? arg*(HZ/10) : HZ/4);
 			return 0;
 		case TIOCGSOFTCAR:
-			error = verify_area(VERIFY_WRITE, (void *) arg,sizeof(long));
+			error = put_user(C_CLOCAL(tty) ? 1 : 0,
+				    (unsigned long *) arg);
 			if (error)
 				return error;
-			put_user(C_CLOCAL(tty) ? 1 : 0,
-				    (unsigned long *) arg);
 			return 0;
 		case TIOCSSOFTCAR:
 			get_user(arg, (unsigned long *) arg);
@@ -1051,48 +1076,37 @@
 			    return get_lsr_info(info, (unsigned int *) arg);
 
 		case TIOCSERGSTRUCT:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-						sizeof(struct mcf_serial));
-			if (error)
-				return error;
-			copy_to_user((struct mcf_serial *) arg,
+			error = copy_to_user((struct mcf_serial *) arg,
 				    info, sizeof(struct mcf_serial));
+			if (error)
+				return -EFAULT;
 			return 0;
 			
 		case TIOCMGET:
-			if ((error = verify_area(VERIFY_WRITE, (void *) arg,
-                            sizeof(unsigned int))))
-                                return(error);
 			val = mcfrs_getsignals(info);
-			put_user(val, (unsigned int *) arg);
+			if ((error = put_user(val, (unsigned int *) arg)))
+				return error;
 			break;
 
                 case TIOCMBIS:
-			if ((error = verify_area(VERIFY_WRITE, (void *) arg,
-                            sizeof(unsigned int))))
-				return(error);
-
-			get_user(val, (unsigned int *) arg);
+			if ((error = get_user(val, (unsigned int *) arg)))
+				return error;
 			rts = (val & TIOCM_RTS) ? 1 : -1;
 			dtr = (val & TIOCM_DTR) ? 1 : -1;
 			mcfrs_setsignals(info, dtr, rts);
 			break;
 
                 case TIOCMBIC:
-			if ((error = verify_area(VERIFY_WRITE, (void *) arg,
-                            sizeof(unsigned int))))
-				return(error);
-			get_user(val, (unsigned int *) arg);
+			if ((error = get_user(val, (unsigned int *) arg)))
+				return error;
 			rts = (val & TIOCM_RTS) ? 0 : -1;
 			dtr = (val & TIOCM_DTR) ? 0 : -1;
 			mcfrs_setsignals(info, dtr, rts);
 			break;
 
                 case TIOCMSET:
-			if ((error = verify_area(VERIFY_WRITE, (void *) arg,
-                            sizeof(unsigned int))))
-				return(error);
-			get_user(val, (unsigned int *) arg);
+			if ((error = get_user(val, (unsigned int *) arg)))
+				return error;
 			rts = (val & TIOCM_RTS) ? 1 : 0;
 			dtr = (val & TIOCM_DTR) ? 1 : 0;
 			mcfrs_setsignals(info, dtr, rts);
@@ -1239,6 +1253,76 @@
 }
 
 /*
+ * mcfrs_wait_until_sent() --- wait until the transmitter is empty
+ */
+static void
+mcfrs_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+#ifdef	CONFIG_M5272
+#define	MCF5272_FIFO_SIZE	25		/* fifo size + shift reg */
+
+	struct mcf_serial * info = (struct mcf_serial *)tty->driver_data;
+	volatile unsigned char *uartp;
+	unsigned long orig_jiffies, fifo_time, char_time, fifo_cnt;
+	
+	if (serial_paranoia_check(info, tty->name, "mcfrs_wait_until_sent"))
+		return;
+	
+	orig_jiffies = jiffies;
+
+	/*
+	 * Set the check interval to be 1/5 of the approximate time
+	 * to send the entire fifo, and make it at least 1.  The check
+	 * interval should also be less than the timeout.
+	 *
+	 * Note: we have to use pretty tight timings here to satisfy
+	 * the NIST-PCTS.
+	 */
+	fifo_time = (MCF5272_FIFO_SIZE * HZ * 10) / info->baud;
+	char_time = fifo_time / 5;
+	if (char_time == 0)
+		char_time = 1;
+	if (timeout && timeout < char_time)
+		char_time = timeout;
+
+	/*
+	 * Clamp the timeout period at 2 * the time to empty the
+	 * fifo.  Just to be safe, set the minimum at .5 seconds.
+	 */
+	fifo_time *= 2;
+	if (fifo_time < (HZ/2))
+		fifo_time = HZ/2;
+	if (!timeout || timeout > fifo_time)
+		timeout = fifo_time;
+
+	/*
+	 * Account for the number of bytes in the UART
+	 * transmitter FIFO plus any byte being shifted out.
+	 */
+	uartp = (volatile unsigned char *) info->addr;
+	for (;;) {
+		fifo_cnt = (uartp[MCFUART_UTF] & MCFUART_UTF_TXB);
+		if ((uartp[MCFUART_USR] & (MCFUART_USR_TXREADY|
+				MCFUART_USR_TXEMPTY)) ==
+			MCFUART_USR_TXREADY)
+			fifo_cnt++;
+		if (fifo_cnt == 0)
+			break;
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(char_time);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, orig_jiffies + timeout))
+			break;
+	}
+#else
+	/*
+	 * For the other coldfire models, assume all data has been sent
+	 */
+#endif
+}
+
+/*
  * mcfrs_hangup() --- called by tty_hangup() when a hangup is signaled.
  */
 void mcfrs_hangup(struct tty_struct *tty)
@@ -1563,6 +1647,7 @@
 	.start = mcfrs_start,
 	.hangup = mcfrs_hangup,
 	.read_proc = mcfrs_readproc,
+	.wait_until_sent = mcfrs_wait_until_sent,
 };
 
 /* mcfrs_init inits the driver */
@@ -1589,7 +1674,9 @@
 	show_serial_version();
 
 	/* Initialize the tty_driver structure */
+	mcfrs_serial_driver->owner = THIS_MODULE;
 	mcfrs_serial_driver->name = "ttyS";
+	mcfrs_serial_driver->devfs_name = "ttys/";
 	mcfrs_serial_driver->driver_name = "serial";
 	mcfrs_serial_driver->major = TTY_MAJOR;
 	mcfrs_serial_driver->minor_start = 64;
diff -Naur linux-2.6.0-test8/fs/binfmt_flat.c linux-2.6.0-test8-uc0/fs/binfmt_flat.c
--- linux-2.6.0-test8/fs/binfmt_flat.c	2003-10-20 09:10:54.989074600 +1000
+++ linux-2.6.0-test8-uc0/fs/binfmt_flat.c	2003-10-20 09:12:45.018347608 +1000
@@ -179,7 +179,7 @@
 	unsigned char *buf;
 	z_stream strm;
 	loff_t fpos;
-	int ret;
+	int ret, retval;
 
 	DBG_FLT("decompress_exec(offset=%x,buf=%x,len=%x)\n",(int)offset, (int)dst, (int)len);
 
@@ -192,7 +192,8 @@
 	buf = kmalloc(LBUFSIZE, GFP_KERNEL);
 	if (buf == NULL) {
 		DBG_FLT("binfmt_flat: no memory for read buffer\n");
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto out_free;
 	}
 
 	/* Read in first chunk of data and parse gzip header. */
@@ -203,28 +204,30 @@
 	strm.avail_in = ret;
 	strm.total_in = 0;
 
+	retval = -ENOEXEC;
+
 	/* Check minimum size -- gzip header */
 	if (ret < 10) {
 		DBG_FLT("binfmt_flat: file too small?\n");
-		return -ENOEXEC;
+		goto out_free_buf;
 	}
 
 	/* Check gzip magic number */
 	if ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {
 		DBG_FLT("binfmt_flat: unknown compression magic?\n");
-		return -ENOEXEC;
+		goto out_free_buf;
 	}
 
 	/* Check gzip method */
 	if (buf[2] != 8) {
 		DBG_FLT("binfmt_flat: unknown compression method?\n");
-		return -ENOEXEC;
+		goto out_free_buf;
 	}
 	/* Check gzip flags */
 	if ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||
 	    (buf[3] & RESERVED)) {
 		DBG_FLT("binfmt_flat: unknown flags?\n");
-		return -ENOEXEC;
+		goto out_free_buf;
 	}
 
 	ret = 10;
@@ -232,7 +235,7 @@
 		ret += 2 + buf[10] + (buf[11] << 8);
 		if (unlikely(LBUFSIZE == ret)) {
 			DBG_FLT("binfmt_flat: buffer overflow (EXTRA)?\n");
-			return -ENOEXEC;
+			goto out_free_buf;
 		}
 	}
 	if (buf[3] & ORIG_NAME) {
@@ -240,7 +243,7 @@
 			;
 		if (unlikely(LBUFSIZE == ret)) {
 			DBG_FLT("binfmt_flat: buffer overflow (ORIG_NAME)?\n");
-			return -ENOEXEC;
+			goto out_free_buf;
 		}
 	}
 	if (buf[3] & COMMENT) {
@@ -248,7 +251,7 @@
 			;
 		if (unlikely(LBUFSIZE == ret)) {
 			DBG_FLT("binfmt_flat: buffer overflow (COMMENT)?\n");
-			return -ENOEXEC;
+			goto out_free_buf;
 		}
 	}
 
@@ -261,7 +264,7 @@
 
 	if (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {
 		DBG_FLT("binfmt_flat: zlib init failed?\n");
-		return -ENOEXEC;
+		goto out_free_buf;
 	}
 
 	while ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {
@@ -280,13 +283,17 @@
 	if (ret < 0) {
 		DBG_FLT("binfmt_flat: decompression failed (%d), %s\n",
 			ret, strm.msg);
-		return -ENOEXEC;
+		goto out_free_buf;
 	}
 
 	zlib_inflateEnd(&strm);
+	retval = 0;
+out_free_buf:
 	kfree(buf);
+out_free:
 	kfree(strm.workspace);
-	return 0;
+out:
+	return retval;
 }
 
 #endif /* CONFIG_BINFMT_ZFLAT */
diff -Naur linux-2.6.0-test8/fs/Kconfig.binfmt linux-2.6.0-test8-uc0/fs/Kconfig.binfmt
--- linux-2.6.0-test8/fs/Kconfig.binfmt	2003-10-20 09:10:57.047761632 +1000
+++ linux-2.6.0-test8-uc0/fs/Kconfig.binfmt	2003-10-20 09:12:45.006349432 +1000
@@ -40,6 +40,12 @@
 	help
 	  Support FLAT format compressed binaries
 
+config BINFMT_SHARED_FLAT
+	bool "Enable shared FLAT support"
+	depends on BINFMT_FLAT
+	help
+	  Support FLAT shared libraries
+
 config BINFMT_AOUT
 	tristate "Kernel support for a.out and ECOFF binaries"
 	depends on (X86 && !X86_64) || ALPHA || ARM || M68K || MIPS || SPARC
diff -Naur linux-2.6.0-test8/fs/proc/task_nommu.c linux-2.6.0-test8-uc0/fs/proc/task_nommu.c
--- linux-2.6.0-test8/fs/proc/task_nommu.c	2003-10-20 09:10:56.398860280 +1000
+++ linux-2.6.0-test8-uc0/fs/proc/task_nommu.c	2003-10-20 09:12:50.002589888 +1000
@@ -1,6 +1,7 @@
 
 #include <linux/mm.h>
 #include <linux/file.h>
+#include <linux/seq_file.h>
 
 /*
  * Logic: we've got two memory sums for each process, "shared", and
@@ -97,12 +98,28 @@
 	return size;
 }
 
-/*
- * Albert D. Cahalan suggested to fake entries for the traditional
- * sections here.  This might be worth investigating.
- */
-ssize_t proc_pid_read_maps(struct task_struct *task, struct file *file,
-			   char *buf, size_t count, loff_t *ppos)
+static int show_map(struct seq_file *m, void *v)
 {
 	return 0;
 }
+
+static void *m_start(struct seq_file *m, loff_t *pos)
+{
+	return NULL;
+}
+
+static void m_stop(struct seq_file *m, void *v)
+{
+}
+
+static void *m_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	return NULL;
+}
+
+struct seq_operations proc_pid_maps_op = {
+	.start	= m_start,
+	.next	= m_next,
+	.stop	= m_stop,
+	.show	= show_map
+};
diff -Naur linux-2.6.0-test8/include/asm-m68knommu/bitops.h linux-2.6.0-test8-uc0/include/asm-m68knommu/bitops.h
--- linux-2.6.0-test8/include/asm-m68knommu/bitops.h	2003-10-20 09:11:27.864076840 +1000
+++ linux-2.6.0-test8-uc0/include/asm-m68knommu/bitops.h	2003-10-20 09:13:01.807795224 +1000
@@ -77,12 +77,6 @@
 }
 
 /*
- * fls: find last bit set.
- */
-#define fls(x) generic_fls(x)
-
-
-/*
  * Every architecture must define this function. It's the fastest
  * way of searching a 140-bit bitmap where the first 100 bits are
  * unlikely to be set. It's guaranteed that at least one of the 140
@@ -283,7 +277,7 @@
 	return ((1UL << (nr & 31)) & (((const volatile unsigned int *) addr)[nr >> 5])) != 0;
 }
 
-static __inline__ int __test_bit(int nr, const unsigned long * addr)
+static __inline__ int __test_bit(int nr, const volatile unsigned long * addr)
 {
 	int 	* a = (int *) addr;
 	int	mask;
@@ -478,4 +472,9 @@
 
 #endif /* __KERNEL__ */
 
+/*
+ * fls: find last bit set.
+ */
+#define fls(x) generic_fls(x)
+
 #endif /* _M68KNOMMU_BITOPS_H */
diff -Naur linux-2.6.0-test8/include/asm-m68knommu/cacheflush.h linux-2.6.0-test8-uc0/include/asm-m68knommu/cacheflush.h
--- linux-2.6.0-test8/include/asm-m68knommu/cacheflush.h	2003-10-20 09:11:27.959062400 +1000
+++ linux-2.6.0-test8-uc0/include/asm-m68knommu/cacheflush.h	2003-10-20 09:13:01.831791576 +1000
@@ -37,13 +37,15 @@
 		"1:\n\t"
 		"movel	%%d0,%%a0\n\t"
 		"2:\n\t"
-		".word	0xf4e8\n\t"
+		".word	0xf468\n\t"
 		"addl	#0x10,%%a0\n\t"
 		"cmpl	#0x00000800,%%a0\n\t"
 		"blt	2b\n\t"
 		"addql	#1,%%d0\n\t"
 		"cmpil	#4,%%d0\n\t"
 		"bne	1b\n\t"
+		"movel	#0xb6088500,%%d0\n\t"
+		"movec	%%d0,%%CACR\n\t"
 		: : : "d0", "a0" );
 #endif /* CONFIG_M5407 */
 #ifdef CONFIG_M5272
diff -Naur linux-2.6.0-test8/include/asm-m68knommu/elf.h linux-2.6.0-test8-uc0/include/asm-m68knommu/elf.h
--- linux-2.6.0-test8/include/asm-m68knommu/elf.h	2003-10-20 09:11:27.956062856 +1000
+++ linux-2.6.0-test8-uc0/include/asm-m68knommu/elf.h	2003-10-20 09:13:01.848788992 +1000
@@ -9,6 +9,33 @@
 #include <asm/ptrace.h>
 #include <asm/user.h>
 
+/*
+ * 68k ELF relocation types
+ */
+#define R_68K_NONE  0
+#define R_68K_32    1
+#define R_68K_16    2
+#define R_68K_8     3
+#define R_68K_PC32  4
+#define R_68K_PC16  5
+#define R_68K_PC8   6
+#define R_68K_GOT32 7
+#define R_68K_GOT16 8
+#define R_68K_GOT8  9
+#define R_68K_GOT32O    10
+#define R_68K_GOT16O    11
+#define R_68K_GOT8O 12
+#define R_68K_PLT32 13
+#define R_68K_PLT16 14
+#define R_68K_PLT8  15
+#define R_68K_PLT32O    16
+#define R_68K_PLT16O    17
+#define R_68K_PLT8O 18
+#define R_68K_COPY  19
+#define R_68K_GLOB_DAT  20
+#define R_68K_JMP_SLOT  21
+#define R_68K_RELATIVE  22
+
 typedef unsigned long elf_greg_t;
 
 #define ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))
diff -Naur linux-2.6.0-test8/include/asm-m68knommu/kmap_types.h linux-2.6.0-test8-uc0/include/asm-m68knommu/kmap_types.h
--- linux-2.6.0-test8/include/asm-m68knommu/kmap_types.h	2003-10-20 09:11:27.862077144 +1000
+++ linux-2.6.0-test8-uc0/include/asm-m68knommu/kmap_types.h	2003-10-20 09:13:01.991767256 +1000
@@ -13,6 +13,8 @@
 	KM_PTE1,
 	KM_IRQ0,
 	KM_IRQ1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
 	KM_TYPE_NR
 };
 
diff -Naur linux-2.6.0-test8/include/asm-m68knommu/m68360_enet.h linux-2.6.0-test8-uc0/include/asm-m68knommu/m68360_enet.h
--- linux-2.6.0-test8/include/asm-m68knommu/m68360_enet.h	2003-10-20 09:11:27.882074104 +1000
+++ linux-2.6.0-test8-uc0/include/asm-m68knommu/m68360_enet.h	2003-10-20 09:13:01.994766800 +1000
@@ -1,7 +1,4 @@
-/***********************************
- * $Id$
- ***********************************
- *
+/*
  ***************************************
  * Definitions for the ETHERNET controllers
  ***************************************
diff -Naur linux-2.6.0-test8/include/asm-m68knommu/machdep.h linux-2.6.0-test8-uc0/include/asm-m68knommu/machdep.h
--- linux-2.6.0-test8/include/asm-m68knommu/machdep.h	2003-10-20 09:11:27.879074560 +1000
+++ linux-2.6.0-test8-uc0/include/asm-m68knommu/machdep.h	2003-10-20 09:13:01.996766496 +1000
@@ -2,6 +2,7 @@
 #define _M68KNOMMU_MACHDEP_H
 
 #include <linux/seq_file.h>
+#include <linux/interrupt.h>
 
 struct pt_regs;
 struct kbd_repeat;
@@ -10,14 +11,14 @@
 struct gendisk;
 struct buffer_head;
 
-extern void (*mach_sched_init) (void (*handler)(int, void *, struct pt_regs *));
+extern void (*mach_sched_init) (irqreturn_t (*handler)(int, void *, struct pt_regs *));
 /* machine dependent keyboard functions */
 extern int (*mach_keyb_init) (void);
 extern int (*mach_kbdrate) (struct kbd_repeat *);
 extern void (*mach_kbd_leds) (unsigned int);
 /* machine dependent irq functions */
 extern void (*mach_init_IRQ) (void);
-extern void (*(*mach_default_handler)[]) (int, void *, struct pt_regs *);
+extern irqreturn_t (*(*mach_default_handler)[]) (int, void *, struct pt_regs *);
 extern int (*mach_request_irq) (unsigned int irq, void (*handler)(int, void *, struct pt_regs *),
                                 unsigned long flags, const char *devname, void *dev_id);
 extern void (*mach_free_irq) (unsigned int irq, void *dev_id);
diff -Naur linux-2.6.0-test8/include/asm-m68knommu/mcfsmc.h linux-2.6.0-test8-uc0/include/asm-m68knommu/mcfsmc.h
--- linux-2.6.0-test8/include/asm-m68knommu/mcfsmc.h	2003-10-20 09:11:27.880074408 +1000
+++ linux-2.6.0-test8-uc0/include/asm-m68knommu/mcfsmc.h	2003-10-20 09:13:02.023762392 +1000
@@ -21,6 +21,18 @@
 
 #undef	outb
 #undef	inb
+#undef	outw
+#undef	outwd
+#undef	inw	
+#undef	outl
+#undef	inl
+
+#undef	outsb
+#undef	outsw
+#undef	outsl
+#undef	insb
+#undef	insw
+#undef	insl
 
 /*
  *	Re-defines for ColdFire environment... The SMC part is
diff -Naur linux-2.6.0-test8/include/asm-m68knommu/types.h linux-2.6.0-test8-uc0/include/asm-m68knommu/types.h
--- linux-2.6.0-test8/include/asm-m68knommu/types.h	2003-10-20 09:11:27.865076688 +1000
+++ linux-2.6.0-test8-uc0/include/asm-m68knommu/types.h	2003-10-20 09:13:02.041759656 +1000
@@ -1,66 +1 @@
-#ifndef _M68K_TYPES_H
-#define _M68K_TYPES_H
-
-/*
- * This file is never included by application software unless
- * explicitly requested (e.g., via linux/types.h) in which case the
- * application is Linux specific so (user-) name space pollution is
- * not a major issue.  However, for interoperability, libraries still
- * need to be careful to avoid a name clashes.
- */
-
-#ifndef __ASSEMBLY__
-
-typedef unsigned short umode_t;
-
-/*
- * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
- * header files exported to user space
- */
-
-typedef __signed__ char __s8;
-typedef unsigned char __u8;
-
-typedef __signed__ short __s16;
-typedef unsigned short __u16;
-
-typedef __signed__ int __s32;
-typedef unsigned int __u32;
-
-#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
-typedef __signed__ long long __s64;
-typedef unsigned long long __u64;
-#endif
-
-#endif /* __ASSEMBLY__ */
-
-/*
- * These aren't exported outside the kernel to avoid name space clashes
- */
-#ifdef __KERNEL__
-
-#define BITS_PER_LONG 32
-
-#ifndef __ASSEMBLY__
-
-typedef signed char s8;
-typedef unsigned char u8;
-
-typedef signed short s16;
-typedef unsigned short u16;
-
-typedef signed int s32;
-typedef unsigned int u32;
-
-typedef signed long long s64;
-typedef unsigned long long u64;
-
-/* Dma addresses are 32-bits wide.  */
-
-typedef u32 dma_addr_t;
-
-#endif /* __ASSEMBLY__ */
-
-#endif /* __KERNEL__ */
-
-#endif /* _M68K_TYPES_H */
+#include <asm-m68k/types.h>
diff -Naur linux-2.6.0-test8/include/linux/list.h linux-2.6.0-test8-uc0/include/linux/list.h
--- linux-2.6.0-test8/include/linux/list.h	2003-10-20 09:11:18.436510048 +1000
+++ linux-2.6.0-test8-uc0/include/linux/list.h	2003-10-20 09:13:15.424725136 +1000
@@ -3,6 +3,7 @@
 
 #ifdef __KERNEL__
 
+#include <linux/kernel.h>
 #include <linux/stddef.h>
 #include <linux/prefetch.h>
 #include <asm/system.h>
diff -Naur linux-2.6.0-test8/include/linux/mtd/inftl.h linux-2.6.0-test8-uc0/include/linux/mtd/inftl.h
--- linux-2.6.0-test8/include/linux/mtd/inftl.h	2003-10-20 09:11:17.755613560 +1000
+++ linux-2.6.0-test8-uc0/include/linux/mtd/inftl.h	2003-10-20 09:13:16.352584080 +1000
@@ -19,7 +19,7 @@
 #define	SECTORSIZE	512
 
 #ifndef INFTL_MAJOR
-#define INFTL_MAJOR 93 /* FIXME */
+#define INFTL_MAJOR 94
 #endif
 #define INFTL_PARTN_BITS 4
 
diff -Naur linux-2.6.0-test8/mm/nommu.c linux-2.6.0-test8-uc0/mm/nommu.c
--- linux-2.6.0-test8/mm/nommu.c	2003-10-20 09:11:41.792959328 +1000
+++ linux-2.6.0-test8-uc0/mm/nommu.c	2003-10-20 09:13:21.524797784 +1000
@@ -551,6 +551,11 @@
 	return NULL;
 }
 
+struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)
+{
+	return NULL;
+}
+
 int remap_page_range(struct vm_area_struct *vma, unsigned long from,
 		unsigned long to, unsigned long size, pgprot_t prot)
 {
