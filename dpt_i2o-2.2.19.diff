--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/dpti.c	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,3835 @@
+/***************************************************************************
+                          dpti.c  -  description
+                             -------------------
+    begin                : Thu Sep 7 2001
+    copyright            : (C) 2000 by Adaptec
+    email                : deanna_bonds@adaptec.com
+
+    ToDo		 : Investigate why we can't throttle the scsi
+    			   subsystem. It can't handle a condition where
+			   no commands can be issued to the controller.
+			 : If there is no TID for LUN0, but one for LUNx,
+			   we need to fake an inquiry response at LUN0 to x-1
+			   indicating that we support LUNs. This is to
+			   support Fibre and SCSI bridges.
+
+    See README.dpti for history, notes, license info, and credits
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+//#define DEBUG 1
+//#define UARTDELAY 1
+
+
+
+//Define ADDR32 = GFP_DMA for 64 bin architectures.  This provides us with a
+//way to work withing the boundaries of i2o address space limitations -
+//the exception is our own private scsi cmd which can take 64 bit sg
+#define ADDR32 0
+//#define ADDR32 GFP_DMA
+
+#include <linux/autoconf.h>
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#	define MODVERSIONS
+#endif
+
+#if defined MODVERSIONS && defined MODULE
+#	include <linux/modversions.h>
+#endif
+
+#include <linux/version.h>
+
+#ifdef MODULE
+#include <linux/module.h>
+
+MODULE_AUTHOR("Deanna Bonds, with _lots_ of help from Mark Salyzyn");
+MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
+char kernel_version[] = UTS_RELEASE;
+
+#endif
+
+////////////////////////////////////////////////////////////////
+
+#include <linux/ioctl.h>	/* For SCSI-Passthrough */
+#include <asm/uaccess.h>
+
+#include <linux/stat.h>
+#include <linux/malloc.h>	/* for kmalloc() */
+#include <linux/config.h>	/* for CONFIG_PCI */
+#include <linux/pci.h>		/* for PCI support */
+#include <linux/proc_fs.h>
+#include <linux/blk.h>
+#include <linux/delay.h>	/* for udelay */
+#include <linux/tqueue.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>	/* for printk */
+#include <linux/sched.h>
+#include <linux/reboot.h>
+#include <linux/smp_lock.h>
+
+#include <linux/timer.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/stat.h>
+
+#include <asm/processor.h>	/* for boot_cpu_data */
+#include <asm/pgtable.h>
+#include <asm/io.h>		/* for virt_to_bus, etc. */
+
+#include "scsi.h"
+#include "hosts.h"
+#include "sd.h"
+
+#include "dptsig.h"
+#include "dpti.h"
+
+/* Create a binary signature */
+static dpt_sig_S DPTI_sig = {
+	{'d', 'P', 't', 'S', 'i', 'G'}, SIG_VERSION,
+#ifdef __i386__
+	PROC_INTEL, PROC_386 | PROC_486 | PROC_PENTIUM | PROC_SEXIUM,
+#elif defined __ia64__
+	PROC_INTEL, PROC_IA64,
+#elif define __sparc__
+	PROC_ULTRASPARC,
+#elif defined(__alpha__)
+	PROC_ALPHA ,
+#else
+#error This has not been ported to your architecture
+#endif
+	 FT_HBADRVR, 0, OEM_DPT, OS_LINUX, CAP_OVERLAP, DEV_ALL,
+	ADF_ALL_SC5, 0, 0, DPT_VERSION, DPT_REVISION, DPT_SUBREVISION,
+	DPT_MONTH, DPT_DAY, DPT_YEAR, "Adaptec Linux I2O RAID Driver"
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,00)
+static struct semaphore adpt_configuration_lock = MUTEX;
+#else
+DECLARE_MUTEX(adpt_configuration_lock);
+#endif
+static struct i2o_sys_tbl *sys_tbl = NULL;
+static int sys_tbl_ind = 0;
+static int sys_tbl_len = 0;
+/*
+ * The method for determining if PCI is present was changed in the 2.1.xx tree.
+ */
+#define NEWPCI_VERSION	KERNEL_VERSION(2,1,92)
+
+static adpt_hba* hbas[DPTI_MAX_HBA];
+static adpt_hba* hba_chain = NULL;
+static int hba_count = 0;
+
+// Debug flags to be put into the HBA flags field when initialized
+// Make sure to enable DEBUG_PRINT for these flags to work
+unsigned long DebugFlags = HBA_FLAGS_DBG_SCAN_B | HBA_FLAGS_DBG_FLAGS_MASK;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,00)
+// If this is driver is embedded in the kernel this define
+// should be moved to include/linux/proc_fs.h as an emumerated type
+#define PROC_SCSI_DPT_I2O  0
+struct proc_dir_entry proc_scsi_dptI2O = {
+	PROC_SCSI_DPT_I2O, 7, DPT_DRIVER,
+	S_IFDIR | S_IRUGO | S_IXUGO, 2,
+	0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+};
+#endif
+
+static struct file_operations adpt_fops = {
+	ioctl: adpt_ioctl,
+	open: adpt_open,
+	release: adpt_close
+};
+
+#ifdef REBOOT_NOTIFIER
+static struct notifier_block adpt_reboot_notifier =
+{
+	 adpt_reboot_event,
+	 NULL,
+	 0
+};
+#endif
+
+inline u32 adpt_getBlinkLED(adpt_hba* host)
+{
+	return (host->FwDebugBLEDflag_P && (volatile u32)(*(host->FwDebugBLEDflag_P)) == 0xbc) ?
+			host->FwDebugBLEDvalue_P[0] : 0;
+}
+
+inline struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u32 lun)
+{
+
+	struct adpt_device* d;
+
+	if( pHba->channel[chan].device == NULL){
+		printk(KERN_ERR"Adaptec I2O RAID: Trying to find device before they are allocated\n");
+		return NULL;
+	}
+
+	d = pHba->channel[chan].device[id];
+	if(!d || d->tid == 0) {
+		return NULL;
+	}
+
+	if(d->scsi_lun == lun){
+		return d;
+	}
+
+	for(d=d->next_lun ; d ; d = d->next_lun){
+		if(d->scsi_lun == lun){
+			return d;
+		}
+	}
+
+	return NULL;
+}
+
+///////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////
+//				Functions
+///////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+
+Scsi_Host_Template driver_template = DPT_I2O;
+#include "scsi_module.c"
+
+#else
+#ifdef MODULE 
+
+Scsi_Host_Template driver_template = DPT_I2O;
+#include "scsi_module.c"
+
+#endif
+#endif
+
+
+static int adpt_i2o_systab_send(adpt_hba* pHba)
+{
+	 u32 msg[12];
+	 int ret;
+
+	msg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;
+	msg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;
+	msg[2] = 0;
+	msg[3] = 0;
+	msg[4] = (0<<16) | ((pHba->unit+2) << 12); /* Host 0 IOP ID (unit + 2) */
+	msg[5] = 0;				   /* Segment 0 */
+
+	/* 
+	 * Provide three SGL-elements:
+	 * System table (SysTab), Private memory space declaration and 
+	 * Private i/o space declaration  
+	 */
+	msg[6] = 0x54000000 | sys_tbl_len;
+	msg[7] = virt_to_phys(sys_tbl);
+	msg[8] = 0x54000000 | 0;
+	msg[9] = 0;
+	msg[10] = 0xD4000000 | 0;
+	msg[11] = 0;
+
+	if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {
+		printk(KERN_INFO "%s: Unable to set SysTab (status=%#10x).\n", 
+			pHba->name, ret);
+	}
+#ifdef DEBUG
+	else {
+		PINFO("%s: SysTab set.\n", pHba->name);
+	}
+#endif
+
+	return ret;	
+ }
+
+
+void adpt_i2o_sys_shutdown(void)
+{
+	adpt_hba *pHba, *pNext;
+
+	 printk(KERN_INFO "Shutting down Adaptec I2O controllers.\n");
+	 printk(KERN_INFO
+		  "   This could take a few minutes if there are many devices attached\n");
+	/* Delete all IOPs from the controller chain */
+	for (pHba = hba_chain; pHba; pHba = pNext) {
+		pNext = pHba->next;
+		adpt_i2o_delete_hba(pHba);
+	}
+
+	 printk(KERN_INFO "Adaptec I2O controllers down.\n");
+}
+
+/*
+ * reboot/shutdown notification.
+ *
+ * - Quiesce each IOP in the system
+ *
+ */
+
+#ifdef REBOOT_NOTIFIER
+int adpt_reboot_event(struct notifier_block *n, unsigned long code, void *p)
+{
+
+	 if(code != SYS_RESTART && code != SYS_HALT && code != SYS_POWER_OFF)
+		  return NOTIFY_DONE;
+
+	 adpt_i2o_sys_shutdown();
+
+	 return NOTIFY_DONE;
+}
+#endif
+
+
+int adpt_install_hba(Scsi_Host_Template* sht, struct pci_dev* pDev) 
+{
+
+	adpt_hba* pHba = NULL;
+	adpt_hba* p = NULL;
+	caddr_t base_addr0_phys = NULL;
+	caddr_t base_addr1_phys = NULL;
+	u32 hba_map0_area_size = 0;
+	u32 hba_map1_area_size = 0;
+	caddr_t base_addr_virt = NULL;
+	caddr_t msg_addr_virt = NULL;
+
+	int raptorFlag = FALSE;
+	int i;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	if(pci_enable_device(pDev)) {
+		return -EINVAL;
+	}
+	pci_set_master(pDev);
+
+	base_addr0_phys = (caddr_t)pci_resource_start(pDev,0);
+	hba_map0_area_size = pci_resource_len(pDev,0);
+
+	// Check if standard PCI card or single BAR Raptor
+	if(pDev->device == PCI_DPT_DEVICE_ID){
+		if(pDev->subsystem_device >=0xc032 && pDev->subsystem_device <= 0xc03b){
+			// Raptor card with this device id needs 4M
+			hba_map0_area_size = 0x400000;
+		} else { // Not Raptor - it is a PCI card
+			if(hba_map0_area_size > 0x100000 ){ 
+				hba_map0_area_size = 0x100000;
+			}
+		}
+	} else {// Raptor split BAR config
+		// Use BAR1 in this configuration
+		base_addr1_phys = (caddr_t)pci_resource_start(pDev,1);
+		hba_map1_area_size = pci_resource_len(pDev,1);
+		raptorFlag = TRUE;
+	}
+
+
+#else
+	u16 command = 0;
+	u16 subdevice = 0;
+
+	// Read in the command register and make sure that the device is 
+	// enabled and set up for bus master                             
+	pci_read_config_word(pDev, PCI_COMMAND, &command);
+	if(((command & PCI_COMMAND_MEMORY) && !(command & PCI_COMMAND_MASTER))){
+		command |= PCI_COMMAND_MASTER;
+		pci_write_config_word(pDev, PCI_COMMAND, command);
+	}
+
+	pci_read_config_dword(pDev, PCI_BASE_ADDRESS_0,(u32*)&base_addr0_phys);
+	// To get the size of the memory space taken we have to write out
+	// 0xffffffff (32 bit) to the base register (PCI_BASE_ADDRESS_0)
+	// and then read it back. The lower 4 bits are ignored not needed.
+	// They contain address space flag (io or memory) 
+	// and memory type (32 1M 64)
+	// The Rest is used to determine the size of memory space
+	// used. All other upper bits will be set to ones. 
+	// If we take the negative of this number and add one
+	// it will give us the memory size. We must also write the original
+	// Base address back out to reset it up.
+	pci_write_config_dword(pDev, PCI_BASE_ADDRESS_0 , 0xffffffff);
+	pci_read_config_dword(pDev, PCI_BASE_ADDRESS_0 , &hba_map0_area_size);
+
+	// Restore the base address
+	pci_write_config_dword(pDev, PCI_BASE_ADDRESS_0 , (u32)base_addr0_phys);
+	(u32)base_addr0_phys &= PCI_BASE_ADDRESS_MEM_MASK;
+
+	// Take the negative, disreguard the bottem four bits and add 1
+	hba_map0_area_size &= PCI_BASE_ADDRESS_MEM_MASK;	// And out the lower 4 bits
+	hba_map0_area_size = ~hba_map0_area_size + 1;	// Take the negative and add 1
+
+	pci_read_config_word (pDev, PCI_SUBSYSTEM_ID, &subdevice);
+
+	if(pDev->device == PCI_DPT_DEVICE_ID){
+		// Raptor card with this device id  needs 4M
+		if(subdevice >= 0xc032 && subdevice <= 0xc03b){ 
+			hba_map0_area_size = 0x400000;
+		} else {
+			if(hba_map0_area_size > 0x100000) { // Only give 'em 1M
+				hba_map0_area_size = 0x100000;
+			}
+		}
+	} else {
+		//Use BAR1 in this config
+		pci_read_config_dword(pDev,PCI_BASE_ADDRESS_1, (u32*)&base_addr1_phys);
+		pci_write_config_dword(pDev,PCI_BASE_ADDRESS_1, 0xffffffff);
+		pci_read_config_dword(pDev,PCI_BASE_ADDRESS_1, &hba_map1_area_size);
+
+		//Restore the base address
+		pci_write_config_dword(pDev,PCI_BASE_ADDRESS_1, (u32)base_addr1_phys);
+		(u32)base_addr1_phys &= PCI_BASE_ADDRESS_MEM_MASK;
+		hba_map1_area_size &= PCI_BASE_ADDRESS_MEM_MASK;
+		hba_map1_area_size = ~hba_map1_area_size + 1;
+		
+		raptorFlag=TRUE;
+	}
+#endif
+
+	base_addr_virt = ioremap((long)base_addr0_phys,(long)hba_map0_area_size);
+	if(base_addr_virt == NULL) {
+		PERROR("dpti: adpt_config_hba: io remap failed\n");
+		return -EINVAL;
+	}
+
+        if(raptorFlag == TRUE) {
+		msg_addr_virt = ioremap((long)base_addr1_phys, (long)hba_map1_area_size );
+		if(msg_addr_virt == NULL) {
+			PERROR("dpti: adpt_config_hba: io remap failed on BAR1\n");
+			return -EINVAL;
+		}
+	} else {
+		msg_addr_virt = base_addr_virt;
+	}
+	
+	// Allocate and zero the data structure
+	if( (pHba = kmalloc(sizeof(adpt_hba), GFP_KERNEL)) == NULL) {
+		iounmap(base_addr_virt);
+		return -ENOMEM;
+	}
+	memset(pHba, 0, sizeof(adpt_hba));
+
+	down(&adpt_configuration_lock);
+	for(i=0;i<DPTI_MAX_HBA;i++) {
+		if(hbas[i]==NULL) {
+			hbas[i]=pHba;
+			break;
+		}
+	}
+
+	if(hba_chain != NULL){
+		for(p = hba_chain; p->next; p = p->next);
+		p->next = pHba;
+	} else {
+		hba_chain = pHba;
+	}
+	pHba->next = NULL;
+//	pHba->next=hba_chain;
+//	hba_chain=pHba;
+	pHba->unit = hba_count;
+	sprintf(pHba->name, "dpti%d", i);
+	hba_count++;
+	
+	up(&adpt_configuration_lock);
+
+	pHba->pDev = pDev;
+	pHba->base_addr_phys = base_addr0_phys;
+
+	// Set up the Virtual Base Address of the I2O Device
+	pHba->base_addr_virt = base_addr_virt;
+	pHba->msg_addr_virt = msg_addr_virt;  
+	pHba->irq_mask = (ulong)(base_addr_virt+0x30);
+	pHba->post_port = (ulong)(base_addr_virt+0x40);
+	pHba->reply_port = (ulong)(base_addr_virt+0x44);
+
+	pHba->hrt = NULL;
+	pHba->lct = NULL;
+	pHba->lct_size = 0;
+	pHba->status_block = NULL;
+	pHba->post_count = 0;
+	pHba->state = DPTI_STATE_RESET;
+	pHba->pDev = pDev;
+	pHba->devices = NULL;
+
+	// Initializing the spinlocks
+	spin_lock_init(&pHba->state_lock);
+
+	if(raptorFlag == 0){
+		printk(KERN_INFO"Adaptec I2O RAID controller %d at %p size=%x irq=%d\n", 
+			hba_count-1, base_addr_virt, hba_map0_area_size, pDev->irq);
+	} else {
+		printk(KERN_INFO"Adaptec I2O RAID controller %d irq=%d\n",hba_count-1, pDev->irq);
+		printk(KERN_INFO"     BAR0 %p - size= %x\n",base_addr_virt,hba_map0_area_size);
+		printk(KERN_INFO"     BAR1 %p - size= %x\n",msg_addr_virt,hba_map1_area_size);
+
+	}
+
+	if (request_irq (pDev->irq, adpt_isr, SA_SHIRQ, pHba->name, pHba)) {
+		printk(KERN_ERR"%s: Couldn't register IRQ %d\n", pHba->name, pDev->irq);
+		adpt_i2o_delete_hba(pHba);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+void adpt_i2o_delete_hba(adpt_hba* pHba)
+{
+	adpt_hba* p1;
+	adpt_hba* p2;
+	struct i2o_device* d;
+	struct i2o_device* next;
+	int i;
+	int j;
+	struct adpt_device* pDev;
+	struct adpt_device* pNext;
+
+
+	down(&adpt_configuration_lock);
+	// scsi_unregister calls our adpt_release which
+	// does a quiese
+	if(pHba->host){
+		free_irq(pHba->host->irq, pHba);
+	}
+	for(i=0;i<DPTI_MAX_HBA;i++) {
+		if(hbas[i]==pHba) {
+			hbas[i] = NULL;
+		}
+	}
+	p2 = NULL;
+	for( p1 = hba_chain; p1; p2 = p1,p1=p1->next){
+		if(p1 == pHba) {
+			if(p2) {
+				p2->next = p1->next;
+			} else {
+				hba_chain = p1->next;
+			}
+			break;
+		}
+	}
+
+	hba_count--;
+	up(&adpt_configuration_lock);
+
+	iounmap(pHba->base_addr_virt);
+	if(pHba->msg_addr_virt != pHba->base_addr_virt){
+		iounmap(pHba->msg_addr_virt);
+	}
+	if(pHba->hrt) {
+		kfree(pHba->hrt);
+	}
+	if(pHba->lct){
+		kfree(pHba->lct);
+	}
+	if(pHba->status_block) {
+		kfree(pHba->status_block);
+	}
+	if(pHba->reply_pool){
+		kfree(pHba->reply_pool);
+	}
+
+	for(d = pHba->devices; d ; d = next){
+		next = d->next;
+		kfree(d);
+	}
+	for(i = 0 ; i < pHba->top_scsi_channel ; i++){
+		for(j = 0; j < MAX_ID; j++){
+			if(pHba->channel[i].device[j] != NULL){
+				for(pDev = pHba->channel[i].device[j]; pDev; pDev = pNext){
+					pNext = pDev->next_lun;
+					kfree(pDev);
+				}
+			}
+		}
+	}
+
+	kfree(pHba);
+
+	if(hba_count <= 0){
+		unregister_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER);   
+	}
+}
+
+
+
+/* 
+ * Enable IOP. Allows the IOP to resume external operations.
+ */
+int adpt_i2o_enable_hba(adpt_hba* pHba)
+{
+	u32 msg[4];
+	int ret;
+	
+	adpt_i2o_status_get(pHba);
+	if(!pHba->status_block){
+		return -ENOMEM;
+	}
+	/* Enable only allowed on READY state */
+	if(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)
+		return 0;
+
+	if(pHba->status_block->iop_state != ADAPTER_STATE_READY)
+		return -EINVAL;
+
+	msg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[2]= 0;
+	msg[3]= 0;
+
+	/* How long of a timeout do we need? */
+
+	if ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {
+		printk(KERN_ERR "%s: Could not enable (status=%#10x).\n", 
+			pHba->name, ret);
+	} else {
+		printk(KERN_INFO "%s: Enabled.\n", pHba->name);
+	}
+
+	adpt_i2o_status_get(pHba);
+	return ret;
+}
+
+
+/*
+ *	Bring a controller online into OPERATIONAL state. 
+ */
+ 
+int adpt_i2o_online_hba(adpt_hba* pHba)
+{
+	if (adpt_i2o_systab_send(pHba) < 0) {
+		adpt_i2o_delete_hba(pHba);
+		return -1;
+	}
+	/* In READY state */
+
+	if (adpt_i2o_enable_hba(pHba) < 0) {
+		adpt_i2o_delete_hba(pHba);
+		return -1;
+	}
+
+	/* In OPERATIONAL state  */
+	return 0;
+}
+
+
+// This function is called by the OS at initalization time. The system  
+// is scanned For HBAs. Once an HBA is found various structures are
+// set up for the HBA and a list of all devices on the HBA is generated.
+// Once all HBAs are found, a device lookup table is set up and then
+// each HBA is enabled and presented to the OS.
+
+
+int adpt_detect(Scsi_Host_Template* sht)
+{
+	struct pci_dev *pDev = NULL;
+	adpt_hba* pHba;
+
+	adpt_init();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,00)
+	sht->proc_dir = &proc_scsi_dptI2O;
+#endif
+	sht->use_new_eh_code = 1;
+
+	PINFO("Detecting Adaptec I2O RAID controllers...\n");
+
+        /* search for all Adatpec I2O RAID cards */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	while ((pDev = pci_find_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
+		if(pDev->device == PCI_DPT_DEVICE_ID ||
+		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
+			if(adpt_install_hba(sht, pDev) ){
+				PERROR("Could not Init an I2O RAID device\n");
+				PERROR("Will not try to detect others.\n");
+				return hba_count-1;
+			}
+		}
+	}
+#else
+	while ((pDev = adpt_pci_find_device( PCI_DPT_VENDOR_ID, pDev))) {
+		if(pDev->device == PCI_DPT_DEVICE_ID ||
+		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
+			if(adpt_install_hba(sht, pDev) ){
+				PERROR("Could not Init an I2O RAID device\n");
+				PERROR("Will not try to detect others.\n");
+				return hba_count-1;
+			}
+		}
+	}
+#endif
+
+	/* In INIT state, Activate IOPs */
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		// Activate does get status , init outbound, and get hrt
+		if (adpt_i2o_activate_hba(pHba) < 0) {
+			adpt_i2o_delete_hba(pHba);
+		}
+	}
+
+
+	/* Active IOPs in HOLD state */
+
+rebuild_sys_tab:
+	if (hba_chain == NULL) 
+		return 0;
+
+	/*
+	 * If build_sys_table fails, we kill everything and bail
+	 * as we can't init the IOPs w/o a system table
+	 */	
+	if (adpt_i2o_build_sys_table() < 0) {
+		adpt_i2o_sys_shutdown();
+		return 0;
+	}
+
+	PDEBUG("HBA's in HOLD state\n");
+
+	/* If IOP don't get online, we need to rebuild the System table */
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (adpt_i2o_online_hba(pHba) < 0) {
+			adpt_i2o_delete_hba(pHba);	
+			goto rebuild_sys_tab;
+		}
+	}
+
+	/* Active IOPs now in OPERATIONAL state */
+	PDEBUG("HBA's in OPERATIONAL state\n");
+
+	printk("dpti: If you have a lot of devices this could take a few minutes.\n");
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		printk("%s: Reading the hardware resource table.\n", pHba->name);
+		if (adpt_i2o_lct_get(pHba) < 0){
+			adpt_i2o_delete_hba(pHba);
+			continue;
+		}
+
+		if (adpt_i2o_parse_lct(pHba) < 0){
+			adpt_i2o_delete_hba(pHba);
+			continue;
+		}
+		adpt_inquiry(pHba);
+	}
+
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if( adpt_scsi_register(pHba,sht) < 0){
+			adpt_i2o_delete_hba(pHba);
+			continue;
+		}
+		pHba->initialized = TRUE;
+		pHba->state &= ~DPTI_STATE_RESET;
+	}
+
+	// Register our control device node
+	// nodes will need to be created in /dev to access this
+	// the nodes can not be created from within the driver
+	if (hba_count && register_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER, &adpt_fops)) {
+		adpt_i2o_sys_shutdown();
+		return 0;
+	}
+	return hba_count;
+}
+
+
+int adpt_init(void)
+{
+	int i;
+
+	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
+	for (i = 0; i < DPTI_MAX_HBA; i++) {
+		hbas[i] = NULL;
+	}
+#ifdef REBOOT_NOTIFIER
+	register_reboot_notifier(&adpt_reboot_notifier);
+#endif
+
+	return 0;
+}
+
+/* Structures and definitions for synchronous message posting.
+ * See adpt_i2o_post_wait() for description
+ * */
+struct adpt_i2o_post_wait_data
+{
+	int status;
+	u32 id;
+	adpt_wait_queue_head_t *wq;
+	struct adpt_i2o_post_wait_data *next;
+};
+
+static struct adpt_i2o_post_wait_data *adpt_post_wait_queue = NULL;
+static u32 adpt_post_wait_id = 0;
+static spinlock_t adpt_post_wait_lock = SPIN_LOCK_UNLOCKED;
+static void adpt_i2o_post_wait_complete(u32, int);
+
+int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout)
+{
+	ADPT_DECLARE_WAIT_QUEUE_HEAD(adpt_wq_i2o_post);
+	int status = 0;
+	ulong flags = 0;
+	struct adpt_i2o_post_wait_data *p1, *p2;
+	struct adpt_i2o_post_wait_data *wait_data =
+		kmalloc(sizeof(struct adpt_i2o_post_wait_data),GFP_KERNEL);
+	adpt_wait_queue_t wait;
+
+	if(!wait_data){
+		return -ENOMEM;
+	}
+	/*
+	 * The spin locking is needed to keep anyone from playing
+	 * with the queue pointers and id while we do the same
+	 */
+	spin_lock_irqsave(&adpt_post_wait_lock, flags);
+       // TODO we need a MORE unique way of getting ids
+       // to support async LCT get
+	wait_data->next = adpt_post_wait_queue;
+	adpt_post_wait_queue = wait_data;
+	adpt_post_wait_id = (++adpt_post_wait_id & 0x7fff);
+	wait_data->id =  adpt_post_wait_id;
+	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
+
+	wait_data->wq = &adpt_wq_i2o_post;
+	wait_data->status = -ETIMEDOUT;
+
+	// this code is taken from kernel/sched.c:interruptible_sleep_on_timeout
+	wait.task = current;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	write_lock_irqsave(&waitqueue_lock,flags);
+	__add_wait_queue(&adpt_wq_i2o_post, &wait);
+	write_unlock(&waitqueue_lock);
+#else
+	init_waitqueue_entry(&wait, current);
+	wq_write_lock_irqsave(&adpt_wq_i2o_post.lock,flags);
+	__add_wait_queue(&adpt_wq_i2o_post, &wait);
+	wq_write_unlock(&adpt_wq_i2o_post.lock);
+#endif
+
+	msg[2] |= 0x80000000 | ((u32)wait_data->id);
+	timeout *= HZ;
+	if((status = adpt_i2o_post_this(pHba, msg, len)) == 0){
+		if(!timeout){
+			current->state = TASK_INTERRUPTIBLE;
+			spin_unlock_irq(&io_request_lock);
+			schedule();
+			spin_lock_irq(&io_request_lock);
+		} else {
+			current->state = TASK_INTERRUPTIBLE;
+			spin_unlock_irq(&io_request_lock);
+			schedule_timeout(timeout*HZ);
+			spin_lock_irq(&io_request_lock);
+		}
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	write_lock_irq(&waitqueue_lock);
+	__remove_wait_queue(&adpt_wq_i2o_post, &wait);
+	write_unlock_irqrestore(&waitqueue_lock,flags);
+#else
+	wq_write_lock_irq(&adpt_wq_i2o_post.lock);
+	__remove_wait_queue(&adpt_wq_i2o_post, &wait);
+	wq_write_unlock_irqrestore(&adpt_wq_i2o_post.lock,flags);
+#endif
+
+	if(status == -ETIMEDOUT)
+		printk("dpti%d: POST WAIT TIMEOUT\n",pHba->unit);
+
+	/* Remove the entry from the queue.  */
+	p2 = NULL;
+	spin_lock_irqsave(&adpt_post_wait_lock, flags);
+	for(p1 = adpt_post_wait_queue; p1; p2 = p1, p1 = p1->next) {
+		if(p1 == wait_data) {
+			if(p2)
+				p2->next = p1->next;
+			else
+				adpt_post_wait_queue = p1->next;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
+	kfree(wait_data);
+	return status;
+}
+
+
+s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)
+{
+
+	u32 m = EMPTY_QUEUE;
+	u32 *msg;
+	u32 timeout = jiffies + 30*HZ;
+	do {
+		rmb();
+		m = readl(pHba->post_port);
+		if (m != EMPTY_QUEUE) {
+			break;
+		}
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR 
+				"dpti%d: Timeout waiting for message frame!\n", 
+					pHba->unit);
+			return -ETIMEDOUT;
+		}
+	} while(m == EMPTY_QUEUE);
+		
+	msg = (u32*) (pHba->msg_addr_virt + m);
+	memcpy_toio(msg, data, len);
+	wmb();
+
+	//post message
+	writel(m, pHba->post_port);
+	wmb();
+
+	return 0;
+}
+
+
+static void adpt_i2o_post_wait_complete(u32 context, int status)
+{
+	struct adpt_i2o_post_wait_data *p1 = NULL;
+	/*
+	 * We need to search through the adpt_post_wait
+	 * queue to see if the given message is still
+	 * outstanding.  If not, it means that the IOP
+	 * took longer to respond to the message than we
+	 * had allowed and timer has already expired.
+	 * Not much we can do about that except log
+	 * it for debug purposes, increase timeout, and recompile
+	 *
+	 * Lock needed to keep anyone from moving queue pointers
+	 * around while we're looking through them.
+	 */
+
+	context &= 0x7fff;
+
+	spin_lock(&adpt_post_wait_lock);
+	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
+		if(p1->id == context) {
+			p1->status = status;
+			spin_unlock(&adpt_post_wait_lock);
+			wake_up_interruptible(p1->wq);
+			return;
+		}
+	}
+	spin_unlock(&adpt_post_wait_lock);
+        // If this happens we loose commands that probably really completed
+	printk(KERN_ERR"dpti: Could Not find task %d in wait queue\n",context);
+	printk(KERN_ERR"      Tasks in wait queue:\n");
+	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
+		printk(KERN_ERR"           %d\n",p1->id);
+	}
+	return;
+}
+
+/*
+ *	Bring an I2O controller into HOLD state. See the spec.
+ */
+int adpt_i2o_activate_hba(adpt_hba* pHba)
+{
+	int rcode;
+
+	if(pHba->initialized ) {
+		if (adpt_i2o_status_get(pHba) < 0) {
+			if((rcode = adpt_i2o_reset_hba(pHba) != 0)){
+				printk(KERN_WARNING"%s: Could NOT reset.\n", pHba->name);
+				return rcode;
+			}
+			if (adpt_i2o_status_get(pHba) < 0) {
+				printk(KERN_INFO "HBA not responding.\n");
+				return -1;
+			}
+		}
+
+		if(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {
+			printk(KERN_CRIT "%s: hardware fault\n", pHba->name);
+			return -1;
+		}
+
+		if (pHba->status_block->iop_state == ADAPTER_STATE_READY ||
+		    pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||
+		    pHba->status_block->iop_state == ADAPTER_STATE_HOLD ||
+		    pHba->status_block->iop_state == ADAPTER_STATE_FAILED) {
+			adpt_i2o_reset_hba(pHba);			
+			if (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {
+				printk(KERN_CRIT "%s: Failed to initialize.\n", pHba->name);
+				return -1;
+			}
+		}
+	} else {
+		if((rcode = adpt_i2o_reset_hba(pHba) != 0)){
+			printk(KERN_WARNING"%s: Could NOT reset.\n", pHba->name);
+			return rcode;
+		}
+
+	}
+
+	if (adpt_i2o_init_outbound_q(pHba) < 0) {
+		return -1;
+	}
+
+	/* In HOLD state */
+	
+	if (adpt_i2o_hrt_get(pHba) < 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+
+s32 adpt_i2o_reset_hba(adpt_hba* pHba)			
+{
+	u32 msg[8];
+	u8* status;
+	u32 m = EMPTY_QUEUE ;
+	u32 timeout = jiffies + (TMOUT_IOPRESET*HZ);
+
+	if(pHba->initialized  == FALSE) {	// First time reset should be quick
+		timeout = jiffies + (25*HZ);
+	} else {
+		adpt_i2o_quiesce_hba(pHba);
+	}
+
+	do {
+		rmb();
+		m = readl(pHba->post_port);
+		if (m != EMPTY_QUEUE) {
+			break;
+		}
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR "Timeout waiting for message!\n");
+			return -ETIMEDOUT;
+		}
+	} while (m == EMPTY_QUEUE);
+
+	status = (u8*)kmalloc(4, GFP_KERNEL|ADDR32);
+	if(status == NULL) {
+		adpt_send_nop(pHba, m);
+		printk(KERN_ERR"IOP reset failed - no free memory.\n");
+		return -ENOMEM;
+	}
+	memset(status,0,4);
+
+	msg[0]=EIGHT_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1]=I2O_CMD_ADAPTER_RESET<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[2]=0;
+	msg[3]=0;
+	msg[4]=0;
+	msg[5]=0;
+	msg[6]=virt_to_bus(status);
+	msg[7]=0;     
+
+	memcpy_toio(pHba->msg_addr_virt+m, msg, sizeof(msg));
+	wmb();
+	writel(m, pHba->post_port);
+	wmb();
+
+	while((volatile u8)*status == 0){
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR"%s: IOP Reset Timeout\n",pHba->name);
+			kfree(status);
+			return -ETIMEDOUT;
+		}
+		rmb();
+	}
+
+	if((volatile u8)*status == 0x01 /*I2O_EXEC_IOP_RESET_IN_PROGRESS*/) {
+		printk(KERN_INFO"%s: Reset in progress...\n", pHba->name);
+		// Here we wait for message frame to become available
+		// indicated that reset has finished
+		do {
+			rmb();
+			m = readl(pHba->post_port);
+			if (m != EMPTY_QUEUE) {
+				break;
+			}
+			if(time_after(jiffies,timeout)){
+				printk(KERN_ERR "%s:Timeout waiting for IOP Reset.\n",pHba->name);
+				return -ETIMEDOUT;
+			}
+		} while (m == EMPTY_QUEUE);
+		// Flush the offset
+		adpt_send_nop(pHba, m);
+	}
+	adpt_i2o_status_get(pHba);
+	if(*status == 0x02 ||
+			pHba->status_block->iop_state != ADAPTER_STATE_RESET) {
+		printk(KERN_WARNING"%s: Reset reject, trying to clear\n",
+				pHba->name);
+	} else {
+		printk(KERN_INFO"%s: Reset completed.\n",
+				pHba->name);
+	}
+
+	kfree(status);
+#ifdef UARTDELAY
+	adpt_delay(20000);
+#endif
+	return 0;
+}
+
+s32 adpt_i2o_quiesce_hba(adpt_hba* pHba)
+{
+	u32 msg[4];
+	int ret;
+
+	adpt_i2o_status_get(pHba);
+
+	/* SysQuiesce discarded if IOP not in READY or OPERATIONAL state */
+
+	if((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&
+   	   (pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){
+		return 0;
+	}
+
+	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[2] = 0;
+	msg[3] = 0;
+
+	if((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {
+		printk("dpti%d: Unable to quiesce (status=%#x).\n",
+				pHba->unit, -ret);
+	} else {
+		printk("dpti%d: Quiesced.\n",pHba->unit);
+	}
+
+	adpt_i2o_status_get(pHba);
+	return ret;
+}
+
+s32 adpt_i2o_status_get(adpt_hba* pHba)
+{
+	u32 timeout;
+	u32 m;
+	volatile u32 *msg;
+	volatile u8 *status_block=NULL;
+	caddr_t status_block_bus;
+
+	if(pHba->status_block == NULL) {
+		pHba->status_block = (i2o_status_block*)
+			kmalloc(sizeof(i2o_status_block),GFP_KERNEL|ADDR32);
+		if(pHba->status_block == NULL) {
+			printk(KERN_ERR
+			"dpti%d: Get Status Block failed; Out of memory. \n", 
+			pHba->unit);
+			return -ENOMEM;
+		}
+	}
+	memset(pHba->status_block, 0, sizeof(i2o_status_block));
+	status_block = (u8*)(pHba->status_block);
+	status_block_bus =(caddr_t) virt_to_bus(pHba->status_block);
+	timeout = jiffies+TMOUT_GETSTATUS*HZ;
+	do {
+		rmb();
+		m = readl(pHba->post_port);
+		if (m != EMPTY_QUEUE) {
+			break;
+		}
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR "%s: Timeout waiting for message !\n",
+					pHba->name);
+			return -ETIMEDOUT;
+		}
+	} while(m==EMPTY_QUEUE);
+
+	
+	msg=(u32*)(pHba->msg_addr_virt+m);
+
+	writel(NINE_WORD_MSG_SIZE|SGL_OFFSET_0, &msg[0]);
+	writel(I2O_CMD_STATUS_GET<<24|HOST_TID<<12|ADAPTER_TID, &msg[1]);
+	writel(1, &msg[2]);
+	writel(0, &msg[3]);
+	writel(0, &msg[4]);
+	writel(0, &msg[5]);
+	writel(((u32)status_block_bus)&0xffffffff, &msg[6]);
+	writel(0, &msg[7]);
+	writel(sizeof(i2o_status_block), &msg[8]); // 88 bytes
+
+	//post message
+	writel(m, pHba->post_port);
+	wmb();
+
+	while(status_block[87]!=0xff){
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR"dpti%d: Get status timeout.\n",
+				pHba->unit);
+			return -ETIMEDOUT;
+		}
+		rmb();
+	}
+
+	// Set up our number of outbound and inbound messages
+	pHba->post_fifo_size = pHba->status_block->max_inbound_frames;
+	if (pHba->post_fifo_size > MAX_TO_IOP_MESSAGES) {
+		pHba->post_fifo_size = MAX_TO_IOP_MESSAGES;
+	}
+
+	pHba->reply_fifo_size = pHba->status_block->max_outbound_frames;
+	if (pHba->reply_fifo_size > MAX_FROM_IOP_MESSAGES) {
+		pHba->reply_fifo_size = MAX_FROM_IOP_MESSAGES;
+	}
+
+	// Calculate the Scatter Gather list size
+	pHba->sg_tablesize = (pHba->status_block->inbound_frame_size * 4 -40)/ sizeof(struct sg_simple_element);
+	if (pHba->sg_tablesize > SG_LIST_ELEMENTS) {
+		pHba->sg_tablesize = SG_LIST_ELEMENTS;
+	}
+
+
+#ifdef DEBUG
+	printk("dpti%d: State = ",pHba->unit);
+	switch(pHba->status_block->iop_state) {
+		case 0x01:
+			printk("INIT\n");
+			break;
+		case 0x02:
+			printk("RESET\n");
+			break;
+		case 0x04:
+			printk("HOLD\n");
+			break;
+		case 0x05:
+			printk("READY\n");
+			break;
+		case 0x08:
+			printk("OPERATIONAL\n");
+			break;
+		case 0x10:
+			printk("FAILED\n");
+			break;
+		case 0x11:
+			printk("FAULTED\n");
+			break;
+		default:
+			printk("%x (unknown!!)\n",pHba->status_block->iop_state);
+	}
+#endif
+	return 0;
+}
+
+
+s32 adpt_i2o_hrt_get(adpt_hba* pHba)
+{
+	u32 msg[6];
+	int ret, size = sizeof(i2o_hrt);
+
+	do {
+		if (pHba->hrt == NULL) {
+			pHba->hrt=kmalloc(size, GFP_KERNEL|ADDR32);
+			if (pHba->hrt == NULL) {
+				printk(KERN_CRIT "%s: Hrt Get failed; Out of memory.\n", pHba->name);
+				return -ENOMEM;
+			}
+		}
+
+		msg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;
+		msg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;
+		msg[2]= 0;
+		msg[3]= 0;
+		msg[4]= (0xD0000000 | size);    /* Simple transaction */
+		msg[5]= virt_to_bus(pHba->hrt);   /* Dump it here */
+
+		if ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {
+			printk(KERN_ERR "%s: Unable to get HRT (status=%#10x)\n", pHba->name, ret);
+			return ret;
+		}
+
+		if (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {
+			size = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;
+			kfree(pHba->hrt);
+			pHba->hrt = NULL;
+		}
+	} while(pHba->hrt == NULL);
+	return 0;
+}                                                                                                                                       
+
+/*
+ *	 Query one scalar group value or a whole scalar group.
+ */		    	
+int adpt_i2o_query_scalar(adpt_hba* pHba, int tid, 
+			int group, int field, void *buf, int buflen)
+{
+	u16 opblk[] = { 1, 0, I2O_PARAMS_FIELD_GET, group, 1, field };
+	u8  resblk[8+buflen]; /* 8 bytes for header */
+	int size;
+
+	if (field == -1)  		/* whole group */
+			opblk[4] = -1;
+
+	size = adpt_i2o_issue_params(I2O_CMD_UTIL_PARAMS_GET, pHba, tid, 
+		opblk, sizeof(opblk), resblk, sizeof(resblk));
+			
+	if (size < 0)
+		return size;	
+
+	memcpy(buf, resblk+8, buflen);  /* cut off header */
+	return buflen;
+}
+
+
+/*	Issue UTIL_PARAMS_GET or UTIL_PARAMS_SET
+ *
+ *	This function can be used for all UtilParamsGet/Set operations.
+ *	The OperationBlock is given in opblk-buffer, 
+ *	and results are returned in resblk-buffer.
+ *	Note that the minimum sized resblk is 8 bytes and contains
+ *	ResultCount, ErrorInfoSize, BlockStatus and BlockSize.
+ */
+int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, 
+		  void *opblk, int oplen, void *resblk, int reslen)
+{
+	u32 msg[9]; 
+	u32 *res = (u32 *)resblk;
+	int wait_status;
+
+	msg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;
+	msg[1] = cmd << 24 | HOST_TID << 12 | tid; 
+	msg[2] = 0;
+	msg[3] = 0;
+	msg[4] = 0;
+	msg[5] = 0x54000000 | oplen;	/* OperationBlock */
+	msg[6] = virt_to_bus(opblk);
+	msg[7] = 0xD0000000 | reslen;	/* ResultBlock */
+	msg[8] = virt_to_bus(resblk);
+
+	if ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {
+   		return wait_status; 	/* -DetailedStatus */
+	}
+
+	if (res[1]&0x00FF0000) { 	/* BlockStatus != SUCCESS */
+		printk(KERN_WARNING "%s: %s - Error:\n  ErrorInfoSize = 0x%02x, "
+			"BlockStatus = 0x%02x, BlockSize = 0x%04x\n",
+			pHba->name,
+			(cmd == I2O_CMD_UTIL_PARAMS_SET) ? "PARAMS_SET"
+							 : "PARAMS_GET",   
+			res[1]>>24, (res[1]>>16)&0xFF, res[1]&0xFFFF);
+		return -((res[1] >> 16) & 0xFF); /* -BlockStatus */
+	}
+
+	 return 4 + ((res[1] & 0x0000FFFF) << 2); /* bytes used in resblk */ 
+}
+
+/*
+ * Get the IOP's Logical Configuration Table
+ */
+int adpt_i2o_lct_get(adpt_hba* pHba)
+{
+	u32 msg[8];
+	int ret;
+	u32 buf[16];
+
+	if ((pHba->lct_size == 0) || (pHba->lct == NULL)){
+		pHba->lct_size = pHba->status_block->expected_lct_size;
+	}
+	do {
+		if (pHba->lct == NULL) {
+			pHba->lct = kmalloc(pHba->lct_size, GFP_KERNEL|ADDR32);
+			if(pHba->lct == NULL) {
+				printk(KERN_CRIT "%s: Lct Get failed. Out of memory.\n",
+					pHba->name);
+				return -ENOMEM;
+			}
+		}
+		memset(pHba->lct, 0, pHba->lct_size);
+
+		msg[0] = EIGHT_WORD_MSG_SIZE|SGL_OFFSET_6;
+		msg[1] = I2O_CMD_LCT_NOTIFY<<24 | HOST_TID<<12 | ADAPTER_TID;
+		msg[2] = 0;
+		msg[3] = 0;
+		msg[4] = 0xFFFFFFFF;	/* All devices */
+		msg[5] = 0x00000000;	/* Report now */
+		msg[6] = 0xD0000000|pHba->lct_size;
+		msg[7] = virt_to_bus(pHba->lct);
+
+		if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 360))) {
+			printk(KERN_ERR "%s: LCT Get failed (status=%#10x.\n", 
+				pHba->name, ret);	
+			printk("Adaptec: Error Reading Hardware.\n");
+			return ret;
+		}
+
+		if ((pHba->lct->table_size << 2) > pHba->lct_size) {
+			pHba->lct_size = pHba->lct->table_size << 2;
+			kfree(pHba->lct);
+			pHba->lct = NULL;
+		}
+	} while (pHba->lct == NULL);
+
+	PDEBUG("%s: Hardware resource table read.\n", pHba->name);
+
+
+	// I2O_DPT_EXEC_IOP_BUFFERS_GROUP_NO;
+	if(adpt_i2o_query_scalar(pHba, 0 , 0x8000, -1, buf, sizeof(buf))>=0) {
+		pHba->FwDebugBufferSize = buf[1];
+		pHba->FwDebugBuffer_P = pHba->base_addr_virt + buf[0];
+		pHba->FwDebugFlags_P = (u32*) (pHba->FwDebugBuffer_P + FW_DEBUG_FLAGS_OFFSET);
+		pHba->FwDebugBLEDvalue_P = pHba->FwDebugBuffer_P + FW_DEBUG_BLED_OFFSET;
+		pHba->FwDebugBLEDflag_P = pHba->FwDebugBLEDvalue_P + 1;
+		pHba->FwDebugStrLength_P = (u32*) (pHba->FwDebugBuffer_P + FW_DEBUG_STR_LENGTH_OFFSET);
+		pHba->FwDebugBuffer_P += buf[2]; 
+		pHba->FwDebugFlags = 0;
+	}
+
+	return 0;
+}
+
+/*
+ *	The logical configuration table tells us what we can talk to
+ *	on the board. Most of the stuff isn't interesting to us. 
+ */
+
+int adpt_i2o_parse_lct(adpt_hba* pHba)
+{
+	int i;
+	int max;
+	int tid;
+	struct i2o_device *d;
+	i2o_lct *lct = pHba->lct;
+	u8 bus_no = 0;
+	s16 scsi_id;
+	s16 scsi_lun;
+	u32 buf[10]; // larger than 7, or 8 ...
+	struct adpt_device* pDev; 
+	
+	if (lct == NULL) {
+		printk(KERN_ERR "%s: LCT is empty???\n",pHba->name);
+		return -1;
+	}
+	
+	max = lct->table_size;	
+	max -= 3;
+	max /= 9;
+
+	if(lct->iop_flags&(1<<0))
+		printk(KERN_WARNING "%s: Configuration dialog desired.\n", pHba->name);
+		
+	for(i=0;i<max;i++) {
+		if( lct->lct_entry[i].user_tid != 0xfff){
+			/*
+			 * If we have hidden devices, we need to inform the upper layers about
+			 * the possible maximum id reference to handle device access when
+			 * an array is disassembled. This code has no other purpose but to
+			 * allow us future access to devices that are currently hidden
+			 * behind arrays, hotspares or have not been configured (JBOD mode).
+			 */
+			if( lct->lct_entry[i].class_id != I2O_CLASS_RANDOM_BLOCK_STORAGE &&
+			    lct->lct_entry[i].class_id != I2O_CLASS_SCSI_PERIPHERAL &&
+			    lct->lct_entry[i].class_id != I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
+			    	continue;
+			}
+			tid = lct->lct_entry[i].tid;
+			// I2O_DPT_DEVICE_INFO_GROUP_NO;
+			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {
+				continue;
+			}
+			bus_no = buf[0]>>16;
+			scsi_id = buf[1];
+			scsi_lun = (buf[2]>>8 )&0xff;
+			if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
+				printk(KERN_WARNING"%s: Channel number %d out of range \n", pHba->name, bus_no);
+				continue;
+			}
+			if(scsi_id > MAX_ID){
+				printk(KERN_WARNING"%s: SCSI ID %d out of range \n", pHba->name, bus_no);
+				continue;
+			}
+			if(bus_no > pHba->top_scsi_channel){
+				pHba->top_scsi_channel = bus_no;
+			}
+			if(scsi_id > pHba->top_scsi_id){
+				pHba->top_scsi_id = scsi_id;
+			}
+			if(scsi_lun > pHba->top_scsi_lun){
+				pHba->top_scsi_lun = scsi_lun;
+			}
+			continue;
+		}
+		d = (struct i2o_device *)kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
+		if(d==NULL)
+		{
+			printk(KERN_CRIT "%s: Out of memory for I2O device data.\n",pHba->name);
+			return -ENOMEM;
+		}
+		
+		d->controller = (void*)pHba;
+		d->next = NULL;
+
+		memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
+
+		d->flags = 0;
+		tid = d->lct_data.tid;
+		adpt_i2o_report_hba_unit(pHba, d);
+		adpt_i2o_install_device(pHba, d);
+	}
+	bus_no = 0;
+	for(d = pHba->devices; d ; d = d->next) {
+		if(d->lct_data.class_id  == I2O_CLASS_BUS_ADAPTER_PORT ||
+		   d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PORT){
+			tid = d->lct_data.tid;
+			// TODO get the bus_no from hrt
+			//bus_no = 
+			if(bus_no > pHba->top_scsi_channel){
+				pHba->top_scsi_channel = bus_no;
+			}
+			pHba->channel[bus_no].type = d->lct_data.class_id;
+			pHba->channel[bus_no].tid = tid;
+			if(adpt_i2o_query_scalar(pHba, tid, 0x0200, -1, buf, 28)>=0)
+			{
+				pHba->channel[bus_no].scsi_id = buf[1];
+				printk(KERN_INFO "Bus %d - SCSI ID %d.\n", bus_no, buf[1]);
+			}
+			// TODO remove - this is just until we get from hrt
+			bus_no++;
+			if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
+				printk(KERN_WARNING"%s: Channel number %d out of range - LCT\n", pHba->name, bus_no);
+				break;
+			}
+		}
+	}
+
+	// Setup adpt_device table
+	for(d = pHba->devices; d ; d = d->next) {
+		if(d->lct_data.class_id  == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
+		   d->lct_data.class_id  == I2O_CLASS_SCSI_PERIPHERAL ||
+		   d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
+
+			tid = d->lct_data.tid;
+			scsi_id = -1;
+			// I2O_DPT_DEVICE_INFO_GROUP_NO;
+			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)>=0) {
+				bus_no = buf[0]>>16;
+				scsi_id = buf[1];
+				scsi_lun = (buf[2]>>8 )&0xff;
+				if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
+					continue;
+				}
+				if(scsi_id > MAX_ID){
+					continue;
+				}
+				if( pHba->channel[bus_no].device[scsi_id] == NULL){
+					pDev =  kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					if(pDev == NULL) {
+						return -ENOMEM;
+					}
+					pHba->channel[bus_no].device[scsi_id] = pDev;
+					memset(pDev,0,sizeof(struct adpt_device));
+				} else {
+					for( pDev = pHba->channel[bus_no].device[scsi_id];	
+							pDev->next_lun; pDev = pDev->next_lun){
+					}
+					pDev->next_lun = kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					if(pDev == NULL) {
+						return -ENOMEM;
+					}
+					memset(pDev->next_lun,0,sizeof(struct adpt_device));
+					pDev = pDev->next_lun;
+				}
+				pDev->tid = tid;
+				pDev->scsi_channel = bus_no;
+				pDev->scsi_id = scsi_id;
+				pDev->scsi_lun = scsi_lun;
+				pDev->pI2o_dev = d;
+				d->owner = (struct i2o_handler *)pDev;
+				pDev->type = (buf[0])&0xff;
+				pDev->flags = (buf[0]>>8)&0xff;
+				if(scsi_id > pHba->top_scsi_id){
+					pHba->top_scsi_id = scsi_id;
+				}
+				if(scsi_lun > pHba->top_scsi_lun){
+					pHba->top_scsi_lun = scsi_lun;
+				}
+			}
+			if(scsi_id == -1){
+				printk(KERN_WARNING"Could not find SCSI ID for %s\n",
+						d->lct_data.identity_tag);
+			}
+		}
+	}
+	return 0;
+}
+
+
+/*
+ *	Each I2O controller has a chain of devices on it - these match
+ *	the useful parts of the LCT of the board.
+ */
+ 
+int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)
+{
+	down(&adpt_configuration_lock);
+	d->controller=(struct i2o_controller*)pHba;
+	d->owner=NULL;
+	d->next=pHba->devices;
+	d->prev=NULL;
+	if (pHba->devices != NULL){
+		pHba->devices->prev=d;
+	}
+	pHba->devices=d;
+	*d->dev_name = 0;
+
+	up(&adpt_configuration_lock);
+	return 0;
+}
+
+
+/*
+ *	 Dump the information block associated with a given unit (TID)
+ */
+ 
+void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)
+{
+	char buf[64];
+	int unit = d->lct_data.tid;
+
+	printk(KERN_INFO "Target ID %d.\n", unit);
+
+	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 3, buf, 16)>=0)
+	{
+		buf[16]=0;
+		printk(KERN_INFO"  Vendor: %s", buf);
+	}
+	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 4, buf, 16)>=0)
+	{
+		buf[16]=0;
+		printk("     Device: %s", buf);
+	}
+#if 0
+	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 5, buf, 16)>=0)
+	{
+		buf[16]=0;
+		printk(KERN_INFO "Description: %s", buf);
+	}
+#endif	
+	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 6, buf, 8)>=0)
+	{
+		buf[8]=0;
+		printk("  Rev: %s\n", buf);
+	}
+
+	 printk(KERN_INFO "  Class: %.21s\n", adpt_i2o_get_class_name(d->lct_data.class_id));
+	 printk(KERN_INFO "  Subclass: 0x%04X\n", d->lct_data.sub_class);
+	 printk(KERN_INFO "  Flags: ");
+
+	 if(d->lct_data.device_flags&(1<<0))
+		  printk("C");	     // ConfigDialog requested
+	 if(d->lct_data.device_flags&(1<<1))
+		  printk("U");	     // Multi-user capable
+	 if(!(d->lct_data.device_flags&(1<<4)))
+		  printk("P");	     // Peer service enabled!
+	 if(!(d->lct_data.device_flags&(1<<5)))
+		  printk("M");	     // Mgmt service enabled!
+	 printk("\n");
+}
+
+
+/*
+ *	Do i2o class name lookup
+ */
+const char *adpt_i2o_get_class_name(int class)
+{
+	int idx = 16;
+	static char *i2o_class_name[] = {
+		"Executive",
+		"Device Driver Module",
+		"Block Device",
+		"Tape Device",
+		"LAN Interface",
+		"WAN Interface",
+		"Fibre Channel Port",
+		"Fibre Channel Device",
+		"SCSI Device",
+		"ATE Port",
+		"ATE Device",
+		"Floppy Controller",
+		"Floppy Device",
+		"Secondary Bus Port",
+		"Peer Transport Agent",
+		"Peer Transport",
+		"Unknown"
+	};
+	
+	switch(class&0xFFF) {
+	case I2O_CLASS_EXECUTIVE:
+		idx = 0; break;
+	case I2O_CLASS_DDM:
+		idx = 1; break;
+	case I2O_CLASS_RANDOM_BLOCK_STORAGE:
+		idx = 2; break;
+	case I2O_CLASS_SEQUENTIAL_STORAGE:
+		idx = 3; break;
+	case I2O_CLASS_LAN:
+		idx = 4; break;
+	case I2O_CLASS_WAN:
+		idx = 5; break;
+	case I2O_CLASS_FIBRE_CHANNEL_PORT:
+		idx = 6; break;
+	case I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:
+		idx = 7; break;
+	case I2O_CLASS_SCSI_PERIPHERAL:
+		idx = 8; break;
+	case I2O_CLASS_ATE_PORT:
+		idx = 9; break;
+	case I2O_CLASS_ATE_PERIPHERAL:
+		idx = 10; break;
+	case I2O_CLASS_FLOPPY_CONTROLLER:
+		idx = 11; break;
+	case I2O_CLASS_FLOPPY_DEVICE:
+		idx = 12; break;
+	case I2O_CLASS_BUS_ADAPTER_PORT:
+		idx = 13; break;
+	case I2O_CLASS_PEER_TRANSPORT_AGENT:
+		idx = 14; break;
+	case I2O_CLASS_PEER_TRANSPORT:
+		idx = 15; break;
+	}
+	return i2o_class_name[idx];
+}
+
+
+int adpt_open(struct inode *inode, struct file *file)
+{
+	int minor;
+	adpt_hba* pHba;
+
+	//TODO check for root access
+	//
+	minor = MINOR(inode->i_rdev);
+	if (minor >= hba_count) {
+		return -ENXIO;
+	}
+	down(&adpt_configuration_lock);
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (pHba->unit == minor) {
+			break;	/* found adapter */
+		}
+	}
+	if (pHba == NULL) {
+		up(&adpt_configuration_lock);
+		return -ENXIO;
+	}
+
+//	if(pHba->in_use){
+	//	up(&adpt_configuration_lock);
+//		return -EBUSY;
+//	}
+
+	pHba->in_use = 1;
+	up(&adpt_configuration_lock);
+
+	return 0;
+}
+
+int adpt_close(struct inode *inode, struct file *file)
+{
+	int minor;
+	adpt_hba* pHba;
+
+	minor = MINOR(inode->i_rdev);
+	if (minor >= hba_count) {
+		return -ENXIO;
+	}
+	down(&adpt_configuration_lock);
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (pHba->unit == minor) {
+			break;	/* found adapter */
+		}
+	}
+	up(&adpt_configuration_lock);
+	if (pHba == NULL) {
+		return -ENXIO;
+	}
+
+	pHba->in_use = 0;
+
+	return 0;
+}
+
+
+int adpt_i2o_passthru(adpt_hba* pHba, u32* arg)
+{
+	u32 msg[MAX_MESSAGE_SIZE/4];
+	u32* reply = NULL;
+	u32 size = 0;
+	u32 reply_size = 0;
+	u32* user_msg = (u32*)arg;
+	u32* user_reply = NULL;
+	u32 sg_offset = 0;
+	u32 sg_count = 0;
+	u32 i = 0;
+	u32 rcode = 0;
+	caddr_t p = NULL;
+	caddr_t sg_list[pHba->sg_tablesize];
+	int sg_index = 0;
+	ulong flags = 0;
+	memset(&msg, 0, MAX_MESSAGE_SIZE);
+	// get user msg size in u32s 
+	get_user(size, &user_msg[0]);
+	size = size>>16;
+
+	user_reply = &user_msg[size];
+	size *= 4; // Convert to bytes
+	if(size > MAX_MESSAGE_SIZE){
+		return -EFAULT;
+	}
+
+	/* Copy in the user's I2O command */
+	if (copy_from_user ((void*)msg, (void*)user_msg, size)) {
+		return -EFAULT;
+	}
+	get_user(reply_size, &user_reply[0]);
+	reply_size = reply_size>>16;
+	if(reply_size > REPLY_FRAME_SIZE){
+		reply_size = REPLY_FRAME_SIZE;
+	}
+	reply_size *= 4;
+	reply = kmalloc(REPLY_FRAME_SIZE*4, GFP_KERNEL);
+	if(reply == NULL) {
+		printk(KERN_WARNING"%s: Could not allocate reply buffer\n",pHba->name);
+		return -ENOMEM;
+	}
+	memset(reply,0,REPLY_FRAME_SIZE*4);
+	sg_offset = (msg[0]>>4)&0xf;
+	msg[2] = 0x40000000; // IOCTL context
+	msg[3] = (u32)reply;
+	memset(sg_list,0, sizeof(sg_list[0])*pHba->sg_tablesize);
+	if(sg_offset) {
+		struct sg_simple_element *sg =  (struct sg_simple_element*) (msg+sg_offset);
+		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
+		if (sg_count > pHba->sg_tablesize){
+			printk(KERN_WARNING"%s:IOCTL SG List too large (%u)\n", pHba->name,sg_count);
+			kfree (reply);
+			return -EINVAL;
+		}
+
+		for (i = 0; i < sg_count; i++) {
+#if 0
+			u32 physical;
+			caddr_t virtual;
+			int residual, length, sub_length;
+#endif
+			int sg_size;
+
+			if (!(sg[i].flag_count & 0x10000000 /*I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT*/)) {
+				printk(KERN_WARNING"%s:Bad SG element %d - not simple (%x)\n",pHba->name,i,  sg[i].flag_count);
+				rcode = -EINVAL;
+				goto cleanup;
+			}
+			sg_size = sg[i].flag_count & 0xffffff;      
+			/* Allocate memory for the transfer */
+			p = (caddr_t)kmalloc(sg_size, GFP_KERNEL|ADDR32);
+			if (p == NULL) {
+				printk(KERN_WARNING"%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n",
+						pHba->name,sg_size,i,sg_count);
+				rcode = -ENOMEM;
+				goto cleanup;
+			}
+			sg_list[sg_index++] = p; // sglist indexed with input frame, not our internal frame.
+			/* Copy in the user's SG buffer if necessary */
+			if (sg[i].flag_count & 0x04000000 /*I2O_SGL_FLAGS_DIR*/) {
+				if (copy_from_user(p,(caddr_t)(sg[i].addr_bus), sg_size)) {
+					printk(KERN_WARNING"%s: Could not copy SG buf %d FROM user\n",pHba->name,i);
+					rcode = -EFAULT;
+					goto cleanup;
+				}
+			}
+			sg[i].addr_bus = (u32)virt_to_bus(p);
+#if 0
+			// Need to split requests should the buffer not be physically contiguous
+			// It gets ugly from here on in ...
+			physical = sg[i].addr_bus;
+			virtual = p;
+			residual = sg[i].flag_count&0xffffff;
+			length = 0;
+			while ((sub_length = (((physical + PAGE_SIZE) & PAGE_MASK) - physical)) < residual) {
+				// split this request?
+				length += sub_length;
+				residual -= sub_length;
+				physical += sub_length;
+				virtual += sub_length;
+				if (physical != (u32)virt_to_bus(virtual)) {
+					int j;
+					if (++sg_count > pHba->sg_tablesize){
+						printk(KERN_WARNING"%s:IOCTL SG List too large (%u)\n", pHba->name,sg_count);
+						rcode = -EINVAL;
+						goto cleanup;
+					}
+					if((size += sizeof(struct sg_simple_element)) > MAX_MESSAGE_SIZE){
+						printk(KERN_WARNING"%s:IOCTL Message too large (%u)\n", pHba->name,size);
+						rcode = -EINVAL;
+						goto cleanup;
+					}
+					// fixup message and scatter gather list.
+					msg[0] &= 0xffff;
+					msg[0] |= (size / sizeof(u32)) << 16;
+					// shift upwards the scatter gather list.
+					sg[i].flag_count &= ~0xffffff;
+					for (j = sg_count; --j > i;) {
+						sg[j] = sg[j-1];
+					}
+					// length &= 0xffffff;
+					sg[i].flag_count |= length;
+					length = 0;
+					sg[++i].addr_bus = physical = (u32)virt_to_bus(virtual);
+					// residual &= 0xffffff;
+					sg[i].flag_count |= residual;
+				}
+			}
+#endif
+		}
+	}
+
+	do {
+		spin_lock_irqsave(&io_request_lock, flags);
+		// This state stops any new commands from enterring the
+		// controller while processing the ioctl
+//		pHba->state |= DPTI_STATE_IOCTL;
+//		We can't set this now - The scsi subsystem sets host_blocked and
+//		the queue empties and stops.  We need a way to restart the queue
+		rcode = adpt_i2o_post_wait(pHba, msg, size, FOREVER);
+//		pHba->state &= ~DPTI_STATE_IOCTL;
+		spin_unlock_irqrestore(&io_request_lock, flags);
+	} while(rcode == -ETIMEDOUT);  
+
+	if(!rcode && sg_offset) {
+	/* Copy back the Scatter Gather buffers back to user space */
+		u32 j;
+		struct sg_simple_element* sg;
+		int sg_size;
+
+		// re-acquire the original message to handle correctly the sg copy operation
+		memset(&msg, 0, MAX_MESSAGE_SIZE);
+		// get user msg size in u32s 
+		if(get_user(size, &user_msg[0])){
+			rcode = -EFAULT; 
+			goto cleanup; 
+		}
+		size = size>>16;
+		size *= 4;
+		/* Copy in the user's I2O command */
+		if (copy_from_user ((void*)msg, (void*)user_msg, size)) {
+			rcode = -EFAULT;
+			goto cleanup;
+		}
+		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
+
+		sg 	 = (struct sg_simple_element*)(msg + sg_offset);
+		for (j = 0; j < sg_count; j++) {
+			/* Copy out the SG list to user's buffer if necessary */
+			if(! (sg[j].flag_count & 0x4000000 /*I2O_SGL_FLAGS_DIR*/)) {
+				sg_size = sg[j].flag_count & 0xffffff; 
+				if (copy_to_user((caddr_t)(sg[j].addr_bus),sg_list[j], sg_size)) {
+					printk(KERN_WARNING"%s: Could not copy %p TO user %p\n",pHba->name, sg_list[j], (caddr_t)sg[j].addr_bus);
+					rcode = -EFAULT;
+					goto cleanup;
+				}
+			}
+		}
+	} 
+
+	/* Copy back the reply to user space */
+	if (reply_size) {
+		// we wrote our own values for context - now restore the user supplied ones
+		if (copy_from_user (reply+2, user_msg+2, sizeof(u32)*2)) {
+			printk(KERN_WARNING"%s: Could not copy message context FROM user\n",pHba->name);
+			rcode = -EFAULT;
+		}
+		if (copy_to_user(user_reply, reply, reply_size)) {
+			printk(KERN_WARNING"%s: Could not copy reply TO user\n",pHba->name);
+			rcode = -EFAULT;
+		}
+	}
+
+
+cleanup:
+	kfree (reply);
+	while(sg_index) {
+		if(sg_list[--sg_index]) {
+			kfree(sg_list[sg_index]);
+		}
+	}
+	return rcode;
+}
+
+
+/*
+ * This routine returns information about the system.  This does not effect
+ * any logic and if the info is wrong - it doesn't matter.
+ */
+
+/* Get all the info we can not get from kernel services */
+int adpt_system_info(void *buffer)
+{
+	sysInfo_S si;
+
+	memset(&si, 0, sizeof(si));
+
+	si.osType = OS_LINUX;
+	si.osMajorVersion = (u8) (LINUX_VERSION_CODE >> 16);
+	si.osMinorVersion = (u8) (LINUX_VERSION_CODE >> 8 & 0x0ff);
+	si.osRevision =     (u8) (LINUX_VERSION_CODE & 0x0ff);
+	si.busType = SI_PCI_BUS;
+	si.processorFamily = DPTI_sig.dsProcessorFamily;
+
+#if defined __i386__ 
+	adpt_i386_info(&si);
+#elif defined __ia64__
+	adpt_ia64_info(&si);
+#elif define __sparc__
+	adpt_sparc_info(&si);
+#elif defined __alpha__ 
+	adpt_alpha_info(&si);
+#else
+	si.processorType = 0xff ;
+#endif
+	if(copy_to_user(buffer, &si, sizeof(si))){
+		printk(KERN_WARNING"dpti: Could not copy buffer TO user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+#if defined __ia64__ 
+void adpt_ia64_info(sysInfo_S* si)
+{
+	// This is all the info we need for now
+	si->processorType = PROC_IA64;
+}
+#endif
+
+
+#if defined __sparc__ 
+void adpt_sparc_info(sysInfo_S* si)
+{
+	// This is all the info we need for now
+	si->processorType = PROC_ULTRASPARC;
+}
+#endif
+
+#if defined __alpha__ 
+void adpt_sparc_info(sysInfo_S* si)
+{
+	// This is all the info we need for now
+	si->processorType = PROC_ALPHA;
+}
+#endif
+
+#if defined __i386__
+
+#include <linux/mc146818rtc.h>
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+
+void adpt_i386_info(sysInfo_S* si)
+{
+	int i;
+	int j;
+	ulong flags=0;
+
+	switch (boot_cpu_data.x86) {
+	case CPU_386:
+		si->processorType = PROC_386;
+		break;
+	case CPU_486:
+		si->processorType = PROC_486;
+		break;
+	case CPU_586:
+		si->processorType = PROC_PENTIUM;
+		break;
+	default:  // Just in case 
+		si->processorType = PROC_PENTIUM;
+		break;
+	}
+
+	spin_lock_irqsave(&rtc_lock, flags);
+
+	/* Get drive type for 1st drive*/
+	i = CMOS_READ(0x12) >> 4;
+	j = i >> 4;
+	if (i == 0x0f) {
+		j = CMOS_READ(0x19);
+	}
+	si->drive0CMOS = j;
+
+	/* Get driver type for 2nd drive*/
+	j = i & 0x0f;
+	if (i == 0x0f) {
+		j = CMOS_READ(0x1a);
+	}
+	spin_unlock_irqrestore(&rtc_lock, flags);
+
+	si->drive1CMOS = j;
+	/* Get number of drives sys bios found */
+	si->numDrives = *((char *) phys_to_virt(0x475));
+	/* What info in si is valid */
+	si->flags = SI_CMOS_Valid | SI_NumDrivesValid | SI_OSversionValid | SI_BusTypeValid;
+
+	/* Go Out And Look For SmartROM revision */
+	for (i = 0; i < 3; ++i) {
+		int k;
+		u32 addr = 0;
+
+		/* Decide which bank */
+		if(i == 0) {
+			addr = 0xC8000;
+		} else if(i == 1) {
+			addr = 0xD8000;
+		} else {
+			addr = 0xDC000;
+		}
+
+		/* Looking for our bios signature */
+		if(isa_readw(addr) != 0xAA55) {
+			continue;
+		}
+		if(isa_readl( addr+6) != 0x202053) {
+			continue;
+		}
+		if(isa_readl(addr+10) != 0x545044) {
+			continue;
+		}
+
+		addr += 0x24;
+
+		/* scan for " v" */
+		for (k = 0; k < 64; ++k) {
+			if(isa_readb(addr++) == ' ' && isa_readb(addr) == 'v' ) {
+				break;
+			}
+		}
+
+		/* Found it - get version */
+		if(k < 64) {
+			si->smartROMMajorVersion = isa_readb(addr += 3) - '0';
+			si->smartROMMinorVersion = isa_readb(addr += 2);
+			si->smartROMRevision = isa_readb(++addr);
+			si->flags |= SI_SmartROMverValid;
+			break;
+		}
+	}
+
+	if(i >= 3) {
+		/* if didn't find it - no smart ROM */
+		si->flags |= SI_NO_SmartROM;
+	}
+
+	if(si->numDrives > 0) {
+		u32 addr = 0;
+		/* Get The Pointer From Int 41 For The First
+		 * Drive Parameters
+		 */
+		addr =  (((u32)isa_readw(0x104+2)) << 4) + (u16)isa_readw(0x104);
+		/*
+		 * It appears that SmartROM's Int41/Int46 pointers
+		 * use memory that gets stepped on by the kernel
+		 * loading. We no longer have access to this
+		 * geometry information but try anyways (!?)
+		 */
+		si->drives[0].cylinders = isa_readb(addr++);
+		si->drives[0].cylinders += ((int)isa_readb(addr++)) << 8;
+		si->drives[0].heads = isa_readb(addr);
+		addr += 12;
+		si->drives[0].sectors = isa_readb(addr);
+		si->flags |= SI_DriveParamsValid;
+		if((si->drives[0].cylinders != 0) && 
+		   (si->drives[0].heads     != 0) &&
+		   (si->drives[0].sectors   != 0)) {
+			si->flags |= SI_DriveParamsValid;
+			return;
+		}
+		if(si->numDrives > 1) {
+			/*
+			 * Get Pointer From Int 46 For The 2nd Drive Parameters
+			 */
+			addr =  (((u32)isa_readw(0x118+2)) << 4) + (u16)isa_readw(0x118);
+			si->drives[1].cylinders = isa_readb(addr++);
+			si->drives[1].cylinders += ((int)isa_readb(addr++)) << 8;
+			si->drives[1].heads = isa_readb(addr);
+			addr += 12;
+			si->drives[0].sectors = isa_readb(addr);
+			if(!((si->drives[1].cylinders != 0) && 
+			     (si->drives[1].heads     != 0) &&
+			     (si->drives[1].sectors   != 0))) {
+				si->flags &=  ~SI_DriveParamsValid;
+			}
+		}
+	}
+
+}
+
+#else
+
+void adpt_i386_info(sysInfo_S* si)
+{
+	int i;
+	int j;
+	caddr_t c_addr;
+	ulong flags=0;
+
+	switch (boot_cpu_data.x86) {
+	case CPU_386:
+		si->processorType = PROC_386;
+		break;
+	case CPU_486:
+		si->processorType = PROC_486;
+		break;
+	case CPU_586:
+		si->processorType = PROC_PENTIUM;
+		break;
+	default:  // Just in case 
+		si->processorType = PROC_PENTIUM;
+		break;
+	}
+
+//	spin_lock_irqsave(&rtc_lock, flags);
+
+	/* Get drive type for 1st drive*/
+	i = CMOS_READ(0x12) >> 4;
+	j = i >> 4;
+	if (i == 0x0f) {
+		j = CMOS_READ(0x19);
+	}
+	si->drive0CMOS = j;
+
+	/* Get driver type for 2nd drive*/
+	j = i & 0x0f;
+	if (i == 0x0f) {
+		j = CMOS_READ(0x1a);
+	}
+//	spin_unlock_irqrestore(&rtc_lock, flags);
+
+	si->drive1CMOS = j;
+	/* Get number of drives sys bios found */
+	si->numDrives = *((char *) phys_to_virt(0x475));
+	/* What info in si is valid */
+	si->flags = SI_CMOS_Valid | SI_NumDrivesValid | SI_OSversionValid | SI_BusTypeValid;
+
+	/* Go Out And Look For SmartROM revision */
+	for (i = 0; i < 3; ++i) {
+		int k;
+
+		/* Decide which bank */
+		if(i == 0) {
+			j = 0xC8000;
+		} else if(i == 1) {
+			j = 0xD8000;
+		} else {
+			j = 0xDC000;
+		}
+		c_addr = phys_to_virt(j);
+
+		/* Looking for our bios signature */
+		if (*((unsigned short *) c_addr) != 0xAA55) {
+			continue;
+		}
+		if (*((unsigned long *) (c_addr + 6)) != 0x202053) {
+			continue;
+		}
+		if (*((unsigned long *) (c_addr + 10)) != 0x545044) {
+			continue;
+		}
+
+		c_addr += 0x24;
+
+		/* scan for " v" */
+		for (k = 0; k < 64; ++k) {
+			if ((*((unsigned char *) (c_addr++)) == ' ') &&
+			    (*((unsigned char *) (c_addr))   == 'v')) {
+				break;
+			}
+		}
+
+		/* Found it - get version */
+		if(k < 64) {
+			si->smartROMMajorVersion = *((unsigned char *)(c_addr += 3)) - '0';
+			si->smartROMMinorVersion = *((unsigned char *)(c_addr += 2));
+			si->smartROMRevision = *((unsigned char *)(++c_addr));
+			si->flags |= SI_SmartROMverValid;
+			break;
+		}
+	}
+
+	if(i >= 3) {
+		/* if didn't find it - no smart ROM */
+		si->flags |= SI_NO_SmartROM;
+	}
+
+	if(si->numDrives > 0) {
+		/*
+		 * Get The Pointer From Int 41 For The First
+		 * Drive Parameters
+		 */
+		j =  ((unsigned)(*((unsigned short *)phys_to_virt(0x104 + 2))) << 4)
+		    + (unsigned)(*((unsigned short *)phys_to_virt(0x104 + 0)));
+		/*
+		 * It appears that SmartROM's Int41/Int46 pointers
+		 * use memory that gets stepped on by the kernel
+		 * loading. We no longer have access to this
+		 * geometry information but try anyways (!?)
+		 */
+		si->drives[0].cylinders = *((unsigned char *)phys_to_virt(j));
+		si->drives[0].cylinders += ((int)*((unsigned char *)phys_to_virt(j))) << 8;
+		si->drives[0].heads = *((unsigned char *) phys_to_virt(j));
+		j += 12;
+		si->drives[0].sectors = *((unsigned char *) phys_to_virt(j));
+		si->flags |= SI_DriveParamsValid;
+		if((si->drives[0].cylinders != 0) && 
+		   (si->drives[0].heads     != 0) &&
+		   (si->drives[0].sectors   != 0)) {
+			si->flags |= SI_DriveParamsValid;
+			return;
+		}
+		if(si->numDrives > 1) {
+			/*
+			 * Get Pointer From Int 46 For The 2nd Drive Parameters
+			 */
+			j =  ((unsigned)(*((unsigned short *)phys_to_virt(0x118 + 2))) << 4)
+			    + (unsigned)(*((unsigned short *)phys_to_virt(0x118 + 0)));
+			si->drives[1].cylinders = *((unsigned char *)phys_to_virt(j));
+			si->drives[1].cylinders += ((int)*((unsigned char *)phys_to_virt(j))) << 8;
+			si->drives[1].heads = *((unsigned char *) phys_to_virt(j));
+			j += 12;
+			si->drives[1].sectors = *((unsigned char *) phys_to_virt(j));
+			if(!((si->drives[1].cylinders != 0) && 
+			     (si->drives[1].heads     != 0) &&
+			     (si->drives[1].sectors   != 0))) {
+				si->flags &=  ~SI_DriveParamsValid;
+			}
+		}
+	}
+
+}
+
+#endif
+#endif
+
+
+int adpt_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	      unsigned long arg)
+{
+	int minor;
+	int error = 0;
+	adpt_hba* pHba;
+
+	minor = MINOR(inode->i_rdev);
+	if (minor >= DPTI_MAX_HBA){
+		return -ENXIO;
+	}
+	down(&adpt_configuration_lock);
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (pHba->unit == minor) {
+			break;	/* found adapter */
+		}
+	}
+	up(&adpt_configuration_lock);
+	if(pHba == NULL){
+		return -ENXIO;
+	}
+
+	while((volatile u32) pHba->state & DPTI_STATE_RESET ) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		set_task_state(current,TASK_UNINTERRUPTIBLE);
+#else
+		current->state = TASK_UNINTERRUPTIBLE;
+#endif
+		schedule_timeout(2);
+
+	}
+
+	switch (cmd) {
+	// TODO: handle 3 cases
+	case DPT_SIGNATURE:
+		if (copy_to_user((char*)arg, &DPTI_sig, sizeof(DPTI_sig))) {
+			return -EFAULT;
+		}
+		break;
+	case I2OUSRCMD:
+		return	adpt_i2o_passthru(pHba,(u32*)arg);
+		break;
+
+	case DPT_CTRLINFO:{
+		drvrHBAinfo_S HbaInfo;
+
+#define FLG_OSD_PCI_VALID 0x0001
+#define FLG_OSD_DMA	  0x0002
+#define FLG_OSD_I2O	  0x0004
+		memset(&HbaInfo, 0, sizeof(HbaInfo));
+		HbaInfo.drvrHBAnum = pHba->unit;
+		HbaInfo.baseAddr = (ulong) pHba->base_addr_phys;
+		HbaInfo.blinkState = adpt_getBlinkLED(pHba);
+		HbaInfo.pciBusNum =  pHba->pDev->bus->number;
+		HbaInfo.pciDeviceNum=PCI_SLOT(pHba->pDev->devfn); 
+		HbaInfo.Interrupt = pHba->pDev->irq; 
+		HbaInfo.hbaFlags = FLG_OSD_PCI_VALID | FLG_OSD_DMA | FLG_OSD_I2O;
+		if(copy_to_user((void *) arg, &HbaInfo, sizeof(HbaInfo))){
+			printk(KERN_WARNING"%s: Could not copy HbaInfo TO user\n",pHba->name);
+			return -EFAULT;
+		}
+		break;
+		}
+	case DPT_SYSINFO:
+		return adpt_system_info((void*)arg);
+		break;
+	case DPT_BLINKLED:{
+		u32 value;
+		value = adpt_getBlinkLED(pHba);
+		if (copy_to_user((char*)arg, &value, sizeof(value))) {
+			return -EFAULT;
+		}
+		break;
+		}
+	case I2ORESETCMD:
+		adpt_hba_reset(pHba);
+		break;
+	case I2ORESCANCMD:
+		adpt_rescan(pHba);
+		break;
+	case DPT_TARGET_BUSY & 0xFFFF:
+	case DPT_TARGET_BUSY:
+	{
+		TARGET_BUSY_T busy;
+		struct adpt_device* d;
+
+		if (copy_from_user((void*)&busy, (void*)arg, sizeof(TARGET_BUSY_T))) {
+			return -EFAULT;
+		}
+
+		d = adpt_find_device(pHba, busy.channel, busy.id, busy.lun);
+		if(d == NULL){
+			return -ENODEV;
+		}
+		busy.isBusy = ((d->pScsi_dev) && (0 != d->pScsi_dev->access_count)) ? 1 : 0;
+		if (copy_to_user ((char*)arg, &busy, sizeof(busy))) {
+			return -EFAULT;
+		}
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return error;
+}
+
+
+const char *adpt_info(struct Scsi_Host *host)
+{
+	adpt_hba* pHba;
+
+	pHba = (adpt_hba *) host->hostdata[0];
+	return (char *) (pHba->detail);
+}
+
+int adpt_proc_info(char *buffer, char **start, off_t offset,
+		  int length, int hostno, int inout)
+{
+	struct adpt_device* d;
+	int id;
+	int chan;
+	int len = 0;
+	int begin = 0;
+	int pos = 0;
+	adpt_hba* pHba;
+	struct Scsi_Host *host;
+
+	*start = buffer;
+	if (inout == TRUE) {
+		/*
+		 * The user has done a write and wants us to take the
+		 * data in the buffer and do something with it.
+		 * proc_scsiwrite calls us with inout = 1
+		 *
+		 * Read data from buffer (writing to us) - NOT SUPPORTED
+		 */
+		return -ENOSYS;
+	}
+
+	/*
+	 * inout = 0 means the user has done a read and wants information
+	 * returned, so we write information about the cards into the buffer
+	 * proc_scsiread() calls us with inout = 0
+	 */
+
+	/*
+	 * We have returned buffer to (buffer + offset) in previous calls
+	 * Set start to where we want the beginning of the new data to be.
+	 */
+	*start = buffer + offset;
+
+	// Find HBA (host bus adapter) we are looking for
+	down(&adpt_configuration_lock);
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (pHba->host->host_no == hostno) {
+			break;	/* found adapter */
+		}
+	}
+	up(&adpt_configuration_lock);
+	if (pHba == NULL) {
+		return 0;
+	}
+	host = pHba->host;
+
+	len  = sprintf(buffer      , "Adaptec I2O RAID Driver Version: %s:\n\n", DPT_I2O_VERSION);
+	len += sprintf(buffer+len, "%s:\n\n", pHba->detail);
+	len += sprintf(buffer+len, "SCSI Host No. %d. Control Node =/dev/%s\n", pHba->host->host_no, pHba->name);
+	len += sprintf(buffer+len, "  max channel = %d, max id = %d, max lun = %d,\n",
+					host->max_channel, host->max_id - 1, host->max_lun - 1);
+	len += sprintf(buffer+len, "  post fifo size = %d, reply fifo size = %d\n",
+					host->can_queue, (int) pHba->reply_fifo_size );
+	//TODO(defer) change this to something more meaningful
+	len += sprintf(buffer+len, "  sg table size = %d, irq = %d\n\n",
+					host->sg_tablesize, host->irq);
+
+	len +=  sprintf(buffer+len, "  Devices:\n");
+	for (chan = 0; chan < MAX_CHANNEL; chan++) {
+		for (id = 0; id < MAX_ID; id++) {
+			d = pHba->channel[chan].device[id];
+			while(d){
+				len += sprintf(buffer+len, "  Channel = %d, Target = %d, Lun = %d\n",
+					       (int)d->scsi_channel, (int)d->scsi_id, (int)d->scsi_lun); 
+				pos = begin + len;
+				d = d->next_lun;
+			}
+		}
+		if (pos < offset) {
+			/*
+			 * If we haven't even written to where we last left
+			 * off (the last time we were called), reset the 
+			 * beginning pointer.
+			 */
+			len = 0;
+			begin = pos;
+		}
+		if (pos > offset + length) {
+			/*
+			 * We have written past the end of the buffer 
+			 * (proc_read/writescsi gives us 1K slop
+			 *
+			 * stop the output and calculate the correct length
+			 */
+			goto stop_output;
+		}
+	}
+	/*
+	 * begin is where we last checked our position with regards to offset
+	 * begin is always less than offset.  len is relative to begin.  It
+	 * is the number of bytes written past begin
+	 *
+	 */
+stop_output:
+	*(buffer + len) = '\0';
+
+	len -= (offset - begin);
+	if (len > length) {
+		len = length;
+	}
+	return len;
+}
+
+
+/*
+ * I2O System Table.  Contains information about
+ * all the IOPs in the system.  Used to inform IOPs
+ * about each other's existence.
+ *
+ * sys_tbl_ver is the CurrentChangeIndicator that is
+ * used by IOPs to track changes.
+ */
+
+
+int adpt_i2o_build_sys_table(void)
+{
+	adpt_hba* pHba = NULL;
+	int count = 0;
+
+	sys_tbl_len = sizeof(struct i2o_sys_tbl) +	// Header + IOPs
+				(hba_count) * sizeof(struct i2o_sys_tbl_entry);
+
+	if(sys_tbl)
+		kfree(sys_tbl);
+
+	sys_tbl = kmalloc(sys_tbl_len, GFP_KERNEL|ADDR32);
+	if(!sys_tbl) {
+		printk(KERN_ERR "SysTab Set failed. Out of memory.\n");	
+		return -ENOMEM;
+	}
+	memset(sys_tbl, 0, sys_tbl_len);
+
+	sys_tbl->num_entries = hba_count;
+	sys_tbl->version = I2OVERSION;
+	sys_tbl->change_ind = sys_tbl_ind++;
+
+	for(pHba = hba_chain; pHba; pHba = pHba->next) {
+		// Get updated Status Block so we have the latest information
+		if (adpt_i2o_status_get(pHba)) {
+			sys_tbl->num_entries--;
+			continue; // try next one	
+		}
+
+		sys_tbl->iops[count].org_id = pHba->status_block->org_id;
+		sys_tbl->iops[count].iop_id = pHba->unit + 2;
+		sys_tbl->iops[count].seg_num = 0;
+		sys_tbl->iops[count].i2o_version = pHba->status_block->i2o_version;
+		sys_tbl->iops[count].iop_state = pHba->status_block->iop_state;
+		sys_tbl->iops[count].msg_type = pHba->status_block->msg_type;
+		sys_tbl->iops[count].frame_size = pHba->status_block->inbound_frame_size;
+		sys_tbl->iops[count].last_changed = sys_tbl_ind - 1; // ??
+		sys_tbl->iops[count].iop_capabilities = pHba->status_block->iop_capabilities;
+		sys_tbl->iops[count].inbound_low = (u32)virt_to_bus((void*)pHba->post_port);
+		sys_tbl->iops[count].inbound_high = (u32)((u64)virt_to_bus((void*)pHba->post_port)>>32);
+
+		count++;
+	}
+
+#ifdef DEBUG
+{
+	u32 *table = (u32*)sys_tbl;
+	printk(KERN_INFO"sys_tbl_len=%d in 32bit words\n",(sys_tbl_len >>2));
+	for(count = 0; count < (sys_tbl_len >>2); count++) {
+		printk(KERN_INFO "sys_tbl[%d] = %0#10x\n", 
+			count, table[count]);
+	}
+}
+#endif
+
+	return 0;
+}
+
+
+s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
+{
+	u8 *status;
+	u32 m;
+	u32 *msg;
+	int i;
+	u32 timeout = jiffies + TMOUT_INITOUTBOUND*HZ;
+	u32* ptr;
+	u32 outbound_frame;
+
+	do {
+		rmb();
+		m = readl(pHba->post_port);
+		if (m != EMPTY_QUEUE) {
+			break;
+		}
+
+		if(time_after(jiffies,timeout)){
+			printk("%s: Timeout waiting for message frame\n",pHba->name);
+			return -ETIMEDOUT;
+		}
+	} while(m == EMPTY_QUEUE);
+
+	msg=(u32 *)(pHba->msg_addr_virt+m);
+
+	status = kmalloc(4,GFP_KERNEL|ADDR32);
+	if (status==NULL) {
+		adpt_send_nop(pHba, m);
+		printk(KERN_ERR "%s: IOP reset failed - no free memory.\n",
+			pHba->name);
+		return -ENOMEM;
+	}
+	memset(status, 0, 4);
+
+	writel(EIGHT_WORD_MSG_SIZE| SGL_OFFSET_6, &msg[0]);
+	writel(I2O_CMD_OUTBOUND_INIT<<24 | HOST_TID<<12 | ADAPTER_TID, &msg[1]);
+	writel(0, &msg[2]);
+	writel(0x0106, &msg[3]);	/* Transaction context */
+	writel(4096, &msg[4]);		/* Host page frame size */
+	writel((REPLY_FRAME_SIZE)<<16|0x80, &msg[5]);	/* Outbound msg frame size and Initcode */
+	writel(0xD0000004, &msg[6]);		/* Simple SG LE, EOB */
+	writel(virt_to_bus(status), &msg[7]);
+
+	writel(m, pHba->post_port);
+	wmb();
+
+	// Wait for the reply status to come back
+	do {
+		if ((volatile u32)*status) {
+			if ((volatile u32)*status != 0x01 /*I2O_EXEC_OUTBOUND_INIT_IN_PROGRESS*/) {
+				break;
+			}
+		}
+		rmb();
+		if(time_after(jiffies,timeout)){
+			printk("%s: Timeout Initializing\n",pHba->name);
+			kfree((void*)status);
+			return -ETIMEDOUT;
+		}
+	} while (1);
+
+	// If the command was successful, fill the fifo with our reply
+	// message packets
+	if ((volatile u32)(*status) != 0x04 /*I2O_EXEC_OUTBOUND_INIT_COMPLETE*/) {
+		kfree((void*)status);
+		return -2;
+	}
+	kfree((void*)status);
+
+	if(pHba->reply_pool != NULL){
+		kfree(pHba->reply_pool);
+	}
+
+	pHba->reply_pool = (u32*)kmalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
+	if(!pHba->reply_pool){
+		printk(KERN_ERR"%s: Could not allocate reply pool\n",pHba->name);
+		return -1;
+	}
+	memset(pHba->reply_pool, 0 , pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4);
+
+	ptr = pHba->reply_pool;
+	// TODO remove this code
+	m = 0; 
+	for(i = 0; i < pHba->reply_fifo_size; i++) {
+		outbound_frame = (u32)virt_to_bus(ptr);
+		if(m) {
+			if ((m + REPLY_FRAME_SIZE * 4) != outbound_frame) {
+				printk(KERN_WARNING"%s: Reply Frames are not in a contiguous pool, skipping one\n",pHba->name);
+			} else {
+				writel(m, pHba->reply_port);
+				wmb();
+			}
+		}
+		m = outbound_frame;
+		ptr +=  REPLY_FRAME_SIZE;
+	}
+	// the last frame represented in m & outbound_frame is necessarily lost by the above algorithm.
+	adpt_i2o_status_get(pHba);
+	return 0;
+}
+
+
+void adpt_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	Scsi_Cmnd* cmd;
+	adpt_hba* pHba=NULL;
+	u32 m;
+	ulong reply;
+	u32 status=0;
+	u32 context;
+	ulong flags = 0;
+
+	pHba = dev_id;
+	if (pHba == NULL ){
+		printk("adpt_isr: NULL dev_id\n");
+		return;
+	}
+	spin_lock_irqsave(&io_request_lock, flags);
+	while( readl(pHba->irq_mask) & I2O_INTERRUPT_PENDING_B) {
+		m = readl(pHba->reply_port);
+		if(m == EMPTY_QUEUE){
+			// Try twice then give up
+			rmb();
+			m = readl(pHba->reply_port);
+			if(m == EMPTY_QUEUE){ 
+				// This really should not happen
+				printk(KERN_ERR"dpti: Could not get reply frame\n");
+				spin_unlock_irqrestore(&io_request_lock,flags);
+				return;
+			}
+		}
+		reply = (ulong)bus_to_virt(m);
+
+		if (readl(reply) & MSG_FAIL) {
+			u32 old_m = readl(reply+28); 
+			ulong msg;
+			u32 old_context;
+			PDEBUG("%s: Failed message\n",pHba->name);
+			if(old_m >= 0x100000){
+				printk(KERN_ERR"%s: Bad preserved MFA (%x)- dropping frame\n",pHba->name,old_m);
+				writel(m,pHba->reply_port);
+				continue;
+			}
+			// Transaction context is 0 in failed reply frame
+			msg = (ulong)(pHba->msg_addr_virt + old_m);
+			old_context = readl(msg+12);
+			writel(old_context, reply+12);
+			adpt_send_nop(pHba, old_m);
+		} 
+		context = readl(reply+8);
+		if(context & 0x40000000){ // IOCTL
+			caddr_t p = (caddr_t)(readl(reply+12));
+			if( p != NULL) {
+				memcpy(p, (caddr_t)reply, REPLY_FRAME_SIZE * 4);
+			}
+			// All IOCTLs will also be post wait
+		}
+		if(context & 0x80000000){ // Post wait message
+			status = readl(reply+16);
+			if(status  >> 24){
+				status = -( status & 0xffff);
+			} else {
+				status = I2O_POST_WAIT_OK;
+			}
+			if(!(context & 0x40000000)) {
+				cmd = (Scsi_Cmnd*) readl(reply+12); 
+				if(cmd != NULL) {
+					printk(KERN_WARNING"%s: Apparent SCSI cmd in Post Wait Context - cmd=%p context=%x\n", pHba->name, cmd, context);
+				}
+			}
+			adpt_i2o_post_wait_complete(context, status);
+		} else { // SCSI message
+			cmd = (Scsi_Cmnd*) readl(reply+12); 
+			if(cmd != NULL){
+				if(cmd->serial_number != 0) { // If not timedout
+					adpt_i2o_to_scsi(reply, cmd);
+				}
+			}
+		}
+		writel(m, pHba->reply_port);
+		wmb();
+		rmb();
+	}
+	spin_unlock_irqrestore(&io_request_lock, flags);
+	return;
+
+}
+
+s32 adpt_send_nop(adpt_hba*pHba,u32 m)
+{
+	u32 *msg;
+	u32 timeout = jiffies + 5*HZ;
+
+	while(m == EMPTY_QUEUE){
+		rmb();
+		m = readl(pHba->post_port);
+		if(m != EMPTY_QUEUE){
+			break;
+		}
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR "%s: Timeout waiting for message frame!\n",pHba->name);
+			return 2;
+		}
+	}
+	msg = (u32*)(pHba->msg_addr_virt + m);
+	writel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);
+	writel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);
+	writel( 0,&msg[2]);
+	wmb();
+
+	writel(m, pHba->post_port);
+	wmb();
+	return 0;
+}
+
+
+/*
+ * dpti2oscsi2.c contains a table of scsi commands that is used to determine
+ * the data direction of the command.  It is used in dpt_scsi_to_i2o to speed
+ * up the building of the scsi message.
+ */
+#include "dpti2oscsi2.c"
+
+
+s32 adpt_scsi_to_i2o(adpt_hba* pHba, Scsi_Cmnd* cmd, struct adpt_device* d)
+{
+	int i;
+	u32 msg[MAX_MESSAGE_SIZE/4];
+	u32* mptr;
+	u32 *lenptr;
+	int direction;
+	int scsidir;
+	u32 len;
+	u32 reqlen;
+	s32 rcode;
+
+	memset(msg, 0 , sizeof(msg));
+	len = cmd->request_bufflen;
+	direction = 0x00000000;	
+	
+	scsidir = 0x00000000;			// DATA NO XFER
+	if(len) {
+		/*
+		 * Set SCBFlags to indicate if data is being transferred
+		 * in or out, or no data transfer
+		 * Note:  Do not have to verify index is less than 0 since
+		 * cmd->cmnd[0] is an unsigned char
+		 */
+		if (cmd->cmnd[0] < DISKXFERTBLSIZE) {
+			switch (i2oscsi2diskxfer[cmd->cmnd[0]]) {
+			case DATAIN:
+				scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+				break;
+			case DATAOUT:
+				direction=0x04000000;	// SGL OUT
+				scsidir  =0x80000000;	// DATA OUT (iop-->dev)
+				break;
+			case NODATA:
+				break;
+			case NOSUPPORT:
+				scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+				// Assume In - and continue;
+				break;
+			default:
+				printk("%s: scsi opcode 0x%x not supported.\n",
+				     pHba->name, cmd->cmnd[0]);
+				cmd->result = (DID_OK <<16) | (INITIATOR_ERROR << 8);
+				cmd->scsi_done(cmd);
+				return 	0;
+			}
+		} else {
+			printk("%s: cmd->cmnd[0] = %d is greater than table size, which is %d\n",
+			     pHba->name, cmd->cmnd[0], DISKXFERTBLSIZE);
+		}
+	}
+	// msg[0] is set later
+	// I2O_CMD_SCSI_EXEC
+	msg[1] = ((0xff<<24)|(HOST_TID<<12)|d->tid);
+	msg[2] = 0;
+	msg[3] = (u32)cmd;	/* We want the SCSI control block back */
+	// Our cards use the transaction context as the tag for queueing
+	// Adaptec/DPT Private stuff 
+	msg[4] = I2O_CMD_SCSI_EXEC|(DPT_ORGANIZATION_ID<<16);
+	msg[5] = d->tid;
+	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
+	// I2O_SCB_FLAG_ENABLE_DISCONNECT | 
+	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 
+	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
+	msg[6] = scsidir|0x20a00000|cmd->cmd_len;
+
+	mptr=msg+7;
+
+	// Write SCSI command into the message - always 16 byte block 
+	memset(mptr, 0,  16);
+	memcpy(mptr, cmd->cmnd, cmd->cmd_len);
+	mptr+=4;
+	lenptr=mptr++;		/* Remember me - fill in when we know */
+	reqlen = 14;		// SINGLE SGE
+	/* Now fill in the SGList and command */
+	if(cmd->use_sg) {
+		struct scatterlist *sg = (struct scatterlist *)cmd->request_buffer;
+		len = 0;
+		for(i = 0 ; i < cmd->use_sg; i++) {
+			*mptr++ = direction|0x10000000|sg->length;
+			len+=sg->length;
+			*mptr++ = virt_to_bus(sg->address);
+			sg++;
+		}
+		/* Make this an end of list */
+		mptr[-2] = direction|0xD0000000|(sg-1)->length;
+		reqlen = mptr - msg;
+		*lenptr = len;
+		
+		if(cmd->underflow && len != cmd->underflow){
+			printk("Cmd len %08X Cmd underflow %08X\n",
+				len, cmd->underflow);
+		}
+	} else {
+		*lenptr = len = cmd->request_bufflen;
+		if(len == 0) {
+			reqlen = 12;
+		} else {
+			*mptr++ = 0xD0000000|direction|cmd->request_bufflen;
+			*mptr++ = virt_to_bus(cmd->request_buffer);
+		}
+	}
+	
+	/* Stick the headers on */
+	msg[0] = reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0);
+	
+	// Send it on it's way
+	rcode = adpt_i2o_post_this(pHba, msg, reqlen<<2);
+	if (rcode == 0) {
+		return 0;
+	}
+	return rcode;
+}
+
+
+int adpt_abort(Scsi_Cmnd * cmd)
+{
+	adpt_hba* pHba = NULL;	/* host bus adapter structure */
+	struct adpt_device* dptdevice;	/* dpt per device information */
+	u32 msg[5];
+
+	printk(KERN_INFO"%s: Aborting cmd=%p\n",pHba->name, cmd);
+
+	pHba = (adpt_hba*) cmd->host->hostdata[0];
+	if ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {
+		printk(KERN_ERR "%s: Unable to abort: No device in cmnd\n",pHba->name);
+		return SCSI_ABORT_NOT_RUNNING;
+	}
+
+	memset(msg, 0, sizeof(msg));
+	msg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;
+	msg[2] = 0;
+	msg[3]= 0; 
+	msg[4] = (u32)cmd;
+	if(adpt_i2o_post_wait(pHba, msg, sizeof(msg), 60) != 0){
+		return FAILED; // Timedout
+	} 
+	return  SUCCESS;
+}
+
+
+/*
+ * When adpt_release is called (from scsi_unregister_host, etc.), there are
+ * no longer any scsi command or device structures for this host in the
+ * upper-level scsi code - cannot send any commands up
+ *
+ * scsi_unregister will be called AFTER we return. 
+ */
+int adpt_release(struct Scsi_Host *host)
+{
+	adpt_hba* pHba = (adpt_hba*) host->hostdata[0];
+//	adpt_i2o_quiesce_hba(pHba);
+	adpt_i2o_delete_hba(pHba);
+	return 0;
+}
+
+
+void adpt_inquiry(adpt_hba* pHba)
+{
+	u32 msg[14]; 
+	u32 *mptr;
+	u32 *lenptr;
+	int direction;
+	int scsidir;
+	u32 len;
+	u32 reqlen;
+	u8* buf;
+	u8  scb[16];
+	s32 rcode;
+
+	memset(msg, 0, sizeof(msg));
+	buf = (u8*)kmalloc(36,GFP_KERNEL|ADDR32);
+	if(!buf){
+		printk(KERN_ERR"%s: Could not allocate buffer\n",pHba->name);
+		return;
+	}
+	memset((void*)buf, 0, 36);
+	
+	len = 36;
+	direction = 0x00000000;	
+	scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+
+	reqlen = 14;		// SINGLE SGE
+	/* Stick the headers on */
+	msg[0] = reqlen<<16 | SGL_OFFSET_12;
+	msg[1] = (0xff<<24|HOST_TID<<12|ADAPTER_TID);
+	msg[2] = 0;
+	msg[3]  = 0;
+	// Adaptec/DPT Private stuff 
+	msg[4] = I2O_CMD_SCSI_EXEC|DPT_ORGANIZATION_ID<<16;
+	msg[5] = ADAPTER_TID | 1<<16 /* Interpret*/;
+	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
+	// I2O_SCB_FLAG_ENABLE_DISCONNECT | 
+	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 
+	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
+	msg[6] = scsidir|0x20a00000| 6 /* cmd len*/;
+
+	mptr=msg+7;
+
+	memset(scb, 0, sizeof(scb));
+	// Write SCSI command into the message - always 16 byte block 
+	scb[0] = INQUIRY;
+	scb[1] = 0;
+	scb[2] = 0;
+	scb[3] = 0;
+	scb[4] = 36;
+	scb[5] = 0;
+	// Don't care about the rest of scb
+
+	memcpy(mptr, scb, sizeof(scb));
+	mptr+=4;
+	lenptr=mptr++;		/* Remember me - fill in when we know */
+
+	/* Now fill in the SGList and command */
+	*lenptr = len;
+	*mptr++ = 0xD0000000|direction|len;
+	*mptr++ = virt_to_bus(buf);
+
+	// Send it on it's way
+	rcode = adpt_i2o_post_wait(pHba, msg, reqlen<<2, 120);
+	if (rcode != 0) {
+		sprintf(pHba->detail, "Adaptec I2O RAID");
+		printk(KERN_INFO "%s: Inquiry Error (%d)\n",pHba->name,rcode);
+	} else {
+		memset(pHba->detail, 0, sizeof(pHba->detail));
+		memcpy(&(pHba->detail), "Vendor: Adaptec ", 16);
+		memcpy(&(pHba->detail[16]), " Model: ", 8);
+		memcpy(&(pHba->detail[24]), (u8*) &buf[16], 16);
+		memcpy(&(pHba->detail[40]), " Rev: ", 6);
+		memcpy(&(pHba->detail[46]), (u8*) &buf[32], 4);
+		pHba->detail[50] = '\0';	/* precautionary */
+	}
+	kfree(buf);
+	adpt_i2o_status_get(pHba);
+	return ;
+}
+
+
+// This version of reset is called by the eh_error_handler
+int adpt_reset(Scsi_Cmnd* cmd)
+{
+	adpt_hba* pHba;
+	pHba = (adpt_hba*)cmd->host->hostdata;
+	return adpt_hba_reset(pHba);
+}
+
+
+int adpt_hba_reset(adpt_hba* pHba)
+{
+	int rcode;
+	ulong flags;
+
+	pHba->state |= DPTI_STATE_RESET;
+
+	spin_lock_irqsave(&io_request_lock, flags);
+	// Activate does get status , init outbound, and get hrt
+	if ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		printk(KERN_ERR "%s: Could not activate\n", pHba->name);
+		adpt_i2o_delete_hba(pHba);
+		return rcode;
+	}
+
+	if ((rcode=adpt_i2o_build_sys_table()) < 0) {
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		adpt_i2o_delete_hba(pHba);
+		return rcode;
+	}
+	PDEBUG("%s: in HOLD state\n",pHba->name);
+
+	if ((rcode=adpt_i2o_online_hba(pHba)) < 0) {
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		adpt_i2o_delete_hba(pHba);	
+		return rcode;
+	}
+	PDEBUG("%s: in OPERATIONAL state\n",pHba->name);
+
+	if ((rcode=adpt_i2o_lct_get(pHba)) < 0){
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		adpt_i2o_delete_hba(pHba);
+		return rcode;
+	}
+
+	if ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		adpt_i2o_delete_hba(pHba);
+		return rcode;
+	}
+	pHba->state &= ~DPTI_STATE_RESET;
+
+	adpt_fail_posted_scbs(pHba);
+	spin_unlock_irqrestore(&io_request_lock, flags);
+	return 0;	/* return success */
+}
+
+
+// This version of bus reset is called by the eh_error handler
+int adpt_bus_reset(Scsi_Cmnd* cmd)
+{
+	adpt_hba* pHba;
+	u32 msg[4];
+	pHba = (adpt_hba*)cmd->host->hostdata;
+#define I2O_HBA_BUS_RESET 0x87
+	memset(msg, 0, sizeof(msg));
+	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->channel].tid);
+	msg[2] = 0;
+	msg[3] = 0;
+	if(  adpt_i2o_post_wait(pHba, (void*)msg,sizeof(msg), FOREVER) ){
+		// TODO we need to watch out here for infinite loops
+		cmd->result = (DID_OK<<16) | (QUEUE_FULL << 1);
+		cmd->scsi_done(cmd);
+		return SUCCESS;
+	} else {
+		cmd->result = (DID_OK<<16);
+		cmd->scsi_done(cmd);
+		return SUCCESS;
+	}
+}
+
+// This is not currently supported by our adapter but we issue it anyway
+int adpt_device_reset(Scsi_Cmnd* cmd)
+{
+	adpt_hba* pHba;
+	u32 msg[4];
+	struct adpt_device* d = (void*) cmd->device->hostdata;
+
+	pHba = (void*) cmd->host->hostdata;
+	if (!d) {
+		printk("%s: Reset Device: Device Not found\n",pHba->name);
+		return FAILED;
+	}
+#define I2O_DEVICE_RESET 0x27
+	// This is the same for BLK and SCSI devices
+	// NOTE this is wrong in the i2o.h definitions
+	memset(msg, 0, sizeof(msg));
+	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);
+	msg[2] = 0;
+	msg[3] = 0;
+	if( adpt_i2o_post_wait(pHba, (void*)msg,sizeof(msg), FOREVER) ){
+		// TODO we need to watch out here for infinite loops
+		cmd->result = (DID_OK<<16) | (QUEUE_FULL << 1);
+		cmd->scsi_done(cmd);
+		return SUCCESS;
+	} else {
+		cmd->result = (DID_OK<<16);
+		cmd->scsi_done(cmd);
+		return SUCCESS;
+	}
+}
+
+void adpt_select_queue_depths(struct Scsi_Host *host, Scsi_Device * devicelist)
+{
+	Scsi_Device *device;	/* scsi layer per device information */
+	adpt_hba* pHba;
+
+	pHba = (adpt_hba *) host->hostdata[0];
+
+	for (device = devicelist; device != NULL; device = device->next) {
+		if (device->host != host) {
+			continue;
+		}
+		// TODO find better number for this
+		if (host->can_queue) {
+			device->queue_depth =  host->can_queue - 1;
+		} else {
+			device->queue_depth = 1;
+		}
+	}
+}
+
+int adpt_queue(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
+{
+	adpt_hba* pHba = NULL;
+	struct adpt_device* pDev = NULL;	/* dpt per device information */
+	u32 timeout = jiffies + (TMOUT_SCSI*HZ);
+
+	cmd->scsi_done = done;
+	/*
+	 * SCSI REQUEST_SENSE commands will be executed automatically by the 
+	 * Host Adapter for any errors, so they should not be executed 
+	 * explicitly unless the Sense Data is zero indicating that no error 
+	 * occurred.
+	 */
+
+	if ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {
+		cmd->result = (DID_OK << 16);
+		cmd->scsi_done(cmd);
+		return 0;
+	}
+
+	pHba = (adpt_hba*)cmd->host->hostdata[0];
+	if (!pHba) {
+		return FAILED;
+	}
+
+	if((((volatile u32)pHba->state) & DPTI_STATE_IOCTL) ||
+	      (((volatile u32)pHba->state) & DPTI_STATE_RESET)) {
+		pHba->host->last_reset = jiffies;
+		pHba->host->resetting = 1;
+		return 1;
+	}
+	mod_timer(&cmd->eh_timeout, timeout);
+
+	if((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {
+		/*
+		 * First command request for this device.  Set up a pointer
+		 * to the device structure.  This should be a TEST_UNIT_READY
+		 * command from scan_scsis_single.
+		 */
+		if ((pDev = adpt_find_device(pHba, (u32)cmd->channel, (u32)cmd->target, (u32)cmd-> lun)) == NULL) {
+			cmd->result = (DID_NO_CONNECT << 16);
+			cmd->scsi_done(cmd);
+			return 0;
+		}
+		(struct adpt_device*)(cmd->device->hostdata) = pDev;
+	}
+	pDev->pScsi_dev = cmd->device;
+
+	/*
+	 * Let the rescan handler notify the sd layer to rescan the devices
+	 */
+	if (pDev->state & DPTI_DEV_OFFLINE) {
+		if (cmd->device != NULL) {
+			cmd->device->online = FALSE;
+		}
+		cmd->result = (DID_NO_CONNECT << 16);
+		cmd->scsi_done(cmd);
+		return 0;
+	}
+
+	/*
+	 * If we are being called from when the device is being reset, 
+	 * or while being rescanned,
+	 * delay processing of the command until later.
+	 * MS: UNSCANNED components are typically not an issue because the applications
+	 * ensure (race conditions though) that the device to be alterred is not mounted
+	 * before adjusting the configurations. TIDs that have gone missing are better
+	 * processed by bubbling up the FAILED reply frame as a catastrophic failure of
+	 * the command.
+	 */
+	if (pDev->state & DPTI_DEV_RESET /* || pDev->state & DPTI_DEV_UNSCANNED */) {
+		return FAILED;
+	}
+	return adpt_scsi_to_i2o(pHba, cmd, pDev);
+}
+
+
+s32 adpt_scsi_register(adpt_hba* pHba,Scsi_Host_Template * sht)
+{
+	struct Scsi_Host *host = NULL;
+
+	host = scsi_register(sht, sizeof(adpt_hba*));
+	if (host == NULL) {
+		printk ("%s: scsi_register returned NULL\n",pHba->name);
+		return -1;
+	}
+	(adpt_hba*)(host->hostdata[0]) = pHba;
+	pHba->host = host;
+
+	host->irq = pHba->pDev->irq;;
+	/* no IO ports, so don't have to set host->io_port and 
+	 * host->n_io_port
+	 */
+	host->io_port = 0;
+	host->n_io_port = 0;
+				/* see comments in hosts.h */
+	host->max_id = pHba->top_scsi_id + 1;
+	host->max_lun = pHba->top_scsi_lun + 1;
+	host->max_channel = pHba->top_scsi_channel;
+	host->cmd_per_lun = 256;
+	host->unique_id = (unsigned int) pHba;
+	host->sg_tablesize = pHba->sg_tablesize;
+	host->can_queue = pHba->post_fifo_size;
+	host->select_queue_depths = adpt_select_queue_depths;
+
+	return 0;
+}
+
+
+int adpt_bios_param(Disk* disk, kdev_t dev, int geom[])
+{
+	int heads=-1;
+	int sectors=-1;
+	int cylinders=-1;
+
+	// *** First lets set the default geometry ****
+	
+	// If the capacity is less than ox2000
+	if (disk->capacity < 0x2000 ) {	// floppy
+		heads = 18;
+		sectors = 2;
+	} 
+	// else if between 0x2000 and 0x20000
+	else if (disk->capacity < 0x20000) {
+		heads = 64;
+		sectors = 32;
+	}
+	// else if between 0x20000 and 0x40000
+	else if (disk->capacity < 0x40000) {
+		heads = 65;
+		sectors = 63;
+	}
+	// else if between 0x4000 and 0x80000
+	else if (disk->capacity < 0x80000) {
+		heads = 128;
+		sectors = 63;
+	}
+	// else if greater than 0x80000
+	else {
+		heads = 255;
+		sectors = 63;
+	}
+	cylinders = disk->capacity / (heads * sectors);
+
+	// Special case if CDROM
+	if(disk->device->type == 5) {  // CDROM
+		heads = 252;
+		sectors = 63;
+		cylinders = 1111;
+	}
+	// *** Now lets read the partition table to see what it thinks ****
+	//
+	// TODO(defer) dmb - use marks algorythm
+	if( disk->has_part_table == 1){
+
+
+	}
+
+
+
+
+	geom[0] = heads;
+	geom[1] = sectors;
+	geom[2] = cylinders;
+
+	
+	
+	PDEBUG("adpt_bios_param: exit\n");
+	return 0;
+}
+
+
+
+#if 0
+int adpt_read_capacity(adpt_hba* pHba, struct adpt_device* d)
+{
+	u32 msg[MAX_MESSAGE_SIZE/4], *mptr;
+	u32 *lenptr;
+	int direction;
+	int scsidir;
+	u32 len;
+	u32 reqlen;
+	u8* buf;
+	u8  scb[16];
+	u8* ptr;
+	s32 rcode;
+
+	memset(msg, 0, sizeof(msg));
+	len = 8;
+	buf = (u8*)kmalloc(len,GFP_KERNEL|ADDR32);
+	memset((void*)buf, 0, len);
+	direction = 0x00000000;	
+	scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+	reqlen = 14;		// SINGLE SGE
+
+	/* Stick the headers on */
+	msg[0] = reqlen<<16 | SGL_OFFSET_12;
+	msg[1] = (0xff<<24|HOST_TID<<12|d->tid);
+	msg[2] = 0;
+	msg[3] = 0;
+	// Adaptec/DPT Private stuff 
+	msg[4] = I2O_CMD_SCSI_EXEC|DPT_ORGANIZATION_ID<<16;
+	msg[5] = d->tid | 1<<16 /* Interpret*/;
+	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
+	// I2O_SCB_FLAG_ENABLE_DISCONNECT | 
+	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 
+	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
+	msg[6] = scsidir|0x20a00000| 10 /* cmd len*/;
+
+	mptr=msg+7;
+
+	memset(scb, 0, sizeof(scb));
+	// Write SCSI command into the message - always 16 byte block 
+	scb[0] = READ_CAPACITY;	
+	scb[1] = 0;
+	scb[2] = 0;
+	scb[3] = 0;
+	scb[4] = 8;
+	scb[5] = 0;
+	scb[6] = 0;
+	scb[7] = 0;
+	scb[8] = 0;
+	scb[9] = 0;
+	// Don't care about the rest of scb
+
+	memcpy(mptr, scb, 16);
+	mptr+=4;
+	lenptr=mptr++;		/* Remember me - fill in when we know */
+
+	/* Now fill in the SGList and command */
+	*lenptr = len;
+	*mptr++ = 0xD0000000|direction|len;
+	*mptr++ = virt_to_bus(buf);
+
+	// Send it on it's way
+	if( (rcode = adpt_i2o_post_wait(pHba, msg, reqlen<<2,120)) ){
+		printk("%s: Read Capacity failed (%d)\n",pHba->name, rcode);
+		d->capacity = 0;
+		d->block_size = 0;
+	} else {
+		int i;
+		ptr = (u8*) &d->capacity;
+		for (i = 0; i < 4; ++i) {
+			ptr[i] = buf[3-i];
+		}
+		ptr = (u8*)&d->block_size;
+		for (i = 0; i < 4; ++i) {
+			ptr[i] = buf[7-i];
+		}
+	}
+
+	kfree(buf);
+	return rcode;
+}
+#endif
+
+
+s32 adpt_i2o_to_scsi(ulong reply, Scsi_Cmnd* cmd)
+{
+	adpt_hba* pHba;
+	// I know this would look cleaner if I just read bytes
+	// but the model I have been using for all the rest of the
+	// io is in 4 byte words - so I keep that model
+	u8 req_status = ( readl(reply+16) >> 24)&0xff;
+	u16 detailed_status = readl(reply+16) &0xffff;
+	u32 hba_status;
+	u32 dev_status;
+	u32 reply_flags = readl(reply) & 0xff00; // Leave it shifted up 8 bits 
+
+	dev_status = detailed_status & 0xff;
+	hba_status = detailed_status >> 8;
+	pHba = (adpt_hba*) cmd->host->hostdata[0];
+
+	if (!(reply_flags & MSG_FAIL)) {
+		if (req_status) {
+			switch (detailed_status & I2O_SCSI_DSC_MASK) {
+			case I2O_SCSI_DSC_SUCCESS:
+				cmd->result = (DID_OK << 16);
+				break;
+			case I2O_SCSI_DSC_REQUEST_ABORTED:
+				cmd->result = (DID_ABORT << 16);
+				break;
+			case I2O_SCSI_DSC_UNABLE_TO_ABORT:
+			case I2O_SCSI_DSC_COMPLETE_WITH_ERROR:
+			case I2O_SCSI_DSC_UNABLE_TO_TERMINATE:
+			case I2O_SCSI_DSC_MR_MESSAGE_RECEIVED:
+			case I2O_SCSI_DSC_AUTOSENSE_FAILED:
+			case I2O_SCSI_DSC_DATA_OVERRUN:
+			case I2O_SCSI_DSC_UNEXPECTED_BUS_FREE:
+			case I2O_SCSI_DSC_SEQUENCE_FAILURE:
+			case I2O_SCSI_DSC_REQUEST_LENGTH_ERROR:
+			case I2O_SCSI_DSC_PROVIDE_FAILURE:
+			case I2O_SCSI_DSC_REQUEST_TERMINATED:
+			case I2O_SCSI_DSC_IDE_MESSAGE_SENT:
+			case I2O_SCSI_DSC_UNACKNOWLEDGED_EVENT:
+			case I2O_SCSI_DSC_MESSAGE_RECEIVED:
+			case I2O_SCSI_DSC_INVALID_CDB:
+			case I2O_SCSI_DSC_LUN_INVALID:
+			case I2O_SCSI_DSC_SCSI_TID_INVALID:
+			case I2O_SCSI_DSC_FUNCTION_UNAVAILABLE:
+			case I2O_SCSI_DSC_NO_NEXUS:
+			case I2O_SCSI_DSC_SCSI_IID_INVALID:
+			case I2O_SCSI_DSC_CDB_RECEIVED:
+			case I2O_SCSI_DSC_LUN_ALREADY_ENABLED:
+			case I2O_SCSI_DSC_QUEUE_FROZEN:
+				cmd->result = (DID_ERROR << 16);
+				break;
+			case I2O_SCSI_DSC_ADAPTER_BUSY:
+			case I2O_SCSI_DSC_BUS_BUSY:
+				cmd->result = (DID_BUS_BUSY << 16);
+				break;
+			case I2O_SCSI_DSC_REQUEST_INVALID:
+				cmd->result = (DID_ERROR << 16);
+				break;
+			case I2O_SCSI_DSC_PATH_INVALID:
+			case I2O_SCSI_DSC_DEVICE_NOT_PRESENT:
+			case I2O_SCSI_DSC_SELECTION_TIMEOUT:
+			case I2O_SCSI_DSC_COMMAND_TIMEOUT:
+			case I2O_SCSI_DSC_NO_ADAPTER:
+			case I2O_SCSI_DSC_RESOURCE_UNAVAILABLE:
+				cmd->result = (DID_TIME_OUT << 16);
+				cmd->device->online = FALSE;
+				break;
+			case I2O_SCSI_DSC_SCSI_BUS_RESET:
+			case I2O_SCSI_DSC_BDR_MESSAGE_SENT:
+				cmd->result = (DID_RESET << 16);
+				break;
+			case I2O_SCSI_DSC_PARITY_ERROR_FAILURE:
+				cmd->result = (DID_ERROR << 16);
+				break;
+			default:
+				cmd->result = (DID_NO_CONNECT << 16);
+				break;
+			}
+
+			// If there is a SCSI target status, save it off in the OS request 
+			// packet and copy over the request sense data if it was a check
+			// condition status
+			if (dev_status == 0x02 /*I2O_SCSI_DSC_CHECK_CONDITION*/) {
+				u32 len = sizeof(cmd->sense_buffer);
+				len = (len > 40) ?  40 : len;
+				// Copy over the sense data
+				memcpy(cmd->sense_buffer, (void*)(reply+28) , len);
+			}
+		} else {
+			cmd->result = (DID_OK << 16);
+		}
+
+	} else {
+		/*
+		 * We would figure doing a
+		 * 	cmd->result = (DID_NO_CONNECT << 16);
+		 * would be more appropriate, but this would take devices
+		 * offline for a transitory error. Lets allow the applications
+		 * to issue a ioctl rescan, and let that look after taking
+		 * the device offline.
+		 */
+		cmd->result = (DID_TIME_OUT << 16);
+		/*
+		 * Something in the SCSI subsystem is pulling a cruelly upon me.
+		 * The I/O system locks up if I return DID_TIME_OUT (!) but
+		 * handles gracefully DID_NO_CONNECT.
+		 */
+		cmd->result = (DID_NO_CONNECT << 16);
+		printk("%s: I2O MSG_FAIL - Device (%d,%d,%d) tid=%d hba_status = 0x%x, dev_status = 0x%x, cmd = 0x%x\n",pHba->name,
+		(u32)cmd->channel, (u32)cmd->target, (u32)cmd-> lun,
+		((struct adpt_device*)(cmd->device->hostdata))->tid,
+		       hba_status, dev_status, cmd->cmnd[0]);
+	}
+
+	// TODO test the timeout lockup thingie
+	if (cmd->result == (DID_TIME_OUT <<16) ){
+		cmd->result = (DID_NO_CONNECT << 16);
+	}
+
+	if (cmd->result == (DID_ERROR << 16)) {
+		printk("SCSI error - Device (%d,%d,%d) tid=%d hba_status = 0x%x, dev_status = 0x%x, cmd = 0x%x\n",
+		(u32)cmd->channel, (u32)cmd->target, (u32)cmd-> lun,
+		((struct adpt_device*)(cmd->device->hostdata))->tid,
+		       hba_status, dev_status, cmd->cmnd[0]);
+		printk("SCSI cmd serial number  %ld\n", cmd->serial_number);
+	} 
+	if (cmd->result == (DID_TIME_OUT << 16)) {
+		printk("%s: SCSI timeout - Device (%d,%d,%d) tid=%d hba_status = 0x%x, dev_status = 0x%x, cmd = 0x%x\n",pHba->name,
+		(u32)cmd->channel, (u32)cmd->target, (u32)cmd-> lun,
+		((struct adpt_device*)(cmd->device->hostdata))->tid,
+		       hba_status, dev_status, cmd->cmnd[0]);
+		printk("SCSI cmd serial number  %ld\n", cmd->serial_number);
+	} 
+	cmd->result |= (dev_status);
+
+	if(cmd->scsi_done != NULL && cmd->serial_number != 0){
+		cmd->scsi_done(cmd);
+	} else if(cmd->serial_number == 0) {
+		u32 context = readl(reply+8);
+		printk(KERN_WARNING"%s: Interrupt Handler overcompletion - cmd = %p context=%x\n", pHba->name, cmd, context);
+	}
+	return cmd->result;
+}
+
+
+s32 adpt_rescan(adpt_hba* pHba)
+{
+	s32 rcode;
+	u32 flags;
+
+	spin_lock_irqsave(&io_request_lock, flags);
+	if ((rcode=adpt_i2o_lct_get(pHba)) < 0){
+//		adpt_i2o_delete_hba(pHba);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return rcode;
+	}
+
+	if ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){
+//		adpt_i2o_delete_hba(pHba);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return rcode;
+	}
+	spin_unlock_irqrestore(&io_request_lock, flags);
+	return 0;
+}
+
+
+s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
+{
+	int i;
+	int max;
+	int tid;
+	struct i2o_device *d;
+	i2o_lct *lct = pHba->lct;
+	u8 bus_no = 0;
+	s16 scsi_id;
+	s16 scsi_lun;
+	u32 buf[10]; // at least 8 u32's
+	struct adpt_device* pDev = NULL;
+	struct i2o_device* pI2o_dev = NULL;
+	
+	if (lct == NULL) {
+		printk(KERN_ERR "%s: LCT is empty???\n",pHba->name);
+		return -1;
+	}
+	
+	max = lct->table_size;	
+	max -= 3;
+	max /= 9;
+
+	// Mark each drive as unscanned
+	for (d = pHba->devices; d; d = d->next) {
+		pDev =(struct adpt_device*) d->owner;
+		if(!pDev){
+			continue;
+		}
+		pDev->state |= DPTI_DEV_UNSCANNED;
+	}
+
+	printk(KERN_INFO "%s: LCT has %d entries.\n", pHba->name,max);
+	
+	if(lct->iop_flags&(1<<0))
+		printk(KERN_WARNING "%s: Configuration dialog desired.\n", pHba->name);
+
+	for(i=0;i<max;i++) {
+		if( lct->lct_entry[i].user_tid != 0xfff){
+			continue;
+		}
+
+		if( lct->lct_entry[i].class_id == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
+		    lct->lct_entry[i].class_id == I2O_CLASS_SCSI_PERIPHERAL ||
+		    lct->lct_entry[i].class_id == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
+			tid = lct->lct_entry[i].tid;
+			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {
+				printk(KERN_ERR"%s: Could not query device\n",pHba->name);
+				continue;
+			}
+			bus_no = buf[0]>>16;
+			scsi_id = buf[1];
+			scsi_lun = (buf[2]>>8 )&0xff;
+			pDev = pHba->channel[bus_no].device[scsi_id];
+			/* da lun */
+			while(pDev) {
+				if(pDev->scsi_lun == scsi_lun) {
+					break;
+				}
+				pDev = pDev->next_lun;
+			}
+			if(!pDev ) { // Something new add it
+				d = (struct i2o_device *)kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
+				if(d==NULL)
+				{
+					printk(KERN_CRIT "Out of memory for I2O device data.\n");
+					return -ENOMEM;
+				}
+				
+				d->controller = (void*)pHba;
+				d->next = NULL;
+
+				memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
+
+				d->flags = 0;
+				adpt_i2o_report_hba_unit(pHba, d);
+				adpt_i2o_install_device(pHba, d);
+	
+				if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
+					printk(KERN_WARNING"%s: Channel number %d out of range \n", pHba->name, bus_no);
+					continue;
+				}
+				pDev = pHba->channel[bus_no].device[scsi_id];	
+				if( pDev == NULL){
+					pDev =  kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					pHba->channel[bus_no].device[scsi_id] = pDev;
+				} else {
+					while (pDev->next_lun) {
+						pDev = pDev->next_lun;
+					}
+					pDev = pDev->next_lun = kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+				}
+				memset(pDev,0,sizeof(struct adpt_device));
+				pDev->tid = d->lct_data.tid;
+				pDev->scsi_channel = bus_no;
+				pDev->scsi_id = scsi_id;
+				pDev->scsi_lun = scsi_lun;
+				pDev->pI2o_dev = d;
+				d->owner = (struct i2o_handler *)pDev;
+				pDev->type = (buf[0])&0xff;
+				pDev->flags = (buf[0]>>8)&0xff;
+				// Too late, SCSI system has made up it's mind, but what the hey ...
+				if(scsi_id > pHba->top_scsi_id){
+					pHba->top_scsi_id = scsi_id;
+				}
+				if(scsi_lun > pHba->top_scsi_lun){
+					pHba->top_scsi_lun = scsi_lun;
+				}
+				continue;
+			} // end of new i2o device
+
+			// We found an old device - check it
+			while(pDev) {
+				if(pDev->scsi_lun == scsi_lun) {
+					if (pDev->state & DPTI_DEV_OFFLINE) {
+						printk(KERN_WARNING"%s: Device (%d,%d,%d) online\n",pHba->name,bus_no,scsi_id,scsi_lun);
+						if (pDev->pScsi_dev) {
+							pDev->pScsi_dev->online = TRUE;
+						}
+					}
+					d = pDev->pI2o_dev;
+					if(d->lct_data.tid != tid) { // something changed
+						pDev->tid = tid;
+						memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
+						if (pDev->pScsi_dev) {
+							pDev->pScsi_dev->changed = TRUE;
+							pDev->pScsi_dev->removable = TRUE;
+						}
+					}
+					// Found it - mark it scanned
+					pDev->state &= ~(DPTI_DEV_UNSCANNED|DPTI_DEV_OFFLINE);
+					break;
+				}
+				pDev = pDev->next_lun;
+			}
+		}
+	}
+	for (pI2o_dev = pHba->devices; pI2o_dev; pI2o_dev = pI2o_dev->next) {
+		pDev =(struct adpt_device*) pI2o_dev->owner;
+		if(!pDev){
+			continue;
+		}
+		// Drive offline drives that previously existed but could not be found
+		// in the LCT table
+		if (pDev->state & DPTI_DEV_UNSCANNED){
+			pDev->state |= DPTI_DEV_OFFLINE;
+			pDev->state &= ~DPTI_DEV_UNSCANNED;	// just to be clean
+			printk(KERN_WARNING"%s: Device (%d,%d,%d) offline\n",pHba->name,pDev->scsi_channel,pDev->scsi_id,pDev->scsi_lun);
+			if (pDev->pScsi_dev) {
+				pDev->pScsi_dev->online = FALSE;
+				// TODO check if this all that is needed to
+				// notify SCSI layer about this
+				if (pDev->pScsi_dev->access_count) {
+					// A drive that was mounted is no longer there... bad!
+					SCSI_LOG_ERROR_RECOVERY(1, printk ("%s:Rescan: Previously "
+								 "mounted drive not found!\n",pHba->name));
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+void adpt_fail_posted_scbs(adpt_hba* pHba)
+{
+	Scsi_Cmnd* 	cmd = NULL;
+	Scsi_Device* 	d = NULL;
+
+	if( pHba->host->host_queue != NULL ) {
+		d = pHba->host->host_queue;
+		if(!d){
+			return;
+		}
+		while( d->next != NULL ){
+			for(cmd = d->device_queue; cmd ; cmd = cmd->next){
+				if(cmd->serial_number == 0){
+					continue;
+				}
+				cmd->result = (DID_OK << 16) | (QUEUE_FULL <<1);
+				cmd->scsi_done(cmd);
+			}
+			d = d->next;
+		}
+	}
+}
+
+#ifdef UARTDELAY 
+
+static void adpt_delay(int millisec)
+{
+	int i;
+	for (i = 0; i < millisec; i++) {
+		udelay(1000);	/* delay for one millisecond */
+	}
+}
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+struct pci_dev *
+adpt_pci_find_device(unsigned int vendor, struct pci_dev *from)
+{
+	if(!from){
+		from = pci_devices;
+	} else {
+		from = from->next;
+	}
+	while (from && from->vendor != vendor) {
+		from = from->next;
+	}
+	return from;
+}
+#endif
+
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/dpti.h	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,395 @@
+/***************************************************************************
+                          dpti.h  -  description
+                             -------------------
+    begin                : Thu Sep 7 2000
+    copyright            : (C) 2001 by Adaptec
+    email                : deanna_bonds@adaptec.com
+
+    See README.dpti for history, notes, license info, and credits
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _DPT_H
+#define _DPT_H
+
+#define MAX_TO_IOP_MESSAGES   (210)
+#define MAX_FROM_IOP_MESSAGES (56)
+
+#ifndef LINUX_VERSION_CODE
+#include <linux/version.h>
+#endif
+
+#include "sys_info.h"
+
+/*
+ * Function Prototypes
+ */
+
+int adpt_proc_info(char *buffer, char **start, off_t offset,
+		  int length, int inode, int inout);
+int adpt_detect(Scsi_Host_Template * sht);
+int adpt_queue(Scsi_Cmnd * cmd, void (*cmdcomplete) (Scsi_Cmnd *));
+int adpt_abort(Scsi_Cmnd * cmd);
+int adpt_reset(Scsi_Cmnd* cmd);
+int adpt_release(struct Scsi_Host *host);
+
+const char *adpt_info(struct Scsi_Host *pSHost);
+int adpt_bios_param(Disk * disk, kdev_t dev, int geom[]);
+
+int adpt_bus_reset(Scsi_Cmnd* cmd);
+int adpt_device_reset(Scsi_Cmnd* cmd);
+
+
+/*
+ * Scsi_Host_Template (see hosts.h) for DPT - some fields
+ * to do with card config are filled in after the card is detected.
+ */
+
+#define DPT_DRIVER_NAME	"Adaptec I2O RAID"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,00)
+#define DPT_I2O { \
+	proc_info: adpt_proc_info,					\
+	name: DPT_DRIVER_NAME,						\
+	detect: adpt_detect,						\
+	release: adpt_release,						\
+	info: adpt_info,						\
+	queuecommand: adpt_queue,					\
+	eh_abort_handler: adpt_abort,					\
+	eh_device_reset_handler: adpt_device_reset,			\
+	eh_bus_reset_handler: adpt_bus_reset,				\
+	eh_host_reset_handler: adpt_reset,				\
+	bios_param: adpt_bios_param,					\
+	can_queue: MAX_TO_IOP_MESSAGES ,/* max simultaneous cmds      */\
+	this_id: 7,			/* scsi id of host adapter    */\
+	sg_tablesize: 0,		/* max scatter-gather cmds    */\
+	cmd_per_lun: 1,		/* cmds per lun (linked cmds) */\
+	use_clustering: ENABLE_CLUSTERING,				\
+	use_new_eh_code: 1						\
+}
+
+#else				/* KERNEL_VERSION > 2.2.16 */
+
+#define DPT_I2O { \
+	proc_info: adpt_proc_info,					\
+	name: DPT_DRIVER_NAME,						\
+	detect: adpt_detect,						\
+	release: adpt_release,						\
+	info: adpt_info,						\
+	queuecommand: adpt_queue,					\
+	eh_abort_handler: adpt_abort,					\
+	eh_device_reset_handler: adpt_device_reset,			\
+	eh_bus_reset_handler: adpt_bus_reset,				\
+	eh_host_reset_handler: adpt_reset,				\
+	bios_param: adpt_bios_param,					\
+	can_queue: MAX_TO_IOP_MESSAGES,	/* max simultaneous cmds      */\
+	this_id: 7,			/* scsi id of host adapter    */\
+	sg_tablesize: 0,		/* max scatter-gather cmds    */\
+	cmd_per_lun: 1,		/* cmds per lun (linked cmds) */\
+	use_clustering: ENABLE_CLUSTERING,				\
+	use_new_eh_code: 1,						\
+	proc_name: "dpt_i2o"						\
+}
+#endif
+
+#ifndef HOSTS_C
+
+#include <linux/wait.h>
+#include "dpti_i2o.h"
+#include "dpti_ioctl.h"
+
+#define DPT_I2O_VERSION "2.4 Build 2"
+#define DPT_VERSION     2
+#define DPT_REVISION    '4'
+#define DPT_SUBREVISION '2'
+#define DPT_BETA	""
+#define DPT_MONTH      7 
+#define DPT_DAY        15
+#define DPT_YEAR        (2001-1980)
+
+#define DPT_DRIVER	"dpt_i2o"
+#define DPTI_I2O_MAJOR	(151)
+#define DPT_ORGANIZATION_ID (0x1B)        /* For Private Messages */
+#define DPTI_MAX_HBA	(16)
+#define MAX_CHANNEL     (5)	// Maximum Channel # Supported
+#define MAX_ID        	(128)	// Maximum Target ID Supported
+
+#define REPLY_FRAME_SIZE  (17)
+#define SG_LIST_ELEMENTS  (56)
+#define MAX_MESSAGE_SIZE  (512)
+
+#define EMPTY_QUEUE           0xffffffff
+#define I2O_INTERRUPT_PENDING_B   (0x08)
+
+#define PCI_DPT_VENDOR_ID         (0x1044)	// DPT PCI Vendor ID
+#define PCI_DPT_DEVICE_ID         (0xA501)	// DPT PCI I2O Device ID
+#define PCI_DPT_RAPTOR_DEVICE_ID  (0xA511)	
+
+//#define REBOOT_NOTIFIER 1
+/* Debugging macro from Linux Device Drivers - Rubini */
+#undef PDEBUG
+#ifdef DEBUG
+//TODO add debug level switch
+#  define PDEBUG(fmt, args...)  printk(KERN_DEBUG "dpti: " fmt, ##args)
+#  define PDEBUGV(fmt, args...) printk(KERN_DEBUG "dpti: " fmt, ##args)
+#else
+# define PDEBUG(fmt, args...) /* not debugging: nothing */
+# define PDEBUGV(fmt, args...) /* not debugging: nothing */
+#endif
+
+#define PERROR(fmt, args...) printk(KERN_ERR fmt, ##args)
+#define PWARN(fmt, args...) printk(KERN_WARNING fmt, ##args)
+#define PINFO(fmt, args...) printk(KERN_INFO fmt, ##args)
+#define PCRIT(fmt, args...) printk(KERN_CRIT fmt, ##args)
+
+#define SHUTDOWN_SIGS	(sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM))
+
+// Command timeouts
+#define FOREVER			(0)
+#define TMOUT_INQUIRY 		(20)
+#define TMOUT_FLUSH		(360/45)
+#define TMOUT_ABORT		(30)
+#define TMOUT_SCSI		(300)
+#define TMOUT_IOPRESET		(360)
+#define TMOUT_GETSTATUS		(15)
+#define TMOUT_INITOUTBOUND	(15)
+#define TMOUT_LCT		(360)
+
+#define I2O_SCSI_DSC_MASK                   0xFF00
+#define I2O_SCSI_DSC_SUCCESS                0x0000
+#define I2O_SCSI_DSC_REQUEST_ABORTED        0x0200
+#define I2O_SCSI_DSC_UNABLE_TO_ABORT        0x0300
+#define I2O_SCSI_DSC_COMPLETE_WITH_ERROR    0x0400
+#define I2O_SCSI_DSC_ADAPTER_BUSY           0x0500
+#define I2O_SCSI_DSC_REQUEST_INVALID        0x0600
+#define I2O_SCSI_DSC_PATH_INVALID           0x0700
+#define I2O_SCSI_DSC_DEVICE_NOT_PRESENT     0x0800
+#define I2O_SCSI_DSC_UNABLE_TO_TERMINATE    0x0900
+#define I2O_SCSI_DSC_SELECTION_TIMEOUT      0x0A00
+#define I2O_SCSI_DSC_COMMAND_TIMEOUT        0x0B00
+#define I2O_SCSI_DSC_MR_MESSAGE_RECEIVED    0x0D00
+#define I2O_SCSI_DSC_SCSI_BUS_RESET         0x0E00
+#define I2O_SCSI_DSC_PARITY_ERROR_FAILURE   0x0F00
+#define I2O_SCSI_DSC_AUTOSENSE_FAILED       0x1000
+#define I2O_SCSI_DSC_NO_ADAPTER             0x1100
+#define I2O_SCSI_DSC_DATA_OVERRUN           0x1200
+#define I2O_SCSI_DSC_UNEXPECTED_BUS_FREE    0x1300
+#define I2O_SCSI_DSC_SEQUENCE_FAILURE       0x1400
+#define I2O_SCSI_DSC_REQUEST_LENGTH_ERROR   0x1500
+#define I2O_SCSI_DSC_PROVIDE_FAILURE        0x1600
+#define I2O_SCSI_DSC_BDR_MESSAGE_SENT       0x1700
+#define I2O_SCSI_DSC_REQUEST_TERMINATED     0x1800
+#define I2O_SCSI_DSC_IDE_MESSAGE_SENT       0x3300
+#define I2O_SCSI_DSC_RESOURCE_UNAVAILABLE   0x3400
+#define I2O_SCSI_DSC_UNACKNOWLEDGED_EVENT   0x3500
+#define I2O_SCSI_DSC_MESSAGE_RECEIVED       0x3600
+#define I2O_SCSI_DSC_INVALID_CDB            0x3700
+#define I2O_SCSI_DSC_LUN_INVALID            0x3800
+#define I2O_SCSI_DSC_SCSI_TID_INVALID       0x3900
+#define I2O_SCSI_DSC_FUNCTION_UNAVAILABLE   0x3A00
+#define I2O_SCSI_DSC_NO_NEXUS               0x3B00
+#define I2O_SCSI_DSC_SCSI_IID_INVALID       0x3C00
+#define I2O_SCSI_DSC_CDB_RECEIVED           0x3D00
+#define I2O_SCSI_DSC_LUN_ALREADY_ENABLED    0x3E00
+#define I2O_SCSI_DSC_BUS_BUSY               0x3F00
+#define I2O_SCSI_DSC_QUEUE_FROZEN           0x4000
+
+#ifndef TRUE
+#define TRUE                  1
+#define FALSE                 0
+#endif
+
+#define HBA_FLAGS_INSTALLED_B       0x00000001	// Adapter Was Installed
+#define HBA_FLAGS_BLINKLED_B        0x00000002	// Adapter In Blink LED State
+#define HBA_FLAGS_IN_RESET	0x00000040	/* in reset */
+#define HBA_HOSTRESET_FAILED	0x00000080	/* adpt_resethost failed */
+
+
+// Device state flags
+#define DPTI_DEV_UNSCANNED 0x01
+#define DPTI_DEV_RESET	   0x02
+#define DPTI_DEV_OFFLINE   0x04
+
+
+struct adpt_device {
+	struct adpt_device* next_lun;
+	u32	flags;
+	u32	type;
+	u32	capacity;
+	u32	block_size;
+	u8	scsi_channel;
+	u8	scsi_id;
+	u8 	scsi_lun;
+	u8	state;
+	u16	tid;
+	struct i2o_device* pI2o_dev;
+	Scsi_Device *pScsi_dev;
+};
+
+struct adpt_channel {
+	struct adpt_device* device[MAX_ID];	/* used as an array of 128 scsi ids */
+	u8	scsi_id;
+	u8	type;
+	u16	tid;
+	u32	state;
+	struct i2o_device* pI2o_dev;
+};
+
+// HBA state flags
+#define DPTI_STATE_RESET	(0x01)
+#define DPTI_STATE_IOCTL	(0x02)
+
+typedef struct _adpt_hba {
+	struct _adpt_hba *next;
+	struct pci_dev *pDev;
+	struct Scsi_Host *host;
+	u32 state;
+	spinlock_t state_lock;
+	int unit;
+	int host_no;		/* SCSI host number */
+	u8 initialized;
+	u8 in_use;		/* is the management node open*/
+
+	char name[32];
+	char detail[55];
+
+	caddr_t base_addr_virt;
+	caddr_t msg_addr_virt;
+	caddr_t base_addr_phys;
+	ulong  post_port;
+	ulong  reply_port;
+	ulong  irq_mask;
+	u16  post_count;
+	u32  post_fifo_size;
+	u32  reply_fifo_size;
+	u32* reply_pool;
+	u32  sg_tablesize;	// Scatter/Gather List Size.       
+	u8  top_scsi_channel;
+	u8  top_scsi_id;
+	u8  top_scsi_lun;
+
+	i2o_status_block* status_block;
+	i2o_hrt* hrt;
+	i2o_lct* lct;
+	unsigned lct_size;
+	struct i2o_device* devices;
+	struct adpt_channel channel[MAX_CHANNEL];
+
+	caddr_t FwDebugBuffer_P;	// Virtual Address Of FW Debug Buffer
+	u32 FwDebugBufferSize;	// FW Debug Buffer Size In Bytes
+	u32* FwDebugStrLength_P;	// Virtual Addr Of FW Debug String Len
+	volatile u32* FwDebugFlags_P;	// Virtual Address Of FW Debug Flags 
+	volatile u8* FwDebugBLEDflag_P;	// Virtual Addr Of FW Debug BLED
+	volatile u8* FwDebugBLEDvalue_P;	// Virtual Addr Of FW Debug BLED
+	u32 FwDebugFlags;
+} adpt_hba;
+
+struct sg_simple_element {
+   u32  flag_count;
+   u32 addr_bus;
+}; 
+
+/*
+ * Function Prototypes
+ */
+
+void adpt_i2o_sys_shutdown(void);
+int adpt_init(void);
+int adpt_i2o_build_sys_table(void);
+void adpt_isr(int irq, void *dev_id, struct pt_regs *regs);
+#ifdef REBOOT_NOTIFIER
+int adpt_reboot_event(struct notifier_block *n, unsigned long code, void *p);
+#endif
+
+void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d);
+int adpt_i2o_query_scalar(adpt_hba* pHba, int tid, 
+			int group, int field, void *buf, int buflen);
+const char *adpt_i2o_get_class_name(int class);
+int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, 
+		  void *opblk, int oplen, void *resblk, int reslen);
+int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout);
+int adpt_i2o_lct_get(adpt_hba* pHba);
+int adpt_i2o_parse_lct(adpt_hba* pHba);
+int adpt_i2o_activate_hba(adpt_hba* pHba);
+int adpt_i2o_online_controller(adpt_hba* pHba);
+int adpt_i2o_enable_hba(adpt_hba* pHba);
+int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d);
+s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len);
+s32 adpt_i2o_quiesce_hba(adpt_hba* pHba);
+s32 adpt_i2o_status_get(adpt_hba* pHba);
+s32 adpt_i2o_init_outbound_q(adpt_hba* pHba);
+s32 adpt_i2o_hrt_get(adpt_hba* pHba);
+s32 adpt_i2o_parse_hrt(adpt_hba* pHba);
+s32 adpt_scsi_to_i2o(adpt_hba* pHba, Scsi_Cmnd* cmd, struct adpt_device* dptdevice);
+s32 adpt_i2o_to_scsi(ulong reply, Scsi_Cmnd* cmd);
+s32 adpt_scsi_register(adpt_hba* pHba,Scsi_Host_Template * sht);
+s32 adpt_hba_reset(adpt_hba* pHba);
+s32 adpt_scsi_bus_reset(adpt_hba* pHba, u32 chan);
+s32 adpt_i2o_reset_hba(adpt_hba* pHba);
+s32 adpt_scsi_device_reset(adpt_hba* pHba, u8 chan, u8 id, u8 lun);
+s32 adpt_reinit(adpt_hba* pHba);
+s32 adpt_rescan(adpt_hba* pHba);
+s32 adpt_i2o_reparse_lct(adpt_hba* pHba);
+s32 adpt_send_nop(adpt_hba*pHba,u32 m);
+void adpt_i2o_delete_hba(adpt_hba* pHba);
+void adpt_select_queue_depths(struct Scsi_Host *host, Scsi_Device * devicelist);
+int adpt_read_capacity(adpt_hba* pHba, struct adpt_device* d);
+void adpt_inquiry(adpt_hba* pHba);
+void adpt_fail_posted_scbs(adpt_hba* pHba);
+
+int adpt_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+int adpt_open(struct inode *inode, struct file *file);
+int adpt_close(struct inode *inode, struct file *file);
+
+void adpt_start_complete_queue(void);
+void adpt_done_cmds_complete(void * data);
+void adpt_queue_cmd_complete(Scsi_Cmnd *cmd);
+
+#ifdef DEBUG
+static void adpt_delay(int millisec);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+struct pci_dev* adpt_pci_find_device(unsigned int vendor, struct pci_dev* from);
+#endif
+
+#if defined __ia64__ 
+void adpt_ia64_info(sysInfo_S* si);
+#endif
+#if defined __sparc__ 
+void adpt_sparc_info(sysInfo_S* si);
+#endif
+#if defined __alpha__ 
+void adpt_sparc_info(sysInfo_S* si);
+#endif
+#if defined __i386__
+void adpt_i386_info(sysInfo_S* si);
+#endif
+
+#define PRINT_BUFFER_SIZE     512
+
+#define HBA_FLAGS_DBG_FLAGS_MASK         0xffff0000	// Mask for debug flags
+#define HBA_FLAGS_DBG_KERNEL_PRINT_B     0x00010000	// Kernel Debugger Print
+#define HBA_FLAGS_DBG_FW_PRINT_B         0x00020000	// Firmware Debugger Print
+#define HBA_FLAGS_DBG_FUNCTION_ENTRY_B   0x00040000	// Function Entry Point
+#define HBA_FLAGS_DBG_FUNCTION_EXIT_B    0x00080000	// Function Exit
+#define HBA_FLAGS_DBG_ERROR_B            0x00100000	// Error Conditions
+#define HBA_FLAGS_DBG_INIT_B             0x00200000	// Init Prints
+#define HBA_FLAGS_DBG_OS_COMMANDS_B      0x00400000	// OS Command Info
+#define HBA_FLAGS_DBG_SCAN_B             0x00800000	// Device Scan
+
+#define FW_DEBUG_STR_LENGTH_OFFSET 0
+#define FW_DEBUG_FLAGS_OFFSET      4
+#define FW_DEBUG_BLED_OFFSET       8
+
+#define FW_DEBUG_FLAGS_NO_HEADERS_B    0x01
+#endif				/* !HOSTS_C */
+#endif				/* _DPT_H */
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/dpti2oscsi2.c	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,239 @@
+
+/*
+ * NOTE:  You must include i2obscsi.h before including this file
+ */
+
+/*
+ *      SCSI opcodes
+ */
+/*
+ * i2oscsi2dixkxfer is a table of data transfer direction for SCSI Disk 
+ * device commands.  The table indicates if the command will transfer 
+ * data in (from device to system) or data out (from system to device)
+ * NOSUPPORT indicates the command is not used for a disk device
+ */
+
+/* #define	DATAIN	I2O_SCB_FLAG_XFER_FROM_DEVICE */
+#define	DATAIN	0x01
+/* #define	DATAOUT	I2O_SCB_FLAG_XFER_TO_DEVICE */
+#define	DATAOUT	0x02
+/* #define	NODATA	I2O_SCB_FLAG_NO_DATA_XFER */
+#define	NODATA	0x00
+#define	NOSUPPORT	0xFF
+
+unsigned char i2oscsi2diskxfer[] = {
+
+
+/* TEST_UNIT_READY       0x00 */ NODATA,
+/* REZERO_UNIT           0x01 */ NODATA,
+/*			 0x02 */ NOSUPPORT,
+/* REQUEST_SENSE         0x03 */ DATAIN,
+/* FORMAT_UNIT           0x04 */ DATAOUT,
+/* READ_BLOCK_LIMITS     0x05 */ DATAIN,
+/*			 0x06 */ NOSUPPORT,
+/* REASSIGN_BLOCKS       0x07 */ DATAOUT,
+/* READ_6                0x08 */ DATAIN,
+
+/*			 0x09 */ NOSUPPORT,
+
+/* WRITE_6               0x0a */ DATAOUT,
+/* SEEK_6                0x0b */ NODATA,
+/*			 0x0c */ NOSUPPORT,
+/*			 0x0d */ NOSUPPORT,
+/*			 0x0e */ NOSUPPORT,
+/* READ_REVERSE          0x0f */ NOSUPPORT,
+/* WRITE_FILEMARKS       0x10 */ NODATA,
+/* SPACE                 0x11 */ NOSUPPORT,
+/* INQUIRY               0x12 */ DATAIN,
+/*			 0x13 */ NOSUPPORT,
+/* RECOVER_BUFFERED_DATA 0x14 */ NOSUPPORT,
+/* MODE_SELECT           0x15 */ DATAOUT,
+/* RESERVE               0x16 */ DATAOUT,
+/* RELEASE               0x17 */ NODATA,
+/* COPY                  0x18 */ DATAOUT,
+	/* ERASE                 0x19 */ NOSUPPORT,
+	/* NODATA if supported */
+/* MODE_SENSE            0x1a */ DATAIN,
+/* START_STOP            0x1b */ NODATA,
+/* RECEIVE_DIAGNOSTIC    0x1c */ DATAIN,
+/* SEND_DIAGNOSTIC       0x1d */ DATAOUT,
+/* ALLOW_MEDIUM_REMOVAL  0x1e */ NODATA,
+
+/*			 0x1f */ NOSUPPORT,
+/*			 0x20 */ NOSUPPORT,
+/*			 0x21 */ NOSUPPORT,
+/*			 0x22 */ NOSUPPORT,
+/*			 0x23 */ NOSUPPORT,
+
+/* SET_WINDOW            0x24 */ DATAOUT,
+/* READ_CAPACITY         0x25 */ DATAIN,
+
+/*			 0x26 */ NOSUPPORT,
+/*			 0x27 */ NOSUPPORT,
+
+/* READ_10               0x28 */ DATAIN,
+
+/*			 0x29 */ NOSUPPORT,
+
+/* WRITE_10              0x2a */ DATAOUT,
+/* SEEK_10               0x2b */ NODATA,
+
+/*			 0x2c */ NOSUPPORT,
+/*			 0x2d */ NOSUPPORT,
+
+/* WRITE_VERIFY          0x2e */ DATAOUT,
+/* VERIFY                0x2f */ NODATA,
+/* SEARCH_HIGH           0x30 */ DATAOUT,
+/* SEARCH_EQUAL          0x31 */ DATAOUT,
+/* SEARCH_LOW            0x32 */ DATAOUT,
+/* SET_LIMITS            0x33 */ NODATA,
+/* PRE_FETCH             0x34 */ DATAIN,
+/* SYNCHRONIZE_CACHE     0x35 */ NODATA,
+/* LOCK_UNLOCK_CACHE     0x36 */ NODATA,
+/* READ_DEFECT_DATA      0x37 */ DATAIN,
+/* MEDIUM_SCAN           0x38 */ DATAOUT,
+/* COMPARE               0x39 */ DATAOUT,
+/* COPY_VERIFY           0x3a */ DATAOUT,
+/* WRITE_BUFFER          0x3b */ DATAOUT,
+/* READ_BUFFER           0x3c */ DATAIN,
+/* UPDATE_BLOCK          0x3d */ DATAOUT,
+/* READ_LONG             0x3e */ DATAIN,
+/* WRITE_LONG            0x3f */ DATAOUT,
+/* CHANGE_DEFINITION     0x40 */ DATAOUT,
+/* WRITE_SAME            0x41 */ DATAOUT,
+
+/*			 0x42 */ DATAIN,
+
+/* READ_TOC              0x43 */ DATAIN,
+
+/*			 0x44 */ DATAIN,
+/*			 0x45 */ NOSUPPORT,
+/*			 0x46 */ NOSUPPORT,
+/*			 0x47 */ NOSUPPORT,
+/*			 0x48 */ NOSUPPORT,
+/*			 0x49 */ NOSUPPORT,
+/*			 0x4a */ NOSUPPORT,
+/*			 0x4b */ NOSUPPORT,
+
+/* LOG_SELECT            0x4c */ DATAOUT,
+/* LOG_SENSE             0x4d */ DATAIN,
+
+/*			 0x4e */ NOSUPPORT,
+/*			 0x4f */ NOSUPPORT,
+/*			 0x50 */ NOSUPPORT,
+/*			 0x51 */ DATAIN,
+/*			 0x52 */ DATAIN,
+/*			 0x53 */ DATAOUT,
+/*			 0x54 */ NOSUPPORT,
+
+/* MODE_SELECT_10        0x55 */ DATAOUT,
+
+/*			 0x56 */ NODATA,
+/*			 0x57 */ NODATA,
+/*			 0x58 */ NOSUPPORT,
+/*			 0x59 */ NOSUPPORT,
+
+/* MODE_SENSE_10         0x5a */ DATAIN,
+
+/*			 0x5b */ DATAIN,
+/*			 0x5c */ DATAIN,
+/*			 0x5d */ NOSUPPORT,
+/*			 0x5e */ NOSUPPORT,
+/*			 0x5f */ NOSUPPORT,
+
+/* assign NOSUPPORT for 0x60 - 0x9f */
+	/* 0x60 - 0x6f */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	/* 0x70 - 0x7f */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	/* 0x80 - 0x8f */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	/* 0x90 - 0x9f */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+
+/*			 0xa0 */ NOSUPPORT,
+/*			 0xa1 */ NOSUPPORT,
+/*			 0xa2 */ NOSUPPORT,
+/*			 0xa3 */ NOSUPPORT,
+/*			 0xa4 */ NOSUPPORT,
+
+/* MOVE_MEDIUM           0xa5 */ NODATA,
+
+/*			 0xa6 */ NOSUPPORT,
+/*			 0xa7 */ NOSUPPORT,
+
+/* READ_12               0xa8 */ DATAIN,
+
+/*			 0xa9 */ NOSUPPORT,
+
+/* WRITE_12              0xaa */ DATAOUT,
+
+/*			 0xab */ NOSUPPORT,
+/*			 0xac */ NOSUPPORT,
+/*			 0xad */ NOSUPPORT,
+
+/* WRITE_VERIFY_12       0xae */ DATAOUT,
+
+/*			 0xaf */ NOSUPPORT,
+
+/* SEARCH_HIGH_12        0xb0 */ DATAOUT,
+/* SEARCH_EQUAL_12       0xb1 */ DATAOUT,
+/* SEARCH_LOW_12         0xb2 */ DATAOUT,
+
+/*			 0xb3 */ NOSUPPORT,
+/*			 0xb4 */ NOSUPPORT,
+/*			 0xb5 */ NOSUPPORT,
+
+/* SEND_VOLUME_TAG       0xb6 */ DATAOUT,
+
+/*			 0xb7 */ NOSUPPORT,
+
+/* READ_ELEMENT_STATUS   0xb8 */ DATAIN,
+
+/*			 0xb9 */ NOSUPPORT,
+/*			 0xba */ NOSUPPORT,
+/*			 0xbb */ DATAOUT,
+/*			 0xbc */ NOSUPPORT,
+/*			 0xbd */ DATAIN,
+/*			 0xbe */ NOSUPPORT,
+/*			 0xbf */ NOSUPPORT,
+
+/* assign NOSUPPORT for 0xc0 - 0xdf */
+	/* 0xc0 - 0xcf */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	/* 0xd0 - 0xdf */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+
+/*			 0xe0 */ NOSUPPORT,
+/*			 0xe1 */ NOSUPPORT,
+/*			 0xe2 */ NOSUPPORT,
+/*			 0xe3 */ NOSUPPORT,
+/*			 0xe4 */ NOSUPPORT,
+/*			 0xe5 */ NOSUPPORT,
+/*			 0xe6 */ NOSUPPORT,
+/*			 0xe7 */ NOSUPPORT,
+/*			 0xe8 */ NOSUPPORT,
+/*			 0xe9 */ NOSUPPORT,
+
+/* WRITE_LONG_2          0xea */ DATAOUT
+};
+
+#define	DISKXFERTBLSIZE sizeof(i2oscsi2diskxfer)
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/dpti_ioctl.h	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,139 @@
+/***************************************************************************
+                          dpti_ioctl.h  -  description
+                             -------------------
+    begin                : Thu Sep 7 2000
+    copyright            : (C) 2001 by Adaptec
+    email                : deanna_bonds@adaptec.com
+
+    See README.dpti for history, notes, license info, and credits
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+/***************************************************************************
+ * This file is generated from  osd_unix.h                                 *
+ * *************************************************************************/
+
+#ifndef _dpti_ioctl_h
+#define _dpti_ioctl_h
+
+// IOCTL interface commands
+
+#ifndef _IOWR
+# define _IOWR(x,y,z)	(((x)<<8)|y)
+#endif
+#ifndef _IOW
+# define _IOW(x,y,z)	(((x)<<8)|y)
+#endif
+#ifndef _IOR
+# define _IOR(x,y,z)	(((x)<<8)|y)
+#endif
+#ifndef _IO
+# define _IO(x,y)	(((x)<<8)|y)
+#endif
+/* EATA PassThrough Command	*/
+#define EATAUSRCMD      _IOWR('D',65,EATA_CP)
+/* Set Debug Level If Enabled	*/
+#define DPT_DEBUG       _IOW('D',66,int)
+/* Get Signature Structure	*/
+#define DPT_SIGNATURE   _IOR('D',67,dpt_sig_S)
+#if defined __bsdi__
+#define DPT_SIGNATURE_PACKED   _IOR('D',67,dpt_sig_S_Packed)
+#endif
+/* Get Number Of DPT Adapters	*/
+#define DPT_NUMCTRLS    _IOR('D',68,int)
+/* Get Adapter Info Structure	*/
+#define DPT_CTRLINFO    _IOR('D',69,CtrlInfo)
+/* Get Statistics If Enabled	*/
+#define DPT_STATINFO    _IO('D',70)
+/* Clear Stats If Enabled	*/
+#define DPT_CLRSTAT     _IO('D',71)
+/* Get System Info Structure	*/
+#define DPT_SYSINFO     _IOR('D',72,sysInfo_S)
+/* Set Timeout Value		*/
+#define DPT_TIMEOUT     _IO('D',73)
+/* Get config Data  		*/
+#define DPT_CONFIG      _IO('D',74)
+/* Get Blink LED Code	        */
+#define DPT_BLINKLED    _IOR('D',75,int)
+/* Get Statistical information (if available) */
+#define DPT_STATS_INFO        _IOR('D',80,STATS_DATA)
+/* Clear the statistical information          */
+#define DPT_STATS_CLEAR       _IO('D',81)
+/* Get Performance metrics */
+#define DPT_PERF_INFO        _IOR('D',82,dpt_perf_t)
+/* Send an I2O command */
+#define I2OUSRCMD	_IO('D',76)
+/* Inform driver to re-acquire LCT information */
+#define I2ORESCANCMD	_IO('D',77)
+/* Inform driver to reset adapter */
+#define I2ORESETCMD	_IO('D',78)
+/* See if the target is mounted */
+#define DPT_TARGET_BUSY	_IOR('D',79, TARGET_BUSY_T)
+
+
+  /* Structure Returned From Get Controller Info                             */
+
+typedef struct {
+	uCHAR    state;            /* Operational state               */
+	uCHAR    id;               /* Host adapter SCSI id            */
+	int      vect;             /* Interrupt vector number         */
+	int      base;             /* Base I/O address                */
+	int      njobs;            /* # of jobs sent to HA            */
+	int      qdepth;           /* Controller queue depth.         */
+	int      wakebase;         /* mpx wakeup base index.          */
+	uLONG    SGsize;           /* Scatter/Gather list size.       */
+	unsigned heads;            /* heads for drives on cntlr.      */
+	unsigned sectors;          /* sectors for drives on cntlr.    */
+	uCHAR    do_drive32;       /* Flag for Above 16 MB Ability    */
+	uCHAR    BusQuiet;         /* SCSI Bus Quiet Flag             */
+	char     idPAL[4];         /* 4 Bytes Of The ID Pal           */
+	uCHAR    primary;          /* 1 For Primary, 0 For Secondary  */
+	uCHAR    eataVersion;      /* EATA Version                    */
+	uLONG    cpLength;         /* EATA Command Packet Length      */
+	uLONG    spLength;         /* EATA Status Packet Length       */
+	uCHAR    drqNum;           /* DRQ Index (0,5,6,7)             */ 
+	uCHAR    flag1;            /* EATA Flags 1 (Byte 9)           */
+	uCHAR    flag2;            /* EATA Flags 2 (Byte 30)          */
+} CtrlInfo;
+
+typedef struct {
+	uSHORT length;		// Remaining length of this
+	uSHORT drvrHBAnum;	// Relative HBA # used by the driver
+	uLONG baseAddr;		// Base I/O address
+	uSHORT blinkState;	// Blink LED state (0=Not in blink LED)
+	uCHAR pciBusNum;	// PCI Bus # (Optional)
+	uCHAR pciDeviceNum;	// PCI Device # (Optional)
+	uSHORT hbaFlags;	// Miscellaneous HBA flags
+	uSHORT Interrupt;	// Interrupt set for this device.
+#   if (defined(_DPT_ARC))
+	uLONG baseLength;
+	ADAPTER_OBJECT *AdapterObject;
+	LARGE_INTEGER DmaLogicalAddress;
+	PVOID DmaVirtualAddress;
+	LARGE_INTEGER ReplyLogicalAddress;
+	PVOID ReplyVirtualAddress;
+#   else
+	uLONG reserved1;	// Reserved for future expansion
+	uLONG reserved2;	// Reserved for future expansion
+	uLONG reserved3;	// Reserved for future expansion
+#   endif
+} drvrHBAinfo_S;
+
+typedef struct TARGET_BUSY
+{
+  uLONG channel;
+  uLONG id;
+  uLONG lun;
+  uLONG isBusy;
+} TARGET_BUSY_T;
+
+#endif
+
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/dptsig.h	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,339 @@
+/*	BSDI dptsig.h,v 1.7 1998/06/03 19:15:00 karels Exp	*/
+
+/*
+ * Copyright (c) 1996-1999 Distributed Processing Technology Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source form, with or without modification, are
+ * permitted provided that redistributions of source code must retain the
+ * above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * This software is provided `as is' by Distributed Processing Technology and
+ * any express or implied warranties, including, but not limited to, the
+ * implied warranties of merchantability and fitness for a particular purpose,
+ * are disclaimed. In no event shall Distributed Processing Technology be
+ * liable for any direct, indirect, incidental, special, exemplary or
+ * consequential damages (including, but not limited to, procurement of
+ * substitute goods or services; loss of use, data, or profits; or business
+ * interruptions) however caused and on any theory of liability, whether in
+ * contract, strict liability, or tort (including negligence or otherwise)
+ * arising in any way out of the use of this driver software, even if advised
+ * of the possibility of such damage.
+ *
+ */
+
+#ifndef __DPTSIG_H_
+#define __DPTSIG_H_
+#ifdef _SINIX_ADDON
+#include "dpt.h"
+#endif
+/* DPT SIGNATURE SPEC AND HEADER FILE                           */
+/* Signature Version 1 (sorry no 'A')                           */
+
+/* to make sure we are talking the same size under all OS's     */
+typedef unsigned char sigBYTE;
+typedef unsigned short sigWORD;
+#if (defined(_MULTI_DATAMODEL) && defined(sun) && !defined(_ILP32))
+typedef uint32_t sigLONG;
+#else
+typedef unsigned long sigLONG;
+#endif
+
+/*
+ * use sigWORDLittleEndian for:
+ *  dsCapabilities
+ *  dsDeviceSupp
+ *  dsAdapterSupp
+ *  dsApplication
+ * use sigLONGLittleEndian for:
+ *      dsOS
+ * so that the sig can be standardised to Little Endian
+ */
+#if (defined(_DPT_BIG_ENDIAN))
+# define sigWORDLittleEndian(x) ((((x)&0xFF)<<8)|(((x)>>8)&0xFF))
+# define sigLONGLittleEndian(x) \
+        ((((x)&0xFF)<<24) |             \
+         (((x)&0xFF00)<<8) |    \
+         (((x)&0xFF0000L)>>8) | \
+         (((x)&0xFF000000L)>>24))
+#else
+# define sigWORDLittleEndian(x) (x)
+# define sigLONGLittleEndian(x) (x)
+#endif
+
+/* must make sure the structure is not word or double-word aligned      */
+/* ---------------------------------------------------------------      */
+/* Borland will ignore the following pragma:                            */
+/* Word alignment is OFF by default.  If in the, IDE make               */
+/* sure that Options | Compiler | Code Generation | Word Alignment      */
+/* is not checked.  If using BCC, do not use the -a option.             */
+
+#ifndef NO_PACK
+#if defined (_DPT_AIX)
+#pragma options align=packed
+#else
+#pragma pack(1)
+#endif  /* aix */
+#endif
+/* For the Macintosh */
+#if STRUCTALIGNMENTSUPPORTED
+#pragma options align=mac68k
+#endif
+
+
+/* Current Signature Version - sigBYTE dsSigVersion; */
+/* ------------------------------------------------------------------ */
+#define SIG_VERSION 1
+
+/* Processor Family - sigBYTE dsProcessorFamily;  DISTINCT VALUES */
+/* ------------------------------------------------------------------ */
+/* What type of processor the file is meant to run on. */
+/* This will let us know whether to read sigWORDs as high/low or low/high. */
+#define PROC_INTEL      0x00    /* Intel 80x86 */
+#define PROC_MOTOROLA   0x01    /* Motorola 68K */
+#define PROC_MIPS4000   0x02    /* MIPS RISC 4000 */
+#define PROC_ALPHA      0x03    /* DEC Alpha */
+#define PROC_POWERPC    0x04    /* IBM Power PC */
+#define PROC_i960       0x05    /* Intel i960 */
+#define PROC_ULTRASPARC 0x06    /* SPARC processor */
+
+/* Specific Minimim Processor - sigBYTE dsProcessor;    FLAG BITS */
+/* ------------------------------------------------------------------ */
+/* Different bit definitions dependent on processor_family */
+
+/* PROC_INTEL: */
+#define PROC_8086       0x01    /* Intel 8086 */
+#define PROC_286        0x02    /* Intel 80286 */
+#define PROC_386        0x04    /* Intel 80386 */
+#define PROC_486        0x08    /* Intel 80486 */
+#define PROC_PENTIUM    0x10    /* Intel 586 aka P5 aka Pentium */
+#define PROC_SEXIUM	0x20	/* Intel 686 aka P6 aka Pentium Pro or MMX */
+
+/* PROC_i960: */
+#define PROC_960RX      0x01    /* Intel 80960RC/RD */
+#define PROC_960HX      0x02    /* Intel 80960HA/HD/HT */
+
+/* PROC_MOTOROLA: */
+#define PROC_68000      0x01    /* Motorola 68000 */
+#define PROC_68010	0x02	/* Motorola 68010 */
+#define PROC_68020      0x04    /* Motorola 68020 */
+#define PROC_68030      0x08    /* Motorola 68030 */
+#define PROC_68040      0x10    /* Motorola 68040 */
+
+/* PROC_POWERPC */
+#define PROC_PPC601		0x01	/* PowerPC 601 */
+#define PROC_PPC603		0x02	/* PowerPC 603 */
+#define PROC_PPC604		0x04	/* PowerPC 604 */
+
+/* PROC_MIPS4000: */
+#define PROC_R4000      0x01    /* MIPS R4000 */
+
+/* Filetype - sigBYTE dsFiletype;       DISTINCT VALUES */
+/* ------------------------------------------------------------------ */
+#define FT_EXECUTABLE   0       /* Executable Program */
+#define FT_SCRIPT       1       /* Script/Batch File??? */
+#define FT_HBADRVR      2       /* HBA Driver */
+#define FT_OTHERDRVR    3       /* Other Driver */
+#define FT_IFS          4       /* Installable Filesystem Driver */
+#define FT_ENGINE       5       /* DPT Engine */
+#define FT_COMPDRVR     6       /* Compressed Driver Disk */
+#define FT_LANGUAGE     7       /* Foreign Language file */
+#define FT_FIRMWARE     8       /* Downloadable or actual Firmware */
+#define FT_COMMMODL     9       /* Communications Module */
+#define FT_INT13        10      /* INT 13 style HBA Driver */
+#define FT_HELPFILE     11      /* Help file */
+#define FT_LOGGER       12      /* Event Logger */
+#define FT_INSTALL      13      /* An Install Program */
+#define FT_LIBRARY      14      /* Storage Manager Real-Mode Calls */
+#define FT_RESOURCE 	15 	/* Storage Manager Resource File */
+#define FT_MODEM_DB  	16  	/* Storage Manager Modem Database */
+
+/* Filetype flags - sigBYTE dsFiletypeFlags;    FLAG BITS */
+/* ------------------------------------------------------------------ */
+#define FTF_DLL         0x01    /* Dynamic Link Library */
+#define FTF_NLM         0x02    /* Netware Loadable Module */
+#define FTF_OVERLAYS    0x04    /* Uses overlays */
+#define FTF_DEBUG       0x08    /* Debug version */
+#define FTF_TSR         0x10    /* TSR */
+#define FTF_SYS         0x20    /* DOS Loadable driver */
+#define FTF_PROTECTED   0x40    /* Runs in protected mode */
+#define FTF_APP_SPEC    0x80    /* Application Specific */
+#define FTF_ROM		(FTF_SYS|FTF_TSR)	/* Special Case */
+
+/* OEM - sigBYTE dsOEM;         DISTINCT VALUES */
+/* ------------------------------------------------------------------ */
+#define OEM_DPT         0       /* DPT */
+#define OEM_ATT         1       /* ATT */
+#define OEM_NEC         2       /* NEC */
+#define OEM_ALPHA       3       /* Alphatronix */
+#define OEM_AST         4       /* AST */
+#define OEM_OLIVETTI    5       /* Olivetti */
+#define OEM_SNI         6       /* Siemens/Nixdorf */
+#define OEM_SUN         7       /* SUN Microsystems */
+
+/* Operating System  - sigLONG dsOS;    FLAG BITS */
+/* ------------------------------------------------------------------ */
+#define OS_DOS          0x00000001 /* PC/MS-DOS				*/
+#define OS_WINDOWS      0x00000002 /* Microsoft Windows 3.x		*/
+#define OS_WINDOWS_NT   0x00000004 /* Microsoft Windows NT		*/
+#define OS_OS2M         0x00000008 /* OS/2 1.2.x,MS 1.3.0,IBM 1.3.x - Monolithic */
+#define OS_OS2L         0x00000010 /* Microsoft OS/2 1.301 - LADDR	*/
+#define OS_OS22x        0x00000020 /* IBM OS/2 2.x			*/
+#define OS_NW286        0x00000040 /* Novell NetWare 286		*/
+#define OS_NW386        0x00000080 /* Novell NetWare 386		*/
+#define OS_GEN_UNIX     0x00000100 /* Generic Unix			*/
+#define OS_SCO_UNIX     0x00000200 /* SCO Unix				*/
+#define OS_ATT_UNIX     0x00000400 /* ATT Unix				*/
+#define OS_UNIXWARE     0x00000800 /* USL Unix				*/
+#define OS_INT_UNIX     0x00001000 /* Interactive Unix			*/
+#define OS_SOLARIS      0x00002000 /* SunSoft Solaris			*/
+#define OS_QNX          0x00004000 /* QNX for Tom Moch			*/
+#define OS_NEXTSTEP     0x00008000 /* NeXTSTEP/OPENSTEP/MACH		*/
+#define OS_BANYAN       0x00010000 /* Banyan Vines			*/
+#define OS_OLIVETTI_UNIX 0x00020000/* Olivetti Unix			*/
+#define OS_MAC_OS	0x00040000 /* Mac OS				*/
+#define OS_WINDOWS_95	0x00080000 /* Microsoft Windows '95		*/
+#define OS_NW4x		0x00100000 /* Novell Netware 4.x		*/
+#define OS_BSDI_UNIX	0x00200000 /* BSDi Unix BSD/OS 2.0 and up	*/
+#define OS_AIX_UNIX     0x00400000 /* AIX Unix				*/
+#define OS_FREE_BSD	0x00800000 /* FreeBSD Unix			*/
+#define OS_LINUX	0x01000000 /* Linux				*/
+#define OS_DGUX_UNIX	0x02000000 /* Data General Unix			*/
+#define OS_SINIX_N      0x04000000 /* SNI SINIX-N			*/
+#define OS_PLAN9	0x08000000 /* ATT Plan 9			*/
+#define OS_TSX		0x10000000 /* SNH TSX-32			*/
+
+#define OS_OTHER        0x80000000 /* Other				*/
+
+/* Capabilities - sigWORD dsCapabilities;        FLAG BITS */
+/* ------------------------------------------------------------------ */
+#define CAP_RAID0       0x0001  /* RAID-0 */
+#define CAP_RAID1       0x0002  /* RAID-1 */
+#define CAP_RAID3       0x0004  /* RAID-3 */
+#define CAP_RAID5       0x0008  /* RAID-5 */
+#define CAP_SPAN        0x0010  /* Spanning */
+#define CAP_PASS        0x0020  /* Provides passthrough */
+#define CAP_OVERLAP     0x0040  /* Passthrough supports overlapped commands */
+#define CAP_ASPI        0x0080  /* Supports ASPI Command Requests */
+#define CAP_ABOVE16MB   0x0100  /* ISA Driver supports greater than 16MB */
+#define CAP_EXTEND      0x8000  /* Extended info appears after description */
+#ifdef SNI_MIPS
+#define CAP_CACHEMODE   0x1000  /* dpt_force_cache is set in driver */
+#endif
+
+/* Devices Supported - sigWORD dsDeviceSupp;    FLAG BITS */
+/* ------------------------------------------------------------------ */
+#define DEV_DASD        0x0001  /* DASD (hard drives) */
+#define DEV_TAPE        0x0002  /* Tape drives */
+#define DEV_PRINTER     0x0004  /* Printers */
+#define DEV_PROC        0x0008  /* Processors */
+#define DEV_WORM        0x0010  /* WORM drives */
+#define DEV_CDROM       0x0020  /* CD-ROM drives */
+#define DEV_SCANNER     0x0040  /* Scanners */
+#define DEV_OPTICAL     0x0080  /* Optical Drives */
+#define DEV_JUKEBOX     0x0100  /* Jukebox */
+#define DEV_COMM        0x0200  /* Communications Devices */
+#define DEV_OTHER       0x0400  /* Other Devices */
+#define DEV_ALL         0xFFFF  /* All SCSI Devices */
+
+/* Adapters Families Supported - sigWORD dsAdapterSupp; FLAG BITS */
+/* ------------------------------------------------------------------ */
+#define ADF_2001        0x0001  /* PM2001           */
+#define ADF_2012A       0x0002  /* PM2012A          */
+#define ADF_PLUS_ISA    0x0004  /* PM2011,PM2021    */
+#define ADF_PLUS_EISA   0x0008  /* PM2012B,PM2022   */
+#define ADF_SC3_ISA	0x0010  /* PM2021           */
+#define ADF_SC3_EISA	0x0020  /* PM2022,PM2122, etc */
+#define ADF_SC3_PCI	0x0040  /* SmartCache III PCI */
+#define ADF_SC4_ISA	0x0080  /* SmartCache IV ISA */
+#define ADF_SC4_EISA	0x0100  /* SmartCache IV EISA */
+#define ADF_SC4_PCI	0x0200	/* SmartCache IV PCI */
+#define ADF_SC5_PCI	0x0400	/* Fifth Generation I2O products */
+/*
+ *	Combinations of products
+ */
+#define ADF_ALL_2000	(ADF_2001|ADF_2012A)
+#define ADF_ALL_PLUS	(ADF_PLUS_ISA|ADF_PLUS_EISA)
+#define ADF_ALL_SC3	(ADF_SC3_ISA|ADF_SC3_EISA|ADF_SC3_PCI)
+#define ADF_ALL_SC4	(ADF_SC4_ISA|ADF_SC4_EISA|ADF_SC4_PCI)
+#define ADF_ALL_SC5	(ADF_SC5_PCI)
+/* All EATA Cacheing Products */
+#define ADF_ALL_CACHE	(ADF_ALL_PLUS|ADF_ALL_SC3|ADF_ALL_SC4)
+/* All EATA Bus Mastering Products */
+#define ADF_ALL_MASTER	(ADF_2012A|ADF_ALL_CACHE)
+/* All EATA Adapter Products */
+#define ADF_ALL_EATA	(ADF_2001|ADF_ALL_MASTER)
+#define ADF_ALL		ADF_ALL_EATA
+
+/* Application - sigWORD dsApplication;         FLAG BITS */
+/* ------------------------------------------------------------------ */
+#define APP_DPTMGR      0x0001  /* DPT Storage Manager */
+#define APP_ENGINE      0x0002  /* DPT Engine */
+#define APP_SYTOS       0x0004  /* Sytron Sytos Plus */
+#define APP_CHEYENNE    0x0008  /* Cheyenne ARCServe + ARCSolo */
+#define APP_MSCDEX      0x0010  /* Microsoft CD-ROM extensions */
+#define APP_NOVABACK    0x0020  /* NovaStor Novaback */
+#define APP_AIM         0x0040  /* Archive Information Manager */
+
+/* Requirements - sigBYTE dsRequirements;         FLAG BITS             */
+/* ------------------------------------------------------------------   */
+#define REQ_SMARTROM    0x01    /* Requires SmartROM to be present      */
+#define REQ_DPTDDL      0x02    /* Requires DPTDDL.SYS to be loaded     */
+#define REQ_HBA_DRIVER  0x04    /* Requires an HBA driver to be loaded  */
+#define REQ_ASPI_TRAN   0x08    /* Requires an ASPI Transport Modules   */
+#define REQ_ENGINE      0x10    /* Requires a DPT Engine to be loaded   */
+#define REQ_COMM_ENG    0x20    /* Requires a DPT Communications Engine */
+
+/*
+ * You may adjust dsDescription_size with an override to a value less than
+ * 50 so that the structure allocates less real space.
+ */
+#if (!defined(dsDescription_size))
+# define dsDescription_size 50
+#endif
+
+typedef struct dpt_sig {
+    char    dsSignature[6];      /* ALWAYS "dPtSiG" */
+    sigBYTE dsSigVersion;        /* signature version (currently 1) */
+    sigBYTE dsProcessorFamily;   /* what type of processor */
+    sigBYTE dsProcessor;         /* precise processor */
+    sigBYTE dsFiletype;          /* type of file */
+    sigBYTE dsFiletypeFlags;     /* flags to specify load type, etc. */
+    sigBYTE dsOEM;               /* OEM file was created for */
+    sigLONG dsOS;                /* which Operating systems */
+    sigWORD dsCapabilities;      /* RAID levels, etc. */
+    sigWORD dsDeviceSupp;        /* Types of SCSI devices supported */
+    sigWORD dsAdapterSupp;       /* DPT adapter families supported */
+    sigWORD dsApplication;       /* applications file is for */
+    sigBYTE dsRequirements;      /* Other driver dependencies */
+    sigBYTE dsVersion;           /* 1 */
+    sigBYTE dsRevision;          /* 'J' */
+    sigBYTE dsSubRevision;       /* '9'   ' ' if N/A */
+    sigBYTE dsMonth;             /* creation month */
+    sigBYTE dsDay;               /* creation day */
+    sigBYTE dsYear;              /* creation year since 1980 (1993=13) */
+    /* description (NULL terminated) */
+    char  dsDescription[dsDescription_size];
+} dpt_sig_S;
+/* 32 bytes minimum - with no description.  Put NULL at description[0] */
+/* 81 bytes maximum - with 49 character description plus NULL. */
+
+/* This line added at Roycroft's request */
+/* Microsoft's NT compiler gets confused if you do a pack and don't */
+/* restore it. */
+
+#ifndef NO_UNPACK
+#if defined (_DPT_AIX)
+#pragma options align=reset
+#elif defined (UNPACK_FOUR)
+#pragma pack(4)
+#else
+#pragma pack()
+#endif  /* aix */
+#endif
+/* For the Macintosh */
+#if STRUCTALIGNMENTSUPPORTED
+#pragma options align=reset
+#endif
+
+#endif
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/sys_info.h	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,417 @@
+/*	BSDI sys_info.h,v 1.6 1998/06/03 19:14:59 karels Exp	*/
+
+/*
+ * Copyright (c) 1996-1999 Distributed Processing Technology Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source form, with or without modification, are
+ * permitted provided that redistributions of source code must retain the
+ * above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * This software is provided `as is' by Distributed Processing Technology and
+ * any express or implied warranties, including, but not limited to, the
+ * implied warranties of merchantability and fitness for a particular purpose,
+ * are disclaimed. In no event shall Distributed Processing Technology be
+ * liable for any direct, indirect, incidental, special, exemplary or
+ * consequential damages (including, but not limited to, procurement of
+ * substitute goods or services; loss of use, data, or profits; or business
+ * interruptions) however caused and on any theory of liability, whether in
+ * contract, strict liability, or tort (including negligence or otherwise)
+ * arising in any way out of the use of this driver software, even if advised
+ * of the possibility of such damage.
+ *
+ */
+
+#ifndef         __SYS_INFO_H
+#define         __SYS_INFO_H
+
+/*File - SYS_INFO.H
+ ****************************************************************************
+ *
+ *Description:
+ *
+ *      This file contains structure definitions for the OS dependent
+ *layer system information buffers.
+ *
+ *Copyright Distributed Processing Technology, Corp.
+ *        140 Candace Dr.
+ *        Maitland, Fl. 32751   USA
+ *        Phone: (407) 830-5522  Fax: (407) 260-5366
+ *        All Rights Reserved
+ *
+ *Author:       Don Kemper
+ *Date:         5/10/94
+ *
+ *Editors:
+ *
+ *Remarks:
+ *
+ *
+ *****************************************************************************/
+
+
+/*Include Files ------------------------------------------------------------- */
+
+#include        "osd_util.h"
+
+#ifndef NO_PACK
+#if defined (_DPT_AIX)
+#pragma options align=packed
+#else
+#pragma pack(1)
+#endif  /* aix */
+#endif  // no unpack
+
+
+/*struct - driveParam_S - start
+ *===========================================================================
+ *
+ *Description:
+ *
+ *      This structure defines the drive parameters seen during
+ *booting.
+ *
+ *---------------------------------------------------------------------------*/
+
+#ifdef  __cplusplus
+   struct driveParam_S {
+#else
+   typedef struct  {
+#endif
+
+   uSHORT       cylinders;      /* Upto 1024 */
+   uCHAR        heads;          /* Upto 255 */
+   uCHAR        sectors;        /* Upto 63 */
+
+#ifdef  __cplusplus
+
+//---------- Portability Additions ----------- in sp_sinfo.cpp
+#ifdef DPT_PORTABLE
+	uSHORT		netInsert(dptBuffer_S *buffer);
+	uSHORT		netExtract(dptBuffer_S *buffer);
+#endif // DPT PORTABLE
+//--------------------------------------------
+
+   };
+#else
+   } driveParam_S;
+#endif
+/*driveParam_S - end */
+
+
+/*struct - sysInfo_S - start
+ *===========================================================================
+ *
+ *Description:
+ *
+ *      This structure defines the command system information that
+ *should be returned by every OS dependent layer.
+ *
+ *---------------------------------------------------------------------------*/
+
+/*flags - bit definitions */
+#define SI_CMOS_Valid           0x0001
+#define SI_NumDrivesValid       0x0002
+#define SI_ProcessorValid       0x0004
+#define SI_MemorySizeValid      0x0008
+#define SI_DriveParamsValid     0x0010
+#define SI_SmartROMverValid     0x0020
+#define SI_OSversionValid       0x0040
+#define SI_OSspecificValid      0x0080  /* 1 if OS structure returned */
+#define SI_BusTypeValid         0x0100
+
+#define SI_ALL_VALID            0x0FFF  /* All Std SysInfo is valid */
+#define SI_NO_SmartROM          0x8000
+
+/*busType - definitions */
+#define SI_ISA_BUS      0x00
+#define SI_MCA_BUS      0x01
+#define SI_EISA_BUS     0x02
+#define SI_PCI_BUS      0x04
+
+#ifdef  __cplusplus
+   struct sysInfo_S {
+#else
+   typedef struct  {
+#endif
+
+   uCHAR        drive0CMOS;             /* CMOS Drive 0 Type */
+   uCHAR        drive1CMOS;             /* CMOS Drive 1 Type */
+   uCHAR        numDrives;              /* 0040:0075 contents */
+   uCHAR        processorFamily;        /* Same as DPTSIG's definition */
+   uCHAR        processorType;          /* Same as DPTSIG's definition */
+   uCHAR        smartROMMajorVersion;
+   uCHAR        smartROMMinorVersion;   /* SmartROM version */
+   uCHAR        smartROMRevision;
+   uSHORT       flags;                  /* See bit definitions above */
+   uSHORT       conventionalMemSize;    /* in KB */
+   uLONG        extendedMemSize;        /* in KB */
+   uLONG        osType;                 /* Same as DPTSIG's definition */
+   uCHAR        osMajorVersion;
+   uCHAR        osMinorVersion;         /* The OS version */
+   uCHAR        osRevision;
+#ifdef _SINIX_ADDON
+   uCHAR        busType;                /* See defininitions above */
+   uSHORT       osSubRevision;
+   uCHAR        pad[2];                 /* For alignment */
+#else
+   uCHAR        osSubRevision;
+   uCHAR        busType;                /* See defininitions above */
+   uCHAR        pad[3];                 /* For alignment */
+#endif
+   driveParam_S drives[16];             /* SmartROM Logical Drives */
+
+#ifdef  __cplusplus
+
+//---------- Portability Additions ----------- in sp_sinfo.cpp
+#ifdef DPT_PORTABLE
+	uSHORT		netInsert(dptBuffer_S *buffer);
+	uSHORT		netExtract(dptBuffer_S *buffer);
+#endif // DPT PORTABLE
+//--------------------------------------------
+
+   };
+#else
+   } sysInfo_S;
+#endif
+/*sysInfo_S - end */
+
+
+/*struct - DOS_Info_S - start
+ *===========================================================================
+ *
+ *Description:
+ *
+ *      This structure defines the system information specific to a
+ *DOS workstation.
+ *
+ *---------------------------------------------------------------------------*/
+
+/*flags - bit definitions */
+#define DI_DOS_HIGH             0x01    /* DOS is loaded high */
+#define DI_DPMI_VALID           0x02    /* DPMI version is valid */
+
+#ifdef  __cplusplus
+   struct DOS_Info_S {
+#else
+   typedef struct {
+#endif
+
+   uCHAR        flags;          /* See bit definitions above */
+   uSHORT       driverLocation; /* SmartROM BIOS address */
+   uSHORT       DOS_version;
+   uSHORT       DPMI_version;
+
+#ifdef  __cplusplus
+
+//---------- Portability Additions ----------- in sp_sinfo.cpp
+#ifdef DPT_PORTABLE
+	uSHORT		netInsert(dptBuffer_S *buffer);
+	uSHORT		netExtract(dptBuffer_S *buffer);
+#endif // DPT PORTABLE
+//--------------------------------------------
+
+   };
+#else
+   } DOS_Info_S;
+#endif
+/*DOS_Info_S - end */
+
+
+/*struct - Netware_Info_S - start
+ *===========================================================================
+ *
+ *Description:
+ *
+ *      This structure defines the system information specific to a
+ *Netware machine.
+ *
+ *---------------------------------------------------------------------------*/
+
+#ifdef  __cplusplus
+   struct Netware_Info_S {
+#else
+   typedef struct {
+#endif
+
+   uCHAR        driverName[13];         /* ie PM12NW31.DSK */
+   uCHAR        serverName[48];
+   uCHAR        netwareVersion;         /* The Netware OS version */
+   uCHAR        netwareSubVersion;
+   uCHAR        netwareRevision;
+   uSHORT       maxConnections;         /* Probably  250 or 1000 */
+   uSHORT       connectionsInUse;
+   uSHORT       maxVolumes;
+   uCHAR        unused;
+   uCHAR        SFTlevel;
+   uCHAR        TTSlevel;
+
+   uCHAR        clibMajorVersion;       /* The CLIB.NLM version */
+   uCHAR        clibMinorVersion;
+   uCHAR        clibRevision;
+
+#ifdef  __cplusplus
+
+//---------- Portability Additions ----------- in sp_sinfo.cpp
+#ifdef DPT_PORTABLE
+	uSHORT		netInsert(dptBuffer_S *buffer);
+	uSHORT		netExtract(dptBuffer_S *buffer);
+#endif // DPT PORTABLE
+//--------------------------------------------
+
+   };
+#else
+   } Netware_Info_S;
+#endif
+/*Netware_Info_S - end */
+
+
+/*struct - OS2_Info_S - start
+ *===========================================================================
+ *
+ *Description:
+ *
+ *      This structure defines the system information specific to an
+ *OS/2 machine.
+ *
+ *---------------------------------------------------------------------------*/
+
+#ifdef  __cplusplus
+   struct OS2_Info_S {
+#else
+   typedef struct {
+#endif
+
+   uCHAR        something;
+
+#ifdef  __cplusplus
+
+//---------- Portability Additions ----------- in sp_sinfo.cpp
+#ifdef DPT_PORTABLE
+	uSHORT		netInsert(dptBuffer_S *buffer);
+	uSHORT		netExtract(dptBuffer_S *buffer);
+#endif // DPT PORTABLE
+//--------------------------------------------
+
+   };
+#else
+   } OS2_Info_S;
+#endif
+/*OS2_Info_S - end */
+
+
+/*struct - WinNT_Info_S - start
+ *===========================================================================
+ *
+ *Description:
+ *
+ *      This structure defines the system information specific to a
+ *Windows NT machine.
+ *
+ *---------------------------------------------------------------------------*/
+
+#ifdef  __cplusplus
+   struct WinNT_Info_S {
+#else
+   typedef struct {
+#endif
+
+   uCHAR        something;
+
+#ifdef  __cplusplus
+
+//---------- Portability Additions ----------- in sp_sinfo.cpp
+#ifdef DPT_PORTABLE
+	uSHORT		netInsert(dptBuffer_S *buffer);
+	uSHORT		netExtract(dptBuffer_S *buffer);
+#endif // DPT PORTABLE
+//--------------------------------------------
+
+   };
+#else
+   } WinNT_Info_S;
+#endif
+/*WinNT_Info_S - end */
+
+
+/*struct - SCO_Info_S - start
+ *===========================================================================
+ *
+ *Description:
+ *
+ *      This structure defines the system information specific to an
+ *SCO UNIX machine.
+ *
+ *---------------------------------------------------------------------------*/
+
+#ifdef  __cplusplus
+   struct SCO_Info_S {
+#else
+   typedef struct {
+#endif
+
+   uCHAR        something;
+
+#ifdef  __cplusplus
+
+//---------- Portability Additions ----------- in sp_sinfo.cpp
+#ifdef DPT_PORTABLE
+	uSHORT		netInsert(dptBuffer_S *buffer);
+	uSHORT		netExtract(dptBuffer_S *buffer);
+#endif // DPT PORTABLE
+//--------------------------------------------
+
+   };
+#else
+   } SCO_Info_S;
+#endif
+/*SCO_Info_S - end */
+
+
+/*struct - USL_Info_S - start
+ *===========================================================================
+ *
+ *Description:
+ *
+ *      This structure defines the system information specific to a
+ *USL UNIX machine.
+ *
+ *---------------------------------------------------------------------------*/
+
+#ifdef  __cplusplus
+   struct USL_Info_S {
+#else
+   typedef struct {
+#endif
+
+   uCHAR        something;
+
+#ifdef  __cplusplus
+
+//---------- Portability Additions ----------- in sp_sinfo.cpp
+#ifdef DPT_PORTABLE
+	uSHORT		netInsert(dptBuffer_S *buffer);
+	uSHORT		netExtract(dptBuffer_S *buffer);
+#endif // DPT PORTABLE
+//--------------------------------------------
+
+   };
+#else
+   } USL_Info_S;
+#endif
+/*USL_Info_S - end */
+
+
+  /* Restore default structure packing */
+#ifndef NO_UNPACK
+#if defined (_DPT_AIX)
+#pragma options align=reset
+#elif defined (UNPACK_FOUR)
+#pragma pack(4)
+#else
+#pragma pack()
+#endif  /* aix */
+#endif  // no unpack
+
+#endif  // __SYS_INFO_H
+
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/README.dpti	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,41 @@
+ /* TERMS AND CONDITIONS OF USE
+ * 
+ * Redistribution and use in source form, with or without modification, are
+ * permitted provided that redistributions of source code must retain the
+ * above copyright notice, this list of conditions and the following disclaimer.
+ * 
+ * This software is provided `as is' by Adaptec and
+ * any express or implied warranties, including, but not limited to, the
+ * implied warranties of merchantability and fitness for a particular purpose,
+ * are disclaimed. In no event shall Adaptec be
+ * liable for any direct, indirect, incidental, special, exemplary or
+ * consequential damages (including, but not limited to, procurement of
+ * substitute goods or services; loss of use, data, or profits; or business
+ * interruptions) however caused and on any theory of liability, whether in
+ * contract, strict liability, or tort (including negligence or otherwise)
+ * arising in any way out of the use of this driver software, even if advised
+ * of the possibility of such damage.
+ * 
+ ****************************************************************
+ * This driver supports the Adaptec I2O RAID and DPT SmartRAID V I2O boards.
+ *
+ * CREDITS:
+ * The original linux driver was ported to Linux by Karen White while at 
+ * Dell Computer.  It was ported from Bob Pasteur's (of DPT) original 
+ * non-Linux driver.  Mark Salyzyn and Bob Pasteur consulted on the original
+ * driver. 
+ * 
+ * Thanks to Ricky Beam for supplying porting information to 2.3 kernel.
+ *
+ * 2.0 version of the driver by Deanna Bonds and Mark Salyzyn.
+ *
+ * HISTORY:
+ * The driver was originally ported to linux version 2.0.34.  
+ * SMP support was added in version 2.2.1 and 2.2.2.
+ *
+ * The DPT card optimizes the order of processing commands.  Consequently,
+ * a command may take up to 6 minutes to complete after it has been sent
+ * to the board.  
+ *
+ */
+
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/osd_util.h	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,358 @@
+/*	BSDI osd_util.h,v 1.8 1998/06/03 19:14:58 karels Exp	*/
+
+/*
+ * Copyright (c) 1996-1999 Distributed Processing Technology Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source form, with or without modification, are
+ * permitted provided that redistributions of source code must retain the
+ * above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * This software is provided `as is' by Distributed Processing Technology and
+ * any express or implied warranties, including, but not limited to, the
+ * implied warranties of merchantability and fitness for a particular purpose,
+ * are disclaimed. In no event shall Distributed Processing Technology be
+ * liable for any direct, indirect, incidental, special, exemplary or
+ * consequential damages (including, but not limited to, procurement of
+ * substitute goods or services; loss of use, data, or profits; or business
+ * interruptions) however caused and on any theory of liability, whether in
+ * contract, strict liability, or tort (including negligence or otherwise)
+ * arising in any way out of the use of this driver software, even if advised
+ * of the possibility of such damage.
+ *
+ */
+
+#ifndef         __OSD_UTIL_H
+#define         __OSD_UTIL_H
+
+/*File - OSD_UTIL.H
+ ****************************************************************************
+ *
+ *Description:
+ *
+ *      This file contains defines and function prototypes that are
+ *operating system dependent.  The resources defined in this file
+ *are not specific to any particular application.
+ *
+ *Copyright Distributed Processing Technology, Corp.
+ *        140 Candace Dr.
+ *        Maitland, Fl. 32751   USA
+ *        Phone: (407) 830-5522  Fax: (407) 260-5366
+ *        All Rights Reserved
+ *
+ *Author:       Doug Anderson
+ *Date:         1/7/94
+ *
+ *Editors:
+ *
+ *Remarks:
+ *
+ *
+ *****************************************************************************/
+
+
+/*Definitions - Defines & Constants ----------------------------------------- */
+
+/*----------------------------- */
+/* Operating system selections: */
+/*----------------------------- */
+
+/*#define               _DPT_MSDOS      */
+/*#define               _DPT_WIN_3X     */
+/*#define               _DPT_WIN_4X     */
+/*#define               _DPT_WIN_NT     */
+/*#define               _DPT_NETWARE    */
+/*#define               _DPT_OS2        */
+/*#define               _DPT_SCO        */
+/*#define               _DPT_UNIXWARE   */
+/*#define               _DPT_SOLARIS    */
+/*#define               _DPT_NEXTSTEP   */
+/*#define               _DPT_BANYAN     */
+
+/*-------------------------------- */
+/* Include the OS specific defines */
+/*-------------------------------- */
+
+/*#define       OS_SELECTION    From Above List */
+/*#define       SEMAPHORE_T     ??? */
+/*#define       DLL_HANDLE_T    ??? */
+
+#if (defined(KERNEL) && (defined(__FreeBSD__) || defined(__bsdi__)))
+# include        "i386/isa/dpt_osd_defs.h"
+#else
+# include        "osd_defs.h"
+#endif
+
+#ifndef DPT_UNALIGNED
+   #define      DPT_UNALIGNED
+#endif
+
+#ifndef DPT_EXPORT
+   #define      DPT_EXPORT
+#endif
+
+#ifndef DPT_IMPORT
+   #define      DPT_IMPORT
+#endif
+
+#ifndef DPT_RUNTIME_IMPORT
+   #define      DPT_RUNTIME_IMPORT  DPT_IMPORT
+#endif
+
+/*--------------------- */
+/* OS dependent defines */
+/*--------------------- */
+
+#if defined (_DPT_MSDOS) || defined (_DPT_WIN_3X)
+   #define      _DPT_16_BIT
+#else
+   #define      _DPT_32_BIT
+#endif
+
+#if defined (_DPT_SCO) || defined (_DPT_UNIXWARE) || defined (_DPT_SOLARIS) || defined (_DPT_AIX) || defined (SNI_MIPS) || defined (_DPT_BSDI) || defined (_DPT_FREE_BSD) || defined(_DPT_LINUX)
+   #define      _DPT_UNIX
+#endif
+
+#if defined (_DPT_WIN_3x) || defined (_DPT_WIN_4X) || defined (_DPT_WIN_NT) \
+	    || defined (_DPT_OS2)
+   #define      _DPT_DLL_SUPPORT
+#endif
+
+#if !defined (_DPT_MSDOS) && !defined (_DPT_WIN_3X) && !defined (_DPT_NETWARE)
+   #define      _DPT_PREEMPTIVE
+#endif
+
+#if !defined (_DPT_MSDOS) && !defined (_DPT_WIN_3X)
+   #define      _DPT_MULTI_THREADED
+#endif
+
+#if !defined (_DPT_MSDOS)
+   #define      _DPT_MULTI_TASKING
+#endif
+
+  /* These exist for platforms that   */
+  /* chunk when accessing mis-aligned */
+  /* data                             */
+#if defined (SNI_MIPS) || defined (_DPT_SOLARIS)
+   #if defined (_DPT_BIG_ENDIAN)
+	#if !defined (_DPT_STRICT_ALIGN)
+            #define _DPT_STRICT_ALIGN
+	#endif
+   #endif
+#endif
+
+  /* Determine if in C or C++ mode */
+#ifdef  __cplusplus
+   #define      _DPT_CPP
+#else
+   #define      _DPT_C
+#endif
+
+/*-------------------------------------------------------------------*/
+/* Under Solaris the compiler refuses to accept code like:           */
+/*   { {"DPT"}, 0, NULL .... },                                      */
+/* and complains about the {"DPT"} part by saying "cannot use { }    */
+/* to initialize char*".                                             */
+/*                                                                   */
+/* By defining these ugly macros we can get around this and also     */
+/* not have to copy and #ifdef large sections of code.  I know that  */
+/* these macros are *really* ugly, but they should help reduce       */
+/* maintenance in the long run.                                      */
+/*                                                                   */
+/*-------------------------------------------------------------------*/
+#if !defined (DPTSQO)
+   #if defined (_DPT_SOLARIS)
+      #define DPTSQO
+      #define DPTSQC
+   #else
+      #define DPTSQO {
+      #define DPTSQC }
+   #endif  /* solaris */
+#endif  /* DPTSQO */
+
+
+/*---------------------- */
+/* OS dependent typedefs */
+/*---------------------- */
+
+#if defined (_DPT_MSDOS) || defined (_DPT_SCO)
+   #define BYTE unsigned char
+   #define WORD unsigned short
+#endif
+
+#ifndef _DPT_TYPEDEFS
+   #define _DPT_TYPEDEFS
+   typedef unsigned char   uCHAR;
+   typedef unsigned short  uSHORT;
+   typedef unsigned int    uINT;
+   typedef unsigned long   uLONG;
+
+   typedef union {
+	 uCHAR        u8[4];
+	 uSHORT       u16[2];
+	 uLONG        u32;
+   } access_U;
+#endif
+
+#if !defined (NULL)
+   #define      NULL    0
+#endif
+
+
+/*Prototypes - function ----------------------------------------------------- */
+
+#ifdef  __cplusplus
+   extern "C" {         /* Declare all these functions as "C" functions */
+#endif
+
+/*------------------------ */
+/* Byte reversal functions */
+/*------------------------ */
+
+  /* Reverses the byte ordering of a 2 byte variable */
+#if (!defined(osdSwap2))
+ uSHORT       osdSwap2(DPT_UNALIGNED uSHORT *);
+#endif  // !osdSwap2
+
+  /* Reverses the byte ordering of a 4 byte variable and shifts left 8 bits */
+#if (!defined(osdSwap3))
+ uLONG        osdSwap3(DPT_UNALIGNED uLONG *);
+#endif  // !osdSwap3
+
+
+#ifdef  _DPT_NETWARE
+   #include "novpass.h" /* For DPT_Bswapl() prototype */
+	/* Inline the byte swap */
+   #ifdef __cplusplus
+	 inline uLONG osdSwap4(uLONG *inLong) {
+	 return *inLong = DPT_Bswapl(*inLong);
+	 }
+   #else
+	 #define osdSwap4(inLong)       DPT_Bswapl(inLong)
+   #endif  // cplusplus
+#else
+	/* Reverses the byte ordering of a 4 byte variable */
+# if (!defined(osdSwap4))
+   uLONG        osdSwap4(DPT_UNALIGNED uLONG *);
+# endif  // !osdSwap4
+
+  /* The following functions ALWAYS swap regardless of the *
+   * presence of DPT_BIG_ENDIAN                            */
+
+   uSHORT       trueSwap2(DPT_UNALIGNED uSHORT *);
+   uLONG        trueSwap4(DPT_UNALIGNED uLONG *);
+
+#endif  // netware
+
+
+/*-------------------------------------*
+ * Network order swap functions        *
+ *                                     *
+ * These functions/macros will be used *
+ * by the structure insert()/extract() *
+ * functions.                          *
+ *
+ * We will enclose all structure       *
+ * portability modifications inside    *
+ * #ifdefs.  When we are ready, we     *
+ * will #define DPT_PORTABLE to begin  *
+ * using the modifications.            *
+ *-------------------------------------*/
+uLONG	netSwap4(uLONG val);
+
+#if defined (_DPT_BIG_ENDIAN)
+
+// for big-endian we need to swap
+
+#ifndef NET_SWAP_2
+#define NET_SWAP_2(x) (((x) >> 8) | ((x) << 8))
+#endif  // NET_SWAP_2
+
+#ifndef NET_SWAP_4
+#define NET_SWAP_4(x) netSwap4((x))
+#endif  // NET_SWAP_4
+
+#else
+
+// for little-endian we don't need to do anything
+
+#ifndef NET_SWAP_2
+#define NET_SWAP_2(x) (x)
+#endif  // NET_SWAP_2
+
+#ifndef NET_SWAP_4
+#define NET_SWAP_4(x) (x)
+#endif  // NET_SWAP_4
+
+#endif  // big endian
+
+
+
+/*----------------------------------- */
+/* Run-time loadable module functions */
+/*----------------------------------- */
+
+  /* Loads the specified run-time loadable DLL */
+DLL_HANDLE_T    osdLoadModule(uCHAR *);
+  /* Unloads the specified run-time loadable DLL */
+uSHORT          osdUnloadModule(DLL_HANDLE_T);
+  /* Returns a pointer to a function inside a run-time loadable DLL */
+void *          osdGetFnAddr(DLL_HANDLE_T,uCHAR *);
+
+/*--------------------------------------- */
+/* Mutually exclusive semaphore functions */
+/*--------------------------------------- */
+
+  /* Create a named semaphore */
+SEMAPHORE_T     osdCreateNamedSemaphore(char *);
+  /* Create a mutually exlusive semaphore */
+SEMAPHORE_T     osdCreateSemaphore(void);
+	/* create an event semaphore */
+SEMAPHORE_T              osdCreateEventSemaphore(void);
+	/* create a named event semaphore */
+SEMAPHORE_T             osdCreateNamedEventSemaphore(char *);
+
+  /* Destroy the specified mutually exclusive semaphore object */
+uSHORT          osdDestroySemaphore(SEMAPHORE_T);
+  /* Request access to the specified mutually exclusive semaphore */
+uLONG           osdRequestSemaphore(SEMAPHORE_T,uLONG);
+  /* Release access to the specified mutually exclusive semaphore */
+uSHORT          osdReleaseSemaphore(SEMAPHORE_T);
+	/* wait for a event to happen */
+uLONG                            osdWaitForEventSemaphore(SEMAPHORE_T, uLONG);
+	/* signal an event */
+uLONG                            osdSignalEventSemaphore(SEMAPHORE_T);
+	/* reset the event */
+uLONG                            osdResetEventSemaphore(SEMAPHORE_T);
+
+/*----------------- */
+/* Thread functions */
+/*----------------- */
+
+  /* Releases control to the task switcher in non-preemptive */
+  /* multitasking operating systems. */
+void            osdSwitchThreads(void);
+
+  /* Starts a thread function */
+uLONG   osdStartThread(void *,void *);
+
+/* what is my thread id */
+uLONG osdGetThreadID(void);
+
+/* wakes up the specifed thread */
+void osdWakeThread(uLONG);
+
+/* osd sleep for x miliseconds */
+void osdSleep(uLONG);
+
+#define DPT_THREAD_PRIORITY_LOWEST 0x00
+#define DPT_THREAD_PRIORITY_NORMAL 0x01
+#define DPT_THREAD_PRIORITY_HIGHEST 0x02
+
+uCHAR osdSetThreadPriority(uLONG tid, uCHAR priority);
+
+#ifdef __cplusplus
+   }    /* end the xtern "C" declaration */
+#endif
+
+#endif  /* osd_util_h */
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/osd_defs.h	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,79 @@
+/*	BSDI osd_defs.h,v 1.4 1998/06/03 19:14:58 karels Exp	*/
+/*
+ * Copyright (c) 1996-1999 Distributed Processing Technology Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source form, with or without modification, are
+ * permitted provided that redistributions of source code must retain the
+ * above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * This software is provided `as is' by Distributed Processing Technology and
+ * any express or implied warranties, including, but not limited to, the
+ * implied warranties of merchantability and fitness for a particular purpose,
+ * are disclaimed. In no event shall Distributed Processing Technology be
+ * liable for any direct, indirect, incidental, special, exemplary or
+ * consequential damages (including, but not limited to, procurement of
+ * substitute goods or services; loss of use, data, or profits; or business
+ * interruptions) however caused and on any theory of liability, whether in
+ * contract, strict liability, or tort (including negligence or otherwise)
+ * arising in any way out of the use of this driver software, even if advised
+ * of the possibility of such damage.
+ *
+ */
+
+#ifndef		_OSD_DEFS_H
+#define		_OSD_DEFS_H
+
+/*File - OSD_DEFS.H
+ ****************************************************************************
+ *
+ *Description:
+ *
+ *	This file contains the OS dependent defines.  This file is included
+ *in osd_util.h and provides the OS specific defines for that file.
+ *
+ *Copyright Distributed Processing Technology, Corp.
+ *	  140 Candace Dr.
+ *	  Maitland, Fl.	32751   USA
+ *	  Phone: (407) 830-5522  Fax: (407) 260-5366
+ *	  All Rights Reserved
+ *
+ *Author:	Doug Anderson
+ *Date:		1/31/94
+ *
+ *Editors:
+ *
+ *Remarks:
+ *
+ *
+ *****************************************************************************/
+
+
+/*Definitions - Defines & Constants ----------------------------------------- */
+
+  /* Define the operating system */
+#if (defined(__linux__))
+# define _DPT_LINUX
+#elif (defined(__bsdi__))
+# define _DPT_BSDI
+#elif (defined(__FreeBSD__))
+# define _DPT_FREE_BSD
+#else
+# define _DPT_SCO
+#endif
+
+#if defined (ZIL_CURSES)
+#define		_DPT_CURSES
+#else
+#define         _DPT_MOTIF
+#endif
+
+  /* Redefine 'far' to nothing - no far pointer type required in UNIX */
+#define		far
+
+  /* Define the mutually exclusive semaphore type */
+#define		SEMAPHORE_T	unsigned int *
+  /* Define a handle to a DLL */
+#define		DLL_HANDLE_T	unsigned int *
+
+#endif
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/dpti_i2o-dev.h	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,397 @@
+/*
+ * I2O user space accessible structures/APIs
+ * 
+ * (c) Copyright 1999, 2000 Red Hat Software
+ *
+ * This program is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU General Public License 
+ * as published by the Free Software Foundation; either version 
+ * 2 of the License, or (at your option) any later version.  
+ * 
+ *************************************************************************
+ *
+ * This header file defines the I2O APIs that are available to both
+ * the kernel and user level applications.  Kernel specific structures
+ * are defined in i2o_osm. OSMs should include _only_ i2o_osm.h which
+ * automatically includs this file.
+ *
+ */
+
+#ifndef _I2O_DEV_H
+#define _I2O_DEV_H
+
+/* How many controllers are we allowing */
+#define MAX_I2O_CONTROLLERS	32
+
+#include <linux/ioctl.h>
+
+/*
+ * I2O Control IOCTLs and structures
+ */
+#define I2O_MAGIC_NUMBER	'i'
+#define I2OGETIOPS		_IOR(I2O_MAGIC_NUMBER,0,u8[MAX_I2O_CONTROLLERS])
+#define I2OHRTGET		_IOWR(I2O_MAGIC_NUMBER,1,struct i2o_cmd_hrtlct)
+#define I2OLCTGET		_IOWR(I2O_MAGIC_NUMBER,2,struct i2o_cmd_hrtlct)
+#define I2OPARMSET		_IOWR(I2O_MAGIC_NUMBER,3,struct i2o_cmd_psetget)
+#define I2OPARMGET		_IOWR(I2O_MAGIC_NUMBER,4,struct i2o_cmd_psetget)
+#define I2OSWDL			_IOWR(I2O_MAGIC_NUMBER,5,struct i2o_sw_xfer)
+#define I2OSWUL			_IOWR(I2O_MAGIC_NUMBER,6,struct i2o_sw_xfer)
+#define I2OSWDEL		_IOWR(I2O_MAGIC_NUMBER,7,struct i2o_sw_xfer)
+#define I2OVALIDATE		_IOR(I2O_MAGIC_NUMBER,8,u32)
+#define I2OHTML			_IOWR(I2O_MAGIC_NUMBER,9,struct i2o_html)
+#define I2OEVTREG		_IOW(I2O_MAGIC_NUMBER,10,struct i2o_evt_id)
+#define I2OEVTGET		_IOR(I2O_MAGIC_NUMBER,11,struct i2o_evt_info)
+
+struct i2o_cmd_hrtlct
+{
+	unsigned int iop;	/* IOP unit number */
+	void *resbuf;		/* Buffer for result */
+	unsigned int *reslen;	/* Buffer length in bytes */
+};
+
+struct i2o_cmd_psetget
+{
+	unsigned int iop;	/* IOP unit number */
+	unsigned int tid;	/* Target device TID */
+	void *opbuf;		/* Operation List buffer */
+	unsigned int oplen;	/* Operation List buffer length in bytes */
+	void *resbuf;		/* Result List buffer */
+	unsigned int *reslen;	/* Result List buffer length in bytes */
+};
+
+struct i2o_sw_xfer
+{
+	unsigned int iop;	/* IOP unit number */
+	unsigned char flags;	/* Flags field */
+	unsigned char sw_type;	/* Software type */
+	unsigned int sw_id;	/* Software ID */
+	void *buf;		/* Pointer to software buffer */
+	unsigned int *swlen;	/* Length of software data */
+	unsigned int *maxfrag;	/* Maximum fragment count */
+        unsigned int *curfrag;	/* Current fragment count */
+};
+
+struct i2o_html
+{
+	unsigned int iop;	/* IOP unit number */
+	unsigned int tid;	/* Target device ID */
+	unsigned int page;	/* HTML page */
+	void *resbuf;		/* Buffer for reply HTML page */
+	unsigned int *reslen;	/* Length in bytes of reply buffer */
+	void *qbuf;		/* Pointer to HTTP query string */
+	unsigned int qlen;	/* Length in bytes of query string buffer */
+};
+
+#define I2O_EVT_Q_LEN 32
+
+struct i2o_evt_id
+{
+	unsigned int iop;
+	unsigned int tid;
+	unsigned int evt_mask;
+};
+
+/* Event data size = frame size - message header + evt indicator */
+#define I2O_EVT_DATA_SIZE 88
+
+struct i2o_evt_info
+{
+	struct i2o_evt_id id;
+	unsigned char evt_data[I2O_EVT_DATA_SIZE];
+ 	unsigned int data_size;
+};
+
+struct i2o_evt_get
+{
+	struct i2o_evt_info info;
+	int pending;
+	int lost;
+};
+
+
+/**************************************************************************
+ * HRT related constants and structures
+ **************************************************************************/
+#define I2O_BUS_LOCAL	0
+#define I2O_BUS_ISA	1
+#define I2O_BUS_EISA	2
+#define I2O_BUS_MCA	3
+#define I2O_BUS_PCI	4
+#define I2O_BUS_PCMCIA	5
+#define I2O_BUS_NUBUS	6
+#define I2O_BUS_CARDBUS	7
+#define I2O_BUS_UNKNOWN	0x80
+
+#ifndef __KERNEL__
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+
+#endif /* __KERNEL__ */
+
+typedef struct _i2o_pci_bus {
+	u8 PciFunctionNumber;
+	u8 PciDeviceNumber;
+	u8 PciBusNumber;
+	u8 reserved;
+	u16 PciVendorID;
+	u16 PciDeviceID;
+} i2o_pci_bus;
+
+typedef struct _i2o_local_bus {
+	u16 LbBaseIOPort;
+	u16 reserved;
+	u32 LbBaseMemoryAddress;
+} i2o_local_bus;
+
+typedef struct _i2o_isa_bus {
+	u16 IsaBaseIOPort;
+	u8 CSN;
+	u8 reserved;
+	u32 IsaBaseMemoryAddress;
+} i2o_isa_bus;
+
+typedef struct _i2o_eisa_bus_info {
+	u16 EisaBaseIOPort;
+	u8 reserved;
+	u8 EisaSlotNumber;
+	u32 EisaBaseMemoryAddress;
+} i2o_eisa_bus;
+
+typedef struct _i2o_mca_bus {
+	u16 McaBaseIOPort;
+	u8 reserved;
+	u8 McaSlotNumber;
+	u32 McaBaseMemoryAddress;
+} i2o_mca_bus;
+
+typedef struct _i2o_other_bus {
+	u16 BaseIOPort;
+	u16 reserved;
+	u32 BaseMemoryAddress;
+} i2o_other_bus;
+
+typedef struct _i2o_hrt_entry {
+	u32 adapter_id;
+	u32 parent_tid:12;
+	u32 state:4;
+	u32 bus_num:8;
+	u32 bus_type:8;
+	union {
+		i2o_pci_bus pci_bus;
+		i2o_local_bus local_bus;
+		i2o_isa_bus isa_bus;
+		i2o_eisa_bus eisa_bus;
+		i2o_mca_bus mca_bus;
+		i2o_other_bus other_bus;
+	} bus;
+} i2o_hrt_entry;
+
+typedef struct _i2o_hrt {
+	u16 num_entries;
+	u8 entry_len;
+	u8 hrt_version;
+	u32 change_ind;
+	i2o_hrt_entry hrt_entry[1];
+} i2o_hrt;
+
+typedef struct _i2o_lct_entry {
+	u32 entry_size:16;
+	u32 tid:12;
+	u32 reserved:4;
+	u32 change_ind;
+	u32 device_flags;
+	u32 class_id:12;
+	u32 version:4;
+	u32 vendor_id:16;
+	u32 sub_class;
+	u32 user_tid:12;
+	u32 parent_tid:12;
+	u32 bios_info:8;
+	u8 identity_tag[8];
+	u32 event_capabilities;
+} i2o_lct_entry;
+
+typedef struct _i2o_lct {
+	u32 table_size:16;
+	u32 boot_tid:12;
+	u32 lct_ver:4;
+	u32 iop_flags;
+	u32 change_ind;
+	i2o_lct_entry lct_entry[1];
+} i2o_lct;
+
+typedef struct _i2o_status_block {
+	u16 org_id;
+	u16 reserved;
+	u16 iop_id:12;
+	u16 reserved1:4;
+	u16 host_unit_id;
+	u16 segment_number:12;
+	u16 i2o_version:4;
+	u8 iop_state;
+	u8 msg_type;
+	u16 inbound_frame_size;
+	u8 init_code;	
+	u8 reserved2;
+	u32 max_inbound_frames;
+	u32 cur_inbound_frames;
+	u32 max_outbound_frames;
+	char product_id[24];	
+	u32 expected_lct_size;
+	u32 iop_capabilities;
+	u32 desired_mem_size;
+	u32 current_mem_size;
+	u32 current_mem_base;
+	u32 desired_io_size;
+	u32 current_io_size;
+	u32 current_io_base;
+	u32 reserved3:24;
+	u32 cmd_status:8;
+} i2o_status_block;
+ 
+/* Event indicator mask flags */
+#define I2O_EVT_IND_STATE_CHANGE		0x80000000
+#define I2O_EVT_IND_GENERAL_WARNING		0x40000000
+#define I2O_EVT_IND_CONFIGURATION_FLAG		0x20000000
+#define I2O_EVT_IND_LOCK_RELEASE		0x10000000
+#define I2O_EVT_IND_CAPABILITY_CHANGE		0x08000000
+#define I2O_EVT_IND_DEVICE_RESET		0x04000000
+#define I2O_EVT_IND_EVT_MASK_MODIFIED		0x02000000
+#define I2O_EVT_IND_FIELD_MODIFIED		0x01000000
+#define I2O_EVT_IND_VENDOR_EVT			0x00800000
+#define I2O_EVT_IND_DEVICE_STATE		0x00400000
+
+/* Executive event indicitors */
+#define I2O_EVT_IND_EXEC_RESOURCE_LIMITS	0x00000001
+#define I2O_EVT_IND_EXEC_CONNECTION_FAIL	0x00000002
+#define I2O_EVT_IND_EXEC_ADAPTER_FAULT		0x00000004
+#define I2O_EVT_IND_EXEC_POWER_FAIL		0x00000008
+#define I2O_EVT_IND_EXEC_RESET_PENDING		0x00000010
+#define I2O_EVT_IND_EXEC_RESET_IMMINENT		0x00000020
+#define I2O_EVT_IND_EXEC_HW_FAIL		0x00000040
+#define I2O_EVT_IND_EXEC_XCT_CHANGE		0x00000080
+#define I2O_EVT_IND_EXEC_NEW_LCT_ENTRY		0x00000100
+#define I2O_EVT_IND_EXEC_MODIFIED_LCT		0x00000200
+#define I2O_EVT_IND_EXEC_DDM_AVAILABILITY	0x00000400
+
+/* Random Block Storage Event Indicators */
+#define I2O_EVT_IND_BSA_VOLUME_LOAD		0x00000001
+#define I2O_EVT_IND_BSA_VOLUME_UNLOAD		0x00000002
+#define I2O_EVT_IND_BSA_VOLUME_UNLOAD_REQ	0x00000004
+#define I2O_EVT_IND_BSA_CAPACITY_CHANGE		0x00000008
+#define I2O_EVT_IND_BSA_SCSI_SMART		0x00000010
+
+/* Event data for generic events */
+#define I2O_EVT_STATE_CHANGE_NORMAL		0x00
+#define I2O_EVT_STATE_CHANGE_SUSPENDED		0x01
+#define I2O_EVT_STATE_CHANGE_RESTART		0x02
+#define I2O_EVT_STATE_CHANGE_NA_RECOVER		0x03
+#define I2O_EVT_STATE_CHANGE_NA_NO_RECOVER	0x04
+#define I2O_EVT_STATE_CHANGE_QUIESCE_REQUEST	0x05
+#define I2O_EVT_STATE_CHANGE_FAILED		0x10
+#define I2O_EVT_STATE_CHANGE_FAULTED		0x11
+
+#define I2O_EVT_GEN_WARNING_NORMAL		0x00
+#define I2O_EVT_GEN_WARNING_ERROR_THRESHOLD	0x01
+#define I2O_EVT_GEN_WARNING_MEDIA_FAULT		0x02
+
+#define I2O_EVT_CAPABILITY_OTHER		0x01
+#define I2O_EVT_CAPABILITY_CHANGED		0x02
+
+#define I2O_EVT_SENSOR_STATE_CHANGED		0x01
+
+/*
+ *	I2O classes / subclasses
+ */
+
+/*  Class ID and Code Assignments
+ *  (LCT.ClassID.Version field)
+ */
+#define    I2O_CLASS_VERSION_10                        0x00
+#define    I2O_CLASS_VERSION_11                        0x01
+
+/*  Class code names
+ *  (from v1.5 Table 6-1 Class Code Assignments.)
+ */
+ 
+#define    I2O_CLASS_EXECUTIVE                         0x000
+#define    I2O_CLASS_DDM                               0x001
+#define    I2O_CLASS_RANDOM_BLOCK_STORAGE              0x010
+#define    I2O_CLASS_SEQUENTIAL_STORAGE                0x011
+#define    I2O_CLASS_LAN                               0x020
+#define    I2O_CLASS_WAN                               0x030
+#define    I2O_CLASS_FIBRE_CHANNEL_PORT                0x040
+#define    I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL          0x041
+#define    I2O_CLASS_SCSI_PERIPHERAL                   0x051
+#define    I2O_CLASS_ATE_PORT                          0x060
+#define    I2O_CLASS_ATE_PERIPHERAL                    0x061
+#define    I2O_CLASS_FLOPPY_CONTROLLER                 0x070
+#define    I2O_CLASS_FLOPPY_DEVICE                     0x071
+#define    I2O_CLASS_BUS_ADAPTER_PORT                  0x080
+#define    I2O_CLASS_PEER_TRANSPORT_AGENT              0x090
+#define    I2O_CLASS_PEER_TRANSPORT                    0x091
+
+/* 
+ *  Rest of 0x092 - 0x09f reserved for peer-to-peer classes
+ */
+ 
+#define    I2O_CLASS_MATCH_ANYCLASS                    0xffffffff
+
+/* 
+ *  Subclasses
+ */
+
+#define    I2O_SUBCLASS_i960                           0x001
+#define    I2O_SUBCLASS_HDM                            0x020
+#define    I2O_SUBCLASS_ISM                            0x021
+ 
+/* Operation functions */
+
+#define I2O_PARAMS_FIELD_GET	0x0001
+#define I2O_PARAMS_LIST_GET	0x0002
+#define I2O_PARAMS_MORE_GET	0x0003
+#define I2O_PARAMS_SIZE_GET	0x0004
+#define I2O_PARAMS_TABLE_GET	0x0005
+#define I2O_PARAMS_FIELD_SET	0x0006
+#define I2O_PARAMS_LIST_SET	0x0007
+#define I2O_PARAMS_ROW_ADD	0x0008
+#define I2O_PARAMS_ROW_DELETE	0x0009
+#define I2O_PARAMS_TABLE_CLEAR	0x000A
+
+/*
+ * I2O serial number conventions / formats 
+ * (circa v1.5)
+ */
+
+#define    I2O_SNFORMAT_UNKNOWN                        0
+#define    I2O_SNFORMAT_BINARY                         1
+#define    I2O_SNFORMAT_ASCII                          2
+#define    I2O_SNFORMAT_UNICODE                        3
+#define    I2O_SNFORMAT_LAN48_MAC                      4
+#define    I2O_SNFORMAT_WAN                            5
+
+/* 
+ * Plus new in v2.0 (Yellowstone pdf doc)
+ */
+
+#define    I2O_SNFORMAT_LAN64_MAC                      6
+#define    I2O_SNFORMAT_DDM                            7
+#define    I2O_SNFORMAT_IEEE_REG64                     8
+#define    I2O_SNFORMAT_IEEE_REG128                    9
+#define    I2O_SNFORMAT_UNKNOWN2                       0xff
+
+/*
+ *	I2O Get Status State values 
+ */
+
+#define	ADAPTER_STATE_INITIALIZING		0x01
+#define	ADAPTER_STATE_RESET			0x02
+#define	ADAPTER_STATE_HOLD			0x04
+#define 	ADAPTER_STATE_READY			0x05
+#define	ADAPTER_STATE_OPERATIONAL		0x08
+#define	ADAPTER_STATE_FAILED			0x10
+#define	ADAPTER_STATE_FAULTED			0x11
+	
+#endif /* _I2O_DEV_H */
--- /dev/null	Sat Apr 14 07:06:21 2001
+++ linux/drivers/scsi/dpti_i2o.h	Wed Jul 18 14:31:28 2001
@@ -0,0 +1,660 @@
+#ifndef _I2O_H
+#define _I2O_H
+/* I2O kernel space accessible structures/APIs
+ *
+ * (c) Copyright 1999, 2000 Red Hat Software
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ *************************************************************************
+ *
+ * This header file defined the I2O APIs/structures for use by
+ * the I2O kernel modules.
+ *
+ */
+
+#ifdef __KERNEL__       /* This file to be included by kernel only */
+
+#include "dpti_i2o-dev.h"
+
+#include <asm/semaphore.h> /* Needed for MUTEX init macros */
+#include <linux/config.h>
+#include <linux/notifier.h>
+#include <asm/atomic.h>
+
+
+/*
+ *	Tunable parameters first
+ */
+
+/* How many different OSM's are we allowing */ 
+#define MAX_I2O_MODULES		64
+
+#define I2O_EVT_CAPABILITY_OTHER		0x01
+#define I2O_EVT_CAPABILITY_CHANGED		0x02
+
+#define I2O_EVT_SENSOR_STATE_CHANGED		0x01
+
+//#ifdef __KERNEL__   /* ioctl stuff only thing exported to users */
+
+#define I2O_MAX_MANAGERS	4
+
+#include <asm/semaphore.h> /* Needed for MUTEX init macros */
+
+/*
+ *	I2O Interface Objects
+ */
+
+#include <linux/config.h>
+#include <linux/notifier.h>
+#include <asm/atomic.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+
+#define DECLARE_MUTEX(name) struct semaphore name=MUTEX
+
+typedef struct wait_queue *adpt_wait_queue_head_t;
+#define ADPT_DECLARE_WAIT_QUEUE_HEAD(wait) adpt_wait_queue_head_t wait = NULL
+typedef struct wait_queue adpt_wait_queue_t;
+#else
+
+#include <linux/wait.h>
+typedef wait_queue_head_t adpt_wait_queue_head_t;
+#define ADPT_DECLARE_WAIT_QUEUE_HEAD(wait) DECLARE_WAIT_QUEUE_HEAD(wait)
+typedef wait_queue_t adpt_wait_queue_t;
+
+#endif
+/*
+ * message structures
+ */
+
+struct i2o_message
+{
+	u8	version_offset;
+	u8	flags;
+	u16	size;
+	u32	target_tid:12;
+	u32	init_tid:12;
+	u32	function:8;	
+	u32	initiator_context;
+	/* List follows */
+};
+
+/*
+ *	Each I2O device entity has one or more of these. There is one
+ *	per device. *FIXME* how to handle multiple types on one unit.
+ */
+ 
+struct i2o_device
+{
+	i2o_lct_entry lct_data;/* Device LCT information */
+	u32 flags;		
+	int i2oversion;		/* I2O version supported. Actually there
+				 * should be high and low version */
+
+	struct proc_dir_entry* proc_entry;	/* /proc dir */
+
+	/* Primary user */
+	struct i2o_handler *owner;
+
+	/* Management users */
+	struct i2o_handler *managers[I2O_MAX_MANAGERS];		
+	int num_managers;
+
+	struct i2o_controller *controller;	/* Controlling IOP */
+	struct i2o_device *next;	/* Chain */
+	struct i2o_device *prev;
+	char dev_name[8];		/* linux /dev name if available */
+};
+
+/*
+ *	Resource data for each PCI I2O controller
+ */	 	
+struct i2o_pci
+{
+	int irq;
+#ifdef CONFIG_MTRR
+	int mtrr_reg0;
+	int mtrr_reg1;
+#endif
+};
+
+
+/*
+ *	Each I2O controller has one of these objects
+ */
+ 
+struct i2o_controller
+{
+	char name[16];
+	int unit;
+	int type;
+	int enabled;
+
+#define I2O_TYPE_PCI		0x01		/* PCI I2O controller */	
+
+	struct notifier_block *event_notifer;	/* Events */
+	atomic_t users;
+	struct i2o_device *devices;		/* I2O device chain */
+	struct i2o_controller *next;		/* Controller chain */
+	volatile u32 *post_port;		/* Messaging ports */
+	volatile u32 *reply_port;
+	volatile u32 *irq_mask;			/* Interrupt port */
+
+        /* Dynamic LCT related data */
+        struct semaphore lct_sem;
+        int lct_pid;
+        int lct_running;
+
+	i2o_status_block *status_block;		/* IOP status block */
+	i2o_lct *lct;				/* Logical Config Table */
+	i2o_lct *dlct;				/* Temp LCT */
+	i2o_hrt *hrt;
+
+	u32 mem_offset;				/* MFA offset */
+	u32 mem_phys;				/* MFA physical */
+
+	u32 priv_mem;
+	u32 priv_mem_size;
+	u32 priv_io;
+	u32 priv_io_size;
+
+	struct proc_dir_entry* proc_entry;	/* /proc dir */
+
+	union
+	{					/* Bus information */
+		struct i2o_pci pci;
+	} bus;
+	/* Bus specific destructor */
+	void (*destructor)(struct i2o_controller *);		
+	/* Bus specific attach/detach */
+	int (*bind)(struct i2o_controller *, struct i2o_device *);	
+	/* Bus specific initiator */
+	int (*unbind)(struct i2o_controller *, struct i2o_device *);
+	/* Bus specific enable/disable */
+	void (*bus_enable)(struct i2o_controller *c);
+	void (*bus_disable)(struct i2o_controller *c);
+
+	void *page_frame;		/* Message buffers */
+	int inbound_size;		/* Inbound queue size */
+};
+
+struct i2o_handler
+{
+        /* Message reply handler */
+
+	void (*reply)(struct i2o_handler *, struct i2o_controller *, struct i2o_message *);
+
+        /* New device notification handler */
+        void (*new_dev_notify)(struct i2o_controller *, struct i2o_device *);
+
+        /* Device deltion handler */
+        void (*dev_del_notify)(struct i2o_controller *, struct i2o_device *);
+
+        /* Reboot notification handler */
+        void (*reboot_notify)(void);
+
+	char *name;
+	int context;		/* Low 8 bits of the transaction info */
+	u32 class;			/* I2O classes that this driver handles */
+	/* User data follows */
+};
+
+#ifdef MODULE
+/*
+ * Used by bus specific modules to communicate with the core
+ *
+ * This is needed because the bus modules cannot make direct
+ * calls to the core as this results in the i2o_bus_specific_module
+ * being dependent on the core, not the otherway around.
+ * In that case, a 'modprobe i2o_lan' loads i2o_core & i2o_lan,
+ * but _not_ i2o_pci...which makes the whole thing pretty useless :)
+ *
+ */
+struct i2o_core_func_table
+{
+	int	(*install)(struct i2o_controller *);
+	int	(*activate)(struct i2o_controller *);
+	struct  i2o_controller*	(*find)(int);
+	void	(*unlock)(struct i2o_controller *);
+	void	(*run_queue)(struct i2o_controller *c);
+	int	(*delete)(struct i2o_controller *);
+};
+#endif
+
+/*
+ * I2O System table entry
+ */
+struct i2o_sys_tbl_entry
+{
+	u16	org_id;
+	u16	reserved1;
+	u32	iop_id:12;
+	u32	reserved2:20;
+	u16	seg_num:12;
+	u16 	i2o_version:4;
+	u8 	iop_state;
+	u8 	msg_type;
+	u16	frame_size;
+	u16	reserved3;
+	u32	last_changed;
+	u32	iop_capabilities;
+	u32	inbound_low;
+	u32	inbound_high;
+};
+
+struct i2o_sys_tbl
+{
+	u8 	num_entries;
+	u8 	version;
+	u16 	reserved1;
+	u32	change_ind;
+	u32	reserved2;
+	u32	reserved3;
+	struct i2o_sys_tbl_entry iops[0];
+};	
+
+/*
+ *	Messenger inlines
+ */
+extern inline u32 I2O_POST_READ32(struct i2o_controller *c)
+{
+	return *c->post_port;
+}
+
+extern inline void I2O_POST_WRITE32(struct i2o_controller *c, u32 Val)
+{
+	*c->post_port = Val;
+}
+
+
+extern inline u32 I2O_REPLY_READ32(struct i2o_controller *c)
+{
+	return *c->reply_port;
+}
+
+extern inline void I2O_REPLY_WRITE32(struct i2o_controller *c, u32 Val)
+{
+	*c->reply_port= Val;
+}
+ 
+
+extern inline u32 I2O_IRQ_READ32(struct i2o_controller *c)
+{
+	return *c->irq_mask;
+}
+
+extern inline void I2O_IRQ_WRITE32(struct i2o_controller *c, u32 Val)
+{
+	*c->irq_mask = Val;
+}
+
+
+extern inline void i2o_post_message(struct i2o_controller *c, u32 m)
+{
+	/* The second line isnt spurious - thats forcing PCI posting */
+	I2O_POST_WRITE32(c,m);
+	(void) I2O_IRQ_READ32(c);
+}
+
+extern inline void i2o_flush_reply(struct i2o_controller *c, u32 m)
+{
+	I2O_REPLY_WRITE32(c,m);
+}
+
+extern int i2o_install_controller(struct i2o_controller *);
+extern int i2o_delete_controller(struct i2o_controller *);
+extern void i2o_unlock_controller(struct i2o_controller *);
+extern struct i2o_controller *i2o_find_controller(int);
+extern int i2o_status_get(struct i2o_controller *);
+extern int i2o_num_controllers;
+
+extern int i2o_install_handler(struct i2o_handler *);
+extern int i2o_remove_handler(struct i2o_handler *);
+
+extern int i2o_claim_device(struct i2o_device *, struct i2o_handler *);
+extern int i2o_release_device(struct i2o_device *, struct i2o_handler *);
+extern int i2o_device_notify_on(struct i2o_device *, struct i2o_handler *);
+extern int i2o_device_notify_off(struct i2o_device *, struct i2o_handler *);
+
+extern int i2o_post_this(struct i2o_controller *, u32 *, int);
+extern int i2o_post_wait(struct i2o_controller *, u32 *, int, int);
+extern int i2o_issue_params(int, struct i2o_controller *, int, void *,
+			    int, void *, int); 
+
+extern int i2o_query_scalar(struct i2o_controller *, int, int, int, void *, int);
+extern int i2o_set_scalar(struct i2o_controller *, int, int, int, void *, int);
+
+extern int i2o_query_table(int, struct i2o_controller *, int, int, int, void *,
+			   int, void *, int);
+extern int i2o_clear_table(struct i2o_controller *, int, int); 
+extern int i2o_row_add_table(struct i2o_controller *, int, int, int, void *,
+			     int);
+extern int i2o_row_delete_table(struct i2o_controller *, int, int, int, void *,			int);
+
+extern int i2o_event_register(struct i2o_controller *, u32, u32,u32, u32); 
+extern int i2o_event_ack(struct i2o_controller *,  u32 *);
+
+extern void i2o_run_queue(struct i2o_controller *);
+extern void i2o_report_status(const char *, const char *, u32 *);
+extern void i2o_dump_message(u32 *);
+
+extern const char *i2o_get_class_name(int);
+
+
+/*
+ *	I2O classes / subclasses
+ */
+
+/*  Class ID and Code Assignments
+ *  (LCT.ClassID.Version field)
+ */
+#define    I2O_CLASS_VERSION_10                        0x00
+#define    I2O_CLASS_VERSION_11                        0x01
+
+/*  Class code names
+ *  (from v1.5 Table 6-1 Class Code Assignments.)
+ */
+ 
+#define    I2O_CLASS_EXECUTIVE                         0x000
+#define    I2O_CLASS_DDM                               0x001
+#define    I2O_CLASS_RANDOM_BLOCK_STORAGE              0x010
+#define    I2O_CLASS_SEQUENTIAL_STORAGE                0x011
+#define    I2O_CLASS_LAN                               0x020
+#define    I2O_CLASS_WAN                               0x030
+#define    I2O_CLASS_FIBRE_CHANNEL_PORT                0x040
+#define    I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL          0x041
+#define    I2O_CLASS_SCSI_PERIPHERAL                   0x051
+#define    I2O_CLASS_ATE_PORT                          0x060
+#define    I2O_CLASS_ATE_PERIPHERAL                    0x061
+#define    I2O_CLASS_FLOPPY_CONTROLLER                 0x070
+#define    I2O_CLASS_FLOPPY_DEVICE                     0x071
+#define    I2O_CLASS_BUS_ADAPTER_PORT                  0x080
+#define    I2O_CLASS_PEER_TRANSPORT_AGENT              0x090
+#define    I2O_CLASS_PEER_TRANSPORT                    0x091
+
+/*  Rest of 0x092 - 0x09f reserved for peer-to-peer classes
+ */
+ 
+#define    I2O_CLASS_MATCH_ANYCLASS                    0xffffffff
+
+/*  Subclasses
+ */
+
+#define    I2O_SUBCLASS_i960                           0x001
+#define    I2O_SUBCLASS_HDM                            0x020
+#define    I2O_SUBCLASS_ISM                            0x021
+ 
+/* Operation functions */
+
+#define I2O_PARAMS_FIELD_GET	0x0001
+#define I2O_PARAMS_LIST_GET	0x0002
+#define I2O_PARAMS_MORE_GET	0x0003
+#define I2O_PARAMS_SIZE_GET	0x0004
+#define I2O_PARAMS_TABLE_GET	0x0005
+#define I2O_PARAMS_FIELD_SET	0x0006
+#define I2O_PARAMS_LIST_SET	0x0007
+#define I2O_PARAMS_ROW_ADD	0x0008
+#define I2O_PARAMS_ROW_DELETE	0x0009
+#define I2O_PARAMS_TABLE_CLEAR	0x000A
+
+/*
+ *	I2O serial number conventions / formats
+ *	(circa v1.5)
+ */
+
+#define    I2O_SNFORMAT_UNKNOWN                        0
+#define    I2O_SNFORMAT_BINARY                         1
+#define    I2O_SNFORMAT_ASCII                          2
+#define    I2O_SNFORMAT_UNICODE                        3
+#define    I2O_SNFORMAT_LAN48_MAC                      4
+#define    I2O_SNFORMAT_WAN                            5
+
+/* Plus new in v2.0 (Yellowstone pdf doc)
+ */
+
+#define    I2O_SNFORMAT_LAN64_MAC                      6
+#define    I2O_SNFORMAT_DDM                            7
+#define    I2O_SNFORMAT_IEEE_REG64                     8
+#define    I2O_SNFORMAT_IEEE_REG128                    9
+#define    I2O_SNFORMAT_UNKNOWN2                       0xff
+
+/* Transaction Reply Lists (TRL) Control Word structure */
+
+#define TRL_SINGLE_FIXED_LENGTH		0x00
+#define TRL_SINGLE_VARIABLE_LENGTH	0x40
+#define TRL_MULTIPLE_FIXED_LENGTH	0x80
+
+/*
+ *	Messaging API values
+ */
+ 
+#define	I2O_CMD_ADAPTER_ASSIGN		0xB3
+#define	I2O_CMD_ADAPTER_READ		0xB2
+#define	I2O_CMD_ADAPTER_RELEASE		0xB5
+#define	I2O_CMD_BIOS_INFO_SET		0xA5
+#define	I2O_CMD_BOOT_DEVICE_SET		0xA7
+#define	I2O_CMD_CONFIG_VALIDATE		0xBB
+#define	I2O_CMD_CONN_SETUP		0xCA
+#define	I2O_CMD_DDM_DESTROY		0xB1
+#define	I2O_CMD_DDM_ENABLE		0xD5
+#define	I2O_CMD_DDM_QUIESCE		0xC7
+#define	I2O_CMD_DDM_RESET		0xD9
+#define	I2O_CMD_DDM_SUSPEND		0xAF
+#define	I2O_CMD_DEVICE_ASSIGN		0xB7
+#define	I2O_CMD_DEVICE_RELEASE		0xB9
+#define	I2O_CMD_HRT_GET			0xA8
+#define	I2O_CMD_ADAPTER_CLEAR		0xBE
+#define	I2O_CMD_ADAPTER_CONNECT		0xC9
+#define	I2O_CMD_ADAPTER_RESET		0xBD
+#define	I2O_CMD_LCT_NOTIFY		0xA2
+#define	I2O_CMD_OUTBOUND_INIT		0xA1
+#define	I2O_CMD_PATH_ENABLE		0xD3
+#define	I2O_CMD_PATH_QUIESCE		0xC5
+#define	I2O_CMD_PATH_RESET		0xD7
+#define	I2O_CMD_STATIC_MF_CREATE	0xDD
+#define	I2O_CMD_STATIC_MF_RELEASE	0xDF
+#define	I2O_CMD_STATUS_GET		0xA0
+#define	I2O_CMD_SW_DOWNLOAD		0xA9
+#define	I2O_CMD_SW_UPLOAD		0xAB
+#define	I2O_CMD_SW_REMOVE		0xAD
+#define	I2O_CMD_SYS_ENABLE		0xD1
+#define	I2O_CMD_SYS_MODIFY		0xC1
+#define	I2O_CMD_SYS_QUIESCE		0xC3
+#define	I2O_CMD_SYS_TAB_SET		0xA3
+
+#define I2O_CMD_UTIL_NOP		0x00
+#define I2O_CMD_UTIL_ABORT		0x01
+#define I2O_CMD_UTIL_CLAIM		0x09
+#define I2O_CMD_UTIL_RELEASE		0x0B
+#define I2O_CMD_UTIL_PARAMS_GET		0x06
+#define I2O_CMD_UTIL_PARAMS_SET		0x05
+#define I2O_CMD_UTIL_EVT_REGISTER	0x13
+#define I2O_CMD_UTIL_EVT_ACK		0x14
+#define I2O_CMD_UTIL_CONFIG_DIALOG	0x10
+#define I2O_CMD_UTIL_DEVICE_RESERVE	0x0D
+#define I2O_CMD_UTIL_DEVICE_RELEASE	0x0F
+#define I2O_CMD_UTIL_LOCK		0x17
+#define I2O_CMD_UTIL_LOCK_RELEASE	0x19
+#define I2O_CMD_UTIL_REPLY_FAULT_NOTIFY	0x15
+
+#define I2O_CMD_SCSI_EXEC		0x81
+#define I2O_CMD_SCSI_ABORT		0x83
+#define I2O_CMD_SCSI_BUSRESET		0x27
+
+#define I2O_CMD_BLOCK_READ		0x30
+#define I2O_CMD_BLOCK_WRITE		0x31
+#define I2O_CMD_BLOCK_CFLUSH		0x37
+#define I2O_CMD_BLOCK_MLOCK		0x49
+#define I2O_CMD_BLOCK_MUNLOCK		0x4B
+#define I2O_CMD_BLOCK_MMOUNT		0x41
+#define I2O_CMD_BLOCK_MEJECT		0x43
+
+#define I2O_PRIVATE_MSG			0xFF
+
+/*
+ *	Init Outbound Q status 
+ */
+ 
+#define I2O_CMD_OUTBOUND_INIT_IN_PROGRESS	0x01
+#define I2O_CMD_OUTBOUND_INIT_REJECTED		0x02
+#define I2O_CMD_OUTBOUND_INIT_FAILED		0x03
+#define I2O_CMD_OUTBOUND_INIT_COMPLETE		0x04
+
+/*
+ *	I2O Get Status State values 
+ */
+
+#define	ADAPTER_STATE_INITIALIZING		0x01
+#define	ADAPTER_STATE_RESET			0x02
+#define	ADAPTER_STATE_HOLD			0x04
+#define ADAPTER_STATE_READY			0x05
+#define	ADAPTER_STATE_OPERATIONAL		0x08
+#define	ADAPTER_STATE_FAILED			0x10
+#define	ADAPTER_STATE_FAULTED			0x11
+	
+/* I2O API function return values */
+
+#define I2O_RTN_NO_ERROR			0
+#define I2O_RTN_NOT_INIT			1
+#define I2O_RTN_FREE_Q_EMPTY			2
+#define I2O_RTN_TCB_ERROR			3
+#define I2O_RTN_TRANSACTION_ERROR		4
+#define I2O_RTN_ADAPTER_ALREADY_INIT		5
+#define I2O_RTN_MALLOC_ERROR			6
+#define I2O_RTN_ADPTR_NOT_REGISTERED		7
+#define I2O_RTN_MSG_REPLY_TIMEOUT		8
+#define I2O_RTN_NO_STATUS			9
+#define I2O_RTN_NO_FIRM_VER			10
+#define	I2O_RTN_NO_LINK_SPEED			11
+
+/* Reply message status defines for all messages */
+
+#define I2O_REPLY_STATUS_SUCCESS                    	0x00
+#define I2O_REPLY_STATUS_ABORT_DIRTY                	0x01
+#define I2O_REPLY_STATUS_ABORT_NO_DATA_TRANSFER     	0x02
+#define	I2O_REPLY_STATUS_ABORT_PARTIAL_TRANSFER		0x03
+#define	I2O_REPLY_STATUS_ERROR_DIRTY			0x04
+#define	I2O_REPLY_STATUS_ERROR_NO_DATA_TRANSFER		0x05
+#define	I2O_REPLY_STATUS_ERROR_PARTIAL_TRANSFER		0x06
+#define	I2O_REPLY_STATUS_PROCESS_ABORT_DIRTY		0x08
+#define	I2O_REPLY_STATUS_PROCESS_ABORT_NO_DATA_TRANSFER	0x09
+#define	I2O_REPLY_STATUS_PROCESS_ABORT_PARTIAL_TRANSFER	0x0A
+#define	I2O_REPLY_STATUS_TRANSACTION_ERROR		0x0B
+#define	I2O_REPLY_STATUS_PROGRESS_REPORT		0x80
+
+/* Status codes and Error Information for Parameter functions */
+
+#define I2O_PARAMS_STATUS_SUCCESS		0x00
+#define I2O_PARAMS_STATUS_BAD_KEY_ABORT		0x01
+#define I2O_PARAMS_STATUS_BAD_KEY_CONTINUE   	0x02
+#define I2O_PARAMS_STATUS_BUFFER_FULL		0x03
+#define I2O_PARAMS_STATUS_BUFFER_TOO_SMALL	0x04
+#define I2O_PARAMS_STATUS_FIELD_UNREADABLE	0x05
+#define I2O_PARAMS_STATUS_FIELD_UNWRITEABLE	0x06
+#define I2O_PARAMS_STATUS_INSUFFICIENT_FIELDS	0x07
+#define I2O_PARAMS_STATUS_INVALID_GROUP_ID	0x08
+#define I2O_PARAMS_STATUS_INVALID_OPERATION	0x09
+#define I2O_PARAMS_STATUS_NO_KEY_FIELD		0x0A
+#define I2O_PARAMS_STATUS_NO_SUCH_FIELD		0x0B
+#define I2O_PARAMS_STATUS_NON_DYNAMIC_GROUP	0x0C
+#define I2O_PARAMS_STATUS_OPERATION_ERROR	0x0D
+#define I2O_PARAMS_STATUS_SCALAR_ERROR		0x0E
+#define I2O_PARAMS_STATUS_TABLE_ERROR		0x0F
+#define I2O_PARAMS_STATUS_WRONG_GROUP_TYPE	0x10
+
+/* DetailedStatusCode defines for Executive, DDM, Util and Transaction error
+ * messages: Table 3-2 Detailed Status Codes.*/
+
+#define I2O_DSC_SUCCESS                        0x0000
+#define I2O_DSC_BAD_KEY                        0x0002
+#define I2O_DSC_TCL_ERROR                      0x0003
+#define I2O_DSC_REPLY_BUFFER_FULL              0x0004
+#define I2O_DSC_NO_SUCH_PAGE                   0x0005
+#define I2O_DSC_INSUFFICIENT_RESOURCE_SOFT     0x0006
+#define I2O_DSC_INSUFFICIENT_RESOURCE_HARD     0x0007
+#define I2O_DSC_CHAIN_BUFFER_TOO_LARGE         0x0009
+#define I2O_DSC_UNSUPPORTED_FUNCTION           0x000A
+#define I2O_DSC_DEVICE_LOCKED                  0x000B
+#define I2O_DSC_DEVICE_RESET                   0x000C
+#define I2O_DSC_INAPPROPRIATE_FUNCTION         0x000D
+#define I2O_DSC_INVALID_INITIATOR_ADDRESS      0x000E
+#define I2O_DSC_INVALID_MESSAGE_FLAGS          0x000F
+#define I2O_DSC_INVALID_OFFSET                 0x0010
+#define I2O_DSC_INVALID_PARAMETER              0x0011
+#define I2O_DSC_INVALID_REQUEST                0x0012
+#define I2O_DSC_INVALID_TARGET_ADDRESS         0x0013
+#define I2O_DSC_MESSAGE_TOO_LARGE              0x0014
+#define I2O_DSC_MESSAGE_TOO_SMALL              0x0015
+#define I2O_DSC_MISSING_PARAMETER              0x0016
+#define I2O_DSC_TIMEOUT                        0x0017
+#define I2O_DSC_UNKNOWN_ERROR                  0x0018
+#define I2O_DSC_UNKNOWN_FUNCTION               0x0019
+#define I2O_DSC_UNSUPPORTED_VERSION            0x001A
+#define I2O_DSC_DEVICE_BUSY                    0x001B
+#define I2O_DSC_DEVICE_NOT_AVAILABLE           0x001C
+
+/* Device Claim Types */
+#define	I2O_CLAIM_PRIMARY					0x01000000
+#define	I2O_CLAIM_MANAGEMENT					0x02000000
+#define	I2O_CLAIM_AUTHORIZED					0x03000000
+#define	I2O_CLAIM_SECONDARY					0x04000000
+ 
+/* Message header defines for VersionOffset */
+#define I2OVER15	0x0001
+#define I2OVER20	0x0002
+/* Default is 1.5, FIXME: Need support for both 1.5 and 2.0 */
+#define I2OVERSION	I2OVER15
+#define SGL_OFFSET_0    I2OVERSION
+#define SGL_OFFSET_4    (0x0040 | I2OVERSION)
+#define SGL_OFFSET_5    (0x0050 | I2OVERSION)
+#define SGL_OFFSET_6    (0x0060 | I2OVERSION)
+#define SGL_OFFSET_7    (0x0070 | I2OVERSION)
+#define SGL_OFFSET_8    (0x0080 | I2OVERSION)
+#define SGL_OFFSET_9    (0x0090 | I2OVERSION)
+#define SGL_OFFSET_10   (0x00A0 | I2OVERSION)
+#define SGL_OFFSET_12   (0x00C0 | I2OVERSION)
+
+#define TRL_OFFSET_5    (0x0050 | I2OVERSION)
+#define TRL_OFFSET_6    (0x0060 | I2OVERSION)
+
+ /* msg header defines for MsgFlags */
+#define MSG_STATIC	0x0100
+#define MSG_64BIT_CNTXT	0x0200
+#define MSG_MULTI_TRANS	0x1000
+#define MSG_FAIL	0x2000
+#define MSG_LAST	0x4000
+#define MSG_REPLY	0x8000
+
+ /* minimum size msg */
+#define THREE_WORD_MSG_SIZE	0x00030000
+#define FOUR_WORD_MSG_SIZE	0x00040000
+#define FIVE_WORD_MSG_SIZE	0x00050000
+#define SIX_WORD_MSG_SIZE	0x00060000
+#define SEVEN_WORD_MSG_SIZE	0x00070000
+#define EIGHT_WORD_MSG_SIZE	0x00080000
+#define NINE_WORD_MSG_SIZE	0x00090000
+#define TEN_WORD_MSG_SIZE	0x000A0000
+#define I2O_MESSAGE_SIZE(x)	((x)<<16)
+
+
+/* Special TID Assignments */
+
+#define ADAPTER_TID		0
+#define HOST_TID		1
+
+#define MSG_FRAME_SIZE		128
+#define NMBR_MSG_FRAMES		128
+
+#define MSG_POOL_SIZE		16384
+
+#define I2O_POST_WAIT_OK	0
+#define I2O_POST_WAIT_TIMEOUT	-ETIMEDOUT
+
+
+#endif /* __KERNEL__ */
+
+#endif /* _I2O_H */
--- /usr/src/linux-orig/drivers/scsi/Makefile	Sun Mar 25 11:37:35 2001
+++ linux/drivers/scsi/Makefile	Fri May  4 12:08:56 2001
@@ -407,6 +407,14 @@
   endif
 endif
 
+ifeq ($(CONFIG_SCSI_DPT_I2O),y)
+L_OBJS += dpt_i2o.o
+else
+  ifeq ($(CONFIG_SCSI_DPT_I2O),m)
+  M_OBJS += dpt_i2o.o
+  endif
+endif
+
 ifeq ($(CONFIG_SCSI_EATA_DMA),y)
 L_OBJS += eata_dma.o
 else
@@ -748,4 +756,7 @@
 
 sd_mod.o: sd.o sd_ioctl.o
 	$(LD) $(LD_RFLAG) -r -o $@ sd.o sd_ioctl.o
+
+dpt_i2o.o: dpti.c
+	$(CC) $(CFLAGS) -c dpti.c -o dpt_i2o.o
 
--- /usr/src/linux-orig/drivers/scsi/Config.in	Sun Mar 25 11:37:35 2001
+++ linux/drivers/scsi/Config.in	Fri May  4 12:09:23 2001
@@ -33,6 +33,7 @@
     int  '   Maximum number of TCQ commands per device' CONFIG_AIC7XXX_CMDS_PER_DEVICE 24
     bool '   Collect statistics to report in /proc' CONFIG_AIC7XXX_PROC_STATS
 fi
+dep_tristate 'Adaptec I2O RAID support ' CONFIG_SCSI_DPT_I2O $CONFIG_SCSI
 dep_tristate 'IBM ServeRAID support' CONFIG_SCSI_IPS $CONFIG_SCSI
 dep_tristate 'AdvanSys SCSI support' CONFIG_SCSI_ADVANSYS $CONFIG_SCSI
 dep_tristate 'Always IN2000 SCSI support' CONFIG_SCSI_IN2000 $CONFIG_SCSI
--- /usr/src/linux-orig/drivers/scsi/hosts.c	Sun Mar 25 11:37:36 2001
+++ linux/drivers/scsi/hosts.c	Fri May  4 12:10:24 2001
@@ -147,6 +147,10 @@
 #include "BusLogic.h"
 #endif
 
+#ifdef CONFIG_SCSI_DPT_I2O
+#include "dpti.h"
+#endif
+
 #ifdef CONFIG_SCSI_EATA_DMA
 #include "eata_dma.h"
 #endif
@@ -549,6 +553,9 @@
 #endif
 #ifdef CONFIG_SCSI_NCR53C8XX
     NCR53C8XX,
+#endif
+#ifdef CONFIG_SCSI_DPT_I2O
+    DPT_I2O,
 #endif
 #ifdef CONFIG_SCSI_EATA_DMA
     EATA_DMA,
