diff -uNr linux-2.6.16.orig/Documentation/cciss.txt linux-2.6.16/Documentation/cciss.txt
--- linux-2.6.16.orig/Documentation/cciss.txt	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/Documentation/cciss.txt	2008-10-03 02:40:19.000000000 +0200
@@ -16,10 +16,16 @@
 	* SA 6i
 	* SA P600
 	* SA P800
-	* SA E400
+	* SA P400
 	* SA P400i
 	* SA E200
 	* SA E200i
+	* SA E500
+
+This driver also implements a new method of detecting HP Smart Array 
+controllers. If an "unknown" controller is detected, we will attempt to
+bind to the controller. On success a message is displayed informing the
+user to upgrade the driver. On failure we bail.
 
 If nodes are not already created in the /dev/cciss directory, run as root:
 
@@ -36,8 +42,8 @@
 Major numbers:
 	104	cciss0	
 	105	cciss1	
-	106	cciss2
-	105	cciss3
+	106	cciss2 
+	107	cciss3
 	108	cciss4
 	109	cciss5
 	110	cciss6
@@ -79,7 +85,7 @@
 the SCSI core may not yet be initialized (because the driver is a block 
 driver) and attempting to register it with the SCSI core in such a case 
 would cause a hang.  This is best done via an initialization script 
-(typically in /etc/init.d, but could vary depending on distibution). 
+(typically in /etc/init.d, but could vary depending on distribution).
 For example:
 
 	for x in /proc/driver/cciss/cciss[0-9]*
@@ -145,18 +151,18 @@
 If that doesn't work, the SCSI bus is reset.  If that doesn't work
 the host bus adapter is reset.  Because the cciss driver is a block
 driver as well as a SCSI driver and only the tape drives and medium
-changers are presented to the SCSI mid layer, and unlike more 
+changers are presented to the SCSI mid layer, and unlike more
 straightforward SCSI drivers, disk i/o continues through the block
 side during the SCSI error recovery process, the cciss driver only
 implements the first two of these actions, aborting the command, and
-resetting the device.  Additionally, most tape drives will not oblige 
-in aborting commands, and sometimes it appears they will not even 
-obey a reset coommand, though in most circumstances they will.  In
-the case that the command cannot be aborted and the device cannot be 
+resetting the device.  Additionally, most tape drives will not oblige
+in aborting commands, and sometimes it appears they will not even
+obey a reset command, though in most circumstances they will.  In
+the case that the command cannot be aborted and the device cannot be
 reset, the device will be set offline.
 
 In the event the error handling code is triggered and a tape drive is
-successfully reset or the tardy command is successfully aborted, the 
+successfully reset or the tardy command is successfully aborted, the
 tape drive may still not allow i/o to continue until some command
 is issued which positions the tape to a known position.  Typically you
 must rewind the tape (by issuing "mt -f /dev/st0 rewind" for example)
diff -uNr linux-2.6.16.orig/drivers/block/cciss.c linux-2.6.16/drivers/block/cciss.c
--- linux-2.6.16.orig/drivers/block/cciss.c	2008-11-02 19:51:53.000000000 +0100
+++ linux-2.6.16/drivers/block/cciss.c	2008-10-03 02:40:19.000000000 +0200
@@ -33,6 +33,7 @@
 #include <linux/bio.h>
 #include <linux/blkpg.h>
 #include <linux/timer.h>
+#include <linux/seq_file.h>
 #include <linux/proc_fs.h>
 #include <linux/init.h> 
 #include <linux/hdreg.h>
@@ -40,111 +41,121 @@
 #include <linux/compat.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
+#include <asm/div64.h>
+
+#ifdef CONFIG_BLK_DEV_IO_TRACE
+#include <linux/blktrace_api.h>
+#endif
 
 #include <linux/dma-mapping.h>
 #include <linux/blkdev.h>
 #include <linux/genhd.h>
 #include <linux/completion.h>
+#include <scsi/scsi.h>
+#include <scsi/sg.h>
+#include <scsi/scsi_ioctl.h>
+#include <linux/cdrom.h>
 
 #define CCISS_DRIVER_VERSION(maj,min,submin) ((maj<<16)|(min<<8)|(submin))
-#define DRIVER_NAME "HP CISS Driver (v 2.6.10)"
-#define DRIVER_VERSION CCISS_DRIVER_VERSION(2,6,10)
+#define DRIVER_NAME "HP CISS Driver (v 3.6.18)"
+#define DRIVER_VERSION CCISS_DRIVER_VERSION(3,6,18)
 
 /* Embedded module documentation macros - see modules.h */
 MODULE_AUTHOR("Hewlett-Packard Company");
-MODULE_DESCRIPTION("Driver for HP Controller SA5xxx SA6xxx version 2.6.10");
+MODULE_DESCRIPTION("Driver for HP Controller SA5xxx SA6xxx version 3.6.18");
 MODULE_SUPPORTED_DEVICE("HP SA5i SA5i+ SA532 SA5300 SA5312 SA641 SA642 SA6400"
-			" SA6i P600 P800 P400 P400i E200 E200i");
+			" SA6i P600 P800 P400 P400i E200 E200i E500");
 MODULE_LICENSE("GPL");
 
 #include "cciss_cmd.h"
 #include "cciss.h"
 #include <linux/cciss_ioctl.h>
 
+#ifndef PCI_DEVICE_ID_COMPAQ_CISSC
+#define PCI_DEVICE_ID_COMPAQ_CISSC 0x46
+#endif
+#ifndef PCI_DEVICE_ID_HP_CISS
+#define PCI_DEVICE_ID_HP_CISS 0x3210
+#endif
+#ifndef PCI_DEVICE_ID_HP_CISSA
+#define PCI_DEVICE_ID_HP_CISSA 0x3220
+#endif
+#ifndef PCI_DEVICE_ID_HP_CISSC
+#define PCI_DEVICE_ID_HP_CISSC 0x3230
+#endif
+#ifndef PCI_DEVICE_ID_HP_CISSD
+#define PCI_DEVICE_ID_HP_CISSD 0x3238
+#endif
 /* define the PCI info for the cards we can control */
 static const struct pci_device_id cciss_pci_device_id[] = {
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISS,
-			0x0E11, 0x4070, 0, 0, 0},
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSB,
-                        0x0E11, 0x4080, 0, 0, 0},
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSB,
-                        0x0E11, 0x4082, 0, 0, 0},
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSB,
-                        0x0E11, 0x4083, 0, 0, 0},
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC,
-		0x0E11, 0x409A, 0, 0, 0},
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC,
-		0x0E11, 0x409B, 0, 0, 0},
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC,
-		0x0E11, 0x409C, 0, 0, 0},
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC,
-		0x0E11, 0x409D, 0, 0, 0},
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC,
-		0x0E11, 0x4091, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSA,
-		0x103C, 0x3225, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSC,
-		0x103c, 0x3223, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSC,
-		0x103c, 0x3234, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSC,
-		0x103c, 0x3235, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSD,
-		0x103c, 0x3211, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSD,
-		0x103c, 0x3212, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSD,
-		0x103c, 0x3213, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSD,
-		0x103c, 0x3214, 0, 0, 0},
-	{ PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_CISSD,
-		0x103c, 0x3215, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISS,  0x0E11, 0x4070},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSB, 0x0E11, 0x4080},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSB, 0x0E11, 0x4082},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSB, 0x0E11, 0x4083},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC, 0x0E11, 0x409A},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC, 0x0E11, 0x409B},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC, 0x0E11, 0x409C},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC, 0x0E11, 0x409D},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC, 0x0E11, 0x4091},
+	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISSC, 0x0E11, 0x409E},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSA,     0x103C, 0x3225},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSC,     0x103c, 0x3234},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSC,     0x103c, 0x3235},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSD,     0x103c, 0x3211},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSD,     0x103c, 0x3212},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSD,     0x103c, 0x3213},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSD,     0x103c, 0x3214},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSD,     0x103c, 0x3215},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSC,     0x103C, 0x3223},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSC,     0x103c, 0x3237},
+	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSC,     0x103C, 0x323D},
+	{PCI_VENDOR_ID_HP, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_STORAGE_RAID << 8, 0xffff << 8, 0},
 	{0,}
 };
 MODULE_DEVICE_TABLE(pci, cciss_pci_device_id);
 
-#define NR_PRODUCTS ARRAY_SIZE(products)
-
 /*  board_id = Subsystem Device ID & Vendor ID
  *  product = Marketing Name for the board
  *  access = Address of the struct of function pointers 
+ *  nr_cmds = Number of commands supported by controller
  */
 static struct board_type products[] = {
-	{ 0x40700E11, "Smart Array 5300", &SA5_access },
-	{ 0x40800E11, "Smart Array 5i", &SA5B_access},
-	{ 0x40820E11, "Smart Array 532", &SA5B_access},
-	{ 0x40830E11, "Smart Array 5312", &SA5B_access},
-	{ 0x409A0E11, "Smart Array 641", &SA5_access},
-	{ 0x409B0E11, "Smart Array 642", &SA5_access},
-	{ 0x409C0E11, "Smart Array 6400", &SA5_access},
-	{ 0x409D0E11, "Smart Array 6400 EM", &SA5_access},
-	{ 0x40910E11, "Smart Array 6i", &SA5_access},
-	{ 0x3225103C, "Smart Array P600", &SA5_access},
-	{ 0x3223103C, "Smart Array P800", &SA5_access},
-	{ 0x3234103C, "Smart Array P400", &SA5_access},
-	{ 0x3235103C, "Smart Array P400i", &SA5_access},
-	{ 0x3211103C, "Smart Array E200i", &SA5_access},
-	{ 0x3212103C, "Smart Array E200", &SA5_access},
-	{ 0x3213103C, "Smart Array E200i", &SA5_access},
-	{ 0x3214103C, "Smart Array E200i", &SA5_access},
-	{ 0x3215103C, "Smart Array E200i", &SA5_access},
+	{ 0x40700E11, "Smart Array 5300", &SA5_access, 384},
+	{ 0x40800E11, "Smart Array 5i", &SA5B_access, 384},
+	{ 0x40820E11, "Smart Array 532", &SA5B_access, 384},
+	{ 0x40830E11, "Smart Array 5312", &SA5B_access, 384},
+	{ 0x409A0E11, "Smart Array 641", &SA5_access, 384},
+	{ 0x409B0E11, "Smart Array 642", &SA5_access, 384},
+	{ 0x409C0E11, "Smart Array 6400", &SA5_access, 384},
+	{ 0x409D0E11, "Smart Array 6400 EM", &SA5_access, 384},
+	{ 0x40910E11, "Smart Array 6i", &SA5_access, 384},
+	{ 0x409E0E11, "Smart Array 6422", &SA5_access, 384},
+	{ 0x3225103C, "Smart Array P600", &SA5_access, 384},
+	{ 0x3234103C, "Smart Array P400", &SA5_access, 512},
+	{ 0x3235103C, "Smart Array P400i", &SA5_access, 512},
+	{ 0x3211103C, "Smart Array E200i", &SA5_access,120},
+	{ 0x3212103C, "Smart Array E200", &SA5_access,120},
+	{ 0x3213103C, "Smart Array E200i", &SA5_access,120},
+	{ 0x3214103C, "Smart Array E200i", &SA5_access, 120},
+	{ 0x3215103C, "Smart Array E200i", &SA5_access, 120},
+	{ 0x3223103C, "Smart Array P800", &SA5_access, 512},
+	{ 0x3237103C, "Smart Array E500", &SA5_access, 128},
+	{ 0x323D103C, "Smart Array P700m", &SA5_access, 512},
+	{ 0xFFFF103C, "Unknown Smart Array", &SA5_access, 120},
 };
 
-/* How long to wait (in millesconds) for board to go into simple mode */
+/* How long to wait (in millisconds) for board to go into simple mode */
 #define MAX_CONFIG_WAIT 30000 
 #define MAX_IOCTL_CONFIG_WAIT 1000
 
 /*define how many times we will try a command because of bus resets */
 #define MAX_CMD_RETRIES 3
-
-#define READ_AHEAD 	 1024
-#define NR_CMDS		 384 /* #commands that can be outstanding */
 #define MAX_CTLR	32
 
 /* Originally cciss driver only supports 8 major numbers */
 #define MAX_CTLR_ORIG 	8
 
-
 static ctlr_info_t *hba[MAX_CTLR];
 
 static void do_cciss_request(request_queue_t *q);
@@ -155,35 +166,40 @@
 		unsigned int cmd, unsigned long arg);
 static int cciss_getgeo(struct block_device *bdev, struct hd_geometry *geo);
 
-static int revalidate_allvol(ctlr_info_t *host);
 static int cciss_revalidate(struct gendisk *disk);
 static int rebuild_lun_table(ctlr_info_t *h, struct gendisk *del_disk);
-static int deregister_disk(struct gendisk *disk, drive_info_struct *drv, int clear_all);
-
-static void cciss_read_capacity(int ctlr, int logvol, ReadCapdata_struct *buf,
-	int withirq, unsigned int *total_size, unsigned int *block_size);
+static int deregister_disk(struct gendisk *disk, drive_info_struct *drv,
+			int clear_all);
+static void cciss_read_capacity(int ctlr, int logvol, int withirq,
+			sector_t *total_size, unsigned int *block_size);
+static void cciss_read_capacity_16(int ctlr, int logvol, int withirq,
+			sector_t *total_size, unsigned int *block_size);
 static void cciss_geometry_inquiry(int ctlr, int logvol,
-			int withirq, unsigned int total_size,
+			int withirq, sector_t total_size,
 			unsigned int block_size, InquiryData_struct *inq_buff,
 			drive_info_struct *drv);
 static void cciss_getgeometry(int cntl_num);
-static void __devinit cciss_interrupt_mode(ctlr_info_t *, struct pci_dev *, __u32);
+static void __devinit cciss_interrupt_mode(ctlr_info_t *, struct pci_dev *,
+					__u32);
 static void start_io( ctlr_info_t *h);
 static int sendcmd( __u8 cmd, int ctlr, void *buff, size_t size,
-	unsigned int use_unit_num, unsigned int log_unit, __u8 page_code,
-	unsigned char *scsi3addr, int cmd_type);
+		unsigned int use_unit_num, unsigned int log_unit,
+		__u8 page_code,	unsigned char *scsi3addr, int cmd_type);
 static int sendcmd_withirq(__u8	cmd, int ctlr, void *buff, size_t size,
-	unsigned int use_unit_num, unsigned int log_unit, __u8	page_code,
-	int cmd_type);
+		unsigned int use_unit_num, unsigned int log_unit,
+		__u8	page_code, int cmd_type);
 
-static void fail_all_cmds(unsigned long ctlr);
+static void cciss_shutdown (struct pci_dev *pdev);
+static void __devexit cciss_remove_one(struct pci_dev *pdev);
 
+static void fail_all_cmds(unsigned long ctlr);
+static void print_cmd(CommandList_struct *);
 #ifdef CONFIG_PROC_FS
-static int cciss_proc_get_info(char *buffer, char **start, off_t offset, 
-		int length, int *eof, void *data);
 static void cciss_procinit(int i);
 #else
-static void cciss_procinit(int i) {}
+static void cciss_procinit(int i)
+{
+}
 #endif /* CONFIG_PROC_FS */
 
 #ifdef CONFIG_COMPAT
@@ -222,7 +238,8 @@
 						CommandList_struct *c)
 {
         if (c && c->next != c) {
-                if (*Qptr == c) *Qptr = c->next;
+                if (*Qptr == c)
+			*Qptr = c->next;
                 c->prev->next = c->next;
                 c->next->prev = c->prev;
         } else {
@@ -231,46 +248,492 @@
         return c;
 }
 
-#include "cciss_scsi.c"		/* For SCSI tape support */
+static inline int find_drv_index(int ctlr, drive_info_struct *drv){
+	int i;
+	for (i=0; i < CISS_MAX_LUN; i++) {
+		if (hba[ctlr]->drv[i].LunID == drv->LunID)
+			return i;
+	}
+	return i;
+}
 
-#ifdef CONFIG_PROC_FS
+#include "cciss_scsi.c"		/* For SCSI tape support */
 
-/*
- * Report information about this controller.
- */
 #define ENG_GIG 1000000000
 #define ENG_GIG_FACTOR (ENG_GIG/512)
 #define RAID_UNKNOWN 6
+#define ENGAGE_SCSI	"engage scsi"
+#define RESCAN_VOLUMES	"rescan volumes"
+
 static const char *raid_label[] = {"0","4","1(1+0)","5","5+1","ADG",
 	                                   "UNKNOWN"};
 
-static struct proc_dir_entry *proc_cciss;
+static spinlock_t sysfs_lock = SPIN_LOCK_UNLOCKED;
+
+static void cciss_sysfs_stat_inquiry(int ctlr, int logvol,
+			int withirq, drive_info_struct *drv)
+{
+	int return_code;
+	InquiryData_struct *inq_buff;
+
+	/* If there are no heads then this is the controller disk and
+	 * not a valid logical drive so don't query it.
+	 */
+	if (!drv->heads)
+		return;
+
+	inq_buff = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);
+	if (!inq_buff) {
+		printk(KERN_ERR "cciss: out of memory\n");
+		goto err;
+	}
+
+	if (withirq)
+		return_code = sendcmd_withirq(CISS_INQUIRY, ctlr,
+			inq_buff, sizeof(*inq_buff), 1, logvol ,0, TYPE_CMD);
+	else
+		return_code = sendcmd(CISS_INQUIRY, ctlr, inq_buff,
+			sizeof(*inq_buff), 1, logvol , 0, NULL, TYPE_CMD);
+	if (return_code == IO_OK) {
+		memcpy(drv->vendor, &inq_buff->data_byte[8], 8);
+		drv->vendor[8]='\0';
+		memcpy(drv->model, &inq_buff->data_byte[16], 16);
+		drv->model[16] = '\0';
+		memcpy(drv->rev, &inq_buff->data_byte[32], 4);
+		drv->rev[4] = '\0';
+	} else { /* Get geometry failed */
+		printk(KERN_WARNING "cciss: inquiry for VPD page 0 failed\n");
+	}
+
+	if (withirq)
+		return_code = sendcmd_withirq(CISS_INQUIRY, ctlr,
+			inq_buff, sizeof(*inq_buff), 1, logvol ,0x83, TYPE_CMD);
+	else
+		return_code = sendcmd(CISS_INQUIRY, ctlr, inq_buff,
+			sizeof(*inq_buff), 1, logvol , 0x83, NULL, TYPE_CMD);
+
+	if (return_code == IO_OK) {
+		memcpy(drv->uid, &inq_buff->data_byte[8], 16);
+	} else { /* Get geometry failed */
+		printk(KERN_WARNING "cciss: id logical drive failed\n");
+	}
+
+	kfree(inq_buff);
+err:
+	drv->vendor[8] = '\0';
+	drv->model[16] = '\0';
+	drv->rev[4] = '\0';
+
+}
 
-static int cciss_proc_get_info(char *buffer, char **start, off_t offset, 
-		int length, int *eof, void *data)
+static ssize_t cciss_show_raid_level(struct device *dev,
+				     struct device_attribute *attr, char *buf)
 {
-        off_t pos = 0;
-        off_t len = 0;
-        int size, i, ctlr;
-        ctlr_info_t *h = (ctlr_info_t*)data;
-        drive_info_struct *drv;
+	struct drv_dynamic *d;
+	drive_info_struct *drv;
+	ctlr_info_t *h;
 	unsigned long flags;
-        sector_t vol_sz, vol_sz_frac;
+	int raid;
 
-        ctlr = h->ctlr;
+	d = container_of(dev, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	if (!d->disk) {
+		spin_unlock(&sysfs_lock);
+		return -ENOENT;
+	}
 
-	/* prevent displaying bogus info during configuration
-	 * or deconfiguration of a logical volume
-	 */
-	spin_lock_irqsave(CCISS_LOCK(ctlr), flags);
+	h = get_host(d->disk);
+
+	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
 	if (h->busy_configuring) {
-		spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
-	return -EBUSY;
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return snprintf(buf, 30, "Device busy configuring\n");
 	}
-	h->busy_configuring = 1;
-	spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
 
-        size = sprintf(buffer, "%s: HP %s Controller\n"
+	drv = d->disk->private_data;
+	if ((drv->raid_level < 0) || (drv->raid_level) > 5)
+		raid = RAID_UNKNOWN;
+	else
+		raid = drv->raid_level;
+
+	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+	spin_unlock(&sysfs_lock);
+	return snprintf(buf, 20, "RAID %s\n", raid_label[raid]);
+}
+
+static ssize_t cciss_show_disk_size(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct drv_dynamic *d;
+	drive_info_struct *drv;
+	ctlr_info_t *h;
+	unsigned long flags;
+	sector_t vol_sz, vol_sz_frac;
+
+	d = container_of(dev, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	if (!d->disk) {
+		spin_unlock(&sysfs_lock);
+		return -ENOENT;
+	}
+	h = get_host(d->disk);
+
+	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
+	if (h->busy_configuring) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return snprintf(buf, 30, "Device busy configuring\n");
+	}
+
+	drv = d->disk->private_data;
+	vol_sz = drv->nr_blocks;
+	vol_sz_frac = sector_div(vol_sz, ENG_GIG_FACTOR);
+	vol_sz_frac *= 100;
+	sector_div(vol_sz_frac, ENG_GIG_FACTOR);
+
+	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+	spin_unlock(&sysfs_lock);
+	return snprintf(buf, 30, "%4u.%02uGB\n", (int)vol_sz, (int)vol_sz_frac);
+}
+
+static ssize_t cciss_show_usage_count(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct drv_dynamic *d;
+	drive_info_struct *drv;
+	int count;
+
+	d = container_of(dev, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	if (!d->disk) {
+		spin_unlock(&sysfs_lock);
+		return -ENOENT;
+	}
+	drv = d->disk->private_data;
+	count = drv->usage_count;
+	spin_unlock(&sysfs_lock);
+	return snprintf(buf, 20, "%d\n", count);
+}
+
+static ssize_t cciss_show_vendor(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct drv_dynamic *d;
+	drive_info_struct *drv;
+	ctlr_info_t *h;
+	unsigned long flags;
+	int drv_index;
+
+	d = container_of(dev, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	if (!d->disk) {
+		spin_unlock(&sysfs_lock);
+		return -ENOENT;
+	}
+
+	h = get_host(d->disk);
+
+	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
+	if (h->busy_configuring) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -EBUSY;
+	}
+
+	drv = d->disk->private_data;
+
+	if (!drv->heads) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -ENOTTY;
+	}
+
+	drv_index = find_drv_index(h->ctlr, drv);
+	if (drv_index != CISS_MAX_LUN) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return snprintf(buf, 20, "%s\n", (char *)drv->vendor);
+	}
+
+	printk(KERN_ERR "cciss: logical drive not found\n");
+	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+	spin_unlock(&sysfs_lock);
+	return -ENOTTY;
+}
+
+static ssize_t cciss_show_model(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct drv_dynamic *d;
+	drive_info_struct *drv;
+	ctlr_info_t *h;
+	unsigned long flags;
+	int drv_index;
+
+	d = container_of(dev, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	if (!d->disk) {
+		spin_unlock(&sysfs_lock);
+		return -ENOENT;
+	}
+
+	h = get_host(d->disk);
+
+	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
+	if (h->busy_configuring) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -EBUSY;
+	}
+
+	drv = d->disk->private_data;
+
+	if (!drv->heads) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -ENOTTY;
+	}
+
+	drv_index = find_drv_index(h->ctlr, drv);
+	if (drv_index != CISS_MAX_LUN) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return snprintf(buf, 20, "%s\n", (char *)drv->model);
+	}
+	printk(KERN_ERR "cciss: logical drive not found\n");
+	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+	spin_unlock(&sysfs_lock);
+	return -ENOTTY;
+}
+
+static ssize_t cciss_show_rev(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct drv_dynamic *d;
+	drive_info_struct *drv;
+	ctlr_info_t *h;
+	unsigned long flags;
+	int drv_index;
+
+	d = container_of(dev, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	if (!d->disk) {
+		spin_unlock(&sysfs_lock);
+		return -ENOENT;
+	}
+
+	h = get_host(d->disk);
+
+	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
+	if (h->busy_configuring) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -EBUSY;
+	}
+
+	drv = d->disk->private_data;
+
+	if (!drv->heads) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -ENOTTY;
+	}
+
+	drv_index = find_drv_index(h->ctlr, drv);
+	if (drv_index != CISS_MAX_LUN) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return snprintf(buf, 20, "%s\n", (char *)drv->rev);
+	}
+
+	printk(KERN_ERR "cciss: logical drive not found\n");
+	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+	spin_unlock(&sysfs_lock);
+	return -ENOTTY;
+}
+
+static ssize_t cciss_show_unique_id(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct drv_dynamic *d;
+	drive_info_struct *drv;
+	ctlr_info_t *h;
+	unsigned long flags;
+	int drv_index;
+
+	d = container_of(dev, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	if (!d->disk) {
+		spin_unlock(&sysfs_lock);
+		return -ENOENT;
+	}
+
+	h = get_host(d->disk);
+
+	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
+	if (h->busy_configuring) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return snprintf(buf, 30, "Device busy configuring\n");
+	}
+	drv = d->disk->private_data;
+
+	if (!drv->heads) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -ENOTTY;
+	}
+
+	drv_index = find_drv_index(h->ctlr, drv);
+	if (drv_index != CISS_MAX_LUN) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+
+		return snprintf(buf, 40, "%02X%02X%02X%02X%02X%02X%02X%02X"
+					 "%02X%02X%02X%02X%02X%02X%02X%02X\n",
+				  drv->uid[0], drv->uid[1], drv->uid[2],
+				  drv->uid[3], drv->uid[4], drv->uid[5],
+				  drv->uid[6], drv->uid[7], drv->uid[8],
+				  drv->uid[9], drv->uid[10], drv->uid[11],
+				  drv->uid[12], drv->uid[13], drv->uid[14],
+				  drv->uid[15]);
+	}
+
+	printk(KERN_ERR "cciss: logical drive not found\n");
+	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+	spin_unlock(&sysfs_lock);
+	return -ENOENT;
+}
+
+static ssize_t cciss_show_bus(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, 20, "cciss\n");
+}
+
+static ssize_t cciss_show_lunid(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct drv_dynamic *d;
+	drive_info_struct *drv;
+	ctlr_info_t *h;
+	unsigned long flags;
+	int drv_index;
+
+	d = container_of(dev, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	if (!d->disk) {
+		spin_unlock(&sysfs_lock);
+		return -ENOENT;
+	}
+
+	h = get_host(d->disk);
+
+	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
+	if (h->busy_configuring) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -EBUSY;
+	}
+
+	drv = d->disk->private_data;
+
+	if (!drv->heads) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return -ENOTTY;
+	}
+
+	drv_index = find_drv_index(h->ctlr, drv);
+	if (drv_index != CISS_MAX_LUN) {
+		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+		spin_unlock(&sysfs_lock);
+		return snprintf(buf, 20, "%d\n", drv->LunID);
+	}
+
+	printk(KERN_ERR "cciss: logical drive not found\n");
+	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+	spin_unlock(&sysfs_lock);
+	return -ENOTTY;
+}
+
+DEVICE_ATTR(raid_level, S_IRUGO | S_IWUSR, cciss_show_raid_level, NULL);
+DEVICE_ATTR(disk_size, S_IRUGO | S_IWUSR, cciss_show_disk_size, NULL);
+DEVICE_ATTR(usage_count, S_IRUGO | S_IWUSR, cciss_show_usage_count, NULL);
+DEVICE_ATTR(vendor, S_IRUGO | S_IWUSR, cciss_show_vendor, NULL);
+DEVICE_ATTR(model, S_IRUGO | S_IWUSR, cciss_show_model, NULL);
+DEVICE_ATTR(rev, S_IRUGO | S_IWUSR, cciss_show_rev, NULL);
+DEVICE_ATTR(unique_id, S_IRUGO | S_IWUSR, cciss_show_unique_id, NULL);
+DEVICE_ATTR(bus, S_IRUGO | S_IWUSR, cciss_show_bus, NULL);
+DEVICE_ATTR(lunid, S_IRUGO | S_IWUSR, cciss_show_lunid, NULL);
+
+static struct attribute *cciss_sysfs_attrs[] = {
+	&dev_attr_raid_level.attr,
+	&dev_attr_disk_size.attr,
+	&dev_attr_usage_count.attr,
+	&dev_attr_vendor.attr,
+	&dev_attr_model.attr,
+	&dev_attr_rev.attr,
+	&dev_attr_unique_id.attr,
+	&dev_attr_bus.attr,
+	&dev_attr_lunid.attr,
+	NULL
+};
+
+static struct attribute_group cciss_attrs = {.attrs = cciss_sysfs_attrs};
+
+static void cciss_add_blk_sysfs_dev(drive_info_struct *drv,
+				    struct gendisk* disk,
+				    struct pci_dev *pdev, int disk_num)
+{
+	struct drv_dynamic *d = kmalloc(sizeof(struct drv_dynamic), GFP_KERNEL);
+	if (!d)
+		return;
+	memset(d, 0, sizeof(struct drv_dynamic));
+	disk->driverfs_dev = &d->dev;
+	d->dev.parent = &pdev->dev;
+	d->dev.release = (void (*)(struct device *))kfree;
+	sprintf(d->dev.bus_id, "disk%d", disk_num);
+	d->dev.driver_data = "cciss";
+	if (device_register(&d->dev)) {
+		put_device(&d->dev);
+		return;
+	}
+	sysfs_create_group(&d->dev.kobj, &cciss_attrs);
+	d->disk = disk;
+	drv->dev_info = &d->dev;
+}
+
+static void cciss_remove_blk_sysfs_dev(struct gendisk *disk)
+{
+	drive_info_struct *drv = get_drv(disk);
+	struct drv_dynamic *d;
+
+	if (!drv->dev_info)
+		return;
+
+	d = container_of(drv->dev_info, struct drv_dynamic, dev);
+	spin_lock(&sysfs_lock);
+	sysfs_remove_group(&d->dev.kobj, &cciss_attrs);
+	d->disk = NULL;
+	spin_unlock(&sysfs_lock);
+	device_unregister(drv->dev_info);
+	drv->dev_info = NULL;
+}
+
+#ifdef CONFIG_PROC_FS
+
+/*
+ * Report information about this controller.
+ */
+static struct proc_dir_entry *proc_cciss;
+
+static void cciss_seq_show_header(struct seq_file *seq)
+{
+	ctlr_info_t *h = seq->private;
+
+	seq_printf(seq, "%s: HP %s Controller\n"
 		"Board ID: 0x%08lx\n"
 		"Firmware Version: %c%c%c%c\n"
 		"IRQ: %d\n"
@@ -279,94 +742,196 @@
 		"Current # commands on controller: %d\n"
 		"Max Q depth since init: %d\n"
 		"Max # commands on controller since init: %d\n"
-		"Max SG entries since init: %d\n\n",
-                h->devname,
-                h->product_name,
-                (unsigned long)h->board_id,
-		h->firm_ver[0], h->firm_ver[1], h->firm_ver[2], h->firm_ver[3],
-                (unsigned int)h->intr[SIMPLE_MODE_INT],
-                h->num_luns, 
+		"Max SG entries since init: %d\n",
+		h->devname,
+		h->product_name,
+		(unsigned long)h->board_id,
+		h->firm_ver[0], h->firm_ver[1], h->firm_ver[2],
+		h->firm_ver[3], (unsigned int)h->intr[SIMPLE_MODE_INT],
+		h->num_luns,
 		h->Qdepth, h->commands_outstanding,
 		h->maxQsinceinit, h->max_outstanding, h->maxSG);
+  
+#ifdef CONFIG_CISS_SCSI_TAPE
+	cciss_seq_tape_report(seq, h->ctlr);
+#endif /* CONFIG_CISS_SCSI_TAPE */
+}
 
-        pos += size; len += size;
-	cciss_proc_tape_report(ctlr, buffer, &pos, &len);
-	for(i=0; i<=h->highest_lun; i++) {
+static void *cciss_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	ctlr_info_t *h = seq->private;
+	unsigned ctlr = h->ctlr;
+	unsigned long flags;
 
-                drv = &h->drv[i];
-		if (drv->heads == 0)
-			continue;
+	/* prevent displaying bogus info during configuration
+	 * or deconfiguration of a logical volume
+	 */
+	spin_lock_irqsave(CCISS_LOCK(ctlr), flags);
+	if (h->busy_configuring) {
+		spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
+		return ERR_PTR(-EBUSY);	
+	}
+	h->busy_configuring = 1;
+	spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
 
-		vol_sz = drv->nr_blocks;
-		vol_sz_frac = sector_div(vol_sz, ENG_GIG_FACTOR);
-		vol_sz_frac *= 100;
-		sector_div(vol_sz_frac, ENG_GIG_FACTOR);
+	if (*pos == 0)
+		cciss_seq_show_header(seq);
 
-		if (drv->raid_level > 5)
-			drv->raid_level = RAID_UNKNOWN;
-		size = sprintf(buffer+len, "cciss/c%dd%d:"
-				"\t%4u.%02uGB\tRAID %s\n",
-				ctlr, i, (int)vol_sz, (int)vol_sz_frac,
-				raid_label[drv->raid_level]);
-                pos += size; len += size;
-        }
+	return pos;
+}
+
+static int cciss_seq_show(struct seq_file *seq, void *v)
+{
+	sector_t vol_sz, vol_sz_frac;
+	ctlr_info_t *h = seq->private;
+	unsigned ctlr = h->ctlr;
+	loff_t *pos = v;
+	drive_info_struct *drv = &h->drv[*pos];
+
+	if (*pos > h->highest_lun)
+		return 0;
+
+	if (drv->heads == 0)
+		return 0;
+
+	vol_sz = drv->nr_blocks;
+	vol_sz_frac = sector_div(vol_sz, ENG_GIG_FACTOR);
+	vol_sz_frac *= 100;
+	sector_div(vol_sz_frac, ENG_GIG_FACTOR);
+
+	if (drv->raid_level > 5)
+		drv->raid_level = RAID_UNKNOWN;
+	seq_printf(seq, "cciss/c%dd%d:"
+			"\t%4u.%02uGB\tRAID %s\n",
+			ctlr, (int) *pos, (int)vol_sz, (int)vol_sz_frac,
+			raid_label[drv->raid_level]);
+	return 0;
+}
+
+static void *cciss_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	ctlr_info_t *h = seq->private;
+
+	if (*pos > h->highest_lun)
+		return NULL;
+	*pos += 1;
+
+	return pos;
+}
+
+static void cciss_seq_stop(struct seq_file *seq, void *v)
+{
+	ctlr_info_t *h = seq->private;
+
+	/* Only reset h->busy_configuring if we succeeded in setting
+	 * it during cciss_seq_start. */
+	if (v == ERR_PTR(-EBUSY))
+		return;
 
-        *eof = 1;
-        *start = buffer+offset;
-        len -= offset;
-        if (len>length)
-                len = length;
 	h->busy_configuring = 0;
-        return len;
 }
 
-static int 
-cciss_proc_write(struct file *file, const char __user *buffer, 
-			unsigned long count, void *data)
+static struct seq_operations cciss_seq_ops = {
+	.start = cciss_seq_start,
+	.show  = cciss_seq_show,
+	.next  = cciss_seq_next,
+	.stop  = cciss_seq_stop,
+};
+
+static int cciss_seq_open(struct inode *inode, struct file *file)
+{
+	int ret = seq_open(file, &cciss_seq_ops);
+	struct seq_file *seq = file->private_data;
+
+	if (!ret)
+		seq->private = PDE(inode)->data;
+
+	return ret;
+}
+
+static ssize_t
+cciss_proc_write(struct file *file, const char __user *buf,
+		 size_t length, loff_t *ppos)
 {
-	unsigned char cmd[80];
-	int len;
-#ifdef CONFIG_CISS_SCSI_TAPE
-	ctlr_info_t *h = (ctlr_info_t *) data;
+	int err;
+	char *buffer;
+	struct seq_file *seq = file->private_data;
+	ctlr_info_t *h = seq->private;
 	int rc;
-#endif
 
-	if (count > sizeof(cmd)-1) return -EINVAL;
-	if (copy_from_user(cmd, buffer, count)) return -EFAULT;
-	cmd[count] = '\0';
-	len = strlen(cmd);	// above 3 lines ensure safety
-	if (len && cmd[len-1] == '\n')
-		cmd[--len] = '\0';
-#	ifdef CONFIG_CISS_SCSI_TAPE
-		if (strcmp("engage scsi", cmd)==0) {
-			rc = cciss_engage_scsi(h->ctlr);
-			if (rc != 0) return -rc;
-			return count;
-		}
+	if (!buf || length > PAGE_SIZE - 1)
+		return -EINVAL;
+
+	buffer = (char *)__get_free_page(GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(buffer, buf, length))
+		goto out;
+	buffer[length] = '\0';
+
+	/* For the MSA2000 the firmware cannot tell the driver to
+	 * rescan when new logical volumes are created. We provide
+	 * this interface so users can `echo "rescan volumes" >
+	 * /proc/driver/cciss/ccissN` to accomplish that task. It's not
+	 * the best solution because it must be done on every server
+	 * that connected to the storage.
+	 */
+	if (strncmp(RESCAN_VOLUMES, buffer, sizeof RESCAN_VOLUMES - 1) == 0) {
+		/* rebuild_lun_table returns -1 on success to tell ACU
+		 * to quit calling it. In this case we just ignore any
+		 * return code.
+		 */
+		(void) rebuild_lun_table(h, NULL);
+		err = length;
+		goto out;
+	}
+	
+#ifdef CONFIG_CISS_SCSI_TAPE
+	if (strncmp(ENGAGE_SCSI, buffer, sizeof ENGAGE_SCSI - 1) == 0) {
+		rc = cciss_engage_scsi(h->ctlr);
+		if (rc != 0)
+			err = -rc;
+		else
+			err = length;
+	} else
+#endif 					/* CONFIG_CISS_SCSI_TAPE */
+		err = -EINVAL;
 		/* might be nice to have "disengage" too, but it's not 
 		   safely possible. (only 1 module use count, lock issues.) */
-#	endif
-	return -EINVAL;
+
+out:
+	free_page((unsigned long)buffer);
+	return err;
 }
 
-/*
- * Get us a file in /proc/cciss that says something about each controller.
- * Create /proc/cciss if it doesn't exist yet.
- */
+static struct file_operations cciss_proc_fops = {
+	.owner	 = THIS_MODULE,
+	.open    = cciss_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+	.write	 = cciss_proc_write,
+};
+
 static void __devinit cciss_procinit(int i)
 {
 	struct proc_dir_entry *pde;
 
-        if (proc_cciss == NULL) {
+        if (proc_cciss == NULL)
                 proc_cciss = proc_mkdir("cciss", proc_root_driver);
-                if (!proc_cciss) 
-			return;
-        }
 
-	pde = create_proc_read_entry(hba[i]->devname, 
-		S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH, 
-		proc_cciss, cciss_proc_get_info, hba[i]);
-	pde->write_proc = cciss_proc_write;
+	if (!proc_cciss)
+		return;
+
+	pde = create_proc_entry(hba[i]->devname, 
+		S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH, proc_cciss);
+	if (!pde)
+		return;
+
+	pde->proc_fops = &cciss_proc_fops;
+	pde->data = hba[i];
 }
 #endif /* CONFIG_PROC_FS */
 
@@ -377,52 +942,51 @@
  * to possible sleep, this routine can be called with get_from_pool set to 0. 
  * cmd_free() MUST be called with a got_from_pool set to 0 if cmd_alloc was. 
  */ 
-static CommandList_struct * cmd_alloc(ctlr_info_t *h, int get_from_pool)
+static CommandList_struct *cmd_alloc(ctlr_info_t *h, int get_from_pool)
 {
 	CommandList_struct *c;
 	int i; 
 	u64bit temp64;
 	dma_addr_t cmd_dma_handle, err_dma_handle;
 
-	if (!get_from_pool)
-	{
-		c = (CommandList_struct *) pci_alloc_consistent(
-			h->pdev, sizeof(CommandList_struct), &cmd_dma_handle); 
-        	if(c==NULL)
+	if (!get_from_pool) {
+		c = (CommandList_struct *) pci_alloc_consistent(h->pdev,
+			sizeof(CommandList_struct), &cmd_dma_handle);
+        	if(c == NULL)
                  	return NULL;
 		memset(c, 0, sizeof(CommandList_struct));
 
 		c->cmdindex = -1;
 
-		c->err_info = (ErrorInfo_struct *)pci_alloc_consistent(
-					h->pdev, sizeof(ErrorInfo_struct), 
+		c->err_info = (ErrorInfo_struct *)
+		    pci_alloc_consistent(h->pdev, sizeof(ErrorInfo_struct),
 					&err_dma_handle);
 	
-		if (c->err_info == NULL)
-		{
+		if (c->err_info == NULL) {
 			pci_free_consistent(h->pdev, 
 				sizeof(CommandList_struct), c, cmd_dma_handle);
 			return NULL;
 		}
 		memset(c->err_info, 0, sizeof(ErrorInfo_struct));
-	} else /* get it out of the controllers pool */ 
-	{
-	     	do {
-                	i = find_first_zero_bit(h->cmd_pool_bits, NR_CMDS);
-                        if (i == NR_CMDS)
-                                return NULL;
-                } while(test_and_set_bit(i & (BITS_PER_LONG - 1), h->cmd_pool_bits+(i/BITS_PER_LONG)) != 0);
+	} else {		/* get it out of the controllers pool */
+		do {
+			i = find_first_zero_bit(h->cmd_pool_bits, h->nr_cmds);
+			if (i == h->nr_cmds)
+				return NULL;
+		} while(test_and_set_bit
+			(i & (BITS_PER_LONG - 1),
+			h->cmd_pool_bits + (i / BITS_PER_LONG)) != 0);
 #ifdef CCISS_DEBUG
 		printk(KERN_DEBUG "cciss: using command buffer %d\n", i);
 #endif
                 c = h->cmd_pool + i;
 		memset(c, 0, sizeof(CommandList_struct));
-		cmd_dma_handle = h->cmd_pool_dhandle 
-					+ i*sizeof(CommandList_struct);
+		cmd_dma_handle = h->cmd_pool_dhandle
+		    + i * sizeof(CommandList_struct);
 		c->err_info = h->errinfo_pool + i;
 		memset(c->err_info, 0, sizeof(ErrorInfo_struct));
 		err_dma_handle = h->errinfo_pool_dhandle 
-					+ i*sizeof(ErrorInfo_struct);
+		    + i * sizeof(ErrorInfo_struct);
                 h->nr_allocs++;
 
 		c->cmdindex = i;
@@ -436,8 +1000,6 @@
 	
 	c->ctlr = h->ctlr;
         return c;
-
-
 }
 
 /* 
@@ -448,32 +1010,21 @@
 	int i;
 	u64bit temp64;
 
-	if( !got_from_pool)
-	{ 
+	if (!got_from_pool) {
 		temp64.val32.lower = c->ErrDesc.Addr.lower;
 		temp64.val32.upper = c->ErrDesc.Addr.upper;
 		pci_free_consistent(h->pdev, sizeof(ErrorInfo_struct), 
 			c->err_info, (dma_addr_t) temp64.val);
 		pci_free_consistent(h->pdev, sizeof(CommandList_struct), 
 			c, (dma_addr_t) c->busaddr);
-	} else 
-	{
+	} else {
 		i = c - h->cmd_pool;
-		clear_bit(i&(BITS_PER_LONG-1), h->cmd_pool_bits+(i/BITS_PER_LONG));
+		clear_bit(i & (BITS_PER_LONG - 1),
+			  h->cmd_pool_bits + (i / BITS_PER_LONG));
                 h->nr_frees++;
         }
 }
 
-static inline ctlr_info_t *get_host(struct gendisk *disk)
-{
-	return disk->queue->queuedata; 
-}
-
-static inline drive_info_struct *get_drv(struct gendisk *disk)
-{
-	return disk->private_data;
-}
-
 /*
  * Open.  Make sure the device is really there.
  */
@@ -496,7 +1047,7 @@
 	 * but I'm already using way to many device nodes to claim another one
 	 * for "raw controller".
 	 */
-	if (drv->nr_blocks == 0) {
+	if (drv->heads == 0) {
 		if (iminor(inode) != 0)	{ 	/* not node 0? */
 			/* if not node 0 make sure it is a partition = 0 */
 			if (iminor(inode) & 0x0f) {
@@ -513,6 +1064,7 @@
 	host->usage_count++;
 	return 0;
 }
+
 /*
  * Close.  Sync first.
  */
@@ -522,7 +1074,8 @@
 	drive_info_struct *drv = get_drv(inode->i_bdev->bd_disk);
 
 #ifdef CCISS_DEBUG
-	printk(KERN_DEBUG "cciss_release %s\n", inode->i_bdev->bd_disk->disk_name);
+	printk(KERN_DEBUG "cciss_release %s\n",
+	       inode->i_bdev->bd_disk->disk_name);
 #endif /* CCISS_DEBUG */
 
 	drv->usage_count--;
@@ -541,8 +1094,10 @@
 	return ret;
 }
 
-static int cciss_ioctl32_passthru(struct file *f, unsigned cmd, unsigned long arg);
-static int cciss_ioctl32_big_passthru(struct file *f, unsigned cmd, unsigned long arg);
+static int cciss_ioctl32_passthru(struct file *f, unsigned cmd,
+				 unsigned long arg);
+static int cciss_ioctl32_big_passthru(struct file *f, unsigned cmd,
+				     unsigned long arg);
 
 static long cciss_compat_ioctl(struct file *f, unsigned cmd, unsigned long arg)
 {
@@ -574,7 +1129,8 @@
 	}
 }
 
-static int cciss_ioctl32_passthru(struct file *f, unsigned cmd, unsigned long arg)
+static int cciss_ioctl32_passthru(struct file *f, unsigned cmd,
+				 unsigned long arg)
 {
 	IOCTL32_Command_struct __user *arg32 =
 		(IOCTL32_Command_struct __user *) arg;
@@ -584,9 +1140,12 @@
 	u32 cp;
 
 	err = 0;
-	err |= copy_from_user(&arg64.LUN_info, &arg32->LUN_info, sizeof(arg64.LUN_info));
-	err |= copy_from_user(&arg64.Request, &arg32->Request, sizeof(arg64.Request));
-	err |= copy_from_user(&arg64.error_info, &arg32->error_info, sizeof(arg64.error_info));
+	err |= copy_from_user(&arg64.LUN_info, &arg32->LUN_info,
+			      sizeof(arg64.LUN_info));
+	err |= copy_from_user(&arg64.Request, &arg32->Request,
+			      sizeof(arg64.Request));
+	err |= copy_from_user(&arg64.error_info, &arg32->error_info,
+			      sizeof(arg64.error_info));
 	err |= get_user(arg64.buf_size, &arg32->buf_size);
 	err |= get_user(cp, &arg32->buf);
 	arg64.buf = compat_ptr(cp);
@@ -595,28 +1154,34 @@
 	if (err)
 		return -EFAULT;
 
-	err = do_ioctl(f, CCISS_PASSTHRU, (unsigned long) p);
+	err = do_ioctl(f, CCISS_PASSTHRU, (unsigned long)p);
 	if (err)
 		return err;
-	err |= copy_in_user(&arg32->error_info, &p->error_info, sizeof(arg32->error_info));
+	err |= copy_in_user(&arg32->error_info, &p->error_info,
+			    sizeof(arg32->error_info));
 	if (err)
 		return -EFAULT;
 	return err;
 }
 
-static int cciss_ioctl32_big_passthru(struct file *file, unsigned cmd, unsigned long arg)
+static int cciss_ioctl32_big_passthru(struct file *file, unsigned cmd,
+				     unsigned long arg)
 {
 	BIG_IOCTL32_Command_struct __user *arg32 =
 		(BIG_IOCTL32_Command_struct __user *) arg;
 	BIG_IOCTL_Command_struct arg64;
-	BIG_IOCTL_Command_struct __user *p = compat_alloc_user_space(sizeof(arg64));
+	BIG_IOCTL_Command_struct __user *p =
+	    compat_alloc_user_space(sizeof(arg64));
 	int err;
 	u32 cp;
 
 	err = 0;
-	err |= copy_from_user(&arg64.LUN_info, &arg32->LUN_info, sizeof(arg64.LUN_info));
-	err |= copy_from_user(&arg64.Request, &arg32->Request, sizeof(arg64.Request));
-	err |= copy_from_user(&arg64.error_info, &arg32->error_info, sizeof(arg64.error_info));
+	err |= copy_from_user(&arg64.LUN_info, &arg32->LUN_info,
+			     sizeof(arg64.LUN_info));
+	err |= copy_from_user(&arg64.Request, &arg32->Request,
+			     sizeof(arg64.Request));
+	err |= copy_from_user(&arg64.error_info, &arg32->error_info,
+			     sizeof(arg64.error_info));
 	err |= get_user(arg64.buf_size, &arg32->buf_size);
 	err |= get_user(arg64.malloc_size, &arg32->malloc_size);
 	err |= get_user(cp, &arg32->buf);
@@ -626,10 +1191,11 @@
 	if (err)
 		 return -EFAULT;
 
-	err = do_ioctl(file, CCISS_BIG_PASSTHRU, (unsigned long) p);
+	err = do_ioctl(file, CCISS_BIG_PASSTHRU, (unsigned long)p);
 	if (err)
 		return err;
-	err |= copy_in_user(&arg32->error_info, &p->error_info, sizeof(arg32->error_info));
+	err |= copy_in_user(&arg32->error_info, &p->error_info,
+			   sizeof(arg32->error_info));
 	if (err)
 		return -EFAULT;
 	return err;
@@ -666,29 +1232,33 @@
 	printk(KERN_DEBUG "cciss_ioctl: Called with cmd=%x %lx\n", cmd, arg);
 #endif /* CCISS_DEBUG */ 
 	
-	switch(cmd) {
+	switch (cmd) {
 	case CCISS_GETPCIINFO:
 	{
 		cciss_pci_info_struct pciinfo;
 
-		if (!arg) return -EINVAL;
+		if (!arg)
+			return -EINVAL;
 		pciinfo.domain = pci_domain_nr(host->pdev->bus);
 		pciinfo.bus = host->pdev->bus->number;
 		pciinfo.dev_fn = host->pdev->devfn;
 		pciinfo.board_id = host->board_id;
-		if (copy_to_user(argp, &pciinfo,  sizeof( cciss_pci_info_struct )))
-			return  -EFAULT;
-		return(0);
+		if (copy_to_user(argp, &pciinfo,
+		    sizeof( cciss_pci_info_struct)))
+			return -EFAULT;
+		return 0;
 	}	
 	case CCISS_GETINTINFO:
 	{
 		cciss_coalint_struct intinfo;
-		if (!arg) return -EINVAL;
+		if (!arg)
+			return -EINVAL;
 		intinfo.delay = readl(&host->cfgtable->HostWrite.CoalIntDelay);
 		intinfo.count = readl(&host->cfgtable->HostWrite.CoalIntCount);
-		if (copy_to_user(argp, &intinfo, sizeof( cciss_coalint_struct )))
+		if (copy_to_user(argp, &intinfo,
+		    sizeof( cciss_coalint_struct)))
 			return -EFAULT;
-                return(0);
+                return 0;
         }
 	case CCISS_SETINTINFO:
         {
@@ -696,25 +1266,28 @@
 		unsigned long flags;
 		int i;
 
-		if (!arg) return -EINVAL;	
-		if (!capable(CAP_SYS_ADMIN)) return -EPERM;
-		if (copy_from_user(&intinfo, argp, sizeof( cciss_coalint_struct)))
+		if (!arg)
+			return -EINVAL;
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
+		if (copy_from_user(&intinfo, argp,
+		    sizeof(cciss_coalint_struct)))
 			return -EFAULT;
-		if ( (intinfo.delay == 0 ) && (intinfo.count == 0))
+		if ((intinfo.delay == 0 ) && (intinfo.count == 0))
 
 		{
 //			printk("cciss_ioctl: delay and count cannot be 0\n");
-			return( -EINVAL);
+			return -EINVAL;
 		}
 		spin_lock_irqsave(CCISS_LOCK(ctlr), flags);
 		/* Update the field, and then ring the doorbell */ 
-		writel( intinfo.delay, 
+		writel(intinfo.delay,
 			&(host->cfgtable->HostWrite.CoalIntDelay));
-		writel( intinfo.count, 
+		writel(intinfo.count,
                         &(host->cfgtable->HostWrite.CoalIntCount));
-		writel( CFGTBL_ChangeReq, host->vaddr + SA5_DOORBELL);
+		writel(CFGTBL_ChangeReq, host->vaddr + SA5_DOORBELL);
 
-		for(i=0;i<MAX_IOCTL_CONFIG_WAIT;i++) {
+		for(i = 0; i < MAX_IOCTL_CONFIG_WAIT; i++) {
 			if (!(readl(host->vaddr + SA5_DOORBELL) 
 					& CFGTBL_ChangeReq))
 				break;
@@ -724,19 +1297,21 @@
 		spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
 		if (i >= MAX_IOCTL_CONFIG_WAIT)
 			return -EAGAIN;
-                return(0);
+                return 0;
         }
 	case CCISS_GETNODENAME:
         {
                 NodeName_type NodeName;
 		int i; 
 
-		if (!arg) return -EINVAL;
-		for(i=0;i<16;i++)
+		if (!arg)
+			return -EINVAL;
+		for(i = 0; i < 16; i++) {
 			NodeName[i] = readb(&host->cfgtable->ServerName[i]);
-                if (copy_to_user(argp, NodeName, sizeof( NodeName_type)))
-                	return  -EFAULT;
-                return(0);
+		}
+                if (copy_to_user(argp, NodeName, sizeof(NodeName_type)))
+                	return -EFAULT;
+                return 0;
         }
 	case CCISS_SETNODENAME:
 	{
@@ -744,21 +1319,23 @@
 		unsigned long flags;
 		int i;
 
-		if (!arg) return -EINVAL;
-		if (!capable(CAP_SYS_ADMIN)) return -EPERM;
+		if (!arg)
+			return -EINVAL;
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
 		
-		if (copy_from_user(NodeName, argp, sizeof( NodeName_type)))
+		if (copy_from_user(NodeName, argp, sizeof(NodeName_type)))
 			return -EFAULT;
 
 		spin_lock_irqsave(CCISS_LOCK(ctlr), flags);
 
 			/* Update the field, and then ring the doorbell */ 
-		for(i=0;i<16;i++)
-			writeb( NodeName[i], &host->cfgtable->ServerName[i]);
+		for(i = 0; i < 16; i++)
+			writeb(NodeName[i], &host->cfgtable->ServerName[i]);
 			
-		writel( CFGTBL_ChangeReq, host->vaddr + SA5_DOORBELL);
+		writel(CFGTBL_ChangeReq, host->vaddr + SA5_DOORBELL);
 
-		for(i=0;i<MAX_IOCTL_CONFIG_WAIT;i++) {
+		for(i = 0; i < MAX_IOCTL_CONFIG_WAIT; i++) {
 			if (!(readl(host->vaddr + SA5_DOORBELL) 
 					& CFGTBL_ChangeReq))
 				break;
@@ -768,70 +1345,70 @@
 		spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
 		if (i >= MAX_IOCTL_CONFIG_WAIT)
 			return -EAGAIN;
-                return(0);
+                return 0;
         }
 
 	case CCISS_GETHEARTBEAT:
         {
                 Heartbeat_type heartbeat;
 
-		if (!arg) return -EINVAL;
+		if (!arg)
+			return -EINVAL;
                 heartbeat = readl(&host->cfgtable->HeartBeat);
-                if (copy_to_user(argp, &heartbeat, sizeof( Heartbeat_type)))
+                if (copy_to_user(argp, &heartbeat, sizeof(Heartbeat_type)))
                 	return -EFAULT;
-                return(0);
+                return 0;
         }
 	case CCISS_GETBUSTYPES:
         {
                 BusTypes_type BusTypes;
 
-		if (!arg) return -EINVAL;
+		if (!arg)
+			return -EINVAL;
                 BusTypes = readl(&host->cfgtable->BusTypes);
-                if (copy_to_user(argp, &BusTypes, sizeof( BusTypes_type) ))
-                	return  -EFAULT;
-                return(0);
+                if (copy_to_user(argp, &BusTypes, sizeof(BusTypes_type)))
+                	return -EFAULT;
+                return 0;
         }
 	case CCISS_GETFIRMVER:
         {
 		FirmwareVer_type firmware;
 
-		if (!arg) return -EINVAL;
+		if (!arg)
+			return -EINVAL;
 		memcpy(firmware, host->firm_ver, 4);
 
-                if (copy_to_user(argp, firmware, sizeof( FirmwareVer_type)))
+                if (copy_to_user(argp, firmware, sizeof(FirmwareVer_type)))
                 	return -EFAULT;
-                return(0);
+                return 0;
         }
         case CCISS_GETDRIVVER:
         {
 		DriverVer_type DriverVer = DRIVER_VERSION;
 
-                if (!arg) return -EINVAL;
+                if (!arg)
+			return -EINVAL;
 
-                if (copy_to_user(argp, &DriverVer, sizeof( DriverVer_type) ))
+                if (copy_to_user(argp, &DriverVer, sizeof(DriverVer_type)))
                 	return -EFAULT;
-                return(0);
+                return 0;
         }
 
-	case CCISS_REVALIDVOLS:
-		if (bdev != bdev->bd_contains || drv != host->drv)
-			return -ENXIO;
-                return revalidate_allvol(host);
-
- 	case CCISS_GETLUNINFO: {
+ 	case CCISS_GETLUNINFO:
+	{
  		LogvolInfo_struct luninfo;
  		
  		luninfo.LunID = drv->LunID;
  		luninfo.num_opens = drv->usage_count;
- 		luninfo.num_parts = 0;
+
  		if (copy_to_user(argp, &luninfo,
  				sizeof(LogvolInfo_struct)))
  			return -EFAULT;
- 		return(0);
+ 		return 0;
  	}
-	case CCISS_DEREGDISK:
-		return rebuild_lun_table(host, disk);
 
+	case CCISS_REVALIDVOLS:
+	case CCISS_DEREGDISK:
 	case CCISS_REGNEWD:
 		return rebuild_lun_table(host, NULL);
 
@@ -842,17 +1419,19 @@
 		char 	*buff = NULL;
 		u64bit	temp64;
 		unsigned long flags;
-		DECLARE_COMPLETION(wait);
+		CCISS_DECLARE_COMPLETION(wait);
 
-		if (!arg) return -EINVAL;
+		if (!arg)
+			return -EINVAL;
 	
-		if (!capable(CAP_SYS_RAWIO)) return -EPERM;
+		if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
 
-		if (copy_from_user(&iocommand, argp, sizeof( IOCTL_Command_struct) ))
+		if (copy_from_user(&iocommand, argp,
+				   sizeof(IOCTL_Command_struct)))
 			return -EFAULT;
-		if((iocommand.buf_size < 1) && 
-				(iocommand.Request.Type.Direction != XFER_NONE))
-		{	
+		if((iocommand.buf_size < 1) &&
+		  (iocommand.Request.Type.Direction != XFER_NONE)) {
 			return -EINVAL;
 		} 
 #if 0 /* 'buf_size' member is 16-bits, and always smaller than kmalloc limit */
@@ -860,25 +1439,22 @@
 		if(iocommand.buf_size > 128000)
 			return -EINVAL;
 #endif
-		if(iocommand.buf_size > 0)
-		{
+		if (iocommand.buf_size > 0) {
 			buff =  kmalloc(iocommand.buf_size, GFP_KERNEL);
 			if( buff == NULL) 
-				return -EFAULT;
+				return -ENOMEM;
 		}
-		if (iocommand.Request.Type.Direction == XFER_WRITE)
-		{
+		if (iocommand.Request.Type.Direction == XFER_WRITE) {
 			/* Copy the data into the buffer we created */ 
-			if (copy_from_user(buff, iocommand.buf, iocommand.buf_size))
-			{
+			if (copy_from_user(buff,
+			    iocommand.buf, iocommand.buf_size)) {
 				kfree(buff);
 				return -EFAULT;
 			}
 		} else {
 			memset(buff, 0, iocommand.buf_size);
 		}
-		if ((c = cmd_alloc(host , 0)) == NULL)
-		{
+		if ((c = cmd_alloc(host, 0)) == NULL) {
 			kfree(buff);
 			return -ENOMEM;
 		}
@@ -886,14 +1462,12 @@
 		c->cmd_type = CMD_IOCTL_PEND;
 			// Fill in Command Header 
 		c->Header.ReplyQueue = 0;  // unused in simple mode
-		if( iocommand.buf_size > 0) 	// buffer to fill 
-		{
+		if(iocommand.buf_size > 0) {	// buffer to fill
 			c->Header.SGList = 1;
-			c->Header.SGTotal= 1;
-		} else	// no buffers to fill  
-		{
+			c->Header.SGTotal = 1;
+		} else {	// no buffers to fill
 			c->Header.SGList = 0;
-                	c->Header.SGTotal= 0;
+                	c->Header.SGTotal = 0;
 		}
 		c->Header.LUN = iocommand.LUN_info;
 		c->Header.Tag.lower = c->busaddr;  // use the kernel address the cmd block for tag
@@ -902,11 +1476,10 @@
 		c->Request = iocommand.Request; 
 	
 		// Fill in the scatter gather information
-		if (iocommand.buf_size > 0 ) 
-		{
-			temp64.val = pci_map_single( host->pdev, buff,
-                                        iocommand.buf_size, 
-                                PCI_DMA_BIDIRECTIONAL);	
+		if (iocommand.buf_size > 0) {
+			temp64.val = pci_map_single(host->pdev, buff,
+                                        iocommand.buf_size,
+	                                PCI_DMA_BIDIRECTIONAL);
 			c->SG[0].Addr.lower = temp64.val32.lower;
 			c->SG[0].Addr.upper = temp64.val32.upper;
 			c->SG[0].Len = iocommand.buf_size;
@@ -926,23 +1499,22 @@
 		/* unlock the buffers from DMA */
 		temp64.val32.lower = c->SG[0].Addr.lower;
                 temp64.val32.upper = c->SG[0].Addr.upper;
-                pci_unmap_single( host->pdev, (dma_addr_t) temp64.val,
+                pci_unmap_single(host->pdev, (dma_addr_t) temp64.val,
                 	iocommand.buf_size, PCI_DMA_BIDIRECTIONAL);
 
 		/* Copy the error information out */ 
 		iocommand.error_info = *(c->err_info);
-		if ( copy_to_user(argp, &iocommand, sizeof( IOCTL_Command_struct) ) )
-		{
+		if (copy_to_user(argp, &iocommand,
+		    sizeof(IOCTL_Command_struct))) {
 			kfree(buff);
 			cmd_free(host, c, 0);
-			return( -EFAULT);	
+			return -EFAULT;
 		} 	
 
-		if (iocommand.Request.Type.Direction == XFER_READ)
-                {
+		if (iocommand.Request.Type.Direction == XFER_READ) {
                         /* Copy the data out of the buffer we created */
-                        if (copy_to_user(iocommand.buf, buff, iocommand.buf_size))
-			{
+                        if (copy_to_user(iocommand.buf, buff,
+				iocommand.buf_size)) {
                         	kfree(buff);
 				cmd_free(host, c, 0);
 				return -EFAULT;
@@ -950,9 +1522,10 @@
                 }
                 kfree(buff);
 		cmd_free(host, c, 0);
-                return(0);
+                return 0;
 	} 
-	case CCISS_BIG_PASSTHRU: {
+	case CCISS_BIG_PASSTHRU:
+	{
 		BIG_IOCTL_Command_struct *ioc;
 		CommandList_struct *c;
 		unsigned char **buff = NULL;
@@ -962,7 +1535,7 @@
 		BYTE sg_used = 0;
 		int status = 0;
 		int i;
-		DECLARE_COMPLETION(wait);
+		CCISS_DECLARE_COMPLETION(wait);
 		__u32   left;
 		__u32	sz;
 		BYTE    __user *data_ptr;
@@ -995,14 +1568,13 @@
 			status = -EINVAL;
 			goto cleanup1;
 		}
-		buff = (unsigned char **) kmalloc(MAXSGENTRIES * 
-				sizeof(char *), GFP_KERNEL);
+		buff = kzalloc(MAXSGENTRIES * sizeof(char *), GFP_KERNEL);
+
 		if (!buff) {
 			status = -ENOMEM;
 			goto cleanup1;
 		}
-		memset(buff, 0, MAXSGENTRIES);
-		buff_size = (int *) kmalloc(MAXSGENTRIES * sizeof(int), 
+		buff_size = (int *) kmalloc(MAXSGENTRIES * sizeof(int),
 					GFP_KERNEL);
 		if (!buff_size) {
 			status = -ENOMEM;
@@ -1019,8 +1591,8 @@
 				goto cleanup1;
 			}
 			if (ioc->Request.Type.Direction == XFER_WRITE) {
-				if (copy_from_user(buff[sg_used], data_ptr, sz)) {
-					status = -ENOMEM;
+				if (copy_from_user(buff[sg_used],data_ptr,sz)) {
+					status = -EFAULT;
 					goto cleanup1;
 				}
 			} else {
@@ -1030,19 +1602,19 @@
 			data_ptr += sz;
 			sg_used++;
 		}
-		if ((c = cmd_alloc(host , 0)) == NULL) {
+		if ((c = cmd_alloc(host, 0)) == NULL) {
 			status = -ENOMEM;
 			goto cleanup1;	
 		}
 		c->cmd_type = CMD_IOCTL_PEND;
 		c->Header.ReplyQueue = 0;
 		
-		if( ioc->buf_size > 0) {
+		if (ioc->buf_size > 0) {
 			c->Header.SGList = sg_used;
-			c->Header.SGTotal= sg_used;
+			c->Header.SGTotal = sg_used;
 		} else { 
 			c->Header.SGList = 0;
-			c->Header.SGTotal= 0;
+			c->Header.SGTotal = 0;
 		}
 		c->Header.LUN = ioc->LUN_info;
 		c->Header.Tag.lower = c->busaddr;
@@ -1050,8 +1622,9 @@
 		c->Request = ioc->Request;
 		if (ioc->buf_size > 0 ) {
 			int i;
-			for(i=0; i<sg_used; i++) {
-				temp64.val = pci_map_single( host->pdev, buff[i],
+			for (i = 0; i < sg_used; i++) {
+				temp64.val =
+					pci_map_single(host->pdev, buff[i],
 					buff_size[i],
 					PCI_DMA_BIDIRECTIONAL);
 				c->SG[i].Addr.lower = temp64.val32.lower;
@@ -1069,10 +1642,10 @@
 		spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
 		wait_for_completion(&wait);
 		/* unlock the buffers from DMA */
-		for(i=0; i<sg_used; i++) {
+		for (i = 0; i < sg_used; i++) {
 			temp64.val32.lower = c->SG[i].Addr.lower;
 			temp64.val32.upper = c->SG[i].Addr.upper;
-			pci_unmap_single( host->pdev, (dma_addr_t) temp64.val,
+			pci_unmap_single(host->pdev, (dma_addr_t) temp64.val,
 				buff_size[i], PCI_DMA_BIDIRECTIONAL);
 		}
 		/* Copy the error information out */
@@ -1085,7 +1658,7 @@
 		if (ioc->Request.Type.Direction == XFER_READ) {
 			/* Copy the data out of the buffer we created */
 			BYTE __user *ptr = ioc->buf;
-	        	for(i=0; i< sg_used; i++) {
+	        	for(i=0; i < sg_used; i++) {
 				if (copy_to_user(ptr, buff[i], buff_size[i])) {
 					cmd_free(host, c, 0);
 					status = -EFAULT;
@@ -1098,101 +1671,103 @@
 		status = 0;
 cleanup1:
 		if (buff) {
-			for(i=0; i<sg_used; i++)
+			for (i = 0; i < sg_used; i++)
 				kfree(buff[i]);
+
 			kfree(buff);
 		}
 		kfree(buff_size);
 		kfree(ioc);
-		return(status);
+		return status;
 	}
+
+	/* scsi_cmd_ioctl handles these, below, though some are not */
+	/* very meaningful for cciss.  SG_IO is the main one people want. */
+
+	case SG_GET_VERSION_NUM:
+	case SG_SET_TIMEOUT:
+	case SG_GET_TIMEOUT:
+	case SG_GET_RESERVED_SIZE:
+	case SG_SET_RESERVED_SIZE:
+	case SG_EMULATED_HOST:
+	case SG_IO:
+	case SCSI_IOCTL_SEND_COMMAND:
+		return scsi_cmd_ioctl(filep, disk, cmd, argp);
+
+	/* scsi_cmd_ioctl would normally handle these, below, but */
+	/* they aren't a good fit for cciss, as CD-ROMs are */
+	/* not supported, and we don't have any bus/target/lun */
+	/* which we present to the kernel. */
+
+	case CDROM_SEND_PACKET:
+	case CDROMCLOSETRAY:
+	case CDROMEJECT:
+	case SCSI_IOCTL_GET_IDLUN:
+	case SCSI_IOCTL_GET_BUS_NUMBER:
 	default:
 		return -ENOTTY;
 	}
 	
 }
 
-/*
- * revalidate_allvol is for online array config utilities.  After a
- * utility reconfigures the drives in the array, it can use this function
- * (through an ioctl) to make the driver zap any previous disk structs for
- * that controller and get new ones.
- *
- * Right now I'm using the getgeometry() function to do this, but this
- * function should probably be finer grained and allow you to revalidate one
- * particualar logical volume (instead of all of them on a particular
- * controller).
- */
-static int revalidate_allvol(ctlr_info_t *host)
-{
-	int ctlr = host->ctlr, i;
-	unsigned long flags;
-
-        spin_lock_irqsave(CCISS_LOCK(ctlr), flags);
-        if (host->usage_count > 1) {
-                spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
-                printk(KERN_WARNING "cciss: Device busy for volume"
-                        " revalidation (usage=%d)\n", host->usage_count);
-                return -EBUSY;
-        }
-        host->usage_count++;
-	spin_unlock_irqrestore(CCISS_LOCK(ctlr), flags);
-
-	for(i=0; i< NWD; i++) {
-		struct gendisk *disk = host->gendisk[i];
-		if (disk) {
-			request_queue_t *q = disk->queue;
-
-			if (disk->flags & GENHD_FL_UP)
-				del_gendisk(disk);
-			if (q)
-				blk_cleanup_queue(q);
-		}
-	}
-
-        /*
-         * Set the partition and block size structures for all volumes
-         * on this controller to zero.  We will reread all of this data
-         */
-        memset(host->drv,        0, sizeof(drive_info_struct)
-						* CISS_MAX_LUN);
-        /*
-         * Tell the array controller not to give us any interrupts while
-         * we check the new geometry.  Then turn interrupts back on when
-         * we're done.
-         */
-        host->access.set_intr_mask(host, CCISS_INTR_OFF);
-        cciss_getgeometry(ctlr);
-        host->access.set_intr_mask(host, CCISS_INTR_ON);
-
-	/* Loop through each real device */ 
-	for (i = 0; i < NWD; i++) {
-		struct gendisk *disk = host->gendisk[i];
-		drive_info_struct *drv = &(host->drv[i]);
-		/* we must register the controller even if no disks exist */
-		/* this is for the online array utilities */
-		if (!drv->heads && i)
-			continue;
-		blk_queue_hardsect_size(drv->queue, drv->block_size);
-		set_capacity(disk, drv->nr_blocks);
-		add_disk(disk);
-	}
-        host->usage_count--;
-        return 0;
-}
-
 static inline void complete_buffers(struct bio *bio, int status)
 {
 	while (bio) {
 		struct bio *xbh = bio->bi_next;
 		int nr_sectors = bio_sectors(bio);
-
+ 
 		bio->bi_next = NULL;
 		blk_finished_io(len);
 		bio_endio(bio, nr_sectors << 9, status ? 0 : -EIO);
 		bio = xbh;
 	}
+}
+
+static void cciss_check_queues(ctlr_info_t *h)
+{
+	int start_queue = h->next_to_run;
+	int i;
+
+	/* check to see if we have maxed out the number of commands that can
+	 * be placed on the queue.  If so then exit.  We do this check here
+	 * in case the interrupt we serviced was from an ioctl and did not
+	 * free any new commands.
+	 */
+	if ((find_first_zero_bit(h->cmd_pool_bits, h->nr_cmds)) == h->nr_cmds)
+		return;
+
+	/* We have room on the queue for more commands.  Now we need to queue
+	 * them up.  We will also keep track of the next queue to run so
+	 * that every queue gets a chance to be started first.
+	 */
+	for (i = 0; i < h->highest_lun + 1; i++) {
+		int curr_queue = (start_queue + i) % (h->highest_lun + 1);
+		/* make sure the disk has been added and the drive is real
+		 * because this can be called from the middle of init_one.
+		 */
+		if (!(h->drv[curr_queue].queue) ||
+		    !(h->drv[curr_queue].heads) ||
+		    h->drv[curr_queue].busy_configuring)
+			continue;
+
+		blk_start_queue(h->gendisk[curr_queue]->queue);
 
+		/* check to see if we have maxed out the number of commands
+		 * that can be placed on the queue.
+		 */
+		if ((find_first_zero_bit(h->cmd_pool_bits, h->nr_cmds)) == h->nr_cmds) {
+			if (curr_queue == start_queue) {
+				h->next_to_run =
+				    (start_queue + 1) % (h->highest_lun + 1);
+				break;
+			} else {
+				h->next_to_run = curr_queue;
+				break;
+			}
+		} else {
+			curr_queue = (curr_queue + 1) % (h->highest_lun + 1);
+		}
+	}
 }
 
 static void cciss_softirq_done(struct request *rq)
@@ -1210,17 +1785,16 @@
 
 	/* command did not need to be retried */
 	/* unmap the DMA mapping for all the scatter gather elements */
-	for(i=0; i<cmd->Header.SGList; i++) {
+	for (i = 0; i < cmd->Header.SGList; i++) {
 		temp64.val32.lower = cmd->SG[i].Addr.lower;
 		temp64.val32.upper = cmd->SG[i].Addr.upper;
 		pci_unmap_page(h->pdev, temp64.val, cmd->SG[i].Len, ddir);
 	}
 
-	complete_buffers(rq->bio, rq->errors);
+	complete_buffers(rq->bio, (rq->errors == 0));
 
 	if (blk_fs_request(rq)) {
 		const int rw = rq_data_dir(rq);
-
 		disk_stat_add(rq->rq_disk, sectors[rw], rq->nr_sectors);
 	}
 
@@ -1228,9 +1802,11 @@
 	printk("Done with %p\n", rq);
 #endif /* CCISS_DEBUG */
 
+	add_disk_randomness(rq->rq_disk);
 	spin_lock_irqsave(&h->lock, flags);
-	end_that_request_last(rq, rq->errors);
-	cmd_free(h, cmd,1);
+	end_that_request_last(rq, (rq->errors == 0));
+	cmd_free(h, cmd, 1);
+	cciss_check_queues(h);
 	spin_unlock_irqrestore(&h->lock, flags);
 }
 
@@ -1241,23 +1817,26 @@
  * will always be left registered with the kernel since it is also the
  * controller node.  Any changes to disk 0 will show up on the next
  * reboot.
-*/
+ */
 static void cciss_update_drive_info(int ctlr, int drv_index)
-  {
+{
 	ctlr_info_t *h = hba[ctlr];
 	struct gendisk *disk;
-	ReadCapdata_struct *size_buff = NULL;
 	InquiryData_struct *inq_buff = NULL;
 	unsigned int block_size;
-	unsigned int total_size;
+	sector_t total_size;
 	unsigned long flags = 0;
 	int ret = 0;
 
-	/* if the disk already exists then deregister it before proceeding*/
-	if (h->drv[drv_index].raid_level != -1){
+	/* if the disk already exists then deregister it before proceeding */
+	if (h->drv[drv_index].raid_level != -1) {
 		spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
 		h->drv[drv_index].busy_configuring = 1;
 		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
+
+		/* deregister_disk sets h->drv[drv_index].queue = NULL */
+		/* which keeps the interrupt handler from starting */
+		/* the queue. */ 
 		ret = deregister_disk(h->gendisk[drv_index],
 			&h->drv[drv_index], 0);
 		h->drv[drv_index].busy_configuring = 0;
@@ -1268,16 +1847,38 @@
 		return;
 
 
-	/* Get information about the disk and modify the driver sturcture */
-	size_buff = kmalloc(sizeof( ReadCapdata_struct), GFP_KERNEL);
-        if (size_buff == NULL)
-		goto mem_msg;
-	inq_buff = kmalloc(sizeof( InquiryData_struct), GFP_KERNEL);
+	/* Get information about the disk and modify the driver structure */
+	inq_buff = kmalloc(sizeof(InquiryData_struct), GFP_KERNEL);
 	if (inq_buff == NULL)
 		goto mem_msg;
 
-	cciss_read_capacity(ctlr, drv_index, size_buff, 1,
+	/* testing to see if 16-byte CDBs are already
+	   being used */
+	if (h->cciss_read == CCISS_READ_16) {
+		cciss_read_capacity_16(h->ctlr, drv_index, 1,
+				&total_size, &block_size);
+		goto geo_inq;
+	}
+
+	cciss_read_capacity(ctlr, drv_index, 1,
 		&total_size, &block_size);
+
+	/*
+	 * If read_capacity returns all F's the logical volume is >2TB
+	 * so we switch to 16-byte CDBs for all read/write ops
+	 */
+ 
+	if (total_size == 0xFFFFFFFFULL) {
+		cciss_read_capacity_16(ctlr, drv_index, 1,
+				&total_size, &block_size);
+		h->cciss_read = CCISS_READ_16;
+		h->cciss_write = CCISS_WRITE_16;
+	} else {
+		h->cciss_read = CCISS_READ_10;
+		h->cciss_write = CCISS_WRITE_10;
+	}
+	
+geo_inq:
 	cciss_geometry_inquiry(ctlr, drv_index, 1, total_size, block_size,
 		inq_buff, &h->drv[drv_index]);
 
@@ -1287,11 +1888,16 @@
 
 
 	/* if it's the controller it's already added */
-	if (drv_index){
+	if (drv_index) {
+
 		disk->queue = blk_init_queue(do_cciss_request, &h->lock);
+		sprintf(disk->disk_name, "cciss/c%dd%d", ctlr, drv_index);
+		disk->major = h->major;
+		disk->first_minor = drv_index << NWD_SHIFT;
+		disk->fops = &cciss_fops;
+		disk->private_data = &h->drv[drv_index];
 
 		/* Set up queue information */
-		disk->queue->backing_dev_info.ra_pages = READ_AHEAD;
 		blk_queue_bounce_limit(disk->queue, hba[ctlr]->pdev->dma_mask);
 
 		/* This is a hardware imposed limit. */
@@ -1304,17 +1910,30 @@
 
 		blk_queue_softirq_done(disk->queue, cciss_softirq_done);
 
+		blk_queue_max_sectors(disk->queue, hba[ctlr]->cciss_sector_size);
+
 		disk->queue->queuedata = hba[ctlr];
 
+		if (!h->drv[drv_index].heads)
+			goto freeret;
+
 		blk_queue_hardsect_size(disk->queue,
 			hba[ctlr]->drv[drv_index].block_size);
 
+
+		cciss_sysfs_stat_inquiry(ctlr, drv_index, 1, &h->drv[drv_index]);
+
+		cciss_add_blk_sysfs_dev(&h->drv[drv_index], disk, h->pdev, drv_index);
+
+		/* Make sure all queue data is written out before */
+		/* setting h->drv[drv_index].queue, as setting this */
+		/* allows the interrupt handler to start the queue */
+		wmb();
 		h->drv[drv_index].queue = disk->queue;
 		add_disk(disk);
 	}
 
 freeret:
-	kfree(size_buff);
 	kfree(inq_buff);
 	return;
 mem_msg:
@@ -1327,13 +1946,13 @@
  * where new drives will be added.  If the index to be returned is greater
  * than the highest_lun index for the controller then highest_lun is set
  * to this new index.  If there are no available indexes then -1 is returned.
-*/
+ */
 static int cciss_find_free_drive_index(int ctlr)
 {
 	int i;
 
-	for (i=0; i < CISS_MAX_LUN; i++){
-		if (hba[ctlr]->drv[i].raid_level == -1){
+	for (i = 0; i < CISS_MAX_LUN; i++){
+		if (hba[ctlr]->drv[i].raid_level == -1) {
 			if (i > hba[ctlr]->highest_lun)
 				hba[ctlr]->highest_lun = i;
 			return i;
@@ -1343,7 +1962,7 @@
 }
 
 /* This function will add and remove logical drives from the Logical
- * drive array of the controller and maintain persistancy of ordering
+ * drive array of the controller and maintain persistency of ordering
  * so that mount points are preserved until the next reboot.  This allows
  * for the removal of logical drives in the middle of the drive array
  * without a re-ordering of those drives.
@@ -1351,7 +1970,7 @@
  * h		= The controller to perform the operations on
  * del_disk	= The disk to remove if specified.  If the value given
  *		  is NULL then no disk is removed.
-*/
+ */
 static int rebuild_lun_table(ctlr_info_t *h, struct gendisk *del_disk)
 {
 	int ctlr = h->ctlr;
@@ -1368,12 +1987,7 @@
 
 	/* Set busy_configuring flag for this operation */
 	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
-	if (h->num_luns >= CISS_MAX_LUN){
-		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
-		return -EINVAL;
-	}
-
-	if (h->busy_configuring){
+	if (h->busy_configuring) {
 		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
 		return -EBUSY;
 	}
@@ -1383,7 +1997,7 @@
 	 * and update the logical drive table.  If it is not NULL then
 	 * we will check if the disk is in use or not.
 	 */
-	if (del_disk != NULL){
+	if (del_disk != NULL) {
 		drv = get_drv(del_disk);
 		drv->busy_configuring = 1;
 		spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
@@ -1405,11 +2019,9 @@
 				TYPE_CMD);
 
 		if (return_code == IO_OK){
-			listlength |= (0xff & (unsigned int)(ld_buff->LUNListLength[0])) << 24;
-			listlength |= (0xff & (unsigned int)(ld_buff->LUNListLength[1])) << 16;
-			listlength |= (0xff & (unsigned int)(ld_buff->LUNListLength[2])) << 8;
-			listlength |= 0xff & (unsigned int)(ld_buff->LUNListLength[3]);
-		} else{ /* reading number of logical volumes failed */
+			listlength =
+				be32_to_cpu(*(__u32 *) ld_buff->LUNListLength);
+		} else { /* reading number of logical volumes failed */
 			printk(KERN_WARNING "cciss: report logical volume"
 				" command failed\n");
 			listlength = 0;
@@ -1417,7 +2029,7 @@
 		}
 
 		num_luns = listlength / 8;	/* 8 bytes per entry */
-		if (num_luns > CISS_MAX_LUN){
+		if (num_luns > CISS_MAX_LUN) {
 			num_luns = CISS_MAX_LUN;
 			printk(KERN_WARNING "cciss: more luns configured"
 				" on controller than can be handled by"
@@ -1428,7 +2040,7 @@
 	 	* Check for updates in the drive information and any new drives
 	 	* on the controller.
 	 	*/
-		for (i=0; i < num_luns; i++){
+		for (i = 0; i < num_luns; i++) {
 			int j;
 
 			drv_found = 0;
@@ -1447,19 +2059,26 @@
 			 * if not is use.  If it does not exist then find
 			 * the first free index and add it.
 			*/
-			for (j=0; j <= h->highest_lun; j++){
-				if (h->drv[j].LunID == lunid){
+			for (j = 0; j <= h->highest_lun; j++) {
+				if (h->drv[j].LunID == lunid) {
 					drv_index = j;
 					drv_found = 1;
 				}
 			}
 
 			/* check if the drive was found already in the array */
-			if (!drv_found){
+			if (!drv_found) {
 				drv_index = cciss_find_free_drive_index(ctlr);
 				if (drv_index == -1)
 					goto freeret;
-
+				/*Check if the gendisk needs to be allocated */
+				if (!h->gendisk[drv_index]) {
+					h->gendisk[drv_index] = alloc_disk(1 << NWD_SHIFT);
+					if (!h->gendisk[drv_index]) {
+						printk(KERN_ERR "cciss: could not allocate new disk %d\n", drv_index);
+						goto mem_msg;
+					}
+				}
 			}
 			h->drv[drv_index].LunID = lunid;
 			cciss_update_drive_info(ctlr, drv_index);
@@ -1490,41 +2109,68 @@
  * clear_all = This flag determines whether or not the disk information
  *             is going to be completely cleared out and the highest_lun
  *             reset.  Sometimes we want to clear out information about
- *             the disk in preperation for re-adding it.  In this case
+ *             the disk in preparation for re-adding it.  In this case
  *             the highest_lun should be left unchanged and the LunID
  *             should not be cleared.
 */
 static int deregister_disk(struct gendisk *disk, drive_info_struct *drv,
 			   int clear_all)
 {
+	int i;
 	ctlr_info_t *h = get_host(disk);
 
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
 	/* make sure logical volume is NOT is use */
-	if(clear_all || (h->gendisk[0] == disk)) {
+	if (clear_all || (h->gendisk[0] == disk)) {
 	if (drv->usage_count > 1)
                 return -EBUSY;
-	}
-        else
-        	if( drv->usage_count > 0 )
+	} else if (drv->usage_count > 0)
                 	return -EBUSY;
 
 	/* invalidate the devices and deregister the disk.  If it is disk
 	 * zero do not deregister it but just zero out it's values.  This
 	 * allows us to delete disk zero but keep the controller registered.
 	*/
-	if (h->gendisk[0] != disk){
+	if (h->gendisk[0] != disk) {
 		if (disk) {
 			request_queue_t *q = disk->queue;
-			if (disk->flags & GENHD_FL_UP)
+			if (disk->flags & GENHD_FL_UP) {
+				cciss_remove_blk_sysfs_dev(disk);
 				del_gendisk(disk);
+			}
 			if (q) {
 				blk_cleanup_queue(q);
+				/* Set drv->queue to NULL so that we do not try
+				 * to call blk_start_queue on this queue in the
+				 * interrupt handler
+				*/
 				drv->queue = NULL;
 			}
+			/* If clear_all is set then we are deleting the logical
+			 * drive, not just refreshing its info.  For drives
+			 * other than disk 0 we will call put_disk.  We do not
+			 * do this for disk 0 as we need it to be able to
+			 * configure the controller.
+			*/
+			if (clear_all) {
+				/* This isn't pretty, but we need to find the
+				 * disk in our array and NULL our the pointer.
+				 * This is so that we will call alloc_disk if
+				 * this index is used again later.
+				*/
+				for (i = 0; i < CISS_MAX_LUN; i++) {
+					if (h->gendisk[i] == disk) {
+						h->gendisk[i] = NULL;
+						break;
+					}
+				}
+				put_disk(disk);
+			}
 		}
+	} else {
+		set_capacity(disk, 0);
 	}
 
 	--h->num_luns;
@@ -1539,22 +2185,22 @@
 				 * array is free.
 				*/
 
-	if (clear_all){
-	/* check to see if it was the last disk */
-	if (drv == h->drv + h->highest_lun) {
-		/* if so, find the new hightest lun */
-		int i, newhighest =-1;
-		for(i=0; i<h->highest_lun; i++) {
-			/* if the disk has size > 0, it is available */
-				if (h->drv[i].heads)
-				newhighest = i;
+	if (clear_all) {
+		/* check to see if it was the last disk */
+		if (drv == h->drv + h->highest_lun) {
+			/* if so, find the new hightest lun */
+			int i, newhighest = -1;
+			for (i = 0; i < h->highest_lun; i++) {
+				/* if the disk has size > 0, it is available */
+					if (h->drv[i].heads)
+						newhighest = i;
+			}
+			h->highest_lun = newhighest;
 		}
-		h->highest_lun = newhighest;
-	}
 
-	drv->LunID = 0;
+		drv->LunID = 0;
 	}
-	return(0);
+	return 0;
 }
 
 static int fill_cmd(CommandList_struct *c, __u8 cmd, int ctlr, void *buff,
@@ -1565,24 +2211,24 @@
 	unsigned int log_unit, __u8 page_code, unsigned char *scsi3addr,
 	int cmd_type)
 {
-	ctlr_info_t *h= hba[ctlr];
+	ctlr_info_t *h = hba[ctlr];
 	u64bit buff_dma_handle;
 	int status = IO_OK;
 
 	c->cmd_type = CMD_IOCTL_PEND;
 	c->Header.ReplyQueue = 0;
-	if( buff != NULL) {
+	if (buff != NULL) {
 		c->Header.SGList = 1;
-		c->Header.SGTotal= 1;
+		c->Header.SGTotal = 1;
 	} else {
 		c->Header.SGList = 0;
-                c->Header.SGTotal= 0;
+                c->Header.SGTotal = 0;
 	}
 	c->Header.Tag.lower = c->busaddr;
 
 	c->Request.Type.Type = cmd_type;
 	if (cmd_type == TYPE_CMD) {
-		switch(cmd) {
+		switch (cmd) {
 		case  CISS_INQUIRY:
 			/* If the logical unit number is 0 then, this is going
 			to controller so It's a physical command
@@ -1592,15 +2238,16 @@
 			otherwise, if use_unit_num == 2,
 			mode = 0(periph dev addr) target = scsi3addr */
 			if (use_unit_num == 1) {
-				c->Header.LUN.LogDev.VolId=
+				c->Header.LUN.LogDev.VolId =
 					h->drv[log_unit].LunID;
                         	c->Header.LUN.LogDev.Mode = 1;
 			} else if (use_unit_num == 2) {
-				memcpy(c->Header.LUN.LunAddrBytes,scsi3addr,8);
+				memcpy(c->Header.LUN.LunAddrBytes, scsi3addr,
+					8);
 				c->Header.LUN.LogDev.Mode = 0;
 			}
 			/* are we trying to read a vital product page */
-			if(page_code != 0) {
+			if (page_code != 0) {
 				c->Request.CDB[1] = 0x01;
 				c->Request.CDB[2] = page_code;
 			}
@@ -1636,6 +2283,20 @@
 			c->Request.Timeout = 0;
 			c->Request.CDB[0] = cmd;
 		break;
+		case CCISS_READ_CAPACITY_16:
+			c->Header.LUN.LogDev.VolId = h->drv[log_unit].LunID;
+			c->Header.LUN.LogDev.Mode = 1;
+			c->Request.CDBLen = 16;
+			c->Request.Type.Attribute = ATTR_SIMPLE;
+			c->Request.Type.Direction = XFER_READ;
+			c->Request.Timeout = 0;
+			c->Request.CDB[0] = cmd;
+			c->Request.CDB[1] = 0x10;
+			c->Request.CDB[10] = (size >> 24) & 0xFF;
+			c->Request.CDB[11] = (size >> 16) & 0xFF;
+			c->Request.CDB[12] = (size >> 8) & 0xFF;
+			c->Request.CDB[13] = size & 0xFF;
+		break;
 		case CCISS_CACHE_FLUSH:
 			c->Request.CDBLen = 12;
 			c->Request.Type.Attribute = ATTR_SIMPLE;
@@ -1647,7 +2308,7 @@
 		default:
 			printk(KERN_WARNING
 				"cciss%d:  Unknown Command 0x%c\n", ctlr, cmd);
-			return(IO_ERROR);
+			return IO_ERROR;
 		}
 	} else if (cmd_type == TYPE_MSG) {
 		switch (cmd) {
@@ -1669,6 +2330,7 @@
 			memset(&c->Request.CDB[0], 0, sizeof(c->Request.CDB));
 			c->Request.CDB[0] = cmd;  /* reset */
 			c->Request.CDB[1] = 0x04; /* reset a LUN */
+			break;
 		case 3:	/* No-Op message */
 			c->Request.CDBLen = 1;
 			c->Request.Type.Attribute = ATTR_SIMPLE;
@@ -1698,6 +2360,7 @@
 	}
 	return status;
 }
+
 static int sendcmd_withirq(__u8	cmd,
 	int	ctlr,
 	void	*buff,
@@ -1712,9 +2375,10 @@
 	u64bit	buff_dma_handle;
 	unsigned long flags;
 	int return_status;
-	DECLARE_COMPLETION(wait);
+	int print_this_error = 1;  /* by default print this error */
+	CCISS_DECLARE_COMPLETION(wait);
 	
-	if ((c = cmd_alloc(h , 0)) == NULL)
+	if ((c = cmd_alloc(h, 0)) == NULL)
 		return -ENOMEM;
 	return_status = fill_cmd(c, cmd, ctlr, buff, size, use_unit_num,
 		log_unit, page_code, NULL, cmd_type);
@@ -1734,22 +2398,56 @@
 	
 	wait_for_completion(&wait);
 
-	if(c->err_info->CommandStatus != 0) 
-	{ /* an error has occurred */ 
-		switch(c->err_info->CommandStatus)
-		{
+	if(c->err_info->CommandStatus != 0) { /* an error has occurred */
+		switch(c->err_info->CommandStatus) {
+			unsigned char sense_key;
 			case CMD_TARGET_STATUS:
-				printk(KERN_WARNING "cciss: cmd %p has "
-					" completed with errors\n", c);
-				if( c->err_info->ScsiStatus)
-                		{
-                    			printk(KERN_WARNING "cciss: cmd %p "
-					"has SCSI Status = %x\n",
-                        			c,  
-						c->err_info->ScsiStatus);
-                		}
+				return_status = IO_ERROR;
+				switch( c->err_info->ScsiStatus) {
+					case 0x02:  /* Check Condition */ 
+					/* Check if condition is Unit
+					 * Attention
+					 */
+					if((c->err_info->SenseInfo[2] == 6) &&
+					   (c->retry_count < MAX_CMD_RETRIES))
+					{
+						printk(KERN_WARNING
+						      "cciss%d: retrying unit "
+						      "attention\n", ctlr);
+						c->retry_count++;
+						/* erase old err info */
+						memset(c->err_info, 0,
+						      sizeof(ErrorInfo_struct));
+						return_status = IO_OK;
+						INIT_COMPLETION(wait);
+						goto resend_cmd2;
+					} else {
+						printk(KERN_WARNING "cciss%d: "
+						      "has CHECK CONDITION "
+						      "byte 2 = 0x%x\n", ctlr,
+						      c->err_info->SenseInfo[2]);
+					}
+					/* check the sense key */
+					sense_key = 0xf &
+						c->err_info->SenseInfo[2];
+
+					/* no status or recovered error */
 
+					if((sense_key == 0x0) ||
+					   (sense_key == 0x1) )
+						return_status=IO_OK;
+					break;
+					case 0x18:  /* Reserve Conflict */
+						return_status=IO_ERROR;
+						print_this_error=0;
+				    	break;
+					default: 
+                    				printk(KERN_WARNING "cciss%d:"
+						    " cmd has SCSI Status"
+						    "  = %x\n", ctlr,
+					c->err_info->ScsiStatus);
 			break;
+                 }
 			case CMD_DATA_UNDERRUN:
 			case CMD_DATA_OVERRUN:
 			/* expected for inquire and report lun commands */
@@ -1764,7 +2462,7 @@
 					"protocol error \n", c);
                                 return_status = IO_ERROR;
                         break;
-case CMD_HARDWARE_ERR:
+			case CMD_HARDWARE_ERR:
                                 printk(KERN_WARNING "cciss: cmd %p had " 
                                         " hardware error\n", c);
                                 return_status = IO_ERROR;
@@ -1807,23 +2505,31 @@
 					"unknown status %x\n", c, 
 						c->err_info->CommandStatus); 
 				return_status = IO_ERROR;
+      
+
 		}
 	}	
+	if ((return_status == IO_ERROR) && (print_this_error)) {
+		print_cmd(c);
+	}
+
 	/* unlock the buffers from DMA */
 	buff_dma_handle.val32.lower = c->SG[0].Addr.lower;
 	buff_dma_handle.val32.upper = c->SG[0].Addr.upper;
-	pci_unmap_single( h->pdev, (dma_addr_t) buff_dma_handle.val,
+	pci_unmap_single(h->pdev, (dma_addr_t) buff_dma_handle.val,
 			c->SG[0].Len, PCI_DMA_BIDIRECTIONAL);
 	cmd_free(h, c, 0);
-        return(return_status);
+        return return_status;
 
 }
 static void cciss_geometry_inquiry(int ctlr, int logvol,
-			int withirq, unsigned int total_size,
+			int withirq, sector_t total_size,
 			unsigned int block_size, InquiryData_struct *inq_buff,
 			drive_info_struct *drv)
 {
 	int return_code;
+	unsigned int t;
+
 	memset(inq_buff, 0, sizeof(InquiryData_struct));
 	if (withirq)
 		return_code = sendcmd_withirq(CISS_INQUIRY, ctlr,
@@ -1832,58 +2538,98 @@
 		return_code = sendcmd(CISS_INQUIRY, ctlr, inq_buff,
 			sizeof(*inq_buff), 1, logvol ,0xC1, NULL, TYPE_CMD);
 	if (return_code == IO_OK) {
-		if(inq_buff->data_byte[8] == 0xFF) {
+		if (inq_buff->data_byte[8] == 0xFF) {
 			printk(KERN_WARNING
 				"cciss: reading geometry failed, volume "
 				"does not support reading geometry\n");
-			drv->block_size = block_size;
-			drv->nr_blocks = total_size;
 			drv->heads = 255;
 			drv->sectors = 32; // Sectors per track
-			drv->cylinders = total_size / 255 / 32;
+			drv->raid_level = RAID_UNKNOWN;
 		} else {
-			unsigned int t;
-
-			drv->block_size = block_size;
-			drv->nr_blocks = total_size;
 			drv->heads = inq_buff->data_byte[6];
 			drv->sectors = inq_buff->data_byte[7];
 			drv->cylinders = (inq_buff->data_byte[4] & 0xff) << 8;
 			drv->cylinders += inq_buff->data_byte[5];
 			drv->raid_level = inq_buff->data_byte[8];
-			t = drv->heads * drv->sectors;
-			if (t > 1) {
-				drv->cylinders = total_size/t;
-			}
+		}
+		drv->block_size = block_size;
+		drv->nr_blocks = total_size + 1;
+		t = drv->heads * drv->sectors;
+		if (t > 1) {
+			sector_t real_size = total_size+1;
+			unsigned long rem = sector_div(real_size, t);
+			if (rem)
+				real_size++;
+			drv->cylinders = real_size;
 		}
 	} else { /* Get geometry failed */
 		printk(KERN_WARNING "cciss: reading geometry failed\n");
 	}
-	printk(KERN_INFO "      heads= %d, sectors= %d, cylinders= %d\n\n",
-		drv->heads, drv->sectors, drv->cylinders);
 }
+
 static void
-cciss_read_capacity(int ctlr, int logvol, ReadCapdata_struct *buf,
-		int withirq, unsigned int *total_size, unsigned int *block_size)
+cciss_read_capacity(int ctlr, int logvol, int withirq, sector_t *total_size,
+				unsigned int *block_size)
 {
+	ReadCapdata_struct *buf;
 	int return_code;
-	memset(buf, 0, sizeof(*buf));
+	buf = kmalloc(sizeof(ReadCapdata_struct), GFP_KERNEL);
+	if (buf == NULL) {
+		printk(KERN_WARNING "cciss: out of memory\n");
+		return;
+	}
+	memset(buf, 0, sizeof(ReadCapdata_struct));
+
 	if (withirq)
 		return_code = sendcmd_withirq(CCISS_READ_CAPACITY,
-			ctlr, buf, sizeof(*buf), 1, logvol, 0, TYPE_CMD);
+			ctlr, buf, sizeof(ReadCapdata_struct),
+				1, logvol, 0, TYPE_CMD);
 	else
 		return_code = sendcmd(CCISS_READ_CAPACITY,
-			ctlr, buf, sizeof(*buf), 1, logvol, 0, NULL, TYPE_CMD);
+			ctlr, buf, sizeof(ReadCapdata_struct),
+				1, logvol, 0, NULL, TYPE_CMD);
+	if (return_code == IO_OK) {
+		*total_size = be32_to_cpu(*(__u32 *) buf->total_size);
+		*block_size = be32_to_cpu(*(__u32 *) buf->block_size);
+	} else { /* read capacity command failed */
+		printk(KERN_WARNING "cciss: read capacity failed\n");
+		*total_size = 0;
+		*block_size = BLOCK_SIZE;
+	}
+	kfree(buf);
+	return;
+}
+
+static void
+cciss_read_capacity_16(int ctlr, int logvol, int withirq, sector_t *total_size, 				unsigned int *block_size)
+{
+	ReadCapdata_struct_16 *buf;
+	int return_code;
+	buf = kmalloc(sizeof(ReadCapdata_struct_16), GFP_KERNEL);
+	if (buf == NULL) {
+		printk(KERN_WARNING "cciss: out of memory\n");
+		return;
+	}
+	memset(buf, 0, sizeof(ReadCapdata_struct_16));
+	if (withirq) {
+		return_code = sendcmd_withirq(CCISS_READ_CAPACITY_16,
+			ctlr, buf, sizeof(ReadCapdata_struct_16), 
+				1, logvol, 0, TYPE_CMD);
+	}
+	else {
+		return_code = sendcmd(CCISS_READ_CAPACITY_16,
+			ctlr, buf, sizeof(ReadCapdata_struct_16), 
+				1, logvol, 0, NULL, TYPE_CMD);
+	}
 	if (return_code == IO_OK) {
-		*total_size = be32_to_cpu(*((__be32 *) &buf->total_size[0]))+1;
-		*block_size = be32_to_cpu(*((__be32 *) &buf->block_size[0]));
+		*total_size = be64_to_cpu(*(__u64 *) buf->total_size);
+		*block_size = be32_to_cpu(*(__u32 *) buf->block_size);
 	} else { /* read capacity command failed */
 		printk(KERN_WARNING "cciss: read capacity failed\n");
 		*total_size = 0;
 		*block_size = BLOCK_SIZE;
 	}
-	printk(KERN_INFO "      blocks= %u block_size= %d\n",
-		*total_size, *block_size);
+	kfree(buf);
 	return;
 }
 
@@ -1894,8 +2640,7 @@
 	int logvol;
 	int FOUND=0;
 	unsigned int block_size;
-	unsigned int total_size;
-	ReadCapdata_struct *size_buff = NULL;
+	sector_t total_size;
 	InquiryData_struct *inq_buff = NULL;
 
 	for(logvol=0; logvol < CISS_MAX_LUN; logvol++)
@@ -1908,27 +2653,24 @@
 
 	if (!FOUND) return 1;
 
-	size_buff = kmalloc(sizeof( ReadCapdata_struct), GFP_KERNEL);
-        if (size_buff == NULL)
-        {
-                printk(KERN_WARNING "cciss: out of memory\n");
-                return 1;
-        }
 	inq_buff = kmalloc(sizeof( InquiryData_struct), GFP_KERNEL);
-        if (inq_buff == NULL)
-        {
+	if (inq_buff == NULL) {
                 printk(KERN_WARNING "cciss: out of memory\n");
-		kfree(size_buff);
                 return 1;
         }
-
-	cciss_read_capacity(h->ctlr, logvol, size_buff, 1, &total_size, &block_size);
-	cciss_geometry_inquiry(h->ctlr, logvol, 1, total_size, block_size, inq_buff, drv);
+	if (h->cciss_read == CCISS_READ_10) {
+		cciss_read_capacity(h->ctlr, logvol, 1,
+			&total_size, &block_size);
+	} else {
+		cciss_read_capacity_16(h->ctlr, logvol, 1,
+			&total_size, &block_size);
+	}
+	cciss_geometry_inquiry(h->ctlr, logvol, 1, total_size, block_size,
+					inq_buff, drv);
 
 	blk_queue_hardsect_size(drv->queue, drv->block_size);
 	set_capacity(disk, drv->nr_blocks);
 
-	kfree(size_buff);
 	kfree(inq_buff);
 	return 0;
 }
@@ -1943,14 +2685,17 @@
 	unsigned long done;
 	int i;
 
-	/* Wait (up to 20 seconds) for a command to complete */
+	/* Increase timeout from 20 to 60 seconds to support a
+	 * large number of logical volumes. Otherwise we may
+	 * timeout during init.
+	 */
 
-	for (i = 20 * HZ; i > 0; i--) {
+	for (i = 60 * HZ; i > 0; i--) {
 		done = hba[ctlr]->access.command_completed(hba[ctlr]);
 		if (done == FIFO_EMPTY)
 			schedule_timeout_uninterruptible(1);
 		else
-			return (done);
+			return done;
 	}
 	/* Invalid address to tell caller we ran out of time */
 	return 1;
@@ -1978,7 +2723,7 @@
 	/* or reset) then we don't expect anything weird. */
 	if (cmd != CCISS_RESET_MSG && cmd != CCISS_ABORT_MSG) {
 #endif
-		printk( KERN_WARNING "cciss cciss%d: SendCmd "
+		printk(KERN_WARNING "cciss cciss%d: SendCmd "
 		      "Invalid command list address returned! (%lx)\n",
 			ctlr, complete);
 		/* not much we can do. */
@@ -1988,7 +2733,7 @@
 
 	/* We've sent down an abort or reset, but something else
 	   has completed */
-	if (srl->ncompletions >= (NR_CMDS + 2)) {
+	if (srl->ncompletions >= (hba[ctlr]->nr_cmds + 2)) {
 		/* Uh oh.  No room to save it for later... */
 		printk(KERN_WARNING "cciss%d: Sendcmd: Invalid command addr, "
 			"reject list overflow, command lost!\n", ctlr);
@@ -2021,13 +2766,15 @@
 	CommandList_struct *c;
 	int i;
 	unsigned long complete;
-	ctlr_info_t *info_p= hba[ctlr];
+	ctlr_info_t *info_p = hba[ctlr];
 	u64bit buff_dma_handle;
 	int status, done = 0;
+	unsigned char sense_key;
+	int print_this_error = 1;	/* print errors by default */
 
 	if ((c = cmd_alloc(info_p, 1)) == NULL) {
 		printk(KERN_WARNING "cciss: unable to get memory");
-		return(IO_ERROR);
+		return IO_ERROR;
 	}
 	status = fill_cmd(c, cmd, ctlr, buff, size, use_unit_num,
 		log_unit, page_code, scsi3addr, cmd_type);
@@ -2048,12 +2795,9 @@
         /* Actually it should be completely empty at this time */
 	/* unless we are in here doing error handling for the scsi */
 	/* tape side of the driver. */
-        for (i = 200000; i > 0; i--) 
-	{
+        for (i = 200000; i > 0; i--) {
 		/* if fifo isn't full go */
-                if (!(info_p->access.fifo_full(info_p))) 
-		{
-			
+                if (!(info_p->access.fifo_full(info_p))) {
                         break;
                 }
                 udelay(10);
@@ -2081,11 +2825,9 @@
 			done = 1;
 			break;
 		}
-
 		/* This will need to change for direct lookup completions */
-		if ( (complete & CISS_ERROR_BIT)
-		     && (complete & ~CISS_ERROR_BIT) == c->busaddr)
-		     {
+		if ((complete & CISS_ERROR_BIT)
+		     && (complete & ~CISS_ERROR_BIT) == c->busaddr) {
 			/* if data overrun or underun on Report command 
 				ignore it 
 			*/
@@ -2095,37 +2837,44 @@
 				((c->err_info->CommandStatus == 
 					CMD_DATA_OVERRUN) || 
 				 (c->err_info->CommandStatus == 
-					CMD_DATA_UNDERRUN)
-			 	))
-			{
+					CMD_DATA_UNDERRUN))) {
 				complete = c->busaddr;
 			} else {
-				if (c->err_info->CommandStatus ==
-						CMD_UNSOLICITED_ABORT) {
+				switch(c->err_info->CommandStatus) {
+					case CMD_UNSOLICITED_ABORT:
 					printk(KERN_WARNING "cciss%d: "
-						"unsolicited abort %p\n",
-						ctlr, c);
-					if (c->retry_count < MAX_CMD_RETRIES) {
+						"unsolicited abort\n",
+						ctlr);
+						if (c->retry_count
+							< MAX_CMD_RETRIES) {
 						printk(KERN_WARNING
-						   "cciss%d: retrying %p\n",
-						   ctlr, c);
+                                                   		"cciss%d:"
+								" retrying"
+								"  cmd\n",
+						   ctlr);
 						c->retry_count++;
-						/* erase the old error */
-						/* information */
+	                                                /* erase the old
+							 * error info
+							 */
 						memset(c->err_info, 0,
-						   sizeof(ErrorInfo_struct));
+                                                   		sizeof (ErrorInfo_struct));
 						goto resend_cmd1;
 					} else {
 						printk(KERN_WARNING
-						   "cciss%d: retried %p too "
-						   "many times\n", ctlr, c);
+							   "cciss%d: retried"
+							   " cmd too many "
+							   " times\n", ctlr);
 						status = IO_ERROR;
 						goto cleanup1;
 					}
-				} else if (c->err_info->CommandStatus == CMD_UNABORTABLE) {
-					printk(KERN_WARNING "cciss%d: command could not be aborted.\n", ctlr);
+					break;
+					case CMD_UNABORTABLE:
+						printk(KERN_WARNING "cciss%d"
+							" command could not be"
+							" aborted.\n", ctlr);
 					status = IO_ERROR;
 					goto cleanup1;
+					break;
 				}
 				printk(KERN_WARNING "ciss ciss%d: sendcmd"
 				" Error %x \n", ctlr, 
@@ -2140,6 +2889,15 @@
 				goto cleanup1;
 			}
 		}
+		if ((c->err_info->ScsiStatus) ==
+				CMD_RESERVATION_CONFLICT) {
+			printk(KERN_WARNING "cciss:%d"
+				" device is reserved."
+				"\n", ctlr);
+			print_this_error = 0;
+			status = IO_ERROR;
+			goto cleanup1;
+		}
 		/* This will need changing for direct lookup completions */
                 if (complete != c->busaddr) {
 			if (add_sendcmd_reject(cmd, ctlr, complete) != 0) {
@@ -2151,6 +2909,10 @@
         } while (!done);
 		
 cleanup1:	
+
+	if ((status == IO_ERROR) && (print_this_error))
+		print_cmd(c);
+
 	/* unlock the data buffer from DMA */
 	buff_dma_handle.val32.lower = c->SG[0].Addr.lower;
 	buff_dma_handle.val32.upper = c->SG[0].Addr.upper;
@@ -2162,7 +2924,7 @@
 		do_cciss_intr(0, info_p, NULL);
 #endif
 	cmd_free(info_p, c, 1);
-	return (status);
+	return status;
 } 
 /*
  * Map (physical) PCI mem into (virtual) kernel space
@@ -2171,7 +2933,7 @@
 {
         ulong page_base        = ((ulong) base) & PAGE_MASK;
         ulong page_offs        = ((ulong) base) - page_base;
-        void __iomem *page_remapped = ioremap(page_base, page_offs+size);
+        void __iomem *page_remapped = ioremap(page_base, page_offs + size);
 
         return page_remapped ? (page_remapped + page_offs) : NULL;
 }
@@ -2180,19 +2942,18 @@
  * Takes jobs of the Q and sends them to the hardware, then puts it on 
  * the Q to wait for completion. 
  */ 
-static void start_io( ctlr_info_t *h)
+static void start_io(ctlr_info_t *h)
 {
 	CommandList_struct *c;
 	
-	while(( c = h->reqQ) != NULL )
-	{
+	while(( c = h->reqQ) != NULL ) {
 		/* can't do anything if fifo is full */
 		if ((h->access.fifo_full(h))) {
 			printk(KERN_WARNING "cciss: fifo full\n");
 			break;
 		}
 
-		/* Get the frist entry from the Request Q */ 
+		/* Get the first entry from the Request Q */
 		removeQ(&(h->reqQ), c);
 		h->Qdepth--;
 	
@@ -2200,145 +2961,220 @@
 		h->access.submit_command(h, c);
 		
 		/* Put job onto the completed Q */ 
-		addQ (&(h->cmpQ), c); 
+		addQ(&(h->cmpQ), c);
 	}
 }
 /* Assumes that CCISS_LOCK(h->ctlr) is held. */
 /* Zeros out the error record and then resends the command back */
 /* to the controller */
-static inline void resend_cciss_cmd( ctlr_info_t *h, CommandList_struct *c)
+static inline void resend_cciss_cmd(ctlr_info_t *h, CommandList_struct *c)
 {
 	/* erase the old error information */
 	memset(c->err_info, 0, sizeof(ErrorInfo_struct));
 
 	/* add it to software queue and then send it to the controller */
-	addQ(&(h->reqQ),c);
+	addQ(&(h->reqQ), c);
 	h->Qdepth++;
-	if(h->Qdepth > h->maxQsinceinit)
+	if (h->Qdepth > h->maxQsinceinit)
 		h->maxQsinceinit = h->Qdepth;
 
 	start_io(h);
 }
 
+static inline unsigned int make_status_bytes(unsigned int scsi_status_byte,
+	unsigned int msg_byte, unsigned int host_byte,
+	unsigned int driver_byte)
+{
+	/* inverse of macros in scsi.h */
+	return (scsi_status_byte & 0xff) |
+		((msg_byte & 0xff) << 8) |
+		((host_byte & 0xff) << 16) |
+		((driver_byte & 0xff) << 24);
+}
+
+static inline int evaluate_target_status(CommandList_struct *cmd)
+{
+	unsigned char sense_key;
+	unsigned char status_byte, msg_byte, host_byte, driver_byte;
+	int error_value;
+
+	/* If we get in here, it means we got "target status", that is, scsi status */
+	status_byte = cmd->err_info->ScsiStatus;
+	driver_byte = DRIVER_OK;
+	msg_byte = cmd->err_info->CommandStatus; /* correct?  seems too device specific */
+
+	if (blk_pc_request(cmd->rq))
+		host_byte = DID_PASSTHROUGH;
+	else
+		host_byte = DID_OK;
+
+	error_value = make_status_bytes(status_byte, msg_byte,
+		host_byte, driver_byte);
+
+	if (cmd->err_info->ScsiStatus != CMD_RESERVATION_CONFLICT) {
+		if (cmd->err_info->ScsiStatus != SAM_STAT_CHECK_CONDITION) 
+		if (!blk_pc_request(cmd->rq))
+			printk(KERN_WARNING "cciss: cmd %p "
+			       "has SCSI Status 0x%x\n",
+			       cmd, cmd->err_info->ScsiStatus);
+		return error_value;
+	}
+
+	/* check the sense key */
+	sense_key = 0xf & cmd->err_info->SenseInfo[2];
+	/* no status or recovered error */
+	if (((sense_key == 0x0) || (sense_key == 0x1)) && !blk_pc_request(cmd->rq))
+		error_value = 0;
+
+	if (!blk_pc_request(cmd->rq)) { /* Not SG_IO or similar? */
+		if (error_value != 0)
+			printk(KERN_WARNING "cciss: cmd %p has CHECK CONDITION"
+			       " sense key = 0x%x\n", cmd, sense_key);
+		return error_value;
+	}
+
+	/* SG_IO or similar, copy sense data back */
+	if (cmd->rq->sense) {
+		if (cmd->rq->sense_len > cmd->err_info->SenseLen)
+			cmd->rq->sense_len = cmd->err_info->SenseLen;
+		memcpy(cmd->rq->sense, cmd->err_info->SenseInfo,
+			cmd->rq->sense_len);
+	} else
+		cmd->rq->sense_len = 0;
+
+	return error_value;
+}
+
 /* checks the status of the job and calls complete buffers to mark all 
  * buffers for the completed job. Note that this function does not need
  * to hold the hba/queue lock.
  */ 
-static inline void complete_command( ctlr_info_t *h, CommandList_struct *cmd,
+static inline void complete_command(ctlr_info_t *h, CommandList_struct *cmd,
 		int timeout)
 {
-	int status = 1;
 	int retry_cmd = 0;
-		
+	struct request *rq = cmd->rq;
+	int ctlr = h->ctlr;
+	int print_this_error = 1;	/* print errors by default */
+
+	rq->errors = 0;
 	if (timeout)
-		status = 0; 
+		rq->errors = make_status_bytes(0, 0, 0, DRIVER_TIMEOUT);
 
-	if(cmd->err_info->CommandStatus != 0) 
-	{ /* an error has occurred */ 
-		switch(cmd->err_info->CommandStatus)
-		{
-			unsigned char sense_key;
-			case CMD_TARGET_STATUS:
-				status = 0;
-			
-				if( cmd->err_info->ScsiStatus == 0x02)
-				{
-					printk(KERN_WARNING "cciss: cmd %p "
-                                        	"has CHECK CONDITION "
-						" byte 2 = 0x%x\n", cmd,
-						cmd->err_info->SenseInfo[2]
-					);
-					/* check the sense key */
-					sense_key = 0xf & 
-						cmd->err_info->SenseInfo[2];
-					/* no status or recovered error */
-					if((sense_key == 0x0) ||
-					    (sense_key == 0x1))
-					{
-							status = 1;
-					}
-				} else
-				{
-					printk(KERN_WARNING "cciss: cmd %p "
-                                                "has SCSI Status 0x%x\n",
-						cmd, cmd->err_info->ScsiStatus);
-				}
-			break;
-			case CMD_DATA_UNDERRUN:
-				printk(KERN_WARNING "cciss: cmd %p has"
-					" completed with data underrun "
-					"reported\n", cmd);
-			break;
-			case CMD_DATA_OVERRUN:
-				printk(KERN_WARNING "cciss: cmd %p has"
-					" completed with data overrun "
-					"reported\n", cmd);
-			break;
-			case CMD_INVALID:
-				printk(KERN_WARNING "cciss: cmd %p is "
-					"reported invalid\n", cmd);
-				status = 0;
-			break;
-			case CMD_PROTOCOL_ERR:
-                                printk(KERN_WARNING "cciss: cmd %p has "
-					"protocol error \n", cmd);
-                                status = 0;
-                        break;
-			case CMD_HARDWARE_ERR:
-                                printk(KERN_WARNING "cciss: cmd %p had " 
-                                        " hardware error\n", cmd);
-                                status = 0;
-                        break;
-			case CMD_CONNECTION_LOST:
-				printk(KERN_WARNING "cciss: cmd %p had "
-					"connection lost\n", cmd);
-				status=0;
-			break;
-			case CMD_ABORTED:
-				printk(KERN_WARNING "cciss: cmd %p was "
-					"aborted\n", cmd);
-				status=0;
-			break;
-			case CMD_ABORT_FAILED:
-				printk(KERN_WARNING "cciss: cmd %p reports "
-					"abort failed\n", cmd);
-				status=0;
-			break;
-			case CMD_UNSOLICITED_ABORT:
-				printk(KERN_WARNING "cciss%d: unsolicited "
-					"abort %p\n", h->ctlr, cmd);
-				if (cmd->retry_count < MAX_CMD_RETRIES) {
-					retry_cmd=1;
-					printk(KERN_WARNING
-						"cciss%d: retrying %p\n",
-						h->ctlr, cmd);
-					cmd->retry_count++;
-				} else
-					printk(KERN_WARNING
-						"cciss%d: %p retried too "
-						"many times\n", h->ctlr, cmd);
-				status=0;
-			break;
-			case CMD_TIMEOUT:
-				printk(KERN_WARNING "cciss: cmd %p timedout\n",
-					cmd);
-				status=0;
-			break;
-			default:
-				printk(KERN_WARNING "cciss: cmd %p returned "
-					"unknown status %x\n", cmd, 
-						cmd->err_info->CommandStatus); 
-				status=0;
-		}
+	if(cmd->err_info->CommandStatus == 0) /* no error has occurred */
+		goto after_error_processing;
+
+	switch(cmd->err_info->CommandStatus) {
+	case CMD_TARGET_STATUS:
+		rq->errors = evaluate_target_status(cmd);
+		break;
+	case CMD_DATA_UNDERRUN:
+		if (blk_fs_request(rq))
+			printk(KERN_WARNING "cciss: cmd %p has"
+			       " completed with data underrun "
+			       "reported\n", cmd);
+		break;
+	case CMD_DATA_OVERRUN:
+		if (blk_fs_request(rq))
+			printk(KERN_WARNING "cciss: cmd %p has"
+			       " completed with data overrun "
+			       "reported\n", cmd);
+		break;
+	case CMD_INVALID:
+		printk(KERN_WARNING "cciss%d: cmd is "
+		       "reported invalid\n", ctlr);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ERROR);
+		break;
+	case CMD_PROTOCOL_ERR:
+		printk(KERN_WARNING "cciss%d: cmd has "
+		       "protocol error \n", ctlr);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ERROR);
+		break;
+	case CMD_HARDWARE_ERR:
+		printk(KERN_WARNING "cciss%d: cmd had "
+		       " hardware error\n", ctlr);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ERROR);
+		break;
+	case CMD_CONNECTION_LOST:
+		printk(KERN_WARNING "cciss%d: cmd had "
+		       "connection lost\n", ctlr);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ERROR);
+		break;
+	case CMD_ABORTED:
+		printk(KERN_WARNING "cciss%d: cmd was "
+		       "aborted\n", ctlr);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ABORT);
+		break;
+	case CMD_ABORT_FAILED:
+		printk(KERN_WARNING "cciss%d: cmd reports "
+		       "abort failed\n", ctlr);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ERROR);
+		break;
+	case CMD_UNSOLICITED_ABORT:
+		printk(KERN_WARNING "cciss%d: unsolicited "
+		       "abort\n", ctlr);
+		if (cmd->retry_count < MAX_CMD_RETRIES) {
+			retry_cmd = 1;
+			printk(KERN_WARNING
+			       "cciss%d: retrying cmd\n", ctlr);
+			cmd->retry_count++;
+		} else
+			printk(KERN_WARNING
+			       "cciss%d: cmd retried too "
+			       "many times\n", ctlr);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ABORT);
+		break;
+	case CMD_TIMEOUT:
+		printk(KERN_WARNING "cciss%d: cmd timedout\n", ctlr);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ERROR);
+		break;
+	case CMD_RESERVATION_CONFLICT:
+		printk(KERN_WARNING "reservation conflict in complete_command\n");
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ERROR);
+		print_this_error = 0;
+		break;
+	default:
+		printk(KERN_WARNING "cciss%d: cmd returned "
+		       "unknown status %x\n", ctlr,
+		       cmd->err_info->CommandStatus);
+		rq->errors = make_status_bytes(SAM_STAT_GOOD,
+			cmd->err_info->CommandStatus, DRIVER_OK,
+			blk_pc_request(rq) ? DID_PASSTHROUGH : DID_ERROR);
 	}
+
+after_error_processing:
+
 	/* We need to return this command */
-	if(retry_cmd) {
-		resend_cciss_cmd(h,cmd);
+	if (retry_cmd) {
+		resend_cciss_cmd(h, cmd);
 		return;
-	}	
+	}
+
+	if ((rq->errors != 0) && !blk_pc_request(rq) && print_this_error)
+		print_cmd(cmd);
 
 	cmd->rq->completion_data = cmd;
-	cmd->rq->errors = status;
+#ifdef CONFIG_BLK_DEV_IO_TRACE
+	blk_add_trace_rq(cmd->rq->q, cmd->rq, BLK_TA_COMPLETE);
+#endif
 	blk_complete_request(cmd->rq);
 }
 
@@ -2347,9 +3183,10 @@
  */
 static void do_cciss_request(request_queue_t *q)
 {
-	ctlr_info_t *h= q->queuedata; 
+	ctlr_info_t *h = q->queuedata;
 	CommandList_struct *c;
-	int start_blk, seg;
+	sector_t start_blk;
+	int seg;
 	struct request *creq;
 	u64bit temp64;
 	struct scatterlist tmp_sg[MAXSGENTRIES];
@@ -2367,10 +3204,9 @@
 	if (!creq)
 		goto startio;
 
-	if (creq->nr_phys_segments > MAXSGENTRIES)
-                BUG();
+	BUG_ON(creq->nr_phys_segments > MAXSGENTRIES);
 
-	if (( c = cmd_alloc(h, 1)) == NULL)
+	if ((c = cmd_alloc(h, 1)) == NULL)
 		goto full;
 
 	blkdev_dequeue_request(creq);
@@ -2388,7 +3224,7 @@
 	/* The first 2 bits are reserved for controller error reporting. */
 	c->Header.Tag.lower = (c->cmdindex << 3);
 	c->Header.Tag.lower |= 0x04; /* flag for direct lookup. */
-	c->Header.LUN.LogDev.VolId= drv->LunID;
+	c->Header.LUN.LogDev.VolId = drv->LunID;
 	c->Header.LUN.LogDev.Mode = 1;
 	c->Request.CDBLen = 10; // 12 byte commands not in FW yet;
 	c->Request.Type.Type =  TYPE_CMD; // It is a command. 
@@ -2396,10 +3232,10 @@
 	c->Request.Type.Direction = 
 		(rq_data_dir(creq) == READ) ? XFER_READ: XFER_WRITE; 
 	c->Request.Timeout = 0; // Don't time out	
-	c->Request.CDB[0] = (rq_data_dir(creq) == READ) ? CCISS_READ : CCISS_WRITE;
+	c->Request.CDB[0] = (rq_data_dir(creq) == READ) ? h->cciss_read : h->cciss_write;
 	start_blk = creq->sector;
 #ifdef CCISS_DEBUG
-	printk(KERN_DEBUG "ciss: sector =%d nr_sectors=%d\n",(int) creq->sector,
+	printk(KERN_DEBUG "ciss: sector =%d nr_sectors=%d\n", (int)creq->sector,
 		(int) creq->nr_sectors);	
 #endif /* CCISS_DEBUG */
 
@@ -2411,8 +3247,7 @@
 	else
 		dir = PCI_DMA_TODEVICE;
 
-	for (i=0; i<seg; i++)
-	{
+	for (i = 0; i < seg; i++) {
 		c->SG[i].Len = tmp_sg[i].length;
 		temp64.val = (__u64) pci_map_page(h->pdev, tmp_sg[i].page,
 			 		  tmp_sg[i].offset, tmp_sg[i].length,
@@ -2422,7 +3257,7 @@
                 c->SG[i].Ext = 0;  // we are not chaining
 	}
 	/* track how many SG entries we are using */ 
-	if( seg > h->maxSG)
+	if(seg > h->maxSG)
 		h->maxSG = seg; 
 
 #ifdef CCISS_DEBUG
@@ -2430,21 +3265,49 @@
 #endif /* CCISS_DEBUG */
 
 	c->Header.SGList = c->Header.SGTotal = seg;
-	c->Request.CDB[1]= 0;
-	c->Request.CDB[2]= (start_blk >> 24) & 0xff;	//MSB
-	c->Request.CDB[3]= (start_blk >> 16) & 0xff;
-	c->Request.CDB[4]= (start_blk >>  8) & 0xff;
-	c->Request.CDB[5]= start_blk & 0xff;
-	c->Request.CDB[6]= 0; // (sect >> 24) & 0xff; MSB
-	c->Request.CDB[7]= (creq->nr_sectors >>  8) & 0xff; 
-	c->Request.CDB[8]= creq->nr_sectors & 0xff; 
-	c->Request.CDB[9] = c->Request.CDB[11] = c->Request.CDB[12] = 0;
+	if (likely(blk_fs_request(creq))) {
+		if(h->cciss_read == CCISS_READ_10) {
+			c->Request.CDB[1] = 0;
+			c->Request.CDB[2] = (start_blk >> 24) & 0xff;	//MSB
+			c->Request.CDB[3] = (start_blk >> 16) & 0xff;
+			c->Request.CDB[4] = (start_blk >>  8) & 0xff;
+			c->Request.CDB[5] = start_blk & 0xff;
+			c->Request.CDB[6] = 0; // (sect >> 24) & 0xff; MSB
+			c->Request.CDB[7] = (creq->nr_sectors >>  8) & 0xff;
+			c->Request.CDB[8] = creq->nr_sectors & 0xff;
+			c->Request.CDB[9] = c->Request.CDB[11] = c->Request.CDB[12] = 0;
+		} else {
+			c->Request.CDBLen = 16;
+			c->Request.CDB[1] = 0;
+			c->Request.CDB[2] = (start_blk >> 56) & 0xff;	//MSB
+			c->Request.CDB[3] = (start_blk >> 48) & 0xff;
+			c->Request.CDB[4] = (start_blk >> 40) & 0xff;
+			c->Request.CDB[5] = (start_blk >> 32) & 0xff;
+			c->Request.CDB[6] = (start_blk >> 24) & 0xff;
+			c->Request.CDB[7] = (start_blk >> 16) & 0xff;
+			c->Request.CDB[8] = (start_blk >>  8) & 0xff;
+			c->Request.CDB[9] = start_blk & 0xff;
+			c->Request.CDB[10] = (creq->nr_sectors >>  24) & 0xff;
+			c->Request.CDB[11] = (creq->nr_sectors >>  16) & 0xff;
+			c->Request.CDB[12] = (creq->nr_sectors >>  8) & 0xff;
+			c->Request.CDB[13] = creq->nr_sectors & 0xff;
+			c->Request.CDB[14] = c->Request.CDB[15] = 0;
+		}
+	} else if (blk_pc_request(creq)) {
+		c->Request.CDBLen = creq->cmd_len;
+		memcpy(c->Request.CDB, creq->cmd, BLK_MAX_CDB);
+	} else {
+		/* In later kernels, rq->flags is supplanted by rq->cmd_type */
+		printk(KERN_WARNING "cciss%d: bad request type, rq->flags=%ld\n",
+			 h->ctlr, creq->flags);
+		BUG();
+	}
 
 	spin_lock_irq(q->queue_lock);
 
-	addQ(&(h->reqQ),c);
+	addQ(&(h->reqQ), c);
 	h->Qdepth++;
-	if(h->Qdepth > h->maxQsinceinit)
+	if (h->Qdepth > h->maxQsinceinit)
 		h->maxQsinceinit = h->Qdepth; 
 
 	goto queue;
@@ -2480,7 +3343,7 @@
 static inline int interrupt_pending(ctlr_info_t *h)
 {
 #ifdef CONFIG_CISS_SCSI_TAPE
-	return ( h->access.intr_pending(h) 
+	return (h->access.intr_pending(h)
 		|| (h->scsi_rejects.ncompletions > 0));
 #else
 	return h->access.intr_pending(h);
@@ -2505,8 +3368,6 @@
 	CommandList_struct *c;
 	unsigned long flags;
 	__u32 a, a1, a2;
-	int j;
-	int start_queue = h->next_to_run;
 
 	if (interrupt_not_for_us(h))
 		return IRQ_NONE;
@@ -2516,12 +3377,14 @@
 	 */
 	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
 	while (interrupt_pending(h)) {
-		while((a = get_next_completion(h)) != FIFO_EMPTY) {
+		while ((a = get_next_completion(h)) != FIFO_EMPTY) {
 			a1 = a;
 			if ((a & 0x04)) {
 				a2 = (a >> 3);
-				if (a2 >= NR_CMDS) {
+				if (a2 >= h->nr_cmds) {
 					printk(KERN_WARNING "cciss: controller cciss%d failed, stopping.\n", h->ctlr);
+					spin_unlock_irqrestore(
+						CCISS_LOCK(h->ctlr), flags);
 					fail_all_cmds(h->ctlr);
 					return IRQ_HANDLED;
 				}
@@ -2535,7 +3398,7 @@
 					printk(KERN_WARNING "cciss: Completion of %08x ignored\n", a1);
 				continue;	
 			} 
-			while(c->busaddr != a) {
+			while (c->busaddr != a) {
 				c = c->next;
 				if (c == h->cmpQ) 
 					break;
@@ -2560,66 +3423,25 @@
 			}
 		}
 	}
-
- 	/* check to see if we have maxed out the number of commands that can
- 	 * be placed on the queue.  If so then exit.  We do this check here
- 	 * in case the interrupt we serviced was from an ioctl and did not
- 	 * free any new commands.
-	 */
- 	if ((find_first_zero_bit(h->cmd_pool_bits, NR_CMDS)) == NR_CMDS)
- 		goto cleanup;
-
- 	/* We have room on the queue for more commands.  Now we need to queue
- 	 * them up.  We will also keep track of the next queue to run so
- 	 * that every queue gets a chance to be started first.
- 	*/
-	for (j=0; j < h->highest_lun + 1; j++){
-		int curr_queue = (start_queue + j) % (h->highest_lun + 1);
- 		/* make sure the disk has been added and the drive is real
- 		 * because this can be called from the middle of init_one.
- 		*/
-		if(!(h->drv[curr_queue].queue) ||
-		 		   !(h->drv[curr_queue].heads))
- 			continue;
- 		blk_start_queue(h->gendisk[curr_queue]->queue);
-
- 		/* check to see if we have maxed out the number of commands
- 		 * that can be placed on the queue.
- 		*/
- 		if ((find_first_zero_bit(h->cmd_pool_bits, NR_CMDS)) == NR_CMDS)
- 		{
- 			if (curr_queue == start_queue){
-				h->next_to_run = (start_queue + 1) % (h->highest_lun + 1);
- 				goto cleanup;
- 			} else {
- 				h->next_to_run = curr_queue;
- 				goto cleanup;
- 	}
- 		} else {
-			curr_queue = (curr_queue + 1) % (h->highest_lun + 1);
- 		}
- 	}
-
-cleanup:
 	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
 	return IRQ_HANDLED;
 }
 /* 
- *  We cannot read the structure directly, for portablity we must use 
+ *  We cannot read the structure directly, for portability we must use
  *   the io functions.
  *   This is for debug only. 
  */
 #ifdef CCISS_DEBUG
-static void print_cfg_table( CfgTable_struct *tb)
+static void print_cfg_table(CfgTable_struct *tb)
 {
 	int i;
 	char temp_name[17];
 
 	printk("Controller Configuration information\n");
 	printk("------------------------------------\n");
-	for(i=0;i<4;i++)
+	for (i = 0; i < 4; i++)
 		temp_name[i] = readb(&(tb->Signature[i]));
-	temp_name[4]='\0';
+	temp_name[4] = '\0';
 	printk("   Signature = %s\n", temp_name); 
 	printk("   Spec Number = %d\n", readl(&(tb->SpecValence)));
 	printk("   Transport methods supported = 0x%x\n", 
@@ -2628,14 +3450,14 @@
 				readl(&(tb->TransportActive)));
 	printk("   Requested transport Method = 0x%x\n", 
 			readl(&(tb->HostWrite.TransportRequest)));
-	printk("   Coalese Interrupt Delay = 0x%x\n", 
+	printk("   Coalesce Interrupt Delay = 0x%x\n",
 			readl(&(tb->HostWrite.CoalIntDelay)));
-	printk("   Coalese Interrupt Count = 0x%x\n", 
+	printk("   Coalesce Interrupt Count = 0x%x\n",
 			readl(&(tb->HostWrite.CoalIntCount)));
 	printk("   Max outstanding commands = 0x%d\n", 
 			readl(&(tb->CmdsOutMax)));
 	printk("   Bus Types = 0x%x\n", readl(&(tb-> BusTypes)));
-	for(i=0;i<16;i++)
+	for (i = 0; i < 16; i++)
 		temp_name[i] = readb(&(tb->ServerName[i]));
 	temp_name[16] = '\0';
 	printk("   Server Name = %s\n", temp_name);
@@ -2644,16 +3466,6 @@
 }
 #endif /* CCISS_DEBUG */ 
 
-static void release_io_mem(ctlr_info_t *c)
-{
-	/* if IO mem was not protected do nothing */
-	if( c->io_mem_addr == 0)
-		return;
-	release_region(c->io_mem_addr, c->io_mem_length);
-	c->io_mem_addr = 0;
-	c->io_mem_length = 0;
-}
-
 static int find_PCI_BAR_index(struct pci_dev *pdev,
 				unsigned long pci_bar_addr)
 {
@@ -2661,7 +3473,7 @@
 	if (pci_bar_addr == PCI_BASE_ADDRESS_0) /* looking for BAR zero? */
 		return 0;
 	offset = 0;
-	for (i=0; i<DEVICE_COUNT_RESOURCE; i++) {
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
 		bar_type = pci_resource_flags(pdev, i) &
 			PCI_BASE_ADDRESS_SPACE;
 		if (bar_type == PCI_BASE_ADDRESS_SPACE_IO)
@@ -2684,7 +3496,7 @@
 			}
 		}
  		if (offset == pci_bar_addr - PCI_BASE_ADDRESS_0)
-			return i+1;
+			return i + 1;
 	}
 	return -1;
 }
@@ -2692,8 +3504,8 @@
 /* If MSI/MSI-X is supported by the kernel we will try to enable it on
  * controllers that are capable. If not, we use IO-APIC mode.
  */
-
-static void __devinit cciss_interrupt_mode(ctlr_info_t *c, struct pci_dev *pdev, __u32 board_id)
+static void __devinit cciss_interrupt_mode(ctlr_info_t *c,
+					   struct pci_dev *pdev, __u32 board_id)
 {
 #ifdef CONFIG_PCI_MSI
         int err;
@@ -2719,26 +3531,24 @@
                 }
                 if (err > 0) {
                         printk(KERN_WARNING "cciss: only %d MSI-X vectors "
-                                        "available\n", err);
+                                        " available\n", err);
+			goto default_int_mode;
                 } else {
-                        printk(KERN_WARNING "cciss: MSI-X init failed %d\n",
-						err);
+                        printk(KERN_WARNING "cciss: MSI-X init failed,"
+				" failure mode unknown, error = %d\n", err);
+			goto default_int_mode;
                 }
         }
         if (pci_find_capability(pdev, PCI_CAP_ID_MSI)) {
                 if (!pci_enable_msi(pdev)) {
-                        c->intr[SIMPLE_MODE_INT] = pdev->irq;
                         c->msi_vector = 1;
-                        return;
                 } else {
                         printk(KERN_WARNING "cciss: MSI init failed\n");
-        		c->intr[SIMPLE_MODE_INT] = pdev->irq;
-                        return;
                 }
         }
+default_int_mode:
 #endif /* CONFIG_PCI_MSI */
 	/* if we get here we're going to use the default interrupt mode */
-default_int_mode:
         c->intr[SIMPLE_MODE_INT] = pdev->irq;
 	return;
 }
@@ -2750,53 +3560,34 @@
 	__u64 cfg_offset;
 	__u32 cfg_base_addr;
 	__u64 cfg_base_addr_index;
-	int i;
+	int i, err;
 
 	/* check to see if controller has been disabled */
 	/* BEFORE trying to enable it */
-	(void) pci_read_config_word(pdev, PCI_COMMAND,&command);
-	if(!(command & 0x02))
-	{
-		printk(KERN_WARNING "cciss: controller appears to be disabled\n");
-		return(-1);
+	(void)pci_read_config_word(pdev, PCI_COMMAND,&command);
+	if (!(command & 0x02)) {
+		printk(KERN_WARNING
+			"cciss: controller appears to be disabled\n");
+		return -ENODEV;
 	}
 
-	if (pci_enable_device(pdev))
-	{
+	err = pci_enable_device(pdev);
+	if (err) {
 		printk(KERN_ERR "cciss: Unable to Enable PCI device\n");
-		return( -1);
+		return err;
 	}
 
+	err = pci_request_regions(pdev, "cciss");
+	if (err) {
+		printk(KERN_ERR "cciss: Cannot obtain PCI resources, "
+			"aborting\n");
+		goto err_out_disable_pdev;
+	}
 	subsystem_vendor_id = pdev->subsystem_vendor;
 	subsystem_device_id = pdev->subsystem_device;
 	board_id = (((__u32) (subsystem_device_id << 16) & 0xffff0000) |
 					subsystem_vendor_id);
 
-	/* search for our IO range so we can protect it */
-	for(i=0; i<DEVICE_COUNT_RESOURCE; i++)
-	{
-		/* is this an IO range */ 
-		if( pci_resource_flags(pdev, i) & 0x01 ) {
-			c->io_mem_addr = pci_resource_start(pdev, i);
-			c->io_mem_length = pci_resource_end(pdev, i) -
-				pci_resource_start(pdev, i) +1;
-#ifdef CCISS_DEBUG
-			printk("IO value found base_addr[%d] %lx %lx\n", i,
-				c->io_mem_addr, c->io_mem_length);
-#endif /* CCISS_DEBUG */
-			/* register the IO range */ 
-			if(!request_region( c->io_mem_addr,
-                                        c->io_mem_length, "cciss"))
-			{
-				printk(KERN_WARNING "cciss I/O memory range already in use addr=%lx length=%ld\n",
-				c->io_mem_addr, c->io_mem_length);
-				c->io_mem_addr= 0;
-				c->io_mem_length = 0;
-			} 
-			break;
-		}
-	}
-
 #ifdef CCISS_DEBUG
 	printk("command = %x\n", command);
 	printk("irq = %x\n", pdev->irq);
@@ -2817,11 +3608,11 @@
 #ifdef CCISS_DEBUG
 	printk("address 0 = %x\n", c->paddr);
 #endif /* CCISS_DEBUG */ 
-	c->vaddr = remap_pci_mem(c->paddr, 200);
+	c->vaddr = remap_pci_mem(c->paddr, 0x250);
 
 	/* Wait for the board to become ready.  (PCI hotplug needs this.)
 	 * We poll for up to 120 secs, once per 100ms. */
-	for (i=0; i < 1200; i++) {
+	for (i = 0; i < 1200; i++) {
 		scratchpad = readl(c->vaddr + SA5_SCRATCHPAD_OFFSET);
 		if (scratchpad == CCISS_FIRMWARE_READY)
 			break;
@@ -2830,7 +3621,8 @@
 	}
 	if (scratchpad != CCISS_FIRMWARE_READY) {
 		printk(KERN_WARNING "cciss: Board not ready.  Timed out.\n");
-		return -1;
+		err = -ENODEV;
+		goto err_out_free_res;
 	}
 
 	/* get the address index number */
@@ -2839,15 +3631,14 @@
 #ifdef CCISS_DEBUG
 	printk("cfg base address = %x\n", cfg_base_addr);
 #endif /* CCISS_DEBUG */
-	cfg_base_addr_index =
-		find_PCI_BAR_index(pdev, cfg_base_addr);
+	cfg_base_addr_index = find_PCI_BAR_index(pdev, cfg_base_addr);
 #ifdef CCISS_DEBUG
 	printk("cfg base address index = %x\n", cfg_base_addr_index);
 #endif /* CCISS_DEBUG */
 	if (cfg_base_addr_index == -1) {
 		printk(KERN_WARNING "cciss: Cannot find cfg_base_addr_index\n");
-		release_io_mem(c);
-		return -1;
+		err = -ENODEV;
+		goto err_out_free_res;
 	}
 
 	cfg_offset = readl(c->vaddr + SA5_CTMEM_OFFSET);
@@ -2863,19 +3654,14 @@
 	print_cfg_table(c->cfgtable);
 #endif /* CCISS_DEBUG */
 
-	for(i=0; i<NR_PRODUCTS; i++) {
+	for (i = 0; i < ARRAY_SIZE(products); i++) {
 		if (board_id == products[i].board_id) {
 			c->product_name = products[i].product_name;
 			c->access = *(products[i].access);
+			c->nr_cmds = products[i].nr_cmds;
 			break;
 		}
 	}
-	if (i == NR_PRODUCTS) {
-		printk(KERN_WARNING "cciss: Sorry, I don't know how"
-			" to access the Smart Array controller %08lx\n", 
-				(unsigned long)board_id);
-		return -1;
-	}
 	if (  (readb(&c->cfgtable->Signature[0]) != 'C') ||
 	      (readb(&c->cfgtable->Signature[1]) != 'I') ||
 	      (readb(&c->cfgtable->Signature[2]) != 'S') ||
@@ -2885,6 +3671,27 @@
 		return -1;
 	}
 
+	/* We didn't find the controller in our list. We know the
+	 * signature is valid. If it's an HP device let's try to
+	 * bind to the device and fire it up. Otherwise we bail.
+	 */
+	if (i == ARRAY_SIZE(products)) {
+		if (subsystem_vendor_id == PCI_VENDOR_ID_HP) {
+			c->product_name = products[ARRAY_SIZE(products)-1].product_name;
+			c->access = *(products[ARRAY_SIZE(products)-1].access);
+			c->nr_cmds = products[ARRAY_SIZE(products)-1].nr_cmds;
+			printk(KERN_WARNING "cciss: This is an unknown "
+				"Smart Array controller.\n"
+				"cciss: Please update to the latest driver "
+				"available from www.hp.com.\n");
+		} else {
+			printk(KERN_WARNING "cciss: Sorry, I don't know how"
+				" to access the Smart Array controller %08lx\n"
+					, (unsigned long)board_id);
+			return -1;
+		}
+	}
+
 #ifdef CONFIG_X86
 {
 	/* Need to enable prefetch in the SCSI core for 6400 in x86 */
@@ -2895,6 +3702,28 @@
 }
 #endif
 
+	/* Disabling DMA prefetch for the P600
+	 * An ASIC bug may result in a prefetch beyond
+	 * physical memory.
+	 */
+	if(board_id == 0x3225103C) {
+		__u32 dma_prefetch;
+		dma_prefetch = readl(c->vaddr + I2O_DMA1_CFG);
+		dma_prefetch |= 0x8000;
+		writel(dma_prefetch, c->vaddr + I2O_DMA1_CFG);
+#ifdef __ia64__
+               /* On HP Integrity platforms, turn off DMA refetch
+                * as well.
+                */
+               {
+               __u32 dma_refetch;
+               pci_read_config_dword(pdev, PCI_COMMAND_PARITY, &dma_refetch);
+               dma_refetch |= 0x1;
+               pci_write_config_dword(pdev, PCI_COMMAND_PARITY, dma_refetch);
+               }
+#endif
+	}
+
 #ifdef CCISS_DEBUG
 	printk("Trying to put board into Simple mode\n");
 #endif /* CCISS_DEBUG */ 
@@ -2907,7 +3736,7 @@
 	/* under certain very rare conditions, this can take awhile.
 	 * (e.g.: hot replace a failed 144GB drive in a RAID 5 set right
 	 * as we enter this code.) */
-	for(i=0;i<MAX_CONFIG_WAIT;i++) {
+	for (i = 0; i < MAX_CONFIG_WAIT; i++) {
 		if (!(readl(c->vaddr + SA5_DOORBELL) & CFGTBL_ChangeReq))
 			break;
 		/* delay and try again */
@@ -2922,14 +3751,20 @@
 	print_cfg_table(c->cfgtable);	
 #endif /* CCISS_DEBUG */ 
 
-	if (!(readl(&(c->cfgtable->TransportActive)) & CFGTBL_Trans_Simple))
-	{
+	if (!(readl(&(c->cfgtable->TransportActive)) & CFGTBL_Trans_Simple)) {
 		printk(KERN_WARNING "cciss: unable to get board into"
 					" simple mode\n");
-		return -1;
+		err = -ENODEV;
+		goto err_out_free_res;
 	}
 	return 0;
 
+err_out_free_res:
+	pci_release_regions(pdev);
+
+err_out_disable_pdev:
+	pci_disable_device(pdev);
+	return err;
 }
 
 /* 
@@ -2938,48 +3773,34 @@
 static void cciss_getgeometry(int cntl_num)
 {
 	ReportLunData_struct *ld_buff;
-	ReadCapdata_struct *size_buff;
 	InquiryData_struct *inq_buff;
 	int return_code;
 	int i;
 	int listlength = 0;
 	__u32 lunid = 0;
 	int block_size;
-	int total_size; 
+	sector_t total_size; 
 
-	ld_buff = kmalloc(sizeof(ReportLunData_struct), GFP_KERNEL);
-	if (ld_buff == NULL)
-	{
+	ld_buff = kzalloc(sizeof(ReportLunData_struct), GFP_KERNEL);
+	if (ld_buff == NULL) {
 		printk(KERN_ERR "cciss: out of memory\n");
 		return;
 	}
-	memset(ld_buff, 0, sizeof(ReportLunData_struct));
-	size_buff = kmalloc(sizeof( ReadCapdata_struct), GFP_KERNEL);
-        if (size_buff == NULL)
-        {
-                printk(KERN_ERR "cciss: out of memory\n");
-		kfree(ld_buff);
-                return;
-        }
-	inq_buff = kmalloc(sizeof( InquiryData_struct), GFP_KERNEL);
-        if (inq_buff == NULL)
-        {
+	inq_buff = kmalloc(sizeof(InquiryData_struct), GFP_KERNEL);
+        if (inq_buff == NULL) {
                 printk(KERN_ERR "cciss: out of memory\n");
                 kfree(ld_buff);
-		kfree(size_buff);
                 return;
         }
 	/* Get the firmware version */ 
 	return_code = sendcmd(CISS_INQUIRY, cntl_num, inq_buff, 
 		sizeof(InquiryData_struct), 0, 0 ,0, NULL, TYPE_CMD);
-	if (return_code == IO_OK)
-	{
+	if (return_code == IO_OK) {
 		hba[cntl_num]->firm_ver[0] = inq_buff->data_byte[32];
 		hba[cntl_num]->firm_ver[1] = inq_buff->data_byte[33];
 		hba[cntl_num]->firm_ver[2] = inq_buff->data_byte[34];
 		hba[cntl_num]->firm_ver[3] = inq_buff->data_byte[35];
-	} else /* send command failed */
-	{
+	} else {	 /* send command failed */
 		printk(KERN_WARNING "cciss: unable to determine firmware"
 			" version of controller\n");
 	}
@@ -2987,8 +3808,7 @@
 	return_code = sendcmd(CISS_REPORT_LOG, cntl_num, ld_buff, 
 			sizeof(ReportLunData_struct), 0, 0, 0, NULL, TYPE_CMD);
 
-	if( return_code == IO_OK)
-	{
+	if (return_code == IO_OK) {
 #ifdef CCISS_DEBUG
 		printk("LUN Data\n--------------------------\n");
 #endif /* CCISS_DEBUG */ 
@@ -2997,15 +3817,14 @@
 		listlength |= (0xff & (unsigned int)(ld_buff->LUNListLength[1])) << 16;
 		listlength |= (0xff & (unsigned int)(ld_buff->LUNListLength[2])) << 8;	
 		listlength |= 0xff & (unsigned int)(ld_buff->LUNListLength[3]);
-	} else /* reading number of logical volumes failed */
-	{
+	} else {	 
+		/* reading number of logical volumes failed */
 		printk(KERN_WARNING "cciss: report logical volume"
 			" command failed\n");
 		listlength = 0;
 	}
-	hba[cntl_num]->num_luns = listlength / 8; // 8 bytes pre entry
-	if (hba[cntl_num]->num_luns > CISS_MAX_LUN)
-	{
+	hba[cntl_num]->num_luns = listlength / 8; // 8 bytes per entry
+	if (hba[cntl_num]->num_luns > CISS_MAX_LUN) {
 		printk(KERN_ERR "ciss:  only %d number of logical volumes supported\n",
 			CISS_MAX_LUN);
 		hba[cntl_num]->num_luns = CISS_MAX_LUN;
@@ -3016,11 +3835,9 @@
 		ld_buff->LUNListLength[3],  hba[cntl_num]->num_luns);
 #endif /* CCISS_DEBUG */
 
-	hba[cntl_num]->highest_lun = hba[cntl_num]->num_luns-1;
-//	for(i=0; i<  hba[cntl_num]->num_luns; i++)
-	for(i=0; i < CISS_MAX_LUN; i++)
-	{
-		if (i < hba[cntl_num]->num_luns){
+	hba[cntl_num]->highest_lun = hba[cntl_num]->num_luns - 1;
+	for (i = 0; i < CISS_MAX_LUN; i++) {
+		if (i < hba[cntl_num]->num_luns) {
 		  	lunid = (0xff & (unsigned int)(ld_buff->LUN[i][3]))
 				 << 24;
         		lunid |= (0xff & (unsigned int)(ld_buff->LUN[i][2]))
@@ -3031,15 +3848,33 @@
 		
 		hba[cntl_num]->drv[i].LunID = lunid;
 
-
 #ifdef CCISS_DEBUG
 	  	printk(KERN_DEBUG "LUN[%d]:  %x %x %x %x = %x\n", i, 
 			ld_buff->LUN[i][0], ld_buff->LUN[i][1],
 			ld_buff->LUN[i][2], ld_buff->LUN[i][3],
 			hba[cntl_num]->drv[i].LunID);
 #endif /* CCISS_DEBUG */
-		cciss_read_capacity(cntl_num, i, size_buff, 0,
-			&total_size, &block_size);
+
+		/* testing to see if 16-byte CDBs are already being used */
+		if(hba[cntl_num]->cciss_read == CCISS_READ_16) {
+			cciss_read_capacity_16(cntl_num, i, 0,
+				&total_size, &block_size);
+			goto geo_inq;
+		}
+		cciss_read_capacity(cntl_num, i, 0, &total_size, &block_size);
+
+		/* If read_capacity returns all F's the volume is >2TB */
+		/* so we switch to 16-byte CDBs for all read/write ops */
+		if(total_size == 0xFFFFFFFFULL) {
+			cciss_read_capacity_16(cntl_num, i, 0,
+					&total_size, &block_size);
+			hba[cntl_num]->cciss_read = CCISS_READ_16;
+			hba[cntl_num]->cciss_write = CCISS_WRITE_16;
+		} else {
+			hba[cntl_num]->cciss_read = CCISS_READ_10;
+			hba[cntl_num]->cciss_write = CCISS_WRITE_10;
+		}
+geo_inq:
 			cciss_geometry_inquiry(cntl_num, i, 0, total_size,
 				block_size, inq_buff, &hba[cntl_num]->drv[i]);
 		} else {
@@ -3048,7 +3883,6 @@
 		}
 	}
 	kfree(ld_buff);
-	kfree(size_buff);
 	kfree(inq_buff);
 }	
 
@@ -3056,35 +3890,29 @@
 /* Returns -1 if no free entries are left.  */
 static int alloc_cciss_hba(void)
 {
-	struct gendisk *disk[NWD];
-	int i, n;
-	for (n = 0; n < NWD; n++) {
-		disk[n] = alloc_disk(1 << NWD_SHIFT);
-		if (!disk[n])
-			goto out;
-	}
+	int i;
 
-	for(i=0; i< MAX_CTLR; i++) {
+	for (i = 0; i < MAX_CTLR; i++) {
 		if (!hba[i]) {
 			ctlr_info_t *p;
 			p = kmalloc(sizeof(ctlr_info_t), GFP_KERNEL);
 			if (!p)
 				goto Enomem;
 			memset(p, 0, sizeof(ctlr_info_t));
-			for (n = 0; n < NWD; n++)
-				p->gendisk[n] = disk[n];
+			p->gendisk[0] = alloc_disk(1 << NWD_SHIFT);
+			if (!p->gendisk[0]) {
+				kfree(p);
+				goto Enomem;
+			}
 			hba[i] = p;
 			return i;
 		}
 	}
 	printk(KERN_WARNING "cciss: This driver supports a maximum"
 		" of %d controllers.\n", MAX_CTLR);
-	goto out;
+	return -1;
 Enomem:
 	printk(KERN_ERR "cciss: out of memory.\n");
-out:
-	while (n--)
-		put_disk(disk[n]);
 	return -1;
 }
 
@@ -3094,7 +3922,7 @@
 	int n;
 
 	hba[i] = NULL;
-	for (n = 0; n < NWD; n++)
+	for (n = 0; n < CISS_MAX_LUN; n++)
 		put_disk(p->gendisk[n]);
 	kfree(p);
 }
@@ -3107,18 +3935,19 @@
 static int __devinit cciss_init_one(struct pci_dev *pdev,
 	const struct pci_device_id *ent)
 {
-	request_queue_t *q;
-	int i;
-	int j;
+	int i, k;
+	int j = 0;
 	int rc;
+	int dac;
+	InquiryData_struct	*inq_buff;
 
 	printk(KERN_DEBUG "cciss: Device 0x%x has been found at"
 			" bus %d dev %d func %d\n",
 		pdev->device, pdev->bus->number, PCI_SLOT(pdev->devfn),
 			PCI_FUNC(pdev->devfn));
 	i = alloc_cciss_hba();
-	if(i < 0)
-		return (-1);
+	if (i < 0)
+		return -1;
 
 	hba[i]->busy_initializing = 1;
 
@@ -3131,11 +3960,11 @@
 
 	/* configure PCI DMA stuff */
 	if (!pci_set_dma_mask(pdev, DMA_64BIT_MASK))
-		printk("cciss: using DAC cycles\n");
+		dac = 1;
 	else if (!pci_set_dma_mask(pdev, DMA_32BIT_MASK))
-		printk("cciss: not using DAC cycles\n");
+		dac = 0;
 	else {
-		printk("cciss: no suitable DMA available\n");
+		printk(KERN_ERR "cciss: no suitable DMA available\n");
 		goto clean1;
 	}
 
@@ -3147,45 +3976,62 @@
 	if (i < MAX_CTLR_ORIG)
 		hba[i]->major = COMPAQ_CISS_MAJOR + i;
 	rc = register_blkdev(hba[i]->major, hba[i]->devname);
-	if(rc == -EBUSY || rc == -EINVAL) {
+	if (rc == -EBUSY || rc == -EINVAL) {
 		printk(KERN_ERR
 			"cciss:  Unable to get major number %d for %s "
 			"on hba %d\n", hba[i]->major, hba[i]->devname, i);
 		goto clean1;
-	}
-	else {
+	} else {
 		if (i >= MAX_CTLR_ORIG)
 			hba[i]->major = rc;
 	}
 
 	/* make sure the board interrupts are off */
 	hba[i]->access.set_intr_mask(hba[i], CCISS_INTR_OFF);
-	if( request_irq(hba[i]->intr[SIMPLE_MODE_INT], do_cciss_intr,
-		SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM, 
+	/* If we are running in IO-APIC or MSI mode we register only
+	 * one interrupt. If we're running MSI-X mode we must register
+	 * four interrupts because the hardware ORing is ignored.
+	*/
+	if (hba[i]->msix_vector) {
+		for (k = 0; k < 4; k++) {
+			if (request_irq(hba[i]->intr[k], do_cciss_intr,
+					SA_INTERRUPT | SA_SAMPLE_RANDOM,
+					hba[i]->devname, hba[i])) {
+				printk(KERN_ERR "cciss: Unable to get msi irq %d"
+					" for %s\n",
+					hba[i]->intr[k], hba[i]->devname);
+				goto clean2;
+			}
+		}
+	} else {
+		if (request_irq(hba[i]->intr[SIMPLE_MODE_INT], do_cciss_intr,
+				SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM,
 			hba[i]->devname, hba[i])) {
-		printk(KERN_ERR "cciss: Unable to get irq %d for %s\n",
-			hba[i]->intr[SIMPLE_MODE_INT], hba[i]->devname);
-		goto clean2;
+			printk(KERN_ERR "cciss: Unable to get irq %d for %s\n",
+				hba[i]->intr[SIMPLE_MODE_INT], hba[i]->devname);
+			goto clean2;
+		}
 	}
-	hba[i]->cmd_pool_bits = kmalloc(((NR_CMDS+BITS_PER_LONG-1)/BITS_PER_LONG)*sizeof(unsigned long), GFP_KERNEL);
+
+	hba[i]->cmd_pool_bits = kmalloc(((hba[i]->nr_cmds+BITS_PER_LONG-1)/BITS_PER_LONG)*sizeof(unsigned long), GFP_KERNEL);
 	hba[i]->cmd_pool = (CommandList_struct *)pci_alloc_consistent(
-		hba[i]->pdev, NR_CMDS * sizeof(CommandList_struct), 
+		hba[i]->pdev, hba[i]->nr_cmds * sizeof(CommandList_struct),
 		&(hba[i]->cmd_pool_dhandle));
 	hba[i]->errinfo_pool = (ErrorInfo_struct *)pci_alloc_consistent(
-		hba[i]->pdev, NR_CMDS * sizeof( ErrorInfo_struct), 
+		hba[i]->pdev, hba[i]->nr_cmds * sizeof( ErrorInfo_struct),
 		&(hba[i]->errinfo_pool_dhandle));
-	if((hba[i]->cmd_pool_bits == NULL) 
+	if ((hba[i]->cmd_pool_bits == NULL)
 		|| (hba[i]->cmd_pool == NULL)
 		|| (hba[i]->errinfo_pool == NULL)) {
-                printk( KERN_ERR "cciss: out of memory");
+                printk(KERN_ERR "cciss: out of memory");
 		goto clean4;
 	}
 #ifdef CONFIG_CISS_SCSI_TAPE
 	hba[i]->scsi_rejects.complete = 
 		kmalloc(sizeof(hba[i]->scsi_rejects.complete[0]) * 
-			(NR_CMDS + 5), GFP_KERNEL);
+			(hba[i]->nr_cmds + 5), GFP_KERNEL);
 	if (hba[i]->scsi_rejects.complete == NULL) {
-                printk( KERN_ERR "cciss: out of memory");
+                printk(KERN_ERR "cciss: out of memory");
 		goto clean4;
 	}
 #endif
@@ -3196,10 +4042,10 @@
 	pci_set_drvdata(pdev, hba[i]);
 	/* command and error info recs zeroed out before 
 			they are used */
-        memset(hba[i]->cmd_pool_bits, 0, ((NR_CMDS+BITS_PER_LONG-1)/BITS_PER_LONG)*sizeof(unsigned long));
+        memset(hba[i]->cmd_pool_bits, 0, ((hba[i]->nr_cmds+BITS_PER_LONG-1)/BITS_PER_LONG)*sizeof(unsigned long));
 
 #ifdef CCISS_DEBUG	
-	printk(KERN_DEBUG "Scanning for drives on controller cciss%d\n",i);
+	printk(KERN_DEBUG "Scanning for drives on controller cciss%d\n", i);
 #endif /* CCISS_DEBUG */
 
 	cciss_getgeometry(i);
@@ -3210,22 +4056,35 @@
 	hba[i]->access.set_intr_mask(hba[i], CCISS_INTR_ON);
 
 	cciss_procinit(i);
+	hba[i]->cciss_sector_size = 2048; 
+
 	hba[i]->busy_initializing = 0;
 
-	for(j=0; j < NWD; j++) { /* mfm */
+	do {
 		drive_info_struct *drv = &(hba[i]->drv[j]);
 		struct gendisk *disk = hba[i]->gendisk[j];
+		request_queue_t *q;
+
+		/* Check if the disk was allocated already */
+		if (!disk) {
+			hba[i]->gendisk[j] = alloc_disk(1 << NWD_SHIFT);
+			disk = hba[i]->gendisk[j];
+		}
+
+		/* Check that the disk was able to be allocated */
+		if (!disk) {
+			printk(KERN_ERR "cciss: unable to allocate memory for disk %d\n", j);
+			goto clean4;
+		}
 
 		q = blk_init_queue(do_cciss_request, &hba[i]->lock);
 		if (!q) {
 			printk(KERN_ERR
 			   "cciss:  unable to allocate queue for disk %d\n",
 			   j);
-			break;
+			goto clean4;
 		}
-		drv->queue = q;
 
-		q->backing_dev_info.ra_pages = READ_AHEAD;
 		blk_queue_bounce_limit(q, hba[i]->pdev->dma_mask);
 
 		/* This is a hardware imposed limit. */
@@ -3234,130 +4093,181 @@
 		/* This is a limit in the driver and could be eliminated. */
 		blk_queue_max_phys_segments(q, MAXSGENTRIES);
 
-		blk_queue_max_sectors(q, 512);
+		blk_queue_max_sectors(q, hba[i]->cciss_sector_size);
 
 		blk_queue_softirq_done(q, cciss_softirq_done);
 
 		q->queuedata = hba[i];
-		sprintf(disk->disk_name, "cciss/c%dd%d", i, j);
-		sprintf(disk->devfs_name, "cciss/host%d/target%d", i, j);
-		disk->major = hba[i]->major;
-		disk->first_minor = j << NWD_SHIFT;
-		disk->fops = &cciss_fops;
-		disk->queue = q;
-		disk->private_data = drv;
 		/* we must register the controller even if no disks exist */
 		/* this is for the online array utilities */
-		if(!drv->heads && j)
+		if (!drv->heads && j)
 			continue;
 		blk_queue_hardsect_size(q, drv->block_size);
+		cciss_sysfs_stat_inquiry(i, j, 1, drv);
+		cciss_add_blk_sysfs_dev(drv, disk, pdev, j);
 		set_capacity(disk, drv->nr_blocks);
+		sprintf(disk->disk_name, "cciss/c%dd%d", i, j);
+		disk->major = hba[i]->major;
+		disk->first_minor = j << NWD_SHIFT;
+		disk->fops = &cciss_fops;
+		disk->private_data = drv;
+		disk->queue = q;
+		drv->queue = q;
 		add_disk(disk);
-	}
+		j++;
+	} while (j <= hba[i]->highest_lun);
 
-	return(1);
+	return 1;
 
 clean4:
 #ifdef CONFIG_CISS_SCSI_TAPE
-	if(hba[i]->scsi_rejects.complete)
-		kfree(hba[i]->scsi_rejects.complete);
+	kfree(hba[i]->scsi_rejects.complete);
 #endif
 	kfree(hba[i]->cmd_pool_bits);
-	if(hba[i]->cmd_pool)
+	if (hba[i]->cmd_pool)
 		pci_free_consistent(hba[i]->pdev,
-			NR_CMDS * sizeof(CommandList_struct),
+			hba[i]->nr_cmds * sizeof(CommandList_struct),
 			hba[i]->cmd_pool, hba[i]->cmd_pool_dhandle);
-	if(hba[i]->errinfo_pool)
+	if (hba[i]->errinfo_pool)
 		pci_free_consistent(hba[i]->pdev,
-			NR_CMDS * sizeof( ErrorInfo_struct),
+			hba[i]->nr_cmds * sizeof( ErrorInfo_struct),
 			hba[i]->errinfo_pool,
 			hba[i]->errinfo_pool_dhandle);
-	free_irq(hba[i]->intr[SIMPLE_MODE_INT], hba[i]);
+	if (hba[i]->msix_vector) {
+		for (j = 0; j < 4; j++)
+			free_irq(hba[i]->intr[j], hba[i]);
+	} else {
+		free_irq(hba[i]->intr[SIMPLE_MODE_INT], hba[i]);
+	}
+#ifdef CONFIG_PCI_MSI
+	if (hba[i]->msix_vector)
+		pci_disable_msix(hba[i]->pdev);
+	else if (hba[i]->msi_vector)
+		pci_disable_msi(hba[i]->pdev);
+#endif /* CONFIG_PCI_MSI */
 clean2:
 	unregister_blkdev(hba[i]->major, hba[i]->devname);
 clean1:
-	release_io_mem(hba[i]);
 	hba[i]->busy_initializing = 0;
+	/* cleanup any queues that may have been initialized */
+	for (j = 0; j <= hba[i]->highest_lun; j++){
+		drive_info_struct *drv = &(hba[i]->drv[j]);
+		if (drv->queue)
+			blk_cleanup_queue(drv->queue);
+	}
+	pci_release_regions(pdev);
+	/* This call to pci_disable_device causes the driver to be unable
+	 * to load/unload multiple times.  No reason why yet, but we are
+	 * leaving it out for now.
+	 */
+//	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
 	free_hba(i);
-	return(-1);
+	return -1;
 }
 
-static void __devexit cciss_remove_one (struct pci_dev *pdev)
+static void cciss_shutdown (struct pci_dev *pdev)
 {
 	ctlr_info_t *tmp_ptr;
 	int i, j;
 	char flush_buf[4];
 	int return_code; 
 
-	if (pci_get_drvdata(pdev) == NULL)
-	{
-		printk( KERN_ERR "cciss: Unable to remove device \n");
-		return;
-	}
 	tmp_ptr = pci_get_drvdata(pdev);
+	if (tmp_ptr == NULL)
+		return;
 	i = tmp_ptr->ctlr;
-	if (hba[i] == NULL) 
-	{
-		printk(KERN_ERR "cciss: device appears to "
-			"already be removed \n");
+	if (hba[i] == NULL)
 		return;
-	}
+
 	/* Turn board interrupts off  and send the flush cache command */
 	/* sendcmd will turn off interrupt, and send the flush...
 	* To write all data in the battery backed cache to disks */
 	memset(flush_buf, 0, 4);
 	return_code = sendcmd(CCISS_CACHE_FLUSH, i, flush_buf, 4, 0, 0, 0, NULL,
 				TYPE_CMD);
-	if(return_code != IO_OK)
-	{
+	if(return_code != IO_OK) {
 		printk(KERN_WARNING "Error Flushing cache on controller %d\n", 
 			i);
 	}
-	free_irq(hba[i]->intr[2], hba[i]);
+	if (hba[i]->msix_vector) {
+		 for (j = 0; j < 4; j++)
+			free_irq(hba[i]->intr[j], hba[i]);
+	} else {
+		free_irq(hba[i]->intr[SIMPLE_MODE_INT], hba[i]);
+	}
+}
 
-#ifdef CONFIG_PCI_MSI
-        if (hba[i]->msix_vector)
-                pci_disable_msix(hba[i]->pdev);
-        else if (hba[i]->msi_vector)
-                pci_disable_msi(hba[i]->pdev);
-#endif /* CONFIG_PCI_MSI */
+static void __devexit cciss_remove_one(struct pci_dev *pdev)
+{
+	ctlr_info_t *tmp_ptr;
+	int i, j;
 
-	pci_set_drvdata(pdev, NULL);
-	iounmap(hba[i]->vaddr);
-	cciss_unregister_scsi(i);  /* unhook from SCSI subsystem */
+	if (pci_get_drvdata(pdev) == NULL) {
+		printk(KERN_ERR "cciss: Unable to remove device \n");
+		return;
+	}
+	tmp_ptr = pci_get_drvdata(pdev);
+	i = tmp_ptr->ctlr;
+	if (hba[i] == NULL) {
+		printk(KERN_ERR "cciss: device appears to "
+		       "already be removed \n");
+		return;
+	}
+
+	remove_proc_entry(hba[i]->devname, proc_cciss);
 	unregister_blkdev(hba[i]->major, hba[i]->devname);
-	remove_proc_entry(hba[i]->devname, proc_cciss);	
-	
+
 	/* remove it from the disk list */
-	for (j = 0; j < NWD; j++) {
+	for (j = 0; j < CISS_MAX_LUN; j++) {
 		struct gendisk *disk = hba[i]->gendisk[j];
 		if (disk) {
 			request_queue_t *q = disk->queue;
 
-			if (disk->flags & GENHD_FL_UP) 
+			if (disk->flags & GENHD_FL_UP)
+				cciss_remove_blk_sysfs_dev(disk);
 				del_gendisk(disk);
 			if (q)
 				blk_cleanup_queue(q);
 		}
 	}
 
-	pci_free_consistent(hba[i]->pdev, NR_CMDS * sizeof(CommandList_struct),
+	cciss_unregister_scsi(i);	/* unhook from SCSI subsystem */
+
+	cciss_shutdown(pdev);
+
+#ifdef CONFIG_PCI_MSI
+	if (hba[i]->msix_vector)
+		pci_disable_msix(hba[i]->pdev);
+	else if (hba[i]->msi_vector)
+		pci_disable_msi(hba[i]->pdev);
+#endif				/* CONFIG_PCI_MSI */
+
+	iounmap(hba[i]->vaddr);
+
+	pci_free_consistent(hba[i]->pdev, hba[i]->nr_cmds * sizeof(CommandList_struct),
 			    hba[i]->cmd_pool, hba[i]->cmd_pool_dhandle);
-	pci_free_consistent(hba[i]->pdev, NR_CMDS * sizeof( ErrorInfo_struct),
-		hba[i]->errinfo_pool, hba[i]->errinfo_pool_dhandle);
+	pci_free_consistent(hba[i]->pdev, hba[i]->nr_cmds * sizeof(ErrorInfo_struct),
+			    hba[i]->errinfo_pool, hba[i]->errinfo_pool_dhandle);
 	kfree(hba[i]->cmd_pool_bits);
 #ifdef CONFIG_CISS_SCSI_TAPE
 	kfree(hba[i]->scsi_rejects.complete);
 #endif
- 	release_io_mem(hba[i]);
+	/*
+	 * Deliberately omit pci_disable_device(): it does something nasty to
+	 * Smart Array controllers that pci_enable_device does not undo
+	 */
+	pci_release_regions(pdev);
+	pci_set_drvdata(pdev, NULL);
 	free_hba(i);
-}	
+}
 
 static struct pci_driver cciss_pci_driver = {
-	.name =		"cciss",
-	.probe =	cciss_init_one,
-	.remove =	__devexit_p(cciss_remove_one),
-	.id_table =	cciss_pci_device_id, /* id_table */
+	.name = "cciss",
+	.probe = cciss_init_one,
+	.remove = __devexit_p(cciss_remove_one),
+	.id_table = cciss_pci_device_id,	/* id_table */
+	.shutdown = cciss_shutdown,
 };
 
 /*
@@ -3378,10 +4288,8 @@
 
 	pci_unregister_driver(&cciss_pci_driver);
 	/* double check that all controller entrys have been removed */
-	for (i=0; i< MAX_CTLR; i++) 
-	{
-		if (hba[i] != NULL)
-		{
+	for (i = 0; i < MAX_CTLR; i++) {
+		if (hba[i] != NULL) {
 			printk(KERN_WARNING "cciss: had to remove"
 					" controller %d\n", i);
 			cciss_remove_one(hba[i]->pdev);
@@ -3405,14 +4313,14 @@
 	pci_disable_device(h->pdev); /* Make sure it is really dead. */
 
 	/* move everything off the request queue onto the completed queue */
-	while( (c = h->reqQ) != NULL ) {
+	while ((c = h->reqQ) != NULL) {
 		removeQ(&(h->reqQ), c);
 		h->Qdepth--;
-		addQ (&(h->cmpQ), c);
+		addQ(&(h->cmpQ), c);
 	}
 
 	/* Now, fail everything on the completed queue with a HW error */
-	while( (c = h->cmpQ) != NULL ) {
+	while ((c = h->cmpQ) != NULL) {
 		removeQ(&h->cmpQ, c);
 		c->err_info->CommandStatus = CMD_HARDWARE_ERR;
 		if (c->cmd_type == CMD_RWREQ) {
diff -uNr linux-2.6.16.orig/drivers/block/cciss_cmd.h linux-2.6.16/drivers/block/cciss_cmd.h
--- linux-2.6.16.orig/drivers/block/cciss_cmd.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/block/cciss_cmd.h	2008-10-03 02:40:19.000000000 +0200
@@ -8,7 +8,7 @@
 //general boundary defintions
 #define SENSEINFOBYTES          32//note that this value may vary between host implementations
 #define MAXSGENTRIES            31
-#define MAXREPLYQS              256
+#define MAXREPLYQS              1024
 
 //Command Status value
 #define CMD_SUCCESS             0x0000
@@ -24,6 +24,7 @@
 #define CMD_UNSOLICITED_ABORT   0x000A
 #define CMD_TIMEOUT             0x000B
 #define CMD_UNABORTABLE		0x000C
+#define CMD_RESERVATION_CONFLICT	0x0018
 
 //transfer direction
 #define XFER_NONE               0x00
@@ -55,6 +56,7 @@
 #define I2O_INT_MASK            0x34
 #define I2O_IBPOST_Q            0x40
 #define I2O_OBPOST_Q            0x44
+#define I2O_DMA1_CFG		0x214
 
 //Configuration Table
 #define CFGTBL_ChangeReq        0x00000001l
@@ -88,7 +90,7 @@
 //###########################################################################
 //STRUCTURES
 //###########################################################################
-#define CISS_MAX_LUN	16	
+#define CISS_MAX_LUN		1024
 #define CISS_MAX_PHYS_LUN	1024
 // SCSI-3 Cmmands 
 
@@ -118,11 +120,34 @@
   BYTE block_size[4];	// Size of blocks in bytes
 } ReadCapdata_struct;
 
-// 12 byte commands not implemented in firmware yet. 
-// #define CCISS_READ 	0xa8	// Read(12)
-// #define CCISS_WRITE	0xaa	// Write(12)
- #define CCISS_READ   0x28    // Read(10)
- #define CCISS_WRITE  0x2a    // Write(10)
+#define CCISS_READ_CAPACITY_16 0x9e /* Read Capacity 16 */
+
+/* service action to differentiate a 16 byte read capacity from
+   other commands that use the 0x9e SCSI op code */
+
+#define CCISS_READ_CAPACITY_16_SERVICE_ACT 0x10
+
+typedef struct _ReadCapdata_struct_16
+{
+	BYTE total_size[8];   /* Total size in blocks */
+	BYTE block_size[4];   /* Size of blocks in bytes */
+	BYTE prot_en:1;       /* protection enable bit */
+	BYTE rto_en:1;        /* reference tag own enable bit */
+	BYTE reserved:6;      /* reserved bits */
+	BYTE reserved2[18];   /* reserved bytes per spec */
+} ReadCapdata_struct_16;
+
+/* Define the supported read/write commands for cciss based controllers */
+
+#define CCISS_READ_10   0x28    /* Read(10)  */
+#define CCISS_WRITE_10  0x2a    /* Write(10) */
+#define CCISS_READ_16   0x88    /* Read(16)  */
+#define CCISS_WRITE_16  0x8a    /* Write(16) */
+
+/* Define the CDB lengths supported by cciss based controllers */
+
+#define CDB_LEN10	10
+#define CDB_LEN16	16
 
 // BMIC commands 
 #define BMIC_READ 0x26
diff -uNr linux-2.6.16.orig/drivers/block/cciss.h linux-2.6.16/drivers/block/cciss.h
--- linux-2.6.16.orig/drivers/block/cciss.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/block/cciss.h	2008-10-03 02:40:19.000000000 +0200
@@ -6,7 +6,6 @@
 #include "cciss_cmd.h"
 
 
-#define NWD		16
 #define NWD_SHIFT	4
 #define MAX_PART	(1 << NWD_SHIFT)
 
@@ -37,16 +36,21 @@
 			     * the drive is not in use/configured
 			    */
 	int	busy_configuring; /*This is set when the drive is being removed
-				   *to prevent it from being opened or it's queue
-				   *from being started.
+				   *to prevent it from being opened or it's
+				   *queue from being started.
 				  */
+	char	vendor[9];
+	char	model[17];
+	char	rev[5];
+	BYTE	uid[16];
+	struct device *dev_info;
 } drive_info_struct;
 
 #ifdef CONFIG_CISS_SCSI_TAPE
 
 struct sendcmd_reject_list {
 	int ncompletions;
-	unsigned long *complete; /* array of NR_CMDS tags */
+	unsigned long *complete; /* array of tags */
 };
 
 #endif
@@ -60,8 +64,7 @@
 	__u32	board_id;
 	void __iomem *vaddr;
 	unsigned long paddr;
-	unsigned long io_mem_addr;
-	unsigned long io_mem_length;
+	int nr_cmds;	/* Number of commands allowed on this controller */
 	CfgTable_struct __iomem *cfgtable;
 	int	interrupts_enabled;
 	int	major;
@@ -78,6 +81,10 @@
 	unsigned int intr[4];
 	unsigned int msix_vector;
 	unsigned int msi_vector;
+	int cciss_sector_size; /* For setting blk_queue_max_sectors */
+	BYTE	cciss_read;
+	BYTE	cciss_write;
+	BYTE	cciss_read_capacity;
 
 	// information about each logical volume
 	drive_info_struct drv[CISS_MAX_LUN];
@@ -109,7 +116,7 @@
 	int			next_to_run;
 
 	// Disk structures we need to pass back
-	struct gendisk   *gendisk[NWD];
+	struct gendisk   *gendisk[CISS_MAX_LUN];
 #ifdef CONFIG_CISS_SCSI_TAPE
 	void *scsi_ctlr; /* ptr to structure containing scsi related stuff */
 	/* list of block side commands the scsi error handling sucked up */
@@ -144,6 +151,17 @@
 
 #define CCISS_INTR_ON 	1 
 #define CCISS_INTR_OFF	0
+
+static inline ctlr_info_t *get_host(struct gendisk *disk)
+{
+	return disk->queue->queuedata;
+}
+
+static inline drive_info_struct *get_drv(struct gendisk *disk)
+{
+	return disk->private_data;
+}
+
 /* 
 	Send the command to the hardware 
 */
@@ -281,9 +299,21 @@
 	__u32	board_id;
 	char	*product_name;
 	struct access_method *access;
+	int nr_cmds; /* Max cmds to send to this kind of ctlr. */
+};
+
+struct drv_dynamic {
+	struct device dev;      /* should be the first member */
+	struct gendisk *disk;
 };
 
 #define CCISS_LOCK(i)	(&hba[i]->lock)
 
+#ifdef DECLARE_COMPLETION_ONSTACK
+#define CCISS_DECLARE_COMPLETION(work) DECLARE_COMPLETION_ONSTACK(work)
+#else
+#define CCISS_DECLARE_COMPLETION(work) DECLARE_COMPLETION(work)
+#endif
+
 #endif /* CCISS_H */
 
diff -uNr linux-2.6.16.orig/drivers/block/cciss_scsi.c linux-2.6.16/drivers/block/cciss_scsi.c
--- linux-2.6.16.orig/drivers/block/cciss_scsi.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/block/cciss_scsi.c	2008-10-03 02:40:19.000000000 +0200
@@ -35,12 +35,12 @@
 
 #include <asm/atomic.h>
 
-#include <scsi/scsi.h> 
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h> 
 
 #include "cciss_scsi.h"
+#include "cciss.h"
 
 #define CCISS_ABORT_MSG 0x00
 #define CCISS_RESET_MSG 0x01
@@ -255,7 +255,6 @@
 #define DEVICETYPE(n) (n<0 || n>MAX_SCSI_DEVICE_CODE) ? \
 	"Unknown" : scsi_device_types[n]
 
-#if 0
 static int xmargin=8;
 static int amargin=60;
 
@@ -293,6 +292,7 @@
 	}
 }
 
+
 static void
 print_cmd(CommandList_struct *cp)
 {
@@ -329,18 +329,21 @@
 		cp->ErrDesc.Addr.upper, cp->ErrDesc.Addr.lower, 
 			cp->ErrDesc.Len);
 	printk("sgs..........Errorinfo:\n");
-	printk("scsistatus:%d\n", cp->err_info->ScsiStatus);
-	printk("senselen:%d\n", cp->err_info->SenseLen);
-	printk("cmd status:%d\n", cp->err_info->CommandStatus);
-	printk("resid cnt:%d\n", cp->err_info->ResidualCnt);
-	printk("offense size:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_size);
-	printk("offense byte:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_num);
-	printk("offense value:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_value);
+	printk("scsistatus: 0x%x\n", cp->err_info->ScsiStatus);
+	printk("senselen: 0x%x\n", cp->err_info->SenseLen);
+	printk("cmd status: 0x%x\n", cp->err_info->CommandStatus);
+	printk("resid cnt: 0x%x\n", cp->err_info->ResidualCnt);
+
+	/* If this is a check condition print the SenseInfo */
+	if ((cp->err_info->SenseInfo[2] & 0x0F) == 0x02)
+		print_bytes(cp->err_info->SenseInfo, cp->err_info->SenseLen, 1, 0);
+
+	printk("offense size: 0x%x\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_size);
+	printk("offense byte: 0x%x\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_num);
+	printk("offense value: 0x%x\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_value);
 			
 }
 
-#endif
-
 static int 
 find_bus_target_lun(int ctlr, int *bus, int *target, int *lun)
 {
@@ -578,7 +581,7 @@
 
 	if (cmd->use_sg) {
 		pci_unmap_sg(ctlr->pdev,
-			cmd->buffer, cmd->use_sg,
+			cmd->request_buffer, cmd->use_sg,
 				cmd->sc_data_direction); 
 	}
 	else if (cmd->request_bufflen) {
@@ -652,6 +655,7 @@
 				}
 			break;
 			case CMD_PROTOCOL_ERR:
+				cmd->result = DID_ERROR << 16;
                                 printk(KERN_WARNING "cciss: cp %p has "
 					"protocol error \n", cp);
                         break;
@@ -770,7 +774,7 @@
 			int direction)
 {
 	unsigned long flags;
-	DECLARE_COMPLETION(wait);
+	CCISS_DECLARE_COMPLETION(wait);
 
 	cp->cmd_type = CMD_IOCTL_PEND;		// treat this like an ioctl 
 	cp->scsi_cmd = NULL;
@@ -1211,7 +1215,7 @@
 		struct scsi_cmnd *cmd)
 {
 	unsigned int use_sg, nsegs=0, len;
-	struct scatterlist *scatter = (struct scatterlist *) cmd->buffer;
+	struct scatterlist *scatter = (struct scatterlist *) cmd->request_buffer;
 	__u64 addr64;
 
 	/* is it just one virtual address? */	
@@ -1233,7 +1237,7 @@
 	} /* else, must be a list of virtual addresses.... */
 	else if (cmd->use_sg <= MAXSGENTRIES) {	/* not too many addrs? */
 
-		use_sg = pci_map_sg(pdev, cmd->buffer, cmd->use_sg, 
+		use_sg = pci_map_sg(pdev, cmd->request_buffer, cmd->use_sg, 
 			cmd->sc_data_direction);
 
 		for (nsegs=0; nsegs < use_sg; nsegs++) {
@@ -1441,21 +1445,18 @@
 }
 
 static void
-cciss_proc_tape_report(int ctlr, unsigned char *buffer, off_t *pos, off_t *len)
+cciss_seq_tape_report(struct seq_file *seq, int ctlr)
 {
 	unsigned long flags;
-	int size;
-
-	*pos = *pos -1; *len = *len - 1; // cut off the last trailing newline
 
 	CPQ_TAPE_LOCK(ctlr, flags);
-	size = sprintf(buffer + *len, 
+	seq_printf(seq,
 		"Sequential access devices: %d\n\n",
 			ccissscsi[ctlr].ndevices);
 	CPQ_TAPE_UNLOCK(ctlr, flags);
-	*pos += size; *len += size;
 }
 
+
 /* Need at least one of these error handlers to keep ../scsi/hosts.c from 
  * complaining.  Doing a host- or bus-reset can't do anything good here. 
  * Despite what it might say in scsi_error.c, there may well be commands
@@ -1535,6 +1536,5 @@
 #define cciss_scsi_setup(cntl_num)
 #define cciss_unregister_scsi(ctlr)
 #define cciss_register_scsi(ctlr)
-#define cciss_proc_tape_report(ctlr, buffer, pos, len)
 
 #endif /* CONFIG_CISS_SCSI_TAPE */
diff -uNr linux-2.6.16.orig/include/linux/cciss_ioctl.h linux-2.6.16/include/linux/cciss_ioctl.h
--- linux-2.6.16.orig/include/linux/cciss_ioctl.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/include/linux/cciss_ioctl.h	2008-10-03 02:40:19.000000000 +0200
@@ -11,7 +11,7 @@
 {
 	unsigned char 	bus;
 	unsigned char 	dev_fn;
-	unsigned short	domain;
+	__u16           domain;
 	__u32 		board_id;
 } cciss_pci_info_struct; 
 
@@ -80,7 +80,7 @@
 #define HWORD __u16
 #define DWORD __u32
 
-#define CISS_MAX_LUN	16	
+#define CISS_MAX_LUN		256
 
 #define LEVEL2LUN   1   // index into Target(x) structure, due to byte swapping
 #define LEVEL3LUN   0
