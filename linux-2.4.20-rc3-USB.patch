diff -Nur linux-2.4.19.old/drivers/usb/CDCEther.c linux-2.4.19/drivers/usb/CDCEther.c
--- linux-2.4.19.old/drivers/usb/CDCEther.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/CDCEther.c	Mon Nov 25 12:26:54 2002
@@ -148,7 +148,7 @@
 	// Give this to the USB subsystem so it can tell us 
 	// when more data arrives.
 	if ( (res = usb_submit_urb(&ether_dev->rx_urb)) ) {
-		warn( __FUNCTION__ " failed submit rx_urb %d", res);
+		warn("%s failed submit rx_urb %d", __FUNCTION__, res);
 	}
 	
 	// We are no longer busy, show us the frames!!!
@@ -379,7 +379,7 @@
 
 	// Turn on the USB and let the packets flow!!!
 	if ( (res = enable_net_traffic( ether_dev )) ) {
-		err( __FUNCTION__ "can't enable_net_traffic() - %d", res );
+		err("%s can't enable_net_traffic() - %d", __FUNCTION__, res );
 		return -EIO;
 	}
 
@@ -392,7 +392,7 @@
 	/* Put it out there so the device can send us stuff */
 	if ( (res = usb_submit_urb(&ether_dev->rx_urb)) ) {
 		/* Hmm...  Okay... */
-		warn( __FUNCTION__ " failed rx_urb %d", res );
+		warn( "%s failed rx_urb %d", __FUNCTION__, res );
 	}
 
 	if (ether_dev->properties & HAVE_NOTIFICATION_ELEMENT) {
@@ -406,7 +406,7 @@
 			ether_dev,
 			ether_dev->intr_interval);
 		if ( (res = usb_submit_urb(&ether_dev->intr_urb)) ) {
-			warn( __FUNCTION__ " failed intr_urb %d", res );
+			warn("%s failed intr_urb %d", __FUNCTION__, res );
 		}
 	}
 
@@ -497,14 +497,14 @@
 static void CDC_SetEthernetPacketFilter (ether_dev_t *ether_dev)
 {
 #if 0
-	devrequest *dr = &ether_dev->ctrl_dr;
+	struct usb_ctrlrequest *dr = &ether_dev->ctrl_dr;
 	int res;
 
-	dr->requesttype = USB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE;
-	dr->request = SET_ETHERNET_PACKET_FILTER;
-	dr->value = cpu_to_le16(ether_dev->mode_flags);
-	dr->index = cpu_to_le16((u16)ether_dev->comm_interface);
-	dr->length = 0;
+	dr->bRequestType = USB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE;
+	dr->bRequest = SET_ETHERNET_PACKET_FILTER;
+	dr->wValue = cpu_to_le16(ether_dev->mode_flags);
+	dr->wIndex = cpu_to_le16((u16)ether_dev->comm_interface);
+	dr->wLength = 0;
 
 	FILL_CONTROL_URB(&ether_dev->ctrl_urb,
 			ether_dev->usb,
@@ -515,7 +515,7 @@
 			setpktfilter_done,
 			ether_dev);
 	if ( (res = usb_submit_urb(&ether_dev->ctrl_urb)) ) {
-		warn( __FUNCTION__ " failed submit ctrl_urb %d", res);
+		warn("%s failed submit ctrl_urb %d", __FUNCTION__, res);
 	}
 #endif
 
diff -Nur linux-2.4.19.old/drivers/usb/CDCEther.h linux-2.4.19/drivers/usb/CDCEther.h
--- linux-2.4.19.old/drivers/usb/CDCEther.h	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/CDCEther.h	Mon Nov 25 12:26:54 2002
@@ -75,7 +75,7 @@
 	__u8			bNumberPowerFilters;
 	__u16			mode_flags;
 	int			intr_interval;
-	devrequest		ctrl_dr;
+	struct usb_ctrlrequest	ctrl_dr;
 	struct urb		rx_urb, tx_urb, intr_urb, ctrl_urb;
 	unsigned char		rx_buff[CDC_ETHER_MAX_MTU] __attribute__((aligned(L1_CACHE_BYTES)));
 	unsigned char		tx_buff[CDC_ETHER_MAX_MTU] __attribute__((aligned(L1_CACHE_BYTES)));
diff -Nur linux-2.4.19.old/drivers/usb/Config.in linux-2.4.19/drivers/usb/Config.in
--- linux-2.4.19.old/drivers/usb/Config.in	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/Config.in	Mon Nov 25 12:26:54 2002
@@ -33,6 +33,7 @@
    dep_tristate '  USB Audio support' CONFIG_USB_AUDIO $CONFIG_USB $CONFIG_SOUND
    dep_tristate '    EMI 2|6 USB Audio interface support' CONFIG_USB_EMI26 $CONFIG_USB_AUDIO
    dep_tristate '  USB Bluetooth support (EXPERIMENTAL)' CONFIG_USB_BLUETOOTH $CONFIG_USB $CONFIG_EXPERIMENTAL
+   dep_tristate '  USB MIDI support' CONFIG_USB_MIDI $CONFIG_USB
    if [ "$CONFIG_SCSI" = "n" ]; then
       comment '  SCSI support is needed for USB Storage'
    fi
@@ -44,6 +45,7 @@
       dep_mbool '    Microtech CompactFlash/SmartMedia support' CONFIG_USB_STORAGE_DPCM $CONFIG_USB_STORAGE
       dep_mbool '    HP CD-Writer 82xx support' CONFIG_USB_STORAGE_HP8200e $CONFIG_USB_STORAGE $CONFIG_EXPERIMENTAL
       dep_mbool '    SanDisk SDDR-09 (and other SmartMedia) support' CONFIG_USB_STORAGE_SDDR09 $CONFIG_USB_STORAGE $CONFIG_EXPERIMENTAL
+      dep_mbool '    SanDisk SDDR-55 SmartMedia support' CONFIG_USB_STORAGE_SDDR55 $CONFIG_USB_STORAGE $CONFIG_EXPERIMENTAL
       dep_mbool '    Lexar Jumpshot Compact Flash Reader' CONFIG_USB_STORAGE_JUMPSHOT $CONFIG_USB_STORAGE $CONFIG_EXPERIMENTAL
    dep_tristate '  USB Modem (CDC ACM) support' CONFIG_USB_ACM $CONFIG_USB
    dep_tristate '  USB Printer support' CONFIG_USB_PRINTER $CONFIG_USB
@@ -59,6 +61,7 @@
       dep_tristate '  USB HIDBP Keyboard (basic) support' CONFIG_USB_KBD $CONFIG_USB $CONFIG_INPUT
       dep_tristate '  USB HIDBP Mouse (basic) support' CONFIG_USB_MOUSE $CONFIG_USB $CONFIG_INPUT
    fi
+   dep_tristate '  Aiptek 6000U/8000U tablet support' CONFIG_USB_AIPTEK $CONFIG_USB $CONFIG_INPUT
    dep_tristate '  Wacom Intuos/Graphire tablet support' CONFIG_USB_WACOM $CONFIG_USB $CONFIG_INPUT
 
    comment 'USB Imaging devices'
@@ -101,6 +104,8 @@
    comment 'USB Miscellaneous drivers'
    dep_tristate '  USB Diamond Rio500 support (EXPERIMENTAL)' CONFIG_USB_RIO500 $CONFIG_USB $CONFIG_EXPERIMENTAL
    dep_tristate '  USB Auerswald ISDN support (EXPERIMENTAL)' CONFIG_USB_AUERSWALD $CONFIG_USB $CONFIG_EXPERIMENTAL
+   dep_tristate '  Texas Instruments Graph Link USB (aka SilverLink) cable support' CONFIG_USB_TIGL $CONFIG_USB
    dep_tristate '  Tieman Voyager USB Braille display support (EXPERIMENTAL)' CONFIG_USB_BRLVGER $CONFIG_USB $CONFIG_EXPERIMENTAL
+   dep_tristate '  USB LCD device support' CONFIG_USB_LCD $CONFIG_USB
 fi
 endmenu
diff -Nur linux-2.4.19.old/drivers/usb/Makefile linux-2.4.19/drivers/usb/Makefile
--- linux-2.4.19.old/drivers/usb/Makefile	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/Makefile	Mon Nov 25 12:26:54 2002
@@ -62,6 +62,7 @@
 obj-$(CONFIG_USB_MOUSE)		+= usbmouse.o
 obj-$(CONFIG_USB_HID)		+= hid.o
 obj-$(CONFIG_USB_KBD)		+= usbkbd.o
+obj-$(CONFIG_USB_AIPTEK)	+= aiptek.o
 obj-$(CONFIG_USB_WACOM)		+= wacom.o
 
 obj-$(CONFIG_USB_SCANNER)	+= scanner.o
@@ -69,6 +70,7 @@
 obj-$(CONFIG_USB_PRINTER)	+= printer.o
 obj-$(CONFIG_USB_AUDIO)		+= audio.o
 obj-$(CONFIG_USB_EMI26)		+= emi26.o
+obj-$(CONFIG_USB_MIDI)		+= usb-midi.o
 obj-$(CONFIG_USB_IBMCAM)	+= ibmcam.o usbvideo.o ultracam.o
 obj-$(CONFIG_USB_PWC)		+= pwc.o
 obj-$(CONFIG_USB_DC2XX)		+= dc2xx.o
@@ -85,6 +87,7 @@
 obj-$(CONFIG_USB_KAWETH)        += kaweth.o
 obj-$(CONFIG_USB_CDCETHER)	+= CDCEther.o
 obj-$(CONFIG_USB_RIO500)	+= rio500.o
+obj-$(CONFIG_USB_TIGL)          += tiglusb.o
 obj-$(CONFIG_USB_DSBR)		+= dsbr100.o
 obj-$(CONFIG_USB_MICROTEK)	+= microtek.o
 obj-$(CONFIG_USB_HPUSBSCSI)	+= hpusbscsi.o
@@ -92,6 +95,7 @@
 obj-$(CONFIG_USB_USBNET)	+= usbnet.o
 obj-$(CONFIG_USB_AUERSWALD)	+= auerswald.o
 obj-$(CONFIG_USB_BRLVGER)	+= brlvger.o
+obj-$(CONFIG_USB_LCD)		+= usblcd.o
 
 # Object files in subdirectories
 mod-subdirs	:= serial hcd
diff -Nur linux-2.4.19.old/drivers/usb/acm.c linux-2.4.19/drivers/usb/acm.c
--- linux-2.4.19.old/drivers/usb/acm.c	Fri Oct  5 21:06:08 2001
+++ linux-2.4.19/drivers/usb/acm.c	Mon Nov 25 12:26:54 2002
@@ -184,7 +184,7 @@
 static void acm_ctrl_irq(struct urb *urb)
 {
 	struct acm *acm = urb->context;
-	devrequest *dr = urb->transfer_buffer;
+	struct usb_ctrlrequest *dr = urb->transfer_buffer;
 	unsigned char *data = (unsigned char *)(dr + 1);
 	int newctrl;
 
@@ -195,7 +195,7 @@
 		return;
 	}
 
-	switch (dr->request) {
+	switch (dr->bRequest) {
 
 		case ACM_IRQ_NETWORK:
 
@@ -223,7 +223,7 @@
 
 		default:
 			dbg("unknown control event received: request %d index %d len %d data0 %d data1 %d",
-				dr->request, dr->index, dr->length, data[0], data[1]);
+				dr->bRequest, dr->wIndex, dr->wLength, data[0], data[1]);
 			return;
 	}
 }
diff -Nur linux-2.4.19.old/drivers/usb/aiptek.c linux-2.4.19/drivers/usb/aiptek.c
--- linux-2.4.19.old/drivers/usb/aiptek.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/aiptek.c	Mon Nov 25 12:26:54 2002
@@ -0,0 +1,332 @@
+/*
+ *  Native support for the Aiptek 8000U
+ *
+ *  Copyright (c) 2001 Chris Atenasio		<chris@crud.net>
+ *
+ *  based on wacom.c by
+ *     Vojtech Pavlik      <vojtech@suse.cz>
+ *     Andreas Bach Aaen   <abach@stofanet.dk>
+ *     Clifford Wolf       <clifford@clifford.at>
+ *     Sam Mosel           <sam.mosel@computer.org>
+ *     James E. Blair      <corvus@gnu.org>
+ *     Daniel Egger        <egger@suse.de>
+ *
+ *
+ *  Many thanks to Oliver Kuechemann for his support.
+ *
+ *  ChangeLog:
+ *      v0.1 - Initial release
+ *      v0.2 - Hack to get around fake event 28's.
+ *      v0.3 - Make URB dynamic (Bryan W. Headley, Jun-8-2002)
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION "v0.3"
+#define DRIVER_AUTHOR "Chris Atenasio <chris@crud.net>"
+#define DRIVER_DESC "USB Aiptek 6000U/8000U tablet driver (Linux 2.4.x)"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+/*
+ * Aiptek status packet:
+ *
+ *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
+ * byte0   0     0     0     0     0     0     1     0
+ * byte1  X7    X6    X5    X4    X3    X2    X1    X0
+ * byte2  X15   X14   X13   X12   X11   X10   X9    X8
+ * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
+ * byte4  Y15   Y14   Y13   Y12   Y11   Y10   Y9    Y8
+ * byte5   *     *     *    BS2   BS1   Tip   DV    IR
+ * byte6  P7    P6    P5    P4    P3    P2    P1    P0
+ * byte7  P15   P14   P13   P12   P11   P10   P9    P8
+ *
+ * IR: In Range = Proximity on
+ * DV = Data Valid
+ *
+ * 
+ * Command Summary:
+ *
+ * Command/Data    Description     Return Bytes    Return Value
+ * 0x10/0x00       SwitchToMouse       0
+ * 0x10/0x01       SwitchToTablet      0
+ * 0x18/0x04       Resolution500LPI    0
+ * 0x17/0x00       FilterOn            0
+ * 0x12/0xFF       AutoGainOn          0
+ * 0x01/0x00       GetXExtension       2           MaxX
+ * 0x01/0x01       GetYExtension       2           MaxY
+ * 0x02/0x00       GetModelCode        2           ModelCode = LOBYTE
+ * 0x03/0x00       GetODMCode          2           ODMCode
+ * 0x08/0x00       GetPressureLevels   2           =512
+ * 0x04/0x00       GetFirmwareVersion  2           Firmware Version
+ *
+ *
+ * To initialize the tablet:
+ *
+ * (1) Send command Resolution500LPI
+ * (2) Option Commands (GetXExtension, GetYExtension)
+ * (3) Send command SwitchToTablet
+ */
+
+#define USB_VENDOR_ID_AIPTEK   0x08ca
+
+struct aiptek_features {
+	char *name;
+	int pktlen;
+	int x_max;
+	int y_max;
+	int pressure_min;
+	int pressure_max;
+	void (*irq) (struct urb * urb);
+	unsigned long evbit;
+	unsigned long absbit;
+	unsigned long relbit;
+	unsigned long btnbit;
+	unsigned long digibit;
+};
+
+struct aiptek {
+	signed char data[10];
+	struct input_dev dev;
+	struct usb_device *usbdev;
+	struct urb *irq;
+	struct aiptek_features *features;
+	int tool;
+	int open;
+};
+
+static void
+aiptek_irq(struct urb *urb)
+{
+	struct aiptek *aiptek = urb->context;
+	unsigned char *data = aiptek->data;
+	struct input_dev *dev = &aiptek->dev;
+	int x;
+	int y;
+	int pressure;
+	int proximity;
+
+	if (urb->status)
+		return;
+
+	if ((data[0] & 2) == 0) {
+		dbg("received unknown report #%d", data[0]);
+	}
+
+	proximity = data[5] & 0x01;
+	input_report_key(dev, BTN_TOOL_PEN, proximity);
+
+	x = ((__u32) data[1]) | ((__u32) data[2] << 8);
+	y = ((__u32) data[3]) | ((__u32) data[4] << 8);
+	pressure = ((__u32) data[6]) | ((__u32) data[7] << 8);
+	pressure -= aiptek->features->pressure_min;
+
+	if (pressure < 0) {
+		pressure = 0;
+	}
+
+	if (proximity) {
+		input_report_abs(dev, ABS_X, x);
+		input_report_abs(dev, ABS_Y, y);
+		input_report_abs(dev, ABS_PRESSURE, pressure);
+		input_report_key(dev, BTN_TOUCH, data[5] & 0x04);
+		input_report_key(dev, BTN_STYLUS, data[5] & 0x08);
+		input_report_key(dev, BTN_STYLUS2, data[5] & 0x10);
+	}
+
+}
+
+struct aiptek_features aiptek_features[] = {
+	{"Aiptek 6000U/8000U", 
+	 8, 3000, 2250, 26, 511, aiptek_irq, 0, 0, 0, 0},
+	{NULL, 0}
+};
+
+struct usb_device_id aiptek_ids[] = {
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x20), driver_info:0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, aiptek_ids);
+
+static int
+aiptek_open(struct input_dev *dev)
+{
+	struct aiptek *aiptek = dev->private;
+
+	if (aiptek->open++)
+		return 0;
+
+	aiptek->irq->dev = aiptek->usbdev;
+	if (usb_submit_urb(aiptek->irq))
+		return -EIO;
+
+	return 0;
+}
+
+static void
+aiptek_close(struct input_dev *dev)
+{
+	struct aiptek *aiptek = dev->private;
+
+	if (!--aiptek->open)
+		usb_unlink_urb(aiptek->irq);
+}
+
+static void
+aiptek_command(struct usb_device *dev, unsigned int ifnum,
+	       unsigned char command, unsigned char data)
+{
+	__u8 buf[3];
+
+	buf[0] = 4;
+	buf[1] = command;
+	buf[2] = data;
+
+	if (usb_set_report(dev, ifnum, 3, 2, buf, 3) != 3) {
+		dbg("aiptek_command: 0x%x 0x%x\n", command, data);
+	}
+}
+
+static void*
+aiptek_probe(struct usb_device *dev, unsigned int ifnum,
+	     const struct usb_device_id *id)
+{
+	struct usb_endpoint_descriptor *endpoint;
+	struct aiptek *aiptek;
+
+	if (!(aiptek = kmalloc(sizeof (struct aiptek), GFP_KERNEL)))
+		return NULL;
+
+	memset(aiptek, 0, sizeof (struct aiptek));
+
+	aiptek->irq = usb_alloc_urb(0);
+	if (!aiptek->irq) {
+		kfree(aiptek);
+		return NULL;
+	}
+
+	// Resolution500LPI
+	aiptek_command(dev, ifnum, 0x18, 0x04);
+
+	// SwitchToTablet
+	aiptek_command(dev, ifnum, 0x10, 0x01);
+
+	aiptek->features = aiptek_features + id->driver_info;
+
+	aiptek->dev.evbit[0] |= BIT(EV_KEY) | BIT(EV_ABS) | BIT(EV_MSC) |
+	    aiptek->features->evbit;
+
+	aiptek->dev.absbit[0] |= BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE) |
+	    BIT(ABS_MISC) | aiptek->features->absbit;
+
+	aiptek->dev.relbit[0] |= aiptek->features->relbit;
+
+	aiptek->dev.keybit[LONG(BTN_LEFT)] |= BIT(BTN_LEFT) | BIT(BTN_RIGHT) |
+	    BIT(BTN_MIDDLE) | aiptek->features->btnbit;
+
+	aiptek->dev.keybit[LONG(BTN_DIGI)] |= BIT(BTN_TOOL_PEN) |
+	    BIT(BTN_TOOL_MOUSE) | BIT(BTN_TOUCH) |
+	    BIT(BTN_STYLUS) | BIT(BTN_STYLUS2) | aiptek->features->digibit;
+
+	aiptek->dev.mscbit[0] = BIT(MSC_SERIAL);
+
+	aiptek->dev.absmax[ABS_X] = aiptek->features->x_max;
+	aiptek->dev.absmax[ABS_Y] = aiptek->features->y_max;
+	aiptek->dev.absmax[ABS_PRESSURE] = aiptek->features->pressure_max -
+	    aiptek->features->pressure_min;
+
+	aiptek->dev.absfuzz[ABS_X] = 0;
+	aiptek->dev.absfuzz[ABS_Y] = 0;
+
+	aiptek->dev.private = aiptek;
+	aiptek->dev.open = aiptek_open;
+	aiptek->dev.close = aiptek_close;
+
+	aiptek->dev.name = aiptek->features->name;
+	aiptek->dev.idbus = BUS_USB;
+	aiptek->dev.idvendor = dev->descriptor.idVendor;
+	aiptek->dev.idproduct = dev->descriptor.idProduct;
+	aiptek->dev.idversion = dev->descriptor.bcdDevice;
+	aiptek->usbdev = dev;
+
+	endpoint = dev->config[0].interface[ifnum].altsetting[0].endpoint + 0;
+
+	FILL_INT_URB(aiptek->irq,
+		  dev,
+		  usb_rcvintpipe(dev, endpoint->bEndpointAddress),
+		         aiptek->data,
+		  aiptek->features->pktlen,
+		         aiptek->features->irq,
+		  aiptek,
+		  endpoint->bInterval);
+
+	input_register_device(&aiptek->dev);
+
+	printk(KERN_INFO "input%d: %s on usb%d:%d.%d\n",
+	       aiptek->dev.number, aiptek->features->name, dev->bus->busnum,
+	       dev->devnum, ifnum);
+
+	return aiptek;
+}
+
+static void
+aiptek_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct aiptek *aiptek = ptr;
+	usb_unlink_urb(aiptek->irq);
+	input_unregister_device(&aiptek->dev);
+	usb_free_urb(aiptek->irq);
+	kfree(aiptek);
+}
+
+static struct usb_driver aiptek_driver = {
+	name:"aiptek",
+	probe:aiptek_probe,
+	disconnect:aiptek_disconnect,
+	id_table:aiptek_ids,
+};
+
+static int __init
+aiptek_init(void)
+{
+	usb_register(&aiptek_driver);
+	info(DRIVER_VERSION " " DRIVER_AUTHOR);
+	info(DRIVER_DESC);
+	return 0;
+}
+
+static void __exit
+aiptek_exit(void)
+{
+	usb_deregister(&aiptek_driver);
+}
+
+module_init(aiptek_init);
+module_exit(aiptek_exit);
diff -Nur linux-2.4.19.old/drivers/usb/audio.c linux-2.4.19/drivers/usb/audio.c
--- linux-2.4.19.old/drivers/usb/audio.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/audio.c	Mon Nov 25 12:26:54 2002
@@ -297,13 +297,13 @@
 #define FLG_CONNECTED    32
 
 struct my_data_urb {
-	urb_t urb;
-	iso_packet_descriptor_t isoframe[DESCFRAMES];
+	struct urb urb;
+	struct iso_packet_descriptor isoframe[DESCFRAMES];
 };
 
 struct my_sync_urb {
-	urb_t urb;
-	iso_packet_descriptor_t isoframe[SYNCFRAMES];
+	struct urb urb;
+	struct iso_packet_descriptor isoframe[SYNCFRAMES];
 };
 
 
@@ -833,7 +833,7 @@
 	}
 }		
 
-static int usbin_prepare_desc(struct usbin *u, purb_t urb)
+static int usbin_prepare_desc(struct usbin *u, struct urb *urb)
 {
 	unsigned int i, maxsize, offs;
 
@@ -850,7 +850,7 @@
  * return value: 0 if descriptor should be restarted, -1 otherwise
  * convert sample format on the fly if necessary
  */
-static int usbin_retire_desc(struct usbin *u, purb_t urb)
+static int usbin_retire_desc(struct usbin *u, struct urb *urb)
 {
 	unsigned int i, ufmtsh, dfmtsh, err = 0, cnt, scnt, dmafree;
 	unsigned char *cp;
@@ -930,7 +930,7 @@
 /*
  * we output sync data
  */
-static int usbin_sync_prepare_desc(struct usbin *u, purb_t urb)
+static int usbin_sync_prepare_desc(struct usbin *u, struct urb *urb)
 {
 	unsigned char *cp = urb->transfer_buffer;
 	unsigned int i, offs;
@@ -948,7 +948,7 @@
 /*
  * return value: 0 if descriptor should be restarted, -1 otherwise
  */
-static int usbin_sync_retire_desc(struct usbin *u, purb_t urb)
+static int usbin_sync_retire_desc(struct usbin *u, struct urb *urb)
 {
 	unsigned int i;
 	
@@ -996,7 +996,7 @@
 {
 	struct usb_device *dev = as->state->usbdev;
 	struct usbin *u = &as->usbin;
-	purb_t urb;
+	struct urb *urb;
 	unsigned long flags;
 	unsigned int maxsze, bufsz;
 
@@ -1186,7 +1186,7 @@
 	}
 }		
 
-static int usbout_prepare_desc(struct usbout *u, purb_t urb)
+static int usbout_prepare_desc(struct usbout *u, struct urb *urb)
 {
 	unsigned int i, ufmtsh, dfmtsh, err = 0, cnt, scnt, offs;
 	unsigned char *cp = urb->transfer_buffer;
@@ -1238,7 +1238,7 @@
 /*
  * return value: 0 if descriptor should be restarted, -1 otherwise
  */
-static int usbout_retire_desc(struct usbout *u, purb_t urb)
+static int usbout_retire_desc(struct usbout *u, struct urb *urb)
 {
 	unsigned int i;
 
@@ -1285,7 +1285,7 @@
 	spin_unlock_irqrestore(&as->lock, flags);
 }
 
-static int usbout_sync_prepare_desc(struct usbout *u, purb_t urb)
+static int usbout_sync_prepare_desc(struct usbout *u, struct urb *urb)
 {
 	unsigned int i, offs;
 
@@ -1299,7 +1299,7 @@
 /*
  * return value: 0 if descriptor should be restarted, -1 otherwise
  */
-static int usbout_sync_retire_desc(struct usbout *u, purb_t urb)
+static int usbout_sync_retire_desc(struct usbout *u, struct urb *urb)
 {
 	unsigned char *cp = urb->transfer_buffer;
 	unsigned int f, i;
@@ -1361,7 +1361,7 @@
 {
 	struct usb_device *dev = as->state->usbdev;
 	struct usbout *u = &as->usbout;
-	purb_t urb;
+	struct urb *urb;
 	unsigned long flags;
 	unsigned int maxsze, bufsz;
 
diff -Nur linux-2.4.19.old/drivers/usb/auerswald.c linux-2.4.19/drivers/usb/auerswald.c
--- linux-2.4.19.old/drivers/usb/auerswald.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/auerswald.c	Mon Nov 25 12:26:54 2002
@@ -2,7 +2,7 @@
 /*
  *      auerswald.c  --  Auerswald PBX/System Telephone usb driver.
  *
- *      Copyright (C) 2001  Wolfgang Mües (wmues@nexgo.de)
+ *      Copyright (C) 2001  Wolfgang Mües (wolfgang@iksw-muees.de)
  *
  *      Very much code of this driver is borrowed from dabusb.c (Deti Fliegl)
  *      and from the USB Skeleton driver (Greg Kroah-Hartman). Thank you.
@@ -50,7 +50,7 @@
 /*-------------------------------------------------------------------*/
 /* Version Information */
 #define DRIVER_VERSION "0.9.11"
-#define DRIVER_AUTHOR  "Wolfgang Mües <wmues@nexgo.de>"
+#define DRIVER_AUTHOR  "Wolfgang Mües <wolfgang@iksw-muees.de>"
 #define DRIVER_DESC    "Auerswald PBX/System Telephone usb driver"
 
 /*-------------------------------------------------------------------*/
@@ -176,7 +176,7 @@
 typedef struct
 {
         struct auerchain *chain;        /* pointer to the chain to which this element belongs */
-        urb_t * urbp;                   /* pointer to attached urb */
+        struct urb * urbp;                   /* pointer to attached urb */
         void *context;                  /* saved URB context */
         usb_complete_t complete;        /* saved URB completion function */
         struct list_head list;          /* to include element into a list */
@@ -206,8 +206,8 @@
         char *bufp;                     /* reference to allocated data buffer */
         unsigned int len;               /* number of characters in data buffer */
 	unsigned int retries;		/* for urb retries */
-        devrequest *dr;                 /* for setup data in control messages */
-        urb_t * urbp;                   /* USB urb */
+        struct usb_ctrlrequest *dr;                 /* for setup data in control messages */
+        struct urb * urbp;                   /* USB urb */
         struct auerbufctl *list;        /* pointer to list */
         struct list_head buff_list;     /* reference to next buffer in list */
 } auerbuf_t,*pauerbuf_t;
@@ -244,7 +244,7 @@
 	int			open_count;	    /* count the number of open character channels */
         char 			dev_desc[AUSI_DLEN];/* for storing a textual description */
         unsigned int 		maxControlLength;   /* max. Length of control paket (without header) */
-        urb_t * 		inturbp;            /* interrupt urb */
+        struct urb * 		inturbp;            /* interrupt urb */
         char *			intbufp;            /* data buffer for interrupt urb */
 	unsigned int 		irqsize;	    /* size of interrupt endpoint 1 */
         struct auerchain 	controlchain;  	    /* for chaining of control messages */
@@ -281,7 +281,7 @@
 
 /*-------------------------------------------------------------------*/
 /* Forwards */
-static void auerswald_ctrlread_complete (urb_t * urb);
+static void auerswald_ctrlread_complete (struct urb * urb);
 static void auerswald_removeservice (pauerswald_t cp, pauerscon_t scp);
 
 
@@ -290,7 +290,7 @@
 /* --------------------------                                        */
 
 /* completion function for chained urbs */
-static void auerchain_complete (urb_t * urb)
+static void auerchain_complete (struct urb * urb)
 {
 	unsigned long flags;
         int result;
@@ -357,7 +357,7 @@
    this function may be called from completion context or from user space!
    early = 1 -> submit in front of chain
 */
-static int auerchain_submit_urb_list (pauerchain_t acp, urb_t * urb, int early)
+static int auerchain_submit_urb_list (pauerchain_t acp, struct urb * urb, int early)
 {
         int result;
         unsigned long flags;
@@ -431,7 +431,7 @@
 /* submit function for chained urbs
    this function may be called from completion context or from user space!
 */
-static int auerchain_submit_urb (pauerchain_t acp, urb_t * urb)
+static int auerchain_submit_urb (pauerchain_t acp, struct urb * urb)
 {
 	return auerchain_submit_urb_list (acp, urb, 0);
 }
@@ -440,10 +440,10 @@
    the result is 0 if the urb is cancelled, or -EINPROGRESS if
    USB_ASYNC_UNLINK is set and the function is successfully started.
 */
-static int auerchain_unlink_urb (pauerchain_t acp, urb_t * urb)
+static int auerchain_unlink_urb (pauerchain_t acp, struct urb * urb)
 {
 	unsigned long flags;
-        urb_t * urbp;
+        struct urb * urbp;
         pauerchainelement_t acep;
         struct list_head *tmp;
 
@@ -499,7 +499,7 @@
 static void auerchain_unlink_all (pauerchain_t acp)
 {
 	unsigned long flags;
-        urb_t * urbp;
+        struct urb * urbp;
         pauerchainelement_t acep;
 
         dbg ("auerchain_unlink_all called");
@@ -605,7 +605,7 @@
 
 
 /* completion handler for synchronous chained URBs */
-static void auerchain_blocking_completion (urb_t *urb)
+static void auerchain_blocking_completion (struct urb *urb)
 {
 	pauerchain_chs_t pchs = (pauerchain_chs_t)urb->context;
 	pchs->done = 1;
@@ -615,7 +615,7 @@
 
 
 /* Starts chained urb and waits for completion or timeout */
-static int auerchain_start_wait_urb (pauerchain_t acp, urb_t *urb, int timeout, int* actual_length)
+static int auerchain_start_wait_urb (pauerchain_t acp, struct urb *urb, int timeout, int* actual_length)
 {
 	DECLARE_WAITQUEUE (wait, current);
 	auerchain_chs_t chs;
@@ -690,12 +690,12 @@
 			          __u16 value, __u16 index, void *data, __u16 size, int timeout)
 {
 	int ret;
-	devrequest *dr;
-	urb_t *urb;
+	struct usb_ctrlrequest *dr;
+	struct urb *urb;
         int length;
 
         dbg ("auerchain_control_msg");
-        dr = kmalloc (sizeof (devrequest), GFP_KERNEL);
+        dr = kmalloc (sizeof (struct usb_ctrlrequest), GFP_KERNEL);
 	if (!dr)
 		return -ENOMEM;
 	urb = usb_alloc_urb (0);
@@ -704,11 +704,11 @@
 		return -ENOMEM;
         }
 
-	dr->requesttype = requesttype;
-	dr->request = request;
-	dr->value  = cpu_to_le16 (value);
-	dr->index  = cpu_to_le16 (index);
-	dr->length = cpu_to_le16 (size);
+	dr->bRequestType = requesttype;
+	dr->bRequest = request;
+	dr->wValue  = cpu_to_le16 (value);
+	dr->wIndex  = cpu_to_le16 (index);
+	dr->wLength = cpu_to_le16 (size);
 
 	FILL_CONTROL_URB (urb, dev, pipe, (unsigned char*)dr, data, size,    /* build urb */
 		          (usb_complete_t)auerchain_blocking_completion,0);
@@ -799,7 +799,7 @@
                 INIT_LIST_HEAD (&bep->buff_list);
                 bep->bufp = (char *) kmalloc (bufsize, GFP_KERNEL);
                 if (!bep->bufp) goto bl_fail;
-                bep->dr = (devrequest *) kmalloc (sizeof (devrequest), GFP_KERNEL);
+                bep->dr = (struct usb_ctrlrequest *) kmalloc (sizeof (struct usb_ctrlrequest), GFP_KERNEL);
                 if (!bep->dr) goto bl_fail;
                 bep->urbp = usb_alloc_urb (0);
                 if (!bep->urbp) goto bl_fail;
@@ -874,7 +874,7 @@
 }
 
 /* Completion of asynchronous write block */
-static void auerchar_ctrlwrite_complete (urb_t * urb)
+static void auerchar_ctrlwrite_complete (struct urb * urb)
 {
 	pauerbuf_t bp = (pauerbuf_t) urb->context;
 	pauerswald_t cp = ((pauerswald_t)((char *)(bp->list)-(unsigned long)(&((pauerswald_t)0)->bufctl)));
@@ -887,7 +887,7 @@
 }
 
 /* Completion handler for dummy retry packet */
-static void auerswald_ctrlread_wretcomplete (urb_t * urb)
+static void auerswald_ctrlread_wretcomplete (struct urb * urb)
 {
         pauerbuf_t bp = (pauerbuf_t) urb->context;
         pauerswald_t cp;
@@ -907,13 +907,13 @@
 	}
 
 	/* fill the control message */
-	bp->dr->requesttype = AUT_RREQ;
-	bp->dr->request     = AUV_RBLOCK;
-	bp->dr->length      = bp->dr->value;	/* temporary stored */
-	bp->dr->value       = cpu_to_le16 (1);	/* Retry Flag */
+	bp->dr->bRequestType = AUT_RREQ;
+	bp->dr->bRequest     = AUV_RBLOCK;
+	bp->dr->wLength      = bp->dr->wValue;	/* temporary stored */
+	bp->dr->wValue       = cpu_to_le16 (1);	/* Retry Flag */
 	/* bp->dr->index    = channel id;          remains */
 	FILL_CONTROL_URB (bp->urbp, cp->usbdev, usb_rcvctrlpipe (cp->usbdev, 0),
-                          (unsigned char*)bp->dr, bp->bufp, le16_to_cpu (bp->dr->length),
+                          (unsigned char*)bp->dr, bp->bufp, le16_to_cpu (bp->dr->wLength),
 		          (usb_complete_t)auerswald_ctrlread_complete,bp);
 
 	/* submit the control msg as next paket */
@@ -926,7 +926,7 @@
 }
 
 /* completion handler for receiving of control messages */
-static void auerswald_ctrlread_complete (urb_t * urb)
+static void auerswald_ctrlread_complete (struct urb * urb)
 {
         unsigned int  serviceid;
         pauerswald_t  cp;
@@ -955,11 +955,11 @@
 		bp->retries++;
 		dbg ("Retry count = %d", bp->retries);
 		/* send a long dummy control-write-message to allow device firmware to react */
-		bp->dr->requesttype = AUT_WREQ;
-		bp->dr->request     = AUV_DUMMY;
-		bp->dr->value       = bp->dr->length; /* temporary storage */
+		bp->dr->bRequestType = AUT_WREQ;
+		bp->dr->bRequest     = AUV_DUMMY;
+		bp->dr->wValue       = bp->dr->wLength; /* temporary storage */
 		// bp->dr->index    channel ID remains
-		bp->dr->length      = cpu_to_le16 (32); /* >= 8 bytes */
+		bp->dr->wLength      = cpu_to_le16 (32); /* >= 8 bytes */
 		FILL_CONTROL_URB (bp->urbp, cp->usbdev, usb_sndctrlpipe (cp->usbdev, 0),
   			(unsigned char*)bp->dr, bp->bufp, 32,
 	   		(usb_complete_t)auerswald_ctrlread_wretcomplete,bp);
@@ -972,7 +972,7 @@
                		auerswald_ctrlread_wretcomplete (bp->urbp);
 		}
                 return;
-        }
+	} 
 
         /* get the actual bytecount (incl. headerbyte) */
         bp->len = urb->actual_length;
@@ -998,7 +998,7 @@
    messages from the USB device.
 */
 /* int completion handler. */
-static void auerswald_int_complete (urb_t * urb)
+static void auerswald_int_complete (struct urb * urb)
 {
         unsigned long flags;
         unsigned  int channelid;
@@ -1074,11 +1074,11 @@
         }
 
 	/* fill the control message */
-        bp->dr->requesttype = AUT_RREQ;
-	bp->dr->request     = AUV_RBLOCK;
-	bp->dr->value       = cpu_to_le16 (0);
-	bp->dr->index       = cpu_to_le16 (channelid | AUH_DIRECT | AUH_UNSPLIT);
-	bp->dr->length      = cpu_to_le16 (bytecount);
+        bp->dr->bRequestType = AUT_RREQ;
+	bp->dr->bRequest     = AUV_RBLOCK;
+	bp->dr->wValue       = cpu_to_le16 (0);
+	bp->dr->wIndex       = cpu_to_le16 (channelid | AUH_DIRECT | AUH_UNSPLIT);
+	bp->dr->wLength      = cpu_to_le16 (bytecount);
 	FILL_CONTROL_URB (bp->urbp, cp->usbdev, usb_rcvctrlpipe (cp->usbdev, 0),
                           (unsigned char*)bp->dr, bp->bufp, bytecount,
 		          (usb_complete_t)auerswald_ctrlread_complete,bp);
@@ -1327,7 +1327,7 @@
 }
 
 
-/* remove a service from the the device
+/* remove a service from the device
    scp->id must be set! */
 static void auerswald_removeservice (pauerswald_t cp, pauerscon_t scp)
 {
@@ -1813,11 +1813,11 @@
 
 	/* Set the transfer Parameters */
 	bp->len = len+AUH_SIZE;
-        bp->dr->requesttype = AUT_WREQ;
-	bp->dr->request     = AUV_WBLOCK;
-	bp->dr->value       = cpu_to_le16 (0);
-	bp->dr->index       = cpu_to_le16 (ccp->scontext.id | AUH_DIRECT | AUH_UNSPLIT);
-	bp->dr->length      = cpu_to_le16 (len+AUH_SIZE);
+        bp->dr->bRequestType = AUT_WREQ;
+	bp->dr->bRequest     = AUV_WBLOCK;
+	bp->dr->wValue       = cpu_to_le16 (0);
+	bp->dr->wIndex       = cpu_to_le16 (ccp->scontext.id | AUH_DIRECT | AUH_UNSPLIT);
+	bp->dr->wLength      = cpu_to_le16 (len+AUH_SIZE);
 	FILL_CONTROL_URB (bp->urbp, cp->usbdev, usb_sndctrlpipe (cp->usbdev, 0),
                    (unsigned char*)bp->dr, bp->bufp, len+AUH_SIZE,
 		    auerchar_ctrlwrite_complete, bp);
diff -Nur linux-2.4.19.old/drivers/usb/bluetooth.c linux-2.4.19/drivers/usb/bluetooth.c
--- linux-2.4.19.old/drivers/usb/bluetooth.c	Tue Nov 13 18:19:41 2001
+++ linux-2.4.19/drivers/usb/bluetooth.c	Mon Nov 25 12:26:54 2002
@@ -4,8 +4,12 @@
  * Copyright (c) 2000, 2001 Greg Kroah-Hartman	<greg@kroah.com>
  * Copyright (c) 2000 Mark Douglas Corner	<mcorner@umich.edu>
  *
- * USB Bluetooth driver, based on the Bluetooth Spec version 1.0B
+ * USB Bluetooth TTY driver, based on the Bluetooth Spec version 1.0B
  * 
+ * (2001/11/30) Version 0.13 gkh
+ *	- added locking patch from Masoodur Rahman <rmasoodu@in.ibm.com>
+ *	- removed active variable, as open_count will do.
+ *
  * (2001/07/09) Version 0.12 gkh
  *	- removed in_interrupt() call, as it doesn't make sense to do 
  *	  that anymore.
@@ -100,17 +104,14 @@
 
 
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
+#include <asm/uaccess.h>
 
 #define DEBUG
 #include <linux/usb.h>
@@ -118,7 +119,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v0.12"
+#define DRIVER_VERSION "v0.13"
 #define DRIVER_AUTHOR "Greg Kroah-Hartman, Mark Douglas Corner"
 #define DRIVER_DESC "USB Bluetooth tty driver"
 
@@ -170,12 +171,12 @@
 	struct tty_struct *	tty;		/* the coresponding tty for this port */
 
 	unsigned char		minor;		/* the starting minor number for this device */
-	char			active;		/* someone has this device open */
 	int			throttle;	/* throttled by tty layer */
+	int			open_count;
 	
 	__u8			control_out_bInterfaceNum;
 	struct urb *		control_urb_pool[NUM_CONTROL_URBS];
-	devrequest		dr[NUM_CONTROL_URBS];
+	struct usb_ctrlrequest	dr[NUM_CONTROL_URBS];
 
 	unsigned char *		interrupt_in_buffer;
 	struct urb *		interrupt_in_urb;
@@ -200,6 +201,7 @@
 	unsigned char		int_buffer[EVENT_BUFFER_SIZE];
 	unsigned int		bulk_packet_pos;
 	unsigned char		bulk_buffer[ACL_BUFFER_SIZE];	/* 64k preallocated, fix? */
+	struct semaphore	lock;
 };
 
 
@@ -232,10 +234,10 @@
 MODULE_DEVICE_TABLE (usb, usb_bluetooth_ids);
 
 static struct usb_driver usb_bluetooth_driver = {
-	name:		"bluetooth",
-	probe:		usb_bluetooth_probe,
-	disconnect:	usb_bluetooth_disconnect,
-	id_table:	usb_bluetooth_ids,
+	.name =		"bluetty",
+	.probe =	usb_bluetooth_probe,
+	.disconnect =	usb_bluetooth_disconnect,
+	.id_table =	usb_bluetooth_ids,
 };
 
 static int			bluetooth_refcount;
@@ -283,11 +285,11 @@
 static int bluetooth_ctrl_msg (struct usb_bluetooth *bluetooth, int request, int value, const unsigned char *buf, int len)
 {
 	struct urb *urb = NULL;
-	devrequest *dr = NULL;
+	struct usb_ctrlrequest *dr = NULL;
 	int i;
 	int status;
 
-	dbg (__FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 
 	/* try to find a free urb in our list */
 	for (i = 0; i < NUM_CONTROL_URBS; ++i) {
@@ -298,7 +300,7 @@
 		}
 	}
 	if (urb == NULL) {
-		dbg (__FUNCTION__ " - no free urbs");
+		dbg ("%s - no free urbs", __FUNCTION__);
 		return -ENOMEM;
 	}
 
@@ -306,7 +308,7 @@
 	if (urb->transfer_buffer == NULL) {
 		urb->transfer_buffer = kmalloc (len, GFP_KERNEL);
 		if (urb->transfer_buffer == NULL) {
-			err (__FUNCTION__" - out of memory");
+			err ("%s - out of memory", __FUNCTION__);
 			return -ENOMEM;
 		}
 	}
@@ -314,17 +316,17 @@
 		kfree (urb->transfer_buffer);
 		urb->transfer_buffer = kmalloc (len, GFP_KERNEL);
 		if (urb->transfer_buffer == NULL) {
-			err (__FUNCTION__" - out of memory");
+			err ("%s - out of memory", __FUNCTION__);
 			return -ENOMEM;
 		}
 	}
 	memcpy (urb->transfer_buffer, buf, len);
 
-	dr->requesttype = BLUETOOTH_CONTROL_REQUEST_TYPE;
-	dr->request = request;
-	dr->value = cpu_to_le16((u16) value);
-	dr->index = cpu_to_le16((u16) bluetooth->control_out_bInterfaceNum);
-	dr->length = cpu_to_le16((u16) len);
+	dr->bRequestType= BLUETOOTH_CONTROL_REQUEST_TYPE;
+	dr->bRequest = request;
+	dr->wValue = cpu_to_le16((u16) value);
+	dr->wIndex = cpu_to_le16((u16) bluetooth->control_out_bInterfaceNum);
+	dr->wLength = cpu_to_le16((u16) len);
 	
 	FILL_CONTROL_URB (urb, bluetooth->dev, usb_sndctrlpipe(bluetooth->dev, 0),
 			  (unsigned char*)dr, urb->transfer_buffer, len, bluetooth_ctrl_callback, bluetooth);
@@ -332,7 +334,7 @@
 	/* send it down the pipe */
 	status = usb_submit_urb(urb);
 	if (status)
-		dbg(__FUNCTION__ " - usb_submit_urb(control) failed with status = %d", status);
+		dbg("%s - usb_submit_urb(control) failed with status = %d", __FUNCTION__, status);
 	
 	return status;
 }
@@ -349,7 +351,7 @@
 	struct usb_bluetooth *bluetooth;
 	int result;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	/* initialize the pointer incase something fails */
 	tty->driver_data = NULL;
@@ -361,43 +363,46 @@
 		return -ENODEV;
 	}
 
-	if (bluetooth->active) {
-		dbg (__FUNCTION__ " - device already open");
-		return -EINVAL;
-	}
-
-	/* set up our structure making the tty driver remember our object, and us it */
-	tty->driver_data = bluetooth;
-	bluetooth->tty = tty;
-
-	/* force low_latency on so that our tty_push actually forces the data through, 
-	 * otherwise it is scheduled, and with high data rates (like with OHCI) data
-	 * can get lost. */
-	bluetooth->tty->low_latency = 1;
+	down (&bluetooth->lock);
+ 
+	++bluetooth->open_count;
+	if (bluetooth->open_count == 1) {
+		/* set up our structure making the tty driver remember our object, and us it */
+		tty->driver_data = bluetooth;
+		bluetooth->tty = tty;
+
+		/* force low_latency on so that our tty_push actually forces the data through, 
+		 * otherwise it is scheduled, and with high data rates (like with OHCI) data
+		 * can get lost. */
+		bluetooth->tty->low_latency = 1;
 	
-	bluetooth->active = 1;
-
-	/* Reset the packet position counters */
-	bluetooth->int_packet_pos = 0;
-	bluetooth->bulk_packet_pos = 0;
+		/* Reset the packet position counters */
+		bluetooth->int_packet_pos = 0;
+		bluetooth->bulk_packet_pos = 0;
 
 #ifndef BTBUGGYHARDWARE
-	/* Start reading from the device */
-	FILL_BULK_URB(bluetooth->read_urb, bluetooth->dev, 
-		      usb_rcvbulkpipe(bluetooth->dev, bluetooth->bulk_in_endpointAddress),
-		      bluetooth->bulk_in_buffer, bluetooth->bulk_in_buffer_size, 
-		      bluetooth_read_bulk_callback, bluetooth);
-	result = usb_submit_urb(bluetooth->read_urb);
-	if (result)
-		dbg(__FUNCTION__ " - usb_submit_urb(read bulk) failed with status %d", result);
+		/* Start reading from the device */
+		FILL_BULK_URB (bluetooth->read_urb, bluetooth->dev, 
+			       usb_rcvbulkpipe(bluetooth->dev, bluetooth->bulk_in_endpointAddress),
+			       bluetooth->bulk_in_buffer,
+			       bluetooth->bulk_in_buffer_size,
+			       bluetooth_read_bulk_callback, bluetooth);
+		result = usb_submit_urb(bluetooth->read_urb);
+		if (result)
+			dbg("%s - usb_submit_urb(read bulk) failed with status %d", __FUNCTION__, result);
 #endif
-	FILL_INT_URB(bluetooth->interrupt_in_urb, bluetooth->dev, 
-		     usb_rcvintpipe(bluetooth->dev, bluetooth->interrupt_in_endpointAddress),
-		     bluetooth->interrupt_in_buffer, bluetooth->interrupt_in_buffer_size, 
-		     bluetooth_int_callback, bluetooth, bluetooth->interrupt_in_interval);
-	result = usb_submit_urb(bluetooth->interrupt_in_urb);
-	if (result)
-		dbg(__FUNCTION__ " - usb_submit_urb(interrupt in) failed with status %d", result);
+		FILL_INT_URB (bluetooth->interrupt_in_urb, bluetooth->dev, 
+			      usb_rcvintpipe(bluetooth->dev, bluetooth->interrupt_in_endpointAddress),
+			      bluetooth->interrupt_in_buffer,
+			      bluetooth->interrupt_in_buffer_size,
+			      bluetooth_int_callback, bluetooth,
+			      bluetooth->interrupt_in_interval);
+		result = usb_submit_urb(bluetooth->interrupt_in_urb);
+		if (result)
+			dbg("%s - usb_submit_urb(interrupt in) failed with status %d", __FUNCTION__, result);
+	}
+	
+	up(&bluetooth->lock);
 
 	return 0;
 }
@@ -412,20 +417,26 @@
 		return;
 	}
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not opened");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not opened", __FUNCTION__);
 		return;
 	}
 
-	/* shutdown any bulk reads and writes that might be going on */
-	for (i = 0; i < NUM_BULK_URBS; ++i)
-		usb_unlink_urb (bluetooth->write_urb_pool[i]);
-	usb_unlink_urb (bluetooth->read_urb);
-	usb_unlink_urb (bluetooth->interrupt_in_urb);
+	down (&bluetooth->lock);
+ 
+	--bluetooth->open_count;
+	if (bluetooth->open_count <= 0) {
+		bluetooth->open_count = 0;
 
-	bluetooth->active = 0;
+		/* shutdown any bulk reads and writes that might be going on */
+		for (i = 0; i < NUM_BULK_URBS; ++i)
+			usb_unlink_urb (bluetooth->write_urb_pool[i]);
+		usb_unlink_urb (bluetooth->read_urb);
+		usb_unlink_urb (bluetooth->interrupt_in_urb);
+	}
+	up(&bluetooth->lock);
 }
 
 
@@ -445,24 +456,24 @@
 		return -ENODEV;
 	}
 
-	dbg(__FUNCTION__ " - %d byte(s)", count);
+	dbg("%s - %d byte(s)", __FUNCTION__, count);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not opened");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not opened", __FUNCTION__);
 		return -EINVAL;
 	}
 
 	if (count == 0) {
-		dbg(__FUNCTION__ " - write request of 0 bytes");
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
 		return 0;
 	}
 	if (count == 1) {
-		dbg(__FUNCTION__ " - write request only included type %d", buf[0]);
+		dbg("%s - write request only included type %d", __FUNCTION__, buf[0]);
 		return 1;
 	}
 
 #ifdef DEBUG
-	printk (KERN_DEBUG __FILE__ ": " __FUNCTION__ " - length = %d, data = ", count);
+	printk (KERN_DEBUG __FILE__ ": %s - length = %d, data = ", __FUNCTION__, count);
 	for (i = 0; i < count; ++i) {
 		printk ("%.2x ", buf[i]);
 	}
@@ -472,11 +483,14 @@
 	if (from_user) {
 		temp_buffer = kmalloc (count, GFP_KERNEL);
 		if (temp_buffer == NULL) {
-			err (__FUNCTION__ "- out of memory.");
+			err ("%s - out of memory.", __FUNCTION__);
 			retval = -ENOMEM;
 			goto exit;
 		}
-		copy_from_user (temp_buffer, buf, count);
+		if (copy_from_user (temp_buffer, buf, count)) {
+			retval = -EFAULT;
+			goto exit;
+		}
 		current_buffer = temp_buffer;
 	} else {
 		current_buffer = buf;
@@ -485,7 +499,7 @@
 	switch (*current_buffer) {
 		/* First byte indicates the type of packet */
 		case CMD_PKT:
-			/* dbg(__FUNCTION__ "- Send cmd_pkt len:%d", count);*/
+			/* dbg("%s- Send cmd_pkt len:%d", __FUNCTION__, count);*/
 
 			retval = bluetooth_ctrl_msg (bluetooth, 0x00, 0x00, &current_buffer[1], count-1);
 			if (retval) {
@@ -511,7 +525,7 @@
 					}
 				}
 				if (urb == NULL) {
-					dbg (__FUNCTION__ " - no free urbs");
+					dbg ("%s - no free urbs", __FUNCTION__);
 					retval = bytes_sent;
 					goto exit;
 				}
@@ -528,7 +542,7 @@
 				/* send it down the pipe */
 				retval = usb_submit_urb(urb);
 				if (retval) {
-					dbg(__FUNCTION__ " - usb_submit_urb(write bulk) failed with error = %d", retval);
+					dbg("%s - usb_submit_urb(write bulk) failed with error = %d", __FUNCTION__, retval);
 					goto exit;
 				}
 #ifdef BTBUGGYHARDWARE
@@ -547,7 +561,7 @@
 			break;
 		
 		default :
-			dbg(__FUNCTION__" - unsupported (at this time) write type");
+			dbg("%s - unsupported (at this time) write type", __FUNCTION__);
 			retval = -EINVAL;
 			break;
 	}
@@ -570,10 +584,10 @@
 		return -ENODEV;
 	}
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not open");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
 		return -EINVAL;
 	}
 
@@ -583,7 +597,7 @@
 		}
 	}
 
-	dbg(__FUNCTION__ " - returns %d", room);
+	dbg("%s - returns %d", __FUNCTION__, room);
 	return room;
 }
 
@@ -598,8 +612,8 @@
 		return -ENODEV;
 	}
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not open");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
 		return -EINVAL;
 	}
 
@@ -609,7 +623,7 @@
 		}
 	}
 
-	dbg (__FUNCTION__ " - returns %d", chars);
+	dbg ("%s - returns %d", __FUNCTION__, chars);
 	return chars;
 }
 
@@ -622,14 +636,14 @@
 		return;
 	}
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not open");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
 		return;
 	}
 	
-	dbg(__FUNCTION__ " unsupported (at this time)");
+	dbg("%s unsupported (at this time)", __FUNCTION__);
 
 	return;
 }
@@ -643,14 +657,14 @@
 		return;
 	}
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not open");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
 		return;
 	}
 
-	dbg(__FUNCTION__ " unsupported (at this time)");
+	dbg("%s unsupported (at this time)", __FUNCTION__);
 }
 
 
@@ -662,10 +676,10 @@
 		return -ENODEV;
 	}
 
-	dbg(__FUNCTION__ " - cmd 0x%.4x", cmd);
+	dbg("%s - cmd 0x%.4x", __FUNCTION__, cmd);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not open");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
 		return -ENODEV;
 	}
 
@@ -682,10 +696,10 @@
 		return;
 	}
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not open");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
 		return;
 	}
 
@@ -704,10 +718,10 @@
 		return;
 	}
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not open");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
 		return;
 	}
 
@@ -718,7 +732,7 @@
 			      bluetooth_read_bulk_callback, bluetooth);
 		result = usb_submit_urb(bluetooth->read_urb);
 		if (result)
-			err (__FUNCTION__ " - failed submitting read urb, error %d", result);
+			err ("%s - failed submitting read urb, error %d", __FUNCTION__, result);
 	}
 }
 
@@ -729,10 +743,10 @@
 		return;
 	}
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	if (!bluetooth->active) {
-		dbg (__FUNCTION__ " - device not open");
+	if (!bluetooth->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
 		return;
 	}
 
@@ -755,27 +769,27 @@
 	unsigned int count = urb->actual_length;
 	unsigned int packet_size;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (!bluetooth) {
-		dbg(__FUNCTION__ " - bad bluetooth pointer, exiting");
+		dbg("%s - bad bluetooth pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero int status received: %d", urb->status);
+		dbg("%s - nonzero int status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
 	if (!count) {
-		dbg(__FUNCTION__ " - zero length int");
+		dbg("%s - zero length int", __FUNCTION__);
 		return;
 	}
 
 
 #ifdef DEBUG
 	if (count) {
-		printk (KERN_DEBUG __FILE__ ": " __FUNCTION__ "- length = %d, data = ", count);
+		printk (KERN_DEBUG __FILE__ ": %s- length = %d, data = ", __FUNCTION__, count);
 		for (i = 0; i < count; ++i) {
 			printk ("%.2x ", data[i]);
 		}
@@ -805,7 +819,7 @@
 	}
 	
 	if (bluetooth->int_packet_pos + count > EVENT_BUFFER_SIZE) {
-		err(__FUNCTION__ " - exceeded EVENT_BUFFER_SIZE");
+		err("%s - exceeded EVENT_BUFFER_SIZE", __FUNCTION__);
 		bluetooth->int_packet_pos = 0;
 		return;
 	}
@@ -821,7 +835,7 @@
 		return;
 
 	if (packet_size + EVENT_HDR_SIZE < bluetooth->int_packet_pos) {
-		err(__FUNCTION__ " - packet was too long");
+		err("%s - packet was too long", __FUNCTION__);
 		bluetooth->int_packet_pos = 0;
 		return;
 	}
@@ -845,15 +859,15 @@
 {
 	struct usb_bluetooth *bluetooth = get_usb_bluetooth ((struct usb_bluetooth *)urb->context, __FUNCTION__);
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (!bluetooth) {
-		dbg(__FUNCTION__ " - bad bluetooth pointer, exiting");
+		dbg("%s - bad bluetooth pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 }
@@ -869,30 +883,30 @@
 	int result;
 
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (!bluetooth) {
-		dbg(__FUNCTION__ " - bad bluetooth pointer, exiting");
+		dbg("%s - bad bluetooth pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		if (urb->status == -ENOENT) {                   
-			dbg(__FUNCTION__ " - URB canceled, won't reschedule");
+			dbg("%s - URB canceled, won't reschedule", __FUNCTION__);
 			return;
 		}
 		goto exit;
 	}
 
 	if (!count) {
-		dbg(__FUNCTION__ " - zero length read bulk");
+		dbg("%s - zero length read bulk", __FUNCTION__);
 		goto exit;
 	}
 
 #ifdef DEBUG
 	if (count) {
-		printk (KERN_DEBUG __FILE__ ": " __FUNCTION__ "- length = %d, data = ", count);
+		printk (KERN_DEBUG __FILE__ ": %s- length = %d, data = ", __FUNCTION__, count);
 		for (i = 0; i < count; ++i) {
 			printk ("%.2x ", data[i]);
 		}
@@ -909,7 +923,7 @@
 			      bluetooth_read_bulk_callback, bluetooth);
 		result = usb_submit_urb(bluetooth->read_urb);
 		if (result)
-			err (__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+			err ("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 
 		return;
 	}
@@ -926,7 +940,7 @@
 	}
 
 	if (bluetooth->bulk_packet_pos + count > ACL_BUFFER_SIZE) {
-		err(__FUNCTION__ " - exceeded ACL_BUFFER_SIZE");
+		err("%s - exceeded ACL_BUFFER_SIZE", __FUNCTION__);
 		bluetooth->bulk_packet_pos = 0;
 		goto exit;
 	}
@@ -943,7 +957,7 @@
 	}
 
 	if (packet_size + ACL_HDR_SIZE < bluetooth->bulk_packet_pos) {
-		err(__FUNCTION__ " - packet was too long");
+		err("%s - packet was too long", __FUNCTION__);
 		bluetooth->bulk_packet_pos = 0;
 		goto exit;
 	}
@@ -961,7 +975,7 @@
 	}	
 
 exit:
-	if (!bluetooth || !bluetooth->active)
+	if (!bluetooth || !bluetooth->open_count)
 		return;
 
 	FILL_BULK_URB(bluetooth->read_urb, bluetooth->dev, 
@@ -970,7 +984,7 @@
 		      bluetooth_read_bulk_callback, bluetooth);
 	result = usb_submit_urb(bluetooth->read_urb);
 	if (result)
-		err (__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+		err ("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 
 	return;
 }
@@ -980,15 +994,15 @@
 {
 	struct usb_bluetooth *bluetooth = get_usb_bluetooth ((struct usb_bluetooth *)urb->context, __FUNCTION__);
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (!bluetooth) {
-		dbg(__FUNCTION__ " - bad bluetooth pointer, exiting");
+		dbg("%s - bad bluetooth pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -1004,7 +1018,7 @@
 	struct usb_bluetooth *bluetooth = get_usb_bluetooth ((struct usb_bluetooth *)private, __FUNCTION__);
 	struct tty_struct *tty;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (!bluetooth) {
 		return;
@@ -1012,7 +1026,7 @@
 
 	tty = bluetooth->tty;
 	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
-		dbg(__FUNCTION__ " - write wakeup call.");
+		dbg("%s - write wakeup call.", __FUNCTION__);
 		(tty->ldisc.write_wakeup)(tty);
 	}
 
@@ -1074,7 +1088,7 @@
 	if ((num_bulk_in != 1) ||
 	    (num_bulk_out != 1) ||
 	    (num_interrupt_in != 1)) {
-		dbg (__FUNCTION__ " - improper number of endpoints. Bluetooth driver not bound.");
+		dbg ("%s - improper number of endpoints. Bluetooth driver not bound.", __FUNCTION__);
 		return NULL;
 	}
 
@@ -1102,6 +1116,7 @@
 	bluetooth->minor = minor;
 	bluetooth->tqueue.routine = bluetooth_softint;
 	bluetooth->tqueue.data = bluetooth;
+	init_MUTEX(&bluetooth->lock);
 
 	/* record the interface number for the control out */
 	bluetooth->control_out_bInterfaceNum = control_out_endpoint;
@@ -1136,7 +1151,8 @@
 
 	endpoint = bulk_out_endpoint[0];
 	bluetooth->bulk_out_endpointAddress = endpoint->bEndpointAddress;
-	
+	bluetooth->bulk_out_buffer_size = endpoint->wMaxPacketSize * 2;
+
 	/* create our write urb pool */ 
 	for (i = 0; i < NUM_BULK_URBS; ++i) {
 		struct urb  *urb = usb_alloc_urb(0);
@@ -1151,8 +1167,6 @@
 		}
 		bluetooth->write_urb_pool[i] = urb;
 	}
-	
-	bluetooth->bulk_out_buffer_size = endpoint->wMaxPacketSize * 2;
 
 	endpoint = interrupt_in_endpoint[0];
 	bluetooth->interrupt_in_urb = usb_alloc_urb(0);
@@ -1217,10 +1231,10 @@
 	int i;
 
 	if (bluetooth) {
-		if ((bluetooth->active) && (bluetooth->tty))
+		if ((bluetooth->open_count) && (bluetooth->tty))
 			tty_hangup(bluetooth->tty);
 
-		bluetooth->active = 0;
+		bluetooth->open_count = 0;
 
 		if (bluetooth->read_urb) {
 			usb_unlink_urb (bluetooth->read_urb);
@@ -1271,30 +1285,30 @@
 
 
 static struct tty_driver bluetooth_tty_driver = {
-	magic:			TTY_DRIVER_MAGIC,
-	driver_name:		"usb-bluetooth",
-	name:			"usb/ttub/%d",
-	major:			BLUETOOTH_TTY_MAJOR,
-	minor_start:		0,
-	num:			BLUETOOTH_TTY_MINORS,
-	type:			TTY_DRIVER_TYPE_SERIAL,
-	subtype:		SERIAL_TYPE_NORMAL,
-	flags:			TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
-
-	refcount:		&bluetooth_refcount,
-	table:			bluetooth_tty,
-	termios:		bluetooth_termios,
-	termios_locked:		bluetooth_termios_locked,
-
-	open:			bluetooth_open,
-	close:			bluetooth_close,
-	write:			bluetooth_write,
-	write_room:		bluetooth_write_room,
-	ioctl:			bluetooth_ioctl,
-	set_termios:		bluetooth_set_termios,
-	throttle:		bluetooth_throttle,
-	unthrottle:		bluetooth_unthrottle,
-	chars_in_buffer:	bluetooth_chars_in_buffer,
+	.magic =		TTY_DRIVER_MAGIC,
+	.driver_name =		"usb-bluetooth",
+	.name =			"usb/ttub/%d",
+	.major =		BLUETOOTH_TTY_MAJOR,
+	.minor_start =		0,
+	.num =			BLUETOOTH_TTY_MINORS,
+	.type =			TTY_DRIVER_TYPE_SERIAL,
+	.subtype =		SERIAL_TYPE_NORMAL,
+	.flags =		TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
+
+	.refcount =		&bluetooth_refcount,
+	.table =		bluetooth_tty,
+	.termios =		bluetooth_termios,
+	.termios_locked =	bluetooth_termios_locked,
+
+	.open =			bluetooth_open,
+	.close =		bluetooth_close,
+	.write =		bluetooth_write,
+	.write_room =		bluetooth_write_room,
+	.ioctl =		bluetooth_ioctl,
+	.set_termios =		bluetooth_set_termios,
+	.throttle =		bluetooth_throttle,
+	.unthrottle =		bluetooth_unthrottle,
+	.chars_in_buffer =	bluetooth_chars_in_buffer,
 };
 
 
@@ -1314,7 +1328,7 @@
 	bluetooth_tty_driver.init_termios          = tty_std_termios;
 	bluetooth_tty_driver.init_termios.c_cflag  = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	if (tty_register_driver (&bluetooth_tty_driver)) {
-		err(__FUNCTION__ " - failed to register tty driver");
+		err("%s - failed to register tty driver", __FUNCTION__);
 		return -1;
 	}
 
diff -Nur linux-2.4.19.old/drivers/usb/brlvger.c linux-2.4.19/drivers/usb/brlvger.c
--- linux-2.4.19.old/drivers/usb/brlvger.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/brlvger.c	Mon Nov 25 12:26:54 2002
@@ -208,8 +208,8 @@
 #define err(args...) \
     ({ printk(KERN_ERR "Voyager: " args); \
        printk("\n"); })
-#define dbgprint(args...) \
-    ({ printk(KERN_DEBUG "Voyager: " __FUNCTION__ ": " args); \
+#define dbgprint(fmt, args...) \
+    ({ printk(KERN_DEBUG "Voyager: %s: " fmt, __FUNCTION__ , ##args); \
        printk("\n"); })
 #define dbg(args...) \
     ({ if(debug >= 1) dbgprint(args); })
@@ -586,7 +586,9 @@
 	struct brlvger_priv *priv = file->private_data;
 	char buf[MAX_BRLVGER_CELLS];
 	int ret;
-	int rs, off;
+	size_t rs;
+	loff_t off;
+
 	__u16 written;
 
 	if(!priv->dev)
diff -Nur linux-2.4.19.old/drivers/usb/catc.c linux-2.4.19/drivers/usb/catc.c
--- linux-2.4.19.old/drivers/usb/catc.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/catc.c	Mon Nov 25 12:26:55 2002
@@ -7,6 +7,9 @@
  *
  *  Based on the work of
  *		Donald Becker
+ * 
+ *  Old chipset support added by Simon Evans <spse@secret.org.uk> 2002
+ *    - adds support for Belkin F5U011
  */
 
 /*
@@ -69,6 +72,7 @@
 #define RX_MAX_BURST		15	/* Max packets per rx buffer (> 0, < 16) */
 #define TX_MAX_BURST		15	/* Max full sized packets per tx buffer (> 0) */
 #define CTRL_QUEUE		16	/* Max control requests in flight (power of two) */
+#define RX_PKT_SZ		1600	/* Max size of receive packet for F5U011 */
 
 /*
  * Control requests.
@@ -79,6 +83,7 @@
 	GetMac =	0xf2,
 	Reset =		0xf4,
 	SetMac =	0xf5,
+	SetRxMode =     0xf5,  /* F5U011 only */
 	WriteROM =	0xf8,
 	SetReg =	0xfa,
 	GetReg =	0xfb,
@@ -126,6 +131,7 @@
 	RxForceOK =	0x04,
 	RxMultiCast =	0x08,
 	RxPromisc =	0x10,
+	AltRxPromisc =  0x20, /* F5U011 uses different bit */
 };
 
 enum led_values {
@@ -136,6 +142,12 @@
 	LEDLink =	0x08,
 };
 
+enum link_status {
+	LinkNoChange = 0,
+	LinkGood     = 1,
+	LinkBad      = 2
+};
+
 /*
  * The catc struct.
  */
@@ -159,7 +171,7 @@
 	u8 rx_buf[RX_MAX_BURST * (PKT_SZ + 2)];
 	u8 irq_buf[2];
 	u8 ctrl_buf[64];
-	devrequest ctrl_dr;
+	struct usb_ctrlrequest ctrl_dr;
 
 	struct timer_list timer;
 	u8 stats_buf[8];
@@ -179,6 +191,10 @@
 	} ctrl_queue[CTRL_QUEUE];
 
 	struct urb tx_urb, rx_urb, irq_urb, ctrl_urb;
+
+	u8 is_f5u011;	/* Set if device is an F5U011 */
+	u8 rxmode[2];	/* Used for F5U011 */
+	atomic_t recq_sz; /* Used for F5U011 - counter of waiting rx packets */
 };
 
 /*
@@ -192,6 +208,10 @@
 #define catc_write_mem(catc, addr, buf, size)		catc_ctrl_msg(catc, USB_DIR_OUT, WriteMem, 0, addr, buf, size)
 #define catc_read_mem(catc, addr, buf, size)		catc_ctrl_msg(catc, USB_DIR_IN,  ReadMem, 0, addr, buf, size)
 
+#define f5u011_rxmode(catc, rxmode)			catc_ctrl_msg(catc, USB_DIR_OUT, SetRxMode, 0, 1, rxmode, 2)
+#define f5u011_rxmode_async(catc, rxmode)		catc_ctrl_async(catc, USB_DIR_OUT, SetRxMode, 0, 1, &rxmode, 2, NULL)
+#define f5u011_mchash_async(catc, hash)			catc_ctrl_async(catc, USB_DIR_OUT, SetRxMode, 0, 2, &hash, 8, NULL)
+
 #define catc_set_reg_async(catc, reg, val)		catc_ctrl_async(catc, USB_DIR_OUT, SetReg, val, reg, NULL, 0, NULL)
 #define catc_get_reg_async(catc, reg, cb)		catc_ctrl_async(catc, USB_DIR_IN, GetReg, 0, reg, NULL, 1, cb)
 #define catc_write_mem_async(catc, addr, buf, size)	catc_ctrl_async(catc, USB_DIR_OUT, WriteMem, 0, addr, buf, size, NULL)
@@ -205,9 +225,12 @@
 	struct catc *catc = urb->context;
 	u8 *pkt_start = urb->transfer_buffer;
 	struct sk_buff *skb;
-	int pkt_len;
+	int pkt_len, pkt_offset = 0;
 
-	clear_bit(RX_RUNNING, &catc->flags);
+	if (!catc->is_f5u011) {
+		clear_bit(RX_RUNNING, &catc->flags);
+		pkt_offset = 2;
+	}
 
 	if (urb->status) {
 		dbg("rx_done, status %d, length %d", urb->status, urb->actual_length);
@@ -215,19 +238,22 @@
 	}
 
 	do {
-		pkt_len = le16_to_cpup((u16*)pkt_start);
-
-		if (pkt_len > urb->actual_length) {
-			catc->stats.rx_length_errors++;
-			catc->stats.rx_errors++;
-			break;
+		if(!catc->is_f5u011) {
+			pkt_len = le16_to_cpup((u16*)pkt_start);
+			if (pkt_len > urb->actual_length) {
+				catc->stats.rx_length_errors++;
+				catc->stats.rx_errors++;
+				break;
+			}
+		} else {
+			pkt_len = urb->actual_length;
 		}
 
 		if (!(skb = dev_alloc_skb(pkt_len)))
 			return;
 
 		skb->dev = catc->netdev;
-		eth_copy_and_sum(skb, pkt_start + 2, pkt_len, 0);
+		eth_copy_and_sum(skb, pkt_start + pkt_offset, pkt_len, 0);
 		skb_put(skb, pkt_len);
 
 		skb->protocol = eth_type_trans(skb, catc->netdev);
@@ -236,11 +262,28 @@
 		catc->stats.rx_packets++;
 		catc->stats.rx_bytes += pkt_len;
 
+		/* F5U011 only does one packet per RX */
+		if (catc->is_f5u011)
+			break;
 		pkt_start += (((pkt_len + 1) >> 6) + 1) << 6;
 
 	} while (pkt_start - (u8 *) urb->transfer_buffer < urb->actual_length);
 
 	catc->netdev->last_rx = jiffies;
+
+	if (catc->is_f5u011) {
+		if (atomic_read(&catc->recq_sz)) {
+			int status;
+			atomic_dec(&catc->recq_sz);
+			dbg("getting extra packet");
+			urb->dev = catc->usbdev;
+			if ((status = usb_submit_urb(urb)) < 0) {
+				dbg("submit(rx_urb) status %d", status);
+			}
+		} else {
+			clear_bit(RX_RUNNING, &catc->flags);
+		}
+	}
 }
 
 static void catc_irq_done(struct urb *urb)
@@ -248,29 +291,48 @@
 	struct catc *catc = urb->context;
 	u8 *data = urb->transfer_buffer;
 	int status;
+	unsigned int hasdata = 0, linksts = LinkNoChange;
+
+	if (!catc->is_f5u011) {
+		hasdata = data[1] & 0x80;
+		if (data[1] & 0x40)
+			linksts = LinkGood;
+		else if (data[1] & 0x20)
+			linksts = LinkBad;
+	} else {
+		hasdata = (unsigned int)(be16_to_cpup((u16*)data) & 0x0fff);
+		if (data[0] == 0x90)
+			linksts = LinkGood;
+		else if (data[0] == 0xA0)
+			linksts = LinkBad;
+	}
 
 	if (urb->status) {
 		dbg("irq_done, status %d, data %02x %02x.", urb->status, data[0], data[1]);
 		return;
 	}
 
-	if ((data[1] & 0x80) && !test_and_set_bit(RX_RUNNING, &catc->flags)) {
-		catc->rx_urb.dev = catc->usbdev;
-		if ((status = usb_submit_urb(&catc->rx_urb)) < 0) {
-			err("submit(rx_urb) status %d", status);
-			return;
-		} 
-	}
-
-	if (data[1] & 0x40) {
+	if (linksts == LinkGood) {
 		netif_carrier_on(catc->netdev);
 		dbg("link ok");
 	}
 
-	if (data[1] & 0x20) {
+	if (linksts == LinkBad) {
 		netif_carrier_off(catc->netdev);
 		dbg("link bad");
 	}
+
+	if (hasdata) {
+		if (test_and_set_bit(RX_RUNNING, &catc->flags)) {
+			if (catc->is_f5u011)
+				atomic_inc(&catc->recq_sz);
+		} else {
+			catc->rx_urb.dev = catc->usbdev;
+			if ((status = usb_submit_urb(&catc->rx_urb)) < 0) {
+				err("submit(rx_urb) status %d", status);
+			}
+		} 
+	}
 }
 
 /*
@@ -281,6 +343,9 @@
 {
 	int status;
 
+	if (catc->is_f5u011)
+		catc->tx_ptr = (catc->tx_ptr + 63) & ~63;
+
 	catc->tx_urb.transfer_buffer_length = catc->tx_ptr;
 	catc->tx_urb.transfer_buffer = catc->tx_buf[catc->tx_idx];
 	catc->tx_urb.dev = catc->usbdev;
@@ -337,14 +402,16 @@
 
 	catc->tx_ptr = (((catc->tx_ptr - 1) >> 6) + 1) << 6;
 	tx_buf = catc->tx_buf[catc->tx_idx] + catc->tx_ptr;
-	*((u16*)tx_buf) = cpu_to_le16((u16)skb->len);
+	*((u16*)tx_buf) = (catc->is_f5u011) ? 
+		cpu_to_be16((u16)skb->len) : cpu_to_le16((u16)skb->len);
 	memcpy(tx_buf + 2, skb->data, skb->len);
 	catc->tx_ptr += skb->len + 2;
 
 	if (!test_and_set_bit(TX_RUNNING, &catc->flags))
 		catc_tx_run(catc);
 
-	if (catc->tx_ptr >= ((TX_MAX_BURST - 1) * (PKT_SZ + 2)))
+	if ((catc->is_f5u011 && catc->tx_ptr)
+	     || (catc->tx_ptr >= ((TX_MAX_BURST - 1) * (PKT_SZ + 2))))
 		netif_stop_queue(netdev);
 
 	spin_unlock_irqrestore(&catc->tx_lock, flags);
@@ -383,14 +450,14 @@
 	struct ctrl_queue *q = catc->ctrl_queue + catc->ctrl_tail;
 	struct usb_device *usbdev = catc->usbdev;
 	struct urb *urb = &catc->ctrl_urb;
-	devrequest *dr = &catc->ctrl_dr;
+	struct usb_ctrlrequest *dr = &catc->ctrl_dr;
 	int status;
 
-	dr->request = q->request;
-	dr->requesttype = 0x40 | q->dir;
-	dr->value = cpu_to_le16(q->value);
-	dr->index = cpu_to_le16(q->index);
-	dr->length = cpu_to_le16(q->len);
+	dr->bRequest = q->request;
+	dr->bRequestType = 0x40 | q->dir;
+	dr->wValue = cpu_to_le16(q->value);
+	dr->wIndex = cpu_to_le16(q->index);
+	dr->wLength = cpu_to_le16(q->len);
 
         urb->pipe = q->dir ? usb_rcvctrlpipe(usbdev, 0) : usb_sndctrlpipe(usbdev, 0);
 	urb->transfer_buffer_length = q->len;
@@ -529,15 +596,20 @@
  * Receive modes. Broadcast, Multicast, Promisc.
  */
 
-static void catc_multicast(unsigned char *addr, u8 *multicast)
+static inline u32 ether_crc_le(int cnt, unsigned char *addr)
 {
 	unsigned int crc = 0xffffffff;
 	u8 byte, idx, bit;
-
-        for (idx = 0; idx < 6; idx++)
+	
+        for (idx = 0; idx < cnt; idx++)
                 for (byte = *addr++, bit = 0; bit < 8; bit++, byte >>= 1)
                         crc = (crc >> 1) ^ (((crc ^ byte) & 1) ? 0xedb88320U : 0);
+	return crc;
+}
 
+static void catc_multicast(unsigned char *addr, u8 *multicast)
+{
+	unsigned int crc = ether_crc_le(6, addr);
 	multicast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);
 }
 
@@ -557,17 +629,33 @@
 
 	if (netdev->flags & IFF_PROMISC) {
 		memset(catc->multicast, 0xff, 64);
-		rx |= RxPromisc;
+		rx |= (!catc->is_f5u011) ? RxPromisc : AltRxPromisc;
 	} 
 
-	if (netdev->flags & IFF_ALLMULTI)
+	if (netdev->flags & IFF_ALLMULTI) {
 		memset(catc->multicast, 0xff, 64);
-
-	for (i = 0, mc = netdev->mc_list; mc && i < netdev->mc_count; i++, mc = mc->next)
-		catc_multicast(mc->dmi_addr, catc->multicast);
-
-	catc_set_reg_async(catc, RxUnit, rx);
-	catc_write_mem_async(catc, 0xfa80, catc->multicast, 64);
+	} else {
+		for (i = 0, mc = netdev->mc_list; mc && i < netdev->mc_count; i++, mc = mc->next) {
+			u32 crc = ether_crc_le(6, mc->dmi_addr);
+			if (!catc->is_f5u011) {
+				catc->multicast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);
+			} else {
+				catc->multicast[7-(crc >> 29)] |= 1 << ((crc >> 26) & 7);
+			}
+		}
+	}
+	if (!catc->is_f5u011) {
+		catc_set_reg_async(catc, RxUnit, rx);
+		catc_write_mem_async(catc, 0xfa80, catc->multicast, 64);
+	} else {
+		f5u011_mchash_async(catc, catc->multicast);
+		if (catc->rxmode[0] != rx) {
+			catc->rxmode[0] = rx;
+			dbg("Setting RX mode to %2.2X %2.2X", catc->rxmode[0],
+			    catc->rxmode[1]);
+			f5u011_rxmode_async(catc, catc->rxmode);
+		}
+	}
 }
 
 /*
@@ -594,6 +682,30 @@
                         return -EFAULT;
                 return 0;
         }
+
+	/* get settings */
+	case ETHTOOL_GSET:
+		if (catc->is_f5u011) {
+			struct ethtool_cmd ecmd = { 
+				ETHTOOL_GSET, 
+				SUPPORTED_10baseT_Half | SUPPORTED_TP, 
+				ADVERTISED_10baseT_Half | ADVERTISED_TP, 
+				SPEED_10, 
+				DUPLEX_HALF, 
+				PORT_TP, 
+				0, 
+				XCVR_INTERNAL, 
+				AUTONEG_DISABLE, 
+				1, 
+				1 
+			};
+			if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
+				return -EFAULT;
+			return 0;
+		} else {
+			return -EOPNOTSUPP;
+		}
+
         /* get link status */
         case ETHTOOL_GLINK: {
                 struct ethtool_value edata = {ETHTOOL_GLINK};
@@ -635,7 +747,8 @@
 
 	netif_start_queue(netdev);
 
-	mod_timer(&catc->timer, jiffies + STATS_UPDATE);
+	if (!catc->is_f5u011)
+		mod_timer(&catc->timer, jiffies + STATS_UPDATE);
 
 	return 0;
 }
@@ -646,7 +759,8 @@
 
 	netif_stop_queue(netdev);
 
-	del_timer_sync(&catc->timer);
+	if (!catc->is_f5u011)
+		del_timer_sync(&catc->timer);
 
 	usb_unlink_urb(&catc->rx_urb);
 	usb_unlink_urb(&catc->tx_urb);
@@ -665,7 +779,7 @@
 	struct net_device *netdev;
 	struct catc *catc;
 	u8 broadcast[6];
-	int i;
+	int i, pktsz;
 
 	if (usb_set_interface(usbdev, ifnum, 1)) {
                 err("Can't set altsetting 1.");
@@ -704,6 +818,20 @@
 	catc->timer.data = (long) catc;
 	catc->timer.function = catc_stats_timer;
 
+	/* The F5U011 has the same vendor/product as the netmate 
+	 *  but a device version of 0x130
+	 */
+	if (usbdev->descriptor.idVendor == 0x0423 && 
+	    usbdev->descriptor.idProduct == 0xa &&
+	    catc->usbdev->descriptor.bcdDevice == 0x0130) {
+		dbg("Testing for f5u011");
+		catc->is_f5u011 = 1;
+		atomic_set(&catc->recq_sz, 0);
+		pktsz = RX_PKT_SZ;
+	} else {
+		pktsz = RX_MAX_BURST * (PKT_SZ + 2);
+	}
+
 	FILL_CONTROL_URB(&catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),
 		NULL, NULL, 0, catc_ctrl_done, catc);
 
@@ -711,20 +839,21 @@
 		NULL, 0, catc_tx_done, catc);
 
 	FILL_BULK_URB(&catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),
-		catc->rx_buf, RX_MAX_BURST * (PKT_SZ + 2), catc_rx_done, catc);
+		catc->rx_buf, pktsz, catc_rx_done, catc);
 
 	FILL_INT_URB(&catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),
                 catc->irq_buf, 2, catc_irq_done, catc, 1);
 
-	dbg("Checking memory size\n");
-
-	i = 0x12345678;
-	catc_write_mem(catc, 0x7a80, &i, 4);
-	i = 0x87654321;	
-	catc_write_mem(catc, 0xfa80, &i, 4);
-	catc_read_mem(catc, 0x7a80, &i, 4);
+	if (!catc->is_f5u011) {
+		dbg("Checking memory size\n");
 
-	switch (i) {
+		i = 0x12345678;
+		catc_write_mem(catc, 0x7a80, &i, 4);
+		i = 0x87654321;	
+		catc_write_mem(catc, 0xfa80, &i, 4);
+		catc_read_mem(catc, 0x7a80, &i, 4);
+	  
+		switch (i) {
 		case 0x12345678:
 			catc_set_reg(catc, TxBufCount, 8);
 			catc_set_reg(catc, RxBufCount, 32);
@@ -737,44 +866,52 @@
 			catc_set_reg(catc, RxBufCount, 16);
 			dbg("32k Memory\n");
 			break;
+		}
+	  
+		dbg("Getting MAC from SEEROM.");
+	  
+		catc_get_mac(catc, netdev->dev_addr);
+		
+		dbg("Setting MAC into registers.");
+	  
+		for (i = 0; i < 6; i++)
+			catc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);
+		
+		dbg("Filling the multicast list.");
+	  
+		memset(broadcast, 0xff, 6);
+		catc_multicast(broadcast, catc->multicast);
+		catc_multicast(netdev->dev_addr, catc->multicast);
+		catc_write_mem(catc, 0xfa80, catc->multicast, 64);
+		
+		dbg("Clearing error counters.");
+		
+		for (i = 0; i < 8; i++)
+			catc_set_reg(catc, EthStats + i, 0);
+		catc->last_stats = jiffies;
+		
+		dbg("Enabling.");
+		
+		catc_set_reg(catc, MaxBurst, RX_MAX_BURST);
+		catc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);
+		catc_set_reg(catc, LEDCtrl, LEDLink);
+		catc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);
+	} else {
+		dbg("Performing reset\n");
+		catc_reset(catc);
+		catc_get_mac(catc, netdev->dev_addr);
+		
+		dbg("Setting RX Mode");
+		catc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;
+		catc->rxmode[1] = 0;
+		f5u011_rxmode(catc, catc->rxmode);
 	}
-
-	dbg("Getting MAC from SEEROM.");
-
-	catc_get_mac(catc, netdev->dev_addr);
-
-	dbg("Setting MAC into registers.");
-
-	for (i = 0; i < 6; i++)
-		catc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);
-
-	dbg("Filling the multicast list.");
-
-	memset(broadcast, 0xff, 8);
-	catc_multicast(broadcast, catc->multicast);
-	catc_multicast(netdev->dev_addr, catc->multicast);
-	catc_write_mem(catc, 0xfa80, catc->multicast, 64);
-
-	dbg("Clearing error counters.");
-
-	for (i = 0; i < 8; i++)
-		catc_set_reg(catc, EthStats + i, 0);
-	catc->last_stats = jiffies;
-
-	dbg("Enabling.");
-
-	catc_set_reg(catc, MaxBurst, RX_MAX_BURST);
-	catc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);
-	catc_set_reg(catc, LEDCtrl, LEDLink);
-	catc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);
-
 	dbg("Init done.");
-
-	printk(KERN_INFO "%s: CATC EL1210A NetMate USB Ethernet at usb%d:%d.%d, ",
-		netdev->name, usbdev->bus->busnum, usbdev->devnum, ifnum);
+	printk(KERN_INFO "%s: %s USB Ethernet at usb%d:%d.%d, ",
+	       netdev->name, (catc->is_f5u011) ? "Belkin F5U011" : "CATC EL1210A NetMate",
+	       usbdev->bus->busnum, usbdev->devnum, ifnum);
 	for (i = 0; i < 5; i++) printk("%2.2x:", netdev->dev_addr[i]);
 	printk("%2.2x.\n", netdev->dev_addr[i]);
-
 	return catc;
 }
 
@@ -791,7 +928,7 @@
  */
 
 static struct usb_device_id catc_id_table [] = {
-	{ USB_DEVICE(0x0423, 0xa) },	/* CATC Netmate */
+	{ USB_DEVICE(0x0423, 0xa) },	/* CATC Netmate, Belkin F5U011 */
 	{ USB_DEVICE(0x0423, 0xc) },	/* CATC Netmate II, Belkin F5U111 */
 	{ USB_DEVICE(0x08d1, 0x1) },	/* smartBridges smartNIC */
 	{ }
diff -Nur linux-2.4.19.old/drivers/usb/dabusb.c linux-2.4.19/drivers/usb/dabusb.c
--- linux-2.4.19.old/drivers/usb/dabusb.c	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/dabusb.c	Mon Nov 25 12:26:55 2002
@@ -83,7 +83,7 @@
 }
 /*-------------------------------------------------------------------*/
 #ifdef DEBUG 
-static void dump_urb (purb_t purb)
+static void dump_urb (struct urb *purb)
 {
 	dbg("urb                   :%p", purb);
 	dbg("next                  :%p", purb->next);
@@ -167,7 +167,7 @@
 	return 0;
 }
 /*-------------------------------------------------------------------*/
-static void dabusb_iso_complete (purb_t purb)
+static void dabusb_iso_complete (struct urb *purb)
 {
 	pbuff_t b = purb->context;
 	pdabusb_t s = b->s;
@@ -482,7 +482,7 @@
 	int rem;
 	int cnt;
 	pbuff_t b;
-	purb_t purb = NULL;
+	struct urb *purb = NULL;
 
 	dbg("dabusb_read");
 
@@ -605,6 +605,7 @@
 	}
 	if (usb_set_interface (s->usbdev, _DABUSB_IF, 1) < 0) {
 		err("set_interface failed");
+		up(&s->mutex);
 		return -EINVAL;
 	}
 	s->opened = 1;
diff -Nur linux-2.4.19.old/drivers/usb/dabusb.h linux-2.4.19/drivers/usb/dabusb.h
--- linux-2.4.19.old/drivers/usb/dabusb.h	Tue Oct  3 18:24:40 2000
+++ linux-2.4.19/drivers/usb/dabusb.h	Mon Nov 25 12:26:55 2002
@@ -38,7 +38,7 @@
 typedef struct 
 {
 	pdabusb_t s;
-	purb_t purb;
+	struct urb *purb;
 	struct list_head buff_list;
 } buff_t,*pbuff_t;
 
diff -Nur linux-2.4.19.old/drivers/usb/devices.c linux-2.4.19/drivers/usb/devices.c
--- linux-2.4.19.old/drivers/usb/devices.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/devices.c	Mon Nov 25 12:26:55 2002
@@ -61,6 +61,8 @@
 #include <linux/usbdevice_fs.h>
 #include <asm/uaccess.h>
 
+#include "hcd.h"
+
 #define MAX_TOPO_LEVEL		6
 
 /* Define ALLOW_SERIAL_NUMBER if you want to see the serial number of devices */
diff -Nur linux-2.4.19.old/drivers/usb/devio.c linux-2.4.19/drivers/usb/devio.c
--- linux-2.4.19.old/drivers/usb/devio.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/devio.c	Mon Nov 25 12:26:55 2002
@@ -52,7 +52,7 @@
 	unsigned int signr;
 	void *userbuffer;
         void *userurb;
-        urb_t urb;
+        struct urb urb;
 };
 
 static loff_t usbdev_lseek(struct file *file, loff_t offset, int orig)
@@ -138,7 +138,7 @@
 	return ret;
 }
 
-extern inline unsigned int ld2(unsigned int x)
+static inline unsigned int ld2(unsigned int x)
 {
         unsigned int r = 0;
         
@@ -169,7 +169,7 @@
 
 static struct async *alloc_async(unsigned int numisoframes)
 {
-        unsigned int assize = sizeof(struct async) + numisoframes * sizeof(iso_packet_descriptor_t);
+        unsigned int assize = sizeof(struct async) + numisoframes * sizeof(struct iso_packet_descriptor);
         struct async *as = kmalloc(assize, GFP_KERNEL);
         if (!as)
                 return NULL;
@@ -188,7 +188,7 @@
         kfree(as);
 }
 
-extern __inline__ void async_newpending(struct async *as)
+static inline void async_newpending(struct async *as)
 {
         struct dev_state *ps = as->ps;
         unsigned long flags;
@@ -198,7 +198,7 @@
         spin_unlock_irqrestore(&ps->lock, flags);
 }
 
-extern __inline__ void async_removepending(struct async *as)
+static inline void async_removepending(struct async *as)
 {
         struct dev_state *ps = as->ps;
         unsigned long flags;
@@ -209,7 +209,7 @@
         spin_unlock_irqrestore(&ps->lock, flags);
 }
 
-extern __inline__ struct async *async_getcompleted(struct dev_state *ps)
+static inline struct async *async_getcompleted(struct dev_state *ps)
 {
         unsigned long flags;
         struct async *as = NULL;
@@ -224,7 +224,7 @@
         return as;
 }
 
-extern __inline__ struct async *async_getpending(struct dev_state *ps, void *userurb)
+static inline struct async *async_getpending(struct dev_state *ps, void *userurb)
 {
         unsigned long flags;
         struct async *as;
@@ -245,7 +245,7 @@
         return NULL;
 }
 
-static void async_completed(purb_t urb)
+static void async_completed(struct urb *urb)
 {
         struct async *as = (struct async *)urb->context;
         struct dev_state *ps = as->ps;
@@ -772,7 +772,7 @@
 	struct usbdevfs_iso_packet_desc *isopkt = NULL;
 	struct usb_endpoint_descriptor *ep_desc;
 	struct async *as;
-	devrequest *dr = NULL;
+	struct usb_ctrlrequest *dr = NULL;
 	unsigned int u, totlen, isofrmlen;
 	int ret;
 
@@ -802,23 +802,23 @@
 		/* min 8 byte setup packet, max arbitrary */
 		if (uurb.buffer_length < 8 || uurb.buffer_length > PAGE_SIZE)
 			return -EINVAL;
-		if (!(dr = kmalloc(sizeof(devrequest), GFP_KERNEL)))
+		if (!(dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL)))
 			return -ENOMEM;
 		if (copy_from_user(dr, (unsigned char*)uurb.buffer, 8)) {
 			kfree(dr);
 			return -EFAULT;
 		}
-		if (uurb.buffer_length < (le16_to_cpup(&dr->length) + 8)) {
+		if (uurb.buffer_length < (le16_to_cpup(&dr->wLength) + 8)) {
 			kfree(dr);
 			return -EINVAL;
 		}
-		if ((ret = check_ctrlrecip(ps, dr->requesttype, le16_to_cpup(&dr->index)))) {
+		if ((ret = check_ctrlrecip(ps, dr->bRequestType, le16_to_cpup(&dr->wIndex)))) {
 			kfree(dr);
 			return ret;
 		}
-		uurb.endpoint = (uurb.endpoint & ~USB_ENDPOINT_DIR_MASK) | (dr->requesttype & USB_ENDPOINT_DIR_MASK);
+		uurb.endpoint = (uurb.endpoint & ~USB_ENDPOINT_DIR_MASK) | (dr->bRequestType & USB_ENDPOINT_DIR_MASK);
 		uurb.number_of_packets = 0;
-		uurb.buffer_length = le16_to_cpup(&dr->length);
+		uurb.buffer_length = le16_to_cpup(&dr->wLength);
 		uurb.buffer += 8;
 		if (!access_ok((uurb.endpoint & USB_DIR_IN) ?  VERIFY_WRITE : VERIFY_READ, uurb.buffer, uurb.buffer_length)) {
 			kfree(dr);
diff -Nur linux-2.4.19.old/drivers/usb/hc_simple.c linux-2.4.19/drivers/usb/hc_simple.c
--- linux-2.4.19.old/drivers/usb/hc_simple.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/hc_simple.c	Mon Nov 25 12:26:55 2002
@@ -0,0 +1,1072 @@
+/*-------------------------------------------------------------------------*/
+/*-------------------------------------------------------------------------*
+ * simple generic USB HCD frontend Version 0.9.5 (10/28/2001)
+ * for embedded HCs (SL811HS)
+ * 
+ * USB URB handling, hci_ hcs_
+ * URB queueing, qu_
+ * Transfer scheduling, sh_
+ * 
+ *
+ *-------------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *-------------------------------------------------------------------------*/
+
+/* main lock for urb access */
+static spinlock_t usb_urb_lock = SPIN_LOCK_UNLOCKED;
+
+/*-------------------------------------------------------------------------*/
+/*-------------------------------------------------------------------------*/
+/* URB HCD API function layer
+ * * * */
+
+/***************************************************************************
+ * Function Name : hcs_urb_queue
+ *
+ * This function initializes the urb status and length before queueing the 
+ * urb. 
+ *
+ * Input:  hci = data structure for the host controller
+ *         urb = USB request block data structure 
+ *
+ * Return: 0 
+ **************************************************************************/
+static inline int hcs_urb_queue (hci_t * hci, struct urb * urb)
+{
+	int i;
+
+	DBGFUNC ("enter hcs_urb_queue\n");
+	if (usb_pipeisoc (urb->pipe)) {
+		DBGVERBOSE ("hcs_urb_queue: isoc pipe\n");
+		for (i = 0; i < urb->number_of_packets; i++) {
+			urb->iso_frame_desc[i].actual_length = 0;
+			urb->iso_frame_desc[i].status = -EXDEV;
+		}
+
+		/* urb->next hack : 1 .. resub, 0 .. single shot */
+		/* urb->interval = urb->next ? 1 : 0; */
+	}
+
+	urb->status = -EINPROGRESS;
+	urb->actual_length = 0;
+	urb->error_count = 0;
+
+	if (usb_pipecontrol (urb->pipe))
+		hc_flush_data_cache (hci, urb->setup_packet, 8);
+	if (usb_pipeout (urb->pipe))
+		hc_flush_data_cache (hci, urb->transfer_buffer,
+				     urb->transfer_buffer_length);
+
+	qu_queue_urb (hci, urb);
+
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : hcs_return_urb
+ *
+ * This function the return path of URB back to the USB core. It calls the
+ * the urb complete function if exist, and also handles the resubmition of
+ * interrupt URBs.
+ *
+ * Input:  hci = data structure for the host controller
+ *         urb = USB request block data structure 
+ *         resub_ok = resubmit flag: 1 = submit urb again, 0 = not submit 
+ *
+ * Return: 0 
+ **************************************************************************/
+static int hcs_return_urb (hci_t * hci, struct urb * urb, int resub_ok)
+{
+	struct usb_device *dev = urb->dev;
+	int resubmit = 0;
+
+	DBGFUNC ("enter hcs_return_urb, urb pointer = 0x%x, "
+		 "transferbuffer point = 0x%x, "
+		 " setup packet pointer = 0x%x, context pointer = 0x%x \n",
+		 (__u32 *) urb, (__u32 *) urb->transfer_buffer,
+		 (__u32 *) urb->setup_packet, (__u32 *) urb->context);
+	if (urb_debug)
+		urb_print (urb, "RET", usb_pipeout (urb->pipe));
+
+	resubmit = urb->interval && resub_ok;
+
+	urb->dev = urb->hcpriv = NULL;
+
+	if (urb->complete) {
+		urb->complete (urb);	/* call complete */
+	}
+
+	if (resubmit) {
+		/* requeue the URB */
+		urb->dev = dev;
+		hcs_urb_queue (hci, urb);
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : hci_submit_urb
+ *
+ * This function is called by the USB core API when an URB is available to
+ * process.  This function does the following
+ *
+ * 1) Check the validity of the URB
+ * 2) Parse the device number from the URB
+ * 3) Pass the URB to the root hub routine if its intended for the hub, else
+ *    queue the urb for the attached device. 
+ *
+ * Input: urb = USB request block data structure 
+ *
+ * Return: 0 if success or error code 
+ **************************************************************************/
+static int hci_submit_urb (struct urb * urb)
+{
+	hci_t *hci;
+	unsigned int pipe = urb->pipe;
+	unsigned long flags;
+	int ret;
+
+	DBGFUNC ("enter hci_submit_urb, pipe = 0x%x\n", urb->pipe);
+	if (!urb->dev || !urb->dev->bus || urb->hcpriv)
+		return -EINVAL;
+
+	if (usb_endpoint_halted
+	    (urb->dev, usb_pipeendpoint (pipe), usb_pipeout (pipe))) {
+		printk ("hci_submit_urb: endpoint_halted\n");
+		return -EPIPE;
+	}
+	hci = (hci_t *) urb->dev->bus->hcpriv;
+
+	/* a request to the virtual root hub */
+
+	if (usb_pipedevice (pipe) == hci->rh.devnum) {
+		if (urb_debug > 1)
+			urb_print (urb, "SUB-RH", usb_pipein (pipe));
+
+		return rh_submit_urb (urb);
+	}
+
+	/* queue the URB to its endpoint-queue */
+
+	spin_lock_irqsave (&usb_urb_lock, flags);
+	ret = hcs_urb_queue (hci, urb);
+	if (ret != 0) {
+		/* error on return */
+		DBGERR
+		    ("hci_submit_urb: return err, ret = 0x%x, urb->status = 0x%x\n",
+		     ret, urb->status);
+	}
+
+	spin_unlock_irqrestore (&usb_urb_lock, flags);
+
+	return ret;
+
+}
+
+/***************************************************************************
+ * Function Name : hci_unlink_urb
+ *
+ * This function mark the URB to unlink
+ *
+ * Input: urb = USB request block data structure 
+ *
+ * Return: 0 if success or error code 
+ **************************************************************************/
+static int hci_unlink_urb (struct urb * urb)
+{
+	unsigned long flags;
+	hci_t *hci;
+	DECLARE_WAITQUEUE (wait, current);
+	void *comp = NULL;
+
+	DBGFUNC ("enter hci_unlink_urb\n");
+
+	if (!urb)		/* just to be sure */
+		return -EINVAL;
+
+	if (!urb->dev || !urb->dev->bus)
+		return -ENODEV;
+
+	hci = (hci_t *) urb->dev->bus->hcpriv;
+
+	/* a request to the virtual root hub */
+	if (usb_pipedevice (urb->pipe) == hci->rh.devnum) {
+		return rh_unlink_urb (urb);
+	}
+
+	if (urb_debug)
+		urb_print (urb, "UNLINK", 1);
+
+	spin_lock_irqsave (&usb_urb_lock, flags);
+
+	if (!list_empty (&urb->urb_list) && urb->status == -EINPROGRESS) {
+		/* URB active? */
+
+		if (urb->
+		    transfer_flags & (USB_ASYNC_UNLINK | USB_TIMEOUT_KILLED)) {
+			/* asynchron with callback */
+
+			list_del (&urb->urb_list);	/* relink the urb to the del list */
+			list_add (&urb->urb_list, &hci->del_list);
+			spin_unlock_irqrestore (&usb_urb_lock, flags);
+
+		} else {
+			/* synchron without callback */
+
+			add_wait_queue (&hci->waitq, &wait);
+
+			set_current_state (TASK_UNINTERRUPTIBLE);
+			comp = urb->complete;
+			urb->complete = NULL;
+
+			list_del (&urb->urb_list);	/* relink the urb to the del list */
+			list_add (&urb->urb_list, &hci->del_list);
+
+			spin_unlock_irqrestore (&usb_urb_lock, flags);
+
+			schedule_timeout (HZ / 50);
+
+			if (!list_empty (&urb->urb_list))
+				list_del (&urb->urb_list);
+
+			urb->complete = comp;
+			urb->hcpriv = NULL;
+			remove_wait_queue (&hci->waitq, &wait);
+		}
+	} else {
+		/* hcd does not own URB but we keep the driver happy anyway */
+		spin_unlock_irqrestore (&usb_urb_lock, flags);
+
+		if (urb->complete && (urb->transfer_flags & USB_ASYNC_UNLINK)) {
+			urb->status = -ENOENT;
+			urb->actual_length = 0;
+			urb->complete (urb);
+			urb->status = 0;
+		} else {
+			urb->status = -ENOENT;
+		}
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : hci_alloc_dev
+ *
+ * This function allocates private data space for the usb device and 
+ * initialize the endpoint descriptor heads.
+ *
+ * Input: usb_dev = pointer to the usb device 
+ *
+ * Return: 0 if success or error code 
+ **************************************************************************/
+static int hci_alloc_dev (struct usb_device *usb_dev)
+{
+	struct hci_device *dev;
+	int i;
+
+	DBGFUNC ("enter hci_alloc_dev\n");
+	dev = kmalloc (sizeof (*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	memset (dev, 0, sizeof (*dev));
+
+	for (i = 0; i < 32; i++) {
+		INIT_LIST_HEAD (&(dev->ed[i].urb_queue));
+		dev->ed[i].pipe_head = NULL;
+	}
+
+	usb_dev->hcpriv = dev;
+
+	DBGVERBOSE ("USB HC dev alloc %d bytes\n", sizeof (*dev));
+
+	return 0;
+
+}
+
+/***************************************************************************
+ * Function Name : hci_free_dev
+ *
+ * This function de-allocates private data space for the usb devic
+ *
+ * Input: usb_dev = pointer to the usb device 
+ *
+ * Return: 0  
+ **************************************************************************/
+static int hci_free_dev (struct usb_device *usb_dev)
+{
+	DBGFUNC ("enter hci_free_dev\n");
+
+	if (usb_dev->hcpriv)
+		kfree (usb_dev->hcpriv);
+
+	usb_dev->hcpriv = NULL;
+
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : hci_get_current_frame_number
+ *
+ * This function get the current USB frame number
+ *
+ * Input: usb_dev = pointer to the usb device 
+ *
+ * Return: frame number  
+ **************************************************************************/
+static int hci_get_current_frame_number (struct usb_device *usb_dev)
+{
+	hci_t *hci = usb_dev->bus->hcpriv;
+	DBGFUNC ("enter hci_get_current_frame_number, frame = 0x%x \r\n",
+		 hci->frame_number);
+
+	return (hci->frame_number);
+}
+
+/***************************************************************************
+ * List of all io-functions 
+ **************************************************************************/
+
+static struct usb_operations hci_device_operations = {
+	allocate:		hci_alloc_dev,
+	deallocate:		hci_free_dev,
+	get_frame_number:	hci_get_current_frame_number,
+	submit_urb:		hci_submit_urb,
+	unlink_urb:		hci_unlink_urb,
+};
+
+/***************************************************************************
+ * URB queueing:
+ * 
+ * For each type of transfer (INTR, BULK, ISO, CTRL) there is a list of 
+ * active URBs.
+ * (hci->intr_list, hci->bulk_list, hci->iso_list, hci->ctrl_list)
+ * For every endpoint the head URB of the queued URBs is linked to one of 
+ * those lists.
+ * 
+ * The rest of the queued URBs of an endpoint are linked into a 
+ * private URB list for each endpoint. (hci_dev->ed [endpoint_io].urb_queue)
+ * hci_dev->ed [endpoint_io].pipe_head .. points to the head URB which is 
+ * in one of the active URB lists.
+ * 
+ * The index of an endpoint consists of its number and its direction.
+ * 
+ * The state of an intr and iso URB is 0. 
+ * For ctrl URBs the states are US_CTRL_SETUP, US_CTRL_DATA, US_CTRL_ACK
+ * Bulk URBs states are US_BULK and US_BULK0 (with 0-len packet)
+ * 
+ **************************************************************************/
+
+/***************************************************************************
+ * Function Name : qu_urb_timeout
+ *
+ * This function is called when the URB timeout. The function unlinks the 
+ * URB. 
+ *
+ * Input: lurb: URB 
+ *
+ * Return: none  
+ **************************************************************************/
+#ifdef HC_URB_TIMEOUT
+static void qu_urb_timeout (unsigned long lurb)
+{
+	struct urb *urb = (struct urb *) lurb;
+
+	DBGFUNC ("enter qu_urb_timeout\n");
+	urb->transfer_flags |= USB_TIMEOUT_KILLED;
+	hci_unlink_urb (urb);
+}
+#endif
+
+/***************************************************************************
+ * Function Name : qu_pipeindex
+ *
+ * This function gets the index of the pipe.   
+ *
+ * Input: pipe: the urb pipe 
+ *
+ * Return: index  
+ **************************************************************************/
+static inline int qu_pipeindex (__u32 pipe)
+{
+	DBGFUNC ("enter qu_pipeindex\n");
+	return (usb_pipeendpoint (pipe) << 1) | (usb_pipecontrol (pipe) ? 0 : usb_pipeout (pipe));
+}
+
+/***************************************************************************
+ * Function Name : qu_seturbstate
+ *
+ * This function set the state of the URB.  
+ * 
+ * control pipe: 3 states -- Setup, data, status
+ * interrupt and bulk pipe: 1 state -- data    
+ *
+ * Input: urb = USB request block data structure 
+ *        state = the urb state
+ *
+ * Return: none  
+ **************************************************************************/
+static inline void qu_seturbstate (struct urb * urb, int state)
+{
+	DBGFUNC ("enter qu_seturbstate\n");
+	urb->pipe &= ~0x1f;
+	urb->pipe |= state & 0x1f;
+}
+
+/***************************************************************************
+ * Function Name : qu_urbstate
+ *
+ * This function get the current state of the URB.  
+ * 
+ * Input: urb = USB request block data structure 
+ *
+ * Return: none  
+ **************************************************************************/
+static inline int qu_urbstate (struct urb * urb)
+{
+
+	DBGFUNC ("enter qu_urbstate\n");
+
+	return urb->pipe & 0x1f;
+}
+
+/***************************************************************************
+ * Function Name : qu_queue_active_urb
+ *
+ * This function adds the urb to the appropriate active urb list and set
+ * the urb state.
+ * 
+ * There are four active lists: isochoronous list, interrupt list, 
+ * control list, and bulk list.
+ * 
+ * Input: hci = data structure for the host controller 
+ *        urb = USB request block data structure 
+ *        ed = endpoint descriptor
+ *
+ * Return: none  
+ **************************************************************************/
+static inline void qu_queue_active_urb (hci_t * hci, struct urb * urb, epd_t * ed)
+{
+	int urb_state = 0;
+	DBGFUNC ("enter qu_queue_active_urb\n");
+	switch (usb_pipetype (urb->pipe)) {
+	case PIPE_CONTROL:
+		list_add (&urb->urb_list, &hci->ctrl_list);
+		urb_state = US_CTRL_SETUP;
+		break;
+
+	case PIPE_BULK:
+		list_add (&urb->urb_list, &hci->bulk_list);
+		if ((urb->transfer_flags & USB_ZERO_PACKET)
+		    && urb->transfer_buffer_length > 0
+		    &&
+		    ((urb->transfer_buffer_length %
+		      usb_maxpacket (urb->dev, urb->pipe,
+				     usb_pipeout (urb->pipe))) == 0)) {
+			urb_state = US_BULK0;
+		}
+		break;
+
+	case PIPE_INTERRUPT:
+		urb->start_frame = hci->frame_number;
+		list_add (&urb->urb_list, &hci->intr_list);
+		break;
+
+	case PIPE_ISOCHRONOUS:
+		list_add (&urb->urb_list, &hci->iso_list);
+		break;
+	}
+
+#ifdef HC_URB_TIMEOUT
+	if (urb->timeout) {
+		ed->timeout.data = (unsigned long) urb;
+		ed->timeout.expires = urb->timeout + jiffies;
+		ed->timeout.function = qu_urb_timeout;
+		add_timer (&ed->timeout);
+	}
+#endif
+
+	qu_seturbstate (urb, urb_state);
+}
+
+/***************************************************************************
+ * Function Name : qu_queue_urb
+ *
+ * This function adds the urb to the endpoint descriptor list 
+ * 
+ * Input: hci = data structure for the host controller 
+ *        urb = USB request block data structure 
+ *
+ * Return: none  
+ **************************************************************************/
+static int qu_queue_urb (hci_t * hci, struct urb * urb)
+{
+	struct hci_device *hci_dev = usb_to_hci (urb->dev);
+	epd_t *ed = &hci_dev->ed[qu_pipeindex (urb->pipe)];
+
+	DBGFUNC ("Enter qu_queue_urb\n");
+
+	/* for ISOC transfers calculate start frame index */
+
+	if (usb_pipeisoc (urb->pipe) && urb->transfer_flags & USB_ISO_ASAP) {
+		urb->start_frame = ((ed->pipe_head) ? (ed->last_iso + 1) : hci_get_current_frame_number (urb-> dev) + 1) & 0xffff;
+	}
+
+	if (ed->pipe_head) {
+		__list_add (&urb->urb_list, ed->urb_queue.prev,
+			    &(ed->urb_queue));
+	} else {
+		ed->pipe_head = urb;
+		qu_queue_active_urb (hci, urb, ed);
+		if (++hci->active_urbs == 1)
+			hc_start_int (hci);
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : qu_next_urb
+ *
+ * This function removes the URB from the queue and add the next URB to 
+ * active list. 
+ * 
+ * Input: hci = data structure for the host controller 
+ *        urb = USB request block data structure 
+ *        resub_ok = resubmit flag
+ *
+ * Return: pointer to the next urb  
+ **************************************************************************/
+static struct urb *qu_next_urb (hci_t * hci, struct urb * urb, int resub_ok)
+{
+	struct hci_device *hci_dev = usb_to_hci (urb->dev);
+	epd_t *ed = &hci_dev->ed[qu_pipeindex (urb->pipe)];
+
+	DBGFUNC ("enter qu_next_urb\n");
+	list_del (&urb->urb_list);
+	INIT_LIST_HEAD (&urb->urb_list);
+	if (ed->pipe_head == urb) {
+
+#ifdef HC_URB_TIMEOUT
+		if (urb->timeout)
+			del_timer (&ed->timeout);
+#endif
+
+		if (!--hci->active_urbs)
+			hc_stop_int (hci);
+
+		if (!list_empty (&ed->urb_queue)) {
+			urb = list_entry (ed->urb_queue.next, struct urb, urb_list);
+			list_del (&urb->urb_list);
+			INIT_LIST_HEAD (&urb->urb_list);
+			ed->pipe_head = urb;
+			qu_queue_active_urb (hci, urb, ed);
+		} else {
+			ed->pipe_head = NULL;
+			urb = NULL;
+		}
+	}
+	return urb;
+}
+
+/***************************************************************************
+ * Function Name : qu_return_urb
+ *
+ * This function is part of the return path.   
+ * 
+ * Input: hci = data structure for the host controller 
+ *        urb = USB request block data structure 
+ *        resub_ok = resubmit flag
+ *
+ * Return: pointer to the next urb  
+ **************************************************************************/
+static struct urb *qu_return_urb (hci_t * hci, struct urb * urb, int resub_ok)
+{
+	struct urb *next_urb;
+
+	DBGFUNC ("enter qu_return_rub\n");
+	next_urb = qu_next_urb (hci, urb, resub_ok);
+	hcs_return_urb (hci, urb, resub_ok);
+	return next_urb;
+}
+
+/***************************************************************************
+ * Function Name : sh_scan_iso_urb_list
+ *
+ * This function goes throught the isochronous urb list and schedule the 
+ * the transfer.   
+ *
+ * Note: This function has not tested yet
+ * 
+ * Input: hci = data structure for the host controller 
+ *        list_lh = pointer to the isochronous list 
+ *        frame_number = the frame number 
+ *
+ * Return: 0 = unsuccessful; 1 = successful  
+ **************************************************************************/
+static int sh_scan_iso_urb_list (hci_t * hci, struct list_head *list_lh,
+				 int frame_number)
+{
+	struct list_head *lh = list_lh->next;
+	struct urb *urb;
+
+	DBGFUNC ("enter sh_scan_iso_urb_list\n");
+	hci->td_array->len = 0;
+
+	while (lh != list_lh) {
+		urb = list_entry (lh, struct urb, urb_list);
+		lh = lh->next;
+		if (((frame_number - urb->start_frame) & 0x7ff) <
+		    urb->number_of_packets) {
+			if (!sh_add_packet (hci, urb)) {
+				return 0;
+			} else {
+				if (((frame_number -
+				      urb->start_frame) & 0x7ff) > 0x400) {
+					if (qu_urbstate (urb) > 0)
+						urb = qu_return_urb (hci, urb, 1);
+					else
+						urb = qu_next_urb (hci, urb, 1);
+
+					if (lh == list_lh && urb)
+						lh = &urb->urb_list;
+				}
+			}
+		}
+	}
+	return 1;
+}
+
+/***************************************************************************
+ * Function Name : sh_scan_urb_list
+ *
+ * This function goes through the urb list and schedule the 
+ * the transaction.   
+ * 
+ * Input: hci = data structure for the host controller 
+ *        list_lh = pointer to the isochronous list 
+ *
+ * Return: 0 = unsuccessful; 1 = successful  
+ **************************************************************************/
+static int sh_scan_urb_list (hci_t * hci, struct list_head *list_lh)
+{
+	struct list_head *lh = NULL;
+	struct urb *urb;
+
+	if (list_lh == NULL) {
+		DBGERR ("sh_scan_urb_list: error, list_lh == NULL\n");
+	}
+
+	DBGFUNC ("enter sh_scan_urb_list: frame# \n");
+
+	list_for_each (lh, list_lh) {
+		urb = list_entry (lh, struct urb, urb_list);
+		if (urb == NULL)
+			return 1;
+		if (!usb_pipeint (urb->pipe)
+		    || (((hci->frame_number - urb->start_frame)
+			 & 0x7ff) >= urb->interval)) {
+			DBGVERBOSE ("sh_scan_urb_list !INT: %d fr_no: %d int: %d pint: %d\n",
+				    urb->start_frame, hci->frame_number, urb->interval,
+				    usb_pipeint (urb->pipe));
+			if (!sh_add_packet (hci, urb)) {
+				return 0;
+			} else {
+				DBGVERBOSE ("INT: start: %d fr_no: %d int: %d pint: %d\n",
+					    urb->start_frame, hci->frame_number,
+					    urb->interval, usb_pipeint (urb->pipe));
+				urb->start_frame = hci->frame_number;
+				return 0;
+
+			}
+		}
+	}
+	return 1;
+}
+
+/***************************************************************************
+ * Function Name : sh_shedule_trans
+ *
+ * This function schedule the USB transaction.
+ * This function will process the endpoint in the following order: 
+ * interrupt, control, and bulk.    
+ * 
+ * Input: hci = data structure for the host controller 
+ *        isSOF = flag indicate if Start Of Frame has occurred 
+ *
+ * Return: 0   
+ **************************************************************************/
+static int sh_schedule_trans (hci_t * hci, int isSOF)
+{
+	int units_left = 1;
+	struct list_head *lh;
+
+	if (hci == NULL) {
+		DBGERR ("sh_schedule_trans: hci == NULL\n");
+		return 0;
+	}
+	if (hci->td_array == NULL) {
+		DBGERR ("sh_schedule_trans: hci->td_array == NULL\n");
+		return 0;
+	}
+
+	if (hci->td_array->len != 0) {
+		DBGERR ("ERROR: schedule, hci->td_array->len = 0x%x, s/b: 0\n",
+			hci->td_array->len);
+	}
+
+	/* schedule the next available interrupt transfer or the next
+	 * stage of the interrupt transfer */
+
+	if (hci->td_array->len == 0 && !list_empty (&hci->intr_list)) {
+		units_left = sh_scan_urb_list (hci, &hci->intr_list);
+	}
+
+	/* schedule the next available control transfer or the next
+	 * stage of the control transfer */
+
+	if (hci->td_array->len == 0 && !list_empty (&hci->ctrl_list) && units_left > 0) {
+		units_left = sh_scan_urb_list (hci, &hci->ctrl_list);
+	}
+
+	/* schedule the next available bulk transfer or the next
+	 * stage of the bulk transfer */
+
+	if (hci->td_array->len == 0 && !list_empty (&hci->bulk_list) && units_left > 0) {
+		sh_scan_urb_list (hci, &hci->bulk_list);
+
+		/* be fair to each BULK URB (move list head around) 
+		 * only when the new SOF happens */
+
+		lh = hci->bulk_list.next;
+		list_del (&hci->bulk_list);
+		list_add (&hci->bulk_list, lh);
+	}
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : sh_add_packet
+ *
+ * This function forms the packet and transmit the packet. This function
+ * will handle all endpoint type: isochoronus, interrupt, control, and 
+ * bulk.
+ * 
+ * Input: hci = data structure for the host controller 
+ *        urb = USB request block data structure 
+ *
+ * Return: 0 = unsucessful; 1 = successful   
+ **************************************************************************/
+static int sh_add_packet (hci_t * hci, struct urb * urb)
+{
+	__u8 *data = NULL;
+	int len = 0;
+	int toggle = 0;
+	int maxps = usb_maxpacket (urb->dev, urb->pipe, usb_pipeout (urb->pipe));
+	int endpoint = usb_pipeendpoint (urb->pipe);
+	int address = usb_pipedevice (urb->pipe);
+	int slow = (((urb->pipe) >> 26) & 1);
+	int out = usb_pipeout (urb->pipe);
+	int pid = 0;
+	int ret;
+	int i = 0;
+	int iso = 0;
+
+	DBGFUNC ("enter sh_add_packet\n");
+	if (maxps == 0)
+		maxps = 8;
+
+	/* calculate len, toggle bit and add the transaction */
+	switch (usb_pipetype (urb->pipe)) {
+	case PIPE_ISOCHRONOUS:
+		pid = out ? PID_OUT : PID_IN;
+		iso = 1;
+		i = hci->frame_number - urb->start_frame;
+		data = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
+		len = urb->iso_frame_desc[i].length;
+		break;
+
+	case PIPE_BULK:	/* BULK and BULK0 */
+	case PIPE_INTERRUPT:
+		pid = out ? PID_OUT : PID_IN;
+		len = urb->transfer_buffer_length - urb->actual_length;
+		data = urb->transfer_buffer + urb->actual_length;
+		toggle = usb_gettoggle (urb->dev, endpoint, out);
+		break;
+
+	case PIPE_CONTROL:
+		switch (qu_urbstate (urb)) {
+		case US_CTRL_SETUP:
+			len = 8;
+			pid = PID_SETUP;
+			data = urb->setup_packet;
+			toggle = 0;
+			break;
+
+		case US_CTRL_DATA:
+			if (!hci->last_packet_nak) {
+				/* The last packet received is not a nak:
+				 * reset the nak count
+				 */
+
+				hci->nakCnt = 0;
+			}
+			if (urb->transfer_buffer_length != 0) {
+				pid = out ? PID_OUT : PID_IN;
+				len = urb->transfer_buffer_length - urb->actual_length;
+				data = urb->transfer_buffer + urb->actual_length;
+				toggle = (urb->actual_length & maxps) ? 0 : 1;
+				usb_settoggle (urb->dev,
+					       usb_pipeendpoint (urb->pipe),
+					       usb_pipeout (urb->pipe), toggle);
+				break;
+			} else {
+				/* correct state and fall through */
+				qu_seturbstate (urb, US_CTRL_ACK);
+			}
+
+		case US_CTRL_ACK:
+			len = 0;
+
+			/* reply in opposite direction */
+			pid = !out ? PID_OUT : PID_IN;
+			toggle = 1;
+			usb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe),
+				       usb_pipeout (urb->pipe), toggle);
+			break;
+		}
+	}
+
+	ret =
+	    hc_add_trans (hci, len, data, toggle, maxps, slow, endpoint,
+			  address, pid, iso, qu_urbstate (urb));
+
+	DBGVERBOSE ("transfer_pa: addr:%d ep:%d pid:%x tog:%x iso:%x sl:%x "
+		    "max:%d\n len:%d ret:%d data:%p left:%d\n",
+		    address, endpoint, pid, toggle, iso, slow,
+		    maxps, len, ret, data, hci->hp.units_left);
+
+	if (ret >= 0) {
+		hci->td_array->td[hci->td_array->len].urb = urb;
+		hci->td_array->td[hci->td_array->len].len = ret;
+		hci->td_array->td[hci->td_array->len].iso_index = i;
+		hci->td_array->len++;
+		hci->active_trans = 1;
+		return 1;
+	}
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : cc_to_error
+ *
+ * This function maps the SL811HS hardware error code to the linux USB error
+ * code.
+ * 
+ * Input: cc = hardware error code 
+ *
+ * Return: USB error code   
+ **************************************************************************/
+static int cc_to_error (int cc)
+{
+	int errCode = 0;
+	if (cc & SL11H_STATMASK_ERROR) {
+		errCode |= -EILSEQ;
+	} else if (cc & SL11H_STATMASK_OVF) {
+		errCode |= -EOVERFLOW;
+	} else if (cc & SL11H_STATMASK_STALL) {
+		errCode |= -EPIPE;
+	}
+	return errCode;
+}
+
+/***************************************************************************
+ * Function Name : sh_done_list
+ *
+ * This function process the packet when it has done finish transfer.
+ * 
+ * 1) It handles hardware error
+ * 2) It updates the URB state
+ * 3) If the USB transaction is complete, it start the return stack path.
+ * 
+ * Input: hci = data structure for the host controller 
+ *        isExcessNak = flag tells if there excess NAK condition occurred 
+ *
+ * Return:  urb_state or -1 if the transaction has complete   
+ **************************************************************************/
+static int sh_done_list (hci_t * hci, int *isExcessNak)
+{
+	int actbytes = 0;
+	int active = 0;
+	void *data = NULL;
+	int cc;
+	int maxps;
+	int toggle;
+	struct urb *urb;
+	int urb_state = 0;
+	int ret = 1;		/* -1 parse abbort, 1 parse ok, 0 last element */
+	int trans = 0;
+	int len;
+	int iso_index = 0;
+	int out;
+	int pid = 0;
+	int debugLen = 0;
+
+	*isExcessNak = 0;
+
+	DBGFUNC ("enter sh_done_list: td_array->len = 0x%x\n",
+		 hci->td_array->len);
+
+	debugLen = hci->td_array->len;
+	if (debugLen > 1)
+		DBGERR ("sh_done_list: td_array->len = 0x%x > 1\n",
+			hci->td_array->len);
+
+	for (trans = 0; ret && trans < hci->td_array->len && trans < MAX_TRANS;
+	     trans++) {
+		urb = hci->td_array->td[trans].urb;
+		len = hci->td_array->td[trans].len;
+		out = usb_pipeout (urb->pipe);
+
+		if (usb_pipeisoc (urb->pipe)) {
+			iso_index = hci->td_array->td[trans].iso_index;
+			data = urb->transfer_buffer + urb->iso_frame_desc[iso_index].offset;
+			toggle = 0;
+		} else {
+			data = urb->transfer_buffer + urb->actual_length;
+			toggle = usb_gettoggle (urb->dev,
+						usb_pipeendpoint (urb->pipe),
+						usb_pipeout (urb->pipe));
+
+		}
+		urb_state = qu_urbstate (urb);
+		pid = out ? PID_OUT : PID_IN;
+		ret = hc_parse_trans (hci, &actbytes, data, &cc, &toggle, len,
+				      pid, urb_state);
+		maxps = usb_maxpacket (urb->dev, urb->pipe, usb_pipeout (urb->pipe));
+
+		if (maxps == 0)
+			maxps = 8;
+
+		active = (urb_state != US_CTRL_SETUP) && (actbytes && !(actbytes & (maxps - 1)));
+
+		/* If the transfer is not bulk in, then it is necessary to get all
+		 * data specify by the urb->transfer_len.
+		 */
+
+		if (!(usb_pipebulk (urb->pipe) && usb_pipein (urb->pipe)))
+			active = active && (urb->transfer_buffer_length != urb->actual_length + actbytes);
+
+		if (urb->transfer_buffer_length == urb->actual_length + actbytes)
+			active = 0;
+
+		if ((cc &
+		     (SL11H_STATMASK_ERROR | SL11H_STATMASK_TMOUT |
+		      SL11H_STATMASK_OVF | SL11H_STATMASK_STALL))
+		    && !(cc & SL11H_STATMASK_NAK)) {
+			if (++urb->error_count > 3) {
+				DBGERR ("done_list: excessive error: errcount = 0x%x, cc = 0x%x\n",
+					urb->error_count, cc);
+				urb_state = 0;
+				active = 0;
+			} else {
+				DBGERR ("done_list: packet err, cc = 0x%x, "
+					" urb->length = 0x%x, actual_len = 0x%x,"
+					" urb_state =0x%x\n",
+					cc, urb->transfer_buffer_length,
+					urb->actual_length, urb_state);
+//			if (cc & SL11H_STATMASK_STALL) {
+				/* The USB function is STALLED on a control pipe (0), 
+				 * then it needs to send the SETUP command again to 
+				 * clear the STALL condition
+				 */
+
+//				if (usb_pipeendpoint (urb->pipe) == 0) {
+//					urb_state = 2;  
+//					active = 0;
+//				}
+//			} else   
+				active = 1;
+			}
+		} else {
+			if (cc & SL11H_STATMASK_NAK) {
+				if (hci->nakCnt < 0x10000) {
+					hci->nakCnt++;
+					hci->last_packet_nak = 1;
+					active = 1;
+					*isExcessNak = 0;
+				} else {
+					DBGERR ("done_list: nak count exceed limit\n");
+					active = 0;
+					*isExcessNak = 1;
+					hci->nakCnt = 0;
+				}
+			} else {
+				hci->nakCnt = 0;
+				hci->last_packet_nak = 0;
+			}
+
+			if (urb_state != US_CTRL_SETUP) {
+				/* no error */
+				urb->actual_length += actbytes;
+				usb_settoggle (urb->dev,
+					       usb_pipeendpoint (urb->pipe),
+					       usb_pipeout (urb->pipe), toggle);
+			}
+			if (usb_pipeisoc (urb->pipe)) {
+				urb->iso_frame_desc[iso_index].actual_length = actbytes;
+				urb->iso_frame_desc[iso_index].status = cc_to_error (cc);
+				active = (iso_index < urb->number_of_packets);
+			}
+		}
+		if (!active) {
+			if (!urb_state) {
+				urb->status = cc_to_error (cc);
+				if (urb->status) {
+					DBGERR ("error on received packet: urb->status = 0x%x\n",
+						urb->status);
+				}
+				hci->td_array->len = 0;
+				qu_return_urb (hci, urb, 1);
+				return -1;
+			} else {
+				/* We do not want to decrement the urb_state if exceeded nak,
+				 * because we need to finish the data stage of the control 
+				 * packet 
+				 */
+
+				if (!(*isExcessNak))
+					urb_state--;
+				qu_seturbstate (urb, urb_state);
+			}
+		}
+	}
+
+	if (urb_state < 0)
+		DBGERR ("ERROR: done_list, urb_state = %d, suppose > 0\n",
+			urb_state);
+	if (debugLen != hci->td_array->len) {
+		DBGERR ("ERROR: done_list, debugLen!= td_array->len,"
+			"debugLen = 0x%x, hci->td_array->len = 0x%x\n",
+			debugLen, hci->td_array->len);
+	}
+
+	hci->td_array->len = 0;
+
+	return urb_state;
+}
diff -Nur linux-2.4.19.old/drivers/usb/hc_simple.h linux-2.4.19/drivers/usb/hc_simple.h
--- linux-2.4.19.old/drivers/usb/hc_simple.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/hc_simple.h	Mon Nov 25 12:26:55 2002
@@ -0,0 +1,231 @@
+/*-------------------------------------------------------------------------*/
+/* list of all controllers using this driver 
+ * */
+
+static LIST_HEAD (hci_hcd_list);
+
+/* URB states (urb_state) */
+/* isoc, interrupt single state */
+
+/* bulk transfer main state and 0-length packet */
+#define US_BULK		0
+#define US_BULK0	1
+/* three setup states */
+#define US_CTRL_SETUP	2
+#define US_CTRL_DATA	1
+#define US_CTRL_ACK	0
+
+/*-------------------------------------------------------------------------*/
+/* HC private part of a device descriptor
+ * */
+
+#define NUM_EDS 32
+
+typedef struct epd {
+	struct urb *pipe_head;
+	struct list_head urb_queue;
+//	int urb_state;
+	struct timer_list timeout;
+	int last_iso;		/* timestamp of last queued ISOC transfer */
+
+} epd_t;
+
+struct hci_device {
+	epd_t ed[NUM_EDS];
+};
+
+/*-------------------------------------------------------------------------*/
+/* Virtual Root HUB 
+ */
+
+#define usb_to_hci(usb)	((struct hci_device *)(usb)->hcpriv)
+
+struct virt_root_hub {
+	int devnum;		/* Address of Root Hub endpoint */
+	void *urb;		/* interrupt URB of root hub */
+	int send;		/* active flag */
+	int interval;		/* intervall of roothub interrupt transfers */
+	struct timer_list rh_int_timer;	/* intervall timer for rh interrupt EP */
+};
+
+#if 1
+/* USB HUB CONSTANTS (not OHCI-specific; see hub.h and USB spec) */
+
+/* destination of request */
+#define RH_INTERFACE		0x01
+#define RH_ENDPOINT		0x02
+#define RH_OTHER		0x03
+
+#define RH_CLASS		0x20
+#define RH_VENDOR		0x40
+
+/* Requests: bRequest << 8 | bmRequestType */
+#define RH_GET_STATUS		0x0080
+#define RH_CLEAR_FEATURE	0x0100
+#define RH_SET_FEATURE		0x0300
+#define RH_SET_ADDRESS		0x0500
+#define RH_GET_DESCRIPTOR	0x0680
+#define RH_SET_DESCRIPTOR	0x0700
+#define RH_GET_CONFIGURATION	0x0880
+#define RH_SET_CONFIGURATION	0x0900
+#define RH_GET_STATE		0x0280
+#define RH_GET_INTERFACE	0x0A80
+#define RH_SET_INTERFACE	0x0B00
+#define RH_SYNC_FRAME		0x0C80
+/* Our Vendor Specific Request */
+#define RH_SET_EP		0x2000
+
+/* Hub port features */
+#define RH_PORT_CONNECTION	0x00
+#define RH_PORT_ENABLE		0x01
+#define RH_PORT_SUSPEND		0x02
+#define RH_PORT_OVER_CURRENT	0x03
+#define RH_PORT_RESET		0x04
+#define RH_PORT_POWER		0x08
+#define RH_PORT_LOW_SPEED	0x09
+
+#define RH_C_PORT_CONNECTION	0x10
+#define RH_C_PORT_ENABLE	0x11
+#define RH_C_PORT_SUSPEND	0x12
+#define RH_C_PORT_OVER_CURRENT	0x13
+#define RH_C_PORT_RESET		0x14
+
+/* Hub features */
+#define RH_C_HUB_LOCAL_POWER	0x00
+#define RH_C_HUB_OVER_CURRENT	0x01
+
+#define RH_DEVICE_REMOTE_WAKEUP	0x00
+#define RH_ENDPOINT_STALL	0x01
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+/* struct for each HC 
+ */
+
+#define MAX_TRANS	32
+
+typedef struct td {
+	struct urb *urb;
+	__u16 len;
+	__u16 iso_index;
+} td_t;
+
+typedef struct td_array {
+	int len;
+	td_t td[MAX_TRANS];
+} td_array_t;
+
+typedef struct hci {
+	struct virt_root_hub rh;	/* roothub */
+	wait_queue_head_t waitq;	/* deletion of URBs and devices needs a waitqueue */
+	int active;			/* HC is operating */
+
+	struct list_head ctrl_list;	/* set of ctrl endpoints */
+	struct list_head bulk_list;	/* set of bulk endpoints */
+	struct list_head iso_list;	/* set of isoc endpoints */
+	struct list_head intr_list;	/* ordered (tree) set of int endpoints */
+	struct list_head del_list;	/* set of entpoints to be deleted */
+
+	td_array_t *td_array;
+	td_array_t a_td_array;
+	td_array_t i_td_array[2];
+
+	struct list_head hci_hcd_list;	/* list of all hci_hcd */
+	struct usb_bus *bus;		/* our bus */
+
+//	int trans;			/* number of transactions pending */
+	int active_urbs;
+	int active_trans;
+	int frame_number;		/* frame number */
+	hcipriv_t hp;			/* individual part of hc type */
+	int nakCnt;
+	int last_packet_nak;
+
+} hci_t;
+
+/*-------------------------------------------------------------------------*/
+/* condition (error) CC codes and mapping OHCI like
+ */
+
+#define TD_CC_NOERROR		0x00
+#define TD_CC_CRC		0x01
+#define TD_CC_BITSTUFFING	0x02
+#define TD_CC_DATATOGGLEM	0x03
+#define TD_CC_STALL		0x04
+#define TD_DEVNOTRESP		0x05
+#define TD_PIDCHECKFAIL		0x06
+#define TD_UNEXPECTEDPID	0x07
+#define TD_DATAOVERRUN		0x08
+#define TD_DATAUNDERRUN		0x09
+#define TD_BUFFEROVERRUN	0x0C
+#define TD_BUFFERUNDERRUN	0x0D
+#define TD_NOTACCESSED		0x0F
+
+
+/* urb interface functions */
+static int hci_get_current_frame_number (struct usb_device *usb_dev);
+static int hci_unlink_urb (struct urb * urb);
+
+static int qu_queue_urb (hci_t * hci, struct urb * urb);
+
+/* root hub */
+static int rh_init_int_timer (struct urb * urb);
+static int rh_submit_urb (struct urb * urb);
+static int rh_unlink_urb (struct urb * urb);
+
+/* schedule functions */
+static int sh_add_packet (hci_t * hci, struct urb * urb);
+
+/* hc specific functions */
+static inline void hc_flush_data_cache (hci_t * hci, void *data, int len);
+static inline int hc_parse_trans (hci_t * hci, int *actbytes, __u8 * data,
+				  int *cc, int *toggle, int length, int pid,
+				  int urb_state);
+static inline int hc_add_trans (hci_t * hci, int len, void *data, int toggle,
+				int maxps, int slow, int endpoint, int address,
+				int pid, int format, int urb_state);
+
+static void hc_start_int (hci_t * hci);
+static void hc_stop_int (hci_t * hci);
+static void SL811Write (hci_t * hci, char offset, char data);
+
+/* debug| print the main components of an URB     
+ * small: 0) header + data packets 1) just header */
+
+static void urb_print (struct urb * urb, char *str, int small)
+{
+	unsigned int pipe = urb->pipe;
+	int i, len;
+
+	if (!urb->dev || !urb->dev->bus) {
+		dbg ("%s URB: no dev", str);
+		return;
+	}
+
+	printk ("%s URB:[%4x] dev:%2d,ep:%2d-%c,type:%s,flags:%4x,len:%d/%d,stat:%d(%x)\n",
+		str, hci_get_current_frame_number (urb->dev),
+		usb_pipedevice (pipe), usb_pipeendpoint (pipe),
+		usb_pipeout (pipe) ? 'O' : 'I',
+		usb_pipetype (pipe) < 2 ? (usb_pipeint (pipe) ? "INTR" : "ISOC")
+		: (usb_pipecontrol (pipe) ? "CTRL" : "BULK"), urb->transfer_flags,
+		urb->actual_length, urb->transfer_buffer_length, urb->status,
+		urb->status);
+	if (!small) {
+		if (usb_pipecontrol (pipe)) {
+			printk (__FILE__ ": cmd(8):");
+			for (i = 0; i < 8; i++)
+				printk (" %02x", ((__u8 *) urb->setup_packet)[i]);
+			printk ("\n");
+		}
+		if (urb->transfer_buffer_length > 0 && urb->transfer_buffer) {
+			printk (__FILE__ ": data(%d/%d):", urb->actual_length,
+				urb->transfer_buffer_length);
+			len = usb_pipeout (pipe) ? urb-> transfer_buffer_length : urb->actual_length;
+			for (i = 0; i < 2096 && i < len; i++)
+				printk (" %02x", ((__u8 *) urb->transfer_buffer)[i]);
+			printk ("%s stat:%d\n", i < len ? "..." : "",
+				urb->status);
+		}
+	}
+}
diff -Nur linux-2.4.19.old/drivers/usb/hc_sl811.c linux-2.4.19/drivers/usb/hc_sl811.c
--- linux-2.4.19.old/drivers/usb/hc_sl811.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/hc_sl811.c	Mon Nov 25 12:26:55 2002
@@ -0,0 +1,1359 @@
+/*-------------------------------------------------------------------------*/
+/*-------------------------------------------------------------------------*
+ * SL811HS USB HCD for Linux Version 0.1 (10/28/2001)
+ * 
+ * requires (includes) hc_simple.[hc] simple generic HCD frontend
+ *  
+ * COPYRIGHT(C) 2001 by CYPRESS SEMICONDUCTOR INC.
+ *
+ *-------------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *-------------------------------------------------------------------------*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/malloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/list.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <linux/usb.h>
+#include "../core/hcd.h"
+
+#undef HC_URB_TIMEOUT
+#undef HC_SWITCH_INT
+#undef HC_ENABLE_ISOC
+
+#define SL811_DEBUG_ERR
+
+#ifdef SL811_DEBUG_ERR
+#define DBGERR(fmt, args...) printk(fmt,## args)
+#else
+#define DBGERR(fmt, args...)
+#endif
+
+#ifdef SL811_DEBUG
+#define DBG(fmt, args...) printk(fmt,## args)
+#else
+#define DBG(fmt, args...)
+#endif
+
+#ifdef SL811_DEBUG_FUNC
+#define DBGFUNC(fmt, args...) printk(fmt,## args)
+#else
+#define DBGFUNC(fmt, args...)
+#endif
+
+#ifdef SL811_DEBUG_DATA
+#define DBGDATAR(fmt, args...) printk(fmt,## args)
+#define DBGDATAW(fmt, args...) printk(fmt,## args)
+#else
+#define DBGDATAR(fmt, args...)
+#define DBGDATAW(fmt, args...)
+#endif
+
+#ifdef SL811_DEBUG_VERBOSE
+#define DBGVERBOSE(fmt, args...) printk(fmt,## args)
+#else
+#define DBGVERBOSE(fmt, args...)
+#endif
+
+#define TRUE 1
+#define FALSE 0
+
+#define HC_SWITCH_INT
+#include "hc_sl811.h"
+#include "hc_simple.h"
+
+static int urb_debug = 0;
+
+#include "hc_simple.c"
+#include "hc_sl811_rh.c"
+
+/* The base_addr, data_reg_addr, and irq number are board specific.
+ * The current values are design to run on the Accelent SA1110 IDP
+ * NOTE: values need to modify for different development boards 
+ */
+
+static int base_addr = 0xd3800000;
+static int data_reg_addr = 0xd3810000;
+static int irq = 34;
+
+/* forware declaration */
+
+int SL11StartXaction (hci_t * hci, __u8 addr, __u8 epaddr, int pid, int len,
+		      int toggle, int slow, int urb_state);
+
+static int sofWaitCnt = 0;
+
+MODULE_PARM (urb_debug, "i");
+MODULE_PARM_DESC (urb_debug, "debug urb messages, default is 0 (no)");
+
+MODULE_PARM (base_addr, "i");
+MODULE_PARM_DESC (base_addr, "sl811 base address 0xd3800000");
+MODULE_PARM (data_reg_addr, "i");
+MODULE_PARM_DESC (data_reg_addr, "sl811 data register address 0xd3810000");
+MODULE_PARM (irq, "i");
+MODULE_PARM_DESC (irq, "IRQ 34 (default)");
+
+static int hc_reset (hci_t * hci);
+
+/***************************************************************************
+ * Function Name : SL811Read
+ *
+ * Read a byte of data from the SL811H/SL11H
+ *
+ * Input:  hci = data structure for the host controller
+ *         offset = address of SL811/SL11H register or memory
+ *
+ * Return: data 
+ **************************************************************************/
+char SL811Read (hci_t * hci, char offset)
+{
+	hcipriv_t *hp = &hci->hp;
+	char data;
+	writeb (offset, hp->hcport);
+	wmb ();
+	data = readb (hp->hcport2);
+	rmb ();
+	return (data);
+}
+
+/***************************************************************************
+ * Function Name : SL811Write
+ *
+ * Write a byte of data to the SL811H/SL11H
+ *
+ * Input:  hci = data structure for the host controller
+ *         offset = address of SL811/SL11H register or memory
+ *         data  = the data going to write to SL811H
+ *
+ * Return: none 
+ **************************************************************************/
+void SL811Write (hci_t * hci, char offset, char data)
+{
+	hcipriv_t *hp = &hci->hp;
+	writeb (offset, hp->hcport);
+	writeb (data, hp->hcport2);
+	wmb ();
+}
+
+/***************************************************************************
+ * Function Name : SL811BufRead
+ *
+ * Read consecutive bytes of data from the SL811H/SL11H buffer
+ *
+ * Input:  hci = data structure for the host controller
+ *         offset = SL811/SL11H register offset
+ *         buf = the buffer where the data will store
+ *         size = number of bytes to read
+ *
+ * Return: none 
+ **************************************************************************/
+void SL811BufRead (hci_t * hci, short offset, char *buf, short size)
+{
+	hcipriv_t *hp = &hci->hp;
+	if (size <= 0)
+		return;
+	writeb ((char) offset, hp->hcport);
+	wmb ();
+	DBGDATAR ("SL811BufRead: offset = 0x%x, data = ", offset);
+	while (size--) {
+		*buf++ = (char) readb (hp->hcport2);
+		DBGDATAR ("0x%x ", *(buf - 1));
+		rmb ();
+	}
+	DBGDATAR ("\n");
+}
+
+/***************************************************************************
+ * Function Name : SL811BufWrite
+ *
+ * Write consecutive bytes of data to the SL811H/SL11H buffer
+ *
+ * Input:  hci = data structure for the host controller
+ *         offset = SL811/SL11H register offset
+ *         buf = the data buffer 
+ *         size = number of bytes to write
+ *
+ * Return: none 
+ **************************************************************************/
+void SL811BufWrite (hci_t * hci, short offset, char *buf, short size)
+{
+	hcipriv_t *hp = &hci->hp;
+	if (size <= 0)
+		return;
+	writeb ((char) offset, hp->hcport);
+	wmb ();
+	DBGDATAW ("SL811BufWrite: offset = 0x%x, data = ", offset);
+	while (size--) {
+		DBGDATAW ("0x%x ", *buf);
+		writeb (*buf, hp->hcport2);
+		wmb ();
+		buf++;
+	}
+	DBGDATAW ("\n");
+}
+
+/***************************************************************************
+ * Function Name : regTest
+ *
+ * This routine test the Read/Write functionality of SL811HS registers  
+ *
+ * 1) Store original register value into a buffer
+ * 2) Write to registers with a RAMP pattern. (10, 11, 12, ..., 255)
+ * 3) Read from register
+ * 4) Compare the written value with the read value and make sure they are 
+ *    equivalent
+ * 5) Restore the original register value 
+ *
+ * Input:  hci = data structure for the host controller
+ *   
+ *
+ * Return: TRUE = passed; FALSE = failed 
+ **************************************************************************/
+int regTest (hci_t * hci)
+{
+	int i, data, result = TRUE;
+	char buf[256];
+
+	DBGFUNC ("Enter regTest\n");
+	for (i = 0x10; i < 256; i++) {
+		/* save the original buffer */
+		buf[i] = (char) SL811Read (hci, i);
+
+		/* Write the new data to the buffer */
+		SL811Write (hci, i, i);
+	}
+
+	/* compare the written data */
+	for (i = 0x10; i < 256; i++) {
+		data = SL811Read (hci, i);
+		if (data != i) {
+			DBGERR ("Pattern test failed!! value = 0x%x, s/b 0x%x\n",
+				data, i);
+			result = FALSE;
+		}
+	}
+
+	/* restore the data */
+	for (i = 0x10; i < 256; i++) {
+		SL811Write (hci, i, buf[i]);
+	}
+
+	return (result);
+}
+
+/***************************************************************************
+ * Function Name : regShow
+ *
+ * Display all SL811HS register values
+ *
+ * Input:  hci = data structure for the host controller
+ *
+ * Return: none 
+ **************************************************************************/
+void regShow (hci_t * hci)
+{
+	int i;
+	for (i = 0; i < 256; i++) {
+		printk ("offset %d: 0x%x\n", i, SL811Read (hci, i));
+	}
+}
+
+/************************************************************************
+ * Function Name : USBReset
+ *  
+ * This function resets SL811HS controller and detects the speed of
+ * the connecting device				  
+ *
+ * Input:  hci = data structure for the host controller
+ *                
+ * Return: 0 = no device attached; 1 = USB device attached
+ *                
+ ***********************************************************************/
+static int USBReset (hci_t * hci)
+{
+	int status;
+	hcipriv_t *hp = &hci->hp;
+
+	DBGFUNC ("enter USBReset\n");
+
+	SL811Write (hci, SL11H_CTLREG2, 0xae);
+
+	// setup master and full speed
+
+	SL811Write (hci, SL11H_CTLREG1, 0x08);	// reset USB
+	mdelay (20);		// 20ms                             
+	SL811Write (hci, SL11H_CTLREG1, 0);	// remove SE0        
+
+	for (status = 0; status < 100; status++)
+		SL811Write (hci, SL11H_INTSTATREG, 0xff);	// clear all interrupt bits
+
+	status = SL811Read (hci, SL11H_INTSTATREG);
+
+	if (status & 0x40)	// Check if device is removed
+	{
+		DBG ("USBReset: Device removed\n");
+		SL811Write (hci, SL11H_INTENBLREG,
+			    SL11H_INTMASK_XFERDONE | SL11H_INTMASK_SOFINTR |
+			    SL11H_INTMASK_INSRMV);
+		hp->RHportStatus->portStatus &=
+		    ~(PORT_CONNECT_STAT | PORT_ENABLE_STAT);
+
+		return 0;
+	}
+
+	SL811Write (hci, SL11H_BUFLNTHREG_B, 0);	//zero lenth
+	SL811Write (hci, SL11H_PIDEPREG_B, 0x50);	//send SOF to EP0       
+	SL811Write (hci, SL11H_DEVADDRREG_B, 0x01);	//address0
+	SL811Write (hci, SL11H_SOFLOWREG, 0xe0);
+
+	if (!(status & 0x80)) {
+		/* slow speed device connect directly to root-hub */
+
+		DBG ("USBReset: low speed Device attached\n");
+		SL811Write (hci, SL11H_CTLREG1, 0x8);
+		mdelay (20);
+		SL811Write (hci, SL11H_SOFTMRREG, 0xee);
+		SL811Write (hci, SL11H_CTLREG1, 0x21);
+
+		/* start the SOF or EOP */
+
+		SL811Write (hci, SL11H_HOSTCTLREG_B, 0x01);
+		hp->RHportStatus->portStatus |=
+		    (PORT_CONNECT_STAT | PORT_LOW_SPEED_DEV_ATTACH_STAT);
+
+		/* clear all interrupt bits */
+
+		for (status = 0; status < 20; status++)
+			SL811Write (hci, SL11H_INTSTATREG, 0xff);
+	} else {
+		/* full speed device connect directly to root hub */
+
+		DBG ("USBReset: full speed Device attached\n");
+		SL811Write (hci, SL11H_CTLREG1, 0x8);
+		mdelay (20);
+		SL811Write (hci, SL11H_SOFTMRREG, 0xae);
+		SL811Write (hci, SL11H_CTLREG1, 0x01);
+
+		/* start the SOF or EOP */
+
+		SL811Write (hci, SL11H_HOSTCTLREG_B, 0x01);
+		hp->RHportStatus->portStatus |= (PORT_CONNECT_STAT);
+		hp->RHportStatus->portStatus &= ~PORT_LOW_SPEED_DEV_ATTACH_STAT;
+
+		/* clear all interrupt bits */
+
+		SL811Write (hci, SL11H_INTSTATREG, 0xff);
+
+	}
+
+	/* enable all interrupts */
+	SL811Write (hci, SL11H_INTENBLREG,
+		    SL11H_INTMASK_XFERDONE | SL11H_INTMASK_SOFINTR |
+		    SL11H_INTMASK_INSRMV);
+
+	return 1;
+}
+
+/*-------------------------------------------------------------------------*/
+/* tl functions */
+static inline void hc_mark_last_trans (hci_t * hci)
+{
+	hcipriv_t *hp = &hci->hp;
+	__u8 *ptd = hp->tl;
+
+	dbg ("enter hc_mark_last_trans\n");
+	if (ptd == NULL) {
+		printk ("hc_mark_last_trans: ptd = null\n");
+		return;
+	}
+	if (hp->xferPktLen > 0)
+		*(ptd + hp->tl_last) |= (1 << 3);
+}
+
+static inline void hc_flush_data_cache (hci_t * hci, void *data, int len)
+{
+}
+
+/************************************************************************
+ * Function Name : hc_add_trans
+ *  
+ * This function sets up the SL811HS register and transmit the USB packets.
+ * 
+ * 1) Determine if enough time within the current frame to send the packet
+ * 2) Load the data into the SL811HS register
+ * 3) Set the appropriate command to the register and trigger the transmit
+ *
+ * Input:  hci = data structure for the host controller
+ *         len = data length
+ *         data = transmitting data
+ *         toggle = USB toggle bit, either 0 or 1
+ *         maxps = maximum packet size for this endpoint
+ *         slow = speed of the device
+ *         endpoint = endpoint number
+ *         address = USB address of the device
+ *         pid = packet ID
+ *         format = 
+ *         urb_state = the current stage of USB transaction
+ *       
+ * Return: 0 = no time left to schedule the transfer
+ *         1 = success 
+ *                
+ ***********************************************************************/
+static inline int hc_add_trans (hci_t * hci, int len, void *data, int toggle,
+				int maxps, int slow, int endpoint, int address,
+				int pid, int format, int urb_state)
+{
+	hcipriv_t *hp = &hci->hp;
+	__u16 speed;
+	int ii, jj, kk;
+
+	DBGFUNC ("enter hc_addr_trans: len =0x%x, toggle:0x%x, endpoing:0x%x,"
+		 " addr:0x%x, pid:0x%x,format:0x%x\n", len, toggle, endpoint,
+		 i address, pid, format);
+
+	if (len > maxps) {
+		len = maxps;
+	}
+
+	speed = hp->RHportStatus->portStatus;
+	if (speed & PORT_LOW_SPEED_DEV_ATTACH_STAT) {
+//      ii = (8*7*8 + 6*3) * len + 800; 
+		ii = 8 * 8 * len + 1024;
+	} else {
+		if (slow) {
+//          ii = (8*7*8 + 6*3) * len + 800; 
+			ii = 8 * 8 * len + 2048;
+		} else
+//          ii = (8*7 + 6*3)*len + 110;
+			ii = 8 * len + 256;
+	}
+
+	ii += 2 * 10 * len;
+
+	jj = SL811Read (hci, SL11H_SOFTMRREG);
+	kk = (jj & 0xFF) * 64 - ii;
+
+	if (kk < 0) {
+		DBGVERBOSE
+		    ("hc_add_trans: no bandwidth for schedule, ii = 0x%x,"
+		     "jj = 0x%x, len =0x%x, active_trans = 0x%x\n", ii, jj, len,
+		     hci->active_trans);
+		return (-1);
+	}
+
+	if (pid != PID_IN) {
+		/* Load data into hc */
+
+		SL811BufWrite (hci, SL11H_DATA_START, (__u8 *) data, len);
+	}
+
+	/* transmit */
+
+	SL11StartXaction (hci, (__u8) address, (__u8) endpoint, (__u8) pid, len,
+			  toggle, slow, urb_state);
+
+	return len;
+}
+
+/************************************************************************
+ * Function Name : hc_parse_trans
+ *  
+ * This function checks the status of the transmitted or received packet
+ * and copy the data from the SL811HS register into a buffer.
+ *
+ * 1) Check the status of the packet 
+ * 2) If successful, and IN packet then copy the data from the SL811HS register
+ *    into a buffer
+ *
+ * Input:  hci = data structure for the host controller
+ *         actbytes = pointer to actual number of bytes
+ *         data = data buffer
+ *         cc = packet status
+ *         length = the urb transmit length
+ *         pid = packet ID
+ *         urb_state = the current stage of USB transaction
+ *       
+ * Return: 0 
+ ***********************************************************************/
+static inline int hc_parse_trans (hci_t * hci, int *actbytes, __u8 * data,
+				  int *cc, int *toggle, int length, int pid,
+				  int urb_state)
+{
+	__u8 addr;
+	__u8 len;
+
+	DBGFUNC ("enter hc_parse_trans\n");
+
+	/* get packet status; convert ack rcvd to ack-not-rcvd */
+
+	*cc = (int) SL811Read (hci, SL11H_PKTSTATREG);
+
+	if (*cc &
+	    (SL11H_STATMASK_ERROR | SL11H_STATMASK_TMOUT | SL11H_STATMASK_OVF |
+	     SL11H_STATMASK_NAK | SL11H_STATMASK_STALL)) {
+		if (*cc & SL11H_STATMASK_OVF)
+			DBGERR ("parse trans: error recv ack, cc = 0x%x, TX_BASE_Len = "
+				"0x%x, TX_count=0x%x\n", *cc,
+				SL811Read (hci, SL11H_BUFLNTHREG),
+				SL811Read (hci, SL11H_XFERCNTREG));
+
+	} else {
+		DBGVERBOSE ("parse trans: recv ack, cc = 0x%x, len = 0x%x, \n",
+			    *cc, length);
+
+		/* Successful data */
+		if ((pid == PID_IN) && (urb_state != US_CTRL_SETUP)) {
+
+			/* Find the base address */
+			addr = SL811Read (hci, SL11H_BUFADDRREG);
+
+			/* Find the Transmit Length */
+			len = SL811Read (hci, SL11H_BUFLNTHREG);
+
+			/* The actual data length = xmit length reg - xfer count reg */
+			*actbytes = len - SL811Read (hci, SL11H_XFERCNTREG);
+
+			if ((data != NULL) && (*actbytes > 0)) {
+				SL811BufRead (hci, addr, data, *actbytes);
+
+			} else if ((data == NULL) && (*actbytes <= 0)) {
+				DBGERR ("hc_parse_trans: data = NULL or actbyte = 0x%x\n",
+					*actbytes);
+				return 0;
+			}
+		} else if (pid == PID_OUT) {
+			*actbytes = length;
+		} else {
+			// printk ("ERR:parse_trans, pid != IN or OUT, pid = 0x%x\n", pid);
+		}
+		*toggle = !*toggle;
+	}
+
+	return 0;
+}
+
+/************************************************************************
+ * Function Name : hc_start_int
+ *  
+ * This function enables SL811HS interrupts
+ *
+ * Input:  hci = data structure for the host controller
+ *       
+ * Return: none 
+ ***********************************************************************/
+static void hc_start_int (hci_t * hci)
+{
+#ifdef HC_SWITCH_INT
+	int mask =
+	    SL11H_INTMASK_XFERDONE | SL11H_INTMASK_SOFINTR |
+	    SL11H_INTMASK_INSRMV | SL11H_INTMASK_USBRESET;
+	SL811Write (hci, IntEna, mask);
+#endif
+}
+
+/************************************************************************
+ * Function Name : hc_stop_int
+ *  
+ * This function disables SL811HS interrupts
+ *
+ * Input:  hci = data structure for the host controller
+ *       
+ * Return: none 
+ ***********************************************************************/
+static void hc_stop_int (hci_t * hci)
+{
+#ifdef HC_SWITCH_INT
+	SL811Write (hci, SL11H_INTSTATREG, 0xff);
+//  SL811Write(hci, SL11H_INTENBLREG, SL11H_INTMASK_INSRMV);
+
+#endif
+}
+
+/************************************************************************
+ * Function Name : handleInsRmvIntr
+ *  
+ * This function handles the insertion or removal of device on  SL811HS. 
+ * It resets the controller and updates the port status
+ *
+ * Input:  hci = data structure for the host controller
+ *       
+ * Return: none 
+ ***********************************************************************/
+void handleInsRmvIntr (hci_t * hci)
+{
+	hcipriv_t *hp = &hci->hp;
+
+	USBReset (hci);
+
+	/* Changes in connection status */
+
+	hp->RHportStatus->portChange |= PORT_CONNECT_CHANGE;
+
+	/* Port Enable or Disable */
+
+	if (hp->RHportStatus->portStatus & PORT_CONNECT_STAT) {
+		/* device is connected to the port:
+		 *    1) Enable port 
+		 *    2) Resume ?? 
+		 */
+//               hp->RHportStatus->portChange |= PORT_ENABLE_CHANGE;
+
+		/* Over Current is not supported by the SL811 HW ?? */
+
+		/* How about the Port Power ?? */
+
+	} else {
+		/* Device has disconnect:
+		 *    1) Disable port
+		 */
+
+		hp->RHportStatus->portStatus &= ~(PORT_ENABLE_STAT);
+		hp->RHportStatus->portChange |= PORT_ENABLE_CHANGE;
+
+	}
+}
+
+/*****************************************************************
+ *
+ * Function Name: SL11StartXaction
+ *  
+ * This functions load the registers with appropriate value and 
+ * transmit the packet.				  
+ *
+ * Input:  hci = data structure for the host controller
+ *         addr = USB address of the device
+ *         epaddr = endpoint number
+ *         pid = packet ID
+ *         len = data length
+ *         toggle = USB toggle bit, either 0 or 1
+ *         slow = speed of the device
+ *         urb_state = the current stage of USB transaction
+ *
+ * Return: 0 = error; 1 = successful
+ *                
+ *****************************************************************/
+int SL11StartXaction (hci_t * hci, __u8 addr, __u8 epaddr, int pid, int len,
+		      int toggle, int slow, int urb_state)
+{
+
+	hcipriv_t *hp = &hci->hp;
+	__u8 cmd = 0;
+	__u8 setup_data[4];
+	__u16 speed;
+
+	speed = hp->RHportStatus->portStatus;
+	if (!(speed & PORT_LOW_SPEED_DEV_ATTACH_STAT) && slow) {
+		cmd |= SL11H_HCTLMASK_PREAMBLE;
+	}
+	switch (pid) {
+	case PID_SETUP:
+		cmd &= SL11H_HCTLMASK_PREAMBLE;
+		cmd |=
+		    (SL11H_HCTLMASK_ARM | SL11H_HCTLMASK_ENBLEP |
+		     SL11H_HCTLMASK_WRITE);
+		break;
+
+	case PID_OUT:
+		cmd &= (SL11H_HCTLMASK_SEQ | SL11H_HCTLMASK_PREAMBLE);
+		cmd |=
+		    (SL11H_HCTLMASK_ARM | SL11H_HCTLMASK_ENBLEP |
+		     SL11H_HCTLMASK_WRITE);
+		if (toggle) {
+			cmd |= SL11H_HCTLMASK_SEQ;
+		}
+		break;
+
+	case PID_IN:
+		cmd &= (SL11H_HCTLMASK_SEQ | SL11H_HCTLMASK_PREAMBLE);
+		cmd |= (SL11H_HCTLMASK_ARM | SL11H_HCTLMASK_ENBLEP);
+		break;
+
+	default:
+		DBGERR ("ERR: SL11StartXaction: unknow pid = 0x%x\n", pid);
+		return 0;
+	}
+	setup_data[0] = SL11H_DATA_START;
+	setup_data[1] = len;
+	setup_data[2] = (((pid & 0x0F) << 4) | (epaddr & 0xF));
+	setup_data[3] = addr & 0x7F;
+
+	SL811BufWrite (hci, SL11H_BUFADDRREG, (__u8 *) & setup_data[0], 4);
+
+	SL811Write (hci, SL11H_HOSTCTLREG, cmd);
+
+#if 0
+	/* The SL811 has a hardware flaw when hub devices sends out
+	 * SE0 between packets. It has been found in a TI chipset and
+	 * cypress hub chipset. It causes the SL811 to hang
+	 * The workaround is to re-issue the preample again.
+	 */
+
+	if ((cmd & SL11H_HCTLMASK_PREAMBLE)) {
+		SL811Write (hci, SL11H_PIDEPREG_B, 0xc0);
+		SL811Write (hci, SL11H_HOSTCTLREG_B, 0x1);	// send the premable
+	}
+#endif
+	return 1;
+}
+
+/*****************************************************************
+ *
+ * Function Name: hc_interrupt
+ *
+ * Interrupt service routine. 
+ *
+ * 1) determine the causes of interrupt
+ * 2) clears all interrupts
+ * 3) calls appropriate function to service the interrupt
+ *
+ * Input:  irq = interrupt line associated with the controller 
+ *         hci = data structure for the host controller
+ *         r = holds the snapshot of the processor's context before 
+ *             the processor entered interrupt code. (not used here) 
+ *
+ * Return value  : None.
+ *                
+ *****************************************************************/
+static void hc_interrupt (int irq, void *__hci, struct pt_regs *r)
+{
+	char ii;
+	hci_t *hci = __hci;
+	int isExcessNak = 0;
+	int urb_state = 0;
+	char tmpIrq = 0;
+
+	/* Get value from interrupt status register */
+
+	ii = SL811Read (hci, SL11H_INTSTATREG);
+
+	if (ii & SL11H_INTMASK_INSRMV) {
+		/* Device insertion or removal detected for the USB port */
+
+		SL811Write (hci, SL11H_INTENBLREG, 0);
+		SL811Write (hci, SL11H_CTLREG1, 0);
+		mdelay (100);	// wait for device stable 
+		handleInsRmvIntr (hci);
+		return;
+	}
+
+	/* Clear all interrupts */
+
+	SL811Write (hci, SL11H_INTSTATREG, 0xff);
+
+	if (ii & SL11H_INTMASK_XFERDONE) {
+		/* USB Done interrupt occurred */
+
+		urb_state = sh_done_list (hci, &isExcessNak);
+#ifdef WARNING
+		if (hci->td_array->len > 0)
+			printk ("WARNING: IRQ, td_array->len = 0x%x, s/b:0\n",
+				hci->td_array->len);
+#endif
+		if (hci->td_array->len == 0 && !isExcessNak
+		    && !(ii & SL11H_INTMASK_SOFINTR) && (urb_state == 0)) {
+			if (urb_state == 0) {
+				/* All urb_state has not been finished yet! 
+				 * continue with the current urb transaction 
+				 */
+
+				if (hci->last_packet_nak == 0) {
+					if (!usb_pipecontrol
+					    (hci->td_array->td[0].urb->pipe))
+						sh_add_packet (hci, hci->td_array-> td[0].urb);
+				}
+			} else {
+				/* The last transaction has completed:
+				 * schedule the next transaction 
+				 */
+
+				sh_schedule_trans (hci, 0);
+			}
+		}
+		SL811Write (hci, SL11H_INTSTATREG, 0xff);
+		return;
+	}
+
+	if (ii & SL11H_INTMASK_SOFINTR) {
+		hci->frame_number = (hci->frame_number + 1) % 2048;
+		if (hci->td_array->len == 0)
+			sh_schedule_trans (hci, 1);
+		else {
+			if (sofWaitCnt++ > 100) {
+				/* The last transaction has not completed.
+				 * Need to retire the current td, and let
+				 * it transmit again later on.
+				 * (THIS NEEDS TO BE WORK ON MORE, IT SHOULD NEVER 
+				 *  GET TO THIS POINT)
+				 */
+
+				DBGERR ("SOF interrupt: td_array->len = 0x%x, s/b: 0\n",
+					hci->td_array->len);
+				urb_print (hci->td_array->td[hci->td_array->len - 1].urb,
+					   "INTERRUPT", 0);
+				sh_done_list (hci, &isExcessNak);
+				SL811Write (hci, SL11H_INTSTATREG, 0xff);
+				hci->td_array->len = 0;
+				sofWaitCnt = 0;
+			}
+		}
+		tmpIrq = SL811Read (hci, SL11H_INTSTATREG) & SL811Read (hci, SL11H_INTENBLREG);
+		if (tmpIrq) {
+			DBG ("IRQ occurred while service SOF: irq = 0x%x\n",
+			     tmpIrq);
+
+			/* If we receive a DONE IRQ after schedule, need to 
+			 * handle DONE IRQ again 
+			 */
+
+			if (tmpIrq & SL11H_INTMASK_XFERDONE) {
+				DBGERR ("IRQ occurred while service SOF: irq = 0x%x\n",
+					tmpIrq);
+				urb_state = sh_done_list (hci, &isExcessNak);
+			}
+			SL811Write (hci, SL11H_INTSTATREG, 0xff);
+		}
+	} else {
+		DBG ("SL811 ISR: unknown, int = 0x%x \n", ii);
+	}
+
+	SL811Write (hci, SL11H_INTSTATREG, 0xff);
+	return;
+}
+
+/*****************************************************************
+ *
+ * Function Name: hc_reset
+ *
+ * This function does register test and resets the SL811HS 
+ * controller.
+ *
+ * Input:  hci = data structure for the host controller
+ *
+ * Return value  : 0
+ *                
+ *****************************************************************/
+static int hc_reset (hci_t * hci)
+{
+	int attachFlag = 0;
+
+	DBGFUNC ("Enter hc_reset\n");
+	regTest (hci);
+	attachFlag = USBReset (hci);
+	if (attachFlag) {
+		setPortChange (hci, PORT_CONNECT_CHANGE);
+	}
+	return (0);
+}
+
+/*****************************************************************
+ *
+ * Function Name: hc_alloc_trans_buffer
+ *
+ * This function allocates all transfer buffer  
+ *
+ * Input:  hci = data structure for the host controller
+ *
+ * Return value  : 0
+ *                
+ *****************************************************************/
+static int hc_alloc_trans_buffer (hci_t * hci)
+{
+	hcipriv_t *hp = &hci->hp;
+	int maxlen;
+
+	hp->itl0_len = 0;
+	hp->itl1_len = 0;
+	hp->atl_len = 0;
+
+	hp->itl_buffer_len = 1024;
+	hp->atl_buffer_len = 4096 - 2 * hp->itl_buffer_len;	/* 2048 */
+
+	maxlen = (hp->itl_buffer_len > hp->atl_buffer_len) ? hp->itl_buffer_len : hp->atl_buffer_len;
+
+	hp->tl = kmalloc (maxlen, GFP_KERNEL);
+
+	if (!hp->tl)
+		return -ENOMEM;
+
+	memset (hp->tl, 0, maxlen);
+	return 0;
+}
+
+/*****************************************************************
+ *
+ * Function Name: getPortStatusAndChange
+ *
+ * This function gets the ports status from SL811 and format it 
+ * to a USB request format
+ *
+ * Input:  hci = data structure for the host controller
+ *
+ * Return value  : port status and change
+ *                
+ *****************************************************************/
+static __u32 getPortStatusAndChange (hci_t * hci)
+{
+	hcipriv_t *hp = &hci->hp;
+	__u32 portstatus;
+
+	DBGFUNC ("enter getPorStatusAndChange\n");
+
+	portstatus = hp->RHportStatus->portChange << 16 | hp->RHportStatus->portStatus;
+
+	return (portstatus);
+}
+
+/*****************************************************************
+ *
+ * Function Name: setPortChange
+ *
+ * This function set the bit position of portChange.
+ *
+ * Input:  hci = data structure for the host controller
+ *         bitPos = the bit position
+ *
+ * Return value  : none 
+ *                
+ *****************************************************************/
+static void setPortChange (hci_t * hci, __u16 bitPos)
+{
+	hcipriv_t *hp = &hci->hp;
+
+	switch (bitPos) {
+	case PORT_CONNECT_STAT:
+		hp->RHportStatus->portChange |= bitPos;
+		break;
+
+	case PORT_ENABLE_STAT:
+		hp->RHportStatus->portChange |= bitPos;
+		break;
+
+	case PORT_RESET_STAT:
+		hp->RHportStatus->portChange |= bitPos;
+		break;
+
+	case PORT_POWER_STAT:
+		hp->RHportStatus->portChange |= bitPos;
+		break;
+
+	case PORT_SUSPEND_STAT:
+		hp->RHportStatus->portChange |= bitPos;
+		break;
+
+	case PORT_OVER_CURRENT_STAT:
+		hp->RHportStatus->portChange |= bitPos;
+		break;
+	}
+}
+
+/*****************************************************************
+ *
+ * Function Name: clrPortChange
+ *
+ * This function clear the bit position of portChange.
+ *
+ * Input:  hci = data structure for the host controller
+ *         bitPos = the bit position
+ *
+ * Return value  : none 
+ *                
+ *****************************************************************/
+static void clrPortChange (hci_t * hci, __u16 bitPos)
+{
+	hcipriv_t *hp = &hci->hp;
+	switch (bitPos) {
+	case PORT_CONNECT_CHANGE:
+		hp->RHportStatus->portChange &= ~bitPos;
+		break;
+
+	case PORT_ENABLE_CHANGE:
+		hp->RHportStatus->portChange &= ~bitPos;
+		break;
+
+	case PORT_RESET_CHANGE:
+		hp->RHportStatus->portChange &= ~bitPos;
+		break;
+
+	case PORT_SUSPEND_CHANGE:
+		hp->RHportStatus->portChange &= ~bitPos;
+		break;
+
+	case PORT_OVER_CURRENT_CHANGE:
+		hp->RHportStatus->portChange &= ~bitPos;
+		break;
+	}
+}
+
+/*****************************************************************
+ *
+ * Function Name: clrPortStatus
+ *
+ * This function clear the bit position of portStatus.
+ *
+ * Input:  hci = data structure for the host controller
+ *         bitPos = the bit position
+ *
+ * Return value  : none 
+ *                
+ *****************************************************************/
+static void clrPortStatus (hci_t * hci, __u16 bitPos)
+{
+	hcipriv_t *hp = &hci->hp;
+	switch (bitPos) {
+	case PORT_ENABLE_STAT:
+		hp->RHportStatus->portStatus &= ~bitPos;
+		break;
+
+	case PORT_RESET_STAT:
+		hp->RHportStatus->portStatus &= ~bitPos;
+		break;
+
+	case PORT_POWER_STAT:
+		hp->RHportStatus->portStatus &= ~bitPos;
+		break;
+
+	case PORT_SUSPEND_STAT:
+		hp->RHportStatus->portStatus &= ~bitPos;
+		break;
+	}
+}
+
+/*****************************************************************
+ *
+ * Function Name: setPortStatus
+ *
+ * This function set the bit position of portStatus.
+ *
+ * Input:  hci = data structure for the host controller
+ *         bitPos = the bit position
+ *
+ * Return value  : none 
+ *                
+ *****************************************************************/
+static void setPortStatus (hci_t * hci, __u16 bitPos)
+{
+	hcipriv_t *hp = &hci->hp;
+	switch (bitPos) {
+	case PORT_ENABLE_STAT:
+		hp->RHportStatus->portStatus |= bitPos;
+		break;
+
+	case PORT_RESET_STAT:
+		hp->RHportStatus->portStatus |= bitPos;
+		break;
+
+	case PORT_POWER_STAT:
+		hp->RHportStatus->portStatus |= bitPos;
+		break;
+
+	case PORT_SUSPEND_STAT:
+		hp->RHportStatus->portStatus |= bitPos;
+		break;
+	}
+}
+
+/*****************************************************************
+ *
+ * Function Name: hc_start
+ *
+ * This function starts the root hub functionality. 
+ *
+ * Input:  hci = data structure for the host controller
+ *
+ * Return value  : 0 
+ *                
+ *****************************************************************/
+static int hc_start (hci_t * hci)
+{
+	DBGFUNC ("Enter hc_start\n");
+
+	rh_connect_rh (hci);
+
+	return 0;
+}
+
+/*****************************************************************
+ *
+ * Function Name: hc_alloc_hci
+ *
+ * This function allocates all data structure and store in the 
+ * private data structure. 
+ *
+ * Input:  hci = data structure for the host controller
+ *
+ * Return value  : 0 
+ *                
+ *****************************************************************/
+static hci_t *__devinit hc_alloc_hci (void)
+{
+	hci_t *hci;
+	hcipriv_t *hp;
+	portstat_t *ps;
+	struct usb_bus *bus;
+
+	DBGFUNC ("Enter hc_alloc_hci\n");
+	hci = (hci_t *) kmalloc (sizeof (hci_t), GFP_KERNEL);
+	if (!hci)
+		return NULL;
+
+	memset (hci, 0, sizeof (hci_t));
+
+	hp = &hci->hp;
+
+	hp->irq = -1;
+	hp->hcport = -1;
+
+	/* setup root hub port status */
+
+	ps = (portstat_t *) kmalloc (sizeof (portstat_t), GFP_KERNEL);
+
+	if (!ps)
+		return NULL;
+	ps->portStatus = PORT_STAT_DEFAULT;
+	ps->portChange = PORT_CHANGE_DEFAULT;
+	hp->RHportStatus = ps;
+
+	hci->nakCnt = 0;
+	hci->last_packet_nak = 0;
+
+	hci->a_td_array.len = 0;
+	hci->i_td_array[0].len = 0;
+	hci->i_td_array[1].len = 0;
+	hci->td_array = &hci->a_td_array;
+	hci->active_urbs = 0;
+	hci->active_trans = 0;
+	INIT_LIST_HEAD (&hci->hci_hcd_list);
+	list_add (&hci->hci_hcd_list, &hci_hcd_list);
+	init_waitqueue_head (&hci->waitq);
+
+	INIT_LIST_HEAD (&hci->ctrl_list);
+	INIT_LIST_HEAD (&hci->bulk_list);
+	INIT_LIST_HEAD (&hci->iso_list);
+	INIT_LIST_HEAD (&hci->intr_list);
+	INIT_LIST_HEAD (&hci->del_list);
+
+	bus = usb_alloc_bus (&hci_device_operations);
+	if (!bus) {
+		kfree (hci);
+		return NULL;
+	}
+
+	hci->bus = bus;
+	bus->bus_name = "sl811";
+	bus->hcpriv = (void *) hci;
+
+	return hci;
+}
+
+/*****************************************************************
+ *
+ * Function Name: hc_release_hci
+ *
+ * This function De-allocate all resources  
+ *
+ * Input:  hci = data structure for the host controller
+ *
+ * Return value  : 0 
+ *                
+ *****************************************************************/
+static void hc_release_hci (hci_t * hci)
+{
+	hcipriv_t *hp = &hci->hp;
+
+	DBGFUNC ("Enter hc_release_hci\n");
+
+	/* disconnect all devices */
+	if (hci->bus->root_hub)
+		usb_disconnect (&hci->bus->root_hub);
+
+	hc_reset (hci);
+
+	if (hp->tl)
+		kfree (hp->tl);
+
+	if (hp->hcport > 0) {
+		release_region (hp->hcport, 2);
+		hp->hcport = 0;
+	}
+
+	if (hp->irq >= 0) {
+		free_irq (hp->irq, hci);
+		hp->irq = -1;
+	}
+
+	usb_deregister_bus (hci->bus);
+	usb_free_bus (hci->bus);
+
+	list_del (&hci->hci_hcd_list);
+	INIT_LIST_HEAD (&hci->hci_hcd_list);
+
+	kfree (hci);
+}
+
+/*****************************************************************
+ *
+ * Function Name: init_irq
+ *
+ * This function is board specific.  It sets up the interrupt to 
+ * be an edge trigger and trigger on the rising edge  
+ *
+ * Input: none 
+ *
+ * Return value  : none 
+ *                
+ *****************************************************************/
+void init_irq (void)
+{
+	GPDR &= ~(1 << 13);
+	set_GPIO_IRQ_edge (1 << 13, GPIO_RISING_EDGE);
+}
+
+/*****************************************************************
+ *
+ * Function Name: hc_found_hci
+ *
+ * This function request IO memory regions, request IRQ, and
+ * allocate all other resources. 
+ *
+ * Input: addr = first IO address
+ *        addr2 = second IO address
+ *        irq = interrupt number 
+ *
+ * Return: 0 = success or error condition 
+ *                
+ *****************************************************************/
+static int __devinit hc_found_hci (int addr, int addr2, int irq)
+{
+	hci_t *hci;
+	hcipriv_t *hp;
+
+	DBGFUNC ("Enter hc_found_hci\n");
+	hci = hc_alloc_hci ();
+	if (!hci) {
+		return -ENOMEM;
+	}
+
+	init_irq ();
+	hp = &hci->hp;
+
+	if (!request_region (addr, 256, "SL811 USB HOST")) {
+		DBGERR ("request address %d failed", addr);
+		hc_release_hci (hci);
+		return -EBUSY;
+	}
+	hp->hcport = addr;
+	if (!hp->hcport) {
+		DBGERR ("Error mapping SL811 Memory 0x%x", hp->hcport);
+	}
+
+	if (!request_region (addr2, 256, "SL811 USB HOST")) {
+		DBGERR ("request address %d failed", addr2);
+		hc_release_hci (hci);
+		return -EBUSY;
+	}
+	hp->hcport2 = addr2;
+	if (!hp->hcport2) {
+		DBGERR ("Error mapping SL811 Memory 0x%x", hp->hcport2);
+	}
+
+	if (hc_alloc_trans_buffer (hci)) {
+		hc_release_hci (hci);
+		return -ENOMEM;
+	}
+
+	usb_register_bus (hci->bus);
+
+	if (request_irq (irq, hc_interrupt, 0, "SL811", hci) != 0) {
+		DBGERR ("request interrupt %d failed", irq);
+		hc_release_hci (hci);
+		return -EBUSY;
+	}
+	hp->irq = irq;
+
+	printk (KERN_INFO __FILE__ ": USB SL811 at %x, addr2 = %x, IRQ %d\n",
+		addr, addr2, irq);
+	hc_reset (hci);
+
+	if (hc_start (hci) < 0) {
+		DBGERR ("can't start usb-%x", addr);
+		hc_release_hci (hci);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*****************************************************************
+ *
+ * Function Name: hci_hcd_init
+ *
+ * This is an init function, and it is the first function being called
+ *
+ * Input: none 
+ *
+ * Return: 0 = success or error condition 
+ *                
+ *****************************************************************/
+static int __init hci_hcd_init (void)
+{
+	int ret;
+
+	DBGFUNC ("Enter hci_hcd_init\n");
+	ret = hc_found_hci (base_addr, data_reg_addr, irq);
+
+	return ret;
+}
+
+/*****************************************************************
+ *
+ * Function Name: hci_hcd_cleanup
+ *
+ * This is a cleanup function, and it is called when module is 
+ * unloaded. 
+ *
+ * Input: none 
+ *
+ * Return: none 
+ *                
+ *****************************************************************/
+static void __exit hci_hcd_cleanup (void)
+{
+	struct list_head *hci_l;
+	hci_t *hci;
+
+	DBGFUNC ("Enter hci_hcd_cleanup\n");
+	for (hci_l = hci_hcd_list.next; hci_l != &hci_hcd_list;) {
+		hci = list_entry (hci_l, hci_t, hci_hcd_list);
+		hci_l = hci_l->next;
+		hc_release_hci (hci);
+	}
+}
+
+module_init (hci_hcd_init);
+module_exit (hci_hcd_cleanup);
+
+MODULE_AUTHOR ("Pei Liu <pbl@cypress.com>");
+MODULE_DESCRIPTION ("USB SL811HS Host Controller Driver");
diff -Nur linux-2.4.19.old/drivers/usb/hc_sl811.h linux-2.4.19/drivers/usb/hc_sl811.h
--- linux-2.4.19.old/drivers/usb/hc_sl811.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/hc_sl811.h	Mon Nov 25 12:26:55 2002
@@ -0,0 +1,385 @@
+/*
+ * SL811HS HCD (Host Controller Driver) for USB.
+ * 
+ * COPYRIGHT (C) by CYPRESS SEMICONDUCTOR INC 
+ * 
+ *
+ */
+
+#define GET_FRAME_NUMBER(hci)	READ_REG32 (hci, HcFmNumber)
+
+/*
+ * Maximum number of root hub ports
+ */
+#define MAX_ROOT_PORTS		15	/* maximum OHCI root hub ports */
+
+/* control and status registers */
+#define HcRevision		0x00
+#define HcControl		0x01
+#define HcCommandStatus		0x02
+#define HcInterruptStatus	0x03
+#define HcInterruptEnable	0x04
+#define HcInterruptDisable	0x05
+#define HcFmInterval		0x0D
+#define HcFmRemaining		0x0E
+#define HcFmNumber		0x0F
+#define HcLSThreshold		0x11
+#define HcRhDescriptorA		0x12
+#define HcRhDescriptorB		0x13
+#define HcRhStatus		0x14
+#define HcRhPortStatus		0x15
+
+#define HcHardwareConfiguration 0x20
+#define HcDMAConfiguration	0x21
+#define HcTransferCounter	0x22
+#define HcuPInterrupt		0x24
+#define HcuPInterruptEnable	0x25
+#define HcChipID		0x27
+#define HcScratch		0x28
+#define HcSoftwareReset		0x29
+#define HcITLBufferLength	0x2A
+#define HcATLBufferLength	0x2B
+#define HcBufferStatus		0x2C
+#define HcReadBackITL0Length	0x2D
+#define HcReadBackITL1Length	0x2E
+#define HcITLBufferPort		0x40
+#define HcATLBufferPort		0x41
+
+/* OHCI CONTROL AND STATUS REGISTER MASKS */
+
+/*
+ * HcControl (control) register masks
+ */
+#define OHCI_CTRL_HCFS		(3 << 6)	/* BUS state mask */
+#define OHCI_CTRL_RWC		(1 << 9)	/* remote wakeup connected */
+#define OHCI_CTRL_RWE		(1 << 10)	/* remote wakeup enable */
+
+/* pre-shifted values for HCFS */
+#define OHCI_USB_RESET		(0 << 6)
+#define OHCI_USB_RESUME		(1 << 6)
+#define OHCI_USB_OPER		(2 << 6)
+#define OHCI_USB_SUSPEND	(3 << 6)
+
+/*
+ * HcCommandStatus (cmdstatus) register masks
+ */
+#define OHCI_HCR	(1 << 0)	/* host controller reset */
+#define OHCI_SO		(3 << 16)	/* scheduling overrun count */
+
+/*
+ * masks used with interrupt registers:
+ * HcInterruptStatus (intrstatus)
+ * HcInterruptEnable (intrenable)
+ * HcInterruptDisable (intrdisable)
+ */
+#define OHCI_INTR_SO	(1 << 0)	/* scheduling overrun */
+
+#define OHCI_INTR_SF	(1 << 2)	/* start frame */
+#define OHCI_INTR_RD	(1 << 3)	/* resume detect */
+#define OHCI_INTR_UE	(1 << 4)	/* unrecoverable error */
+#define OHCI_INTR_FNO	(1 << 5)	/* frame number overflow */
+#define OHCI_INTR_RHSC	(1 << 6)	/* root hub status change */
+#define OHCI_INTR_ATD	(1 << 7)	/* scheduling overrun */
+
+#define OHCI_INTR_MIE	(1 << 31)	/* master interrupt enable */
+
+/*
+ * HcHardwareConfiguration
+ */
+#define InterruptPinEnable	(1 << 0)
+#define InterruptPinTrigger	(1 << 1)
+#define InterruptOutputPolarity	(1 << 2)
+#define DataBusWidth16		(1 << 3)
+#define DREQOutputPolarity	(1 << 5)
+#define DACKInputPolarity	(1 << 6)
+#define EOTInputPolarity	(1 << 7)
+#define DACKMode		(1 << 8)
+#define AnalogOCEnable		(1 << 10)
+#define SuspendClkNotStop	(1 << 11)
+#define DownstreamPort15KRSel	(1 << 12)
+
+/* 
+ * HcDMAConfiguration
+ */
+#define DMAReadWriteSelect 	(1 << 0)
+#define ITL_ATL_DataSelect	(1 << 1)
+#define DMACounterSelect	(1 << 2)
+#define DMAEnable		(1 << 4)
+#define BurstLen_1		0
+#define BurstLen_4		(1 << 5)
+#define BurstLen_8		(2 << 5)
+
+/*
+ * HcuPInterrupt
+ */
+#define SOFITLInt		(1 << 0)
+#define ATLInt			(1 << 1)
+#define AllEOTInterrupt		(1 << 2)
+#define OPR_Reg			(1 << 4)
+#define HCSuspended		(1 << 5)
+#define ClkReady		(1 << 6)
+
+/*
+ * HcBufferStatus
+ */
+#define ITL0BufferFull		(1 << 0)
+#define ITL1BufferFull		(1 << 1)
+#define ATLBufferFull		(1 << 2)
+#define ITL0BufferDone		(1 << 3)
+#define ITL1BufferDone		(1 << 4)
+#define ATLBufferDone		(1 << 5)
+
+/* OHCI ROOT HUB REGISTER MASKS */
+
+/* roothub.portstatus [i] bits */
+#define RH_PS_CCS            0x00000001	/* current connect status */
+#define RH_PS_PES            0x00000002	/* port enable status */
+#define RH_PS_PSS            0x00000004	/* port suspend status */
+#define RH_PS_POCI           0x00000008	/* port over current indicator */
+#define RH_PS_PRS            0x00000010	/* port reset status */
+#define RH_PS_PPS            0x00000100	/* port power status */
+#define RH_PS_LSDA           0x00000200	/* low speed device attached */
+#define RH_PS_CSC            0x00010000	/* connect status change */
+#define RH_PS_PESC           0x00020000	/* port enable status change */
+#define RH_PS_PSSC           0x00040000	/* port suspend status change */
+#define RH_PS_OCIC           0x00080000	/* over current indicator change */
+#define RH_PS_PRSC           0x00100000	/* port reset status change */
+
+/* roothub.status bits */
+#define RH_HS_LPS		0x00000001	/* local power status */
+#define RH_HS_OCI		0x00000002	/* over current indicator */
+#define RH_HS_DRWE		0x00008000	/* device remote wakeup enable */
+#define RH_HS_LPSC		0x00010000	/* local power status change */
+#define RH_HS_OCIC		0x00020000	/* over current indicator change */
+#define RH_HS_CRWE		0x80000000	/* clear remote wakeup enable */
+
+/* roothub.b masks */
+#define RH_B_DR			0x0000ffff	/* device removable flags */
+#define RH_B_PPCM		0xffff0000	/* port power control mask */
+
+/* roothub.a masks */
+#define	RH_A_NDP		(0xff << 0)	/* number of downstream ports */
+#define	RH_A_PSM		(1 << 8)	/* power switching mode */
+#define	RH_A_NPS		(1 << 9)	/* no power switching */
+#define	RH_A_DT			(1 << 10)	/* device type (mbz) */
+#define	RH_A_OCPM		(1 << 11)	/* over current protection mode */
+#define	RH_A_NOCP		(1 << 12)	/* no over current protection */
+#define	RH_A_POTPGT		(0xff << 24)	/* power on to power good time */
+
+#define URB_DEL 1
+
+#define PORT_STAT_DEFAULT		0x0100
+#define PORT_CONNECT_STAT  		0x1
+#define PORT_ENABLE_STAT		0x2
+#define PORT_SUSPEND_STAT		0x4
+#define PORT_OVER_CURRENT_STAT		0x8
+#define PORT_RESET_STAT			0x10
+#define PORT_POWER_STAT			0x100
+#define PORT_LOW_SPEED_DEV_ATTACH_STAT	0x200
+
+#define PORT_CHANGE_DEFAULT		0x0
+#define PORT_CONNECT_CHANGE		0x1
+#define PORT_ENABLE_CHANGE		0x2
+#define PORT_SUSPEND_CHANGE		0x4
+#define PORT_OVER_CURRENT_CHANGE	0x8
+#define PORT_RESET_CHANGE		0x10
+
+/* Port Status Request info */
+
+typedef struct portstat {
+	__u16 portChange;
+	__u16 portStatus;
+} portstat_t;
+
+typedef struct hcipriv {
+	int irq;
+	int disabled;		/* e.g. got a UE, we're hung */
+	atomic_t resume_count;	/* defending against multiple resumes */
+	struct ohci_regs *regs;	/* OHCI controller's memory */
+	int hcport;		/* I/O base address */
+	int hcport2;		/* I/O data reg addr */
+
+	struct portstat *RHportStatus;	/* root hub port status */
+
+	int intrstatus;
+	__u32 hc_control;	/* copy of the hc control reg */
+
+	int frame;
+
+	__u8 *tl;
+	int xferPktLen;
+	int atl_len;
+	int atl_buffer_len;
+	int itl0_len;
+	int itl1_len;
+	int itl_buffer_len;
+	int itl_index;
+	int tl_last;
+	int units_left;
+
+} hcipriv_t;
+struct hci;
+
+#define cClt        0		// Control
+#define cISO        1		// ISO
+#define cBULK       2		// BULK
+#define cInt        3		// Interrupt
+#define ISO_BIT     0x10
+
+/*-------------------------------------------------------------------------
+ * EP0 use for configuration and Vendor Specific command interface
+ *------------------------------------------------------------------------*/
+#define cMemStart       0x10
+#define EP0Buf          0x40	/* SL11H/SL811H memory start at 0x40 */
+#define EP0Len          0x40	/* Length of config buffer EP0Buf */
+#define EP1Buf          0x60
+#define EP1Len          0x40
+
+/*-------------------------------------------------------------------------
+ * SL11H/SL811H memory from 80h-ffh use as ping-pong buffer.
+ *------------------------------------------------------------------------*/
+#define uBufA           0x80	/* buffer A address for DATA0 */
+#define uBufB           0xc0	/* buffer B address for DATA1 */
+#define uXferLen        0x40	/* xfer length */
+#define sMemSize        0xc0	/* Total SL11 memory size */
+#define cMemEnd         256
+
+/*-------------------------------------------------------------------------
+ * SL811H Register Control memory map
+ * --Note: 
+ *      --SL11H only has one control register set from 0x00-0x04
+ *      --SL811H has two control register set from 0x00-0x04 and 0x08-0x0c
+ *------------------------------------------------------------------------*/
+
+#define EP0Control      0x00
+#define EP0Address      0x01
+#define EP0XferLen      0x02
+#define EP0Status       0x03
+#define EP0Counter      0x04
+
+#define EP1Control      0x08
+#define EP1Address      0x09
+#define EP1XferLen      0x0a
+#define EP1Status       0x0b
+#define EP1Counter      0x0c
+
+#define CtrlReg         0x05
+#define IntEna          0x06
+			 // 0x07 is reserved
+#define IntStatus       0x0d
+#define cDATASet        0x0e
+#define cSOFcnt         0x0f
+#define IntMask         0x57	/* Reset|DMA|EP0|EP2|EP1 for IntEna */
+#define HostMask        0x47	/* Host request command  for IntStatus */
+#define ReadMask        0xd7	/* Read mask interrupt   for IntStatus */
+
+/*-------------------------------------------------------------------------
+ * Standard Chapter 9 definition
+ *-------------------------------------------------------------------------
+ */
+#define GET_STATUS      0x00
+#define CLEAR_FEATURE   0x01
+#define SET_FEATURE     0x03
+#define SET_ADDRESS     0x05
+#define GET_DESCRIPTOR  0x06
+#define SET_DESCRIPTOR  0x07
+#define GET_CONFIG      0x08
+#define SET_CONFIG      0x09
+#define GET_INTERFACE   0x0a
+#define SET_INTERFACE   0x0b
+#define SYNCH_FRAME     0x0c
+
+#define DEVICE          0x01
+#define CONFIGURATION   0x02
+#define STRING          0x03
+#define INTERFACE       0x04
+#define ENDPOINT        0x05
+
+/*-------------------------------------------------------------------------
+ * SL11H/SL811H definition
+ *-------------------------------------------------------------------------
+ */
+#define DATA0_WR	0x07	// (Arm+Enable+tranmist to Host+DATA0)
+#define DATA1_WR	0x47	// (Arm+Enable+tranmist to Host on DATA1)
+#define ZDATA0_WR	0x05	// (Arm+Transaction Ignored+tranmist to Host+DATA0)
+#define ZDATA1_WR	0x45	// (Arm+Transaction Ignored+tranmist to Host+DATA1)
+#define DATA0_RD	0x03	// (Arm+Enable+received from Host+DATA0)
+#define DATA1_RD	0x43	// (Arm+Enable+received from Host+DATA1)
+
+#define PID_SETUP	0x2d	// USB Specification 1.1 Standard Definition
+#define PID_SOF		0xA5
+#define PID_IN		0x69
+#define PID_OUT		0xe1
+
+#define MAX_RETRY	0xffff
+#define TIMEOUT		5		/* 2 mseconds */
+
+#define SL11H_HOSTCTLREG	0
+#define SL11H_BUFADDRREG	1
+#define SL11H_BUFLNTHREG	2
+#define SL11H_PKTSTATREG	3	/* read */
+#define SL11H_PIDEPREG		3	/* write */
+#define SL11H_XFERCNTREG	4	/* read */
+#define SL11H_DEVADDRREG	4	/* write */
+#define SL11H_CTLREG1		5
+#define SL11H_INTENBLREG	6
+
+#define SL11H_HOSTCTLREG_B	8
+#define SL11H_BUFADDRREG_B	9
+#define SL11H_BUFLNTHREG_B	0x0A
+#define SL11H_PKTSTATREG_B	0x0B	/* read */
+#define SL11H_PIDEPREG_B	0x0B	/* write */
+#define SL11H_XFERCNTREG_B	0x0C	/* read */
+#define SL11H_DEVADDRREG_B	0x0C	/* write */
+
+#define SL11H_INTSTATREG	0x0D	/* write clears bitwise */
+#define SL11H_HWREVREG		0x0E	/* read */
+#define SL11H_SOFLOWREG		0x0E	/* write */
+#define SL11H_SOFTMRREG		0x0F	/* read */
+#define SL11H_CTLREG2		0x0F	/* write */
+#define SL11H_DATA_START	0x10
+
+/* Host control register bits (addr 0) */
+#define SL11H_HCTLMASK_ARM	1
+#define SL11H_HCTLMASK_ENBLEP	2
+#define SL11H_HCTLMASK_WRITE	4
+#define SL11H_HCTLMASK_ISOCH	0x10
+#define SL11H_HCTLMASK_AFTERSOF	0x20
+#define SL11H_HCTLMASK_SEQ	0x40
+#define SL11H_HCTLMASK_PREAMBLE	0x80
+
+/* Packet status register bits (addr 3) */
+#define SL11H_STATMASK_ACK	1
+#define SL11H_STATMASK_ERROR	2
+#define SL11H_STATMASK_TMOUT	4
+#define SL11H_STATMASK_SEQ	8
+#define SL11H_STATMASK_SETUP	0x10
+#define SL11H_STATMASK_OVF	0x20
+#define SL11H_STATMASK_NAK	0x40
+#define SL11H_STATMASK_STALL	0x80
+
+/* Control register 1 bits (addr 5) */
+#define SL11H_CTL1MASK_DSBLSOF	1
+#define SL11H_CTL1MASK_NOTXEOF2	4
+#define SL11H_CTL1MASK_DSTATE	0x18
+#define SL11H_CTL1MASK_NSPD	0x20
+#define SL11H_CTL1MASK_SUSPEND	0x40
+#define SL11H_CTL1MASK_CLK12	0x80
+
+#define SL11H_CTL1VAL_RESET	8
+
+/* Interrut enable (addr 6) and interrupt status register bits (addr 0xD) */
+#define SL11H_INTMASK_XFERDONE	1
+#define SL11H_INTMASK_SOFINTR	0x10
+#define SL11H_INTMASK_INSRMV	0x20
+#define SL11H_INTMASK_USBRESET	0x40
+#define SL11H_INTMASK_DSTATE	0x80	/* only in status reg */
+
+/* HW rev and SOF lo register bits (addr 0xE) */
+#define SL11H_HWRMASK_HWREV	0xF0
+
+/* SOF counter and control reg 2 (addr 0xF) */
+#define SL11H_CTL2MASK_SOFHI	0x3F
+#define SL11H_CTL2MASK_DSWAP	0x40
+#define SL11H_CTL2MASK_HOSTMODE	0xae
+
diff -Nur linux-2.4.19.old/drivers/usb/hc_sl811_rh.c linux-2.4.19/drivers/usb/hc_sl811_rh.c
--- linux-2.4.19.old/drivers/usb/hc_sl811_rh.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/hc_sl811_rh.c	Mon Nov 25 12:26:55 2002
@@ -0,0 +1,526 @@
+
+/*-------------------------------------------------------------------------*/
+/*-------------------------------------------------------------------------*
+ * SL811HS virtual root hub
+ *  
+ * based on usb-ohci.c by R. Weissgaerber et al.
+ *-------------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+#undef DEBUG
+#endif
+static __u32 getPortStatusAndChange (hci_t * hci);
+static void setPortStatus (hci_t * hci, __u16 bitPos);
+static void setPortChange (hci_t * hci, __u16 bitPos);
+static void clrPortStatus (hci_t * hci, __u16 bitPos);
+static void clrPortChange (hci_t * hci, __u16 bitPos);
+static int USBReset (hci_t * hci);
+static int cc_to_error (int cc);
+
+/*-------------------------------------------------------------------------*
+ * Virtual Root Hub 
+ *-------------------------------------------------------------------------*/
+
+/* Device descriptor */
+static __u8 root_hub_dev_des[] = {
+	0x12,			/*  __u8  bLength; */
+	0x01,			/*  __u8  bDescriptorType; Device */
+	0x10,			/*  __u16 bcdUSB; v1.1 */
+	0x01,
+	0x09,			/*  __u8  bDeviceClass; HUB_CLASSCODE */
+	0x00,			/*  __u8  bDeviceSubClass; */
+	0x00,			/*  __u8  bDeviceProtocol; */
+	0x08,			/*  __u8  bMaxPacketSize0; 8 Bytes */
+	0x00,			/*  __u16 idVendor; */
+	0x00,
+	0x00,			/*  __u16 idProduct; */
+	0x00,
+	0x00,			/*  __u16 bcdDevice; */
+	0x00,
+	0x00,			/*  __u8  iManufacturer; */
+	0x02,			/*  __u8  iProduct; */
+	0x01,			/*  __u8  iSerialNumber; */
+	0x01			/*  __u8  bNumConfigurations; */
+};
+
+/* Configuration descriptor */
+static __u8 root_hub_config_des[] = {
+	0x09,			/*  __u8  bLength; */
+	0x02,			/*  __u8  bDescriptorType; Configuration */
+	0x19,			/*  __u16 wTotalLength; */
+	0x00,
+	0x01,			/*  __u8  bNumInterfaces; */
+	0x01,			/*  __u8  bConfigurationValue; */
+	0x00,			/*  __u8  iConfiguration; */
+	0x40,			/*  __u8  bmAttributes; 
+				   Bit 7: Bus-powered, 6: Self-powered, 5 Remote-wakwup, 
+				   4..0: resvd */
+	0x00,			/*  __u8  MaxPower; */
+
+	/* interface */
+	0x09,			/*  __u8  if_bLength; */
+	0x04,			/*  __u8  if_bDescriptorType; Interface */
+	0x00,			/*  __u8  if_bInterfaceNumber; */
+	0x00,			/*  __u8  if_bAlternateSetting; */
+	0x01,			/*  __u8  if_bNumEndpoints; */
+	0x09,			/*  __u8  if_bInterfaceClass; HUB_CLASSCODE */
+	0x00,			/*  __u8  if_bInterfaceSubClass; */
+	0x00,			/*  __u8  if_bInterfaceProtocol; */
+	0x00,			/*  __u8  if_iInterface; */
+
+	/* endpoint */
+	0x07,			/*  __u8  ep_bLength; */
+	0x05,			/*  __u8  ep_bDescriptorType; Endpoint */
+	0x81,			/*  __u8  ep_bEndpointAddress; IN Endpoint 1 */
+	0x03,			/*  __u8  ep_bmAttributes; Interrupt */
+	0x02,			/*  __u16 ep_wMaxPacketSize; ((MAX_ROOT_PORTS + 1) / 8 */
+	0x00,
+	0xff			/*  __u8  ep_bInterval; 255 ms */
+};
+
+/* Hub class-specific descriptor is constructed dynamically */
+
+/***************************************************************************
+ * Function Name : rh_send_irq
+ * 
+ * This function examine the port change in the virtual root hub.
+ * 
+ * Note: This function assumes only one port exist in the root hub.
+ *
+ * Input:  hci = data structure for the host controller
+ *         rh_data = The pointer to port change data
+ *         rh_len = length of the data in bytes
+ *
+ * Return: length of data  
+ **************************************************************************/
+static int rh_send_irq (hci_t * hci, void *rh_data, int rh_len)
+{
+	int num_ports;
+	int i;
+	int ret;
+	int len;
+	__u8 data[8];
+
+	DBGFUNC ("enter rh_send_irq: \n");
+
+	/* Assuming the root hub has one port.  This value need to change if
+	 * there are more than one port for the root hub
+	 */
+
+	num_ports = 1;
+
+	/* The root hub status is not implemented, it basically has two fields:
+	 *     -- Local Power Status
+	 *     -- Over Current Indicator
+	 *     -- Local Power Change
+	 *     -- Over Current Indicator
+	 *
+	 * Right now, It is assume the power is good and no changes 
+	 */
+
+	*(__u8 *) data = 0;
+
+	ret = *(__u8 *) data;
+
+	/* Has the port status change within the root hub: It checks for
+	 *      -- Port Connect Status change
+	 *      -- Port Enable Change
+	 */
+
+	for (i = 0; i < num_ports; i++) {
+		*(__u8 *) (data + (i + 1) / 8) |=
+		    (((getPortStatusAndChange (hci) >> 16) & (PORT_CONNECT_STAT | PORT_ENABLE_STAT)) ? 1 : 0) << ((i + 1) % 8);
+		ret += *(__u8 *) (data + (i + 1) / 8);
+
+		/* After the port change is read, it should be reset so the next time 
+		 * is it doesn't trigger a change again */
+
+	}
+	len = i / 8 + 1;
+
+	if (ret > 0) {
+		memcpy (rh_data, data, min (len, min (rh_len, (int)sizeof (data))));
+		return len;
+	}
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : rh_int_timer_do
+ * 
+ * This function is called when the timer expires.  It gets the the port 
+ * change data and pass along to the upper protocol.
+ * 
+ * Note:  The virtual root hub interrupt pipe are polled by the timer
+ *        every "interval" ms
+ *
+ * Input:  ptr = ptr to the urb
+ *
+ * Return: none  
+ **************************************************************************/
+static void rh_int_timer_do (unsigned long ptr)
+{
+	int len;
+	struct urb *urb = (struct urb *) ptr;
+	hci_t *hci = urb->dev->bus->hcpriv;
+
+	DBGFUNC ("enter rh_int_timer_do\n");
+
+	if (hci->rh.send) {
+		len = rh_send_irq (hci, urb->transfer_buffer,
+				   urb->transfer_buffer_length);
+		if (len > 0) {
+			urb->actual_length = len;
+			if (urb_debug == 2)
+				urb_print (urb, "RET-t(rh)",
+					   usb_pipeout (urb->pipe));
+
+			if (urb->complete) {
+				urb->complete (urb);
+			}
+		}
+	}
+
+	/* re-activate the timer */
+	rh_init_int_timer (urb);
+}
+
+/***************************************************************************
+ * Function Name : rh_init_int_timer
+ * 
+ * This function creates a timer that act as interrupt pipe in the
+ * virtual hub.   
+ * 
+ * Note:  The virtual root hub's interrupt pipe are polled by the timer
+ *        every "interval" ms
+ *
+ * Input: urb = USB request block 
+ *
+ * Return: 0  
+ **************************************************************************/
+static int rh_init_int_timer (struct urb * urb)
+{
+	hci_t *hci = urb->dev->bus->hcpriv;
+	hci->rh.interval = urb->interval;
+
+	init_timer (&hci->rh.rh_int_timer);
+	hci->rh.rh_int_timer.function = rh_int_timer_do;
+	hci->rh.rh_int_timer.data = (unsigned long) urb;
+	hci->rh.rh_int_timer.expires = jiffies + (HZ * (urb->interval < 30 ? 30 : urb->interval)) / 1000;
+	add_timer (&hci->rh.rh_int_timer);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* helper macro */
+#define OK(x) 			len = (x); break
+
+/***************************************************************************
+ * Function Name : rh_submit_urb
+ * 
+ * This function handles all USB request to the the virtual root hub
+ * 
+ * Input: urb = USB request block 
+ *
+ * Return: 0  
+ **************************************************************************/
+static int rh_submit_urb (struct urb * urb)
+{
+	struct usb_device *usb_dev = urb->dev;
+	hci_t *hci = usb_dev->bus->hcpriv;
+	unsigned int pipe = urb->pipe;
+	struct usb_ctrlrequest *cmd = (struct usb_ctrlrequest *) urb->setup_packet;
+	void *data = urb->transfer_buffer;
+	int leni = urb->transfer_buffer_length;
+	int len = 0;
+	int status = TD_CC_NOERROR;
+	__u32 datab[4];
+	__u8 *data_buf = (__u8 *) datab;
+
+	__u16 bmRType_bReq;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+
+	DBGFUNC ("enter rh_submit_urb\n");
+	if (usb_pipeint (pipe)) {
+		hci->rh.urb = urb;
+		hci->rh.send = 1;
+		hci->rh.interval = urb->interval;
+		rh_init_int_timer (urb);
+		urb->status = cc_to_error (TD_CC_NOERROR);
+
+		return 0;
+	}
+
+	bmRType_bReq = cmd->bRequestType | (cmd->bRequest << 8);
+	wValue = le16_to_cpu (cmd->wValue);
+	wIndex = le16_to_cpu (cmd->wIndex);
+	wLength = le16_to_cpu (cmd->wLength);
+
+	DBG ("rh_submit_urb, req = %d(%x) len=%d",
+	     bmRType_bReq, bmRType_bReq, wLength);
+
+	switch (bmRType_bReq) {
+		/* Request Destination:
+		   without flags: Device, 
+		   RH_INTERFACE: interface, 
+		   RH_ENDPOINT: endpoint,
+		   RH_CLASS means HUB here, 
+		   RH_OTHER | RH_CLASS  almost ever means HUB_PORT here 
+		 */
+
+	case RH_GET_STATUS:
+		*(__u16 *) data_buf = cpu_to_le16 (1);
+		OK (2);
+
+	case RH_GET_STATUS | RH_INTERFACE:
+		*(__u16 *) data_buf = cpu_to_le16 (0);
+		OK (2);
+
+	case RH_GET_STATUS | RH_ENDPOINT:
+		*(__u16 *) data_buf = cpu_to_le16 (0);
+		OK (2);
+
+	case RH_GET_STATUS | RH_CLASS:
+		*(__u32 *) data_buf = cpu_to_le32 (0);
+		OK (4);
+
+	case RH_GET_STATUS | RH_OTHER | RH_CLASS:
+		*(__u32 *) data_buf =
+		    cpu_to_le32 (getPortStatusAndChange (hci));
+		OK (4);
+
+	case RH_CLEAR_FEATURE | RH_ENDPOINT:
+		switch (wValue) {
+		case (RH_ENDPOINT_STALL):
+			OK (0);
+		}
+		break;
+
+	case RH_CLEAR_FEATURE | RH_CLASS:
+		switch (wValue) {
+		case RH_C_HUB_LOCAL_POWER:
+			OK (0);
+
+		case (RH_C_HUB_OVER_CURRENT):
+			/* Over Current Not Implemented */
+			OK (0);
+		}
+		break;
+
+	case RH_CLEAR_FEATURE | RH_OTHER | RH_CLASS:
+		switch (wValue) {
+		case (RH_PORT_ENABLE):
+			clrPortStatus (hci, PORT_ENABLE_STAT);
+			OK (0);
+
+		case (RH_PORT_SUSPEND):
+			clrPortStatus (hci, PORT_SUSPEND_STAT);
+			OK (0);
+
+		case (RH_PORT_POWER):
+			clrPortStatus (hci, PORT_POWER_STAT);
+			OK (0);
+
+		case (RH_C_PORT_CONNECTION):
+			clrPortChange (hci, PORT_CONNECT_STAT);
+			OK (0);
+
+		case (RH_C_PORT_ENABLE):
+			clrPortChange (hci, PORT_ENABLE_STAT);
+			OK (0);
+
+		case (RH_C_PORT_SUSPEND):
+			clrPortChange (hci, PORT_SUSPEND_STAT);
+			OK (0);
+
+		case (RH_C_PORT_OVER_CURRENT):
+			clrPortChange (hci, PORT_OVER_CURRENT_STAT);
+			OK (0);
+
+		case (RH_C_PORT_RESET):
+			clrPortChange (hci, PORT_RESET_STAT);
+			OK (0);
+		}
+		break;
+
+	case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
+		switch (wValue) {
+		case (RH_PORT_SUSPEND):
+			setPortStatus (hci, PORT_SUSPEND_STAT);
+			OK (0);
+
+		case (RH_PORT_RESET):
+			setPortStatus (hci, PORT_RESET_STAT);
+			// USBReset(hci);
+			clrPortChange (hci,
+				       PORT_CONNECT_CHANGE | PORT_ENABLE_CHANGE
+				       | PORT_SUSPEND_CHANGE |
+				       PORT_OVER_CURRENT_CHANGE);
+			setPortChange (hci, PORT_RESET_CHANGE);
+			clrPortStatus (hci, PORT_RESET_STAT);
+			setPortStatus (hci, PORT_ENABLE_STAT);
+
+			OK (0);
+
+		case (RH_PORT_POWER):
+			setPortStatus (hci, PORT_POWER_STAT);
+			OK (0);
+
+		case (RH_PORT_ENABLE):
+			setPortStatus (hci, PORT_ENABLE_STAT);
+			OK (0);
+		}
+		break;
+
+	case RH_SET_ADDRESS:
+		hci->rh.devnum = wValue;
+		OK (0);
+
+	case RH_GET_DESCRIPTOR:
+		DBGVERBOSE ("rh_submit_urb: RH_GET_DESCRIPTOR, wValue = 0x%x\n", wValue);
+		switch ((wValue & 0xff00) >> 8) {
+		case (0x01):	/* device descriptor */
+			len = min (leni, min ((__u16)sizeof (root_hub_dev_des), wLength));
+			data_buf = root_hub_dev_des;
+			OK (len);
+
+		case (0x02):	/* configuration descriptor */
+			len = min (leni, min ((__u16)sizeof (root_hub_config_des), wLength));
+			data_buf = root_hub_config_des;
+			OK (len);
+
+		case (0x03):	/* string descriptors */
+			len = usb_root_hub_string (wValue & 0xff, (int) (long) 0,
+						   "SL811HS", data, wLength);
+			if (len > 0) {
+				data_buf = data;
+				OK (min (leni, len));
+			}
+
+		default:
+			status = SL11H_STATMASK_STALL;
+		}
+		break;
+
+	case RH_GET_DESCRIPTOR | RH_CLASS:
+		data_buf[0] = 9;	// min length;
+		data_buf[1] = 0x29;
+		data_buf[2] = 1;	// # of downstream port
+		data_buf[3] = 0;
+		datab[1] = 0;
+		data_buf[5] = 50;	// 100 ms for port reset
+		data_buf[7] = 0xfc;	// which port is attachable
+		if (data_buf[2] < 7) {
+			data_buf[8] = 0xff;
+		} else {
+		}
+
+		len = min (leni, min ((__u16)data_buf[0], wLength));
+		OK (len);
+
+	case RH_GET_CONFIGURATION:
+		*(__u8 *) data_buf = 0x01;
+		OK (1);
+
+	case RH_SET_CONFIGURATION:
+		OK (0);
+
+	default:
+		DBGERR ("unsupported root hub command");
+		status = SL11H_STATMASK_STALL;
+	}
+
+	len = min (len, leni);
+	if (data != data_buf)
+		memcpy (data, data_buf, len);
+	urb->actual_length = len;
+	urb->status = cc_to_error (status);
+
+	urb->hcpriv = NULL;
+	urb->dev = NULL;
+	if (urb->complete) {
+		urb->complete (urb);
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : rh_unlink_urb
+ * 
+ * This function unlinks the URB 
+ * 
+ * Input: urb = USB request block 
+ *
+ * Return: 0  
+ **************************************************************************/
+static int rh_unlink_urb (struct urb * urb)
+{
+	hci_t *hci = urb->dev->bus->hcpriv;
+
+	DBGFUNC ("enter rh_unlink_urb\n");
+	if (hci->rh.urb == urb) {
+		hci->rh.send = 0;
+		del_timer (&hci->rh.rh_int_timer);
+		hci->rh.urb = NULL;
+
+		urb->hcpriv = NULL;
+		usb_put_dev (urb->dev);
+		urb->dev = NULL;
+		if (urb->transfer_flags & USB_ASYNC_UNLINK) {
+			urb->status = -ECONNRESET;
+			if (urb->complete) {
+				urb->complete (urb);
+			}
+		} else
+			urb->status = -ENOENT;
+	}
+	return 0;
+}
+
+/***************************************************************************
+ * Function Name : rh_connect_rh
+ * 
+ * This function connect the virtual root hub to the USB stack 
+ * 
+ * Input: urb = USB request block 
+ *
+ * Return: 0  
+ **************************************************************************/
+static int rh_connect_rh (hci_t * hci)
+{
+	struct usb_device *usb_dev;
+
+	hci->rh.devnum = 0;
+	usb_dev = usb_alloc_dev (NULL, hci->bus);
+	if (!usb_dev)
+		return -ENOMEM;
+
+	hci->bus->root_hub = usb_dev;
+	usb_connect (usb_dev);
+	if (usb_new_device (usb_dev) != 0) {
+		usb_free_dev (usb_dev);
+		return -ENODEV;
+	}
+
+	return 0;
+}
diff -Nur linux-2.4.19.old/drivers/usb/hcd/ehci-hcd.c linux-2.4.19/drivers/usb/hcd/ehci-hcd.c
--- linux-2.4.19.old/drivers/usb/hcd/ehci-hcd.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hcd/ehci-hcd.c	Mon Nov 25 12:26:55 2002
@@ -434,10 +434,6 @@
 	scan_async (ehci);
 	if (ehci->next_uframe != -1)
 		scan_periodic (ehci);
-
-	// FIXME:  when nothing is connected to the root hub,
-	// turn off the RUN bit so the host can enter C3 "sleep" power
-	// saving mode; make root hub code scan memory less often.
 }
 
 /*-------------------------------------------------------------------------*/
@@ -582,7 +578,10 @@
 		return 0;
 
 	case PIPE_INTERRUPT:
-		intr_deschedule (ehci, urb->start_frame, qh, urb->interval);
+		intr_deschedule (ehci, urb->start_frame, qh,
+			(urb->dev->speed == USB_SPEED_HIGH)
+			    ? urb->interval
+			    : (urb->interval << 3));
 		if (ehci->hcd.state == USB_STATE_HALT)
 			urb->status = -ESHUTDOWN;
 		qh_completions (ehci, qh, 1);
diff -Nur linux-2.4.19.old/drivers/usb/hcd/ehci-q.c linux-2.4.19/drivers/usb/hcd/ehci-q.c
--- linux-2.4.19.old/drivers/usb/hcd/ehci-q.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hcd/ehci-q.c	Mon Nov 25 12:26:55 2002
@@ -368,7 +368,7 @@
 		/* SETUP for control urb? */
 		if (unlikely (QTD_PID (token) == 2))
 			pci_unmap_single (ehci->hcd.pdev,
-				qtd->buf_dma, sizeof (devrequest),
+				qtd->buf_dma, sizeof (struct usb_ctrlrequest),
 				PCI_DMA_TODEVICE);
 	}
 
@@ -419,7 +419,7 @@
 			 */
 			if (!unmapped++ && usb_pipecontrol (urb->pipe)) {
 				direction = PCI_DMA_TODEVICE;
-				size = sizeof (devrequest);
+				size = sizeof (struct usb_ctrlrequest);
 			} else {
 				direction = usb_pipein (urb->pipe)
 					? PCI_DMA_FROMDEVICE
@@ -470,13 +470,13 @@
 		qtd->buf_dma = pci_map_single (
 					ehci->hcd.pdev,
 					urb->setup_packet,
-					sizeof (devrequest),
+					sizeof (struct usb_ctrlrequest),
 					PCI_DMA_TODEVICE);
 		if (unlikely (!qtd->buf_dma))
 			goto cleanup;
 
 		/* SETUP pid */
-		qtd_fill (qtd, qtd->buf_dma, sizeof (devrequest),
+		qtd_fill (qtd, qtd->buf_dma, sizeof (struct usb_ctrlrequest),
 			token | (2 /* "setup" */ << 8));
 
 		/* ... and always at least one more pid */
@@ -681,6 +681,8 @@
 	default:
 #ifdef DEBUG
 		BUG ();
+#else
+		;
 #endif
 	}
 
@@ -817,9 +819,9 @@
 		} else {
 			// dbg_qh ("empty qh", ehci, qh);
 
-// FIXME:  how handle usb_clear_halt() for an EP with queued URBs?
-// usbcore may not let us handle that cleanly...
-// likely must cancel them all first!
+			/* NOTE: we already canceled any queued URBs
+			 * when the endpoint halted.
+			 */
 
 			/* usb_clear_halt() means qh data toggle gets reset */
 			if (usb_pipebulk (urb->pipe)
diff -Nur linux-2.4.19.old/drivers/usb/hcd/ehci-sched.c linux-2.4.19/drivers/usb/hcd/ehci-sched.c
--- linux-2.4.19.old/drivers/usb/hcd/ehci-sched.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hcd/ehci-sched.c	Mon Nov 25 12:26:55 2002
@@ -881,7 +881,7 @@
 	unsigned long	flags
 ) {
 	struct urb				*urb = itd->urb;
-	iso_packet_descriptor_t			*desc;
+	struct iso_packet_descriptor		*desc;
 	u32					t;
 
 	/* update status for this uframe's transfers */
@@ -919,17 +919,9 @@
 		return flags;
 
 	/*
-	 * For now, always give the urb back to the driver ... expect it
-	 * to submit a new urb (or resubmit this), and to have another
-	 * already queued when un-interrupted transfers are needed.
-	 * No, that's not what OHCI or UHCI are now doing.
-	 *
-	 * FIXME Revisit the ISO URB model.  It's cleaner not to have all
-	 * the special case magic, but it'd be faster to reuse existing
-	 * ITD/DMA setup and schedule state.  Easy to dma_sync/complete(),
-	 * then either reschedule or, if unlinking, free and giveback().
-	 * But we can't overcommit like the full and low speed HCs do, and
-	 * there's no clean way to report an error when rescheduling...
+	 * Always give the urb back to the driver ... expect it to submit
+	 * a new urb (or resubmit this), and to have another already queued
+	 * when un-interrupted transfers are needed.
 	 *
 	 * NOTE that for now we don't accelerate ISO unlinks; they just
 	 * happen according to the current schedule.  Means a delay of
@@ -964,15 +956,6 @@
 	if (urb->iso_frame_desc [0].offset != 0)
 		return -EINVAL;
 	
-	/*
-	 * NOTE doing this for now, anticipating periodic URB models
-	 * get updated to be "explicit resubmit".
-	 */
-	if (urb->next) {
-		dbg ("use explicit resubmit for ISO");
-		return -EINVAL;
-	}
-
 	/* allocate ITDs w/o locking anything */
 	status = itd_urb_transaction (ehci, urb, mem_flags);
 	if (status < 0)
diff -Nur linux-2.4.19.old/drivers/usb/hcd.c linux-2.4.19/drivers/usb/hcd.c
--- linux-2.4.19.old/drivers/usb/hcd.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hcd.c	Mon Nov 25 12:26:55 2002
@@ -56,7 +56,8 @@
  * USB Host Controller Driver framework
  *
  * Plugs into usbcore (usb_bus) and lets HCDs share code, minimizing
- * HCD-specific behaviors/bugs.
+ * HCD-specific behaviors/bugs.  Think of it as the "upper level" of
+ * some drivers, where the "lower level" is hardware-specific.
  *
  * This does error checks, tracks devices and urbs, and delegates to a
  * "hc_driver" only for code (and data) that really needs to know about
@@ -78,6 +79,9 @@
  * Roman Weissgaerber, Rory Bolt, ...
  *
  * HISTORY:
+ * 2002-sept	Merge some 2.5 updates so we can share hardware level HCD
+ * 	code between the 2.4.20+ and 2.5 trees.
+ * 2002-feb	merge to 2.4.19
  * 2001-12-12	Initial patch version for Linux 2.5.1 kernel.
  */
 
@@ -316,16 +320,16 @@
 /* Root hub control transfers execute synchronously */
 static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 {
-	devrequest	*cmd = (devrequest *) urb->setup_packet;
+	struct usb_ctrlrequest *cmd = (struct usb_ctrlrequest *) urb->setup_packet;
  	u16		typeReq, wValue, wIndex, wLength;
 	const u8	*bufp = 0;
 	u8		*ubuf = urb->transfer_buffer;
 	int		len = 0;
 
-	typeReq  = (cmd->requesttype << 8) | cmd->request;
-	wValue   = le16_to_cpu (cmd->value);
-	wIndex   = le16_to_cpu (cmd->index);
-	wLength  = le16_to_cpu (cmd->length);
+	typeReq  = (cmd->bRequestType << 8) | cmd->bRequest;
+	wValue   = le16_to_cpu (cmd->wValue);
+	wIndex   = le16_to_cpu (cmd->wIndex);
+	wLength  = le16_to_cpu (cmd->wLength);
 
 	if (wLength > urb->transfer_buffer_length)
 		goto error;
@@ -583,7 +587,6 @@
 	struct hc_driver	*driver;
 	unsigned long		resource, len;
 	void			*base;
-	u8			latency, limit;
 	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
 	int			retval, region;
@@ -662,15 +665,6 @@
 	hcd->pdev = dev;
 	info ("%s @ %s, %s", hcd->description,  dev->slot_name, dev->name);
 
-	pci_read_config_byte (dev, PCI_LATENCY_TIMER, &latency);
-	if (latency) {
-		pci_read_config_byte (dev, PCI_MAX_LAT, &limit);
-		if (limit && limit < latency) {
-			dbg ("PCI latency reduced to max %d", limit);
-			pci_write_config_byte (dev, PCI_LATENCY_TIMER, limit);
-		}
-	}
-
 #ifndef __sparc__
 	sprintf (buf, "%d", dev->irq);
 #else
@@ -701,7 +695,8 @@
 		goto clean_3;
 	}
 	hcd->bus = bus;
-	hcd->bus_name = dev->slot_name;
+	hcd->bus_name = dev->slot_name;		/* prefer bus->bus_name */
+	bus->bus_name = dev->slot_name;
 	hcd->product_desc = dev->name;
 	bus->hcpriv = (void *) hcd;
 
@@ -1072,6 +1067,8 @@
 	if (urb->transfer_buffer_length < 0)
 		return -EINVAL;
 
+	// FIXME set urb->transfer_dma and/or setup_dma 
+
 	if (urb->next) {
 		warn ("use explicit queuing not urb->next");
 		return -EINVAL;
@@ -1463,6 +1460,8 @@
 		dbg ("giveback urb %p status %d len %d",
 			urb, urb->status, urb->actual_length);
 
+	// FIXME unmap urb->transfer_dma and/or setup_dma 
+
 	/* pass ownership to the completion handler */
 	urb->complete (urb);
 }
diff -Nur linux-2.4.19.old/drivers/usb/hcd.h linux-2.4.19/drivers/usb/hcd.h
--- linux-2.4.19.old/drivers/usb/hcd.h	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hcd.h	Mon Nov 25 12:26:55 2002
@@ -153,6 +153,7 @@
 
 #ifdef CONFIG_PCI
 
+struct pci_device_id;
 extern int usb_hcd_pci_probe (struct pci_dev *dev,
 				const struct pci_device_id *id);
 extern void usb_hcd_pci_remove (struct pci_dev *dev);
@@ -206,6 +207,54 @@
 
 /*-------------------------------------------------------------------------*/
 
+/*
+ * Generic bandwidth allocation constants/support
+ */
+#define FRAME_TIME_USECS	1000L
+#define BitTime(bytecount)  (7 * 8 * bytecount / 6)  /* with integer truncation */
+		/* Trying not to use worst-case bit-stuffing
+                   of (7/6 * 8 * bytecount) = 9.33 * bytecount */
+		/* bytecount = data payload byte count */
+
+#define NS_TO_US(ns)	((ns + 500L) / 1000L)
+			/* convert & round nanoseconds to microseconds */
+
+extern void usb_claim_bandwidth (struct usb_device *dev, struct urb *urb,
+		int bustime, int isoc);
+extern void usb_release_bandwidth (struct usb_device *dev, struct urb *urb,
+		int isoc);
+
+/*
+ * Full/low speed bandwidth allocation constants/support.
+ */
+#define BW_HOST_DELAY	1000L		/* nanoseconds */
+#define BW_HUB_LS_SETUP	333L		/* nanoseconds */
+                        /* 4 full-speed bit times (est.) */
+
+#define FRAME_TIME_BITS         12000L		/* frame = 1 millisecond */
+#define FRAME_TIME_MAX_BITS_ALLOC	(90L * FRAME_TIME_BITS / 100L)
+#define FRAME_TIME_MAX_USECS_ALLOC	(90L * FRAME_TIME_USECS / 100L)
+
+extern int usb_check_bandwidth (struct usb_device *dev, struct urb *urb);
+
+/*
+ * Ceiling microseconds (typical) for that many bytes at high speed
+ * ISO is a bit less, no ACK ... from USB 2.0 spec, 5.11.3 (and needed
+ * to preallocate bandwidth)
+ */
+#define USB2_HOST_DELAY	5	/* nsec, guess */
+#define HS_USECS(bytes) NS_TO_US ( ((55 * 8 * 2083)/1000) \
+	+ ((2083UL * (3167 + BitTime (bytes)))/1000) \
+	+ USB2_HOST_DELAY)
+#define HS_USECS_ISO(bytes) NS_TO_US ( ((long)(38 * 8 * 2.083)) \
+	+ ((2083UL * (3167 + BitTime (bytes)))/1000) \
+	+ USB2_HOST_DELAY)
+
+extern long usb_calc_bus_time (int speed, int is_input,
+			int isoc, int bytecount);
+
+/*-------------------------------------------------------------------------*/
+
 /* hub.h ... DeviceRemovable in 2.4.2-ac11, gone in 2.4.10 */
 // bleech -- resurfaced in 2.4.11 or 2.4.12
 #define bitmap 	DeviceRemovable
@@ -217,3 +266,20 @@
 
 #define	RUN_CONTEXT (in_irq () ? "in_irq" \
 		: (in_interrupt () ? "in_interrupt" : "can sleep"))
+
+/* 2.5 changes ... */
+
+#ifndef container_of
+#define	container_of	list_entry
+#endif
+
+#define usb_get_urb(x) (x)
+#define usb_put_urb(x)
+
+static inline struct usb_bus *hcd_to_bus (struct usb_hcd *hcd)
+	{ return hcd->bus; }
+
+static inline void
+usb_hub_tt_clear_buffer (struct usb_device *dev, int pipe)
+	{ }
+
diff -Nur linux-2.4.19.old/drivers/usb/hid-core.c linux-2.4.19/drivers/usb/hid-core.c
--- linux-2.4.19.old/drivers/usb/hid-core.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hid-core.c	Mon Nov 25 12:26:55 2002
@@ -988,7 +988,7 @@
 
 static int hid_submit_out(struct hid_device *hid)
 {
-	hid->urbout.transfer_buffer_length = le16_to_cpup(&hid->out[hid->outtail].dr.length);
+	hid->urbout.transfer_buffer_length = le16_to_cpup(&hid->out[hid->outtail].dr.wLength);
 	hid->urbout.transfer_buffer = hid->out[hid->outtail].buffer;
 	hid->urbout.setup_packet = (void *) &(hid->out[hid->outtail].dr);
 	hid->urbout.dev = hid->dev;
@@ -1018,8 +1018,8 @@
 {
 	hid_output_report(report, hid->out[hid->outhead].buffer);
 
-	hid->out[hid->outhead].dr.value = cpu_to_le16(0x200 | report->id);
-	hid->out[hid->outhead].dr.length = cpu_to_le16((report->size + 7) >> 3);
+	hid->out[hid->outhead].dr.wValue = cpu_to_le16(0x200 | report->id);
+	hid->out[hid->outhead].dr.wLength = cpu_to_le16((report->size + 7) >> 3);
 
 	hid->outhead = (hid->outhead + 1) & (HID_CONTROL_FIFO_SIZE - 1);
 
@@ -1065,8 +1065,8 @@
 			list = report_enum->report_list.next;
 			while (list != &report_enum->report_list) {
 				report = (struct hid_report *) list;
-				usb_set_idle(hid->dev, hid->ifnum, 0, report->id);
 				hid_read_report(hid, report);
+				usb_set_idle(hid->dev, hid->ifnum, 0, report->id);
 				list = list->next;
 			}
 		}
@@ -1204,9 +1204,9 @@
 	hid->ifnum = interface->bInterfaceNumber;
 
 	for (n = 0; n < HID_CONTROL_FIFO_SIZE; n++) {
-		hid->out[n].dr.requesttype = USB_TYPE_CLASS | USB_RECIP_INTERFACE;
-		hid->out[n].dr.request = USB_REQ_SET_REPORT;
-		hid->out[n].dr.index = cpu_to_le16(hid->ifnum);
+		hid->out[n].dr.bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE;
+		hid->out[n].dr.bRequest = USB_REQ_SET_REPORT;
+		hid->out[n].dr.wIndex = cpu_to_le16(hid->ifnum);
 	}
 
 	hid->name[0] = 0;
diff -Nur linux-2.4.19.old/drivers/usb/hid.h linux-2.4.19/drivers/usb/hid.h
--- linux-2.4.19.old/drivers/usb/hid.h	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hid.h	Mon Nov 25 12:26:55 2002
@@ -287,7 +287,7 @@
 #define HID_CONTROL_FIFO_SIZE	8
 
 struct hid_control_fifo {
-	devrequest dr;
+	struct usb_ctrlrequest dr;
 	char buffer[HID_BUFFER_SIZE];
 };
 
diff -Nur linux-2.4.19.old/drivers/usb/hpusbscsi.c linux-2.4.19/drivers/usb/hpusbscsi.c
--- linux-2.4.19.old/drivers/usb/hpusbscsi.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hpusbscsi.c	Mon Nov 25 12:26:55 2002
@@ -1,3 +1,51 @@
+/*
+ * hpusbscsi
+ * (C) Copyright 2001 Oliver Neukum 
+ * Sponsored by the Linux Usb Project
+ * Large parts based on or taken from code by John Fremlin and Matt Dharm
+ * 
+ * This driver is known to work with the following scanners (VID, PID)
+ *    (0x03f0, 0x0701)  HP 53xx 
+ *    (0x03f0, 0x0801)  HP 7400 
+ *    (0x0638, 0x026a)  Minolta Scan Dual II
+ *    (0x0686, 0x4004)  Minolta Elite II
+ * To load with full debugging load with "insmod hpusbscsi debug=2"
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Contributors:
+ *   Oliver Neukum
+ *   John Fremlin
+ *   Matt Dharm
+ *   .
+ *   .
+ *   Timothy Jedlicka <bonzo@lucent.com>
+ *
+ * History
+ *
+ * 22-Apr-2002
+ *
+ * - Added Elite II scanner - bonzo
+ * - Cleaned up the debug statements and made them optional at load time - bonzo
+ *
+ * 20020618
+ *
+ * - Confirm to stupid 2.4 rules on io_request_lock
+ *
+ */
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -16,12 +64,28 @@
 
 #include "hpusbscsi.h"
 
-#define DEBUG(x...) \
-	printk( KERN_DEBUG x )
-
 static char *states[]={"FREE", "BEGINNING", "WORKING", "ERROR", "WAIT", "PREMATURE"};
 
-#define TRACE_STATE printk(KERN_DEBUG"hpusbscsi->state = %s at line %d\n", states[hpusbscsi->state], __LINE__)
+/* DEBUG related parts */
+#define HPUSBSCSI_DEBUG
+
+#ifdef HPUSBSCSI_DEBUG
+#  define PDEBUG(level, fmt, args...) \
+          if (debug >= (level)) info("[" __PRETTY_FUNCTION__ ":%d] " fmt, __LINE__ , \
+                 ## args)
+#else
+#  define PDEBUG(level, fmt, args...) do {} while(0)
+#endif
+
+
+/* 0=no debug messages
+ * 1=everything but trace states
+ * 2=trace states
+ */
+static int debug; /* = 0 */
+
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Debug level: 0=none, 1=no trace states, 2=trace states");
 
 /* global variables */
 
@@ -54,7 +118,7 @@
 					      GFP_KERNEL);
 	if (new == NULL)
 		return NULL;
-	DEBUG ("Allocated memory\n");
+	PDEBUG (1, "Allocated memory");
 	memset (new, 0, sizeof (struct hpusbscsi));
 	spin_lock_init (&new->dataurb.lock);
 	spin_lock_init (&new->controlurb.lock);
@@ -136,14 +200,26 @@
 static void
 hpusbscsi_usb_disconnect (struct usb_device *dev, void *ptr)
 {
-                 usb_unlink_urb(&(((struct hpusbscsi *) ptr)->controlurb));
-	((struct hpusbscsi *) ptr)->dev = NULL;
+	struct hpusbscsi *hp = (struct hpusbscsi *)ptr;
+
+	usb_unlink_urb(&hp->controlurb);
+	usb_unlink_urb(&hp->dataurb);
+
+	spin_lock_irq(&io_request_lock);
+	hp->dev = NULL;
+	spin_unlock_irq(&io_request_lock);
 }
 
 static struct usb_device_id hpusbscsi_usb_ids[] = {
 	{USB_DEVICE (0x03f0, 0x0701)},	/* HP 53xx */
 	{USB_DEVICE (0x03f0, 0x0801)},	/* HP 7400 */
+	{USB_DEVICE (0x0638, 0x0268)},  /*iVina 1200U */
 	{USB_DEVICE (0x0638, 0x026a)},	/*Scan Dual II */
+	{USB_DEVICE (0x0638, 0x0A13)},  /*Avision AV600U */
+	{USB_DEVICE (0x0638, 0x0A16)},  /*Avision DS610CU Scancopier */
+	{USB_DEVICE (0x0638, 0x0A18)},  /*Avision AV600U Plus */
+	{USB_DEVICE (0x0638, 0x0A23)},  /*Avision AV220 */
+	{USB_DEVICE (0x0638, 0x0A24)},  /*Avision AV210 */
 	{USB_DEVICE (0x0686, 0x4004)},  /*Minolta Elite II */
 	{}			/* Terminating entry */
 };
@@ -167,7 +243,8 @@
 	int result;
 
 	INIT_LIST_HEAD (&hpusbscsi_devices);
-
+	PDEBUG(0, "driver loaded, DebugLvel=%d", debug);
+ 
 	if ((result = usb_register (&hpusbscsi_usb_driver)) < 0) {
 		printk (KERN_ERR "hpusbscsi: driver registration failed\n");
 		return -1;
@@ -210,6 +287,7 @@
 	/* What a hideous hack! */
 
 	char local_name[48];
+	spin_unlock_irq(&io_request_lock);
 
 
 	/* set up the name of our subdirectory under /proc/scsi/ */
@@ -218,6 +296,7 @@
 	/* FIXME: where is this freed ? */
 
 	if (!sht->proc_name) {
+		spin_lock_irq(&io_request_lock);
 		return 0;
 	}
 
@@ -238,6 +317,7 @@
 
 	if ( 0  >  usb_submit_urb(&desc->controlurb)) {
 		kfree(sht->proc_name);
+		spin_lock_irq(&io_request_lock);
 		return 0;
 	}
 
@@ -246,10 +326,11 @@
 	if (desc->host == NULL) {
 		kfree (sht->proc_name);
 		usb_unlink_urb(&desc->controlurb);
+		spin_lock_irq(&io_request_lock);
 		return 0;
 	}
 	desc->host->hostdata[0] = (unsigned long) desc;
-
+	spin_lock_irq(&io_request_lock);
 
 	return 1;
 }
@@ -260,15 +341,13 @@
 	usb_urb_callback usb_callback;
 	int res;
 
-	hpusbscsi->use_count++;
+	spin_unlock_irq(&io_request_lock);
 
 	/* we don't answer for anything but our single device on any faked host controller */
 	if ( srb->device->lun || srb->device->id || srb->device->channel ) {
-		if (callback) {
-			srb->result = DID_BAD_TARGET;
-			callback(srb);
-		}
-                	goto out;
+		srb->result = DID_BAD_TARGET;
+		callback(srb);
+		goto out;
 	}
 
 	/* Now we need to decide which callback to give to the urb we send the command with */
@@ -297,7 +376,7 @@
 	}
 
 
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 	if (hpusbscsi->state != HP_STATE_FREE) {
 		printk(KERN_CRIT"hpusbscsi - Ouch: queueing violation!\n");
 		return 1; /* This must not happen */
@@ -307,7 +386,7 @@
         memset(srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
 
 	hpusbscsi->state = HP_STATE_BEGINNING;
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 
 	/* We prepare the urb for writing out the scsi command */
 	FILL_BULK_URB(
@@ -321,19 +400,24 @@
 	);
 	hpusbscsi->scallback = callback;
 	hpusbscsi->srb = srb;
+	
+	if (hpusbscsi->dev == NULL) {
+		srb->result = DID_ERROR;
+		callback(srb);
+		goto out;
+	}
 
 	res = usb_submit_urb(&hpusbscsi->dataurb);
 	if (res) {
 		hpusbscsi->state = HP_STATE_FREE;
-		TRACE_STATE;
-		if (callback) {
-			srb->result = DID_ERROR;
-			callback(srb);
-		}
+		PDEBUG(2, "state= %s", states[hpusbscsi->state]);
+		srb->result = DID_ERROR;
+		callback(srb);
+
 	}
 
 out:
-	hpusbscsi->use_count--;
+	spin_lock_irq(&io_request_lock);
 	return 0;
 }
 
@@ -341,9 +425,9 @@
 {
 	struct hpusbscsi* hpusbscsi = (struct hpusbscsi*)(srb->host->hostdata[0]);
 
-	printk(KERN_DEBUG"SCSI reset requested.\n");
+	PDEBUG(1, "SCSI reset requested");
 	//usb_reset_device(hpusbscsi->dev);
-	//printk(KERN_DEBUG"SCSI reset completed.\n");
+	//PDEBUG(1, "SCSI reset completed");
 	hpusbscsi->state = HP_STATE_FREE;
 
 	return 0;
@@ -352,11 +436,14 @@
 static int hpusbscsi_scsi_abort (Scsi_Cmnd *srb)
 {
 	struct hpusbscsi* hpusbscsi = (struct hpusbscsi*)(srb->host->hostdata[0]);
-	printk(KERN_DEBUG"Request is canceled.\n");
+	PDEBUG(1, "Request is canceled");
 
+	spin_unlock_irq(&io_request_lock);
 	usb_unlink_urb(&hpusbscsi->dataurb);
 	hpusbscsi->state = HP_STATE_FREE;
 
+	spin_lock_irq(&io_request_lock);
+
 	return SCSI_ABORT_PENDING;
 }
 
@@ -376,7 +463,7 @@
 	struct hpusbscsi * hpusbscsi = (struct hpusbscsi *)u->context;
 	u8 scsi_state;
 
-DEBUG("Getting status byte %d \n",hpusbscsi->scsi_state_byte);
+	PDEBUG(1, "Getting status byte %d",hpusbscsi->scsi_state_byte);
 	if(u->status < 0) {
                 if (hpusbscsi->state != HP_STATE_FREE)
                         handle_usb_error(hpusbscsi);
@@ -402,24 +489,24 @@
 		/* we do a callback to the scsi layer if and only if all data has been transfered */
 		hpusbscsi->scallback(hpusbscsi->srb);
 
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 	switch (hpusbscsi->state) {
 	case HP_STATE_WAIT:
 		hpusbscsi->state = HP_STATE_FREE;
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 		break;
 	case HP_STATE_WORKING:
 	case HP_STATE_BEGINNING:
 		hpusbscsi->state = HP_STATE_PREMATURE;
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 		break;
 	case HP_STATE_ERROR:
 		break;
 	default:
 		printk(KERN_ERR"hpusbscsi: Unexpected status report.\n");
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 		hpusbscsi->state = HP_STATE_FREE;
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 		break;
 	}
 }
@@ -431,15 +518,15 @@
 		handle_usb_error(hpusbscsi);
 		return;
         }
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 	if (hpusbscsi->state != HP_STATE_PREMATURE) {
-	        TRACE_STATE;
+	        PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 		hpusbscsi->state = HP_STATE_WAIT;
 	} else {
 		if (hpusbscsi->scallback != NULL)
 			hpusbscsi->scallback(hpusbscsi->srb);
 		hpusbscsi->state = HP_STATE_FREE;
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 	}
 }
 
@@ -450,7 +537,7 @@
         usb_urb_callback callback;
         int res;
 
-        DEBUG("Going through scatter/gather\n");
+        PDEBUG(1, "Going through scatter/gather"); // bonzo - this gets hit a lot - maybe make it a 2
         if (u->status < 0) {
                 handle_usb_error(hpusbscsi);
                 return;
@@ -461,10 +548,10 @@
         else
                 callback = simple_done;
 
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
         if (hpusbscsi->state != HP_STATE_PREMATURE)
 		hpusbscsi->state = HP_STATE_WORKING;
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 
         FILL_BULK_URB(
                 u,
@@ -479,7 +566,7 @@
         res = usb_submit_urb(u);
         if (res)
         	handle_usb_error(hpusbscsi);
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 }
 
 static void simple_done (struct urb *u)
@@ -490,8 +577,8 @@
                 handle_usb_error(hpusbscsi);
                 return;
         }
-        DEBUG("Data transfer done\n");
-	TRACE_STATE;
+	PDEBUG(1, "Data transfer done");
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 	if (hpusbscsi->state != HP_STATE_PREMATURE) {
 		if (u->status < 0) {
 			handle_usb_error(hpusbscsi);
@@ -501,7 +588,7 @@
 			} else {
 				issue_request_sense(hpusbscsi);
 			}
-		TRACE_STATE;
+		PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 		}
 	} else {
 		if (hpusbscsi->scallback != NULL)
@@ -535,10 +622,10 @@
                 handle_usb_error(hpusbscsi);
 		return;
         }
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 	if (hpusbscsi->state != HP_STATE_PREMATURE) {
 		hpusbscsi->state = HP_STATE_WORKING;
-	TRACE_STATE;
+	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 	}
 }
 
diff -Nur linux-2.4.19.old/drivers/usb/hub.c linux-2.4.19/drivers/usb/hub.c
--- linux-2.4.19.old/drivers/usb/hub.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.19/drivers/usb/hub.c	Mon Nov 25 12:26:55 2002
@@ -155,7 +155,7 @@
 static int usb_hub_configure(struct usb_hub *hub, struct usb_endpoint_descriptor *endpoint)
 {
 	struct usb_device *dev = hub->dev;
-	struct usb_hub_status hubstatus;
+	struct usb_hub_status *hubstatus;
 	char portstr[USB_MAXCHILDREN + 1];
 	unsigned int pipe;
 	int i, maxp, ret;
@@ -258,20 +258,29 @@
 
 	dbg("port removable status: %s", portstr);
 
-	ret = usb_get_hub_status(dev, &hubstatus);
+	hubstatus = kmalloc(sizeof *hubstatus, GFP_KERNEL);
+	if (!hubstatus) {
+		err("Unable to allocate hubstatus");
+		kfree(hub->descriptor);
+		return -1;
+	}
+	ret = usb_get_hub_status(dev, hubstatus);
 	if (ret < 0) {
 		err("Unable to get hub status (err = %d)", ret);
+		kfree(hubstatus);
 		kfree(hub->descriptor);
 		return -1;
 	}
 
-	le16_to_cpus(&hubstatus.wHubStatus);
+	le16_to_cpus(&hubstatus->wHubStatus);
 
 	dbg("local power source is %s",
-		(hubstatus.wHubStatus & HUB_STATUS_LOCAL_POWER) ? "lost (inactive)" : "good");
+		(hubstatus->wHubStatus & HUB_STATUS_LOCAL_POWER) ? "lost (inactive)" : "good");
 
 	dbg("%sover-current condition exists",
-		(hubstatus.wHubStatus & HUB_STATUS_OVERCURRENT) ? "" : "no ");
+		(hubstatus->wHubStatus & HUB_STATUS_OVERCURRENT) ? "" : "no ");
+
+	kfree(hubstatus);
 
 	/* Start the interrupt endpoint */
 	pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
@@ -287,8 +296,11 @@
 		return -1;
 	}
 
-	FILL_INT_URB(hub->urb, dev, pipe, hub->buffer, maxp, hub_irq,
-		hub, endpoint->bInterval);
+	FILL_INT_URB(hub->urb, dev, pipe, hub->buffer, maxp, hub_irq, hub,
+		/* NOTE:  in 2.5 fill_int_urb() converts the encoding */
+		(dev->speed == USB_SPEED_HIGH)
+			? 1 << (endpoint->bInterval - 1)
+			: endpoint->bInterval);
 	ret = usb_submit_urb(hub->urb);
 	if (ret) {
 		err("usb_submit_urb failed (%d)", ret);
@@ -666,7 +678,6 @@
 	struct usb_device *dev;
 	unsigned int delay = HUB_SHORT_RESET_TIME;
 	int i;
-	char *portstr, *tempstr;
 
 	dbg("port %d, portstatus %x, change %x, %s",
 		port + 1, portstatus, portchange, portspeed (portstatus));
@@ -694,11 +705,9 @@
 
 	down(&usb_address0_sem);
 
-	tempstr = kmalloc(1024, GFP_KERNEL);
-	portstr = kmalloc(1024, GFP_KERNEL);
-
 	for (i = 0; i < HUB_PROBE_TRIES; i++) {
-		struct usb_device *pdev, *cdev;
+		struct usb_device *pdev;
+		int len;
 
 		/* Allocate a new device struct */
 		dev = usb_alloc_dev(hub, hub->bus);
@@ -728,32 +737,28 @@
 			dev->ttport = port + 1;
 		}
 
-		/* Create a readable topology string */
-		cdev = dev;
+		/* Save readable and stable topology id, distinguishing
+		 * devices by location for diagnostics, tools, etc.  The
+		 * string is a path along hub ports, from the root.  Each
+		 * device's id will be stable until USB is re-cabled, and
+		 * hubs are often labeled with these port numbers.
+		 *
+		 * Initial size: ".NN" times five hubs + NUL = 16 bytes max
+		 * (quite rare, since most hubs have 4-6 ports).
+		 */
 		pdev = dev->parent;
-		if (portstr && tempstr) {
-			portstr[0] = 0;
-			while (pdev) {
-				int port;
-
-				for (port = 0; port < pdev->maxchild; port++)
-					if (pdev->children[port] == cdev)
-						break;
-
-				strcpy(tempstr, portstr);
-				if (!strlen(tempstr))
-					sprintf(portstr, "%d", port + 1);
-				else
-					sprintf(portstr, "%d/%s", port + 1, tempstr);
-
-				cdev = pdev;
-				pdev = pdev->parent;
-			}
-			info("USB new device connect on bus%d/%s, assigned device number %d",
-				dev->bus->busnum, portstr, dev->devnum);
-		} else
-			info("USB new device connect on bus%d, assigned device number %d",
-				dev->bus->busnum, dev->devnum);
+		if (pdev->devpath [0] != '0')	/* parent not root? */
+			len = snprintf (dev->devpath, sizeof dev->devpath,
+				"%s.%d", pdev->devpath, port + 1);
+		/* root == "0", root port 2 == "2", port 3 that hub "2.3" */
+		else
+			len = snprintf (dev->devpath, sizeof dev->devpath,
+				"%d", port + 1);
+		if (len == sizeof dev->devpath)
+			warn ("devpath size! usb/%03d/%03d path %s",
+				dev->bus->busnum, dev->devnum, dev->devpath);
+		info("new USB device %s-%s, assigned address %d",
+			dev->bus->bus_name, dev->devpath, dev->devnum);
 
 		/* Run it through the hoops (find a driver, etc) */
 		if (!usb_new_device(dev))
@@ -770,10 +775,6 @@
 	usb_hub_port_disable(hub, port);
 done:
 	up(&usb_address0_sem);
-	if (portstr)
-		kfree(portstr);
-	if (tempstr)
-		kfree(tempstr);
 }
 
 static void usb_hub_events(void)
@@ -782,7 +783,7 @@
 	struct list_head *tmp;
 	struct usb_device *dev;
 	struct usb_hub *hub;
-	struct usb_hub_status hubsts;
+	struct usb_hub_status *hubsts;
 	u16 hubstatus;
 	u16 hubchange;
 	u16 portstatus;
@@ -872,21 +873,27 @@
 		} /* end for i */
 
 		/* deal with hub status changes */
-		if (usb_get_hub_status(dev, &hubsts) < 0)
-			err("get_hub_status failed");
-		else {
-			hubstatus = le16_to_cpup(&hubsts.wHubStatus);
-			hubchange = le16_to_cpup(&hubsts.wHubChange);
-			if (hubchange & HUB_CHANGE_LOCAL_POWER) {
-				dbg("hub power change");
-				usb_clear_hub_feature(dev, C_HUB_LOCAL_POWER);
-			}
-			if (hubchange & HUB_CHANGE_OVERCURRENT) {
-				dbg("hub overcurrent change");
-				wait_ms(500);	/* Cool down */
-				usb_clear_hub_feature(dev, C_HUB_OVER_CURRENT);
-                        	usb_hub_power_on(hub);
+		hubsts = kmalloc(sizeof *hubsts, GFP_KERNEL);
+		if (!hubsts) {
+			err("couldn't allocate hubsts");
+		} else {
+			if (usb_get_hub_status(dev, hubsts) < 0)
+				err("get_hub_status failed");
+			else {
+				hubstatus = le16_to_cpup(&hubsts->wHubStatus);
+				hubchange = le16_to_cpup(&hubsts->wHubChange);
+				if (hubchange & HUB_CHANGE_LOCAL_POWER) {
+					dbg("hub power change");
+					usb_clear_hub_feature(dev, C_HUB_LOCAL_POWER);
+				}
+				if (hubchange & HUB_CHANGE_OVERCURRENT) {
+					dbg("hub overcurrent change");
+					wait_ms(500);	/* Cool down */
+					usb_clear_hub_feature(dev, C_HUB_OVER_CURRENT);
+					usb_hub_power_on(hub);
+				}
 			}
+			kfree(hubsts);
 		}
 		up(&hub->khubd_sem);
         } /* end while (1) */
@@ -995,7 +1002,7 @@
 int usb_reset_device(struct usb_device *dev)
 {
 	struct usb_device *parent = dev->parent;
-	struct usb_device_descriptor descriptor;
+	struct usb_device_descriptor *descriptor;
 	int i, ret, port = -1;
 
 	if (!parent) {
@@ -1044,17 +1051,22 @@
 	 * If nothing changed, we reprogram the configuration and then
 	 * the alternate settings.
 	 */
-	ret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, &descriptor,
-			sizeof(descriptor));
+	descriptor = kmalloc(sizeof *descriptor, GFP_NOIO);
+	if (!descriptor) {
+		return -ENOMEM;
+	}
+	ret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, descriptor,
+			sizeof(*descriptor));
 	if (ret < 0)
 		return ret;
 
-	le16_to_cpus(&descriptor.bcdUSB);
-	le16_to_cpus(&descriptor.idVendor);
-	le16_to_cpus(&descriptor.idProduct);
-	le16_to_cpus(&descriptor.bcdDevice);
+	le16_to_cpus(&descriptor->bcdUSB);
+	le16_to_cpus(&descriptor->idVendor);
+	le16_to_cpus(&descriptor->idProduct);
+	le16_to_cpus(&descriptor->bcdDevice);
 
-	if (memcmp(&dev->descriptor, &descriptor, sizeof(descriptor))) {
+	if (memcmp(&dev->descriptor, descriptor, sizeof(*descriptor))) {
+		kfree(descriptor);
 		usb_destroy_configuration(dev);
 
 		ret = usb_get_device_descriptor(dev);
@@ -1084,6 +1096,8 @@
 		return 1;
 	}
 
+	kfree(descriptor);
+
 	ret = usb_set_configuration(dev, dev->actconfig->bConfigurationValue);
 	if (ret < 0) {
 		err("failed to set active configuration (error=%d)", ret);
diff -Nur linux-2.4.19.old/drivers/usb/inode.c linux-2.4.19/drivers/usb/inode.c
--- linux-2.4.19.old/drivers/usb/inode.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/inode.c	Mon Nov 25 12:26:55 2002
@@ -628,6 +628,7 @@
         s->s_root = d_alloc_root(root_inode);
         if (!s->s_root)
                 goto out_no_root;
+	lock_kernel();
 	list_add_tail(&s->u.usbdevfs_sb.slist, &superlist);
 	for (i = 0; i < NRSPECIAL; i++) {
 		if (!(inode = iget(s, IROOT+1+i)))
@@ -646,6 +647,7 @@
 		recurse_new_dev_inode(bus->root_hub, s);
 	}
 	up (&usb_bus_list_lock);
+	unlock_kernel();
         return s;
 
  out_no_root:
diff -Nur linux-2.4.19.old/drivers/usb/kaweth.c linux-2.4.19/drivers/usb/kaweth.c
--- linux-2.4.19.old/drivers/usb/kaweth.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/kaweth.c	Mon Nov 25 12:26:55 2002
@@ -5,17 +5,18 @@
  *     (c) 2000 Interlan Communications
  *     (c) 2000 Stephane Alnet
  *     (C) 2001 Brad Hards
+ *     (C) 2002 Oliver Neukum
  *
  *     Original author: The Zapman <zapman@interlan.net>
- *     Inspired by, and much credit goes to Michael Rothwell 
+ *     Inspired by, and much credit goes to Michael Rothwell
  *     <rothwell@interlan.net> for the test equipment, help, and patience
  *     Based off of (and with thanks to) Petko Manolov's pegaus.c driver.
- *     Also many thanks to Joel Silverman and Ed Surprenant at Kawasaki 
+ *     Also many thanks to Joel Silverman and Ed Surprenant at Kawasaki
  *     for providing the firmware and driver resources.
  *
  *     This program is free software; you can redistribute it and/or
  *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2, or 
+ *     published by the Free Software Foundation; either version 2, or
  *     (at your option) any later version.
  *
  *     This program is distributed in the hope that it will be useful,
@@ -25,7 +26,7 @@
  *
  *     You should have received a copy of the GNU General Public License
  *     along with this program; if not, write to the Free Software Foundation,
- *     Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ *     Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  ****************************************************************/
 
@@ -36,8 +37,8 @@
  * Fix bugs from previous two steps
  * Snoop other OSs for any tricks we're not doing
  * SMP locking
- * Reduce arbitrary timeouts 
- * Smart multicast support 
+ * Reduce arbitrary timeouts
+ * Smart multicast support
  * Temporary MAC change support
  * Tunable SOFs parameter - ioctl()?
  * Ethernet stats collection
@@ -54,7 +55,10 @@
 #include <linux/etherdevice.h>
 #include <linux/usb.h>
 #include <linux/types.h>
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
 #include <asm/semaphore.h>
+#include <asm/byteorder.h>
 
 #define DEBUG
 
@@ -73,6 +77,7 @@
 #define KAWETH_MTU			1514
 #define KAWETH_BUF_SIZE			1664
 #define KAWETH_TX_TIMEOUT		(5 * HZ)
+#define KAWETH_SCRATCH_SIZE		32
 #define KAWETH_FIRMWARE_BUF_SIZE	4096
 #define KAWETH_CONTROL_TIMEOUT		(30 * HZ)
 
@@ -98,8 +103,14 @@
 
 #define KAWETH_SOFS_TO_WAIT			0x05
 
+#define INTBUFFERSIZE				4
 
-MODULE_AUTHOR("Michael Zappe <zapman@interlan.net>, Stephane Alnet <stephane@u-picardie.fr> and Brad Hards <bhards@bigpond.net.au>");
+#define STATE_OFFSET				0
+#define STATE_MASK				0x40
+#define	STATE_SHIFT				5
+
+
+MODULE_AUTHOR("Michael Zappe <zapman@interlan.net>, Stephane Alnet <stephane@u-picardie.fr>, Brad Hards <bhards@bigpond.net.au> and Oliver Neukum <oliver@neukum.org>");
 MODULE_DESCRIPTION("KL5USB101 USB Ethernet driver");
 MODULE_LICENSE("GPL");
 
@@ -110,28 +121,28 @@
 	);
 static void kaweth_disconnect(struct usb_device *dev, void *ptr);
 int kaweth_internal_control_msg(struct usb_device *usb_dev, unsigned int pipe,
-				devrequest *cmd, void *data, int len,
-				int timeout);
+				struct usb_ctrlrequest *cmd, void *data,
+				int len, int timeout);
 
 /****************************************************************
  *     usb_device_id
  ****************************************************************/
 static struct usb_device_id usb_klsi_table[] = {
-	{ USB_DEVICE(0x03e8, 0x0008) }, /* AOX Endpoints USB Ethernet */ 
+	{ USB_DEVICE(0x03e8, 0x0008) }, /* AOX Endpoints USB Ethernet */
 	{ USB_DEVICE(0x04bb, 0x0901) }, /* I-O DATA USB-ET/T */
-	{ USB_DEVICE(0x0506, 0x03e8) }, /* 3Com 3C19250 */ 
-	{ USB_DEVICE(0x0557, 0x2002) }, /* ATEN USB Ethernet */ 
-	{ USB_DEVICE(0x0557, 0x4000) }, /* D-Link DSB-650C */ 
+	{ USB_DEVICE(0x0506, 0x03e8) }, /* 3Com 3C19250 */
+	{ USB_DEVICE(0x0557, 0x2002) }, /* ATEN USB Ethernet */
+	{ USB_DEVICE(0x0557, 0x4000) }, /* D-Link DSB-650C */
 	{ USB_DEVICE(0x0565, 0x0002) }, /* Peracom Enet */
 	{ USB_DEVICE(0x0565, 0x0003) }, /* Optus@Home UEP1045A */
-	{ USB_DEVICE(0x0565, 0x0005) }, /* Peracom Enet2 */ 
+	{ USB_DEVICE(0x0565, 0x0005) }, /* Peracom Enet2 */
 	{ USB_DEVICE(0x05e9, 0x0008) }, /* KLSI KL5KUSB101B */
 	{ USB_DEVICE(0x05e9, 0x0009) }, /* KLSI KL5KUSB101B (Board change) */
-	{ USB_DEVICE(0x066b, 0x2202) }, /* Linksys USB10T */ 
-	{ USB_DEVICE(0x06e1, 0x0008) }, /* ADS USB-10BT */ 
-	{ USB_DEVICE(0x06e1, 0x0009) }, /* ADS USB-10BT */ 
-	{ USB_DEVICE(0x0707, 0x0100) }, /* SMC 2202USB */ 
-	{ USB_DEVICE(0x07aa, 0x0001) }, /* Correga K.K. */ 
+	{ USB_DEVICE(0x066b, 0x2202) }, /* Linksys USB10T */
+	{ USB_DEVICE(0x06e1, 0x0008) }, /* ADS USB-10BT */
+	{ USB_DEVICE(0x06e1, 0x0009) }, /* ADS USB-10BT */
+	{ USB_DEVICE(0x0707, 0x0100) }, /* SMC 2202USB */
+	{ USB_DEVICE(0x07aa, 0x0001) }, /* Correga K.K. */
 	{ USB_DEVICE(0x07b8, 0x4000) }, /* D-Link DU-E10 */
 	{ USB_DEVICE(0x0846, 0x1001) }, /* NetGear EA-101 */
 	{ USB_DEVICE(0x0846, 0x1002) }, /* NetGear EA-101 */
@@ -143,9 +154,10 @@
 	{ USB_DEVICE(0x10bd, 0x1427) }, /* ASANTE USB To Ethernet Adapter */
 	{ USB_DEVICE(0x1342, 0x0204) }, /* Mobility USB-Ethernet Adapter */
 	{ USB_DEVICE(0x13d2, 0x0400) }, /* Shark Pocket Adapter */
-	{ USB_DEVICE(0x1645, 0x0005) }, /* Entrega E45 */ 
-	{ USB_DEVICE(0x1645, 0x0008) }, /* Entrega USB Ethernet Adapter */ 
-	{ USB_DEVICE(0x1645, 0x8005) }, /* PortGear Ethernet Adapter */ 
+	{ USB_DEVICE(0x1485, 0x0001) },	/* Silicom U2E */
+	{ USB_DEVICE(0x1645, 0x0005) }, /* Entrega E45 */
+	{ USB_DEVICE(0x1645, 0x0008) }, /* Entrega USB Ethernet Adapter */
+	{ USB_DEVICE(0x1645, 0x8005) }, /* PortGear Ethernet Adapter */
 	{ USB_DEVICE(0x2001, 0x4000) }, /* D-link DSB-650C */
 	{} /* Null terminator */
 };
@@ -156,10 +168,10 @@
  *     kaweth_driver
  ****************************************************************/
 static struct usb_driver kaweth_driver = {
-	name:		"kaweth",
-	probe:		kaweth_probe,
-	disconnect:	kaweth_disconnect,
-	id_table:       usb_klsi_table,
+	.name =		"kaweth",
+	.probe =	kaweth_probe,
+	.disconnect =	kaweth_disconnect,
+	.id_table =     usb_klsi_table,
 };
 
 typedef __u8 eth_addr_t[6];
@@ -198,17 +210,25 @@
 	spinlock_t device_lock;
 
 	__u32 status;
+	int end;
+	int removed;
+	int suspend_lowmem;
+	int linkstate;
 
 	struct usb_device *dev;
 	struct net_device *net;
-	wait_queue_head_t control_wait;
+	wait_queue_head_t term_wait;
 
 	struct urb *rx_urb;
 	struct urb *tx_urb;
+	struct urb *irq_urb;
 	
-	__u8 firmware_buf[KAWETH_FIRMWARE_BUF_SIZE];
-	__u8 tx_buf[KAWETH_BUF_SIZE];
+	struct sk_buff *tx_skb;
+
+	__u8 *firmware_buf;
+	__u8 scratch[KAWETH_SCRATCH_SIZE];
 	__u8 rx_buf[KAWETH_BUF_SIZE];
+	__u8 intbuffer[INTBUFFERSIZE];
 	__u16 packet_filter_bitmap;
 
 	struct kaweth_ethernet_configuration configuration;
@@ -221,16 +241,16 @@
  *     kaweth_control
  ****************************************************************/
 static int kaweth_control(struct kaweth_device *kaweth,
-			  unsigned int pipe, 
-			  __u8 request, 
-			  __u8 requesttype, 
-			  __u16 value, 
+			  unsigned int pipe,
+			  __u8 request,
+			  __u8 requesttype,
+			  __u16 value,
 			  __u16 index,
-			  void *data, 
-			  __u16 size, 
+			  void *data,
+			  __u16 size,
 			  int timeout)
 {
-	devrequest *dr;
+	struct usb_ctrlrequest *dr;
 
 	kaweth_dbg("kaweth_control()");
 
@@ -239,19 +259,18 @@
 		return -EBUSY;
 	}
 
-	dr = kmalloc(sizeof(devrequest), GFP_ATOMIC);
+	dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);
 
-	if(!dr)
-	{
+	if (!dr) {
 		kaweth_dbg("kmalloc() failed");
 		return -ENOMEM;
 	}
-	
-	dr->requesttype = requesttype;
-	dr->request = request;
-	dr->value = cpu_to_le16p(&value);
-	dr->index = cpu_to_le16p(&index);
-	dr->length = cpu_to_le16p(&size);
+
+	dr->bRequestType= requesttype;
+	dr->bRequest = request;
+	dr->wValue = cpu_to_le16p(&value);
+	dr->wIndex = cpu_to_le16p(&index);
+	dr->wLength = cpu_to_le16p(&size);
 
 	return kaweth_internal_control_msg(kaweth->dev,
 					pipe,
@@ -298,7 +317,7 @@
 				USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
 				urb_size,
 				0,
-				(void *)&kaweth->firmware_buf,
+				(void *)&kaweth->scratch,
 				0,
 				KAWETH_CONTROL_TIMEOUT);
 
@@ -320,7 +339,7 @@
 				USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
 				sofs_wait,
 				0,
-				(void *)&kaweth->firmware_buf,
+				(void *)&kaweth->scratch,
 				0,
 				KAWETH_CONTROL_TIMEOUT);
 
@@ -343,7 +362,7 @@
 				USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
 				receive_filter,
 				0,
-				(void *)&kaweth->firmware_buf,
+				(void *)&kaweth->scratch,
 				0,
 				KAWETH_CONTROL_TIMEOUT);
 
@@ -353,19 +372,19 @@
 /****************************************************************
  *     kaweth_download_firmware
  ****************************************************************/
-static int kaweth_download_firmware(struct kaweth_device *kaweth, 
-				    __u8 *data, 
+static int kaweth_download_firmware(struct kaweth_device *kaweth,
+				    __u8 *data,
 				    __u16 data_len,
 				    __u8 interrupt,
 				    __u8 type)
-{	
+{
 	if(data_len > KAWETH_FIRMWARE_BUF_SIZE)	{
 		kaweth_err("Firmware too big: %d", data_len);
 		return -ENOSPC;
 	}
-	
+
 	memcpy(kaweth->firmware_buf, data, data_len);
-	
+
 	kaweth->firmware_buf[2] = (data_len & 0xFF) - 7;
 	kaweth->firmware_buf[3] = data_len >> 8;
 	kaweth->firmware_buf[4] = type;
@@ -374,8 +393,8 @@
 	kaweth_dbg("High: %i, Low:%i", kaweth->firmware_buf[3],
 		   kaweth->firmware_buf[2]);
 
-	kaweth_dbg("Downloading firmware at %p to kaweth device at %p", 
-	    data, 
+	kaweth_dbg("Downloading firmware at %p to kaweth device at %p",
+	    data,
 	    kaweth);
 	kaweth_dbg("Firmware length: %d", data_len);
 
@@ -385,7 +404,7 @@
 			      USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
 			      0,
 			      0,
-			      (void *)&kaweth->firmware_buf,
+			      (void *)kaweth->firmware_buf,
 			      data_len,
 			      KAWETH_CONTROL_TIMEOUT);
 }
@@ -404,7 +423,7 @@
 	kaweth->firmware_buf[5] = interrupt;
 	kaweth->firmware_buf[6] = 0x00;
 	kaweth->firmware_buf[7] = 0x00;
-	
+
 	kaweth_dbg("Triggering firmware");
 
 	return kaweth_control(kaweth,
@@ -413,7 +432,7 @@
 			      USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
 			      0,
 			      0,
-			      (void *)&kaweth->firmware_buf,
+			      (void *)kaweth->firmware_buf,
 			      8,
 			      KAWETH_CONTROL_TIMEOUT);
 }
@@ -428,12 +447,12 @@
 	kaweth_dbg("kaweth_reset(%p)", kaweth);
 	result = kaweth_control(kaweth,
 				usb_sndctrlpipe(kaweth->dev, 0),
-				USB_REQ_SET_CONFIGURATION, 
-				0, 
+				USB_REQ_SET_CONFIGURATION,
+				0,
 				kaweth->dev->config[0].bConfigurationValue,
-				0, 
-				NULL, 
-				0, 
+				0,
+				NULL,
+				0,
 				KAWETH_CONTROL_TIMEOUT);
 
 	udelay(10000);
@@ -444,15 +463,39 @@
 }
 
 static void kaweth_usb_receive(struct urb *);
+static void kaweth_resubmit_rx_urb(struct kaweth_device *);
+
+/****************************************************************
+	int_callback
+*****************************************************************/
+static void int_callback(struct urb *u)
+{
+	struct kaweth_device *kaweth = u->context;
+	int act_state;
+
+	/* we abuse the interrupt urb for rebsubmitting under low memory saving a timer */
+	if (kaweth->suspend_lowmem)
+		kaweth_resubmit_rx_urb(kaweth);
+
+	/* we check the link state to report changes */
+	if (kaweth->linkstate != (act_state = ( kaweth->intbuffer[STATE_OFFSET] | STATE_MASK) >> STATE_SHIFT)) {
+		if (!act_state)
+			netif_carrier_on(kaweth->net);
+		else
+			netif_carrier_off(kaweth->net);
+
+		kaweth->linkstate = act_state;
+	}
+
+}
 
 /****************************************************************
  *     kaweth_resubmit_rx_urb
  ****************************************************************/
-static inline void kaweth_resubmit_rx_urb(struct kaweth_device *kaweth)
+static void kaweth_resubmit_rx_urb(struct kaweth_device *kaweth)
 {
 	int result;
-
-	memset(kaweth->rx_urb, 0, sizeof(*kaweth->rx_urb));
+	long flags;
 
 	FILL_BULK_URB(kaweth->rx_urb,
 		      kaweth->dev,
@@ -462,9 +505,17 @@
 		      kaweth_usb_receive,
 		      kaweth);
 
-	if((result = usb_submit_urb(kaweth->rx_urb))) {
-		kaweth_err("resubmitting rx_urb %d failed", result);
+	spin_lock_irqsave(&kaweth->device_lock, flags);
+	if (!kaweth->removed) { /* no resubmit if disconnecting */
+		if((result = usb_submit_urb(kaweth->rx_urb))) {
+			if (result == -ENOMEM)
+				kaweth->suspend_lowmem = 1;
+			kaweth_err("resubmitting rx_urb %d failed", result);
+		} else {
+			kaweth->suspend_lowmem = 0;
+		}
 	}
+	spin_unlock_irqrestore(&kaweth->device_lock, flags);
 }
 
 static void kaweth_async_set_rx_mode(struct kaweth_device *kaweth);
@@ -476,23 +527,30 @@
 {
 	struct kaweth_device *kaweth = urb->context;
 	struct net_device *net = kaweth->net;
-	
+
 	int count = urb->actual_length;
 	int count2 = urb->transfer_buffer_length;
-			
+
 	__u16 pkt_len = le16_to_cpup((u16 *)kaweth->rx_buf);
 
 	struct sk_buff *skb;
 
-	if(kaweth->status & KAWETH_STATUS_CLOSING) {
+	if(urb->status == -ECONNRESET || urb->status == -ECONNABORTED)
+	/* we are killed - set a flag and wake the disconnect handler */
+	{
+		kaweth->end = 1;
+		wake_up(&kaweth->term_wait);
 		return;
 	}
-	
-	if(urb->status && urb->status != -EREMOTEIO && count != 1) { 
+
+	if (kaweth->status & KAWETH_STATUS_CLOSING)
+		return;
+
+	if(urb->status && urb->status != -EREMOTEIO && count != 1) {
 		kaweth_err("%s RX status: %d count: %d packet_len: %d",
-                           net->name, 
+                           net->name,
 			   urb->status,
-			   count, 
+			   count,
 			   (int)pkt_len);
 		kaweth_resubmit_rx_urb(kaweth);
                 return;
@@ -506,22 +564,24 @@
 		        kaweth_resubmit_rx_urb(kaweth);
                         return;
                 }
-		
+
 		if(!(skb = dev_alloc_skb(pkt_len+2))) {
 		        kaweth_resubmit_rx_urb(kaweth);
                         return;
 		}
 
+		skb_reserve(skb, 2);    /* Align IP on 16 byte boundaries */
+
 		skb->dev = net;
 
 		eth_copy_and_sum(skb, kaweth->rx_buf + 2, pkt_len, 0);
-		
+
 		skb_put(skb, pkt_len);
 
 		skb->protocol = eth_type_trans(skb, net);
-		
+
 		netif_rx(skb);
-		
+
 		kaweth->stats.rx_packets++;
 		kaweth->stats.rx_bytes += pkt_len;
 	}
@@ -540,11 +600,23 @@
 
 	kaweth_dbg("Opening network device.");
 
+	MOD_INC_USE_COUNT;
+
 	kaweth_resubmit_rx_urb(kaweth);
 
-	netif_start_queue(net);
+	FILL_INT_URB(
+		kaweth->irq_urb,
+		kaweth->dev,
+		usb_rcvintpipe(kaweth->dev, 3),
+		kaweth->intbuffer,
+		INTBUFFERSIZE,
+		int_callback,
+		kaweth,
+		HZ/4);
 
-	MOD_INC_USE_COUNT;
+	usb_submit_urb(kaweth->irq_urb);
+
+	netif_start_queue(net);
 
 	kaweth_async_set_rx_mode(kaweth);
 	return 0;
@@ -558,9 +630,12 @@
 	struct kaweth_device *kaweth = net->priv;
 
 	netif_stop_queue(net);
-
+	
+	spin_lock_irq(&kaweth->device_lock);
 	kaweth->status |= KAWETH_STATUS_CLOSING;
+	spin_unlock_irq(&kaweth->device_lock);
 
+	usb_unlink_urb(kaweth->irq_urb);
 	usb_unlink_urb(kaweth->rx_urb);
 
 	kaweth->status &= ~KAWETH_STATUS_CLOSING;
@@ -572,11 +647,35 @@
 	return 0;
 }
 
+static int netdev_ethtool_ioctl(struct net_device *dev, void *useraddr)
+{
+	u32 ethcmd;
+	
+	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
+		return -EFAULT;
+	
+	switch (ethcmd) {
+	case ETHTOOL_GDRVINFO: {
+		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
+		strncpy(info.driver, "kaweth", sizeof(info.driver)-1);
+		if (copy_to_user(useraddr, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+	}
+	
+	return -EOPNOTSUPP;
+}
+
 /****************************************************************
  *     kaweth_ioctl
  ****************************************************************/
 static int kaweth_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
 {
+	switch (cmd) {
+	case SIOCETHTOOL:
+		return netdev_ethtool_ioctl(net, (void *) rq->ifr_data);
+	}
 	return -EOPNOTSUPP;
 }
 
@@ -586,11 +685,13 @@
 static void kaweth_usb_transmit_complete(struct urb *urb)
 {
 	struct kaweth_device *kaweth = urb->context;
+	struct sk_buff *skb = kaweth->tx_skb;
 
-	if (urb->status)
+	if (urb->status != 0)
 		kaweth_dbg("%s: TX status %d.", kaweth->net->name, urb->status);
 
 	netif_wake_queue(kaweth->net);
+	dev_kfree_skb(skb);
 }
 
 /****************************************************************
@@ -599,45 +700,66 @@
 static int kaweth_start_xmit(struct sk_buff *skb, struct net_device *net)
 {
 	struct kaweth_device *kaweth = net->priv;
-	int count = skb->len;
-	
+	char *private_header;
+
 	int res;
 
 	spin_lock(&kaweth->device_lock);
 
+	if (kaweth->removed) {
+	/* our device is undergoing disconnection - we bail out */
+		spin_unlock(&kaweth->device_lock);
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
 	kaweth_async_set_rx_mode(kaweth);
 	netif_stop_queue(net);
 
-	*((__u16 *)kaweth->tx_buf) = cpu_to_le16(skb->len);
-
-	memcpy(kaweth->tx_buf + 2, skb->data, skb->len);
+	/* We now decide whether we can put our special header into the sk_buff */
+	if (skb_cloned(skb) || skb_headroom(skb) < 2) {
+		/* no such luck - we make our own */
+		struct sk_buff *copied_skb;
+		copied_skb = skb_copy_expand(skb, 2, 0, GFP_ATOMIC);
+		dev_kfree_skb_any(skb);
+		skb = copied_skb;
+		if (!copied_skb) {
+			kaweth->stats.tx_errors++;
+			netif_start_queue(net);
+			spin_unlock(&kaweth->device_lock);
+			return 0;
+		}
+	}
 
-	memset(kaweth->tx_urb, 0, sizeof(*kaweth->tx_urb));
+	private_header = __skb_push(skb, 2);
+	*private_header = cpu_to_le16(skb->len);
+	kaweth->tx_skb = skb;
 
 	FILL_BULK_URB(kaweth->tx_urb,
 		      kaweth->dev,
 		      usb_sndbulkpipe(kaweth->dev, 2),
-		      kaweth->tx_buf,
-		      count + 2,
+		      private_header,
+		      skb->len,
 		      kaweth_usb_transmit_complete,
 		      kaweth);
+	kaweth->end = 0;
+	kaweth->tx_urb->transfer_flags |= USB_ASYNC_UNLINK;
 
 	if((res = usb_submit_urb(kaweth->tx_urb)))
 	{
 		kaweth_warn("kaweth failed tx_urb %d", res);
 		kaweth->stats.tx_errors++;
-		
+
 		netif_start_queue(net);
-	} 
-	else 
+		dev_kfree_skb(skb);
+	}
+	else
 	{
 		kaweth->stats.tx_packets++;
 		kaweth->stats.tx_bytes += skb->len;
 		net->trans_start = jiffies;
 	}
 
-	dev_kfree_skb(skb);
-
 	spin_unlock(&kaweth->device_lock);
 
 	return 0;
@@ -649,7 +771,7 @@
 static void kaweth_set_rx_mode(struct net_device *net)
 {
 	struct kaweth_device *kaweth = net->priv;
-	
+
 	__u16 packet_filter_bitmap = KAWETH_PACKET_FILTER_DIRECTED |
                                      KAWETH_PACKET_FILTER_BROADCAST |
 		                     KAWETH_PACKET_FILTER_MULTICAST;
@@ -660,7 +782,7 @@
 
 	if (net->flags & IFF_PROMISC) {
 		packet_filter_bitmap |= KAWETH_PACKET_FILTER_PROMISCUOUS;
-	} 
+	}
 	else if ((net->mc_count) || (net->flags & IFF_ALLMULTI)) {
 		packet_filter_bitmap |= KAWETH_PACKET_FILTER_ALL_MULTICAST;
 	}
@@ -675,7 +797,7 @@
 static void kaweth_async_set_rx_mode(struct kaweth_device *kaweth)
 {
 	__u16 packet_filter_bitmap = kaweth->packet_filter_bitmap;
-	kaweth->packet_filter_bitmap = 0;	
+	kaweth->packet_filter_bitmap = 0;
 	if(packet_filter_bitmap == 0) return;
 
 	{
@@ -686,7 +808,7 @@
 				USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
 				packet_filter_bitmap,
 				0,
-				(void *)&kaweth->firmware_buf,
+				(void *)&kaweth->scratch,
 				0,
 				KAWETH_CONTROL_TIMEOUT);
 
@@ -718,7 +840,6 @@
 	kaweth->stats.tx_errors++;
 	net->trans_start = jiffies;
 
-	kaweth->tx_urb->transfer_flags |= USB_ASYNC_UNLINK;
 	usb_unlink_urb(kaweth->tx_urb);
 }
 
@@ -736,14 +857,14 @@
 	int result = 0;
 
 	kaweth_dbg("Kawasaki Device Probe (Device number:%d): 0x%4.4x:0x%4.4x:0x%4.4x",
-		 dev->devnum, 
-		 (int)dev->descriptor.idVendor, 
+		 dev->devnum,
+		 (int)dev->descriptor.idVendor,
 		 (int)dev->descriptor.idProduct,
 		 (int)dev->descriptor.bcdDevice);
 
 	kaweth_dbg("Device at %p", dev);
 
-	kaweth_dbg("Descriptor length: %x type: %x", 
+	kaweth_dbg("Descriptor length: %x type: %x",
 		 (int)dev->descriptor.bLength,
 		 (int)dev->descriptor.bDescriptorType);
 
@@ -755,10 +876,9 @@
 	memset(kaweth, 0, sizeof(struct kaweth_device));
 
 	kaweth->dev = dev;
-	kaweth->status = 0;
-	kaweth->net = NULL;
-	kaweth->device_lock = SPIN_LOCK_UNLOCKED;
-		
+	spin_lock_init(&kaweth->device_lock);
+	init_waitqueue_head(&kaweth->term_wait);
+
 	kaweth_dbg("Resetting.");
 
 	kaweth_reset(kaweth);
@@ -773,22 +893,25 @@
 	} else {
 		/* Download the firmware */
 		kaweth_info("Downloading firmware...");
-		if ((result = kaweth_download_firmware(kaweth, 
-						      kaweth_new_code, 
-						      len_kaweth_new_code, 
-						      100, 
+		kaweth->firmware_buf = (__u8 *)__get_free_page(GFP_KERNEL);
+		if ((result = kaweth_download_firmware(kaweth,
+						      kaweth_new_code,
+						      len_kaweth_new_code,
+						      100,
 						      2)) < 0) {
 			kaweth_err("Error downloading firmware (%d)", result);
+			free_page((unsigned long)kaweth->firmware_buf);
 			kfree(kaweth);
 			return NULL;
 		}
 
-		if ((result = kaweth_download_firmware(kaweth, 
-						      kaweth_new_code_fix, 
-						      len_kaweth_new_code_fix, 
-						      100, 
+		if ((result = kaweth_download_firmware(kaweth,
+						      kaweth_new_code_fix,
+						      len_kaweth_new_code_fix,
+						      100,
 						      3)) < 0) {
 			kaweth_err("Error downloading firmware fix (%d)", result);
+			free_page((unsigned long)kaweth->firmware_buf);
 			kfree(kaweth);
 			return NULL;
 		}
@@ -799,6 +922,7 @@
 						      126,
 						      2)) < 0) {
 			kaweth_err("Error downloading trigger code (%d)", result);
+			free_page((unsigned long)kaweth->firmware_buf);
 			kfree(kaweth);
 			return NULL;
 		}
@@ -809,6 +933,7 @@
 						      126,
 						      3)) < 0) {
 			kaweth_err("Error downloading trigger code fix (%d)", result);
+			free_page((unsigned long)kaweth->firmware_buf);
 			kfree(kaweth);
 			return NULL;
 		}
@@ -816,12 +941,14 @@
 
 		if ((result = kaweth_trigger_firmware(kaweth, 126)) < 0) {
 			kaweth_err("Error triggering firmware (%d)", result);
+			free_page((unsigned long)kaweth->firmware_buf);
 			kfree(kaweth);
 			return NULL;
 		}
 
 		/* Device will now disappear for a moment...  */
 		kaweth_info("Firmware loaded.  I'll be back...");
+		free_page((unsigned long)kaweth->firmware_buf);
 		kfree(kaweth);
 		return NULL;
 	}
@@ -846,7 +973,7 @@
 		 (int)kaweth->configuration.hw_addr[5]);
 
 	if(!memcmp(&kaweth->configuration.hw_addr,
-                   &bcast_addr, 
+                   &bcast_addr,
 		   sizeof(bcast_addr))) {
 		kaweth_err("Firmware not functioning properly, no net device created");
 		kfree(kaweth);
@@ -857,13 +984,13 @@
 		kaweth_dbg("Error setting URB size");
 		return kaweth;
 	}
-	
+
 	if(kaweth_set_sofs_wait(kaweth, KAWETH_SOFS_TO_WAIT) < 0) {
 		kaweth_err("Error setting SOFS wait");
 		return kaweth;
 	}
 
-	result = kaweth_set_receive_filter(kaweth, 
+	result = kaweth_set_receive_filter(kaweth,
                                            KAWETH_PACKET_FILTER_DIRECTED |
                                            KAWETH_PACKET_FILTER_BROADCAST |
                                            KAWETH_PACKET_FILTER_MULTICAST);
@@ -872,11 +999,18 @@
 		kaweth_err("Error setting receive filter");
 		return kaweth;
 	}
-	
+
 	kaweth_dbg("Initializing net device.");
 
 	kaweth->tx_urb = usb_alloc_urb(0);
+	if (!kaweth->tx_urb)
+		goto err_no_urb;
 	kaweth->rx_urb = usb_alloc_urb(0);
+	if (!kaweth->rx_urb)
+		goto err_only_tx;
+	kaweth->irq_urb = usb_alloc_urb(0);
+	if (!kaweth->irq_urb)
+		goto err_tx_and_rx;
 
 	kaweth->net = init_etherdev(0, 0);
 	if (!kaweth->net) {
@@ -885,17 +1019,17 @@
 	}
 
 	memcpy(kaweth->net->broadcast, &bcast_addr, sizeof(bcast_addr));
-	memcpy(kaweth->net->dev_addr, 
+	memcpy(kaweth->net->dev_addr,
                &kaweth->configuration.hw_addr,
                sizeof(kaweth->configuration.hw_addr));
-	 
+
 	kaweth->net->priv = kaweth;
 	kaweth->net->open = kaweth_open;
 	kaweth->net->stop = kaweth_close;
 
 	kaweth->net->watchdog_timeo = KAWETH_TX_TIMEOUT;
 	kaweth->net->tx_timeout = kaweth_tx_timeout;
-	
+
 	kaweth->net->do_ioctl = kaweth_ioctl;
 	kaweth->net->hard_start_xmit = kaweth_start_xmit;
 	kaweth->net->set_multicast_list = kaweth_set_rx_mode;
@@ -905,10 +1039,18 @@
 	memset(&kaweth->stats, 0, sizeof(kaweth->stats));
 
 	kaweth_info("kaweth interface created at %s", kaweth->net->name);
-								
+
 	kaweth_dbg("Kaweth probe returning.");
 
 	return kaweth;
+
+err_tx_and_rx:
+	usb_free_urb(kaweth->rx_urb);
+err_only_tx:
+	usb_free_urb(kaweth->tx_urb);
+err_no_urb:
+	kfree(kaweth);
+	return NULL;
 }
 
 /****************************************************************
@@ -925,8 +1067,18 @@
 		return;
 	}
 
+	kaweth->removed = 1;
+	usb_unlink_urb(kaweth->irq_urb);
 	usb_unlink_urb(kaweth->rx_urb);
-	usb_unlink_urb(kaweth->tx_urb);
+
+	/* we need to wait for the urb to be cancelled, if it is active */
+	spin_lock_irq(&kaweth->device_lock);
+	if (usb_unlink_urb(kaweth->tx_urb) == -EINPROGRESS) {
+		spin_unlock_irq(&kaweth->device_lock);
+		wait_event(kaweth->term_wait, kaweth->end);
+	} else {
+		spin_unlock_irq(&kaweth->device_lock);
+	}
 
 	if(kaweth->net) {
 		if(kaweth->net->flags & IFF_UP) {
@@ -945,12 +1097,19 @@
 }
 
 
+// FIXME this completion stuff is a modified clone of
+// an OLD version of some stuff in usb.c ...
+struct kw_api_data {
+	wait_queue_head_t wqh;
+	int done;
+};
+
 /*-------------------------------------------------------------------*
  * completion handler for compatibility wrappers (sync control/bulk) *
  *-------------------------------------------------------------------*/
-static void usb_api_blocking_completion(urb_t *urb)
+static void usb_api_blocking_completion(struct urb *urb)
 {
-        struct usb_api_data *awd = (struct usb_api_data *)urb->context;
+        struct kw_api_data *awd = (struct kw_api_data *)urb->context;
 
 	awd->done=1;
 	wake_up(&awd->wqh);
@@ -961,15 +1120,15 @@
  *-------------------------------------------------------------------*/
 
 // Starts urb and waits for completion or timeout
-static int usb_start_wait_urb(urb_t *urb, int timeout, int* actual_length)
+static int usb_start_wait_urb(struct urb *urb, int timeout, int* actual_length)
 {
         DECLARE_WAITQUEUE(wait, current);
-	struct usb_api_data awd;
+	struct kw_api_data awd;
         int status;
 
         init_waitqueue_head(&awd.wqh);
         awd.done = 0;
-        
+
         set_current_state(TASK_INTERRUPTIBLE);
         add_wait_queue(&awd.wqh, &wait);
         urb->context = &awd;
@@ -1009,9 +1168,10 @@
 /*-------------------------------------------------------------------*/
 // returns status (negative) or length (positive)
 int kaweth_internal_control_msg(struct usb_device *usb_dev, unsigned int pipe,
-                            devrequest *cmd,  void *data, int len, int timeout)
+                            struct usb_ctrlrequest *cmd, void *data, int len,
+			    int timeout)
 {
-        urb_t *urb;
+        struct urb *urb;
         int retv;
         int length;
 
@@ -1054,6 +1214,7 @@
 
 
 
+
 
 
 
diff -Nur linux-2.4.19.old/drivers/usb/mdc800.c linux-2.4.19/drivers/usb/mdc800.c
--- linux-2.4.19.old/drivers/usb/mdc800.c	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/mdc800.c	Mon Nov 25 12:26:55 2002
@@ -140,7 +140,7 @@
 
 	unsigned int		endpoint [4];
 
-	purb_t			irq_urb;
+	struct urb *		irq_urb;
 	wait_queue_head_t	irq_wait;
 	int                     irq_woken;
 	char*			irq_urb_buffer;
@@ -149,13 +149,13 @@
 	int 			camera_request_ready; // Status to synchronize with irq
 	char 			camera_response [8];  // last Bytes send after busy
 
-	purb_t   		write_urb;
+	struct urb *   		write_urb;
 	char*			write_urb_buffer;
 	wait_queue_head_t	write_wait;
 	int                     written;
 
 
-	purb_t	   		download_urb;
+	struct urb *		download_urb;
 	char*			download_urb_buffer;
 	wait_queue_head_t	download_wait;
 	int                     downloaded;
@@ -652,7 +652,7 @@
  */
 static ssize_t mdc800_device_read (struct file *file, char *buf, size_t len, loff_t *pos)
 {
-	int   left=len, sts=len; /* single transfer size */
+	size_t left=len, sts=len; /* single transfer size */
 	char* ptr=buf;
 	DECLARE_WAITQUEUE(wait, current);
 
@@ -746,7 +746,7 @@
  */
 static ssize_t mdc800_device_write (struct file *file, const char *buf, size_t len, loff_t *pos)
 {
-	int i=0;
+	size_t i=0;
 	DECLARE_WAITQUEUE(wait, current);
 
 	down (&mdc800->io_lock);
diff -Nur linux-2.4.19.old/drivers/usb/microtek.c linux-2.4.19/drivers/usb/microtek.c
--- linux-2.4.19.old/drivers/usb/microtek.c	Fri Oct  5 21:04:51 2001
+++ linux-2.4.19/drivers/usb/microtek.c	Mon Nov 25 12:26:55 2002
@@ -117,6 +117,8 @@
  *	20010320 Version 0.4.3
  *	20010408 Identify version on module load.
  *	20011003 Fix multiple requests
+ *	20020618 Version 0.4.4
+ *	20020618 Confirm to utterly stupid rules about io_request_lock
  */
 
 #include <linux/module.h>
@@ -144,7 +146,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v0.4.3"
+#define DRIVER_VERSION "v0.4.4"
 #define DRIVER_AUTHOR "John Fremlin <vii@penguinpowered.com>, Oliver Neukum <Oliver.Neukum@lrz.uni-muenchen.de>"
 #define DRIVER_DESC "Microtek Scanmaker X6 USB scanner driver"
 
@@ -326,10 +328,12 @@
 }  */
 
 static inline void mts_urb_abort(struct mts_desc* desc) {
+	spin_unlock_irq(&io_request_lock);
 	MTS_DEBUG_GOT_HERE();
 	mts_debug_dump(desc);
 
 	usb_unlink_urb( &desc->urb );
+	spin_lock_irq(&io_request_lock);
 }
 
 static struct mts_desc * mts_list; /* list of active scanners */
@@ -414,12 +418,14 @@
 
 static int mts_scsi_host_reset (Scsi_Cmnd *srb)
 {
-	struct mts_desc* desc = (struct mts_desc*)(srb->host->hostdata[0]);
 
+	struct mts_desc* desc = (struct mts_desc*)(srb->host->hostdata[0]);
+	spin_unlock_irq(&io_request_lock);
 	MTS_DEBUG_GOT_HERE();
 	mts_debug_dump(desc);
 
 	usb_reset_device(desc->usb_dev); /*FIXME: untested on new reset code */
+	spin_lock_irq(&io_request_lock);
 	return 0;  /* RANT why here 0 and not SUCCESS */
 }
 
@@ -435,6 +441,7 @@
 	/* What a hideous hack! */
 
 	char local_name[48];
+	spin_unlock_irq(&io_request_lock);
 
 	MTS_DEBUG_GOT_HERE();
 
@@ -445,6 +452,7 @@
 
 	if (!sht->proc_name) {
 		MTS_ERROR( "unable to allocate memory for proc interface!!\n" );
+		spin_lock_irq(&io_request_lock);
 		return 0;
 	}
 
@@ -457,11 +465,12 @@
 	if (desc->host == NULL) {
 		MTS_ERROR("Cannot register due to low memory");
 		kfree(sht->proc_name);
+		spin_lock_irq(&io_request_lock);
 		return 0;
 	}
 	desc->host->hostdata[0] = (unsigned long)desc;
 /* FIXME: what if sizeof(void*) != sizeof(unsigned long)? */
-
+	spin_lock_irq(&io_request_lock);
 	return 1;
 }
 
diff -Nur linux-2.4.19.old/drivers/usb/ov511.c linux-2.4.19/drivers/usb/ov511.c
--- linux-2.4.19.old/drivers/usb/ov511.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/ov511.c	Mon Nov 25 12:26:55 2002
@@ -9,7 +9,8 @@
  * OV7620 fixes by Charl P. Botha <cpbotha@ieee.org>
  * Changes by Claudio Matsuoka <claudio@conectiva.com>
  * Original SAA7111A code by Dave Perks <dperks@ibm.net>
- * Kernel I2C interface adapted from nt1003 driver
+ * URB error messages from pwc driver by Nemosoft
+ * generic_ioctl() code from videodev.c by Gerd Knorr and Alan Cox
  *
  * Based on the Linux CPiA driver written by Peter Pregler,
  * Scott J. Bertin and Johannes Erdfelt.
@@ -57,19 +58,22 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.50 for Linux 2.4"
-#define EMAIL "mmcclell@bigfoot.com"
+#define DRIVER_VERSION "v1.61 for Linux 2.4"
+#define EMAIL "mark@alpha.dyndns.org"
 #define DRIVER_AUTHOR "Mark McClelland <mmcclell@bigfoot.com> & Bret Wallach \
 	& Orion Sky Lawlor <olawlor@acm.org> & Kevin Moore & Charl P. Botha \
 	<cpbotha@ieee.org> & Claudio Matsuoka <claudio@conectiva.com>"
-#define DRIVER_DESC "OV511 USB Camera Driver"
+#define DRIVER_DESC "ov511 USB Camera Driver"
 
 #define OV511_I2C_RETRIES 3
 #define ENABLE_Y_QUANTABLE 1
 #define ENABLE_UV_QUANTABLE 1
 
+#define OV511_MAX_UNIT_VIDEO 16
+
 /* Pixel count * 3 bytes for RGB */
 #define MAX_FRAME_SIZE(w, h) ((w) * (h) * 3)
+
 #define MAX_DATA_SIZE(w, h) (MAX_FRAME_SIZE(w, h) + sizeof(struct timeval))
 
 /* Max size * bytes per YUV420 pixel (1.5) + one extra isoc frame for safety */
@@ -77,128 +81,47 @@
 
 #define FATAL_ERROR(rc) ((rc) < 0 && (rc) != -EPERM)
 
-/* PARAMETER VARIABLES: */
-/* (See ov511.txt for detailed descriptions of these.) */
-
-/* Sensor automatically changes brightness */
-static int autobright = 1;
-
-/* Sensor automatically changes gain */
-static int autogain = 1;
-
-/* Sensor automatically changes exposure */
-static int autoexp = 1;
-
-/* 0=no debug messages
- * 1=init/detection/unload and other significant messages,
- * 2=some warning messages
- * 3=config/control function calls
- * 4=most function calls and data parsing messages
- * 5=highly repetitive mesgs
- * NOTE: This should be changed to 0, 1, or 2 for production kernels
- */
-static int debug; /* = 0 */
-
-/* Fix vertical misalignment of red and blue at 640x480 */
-static int fix_rgb_offset; /* = 0 */
-
-/* Snapshot mode enabled flag */
-static int snapshot; /* = 0 */
-
-/* Force image to be read in RGB instead of BGR. This option allow
- * programs that expect RGB data (e.g. gqcam) to work with this driver. */
-static int force_rgb; /* = 0 */
-
-/* Number of seconds before inactive buffers are deallocated */
-static int buf_timeout = 5;
-
-/* Number of cameras to stream from simultaneously */
-static int cams = 1;
-
-/* Enable compression. Needs a fast (>300 MHz) CPU. */
-static int compress; /* = 0 */
-
-/* Display test pattern - doesn't work yet either */
-static int testpat; /* = 0 */
-
-/* Setting this to 1 will make the sensor output GBR422 instead of YUV420. Only
- * affects RGB24 mode. */
-static int sensor_gbr; /* = 0 */
-
-/* Dump raw pixel data. */
-static int dumppix; /* = 0 */
-
-/* LED policy. Only works on some OV511+ cameras. 0=off, 1=on (default), 2=auto
- * (on when open) */
-static int led = 1;
-
-/* Set this to 1 to dump the bridge register contents after initialization */
-static int dump_bridge; /* = 0 */
-
-/* Set this to 1 to dump the sensor register contents after initialization */
-static int dump_sensor; /* = 0 */
-
-/* Temporary option for debugging "works, but no image" problem. Prints the
- * first 12 bytes of data (potentially a packet header) in each isochronous
- * data frame. */
-static int printph; /* = 0 */
-
-/* Compression parameters - I'm not exactly sure what these do yet */
-static int phy = 0x1f;
-static int phuv = 0x05;
-static int pvy = 0x06;
-static int pvuv = 0x06;
-static int qhy = 0x14;
-static int qhuv = 0x03;
-static int qvy = 0x04;
-static int qvuv = 0x04;
-
-/* Light frequency. Set to 50 or 60 (Hz), or zero for default settings */
-static int lightfreq; /* = 0 */
-
-/* Set this to 1 to enable banding filter by default. Compensates for
- * alternating horizontal light/dark bands caused by (usually fluorescent)
- * lights */
-static int bandingfilter; /* = 0 */
-
-/* Pixel clock divisor */
-static int clockdiv = -1;
-
-/* Isoc packet size */
-static int packetsize = -1;
-
-/* Frame drop register (16h) */
-static int framedrop = -1;
-
-/* Allows picture settings (brightness, hue, etc...) to take effect immediately,
- * even in the middle of a frame. This reduces the time to change settings, but
- * can ruin frames during the change. Only affects OmniVision sensors. */
-static int fastset; /* = 0 */
-
-/* Forces the palette to a specific value. If an application requests a
- * different palette, it will be rejected. */
-static int force_palette; /* = 0 */
-
-/* Set tuner type, if not autodetected */
-static int tuner = -1;
-
-/* Allows proper exposure of objects that are illuminated from behind. Only
- * affects OmniVision sensors. */
-static int backlight; /* = 0 */
-
-/* If you change this, you must also change the MODULE_PARM definition */
-#define OV511_MAX_UNIT_VIDEO 16
+/**********************************************************************
+ * Module Parameters
+ * (See ov511.txt for detailed descriptions of these)
+ **********************************************************************/
 
-/* Allows specified minor numbers to be forced. They will be assigned in the
- * order that devices are detected. Note that you cannot specify 0 as a minor
- * number. If you do not specify any, the next available one will be used. This
- * requires kernel 2.4.5 or later. */
+/* These variables (and all static globals) default to zero */
+static int autobright		= 1;
+static int autogain		= 1;
+static int autoexp		= 1;
+static int debug;
+static int snapshot;
+static int fix_rgb_offset;
+static int force_rgb;
+static int cams			= 1;
+static int compress;
+static int testpat;
+static int sensor_gbr;
+static int dumppix;
+static int led 			= 1;
+static int dump_bridge;
+static int dump_sensor;
+static int printph;
+static int phy			= 0x1f;
+static int phuv			= 0x05;
+static int pvy			= 0x06;
+static int pvuv			= 0x06;
+static int qhy			= 0x14;
+static int qhuv			= 0x03;
+static int qvy			= 0x04;
+static int qvuv			= 0x04;
+static int lightfreq;
+static int bandingfilter;
+static int clockdiv		= -1;
+static int packetsize		= -1;
+static int framedrop		= -1;
+static int fastset;
+static int force_palette;
+static int backlight;
 static int unit_video[OV511_MAX_UNIT_VIDEO];
-
-/* Remove zero-padding from uncompressed incoming data. This will compensate for
- * the blocks of corruption that appear when the camera cannot keep up with the
- * speed of the USB bus (eg. at low frame resolutions) */
-static int remove_zeros; /* = 0 */
+static int remove_zeros;
+static int mirror;
 
 MODULE_PARM(autobright, "i");
 MODULE_PARM_DESC(autobright, "Sensor automatically changes brightness");
@@ -209,15 +132,13 @@
 MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug,
   "Debug level: 0=none, 1=inits, 2=warning, 3=config, 4=functions, 5=max");
+MODULE_PARM(snapshot, "i");
+MODULE_PARM_DESC(snapshot, "Enable snapshot mode");
 MODULE_PARM(fix_rgb_offset, "i");
 MODULE_PARM_DESC(fix_rgb_offset,
   "Fix vertical misalignment of red and blue at 640x480");
-MODULE_PARM(snapshot, "i");
-MODULE_PARM_DESC(snapshot, "Enable snapshot mode");
 MODULE_PARM(force_rgb, "i");
 MODULE_PARM_DESC(force_rgb, "Read RGB instead of BGR");
-MODULE_PARM(buf_timeout, "i");
-MODULE_PARM_DESC(buf_timeout, "Number of seconds before buffer deallocation");
 MODULE_PARM(cams, "i");
 MODULE_PARM_DESC(cams, "Number of simultaneous cameras");
 MODULE_PARM(compress, "i");
@@ -225,11 +146,6 @@
 MODULE_PARM(testpat, "i");
 MODULE_PARM_DESC(testpat,
   "Replace image with vertical bar testpattern (only partially working)");
-
-// Temporarily removed (needs to be rewritten for new format conversion code)
-// MODULE_PARM(sensor_gbr, "i");
-// MODULE_PARM_DESC(sensor_gbr, "Make sensor output GBR422 rather than YUV420");
-
 MODULE_PARM(dumppix, "i");
 MODULE_PARM_DESC(dumppix, "Dump raw pixel data");
 MODULE_PARM(led, "i");
@@ -273,21 +189,25 @@
 MODULE_PARM_DESC(fastset, "Allows picture settings to take effect immediately");
 MODULE_PARM(force_palette, "i");
 MODULE_PARM_DESC(force_palette, "Force the palette to a specific value");
-MODULE_PARM(tuner, "i");
-MODULE_PARM_DESC(tuner, "Set tuner type, if not autodetected");
 MODULE_PARM(backlight, "i");
 MODULE_PARM_DESC(backlight, "For objects that are lit from behind");
-MODULE_PARM(unit_video, "0-16i");
+MODULE_PARM(unit_video, "1-" __MODULE_STRING(OV511_MAX_UNIT_VIDEO) "i");
 MODULE_PARM_DESC(unit_video,
   "Force use of specific minor number(s). 0 is not allowed.");
 MODULE_PARM(remove_zeros, "i");
 MODULE_PARM_DESC(remove_zeros,
   "Remove zero-padding from uncompressed incoming data");
+MODULE_PARM(mirror, "i");
+MODULE_PARM_DESC(mirror, "Reverse image horizontally");
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
+/**********************************************************************
+ * Miscellaneous Globals
+ **********************************************************************/
+
 static struct usb_driver ov511_driver;
 
 static struct ov51x_decomp_ops *ov511_decomp_ops;
@@ -302,20 +222,28 @@
 /* MMX support is present in kernel and CPU. Checked upon decomp module load. */
 static int ov51x_mmx_available;
 
-/* Function prototypes */
-static void ov51x_clear_snapshot(struct usb_ov511 *);
-static int ov51x_check_snapshot(struct usb_ov511 *);
-static inline int sensor_get_picture(struct usb_ov511 *, 
-				     struct video_picture *);
-static int sensor_get_exposure(struct usb_ov511 *, unsigned char *);
-static int ov51x_control_ioctl(struct inode *, struct file *, unsigned int,
-			       unsigned long);
+static __devinitdata struct usb_device_id device_table [] = {
+	{ USB_DEVICE(VEND_OMNIVISION, PROD_OV511) },
+	{ USB_DEVICE(VEND_OMNIVISION, PROD_OV511PLUS) },
+	{ USB_DEVICE(VEND_OMNIVISION, PROD_OV518) },
+	{ USB_DEVICE(VEND_OMNIVISION, PROD_OV518PLUS) },
+	{ USB_DEVICE(VEND_MATTEL, PROD_ME2CAM) },
+	{ }  /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, device_table);
+
+static unsigned char yQuanTable511[] = OV511_YQUANTABLE;
+static unsigned char uvQuanTable511[] = OV511_UVQUANTABLE;
+static unsigned char yQuanTable518[] = OV518_YQUANTABLE;
+static unsigned char uvQuanTable518[] = OV518_UVQUANTABLE;
 
 /**********************************************************************
- * List of known OV511-based cameras
+ * Symbolic Names
  **********************************************************************/
 
-static struct cam_list clist[] = {
+/* Known OV511-based cameras */
+static struct symbolic_list camlist[] = {
 	{   0, "Generic Camera (no ID)" },
 	{   1, "Mustek WCam 3X" },
 	{   3, "D-Link DSB-C300" },
@@ -323,11 +251,13 @@
 	{   5, "Puretek PT-6007" },
 	{   6, "Lifeview USB Life TV (NTSC)" },
 	{  21, "Creative Labs WebCam 3" },
+	{  22, "Lifeview USB Life TV (PAL D/K+B/G)" },
 	{  36, "Koala-Cam" },
-	{  38, "Lifeview USB Life TV" },
+	{  38, "Lifeview USB Life TV (PAL)" },
 	{  41, "Samsung Anycam MPC-M10" },
 	{  43, "Mtekvision Zeca MV402" },
 	{  46, "Suma eON" },
+	{  70, "Lifeview USB Life TV (PAL/SECAM)" },
 	{ 100, "Lifeview RoboCam" },
 	{ 102, "AverMedia InterCam Elite" },
 	{ 112, "MediaForte MV300" },	/* or OV7110 evaluation kit */
@@ -335,97 +265,90 @@
 	{  -1, NULL }
 };
 
-static __devinitdata struct usb_device_id device_table [] = {
-	{ USB_DEVICE(VEND_OMNIVISION, PROD_OV511) },
-	{ USB_DEVICE(VEND_OMNIVISION, PROD_OV511PLUS) },
-	{ USB_DEVICE(VEND_OMNIVISION, PROD_OV518) },
-	{ USB_DEVICE(VEND_OMNIVISION, PROD_OV518PLUS) },
-	{ USB_DEVICE(VEND_MATTEL, PROD_ME2CAM) },
-	{ }  /* Terminating entry */
-};
-
-MODULE_DEVICE_TABLE (usb, device_table);
-
-#if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
-static struct palette_list plist[] = {
+/* Video4Linux1 Palettes */
+static struct symbolic_list v4l1_plist[] = {
 	{ VIDEO_PALETTE_GREY,	"GREY" },
-	{ VIDEO_PALETTE_HI240,  "HI240" },
-	{ VIDEO_PALETTE_RGB565, "RGB565" },
+	{ VIDEO_PALETTE_HI240,	"HI240" },
+	{ VIDEO_PALETTE_RGB565,	"RGB565" },
 	{ VIDEO_PALETTE_RGB24,	"RGB24" },
 	{ VIDEO_PALETTE_RGB32,	"RGB32" },
-	{ VIDEO_PALETTE_RGB555, "RGB555" },
-	{ VIDEO_PALETTE_YUV422, "YUV422" },
-	{ VIDEO_PALETTE_YUYV,   "YUYV" },
-	{ VIDEO_PALETTE_UYVY,   "UYVY" },
-	{ VIDEO_PALETTE_YUV420, "YUV420" },
-	{ VIDEO_PALETTE_YUV411, "YUV411" },
-	{ VIDEO_PALETTE_RAW,    "RAW" },
+	{ VIDEO_PALETTE_RGB555,	"RGB555" },
+	{ VIDEO_PALETTE_YUV422,	"YUV422" },
+	{ VIDEO_PALETTE_YUYV,	"YUYV" },
+	{ VIDEO_PALETTE_UYVY,	"UYVY" },
+	{ VIDEO_PALETTE_YUV420,	"YUV420" },
+	{ VIDEO_PALETTE_YUV411,	"YUV411" },
+	{ VIDEO_PALETTE_RAW,	"RAW" },
 	{ VIDEO_PALETTE_YUV422P,"YUV422P" },
 	{ VIDEO_PALETTE_YUV411P,"YUV411P" },
 	{ VIDEO_PALETTE_YUV420P,"YUV420P" },
 	{ VIDEO_PALETTE_YUV410P,"YUV410P" },
 	{ -1, NULL }
 };
-#endif
 
-static unsigned char yQuanTable511[] = OV511_YQUANTABLE;
-static unsigned char uvQuanTable511[] = OV511_UVQUANTABLE;
-static unsigned char yQuanTable518[] = OV518_YQUANTABLE;
-static unsigned char uvQuanTable518[] = OV518_UVQUANTABLE;
+static struct symbolic_list brglist[] = {
+	{ BRG_OV511,		"OV511" },
+	{ BRG_OV511PLUS,	"OV511+" },
+	{ BRG_OV518,		"OV518" },
+	{ BRG_OV518PLUS,	"OV518+" },
+	{ -1, NULL }
+};
+
+static struct symbolic_list senlist[] = {
+	{ SEN_OV76BE,	"OV76BE" },
+	{ SEN_OV7610,	"OV7610" },
+	{ SEN_OV7620,	"OV7620" },
+	{ SEN_OV7620AE,	"OV7620AE" },
+	{ SEN_OV6620,	"OV6620" },
+	{ SEN_OV6630,	"OV6630" },
+	{ SEN_OV6630AE,	"OV6630AE" },
+	{ SEN_OV6630AF,	"OV6630AF" },
+	{ SEN_OV8600,	"OV8600" },
+	{ SEN_KS0127,	"KS0127" },
+	{ SEN_KS0127B,	"KS0127B" },
+	{ SEN_SAA7111A,	"SAA7111A" },
+	{ -1, NULL }
+};
+
+/* URB error codes: */
+static struct symbolic_list urb_errlist[] = {
+	{ -ENOSR,	"Buffer error (overrun)" },
+	{ -EPIPE,	"Stalled (device not responding)" },
+	{ -EOVERFLOW,	"Babble (bad cable?)" },
+	{ -EPROTO,	"Bit-stuff error (bad cable?)" },
+	{ -EILSEQ,	"CRC/Timeout" },
+	{ -ETIMEDOUT,	"NAK (device does not respond)" },
+	{ -1, NULL }
+};
 
 /**********************************************************************
- *
- * Memory management
- *
- * This is a shameless copy from the USB-cpia driver (linux kernel
- * version 2.3.29 or so, I have no idea what this code actually does ;).
- * Actually it seems to be a copy of a shameless copy of the bttv-driver.
- * Or that is a copy of a shameless copy of ... (To the powers: is there
- * no generic kernel-function to do this sort of stuff?)
- *
- * Yes, it was a shameless copy from the bttv-driver. IIRC, Alan says
- * there will be one, but apparentely not yet -jerdfelt
- *
- * So I copied it again for the OV511 driver -claudio
+ * Prototypes
  **********************************************************************/
 
-/* Given PGD from the address space's page table, return the kernel
- * virtual mapping of the physical memory mapped at ADR.
- */
-static inline unsigned long 
-uvirt_to_kva(pgd_t *pgd, unsigned long adr)
-{
-	unsigned long ret = 0UL;
-	pmd_t *pmd;
-	pte_t *ptep, pte;
-
-	if (!pgd_none(*pgd)) {
-		pmd = pmd_offset(pgd, adr);
-		if (!pmd_none(*pmd)) {
-			ptep = pte_offset(pmd, adr);
-			pte = *ptep;
-			if (pte_present(pte)) {
-				ret = (unsigned long) 
-				      page_address(pte_page(pte));
-				ret |= (adr & (PAGE_SIZE - 1));
-			}
-		}
-	}
+static void ov51x_clear_snapshot(struct usb_ov511 *);
+static inline int sensor_get_picture(struct usb_ov511 *,
+				     struct video_picture *);
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
+static int sensor_get_exposure(struct usb_ov511 *, unsigned char *);
+static int ov51x_control_ioctl(struct inode *, struct file *, unsigned int,
+			       unsigned long);
+static int ov51x_check_snapshot(struct usb_ov511 *);
+#endif
 
-	return ret;
-}
+/**********************************************************************
+ * Memory management
+ **********************************************************************/
 
 /* Here we want the physical address of the memory.
- * This is used when initializing the contents of the
- * area and marking the pages as reserved.
+ * This is used when initializing the contents of the area.
  */
-static inline unsigned long 
+static inline unsigned long
 kvirt_to_pa(unsigned long adr)
 {
-	unsigned long va, kva, ret;
+	unsigned long kva, ret;
 
-	va = VMALLOC_VMADDR(adr);
-	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
 	ret = __pa(kva);
 	return ret;
 }
@@ -434,12 +357,9 @@
 rvmalloc(unsigned long size)
 {
 	void *mem;
-	unsigned long adr, page;
-
-	/* Round it off to PAGE_SIZE */
-	size += (PAGE_SIZE - 1);
-	size &= ~(PAGE_SIZE - 1);
+	unsigned long adr;
 
+	size = PAGE_ALIGN(size);
 	mem = vmalloc_32(size);
 	if (!mem)
 		return NULL;
@@ -447,38 +367,27 @@
 	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
 	adr = (unsigned long) mem;
 	while (size > 0) {
-		page = kvirt_to_pa(adr);
-		mem_map_reserve(virt_to_page(__va(page)));
+		mem_map_reserve(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
-		if (size > PAGE_SIZE)
-			size -= PAGE_SIZE;
-		else
-			size = 0;
+		size -= PAGE_SIZE;
 	}
 
 	return mem;
 }
 
-static void 
+static void
 rvfree(void *mem, unsigned long size)
 {
-	unsigned long adr, page;
+	unsigned long adr;
 
 	if (!mem)
 		return;
 
-	size += (PAGE_SIZE - 1);
-	size &= ~(PAGE_SIZE - 1);
-
-	adr=(unsigned long) mem;
-	while (size > 0) {
-		page = kvirt_to_pa(adr);
-		mem_map_unreserve(virt_to_page(__va(page)));
+	adr = (unsigned long) mem;
+	while ((long) size > 0) {
+		mem_map_unreserve(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
-		if (size > PAGE_SIZE)
-			size -= PAGE_SIZE;
-		else
-			size = 0;
+		size -= PAGE_SIZE;
 	}
 	vfree(mem);
 }
@@ -500,12 +409,12 @@
 #define YES_NO(x) ((x) ? "yes" : "no")
 
 /* /proc/video/ov511/<minor#>/info */
-static int 
+static int
 ov511_read_proc_info(char *page, char **start, off_t off, int count, int *eof,
 		     void *data)
 {
 	char *out = page;
-	int i, j, len;
+	int i, len;
 	struct usb_ov511 *ov = data;
 	struct video_picture p;
 	unsigned char exp;
@@ -521,8 +430,7 @@
 
 	out += sprintf(out, "driver_version  : %s\n", DRIVER_VERSION);
 	out += sprintf(out, "custom_id       : %d\n", ov->customid);
-	out += sprintf(out, "model           : %s\n", ov->desc ?
-		       clist[ov->desc].description : "unknown");
+	out += sprintf(out, "model           : %s\n", ov->desc);
 	out += sprintf(out, "streaming       : %s\n", YES_NO(ov->streaming));
 	out += sprintf(out, "grabbing        : %s\n", YES_NO(ov->grabbing));
 	out += sprintf(out, "compress        : %s\n", YES_NO(ov->compress));
@@ -543,36 +451,16 @@
 			       ov->frame[i].depth);
 		out += sprintf(out, "  size          : %d %d\n",
 			       ov->frame[i].width, ov->frame[i].height);
-		out += sprintf(out, "  format        : ");
-		for (j = 0; plist[j].num >= 0; j++) {
-			if (plist[j].num == ov->frame[i].format) {
-				out += sprintf(out, "%s\n", plist[j].name);
-				break;
-			}
-		}
-		if (plist[j].num < 0)
-			out += sprintf(out, "unknown\n");
+		out += sprintf(out, "  format        : %s\n",
+			       symbolic(v4l1_plist, ov->frame[i].format));
 		out += sprintf(out, "  data_buffer   : 0x%p\n",
 			       ov->frame[i].data);
 	}
 	out += sprintf(out, "snap_enabled    : %s\n", YES_NO(ov->snap_enabled));
 	out += sprintf(out, "bridge          : %s\n",
-		       ov->bridge == BRG_OV511 ? "OV511" :
-			ov->bridge == BRG_OV511PLUS ? "OV511+" :
-			ov->bridge == BRG_OV518 ? "OV518" :
-			ov->bridge == BRG_OV518PLUS ? "OV518+" :
-			"unknown");
+		       symbolic(brglist, ov->bridge));
 	out += sprintf(out, "sensor          : %s\n",
-		       ov->sensor == SEN_OV6620 ? "OV6620" :
-			ov->sensor == SEN_OV6630 ? "OV6630" :
-			ov->sensor == SEN_OV7610 ? "OV7610" :
-			ov->sensor == SEN_OV7620 ? "OV7620" :
-			ov->sensor == SEN_OV7620AE ? "OV7620AE" :
-			ov->sensor == SEN_OV8600 ? "OV8600" :
-			ov->sensor == SEN_KS0127 ? "KS0127" :
-			ov->sensor == SEN_KS0127B ? "KS0127B" :
-			ov->sensor == SEN_SAA7111A ? "SAA7111A" :
-			"unknown");
+		       symbolic(senlist, ov->sensor));
 	out += sprintf(out, "packet_size     : %d\n", ov->packet_size);
 	out += sprintf(out, "framebuffer     : 0x%p\n", ov->fbuf);
 
@@ -595,13 +483,13 @@
  * When the camera's button is pressed, the output of this will change from a
  * 0 to a 1 (ASCII). It will retain this value until it is read, after which
  * it will reset to zero.
- * 
+ *
  * SECURITY NOTE: Since reading this file can change the state of the snapshot
  * status, it is important for applications that open it to keep it locked
  * against access by other processes, using flock() or a similar mechanism. No
  * locking is provided by this driver.
  */
-static int 
+static int
 ov511_read_proc_button(char *page, char **start, off_t off, int count, int *eof,
 		       void *data)
 {
@@ -633,97 +521,95 @@
 	return len;
 }
 
-static void 
-create_proc_ov511_cam(struct usb_ov511 *ov511)
+static void
+create_proc_ov511_cam(struct usb_ov511 *ov)
 {
 	char dirname[10];
 
-	if (!ov511_proc_entry || !ov511)
+	if (!ov511_proc_entry || !ov)
 		return;
 
 	/* Create per-device directory */
-	snprintf(dirname, 10, "%d", ov511->vdev.minor);
+	snprintf(dirname, 10, "%d", ov->vdev.minor);
 	PDEBUG(4, "creating /proc/video/ov511/%s/", dirname);
-	ov511->proc_devdir = create_proc_entry(dirname, S_IFDIR,
-		ov511_proc_entry);
-	if (!ov511->proc_devdir)
+	ov->proc_devdir = create_proc_entry(dirname, S_IFDIR, ov511_proc_entry);
+	if (!ov->proc_devdir)
 		return;
-	ov511->proc_devdir->owner = THIS_MODULE;
+	ov->proc_devdir->owner = THIS_MODULE;
 
 	/* Create "info" entry (human readable device information) */
 	PDEBUG(4, "creating /proc/video/ov511/%s/info", dirname);
-	ov511->proc_info = create_proc_read_entry("info",
-		S_IFREG|S_IRUGO|S_IWUSR, ov511->proc_devdir,
-		ov511_read_proc_info, ov511);
-	if (!ov511->proc_info)
+	ov->proc_info = create_proc_read_entry("info", S_IFREG|S_IRUGO|S_IWUSR,
+		ov->proc_devdir, ov511_read_proc_info, ov);
+	if (!ov->proc_info)
 		return;
-	ov511->proc_info->owner = THIS_MODULE;
+	ov->proc_info->owner = THIS_MODULE;
 
 	/* Don't create it if old snapshot mode on (would cause race cond.) */
 	if (!snapshot) {
 		/* Create "button" entry (snapshot button status) */
 		PDEBUG(4, "creating /proc/video/ov511/%s/button", dirname);
-		ov511->proc_button = create_proc_read_entry("button",
-			S_IFREG|S_IRUGO|S_IWUSR, ov511->proc_devdir,
-			ov511_read_proc_button, ov511);
-		if (!ov511->proc_button)
+		ov->proc_button = create_proc_read_entry("button",
+			S_IFREG|S_IRUGO|S_IWUSR, ov->proc_devdir,
+			ov511_read_proc_button, ov);
+		if (!ov->proc_button)
 			return;
 	}
-	ov511->proc_button->owner = THIS_MODULE;
+	ov->proc_button->owner = THIS_MODULE;
 
 	/* Create "control" entry (ioctl() interface) */
 	PDEBUG(4, "creating /proc/video/ov511/%s/control", dirname);
 	lock_kernel();
-	ov511->proc_control = create_proc_entry("control",
-		S_IFREG|S_IRUGO|S_IWUSR, ov511->proc_devdir);
-	if (!ov511->proc_control) {
+	ov->proc_control = create_proc_entry("control",	S_IFREG|S_IRUGO|S_IWUSR,
+		ov->proc_devdir);
+	if (!ov->proc_control) {
 		unlock_kernel();
 		return;
 	}
-	ov511->proc_control->owner = THIS_MODULE;
-	ov511->proc_control->data = ov511;
-	ov511->proc_control->proc_fops = &ov511_control_fops;
+	ov->proc_control->owner = THIS_MODULE;
+	ov->proc_control->data = ov;
+	ov->proc_control->proc_fops = &ov511_control_fops;
 	unlock_kernel();
 }
 
-static void 
-destroy_proc_ov511_cam(struct usb_ov511 *ov511)
+static void
+destroy_proc_ov511_cam(struct usb_ov511 *ov)
 {
 	char dirname[10];
-	
-	if (!ov511 || !ov511->proc_devdir)
+
+	if (!ov || !ov->proc_devdir)
 		return;
 
-	snprintf(dirname, 10, "%d", ov511->vdev.minor);
+	snprintf(dirname, 10, "%d", ov->vdev.minor);
 
 	/* Destroy "control" entry */
-	if (ov511->proc_control) {
+	if (ov->proc_control) {
 		PDEBUG(4, "destroying /proc/video/ov511/%s/control", dirname);
-		remove_proc_entry("control", ov511->proc_devdir);
-		ov511->proc_control = NULL;
+		remove_proc_entry("control", ov->proc_devdir);
+		ov->proc_control = NULL;
 	}
 
 	/* Destroy "button" entry */
-	if (ov511->proc_button) {
+	if (ov->proc_button) {
 		PDEBUG(4, "destroying /proc/video/ov511/%s/button", dirname);
-		remove_proc_entry("button", ov511->proc_devdir);
-		ov511->proc_button = NULL;
+		remove_proc_entry("button", ov->proc_devdir);
+		ov->proc_button = NULL;
 	}
 
 	/* Destroy "info" entry */
-	if (ov511->proc_info) {
+	if (ov->proc_info) {
 		PDEBUG(4, "destroying /proc/video/ov511/%s/info", dirname);
-		remove_proc_entry("info", ov511->proc_devdir);
-		ov511->proc_info = NULL;
+		remove_proc_entry("info", ov->proc_devdir);
+		ov->proc_info = NULL;
 	}
 
 	/* Destroy per-device directory */
 	PDEBUG(4, "destroying /proc/video/ov511/%s/", dirname);
 	remove_proc_entry(dirname, ov511_proc_entry);
-	ov511->proc_devdir = NULL;
+	ov->proc_devdir = NULL;
 }
 
-static void 
+static void
 proc_ov511_create(void)
 {
 	/* No current standard here. Alan prefers /proc/video/ as it keeps
@@ -744,7 +630,7 @@
 		err("Unable to create /proc/video/ov511");
 }
 
-static void 
+static void
 proc_ov511_destroy(void)
 {
 	PDEBUG(3, "removing /proc/video/ov511");
@@ -763,7 +649,7 @@
  **********************************************************************/
 
 /* Write an OV51x register */
-static int 
+static int
 reg_w(struct usb_ov511 *ov, unsigned char reg, unsigned char value)
 {
 	int rc;
@@ -774,20 +660,20 @@
 	ov->cbuf[0] = value;
 	rc = usb_control_msg(ov->dev,
 			     usb_sndctrlpipe(ov->dev, 0),
-			     2 /* REG_IO */,
-			     USB_TYPE_CLASS | USB_RECIP_DEVICE,
-			     0, (__u16)reg, &ov->cbuf[0], 1, HZ);	
+			     (ov->bclass == BCL_OV518)?1:2 /* REG_IO */,
+			     USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			     0, (__u16)reg, &ov->cbuf[0], 1, HZ);
 	up(&ov->cbuf_lock);
 
 	if (rc < 0)
-		err("reg write: error %d", rc);
+		err("reg write: error %d: %s", rc, symbolic(urb_errlist, rc));
 
 	return rc;
 }
 
 /* Read from an OV51x register */
 /* returns: negative is error, pos or zero is data */
-static int 
+static int
 reg_r(struct usb_ov511 *ov, unsigned char reg)
 {
 	int rc;
@@ -795,16 +681,16 @@
 	down(&ov->cbuf_lock);
 	rc = usb_control_msg(ov->dev,
 			     usb_rcvctrlpipe(ov->dev, 0),
-			     2 /* REG_IO */,
-			     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_DEVICE,
+			     (ov->bclass == BCL_OV518)?1:3 /* REG_IO */,
+			     USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
 			     0, (__u16)reg, &ov->cbuf[0], 1, HZ);
-                               
-	PDEBUG(5, "0x%02X:0x%02X", reg, ov->cbuf[0]);
-	
-	if (rc < 0)
-		err("reg read: error %d", rc);
-	else
-		rc = ov->cbuf[0];	
+
+	if (rc < 0) {
+		err("reg read: error %d: %s", rc, symbolic(urb_errlist, rc));
+	} else {
+		rc = ov->cbuf[0];
+		PDEBUG(5, "0x%02X:0x%02X", reg, ov->cbuf[0]);
+	}
 
 	up(&ov->cbuf_lock);
 
@@ -814,10 +700,10 @@
 /*
  * Writes bits at positions specified by mask to an OV51x reg. Bits that are in
  * the same position as 1's in "mask" are cleared and set to "value". Bits
- * that are in the same position as 0's in "mask" are preserved, regardless 
+ * that are in the same position as 0's in "mask" are preserved, regardless
  * of their respective state in "value".
  */
-static int 
+static int
 reg_w_mask(struct usb_ov511 *ov,
 	   unsigned char reg,
 	   unsigned char value,
@@ -842,7 +728,7 @@
  * Writes multiple (n) byte value to a single register. Only valid with certain
  * registers (0x30 and 0xc4 - 0xce).
  */
-static int 
+static int
 ov518_reg_w32(struct usb_ov511 *ov, unsigned char reg, u32 val, int n)
 {
 	int rc;
@@ -855,18 +741,19 @@
 
 	rc = usb_control_msg(ov->dev,
 			     usb_sndctrlpipe(ov->dev, 0),
-			     2 /* REG_IO */,
-			     USB_TYPE_CLASS | USB_RECIP_DEVICE,
+			     1 /* REG_IO */,
+			     USB_TYPE_VENDOR | USB_RECIP_DEVICE,
 			     0, (__u16)reg, ov->cbuf, n, HZ);
 	up(&ov->cbuf_lock);
 
 	if (rc < 0)
-		err("reg write multiple: error %d", rc);
+		err("reg write multiple: error %d: %s", rc,
+		    symbolic(urb_errlist, rc));
 
 	return rc;
 }
 
-static int 
+static int
 ov511_upload_quan_tables(struct usb_ov511 *ov)
 {
 	unsigned char *pYTable = yQuanTable511;
@@ -876,10 +763,8 @@
 
 	PDEBUG(4, "Uploading quantization tables");
 
-	for (i = 0; i < OV511_QUANTABLESIZE / 2; i++)
-	{
-		if (ENABLE_Y_QUANTABLE)
-		{
+	for (i = 0; i < OV511_QUANTABLESIZE / 2; i++) {
+		if (ENABLE_Y_QUANTABLE)	{
 			val0 = *pYTable++;
 			val1 = *pYTable++;
 			val0 &= 0x0f;
@@ -890,8 +775,7 @@
 				return rc;
 		}
 
-		if (ENABLE_UV_QUANTABLE)
-		{
+		if (ENABLE_UV_QUANTABLE) {
 			val0 = *pUVTable++;
 			val1 = *pUVTable++;
 			val0 &= 0x0f;
@@ -909,7 +793,7 @@
 }
 
 /* OV518 quantization tables are 8x4 (instead of 8x8) */
-static int 
+static int
 ov518_upload_quan_tables(struct usb_ov511 *ov)
 {
 	unsigned char *pYTable = yQuanTable518;
@@ -919,10 +803,8 @@
 
 	PDEBUG(4, "Uploading quantization tables");
 
-	for (i = 0; i < OV518_QUANTABLESIZE / 2; i++)
-	{
-		if (ENABLE_Y_QUANTABLE)
-		{
+	for (i = 0; i < OV518_QUANTABLESIZE / 2; i++) {
+		if (ENABLE_Y_QUANTABLE) {
 			val0 = *pYTable++;
 			val1 = *pYTable++;
 			val0 &= 0x0f;
@@ -933,8 +815,7 @@
 				return rc;
 		}
 
-		if (ENABLE_UV_QUANTABLE)
-		{
+		if (ENABLE_UV_QUANTABLE) {
 			val0 = *pUVTable++;
 			val1 = *pUVTable++;
 			val0 &= 0x0f;
@@ -951,16 +832,16 @@
 	return 0;
 }
 
-static int 
+static int
 ov51x_reset(struct usb_ov511 *ov, unsigned char reset_type)
 {
 	int rc;
-		
+
 	/* Setting bit 0 not allowed on 518/518Plus */
 	if (ov->bclass == BCL_OV518)
 		reset_type &= 0xfe;
 
-	PDEBUG(4, "Reset: type=0x%X", reset_type);
+	PDEBUG(4, "Reset: type=0x%02X", reset_type);
 
 	rc = reg_w(ov, R51x_SYS_RESET, reset_type);
 	rc = reg_w(ov, R51x_SYS_RESET, 0);
@@ -973,7 +854,7 @@
 
 /**********************************************************************
  *
- * I2C (sensor) I/O
+ * Low-level I2C I/O functions
  *
  **********************************************************************/
 
@@ -982,7 +863,7 @@
  * This is normally only called from i2c_w(). Note that this function
  * always succeeds regardless of whether the sensor is present and working.
  */
-static int 
+static int
 ov518_i2c_write_internal(struct usb_ov511 *ov,
 			 unsigned char reg,
 			 unsigned char value)
@@ -993,25 +874,21 @@
 
 	/* Select camera register */
 	rc = reg_w(ov, R51x_I2C_SADDR_3, reg);
-	if (rc < 0) goto error;
+	if (rc < 0) return rc;
 
 	/* Write "value" to I2C data port of OV511 */
 	rc = reg_w(ov, R51x_I2C_DATA, value);
-	if (rc < 0) goto error;
+	if (rc < 0) return rc;
 
 	/* Initiate 3-byte write cycle */
 	rc = reg_w(ov, R518_I2C_CTL, 0x01);
-	if (rc < 0) goto error;
+	if (rc < 0) return rc;
 
 	return 0;
-
-error:
-	err("ov518 i2c write: error %d", rc);
-	return rc;
 }
 
 /* NOTE: Do not call this function directly! */
-static int 
+static int
 ov511_i2c_write_internal(struct usb_ov511 *ov,
 			 unsigned char reg,
 			 unsigned char value)
@@ -1024,38 +901,33 @@
 	for (retries = OV511_I2C_RETRIES; ; ) {
 		/* Select camera register */
 		rc = reg_w(ov, R51x_I2C_SADDR_3, reg);
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		/* Write "value" to I2C data port of OV511 */
-		rc = reg_w(ov, R51x_I2C_DATA, value);	
-		if (rc < 0) goto error;
+		rc = reg_w(ov, R51x_I2C_DATA, value);
+		if (rc < 0) return rc;
 
 		/* Initiate 3-byte write cycle */
 		rc = reg_w(ov, R511_I2C_CTL, 0x01);
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		do rc = reg_r(ov, R511_I2C_CTL);
 		while (rc > 0 && ((rc&1) == 0)); /* Retry until idle */
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		if ((rc&2) == 0) /* Ack? */
 			break;
 #if 0
-		/* I2C abort */	
+		/* I2C abort */
 		reg_w(ov, R511_I2C_CTL, 0x10);
 #endif
 		if (--retries < 0) {
 			err("i2c write retries exhausted");
-			rc = -1;
-			goto error;
+			return -1;
 		}
 	}
 
 	return 0;
-
-error:
-	err("i2c write: error %d", rc);
-	return rc;
 }
 
 /* NOTE: Do not call this function directly!
@@ -1063,37 +935,33 @@
  * This is normally only called from i2c_r(). Note that this function
  * always succeeds regardless of whether the sensor is present and working.
  */
-static int 
+static int
 ov518_i2c_read_internal(struct usb_ov511 *ov, unsigned char reg)
 {
 	int rc, value;
 
 	/* Select camera register */
 	rc = reg_w(ov, R51x_I2C_SADDR_2, reg);
-	if (rc < 0) goto error;
+	if (rc < 0) return rc;
 
 	/* Initiate 2-byte write cycle */
 	rc = reg_w(ov, R518_I2C_CTL, 0x03);
-	if (rc < 0) goto error;
+	if (rc < 0) return rc;
 
 	/* Initiate 2-byte read cycle */
 	rc = reg_w(ov, R518_I2C_CTL, 0x05);
-	if (rc < 0) goto error;
+	if (rc < 0) return rc;
 
 	value = reg_r(ov, R51x_I2C_DATA);
 
 	PDEBUG(5, "0x%02X:0x%02X", reg, value);
 
 	return value;
-
-error:
-	err("ov518 i2c read: error %d", rc);
-	return rc;
 }
 
 /* NOTE: Do not call this function directly!
  * returns: negative is error, pos or zero is data */
-static int 
+static int
 ov511_i2c_read_internal(struct usb_ov511 *ov, unsigned char reg)
 {
 	int rc, value, retries;
@@ -1102,26 +970,25 @@
 	for (retries = OV511_I2C_RETRIES; ; ) {
 		/* Select camera register */
 		rc = reg_w(ov, R51x_I2C_SADDR_2, reg);
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		/* Initiate 2-byte write cycle */
 		rc = reg_w(ov, R511_I2C_CTL, 0x03);
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		do rc = reg_r(ov, R511_I2C_CTL);
 		while (rc > 0 && ((rc&1) == 0)); /* Retry until idle */
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		if ((rc&2) == 0) /* Ack? */
 			break;
 
-		/* I2C abort */	
+		/* I2C abort */
 		reg_w(ov, R511_I2C_CTL, 0x10);
 
 		if (--retries < 0) {
 			err("i2c write retries exhausted");
-			rc = -1;
-			goto error;
+			return -1;
 		}
 	}
 
@@ -1129,44 +996,39 @@
 	for (retries = OV511_I2C_RETRIES; ; ) {
 		/* Initiate 2-byte read cycle */
 		rc = reg_w(ov, R511_I2C_CTL, 0x05);
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		do rc = reg_r(ov, R511_I2C_CTL);
 		while (rc > 0 && ((rc&1) == 0)); /* Retry until idle */
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		if ((rc&2) == 0) /* Ack? */
 			break;
 
-		/* I2C abort */	
+		/* I2C abort */
 		rc = reg_w(ov, R511_I2C_CTL, 0x10);
-		if (rc < 0) goto error;
+		if (rc < 0) return rc;
 
 		if (--retries < 0) {
 			err("i2c read retries exhausted");
-			rc = -1;
-			goto error;
+			return -1;
 		}
 	}
 
 	value = reg_r(ov, R51x_I2C_DATA);
 
 	PDEBUG(5, "0x%02X:0x%02X", reg, value);
-		
+
 	/* This is needed to make i2c_w() work */
 	rc = reg_w(ov, R511_I2C_CTL, 0x05);
 	if (rc < 0)
-		goto error;
-	
-	return value;
+		return rc;
 
-error:
-	err("i2c read: error %d", rc);
-	return rc;
+	return value;
 }
 
 /* returns: negative is error, pos or zero is data */
-static int 
+static int
 i2c_r(struct usb_ov511 *ov, unsigned char reg)
 {
 	int rc;
@@ -1183,7 +1045,7 @@
 	return rc;
 }
 
-static int 
+static int
 i2c_w(struct usb_ov511 *ov, unsigned char reg, unsigned char value)
 {
 	int rc;
@@ -1201,7 +1063,7 @@
 }
 
 /* Do not call this function directly! */
-static int 
+static int
 ov51x_i2c_write_mask_internal(struct usb_ov511 *ov,
 			      unsigned char reg,
 			      unsigned char value,
@@ -1234,10 +1096,10 @@
 
 /* Writes bits at positions specified by mask to an I2C reg. Bits that are in
  * the same position as 1's in "mask" are cleared and set to "value". Bits
- * that are in the same position as 0's in "mask" are preserved, regardless 
+ * that are in the same position as 0's in "mask" are preserved, regardless
  * of their respective state in "value".
  */
-static int 
+static int
 i2c_w_mask(struct usb_ov511 *ov,
 	   unsigned char reg,
 	   unsigned char value,
@@ -1252,8 +1114,29 @@
 	return rc;
 }
 
+/* Set the read and write slave IDs. The "slave" argument is the write slave,
+ * and the read slave will be set to (slave + 1). ov->i2c_lock should be held
+ * when calling this. This should not be called from outside the i2c I/O
+ * functions.
+ */
+static inline int
+i2c_set_slave_internal(struct usb_ov511 *ov, unsigned char slave)
+{
+	int rc;
+
+	rc = reg_w(ov, R51x_I2C_W_SID, slave);
+	if (rc < 0) return rc;
+
+	rc = reg_w(ov, R51x_I2C_R_SID, slave + 1);
+	if (rc < 0) return rc;
+
+	return 0;
+}
+
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
+
 /* Write to a specific I2C slave ID and register, using the specified mask */
-static int 
+static int
 i2c_w_slave(struct usb_ov511 *ov,
 	    unsigned char slave,
 	    unsigned char reg,
@@ -1265,38 +1148,22 @@
 	down(&ov->i2c_lock);
 
 	/* Set new slave IDs */
-	if (reg_w(ov, R51x_I2C_W_SID, slave) < 0) {
-		rc = -EIO;
-		goto out;
-	}
-
-	if (reg_w(ov, R51x_I2C_R_SID, slave + 1) < 0) {
-		rc = -EIO;
-		goto out;
-	}
+	rc = i2c_set_slave_internal(ov, slave);
+	if (rc < 0) goto out;
 
 	rc = ov51x_i2c_write_mask_internal(ov, reg, value, mask);
-	/* Don't bail out yet if error; IDs must be restored */
 
+out:
 	/* Restore primary IDs */
-	slave = ov->primary_i2c_slave;
-	if (reg_w(ov, R51x_I2C_W_SID, slave) < 0) {
-		rc = -EIO;
-		goto out;
-	}
-
-	if (reg_w(ov, R51x_I2C_R_SID, slave + 1) < 0) {
-		rc = -EIO;
-		goto out;
-	}
+	if (i2c_set_slave_internal(ov, ov->primary_i2c_slave) < 0)
+		err("Couldn't restore primary I2C slave");
 
-out:
 	up(&ov->i2c_lock);
 	return rc;
 }
 
 /* Read from a specific I2C slave ID and register */
-static int 
+static int
 i2c_r_slave(struct usb_ov511 *ov,
 	    unsigned char slave,
 	    unsigned char reg)
@@ -1306,60 +1173,46 @@
 	down(&ov->i2c_lock);
 
 	/* Set new slave IDs */
-	if (reg_w(ov, R51x_I2C_W_SID, slave) < 0) {
-		rc = -EIO;
-		goto out;
-	}
-
-	if (reg_w(ov, R51x_I2C_R_SID, slave + 1) < 0) {
-		rc = -EIO;
-		goto out;
-	}
+	rc = i2c_set_slave_internal(ov, slave);
+	if (rc < 0) goto out;
 
 	if (ov->bclass == BCL_OV518)
 		rc = ov518_i2c_read_internal(ov, reg);
 	else
 		rc = ov511_i2c_read_internal(ov, reg);
-	/* Don't bail out yet if error; IDs must be restored */
 
+out:
 	/* Restore primary IDs */
-	slave = ov->primary_i2c_slave;
-	if (reg_w(ov, R51x_I2C_W_SID, slave) < 0) {
-		rc = -EIO;
-		goto out;
-	}
-
-	if (reg_w(ov, R51x_I2C_R_SID, slave + 1) < 0) {
-		rc = -EIO;
-		goto out;
-	}
+	if (i2c_set_slave_internal(ov, ov->primary_i2c_slave) < 0)
+		err("Couldn't restore primary I2C slave");
 
-out:
 	up(&ov->i2c_lock);
 	return rc;
 }
 
+#endif /* defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS) */
+
 /* Sets I2C read and write slave IDs. Returns <0 for error */
-static int 
+static int
 ov51x_set_slave_ids(struct usb_ov511 *ov, unsigned char sid)
 {
+	int rc;
+
 	down(&ov->i2c_lock);
 
-	if (reg_w(ov, R51x_I2C_W_SID, sid) < 0)
-		return -EIO;
+	rc = i2c_set_slave_internal(ov, sid);
+	if (rc < 0) goto out;
 
-	if (reg_w(ov, R51x_I2C_R_SID, sid + 1) < 0)
-		return -EIO;
-
-	if (ov51x_reset(ov, OV511_RESET_NOREGS) < 0)
-		return -EIO;
+	// FIXME: Is this actually necessary?
+	rc = ov51x_reset(ov, OV511_RESET_NOREGS);
+	if (rc < 0) goto out;
 
+out:
 	up(&ov->i2c_lock);
-
-	return 0;
+	return rc;
 }
 
-static int 
+static int
 write_regvals(struct usb_ov511 *ov, struct ov511_regvals * pRegvals)
 {
 	int rc;
@@ -1367,26 +1220,21 @@
 	while (pRegvals->bus != OV511_DONE_BUS) {
 		if (pRegvals->bus == OV511_REG_BUS) {
 			if ((rc = reg_w(ov, pRegvals->reg, pRegvals->val)) < 0)
-				goto error;
+				return rc;
 		} else if (pRegvals->bus == OV511_I2C_BUS) {
 			if ((rc = i2c_w(ov, pRegvals->reg, pRegvals->val)) < 0)
-				goto error;
+				return rc;
 		} else {
 			err("Bad regval array");
-			rc = -1;
-			goto error;
+			return -1;
 		}
 		pRegvals++;
 	}
 	return 0;
-
-error:
-	err("write regvals: error %d", rc);
-	return rc;
 }
 
-#ifdef OV511_DEBUG 
-static void 
+#ifdef OV511_DEBUG
+static void
 dump_i2c_range(struct usb_ov511 *ov, int reg1, int regn)
 {
 	int i;
@@ -1394,18 +1242,18 @@
 
 	for (i = reg1; i <= regn; i++) {
 		rc = i2c_r(ov, i);
-		info("OV7610[0x%X] = 0x%X", i, rc);
+		info("Sensor[0x%02X] = 0x%02X", i, rc);
 	}
 }
 
-static void 
+static void
 dump_i2c_regs(struct usb_ov511 *ov)
 {
 	info("I2C REGS");
 	dump_i2c_range(ov, 0x00, 0x7C);
 }
 
-static void 
+static void
 dump_reg_range(struct usb_ov511 *ov, int reg1, int regn)
 {
 	int i;
@@ -1413,12 +1261,12 @@
 
 	for (i = reg1; i <= regn; i++) {
 		rc = reg_r(ov, i);
-		info("OV511[0x%X] = 0x%X", i, rc);
+		info("OV511[0x%02X] = 0x%02X", i, rc);
 	}
 }
 
 /* FIXME: Should there be an OV518 version of this? */
-static void 
+static void
 ov511_dump_regs(struct usb_ov511 *ov)
 {
 	info("CAMERA INTERFACE REGS");
@@ -1445,43 +1293,29 @@
 }
 #endif
 
-/**********************************************************************
- *
- * Kernel I2C Interface
- *
- **********************************************************************/
-
-/* For as-yet unimplemented I2C interface */
-static void 
-call_i2c_clients(struct usb_ov511 *ov, unsigned int cmd,
-		 void *arg)
-{
-	/* Do nothing */
-}
-
 /*****************************************************************************/
 
 /* Temporarily stops OV511 from functioning. Must do this before changing
  * registers while the camera is streaming */
-static inline int 
+static inline int
 ov51x_stop(struct usb_ov511 *ov)
 {
 	PDEBUG(4, "stopping");
-	ov->stopped = 1;	
+	ov->stopped = 1;
 	if (ov->bclass == BCL_OV518)
-		return (reg_w(ov, R51x_SYS_RESET, 0x3a));
+		return (reg_w_mask(ov, R51x_SYS_RESET, 0x3a, 0x3a));
 	else
 		return (reg_w(ov, R51x_SYS_RESET, 0x3d));
 }
 
 /* Restarts OV511 after ov511_stop() is called. Has no effect if it is not
  * actually stopped (for performance). */
-static inline int 
+static inline int
 ov51x_restart(struct usb_ov511 *ov)
 {
 	if (ov->stopped) {
 		PDEBUG(4, "restarting");
-		ov->stopped = 0;	
+		ov->stopped = 0;
 
 		/* Reinitialize the stream */
 		if (ov->bclass == BCL_OV518)
@@ -1494,7 +1328,7 @@
 }
 
 /* Resets the hardware snapshot button */
-static void 
+static void
 ov51x_clear_snapshot(struct usb_ov511 *ov)
 {
 	if (ov->bclass == BCL_OV511) {
@@ -1506,12 +1340,12 @@
 	} else {
 		err("clear snap: invalid bridge type");
 	}
-	
 }
 
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
 /* Checks the status of the snapshot button. Returns 1 if it was pressed since
  * it was last cleared, and zero in all other cases (including errors) */
-static int 
+static int
 ov51x_check_snapshot(struct usb_ov511 *ov)
 {
 	int ret, status = 0;
@@ -1531,19 +1365,20 @@
 
 	return status;
 }
+#endif
 
 /* This does an initial reset of an OmniVision sensor and ensures that I2C
  * is synchronized. Returns <0 for failure.
  */
-static int 
+static int
 init_ov_sensor(struct usb_ov511 *ov)
 {
 	int i, success;
 
-	/* Reset the sensor */ 
+	/* Reset the sensor */
 	if (i2c_w(ov, 0x12, 0x80) < 0) return -EIO;
 
-	/* Wait for it to initialize */ 
+	/* Wait for it to initialize */
 	schedule_timeout (1 + 150 * HZ / 1000);
 
 	for (i = 0, success = 0; i < i2c_detect_tries && !success; i++) {
@@ -1553,9 +1388,9 @@
 			continue;
 		}
 
-		/* Reset the sensor */ 
+		/* Reset the sensor */
 		if (i2c_w(ov, 0x12, 0x80) < 0) return -EIO;
-		/* Wait for it to initialize */ 
+		/* Wait for it to initialize */
 		schedule_timeout(1 + 150 * HZ / 1000);
 		/* Dummy read to sync I2C */
 		if (i2c_r(ov, 0x00) < 0) return -EIO;
@@ -1563,14 +1398,14 @@
 
 	if (!success)
 		return -EIO;
-	
+
 	PDEBUG(1, "I2C synced in %d attempt(s)", i);
 
 	return 0;
 }
 
-static int 
-ov51x_set_packet_size(struct usb_ov511 *ov, int size)
+static int
+ov511_set_packet_size(struct usb_ov511 *ov, int size)
 {
 	int alt, mult;
 
@@ -1602,7 +1437,44 @@
 			err("Set packet size: invalid size (%d)", size);
 			return -EINVAL;
 		}
-	} else if (ov->bclass == BCL_OV518) {
+	} else {
+		err("Set packet size: Invalid bridge type");
+		return -EINVAL;
+	}
+
+	PDEBUG(3, "%d, mult=%d, alt=%d", size, mult, alt);
+
+	if (reg_w(ov, R51x_FIFO_PSIZE, mult) < 0)
+		return -EIO;
+
+	if (usb_set_interface(ov->dev, ov->iface, alt) < 0) {
+		err("Set packet size: set interface error");
+		return -EBUSY;
+	}
+
+	if (ov51x_reset(ov, OV511_RESET_NOREGS) < 0)
+		return -EIO;
+
+	ov->packet_size = size;
+
+	if (ov51x_restart(ov) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+/* Note: Unlike the OV511/OV511+, the size argument does NOT include the
+ * optional packet number byte. The actual size *is* stored in ov->packet_size,
+ * though. */
+static int
+ov518_set_packet_size(struct usb_ov511 *ov, int size)
+{
+	int alt;
+
+	if (ov51x_stop(ov) < 0)
+		return -EIO;
+
+	if (ov->bclass == BCL_OV518) {
 		if (size == 0) alt = OV518_ALT_SIZE_0;
 		else if (size == 128) alt = OV518_ALT_SIZE_128;
 		else if (size == 256) alt = OV518_ALT_SIZE_256;
@@ -1620,35 +1492,32 @@
 		return -EINVAL;
 	}
 
-	PDEBUG(3, "set packet size: %d, mult=%d, alt=%d", size, mult, alt);
+	PDEBUG(3, "%d, alt=%d", size, alt);
 
-	// FIXME: Don't know how to do this on OV518 yet
-	if (ov->bclass == BCL_OV511) {
-		if (reg_w(ov, R51x_FIFO_PSIZE,
-				    mult) < 0) {
-			return -EIO;
-		}
+	ov->packet_size = size;
+	if (size > 0) {
+		/* Program ISO FIFO size reg (packet number isn't included) */
+		ov518_reg_w32(ov, 0x30, size, 2);
+
+		if (ov->packet_numbering)
+			++ov->packet_size;
 	}
-	
+
 	if (usb_set_interface(ov->dev, ov->iface, alt) < 0) {
 		err("Set packet size: set interface error");
 		return -EBUSY;
 	}
 
 	/* Initialize the stream */
-	if (ov->bclass == BCL_OV518)
-		if (reg_w(ov, 0x2f, 0x80) < 0)
-			return -EIO;
-
-	// FIXME - Should we only reset the FIFO?
-	if (ov51x_reset(ov, OV511_RESET_NOREGS) < 0)
+	if (reg_w(ov, 0x2f, 0x80) < 0)
 		return -EIO;
 
-	ov->packet_size = size;
-
 	if (ov51x_restart(ov) < 0)
 		return -EIO;
 
+	if (ov51x_reset(ov, OV511_RESET_NOREGS) < 0)
+		return -EIO;
+
 	return 0;
 }
 
@@ -1659,7 +1528,6 @@
 	int rc = 0;
 
 	if (!ov->compress_inited) {
-
 		reg_w(ov, 0x70, phy);
 		reg_w(ov, 0x71, phuv);
 		reg_w(ov, 0x72, pvy);
@@ -1677,7 +1545,7 @@
 	}
 
 	ov->compress_inited = 1;
-out:	
+out:
 	return rc;
 }
 
@@ -1688,7 +1556,6 @@
 	int rc = 0;
 
 	if (!ov->compress_inited) {
-
 		if (ov518_upload_quan_tables(ov) < 0) {
 			err("Error uploading quantization tables");
 			rc = -EIO;
@@ -1697,7 +1564,7 @@
 	}
 
 	ov->compress_inited = 1;
-out:	
+out:
 	return rc;
 }
 
@@ -1718,13 +1585,19 @@
 	switch (ov->sensor) {
 	case SEN_OV7610:
 	case SEN_OV6620:
-	case SEN_OV6630:
 	{
 		rc = i2c_w(ov, OV7610_REG_CNT, val >> 8);
 		if (rc < 0)
 			goto out;
 		break;
 	}
+	case SEN_OV6630:
+	{
+		rc = i2c_w_mask(ov, OV7610_REG_CNT, val >> 12, 0x0f);
+		if (rc < 0)
+			goto out;
+		break;
+	}
 	case SEN_OV7620:
 	{
 		unsigned char ctab[] = {
@@ -1771,13 +1644,19 @@
 	switch (ov->sensor) {
 	case SEN_OV7610:
 	case SEN_OV6620:
-	case SEN_OV6630:
 		rc = i2c_r(ov, OV7610_REG_CNT);
 		if (rc < 0)
 			return rc;
 		else
 			*val = rc << 8;
 		break;
+	case SEN_OV6630:
+		rc = i2c_r(ov, OV7610_REG_CNT);
+		if (rc < 0)
+			return rc;
+		else
+			*val = rc << 12;
+		break;
 	case SEN_OV7620:
 		/* Use Y gamma reg instead. Bit 0 is the enable bit. */
 		rc = i2c_r(ov, 0x64);
@@ -1816,7 +1695,7 @@
 
 	switch (ov->sensor) {
 	case SEN_OV7610:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV6620:
 	case SEN_OV6630:
 		rc = i2c_w(ov, OV7610_REG_BRT, val >> 8);
@@ -1859,7 +1738,7 @@
 
 	switch (ov->sensor) {
 	case SEN_OV7610:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV7620:
 	case SEN_OV6620:
 	case SEN_OV6630:
@@ -1899,7 +1778,7 @@
 
 	switch (ov->sensor) {
 	case SEN_OV7610:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV6620:
 	case SEN_OV6630:
 		rc = i2c_w(ov, OV7610_REG_SAT, val >> 8);
@@ -1943,7 +1822,7 @@
 
 	switch (ov->sensor) {
 	case SEN_OV7610:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV6620:
 	case SEN_OV6630:
 		rc = i2c_r(ov, OV7610_REG_SAT);
@@ -2142,6 +2021,7 @@
 	return 0;
 }
 
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
 // FIXME: Exposure range is only 0x00-0x7f in interlace mode
 /* Sets current exposure for sensor. This only has an effect if auto-exposure
  * is off */
@@ -2161,7 +2041,7 @@
 	case SEN_OV6630:
 	case SEN_OV7610:
 	case SEN_OV7620:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV8600:
 		rc = i2c_w(ov, 0x10, val);
 		if (rc < 0)
@@ -2199,7 +2079,7 @@
 	case SEN_OV6620:
 	case SEN_OV6630:
 	case SEN_OV7620:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV8600:
 		rc = i2c_r(ov, 0x10);
 		if (rc < 0)
@@ -2223,9 +2103,10 @@
 
 	return 0;
 }
+#endif /* CONFIG_PROC_FS && CONFIG_VIDEO_PROC_FS */
 
 /* Turns on or off the LED. Only has an effect with OV511+/OV518(+) */
-static inline void 
+static inline void
 ov51x_led_control(struct usb_ov511 *ov, int enable)
 {
 	PDEBUG(4, " (%s)", enable ? "turn on" : "turn off");
@@ -2243,7 +2124,7 @@
  *	50 - 50Hz, for European and Asian lighting
  *	60 - 60Hz, for American lighting
  *
- * Tested with: OV7610, OV7620, OV7620AE, OV6620
+ * Tested with: OV7610, OV7620, OV76BE, OV6620
  * Unsupported: KS0127, KS0127B, SAA7111A
  * Returns: 0 for success
  */
@@ -2271,12 +2152,12 @@
 		i2c_w_mask(ov, 0x13, 0x00, 0x10);
 		break;
 	case SEN_OV7620:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV8600:
 		i2c_w_mask(ov, 0x2a, sixty?0x00:0x80, 0x80);
 		i2c_w(ov, 0x2b, sixty?0x00:0xac);
 		i2c_w_mask(ov, 0x76, 0x01, 0x01);
-		break;		
+		break;
 	case SEN_OV6620:
 	case SEN_OV6630:
 		i2c_w(ov, 0x2b, sixty?0xa8:0x28);
@@ -2302,7 +2183,7 @@
  * caused by some (usually fluorescent) lighting. The light frequency must be
  * set either before or after enabling it with ov51x_set_light_freq().
  *
- * Tested with: OV7610, OV7620, OV7620AE, OV6620.
+ * Tested with: OV7610, OV7620, OV76BE, OV6620.
  * Unsupported: KS0127, KS0127B, SAA7111A
  * Returns: 0 for success
  */
@@ -2364,7 +2245,7 @@
  */
 static inline int
 sensor_set_auto_exposure(struct usb_ov511 *ov, int enable)
-{	
+{
 	PDEBUG(4, " (%s)", enable ? "turn on" : "turn off");
 
 	switch (ov->sensor) {
@@ -2373,10 +2254,10 @@
 		break;
 	case SEN_OV6620:
 	case SEN_OV7620:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV8600:
 		i2c_w_mask(ov, 0x13, enable?0x01:0x00, 0x01);
-		break;		
+		break;
 	case SEN_OV6630:
 		i2c_w_mask(ov, 0x28, enable?0x00:0x10, 0x10);
 		break;
@@ -2399,13 +2280,12 @@
  * that are illuminated from behind.
  *
  * Tested with: OV6620, OV7620
- * Unsupported: OV7610, OV7620AE, KS0127, KS0127B, SAA7111A
+ * Unsupported: OV7610, OV76BE, KS0127, KS0127B, SAA7111A
  * Returns: 0 for success
  */
 static int
 sensor_set_backlight(struct usb_ov511 *ov, int enable)
 {
-
 	PDEBUG(4, " (%s)", enable ? "turn on" : "turn off");
 
 	switch (ov->sensor) {
@@ -2414,7 +2294,7 @@
 		i2c_w_mask(ov, 0x68, enable?0xe0:0xc0, 0xe0);
 		i2c_w_mask(ov, 0x29, enable?0x08:0x00, 0x08);
 		i2c_w_mask(ov, 0x28, enable?0x02:0x00, 0x02);
-		break;		
+		break;
 	case SEN_OV6620:
 		i2c_w_mask(ov, 0x4e, enable?0xe0:0xc0, 0xe0);
 		i2c_w_mask(ov, 0x29, enable?0x08:0x00, 0x08);
@@ -2426,7 +2306,7 @@
 		i2c_w_mask(ov, 0x28, enable?0x02:0x00, 0x02);
 		break;
 	case SEN_OV7610:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_KS0127:
 	case SEN_KS0127B:
 	case SEN_SAA7111A:
@@ -2442,27 +2322,56 @@
 	return 0;
 }
 
+static inline int
+sensor_set_mirror(struct usb_ov511 *ov, int enable)
+{
+	PDEBUG(4, " (%s)", enable ? "turn on" : "turn off");
+
+	switch (ov->sensor) {
+	case SEN_OV6620:
+	case SEN_OV6630:
+	case SEN_OV7610:
+	case SEN_OV7620:
+	case SEN_OV76BE:
+	case SEN_OV8600:
+		i2c_w_mask(ov, 0x12, enable?0x40:0x00, 0x40);
+		break;
+	case SEN_KS0127:
+	case SEN_KS0127B:
+	case SEN_SAA7111A:
+		PDEBUG(5, "Unsupported with this sensor");
+		return -EPERM;
+	default:
+		err("Sensor not supported for set_mirror");
+		return -EINVAL;
+	}
+
+	ov->mirror = enable;
+
+	return 0;
+}
+
 /* Returns number of bits per pixel (regardless of where they are located;
  * planar or not), or zero for unsupported format.
  */
-static inline int 
+static inline int
 get_depth(int palette)
 {
 	switch (palette) {
 	case VIDEO_PALETTE_GREY:    return 8;
+	case VIDEO_PALETTE_YUV420:  return 12;
+	case VIDEO_PALETTE_YUV420P: return 12; /* Planar */
 	case VIDEO_PALETTE_RGB565:  return 16;
-	case VIDEO_PALETTE_RGB24:   return 24;  
+	case VIDEO_PALETTE_RGB24:   return 24;
 	case VIDEO_PALETTE_YUV422:  return 16;
 	case VIDEO_PALETTE_YUYV:    return 16;
-	case VIDEO_PALETTE_YUV420:  return 12;
 	case VIDEO_PALETTE_YUV422P: return 16; /* Planar */
-	case VIDEO_PALETTE_YUV420P: return 12; /* Planar */
 	default:		    return 0;  /* Invalid format */
 	}
 }
 
 /* Bytes per frame. Used by read(). Return of 0 indicates error */
-static inline long int 
+static inline long int
 get_frame_length(struct ov511_frame *frame)
 {
 	if (!frame)
@@ -2502,7 +2411,7 @@
 		i2c_w_mask(ov, 0x67, qvga?0xf0:0x90, 0xf0);
 		i2c_w_mask(ov, 0x74, qvga?0x20:0x00, 0x20);
 		break;
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 //		i2c_w(ov, 0x2b, 0x00);
 		i2c_w(ov, 0x14, qvga?0xa4:0x84);
 // FIXME: Enable this once 7620AE uses 7620 initial settings
@@ -2528,13 +2437,13 @@
 	/******** Palette-specific regs ********/
 
 	if (mode == VIDEO_PALETTE_GREY) {
-		if (ov->sensor == SEN_OV7610 || ov->sensor == SEN_OV7620AE) {
+		if (ov->sensor == SEN_OV7610 || ov->sensor == SEN_OV76BE) {
 			/* these aren't valid on the OV6620/OV7620/6630? */
 			i2c_w_mask(ov, 0x0e, 0x40, 0x40);
 		}
 		i2c_w_mask(ov, 0x13, 0x20, 0x20);
 	} else {
-		if (ov->sensor == SEN_OV7610 || ov->sensor == SEN_OV7620AE) {
+		if (ov->sensor == SEN_OV7610 || ov->sensor == SEN_OV76BE) {
 			/* not valid on the OV6620/OV7620/6630? */
 			i2c_w_mask(ov, 0x0e, 0x00, 0x40);
 		}
@@ -2596,8 +2505,7 @@
 	if (framedrop >= 0)
 		i2c_w(ov, 0x16, framedrop);
 
-	/* We only have code to convert GBR -> RGB24 */
-	if ((mode == VIDEO_PALETTE_RGB24) && sensor_gbr)
+	if (sensor_gbr)
 		i2c_w_mask(ov, 0x12, 0x08, 0x08);
 	else
 		i2c_w_mask(ov, 0x12, 0x00, 0x08);
@@ -2614,7 +2522,7 @@
 	// This will go away as soon as ov51x_mode_init_sensor_regs()
 	// is fully tested.
 	/* 7620/6620/6630? don't have register 0x35, so play it safe */
-	if (ov->sensor == SEN_OV7610 || ov->sensor == SEN_OV7620AE) {
+	if (ov->sensor == SEN_OV7610 || ov->sensor == SEN_OV76BE) {
 		if (width == 640 && height == 480)
 			i2c_w(ov, 0x35, 0x9e);
 		else
@@ -2636,13 +2544,13 @@
 	 * IF YOU SET IT WRONG, YOU WILL GET ALL ZERO ISOC DATA FROM OV51x!!! */
 	switch (ov->sensor) {
 	case SEN_OV7610:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 		hwsbase = 0x38;
 		hwebase = 0x3a;
 		vwsbase = vwebase = 0x05;
 		break;
 	case SEN_OV6620:
-	case SEN_OV6630:	// FIXME: Is this right?
+	case SEN_OV6630:
 		hwsbase = 0x38;
 		hwebase = 0x3a;
 		vwsbase = 0x05;
@@ -2659,7 +2567,9 @@
 	}
 
 	if (ov->sensor == SEN_OV6620 || ov->sensor == SEN_OV6630) {
-		if (width > 176 && height > 144) {  /* CIF */
+		/* Note: OV518(+) does downsample on its own) */
+		if ((width > 176 && height > 144)
+		    || ov->bclass == BCL_OV518) {  /* CIF */
 			ret = mode_init_ov_sensor_regs(ov, width, height,
 				mode, sub_flag, 0);
 			if (ret < 0)
@@ -2736,7 +2646,7 @@
 ov511_mode_init_regs(struct usb_ov511 *ov,
 		     int width, int height, int mode, int sub_flag)
 {
-	int lncnt, pxcnt, rc = 0;
+	int hsegs, vsegs;
 
 	if (sub_flag) {
 		width = ov->subw;
@@ -2752,11 +2662,11 @@
 		if (width == 320 && height == 240) {
 			/* No need to do anything special */
 		} else if (width == 640 && height == 480) {
-			/* Set the OV511 up as 320x480, but keep the V4L
-			 * resolution as 640x480 */
+			/* Set the OV511 up as 320x480, but keep the
+			 * V4L resolution as 640x480 */
 			width = 320;
 		} else {
-			err("SAA7111A only supports 320x240 or 640x480");
+			err("SAA7111A only allows 320x240 or 640x480");
 			return -EINVAL;
 		}
 	}
@@ -2788,11 +2698,11 @@
 	/* Here I'm assuming that snapshot size == image size.
 	 * I hope that's always true. --claudio
 	 */
-	pxcnt = (width >> 3) - 1;
-	lncnt = (height >> 3) - 1;
+	hsegs = (width >> 3) - 1;
+	vsegs = (height >> 3) - 1;
 
-	reg_w(ov, R511_CAM_PXCNT, pxcnt);
-	reg_w(ov, R511_CAM_LNCNT, lncnt);
+	reg_w(ov, R511_CAM_PXCNT, hsegs);
+	reg_w(ov, R511_CAM_LNCNT, vsegs);
 	reg_w(ov, R511_CAM_PXDIV, 0x00);
 	reg_w(ov, R511_CAM_LNDIV, 0x00);
 
@@ -2800,8 +2710,8 @@
 	reg_w(ov, R511_CAM_OPTS, 0x03);
 
 	/* Snapshot additions */
-	reg_w(ov, R511_SNAP_PXCNT, pxcnt);
-	reg_w(ov, R511_SNAP_LNCNT, lncnt);
+	reg_w(ov, R511_SNAP_PXCNT, hsegs);
+	reg_w(ov, R511_SNAP_LNCNT, vsegs);
 	reg_w(ov, R511_SNAP_PXDIV, 0x00);
 	reg_w(ov, R511_SNAP_LNDIV, 0x00);
 
@@ -2811,27 +2721,17 @@
 		reg_w(ov, R511_COMP_LUT_EN, 0x03);
 		ov51x_reset(ov, OV511_RESET_OMNICE);
 	}
-//out:
+
 	if (ov51x_restart(ov) < 0)
 		return -EIO;
 
-	return rc;
+	return 0;
 }
 
-static struct mode_list_518 mlist518[] = {
-	/* W    H   reg28 reg29 reg2a reg2c reg2e reg24 reg25 */
-	{ 352, 288, 0x00, 0x16, 0x48, 0x00, 0x00, 0x9f, 0x90 },
-	{ 320, 240, 0x00, 0x14, 0x3c, 0x10, 0x18, 0x9f, 0x90 },
-	{ 176, 144, 0x05, 0x0b, 0x24, 0x00, 0x00, 0xff, 0xf0 },
-	{ 160, 120, 0x05, 0x0a, 0x1e, 0x08, 0x0c, 0xff, 0xf0 },
-	{ 0, 0 }
-};
-
 /* Sets up the OV518/OV518+ with the given image parameters
  *
  * OV518 needs a completely different approach, until we can figure out what
- * the individual registers do. Many register ops are commented out until we
- * can find out if they are still valid. Also, only 15 FPS is supported now.
+ * the individual registers do. Also, only 15 FPS is supported now.
  *
  * Do not put any sensor-specific code in here (including I2C I/O functions)
  */
@@ -2839,112 +2739,110 @@
 ov518_mode_init_regs(struct usb_ov511 *ov,
 		     int width, int height, int mode, int sub_flag)
 {
-	int i;
+	int hsegs, vsegs, hi_res;
+
+	if (sub_flag) {
+		width = ov->subw;
+		height = ov->subh;
+	}
 
 	PDEBUG(3, "width:%d, height:%d, mode:%d, sub:%d",
 	       width, height, mode, sub_flag);
 
+	if (width % 16 || height % 8) {
+		err("Invalid size (%d, %d)", width, height);
+		return -EINVAL;
+	}
+
+	if (width < ov->minwidth || height < ov->minheight) {
+		err("Requested dimensions are too small");
+		return -EINVAL;
+	}
+
+	if (width >= 320 && height >= 240) {
+		hi_res = 1;
+	} else if (width >= 320 || height >= 240) {
+		err("Invalid width/height combination (%d, %d)", width, height);
+		return -EINVAL;
+	} else {
+		hi_res = 0;
+	}
+
 	if (ov51x_stop(ov) < 0)
 		return -EIO;
 
-	for (i = 0; mlist518[i].width; i++) {
-//		int lncnt, pxcnt;
+	/******** Set the mode ********/
 
-		if (width != mlist518[i].width || height != mlist518[i].height)
-			continue;
+	reg_w(ov, 0x2b, 0);
+	reg_w(ov, 0x2c, 0);
+	reg_w(ov, 0x2d, 0);
+	reg_w(ov, 0x2e, 0);
+	reg_w(ov, 0x3b, 0);
+	reg_w(ov, 0x3c, 0);
+	reg_w(ov, 0x3d, 0);
+	reg_w(ov, 0x3e, 0);
 
-// FIXME: Subcapture won't be possible until we know what the registers do
-// FIXME: We can't handle anything but YUV420 so far
+	reg_w(ov, 0x28, (mode == VIDEO_PALETTE_GREY) ? 0x00:0x80);
+	reg_w(ov, 0x38, (mode == VIDEO_PALETTE_GREY) ? 0x00:0x80);
 
-//		/* Here I'm assuming that snapshot size == image size.
-//		 * I hope that's always true. --claudio
-//		 */
-//		pxcnt = sub_flag ? (ov511->subw >> 3) - 1 : mlist[i].pxcnt;
-//		lncnt = sub_flag ? (ov511->subh >> 3) - 1 : mlist[i].lncnt;
-//
-//		reg_w(ov511, 0x12, pxcnt);
-//		reg_w(ov511, 0x13, lncnt);
-
-		/******** Set the mode ********/		
-
-		/* Mode independent regs */
-		reg_w(ov, 0x2b, 0x00);
-		reg_w(ov, 0x2d, 0x00);
-		reg_w(ov, 0x3b, 0x00);
-		reg_w(ov, 0x3d, 0x00);
-
-		/* Mode dependent regs. Regs 38 - 3e are always the same as
-		 * regs 28 - 2e */
-		reg_w_mask(ov, 0x28, mlist518[i].reg28
-			| (mode == VIDEO_PALETTE_GREY) ? 0x80:0x00, 0x8f);
-		reg_w(ov, 0x29, mlist518[i].reg29);
-		reg_w(ov, 0x2a, mlist518[i].reg2a);
-		reg_w(ov, 0x2c, mlist518[i].reg2c);
-		reg_w(ov, 0x2e, mlist518[i].reg2e);
-		reg_w_mask(ov, 0x38, mlist518[i].reg28 
-			| (mode == VIDEO_PALETTE_GREY) ? 0x80:0x00, 0x8f);
-		reg_w(ov, 0x39, mlist518[i].reg29);
-		reg_w(ov, 0x3a, mlist518[i].reg2a);
-		reg_w(ov, 0x3c, mlist518[i].reg2c);
-		reg_w(ov, 0x3e, mlist518[i].reg2e);
-		reg_w(ov, 0x24, mlist518[i].reg24);
-		reg_w(ov, 0x25, mlist518[i].reg25);
-
-		/* Windows driver does this here; who knows why */
-		reg_w(ov, 0x2f, 0x80);
-
-		/******** Set the framerate (to 15 FPS) ********/		
-
-		/* Mode independent, but framerate dependent, regs */
-		/* These are for 15 FPS only */
-		reg_w(ov, 0x51, 0x08);
-		reg_w(ov, 0x22, 0x18);
-		reg_w(ov, 0x23, 0xff);
-		reg_w(ov, 0x71, 0x19);  /* Compression-related? */
-
-		// FIXME: Sensor-specific
-		/* Bit 5 is what matters here. Of course, it is "reserved" */
-		i2c_w(ov, 0x54, 0x23);
-
-		reg_w(ov, 0x2f, 0x80);
-
-		/* Mode dependent regs */
-		if ((width == 352 && height == 288) ||
-		    (width == 320 && height == 240)) {
-			/*  640 (280h) byte iso packets */
-			ov518_reg_w32(ov, 0x30,    640, 2);	/* 280h   */
-			ov518_reg_w32(ov, 0xc4,    400, 2);	/* 190h   */
-			ov518_reg_w32(ov, 0xc6,    500, 2);	/* 1f4h   */
-			ov518_reg_w32(ov, 0xc7,    500, 2);	/* 1f4h   */
-			ov518_reg_w32(ov, 0xc8,    142, 2);	/* 8eh    */
-			ov518_reg_w32(ov, 0xca, 131098, 3);	/* 2001ah */
-			ov518_reg_w32(ov, 0xcb,    532, 2);	/* 214h   */
-			ov518_reg_w32(ov, 0xcc,   2000, 2);	/* 7d0h   */
-			ov518_reg_w32(ov, 0xcd,     32, 2);	/* 20h    */
-			ov518_reg_w32(ov, 0xce,    608, 2);	/* 260h   */
-		} else if ((width == 176 && height == 144) ||
-			   (width == 160 && height == 120)) {
-			/*  384 (180h) byte iso packets */
-			ov518_reg_w32(ov, 0x30,    384, 2);	/* 180h   */
-			ov518_reg_w32(ov, 0xc4,    200, 2);	/* c8h    */
-			ov518_reg_w32(ov, 0xc6,    320, 2);	/* 140h   */
-			ov518_reg_w32(ov, 0xc7,    320, 2);	/* 140h   */
-			ov518_reg_w32(ov, 0xc8,     96, 2);	/* 60h    */
-			ov518_reg_w32(ov, 0xca,  78607, 3);	/* 1330fh */
-			ov518_reg_w32(ov, 0xcb,    320, 2);	/* 140h   */
-			ov518_reg_w32(ov, 0xcc,   1260, 2);	/* 4ech   */
-			ov518_reg_w32(ov, 0xcd,     19, 2);	/* 13h    */
-			ov518_reg_w32(ov, 0xce,    365, 2);	/* 16dh   */
-		} else {
-			/* Can't happen, since we already handled this case */
-			err("ov518_mode_init_regs(): **** logic error ****");
-		}
+	hsegs = width / 16;
+	vsegs = height / 4;
 
-		reg_w(ov, 0x2f, 0x80);
+	reg_w(ov, 0x29, hsegs);
+	reg_w(ov, 0x2a, vsegs);
 
-		break;
+	reg_w(ov, 0x39, hsegs);
+	reg_w(ov, 0x3a, vsegs);
+
+	/* Windows driver does this here; who knows why */
+	reg_w(ov, 0x2f, 0x80);
+
+	/******** Set the framerate (to 15 FPS) ********/
+
+	/* Mode independent, but framerate dependent, regs */
+	reg_w(ov, 0x51, 0x02);	/* Clock divider; lower==faster */
+	reg_w(ov, 0x22, 0x18);
+	reg_w(ov, 0x23, 0xff);
+
+	if (ov->bridge == BRG_OV518PLUS)
+		reg_w(ov, 0x21, 0x19);
+	else
+		reg_w(ov, 0x71, 0x19);	/* Compression-related? */
+
+	// FIXME: Sensor-specific
+	/* Bit 5 is what matters here. Of course, it is "reserved" */
+	i2c_w(ov, 0x54, 0x23);
+
+	reg_w(ov, 0x2f, 0x80);
+
+	if (ov->bridge == BRG_OV518PLUS) {
+		reg_w(ov, 0x24, 0x94);
+		reg_w(ov, 0x25, 0x90);
+		ov518_reg_w32(ov, 0xc4,    400, 2);	/* 190h   */
+		ov518_reg_w32(ov, 0xc6,    540, 2);	/* 21ch   */
+		ov518_reg_w32(ov, 0xc7,    540, 2);	/* 21ch   */
+		ov518_reg_w32(ov, 0xc8,    108, 2);	/* 6ch    */
+		ov518_reg_w32(ov, 0xca, 131098, 3);	/* 2001ah */
+		ov518_reg_w32(ov, 0xcb,    532, 2);	/* 214h   */
+		ov518_reg_w32(ov, 0xcc,   2400, 2);	/* 960h   */
+		ov518_reg_w32(ov, 0xcd,     32, 2);	/* 20h    */
+		ov518_reg_w32(ov, 0xce,    608, 2);	/* 260h   */
+	} else {
+		reg_w(ov, 0x24, 0x9f);
+		reg_w(ov, 0x25, 0x90);
+		ov518_reg_w32(ov, 0xc4,    400, 2);	/* 190h   */
+		ov518_reg_w32(ov, 0xc6,    500, 2);	/* 1f4h   */
+		ov518_reg_w32(ov, 0xc7,    500, 2);	/* 1f4h   */
+		ov518_reg_w32(ov, 0xc8,    142, 2);	/* 8eh    */
+		ov518_reg_w32(ov, 0xca, 131098, 3);	/* 2001ah */
+		ov518_reg_w32(ov, 0xcb,    532, 2);	/* 214h   */
+		ov518_reg_w32(ov, 0xcc,   2000, 2);	/* 7d0h   */
+		ov518_reg_w32(ov, 0xcd,     32, 2);	/* 20h    */
+		ov518_reg_w32(ov, 0xce,    608, 2);	/* 260h   */
 	}
 
+	reg_w(ov, 0x2f, 0x80);
+
 	if (ov51x_restart(ov) < 0)
 		return -EIO;
 
@@ -2952,11 +2850,6 @@
 	if (ov51x_reset(ov, OV511_RESET_NOREGS) < 0)
 		return -EIO;
 
-	if (mlist518[i].width == 0) {
-		err("Unknown mode (%d, %d): %d", width, height, mode);
-		return -EINVAL;
-	}
-
 	return 0;
 }
 
@@ -2982,7 +2875,7 @@
 	switch (ov->sensor) {
 	case SEN_OV7610:
 	case SEN_OV7620:
-	case SEN_OV7620AE:
+	case SEN_OV76BE:
 	case SEN_OV8600:
 	case SEN_OV6620:
 	case SEN_OV6630:
@@ -2994,10 +2887,10 @@
 		rc = -EINVAL;
 		break;
 	case SEN_SAA7111A:
-//		rc = mode_init_saa_sensor_regs(ov, width, height, mode, 
+//		rc = mode_init_saa_sensor_regs(ov, width, height, mode,
 //					       sub_flag);
 
-		PDEBUG(1, "SAA status = 0X%x", i2c_r(ov, 0x1f));
+		PDEBUG(1, "SAA status = 0x%02X", i2c_r(ov, 0x1f));
 		break;
 	default:
 		err("Unknown sensor");
@@ -3030,19 +2923,21 @@
 	if (FATAL_ERROR(rc))
 		return rc;
 
+	rc = sensor_set_mirror(ov, ov->mirror);
+	if (FATAL_ERROR(rc))
+		return rc;
+
 	return 0;
 }
 
-/* This sets the default image parameters (Size = max, RGB24). This is
- * useful for apps that use read() and do not set these.
+/* This sets the default image parameters. This is useful for apps that use
+ * read() and do not set these.
  */
-static int 
+static int
 ov51x_set_default_params(struct usb_ov511 *ov)
 {
 	int i;
 
-	PDEBUG(3, "%dx%d, RGB24", ov->maxwidth, ov->maxheight);
-
 	/* Set default sizes in case IOCTL (VIDIOCMCAPTURE) is not used
 	 * (using read() instead). */
 	for (i = 0; i < OV511_NUMFRAMES; i++) {
@@ -3053,10 +2948,14 @@
 			ov->frame[i].format = force_palette;
 		else
 			ov->frame[i].format = VIDEO_PALETTE_RGB24;
+
 		ov->frame[i].depth = get_depth(ov->frame[i].format);
 	}
 
-	/* Initialize to max width/height, RGB24 */
+	PDEBUG(3, "%dx%d, %s", ov->maxwidth, ov->maxheight,
+	       symbolic(v4l1_plist, ov->frame[0].format));
+
+	/* Initialize to max width/height, YUV420 or RGB24 (if supported) */
 	if (mode_init_regs(ov, ov->maxwidth, ov->maxheight,
 			   ov->frame[0].format, 0) < 0)
 		return -EINVAL;
@@ -3071,7 +2970,7 @@
  **********************************************************************/
 
 /* Set analog input port of decoder */
-static int 
+static int
 decoder_set_input(struct usb_ov511 *ov, int input)
 {
 	PDEBUG(4, "port %d", input);
@@ -3093,7 +2992,7 @@
 }
 
 /* Get ASCII name of video input */
-static int 
+static int
 decoder_get_input_name(struct usb_ov511 *ov, int input, char *name)
 {
 	switch (ov->sensor) {
@@ -3105,7 +3004,6 @@
 			sprintf(name, "CVBS-%d", input);
 		else // if (input < 8)
 			sprintf(name, "S-Video-%d", input - 4);
-
 		break;
 	}
 	default:
@@ -3116,7 +3014,7 @@
 }
 
 /* Set norm (NTSC, PAL, SECAM, AUTO) */
-static int 
+static int
 decoder_set_norm(struct usb_ov511 *ov, int norm)
 {
 	PDEBUG(4, "%d", norm);
@@ -3131,7 +3029,7 @@
 			reg_e = 0x00;	/* NTSC M / PAL BGHI */
 		} else if (norm == VIDEO_MODE_PAL) {
 			reg_8 = 0x00;	/* 50 Hz */
-			reg_e = 0x00;	/* NTSC M / PAL BGHI */	
+			reg_e = 0x00;	/* NTSC M / PAL BGHI */
 		} else if (norm == VIDEO_MODE_AUTO) {
 			reg_8 = 0x80;	/* Auto field detect */
 			reg_e = 0x00;	/* NTSC M / PAL BGHI */
@@ -3153,7 +3051,6 @@
 	return 0;
 }
 
-
 /**********************************************************************
  *
  * Color correction functions
@@ -3176,21 +3073,21 @@
  * coefficients are scaled into 16.16 fixed-point integers.
  * They were determined as follows:
  *
- *	double brightness = 1.0;  (0->black; 1->full scale) 
+ *	double brightness = 1.0;  (0->black; 1->full scale)
  *	double saturation = 1.0;  (0->greyscale; 1->full color)
  *	double fixScale = brightness * 256 * 256;
  *	int rvScale = (int)(1.402 * saturation * fixScale);
  *	int guScale = (int)(-0.344136 * saturation * fixScale);
  *	int gvScale = (int)(-0.714136 * saturation * fixScale);
  *	int buScale = (int)(1.772 * saturation * fixScale);
- *	int yScale = (int)(fixScale);	
+ *	int yScale = (int)(fixScale);
  */
 
 /* LIMIT: convert a 16.16 fixed-point value to a byte, with clipping. */
 #define LIMIT(x) ((x)>0xffffff?0xff: ((x)<=0xffff?0:((x)>>16)))
 
 static inline void
-move_420_block(int yTL, int yTR, int yBL, int yBR, int u, int v, 
+move_420_block(int yTL, int yTR, int yBL, int yBR, int u, int v,
 	       int rowPixels, unsigned char * rgb, int bits)
 {
 	const int rvScale = 91881;
@@ -3229,14 +3126,14 @@
 		rgb[5] = LIMIT(r+yBR);
 	} else if (bits == 16) {
 		/* Write out top two pixels */
-		rgb[0] = ((LIMIT(b+yTL) >> 3) & 0x1F) 
+		rgb[0] = ((LIMIT(b+yTL) >> 3) & 0x1F)
 			| ((LIMIT(g+yTL) << 3) & 0xE0);
 		rgb[1] = ((LIMIT(g+yTL) >> 5) & 0x07)
 			| (LIMIT(r+yTL) & 0xF8);
 
-		rgb[2] = ((LIMIT(b+yTR) >> 3) & 0x1F) 
+		rgb[2] = ((LIMIT(b+yTR) >> 3) & 0x1F)
 			| ((LIMIT(g+yTR) << 3) & 0xE0);
-		rgb[3] = ((LIMIT(g+yTR) >> 5) & 0x07) 
+		rgb[3] = ((LIMIT(g+yTR) >> 5) & 0x07)
 			| (LIMIT(r+yTR) & 0xF8);
 
 		/* Skip down to next line to write out bottom two pixels */
@@ -3263,7 +3160,7 @@
 /* Copies a 64-byte segment at pIn to an 8x8 block at pOut. The width of the
  * image at pOut is specified by w.
  */
-static inline void 
+static inline void
 make_8x8(unsigned char *pIn, unsigned char *pOut, int w)
 {
 	unsigned char *pOut1 = pOut;
@@ -3276,7 +3173,6 @@
 		}
 		pOut += w;
 	}
-		
 }
 
 /*
@@ -3394,7 +3290,7 @@
  * low, and the blue channel about 1 pixel high. After YUV->RGB
  * conversion, we can correct this easily. OSL 2/24/2000.
  */
-static void 
+static void
 fixFrameRGBoffset(struct ov511_frame *frame)
 {
 	int x, y;
@@ -3403,7 +3299,7 @@
 	const int shift = 1;  /* Distance to shift pixels by, vertically */
 
 	/* Don't bother with little images */
-	if (frame->width < 400) 
+	if (frame->width < 400)
 		return;
 
 	/* This only works with RGB24 */
@@ -3437,7 +3333,7 @@
  * accordingly. Returns -ENXIO if decompressor is not available, otherwise
  * returns 0 if no other error.
  */
-static int 
+static int
 request_decompressor(struct usb_ov511 *ov)
 {
 	if (!ov)
@@ -3476,24 +3372,24 @@
 	}
 
 	if (ov->decomp_ops) {
-		if (!ov->decomp_ops->decomp_lock) {
+		if (!ov->decomp_ops->owner) {
 			ov->decomp_ops = NULL;
 			unlock_kernel();
 			return -ENOSYS;
 		}
-		ov->decomp_ops->decomp_lock();
+		__MOD_INC_USE_COUNT(ov->decomp_ops->owner);
 		unlock_kernel();
 		return 0;
 	} else {
 		unlock_kernel();
-		return -ENXIO;
+		return -ENOSYS;
 	}
 }
 
 /* Unlocks decompression module and nulls ov->decomp_ops. Safe to call even
  * if ov->decomp_ops is NULL.
  */
-static void 
+static void
 release_decompressor(struct usb_ov511 *ov)
 {
 	int released = 0;	/* Did we actually do anything? */
@@ -3503,20 +3399,20 @@
 
 	lock_kernel();
 
-	if (ov->decomp_ops && ov->decomp_ops->decomp_unlock) {
-		ov->decomp_ops->decomp_unlock();
+	if (ov->decomp_ops && ov->decomp_ops->owner) {
+		__MOD_DEC_USE_COUNT(ov->decomp_ops->owner);
 		released = 1;
 	}
 
 	ov->decomp_ops = NULL;
-	
+
 	unlock_kernel();
 
 	if (released)
 		PDEBUG(3, "Decompressor released");
 }
 
-static void 
+static void
 decompress(struct usb_ov511 *ov, struct ov511_frame *frame,
 	   unsigned char *pIn0, unsigned char *pOut0)
 {
@@ -3526,19 +3422,22 @@
 
 	PDEBUG(4, "Decompressing %d bytes", frame->bytes_recvd);
 
-	if (frame->format == VIDEO_PALETTE_GREY 
+	if (frame->format == VIDEO_PALETTE_GREY
 	    && ov->decomp_ops->decomp_400) {
 		int ret = ov->decomp_ops->decomp_400(
 			pIn0,
 			pOut0,
+			frame->compbuf,
 			frame->rawwidth,
 			frame->rawheight,
 			frame->bytes_recvd);
 		PDEBUG(4, "DEBUG: decomp_400 returned %d", ret);
-	} else if (ov->decomp_ops->decomp_420) {
+	} else if (frame->format != VIDEO_PALETTE_GREY
+		   && ov->decomp_ops->decomp_420) {
 		int ret = ov->decomp_ops->decomp_420(
 			pIn0,
 			pOut0,
+			frame->compbuf,
 			frame->rawwidth,
 			frame->rawheight,
 			frame->bytes_recvd);
@@ -3555,7 +3454,7 @@
  **********************************************************************/
 
 /* Converts from planar YUV420 to RGB24. */
-static void 
+static void
 yuv420p_to_rgb(struct ov511_frame *frame,
 	       unsigned char *pIn0, unsigned char *pOut0, int bits)
 {
@@ -3578,10 +3477,9 @@
 
 			move_420_block(y00, y01, y10, y11, u, v,
 				       frame->width, pOut, bits);
-	
+
 			pY += 2;
 			pOut += 2 * bytes;
-
 		}
 		pY += frame->width;
 		pOut += frame->width * bytes;
@@ -3610,7 +3508,7 @@
 		for (i = 0; i <= frame->width - 2; i += 2) {
 			int u = *pU++;
 			int v = *pV++;
-			
+
 			*pOut = u;
 			*(pOut+2) = v;
 			*(pOut+frame->width*2) = u;
@@ -3725,27 +3623,11 @@
 	}
 }
 
-/* Post-processes the specified frame. This consists of:
- * 	1. Decompress frame, if necessary
- *	2. Deinterlace frame and scale to proper size, if necessary
- * 	3. Convert from YUV planar to destination format, if necessary
- * 	4. Fix the RGB offset, if necessary
- */
-static void 
-ov51x_postprocess(struct usb_ov511 *ov, struct ov511_frame *frame)
+static void
+ov51x_postprocess_grey(struct usb_ov511 *ov, struct ov511_frame *frame)
 {
-	if (dumppix) {
-		memset(frame->data, 0, 
-			MAX_DATA_SIZE(ov->maxwidth, ov->maxheight));
-		PDEBUG(4, "Dumping %d bytes", frame->bytes_recvd);
-		memmove(frame->data, frame->rawdata, frame->bytes_recvd);
-		return;
-	}
-
-	/* YUV400 must be handled separately */
-	if (frame->format == VIDEO_PALETTE_GREY) {
 		/* Deinterlace frame, if necessary */
-		if (ov->sensor == SEN_SAA7111A && frame->rawheight == 480) {
+		if (ov->sensor == SEN_SAA7111A && frame->rawheight >= 480) {
 			if (frame->compressed)
 				decompress(ov, frame, frame->rawdata,
 						 frame->tempdata);
@@ -3763,19 +3645,23 @@
 				yuv400raw_to_yuv400p(frame, frame->rawdata,
 						     frame->data);
 		}
+}
 
-		return;
-	}
-
-	/* Process frame->data to frame->rawdata */
+/* Process raw YUV420 data into the format requested by the app. Conversion
+ * between V4L formats is allowed.
+ */
+static void
+ov51x_postprocess_yuv420(struct usb_ov511 *ov, struct ov511_frame *frame)
+{
+	/* Process frame->rawdata to frame->tempdata */
 	if (frame->compressed)
 		decompress(ov, frame, frame->rawdata, frame->tempdata);
 	else
 		yuv420raw_to_yuv420p(frame, frame->rawdata, frame->tempdata);
 
 	/* Deinterlace frame, if necessary */
-	if (ov->sensor == SEN_SAA7111A && frame->rawheight == 480) {
-		memmove(frame->rawdata, frame->tempdata,
+	if (ov->sensor == SEN_SAA7111A && frame->rawheight >= 480) {
+		memcpy(frame->rawdata, frame->tempdata,
 			MAX_RAW_DATA_SIZE(frame->width, frame->height));
 		deinterlace(frame, RAWFMT_YUV420, frame->rawdata,
 		            frame->tempdata);
@@ -3784,11 +3670,6 @@
 	/* Frame should be (width x height) and not (rawwidth x rawheight) at
          * this point. */
 
-#if 0
-	/* Clear output buffer for testing purposes */
-	memset(frame->data, 0, MAX_DATA_SIZE(frame->width, frame->height));
-#endif
-
 	/* Process frame->tempdata to frame->data */
 	switch (frame->format) {
 	case VIDEO_PALETTE_RGB565:
@@ -3803,348 +3684,124 @@
 		break;
 	case VIDEO_PALETTE_YUV420:
 	case VIDEO_PALETTE_YUV420P:
-		memmove(frame->data, frame->tempdata,
+		memcpy(frame->data, frame->tempdata,
 			MAX_RAW_DATA_SIZE(frame->width, frame->height));
 		break;
 	case VIDEO_PALETTE_YUV422P:
 		/* Data is converted in place, so copy it in advance */
-		memmove(frame->data, frame->tempdata,
+		memcpy(frame->data, frame->tempdata,
 			MAX_RAW_DATA_SIZE(frame->width, frame->height));
 
 		yuv420p_to_yuv422p(frame, frame->data);
 		break;
 	default:
-		err("Cannot convert data to this format");
+		err("Cannot convert YUV420 to %s",
+		    symbolic(v4l1_plist, frame->format));
 	}
 
 	if (fix_rgb_offset)
 		fixFrameRGBoffset(frame);
 }
 
-/**********************************************************************
- *
- * OV51x data transfer, IRQ handler
- *
- **********************************************************************/
-
-static int 
-ov511_move_data(struct usb_ov511 *ov, struct urb *urb)
+/* Post-processes the specified frame. This consists of:
+ * 	1. Decompress frame, if necessary
+ *	2. Deinterlace frame and scale to proper size, if necessary
+ * 	3. Convert from YUV planar to destination format, if necessary
+ * 	4. Fix the RGB offset, if necessary
+ */
+static void
+ov51x_postprocess(struct usb_ov511 *ov, struct ov511_frame *frame)
 {
-	unsigned char *cdata;
-	int data_size, num, offset, i, totlen = 0;
-	int aPackNum[FRAMES_PER_DESC];
-	struct ov511_frame *frame;
-	struct timeval *ts;
-
-	PDEBUG(5, "Moving %d packets", urb->number_of_packets);
-
-	data_size = ov->packet_size - 1;
-
-	for (i = 0; i < urb->number_of_packets; i++) {
-		int n = urb->iso_frame_desc[i].actual_length;
-		int st = urb->iso_frame_desc[i].status;
-
-		urb->iso_frame_desc[i].actual_length = 0;
-		urb->iso_frame_desc[i].status = 0;
-
-		cdata = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
-
-		aPackNum[i] = n ? cdata[ov->packet_size - 1] : -1;
-
-		if (!n || ov->curframe == -1)
-			continue;
-
-		if (st)
-			PDEBUG(2, "data error: [%d] len=%d, status=%d", i, n, st);
-
-		frame = &ov->frame[ov->curframe];
-
-		/* SOF/EOF packets have 1st to 8th bytes zeroed and the 9th
-		 * byte non-zero. The EOF packet has image width/height in the
-		 * 10th and 11th bytes. The 9th byte is given as follows:
-		 *
-		 * bit 7: EOF
-		 *     6: compression enabled
-		 *     5: 422/420/400 modes
-		 *     4: 422/420/400 modes
-		 *     3: 1
-		 *     2: snapshot button on
-		 *     1: snapshot frame
-		 *     0: even/odd field
-		 */
-
-		if (printph) {
-			info("packet header (%3d): %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
-				cdata[ov->packet_size - 1],
-				cdata[0], cdata[1], cdata[2], cdata[3], cdata[4], cdata[5],
-				cdata[6], cdata[7], cdata[8], cdata[9], cdata[10], cdata[11]);
-		}
-
-		/* Check for SOF/EOF packet */
-		if ((cdata[0] | cdata[1] | cdata[2] | cdata[3] |
-		     cdata[4] | cdata[5] | cdata[6] | cdata[7]) ||
-		     (~cdata[8] & 0x08))
-			goto check_middle;
-
-		/* Frame end */
-		if (cdata[8] & 0x80) {
-			ts = (struct timeval *)(frame->data 
-			      + MAX_FRAME_SIZE(ov->maxwidth, ov->maxheight));
-			do_gettimeofday(ts);
-
-			/* Get the actual frame size from the EOF header */
-			frame->rawwidth = ((int)(cdata[9]) + 1) * 8;
-			frame->rawheight = ((int)(cdata[10]) + 1) * 8;
-
-	 		PDEBUG(4, "Frame end, curframe = %d, packnum=%d, hw=%d, vw=%d, recvd=%d",
-				ov->curframe,
-				(int)(cdata[ov->packet_size - 1]),
-				frame->rawwidth,
-				frame->rawheight,
-				frame->bytes_recvd);
-
-			/* Validate the header data */
-			RESTRICT_TO_RANGE(frame->rawwidth, ov->minwidth, ov->maxwidth);
-			RESTRICT_TO_RANGE(frame->rawheight, ov->minheight, ov->maxheight);
-
-			/* Don't allow byte count to exceed buffer size */
-			RESTRICT_TO_RANGE(frame->bytes_recvd,
-					  8, 
-					  MAX_RAW_DATA_SIZE(ov->maxwidth,
-					                    ov->maxheight));
-
-			if (frame->scanstate == STATE_LINES) {
-		    		int iFrameNext;
-
-				frame->grabstate = FRAME_DONE;	// FIXME: Is this right?
-
-				if (waitqueue_active(&frame->wq)) {
-					frame->grabstate = FRAME_DONE;
-					wake_up_interruptible(&frame->wq);
-				}
-
-				/* If next frame is ready or grabbing,
-                                 * point to it */
-				iFrameNext = (ov->curframe + 1) % OV511_NUMFRAMES;
-				if (ov->frame[iFrameNext].grabstate == FRAME_READY
-				    || ov->frame[iFrameNext].grabstate == FRAME_GRABBING) {
-					ov->curframe = iFrameNext;
-					ov->frame[iFrameNext].scanstate = STATE_SCANNING;
-				} else {
-					if (frame->grabstate == FRAME_DONE) {
-						PDEBUG(4, "Frame done! congratulations");
-					} else {
-						PDEBUG(4, "Frame not ready? state = %d",
-							ov->frame[iFrameNext].grabstate);
-					}
-
-					ov->curframe = -1;
-				}
-			} else {
-				PDEBUG(5, "Frame done, but not scanning");
-			}
-			/* Image corruption caused by misplaced frame->segment = 0
-			 * fixed by carlosf@conectiva.com.br
-			 */
-		} else {
-			/* Frame start */
-			PDEBUG(4, "Frame start, framenum = %d", ov->curframe);
-
-			/* Check to see if it's a snapshot frame */
-			/* FIXME?? Should the snapshot reset go here? Performance? */
-			if (cdata[8] & 0x02) {
-				frame->snapshot = 1;
-				PDEBUG(3, "snapshot detected");
-			}
-
-			frame->scanstate = STATE_LINES;
-			frame->bytes_recvd = 0;
-			frame->compressed = cdata[8] & 0x40;
-		}
-
-check_middle:
-		/* Are we in a frame? */
-		if (frame->scanstate != STATE_LINES) {
-			PDEBUG(5, "Not in a frame; packet skipped");
-			continue;
-		}
-
-#if 0
-		/* Skip packet if first 9 bytes are zero. These are common, so
-		 * we use a less expensive test here instead of later */
-		if (frame->compressed) {
-			int b, skip = 1;
-
-			for (b = 0; b < 9; b++) { 
-				if (cdata[b])
-					skip=0;
-			}
-
-			if (skip) {
-				PDEBUG(5, "Skipping packet (all zero)");
-				continue;
-			}
-		}
-#endif
-		/* If frame start, skip header */
-		if (frame->bytes_recvd == 0)
-			offset = 9;
-		else
-			offset = 0;
-
-		num = n - offset - 1;
-
-		/* Dump all data exactly as received */
-		if (dumppix == 2) {
-			frame->bytes_recvd += n - 1;
-			if (frame->bytes_recvd <= MAX_RAW_DATA_SIZE(ov->maxwidth, ov->maxheight))
-				memmove(frame->rawdata + frame->bytes_recvd - (n - 1),
-					&cdata[0], n - 1);
-			else
-				PDEBUG(3, "Raw data buffer overrun!! (%d)",
-					frame->bytes_recvd
-					- MAX_RAW_DATA_SIZE(ov->maxwidth,
-							    ov->maxheight));
-		} else if (!frame->compressed && !remove_zeros) {
-			frame->bytes_recvd += num;
-			if (frame->bytes_recvd <= MAX_RAW_DATA_SIZE(ov->maxwidth, ov->maxheight))
-				memmove(frame->rawdata + frame->bytes_recvd - num,
-					&cdata[offset], num);
-			else
-				PDEBUG(3, "Raw data buffer overrun!! (%d)",
-					frame->bytes_recvd
-					- MAX_RAW_DATA_SIZE(ov->maxwidth,
-							    ov->maxheight));
-		} else { /* Remove all-zero FIFO lines (aligned 32-byte blocks) */
-			int b, in = 0, allzero, copied=0;
-			if (offset) {
-				frame->bytes_recvd += 32 - offset;	// Bytes out
-				memmove(frame->rawdata,
-					&cdata[offset], 32 - offset);
-				in += 32;
-			}
-
-			while (in < n - 1) {
-				allzero = 1;
-				for (b = 0; b < 32; b++) {
-					if (cdata[in + b]) {
-						allzero = 0;
-						break;
-					}
-				}
-
-				if (allzero) {
-					/* Don't copy it */
-				} else {
-					if (frame->bytes_recvd + copied + 32
-					    <= MAX_RAW_DATA_SIZE(ov->maxwidth, ov->maxheight)) {
-						memmove(frame->rawdata + frame->bytes_recvd + copied,
-							&cdata[in], 32);
-						copied += 32;
-					} else {
-						PDEBUG(3, "Raw data buffer overrun!!");
-					}
-				}
-				in += 32;
-			}
-
-			frame->bytes_recvd += copied;
+	if (dumppix) {
+		memset(frame->data, 0,
+			MAX_DATA_SIZE(ov->maxwidth, ov->maxheight));
+		PDEBUG(4, "Dumping %d bytes", frame->bytes_recvd);
+		memcpy(frame->data, frame->rawdata, frame->bytes_recvd);
+	} else {
+		switch (frame->format) {
+		case VIDEO_PALETTE_GREY:
+			ov51x_postprocess_grey(ov, frame);
+			break;
+		case VIDEO_PALETTE_YUV420:
+		case VIDEO_PALETTE_YUV420P:
+		case VIDEO_PALETTE_RGB565:
+		case VIDEO_PALETTE_RGB24:
+		case VIDEO_PALETTE_YUV422:
+		case VIDEO_PALETTE_YUYV:
+		case VIDEO_PALETTE_YUV422P:
+			ov51x_postprocess_yuv420(ov, frame);
+			break;
+		default:
+			err("Cannot convert data to %s",
+			    symbolic(v4l1_plist, frame->format));
 		}
-
 	}
-
-	PDEBUG(5, "pn: %d %d %d %d %d %d %d %d %d %d",
-		aPackNum[0], aPackNum[1], aPackNum[2], aPackNum[3], aPackNum[4],
-		aPackNum[5],aPackNum[6], aPackNum[7], aPackNum[8], aPackNum[9]);
-
-	return totlen;
 }
 
-static int 
-ov518_move_data(struct usb_ov511 *ov, struct urb *urb)
+/**********************************************************************
+ *
+ * OV51x data transfer, IRQ handler
+ *
+ **********************************************************************/
+
+static inline void
+ov511_move_data(struct usb_ov511 *ov, unsigned char *in, int n)
 {
-	unsigned char *cdata;
-	int i, data_size, totlen = 0;
-	struct ov511_frame *frame;
+	int num, offset;
+	int pnum = in[ov->packet_size - 1];		/* Get packet number */
+	int max_raw = MAX_RAW_DATA_SIZE(ov->maxwidth, ov->maxheight);
+	struct ov511_frame *frame = &ov->frame[ov->curframe];
 	struct timeval *ts;
 
-	PDEBUG(5, "Moving %d packets", urb->number_of_packets);
-
-	/* OV518(+) has no packet numbering */
-	data_size = ov->packet_size;
-
-	for (i = 0; i < urb->number_of_packets; i++) {
-		int n = urb->iso_frame_desc[i].actual_length;
-		int st = urb->iso_frame_desc[i].status;
-
-		urb->iso_frame_desc[i].actual_length = 0;
-		urb->iso_frame_desc[i].status = 0;
-
-		cdata = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
-
-		if (!n) {
-			PDEBUG(4, "Zero-length packet");
-			continue;
-		}
-
-		if (ov->curframe == -1) {
-			PDEBUG(4, "No frame currently active");
-			continue;
-		}
+	/* SOF/EOF packets have 1st to 8th bytes zeroed and the 9th
+	 * byte non-zero. The EOF packet has image width/height in the
+	 * 10th and 11th bytes. The 9th byte is given as follows:
+	 *
+	 * bit 7: EOF
+	 *     6: compression enabled
+	 *     5: 422/420/400 modes
+	 *     4: 422/420/400 modes
+	 *     3: 1
+	 *     2: snapshot button on
+	 *     1: snapshot frame
+	 *     0: even/odd field
+	 */
 
-		if (st)
-			PDEBUG(2, "data error: [%d] len=%d, status=%d", i, n, st);
+	if (printph) {
+		info("ph(%3d): %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+		     pnum, in[0], in[1], in[2], in[3], in[4], in[5], in[6],
+		     in[7], in[8], in[9], in[10], in[11]);
+	}
 
-		frame = &ov->frame[ov->curframe];
+	/* Check for SOF/EOF packet */
+	if ((in[0] | in[1] | in[2] | in[3] | in[4] | in[5] | in[6] | in[7]) ||
+	    (~in[8] & 0x08))
+		goto check_middle;
 
-		if (printph) {
-			info("packet header: %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
-				cdata[0], cdata[1], cdata[2], cdata[3], cdata[4], cdata[5],
-				cdata[6], cdata[7], cdata[8], cdata[9], cdata[10], cdata[11]);
-		}
-
-		/* A false positive here is likely, until OVT gives me
-		 * the definitive SOF/EOF format */
-		if ((!(cdata[0] | cdata[1] | cdata[2] | cdata[3] |
-		      cdata[5])) && cdata[6]) {
-			
-			if (frame->scanstate == STATE_LINES) {
-				PDEBUG(4, "Detected frame end/start");
-				goto eof;
-			} else { //scanstate == STATE_SCANNING
-				/* Frame start */
-				PDEBUG(4, "Frame start, framenum = %d", ov->curframe);
-				goto sof;
-			}
-		} else {
-			goto check_middle;
-		}
-	
-eof:
+	/* Frame end */
+	if (in[8] & 0x80) {
 		ts = (struct timeval *)(frame->data
 		      + MAX_FRAME_SIZE(ov->maxwidth, ov->maxheight));
 		do_gettimeofday(ts);
 
- 		PDEBUG(4, "Frame end, curframe = %d, hw=%d, vw=%d, recvd=%d",
-			ov->curframe,
-			(int)(cdata[9]), (int)(cdata[10]), frame->bytes_recvd);
-
-		// FIXME: Since we don't know the header formats yet,
-		// there is no way to know what the actual image size is
-		frame->rawwidth = frame->width;
-		frame->rawheight = frame->height;
+		/* Get the actual frame size from the EOF header */
+		frame->rawwidth = ((int)(in[9]) + 1) * 8;
+		frame->rawheight = ((int)(in[10]) + 1) * 8;
+
+ 		PDEBUG(4, "Frame end, frame=%d, pnum=%d, w=%d, h=%d, recvd=%d",
+			ov->curframe, pnum, frame->rawwidth, frame->rawheight,
+			frame->bytes_recvd);
 
 		/* Validate the header data */
 		RESTRICT_TO_RANGE(frame->rawwidth, ov->minwidth, ov->maxwidth);
-		RESTRICT_TO_RANGE(frame->rawheight, ov->minheight, ov->maxheight);
+		RESTRICT_TO_RANGE(frame->rawheight, ov->minheight,
+				  ov->maxheight);
 
 		/* Don't allow byte count to exceed buffer size */
-		RESTRICT_TO_RANGE(frame->bytes_recvd,
-				  8, 
-				  MAX_RAW_DATA_SIZE(ov->maxwidth, ov->maxheight));
+		RESTRICT_TO_RANGE(frame->bytes_recvd, 8, max_raw);
 
 		if (frame->scanstate == STATE_LINES) {
-	    		int iFrameNext;
+	    		int nextf;
 
 			frame->grabstate = FRAME_DONE;	// FIXME: Is this right?
 
@@ -4155,115 +3812,280 @@
 
 			/* If next frame is ready or grabbing,
 			 * point to it */
-			iFrameNext = (ov->curframe + 1) % OV511_NUMFRAMES;
-			if (ov->frame[iFrameNext].grabstate == FRAME_READY
-			    || ov->frame[iFrameNext].grabstate == FRAME_GRABBING) {
-				ov->curframe = iFrameNext;
-				ov->frame[iFrameNext].scanstate = STATE_SCANNING;
-				frame = &ov->frame[iFrameNext];
+			nextf = (ov->curframe + 1) % OV511_NUMFRAMES;
+			if (ov->frame[nextf].grabstate == FRAME_READY
+			    || ov->frame[nextf].grabstate == FRAME_GRABBING) {
+				ov->curframe = nextf;
+				ov->frame[nextf].scanstate = STATE_SCANNING;
 			} else {
 				if (frame->grabstate == FRAME_DONE) {
-					PDEBUG(4, "Frame done! congratulations");
+					PDEBUG(4, "** Frame done **");
 				} else {
 					PDEBUG(4, "Frame not ready? state = %d",
-						ov->frame[iFrameNext].grabstate);
+						ov->frame[nextf].grabstate);
 				}
 
 				ov->curframe = -1;
-				PDEBUG(4, "SOF dropped (no active frame)");
-				continue;  /* Nowhere to store this frame */
 			}
+		} else {
+			PDEBUG(5, "Frame done, but not scanning");
 		}
 		/* Image corruption caused by misplaced frame->segment = 0
 		 * fixed by carlosf@conectiva.com.br
 		 */
-sof:
-		PDEBUG(4, "Starting capture on frame %d", frame->framenum);
-// Snapshot not reverse-engineered yet.
-#if 0
+	} else {
+		/* Frame start */
+		PDEBUG(4, "Frame start, framenum = %d", ov->curframe);
+
 		/* Check to see if it's a snapshot frame */
 		/* FIXME?? Should the snapshot reset go here? Performance? */
-		if (cdata[8] & 0x02) {
+		if (in[8] & 0x02) {
 			frame->snapshot = 1;
 			PDEBUG(3, "snapshot detected");
 		}
-#endif
+
 		frame->scanstate = STATE_LINES;
 		frame->bytes_recvd = 0;
-//		frame->compressed = 1;
+		frame->compressed = in[8] & 0x40;
+	}
 
 check_middle:
-		/* Are we in a frame? */
-		if (frame->scanstate != STATE_LINES) {
-			PDEBUG(4, "scanstate: no SOF yet");
-			continue;
-		}
+	/* Are we in a frame? */
+	if (frame->scanstate != STATE_LINES) {
+		PDEBUG(5, "Not in a frame; packet skipped");
+		return;
+	}
 
-		/* Dump all data exactly as received */
-		if (dumppix == 2) {
-			frame->bytes_recvd += n;
-			if (frame->bytes_recvd <= MAX_RAW_DATA_SIZE(ov->maxwidth, ov->maxheight))
-				memmove(frame->rawdata + frame->bytes_recvd - n,
-					&cdata[0], n);
-			else
-				PDEBUG(3, "Raw data buffer overrun!! (%d)",
-					frame->bytes_recvd
-					- MAX_RAW_DATA_SIZE(ov->maxwidth,
-							    ov->maxheight));
-		} else {
-			/* All incoming data are divided into 8-byte segments. If the
-			 * segment contains all zero bytes, it must be skipped. These
-			 * zero-segments allow the OV518 to mainain a constant data rate
-			 * regardless of the effectiveness of the compression. Segments
-			 * are aligned relative to the beginning of each isochronous
-			 * packet. The first segment is a header (the decompressor
-			 * skips it later).
-			 */
-
-			int b, in = 0, allzero, copied=0;
-
-			while (in < n) {
-				allzero = 1;
-				for (b = 0; b < 8; b++) {
-					if (cdata[in + b]) {
-						allzero = 0;
-						break;
-					}
+	/* If frame start, skip header */
+	if (frame->bytes_recvd == 0)
+		offset = 9;
+	else
+		offset = 0;
+
+	num = n - offset - 1;
+
+	/* Dump all data exactly as received */
+	if (dumppix == 2) {
+		frame->bytes_recvd += n - 1;
+		if (frame->bytes_recvd <= max_raw)
+			memcpy(frame->rawdata + frame->bytes_recvd - (n - 1),
+				in, n - 1);
+		else
+			PDEBUG(3, "Raw data buffer overrun!! (%d)",
+				frame->bytes_recvd - max_raw);
+	} else if (!frame->compressed && !remove_zeros) {
+		frame->bytes_recvd += num;
+		if (frame->bytes_recvd <= max_raw)
+			memcpy(frame->rawdata + frame->bytes_recvd - num,
+				in + offset, num);
+		else
+			PDEBUG(3, "Raw data buffer overrun!! (%d)",
+				frame->bytes_recvd - max_raw);
+	} else { /* Remove all-zero FIFO lines (aligned 32-byte blocks) */
+		int b, read = 0, allzero, copied = 0;
+		if (offset) {
+			frame->bytes_recvd += 32 - offset;	// Bytes out
+			memcpy(frame->rawdata,	in + offset, 32 - offset);
+			read += 32;
+		}
+
+		while (read < n - 1) {
+			allzero = 1;
+			for (b = 0; b < 32; b++) {
+				if (in[read + b]) {
+					allzero = 0;
+					break;
 				}
+			}
 
-				if (allzero) {
+			if (allzero) {
 				/* Don't copy it */
+			} else {
+				if (frame->bytes_recvd + copied + 32 <= max_raw)
+				{
+					memcpy(frame->rawdata
+						+ frame->bytes_recvd + copied,
+						in + read, 32);
+					copied += 32;
 				} else {
-					if (frame->bytes_recvd + copied + 8
-					    <= MAX_RAW_DATA_SIZE(ov->maxwidth, ov->maxheight)) {
-						memmove(frame->rawdata + frame->bytes_recvd + copied,
-							&cdata[in], 8);
-						copied += 8;
-					} else {
-						PDEBUG(3, "Raw data buffer overrun!!");
-					}
+					PDEBUG(3, "Raw data buffer overrun!!");
 				}
-				in += 8;
 			}
-			frame->bytes_recvd += copied;
+			read += 32;
 		}
+
+		frame->bytes_recvd += copied;
 	}
+}
 
-	return totlen;
+static inline void
+ov518_move_data(struct usb_ov511 *ov, unsigned char *in, int n)
+{
+	int max_raw = MAX_RAW_DATA_SIZE(ov->maxwidth, ov->maxheight);
+	struct ov511_frame *frame = &ov->frame[ov->curframe];
+	struct timeval *ts;
+
+	/* Don't copy the packet number byte */
+	if (ov->packet_numbering)
+		--n;
+
+	/* A false positive here is likely, until OVT gives me
+	 * the definitive SOF/EOF format */
+	if ((!(in[0] | in[1] | in[2] | in[3] | in[5])) && in[6]) {
+		if (printph) {
+			info("ph: %2x %2x %2x %2x %2x %2x %2x %2x", in[0],
+			     in[1], in[2], in[3], in[4], in[5], in[6], in[7]);
+		}
+
+		if (frame->scanstate == STATE_LINES) {
+			PDEBUG(4, "Detected frame end/start");
+			goto eof;
+		} else { //scanstate == STATE_SCANNING
+			/* Frame start */
+			PDEBUG(4, "Frame start, framenum = %d", ov->curframe);
+			goto sof;
+		}
+	} else {
+		goto check_middle;
+	}
+
+eof:
+	ts = (struct timeval *)(frame->data
+	      + MAX_FRAME_SIZE(ov->maxwidth, ov->maxheight));
+	do_gettimeofday(ts);
+
+	PDEBUG(4, "Frame end, curframe = %d, hw=%d, vw=%d, recvd=%d",
+		ov->curframe,
+		(int)(in[9]), (int)(in[10]), frame->bytes_recvd);
+
+	// FIXME: Since we don't know the header formats yet,
+	// there is no way to know what the actual image size is
+	frame->rawwidth = frame->width;
+	frame->rawheight = frame->height;
+
+	/* Validate the header data */
+	RESTRICT_TO_RANGE(frame->rawwidth, ov->minwidth, ov->maxwidth);
+	RESTRICT_TO_RANGE(frame->rawheight, ov->minheight, ov->maxheight);
+
+	/* Don't allow byte count to exceed buffer size */
+	RESTRICT_TO_RANGE(frame->bytes_recvd, 8, max_raw);
+
+	if (frame->scanstate == STATE_LINES) {
+    		int nextf;
+
+		frame->grabstate = FRAME_DONE;	// FIXME: Is this right?
+
+		if (waitqueue_active(&frame->wq)) {
+			frame->grabstate = FRAME_DONE;
+			wake_up_interruptible(&frame->wq);
+		}
+
+		/* If next frame is ready or grabbing,
+		 * point to it */
+		nextf = (ov->curframe + 1) % OV511_NUMFRAMES;
+		if (ov->frame[nextf].grabstate == FRAME_READY
+		    || ov->frame[nextf].grabstate == FRAME_GRABBING) {
+			ov->curframe = nextf;
+			ov->frame[nextf].scanstate = STATE_SCANNING;
+			frame = &ov->frame[nextf];
+		} else {
+			if (frame->grabstate == FRAME_DONE) {
+				PDEBUG(4, "** Frame done **");
+			} else {
+				PDEBUG(4, "Frame not ready? state = %d",
+				       ov->frame[nextf].grabstate);
+			}
+
+			ov->curframe = -1;
+			PDEBUG(4, "SOF dropped (no active frame)");
+			return;  /* Nowhere to store this frame */
+		}
+	}
+sof:
+	PDEBUG(4, "Starting capture on frame %d", frame->framenum);
+
+// Snapshot not reverse-engineered yet.
+#if 0
+	/* Check to see if it's a snapshot frame */
+	/* FIXME?? Should the snapshot reset go here? Performance? */
+	if (in[8] & 0x02) {
+		frame->snapshot = 1;
+		PDEBUG(3, "snapshot detected");
+	}
+#endif
+	frame->scanstate = STATE_LINES;
+	frame->bytes_recvd = 0;
+	frame->compressed = 1;
+
+check_middle:
+	/* Are we in a frame? */
+	if (frame->scanstate != STATE_LINES) {
+		PDEBUG(4, "scanstate: no SOF yet");
+		return;
+	}
+
+	/* Dump all data exactly as received */
+	if (dumppix == 2) {
+		frame->bytes_recvd += n;
+		if (frame->bytes_recvd <= max_raw)
+			memcpy(frame->rawdata + frame->bytes_recvd - n, in, n);
+		else
+			PDEBUG(3, "Raw data buffer overrun!! (%d)",
+				frame->bytes_recvd - max_raw);
+	} else {
+		/* All incoming data are divided into 8-byte segments. If the
+		 * segment contains all zero bytes, it must be skipped. These
+		 * zero-segments allow the OV518 to mainain a constant data rate
+		 * regardless of the effectiveness of the compression. Segments
+		 * are aligned relative to the beginning of each isochronous
+		 * packet. The first segment in each image is a header (the
+		 * decompressor skips it later).
+		 */
+
+		int b, read = 0, allzero, copied = 0;
+
+		while (read < n) {
+			allzero = 1;
+			for (b = 0; b < 8; b++) {
+				if (in[read + b]) {
+					allzero = 0;
+					break;
+				}
+			}
+
+			if (allzero) {
+			/* Don't copy it */
+			} else {
+				if (frame->bytes_recvd + copied + 8 <= max_raw)
+				{
+					memcpy(frame->rawdata
+						+ frame->bytes_recvd + copied,
+						in + read, 8);
+					copied += 8;
+				} else {
+					PDEBUG(3, "Raw data buffer overrun!!");
+				}
+			}
+			read += 8;
+		}
+		frame->bytes_recvd += copied;
+	}
 }
 
-static void 
+static void
 ov51x_isoc_irq(struct urb *urb)
 {
-	int len;
+	int i;
 	struct usb_ov511 *ov;
+	struct ov511_sbuf *sbuf;
 
 	if (!urb->context) {
 		PDEBUG(4, "no context");
 		return;
 	}
 
-	ov = (struct usb_ov511 *) urb->context;
+	sbuf = urb->context;
+	ov = sbuf->ov;
 
 	if (!ov || !ov->dev || !ov->user) {
 		PDEBUG(4, "no device, or not open");
@@ -4275,16 +4097,51 @@
 		return;
 	}
 
+        if (urb->status == -ENOENT || urb->status == -ECONNRESET) {
+                PDEBUG(4, "URB unlinked");
+                return;
+        }
+
+	if (urb->status != -EINPROGRESS && urb->status != 0) {
+		err("ERROR: urb->status=%d: %s", urb->status,
+		    symbolic(urb_errlist, urb->status));
+	}
+
 	/* Copy the data received into our frame buffer */
-	if (ov->curframe >= 0) {
-		if (ov->bclass == BCL_OV511)
-			len = ov511_move_data(ov, urb);
-		else if (ov->bclass == BCL_OV518)
-			len = ov518_move_data(ov, urb);
-		else
-			err("Unknown bridge device (%d)", ov->bridge);
-	} else if (waitqueue_active(&ov->wq)) {
-		wake_up_interruptible(&ov->wq);
+	PDEBUG(5, "sbuf[%d]: Moving %d packets", sbuf->n,
+	       urb->number_of_packets);
+	for (i = 0; i < urb->number_of_packets; i++) {
+		/* Warning: Don't call *_move_data() if no frame active! */
+		if (ov->curframe >= 0) {
+			int n = urb->iso_frame_desc[i].actual_length;
+			int st = urb->iso_frame_desc[i].status;
+			unsigned char *cdata;
+
+			urb->iso_frame_desc[i].actual_length = 0;
+			urb->iso_frame_desc[i].status = 0;
+
+			cdata = urb->transfer_buffer
+				+ urb->iso_frame_desc[i].offset;
+
+			if (!n) {
+				PDEBUG(4, "Zero-length packet");
+				continue;
+			}
+
+			if (st)
+				PDEBUG(2, "data error: [%d] len=%d, status=%d",
+				       i, n, st);
+
+			if (ov->bclass == BCL_OV511)
+				ov511_move_data(ov, cdata, n);
+			else if (ov->bclass == BCL_OV518)
+				ov518_move_data(ov, cdata, n);
+			else
+				err("Unknown bridge device (%d)", ov->bridge);
+
+		} else if (waitqueue_active(&ov->wq)) {
+			wake_up_interruptible(&ov->wq);
+		}
 	}
 
 	urb->dev = ov->dev;
@@ -4298,7 +4155,7 @@
  *
  ***************************************************************************/
 
-static int 
+static int
 ov51x_init_isoc(struct usb_ov511 *ov)
 {
 	struct urb *urb;
@@ -4340,27 +4197,32 @@
 		return -1;
 	}
 
-	if (packetsize == -1) {
-		// FIXME: OV518 is hardcoded to 15 FPS (alternate 5) for now
-		if (ov->bclass == BCL_OV518)
-			ov51x_set_packet_size(ov, 640);
-		else
-			ov51x_set_packet_size(ov, size);
+	// FIXME: OV518 is hardcoded to 15 FPS (alternate 5) for now
+	if (ov->bclass == BCL_OV518) {
+		if (packetsize == -1) {
+			ov518_set_packet_size(ov, 640);
+		} else {
+			info("Forcing packet size to %d", packetsize);
+			ov518_set_packet_size(ov, packetsize);
+		}
 	} else {
+		if (packetsize == -1) {
+			ov511_set_packet_size(ov, size);
+		} else {
 			info("Forcing packet size to %d", packetsize);
-			ov51x_set_packet_size(ov, packetsize);
+			ov511_set_packet_size(ov, packetsize);
+		}
 	}
 
 	for (n = 0; n < OV511_NUMSBUF; n++) {
 		urb = usb_alloc_urb(FRAMES_PER_DESC);
-	
 		if (!urb) {
 			err("init isoc: usb_alloc_urb ret. NULL");
 			return -ENOMEM;
 		}
 		ov->sbuf[n].urb = urb;
 		urb->dev = ov->dev;
-		urb->context = ov;
+		urb->context = &ov->sbuf[n];
 		urb->pipe = usb_rcvisocpipe(ov->dev, OV511_ENDPOINT_ADDRESS);
 		urb->transfer_flags = USB_ISO_ASAP;
 		urb->transfer_buffer = ov->sbuf[n].data;
@@ -4382,31 +4244,23 @@
 	for (n = 0; n < OV511_NUMSBUF; n++) {
 		ov->sbuf[n].urb->dev = ov->dev;
 		err = usb_submit_urb(ov->sbuf[n].urb);
-		if (err)
+		if (err) {
 			err("init isoc: usb_submit_urb(%d) ret %d", n, err);
+			return err;
+		}
 	}
 
 	return 0;
 }
 
-static void 
-ov51x_stop_isoc(struct usb_ov511 *ov)
+static void
+ov51x_unlink_isoc(struct usb_ov511 *ov)
 {
 	int n;
 
-	if (!ov->streaming || !ov->dev)
-		return;
-
-	PDEBUG(3, "*** Stopping capture ***");
-
-	ov51x_set_packet_size(ov, 0);
-
-	ov->streaming = 0;
-
 	/* Unschedule all of the iso td's */
 	for (n = OV511_NUMSBUF - 1; n >= 0; n--) {
 		if (ov->sbuf[n].urb) {
-			ov->sbuf[n].urb->next = NULL;
 			usb_unlink_urb(ov->sbuf[n].urb);
 			usb_free_urb(ov->sbuf[n].urb);
 			ov->sbuf[n].urb = NULL;
@@ -4414,7 +4268,25 @@
 	}
 }
 
-static int 
+static void
+ov51x_stop_isoc(struct usb_ov511 *ov)
+{
+	if (!ov->streaming || !ov->dev)
+		return;
+
+	PDEBUG(3, "*** Stopping capture ***");
+
+	if (ov->bclass == BCL_OV518)
+		ov518_set_packet_size(ov, 0);
+	else
+		ov511_set_packet_size(ov, 0);
+
+	ov->streaming = 0;
+
+	ov51x_unlink_isoc(ov);
+}
+
+static int
 ov51x_new_frame(struct usb_ov511 *ov, int framenum)
 {
 	struct ov511_frame *frame;
@@ -4436,7 +4308,7 @@
 
 	frame = &ov->frame[framenum];
 
-	PDEBUG(4, "framenum = %d, width = %d, height = %d", framenum, 
+	PDEBUG(4, "framenum = %d, width = %d, height = %d", framenum,
 	       frame->width, frame->height);
 
 	frame->grabstate = FRAME_GRABBING;
@@ -4465,172 +4337,133 @@
  *
  ***************************************************************************/
 
-static int 
-ov51x_alloc(struct usb_ov511 *ov)
+/*
+ * - You must acquire buf_lock before entering this function.
+ * - Because this code will free any non-null pointer, you must be sure to null
+ *   them if you explicitly free them somewhere else!
+ */
+static void
+ov51x_do_dealloc(struct usb_ov511 *ov)
 {
 	int i;
-	const int w = ov->maxwidth;
-	const int h = ov->maxheight;
-	const int data_bufsize = OV511_NUMFRAMES * MAX_DATA_SIZE(w, h);
-	const int raw_bufsize = OV511_NUMFRAMES * MAX_RAW_DATA_SIZE(w, h);
-
 	PDEBUG(4, "entered");
-	down(&ov->buf_lock);
-
-	if (ov->buf_state == BUF_PEND_DEALLOC) {
-		ov->buf_state = BUF_ALLOCATED;
-		del_timer(&ov->buf_timer);
-	}
-
-	if (ov->buf_state == BUF_ALLOCATED)
-		goto out;
 
-	ov->fbuf = rvmalloc(data_bufsize);
-	if (!ov->fbuf)
-		goto error;
-
-	ov->rawfbuf = vmalloc(raw_bufsize);
-	if (!ov->rawfbuf) {
-		rvfree(ov->fbuf, data_bufsize);
+	if (ov->fbuf) {
+		rvfree(ov->fbuf, OV511_NUMFRAMES
+		       * MAX_DATA_SIZE(ov->maxwidth, ov->maxheight));
 		ov->fbuf = NULL;
-		goto error;
 	}
-	memset(ov->rawfbuf, 0, raw_bufsize);
 
-	ov->tempfbuf = vmalloc(raw_bufsize);
-	if (!ov->tempfbuf) {
+	if (ov->rawfbuf) {
 		vfree(ov->rawfbuf);
 		ov->rawfbuf = NULL;
-		rvfree(ov->fbuf, data_bufsize);
-		ov->fbuf = NULL;
-		goto error;
 	}
-	memset(ov->tempfbuf, 0, raw_bufsize);
 
-	for (i = 0; i < OV511_NUMSBUF; i++) {
-		ov->sbuf[i].data = kmalloc(FRAMES_PER_DESC *
-			MAX_FRAME_SIZE_PER_DESC, GFP_KERNEL);
-		if (!ov->sbuf[i].data) {
-			while (--i) {
-				kfree(ov->sbuf[i].data);
-				ov->sbuf[i].data = NULL;
-			}
-			vfree(ov->tempfbuf);
-			ov->tempfbuf = NULL;
-			vfree(ov->rawfbuf);
-			ov->rawfbuf = NULL;
-			rvfree(ov->fbuf, data_bufsize);
-			ov->fbuf = NULL;
+	if (ov->tempfbuf) {
+		vfree(ov->tempfbuf);
+		ov->tempfbuf = NULL;
+	}
 
-			goto error;
+	for (i = 0; i < OV511_NUMSBUF; i++) {
+		if (ov->sbuf[i].data) {
+			kfree(ov->sbuf[i].data);
+			ov->sbuf[i].data = NULL;
 		}
-		PDEBUG(4, "sbuf[%d] @ %p", i, ov->sbuf[i].data);
 	}
 
 	for (i = 0; i < OV511_NUMFRAMES; i++) {
-		ov->frame[i].data = ov->fbuf + i * MAX_DATA_SIZE(w, h);
-		ov->frame[i].rawdata = ov->rawfbuf 
-		 + i * MAX_RAW_DATA_SIZE(w, h);
-		ov->frame[i].tempdata = ov->tempfbuf 
-		 + i * MAX_RAW_DATA_SIZE(w, h);
-		PDEBUG(4, "frame[%d] @ %p", i, ov->frame[i].data);
+		ov->frame[i].data = NULL;
+		ov->frame[i].rawdata = NULL;
+		ov->frame[i].tempdata = NULL;
+		if (ov->frame[i].compbuf) {
+			free_page((unsigned long) ov->frame[i].compbuf);
+			ov->frame[i].compbuf = NULL;
+		}
 	}
 
-	ov->buf_state = BUF_ALLOCATED;
-out:
-	up(&ov->buf_lock);
-	PDEBUG(4, "leaving");
-	return 0;
-error:
+	PDEBUG(4, "buffer memory deallocated");
 	ov->buf_state = BUF_NOT_ALLOCATED;
-	up(&ov->buf_lock);
-	PDEBUG(4, "errored");
-	return -ENOMEM;
+	PDEBUG(4, "leaving");
 }
 
-/* 
- * - You must acquire buf_lock before entering this function.
- * - Because this code will free any non-null pointer, you must be sure to null
- *   them if you explicitly free them somewhere else!
- */
-static void 
-ov51x_do_dealloc(struct usb_ov511 *ov)
+static int
+ov51x_alloc(struct usb_ov511 *ov)
 {
 	int i;
+	const int w = ov->maxwidth;
+	const int h = ov->maxheight;
+	const int data_bufsize = OV511_NUMFRAMES * MAX_DATA_SIZE(w, h);
+	const int raw_bufsize = OV511_NUMFRAMES * MAX_RAW_DATA_SIZE(w, h);
+
 	PDEBUG(4, "entered");
+	down(&ov->buf_lock);
 
-	if (ov->fbuf) {
-		rvfree(ov->fbuf, OV511_NUMFRAMES
-		       * MAX_DATA_SIZE(ov->maxwidth, ov->maxheight));
-		ov->fbuf = NULL;
+	if (ov->buf_state == BUF_PEND_DEALLOC) {
+		ov->buf_state = BUF_ALLOCATED;
+		del_timer(&ov->buf_timer);
 	}
 
-	if (ov->rawfbuf) {
-		vfree(ov->rawfbuf);
-		ov->rawfbuf = NULL;
-	}
+	if (ov->buf_state == BUF_ALLOCATED)
+		goto out;
+
+	ov->fbuf = rvmalloc(data_bufsize);
+	if (!ov->fbuf)
+		goto error;
+
+	ov->rawfbuf = vmalloc(raw_bufsize);
+	if (!ov->rawfbuf)
+		goto error;
+
+	memset(ov->rawfbuf, 0, raw_bufsize);
 
-	if (ov->tempfbuf) {
-		vfree(ov->tempfbuf);
-		ov->tempfbuf = NULL;
-	}
+	ov->tempfbuf = vmalloc(raw_bufsize);
+	if (!ov->tempfbuf)
+		goto error;
+
+	memset(ov->tempfbuf, 0, raw_bufsize);
 
 	for (i = 0; i < OV511_NUMSBUF; i++) {
-		if (ov->sbuf[i].data) {
-			kfree(ov->sbuf[i].data);
-			ov->sbuf[i].data = NULL;
-		}
-	}
+		ov->sbuf[i].data = kmalloc(FRAMES_PER_DESC *
+			MAX_FRAME_SIZE_PER_DESC, GFP_KERNEL);
+		if (!ov->sbuf[i].data)
+			goto error;
 
-	for (i = 0; i < OV511_NUMFRAMES; i++) {
-		ov->frame[i].data = NULL;
-		ov->frame[i].rawdata = NULL;
-		ov->frame[i].tempdata = NULL;
+		PDEBUG(4, "sbuf[%d] @ %p", i, ov->sbuf[i].data);
 	}
 
-	PDEBUG(4, "buffer memory deallocated");
-	ov->buf_state = BUF_NOT_ALLOCATED;
-	PDEBUG(4, "leaving");
-}
+	for (i = 0; i < OV511_NUMFRAMES; i++) {
+		ov->frame[i].data = ov->fbuf + i * MAX_DATA_SIZE(w, h);
+		ov->frame[i].rawdata = ov->rawfbuf
+		 + i * MAX_RAW_DATA_SIZE(w, h);
+		ov->frame[i].tempdata = ov->tempfbuf
+		 + i * MAX_RAW_DATA_SIZE(w, h);
 
-static void 
-ov51x_buf_callback(unsigned long data)
-{
-	struct usb_ov511 *ov = (struct usb_ov511 *)data;
-	PDEBUG(4, "entered");
-	down(&ov->buf_lock);
+		ov->frame[i].compbuf =
+		 (unsigned char *) __get_free_page(GFP_KERNEL);
+		if (!ov->frame[i].compbuf)
+			goto error;
 
-	if (ov->buf_state == BUF_PEND_DEALLOC)
-		ov51x_do_dealloc(ov);
+		PDEBUG(4, "frame[%d] @ %p", i, ov->frame[i].data);
+	}
 
+	ov->buf_state = BUF_ALLOCATED;
+out:
 	up(&ov->buf_lock);
 	PDEBUG(4, "leaving");
+	return 0;
+error:
+	ov51x_do_dealloc(ov);
+	up(&ov->buf_lock);
+	PDEBUG(4, "errored");
+	return -ENOMEM;
 }
 
-static void 
+static void
 ov51x_dealloc(struct usb_ov511 *ov, int now)
 {
-	struct timer_list *bt = &(ov->buf_timer);
 	PDEBUG(4, "entered");
 	down(&ov->buf_lock);
-
-	PDEBUG(4, "deallocating buffer memory %s", now ? "now" : "later");
-
-	if (ov->buf_state == BUF_PEND_DEALLOC) {
-		ov->buf_state = BUF_ALLOCATED;
-		del_timer(bt);
-	}
-
-	if (now)
-		ov51x_do_dealloc(ov);
-	else {
-		ov->buf_state = BUF_PEND_DEALLOC;
-		init_timer(bt);
-		bt->function = ov51x_buf_callback;
-		bt->data = (unsigned long)ov;
-		bt->expires = jiffies + buf_timeout * HZ;
-		add_timer(bt);
-	}
+	ov51x_do_dealloc(ov);
 	up(&ov->buf_lock);
 	PDEBUG(4, "leaving");
 }
@@ -4641,7 +4474,7 @@
  *
  ***************************************************************************/
 
-static int 
+static int
 ov51x_v4l1_open(struct video_device *vdev, int flags)
 {
 	struct usb_ov511 *ov = vdev->priv;
@@ -4652,17 +4485,18 @@
 	down(&ov->lock);
 
 	err = -EBUSY;
-	if (ov->user) 
+	if (ov->user)
 		goto out;
 
-	err = -ENOMEM;
-	if (ov51x_alloc(ov))
+	err = ov51x_alloc(ov);
+	if (err < 0)
 		goto out;
 
 	ov->sub_flag = 0;
 
 	/* In case app doesn't set them... */
-	if (ov51x_set_default_params(ov) < 0)
+	err = ov51x_set_default_params(ov);
+	if (err < 0)
 		goto out;
 
 	/* Make sure frames are reset */
@@ -4671,7 +4505,7 @@
 		ov->frame[i].bytes_read = 0;
 	}
 
-	/* If compression is on, make sure now that a 
+	/* If compression is on, make sure now that a
 	 * decompressor can be loaded */
 	if (ov->compress && !ov->decomp_ops) {
 		err = request_decompressor(ov);
@@ -4686,23 +4520,22 @@
 	}
 
 	ov->user++;
-	
+
 	if (ov->led_policy == LED_AUTO)
 		ov51x_led_control(ov, 1);
 
 out:
 	up(&ov->lock);
-
 	return err;
 }
 
-static void 
+static void
 ov51x_v4l1_close(struct video_device *vdev)
 {
 	struct usb_ov511 *ov = vdev->priv;
 
 	PDEBUG(4, "ov511_close");
-	
+
 	down(&ov->lock);
 
 	ov->user--;
@@ -4731,129 +4564,93 @@
 		kfree(ov);
 		ov = NULL;
 	}
-}
-
-static int 
-ov51x_v4l1_init_done(struct video_device *vdev)
-{
-#if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
-	create_proc_ov511_cam(vdev->priv);
-#endif
-
-	return 0;
-}
 
-static long 
-ov51x_v4l1_write(struct video_device *vdev, const char *buf,
-		 unsigned long count, int noblock)
-{
-	return -EINVAL;
+	return;
 }
 
 /* Do not call this function directly! */
-static int 
-ov51x_v4l1_ioctl_internal(struct video_device *vdev, unsigned int cmd,
+static int
+ov51x_v4l1_ioctl_internal(struct usb_ov511 *ov, unsigned int cmd,
 			  void *arg)
 {
-	struct usb_ov511 *ov = vdev->priv;
-
 	PDEBUG(5, "IOCtl: 0x%X", cmd);
 
 	if (!ov->dev)
-		return -EIO;	
+		return -EIO;
 
 	switch (cmd) {
 	case VIDIOCGCAP:
 	{
-		struct video_capability b;
+		struct video_capability *b = arg;
 
 		PDEBUG(4, "VIDIOCGCAP");
 
-		memset(&b, 0, sizeof(b));
-		sprintf(b.name, "%s USB Camera",
-			ov->bridge == BRG_OV511 ? "OV511" :
-			ov->bridge == BRG_OV511PLUS ? "OV511+" :
-			ov->bridge == BRG_OV518 ? "OV518" :
-			ov->bridge == BRG_OV518PLUS ? "OV518+" :
-			"unknown");
-		b.type = VID_TYPE_CAPTURE | VID_TYPE_SUBCAPTURE;
-		if (ov->has_tuner)
-			b.type |= VID_TYPE_TUNER;
-		b.channels = ov->num_inputs;
-		b.audios = ov->has_audio_proc ? 1:0;
-		b.maxwidth = ov->maxwidth;
-		b.maxheight = ov->maxheight;
-		b.minwidth = ov->minwidth;
-		b.minheight = ov->minheight;
+		memset(b, 0, sizeof(struct video_capability));
+		sprintf(b->name, "%s USB Camera",
+			symbolic(brglist, ov->bridge));
+		b->type = VID_TYPE_CAPTURE | VID_TYPE_SUBCAPTURE;
+		b->channels = ov->num_inputs;
+		b->audios = 0;
+		b->maxwidth = ov->maxwidth;
+		b->maxheight = ov->maxheight;
+		b->minwidth = ov->minwidth;
+		b->minheight = ov->minheight;
 
-		if (copy_to_user(arg, &b, sizeof(b)))
-			return -EFAULT;
-				
 		return 0;
 	}
 	case VIDIOCGCHAN:
 	{
-		struct video_channel v;
+		struct video_channel *v = arg;
 
 		PDEBUG(4, "VIDIOCGCHAN");
 
-		if (copy_from_user(&v, arg, sizeof(v)))
-			return -EFAULT;
-
-		if ((unsigned)(v.channel) >= ov->num_inputs) {
-			err("Invalid channel (%d)", v.channel);
+		if ((unsigned)(v->channel) >= ov->num_inputs) {
+			err("Invalid channel (%d)", v->channel);
 			return -EINVAL;
 		}
 
-		v.norm = ov->norm;
-		v.type = (ov->has_tuner) ? VIDEO_TYPE_TV : VIDEO_TYPE_CAMERA;
-		v.flags = (ov->has_tuner) ? VIDEO_VC_TUNER : 0;
-		v.flags |= (ov->has_audio_proc) ? VIDEO_VC_AUDIO : 0;
-//		v.flags |= (ov->has_decoder) ? VIDEO_VC_NORM : 0;
-		v.tuners = (ov->has_tuner) ? 1:0;
-		decoder_get_input_name(ov, v.channel, v.name);
+		v->norm = ov->norm;
+		v->type = VIDEO_TYPE_CAMERA;
+		v->flags = 0;
+//		v->flags |= (ov->has_decoder) ? VIDEO_VC_NORM : 0;
+		v->tuners = 0;
+		decoder_get_input_name(ov, v->channel, v->name);
 
-		if (copy_to_user(arg, &v, sizeof(v)))
-			return -EFAULT;
-				
 		return 0;
 	}
 	case VIDIOCSCHAN:
 	{
-		struct video_channel v;
+		struct video_channel *v = arg;
 		int err;
 
 		PDEBUG(4, "VIDIOCSCHAN");
 
-		if (copy_from_user(&v, arg, sizeof(v)))
-			return -EFAULT;
-
 		/* Make sure it's not a camera */
 		if (!ov->has_decoder) {
-			if (v.channel == 0)
+			if (v->channel == 0)
 				return 0;
 			else
 				return -EINVAL;
 		}
 
-		if (v.norm != VIDEO_MODE_PAL &&
-		    v.norm != VIDEO_MODE_NTSC &&
-		    v.norm != VIDEO_MODE_SECAM &&
-		    v.norm != VIDEO_MODE_AUTO) {
-			err("Invalid norm (%d)", v.norm);
+		if (v->norm != VIDEO_MODE_PAL &&
+		    v->norm != VIDEO_MODE_NTSC &&
+		    v->norm != VIDEO_MODE_SECAM &&
+		    v->norm != VIDEO_MODE_AUTO) {
+			err("Invalid norm (%d)", v->norm);
 			return -EINVAL;
 		}
 
-		if ((unsigned)(v.channel) >= ov->num_inputs) {
-			err("Invalid channel (%d)", v.channel);
+		if ((unsigned)(v->channel) >= ov->num_inputs) {
+			err("Invalid channel (%d)", v->channel);
 			return -EINVAL;
 		}
 
-		err = decoder_set_input(ov, v.channel);
+		err = decoder_set_input(ov, v->channel);
 		if (err)
 			return err;
 
-		err = decoder_set_norm(ov, v.norm);
+		err = decoder_set_norm(ov, v->norm);
 		if (err)
 			return err;
 
@@ -4861,43 +4658,37 @@
 	}
 	case VIDIOCGPICT:
 	{
-		struct video_picture p;
+		struct video_picture *p = arg;
 
 		PDEBUG(4, "VIDIOCGPICT");
 
-		memset(&p, 0, sizeof(p));
-
-		if (sensor_get_picture(ov, &p))
+		memset(p, 0, sizeof(struct video_picture));
+		if (sensor_get_picture(ov, p))
 			return -EIO;
 
-		if (copy_to_user(arg, &p, sizeof(p)))
-			return -EFAULT;
-
 		return 0;
 	}
 	case VIDIOCSPICT:
 	{
-		struct video_picture p;
+		struct video_picture *p = arg;
 		int i;
 
 		PDEBUG(4, "VIDIOCSPICT");
 
-		if (copy_from_user(&p, arg, sizeof(p)))
-			return -EFAULT;
-
-		if (!get_depth(p.palette))
+		if (!get_depth(p->palette))
 			return -EINVAL;
 
-		if (sensor_set_picture(ov, &p))
+		if (sensor_set_picture(ov, p))
 			return -EIO;
 
-		if (force_palette && p.palette != force_palette) {
-			info("Palette rejected (%d)", p.palette);
+		if (force_palette && p->palette != force_palette) {
+			info("Palette rejected (%s)",
+			     symbolic(v4l1_plist, p->palette));
 			return -EINVAL;
 		}
 
 		// FIXME: Format should be independent of frames
-		if (p.palette != ov->frame[0].format) {
+		if (p->palette != ov->frame[0].format) {
 			PDEBUG(4, "Detected format change");
 
 			/* If we're collecting previous frame wait
@@ -4906,79 +4697,73 @@
 			if (signal_pending(current)) return -EINTR;
 
 			mode_init_regs(ov, ov->frame[0].width,
-				ov->frame[0].height, p.palette, ov->sub_flag);
+				ov->frame[0].height, p->palette, ov->sub_flag);
 		}
 
-		PDEBUG(4, "Setting depth=%d, palette=%d", p.depth, p.palette);
+		PDEBUG(4, "Setting depth=%d, palette=%s",
+		       p->depth, symbolic(v4l1_plist, p->palette));
+
 		for (i = 0; i < OV511_NUMFRAMES; i++) {
-			ov->frame[i].depth = p.depth;
-			ov->frame[i].format = p.palette;
+			ov->frame[i].depth = p->depth;
+			ov->frame[i].format = p->palette;
 		}
 
 		return 0;
 	}
 	case VIDIOCGCAPTURE:
 	{
-		int vf;
+		int *vf = arg;
 
 		PDEBUG(4, "VIDIOCGCAPTURE");
 
-		if (copy_from_user(&vf, arg, sizeof(vf)))
-			return -EFAULT;
-		ov->sub_flag = vf;
+		ov->sub_flag = *vf;
 		return 0;
 	}
 	case VIDIOCSCAPTURE:
 	{
-		struct video_capture vc;
+		struct video_capture *vc = arg;
 
 		PDEBUG(4, "VIDIOCSCAPTURE");
 
-		if (copy_from_user(&vc, arg, sizeof(vc)))
-			return -EFAULT;
-		if (vc.flags)
+		if (vc->flags)
 			return -EINVAL;
-		if (vc.decimation)
+		if (vc->decimation)
 			return -EINVAL;
 
-		vc.x &= ~3L;
-		vc.y &= ~1L;
-		vc.y &= ~31L;
-
-		if (vc.width == 0)
-			vc.width = 32;
-
-		vc.height /= 16;
-		vc.height *= 16;
-		if (vc.height == 0)
-			vc.height = 16;
-
-		ov->subx = vc.x;
-		ov->suby = vc.y;
-		ov->subw = vc.width;
-		ov->subh = vc.height;
+		vc->x &= ~3L;
+		vc->y &= ~1L;
+		vc->y &= ~31L;
+
+		if (vc->width == 0)
+			vc->width = 32;
+
+		vc->height /= 16;
+		vc->height *= 16;
+		if (vc->height == 0)
+			vc->height = 16;
+
+		ov->subx = vc->x;
+		ov->suby = vc->y;
+		ov->subw = vc->width;
+		ov->subh = vc->height;
 
 		return 0;
 	}
 	case VIDIOCSWIN:
 	{
-		struct video_window vw;
+		struct video_window *vw = arg;
 		int i, result;
 
-		if (copy_from_user(&vw, arg, sizeof(vw)))
-			return -EFAULT;
-
-		PDEBUG(4, "VIDIOCSWIN: width=%d, height=%d",
-			vw.width, vw.height);
+		PDEBUG(4, "VIDIOCSWIN: %dx%d", vw->width, vw->height);
 
 #if 0
-		if (vw.flags)
+		if (vw->flags)
 			return -EINVAL;
-		if (vw.clipcount)
+		if (vw->clipcount)
 			return -EINVAL;
-		if (vw.height != ov->maxheight)
+		if (vw->height != ov->maxheight)
 			return -EINVAL;
-		if (vw.width != ov->maxwidth)
+		if (vw->width != ov->maxwidth)
 			return -EINVAL;
 #endif
 
@@ -4987,140 +4772,131 @@
 		interruptible_sleep_on(&ov->wq);
 		if (signal_pending(current)) return -EINTR;
 
-		result = mode_init_regs(ov, vw.width, vw.height,
+		result = mode_init_regs(ov, vw->width, vw->height,
 			ov->frame[0].format, ov->sub_flag);
 		if (result < 0)
 			return result;
 
 		for (i = 0; i < OV511_NUMFRAMES; i++) {
-			ov->frame[i].width = vw.width;
-			ov->frame[i].height = vw.height;
+			ov->frame[i].width = vw->width;
+			ov->frame[i].height = vw->height;
 		}
 
 		return 0;
 	}
 	case VIDIOCGWIN:
 	{
-		struct video_window vw;
-
-		memset(&vw, 0, sizeof(vw));
-		vw.x = 0;		/* FIXME */
-		vw.y = 0;
-		vw.width = ov->frame[0].width;
-		vw.height = ov->frame[0].height;
-		vw.flags = 30;
+		struct video_window *vw = arg;
 
-		PDEBUG(4, "VIDIOCGWIN: %dx%d", vw.width, vw.height);
+		memset(vw, 0, sizeof(struct video_window));
+		vw->x = 0;		/* FIXME */
+		vw->y = 0;
+		vw->width = ov->frame[0].width;
+		vw->height = ov->frame[0].height;
+		vw->flags = 30;
 
-		if (copy_to_user(arg, &vw, sizeof(vw)))
-			return -EFAULT;
+		PDEBUG(4, "VIDIOCGWIN: %dx%d", vw->width, vw->height);
 
 		return 0;
 	}
 	case VIDIOCGMBUF:
 	{
-		struct video_mbuf vm;
+		struct video_mbuf *vm = arg;
 		int i;
 
 		PDEBUG(4, "VIDIOCGMBUF");
 
-		memset(&vm, 0, sizeof(vm));
-		vm.size = OV511_NUMFRAMES
-			* MAX_DATA_SIZE(ov->maxwidth, ov->maxheight);
-		vm.frames = OV511_NUMFRAMES;
+		memset(vm, 0, sizeof(struct video_mbuf));
+		vm->size = OV511_NUMFRAMES
+			   * MAX_DATA_SIZE(ov->maxwidth, ov->maxheight);
+		vm->frames = OV511_NUMFRAMES;
 
-		vm.offsets[0] = 0;
+		vm->offsets[0] = 0;
 		for (i = 1; i < OV511_NUMFRAMES; i++) {
-			vm.offsets[i] = vm.offsets[i-1]
+			vm->offsets[i] = vm->offsets[i-1]
 			   + MAX_DATA_SIZE(ov->maxwidth, ov->maxheight);
 		}
 
-		if (copy_to_user((void *)arg, (void *)&vm, sizeof(vm)))
-			return -EFAULT;
-
 		return 0;
 	}
 	case VIDIOCMCAPTURE:
 	{
-		struct video_mmap vm;
+		struct video_mmap *vm = arg;
 		int ret, depth;
+		unsigned int f = vm->frame;
 
-		if (copy_from_user((void *)&vm, (void *)arg, sizeof(vm)))
-			return -EFAULT;
-
-		PDEBUG(4, "CMCAPTURE");
-		PDEBUG(4, "frame: %d, size: %dx%d, format: %d",
-			vm.frame, vm.width, vm.height, vm.format);
+		PDEBUG(4, "VIDIOCMCAPTURE: frame: %d, %dx%d, %s", f, vm->width,
+			vm->height, symbolic(v4l1_plist, vm->format));
 
-		depth = get_depth(vm.format);
+		depth = get_depth(vm->format);
 		if (!depth) {
-			err("VIDIOCMCAPTURE: invalid format (%d)", vm.format);
+			err("VIDIOCMCAPTURE: invalid format (%s)",
+			    symbolic(v4l1_plist, vm->format));
 			return -EINVAL;
 		}
 
-		if ((unsigned)vm.frame >= OV511_NUMFRAMES) {
-			err("VIDIOCMCAPTURE: invalid frame (%d)", vm.frame);
+		if (f >= OV511_NUMFRAMES) {
+			err("VIDIOCMCAPTURE: invalid frame (%d)", f);
 			return -EINVAL;
 		}
 
-		if (vm.width > ov->maxwidth 
-		    || vm.height > ov->maxheight) {
+		if (vm->width > ov->maxwidth
+		    || vm->height > ov->maxheight) {
 			err("VIDIOCMCAPTURE: requested dimensions too big");
 			return -EINVAL;
 		}
 
-		if (ov->frame[vm.frame].grabstate == FRAME_GRABBING) {
+		if (ov->frame[f].grabstate == FRAME_GRABBING) {
 			PDEBUG(4, "VIDIOCMCAPTURE: already grabbing");
 			return -EBUSY;
 		}
 
-		if (force_palette && vm.format != force_palette) {
-			info("palette rejected (%d)", vm.format);
+		if (force_palette && (vm->format != force_palette)) {
+			info("palette rejected (%s)",
+			     symbolic(v4l1_plist, vm->format));
 			return -EINVAL;
 		}
 
-		if ((ov->frame[vm.frame].width != vm.width) ||
-		    (ov->frame[vm.frame].height != vm.height) ||
-		    (ov->frame[vm.frame].format != vm.format) ||
-		    (ov->frame[vm.frame].sub_flag != ov->sub_flag) ||
-		    (ov->frame[vm.frame].depth != depth)) {
+		if ((ov->frame[f].width != vm->width) ||
+		    (ov->frame[f].height != vm->height) ||
+		    (ov->frame[f].format != vm->format) ||
+		    (ov->frame[f].sub_flag != ov->sub_flag) ||
+		    (ov->frame[f].depth != depth)) {
 			PDEBUG(4, "VIDIOCMCAPTURE: change in image parameters");
 
 			/* If we're collecting previous frame wait
 			   before changing modes */
 			interruptible_sleep_on(&ov->wq);
 			if (signal_pending(current)) return -EINTR;
-			ret = mode_init_regs(ov, vm.width, vm.height,
-				vm.format, ov->sub_flag);
+			ret = mode_init_regs(ov, vm->width, vm->height,
+				vm->format, ov->sub_flag);
 #if 0
 			if (ret < 0) {
 				PDEBUG(1, "Got error while initializing regs ");
 				return ret;
 			}
 #endif
-			ov->frame[vm.frame].width = vm.width;
-			ov->frame[vm.frame].height = vm.height;
-			ov->frame[vm.frame].format = vm.format;
-			ov->frame[vm.frame].sub_flag = ov->sub_flag;
-			ov->frame[vm.frame].depth = depth;
+			ov->frame[f].width = vm->width;
+			ov->frame[f].height = vm->height;
+			ov->frame[f].format = vm->format;
+			ov->frame[f].sub_flag = ov->sub_flag;
+			ov->frame[f].depth = depth;
 		}
 
 		/* Mark it as ready */
-		ov->frame[vm.frame].grabstate = FRAME_READY;
+		ov->frame[f].grabstate = FRAME_READY;
 
-		PDEBUG(4, "VIDIOCMCAPTURE: renewing frame %d", vm.frame);
+		PDEBUG(4, "VIDIOCMCAPTURE: renewing frame %d", f);
 
-		return ov51x_new_frame(ov, vm.frame);
+		return ov51x_new_frame(ov, f);
 	}
 	case VIDIOCSYNC:
 	{
-		int fnum, rc;
+		unsigned int fnum = *((unsigned int *) arg);
 		struct ov511_frame *frame;
+		int rc;
 
-		if (copy_from_user((void *)&fnum, arg, sizeof(int)))
-			return -EFAULT;
-
-		if ((unsigned)fnum >= OV511_NUMFRAMES) {
+		if (fnum >= OV511_NUMFRAMES) {
 			err("VIDIOCSYNC: invalid frame (%d)", fnum);
 			return -EINVAL;
 		}
@@ -5154,7 +4930,7 @@
 					return ret;
 				goto redo;
 			}
-			/* Fall through */			
+			/* Fall through */
 		case FRAME_DONE:
 			if (ov->snap_enabled && !frame->snapshot) {
 				int ret;
@@ -5182,159 +4958,109 @@
 	}
 	case VIDIOCGFBUF:
 	{
-		struct video_buffer vb;
-
-		PDEBUG(4, "VIDIOCSCHAN");
+		struct video_buffer *vb = arg;
 
-		memset(&vb, 0, sizeof(vb));
-		vb.base = NULL;	/* frame buffer not supported, not used */
+		PDEBUG(4, "VIDIOCGFBUF");
 
-		if (copy_to_user((void *)arg, (void *)&vb, sizeof(vb)))
-			return -EFAULT;
+		memset(vb, 0, sizeof(struct video_buffer));
 
 		return 0;
 	}
 	case VIDIOCGUNIT:
 	{
-		struct video_unit vu;
+		struct video_unit *vu = arg;
 
 		PDEBUG(4, "VIDIOCGUNIT");
 
-		memset(&vu, 0, sizeof(vu));
-
-		vu.video = ov->vdev.minor;	/* Video minor */
-		vu.vbi = VIDEO_NO_UNIT;		/* VBI minor */
-		vu.radio = VIDEO_NO_UNIT;	/* Radio minor */
-		vu.audio = VIDEO_NO_UNIT;	/* Audio minor */
-		vu.teletext = VIDEO_NO_UNIT;	/* Teletext minor */
-
-		if (copy_to_user((void *)arg, (void *)&vu, sizeof(vu)))
-			return -EFAULT;
-
-		return 0;
-	}
-	case VIDIOCGTUNER:
-	{
-		struct video_tuner v;
-
-		PDEBUG(4, "VIDIOCGTUNER");
-
-		if (copy_from_user(&v, arg, sizeof(v)))
-			return -EFAULT;
-
-		if (!ov->has_tuner || v.tuner)	// Only tuner 0
-			return -EINVAL;
-
-		strcpy(v.name, "Television");
-
-		// FIXME: Need a way to get the real values
-		v.rangelow = 0;
-		v.rangehigh = ~0;
-
-		v.flags = VIDEO_TUNER_PAL | VIDEO_TUNER_NTSC |
-		    VIDEO_TUNER_SECAM;
-		v.mode = 0; 		/* FIXME:  Not sure what this is yet */
-		v.signal = 0xFFFF;	/* unknown */
-
-		call_i2c_clients(ov, cmd, &v);
-
-		if (copy_to_user(arg, &v, sizeof(v)))
-			return -EFAULT;
-
-		return 0;
-	}
-	case VIDIOCSTUNER:
-	{
-		struct video_tuner v;
-		int err;
-
-		PDEBUG(4, "VIDIOCSTUNER");
-
-		if (copy_from_user(&v, arg, sizeof(v)))
-			return -EFAULT;
-
-		/* Only no or one tuner for now */
-		if (!ov->has_tuner || v.tuner)
-			return -EINVAL;
-
-		/* and it only has certain valid modes */
-		if (v.mode != VIDEO_MODE_PAL &&
-		    v.mode != VIDEO_MODE_NTSC &&
-		    v.mode != VIDEO_MODE_SECAM) return -EOPNOTSUPP;
-
-		/* Is this right/necessary? */
-		err = decoder_set_norm(ov, v.mode);
-		if (err)
-			return err;
+		memset(vu, 0, sizeof(struct video_unit));
 
-		call_i2c_clients(ov, cmd, &v);
+		vu->video = ov->vdev.minor;
+		vu->vbi = VIDEO_NO_UNIT;
+		vu->radio = VIDEO_NO_UNIT;
+		vu->audio = VIDEO_NO_UNIT;
+		vu->teletext = VIDEO_NO_UNIT;
 
 		return 0;
 	}
-	case VIDIOCGFREQ:
-	{
-		unsigned long v = ov->freq;
+	default:
+		PDEBUG(3, "Unsupported IOCtl: 0x%X", cmd);
+		return -ENOIOCTLCMD;
+	} /* end switch */
 
-		PDEBUG(4, "VIDIOCGFREQ");
+	return 0;
+}
 
-		if (!ov->has_tuner)
-			return -EINVAL;
-#if 0
-		/* FIXME: this is necessary for testing */
-		v = 46*16;
-#endif
-		if (copy_to_user(arg, &v, sizeof(v)))
-			return -EFAULT;
+/* This is implemented as video_generic_ioctl() in the new V4L's videodev.c */
+static int
+ov51x_v4l1_generic_ioctl(struct video_device *vdev, unsigned int cmd, void *arg)
+{
+	char	sbuf[128];
+	void    *mbuf = NULL;
+	void	*parg = NULL;
+	int	err  = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		parg = arg;
+		break;
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
 
-		return 0;
+		err = -EFAULT;
+		if (copy_from_user(parg, arg, _IOC_SIZE(cmd)))
+			goto out;
+		break;
 	}
-	case VIDIOCSFREQ:
-	{
-		unsigned long v;
-
-		if (!ov->has_tuner)
-			return -EINVAL;
-
-		if (copy_from_user(&v, arg, sizeof(v)))
-			return -EFAULT;
-
-		PDEBUG(4, "VIDIOCSFREQ: %lx", v);
 
-		ov->freq = v;
-		call_i2c_clients(ov, cmd, &v);
+	err = ov51x_v4l1_ioctl_internal(vdev->priv, cmd, parg);
+	if (err == -ENOIOCTLCMD)
+		err = -EINVAL;
+	if (err < 0)
+		goto out;
 
-		return 0;
-	}
-	case VIDIOCGAUDIO:
-	case VIDIOCSAUDIO:
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd))
 	{
-		/* FIXME: Implement this... */
-		return 0;
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user(arg, parg, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+		break;
 	}
-	default:
-		PDEBUG(3, "Unsupported IOCtl: 0x%X", cmd);
-		return -ENOIOCTLCMD;
-	} /* end switch */
 
-	return 0;
+out:
+	if (mbuf)
+		kfree(mbuf);
+	return err;
 }
 
-static int 
+static int
 ov51x_v4l1_ioctl(struct video_device *vdev, unsigned int cmd, void *arg)
 {
-	int rc;
 	struct usb_ov511 *ov = vdev->priv;
+	int rc;
 
 	if (down_interruptible(&ov->lock))
 		return -EINTR;
 
-	rc = ov51x_v4l1_ioctl_internal(vdev, cmd, arg);
+	rc = ov51x_v4l1_generic_ioctl(vdev, cmd, arg);
 
 	up(&ov->lock);
 	return rc;
 }
 
-static inline long 
+static inline long
 ov51x_v4l1_read(struct video_device *vdev, char *buf, unsigned long count,
 		int noblock)
 {
@@ -5397,7 +5123,7 @@
 
 	/* Wait while we're grabbing the image */
 	PDEBUG(4, "Waiting image grabbing");
-	rc = wait_event_interruptible(frame->wq, 
+	rc = wait_event_interruptible(frame->wq,
 		(frame->grabstate == FRAME_DONE)
 		|| (frame->grabstate == FRAME_ERROR));
 
@@ -5444,7 +5170,7 @@
 		get_frame_length(frame));
 
 	/* copy bytes to user space; we allow for partials reads */
-//	if ((count + frame->bytes_read) 
+//	if ((count + frame->bytes_read)
 //	    > get_frame_length((struct ov511_frame *)frame))
 //		count = frame->scanlength - frame->bytes_read;
 
@@ -5486,11 +5212,11 @@
 	return rc;
 }
 
-static int 
+static int
 ov51x_v4l1_mmap(struct video_device *vdev, const char *adr, unsigned long size)
 {
-	struct usb_ov511 *ov = vdev->priv;
 	unsigned long start = (unsigned long)adr;
+	struct usb_ov511 *ov = vdev->priv;
 	unsigned long page, pos;
 
 	if (ov->dev == NULL)
@@ -5533,14 +5259,12 @@
 	open:		ov51x_v4l1_open,
 	close:		ov51x_v4l1_close,
 	read:		ov51x_v4l1_read,
-	write:		ov51x_v4l1_write,
 	ioctl:		ov51x_v4l1_ioctl,
 	mmap:		ov51x_v4l1_mmap,
-	initialize:	ov51x_v4l1_init_done,
 };
 
 #if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
-static int 
+static int
 ov51x_control_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
 		    unsigned long ularg)
 {
@@ -5761,10 +5485,10 @@
  *
  ***************************************************************************/
 
-/* This initializes the OV7610, OV7620, or OV7620AE sensor. The OV7620AE uses
+/* This initializes the OV7610, OV7620, or OV76BE sensor. The OV76BE uses
  * the same register settings as the OV7610, since they are very similar.
  */
-static int 
+static int
 ov7xx0_configure(struct usb_ov511 *ov)
 {
 	int i, success;
@@ -5915,7 +5639,7 @@
 			err("this to " EMAIL);
 			err("This is only a warning. You can attempt to use");
 			err("your camera anyway");
-// Only issue a warning for now  
+// Only issue a warning for now
 //			return -1;
 		} else {
 			PDEBUG(1, "OV7xx0 initialized (method 2, %dx)", i+1);
@@ -5932,20 +5656,23 @@
 		info("Sensor is an OV7610");
 		ov->sensor = SEN_OV7610;
 	} else if ((rc & 3) == 1) {
-		/* I don't know what's different about the 76BE yet */
-		if (i2c_r(ov, 0x15) & 1)
+		/* I don't know what's different about the 76BE yet. */
+		if (i2c_r(ov, 0x15) & 1) {
 			info("Sensor is an OV7620AE");
-		else
+			info("PLEASE REPORT THE EXISTENCE OF THIS SENSOR TO");
+			info("THE DRIVER AUTHOR");
+		} else {
 			info("Sensor is an OV76BE");
+		}
 
 		/* OV511+ will return all zero isoc data unless we
 		 * configure the sensor as a 7620. Someone needs to
 		 * find the exact reg. setting that causes this. */
 		if (ov->bridge == BRG_OV511PLUS) {
-			info("Enabling 511+/7620AE workaround");
+			info("Enabling 511+/76BE workaround");
 			ov->sensor = SEN_OV7620;
 		} else {
-			ov->sensor = SEN_OV7620AE;
+			ov->sensor = SEN_OV76BE;
 		}
 	} else if ((rc & 3) == 0) {
 		info("Sensor is an OV7620");
@@ -5981,7 +5708,7 @@
 }
 
 /* This initializes the OV6620, OV6630, OV6630AE, or OV6630AF sensor. */
-static int 
+static int
 ov6xx0_configure(struct usb_ov511 *ov)
 {
 	int rc;
@@ -5995,6 +5722,8 @@
 		/* The ratio of 0x0c and 0x0d  controls the white point */
 		{ OV511_I2C_BUS, 0x0c, 0x24 },
 		{ OV511_I2C_BUS, 0x0d, 0x24 },
+		{ OV511_I2C_BUS, 0x0f, 0x15 }, /* COMS */
+		{ OV511_I2C_BUS, 0x10, 0x75 }, /* AEC Exposure time */
 		{ OV511_I2C_BUS, 0x12, 0x24 }, /* Enable AGC */
 		{ OV511_I2C_BUS, 0x14, 0x04 },
 		/* 0x16: 0x06 helps frame stability with moving objects */
@@ -6006,10 +5735,11 @@
 		{ OV511_I2C_BUS, 0x2a, 0x04 }, /* Disable framerate adjust */
 //		{ OV511_I2C_BUS, 0x2b, 0xac }, /* Framerate; Set 2a[7] first */
 		{ OV511_I2C_BUS, 0x2d, 0x99 },
+		{ OV511_I2C_BUS, 0x33, 0xa0 }, /* Color Procesing Parameter */
 		{ OV511_I2C_BUS, 0x34, 0xd2 }, /* Max A/D range */
 		{ OV511_I2C_BUS, 0x38, 0x8b },
 		{ OV511_I2C_BUS, 0x39, 0x40 },
-		
+
 		{ OV511_I2C_BUS, 0x3c, 0x39 }, /* Enable AEC mode changing */
 		{ OV511_I2C_BUS, 0x3c, 0x3c }, /* Change AEC mode */
 		{ OV511_I2C_BUS, 0x3c, 0x24 }, /* Disable AEC mode changing */
@@ -6089,7 +5819,7 @@
 		 * control the color balance */
 //	/*OK?*/	{ OV511_I2C_BUS, 0x4a, 0x80 }, // Check these
 //	/*OK?*/	{ OV511_I2C_BUS, 0x4b, 0x80 },
-//	/*U*/	{ OV511_I2C_BUS, 0x4c, 0xd0 }, 
+//	/*U*/	{ OV511_I2C_BUS, 0x4c, 0xd0 },
 	/*d2?*/	{ OV511_I2C_BUS, 0x4d, 0x10 }, /* This reduces noise a bit */
 	/*c1?*/	{ OV511_I2C_BUS, 0x4e, 0x40 },
 	/*04?*/	{ OV511_I2C_BUS, 0x4f, 0x07 },
@@ -6107,7 +5837,7 @@
 	};
 
 	PDEBUG(4, "starting sensor configuration");
-	
+
 	if (init_ov_sensor(ov) < 0) {
 		err("Failed to read sensor ID. You might not have an OV6xx0,");
 		err("or it may be not responding. Report this to " EMAIL);
@@ -6122,19 +5852,18 @@
 	if (rc < 0) {
 		err("Error detecting sensor type");
 		return -1;
-	} else if ((rc & 3) == 0) {
-		info("Sensor is an OV6630");
+	}
+
+	if ((rc & 3) == 0)
 		ov->sensor = SEN_OV6630;
-	} else if ((rc & 3) == 1) {
-		info("Sensor is an OV6620");
+	else if ((rc & 3) == 1)
 		ov->sensor = SEN_OV6620;
-	} else if ((rc & 3) == 2) {
-		info("Sensor is an OV6630AE");
+	else if ((rc & 3) == 2)
 		ov->sensor = SEN_OV6630;
-	} else if ((rc & 3) == 3) {
-		info("Sensor is an OV6630AF");
+	else if ((rc & 3) == 3)
 		ov->sensor = SEN_OV6630;
-	} 
+
+	info("Sensor is an %s", symbolic(senlist, ov->sensor));
 
 	/* Set sensor-specific vars */
 	ov->maxwidth = 352;
@@ -6157,7 +5886,7 @@
 		if (write_regvals(ov, aRegvalsNorm6x30))
 			return -1;
 	}
-	
+
 	return 0;
 }
 
@@ -6219,8 +5948,8 @@
 }
 
 /* This initializes the SAA7111A video decoder. */
-static int 
-saa7111a_configure(struct usb_ov511 *ov511)
+static int
+saa7111a_configure(struct usb_ov511 *ov)
 {
 	int rc;
 
@@ -6264,45 +5993,51 @@
 	}
 #endif
 
-	/* Set sensor-specific vars */
-	ov511->maxwidth = 640;
-	ov511->maxheight = 480;		/* Even/Odd fields */
-	ov511->minwidth = 320;
-	ov511->minheight = 240;		/* Even field only */
-
-	ov511->has_decoder = 1;
-	ov511->num_inputs = 8;
-	ov511->norm = VIDEO_MODE_AUTO;
-	ov511->stop_during_set = 0;	/* Decoder guarantees stable image */
+	/* 640x480 not supported with PAL */
+	if (ov->pal) {
+		ov->maxwidth = 320;
+		ov->maxheight = 240;		/* Even field only */
+	} else {
+		ov->maxwidth = 640;
+		ov->maxheight = 480;		/* Even/Odd fields */
+	}
+
+	ov->minwidth = 320;
+	ov->minheight = 240;		/* Even field only */
+
+	ov->has_decoder = 1;
+	ov->num_inputs = 8;
+	ov->norm = VIDEO_MODE_AUTO;
+	ov->stop_during_set = 0;	/* Decoder guarantees stable image */
 
 	/* Decoder doesn't change these values, so we use these instead of
 	 * acutally reading the registers (which doesn't work) */
-	ov511->brightness = 0x80 << 8;
-	ov511->contrast = 0x40 << 9;
-	ov511->colour = 0x40 << 9;
-	ov511->hue = 32768;
+	ov->brightness = 0x80 << 8;
+	ov->contrast = 0x40 << 9;
+	ov->colour = 0x40 << 9;
+	ov->hue = 32768;
 
 	PDEBUG(4, "Writing SAA7111A registers");
-	if (write_regvals(ov511, aRegvalsNormSAA7111A))
+	if (write_regvals(ov, aRegvalsNormSAA7111A))
 		return -1;
 
 	/* Detect version of decoder. This must be done after writing the
          * initial regs or the decoder will lock up. */
-	rc = i2c_r(ov511, 0x00);
+	rc = i2c_r(ov, 0x00);
 
 	if (rc < 0) {
 		err("Error detecting sensor version");
 		return -1;
 	} else {
 		info("Sensor is an SAA7111A (version 0x%x)", rc);
-		ov511->sensor = SEN_SAA7111A;
+		ov->sensor = SEN_SAA7111A;
 	}
 
 	// FIXME: Fix this for OV518(+)
 	/* Latch to negative edge of clock. Otherwise, we get incorrect
 	 * colors and jitter in the digital signal. */
-	if (ov511->bclass == BCL_OV511)
-		reg_w(ov511, 0x11, 0x00);
+	if (ov->bclass == BCL_OV511)
+		reg_w(ov, 0x11, 0x00);
 	else
 		warn("SAA7111A not yet supported with OV518/OV518+");
 
@@ -6313,8 +6048,6 @@
 static int 
 ov511_configure(struct usb_ov511 *ov)
 {
-	int i;
-
 	static struct ov511_regvals aRegvalsInit511[] = {
 		{ OV511_REG_BUS, R51x_SYS_RESET,	0x7f },
 	 	{ OV511_REG_BUS, R51x_SYS_INIT,		0x01 },
@@ -6356,26 +6089,19 @@
 		goto error;
 	}
 
-	ov->desc = -1;
 	PDEBUG (1, "CustomID = %d", ov->customid);
-	for (i = 0; clist[i].id >= 0; i++) {
-		if (ov->customid == clist[i].id) {
-			info("model: %s", clist[i].description);
-			ov->desc = i;
-			break;
-		}
-	}
+	ov->desc = symbolic(camlist, ov->customid);
+	info("model: %s", ov->desc);
 
-	if (clist[i].id == -1) {
+	if (0 == strcmp(ov->desc, NOT_DEFINED_STR)) {
 		err("Camera type (%d) not recognized", ov->customid);
 		err("Please notify " EMAIL " of the name,");
 		err("manufacturer, model, and this number of your camera.");
 		err("Also include the output of the detection process.");
 	} 
 
-	if (clist[i].id == 6) {	/* USB Life TV (NTSC) */
-		ov->tuner_type = 8;		/* Temic 4036FY5 3X 1981 */
-	}
+	if (ov->customid == 70)		/* USB Life TV (PAL/SECAM) */
+		ov->pal = 1;
 
 	if (write_regvals(ov, aRegvalsInit511)) goto error;
 
@@ -6394,9 +6120,10 @@
 
 	if (ov511_init_compression(ov)) goto error;
 
-	ov51x_set_packet_size(ov, 0);
+	ov->packet_numbering = 1;
+	ov511_set_packet_size(ov, 0);
 
-	ov->snap_enabled = snapshot;	
+	ov->snap_enabled = snapshot;
 
 	/* Test for 7xx0 */
 	PDEBUG(3, "Testing for 0V7xx0");
@@ -6415,21 +6142,21 @@
 			/* Test for 8xx0 */
 			PDEBUG(3, "Testing for 0V8xx0");
 			ov->primary_i2c_slave = OV8xx0_SID;
-			if (ov51x_set_slave_ids(ov, OV8xx0_SID))
+			if (ov51x_set_slave_ids(ov, OV8xx0_SID) < 0)
 				goto error;
 
 			if (i2c_w(ov, 0x12, 0x80) < 0) {
 				/* Test for SAA7111A */
 				PDEBUG(3, "Testing for SAA7111A");
 				ov->primary_i2c_slave = SAA7111A_SID;
-				if (ov51x_set_slave_ids(ov, SAA7111A_SID))
+				if (ov51x_set_slave_ids(ov, SAA7111A_SID) < 0)
 					goto error;
 
 				if (i2c_w(ov, 0x0d, 0x00) < 0) {
 					/* Test for KS0127 */
 					PDEBUG(3, "Testing for KS0127");
 					ov->primary_i2c_slave = KS0127_SID;
-					if (ov51x_set_slave_ids(ov, KS0127_SID))
+					if (ov51x_set_slave_ids(ov, KS0127_SID) < 0)
 						goto error;
 
 					if (i2c_w(ov, 0x10, 0x00) < 0) {
@@ -6473,9 +6200,10 @@
 }
 
 /* This initializes the OV518/OV518+ and the sensor */
-static int 
+static int
 ov518_configure(struct usb_ov511 *ov)
 {
+	/* For 518 and 518+ */
 	static struct ov511_regvals aRegvalsInit518[] = {
 		{ OV511_REG_BUS, R51x_SYS_RESET,	0x40 },
 	 	{ OV511_REG_BUS, R51x_SYS_INIT,		0xe1 },
@@ -6488,8 +6216,6 @@
 		{ OV511_DONE_BUS, 0x0, 0x00},
 	};
 
-	/* New values, based on Windows driver. Since what they do is not
-	 * known yet, this may be incorrect. */
 	static struct ov511_regvals aRegvalsNorm518[] = {
 		{ OV511_REG_BUS, R51x_SYS_SNAP,		0x02 }, /* Reset */
 		{ OV511_REG_BUS, R51x_SYS_SNAP,		0x01 }, /* Enable */
@@ -6503,11 +6229,33 @@
 		{ OV511_DONE_BUS, 0x0, 0x00 },
 	};
 
+	static struct ov511_regvals aRegvalsNorm518Plus[] = {
+		{ OV511_REG_BUS, R51x_SYS_SNAP,		0x02 }, /* Reset */
+		{ OV511_REG_BUS, R51x_SYS_SNAP,		0x01 }, /* Enable */
+		{ OV511_REG_BUS, 0x31, 			0x0f },
+		{ OV511_REG_BUS, 0x5d,			0x03 },
+		{ OV511_REG_BUS, 0x24,			0x9f },
+		{ OV511_REG_BUS, 0x25,			0x90 },
+		{ OV511_REG_BUS, 0x20,			0x60 }, /* Was 0x08 */
+		{ OV511_REG_BUS, 0x51,			0x02 },
+		{ OV511_REG_BUS, 0x71,			0x19 },
+		{ OV511_REG_BUS, 0x40,			0xff },
+		{ OV511_REG_BUS, 0x41,			0x42 },
+		{ OV511_REG_BUS, 0x46,			0x00 },
+		{ OV511_REG_BUS, 0x33,			0x04 },
+		{ OV511_REG_BUS, 0x21,			0x19 },
+		{ OV511_REG_BUS, 0x3f,			0x10 },
+		{ OV511_DONE_BUS, 0x0, 0x00 },
+	};
+
 	PDEBUG(4, "");
 
 	/* First 5 bits of custom ID reg are a revision ID on OV518 */
 	info("Device revision %d", 0x1F & reg_r(ov, R511_SYS_CUST_ID));
 
+	/* Give it the default description */
+	ov->desc = symbolic(camlist, 0);
+
 	if (write_regvals(ov, aRegvalsInit518)) goto error;
 
 	/* Set LED GPIO pin to output mode */
@@ -6526,13 +6274,25 @@
 		warn("Compression required with OV518...enabling");
 	}
 
-	if (write_regvals(ov, aRegvalsNorm518)) goto error;
+	if (ov->bridge == BRG_OV518) {
+		if (write_regvals(ov, aRegvalsNorm518)) goto error;
+	} else if (ov->bridge == BRG_OV518PLUS) {
+		if (write_regvals(ov, aRegvalsNorm518Plus)) goto error;
+	} else {
+		err("Invalid bridge");
+	}
 
 	if (reg_w(ov, 0x2f, 0x80) < 0) goto error;
 
 	if (ov518_init_compression(ov)) goto error;
 
-	ov51x_set_packet_size(ov, 0);
+	/* OV518+ has packet numbering turned on by default */
+	if (ov->bridge == BRG_OV518)
+		ov->packet_numbering = 0;
+	else
+		ov->packet_numbering = 1;
+
+	ov518_set_packet_size(ov, 0);
 
 	ov->snap_enabled = snapshot;
 
@@ -6577,9 +6337,8 @@
 		}
 	}
 
-	// FIXME: Sizes > 320x240 are not working yet
-	ov->maxwidth = 320;
-	ov->maxheight = 240;
+	ov->maxwidth = 352;
+	ov->maxheight = 288;
 
 	// The OV518 cannot go as low as the sensor can
 	ov->minwidth = 160;
@@ -6640,46 +6399,42 @@
 	ov->lightfreq = lightfreq;
 	ov->num_inputs = 1;	   /* Video decoder init functs. change this */
 	ov->stop_during_set = !fastset;
-	ov->tuner_type = tuner;
 	ov->backlight = backlight;
-
+	ov->mirror = mirror;
 	ov->auto_brt = autobright;
 	ov->auto_gain = autogain;
 	ov->auto_exp = autoexp;
 
 	switch (dev->descriptor.idProduct) {
 	case PROD_OV511:
-		info("USB OV511 camera found");
 		ov->bridge = BRG_OV511;
 		ov->bclass = BCL_OV511;
 		break;
 	case PROD_OV511PLUS:
-		info("USB OV511+ camera found");
 		ov->bridge = BRG_OV511PLUS;
 		ov->bclass = BCL_OV511;
 		break;
 	case PROD_OV518:
-		info("USB OV518 camera found");
 		ov->bridge = BRG_OV518;
 		ov->bclass = BCL_OV518;
 		break;
 	case PROD_OV518PLUS:
-		info("USB OV518+ camera found");
 		ov->bridge = BRG_OV518PLUS;
 		ov->bclass = BCL_OV518;
 		break;
 	case PROD_ME2CAM:
 		if (dev->descriptor.idVendor != VEND_MATTEL)
 			goto error;
-		info("Intel Play Me2Cam (OV511+) found");
 		ov->bridge = BRG_OV511PLUS;
 		ov->bclass = BCL_OV511;
 		break;
 	default:
-		err("Unknown product ID 0x%x", dev->descriptor.idProduct);
+		err("Unknown product ID 0x%04x", dev->descriptor.idProduct);
 		goto error_dealloc;
 	}
 
+	info("USB %s video device found", symbolic(brglist, ov->bridge));
+
 	/* Workaround for some applications that want data in RGB
 	 * instead of BGR. */
 	if (force_rgb)
@@ -6713,6 +6468,12 @@
 		init_waitqueue_head(&ov->frame[i].wq);
 	}
 
+	for (i = 0; i < OV511_NUMSBUF; i++) {
+		ov->sbuf[i].ov = ov;
+		spin_lock_init(&ov->sbuf[i].lock);
+		ov->sbuf[i].n = i;
+	}
+
 	/* Unnecessary? (This is done on open(). Need to make sure variables
 	 * are properly initialized without this before removing it, though). */
 	if (ov51x_set_default_params(ov) < 0)
@@ -6747,12 +6508,14 @@
 
 	info("Device registered on minor %d", ov->vdev.minor);
 
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
+	create_proc_ov511_cam(ov);
+#endif
+
 	MOD_DEC_USE_COUNT;
      	return ov;
 
 error:
-	err("Camera initialization failed");
-
 #if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
 	/* Safe to call even if entry doesn't exist */
 	destroy_proc_ov511_cam(ov);
@@ -6765,9 +6528,6 @@
 		up(&ov->cbuf_lock);
 	}
 
-	usb_driver_release_interface(&ov511_driver,
-		&dev->actconfig->interface[ov->iface]);
-
 error_dealloc:
 	if (ov) {
 		kfree(ov);
@@ -6776,6 +6536,7 @@
 
 error_out:
 	MOD_DEC_USE_COUNT;
+	err("Camera initialization failed");
 	return NULL;
 }
 
@@ -6810,22 +6571,12 @@
 
 	ov->streaming = 0;
 
-	/* Unschedule all of the iso td's */
-	for (n = OV511_NUMSBUF - 1; n >= 0; n--) {
-		if (ov->sbuf[n].urb) {
-			ov->sbuf[n].urb->next = NULL;
-			usb_unlink_urb(ov->sbuf[n].urb);
-			usb_free_urb(ov->sbuf[n].urb);
-			ov->sbuf[n].urb = NULL;
-		}
-	}
+	ov51x_unlink_isoc(ov);
 
 #if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
         destroy_proc_ov511_cam(ov);
 #endif
 
-	usb_driver_release_interface(&ov511_driver,
-		&ov->dev->actconfig->interface[ov->iface]);
 	ov->dev = NULL;
 
 	/* Free the memory */
@@ -6858,7 +6609,7 @@
  ***************************************************************************/
 
 /* Returns 0 for success */
-int 
+int
 ov511_register_decomp_module(int ver, struct ov51x_decomp_ops *ops, int ov518,
 			     int mmx)
 {
@@ -6915,7 +6666,7 @@
 	return -EBUSY;
 }
 
-void 
+void
 ov511_deregister_decomp_module(int ov518, int mmx)
 {
 	lock_kernel();
@@ -6931,13 +6682,13 @@
 		else
 			ov511_decomp_ops = NULL;
 	}
-	
+
 	MOD_DEC_USE_COUNT;
 
 	unlock_kernel();
 }
 
-static int __init 
+static int __init
 usb_ov511_init(void)
 {
 #if defined(CONFIG_PROC_FS) && defined(CONFIG_VIDEO_PROC_FS)
@@ -6947,11 +6698,8 @@
 	if (usb_register(&ov511_driver) < 0)
 		return -1;
 
-	// FIXME: Don't know how to determine this yet
-	ov51x_mmx_available = 0;
-
 #if defined (__i386__)
-	if (test_bit(X86_FEATURE_MMX, &boot_cpu_data.x86_capability))
+	if (test_bit(X86_FEATURE_MMX, boot_cpu_data.x86_capability))
 		ov51x_mmx_available = 1;
 #endif
 
@@ -6960,7 +6708,7 @@
 	return 0;
 }
 
-static void __exit 
+static void __exit
 usb_ov511_exit(void)
 {
 	usb_deregister(&ov511_driver);
@@ -6974,6 +6722,5 @@
 module_init(usb_ov511_init);
 module_exit(usb_ov511_exit);
 
-/* No version, for compatibility with binary-only modules */
-EXPORT_SYMBOL_NOVERS(ov511_register_decomp_module);
-EXPORT_SYMBOL_NOVERS(ov511_deregister_decomp_module);
+EXPORT_SYMBOL(ov511_register_decomp_module);
+EXPORT_SYMBOL(ov511_deregister_decomp_module);
diff -Nur linux-2.4.19.old/drivers/usb/ov511.h linux-2.4.19/drivers/usb/ov511.h
--- linux-2.4.19.old/drivers/usb/ov511.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/ov511.h	Mon Nov 25 12:26:55 2002
@@ -10,8 +10,8 @@
 
 #ifdef OV511_DEBUG
 	#define PDEBUG(level, fmt, args...) \
-		if (debug >= (level)) info("[" __PRETTY_FUNCTION__ ":%d] " fmt,\
-		__LINE__ , ## args)
+		if (debug >= (level)) info("[%s:%d] " fmt, \
+		__PRETTY_FUNCTION__, __LINE__ , ## args)
 #else
 	#define PDEBUG(level, fmt, args...) do {} while(0)
 #endif
@@ -243,6 +243,16 @@
 
 #define OV511_ENDPOINT_ADDRESS	1	/* Isoc endpoint number */
 
+#define OV511_NUMFRAMES	2
+#if OV511_NUMFRAMES > VIDEO_MAX_FRAME
+	#error "OV511_NUMFRAMES is too high"
+#endif
+
+#define OV511_NUMSBUF		2
+
+/* Control transfers use up to 4 bytes */
+#define OV511_CBUF_SIZE		4
+
 /* Bridge types */
 enum {
 	BRG_UNKNOWN,
@@ -376,9 +386,14 @@
 			       struct ov511_i2c_struct)
 /* ------------- End IOCTL interface -------------- */
 
+struct usb_ov511;		/* Forward declaration */
+
 struct ov511_sbuf {
-	char *data;
+	struct usb_ov511 *ov;
+	unsigned char *data;
 	struct urb *urb;
+	spinlock_t lock;
+	int n;
 };
 
 enum {
@@ -401,9 +416,10 @@
 
 struct ov511_frame {
 	int framenum;		/* Index of this frame */
-	char *data;		/* Frame buffer */
-	char *tempdata;		/* Temp buffer for multi-stage conversions */
-	char *rawdata;		/* Raw camera data buffer */
+	unsigned char *data;	/* Frame buffer */
+	unsigned char *tempdata; /* Temp buffer for multi-stage conversions */
+	unsigned char *rawdata;	/* Raw camera data buffer */
+	unsigned char *compbuf;	/* Temp buffer for decompressor */
 
 	int depth;		/* Bytes per pixel */
 	int width;		/* Width application is expecting */
@@ -428,27 +444,19 @@
 	int snapshot;		/* True if frame was a snapshot */
 };
 
-#define DECOMP_INTERFACE_VER 2
+#define DECOMP_INTERFACE_VER 4
 
 /* Compression module operations */
 struct ov51x_decomp_ops {
-	int (*decomp_400)(unsigned char *, unsigned char *, int, int, int);
-	int (*decomp_420)(unsigned char *, unsigned char *, int, int, int);
-	int (*decomp_422)(unsigned char *, unsigned char *, int, int, int);
-	void (*decomp_lock)(void);
-	void (*decomp_unlock)(void);
+	int (*decomp_400)(unsigned char *, unsigned char *, unsigned char *,
+			  int, int, int);
+	int (*decomp_420)(unsigned char *, unsigned char *, unsigned char *,
+			  int, int, int);
+	int (*decomp_422)(unsigned char *, unsigned char *, unsigned char *,
+			  int, int, int);
+	struct module *owner;
 };
 
-#define OV511_NUMFRAMES	2
-#if OV511_NUMFRAMES > VIDEO_MAX_FRAME
-	#error "OV511_NUMFRAMES is too high"
-#endif
-
-#define OV511_NUMSBUF		2
-
-/* Control transfers use up to 4 bytes */
-#define OV511_CBUF_SIZE		4
-
 struct usb_ov511 {
 	struct video_device vdev;
 
@@ -456,7 +464,7 @@
 	struct usb_device *dev;
 
 	int customid;
-	int desc;
+	char *desc;
 	unsigned char iface;
 
 	/* Determined by sensor type */
@@ -475,6 +483,7 @@
 	int auto_gain;		/* Auto gain control enabled flag */
 	int auto_exp;		/* Auto exposure enabled flag */
 	int backlight;		/* Backlight exposure algorithm flag */
+	int mirror;		/* Image is reversed horizontally */
 
 	int led_policy;		/* LED: off|on|auto; OV511+ only */
 
@@ -490,9 +499,9 @@
 	int lightfreq;		/* Power (lighting) frequency */
 	int bandfilt;		/* Banding filter enabled flag */
 
-	char *fbuf;		/* Videodev buffer area */
-	char *tempfbuf;		/* Temporary (intermediate) buffer area */
-	char *rawfbuf;		/* Raw camera data buffer area */
+	unsigned char *fbuf;	/* Videodev buffer area */
+	unsigned char *tempfbuf; /* Temporary (intermediate) buffer area */
+	unsigned char *rawfbuf;	/* Raw camera data buffer area */
 
 	int sub_flag;		/* Pix Array subcapture on flag */
 	int subx;		/* Pix Array subcapture x offset */
@@ -513,9 +522,9 @@
 	int bclass;		/* Class of bridge (BCL_*) */
 	int sensor;		/* Type of image sensor chip (SEN_*) */
 	int sclass;		/* Type of image sensor chip (SCL_*) */
-	int tuner;		/* Type of TV tuner */
 
 	int packet_size;	/* Frame size per isoc desc */
+	int packet_numbering;	/* Is ISO frame numbering enabled? */
 
 	struct semaphore param_lock;	/* params lock for this camera */
 
@@ -542,12 +551,9 @@
 	int num_inputs;		/* Number of inputs */
 	int norm; 		/* NTSC / PAL / SECAM */
 	int has_decoder;	/* Device has a video decoder */
-	int has_tuner;		/* Device has a TV tuner */
-	int has_audio_proc;	/* Device has an audio processor */
-	int freq;		/* Current tuner frequency */
-	int tuner_type;		/* Specific tuner model */
+	int pal;		/* Device is designed for PAL resolution */
 
-	/* I2C interface to kernel */
+	/* I2C interface */
 	struct semaphore i2c_lock;	  /* Protect I2C controller regs */
 	unsigned char primary_i2c_slave;  /* I2C write id of sensor */
 
@@ -556,27 +562,28 @@
 	struct semaphore cbuf_lock;
 };
 
-struct cam_list {
-	int id;
-	char *description;
-};
-
-struct palette_list {
+/* Used to represent a list of values and their respective symbolic names */
+struct symbolic_list {
 	int num;
 	char *name;
 };
 
-struct mode_list_518 {
-	int width;
-	int height;
-	u8 reg28;
-	u8 reg29;
-	u8 reg2a;
-	u8 reg2c;
-	u8 reg2e;
-	u8 reg24;
-	u8 reg25;
-};
+#define NOT_DEFINED_STR "Unknown"
+
+/* Returns the name of the matching element in the symbolic_list array. The
+ * end of the list must be marked with an element that has a NULL name.
+ */
+static inline char * 
+symbolic(struct symbolic_list list[], int num)
+{
+	int i;
+
+	for (i = 0; list[i].name != NULL; i++)
+			if (list[i].num == num)
+				return (list[i].name);
+
+	return (NOT_DEFINED_STR);
+}
 
 /* Compression stuff */
 
diff -Nur linux-2.4.19.old/drivers/usb/pegasus.c linux-2.4.19/drivers/usb/pegasus.c
--- linux-2.4.19.old/drivers/usb/pegasus.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/pegasus.c	Mon Nov 25 12:26:55 2002
@@ -1,46 +1,31 @@
 /*
-**	Pegasus: USB 10/100Mbps/HomePNA (1Mbps) Controller
-**
-**	Copyright (c) 1999-2002 Petko Manolov (petkan@users.sourceforge.net)
-**	
-**
-**	ChangeLog:
-**		....	Most of the time spend reading sources & docs.
-**		v0.2.x	First official release for the Linux kernel.
-**		v0.3.0	Beutified and structured, some bugs fixed.
-**		v0.3.x	URBifying bulk requests and bugfixing. First relatively
-**			stable release. Still can touch device's registers only
-**			from top-halves.
-**		v0.4.0	Control messages remained unurbified are now URBs.
-**			Now we can touch the HW at any time.
-**		v0.4.9	Control urbs again use process context to wait. Argh...
-**			Some long standing bugs (enable_net_traffic) fixed.
-**			Also nasty trick about resubmiting control urb from
-**			interrupt context used. Please let me know how it
-**			behaves. Pegasus II support added since this version.
-**			TODO: suppressing HCD warnings spewage on disconnect.
-**		v0.4.13	Ethernet address is now set at probe(), not at open()
-**			time as this seems to break dhcpd. 
-**		v0.4.25	ethtool support added.
-*/
-
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ *  Copyright (c) 1999-2002 Petko Manolov (petkan@users.sourceforge.net)
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *	
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *	ChangeLog:
+ *		....	Most of the time spend reading sources & docs.
+ *		v0.2.x	First official release for the Linux kernel.
+ *		v0.3.0	Beutified and structured, some bugs fixed.
+ *		v0.3.x	URBifying bulk requests and bugfixing. First relatively
+ *			stable release. Still can touch device's registers only
+ *			from top-halves.
+ *		v0.4.0	Control messages remained unurbified are now URBs.
+ *			Now we can touch the HW at any time.
+ *		v0.4.9	Control urbs again use process context to wait. Argh...
+ *			Some long standing bugs (enable_net_traffic) fixed.
+ *			Also nasty trick about resubmiting control urb from
+ *			interrupt context used. Please let me know how it
+ *			behaves. Pegasus II support added since this version.
+ *			TODO: suppressing HCD warnings spewage on disconnect.
+ *		v0.4.13	Ethernet address is now set at probe(), not at open()
+ *			time as this seems to break dhcpd. 
+ *		v0.4.25	ethtool support added.
  */
 
-
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/init.h>
@@ -69,7 +54,6 @@
 static int loopback = 0;
 static int mii_mode = 1;
 static int multicast_filter_limit = 32;
-static DECLARE_MUTEX(gsem);
 
 static struct usb_eth_dev usb_dev_id[] = {
 #define	PEGASUS_DEV(pn, vid, pid, flags)	\
@@ -84,104 +68,102 @@
 	{match_flags: USB_DEVICE_ID_MATCH_DEVICE, idVendor:vid, idProduct:pid},
 #include "pegasus.h"
 #undef	PEGASUS_DEV
-	{ }
+	{}
 };
 
-
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 MODULE_PARM(loopback, "i");
 MODULE_PARM(mii_mode, "i");
 MODULE_PARM_DESC(loopback, "Enable MAC loopback mode (bit 0)");
 MODULE_PARM_DESC(mii_mode, "Enable HomePNA mode (bit 0),default=MII mode = 0");
 
-MODULE_DEVICE_TABLE (usb, pegasus_ids);
-
+MODULE_DEVICE_TABLE(usb, pegasus_ids);
 
-static int update_eth_regs_async( pegasus_t * );
+static int update_eth_regs_async(pegasus_t *);
 /* Aargh!!! I _really_ hate such tweaks */
-static void ctrl_callback( struct urb *urb )
+static void ctrl_callback(struct urb *urb)
 {
-	pegasus_t	*pegasus = urb->context;
+	pegasus_t *pegasus = urb->context;
 
-	if ( !pegasus )
+	if (!pegasus)
 		return;
 
-	switch ( urb->status ) {
-		case 0:
-			if ( pegasus->flags & ETH_REGS_CHANGE ) {
-				pegasus->flags &= ~ETH_REGS_CHANGE;
-				pegasus->flags |= ETH_REGS_CHANGED;
-				update_eth_regs_async( pegasus );
-				return;
-			}
-			break;
-		case -EINPROGRESS:
+	switch (urb->status) {
+	case 0:
+		if (pegasus->flags & ETH_REGS_CHANGE) {
+			pegasus->flags &= ~ETH_REGS_CHANGE;
+			pegasus->flags |= ETH_REGS_CHANGED;
+			update_eth_regs_async(pegasus);
 			return;
-		case -ENOENT:
-			break;
-		default:
-			warn("%s: status %d", __FUNCTION__, urb->status);
+		}
+		break;
+	case -EINPROGRESS:
+		return;
+	case -ENOENT:
+		break;
+	default:
+		warn("%s: status %d", __FUNCTION__, urb->status);
 	}
 	pegasus->flags &= ~ETH_REGS_CHANGED;
-	wake_up(&pegasus->ctrl_wait );
+	wake_up(&pegasus->ctrl_wait);
 }
 
-
-static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
+static int get_registers(pegasus_t * pegasus, __u16 indx, __u16 size,
+			 void *data)
 {
-	int	ret;
+	int ret;
 	unsigned char *buffer;
 	DECLARE_WAITQUEUE(wait, current);
 
-	buffer = kmalloc(size,GFP_KERNEL);
+	buffer = kmalloc(size, GFP_KERNEL);
 	if (!buffer) {
 		err("unable to allocate memory for configuration descriptors");
 		return 0;
 	}
-	memcpy(buffer,data,size);
+	memcpy(buffer, data, size);
 
 	add_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_UNINTERRUPTIBLE);
-	while ( pegasus->flags & ETH_REGS_CHANGED )
+	while (pegasus->flags & ETH_REGS_CHANGED)
 		schedule();
 	remove_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_RUNNING);
 
-	pegasus->dr.requesttype = PEGASUS_REQT_READ;
-	pegasus->dr.request = PEGASUS_REQ_GET_REGS;
-	pegasus->dr.value = cpu_to_le16 (0);
-	pegasus->dr.index = cpu_to_le16p(&indx);
-	pegasus->dr.length = cpu_to_le16p(&size);
+	pegasus->dr.bRequestType = PEGASUS_REQT_READ;
+	pegasus->dr.bRequest = PEGASUS_REQ_GET_REGS;
+	pegasus->dr.wValue = cpu_to_le16(0);
+	pegasus->dr.wIndex = cpu_to_le16p(&indx);
+	pegasus->dr.wLength = cpu_to_le16p(&size);
 	pegasus->ctrl_urb->transfer_buffer_length = size;
 
-	FILL_CONTROL_URB( pegasus->ctrl_urb, pegasus->usb,
-			  usb_rcvctrlpipe(pegasus->usb,0),
-			  (char *)&pegasus->dr,
-			  buffer, size, ctrl_callback, pegasus );
+	FILL_CONTROL_URB(pegasus->ctrl_urb, pegasus->usb,
+			 usb_rcvctrlpipe(pegasus->usb, 0),
+			 (char *) &pegasus->dr,
+			 buffer, size, ctrl_callback, pegasus);
 
-	add_wait_queue( &pegasus->ctrl_wait, &wait );
-	set_current_state( TASK_UNINTERRUPTIBLE );
+	add_wait_queue(&pegasus->ctrl_wait, &wait);
+	set_current_state(TASK_UNINTERRUPTIBLE);
 
-	if ( (ret = usb_submit_urb( pegasus->ctrl_urb )) ) {
+	if ((ret = usb_submit_urb(pegasus->ctrl_urb))) {
 		err("%s: BAD CTRLs %d", __FUNCTION__, ret);
 		goto out;
 	}
 
 	schedule();
 out:
-	remove_wait_queue( &pegasus->ctrl_wait, &wait );
-	memcpy(data,buffer,size);
+	remove_wait_queue(&pegasus->ctrl_wait, &wait);
+	memcpy(data, buffer, size);
 	kfree(buffer);
 
 	return ret;
 }
 
-
-static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
+static int set_registers(pegasus_t * pegasus, __u16 indx, __u16 size,
+			 void *data)
 {
-	int	ret;
+	int ret;
 	unsigned char *buffer;
 	DECLARE_WAITQUEUE(wait, current);
 
@@ -194,47 +176,46 @@
 
 	add_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_UNINTERRUPTIBLE);
-	while ( pegasus->flags & ETH_REGS_CHANGED )
+	while (pegasus->flags & ETH_REGS_CHANGED)
 		schedule();
 	remove_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_RUNNING);
 
-	pegasus->dr.requesttype = PEGASUS_REQT_WRITE;
-	pegasus->dr.request = PEGASUS_REQ_SET_REGS;
-	pegasus->dr.value = cpu_to_le16 (0);
-	pegasus->dr.index = cpu_to_le16p( &indx );
-	pegasus->dr.length = cpu_to_le16p( &size );
+	pegasus->dr.bRequestType = PEGASUS_REQT_WRITE;
+	pegasus->dr.bRequest = PEGASUS_REQ_SET_REGS;
+	pegasus->dr.wValue = cpu_to_le16(0);
+	pegasus->dr.wIndex = cpu_to_le16p(&indx);
+	pegasus->dr.wLength = cpu_to_le16p(&size);
 	pegasus->ctrl_urb->transfer_buffer_length = size;
 
-	FILL_CONTROL_URB( pegasus->ctrl_urb, pegasus->usb,
-			  usb_sndctrlpipe(pegasus->usb,0),
-			  (char *)&pegasus->dr,
-			  buffer, size, ctrl_callback, pegasus );
-			  
-	add_wait_queue( &pegasus->ctrl_wait, &wait );
-	set_current_state( TASK_UNINTERRUPTIBLE );
+	FILL_CONTROL_URB(pegasus->ctrl_urb, pegasus->usb,
+			 usb_sndctrlpipe(pegasus->usb, 0),
+			 (char *) &pegasus->dr,
+			 buffer, size, ctrl_callback, pegasus);
 
-	if ( (ret = usb_submit_urb( pegasus->ctrl_urb )) ) {
+	add_wait_queue(&pegasus->ctrl_wait, &wait);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+
+	if ((ret = usb_submit_urb(pegasus->ctrl_urb))) {
 		err("%s: BAD CTRL %d", __FUNCTION__, ret);
 		goto out;
 	}
-	
+
 	schedule();
 out:
-	remove_wait_queue( &pegasus->ctrl_wait, &wait );
+	remove_wait_queue(&pegasus->ctrl_wait, &wait);
 	kfree(buffer);
-	
+
 	return ret;
 }
 
-
-static int set_register( pegasus_t *pegasus, __u16 indx, __u8 data )
+static int set_register(pegasus_t * pegasus, __u16 indx, __u8 data)
 {
-	int	ret;
+	int ret;
 	unsigned char *buffer;
 	__u16 dat = data;
 	DECLARE_WAITQUEUE(wait, current);
-	
+
 	buffer = kmalloc(1, GFP_KERNEL);
 	if (!buffer) {
 		err("unable to allocate memory for configuration descriptors");
@@ -244,129 +225,126 @@
 
 	add_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_UNINTERRUPTIBLE);
-	while ( pegasus->flags & ETH_REGS_CHANGED )
+	while (pegasus->flags & ETH_REGS_CHANGED)
 		schedule();
 	remove_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_RUNNING);
 
-	pegasus->dr.requesttype = PEGASUS_REQT_WRITE;
-	pegasus->dr.request = PEGASUS_REQ_SET_REG;
-	pegasus->dr.value = cpu_to_le16p( &dat);
-	pegasus->dr.index = cpu_to_le16p( &indx );
-	pegasus->dr.length = cpu_to_le16( 1 );
+	pegasus->dr.bRequestType = PEGASUS_REQT_WRITE;
+	pegasus->dr.bRequest = PEGASUS_REQ_SET_REG;
+	pegasus->dr.wValue = cpu_to_le16p(&dat);
+	pegasus->dr.wIndex = cpu_to_le16p(&indx);
+	pegasus->dr.wLength = cpu_to_le16(1);
 	pegasus->ctrl_urb->transfer_buffer_length = 1;
 
-	FILL_CONTROL_URB( pegasus->ctrl_urb, pegasus->usb,
-			  usb_sndctrlpipe(pegasus->usb,0),
-			  (char *)&pegasus->dr,
-			  buffer, 1, ctrl_callback, pegasus );
+	FILL_CONTROL_URB(pegasus->ctrl_urb, pegasus->usb,
+			 usb_sndctrlpipe(pegasus->usb, 0),
+			 (char *) &pegasus->dr,
+			 buffer, 1, ctrl_callback, pegasus);
 
-	add_wait_queue( &pegasus->ctrl_wait, &wait );
-	set_current_state( TASK_UNINTERRUPTIBLE );
+	add_wait_queue(&pegasus->ctrl_wait, &wait);
+	set_current_state(TASK_UNINTERRUPTIBLE);
 
-	if ( (ret = usb_submit_urb( pegasus->ctrl_urb )) ) {
+	if ((ret = usb_submit_urb(pegasus->ctrl_urb))) {
 		err("%s: BAD CTRL %d", __FUNCTION__, ret);
 		goto out;
 	}
 
 	schedule();
 out:
-	remove_wait_queue( &pegasus->ctrl_wait, &wait );
+	remove_wait_queue(&pegasus->ctrl_wait, &wait);
 	kfree(buffer);
 
 	return ret;
 }
 
-
-static int update_eth_regs_async( pegasus_t *pegasus )
+static int update_eth_regs_async(pegasus_t * pegasus)
 {
-	int	ret;
+	int ret;
 
-	pegasus->dr.requesttype = PEGASUS_REQT_WRITE;
-	pegasus->dr.request = PEGASUS_REQ_SET_REGS;
-	pegasus->dr.value = 0;
-	pegasus->dr.index =  cpu_to_le16(EthCtrl0);
-	pegasus->dr.length = cpu_to_le16(3);
+	pegasus->dr.bRequestType = PEGASUS_REQT_WRITE;
+	pegasus->dr.bRequest = PEGASUS_REQ_SET_REGS;
+	pegasus->dr.wValue = 0;
+	pegasus->dr.wIndex = cpu_to_le16(EthCtrl0);
+	pegasus->dr.wLength = cpu_to_le16(3);
 	pegasus->ctrl_urb->transfer_buffer_length = 3;
 
-	FILL_CONTROL_URB( pegasus->ctrl_urb, pegasus->usb,
-			  usb_sndctrlpipe(pegasus->usb,0),
-			  (char *)&pegasus->dr,
-			  pegasus->eth_regs, 3, ctrl_callback, pegasus );
+	FILL_CONTROL_URB(pegasus->ctrl_urb, pegasus->usb,
+			 usb_sndctrlpipe(pegasus->usb, 0),
+			 (char *) &pegasus->dr,
+			 pegasus->eth_regs, 3, ctrl_callback, pegasus);
+
+	if ((ret = usb_submit_urb(pegasus->ctrl_urb)))
+		err("%s: BAD CTRL %d, flgs %x", __FUNCTION__, ret,
+		    pegasus->flags);
 
-	if ( (ret = usb_submit_urb( pegasus->ctrl_urb )) )
-		err("%s: BAD CTRL %d, flgs %x",__FUNCTION__,ret,pegasus->flags);
-
-	return	ret;
+	return ret;
 }
 
-
-static int read_mii_word( pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd )
+static int read_mii_word(pegasus_t * pegasus, __u8 phy, __u8 indx, __u16 * regd)
 {
-	int	i;
-	__u8	data[4] = { phy, 0, 0, indx };
-	__u16  regdi;
-	
-	set_register( pegasus, PhyCtrl, 0 );
-	set_registers( pegasus, PhyAddr, sizeof(data), data );
-	set_register( pegasus, PhyCtrl, (indx | PHY_READ) );
+	int i;
+	__u8 data[4] = { phy, 0, 0, indx };
+	__u16 regdi;
+
+	set_register(pegasus, PhyCtrl, 0);
+	set_registers(pegasus, PhyAddr, sizeof(data), data);
+	set_register(pegasus, PhyCtrl, (indx | PHY_READ));
 	for (i = 0; i < REG_TIMEOUT; i++) {
 		get_registers(pegasus, PhyCtrl, 1, data);
-		if ( data[0] & PHY_DONE ) 
+		if (data[0] & PHY_DONE)
 			break;
 	}
-	if ( i < REG_TIMEOUT ) {
-		get_registers( pegasus, PhyData, 2, &regdi );
+	if (i < REG_TIMEOUT) {
+		get_registers(pegasus, PhyData, 2, &regdi);
 		*regd = le16_to_cpu(regdi);
-		return	0;
+		return 0;
 	}
 	warn("%s: failed", __FUNCTION__);
-	
+
 	return 1;
 }
 
-
-static int write_mii_word( pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 regd )
+static int write_mii_word(pegasus_t * pegasus, __u8 phy, __u8 indx, __u16 regd)
 {
-	int	i;
-	__u8	data[4] = { phy, 0, 0, indx };
-	
-	*(data + 1) = cpu_to_le16p( &regd );
-	set_register( pegasus, PhyCtrl, 0 );
-	set_registers( pegasus, PhyAddr, 4, data );
-	set_register( pegasus, PhyCtrl, (indx | PHY_WRITE) );
+	int i;
+	__u8 data[4] = { phy, 0, 0, indx };
+
+	*(data + 1) = cpu_to_le16p(&regd);
+	set_register(pegasus, PhyCtrl, 0);
+	set_registers(pegasus, PhyAddr, 4, data);
+	set_register(pegasus, PhyCtrl, (indx | PHY_WRITE));
 	for (i = 0; i < REG_TIMEOUT; i++) {
 		get_registers(pegasus, PhyCtrl, 1, data);
-		if ( data[0] & PHY_DONE ) 
+		if (data[0] & PHY_DONE)
 			break;
 	}
-	if ( i < REG_TIMEOUT )
-		return	0;
+	if (i < REG_TIMEOUT)
+		return 0;
 	warn("%s: failed", __FUNCTION__);
 
 	return 1;
 }
 
-
-static int read_eprom_word( pegasus_t *pegasus, __u8 index, __u16 *retdata )
+static int read_eprom_word(pegasus_t * pegasus, __u8 index, __u16 * retdata)
 {
-	int	i;
+	int i;
 	__u8 tmp;
 	__u16 retdatai;
-	
-	set_register( pegasus, EpromCtrl, 0 );
-	set_register( pegasus, EpromOffset, index );
-	set_register( pegasus, EpromCtrl, EPROM_READ); 
-
-	for ( i=0; i < REG_TIMEOUT; i++ ) {
-		get_registers( pegasus, EpromCtrl, 1, &tmp );
-		if ( tmp & EPROM_DONE )
+
+	set_register(pegasus, EpromCtrl, 0);
+	set_register(pegasus, EpromOffset, index);
+	set_register(pegasus, EpromCtrl, EPROM_READ);
+
+	for (i = 0; i < REG_TIMEOUT; i++) {
+		get_registers(pegasus, EpromCtrl, 1, &tmp);
+		if (tmp & EPROM_DONE)
 			break;
 	}
-	if ( i < REG_TIMEOUT ) {
-		get_registers( pegasus, EpromData, 2, &retdatai );
-		*retdata = le16_to_cpu (retdatai);
-		return	0;
+	if (i < REG_TIMEOUT) {
+		get_registers(pegasus, EpromData, 2, &retdatai);
+		*retdata = le16_to_cpu(retdatai);
+		return 0;
 	}
 	warn("%s: failed", __FUNCTION__);
 
@@ -374,199 +352,188 @@
 }
 
 #ifdef	PEGASUS_WRITE_EEPROM
-static inline void enable_eprom_write( pegasus_t *pegasus )
+static inline void enable_eprom_write(pegasus_t * pegasus)
 {
-	__u8	tmp;
+	__u8 tmp;
 
-	get_registers( pegasus, EthCtrl2, 1, &tmp );
-	set_register( pegasus, EthCtrl2, tmp | EPROM_WR_ENABLE );
+	get_registers(pegasus, EthCtrl2, 1, &tmp);
+	set_register(pegasus, EthCtrl2, tmp | EPROM_WR_ENABLE);
 }
 
-
-static inline void disable_eprom_write( pegasus_t *pegasus )
+static inline void disable_eprom_write(pegasus_t * pegasus)
 {
-	__u8 	tmp;
+	__u8 tmp;
 
-	get_registers( pegasus, EthCtrl2, 1, &tmp );
-	set_register( pegasus, EpromCtrl, 0 );
-	set_register( pegasus, EthCtrl2, tmp & ~EPROM_WR_ENABLE );
+	get_registers(pegasus, EthCtrl2, 1, &tmp);
+	set_register(pegasus, EpromCtrl, 0);
+	set_register(pegasus, EthCtrl2, tmp & ~EPROM_WR_ENABLE);
 }
 
-
-static int write_eprom_word( pegasus_t *pegasus, __u8 index, __u16 data )
+static int write_eprom_word(pegasus_t * pegasus, __u8 index, __u16 data)
 {
-	int	i, tmp;
-	__u8	d[4] = {0x3f, 0, 0, EPROM_WRITE};
+	int i, tmp;
+	__u8 d[4] = { 0x3f, 0, 0, EPROM_WRITE };
 
-	set_registers( pegasus, EpromOffset, 4, d );
-	enable_eprom_write( pegasus );
-	set_register( pegasus, EpromOffset, index );
-	set_registers( pegasus, EpromData, 2, &data );
-	set_register( pegasus, EpromCtrl, EPROM_WRITE );
+	set_registers(pegasus, EpromOffset, 4, d);
+	enable_eprom_write(pegasus);
+	set_register(pegasus, EpromOffset, index);
+	set_registers(pegasus, EpromData, 2, &data);
+	set_register(pegasus, EpromCtrl, EPROM_WRITE);
 
-	for ( i=0; i < REG_TIMEOUT; i++ ) {
-		get_registers( pegasus, EpromCtrl, 1, &tmp );
-		if ( tmp & EPROM_DONE )
+	for (i = 0; i < REG_TIMEOUT; i++) {
+		get_registers(pegasus, EpromCtrl, 1, &tmp);
+		if (tmp & EPROM_DONE)
 			break;
 	}
-	disable_eprom_write( pegasus );
-	if ( i < REG_TIMEOUT )
-		return	0;
+	disable_eprom_write(pegasus);
+	if (i < REG_TIMEOUT)
+		return 0;
 	warn("%s: failed", __FUNCTION__);
-	return	-1;
+	return -1;
 }
-#endif	/* PEGASUS_WRITE_EEPROM */
+#endif				/* PEGASUS_WRITE_EEPROM */
 
-static inline void get_node_id( pegasus_t *pegasus, __u8 *id )
+static inline void get_node_id(pegasus_t * pegasus, __u8 * id)
 {
-	int	i;
+	int i;
 	__u16 w16;
-	
+
 	for (i = 0; i < 3; i++) {
-		read_eprom_word( pegasus, i, &w16);
-		((__u16 *) id)[i] = cpu_to_le16p (&w16);
+		read_eprom_word(pegasus, i, &w16);
+		((__u16 *) id)[i] = cpu_to_le16p(&w16);
 	}
 }
 
-
-static void set_ethernet_addr( pegasus_t *pegasus )
+static void set_ethernet_addr(pegasus_t * pegasus)
 {
-	__u8	node_id[6];
+	__u8 node_id[6];
 
 	get_node_id(pegasus, node_id);
-	set_registers( pegasus, EthID, sizeof(node_id), node_id );
-	memcpy( pegasus->net->dev_addr, node_id, sizeof(node_id) );
+	set_registers(pegasus, EthID, sizeof(node_id), node_id);
+	memcpy(pegasus->net->dev_addr, node_id, sizeof(node_id));
 }
 
-
-static inline int reset_mac( pegasus_t *pegasus )
+static inline int reset_mac(pegasus_t * pegasus)
 {
-	__u8	data = 0x8;
-	int	i;
+	__u8 data = 0x8;
+	int i;
 
 	set_register(pegasus, EthCtrl1, data);
 	for (i = 0; i < REG_TIMEOUT; i++) {
 		get_registers(pegasus, EthCtrl1, 1, &data);
 		if (~data & 0x08) {
-			if (loopback & 1) 
+			if (loopback & 1)
 				break;
-			if ( mii_mode && (pegasus->features & HAS_HOME_PNA) )
-				set_register( pegasus, Gpio1, 0x34 );
+			if (mii_mode && (pegasus->features & HAS_HOME_PNA))
+				set_register(pegasus, Gpio1, 0x34);
 			else
-				set_register( pegasus, Gpio1, 0x26 );
-			set_register( pegasus, Gpio0, pegasus->features );
-			set_register( pegasus, Gpio0, DEFAULT_GPIO_SET );
+				set_register(pegasus, Gpio1, 0x26);
+			set_register(pegasus, Gpio0, pegasus->features);
+			set_register(pegasus, Gpio0, DEFAULT_GPIO_SET);
 			break;
 		}
 	}
-	if ( i == REG_TIMEOUT )
+	if (i == REG_TIMEOUT)
 		return 1;
 
 	if (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||
 	    usb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {
-		__u16	auxmode;
+		__u16 auxmode;
 
 		read_mii_word(pegasus, 1, 0x1b, &auxmode);
 		write_mii_word(pegasus, 1, 0x1b, auxmode | 4);
 	}
 	if (usb_dev_id[pegasus->dev_index].vendor == VENDOR_ELCON) {
-		__u16	auxmode;
+		__u16 auxmode;
 		read_mii_word(pegasus, 3, 0x1b, &auxmode);
 		write_mii_word(pegasus, 3, 0x1b, auxmode | 4);
 	}
-	return	0;
+	return 0;
 }
 
-
-static int enable_net_traffic( struct net_device *dev, struct usb_device *usb )
+static int enable_net_traffic(struct net_device *dev, struct usb_device *usb)
 {
-	__u16	linkpart, bmsr;
-	__u8	data[4];
+	__u16 linkpart, bmsr;
+	__u8 data[4];
 	pegasus_t *pegasus = dev->priv;
 
 	/* read twice 'cos this is a latch bit */
 	read_mii_word(pegasus, pegasus->phy, MII_BMSR, &bmsr);
 	read_mii_word(pegasus, pegasus->phy, MII_BMSR, &bmsr);
-	if ( !(bmsr & 4) && !loopback ) 
-		warn( "%s: link NOT established (0x%x) - check the cable.",
-			dev->name, bmsr );
-	if ( read_mii_word(pegasus, pegasus->phy, MII_LPA, &linkpart) )
+	if (read_mii_word(pegasus, pegasus->phy, MII_LPA, &linkpart))
 		return 2;
-	if ( !(linkpart & 1) )
-		warn( "link partner stat %x", linkpart );
+	if (!(linkpart & 1))
+		warn("link partner stat %x", linkpart);
 
 	data[0] = 0xc9;
 	data[1] = 0;
-	if ( linkpart & (ADVERTISE_100FULL | ADVERTISE_10FULL) )
-		data[1] |= 0x20; /* set full duplex */
-	if ( linkpart & (ADVERTISE_100FULL | ADVERTISE_100HALF) )
-		data[1] |= 0x10; /* set 100 Mbps */
-	if ( mii_mode )
+	if (linkpart & (ADVERTISE_100FULL | ADVERTISE_10FULL))
+		data[1] |= 0x20;	/* set full duplex */
+	if (linkpart & (ADVERTISE_100FULL | ADVERTISE_100HALF))
+		data[1] |= 0x10;	/* set 100 Mbps */
+	if (mii_mode)
 		data[1] = 0;
 	data[2] = (loopback & 1) ? 0x09 : 0x01;
-
-	memcpy( pegasus->eth_regs, data, sizeof(data) );
-
-	set_registers( pegasus, EthCtrl0, 3, data );
+	memcpy(pegasus->eth_regs, data, sizeof(data));
+	set_registers(pegasus, EthCtrl0, 3, data);
 
 	return 0;
 }
 
-
-static void read_bulk_callback( struct urb *urb )
+static void read_bulk_callback(struct urb *urb)
 {
 	pegasus_t *pegasus = urb->context;
 	struct net_device *net;
 	int count = urb->actual_length, res;
 	int rx_status;
-	struct sk_buff	*skb;
+	struct sk_buff *skb;
 	__u16 pkt_len;
 
-	if ( !pegasus || !(pegasus->flags & PEGASUS_RUNNING) )
+	if (!pegasus || !(pegasus->flags & PEGASUS_RUNNING))
 		return;
 
 	net = pegasus->net;
-	if ( !netif_device_present(net) )
+	if (!netif_device_present(net))
 		return;
 
-	if ( pegasus->flags & PEGASUS_RX_BUSY ) {
+	if (pegasus->flags & PEGASUS_RX_BUSY) {
 		pegasus->stats.rx_errors++;
 		dbg("pegasus Rx busy");
 		return;
 	}
 	pegasus->flags |= PEGASUS_RX_BUSY;
 
-	switch ( urb->status ) {
-		case 0:
-			break;
-		case -ETIMEDOUT:
-			dbg( "reset MAC" );
-			pegasus->flags &= ~PEGASUS_RX_BUSY;
-			break;
-		default:
-			dbg( "%s: RX status %d", net->name, urb->status );
-			goto goon;
+	switch (urb->status) {
+	case 0:
+		break;
+	case -ETIMEDOUT:
+		dbg("reset MAC");
+		pegasus->flags &= ~PEGASUS_RX_BUSY;
+		break;
+	default:
+		dbg("%s: RX status %d", net->name, urb->status);
+		goto goon;
 	}
 
-	if ( !count )
+	if (!count)
 		goto goon;
 
-	rx_status = le32_to_cpu(*(int *)(pegasus->rx_buff + count - 4));
-	if ( rx_status & 0x000e0000 ) {
+	rx_status = le32_to_cpu(*(int *) (pegasus->rx_buff + count - 4));
+	if (rx_status & 0x000e0000) {
 		dbg("%s: RX packet error %x", net->name, rx_status & 0xe0000);
 		pegasus->stats.rx_errors++;
-		if ( rx_status & 0x060000 )
+		if (rx_status & 0x060000)
 			pegasus->stats.rx_length_errors++;
-		if ( rx_status & 0x080000 )
+		if (rx_status & 0x080000)
 			pegasus->stats.rx_crc_errors++;
-		if ( rx_status & 0x100000 )
+		if (rx_status & 0x100000)
 			pegasus->stats.rx_frame_errors++;
 		goto goon;
 	}
 
 	pkt_len = (rx_status & 0xfff) - 8;
 
-	if ( !(skb = dev_alloc_skb(pkt_len+2)) )
+	if (!(skb = dev_alloc_skb(pkt_len + 2)))
 		goto goon;
 
 	skb->dev = net;
@@ -580,102 +547,100 @@
 	pegasus->stats.rx_bytes += pkt_len;
 
 goon:
-	FILL_BULK_URB( pegasus->rx_urb, pegasus->usb,
-			usb_rcvbulkpipe(pegasus->usb, 1),
-			pegasus->rx_buff, PEGASUS_MAX_MTU, 
-			read_bulk_callback, pegasus );
-	if ( (res = usb_submit_urb(pegasus->rx_urb)) )
+	FILL_BULK_URB(pegasus->rx_urb, pegasus->usb,
+		      usb_rcvbulkpipe(pegasus->usb, 1),
+		      pegasus->rx_buff, PEGASUS_MAX_MTU,
+		      read_bulk_callback, pegasus);
+	if ((res = usb_submit_urb(pegasus->rx_urb)))
 		warn("%s: failed submint rx_urb %d", __FUNCTION__, res);
 	pegasus->flags &= ~PEGASUS_RX_BUSY;
 }
 
-
-static void write_bulk_callback( struct urb *urb )
+static void write_bulk_callback(struct urb *urb)
 {
 	pegasus_t *pegasus = urb->context;
 
-	if ( !pegasus || !(pegasus->flags & PEGASUS_RUNNING) )
+	if (!pegasus || !(pegasus->flags & PEGASUS_RUNNING))
 		return;
 
-	if ( !netif_device_present(pegasus->net) )
+	if (!netif_device_present(pegasus->net))
 		return;
-		
-	if ( urb->status )
+
+	if (urb->status)
 		info("%s: TX status %d", pegasus->net->name, urb->status);
 
 	pegasus->net->trans_start = jiffies;
-	netif_wake_queue( pegasus->net );
+	netif_wake_queue(pegasus->net);
 }
 
 #ifdef	PEGASUS_USE_INTR
-static void intr_callback( struct urb *urb )
+static void intr_callback(struct urb *urb)
 {
 	pegasus_t *pegasus = urb->context;
 	struct net_device *net;
-	__u8	*d;
+	__u8 *d;
 
-	if ( !pegasus )
+	if (!pegasus)
 		return;
-		
-	switch ( urb->status ) {
-		case 0:
-			break;
-		case -ENOENT:
-			return;
-		default:
-			info("intr status %d", urb->status);
+
+	switch (urb->status) {
+	case 0:
+		break;
+	case -ENOENT:
+		return;
+	default:
+		info("intr status %d", urb->status);
 	}
 
 	d = urb->transfer_buffer;
 	net = pegasus->net;
-	if ( d[0] & 0xfc ) {
+	if (d[0] & 0xfc) {
 		pegasus->stats.tx_errors++;
-		if ( d[0] & TX_UNDERRUN )
+		if (d[0] & TX_UNDERRUN)
 			pegasus->stats.tx_fifo_errors++;
-		if ( d[0] & (EXCESSIVE_COL | JABBER_TIMEOUT) )
+		if (d[0] & (EXCESSIVE_COL | JABBER_TIMEOUT))
 			pegasus->stats.tx_aborted_errors++;
-		if ( d[0] & LATE_COL )
+		if (d[0] & LATE_COL)
 			pegasus->stats.tx_window_errors++;
-		if ( d[0] & (NO_CARRIER | LOSS_CARRIER) )
+		if (d[0] & (NO_CARRIER | LOSS_CARRIER))
 			pegasus->stats.tx_carrier_errors++;
 	}
 }
 #endif
 
-static void pegasus_tx_timeout( struct net_device *net )
+static void pegasus_tx_timeout(struct net_device *net)
 {
 	pegasus_t *pegasus = net->priv;
 
-	if ( !pegasus )
+	if (!pegasus)
 		return;
-		
+
 	warn("%s: Tx timed out.", net->name);
 	pegasus->tx_urb->transfer_flags |= USB_ASYNC_UNLINK;
-	usb_unlink_urb( pegasus->tx_urb );
+	usb_unlink_urb(pegasus->tx_urb);
 	pegasus->stats.tx_errors++;
 }
 
-
-static int pegasus_start_xmit( struct sk_buff *skb, struct net_device *net )
+static int pegasus_start_xmit(struct sk_buff *skb, struct net_device *net)
 {
-	pegasus_t	*pegasus = net->priv;
-	int 	count = ((skb->len+2) & 0x3f) ? skb->len+2 : skb->len+3;
-	int 	res;
+	pegasus_t *pegasus = net->priv;
+	int count = ((skb->len + 2) & 0x3f) ? skb->len + 2 : skb->len + 3;
+	int res;
 	__u16 l16 = skb->len;
-	
-	netif_stop_queue( net );
-		
-	((__u16 *)pegasus->tx_buff)[0] = cpu_to_le16( l16 );
-	memcpy(pegasus->tx_buff+2, skb->data, skb->len);
-	FILL_BULK_URB( pegasus->tx_urb, pegasus->usb,
-			usb_sndbulkpipe(pegasus->usb, 2),
-			pegasus->tx_buff, PEGASUS_MAX_MTU, 
-			write_bulk_callback, pegasus );
+
+	netif_stop_queue(net);
+
+	((__u16 *) pegasus->tx_buff)[0] = cpu_to_le16(l16);
+	memcpy(pegasus->tx_buff + 2, skb->data, skb->len);
+	FILL_BULK_URB(pegasus->tx_urb, pegasus->usb,
+		      usb_sndbulkpipe(pegasus->usb, 2),
+		      pegasus->tx_buff, PEGASUS_MAX_MTU,
+		      write_bulk_callback, pegasus);
 	pegasus->tx_urb->transfer_buffer_length = count;
 	if ((res = usb_submit_urb(pegasus->tx_urb))) {
 		warn("failed tx_urb %d", res);
 		pegasus->stats.tx_errors++;
-		netif_start_queue( net );
+		netif_start_queue(net);
 	} else {
 		pegasus->stats.tx_packets++;
 		pegasus->stats.tx_bytes += skb->len;
@@ -687,42 +652,38 @@
 	return 0;
 }
 
-
-static struct net_device_stats *pegasus_netdev_stats( struct net_device *dev )
+static struct net_device_stats *pegasus_netdev_stats(struct net_device *dev)
 {
-	return &((pegasus_t *)dev->priv)->stats;
+	return &((pegasus_t *) dev->priv)->stats;
 }
 
-
-static inline void disable_net_traffic( pegasus_t *pegasus )
+static inline void disable_net_traffic(pegasus_t * pegasus)
 {
-	int 	tmp=0;
+	int tmp = 0;
 
-	set_registers( pegasus, EthCtrl0, 2, &tmp );
+	set_registers(pegasus, EthCtrl0, 2, &tmp);
 }
 
-
-static inline void get_interrupt_interval( pegasus_t *pegasus )
+static inline void get_interrupt_interval(pegasus_t * pegasus)
 {
-	__u8	data[2];
+	__u8 data[2];
 
-	read_eprom_word( pegasus, 4, (__u16 *)data );
-	if ( data[1] < 0x80 ) {
-		info( "intr interval will be changed from %ums to %ums",
-		     data[1], 0x80 );
+	read_eprom_word(pegasus, 4, (__u16 *) data);
+	if (data[1] < 0x80) {
+		info("intr interval will be changed from %ums to %ums",
+		     data[1], 0x80);
 		data[1] = 0x80;
 #ifdef	PEGASUS_WRITE_EEPROM
-		write_eprom_word( pegasus, 4, *(__u16 *)data );
+		write_eprom_word(pegasus, 4, *(__u16 *) data);
 #endif
 	}
 	pegasus->intr_interval = data[1];
 }
 
-
 static void set_carrier(struct net_device *net)
 {
-	pegasus_t	*pegasus;
-	short		tmp;
+	pegasus_t *pegasus;
+	short tmp;
 
 	pegasus = net->priv;
 	read_mii_word(pegasus, pegasus->phy, MII_BMSR, &tmp);
@@ -730,34 +691,32 @@
 		netif_carrier_on(net);
 	else
 		netif_carrier_off(net);
-	
-}
 
+}
 
 static int pegasus_open(struct net_device *net)
 {
-	pegasus_t *pegasus = (pegasus_t *)net->priv;
-	int	res;
-
+	pegasus_t *pegasus = (pegasus_t *) net->priv;
+	int res;
 
 	down(&pegasus->sem);
-	FILL_BULK_URB( pegasus->rx_urb, pegasus->usb,
-			usb_rcvbulkpipe(pegasus->usb, 1),
-			pegasus->rx_buff, PEGASUS_MAX_MTU, 
-			read_bulk_callback, pegasus );
-	if ( (res = usb_submit_urb(pegasus->rx_urb)) )
+	FILL_BULK_URB(pegasus->rx_urb, pegasus->usb,
+		      usb_rcvbulkpipe(pegasus->usb, 1),
+		      pegasus->rx_buff, PEGASUS_MAX_MTU,
+		      read_bulk_callback, pegasus);
+	if ((res = usb_submit_urb(pegasus->rx_urb)))
 		warn("%s: failed rx_urb %d", __FUNCTION__, res);
 #ifdef	PEGASUS_USE_INTR
-	FILL_INT_URB( pegasus->intr_urb, pegasus->usb,
-			usb_rcvintpipe(pegasus->usb, 3),
-			pegasus->intr_buff, sizeof(pegasus->intr_buff),
-			intr_callback, pegasus, pegasus->intr_interval );
-	if ( (res = usb_submit_urb(pegasus->intr_urb)) )
+	FILL_INT_URB(pegasus->intr_urb, pegasus->usb,
+		     usb_rcvintpipe(pegasus->usb, 3),
+		     pegasus->intr_buff, sizeof(pegasus->intr_buff),
+		     intr_callback, pegasus, pegasus->intr_interval);
+	if ((res = usb_submit_urb(pegasus->intr_urb)))
 		warn("%s: failed intr_urb %d", __FUNCTION__, res);
 #endif
-	netif_start_queue( net );
+	netif_start_queue(net);
 	pegasus->flags |= PEGASUS_RUNNING;
-	if ( (res = enable_net_traffic(net, pegasus->usb)) ) {
+	if ((res = enable_net_traffic(net, pegasus->usb))) {
 		err("can't enable_net_traffic() - %d", res);
 		res = -EIO;
 		goto exit;
@@ -767,129 +726,126 @@
 	res = 0;
 exit:
 	up(&pegasus->sem);
-	
+
 	return res;
 }
 
-
-static int pegasus_close( struct net_device *net )
+static int pegasus_close(struct net_device *net)
 {
-	pegasus_t	*pegasus = net->priv;
+	pegasus_t *pegasus = net->priv;
 
 	down(&pegasus->sem);
 	pegasus->flags &= ~PEGASUS_RUNNING;
-	netif_stop_queue( net );
-	if ( !(pegasus->flags & PEGASUS_UNPLUG) )
-		disable_net_traffic( pegasus );
-
-	usb_unlink_urb( pegasus->rx_urb );
-	usb_unlink_urb( pegasus->tx_urb );
-	usb_unlink_urb( pegasus->ctrl_urb );
+	netif_stop_queue(net);
+	if (!(pegasus->flags & PEGASUS_UNPLUG))
+		disable_net_traffic(pegasus);
+
+	usb_unlink_urb(pegasus->rx_urb);
+	usb_unlink_urb(pegasus->tx_urb);
+	usb_unlink_urb(pegasus->ctrl_urb);
 #ifdef	PEGASUS_USE_INTR
-	usb_unlink_urb( pegasus->intr_urb );
+	usb_unlink_urb(pegasus->intr_urb);
 #endif
 	up(&pegasus->sem);
-	
+
 	return 0;
 }
 
-
 static int pegasus_ethtool_ioctl(struct net_device *net, void *uaddr)
 {
-	pegasus_t	*pegasus;
-	int		cmd;
-	char		tmp[128];
+	pegasus_t *pegasus;
+	int cmd;
+	char tmp[128];
 
 	pegasus = net->priv;
-	if (get_user(cmd, (int *)uaddr))
+	if (get_user(cmd, (int *) uaddr))
 		return -EFAULT;
 	switch (cmd) {
-	case ETHTOOL_GDRVINFO: {
-		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
-		strncpy(info.driver, DRIVER_DESC, ETHTOOL_BUSINFO_LEN);
-		strncpy(info.version, DRIVER_VERSION, ETHTOOL_BUSINFO_LEN);
-		sprintf(tmp, "usb%d:%d", pegasus->usb->bus->busnum,
-		        pegasus->usb->devnum);
-		strncpy(info.bus_info, tmp, ETHTOOL_BUSINFO_LEN);
-		if (copy_to_user(uaddr, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	case ETHTOOL_GSET: {
-		struct ethtool_cmd ecmd;
-		short	lpa, bmcr;
-
-		if (copy_from_user(&ecmd, uaddr, sizeof(ecmd)))
-			return -EFAULT;
-		ecmd.supported = (SUPPORTED_10baseT_Half |
-		                 SUPPORTED_10baseT_Full |
-		                 SUPPORTED_100baseT_Half |
-		                 SUPPORTED_100baseT_Full |
-		                 SUPPORTED_Autoneg |
-		                 SUPPORTED_TP |
-		                 SUPPORTED_MII);
-		ecmd.port = PORT_TP;
-		ecmd.transceiver = XCVR_INTERNAL;
-		ecmd.phy_address = pegasus->phy;
-		read_mii_word(pegasus, pegasus->phy, MII_BMCR, &bmcr);
-		read_mii_word(pegasus, pegasus->phy, MII_LPA, &lpa);
-		if (bmcr & BMCR_ANENABLE) {
-			ecmd.autoneg = AUTONEG_ENABLE;
-			ecmd.speed = lpa & (LPA_100HALF|LPA_100FULL) ?
-		                     SPEED_100 : SPEED_10;
-			if (ecmd.speed == SPEED_100)
-				ecmd.duplex = lpa & LPA_100FULL ?
-				              DUPLEX_FULL : DUPLEX_HALF;
-			else
-				ecmd.duplex = lpa & LPA_10FULL ?
-				              DUPLEX_FULL : DUPLEX_HALF;
-		} else {
-			ecmd.autoneg = AUTONEG_DISABLE;
-			ecmd.speed = bmcr & BMCR_SPEED100 ? 
-			             SPEED_100 : SPEED_10;
-			ecmd.duplex = bmcr & BMCR_FULLDPLX ?
-			              DUPLEX_FULL : DUPLEX_HALF;
+	case ETHTOOL_GDRVINFO:{
+			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+			strncpy(info.driver, DRIVER_DESC, ETHTOOL_BUSINFO_LEN);
+			strncpy(info.version, DRIVER_VERSION,
+				ETHTOOL_BUSINFO_LEN);
+			sprintf(tmp, "usb%d:%d", pegasus->usb->bus->busnum,
+				pegasus->usb->devnum);
+			strncpy(info.bus_info, tmp, ETHTOOL_BUSINFO_LEN);
+			if (copy_to_user(uaddr, &info, sizeof(info)))
+				return -EFAULT;
+			return 0;
+		}
+	case ETHTOOL_GSET:{
+			struct ethtool_cmd ecmd;
+			short lpa, bmcr;
+
+			if (copy_from_user(&ecmd, uaddr, sizeof(ecmd)))
+				return -EFAULT;
+			ecmd.supported = (SUPPORTED_10baseT_Half |
+					  SUPPORTED_10baseT_Full |
+					  SUPPORTED_100baseT_Half |
+					  SUPPORTED_100baseT_Full |
+					  SUPPORTED_Autoneg |
+					  SUPPORTED_TP | SUPPORTED_MII);
+			ecmd.port = PORT_TP;
+			ecmd.transceiver = XCVR_INTERNAL;
+			ecmd.phy_address = pegasus->phy;
+			read_mii_word(pegasus, pegasus->phy, MII_BMCR, &bmcr);
+			read_mii_word(pegasus, pegasus->phy, MII_LPA, &lpa);
+			if (bmcr & BMCR_ANENABLE) {
+				ecmd.autoneg = AUTONEG_ENABLE;
+				ecmd.speed = lpa & (LPA_100HALF | LPA_100FULL) ?
+				    SPEED_100 : SPEED_10;
+				if (ecmd.speed == SPEED_100)
+					ecmd.duplex = lpa & LPA_100FULL ?
+					    DUPLEX_FULL : DUPLEX_HALF;
+				else
+					ecmd.duplex = lpa & LPA_10FULL ?
+					    DUPLEX_FULL : DUPLEX_HALF;
+			} else {
+				ecmd.autoneg = AUTONEG_DISABLE;
+				ecmd.speed = bmcr & BMCR_SPEED100 ?
+				    SPEED_100 : SPEED_10;
+				ecmd.duplex = bmcr & BMCR_FULLDPLX ?
+				    DUPLEX_FULL : DUPLEX_HALF;
+			}
+			if (copy_to_user(uaddr, &ecmd, sizeof(ecmd)))
+				return -EFAULT;
+
+			return 0;
+		}
+	case ETHTOOL_SSET:{
+			return -EOPNOTSUPP;
+		}
+	case ETHTOOL_GLINK:{
+			struct ethtool_value edata = { ETHTOOL_GLINK };
+			edata.data = netif_carrier_ok(net);
+			if (copy_to_user(uaddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
 		}
-		if (copy_to_user(uaddr, &ecmd, sizeof(ecmd)))
-			return -EFAULT;
-		
-		return 0;
-	}
-	case ETHTOOL_SSET: {
-		return -EOPNOTSUPP;
-	}
-	case ETHTOOL_GLINK: {
-		struct ethtool_value edata = {ETHTOOL_GLINK};
-		edata.data = netif_carrier_ok(net);
-		if (copy_to_user(uaddr, &edata, sizeof(edata)))
-			return -EFAULT;
-		return 0;
-	}
 	default:
 		return -EOPNOTSUPP;
 	}
 }
 
-
-static int pegasus_ioctl( struct net_device *net, struct ifreq *rq, int cmd )
+static int pegasus_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
 {
-	__u16 *data = (__u16 *)&rq->ifr_data;
-	pegasus_t	*pegasus = net->priv;
-	int	res;
+	__u16 *data = (__u16 *) & rq->ifr_data;
+	pegasus_t *pegasus = net->priv;
+	int res;
 
 	down(&pegasus->sem);
-	switch(cmd) {
+	switch (cmd) {
 	case SIOCETHTOOL:
 		res = pegasus_ethtool_ioctl(net, rq->ifr_data);
 		break;
 	case SIOCDEVPRIVATE:
 		data[0] = pegasus->phy;
-	case SIOCDEVPRIVATE+1:
-		read_mii_word(pegasus, data[0], data[1]&0x1f, &data[3]);
+	case SIOCDEVPRIVATE + 1:
+		read_mii_word(pegasus, data[0], data[1] & 0x1f, &data[3]);
 		res = 0;
 		break;
-	case SIOCDEVPRIVATE+2:
-		if ( !capable(CAP_NET_ADMIN) ) {
+	case SIOCDEVPRIVATE + 2:
+		if (!capable(CAP_NET_ADMIN)) {
 			up(&pegasus->sem);
 			return -EPERM;
 		}
@@ -904,8 +860,7 @@
 	return res;
 }
 
-
-static void pegasus_set_multicast( struct net_device *net )
+static void pegasus_set_multicast(struct net_device *net)
 {
 	pegasus_t *pegasus = net->priv;
 
@@ -915,7 +870,7 @@
 		pegasus->eth_regs[EthCtrl2] |= RX_PROMISCUOUS;
 		info("%s: Promiscuous mode enabled", net->name);
 	} else if ((net->mc_count > multicast_filter_limit) ||
-			(net->flags & IFF_ALLMULTI)) {
+		   (net->flags & IFF_ALLMULTI)) {
 		pegasus->eth_regs[EthCtrl0] |= RX_MULTICAST;
 		pegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;
 		info("%s set allmulti", net->name);
@@ -925,100 +880,92 @@
 	}
 
 	pegasus->flags |= ETH_REGS_CHANGE;
-	ctrl_callback( pegasus->ctrl_urb );
+	ctrl_callback(pegasus->ctrl_urb);
 
 	netif_wake_queue(net);
 }
 
-
-static __u8 mii_phy_probe( pegasus_t *pegasus )
+static __u8 mii_phy_probe(pegasus_t * pegasus)
 {
-	int	i;
-	__u16	tmp;
+	int i;
+	__u16 tmp;
 
-	for ( i=0; i < 32; i++ ) {
-		read_mii_word( pegasus, i, MII_BMSR, &tmp );
-		if ( tmp == 0 || tmp == 0xffff || (tmp & BMSR_MEDIA) == 0 )
+	for (i = 0; i < 32; i++) {
+		read_mii_word(pegasus, i, MII_BMSR, &tmp);
+		if (tmp == 0 || tmp == 0xffff || (tmp & BMSR_MEDIA) == 0)
 			continue;
 		else
-			return	i;
+			return i;
 	}
 
-	return	0xff;
+	return 0xff;
 }
 
-
-static inline void setup_pegasus_II( pegasus_t *pegasus )
+static inline void setup_pegasus_II(pegasus_t * pegasus)
 {
-	set_register( pegasus, Reg1d, 0 );
-	set_register( pegasus, Reg7b, 2 );
-	if ( pegasus->features & HAS_HOME_PNA  && mii_mode )
-		set_register( pegasus, Reg81, 6 );
+	set_register(pegasus, Reg1d, 0);
+	set_register(pegasus, Reg7b, 2);
+	if (pegasus->features & HAS_HOME_PNA && mii_mode)
+		set_register(pegasus, Reg81, 6);
 	else
-		set_register( pegasus, Reg81, 2 );
+		set_register(pegasus, Reg81, 2);
 }
 
-
-static void * pegasus_probe( struct usb_device *dev, unsigned int ifnum,
-			     const struct usb_device_id *id)
+static void *pegasus_probe(struct usb_device *dev, unsigned int ifnum,
+			   const struct usb_device_id *id)
 {
-	struct net_device	*net;
-	pegasus_t		*pegasus;
-	int			dev_index = id - pegasus_ids;
+	struct net_device *net;
+	pegasus_t *pegasus;
+	int dev_index = id - pegasus_ids;
 
 	if (usb_set_configuration(dev, dev->config[0].bConfigurationValue)) {
 		err("usb_set_configuration() failed");
 		return NULL;
 	}
 
-	down(&gsem);
-	if(!(pegasus = kmalloc(sizeof(struct pegasus), GFP_KERNEL))) {
+	if (!(pegasus = kmalloc(sizeof(struct pegasus), GFP_KERNEL))) {
 		err("out of memory allocating device structure");
-		goto exit;
+		return NULL;
 	}
 
-	usb_inc_dev_use( dev );
+	usb_inc_dev_use(dev);
 	memset(pegasus, 0, sizeof(struct pegasus));
 	pegasus->dev_index = dev_index;
-	init_waitqueue_head( &pegasus->ctrl_wait );
+	init_waitqueue_head(&pegasus->ctrl_wait);
 
 	pegasus->ctrl_urb = usb_alloc_urb(0);
 	if (!pegasus->ctrl_urb) {
-		kfree (pegasus);
-		pegasus = NULL;
-		goto exit;
+		kfree(pegasus);
+		return NULL;
 	}
 	pegasus->rx_urb = usb_alloc_urb(0);
 	if (!pegasus->rx_urb) {
-		usb_free_urb (pegasus->ctrl_urb);
-		kfree (pegasus);
-		pegasus = NULL;
-		goto exit;
+		usb_free_urb(pegasus->ctrl_urb);
+		kfree(pegasus);
+		return NULL;
 	}
 	pegasus->tx_urb = usb_alloc_urb(0);
 	if (!pegasus->tx_urb) {
-		usb_free_urb (pegasus->rx_urb);
-		usb_free_urb (pegasus->ctrl_urb);
-		kfree (pegasus);
-		pegasus = NULL;
-		goto exit;
+		usb_free_urb(pegasus->rx_urb);
+		usb_free_urb(pegasus->ctrl_urb);
+		kfree(pegasus);
+		return NULL;
 	}
 	pegasus->intr_urb = usb_alloc_urb(0);
 	if (!pegasus->intr_urb) {
-		usb_free_urb (pegasus->tx_urb);
-		usb_free_urb (pegasus->rx_urb);
-		usb_free_urb (pegasus->ctrl_urb);
-		kfree (pegasus);
-		pegasus = NULL;
-		goto exit;
+		usb_free_urb(pegasus->tx_urb);
+		usb_free_urb(pegasus->rx_urb);
+		usb_free_urb(pegasus->ctrl_urb);
+		kfree(pegasus);
+		return NULL;
 	}
 
-	net = init_etherdev( NULL, 0 );
-	if ( !net ) {
-		usb_free_urb (pegasus->tx_urb);
-		usb_free_urb (pegasus->rx_urb);
-		usb_free_urb (pegasus->ctrl_urb);
-		kfree( pegasus );
+	net = init_etherdev(NULL, 0);
+	if (!net) {
+		usb_free_urb(pegasus->tx_urb);
+		usb_free_urb(pegasus->rx_urb);
+		usb_free_urb(pegasus->ctrl_urb);
+		kfree(pegasus);
 		return NULL;
 	}
 
@@ -1040,32 +987,32 @@
 
 	pegasus->features = usb_dev_id[dev_index].private;
 #ifdef	PEGASUS_USE_INTR
-	get_interrupt_interval( pegasus );
+	get_interrupt_interval(pegasus);
 #endif
-	if ( reset_mac(pegasus) ) {
+	if (reset_mac(pegasus)) {
 		err("can't reset MAC");
-		unregister_netdev( pegasus->net );
-		usb_free_urb (pegasus->tx_urb);
-		usb_free_urb (pegasus->rx_urb);
-		usb_free_urb (pegasus->ctrl_urb);
+		unregister_netdev(pegasus->net);
+		usb_free_urb(pegasus->tx_urb);
+		usb_free_urb(pegasus->rx_urb);
+		usb_free_urb(pegasus->ctrl_urb);
 		kfree(pegasus->net);
 		kfree(pegasus);
 		pegasus = NULL;
 		goto exit;
 	}
 
-	info( "%s: %s", net->name, usb_dev_id[dev_index].name );
+	info("%s: %s", net->name, usb_dev_id[dev_index].name);
 
-	set_ethernet_addr( pegasus );
+	set_ethernet_addr(pegasus);
 
-	if ( pegasus->features & PEGASUS_II ) {
-		info( "setup Pegasus II specific registers" );
-		setup_pegasus_II( pegasus );
-	}
-	
-	pegasus->phy = mii_phy_probe( pegasus );
-	if ( pegasus->phy == 0xff ) {
-		warn( "can't locate MII phy, using default" );
+	if (pegasus->features & PEGASUS_II) {
+		info("setup Pegasus II specific registers");
+		setup_pegasus_II(pegasus);
+	}
+
+	pegasus->phy = mii_phy_probe(pegasus);
+	if (pegasus->phy == 0xff) {
+		warn("can't locate MII phy, using default");
 		pegasus->phy = 1;
 	}
 
@@ -1074,19 +1021,18 @@
 	return pegasus;
 }
 
-
-static void pegasus_disconnect( struct usb_device *dev, void *ptr )
+static void pegasus_disconnect(struct usb_device *dev, void *ptr)
 {
 	struct pegasus *pegasus = ptr;
 
-	if ( !pegasus ) {
+	if (!pegasus) {
 		warn("unregistering non-existant device");
 		return;
 	}
 
 	pegasus->flags |= PEGASUS_UNPLUG;
-	unregister_netdev( pegasus->net );
-	usb_dec_dev_use( dev );
+	unregister_netdev(pegasus->net);
+	usb_dec_dev_use(dev);
 	usb_unlink_urb(pegasus->intr_urb);
 	usb_unlink_urb(pegasus->tx_urb);
 	usb_unlink_urb(pegasus->rx_urb);
@@ -1095,12 +1041,11 @@
 	usb_free_urb(pegasus->tx_urb);
 	usb_free_urb(pegasus->rx_urb);
 	usb_free_urb(pegasus->ctrl_urb);
-	kfree( pegasus->net );
-	kfree( pegasus );
+	kfree(pegasus->net);
+	kfree(pegasus);
 	pegasus = NULL;
 }
 
-
 static struct usb_driver pegasus_driver = {
 	name:		"pegasus",
 	probe:		pegasus_probe,
@@ -1111,13 +1056,13 @@
 int __init pegasus_init(void)
 {
 	info(DRIVER_VERSION ":" DRIVER_DESC);
-	return usb_register( &pegasus_driver );
+	return usb_register(&pegasus_driver);
 }
 
 void __exit pegasus_exit(void)
 {
-	usb_deregister( &pegasus_driver );
+	usb_deregister(&pegasus_driver);
 }
 
-module_init( pegasus_init );
-module_exit( pegasus_exit );
+module_init(pegasus_init);
+module_exit(pegasus_exit);
diff -Nur linux-2.4.19.old/drivers/usb/pegasus.h linux-2.4.19/drivers/usb/pegasus.h
--- linux-2.4.19.old/drivers/usb/pegasus.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/pegasus.h	Mon Nov 25 12:26:55 2002
@@ -2,18 +2,9 @@
  * Copyright (c) 1999-2002 Petko Manolov - Petkan (petkan@users.sourceforge.net)
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 
@@ -99,7 +90,7 @@
 	int			dev_index;
 	int			intr_interval;
 	struct urb		*ctrl_urb, *rx_urb, *tx_urb, *intr_urb;
-	devrequest		dr;
+	struct usb_ctrlrequest	dr;
 	wait_queue_head_t	ctrl_wait;
 	struct semaphore	sem;
 	unsigned char		rx_buff[PEGASUS_MAX_MTU];
@@ -122,6 +113,7 @@
 #define	VENDOR_ABOCOM		0x07b8
 #define	VENDOR_ACCTON		0x083a
 #define	VENDOR_ADMTEK		0x07a6
+#define	VENDOR_AEILAB		0x3334
 #define	VENDOR_ALLIEDTEL	0x07c9
 #define	VENDOR_BELKIN		0x050d
 #define	VENDOR_BILLIONTON	0x08dd
@@ -177,6 +169,8 @@
 		DEFAULT_GPIO_RESET | HAS_HOME_PNA )
 PEGASUS_DEV( "ADMtek AN986A USB MAC", VENDOR_ADMTEK, 0x1986,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
+PEGASUS_DEV( "AEI USB Fast Ethernet Adapter", VENDOR_AEILAB, 0x1701,
+		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "Allied Telesyn Int. AT-USB100", VENDOR_ALLIEDTEL, 0xb100,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "Belkin F5D5050 USB Ethernet", VENDOR_BELKIN, 0x0121,
@@ -193,6 +187,8 @@
 		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "Corega FEter USB-TX", VENDOR_COREGA, 0x0004,
 		DEFAULT_GPIO_RESET )
+PEGASUS_DEV( "Corega FEter", VENDOR_COREGA, 0x000d,
+		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "D-Link DSB-650TX", VENDOR_DLINK, 0x4001,
 		LINKSYS_GPIO_RESET )
 PEGASUS_DEV( "D-Link DSB-650TX", VENDOR_DLINK, 0x4002,
@@ -207,7 +203,7 @@
 		DEFAULT_GPIO_RESET | HAS_HOME_PNA )
 PEGASUS_DEV( "D-Link DSB-650", VENDOR_DLINK, 0xabc1,
 		DEFAULT_GPIO_RESET )
-PEGASUS_DEV( "ELCON EPLC10Mi USB to Powerline Adapter", VENDOR_ELCON, 0x0002,
+PEGASUS_DEV( "GOLDPFEIL USB Adapter", VENDOR_ELCON, 0x0002,
 		DEFAULT_GPIO_RESET | PEGASUS_II | HAS_HOME_PNA )
 PEGASUS_DEV( "Elsa Micolink USB2Ethernet", VENDOR_ELSA, 0x3000,
 		DEFAULT_GPIO_RESET )
@@ -256,6 +252,6 @@
 PEGASUS_DEV( "SOHOware NUB110 Ethernet", VENDOR_SOHOWARE, 0x9110,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "SpeedStream USB 10/100 Ethernet", VENDOR_SIEMENS, 0x1001,
-		DEFAULT_GPIO_RESET )
+		DEFAULT_GPIO_RESET | PEGASUS_II )
 
 #endif	/* PEGASUS_DEV */
diff -Nur linux-2.4.19.old/drivers/usb/printer.c linux-2.4.19/drivers/usb/printer.c
--- linux-2.4.19.old/drivers/usb/printer.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/printer.c	Mon Nov 25 12:26:55 2002
@@ -257,7 +257,7 @@
  * Get and print printer errors.
  */
 
-static char *usblp_messages[] = { "ok", "out of paper", "off-line", "on fire" };
+static char *usblp_messages[] = { "ok", "out of paper", "off-line", "unknown error" };
 
 static int usblp_check_status(struct usblp *usblp, int err)
 {
@@ -388,7 +388,8 @@
 {
 	struct usblp *usblp = file->private_data;
 	int length, err, i;
-	unsigned char status, newChannel;
+	unsigned char lpstatus, newChannel;
+	int status;
 	int twoints[2];
 	int retval = 0;
 
@@ -539,12 +540,13 @@
 		switch (cmd) {
 
 			case LPGETSTATUS:
-				if (usblp_read_status(usblp, &status)) {
+				if (usblp_read_status(usblp, &lpstatus)) {
 					err("usblp%d: failed reading printer status", usblp->minor);
 					retval = -EIO;
 					goto done;
 				}
-				if (copy_to_user ((unsigned char *)arg, &status, 1))
+				status = lpstatus;
+				if (copy_to_user ((int *)arg, &status, sizeof(int)))
 					retval = -EFAULT;
 				break;
 
@@ -560,7 +562,8 @@
 static ssize_t usblp_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)
 {
 	struct usblp *usblp = file->private_data;
-	int timeout, err = 0, writecount = 0;
+	int timeout, err = 0;
+	size_t writecount = 0;
 
 	while (writecount < count) {
 
@@ -616,10 +619,9 @@
 							 (count - writecount) : USBLP_BUF_SIZE;
 
 		if (copy_from_user(usblp->writeurb.transfer_buffer, buffer + writecount,
-				usblp->writeurb.transfer_buffer_length))
-		{
+				usblp->writeurb.transfer_buffer_length)) {
 			up(&usblp->sem);
-			return writecount?writecount:-EFAULT;
+			return writecount ? writecount : -EFAULT;
 		}
 
 		usblp->writeurb.dev = usblp->dev;
diff -Nur linux-2.4.19.old/drivers/usb/pwc-if.c linux-2.4.19/drivers/usb/pwc-if.c
--- linux-2.4.19.old/drivers/usb/pwc-if.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/pwc-if.c	Mon Nov 25 12:26:55 2002
@@ -65,7 +65,7 @@
 /* Function prototypes and driver templates */
 
 /* hotplug device table support */
-static __devinitdata struct usb_device_id pwc_device_table [] = {
+static struct usb_device_id pwc_device_table [] = {
 	{ USB_DEVICE(0x0471, 0x0302) }, /* Philips models */
 	{ USB_DEVICE(0x0471, 0x0303) },
 	{ USB_DEVICE(0x0471, 0x0304) },
@@ -179,60 +179,25 @@
 /***************************************************************************/
 /* Private functions */
 
-/* Memory management functions, nicked from cpia.c, which nicked them from
-   bttv.c. So far, I've counted duplication of this code 6 times 
-   (bttv, cpia, ibmcam, ov511, pwc, ieee1394).
- */
-
-/* Given PGD from the address space's page table, return the kernel
- * virtual mapping of the physical memory mapped at ADR.
- */
-static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
-{
-        unsigned long ret = 0UL;
-	pmd_t *pmd;
-	pte_t *ptep, pte;
-  
-	if (!pgd_none(*pgd)) {
-                pmd = pmd_offset(pgd, adr);
-                if (!pmd_none(*pmd)) {
-                        ptep = pte_offset(pmd, adr);
-                        pte = *ptep;
-                        if(pte_present(pte)) {
-				ret  = (unsigned long) page_address(pte_page(pte));
-				ret |= (adr & (PAGE_SIZE - 1));
-				
-			}
-                }
-        }
-	return ret;
-}
-
-
-
 /* Here we want the physical address of the memory.
- * This is used when initializing the contents of the
- * area and marking the pages as reserved.
+ * This is used when initializing the contents of the area.
  */
 static inline unsigned long kvirt_to_pa(unsigned long adr) 
 {
-        unsigned long va, kva, ret;
+        unsigned long kva, ret;
 
-        va = VMALLOC_VMADDR(adr);
-        kva = uvirt_to_kva(pgd_offset_k(va), va);
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
 	ret = __pa(kva);
         return ret;
 }
 
-static void * rvmalloc(signed long size)
+static void * rvmalloc(unsigned long size)
 {
 	void * mem;
-	unsigned long adr, page;
+	unsigned long adr;
 
-        /* Round it off to PAGE_SIZE */
-        size += (PAGE_SIZE - 1);
-        size &= ~(PAGE_SIZE - 1);	
-        
+	size=PAGE_ALIGN(size);
         mem=vmalloc_32(size);
 	if (mem) 
 	{
@@ -240,8 +205,7 @@
 	        adr=(unsigned long) mem;
 		while (size > 0) 
                 {
-	                page = kvirt_to_pa(adr);
-			mem_map_reserve(virt_to_page(__va(page)));
+			mem_map_reserve(vmalloc_to_page((void *)adr));
 			adr+=PAGE_SIZE;
 			size-=PAGE_SIZE;
 		}
@@ -249,20 +213,16 @@
 	return mem;
 }
 
-static void rvfree(void * mem, signed long size)
+static void rvfree(void * mem, unsigned long size)
 {
-        unsigned long adr, page;
-        
-        /* Round it off to PAGE_SIZE */
-        size += (PAGE_SIZE - 1);
-        size &= ~(PAGE_SIZE - 1);	
+        unsigned long adr;
+
 	if (mem) 
 	{
 	        adr=(unsigned long) mem;
-		while (size > 0) 
+		while ((long) size > 0) 
                 {
-	                page = kvirt_to_pa(adr);
-			mem_map_unreserve(virt_to_page(__va(page)));
+			mem_map_unreserve(vmalloc_to_page((void *)adr));
 			adr+=PAGE_SIZE;
 			size-=PAGE_SIZE;
 		}
diff -Nur linux-2.4.19.old/drivers/usb/rtl8150.c linux-2.4.19/drivers/usb/rtl8150.c
--- linux-2.4.19.old/drivers/usb/rtl8150.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/rtl8150.c	Mon Nov 25 12:26:56 2002
@@ -1,11 +1,9 @@
 /*
- * Copyright (c) 2002 Petko Manolov (petkan@users.sourceforge.net)
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License as
- *	published by the Free Software Foundation; either version 2 of
- *	the License, or (at your option) any later version.
+ *  Copyright (c) 2002 Petko Manolov (petkan@users.sourceforge.net)
  *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License 
+ * version 2 as published by the Free Software Foundation.
  */
 
 #include <linux/config.h>
@@ -22,14 +20,11 @@
 #include <linux/init.h>
 #include <asm/uaccess.h>
 
-
-
 /* Version Information */
-#define DRIVER_VERSION "v0.4.0 (2002/03/28)"
+#define DRIVER_VERSION "v0.4.1 (2002/07/22)"
 #define DRIVER_AUTHOR "Petko Manolov <petkan@users.sourceforge.net>"
 #define DRIVER_DESC "rtl8150 based usb-ethernet driver"
 
-
 #define	IRD			0x0120
 #define	MAR			0x0126
 #define	CR			0x012e
@@ -69,49 +64,48 @@
 #define	RX_REG_SET		1
 #define	RTL8150_UNPLUG		2
 
-
 /* Define these values to match your device */
 #define VENDOR_ID_REALTEK		0x0bda
+#define	VENDOR_ID_MELCO			0x0411
+
 #define PRODUCT_ID_RTL8150		0x8150
+#define	PRODUCT_ID_LUAKTX		0x0012
 
 /* table of devices that work with this driver */
-static struct usb_device_id rtl8150_table [] = {
-	{ USB_DEVICE(VENDOR_ID_REALTEK, PRODUCT_ID_RTL8150) },
-	{ }				
+static struct usb_device_id rtl8150_table[] = {
+	{USB_DEVICE(VENDOR_ID_REALTEK, PRODUCT_ID_RTL8150)},
+	{USB_DEVICE(VENDOR_ID_MELCO, PRODUCT_ID_LUAKTX)},
+	{}
 };
 
-MODULE_DEVICE_TABLE (usb, rtl8150_table);
-
+MODULE_DEVICE_TABLE(usb, rtl8150_table);
 
 struct rtl8150 {
-	unsigned long		flags;
-	struct usb_device	*udev;
-	struct usb_interface	*interface;
-	struct semaphore	sem;
-	struct net_device_stats	stats;
-	struct net_device	*netdev;
-	struct urb		*rx_urb, *tx_urb, *intr_urb, *ctrl_urb;
-	devrequest		dr;
-	int			intr_interval;
-	u16			rx_creg;
-	u8			rx_buff[RTL8150_MAX_MTU];
-	u8			tx_buff[RTL8150_MAX_MTU];
-	u8			intr_buff[8];
-	u8			phy;
+	unsigned int flags;
+	struct usb_device *udev;
+	struct usb_interface *interface;
+	struct semaphore sem;
+	struct net_device_stats stats;
+	struct net_device *netdev;
+	struct urb *rx_urb, *tx_urb, *intr_urb, *ctrl_urb;
+	struct usb_ctrlrequest dr;
+	int intr_interval;
+	u16 rx_creg;
+	u8 rx_buff[RTL8150_MAX_MTU];
+	u8 tx_buff[RTL8150_MAX_MTU];
+	u8 intr_buff[8];
+	u8 phy;
 };
 
-typedef	struct rtl8150	rtl8150_t;
-
+typedef struct rtl8150 rtl8150_t;
 
 /* the global usb devfs handle */
 extern devfs_handle_t usb_devfs_handle;
 unsigned long multicast_filter_limit = 32;
 
-
 static void rtl8150_disconnect(struct usb_device *dev, void *ptr);
-static void * rtl8150_probe(struct usb_device *dev, unsigned int ifnum,
-			    const struct usb_device_id *id);
-
+static void *rtl8150_probe(struct usb_device *dev, unsigned int ifnum,
+			   const struct usb_device_id *id);
 
 static struct usb_driver rtl8150_driver = {
 	name:		"rtl8150",
@@ -120,33 +114,29 @@
 	id_table:	rtl8150_table,
 };
 
-
-
 /*
 **
 **	device related part of the code
 **
 */
-static int get_registers(rtl8150_t *dev, u16 indx, u16 size, void *data)
+static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
-	return usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev,0),
-				RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
-				indx, 0, data, size, HZ/2);
+	return usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
+			       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
+			       indx, 0, data, size, HZ / 2);
 }
 
-
-static int set_registers(rtl8150_t *dev, u16 indx, u16 size, void *data)
+static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
-	return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev,0),
-				RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
-				indx, 0, data, size, HZ/2);
+	return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
+			       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
+			       indx, 0, data, size, HZ / 2);
 }
 
-
 static void ctrl_callback(struct urb *urb)
 {
-	rtl8150_t	*dev;
-	
+	rtl8150_t *dev;
+
 	switch (urb->status) {
 	case 0:
 		break;
@@ -161,22 +151,22 @@
 	clear_bit(RX_REG_SET, &dev->flags);
 }
 
-
-static int async_set_registers(rtl8150_t *dev, u16 indx, u16 size, void *data)
+static int async_set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
-	int	ret;
+	int ret;
 
 	if (test_bit(RX_REG_SET, &dev->flags))
 		return -EAGAIN;
-	
-	dev->dr.requesttype = RTL8150_REQT_WRITE;
-	dev->dr.request = RTL8150_REQ_SET_REGS;
-	dev->dr.value = cpu_to_le16(indx);
-	dev->dr.index = 0;
-	dev->dr.length = cpu_to_le16(2);
+
+	dev->dr.bRequestType = RTL8150_REQT_WRITE;
+	dev->dr.bRequest = RTL8150_REQ_SET_REGS;
+	dev->dr.wValue = cpu_to_le16(indx);
+	dev->dr.wIndex = 0;
+	dev->dr.wLength = cpu_to_le16(2);
 	dev->ctrl_urb->transfer_buffer_length = 2;
-	FILL_CONTROL_URB(dev->ctrl_urb, dev->udev, usb_sndctrlpipe(dev->udev,0),
-	                 (char*)&dev->dr, &dev->rx_creg, 2, ctrl_callback, dev);
+	FILL_CONTROL_URB(dev->ctrl_urb, dev->udev,
+			 usb_sndctrlpipe(dev->udev, 0), (char *) &dev->dr,
+			 &dev->rx_creg, 2, ctrl_callback, dev);
 	if ((ret = usb_submit_urb(dev->ctrl_urb)))
 		err("control request submission failed: %d", ret);
 	else
@@ -185,11 +175,10 @@
 	return ret;
 }
 
-
-static int read_mii_word(rtl8150_t *dev, u8 phy, __u8 indx, u16 *reg)
+static int read_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 * reg)
 {
-	int	i;
-	u8	data[3], tmp;
+	int i;
+	u8 data[3], tmp;
 
 	data[0] = phy;
 	data[1] = data[2] = 0;
@@ -204,17 +193,16 @@
 
 	if (i < HZ) {
 		get_registers(dev, PHYDAT, 2, data);
-		*reg = le16_to_cpup(data);
+		*reg = le16_to_cpup((u16 *)data);
 		return 0;
 	} else
 		return 1;
 }
 
-
-static int write_mii_word(rtl8150_t *dev, u8 phy, __u8 indx, u16 reg)
+static int write_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 reg)
 {
-	int	i;
-	u8	data[3], tmp;
+	int i;
+	u8 data[3], tmp;
 
 	data[0] = phy;
 	*(data + 1) = cpu_to_le16p(&reg);
@@ -225,7 +213,7 @@
 	set_registers(dev, PHYCNT, 1, &tmp);
 	do {
 		get_registers(dev, PHYCNT, 1, data);
-	} while((data[0] & PHY_GO) && (i++ < HZ));
+	} while ((data[0] & PHY_GO) && (i++ < HZ));
 
 	if (i < HZ)
 		return 0;
@@ -233,31 +221,28 @@
 		return 1;
 }
 
-
-static inline void set_ethernet_addr(rtl8150_t *dev)
+static inline void set_ethernet_addr(rtl8150_t * dev)
 {
-	u8	node_id[6];
+	u8 node_id[6];
 
 	get_registers(dev, IRD, sizeof(node_id), node_id);
 	memcpy(dev->netdev->dev_addr, node_id, sizeof(node_id));
 }
 
-
-static int rtl8150_reset(rtl8150_t *dev)
+static int rtl8150_reset(rtl8150_t * dev)
 {
-	u8	data=0x10;
-	int	i=HZ;
+	u8 data = 0x10;
+	int i = HZ;
 
 	set_registers(dev, CR, 1, &data);
 	do {
 		get_registers(dev, CR, 1, &data);
 	} while ((data & 0x10) && --i);
-	
+
 	return (i > 0) ? 0 : -1;
 }
 
-
-static int alloc_all_urbs(rtl8150_t *dev)
+static int alloc_all_urbs(rtl8150_t * dev)
 {
 	dev->rx_urb = usb_alloc_urb(0);
 	if (!dev->rx_urb)
@@ -284,8 +269,7 @@
 	return 1;
 }
 
-
-static void free_all_urbs(rtl8150_t *dev)
+static void free_all_urbs(rtl8150_t * dev)
 {
 	usb_free_urb(dev->rx_urb);
 	usb_free_urb(dev->tx_urb);
@@ -293,8 +277,7 @@
 	usb_free_urb(dev->ctrl_urb);
 }
 
-
-static void unlink_all_urbs(rtl8150_t *dev)
+static void unlink_all_urbs(rtl8150_t * dev)
 {
 	usb_unlink_urb(dev->rx_urb);
 	usb_unlink_urb(dev->tx_urb);
@@ -302,14 +285,13 @@
 	usb_unlink_urb(dev->ctrl_urb);
 }
 
-
 static void read_bulk_callback(struct urb *urb)
 {
-	rtl8150_t	*dev;
-	int		pkt_len, res;
-	struct sk_buff	*skb;
+	rtl8150_t *dev;
+	int pkt_len, res;
+	struct sk_buff *skb;
 	struct net_device *netdev;
-	u16		rx_stat;
+	u16 rx_stat;
 
 	dev = urb->context;
 	if (!dev) {
@@ -333,11 +315,11 @@
 		warn("Rx status %d", urb->status);
 		goto goon;
 	}
-	
+
 	pkt_len = urb->actual_length - 4;
-	rx_stat = le16_to_cpu(*(u16 *)(dev->rx_buff + pkt_len));
+	rx_stat = le16_to_cpu(*(u16 *) (dev->rx_buff + pkt_len));
 
-	if (!(skb = dev_alloc_skb(pkt_len + 2))) 
+	if (!(skb = dev_alloc_skb(pkt_len + 2)))
 		goto goon;
 	skb->dev = netdev;
 	skb_reserve(skb, 2);
@@ -348,16 +330,15 @@
 	dev->stats.rx_packets++;
 	dev->stats.rx_bytes += pkt_len;
 goon:
-	FILL_BULK_URB(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev,1),
-	              dev->rx_buff, RTL8150_MAX_MTU, read_bulk_callback, dev);
-	if ((res=usb_submit_urb(dev->rx_urb)))
+	FILL_BULK_URB(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),
+		      dev->rx_buff, RTL8150_MAX_MTU, read_bulk_callback, dev);
+	if ((res = usb_submit_urb(dev->rx_urb)))
 		warn("%s: Rx urb submission failed %d", netdev->name, res);
 }
 
-
 static void write_bulk_callback(struct urb *urb)
 {
-	rtl8150_t	*dev;
+	rtl8150_t *dev;
 
 	dev = urb->context;
 	if (!dev)
@@ -370,36 +351,32 @@
 	netif_wake_queue(dev->netdev);
 }
 
-
 void intr_callback(struct urb *urb)
 {
-	rtl8150_t	*dev;
+	rtl8150_t *dev;
 
 	dev = urb->context;
 	if (!dev)
 		return;
 	switch (urb->status) {
-		case 0:
-			break;
-		case -ENOENT:
-			return;
-		default:
-			info("%s: intr status %d", dev->netdev->name,
-			     urb->status);
+	case 0:
+		break;
+	case -ENOENT:
+		return;
+	default:
+		info("%s: intr status %d", dev->netdev->name, urb->status);
 	}
 }
 
-
 /*
 **
 **	network related part of the code
 **
 */
 
-
-static int enable_net_traffic(rtl8150_t *dev)
+static int enable_net_traffic(rtl8150_t * dev)
 {
-	u8	cr, tcr, rcr, msr;
+	u8 cr, tcr, rcr, msr;
 
 	if (rtl8150_reset(dev)) {
 		warn("%s - device reset failed", __FUNCTION__);
@@ -415,26 +392,23 @@
 	return 0;
 }
 
-
-static void disable_net_traffic(rtl8150_t *dev)
+static void disable_net_traffic(rtl8150_t * dev)
 {
-	u8	cr;
+	u8 cr;
 
 	get_registers(dev, CR, 1, &cr);
 	cr &= 0xf3;
 	set_registers(dev, CR, 1, &cr);
 }
 
-
 static struct net_device_stats *rtl8150_netdev_stats(struct net_device *dev)
 {
-	return &((rtl8150_t *)dev->priv)->stats;
+	return &((rtl8150_t *) dev->priv)->stats;
 }
 
-
 static void rtl8150_tx_timeout(struct net_device *netdev)
 {
-	rtl8150_t	*dev;
+	rtl8150_t *dev;
 
 	dev = netdev->priv;
 	if (!dev)
@@ -445,10 +419,9 @@
 	dev->stats.tx_errors++;
 }
 
-
 static void rtl8150_set_multicast(struct net_device *netdev)
 {
-	rtl8150_t	*dev;
+	rtl8150_t *dev;
 
 	dev = netdev->priv;
 	netif_stop_queue(netdev);
@@ -456,7 +429,7 @@
 		dev->rx_creg |= 0x0001;
 		info("%s: promiscuous mode", netdev->name);
 	} else if ((netdev->mc_count > multicast_filter_limit) ||
-	           (netdev->flags & IFF_ALLMULTI)) {
+		   (netdev->flags & IFF_ALLMULTI)) {
 		dev->rx_creg &= 0xfffe;
 		dev->rx_creg |= 0x0002;
 		info("%s: allmulti set", netdev->name);
@@ -468,18 +441,17 @@
 	netif_wake_queue(netdev);
 }
 
-
 static int rtl8150_start_xmit(struct sk_buff *skb, struct net_device *netdev)
 {
-	rtl8150_t	*dev;
-	int		count, res;
+	rtl8150_t *dev;
+	int count, res;
 
 	netif_stop_queue(netdev);
 	dev = netdev->priv;
 	count = (skb->len < 60) ? 60 : skb->len;
 	count = (count & 0x3f) ? count : count + 1;
 	memcpy(dev->tx_buff, skb->data, skb->len);
-	FILL_BULK_URB(dev->tx_urb, dev->udev, usb_sndbulkpipe(dev->udev,2),
+	FILL_BULK_URB(dev->tx_urb, dev->udev, usb_sndbulkpipe(dev->udev, 2),
 		      dev->tx_buff, RTL8150_MAX_MTU, write_bulk_callback, dev);
 	dev->tx_urb->transfer_buffer_length = count;
 
@@ -497,26 +469,25 @@
 	return 0;
 }
 
-
 static int rtl8150_open(struct net_device *netdev)
 {
-	rtl8150_t	*dev;
-	int		res;
-	
+	rtl8150_t *dev;
+	int res;
+
 	dev = netdev->priv;
 	if (dev == NULL) {
 		return -ENODEV;
 	}
 
 	down(&dev->sem);
-	FILL_BULK_URB(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev,1),
-			dev->rx_buff, RTL8150_MAX_MTU, read_bulk_callback, dev);
-	if ((res=usb_submit_urb(dev->rx_urb)))
+	FILL_BULK_URB(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),
+		      dev->rx_buff, RTL8150_MAX_MTU, read_bulk_callback, dev);
+	if ((res = usb_submit_urb(dev->rx_urb)))
 		warn("%s: rx_urb submit failed: %d", __FUNCTION__, res);
-	FILL_INT_URB(dev->intr_urb, dev->udev, usb_rcvintpipe(dev->udev,3),
-			dev->intr_buff, sizeof(dev->intr_buff), intr_callback,
-			dev, dev->intr_interval);
-	if ((res=usb_submit_urb(dev->intr_urb)))
+	FILL_INT_URB(dev->intr_urb, dev->udev, usb_rcvintpipe(dev->udev, 3),
+		     dev->intr_buff, sizeof(dev->intr_buff), intr_callback,
+		     dev, dev->intr_interval);
+	if ((res = usb_submit_urb(dev->intr_urb)))
 		warn("%s: intr_urb submit failed: %d", __FUNCTION__, res);
 	netif_start_queue(netdev);
 	enable_net_traffic(dev);
@@ -525,7 +496,6 @@
 	return res;
 }
 
-
 static int rtl8150_close(struct net_device *netdev)
 {
 	rtl8150_t *dev;
@@ -545,93 +515,92 @@
 	return res;
 }
 
-
 static int rtl8150_ethtool_ioctl(struct net_device *netdev, void *uaddr)
 {
-	rtl8150_t	*dev;
-	int		cmd;
-	char		tmp[128];
+	rtl8150_t *dev;
+	int cmd;
+	char tmp[128];
 
 	dev = netdev->priv;
-	if (get_user(cmd, (int *)uaddr))
+	if (get_user(cmd, (int *) uaddr))
 		return -EFAULT;
 
 	switch (cmd) {
-	case ETHTOOL_GDRVINFO: {
-		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
-		
-		strncpy(info.driver, DRIVER_DESC, ETHTOOL_BUSINFO_LEN);
-		strncpy(info.version, DRIVER_VERSION, ETHTOOL_BUSINFO_LEN);
-		sprintf(tmp, "usb%d:%d", dev->udev->bus->busnum,
-		        dev->udev->devnum);
-		strncpy(info.bus_info, tmp, ETHTOOL_BUSINFO_LEN);
-		if (copy_to_user(uaddr, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	case ETHTOOL_GSET: {
-		struct ethtool_cmd ecmd;
-		short   lpa, bmcr;
-
-		if (copy_from_user(&ecmd, uaddr, sizeof(ecmd)))
-			return -EFAULT;
-		ecmd.supported = (SUPPORTED_10baseT_Half |
-		                  SUPPORTED_10baseT_Full |
-		                  SUPPORTED_100baseT_Half |
-		                  SUPPORTED_100baseT_Full |
-		                  SUPPORTED_Autoneg |
-		                  SUPPORTED_TP |
-		                  SUPPORTED_MII);
-		ecmd.port = PORT_TP;
-		ecmd.transceiver = XCVR_INTERNAL;
-		ecmd.phy_address = dev->phy;
-		get_registers(dev, BMCR, 2, &bmcr);
-		get_registers(dev, ANLP, 2, &lpa);
-		if (bmcr & BMCR_ANENABLE) {
-			ecmd.autoneg = AUTONEG_ENABLE;
-			ecmd.speed = (lpa & (LPA_100HALF | LPA_100FULL)) ?
-			             SPEED_100 : SPEED_10;
-			if (ecmd.speed == SPEED_100)
-				ecmd.duplex = (lpa & LPA_100FULL) ?
-				              DUPLEX_FULL : DUPLEX_HALF;
-			else
-				ecmd.duplex = (lpa & LPA_10FULL) ?
-				              DUPLEX_FULL : DUPLEX_HALF;
-		} else {
-			ecmd.autoneg = AUTONEG_DISABLE;
-			ecmd.speed = (bmcr & BMCR_SPEED100) ?
-			             SPEED_100 : SPEED_10;
-			ecmd.duplex = (bmcr & BMCR_FULLDPLX) ?
-			              DUPLEX_FULL : DUPLEX_HALF;
+	case ETHTOOL_GDRVINFO:{
+			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+
+			strncpy(info.driver, DRIVER_DESC, ETHTOOL_BUSINFO_LEN);
+			strncpy(info.version, DRIVER_VERSION,
+				ETHTOOL_BUSINFO_LEN);
+			sprintf(tmp, "usb%d:%d", dev->udev->bus->busnum,
+				dev->udev->devnum);
+			strncpy(info.bus_info, tmp, ETHTOOL_BUSINFO_LEN);
+			if (copy_to_user(uaddr, &info, sizeof(info)))
+				return -EFAULT;
+			return 0;
+		}
+	case ETHTOOL_GSET:{
+			struct ethtool_cmd ecmd;
+			short lpa, bmcr;
+
+			if (copy_from_user(&ecmd, uaddr, sizeof(ecmd)))
+				return -EFAULT;
+			ecmd.supported = (SUPPORTED_10baseT_Half |
+					  SUPPORTED_10baseT_Full |
+					  SUPPORTED_100baseT_Half |
+					  SUPPORTED_100baseT_Full |
+					  SUPPORTED_Autoneg |
+					  SUPPORTED_TP | SUPPORTED_MII);
+			ecmd.port = PORT_TP;
+			ecmd.transceiver = XCVR_INTERNAL;
+			ecmd.phy_address = dev->phy;
+			get_registers(dev, BMCR, 2, &bmcr);
+			get_registers(dev, ANLP, 2, &lpa);
+			if (bmcr & BMCR_ANENABLE) {
+				ecmd.autoneg = AUTONEG_ENABLE;
+				ecmd.speed =
+				    (lpa & (LPA_100HALF | LPA_100FULL)) ?
+				    SPEED_100 : SPEED_10;
+				if (ecmd.speed == SPEED_100)
+					ecmd.duplex = (lpa & LPA_100FULL) ?
+					    DUPLEX_FULL : DUPLEX_HALF;
+				else
+					ecmd.duplex = (lpa & LPA_10FULL) ?
+					    DUPLEX_FULL : DUPLEX_HALF;
+			} else {
+				ecmd.autoneg = AUTONEG_DISABLE;
+				ecmd.speed = (bmcr & BMCR_SPEED100) ?
+				    SPEED_100 : SPEED_10;
+				ecmd.duplex = (bmcr & BMCR_FULLDPLX) ?
+				    DUPLEX_FULL : DUPLEX_HALF;
+			}
+			if (copy_to_user(uaddr, &ecmd, sizeof(ecmd)))
+				return -EFAULT;
+			return 0;
 		}
-		if (copy_to_user(uaddr, &ecmd, sizeof(ecmd)))
-			return -EFAULT;
-		return 0;
-	}
 	case ETHTOOL_SSET:
 		return -ENOTSUPP;
-	case ETHTOOL_GLINK: {
-		struct ethtool_value edata = {ETHTOOL_GLINK};
+	case ETHTOOL_GLINK:{
+			struct ethtool_value edata = { ETHTOOL_GLINK };
 
-		edata.data = netif_carrier_ok(netdev);
-		if (copy_to_user(uaddr, &edata, sizeof(edata)))
-			return -EFAULT;
-		return 0;
-	}
+			edata.data = netif_carrier_ok(netdev);
+			if (copy_to_user(uaddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
 	default:
 		return -EOPNOTSUPP;
 	}
 }
 
-
-static int rtl8150_ioctl (struct net_device *netdev, struct ifreq *rq, int cmd)
+static int rtl8150_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
 {
 	rtl8150_t *dev;
-	u16	*data;
-	int	res;
+	u16 *data;
+	int res;
 
 	dev = netdev->priv;
-	data = (u16 *)&rq->ifr_data;
+	data = (u16 *) & rq->ifr_data;
 	res = 0;
 
 	down(&dev->sem);
@@ -641,10 +610,10 @@
 		break;
 	case SIOCDEVPRIVATE:
 		data[0] = dev->phy;
-	case SIOCDEVPRIVATE+1:
+	case SIOCDEVPRIVATE + 1:
 		read_mii_word(dev, dev->phy, (data[1] & 0x1f), &data[3]);
 		break;
-	case SIOCDEVPRIVATE+2:
+	case SIOCDEVPRIVATE + 2:
 		if (!capable(CAP_NET_ADMIN)) {
 			up(&dev->sem);
 			return -EPERM;
@@ -659,9 +628,8 @@
 	return res;
 }
 
-
-static void * rtl8150_probe(struct usb_device *udev, unsigned int ifnum,
-			    const struct usb_device_id *id)
+static void *rtl8150_probe(struct usb_device *udev, unsigned int ifnum,
+			   const struct usb_device_id *id)
 {
 	rtl8150_t *dev;
 	struct net_device *netdev;
@@ -671,14 +639,9 @@
 		err("usb_set_configuration() failed");
 		return NULL;
 	}
-	if ((udev->descriptor.idVendor != VENDOR_ID_REALTEK) ||
-	    (udev->descriptor.idProduct != PRODUCT_ID_RTL8150)) {
-	    	err("Not the one we are interested about");
-		return NULL;
-	}
 	dev = kmalloc(sizeof(rtl8150_t), GFP_KERNEL);
 	if (!dev) {
-		err ("Out of memory");
+		err("Out of memory");
 		goto exit;
 	} else
 		memset(dev, 0, sizeof(rtl8150_t));
@@ -690,7 +653,7 @@
 		dev = NULL;
 		goto exit;
 	}
-		
+
 	init_MUTEX(&dev->sem);
 	dev->udev = udev;
 	dev->netdev = netdev;
@@ -724,7 +687,6 @@
 	return dev;
 }
 
-
 static void rtl8150_disconnect(struct usb_device *udev, void *ptr)
 {
 	rtl8150_t *dev;
@@ -740,21 +702,17 @@
 	dev = NULL;
 }
 
-
-
 static int __init usb_rtl8150_init(void)
 {
 	info(DRIVER_DESC " " DRIVER_VERSION);
 	return usb_register(&rtl8150_driver);
 }
 
-
 static void __exit usb_rtl8150_exit(void)
 {
 	usb_deregister(&rtl8150_driver);
 }
 
-
 module_init(usb_rtl8150_init);
 module_exit(usb_rtl8150_exit);
 
diff -Nur linux-2.4.19.old/drivers/usb/scanner.c linux-2.4.19/drivers/usb/scanner.c
--- linux-2.4.19.old/drivers/usb/scanner.c	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/scanner.c	Mon Nov 25 12:26:56 2002
@@ -1,13 +1,13 @@
 /* -*- linux-c -*- */
 
 /* 
- * Driver for USB Scanners (linux-2.4.12)
+ * Driver for USB Scanners (linux-2.4.18)
  *
- * Copyright (C) 1999, 2000, 2001 David E. Nelson
+ * Copyright (C) 1999, 2000, 2001, 2002 David E. Nelson
  *
  * Portions may be copyright Brad Keryan and Michael Gee.
  *
- * David E. Nelson (dnelson@jump.net)
+ * Brian Beattie <beattie@beattie-home.net>
  * 
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -300,11 +300,24 @@
  *      Frank Zago <fzago@greshamstorage.com> and
  *      Oliver Neukum <520047054719-0001@t-online.de> for reviewing/testing.
  *
+ * 0.4.8  5/30/2002
+ *    - Added Mustek BearPaw 2400 TA.  Thanks to Sergey
+ *      Vlasov <vsu@mivlgu.murom.ru>.
+ *    - Added Mustek 1200UB Plus and Mustek BearPaw 1200 CU ID's.  These use
+ *      the Grandtech GT-6801 chip. Thanks to Henning
+ *      Meier-Geinitz <henning@meier-geinitz.de>.
+ *    - Increased Epson timeout to 60 secs as requested from 
+ *      Karl Heinz Kremer <khk@khk.net>.
+ *    - Changed maintainership from David E. Nelson to Brian
+ *      Beattie <beattie@beattie-home.net>.
+ *
  * TODO
+ *    - Remove the 2/3 endpoint limitation
  *    - Performance
  *    - Select/poll methods
  *    - More testing
  *    - Proper registry/assignment for LM9830 ioctl's
+ *    - More general usage ioctl's
  *
  *
  *  Thanks to:
@@ -320,6 +333,8 @@
  *    - All the folks who chimed in with reports and suggestions.
  *    - All the developers that are working on USB SANE backends or other
  *      applications to use USB scanners.
+ *    - Thanks to Greg KH <greg@kroah.com> for setting up Brian Beattie
+ *      to be the new USB Scanner maintainer.
  *
  *  Performance:
  *
@@ -747,7 +762,7 @@
  	case SCANNER_IOCTL_CTRLMSG:
  	{
  		struct ctrlmsg_ioctl {
- 			devrequest	req;
+ 			struct usb_ctrlrequest	req;
  			void		*data;
  		} cmsg;
  		int pipe, nb, ret;
@@ -756,12 +771,12 @@
  		if (copy_from_user(&cmsg, (void *)arg, sizeof(cmsg)))
  			return -EFAULT;
 
- 		nb = le16_to_cpup(&cmsg.req.length);
+ 		nb = cmsg.req.wLength;
 
  		if (nb > sizeof(buf))
  			return -EINVAL;
 
- 		if ((cmsg.req.requesttype & 0x80) == 0) {
+ 		if ((cmsg.req.bRequestType & 0x80) == 0) {
  			pipe = usb_sndctrlpipe(dev, 0);
  			if (nb > 0 && copy_from_user(buf, cmsg.data, nb))
  				return -EFAULT;
@@ -769,10 +784,10 @@
  			pipe = usb_rcvctrlpipe(dev, 0);
 		}
 
- 		ret = usb_control_msg(dev, pipe, cmsg.req.request,
- 				      cmsg.req.requesttype,
- 				      le16_to_cpup(&cmsg.req.value),
- 				      le16_to_cpup(&cmsg.req.index),
+ 		ret = usb_control_msg(dev, pipe, cmsg.req.bRequest,
+ 				      cmsg.req.bRequestType,
+ 				      cmsg.req.wValue,
+ 				      cmsg.req.wIndex,
  				      buf, nb, HZ);
 
  		if (ret < 0) {
@@ -780,7 +795,7 @@
  			return -EIO;
  		}
 
- 		if (nb > 0 && (cmsg.req.requesttype & 0x80) && copy_to_user(cmsg.data, buf, nb))
+ 		if (nb > 0 && (cmsg.req.bRequestType & 0x80) && copy_to_user(cmsg.data, buf, nb))
  			return -EFAULT;
 
  		return 0;
@@ -1017,7 +1032,7 @@
 
 	switch (dev->descriptor.idVendor) { /* Scanner specific read timeout parameters */
 	case 0x04b8:		/* Seiko/Epson */
-		scn->rd_nak_timeout = HZ * 40;
+		scn->rd_nak_timeout = HZ * 60;
 		break;
 	case 0x055f:		/* Mustek */
 	case 0x0400:		/* Another Mustek */
diff -Nur linux-2.4.19.old/drivers/usb/scanner.h linux-2.4.19/drivers/usb/scanner.h
--- linux-2.4.19.old/drivers/usb/scanner.h	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/scanner.h	Mon Nov 25 12:26:56 2002
@@ -1,9 +1,9 @@
 /*
- * Driver for USB Scanners (linux-2.4.12)
+ * Driver for USB Scanners (linux-2.4.18)
  *
- * Copyright (C) 1999, 2000, 2001 David E. Nelson
+ * Copyright (C) 1999, 2000, 2001, 2002 David E. Nelson
  *
- * David E. Nelson (dnelson@jump.net)
+ * Brian Beattie <beattie@beattie-home.net>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -48,7 +48,7 @@
 
 static __s32 vendor=-1, product=-1, read_timeout=0;
 
-MODULE_AUTHOR("David E. Nelson, dnelson@jump.net, http://www.jump.net/~dnelson");
+MODULE_AUTHOR("Brian Beattie, beattie@beattie-home.net");
 MODULE_DESCRIPTION(DRIVER_DESC" "DRIVER_VERSION);
 MODULE_LICENSE("GPL");
 
@@ -90,9 +90,12 @@
 	{ USB_DEVICE(0x06bd, 0x2097) }, /* SnapScan e26 */
 	{ USB_DEVICE(0x06bd, 0x208d) }, /* Snapscan e40 */
 	/* Canon */
-	{ USB_DEVICE(0x04a9, 0x2202) }, /* FB620U */
+	{ USB_DEVICE(0x04a9, 0x2202) }, /* CanoScan FB620U */
+	{ USB_DEVICE(0x04a9, 0x2204) }, /* CanoScan FB630U/FB636U */
+	{ USB_DEVICE(0x04a9, 0x2206) }, /* CanoScan N650U/N656U */
+	{ USB_DEVICE(0x04a9, 0x2207) }, /* CanoScan N1220U */
+	{ USB_DEVICE(0x04a9, 0x2208) }, /* CanoScan D660U */ 
 	{ USB_DEVICE(0x04a9, 0x220b) }, /* D646U */
-	{ USB_DEVICE(0x04a9, 0x2207) }, /* 1220U */
 	/* Colorado -- See Primax/Colorado below */
 	/* Epson -- See Seiko/Epson below */
 	/* Genius */
@@ -110,6 +113,7 @@
 	{ USB_DEVICE(0x03f0, 0x0105) },	/* 4200C */
 	{ USB_DEVICE(0x03f0, 0x0305) }, /* 4300C */
 	{ USB_DEVICE(0x03f0, 0x0102) },	/* PhotoSmart S20 */
+	{ USB_DEVICE(0x03f0, 0x0705) }, /* 4400C */
 	{ USB_DEVICE(0x03f0, 0x0401) },	/* 5200C */
 	//	{ USB_DEVICE(0x03f0, 0x0701) },	/* 5300C - NOT SUPPORTED - see http://www.neatech.nl/oss/HP5300C/ */
 	{ USB_DEVICE(0x03f0, 0x0201) },	/* 6200C */
@@ -141,6 +145,8 @@
 	{ USB_DEVICE(0x0400, 0x1001) }, /* BearPaw 2400 */
 	{ USB_DEVICE(0x055f, 0x0008) }, /* 1200 CU Plus */
 	{ USB_DEVICE(0x0ff5, 0x0010) }, /* BearPaw 1200F */
+	{ USB_DEVICE(0x055f, 0x0218) }, /* BearPaw 2400 TA */
+	{ USB_DEVICE(0x05d8, 0x4002) }, /* 1200 CU and 1200 UB Plus */
 	/* Plustek */
 	{ USB_DEVICE(0x07b3, 0x0017) }, /* OpticPro UT12 */
 	{ USB_DEVICE(0x07b3, 0x0011) }, /* OpticPro UT24 */
@@ -179,8 +185,12 @@
 	{ USB_DEVICE(0x04b8, 0x010b) }, /* Perfection 1240U */
 	{ USB_DEVICE(0x04b8, 0x010c) }, /* Perfection 640U */
 	{ USB_DEVICE(0x04b8, 0x010e) }, /* Expression 1680 */
+	{ USB_DEVICE(0x04b8, 0x010f) }, /* Perfection 1250U */
 	{ USB_DEVICE(0x04b8, 0x0110) }, /* Perfection 1650 */
 	{ USB_DEVICE(0x04b8, 0x0112) }, /* Perfection 2450 - GT-9700 for the Japanese mkt */
+	{ USB_DEVICE(0x04b8, 0x0114) }, /* Perfection 660 */
+	{ USB_DEVICE(0x04b8, 0x011b) }, /* Perfection 2400 Photo */
+	{ USB_DEVICE(0x04b8, 0x011e) }, /* Perfection 1660 Photo */
 	/* Umax */
 	{ USB_DEVICE(0x1606, 0x0010) },	/* Astra 1220U */
 	{ USB_DEVICE(0x1606, 0x0030) },	/* Astra 2000U */
@@ -230,7 +240,7 @@
 #define SCANNER_IOCTL_VENDOR _IOR('U', 0x20, int)
 #define SCANNER_IOCTL_PRODUCT _IOR('U', 0x21, int)
 /* send/recv a control message to the scanner */
-#define SCANNER_IOCTL_CTRLMSG _IOWR('U', 0x22, devrequest )
+#define SCANNER_IOCTL_CTRLMSG _IOWR('U', 0x22, struct usb_ctrlrequest )
 
 
 #define SCN_MAX_MNR 16		/* We're allocated 16 minors */
diff -Nur linux-2.4.19.old/drivers/usb/se401.c linux-2.4.19/drivers/usb/se401.c
--- linux-2.4.19.old/drivers/usb/se401.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/se401.c	Mon Nov 25 12:27:01 2002
@@ -41,18 +41,12 @@
 #include <asm/semaphore.h>
 #include <linux/wrapper.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
-#define virt_to_page(arg)	MAP_NR(arg)
-#define vmalloc_32		vmalloc
-#endif
-
 #include "se401.h"
 
 static int flickerless=0;
 static int video_nr = -1;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 3, 0)
-static __devinitdata struct usb_device_id device_table [] = {
+static struct usb_device_id device_table [] = {
 	{ USB_DEVICE(0x03e8, 0x0004) },/* Endpoints/Aox SE401 */
 	{ USB_DEVICE(0x0471, 0x030b) },/* Philips PCVC665K */
 	{ USB_DEVICE(0x047d, 0x5001) },/* Kensington 67014 */
@@ -62,7 +56,6 @@
 };
 
 MODULE_DEVICE_TABLE(usb, device_table);
-#endif
 
 MODULE_AUTHOR("Jeroen Vreeken <pe1rxq@amsat.org>");
 MODULE_DESCRIPTION("SE401 USB Camera Driver");
@@ -80,54 +73,17 @@
  *
  * Memory management
  *
- * This is a shameless copy from the USB-cpia driver (linux kernel
- * version 2.3.29 or so, I have no idea what this code actually does ;).
- * Actually it seems to be a copy of a shameless copy of the bttv-driver.
- * Or that is a copy of a shameless copy of ... (To the powers: is there
- * no generic kernel-function to do this sort of stuff?)
- *
- * Yes, it was a shameless copy from the bttv-driver. IIRC, Alan says
- * there will be one, but apparentely not yet -jerdfelt
- *
- * So I copied it again for the ov511 driver -claudio
- *
- * Same for the se401 driver -Jeroen
  **********************************************************************/
 
-/* Given PGD from the address space's page table, return the kernel
- * virtual mapping of the physical memory mapped at ADR.
- */
-static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
-{
-	unsigned long ret = 0UL;
-	pmd_t *pmd;
-	pte_t *ptep, pte;
-
-	if (!pgd_none(*pgd)) {
-		pmd = pmd_offset(pgd, adr);
-		if (!pmd_none(*pmd)) {
-			ptep = pte_offset(pmd, adr);
-			pte = *ptep;
-			if (pte_present(pte)) {
-				ret = (unsigned long) page_address(pte_page(pte));
-				ret |= (adr & (PAGE_SIZE - 1));
-			}
-		}
-	}
-
-	return ret;
-}
-
 /* Here we want the physical address of the memory.
- * This is used when initializing the contents of the
- * area and marking the pages as reserved.
+ * This is used when initializing the contents of the area.
  */
 static inline unsigned long kvirt_to_pa(unsigned long adr)
 {
-	unsigned long va, kva, ret;
+	unsigned long kva, ret;
 
-	va = VMALLOC_VMADDR(adr);
-	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
 	ret = __pa(kva);
 	return ret;
 }
@@ -135,12 +91,9 @@
 static void *rvmalloc(unsigned long size)
 {
 	void *mem;
-	unsigned long adr, page;
-
-	/* Round it off to PAGE_SIZE */
-	size += (PAGE_SIZE - 1);
-	size &= ~(PAGE_SIZE - 1);
+	unsigned long adr;
 
+	size = PAGE_ALIGN(size);
 	mem = vmalloc_32(size);
 	if (!mem)
 		return NULL;
@@ -148,13 +101,9 @@
 	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
 	adr = (unsigned long) mem;
 	while (size > 0) {
-		page = kvirt_to_pa(adr);
-		mem_map_reserve(virt_to_page(__va(page)));
+		mem_map_reserve(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
-		if (size > PAGE_SIZE)
-			size -= PAGE_SIZE;
-		else
-			size = 0;
+		size -= PAGE_SIZE;
 	}
 
 	return mem;
@@ -162,23 +111,16 @@
 
 static void rvfree(void *mem, unsigned long size)
 {
-	unsigned long adr, page;
+	unsigned long adr;
 
 	if (!mem)
 		return;
 
-	size += (PAGE_SIZE - 1);
-	size &= ~(PAGE_SIZE - 1);
-
-	adr=(unsigned long) mem;
-	while (size > 0) {
-		page = kvirt_to_pa(adr);
-		mem_map_unreserve(virt_to_page(__va(page)));
+	adr = (unsigned long) mem;
+	while ((long) size > 0) {
+		mem_map_unreserve(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
-		if (size > PAGE_SIZE)
-			size -= PAGE_SIZE;
-		else
-			size = 0;
+		size -= PAGE_SIZE;
 	}
 	vfree(mem);
 }
@@ -610,7 +552,7 @@
 */
 static int se401_start_stream(struct usb_se401 *se401)
 {
-	urb_t *urb;
+	struct urb *urb;
 	int err=0, i;
 	se401->streaming=1;
 
@@ -704,7 +646,7 @@
 		return 0;
 
 	/* Check for a valid mode */
-	if (!width || !height)
+	if (width <= 0 || height <= 0)
 		return 1;
 	if ((width & 1) || (height & 1))
 		return 1;
@@ -738,7 +680,8 @@
 static inline void enhance_picture(unsigned char *frame, int len)
 {
 	while (len--) {
-		*frame++=(((*frame^255)*(*frame^255))/255)^255;
+		*frame=(((*frame^255)*(*frame^255))/255)^255;
+		frame++;
 	}
 }
 
@@ -972,7 +915,8 @@
 		/* Fix the top line */
 		framedata+=linelength;
 		for (i=0; i<linelength; i++) {
-			*--framedata=*(framedata+linelength);
+			framedata--;
+			*framedata=*(framedata+linelength);
 		}
 		/* Fix the left side (green is already present) */
 		for (i=0; i<se401->cheight; i++) {
@@ -1425,7 +1369,13 @@
 
 	se401->sizes=cp[4]+cp[5]*256;
 	se401->width=kmalloc(se401->sizes*sizeof(int), GFP_KERNEL);
+	if (!se401->width)
+		return 1;
 	se401->height=kmalloc(se401->sizes*sizeof(int), GFP_KERNEL);
+	if (!se401->height) {
+		kfree(se401->width);
+		return 1;
+	}
 	for (i=0; i<se401->sizes; i++) {
 		    se401->width[i]=cp[6+i*4+0]+cp[6+i*4+1]*256;
 		    se401->height[i]=cp[6+i*4+2]+cp[6+i*4+3]*256;
@@ -1491,12 +1441,8 @@
         return 0;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
-static void* se401_probe(struct usb_device *dev, unsigned int ifnum)
-#else
-static void* __devinit se401_probe(struct usb_device *dev, unsigned int ifnum,
+static void* se401_probe(struct usb_device *dev, unsigned int ifnum,
 	const struct usb_device_id *id)
-#endif
 {
         struct usb_interface_descriptor *interface;
         struct usb_se401 *se401;
@@ -1625,9 +1571,7 @@
 
 static struct usb_driver se401_driver = {
         name:		"se401",
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 3, 0)
         id_table:	device_table,
-#endif
 	probe:		se401_probe,
         disconnect:	se401_disconnect
 };
diff -Nur linux-2.4.19.old/drivers/usb/se401.h linux-2.4.19/drivers/usb/se401.h
--- linux-2.4.19.old/drivers/usb/se401.h	Fri Sep  7 19:59:04 2001
+++ linux-2.4.19/drivers/usb/se401.h	Mon Nov 25 12:27:07 2002
@@ -10,7 +10,7 @@
 
 #ifdef se401_DEBUG
 #  define PDEBUG(level, fmt, args...) \
-if (debug >= level) info("[" __PRETTY_FUNCTION__ ":%d] " fmt, __LINE__ , ## args)
+if (debug >= level) info("[%s:%d] " fmt, __PRETTY_FUNCTION__, __LINE__ , ## args)
 #else
 #  define PDEBUG(level, fmt, args...) do {} while(0)
 #endif
@@ -197,8 +197,8 @@
 
 	char *fbuf;		/* Videodev buffer area */
 
-	urb_t *urb[SE401_NUMSBUF];
-	urb_t *inturb;
+	struct urb *urb[SE401_NUMSBUF];
+	struct urb *inturb;
 	
 	int button;
 	int buttonpressed;
diff -Nur linux-2.4.19.old/drivers/usb/serial/Config.in linux-2.4.19/drivers/usb/serial/Config.in
--- linux-2.4.19.old/drivers/usb/serial/Config.in	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/Config.in	Mon Nov 25 12:27:07 2002
@@ -5,34 +5,39 @@
 comment 'USB Serial Converter support'
 
 dep_tristate 'USB Serial Converter support' CONFIG_USB_SERIAL $CONFIG_USB
-if [ "$CONFIG_USB_SERIAL" = "y" ]; then
-  dep_mbool '  USB Serial Converter verbose debug' CONFIG_USB_SERIAL_DEBUG $CONFIG_USB_SERIAL
+if [ "$CONFIG_USB_SERIAL" != "n" ]; then
+   dep_bool '  USB Serial Converter verbose debug' CONFIG_USB_SERIAL_DEBUG $CONFIG_USB_SERIAL
+   dep_mbool '  USB Generic Serial Driver' CONFIG_USB_SERIAL_GENERIC $CONFIG_USB_SERIAL
+   dep_tristate '  USB Belkin and Peracom Single Port Serial Driver' CONFIG_USB_SERIAL_BELKIN $CONFIG_USB_SERIAL
+   dep_tristate '  USB ConnectTech WhiteHEAT Serial Driver' CONFIG_USB_SERIAL_WHITEHEAT $CONFIG_USB_SERIAL
+   dep_tristate '  USB Digi International AccelePort USB Serial Driver' CONFIG_USB_SERIAL_DIGI_ACCELEPORT $CONFIG_USB_SERIAL
+   dep_tristate '  USB Empeg empeg-car Mark I/II Driver' CONFIG_USB_SERIAL_EMPEG $CONFIG_USB_SERIAL
+   dep_tristate '  USB FTDI Single Port Serial Driver' CONFIG_USB_SERIAL_FTDI_SIO $CONFIG_USB_SERIAL
+   dep_tristate '  USB Handspring Visor / Palm m50x / Sony Clie Driver' CONFIG_USB_SERIAL_VISOR $CONFIG_USB_SERIAL
+   dep_tristate '  USB Compaq iPAQ / HP Jornada / Casio EM500 Driver' CONFIG_USB_SERIAL_IPAQ $CONFIG_USB_SERIAL
+   dep_tristate '  USB IR Dongle Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_IR $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
+   dep_tristate '  USB Inside Out Edgeport Serial Driver' CONFIG_USB_SERIAL_EDGEPORT $CONFIG_USB_SERIAL
+   dep_tristate '  USB Inside Out Edgeport Serial Driver (TI devices)' CONFIG_USB_SERIAL_EDGEPORT_TI $CONFIG_USB_SERIAL
+   dep_tristate '  USB Keyspan PDA Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_KEYSPAN_PDA $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
+   dep_tristate '  USB Keyspan USA-xxx Serial Driver' CONFIG_USB_SERIAL_KEYSPAN $CONFIG_USB_SERIAL
+   if [ "$CONFIG_USB_SERIAL_KEYSPAN" != "n" ]; then
+      bool '    USB Keyspan USA-28 Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA28
+      bool '    USB Keyspan USA-28X Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA28X
+      bool '    USB Keyspan USA-28XA Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA28XA
+      bool '    USB Keyspan USA-28XB Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA28XB
+      bool '    USB Keyspan USA-19 Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA19
+      bool '    USB Keyspan USA-18X Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA18X
+      bool '    USB Keyspan USA-19W Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA19W
+      bool '    USB Keyspan USA-19QW Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA19QW
+      bool '    USB Keyspan USA-19QI Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA19QI
+      bool '    USB Keyspan USA-49W Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA49W
+   fi
+   dep_tristate '  USB MCT Single Port Serial Driver' CONFIG_USB_SERIAL_MCT_U232 $CONFIG_USB_SERIAL
+   dep_tristate '  USB KL5KUSB105 (Palmconnect) Driver' CONFIG_USB_SERIAL_KLSI $CONFIG_USB_SERIAL
+   dep_tristate '  USB Prolific 2303 Single Port Serial Driver' CONFIG_USB_SERIAL_PL2303 $CONFIG_USB_SERIAL
+   dep_tristate '  USB REINER SCT cyberJack pinpad/e-com chipcard reader (EXPERIMENTAL)' CONFIG_USB_SERIAL_CYBERJACK $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
+   dep_tristate '  USB Xircom / Entregra Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_XIRCOM $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
+   dep_tristate '  USB ZyXEL omni.net LCD Plus Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_OMNINET $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
 fi
-dep_mbool '  USB Generic Serial Driver' CONFIG_USB_SERIAL_GENERIC $CONFIG_USB_SERIAL
-dep_tristate '  USB Belkin and Peracom Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_BELKIN $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB ConnectTech WhiteHEAT Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_WHITEHEAT $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB Digi International AccelePort USB Serial Driver' CONFIG_USB_SERIAL_DIGI_ACCELEPORT $CONFIG_USB_SERIAL
-dep_tristate '  USB Empeg empeg-car Mark I/II Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_EMPEG $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB FTDI Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_FTDI_SIO $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB Handspring Visor / Palm m50x / Sony Clie Driver' CONFIG_USB_SERIAL_VISOR $CONFIG_USB_SERIAL
-dep_tristate '  USB Compaq iPAQ / HP Jornada / Casio EM500 Driver' CONFIG_USB_SERIAL_IPAQ $CONFIG_USB_SERIAL
-dep_tristate '  USB IR Dongle Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_IR $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB Inside Out Edgeport Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_EDGEPORT $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB Keyspan PDA Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_KEYSPAN_PDA $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB Keyspan USA-xxx Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_KEYSPAN $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-   dep_mbool '    USB Keyspan USA-28 Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA28 $CONFIG_USB_SERIAL_KEYSPAN
-   dep_mbool '    USB Keyspan USA-28X Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA28X $CONFIG_USB_SERIAL_KEYSPAN
-   dep_mbool '    USB Keyspan USA-28XA Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA28XA $CONFIG_USB_SERIAL_KEYSPAN
-   dep_mbool '    USB Keyspan USA-28XB Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA28XB $CONFIG_USB_SERIAL_KEYSPAN
-   dep_mbool '    USB Keyspan USA-19 Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA19 $CONFIG_USB_SERIAL_KEYSPAN
-   dep_mbool '    USB Keyspan USA-18X Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA18X $CONFIG_USB_SERIAL_KEYSPAN
-   dep_mbool '    USB Keyspan USA-19W Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA19W $CONFIG_USB_SERIAL_KEYSPAN
-   dep_mbool '    USB Keyspan USA-49W Firmware' CONFIG_USB_SERIAL_KEYSPAN_USA49W $CONFIG_USB_SERIAL_KEYSPAN
-dep_tristate '  USB MCT Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_MCT_U232 $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB KL5KUSB105 (Palmconnect) Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_KLSI $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB Prolific 2303 Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_PL2303 $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB REINER SCT cyberJack pinpad/e-com chipcard reader (EXPERIMENTAL)' CONFIG_USB_SERIAL_CYBERJACK $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB Xircom / Entregra Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_XIRCOM $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
-dep_tristate '  USB ZyXEL omni.net LCD Plus Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_OMNINET $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
 
 endmenu
diff -Nur linux-2.4.19.old/drivers/usb/serial/Makefile linux-2.4.19/drivers/usb/serial/Makefile
--- linux-2.4.19.old/drivers/usb/serial/Makefile	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/serial/Makefile	Mon Nov 25 12:27:07 2002
@@ -20,6 +20,7 @@
 obj-$(CONFIG_USB_SERIAL_EMPEG)			+= empeg.o
 obj-$(CONFIG_USB_SERIAL_MCT_U232)		+= mct_u232.o
 obj-$(CONFIG_USB_SERIAL_EDGEPORT)		+= io_edgeport.o
+obj-$(CONFIG_USB_SERIAL_EDGEPORT_TI)		+= io_ti.o
 obj-$(CONFIG_USB_SERIAL_PL2303)			+= pl2303.o
 obj-$(CONFIG_USB_SERIAL_CYBERJACK)		+= cyberjack.o
 obj-$(CONFIG_USB_SERIAL_IR)			+= ir-usb.o
diff -Nur linux-2.4.19.old/drivers/usb/serial/belkin_sa.c linux-2.4.19/drivers/usb/serial/belkin_sa.c
--- linux-2.4.19.old/drivers/usb/serial/belkin_sa.c	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/serial/belkin_sa.c	Mon Nov 25 12:27:08 2002
@@ -1,8 +1,8 @@
 /*
  * Belkin USB Serial Adapter Driver
  *
- *  Copyright (C) 2000
- *      William Greathouse (wgreathouse@smva.com)
+ *  Copyright (C) 2000		William Greathouse (wgreathouse@smva.com)
+ *  Copyright (C) 2000-2001 	Greg Kroah-Hartman (greg@kroah.com)
  *
  *  This program is largely derived from work by the linux-usb group
  *  and associated source files.  Please see the usb/serial files for
@@ -24,6 +24,9 @@
  * -- Add support for flush commands
  * -- Add everything that is missing :)
  *
+ * 27-Nov-2001 gkh
+ * 	compressed all the differnent device entries into 1.
+ *
  * 30-May-2001 gkh
  *	switched from using spinlock to a semaphore, which fixes lots of problems.
  *
@@ -62,18 +65,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -88,7 +88,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.1"
+#define DRIVER_VERSION "v1.2"
 #define DRIVER_AUTHOR "William Greathouse <wgreathouse@smva.com>"
 #define DRIVER_DESC "USB Belkin Serial converter driver"
 
@@ -103,146 +103,35 @@
 static void belkin_sa_break_ctl		(struct usb_serial_port *port, int break_state );
 
 
-static __devinitdata struct usb_device_id id_table_combined [] = {
+static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(BELKIN_SA_VID, BELKIN_SA_PID) },
 	{ USB_DEVICE(BELKIN_OLD_VID, BELKIN_OLD_PID) },
 	{ USB_DEVICE(PERACOM_VID, PERACOM_PID) },
 	{ USB_DEVICE(GOHUBS_VID, GOHUBS_PID) },
+	{ USB_DEVICE(GOHUBS_VID, HANDYLINK_PID) },
 	{ USB_DEVICE(BELKIN_DOCKSTATION_VID, BELKIN_DOCKSTATION_PID) },
 	{ }							/* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id belkin_dockstation_table [] = {
-	{ USB_DEVICE(BELKIN_DOCKSTATION_VID, BELKIN_DOCKSTATION_PID) },
-	{ }							/* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id belkin_sa_table [] = {
-	{ USB_DEVICE(BELKIN_SA_VID, BELKIN_SA_PID) },
-	{ }							/* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id belkin_old_table [] = {
-	{ USB_DEVICE(BELKIN_OLD_VID, BELKIN_OLD_PID) },
-	{ }							/* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id peracom_table [] = {
-	{ USB_DEVICE(PERACOM_VID, PERACOM_PID) },
-	{ }							/* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id gocom232_table [] = {
-	{ USB_DEVICE(GOHUBS_VID, GOHUBS_PID) },
-	{ }							/* Terminating entry */
-};
-
 MODULE_DEVICE_TABLE (usb, id_table_combined);
 
-/* All of the device info needed for the Belkin dockstation serial converter */
-static struct usb_serial_device_type belkin_dockstation_device = {
-	name:			"Belkin F5U120-PC USB Serial Adapter",
-	id_table:		belkin_dockstation_table,		/* the Belkin F5U103 device */
-	needs_interrupt_in:	MUST_HAVE,			/* this device must have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,			/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,			/* this device must have a bulk out endpoint */
-	num_interrupt_in:	1,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			belkin_sa_open,
-	close:			belkin_sa_close,
-	read_int_callback:	belkin_sa_read_int_callback,	/* How we get the status info */
-	ioctl:			belkin_sa_ioctl,
-	set_termios:		belkin_sa_set_termios,
-	break_ctl:		belkin_sa_break_ctl,
-	startup:		belkin_sa_startup,
-	shutdown:		belkin_sa_shutdown,
-};
-
-/* All of the device info needed for the Belkin serial converter */
-static struct usb_serial_device_type belkin_sa_device = {
-	name:			"Belkin F5U103 USB Serial Adapter",
-	id_table:		belkin_sa_table,		/* the Belkin F5U103 device */
-	needs_interrupt_in:	MUST_HAVE,			/* this device must have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,			/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,			/* this device must have a bulk out endpoint */
-	num_interrupt_in:	1,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			belkin_sa_open,
-	close:			belkin_sa_close,
-	read_int_callback:	belkin_sa_read_int_callback,	/* How we get the status info */
-	ioctl:			belkin_sa_ioctl,
-	set_termios:		belkin_sa_set_termios,
-	break_ctl:		belkin_sa_break_ctl,
-	startup:		belkin_sa_startup,
-	shutdown:		belkin_sa_shutdown,
-};
-
-
-/* This driver also supports the "old" school Belkin single port adaptor */
-static struct usb_serial_device_type belkin_old_device = {
-	name:			"Belkin USB Serial Adapter",
-	id_table:		belkin_old_table,		/* the old Belkin device */
-	needs_interrupt_in:	MUST_HAVE,			/* this device must have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,			/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,			/* this device must have a bulk out endpoint */
-	num_interrupt_in:	1,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			belkin_sa_open,
-	close:			belkin_sa_close,
-	read_int_callback:	belkin_sa_read_int_callback,	/* How we get the status info */
-	ioctl:			belkin_sa_ioctl,
-	set_termios:		belkin_sa_set_termios,
-	break_ctl:		belkin_sa_break_ctl,
-	startup:		belkin_sa_startup,
-	shutdown:		belkin_sa_shutdown,
-};
-
-/* this driver also works for the Peracom single port adapter */
-static struct usb_serial_device_type peracom_device = {
-	name:			"Peracom single port USB Serial Adapter",
-	id_table:		peracom_table,			/* the Peracom device */
-	needs_interrupt_in:	MUST_HAVE,			/* this device must have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,			/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,			/* this device must have a bulk out endpoint */
-	num_interrupt_in:	1,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			belkin_sa_open,
-	close:			belkin_sa_close,
-	read_int_callback:	belkin_sa_read_int_callback,	/* How we get the status info */
-	ioctl:			belkin_sa_ioctl,
-	set_termios:		belkin_sa_set_termios,
-	break_ctl:		belkin_sa_break_ctl,
-	startup:		belkin_sa_startup,
-	shutdown:		belkin_sa_shutdown,
-};
-
-/* the GoHubs Go-COM232 device is the same as the Peracom single port adapter */
-static struct usb_serial_device_type gocom232_device = {
-	name:			"GO-COM232 USB Serial Converter",
-	id_table:		gocom232_table,			/* the GO-COM232 device */
-	needs_interrupt_in:	MUST_HAVE,			/* this device must have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,			/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,			/* this device must have a bulk out endpoint */
-	num_interrupt_in:	1,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			belkin_sa_open,
-	close:			belkin_sa_close,
-	read_int_callback:	belkin_sa_read_int_callback,	/* How we get the status info */
-	ioctl:			belkin_sa_ioctl,
-	set_termios:		belkin_sa_set_termios,
-	break_ctl:		belkin_sa_break_ctl,
-	startup:		belkin_sa_startup,
-	shutdown:		belkin_sa_shutdown,
+/* All of the device info needed for the serial converters */
+static struct usb_serial_device_type belkin_device = {
+	.owner =		THIS_MODULE,
+	.name =			"Belkin / Peracom / GoHubs USB Serial Adapter",
+	.id_table =		id_table_combined,
+	.num_interrupt_in =	1,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			belkin_sa_open,
+	.close =		belkin_sa_close,
+	.read_int_callback =	belkin_sa_read_int_callback,	/* How we get the status info */
+	.ioctl =		belkin_sa_ioctl,
+	.set_termios =		belkin_sa_set_termios,
+	.break_ctl =		belkin_sa_break_ctl,
+	.startup =		belkin_sa_startup,
+	.shutdown =		belkin_sa_shutdown,
 };
 
 
@@ -296,13 +185,10 @@
 {
 	int i;
 	
-	dbg (__FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 
 	/* stop reads and writes on all ports */
 	for (i=0; i < serial->num_ports; ++i) {
-		while (serial->port[i].open_count > 0) {
-			belkin_sa_close (&serial->port[i], NULL);
-		}
 		/* My special items, the standard routines free my urbs */
 		if (serial->port[i].private)
 			kfree(serial->port[i].private);
@@ -314,36 +200,25 @@
 {
 	int retval = 0;
 
-	dbg(__FUNCTION__" port %d", port->number);
+	dbg("%s port %d", __FUNCTION__, port->number);
 
-	down (&port->sem);
-	
-	++port->open_count;
-	MOD_INC_USE_COUNT;
-	
-	if (!port->active) {
-		port->active = 1;
-
-		/*Start reading from the device*/
-		/* TODO: Look at possibility of submitting mulitple URBs to device to
-		 *       enhance buffering.  Win trace shows 16 initial read URBs.
-		 */
-		port->read_urb->dev = port->serial->dev;
-		retval = usb_submit_urb(port->read_urb);
-		if (retval) {
-			err("usb_submit_urb(read bulk) failed");
-			goto exit;
-		}
-
-		port->interrupt_in_urb->dev = port->serial->dev;
-		retval = usb_submit_urb(port->interrupt_in_urb);
-		if (retval)
-			err(" usb_submit_urb(read int) failed");
+	/*Start reading from the device*/
+	/* TODO: Look at possibility of submitting mulitple URBs to device to
+	 *       enhance buffering.  Win trace shows 16 initial read URBs.
+	 */
+	port->read_urb->dev = port->serial->dev;
+	retval = usb_submit_urb(port->read_urb);
+	if (retval) {
+		err("usb_submit_urb(read bulk) failed");
+		goto exit;
 	}
-	
-exit:
-	up (&port->sem);
 
+	port->interrupt_in_urb->dev = port->serial->dev;
+	retval = usb_submit_urb(port->interrupt_in_urb);
+	if (retval)
+		err(" usb_submit_urb(read int) failed");
+
+exit:
 	return retval;
 } /* belkin_sa_open */
 
@@ -359,24 +234,14 @@
 	if (!serial)
 		return;
 
-	dbg(__FUNCTION__" port %d", port->number);
-
-	down (&port->sem);
-
-	--port->open_count;
+	dbg("%s port %d", __FUNCTION__, port->number);
 
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			/* shutdown our bulk reads and writes */
-			usb_unlink_urb (port->write_urb);
-			usb_unlink_urb (port->read_urb);
-			usb_unlink_urb (port->interrupt_in_urb);
-		}
-		port->active = 0;
+	if (serial->dev) {
+		/* shutdown our bulk reads and writes */
+		usb_unlink_urb (port->write_urb);
+		usb_unlink_urb (port->read_urb);
+		usb_unlink_urb (port->interrupt_in_urb);
 	}
-	
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
 } /* belkin_sa_close */
 
 
@@ -457,12 +322,31 @@
 {
 	struct usb_serial *serial = port->serial;
 	struct belkin_sa_private *priv = (struct belkin_sa_private *)port->private;
-	unsigned int iflag = port->tty->termios->c_iflag;
-	unsigned int cflag = port->tty->termios->c_cflag;
-	unsigned int old_iflag = old_termios->c_iflag;
-	unsigned int old_cflag = old_termios->c_cflag;
+	unsigned int iflag;
+	unsigned int cflag;
+	unsigned int old_iflag = 0;
+	unsigned int old_cflag = 0;
 	__u16 urb_value = 0; /* Will hold the new flags */
 	
+	if ((!port->tty) || (!port->tty->termios)) {
+		dbg ("%s - no tty or termios structure", __FUNCTION__);
+		return;
+	}
+
+	iflag = port->tty->termios->c_iflag;
+	cflag = port->tty->termios->c_cflag;
+
+	/* check that they really want us to change something */
+	if (old_termios) {
+		if ((cflag == old_termios->c_cflag) &&
+		    (RELEVANT_IFLAG(port->tty->termios->c_iflag) == RELEVANT_IFLAG(old_termios->c_iflag))) {
+			dbg("%s - nothing to change...", __FUNCTION__);
+			return;
+		}
+		old_iflag = old_termios->c_iflag;
+		old_cflag = old_termios->c_cflag;
+	}
+
 	/* Set the baud rate */
 	if( (cflag&CBAUD) != (old_cflag&CBAUD) ) {
 		/* reassert DTR and (maybe) RTS on transition from B0 */
@@ -642,11 +526,7 @@
 
 static int __init belkin_sa_init (void)
 {
-	usb_serial_register (&belkin_dockstation_device);
-	usb_serial_register (&belkin_sa_device);
-	usb_serial_register (&belkin_old_device);
-	usb_serial_register (&peracom_device);
-	usb_serial_register (&gocom232_device);
+	usb_serial_register (&belkin_device);
 	info(DRIVER_DESC " " DRIVER_VERSION);
 	return 0;
 }
@@ -654,11 +534,7 @@
 
 static void __exit belkin_sa_exit (void)
 {
-	usb_serial_deregister (&belkin_dockstation_device);
-	usb_serial_deregister (&belkin_sa_device);
-	usb_serial_deregister (&belkin_old_device);
-	usb_serial_deregister (&peracom_device);
-	usb_serial_deregister (&gocom232_device);
+	usb_serial_deregister (&belkin_device);
 }
 
 
diff -Nur linux-2.4.19.old/drivers/usb/serial/belkin_sa.h linux-2.4.19/drivers/usb/serial/belkin_sa.h
--- linux-2.4.19.old/drivers/usb/serial/belkin_sa.h	Mon Oct  1 22:45:43 2001
+++ linux-2.4.19/drivers/usb/serial/belkin_sa.h	Mon Nov 25 12:27:08 2002
@@ -47,6 +47,7 @@
 
 #define GOHUBS_VID	0x0921	/* GoHubs vendor id */
 #define GOHUBS_PID	0x1000	/* GoHubs single port serial converter's id (identical to the Peracom device) */
+#define HANDYLINK_PID	0x1200	/* HandyLink USB's id (identical to the Peracom device) */
 
 /* Vendor Request Interface */
 #define BELKIN_SA_SET_BAUDRATE_REQUEST	0  /* Set baud rate */
diff -Nur linux-2.4.19.old/drivers/usb/serial/cyberjack.c linux-2.4.19/drivers/usb/serial/cyberjack.c
--- linux-2.4.19.old/drivers/usb/serial/cyberjack.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/cyberjack.c	Mon Nov 25 12:27:08 2002
@@ -25,18 +25,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -69,7 +66,7 @@
 static void cyberjack_read_bulk_callback (struct urb *urb);
 static void cyberjack_write_bulk_callback (struct urb *urb);
 
-static __devinitdata struct usb_device_id id_table [] = {
+static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(CYBERJACK_VENDOR_ID, CYBERJACK_PRODUCT_ID) },
 	{ }			/* Terminating entry */
 };
@@ -77,23 +74,21 @@
 MODULE_DEVICE_TABLE (usb, id_table);
 
 static struct usb_serial_device_type cyberjack_device = {
-	name:			"Reiner SCT Cyberjack USB card reader",
-	id_table:		id_table,
-	needs_interrupt_in:	MUST_HAVE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	1,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	startup:		cyberjack_startup,
-	shutdown:		cyberjack_shutdown,
-	open:			cyberjack_open,
-	close:			cyberjack_close,
-	write:			cyberjack_write,
-	read_int_callback:	cyberjack_read_int_callback,
-	read_bulk_callback:	cyberjack_read_bulk_callback,
-	write_bulk_callback:	cyberjack_write_bulk_callback,
+	.owner =		THIS_MODULE,
+	.name =			"Reiner SCT Cyberjack USB card reader",
+	.id_table =		id_table,
+	.num_interrupt_in =	1,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.startup =		cyberjack_startup,
+	.shutdown =		cyberjack_shutdown,
+	.open =			cyberjack_open,
+	.close =		cyberjack_close,
+	.write =		cyberjack_write,
+	.read_int_callback =	cyberjack_read_int_callback,
+	.read_bulk_callback =	cyberjack_read_bulk_callback,
+	.write_bulk_callback =	cyberjack_write_bulk_callback,
 };
 
 struct cyberjack_private {
@@ -108,7 +103,7 @@
 {
 	struct cyberjack_private *priv;
 
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	/* allocate the private data structure */
 	serial->port->private = kmalloc(sizeof(struct cyberjack_private), GFP_KERNEL);
@@ -130,13 +125,9 @@
 {
 	int i;
 	
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	/* stop reads and writes on all ports */
 	for (i=0; i < serial->num_ports; ++i) {
-		while (serial->port[i].open_count > 0) {
-			cyberjack_close (&serial->port[i], NULL);
-		}
 		/* My special items, the standard routines free my urbs */
 		if (serial->port[i].private)
 			kfree(serial->port[i].private);
@@ -151,66 +142,43 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return -ENODEV;
 
-	MOD_INC_USE_COUNT;
-
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
-
-	++port->open_count;
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	if (!port->active) {
-		port->active = 1;
-		/* force low_latency on so that our tty_push actually forces
-		 * the data through, otherwise it is scheduled, and with high
-		 * data rates (like with OHCI) data can get lost.
-		 */
-		port->tty->low_latency = 1;
-
-		priv = (struct cyberjack_private *)port->private;
-		priv->rdtodo = 0;
-		priv->wrfilled = 0;
-		priv->wrsent = 0;
+	/* force low_latency on so that our tty_push actually forces
+	 * the data through, otherwise it is scheduled, and with high
+	 * data rates (like with OHCI) data can get lost.
+	 */
+	port->tty->low_latency = 1;
 
-		/* shutdown any bulk reads that might be going on */
-		usb_unlink_urb (port->write_urb);
-		usb_unlink_urb (port->read_urb);
-		usb_unlink_urb (port->interrupt_in_urb);
-
-		port->interrupt_in_urb->dev = port->serial->dev;
-		result = usb_submit_urb(port->interrupt_in_urb);
-		if (result)
-			err(" usb_submit_urb(read int) failed");
-		dbg(__FUNCTION__ " - usb_submit_urb(int urb)");
-	}
+	priv = (struct cyberjack_private *)port->private;
+	priv->rdtodo = 0;
+	priv->wrfilled = 0;
+	priv->wrsent = 0;
 
-	up (&port->sem);
+	/* shutdown any bulk reads that might be going on */
+	usb_unlink_urb (port->write_urb);
+	usb_unlink_urb (port->read_urb);
+	usb_unlink_urb (port->interrupt_in_urb);
+
+	port->interrupt_in_urb->dev = port->serial->dev;
+	result = usb_submit_urb(port->interrupt_in_urb);
+	if (result)
+		err(" usb_submit_urb(read int) failed");
+	dbg("%s - usb_submit_urb(int urb)", __FUNCTION__);
 
 	return result;
 }
 
 static void cyberjack_close (struct usb_serial_port *port, struct file *filp)
 {
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
-
-	--port->open_count;
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	if (port->open_count <= 0) {
-		if (port->serial->dev) {
-			/* shutdown any bulk reads that might be going on */
-			usb_unlink_urb (port->write_urb);
-			usb_unlink_urb (port->read_urb);
-			usb_unlink_urb (port->interrupt_in_urb);
-		}
-
-		port->active = 0;
-		port->open_count = 0;
+	if (port->serial->dev) {
+		/* shutdown any bulk reads that might be going on */
+		usb_unlink_urb (port->write_urb);
+		usb_unlink_urb (port->read_urb);
+		usb_unlink_urb (port->interrupt_in_urb);
 	}
-
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
 }
 
 static int cyberjack_write (struct usb_serial_port *port, int from_user, const unsigned char *buf, int count)
@@ -220,32 +188,28 @@
 	int result;
 	int wrexpected;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-	dbg(__FUNCTION__ " - from_user %d", from_user);
+	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - from_user %d", __FUNCTION__, from_user);
 
 	if (count == 0) {
-		dbg(__FUNCTION__ " - write request of 0 bytes");
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
 		return (0);
 	}
 
 	if (port->write_urb->status == -EINPROGRESS) {
-		dbg (__FUNCTION__ " - already writing");
+		dbg("%s - already writing", __FUNCTION__);
 		return (0);
 	}
 
-	down (&port->sem);
-
 	if( (count+priv->wrfilled)>sizeof(priv->wrbuf) ) {
 		/* To much data  for buffer. Reset buffer. */
 		priv->wrfilled=0;
-		up (&port->sem);
 		return (0);
 	}
 
 	/* Copy data */
 	if (from_user) {
 		if (copy_from_user(priv->wrbuf+priv->wrfilled, buf, count)) {
-			up (&port->sem);
 			return -EFAULT;
 		}
 	} else {
@@ -257,7 +221,7 @@
 
 	if( priv->wrfilled >= 3 ) {
 		wrexpected = ((int)priv->wrbuf[2]<<8)+priv->wrbuf[1]+3;
-		dbg(__FUNCTION__ " - expected data: %d", wrexpected);
+		dbg("%s - expected data: %d", __FUNCTION__, wrexpected);
 	} else {
 		wrexpected = sizeof(priv->wrbuf);
 	}
@@ -266,7 +230,7 @@
 		/* We have enough data to begin transmission */
 		int length;
 
-		dbg(__FUNCTION__ " - transmitting data (frame 1)");
+		dbg("%s - transmitting data (frame 1)", __FUNCTION__);
 		length = (wrexpected > port->bulk_out_size) ? port->bulk_out_size : wrexpected;
 
 		memcpy (port->write_urb->transfer_buffer, priv->wrbuf, length );
@@ -284,26 +248,24 @@
 		/* send the data out the bulk port */
 		result = usb_submit_urb(port->write_urb);
 		if (result) {
-			err(__FUNCTION__ " - failed submitting write urb, error %d", result);
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 			/* Throw away data. No better idea what to do with it. */
 			priv->wrfilled=0;
 			priv->wrsent=0;
-			up (&port->sem);
 			return 0;
 		}
 
-		dbg(__FUNCTION__ " - priv->wrsent=%d",priv->wrsent);
-		dbg(__FUNCTION__ " - priv->wrfilled=%d",priv->wrfilled);
+		dbg("%s - priv->wrsent=%d", __FUNCTION__,priv->wrsent);
+		dbg("%s - priv->wrfilled=%d", __FUNCTION__,priv->wrfilled);
 
 		if( priv->wrsent>=priv->wrfilled ) {
-			dbg(__FUNCTION__ " - buffer cleaned");
+			dbg("%s - buffer cleaned", __FUNCTION__);
 			memset( priv->wrbuf, 0, sizeof(priv->wrbuf) );
 			priv->wrfilled=0;
 			priv->wrsent=0;
 		}
 	}
 
-	up (&port->sem);
 	return (count);
 } 
 
@@ -316,7 +278,7 @@
 
 	if (port_paranoia_check (port, __FUNCTION__)) return;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* the urb might have been killed. */
 	if (urb->status)
@@ -349,14 +311,14 @@
 		/* "+=" is probably more fault tollerant than "=" */
 		priv->rdtodo += size;
 
-		dbg(__FUNCTION__ " - rdtodo: %d", priv->rdtodo);
+		dbg("%s - rdtodo: %d", __FUNCTION__, priv->rdtodo);
 
 		if( !old_rdtodo ) {
 			port->read_urb->dev = port->serial->dev;
 			result = usb_submit_urb(port->read_urb);
 			if( result )
-				err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
-			dbg(__FUNCTION__ " - usb_submit_urb(read urb)");
+				err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
+			dbg("%s - usb_submit_urb(read urb)", __FUNCTION__);
 		}
 	}
 }
@@ -371,16 +333,16 @@
 	int i;
 	int result;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
 		usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
-		dbg(__FUNCTION__ " - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -404,15 +366,15 @@
 	/* Just to be sure */
 	if( priv->rdtodo<0 ) priv->rdtodo=0;
 
-	dbg(__FUNCTION__ " - rdtodo: %d", priv->rdtodo);
+	dbg("%s - rdtodo: %d", __FUNCTION__, priv->rdtodo);
 
 	/* Continue to read if we have still urbs to do. */
 	if( priv->rdtodo /* || (urb->actual_length==port->bulk_in_endpointAddress)*/ ) {
 		port->read_urb->dev = port->serial->dev;
 		result = usb_submit_urb(port->read_urb);
 		if (result)
-			err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
-		dbg(__FUNCTION__ " - usb_submit_urb(read urb)");
+			err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
+		dbg("%s - usb_submit_urb(read urb)", __FUNCTION__);
 	}
 }
 
@@ -422,15 +384,15 @@
 	struct cyberjack_private *priv = (struct cyberjack_private *)port->private;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -439,13 +401,11 @@
 		int length, blksize, result;
 
 		if (port->write_urb->status == -EINPROGRESS) {
-			dbg (__FUNCTION__ " - already writing");
+			dbg("%s - already writing", __FUNCTION__);
 			return;
 		}
 
-		down (&port->sem);
-
-		dbg(__FUNCTION__ " - transmitting data (frame n)");
+		dbg("%s - transmitting data (frame n)", __FUNCTION__);
 
 		length = ((priv->wrfilled - priv->wrsent) > port->bulk_out_size) ?
 			port->bulk_out_size : (priv->wrfilled - priv->wrsent);
@@ -466,29 +426,27 @@
 		/* send the data out the bulk port */
 		result = usb_submit_urb(port->write_urb);
 		if (result) {
-			err(__FUNCTION__ " - failed submitting write urb, error %d", result);
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 			/* Throw away data. No better idea what to do with it. */
 			priv->wrfilled=0;
 			priv->wrsent=0;
-			up (&port->sem);
 			queue_task(&port->tqueue, &tq_immediate);
 			mark_bh(IMMEDIATE_BH);
 			return;
 		}
 
-		dbg(__FUNCTION__ " - priv->wrsent=%d",priv->wrsent);
-		dbg(__FUNCTION__ " - priv->wrfilled=%d",priv->wrfilled);
+		dbg("%s - priv->wrsent=%d", __FUNCTION__,priv->wrsent);
+		dbg("%s - priv->wrfilled=%d", __FUNCTION__,priv->wrfilled);
 
 		blksize = ((int)priv->wrbuf[2]<<8)+priv->wrbuf[1]+3;
 
 		if( (priv->wrsent>=priv->wrfilled) || (priv->wrsent>=blksize) ) {
-			dbg(__FUNCTION__ " - buffer cleaned");
+			dbg("%s - buffer cleaned", __FUNCTION__);
 			memset( priv->wrbuf, 0, sizeof(priv->wrbuf) );
 			priv->wrfilled=0;
 			priv->wrsent=0;
 		}
 
-		up (&port->sem);
 		queue_task(&port->tqueue, &tq_immediate);
 		mark_bh(IMMEDIATE_BH);
 		return;
diff -Nur linux-2.4.19.old/drivers/usb/serial/digi_acceleport.c linux-2.4.19/drivers/usb/serial/digi_acceleport.c
--- linux-2.4.19.old/drivers/usb/serial/digi_acceleport.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/digi_acceleport.c	Mon Nov 25 12:27:08 2002
@@ -14,6 +14,10 @@
 *  Peter Berger (pberger@brimson.com)
 *  Al Borchers (borchers@steinerpoint.com)
 * 
+* (12/03/2001) gkh
+*	switched to using port->open_count instead of private version.
+*	Removed port->active
+*
 * (04/08/2001) gb
 *	Identify version on module load.
 *
@@ -231,19 +235,16 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/tqueue.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -411,14 +412,14 @@
 
 /* Structures */
 
-typedef struct digi_serial {
+struct digi_serial {
 	spinlock_t ds_serial_lock;
 	struct usb_serial_port *ds_oob_port;	/* out-of-band port */
 	int ds_oob_port_num;			/* index of out-of-band port */
 	int ds_device_started;
-} digi_serial_t;
+};
 
-typedef struct digi_port {
+struct digi_port {
 	spinlock_t dp_port_lock;
 	int dp_port_num;
 	int dp_out_buf_len;
@@ -429,7 +430,6 @@
 	int dp_write_urb_in_use;
 	unsigned int dp_modem_signals;
 	wait_queue_head_t dp_modem_change_wait;
-	int dp_open_count;			/* inc on open, dec on close */
 	int dp_transmit_idle;
 	wait_queue_head_t dp_transmit_idle_wait;
 	int dp_throttled;
@@ -438,7 +438,7 @@
 	int dp_in_close;			/* close in progress */
 	wait_queue_head_t dp_close_wait;	/* wait queue for close */
 	struct tq_struct dp_wakeup_task;
-} digi_port_t;
+};
 
 
 /* Local Function Declarations */
@@ -483,12 +483,12 @@
 	{ }						/* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id id_table_2 [] = {
+static struct usb_device_id id_table_2 [] = {
 	{ USB_DEVICE(DIGI_VENDOR_ID, DIGI_2_ID) },
 	{ }						/* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id id_table_4 [] = {
+static struct usb_device_id id_table_4 [] = {
 	{ USB_DEVICE(DIGI_VENDOR_ID, DIGI_4_ID) },
 	{ }						/* Terminating entry */
 };
@@ -498,55 +498,51 @@
 /* device info needed for the Digi serial converter */
 
 static struct usb_serial_device_type digi_acceleport_2_device = {
-	name:				"Digi USB",
-	id_table:			id_table_2,
-	needs_interrupt_in:		DONT_CARE,
-	needs_bulk_in:			MUST_HAVE,
-	needs_bulk_out:			MUST_HAVE,
-	num_interrupt_in:		0,
-	num_bulk_in:			4,
-	num_bulk_out:			4,
-	num_ports:			3,
-	open:				digi_open,
-	close:				digi_close,
-	write:				digi_write,
-	write_room:			digi_write_room,
-	write_bulk_callback: 		digi_write_bulk_callback,
-	read_bulk_callback:		digi_read_bulk_callback,
-	chars_in_buffer:		digi_chars_in_buffer,
-	throttle:			digi_rx_throttle,
-	unthrottle:			digi_rx_unthrottle,
-	ioctl:				digi_ioctl,
-	set_termios:			digi_set_termios,
-	break_ctl:			digi_break_ctl,
-	startup:			digi_startup,
-	shutdown:			digi_shutdown,
+	.owner =			THIS_MODULE,
+	.name =				"Digi USB",
+	.id_table =			id_table_2,
+	.num_interrupt_in =		0,
+	.num_bulk_in =			4,
+	.num_bulk_out =			4,
+	.num_ports =			3,
+	.open =				digi_open,
+	.close =			digi_close,
+	.write =			digi_write,
+	.write_room =			digi_write_room,
+	.write_bulk_callback = 		digi_write_bulk_callback,
+	.read_bulk_callback =		digi_read_bulk_callback,
+	.chars_in_buffer =		digi_chars_in_buffer,
+	.throttle =			digi_rx_throttle,
+	.unthrottle =			digi_rx_unthrottle,
+	.ioctl =			digi_ioctl,
+	.set_termios =			digi_set_termios,
+	.break_ctl =			digi_break_ctl,
+	.startup =			digi_startup,
+	.shutdown =			digi_shutdown,
 };
 
 static struct usb_serial_device_type digi_acceleport_4_device = {
-	name:				"Digi USB",
-	id_table:			id_table_4,
-	needs_interrupt_in:		DONT_CARE,
-	needs_bulk_in:			MUST_HAVE,
-	needs_bulk_out:			MUST_HAVE,
-	num_interrupt_in:		0,
-	num_bulk_in:			5,
-	num_bulk_out:			5,
-	num_ports:			4,
-	open:				digi_open,
-	close:				digi_close,
-	write:				digi_write,
-	write_room:			digi_write_room,
-	write_bulk_callback: 		digi_write_bulk_callback,
-	read_bulk_callback:		digi_read_bulk_callback,
-	chars_in_buffer:		digi_chars_in_buffer,
-	throttle:			digi_rx_throttle,
-	unthrottle:			digi_rx_unthrottle,
-	ioctl:				digi_ioctl,
-	set_termios:			digi_set_termios,
-	break_ctl:			digi_break_ctl,
-	startup:			digi_startup,
-	shutdown:			digi_shutdown,
+	.owner =			THIS_MODULE,
+	.name =				"Digi USB",
+	.id_table =			id_table_4,
+	.num_interrupt_in =		0,
+	.num_bulk_in =			5,
+	.num_bulk_out =			5,
+	.num_ports =			4,
+	.open =				digi_open,
+	.close =			digi_close,
+	.write =			digi_write,
+	.write_room =			digi_write_room,
+	.write_bulk_callback = 		digi_write_bulk_callback,
+	.read_bulk_callback =		digi_read_bulk_callback,
+	.chars_in_buffer =		digi_chars_in_buffer,
+	.throttle =			digi_rx_throttle,
+	.unthrottle =			digi_rx_unthrottle,
+	.ioctl =			digi_ioctl,
+	.set_termios =			digi_set_termios,
+	.break_ctl =			digi_break_ctl,
+	.startup =			digi_startup,
+	.shutdown =			digi_shutdown,
 };
 
 
@@ -600,13 +596,12 @@
 {
 
 	unsigned long flags;
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 
 
 	spin_lock_irqsave( &priv->dp_port_lock, flags );
 	digi_wakeup_write( port );
 	spin_unlock_irqrestore( &priv->dp_port_lock, flags );
-	MOD_DEC_USE_COUNT;
 }
 
 static void digi_wakeup_write( struct usb_serial_port *port )
@@ -647,8 +642,8 @@
 
 	int ret = 0;
 	int len;
-	struct usb_serial_port *oob_port = (struct usb_serial_port *)((digi_serial_t *)port->serial->private)->ds_oob_port;
-	digi_port_t *oob_priv = (digi_port_t *)oob_port->private;
+	struct usb_serial_port *oob_port = (struct usb_serial_port *)((struct digi_serial *)port->serial->private)->ds_oob_port;
+	struct digi_port *oob_priv = (struct digi_port *)oob_port->private;
 	unsigned long flags = 0;
 
 
@@ -689,7 +684,7 @@
 	spin_unlock_irqrestore( &oob_priv->dp_port_lock, flags );
 
 	if( ret ) {
-		err( __FUNCTION__ ": usb_submit_urb failed, ret=%d",
+		err("%s: usb_submit_urb failed, ret=%d", __FUNCTION__,
 			ret );
 	}
 
@@ -716,7 +711,7 @@
 
 	int ret = 0;
 	int len;
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	unsigned char *data = port->write_urb->transfer_buffer;
 	unsigned long flags = 0;
 
@@ -778,7 +773,7 @@
 	spin_unlock_irqrestore( &priv->dp_port_lock, flags );
 
 	if( ret ) {
-		err( __FUNCTION__ ": usb_submit_urb failed, ret=%d, port=%d",
+		err("%s: usb_submit_urb failed, ret=%d, port=%d", __FUNCTION__,
 		ret, priv->dp_port_num );
 	}
 
@@ -802,9 +797,9 @@
 {
 
 	int ret;
-	digi_port_t *port_priv = (digi_port_t *)port->private;
-	struct usb_serial_port *oob_port = (struct usb_serial_port *)((digi_serial_t *)port->serial->private)->ds_oob_port;
-	digi_port_t *oob_priv = (digi_port_t *)oob_port->private;
+	struct digi_port *port_priv = (struct digi_port *)port->private;
+	struct usb_serial_port *oob_port = (struct usb_serial_port *)((struct digi_serial *)port->serial->private)->ds_oob_port;
+	struct digi_port *oob_priv = (struct digi_port *)oob_port->private;
 	unsigned char *data = oob_port->write_urb->transfer_buffer;
 	unsigned long flags = 0;
 
@@ -854,7 +849,7 @@
 	spin_unlock_irqrestore( &oob_priv->dp_port_lock, flags );
 
 	if( ret ) {
-		err( __FUNCTION__ ": usb_submit_urb failed, ret=%d",
+		err("%s: usb_submit_urb failed, ret=%d", __FUNCTION__,
 		ret );
 	}
 
@@ -881,7 +876,7 @@
 
 	int ret;
 	unsigned char buf[2];
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	unsigned long flags = 0;
 
 
@@ -921,7 +916,7 @@
 {
 
 	unsigned long flags;
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 
 
 dbg( "digi_rx_throttle: TOP: port=%d", priv->dp_port_num );
@@ -942,7 +937,7 @@
 	int ret = 0;
 	int len;
 	unsigned long flags;
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	struct tty_struct *tty = port->tty;
 
 
@@ -975,7 +970,7 @@
 	spin_unlock_irqrestore( &priv->dp_port_lock, flags );
 
 	if( ret ) {
-		err( __FUNCTION__ ": usb_submit_urb failed, ret=%d, port=%d",
+		err("%s: usb_submit_urb failed, ret=%d, port=%d", __FUNCTION__,
 			ret, priv->dp_port_num );
 	}
 
@@ -986,7 +981,7 @@
 	struct termios *old_termios )
 {
 
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	unsigned int iflag = port->tty->termios->c_iflag;
 	unsigned int cflag = port->tty->termios->c_cflag;
 	unsigned int old_iflag = old_termios->c_iflag;
@@ -1210,7 +1205,7 @@
 	unsigned int cmd, unsigned long arg )
 {
 
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	unsigned int val;
 	unsigned long flags = 0;
 
@@ -1262,7 +1257,7 @@
 {
 
 	int ret,data_len,new_len;
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	unsigned char *data = port->write_urb->transfer_buffer;
 	unsigned char user_buf[64];	/* 64 bytes is max USB bulk packet */
 	unsigned long flags = 0;
@@ -1334,7 +1329,7 @@
 	/* return length of new data written, or error */
 	spin_unlock_irqrestore( &priv->dp_port_lock, flags );
 	if( ret < 0 ) {
-		err( __FUNCTION__ ": usb_submit_urb failed, ret=%d, port=%d",
+		err("%s: usb_submit_urb failed, ret=%d, port=%d", __FUNCTION__,
 			ret, priv->dp_port_num );
 	}
 
@@ -1349,27 +1344,27 @@
 
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct usb_serial *serial;
-	digi_port_t *priv;
+	struct digi_port *priv;
 	int ret = 0;
 
 
 dbg( "digi_write_bulk_callback: TOP, urb->status=%d", urb->status );
 
 	/* port and serial sanity check */
-	if( port == NULL || (priv=(digi_port_t *)(port->private)) == NULL ) {
-		err( __FUNCTION__ ": port or port->private is NULL, status=%d",
+	if( port == NULL || (priv=(struct digi_port *)(port->private)) == NULL ) {
+		err("%s: port or port->private is NULL, status=%d", __FUNCTION__,
 			urb->status );
 		return;
 	}
 	serial = port->serial;
 	if( serial == NULL || serial->private == NULL ) {
-		err( __FUNCTION__ ": serial or serial->private is NULL, status=%d", urb->status );
+		err("%s: serial or serial->private is NULL, status=%d", __FUNCTION__, urb->status );
 		return;
 	}
 
 	/* handle oob callback */
 	if( priv->dp_port_num
-	== ((digi_serial_t *)(serial->private))->ds_oob_port_num ) {
+	== ((struct digi_serial *)(serial->private))->ds_oob_port_num ) {
 		dbg( "digi_write_bulk_callback: oob callback" );
 		spin_lock( &priv->dp_port_lock );
 		priv->dp_write_urb_in_use = 0;
@@ -1386,7 +1381,7 @@
 	/* try to send any buffered data on this port, if it is open */
 	spin_lock( &priv->dp_port_lock );
 	priv->dp_write_urb_in_use = 0;
-	if( priv->dp_open_count && port->write_urb->status != -EINPROGRESS
+	if( port->open_count && port->write_urb->status != -EINPROGRESS
 	&& priv->dp_out_buf_len > 0 ) {
 
 		*((unsigned char *)(port->write_urb->transfer_buffer))
@@ -1413,14 +1408,12 @@
 
 	/* also queue up a wakeup at scheduler time, in case we */
 	/* lost the race in write_chan(). */
-	MOD_INC_USE_COUNT;
-	if (schedule_task(&priv->dp_wakeup_task) == 0)
-		MOD_DEC_USE_COUNT;
+	schedule_task(&priv->dp_wakeup_task);
 
 	spin_unlock( &priv->dp_port_lock );
 
 	if( ret ) {
-		err( __FUNCTION__ ": usb_submit_urb failed, ret=%d, port=%d",
+		err("%s: usb_submit_urb failed, ret=%d, port=%d", __FUNCTION__,
 			ret, priv->dp_port_num );
 	}
 
@@ -1431,7 +1424,7 @@
 {
 
 	int room;
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	unsigned long flags = 0;
 
 
@@ -1454,7 +1447,7 @@
 static int digi_chars_in_buffer( struct usb_serial_port *port )
 {
 
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 
 
 	if( port->write_urb->status == -EINPROGRESS
@@ -1475,12 +1468,12 @@
 
 	int ret;
 	unsigned char buf[32];
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	struct termios not_termios;
 	unsigned long flags = 0;
 
 
-dbg( "digi_open: TOP: port=%d, active=%d, open_count=%d", priv->dp_port_num, port->active, priv->dp_open_count );
+dbg( "digi_open: TOP: port=%d, open_count=%d", priv->dp_port_num, port->open_count );
 
 	/* be sure the device is started up */
 	if( digi_startup_device( port->serial ) != 0 )
@@ -1494,32 +1487,17 @@
 		return( -EAGAIN );
 	}
 
-	/* inc module use count before sleeping to wait for closes */
-	++priv->dp_open_count;
-	MOD_INC_USE_COUNT;
-
 	/* wait for a close in progress to finish */
 	while( priv->dp_in_close ) {
 		cond_wait_interruptible_timeout_irqrestore(
 			&priv->dp_close_wait, DIGI_RETRY_TIMEOUT,
 			&priv->dp_port_lock, flags );
 		if( signal_pending(current) ) {
-			--priv->dp_open_count;
-			MOD_DEC_USE_COUNT;
 			return( -EINTR );
 		}
 		spin_lock_irqsave( &priv->dp_port_lock, flags );
 	}
 
-	/* if port is already open, just return */
-	/* be sure exactly one open proceeds */
-	if( port->active ) {
-		spin_unlock_irqrestore( &priv->dp_port_lock, flags );
-		return( 0 );
-	}
-
-	/* first open, mark port as active */
-	port->active = 1;
 	spin_unlock_irqrestore( &priv->dp_port_lock, flags );
  
 	/* read modem signals automatically whenever they change */
@@ -1556,24 +1534,15 @@
 	int ret;
 	unsigned char buf[32];
 	struct tty_struct *tty = port->tty;
-	digi_port_t *priv = (digi_port_t *)port->private;
+	struct digi_port *priv = (struct digi_port *)port->private;
 	unsigned long flags = 0;
 
 
-dbg( "digi_close: TOP: port=%d, active=%d, open_count=%d", priv->dp_port_num, port->active, priv->dp_open_count );
+dbg( "digi_close: TOP: port=%d, open_count=%d", priv->dp_port_num, port->open_count );
 
 
 	/* do cleanup only after final close on this port */
 	spin_lock_irqsave( &priv->dp_port_lock, flags );
-	if( priv->dp_open_count > 1 ) {
-		--priv->dp_open_count;
-		MOD_DEC_USE_COUNT;
-		spin_unlock_irqrestore( &priv->dp_port_lock, flags );
-		return;
-	} else if( priv->dp_open_count <= 0 ) {
-		spin_unlock_irqrestore( &priv->dp_port_lock, flags );
-		return;
-	}
 	priv->dp_in_close = 1;
 	spin_unlock_irqrestore( &priv->dp_port_lock, flags );
 
@@ -1644,11 +1613,8 @@
 	tty->closing = 0;
 
 	spin_lock_irqsave( &priv->dp_port_lock, flags );
-	port->active = 0;
 	priv->dp_write_urb_in_use = 0;
 	priv->dp_in_close = 0;
-	--priv->dp_open_count;
-	MOD_DEC_USE_COUNT;
 	wake_up_interruptible( &priv->dp_close_wait );
 	spin_unlock_irqrestore( &priv->dp_port_lock, flags );
 
@@ -1667,7 +1633,7 @@
 {
 
 	int i,ret = 0;
-	digi_serial_t *serial_priv = (digi_serial_t *)serial->private;
+	struct digi_serial *serial_priv = (struct digi_serial *)serial->private;
 	struct usb_serial_port *port;
 
 
@@ -1689,8 +1655,7 @@
 		port->write_urb->dev = port->serial->dev;
 
 		if( (ret=usb_submit_urb(port->read_urb)) != 0 ) {
-			err(
-			__FUNCTION__ ": usb_submit_urb failed, ret=%d, port=%d",
+			err("%s: usb_submit_urb failed, ret=%d, port=%d", __FUNCTION__,
 			ret, i );
 			break;
 		}
@@ -1706,8 +1671,8 @@
 {
 
 	int i;
-	digi_port_t *priv;
-	digi_serial_t *serial_priv;
+	struct digi_port *priv;
+	struct digi_serial *serial_priv;
 
 
 dbg( "digi_startup: TOP" );
@@ -1716,13 +1681,11 @@
 	/* number of regular ports + 1 for the out-of-band port */
 	for( i=0; i<serial->type->num_ports+1; i++ ) {
 
-		serial->port[i].active = 0;
-
 		/* allocate port private structure */
 		priv = serial->port[i].private =
-			(digi_port_t *)kmalloc( sizeof(digi_port_t),
+			(struct digi_port *)kmalloc( sizeof(struct digi_port),
 			GFP_KERNEL );
-		if( priv == (digi_port_t *)0 ) {
+		if( priv == (struct digi_port *)0 ) {
 			while( --i >= 0 )
 				kfree( serial->port[i].private );
 			return( 1 );			/* error */
@@ -1736,7 +1699,6 @@
 		priv->dp_write_urb_in_use = 0;
 		priv->dp_modem_signals = 0;
 		init_waitqueue_head( &priv->dp_modem_change_wait );
-		priv->dp_open_count = 0;
 		priv->dp_transmit_idle = 0;
 		init_waitqueue_head( &priv->dp_transmit_idle_wait );
 		priv->dp_throttled = 0;
@@ -1756,9 +1718,9 @@
 
 	/* allocate serial private structure */
 	serial_priv = serial->private =
-		(digi_serial_t *)kmalloc( sizeof(digi_serial_t),
+		(struct digi_serial *)kmalloc( sizeof(struct digi_serial),
 		GFP_KERNEL );
-	if( serial_priv == (digi_serial_t *)0 ) {
+	if( serial_priv == (struct digi_serial *)0 ) {
 		for( i=0; i<serial->type->num_ports+1; i++ )
 			kfree( serial->port[i].private );
 		return( 1 );			/* error */
@@ -1779,8 +1741,6 @@
 {
 
 	int i;
-	digi_port_t *priv;
-	unsigned long flags;
 
 
 dbg( "digi_shutdown: TOP, in_interrupt()=%d", in_interrupt() );
@@ -1791,17 +1751,6 @@
 		usb_unlink_urb( serial->port[i].write_urb );
 	}
 
-	/* dec module use count */
-	for( i=0; i<serial->type->num_ports; i++ ) {
-		priv = serial->port[i].private;
-		spin_lock_irqsave( &priv->dp_port_lock, flags );
-		while( priv->dp_open_count > 0 ) {
-			MOD_DEC_USE_COUNT;
-			--priv->dp_open_count;
-		}
-		spin_unlock_irqrestore( &priv->dp_port_lock, flags );
-	}
-
 	/* free the private data structures for all ports */
 	/* number of regular ports + 1 for the out-of-band port */
 	for( i=0; i<serial->type->num_ports+1; i++ )
@@ -1815,34 +1764,34 @@
 {
 
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
-	digi_port_t *priv;
+	struct digi_port *priv;
 	int ret;
 
 
 dbg( "digi_read_bulk_callback: TOP" );
 
 	/* port sanity check, do not resubmit if port is not valid */
-	if( port == NULL || (priv=(digi_port_t *)(port->private)) == NULL ) {
-		err( __FUNCTION__ ": port or port->private is NULL, status=%d",
+	if( port == NULL || (priv=(struct digi_port *)(port->private)) == NULL ) {
+		err("%s: port or port->private is NULL, status=%d", __FUNCTION__,
 			urb->status );
 		return;
 	}
 	if( port->serial == NULL
 	|| serial_paranoia_check( port->serial, __FUNCTION__ )
 	|| port->serial->private == NULL ) {
-		err( __FUNCTION__ ": serial is bad or serial->private is NULL, status=%d", urb->status );
+		err("%s: serial is bad or serial->private is NULL, status=%d", __FUNCTION__, urb->status );
 		return;
 	}
 
 	/* do not resubmit urb if it has any status error */
 	if( urb->status ) {
-		err( __FUNCTION__ ": nonzero read bulk status: status=%d, port=%d", urb->status, priv->dp_port_num );
+		err("%s: nonzero read bulk status: status=%d, port=%d", __FUNCTION__, urb->status, priv->dp_port_num );
 		return;
 	}
 
 	/* handle oob or inb callback, do not resubmit if error */
 	if( priv->dp_port_num
-	== ((digi_serial_t *)(port->serial->private))->ds_oob_port_num ) {
+	== ((struct digi_serial *)(port->serial->private))->ds_oob_port_num ) {
 		if( digi_read_oob_callback( urb ) != 0 )
 			return;
 	} else {
@@ -1853,7 +1802,7 @@
 	/* continue read */
 	urb->dev = port->serial->dev;
 	if( (ret=usb_submit_urb(urb)) != 0 ) {
-		err( __FUNCTION__ ": failed resubmitting urb, ret=%d, port=%d",
+		err("%s: failed resubmitting urb, ret=%d, port=%d", __FUNCTION__,
 			ret, priv->dp_port_num );
 	}
 
@@ -1875,7 +1824,7 @@
 
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct tty_struct *tty = port->tty;
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	int opcode = ((unsigned char *)urb->transfer_buffer)[0];
 	int len = ((unsigned char *)urb->transfer_buffer)[1];
 	int status = ((unsigned char *)urb->transfer_buffer)[2];
@@ -1889,12 +1838,12 @@
 
 	/* do not process callbacks on closed ports */
 	/* but do continue the read chain */
-	if( priv->dp_open_count == 0 )
+	if( port->open_count == 0 )
 		return( 0 );
 
 	/* short/multiple packet check */
 	if( urb->actual_length != len + 2 ) {
-     		err( __FUNCTION__ ": INCOMPLETE OR MULTIPLE PACKET, urb->status=%d, port=%d, opcode=%d, len=%d, actual_length=%d, status=%d", urb->status, priv->dp_port_num, opcode, len, urb->actual_length, status );
+     		err("%s: INCOMPLETE OR MULTIPLE PACKET, urb->status=%d, port=%d, opcode=%d, len=%d, actual_length=%d, status=%d", __FUNCTION__, urb->status, priv->dp_port_num, opcode, len, urb->actual_length, status );
 		return( -1 );
 	}
 
@@ -1963,9 +1912,9 @@
 	spin_unlock( &priv->dp_port_lock );
 
 	if( opcode == DIGI_CMD_RECEIVE_DISABLE ) {
-		dbg( __FUNCTION__ ": got RECEIVE_DISABLE" );
+		dbg("%s: got RECEIVE_DISABLE", __FUNCTION__ );
 	} else if( opcode != DIGI_CMD_RECEIVE_DATA ) {
-		dbg( __FUNCTION__ ": unknown opcode: %d", opcode );
+		dbg("%s: unknown opcode: %d", __FUNCTION__, opcode );
 	}
 
 	return( throttled ? 1 : 0 );
@@ -1987,7 +1936,7 @@
 
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct usb_serial *serial = port->serial;
-	digi_port_t *priv = (digi_port_t *)(port->private);
+	struct digi_port *priv = (struct digi_port *)(port->private);
 	int opcode, line, status, val;
 	int i;
 
@@ -2023,7 +1972,7 @@
 			if( val & DIGI_READ_INPUT_SIGNALS_CTS ) {
 				priv->dp_modem_signals |= TIOCM_CTS;
 				/* port must be open to use tty struct */
-				if( priv->dp_open_count
+				if( port->open_count
 				&& port->tty->termios->c_cflag & CRTSCTS ) {
 					port->tty->hw_stopped = 0;
 					digi_wakeup_write( port );
@@ -2031,7 +1980,7 @@
 			} else {
 				priv->dp_modem_signals &= ~TIOCM_CTS;
 				/* port must be open to use tty struct */
-				if( priv->dp_open_count
+				if( port->open_count
 				&& port->tty->termios->c_cflag & CRTSCTS ) {
 					port->tty->hw_stopped = 1;
 				}
diff -Nur linux-2.4.19.old/drivers/usb/serial/empeg.c linux-2.4.19/drivers/usb/serial/empeg.c
--- linux-2.4.19.old/drivers/usb/serial/empeg.c	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/serial/empeg.c	Mon Nov 25 12:27:08 2002
@@ -53,18 +53,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -106,7 +103,7 @@
 static void empeg_write_bulk_callback	(struct urb *urb);
 static void empeg_read_bulk_callback	(struct urb *urb);
 
-static __devinitdata struct usb_device_id id_table [] = {
+static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(EMPEG_VENDOR_ID, EMPEG_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
@@ -114,28 +111,26 @@
 MODULE_DEVICE_TABLE (usb, id_table);
 
 static struct usb_serial_device_type empeg_device = {
-	name:			"Empeg",
-	id_table:		id_table,
-	needs_interrupt_in:	MUST_HAVE_NOT,	/* must not have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,	/* must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,	/* must have a bulk out endpoint */
-	num_interrupt_in:	0,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			empeg_open,
-	close:			empeg_close,
-	throttle:		empeg_throttle,
-	unthrottle:		empeg_unthrottle,
-	startup:		empeg_startup,
-	shutdown:		empeg_shutdown,
-	ioctl:			empeg_ioctl,
-	set_termios:		empeg_set_termios,
-	write:			empeg_write,
-	write_room:		empeg_write_room,
-	chars_in_buffer:	empeg_chars_in_buffer,
-	write_bulk_callback:	empeg_write_bulk_callback,
-	read_bulk_callback:	empeg_read_bulk_callback,
+	.owner =		THIS_MODULE,
+	.name =			"Empeg",
+	.id_table =		id_table,
+	.num_interrupt_in =	0,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			empeg_open,
+	.close =		empeg_close,
+	.throttle =		empeg_throttle,
+	.unthrottle =		empeg_unthrottle,
+	.startup =		empeg_startup,
+	.shutdown =		empeg_shutdown,
+	.ioctl =		empeg_ioctl,
+	.set_termios =		empeg_set_termios,
+	.write =		empeg_write,
+	.write_room =		empeg_write_room,
+	.chars_in_buffer =	empeg_chars_in_buffer,
+	.write_bulk_callback =	empeg_write_bulk_callback,
+	.read_bulk_callback =	empeg_read_bulk_callback,
 };
 
 #define NUM_URBS			16
@@ -157,43 +152,31 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return -ENODEV;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	down (&port->sem);
+	/* Force default termio settings */
+	empeg_set_termios (port, NULL) ;
 
-	++port->open_count;
-	MOD_INC_USE_COUNT;
+	bytes_in = 0;
+	bytes_out = 0;
 
-	if (!port->active) {
-
-		/* Force default termio settings */
-		empeg_set_termios (port, NULL) ;
-
-		port->active = 1;
-		bytes_in = 0;
-		bytes_out = 0;
-
-		/* Start reading from the device */
-		FILL_BULK_URB(
-			port->read_urb,
-			serial->dev, 
-			usb_rcvbulkpipe(serial->dev,
-				port->bulk_in_endpointAddress),
-			port->read_urb->transfer_buffer,
-			port->read_urb->transfer_buffer_length,
-			empeg_read_bulk_callback,
-			port);
-
-		port->read_urb->transfer_flags |= USB_QUEUE_BULK;
-
-		result = usb_submit_urb(port->read_urb);
+	/* Start reading from the device */
+	FILL_BULK_URB(
+		port->read_urb,
+		serial->dev, 
+		usb_rcvbulkpipe(serial->dev,
+			port->bulk_in_endpointAddress),
+		port->read_urb->transfer_buffer,
+		port->read_urb->transfer_buffer_length,
+		empeg_read_bulk_callback,
+		port);
 
-		if (result)
-			err(__FUNCTION__ " - failed submitting read urb, error %d", result);
+	port->read_urb->transfer_flags |= USB_QUEUE_BULK;
 
-	}
+	result = usb_submit_urb(port->read_urb);
 
-	up (&port->sem);
+	if (result)
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
 
 	return result;
 }
@@ -206,31 +189,18 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	serial = get_usb_serial (port, __FUNCTION__);
 	if (!serial)
 		return;
 
-	down (&port->sem);
-
-	--port->open_count;
-
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			/* shutdown our bulk read */
-			usb_unlink_urb (port->read_urb);
-		}
-		port->active = 0;
-		port->open_count = 0;
+	if (serial->dev) {
+		/* shutdown our bulk read */
+		usb_unlink_urb (port->read_urb);
 	}
-
-	up (&port->sem);
-
 	/* Uncomment the following line if you want to see some statistics in your syslog */
 	/* info ("Bytes In = %d  Bytes Out = %d", bytes_in, bytes_out); */
-
-	MOD_DEC_USE_COUNT;
 }
 
 
@@ -245,7 +215,7 @@
 	int bytes_sent = 0;
 	int transfer_size;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	usb_serial_debug_data (__FILE__, __FUNCTION__, count, buf);
 
@@ -266,14 +236,14 @@
 		spin_unlock_irqrestore (&write_urb_pool_lock, flags);
 
 		if (urb == NULL) {
-			dbg (__FUNCTION__ " - no more free urbs");
+			dbg("%s - no more free urbs", __FUNCTION__);
 			goto exit;
 		}
 
 		if (urb->transfer_buffer == NULL) {
-			urb->transfer_buffer = kmalloc (URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);
+			urb->transfer_buffer = kmalloc (URB_TRANSFER_BUFFER_SIZE, GFP_ATOMIC);
 			if (urb->transfer_buffer == NULL) {
-				err(__FUNCTION__" no more kernel memory...");
+				err("%s no more kernel memory...", __FUNCTION__);
 				goto exit;
 			}
 		}
@@ -305,7 +275,7 @@
 		/* send it down the pipe */
 		status = usb_submit_urb(urb);
 		if (status) {
-			err(__FUNCTION__ " - usb_submit_urb(write bulk) failed with status = %d", status);
+			err("%s - usb_submit_urb(write bulk) failed with status = %d", __FUNCTION__, status);
 			bytes_sent = status;
 			break;
 		}
@@ -329,7 +299,7 @@
 	int i;
 	int room = 0;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	spin_lock_irqsave (&write_urb_pool_lock, flags);
 
@@ -342,7 +312,7 @@
 
 	spin_unlock_irqrestore (&write_urb_pool_lock, flags);
 
-	dbg(__FUNCTION__ " - returns %d", room);
+	dbg("%s - returns %d", __FUNCTION__, room);
 
 	return (room);
 
@@ -355,7 +325,7 @@
 	int i;
 	int chars = 0;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	spin_lock_irqsave (&write_urb_pool_lock, flags);
 
@@ -368,7 +338,7 @@
 
 	spin_unlock_irqrestore (&write_urb_pool_lock, flags);
 
-	dbg (__FUNCTION__ " - returns %d", chars);
+	dbg("%s - returns %d", __FUNCTION__, chars);
 
 	return (chars);
 
@@ -382,10 +352,10 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -409,15 +379,15 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -459,7 +429,7 @@
 	result = usb_submit_urb(port->read_urb);
 
 	if (result)
-		err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 
 	return;
 
@@ -468,16 +438,8 @@
 
 static void empeg_throttle (struct usb_serial_port *port)
 {
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
-
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	usb_unlink_urb (port->read_urb);
-
-	up (&port->sem);
-
-	return;
-
 }
 
 
@@ -485,30 +447,25 @@
 {
 	int result;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	port->read_urb->dev = port->serial->dev;
 
 	result = usb_submit_urb(port->read_urb);
 
 	if (result)
-		err(__FUNCTION__ " - failed submitting read urb, error %d", result);
-
-	up (&port->sem);
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
 
 	return;
-
 }
 
 
 static int  empeg_startup (struct usb_serial *serial)
 {
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	dbg(__FUNCTION__ " - Set config to 1");
+	dbg("%s - Set config to 1", __FUNCTION__);
 	usb_set_configuration (serial->dev, 1);
 
 	/* continue on with initialization */
@@ -519,23 +476,13 @@
 
 static void empeg_shutdown (struct usb_serial *serial)
 {
-	int i;
-
-	dbg (__FUNCTION__);
-
-	/* stop reads and writes on all ports */
-	for (i=0; i < serial->num_ports; ++i) {
-		while (serial->port[i].open_count > 0) {
-			empeg_close (&serial->port[i], NULL);
-		}
-	}
-
+	dbg ("%s", __FUNCTION__);
 }
 
 
 static int empeg_ioctl (struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg)
 {
-	dbg(__FUNCTION__ " - port %d, cmd 0x%.4x", port->number, cmd);
+	dbg("%s - port %d, cmd 0x%.4x", __FUNCTION__, port->number, cmd);
 
 	return -ENOIOCTLCMD;
 }
@@ -544,10 +491,10 @@
 static void empeg_set_termios (struct usb_serial_port *port, struct termios *old_termios)
 {
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if ((!port->tty) || (!port->tty->termios)) {
-		dbg(__FUNCTION__" - no tty structures");
+		dbg("%s - no tty structures", __FUNCTION__);
 		return;
 	}
 
@@ -624,7 +571,8 @@
 		urb->transfer_buffer = NULL;
 		urb->transfer_buffer = kmalloc (URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);
 		if (!urb->transfer_buffer) {
-			err (__FUNCTION__ " - out of memory for urb buffers.");
+			err("%s - out of memory for urb buffers.", 
+			    __FUNCTION__);
 			continue;
 		}
 	}
diff -Nur linux-2.4.19.old/drivers/usb/serial/ftdi_sio.c linux-2.4.19/drivers/usb/serial/ftdi_sio.c
--- linux-2.4.19.old/drivers/usb/serial/ftdi_sio.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/ftdi_sio.c	Mon Nov 25 12:27:08 2002
@@ -4,6 +4,8 @@
  * 	Copyright (C) 1999 - 2001
  * 	    Greg Kroah-Hartman (greg@kroah.com)
  *          Bill Ryder (bryder@sgi.com)
+ *	Copyright (C) 2002
+ *	    Kuba Ober (kuba@mareimbrium.org)
  *
  * 	This program is free software; you can redistribute it and/or modify
  * 	it under the terms of the GNU General Public License as published by
@@ -13,49 +15,63 @@
  * See Documentation/usb/usb-serial.txt for more information on using this driver
  *
  * See http://ftdi-usb-sio.sourceforge.net for upto date testing info
- *     and extra documentation
+ *	and extra documentation
+ *
+ * (25/Jul/2002) Bill Ryder inserted Dmitri's TIOCMIWAIT patch
+ *      Not tested by me but it doesn't break anything I use.
  * 
+ * (04/Jan/2002) Kuba Ober
+ *	Implemented 38400 baudrate kludge, where it can be substituted with other
+ *	  values. That's the only way to set custom baudrates.
+ *	Implemented TIOCSSERIAL, TIOCGSERIAL ioctl's so that setserial is happy.
+ *	FIXME: both baudrate things should eventually go to usbserial.c as other
+ *	  devices may need that functionality too. Actually, it can probably be
+ *	  merged in serial.c somehow - too many drivers repeat this code over
+ *	  and over.
+ *	Fixed baudrate forgetfulness - open() used to reset baudrate to 9600 every time.
+ *	Divisors for baudrates are calculated by a macro.
+ *	Small code cleanups. Ugly whitespace changes for Plato's sake only ;-].
+ *
  * (04/Nov/2001) Bill Ryder
- *     Fixed bug in read_bulk_callback where incorrect urb buffer was used.
- *     cleaned up write offset calculation
- *     added write_room since default values can be incorrect for sio
- *     changed write_bulk_callback to use same queue_task as other drivers
- *       (the previous version caused panics)
- *     Removed port iteration code since the device only has one I/O port and it 
- *       was wrong anyway.
+ *	Fixed bug in read_bulk_callback where incorrect urb buffer was used.
+ *	Cleaned up write offset calculation
+ *	Added write_room since default values can be incorrect for sio
+ *	Changed write_bulk_callback to use same queue_task as other drivers
+ *        (the previous version caused panics)
+ *	Removed port iteration code since the device only has one I/O port and it
+ *	  was wrong anyway.
  * 
  * (31/May/2001) gkh
- *	switched from using spinlock to a semaphore, which fixes lots of problems.
+ *	Switched from using spinlock to a semaphore, which fixes lots of problems.
  *
  * (23/May/2001)   Bill Ryder
- *     Added runtime debug patch (thanx Tyson D Sawyer).
- *     Cleaned up comments for 8U232
- *     Added parity, framing and overrun error handling
- *     Added receive break handling.
+ *	Added runtime debug patch (thanx Tyson D Sawyer).
+ *	Cleaned up comments for 8U232
+ *	Added parity, framing and overrun error handling
+ *	Added receive break handling.
  * 
  * (04/08/2001) gb
  *	Identify version on module load.
  *       
  * (18/March/2001) Bill Ryder
- *     (Not released)
- *     Added send break handling. (requires kernel patch too)
- *     Fixed 8U232AM hardware RTS/CTS etc status reporting.
- *     Added flipbuf fix copied from generic device
+ *	(Not released)
+ *	Added send break handling. (requires kernel patch too)
+ *	Fixed 8U232AM hardware RTS/CTS etc status reporting.
+ *	Added flipbuf fix copied from generic device
  * 
  * (12/3/2000) Bill Ryder
- *     Added support for 8U232AM device.
- *     Moved PID and VIDs into header file only.
- *     Turned on low-latency for the tty (device will do high baudrates)
- *     Added shutdown routine to close files when device removed.
- *     More debug and error message cleanups.
- *     
+ *	Added support for 8U232AM device.
+ *	Moved PID and VIDs into header file only.
+ *	Turned on low-latency for the tty (device will do high baudrates)
+ *	Added shutdown routine to close files when device removed.
+ *	More debug and error message cleanups.
  *
  * (11/13/2000) Bill Ryder
- *     Added spinlock protected open code and close code.
- *     Multiple opens work (sort of - see webpage mentioned above).
- *     Cleaned up comments. Removed multiple PID/VID definitions.
- *     Factorised cts/dtr code
- *     Made use of __FUNCTION__ in dbg's
+ *	Added spinlock protected open code and close code.
+ *	Multiple opens work (sort of - see webpage mentioned above).
+ *	Cleaned up comments. Removed multiple PID/VID definitions.
+ *	Factorised cts/dtr code
+ *	Made use of __FUNCTION__ in dbg's
  *      
  * (11/01/2000) Adam J. Richter
  *	usb_device_id table support
@@ -72,16 +88,16 @@
  *	driver is a loadable module now.
  *
  * (04/04/2000) Bill Ryder 
- *      Fixed bugs in TCGET/TCSET ioctls (by removing them - they are 
+ *	Fixed bugs in TCGET/TCSET ioctls (by removing them - they are
  *        handled elsewhere in the tty io driver chain).
  *
  * (03/30/2000) Bill Ryder 
- *      Implemented lots of ioctls
- * 	Fixed a race condition in write
- * 	Changed some dbg's to errs
+ *	Implemented lots of ioctls
+ *	Fixed a race condition in write
+ *	Changed some dbg's to errs
  *
  * (03/26/2000) gkh
- * 	Split driver up into device specific pieces.
+ *	Split driver up into device specific pieces.
  *
  */
 
@@ -90,22 +106,19 @@
 /*   to talk to the device */
 /* Thanx to gkh and the rest of the usb dev group for all code I have assimilated :-) */
 
-
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
+#include <linux/serial.h>
 #ifdef CONFIG_USB_SERIAL_DEBUG
 	static int debug = 1;
 #else
@@ -115,28 +128,30 @@
 #include "usb-serial.h"
 #include "ftdi_sio.h"
 
-
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.2.0"
-#define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>, Bill Ryder <bryder@sgi.com>"
-#define DRIVER_DESC "USB FTDI RS232 Converters Driver"
+#define DRIVER_VERSION "v1.2.1"
+#define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>, Bill Ryder <bryder@sgi.com>, Kuba Ober <kuba@mareimbrium.org>"
+#define DRIVER_DESC "USB FTDI Serial Converters Driver"
 
-static __devinitdata struct usb_device_id id_table_sio [] = {
+static struct usb_device_id id_table_sio [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_SIO_PID) },
 	{ }						/* Terminating entry */
 };
 
-/* THe 8U232AM has the same API as the sio except for:
-   - it can support MUCH higher baudrates (921600 at 48MHz/230400 
-     at 12MHz so .. it's baudrate setting codes are different 
-   - it has a two byte status code.
-   - it returns characters very 16ms (the FTDI does it every 40ms)
-  */
+/*
+ * The 8U232AM has the same API as the sio except for:
+ * - it can support MUCH higher baudrates; up to:
+ *   o 921600 for RS232 and 2000000 for RS422/485 at 48MHz
+ *   o 230400 at 12MHz
+ *   so .. 8U232AM's baudrate setting codes are different
+ * - it has a two byte status code.
+ * - it returns characters every 16ms (the FTDI does it every 40ms)
+ */
 
-   
-static __devinitdata struct usb_device_id id_table_8U232AM [] = {
+
+static struct usb_device_id id_table_8U232AM [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_8U232AM_PID) },
 	{ USB_DEVICE(FTDI_NF_RIC_VID, FTDI_NF_RIC_PID) },
 	{ }						/* Terminating entry */
@@ -152,88 +167,98 @@
 
 MODULE_DEVICE_TABLE (usb, id_table_combined);
 
-
 struct ftdi_private {
-	ftdi_type_t ftdi_type;
-	__u16 last_set_data_urb_value ; /* the last data state set - needed for doing a break */
-        int write_offset;
+	ftdi_chip_type_t chip_type;
+				/* type of the device, either SIO or FT8U232AM */
+	int baud_base;		/* baud base clock for divisor setting */
+	int custom_divisor;	/* custom_divisor kludge, this is for baud_base (different from what goes to the chip!) */
+	__u16 last_set_data_urb_value ;
+				/* the last data state set - needed for doing a break */
+        int write_offset;       /* This is the offset in the usb data block to write the serial data - 
+				 * it is different between devices
+				 */
+	int flags;		/* some ASYNC_xxxx flags are supported */
+        wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
+ 	char prev_status, diff_status;        /* Used for TIOCMIWAIT */
 };
+
+/* Used for TIOCMIWAIT */
+#define FTDI_STATUS_B0_MASK	(FTDI_RS0_CTS | FTDI_RS0_DSR | FTDI_RS0_RI | FTDI_RS0_RLSD)
+#define FTDI_STATUS_B1_MASK	(FTDI_RS_BI)
+/* End TIOCMIWAIT */
+
+#define FTDI_IMPL_ASYNC_FLAGS = ( ASYNC_SPD_HI | ASYNC_SPD_VHI \
+ ASYNC_SPD_CUST | ASYNC_SPD_SHI | ASYNC_SPD_WARP )
+
 /* function prototypes for a FTDI serial converter */
-static int  ftdi_sio_startup		(struct usb_serial *serial);
+static int  ftdi_SIO_startup		(struct usb_serial *serial);
 static int  ftdi_8U232AM_startup	(struct usb_serial *serial);
-static void ftdi_sio_shutdown		(struct usb_serial *serial);
-static int  ftdi_sio_open		(struct usb_serial_port *port, struct file *filp);
-static void ftdi_sio_close		(struct usb_serial_port *port, struct file *filp);
-static int  ftdi_sio_write		(struct usb_serial_port *port, int from_user, const unsigned char *buf, int count);
-static int  ftdi_sio_write_room		(struct usb_serial_port *port);
-static void ftdi_sio_write_bulk_callback (struct urb *urb);
-static void ftdi_sio_read_bulk_callback	(struct urb *urb);
-static void ftdi_sio_set_termios	(struct usb_serial_port *port, struct termios * old);
-static int  ftdi_sio_ioctl		(struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg);
-static void ftdi_sio_break_ctl		(struct usb_serial_port *port, int break_state );
-
-/* Should rename most ftdi_sio's to ftdi_ now since there are two devices 
-   which share common code */ 
-
-static struct usb_serial_device_type ftdi_sio_device = {
-	name:			"FTDI SIO",
-	id_table:		id_table_sio,
-	needs_interrupt_in:	MUST_HAVE_NOT,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	0,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			ftdi_sio_open,
-	close:			ftdi_sio_close,
-	write:			ftdi_sio_write,
-	write_room:		ftdi_sio_write_room,
-	read_bulk_callback:	ftdi_sio_read_bulk_callback,
-	write_bulk_callback:	ftdi_sio_write_bulk_callback,
-	ioctl:			ftdi_sio_ioctl,
-	set_termios:		ftdi_sio_set_termios,
-	break_ctl:		ftdi_sio_break_ctl,
-	startup:		ftdi_sio_startup,
-        shutdown:               ftdi_sio_shutdown,
+static void ftdi_shutdown		(struct usb_serial *serial);
+static int  ftdi_open			(struct usb_serial_port *port, struct file *filp);
+static void ftdi_close			(struct usb_serial_port *port, struct file *filp);
+static int  ftdi_write			(struct usb_serial_port *port, int from_user, const unsigned char *buf, int count);
+static int  ftdi_write_room		(struct usb_serial_port *port);
+static void ftdi_write_bulk_callback	(struct urb *urb);
+static void ftdi_read_bulk_callback	(struct urb *urb);
+static void ftdi_set_termios		(struct usb_serial_port *port, struct termios * old);
+static int  ftdi_ioctl			(struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg);
+static void ftdi_break_ctl		(struct usb_serial_port *port, int break_state );
+
+static struct usb_serial_device_type ftdi_SIO_device = {
+	.owner =		THIS_MODULE,
+	.name =			"FTDI SIO",
+	.id_table =		id_table_sio,
+	.num_interrupt_in =	0,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			ftdi_open,
+	.close =		ftdi_close,
+	.write =		ftdi_write,
+	.write_room =		ftdi_write_room,
+	.read_bulk_callback =	ftdi_read_bulk_callback,
+	.write_bulk_callback =	ftdi_write_bulk_callback,
+	.ioctl =		ftdi_ioctl,
+	.set_termios =		ftdi_set_termios,
+	.break_ctl =		ftdi_break_ctl,
+	.startup =		ftdi_SIO_startup,
+	.shutdown =		ftdi_shutdown,
 };
 
 static struct usb_serial_device_type ftdi_8U232AM_device = {
-	name:			"FTDI 8U232AM",
-	id_table:		id_table_8U232AM,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	0,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			ftdi_sio_open,
-	close:			ftdi_sio_close,
-	write:			ftdi_sio_write,
-	write_room:		ftdi_sio_write_room,
-	read_bulk_callback:	ftdi_sio_read_bulk_callback,
-	write_bulk_callback:	ftdi_sio_write_bulk_callback,
-	ioctl:			ftdi_sio_ioctl,
-	set_termios:		ftdi_sio_set_termios,
-	break_ctl:		ftdi_sio_break_ctl,
-	startup:		ftdi_8U232AM_startup,
-        shutdown:               ftdi_sio_shutdown,
+	.owner =		THIS_MODULE,
+	.name =			"FTDI 8U232AM",
+	.id_table =		id_table_8U232AM,
+	.num_interrupt_in =	0,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			ftdi_open,
+	.close =		ftdi_close,
+	.write =		ftdi_write,
+	.write_room =		ftdi_write_room,
+	.read_bulk_callback =	ftdi_read_bulk_callback,
+	.write_bulk_callback =	ftdi_write_bulk_callback,
+	.ioctl =		ftdi_ioctl,
+	.set_termios =		ftdi_set_termios,
+	.break_ctl =		ftdi_break_ctl,
+	.startup =		ftdi_8U232AM_startup,
+	.shutdown =		ftdi_shutdown,
 };
 
+#define WDR_TIMEOUT (HZ * 5 ) /* default urb timeout */
+
+#define HIGH 1
+#define LOW 0
 
 /*
  * ***************************************************************************
- * FTDI SIO Serial Converter specific driver functions
+ * Utlity functions
  * ***************************************************************************
  */
 
-#define WDR_TIMEOUT (HZ * 5 ) /* default urb timeout */
 
-/* utility functions to set and unset dtr and rts */
-#define HIGH 1
-#define LOW 0
-static int set_rts(struct usb_device *dev, 
+static int set_rts(struct usb_device *dev,
 		   unsigned int pipe,
 		   int high_or_low)
 {
@@ -246,9 +271,11 @@
 			       ftdi_high_or_low, 0, 
 			       buf, 0, WDR_TIMEOUT));
 }
-static int set_dtr(struct usb_device *dev, 
-		   unsigned int pipe,
-		   int high_or_low)
+
+
+static int set_dtr(struct usb_device *dev,
+                   unsigned int pipe,
+                   int high_or_low)
 {
 	static char buf[1];
 	unsigned ftdi_high_or_low = (high_or_low? FTDI_SIO_SET_DTR_HIGH : 
@@ -261,51 +288,238 @@
 }
 
 
+static __u16 get_ftdi_divisor(struct usb_serial_port * port);
+
 
-static int ftdi_sio_startup (struct usb_serial *serial)
+static int change_speed(struct usb_serial_port *port)
 {
-	struct ftdi_private *priv;
+	char buf[1];
+        __u16 urb_value;
+
+	urb_value = get_ftdi_divisor(port);
 	
+	return (usb_control_msg(port->serial->dev,
+			    usb_sndctrlpipe(port->serial->dev, 0),
+			    FTDI_SIO_SET_BAUDRATE_REQUEST,
+			    FTDI_SIO_SET_BAUDRATE_REQUEST_TYPE,
+			    urb_value, 0,
+			    buf, 0, 100) < 0);
+}
+
+
+static __u16 get_ftdi_divisor(struct usb_serial_port * port)
+{ /* get_ftdi_divisor */
 	
+	struct ftdi_private * priv = (struct ftdi_private *)port->private;
+	__u16 urb_value = 0;
+	int baud;
+
+	/*
+	 * The logic involved in setting the baudrate can be cleanly split in 3 steps.
+	 * Obtaining the actual baud rate is a little tricky since unix traditionally
+	 * somehow ignored the possibility to set non-standard baud rates.
+	 * 1. Standard baud rates are set in tty->termios->c_cflag
+	 * 2. If these are not enough, you can set any speed using alt_speed as follows:
+	 *    - set tty->termios->c_cflag speed to B38400
+	 *    - set your real speed in tty->alt_speed; it gets ignored when
+	 *      alt_speed==0, (or)
+	 *    - call TIOCSSERIAL ioctl with (struct serial_struct) set as follows:
+	 *      flags & ASYNC_SPD_MASK == ASYNC_SPD_[HI, VHI, SHI, WARP], this just
+	 *      sets alt_speed to (HI: 57600, VHI: 115200, SHI: 230400, WARP: 460800)
+	 * ** Steps 1, 2 are done courtesy of tty_get_baud_rate
+	 * 3. You can also set baud rate by setting custom divisor as follows
+	 *    - set tty->termios->c_cflag speed to B38400
+	 *    - call TIOCSSERIAL ioctl with (struct serial_struct) set as follows:
+	 *      o flags & ASYNC_SPD_MASK == ASYNC_SPD_CUST
+	 *      o custom_divisor set to baud_base / your_new_baudrate
+	 * ** Step 3 is done courtesy of code borrowed from serial.c - I should really
+	 *    spend some time and separate+move this common code to serial.c, it is
+	 *    replicated in nearly every serial driver you see.
+	 */
+
+	/* 1. Get the baud rate from the tty settings, this observes alt_speed hack */
+
+	baud = tty_get_baud_rate(port->tty);
+	dbg("%s - tty_get_baud_rate reports speed %d", __FUNCTION__, baud);
+
+	/* 2. Observe async-compatible custom_divisor hack, update baudrate if needed */
+
+	if (baud == 38400 &&
+	    ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST) &&
+	     (priv->custom_divisor)) {
+		baud = priv->baud_base / priv->custom_divisor;
+		dbg("%s - custom divisor %d sets baud rate to %d", __FUNCTION__, priv->custom_divisor, baud);
+	}
+
+	/* 3. Convert baudrate to device-specific divisor */
+
+	if (!baud) baud = 9600;	
+	switch(priv->chip_type) {
+	case SIO: /* SIO chip */
+		switch(baud) {
+		case 300: urb_value = ftdi_sio_b300; break;
+		case 600: urb_value = ftdi_sio_b600; break;
+		case 1200: urb_value = ftdi_sio_b1200; break;
+		case 2400: urb_value = ftdi_sio_b2400; break;
+		case 4800: urb_value = ftdi_sio_b4800; break;
+		case 9600: urb_value = ftdi_sio_b9600; break;
+		case 19200: urb_value = ftdi_sio_b19200; break;
+		case 38400: urb_value = ftdi_sio_b38400; break;
+		case 57600: urb_value = ftdi_sio_b57600;  break;
+		case 115200: urb_value = ftdi_sio_b115200; break;
+		} /* baud */
+		if (urb_value == 0)
+			dbg("%s - Baudrate (%d) requested is not supported", __FUNCTION__,  baud);
+		break;
+	case FT8U232AM: /* 8U232AM chip */
+		if (baud <= 3000000) {
+			urb_value = FTDI_SIO_BAUD_TO_DIVISOR(baud);
+		} else {
+	                dbg("%s - Baud rate too high!", __FUNCTION__);
+		}
+		break;
+	} /* priv->chip_type */
+
+	if (urb_value == 0) {
+		urb_value = ftdi_sio_b9600;
+	} else {
+		dbg("%s - Baud rate set to %d (divisor %d) on chip %s", __FUNCTION__, baud, urb_value, (priv->chip_type == SIO) ? "SIO" : "FT8U232AM" );
+	}
+
+	return(urb_value);
+}
+
+
+static int get_serial_info(struct usb_serial_port * port, struct serial_struct * retinfo)
+{
+	struct ftdi_private * priv = (struct ftdi_private*) port->private;
+	struct serial_struct tmp;
+
+	if (!retinfo)
+		return -EFAULT;
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.flags = priv->flags;
+	tmp.baud_base = priv->baud_base;
+	tmp.custom_divisor = priv->custom_divisor;
+	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+} /* get_serial_info */
+
+
+static int set_serial_info(struct usb_serial_port * port, struct serial_struct * newinfo)
+{ /* set_serial_info */
+	struct ftdi_private * priv = (struct ftdi_private *) port->private;
+	struct serial_struct new_serial;
+	struct ftdi_private old_priv;
+
+	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
+		return -EFAULT;
+	old_priv = * priv;
+
+	/* Do error checking and permission checking */
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		if (((new_serial.flags & ~ASYNC_USR_MASK) !=
+		     (priv->flags & ~ASYNC_USR_MASK)))
+			return -EPERM;
+		priv->flags = ((priv->flags & ~ASYNC_USR_MASK) |
+			       (new_serial.flags & ASYNC_USR_MASK));
+		priv->custom_divisor = new_serial.custom_divisor;
+		goto check_and_exit;
+	}
+
+	if ((new_serial.baud_base != priv->baud_base) ||
+	    (new_serial.baud_base < 9600))
+		return -EINVAL;
+
+	/* Make the changes - these are privileged changes! */
+
+	priv->flags = ((priv->flags & ~ASYNC_FLAGS) |
+	               (new_serial.flags & ASYNC_FLAGS));	
+	priv->custom_divisor = new_serial.custom_divisor;
+
+	port->tty->low_latency = (priv->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+
+check_and_exit:
+	if (((old_priv.flags & ASYNC_SPD_MASK) !=
+	     (priv->flags & ASYNC_SPD_MASK)) ||
+	    (old_priv.custom_divisor != priv->custom_divisor)) {
+		if ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+			port->tty->alt_speed = 57600;
+		if ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+			port->tty->alt_speed = 115200;
+		if ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			port->tty->alt_speed = 230400;
+		if ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			port->tty->alt_speed = 460800;
+		change_speed(port);
+	}
+	
+	return (0);
+
+} /* set_serial_info */
+
+/*
+ * ***************************************************************************
+ * FTDI driver specific functions
+ * ***************************************************************************
+ */
+
+/* Startup for the SIO chip */
+static int ftdi_SIO_startup (struct usb_serial *serial)
+{
+	struct ftdi_private *priv;
+
 	priv = serial->port->private = kmalloc(sizeof(struct ftdi_private), GFP_KERNEL);
 	if (!priv){
-		err(__FUNCTION__"- kmalloc(%Zd) failed.", sizeof(struct ftdi_private));
+		err("%s- kmalloc(%Zd) failed.", __FUNCTION__, sizeof(struct ftdi_private));
 		return -ENOMEM;
 	}
 
-	priv->ftdi_type = sio;
+	priv->chip_type = SIO;
+	priv->baud_base = 12000000 / 16;
+	priv->custom_divisor = 0;
 	priv->write_offset = 1;
+ 	priv->prev_status = priv->diff_status = 0;
+	/* This will push the characters through immediately rather
+	   than queue a task to deliver them */
+	priv->flags = ASYNC_LOW_LATENCY;
 	
 	return (0);
 }
 
-
+/* Startup for the 8U232AM chip */
 static int ftdi_8U232AM_startup (struct usb_serial *serial)
 {
 	struct ftdi_private *priv;
- 
 
 	priv = serial->port->private = kmalloc(sizeof(struct ftdi_private), GFP_KERNEL);
 	if (!priv){
-		err(__FUNCTION__"- kmalloc(%Zd) failed.", sizeof(struct ftdi_private));
+		err("%s- kmalloc(%Zd) failed.", __FUNCTION__, sizeof(struct ftdi_private));
 		return -ENOMEM;
 	}
 
-	priv->ftdi_type = F8U232AM;
+	priv->chip_type = FT8U232AM;
+	priv->baud_base = 48000000 / 2; /* Would be / 16, but FTDI supports 0.125, 0.25 and 0.5 divisor fractions! */
+	priv->custom_divisor = 0;
 	priv->write_offset = 0;
+        init_waitqueue_head(&priv->delta_msr_wait);
+	/* This will push the characters through immediately rather
+	   than queue a task to deliver them */
+	priv->flags = ASYNC_LOW_LATENCY;
 	
 	return (0);
 }
 
-static void ftdi_sio_shutdown (struct usb_serial *serial)
-{
-	
-	dbg (__FUNCTION__);
 
+static void ftdi_shutdown (struct usb_serial *serial)
+{
+	dbg("%s", __FUNCTION__);
 
 	/* stop reads and writes on all ports */
 	while (serial->port[0].open_count > 0) {
-	        ftdi_sio_close (&serial->port[0], NULL);
+	        ftdi_close (&serial->port[0], NULL);
 	}
 	if (serial->port[0].private){
 		kfree(serial->port[0].private);
@@ -314,117 +528,92 @@
 }
 
 
-
-static int  ftdi_sio_open (struct usb_serial_port *port, struct file *filp)
-{ /* ftdi_sio_open */
+static int  ftdi_open (struct usb_serial_port *port, struct file *filp)
+{ /* ftdi_open */
 	struct termios tmp_termios;
 	struct usb_serial *serial = port->serial;
+	struct ftdi_private *priv = port->private;
+	
 	int result = 0;
 	char buf[1]; /* Needed for the usb_control_msg I think */
 
-	dbg(__FUNCTION__);
-
-	down (&port->sem);
-	
-	MOD_INC_USE_COUNT;
-	++port->open_count;
+	dbg("%s", __FUNCTION__);
 
-	if (!port->active){
-		port->active = 1;
 
-		/* This will push the characters through immediately rather 
-		   than queue a task to deliver them */
-		port->tty->low_latency = 1;
+	port->tty->low_latency = (priv->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
 
-		/* No error checking for this (will get errors later anyway) */
-		/* See ftdi_sio.h for description of what is reset */
-		usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
-				FTDI_SIO_RESET_REQUEST, FTDI_SIO_RESET_REQUEST_TYPE, 
-				FTDI_SIO_RESET_SIO, 
-				0, buf, 0, WDR_TIMEOUT);
+	/* No error checking for this (will get errors later anyway) */
+	/* See ftdi_sio.h for description of what is reset */
+	usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
+			FTDI_SIO_RESET_REQUEST, FTDI_SIO_RESET_REQUEST_TYPE, 
+			FTDI_SIO_RESET_SIO, 
+			0, buf, 0, WDR_TIMEOUT);
 
-		/* Setup termios defaults. According to tty_io.c the 
-		   settings are driver specific */
-		port->tty->termios->c_cflag =
-			B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	/* Termios defaults are set by usb_serial_init. We don't change
+	   port->tty->termios - this would loose speed settings, etc.
+	   This is same behaviour as serial.c/rs_open() - Kuba */
 
-		/* ftdi_sio_set_termios  will send usb control messages */
-		ftdi_sio_set_termios(port, &tmp_termios);	
+	/* ftdi_set_termios  will send usb control messages */
+	ftdi_set_termios(port, &tmp_termios);
 
-		/* Turn on RTS and DTR since we are not flow controlling by default */
-		if (set_dtr(serial->dev, usb_sndctrlpipe(serial->dev, 0),HIGH) < 0) {
-			err(__FUNCTION__ " Error from DTR HIGH urb");
-		}
-		if (set_rts(serial->dev, usb_sndctrlpipe(serial->dev, 0),HIGH) < 0){
-			err(__FUNCTION__ " Error from RTS HIGH urb");
-		}
-	
-		/* Start reading from the device */
-		FILL_BULK_URB(port->read_urb, serial->dev, 
-			      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-			      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-			      ftdi_sio_read_bulk_callback, port);
-		result = usb_submit_urb(port->read_urb);
-		if (result)
-			err(__FUNCTION__ " - failed submitting read urb, error %d", result);
+	/* FIXME: Flow control might be enabled, so it should be checked -
+	   we have no control of defaults! */
+	/* Turn on RTS and DTR since we are not flow controlling by default */
+	if (set_dtr(serial->dev, usb_sndctrlpipe(serial->dev, 0),HIGH) < 0) {
+		err("%s Error from DTR HIGH urb", __FUNCTION__);
+	}
+	if (set_rts(serial->dev, usb_sndctrlpipe(serial->dev, 0),HIGH) < 0){
+		err("%s Error from RTS HIGH urb", __FUNCTION__);
 	}
 
-	up (&port->sem);
+	/* Start reading from the device */
+	FILL_BULK_URB(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
+		      ftdi_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb);
+	if (result)
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+
 	return result;
-} /* ftdi_sio_open */
+} /* ftdi_open */
 
 
-static void ftdi_sio_close (struct usb_serial_port *port, struct file *filp)
-{ /* ftdi_sio_close */
+static void ftdi_close (struct usb_serial_port *port, struct file *filp)
+{ /* ftdi_close */
 	struct usb_serial *serial = port->serial; /* Checked in usbserial.c */
 	unsigned int c_cflag = port->tty->termios->c_cflag;
 	char buf[1];
 
-	dbg( __FUNCTION__);
-
-	down (&port->sem);
-	--port->open_count;
+	dbg("%s", __FUNCTION__);
 
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			if (c_cflag & HUPCL){
-				/* Disable flow control */
-				if (usb_control_msg(serial->dev, 
-						    usb_sndctrlpipe(serial->dev, 0),
-						    FTDI_SIO_SET_FLOW_CTRL_REQUEST,
-						    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-						    0, 0, buf, 0, WDR_TIMEOUT) < 0) {
-					err("error from flowcontrol urb");
-				}	    
-
-				/* drop DTR */
-				if (set_dtr(serial->dev, usb_sndctrlpipe(serial->dev, 0), LOW) < 0){
-					err("Error from DTR LOW urb");
-				}
-				/* drop RTS */
-				if (set_rts(serial->dev, usb_sndctrlpipe(serial->dev, 0),LOW) < 0) {
-					err("Error from RTS LOW urb");
-				}	
-			} /* Note change no line is hupcl is off */
-
-			/* shutdown our bulk reads and writes */
-			/* ***CHECK*** behaviour when there is nothing queued */
-			usb_unlink_urb (port->write_urb);
-			usb_unlink_urb (port->read_urb);
-		}
-		port->active = 0;
-		port->open_count = 0;
-	} else {  
-		/* Send a HUP if necessary */
-		if (!(port->tty->termios->c_cflag & CLOCAL)){
-			tty_hangup(port->tty);
-		}
+	if (serial->dev) {
+		if (c_cflag & HUPCL){
+			/* Disable flow control */
+			if (usb_control_msg(serial->dev, 
+					    usb_sndctrlpipe(serial->dev, 0),
+					    FTDI_SIO_SET_FLOW_CTRL_REQUEST,
+					    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
+					    0, 0, buf, 0, WDR_TIMEOUT) < 0) {
+				err("error from flowcontrol urb");
+			}	    
+
+			/* drop DTR */
+			if (set_dtr(serial->dev, usb_sndctrlpipe(serial->dev, 0), LOW) < 0){
+				err("Error from DTR LOW urb");
+			}
+			/* drop RTS */
+			if (set_rts(serial->dev, usb_sndctrlpipe(serial->dev, 0),LOW) < 0) {
+				err("Error from RTS LOW urb");
+			}	
+		} /* Note change no line is hupcl is off */
+
+		/* shutdown our bulk reads and writes */
+		/* ***CHECK*** behaviour when there is nothing queued */
+		usb_unlink_urb (port->write_urb);
+		usb_unlink_urb (port->read_urb);
 	}
-
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
-
-} /* ftdi_sio_close */
+} /* ftdi_close */
 
 
   
@@ -433,16 +622,16 @@
  *  B1 0
  *  B2..7 length of message excluding byte 0
  */
-static int ftdi_sio_write (struct usb_serial_port *port, int from_user, 
+static int ftdi_write (struct usb_serial_port *port, int from_user,
 			   const unsigned char *buf, int count)
-{ /* ftdi_sio_write */
+{ /* ftdi_write */
 	struct usb_serial *serial = port->serial;
 	struct ftdi_private *priv = (struct ftdi_private *)port->private;
 	unsigned char *first_byte = port->write_urb->transfer_buffer;
 	int data_offset ;
 	int result;
 	
-	dbg(__FUNCTION__ " port %d, %d bytes", port->number, count);
+	dbg("%s port %d, %d bytes", __FUNCTION__, port->number, count);
 
 	if (count == 0) {
 		err("write request of 0 bytes");
@@ -453,20 +642,17 @@
         dbg("data_offset set to %d",data_offset);
 
 	if (port->write_urb->status == -EINPROGRESS) {
-		dbg (__FUNCTION__ " - already writing");
+		dbg("%s - already writing", __FUNCTION__);
 		return (0);
 	}		
 
-	down(&port->sem);
-
 	count += data_offset;
 	count = (count > port->bulk_out_size) ? port->bulk_out_size : count;
 
-		/* Copy in the data to send */
+	/* Copy in the data to send */
 	if (from_user) {
 		if (copy_from_user(port->write_urb->transfer_buffer + data_offset,
 				   buf, count - data_offset )){
-			up (&port->sem);
 			return -EFAULT;
 		}
 	} else {
@@ -480,41 +666,39 @@
 		*first_byte = 1 | ((count-data_offset) << 2) ; 
 	}
 
-	dbg(__FUNCTION__ " Bytes: %d, First Byte: 0x%02x",count, first_byte[0]);
+	dbg("%s Bytes: %d, First Byte: 0x%02x", __FUNCTION__,count, first_byte[0]);
 	usb_serial_debug_data (__FILE__, __FUNCTION__, count, first_byte);
 		
 	/* send the data out the bulk port */
 	FILL_BULK_URB(port->write_urb, serial->dev, 
 		      usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress),
 		      port->write_urb->transfer_buffer, count,
-		      ftdi_sio_write_bulk_callback, port);
+		      ftdi_write_bulk_callback, port);
 		
 	result = usb_submit_urb(port->write_urb);
 	if (result) {
-		err(__FUNCTION__ " - failed submitting write urb, error %d", result);
-		up (&port->sem);
+		err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 		return 0;
 	}
-	up (&port->sem);
 
-	dbg(__FUNCTION__ " write returning: %d", count - data_offset);
+	dbg("%s write returning: %d", __FUNCTION__, count - data_offset);
 	return (count - data_offset);
+} /* ftdi_write */
 
-} /* ftdi_sio_write */
 
-static void ftdi_sio_write_bulk_callback (struct urb *urb)
+static void ftdi_write_bulk_callback (struct urb *urb)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct usb_serial *serial;
 
-	dbg("ftdi_sio_write_bulk_callback");
+	dbg("%s", __FUNCTION__);
 
-	if (port_paranoia_check (port, "ftdi_sio_write_bulk_callback")) {
+	if (port_paranoia_check (port, "ftdi_write_bulk_callback")) {
 		return;
 	}
 	
 	serial = port->serial;
-	if (serial_paranoia_check (serial, "ftdi_sio_write_bulk_callback")) {
+	if (serial_paranoia_check (serial, "ftdi_write_bulk_callback")) {
 		return;
 	}
 	
@@ -526,13 +710,14 @@
 	mark_bh(IMMEDIATE_BH);
 
 	return;
-} /* ftdi_sio_write_bulk_callback */
+} /* ftdi_write_bulk_callback */
 
 
-static int ftdi_sio_write_room( struct usb_serial_port *port )
+static int ftdi_write_room( struct usb_serial_port *port )
 {
 	struct ftdi_private *priv = (struct ftdi_private *)port->private;
 	int room;
+
 	if ( port->write_urb->status == -EINPROGRESS) {
 		/* There is a race here with the _write routines but it won't hurt */
 		room = 0;
@@ -540,16 +725,15 @@
 		room = port->bulk_out_size - priv->write_offset;
 	}
 	return(room);
+} /* ftdi_write_room */
 
 
-} /* ftdi_sio_write_room */
-
-
-static void ftdi_sio_read_bulk_callback (struct urb *urb)
-{ /* ftdi_sio_serial_buld_callback */
+static void ftdi_read_bulk_callback (struct urb *urb)
+{ /* ftdi_read_bulk_callback */
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct usb_serial *serial;
        	struct tty_struct *tty = port->tty ;
+	struct ftdi_private *priv = (struct ftdi_private *) port->private;
 	char error_flag;
        	unsigned char *data = urb->transfer_buffer;
 
@@ -557,7 +741,7 @@
 	int i;
 	int result;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (port_paranoia_check (port, "ftdi_sio_read_bulk_callback")) {
 		return;
@@ -586,6 +770,16 @@
 	/* See acm.c - you do a tty_hangup  - eg tty_hangup(tty) */
 	/* if CD is dropped and the line is not CLOCAL then we should hangup */
 
+	/* Compare new line status to the old one, signal if different */
+	if (priv != NULL) {
+		char new_status = data[0] & FTDI_STATUS_B0_MASK;
+		if (new_status != priv->prev_status) {
+			priv->diff_status |= new_status ^ priv->prev_status;
+			wake_up_interruptible(&priv->delta_msr_wait);
+			priv->prev_status = new_status;
+		}
+	}
+
 	/* Handle errors and break */
 	error_flag = TTY_NORMAL;
         /* Although the device uses a bitmask and hence can have multiple */
@@ -652,63 +846,17 @@
 	FILL_BULK_URB(port->read_urb, serial->dev, 
 		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
 		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-		      ftdi_sio_read_bulk_callback, port);
+		      ftdi_read_bulk_callback, port);
 
 	result = usb_submit_urb(port->read_urb);
 	if (result)
-		err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 
 	return;
-} /* ftdi_sio_serial_read_bulk_callback */
-
-
-static __u16 translate_baudrate_to_ftdi(unsigned int cflag, ftdi_type_t ftdi_type) 
-{ /* translate_baudrate_to_ftdi */
-	
-	__u16 urb_value = ftdi_sio_b9600;
+} /* ftdi_read_bulk_callback */
 
-	if (ftdi_type == sio){
-		switch(cflag & CBAUD){
-		case B0: break; /* ignored by this */
-		case B300: urb_value = ftdi_sio_b300; dbg("Set to 300"); break;
-		case B600: urb_value = ftdi_sio_b600; dbg("Set to 600") ; break;
-		case B1200: urb_value = ftdi_sio_b1200; dbg("Set to 1200") ; break;
-		case B2400: urb_value = ftdi_sio_b2400; dbg("Set to 2400") ; break;
-		case B4800: urb_value = ftdi_sio_b4800; dbg("Set to 4800") ; break;
-		case B9600: urb_value = ftdi_sio_b9600; dbg("Set to 9600") ; break;
-		case B19200: urb_value = ftdi_sio_b19200; dbg("Set to 19200") ; break;
-		case B38400: urb_value = ftdi_sio_b38400; dbg("Set to 38400") ; break;
-		case B57600: urb_value = ftdi_sio_b57600; dbg("Set to 57600") ; break;
-		case B115200: urb_value = ftdi_sio_b115200; dbg("Set to 115200") ; break;
-		default: dbg(__FUNCTION__ " FTDI_SIO does not support the baudrate (%d) requested",
-			     (cflag & CBAUD)); 
-		   break;
-		}
-	} else { /* it is 8U232AM */
-		switch(cflag & CBAUD){
-		case B0: break; /* ignored by this */
-		case B300: urb_value = ftdi_8U232AM_48MHz_b300; dbg("Set to 300"); break;
-		case B600: urb_value = ftdi_8U232AM_48MHz_b600; dbg("Set to 600") ; break;
-		case B1200: urb_value = ftdi_8U232AM_48MHz_b1200; dbg("Set to 1200") ; break;
-		case B2400: urb_value = ftdi_8U232AM_48MHz_b2400; dbg("Set to 2400") ; break;
-		case B4800: urb_value = ftdi_8U232AM_48MHz_b4800; dbg("Set to 4800") ; break;
-		case B9600: urb_value = ftdi_8U232AM_48MHz_b9600; dbg("Set to 9600") ; break;
-		case B19200: urb_value = ftdi_8U232AM_48MHz_b19200; dbg("Set to 19200") ; break;
-		case B38400: urb_value = ftdi_8U232AM_48MHz_b38400; dbg("Set to 38400") ; break;
-		case B57600: urb_value = ftdi_8U232AM_48MHz_b57600; dbg("Set to 57600") ; break;
-		case B115200: urb_value = ftdi_8U232AM_48MHz_b115200; dbg("Set to 115200") ; break;
-		case B230400: urb_value = ftdi_8U232AM_48MHz_b230400; dbg("Set to 230400") ; break;
-		case B460800: urb_value = ftdi_8U232AM_48MHz_b460800; dbg("Set to 460800") ; break;
-		case B921600: urb_value = ftdi_8U232AM_48MHz_b921600; dbg("Set to 921600") ; break;
-		default: dbg(__FUNCTION__ " The baudrate (%d) requested is not implemented",
-			     (cflag & CBAUD)); 
-		   break;
-		}
-	}
-	return(urb_value);
-}
 
-static void ftdi_sio_break_ctl( struct usb_serial_port *port, int break_state )
+static void ftdi_break_ctl( struct usb_serial_port *port, int break_state )
 {
 	struct usb_serial *serial = port->serial;
 	struct ftdi_private *priv = (struct ftdi_private *)port->private;
@@ -731,22 +879,21 @@
 			    FTDI_SIO_SET_DATA_REQUEST_TYPE,
 			    urb_value , 0,
 			    buf, 0, WDR_TIMEOUT) < 0) {
-		err(__FUNCTION__ " FAILED to enable/disable break state (state was %d)",break_state);
+		err("%s FAILED to enable/disable break state (state was %d)", __FUNCTION__,break_state);
 	}	   
 
-	dbg(__FUNCTION__ " break state is %d - urb is %d",break_state, urb_value);
+	dbg("%s break state is %d - urb is %d", __FUNCTION__,break_state, urb_value);
 	
 }
 
 
+/* old_termios contains the original termios settings and tty->termios contains
+ * the new setting to be used
+ * WARNING: set_termios calls this with old_termios in kernel space
+ */
 
-/* As I understand this - old_termios contains the original termios settings */
-/*  and tty->termios contains the new setting to be used */
-/* */
-/*   WARNING: set_termios calls this with old_termios in kernel space */
-
-static void ftdi_sio_set_termios (struct usb_serial_port *port, struct termios *old_termios)
-{ /* ftdi_sio_set_termios */
+static void ftdi_set_termios (struct usb_serial_port *port, struct termios *old_termios)
+{ /* ftdi_termios */
 	struct usb_serial *serial = port->serial;
 	unsigned int cflag = port->tty->termios->c_cflag;
 	struct ftdi_private *priv = (struct ftdi_private *)port->private;	
@@ -754,7 +901,7 @@
 	char buf[1]; /* Perhaps I should dynamically alloc this? */
 	
 	
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 
 	/* FIXME -For this cut I don't care if the line is really changing or 
@@ -793,12 +940,10 @@
 			    FTDI_SIO_SET_DATA_REQUEST_TYPE,
 			    urb_value , 0,
 			    buf, 0, 100) < 0) {
-		err(__FUNCTION__ " FAILED to set databits/stopbits/parity");
+		err("%s FAILED to set databits/stopbits/parity", __FUNCTION__);
 	}	   
 
 	/* Now do the baudrate */
-	urb_value = translate_baudrate_to_ftdi((cflag & CBAUD), priv->ftdi_type);
-	
 	if ((cflag & CBAUD) == B0 ) {
 		/* Disable flow control */
 		if (usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
@@ -806,31 +951,27 @@
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
 				    0, 0, 
 				    buf, 0, WDR_TIMEOUT) < 0) {
-			err(__FUNCTION__ " error from disable flowcontrol urb");
+			err("%s error from disable flowcontrol urb", __FUNCTION__);
 		}	    
 		/* Drop RTS and DTR */
 		if (set_dtr(serial->dev, usb_sndctrlpipe(serial->dev, 0),LOW) < 0){
-			err(__FUNCTION__ " Error from DTR LOW urb");
+			err("%s Error from DTR LOW urb", __FUNCTION__);
 		}
 		if (set_rts(serial->dev, usb_sndctrlpipe(serial->dev, 0),LOW) < 0){
-			err(__FUNCTION__ " Error from RTS LOW urb");
+			err("%s Error from RTS LOW urb", __FUNCTION__);
 		}	
 		
 	} else {
 		/* set the baudrate determined before */
-		if (usb_control_msg(serial->dev, 
-				    usb_sndctrlpipe(serial->dev, 0),
-				    FTDI_SIO_SET_BAUDRATE_REQUEST, 
-				    FTDI_SIO_SET_BAUDRATE_REQUEST_TYPE,
-				    urb_value, 0, 
-				    buf, 0, 100) < 0) {
-			err(__FUNCTION__ " urb failed to set baurdrate");
+		if (change_speed(port)) {
+			err("%s urb failed to set baurdrate", __FUNCTION__);
 		}
 	}
+
 	/* Set flow control */
 	/* Note device also supports DTR/CD (ugh) and Xon/Xoff in hardware */
 	if (cflag & CRTSCTS) {
-		dbg(__FUNCTION__ " Setting to CRTSCTS flow control");
+		dbg("%s Setting to CRTSCTS flow control", __FUNCTION__);
 		if (usb_control_msg(serial->dev, 
 				    usb_sndctrlpipe(serial->dev, 0),
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST, 
@@ -842,7 +983,7 @@
 		
 	} else { 
 		/* CHECKME Assuming XON/XOFF handled by tty stack - not by device */
-		dbg(__FUNCTION__ " Turning off hardware flow control");
+		dbg("%s Turning off hardware flow control", __FUNCTION__);
 		if (usb_control_msg(serial->dev, 
 				    usb_sndctrlpipe(serial->dev, 0),
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST, 
@@ -854,24 +995,27 @@
 		
 	}
 	return;
-} /* ftdi_sio_set_termios */
+} /* ftdi_termios */
+
 
-static int ftdi_sio_ioctl (struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg)
+static int ftdi_ioctl (struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg)
 {
 	struct usb_serial *serial = port->serial;
 	struct ftdi_private *priv = (struct ftdi_private *)port->private;
+
 	__u16 urb_value=0; /* Will hold the new flags */
 	char buf[2];
 	int  ret, mask;
 	
-	dbg(__FUNCTION__ " cmd 0x%04x", cmd);
+	dbg("%s cmd 0x%04x", __FUNCTION__, cmd);
 
 	/* Based on code from acm.c and others */
 	switch (cmd) {
 
 	case TIOCMGET:
-		dbg(__FUNCTION__ " TIOCMGET");
-		if (priv->ftdi_type == sio){
+		dbg("%s TIOCMGET", __FUNCTION__);
+		switch (priv->chip_type) {
+		case SIO:
 			/* Request the status from the device */
 			if ((ret = usb_control_msg(serial->dev, 
 						   usb_rcvctrlpipe(serial->dev, 0),
@@ -879,12 +1023,13 @@
 						   FTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE,
 						   0, 0, 
 						   buf, 1, WDR_TIMEOUT)) < 0 ) {
-				err(__FUNCTION__ " Could not get modem status of device - err: %d",
+				err("%s Could not get modem status of device - err: %d", __FUNCTION__,
 				    ret);
 				return(ret);
 			}
-		} else {
-			/* the 8U232AM returns a two byte value (the sio is a 1 byte value) - in the same 
+			break;
+		case FT8U232AM:
+			/* the 8U232AM returns a two byte value (the sio is a 1 byte value) - in the same
 			   format as the data returned from the in point */
 			if ((ret = usb_control_msg(serial->dev, 
 						   usb_rcvctrlpipe(serial->dev, 0),
@@ -892,10 +1037,14 @@
 						   FTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE,
 						   0, 0, 
 						   buf, 2, WDR_TIMEOUT)) < 0 ) {
-				err(__FUNCTION__ " Could not get modem status of device - err: %d",
+				err("%s Could not get modem status of device - err: %d", __FUNCTION__,
 				    ret);
 				return(ret);
 			}
+			break;
+		default:
+			return -EFAULT;
+			break;
 		}
 
 		return put_user((buf[0] & FTDI_SIO_DSR_MASK ? TIOCM_DSR : 0) |
@@ -906,7 +1055,7 @@
 		break;
 
 	case TIOCMSET: /* Turns on and off the lines as specified by the mask */
-		dbg(__FUNCTION__ " TIOCMSET");
+		dbg("%s TIOCMSET", __FUNCTION__);
 		if (get_user(mask, (unsigned long *) arg))
 			return -EFAULT;
 		urb_value = ((mask & TIOCM_DTR) ? HIGH : LOW);
@@ -920,7 +1069,7 @@
 		break;
 					
 	case TIOCMBIS: /* turns on (Sets) the lines as specified by the mask */
-		dbg(__FUNCTION__ " TIOCMBIS");
+		dbg("%s TIOCMBIS", __FUNCTION__);
  	        if (get_user(mask, (unsigned long *) arg))
 			return -EFAULT;
   	        if (mask & TIOCM_DTR){
@@ -942,7 +1091,7 @@
 					break;
 
 	case TIOCMBIC: /* turns off (Clears) the lines as specified by the mask */
-		dbg(__FUNCTION__ " TIOCMBIC");
+		dbg("%s TIOCMBIC", __FUNCTION__);
  	        if (get_user(mask, (unsigned long *) arg))
 			return -EFAULT;
   	        if (mask & TIOCM_DTR){
@@ -972,38 +1121,83 @@
 		 *
 		 */
 
+	case TIOCGSERIAL: /* gets serial port data */
+		return get_serial_info(port, (struct serial_struct *) arg);
+
+	case TIOCSSERIAL: /* sets serial port data */
+		return set_serial_info(port, (struct serial_struct *) arg);
+
+	/*
+	 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+	 * - mask passed in arg for lines of interest
+	 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+	 * Caller should use TIOCGICOUNT to see which one it was.
+	 *
+	 * This code is borrowed from linux/drivers/char/serial.c
+	 */
+	case TIOCMIWAIT:
+		while (priv != NULL) {
+			interruptible_sleep_on(&priv->delta_msr_wait);
+			/* see if a signal did it */
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+			else {
+				char diff = priv->diff_status;
+
+				if (diff == 0) {
+					return -EIO; /* no change => error */
+				}
+
+				/* Consume all events */
+				priv->diff_status = 0;
+
+				/* Return 0 if caller wanted to know about these bits */
+				if ( ((arg & TIOCM_RNG) && (diff & FTDI_RS0_RI)) ||
+				     ((arg & TIOCM_DSR) && (diff & FTDI_RS0_DSR)) ||
+				     ((arg & TIOCM_CD)  && (diff & FTDI_RS0_RLSD)) ||
+				     ((arg & TIOCM_CTS) && (diff & FTDI_RS0_CTS)) ) {
+					return 0;
+				}
+				/*
+				 * Otherwise caller can't care less about what happened,
+				 * and so we continue to wait for more events.
+				 */
+			}
+		}
+		/* NOTREACHED */
+
 	default:
 	  /* This is not an error - turns out the higher layers will do 
 	   *  some ioctls itself (see comment above)
  	   */
-		dbg(__FUNCTION__ " arg not supported - it was 0x%04x",cmd);
+		dbg("%s arg not supported - it was 0x%04x", __FUNCTION__,cmd);
 		return(-ENOIOCTLCMD);
 		break;
 	}
 	return 0;
-} /* ftdi_sio_ioctl */
+} /* ftdi_ioctl */
 
 
-static int __init ftdi_sio_init (void)
+static int __init ftdi_init (void)
 {
-	dbg(__FUNCTION__);
-	usb_serial_register (&ftdi_sio_device);
+	dbg("%s", __FUNCTION__);
+	usb_serial_register (&ftdi_SIO_device);
 	usb_serial_register (&ftdi_8U232AM_device);
 	info(DRIVER_VERSION ":" DRIVER_DESC);
 	return 0;
 }
 
 
-static void __exit ftdi_sio_exit (void)
+static void __exit ftdi_exit (void)
 {
-	dbg(__FUNCTION__);
-	usb_serial_deregister (&ftdi_sio_device);
+	dbg("%s", __FUNCTION__);
+	usb_serial_deregister (&ftdi_SIO_device);
 	usb_serial_deregister (&ftdi_8U232AM_device);
 }
 
 
-module_init(ftdi_sio_init);
-module_exit(ftdi_sio_exit);
+module_init(ftdi_init);
+module_exit(ftdi_exit);
 
 MODULE_AUTHOR( DRIVER_AUTHOR );
 MODULE_DESCRIPTION( DRIVER_DESC );
diff -Nur linux-2.4.19.old/drivers/usb/serial/ftdi_sio.h linux-2.4.19/drivers/usb/serial/ftdi_sio.h
--- linux-2.4.19.old/drivers/usb/serial/ftdi_sio.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/ftdi_sio.h	Mon Nov 25 12:27:08 2002
@@ -81,17 +81,36 @@
 /*
  * BmRequestType:  0100 0000B
  * bRequest:       FTDI_SIO_SET_BAUDRATE
- * wValue:         BaudRate value - see below
+ * wValue:         BaudDivisor value - see below
  * wIndex:         Port
  * wLength:        0
  * Data:           None
+ * The BaudDivisor values are calculated as follows:
+ * - BaseClock is either 12000000 or 48000000 depending on the device. FIXME: I wish
+ *   I knew how to detect old chips to select proper base clock!
+ * - BaudDivisor is a fixed point number encoded in a funny way.
+ *   (--WRONG WAY OF THINKING--)
+ *   BaudDivisor is a fixed point number encoded with following bit weighs:
+ *   (-2)(-1)(13..0). It is a radical with a denominator of 4, so values
+ *   end with 0.0 (00...), 0.25 (10...), 0.5 (01...), and 0.75 (11...).
+ *   (--THE REALITY--)
+ *   The both-bits-set has quite different meaning from 0.75 - the chip designers
+ *   have decided it to mean 0.125 instead of 0.75.
+ *   This info looked up in FTDI application note "FT8U232 DEVICES \ Data Rates
+ *   and Flow Control Consideration for USB to RS232".
+ * - BaudDivisor = (BaseClock / 16) / BaudRate, where the (=) operation should
+ *   automagically re-encode the resulting value to take fractions into consideration.
+ * As all values are integers, some bit twiddling is in order:
+ *   BaudDivisor = (BaseClock / 16 / BaudRate) |
+ *   (((BaseClock / 2 / BaudRate) & 2) ? 0x8000 : 0) | // 0.25
+ *   (((BaseClock / 2 / BaudRate) & 4) ? 0x4000 : 0) | // 0.5
+ *   (((BaseClock / 2 / BaudRate) & 0x7) == 1 ? 0xc000) // 0.125 - this line due to funny encoding only
  */
 
 typedef enum {
-	sio = 1,
-	F8U232AM = 2,
-} ftdi_type_t;
-
+	SIO = 1,
+	FT8U232AM = 2,
+} ftdi_chip_type_t;
 
 typedef enum {
  ftdi_sio_b300 = 0, 
@@ -106,37 +125,18 @@
  ftdi_sio_b115200 = 9
 } FTDI_SIO_baudrate_t ;
 
+#define FTDI_SIO_BASE_BAUD_TO_DIVISOR(base, baud) ( \
+((base/2/baud) >> 3) | \
+(((base/2/baud) & 2) ? 0x8000 : 0) | \
+(((base/2/baud) & 4) ? 0x4000 : 0) | \
+((((base/2/baud) & 0x7) == 1) ? 0xc000 : 0) )
 
-typedef enum {
-  ftdi_8U232AM_12MHz_b300 = 0x09c4,
-  ftdi_8U232AM_12MHz_b600 = 0x04E2,
-  ftdi_8U232AM_12MHz_b1200 = 0x0271,
-  ftdi_8U232AM_12MHz_b2400 = 0x4138,
-  ftdi_8U232AM_12MHz_b4800 = 0x809c,
-  ftdi_8U232AM_12MHz_b9600 = 0xc04e,
-  ftdi_8U232AM_12MHz_b19200 = 0x0027,
-  ftdi_8U232AM_12MHz_b38400 = 0x4013,
-  ftdi_8U232AM_12MHz_b57600 = 0x000d,
-  ftdi_8U232AM_12MHz_b115200 = 0x4006,
-  ftdi_8U232AM_12MHz_b230400 = 0x8003,
-} FTDI_8U232AM_12MHz_baudrate_t;
-/* Apparently all devices are 48MHz */
-typedef enum {
-  ftdi_8U232AM_48MHz_b300 = 0x2710,
-  ftdi_8U232AM_48MHz_b600 = 0x1388,
-  ftdi_8U232AM_48MHz_b1200 = 0x09c4,
-  ftdi_8U232AM_48MHz_b2400 = 0x04e2,
-  ftdi_8U232AM_48MHz_b4800 = 0x0271,
-  ftdi_8U232AM_48MHz_b9600 = 0x4138,
-  ftdi_8U232AM_48MHz_b19200 = 0x809c,
-  ftdi_8U232AM_48MHz_b38400 = 0xc04e,
-  ftdi_8U232AM_48MHz_b57600 = 0x0034,
-  ftdi_8U232AM_48MHz_b115200 = 0x001a,
-  ftdi_8U232AM_48MHz_b230400 = 0x000d,
-  ftdi_8U232AM_48MHz_b460800 = 0x4006,
-  ftdi_8U232AM_48MHz_b921600 = 0x8003,
+#define FTDI_SIO_BAUD_TO_DIVISOR(baud) FTDI_SIO_BASE_BAUD_TO_DIVISOR(48000000, baud)
 
-} FTDI_8U232AM_48MHz_baudrate_t;
+/*
+ * The ftdi_8U232AM_xxMHz_byyy constans have been removed. Their values can
+ * be calculated as follows: FTDI_SIO_BAUD_TO_DIVISOR(xx000000, yyy)
+ */
 
 #define FTDI_SIO_SET_DATA_REQUEST FTDI_SIO_SET_DATA
 #define FTDI_SIO_SET_DATA_REQUEST_TYPE 0x40
@@ -440,6 +440,11 @@
  * B7	Error in RCVR FIFO
  * 
  */
+#define FTDI_RS0_CTS	(1 << 4)
+#define FTDI_RS0_DSR	(1 << 5)
+#define FTDI_RS0_RI	(1 << 6)
+#define FTDI_RS0_RLSD	(1 << 7)
+
 #define FTDI_RS_DR  1
 #define FTDI_RS_OE (1<<1)
 #define FTDI_RS_PE (1<<2)
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_edgeport.c linux-2.4.19/drivers/usb/serial/io_edgeport.c
--- linux-2.4.19.old/drivers/usb/serial/io_edgeport.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/io_edgeport.c	Mon Nov 25 12:27:08 2002
@@ -242,13 +242,9 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
@@ -256,7 +252,7 @@
 #include <linux/spinlock.h>
 #include <linux/serial.h>
 #include <linux/ioctl.h>
-#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -274,7 +270,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v2.2"
+#define DRIVER_VERSION "v2.3"
 #define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com> and David Iacovelli"
 #define DRIVER_DESC "Edgeport USB Serial Driver"
 
@@ -372,8 +368,8 @@
 struct edgeport_serial {
 	char			name[MAX_NAME_LEN+1];		/* string name of this device */
 
-	EDGE_MANUF_DESCRIPTOR		manuf_descriptor;	/* the manufacturer descriptor */
-	EDGE_BOOT_DESCRIPTOR		boot_descriptor;	/* the boot firmware descriptor */
+	struct edge_manuf_descriptor	manuf_descriptor;	/* the manufacturer descriptor */
+	struct edge_boot_descriptor	boot_descriptor;	/* the boot firmware descriptor */
 	struct edgeport_product_info	product_info;		/* Product Info */
 
 	__u8			interrupt_in_endpoint;		/* the interrupt endpoint handle */
@@ -400,17 +396,17 @@
 };
 
 /* baud rate information */
-typedef struct _DIVISOR_TABLE_ENTRY {
+struct divisor_table_entry {
 	__u32   BaudRate;
 	__u16  Divisor;
-} DIVISOR_TABLE_ENTRY, *PDIVISOR_TABLE_ENTRY;
+};
 
 //
 // Define table of divisors for Rev A EdgePort/4 hardware
 // These assume a 3.6864MHz crystal, the standard /16, and
 // MCR.7 = 0.
 //
-static DIVISOR_TABLE_ENTRY  DivisorTable[] = {
+static struct divisor_table_entry divisor_table[] = {
 	{   75,		3072},  
 	{   110,	2095},		/* 2094.545455 => 230450   => .0217 % over */
 	{   134,	1713},		/* 1713.011152 => 230398.5 => .00065% under */
@@ -510,7 +506,7 @@
 	__u16 BootBuildNumber;
 	__u8 *BootImage;      
 	__u32 BootSize;
-	PEDGE_FIRMWARE_IMAGE_RECORD record;
+	struct edge_firmware_image_record *record;
 	unsigned char *firmware;
 	int response;
 
@@ -566,13 +562,13 @@
 		firmware = BootImage;
 
 		for (;;) {
-			record = (PEDGE_FIRMWARE_IMAGE_RECORD)firmware;
+			record = (struct edge_firmware_image_record *)firmware;
 			response = rom_write (edge_serial->serial, record->ExtAddr, record->Addr, record->Len, &record->Data[0]);
 			if (response < 0) {
 				err("sram_write failed (%x, %x, %d)", record->ExtAddr, record->Addr, record->Len);
 				break;
 			}
-			firmware += sizeof (EDGE_FIRMWARE_IMAGE_RECORD) + record->Len;
+			firmware += sizeof (struct edge_firmware_image_record) + record->Len;
 			if (firmware >= &BootImage[BootSize]) {
 				break;
 			}
@@ -593,7 +589,7 @@
 	struct usb_string_descriptor StringDesc;
 	struct usb_string_descriptor *pStringDesc;
 
-	dbg(__FUNCTION__ " - USB String ID = %d", Id );
+	dbg("%s - USB String ID = %d", __FUNCTION__, Id );
 
 	if (!usb_get_descriptor(dev, USB_DT_STRING, Id, &StringDesc, sizeof(StringDesc))) {
 		return 0;
@@ -628,7 +624,7 @@
 	struct usb_string_descriptor StringDesc;
 	struct usb_string_descriptor *pStringDesc;
 
-	dbg(__FUNCTION__ " - USB String ID = %d", Id );
+	dbg("%s - USB String ID = %d", __FUNCTION__, Id );
 
 	if (!usb_get_descriptor(dev, USB_DT_STRING, Id, &StringDesc, sizeof(StringDesc))) {
 		return 0;
@@ -763,14 +759,14 @@
 	int portNumber;
 	int result;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (serial_paranoia_check (edge_serial->serial, __FUNCTION__)) {
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__" - nonzero control read status received: %d", urb->status);
+		dbg("%s - nonzero control read status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -782,7 +778,7 @@
 			bytes_avail = data[0] | (data[1] << 8);
 			if (bytes_avail) {
 				edge_serial->rxBytesAvail += bytes_avail;
-				dbg(__FUNCTION__" - bytes_avail = %d, rxBytesAvail %d", bytes_avail, edge_serial->rxBytesAvail);
+				dbg("%s - bytes_avail = %d, rxBytesAvail %d", __FUNCTION__, bytes_avail, edge_serial->rxBytesAvail);
 
 				if ((edge_serial->rxBytesAvail > 0) &&
 				    (edge_serial->read_urb->status != -EINPROGRESS)) {
@@ -792,7 +788,7 @@
 					edge_serial->read_urb->dev = edge_serial->serial->dev;
 					result = usb_submit_urb(edge_serial->read_urb);
 					if (result) {
-						dbg(__FUNCTION__" - usb_submit_urb(read bulk) failed with result = %d", result);
+						dbg("%s - usb_submit_urb(read bulk) failed with result = %d", __FUNCTION__, result);
 					}
 				}
 			}
@@ -808,10 +804,11 @@
 					edge_port = (struct edgeport_port *)port->private;
 					if (edge_port->open) {
 						edge_port->txCredits += txCredits;
-						dbg(__FUNCTION__" - txcredits for port%d = %d", portNumber, edge_port->txCredits);
+						dbg("%s - txcredits for port%d = %d", __FUNCTION__, portNumber, edge_port->txCredits);
 
 						/* tell the tty driver that something has changed */
-						wake_up_interruptible(&edge_port->port->tty->write_wait);
+						if (edge_port->port->tty)
+							wake_up_interruptible(&edge_port->port->tty->write_wait);
 
 						// Since we have more credit, check if more data can be sent
 						send_more_port_data(edge_serial, edge_port);
@@ -837,14 +834,14 @@
 	int			status;
 	__u16			raw_data_length;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (serial_paranoia_check (edge_serial->serial, __FUNCTION__)) {
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__" - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -856,7 +853,7 @@
 		/* decrement our rxBytes available by the number that we just got */
 		edge_serial->rxBytesAvail -= raw_data_length;
 
-		dbg(__FUNCTION__" - Received = %d, rxBytesAvail %d", raw_data_length, edge_serial->rxBytesAvail);
+		dbg("%s - Received = %d, rxBytesAvail %d", __FUNCTION__, raw_data_length, edge_serial->rxBytesAvail);
 
 		process_rcvd_data (edge_serial, data, urb->actual_length);
 
@@ -869,7 +866,7 @@
 			edge_serial->read_urb->dev = edge_serial->serial->dev;
 			status = usb_submit_urb(edge_serial->read_urb);
 			if (status) {
-				err(__FUNCTION__" - usb_submit_urb(read bulk) failed, status = %d", status);
+				err("%s - usb_submit_urb(read bulk) failed, status = %d", __FUNCTION__, status);
 			}
 		}
 	}
@@ -886,25 +883,27 @@
 	struct edgeport_port *edge_port = (struct edgeport_port *)urb->context;
 	struct tty_struct *tty;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (port_paranoia_check (edge_port->port, __FUNCTION__)) {
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__" - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 	}
 
 	tty = edge_port->port->tty;
 
-	/* let the tty driver wakeup if it has a special write_wakeup function */
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
-		(tty->ldisc.write_wakeup)(tty);
-	}
+	if (tty) {
+		/* let the tty driver wakeup if it has a special write_wakeup function */
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
+			(tty->ldisc.write_wakeup)(tty);
+		}
 
-	/* tell the tty driver that something has changed */
-	wake_up_interruptible(&tty->write_wait);
+		/* tell the tty driver that something has changed */
+		wake_up_interruptible(&tty->write_wait);
+	}
 
 	// Release the Write URB
 	edge_port->write_in_progress = FALSE;
@@ -925,10 +924,10 @@
 	struct tty_struct *tty;
 	int status = urb->status;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	CmdUrbs--;
-	dbg(__FUNCTION__" - FREE URB %p (outstanding %d)", urb, CmdUrbs);
+	dbg("%s - FREE URB %p (outstanding %d)", __FUNCTION__, urb, CmdUrbs);
 
 
 	/* clean up the transfer buffer */
@@ -945,7 +944,7 @@
 	}
 
 	if (status) {
-		dbg(__FUNCTION__" - nonzero write bulk status received: %d", status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, status);
 		return;
 	}
 
@@ -953,7 +952,8 @@
 	tty = edge_port->port->tty;
 
 	/* tell the tty driver that something has changed */
-	wake_up_interruptible(&tty->write_wait);
+	if (tty)
+		wake_up_interruptible(&tty->write_wait);
 
 	/* we have completed the command */
 	edge_port->commandPending = FALSE;
@@ -982,139 +982,124 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return -ENODEV;
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (edge_port == NULL)
 		return -ENODEV;
 
-	++port->open_count;
-	MOD_INC_USE_COUNT;
-	
-	if (!port->active) {
-		port->active = 1;
-
-		/* force low_latency on so that our tty_push actually forces the data through, 
-		   otherwise it is scheduled, and with high data rates (like with OHCI) data
-		   can get lost. */
+	/* force low_latency on so that our tty_push actually forces the data through, 
+	   otherwise it is scheduled, and with high data rates (like with OHCI) data
+	   can get lost. */
+	if (port->tty)
 		port->tty->low_latency = 1;
+
+	/* see if we've set up our endpoint info yet (can't set it up in edge_startup
+	   as the structures were not set up at that time.) */
+	serial = port->serial;
+	edge_serial = (struct edgeport_serial *)serial->private;
+	if (edge_serial == NULL) {
+		return -ENODEV;
+	}
+	if (edge_serial->interrupt_in_buffer == NULL) {
+		struct usb_serial_port *port0 = &serial->port[0];
+		
+		/* not set up yet, so do it now */
+		edge_serial->interrupt_in_buffer = port0->interrupt_in_buffer;
+		edge_serial->interrupt_in_endpoint = port0->interrupt_in_endpointAddress;
+		edge_serial->interrupt_read_urb = port0->interrupt_in_urb;
+		edge_serial->bulk_in_buffer = port0->bulk_in_buffer;
+		edge_serial->bulk_in_endpoint = port0->bulk_in_endpointAddress;
+		edge_serial->read_urb = port0->read_urb;
+		edge_serial->bulk_out_endpoint = port0->bulk_out_endpointAddress;
 	
-		/* see if we've set up our endpoint info yet (can't set it up in edge_startup
-		   as the structures were not set up at that time.) */
-		serial = port->serial;
-		edge_serial = (struct edgeport_serial *)serial->private;
-		if (edge_serial == NULL) {
-			port->active = 0;
-			port->open_count = 0;
-			MOD_DEC_USE_COUNT;
-			return -ENODEV;
-		}
-		if (edge_serial->interrupt_in_buffer == NULL) {
-			struct usb_serial_port *port0 = &serial->port[0];
-			
-			/* not set up yet, so do it now */
-			edge_serial->interrupt_in_buffer = port0->interrupt_in_buffer;
-			edge_serial->interrupt_in_endpoint = port0->interrupt_in_endpointAddress;
-			edge_serial->interrupt_read_urb = port0->interrupt_in_urb;
-			edge_serial->bulk_in_buffer = port0->bulk_in_buffer;
-			edge_serial->bulk_in_endpoint = port0->bulk_in_endpointAddress;
-			edge_serial->read_urb = port0->read_urb;
-			edge_serial->bulk_out_endpoint = port0->bulk_out_endpointAddress;
+		/* set up our interrupt urb */
+		FILL_INT_URB(edge_serial->interrupt_read_urb,
+			     serial->dev,
+			     usb_rcvintpipe(serial->dev,
+					    port0->interrupt_in_endpointAddress),
+			     port0->interrupt_in_buffer,
+			     edge_serial->interrupt_read_urb->transfer_buffer_length,
+			     edge_interrupt_callback, edge_serial,
+			     edge_serial->interrupt_read_urb->interval);
 		
-			/* set up our interrupt urb */
-			FILL_INT_URB(edge_serial->interrupt_read_urb,
-				     serial->dev,
-				     usb_rcvintpipe(serial->dev,
-					            port0->interrupt_in_endpointAddress),
-				     port0->interrupt_in_buffer,
-				     edge_serial->interrupt_read_urb->transfer_buffer_length,
-				     edge_interrupt_callback, edge_serial,
-				     edge_serial->interrupt_read_urb->interval);
-			
-			/* set up our bulk in urb */
-			FILL_BULK_URB(edge_serial->read_urb, serial->dev,
-				      usb_rcvbulkpipe(serial->dev, port0->bulk_in_endpointAddress),
-				      port0->bulk_in_buffer,
-				      edge_serial->read_urb->transfer_buffer_length,
-				      edge_bulk_in_callback, edge_serial);
-
-			/* start interrupt read for this edgeport
-			 * this interrupt will continue as long as the edgeport is connected */
-			response = usb_submit_urb (edge_serial->interrupt_read_urb);
-			if (response) {
-				err(__FUNCTION__" - Error %d submitting control urb", response);
-			}
+		/* set up our bulk in urb */
+		FILL_BULK_URB(edge_serial->read_urb, serial->dev,
+			      usb_rcvbulkpipe(serial->dev, port0->bulk_in_endpointAddress),
+			      port0->bulk_in_buffer,
+			      edge_serial->read_urb->transfer_buffer_length,
+			      edge_bulk_in_callback, edge_serial);
+
+		/* start interrupt read for this edgeport
+		 * this interrupt will continue as long as the edgeport is connected */
+		response = usb_submit_urb (edge_serial->interrupt_read_urb);
+		if (response) {
+			err("%s - Error %d submitting control urb", __FUNCTION__, response);
 		}
-		
-		/* initialize our wait queues */
-		init_waitqueue_head(&edge_port->wait_open);
-		init_waitqueue_head(&edge_port->wait_chase);
-		init_waitqueue_head(&edge_port->delta_msr_wait);
-		init_waitqueue_head(&edge_port->wait_command);
-
-		/* initialize our icount structure */
-		memset (&(edge_port->icount), 0x00, sizeof(edge_port->icount));
-
-		/* initialize our port settings */
-		edge_port->txCredits            = 0;			/* Can't send any data yet */
-		edge_port->shadowMCR            = MCR_MASTER_IE;	/* Must always set this bit to enable ints! */
-		edge_port->chaseResponsePending = FALSE;
+	}
+	
+	/* initialize our wait queues */
+	init_waitqueue_head(&edge_port->wait_open);
+	init_waitqueue_head(&edge_port->wait_chase);
+	init_waitqueue_head(&edge_port->delta_msr_wait);
+	init_waitqueue_head(&edge_port->wait_command);
+
+	/* initialize our icount structure */
+	memset (&(edge_port->icount), 0x00, sizeof(edge_port->icount));
+
+	/* initialize our port settings */
+	edge_port->txCredits            = 0;			/* Can't send any data yet */
+	edge_port->shadowMCR            = MCR_MASTER_IE;	/* Must always set this bit to enable ints! */
+	edge_port->chaseResponsePending = FALSE;
+
+	/* send a open port command */
+	edge_port->openPending = TRUE;
+	edge_port->open        = FALSE;
+	response = send_iosp_ext_cmd (edge_port, IOSP_CMD_OPEN_PORT, 0);
 
-		/* send a open port command */
-		edge_port->openPending = TRUE;
-		edge_port->open        = FALSE;
-		response = send_iosp_ext_cmd (edge_port, IOSP_CMD_OPEN_PORT, 0);
+	if (response < 0) {
+		err("%s - error sending open port command", __FUNCTION__);
+		edge_port->openPending = FALSE;
+		return -ENODEV;
+	}
 
-		if (response < 0) {
-			err(__FUNCTION__" - error sending open port command");
-			edge_port->openPending = FALSE;
-			port->active = 0;
-			port->open_count = 0;
-			MOD_DEC_USE_COUNT;
-			return -ENODEV;
-		}
-
-		/* now wait for the port to be completly opened */
-		timeout = OPEN_TIMEOUT;
-		while (timeout && edge_port->openPending == TRUE) {
-			timeout = interruptible_sleep_on_timeout (&edge_port->wait_open, timeout);
-		}
-
-		if (edge_port->open == FALSE) {
-			/* open timed out */
-			dbg(__FUNCTION__" - open timedout");
-			edge_port->openPending = FALSE;
-			port->active = 0;
-			port->open_count = 0;
-			MOD_DEC_USE_COUNT;
-			return -ENODEV;
-		}
-
-		/* create the txfifo */
-		edge_port->txfifo.head	= 0;
-		edge_port->txfifo.tail	= 0;
-		edge_port->txfifo.count	= 0;
-		edge_port->txfifo.size	= edge_port->maxTxCredits;
-		edge_port->txfifo.fifo	= kmalloc (edge_port->maxTxCredits, GFP_KERNEL);
-
-		if (!edge_port->txfifo.fifo) {
-			dbg(__FUNCTION__" - no memory");
-			edge_close (port, filp);
-			return -ENOMEM;
-		}
+	/* now wait for the port to be completly opened */
+	timeout = OPEN_TIMEOUT;
+	while (timeout && edge_port->openPending == TRUE) {
+		timeout = interruptible_sleep_on_timeout (&edge_port->wait_open, timeout);
+	}
 
-		/* Allocate a URB for the write */
-		edge_port->write_urb = usb_alloc_urb (0);
+	if (edge_port->open == FALSE) {
+		/* open timed out */
+		dbg("%s - open timedout", __FUNCTION__);
+		edge_port->openPending = FALSE;
+		return -ENODEV;
+	}
 
-		if (!edge_port->write_urb) {
-			dbg(__FUNCTION__" - no memory");
-			edge_close (port, filp);
-			return -ENOMEM;
-		}
+	/* create the txfifo */
+	edge_port->txfifo.head	= 0;
+	edge_port->txfifo.tail	= 0;
+	edge_port->txfifo.count	= 0;
+	edge_port->txfifo.size	= edge_port->maxTxCredits;
+	edge_port->txfifo.fifo	= kmalloc (edge_port->maxTxCredits, GFP_KERNEL);
+
+	if (!edge_port->txfifo.fifo) {
+		dbg("%s - no memory", __FUNCTION__);
+		edge_close (port, filp);
+		return -ENOMEM;
+	}
+
+	/* Allocate a URB for the write */
+	edge_port->write_urb = usb_alloc_urb (0);
 
-		dbg(__FUNCTION__"(%d) - Initialize TX fifo to %d bytes", port->number, edge_port->maxTxCredits);
+	if (!edge_port->write_urb) {
+		dbg("%s - no memory", __FUNCTION__);
+		edge_close (port, filp);
+		return -ENOMEM;
 	}
 
-	dbg(__FUNCTION__" exited");
+	dbg("%s(%d) - Initialize TX fifo to %d bytes", __FUNCTION__, port->number, edge_port->maxTxCredits);
+
+	dbg("%s exited", __FUNCTION__);
 
 	return 0;
 }
@@ -1142,11 +1127,11 @@
 
 		// Did we get our Chase response
 		if (edge_port->chaseResponsePending == FALSE) {
-			dbg(__FUNCTION__" - Got Chase Response");
+			dbg("%s - Got Chase Response", __FUNCTION__);
 
 			// did we get all of our credit back?
 			if (edge_port->txCredits == edge_port->maxTxCredits ) {
-				dbg(__FUNCTION__" - Got all credits");
+				dbg("%s - Got all credits", __FUNCTION__);
 				return;
 			}
 		}
@@ -1159,12 +1144,12 @@
 			wait--;
 			if (wait == 0) {
 				edge_port->chaseResponsePending = FALSE;
-				dbg(__FUNCTION__" - Chase TIMEOUT");
+				dbg("%s - Chase TIMEOUT", __FUNCTION__);
 				return;
 			}
 		} else {
 			// Reset timout value back to 10 seconds
-			dbg(__FUNCTION__" - Last %d, Current %d", lastCredits, edge_port->txCredits);
+			dbg("%s - Last %d, Current %d", __FUNCTION__, lastCredits, edge_port->txCredits);
 			wait = 10;
 		}
 	}
@@ -1194,20 +1179,20 @@
 
 		// Is the Edgeport Buffer empty?
 		if (lastCount == 0) {
-			dbg(__FUNCTION__" - TX Buffer Empty");
+			dbg("%s - TX Buffer Empty", __FUNCTION__);
 			return;
 		}
 
 		// Block the thread for a while
 		interruptible_sleep_on_timeout (&edge_port->wait_chase, timeout);
 
-		dbg(__FUNCTION__ " wait");
+		dbg("%s wait", __FUNCTION__);
 
 		if (lastCount == fifo->count) {
 			// No activity.. count down.
 			wait--;
 			if (wait == 0) {
-				dbg(__FUNCTION__" - TIMEOUT");
+				dbg("%s - TIMEOUT", __FUNCTION__);
 				return;
 			}
 		} else {
@@ -1232,7 +1217,7 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 			 
 	serial = get_usb_serial (port, __FUNCTION__);
 	if (!serial)
@@ -1243,57 +1228,50 @@
 	if ((edge_serial == NULL) || (edge_port == NULL))
 		return;
 	
-	--port->open_count;
+	if (serial->dev) {
+		// block until tx is empty
+		block_until_tx_empty(edge_port);
+
+		edge_port->closePending = TRUE;
+
+		/* flush and chase */
+		edge_port->chaseResponsePending = TRUE;
+
+		dbg("%s - Sending IOSP_CMD_CHASE_PORT", __FUNCTION__);
+		status = send_iosp_ext_cmd (edge_port, IOSP_CMD_CHASE_PORT, 0);
+		if (status == 0) {
+			// block until chase finished
+			block_until_chase_response(edge_port);
+		} else {
+			edge_port->chaseResponsePending = FALSE;
+		}
 
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			// block until tx is empty
-			block_until_tx_empty(edge_port);
-
-			edge_port->closePending = TRUE;
-
-			/* flush and chase */
-			edge_port->chaseResponsePending = TRUE;
-
-			dbg(__FUNCTION__" - Sending IOSP_CMD_CHASE_PORT");
-			status = send_iosp_ext_cmd (edge_port, IOSP_CMD_CHASE_PORT, 0);
-			if (status == 0) {
-				// block until chase finished
-				block_until_chase_response(edge_port);
-			} else {
-				edge_port->chaseResponsePending = FALSE;
-			}
+		/* close the port */
+		dbg("%s - Sending IOSP_CMD_CLOSE_PORT", __FUNCTION__);
+		send_iosp_ext_cmd (edge_port, IOSP_CMD_CLOSE_PORT, 0);
 
-			/* close the port */
-			dbg(__FUNCTION__" - Sending IOSP_CMD_CLOSE_PORT");
-			send_iosp_ext_cmd (edge_port, IOSP_CMD_CLOSE_PORT, 0);
-
-			//port->close = TRUE;
-			edge_port->closePending = FALSE;
-			edge_port->open = FALSE;
-			edge_port->openPending = FALSE;
+		//port->close = TRUE;
+		edge_port->closePending = FALSE;
+		edge_port->open = FALSE;
+		edge_port->openPending = FALSE;
 
-			if (edge_port->write_urb) {
-				usb_unlink_urb (edge_port->write_urb);
-			}
-		}
-	
 		if (edge_port->write_urb) {
-			/* if this urb had a transfer buffer already (old transfer) free it */
-			if (edge_port->write_urb->transfer_buffer != NULL) {
-				kfree(edge_port->write_urb->transfer_buffer);
-			}
-			usb_free_urb   (edge_port->write_urb);
+			usb_unlink_urb (edge_port->write_urb);
 		}
-		if (edge_port->txfifo.fifo) {
-			kfree(edge_port->txfifo.fifo);
+	}
+
+	if (edge_port->write_urb) {
+		/* if this urb had a transfer buffer already (old transfer) free it */
+		if (edge_port->write_urb->transfer_buffer != NULL) {
+			kfree(edge_port->write_urb->transfer_buffer);
 		}
-		port->active = 0;
-		port->open_count = 0;
+		usb_free_urb   (edge_port->write_urb);
+	}
+	if (edge_port->txfifo.fifo) {
+		kfree(edge_port->txfifo.fifo);
 	}
 
-	MOD_DEC_USE_COUNT;
-	dbg(__FUNCTION__" exited");
+	dbg("%s exited", __FUNCTION__);
 }   
 
 /*****************************************************************************
@@ -1312,7 +1290,7 @@
 	int firsthalf;
 	int secondhalf;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (edge_port == NULL)
 		return -ENODEV;
@@ -1323,12 +1301,12 @@
 	// calculate number of bytes to put in fifo
 	copySize = min ((unsigned int)count, (edge_port->txCredits - fifo->count));
 
-	dbg(__FUNCTION__"(%d) of %d byte(s) Fifo room  %d -- will copy %d bytes", 
+	dbg("%s(%d) of %d byte(s) Fifo room  %d -- will copy %d bytes", __FUNCTION__, 
 	    port->number, count, edge_port->txCredits - fifo->count, copySize);
 
 	/* catch writes of 0 bytes which the tty driver likes to give us, and when txCredits is empty */
 	if (copySize == 0) {
-		dbg (__FUNCTION__" - copySize = Zero");
+		dbg("%s - copySize = Zero", __FUNCTION__);
 		return 0;
 	}
 
@@ -1340,7 +1318,7 @@
 
 	bytesleft = fifo->size - fifo->head;
 	firsthalf = min (bytesleft, copySize);
-	dbg (__FUNCTION__" - copy %d bytes of %d into fifo ", firsthalf, bytesleft);
+	dbg("%s - copy %d bytes of %d into fifo ", __FUNCTION__, firsthalf, bytesleft);
 
 	/* now copy our data */
 	if (from_user) {
@@ -1362,7 +1340,7 @@
 	secondhalf = copySize-firsthalf;
 
 	if (secondhalf) {
-		dbg (__FUNCTION__" - copy rest of data %d", secondhalf);
+		dbg("%s - copy rest of data %d", __FUNCTION__, secondhalf);
 		if (from_user) {
 			if (copy_from_user(&fifo->fifo[fifo->head], &data[firsthalf], secondhalf))
 				return -EFAULT;
@@ -1381,7 +1359,7 @@
 
 	send_more_port_data((struct edgeport_serial *)port->serial->private, edge_port);
 
-	dbg(__FUNCTION__" wrote %d byte(s) TxCredits %d, Fifo %d", copySize, edge_port->txCredits, fifo->count);
+	dbg("%s wrote %d byte(s) TxCredits %d, Fifo %d", __FUNCTION__, copySize, edge_port->txCredits, fifo->count);
 
 	return copySize;   
 }
@@ -1411,12 +1389,12 @@
 	int		firsthalf;
 	int		secondhalf;
 
-	dbg(__FUNCTION__"(%d)", edge_port->port->number);
+	dbg("%s(%d)", __FUNCTION__, edge_port->port->number);
 
 	if (edge_port->write_in_progress ||
 	    !edge_port->open             ||
 	    (fifo->count == 0)) {
-		dbg(__FUNCTION__"(%d) EXIT - fifo %d, PendingWrite = %d", edge_port->port->number, fifo->count, edge_port->write_in_progress);
+		dbg("%s(%d) EXIT - fifo %d, PendingWrite = %d", __FUNCTION__, edge_port->port->number, fifo->count, edge_port->write_in_progress);
 		return;
 	}
 
@@ -1428,7 +1406,7 @@
 	//	it's better to wait for more credits so we can do a larger
 	//	write.
 	if (edge_port->txCredits < EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(edge_port->maxTxCredits)) {
-		dbg(__FUNCTION__"(%d) Not enough credit - fifo %d TxCredit %d", edge_port->port->number, fifo->count, edge_port->txCredits );
+		dbg("%s(%d) Not enough credit - fifo %d TxCredit %d", __FUNCTION__, edge_port->port->number, fifo->count, edge_port->txCredits );
 		return;
 	}
 
@@ -1446,9 +1424,9 @@
 
 	/* build the data header for the buffer and port that we are about to send out */
 	count = fifo->count;
-	buffer = kmalloc (count+2, GFP_KERNEL);
+	buffer = kmalloc (count+2, GFP_ATOMIC);
 	if (buffer == NULL) {
-		err(__FUNCTION__" - no more kernel memory...");
+		err("%s - no more kernel memory...", __FUNCTION__);
 		edge_port->write_in_progress = FALSE;
 		return;
 	}
@@ -1488,14 +1466,14 @@
 	status = usb_submit_urb(urb);
 	if (status) {
 		/* something went wrong */
-		dbg(__FUNCTION__" - usb_submit_urb(write bulk) failed");
+		dbg("%s - usb_submit_urb(write bulk) failed", __FUNCTION__);
 		edge_port->write_in_progress = FALSE;
 	} else {
 		/* decrement the number of credits we have by the number we just sent */
 		edge_port->txCredits -= count;
 		edge_port->icount.tx += count;
 	}
-	dbg(__FUNCTION__" wrote %d byte(s) TxCredit %d, Fifo %d", count, edge_port->txCredits, fifo->count);
+	dbg("%s wrote %d byte(s) TxCredit %d, Fifo %d", __FUNCTION__, count, edge_port->txCredits, fifo->count);
 }
 
 
@@ -1512,24 +1490,24 @@
 	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
 	int room;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (edge_port == NULL)
 		return -ENODEV;
 	if (edge_port->closePending == TRUE)
 		return -ENODEV;
 
-	dbg(__FUNCTION__" - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (!edge_port->open) {
-		dbg (__FUNCTION__" - port not opened");
+		dbg("%s - port not opened", __FUNCTION__);
 		return -EINVAL;
 	}
 
 	// total of both buffers is still txCredit
 	room = edge_port->txCredits - edge_port->txfifo.count;
 
-	dbg(__FUNCTION__" - returns %d", room);
+	dbg("%s - returns %d", __FUNCTION__, room);
 	return room;
 }
 
@@ -1548,7 +1526,7 @@
 	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
 	int num_chars;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (edge_port == NULL)
 		return -ENODEV;
@@ -1556,13 +1534,13 @@
 		return -ENODEV;
 
 	if (!edge_port->open) {
-		dbg (__FUNCTION__" - port not opened");
+		dbg("%s - port not opened", __FUNCTION__);
 		return -EINVAL;
 	}
 
 	num_chars = edge_port->maxTxCredits - edge_port->txCredits + edge_port->txfifo.count;
 	if (num_chars) {
-		dbg(__FUNCTION__"(port %d) - returns %d", port->number, num_chars);
+		dbg("%s(port %d) - returns %d", __FUNCTION__, port->number, num_chars);
 	}
 
 	return num_chars;
@@ -1580,17 +1558,21 @@
 	struct tty_struct *tty;
 	int status;
 
-	dbg(__FUNCTION__" - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (edge_port == NULL)
 		return;
 
 	if (!edge_port->open) {
-		dbg (__FUNCTION__" - port not opened");
+		dbg("%s - port not opened", __FUNCTION__);
 		return;
 	}
 
 	tty = port->tty;
+	if (!tty) {
+		dbg ("%s - no tty available", __FUNCTION__);
+		return;
+	}
 
 	/* if we are implementing XON/XOFF, send the stop character */
 	if (I_IXOFF(tty)) {
@@ -1625,17 +1607,21 @@
 	struct tty_struct *tty;
 	int status;
 
-	dbg(__FUNCTION__" - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (edge_port == NULL)
 		return;
 
 	if (!edge_port->open) {
-		dbg (__FUNCTION__" - port not opened");
+		dbg("%s - port not opened", __FUNCTION__);
 		return;
 	}
 
 	tty = port->tty;
+	if (!tty) {
+		dbg ("%s - no tty available", __FUNCTION__);
+		return;
+	}
 
 	/* if we are implementing XON/XOFF, send the start character */
 	if (I_IXOFF(tty)) {
@@ -1667,31 +1653,39 @@
 {
 	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
 	struct tty_struct *tty = port->tty;
-	unsigned int cflag = tty->termios->c_cflag;
+	unsigned int cflag;
 
-	dbg(__FUNCTION__" - clfag %08x %08x iflag %08x %08x", 
-	    tty->termios->c_cflag,
-	    old_termios->c_cflag,
-	    RELEVANT_IFLAG(tty->termios->c_iflag),
-	    RELEVANT_IFLAG(old_termios->c_iflag)
-	   );
+	if (!port->tty || !port->tty->termios) {
+		dbg ("%s - no tty or termios", __FUNCTION__);
+		return;
+	}
 
+	cflag = tty->termios->c_cflag;
 	/* check that they really want us to change something */
 	if (old_termios) {
 		if ((cflag == old_termios->c_cflag) &&
 		    (RELEVANT_IFLAG(tty->termios->c_iflag) == RELEVANT_IFLAG(old_termios->c_iflag))) {
-			dbg(__FUNCTION__" - nothing to change");
+			dbg("%s - nothing to change", __FUNCTION__);
 			return;
 		}
 	}
 
-	dbg(__FUNCTION__" - port %d", port->number);
+	dbg("%s - clfag %08x iflag %08x", __FUNCTION__, 
+	    tty->termios->c_cflag,
+	    RELEVANT_IFLAG(tty->termios->c_iflag));
+	if (old_termios) {
+		dbg("%s - old clfag %08x old iflag %08x", __FUNCTION__,
+		    old_termios->c_cflag,
+		    RELEVANT_IFLAG(old_termios->c_iflag));
+	}
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (edge_port == NULL)
 		return;
 
 	if (!edge_port->open) {
-		dbg (__FUNCTION__" - port not opened");
+		dbg("%s - port not opened", __FUNCTION__);
 		return;
 	}
 
@@ -1718,7 +1712,7 @@
 
 	if (edge_port->maxTxCredits == edge_port->txCredits &&
 	    edge_port->txfifo.count == 0) {
-		dbg(__FUNCTION__" -- Empty");
+		dbg("%s -- Empty", __FUNCTION__);
 		result = TIOCSER_TEMT;
 	}
 
@@ -1732,9 +1726,12 @@
 	unsigned int result = 0;
 	struct tty_struct *tty = edge_port->port->tty;
 
+	if (!tty)
+		return -ENOIOCTLCMD;
+
 	result = tty->read_cnt;
 
-	dbg(__FUNCTION__"(%d) = %d",  edge_port->port->number, result);
+	dbg("%s(%d) = %d", __FUNCTION__,  edge_port->port->number, result);
 	if (copy_to_user(value, &result, sizeof(int)))
 		return -EFAULT;
 	//return 0;
@@ -1799,7 +1796,7 @@
 		  | ((msr & MSR_DSR)	? TIOCM_DSR: 0);  /* 0x100 */
 
 
-	dbg(__FUNCTION__" -- %x", result);
+	dbg("%s -- %x", __FUNCTION__, result);
 
 	if (copy_to_user(value, &result, sizeof(int)))
 		return -EFAULT;
@@ -1850,40 +1847,40 @@
 	struct serial_icounter_struct icount;
 
 
-	dbg(__FUNCTION__" - port %d, cmd = 0x%x", port->number, cmd);
+	dbg("%s - port %d, cmd = 0x%x", __FUNCTION__, port->number, cmd);
 
 	switch (cmd) {
 		// return number of bytes available
 		case TIOCINQ:
-			dbg(__FUNCTION__" (%d) TIOCINQ",  port->number);
+			dbg("%s (%d) TIOCINQ", __FUNCTION__,  port->number);
 			return get_number_bytes_avail(edge_port, (unsigned int *) arg);
 			break;
 
 		case TIOCSERGETLSR:
-			dbg(__FUNCTION__" (%d) TIOCSERGETLSR",  port->number);
+			dbg("%s (%d) TIOCSERGETLSR", __FUNCTION__,  port->number);
 			return get_lsr_info(edge_port, (unsigned int *) arg);
 			return 0;
 
 		case TIOCMBIS:
 		case TIOCMBIC:
 		case TIOCMSET:
-			dbg(__FUNCTION__" (%d) TIOCMSET/TIOCMBIC/TIOCMSET",  port->number);
+			dbg("%s (%d) TIOCMSET/TIOCMBIC/TIOCMSET", __FUNCTION__,  port->number);
 			return set_modem_info(edge_port, cmd, (unsigned int *) arg);
 
 		case TIOCMGET:  
-			dbg(__FUNCTION__" (%d) TIOCMGET",  port->number);
+			dbg("%s (%d) TIOCMGET", __FUNCTION__,  port->number);
 			return get_modem_info(edge_port, (unsigned int *) arg);
 
 		case TIOCGSERIAL:
-			dbg(__FUNCTION__" (%d) TIOCGSERIAL",  port->number);
+			dbg("%s (%d) TIOCGSERIAL", __FUNCTION__,  port->number);
 			return get_serial_info(edge_port, (struct serial_struct *) arg);
 
 		case TIOCSSERIAL:
-			dbg(__FUNCTION__" (%d) TIOCSSERIAL",  port->number);
+			dbg("%s (%d) TIOCSSERIAL", __FUNCTION__,  port->number);
 			break;
 
 		case TIOCMIWAIT:
-			dbg(__FUNCTION__" (%d) TIOCMIWAIT",  port->number);
+			dbg("%s (%d) TIOCMIWAIT", __FUNCTION__,  port->number);
 			cprev = edge_port->icount;
 			while (1) {
 				interruptible_sleep_on(&edge_port->delta_msr_wait);
@@ -1919,7 +1916,7 @@
 			icount.brk = cnow.brk;
 			icount.buf_overrun = cnow.buf_overrun;
 
-			dbg(__FUNCTION__" (%d) TIOCGICOUNT RX=%d, TX=%d",  port->number, icount.rx, icount.tx );
+			dbg("%s (%d) TIOCGICOUNT RX=%d, TX=%d", __FUNCTION__,  port->number, icount.rx, icount.tx );
 			if (copy_to_user((void *)arg, &icount, sizeof(icount)))
 				return -EFAULT;
 			return 0;
@@ -1941,7 +1938,7 @@
 	/* flush and chase */
 	edge_port->chaseResponsePending = TRUE;
 
-	dbg(__FUNCTION__" - Sending IOSP_CMD_CHASE_PORT");
+	dbg("%s - Sending IOSP_CMD_CHASE_PORT", __FUNCTION__);
 	status = send_iosp_ext_cmd (edge_port, IOSP_CMD_CHASE_PORT, 0);
 	if (status == 0) {
 		// block until chase finished
@@ -1951,14 +1948,14 @@
 	}
 
 	if (break_state == -1) {
-		dbg(__FUNCTION__" - Sending IOSP_CMD_SET_BREAK");
+		dbg("%s - Sending IOSP_CMD_SET_BREAK", __FUNCTION__);
 		status = send_iosp_ext_cmd (edge_port, IOSP_CMD_SET_BREAK, 0);
 	} else {
-		dbg(__FUNCTION__" - Sending IOSP_CMD_CLEAR_BREAK");
+		dbg("%s - Sending IOSP_CMD_CLEAR_BREAK", __FUNCTION__);
 		status = send_iosp_ext_cmd (edge_port, IOSP_CMD_CLEAR_BREAK, 0);
 	}
 	if (status) {
-		dbg(__FUNCTION__" - error sending break set/clear command.");
+		dbg("%s - error sending break set/clear command.", __FUNCTION__);
 	}
 
 	return;
@@ -1978,14 +1975,14 @@
 	__u16 rxLen;
 	int i;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	lastBufferLength = bufferLength + 1;
 
 	while (bufferLength > 0) {
 		/* failsafe incase we get a message that we don't understand */
 		if (lastBufferLength == bufferLength) {
-			dbg(__FUNCTION__" - stuck in loop, exiting it.");
+			dbg("%s - stuck in loop, exiting it.", __FUNCTION__);
 			break;
 		}
 		lastBufferLength = bufferLength;
@@ -2007,7 +2004,7 @@
 				++buffer;
 				--bufferLength;
 
-				dbg(__FUNCTION__" - Hdr1=%02X Hdr2=%02X", edge_serial->rxHeader1, edge_serial->rxHeader2);
+				dbg("%s - Hdr1=%02X Hdr2=%02X", __FUNCTION__, edge_serial->rxHeader1, edge_serial->rxHeader2);
 
 				// Process depending on whether this header is
 				// data or status
@@ -2038,7 +2035,7 @@
 					edge_serial->rxPort = IOSP_GET_HDR_PORT(edge_serial->rxHeader1);
 					edge_serial->rxBytesRemaining = IOSP_GET_HDR_DATA_LEN(edge_serial->rxHeader1, edge_serial->rxHeader2);
 
-					dbg(__FUNCTION__" - Data for Port %u Len %u", edge_serial->rxPort, edge_serial->rxBytesRemaining);
+					dbg("%s - Data for Port %u Len %u", __FUNCTION__, edge_serial->rxPort, edge_serial->rxBytesRemaining);
 
 					//ASSERT( DevExt->RxPort < DevExt->NumPorts );
 					//ASSERT( DevExt->RxBytesRemaining < IOSP_MAX_DATA_LENGTH );
@@ -2072,7 +2069,7 @@
 						if (edge_port->open) {
 							tty = edge_port->port->tty;
 							if (tty) {
-								dbg (__FUNCTION__" - Sending %d bytes to TTY for port %d", rxLen, edge_serial->rxPort);
+								dbg("%s - Sending %d bytes to TTY for port %d", __FUNCTION__, rxLen, edge_serial->rxPort);
 								for (i = 0; i < rxLen ; ++i) {
 									/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
 									if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
@@ -2125,17 +2122,17 @@
 	}
 	edge_port = (struct edgeport_port *)port->private;
 	if (edge_port == NULL) {
-		err (__FUNCTION__ " - edge_port == NULL for port %d", edge_serial->rxPort);
+		err("%s - edge_port == NULL for port %d", __FUNCTION__, edge_serial->rxPort);
 		return;
 	}
 
-	dbg(__FUNCTION__" - port %d", edge_serial->rxPort);
+	dbg("%s - port %d", __FUNCTION__, edge_serial->rxPort);
 
 	if (code == IOSP_EXT_STATUS) {
 		switch (byte2) {
 			case IOSP_EXT_STATUS_CHASE_RSP:
 				// we want to do EXT status regardless of port open/closed 
-				dbg(__FUNCTION__" - Port %u EXT CHASE_RSP Data = %02x", edge_serial->rxPort, byte3 );
+				dbg("%s - Port %u EXT CHASE_RSP Data = %02x", __FUNCTION__, edge_serial->rxPort, byte3 );
 				// Currently, the only EXT_STATUS is Chase, so process here instead of one more call
 				// to one more subroutine. If/when more EXT_STATUS, there'll be more work to do.
 				// Also, we currently clear flag and close the port regardless of content of above's Byte3.
@@ -2146,7 +2143,7 @@
 				return;
 
 			case IOSP_EXT_STATUS_RX_CHECK_RSP:
-				dbg( __FUNCTION__" ========== Port %u CHECK_RSP Sequence = %02x =============\n", edge_serial->rxPort, byte3 );
+				dbg("%s ========== Port %u CHECK_RSP Sequence = %02x =============\n", __FUNCTION__, edge_serial->rxPort, byte3 );
 				//Port->RxCheckRsp = TRUE;
 				return;
 		}
@@ -2155,11 +2152,12 @@
 	if (code == IOSP_STATUS_OPEN_RSP) {
 		edge_port->txCredits = GET_TX_BUFFER_SIZE(byte3);
 		edge_port->maxTxCredits = edge_port->txCredits;
-		dbg (__FUNCTION__" - Port %u Open Response Inital MSR = %02x TxBufferSize = %d", edge_serial->rxPort, byte2, edge_port->txCredits);
+		dbg("%s - Port %u Open Response Inital MSR = %02x TxBufferSize = %d", __FUNCTION__, edge_serial->rxPort, byte2, edge_port->txCredits);
 		handle_new_msr (edge_port, byte2);
 
 		/* send the current line settings to the port so we are in sync with any further termios calls */
-		change_port_settings (edge_port, edge_port->port->tty->termios);
+		if (edge_port->port->tty)
+			change_port_settings (edge_port, edge_port->port->tty->termios);
 
 		/* we have completed the open */
 		edge_port->openPending = FALSE;
@@ -2178,23 +2176,23 @@
 	switch (code) {
 		// Not currently sent by Edgeport
 		case IOSP_STATUS_LSR:
-			dbg(__FUNCTION__" - Port %u LSR Status = %02x", edge_serial->rxPort, byte2);
+			dbg("%s - Port %u LSR Status = %02x", __FUNCTION__, edge_serial->rxPort, byte2);
 			handle_new_lsr (edge_port, FALSE, byte2, 0);
 			break;
 
 		case IOSP_STATUS_LSR_DATA:
-			dbg(__FUNCTION__" - Port %u LSR Status = %02x, Data = %02x", edge_serial->rxPort, byte2, byte3);
+			dbg("%s - Port %u LSR Status = %02x, Data = %02x", __FUNCTION__, edge_serial->rxPort, byte2, byte3);
 			// byte2 is LSR Register
 			// byte3 is broken data byte
 			handle_new_lsr (edge_port, TRUE, byte2, byte3);
 			break;
 			//
 			//	case IOSP_EXT_4_STATUS:
-			//		dbg(__FUNCTION__" - Port %u LSR Status = %02x Data = %02x", edge_serial->rxPort, byte2, byte3);
+			//		dbg("%s - Port %u LSR Status = %02x Data = %02x", __FUNCTION__, edge_serial->rxPort, byte2, byte3);
 			//		break;
 			//
 		case IOSP_STATUS_MSR:
-			dbg(__FUNCTION__" - Port %u MSR Status = %02x", edge_serial->rxPort, byte2);
+			dbg("%s - Port %u MSR Status = %02x", __FUNCTION__, edge_serial->rxPort, byte2);
 
 			// Process this new modem status and generate appropriate
 			// events, etc, based on the new status. This routine
@@ -2203,7 +2201,7 @@
 			break;
 
 		default:
-			dbg(__FUNCTION__" - Unrecognized IOSP status code %u\n", code);
+			dbg("%s - Unrecognized IOSP status code %u\n", __FUNCTION__, code);
 			break;
 	}
 
@@ -2219,7 +2217,7 @@
 {
 	struct  async_icount *icount;
 
-	dbg(__FUNCTION__" %02x", newMsr);
+	dbg("%s %02x", __FUNCTION__, newMsr);
 
 	if (newMsr & (MSR_DELTA_CTS | MSR_DELTA_DSR | MSR_DELTA_RI | MSR_DELTA_CD)) {
 		icount = &edge_port->icount;
@@ -2256,7 +2254,7 @@
 	__u8    newLsr = (__u8)(lsr & (__u8)(LSR_OVER_ERR | LSR_PAR_ERR | LSR_FRM_ERR | LSR_BREAK));
 	struct  async_icount *icount;
 
-	dbg(__FUNCTION__" - %02x", newLsr);
+	dbg("%s - %02x", __FUNCTION__, newLsr);
 
 	edge_port->shadowLSR = lsr;
 
@@ -2270,7 +2268,7 @@
 	}
 
 	/* Place LSR data byte into Rx buffer */
-	if (lsrData) {
+	if (lsrData && edge_port->port->tty) {
 		tty_insert_flip_char(edge_port->port->tty, data, 0);
 		tty_flip_buffer_push(edge_port->port->tty);
 	}
@@ -2307,11 +2305,11 @@
 	__u16 current_length;
 	unsigned char *transfer_buffer;
 
-//	dbg (__FUNCTION__" - %x, %x, %d", extAddr, addr, length);
+//	dbg("%s - %x, %x, %d", __FUNCTION__, extAddr, addr, length);
 
 	transfer_buffer =  kmalloc (64, GFP_KERNEL);
 	if (!transfer_buffer) {
-		err(__FUNCTION__" - kmalloc(%d) failed.\n", 64);
+		err("%s - kmalloc(%d) failed.\n", __FUNCTION__, 64);
 		return -ENOMEM;
 	}
 
@@ -2323,7 +2321,7 @@
 		} else {
 			current_length = length;
 		}
-//		dbg (__FUNCTION__" - writing %x, %x, %d", extAddr, addr, current_length);
+//		dbg("%s - writing %x, %x, %d", __FUNCTION__, extAddr, addr, current_length);
 		memcpy (transfer_buffer, data, current_length);
 		result = usb_control_msg (serial->dev, usb_sndctrlpipe(serial->dev, 0), USB_REQUEST_ION_WRITE_RAM, 
 					  0x40, addr, extAddr, transfer_buffer, current_length, 300);
@@ -2352,11 +2350,11 @@
 	__u16 current_length;
 	unsigned char *transfer_buffer;
 
-//	dbg (__FUNCTION__" - %x, %x, %d", extAddr, addr, length);
+//	dbg("%s - %x, %x, %d", __FUNCTION__, extAddr, addr, length);
 
 	transfer_buffer =  kmalloc (64, GFP_KERNEL);
 	if (!transfer_buffer) {
-		err(__FUNCTION__" - kmalloc(%d) failed.\n", 64);
+		err("%s - kmalloc(%d) failed.\n", __FUNCTION__, 64);
 		return -ENOMEM;
 	}
 
@@ -2368,7 +2366,7 @@
 		} else {
 			current_length = length;
 		}
-//		dbg (__FUNCTION__" - writing %x, %x, %d", extAddr, addr, current_length);
+//		dbg("%s - writing %x, %x, %d", __FUNCTION__, extAddr, addr, current_length);
 		memcpy (transfer_buffer, data, current_length);
 		result = usb_control_msg (serial->dev, usb_sndctrlpipe(serial->dev, 0), USB_REQUEST_ION_WRITE_ROM, 
 					  0x40, addr, extAddr, transfer_buffer, current_length, 300);
@@ -2397,11 +2395,11 @@
 	__u16 current_length;
 	unsigned char *transfer_buffer;
 
-	dbg (__FUNCTION__" - %x, %x, %d", extAddr, addr, length);
+	dbg("%s - %x, %x, %d", __FUNCTION__, extAddr, addr, length);
 
 	transfer_buffer =  kmalloc (64, GFP_KERNEL);
 	if (!transfer_buffer) {
-		err(__FUNCTION__" - kmalloc(%d) failed.\n", 64);
+		err("%s - kmalloc(%d) failed.\n", __FUNCTION__, 64);
 		return -ENOMEM;
 	}
 
@@ -2413,7 +2411,7 @@
 		} else {
 			current_length = length;
 		}
-//		dbg (__FUNCTION__" - %x, %x, %d", extAddr, addr, current_length);
+//		dbg("%s - %x, %x, %d", __FUNCTION__, extAddr, addr, current_length);
 		result = usb_control_msg (serial->dev, usb_rcvctrlpipe(serial->dev, 0), USB_REQUEST_ION_READ_ROM, 
 					  0xC0, addr, extAddr, transfer_buffer, current_length, 300);
 		if (result < 0)
@@ -2440,11 +2438,11 @@
 	int             length = 0;
 	int             status = 0;
 
-	dbg(__FUNCTION__" - %d, %d", command, param);
+	dbg("%s - %d, %d", __FUNCTION__, command, param);
 
-	buffer =  kmalloc (10, GFP_KERNEL);
+	buffer =  kmalloc (10, GFP_ATOMIC);
 	if (!buffer) {
-		err(__FUNCTION__" - kmalloc(%d) failed.\n", 10);
+		err("%s - kmalloc(%d) failed.\n", __FUNCTION__, 10);
 		return -ENOMEM;
 	}
 
@@ -2472,7 +2470,7 @@
 {
 	struct edgeport_serial *edge_serial = (struct edgeport_serial *)edge_port->port->serial->private;
 	int status = 0;
-	urb_t *urb;
+	struct urb *urb;
 	int timeout;
 
 	usb_serial_debug_data (__FILE__, __FUNCTION__, length, buffer);
@@ -2483,7 +2481,7 @@
 		return -ENOMEM;
 
 	CmdUrbs++;
-	dbg(__FUNCTION__" - ALLOCATE URB %p (outstanding %d)", urb, CmdUrbs);
+	dbg("%s - ALLOCATE URB %p (outstanding %d)", __FUNCTION__, urb, CmdUrbs);
 
 	FILL_BULK_URB (urb, edge_serial->serial->dev, 
 		       usb_sndbulkpipe(edge_serial->serial->dev, edge_serial->bulk_out_endpoint),
@@ -2497,7 +2495,7 @@
 
 	if (status) {
 		/* something went wrong */
-		dbg(__FUNCTION__" - usb_submit_urb(write bulk) failed");
+		dbg("%s - usb_submit_urb(write bulk) failed", __FUNCTION__);
 		usb_unlink_urb (urb);
 		usb_free_urb   (urb);
 		return status;
@@ -2512,7 +2510,7 @@
 
 	if (edge_port->commandPending == TRUE) {
 		/* command timed out */
-		dbg(__FUNCTION__" - command timed out");
+		dbg("%s - command timed out", __FUNCTION__);
 		status = -EINVAL;
 	}
 #endif
@@ -2534,18 +2532,18 @@
 	int status;
 	unsigned char number = edge_port->port->number - edge_port->port->serial->minor;
 
-	dbg(__FUNCTION__" - port = %d, baud = %d", edge_port->port->number, baudRate);
+	dbg("%s - port = %d, baud = %d", __FUNCTION__, edge_port->port->number, baudRate);
 
 	status = calc_baud_rate_divisor (baudRate, &divisor);
 	if (status) {
-		err(__FUNCTION__" - bad baud rate");
+		err("%s - bad baud rate", __FUNCTION__);
 		return status;
 	}
 
 	// Alloc memory for the string of commands.
-	cmdBuffer =  kmalloc (0x100, GFP_KERNEL);
+	cmdBuffer =  kmalloc (0x100, GFP_ATOMIC);
 	if (!cmdBuffer) {
-		err(__FUNCTION__" - kmalloc(%d) failed.\n", 0x100);
+		err("%s - kmalloc(%d) failed.\n", __FUNCTION__, 0x100);
 		return -ENOMEM;
 	}
 	currCmd = cmdBuffer;
@@ -2583,11 +2581,11 @@
 	__u16 round;
 
 
-	dbg(__FUNCTION__" - %d", baudrate);
+	dbg("%s - %d", __FUNCTION__, baudrate);
 
-	for (i = 0; i < NUM_ENTRIES(DivisorTable); i++) {
-		if ( DivisorTable[i].BaudRate == baudrate ) {
-			*divisor = DivisorTable[i].Divisor;
+	for (i = 0; i < NUM_ENTRIES(divisor_table); i++) {
+		if ( divisor_table[i].BaudRate == baudrate ) {
+			*divisor = divisor_table[i].Divisor;
 			return 0;
 		}
 	}
@@ -2607,7 +2605,7 @@
 		}
 		*divisor = custom;
 
-		dbg(__FUNCTION__" - Baud %d = %d\n", baudrate, custom);
+		dbg("%s - Baud %d = %d\n", __FUNCTION__, baudrate, custom);
 		return 0;
 	}
 
@@ -2626,10 +2624,10 @@
 	unsigned long cmdLen = 0;
 	int status;
 
-	dbg (__FUNCTION__" - write to %s register 0x%02x", (regNum == MCR) ? "MCR" : "LCR", regValue);
+	dbg("%s - write to %s register 0x%02x", (regNum == MCR) ? "MCR" : "LCR", __FUNCTION__, regValue);
 
 	// Alloc memory for the string of commands.
-	cmdBuffer = kmalloc (0x10, GFP_KERNEL);
+	cmdBuffer = kmalloc (0x10, GFP_ATOMIC);
 	if (cmdBuffer == NULL ) {
 		return -ENOMEM;
 	}
@@ -2669,50 +2667,50 @@
 	__u8 txFlow;
 	int status;
 
-	dbg(__FUNCTION__" - port %d", edge_port->port->number);
+	dbg("%s - port %d", __FUNCTION__, edge_port->port->number);
 
 	if ((!edge_port->open) &&
 	    (!edge_port->openPending)) {
-		dbg(__FUNCTION__" - port not opened");
+		dbg("%s - port not opened", __FUNCTION__);
 		return;
 	}
 
 	tty = edge_port->port->tty;
 	if ((!tty) ||
 	    (!tty->termios)) {
-		dbg(__FUNCTION__" - no tty structures");
+		dbg("%s - no tty structures", __FUNCTION__);
 		return;
 	}
 
 	cflag = tty->termios->c_cflag;
 
 	switch (cflag & CSIZE) {
-		case CS5:   lData = LCR_BITS_5; mask = 0x1f;    dbg(__FUNCTION__" - data bits = 5");   break;
-		case CS6:   lData = LCR_BITS_6; mask = 0x3f;    dbg(__FUNCTION__" - data bits = 6");   break;
-		case CS7:   lData = LCR_BITS_7; mask = 0x7f;    dbg(__FUNCTION__" - data bits = 7");   break;
+		case CS5:   lData = LCR_BITS_5; mask = 0x1f;    dbg("%s - data bits = 5", __FUNCTION__);   break;
+		case CS6:   lData = LCR_BITS_6; mask = 0x3f;    dbg("%s - data bits = 6", __FUNCTION__);   break;
+		case CS7:   lData = LCR_BITS_7; mask = 0x7f;    dbg("%s - data bits = 7", __FUNCTION__);   break;
 		default:
-		case CS8:   lData = LCR_BITS_8;                 dbg(__FUNCTION__" - data bits = 8");   break;
+		case CS8:   lData = LCR_BITS_8;                 dbg("%s - data bits = 8", __FUNCTION__);   break;
 	}
 
 	lParity = LCR_PAR_NONE;
 	if (cflag & PARENB) {
 		if (cflag & PARODD) {
 			lParity = LCR_PAR_ODD;
-			dbg(__FUNCTION__" - parity = odd");
+			dbg("%s - parity = odd", __FUNCTION__);
 		} else {
 			lParity = LCR_PAR_EVEN;
-			dbg(__FUNCTION__" - parity = even");
+			dbg("%s - parity = even", __FUNCTION__);
 		}
 	} else {
-		dbg(__FUNCTION__" - parity = none");
+		dbg("%s - parity = none", __FUNCTION__);
 	}
 
 	if (cflag & CSTOPB) {
 		lStop = LCR_STOP_2;
-		dbg(__FUNCTION__" - stop bits = 2");
+		dbg("%s - stop bits = 2", __FUNCTION__);
 	} else {
 		lStop = LCR_STOP_1;
-		dbg(__FUNCTION__" - stop bits = 1");
+		dbg("%s - stop bits = 1", __FUNCTION__);
 	}
 
 	/* figure out the flow control settings */
@@ -2720,9 +2718,9 @@
 	if (cflag & CRTSCTS) {
 		rxFlow |= IOSP_RX_FLOW_RTS;
 		txFlow |= IOSP_TX_FLOW_CTS;
-		dbg(__FUNCTION__" - RTS/CTS is enabled");
+		dbg("%s - RTS/CTS is enabled", __FUNCTION__);
 	} else {
-		dbg(__FUNCTION__" - RTS/CTS is disabled");
+		dbg("%s - RTS/CTS is disabled", __FUNCTION__);
 	}
 
 	/* if we are implementing XON/XOFF, set the start and stop character in the device */
@@ -2736,17 +2734,17 @@
 		/* if we are implementing INBOUND XON/XOFF */
 		if (I_IXOFF(tty)) {
 			rxFlow |= IOSP_RX_FLOW_XON_XOFF;
-			dbg(__FUNCTION__" - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x", start_char, stop_char);
+			dbg("%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x", __FUNCTION__, start_char, stop_char);
 		} else {
-			dbg(__FUNCTION__" - INBOUND XON/XOFF is disabled");
+			dbg("%s - INBOUND XON/XOFF is disabled", __FUNCTION__);
 		}
 
 		/* if we are implementing OUTBOUND XON/XOFF */
 		if (I_IXON(tty)) {
 			txFlow |= IOSP_TX_FLOW_XON_XOFF;
-			dbg(__FUNCTION__" - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x", start_char, stop_char);
+			dbg("%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x", __FUNCTION__, start_char, stop_char);
 		} else {
-			dbg(__FUNCTION__" - OUTBOUND XON/XOFF is disabled");
+			dbg("%s - OUTBOUND XON/XOFF is disabled", __FUNCTION__);
 		}
 	}
 
@@ -2783,7 +2781,7 @@
 		baud = 9600;
 	}
 
-	dbg(__FUNCTION__ " - baud rate = %d", baud);
+	dbg("%s - baud rate = %d", __FUNCTION__, baud);
 	status = send_cmd_write_baud_rate (edge_port, baud);
 
 	return;
@@ -2881,7 +2879,7 @@
  ****************************************************************************/
 static void load_application_firmware (struct edgeport_serial *edge_serial)
 {
-	PEDGE_FIRMWARE_IMAGE_RECORD record;
+	struct edge_firmware_image_record *record;
 	unsigned char *firmware;
 	unsigned char *FirmwareImage;
 	int ImageSize;
@@ -2919,13 +2917,13 @@
 
 
 	for (;;) {
-		record = (PEDGE_FIRMWARE_IMAGE_RECORD)firmware;
+		record = (struct edge_firmware_image_record *)firmware;
 		response = sram_write (edge_serial->serial, record->ExtAddr, record->Addr, record->Len, &record->Data[0]);
 		if (response < 0) {
 			err("sram_write failed (%x, %x, %d)", record->ExtAddr, record->Addr, record->Len);
 			break;
 		}
-		firmware += sizeof (EDGE_FIRMWARE_IMAGE_RECORD) + record->Len;
+		firmware += sizeof (struct edge_firmware_image_record) + record->Len;
 		if (firmware >= &FirmwareImage[ImageSize]) {
 			break;
 		}
@@ -2958,7 +2956,7 @@
 	/* create our private serial structure */
 	edge_serial = kmalloc (sizeof(struct edgeport_serial), GFP_KERNEL);
 	if (edge_serial == NULL) {
-		err(__FUNCTION__" - Out of memory");
+		err("%s - Out of memory", __FUNCTION__);
 		return -ENOMEM;
 	}
 	memset (edge_serial, 0, sizeof(struct edgeport_serial));
@@ -2985,22 +2983,23 @@
 	/* set the number of ports from the manufacturing description */
 	/* serial->num_ports = serial->product_info.NumPorts; */
 	if (edge_serial->product_info.NumPorts != serial->num_ports) {
-		warn(__FUNCTION__ " - Device Reported %d serial ports vs core "
+		warn("%s - Device Reported %d serial ports vs core "
 		     "thinking we have %d ports, email greg@kroah.com this info.",
-		     edge_serial->product_info.NumPorts, serial->num_ports);
+		     __FUNCTION__, edge_serial->product_info.NumPorts, 
+		     serial->num_ports);
 	}
 
-	dbg(__FUNCTION__ " - time 1 %ld", jiffies);
+	dbg("%s - time 1 %ld", __FUNCTION__, jiffies);
 
 	/* now load the application firmware into this device */
 	load_application_firmware (edge_serial);
 
-	dbg(__FUNCTION__ " - time 2 %ld", jiffies);
+	dbg("%s - time 2 %ld", __FUNCTION__, jiffies);
 
 	/* Check current Edgeport EEPROM and update if necessary */
 	update_edgeport_E2PROM (edge_serial);
 	
-	dbg(__FUNCTION__ " - time 3 %ld", jiffies);
+	dbg("%s - time 3 %ld", __FUNCTION__, jiffies);
 
 	/* set the configuration to use #1 */
 //	dbg("set_configuration 1");
@@ -3013,7 +3012,7 @@
 	for (i = 0; i < serial->num_ports; ++i) {
 		edge_port = kmalloc (sizeof(struct edgeport_port), GFP_KERNEL);
 		if (edge_port == NULL) {
-			err(__FUNCTION__" - Out of memory");
+			err("%s - Out of memory", __FUNCTION__);
 			return -ENOMEM;
 		}
 		memset (edge_port, 0, sizeof(struct edgeport_port));
@@ -3034,13 +3033,10 @@
 {
 	int i;
 
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	/* stop reads and writes on all ports */
 	for (i=0; i < serial->num_ports; ++i) {
-		while (serial->port[i].open_count > 0) {
-			edge_close (&serial->port[i], NULL);
-		}
 		kfree (serial->port[i].private);
 		serial->port[i].private = NULL;
 	}
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_edgeport.h linux-2.4.19/drivers/usb/serial/io_edgeport.h
--- linux-2.4.19.old/drivers/usb/serial/io_edgeport.h	Tue Aug 28 20:21:02 2001
+++ linux-2.4.19/drivers/usb/serial/io_edgeport.h	Mon Nov 25 12:27:08 2002
@@ -136,7 +136,6 @@
 	__u16	Strings[1];			/* Start of string block */
 };
 
-typedef struct string_block STRING_BLOCK, *PSTRING_BLOCK;
 
 
 #endif
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_fw_boot.h linux-2.4.19/drivers/usb/serial/io_fw_boot.h
--- linux-2.4.19.old/drivers/usb/serial/io_fw_boot.h	Tue Mar 20 02:21:54 2001
+++ linux-2.4.19/drivers/usb/serial/io_fw_boot.h	Mon Nov 25 12:27:08 2002
@@ -12,20 +12,18 @@
 //Image structure definition
 #if !defined(DEFINED_EDGE_FIRMWARE_IMAGE_RECORD)
 #define DEFINED_EDGE_FIRMWARE_IMAGE_RECORD
-	typedef struct _EDGE_FIRMWARE_IMAGE_RECORD
-	{
+	struct edge_firmware_image_record {
 		unsigned short ExtAddr;
 		unsigned short Addr;
 		unsigned short Len;
 		unsigned char  Data[0];
-	} EDGE_FIRMWARE_IMAGE_RECORD, *PEDGE_FIRMWARE_IMAGE_RECORD;
+	};
 
-	typedef struct _EDGE_FIRMWARE_VERSION_INFO
-	{
+	struct edge_firmware_version_info {
 		unsigned char	 MajorVersion;
 		unsigned char  MinorVersion;
 		unsigned short BuildNumber;
-	} EDGE_FIRMWARE_VERSION_INFO, *PEDGE_FIRMWARE_VERSION_INFO;
+	};
 
 #endif
 
@@ -549,7 +547,7 @@
     0x7e, 0x74, 0x00, 0x01, 0x02, 0x08, 0xd6, 
 };
 
-static EDGE_FIRMWARE_VERSION_INFO IMAGE_VERSION_NAME = {
+static struct edge_firmware_version_info IMAGE_VERSION_NAME = {
 	1, 12, 2 };		// Major, Minor, Build
 
 #undef IMAGE_VERSION_NAME
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_fw_boot2.h linux-2.4.19/drivers/usb/serial/io_fw_boot2.h
--- linux-2.4.19.old/drivers/usb/serial/io_fw_boot2.h	Tue Mar 20 02:21:54 2001
+++ linux-2.4.19/drivers/usb/serial/io_fw_boot2.h	Mon Nov 25 12:27:08 2002
@@ -12,20 +12,18 @@
 //Image structure definition
 #if !defined(DEFINED_EDGE_FIRMWARE_IMAGE_RECORD)
 #define DEFINED_EDGE_FIRMWARE_IMAGE_RECORD
-	typedef struct _EDGE_FIRMWARE_IMAGE_RECORD
-	{
+	struct edge_firmware_image_record {
 		unsigned short ExtAddr;
 		unsigned short Addr;
 		unsigned short Len;
 		unsigned char  Data[0];
-	} EDGE_FIRMWARE_IMAGE_RECORD, *PEDGE_FIRMWARE_IMAGE_RECORD;
+	};
 
-	typedef struct _EDGE_FIRMWARE_VERSION_INFO
-	{
+	struct edge_firmware_version_info {
 		unsigned char	 MajorVersion;
 		unsigned char  MinorVersion;
 		unsigned short BuildNumber;
-	} EDGE_FIRMWARE_VERSION_INFO, *PEDGE_FIRMWARE_VERSION_INFO;
+	};
 
 #endif
 
@@ -539,7 +537,7 @@
 
 };
 
-static EDGE_FIRMWARE_VERSION_INFO IMAGE_VERSION_NAME = {
+static struct edge_firmware_version_info IMAGE_VERSION_NAME = {
 	2, 0, 3 };		// Major, Minor, Build
 
 #undef IMAGE_VERSION_NAME
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_fw_down.h linux-2.4.19/drivers/usb/serial/io_fw_down.h
--- linux-2.4.19.old/drivers/usb/serial/io_fw_down.h	Tue Mar 20 02:21:54 2001
+++ linux-2.4.19/drivers/usb/serial/io_fw_down.h	Mon Nov 25 12:27:08 2002
@@ -12,20 +12,18 @@
 //Image structure definition
 #if !defined(DEFINED_EDGE_FIRMWARE_IMAGE_RECORD)
 	#define DEFINED_EDGE_FIRMWARE_IMAGE_RECORD
-	typedef struct _EDGE_FIRMWARE_IMAGE_RECORD
-	{
+	struct edge_firmware_image_record {
 		unsigned short	ExtAddr;
 		unsigned short	Addr;
 		unsigned short	Len;
 		unsigned char	Data[0];
-	} EDGE_FIRMWARE_IMAGE_RECORD, *PEDGE_FIRMWARE_IMAGE_RECORD;
+	};
 
-	typedef struct _EDGE_FIRMWARE_VERSION_INFO
-	{
+	struct edge_firmware_version_info {
 		unsigned char	MajorVersion;
 		unsigned char	MinorVersion;
 		unsigned short	BuildNumber;
-	} EDGE_FIRMWARE_VERSION_INFO, *PEDGE_FIRMWARE_VERSION_INFO;
+	};
 
 #endif
 
@@ -1114,7 +1112,7 @@
     0x08, 0xa5, 0xb8, 0x02, 0x03, 0x4e, 0xa0, 0x08, 0x22, 0x80, 0xfe, 
 };
 
-static EDGE_FIRMWARE_VERSION_INFO IMAGE_VERSION_NAME = {
+static struct edge_firmware_version_info IMAGE_VERSION_NAME = {
 	1, 12, 3 };		// Major, Minor, Build
 
 #undef IMAGE_VERSION_NAME
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_fw_down2.h linux-2.4.19/drivers/usb/serial/io_fw_down2.h
--- linux-2.4.19.old/drivers/usb/serial/io_fw_down2.h	Tue Mar 20 02:21:54 2001
+++ linux-2.4.19/drivers/usb/serial/io_fw_down2.h	Mon Nov 25 12:27:08 2002
@@ -12,20 +12,18 @@
 //Image structure definition
 #if !defined(DEFINED_EDGE_FIRMWARE_IMAGE_RECORD)
 	#define DEFINED_EDGE_FIRMWARE_IMAGE_RECORD
-	typedef struct _EDGE_FIRMWARE_IMAGE_RECORD
-	{
+	struct edge_firmware_image_record {
 		unsigned short ExtAddr;
 		unsigned short Addr;
 		unsigned short Len;
 		unsigned char  Data[0];
-	} EDGE_FIRMWARE_IMAGE_RECORD, *PEDGE_FIRMWARE_IMAGE_RECORD;
+	};
 
-	typedef struct _EDGE_FIRMWARE_VERSION_INFO
-	{
-		unsigned char	 MajorVersion;
+	struct edge_firmware_version_info {
+		unsigned char  MajorVersion;
 		unsigned char  MinorVersion;
 		unsigned short BuildNumber;
-	} EDGE_FIRMWARE_VERSION_INFO, *PEDGE_FIRMWARE_VERSION_INFO;
+	};
 
 #endif
 
@@ -1126,7 +1124,7 @@
     0x02, 0x03, 0x4e, 0xa0, 0x08, 0x22, 0x80, 0xfe, 
 };
 
-static EDGE_FIRMWARE_VERSION_INFO IMAGE_VERSION_NAME = {
+static struct edge_firmware_version_info IMAGE_VERSION_NAME = {
 	2, 0, 3 };		// Major, Minor, Build
 
 #undef IMAGE_VERSION_NAME
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_fw_down3.h linux-2.4.19/drivers/usb/serial/io_fw_down3.h
--- linux-2.4.19.old/drivers/usb/serial/io_fw_down3.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/serial/io_fw_down3.h	Mon Nov 25 12:27:08 2002
@@ -0,0 +1,799 @@
+//**************************************************************
+//* Edgeport Binary Image (for TI based products)
+//* Generated by TIBin2C v1.00
+//* Copyright(c) 2001 Inside Out Networks, All rights reserved.
+//**************************************************************
+
+
+static int IMAGE_SIZE = 12166;
+
+struct EDGE_FIRMWARE_VERSION_INFO
+{
+	unsigned char   MajorVersion;
+	unsigned char   MinorVersion;
+	unsigned short  BuildNumber;
+};
+
+static struct EDGE_FIRMWARE_VERSION_INFO IMAGE_VERSION_NAME =
+{
+	4, 1, 0		// Major, Minor, Build
+
+};
+
+static unsigned char IMAGE_ARRAY_NAME[] = 
+{
+//  struct ImageHdr
+//  {
+//      WORD    Length;
+//      BYTE    CheckSum;
+//  };
+0x83, 0x2f, 
+0x33, 
+
+0x02, 0x24, 0x84, 0x02, 0x1f, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x1e, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x1a, 0x85, 0x45, 
+0x8c, 0x85, 0x46, 0x8a, 0xc0, 0xe0, 0xc0, 0xd0, 0xc0, 0xf0, 0xc0, 0x82, 0xc0, 0x83, 0xc0, 0x00, 
+0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x03, 0xc0, 0x04, 0xc0, 0x05, 0xc0, 0x06, 0xc0, 0x07, 0xe5, 0x44, 
+0x24, 0x08, 0xf8, 0xe6, 0x60, 0x2b, 0xe5, 0x44, 0x24, 0x10, 0xf8, 0xa6, 0x81, 0xe5, 0x44, 0x75, 
+0xf0, 0x21, 0xa4, 0x24, 0x05, 0xf5, 0x82, 0xe4, 0x34, 0xf8, 0xf5, 0x83, 0x78, 0x92, 0xe5, 0x81, 
+0x04, 0xc3, 0x98, 0xf9, 0x94, 0x22, 0x40, 0x03, 0x02, 0x11, 0x1a, 0xe6, 0xf0, 0x08, 0xa3, 0xd9, 
+0xfa, 0x74, 0x08, 0x25, 0x44, 0xf8, 0x05, 0x44, 0x08, 0xe6, 0x54, 0x80, 0x70, 0x0c, 0xe5, 0x44, 
+0xb4, 0x07, 0xf3, 0x78, 0x08, 0x75, 0x44, 0x00, 0x80, 0xef, 0xe5, 0x44, 0x24, 0x10, 0xf8, 0x86, 
+0x81, 0xe5, 0x44, 0x75, 0xf0, 0x21, 0xa4, 0x24, 0x05, 0xf5, 0x82, 0xe4, 0x34, 0xf8, 0xf5, 0x83, 
+0x78, 0x92, 0xe5, 0x81, 0x04, 0xc3, 0x98, 0xf9, 0xe0, 0xf6, 0x08, 0xa3, 0xd9, 0xfa, 0xd0, 0x07, 
+0xd0, 0x06, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x03, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0xd0, 0x83, 
+0xd0, 0x82, 0xd0, 0xf0, 0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x30, 0x01, 0x4d, 0x30, 0xb4, 0x48, 0x10, 
+0x00, 0x45, 0x90, 0xff, 0x08, 0xe0, 0x54, 0x20, 0xf8, 0x90, 0xff, 0x48, 0xe0, 0x54, 0x20, 0xf9, 
+0x90, 0xff, 0x10, 0xe0, 0x54, 0x20, 0xfa, 0x90, 0xff, 0x50, 0xe0, 0x54, 0x20, 0xfb, 0x74, 0x00, 
+0xf5, 0x82, 0x74, 0xf8, 0xf5, 0x83, 0xe0, 0xc8, 0xf0, 0x68, 0x60, 0x02, 0x7e, 0x04, 0xa3, 0xe0, 
+0xc9, 0xf0, 0x69, 0x60, 0x02, 0x7e, 0x04, 0xa3, 0xe0, 0xca, 0xf0, 0x6a, 0x60, 0x02, 0x7e, 0x04, 
+0xa3, 0xe0, 0xcb, 0xf0, 0x6b, 0x60, 0x02, 0x7e, 0x04, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0xc0, 0xf0, 
+0xc0, 0x82, 0xc0, 0x83, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x03, 0xc0, 0x04, 0xc0, 0x05, 
+0xc0, 0x06, 0xc0, 0x07, 0x90, 0xff, 0x93, 0x74, 0x01, 0xf0, 0xe5, 0x81, 0x94, 0xfd, 0x40, 0x03, 
+0x02, 0x11, 0x1a, 0x85, 0x47, 0x8d, 0x85, 0x48, 0x8b, 0x74, 0xae, 0xf5, 0x82, 0x74, 0xfa, 0xf5, 
+0x83, 0xe0, 0xb4, 0x01, 0x1b, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x4a, 0xe0, 0x30, 0xe7, 0x2c, 
+0x90, 0xff, 0x4e, 0xe0, 0x30, 0xe7, 0x25, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x02, 0xf0, 0x80, 0x20, 
+0xb4, 0x02, 0x1d, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x7a, 0xe0, 0x30, 0xe7, 0x05, 0x12, 0x25, 
+0x13, 0x80, 0x09, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x03, 0xf0, 0x80, 0x04, 0xd0, 0x83, 0xd0, 0x82, 
+0xa3, 0xe0, 0xb4, 0x01, 0x1b, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x52, 0xe0, 0x30, 0xe7, 0x2c, 
+0x90, 0xff, 0x56, 0xe0, 0x30, 0xe7, 0x25, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x02, 0xf0, 0x80, 0x20, 
+0xb4, 0x02, 0x1d, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x7a, 0xe0, 0x30, 0xe7, 0x05, 0x12, 0x25, 
+0x13, 0x80, 0x09, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x03, 0xf0, 0x80, 0x04, 0xd0, 0x83, 0xd0, 0x82, 
+0x20, 0x02, 0x03, 0x30, 0x01, 0x7b, 0x74, 0x16, 0xf5, 0x82, 0x74, 0xf9, 0xf5, 0x83, 0xe0, 0x14, 
+0xfc, 0xf0, 0xa3, 0xe0, 0xfd, 0xa3, 0xe0, 0xfe, 0x64, 0x04, 0x70, 0x0f, 0xec, 0x70, 0x62, 0x7e, 
+0x01, 0x12, 0x00, 0xc9, 0x7c, 0x0a, 0x7d, 0xfa, 0x02, 0x02, 0x22, 0x12, 0x00, 0xc9, 0xee, 0x64, 
+0x04, 0x60, 0x1d, 0xec, 0x70, 0x4b, 0x7c, 0x0a, 0xed, 0x14, 0xfd, 0x70, 0x15, 0xee, 0x64, 0x02, 
+0x60, 0x07, 0x7e, 0x02, 0x7d, 0x32, 0x02, 0x02, 0x22, 0x7e, 0x01, 0x7d, 0xfa, 0x02, 0x02, 0x22, 
+0x7c, 0x0a, 0x74, 0x16, 0xf5, 0x82, 0x74, 0xf9, 0xf5, 0x83, 0xec, 0xf0, 0xa3, 0xed, 0xf0, 0xa3, 
+0xee, 0xf0, 0x14, 0x60, 0x18, 0x20, 0xe1, 0x0f, 0x20, 0x01, 0x06, 0xd2, 0xb1, 0xc2, 0xb0, 0x80, 
+0x10, 0xc2, 0xb1, 0xd2, 0xb0, 0x80, 0x0a, 0xc2, 0xb1, 0xc2, 0xb0, 0x80, 0x04, 0xd2, 0xb0, 0xd2, 
+0xb1, 0x78, 0x19, 0x79, 0x09, 0x7a, 0x07, 0xe7, 0x70, 0x04, 0xa6, 0x00, 0x80, 0x0b, 0xe6, 0x60, 
+0x08, 0x16, 0xe6, 0x70, 0x04, 0xe7, 0x44, 0x80, 0xf7, 0x08, 0x09, 0xda, 0xea, 0xe5, 0x43, 0x60, 
+0x13, 0x14, 0xf5, 0x43, 0x70, 0x0e, 0xe5, 0x44, 0x24, 0x08, 0xf8, 0x76, 0x00, 0x12, 0x10, 0x95, 
+0xd2, 0x8c, 0xd2, 0x8d, 0xd0, 0x07, 0xd0, 0x06, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x03, 0xd0, 0x02, 
+0xd0, 0x01, 0xd0, 0x00, 0xd0, 0x83, 0xd0, 0x82, 0xd0, 0xf0, 0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x90, 
+0xff, 0x04, 0xe0, 0x90, 0xfa, 0xb5, 0xf0, 0x90, 0xff, 0x06, 0xe0, 0xfc, 0xa3, 0xe0, 0xfa, 0xec, 
+0xff, 0xea, 0xfe, 0xef, 0xc3, 0x94, 0x08, 0xee, 0x94, 0x01, 0x50, 0x02, 0x80, 0x04, 0x7e, 0x01, 
+0x7f, 0x08, 0x8e, 0x34, 0x8f, 0x35, 0x90, 0xff, 0x02, 0xe0, 0xfc, 0xa3, 0xe0, 0xfa, 0xec, 0xff, 
+0xea, 0x90, 0xfa, 0xb9, 0xf0, 0xef, 0xa3, 0xf0, 0x12, 0x18, 0x49, 0x78, 0x24, 0x7c, 0x00, 0x7d, 
+0x00, 0x12, 0x19, 0x6c, 0x7e, 0x00, 0x7f, 0x05, 0x12, 0x13, 0x8f, 0xe4, 0xf5, 0x53, 0xe5, 0x53, 
+0xc3, 0x94, 0x02, 0x50, 0x0f, 0x12, 0x18, 0x2a, 0xe4, 0x12, 0x13, 0xfb, 0x05, 0x53, 0x04, 0x12, 
+0x18, 0x1b, 0x80, 0xea, 0x12, 0x18, 0x49, 0x90, 0xff, 0x00, 0xe0, 0xff, 0x54, 0x60, 0x24, 0xc0, 
+0x70, 0x03, 0x02, 0x08, 0xb8, 0x24, 0x40, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 
+0xfe, 0x54, 0x0f, 0xf5, 0x53, 0xee, 0x30, 0xe7, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x0a, 0x90, 
+0xff, 0x01, 0xe0, 0x12, 0x15, 0x0f, 0x03, 0x55, 0x00, 0x04, 0x28, 0x01, 0x05, 0x2f, 0x03, 0x05, 
+0xf6, 0x05, 0x06, 0x38, 0x06, 0x07, 0x9a, 0x08, 0x07, 0xe2, 0x09, 0x08, 0x3e, 0x0a, 0x08, 0x7e, 
+0x0b, 0x00, 0x00, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb9, 
+0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x64, 0x02, 0x45, 0x34, 
+0x60, 0x03, 0x02, 0x0e, 0xac, 0xef, 0x54, 0x1f, 0x14, 0x60, 0x2b, 0x14, 0x60, 0x47, 0x24, 0x02, 
+0x60, 0x03, 0x02, 0x0e, 0xac, 0xee, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 0x2a, 0x74, 0x01, 
+0x12, 0x13, 0xfb, 0x78, 0x6d, 0xe6, 0x30, 0xe0, 0x08, 0x12, 0x18, 0x2a, 0x74, 0x02, 0x12, 0x13, 
+0xfb, 0x7f, 0x02, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe1, 0x09, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 
+0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0xd3, 0x94, 0x01, 0x40, 0x03, 0x02, 0x0e, 0xac, 
+0x7f, 0x02, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe1, 0x0e, 0x90, 0xfa, 0xb5, 0xe0, 0xff, 0x60, 
+0x07, 0x64, 0x80, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x0f, 0x38, 0x40, 0x03, 0x02, 0x0e, 0xac, 
+0xe5, 0x53, 0x70, 0x19, 0x30, 0x0a, 0x0b, 0x90, 0xff, 0x80, 0x12, 0x18, 0x27, 0x12, 0x13, 0xfb, 
+0x80, 0x24, 0x90, 0xff, 0x82, 0x12, 0x18, 0x27, 0x12, 0x13, 0xfb, 0x80, 0x19, 0x15, 0x53, 0x30, 
+0x0a, 0x0b, 0x12, 0x18, 0xbd, 0x12, 0x18, 0x25, 0x12, 0x13, 0xfb, 0x80, 0x09, 0x12, 0x18, 0xcb, 
+0x12, 0x18, 0x25, 0x12, 0x13, 0xfb, 0x12, 0x18, 0x2a, 0x12, 0x13, 0xb5, 0x60, 0x05, 0x74, 0x01, 
+0x12, 0x13, 0xfb, 0x7f, 0x02, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 
+0xe5, 0x35, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 0xd9, 0x14, 0x60, 0x2d, 0x14, 
+0x60, 0x59, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb9, 0xe0, 0x70, 0x04, 0xa3, 
+0xe0, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 
+0xac, 0x78, 0x6d, 0xe6, 0x54, 0xfe, 0xf6, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe1, 
+0x06, 0x20, 0xe0, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe0, 0x09, 0x90, 0xfa, 0xb5, 0xe0, 
+0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe1, 0x0c, 0x90, 0xfa, 0xb5, 0xe0, 0xd3, 0x94, 
+0x01, 0x40, 0x03, 0x02, 0x0e, 0xac, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0x90, 0xfa, 0xb9, 0xe0, 0x70, 
+0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x0f, 0x38, 0x40, 0x03, 0x02, 0x0e, 0xac, 
+0xe5, 0x2c, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe0, 0x07, 
+0xe5, 0x53, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x53, 0x70, 0x0f, 0x90, 0xff, 0x82, 0xe0, 0x54, 
+0xf7, 0xf0, 0x90, 0xff, 0x80, 0xe0, 0x54, 0xf7, 0xf0, 0x22, 0xe5, 0x53, 0x24, 0xfe, 0x60, 0x1b, 
+0x04, 0x70, 0x2e, 0x30, 0x0a, 0x0c, 0xa2, 0x0a, 0xe4, 0x33, 0xfd, 0x7f, 0x03, 0x12, 0x2a, 0xce, 
+0x80, 0x1f, 0xe4, 0xfd, 0x7f, 0x03, 0x12, 0x2a, 0xce, 0x80, 0x16, 0x30, 0x0a, 0x0c, 0xa2, 0x0a, 
+0xe4, 0x33, 0xfd, 0x7f, 0x04, 0x12, 0x2a, 0xce, 0x80, 0x07, 0xe4, 0xfd, 0x7f, 0x04, 0x12, 0x2a, 
+0xce, 0x15, 0x53, 0x30, 0x0a, 0x0b, 0x12, 0x18, 0xbd, 0xf5, 0x83, 0xe0, 0x54, 0xf7, 0xf0, 0x80, 
+0x09, 0x12, 0x18, 0xcb, 0xf5, 0x83, 0xe0, 0x54, 0xf7, 0xf0, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 
+0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 
+0x12, 0x18, 0xd9, 0x14, 0x60, 0x2d, 0x14, 0x60, 0x55, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0e, 0xac, 
+0x90, 0xfa, 0xb9, 0xe0, 0x70, 0x04, 0xa3, 0xe0, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 
+0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x78, 0x6d, 0xe6, 0x44, 0x01, 0xf6, 0xe4, 0xff, 
+0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 
+0x30, 0xe0, 0x07, 0xe5, 0x53, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe1, 0x0a, 0xe5, 
+0x53, 0xd3, 0x94, 0x01, 0x40, 0x03, 0x02, 0x0e, 0xac, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0x90, 0xfa, 
+0xb9, 0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0xff, 
+0x12, 0x2f, 0x3b, 0x40, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 
+0x02, 0x0e, 0xac, 0xe5, 0x53, 0x70, 0x09, 0x30, 0x0a, 0x03, 0x02, 0x19, 0x7a, 0x02, 0x19, 0x3e, 
+0xe5, 0x2c, 0x20, 0xe1, 0x03, 0x02, 0x0e, 0xac, 0x15, 0x53, 0x30, 0x0a, 0x0b, 0x12, 0x18, 0xbd, 
+0xf5, 0x83, 0xe0, 0x44, 0x08, 0xf0, 0x80, 0x09, 0x12, 0x18, 0xcb, 0xf5, 0x83, 0xe0, 0x44, 0x08, 
+0xf0, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 
+0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 
+0x12, 0x18, 0xd9, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe1, 0x03, 0x02, 0x0e, 0xac, 
+0x90, 0xfa, 0xba, 0xe0, 0x90, 0xff, 0xff, 0xf0, 0xe0, 0x60, 0x05, 0x43, 0x2c, 0x01, 0x80, 0x03, 
+0x53, 0x2c, 0xfe, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe7, 0x03, 0x02, 0x0e, 0xac, 
+0xe5, 0x35, 0x45, 0x34, 0x70, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 0xd9, 0x60, 0x03, 0x02, 0x0e, 
+0xac, 0x90, 0xfa, 0xb9, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0xec, 0x24, 0xfe, 0x60, 0x3a, 0x14, 0x60, 
+0x75, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xed, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 
+0x49, 0x12, 0x19, 0x73, 0x7d, 0x03, 0x12, 0x0e, 0xf3, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x0e, 
+0xb0, 0x90, 0xfa, 0xb2, 0xe0, 0xfd, 0xa3, 0x12, 0x18, 0x93, 0x12, 0x0f, 0x0f, 0x50, 0x02, 0x80, 
+0x04, 0xae, 0x34, 0xaf, 0x35, 0x02, 0x0f, 0x40, 0x12, 0x18, 0x49, 0x90, 0xf9, 0x65, 0xe0, 0x30, 
+0xe4, 0x0d, 0x12, 0x19, 0x73, 0x7d, 0x14, 0x12, 0x0e, 0xf3, 0x60, 0x10, 0x02, 0x0e, 0xac, 0x12, 
+0x19, 0x73, 0x7d, 0x04, 0x12, 0x0f, 0x47, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x0e, 0xb0, 0x90, 
+0xfa, 0xb2, 0xe0, 0xfd, 0xa3, 0x12, 0x18, 0x93, 0x12, 0x0f, 0x0f, 0x50, 0x02, 0x80, 0x04, 0xae, 
+0x34, 0xaf, 0x35, 0x02, 0x0f, 0x40, 0x12, 0x19, 0x73, 0x7d, 0x05, 0x12, 0x0f, 0x47, 0x60, 0x03, 
+0x02, 0x0e, 0xac, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb2, 0x12, 0x18, 0x90, 0x7d, 0x01, 0x12, 0x23, 
+0xee, 0x90, 0xfa, 0xb3, 0xe4, 0x75, 0xf0, 0x03, 0x12, 0x14, 0x2f, 0x90, 0xfa, 0xba, 0xe0, 0x90, 
+0xfa, 0xb1, 0xf0, 0xe4, 0xf5, 0x52, 0x90, 0xfa, 0xb1, 0xe0, 0xff, 0xe5, 0x52, 0xc3, 0x9f, 0x50, 
+0x24, 0x12, 0x18, 0x8a, 0x12, 0x0f, 0x52, 0xff, 0xfd, 0x90, 0xfa, 0xb3, 0xe4, 0x8d, 0xf0, 0x12, 
+0x14, 0x2f, 0x90, 0xfa, 0xb2, 0xe0, 0xc3, 0x9f, 0xf0, 0xd3, 0x94, 0x00, 0x50, 0x03, 0x02, 0x0e, 
+0xac, 0x05, 0x52, 0x80, 0xd1, 0x12, 0x18, 0x8a, 0x12, 0x0f, 0x52, 0x24, 0xfe, 0xff, 0x90, 0xfa, 
+0xb2, 0xf0, 0xfd, 0xa3, 0xe4, 0x75, 0xf0, 0x02, 0x12, 0x14, 0x2f, 0x7a, 0xf9, 0x79, 0x6e, 0x7b, 
+0x01, 0x8b, 0x2d, 0x8a, 0x2e, 0x89, 0x2f, 0xe9, 0x24, 0x02, 0xf9, 0xe4, 0x3a, 0xfa, 0x12, 0x18, 
+0x90, 0x12, 0x23, 0xee, 0x8f, 0x52, 0x05, 0x52, 0x05, 0x52, 0x12, 0x18, 0x2a, 0xe5, 0x52, 0x12, 
+0x13, 0xfb, 0x12, 0x18, 0x2a, 0x90, 0x00, 0x01, 0x74, 0x03, 0x12, 0x14, 0x0d, 0xaf, 0x52, 0x7e, 
+0x00, 0xc3, 0xef, 0x95, 0x35, 0xee, 0x95, 0x34, 0x50, 0x02, 0x80, 0x04, 0xae, 0x34, 0xaf, 0x35, 
+0x8e, 0x30, 0x8f, 0x31, 0x02, 0x29, 0x2d, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe7, 0x03, 0x02, 
+0x0e, 0xac, 0xe5, 0x35, 0x64, 0x01, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 
+0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb9, 0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 
+0x02, 0x0e, 0xac, 0x12, 0x18, 0xd9, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe0, 0x06, 
+0x20, 0xe1, 0x03, 0x02, 0x0e, 0xac, 0x75, 0x2d, 0x00, 0x75, 0x2e, 0x00, 0x75, 0x2f, 0x29, 0x02, 
+0x0f, 0x2f, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x45, 0x34, 0x60, 0x03, 
+0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xd3, 0x90, 0xfa, 0xba, 
+0xe0, 0x94, 0x01, 0x90, 0xfa, 0xb9, 0xe0, 0x94, 0x00, 0x40, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 
+0xd9, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe0, 0x06, 0x20, 0xe1, 0x03, 0x02, 0x0e, 
+0xac, 0x90, 0xfa, 0xba, 0xe0, 0xf5, 0x29, 0xe5, 0x29, 0x70, 0x08, 0x43, 0x2c, 0x01, 0x53, 0x2c, 
+0xfd, 0x80, 0x06, 0x53, 0x2c, 0xfe, 0x43, 0x2c, 0x02, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 
+0x20, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x64, 0x01, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 
+0xac, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb9, 0xe0, 0x70, 0x02, 
+0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 0xd9, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0e, 
+0xac, 0xe5, 0x2c, 0x20, 0xe1, 0x03, 0x02, 0x0e, 0xac, 0x7f, 0x01, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 
+0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xd3, 
+0x90, 0xfa, 0xba, 0xe0, 0x94, 0x00, 0x90, 0xfa, 0xb9, 0xe0, 0x94, 0x00, 0x40, 0x03, 0x02, 0x0e, 
+0xac, 0x12, 0x18, 0xd9, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe1, 0x03, 
+0x02, 0x0e, 0xac, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0x90, 0xff, 0x01, 0x12, 0x19, 0x8a, 0xef, 0x12, 
+0x13, 0xfb, 0x90, 0xfa, 0xb5, 0x12, 0x19, 0x8a, 0x90, 0x00, 0x01, 0xef, 0x12, 0x14, 0x0d, 0x90, 
+0x00, 0x02, 0xe4, 0x12, 0x14, 0x0d, 0x74, 0x03, 0x12, 0x18, 0x1b, 0x90, 0xfa, 0xb9, 0xe0, 0xff, 
+0xa3, 0xe0, 0x85, 0x2f, 0x82, 0x85, 0x2e, 0x83, 0xcf, 0xf0, 0xa3, 0xef, 0xf0, 0x90, 0xff, 0x01, 
+0xe0, 0x12, 0x15, 0x0f, 0x09, 0x3d, 0x02, 0x09, 0x5f, 0x04, 0x09, 0x81, 0x05, 0x09, 0xad, 0x06, 
+0x09, 0xcb, 0x07, 0x09, 0xe9, 0x08, 0x0a, 0x07, 0x09, 0x0a, 0x25, 0x0b, 0x0a, 0xda, 0x80, 0x0c, 
+0xfa, 0x81, 0x0d, 0x1c, 0x82, 0x0b, 0x21, 0x83, 0x0b, 0x6a, 0x84, 0x0b, 0x89, 0x85, 0x0b, 0xc5, 
+0x86, 0x0c, 0x07, 0x87, 0x0c, 0x95, 0x88, 0x0c, 0xd0, 0x89, 0x0a, 0x43, 0x92, 0x0a, 0x43, 0x93, 
+0x0d, 0xcf, 0xc0, 0x0e, 0x00, 0xc1, 0x0e, 0x11, 0xc2, 0x00, 0x00, 0x0e, 0x9b, 0xe5, 0x2c, 0x20, 
+0xe7, 0x05, 0x7f, 0x05, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 
+0xfd, 0x7c, 0x00, 0x7f, 0x07, 0x02, 0x10, 0x9c, 0xe4, 0xfd, 0x7f, 0x07, 0x02, 0x2c, 0xc0, 0xe5, 
+0x2c, 0x20, 0xe7, 0x05, 0x7f, 0x05, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 
+0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0c, 0x02, 0x10, 0x9c, 0xe4, 0xfd, 0x7f, 0x07, 0x02, 0x2c, 
+0xc0, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xaf, 0x12, 0x19, 0x99, 0x50, 0x06, 0xe5, 0x35, 
+0x45, 0x34, 0x70, 0x05, 0x7f, 0x02, 0x02, 0x2e, 0xa5, 0x90, 0xfa, 0xb5, 0xe0, 0x24, 0xfe, 0x24, 
+0xfd, 0x50, 0x02, 0x80, 0x03, 0x02, 0x2f, 0x28, 0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 
+0xe7, 0x03, 0x02, 0x0e, 0xaf, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 
+0x00, 0x7f, 0x08, 0x02, 0x10, 0x9c, 0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 
+0x02, 0x0e, 0xaf, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 
+0x09, 0x02, 0x10, 0x9c, 0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 
+0xaf, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0a, 0x02, 
+0x10, 0x9c, 0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xaf, 0x12, 
+0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0b, 0x02, 0x10, 0x9c, 
+0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xaf, 0x12, 0x18, 0xe0, 
+0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0e, 0x02, 0x10, 0x9c, 0x7f, 0x07, 
+0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x56, 0x12, 0x18, 0xd9, 0x70, 0x4a, 0x90, 0xff, 0x02, 
+0xe0, 0xf5, 0x52, 0xe5, 0x52, 0xb4, 0x82, 0x05, 0x75, 0x52, 0x61, 0x80, 0x12, 0xe5, 0x52, 0xb4, 
+0x83, 0x05, 0x75, 0x52, 0x62, 0x80, 0x08, 0xe5, 0x52, 0xc4, 0x54, 0xf0, 0x04, 0xf5, 0x52, 0x12, 
+0x17, 0x8b, 0x12, 0x19, 0x6c, 0x12, 0x22, 0xb8, 0x12, 0x18, 0xe8, 0x12, 0x13, 0xce, 0x60, 0x05, 
+0x12, 0x2f, 0x76, 0x80, 0x06, 0x85, 0x2a, 0x30, 0x85, 0x2b, 0x31, 0x75, 0x2d, 0x01, 0x75, 0x2e, 
+0xf9, 0x75, 0x2f, 0x71, 0x02, 0x29, 0x2d, 0xe4, 0xfd, 0x7f, 0x05, 0x02, 0x2c, 0xc0, 0x12, 0x18, 
+0xd9, 0x60, 0x05, 0x7f, 0x05, 0x02, 0x2e, 0xa5, 0x12, 0x19, 0x99, 0x40, 0x05, 0x7f, 0x03, 0x02, 
+0x2e, 0xa5, 0x90, 0xff, 0x02, 0xe0, 0xf5, 0x52, 0xe5, 0x52, 0xb4, 0x82, 0x05, 0x75, 0x52, 0x61, 
+0x80, 0x12, 0xe5, 0x52, 0xb4, 0x83, 0x05, 0x75, 0x52, 0x62, 0x80, 0x08, 0xe5, 0x52, 0xc4, 0x54, 
+0xf0, 0x04, 0xf5, 0x52, 0x12, 0x17, 0x8b, 0x02, 0x2f, 0x28, 0x12, 0x19, 0xa3, 0x12, 0x27, 0x19, 
+0x12, 0x18, 0x9b, 0xe0, 0x54, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x78, 
+0x6e, 0x12, 0x14, 0xeb, 0x90, 0x00, 0x02, 0x12, 0x13, 0xce, 0x30, 0xe7, 0xf2, 0x90, 0x00, 0x02, 
+0xe4, 0x12, 0x14, 0x0d, 0x90, 0xfa, 0xb6, 0xe0, 0x44, 0x80, 0xff, 0xf0, 0x78, 0x82, 0xe6, 0xfc, 
+0x08, 0xe6, 0x8c, 0x83, 0x12, 0x18, 0xa3, 0xef, 0xf0, 0x12, 0x2f, 0x80, 0xe4, 0xff, 0x02, 0x2e, 
+0xa5, 0x90, 0xfa, 0xb5, 0xe0, 0x64, 0x01, 0x70, 0x1f, 0x90, 0xfa, 0xb9, 0xe0, 0xff, 0x7e, 0x00, 
+0x70, 0x06, 0xa3, 0xe0, 0xf5, 0x90, 0x80, 0x2d, 0xc2, 0xaf, 0xef, 0xf4, 0x52, 0x90, 0x90, 0xfa, 
+0xba, 0xe0, 0x42, 0x90, 0xd2, 0xaf, 0x80, 0x1d, 0x90, 0xfa, 0xb9, 0xe0, 0xff, 0x7e, 0x00, 0x70, 
+0x06, 0xa3, 0xe0, 0xf5, 0xb0, 0x80, 0x0e, 0xc2, 0xaf, 0xef, 0xf4, 0x52, 0xb0, 0x90, 0xfa, 0xba, 
+0xe0, 0x42, 0xb0, 0xd2, 0xaf, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0x49, 0x90, 0xfa, 0xb5, 
+0xe0, 0xb4, 0x01, 0x0a, 0x12, 0x18, 0x2a, 0xe5, 0x90, 0x12, 0x13, 0xfb, 0x80, 0x08, 0x12, 0x18, 
+0x2a, 0xe5, 0xb0, 0x12, 0x13, 0xfb, 0x02, 0x0f, 0x2f, 0x90, 0xf9, 0x65, 0xe0, 0x20, 0xe1, 0x30, 
+0x12, 0x18, 0x53, 0x60, 0x18, 0x04, 0x70, 0x28, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x09, 0x90, 0xff, 
+0xa4, 0xe0, 0x44, 0x10, 0xf0, 0x80, 0x19, 0x12, 0x19, 0xad, 0xf0, 0x80, 0x13, 0x90, 0xfa, 0xb6, 
+0xe0, 0x60, 0x09, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x10, 0xf0, 0x80, 0x04, 0x12, 0x19, 0xb4, 0xf0, 
+0xe4, 0xff, 0x02, 0x2e, 0xa5, 0x90, 0xf9, 0x65, 0xe0, 0x20, 0xe1, 0x36, 0x12, 0x18, 0x53, 0x60, 
+0x1b, 0x04, 0x70, 0x2e, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x20, 
+0xf0, 0x80, 0x1f, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xdf, 0xf0, 0x80, 0x16, 0x90, 0xfa, 0xb6, 0xe0, 
+0x60, 0x09, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x07, 0x90, 0xff, 0xb4, 0xe0, 0x54, 
+0xdf, 0xf0, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0x53, 0x60, 0x46, 0x04, 0x60, 0x03, 0x02, 
+0x0c, 0x90, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x17, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x04, 0xf0, 0x90, 
+0xf9, 0x65, 0xe0, 0x30, 0xe1, 0x6a, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x61, 0x90, 
+0xff, 0xa4, 0xe0, 0x54, 0xfb, 0xf0, 0x90, 0xf9, 0x65, 0xe0, 0x30, 0xe1, 0x53, 0x30, 0x95, 0x09, 
+0x90, 0xff, 0xa4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x47, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xfd, 0xf0, 
+0x80, 0x3e, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x17, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x04, 0xf0, 0x90, 
+0xf9, 0x65, 0xe0, 0x30, 0xe1, 0x2a, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x21, 0x90, 
+0xff, 0xb4, 0xe0, 0x54, 0xfb, 0xf0, 0x90, 0xf9, 0x65, 0xe0, 0x30, 0xe1, 0x13, 0x30, 0x93, 0x09, 
+0x90, 0xff, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x07, 0x90, 0xff, 0xb4, 0xe0, 0x54, 0xfd, 0xf0, 
+0xe4, 0xff, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0x53, 0x60, 0x1b, 0x04, 0x70, 0x2e, 0x90, 0xfa, 0xb6, 
+0xe0, 0x60, 0x09, 0x90, 0xff, 0xa2, 0xe0, 0x44, 0x40, 0xf0, 0x80, 0x1f, 0x90, 0xff, 0xa2, 0xe0, 
+0x54, 0xbf, 0xf0, 0x80, 0x16, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x09, 0x90, 0xff, 0xb2, 0xe0, 0x44, 
+0x40, 0xf0, 0x80, 0x07, 0x90, 0xff, 0xb2, 0xe0, 0x54, 0xbf, 0xf0, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 
+0x12, 0x18, 0x49, 0x12, 0x18, 0x5b, 0x60, 0x0f, 0x04, 0x70, 0x16, 0x90, 0xff, 0xa4, 0xe0, 0x12, 
+0x18, 0x2a, 0x12, 0x13, 0xfb, 0x80, 0x0a, 0x90, 0xff, 0xb4, 0xe0, 0x12, 0x18, 0x2a, 0x12, 0x13, 
+0xfb, 0x75, 0x30, 0x00, 0x75, 0x31, 0x01, 0x02, 0x29, 0x2d, 0xe4, 0xff, 0x12, 0x2e, 0xa5, 0x12, 
+0x19, 0x46, 0x7f, 0x03, 0x12, 0x11, 0x9f, 0x90, 0xff, 0xfc, 0xe0, 0x54, 0x7f, 0xf0, 0x7f, 0xff, 
+0x7e, 0x00, 0x12, 0x2d, 0xee, 0xc2, 0x90, 0xc2, 0xaf, 0x00, 0x80, 0xfd, 0xe4, 0xf5, 0x54, 0xf5, 
+0x55, 0x90, 0xfa, 0xbb, 0x74, 0x3e, 0xf0, 0xa3, 0xe4, 0xf0, 0x90, 0xfa, 0xb3, 0xf0, 0xa3, 0x74, 
+0x15, 0xf0, 0xe0, 0x54, 0x3f, 0xff, 0xc3, 0x74, 0x40, 0x9f, 0x90, 0xfa, 0xb8, 0xf0, 0xd3, 0x94, 
+0x00, 0xe4, 0x94, 0x3e, 0x40, 0x08, 0x90, 0xfa, 0xbc, 0xe0, 0x90, 0xfa, 0xb8, 0xf0, 0x12, 0x0e, 
+0xd6, 0xe5, 0x23, 0x45, 0x22, 0x70, 0x73, 0x12, 0x18, 0x62, 0x90, 0xfa, 0xbb, 0x12, 0x19, 0x65, 
+0x60, 0x27, 0xd3, 0xef, 0x94, 0x40, 0xee, 0x94, 0x00, 0x40, 0x08, 0x90, 0xfa, 0xb8, 0x74, 0x40, 
+0xf0, 0x80, 0x08, 0x90, 0xfa, 0xbc, 0xe0, 0x90, 0xfa, 0xb8, 0xf0, 0x12, 0x0e, 0xd6, 0xe5, 0x23, 
+0x45, 0x22, 0x70, 0x46, 0x12, 0x18, 0x62, 0x80, 0xd1, 0x75, 0x52, 0x02, 0x90, 0xfa, 0xbb, 0xe4, 
+0xf0, 0xa3, 0x04, 0xf0, 0x90, 0xfa, 0xb3, 0xe4, 0xf0, 0xa3, 0x74, 0x0f, 0xf0, 0x7b, 0x00, 0x7a, 
+0x00, 0x79, 0x52, 0x90, 0xfa, 0xbc, 0xe0, 0xf5, 0x50, 0x7d, 0x0f, 0x7c, 0x00, 0x12, 0x26, 0x25, 
+0x75, 0x22, 0x00, 0x8f, 0x23, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x52, 0xe4, 0xf5, 0x40, 0xf5, 0x41, 
+0x7d, 0x01, 0x12, 0x23, 0xee, 0xe4, 0xf5, 0x22, 0xf5, 0x23, 0xaf, 0x23, 0x02, 0x2e, 0xa5, 0x90, 
+0xfa, 0xba, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x30, 0xe7, 0x10, 0xe0, 0x54, 0x0f, 0x90, 0xf9, 0x62, 
+0xf0, 0xd3, 0x94, 0x00, 0x40, 0x15, 0xc2, 0x95, 0x80, 0x11, 0x90, 0xfa, 0xb6, 0xe0, 0x54, 0x0f, 
+0x90, 0xf9, 0x61, 0xf0, 0xd3, 0x94, 0x00, 0x40, 0x02, 0xc2, 0x94, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 
+0x12, 0x19, 0xa3, 0xbf, 0x01, 0x04, 0xd2, 0x93, 0x80, 0x02, 0xc2, 0x93, 0xe4, 0xff, 0x02, 0x2e, 
+0xa5, 0x90, 0xfa, 0xba, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x54, 0x03, 0x14, 0x60, 0x0a, 0x14, 0x60, 
+0x0f, 0x14, 0x60, 0x08, 0x24, 0x03, 0x70, 0x2b, 0xd2, 0x91, 0x80, 0x27, 0xc2, 0x91, 0x80, 0x23, 
+0x12, 0x19, 0xad, 0x12, 0x0e, 0xfe, 0x60, 0x04, 0xd2, 0x91, 0x80, 0x17, 0x90, 0xff, 0xa4, 0xe0, 
+0x44, 0x10, 0x12, 0x0e, 0xfe, 0xff, 0xbf, 0xa0, 0x04, 0xc2, 0x91, 0x80, 0x02, 0xd2, 0x91, 0x12, 
+0x19, 0xad, 0xf0, 0x90, 0xfa, 0xb6, 0xe0, 0x54, 0x0c, 0xff, 0x13, 0x13, 0x54, 0x3f, 0x14, 0x60, 
+0x0a, 0x14, 0x60, 0x0f, 0x14, 0x60, 0x08, 0x24, 0x03, 0x70, 0x2b, 0xd2, 0x92, 0x80, 0x27, 0xc2, 
+0x92, 0x80, 0x23, 0x12, 0x19, 0xb4, 0x12, 0x0f, 0x1e, 0x60, 0x04, 0xd2, 0x92, 0x80, 0x17, 0x90, 
+0xff, 0xb4, 0xe0, 0x44, 0x10, 0x12, 0x0f, 0x1e, 0xff, 0xbf, 0xa0, 0x04, 0xc2, 0x92, 0x80, 0x02, 
+0xd2, 0x92, 0x12, 0x19, 0xb4, 0xf0, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x07, 
+0xe4, 0xfd, 0x7f, 0x05, 0x02, 0x2c, 0xc0, 0x7f, 0x05, 0x02, 0x2e, 0xa5, 0x12, 0x2f, 0x76, 0x22, 
+0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb2, 0x90, 0xfa, 0xb3, 0xe0, 0xf5, 0x40, 0xa3, 0xe0, 0xf5, 0x41, 
+0x7d, 0x01, 0x12, 0x23, 0xee, 0x90, 0xfa, 0xb3, 0xe4, 0x75, 0xf0, 0x03, 0x12, 0x14, 0x2f, 0xab, 
+0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 0x22, 0xaa, 0x54, 0xa9, 0x55, 0x7b, 0xff, 0x90, 0xfa, 0xb3, 0xe0, 
+0xfc, 0xa3, 0xe0, 0xfd, 0x90, 0xfa, 0xb8, 0xe0, 0xf5, 0x50, 0x12, 0x26, 0x25, 0x75, 0x22, 0x00, 
+0x8f, 0x23, 0x22, 0x12, 0x20, 0xc5, 0x7e, 0x00, 0x8e, 0x22, 0x8f, 0x23, 0xef, 0x22, 0xf0, 0x7f, 
+0x01, 0x12, 0x11, 0x9f, 0x90, 0xff, 0xa6, 0xe0, 0x90, 0xfa, 0xb7, 0xf0, 0x54, 0xa0, 0x22, 0x12, 
+0x23, 0xee, 0x8f, 0x52, 0x7e, 0x00, 0xc3, 0xef, 0x95, 0x35, 0xee, 0x95, 0x34, 0x22, 0xf0, 0x7f, 
+0x01, 0x12, 0x11, 0x9f, 0x90, 0xff, 0xb6, 0xe0, 0x90, 0xfa, 0xb7, 0xf0, 0x54, 0xa0, 0x22, 0x75, 
+0x30, 0x00, 0x75, 0x31, 0x01, 0x02, 0x29, 0x2d, 0x90, 0xfa, 0xb5, 0xe0, 0xff, 0x02, 0x2f, 0x3b, 
+0x8e, 0x30, 0x8f, 0x31, 0x02, 0x29, 0x2d, 0x12, 0x20, 0xc5, 0x7e, 0x00, 0x8e, 0x22, 0x8f, 0x23, 
+0xef, 0x22, 0x7d, 0x01, 0x12, 0x23, 0xee, 0x90, 0xfa, 0xb0, 0xe0, 0x22, 0xef, 0x90, 0xf8, 0x04, 
+0xf0, 0x22, 0xc0, 0xa8, 0xc2, 0xaf, 0xee, 0x60, 0x0a, 0xc0, 0x05, 0x7d, 0x7f, 0xdd, 0xfe, 0xde, 
+0xfa, 0xd0, 0x05, 0xef, 0xc3, 0x94, 0x15, 0x50, 0x03, 0xd0, 0xa8, 0x22, 0x13, 0x70, 0x03, 0xd0, 
+0xa8, 0x22, 0xff, 0xd5, 0x07, 0xfd, 0xd0, 0xa8, 0x22, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 
+0x04, 0xc0, 0x05, 0xe5, 0x44, 0x24, 0x08, 0xf8, 0x86, 0x05, 0x53, 0x05, 0x7f, 0x7c, 0xff, 0x12, 
+0x0f, 0xfe, 0x7f, 0x00, 0x7e, 0x00, 0xe5, 0x49, 0x60, 0x46, 0xfc, 0x90, 0xf9, 0x19, 0xe0, 0x54, 
+0x7f, 0x6d, 0x70, 0x0f, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0xa3, 0x15, 
+0x49, 0x80, 0x07, 0xa3, 0xa3, 0xa3, 0xdc, 0xe6, 0x80, 0x26, 0xdc, 0x06, 0xd0, 0x82, 0xd0, 0x83, 
+0x80, 0x1e, 0xe0, 0xf8, 0xa3, 0xe0, 0xf9, 0xa3, 0xe0, 0xfa, 0xd0, 0x82, 0xd0, 0x83, 0xe8, 0xf0, 
+0xa3, 0xe9, 0xf0, 0xa3, 0xea, 0xf0, 0xa3, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x80, 0xda, 
+0x12, 0x10, 0x95, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0x22, 0x85, 0xa8, 
+0x4a, 0x75, 0xa8, 0x88, 0xec, 0x70, 0x02, 0x7c, 0x3f, 0x8c, 0x43, 0x22, 0xe5, 0x44, 0x24, 0x08, 
+0xf8, 0x76, 0x00, 0x12, 0x10, 0xec, 0x80, 0xfb, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x04, 
+0xc0, 0x06, 0x7c, 0xff, 0x12, 0x0f, 0xfe, 0xe5, 0x49, 0x60, 0x42, 0xfe, 0x90, 0xf9, 0x19, 0xe0, 
+0x54, 0x7f, 0x6f, 0x70, 0x0b, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x15, 0x49, 0x80, 0x07, 
+0xa3, 0xa3, 0xa3, 0xde, 0xea, 0x80, 0x26, 0xde, 0x06, 0xd0, 0x82, 0xd0, 0x83, 0x80, 0xd8, 0xe0, 
+0xf8, 0xa3, 0xe0, 0xf9, 0xa3, 0xe0, 0xfa, 0xd0, 0x82, 0xd0, 0x83, 0xe8, 0xf0, 0xa3, 0xe9, 0xf0, 
+0xa3, 0xea, 0xf0, 0xa3, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x80, 0xda, 0x78, 0x08, 0x08, 
+0x79, 0x18, 0x09, 0x7c, 0x01, 0xe6, 0x54, 0x7f, 0x6f, 0x70, 0x06, 0x76, 0x00, 0x77, 0x00, 0x80, 
+0x06, 0x08, 0x09, 0x0c, 0xbc, 0x08, 0xee, 0x12, 0x10, 0x95, 0xd0, 0x06, 0xd0, 0x04, 0xd0, 0x02, 
+0xd0, 0x01, 0xd0, 0x00, 0x22, 0x75, 0x43, 0x00, 0x85, 0x4a, 0xa8, 0x22, 0xc0, 0xf0, 0xc0, 0x82, 
+0xc0, 0x83, 0xc3, 0xe5, 0x49, 0x24, 0xe8, 0x50, 0x05, 0x12, 0x10, 0xec, 0x80, 0xf4, 0xef, 0x60, 
+0x31, 0x90, 0x2e, 0x2c, 0xe4, 0x93, 0xc3, 0x9f, 0x40, 0x2f, 0xc0, 0x04, 0x7c, 0xff, 0x12, 0x0f, 
+0xfe, 0xd0, 0x04, 0x43, 0x07, 0x80, 0xe5, 0x49, 0x75, 0xf0, 0x03, 0xa4, 0x24, 0x19, 0xf5, 0x82, 
+0xe4, 0x34, 0xf9, 0xf5, 0x83, 0xef, 0xf0, 0xec, 0xa3, 0xf0, 0xed, 0xa3, 0xf0, 0x05, 0x49, 0x12, 
+0x10, 0x95, 0xd0, 0x83, 0xd0, 0x82, 0xd0, 0xf0, 0x22, 0x02, 0x11, 0x1a, 0xc0, 0x04, 0x7c, 0x20, 
+0xd2, 0x8c, 0xd2, 0x8d, 0xd5, 0x04, 0xfd, 0xd0, 0x04, 0x22, 0x75, 0xa8, 0x00, 0x75, 0x88, 0x00, 
+0x75, 0xb8, 0x00, 0x75, 0xf0, 0x00, 0x75, 0xd0, 0x00, 0xe4, 0xf8, 0x90, 0xf8, 0x04, 0xf0, 0x90, 
+0x00, 0x00, 0xf6, 0x08, 0xb8, 0x00, 0xfb, 0x02, 0x00, 0x00, 0xc2, 0xaf, 0xe4, 0x90, 0xff, 0x48, 
+0xf0, 0x90, 0xff, 0x50, 0xf0, 0x90, 0xff, 0x08, 0xf0, 0x90, 0xff, 0x10, 0xf0, 0x90, 0xff, 0x80, 
+0xf0, 0xa3, 0xa3, 0xf0, 0xd2, 0xb1, 0xc2, 0xb0, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x7e, 
+0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0xd2, 0xb0, 0xd2, 
+0xb1, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x7e, 
+0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x80, 0xcc, 0xc3, 0xee, 0x94, 0x02, 0x50, 0x04, 0x7e, 0x03, 
+0x7f, 0xe8, 0xef, 0xf4, 0xff, 0xee, 0xf4, 0xfe, 0x0f, 0xbf, 0x00, 0x01, 0x0e, 0x8f, 0x48, 0x8e, 
+0x47, 0x22, 0xc3, 0xef, 0x94, 0xbc, 0xee, 0x94, 0x02, 0x50, 0x04, 0x7e, 0x07, 0x7f, 0xd0, 0xef, 
+0xf4, 0xff, 0xee, 0xf4, 0xfe, 0x0f, 0xbf, 0x00, 0x01, 0x0e, 0x8f, 0x46, 0x8e, 0x45, 0x22, 0xef, 
+0x70, 0x01, 0x22, 0xc0, 0x00, 0xe5, 0x44, 0x24, 0x18, 0xf8, 0xa6, 0x07, 0xe5, 0x44, 0x24, 0x08, 
+0xf8, 0xc6, 0x54, 0x7f, 0xf6, 0xe6, 0x30, 0xe7, 0x03, 0xd0, 0x00, 0x22, 0x12, 0x10, 0xec, 0x80, 
+0xf4, 0xc0, 0x00, 0x7f, 0x01, 0xef, 0x24, 0x08, 0xf8, 0xe6, 0x60, 0x09, 0x0f, 0xbf, 0x08, 0xf5, 
+0x12, 0x10, 0xec, 0x80, 0xee, 0xd0, 0x00, 0x22, 0xc0, 0xf0, 0xc0, 0x82, 0xc0, 0x83, 0xc0, 0x00, 
+0xc0, 0x06, 0xc0, 0x04, 0xed, 0x24, 0x10, 0xf8, 0x76, 0xa0, 0xed, 0x75, 0xf0, 0x21, 0xa4, 0x24, 
+0x05, 0xf5, 0x82, 0xe4, 0x34, 0xf8, 0xf5, 0x83, 0xc0, 0x82, 0xc0, 0x83, 0xa3, 0xa3, 0xe4, 0x78, 
+0x0d, 0xf0, 0xa3, 0xd8, 0xfc, 0xef, 0x54, 0x7f, 0x75, 0xf0, 0x02, 0xa4, 0x24, 0x0e, 0xf5, 0x82, 
+0xe5, 0xf0, 0x34, 0x2e, 0xf5, 0x83, 0xe4, 0x93, 0xfe, 0x74, 0x01, 0x93, 0xfc, 0xd0, 0x83, 0xd0, 
+0x82, 0xec, 0xf0, 0xa3, 0xee, 0xf0, 0xed, 0x24, 0x08, 0xf8, 0xef, 0x44, 0x80, 0xf6, 0xd0, 0x04, 
+0xd0, 0x06, 0xd0, 0x00, 0xd0, 0x83, 0xd0, 0x82, 0xd0, 0xf0, 0x22, 0x75, 0x44, 0x00, 0x75, 0x49, 
+0x00, 0x7a, 0x08, 0x79, 0x18, 0x78, 0x08, 0x76, 0x00, 0x77, 0x00, 0x08, 0x09, 0xda, 0xf8, 0x90, 
+0xf8, 0x04, 0xe0, 0xfc, 0x90, 0x2e, 0x2c, 0xe4, 0x93, 0xc3, 0x9c, 0x50, 0x05, 0xe4, 0x90, 0xf8, 
+0x04, 0xf0, 0x78, 0x08, 0x74, 0x80, 0x44, 0x7f, 0xf6, 0x74, 0x01, 0x44, 0x10, 0xf5, 0x89, 0x75, 
+0xb8, 0x00, 0xd2, 0xab, 0xd2, 0xa9, 0x22, 0x75, 0x81, 0x91, 0xd2, 0x8e, 0xd2, 0x8c, 0xd2, 0xaf, 
+0xe5, 0x49, 0x60, 0x36, 0xff, 0x90, 0xf9, 0x19, 0xe0, 0x54, 0x80, 0x60, 0x28, 0x78, 0x08, 0x79, 
+0x08, 0xe0, 0x54, 0x7f, 0xfa, 0x7b, 0x00, 0xe6, 0x54, 0x7f, 0xb5, 0x02, 0x02, 0x7b, 0xff, 0x08, 
+0xd9, 0xf5, 0xeb, 0x70, 0x10, 0xea, 0xf0, 0xc0, 0x07, 0x12, 0x11, 0xc1, 0xad, 0x07, 0xaf, 0x02, 
+0x12, 0x11, 0xd8, 0xd0, 0x07, 0xa3, 0xa3, 0xa3, 0xdf, 0xce, 0x12, 0x10, 0xec, 0x80, 0xc1, 0xe7, 
+0x09, 0xf6, 0x08, 0xdf, 0xfa, 0x80, 0x46, 0xe7, 0x09, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x3e, 0x88, 
+0x82, 0x8c, 0x83, 0xe7, 0x09, 0xf0, 0xa3, 0xdf, 0xfa, 0x80, 0x32, 0xe3, 0x09, 0xf6, 0x08, 0xdf, 
+0xfa, 0x80, 0x78, 0xe3, 0x09, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x70, 0x88, 0x82, 0x8c, 0x83, 0xe3, 
+0x09, 0xf0, 0xa3, 0xdf, 0xfa, 0x80, 0x64, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0xa3, 0xf6, 0x08, 0xdf, 
+0xfa, 0x80, 0x58, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0xa3, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x4c, 0x80, 
+0xd2, 0x80, 0xfa, 0x80, 0xc6, 0x80, 0xd4, 0x80, 0x69, 0x80, 0xf2, 0x80, 0x33, 0x80, 0x10, 0x80, 
+0xa6, 0x80, 0xea, 0x80, 0x9a, 0x80, 0xa8, 0x80, 0xda, 0x80, 0xe2, 0x80, 0xca, 0x80, 0x33, 0x89, 
+0x82, 0x8a, 0x83, 0xec, 0xfa, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 
+0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0x0d, 
+0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0xa3, 0xf6, 0x08, 0xdf, 0xf9, 0xec, 0xfa, 0xa9, 0xf0, 0xed, 
+0xfb, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xec, 0xfa, 0xe0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 
+0x83, 0xcc, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 0xdf, 0xea, 0xde, 0xe8, 
+0x80, 0xdb, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0xa3, 0xf2, 0x08, 0xdf, 0xf9, 0x80, 0xcc, 0x88, 
+0xf0, 0xef, 0x60, 0x01, 0x0e, 0x4e, 0x60, 0xc3, 0x88, 0xf0, 0xed, 0x24, 0x02, 0xb4, 0x04, 0x00, 
+0x50, 0xb9, 0xf5, 0x82, 0xeb, 0x24, 0x02, 0xb4, 0x04, 0x00, 0x50, 0xaf, 0x23, 0x23, 0x45, 0x82, 
+0x23, 0x90, 0x13, 0x0f, 0x73, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 
+0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 
+0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 
+0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 
+0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 
+0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xf8, 0xbb, 0x01, 
+0x0d, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe8, 0xf0, 0x22, 0x50, 0x06, 
+0xe9, 0x25, 0x82, 0xc8, 0xf6, 0x22, 0xbb, 0xfe, 0x05, 0xe9, 0x25, 0x82, 0xc8, 0xf2, 0x22, 0xc5, 
+0xf0, 0xf8, 0xa3, 0xe0, 0x28, 0xf0, 0xc5, 0xf0, 0xf8, 0xe5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 
+0x83, 0xe0, 0x38, 0xf0, 0x22, 0xa3, 0xf8, 0xe0, 0xc5, 0xf0, 0x25, 0xf0, 0xf0, 0xe5, 0x82, 0x15, 
+0x82, 0x70, 0x02, 0x15, 0x83, 0xe0, 0xc8, 0x38, 0xf0, 0xe8, 0x22, 0xbb, 0x01, 0x10, 0xe5, 0x82, 
+0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0xf5, 0xf0, 0xa3, 0xe0, 0x22, 0x50, 0x09, 
+0xe9, 0x25, 0x82, 0xf8, 0x86, 0xf0, 0x08, 0xe6, 0x22, 0xbb, 0xfe, 0x0a, 0xe9, 0x25, 0x82, 0xf8, 
+0xe2, 0xf5, 0xf0, 0x08, 0xe2, 0x22, 0xe5, 0x83, 0x2a, 0xf5, 0x83, 0xe9, 0x93, 0xf5, 0xf0, 0xa3, 
+0xe9, 0x93, 0x22, 0xbb, 0x01, 0x0a, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xe5, 0xf0, 0xa3, 0xf0, 0x22, 
+0x50, 0x06, 0xf7, 0x09, 0xa7, 0xf0, 0x19, 0x22, 0xbb, 0xfe, 0x06, 0xf3, 0xe5, 0xf0, 0x09, 0xf3, 
+0x19, 0x22, 0xf8, 0xbb, 0x01, 0x11, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 
+0xe8, 0xf0, 0xe5, 0xf0, 0xa3, 0xf0, 0x22, 0x50, 0x09, 0xe9, 0x25, 0x82, 0xc8, 0xf6, 0x08, 0xa6, 
+0xf0, 0x22, 0xbb, 0xfe, 0x09, 0xe9, 0x25, 0x82, 0xc8, 0xf2, 0xe5, 0xf0, 0x08, 0xf2, 0x22, 0xa4, 
+0x25, 0x82, 0xf5, 0x82, 0xe5, 0xf0, 0x35, 0x83, 0xf5, 0x83, 0x22, 0xe6, 0xfb, 0x08, 0xe6, 0xfa, 
+0x08, 0xe6, 0xf9, 0x22, 0xeb, 0xf6, 0x08, 0xea, 0xf6, 0x08, 0xe9, 0xf6, 0x22, 0xe0, 0xfb, 0xa3, 
+0xe0, 0xfa, 0xa3, 0xe0, 0xf9, 0x22, 0xeb, 0xf0, 0xa3, 0xea, 0xf0, 0xa3, 0xe9, 0xf0, 0x22, 0xd0, 
+0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 
+0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 
+0xa3, 0xa3, 0xa3, 0x80, 0xdf, 0x90, 0xff, 0xfa, 0x74, 0x08, 0xf0, 0xa3, 0x74, 0x16, 0xf0, 0x90, 
+0xff, 0xf9, 0x74, 0x02, 0xf0, 0x90, 0xfa, 0xcb, 0xe4, 0xf0, 0xa3, 0x74, 0x0b, 0xf0, 0x7b, 0x00, 
+0x7a, 0x00, 0x79, 0x37, 0x75, 0x40, 0x00, 0xf5, 0x41, 0x7d, 0x01, 0x12, 0x23, 0xee, 0xe5, 0x37, 
+0x24, 0x80, 0x90, 0xff, 0xf8, 0xf0, 0xe5, 0x37, 0x64, 0x07, 0x60, 0x0b, 0xe5, 0x37, 0x64, 0x06, 
+0x60, 0x05, 0xe5, 0x37, 0xb4, 0x14, 0x1b, 0xd2, 0x94, 0xd2, 0x95, 0xd2, 0x92, 0xd2, 0x93, 0xe5, 
+0x37, 0xb4, 0x07, 0x08, 0x90, 0xf9, 0x65, 0x74, 0x02, 0xf0, 0x80, 0x06, 0x90, 0xf9, 0x65, 0x74, 
+0x01, 0xf0, 0x90, 0xfa, 0xcb, 0xe4, 0xf0, 0xa3, 0x74, 0x0d, 0xf0, 0x12, 0x17, 0x71, 0x90, 0xff, 
+0xf5, 0xe5, 0x37, 0xf0, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcb, 0xe4, 0xfd, 0x12, 0x20, 0xc5, 0x90, 
+0xfa, 0xcb, 0xe4, 0x75, 0xf0, 0x03, 0x12, 0x14, 0x2f, 0x12, 0x17, 0x71, 0xe5, 0x37, 0x30, 0xe7, 
+0x02, 0xd2, 0x02, 0xe4, 0xf5, 0x2c, 0xf5, 0x2a, 0xf5, 0x2b, 0xf5, 0x29, 0x12, 0x19, 0x92, 0x12, 
+0x18, 0x49, 0x12, 0x19, 0x6c, 0x90, 0xf9, 0x66, 0x12, 0x15, 0x06, 0x90, 0xf9, 0x6b, 0x12, 0x15, 
+0x06, 0x90, 0xff, 0xff, 0xe4, 0xf0, 0x90, 0xff, 0x83, 0xe0, 0xe4, 0xf0, 0x90, 0xff, 0x81, 0x74, 
+0x80, 0xf0, 0xa3, 0x74, 0x84, 0xf0, 0x90, 0xff, 0x80, 0xf0, 0xe4, 0xf5, 0x37, 0xe5, 0x37, 0x12, 
+0x18, 0xbf, 0xf5, 0x83, 0xe4, 0xf0, 0xe5, 0x37, 0x12, 0x18, 0xcd, 0xf5, 0x83, 0xe4, 0xf0, 0x05, 
+0x37, 0xe5, 0x37, 0xb4, 0x07, 0xe7, 0x78, 0x80, 0x76, 0xfe, 0x08, 0x76, 0xf0, 0x90, 0x2f, 0x06, 
+0xe4, 0x93, 0xff, 0x78, 0x7e, 0xf6, 0xfd, 0xad, 0x07, 0x90, 0x2f, 0x13, 0xe4, 0x93, 0xff, 0x08, 
+0xf6, 0xff, 0xed, 0x54, 0x0f, 0xfd, 0x12, 0x18, 0xaf, 0x74, 0x84, 0xf0, 0xed, 0x75, 0xf0, 0x08, 
+0xa4, 0x24, 0x47, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xc3, 0x74, 0xf0, 0x9f, 
+0x78, 0x81, 0xf6, 0x74, 0xfe, 0x94, 0x00, 0x18, 0x12, 0x18, 0x41, 0xce, 0xc3, 0x13, 0xce, 0x13, 
+0xd8, 0xf9, 0xff, 0xed, 0x12, 0x19, 0x07, 0xef, 0xf0, 0xed, 0x12, 0x19, 0x2d, 0xe4, 0xf5, 0x37, 
+0xe5, 0x37, 0x90, 0x2f, 0x00, 0x93, 0xff, 0x78, 0x7e, 0xf6, 0xfd, 0xe5, 0x37, 0x25, 0xe0, 0x24, 
+0x07, 0xf5, 0x82, 0xe4, 0x34, 0x2f, 0xf5, 0x83, 0xe4, 0x93, 0x08, 0xf6, 0xed, 0x30, 0xe7, 0x53, 
+0x18, 0xe6, 0x54, 0x0f, 0xf9, 0x12, 0x18, 0xaf, 0x12, 0x19, 0x15, 0x24, 0x47, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0x12, 0x18, 0x31, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xff, 0xe9, 0x12, 0x19, 
+0x07, 0xef, 0xf0, 0x12, 0x18, 0x38, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x12, 0x19, 0x1a, 
+0x24, 0x45, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xe9, 0x12, 0x19, 0x2d, 0xe9, 
+0x75, 0xf0, 0x08, 0xa4, 0x24, 0x46, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x74, 0x80, 0xf0, 
+0x02, 0x17, 0x46, 0x78, 0x7e, 0xe6, 0x54, 0x0f, 0xf9, 0x12, 0x18, 0xf9, 0x12, 0x19, 0x15, 0x24, 
+0x07, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0x12, 0x18, 0x31, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 
+0x12, 0x19, 0x1a, 0x24, 0x01, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0x12, 0x18, 
+0x38, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x12, 0x19, 0x1a, 0x24, 0x05, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xe9, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x02, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0xf5, 0x83, 0xe4, 0xf0, 0xe9, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x06, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0xf5, 0x83, 0xe4, 0xf0, 0x05, 0x37, 0xe5, 0x37, 0x64, 0x04, 0x60, 0x03, 0x02, 0x16, 
+0x70, 0x90, 0x2f, 0x05, 0xe4, 0x93, 0xff, 0x78, 0x7e, 0xf6, 0x12, 0x18, 0xf7, 0xe4, 0xf0, 0x90, 
+0x2f, 0x04, 0x93, 0xff, 0xf6, 0x12, 0x18, 0xad, 0xe4, 0xf0, 0x90, 0xff, 0xfd, 0x74, 0x05, 0xf0, 
+0x22, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x37, 0x90, 0xfa, 0xcb, 0xe4, 0x75, 0xf0, 0x01, 0x12, 0x14, 
+0x45, 0x85, 0xf0, 0x41, 0xf5, 0x40, 0x7d, 0x01, 0x02, 0x23, 0xee, 0xab, 0x2d, 0xaa, 0x2e, 0xa9, 
+0x2f, 0xe5, 0x52, 0x12, 0x13, 0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 0x35, 0x2e, 0xf5, 
+0x2e, 0xab, 0x2d, 0xfa, 0xa9, 0x2f, 0x74, 0x11, 0x12, 0x13, 0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 
+0x2f, 0xe4, 0x35, 0x2e, 0xf5, 0x2e, 0x90, 0xff, 0x06, 0xe0, 0xab, 0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 
+0x12, 0x13, 0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 0x35, 0x2e, 0xf5, 0x2e, 0xab, 0x2d, 
+0xfa, 0xa9, 0x2f, 0xe4, 0x12, 0x13, 0xfb, 0x04, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 0x35, 0x2e, 0xf5, 
+0x2e, 0xab, 0x2d, 0xfa, 0xa9, 0x2f, 0xe4, 0x12, 0x13, 0xfb, 0x04, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 
+0x35, 0x2e, 0xf5, 0x2e, 0x90, 0xff, 0x04, 0xe0, 0xab, 0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 0x12, 0x13, 
+0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 0x35, 0x2e, 0xf5, 0x2e, 0x90, 0xff, 0x05, 0xe0, 
+0xab, 0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 0x12, 0x13, 0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 
+0x35, 0x2e, 0xf5, 0x2e, 0x22, 0xf5, 0x83, 0xe0, 0x54, 0x08, 0xab, 0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 
+0x22, 0xf5, 0x83, 0xef, 0xf0, 0xfd, 0x7c, 0x00, 0xc3, 0x78, 0x81, 0xe6, 0x9d, 0xf6, 0x18, 0xe6, 
+0x9c, 0xf6, 0xe6, 0xfe, 0x08, 0xe6, 0x78, 0x03, 0x22, 0x75, 0x2d, 0x01, 0x75, 0x2e, 0xf9, 0x75, 
+0x2f, 0x6e, 0x22, 0x90, 0xfa, 0xba, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x90, 0xfa, 0xb5, 0xe0, 0x24, 
+0xfc, 0x22, 0x90, 0xfa, 0xb8, 0xe0, 0xff, 0x7e, 0x00, 0xc3, 0x90, 0xfa, 0xbc, 0xe0, 0x9f, 0xf0, 
+0x90, 0xfa, 0xbb, 0xe0, 0x9e, 0xf0, 0x90, 0xfa, 0xb3, 0xee, 0x8f, 0xf0, 0x12, 0x14, 0x2f, 0xef, 
+0x25, 0x55, 0xf5, 0x55, 0xee, 0x35, 0x54, 0xf5, 0x54, 0x22, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb0, 
+0x90, 0xfa, 0xb3, 0xe0, 0xf5, 0x40, 0xa3, 0xe0, 0xf5, 0x41, 0x22, 0x78, 0x82, 0xe6, 0xfe, 0x08, 
+0xe6, 0x8e, 0x83, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x83, 0xf5, 0x83, 0x22, 0x54, 0x0f, 0x75, 
+0xf0, 0x08, 0xa4, 0x24, 0x40, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x22, 0xe5, 0x53, 0x75, 
+0xf0, 0x08, 0xa4, 0x24, 0x48, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0x22, 0xe5, 0x53, 0x75, 0xf0, 0x08, 
+0xa4, 0x24, 0x08, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0x22, 0x90, 0xff, 0x00, 0xe0, 0x54, 0x1f, 0x22, 
+0x90, 0xfa, 0xb5, 0xe0, 0xff, 0x24, 0xfc, 0x22, 0x75, 0x2a, 0x00, 0x8f, 0x2b, 0x90, 0xf9, 0x6b, 
+0x12, 0x14, 0xfd, 0x90, 0x00, 0x02, 0x22, 0x54, 0x0f, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x00, 0xf5, 
+0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x22, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x41, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0xf5, 0x83, 0x22, 0x74, 0x80, 0xf0, 0x08, 0xe6, 0xff, 0xe9, 0x75, 0xf0, 0x08, 0xa4, 
+0x22, 0x74, 0xae, 0x25, 0x36, 0xf5, 0x82, 0xe4, 0x34, 0xfa, 0xf5, 0x83, 0x22, 0x75, 0xf0, 0x08, 
+0xa4, 0x24, 0x42, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x74, 0x80, 0xf0, 0x22, 0x90, 0xff, 
+0x82, 0xe0, 0x44, 0x08, 0xf0, 0x22, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x03, 0xf0, 0x90, 0xff, 0xfc, 
+0xe0, 0x54, 0xfd, 0xf0, 0x22, 0x78, 0x6d, 0xe6, 0x54, 0xfd, 0xf6, 0x90, 0xff, 0xfd, 0x74, 0x65, 
+0xf0, 0x22, 0x12, 0x14, 0xdf, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0x4e, 0x22, 0x7b, 0x01, 0x7a, 0xf9, 
+0x79, 0x6e, 0x22, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb3, 0x22, 0x90, 0xff, 0x80, 0xe0, 0x44, 0x08, 
+0xf0, 0x22, 0x90, 0xff, 0x83, 0xe0, 0x54, 0x7f, 0xf0, 0x22, 0xe0, 0xff, 0x90, 0xf9, 0x66, 0x02, 
+0x14, 0xfd, 0x75, 0x30, 0x01, 0x75, 0x31, 0x09, 0x22, 0xd3, 0xe5, 0x35, 0x94, 0x08, 0xe5, 0x34, 
+0x94, 0x01, 0x22, 0x90, 0xfa, 0xba, 0xe0, 0xff, 0x90, 0xfa, 0xb6, 0xf0, 0x22, 0x90, 0xff, 0xa4, 
+0xe0, 0x54, 0xef, 0x22, 0x90, 0xff, 0xb4, 0xe0, 0x54, 0xef, 0x22, 0x8f, 0x38, 0x12, 0x27, 0x19, 
+0x78, 0x86, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x8e, 0x83, 0x24, 0x08, 0x12, 0x20, 0x25, 0xe0, 0xfd, 
+0x12, 0x20, 0xa6, 0x8a, 0x83, 0x24, 0x0a, 0x12, 0x20, 0x25, 0xed, 0xf0, 0x12, 0x20, 0x7c, 0x24, 
+0x07, 0x12, 0x20, 0x25, 0xe0, 0xff, 0x12, 0x20, 0xbe, 0x24, 0x09, 0x12, 0x20, 0x25, 0xef, 0xf0, 
+0x90, 0xf9, 0x65, 0xe0, 0x30, 0xe4, 0x20, 0x08, 0x12, 0x20, 0x2f, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 
+0xe0, 0x25, 0xe0, 0xff, 0x05, 0x82, 0xd5, 0x82, 0x02, 0x15, 0x83, 0x15, 0x82, 0xe0, 0x33, 0xd0, 
+0x82, 0xd0, 0x83, 0xf0, 0xa3, 0xef, 0xf0, 0x78, 0x86, 0x12, 0x20, 0x2f, 0xe0, 0xfc, 0xa3, 0xe0, 
+0xfd, 0xec, 0xff, 0x12, 0x20, 0xa6, 0x8a, 0x83, 0x24, 0x08, 0x12, 0x20, 0x25, 0xef, 0xf0, 0xed, 
+0x12, 0x20, 0xbe, 0x24, 0x07, 0x12, 0x20, 0x25, 0xed, 0xf0, 0x8b, 0x82, 0x8a, 0x83, 0xa3, 0xa3, 
+0xe0, 0xff, 0x53, 0x07, 0xc7, 0x08, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x12, 0x20, 0x69, 0xa3, 0xe0, 
+0x30, 0xe3, 0x12, 0x8d, 0x82, 0x8c, 0x83, 0xe5, 0x82, 0x24, 0x05, 0x12, 0x20, 0x25, 0xe0, 0x90, 
+0x2f, 0x4d, 0x93, 0x42, 0x07, 0x53, 0x07, 0xfb, 0x12, 0x20, 0xae, 0x24, 0x06, 0x12, 0x20, 0x25, 
+0xe0, 0x60, 0x03, 0x43, 0x07, 0x04, 0x53, 0x07, 0xfc, 0x78, 0x86, 0x12, 0x20, 0x96, 0x24, 0x04, 
+0x12, 0x20, 0x25, 0xe0, 0x42, 0x07, 0x43, 0x07, 0x80, 0x12, 0x20, 0xa6, 0xf5, 0x82, 0x8a, 0x83, 
+0xa3, 0xa3, 0xef, 0xf0, 0x12, 0x20, 0xbe, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0xff, 0x8d, 0x82, 
+0x8c, 0x83, 0xa3, 0xa3, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0x30, 0xe1, 0x05, 0x53, 0x07, 0xdf, 0x80, 
+0x03, 0x43, 0x07, 0x20, 0xec, 0x30, 0xe4, 0x05, 0x53, 0x07, 0xef, 0x80, 0x03, 0x43, 0x07, 0x10, 
+0x90, 0xf9, 0x65, 0xe0, 0xfe, 0x54, 0x03, 0x60, 0x4c, 0x53, 0x07, 0xdf, 0xee, 0x30, 0xe1, 0x42, 
+0x12, 0x20, 0xae, 0x24, 0x09, 0x12, 0x20, 0x25, 0xe0, 0x14, 0x60, 0x31, 0x14, 0x60, 0x29, 0x14, 
+0x60, 0x26, 0x14, 0x60, 0x28, 0x24, 0x04, 0x70, 0x2c, 0xe5, 0x38, 0xb4, 0x03, 0x0d, 0x30, 0x95, 
+0x05, 0x43, 0x07, 0x02, 0x80, 0x1f, 0x53, 0x07, 0xfd, 0x80, 0x1a, 0x30, 0x93, 0x05, 0x43, 0x07, 
+0x02, 0x80, 0x12, 0x53, 0x07, 0xfd, 0x80, 0x0d, 0x43, 0x07, 0x02, 0x80, 0x08, 0x53, 0x07, 0xfd, 
+0x80, 0x03, 0x53, 0x07, 0xfd, 0x12, 0x20, 0x94, 0x24, 0x04, 0x12, 0x20, 0x25, 0xef, 0xf0, 0x8d, 
+0x82, 0x8c, 0x83, 0xa3, 0xa3, 0xa3, 0xe0, 0xff, 0x90, 0xf9, 0x65, 0xe0, 0xfe, 0x54, 0x03, 0x60, 
+0x4a, 0xee, 0x30, 0xe1, 0x43, 0x08, 0x12, 0x20, 0xb0, 0x24, 0x09, 0x12, 0x20, 0x25, 0xe0, 0x14, 
+0x60, 0x2c, 0x14, 0x60, 0x2e, 0x14, 0x60, 0x26, 0x14, 0x60, 0x28, 0x24, 0x04, 0x70, 0x2c, 0xe5, 
+0x38, 0xb4, 0x03, 0x0d, 0x30, 0x94, 0x05, 0x53, 0x07, 0x7f, 0x80, 0x1f, 0x43, 0x07, 0x80, 0x80, 
+0x1a, 0x30, 0x92, 0x05, 0x53, 0x07, 0x7f, 0x80, 0x12, 0x43, 0x07, 0x80, 0x80, 0x0d, 0x53, 0x07, 
+0x7f, 0x80, 0x08, 0x43, 0x07, 0x80, 0x80, 0x03, 0x53, 0x07, 0x7f, 0x78, 0x86, 0x12, 0x20, 0x65, 
+0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0x30, 0xe0, 0x05, 0x43, 0x07, 0x20, 0x80, 0x03, 0x53, 0x07, 0xdf, 
+0xec, 0x30, 0xe3, 0x05, 0x43, 0x07, 0x40, 0x80, 0x03, 0x53, 0x07, 0xbf, 0xec, 0x30, 0xe0, 0x05, 
+0x43, 0x07, 0x10, 0x80, 0x03, 0x53, 0x07, 0xef, 0xed, 0x30, 0xe4, 0x05, 0x43, 0x07, 0x08, 0x80, 
+0x03, 0x53, 0x07, 0xf7, 0xed, 0x30, 0xe5, 0x05, 0x43, 0x07, 0x04, 0x80, 0x03, 0x53, 0x07, 0xfb, 
+0xed, 0x30, 0xe6, 0x05, 0x43, 0x07, 0x01, 0x80, 0x03, 0x53, 0x07, 0xfe, 0xed, 0x30, 0xe7, 0x05, 
+0x43, 0x07, 0x02, 0x80, 0x03, 0x53, 0x07, 0xfd, 0x78, 0x84, 0x12, 0x20, 0x65, 0xa3, 0xef, 0xf0, 
+0x12, 0x2f, 0x80, 0x7f, 0x00, 0x22, 0x12, 0x0f, 0x89, 0x78, 0x8e, 0xef, 0xf6, 0x12, 0x27, 0x19, 
+0x12, 0x20, 0x70, 0x8e, 0x83, 0x24, 0x09, 0x12, 0x20, 0x25, 0xe0, 0xfd, 0x12, 0x20, 0x53, 0x90, 
+0x00, 0x0a, 0x12, 0x20, 0x78, 0x24, 0x0a, 0x12, 0x20, 0x25, 0xe0, 0x90, 0x00, 0x0b, 0x12, 0x14, 
+0x0d, 0x12, 0x20, 0x70, 0xf5, 0x82, 0x8e, 0x83, 0xa3, 0xa3, 0xa3, 0xe0, 0xf5, 0x59, 0x12, 0x20, 
+0x7c, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0xf5, 0x5a, 0x8f, 0x82, 0x8e, 0x83, 0xa3, 0xa3, 0xe0, 
+0xf5, 0x5b, 0xe5, 0x59, 0xc4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x78, 0x8e, 0xf6, 0xd3, 0x94, 0x00, 
+0x40, 0x06, 0xe5, 0x5a, 0x30, 0xe1, 0x01, 0x06, 0x78, 0x8e, 0xe6, 0x12, 0x20, 0x52, 0x90, 0x00, 
+0x0c, 0xef, 0x12, 0x14, 0x0d, 0x78, 0x86, 0x12, 0x20, 0x2f, 0xa3, 0xa3, 0xe0, 0xfe, 0xa3, 0xe0, 
+0xff, 0x53, 0x07, 0x0c, 0x53, 0x06, 0xe6, 0xe5, 0x59, 0x30, 0xe5, 0x03, 0x43, 0x07, 0x01, 0xe5, 
+0x5a, 0x20, 0xe5, 0x0e, 0xe5, 0x59, 0x54, 0x7f, 0x70, 0x08, 0xe5, 0x59, 0x20, 0xe7, 0x03, 0x43, 
+0x07, 0x02, 0xe5, 0x59, 0x30, 0xe3, 0x03, 0x43, 0x07, 0x10, 0xe5, 0x59, 0x30, 0xe2, 0x03, 0x43, 
+0x07, 0x20, 0xe5, 0x59, 0x54, 0x03, 0x60, 0x03, 0x43, 0x07, 0x40, 0xe5, 0x59, 0x30, 0xe1, 0x03, 
+0x43, 0x07, 0x80, 0xe5, 0x59, 0x30, 0xe4, 0x03, 0x43, 0x06, 0x01, 0xe5, 0x59, 0x30, 0xe6, 0x03, 
+0x43, 0x06, 0x08, 0xe5, 0x5a, 0x20, 0xe4, 0x0e, 0xe5, 0x59, 0x54, 0x7f, 0x70, 0x08, 0xe5, 0x59, 
+0x20, 0xe7, 0x03, 0x43, 0x06, 0x10, 0x53, 0x07, 0xfb, 0x53, 0x06, 0x79, 0x90, 0x00, 0x05, 0xee, 
+0x8f, 0xf0, 0x12, 0x14, 0xb2, 0xe5, 0x5b, 0x30, 0xe3, 0x12, 0x54, 0x30, 0xff, 0xc4, 0x54, 0x0f, 
+0x12, 0x20, 0x52, 0x90, 0x00, 0x08, 0xef, 0x12, 0x14, 0x0d, 0x80, 0x0a, 0x12, 0x20, 0x53, 0x90, 
+0x00, 0x08, 0xe4, 0x12, 0x14, 0x0d, 0xe5, 0x5b, 0x54, 0x03, 0x12, 0x20, 0x52, 0x90, 0x00, 0x07, 
+0xef, 0x12, 0x14, 0x0d, 0xe5, 0x5b, 0x54, 0x04, 0xff, 0xc3, 0x13, 0x90, 0x00, 0x09, 0x12, 0x14, 
+0x0d, 0x90, 0x00, 0x07, 0x12, 0x13, 0xce, 0x70, 0x13, 0x12, 0x20, 0x53, 0xe9, 0x24, 0x09, 0xf9, 
+0xe4, 0x3a, 0xfa, 0x12, 0x13, 0xb5, 0xff, 0xc3, 0x13, 0x12, 0x13, 0xfb, 0x12, 0x20, 0x94, 0x24, 
+0x08, 0x12, 0x20, 0x25, 0xe0, 0xfe, 0x8d, 0x82, 0x8c, 0x83, 0xe5, 0x82, 0x24, 0x07, 0x12, 0x20, 
+0x25, 0xe0, 0xfd, 0xee, 0xed, 0x12, 0x20, 0x52, 0x90, 0x00, 0x03, 0xee, 0x8f, 0xf0, 0x12, 0x14, 
+0xb2, 0x12, 0x2f, 0x80, 0x7d, 0x0a, 0xe4, 0xff, 0x12, 0x2c, 0xc0, 0x02, 0x10, 0x0c, 0x90, 0xfa, 
+0xe2, 0xe0, 0xb4, 0x03, 0x06, 0x7e, 0x00, 0x7f, 0x40, 0x80, 0x04, 0x7e, 0x00, 0x7f, 0x08, 0x90, 
+0xfa, 0xd6, 0xee, 0xf0, 0xa3, 0xef, 0xf0, 0x90, 0x00, 0x05, 0x12, 0x13, 0xce, 0xff, 0x7e, 0x00, 
+0x90, 0xfa, 0xd2, 0xee, 0xf0, 0xa3, 0xef, 0xf0, 0x70, 0x03, 0x7f, 0x08, 0x22, 0x90, 0x00, 0x08, 
+0x12, 0x14, 0x5b, 0xff, 0x90, 0xfa, 0xd4, 0xe5, 0xf0, 0xf0, 0xa3, 0xef, 0xf0, 0xae, 0x02, 0xaf, 
+0x01, 0x8e, 0x56, 0x8f, 0x57, 0x74, 0x0a, 0x25, 0x57, 0xf5, 0x57, 0xe4, 0x35, 0x56, 0xf5, 0x56, 
+0x90, 0xfa, 0xd7, 0xe0, 0xff, 0x14, 0xfe, 0x90, 0xfa, 0xd5, 0xe0, 0x5e, 0xfe, 0xc3, 0xef, 0x9e, 
+0xff, 0x90, 0xfa, 0xd9, 0xf0, 0xc3, 0x90, 0xfa, 0xd3, 0xe0, 0x9f, 0x90, 0xfa, 0xd2, 0xe0, 0x94, 
+0x00, 0x50, 0x06, 0xa3, 0xe0, 0x90, 0xfa, 0xd9, 0xf0, 0x12, 0x1e, 0x2d, 0x60, 0x03, 0xe0, 0xff, 
+0x22, 0x12, 0x2a, 0x80, 0x90, 0xfa, 0xd2, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0x4e, 0x60, 0x2b, 0x90, 
+0xfa, 0xd6, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0xd3, 0xef, 0x9d, 0xee, 0x9c, 0x40, 0x07, 0xe0, 0x90, 
+0xfa, 0xd9, 0xf0, 0x80, 0x08, 0x90, 0xfa, 0xd3, 0xe0, 0x90, 0xfa, 0xd9, 0xf0, 0x12, 0x1e, 0x2d, 
+0x60, 0x03, 0xe0, 0xff, 0x22, 0x12, 0x2a, 0x80, 0x80, 0xca, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x58, 
+0xe4, 0xf5, 0x40, 0xf5, 0x41, 0x7d, 0x01, 0x12, 0x23, 0xee, 0x7f, 0x00, 0x22, 0xaa, 0x56, 0xa9, 
+0x57, 0x7b, 0x01, 0x90, 0xfa, 0xd4, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0x90, 0xfa, 0xd9, 0xe0, 0xf5, 
+0x50, 0x12, 0x26, 0x25, 0x90, 0xfa, 0xd8, 0xef, 0xf0, 0x22, 0xef, 0x24, 0xae, 0x60, 0x52, 0x24, 
+0xfe, 0x60, 0x2e, 0x24, 0xfe, 0x70, 0x03, 0x02, 0x1e, 0xed, 0x24, 0x06, 0x60, 0x03, 0x02, 0x1f, 
+0x35, 0x78, 0x77, 0xe6, 0x54, 0xfb, 0xf6, 0x90, 0xff, 0xa5, 0xe0, 0xf5, 0x36, 0x44, 0x0f, 0xf0, 
+0x74, 0x33, 0x90, 0xfa, 0x90, 0xf0, 0xe5, 0x36, 0xa3, 0xf0, 0x90, 0xfa, 0xae, 0x74, 0x01, 0xf0, 
+0x22, 0x78, 0x78, 0xe6, 0x54, 0xfb, 0xf6, 0x90, 0xff, 0xb5, 0xe0, 0xf5, 0x36, 0x44, 0x0f, 0xf0, 
+0x74, 0x43, 0x90, 0xfa, 0x92, 0xf0, 0xe5, 0x36, 0xa3, 0xf0, 0x90, 0xfa, 0xaf, 0x74, 0x01, 0xf0, 
+0x22, 0x90, 0xfa, 0x9c, 0xe0, 0xa3, 0x20, 0xe5, 0x03, 0x02, 0x1f, 0x35, 0x90, 0xff, 0xa6, 0xe0, 
+0x90, 0xfa, 0xc9, 0xf0, 0xa3, 0xf0, 0x90, 0xfa, 0xc9, 0xe0, 0xff, 0x54, 0x0f, 0xfe, 0x60, 0x10, 
+0x90, 0xff, 0xa6, 0x12, 0x20, 0x83, 0x90, 0xff, 0xa6, 0xe0, 0x90, 0xfa, 0xc9, 0xf0, 0x80, 0xe6, 
+0x90, 0xfa, 0xca, 0xe0, 0xff, 0x74, 0x34, 0xfe, 0x12, 0x29, 0xda, 0xef, 0x70, 0x57, 0x90, 0xfa, 
+0xca, 0xe0, 0xff, 0x74, 0x34, 0x90, 0xfa, 0x94, 0xf0, 0xef, 0xa3, 0xf0, 0x22, 0x90, 0xfa, 0xa6, 
+0xe0, 0xa3, 0x30, 0xe5, 0x40, 0x90, 0xff, 0xb6, 0xe0, 0x90, 0xfa, 0xc9, 0xf0, 0xa3, 0xf0, 0x90, 
+0xfa, 0xc9, 0xe0, 0xff, 0x54, 0x0f, 0xfe, 0x60, 0x10, 0x90, 0xff, 0xb6, 0x12, 0x20, 0x83, 0x90, 
+0xff, 0xb6, 0xe0, 0x90, 0xfa, 0xc9, 0xf0, 0x80, 0xe6, 0x90, 0xfa, 0xca, 0xe0, 0xff, 0x74, 0x44, 
+0xfe, 0x12, 0x29, 0xda, 0xef, 0x70, 0x0e, 0x90, 0xfa, 0xca, 0xe0, 0xff, 0x74, 0x44, 0x90, 0xfa, 
+0x96, 0xf0, 0xef, 0xa3, 0xf0, 0x22, 0xc0, 0xe0, 0xc0, 0xf0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0xd0, 
+0x75, 0xd0, 0x00, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x03, 0xc0, 0x04, 0xc0, 0x05, 0xc0, 
+0x06, 0xc0, 0x07, 0x90, 0xff, 0x92, 0xe0, 0xff, 0x90, 0xfa, 0xc8, 0xf0, 0x90, 0xff, 0x92, 0xe4, 
+0xf0, 0xef, 0x12, 0x15, 0x0f, 0x1f, 0xed, 0x26, 0x1f, 0xed, 0x2e, 0x1f, 0x90, 0x30, 0x1f, 0x90, 
+0x32, 0x1f, 0x9e, 0x38, 0x1f, 0xb0, 0x3a, 0x1f, 0xe2, 0x3e, 0x1f, 0xcd, 0x44, 0x1f, 0xc2, 0x46, 
+0x1f, 0xd8, 0x50, 0x1f, 0xd8, 0x52, 0x1f, 0xd8, 0x54, 0x1f, 0xd8, 0x56, 0x00, 0x00, 0x1f, 0xf2, 
+0x90, 0xfa, 0xc8, 0xe0, 0xfd, 0x7c, 0x00, 0x7f, 0x01, 0x12, 0x10, 0x9c, 0x80, 0x62, 0x7c, 0x00, 
+0x7d, 0x01, 0x7f, 0x03, 0x12, 0x10, 0x9c, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x50, 
+0x7c, 0x00, 0x7d, 0x01, 0x7f, 0x02, 0x12, 0x10, 0x9c, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x40, 0xf0, 
+0x80, 0x3e, 0x7c, 0x00, 0x7d, 0x01, 0x7f, 0x05, 0x12, 0x10, 0x9c, 0x80, 0x33, 0x7c, 0x00, 0x7d, 
+0x01, 0x7f, 0x06, 0x12, 0x10, 0x9c, 0x80, 0x28, 0x90, 0xfa, 0xc8, 0xe0, 0xff, 0x12, 0x1e, 0x4a, 
+0x80, 0x1e, 0x7c, 0x00, 0x7d, 0x01, 0x7f, 0x04, 0x12, 0x10, 0x9c, 0x80, 0x13, 0x12, 0x25, 0x13, 
+0x80, 0x0e, 0x90, 0xfa, 0xc8, 0xe0, 0x24, 0x00, 0xff, 0xe4, 0x34, 0xff, 0xfe, 0x12, 0x29, 0xda, 
+0xd0, 0x07, 0xd0, 0x06, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x03, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 
+0xd0, 0xd0, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xf0, 0xd0, 0xe0, 0x32, 0x78, 0x82, 0xe6, 0xfe, 0x08, 
+0xe6, 0x24, 0x04, 0x8e, 0x83, 0xf5, 0x82, 0xe4, 0x35, 0x83, 0xf5, 0x83, 0x22, 0x78, 0x82, 0xe6, 
+0xfe, 0x08, 0xe6, 0xf5, 0x82, 0x8e, 0x83, 0x22, 0x78, 0x86, 0xe6, 0xfe, 0x08, 0xe6, 0xaa, 0x06, 
+0xf8, 0xac, 0x02, 0x7d, 0x01, 0x7b, 0xff, 0x7a, 0x2f, 0x79, 0x52, 0x7e, 0x00, 0x7f, 0x0a, 0x02, 
+0x13, 0x8f, 0xff, 0x90, 0xf9, 0x6b, 0x02, 0x14, 0xfd, 0x90, 0xf9, 0x66, 0x12, 0x14, 0xfd, 0x90, 
+0x00, 0x04, 0x02, 0x13, 0xce, 0xe6, 0xfc, 0x08, 0xe6, 0xf5, 0x82, 0x8c, 0x83, 0xa3, 0xa3, 0x22, 
+0x78, 0x84, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x22, 0xed, 0x12, 0x14, 0x0d, 0x8f, 0x82, 0x8e, 0x83, 
+0xe5, 0x82, 0x22, 0xef, 0xf0, 0x90, 0xfa, 0xca, 0xe0, 0x54, 0x0f, 0x4e, 0xfe, 0xf0, 0xef, 0x54, 
+0xf0, 0x4e, 0xf0, 0x22, 0x78, 0x84, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x8c, 0x83, 0x22, 0xa6, 0x07, 
+0xe6, 0x24, 0x74, 0xf8, 0xe6, 0x22, 0x78, 0x84, 0xe6, 0xfa, 0x08, 0xe6, 0xfb, 0x22, 0x78, 0x86, 
+0xe6, 0xfc, 0x08, 0xe6, 0x8c, 0x83, 0x22, 0x26, 0xf6, 0x18, 0xee, 0x36, 0xf6, 0x22, 0x8b, 0x82, 
+0x8a, 0x83, 0xe5, 0x82, 0x22, 0x8b, 0x38, 0x8a, 0x39, 0x89, 0x3a, 0x8d, 0x3b, 0x90, 0xfa, 0xce, 
+0xe4, 0xf0, 0xa3, 0x74, 0x02, 0xf0, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcd, 0x90, 0xfa, 0xce, 0xe0, 
+0xf5, 0x40, 0xa3, 0xe0, 0xf5, 0x41, 0x7d, 0x01, 0x12, 0x23, 0xee, 0x90, 0xfa, 0xcd, 0xe0, 0x65, 
+0x3b, 0x60, 0x46, 0xa3, 0xe0, 0xff, 0xa3, 0xe0, 0xa3, 0xcf, 0xf0, 0xa3, 0xef, 0xf0, 0x12, 0x21, 
+0x54, 0x90, 0xfa, 0xcd, 0xe0, 0xff, 0x90, 0xfa, 0xd0, 0xe4, 0x8f, 0xf0, 0x12, 0x14, 0x2f, 0x12, 
+0x21, 0x54, 0x90, 0xfa, 0xd0, 0xe0, 0xff, 0xa3, 0xe0, 0x90, 0xfa, 0xce, 0xcf, 0xf0, 0xa3, 0xef, 
+0xf0, 0x90, 0xfa, 0xcd, 0xe0, 0xa3, 0x75, 0xf0, 0x00, 0x12, 0x14, 0x2f, 0x90, 0xfa, 0xce, 0xe4, 
+0x75, 0xf0, 0x04, 0x12, 0x14, 0x2f, 0x02, 0x20, 0xd6, 0x90, 0xfa, 0xcf, 0xe0, 0x24, 0x01, 0xff, 
+0x90, 0xfa, 0xce, 0xe0, 0x34, 0x00, 0xab, 0x38, 0xaa, 0x39, 0xa9, 0x3a, 0x8f, 0xf0, 0x12, 0x14, 
+0x93, 0x7f, 0x00, 0x22, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcd, 0x90, 0xfa, 0xce, 0xe4, 0x75, 0xf0, 
+0x01, 0x12, 0x14, 0x2f, 0x85, 0xf0, 0x41, 0xf5, 0x40, 0x7d, 0x01, 0x02, 0x23, 0xee, 0x8f, 0x68, 
+0x12, 0x27, 0x19, 0x12, 0x20, 0x70, 0x8e, 0x83, 0x24, 0x0b, 0x12, 0x20, 0x25, 0xe0, 0x54, 0xfb, 
+0xf0, 0x44, 0x02, 0xf0, 0x08, 0x12, 0x20, 0x65, 0xe0, 0xa3, 0x30, 0xe5, 0x0c, 0x12, 0x20, 0x7c, 
+0x24, 0x0b, 0x12, 0x20, 0x25, 0xe0, 0x44, 0x01, 0xf0, 0x78, 0x82, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 
+0xf5, 0x82, 0x8e, 0x83, 0xe0, 0x54, 0xb8, 0xfd, 0xf0, 0xe5, 0x68, 0x24, 0xfe, 0x44, 0x20, 0xfc, 
+0x4d, 0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0x54, 0xb8, 0xf0, 0x4c, 0xf0, 0x8f, 
+0x82, 0x8e, 0x83, 0xa3, 0x74, 0x03, 0xf0, 0x18, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x8e, 0x83, 0x24, 
+0x05, 0x12, 0x20, 0x25, 0xc0, 0x83, 0xc0, 0x82, 0xe0, 0xfd, 0x74, 0x95, 0x25, 0x68, 0xf5, 0x82, 
+0xe4, 0x34, 0xfa, 0xf5, 0x83, 0xe0, 0x54, 0xfc, 0x44, 0x03, 0xfc, 0xed, 0x4c, 0xd0, 0x82, 0xd0, 
+0x83, 0xf0, 0x8f, 0x82, 0x8e, 0x83, 0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x20, 
+0x25, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x2f, 0x80, 0x74, 0x74, 0x25, 0x68, 0xf8, 0x74, 0x04, 0x46, 
+0xf6, 0x7f, 0x00, 0x22, 0x8b, 0x62, 0x8a, 0x63, 0x89, 0x64, 0x12, 0x2a, 0x62, 0x90, 0xfa, 0xbf, 
+0x12, 0x15, 0x06, 0xaa, 0x63, 0xa9, 0x64, 0x90, 0xfa, 0xc2, 0x12, 0x15, 0x06, 0x90, 0xfa, 0xc3, 
+0xe4, 0x75, 0xf0, 0x0a, 0x12, 0x14, 0x2f, 0x90, 0xfa, 0xc2, 0x12, 0x14, 0xfd, 0xe9, 0x24, 0x01, 
+0xf9, 0xe4, 0x3a, 0xfa, 0x90, 0xfa, 0xc5, 0x12, 0x15, 0x06, 0xab, 0x62, 0xaa, 0x63, 0xa9, 0x64, 
+0x12, 0x2a, 0x6e, 0xe0, 0xff, 0xc3, 0x13, 0xf0, 0xe4, 0x78, 0x88, 0xf6, 0x90, 0xfa, 0xbd, 0xe0, 
+0xff, 0x78, 0x88, 0xe6, 0xc3, 0x9f, 0x50, 0x4a, 0x90, 0xfa, 0xbf, 0x12, 0x2a, 0x43, 0xff, 0x78, 
+0x89, 0xf6, 0x90, 0xfa, 0xc2, 0x12, 0x2a, 0x43, 0xfe, 0xf4, 0x5f, 0xff, 0x78, 0x89, 0xf6, 0x12, 
+0x2a, 0x40, 0x5e, 0x4f, 0xff, 0x78, 0x89, 0xf6, 0x12, 0x2a, 0x49, 0x75, 0xf0, 0x02, 0x12, 0x14, 
+0x2f, 0x90, 0xfa, 0xc3, 0xe4, 0x75, 0xf0, 0x02, 0x12, 0x14, 0x2f, 0xab, 0x62, 0xaa, 0x63, 0xa9, 
+0x64, 0x90, 0x00, 0x04, 0x12, 0x13, 0xce, 0x30, 0xe4, 0x03, 0x12, 0x2a, 0x58, 0x78, 0x88, 0x06, 
+0x80, 0xaa, 0xe4, 0x90, 0xfa, 0xbe, 0xf0, 0x22, 0x8b, 0x5c, 0x8a, 0x5d, 0x89, 0x5e, 0x90, 0xfa, 
+0xbe, 0x74, 0x06, 0xf0, 0xe4, 0x90, 0xfa, 0xbd, 0xf0, 0x12, 0x13, 0xb5, 0x24, 0x6e, 0x60, 0x26, 
+0x14, 0x70, 0x70, 0x12, 0x2a, 0x2f, 0x60, 0x09, 0x24, 0x30, 0x70, 0x12, 0x12, 0x22, 0x14, 0x80, 
+0x62, 0x12, 0x2a, 0x79, 0x12, 0x1d, 0x5e, 0x90, 0xfa, 0xbe, 0xef, 0xf0, 0x80, 0x55, 0x90, 0xfa, 
+0xbe, 0x74, 0x81, 0xf0, 0x80, 0x4d, 0x12, 0x2a, 0x2f, 0x60, 0x09, 0x24, 0x30, 0x70, 0x3e, 0x12, 
+0x29, 0x85, 0x80, 0x3f, 0xe5, 0x5e, 0x24, 0x03, 0xf9, 0xe4, 0x35, 0x5d, 0xfa, 0x7b, 0x01, 0xc0, 
+0x03, 0xc0, 0x02, 0xc0, 0x01, 0x12, 0x2a, 0x79, 0x90, 0x00, 0x05, 0x12, 0x13, 0xce, 0xfd, 0x90, 
+0x00, 0x08, 0x12, 0x14, 0x5b, 0xf5, 0x41, 0x85, 0xf0, 0x40, 0xd0, 0x01, 0xd0, 0x02, 0xd0, 0x03, 
+0x12, 0x23, 0xee, 0x90, 0xfa, 0xbd, 0xef, 0xf0, 0xe4, 0xa3, 0xf0, 0x80, 0x06, 0x90, 0xfa, 0xbe, 
+0x74, 0x81, 0xf0, 0x90, 0xfa, 0xbe, 0xe0, 0x12, 0x2a, 0x79, 0x90, 0x00, 0x02, 0x12, 0x14, 0x0d, 
+0x90, 0xfa, 0xbd, 0xe0, 0xff, 0x22, 0x12, 0x0f, 0x89, 0x7f, 0x02, 0x12, 0x11, 0x9f, 0x78, 0x6d, 
+0xe6, 0x44, 0x02, 0xf6, 0xd2, 0xb0, 0xd2, 0xb1, 0xd2, 0xb3, 0x90, 0xff, 0xa4, 0xe0, 0x90, 0xfa, 
+0x7a, 0xf0, 0x90, 0xff, 0xb4, 0xe0, 0x90, 0xfa, 0x7b, 0xf0, 0x90, 0xff, 0xa2, 0xe0, 0x90, 0xfa, 
+0x78, 0xf0, 0x90, 0xff, 0xb2, 0xe0, 0x90, 0xfa, 0x79, 0xf0, 0x90, 0xff, 0xa4, 0x74, 0x30, 0xf0, 
+0x90, 0xff, 0xb4, 0xf0, 0x90, 0xff, 0xa2, 0x74, 0x40, 0xf0, 0x90, 0xff, 0xb2, 0xf0, 0x90, 0xfa, 
+0xe3, 0xe5, 0xa8, 0xf0, 0x75, 0xa8, 0x81, 0x90, 0xff, 0x92, 0xe0, 0x60, 0x04, 0xe4, 0xf0, 0x80, 
+0xf6, 0x90, 0xff, 0xfd, 0x74, 0x3a, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x90, 0xfa, 0x7a, 
+0xe0, 0x90, 0xff, 0xa4, 0xf0, 0x90, 0xfa, 0x7b, 0xe0, 0x90, 0xff, 0xb4, 0xf0, 0x90, 0xfa, 0x78, 
+0xe0, 0x90, 0xff, 0xa2, 0xf0, 0x90, 0xfa, 0x79, 0xe0, 0x90, 0xff, 0xb2, 0xf0, 0x90, 0xf9, 0x15, 
+0xe0, 0x60, 0x02, 0xc2, 0xb3, 0x90, 0xfa, 0xe3, 0xe0, 0xf5, 0xa8, 0x02, 0x10, 0x0c, 0x8b, 0x3c, 
+0x8a, 0x3d, 0x89, 0x3e, 0x8d, 0x3f, 0xe5, 0x3f, 0x70, 0x03, 0xaf, 0x3f, 0x22, 0x12, 0x2a, 0xa8, 
+0x70, 0x16, 0x12, 0x2a, 0xc7, 0xe5, 0x40, 0x90, 0xff, 0xf1, 0xf0, 0x12, 0x2e, 0xd4, 0x50, 0xf2, 
+0x12, 0x24, 0x7b, 0x40, 0x0b, 0x7f, 0x00, 0x22, 0x12, 0x2a, 0xc7, 0x12, 0x24, 0x7b, 0x50, 0xf8, 
+0x90, 0xff, 0xf3, 0x74, 0xa1, 0xf0, 0xe5, 0x3f, 0xb4, 0x01, 0x07, 0x90, 0xff, 0xf0, 0xe0, 0x44, 
+0x02, 0xf0, 0x90, 0xff, 0xf1, 0xe4, 0xf0, 0xf5, 0x42, 0xe5, 0x3f, 0x14, 0xff, 0xe5, 0x42, 0xc3, 
+0x9f, 0x50, 0x2a, 0x12, 0x2e, 0xbd, 0x40, 0x03, 0xaf, 0x42, 0x22, 0xc3, 0xe5, 0x3f, 0x95, 0x42, 
+0xff, 0xbf, 0x02, 0x07, 0x90, 0xff, 0xf0, 0xe0, 0x44, 0x02, 0xf0, 0x12, 0x2a, 0xba, 0x05, 0x42, 
+0x74, 0x01, 0x25, 0x3e, 0xf5, 0x3e, 0xe4, 0x35, 0x3d, 0xf5, 0x3d, 0x80, 0xcc, 0x12, 0x2e, 0xbd, 
+0x40, 0x03, 0x7f, 0x18, 0x22, 0x12, 0x2a, 0xba, 0xaf, 0x3f, 0x22, 0x90, 0xff, 0xf1, 0xe5, 0x41, 
+0xf0, 0x02, 0x2e, 0xd4, 0x75, 0xa8, 0x40, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x91, 
+0x02, 0x24, 0xce, 0x02, 0x2e, 0x88, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 
+0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 
+0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 
+0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x28, 
+0xcb, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 
+0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 
+0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 
+0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 
+0xe7, 0x80, 0xbe, 0xe4, 0xf5, 0x36, 0x12, 0x19, 0x21, 0xe0, 0xb4, 0x04, 0x0d, 0xe5, 0x36, 0x24, 
+0x03, 0xff, 0x12, 0x2d, 0x4f, 0x12, 0x19, 0x21, 0xe4, 0xf0, 0x05, 0x36, 0xe5, 0x36, 0xc3, 0x94, 
+0x02, 0x40, 0xe3, 0xe4, 0xf5, 0x36, 0x75, 0xf0, 0x02, 0xe5, 0x36, 0x90, 0xfa, 0x90, 0x12, 0x19, 
+0x62, 0x60, 0x2c, 0x12, 0x29, 0xda, 0xef, 0x60, 0x52, 0x75, 0xf0, 0x02, 0xe5, 0x36, 0x90, 0xfa, 
+0x90, 0x12, 0x14, 0xdf, 0xe4, 0xf0, 0xa3, 0xf0, 0x75, 0xf0, 0x0a, 0xe5, 0x36, 0x90, 0xfa, 0x9c, 
+0x12, 0x14, 0xdf, 0xe0, 0xa3, 0x30, 0xe6, 0x33, 0x12, 0x19, 0x21, 0x74, 0x04, 0xf0, 0x22, 0x75, 
+0xf0, 0x02, 0xe5, 0x36, 0x90, 0xfa, 0x94, 0x12, 0x19, 0x62, 0x60, 0x16, 0x12, 0x29, 0xda, 0xef, 
+0x60, 0x19, 0x75, 0xf0, 0x02, 0xe5, 0x36, 0x90, 0xfa, 0x94, 0x12, 0x14, 0xdf, 0xe4, 0xf0, 0xa3, 
+0xf0, 0x22, 0x05, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x02, 0x40, 0x9b, 0x22, 0xe4, 0xff, 0x90, 0xff, 
+0x83, 0xe0, 0x54, 0x0f, 0xfe, 0xef, 0xc3, 0x9e, 0x50, 0x17, 0x74, 0xf0, 0x2f, 0xf5, 0x82, 0xe4, 
+0x34, 0xfe, 0xf5, 0x83, 0xe0, 0x12, 0x18, 0x2a, 0x12, 0x13, 0xfb, 0x0f, 0x12, 0x18, 0x19, 0x80, 
+0xdd, 0xef, 0xfd, 0xc3, 0xe5, 0x31, 0x9d, 0xf5, 0x31, 0xe5, 0x30, 0x94, 0x00, 0xf5, 0x30, 0xd3, 
+0xe5, 0x31, 0x94, 0x00, 0xe5, 0x30, 0x94, 0x00, 0x40, 0x06, 0xe4, 0x90, 0xff, 0x83, 0xf0, 0x22, 
+0x12, 0x19, 0x3e, 0x12, 0x19, 0x92, 0x12, 0x19, 0x8c, 0x12, 0x13, 0xb5, 0x24, 0x6e, 0x60, 0x1e, 
+0x14, 0x60, 0x1b, 0x24, 0x8e, 0x70, 0x2d, 0x90, 0x00, 0x01, 0x12, 0x13, 0xce, 0xff, 0x24, 0xfc, 
+0x60, 0x03, 0x04, 0x70, 0x1f, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0d, 0x02, 0x10, 0x9c, 0x12, 0x19, 
+0x6c, 0x12, 0x22, 0xb8, 0x12, 0x18, 0xe8, 0x12, 0x13, 0xce, 0x60, 0x03, 0x02, 0x2f, 0x76, 0xe4, 
+0xff, 0x12, 0x2f, 0x6a, 0x22, 0x8b, 0x4b, 0x8a, 0x4c, 0x89, 0x4d, 0x8c, 0x4e, 0x8d, 0x4f, 0xd2, 
+0x00, 0x12, 0x2a, 0xa8, 0x70, 0x16, 0x12, 0x2a, 0xc7, 0xe5, 0x4e, 0x90, 0xff, 0xf1, 0xf0, 0x12, 
+0x2e, 0xd4, 0x50, 0xf2, 0x12, 0x26, 0x9a, 0x40, 0x0b, 0x7f, 0x18, 0x22, 0x12, 0x2a, 0xc7, 0x12, 
+0x26, 0x9a, 0x50, 0xf8, 0xe4, 0xf5, 0x51, 0xe5, 0x50, 0x14, 0xff, 0xe5, 0x51, 0xc3, 0x9f, 0x50, 
+0x17, 0x12, 0x26, 0x8a, 0x40, 0x03, 0x7f, 0x18, 0x22, 0x05, 0x51, 0x74, 0x01, 0x25, 0x4d, 0xf5, 
+0x4d, 0xe4, 0x35, 0x4c, 0xf5, 0x4c, 0x80, 0xdf, 0x90, 0xff, 0xf0, 0xe0, 0x44, 0x01, 0xf0, 0x12, 
+0x26, 0x8a, 0x40, 0x03, 0x7f, 0x18, 0x22, 0x7f, 0x00, 0x22, 0xab, 0x4b, 0xaa, 0x4c, 0xa9, 0x4d, 
+0x12, 0x13, 0xb5, 0x90, 0xff, 0xf1, 0xf0, 0x02, 0x2e, 0xd4, 0x90, 0xff, 0xf1, 0xe5, 0x4f, 0xf0, 
+0x02, 0x2e, 0xd4, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcb, 0xe4, 0xfd, 0x12, 0x20, 0xc5, 0x90, 0xfa, 
+0xcb, 0xe4, 0x75, 0xf0, 0x09, 0x12, 0x14, 0x2f, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x37, 0x90, 0xfa, 
+0xcb, 0xe4, 0x75, 0xf0, 0x01, 0x12, 0x14, 0x45, 0x85, 0xf0, 0x41, 0xf5, 0x40, 0x7d, 0x01, 0x12, 
+0x23, 0xee, 0x90, 0xff, 0xf7, 0xe5, 0x37, 0x12, 0x26, 0xfe, 0x90, 0xff, 0xf6, 0xe5, 0x37, 0xf0, 
+0x90, 0xfa, 0xcb, 0xe4, 0xf0, 0xa3, 0x74, 0x06, 0x12, 0x26, 0xfe, 0xe5, 0x37, 0x30, 0xe0, 0x07, 
+0x90, 0xff, 0xfc, 0x74, 0x94, 0xf0, 0x22, 0x90, 0xff, 0xfc, 0x74, 0x90, 0xf0, 0x22, 0xf0, 0x7b, 
+0x00, 0x7a, 0x00, 0x79, 0x37, 0x90, 0xfa, 0xcb, 0xe4, 0x75, 0xf0, 0x01, 0x12, 0x14, 0x45, 0x85, 
+0xf0, 0x41, 0xf5, 0x40, 0x7d, 0x01, 0x02, 0x23, 0xee, 0x15, 0x6b, 0xa8, 0x6b, 0xa6, 0x07, 0x30, 
+0x08, 0x05, 0x12, 0x10, 0xec, 0x80, 0xf8, 0xd2, 0x08, 0xa8, 0x6b, 0xe6, 0xff, 0xb4, 0x03, 0x0f, 
+0x78, 0x82, 0x76, 0xff, 0x08, 0x76, 0xe0, 0x08, 0x76, 0xff, 0x08, 0x76, 0xa0, 0x80, 0x0d, 0x78, 
+0x82, 0x76, 0xff, 0x08, 0x76, 0xe2, 0x08, 0x76, 0xff, 0x08, 0x76, 0xb0, 0x78, 0x86, 0x76, 0xfa, 
+0x08, 0x76, 0x9a, 0xef, 0x24, 0xfd, 0x75, 0xf0, 0x0a, 0xa4, 0xae, 0xf0, 0x12, 0x20, 0xb7, 0x7b, 
+0x01, 0x7a, 0xff, 0x79, 0x48, 0x78, 0x6e, 0x12, 0x14, 0xf4, 0xa8, 0x6b, 0xe6, 0x24, 0xfd, 0x75, 
+0xf0, 0x08, 0xa4, 0xff, 0xae, 0xf0, 0x78, 0x70, 0x12, 0x20, 0xb7, 0x79, 0x08, 0x78, 0x71, 0x12, 
+0x14, 0xf4, 0x78, 0x73, 0xef, 0x12, 0x20, 0xb7, 0x05, 0x6b, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0x54, 
+0xab, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x90, 0xfa, 0xe2, 0x74, 0x02, 0xf0, 0x7b, 0x01, 0x7a, 0xfa, 
+0x79, 0xcb, 0xe4, 0xf5, 0x40, 0xf5, 0x41, 0x7d, 0x01, 0x12, 0x23, 0xee, 0x7e, 0x00, 0x90, 0xfa, 
+0xe0, 0xee, 0xf0, 0xa3, 0xef, 0xf0, 0x64, 0x01, 0x70, 0x10, 0x90, 0xfa, 0xcb, 0xe0, 0xb4, 0x52, 
+0x09, 0x90, 0xf9, 0x65, 0xe0, 0x54, 0xef, 0xf0, 0x80, 0x29, 0x90, 0xfa, 0xe0, 0xe0, 0x70, 0x04, 
+0xa3, 0xe0, 0x64, 0x01, 0x70, 0x10, 0x90, 0xfa, 0xcb, 0xe0, 0xb4, 0x10, 0x09, 0x90, 0xf9, 0x65, 
+0xe0, 0x44, 0x10, 0xf0, 0x80, 0x0d, 0x90, 0xfa, 0xe2, 0x74, 0x03, 0xf0, 0x90, 0xf9, 0x65, 0xe0, 
+0x54, 0xef, 0xf0, 0x90, 0xff, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x22, 0x90, 0xff, 0x93, 0x74, 0x2a, 
+0xf0, 0x90, 0xff, 0xff, 0xe0, 0x60, 0x06, 0x90, 0xff, 0xfc, 0x74, 0x10, 0xf0, 0x90, 0xff, 0x91, 
+0xe0, 0x44, 0x90, 0xf0, 0x12, 0x27, 0x8b, 0x12, 0x15, 0x35, 0x12, 0x2d, 0xa5, 0x7e, 0x07, 0x7f, 
+0xd0, 0x12, 0x11, 0x68, 0x7e, 0x0f, 0x7f, 0xa0, 0x12, 0x11, 0x82, 0xe4, 0x78, 0x7d, 0xf6, 0x78, 
+0x7d, 0xe6, 0xff, 0xc3, 0x94, 0x06, 0x50, 0x0b, 0x74, 0x74, 0x2f, 0xf8, 0xe4, 0xf6, 0x78, 0x7d, 
+0x06, 0x80, 0xec, 0x7f, 0x03, 0x12, 0x2c, 0x5b, 0x90, 0xf9, 0x65, 0xe0, 0x20, 0xe4, 0x05, 0x7f, 
+0x04, 0x12, 0x2c, 0x5b, 0x90, 0xff, 0x9b, 0xe4, 0xf0, 0x90, 0xff, 0x9a, 0xf0, 0x90, 0xff, 0xe8, 
+0xe0, 0x54, 0x1f, 0xf0, 0xd2, 0xa8, 0x22, 0x12, 0x0f, 0x89, 0x78, 0x90, 0xef, 0xf6, 0x12, 0x27, 
+0x19, 0x12, 0x20, 0x59, 0x30, 0xe0, 0x25, 0x12, 0x20, 0x2d, 0xe0, 0x54, 0x7f, 0xf0, 0x78, 0x71, 
+0x12, 0x14, 0xeb, 0x90, 0x00, 0x02, 0x12, 0x13, 0xce, 0x30, 0xe7, 0x09, 0x90, 0x00, 0x02, 0xe4, 
+0x12, 0x14, 0x0d, 0x80, 0xe9, 0x12, 0x20, 0x2d, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x20, 0x59, 0x30, 
+0xe1, 0x1e, 0x12, 0x20, 0x1b, 0xe0, 0x54, 0x7f, 0xf0, 0x12, 0x2f, 0x15, 0x78, 0x6e, 0x12, 0x14, 
+0xeb, 0x90, 0x00, 0x02, 0x74, 0x80, 0x12, 0x14, 0x0d, 0x12, 0x20, 0x1b, 0xe0, 0x44, 0x80, 0xf0, 
+0x12, 0x2f, 0x80, 0xe4, 0xff, 0x12, 0x2e, 0xa5, 0x02, 0x10, 0x0c, 0x03, 0x6e, 0x01, 0xff, 0x48, 
+0x03, 0x71, 0x01, 0xff, 0x08, 0x02, 0x6c, 0x00, 0x00, 0x44, 0xfa, 0x94, 0x00, 0x00, 0x00, 0x00, 
+0x44, 0xfa, 0x90, 0x00, 0x00, 0x00, 0x00, 0x42, 0xfa, 0xae, 0x00, 0x00, 0x42, 0xfa, 0x7a, 0x00, 
+0x00, 0x42, 0xfa, 0x78, 0x00, 0x00, 0x42, 0xf9, 0x69, 0xff, 0xff, 0x42, 0xfa, 0x76, 0x00, 0x00, 
+0x43, 0xf9, 0x16, 0x0a, 0x32, 0x02, 0x41, 0xf9, 0x63, 0x20, 0x41, 0xf9, 0x64, 0x20, 0x41, 0xf9, 
+0x61, 0x00, 0x41, 0xf9, 0x62, 0x00, 0x44, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xf9, 0x65, 
+0x00, 0x41, 0xf9, 0x15, 0x00, 0x01, 0x20, 0x00, 0x41, 0xf8, 0x04, 0x00, 0x00, 0x12, 0x19, 0x82, 
+0xe5, 0x31, 0x64, 0x09, 0x70, 0x04, 0xe5, 0x30, 0x64, 0x01, 0x60, 0x48, 0xc3, 0xe5, 0x31, 0x94, 
+0x08, 0xe5, 0x30, 0x94, 0x00, 0x40, 0x11, 0x7f, 0x08, 0xef, 0xe5, 0x31, 0x94, 0x08, 0xf5, 0x31, 
+0xe5, 0x30, 0x94, 0x00, 0xf5, 0x30, 0x80, 0x05, 0xaf, 0x31, 0x12, 0x19, 0x92, 0xe4, 0xfe, 0xee, 
+0xc3, 0x9f, 0x50, 0x19, 0x12, 0x18, 0x2a, 0x12, 0x13, 0xb5, 0xfd, 0x74, 0xf8, 0x2e, 0xf5, 0x82, 
+0xe4, 0x34, 0xfe, 0xf5, 0x83, 0xed, 0xf0, 0x0e, 0x12, 0x18, 0x19, 0x80, 0xe2, 0xef, 0x54, 0x7f, 
+0x90, 0xff, 0x81, 0xf0, 0x22, 0x8b, 0x5f, 0x8a, 0x60, 0x89, 0x61, 0x12, 0x2a, 0x6e, 0x70, 0x05, 
+0xa3, 0x74, 0x08, 0xf0, 0x22, 0xab, 0x5f, 0xaa, 0x60, 0xa9, 0x61, 0x12, 0x2a, 0x62, 0x90, 0xfa, 
+0xc5, 0x12, 0x15, 0x06, 0xe5, 0x61, 0x24, 0x03, 0xf9, 0xe4, 0x35, 0x60, 0xfa, 0x90, 0xfa, 0xbf, 
+0x12, 0x15, 0x06, 0xe4, 0x90, 0xfa, 0xbe, 0xf0, 0x78, 0x91, 0xf6, 0x90, 0xfa, 0xbd, 0xe0, 0xff, 
+0x78, 0x91, 0xe6, 0xc3, 0x9f, 0x50, 0x12, 0x12, 0x2a, 0x40, 0xff, 0x12, 0x2a, 0x49, 0x12, 0x2a, 
+0x5c, 0x78, 0x91, 0x06, 0x12, 0x2a, 0x58, 0x80, 0xe2, 0x22, 0xad, 0x07, 0xac, 0x06, 0x90, 0x2f, 
+0x06, 0xe4, 0x93, 0xff, 0x78, 0x7a, 0xf6, 0x54, 0x0f, 0x12, 0x19, 0x07, 0xe0, 0x08, 0x76, 0x00, 
+0x08, 0xf6, 0x18, 0x12, 0x18, 0x42, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0x78, 0x7b, 
+0xee, 0xf6, 0x08, 0xef, 0xf6, 0xee, 0x44, 0xf8, 0x18, 0xf6, 0xef, 0x08, 0xf6, 0x90, 0xff, 0x7a, 
+0xe0, 0x20, 0xe7, 0x03, 0x7f, 0x00, 0x22, 0x78, 0x7b, 0xe6, 0xfe, 0x08, 0xe6, 0xf5, 0x82, 0x8e, 
+0x83, 0xec, 0xf0, 0xa3, 0xed, 0xf0, 0x90, 0xff, 0x7a, 0x74, 0x02, 0xf0, 0x7f, 0x01, 0x22, 0xab, 
+0x5c, 0xaa, 0x5d, 0xa9, 0x5e, 0x90, 0x00, 0x03, 0x12, 0x13, 0xce, 0x54, 0xf0, 0x24, 0xa0, 0x22, 
+0x90, 0xfa, 0xc5, 0x12, 0x14, 0xfd, 0x02, 0x13, 0xb5, 0x90, 0xfa, 0xbf, 0x12, 0x14, 0xfd, 0xef, 
+0x12, 0x13, 0xfb, 0x90, 0xfa, 0xc6, 0xe4, 0x22, 0x90, 0xfa, 0xc0, 0xe4, 0x75, 0xf0, 0x01, 0x02, 
+0x14, 0x2f, 0x90, 0x00, 0x08, 0x12, 0x14, 0x5b, 0xaa, 0xf0, 0xf9, 0x7b, 0x01, 0x22, 0x90, 0x00, 
+0x05, 0x12, 0x13, 0xce, 0x90, 0xfa, 0xbd, 0xf0, 0x22, 0xab, 0x5c, 0xaa, 0x5d, 0xa9, 0x5e, 0x22, 
+0x90, 0xfa, 0xd9, 0xe0, 0xff, 0x7e, 0x00, 0xc3, 0x90, 0xfa, 0xd3, 0xe0, 0x9f, 0xf0, 0x90, 0xfa, 
+0xd2, 0xe0, 0x9e, 0xf0, 0x90, 0xfa, 0xd4, 0xee, 0x8f, 0xf0, 0x12, 0x14, 0x2f, 0xef, 0x25, 0x57, 
+0xf5, 0x57, 0xee, 0x35, 0x56, 0xf5, 0x56, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0x54, 0xfe, 0xf0, 0xe0, 
+0x54, 0xfd, 0xf0, 0x90, 0xfa, 0xe2, 0xe0, 0x64, 0x03, 0x22, 0x90, 0xff, 0xf2, 0xe0, 0xab, 0x3c, 
+0xaa, 0x3d, 0xa9, 0x3e, 0x02, 0x13, 0xfb, 0x90, 0xff, 0xf3, 0x74, 0xa0, 0xf0, 0x22, 0x8f, 0x6a, 
+0xed, 0x70, 0x0f, 0xe5, 0x6a, 0xb4, 0x03, 0x05, 0x7f, 0x01, 0x02, 0x2e, 0xeb, 0x7f, 0x02, 0x02, 
+0x2e, 0xeb, 0xaf, 0x6a, 0x12, 0x27, 0x19, 0x74, 0x74, 0x25, 0x6a, 0xf8, 0xe6, 0x30, 0xe2, 0x0b, 
+0xd2, 0x09, 0x12, 0x18, 0x9b, 0xe0, 0x54, 0x7f, 0xf0, 0x80, 0x02, 0xc2, 0x09, 0xe5, 0x6a, 0xb4, 
+0x03, 0x07, 0x7f, 0x81, 0x12, 0x2e, 0xeb, 0x80, 0x05, 0x7f, 0x82, 0x12, 0x2e, 0xeb, 0x30, 0x09, 
+0x07, 0x12, 0x18, 0x9b, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x2f, 0x80, 0x22, 0x12, 0x0f, 0x89, 0x90, 
+0xff, 0xfd, 0xe0, 0x44, 0x60, 0xf0, 0xd2, 0x01, 0x90, 0xff, 0xfc, 0xe0, 0x44, 0x02, 0xf0, 0x90, 
+0xff, 0x00, 0xe0, 0x30, 0xe7, 0x13, 0x90, 0xff, 0x83, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x2c, 0x80, 
+0x90, 0xff, 0xfc, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x0d, 0x12, 0x19, 0x3e, 0x53, 0x2c, 0x7f, 0x90, 
+0xff, 0xfc, 0xe0, 0x54, 0xfe, 0xf0, 0x90, 0xff, 0x81, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x02, 0x9f, 
+0x12, 0x19, 0x46, 0x02, 0x10, 0x0c, 0x12, 0x0f, 0x89, 0x78, 0x8a, 0x12, 0x20, 0x9e, 0x30, 0xe1, 
+0x07, 0x7f, 0x13, 0x12, 0x2e, 0xa5, 0x80, 0x34, 0x90, 0xf9, 0x65, 0xe0, 0x54, 0x03, 0x60, 0x16, 
+0x78, 0x8a, 0xe6, 0xb4, 0x03, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xdf, 0xf0, 0x80, 0x07, 0x90, 
+0xff, 0xb4, 0xe0, 0x54, 0xdf, 0xf0, 0xc2, 0xb3, 0x90, 0xf9, 0x15, 0xe0, 0x04, 0xf0, 0x78, 0x8a, 
+0xe6, 0xff, 0x12, 0x20, 0x59, 0xfd, 0x12, 0x2d, 0x21, 0x12, 0x2e, 0xa5, 0x02, 0x10, 0x0c, 0x12, 
+0x0f, 0x89, 0x78, 0x8f, 0xef, 0xf6, 0xd2, 0x00, 0x12, 0x27, 0x19, 0x90, 0xf9, 0x66, 0x12, 0x14, 
+0xfd, 0xe9, 0x24, 0x03, 0xf9, 0xe4, 0x3a, 0xfa, 0xc0, 0x02, 0x78, 0x86, 0xe6, 0xfe, 0x08, 0xe6, 
+0xaa, 0x06, 0xf8, 0xac, 0x02, 0x7d, 0x01, 0xd0, 0x02, 0x12, 0x20, 0x4b, 0x12, 0x2f, 0x80, 0x78, 
+0x8f, 0xe6, 0xff, 0x12, 0x19, 0xbb, 0x12, 0x2e, 0xa5, 0x02, 0x10, 0x0c, 0x12, 0x0f, 0x89, 0x78, 
+0x8b, 0xef, 0xf6, 0x12, 0x2e, 0x4c, 0x12, 0x2e, 0xa5, 0x90, 0xf9, 0x65, 0xe0, 0x54, 0x03, 0x60, 
+0x16, 0x78, 0x8b, 0xe6, 0xb4, 0x03, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x07, 
+0x90, 0xff, 0xb4, 0xe0, 0x44, 0x20, 0xf0, 0x90, 0xf9, 0x15, 0xe0, 0x14, 0xf0, 0xe0, 0x70, 0x02, 
+0xd2, 0xb3, 0x02, 0x10, 0x0c, 0x8f, 0x69, 0x12, 0x27, 0x19, 0x12, 0x20, 0x2d, 0xe0, 0x54, 0x3f, 
+0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0x54, 0x3f, 0xf0, 0x08, 0xe6, 0xfe, 0x08, 
+0xe6, 0x8e, 0x83, 0x24, 0x0b, 0x12, 0x20, 0x25, 0xe0, 0x54, 0xf8, 0xf0, 0x12, 0x2f, 0x80, 0x74, 
+0x74, 0x25, 0x69, 0xf8, 0x74, 0xfb, 0x56, 0xf6, 0x7f, 0x00, 0x22, 0x8f, 0x37, 0xc2, 0x08, 0x12, 
+0x27, 0x19, 0x12, 0x20, 0x38, 0x78, 0x84, 0x12, 0x20, 0x1d, 0xe0, 0x44, 0x01, 0xf0, 0x12, 0x20, 
+0x70, 0x12, 0x20, 0x21, 0xe0, 0x20, 0xe0, 0xf6, 0xef, 0x24, 0x0b, 0xf5, 0x82, 0xe4, 0x3e, 0xf5, 
+0x83, 0xe0, 0x54, 0xf8, 0xf0, 0x12, 0x2f, 0x80, 0xaf, 0x37, 0x12, 0x19, 0xbb, 0x22, 0x12, 0x0f, 
+0x89, 0x12, 0x27, 0x19, 0x12, 0x20, 0x70, 0x24, 0x06, 0x12, 0x20, 0x23, 0xe0, 0xfd, 0x12, 0x20, 
+0x53, 0x90, 0x00, 0x03, 0x12, 0x20, 0x78, 0x24, 0x05, 0x12, 0x20, 0x25, 0xe0, 0x90, 0x00, 0x04, 
+0x12, 0x14, 0x0d, 0x12, 0x2f, 0x80, 0x7d, 0x02, 0xe4, 0xff, 0x12, 0x2c, 0xc0, 0x02, 0x10, 0x0c, 
+0xae, 0x05, 0x12, 0x18, 0xed, 0xef, 0x12, 0x14, 0x0d, 0x0e, 0x0e, 0x0e, 0xee, 0xd3, 0x95, 0x35, 
+0xe4, 0x95, 0x34, 0x40, 0x02, 0xae, 0x35, 0xee, 0xd3, 0x94, 0x08, 0x74, 0x80, 0x94, 0x81, 0x40, 
+0x0a, 0x7e, 0x03, 0x90, 0x00, 0x02, 0x74, 0x02, 0x12, 0x14, 0x0d, 0xaf, 0x06, 0x12, 0x2f, 0x6a, 
+0x22, 0x12, 0x0f, 0x89, 0x78, 0x8c, 0x12, 0x20, 0x9e, 0x30, 0xe2, 0x07, 0x7f, 0x13, 0x12, 0x2e, 
+0xa5, 0x80, 0x1b, 0x78, 0x8c, 0xe6, 0x24, 0x74, 0xf8, 0xe6, 0x20, 0xe1, 0x07, 0x7f, 0x12, 0x12, 
+0x2e, 0xa5, 0x80, 0x0a, 0x78, 0x8c, 0xe6, 0xff, 0x12, 0x21, 0x6e, 0x12, 0x2e, 0xa5, 0x02, 0x10, 
+0x0c, 0xae, 0x07, 0xed, 0x54, 0x03, 0x64, 0x01, 0x60, 0x03, 0x7f, 0x10, 0x22, 0xed, 0x54, 0x7c, 
+0xc3, 0x94, 0x04, 0x50, 0x03, 0x7f, 0x0b, 0x22, 0x74, 0x74, 0x2e, 0xf8, 0x74, 0x02, 0x46, 0xf6, 
+0x74, 0x95, 0x2e, 0xf5, 0x82, 0xe4, 0x34, 0xfa, 0xf5, 0x83, 0xed, 0xf0, 0x7f, 0x00, 0x22, 0xbf, 
+0x03, 0x06, 0x7c, 0xff, 0x7d, 0xe0, 0x80, 0x04, 0x7c, 0xff, 0x7d, 0xe2, 0x8d, 0x82, 0x8c, 0x83, 
+0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0x44, 0x80, 0xf0, 0x74, 
+0x74, 0x2f, 0xf8, 0x74, 0x04, 0x46, 0xf6, 0x7f, 0x00, 0x22, 0x12, 0x0f, 0x89, 0xe5, 0x31, 0x64, 
+0x09, 0x70, 0x04, 0xe5, 0x30, 0x64, 0x01, 0x60, 0x16, 0x90, 0xff, 0x83, 0xe0, 0x54, 0x0f, 0xff, 
+0xc3, 0xe5, 0x31, 0x9f, 0xe5, 0x30, 0x94, 0x00, 0x40, 0x05, 0x12, 0x25, 0x9c, 0x80, 0x03, 0x12, 
+0x2f, 0x76, 0x02, 0x10, 0x0c, 0x90, 0xff, 0xfc, 0xe0, 0x20, 0xe7, 0x1f, 0xc2, 0xaf, 0x7d, 0xff, 
+0xac, 0x05, 0x1d, 0xec, 0x60, 0x15, 0x7e, 0x04, 0x7f, 0x00, 0xef, 0x1f, 0xaa, 0x06, 0x70, 0x01, 
+0x1e, 0x4a, 0x60, 0xec, 0x90, 0xff, 0x92, 0xe4, 0xf0, 0x80, 0xef, 0x22, 0x12, 0x0f, 0x89, 0x78, 
+0x6c, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x30, 0xe0, 0x12, 0x30, 0xe1, 0x0f, 0x90, 0xff, 0xfc, 0xe0, 
+0x44, 0x20, 0xf0, 0x7f, 0x04, 0x12, 0x11, 0x9f, 0x12, 0x19, 0x55, 0x02, 0x10, 0x0c, 0x8e, 0x65, 
+0x8f, 0x66, 0xe5, 0x66, 0x15, 0x66, 0xae, 0x65, 0x70, 0x02, 0x15, 0x65, 0xd3, 0x94, 0x00, 0xee, 
+0x94, 0x00, 0x40, 0x09, 0x7e, 0x07, 0x7f, 0xd0, 0x12, 0x0f, 0x62, 0x80, 0xe5, 0x22, 0x11, 0x1a, 
+0x2b, 0x1c, 0x23, 0x56, 0x2f, 0x5c, 0x2d, 0xcc, 0x2d, 0x7a, 0x2e, 0x6b, 0x2c, 0x8e, 0x2b, 0x66, 
+0x2b, 0xec, 0x2c, 0xf1, 0x2e, 0x2d, 0x1b, 0xe6, 0x2b, 0xaf, 0x28, 0x67, 0x0e, 0x12, 0x0f, 0x89, 
+0x78, 0x8d, 0x12, 0x20, 0x9e, 0x20, 0xe2, 0x07, 0x7f, 0x11, 0x12, 0x2e, 0xa5, 0x80, 0x0a, 0x78, 
+0x8d, 0xe6, 0xff, 0x12, 0x2c, 0x25, 0x12, 0x2e, 0xa5, 0x02, 0x10, 0x0c, 0x8f, 0x67, 0x12, 0x2c, 
+0x25, 0xaf, 0x67, 0x12, 0x27, 0x19, 0x12, 0x20, 0x38, 0x12, 0x2f, 0x80, 0x74, 0x74, 0x25, 0x67, 
+0xf8, 0x74, 0xfd, 0x56, 0xf6, 0xaf, 0x67, 0x12, 0x19, 0xbb, 0x22, 0x12, 0x0f, 0x89, 0xe5, 0x31, 
+0x64, 0x09, 0x70, 0x04, 0xe5, 0x30, 0x64, 0x01, 0x60, 0x05, 0x12, 0x29, 0x2d, 0x80, 0x06, 0x12, 
+0x19, 0x7a, 0x12, 0x19, 0x82, 0x02, 0x10, 0x0c, 0x12, 0x27, 0xfb, 0x12, 0x12, 0x3b, 0x90, 0xf8, 
+0x04, 0xe0, 0xff, 0x60, 0x05, 0x7d, 0x01, 0x12, 0x11, 0xd8, 0x12, 0x26, 0xa3, 0x12, 0x12, 0x77, 
+0x12, 0x10, 0xfa, 0x80, 0xe3, 0x12, 0x18, 0xed, 0xef, 0x12, 0x14, 0x0d, 0xe4, 0xf5, 0x2a, 0xf5, 
+0x2b, 0xef, 0x60, 0x03, 0x02, 0x2f, 0x76, 0xe4, 0xff, 0x12, 0x2f, 0x6a, 0x22, 0x90, 0xff, 0xf0, 
+0xe0, 0xff, 0x54, 0xa0, 0x60, 0xf7, 0xef, 0x30, 0xe5, 0x08, 0x90, 0xff, 0xf0, 0x44, 0x20, 0xf0, 
+0xc3, 0x22, 0xd3, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0xff, 0x54, 0x28, 0x60, 0xf7, 0xef, 0x30, 0xe5, 
+0x08, 0x90, 0xff, 0xf0, 0x44, 0x20, 0xf0, 0xc3, 0x22, 0xd3, 0x22, 0xef, 0x30, 0xe7, 0x08, 0x12, 
+0x18, 0xad, 0xe0, 0x54, 0xdf, 0xf0, 0x22, 0xef, 0x12, 0x18, 0xf7, 0xe0, 0x54, 0xdf, 0xf0, 0x22, 
+0x81, 0x01, 0x82, 0x02, 0x83, 0x03, 0x87, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
+0x00, 0x40, 0x00, 0x08, 0x00, 0x78, 0x84, 0x12, 0x20, 0x2f, 0xa3, 0xa3, 0xe0, 0xff, 0x30, 0xe7, 
+0x06, 0x54, 0x7f, 0xf0, 0x44, 0x80, 0xf0, 0x22, 0x85, 0x34, 0x30, 0x85, 0x35, 0x31, 0x90, 0xff, 
+0x82, 0xe0, 0x54, 0xf7, 0xf0, 0xa3, 0xe0, 0x54, 0x7f, 0xf0, 0x22, 0xe4, 0xfe, 0xee, 0x90, 0x2f, 
+0x00, 0x93, 0xb5, 0x07, 0x02, 0xd3, 0x22, 0x0e, 0xbe, 0x07, 0xf2, 0xc3, 0x22, 0x00, 0x08, 0x18, 
+0x38, 0x28, 0x01, 0x81, 0x10, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x0f, 0x89, 0x7f, 
+0x02, 0x12, 0x10, 0x18, 0x12, 0x19, 0x55, 0x02, 0x10, 0x0c, 0x75, 0x30, 0x00, 0x8f, 0x31, 0x12, 
+0x18, 0x49, 0x12, 0x29, 0x2d, 0x22, 0x12, 0x19, 0x82, 0x12, 0x19, 0x3e, 0x12, 0x19, 0x7a, 0x22, 
+0xc2, 0x08, 0x22, 
+};
+
+#undef IMAGE_VERSION_NAME
+
+#undef IMAGE_ARRAY_NAME
+
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_ionsp.h linux-2.4.19/drivers/usb/serial/io_ionsp.h
--- linux-2.4.19.old/drivers/usb/serial/io_ionsp.h	Tue Mar 20 02:21:54 2001
+++ linux-2.4.19/drivers/usb/serial/io_ionsp.h	Mon Nov 25 12:27:08 2002
@@ -88,12 +88,12 @@
 // Interrupt pipe
 //
 
-typedef struct _INT_STATUS_PKT {
+struct int_status_pkt {
 	__u16      RxBytesAvail;		    // Additional bytes available to
 						    // be read from Bulk IN pipe
 	__u16      TxCredits[ MAX_RS232_PORTS ];   // Additional space available in
 						    // given port's TxBuffer
-} INT_STATUS_PKT, *PINT_STATUS_PKT;
+};
 
 
 #define GET_INT_STATUS_SIZE(NumPorts) (sizeof(__u16) + (sizeof(__u16) * (NumPorts)))
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_tables.h linux-2.4.19/drivers/usb/serial/io_tables.h
--- linux-2.4.19.old/drivers/usb/serial/io_tables.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/io_tables.h	Mon Nov 25 12:27:08 2002
@@ -14,12 +14,12 @@
 #ifndef IO_TABLES_H
 #define IO_TABLES_H
 
-static __devinitdata struct usb_device_id edgeport_1port_id_table [] = {
+static struct usb_device_id edgeport_1port_id_table [] = {
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_PARALLEL_PORT) },
 	{ }
 };
 
-static __devinitdata struct usb_device_id edgeport_2port_id_table [] = {
+static struct usb_device_id edgeport_2port_id_table [] = {
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_2) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_2I) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_421) },
@@ -33,7 +33,7 @@
 	{ }
 };
 
-static __devinitdata struct usb_device_id edgeport_4port_id_table [] = {
+static struct usb_device_id edgeport_4port_id_table [] = {
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_4) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_RAPIDPORT_4) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_4T) },
@@ -50,7 +50,7 @@
 	{ }
 };
 
-static __devinitdata struct usb_device_id edgeport_8port_id_table [] = {
+static struct usb_device_id edgeport_8port_id_table [] = {
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_16_DUAL_CPU) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8I) },
@@ -98,11 +98,9 @@
 MODULE_DEVICE_TABLE (usb, id_table_combined);
 
 static struct usb_serial_device_type edgeport_1port_device = {
+	owner:			THIS_MODULE,
 	name:			"Edgeport 1 port adapter",
 	id_table:		edgeport_1port_id_table,
-	needs_interrupt_in:	MUST_HAVE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
 	num_interrupt_in:	1,
 	num_bulk_in:		1,
 	num_bulk_out:		1,
@@ -122,11 +120,9 @@
 };
 
 static struct usb_serial_device_type edgeport_2port_device = {
+	owner:			THIS_MODULE,
 	name:			"Edgeport 2 port adapter",
 	id_table:		edgeport_2port_id_table,
-	needs_interrupt_in:	MUST_HAVE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
 	num_interrupt_in:	1,
 	num_bulk_in:		1,
 	num_bulk_out:		1,
@@ -146,11 +142,9 @@
 };
 
 static struct usb_serial_device_type edgeport_4port_device = {
+	owner:			THIS_MODULE,
 	name:			"Edgeport 4 port adapter",
 	id_table:		edgeport_4port_id_table,
-	needs_interrupt_in:	MUST_HAVE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
 	num_interrupt_in:	1,
 	num_bulk_in:		1,
 	num_bulk_out:		1,
@@ -170,11 +164,9 @@
 };
 
 static struct usb_serial_device_type edgeport_8port_device = {
+	owner:			THIS_MODULE,
 	name:			"Edgeport 8 port adapter",
 	id_table:		edgeport_8port_id_table,
-	needs_interrupt_in:	MUST_HAVE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
 	num_interrupt_in:	1,
 	num_bulk_in:		1,
 	num_bulk_out:		1,
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_ti.c linux-2.4.19/drivers/usb/serial/io_ti.c
--- linux-2.4.19.old/drivers/usb/serial/io_ti.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/serial/io_ti.c	Mon Nov 25 12:27:08 2002
@@ -0,0 +1,2684 @@
+/*
+ * Edgeport USB Serial Converter driver
+ *
+ * Copyright(c) 2000-2002 Inside Out Networks, All rights reserved.
+ * Copyright(c) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ * Supports the following devices:
+ *	EP/1 EP/2 EP/4
+ *
+ * Version history:
+ *
+ *	July 11, 2002 	Removed 4 port device structure since all TI UMP 
+ *			chips have only 2 ports 
+ *			David Iacovelli (davidi@ionetworks.com)
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/serial.h>
+#include <linux/ioctl.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
+#include "usb-serial.h"
+
+#include "io_16654.h"
+#include "io_usbvend.h"
+#include "io_ti.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION "v0.2"
+#define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com> and David Iacovelli"
+#define DRIVER_DESC "Edgeport USB Serial Driver"
+
+
+/* firmware image code */
+#define IMAGE_VERSION_NAME	PagableOperationalCodeImageVersion
+#define IMAGE_ARRAY_NAME	PagableOperationalCodeImage
+#define IMAGE_SIZE		PagableOperationalCodeSize
+#include "io_fw_down3.h"	/* Define array OperationalCodeImage[] */
+
+#define EPROM_PAGE_SIZE		64
+
+
+struct edgeport_uart_buf_desc {
+	__u32 count;		// Number of bytes currently in buffer
+};
+
+/* different hardware types */
+#define HARDWARE_TYPE_930	0
+#define HARDWARE_TYPE_TIUMP	1
+
+// IOCTL_PRIVATE_TI_GET_MODE Definitions
+#define	TI_MODE_CONFIGURING	0   // Device has not entered start device 
+#define	TI_MODE_BOOT		1   // Staying in boot mode
+#define TI_MODE_DOWNLOAD	2   // Made it to download mode
+#define TI_MODE_TRANSITIONING	3   // Currently in boot mode but transitioning to download mode
+
+
+/* Product information read from the Edgeport */
+struct product_info
+{
+	int	TiMode;			// Current TI Mode
+	__u8	hardware_type;		// Type of hardware
+} __attribute__((packed));
+
+
+struct edgeport_port {
+	__u16 uart_base;
+	__u16 dma_address;
+	__u8 shadow_msr;
+	__u8 shadow_mcr;
+	__u8 shadow_lsr;
+	__u8 lsr_mask;
+	__u32 ump_read_timeout;		/* Number of miliseconds the UMP will
+					   wait without data before completing
+					   a read short */
+	int baud_rate;
+	int close_pending;
+	int lsr_event;
+	struct edgeport_uart_buf_desc tx;
+	struct async_icount	icount;
+	wait_queue_head_t	delta_msr_wait;	/* for handling sleeping while
+						   waiting for msr change to
+						   happen */
+	struct edgeport_serial	*edge_serial;
+	struct usb_serial_port	*port;
+};
+
+struct edgeport_serial {
+	struct product_info product_info;
+	u8 TI_I2C_Type;			// Type of I2C in UMP
+	u8 TiReadI2C;			// Set to TRUE if we have read the I2c in Boot Mode
+	int num_ports_open;
+	struct usb_serial *serial;
+};
+
+
+/* Devices that this driver supports */
+static struct usb_device_id edgeport_1port_id_table [] = {
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_1) },
+	{ }
+};
+
+static struct usb_device_id edgeport_2port_id_table [] = {
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421_BOOT) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421_DOWN) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21_BOOT) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21_DOWN) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_42) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22) },
+	{ }
+};
+
+/* Devices that this driver supports */
+static __devinitdata struct usb_device_id id_table_combined [] = {
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_1) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421_BOOT) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421_DOWN) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21_BOOT) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21_DOWN) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_42) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22) },
+	{ }
+};
+
+MODULE_DEVICE_TABLE (usb, id_table_combined);
+
+
+static struct EDGE_FIRMWARE_VERSION_INFO OperationalCodeImageVersion;
+
+static int TIStayInBootMode = 0;
+static int ignore_cpu_rev = 0;
+
+
+
+static void edge_set_termios (struct usb_serial_port *port, struct termios *old_termios);
+
+static int TIReadVendorRequestSync (struct usb_device *dev,
+				__u8		request,
+				__u16		value,
+				__u16		index,
+				u8 		*data,
+				int		size)
+{
+	int status;
+
+	status = usb_control_msg (dev,
+				usb_rcvctrlpipe(dev, 0),
+				request,
+				(USB_TYPE_VENDOR | 
+				 USB_RECIP_DEVICE | 
+				 USB_DIR_IN),
+				value,
+				index,
+				data,
+				size,
+				HZ);
+	if (status < 0)
+		return status;
+	if (status != size) {
+		dbg ("%s - wanted to write %d, but only wrote %d",
+		     __FUNCTION__, size, status);
+		return -ECOMM;
+	}
+	return 0;
+}
+
+static int TISendVendorRequestSync (struct usb_device *dev,
+				__u8		request,
+				__u16		value,
+				__u16		index,
+				u8 		*data,
+				int		size)
+{
+	int status;
+
+	status = usb_control_msg (dev,
+				usb_sndctrlpipe(dev, 0),
+				request,
+				(USB_TYPE_VENDOR | 
+				 USB_RECIP_DEVICE | 
+				 USB_DIR_OUT),
+				value,
+				index,
+				data,
+				size,
+				HZ);
+
+	if (status < 0)
+		return status;
+	if (status != size) {
+		dbg ("%s - wanted to write %d, but only wrote %d",
+		     __FUNCTION__, size, status);
+		return -ECOMM;
+	}
+	return 0;
+}
+
+static int TIWriteCommandSync (struct usb_device *dev, __u8 command,
+				__u8 moduleid, __u16 value, u8 *data,
+				int size)
+{
+	return TISendVendorRequestSync (dev,
+					  command,	  		// Request
+					  value,			// wValue 
+					  moduleid,			// wIndex
+					  data,				// TransferBuffer
+					  size);			// TransferBufferLength
+
+}
+
+
+/* clear tx/rx buffers and fifo in TI UMP */
+static int TIPurgeDataSync (struct usb_serial_port *port, __u16 mask)
+{
+	int port_number = port->number - port->serial->minor;
+
+	dbg ("%s - port %d, mask %x", __FUNCTION__, port_number, mask);
+
+	return TIWriteCommandSync (port->serial->dev,
+					UMPC_PURGE_PORT,
+					(__u8)(UMPM_UART1_PORT + port_number),
+					mask,
+					NULL,
+					0);
+}
+
+/**
+ * TIReadDownloadMemory - Read edgeport memory from TI chip
+ * @dev: usb device pointer
+ * @address: Device CPU address at which to read
+ * @length: Length of above data
+ * @address_type: Can read both XDATA and I2C
+ * @buffer: pointer to input data buffer
+ */
+int TIReadDownloadMemory (struct usb_device *dev, int start_address, int length,
+			  __u8 address_type, __u8 *buffer)
+{
+	int status = 0;
+	__u8 read_length;
+	__u16 be_start_address;
+	
+	dbg ("%s - @ %x for %d", __FUNCTION__, start_address, length);
+
+	/* Read in blocks of 64 bytes
+	 * (TI firmware can't handle more than 64 byte reads)
+	 */
+	while (length) {
+		if (length > 64)
+			read_length= 64;
+		else
+			read_length = (__u8)length;
+
+		if (read_length > 1) {
+			dbg ("%s - @ %x for %d", __FUNCTION__, 
+			     start_address, read_length);
+		}
+		be_start_address = cpu_to_be16 (start_address);
+		status = TIReadVendorRequestSync (dev,
+						  UMPC_MEMORY_READ,	// Request
+						  (__u16)address_type,	// wValue (Address type)
+						  be_start_address,	// wIndex (Address to read)
+						  buffer,		// TransferBuffer
+						  read_length);	// TransferBufferLength
+
+		if (status) {
+			dbg ("%s - ERROR %x", __FUNCTION__, status);
+			return status;
+		}
+
+		if (read_length > 1) {
+			usb_serial_debug_data (__FILE__, __FUNCTION__,
+					       read_length, buffer);
+		}
+
+		/* Update pointers/length */
+		start_address += read_length;
+		buffer += read_length;
+		length -= read_length;
+	}
+	
+	return status;
+}
+
+int TIReadRam (struct usb_device *dev, int start_address, int length, __u8 *buffer)
+{
+	return TIReadDownloadMemory (dev,
+				     start_address,
+				     length,
+				     DTK_ADDR_SPACE_XDATA,
+				     buffer);
+}
+
+/* Read edgeport memory to a given block */
+static int TIReadBootMemory (struct edgeport_serial *serial, int start_address, int length, __u8 * buffer)
+{
+	int status = 0;
+	int i;
+
+	for (i=0; i< length; i++) {
+		status = TIReadVendorRequestSync (serial->serial->dev,
+					UMPC_MEMORY_READ,		// Request
+					serial->TI_I2C_Type,		// wValue (Address type)
+					(__u16)(start_address+i),	// wIndex
+					&buffer[i],			// TransferBuffer
+					0x01);				// TransferBufferLength
+		if (status) {
+			dbg ("%s - ERROR %x", __FUNCTION__, status);
+			return status;
+		}
+	}
+
+	dbg ("%s - start_address = %x, length = %d", __FUNCTION__, start_address, length);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, length, buffer);
+
+	serial->TiReadI2C = 1;
+
+	return status;
+}
+
+/* Write given block to TI EPROM memory */
+static int TIWriteBootMemory (struct edgeport_serial *serial, int start_address, int length, __u8 *buffer)
+{
+	int status = 0;
+	int i;
+	__u8 temp;
+
+	/* Must do a read before write */
+	if (!serial->TiReadI2C) {
+		status = TIReadBootMemory(serial, 0, 1, &temp);
+		if (status)
+			return status;
+	}
+
+	for (i=0; i < length; ++i) {
+		status = TISendVendorRequestSync (serial->serial->dev,
+						UMPC_MEMORY_WRITE,		// Request
+						buffer[i],			// wValue
+						(__u16)(i+start_address),	// wIndex
+						NULL,				// TransferBuffer
+						0);				// TransferBufferLength
+		if (status)
+			return status;
+	}
+
+  	dbg ("%s - start_sddr = %x, length = %d", __FUNCTION__, start_address, length);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, length, buffer);
+
+	return status;
+}
+
+
+/* Write edgeport I2C memory to TI chip	*/
+static int TIWriteDownloadI2C (struct edgeport_serial *serial, int start_address, int length, __u8 address_type, __u8 *buffer)
+{
+	int status = 0;
+	int write_length;
+	__u16 be_start_address;
+
+	/* We can only send a maximum of 1 aligned byte page at a time */
+	
+	/* calulate the number of bytes left in the first page */
+	write_length = EPROM_PAGE_SIZE - (start_address & (EPROM_PAGE_SIZE - 1));
+
+	if (write_length > length)
+		write_length = length;
+
+	dbg ("%s - BytesInFirstPage Addr = %x, length = %d", __FUNCTION__, start_address, write_length);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, write_length, buffer);
+
+	/* Write first page */
+	be_start_address = cpu_to_be16 (start_address);
+	status = TISendVendorRequestSync (serial->serial->dev,
+					UMPC_MEMORY_WRITE,	// Request
+					(__u16)address_type,	// wValue
+					be_start_address,	// wIndex
+					buffer,			// TransferBuffer
+					write_length);
+	if (status) {
+		dbg ("%s - ERROR %d", __FUNCTION__, status);
+		return status;
+	}
+
+	length		-= write_length;
+	start_address	+= write_length;
+	buffer		+= write_length;
+
+	/* We should be aligned now -- can write max page size bytes at a time */
+	while (length) {
+		if (length > EPROM_PAGE_SIZE)
+			write_length = EPROM_PAGE_SIZE;
+		else
+			write_length = length;
+
+		dbg ("%s - Page Write Addr = %x, length = %d", __FUNCTION__, start_address, write_length);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, write_length, buffer);
+
+		/* Write next page */
+		be_start_address = cpu_to_be16 (start_address);
+		status = TISendVendorRequestSync (serial->serial->dev,
+						UMPC_MEMORY_WRITE,	// Request
+						(__u16)address_type,	// wValue
+						be_start_address,	// wIndex
+						buffer,	  		// TransferBuffer
+						write_length);		// TransferBufferLength
+		if (status) {
+			dbg ("%s - ERROR %d", __FUNCTION__, status);
+			return status;
+		}
+		
+		length		-= write_length;
+		start_address	+= write_length;
+		buffer		+= write_length;
+	}
+	return status;
+}
+
+/* Examine the UMP DMA registers and LSR
+ * 
+ * Check the MSBit of the X and Y DMA byte count registers.
+ * A zero in this bit indicates that the TX DMA buffers are empty
+ * then check the TX Empty bit in the UART.
+ */
+static int TIIsTxActive (struct edgeport_port *port)
+{
+	int status;
+	struct out_endpoint_desc_block *oedb;
+	__u8 lsr;
+	int bytes_left = 0;
+
+	oedb = kmalloc (sizeof (* oedb), GFP_KERNEL);
+	if (!oedb) {
+		err ("%s - out of memory", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	/* Read the DMA Count Registers */
+	status = TIReadRam (port->port->serial->dev,
+			    port->dma_address,
+			    sizeof( *oedb),
+			    (void *)oedb);
+
+	if (status)
+		goto exit_is_tx_active;
+
+	dbg ("%s - XByteCount    0x%X", __FUNCTION__, oedb->XByteCount);
+
+	/* and the LSR */
+	status = TIReadRam (port->port->serial->dev, 
+			    port->uart_base + UMPMEM_OFFS_UART_LSR,
+			    1,
+			    &lsr);
+
+	if (status)
+		goto exit_is_tx_active;
+	dbg ("%s - LSR = 0x%X", __FUNCTION__, lsr);
+	
+	/* If either buffer has data or we are transmitting then return TRUE */
+	if ((oedb->XByteCount & 0x80 ) != 0 )
+		bytes_left += 64;
+
+	if ((lsr & UMP_UART_LSR_TX_MASK ) == 0 )
+		bytes_left += 1;
+
+	/* We return Not Active if we get any kind of error */
+exit_is_tx_active:
+	dbg ("%s - return %d", __FUNCTION__, bytes_left );
+	return bytes_left;
+}
+
+static void TIChasePort(struct edgeport_port *port)
+{
+	int loops;
+	int last_count;
+	int write_size;
+
+restart_tx_loop:
+	// Base the LoopTime on the baud rate
+	if (port->baud_rate == 0)
+		port->baud_rate = 1200;
+
+	write_size = port->tx.count;
+	loops = max(100, (100*write_size)/(port->baud_rate/10));
+	dbg ("%s - write_size %d, baud %d loop = %d", __FUNCTION__,
+	     write_size, port->baud_rate, loops);
+
+	while (1) {
+		// Save Last count
+		last_count = port->tx.count;
+
+		dbg ("%s - Tx Buffer Size = %d loops = %d", __FUNCTION__,
+		     last_count, loops);
+
+		/* Is the Edgeport Buffer empty? */
+		if (port->tx.count == 0)
+			break;
+
+		/* Block the thread for 10ms */
+		wait_ms (10);
+
+		if (last_count == port->tx.count) {
+			/* No activity.. count down. */
+			--loops;
+			if (loops == 0) {
+				dbg ("%s - Wait for TxEmpty - TIMEOUT",
+				     __FUNCTION__);
+				return;
+			}
+		} else {
+			/* Reset timeout value back to a minimum of 1 second */
+			dbg ("%s - Wait for TxEmpty  Reset Count", __FUNCTION__);
+			goto restart_tx_loop;
+		}
+	}
+
+	dbg ("%s - Local Tx Buffer Empty -- Waiting for TI UMP to EMPTY X/Y and FIFO",
+	     __FUNCTION__);
+
+	write_size = TIIsTxActive (port);
+	loops = max(50, (100*write_size)/(port->baud_rate/10));
+	dbg ("%s - write_size %d, baud %d loop = %d", __FUNCTION__, 
+	     write_size, port->baud_rate, loops);
+
+	while (1) {
+		/* This function takes 4 ms; */
+		if (!TIIsTxActive (port)) {
+			/* Delay a few char times */
+			wait_ms (50);
+			dbg ("%s - Empty", __FUNCTION__);
+			return;
+		}
+
+		--loops;
+		if (loops == 0) {
+			dbg ("%s - TIMEOUT", __FUNCTION__);
+			return;
+		}
+	}
+}
+
+static int TIChooseConfiguration (struct usb_device *dev)
+{
+	// There may be multiple configurations on this device, in which case
+	// we would need to read and parse all of them to find out which one
+	// we want. However, we just support one config at this point,
+	// configuration # 1, which is Config Descriptor 0.
+
+	dbg ("%s - Number of Interfaces = %d", __FUNCTION__, dev->config->bNumInterfaces);
+	dbg ("%s - MAX Power            = %d", __FUNCTION__, dev->config->MaxPower*2);
+
+	if (dev->config->bNumInterfaces != 1) {
+		err ("%s - bNumInterfaces is not 1, ERROR!", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+int TIReadRom (struct edgeport_serial *serial, int start_address, int length, __u8 *buffer)
+{
+	int status;
+
+	if (serial->product_info.TiMode == TI_MODE_DOWNLOAD) {
+		status = TIReadDownloadMemory (serial->serial->dev,
+					       start_address,
+					       length,
+					       serial->TI_I2C_Type,
+					       buffer);
+	} else {
+		status = TIReadBootMemory (serial,
+					   start_address,
+					   length,
+					   buffer);
+	}
+
+	return status;
+}
+
+int TIWriteRom (struct edgeport_serial *serial, int start_address, int length, __u8 *buffer)
+{
+	if (serial->product_info.TiMode == TI_MODE_BOOT)
+		return TIWriteBootMemory (serial,
+					  start_address,
+					  length,
+					  buffer);
+
+	if (serial->product_info.TiMode == TI_MODE_DOWNLOAD)
+		return TIWriteDownloadI2C (serial,
+					   start_address,
+					   length,
+					   serial->TI_I2C_Type,
+					   buffer);
+
+	return -EINVAL;
+}
+
+
+
+/* Read a descriptor header from I2C based on type */
+static int TIGetDescriptorAddress (struct edgeport_serial *serial, int desc_type, struct ti_i2c_desc *rom_desc)
+{
+	int start_address;
+	int status;
+
+	/* Search for requested descriptor in I2C */
+	start_address = 2;
+	do {
+		status = TIReadRom (serial,
+				   start_address,
+				   sizeof(struct ti_i2c_desc),
+				   (__u8 *)rom_desc );
+		if (status)
+			return 0;
+
+		if (rom_desc->Type == desc_type)
+			return start_address;
+
+		start_address = start_address + sizeof(struct ti_i2c_desc) +  rom_desc->Size;
+
+	} while ((start_address < TI_MAX_I2C_SIZE) && rom_desc->Type);
+	
+	return 0;
+}
+
+/* Validate descriptor checksum */
+static int ValidChecksum(struct ti_i2c_desc *rom_desc, __u8 *buffer)
+{
+	__u16 i;
+	__u8 cs = 0;
+
+	for (i=0; i < rom_desc->Size; i++) {
+		cs = (__u8)(cs + buffer[i]);
+	}
+	if (cs != rom_desc->CheckSum) {
+		dbg ("%s - Mismatch %x - %x", __FUNCTION__, rom_desc->CheckSum, cs);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* Make sure that the I2C image is good */
+static int TiValidateI2cImage (struct edgeport_serial *serial)
+{
+	int status = 0;
+	struct ti_i2c_desc *rom_desc;
+	int start_address = 2;
+	__u8 *buffer;
+
+	rom_desc = kmalloc (sizeof (*rom_desc), GFP_KERNEL);
+	if (!rom_desc) {
+		err ("%s - out of memory", __FUNCTION__);
+		return -ENOMEM;
+	}
+	buffer = kmalloc (TI_MAX_I2C_SIZE, GFP_KERNEL);
+	if (!buffer) {
+		err ("%s - out of memory when allocating buffer", __FUNCTION__);
+		kfree (rom_desc);
+		return -ENOMEM;
+	}
+
+	// Read the first byte (Signature0) must be 0x52
+	status = TIReadRom (serial, 0, 1, buffer);
+	if (status)
+		goto ExitTiValidateI2cImage; 
+
+	if (*buffer != 0x52) {
+		err ("%s - invalid buffer signature", __FUNCTION__);
+		status = -ENODEV;
+		goto ExitTiValidateI2cImage;
+	}
+
+	do {
+		// Validate the I2C
+		status = TIReadRom (serial,
+				start_address,
+				sizeof(struct ti_i2c_desc),
+				(__u8 *)rom_desc);
+		if (status)
+			break;
+
+		if ((start_address + sizeof(struct ti_i2c_desc) + rom_desc->Size) > TI_MAX_I2C_SIZE) {
+			status = -ENODEV;
+			dbg ("%s - structure too big, erroring out.", __FUNCTION__);
+			break;
+		}
+
+		dbg ("%s Type = 0x%x", __FUNCTION__, rom_desc->Type);
+
+		// Skip type 2 record
+		if ((rom_desc->Type & 0x0f) != I2C_DESC_TYPE_FIRMWARE_BASIC) {
+			// Read the descriptor data
+			status = TIReadRom(serial,
+						start_address+sizeof(struct ti_i2c_desc),
+						rom_desc->Size,
+						buffer);
+			if (status)
+				break;
+
+			status = ValidChecksum(rom_desc, buffer);
+			if (status)
+				break;
+		}
+		start_address = start_address + sizeof(struct ti_i2c_desc) + rom_desc->Size;
+
+	} while ((rom_desc->Type != I2C_DESC_TYPE_ION) && (start_address < TI_MAX_I2C_SIZE));
+
+	if ((rom_desc->Type != I2C_DESC_TYPE_ION) || (start_address > TI_MAX_I2C_SIZE))
+		status = -ENODEV;
+
+ExitTiValidateI2cImage:	
+	kfree (buffer);
+	kfree (rom_desc);
+	return status;
+}
+
+static int TIReadManufDescriptor (struct edgeport_serial *serial, __u8 *buffer)
+{
+	int status;
+	int start_address;
+	struct ti_i2c_desc *rom_desc;
+	struct edge_ti_manuf_descriptor *desc;
+
+	rom_desc = kmalloc (sizeof (*rom_desc), GFP_KERNEL);
+	if (!rom_desc) {
+		err ("%s - out of memory", __FUNCTION__);
+		return -ENOMEM;
+	}
+	start_address = TIGetDescriptorAddress (serial, I2C_DESC_TYPE_ION, rom_desc);
+
+	if (!start_address) {
+		dbg ("%s - Edge Descriptor not found in I2C", __FUNCTION__);
+		status = -ENODEV;
+		goto exit;
+	}
+
+	// Read the descriptor data
+	status = TIReadRom (serial,
+				start_address+sizeof(struct ti_i2c_desc),
+				rom_desc->Size,
+				buffer);
+	if (status)
+		goto exit;
+	
+	status = ValidChecksum(rom_desc, buffer);
+	
+	desc = (struct edge_ti_manuf_descriptor *)buffer;
+	dbg ( "%s - IonConfig      0x%x", __FUNCTION__, desc->IonConfig 	);
+	dbg ( "%s - Version          %d", __FUNCTION__, desc->Version	  	);
+	dbg ( "%s - Cpu/Board      0x%x", __FUNCTION__, desc->CpuRev_BoardRev	);
+	dbg ( "%s - NumPorts         %d", __FUNCTION__, desc->NumPorts  	);	
+	dbg ( "%s - NumVirtualPorts  %d", __FUNCTION__, desc->NumVirtualPorts	);	
+	dbg ( "%s - TotalPorts       %d", __FUNCTION__, desc->TotalPorts  	);	
+
+exit:
+	kfree (rom_desc);
+	return status;
+}
+
+/* Build firmware header used for firmware update */
+static int BuildI2CFirmwareHeader (__u8 *header)
+{
+	__u8 *buffer;
+	int buffer_size;
+	int i;
+	__u8 cs = 0;
+	struct ti_i2c_desc *i2c_header;
+	struct ti_i2c_image_header *img_header;
+	struct ti_i2c_firmware_rec *firmware_rec;
+
+	// In order to update the I2C firmware we must change the type 2 record to type 0xF2.
+	// This will force the UMP to come up in Boot Mode.  Then while in boot mode, the driver 
+	// will download the latest firmware (padded to 15.5k) into the UMP ram. 
+	// And finally when the device comes back up in download mode the driver will cause 
+	// the new firmware to be copied from the UMP Ram to I2C and the firmware will update
+	// the record type from 0xf2 to 0x02.
+	
+	// Allocate a 15.5k buffer + 2 bytes for version number (Firmware Record)
+	buffer_size = (((1024 * 16) - 512 )+ sizeof(struct ti_i2c_firmware_rec));
+
+	buffer = kmalloc (buffer_size, GFP_KERNEL);
+	if (!buffer) {
+		err ("%s - out of memory", __FUNCTION__);
+		return -ENOMEM;
+	}
+	
+	// Set entire image of 0xffs
+	memset (buffer, 0xff, buffer_size);
+
+	// Copy version number into firmware record
+	firmware_rec = (struct ti_i2c_firmware_rec *)buffer;
+
+	firmware_rec->Ver_Major	= OperationalCodeImageVersion.MajorVersion;
+	firmware_rec->Ver_Minor	= OperationalCodeImageVersion.MinorVersion;
+
+	// Pointer to fw_down memory image
+	img_header = (struct ti_i2c_image_header *)&PagableOperationalCodeImage[0];
+
+	memcpy (buffer + sizeof(struct ti_i2c_firmware_rec),
+		&PagableOperationalCodeImage[sizeof(struct ti_i2c_image_header)],
+		img_header->Length);
+
+	for (i=0; i < buffer_size; i++) {
+		cs = (__u8)(cs + buffer[i]);
+	}
+
+	kfree (buffer);
+
+	// Build new header
+	i2c_header =  (struct ti_i2c_desc *)header;
+	firmware_rec =  (struct ti_i2c_firmware_rec*)i2c_header->Data;
+	
+	i2c_header->Type	= I2C_DESC_TYPE_FIRMWARE_BLANK;
+	i2c_header->Size	= (__u16)buffer_size;
+	i2c_header->CheckSum	= cs;
+	firmware_rec->Ver_Major	= OperationalCodeImageVersion.MajorVersion;
+	firmware_rec->Ver_Minor	= OperationalCodeImageVersion.MinorVersion;
+
+	return 0;
+}
+
+/* Try to figure out what type of I2c we have */
+static int TIGetI2cTypeInBootMode (struct edgeport_serial *serial)
+{
+	int status;
+	__u8 data;
+		
+	// Try to read type 2
+	status = TIReadVendorRequestSync (serial->serial->dev,
+					UMPC_MEMORY_READ,		// Request
+					DTK_ADDR_SPACE_I2C_TYPE_II,	// wValue (Address type)
+					0,		 		// wIndex
+					&data,				// TransferBuffer
+					0x01);				// TransferBufferLength
+	if (status)
+		dbg ("%s - read 2 status error = %d", __FUNCTION__, status);
+	else
+		dbg ("%s - read 2 data = 0x%x", __FUNCTION__, data);
+	if ((!status) && data == 0x52) {
+		dbg ("%s - ROM_TYPE_II", __FUNCTION__);
+		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
+		return 0;
+	}
+
+	// Try to read type 3
+	status = TIReadVendorRequestSync (serial->serial->dev,
+					UMPC_MEMORY_READ,		// Request
+					DTK_ADDR_SPACE_I2C_TYPE_III,	// wValue (Address type)
+					0,				// wIndex
+					&data,				// TransferBuffer
+					0x01);				// TransferBufferLength
+	if (status)
+		dbg ("%s - read 3 status error = %d", __FUNCTION__, status);
+	else
+		dbg ("%s - read 2 data = 0x%x", __FUNCTION__, data);
+	if ((!status) && data == 0x52) {
+		dbg ("%s - ROM_TYPE_III", __FUNCTION__);
+		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
+		return 0;
+	}
+
+	dbg ("%s - Unknown", __FUNCTION__);
+	serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
+	return -ENODEV;
+}
+
+static int TISendBulkTransferSync (struct usb_serial *serial, void *buffer, int length, int *num_sent)
+{
+	int status;
+
+	status = usb_bulk_msg (serial->dev,
+				usb_sndbulkpipe(serial->dev,
+						serial->port[0].bulk_out_endpointAddress),
+				buffer,
+				length,
+				num_sent,
+				HZ);
+	return status;
+}
+
+/* Download given firmware image to the device (IN BOOT MODE) */
+static int TIDownloadCodeImage (struct edgeport_serial *serial, __u8 *image, int image_length)
+{
+	int status = 0;
+	int pos;
+	int transfer;
+	int done;
+
+	// Transfer firmware image
+	for (pos = 0; pos < image_length; ) {
+		// Read the next buffer from file
+		transfer = image_length - pos;
+		if (transfer > EDGE_FW_BULK_MAX_PACKET_SIZE)
+			transfer = EDGE_FW_BULK_MAX_PACKET_SIZE;
+
+		// Transfer data
+		status = TISendBulkTransferSync (serial->serial, &image[pos], transfer, &done);
+		if (status)
+			break;
+		// Advance buffer pointer
+		pos += done;
+	}
+
+	return status;
+}
+
+// FIXME!!!
+static int TIConfigureBootDevice (struct usb_device *dev)
+{
+	return 0;
+}
+
+/**
+ * DownloadTIFirmware - Download run-time operating firmware to the TI5052
+ * 
+ * This routine downloads the main operating code into the TI5052, using the
+ * boot code already burned into E2PROM or ROM.
+ */
+static int TIDownloadFirmware (struct edgeport_serial *serial)
+{
+	int status = 0;
+	int start_address;
+	struct edge_ti_manuf_descriptor *ti_manuf_desc;
+	struct usb_interface_descriptor *interface;
+	int download_cur_ver;
+	int download_new_ver;
+
+	/* This routine is entered by both the BOOT mode and the Download mode
+	 * We can determine which code is running by the reading the config
+	 * descriptor and if we have only one bulk pipe it is in boot mode
+	 */
+	serial->product_info.hardware_type = HARDWARE_TYPE_TIUMP;
+
+	/* Default to type 2 i2c */
+	serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
+
+	status = TIChooseConfiguration (serial->serial->dev);
+	if (status)
+		return status;
+
+	interface = serial->serial->dev->config->interface->altsetting;
+	if (!interface) {
+		err ("%s - no interface set, error!", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	// Setup initial mode -- the default mode 0 is TI_MODE_CONFIGURING
+	// if we have more than one endpoint we are definitely in download mode
+	if (interface->bNumEndpoints > 1)
+		serial->product_info.TiMode = TI_MODE_DOWNLOAD;
+	else
+		// Otherwise we will remain in configuring mode
+		serial->product_info.TiMode = TI_MODE_CONFIGURING;
+
+	// Save Download Version Number
+	OperationalCodeImageVersion.MajorVersion = PagableOperationalCodeImageVersion.MajorVersion;
+	OperationalCodeImageVersion.MinorVersion = PagableOperationalCodeImageVersion.MinorVersion;
+	OperationalCodeImageVersion.BuildNumber	 = PagableOperationalCodeImageVersion.BuildNumber;
+
+	/********************************************************************/
+	/* Download Mode */
+	/********************************************************************/
+	if (serial->product_info.TiMode == TI_MODE_DOWNLOAD) {
+		struct ti_i2c_desc *rom_desc;
+
+		dbg ("%s - <<<<<<<<<<<<<<<RUNNING IN DOWNLOAD MODE>>>>>>>>>>", __FUNCTION__);
+
+		status = TiValidateI2cImage (serial);
+		if (status) {
+			dbg ("%s - <<<<<<<<<<<<<<<DOWNLOAD MODE -- BAD I2C >>>>>>>>>>",
+			     __FUNCTION__);
+			return status;
+		}
+		
+		/* Validate Hardware version number
+		 * Read Manufacturing Descriptor from TI Based Edgeport
+		 */
+		ti_manuf_desc = kmalloc (sizeof (*ti_manuf_desc), GFP_KERNEL);
+		if (!ti_manuf_desc) {
+			err ("%s - out of memory.", __FUNCTION__);
+			return -ENOMEM;
+		}
+		status = TIReadManufDescriptor (serial, (__u8 *)ti_manuf_desc);
+		if (status) {
+			kfree (ti_manuf_desc);
+			return status;
+		}
+
+		// Check version number of ION descriptor
+		if (!ignore_cpu_rev && TI_GET_CPU_REVISION(ti_manuf_desc->CpuRev_BoardRev) < 2) {
+			dbg ( "%s - Wrong CPU Rev %d (Must be 2)", __FUNCTION__, 
+			     TI_GET_CPU_REVISION(ti_manuf_desc->CpuRev_BoardRev));
+			kfree (ti_manuf_desc);
+		   	return -EINVAL;
+		}
+
+		rom_desc = kmalloc (sizeof (*rom_desc), GFP_KERNEL);
+		if (!rom_desc) {
+			err ("%s - out of memory.", __FUNCTION__);
+			kfree (ti_manuf_desc);
+			return -ENOMEM;
+		}
+
+		// Search for type 2 record (firmware record)
+		if ((start_address = TIGetDescriptorAddress (serial, I2C_DESC_TYPE_FIRMWARE_BASIC, rom_desc)) != 0) {
+			struct ti_i2c_firmware_rec *firmware_version;
+			__u8 record;
+
+			dbg ("%s - Found Type FIRMWARE (Type 2) record", __FUNCTION__);
+
+			firmware_version = kmalloc (sizeof (*firmware_version), GFP_KERNEL);
+			if (!firmware_version) {
+				err ("%s - out of memory.", __FUNCTION__);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return -ENOMEM;
+			}
+
+			// Validate version number				
+			// Read the descriptor data
+			status = TIReadRom (serial,
+					start_address+sizeof(struct ti_i2c_desc),
+					sizeof(struct ti_i2c_firmware_rec),
+					(__u8 *)firmware_version);
+			if (status) {
+				kfree (firmware_version);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return status;
+			}
+
+			// Check version number of download with current version in I2c
+			download_cur_ver = (firmware_version->Ver_Major << 8) + 
+					   (firmware_version->Ver_Minor);
+			download_new_ver = (OperationalCodeImageVersion.MajorVersion << 8) +
+					   (OperationalCodeImageVersion.MinorVersion);
+
+			dbg ("%s - >>>Firmware Versions Device %d.%d  Driver %d.%d",
+			     __FUNCTION__,
+			     firmware_version->Ver_Major,
+			     firmware_version->Ver_Minor,
+			     OperationalCodeImageVersion.MajorVersion,
+			     OperationalCodeImageVersion.MinorVersion);
+
+			// Check if we have an old version in the I2C and update if necessary
+			if (download_cur_ver != download_new_ver) {
+				dbg ("%s - Update I2C Download from %d.%d to %d.%d",
+				     __FUNCTION__,
+				     firmware_version->Ver_Major,
+				     firmware_version->Ver_Minor,
+				     OperationalCodeImageVersion.MajorVersion,
+				     OperationalCodeImageVersion.MinorVersion);
+
+				// In order to update the I2C firmware we must change the type 2 record to type 0xF2.
+				// This will force the UMP to come up in Boot Mode.  Then while in boot mode, the driver 
+				// will download the latest firmware (padded to 15.5k) into the UMP ram. 
+				// And finally when the device comes back up in download mode the driver will cause 
+				// the new firmware to be copied from the UMP Ram to I2C and the firmware will update
+				// the record type from 0xf2 to 0x02.
+
+				record = I2C_DESC_TYPE_FIRMWARE_BLANK;
+
+				// Change the I2C Firmware record type to 0xf2 to trigger an update
+				status = TIWriteRom (serial,
+							start_address,
+							sizeof(record),
+							&record);
+				if (status) {
+					kfree (firmware_version);
+					kfree (rom_desc);
+					kfree (ti_manuf_desc);
+					return status;
+				}
+
+				// verify the write -- must do this in order for write to 
+				// complete before we do the hardware reset
+				status = TIReadRom (serial,
+							start_address,
+							sizeof(record),
+							&record);
+
+				if (status) {
+					kfree (firmware_version);
+					kfree (rom_desc);
+					kfree (ti_manuf_desc);
+					return status;
+				}
+
+				if (record != I2C_DESC_TYPE_FIRMWARE_BLANK) {
+					err ("%s - error resetting device", __FUNCTION__);
+					kfree (firmware_version);
+					kfree (rom_desc);
+					kfree (ti_manuf_desc);
+					return -ENODEV;
+				}
+
+				dbg ("%s - HARDWARE RESET", __FUNCTION__);
+
+				// Reset UMP -- Back to BOOT MODE
+				status = TISendVendorRequestSync (serial->serial->dev,
+								UMPC_HARDWARE_RESET,	// Request
+								0,			// wValue
+								0,			// wIndex
+								NULL,			// TransferBuffer
+								0);			// TransferBufferLength
+
+				dbg ( "%s - HARDWARE RESET return %d", __FUNCTION__, status);
+
+				/* return an error on purpose. */
+				return -ENODEV;
+			}
+		}
+		// Search for type 0xF2 record (firmware blank record)
+		else if ((start_address = TIGetDescriptorAddress (serial, I2C_DESC_TYPE_FIRMWARE_BLANK, rom_desc)) != 0) {
+			#define HEADER_SIZE	(sizeof(struct ti_i2c_desc) + sizeof(struct ti_i2c_firmware_rec))
+			__u8 *header;
+			__u8 *vheader;
+
+			header  = kmalloc (HEADER_SIZE, GFP_KERNEL);
+			if (!header) {
+				err ("%s - out of memory.", __FUNCTION__);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return -ENOMEM;
+			}
+				
+			vheader = kmalloc (HEADER_SIZE, GFP_KERNEL);
+			if (!vheader) {
+				err ("%s - out of memory.", __FUNCTION__);
+				kfree (header);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return -ENOMEM;
+			}
+			
+			dbg ("%s - Found Type BLANK FIRMWARE (Type F2) record", __FUNCTION__);
+
+			// In order to update the I2C firmware we must change the type 2 record to type 0xF2.
+			// This will force the UMP to come up in Boot Mode.  Then while in boot mode, the driver 
+			// will download the latest firmware (padded to 15.5k) into the UMP ram. 
+			// And finally when the device comes back up in download mode the driver will cause 
+			// the new firmware to be copied from the UMP Ram to I2C and the firmware will update
+			// the record type from 0xf2 to 0x02.
+			status = BuildI2CFirmwareHeader(header);
+			if (status) {
+				kfree (vheader);
+				kfree (header);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return status;
+			}
+
+			// Update I2C with type 0xf2 record with correct size and checksum
+			status = TIWriteRom (serial,
+						start_address,
+						HEADER_SIZE,
+						header);
+			if (status) {
+				kfree (vheader);
+				kfree (header);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return status;
+			}
+
+			// verify the write -- must do this in order for write to 
+			// complete before we do the hardware reset
+			status = TIReadRom (serial,
+						start_address,
+						HEADER_SIZE,
+						vheader);
+
+			if (status) {
+				dbg ("%s - can't read header back", __FUNCTION__);
+				kfree (vheader);
+				kfree (header);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return status;
+			}
+			if (memcmp(vheader, header, HEADER_SIZE)) {
+				dbg ("%s - write download record failed", __FUNCTION__);
+				kfree (vheader);
+				kfree (header);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return status;
+			}
+
+			kfree (vheader);
+			kfree (header);
+
+			dbg ("%s - Start firmware update", __FUNCTION__);
+
+			// Tell firmware to copy download image into I2C 
+			status = TISendVendorRequestSync (serial->serial->dev,
+						UMPC_COPY_DNLD_TO_I2C,	// Request
+						0,			// wValue 
+						0,			// wIndex
+						NULL,			// TransferBuffer
+						0);			// TransferBufferLength
+
+		  	dbg ("%s - Update complete 0x%x", __FUNCTION__, status);
+			if (status) {
+				dbg ("%s - UMPC_COPY_DNLD_TO_I2C failed", __FUNCTION__);
+				kfree (rom_desc);
+				kfree (ti_manuf_desc);
+				return status;
+			}
+		}
+
+		// The device is running the download code
+		kfree (rom_desc);
+		kfree (ti_manuf_desc);
+		return 0;
+	}
+
+	/********************************************************************/
+	/* Boot Mode */
+	/********************************************************************/
+	dbg ("%s - <<<<<<<<<<<<<<<RUNNING IN BOOT MODE>>>>>>>>>>>>>>>",
+	     __FUNCTION__);
+
+	// Configure the TI device so we can use the BULK pipes for download
+	status = TIConfigureBootDevice (serial->serial->dev);
+	if (status)
+		return status;
+
+	if (serial->serial->dev->descriptor.idVendor != USB_VENDOR_ID_ION) {
+		dbg ("%s - VID = 0x%x", __FUNCTION__,
+		     serial->serial->dev->descriptor.idVendor);
+		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
+		goto StayInBootMode;
+	}
+
+	// We have an ION device (I2c Must be programmed)
+	// Determine I2C image type
+	if (TIGetI2cTypeInBootMode(serial)) {
+		goto StayInBootMode;
+	}
+
+	// Registry variable set?
+	if (TIStayInBootMode) {
+		dbg ("%s - TIStayInBootMode", __FUNCTION__);
+		goto StayInBootMode;
+	}
+
+	// Check for ION Vendor ID and that the I2C is valid
+	if (!TiValidateI2cImage(serial)) {
+		struct ti_i2c_image_header *header;
+		int i;
+		__u8 cs = 0;
+		__u8 *buffer;
+		int buffer_size;
+
+		/* Validate Hardware version number
+		 * Read Manufacturing Descriptor from TI Based Edgeport
+		 */
+		ti_manuf_desc = kmalloc (sizeof (*ti_manuf_desc), GFP_KERNEL);
+		if (!ti_manuf_desc) {
+			err ("%s - out of memory.", __FUNCTION__);
+			return -ENOMEM;
+		}
+		status = TIReadManufDescriptor (serial, (__u8 *)ti_manuf_desc);
+		if (status) {
+			kfree (ti_manuf_desc);
+			goto StayInBootMode;
+		}
+
+		// Check for version 2
+		if (!ignore_cpu_rev && TI_GET_CPU_REVISION(ti_manuf_desc->CpuRev_BoardRev) < 2) {
+			dbg ("%s - Wrong CPU Rev %d (Must be 2)", __FUNCTION__,
+			     TI_GET_CPU_REVISION(ti_manuf_desc->CpuRev_BoardRev));
+			kfree (ti_manuf_desc);
+			goto StayInBootMode;
+		}
+
+		kfree (ti_manuf_desc);
+
+		// In order to update the I2C firmware we must change the type 2 record to type 0xF2.
+		// This will force the UMP to come up in Boot Mode.  Then while in boot mode, the driver 
+		// will download the latest firmware (padded to 15.5k) into the UMP ram. 
+		// And finally when the device comes back up in download mode the driver will cause 
+		// the new firmware to be copied from the UMP Ram to I2C and the firmware will update
+		// the record type from 0xf2 to 0x02.
+		
+		/*
+		 * Do we really have to copy the whole firmware image,
+		 * or could we do this in place!
+		 */
+
+		// Allocate a 15.5k buffer + 3 byte header
+		buffer_size = (((1024 * 16) - 512) + sizeof(struct ti_i2c_image_header));
+		buffer = kmalloc (buffer_size, GFP_KERNEL);
+		if (!buffer) {
+			err ("%s - out of memory", __FUNCTION__);
+			return -ENOMEM;
+		}
+		
+		// Initialize the buffer to 0xff (pad the buffer)
+		memset (buffer, 0xff, buffer_size);
+
+		memcpy (buffer, &PagableOperationalCodeImage[0], PagableOperationalCodeSize);
+
+		for(i = sizeof(struct ti_i2c_image_header); i < buffer_size; i++) {
+			cs = (__u8)(cs + buffer[i]);
+		}
+		
+		header = (struct ti_i2c_image_header *)buffer;
+		
+		// update length and checksum after padding
+		header->Length 	 = (__u16)(buffer_size - sizeof(struct ti_i2c_image_header));
+		header->CheckSum = cs;
+
+		// Download the operational code 
+		dbg ("%s - Downloading operational code image (TI UMP)", __FUNCTION__);
+		status = TIDownloadCodeImage (serial, buffer, buffer_size);
+
+		kfree (buffer);
+
+		if (status) {
+	  		dbg ("%s - Error downloading operational code image", __FUNCTION__);
+			return status;
+		}
+
+		// Device will reboot
+		serial->product_info.TiMode = TI_MODE_TRANSITIONING;
+
+  		dbg ("%s - Download successful -- Device rebooting...", __FUNCTION__);
+
+		/* return an error on purpose */
+		return -ENODEV;
+	}
+
+StayInBootMode:
+	// Eprom is invalid or blank stay in boot mode
+	dbg ("%s - <<<<<<<<<<<<<<<STAYING IN BOOT MODE>>>>>>>>>>>>", __FUNCTION__);
+	serial->product_info.TiMode = TI_MODE_BOOT;
+
+	return 0;
+}
+
+
+static int TISetDtr (struct edgeport_port *port)
+{
+	int port_number = port->port->number - port->port->serial->minor;
+
+	dbg ("%s", __FUNCTION__);
+	port->shadow_mcr |= MCR_DTR;
+
+	return TIWriteCommandSync (port->port->serial->dev,
+				UMPC_SET_CLR_DTR,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				1,	/* set */
+				NULL,
+				0);
+}
+
+static int TIClearDtr (struct edgeport_port *port)
+{
+	int port_number = port->port->number - port->port->serial->minor;
+
+	dbg ("%s", __FUNCTION__);
+	port->shadow_mcr &= ~MCR_DTR;
+
+	return TIWriteCommandSync (port->port->serial->dev,
+				UMPC_SET_CLR_DTR,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				0,	/* clear */
+				NULL,
+				0);
+}
+
+static int TISetRts (struct edgeport_port *port)
+{
+	int port_number = port->port->number - port->port->serial->minor;
+
+	dbg ("%s", __FUNCTION__);
+	port->shadow_mcr |= MCR_RTS;
+
+	return TIWriteCommandSync (port->port->serial->dev,
+				UMPC_SET_CLR_RTS,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				1,	/* set */
+				NULL,
+				0);
+}
+
+static int TIClearRts (struct edgeport_port *port)
+{
+	int port_number = port->port->number - port->port->serial->minor;
+
+	dbg ("%s", __FUNCTION__);
+	port->shadow_mcr &= ~MCR_RTS;
+
+	return TIWriteCommandSync (port->port->serial->dev,
+				UMPC_SET_CLR_RTS,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				0,	/* clear */
+				NULL,
+				0);
+}
+
+static int TISetLoopBack (struct edgeport_port *port)
+{
+	int port_number = port->port->number - port->port->serial->minor;
+
+	dbg ("%s", __FUNCTION__);
+
+	return TIWriteCommandSync (port->port->serial->dev,
+				UMPC_SET_CLR_LOOPBACK,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				1,	/* set */
+				NULL,
+				0);
+}
+
+static int TIClearLoopBack (struct edgeport_port *port)
+{
+	int port_number = port->port->number - port->port->serial->minor;
+
+	dbg ("%s", __FUNCTION__);
+
+	return TIWriteCommandSync (port->port->serial->dev,
+				UMPC_SET_CLR_LOOPBACK,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				0,	/* clear */
+				NULL,
+				0);
+}
+
+static int TISetBreak (struct edgeport_port *port)
+{
+	int port_number = port->port->number - port->port->serial->minor;
+
+	dbg ("%s", __FUNCTION__);
+
+	return TIWriteCommandSync (port->port->serial->dev,
+				UMPC_SET_CLR_BREAK,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				1,	/* set */
+				NULL,
+				0);
+}
+
+static int TIClearBreak (struct edgeport_port *port)
+{
+	int port_number = port->port->number - port->port->serial->minor;
+
+	dbg ("%s", __FUNCTION__);
+
+	return TIWriteCommandSync (port->port->serial->dev,
+				UMPC_SET_CLR_BREAK,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				0,	/* clear */
+				NULL,
+				0);
+}
+
+static int TIRestoreMCR (struct edgeport_port *port, __u8 mcr)
+{
+	int status = 0;
+
+	dbg ("%s - %x", __FUNCTION__, mcr);
+
+	if (mcr & MCR_DTR)
+		status = TISetDtr (port);
+	else
+		status = TIClearDtr (port);
+
+	if (status)
+		return status;
+
+	if (mcr & MCR_RTS)
+		status = TISetRts (port);
+	else
+		status = TIClearRts (port);
+
+	if (status)
+		return status;
+
+	if (mcr & MCR_LOOPBACK)
+		status = TISetLoopBack (port);
+	else
+		status = TIClearLoopBack (port);
+
+	return status;
+}
+
+
+
+/* Convert TI LSR to standard UART flags */
+static __u8 MapLineStatus (__u8 ti_lsr)
+{
+	__u8 lsr = 0;
+
+#define MAP_FLAG(flagUmp, flagUart)    \
+	if (ti_lsr & flagUmp) lsr |= flagUart;
+
+	MAP_FLAG(UMP_UART_LSR_OV_MASK, LSR_OVER_ERR)	/* overrun */
+	MAP_FLAG(UMP_UART_LSR_PE_MASK, LSR_PAR_ERR)	/* parity error */
+	MAP_FLAG(UMP_UART_LSR_FE_MASK, LSR_FRM_ERR)	/* framing error */
+	MAP_FLAG(UMP_UART_LSR_BR_MASK, LSR_BREAK)	/* break detected */
+	MAP_FLAG(UMP_UART_LSR_RX_MASK, LSR_RX_AVAIL)	/* receive data available */
+	MAP_FLAG(UMP_UART_LSR_TX_MASK, LSR_TX_EMPTY)	/* transmit holding register empty */
+
+#undef MAP_FLAG
+
+	return lsr;
+}
+
+static void handle_new_msr (struct edgeport_port *edge_port, __u8 msr)
+{
+	struct async_icount *icount;
+
+	dbg ("%s - %02x", __FUNCTION__, msr);
+
+	if (msr & (MSR_DELTA_CTS | MSR_DELTA_DSR | MSR_DELTA_RI | MSR_DELTA_CD)) {
+		icount = &edge_port->icount;
+
+		/* update input line counters */
+		if (msr & MSR_DELTA_CTS)
+			icount->cts++;
+		if (msr & MSR_DELTA_DSR)
+			icount->dsr++;
+		if (msr & MSR_DELTA_CD)
+			icount->dcd++;
+		if (msr & MSR_DELTA_RI)
+			icount->rng++;
+		wake_up_interruptible (&edge_port->delta_msr_wait);
+	}
+
+	/* Save the new modem status */
+	edge_port->shadow_msr = msr & 0xf0;
+
+	return;
+}
+
+static void handle_new_lsr (struct edgeport_port *edge_port, int lsr_data, __u8 lsr, __u8 data)
+{
+	struct async_icount *icount;
+	__u8 new_lsr = (__u8)(lsr & (__u8)(LSR_OVER_ERR | LSR_PAR_ERR | LSR_FRM_ERR | LSR_BREAK));
+
+	dbg ("%s - %02x", __FUNCTION__, new_lsr);
+
+	edge_port->shadow_lsr = lsr;
+
+	if (new_lsr & LSR_BREAK) {
+		/*
+		 * Parity and Framing errors only count if they
+		 * occur exclusive of a break being received.
+		 */
+		new_lsr &= (__u8)(LSR_OVER_ERR | LSR_BREAK);
+	}
+
+	/* Place LSR data byte into Rx buffer */
+	if (lsr_data && edge_port->port->tty) {
+		tty_insert_flip_char(edge_port->port->tty, data, 0);
+		tty_flip_buffer_push(edge_port->port->tty);
+	}
+
+	/* update input line counters */
+	icount = &edge_port->icount;
+	if (new_lsr & LSR_BREAK)
+		icount->brk++;
+	if (new_lsr & LSR_OVER_ERR)
+		icount->overrun++;
+	if (new_lsr & LSR_PAR_ERR)
+		icount->parity++;
+	if (new_lsr & LSR_FRM_ERR)
+		icount->frame++;
+}
+
+
+static void edge_interrupt_callback (struct urb *urb)
+{
+	struct edgeport_serial	*edge_serial = (struct edgeport_serial *)urb->context;
+	struct usb_serial_port *port;
+	struct edgeport_port *edge_port;
+	unsigned char *data = urb->transfer_buffer;
+	int length = urb->actual_length;
+	int port_number;
+	int function;
+	__u8 lsr;
+	__u8 msr;
+
+	dbg("%s", __FUNCTION__);
+
+	if (serial_paranoia_check (edge_serial->serial, __FUNCTION__)) {
+		return;
+	}
+
+	if (urb->status) {
+		dbg("%s - nonzero control read status received: %d", __FUNCTION__, urb->status);
+		return;
+	}
+
+	if (!length) {
+		dbg ("%s - no data in urb", __FUNCTION__);
+		return;
+	}
+		
+	usb_serial_debug_data (__FILE__, __FUNCTION__, length, data);
+		
+	if (length != 2) {
+		dbg ("%s - expecting packet of size 2, got %d", __FUNCTION__, length);
+		return;
+	}
+
+	port_number = TIUMP_GET_PORT_FROM_CODE (data[0]);
+	function    = TIUMP_GET_FUNC_FROM_CODE (data[0]);
+	dbg ("%s - port_number %d, function %d, info 0x%x",
+	     __FUNCTION__, port_number, function, data[1]);
+	port = &edge_serial->serial->port[port_number];
+	if (port_paranoia_check (port, __FUNCTION__)) {
+		dbg ("%s - change found for port that is not present",
+		     __FUNCTION__);
+		return;
+	}
+	edge_port = port->private;
+	if (!edge_port) {
+		dbg ("%s - edge_port not found", __FUNCTION__);
+		return;
+	}
+	switch (function) {
+	case TIUMP_INTERRUPT_CODE_LSR:
+		lsr = MapLineStatus(data[1]);
+		if (lsr & UMP_UART_LSR_DATA_MASK) {
+			/* Save the LSR event for bulk read completion routine */
+			dbg ("%s - LSR Event Port %u LSR Status = %02x",
+			     __FUNCTION__, port_number, lsr);
+			edge_port->lsr_event = 1;
+			edge_port->lsr_mask = lsr;
+		} else {
+			dbg ("%s - ===== Port %d LSR Status = %02x ======",
+			     __FUNCTION__, port_number, lsr);
+			handle_new_lsr (edge_port, 0, lsr, 0);
+		}
+		break;
+
+	case TIUMP_INTERRUPT_CODE_MSR:	// MSR
+		/* Copy MSR from UMP */
+		msr = data[1];
+		dbg ("%s - ===== Port %u MSR Status = %02x ======\n",
+		     __FUNCTION__, port_number, msr);
+		handle_new_msr (edge_port, msr);
+		break;
+
+	default:
+		err ("%s - Unknown Interrupt code from UMP %x\n",
+		     __FUNCTION__, data[1]);
+		break;
+		
+	}
+}
+
+static void edge_bulk_in_callback (struct urb *urb)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)urb->context;
+	unsigned char *data = urb->transfer_buffer;
+	struct tty_struct *tty;
+	int status;
+	int i;
+	int port_number;
+
+	dbg("%s", __FUNCTION__);
+
+	if (port_paranoia_check (edge_port->port, __FUNCTION__))
+		return;
+
+	if (urb->status) {
+		dbg ("%s - nonzero read bulk status received: %d",
+		     __FUNCTION__, urb->status);
+
+		if (urb->status == -EPIPE) {
+			/* clear any problem that might have happened on this pipe */
+			usb_clear_halt (edge_port->port->serial->dev, urb->pipe);
+			goto exit;
+		}
+		return;
+	}
+
+	port_number = edge_port->port->number - edge_port->port->serial->minor;
+
+	if (edge_port->lsr_event) {
+		edge_port->lsr_event = 0;
+		dbg ("%s ===== Port %u LSR Status = %02x, Data = %02x ======",
+		     __FUNCTION__, port_number, edge_port->lsr_mask, *data);
+		handle_new_lsr (edge_port, 1, edge_port->lsr_mask, *data);
+		/* Adjust buffer length/pointer */
+		--urb->actual_length;
+		++data;
+	}
+
+	tty = edge_port->port->tty;
+	if (tty && urb->actual_length) {
+		usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
+
+		if (edge_port->close_pending) {
+			dbg ("%s - close is pending, dropping data on the floor.", __FUNCTION__);
+		} else {
+			for (i = 0; i < urb->actual_length ; ++i) {
+				/* if we insert more than TTY_FLIPBUF_SIZE characters,
+				 * we drop them. */
+				if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+					tty_flip_buffer_push(tty);
+				}
+				/* this doesn't actually push the data through unless
+				 * tty->low_latency is set */
+				tty_insert_flip_char(tty, data[i], 0);
+			}
+			tty_flip_buffer_push(tty);
+		}
+		edge_port->icount.rx += urb->actual_length;
+	}
+
+exit:
+	/* continue always trying to read */
+	urb->dev = edge_port->port->serial->dev;
+	status = usb_submit_urb (urb);
+	if (status)
+		err ("%s - usb_submit_urb failed with result %d",
+		     __FUNCTION__, status);
+}
+
+static void edge_bulk_out_callback (struct urb *urb)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+	struct tty_struct *tty;
+
+	dbg ("%s - port %d", __FUNCTION__, port->number);
+
+	if (!serial) {
+		dbg ("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
+	if (urb->status) {
+		dbg ("%s - nonzero write bulk status received: %d",
+		     __FUNCTION__, urb->status);
+
+		if (urb->status == -EPIPE) {
+			/* clear any problem that might have happened on this pipe */
+			usb_clear_halt (serial->dev, urb->pipe);
+		}
+		return;
+	}
+
+	tty = port->tty;
+	if (tty) {
+		/* let the tty driver wakeup if it has a special write_wakeup function */
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
+			(tty->ldisc.write_wakeup)(tty);
+		}
+
+		/* tell the tty driver that something has changed */
+		wake_up_interruptible(&tty->write_wait);
+	}
+}
+
+static int edge_open (struct usb_serial_port *port, struct file * filp)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)port->private;
+	struct edgeport_serial *edge_serial;
+	struct usb_device *dev;
+	struct urb *urb;
+	int port_number;
+	int status;
+	u16 open_settings;
+	u8 transaction_timeout;
+
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+	
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (edge_port == NULL)
+		return -ENODEV;
+
+	/* force low_latency on so that our tty_push actually forces the data through, 
+	   otherwise it is scheduled, and with high data rates (like with OHCI) data
+	   can get lost. */
+	if (port->tty)
+		port->tty->low_latency = 1;
+
+	port_number = port->number - port->serial->minor;
+	switch (port_number) {
+		case 0:
+			edge_port->uart_base = UMPMEM_BASE_UART1;
+			edge_port->dma_address = UMPD_OEDB1_ADDRESS;
+			break;
+		case 1:
+			edge_port->uart_base = UMPMEM_BASE_UART2;
+			edge_port->dma_address = UMPD_OEDB2_ADDRESS;
+			break;
+		default:
+			err ("Unknown port number!!!");
+			return -ENODEV;
+	}
+
+	dbg ("%s - port_number = %d, uart_base = %04x, dma_address = %04x",
+	     __FUNCTION__, port_number, edge_port->uart_base, edge_port->dma_address);
+
+	dev = port->serial->dev;
+
+	memset (&(edge_port->icount), 0x00, sizeof(edge_port->icount));
+	init_waitqueue_head (&edge_port->delta_msr_wait);
+
+	/* turn off loopback */
+	status = TIClearLoopBack (edge_port);
+	if (status)
+		return status;
+	
+	/* set up the port settings */
+	edge_set_termios (port, NULL);
+
+	/* open up the port */
+
+	/* milliseconds to timeout for DMA transfer */
+	transaction_timeout = 2;
+
+	edge_port->ump_read_timeout = max (20, ((transaction_timeout * 3) / 2) );
+
+	// milliseconds to timeout for DMA transfer
+	open_settings = (u8)(UMP_DMA_MODE_CONTINOUS | 
+			     UMP_PIPE_TRANS_TIMEOUT_ENA | 
+			     (transaction_timeout << 2));
+
+	dbg ("%s - Sending UMPC_OPEN_PORT", __FUNCTION__);
+
+	/* Tell TI to open and start the port */
+	status = TIWriteCommandSync (dev,
+					UMPC_OPEN_PORT,
+					(u8)(UMPM_UART1_PORT + port_number),
+					open_settings,
+					NULL,
+					0);
+	if (status)
+		return status;
+
+	/* Start the DMA? */
+	status = TIWriteCommandSync (dev,
+					UMPC_START_PORT,
+					(u8)(UMPM_UART1_PORT + port_number),
+					0,
+					NULL,
+					0);
+	if (status)
+		return status;
+
+	/* Clear TX and RX buffers in UMP */
+	status = TIPurgeDataSync (port, UMP_PORT_DIR_OUT | UMP_PORT_DIR_IN);
+	if (status)
+		return status;
+
+	/* Read Initial MSR */
+	status = TIReadVendorRequestSync (dev,
+					UMPC_READ_MSR,	// Request
+					0,		// wValue
+					(__u16)(UMPM_UART1_PORT + port_number),	// wIndex (Address)
+					&edge_port->shadow_msr,			// TransferBuffer
+					1);					// TransferBufferLength
+	if (status)
+		return status;
+
+	dbg ("ShadowMSR 0x%X", edge_port->shadow_msr);
+ 
+	edge_serial = edge_port->edge_serial;
+	if (edge_serial->num_ports_open == 0) {
+		dbg ("%s - setting up bulk in urb", __FUNCTION__);
+		/* we are the first port to be opened, let's post the interrupt urb */
+		urb = edge_serial->serial->port[0].interrupt_in_urb;
+		if (!urb) {
+			err ("%s - no interrupt urb present, exiting", __FUNCTION__);
+			return -EINVAL;
+		}
+		urb->complete = edge_interrupt_callback;
+		urb->context = edge_serial;
+		urb->dev = dev;
+		status = usb_submit_urb (urb);
+		if (status) {
+			err ("%s - usb_submit_urb failed with value %d", __FUNCTION__, status);
+			return status;
+		}
+	}
+
+	/*
+	 * reset the data toggle on the bulk endpoints to work around bug in
+	 * host controllers where things get out of sync some times
+	 */
+	usb_clear_halt (dev, port->write_urb->pipe);
+	usb_clear_halt (dev, port->read_urb->pipe);
+
+	/* start up our bulk read urb */
+	urb = port->read_urb;
+	if (!urb) {
+		err ("%s - no read urb present, exiting", __FUNCTION__);
+		return -EINVAL;
+	}
+	urb->complete = edge_bulk_in_callback;
+	urb->context = edge_port;
+	urb->dev = dev;
+	status = usb_submit_urb (urb);
+	if (status) {
+		err ("%s - read bulk usb_submit_urb failed with value %d", __FUNCTION__, status);
+		return status;
+	}
+
+	++edge_serial->num_ports_open;
+
+	dbg("%s - exited", __FUNCTION__);
+
+	return 0;
+}
+
+static void edge_close (struct usb_serial_port *port, struct file * filp)
+{
+	struct usb_serial *serial;
+	struct edgeport_serial *edge_serial;
+	struct edgeport_port *edge_port;
+	int port_number;
+	int status;
+
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
+	dbg("%s - port %d", __FUNCTION__, port->number);
+			 
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+	
+	edge_serial = (struct edgeport_serial *)serial->private;
+	edge_port = (struct edgeport_port *)port->private;
+	if ((edge_serial == NULL) || (edge_port == NULL))
+		return;
+	
+	if (serial->dev) {
+		/* The bulkreadcompletion routine will check 
+		 * this flag and dump add read data */
+		edge_port->close_pending = 1;
+
+		/* chase the port close */
+		TIChasePort (edge_port);
+
+		usb_unlink_urb (port->read_urb);
+
+		/* assuming we can still talk to the device,
+		 * send a close port command to it */
+		dbg("%s - send umpc_close_port", __FUNCTION__);
+		port_number = port->number - port->serial->minor;
+		status = TIWriteCommandSync (port->serial->dev,
+					     UMPC_CLOSE_PORT,
+					     (__u8)(UMPM_UART1_PORT + port_number),
+					     0,
+					     NULL,
+					     0);
+		--edge_port->edge_serial->num_ports_open;
+		if (edge_port->edge_serial->num_ports_open <= 0) {
+			/* last port is now closed, let's shut down our interrupt urb */
+			usb_unlink_urb (serial->port[0].interrupt_in_urb);
+			edge_port->edge_serial->num_ports_open = 0;
+		}
+	edge_port->close_pending = 0;
+	}
+
+	dbg("%s - exited", __FUNCTION__);
+}
+
+static int edge_write (struct usb_serial_port *port, int from_user, const unsigned char *data, int count)
+{
+	struct usb_serial *serial = port->serial;
+	struct edgeport_port *edge_port = port->private;
+	int result;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (count == 0) {
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
+		return 0;
+	}
+
+	if (edge_port == NULL)
+		return -ENODEV;
+	if (edge_port->close_pending == 1)
+		return -ENODEV;
+	
+	if (port->write_urb->status == -EINPROGRESS) {
+		dbg ("%s - already writing", __FUNCTION__);
+		return 0;
+	}
+
+	count = min (count, port->bulk_out_size);
+
+	if (from_user) {
+		if (copy_from_user(port->write_urb->transfer_buffer, data, count))
+			return -EFAULT;
+	} else {
+		memcpy (port->write_urb->transfer_buffer, data, count);
+	}
+
+	usb_serial_debug_data (__FILE__, __FUNCTION__, count, port->write_urb->transfer_buffer);
+
+	/* set up our urb */
+	usb_fill_bulk_urb (port->write_urb, serial->dev,
+			   usb_sndbulkpipe (serial->dev,
+					    port->bulk_out_endpointAddress),
+			   port->write_urb->transfer_buffer, count,
+			   edge_bulk_out_callback,
+			   port);
+
+	/* send the data out the bulk port */
+	result = usb_submit_urb(port->write_urb);
+	if (result)
+		err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
+	else
+		result = count;
+
+	if (result > 0)
+		edge_port->icount.tx += count;
+
+	return result;
+}
+
+static int edge_write_room (struct usb_serial_port *port)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
+	int room = 0;
+
+	dbg("%s", __FUNCTION__);
+
+	if (edge_port == NULL)
+		return -ENODEV;
+	if (edge_port->close_pending == 1)
+		return -ENODEV;
+	
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (port->write_urb->status != -EINPROGRESS)
+		room = port->bulk_out_size;
+
+	dbg("%s - returns %d", __FUNCTION__, room);
+	return room;
+}
+
+static int edge_chars_in_buffer (struct usb_serial_port *port)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
+	int chars = 0;
+
+	dbg("%s", __FUNCTION__);
+
+	if (edge_port == NULL)
+		return -ENODEV;
+	if (edge_port->close_pending == 1)
+		return -ENODEV;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (port->write_urb->status == -EINPROGRESS)
+		chars = port->write_urb->transfer_buffer_length;
+
+	dbg ("%s - returns %d", __FUNCTION__, chars);
+	return chars;
+}
+
+static void edge_throttle (struct usb_serial_port *port)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
+	struct tty_struct *tty;
+	int status;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (edge_port == NULL)
+		return;
+
+	tty = port->tty;
+	if (!tty) {
+		dbg ("%s - no tty available", __FUNCTION__);
+		return;
+	}
+	/* if we are implementing XON/XOFF, send the stop character */
+	if (I_IXOFF(tty)) {
+		unsigned char stop_char = STOP_CHAR(tty);
+		status = edge_write (port, 0, &stop_char, 1);
+		if (status <= 0) {
+			return;
+		}
+	}
+
+	/* if we are implementing RTS/CTS, toggle that line */
+	if (tty->termios->c_cflag & CRTSCTS) {
+		status = TIClearRts (edge_port);
+	}
+
+	usb_unlink_urb (port->read_urb);
+}
+
+static void edge_unthrottle (struct usb_serial_port *port)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
+	struct tty_struct *tty;
+	int status;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (edge_port == NULL)
+		return;
+
+	tty = port->tty;
+	if (!tty) {
+		dbg ("%s - no tty available", __FUNCTION__);
+		return;
+	}
+
+	/* if we are implementing XON/XOFF, send the start character */
+	if (I_IXOFF(tty)) {
+		unsigned char start_char = START_CHAR(tty);
+		status = edge_write (port, 0, &start_char, 1);
+		if (status <= 0) {
+			return;
+		}
+	}
+
+	/* if we are implementing RTS/CTS, toggle that line */
+	if (tty->termios->c_cflag & CRTSCTS) {
+		status = TISetRts (edge_port);
+	}
+
+	port->read_urb->dev = port->serial->dev;
+	status = usb_submit_urb (port->read_urb);
+	if (status) {
+		err ("%s - usb_submit_urb failed with value %d", __FUNCTION__, status);
+	}
+}
+
+
+static void change_port_settings (struct edgeport_port *edge_port, struct termios *old_termios)
+{
+	struct ump_uart_config *config;
+	struct tty_struct *tty;
+	int baud;
+	int round;
+	unsigned cflag;
+	int status;
+	int port_number = edge_port->port->number - edge_port->port->serial->minor;
+
+	dbg("%s - port %d", __FUNCTION__, edge_port->port->number);
+
+	tty = edge_port->port->tty;
+	if ((!tty) ||
+	    (!tty->termios)) {
+		dbg("%s - no tty structures", __FUNCTION__);
+		return;
+	}
+
+	config = kmalloc (sizeof (*config), GFP_KERNEL);
+	if (!config) {
+		err ("%s - out of memory", __FUNCTION__);
+		return;
+	}
+
+	cflag = tty->termios->c_cflag;
+
+	config->wFlags = 0;
+
+	/* These flags must be set */
+	config->wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT;
+	config->wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR;
+	config->bUartMode = 0;
+
+	switch (cflag & CSIZE) {
+		case CS5:
+			    config->bDataBits = UMP_UART_CHAR5BITS;
+			    dbg ("%s - data bits = 5", __FUNCTION__);
+			    break;
+		case CS6:
+			    config->bDataBits = UMP_UART_CHAR6BITS;
+			    dbg ("%s - data bits = 6", __FUNCTION__);
+			    break;
+		case CS7:
+			    config->bDataBits = UMP_UART_CHAR7BITS;
+			    dbg ("%s - data bits = 7", __FUNCTION__);
+			    break;
+		default:
+		case CS8:
+			    config->bDataBits = UMP_UART_CHAR8BITS;
+			    dbg ("%s - data bits = 8", __FUNCTION__);
+			    break;
+	}
+
+	if (cflag & PARENB) {
+		if (cflag & PARODD) {
+			config->wFlags |= UMP_MASK_UART_FLAGS_PARITY;
+			config->bParity = UMP_UART_ODDPARITY;
+			dbg("%s - parity = odd", __FUNCTION__);
+		} else {
+			config->wFlags |= UMP_MASK_UART_FLAGS_PARITY;
+			config->bParity = UMP_UART_EVENPARITY;
+			dbg("%s - parity = even", __FUNCTION__);
+		}
+	} else {
+		config->bParity = UMP_UART_NOPARITY; 	
+		dbg("%s - parity = none", __FUNCTION__);
+	}
+
+	if (cflag & CSTOPB) {
+		config->bStopBits = UMP_UART_STOPBIT2;
+		dbg("%s - stop bits = 2", __FUNCTION__);
+	} else {
+		config->bStopBits = UMP_UART_STOPBIT1;
+		dbg("%s - stop bits = 1", __FUNCTION__);
+	}
+
+	/* figure out the flow control settings */
+	if (cflag & CRTSCTS) {
+		config->wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW;
+		config->wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW;
+		dbg("%s - RTS/CTS is enabled", __FUNCTION__);
+	} else {
+		dbg("%s - RTS/CTS is disabled", __FUNCTION__);
+	}
+
+	/* if we are implementing XON/XOFF, set the start and stop character in the device */
+	if (I_IXOFF(tty) || I_IXON(tty)) {
+		config->cXon  = START_CHAR(tty);
+		config->cXoff = STOP_CHAR(tty);
+
+		/* if we are implementing INBOUND XON/XOFF */
+		if (I_IXOFF(tty)) {
+			config->wFlags |= UMP_MASK_UART_FLAGS_IN_X;
+			dbg ("%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x",
+			     __FUNCTION__, config->cXon, config->cXoff);
+		} else {
+			dbg ("%s - INBOUND XON/XOFF is disabled", __FUNCTION__);
+		}
+
+		/* if we are implementing OUTBOUND XON/XOFF */
+		if (I_IXON(tty)) {
+			config->wFlags |= UMP_MASK_UART_FLAGS_OUT_X;
+			dbg ("%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x",
+			     __FUNCTION__, config->cXon, config->cXoff);
+		} else {
+			dbg ("%s - OUTBOUND XON/XOFF is disabled", __FUNCTION__);
+		}
+	}
+
+	/* Round the baud rate */
+	baud = tty_get_baud_rate(tty);
+	if (!baud) {
+		/* pick a default, any default... */
+		baud = 9600;
+	}
+	config->wBaudRate = (__u16)(461550L / baud);
+	round = 4615500L / baud;
+	if ((round - (config->wBaudRate * 10)) >= 5)
+		config->wBaudRate++;
+
+	dbg ("%s - baud rate = %d, wBaudRate = %d", __FUNCTION__, baud, config->wBaudRate);
+
+	dbg ("wBaudRate:   %d", (int)(461550L / config->wBaudRate));
+	dbg ("wFlags:    0x%x", config->wFlags);
+	dbg ("bDataBits:   %d", config->bDataBits);
+	dbg ("bParity:     %d", config->bParity);
+	dbg ("bStopBits:   %d", config->bStopBits);
+	dbg ("cXon:        %d", config->cXon);
+	dbg ("cXoff:       %d", config->cXoff);
+	dbg ("bUartMode:   %d", config->bUartMode);
+
+	/* move the word values into big endian mode */
+	cpu_to_be16s (&config->wFlags);
+	cpu_to_be16s (&config->wBaudRate);
+
+	status = TIWriteCommandSync (edge_port->port->serial->dev,
+				UMPC_SET_CONFIG,
+				(__u8)(UMPM_UART1_PORT + port_number),
+				0,
+				(__u8 *)config,
+				sizeof(*config));
+	if (status) {
+		dbg ("%s - error %d when trying to write config to device",
+		     __FUNCTION__, status);
+	}
+
+	kfree (config);
+	
+	return;
+}
+
+static void edge_set_termios (struct usb_serial_port *port, struct termios *old_termios)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
+	struct tty_struct *tty = port->tty;
+	unsigned int cflag;
+
+	if (!port->tty || !port->tty->termios) {
+		dbg ("%s - no tty or termios", __FUNCTION__);
+		return;
+	}
+
+	cflag = tty->termios->c_cflag;
+	/* check that they really want us to change something */
+	if (old_termios) {
+		if ((cflag == old_termios->c_cflag) &&
+		    (RELEVANT_IFLAG(tty->termios->c_iflag) == RELEVANT_IFLAG(old_termios->c_iflag))) {
+			dbg ("%s - nothing to change", __FUNCTION__);
+			return;
+		}
+	}
+
+	dbg("%s - clfag %08x iflag %08x", __FUNCTION__, 
+	    tty->termios->c_cflag,
+	    RELEVANT_IFLAG(tty->termios->c_iflag));
+	if (old_termios) {
+		dbg("%s - old clfag %08x old iflag %08x", __FUNCTION__,
+		    old_termios->c_cflag,
+		    RELEVANT_IFLAG(old_termios->c_iflag));
+	}
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (edge_port == NULL)
+		return;
+
+	/* change the port settings to the new ones specified */
+	change_port_settings (edge_port, old_termios);
+
+	return;
+}
+
+static int set_modem_info (struct edgeport_port *edge_port, unsigned int cmd, unsigned int *value)
+{
+	unsigned int mcr = edge_port->shadow_mcr;
+	unsigned int arg;
+
+	if (copy_from_user(&arg, value, sizeof(int)))
+		return -EFAULT;
+
+	switch (cmd) {
+		case TIOCMBIS:
+			if (arg & TIOCM_RTS)
+				mcr |= MCR_RTS;
+			if (arg & TIOCM_DTR)
+				mcr |= MCR_RTS;
+			if (arg & TIOCM_LOOP)
+				mcr |= MCR_LOOPBACK;
+			break;
+
+		case TIOCMBIC:
+			if (arg & TIOCM_RTS)
+				mcr &= ~MCR_RTS;
+			if (arg & TIOCM_DTR)
+				mcr &= ~MCR_RTS;
+			if (arg & TIOCM_LOOP)
+				mcr &= ~MCR_LOOPBACK;
+			break;
+
+		case TIOCMSET:
+			/* turn off the RTS and DTR and LOOPBACK 
+			 * and then only turn on what was asked to */
+			mcr &=  ~(MCR_RTS | MCR_DTR | MCR_LOOPBACK);
+			mcr |= ((arg & TIOCM_RTS) ? MCR_RTS : 0);
+			mcr |= ((arg & TIOCM_DTR) ? MCR_DTR : 0);
+			mcr |= ((arg & TIOCM_LOOP) ? MCR_LOOPBACK : 0);
+			break;
+	}
+
+	edge_port->shadow_mcr = mcr;
+
+	TIRestoreMCR (edge_port, mcr);
+
+	return 0;
+}
+
+static int get_modem_info (struct edgeport_port *edge_port, unsigned int *value)
+{
+	unsigned int result = 0;
+	unsigned int msr = edge_port->shadow_msr;
+	unsigned int mcr = edge_port->shadow_mcr;
+
+	result = ((mcr & MCR_DTR)	? TIOCM_DTR: 0)	  /* 0x002 */
+		  | ((mcr & MCR_RTS)	? TIOCM_RTS: 0)   /* 0x004 */
+		  | ((msr & MSR_CTS)	? TIOCM_CTS: 0)   /* 0x020 */
+		  | ((msr & MSR_CD)	? TIOCM_CAR: 0)   /* 0x040 */
+		  | ((msr & MSR_RI)	? TIOCM_RI:  0)   /* 0x080 */
+		  | ((msr & MSR_DSR)	? TIOCM_DSR: 0);  /* 0x100 */
+
+
+	dbg("%s -- %x", __FUNCTION__, result);
+
+	if (copy_to_user(value, &result, sizeof(int)))
+		return -EFAULT;
+	return 0;
+}
+
+static int get_serial_info (struct edgeport_port *edge_port, struct serial_struct * retinfo)
+{
+	struct serial_struct tmp;
+
+	if (!retinfo)
+		return -EFAULT;
+
+	memset(&tmp, 0, sizeof(tmp));
+
+	tmp.type		= PORT_16550A;
+	tmp.line		= edge_port->port->serial->minor;
+	tmp.port		= edge_port->port->number;
+	tmp.irq			= 0;
+	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
+	tmp.xmit_fifo_size	= edge_port->port->bulk_out_size;
+	tmp.baud_base		= 9600;
+	tmp.close_delay		= 5*HZ;
+	tmp.closing_wait	= 30*HZ;
+//	tmp.custom_divisor	= state->custom_divisor;
+//	tmp.hub6		= state->hub6;
+//	tmp.io_type		= state->io_type;
+
+
+	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+static int edge_ioctl (struct usb_serial_port *port, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
+	struct async_icount cnow;
+	struct async_icount cprev;
+
+	dbg("%s - port %d, cmd = 0x%x", __FUNCTION__, port->number, cmd);
+
+	switch (cmd) {
+		case TIOCINQ:
+			dbg("%s - (%d) TIOCINQ", __FUNCTION__, port->number);
+//			return get_number_bytes_avail(edge_port, (unsigned int *) arg);
+			break;
+
+		case TIOCSERGETLSR:
+			dbg("%s - (%d) TIOCSERGETLSR", __FUNCTION__, port->number);
+//			return get_lsr_info(edge_port, (unsigned int *) arg);
+			break;
+
+		case TIOCMBIS:
+		case TIOCMBIC:
+		case TIOCMSET:
+			dbg("%s - (%d) TIOCMSET/TIOCMBIC/TIOCMSET", __FUNCTION__, port->number);
+			return set_modem_info(edge_port, cmd, (unsigned int *) arg);
+			break;
+
+		case TIOCMGET:  
+			dbg("%s - (%d) TIOCMGET", __FUNCTION__, port->number);
+			return get_modem_info(edge_port, (unsigned int *) arg);
+			break;
+
+		case TIOCGSERIAL:
+			dbg("%s - (%d) TIOCGSERIAL", __FUNCTION__, port->number);
+			return get_serial_info(edge_port, (struct serial_struct *) arg);
+			break;
+
+		case TIOCSSERIAL:
+			dbg("%s - (%d) TIOCSSERIAL", __FUNCTION__, port->number);
+			break;
+
+		case TIOCMIWAIT:
+			dbg("%s - (%d) TIOCMIWAIT", __FUNCTION__, port->number);
+			cprev = edge_port->icount;
+			while (1) {
+				interruptible_sleep_on(&edge_port->delta_msr_wait);
+				/* see if a signal did it */
+				if (signal_pending(current))
+					return -ERESTARTSYS;
+				cnow = edge_port->icount;
+				if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
+				    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)
+					return -EIO; /* no change => error */
+				if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+				    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+				    ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+				    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {
+					return 0;
+				}
+				cprev = cnow;
+			}
+			/* not reached */
+			break;
+
+		case TIOCGICOUNT:
+			dbg ("%s - (%d) TIOCGICOUNT RX=%d, TX=%d", __FUNCTION__,
+			     port->number, edge_port->icount.rx, edge_port->icount.tx);
+			if (copy_to_user((void *)arg, &edge_port->icount, sizeof(edge_port->icount)))
+				return -EFAULT;
+			return 0;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+static void edge_break (struct usb_serial_port *port, int break_state)
+{
+	struct edgeport_port *edge_port = (struct edgeport_port *)(port->private);
+	int status;
+
+	dbg ("%s - state = %d", __FUNCTION__, break_state);
+
+	/* chase the port close */
+	TIChasePort (edge_port);
+
+	if (break_state == -1) {
+		status = TISetBreak (edge_port);
+	} else {
+		status = TIClearBreak (edge_port);
+	}
+	if (status) {
+		dbg ("%s - error %d sending break set/clear command.",
+		     __FUNCTION__, status);
+	}
+}
+
+static int edge_startup (struct usb_serial *serial)
+{
+	struct edgeport_serial *edge_serial;
+	struct edgeport_port *edge_port;
+	struct usb_device *dev;
+	int status;
+	int i;
+
+	dev = serial->dev;
+
+	/* create our private serial structure */
+	edge_serial = kmalloc (sizeof(struct edgeport_serial), GFP_KERNEL);
+	if (edge_serial == NULL) {
+		err("%s - Out of memory", __FUNCTION__);
+		return -ENOMEM;
+	}
+	memset (edge_serial, 0, sizeof(struct edgeport_serial));
+	edge_serial->serial = serial;
+	serial->private = edge_serial;
+
+	status = TIDownloadFirmware (edge_serial);
+	if (status) {
+		kfree (edge_serial);
+		return status;
+	}
+
+	/* set up our port private structures */
+	for (i = 0; i < serial->num_ports; ++i) {
+		edge_port = kmalloc (sizeof(struct edgeport_port), GFP_KERNEL);
+		if (edge_port == NULL) {
+			err("%s - Out of memory", __FUNCTION__);
+			return -ENOMEM;
+		}
+		memset (edge_port, 0, sizeof(struct edgeport_port));
+		edge_port->port = &serial->port[i];
+		edge_port->edge_serial = edge_serial;
+		serial->port[i].private = edge_port;
+	}
+	
+	return 0;
+}
+
+static void edge_shutdown (struct usb_serial *serial)
+{
+	int i;
+
+	dbg ("%s", __FUNCTION__);
+
+	for (i=0; i < serial->num_ports; ++i) {
+		kfree (serial->port[i].private);
+		serial->port[i].private = NULL;
+	}
+	kfree (serial->private);
+	serial->private = NULL;
+}
+
+
+static struct usb_serial_device_type edgeport_1port_device = {
+	owner:			THIS_MODULE,
+	name:			"Edgeport TI 1 port adapter",
+	id_table:		edgeport_1port_id_table,
+	num_interrupt_in:	1,
+	num_bulk_in:		1,
+	num_bulk_out:		1,
+	num_ports:		1,
+	open:			edge_open,
+	close:			edge_close,
+	throttle:		edge_throttle,
+	unthrottle:		edge_unthrottle,
+	startup:		edge_startup,
+	shutdown:		edge_shutdown,
+	ioctl:			edge_ioctl,
+	set_termios:		edge_set_termios,
+	write:			edge_write,
+	write_room:		edge_write_room,
+	chars_in_buffer:	edge_chars_in_buffer,
+	break_ctl:		edge_break,
+};
+
+static struct usb_serial_device_type edgeport_2port_device = {
+	owner:			THIS_MODULE,
+	name:			"Edgeport TI 2 port adapter",
+	id_table:		edgeport_2port_id_table,
+	num_interrupt_in:	1,
+	num_bulk_in:		2,
+	num_bulk_out:		2,
+	num_ports:		2,
+	open:			edge_open,
+	close:			edge_close,
+	throttle:		edge_throttle,
+	unthrottle:		edge_unthrottle,
+	startup:		edge_startup,
+	shutdown:		edge_shutdown,
+	ioctl:			edge_ioctl,
+	set_termios:		edge_set_termios,
+	write:			edge_write,
+	write_room:		edge_write_room,
+	chars_in_buffer:	edge_chars_in_buffer,
+	break_ctl:		edge_break,
+};
+
+
+static int __init edgeport_init(void)
+{
+	usb_serial_register (&edgeport_1port_device);
+	usb_serial_register (&edgeport_2port_device);
+	info(DRIVER_DESC " " DRIVER_VERSION);
+	return 0;
+}
+
+static void __exit edgeport_exit (void)
+{
+	usb_serial_deregister (&edgeport_1port_device);
+	usb_serial_deregister (&edgeport_2port_device);
+}
+
+module_init(edgeport_init);
+module_exit(edgeport_exit);
+
+/* Module information */
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+MODULE_PARM(ignore_cpu_rev, "i");
+MODULE_PARM_DESC(ignore_cpu_rev, "Ignore the cpu revision when connecting to a device");
+
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_ti.h linux-2.4.19/drivers/usb/serial/io_ti.h
--- linux-2.4.19.old/drivers/usb/serial/io_ti.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/serial/io_ti.h	Mon Nov 25 12:27:08 2002
@@ -0,0 +1,180 @@
+/*****************************************************************************  
+ *
+ *	Copyright (c) 1997-2002 Inside Out Networks, Inc.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *
+ *	Feb-16-2001	DMI	Added I2C structure definitions
+ *	May-29-2002	gkh	Ported to Linux
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _IO_TI_H_
+#define _IO_TI_H_
+
+/* Address Space */
+#define DTK_ADDR_SPACE_XDATA		0x03	/* Addr is placed in XDATA space */
+#define DTK_ADDR_SPACE_I2C_TYPE_II	0x82	/* Addr is placed in I2C area */
+#define DTK_ADDR_SPACE_I2C_TYPE_III	0x83	/* Addr is placed in I2C area */
+
+// UART Defines
+#define UMPMEM_BASE_UART1		0xFFA0  /* UMP UART1 base address          */
+#define UMPMEM_BASE_UART2		0xFFB0  /* UMP UART2 base address          */
+#define UMPMEM_OFFS_UART_LSR		0x05    /* UMP UART LSR register offset    */
+
+/* Bits per character */
+#define UMP_UART_CHAR5BITS		0x00
+#define UMP_UART_CHAR6BITS		0x01
+#define UMP_UART_CHAR7BITS		0x02
+#define UMP_UART_CHAR8BITS		0x03
+
+/* Parity */
+#define UMP_UART_NOPARITY		0x00
+#define UMP_UART_ODDPARITY		0x01
+#define UMP_UART_EVENPARITY		0x02
+#define UMP_UART_MARKPARITY		0x03
+#define UMP_UART_SPACEPARITY		0x04
+
+/* Stop bits */
+#define UMP_UART_STOPBIT1		0x00
+#define UMP_UART_STOPBIT15		0x01
+#define UMP_UART_STOPBIT2		0x02
+
+/* Line status register masks */
+#define UMP_UART_LSR_OV_MASK		0x01
+#define UMP_UART_LSR_PE_MASK		0x02
+#define UMP_UART_LSR_FE_MASK		0x04
+#define UMP_UART_LSR_BR_MASK		0x08
+#define UMP_UART_LSR_ER_MASK		0x0F
+#define UMP_UART_LSR_RX_MASK		0x10
+#define UMP_UART_LSR_TX_MASK		0x20
+
+#define UMP_UART_LSR_DATA_MASK		( LSR_PAR_ERR | LSR_FRM_ERR | LSR_BREAK )
+
+/* Port Settings Constants) */
+#define UMP_MASK_UART_FLAGS_RTS_FLOW		0x0001
+#define UMP_MASK_UART_FLAGS_RTS_DISABLE		0x0002
+#define UMP_MASK_UART_FLAGS_PARITY		0x0008
+#define UMP_MASK_UART_FLAGS_OUT_X_DSR_FLOW	0x0010
+#define UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW	0x0020
+#define UMP_MASK_UART_FLAGS_OUT_X		0x0040
+#define UMP_MASK_UART_FLAGS_OUT_XA		0x0080
+#define UMP_MASK_UART_FLAGS_IN_X		0x0100
+#define UMP_MASK_UART_FLAGS_DTR_FLOW		0x0800
+#define UMP_MASK_UART_FLAGS_DTR_DISABLE		0x1000
+#define UMP_MASK_UART_FLAGS_RECEIVE_MS_INT	0x2000
+#define UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR	0x4000
+
+#define UMP_DMA_MODE_CONTINOUS			0x01
+#define UMP_PIPE_TRANS_TIMEOUT_ENA		0x80
+#define UMP_PIPE_TRANSFER_MODE_MASK		0x03
+#define UMP_PIPE_TRANS_TIMEOUT_MASK		0x7C
+
+/* Purge port Direction Mask Bits */
+#define UMP_PORT_DIR_OUT			0x01
+#define UMP_PORT_DIR_IN				0x02
+
+// Address of Port 0
+#define UMPM_UART1_PORT  			0x03
+
+// Commands
+#define	UMPC_SET_CONFIG 		0x05
+#define	UMPC_OPEN_PORT  		0x06
+#define	UMPC_CLOSE_PORT 		0x07
+#define	UMPC_START_PORT 		0x08
+#define	UMPC_STOP_PORT  		0x09
+#define	UMPC_TEST_PORT  		0x0A
+#define	UMPC_PURGE_PORT 		0x0B
+
+#define	UMPC_COMPLETE_READ		0x80	// Force the Firmware to complete the current Read
+#define	UMPC_HARDWARE_RESET		0x81	// Force UMP back into BOOT Mode
+#define	UMPC_COPY_DNLD_TO_I2C		0x82	// Copy current download image to type 0xf2 record in 16k I2C
+						// firmware will change 0xff record to type 2 record when complete
+
+	// Special function register commands
+	// wIndex is register address
+	// wValue is MSB/LSB mask/data
+#define	UMPC_WRITE_SFR	  		0x83	// Write SFR Register
+
+	// wIndex is register address
+#define	UMPC_READ_SFR	  		0x84	// Read SRF Register
+
+	// Set or Clear DTR (wValue bit 0 Set/Clear)		wIndex ModuleID (port)
+#define	UMPC_SET_CLR_DTR		0x85
+
+	// Set or Clear RTS (wValue bit 0 Set/Clear)		wIndex ModuleID (port)
+#define	UMPC_SET_CLR_RTS		0x86
+
+	// Set or Clear LOOPBACK (wValue bit 0 Set/Clear)	wIndex ModuleID (port)
+#define	UMPC_SET_CLR_LOOPBACK		0x87
+
+	// Set or Clear BREAK (wValue bit 0 Set/Clear)		wIndex ModuleID (port)
+#define	UMPC_SET_CLR_BREAK		0x88
+
+	// Read MSR wIndex ModuleID (port)
+#define	UMPC_READ_MSR			0x89
+
+	/* Toolkit commands */
+	/* Read-write group */
+#define	UMPC_MEMORY_READ   		0x92
+#define	UMPC_MEMORY_WRITE  		0x93
+
+/*
+ *	UMP DMA Definitions
+ */
+#define UMPD_OEDB1_ADDRESS		0xFF08
+#define UMPD_OEDB2_ADDRESS		0xFF10
+
+struct out_endpoint_desc_block
+{
+	__u8 Configuration;
+	__u8 XBufAddr;
+	__u8 XByteCount;
+	__u8 Unused1;
+	__u8 Unused2;
+	__u8 YBufAddr;
+	__u8 YByteCount;
+	__u8 BufferSize;
+} __attribute__((packed));
+
+
+/*
+ * TYPE DEFINITIONS
+ * Structures for Firmware commands
+ */
+struct ump_uart_config		/* UART settings                    */
+{
+	__u16 wBaudRate;	/* Baud rate                        */
+	__u16 wFlags;		/* Bitmap mask of flags             */
+	__u8 bDataBits;		/* 5..8 - data bits per character   */
+	__u8 bParity;		/* Parity settings                  */
+	__u8 bStopBits;		/* Stop bits settings               */
+	char cXon;		/* XON character                    */
+	char cXoff;		/* XOFF character                   */
+	__u8 bUartMode;		/* Will be updated when a user      */
+				/* interface is defined             */
+} __attribute__((packed));
+
+
+/*
+ * TYPE DEFINITIONS
+ * Structures for USB interrupts
+ */
+struct ump_interrupt			/* Interrupt packet structure       */
+{
+	__u8 bICode;			/* Interrupt code (interrupt num)   */
+	__u8 bIInfo;			/* Interrupt information            */
+}  __attribute__((packed));
+
+
+#define TIUMP_GET_PORT_FROM_CODE(c)	(((c) >> 4) - 3)
+#define TIUMP_GET_FUNC_FROM_CODE(c)	((c) & 0x0f)
+#define TIUMP_INTERRUPT_CODE_LSR	0x03
+#define TIUMP_INTERRUPT_CODE_MSR	0x04
+
+#endif
diff -Nur linux-2.4.19.old/drivers/usb/serial/io_usbvend.h linux-2.4.19/drivers/usb/serial/io_usbvend.h
--- linux-2.4.19.old/drivers/usb/serial/io_usbvend.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/io_usbvend.h	Mon Nov 25 12:27:08 2002
@@ -106,11 +106,23 @@
 #define ION_DEVICE_ID_BB_EDGEPORT_4_DIN		0x011	// Edgeport/4 RS232 with Apple DIN connector
 #define ION_DEVICE_ID_BB_EDGEPORT_16_DUAL_CPU	0x012	// Half of an Edgeport/16 (the kind with 2 EP/8s)
 #define ION_DEVICE_ID_BB_EDGEPORT_8I		0x014	// Edgeport/8 RS422 (single-CPU)
-// These IDs are used by the Edgeport.exe program for uninstalling.
-// 
-#define EDGEPORT_DEVICE_IDS	{0x001, 0x003, 0x004, 0x005, 0x006, 0x007, 0x00B, \
-				 0x00C, 0x00D, 0x00E, 0x00F, 0x010, 0x011, 0x012, \
-				 0x013, 0x014 }
+
+
+/* Edgeport TI based devices */
+#define ION_DEVICE_ID_TI_EDGEPORT_4		0x0201	/* Edgeport/4 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_2		0x0205	/* Edgeport/2 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_4I		0x0206	/* Edgeport/4i RS422 */
+#define ION_DEVICE_ID_TI_EDGEPORT_2I		0x0207	/* Edgeport/2i RS422/RS485 */
+#define ION_DEVICE_ID_TI_EDGEPORT_421		0x020C	/* Edgeport/421 4 hub 2 RS232 + Parallel (lucent on a different hub port) */
+#define ION_DEVICE_ID_TI_EDGEPORT_21		0x020D	/* Edgeport/21 2 RS232 + Parallel (lucent on a different hub port) */
+#define ION_DEVICE_ID_TI_EDGEPORT_1		0x0215	/* Edgeport/1 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_42		0x0217	/* Edgeport/42 4 hub 2 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_22		0x021A	/* Edgeport/22  Edgeport/22I is an Edgeport/4 with ports 1&2 RS422 and ports 3&4 RS232 */
+
+#define ION_DEVICE_ID_TI_EDGEPORT_421_BOOT	0x0240	/* Edgeport/421 in boot mode */
+#define ION_DEVICE_ID_TI_EDGEPORT_421_DOWN	0x0241	/* Edgeport/421 in download mode first interface is 2 RS232 (Note that the second interface of this multi interface device should be a standard USB class 7 printer port) */
+#define ION_DEVICE_ID_TI_EDGEPORT_21_BOOT	0x0242	/* Edgeport/21 in boot mode */
+#define ION_DEVICE_ID_TI_EDGEPORT_21_DOWN	0x0243	/*Edgeport/42 in download mode: first interface is 2 RS232 (Note that the second interface of this multi interface device should be a standard USB class 7 printer port) */
 
 
 #define	MAKE_USB_PRODUCT_ID( OemId, DeviceId )					\
@@ -196,11 +208,11 @@
 // Version 2 format of DeviceParams. This format is longer (3C0h)
 // and starts lower in memory, at the uppermost 1K in ROM.
 #define	EDGE_MANUF_DESC_ADDR		0x00FF7C00
-#define	EDGE_MANUF_DESC_LEN		sizeof(EDGE_MANUF_DESCRIPTOR)
+#define	EDGE_MANUF_DESC_LEN		sizeof(struct edge_manuf_descriptor)
 
 // Boot params descriptor
 #define	EDGE_BOOT_DESC_ADDR		0x00FF7FC0
-#define	EDGE_BOOT_DESC_LEN		sizeof(EDGE_BOOT_DESCRIPTOR)
+#define	EDGE_BOOT_DESC_LEN		sizeof(struct edge_boot_descriptor)
 
 // Define the max block size that may be read or written
 // in a read/write RAM/ROM command.
@@ -217,7 +229,7 @@
 //		descriptor format, so that they may be separately retrieved,
 //		if necessary, with a minimum of work on the 930. This also
 //		requires them to be in UNICODE format, which, for English at
-//		least, simply means extending each UCHAR into a USHORT.
+//		least, simply means extending each __u8 into a __u16.
 //	3.	For all fields, 00 means 'uninitialized'.
 //	4.	All unused areas should be set to 00 for future expansion.
 //
@@ -241,7 +253,7 @@
 #define MAX_SERIALNUMBER_LEN	12
 #define MAX_ASSEMBLYNUMBER_LEN	14
 
-typedef struct _EDGE_MANUF_DESCRIPTOR {
+struct edge_manuf_descriptor {
 
 	__u16	RootDescTable[0x10];			// C00 Root of descriptor tables (just a placeholder)
 	__u8	DescriptorArea[0x2E0];			// C20 Descriptors go here, up to 2E0h (just a placeholder)
@@ -286,7 +298,7 @@
 	__u8	IonConfig;				// FBF Config byte for ION manufacturing use
 							// FBF end of structure, total len = 3C0h
 
-} EDGE_MANUF_DESCRIPTOR, *PEDGE_MANUF_DESCRIPTOR;
+};
 
 
 #define MANUF_DESC_VER_1	1	// Original definition of MANUF_DESC
@@ -331,10 +343,10 @@
 
 
 
-#define	MANUF_SERNUM_LENGTH		sizeof(((PEDGE_MANUF_DESCRIPTOR)0)->SerialNumber)
-#define	MANUF_ASSYNUM_LENGTH		sizeof(((PEDGE_MANUF_DESCRIPTOR)0)->AssemblyNumber)
-#define	MANUF_OEMASSYNUM_LENGTH		sizeof(((PEDGE_MANUF_DESCRIPTOR)0)->OemAssyNumber)
-#define	MANUF_MANUFDATE_LENGTH		sizeof(((PEDGE_MANUF_DESCRIPTOR)0)->ManufDate)
+#define	MANUF_SERNUM_LENGTH		sizeof(((struct edge_manuf_descriptor *)0)->SerialNumber)
+#define	MANUF_ASSYNUM_LENGTH		sizeof(((struct edge_manuf_descriptor *)0)->AssemblyNumber)
+#define	MANUF_OEMASSYNUM_LENGTH		sizeof(((struct edge_manuf_descriptor *)0)->OemAssyNumber)
+#define	MANUF_MANUFDATE_LENGTH		sizeof(((struct edge_manuf_descriptor *)0)->ManufDate)
 
 #define	MANUF_ION_CONFIG_MASTER		0x80	// 1=Master mode, 0=Normal
 #define	MANUF_ION_CONFIG_DIAG		0x40	// 1=Run h/w diags, 0=norm
@@ -349,7 +361,7 @@
 // - FF:xFFF. Note that the 930-mandated UCONFIG bytes are
 // included in this structure.
 //
-typedef struct _EDGE_BOOT_DESCRIPTOR {
+struct edge_boot_descriptor {
 	__u8		Length;			// C0 Desc length, per USB (= 40h)
 	__u8		DescType;		// C1 Desc type, per USB (= DEVICE type)
 	__u8		DescVer;		// C2 Desc version/format
@@ -373,8 +385,7 @@
 	__u8		UConfig1;		// F9 930-defined CPU configuration byte 1
 	__u8		Reserved3[6];		// FA -- unused, set to 0 --
 						// FF end of structure, total len = 80
-
-} EDGE_BOOT_DESCRIPTOR, *PEDGE_BOOT_DESCRIPTOR;
+};
 
 
 #define BOOT_DESC_VER_1		1	// Original definition of BOOT_PARAMS
@@ -385,5 +396,92 @@
 
 #define	BOOT_CAP_RESET_CMD	0x0001	// If set, boot correctly supports ION_RESET_DEVICE
 
-#endif	// if !defined()
 
+
+/************************************************************************
+                 T I   U M P   D E F I N I T I O N S
+ ***********************************************************************/
+
+//************************************************************************
+//	TI I2C Format Definitions
+//************************************************************************
+#define I2C_DESC_TYPE_INFO_BASIC	1
+#define I2C_DESC_TYPE_FIRMWARE_BASIC	2
+#define I2C_DESC_TYPE_DEVICE		3
+#define I2C_DESC_TYPE_CONFIG		4
+#define I2C_DESC_TYPE_STRING		5
+#define I2C_DESC_TYPE_FIRMWARE_BLANK 	0xf2
+
+#define I2C_DESC_TYPE_MAX		5
+// 3410 may define types 6, 7 for other firmware downloads
+
+// Special section defined by ION
+#define I2C_DESC_TYPE_ION		0	// Not defined by TI
+
+
+struct ti_i2c_desc
+{
+	__u8	Type;			// Type of descriptor
+	__u16	Size;			// Size of data only not including header
+	__u8	CheckSum;		// Checksum (8 bit sum of data only)
+	__u8	Data[0];		// Data starts here
+}__attribute__((packed));
+
+struct ti_i2c_firmware_rec 
+{
+	__u8	Ver_Major;		// Firmware Major version number
+	__u8	Ver_Minor;		// Firmware Minor version number
+	__u8	Data[0];		// Download starts here
+}__attribute__((packed));
+
+
+// Structure of header of download image in fw_down.h
+struct ti_i2c_image_header
+{
+	__u16	Length;
+	__u8	CheckSum;
+}__attribute__((packed));
+
+struct ti_basic_descriptor
+{
+	__u8	Power;		// Self powered
+				// bit 7: 1 - power switching supported
+				//        0 - power switching not supported
+				//
+				// bit 0: 1 - self powered
+				//        0 - bus powered
+				//
+				//
+	__u16	HubVid;		// VID HUB
+	__u16	HubPid;		// PID HUB
+	__u16	DevPid;		// PID Edgeport
+	__u8	HubTime;	// Time for power on to power good
+	__u8	HubCurrent;	// HUB Current = 100ma
+} __attribute__((packed));
+
+
+#define TI_GET_CPU_REVISION(x)		(__u8)((((x)>>4)&0x0f))
+#define TI_GET_BOARD_REVISION(x)	(__u8)(((x)&0x0f))
+
+#define TI_I2C_SIZE_MASK		0x1f  // 5 bits
+#define TI_GET_I2C_SIZE(x)		((((x) & TI_I2C_SIZE_MASK)+1)*256)
+
+#define TI_MAX_I2C_SIZE			( 16 * 1024 )
+
+/* TI USB 5052 definitions */
+struct edge_ti_manuf_descriptor
+{
+	__u8 IonConfig;		//  Config byte for ION manufacturing use
+	__u8 IonConfig2;	//  Expansion
+	__u8 Version;		//  Verqsion
+	__u8 CpuRev_BoardRev;	//  CPU revision level (0xF0) and Board Rev Level (0x0F)
+	__u8 NumPorts;		//  Number of ports	for this UMP
+	__u8 NumVirtualPorts;	//  Number of Virtual ports
+	__u8 HubConfig1;	//  Used to configure the Hub
+	__u8 HubConfig2;	//  Used to configure the Hub
+	__u8 TotalPorts;	//  Total Number of Com Ports for the entire device (All UMPs)
+	__u8 Reserved;
+}__attribute__((packed));
+
+
+#endif		// if !defined()
diff -Nur linux-2.4.19.old/drivers/usb/serial/ipaq.c linux-2.4.19/drivers/usb/serial/ipaq.c
--- linux-2.4.19.old/drivers/usb/serial/ipaq.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/ipaq.c	Mon Nov 25 12:27:08 2002
@@ -9,6 +9,10 @@
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
  *
+ * (26/7/2002) ganesh
+ * 	Fixed up broken error handling in ipaq_open. Retry the "kickstart"
+ * 	packet much harder - this drastically reduces connection failures.
+ *
  * (30/4/2002) ganesh
  * 	Added support for the Casio EM500. Completely untested. Thanks
  * 	to info from Nathan <wfilardo@fuse.net>
@@ -34,18 +38,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -57,6 +58,8 @@
 #include "usb-serial.h"
 #include "ipaq.h"
 
+#define KP_RETRIES	100
+
 /*
  * Version Information
  */
@@ -81,7 +84,7 @@
 static void ipaq_destroy_lists(struct usb_serial_port *port);
 
 
-static __devinitdata struct usb_device_id ipaq_id_table [] = {
+static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(COMPAQ_VENDOR_ID, COMPAQ_IPAQ_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_JORNADA_548_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_JORNADA_568_ID) },
@@ -93,24 +96,22 @@
 
 /* All of the device info needed for the Compaq iPAQ */
 struct usb_serial_device_type ipaq_device = {
-	name:			"Compaq iPAQ",
-	id_table:		ipaq_id_table,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			ipaq_open,
-	close:			ipaq_close,
-	startup:		ipaq_startup,
-	shutdown:		ipaq_shutdown,
-	write:			ipaq_write,
-	write_room:		ipaq_write_room,
-	chars_in_buffer:	ipaq_chars_in_buffer,
-	read_bulk_callback:	ipaq_read_bulk_callback,
-	write_bulk_callback:	ipaq_write_bulk_callback,
+	.owner =		THIS_MODULE,
+	.name =			"Compaq iPAQ",
+	.id_table =		ipaq_id_table,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			ipaq_open,
+	.close =		ipaq_close,
+	.startup =		ipaq_startup,
+	.shutdown =		ipaq_shutdown,
+	.write =		ipaq_write,
+	.write_room =		ipaq_write_room,
+	.chars_in_buffer =	ipaq_chars_in_buffer,
+	.read_bulk_callback =	ipaq_read_bulk_callback,
+	.write_bulk_callback =	ipaq_write_bulk_callback,
 };
 
 static spinlock_t	write_list_lock;
@@ -123,115 +124,110 @@
 	struct ipaq_private	*priv;
 	struct ipaq_packet	*pkt;
 	int			i, result = 0;
+	int			retries = KP_RETRIES;
 
 	if (port_paranoia_check(port, __FUNCTION__)) {
 		return -ENODEV;
 	}
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down(&port->sem);
-	
-	++port->open_count;
-	MOD_INC_USE_COUNT;
-	
-	if (!port->active) {
-		port->active = 1;
-		bytes_in = 0;
-		bytes_out = 0;
-		priv = (struct ipaq_private *)kmalloc(sizeof(struct ipaq_private), GFP_KERNEL);
-		if (priv == NULL) {
-			err(__FUNCTION__ " - Out of memory");
-			return -ENOMEM;
-		}
-		port->private = (void *)priv;
-		priv->active = 0;
-		priv->queue_len = 0;
-		INIT_LIST_HEAD(&priv->queue);
-		INIT_LIST_HEAD(&priv->freelist);
-
-		for (i = 0; i < URBDATA_QUEUE_MAX / PACKET_SIZE; i++) {
-			pkt = kmalloc(sizeof(struct ipaq_packet), GFP_KERNEL);
-			if (pkt == NULL) {
-				goto enomem;
-			}
-			pkt->data = kmalloc(PACKET_SIZE, GFP_KERNEL);
-			if (pkt->data == NULL) {
-				kfree(pkt);
-				goto enomem;
-			}
-			pkt->len = 0;
-			pkt->written = 0;
-			INIT_LIST_HEAD(&pkt->list);
-			list_add(&pkt->list, &priv->freelist);
-			priv->free_len += PACKET_SIZE;
-		}
-
-		/*
-		 * Force low latency on. This will immediately push data to the line
-		 * discipline instead of queueing.
-		 */
-
-		port->tty->low_latency = 1;
-		port->tty->raw = 1;
-		port->tty->real_raw = 1;
-
-		/*
-		 * Lose the small buffers usbserial provides. Make larger ones.
-		 */
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-		kfree(port->bulk_in_buffer);
-		kfree(port->bulk_out_buffer);
-		port->bulk_in_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
-		if (port->bulk_in_buffer == NULL) {
+	bytes_in = 0;
+	bytes_out = 0;
+	priv = (struct ipaq_private *)kmalloc(sizeof(struct ipaq_private), GFP_KERNEL);
+	if (priv == NULL) {
+		err("%s - Out of memory", __FUNCTION__);
+		return -ENOMEM;
+	}
+	port->private = (void *)priv;
+	priv->active = 0;
+	priv->queue_len = 0;
+	INIT_LIST_HEAD(&priv->queue);
+	INIT_LIST_HEAD(&priv->freelist);
+
+	for (i = 0; i < URBDATA_QUEUE_MAX / PACKET_SIZE; i++) {
+		pkt = kmalloc(sizeof(struct ipaq_packet), GFP_KERNEL);
+		if (pkt == NULL) {
 			goto enomem;
 		}
-		port->bulk_out_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
-		if (port->bulk_out_buffer == NULL) {
-			kfree(port->bulk_in_buffer);
+		pkt->data = kmalloc(PACKET_SIZE, GFP_KERNEL);
+		if (pkt->data == NULL) {
+			kfree(pkt);
 			goto enomem;
 		}
-		port->read_urb->transfer_buffer = port->bulk_in_buffer;
-		port->write_urb->transfer_buffer = port->bulk_out_buffer;
-		port->read_urb->transfer_buffer_length = URBDATA_SIZE;
-		port->bulk_out_size = port->write_urb->transfer_buffer_length = URBDATA_SIZE;
-		
-		/* Start reading from the device */
-		FILL_BULK_URB(port->read_urb, serial->dev, 
-			      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-			      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-			      ipaq_read_bulk_callback, port);
-		result = usb_submit_urb(port->read_urb);
-		if (result) {
-			err(__FUNCTION__ " - failed submitting read urb, error %d", result);
-		}
-
-		/*
-		 * Send out two control messages observed in win98 sniffs. Not sure what
-		 * they do.
-		 */
-
-		result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
-				0x1, 0, NULL, 0, 5 * HZ);
-		if (result < 0) {
-			err(__FUNCTION__ " - failed doing control urb, error %d", result);
-		}
-		result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
-				0x1, 0, NULL, 0, 5 * HZ);
-		if (result < 0) {
-			err(__FUNCTION__ " - failed doing control urb, error %d", result);
-		}
+		pkt->len = 0;
+		pkt->written = 0;
+		INIT_LIST_HEAD(&pkt->list);
+		list_add(&pkt->list, &priv->freelist);
+		priv->free_len += PACKET_SIZE;
+	}
+
+	/*
+	 * Force low latency on. This will immediately push data to the line
+	 * discipline instead of queueing.
+	 */
+
+	port->tty->low_latency = 1;
+	port->tty->raw = 1;
+	port->tty->real_raw = 1;
+
+	/*
+	 * Lose the small buffers usbserial provides. Make larger ones.
+	 */
+
+	kfree(port->bulk_in_buffer);
+	kfree(port->bulk_out_buffer);
+	port->bulk_in_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
+	if (port->bulk_in_buffer == NULL) {
+		goto enomem;
 	}
+	port->bulk_out_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
+	if (port->bulk_out_buffer == NULL) {
+		kfree(port->bulk_in_buffer);
+		goto enomem;
+	}
+	port->read_urb->transfer_buffer = port->bulk_in_buffer;
+	port->write_urb->transfer_buffer = port->bulk_out_buffer;
+	port->read_urb->transfer_buffer_length = URBDATA_SIZE;
+	port->bulk_out_size = port->write_urb->transfer_buffer_length = URBDATA_SIZE;
 	
-	up(&port->sem);
-	
-	return result;
+	/* Start reading from the device */
+	FILL_BULK_URB(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
+		      ipaq_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb);
+	if (result) {
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+		goto error;
+	}
+
+	/*
+	 * Send out control message observed in win98 sniffs. Not sure what
+	 * it does, but from empirical observations, it seems that the device
+	 * will start the chat sequence once one of these messages gets
+	 * through. Since this has a reasonably high failure rate, we retry
+	 * several times.
+	 */
+
+	while (retries--) {
+		result = usb_control_msg(serial->dev,
+				usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
+				0x1, 0, NULL, 0, HZ / 10 + 1);
+		if (result == 0) {
+			return 0;
+		}
+	}
+	err("%s - failed doing control urb, error %d", __FUNCTION__, result);
+	goto error;
 
 enomem:
+	result = -ENOMEM;
+	err("%s - Out of memory", __FUNCTION__);
+error:
 	ipaq_destroy_lists(port);
 	kfree(priv);
-	err(__FUNCTION__ " - Out of memory");
-	return -ENOMEM;
+	return result;
 }
 
 
@@ -244,37 +240,24 @@
 		return; 
 	}
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 			 
 	serial = get_usb_serial(port, __FUNCTION__);
 	if (!serial)
 		return;
-	
-	down (&port->sem);
-
-	--port->open_count;
 
-	if (port->open_count <= 0) {
+	/*
+	 * shut down bulk read and write
+	 */
 
-		/*
-		 * shut down bulk read and write
-		 */
-
-		usb_unlink_urb(port->write_urb);
-		usb_unlink_urb(port->read_urb);
-		ipaq_destroy_lists(port);
-		kfree(priv);
-		port->private = NULL;
-		port->active = 0;
-		port->open_count = 0;
-
-	}
-	up (&port->sem);
+	usb_unlink_urb(port->write_urb);
+	usb_unlink_urb(port->read_urb);
+	ipaq_destroy_lists(port);
+	kfree(priv);
+	port->private = NULL;
 
 	/* Uncomment the following line if you want to see some statistics in your syslog */
 	/* info ("Bytes In = %d  Bytes Out = %d", bytes_in, bytes_out); */
-
-	MOD_DEC_USE_COUNT;
 }
 
 static void ipaq_read_bulk_callback(struct urb *urb)
@@ -288,15 +271,15 @@
 	if (port_paranoia_check(port, __FUNCTION__))
 		return;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -323,7 +306,7 @@
 		      ipaq_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb);
 	if (result)
-		err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 	return;
 }
 
@@ -334,7 +317,7 @@
 	int			bytes_sent = 0;
 	int			transfer_size;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	usb_serial_debug_data(__FILE__, __FUNCTION__, count, buf);
 	
@@ -361,7 +344,7 @@
 	unsigned long		flags;
 
 	if (priv->free_len <= 0) {
-		dbg(__FUNCTION__ " - we're stuffed");
+		dbg("%s - we're stuffed", __FUNCTION__);
 		return -EAGAIN;
 	}
 
@@ -373,12 +356,13 @@
 	}
 	spin_unlock_irqrestore(&write_list_lock, flags);
 	if (pkt == NULL) {
-		dbg(__FUNCTION__ " - we're stuffed");
+		dbg("%s - we're stuffed", __FUNCTION__);
 		return -EAGAIN;
 	}
 
 	if (from_user) {
-		copy_from_user(pkt->data, buf, count);
+		if (copy_from_user(pkt->data, buf, count))
+			return -EFAULT;
 	} else {
 		memcpy(pkt->data, buf, count);
 	}
@@ -395,7 +379,7 @@
 		spin_unlock_irqrestore(&write_list_lock, flags);
 		result = usb_submit_urb(port->write_urb);
 		if (result) {
-			err(__FUNCTION__ " - failed submitting write urb, error %d", result);
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 		}
 	} else {
 		spin_unlock_irqrestore(&write_list_lock, flags);
@@ -414,7 +398,7 @@
 
 	if (urb->status == -EINPROGRESS) {
 		/* Should never happen */
-		err(__FUNCTION__ " - flushing while urb is active !");
+		err("%s - flushing while urb is active !", __FUNCTION__);
 		return;
 	}
 	room = URBDATA_SIZE;
@@ -456,10 +440,10 @@
 		return;
 	}
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 	}
 
 	spin_lock_irqsave(&write_list_lock, flags);
@@ -468,7 +452,7 @@
 		spin_unlock_irqrestore(&write_list_lock, flags);
 		result = usb_submit_urb(port->write_urb);
 		if (result) {
-			err(__FUNCTION__ " - failed submitting write urb, error %d", result);
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 		}
 	} else {
 		priv->active = 0;
@@ -484,7 +468,7 @@
 {
 	struct ipaq_private	*priv = (struct ipaq_private *)port->private;
 
-	dbg(__FUNCTION__ " - freelen %d", priv->free_len);
+	dbg("%s - freelen %d", __FUNCTION__, priv->free_len);
 	return priv->free_len;
 }
 
@@ -492,7 +476,7 @@
 {
 	struct ipaq_private	*priv = (struct ipaq_private *)port->private;
 
-	dbg(__FUNCTION__ " - queuelen %d", priv->queue_len);
+	dbg("%s - queuelen %d", __FUNCTION__, priv->queue_len);
 	return priv->queue_len;
 }
 
@@ -520,23 +504,14 @@
 
 static int ipaq_startup(struct usb_serial *serial)
 {
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 	usb_set_configuration(serial->dev, 1);
 	return 0;
 }
 
 static void ipaq_shutdown(struct usb_serial *serial)
 {
-	int i;
-
-	dbg (__FUNCTION__);
-
-	/* stop reads and writes on all ports */
-	for (i=0; i < serial->num_ports; ++i) {
-		while (serial->port[i].open_count > 0) {
-			ipaq_close(&serial->port[i], NULL);
-		}
-	}
+	dbg("%s", __FUNCTION__);
 }
 
 static int __init ipaq_init(void)
diff -Nur linux-2.4.19.old/drivers/usb/serial/ipaq.h linux-2.4.19/drivers/usb/serial/ipaq.h
--- linux-2.4.19.old/drivers/usb/serial/ipaq.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/ipaq.h	Mon Nov 25 12:27:08 2002
@@ -19,7 +19,7 @@
 #define COMPAQ_VENDOR_ID	0x049f
 #define COMPAQ_IPAQ_ID		0x0003
 
-#define HP_VENDOR_ID		0x003f
+#define HP_VENDOR_ID		0x03f0
 #define HP_JORNADA_548_ID	0x1016
 #define HP_JORNADA_568_ID	0x1116
 
diff -Nur linux-2.4.19.old/drivers/usb/serial/ir-usb.c linux-2.4.19/drivers/usb/serial/ir-usb.c
--- linux-2.4.19.old/drivers/usb/serial/ir-usb.c	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/serial/ir-usb.c	Mon Nov 25 12:27:08 2002
@@ -1,8 +1,8 @@
 /*
  * USB IR Dongle driver
  *
- *	Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)
- *	Copyright (C) 2002 Gary Brubaker (xavyer@ix.netcom.com)
+ *	Copyright (C) 2001-2002	Greg Kroah-Hartman (greg@kroah.com)
+ *	Copyright (C) 2002	Gary Brubaker (xavyer@ix.netcom.com)
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -21,6 +21,11 @@
  *
  * See Documentation/usb/usb-serial.txt for more information on using this driver
  *
+ * 2002_Mar_07	greg kh
+ *	moved some needed structures and #define values from the
+ *	net/irda/irda-usb.h file into our file, as we don't want to depend on
+ *	that codebase compiling correctly :)
+ *
  * 2002_Jan_14  gb
  *	Added module parameter to force specific number of XBOFs.
  *	Added ir_xbof_change().
@@ -43,20 +48,16 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
-#include <net/irda/irda-usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
 	static int debug = 1;
@@ -73,6 +74,33 @@
 #define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>"
 #define DRIVER_DESC "USB IR Dongle driver"
 
+/* USB IrDA class spec information */
+#define USB_CLASS_IRDA		0x02
+#define USB_DT_IRDA		0x21
+#define IU_REQ_GET_CLASS_DESC	0x06
+#define SPEED_2400		0x01
+#define SPEED_9600		0x02
+#define SPEED_19200		0x03
+#define SPEED_38400		0x04
+#define SPEED_57600		0x05
+#define SPEED_115200		0x06
+#define SPEED_576000		0x07
+#define SPEED_1152000		0x08
+#define SPEED_4000000		0x09
+
+struct irda_class_desc {
+	u8	bLength;
+	u8	bDescriptorType;
+	u16	bcdSpecRevision;
+	u8	bmDataSize;
+	u8	bmWindowSize;
+	u8	bmMinTurnaroundTime;
+	u16	wBaudRate;
+	u8	bmAdditionalBOFs;
+	u8	bIrdaRateSniff;
+	u8	bMaxUnicastList;
+} __attribute__ ((packed));
+
 /* if overridden by the user, then use their value for the size of the read and
  * write urbs */
 static int buffer_size = 0;
@@ -91,7 +119,7 @@
 static u8 ir_xbof = 0;
 static u8 ir_add_bof = 0;
 
-static __devinitdata struct usb_device_id id_table [] = {
+static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(0x050f, 0x0180) },		/* KC Technology, KC-180 */
 	{ USB_DEVICE(0x08e9, 0x0100) },		/* XTNDAccess */
 	{ USB_DEVICE(0x09c4, 0x0011) },		/* ACTiSys ACT-IR2000U */
@@ -103,22 +131,20 @@
 
 
 struct usb_serial_device_type ir_device = {
-	name:			"IR Dongle",
-	id_table:		id_table,
-	needs_interrupt_in:	MUST_HAVE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	1,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	set_termios:		ir_set_termios,
-	startup:		ir_startup,
-	open:			ir_open,
-	close:			ir_close,
-	write:			ir_write,
-	write_bulk_callback:	ir_write_bulk_callback,
-	read_bulk_callback:	ir_read_bulk_callback,
+	.owner =		THIS_MODULE,
+	.name =			"IR Dongle",
+	.id_table =		id_table,
+	.num_interrupt_in =	1,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.set_termios =		ir_set_termios,
+	.startup =		ir_startup,
+	.open =			ir_open,
+	.close =		ir_close,
+	.write =		ir_write,
+	.write_bulk_callback =	ir_write_bulk_callback,
+	.read_bulk_callback =	ir_read_bulk_callback,
 };
 
 static inline void irda_usb_dump_class_desc(struct irda_class_desc *desc)
@@ -160,7 +186,7 @@
 	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev,0),
 			IU_REQ_GET_CLASS_DESC,
 			USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
-			0, ifnum, desc, sizeof(*desc), MSECS_TO_JIFFIES(500));
+			0, ifnum, desc, sizeof(*desc), HZ);
 	
 	dbg("%s -  ret=%d", __FUNCTION__, ret);
 	if (ret < sizeof(*desc)) {
@@ -235,7 +261,7 @@
 		case 0x20: ir_add_bof =  2; break;
 		case 0x40: ir_add_bof =  1; break;
 		case 0x80: ir_add_bof =  0; break;
-		default:
+		default:;
 	}
 
 	kfree (irda_desc);
@@ -254,53 +280,42 @@
 	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	down (&port->sem);
-	
-	++port->open_count;
-	MOD_INC_USE_COUNT;
-	
-	if (!port->active) {
-		port->active = 1;
-
-		if (buffer_size) {
-			/* override the default buffer sizes */
-			buffer = kmalloc (buffer_size, GFP_KERNEL);
-			if (!buffer) {
-				err ("%s - out of memory.", __FUNCTION__);
-				return -ENOMEM;
-			}
-			kfree (port->read_urb->transfer_buffer);
-			port->read_urb->transfer_buffer = buffer;
-			port->read_urb->transfer_buffer_length = buffer_size;
-
-			buffer = kmalloc (buffer_size, GFP_KERNEL);
-			if (!buffer) {
-				err ("%s - out of memory.", __FUNCTION__);
-				return -ENOMEM;
-			}
-			kfree (port->write_urb->transfer_buffer);
-			port->write_urb->transfer_buffer = buffer;
-			port->write_urb->transfer_buffer_length = buffer_size;
-			port->bulk_out_size = buffer_size;
+	if (buffer_size) {
+		/* override the default buffer sizes */
+		buffer = kmalloc (buffer_size, GFP_KERNEL);
+		if (!buffer) {
+			err ("%s - out of memory.", __FUNCTION__);
+			return -ENOMEM;
 		}
-
-		/* Start reading from the device */
-		usb_fill_bulk_urb (
-			port->read_urb,
-			serial->dev, 
-			usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-			port->read_urb->transfer_buffer,
-			port->read_urb->transfer_buffer_length,
-			ir_read_bulk_callback,
-			port);
-		port->read_urb->transfer_flags = USB_QUEUE_BULK;
-		result = usb_submit_urb(port->read_urb);
-		if (result)
-			err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+		kfree (port->read_urb->transfer_buffer);
+		port->read_urb->transfer_buffer = buffer;
+		port->read_urb->transfer_buffer_length = buffer_size;
+
+		buffer = kmalloc (buffer_size, GFP_KERNEL);
+		if (!buffer) {
+			err ("%s - out of memory.", __FUNCTION__);
+			return -ENOMEM;
+		}
+		kfree (port->write_urb->transfer_buffer);
+		port->write_urb->transfer_buffer = buffer;
+		port->write_urb->transfer_buffer_length = buffer_size;
+		port->bulk_out_size = buffer_size;
 	}
-	
-	up (&port->sem);
-	
+
+	/* Start reading from the device */
+	usb_fill_bulk_urb (
+		port->read_urb,
+		serial->dev, 
+		usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+		port->read_urb->transfer_buffer,
+		port->read_urb->transfer_buffer_length,
+		ir_read_bulk_callback,
+		port);
+	port->read_urb->transfer_flags = USB_QUEUE_BULK;
+	result = usb_submit_urb(port->read_urb);
+	if (result)
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+
 	return result;
 }
 
@@ -317,21 +332,10 @@
 	if (!serial)
 		return;
 	
-	down (&port->sem);
-
-	--port->open_count;
-
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			/* shutdown our bulk read */
-			usb_unlink_urb (port->read_urb);
-		}
-		port->active = 0;
-		port->open_count = 0;
-
+	if (serial->dev) {
+		/* shutdown our bulk read */
+		usb_unlink_urb (port->read_urb);
 	}
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
 }
 
 static int ir_write (struct usb_serial_port *port, int from_user, const unsigned char *buf, int count)
@@ -442,7 +446,7 @@
 		return;
 	}
 
-	if (!port->active) {
+	if (!port->open_count) {
 		dbg("%s - port closed.", __FUNCTION__);
 		return;
 	}
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan.c linux-2.4.19/drivers/usb/serial/keyspan.c
--- linux-2.4.19.old/drivers/usb/serial/keyspan.c	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan.c	Mon Nov 25 12:27:08 2002
@@ -1,8 +1,8 @@
 /*
   Keyspan USB to Serial Converter driver
  
-  (C) Copyright (C) 2000-2001
-      Hugh Blemings <hugh@misc.nu>
+  (C) Copyright (C) 2000-2001	Hugh Blemings <hugh@blemings.org>
+  (C) Copyright (C) 2002	Greg Kroah-Hartman <greg@kroah.com>
    
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -28,6 +28,17 @@
 
   Change History
 
+    Wed Apr 25 12:00:00 PST 2002 (Keyspan)
+      Started with Hugh Blemings' code dated Jan 17, 2002.  All adapters
+      now supported (including QI and QW).  Modified port open, port
+      close, and send setup() logic to fix various data and endpoint
+      synchronization bugs and device LED status bugs.  Changed keyspan_
+      write_room() to accurately return transmit buffer availability.
+      Changed forwardingLength from 1 to 16 for all adapters.
+
+    Fri Oct 12 16:45:00 EST 2001
+      Preliminary USA-19QI and USA-28 support (both test OK for me, YMMV)
+
     Mon Oct  8 14:29:00 EST 2001 hugh
       Fixed bug that prevented mulitport devices operating correctly
       if they weren't the first unit attached.
@@ -65,19 +76,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
-#include <linux/usb.h>
+#include <asm/uaccess.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
 	static int debug = 1;
@@ -95,7 +102,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.1.1"
+#define DRIVER_VERSION "v1.1.3"
 #define DRIVER_AUTHOR "Hugh Blemings <hugh@misc.nu"
 #define DRIVER_DESC "Keyspan USB to Serial Converter Driver"
 
@@ -107,13 +114,13 @@
 	/* number of active ports */
 	atomic_t	active_count;
 
-	const keyspan_device_details	*device_details;
+	const struct keyspan_device_details	*device_details;
 
-	urb_t		*instat_urb;
+	struct urb	*instat_urb;
 	char		instat_buf[INSTAT_BUFLEN];
 
 	/* XXX this one probably will need a lock */
-	urb_t		*glocont_urb;
+	struct urb	*glocont_urb;
 	char		glocont_buf[GLOCONT_BUFLEN];
 };
 
@@ -125,21 +132,21 @@
 	/* Keep duplicate of device details in each port
 	   structure as well - simplifies some of the
 	   callback functions etc. */
-	const keyspan_device_details	*device_details;
+	const struct keyspan_device_details	*device_details;
 
 	/* Input endpoints and buffer for this port */
-	urb_t		*in_urbs[2];
+	struct urb	*in_urbs[2];
 	char		in_buffer[2][64];
 	/* Output endpoints and buffer for this port */
-	urb_t		*out_urbs[2];
+	struct urb	*out_urbs[2];
 	char		out_buffer[2][64];
 
 	/* Input ack endpoint */
-	urb_t		*inack_urb;
+	struct urb	*inack_urb;
 	char		inack_buffer[1];
 
 	/* Output control endpoint */
-	urb_t		*outcont_urb;
+	struct urb	*outcont_urb;
 	char		outcont_buffer[64];
 
 	/* Settings for the port */
@@ -167,34 +174,14 @@
 #include "keyspan_usa28msg.h"
 #include "keyspan_usa49msg.h"
 	
-/* If you don't get debugging output, uncomment the following
-   two lines to enable cheat. */
-#if 0
-  #undef 	dbg 
-  #define	dbg	printk 
-#endif
-
 
 /* Functions used by new usb-serial code. */
 static int __init keyspan_init (void)
 {
-	usb_serial_register (&keyspan_usa18x_pre_device);
-	usb_serial_register (&keyspan_usa19_pre_device);
-	usb_serial_register (&keyspan_usa19w_pre_device);
-	usb_serial_register (&keyspan_usa28_pre_device);
-	usb_serial_register (&keyspan_usa28x_pre_device);
-	usb_serial_register (&keyspan_usa28xa_pre_device);
-	usb_serial_register (&keyspan_usa28xb_pre_device);
-	usb_serial_register (&keyspan_usa49w_pre_device);
-
-	usb_serial_register (&keyspan_usa18x_device);
-	usb_serial_register (&keyspan_usa19_device);
-	usb_serial_register (&keyspan_usa19w_device);
-	usb_serial_register (&keyspan_usa28_device);
-	usb_serial_register (&keyspan_usa28x_device);
-	usb_serial_register (&keyspan_usa28xa_device);
-	/* We don't need a separate entry for the usa28xb as it appears as a 28x anyway */
-	usb_serial_register (&keyspan_usa49w_device);
+	usb_serial_register (&keyspan_pre_device);
+	usb_serial_register (&keyspan_1port_device);
+	usb_serial_register (&keyspan_2port_device);
+	usb_serial_register (&keyspan_4port_device);
 
 	info(DRIVER_VERSION ":" DRIVER_DESC);
 
@@ -203,23 +190,10 @@
 
 static void __exit keyspan_exit (void)
 {
-	usb_serial_deregister (&keyspan_usa18x_pre_device);
-	usb_serial_deregister (&keyspan_usa19_pre_device);
-	usb_serial_deregister (&keyspan_usa19w_pre_device);
-	usb_serial_deregister (&keyspan_usa28_pre_device);
-	usb_serial_deregister (&keyspan_usa28x_pre_device);
-	usb_serial_deregister (&keyspan_usa28xa_pre_device);
-	usb_serial_deregister (&keyspan_usa28xb_pre_device);
-	usb_serial_deregister (&keyspan_usa49w_pre_device);
-
-	usb_serial_deregister (&keyspan_usa18x_device);
-	usb_serial_deregister (&keyspan_usa19_device);
-	usb_serial_deregister (&keyspan_usa19w_device);
-	usb_serial_deregister (&keyspan_usa28_device);
-	usb_serial_deregister (&keyspan_usa28x_device);
-	usb_serial_deregister (&keyspan_usa28xa_device);
-	/* We don't need a separate entry for the usa28xb as it appears as a 28x anyway */
-	usb_serial_deregister (&keyspan_usa49w_device);
+	usb_serial_deregister (&keyspan_pre_device);
+	usb_serial_deregister (&keyspan_1port_device);
+	usb_serial_deregister (&keyspan_2port_device);
+	usb_serial_deregister (&keyspan_4port_device);
 }
 
 module_init(keyspan_init);
@@ -227,13 +201,13 @@
 
 static void keyspan_rx_throttle (struct usb_serial_port *port)
 {
-	dbg("keyspan_rx_throttle port %d\n", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 }
 
 
 static void keyspan_rx_unthrottle (struct usb_serial_port *port)
 {
-	dbg("keyspan_rx_unthrottle port %d\n", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 }
 
 
@@ -241,7 +215,7 @@
 {
 	struct keyspan_port_private 	*p_priv;
 
- 	dbg("keyspan_break_ctl\n");
+ 	dbg("%s", __FUNCTION__);
 
 	p_priv = (struct keyspan_port_private *)port->private;
 
@@ -257,16 +231,17 @@
 static void keyspan_set_termios (struct usb_serial_port *port, 
 				     struct termios *old_termios)
 {
-	int				baud_rate;
+	int				baud_rate, device_port;
 	struct keyspan_port_private 	*p_priv;
-	const keyspan_device_details	*d_details;
+	const struct keyspan_device_details	*d_details;
 	unsigned int 			cflag;
 
-	dbg(__FUNCTION__ ".\n"); 
+	dbg("%s", __FUNCTION__); 
 
 	p_priv = (struct keyspan_port_private *)(port->private);
 	d_details = p_priv->device_details;
 	cflag = port->tty->termios->c_cflag;
+	device_port = port->number - port->serial->minor;
 
 	/* Baud rate calculation takes baud rate as an integer
 	   so other rates can be generated if desired. */
@@ -274,7 +249,7 @@
 	/* If no match or invalid, don't change */		
 	if (baud_rate >= 0
 	    && d_details->calculate_baud_rate(baud_rate, d_details->baudclk,
-				NULL, NULL, NULL) == KEYSPAN_BAUD_RATE_OK) {
+				NULL, NULL, NULL, device_port) == KEYSPAN_BAUD_RATE_OK) {
 		/* FIXME - more to do here to ensure rate changes cleanly */
 		p_priv->baud = baud_rate;
 	}
@@ -337,19 +312,17 @@
 			 const unsigned char *buf, int count)
 {
 	struct keyspan_port_private 	*p_priv;
-	const keyspan_device_details	*d_details;
+	const struct keyspan_device_details	*d_details;
 	int				flip;
 	int 				left, todo;
-	urb_t 				*this_urb;
+	struct urb			*this_urb;
 	int 				err;
 
 	p_priv = (struct keyspan_port_private *)(port->private);
 	d_details = p_priv->device_details;
 
-#if 0
-	dbg(__FUNCTION__ " for port %d (%d chars [%x]), flip=%d\n",
-	    port->number, count, buf[0], p_priv->out_flip);
-#endif
+	dbg("%s - for port %d (%d chars [%x]), flip=%d",
+	    __FUNCTION__, port->number, count, buf[0], p_priv->out_flip);
 
 	for (left = count; left > 0; left -= todo) {
 		todo = left;
@@ -361,11 +334,11 @@
 		/* Check we have a valid urb/endpoint before we use it... */
 		if ((this_urb = p_priv->out_urbs[flip]) == 0) {
 			/* no bulk out, so return 0 bytes written */
-			dbg(__FUNCTION__ " no output urb :(\n");
+			dbg("%s - no output urb :(", __FUNCTION__);
 			return count;
 		}
 
-		dbg(__FUNCTION__ " endpoint %d\n", usb_pipeendpoint(this_urb->pipe));
+		dbg("%s - endpoint %d flip %d", __FUNCTION__, usb_pipeendpoint(this_urb->pipe), flip);
 
 		if (this_urb->status == -EINPROGRESS) {
 			if (this_urb->transfer_flags & USB_ASYNC_UNLINK)
@@ -395,7 +368,7 @@
 		this_urb->transfer_flags &= ~USB_ASYNC_UNLINK;
 		this_urb->dev = port->serial->dev;
 		if ((err = usb_submit_urb(this_urb)) != 0) {
-			dbg("usb_submit_urb(write bulk) failed (%d)\n", err);
+			dbg("usb_submit_urb(write bulk) failed (%d)", err);
 		}
 		p_priv->tx_start_time[flip] = jiffies;
 
@@ -415,26 +388,28 @@
 	struct tty_struct	*tty;
 	unsigned char 		*data = urb->transfer_buffer;
 
-	dbg ("%s\n", __FUNCTION__); 
+	dbg ("%s", __FUNCTION__); 
 
 	endpoint = usb_pipeendpoint(urb->pipe);
 
 	if (urb->status) {
-		dbg(__FUNCTION__ "nonzero status: %x on endpoint %d.\n",
-			      		urb->status, endpoint);
+		dbg("%s - nonzero status: %x on endpoint %d.",
+		    __FUNCTION__, urb->status, endpoint);
 		return;
 	}
 
 	port = (struct usb_serial_port *) urb->context;
 	tty = port->tty;
 	if (urb->actual_length) {
-		if (data[0] == 0) {
+		/* 0x80 bit is error flag */
+		if ((data[0] & 0x80) == 0) {
 			/* no error on any byte */
 			for (i = 1; i < urb->actual_length ; ++i) {
 				tty_insert_flip_char(tty, data[i], 0);
 			}
 		} else {
 			/* some bytes had errors, every byte has status */
+			dbg("%s - RX error!!!!", __FUNCTION__);
 			for (i = 0; i + 1 < urb->actual_length; i += 2) {
 				int stat = data[i], flag = 0;
 				if (stat & RXERROR_OVERRUN)
@@ -452,9 +427,10 @@
 				
 		/* Resubmit urb so we continue receiving */
 	urb->dev = port->serial->dev;
-	if ((err = usb_submit_urb(urb)) != 0) {
-		dbg(__FUNCTION__ "resubmit read urb failed. (%d)\n", err);
-	}
+	if (port->open_count)
+		if ((err = usb_submit_urb(urb)) != 0) {
+			dbg("%s - resubmit read urb failed. (%d)", __FUNCTION__, err);
+		}
 	return;
 }
 
@@ -466,9 +442,9 @@
 
 	port = (struct usb_serial_port *) urb->context;
 	p_priv = (struct keyspan_port_private *)(port->private);
-	dbg (__FUNCTION__ " urb %d\n", urb == p_priv->out_urbs[1]); 
+	dbg ("%s - urb %d", __FUNCTION__, urb == p_priv->out_urbs[1]); 
 
-	if (port->active) {
+	if (port->open_count) {
 		queue_task(&port->tqueue, &tq_immediate);
 		mark_bh(IMMEDIATE_BH);
 	}
@@ -476,7 +452,7 @@
 
 static void	usa26_inack_callback(struct urb *urb)
 {
-	dbg ("%s\n", __FUNCTION__); 
+	dbg ("%s", __FUNCTION__); 
 	
 }
 
@@ -489,15 +465,15 @@
 	p_priv = (struct keyspan_port_private *)(port->private);
 
 	if (p_priv->resend_cont) {
-		dbg (__FUNCTION__ " sending setup\n"); 
-		keyspan_usa26_send_setup(port->serial, port, 0);
+		dbg ("%s - sending setup", __FUNCTION__); 
+		keyspan_usa26_send_setup(port->serial, port, p_priv->resend_cont - 1);
 	}
 }
 
 static void	usa26_instat_callback(struct urb *urb)
 {
 	unsigned char 				*data = urb->transfer_buffer;
-	keyspan_usa26_portStatusMessage		*msg;
+	struct keyspan_usa26_portStatusMessage	*msg;
 	struct usb_serial			*serial;
 	struct usb_serial_port			*port;
 	struct keyspan_port_private	 	*p_priv;
@@ -506,19 +482,19 @@
 	serial = (struct usb_serial *) urb->context;
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " nonzero status: %x\n", urb->status);
+		dbg("%s - nonzero status: %x", __FUNCTION__, urb->status);
 		return;
 	}
 	if (urb->actual_length != 9) {
-		dbg(__FUNCTION__ " %d byte report??\n", urb->actual_length);
+		dbg("%s - %d byte report??", __FUNCTION__, urb->actual_length);
 		goto exit;
 	}
 
-	msg = (keyspan_usa26_portStatusMessage *)data;
+	msg = (struct keyspan_usa26_portStatusMessage *)data;
 
 #if 0
-	dbg(__FUNCTION__ " port status: port %d cts %d dcd %d dsr %d ri %d toff %d txoff %d rxen %d cr %d\n",
-	    msg->port, msg->hskia_cts, msg->gpia_dcd, msg->dsr, msg->ri, msg->_txOff,
+	dbg("%s - port status: port %d cts %d dcd %d dsr %d ri %d toff %d txoff %d rxen %d cr %d",
+	    __FUNCTION__, msg->port, msg->hskia_cts, msg->gpia_dcd, msg->dsr, msg->ri, msg->_txOff,
 	    msg->_txXoff, msg->rxEnabled, msg->controlResponse);
 #endif
 
@@ -527,7 +503,7 @@
 
 	/* Check port number from message and retrieve private data */	
 	if (msg->port >= serial->num_ports) {
-		dbg ("Unexpected port number %d\n", msg->port);
+		dbg ("%s - Unexpected port number %d", __FUNCTION__, msg->port);
 		goto exit;
 	}
 	port = &serial->port[msg->port];
@@ -548,17 +524,17 @@
 		/*	wake_up_interruptible(&p_priv->open_wait); */
 	}
 	
-exit:
 	/* Resubmit urb so we continue receiving */
 	urb->dev = serial->dev;
 	if ((err = usb_submit_urb(urb)) != 0) {
-		dbg(__FUNCTION__ "resubmit read urb failed. (%d)\n", err);
+		dbg("%s - resubmit read urb failed. (%d)", __FUNCTION__, err);
 	}
+exit:
 }
 
 static void	usa26_glocont_callback(struct urb *urb)
 {
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 	
 }
 
@@ -571,7 +547,7 @@
 	unsigned char           *data;
 	struct keyspan_port_private             *p_priv;
 
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 
 	port = (struct usb_serial_port *) urb->context;
 	p_priv = (struct keyspan_port_private *)(port->private);
@@ -582,9 +558,8 @@
 
 	do {
 		if (urb->status) {
-			dbg(__FUNCTION__ "nonzero status: %x on endpoint
-%d.\n",
-			    urb->status, usb_pipeendpoint(urb->pipe));
+			dbg("%s - nonzero status: %x on endpoint %d.",
+			    __FUNCTION__, urb->status, usb_pipeendpoint(urb->pipe));
 			return;
 		}
 
@@ -602,10 +577,10 @@
 
 		/* Resubmit urb so we continue receiving */
 		urb->dev = port->serial->dev;
-		if ((err = usb_submit_urb(urb)) != 0) {
-			dbg(__FUNCTION__ "resubmit read urb failed. (%d)\n",
-err);
-		}
+		if (port->open_count)
+			if ((err = usb_submit_urb(urb)) != 0) {
+				dbg("%s - resubmit read urb failed. (%d)", __FUNCTION__, err);
+			}
 		p_priv->in_flip ^= 1;
 
 		urb = p_priv->in_urbs[p_priv->in_flip];
@@ -614,7 +589,7 @@
 
 static void	usa28_inack_callback(struct urb *urb)
 {
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 }
 
 static void	usa28_outcont_callback(struct urb *urb)
@@ -626,8 +601,8 @@
 	p_priv = (struct keyspan_port_private *)(port->private);
 
 	if (p_priv->resend_cont) {
-		dbg (__FUNCTION__ " sending setup\n");
-		keyspan_usa28_send_setup(port->serial, port, 0);
+		dbg ("%s - sending setup", __FUNCTION__);
+		keyspan_usa28_send_setup(port->serial, port, p_priv->resend_cont - 1);
 	}
 }
 
@@ -635,7 +610,7 @@
 {
 	int					err;
 	unsigned char 				*data = urb->transfer_buffer;
-	keyspan_usa28_portStatusMessage		*msg;
+	struct keyspan_usa28_portStatusMessage	*msg;
 	struct usb_serial			*serial;
 	struct usb_serial_port			*port;
 	struct keyspan_port_private	 	*p_priv;
@@ -644,26 +619,26 @@
 	serial = (struct usb_serial *) urb->context;
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " nonzero status: %x\n", urb->status);
+		dbg("%s - nonzero status: %x", __FUNCTION__, urb->status);
 		return;
 	}
 
 	if (urb->actual_length != sizeof(struct keyspan_usa28_portStatusMessage)) {
-		dbg(__FUNCTION__ " bad length %d\n", urb->actual_length);
+		dbg("%s - bad length %d", __FUNCTION__, urb->actual_length);
 		goto exit;
 	}
 
-	/*dbg(__FUNCTION__ " %x %x %x %x %x %x %x %x %x %x %x %x\n",
+	/*dbg("%s %x %x %x %x %x %x %x %x %x %x %x %x", __FUNCTION__
 	    data[0], data[1], data[2], data[3], data[4], data[5],
 	    data[6], data[7], data[8], data[9], data[10], data[11]);*/
 	
 		/* Now do something useful with the data */
-	msg = (keyspan_usa28_portStatusMessage *)data;
+	msg = (struct keyspan_usa28_portStatusMessage *)data;
 
 
 		/* Check port number from message and retrieve private data */	
 	if (msg->port >= serial->num_ports) {
-		dbg ("Unexpected port number %d\n", msg->port);
+		dbg ("%s - Unexpected port number %d", __FUNCTION__, msg->port);
 		goto exit;
 	}
 	port = &serial->port[msg->port];
@@ -684,17 +659,17 @@
 		/*	wake_up_interruptible(&p_priv->open_wait); */
 	}
 
-exit:	
 		/* Resubmit urb so we continue receiving */
 	urb->dev = serial->dev;
 	if ((err = usb_submit_urb(urb)) != 0) {
-		dbg(__FUNCTION__ "resubmit read urb failed. (%d)\n", err);
+		dbg("%s - resubmit read urb failed. (%d)", __FUNCTION__, err);
 	}
+exit:	
 }
 
 static void	usa28_glocont_callback(struct urb *urb)
 {
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 }
 
 
@@ -705,7 +680,7 @@
 	struct keyspan_port_private *p_priv;
 	int i;
 
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 
 	serial = (struct usb_serial *) urb->context;
 	for (i = 0; i < serial->num_ports; ++i) {
@@ -713,8 +688,8 @@
 		p_priv = (struct keyspan_port_private *)(port->private);
 
 		if (p_priv->resend_cont) {
-			dbg (__FUNCTION__ " sending setup\n"); 
-			keyspan_usa49_send_setup(serial, port, 0);
+			dbg ("%s - sending setup", __FUNCTION__); 
+			keyspan_usa49_send_setup(serial, port, p_priv->resend_cont - 1);
 			break;
 		}
 	}
@@ -726,36 +701,36 @@
 {
 	int					err;
 	unsigned char 				*data = urb->transfer_buffer;
-	keyspan_usa49_portStatusMessage		*msg;
+	struct keyspan_usa49_portStatusMessage	*msg;
 	struct usb_serial			*serial;
 	struct usb_serial_port			*port;
 	struct keyspan_port_private	 	*p_priv;
 	int old_dcd_state;
 
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 
 	serial = (struct usb_serial *) urb->context;
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " nonzero status: %x\n", urb->status);
+		dbg("%s - nonzero status: %x", __FUNCTION__, urb->status);
 		return;
 	}
 
 	if (urb->actual_length != sizeof(struct keyspan_usa49_portStatusMessage)) {
-		dbg(__FUNCTION__ " bad length %d\n", urb->actual_length);
+		dbg("%s - bad length %d", __FUNCTION__, urb->actual_length);
 		goto exit;
 	}
 
-	/*dbg(__FUNCTION__ " %x %x %x %x %x %x %x %x %x %x %x\n",
+	/*dbg(" %x %x %x %x %x %x %x %x %x %x %x", __FUNCTION__, 
 	    data[0], data[1], data[2], data[3], data[4], data[5],
 	    data[6], data[7], data[8], data[9], data[10]);*/
 	
 		/* Now do something useful with the data */
-	msg = (keyspan_usa49_portStatusMessage *)data;
+	msg = (struct keyspan_usa49_portStatusMessage *)data;
 
 		/* Check port number from message and retrieve private data */	
 	if (msg->portNumber >= serial->num_ports) {
-		dbg ("Unexpected port number %d\n", msg->portNumber);
+		dbg ("%s - Unexpected port number %d", __FUNCTION__, msg->portNumber);
 		goto exit;
 	}
 	port = &serial->port[msg->portNumber];
@@ -776,18 +751,18 @@
 		/*	wake_up_interruptible(&p_priv->open_wait); */
 	}
 
-exit:	
 		/* Resubmit urb so we continue receiving */
 	urb->dev = serial->dev;
 
 	if ((err = usb_submit_urb(urb)) != 0) {
-		dbg(__FUNCTION__ "resubmit read urb failed. (%d)\n", err);
+		dbg("%s - resubmit read urb failed. (%d)", __FUNCTION__, err);
 	}
+exit:	
 }
 
 static void	usa49_inack_callback(struct urb *urb)
 {
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 }
 
 static void	usa49_indat_callback(struct urb *urb)
@@ -798,20 +773,21 @@
 	struct tty_struct	*tty;
 	unsigned char 		*data = urb->transfer_buffer;
 
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 
 	endpoint = usb_pipeendpoint(urb->pipe);
 
 	if (urb->status) {
-		dbg(__FUNCTION__ "nonzero status: %x on endpoint %d.\n",
-			      		urb->status, endpoint);
+		dbg("%s - nonzero status: %x on endpoint %d.", __FUNCTION__,
+		    urb->status, endpoint);
 		return;
 	}
 
 	port = (struct usb_serial_port *) urb->context;
 	tty = port->tty;
 	if (urb->actual_length) {
-		if (data[0] == 0) {
+		/* 0x80 bit is error flag */
+		if ((data[0] & 0x80) == 0) {
 			/* no error on any byte */
 			for (i = 1; i < urb->actual_length ; ++i) {
 				tty_insert_flip_char(tty, data[i], 0);
@@ -835,24 +811,43 @@
 				
 		/* Resubmit urb so we continue receiving */
 	urb->dev = port->serial->dev;
-	if ((err = usb_submit_urb(urb)) != 0) {
-		dbg(__FUNCTION__ "resubmit read urb failed. (%d)\n", err);
-	}
+	if (port->open_count)
+		if ((err = usb_submit_urb(urb)) != 0) {
+			dbg("%s - resubmit read urb failed. (%d)", __FUNCTION__, err);
+		}
 }
 
 /* not used, usa-49 doesn't have per-port control endpoints */
 static void	usa49_outcont_callback(struct urb *urb)
 {
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 }
 
 
 
 static int keyspan_write_room (struct usb_serial_port *port)
 {
-	dbg("keyspan_write_room called\n");
-	return (32);
+	struct keyspan_port_private	*p_priv;
+	const struct keyspan_device_details	*d_details;
+	int				flip;
+	struct urb			*this_urb;
 
+	dbg("%s", __FUNCTION__);
+	p_priv = (struct keyspan_port_private *)(port->private);
+	d_details = p_priv->device_details;
+
+	flip = p_priv->out_flip;
+
+	/* Check both endpoints to see if any are available. */
+	if ((this_urb = p_priv->out_urbs[flip]) != 0) {
+		if (this_urb->status != -EINPROGRESS)
+			return (63);
+		flip = (flip + 1) & d_details->outdat_endp_flip;        
+		if ((this_urb = p_priv->out_urbs[flip]) != 0) 
+			if (this_urb->status != -EINPROGRESS)
+				return (63);
+	}
+	return (0);
 }
 
 
@@ -867,26 +862,15 @@
 	struct keyspan_port_private 	*p_priv;
 	struct keyspan_serial_private 	*s_priv;
 	struct usb_serial 		*serial = port->serial;
-	const keyspan_device_details	*d_details;
-	int				i, already_active, err;
-	urb_t *urb;
+	const struct keyspan_device_details	*d_details;
+	int				i, err;
+	struct urb			*urb;
 
 	s_priv = (struct keyspan_serial_private *)(serial->private);
 	p_priv = (struct keyspan_port_private *)(port->private);
 	d_details = s_priv->device_details;
 	
-	dbg("keyspan_open called for port%d.\n", port->number); 
-
-	MOD_INC_USE_COUNT;
-
-	down (&port->sem);
-	++port->open_count;
-	already_active = port->active;
-	port->active = 1;
-	up (&port->sem);
-
-	if (already_active)
-		return 0;
+	dbg("%s - port%d.", __FUNCTION__, port->number); 
 
 	p_priv = (struct keyspan_port_private *)(port->private);
 	
@@ -894,22 +878,37 @@
 	p_priv->rts_state = 1;
 	p_priv->dtr_state = 1;
 
-	/* Start reading from endpoints */
+	p_priv->out_flip = 0;
+	p_priv->in_flip = 0;
+
+	/* Reset low level data toggle and start reading from endpoints */
 	for (i = 0; i < 2; i++) {
 		if ((urb = p_priv->in_urbs[i]) == NULL)
 			continue;
 		urb->dev = serial->dev;
+		usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe), 0);
+
 		if ((err = usb_submit_urb(urb)) != 0) {
-			dbg(__FUNCTION__ " submit urb %d failed (%d)\n", i, err);
+			dbg("%s - submit urb %d failed (%d)", __FUNCTION__, i, err);
 		}
 	}
 
+	/* Reset low level data toggle on out endpoints */
+	for (i = 0; i < 2; i++) {
+		if ((urb = p_priv->out_urbs[i]) == NULL)
+			continue;
+		urb->dev = serial->dev;
+		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe), 0); */
+	}
+
+	keyspan_send_setup(port, 1);
+	//mdelay(100);
 	keyspan_set_termios(port, NULL);
 
 	return (0);
 }
 
-static inline void stop_urb(urb_t *urb)
+static inline void stop_urb(struct urb *urb)
 {
 	if (urb && urb->status == -EINPROGRESS) {
 		urb->transfer_flags &= ~USB_ASYNC_UNLINK;
@@ -928,44 +927,37 @@
 	if (!serial)
 		return;
 
-	dbg("keyspan_close called\n");
+	dbg("%s", __FUNCTION__);
 	s_priv = (struct keyspan_serial_private *)(serial->private);
 	p_priv = (struct keyspan_port_private *)(port->private);
 	
 	p_priv->rts_state = 0;
 	p_priv->dtr_state = 0;
 	
-	if (serial->dev)
-		keyspan_send_setup(port, 1);
+	if (serial->dev) {
+		keyspan_send_setup(port, 2);
+		/* pilot-xfer seems to work best with this delay */
+		mdelay(100);
+		keyspan_set_termios(port, NULL);
+	}
 
 	/*while (p_priv->outcont_urb->status == -EINPROGRESS) {
-		dbg("close - urb in progress\n");
+		dbg("%s - urb in progress", __FUNCTION__);
 	}*/
 
 	p_priv->out_flip = 0;
 	p_priv->in_flip = 0;
 
-	down (&port->sem);
-
-	if (--port->open_count <= 0) {
-		if (port->active) {
-			if (serial->dev) {
-				/* Stop reading/writing urbs */
-				stop_urb(p_priv->inack_urb);
-				stop_urb(p_priv->outcont_urb);
-				for (i = 0; i < 2; i++) {
-					stop_urb(p_priv->in_urbs[i]);
-					stop_urb(p_priv->out_urbs[i]);
-				}
-			}
+	if (serial->dev) {
+		/* Stop reading/writing urbs */
+		stop_urb(p_priv->inack_urb);
+		/* stop_urb(p_priv->outcont_urb); */
+		for (i = 0; i < 2; i++) {
+			stop_urb(p_priv->in_urbs[i]);
+			stop_urb(p_priv->out_urbs[i]);
 		}
-		port->active = 0;
-		port->open_count = 0;
-		port->tty = 0;
 	}
-	up (&port->sem);
-
-	MOD_DEC_USE_COUNT;
+	port->tty = 0;
 }
 
 
@@ -976,12 +968,12 @@
 	const struct ezusb_hex_record 	*record;
 	char				*fw_name;
 
-	dbg("Keyspan startup version %04x product %04x\n",
+	dbg("Keyspan startup version %04x product %04x",
 	    serial->dev->descriptor.bcdDevice,
 	    serial->dev->descriptor.idProduct); 
 	
 	if ((serial->dev->descriptor.bcdDevice & 0x8000) != 0x8000) {
-		dbg("Firmware already loaded.  Quitting.\n");
+		dbg("Firmware already loaded.  Quitting.");
 		return(1);
 	}
 
@@ -1012,6 +1004,16 @@
 		fw_name = "USA19";
 		break;
 			     
+	case keyspan_usa19qi_pre_product_id:
+		record = &keyspan_usa19qi_firmware[0];
+		fw_name = "USA19QI";
+		break;
+			     
+	case keyspan_usa19qw_pre_product_id:
+		record = &keyspan_usa19qw_firmware[0];
+		fw_name = "USA19QI";
+		break;
+			     
 	case keyspan_usa18x_pre_product_id:
 		record = &keyspan_usa18x_firmware[0];
 		fw_name = "USA18X";
@@ -1038,7 +1040,7 @@
 		return(1);
 	}
 
-	dbg("Uploading Keyspan %s firmware.\n", fw_name);
+	dbg("Uploading Keyspan %s firmware.", fw_name);
 
 		/* download the firmware image */
 	response = ezusb_set_reset(serial, 1);
@@ -1065,19 +1067,19 @@
 }
 
 /* Helper functions used by keyspan_setup_urbs */
-static urb_t *keyspan_setup_urb(struct usb_serial *serial, int endpoint,
-				int dir, void *ctx, char *buf, int len,
-				void (*callback)(urb_t *))
+static struct urb *keyspan_setup_urb (struct usb_serial *serial, int endpoint,
+				      int dir, void *ctx, char *buf, int len,
+				      void (*callback)(struct urb *))
 {
-	urb_t *urb;
+	struct urb *urb;
 
 	if (endpoint == -1)
 		return NULL;		/* endpoint not needed */
 
-	dbg (__FUNCTION__ " alloc for endpoint %d.\n", endpoint);
+	dbg ("%s - alloc for endpoint %d.", __FUNCTION__, endpoint);
 	urb = usb_alloc_urb(0);		/* No ISO */
 	if (urb == NULL) {
-		dbg (__FUNCTION__ " alloc for endpoint %d failed.\n", endpoint);
+		dbg ("%s - alloc for endpoint %d failed.", __FUNCTION__, endpoint);
 		return NULL;
 	}
 
@@ -1090,37 +1092,37 @@
 }
 
 static struct callbacks {
-	void	(*instat_callback)(urb_t *);
-	void	(*glocont_callback)(urb_t *);
-	void	(*indat_callback)(urb_t *);
-	void	(*outdat_callback)(urb_t *);
-	void	(*inack_callback)(urb_t *);
-	void	(*outcont_callback)(urb_t *);
+	void	(*instat_callback)(struct urb *);
+	void	(*glocont_callback)(struct urb *);
+	void	(*indat_callback)(struct urb *);
+	void	(*outdat_callback)(struct urb *);
+	void	(*inack_callback)(struct urb *);
+	void	(*outcont_callback)(struct urb *);
 } keyspan_callbacks[] = {
 	{
 		/* msg_usa26 callbacks */
-		instat_callback: usa26_instat_callback,
-		glocont_callback: usa26_glocont_callback,
-		indat_callback: usa26_indat_callback,
-		outdat_callback: usa2x_outdat_callback,
-		inack_callback: usa26_inack_callback,
-		outcont_callback: usa26_outcont_callback,
+		.instat_callback =	usa26_instat_callback,
+		.glocont_callback =	usa26_glocont_callback,
+		.indat_callback =	usa26_indat_callback,
+		.outdat_callback =	usa2x_outdat_callback,
+		.inack_callback =	usa26_inack_callback,
+		.outcont_callback =	usa26_outcont_callback,
 	}, {
 		/* msg_usa28 callbacks */
-		instat_callback: usa28_instat_callback,
-		glocont_callback: usa28_glocont_callback,
-		indat_callback: usa28_indat_callback,
-		outdat_callback: usa2x_outdat_callback,
-		inack_callback: usa28_inack_callback,
-		outcont_callback: usa28_outcont_callback,
+		.instat_callback =	usa28_instat_callback,
+		.glocont_callback =	usa28_glocont_callback,
+		.indat_callback =	usa28_indat_callback,
+		.outdat_callback =	usa2x_outdat_callback,
+		.inack_callback =	usa28_inack_callback,
+		.outcont_callback =	usa28_outcont_callback,
 	}, {
 		/* msg_usa49 callbacks */
-		instat_callback: usa49_instat_callback,
-		glocont_callback: usa49_glocont_callback,
-		indat_callback: usa49_indat_callback,
-		outdat_callback: usa2x_outdat_callback,
-		inack_callback: usa49_inack_callback,
-		outcont_callback: usa49_outcont_callback,
+		.instat_callback =	usa49_instat_callback,
+		.glocont_callback =	usa49_glocont_callback,
+		.indat_callback =	usa49_indat_callback,
+		.outdat_callback =	usa2x_outdat_callback,
+		.inack_callback =	usa49_inack_callback,
+		.outcont_callback =	usa49_outcont_callback,
 	}
 };
 
@@ -1130,13 +1132,13 @@
 {
 	int				i, j;
 	struct keyspan_serial_private 	*s_priv;
-	const keyspan_device_details	*d_details;
+	const struct keyspan_device_details	*d_details;
 	struct usb_serial_port		*port;
 	struct keyspan_port_private	*p_priv;
 	struct callbacks		*cback;
 	int				endp;
 
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 
 	s_priv = (struct keyspan_serial_private *)(serial->private);
 	d_details = s_priv->device_details;
@@ -1198,13 +1200,14 @@
 }
 
 /* usa19 function doesn't require prescaler */
-static int keyspan_usa19_calc_baud(u32 baud_rate, u32 baudclk,
-				   u8 *rate_hi, u8 *rate_low, u8 *prescaler)
+static int keyspan_usa19_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,
+				   u8 *rate_low, u8 *prescaler, int portnum)
 {
 	u32 	b16,	/* baud rate times 16 (actual rate used internally) */
 		div,	/* divisor */	
 		cnt;	/* inverse of divisor (programmed into 8051) */
 		
+	dbg ("%s - %d.", __FUNCTION__, baud_rate);
 
 		/* prevent divide by zero...  */
 	if( (b16 = (baud_rate * 16L)) == 0) {
@@ -1237,14 +1240,14 @@
 		*rate_hi = (u8) ((cnt >> 8) & 0xff);
 	}
 	if (rate_low && rate_hi) {
-		dbg (__FUNCTION__ " %d %02x %02x.", baud_rate, *rate_hi, *rate_low);
+		dbg ("%s - %d %02x %02x.", __FUNCTION__, baud_rate, *rate_hi, *rate_low);
 	}
 	
 	return (KEYSPAN_BAUD_RATE_OK);
 }
 
-static int keyspan_usa19w_calc_baud(u32 baud_rate, u32 baudclk,
-				    u8 *rate_hi, u8 *rate_low, u8 *prescaler)
+static int keyspan_usa19w_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,
+				    u8 *rate_low, u8 *prescaler, int portnum)
 {
 	u32 	b16,	/* baud rate times 16 (actual rate used internally) */
 		clk,	/* clock with 13/8 prescaler */
@@ -1255,7 +1258,7 @@
 	u8	best_prescaler;
 	int	i;
 
-	dbg (__FUNCTION__ " %d.\n", baud_rate);
+	dbg ("%s - %d.", __FUNCTION__, baud_rate);
 
 		/* prevent divide by zero */
 	if( (b16 = baud_rate * 16L) == 0) {
@@ -1271,8 +1274,7 @@
 		/* 0 is an invalid prescaler, used as a flag */
 	best_prescaler = 0;
 
-	for(i = 8; i <= 0xff; ++i)
-	{
+	for(i = 8; i <= 0xff; ++i) {
 		clk = (baudclk * 8) / (u32) i;
 		
 		if( (div = clk / b16) == 0) {
@@ -1282,8 +1284,7 @@
 		res = clk / div;
 		diff= (res > b16) ? (res-b16) : (b16-res);
 
-		if(diff < smallest_diff)
-		{
+		if(diff < smallest_diff) {
 			best_prescaler = i;
 			smallest_diff = diff;
 		}
@@ -1305,8 +1306,59 @@
 	}
 	if (prescaler) {
 		*prescaler = best_prescaler;
-		/*  dbg(__FUNCTION__ " %d %d", *prescaler, div); */
+		/*  dbg("%s - %d %d", __FUNCTION__, *prescaler, div); */
+	}
+	return (KEYSPAN_BAUD_RATE_OK);
+}
+
+	/* USA-28 supports different maximum baud rates on each port */
+static int keyspan_usa28_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,
+				    u8 *rate_low, u8 *prescaler, int portnum)
+{
+	u32 	b16,	/* baud rate times 16 (actual rate used internally) */
+		div,	/* divisor */	
+		cnt;	/* inverse of divisor (programmed into 8051) */
+
+	dbg ("%s - %d.", __FUNCTION__, baud_rate);
+
+		/* prevent divide by zero */
+	if ((b16 = baud_rate * 16L) == 0)
+		return (KEYSPAN_INVALID_BAUD_RATE);
+
+		/* calculate the divisor and the counter (its inverse) */
+	if ((div = (KEYSPAN_USA28_BAUDCLK / b16)) == 0) {
+		return (KEYSPAN_INVALID_BAUD_RATE);
+	}
+	else {
+		cnt = 0 - div;
+	}
+
+		/* check for out of range, based on portnum, 
+		   and return result */
+	if(portnum == 0) {
+		if(div > 0xffff)
+			return (KEYSPAN_INVALID_BAUD_RATE);
+	}
+	else {
+		if(portnum == 1) {
+			if(div > 0xff) {
+				return (KEYSPAN_INVALID_BAUD_RATE);
+			}
+		}
+		else {
+			return (KEYSPAN_INVALID_BAUD_RATE);
+		}
+	}
+
+		/* return the counter values if not NULL
+		   (port 1 will ignore retHi) */
+	if (rate_low) {
+		*rate_low = (u8) (cnt & 0xff);
+	}
+	if (rate_hi) {
+		*rate_hi = (u8) ((cnt >> 8) & 0xff);
 	}
+	dbg ("%s - %d OK.", __FUNCTION__, baud_rate);
 	return (KEYSPAN_BAUD_RATE_OK);
 }
 
@@ -1317,31 +1369,35 @@
 	struct keyspan_usa26_portControlMessage	msg;		
 	struct keyspan_serial_private 		*s_priv;
 	struct keyspan_port_private 		*p_priv;
-	const  keyspan_device_details		*d_details;
+	const struct keyspan_device_details	*d_details;
 	int 					outcont_urb;
-	urb_t *this_urb;
-	int err;
+	struct urb				*this_urb;
+	int 					device_port, err;
 
-	dbg ("%s reset=%d\n", __FUNCTION__, reset_port); 
+	dbg ("%s reset=%d", __FUNCTION__, reset_port); 
 
 	s_priv = (struct keyspan_serial_private *)(serial->private);
 	p_priv = (struct keyspan_port_private *)(port->private);
 	d_details = s_priv->device_details;
+	device_port = port->number - port->serial->minor;
 
 	outcont_urb = d_details->outcont_endpoints[port->number];
 	this_urb = p_priv->outcont_urb;
 
-	dbg(__FUNCTION__ " endpoint %d\n", usb_pipeendpoint(this_urb->pipe));
+	dbg("%s - endpoint %d", __FUNCTION__, usb_pipeendpoint(this_urb->pipe));
 
 		/* Make sure we have an urb then send the message */
 	if (this_urb == NULL) {
-		dbg(__FUNCTION__ " oops no urb.\n");
+		dbg("%s - oops no urb.", __FUNCTION__);
 		return -1;
 	}
 
-	p_priv->resend_cont = 1;
+	/* Save reset port val for resend.
+	Don't overwrite resend for close condition. */
+	if (p_priv->resend_cont != 3)
+		p_priv->resend_cont = reset_port + 1;
 	if (this_urb->status == -EINPROGRESS) {
-		/*  dbg (__FUNCTION__ " already writing"); */
+		/*  dbg ("%s - already writing", __FUNCTION__); */
 		return(-1);
 	}
 
@@ -1353,8 +1409,8 @@
 		msg.setClocking = 0xff;
 		if (d_details->calculate_baud_rate
 		    (p_priv->baud, d_details->baudclk, &msg.baudHi,
-		     &msg.baudLo, &msg.prescaler) == KEYSPAN_INVALID_BAUD_RATE ) {
-			dbg(__FUNCTION__ "Invalid baud rate %d requested, using 9600.\n",
+		     &msg.baudLo, &msg.prescaler, device_port) == KEYSPAN_INVALID_BAUD_RATE ) {
+			dbg("%s - Invalid baud rate %d requested, using 9600.", __FUNCTION__,
 			    p_priv->baud);
 			msg.baudLo = 0;
 			msg.baudHi = 125;	/* Values for 9600 baud */
@@ -1388,12 +1444,26 @@
 	msg.ctsFlowControl = (p_priv->flow_control == flow_cts);
 	msg.xonFlowControl = 0;
 	msg.setFlowControl = 0xff;
-	
-	msg.forwardingLength = 1;
+	msg.forwardingLength = 16;
 	msg.xonChar = 17;
 	msg.xoffChar = 19;
 
-	if (reset_port) {
+	/* Opening port */
+	if (reset_port == 1) {
+		msg._txOn = 1;
+		msg._txOff = 0;
+		msg.txFlush = 0;
+		msg.txBreak = 0;
+		msg.rxOn = 1;
+		msg.rxOff = 0;
+		msg.rxFlush = 1;
+		msg.rxForward = 0;
+		msg.returnStatus = 0;
+		msg.resetDataToggle = 0xff;
+	}
+
+	/* Closing port */
+	else if (reset_port == 2) {
 		msg._txOn = 0;
 		msg._txOff = 1;
 		msg.txFlush = 0;
@@ -1403,14 +1473,16 @@
 		msg.rxFlush = 1;
 		msg.rxForward = 0;
 		msg.returnStatus = 0;
-		msg.resetDataToggle = 0xff;
+		msg.resetDataToggle = 0;
 	}
+
+	/* Sending intermediate configs */
 	else {
 		msg._txOn = (! p_priv->break_on);
 		msg._txOff = 0;
 		msg.txFlush = 0;
 		msg.txBreak = (p_priv->break_on);
-		msg.rxOn = 1;
+		msg.rxOn = 0;
 		msg.rxOff = 0;
 		msg.rxFlush = 0;
 		msg.rxForward = 0;
@@ -1433,11 +1505,11 @@
 
 	this_urb->dev = serial->dev;
 	if ((err = usb_submit_urb(this_urb)) != 0) {
-		dbg(__FUNCTION__ " usb_submit_urb(setup) failed (%d)\n", err);
+		dbg("%s - usb_submit_urb(setup) failed (%d)", __FUNCTION__, err);
 	}
 #if 0
 	else {
-		dbg(__FUNCTION__ " usb_submit_urb(%d) OK %d bytes (end %d)",
+		dbg("%s - usb_submit_urb(%d) OK %d bytes (end %d)", __FUNCTION__
 		    outcont_urb, this_urb->transfer_buffer_length,
 		    usb_pipeendpoint(this_urb->pipe));
 	}
@@ -1453,32 +1525,38 @@
 	struct keyspan_usa28_portControlMessage	msg;		
 	struct keyspan_serial_private	 	*s_priv;
 	struct keyspan_port_private 		*p_priv;
-	const  keyspan_device_details		*d_details;
-	urb_t *this_urb;
-	int err;
+	const struct keyspan_device_details	*d_details;
+	struct urb				*this_urb;
+	int 					device_port, err;
+
+	dbg ("%s", __FUNCTION__);
 
 	s_priv = (struct keyspan_serial_private *)(serial->private);
 	p_priv = (struct keyspan_port_private *)(port->private);
 	d_details = s_priv->device_details;
+	device_port = port->number - port->serial->minor;
 
 	/* only do something if we have a bulk out endpoint */
 	if ((this_urb = p_priv->outcont_urb) == NULL) {
-		dbg(__FUNCTION__ " oops no urb.\n");
+		dbg("%s - oops no urb.", __FUNCTION__);
 		return -1;
 	}
 
-	p_priv->resend_cont = 1;
+	/* Save reset port val for resend.
+	   Don't overwrite resend for close condition. */
+	if (p_priv->resend_cont != 3)
+		p_priv->resend_cont = reset_port + 1;
 	if (this_urb->status == -EINPROGRESS) {
-		dbg (__FUNCTION__ " already writing\n");
+		dbg ("%s already writing", __FUNCTION__);
 		return(-1);
 	}
 
 	memset(&msg, 0, sizeof (struct keyspan_usa28_portControlMessage));
 
 	msg.setBaudRate = 1;
-	if (keyspan_usa19_calc_baud(p_priv->baud, d_details->baudclk,
-		&msg.baudHi, &msg.baudLo, NULL) == KEYSPAN_INVALID_BAUD_RATE ) {
-		dbg(__FUNCTION__ "Invalid baud rate requested %d.", p_priv->baud);
+	if (d_details->calculate_baud_rate(p_priv->baud, d_details->baudclk,
+		&msg.baudHi, &msg.baudLo, NULL, device_port) == KEYSPAN_INVALID_BAUD_RATE ) {
+		dbg("%s - Invalid baud rate requested %d.", __FUNCTION__, p_priv->baud);
 		msg.baudLo = 0xff;
 		msg.baudHi = 0xb2;	/* Values for 9600 baud */
 	}
@@ -1493,23 +1571,56 @@
 	msg.rts = p_priv->rts_state;
 	msg.dtr = p_priv->dtr_state;
 
-	msg.forwardingLength = 1;
+	msg.forwardingLength = 16;
 	msg.forwardMs = 10;
 	msg.breakThreshold = 45;
 	msg.xonChar = 17;
 	msg.xoffChar = 19;
 
-	msg._txOn = 1;
-	msg._txOff = 0;
-	msg.txFlush = 0;
-	msg.txForceXoff = 0;
-	msg.txBreak = 0;
-	msg.rxOn = 1;
-	msg.rxOff = 0;
-	msg.rxFlush = 0;
-	msg.rxForward = 0;
 	/*msg.returnStatus = 1;
 	msg.resetDataToggle = 0xff;*/
+	/* Opening port */
+	if (reset_port == 1) {
+		msg._txOn = 1;
+		msg._txOff = 0;
+		msg.txFlush = 0;
+		msg.txForceXoff = 0;
+		msg.txBreak = 0;
+		msg.rxOn = 1;
+		msg.rxOff = 0;
+		msg.rxFlush = 1;
+		msg.rxForward = 0;
+		msg.returnStatus = 0;
+		msg.resetDataToggle = 0xff;
+	}
+	/* Closing port */
+	else if (reset_port == 2) {
+		msg._txOn = 0;
+		msg._txOff = 1;
+		msg.txFlush = 0;
+		msg.txForceXoff = 0;
+		msg.txBreak = 0;
+		msg.rxOn = 0;
+		msg.rxOff = 1;
+		msg.rxFlush = 1;
+		msg.rxForward = 0;
+		msg.returnStatus = 0;
+		msg.resetDataToggle = 0;
+	}
+	/* Sending intermediate configs */
+	else {
+		msg._txOn = (! p_priv->break_on);
+		msg._txOff = 0;
+		msg.txFlush = 0;
+		msg.txForceXoff = 0;
+		msg.txBreak = (p_priv->break_on);
+		msg.rxOn = 0;
+		msg.rxOff = 0;
+		msg.rxFlush = 0;
+		msg.rxForward = 0;
+		msg.returnStatus = 0;
+		msg.resetDataToggle = 0x0;
+	}
 
 	p_priv->resend_cont = 0;
 	memcpy (this_urb->transfer_buffer, &msg, sizeof(msg));
@@ -1519,11 +1630,11 @@
 
 	this_urb->dev = serial->dev;
 	if ((err = usb_submit_urb(this_urb)) != 0) {
-		dbg(__FUNCTION__ " usb_submit_urb(setup) failed\n");
+		dbg("%s - usb_submit_urb(setup) failed", __FUNCTION__);
 	}
 #if 0
 	else {
-		dbg(__FUNCTION__ " usb_submit_urb(setup) OK %d bytes",
+		dbg("%s - usb_submit_urb(setup) OK %d bytes", __FUNCTION__,
 		    this_urb->transfer_buffer_length);
 	}
 #endif
@@ -1538,13 +1649,12 @@
 	struct keyspan_usa49_portControlMessage	msg;		
 	struct keyspan_serial_private 		*s_priv;
 	struct keyspan_port_private 		*p_priv;
-	const  keyspan_device_details		*d_details;
+	const struct keyspan_device_details	*d_details;
 	int 					glocont_urb;
-	urb_t 					*this_urb;
-	int 					err;
-	int					device_port;
+	struct urb				*this_urb;
+	int 					err, device_port;
 
-	dbg ("%s\n", __FUNCTION__);
+	dbg ("%s", __FUNCTION__);
 
 	s_priv = (struct keyspan_serial_private *)(serial->private);
 	p_priv = (struct keyspan_port_private *)(port->private);
@@ -1556,17 +1666,20 @@
 		/* Work out which port within the device is being setup */
 	device_port = port->number - port->serial->minor;
 
-	dbg(__FUNCTION__ " endpoint %d port %d (%d)\n", usb_pipeendpoint(this_urb->pipe), port->number, device_port);
+	dbg("%s - endpoint %d port %d (%d)",__FUNCTION__, usb_pipeendpoint(this_urb->pipe), port->number, device_port);
 
 		/* Make sure we have an urb then send the message */
 	if (this_urb == NULL) {
-		dbg(__FUNCTION__ " oops no urb for port %d.\n", port->number);
+		dbg("%s - oops no urb for port %d.", __FUNCTION__, port->number);
 		return -1;
 	}
 
-	p_priv->resend_cont = 1;
+	/* Save reset port val for resend.
+	   Don't overwrite resend for close condition. */
+	if (p_priv->resend_cont != 3)
+		p_priv->resend_cont = reset_port + 1;
 	if (this_urb->status == -EINPROGRESS) {
-		/*  dbg (__FUNCTION__ " already writing"); */
+		/*  dbg ("%s - already writing", __FUNCTION__); */
 		return(-1);
 	}
 
@@ -1581,8 +1694,8 @@
 		msg.setClocking = 0xff;
 		if (d_details->calculate_baud_rate
 		    (p_priv->baud, d_details->baudclk, &msg.baudHi,
-		     &msg.baudLo, &msg.prescaler) == KEYSPAN_INVALID_BAUD_RATE ) {
-			dbg(__FUNCTION__ "Invalid baud rate %d requested, using 9600.\n",
+		     &msg.baudLo, &msg.prescaler, device_port) == KEYSPAN_INVALID_BAUD_RATE ) {
+			dbg("%s - Invalid baud rate %d requested, using 9600.", __FUNCTION__,
 			    p_priv->baud);
 			msg.baudLo = 0;
 			msg.baudHi = 125;	/* Values for 9600 baud */
@@ -1617,20 +1730,55 @@
 	msg.xonFlowControl = 0;
 	msg.setFlowControl = 0xff;
 	
-	msg.forwardingLength = 1;
+	msg.forwardingLength = 16;
 	msg.xonChar = 17;
 	msg.xoffChar = 19;
-	
-	msg._txOn = 1;
-	msg._txOff = 0;
-	msg.txFlush = 0;
-	msg.txBreak = 0;
-	msg.rxOn = 1;
-	msg.rxOff = 0;
-	msg.rxFlush = 0;
-	msg.rxForward = 0;
-	msg.enablePort = 0xff;
-	msg.disablePort = 0;
+
+	/* Opening port */ 
+	if (reset_port == 1) {
+		msg._txOn = 1;
+		msg._txOff = 0;
+		msg.txFlush = 0;
+		msg.txBreak = 0;
+		msg.rxOn = 1;
+		msg.rxOff = 0;
+		msg.rxFlush = 1;
+		msg.rxForward = 0;
+		msg.returnStatus = 0;
+		msg.resetDataToggle = 0xff;
+		msg.enablePort = 1;
+		msg.disablePort = 0;
+	}
+	/* Closing port */
+	else if (reset_port == 2) {
+		msg._txOn = 0;
+		msg._txOff = 1;
+		msg.txFlush = 0;
+		msg.txBreak = 0;
+		msg.rxOn = 0;
+		msg.rxOff = 1;
+		msg.rxFlush = 1;
+		msg.rxForward = 0;
+		msg.returnStatus = 0;
+		msg.resetDataToggle = 0;
+		msg.enablePort = 0;
+		msg.disablePort = 1;
+	}
+	/* Sending intermediate configs */
+	else {
+		msg._txOn = (! p_priv->break_on);
+		msg._txOff = 0;
+		msg.txFlush = 0;
+		msg.txBreak = (p_priv->break_on);
+		msg.rxOn = 0;
+		msg.rxOff = 0;
+		msg.rxFlush = 0;
+		msg.rxForward = 0;
+		msg.returnStatus = 0;
+		msg.resetDataToggle = 0x0;
+		msg.enablePort = 0;
+		msg.disablePort = 0;
+	}
 
 		/* Do handshaking outputs */	
 	msg.setRts = 0xff;
@@ -1647,11 +1795,11 @@
 
 	this_urb->dev = serial->dev;
 	if ((err = usb_submit_urb(this_urb)) != 0) {
-		dbg(__FUNCTION__ " usb_submit_urb(setup) failed (%d)\n", err);
+		dbg("%s - usb_submit_urb(setup) failed (%d)", __FUNCTION__, err);
 	}
 #if 0
 	else {
-		dbg(__FUNCTION__ " usb_submit_urb(%d) OK %d bytes (end %d)",
+		dbg("%s - usb_submit_urb(%d) OK %d bytes (end %d)", __FUNCTION__,
 		    outcont_urb, this_urb->transfer_buffer_length,
 		    usb_pipeendpoint(this_urb->pipe));
 	}
@@ -1663,8 +1811,10 @@
 static void keyspan_send_setup(struct usb_serial_port *port, int reset_port)
 {
 	struct usb_serial *serial = port->serial;
-	struct keyspan_serial_private 	*s_priv;
-	const keyspan_device_details	*d_details;
+	struct keyspan_serial_private *s_priv;
+	const struct keyspan_device_details *d_details;
+
+	dbg ("%s", __FUNCTION__);
 
 	s_priv = (struct keyspan_serial_private *)(serial->private);
 	d_details = s_priv->device_details;
@@ -1690,16 +1840,15 @@
 	struct usb_serial_port		*port;
 	struct keyspan_serial_private 	*s_priv;
 	struct keyspan_port_private	*p_priv;
-	const keyspan_device_details	*d_details;
+	const struct keyspan_device_details	*d_details;
 
-	dbg("keyspan_startup called.\n");
+	dbg("%s", __FUNCTION__);
 
 	for (i = 0; (d_details = keyspan_devices[i]) != NULL; ++i)
 		if (d_details->product_id == serial->dev->descriptor.idProduct)
 			break;
 	if (d_details == NULL) {
-		printk(KERN_ERR __FUNCTION__ ": unknown product id %x\n",
-		       serial->dev->descriptor.idProduct);
+		err("%s - unknown product id %x", __FUNCTION__, serial->dev->descriptor.idProduct);
 		return 1;
 	}
 
@@ -1707,7 +1856,7 @@
 	serial->private = kmalloc(sizeof(struct keyspan_serial_private),
 				  GFP_KERNEL);
 	if (!serial->private) {
-		dbg(__FUNCTION__ "kmalloc for keyspan_serial_private failed.\n");
+		dbg("%s - kmalloc for keyspan_serial_private failed.", __FUNCTION__);
 		return (1);
 	}
 	memset(serial->private, 0, sizeof(struct keyspan_serial_private));
@@ -1721,7 +1870,7 @@
 		port->private = kmalloc(sizeof(struct keyspan_port_private),
 					GFP_KERNEL);
 		if (!port->private) {
-			dbg(__FUNCTION__ "kmalloc for keyspan_port_private (%d) failed!.\n", i);
+			dbg("%s - kmalloc for keyspan_port_private (%d) failed!.", __FUNCTION__, i);
 			return (1);
 		}
 		memset(port->private, 0, sizeof(struct keyspan_port_private));
@@ -1733,7 +1882,7 @@
 
 	s_priv->instat_urb->dev = serial->dev;
 	if ((err = usb_submit_urb(s_priv->instat_urb)) != 0) {
-		dbg(__FUNCTION__ " submit instat urb failed %d\n", err);
+		dbg("%s - submit instat urb failed %d", __FUNCTION__, err);
 	}
 			
 	return (0);
@@ -1746,7 +1895,7 @@
 	struct keyspan_serial_private 	*s_priv;
 	struct keyspan_port_private	*p_priv;
 
-	dbg("keyspan_shutdown called\n");
+	dbg("%s", __FUNCTION__);
 
 	s_priv = (struct keyspan_serial_private *)(serial->private);
 
@@ -1791,10 +1940,6 @@
 	/* Now free per port private data */
 	for (i = 0; i < serial->num_ports; i++) {
 		port = &serial->port[i];
-		while (port->open_count > 0) {
-			--port->open_count;
-			MOD_DEC_USE_COUNT;
-		}
 		kfree(port->private);
 	}
 }
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan.h linux-2.4.19/drivers/usb/serial/keyspan.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan.h	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan.h	Mon Nov 25 12:27:09 2002
@@ -2,7 +2,7 @@
   Keyspan USB to Serial Converter driver
  
   (C) Copyright (C) 2000-2001
-      Hugh Blemings <hugh@misc.nu>
+      Hugh Blemings <hugh@blemings.org>
    
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -33,9 +33,8 @@
 #ifndef __LINUX_USB_SERIAL_KEYSPAN_H
 #define __LINUX_USB_SERIAL_KEYSPAN_H
 
-#include <linux/config.h>
 
-	/* Function prototypes for Keyspan serial converter */
+/* Function prototypes for Keyspan serial converter */
 static int  keyspan_open		(struct usb_serial_port *port,
 					 struct file *filp);
 static void keyspan_close		(struct usb_serial_port *port,
@@ -54,12 +53,7 @@
 static void keyspan_send_setup		(struct usb_serial_port *port,
 					 int reset_port);
 
-#if 0
-static void keyspan_write_bulk_callback (struct urb *urb);
-#endif
 
-//static void keyspan_usa26_read_int_callback  (struct urb *urb);
-//static void keyspan_usa28_read_int_callback  (struct urb *urb);
 static int  keyspan_chars_in_buffer 	(struct usb_serial_port *port);
 static int  keyspan_ioctl		(struct usb_serial_port *port,
 					 struct file *file,
@@ -72,12 +66,16 @@
 static int  keyspan_fake_startup	(struct usb_serial *serial);
 
 static int  keyspan_usa19_calc_baud	(u32 baud_rate, u32 baudclk, 
-					 u8 *rate_hi, u8 *rate_low, u8 *prescaler);
+					 u8 *rate_hi, u8 *rate_low,
+					 u8 *prescaler, int portnum);
 
 static int  keyspan_usa19w_calc_baud	(u32 baud_rate, u32 baudclk,
-					 u8 *rate_hi, u8 *rate_low, u8 *prescaler);
+					 u8 *rate_hi, u8 *rate_low,
+					 u8 *prescaler, int portnum);
 
-//static void keyspan_usa19_setup_urbs	(struct usb_serial *serial);
+static int  keyspan_usa28_calc_baud	(u32 baud_rate, u32 baudclk,
+					 u8 *rate_hi, u8 *rate_low,
+					 u8 *prescaler, int portnum);
 
 static int  keyspan_usa28_send_setup	(struct usb_serial *serial,
 					 struct usb_serial_port *port,
@@ -89,91 +87,102 @@
 					 struct usb_serial_port *port,
 					 int reset_port);
 
-	/* Functions from usbserial.c for ezusb firmware handling */
-extern int ezusb_set_reset (struct usb_serial *serial, unsigned char reset_bit);
-extern int ezusb_writememory (struct usb_serial *serial, int address, unsigned char *data, int length, __u8 bRequest);
 
-	/* Struct used for firmware - increased size of data section
-	   to allow Keyspan's 'C' firmware struct to be used unmodified */
+/* Struct used for firmware - increased size of data section
+   to allow Keyspan's 'C' firmware struct to be used unmodified */
 struct ezusb_hex_record {
 	__u16 address;
 	__u8 data_size;
 	__u8 data[64];
 };
-	/* Conditionally include firmware images, if they aren't
-	   included create a null pointer instead.  Current 
-	   firmware images aren't optimised to remove duplicate
-	   addresses in the image itself. */
+
+/* Conditionally include firmware images, if they aren't
+   included create a null pointer instead.  Current 
+   firmware images aren't optimised to remove duplicate
+   addresses in the image itself. */
 #ifdef CONFIG_USB_SERIAL_KEYSPAN_USA28
-        #include "keyspan_usa28_fw.h"
+	#include "keyspan_usa28_fw.h"
 #else
 	static const struct ezusb_hex_record *keyspan_usa28_firmware = NULL;
 #endif
 
 #ifdef CONFIG_USB_SERIAL_KEYSPAN_USA28X
-        #include "keyspan_usa28x_fw.h"
+	#include "keyspan_usa28x_fw.h"
 #else
 	static const struct ezusb_hex_record *keyspan_usa28x_firmware = NULL;
 #endif
 
 #ifdef CONFIG_USB_SERIAL_KEYSPAN_USA28XA
-        #include "keyspan_usa28xa_fw.h"
+	#include "keyspan_usa28xa_fw.h"
 #else
 	static const struct ezusb_hex_record *keyspan_usa28xa_firmware = NULL;
 #endif
 
 #ifdef CONFIG_USB_SERIAL_KEYSPAN_USA28XB
-        #include "keyspan_usa28xb_fw.h"
+	#include "keyspan_usa28xb_fw.h"
 #else
 	static const struct ezusb_hex_record *keyspan_usa28xb_firmware = NULL;
 #endif
 
 #ifdef CONFIG_USB_SERIAL_KEYSPAN_USA19
-        #include "keyspan_usa19_fw.h"
+	#include "keyspan_usa19_fw.h"
 #else
 	static const struct ezusb_hex_record *keyspan_usa19_firmware = NULL;
 #endif
 
+#ifdef CONFIG_USB_SERIAL_KEYSPAN_USA19QI
+	#include "keyspan_usa19qi_fw.h"
+#else
+	static const struct ezusb_hex_record *keyspan_usa19qi_firmware = NULL;
+#endif
+
+#ifdef CONFIG_USB_SERIAL_KEYSPAN_USA19QW
+	#include "keyspan_usa19qw_fw.h"
+#else
+	static const struct ezusb_hex_record *keyspan_usa19qw_firmware = NULL;
+#endif
+
 #ifdef CONFIG_USB_SERIAL_KEYSPAN_USA18X
-        #include "keyspan_usa18x_fw.h"
+	#include "keyspan_usa18x_fw.h"
 #else
 	static const struct ezusb_hex_record *keyspan_usa18x_firmware = NULL;
 #endif
 
 #ifdef CONFIG_USB_SERIAL_KEYSPAN_USA19W
-        #include "keyspan_usa19w_fw.h"
+	#include "keyspan_usa19w_fw.h"
 #else
 	static const struct ezusb_hex_record *keyspan_usa19w_firmware = NULL;
 #endif
 
 #ifdef CONFIG_USB_SERIAL_KEYSPAN_USA49W
-        #include "keyspan_usa49w_fw.h"
+	#include "keyspan_usa49w_fw.h"
 #else
 	static const struct ezusb_hex_record *keyspan_usa49w_firmware = NULL;
 #endif
-	
-	/* Values used for baud rate calculation - device specific */
+
+/* Values used for baud rate calculation - device specific */
 #define	KEYSPAN_INVALID_BAUD_RATE		(-1)
 #define	KEYSPAN_BAUD_RATE_OK			(0)
 #define	KEYSPAN_USA18X_BAUDCLK			(12000000L)	/* a guess */
 #define	KEYSPAN_USA19_BAUDCLK			(12000000L)
 #define	KEYSPAN_USA19W_BAUDCLK			(24000000L)
+#define	KEYSPAN_USA28_BAUDCLK			(1843200L)
 #define	KEYSPAN_USA28X_BAUDCLK			(12000000L)
 #define	KEYSPAN_USA49W_BAUDCLK			(48000000L)
 
-	/* Some constants used to characterise each device. 
-	   There is a four port device due later in the year,
-	   we allow for it now in the following */
+/* Some constants used to characterise each device.  */
 #define		KEYSPAN_MAX_NUM_PORTS		(4)
 #define		KEYSPAN_MAX_FLIPS		(2)
-	
-	/* Device info for the Keyspan serial converter, used
-	   by the overall usb-serial probe function */
+
+/* Device info for the Keyspan serial converter, used
+   by the overall usb-serial probe function */
 #define KEYSPAN_VENDOR_ID			(0x06cd)
 
-	/* Product IDs for the eight products supported, pre-renumeration */
+/* Product IDs for the products supported, pre-renumeration */
 #define	keyspan_usa18x_pre_product_id		0x0105
 #define	keyspan_usa19_pre_product_id		0x0103
+#define	keyspan_usa19qi_pre_product_id		0x010b
+#define	keyspan_usa19qw_pre_product_id		0x0118
 #define	keyspan_usa19w_pre_product_id		0x0106
 #define	keyspan_usa28_pre_product_id		0x0101
 #define	keyspan_usa28x_pre_product_id		0x0102
@@ -181,11 +190,13 @@
 #define	keyspan_usa28xb_pre_product_id		0x0113
 #define	keyspan_usa49w_pre_product_id		0x0109
 
-	/* Product IDs post-renumeration.  Note that the 28x and 28xb
-	   have the same id's post-renumeration but behave identically
-	   so it's not an issue. */
+/* Product IDs post-renumeration.  Note that the 28x and 28xb
+   have the same id's post-renumeration but behave identically
+   so it's not an issue. */
 #define	keyspan_usa18x_product_id		0x0112
 #define	keyspan_usa19_product_id		0x0107
+#define	keyspan_usa19qi_product_id		0x010c
+#define	keyspan_usa19qw_product_id		0x0119
 #define	keyspan_usa19w_product_id		0x0108
 #define	keyspan_usa28_product_id		0x010f
 #define	keyspan_usa28x_product_id		0x0110
@@ -194,10 +205,10 @@
 #define	keyspan_usa49w_product_id		0x010a
 
 
-typedef struct {
+struct keyspan_device_details {
 	/* product ID value */
 	int	product_id;
-	
+
 	enum	{msg_usa26, msg_usa28, msg_usa49} msg_format;
 
 		/* Number of physical ports */
@@ -219,137 +230,190 @@
 		/* Input acknowledge endpoints */
 	int	inack_endpoints[KEYSPAN_MAX_NUM_PORTS];
 
-		/* Output control endpoints */	
+		/* Output control endpoints */
 	int	outcont_endpoints[KEYSPAN_MAX_NUM_PORTS];
 
 		/* Endpoint used for input status */
 	int	instat_endpoint;
 
 		/* Endpoint used for global control functions */
-	int	glocont_endpoint;	
-	
+	int	glocont_endpoint;
+
 	int	(*calculate_baud_rate) (u32 baud_rate, u32 baudclk,
-			u8 *rate_hi, u8 *rate_low, u8 *prescaler);
+			u8 *rate_hi, u8 *rate_low, u8 *prescaler, int portnum);
 	u32	baudclk;
+}; 
+
+/* Now for each device type we setup the device detail
+   structure with the appropriate information (provided
+   in Keyspan's documentation) */
+
+static const struct keyspan_device_details usa18x_device_details = {
+	product_id:		keyspan_usa18x_product_id,
+	msg_format:		msg_usa26,
+	num_ports:		1,
+	indat_endp_flip:	0,
+	outdat_endp_flip:	1,
+	indat_endpoints:	{0x81},
+	outdat_endpoints:	{0x01},
+	inack_endpoints:	{0x85},
+	outcont_endpoints:	{0x05},
+	instat_endpoint:	0x87,
+	glocont_endpoint:	0x07,
+	calculate_baud_rate:	keyspan_usa19w_calc_baud,
+	baudclk:		KEYSPAN_USA18X_BAUDCLK,
+};
+
+static const struct keyspan_device_details usa19_device_details = {
+	product_id:		keyspan_usa19_product_id,
+	msg_format:		msg_usa28,
+	num_ports:		1,
+	indat_endp_flip:	1,
+	outdat_endp_flip:	1,
+	indat_endpoints:	{0x81},
+	outdat_endpoints:	{0x01},
+	inack_endpoints:	{0x83},
+	outcont_endpoints:	{0x03},
+	instat_endpoint:	0x84,
+	glocont_endpoint:	-1,
+	calculate_baud_rate:	keyspan_usa19_calc_baud,
+	baudclk:		KEYSPAN_USA19_BAUDCLK,
+};
+
+static const struct keyspan_device_details usa19qi_device_details = {
+	product_id:		keyspan_usa19qi_product_id,
+	msg_format:		msg_usa28,
+	num_ports:		1,
+	indat_endp_flip:	1,
+	outdat_endp_flip:	1,
+	indat_endpoints:	{0x81},
+	outdat_endpoints:	{0x01},
+	inack_endpoints:	{0x83},
+	outcont_endpoints:	{0x03},
+	instat_endpoint:	0x84,
+	glocont_endpoint:	-1,
+	calculate_baud_rate:	keyspan_usa28_calc_baud,
+	baudclk:		KEYSPAN_USA19_BAUDCLK,
+};
+
+static const struct keyspan_device_details usa19qw_device_details = {
+	product_id:		keyspan_usa19qw_product_id,
+	msg_format:		msg_usa26,
+	num_ports:		1,
+	indat_endp_flip:	0,
+	outdat_endp_flip:	1,
+	indat_endpoints:	{0x81},
+	outdat_endpoints:	{0x01},
+	inack_endpoints:	{0x85},
+	outcont_endpoints:	{0x05},
+	instat_endpoint:	0x87,
+	glocont_endpoint:	0x07,
+	calculate_baud_rate:	keyspan_usa19w_calc_baud,
+	baudclk:		KEYSPAN_USA19W_BAUDCLK,
+};
+
+static const struct keyspan_device_details usa19w_device_details = {
+	product_id:		keyspan_usa19w_product_id,
+	msg_format:		msg_usa26,
+	num_ports:		1,
+	indat_endp_flip:	0,
+	outdat_endp_flip:	1,
+	indat_endpoints:	{0x81},
+	outdat_endpoints:	{0x01},
+	inack_endpoints:	{0x85},
+	outcont_endpoints:	{0x05},
+	instat_endpoint:	0x87,
+	glocont_endpoint:	0x07,
+	calculate_baud_rate:	keyspan_usa19w_calc_baud,
+	baudclk:		KEYSPAN_USA19W_BAUDCLK,
+};
+
+static const struct keyspan_device_details usa28_device_details = {
+	product_id:		keyspan_usa28_product_id,
+	msg_format:		msg_usa28,
+	num_ports:		2,
+	indat_endp_flip:	1,
+	outdat_endp_flip:	1,
+	indat_endpoints:	{0x81, 0x83},
+	outdat_endpoints:	{0x01, 0x03},
+	inack_endpoints:	{0x85, 0x86},
+	outcont_endpoints:	{0x05, 0x06},
+	instat_endpoint:	0x87,
+	glocont_endpoint:	0x07,
+	calculate_baud_rate:	keyspan_usa28_calc_baud,
+	baudclk:		KEYSPAN_USA28_BAUDCLK,		
+};
 
-} keyspan_device_details; 
+static const struct keyspan_device_details usa28x_device_details = {
+	product_id:		keyspan_usa28x_product_id,
+	msg_format:		msg_usa26,
+	num_ports:		2,
+	indat_endp_flip:	0,
+	outdat_endp_flip:	1,
+	indat_endpoints:	{0x81, 0x83},
+	outdat_endpoints:	{0x01, 0x03},
+	inack_endpoints:	{0x85, 0x86},
+	outcont_endpoints:	{0x05, 0x06},
+	instat_endpoint:	0x87,
+	glocont_endpoint:	0x07,
+	calculate_baud_rate:	keyspan_usa19w_calc_baud,
+	baudclk:		KEYSPAN_USA28X_BAUDCLK,
+};
 
-	/* Now for each device type we setup the device detail
-	   structure with the appropriate information (provided
-	   in Keyspan's documentation) */
-
-static const keyspan_device_details usa18x_device_details = {
-	keyspan_usa18x_product_id,	/* product ID */
-       	msg_usa26, 			/* msg type*/
-	1,				/* num ports */
-	0,				/* indat endpoint flip */
-	1,				/* outdat endpoint flip */
-  	{0x81},				/* per port indat */
-  	{0x01},				/* per port outdat */
-	{0x85},				/* per port inack */
-	{0x05},				/* per port outcont */
-	0x87,				/* instat endpoint */
-	0x07,				/* glocont endpoint */
-	keyspan_usa19w_calc_baud,	/* calc baud rate */
-	KEYSPAN_USA18X_BAUDCLK		/* base baud clock */
-};
-
-static const keyspan_device_details usa19_device_details = {
-	keyspan_usa19_product_id,	/* product ID */
-       	msg_usa28, 			/* msg type*/
-	1,				/* num ports */
-	1,				/* indat endpoint flip */
-	1,				/* outdat endpoint flip */
-  	{0x81},				/* per port indat */
-  	{0x01},				/* per port outdat */
-	{0x83},				/* per port inack */
-	{0x03},				/* per port outcont */
-	0x84,				/* instat endpoint */
-	-1,				/* glocont endpoint */
-	keyspan_usa19_calc_baud,	/* calc baud rate */
-	KEYSPAN_USA19_BAUDCLK		/* base baud clock */
-};
-
-static const keyspan_device_details usa19w_device_details = {
-	keyspan_usa19w_product_id,	/* product ID */
-       	msg_usa26, 			/* msg type*/
-	1,				/* num ports */
-	0,				/* indat endpoint flip */
-	1,				/* outdat endpoint flip */
-  	{0x81},				/* per port indat */
-  	{0x01},				/* per port outdat */
-	{0x85},				/* per port inack */
-	{0x05},				/* per port outcont */
-	0x87,				/* instat endpoint */
-	0x07,				/* glocont endpoint */
-	keyspan_usa19w_calc_baud,	/* calc baud rate */
-	KEYSPAN_USA19W_BAUDCLK		/* base baud clock */
-};
-
-static const keyspan_device_details usa28x_device_details = {
-	keyspan_usa28x_product_id,	/* product ID */
-       	msg_usa26, 			/* msg type*/
-	2,				/* num ports */
-	0,				/* indat endpoint flip */
-	1,				/* outdat endpoint flip */
-  	{0x81, 0x83},			/* per port indat */
-  	{0x01, 0x03},			/* per port outdat */
-	{0x85, 0x86},			/* per port inack */
-	{0x05, 0x06},			/* per port outcont */
-	0x87,				/* instat endpoint */
-	0x07,				/* glocont endpoint */
-	keyspan_usa19w_calc_baud,	/* calc baud rate */
-	KEYSPAN_USA28X_BAUDCLK
-};
-
-static const keyspan_device_details usa28xa_device_details = {
-	keyspan_usa28xa_product_id,	/* product ID */
-       	msg_usa26, 			/* msg type*/
-	2,				/* num ports */
-	0,				/* indat endpoint flip */
-	1,				/* outdat endpoint flip */
-  	{0x81, 0x83},			/* per port indat */
-  	{0x01, 0x03},			/* per port outdat */
-	{0x85, 0x86},			/* per port inack */
-	{0x05, 0x06},			/* per port outcont */
-	0x87,				/* instat endpoint */
-	0x07,				/* glocont endpoint */
-	keyspan_usa19w_calc_baud,	/* calc baud rate */
-	KEYSPAN_USA28X_BAUDCLK
-};
-
-	/* We don't need a separate entry for the usa28xb as it appears as a 28x anyway */
-
-static const keyspan_device_details usa49w_device_details = {
-	keyspan_usa49w_product_id,	/* product ID */
-       	msg_usa49, 			/* msg type*/
-	4,				/* num ports */
-	0,				/* indat endpoint flip */
-	0,				/* outdat endpoint flip */
-  	{ 0x81, 0x82, 0x83, 0x84},	/* per port indat */
-  	{ 0x01, 0x02, 0x03, 0x04},	/* per port outdat */
-	{-1, -1, -1, -1},		/* per port inack */
-	{-1, -1, -1, -1},		/* per port outcont */
-	0x87,				/* instat endpoint */
-	0x07,				/* glocont endpoint */
-	keyspan_usa19w_calc_baud,	/* calc baud rate */
-	KEYSPAN_USA49W_BAUDCLK
+static const struct keyspan_device_details usa28xa_device_details = {
+	product_id:		keyspan_usa28xa_product_id,
+	msg_format:		msg_usa26,
+	num_ports:		2,
+	indat_endp_flip:	0,
+	outdat_endp_flip:	1,
+	indat_endpoints:	{0x81, 0x83},
+	outdat_endpoints:	{0x01, 0x03},
+	inack_endpoints:	{0x85, 0x86},
+	outcont_endpoints:	{0x05, 0x06},
+	instat_endpoint:	0x87,
+	glocont_endpoint:	0x07,
+	calculate_baud_rate:	keyspan_usa19w_calc_baud,
+	baudclk:		KEYSPAN_USA28X_BAUDCLK,
+};
+
+/* We don't need a separate entry for the usa28xb as it appears as a 28x anyway */
+
+static const struct keyspan_device_details usa49w_device_details = {
+	product_id:		keyspan_usa49w_product_id,
+	msg_format:		msg_usa49,
+	num_ports:		4,
+	indat_endp_flip:	0,
+	outdat_endp_flip:	0,
+	indat_endpoints:	{0x81, 0x82, 0x83, 0x84},
+	outdat_endpoints:	{0x01, 0x02, 0x03, 0x04},
+	inack_endpoints:	{-1, -1, -1, -1},
+	outcont_endpoints:	{-1, -1, -1, -1},
+	instat_endpoint:	0x87,
+	glocont_endpoint:	0x07,
+	calculate_baud_rate:	keyspan_usa19w_calc_baud,
+	baudclk:		KEYSPAN_USA49W_BAUDCLK,
 };
 
-static const keyspan_device_details *keyspan_devices[] = {
+static const struct keyspan_device_details *keyspan_devices[] = {
 	&usa18x_device_details,
 	&usa19_device_details,
+	&usa19qi_device_details,
+	&usa19qw_device_details,
 	&usa19w_device_details,
+	&usa28_device_details,
 	&usa28x_device_details,
 	&usa28xa_device_details,
+	/* 28xb not required as it renumerates as a 28x */
 	&usa49w_device_details,
-	NULL
+	NULL,
 };
 
 static __devinitdata struct usb_device_id keyspan_ids_combined[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa18x_pre_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19_pre_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_pre_product_id) },
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qi_pre_product_id) },
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_pre_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28_pre_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28x_pre_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xa_pre_product_id) },
@@ -358,6 +422,8 @@
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa18x_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_product_id) },
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qi_product_id) },
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28x_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xa_product_id) },
@@ -368,224 +434,58 @@
 
 MODULE_DEVICE_TABLE(usb, keyspan_ids_combined);
 
-/* Eventually, we will not need separate id tables for each USB
-   ID pattern.  But, for now, it looks like we need slightly different
-   behavior for each match. */
-
-static __devinitdata struct usb_device_id keyspan_usa18x_pre_ids[] = {
+/* usb_device_id table for the pre-firmware download keyspan devices */
+static struct usb_device_id keyspan_pre_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa18x_pre_product_id) },
-	{ }	/* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa19_pre_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19_pre_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa19w_pre_ids[] = {
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qi_pre_product_id) },
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_pre_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_pre_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa28_pre_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28_pre_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa28x_pre_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28x_pre_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa28xa_pre_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xa_pre_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa28xb_pre_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xb_pre_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa49w_pre_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49w_pre_product_id) },
 	{ } /* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id keyspan_usa18x_ids[] = {
+static struct usb_device_id keyspan_1port_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa18x_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa19_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa19w_ids[] = {
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qi_product_id) },
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_product_id) },
 	{ } /* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id keyspan_usa28_ids[] = {
+static struct usb_device_id keyspan_2port_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa28x_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28x_product_id) },
-	{ } /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id keyspan_usa28xa_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xa_product_id) },
 	{ } /* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id keyspan_usa49w_ids[] = {
+static struct usb_device_id keyspan_4port_ids[] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49w_product_id) },
 	{ } /* Terminating entry */
 };
 
-    /* Structs for the devices, pre and post renumeration. */
-static struct usb_serial_device_type keyspan_usa18x_pre_device = {
-	name:			"Keyspan USA18X - (without firmware)",
-	id_table:		keyspan_usa18x_pre_ids,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		1,
-	startup:		keyspan_fake_startup	
-};
-
-static struct usb_serial_device_type keyspan_usa19_pre_device = {
-	name:			"Keyspan USA19 - (without firmware)",
-	id_table:		keyspan_usa19_pre_ids,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		1,
-	startup:		keyspan_fake_startup	
-};
-
-
-static struct usb_serial_device_type keyspan_usa19w_pre_device = {
-	name:			"Keyspan USA19W - (without firmware)",
-	id_table:		keyspan_usa19w_pre_ids,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		1,
-	startup:		keyspan_fake_startup	
-};
-
-
-static struct usb_serial_device_type keyspan_usa28_pre_device = {
-	name:			"Keyspan USA28 - (without firmware)",
-	id_table:		keyspan_usa28_pre_ids,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		2,
-	startup:		keyspan_fake_startup	
-};
-
-static struct usb_serial_device_type keyspan_usa28x_pre_device = {
-	name:			"Keyspan USA28X - (without firmware)",
-	id_table:		keyspan_usa28x_pre_ids,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		2,
-	startup:		keyspan_fake_startup	
-};
-
-static struct usb_serial_device_type keyspan_usa28xa_pre_device = {
-	name:			"Keyspan USA28XA - (without firmware)",
-	id_table:		keyspan_usa28xa_pre_ids,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
+/* Structs for the devices, pre and post renumeration. */
+static struct usb_serial_device_type keyspan_pre_device = {
+	owner:			THIS_MODULE,
+	name:			"Keyspan - (without firmware)",
+	id_table:		keyspan_pre_ids,
 	num_interrupt_in:	NUM_DONT_CARE,
 	num_bulk_in:		NUM_DONT_CARE,
 	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		2,
-	startup:		keyspan_fake_startup	
-};
-
-static struct usb_serial_device_type keyspan_usa28xb_pre_device = {
-	name:			"Keyspan USA28XB - (without firmware)",
-	id_table:		keyspan_usa28xb_pre_ids,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		2,
-	startup:		keyspan_fake_startup	
-};
-
-static struct usb_serial_device_type keyspan_usa49w_pre_device = {
-	name:			"Keyspan USA49W - (without firmware)",
-	id_table:		keyspan_usa49w_pre_ids,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		4,
-	startup:		keyspan_fake_startup	
-};
-
-static struct usb_serial_device_type keyspan_usa18x_device = {
-	name:			"Keyspan USA18X",
-	id_table:		keyspan_usa18x_ids,
-	needs_interrupt_in:	DONT_CARE,	
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		3,
-	num_bulk_out:		4,
 	num_ports:		1,
-	open:			keyspan_open,
-	close:			keyspan_close,
-	write:			keyspan_write,
-	write_room:		keyspan_write_room,
-	//write_bulk_callback: 	Not used - we define our own herbs
-	//read_int_callback:	keyspan_usa26_read_int_callback,
-	chars_in_buffer:	keyspan_chars_in_buffer,
-	throttle:		keyspan_rx_throttle,
-	unthrottle:		keyspan_rx_unthrottle,
-	ioctl:			keyspan_ioctl,
-	set_termios:		keyspan_set_termios,
-	break_ctl:		keyspan_break_ctl,
-	startup:		keyspan_startup,
-	shutdown:		keyspan_shutdown,
+	startup:		keyspan_fake_startup,
 };
 
-static struct usb_serial_device_type keyspan_usa19_device = {
-	name:			"Keyspan USA19",
-	id_table:		keyspan_usa19_ids,
-	needs_interrupt_in:	DONT_CARE,	
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
+static struct usb_serial_device_type keyspan_1port_device = {
+	owner:			THIS_MODULE,
+	name:			"Keyspan 1 port adapter",
+	id_table:		keyspan_1port_ids,
 	num_interrupt_in:	NUM_DONT_CARE,
 	num_bulk_in:		3,
 	num_bulk_out:		4,
@@ -594,8 +494,6 @@
 	close:			keyspan_close,
 	write:			keyspan_write,
 	write_room:		keyspan_write_room,
-//	write_bulk_callback: 	keyspan_write_bulk_callback,
-//	read_int_callback:	keyspan_usa28_read_int_callback,
 	chars_in_buffer:	keyspan_chars_in_buffer,
 	throttle:		keyspan_rx_throttle,
 	unthrottle:		keyspan_rx_unthrottle,
@@ -606,85 +504,10 @@
 	shutdown:		keyspan_shutdown,
 };
 
-
-static struct usb_serial_device_type keyspan_usa19w_device = {
-	name:			"Keyspan USA19W",
-	id_table:		keyspan_usa19w_ids,
-	needs_interrupt_in:	DONT_CARE,	
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		3,
-	num_bulk_out:		4,
-	num_ports:		1,
-	open:			keyspan_open,
-	close:			keyspan_close,
-	write:			keyspan_write,
-	write_room:		keyspan_write_room,
-	//write_bulk_callback: 	Not used - we define our own herbs
-	//read_int_callback:	keyspan_usa26_read_int_callback,
-	chars_in_buffer:	keyspan_chars_in_buffer,
-	throttle:		keyspan_rx_throttle,
-	unthrottle:		keyspan_rx_unthrottle,
-	ioctl:			keyspan_ioctl,
-	set_termios:		keyspan_set_termios,
-	break_ctl:		keyspan_break_ctl,
-	startup:		keyspan_startup,
-	shutdown:		keyspan_shutdown,
-};
-
-
-static struct usb_serial_device_type keyspan_usa28_device = {
-	name:			"Keyspan USA28",
-	id_table:		keyspan_usa28_ids,
-	needs_interrupt_in:	DONT_CARE,	
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		2,
-	open:			keyspan_open,
-	close:			keyspan_close,
-	throttle:		keyspan_rx_throttle,
-	unthrottle:		keyspan_rx_unthrottle,
-	set_termios:		keyspan_set_termios,
-};
-
-
-static struct usb_serial_device_type keyspan_usa28x_device = {
-	name:			"Keyspan USA28X/XB",
-	id_table:		keyspan_usa28x_ids,
-	needs_interrupt_in:	DONT_CARE,	
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		2,
-	open:			keyspan_open,
-	close:			keyspan_close,
-	write:			keyspan_write,
-	write_room:		keyspan_write_room,
-//	write_bulk_callback: 	keyspan_write_bulk_callback,
-//	read_int_callback:	keyspan_usa26_read_int_callback,
-	chars_in_buffer:	keyspan_chars_in_buffer,
-	throttle:		keyspan_rx_throttle,
-	unthrottle:		keyspan_rx_unthrottle,
-	ioctl:			keyspan_ioctl,
-	set_termios:		keyspan_set_termios,
-	break_ctl:		keyspan_break_ctl,
-	startup:		keyspan_startup,
-	shutdown:		keyspan_shutdown,
-
-};
-
-static struct usb_serial_device_type keyspan_usa28xa_device = {
-	name:			"Keyspan USA28XA",
-	id_table:		keyspan_usa28xa_ids,
-	needs_interrupt_in:	DONT_CARE,	
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
+static struct usb_serial_device_type keyspan_2port_device = {
+	owner:			THIS_MODULE,
+	name:			"Keyspan 2 port adapter",
+	id_table:		keyspan_2port_ids,
 	num_interrupt_in:	NUM_DONT_CARE,
 	num_bulk_in:		NUM_DONT_CARE,
 	num_bulk_out:		NUM_DONT_CARE,
@@ -693,8 +516,6 @@
 	close:			keyspan_close,
 	write:			keyspan_write,
 	write_room:		keyspan_write_room,
-//	write_bulk_callback: 	keyspan_write_bulk_callback,
-//	read_int_callback:	keyspan_usa26_read_int_callback,
 	chars_in_buffer:	keyspan_chars_in_buffer,
 	throttle:		keyspan_rx_throttle,
 	unthrottle:		keyspan_rx_unthrottle,
@@ -703,15 +524,12 @@
 	break_ctl:		keyspan_break_ctl,
 	startup:		keyspan_startup,
 	shutdown:		keyspan_shutdown,
-
 };
 
-static struct usb_serial_device_type keyspan_usa49w_device = {
-	name:			"Keyspan USA49W",
-	id_table:		keyspan_usa49w_ids,
-	needs_interrupt_in:	DONT_CARE,	
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
+static struct usb_serial_device_type keyspan_4port_device = {
+	owner:			THIS_MODULE,
+	name:			"Keyspan 4 port adapter",
+	id_table:		keyspan_4port_ids,
 	num_interrupt_in:	NUM_DONT_CARE,
 	num_bulk_in:		5,
 	num_bulk_out:		5,
@@ -720,8 +538,6 @@
 	close:			keyspan_close,
 	write:			keyspan_write,
 	write_room:		keyspan_write_room,
-	//write_bulk_callback: 	Not used - we define our own herbs
-	//read_int_callback:	keyspan_usa26_read_int_callback,
 	chars_in_buffer:	keyspan_chars_in_buffer,
 	throttle:		keyspan_rx_throttle,
 	unthrottle:		keyspan_rx_unthrottle,
@@ -732,5 +548,4 @@
 	shutdown:		keyspan_shutdown,
 };
 
-
 #endif
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_pda.c linux-2.4.19/drivers/usb/serial/keyspan_pda.c
--- linux-2.4.19.old/drivers/usb/serial/keyspan_pda.c	Thu Oct 11 08:42:47 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_pda.c	Mon Nov 25 12:27:09 2002
@@ -68,19 +68,16 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/tqueue.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -157,25 +154,21 @@
 
 MODULE_DEVICE_TABLE (usb, id_table_combined);
 
-static __devinitdata struct usb_device_id id_table_std [] = {
+static struct usb_device_id id_table_std [] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, KEYSPAN_PDA_ID) },
 	{ }						/* Terminating entry */
 };
 
 #ifdef KEYSPAN
-static __devinitdata struct usb_device_id id_table_fake [] = {
+static struct usb_device_id id_table_fake [] = {
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, KEYSPAN_PDA_FAKE_ID) },
 	{ }						/* Terminating entry */
 };
 #endif
 
 #ifdef XIRCOM
-static __devinitdata struct usb_device_id id_table_fake_xircom [] = {
+static struct usb_device_id id_table_fake_xircom [] = {
         { USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID) },
-        { }                                             
-};
-
-static __devinitdata struct usb_device_id id_table_fake_entregra [] = {
         { USB_DEVICE(ENTREGRA_VENDOR_ID, ENTREGRA_FAKE_ID) },
         { }                                             
 };
@@ -197,26 +190,28 @@
 	/* wake up other tty processes */
 	wake_up_interruptible( &tty->write_wait );
 	/* For 2.2.16 backport -- wake_up_interruptible( &tty->poll_wait ); */
-	MOD_DEC_USE_COUNT;
 }
 
 static void keyspan_pda_request_unthrottle( struct usb_serial *serial )
 {
+	int result;
 
 	dbg(" request_unthrottle");
 	/* ask the device to tell us when the tx buffer becomes
 	   sufficiently empty */
-	usb_control_msg(serial->dev, 
-			     usb_sndctrlpipe(serial->dev, 0),
-			     7, /* request_unthrottle */
-			     USB_TYPE_VENDOR | USB_RECIP_INTERFACE
-			     | USB_DIR_OUT,
-			     16, /* value: threshold */
-			     0, /* index */
-			     NULL,
-			     0,
-			     2*HZ);
-	MOD_DEC_USE_COUNT;
+	result = usb_control_msg(serial->dev, 
+				 usb_sndctrlpipe(serial->dev, 0),
+				 7, /* request_unthrottle */
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE
+				 | USB_DIR_OUT,
+				 16, /* value: threshold */
+				 0, /* index */
+				 NULL,
+				 0,
+				 2*HZ);
+	if (result < 0)
+		dbg("%s - error %d from usb_control_msg", 
+		    __FUNCTION__, result);
 }
 
 
@@ -265,9 +260,7 @@
 			tty = serial->port[0].tty;
 			priv->tx_throttled = 0;
 			/* queue up a wakeup at scheduler time */
-			MOD_INC_USE_COUNT;
-			if (schedule_task(&priv->wakeup_task) == 0)
-				MOD_DEC_USE_COUNT;
+			schedule_task(&priv->wakeup_task);
 			break;
 		default:
 			break;
@@ -345,14 +338,19 @@
 {
 	struct usb_serial *serial = port->serial;
 	int value;
+	int result;
+
 	if (break_state == -1)
 		value = 1; /* start break */
 	else
 		value = 0; /* clear break */
-	usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
-			4, /* set break */
-			USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-			value, 0, NULL, 0, 2*HZ);
+	result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
+				4, /* set break */
+				USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				value, 0, NULL, 0, 2*HZ);
+	if (result < 0)
+		dbg("%s - error %d from usb_control_msg", 
+		    __FUNCTION__, result);
 	/* there is something funky about this.. the TCSBRK that 'cu' performs
 	   ought to translate into a break_ctl(-1),break_ctl(0) pair HZ/4
 	   seconds apart, but it feels like the break sent isn't as long as it
@@ -606,9 +604,7 @@
 
 	if (request_unthrottle) {
 		priv->tx_throttled = 1; /* block writers */
-		MOD_INC_USE_COUNT;
-		if (schedule_task(&priv->unthrottle_task) == 0)
-			MOD_DEC_USE_COUNT;
+		schedule_task(&priv->unthrottle_task);
 	}
 
 	rc = count;
@@ -635,9 +631,7 @@
 	}
 	
 	/* queue up a wakeup at scheduler time */
-	MOD_INC_USE_COUNT;
-	if (schedule_task(&priv->wakeup_task) == 0)
-		MOD_DEC_USE_COUNT;
+	schedule_task(&priv->wakeup_task);
 }
 
 
@@ -674,62 +668,45 @@
 	int rc = 0;
 	struct keyspan_pda_private *priv;
 
-	down (&port->sem);
-
-	MOD_INC_USE_COUNT;
-	++port->open_count;
-
-	if (!port->active) {
-		port->active = 1;
- 
-		/* find out how much room is in the Tx ring */
-		rc = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
-				     6, /* write_room */
-				     USB_TYPE_VENDOR | USB_RECIP_INTERFACE
-				     | USB_DIR_IN,
-				     0, /* value */
-				     0, /* index */
-				     &room,
-				     1,
-				     2*HZ);
-		if (rc < 0) {
-			dbg(__FUNCTION__" - roomquery failed");
-			goto error;
-		}
-		if (rc == 0) {
-			dbg(__FUNCTION__" - roomquery returned 0 bytes");
-			rc = -EIO;
-			goto error;
-		}
-		priv = (struct keyspan_pda_private *)(port->private);
-		priv->tx_room = room;
-		priv->tx_throttled = room ? 0 : 1;
-
-		/* the normal serial device seems to always turn on DTR and RTS here,
-		   so do the same */
-		if (port->tty->termios->c_cflag & CBAUD)
-			keyspan_pda_set_modem_info(serial, (1<<7) | (1<<2) );
-		else
-			keyspan_pda_set_modem_info(serial, 0);
+	/* find out how much room is in the Tx ring */
+	rc = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
+			     6, /* write_room */
+			     USB_TYPE_VENDOR | USB_RECIP_INTERFACE
+			     | USB_DIR_IN,
+			     0, /* value */
+			     0, /* index */
+			     &room,
+			     1,
+			     2*HZ);
+	if (rc < 0) {
+		dbg("%s - roomquery failed", __FUNCTION__);
+		goto error;
+	}
+	if (rc == 0) {
+		dbg("%s - roomquery returned 0 bytes", __FUNCTION__);
+		rc = -EIO;
+		goto error;
+	}
+	priv = (struct keyspan_pda_private *)(port->private);
+	priv->tx_room = room;
+	priv->tx_throttled = room ? 0 : 1;
 
-		/*Start reading from the device*/
-		port->interrupt_in_urb->dev = serial->dev;
-		rc = usb_submit_urb(port->interrupt_in_urb);
-		if (rc) {
-			dbg(__FUNCTION__" - usb_submit_urb(read int) failed");
-			goto error;
-		}
+	/* the normal serial device seems to always turn on DTR and RTS here,
+	   so do the same */
+	if (port->tty->termios->c_cflag & CBAUD)
+		keyspan_pda_set_modem_info(serial, (1<<7) | (1<<2) );
+	else
+		keyspan_pda_set_modem_info(serial, 0);
 
+	/*Start reading from the device*/
+	port->interrupt_in_urb->dev = serial->dev;
+	rc = usb_submit_urb(port->interrupt_in_urb);
+	if (rc) {
+		dbg("%s - usb_submit_urb(read int) failed", __FUNCTION__);
+		goto error;
 	}
 
-
-	up (&port->sem);
-	return rc;
 error:
-	--port->open_count;
-	port->active = 0;
-	MOD_DEC_USE_COUNT;
-	up (&port->sem);
 	return rc;
 }
 
@@ -738,26 +715,15 @@
 {
 	struct usb_serial *serial = port->serial;
 
-	down (&port->sem);
-
-	--port->open_count;
+	if (serial->dev) {
+		/* the normal serial device seems to always shut off DTR and RTS now */
+		if (port->tty->termios->c_cflag & HUPCL)
+			keyspan_pda_set_modem_info(serial, 0);
 
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			/* the normal serial device seems to always shut off DTR and RTS now */
-			if (port->tty->termios->c_cflag & HUPCL)
-				keyspan_pda_set_modem_info(serial, 0);
-
-			/* shutdown our bulk reads and writes */
-			usb_unlink_urb (port->write_urb);
-			usb_unlink_urb (port->interrupt_in_urb);
-		}
-		port->active = 0;
-		port->open_count = 0;
+		/* shutdown our bulk reads and writes */
+		usb_unlink_urb (port->write_urb);
+		usb_unlink_urb (port->interrupt_in_urb);
 	}
-
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
 }
 
 
@@ -780,7 +746,7 @@
 		record = &xircom_pgs_firmware[0];
 #endif
 	if (record == NULL) {
-		err(__FUNCTION__": unknown vendor, aborting.");
+		err("%s: unknown vendor, aborting.", __FUNCTION__);
 		return -ENODEV;
 	}
 
@@ -831,81 +797,59 @@
 
 static void keyspan_pda_shutdown (struct usb_serial *serial)
 {
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 	
-	while (serial->port[0].open_count > 0) {
-		keyspan_pda_close (&serial->port[0], NULL);
-	}
 	kfree(serial->port[0].private);
 }
 
 #ifdef KEYSPAN
 static struct usb_serial_device_type keyspan_pda_fake_device = {
-	name:			"Keyspan PDA - (prerenumeration)",
-	id_table:		id_table_fake,
-	needs_interrupt_in:	DONT_CARE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		DONT_CARE,
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		1,
-	startup:		keyspan_pda_fake_startup,
+	.owner =		THIS_MODULE,
+	.name =			"Keyspan PDA - (prerenumeration)",
+	.id_table =		id_table_fake,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		NUM_DONT_CARE,
+	.num_bulk_out =		NUM_DONT_CARE,
+	.num_ports =		1,
+	.startup =		keyspan_pda_fake_startup,
 };
 #endif
 
 #ifdef XIRCOM
 static struct usb_serial_device_type xircom_pgs_fake_device = {
-        name:                   "Xircom PGS - (prerenumeration)",
-        id_table:               id_table_fake_xircom,
-        needs_interrupt_in:     DONT_CARE,
-        needs_bulk_in:          DONT_CARE,
-        needs_bulk_out:         DONT_CARE,
-        num_interrupt_in:       NUM_DONT_CARE,
-        num_bulk_in:            NUM_DONT_CARE,
-        num_bulk_out:           NUM_DONT_CARE,
-        num_ports:              1,
-        startup:                keyspan_pda_fake_startup,
-};
-
-static struct usb_serial_device_type entregra_pgs_fake_device = {
-        name:                   "Entregra PGS - (prerenumeration)",
-        id_table:               id_table_fake_entregra,
-        needs_interrupt_in:     DONT_CARE,
-        needs_bulk_in:          DONT_CARE,
-        needs_bulk_out:         DONT_CARE,
-        num_interrupt_in:       NUM_DONT_CARE,
-        num_bulk_in:            NUM_DONT_CARE,
-        num_bulk_out:           NUM_DONT_CARE,
-        num_ports:              1,
-        startup:                keyspan_pda_fake_startup,
+	.owner =		THIS_MODULE,
+	.name =			"Xircom / Entregra PGS - (prerenumeration)",
+	.id_table =		id_table_fake_xircom,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		NUM_DONT_CARE,
+	.num_bulk_out =		NUM_DONT_CARE,
+	.num_ports =		1,
+	.startup =		keyspan_pda_fake_startup,
 };
 #endif
 
 static struct usb_serial_device_type keyspan_pda_device = {
-	name:			"Keyspan PDA",
-	id_table:		id_table_std,
-	needs_interrupt_in:	MUST_HAVE,
-	needs_bulk_in:		DONT_CARE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	1,
-	num_bulk_in:		0,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			keyspan_pda_open,
-	close:			keyspan_pda_close,
-	write:			keyspan_pda_write,
-	write_room:		keyspan_pda_write_room,
-	write_bulk_callback: 	keyspan_pda_write_bulk_callback,
-	read_int_callback:	keyspan_pda_rx_interrupt,
-	chars_in_buffer:	keyspan_pda_chars_in_buffer,
-	throttle:		keyspan_pda_rx_throttle,
-	unthrottle:		keyspan_pda_rx_unthrottle,
-	ioctl:			keyspan_pda_ioctl,
-	set_termios:		keyspan_pda_set_termios,
-	break_ctl:		keyspan_pda_break_ctl,
-	startup:		keyspan_pda_startup,
-	shutdown:		keyspan_pda_shutdown,
+	.owner =		THIS_MODULE,
+	.name =			"Keyspan PDA",
+	.id_table =		id_table_std,
+	.num_interrupt_in =	1,
+	.num_bulk_in =		0,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			keyspan_pda_open,
+	.close =		keyspan_pda_close,
+	.write =		keyspan_pda_write,
+	.write_room =		keyspan_pda_write_room,
+	.write_bulk_callback = 	keyspan_pda_write_bulk_callback,
+	.read_int_callback =	keyspan_pda_rx_interrupt,
+	.chars_in_buffer =	keyspan_pda_chars_in_buffer,
+	.throttle =		keyspan_pda_rx_throttle,
+	.unthrottle =		keyspan_pda_rx_unthrottle,
+	.ioctl =		keyspan_pda_ioctl,
+	.set_termios =		keyspan_pda_set_termios,
+	.break_ctl =		keyspan_pda_break_ctl,
+	.startup =		keyspan_pda_startup,
+	.shutdown =		keyspan_pda_shutdown,
 };
 
 
@@ -917,7 +861,6 @@
 #endif
 #ifdef XIRCOM
 	usb_serial_register (&xircom_pgs_fake_device);
-	usb_serial_register (&entregra_pgs_fake_device);
 #endif
 	info(DRIVER_DESC " " DRIVER_VERSION);
 	return 0;
@@ -931,7 +874,6 @@
 	usb_serial_deregister (&keyspan_pda_fake_device);
 #endif
 #ifdef XIRCOM
-	usb_serial_deregister (&entregra_pgs_fake_device);
 	usb_serial_deregister (&xircom_pgs_fake_device);
 #endif
 }
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa18x_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa18x_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa18x_fw.h	Wed Oct 10 00:15:02 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa18x_fw.h	Mon Nov 25 12:27:09 2002
@@ -1,341 +1,345 @@
 /* keyspan_usa18x_fw.h
-  
-   Generated from Keyspan firmware image usa16code.h Sat Oct  6 12:16:35 EST 2001
-   This firmware is for the Keyspan USA-18X Serial Adaptor
 
-   "The firmware contained herein as keyspan_usa18x_fw.h is
-   Copyright (C) 1999-2001 Keyspan, A division of InnoSys Incorporated
-   ("Keyspan"), as an unpublished work.  This notice does not imply
-   unrestricted or public access to this firmware which is a trade secret of
-   Keyspan, and which may not be reproduced, used, sold or transferred to any
-   third party without Keyspan's prior written consent.  All Rights Reserved.
+	The firmware contained herein as keyspan_usa18x_fw.h is
 
-   This firmware may not be modified and may only be used with the Keyspan 
-   USA-18X Serial Adapter.  Distribution and/or Modification of the
-   keyspan.c driver which includes this firmware, in whole or in part,
-   requires the inclusion of this statement."
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
 
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
+
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
 */
 
 static const struct ezusb_hex_record keyspan_usa18x_firmware[] = {
- {0x0033,  3, { 0x02, 0x13, 0xab}},
+ {0x0033,  3, { 0x02, 0x12, 0xf7}},
  {0x0003, 16, { 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0}},
  {0x0013, 16, { 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x90}},
  {0x0023, 15, { 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x07, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x22}},
- {0x0046, 16, { 0x30, 0x09, 0x18, 0x12, 0x13, 0x33, 0xef, 0xc3, 0x95, 0x3c, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
+ {0x0046, 16, { 0x30, 0x09, 0x18, 0x12, 0x13, 0x1b, 0xef, 0xc3, 0x95, 0x3c, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
  {0x0056, 16, { 0x7f, 0xbf, 0x74, 0x01, 0xf0, 0xc2, 0x09, 0xc2, 0x00, 0x80, 0x77, 0x30, 0x03, 0x3b, 0x90, 0x7f}},
- {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x33, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
+ {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x1b, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
  {0x0076, 16, { 0x40, 0xe0, 0x13, 0x92, 0x09, 0x90, 0x7f, 0xc7, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60}},
- {0x0086, 16, { 0x0f, 0xf5, 0x08, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x41, 0x12, 0x0c, 0xca}},
+ {0x0086, 16, { 0x0f, 0xf5, 0x08, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x41, 0x12, 0x0c, 0xba}},
  {0x0096, 16, { 0xc2, 0x03, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0x80, 0x39, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x32}},
- {0x00a6, 16, { 0x12, 0x13, 0x33, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x09}},
+ {0x00a6, 16, { 0x12, 0x13, 0x1b, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x09}},
  {0x00b6, 16, { 0x90, 0x7f, 0xc9, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d}},
- {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0xc1, 0x12, 0x0c, 0xca, 0xd2, 0x03, 0xe4, 0x90, 0x7f}},
- {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x66, 0x53, 0x36, 0x80, 0x12}},
- {0x00e6, 16, { 0x13, 0x3f, 0xef, 0x42, 0x36, 0x12, 0x11, 0xed, 0x8f, 0x19, 0xef, 0xc3, 0x95, 0x3a, 0x50, 0x0f}},
- {0x00f6, 16, { 0x12, 0x13, 0x1b, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x36, 0x20, 0xe7, 0x03, 0x30, 0x0b, 0x61, 0xc2}},
+ {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0xc1, 0x12, 0x0c, 0xba, 0xd2, 0x03, 0xe4, 0x90, 0x7f}},
+ {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x60, 0x12, 0x11, 0xd6, 0x8f}},
+ {0x00e6, 16, { 0x19, 0x12, 0x13, 0x27, 0x8f, 0x36, 0xe5, 0x19, 0xc3, 0x95, 0x3a, 0x50, 0x0f, 0x12, 0x12, 0xeb}},
+ {0x00f6, 16, { 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x36, 0x20, 0xe7, 0x03, 0x30, 0x0b, 0x5e, 0xc2, 0x0b, 0xe5, 0x19}},
  {0x0036, 12, { 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22}},
  {0x0043,  3, { 0x02, 0x13, 0x00}},
- {0x0000,  3, { 0x02, 0x0e, 0x10}},
- {0x0106, 64, { 0x0b, 0xe5, 0x19, 0x70, 0x04, 0xf5, 0x36, 0x80, 0x57, 0x12, 0x13, 0x3f, 0xef, 0x42, 0x36, 0xe5, 0x36,
-  0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08,
-  0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x80, 0xaf, 0x36, 0x12, 0x0f, 0x5b, 0xe5,
-  0x19, 0x25, 0xe0, 0x90, 0x7f, 0xb7, 0xf0, 0x80, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40}},
- {0x0146, 64, { 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08, 0xe4, 0x90, 0x7e, 0x80, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75,
-  0x0c, 0x7e, 0x75, 0x0d, 0x81, 0x12, 0x0c, 0xef, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90,
-  0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x05, 0x03, 0x02, 0x03, 0xc5, 0xc2, 0x05, 0xe4, 0xf5,
-  0x18, 0x74, 0x40, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5}},
- {0x0186, 64, { 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef,
-  0x12, 0x0e, 0xe2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x68,
-  0x90, 0x7e, 0x03, 0xe0, 0x60, 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xc8, 0x7f, 0x03, 0x7d,
-  0xcd, 0x12, 0x11, 0xc8, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0}},
- {0x01c6, 64, { 0x00, 0xe5, 0x46, 0xf0, 0xe4, 0x90, 0x7e, 0x13, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12,
-  0x10, 0x4c, 0x90, 0x7e, 0x02, 0xe0, 0xff, 0x12, 0x10, 0x72, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0,
-  0xfd, 0x12, 0x11, 0xc8, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xc8, 0x43, 0x46, 0x80, 0x90, 0x7f,
-  0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12}},
- {0x0206, 64, { 0xf0, 0xe5, 0x40, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x03, 0xe0, 0x70, 0x06, 0x90, 0x7e,
-  0x13, 0xe0, 0x70, 0x08, 0xe4, 0x90, 0x7e, 0x13, 0xf0, 0x75, 0x25, 0xff, 0x90, 0x7e, 0x05, 0xe0,
-  0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x44, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0,
-  0x00, 0xe5, 0x44, 0xf0, 0x90, 0x7e, 0x07, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43}},
- {0x0246, 64, { 0x42, 0x80, 0x80, 0x03, 0x53, 0x42, 0x7f, 0x53, 0x42, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43,
-  0x42, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x10, 0xbe, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x10, 0xe4,
-  0xaf, 0x42, 0x12, 0x10, 0x98, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x08, 0x53, 0x42, 0x7f, 0xaf, 0x42,
-  0x12, 0x10, 0x98, 0x90, 0x7e, 0x0c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46}},
- {0x0286, 64, { 0x02, 0x80, 0x03, 0x53, 0x46, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46,
-  0xf0, 0x90, 0x7e, 0x0e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x01, 0x80, 0x03,
-  0x53, 0x46, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90,
-  0x7e, 0x12, 0xe0, 0xf5, 0x3a, 0xa3, 0xe0, 0x13, 0x92, 0x0d, 0xa3, 0xe0, 0xf5, 0x3c, 0xa3}},
- {0x02c6, 64, { 0xe0, 0x60, 0x05, 0x43, 0x46, 0x10, 0x80, 0x03, 0x53, 0x46, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0,
-  0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x44, 0xbf, 0x90,
-  0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x11, 0xf0, 0x12, 0x13, 0x0f, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3e}},
- {0x0306, 64, { 0xfd, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xc8, 0xe4, 0xf5, 0x2a, 0xf5, 0x29, 0xd2, 0x07, 0x90, 0x7e,
-  0x17, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x02, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xc8, 0x75, 0x29,
-  0x01, 0xd2, 0x07, 0x90, 0x7e, 0x18, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5,
-  0x40, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11}},
- {0x0346, 64, { 0x43, 0x44, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
-  0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f, 0x53, 0x3e, 0xfe, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xc8,
-  0x75, 0x2b, 0x01, 0xd2, 0x07, 0x90, 0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x01, 0xe4, 0xff,
-  0xad, 0x3e, 0x12, 0x11, 0xc8, 0xe4, 0xf5, 0x2b, 0xd2, 0x07, 0x90, 0x7e, 0x1c, 0xe0, 0x60}},
- {0x0386, 64, { 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
-  0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x0b, 0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x2c, 0x01, 0xe4,
-  0xf5, 0x38, 0xd2, 0x07, 0x90, 0x7e, 0x1f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0,
-  0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0, 0x74, 0x35, 0xf0, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30}},
- {0x03c6, 64, { 0x1a, 0x52, 0xe5, 0x38, 0x60, 0x02, 0x15, 0x38, 0x20, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40,
-  0x04, 0x15, 0x13, 0x80, 0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xd2, 0x13, 0x12, 0x13, 0x0f,
-  0xef, 0x54, 0x01, 0xf5, 0x19, 0x65, 0x2a, 0x60, 0x05, 0x85, 0x19, 0x2a, 0xd2, 0x07, 0x12, 0x13,
-  0x4b, 0xef, 0x54, 0x80, 0xf5, 0x19, 0x65, 0x26, 0x60, 0x05, 0x85, 0x19, 0x26, 0xd2, 0x07}},
- {0x0406, 64, { 0x30, 0x0d, 0x11, 0x12, 0x13, 0x4b, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x25, 0x60, 0x05, 0x85, 0x19,
-  0x25, 0xd2, 0x07, 0x20, 0x1b, 0x03, 0x02, 0x07, 0xf4, 0x30, 0x0a, 0x18, 0x12, 0x13, 0x87, 0xef,
-  0xc3, 0x95, 0x3d, 0x40, 0x03, 0x02, 0x04, 0xb2, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0xc2, 0x0a,
-  0xc2, 0x00, 0x80, 0x77, 0x30, 0x04, 0x3b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x6d, 0x12}},
- {0x0446, 64, { 0x13, 0x87, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f,
-  0xcb, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d, 0x7f, 0x41,
-  0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x41, 0x12, 0x0d, 0x14, 0xc2, 0x04, 0xe4, 0x90, 0x7f, 0xcb, 0xf0,
-  0x80, 0x39, 0x90, 0x7f, 0xcc, 0xe0, 0x20, 0xe1, 0x32, 0x12, 0x13, 0x87, 0xef, 0xc3, 0x94}},
- {0x0486, 64, { 0x40, 0x50, 0x29, 0x90, 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcd, 0xe0, 0x14, 0xf5, 0x19,
-  0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7c, 0x7f, 0xc1, 0x75, 0x0c, 0x7c, 0x75, 0x0d,
-  0xc1, 0x12, 0x0d, 0x14, 0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xba, 0xe0, 0x30,
-  0xe1, 0x03, 0x02, 0x05, 0x40, 0x53, 0x37, 0x80, 0x12, 0x13, 0x93, 0xef, 0x42, 0x37, 0x12}},
- {0x04c6, 64, { 0x12, 0x37, 0x8f, 0x19, 0xef, 0xc3, 0x95, 0x3b, 0x50, 0x0f, 0x12, 0x13, 0x6f, 0xef, 0x30, 0xe0, 0x08,
-  0xe5, 0x37, 0x20, 0xe7, 0x03, 0x30, 0x0c, 0x61, 0xc2, 0x0c, 0xe5, 0x19, 0x70, 0x04, 0xf5, 0x37,
-  0x80, 0x57, 0x12, 0x13, 0x93, 0xef, 0x42, 0x37, 0xe5, 0x37, 0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3,
-  0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e, 0x7d, 0x7f, 0x80, 0x75}},
- {0x0506, 64, { 0x0c, 0x7d, 0x75, 0x0d, 0x80, 0xaf, 0x37, 0x12, 0x0f, 0x94, 0xe5, 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xbb,
-  0xf0, 0x80, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08,
-  0xe4, 0x90, 0x7d, 0x80, 0xf0, 0x7e, 0x7d, 0x7f, 0x81, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x81, 0x12,
-  0x0d, 0x39, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xbb, 0xf0, 0x90, 0x7f, 0xd0, 0xe0, 0x30, 0xe1}},
- {0x0546, 64, { 0x06, 0x20, 0x06, 0x03, 0x02, 0x07, 0x9f, 0xc2, 0x06, 0xe4, 0xf5, 0x18, 0x74, 0xc0, 0x25, 0x18, 0xf5,
-  0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e,
-  0x79, 0x20, 0x24, 0x20, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e, 0xe2, 0x05, 0x18, 0xe5,
-  0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x20, 0xe0, 0x60, 0x68, 0x90, 0x7e, 0x23, 0xe0, 0x60}},
- {0x0586, 64, { 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x12, 0x12, 0x7f, 0x03, 0x7d, 0xcd, 0x12, 0x12, 0x12, 0x43, 0x47,
-  0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0xe4, 0x90, 0x7e,
-  0x33, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x21, 0xe0, 0xff, 0x12, 0x11, 0x30, 0x90, 0x7e, 0x22, 0xe0,
-  0xff, 0x12, 0x11, 0x56, 0x7f, 0x01, 0x90, 0x7e, 0x31, 0xe0, 0xfd, 0x12, 0x12, 0x12, 0x7f}},
- {0x05c6, 64, { 0x03, 0x7d, 0x07, 0x12, 0x12, 0x12, 0x43, 0x47, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0,
-  0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x06, 0x90, 0xc0,
-  0x00, 0xf0, 0x90, 0x7e, 0x23, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x33, 0xe0, 0x70, 0x08, 0xe4, 0x90,
-  0x7e, 0x33, 0xf0, 0x75, 0x2e, 0xff, 0x90, 0x7e, 0x25, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54}},
- {0x0606, 64, { 0x3f, 0xf5, 0x45, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x45, 0xf0, 0x90, 0x7e,
-  0x27, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x43, 0x80, 0x80, 0x03, 0x53, 0x43, 0x7f,
-  0x53, 0x43, 0xfc, 0x90, 0x7e, 0x29, 0xe0, 0x60, 0x11, 0x43, 0x43, 0x02, 0xa3, 0xe0, 0xff, 0x12,
-  0x11, 0x7c, 0x90, 0x7e, 0x2b, 0xe0, 0xff, 0x12, 0x11, 0xa2, 0xaf, 0x43, 0x12, 0x11, 0x0a}},
- {0x0646, 64, { 0x90, 0x7e, 0x23, 0xe0, 0x60, 0x08, 0x53, 0x43, 0x7f, 0xaf, 0x43, 0x12, 0x11, 0x0a, 0x90, 0x7e, 0x2c,
-  0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x02, 0x80, 0x03, 0x53, 0x47, 0xfd, 0x90,
-  0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x2e, 0xe0, 0x60,
-  0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x01, 0x80, 0x03, 0x53, 0x47, 0xfe, 0x90, 0x7f}},
- {0x0686, 64, { 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x32, 0xe0, 0xf5, 0x3b, 0xa3,
-  0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x10, 0x80,
-  0x03, 0x53, 0x47, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0,
-  0x90, 0x7e, 0x36, 0xe0, 0x60, 0x32, 0x53, 0x45, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0}},
- {0x06c6, 64, { 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x12, 0x13, 0x63,
-  0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3f, 0xfd, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12,
-  0x12, 0xe4, 0xf5, 0x33, 0xf5, 0x32, 0xd2, 0x08, 0x90, 0x7e, 0x37, 0xe0, 0x60, 0x0f, 0x43, 0x3f,
-  0x02, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x12, 0x75, 0x32, 0x01, 0xd2, 0x08, 0x90, 0x7e}},
- {0x0706, 64, { 0x38, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x04, 0x90, 0xc0, 0x00,
-  0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x39, 0xe0, 0x60, 0x11, 0x43, 0x45, 0x40, 0x90, 0x7f, 0x98, 0x74,
-  0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x3a, 0xe0, 0x60, 0x0f,
-  0x53, 0x3f, 0xfe, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x12, 0x75, 0x34, 0x01, 0xd2, 0x08}},
- {0x0746, 64, { 0x90, 0x7e, 0x3b, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x01, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x12, 0xe4,
-  0xf5, 0x34, 0xd2, 0x08, 0x90, 0x7e, 0x3c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
-  0xe5, 0x41, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x3d, 0xe0, 0x60, 0x02, 0xd2, 0x0c,
-  0x90, 0x7e, 0x3e, 0xe0, 0x60, 0x08, 0x75, 0x35, 0x01, 0xe4, 0xf5, 0x39, 0xd2, 0x08, 0x90}},
- {0x0786, 64, { 0x7e, 0x3f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7, 0x74, 0x13, 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x16, 0xf0,
-  0x74, 0x36, 0xf0, 0xe4, 0x90, 0x7f, 0xd1, 0xf0, 0x30, 0x1a, 0x52, 0xe5, 0x39, 0x60, 0x02, 0x15,
-  0x39, 0x30, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80, 0x3e, 0x75,
-  0x13, 0x0a, 0x30, 0x1b, 0x02, 0xc2, 0x13, 0x12, 0x13, 0x63, 0xef, 0x54, 0x01, 0xf5, 0x19}},
- {0x07c6, 64, { 0x65, 0x33, 0x60, 0x05, 0x85, 0x19, 0x33, 0xd2, 0x08, 0x12, 0x13, 0x9f, 0xef, 0x54, 0x80, 0xf5, 0x19,
-  0x65, 0x2f, 0x60, 0x05, 0x85, 0x19, 0x2f, 0xd2, 0x08, 0x30, 0x0e, 0x11, 0x12, 0x13, 0x9f, 0xef,
-  0x54, 0x10, 0xf5, 0x19, 0x65, 0x2e, 0x60, 0x05, 0x85, 0x19, 0x2e, 0xd2, 0x08, 0x30, 0x1a, 0x2a,
-  0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90, 0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5}},
- {0x0806, 64, { 0x15, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x16, 0x90, 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74,
-  0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f, 0xd3, 0xf0, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1,
-  0x03, 0x02, 0x09, 0x28, 0xe5, 0x0a, 0x70, 0x40, 0x30, 0x07, 0x39, 0xe5, 0x38, 0x70, 0x35, 0xc2,
-  0x07, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
- {0x0846, 64, { 0xfa, 0x12, 0x0e, 0x9c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
-  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x38,
-  0x10, 0xe4, 0xf5, 0x2c, 0x75, 0x0a, 0x01, 0x22, 0xe5, 0x0a, 0x64, 0x01, 0x70, 0x40, 0x30, 0x08,
-  0x39, 0xe5, 0x39, 0x70, 0x35, 0xc2, 0x08, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2d}},
- {0x0886, 64, { 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82,
-  0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f,
-  0xc3, 0x74, 0x09, 0xf0, 0x75, 0x39, 0x10, 0xe4, 0xf5, 0x35, 0x75, 0x0a, 0x02, 0x22, 0xe5, 0x0a,
-  0x64, 0x02, 0x70, 0x36, 0x30, 0x14, 0x2f, 0xc2, 0x14, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00}},
- {0x08c6, 64, { 0x74, 0x0e, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9c, 0xff, 0x74, 0x80, 0x25, 0x18,
-  0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x05, 0xdb,
-  0x90, 0x7f, 0xc3, 0x74, 0x05, 0xf0, 0x75, 0x0a, 0x03, 0x22, 0xe5, 0x15, 0x60, 0x30, 0x15, 0x15,
-  0xe4, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x14, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
- {0x0906, 64, { 0xfa, 0x12, 0x0e, 0x9c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
-  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5,
-  0x0a, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0e, 0xf4, 0x0a, 0x10, 0x00, 0x0a, 0x84, 0x01, 0x0a,
-  0xf0, 0x03, 0x09, 0x4c, 0x06, 0x0a, 0x03, 0x08, 0x09, 0xfd, 0x09, 0x09, 0xe5, 0x0a, 0x09}},
- {0x0946, 64, { 0xf4, 0x0b, 0x00, 0x00, 0x0b, 0x3f, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x14, 0x60, 0x61,
-  0x24, 0x02, 0x60, 0x03, 0x02, 0x09, 0xdb, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90,
-  0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02,
-  0x7f, 0x03, 0x75, 0x82, 0x82, 0x75, 0x83, 0x19, 0xef, 0xf0, 0x75, 0x82, 0x7b, 0x75, 0x83}},
- {0x0986, 64, { 0x19, 0xf0, 0x75, 0x82, 0x74, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x66, 0x75, 0x83, 0x19, 0xf0, 0x75,
-  0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f, 0xea, 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83,
-  0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x12, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b,
-  0x46, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0f, 0x1a, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90}},
- {0x09c6, 64, { 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01,
-  0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f,
-  0x00, 0xe5, 0x09, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea,
-  0xe0, 0xf5, 0x09, 0x02, 0x0b, 0x46, 0x12, 0x0b, 0x4e, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0x00}},
- {0x0a06, 64, { 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60,
-  0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b, 0xa2, 0x10, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff,
-  0xa2, 0x16, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74,
-  0x02, 0xf0, 0x02, 0x0b, 0x46, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5}},
- {0x0a46, 64, { 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f,
-  0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83,
-  0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0,
-  0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f}},
- {0x0a86, 64, { 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0,
-  0xb4, 0x01, 0x05, 0xc2, 0x10, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02,
-  0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff,
-  0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4}},
- {0x0ac6, 64, { 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54,
-  0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f,
-  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60,
-  0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x10, 0x80}},
- {0x0b06, 64, { 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90,
-  0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25,
-  0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90,
-  0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0}},
- {0x0b46, 64, { 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74,
-  0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e,
-  0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x18, 0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74,
-  0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xe4, 0xf5, 0x24, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74}},
- {0x0b86, 64, { 0x24, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xe2, 0x05, 0x18, 0xe5, 0x18, 0xb4,
-  0x09, 0xea, 0x75, 0x3a, 0x01, 0xe4, 0xf5, 0x38, 0xf5, 0x13, 0xf5, 0x36, 0xc2, 0x07, 0xc2, 0x0b,
-  0xc2, 0x05, 0xc2, 0x00, 0xc2, 0x09, 0xc2, 0x13, 0xd2, 0x03, 0xd2, 0x01, 0x90, 0x7f, 0x98, 0x74,
-  0x13, 0xf0, 0x75, 0x44, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd}},
- {0x0bc6, 64, { 0x12, 0x11, 0xc8, 0x7f, 0x10, 0x8f, 0x42, 0x12, 0x10, 0x98, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x7f,
-  0x01, 0x8f, 0x40, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0,
-  0x75, 0x46, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x11, 0xc8, 0xe4,
-  0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3e, 0x12, 0x11, 0xc8, 0x90, 0x7f, 0x98, 0x74, 0x11}},
- {0x0c06, 64, { 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x11, 0xc8, 0x7f, 0x01, 0x12, 0x12,
-  0x81, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xc8, 0x20, 0x1b, 0x03, 0x02, 0x0c, 0xc7, 0x75, 0x2d,
-  0x01, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4,
-  0x12, 0x0e, 0xe2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3b, 0x01, 0xe4, 0xf5}},
- {0x0c46, 64, { 0x39, 0xf5, 0x13, 0xf5, 0x37, 0xc2, 0x08, 0xc2, 0x0c, 0xc2, 0x06, 0xc2, 0x00, 0xc2, 0x0a, 0xc2, 0x13,
-  0xd2, 0x04, 0xd2, 0x02, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x75, 0x45, 0x03, 0x90, 0xc0, 0x00,
-  0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x12, 0x12, 0x7f, 0x10, 0x8f, 0x43, 0x12, 0x11,
-  0x0a, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x7f, 0x01, 0x8f, 0x41, 0xef, 0x44, 0x06, 0x90}},
- {0x0c86, 64, { 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x75, 0x47, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80,
-  0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x12, 0x12, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3f, 0x12,
-  0x12, 0x12, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d,
-  0x7f, 0x12, 0x12, 0x12, 0x7f, 0x01, 0x12, 0x12, 0xa2, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x12}},
- {0x0cc6, 64, { 0x12, 0xd2, 0x12, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5,
-  0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86,
+ {0x0000,  3, { 0x02, 0x0e, 0x00}},
+ {0x0106, 64, { 0x60, 0x58, 0xb4, 0x80, 0x03, 0x43, 0x36, 0x02, 0xe5, 0x36, 0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94,
+  0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x0c, 0x7e,
+  0x75, 0x0d, 0x80, 0xaf, 0x36, 0x12, 0x0f, 0x4b, 0xe5, 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xb7, 0xf0,
+  0x80, 0x27, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08}},
+ {0x0146, 64, { 0x90, 0x7e, 0x80, 0xe5, 0x36, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x81, 0x12,
+  0x0c, 0xdf, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90, 0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06,
+  0x20, 0x05, 0x03, 0x02, 0x03, 0xc1, 0xc2, 0x05, 0xe4, 0xf5, 0x18, 0x74, 0x40, 0x25, 0x18, 0xf5,
+  0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a}},
+ {0x0186, 64, { 0x7e, 0x79, 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e, 0xd2, 0x05, 0x18, 0xe5,
+  0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x68, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x24,
+  0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xb1, 0x7f, 0x03, 0x7d, 0xcd, 0x12, 0x11, 0xb1, 0x43, 0x46,
+  0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0xe4, 0x90}},
+ {0x01c6, 64, { 0x7e, 0x13, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12, 0x10, 0x35, 0x90, 0x7e, 0x02, 0xe0,
+  0xff, 0x12, 0x10, 0x5b, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0, 0xfd, 0x12, 0x11, 0xb1, 0x7f, 0x03,
+  0x7d, 0x07, 0x12, 0x11, 0xb1, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0,
+  0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x06, 0x90}},
+ {0x0206, 64, { 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x03, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x13, 0xe0, 0x70, 0x08, 0xe4, 0x90,
+  0x7e, 0x13, 0xf0, 0x75, 0x25, 0xff, 0x90, 0x7e, 0x05, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f,
+  0xf5, 0x44, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x44, 0xf0, 0x90, 0x7e,
+  0x07, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x42, 0x80, 0x80, 0x03, 0x53, 0x42}},
+ {0x0246, 64, { 0x7f, 0x53, 0x42, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43, 0x42, 0x02, 0xa3, 0xe0, 0xff, 0x12,
+  0x10, 0xa7, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x10, 0xcd, 0xaf, 0x42, 0x12, 0x10, 0x81, 0x90,
+  0x7e, 0x03, 0xe0, 0x60, 0x08, 0x53, 0x42, 0x7f, 0xaf, 0x42, 0x12, 0x10, 0x81, 0x90, 0x7e, 0x0c,
+  0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x02, 0x80, 0x03, 0x53, 0x46, 0xfd}},
+ {0x0286, 64, { 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x0e, 0xe0, 0x60,
+  0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x01, 0x80, 0x03, 0x53, 0x46, 0xfe, 0x90, 0x7f, 0x98,
+  0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x12, 0xe0, 0xf5, 0x3a, 0xa3,
+  0xe0, 0x13, 0x92, 0x0d, 0xa3, 0xe0, 0xf5, 0x3c, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x10}},
+ {0x02c6, 64, { 0x80, 0x03, 0x53, 0x46, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0,
+  0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x44, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5,
+  0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x12, 0x12, 0xdf,
+  0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3e, 0xfd, 0xe4, 0xff, 0xad, 0x3e, 0x12}},
+ {0x0306, 64, { 0x11, 0xb1, 0xe4, 0xf5, 0x2a, 0xf5, 0x29, 0xd2, 0x07, 0x90, 0x7e, 0x17, 0xe0, 0x60, 0x0f, 0x43, 0x3e,
+  0x02, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xb1, 0x75, 0x29, 0x01, 0xd2, 0x07, 0x90, 0x7e, 0x18,
+  0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x04, 0x90, 0xc0, 0x00,
+  0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11, 0x43, 0x44, 0x40, 0x90, 0x7f, 0x98}},
+ {0x0346, 64, { 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f,
+  0x53, 0x3e, 0xfe, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xb1, 0x75, 0x2b, 0x01, 0xd2, 0x07, 0x90,
+  0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x01, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xb1, 0xe4,
+  0xf5, 0x2b, 0xd2, 0x07, 0x90, 0x7e, 0x1c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12}},
+ {0x0386, 64, { 0xf0, 0xe5, 0x40, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x0b,
+  0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x2c, 0x01, 0xe4, 0xf5, 0x38, 0xd2, 0x07, 0x90, 0x7e,
+  0x1f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0,
+  0x74, 0x35, 0xf0, 0xd2, 0x03, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30, 0x1a, 0x52, 0xe5, 0x38}},
+ {0x03c6, 64, { 0x60, 0x02, 0x15, 0x38, 0x20, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80,
+  0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xd2, 0x13, 0x12, 0x12, 0xdf, 0xef, 0x54, 0x01, 0xf5,
+  0x19, 0x65, 0x2a, 0x60, 0x05, 0x85, 0x19, 0x2a, 0xd2, 0x07, 0x12, 0x13, 0x33, 0xef, 0x54, 0x80,
+  0xf5, 0x19, 0x65, 0x26, 0x60, 0x05, 0x85, 0x19, 0x26, 0xd2, 0x07, 0x30, 0x0d, 0x11, 0x12}},
+ {0x0406, 64, { 0x13, 0x33, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x25, 0x60, 0x05, 0x85, 0x19, 0x25, 0xd2, 0x07, 0x20,
+  0x1b, 0x03, 0x02, 0x07, 0xec, 0x30, 0x0a, 0x18, 0x12, 0x13, 0x6f, 0xef, 0xc3, 0x95, 0x3d, 0x40,
+  0x03, 0x02, 0x04, 0xae, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0xc2, 0x0a, 0xc2, 0x00, 0x80, 0x77,
+  0x30, 0x04, 0x3b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x6f, 0xef, 0xc3}},
+ {0x0446, 64, { 0x94, 0x40, 0x50, 0x64, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcb, 0xe0, 0x14, 0xf5,
+  0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d, 0x7f, 0x41, 0x75, 0x0c, 0x7d, 0x75,
+  0x0d, 0x41, 0x12, 0x0d, 0x04, 0xc2, 0x04, 0xe4, 0x90, 0x7f, 0xcb, 0xf0, 0x80, 0x39, 0x90, 0x7f,
+  0xcc, 0xe0, 0x20, 0xe1, 0x32, 0x12, 0x13, 0x6f, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90}},
+ {0x0486, 64, { 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcd, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60,
+  0x0f, 0xf5, 0x08, 0x7e, 0x7c, 0x7f, 0xc1, 0x75, 0x0c, 0x7c, 0x75, 0x0d, 0xc1, 0x12, 0x0d, 0x04,
+  0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xba, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x05,
+  0x36, 0x12, 0x12, 0x20, 0x8f, 0x19, 0x12, 0x13, 0x7b, 0x8f, 0x37, 0xe5, 0x19, 0xc3, 0x95}},
+ {0x04c6, 64, { 0x3b, 0x50, 0x0f, 0x12, 0x13, 0x57, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x37, 0x20, 0xe7, 0x03, 0x30, 0x0c,
+  0x5e, 0xc2, 0x0c, 0xe5, 0x19, 0x60, 0x58, 0xb4, 0x80, 0x03, 0x43, 0x37, 0x02, 0xe5, 0x37, 0x30,
+  0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e,
+  0x7d, 0x7f, 0x80, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x80, 0xaf, 0x37, 0x12, 0x0f, 0x84, 0xe5}},
+ {0x0506, 64, { 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xbb, 0xf0, 0x80, 0x27, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75,
+  0x19, 0x3f, 0x85, 0x19, 0x08, 0x90, 0x7d, 0x80, 0xe5, 0x37, 0xf0, 0x7e, 0x7d, 0x7f, 0x81, 0x75,
+  0x0c, 0x7d, 0x75, 0x0d, 0x81, 0x12, 0x0d, 0x29, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xbb, 0xf0, 0x90,
+  0x7f, 0xd0, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x06, 0x03, 0x02, 0x07, 0x97, 0xc2, 0x06, 0xe4}},
+ {0x0546, 64, { 0xf5, 0x18, 0x74, 0xc0, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18,
+  0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x20, 0x24, 0x20, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef,
+  0x12, 0x0e, 0xd2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x20, 0xe0, 0x60, 0x68,
+  0x90, 0x7e, 0x23, 0xe0, 0x60, 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xfb, 0x7f, 0x03}},
+ {0x0586, 64, { 0x7d, 0xcd, 0x12, 0x11, 0xfb, 0x43, 0x47, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00,
+  0xe5, 0x47, 0xf0, 0xe4, 0x90, 0x7e, 0x33, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x21, 0xe0, 0xff, 0x12,
+  0x11, 0x19, 0x90, 0x7e, 0x22, 0xe0, 0xff, 0x12, 0x11, 0x3f, 0x7f, 0x01, 0x90, 0x7e, 0x31, 0xe0,
+  0xfd, 0x12, 0x11, 0xfb, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xfb, 0x43, 0x47, 0x80, 0x90}},
+ {0x05c6, 64, { 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
+  0xe5, 0x41, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x23, 0xe0, 0x70, 0x06, 0x90, 0x7e,
+  0x33, 0xe0, 0x70, 0x08, 0xe4, 0x90, 0x7e, 0x33, 0xf0, 0x75, 0x2e, 0xff, 0x90, 0x7e, 0x25, 0xe0,
+  0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x45, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90}},
+ {0x0606, 64, { 0xc0, 0x00, 0xe5, 0x45, 0xf0, 0x90, 0x7e, 0x27, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x43,
+  0x80, 0x80, 0x03, 0x53, 0x43, 0x7f, 0x53, 0x43, 0xfc, 0x90, 0x7e, 0x29, 0xe0, 0x60, 0x11, 0x43,
+  0x43, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x11, 0x65, 0x90, 0x7e, 0x2b, 0xe0, 0xff, 0x12, 0x11, 0x8b,
+  0xaf, 0x43, 0x12, 0x10, 0xf3, 0x90, 0x7e, 0x23, 0xe0, 0x60, 0x08, 0x53, 0x43, 0x7f, 0xaf}},
+ {0x0646, 64, { 0x43, 0x12, 0x10, 0xf3, 0x90, 0x7e, 0x2c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x02,
+  0x80, 0x03, 0x53, 0x47, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47,
+  0xf0, 0x90, 0x7e, 0x2e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x01, 0x80, 0x03,
+  0x53, 0x47, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0}},
+ {0x0686, 64, { 0x90, 0x7e, 0x32, 0xe0, 0xf5, 0x3b, 0xa3, 0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0,
+  0x60, 0x05, 0x43, 0x47, 0x10, 0x80, 0x03, 0x53, 0x47, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0,
+  0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x36, 0xe0, 0x60, 0x32, 0x53, 0x45, 0xbf, 0x90,
+  0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f}},
+ {0x06c6, 64, { 0x98, 0x74, 0x09, 0xf0, 0x12, 0x13, 0x4b, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3f, 0xfd,
+  0xe4, 0xff, 0xad, 0x3f, 0x12, 0x11, 0xfb, 0xe4, 0xf5, 0x33, 0xf5, 0x32, 0xd2, 0x08, 0x90, 0x7e,
+  0x37, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x02, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x11, 0xfb, 0x75, 0x32,
+  0x01, 0xd2, 0x08, 0x90, 0x7e, 0x38, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0}},
+ {0x0706, 64, { 0xe5, 0x41, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x39, 0xe0, 0x60, 0x11, 0x43,
+  0x45, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
+  0x90, 0x7e, 0x3a, 0xe0, 0x60, 0x0f, 0x53, 0x3f, 0xfe, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x11, 0xfb,
+  0x75, 0x34, 0x01, 0xd2, 0x08, 0x90, 0x7e, 0x3b, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x01, 0xe4}},
+ {0x0746, 64, { 0xff, 0xad, 0x3f, 0x12, 0x11, 0xfb, 0xe4, 0xf5, 0x34, 0xd2, 0x08, 0x90, 0x7e, 0x3c, 0xe0, 0x60, 0x0e,
+  0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
+  0x3d, 0xe0, 0x60, 0x02, 0xd2, 0x0c, 0x90, 0x7e, 0x3e, 0xe0, 0x60, 0x08, 0x75, 0x35, 0x01, 0xe4,
+  0xf5, 0x39, 0xd2, 0x08, 0x90, 0x7e, 0x3f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x13}},
+ {0x0786, 64, { 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x16, 0xf0, 0x74, 0x36, 0xf0, 0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xd1, 0xf0,
+  0x30, 0x1a, 0x52, 0xe5, 0x39, 0x60, 0x02, 0x15, 0x39, 0x30, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94,
+  0x00, 0x40, 0x04, 0x15, 0x13, 0x80, 0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xc2, 0x13, 0x12,
+  0x13, 0x4b, 0xef, 0x54, 0x01, 0xf5, 0x19, 0x65, 0x33, 0x60, 0x05, 0x85, 0x19, 0x33, 0xd2}},
+ {0x07c6, 64, { 0x08, 0x12, 0x13, 0x87, 0xef, 0x54, 0x80, 0xf5, 0x19, 0x65, 0x2f, 0x60, 0x05, 0x85, 0x19, 0x2f, 0xd2,
+  0x08, 0x30, 0x0e, 0x11, 0x12, 0x13, 0x87, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x2e, 0x60, 0x05,
+  0x85, 0x19, 0x2e, 0xd2, 0x08, 0x30, 0x1a, 0x2a, 0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90,
+  0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5, 0x15, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x16, 0x90}},
+ {0x0806, 64, { 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f,
+  0xd3, 0xf0, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x09, 0x20, 0xe5, 0x0a, 0x70, 0x40,
+  0x30, 0x07, 0x39, 0xe5, 0x38, 0x70, 0x35, 0xc2, 0x07, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74,
+  0x24, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x8c, 0xff, 0x74, 0x80, 0x25}},
+ {0x0846, 64, { 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb,
+  0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x38, 0x10, 0xe4, 0xf5, 0x2c, 0x75, 0x0a, 0x01, 0x22,
+  0xe5, 0x0a, 0x64, 0x01, 0x70, 0x40, 0x30, 0x08, 0x39, 0xe5, 0x39, 0x70, 0x35, 0xc2, 0x08, 0xf5,
+  0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12}},
+ {0x0886, 64, { 0x0e, 0x8c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05,
+  0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x39, 0x10, 0xe4,
+  0xf5, 0x35, 0x75, 0x0a, 0x02, 0x22, 0xe5, 0x0a, 0x64, 0x02, 0x70, 0x36, 0x30, 0x14, 0x2f, 0xc2,
+  0x14, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x0e, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
+ {0x08c6, 64, { 0xfa, 0x12, 0x0e, 0x8c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
+  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x05, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x05, 0xf0, 0x75, 0x0a,
+  0x03, 0x22, 0xe5, 0x15, 0x60, 0x30, 0x15, 0x15, 0xe4, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74,
+  0x14, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x8c, 0xff, 0x74, 0x80, 0x25}},
+ {0x0906, 64, { 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x03, 0xdb,
+  0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x0a, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0e,
+  0xe4, 0x0a, 0x08, 0x00, 0x0a, 0x7c, 0x01, 0x0a, 0xe8, 0x03, 0x09, 0x44, 0x06, 0x09, 0xfb, 0x08,
+  0x09, 0xf5, 0x09, 0x09, 0xdd, 0x0a, 0x09, 0xec, 0x0b, 0x00, 0x00, 0x0b, 0x37, 0x90, 0x7f}},
+ {0x0946, 64, { 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x14, 0x60, 0x61, 0x24, 0x02, 0x60, 0x03, 0x02, 0x09, 0xd3, 0x74,
+  0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f,
+  0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03, 0x75, 0x82, 0x82, 0x75, 0x83, 0x19,
+  0xef, 0xf0, 0x75, 0x82, 0x7b, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x74, 0x75, 0x83, 0x19}},
+ {0x0986, 64, { 0xf0, 0x75, 0x82, 0x66, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f,
+  0xea, 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83, 0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0,
+  0x74, 0x12, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0f,
+  0x0a, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90, 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0}},
+ {0x09c6, 64, { 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0,
+  0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0x00, 0xe5, 0x09, 0xf0, 0x90, 0x7f, 0xb5, 0x74,
+  0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x09, 0x02, 0x0b, 0x3e, 0x12, 0x0b,
+  0x46, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0x00, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02}},
+ {0x0a06, 64, { 0x0b, 0x3e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b,
+  0xa2, 0x10, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff, 0xa2, 0x16, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00,
+  0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0xe4, 0x90, 0x7f,
+  0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f}},
+ {0x0a46, 64, { 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24,
+  0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4,
+  0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
+  0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02}},
+ {0x0a86, 64, { 0x60, 0x03, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x05, 0xc2, 0x10, 0x02, 0x0b, 0x3e,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38,
+  0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f,
+  0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f}},
+ {0x0ac6, 64, { 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f,
+  0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80,
+  0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea,
+  0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x10, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0}},
+ {0x0b06, 64, { 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4,
+  0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f,
+  0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22}},
+ {0x0b46, 64, { 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90,
+  0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x18,
+  0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xe4, 0xf5,
+  0x24, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa}},
+ {0x0b86, 64, { 0xe4, 0x12, 0x0e, 0xd2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3a, 0x01, 0xe4, 0xf5, 0x38,
+  0xf5, 0x13, 0xf5, 0x36, 0xc2, 0x07, 0xc2, 0x0b, 0xc2, 0x05, 0xc2, 0x00, 0xc2, 0x09, 0xc2, 0x13,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x75, 0x44, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f,
+  0x0c, 0xe4, 0xfd, 0x12, 0x11, 0xb1, 0x7f, 0x10, 0x8f, 0x42, 0x12, 0x10, 0x81, 0x90, 0x7f}},
+ {0x0bc6, 64, { 0x98, 0x74, 0x12, 0xf0, 0x7f, 0x01, 0x8f, 0x40, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x14, 0xf0, 0x75, 0x46, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd,
+  0x12, 0x11, 0xb1, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3e, 0x12, 0x11, 0xb1, 0x90, 0x7f,
+  0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x11}},
+ {0x0c06, 64, { 0xb1, 0x7f, 0x01, 0x12, 0x12, 0x6a, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xb1, 0x20, 0x1b, 0x03, 0x02,
+  0x0c, 0xb7, 0x75, 0x2d, 0x01, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xe4,
+  0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xd2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3b,
+  0x01, 0xe4, 0xf5, 0x39, 0xf5, 0x13, 0xf5, 0x37, 0xc2, 0x08, 0xc2, 0x0c, 0xc2, 0x06, 0xc2}},
+ {0x0c46, 64, { 0x00, 0xc2, 0x0a, 0xc2, 0x13, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x75, 0x45, 0x03, 0x90, 0xc0, 0x00,
+  0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x11, 0xfb, 0x7f, 0x10, 0x8f, 0x43, 0x12, 0x10,
+  0xf3, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x7f, 0x01, 0x8f, 0x41, 0xef, 0x44, 0x06, 0x90, 0xc0,
+  0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x75, 0x47, 0x80, 0x90, 0xc0, 0x00, 0x74}},
+ {0x0c86, 64, { 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x11, 0xfb, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3f, 0x12,
+  0x11, 0xfb, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d,
+  0x7f, 0x12, 0x11, 0xfb, 0x7f, 0x01, 0x12, 0x12, 0x8b, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xfb,
+  0xd2, 0x12, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82}},
+ {0x0cc6, 64, { 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86,
   0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08,
-  0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00}},
- {0x0d06, 64, { 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05,
+  0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0,
+  0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90, 0x7f}},
+ {0x0d06, 64, { 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05,
   0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2,
-  0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5}},
- {0x0d46, 64, { 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86,
-  0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05,
+  0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c,
+  0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05}},
+ {0x0d46, 64, { 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05,
   0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43,
-  0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xd2, 0x19, 0x90, 0x7f, 0x92, 0xe0, 0x44}},
- {0x0d86, 64, { 0x02, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x10, 0xe4, 0x33, 0xfe, 0xef, 0x4e, 0xf0, 0xd2,
-  0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f,
+  0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xd2, 0x19, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02,
+  0xf0, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x10, 0xe4, 0x33, 0xfe, 0xef, 0x4e, 0xf0}},
+ {0x0d86, 64, { 0xd2, 0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f,
   0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90,
-  0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0, 0xd2, 0xaf}},
- {0x0dc6, 64, { 0xd2, 0x1a, 0x12, 0x12, 0x5c, 0xc2, 0x11, 0xe4, 0xf5, 0x0b, 0xf5, 0x13, 0xc2, 0x17, 0xc2, 0x12, 0x90,
-  0x7f, 0xa1, 0x04, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x17, 0x60, 0x10, 0x30, 0x12, 0x05, 0xd2,
+  0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2,
+  0x1a, 0x12, 0x12, 0x45, 0xc2, 0x11, 0xe4, 0xf5, 0x0b, 0xf5, 0x13, 0xc2, 0x17, 0xc2, 0x12}},
+ {0x0dc6, 64, { 0x90, 0x7f, 0xa1, 0x04, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x17, 0x60, 0x10, 0x30, 0x12, 0x05, 0xd2,
   0x1a, 0x12, 0x00, 0x46, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x17, 0x80, 0x08, 0x30, 0x12, 0x05, 0xc2,
-  0x1a, 0x12, 0x00, 0x46, 0x30, 0x11, 0x07, 0xc2, 0x11, 0x12, 0x09, 0x29, 0x80, 0xd6, 0x30}},
- {0x0e06, 64, { 0x18, 0xd3, 0xc2, 0x18, 0x12, 0x12, 0xf6, 0x80, 0xcc, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75,
-  0x81, 0x47, 0x02, 0x0e, 0x57, 0x02, 0x0d, 0x7f, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40,
+  0x1a, 0x12, 0x00, 0x46, 0x30, 0x11, 0x07, 0xc2, 0x11, 0x12, 0x09, 0x21, 0x80, 0xd6, 0x30, 0x18,
+  0xd3, 0xc2, 0x18, 0x12, 0x13, 0x93, 0x80, 0xcc, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd}},
+ {0x0e06, 64, { 0x75, 0x81, 0x47, 0x02, 0x0e, 0x47, 0x02, 0x0d, 0x6f, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40,
   0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07,
-  0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4}},
- {0x0e46, 64, { 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
-  0x90, 0x12, 0xc3, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09,
+  0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56,
+  0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40}},
+ {0x0e46, 64, { 0x80, 0x90, 0x12, 0xac, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09,
   0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8,
-  0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5}},
- {0x0e86, 64, { 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf,
-  0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02,
+  0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82,
+  0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca}},
+ {0x0e86, 64, { 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02,
   0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01,
-  0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06}},
- {0x0ec6, 64, { 0xe9, 0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82,
-  0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82,
+  0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9,
+  0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5}},
+ {0x0ec6, 64, { 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82,
   0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0,
-  0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8}},
- {0x0f06, 64, { 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3,
-  0xa3, 0x80, 0xdf, 0x8f, 0x18, 0xe4, 0xf5, 0x19, 0x75, 0x1a, 0xff, 0x75, 0x1b, 0x19, 0x75, 0x1c,
-  0x86, 0xab, 0x1a, 0xaa, 0x1b, 0xa9, 0x1c, 0x90, 0x00, 0x01, 0x12, 0x0e, 0xb5, 0xb4, 0x03, 0x1d,
-  0xaf, 0x19, 0x05, 0x19, 0xef, 0xb5, 0x18, 0x01, 0x22, 0x12, 0x0e, 0x9c, 0x7e, 0x00, 0x29}},
- {0x0f46, 64, { 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x1a, 0xff, 0xf5, 0x1b, 0x89, 0x1c, 0x80, 0xd4, 0x7b, 0x00, 0x7a,
-  0x00, 0x79, 0x00, 0x22, 0x8f, 0x1a, 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c,
+  0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74,
+  0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3}},
+ {0x0f06, 64, { 0xa3, 0xa3, 0x80, 0xdf, 0x8f, 0x18, 0xe4, 0xf5, 0x19, 0x75, 0x1a, 0xff, 0x75, 0x1b, 0x19, 0x75, 0x1c,
+  0x86, 0xab, 0x1a, 0xaa, 0x1b, 0xa9, 0x1c, 0x90, 0x00, 0x01, 0x12, 0x0e, 0xa5, 0xb4, 0x03, 0x1d,
+  0xaf, 0x19, 0x05, 0x19, 0xef, 0xb5, 0x18, 0x01, 0x22, 0x12, 0x0e, 0x8c, 0x7e, 0x00, 0x29, 0xff,
+  0xee, 0x3a, 0xa9, 0x07, 0x75, 0x1a, 0xff, 0xf5, 0x1b, 0x89, 0x1c, 0x80, 0xd4, 0x7b, 0x00}},
+ {0x0f46, 64, { 0x7a, 0x00, 0x79, 0x00, 0x22, 0x8f, 0x1a, 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c,
   0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12, 0x00, 0x36, 0x05, 0x0d, 0xe5, 0x0d, 0xac,
-  0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5}},
- {0x0f86, 64, { 0x08, 0x60, 0x0a, 0x12, 0x13, 0x3f, 0x8f, 0x1a, 0xef, 0x42, 0x36, 0x80, 0xca, 0x22, 0x8f, 0x1a, 0x05,
-  0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a,
-  0xf0, 0x12, 0x13, 0x57, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5,
-  0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x93, 0x8f}},
- {0x0fc6, 64, { 0x1a, 0xef, 0x42, 0x37, 0x80, 0xca, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84,
-  0xc0, 0x86, 0x75, 0x86, 0x00, 0x30, 0x15, 0x04, 0xc2, 0x15, 0x80, 0x02, 0xd2, 0x18, 0x53, 0x91,
-  0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0,
-  0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0}},
- {0x1006, 64, { 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04,
-  0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0,
-  0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x11, 0x53,
-  0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0}},
- {0x1046, 64, { 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf,
-  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74,
-  0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13,
-  0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0}},
- {0x1086, 64, { 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
-  0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44,
-  0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0}},
- {0x10c6, 64, { 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f,
-  0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90,
-  0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90}},
- {0x1106, 64, { 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90,
-  0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0,
-  0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90,
-  0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xef}},
- {0x1146, 64, { 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90,
-  0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09,
-  0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f,
-  0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74}},
- {0x1186, 64, { 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74,
-  0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b,
-  0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00,
-  0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00}},
- {0x11c6, 64, { 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90,
-  0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0,
-  0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x27, 0x8f, 0x1a, 0x12, 0x13, 0x27, 0x8f, 0x1b,
-  0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x27, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b}},
- {0x1206, 64, { 0x60, 0x07, 0x12, 0x13, 0x27, 0x8f, 0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b,
-  0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0f, 0xf0, 0x90,
-  0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22,
-  0x12, 0x13, 0x7b, 0x8f, 0x1a, 0x12, 0x13, 0x7b, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60}},
- {0x1246, 64, { 0x12, 0x12, 0x13, 0x7b, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x7b, 0x8f, 0x1b,
-  0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0,
-  0x30, 0x1a, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x12, 0xdf, 0x90, 0x7f,
-  0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44, 0x04, 0xf0, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5}},
- {0x1286, 64, { 0x3e, 0x54, 0x7f, 0xfd, 0x12, 0x11, 0xc8, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee,
-  0xf0, 0xe4, 0xe5, 0x3e, 0x44, 0x80, 0xfd, 0x12, 0x11, 0xc8, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5,
-  0x3f, 0x54, 0x7f, 0xfd, 0x12, 0x12, 0x12, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00,
-  0xee, 0xf0, 0xe4, 0xe5, 0x3f, 0x44, 0x80, 0xfd, 0x12, 0x12, 0x12, 0x22, 0x05, 0x0e, 0x02}},
- {0x12c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x03, 0x14, 0x03, 0x00, 0x00, 0xc1, 0x11, 0xc1, 0x18, 0xc1, 0x95, 0xc1, 0x10,
-  0xc1, 0x16, 0x01, 0x0a, 0x00, 0xc1, 0x1b, 0x00, 0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19,
-  0xae, 0x18, 0x70, 0x02, 0x15, 0x18, 0x4e, 0x60, 0x05, 0x12, 0x0d, 0x5e, 0x80, 0xee, 0x22, 0x12,
-  0x00, 0x03, 0x12, 0x0d, 0x6f, 0x12, 0x0b, 0x4e, 0x22, 0x02, 0x10, 0x25, 0x00, 0x02, 0x13}},
- {0x1306, 64, { 0x04, 0x00, 0x02, 0x0f, 0xfb, 0x00, 0x02, 0x0f, 0xcd, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0,
+  0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08,
+  0x60, 0x0a, 0x12, 0x13, 0x27, 0x8f, 0x1a, 0xef, 0x42, 0x36, 0x80, 0xca, 0x22, 0x8f, 0x1a}},
+ {0x0f86, 64, { 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a,
+  0xf0, 0x12, 0x13, 0x3f, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5,
+  0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x7b, 0x8f, 0x1a,
+  0xef, 0x42, 0x37, 0x80, 0xca, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0}},
+ {0x0fc6, 64, { 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab,
+  0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32,
+  0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2,
+  0x11, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0}},
+ {0x1006, 64, { 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0,
+  0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08,
+  0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f,
+  0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10}},
+ {0x1046, 64, { 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90,
+  0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0,
+  0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13,
+  0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13}},
+ {0x1086, 64, { 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef,
+  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74,
+  0x14, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44}},
+ {0x10c6, 64, { 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74,
+  0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98,
+  0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90}},
+ {0x1106, 64, { 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00,
+  0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5,
+  0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90}},
+ {0x1146, 64, { 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90,
+  0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f,
+  0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0,
+  0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f}},
+ {0x1186, 64, { 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0,
+  0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b,
+  0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0,
+  0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90}},
+ {0x11c6, 64, { 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12,
+  0x13, 0x0f, 0x8f, 0x1a, 0x12, 0x13, 0x0f, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12,
+  0x13, 0x0f, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x0f, 0x8f, 0x1b, 0x80,
+  0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90}},
+ {0x1206, 64, { 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0f, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98,
+  0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x63, 0x8f, 0x1a, 0x12, 0x13,
+  0x63, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x63, 0x8f, 0x1a, 0xe5, 0x1a,
+  0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x63, 0x8f, 0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90}},
+ {0x1246, 64, { 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x1a, 0x04, 0xe0, 0x44, 0x02, 0xf0,
+  0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x12, 0xc8, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44,
+  0x04, 0xf0, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3e, 0x54, 0x7f, 0xfd, 0x12, 0x11, 0xb1, 0x90,
+  0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3e, 0x44, 0x80}},
+ {0x1286, 64, { 0xfd, 0x12, 0x11, 0xb1, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3f, 0x54, 0x7f, 0xfd, 0x12, 0x11, 0xfb,
+  0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3f, 0x44, 0x80,
+  0xfd, 0x12, 0x11, 0xfb, 0x22, 0x05, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x14, 0x03, 0x00,
+  0x00, 0xc1, 0x11, 0xc1, 0x18, 0xc1, 0x95, 0xc1, 0x10, 0xc1, 0x16, 0x01, 0x0a, 0x00, 0xc1}},
+ {0x12c6, 64, { 0x1b, 0x00, 0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19, 0xae, 0x18, 0x70, 0x02, 0x15, 0x18, 0x4e,
+  0x60, 0x05, 0x12, 0x0d, 0x4e, 0x80, 0xee, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0,
   0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
-  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
-  0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90}},
- {0x1346, 64, { 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
-  0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
-  0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0,
-  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff}},
- {0x1386, 64, { 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
-  0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0,
-  0x00, 0xe0, 0xff, 0x22, 0x53, 0xd8, 0xef, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x53, 0xd8, 0xef, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0f, 0xe7, 0x00, 0x02, 0x13}},
+ {0x1306, 64, { 0x04, 0x00, 0x02, 0x0f, 0xbd, 0x00, 0x02, 0x10, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x16, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90}},
+ {0x1346, 64, { 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff}},
+ {0x1386, 64, { 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x12, 0x00, 0x03, 0x12,
+  0x0d, 0x5f, 0x12, 0x0b, 0x46, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
  {0x13c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -420,13 +424,13 @@
  {0x18c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x00, 0x01, 0xff, 0x00}},
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00}},
  {0x1906, 64, { 0x00, 0x40, 0xcd, 0x06, 0x12, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x02, 0x09, 0x02, 0x74, 0x00, 0x01,
   0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00, 0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01,
   0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40,
   0x00, 0x00, 0x07, 0x05, 0x04, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x05, 0x02, 0x40, 0x00}},
  {0x1946, 64, { 0x00, 0x07, 0x05, 0x06, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x07, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05,
-  0x81, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x83, 0x02,
+  0x81, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x83, 0x02,
   0x40, 0x00, 0x01, 0x07, 0x05, 0x84, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x85, 0x02, 0x40, 0x00,
   0x01, 0x07, 0x05, 0x86, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x87, 0x02, 0x40, 0x00, 0x01}},
  {0x1986, 64, { 0x04, 0x03, 0x09, 0x04, 0x48, 0x03, 0x4b, 0x00, 0x65, 0x00, 0x79, 0x00, 0x73, 0x00, 0x70, 0x00, 0x61,
@@ -439,5 +443,5 @@
   0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00, 0x70, 0x00, 0x74, 0x00, 0x65, 0x00}},
  {0x1a06, 20, { 0x72, 0x00, 0x10, 0x03, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
   0x00, 0x00, 0x00}},
- { 0xffff,	0,	{0x00} }
+ {0xffff,	0,	{0x00} }
 };
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa19_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa19_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa19_fw.h	Wed Oct 10 00:15:02 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa19_fw.h	Mon Nov 25 12:27:09 2002
@@ -1,28 +1,33 @@
 /* keyspan_usa19_fw.h
-  
-   Generated from Keyspan firmware image usa19code.h Sat Oct  6 12:14:44 EST 2001
-   This firmware is for the Keyspan USA-19 Serial Adaptor
+ 
+	The firmware contained herein as keyspan_usa19_fw.h is
 
-   "The firmware contained herein as keyspan_usa19_fw.h is
-   Copyright (C) 1999-2001 Keyspan, A division of InnoSys Incorporated
-   ("Keyspan"), as an unpublished work.  This notice does not imply
-   unrestricted or public access to this firmware which is a trade secret of
-   Keyspan, and which may not be reproduced, used, sold or transferred to any
-   third party without Keyspan's prior written consent.  All Rights Reserved.
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
 
-   This firmware may not be modified and may only be used with the Keyspan 
-   USA-19 Serial Adapter.  Distribution and/or Modification of the
-   keyspan.c driver which includes this firmware, in whole or in part,
-   requires the inclusion of this statement."
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
 
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
 */
 
+
 static const struct ezusb_hex_record keyspan_usa19_firmware[] = {
- {0x0026, 10, { 0x12, 0x0d, 0xbb, 0x12, 0x0e, 0xee, 0x12, 0x0d, 0x67, 0x22}},
+ {0x0026, 10, { 0x12, 0x0d, 0xbf, 0x12, 0x0f, 0x47, 0x12, 0x0d, 0x6b, 0x22}},
  {0x0033,  3, { 0x02, 0x00, 0x1a}},
  {0x001a,  4, { 0x53, 0xd8, 0xef, 0x32}},
  {0x0003, 16, { 0x8e, 0x13, 0x8f, 0x14, 0xe5, 0x14, 0x15, 0x14, 0xae, 0x13, 0x70, 0x02, 0x15, 0x13, 0x4e, 0x60}},
- {0x0013,  7, { 0x05, 0x12, 0x0e, 0xdd, 0x80, 0xee, 0x22}},
+ {0x0013,  7, { 0x05, 0x12, 0x0f, 0x36, 0x80, 0xee, 0x22}},
  {0x0023,  3, { 0x02, 0x00, 0x46}},
  {0x0046, 16, { 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xc0, 0xd0, 0x75, 0xd0, 0x08}},
  {0x0056, 16, { 0x30, 0x99, 0x0e, 0x30, 0x08, 0x07, 0xa2, 0x0b, 0x92, 0x9b, 0x85, 0x35, 0x99, 0xc2, 0x99, 0xd2}},
@@ -37,7 +42,7 @@
  {0x00e6, 16, { 0xf5, 0x50, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x20, 0x09, 0x2d, 0x20, 0x06, 0x2a, 0x90}},
  {0x00f6, 16, { 0x7f, 0x9b, 0xe0, 0x30, 0xe3, 0x03, 0x20, 0x0e, 0x20, 0x30, 0x0d, 0x11, 0x90, 0x7d, 0xc1, 0xe0}},
  {0x0043,  3, { 0x02, 0x0f, 0x00}},
- {0x0000,  3, { 0x02, 0x0c, 0x5d}},
+ {0x0000,  3, { 0x02, 0x0c, 0x61}},
  {0x0106, 64, { 0x13, 0x92, 0x0b, 0xa3, 0xe0, 0xf5, 0x35, 0x75, 0x37, 0x03, 0x02, 0x04, 0x2f, 0x75, 0x37, 0x02, 0x90,
   0x7d, 0xc1, 0xe0, 0xf5, 0x35, 0x02, 0x04, 0x2f, 0x75, 0x37, 0x01, 0xc2, 0x08, 0x02, 0x04, 0x2f,
   0xe5, 0x37, 0xc3, 0x95, 0x50, 0x50, 0x03, 0x02, 0x01, 0xcf, 0x90, 0x7f, 0xc6, 0xe0, 0x30, 0xe1,
@@ -110,9 +115,9 @@
   0x15, 0x36, 0x05, 0x2b, 0x43, 0x33, 0x01, 0x80, 0x0b, 0x90, 0x7f, 0xb9, 0xe5, 0x36, 0xf0, 0x75,
   0x36, 0x00, 0xd2, 0x01, 0xd2, 0x12, 0x30, 0x12, 0x05, 0xc2, 0x12, 0x02, 0x00, 0x56, 0xd0, 0xd0,
   0xd0, 0x86, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0xca, 0xe0, 0x30, 0xe1}},
- {0x0586, 64, { 0x03, 0x02, 0x06, 0xa7, 0xe4, 0xf5, 0x13, 0x74, 0x40, 0x25, 0x13, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5,
+ {0x0586, 64, { 0x03, 0x02, 0x06, 0xab, 0xe4, 0xf5, 0x13, 0x74, 0x40, 0x25, 0x13, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5,
   0x83, 0xe0, 0xff, 0xe5, 0x13, 0x7c, 0x00, 0x7b, 0x00, 0x24, 0x38, 0xf9, 0xec, 0x34, 0x00, 0xfa,
-  0xef, 0x12, 0x0d, 0x2f, 0x05, 0x13, 0xe5, 0x13, 0xb4, 0x18, 0xdb, 0xe5, 0x38, 0x60, 0x0c, 0x75,
+  0xef, 0x12, 0x0d, 0x33, 0x05, 0x13, 0xe5, 0x13, 0xb4, 0x18, 0xdb, 0xe5, 0x38, 0x60, 0x0c, 0x75,
   0xc9, 0x20, 0x75, 0xc8, 0x34, 0x85, 0x39, 0xca, 0x85, 0x3a, 0xcb, 0xe5, 0x3b, 0x13, 0x92}},
  {0x05c6, 64, { 0x0d, 0x92, 0x9f, 0xe5, 0x3c, 0x13, 0x92, 0x0e, 0xe5, 0x3d, 0x13, 0x92, 0x11, 0xe5, 0x3e, 0x60, 0x09,
   0x90, 0x7f, 0x98, 0xe0, 0x54, 0xfb, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0x98, 0xe0, 0x44, 0x04, 0xf0,
@@ -125,149 +130,149 @@
  {0x0646, 64, { 0x90, 0x7f, 0x98, 0xe0, 0x54, 0xfd, 0xf0, 0xe5, 0x4a, 0x60, 0x0a, 0xd2, 0x9c, 0xc2, 0x98, 0x75, 0x2c,
   0x01, 0x75, 0x31, 0x1e, 0xe5, 0x4b, 0x60, 0x07, 0xc2, 0x9c, 0xe4, 0xf5, 0x36, 0xf5, 0x2c, 0xe5,
   0x4c, 0x60, 0x03, 0xe4, 0xf5, 0x36, 0xe5, 0x4d, 0x60, 0x02, 0xd2, 0x04, 0xe5, 0x4e, 0x60, 0x0a,
-  0xe5, 0x4a, 0x70, 0x02, 0xf5, 0x31, 0xe5, 0x4e, 0x42, 0x33, 0xe5, 0x4f, 0x60, 0x1b, 0x90}},
+  0xe5, 0x4a, 0x70, 0x02, 0xf5, 0x31, 0xe5, 0x4e, 0x42, 0x33, 0xe5, 0x4f, 0x60, 0x1f, 0x90}},
  {0x0686, 64, { 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74, 0x12, 0xf0, 0x74, 0x32, 0xf0, 0x74, 0x13, 0xf0,
-  0x74, 0x33, 0xf0, 0x74, 0x14, 0xf0, 0x74, 0x34, 0xf0, 0xd2, 0x05, 0xe4, 0x90, 0x7f, 0xcb, 0xf0,
-  0xa2, 0x09, 0xe4, 0x33, 0xff, 0x65, 0x29, 0x60, 0x05, 0x8f, 0x29, 0x43, 0x33, 0x01, 0xa2, 0x06,
-  0xe4, 0x33, 0xff, 0x65, 0x2a, 0x60, 0x05, 0x8f, 0x2a, 0x43, 0x33, 0x01, 0x90, 0x7f, 0x9b}},
- {0x06c6, 64, { 0xe0, 0x54, 0x08, 0xb5, 0x25, 0x0a, 0xe0, 0x54, 0x08, 0x64, 0x08, 0xf5, 0x25, 0x43, 0x33, 0x01, 0x90,
-  0x7f, 0x9b, 0xe0, 0x54, 0x10, 0xb5, 0x26, 0x0a, 0xe0, 0x54, 0x10, 0x64, 0x10, 0xf5, 0x26, 0x43,
-  0x33, 0x01, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x40, 0xb5, 0x27, 0x0a, 0xe0, 0x54, 0x40, 0x64, 0x40,
-  0xf5, 0x27, 0x43, 0x33, 0x01, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x20, 0xb5, 0x28, 0x0a, 0xe0}},
- {0x0706, 64, { 0x54, 0x20, 0x64, 0x20, 0xf5, 0x28, 0x43, 0x33, 0x01, 0x30, 0x04, 0x35, 0xc2, 0xaf, 0x30, 0x01, 0x18,
-  0x90, 0x7f, 0xb8, 0xe0, 0x20, 0xe1, 0x27, 0xe5, 0x36, 0x60, 0x09, 0x90, 0x7f, 0xb7, 0xf0, 0xe4,
-  0xf5, 0x36, 0xc2, 0x01, 0xc2, 0x04, 0x80, 0x16, 0x90, 0x7f, 0xb6, 0xe0, 0x20, 0xe1, 0x0f, 0xe5,
-  0x36, 0x60, 0x09, 0x90, 0x7f, 0xb9, 0xf0, 0xe4, 0xf5, 0x36, 0xd2, 0x01, 0xc2, 0x04, 0xd2}},
- {0x0746, 64, { 0xaf, 0x20, 0x03, 0x37, 0x30, 0x02, 0x1b, 0x90, 0x7f, 0xc6, 0xe0, 0x20, 0xe1, 0x2d, 0x90, 0x7e, 0x40,
-  0xe0, 0x13, 0x92, 0x0a, 0x75, 0x37, 0x01, 0x90, 0x7f, 0xc7, 0xe0, 0xf5, 0x50, 0xd2, 0x03, 0x80,
-  0x19, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x12, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x75,
-  0x37, 0x01, 0x90, 0x7f, 0xc9, 0xe0, 0xf5, 0x50, 0xd2, 0x03, 0x20, 0x10, 0x33, 0x20, 0x00}},
- {0x0786, 64, { 0x06, 0xe5, 0x37, 0x65, 0x50, 0x70, 0x2a, 0x30, 0x03, 0x1a, 0x30, 0x02, 0x09, 0xe4, 0x90, 0x7f, 0xc7,
-  0xf0, 0xc2, 0x02, 0x80, 0x07, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x02, 0xc2, 0x03, 0xe4, 0xf5,
-  0x50, 0xf5, 0x37, 0x30, 0x0a, 0x0a, 0xc2, 0x0a, 0xc2, 0x00, 0x90, 0x7f, 0xbb, 0x74, 0x01, 0xf0,
-  0x30, 0x10, 0x03, 0x02, 0x08, 0xc1, 0x20, 0x03, 0x03, 0x02, 0x08, 0xc1, 0x30, 0x0e, 0x0a}},
- {0x07c6, 64, { 0x90, 0x7f, 0x9b, 0xe0, 0x30, 0xe3, 0x03, 0x02, 0x08, 0xc1, 0x30, 0x06, 0x03, 0x02, 0x08, 0xc1, 0x30,
-  0x09, 0x03, 0x02, 0x08, 0xc1, 0x30, 0x02, 0x62, 0x30, 0x0d, 0x12, 0xaf, 0x37, 0x05, 0x37, 0x74,
-  0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x19, 0xaf, 0x37, 0x05,
-  0x37, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x14, 0xe5}},
- {0x0806, 64, { 0x37, 0xc3, 0x95, 0x50, 0x50, 0x2a, 0x30, 0x0d, 0x12, 0xaf, 0x37, 0x05, 0x37, 0x74, 0x40, 0x2f, 0xf5,
-  0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0b, 0xaf, 0x37, 0x05, 0x37, 0x74, 0x40,
-  0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x35, 0xd2, 0x08, 0x80, 0x6b, 0xc2,
-  0x08, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0xc2, 0x02, 0x80, 0x60, 0x30, 0x0d, 0x12, 0xaf, 0x37}},
- {0x0846, 64, { 0x05, 0x37, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x19, 0xaf,
-  0x37, 0x05, 0x37, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x14,
-  0xe5, 0x37, 0xc3, 0x95, 0x50, 0x50, 0x2a, 0x30, 0x0d, 0x12, 0xaf, 0x37, 0x05, 0x37, 0x74, 0xc0,
-  0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0b, 0xaf, 0x37, 0x05}},
- {0x0886, 64, { 0x37, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x35, 0xd2, 0x08, 0x80,
-  0x09, 0xc2, 0x08, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x02, 0x30, 0x0d, 0x04, 0xa2, 0x19, 0x92,
-  0x9b, 0xd2, 0x10, 0xc2, 0xaf, 0x85, 0x14, 0x99, 0x20, 0x08, 0x0d, 0x30, 0x0a, 0x0a, 0xc2, 0x0a,
-  0xc2, 0x00, 0x90, 0x7f, 0xbb, 0x74, 0x01, 0xf0, 0xd2, 0xaf, 0x90, 0x7f, 0xbc, 0xe0, 0x20}},
- {0x08c6, 64, { 0xe1, 0x51, 0xe5, 0x33, 0x60, 0x4d, 0xe5, 0x31, 0x70, 0x49, 0xe5, 0x33, 0x30, 0xe1, 0x08, 0xe4, 0xf5,
-  0x2f, 0x75, 0x33, 0x01, 0x80, 0x0b, 0xa2, 0x05, 0xe4, 0x33, 0xf5, 0x2f, 0xc2, 0x05, 0xe4, 0xf5,
-  0x33, 0xe4, 0xf5, 0x13, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x13, 0xf9, 0xee, 0x34, 0x00,
-  0xfa, 0x12, 0x0c, 0xe9, 0xff, 0x74, 0x00, 0x25, 0x13, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5}},
- {0x0906, 64, { 0x83, 0xef, 0xf0, 0x05, 0x13, 0xe5, 0x13, 0xb4, 0x0c, 0xdb, 0x90, 0x7f, 0xbd, 0x74, 0x0c, 0xf0, 0x75,
-  0x31, 0x10, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0d, 0x41, 0x09, 0xff, 0x00, 0x0a, 0x73, 0x01,
-  0x0a, 0xdf, 0x03, 0x09, 0x3d, 0x06, 0x09, 0xf0, 0x08, 0x09, 0xe4, 0x09, 0x09, 0xcc, 0x0a, 0x09,
-  0xdb, 0x0b, 0x00, 0x00, 0x0b, 0x2e, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x16, 0x14}},
- {0x0946, 64, { 0x60, 0x57, 0x24, 0x02, 0x70, 0x76, 0x74, 0x0f, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x64, 0x90, 0x7f, 0xd5,
-  0xf0, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03,
-  0x75, 0x82, 0xb5, 0x75, 0x83, 0x0f, 0xef, 0xf0, 0x75, 0x82, 0xae, 0x75, 0x83, 0x0f, 0xf0, 0x75,
-  0x82, 0xa7, 0x75, 0x83, 0x0f, 0xf0, 0x75, 0x82, 0xa0, 0x75, 0x83, 0x0f, 0xf0, 0x90, 0x7f}},
- {0x0986, 64, { 0xea, 0xe0, 0x04, 0x75, 0x82, 0x7b, 0x75, 0x83, 0x0f, 0xf0, 0x74, 0x0f, 0x90, 0x7f, 0xd4, 0xf0, 0x74,
-  0x76, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0e, 0x44,
-  0xea, 0x49, 0x60, 0x0d, 0xea, 0x90, 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b,
-  0x35, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xb4, 0xe0}},
- {0x09c6, 64, { 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0x00, 0xe5, 0x19, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01,
-  0xf0, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x19, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xea,
-  0xe0, 0xf5, 0x18, 0x12, 0x0d, 0x67, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0x00, 0xe5, 0x18, 0xf0, 0x90,
-  0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60}},
- {0x0a06, 64, { 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b, 0xa2, 0x13, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff, 0xa2,
-  0x17, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02,
-  0xf0, 0x02, 0x0b, 0x35, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02,
-  0xf0, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f}},
- {0x0a46, 64, { 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe0,
-  0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02,
-  0x0b, 0x35, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xe8, 0xe0,
-  0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xea, 0xe0}},
- {0x0a86, 64, { 0xb4, 0x01, 0x05, 0xc2, 0x13, 0x02, 0x0b, 0x35, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b,
-  0x35, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4,
-  0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f,
-  0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54}},
- {0x0ac6, 64, { 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f, 0x90,
-  0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x18,
-  0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x13, 0x80, 0x3f, 0x90,
-  0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90}},
- {0x0b06, 64, { 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0,
-  0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90, 0x7f,
-  0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f,
-  0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0x20, 0x15, 0x03, 0x02, 0x0b, 0xcf, 0xe5, 0x31, 0x60}},
- {0x0b46, 64, { 0x02, 0x15, 0x31, 0xe5, 0x36, 0x60, 0x4f, 0x65, 0x34, 0x70, 0x45, 0xe5, 0x32, 0xf4, 0x60, 0x02, 0x05,
-  0x32, 0xe5, 0x32, 0xc3, 0x95, 0x41, 0x40, 0x3d, 0xc2, 0xaf, 0x30, 0x01, 0x18, 0x90, 0x7f, 0xb8,
-  0xe0, 0x20, 0xe1, 0x27, 0x90, 0x7f, 0xb7, 0xe5, 0x36, 0xf0, 0xc2, 0x01, 0xe4, 0xf5, 0x36, 0xf5,
-  0x32, 0xf5, 0x34, 0x80, 0x16, 0x90, 0x7f, 0xb6, 0xe0, 0x20, 0xe1, 0x0f, 0x90, 0x7f, 0xb9}},
- {0x0b86, 64, { 0xe5, 0x36, 0xf0, 0xd2, 0x01, 0xe4, 0xf5, 0x36, 0xf5, 0x32, 0xf5, 0x34, 0xd2, 0xaf, 0x80, 0x06, 0x85,
-  0x36, 0x34, 0xe4, 0xf5, 0x32, 0xe5, 0x2c, 0x60, 0x2f, 0x20, 0x0c, 0x07, 0x90, 0x7f, 0x9b, 0xe0,
-  0x30, 0xe0, 0x0f, 0xe5, 0x2d, 0x60, 0x06, 0xe4, 0xf5, 0x2d, 0x43, 0x33, 0x01, 0xe4, 0xf5, 0x30,
-  0x80, 0x14, 0xe5, 0x30, 0xd3, 0x95, 0x42, 0x50, 0x0d, 0xe5, 0x30, 0xb5, 0x42, 0x06, 0x75}},
- {0x0bc6, 64, { 0x2d, 0x01, 0x43, 0x33, 0x01, 0x05, 0x30, 0xc2, 0x0c, 0x22, 0x75, 0x12, 0x01, 0xc2, 0x14, 0xc2, 0x18,
-  0xc2, 0x13, 0xc2, 0x17, 0xc2, 0x15, 0xc2, 0x12, 0xd2, 0x16, 0xe4, 0xf5, 0x18, 0x90, 0x7f, 0x92,
-  0xe0, 0x54, 0xfd, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x13, 0xe4, 0x33, 0xfe, 0xef,
-  0x4e, 0xf0, 0xd2, 0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f}},
- {0x0c06, 64, { 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53,
-  0x91, 0xef, 0x90, 0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0,
-  0xd2, 0xaf, 0xd2, 0xbc, 0xd2, 0x19, 0x12, 0x0f, 0x36, 0xc2, 0x14, 0x30, 0x15, 0x03, 0x12, 0x05,
-  0x80, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x11, 0x60, 0x08, 0xe0, 0xf5, 0x11, 0x12, 0x0b, 0x3d}},
- {0x0c46, 64, { 0x80, 0xea, 0x30, 0x14, 0x07, 0xc2, 0x14, 0x12, 0x09, 0x1a, 0x80, 0xe0, 0x30, 0x18, 0xdd, 0xc2, 0x18,
-  0x12, 0x00, 0x26, 0x80, 0xd6, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x50, 0x02,
-  0x0c, 0xa4, 0x02, 0x0b, 0xd0, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80,
-  0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c}},
- {0x0c86, 64, { 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46,
-  0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x0e, 0x00,
-  0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe,
-  0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8}},
- {0x0cc6, 64, { 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5,
-  0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7,
-  0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb,
-  0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c, 0xe5}},
- {0x0d06, 64, { 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 0x25, 0x82, 0xf8,
-  0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 0x29, 0xf5, 0x82,
-  0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xf0,
-  0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0, 0x82, 0xf8}},
- {0x0d46, 64, { 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01, 0x93, 0xf5,
-  0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80, 0xdf,
-  0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0x90, 0x7f, 0x96, 0x74, 0x10,
-  0xf0, 0x90, 0x7f, 0x94, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0x9d, 0x04, 0xf0, 0x90, 0x7f, 0x97}},
- {0x0d86, 64, { 0x74, 0x20, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0x03, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x84, 0xf0, 0xe4, 0x90,
-  0x7f, 0x98, 0xf0, 0x90, 0x7f, 0xc7, 0xf0, 0x90, 0x7f, 0xc9, 0xf0, 0x90, 0x7f, 0xcb, 0xf0, 0x75,
-  0x98, 0x40, 0x43, 0xa8, 0x10, 0x90, 0x7f, 0xde, 0x74, 0x1f, 0xf0, 0x90, 0x7f, 0xdf, 0x74, 0x0f,
-  0xf0, 0xd2, 0x15, 0x22, 0xe4, 0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f}},
- {0x0dc6, 64, { 0x93, 0xf0, 0x90, 0x7f, 0x9d, 0xe0, 0x44, 0x02, 0xf0, 0x90, 0x7f, 0x97, 0xe0, 0x44, 0x02, 0xf0, 0x90,
-  0x7f, 0x9d, 0xe0, 0x54, 0xfd, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x20, 0xf0, 0xe4, 0x90, 0x7f, 0x96,
-  0xf0, 0x90, 0x7f, 0x9d, 0xe0, 0x44, 0xfd, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x90, 0x7f, 0x9e,
-  0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x22, 0x0c, 0x24, 0x00, 0x00, 0x00, 0x00}},
- {0x0e06, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x30, 0x00, 0x01, 0x33, 0x01, 0x01, 0x32, 0x00,
-  0x01, 0x37, 0x00, 0x01, 0x50, 0x00, 0x01, 0x36, 0x00, 0x01, 0x34, 0x00, 0xc1, 0x05, 0xc1, 0x0c,
-  0xc1, 0x03, 0xc1, 0x0f, 0xc1, 0x04, 0xc1, 0x0e, 0xc1, 0x11, 0xc1, 0x0a, 0xc1, 0x10, 0xc1, 0x08,
-  0xc1, 0x09, 0xc1, 0x06, 0xc1, 0x00, 0xc1, 0x0d, 0xc1, 0x81, 0xc1, 0x82, 0x00, 0x8f, 0x13}},
- {0x0e46, 64, { 0xe4, 0xf5, 0x14, 0x75, 0x15, 0xff, 0x75, 0x16, 0x0f, 0x75, 0x17, 0xb9, 0xab, 0x15, 0xaa, 0x16, 0xa9,
-  0x17, 0x90, 0x00, 0x01, 0x12, 0x0d, 0x02, 0xb4, 0x03, 0x1d, 0xaf, 0x14, 0x05, 0x14, 0xef, 0xb5,
-  0x13, 0x01, 0x22, 0x12, 0x0c, 0xe9, 0x7e, 0x00, 0x29, 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x15,
-  0xff, 0xf5, 0x16, 0x89, 0x17, 0x80, 0xd4, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x00, 0x22, 0xc0}},
- {0x0e86, 64, { 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x30, 0x16, 0x04,
-  0xc2, 0x16, 0x80, 0x02, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0,
+  0x74, 0x33, 0xf0, 0x74, 0x14, 0xf0, 0x74, 0x34, 0xf0, 0xd2, 0x02, 0xd2, 0x01, 0xd2, 0x05, 0xe4,
+  0x90, 0x7f, 0xcb, 0xf0, 0xa2, 0x09, 0xe4, 0x33, 0xff, 0x65, 0x29, 0x60, 0x05, 0x8f, 0x29, 0x43,
+  0x33, 0x01, 0xa2, 0x06, 0xe4, 0x33, 0xff, 0x65, 0x2a, 0x60, 0x05, 0x8f, 0x2a, 0x43, 0x33}},
+ {0x06c6, 64, { 0x01, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x08, 0xb5, 0x25, 0x0a, 0xe0, 0x54, 0x08, 0x64, 0x08, 0xf5, 0x25,
+  0x43, 0x33, 0x01, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x10, 0xb5, 0x26, 0x0a, 0xe0, 0x54, 0x10, 0x64,
+  0x10, 0xf5, 0x26, 0x43, 0x33, 0x01, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x40, 0xb5, 0x27, 0x0a, 0xe0,
+  0x54, 0x40, 0x64, 0x40, 0xf5, 0x27, 0x43, 0x33, 0x01, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x20}},
+ {0x0706, 64, { 0xb5, 0x28, 0x0a, 0xe0, 0x54, 0x20, 0x64, 0x20, 0xf5, 0x28, 0x43, 0x33, 0x01, 0x30, 0x04, 0x35, 0xc2,
+  0xaf, 0x30, 0x01, 0x18, 0x90, 0x7f, 0xb8, 0xe0, 0x20, 0xe1, 0x27, 0xe5, 0x36, 0x60, 0x09, 0x90,
+  0x7f, 0xb7, 0xf0, 0xe4, 0xf5, 0x36, 0xc2, 0x01, 0xc2, 0x04, 0x80, 0x16, 0x90, 0x7f, 0xb6, 0xe0,
+  0x20, 0xe1, 0x0f, 0xe5, 0x36, 0x60, 0x09, 0x90, 0x7f, 0xb9, 0xf0, 0xe4, 0xf5, 0x36, 0xd2}},
+ {0x0746, 64, { 0x01, 0xc2, 0x04, 0xd2, 0xaf, 0x20, 0x03, 0x37, 0x30, 0x02, 0x1b, 0x90, 0x7f, 0xc6, 0xe0, 0x20, 0xe1,
+  0x2d, 0x90, 0x7e, 0x40, 0xe0, 0x13, 0x92, 0x0a, 0x75, 0x37, 0x01, 0x90, 0x7f, 0xc7, 0xe0, 0xf5,
+  0x50, 0xd2, 0x03, 0x80, 0x19, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x12, 0x90, 0x7d, 0xc0, 0xe0,
+  0x13, 0x92, 0x0a, 0x75, 0x37, 0x01, 0x90, 0x7f, 0xc9, 0xe0, 0xf5, 0x50, 0xd2, 0x03, 0x20}},
+ {0x0786, 64, { 0x10, 0x33, 0x20, 0x00, 0x06, 0xe5, 0x37, 0x65, 0x50, 0x70, 0x2a, 0x30, 0x03, 0x1a, 0x30, 0x02, 0x09,
+  0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0xc2, 0x02, 0x80, 0x07, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x02,
+  0xc2, 0x03, 0xe4, 0xf5, 0x50, 0xf5, 0x37, 0x30, 0x0a, 0x0a, 0xc2, 0x0a, 0xc2, 0x00, 0x90, 0x7f,
+  0xbb, 0x74, 0x01, 0xf0, 0x30, 0x10, 0x03, 0x02, 0x08, 0xc5, 0x20, 0x03, 0x03, 0x02, 0x08}},
+ {0x07c6, 64, { 0xc5, 0x30, 0x0e, 0x0a, 0x90, 0x7f, 0x9b, 0xe0, 0x30, 0xe3, 0x03, 0x02, 0x08, 0xc5, 0x30, 0x06, 0x03,
+  0x02, 0x08, 0xc5, 0x30, 0x09, 0x03, 0x02, 0x08, 0xc5, 0x30, 0x02, 0x62, 0x30, 0x0d, 0x12, 0xaf,
+  0x37, 0x05, 0x37, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92,
+  0x19, 0xaf, 0x37, 0x05, 0x37, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83}},
+ {0x0806, 64, { 0xe0, 0xf5, 0x14, 0xe5, 0x37, 0xc3, 0x95, 0x50, 0x50, 0x2a, 0x30, 0x0d, 0x12, 0xaf, 0x37, 0x05, 0x37,
+  0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0b, 0xaf, 0x37,
+  0x05, 0x37, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x35, 0xd2,
+  0x08, 0x80, 0x6b, 0xc2, 0x08, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0xc2, 0x02, 0x80, 0x60, 0x30}},
+ {0x0846, 64, { 0x0d, 0x12, 0xaf, 0x37, 0x05, 0x37, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0,
+  0x13, 0x92, 0x19, 0xaf, 0x37, 0x05, 0x37, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5,
+  0x83, 0xe0, 0xf5, 0x14, 0xe5, 0x37, 0xc3, 0x95, 0x50, 0x50, 0x2a, 0x30, 0x0d, 0x12, 0xaf, 0x37,
+  0x05, 0x37, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92}},
+ {0x0886, 64, { 0x0b, 0xaf, 0x37, 0x05, 0x37, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5,
+  0x35, 0xd2, 0x08, 0x80, 0x09, 0xc2, 0x08, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x02, 0x30, 0x0d,
+  0x04, 0xa2, 0x19, 0x92, 0x9b, 0xd2, 0x10, 0xc2, 0xaf, 0x85, 0x14, 0x99, 0x20, 0x08, 0x0d, 0x30,
+  0x0a, 0x0a, 0xc2, 0x0a, 0xc2, 0x00, 0x90, 0x7f, 0xbb, 0x74, 0x01, 0xf0, 0xd2, 0xaf, 0x90}},
+ {0x08c6, 64, { 0x7f, 0xbc, 0xe0, 0x20, 0xe1, 0x51, 0xe5, 0x33, 0x60, 0x4d, 0xe5, 0x31, 0x70, 0x49, 0xe5, 0x33, 0x30,
+  0xe1, 0x08, 0xe4, 0xf5, 0x2f, 0x75, 0x33, 0x01, 0x80, 0x0b, 0xa2, 0x05, 0xe4, 0x33, 0xf5, 0x2f,
+  0xc2, 0x05, 0xe4, 0xf5, 0x33, 0xe4, 0xf5, 0x13, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x13,
+  0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0c, 0xed, 0xff, 0x74, 0x00, 0x25, 0x13, 0xf5, 0x82}},
+ {0x0906, 64, { 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x13, 0xe5, 0x13, 0xb4, 0x0c, 0xdb, 0x90, 0x7f, 0xbd,
+  0x74, 0x0c, 0xf0, 0x75, 0x31, 0x10, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0d, 0x45, 0x0a, 0x03,
+  0x00, 0x0a, 0x77, 0x01, 0x0a, 0xe3, 0x03, 0x09, 0x41, 0x06, 0x09, 0xf4, 0x08, 0x09, 0xe8, 0x09,
+  0x09, 0xd0, 0x0a, 0x09, 0xdf, 0x0b, 0x00, 0x00, 0x0b, 0x32, 0x90, 0x7f, 0xeb, 0xe0, 0x24}},
+ {0x0946, 64, { 0xfe, 0x60, 0x16, 0x14, 0x60, 0x57, 0x24, 0x02, 0x70, 0x76, 0x74, 0x0f, 0x90, 0x7f, 0xd4, 0xf0, 0x74,
+  0x64, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02,
+  0x80, 0x02, 0x7f, 0x03, 0x75, 0x82, 0xb5, 0x75, 0x83, 0x0f, 0xef, 0xf0, 0x75, 0x82, 0xae, 0x75,
+  0x83, 0x0f, 0xf0, 0x75, 0x82, 0xa7, 0x75, 0x83, 0x0f, 0xf0, 0x75, 0x82, 0xa0, 0x75, 0x83}},
+ {0x0986, 64, { 0x0f, 0xf0, 0x90, 0x7f, 0xea, 0xe0, 0x04, 0x75, 0x82, 0x7b, 0x75, 0x83, 0x0f, 0xf0, 0x74, 0x0f, 0x90,
+  0x7f, 0xd4, 0xf0, 0x74, 0x76, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xea, 0xe0,
+  0xff, 0x12, 0x0e, 0x48, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90, 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f,
+  0xd5, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x39}},
+ {0x09c6, 64, { 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0x00, 0xe5, 0x19, 0xf0, 0x90,
+  0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x19, 0x02, 0x0b,
+  0x39, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x18, 0x12, 0x0d, 0x6b, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0x00,
+  0xe5, 0x18, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xe8}},
+ {0x0a06, 64, { 0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b, 0xa2, 0x13, 0xe4, 0x33, 0xff,
+  0x25, 0xe0, 0xff, 0xa2, 0x17, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90,
+  0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x39, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3, 0xf0, 0x90,
+  0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80}},
+ {0x0a46, 64, { 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34,
+  0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5,
+  0x74, 0x02, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x39,
+  0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x39}},
+ {0x0a86, 64, { 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x05, 0xc2, 0x13, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
+  0x01, 0xf0, 0x02, 0x0b, 0x39, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38, 0x90, 0x7f, 0xec, 0xe0, 0xf4,
+  0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5,
+  0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff}},
+ {0x0ac6, 64, { 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20,
+  0xf0, 0x80, 0x5f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x56, 0x90, 0x7f, 0xe8, 0xe0,
+  0x24, 0xfe, 0x60, 0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x04, 0xd2,
+  0x13, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea}},
+ {0x0b06, 64, { 0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54,
+  0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0,
+  0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
+  0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0x20, 0x15, 0x03, 0x02, 0x0b}},
+ {0x0b46, 64, { 0xd3, 0xe5, 0x31, 0x60, 0x02, 0x15, 0x31, 0xe5, 0x36, 0x60, 0x4f, 0x65, 0x34, 0x70, 0x45, 0xe5, 0x32,
+  0xf4, 0x60, 0x02, 0x05, 0x32, 0xe5, 0x32, 0xc3, 0x95, 0x41, 0x40, 0x3d, 0xc2, 0xaf, 0x30, 0x01,
+  0x18, 0x90, 0x7f, 0xb8, 0xe0, 0x20, 0xe1, 0x27, 0x90, 0x7f, 0xb7, 0xe5, 0x36, 0xf0, 0xc2, 0x01,
+  0xe4, 0xf5, 0x36, 0xf5, 0x32, 0xf5, 0x34, 0x80, 0x16, 0x90, 0x7f, 0xb6, 0xe0, 0x20, 0xe1}},
+ {0x0b86, 64, { 0x0f, 0x90, 0x7f, 0xb9, 0xe5, 0x36, 0xf0, 0xd2, 0x01, 0xe4, 0xf5, 0x36, 0xf5, 0x32, 0xf5, 0x34, 0xd2,
+  0xaf, 0x80, 0x06, 0x85, 0x36, 0x34, 0xe4, 0xf5, 0x32, 0xe5, 0x2c, 0x60, 0x2f, 0x20, 0x0c, 0x07,
+  0x90, 0x7f, 0x9b, 0xe0, 0x30, 0xe0, 0x0f, 0xe5, 0x2d, 0x60, 0x06, 0xe4, 0xf5, 0x2d, 0x43, 0x33,
+  0x01, 0xe4, 0xf5, 0x30, 0x80, 0x14, 0xe5, 0x30, 0xd3, 0x95, 0x42, 0x50, 0x0d, 0xe5, 0x30}},
+ {0x0bc6, 64, { 0xb5, 0x42, 0x06, 0x75, 0x2d, 0x01, 0x43, 0x33, 0x01, 0x05, 0x30, 0xc2, 0x0c, 0x22, 0x75, 0x12, 0x01,
+  0xc2, 0x14, 0xc2, 0x18, 0xc2, 0x13, 0xc2, 0x17, 0xc2, 0x15, 0xc2, 0x12, 0xd2, 0x16, 0xe4, 0xf5,
+  0x18, 0x90, 0x7f, 0x92, 0xe0, 0x54, 0xfd, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x13,
+  0xe4, 0x33, 0xfe, 0xef, 0x4e, 0xf0, 0xd2, 0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74}},
+ {0x0c06, 64, { 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90,
+  0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae,
+  0xe0, 0x44, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2, 0xbc, 0xd2, 0x19, 0x12, 0x0e, 0xda, 0xc2, 0x14, 0x30,
+  0x15, 0x03, 0x12, 0x05, 0x80, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x11, 0x60, 0x08, 0xe0, 0xf5}},
+ {0x0c46, 64, { 0x11, 0x12, 0x0b, 0x41, 0x80, 0xea, 0x30, 0x14, 0x07, 0xc2, 0x14, 0x12, 0x09, 0x1e, 0x80, 0xe0, 0x30,
+  0x18, 0xdd, 0xc2, 0x18, 0x12, 0x00, 0x26, 0x80, 0xd6, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd,
+  0x75, 0x81, 0x50, 0x02, 0x0c, 0xa8, 0x02, 0x0b, 0xd4, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3,
+  0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8}},
+ {0x0c86, 64, { 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4,
+  0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
+  0x80, 0x90, 0x0e, 0x04, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5,
+  0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0}},
+ {0x0cc6, 64, { 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5,
+  0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca,
+  0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50,
+  0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22}},
+ {0x0d06, 64, { 0xbb, 0x01, 0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06,
+  0xe9, 0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5,
+  0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89,
+  0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0}},
+ {0x0d46, 64, { 0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8,
+  0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3,
+  0xa3, 0xa3, 0x80, 0xdf, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0x90,
+  0x7f, 0x96, 0x74, 0x10, 0xf0, 0x90, 0x7f, 0x94, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0x9d, 0x04}},
+ {0x0d86, 64, { 0xf0, 0x90, 0x7f, 0x97, 0x74, 0x20, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0x03, 0xf0, 0x90, 0x7f, 0x9e, 0x74,
+  0x84, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x90, 0x7f, 0xc7, 0xf0, 0x90, 0x7f, 0xc9, 0xf0, 0x90,
+  0x7f, 0xcb, 0xf0, 0x75, 0x98, 0x40, 0x43, 0xa8, 0x10, 0x90, 0x7f, 0xde, 0x74, 0x1f, 0xf0, 0x90,
+  0x7f, 0xdf, 0x74, 0x0f, 0xf0, 0xd2, 0x15, 0x22, 0xe4, 0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f}},
+ {0x0dc6, 64, { 0x94, 0xf0, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9d, 0xe0, 0x44, 0x02, 0xf0, 0x90, 0x7f, 0x97, 0xe0,
+  0x44, 0x02, 0xf0, 0x90, 0x7f, 0x9d, 0xe0, 0x54, 0xfd, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x20, 0xf0,
+  0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90, 0x7f, 0x9d, 0xe0, 0x44, 0xfd, 0xf0, 0xe4, 0x90, 0x7f, 0x97,
+  0xf0, 0x90, 0x7f, 0x9e, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x22, 0x0c, 0x24}},
+ {0x0e06, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x30, 0x00, 0x01, 0x33,
+  0x01, 0x01, 0x32, 0x00, 0x01, 0x37, 0x00, 0x01, 0x50, 0x00, 0x01, 0x36, 0x00, 0x01, 0x34, 0x00,
+  0xc1, 0x05, 0xc1, 0x0c, 0xc1, 0x03, 0xc1, 0x0f, 0xc1, 0x04, 0xc1, 0x0e, 0xc1, 0x11, 0xc1, 0x0a,
+  0xc1, 0x10, 0xc1, 0x08, 0xc1, 0x09, 0xc1, 0x06, 0xc1, 0x00, 0xc1, 0x0d, 0xc1, 0x81, 0xc1}},
+ {0x0e46, 64, { 0x82, 0x00, 0x8f, 0x13, 0xe4, 0xf5, 0x14, 0x75, 0x15, 0xff, 0x75, 0x16, 0x0f, 0x75, 0x17, 0xb9, 0xab,
+  0x15, 0xaa, 0x16, 0xa9, 0x17, 0x90, 0x00, 0x01, 0x12, 0x0d, 0x06, 0xb4, 0x03, 0x1d, 0xaf, 0x14,
+  0x05, 0x14, 0xef, 0xb5, 0x13, 0x01, 0x22, 0x12, 0x0c, 0xed, 0x7e, 0x00, 0x29, 0xff, 0xee, 0x3a,
+  0xa9, 0x07, 0x75, 0x15, 0xff, 0xf5, 0x16, 0x89, 0x17, 0x80, 0xd4, 0x7b, 0x00, 0x7a, 0x00}},
+ {0x0e86, 64, { 0x79, 0x00, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86,
+  0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0,
   0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83,
-  0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4, 0xe4}},
- {0x0ec6, 64, { 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0,
-  0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3,
-  0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87,
-  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x02, 0x0f, 0x0f, 0x00, 0x02, 0x0f}},
- {0x0f06, 64, { 0x04, 0x00, 0x02, 0x0e, 0xb3, 0x00, 0x02, 0x0e, 0x85, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85,
-  0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x14, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74,
-  0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90,
-  0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x19, 0x04, 0xe0, 0x44}},
- {0x0f46, 64, { 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x00, 0x03, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0,
-  0x44, 0x04, 0xf0, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x00,
+  0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x14, 0x53, 0x91}},
+ {0x0ec6, 64, { 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83,
+  0xd0, 0xe0, 0x32, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x19,
+  0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x00, 0x03, 0x90, 0x7f, 0xd6, 0xe0,
+  0x54, 0xf7, 0xf0, 0xe0, 0x44, 0x04, 0xf0, 0x22, 0x00, 0x02, 0x0e, 0xb3, 0x00, 0x02, 0x0f}},
+ {0x0f06, 64, { 0x04, 0x00, 0x02, 0x0e, 0x89, 0x00, 0x02, 0x0f, 0x0f, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85,
+  0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74,
+  0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x74,
+  0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9}},
+ {0x0f46, 64, { 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x10,
   0x01, 0xff, 0x00, 0x00, 0x40, 0xcd, 0x06, 0x07, 0x01, 0x01, 0x00, 0x01, 0x02, 0x00, 0x02, 0x09,
   0x02, 0x43, 0x00, 0x01, 0x01, 0x00, 0x80, 0x32, 0x09, 0x04, 0x00, 0x00, 0x07, 0xff, 0x00}},
  {0x0f86, 64, { 0x00, 0x00, 0x07, 0x05, 0x01, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07,
@@ -276,5 +281,5 @@
   0x00, 0x01, 0x04, 0x03, 0x09, 0x04, 0x10, 0x03, 0x4b, 0x00, 0x65, 0x00, 0x79, 0x00, 0x73}},
  {0x0fc6, 23, { 0x00, 0x70, 0x00, 0x61, 0x00, 0x6e, 0x00, 0x0e, 0x03, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x69, 0x00,
   0x61, 0x00, 0x6c, 0x00, 0x00, 0x00}},
-{ 0xffff,	0,	{0x00} }
+ {0xffff,	0,	{0x00} }
 };
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa19qi_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa19qi_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa19qi_fw.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa19qi_fw.h	Mon Nov 25 12:27:09 2002
@@ -0,0 +1,284 @@
+/* keyspan_usa19qi_fw.h
+ 
+	The firmware contained herein as keyspn_usa19qi_fw.h is
+
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
+
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
+
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
+
+*/
+
+static const struct ezusb_hex_record keyspan_usa19qi_firmware[] = {
+ {0x0033,  3, { 0x02, 0x00, 0x1a}},
+ {0x001a,  4, { 0x53, 0xd8, 0xef, 0x32}},
+ {0x0003, 16, { 0x8e, 0x11, 0x8f, 0x12, 0xe5, 0x12, 0x15, 0x12, 0xae, 0x11, 0x70, 0x02, 0x15, 0x11, 0x4e, 0x60}},
+ {0x0013,  7, { 0x05, 0x12, 0x0f, 0x84, 0x80, 0xee, 0x22}},
+ {0x0023,  3, { 0x02, 0x00, 0x46}},
+ {0x0046, 16, { 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xc0, 0xd0, 0x75, 0xd0, 0x08}},
+ {0x0056, 16, { 0x30, 0x99, 0x0e, 0x30, 0x0b, 0x07, 0xa2, 0x0e, 0x92, 0x9b, 0x85, 0x36, 0x99, 0xc2, 0x99, 0xd2}},
+ {0x0066, 16, { 0x12, 0x20, 0x12, 0x03, 0x02, 0x04, 0x1e, 0xc2, 0x12, 0x20, 0x03, 0x03, 0x02, 0x02, 0x4e, 0x20}},
+ {0x0076, 16, { 0x0b, 0x03, 0x02, 0x01, 0x26, 0xe5, 0x3a, 0xc3, 0x95, 0x53, 0x50, 0x3c, 0x20, 0x0c, 0x34, 0x20}},
+ {0x0086, 16, { 0x09, 0x31, 0x90, 0x7f, 0x9b, 0xe0, 0x55, 0x38, 0x70, 0x29, 0x30, 0x10, 0x12, 0xaf, 0x3a, 0x05}},
+ {0x0096, 16, { 0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0e, 0xaf}},
+ {0x00a6, 16, { 0x3a, 0x05, 0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x36}},
+ {0x00b6, 16, { 0x02, 0x04, 0x1c, 0xc2, 0x0b, 0x02, 0x04, 0x1c, 0x90, 0x7f, 0xc7, 0xe4, 0xf0, 0xc2, 0x03, 0x30}},
+ {0x00c6, 16, { 0x0d, 0x0c, 0xc2, 0x0d, 0x90, 0x7f, 0xbb, 0x04, 0xf0, 0xc2, 0x0b, 0x02, 0x04, 0x1c, 0x90, 0x7f}},
+ {0x00d6, 16, { 0xc8, 0xe0, 0x30, 0xe1, 0x05, 0xc2, 0x0b, 0x02, 0x04, 0x1c, 0x90, 0x7f, 0xc9, 0xe0, 0xf5, 0x53}},
+ {0x00e6, 16, { 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x0d, 0x75, 0x16, 0xff, 0x20, 0x0c, 0x2b, 0x20, 0x09, 0x28}},
+ {0x00f6, 16, { 0x90, 0x7f, 0x9b, 0xe0, 0x55, 0x38, 0x70, 0x20, 0x30, 0x10, 0x11, 0x90, 0x7d, 0xc1, 0xe0, 0x13}},
+ {0x0043,  3, { 0x02, 0x0e, 0x00}},
+ {0x0000,  3, { 0x02, 0x00, 0x26}},
+ {0x0026, 12, { 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x54, 0x02, 0x0b, 0x28}},
+ {0x0106, 64, { 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x36, 0x75, 0x3a, 0x03, 0x02, 0x04, 0x1c, 0x75, 0x3a, 0x02, 0x90, 0x7d,
+  0xc1, 0xe0, 0xf5, 0x36, 0x02, 0x04, 0x1c, 0x75, 0x3a, 0x01, 0xc2, 0x0b, 0x02, 0x04, 0x1c, 0xe5,
+  0x3a, 0xc3, 0x95, 0x53, 0x50, 0x03, 0x02, 0x01, 0xc9, 0x90, 0x7f, 0xc6, 0xe0, 0x30, 0xe1, 0x07,
+  0xc2, 0x14, 0xc2, 0x05, 0x02, 0x04, 0x1c, 0x90, 0x7f, 0xc7, 0xe0, 0xf5, 0x53, 0x90, 0x7e}},
+ {0x0146, 64, { 0x40, 0xe0, 0x13, 0x92, 0x0d, 0x75, 0x16, 0xff, 0x20, 0x0c, 0x70, 0x20, 0x09, 0x6d, 0x90, 0x7f, 0x9b,
+  0xe0, 0x55, 0x38, 0x70, 0x65, 0x30, 0x10, 0x10, 0x90, 0x7e, 0x41, 0xe0, 0x13, 0x92, 0x9b, 0xa3,
+  0xe0, 0xf5, 0x99, 0x75, 0x3a, 0x03, 0x80, 0x09, 0x90, 0x7e, 0x41, 0xe0, 0xf5, 0x99, 0x75, 0x3a,
+  0x02, 0xe5, 0x3a, 0xc3, 0x95, 0x53, 0x40, 0x17, 0x90, 0x7f, 0xc7, 0xe4, 0xf0, 0xc2, 0x03}},
+ {0x0186, 64, { 0x20, 0x0d, 0x03, 0x02, 0x04, 0x1c, 0xc2, 0x0d, 0x90, 0x7f, 0xbb, 0x04, 0xf0, 0x02, 0x04, 0x1c, 0x30,
+  0x10, 0x12, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83,
+  0xe0, 0x13, 0x92, 0x0e, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e,
+  0xf5, 0x83, 0xe0, 0xf5, 0x36, 0xd2, 0x0b, 0x02, 0x04, 0x1c, 0x75, 0x3a, 0x01, 0xc2, 0x14}},
+ {0x01c6, 64, { 0x02, 0x04, 0x1c, 0x30, 0x0c, 0x03, 0x02, 0x02, 0x49, 0x20, 0x09, 0x77, 0x90, 0x7f, 0x9b, 0xe0, 0x55,
+  0x38, 0x70, 0x6f, 0x30, 0x10, 0x12, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4,
+  0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x9b, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0x40, 0x2f, 0xf5,
+  0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x99, 0xe5, 0x3a, 0xc3, 0x95, 0x53, 0x40}},
+ {0x0206, 64, { 0x17, 0x90, 0x7f, 0xc7, 0xe4, 0xf0, 0xc2, 0x03, 0x20, 0x0d, 0x03, 0x02, 0x04, 0x1c, 0xc2, 0x0d, 0x90,
+  0x7f, 0xbb, 0x04, 0xf0, 0x02, 0x04, 0x1c, 0x30, 0x10, 0x12, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0x40,
+  0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0e, 0xaf, 0x3a, 0x05, 0x3a,
+  0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x36, 0xd2, 0x0b}},
+ {0x0246, 64, { 0x02, 0x04, 0x1c, 0xc2, 0x14, 0x02, 0x04, 0x1c, 0x20, 0x0b, 0x03, 0x02, 0x02, 0xff, 0xe5, 0x3a, 0xc3,
+  0x95, 0x53, 0x50, 0x3c, 0x20, 0x0c, 0x34, 0x20, 0x09, 0x31, 0x90, 0x7f, 0x9b, 0xe0, 0x55, 0x38,
+  0x70, 0x29, 0x30, 0x10, 0x12, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34,
+  0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0e, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5}},
+ {0x0286, 64, { 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x36, 0x02, 0x04, 0x1c, 0xc2, 0x0b, 0x02, 0x04, 0x1c,
+  0x90, 0x7f, 0xc9, 0xe4, 0xf0, 0xd2, 0x03, 0x30, 0x0d, 0x0c, 0xc2, 0x0d, 0x90, 0x7f, 0xbb, 0x04,
+  0xf0, 0xc2, 0x0b, 0x02, 0x04, 0x1c, 0x90, 0x7f, 0xc6, 0xe0, 0x30, 0xe1, 0x05, 0xc2, 0x0b, 0x02,
+  0x04, 0x1c, 0x90, 0x7f, 0xc7, 0xe0, 0xf5, 0x53, 0x90, 0x7e, 0x40, 0xe0, 0x13, 0x92, 0x0d}},
+ {0x02c6, 64, { 0x75, 0x16, 0xff, 0x20, 0x0c, 0x2b, 0x20, 0x09, 0x28, 0x90, 0x7f, 0x9b, 0xe0, 0x55, 0x38, 0x70, 0x20,
+  0x30, 0x10, 0x11, 0x90, 0x7e, 0x41, 0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x36, 0x75, 0x3a,
+  0x03, 0x02, 0x04, 0x1c, 0x75, 0x3a, 0x02, 0x90, 0x7e, 0x41, 0xe0, 0xf5, 0x36, 0x02, 0x04, 0x1c,
+  0x75, 0x3a, 0x01, 0xc2, 0x0b, 0x02, 0x04, 0x1c, 0xe5, 0x3a, 0xc3, 0x95, 0x53, 0x50, 0x03}},
+ {0x0306, 64, { 0x02, 0x03, 0xa2, 0x90, 0x7f, 0xc8, 0xe0, 0x30, 0xe1, 0x07, 0xc2, 0x14, 0xc2, 0x05, 0x02, 0x04, 0x1c,
+  0x90, 0x7f, 0xc9, 0xe0, 0xf5, 0x53, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x0d, 0x75, 0x16, 0xff,
+  0x20, 0x0c, 0x70, 0x20, 0x09, 0x6d, 0x90, 0x7f, 0x9b, 0xe0, 0x55, 0x38, 0x70, 0x65, 0x30, 0x10,
+  0x10, 0x90, 0x7d, 0xc1, 0xe0, 0x13, 0x92, 0x9b, 0xa3, 0xe0, 0xf5, 0x99, 0x75, 0x3a, 0x03}},
+ {0x0346, 64, { 0x80, 0x09, 0x90, 0x7d, 0xc1, 0xe0, 0xf5, 0x99, 0x75, 0x3a, 0x02, 0xe5, 0x3a, 0xc3, 0x95, 0x53, 0x40,
+  0x17, 0x90, 0x7f, 0xc9, 0xe4, 0xf0, 0xd2, 0x03, 0x20, 0x0d, 0x03, 0x02, 0x04, 0x1c, 0xc2, 0x0d,
+  0x90, 0x7f, 0xbb, 0x04, 0xf0, 0x02, 0x04, 0x1c, 0x30, 0x10, 0x12, 0xaf, 0x3a, 0x05, 0x3a, 0x74,
+  0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0e, 0xaf, 0x3a}},
+ {0x0386, 64, { 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x36, 0xd2, 0x0b,
+  0x02, 0x04, 0x1c, 0x75, 0x3a, 0x01, 0xc2, 0x14, 0x02, 0x04, 0x1c, 0x20, 0x0c, 0x75, 0x20, 0x09,
+  0x72, 0x90, 0x7f, 0x9b, 0xe0, 0x55, 0x38, 0x70, 0x6a, 0x30, 0x10, 0x12, 0xaf, 0x3a, 0x05, 0x3a,
+  0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x9b, 0xaf}},
+ {0x03c6, 64, { 0x3a, 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x99, 0xe5,
+  0x3a, 0xc3, 0x95, 0x53, 0x40, 0x13, 0x90, 0x7f, 0xc9, 0xe4, 0xf0, 0xd2, 0x03, 0x30, 0x0d, 0x35,
+  0xc2, 0x0d, 0x90, 0x7f, 0xbb, 0x04, 0xf0, 0x80, 0x2c, 0x30, 0x10, 0x12, 0xaf, 0x3a, 0x05, 0x3a,
+  0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0e, 0xaf}},
+ {0x0406, 64, { 0x3a, 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x36, 0xd2,
+  0x0b, 0x80, 0x02, 0xc2, 0x14, 0xd2, 0x01, 0x20, 0x98, 0x03, 0x02, 0x05, 0x5a, 0xc2, 0x98, 0x20,
+  0x02, 0x03, 0x02, 0x04, 0xc7, 0x20, 0x16, 0x27, 0xaf, 0x39, 0x05, 0x39, 0x74, 0x80, 0x2f, 0xf5,
+  0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe5, 0x99, 0xf0, 0x30, 0x10, 0x4d, 0xaf, 0x39, 0x05}},
+ {0x0446, 64, { 0x39, 0x74, 0x80, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe5, 0x98, 0xf0, 0x80, 0x3a, 0x85,
+  0x99, 0x10, 0xe5, 0x10, 0xb5, 0x47, 0x04, 0xd2, 0x09, 0x80, 0x2e, 0xe5, 0x10, 0xb5, 0x46, 0x04,
+  0xc2, 0x09, 0x80, 0x25, 0xaf, 0x39, 0x05, 0x39, 0x74, 0x80, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e,
+  0xf5, 0x83, 0xe5, 0x10, 0xf0, 0x30, 0x10, 0x11, 0xaf, 0x39, 0x05, 0x39, 0x74, 0x80, 0x2f}},
+ {0x0486, 64, { 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe5, 0x98, 0xf0, 0xd2, 0x0f, 0xe5, 0x39, 0xc3, 0x95, 0x43,
+  0x50, 0x03, 0x02, 0x05, 0x58, 0x90, 0x7f, 0xb8, 0xe0, 0x30, 0xe1, 0x16, 0xe5, 0x39, 0xc3, 0x94,
+  0x40, 0x50, 0x03, 0x02, 0x05, 0x58, 0x15, 0x39, 0x15, 0x39, 0x05, 0x2b, 0x43, 0x34, 0x01, 0x02,
+  0x05, 0x58, 0x90, 0x7f, 0xb7, 0xe5, 0x39, 0xf0, 0x75, 0x39, 0x00, 0xc2, 0x02, 0x02, 0x05}},
+ {0x04c6, 64, { 0x58, 0x20, 0x16, 0x27, 0xaf, 0x39, 0x05, 0x39, 0x74, 0x00, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5,
+  0x83, 0xe5, 0x99, 0xf0, 0x30, 0x10, 0x4d, 0xaf, 0x39, 0x05, 0x39, 0x74, 0x00, 0x2f, 0xf5, 0x82,
+  0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe5, 0x98, 0xf0, 0x80, 0x3a, 0x85, 0x99, 0x10, 0xe5, 0x10, 0xb5,
+  0x47, 0x04, 0xd2, 0x09, 0x80, 0x2e, 0xe5, 0x10, 0xb5, 0x46, 0x04, 0xc2, 0x09, 0x80, 0x25}},
+ {0x0506, 64, { 0xaf, 0x39, 0x05, 0x39, 0x74, 0x00, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe5, 0x10, 0xf0,
+  0x30, 0x10, 0x11, 0xaf, 0x39, 0x05, 0x39, 0x74, 0x00, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5,
+  0x83, 0xe5, 0x98, 0xf0, 0xd2, 0x0f, 0xe5, 0x39, 0xc3, 0x95, 0x43, 0x40, 0x24, 0x90, 0x7f, 0xb6,
+  0xe0, 0x30, 0xe1, 0x12, 0xe5, 0x39, 0xc3, 0x94, 0x40, 0x40, 0x16, 0x15, 0x39, 0x15, 0x39}},
+ {0x0546, 64, { 0x05, 0x2b, 0x43, 0x34, 0x01, 0x80, 0x0b, 0x90, 0x7f, 0xb9, 0xe5, 0x39, 0xf0, 0x75, 0x39, 0x00, 0xd2,
+  0x02, 0xd2, 0x01, 0x30, 0x01, 0x05, 0xc2, 0x01, 0x02, 0x00, 0x56, 0xd0, 0xd0, 0xd0, 0x86, 0xd0,
+  0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0xbc, 0xe0, 0x20, 0xe1, 0x51, 0xe5, 0x34, 0x60,
+  0x4d, 0xe5, 0x31, 0x70, 0x49, 0xe5, 0x34, 0x30, 0xe1, 0x08, 0xe4, 0xf5, 0x2f, 0x75, 0x34}},
+ {0x0586, 64, { 0x01, 0x80, 0x0b, 0xa2, 0x08, 0xe4, 0x33, 0xf5, 0x2f, 0xc2, 0x08, 0xe4, 0xf5, 0x34, 0xe4, 0xf5, 0x11,
+  0x7e, 0x00, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x11, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0d, 0x06,
+  0xff, 0x74, 0x00, 0x25, 0x11, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x11,
+  0xe5, 0x11, 0xb4, 0x0c, 0xdb, 0x90, 0x7f, 0xbd, 0x74, 0x0c, 0xf0, 0x75, 0x31, 0x10, 0x90}},
+ {0x05c6, 64, { 0x7f, 0xca, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x06, 0xf3, 0xe4, 0xf5, 0x11, 0x74, 0x40, 0x25, 0x11, 0xf5,
+  0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x11, 0x7c, 0x00, 0x7b, 0x00, 0x24, 0x3b,
+  0xf9, 0xec, 0x34, 0x00, 0xfa, 0xef, 0x12, 0x0d, 0x1f, 0x05, 0x11, 0xe5, 0x11, 0xb4, 0x18, 0xdb,
+  0xe5, 0x3b, 0x60, 0x11, 0x75, 0xc9, 0x20, 0x75, 0xc8, 0x36, 0x85, 0x3c, 0xca, 0x85, 0x3d}},
+ {0x0606, 64, { 0xcb, 0xe4, 0x90, 0x7f, 0x9f, 0xf0, 0xe5, 0x3e, 0x13, 0x92, 0x10, 0x92, 0x9f, 0x85, 0x3f, 0x38, 0xe5,
+  0x40, 0x13, 0x92, 0x16, 0xe5, 0x41, 0x60, 0x09, 0x90, 0x7f, 0x98, 0xe0, 0x54, 0xfb, 0xf0, 0x80,
+  0x07, 0x90, 0x7f, 0x98, 0xe0, 0x44, 0x04, 0xf0, 0xe5, 0x42, 0x60, 0x09, 0x90, 0x7f, 0x98, 0xe0,
+  0x54, 0x7f, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0x98, 0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x48, 0x60}},
+ {0x0646, 64, { 0x0b, 0xc2, 0x0c, 0xc2, 0x09, 0x90, 0x7f, 0x95, 0xe0, 0x44, 0x02, 0xf0, 0xe5, 0x49, 0x60, 0x0c, 0xd2,
+  0x09, 0x43, 0x34, 0x01, 0x90, 0x7f, 0x95, 0xe0, 0x44, 0x02, 0xf0, 0xe5, 0x4a, 0x60, 0x0d, 0xc2,
+  0xaf, 0xc2, 0x0b, 0xd2, 0x00, 0xe4, 0xf5, 0x53, 0xf5, 0x3a, 0xd2, 0xaf, 0xe5, 0x4b, 0x60, 0x05,
+  0x30, 0x16, 0x02, 0xd2, 0x09, 0xe5, 0x4c, 0x60, 0x15, 0x90, 0x7f, 0x95, 0xe0, 0x54, 0xfd}},
+ {0x0686, 64, { 0xf0, 0x90, 0x7f, 0x9e, 0xe0, 0x44, 0x02, 0xf0, 0x90, 0x7f, 0x98, 0xe0, 0x54, 0xfd, 0xf0, 0xe5, 0x4d,
+  0x60, 0x0a, 0xd2, 0x9c, 0xc2, 0x98, 0x75, 0x2c, 0x01, 0x75, 0x31, 0x1e, 0xe5, 0x4e, 0x60, 0x07,
+  0xc2, 0x9c, 0xe4, 0xf5, 0x39, 0xf5, 0x2c, 0xe5, 0x4f, 0x60, 0x03, 0xe4, 0xf5, 0x39, 0xe5, 0x50,
+  0x60, 0x02, 0xd2, 0x07, 0xe5, 0x51, 0x60, 0x0a, 0xe5, 0x4d, 0x70, 0x02, 0xf5, 0x31, 0xe5}},
+ {0x06c6, 64, { 0x51, 0x42, 0x34, 0xe5, 0x52, 0x60, 0x1f, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74,
+  0x12, 0xf0, 0x74, 0x32, 0xf0, 0x74, 0x13, 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x14, 0xf0, 0x74, 0x34,
+  0xf0, 0xd2, 0x03, 0xd2, 0x02, 0xd2, 0x08, 0xe4, 0x90, 0x7f, 0xcb, 0xf0, 0xa2, 0x0c, 0xe4, 0x33,
+  0xff, 0x65, 0x29, 0x60, 0x05, 0x8f, 0x29, 0x43, 0x34, 0x01, 0xa2, 0x09, 0xe4, 0x33, 0xff}},
+ {0x0706, 64, { 0x65, 0x2a, 0x60, 0x05, 0x8f, 0x2a, 0x43, 0x34, 0x01, 0x90, 0x7f, 0x9b, 0xe0, 0xff, 0x54, 0x08, 0x64,
+  0x08, 0xfe, 0x65, 0x25, 0x60, 0x05, 0x8e, 0x25, 0x43, 0x34, 0x01, 0xef, 0x54, 0x10, 0x64, 0x10,
+  0xfe, 0x65, 0x26, 0x60, 0x05, 0x8e, 0x26, 0x43, 0x34, 0x01, 0xef, 0x54, 0x40, 0x64, 0x40, 0xfe,
+  0x65, 0x27, 0x60, 0x05, 0x8e, 0x27, 0x43, 0x34, 0x01, 0xef, 0x54, 0x20, 0x64, 0x20, 0xfe}},
+ {0x0746, 64, { 0x65, 0x28, 0x60, 0x05, 0x8e, 0x28, 0x43, 0x34, 0x01, 0x90, 0x7f, 0x9a, 0xe0, 0x54, 0x40, 0x64, 0x40,
+  0xfe, 0x65, 0x2e, 0x60, 0x05, 0x8e, 0x2e, 0x43, 0x34, 0x01, 0x30, 0x07, 0x35, 0xc2, 0xaf, 0x30,
+  0x02, 0x18, 0x90, 0x7f, 0xb8, 0xe0, 0x20, 0xe1, 0x27, 0xe5, 0x39, 0x60, 0x09, 0x90, 0x7f, 0xb7,
+  0xf0, 0xe4, 0xf5, 0x39, 0xc2, 0x02, 0xc2, 0x07, 0x80, 0x16, 0x90, 0x7f, 0xb6, 0xe0, 0x20}},
+ {0x0786, 64, { 0xe1, 0x0f, 0xe5, 0x39, 0x60, 0x09, 0x90, 0x7f, 0xb9, 0xf0, 0xe4, 0xf5, 0x39, 0xd2, 0x02, 0xc2, 0x07,
+  0xd2, 0xaf, 0x20, 0x05, 0x3d, 0x30, 0x03, 0x1e, 0x90, 0x7f, 0xc6, 0xe0, 0x20, 0xe1, 0x33, 0x90,
+  0x7e, 0x40, 0xe0, 0x13, 0x92, 0x0d, 0x75, 0x3a, 0x01, 0x90, 0x7f, 0xc7, 0xe0, 0xf5, 0x53, 0xd2,
+  0x05, 0x75, 0x16, 0xff, 0x80, 0x1c, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x15, 0x90, 0x7d}},
+ {0x07c6, 64, { 0xc0, 0xe0, 0x13, 0x92, 0x0d, 0x75, 0x3a, 0x01, 0x90, 0x7f, 0xc9, 0xe0, 0xf5, 0x53, 0xd2, 0x05, 0x75,
+  0x16, 0xff, 0x20, 0x14, 0x33, 0x20, 0x00, 0x06, 0xe5, 0x3a, 0x65, 0x53, 0x70, 0x2a, 0x30, 0x05,
+  0x1a, 0x30, 0x03, 0x09, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0xc2, 0x03, 0x80, 0x07, 0xe4, 0x90, 0x7f,
+  0xc9, 0xf0, 0xd2, 0x03, 0xc2, 0x05, 0xe4, 0xf5, 0x53, 0xf5, 0x3a, 0x30, 0x0d, 0x0a, 0xc2}},
+ {0x0806, 64, { 0x0d, 0xc2, 0x00, 0x90, 0x7f, 0xbb, 0x74, 0x01, 0xf0, 0x30, 0x14, 0x03, 0x02, 0x09, 0x14, 0x20, 0x05,
+  0x03, 0x02, 0x09, 0x14, 0x30, 0x0c, 0x03, 0x02, 0x09, 0x14, 0x30, 0x09, 0x03, 0x02, 0x09, 0x14,
+  0x90, 0x7f, 0x9b, 0xe0, 0x55, 0x38, 0x60, 0x03, 0x02, 0x09, 0x14, 0x30, 0x03, 0x61, 0x30, 0x10,
+  0x12, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83}},
+ {0x0846, 64, { 0xe0, 0x13, 0x92, 0x1b, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5,
+  0x83, 0xe0, 0xfe, 0xe5, 0x3a, 0xc3, 0x95, 0x53, 0x50, 0x2a, 0x30, 0x10, 0x12, 0xaf, 0x3a, 0x05,
+  0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0e, 0xaf,
+  0x3a, 0x05, 0x3a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5}},
+ {0x0886, 64, { 0x36, 0xd2, 0x0b, 0x80, 0x6a, 0xc2, 0x0b, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0xc2, 0x03, 0x80, 0x5f, 0x30,
+  0x10, 0x12, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83,
+  0xe0, 0x13, 0x92, 0x1b, 0xaf, 0x3a, 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d,
+  0xf5, 0x83, 0xe0, 0xfe, 0xe5, 0x3a, 0xc3, 0x95, 0x53, 0x50, 0x2a, 0x30, 0x10, 0x12, 0xaf}},
+ {0x08c6, 64, { 0x3a, 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x0e,
+  0xaf, 0x3a, 0x05, 0x3a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5,
+  0x36, 0xd2, 0x0b, 0x80, 0x09, 0xc2, 0x0b, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x03, 0x30, 0x10,
+  0x04, 0xa2, 0x1b, 0x92, 0x9b, 0xd2, 0x14, 0xc2, 0xaf, 0x8e, 0x99, 0x20, 0x0b, 0x0d, 0x30}},
+ {0x0906, 64, { 0x0d, 0x0a, 0xc2, 0x0d, 0xc2, 0x00, 0x90, 0x7f, 0xbb, 0x74, 0x01, 0xf0, 0xd2, 0xaf, 0x22, 0x90, 0x7f,
+  0xe9, 0xe0, 0x12, 0x0d, 0x31, 0x0a, 0x11, 0x00, 0x0a, 0x7e, 0x01, 0x0a, 0xdb, 0x03, 0x09, 0x38,
+  0x06, 0x0a, 0x02, 0x08, 0x09, 0xf6, 0x09, 0x09, 0xde, 0x0a, 0x09, 0xed, 0x0b, 0x00, 0x00, 0x0b,
+  0x19, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x14, 0x60, 0x5a, 0x24, 0x02, 0x60}},
+ {0x0946, 64, { 0x03, 0x02, 0x0b, 0x19, 0x74, 0x0d, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x87, 0x90, 0x7f, 0xd5, 0xf0, 0x02,
+  0x0b, 0x20, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03, 0x75, 0x82,
+  0xd8, 0x75, 0x83, 0x0d, 0xef, 0xf0, 0x75, 0x82, 0xd1, 0x75, 0x83, 0x0d, 0xf0, 0x75, 0x82, 0xca,
+  0x75, 0x83, 0x0d, 0xf0, 0x75, 0x82, 0xc3, 0x75, 0x83, 0x0d, 0xf0, 0x90, 0x7f, 0xea, 0xe0}},
+ {0x0986, 64, { 0x04, 0x75, 0x82, 0x9e, 0x75, 0x83, 0x0d, 0xf0, 0x74, 0x0d, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x99, 0x90,
+  0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x0b, 0x75, 0x11, 0xff, 0x75,
+  0x12, 0x0d, 0x75, 0x13, 0xdc, 0x80, 0x1b, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x0b, 0x75, 0x11,
+  0xff, 0x75, 0x12, 0x0d, 0x75, 0x13, 0xe0, 0x80, 0x09, 0x75, 0x11, 0xff, 0x75, 0x12, 0x0d}},
+ {0x09c6, 64, { 0x75, 0x13, 0xf0, 0xaa, 0x12, 0xa9, 0x13, 0xae, 0x02, 0xee, 0x90, 0x7f, 0xd4, 0xf0, 0xaf, 0x01, 0xef,
+  0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0x00, 0xe5, 0x15, 0xf0, 0x90, 0x7f, 0xb5,
+  0x74, 0x01, 0xf0, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x15, 0x02, 0x0b, 0x20, 0x12,
+  0x0c, 0xb1, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x14, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0x00, 0xe5}},
+ {0x0a06, 64, { 0x14, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f,
+  0x60, 0x27, 0x14, 0x60, 0x34, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x19, 0xa2, 0x17, 0xe4, 0x33,
+  0xff, 0x25, 0xe0, 0xff, 0xa2, 0x19, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0,
+  0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x20, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3}},
+ {0x0a46, 64, { 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80,
+  0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4,
+  0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f,
+  0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x17}},
+ {0x0a86, 64, { 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0xea, 0xe0, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0b,
+  0x19, 0xc2, 0x17, 0x02, 0x0b, 0x20, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x76, 0x90, 0x7f, 0xec, 0xe0,
+  0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4,
+  0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80}},
+ {0x0ac6, 64, { 0xff, 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44,
+  0x20, 0xf0, 0x80, 0x45, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x10, 0x24, 0x02, 0x70, 0x39,
+  0x90, 0x7f, 0xea, 0xe0, 0x64, 0x01, 0x70, 0x2a, 0xd2, 0x17, 0x80, 0x2d, 0x90, 0x7f, 0xea, 0xe0,
+  0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0}},
+ {0x0b06, 64, { 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0,
+  0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0,
+  0x22, 0xc2, 0x10, 0xe4, 0xf5, 0x14, 0xf5, 0x34, 0xc2, 0x09, 0xc2, 0x0c, 0xc2, 0x0b, 0xc2, 0x14,
+  0xc2, 0x0d, 0xc2, 0x16, 0xc2, 0x11, 0xc2, 0x07, 0xc2, 0x12, 0xc2, 0x0f, 0xc2, 0x08, 0xf5}},
+ {0x0b46, 64, { 0x35, 0xf5, 0x39, 0xf5, 0x53, 0xf5, 0x3a, 0xf5, 0x33, 0xf5, 0x30, 0xf5, 0x2f, 0xf5, 0x2e, 0xf5, 0x2d,
+  0xf5, 0x2c, 0xf5, 0x2b, 0xf5, 0x2a, 0xf5, 0x29, 0xf5, 0x28, 0xf5, 0x27, 0xf5, 0x26, 0xf5, 0x25,
+  0xf5, 0x24, 0xc2, 0x05, 0xc2, 0x18, 0xc2, 0x1a, 0xc2, 0x17, 0xc2, 0x19, 0xc2, 0x15, 0xc2, 0x04,
+  0xd2, 0x13, 0xc2, 0x06, 0xc2, 0x01, 0x90, 0x7f, 0x92, 0xe0, 0x54, 0xfd, 0xf0, 0xd2, 0xe8}},
+ {0x0b86, 64, { 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74,
+  0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xaf,
+  0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0f, 0xf0, 0x90, 0x7f, 0xac, 0x74, 0x0e,
+  0xf0, 0xd2, 0xaf, 0xd2, 0xbc, 0xd2, 0x1b, 0x12, 0x0f, 0x5f, 0xc2, 0x18, 0x30, 0x04, 0x03}},
+ {0x0bc6, 64, { 0x12, 0x05, 0x6d, 0x30, 0x04, 0x2a, 0x30, 0x06, 0x27, 0xc2, 0x06, 0xe5, 0x16, 0x60, 0x16, 0x15, 0x16,
+  0x90, 0x7f, 0xd8, 0xe0, 0x30, 0xe6, 0x04, 0x7f, 0x00, 0x80, 0x02, 0x7f, 0x20, 0x90, 0x7f, 0x96,
+  0xef, 0xf0, 0x80, 0x06, 0x90, 0x7f, 0x96, 0x74, 0x20, 0xf0, 0x12, 0x0c, 0x0b, 0x80, 0xcd, 0x30,
+  0x18, 0x07, 0xc2, 0x18, 0x12, 0x09, 0x15, 0x80, 0xc3, 0x30, 0x1a, 0xc0, 0xc2, 0x1a, 0x12}},
+ {0x0c06, 64, { 0x0f, 0xbb, 0x80, 0xb9, 0x22, 0xe5, 0x31, 0x60, 0x02, 0x15, 0x31, 0xe5, 0x39, 0x60, 0x55, 0x65, 0x35,
+  0x70, 0x4b, 0xe5, 0x33, 0xf4, 0x60, 0x02, 0x05, 0x33, 0xe5, 0x33, 0xc3, 0x95, 0x44, 0x40, 0x43,
+  0xc2, 0xaf, 0x30, 0x02, 0x1b, 0x90, 0x7f, 0xb8, 0xe0, 0x20, 0xe1, 0x2d, 0x90, 0x7f, 0xb7, 0xe5,
+  0x39, 0xf0, 0xc2, 0x02, 0xe4, 0xf5, 0x39, 0xf5, 0x33, 0xf5, 0x35, 0x75, 0x16, 0xff, 0x80}},
+ {0x0c46, 64, { 0x19, 0x90, 0x7f, 0xb6, 0xe0, 0x20, 0xe1, 0x12, 0x90, 0x7f, 0xb9, 0xe5, 0x39, 0xf0, 0xd2, 0x02, 0xe4,
+  0xf5, 0x39, 0xf5, 0x33, 0xf5, 0x35, 0x75, 0x16, 0xff, 0xd2, 0xaf, 0x80, 0x06, 0x85, 0x39, 0x35,
+  0xe4, 0xf5, 0x33, 0xe5, 0x2c, 0x60, 0x30, 0x20, 0x0f, 0x07, 0x90, 0x7f, 0x9b, 0xe0, 0x30, 0xe0,
+  0x0f, 0xe5, 0x2d, 0x60, 0x06, 0xe4, 0xf5, 0x2d, 0x43, 0x34, 0x01, 0xe4, 0xf5, 0x30, 0x80}},
+ {0x0c86, 64, { 0x14, 0xe5, 0x30, 0xd3, 0x95, 0x45, 0x50, 0x0d, 0xe5, 0x30, 0xb5, 0x45, 0x06, 0x75, 0x2d, 0x01, 0x43,
+  0x34, 0x01, 0x05, 0x30, 0xc2, 0x0f, 0x22, 0x90, 0x7f, 0xd9, 0xe0, 0x30, 0xe2, 0x04, 0x7f, 0x00,
+  0x80, 0x02, 0x7f, 0x20, 0x90, 0x7f, 0x96, 0xef, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90,
+  0x7f, 0x9c, 0x74, 0x30, 0xf0, 0x90, 0x7f, 0x96, 0x74, 0x20, 0xf0, 0x90, 0x7f, 0x94, 0x74}},
+ {0x0cc6, 64, { 0x01, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x97, 0x74, 0x86, 0xf0, 0x90, 0x7f, 0x95,
+  0x74, 0x03, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x84, 0xf0, 0x90, 0x7f, 0x98, 0xf0, 0xe4, 0x90, 0x7f,
+  0xc7, 0xf0, 0x90, 0x7f, 0xc9, 0xf0, 0x90, 0x7f, 0xcb, 0xf0, 0x75, 0x98, 0x40, 0x43, 0xa8, 0x10,
+  0x90, 0x7f, 0xde, 0x74, 0x1f, 0xf0, 0x90, 0x7f, 0xdf, 0x74, 0x0f, 0xf0, 0xd2, 0x04, 0x22}},
+ {0x0d06, 64, { 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3,
+  0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xf0,
+  0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0, 0x82, 0xf8, 0xe4,
+  0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01, 0x93}},
+ {0x0d46, 64, { 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80, 0xdf,
+  0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90,
+  0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0,
+  0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x0d86, 64, { 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00, 0x00, 0x40, 0xcd, 0x06, 0x0c, 0x01, 0x01, 0x00, 0x01, 0x02,
+  0x00, 0x02, 0x09, 0x02, 0x43, 0x00, 0x01, 0x01, 0x00, 0x80, 0x32, 0x09, 0x04, 0x00, 0x00, 0x07,
+  0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40,
+  0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x81, 0x02, 0x40, 0x00}},
+ {0x0dc6, 64, { 0x01, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x83, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05,
+  0x84, 0x02, 0x40, 0x00, 0x01, 0x04, 0x03, 0x09, 0x04, 0x10, 0x03, 0x4b, 0x00, 0x65, 0x00, 0x79,
+  0x00, 0x73, 0x00, 0x70, 0x00, 0x61, 0x00, 0x6e, 0x00, 0x0e, 0x03, 0x53, 0x00, 0x65, 0x00, 0x72,
+  0x00, 0x69, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xa2, 0x00, 0x02, 0x0e}},
+ {0x0e06, 64, { 0x7b, 0x00, 0x02, 0x0d, 0x57, 0x00, 0x02, 0x0e, 0xc9, 0x00, 0x02, 0x0e, 0x10, 0x00, 0x02, 0x0e, 0x14,
+  0x00, 0x02, 0x0e, 0x18, 0x00, 0x02, 0x0e, 0x1c, 0x00, 0x02, 0x0e, 0xf0, 0x00, 0x02, 0x0e, 0x24,
+  0x00, 0x02, 0x0f, 0x15, 0x00, 0x02, 0x0e, 0x2c, 0x00, 0x02, 0x0f, 0x3a, 0xe4, 0x90, 0x7f, 0x95,
+  0xf0, 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9d, 0xe0, 0x44, 0x02}},
+ {0x0e46, 64, { 0xf0, 0x90, 0x7f, 0x97, 0xe0, 0x44, 0x02, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x10, 0xf0, 0xe4, 0x90, 0x7f,
+  0x96, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xfe, 0xf0, 0x30, 0x17, 0x04, 0x7f, 0x80, 0x80, 0x02, 0x7f,
+  0x00, 0x90, 0x7f, 0x97, 0xef, 0xf0, 0xe4, 0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0xf0, 0x90,
+  0x7f, 0x98, 0xf0, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0}},
+ {0x0e86, 64, { 0x86, 0x75, 0x86, 0x00, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x02, 0xf0, 0xd2, 0x06, 0xd0, 0x86,
+  0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0,
+  0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90,
+  0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83}},
+ {0x0ec6, 64, { 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86,
+  0x00, 0xd2, 0x1a, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84,
+  0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0,
+  0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xa9, 0x74}},
+ {0x0f06, 64, { 0x02, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0,
+  0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x53, 0x91, 0xef,
+  0x90, 0x7f, 0xa9, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83,
+  0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86}},
+ {0x0f46, 64, { 0x75, 0x86, 0x00, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xa9, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0,
+  0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0,
+  0x44, 0x08, 0xf0, 0x30, 0x1b, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x00,
+  0x03, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44, 0x04, 0xf0, 0x22, 0x74, 0x00}},
+ {0x0f86, 64, { 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f,
+  0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x90, 0x7f,
+  0xd6, 0xe0, 0x44, 0x01, 0xf0, 0x7f, 0x0d, 0x7e, 0x00, 0x12, 0x00, 0x03, 0x90, 0x7f, 0xd6, 0xe0,
+  0x54, 0xfe, 0xf0, 0x22, 0x12, 0x0e, 0x33, 0x12, 0x0f, 0x95, 0x90, 0x7f, 0xd6, 0xe0, 0x30}},
+ {0x0fc6,  9, { 0xe7, 0x03, 0x12, 0x0f, 0xa5, 0x12, 0x0c, 0xb1, 0x22}},
+ {0xffff,	0,	{0x00}}
+};
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa19qw_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa19qw_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa19qw_fw.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa19qw_fw.h	Mon Nov 25 12:27:09 2002
@@ -0,0 +1,448 @@
+/* keyspan_usa19qw_fw.h
+
+	The firmware contained herein as keyspan_usa19wq_fw.h is
+
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
+
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
+
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
+
+*/
+
+static const struct ezusb_hex_record keyspan_usa19qw_firmware[] = {
+ {0x0033,  3, { 0x02, 0x00, 0x2d}},
+ {0x002d,  4, { 0x53, 0xd8, 0xef, 0x32}},
+ {0x0046, 16, { 0x30, 0x10, 0x19, 0x12, 0x0e, 0x0f, 0xef, 0xc3, 0x95, 0x14, 0x40, 0x03, 0x02, 0x00, 0xdf, 0x90}},
+ {0x0056, 16, { 0x7f, 0xbf, 0x74, 0x01, 0xf0, 0xc2, 0x10, 0xc2, 0x0b, 0x02, 0x00, 0xdf, 0x30, 0x0d, 0x3e, 0x90}},
+ {0x0066, 16, { 0x7f, 0xc6, 0xe0, 0x20, 0xe1, 0x73, 0x12, 0x0e, 0x0f, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x6a, 0x90}},
+ {0x0076, 16, { 0x7e, 0x40, 0xe0, 0x13, 0x92, 0x10, 0x90, 0x7f, 0xc7, 0xe0, 0x14, 0xf5, 0x36, 0x20, 0x0b, 0x11}},
+ {0x0086, 16, { 0x60, 0x0f, 0xf5, 0x24, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x29, 0x7e, 0x75, 0x2a, 0x41, 0x12, 0x09}},
+ {0x0096, 16, { 0x10, 0xc2, 0x0d, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0x75, 0x26, 0xff, 0x80, 0x3c, 0x90, 0x7f, 0xc8}},
+ {0x00a6, 16, { 0xe0, 0x20, 0xe1, 0x35, 0x12, 0x0e, 0x0f, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x2c, 0x90, 0x7d, 0xc0}},
+ {0x00b6, 16, { 0xe0, 0x13, 0x92, 0x10, 0x90, 0x7f, 0xc9, 0xe0, 0x14, 0xf5, 0x36, 0x20, 0x0b, 0x11, 0x60, 0x0f}},
+ {0x00c6, 16, { 0xf5, 0x24, 0x7e, 0x7d, 0x7f, 0xc1, 0x75, 0x29, 0x7d, 0x75, 0x2a, 0xc1, 0x12, 0x09, 0x10, 0xd2}},
+ {0x00d6, 16, { 0x0d, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0x75, 0x26, 0xff, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03}},
+ {0x00e6, 16, { 0x02, 0x01, 0x68, 0x12, 0x0c, 0xff, 0x8f, 0x36, 0x12, 0x0e, 0x1b, 0x8f, 0x11, 0xe5, 0x36, 0xc3}},
+ {0x00f6, 16, { 0x95, 0x13, 0x50, 0x0f, 0x12, 0x0d, 0xde, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x11, 0x20, 0xe7, 0x03}},
+ {0x0036, 12, { 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22}},
+ {0x0043,  3, { 0x02, 0x0e, 0x00}},
+ {0x0003, 16, { 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90}},
+ {0x0013, 16, { 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0}},
+ {0x0023, 10, { 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32}},
+ {0x0000,  3, { 0x02, 0x09, 0xc5}},
+ {0x0106, 64, { 0x30, 0x13, 0x5f, 0xc2, 0x13, 0xe5, 0x36, 0x60, 0x59, 0xb4, 0x80, 0x03, 0x43, 0x11, 0x02, 0xe5, 0x11,
+  0x30, 0xe7, 0x24, 0xe5, 0x36, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x36, 0x20, 0x85, 0x36, 0x24,
+  0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x29, 0x7e, 0x75, 0x2a, 0x80, 0x12, 0x0b, 0x9a, 0xe5, 0x36, 0x25,
+  0xe0, 0x90, 0x7f, 0xb7, 0xf0, 0x80, 0x2a, 0xe5, 0x36, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75}},
+ {0x0146, 64, { 0x36, 0x3f, 0x85, 0x36, 0x24, 0x90, 0x7e, 0x80, 0xe5, 0x11, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75, 0x29,
+  0x7e, 0x75, 0x2a, 0x81, 0x12, 0x09, 0x35, 0xe5, 0x36, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x75, 0x26,
+  0xff, 0x90, 0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x0e, 0x03, 0x02, 0x03, 0xc4, 0xe4, 0xf5,
+  0x35, 0x74, 0x40, 0x25, 0x35, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5}},
+ {0x0186, 64, { 0x35, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef,
+  0x12, 0x0a, 0x97, 0x05, 0x35, 0xe5, 0x35, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x6e,
+  0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0, 0xfd, 0x12, 0x0c, 0xda, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12,
+  0x0c, 0x1c, 0x90, 0x7e, 0x02, 0xe0, 0xff, 0x12, 0x0c, 0x42, 0xd2, 0x11, 0xd2, 0x12, 0x75}},
+ {0x01c6, 64, { 0x36, 0x04, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x05, 0xc2, 0x12, 0x43, 0x36, 0xc0, 0x90, 0x7e, 0x04, 0xe0,
+  0xb4, 0x01, 0x07, 0xc2, 0x12, 0x43, 0x36, 0x0b, 0x80, 0x10, 0x90, 0x7e, 0x04, 0xe0, 0x60, 0x07,
+  0xc2, 0x11, 0x43, 0x36, 0x09, 0x80, 0x03, 0x43, 0x36, 0x02, 0x7f, 0x03, 0xad, 0x36, 0x12, 0x0c,
+  0xda, 0x43, 0x1a, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x1a}},
+ {0x0206, 64, { 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x17, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
+  0x05, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x19, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0,
+  0x90, 0xc0, 0x00, 0xe5, 0x19, 0xf0, 0x90, 0x7e, 0x07, 0xe0, 0x60, 0x42, 0x90, 0x7e, 0x13, 0xe0,
+  0x60, 0x05, 0x43, 0x16, 0x04, 0x80, 0x03, 0x53, 0x16, 0xfb, 0xe4, 0xff, 0xad, 0x16, 0x12}},
+ {0x0246, 64, { 0x0c, 0xda, 0x90, 0x7e, 0x08, 0xe0, 0x60, 0x05, 0x43, 0x18, 0x80, 0x80, 0x03, 0x53, 0x18, 0x7f, 0x53,
+  0x18, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43, 0x18, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x0c,
+  0x8e, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x0c, 0xb4, 0xaf, 0x18, 0x12, 0x0c, 0x68, 0x90, 0x7e,
+  0x0e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x1a, 0x01, 0x80, 0x03, 0x53, 0x1a}},
+ {0x0286, 64, { 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x1a, 0xf0, 0x90, 0x7e, 0x0c, 0xe0,
+  0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x1a, 0x02, 0x80, 0x03, 0x53, 0x1a, 0xfd, 0x90, 0x7f,
+  0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x1a, 0xf0, 0x90, 0x7e, 0x12, 0xe0, 0xf5, 0x13,
+  0xa3, 0xe0, 0x13, 0x92, 0x14, 0xa3, 0xe0, 0xf5, 0x14, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x1a}},
+ {0x02c6, 64, { 0x10, 0x80, 0x03, 0x53, 0x1a, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x1a,
+  0xf0, 0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x19, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0,
+  0xe5, 0x19, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x12, 0x0d,
+  0xd2, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x16, 0xfd, 0xe4, 0xff, 0xad, 0x16}},
+ {0x0306, 64, { 0x12, 0x0c, 0xda, 0xe4, 0xf5, 0x0e, 0xf5, 0x0d, 0xd2, 0x0f, 0x90, 0x7e, 0x17, 0xe0, 0x60, 0x0f, 0x43,
+  0x16, 0x02, 0xe4, 0xff, 0xad, 0x16, 0x12, 0x0c, 0xda, 0x75, 0x0d, 0x01, 0xd2, 0x0f, 0x90, 0x7e,
+  0x18, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x17, 0x44, 0x04, 0x90, 0xc0,
+  0x00, 0xf0, 0xd2, 0x0b, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11, 0x43, 0x19, 0x40, 0x90, 0x7f}},
+ {0x0346, 64, { 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x19, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1a, 0xe0, 0x60,
+  0x0f, 0x53, 0x16, 0xfe, 0xe4, 0xff, 0xad, 0x16, 0x12, 0x0c, 0xda, 0x75, 0x0f, 0x01, 0xd2, 0x0f,
+  0x90, 0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x16, 0x01, 0xe4, 0xff, 0xad, 0x16, 0x12, 0x0c, 0xda,
+  0xe4, 0xf5, 0x0f, 0xd2, 0x0f, 0x90, 0x7e, 0x1c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74}},
+ {0x0386, 64, { 0x12, 0xf0, 0xe5, 0x17, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1d, 0xe0, 0x60, 0x02, 0xd2,
+  0x13, 0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x10, 0x01, 0xe4, 0xf5, 0x12, 0xd2, 0x0f, 0x90,
+  0x7e, 0x1f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74, 0x15,
+  0xf0, 0x74, 0x35, 0xf0, 0xd2, 0x0d, 0xc2, 0x0e, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30, 0x16}},
+ {0x03c6, 64, { 0x71, 0xe5, 0x12, 0x60, 0x02, 0x15, 0x12, 0xe5, 0x30, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x30, 0x80,
+  0x60, 0x75, 0x30, 0x0a, 0x12, 0x0d, 0xd2, 0xef, 0x54, 0x01, 0xf5, 0x36, 0x65, 0x0e, 0x60, 0x07,
+  0x85, 0x36, 0x0e, 0xd2, 0x0f, 0x80, 0x11, 0x12, 0x0e, 0x27, 0xef, 0x54, 0x10, 0xf5, 0x36, 0x65,
+  0x09, 0x60, 0x05, 0x85, 0x36, 0x09, 0xd2, 0x0f, 0x12, 0x0e, 0x27, 0xef, 0x54, 0x80, 0xf5}},
+ {0x0406, 64, { 0x36, 0x65, 0x0a, 0x60, 0x05, 0x85, 0x36, 0x0a, 0xd2, 0x0f, 0x12, 0x0e, 0x27, 0xef, 0x54, 0x20, 0xf5,
+  0x36, 0x65, 0x0b, 0x60, 0x08, 0x85, 0x36, 0x0b, 0x30, 0x11, 0x02, 0xd2, 0x0f, 0x12, 0x0e, 0x27,
+  0xef, 0x54, 0x40, 0xf5, 0x36, 0x65, 0x0c, 0x60, 0x08, 0x85, 0x36, 0x0c, 0x30, 0x12, 0x02, 0xd2,
+  0x0f, 0x30, 0x16, 0x2a, 0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90, 0x7b, 0x40, 0xe0}},
+ {0x0446, 64, { 0x60, 0x09, 0xe0, 0xf5, 0x32, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x33, 0x90, 0x7b, 0x41, 0xe0, 0x60, 0x09,
+  0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f, 0xd3, 0xf0, 0x90, 0x7f,
+  0xc2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x05, 0x29, 0xe5, 0x27, 0x70, 0x40, 0x30, 0x0f, 0x39, 0xe5,
+  0x12, 0x70, 0x35, 0xc2, 0x0f, 0xf5, 0x35, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x08, 0x25, 0x35}},
+ {0x0486, 64, { 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0a, 0x51, 0xff, 0x74, 0x80, 0x25, 0x35, 0xf5, 0x82, 0xe4, 0x34,
+  0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x35, 0xe5, 0x35, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74,
+  0x09, 0xf0, 0x75, 0x12, 0x10, 0xe4, 0xf5, 0x10, 0x75, 0x27, 0x02, 0x22, 0xe5, 0x27, 0x64, 0x02,
+  0x70, 0x36, 0x30, 0x05, 0x2f, 0xc2, 0x05, 0xf5, 0x35, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2b}},
+ {0x04c6, 64, { 0x25, 0x35, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0a, 0x51, 0xff, 0x74, 0x80, 0x25, 0x35, 0xf5, 0x82,
+  0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x35, 0xe5, 0x35, 0xb4, 0x05, 0xdb, 0x90, 0x7f,
+  0xc3, 0x74, 0x05, 0xf0, 0x75, 0x27, 0x03, 0x22, 0xe5, 0x32, 0x60, 0x33, 0x75, 0x31, 0x03, 0x15,
+  0x32, 0xe4, 0xf5, 0x35, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x31, 0x25, 0x35, 0xf9, 0xee, 0x34}},
+ {0x0506, 64, { 0x00, 0xfa, 0x12, 0x0a, 0x51, 0xff, 0x74, 0x80, 0x25, 0x35, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83,
+  0xef, 0xf0, 0x05, 0x35, 0xe5, 0x35, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4,
+  0xf5, 0x27, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0a, 0xa9, 0x06, 0x08, 0x00, 0x06, 0x7c, 0x01,
+  0x06, 0xe9, 0x03, 0x05, 0x4d, 0x06, 0x05, 0xf9, 0x08, 0x05, 0xed, 0x09, 0x05, 0xd5, 0x0a}},
+ {0x0546, 64, { 0x05, 0xe4, 0x0b, 0x00, 0x00, 0x07, 0x39, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x16, 0x14, 0x60,
+  0x50, 0x24, 0x02, 0x70, 0x6f, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90, 0x7f, 0xd5,
+  0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03,
+  0x75, 0x82, 0x82, 0x75, 0x83, 0x19, 0xef, 0xf0, 0x75, 0x82, 0x74, 0x75, 0x83, 0x19, 0xf0}},
+ {0x0586, 64, { 0x75, 0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f, 0xea, 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83,
+  0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x12, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x07,
+  0x40, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0b, 0x1c, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90, 0x7f,
+  0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f, 0xb4, 0xe0, 0x44}},
+ {0x05c6, 64, { 0x01, 0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f,
+  0x00, 0xe5, 0x25, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f, 0xea,
+  0xe0, 0xf5, 0x25, 0x02, 0x07, 0x40, 0x12, 0x07, 0x48, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x23, 0x02,
+  0x07, 0x40, 0x90, 0x7f, 0x00, 0xe5, 0x23, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02}},
+ {0x0606, 64, { 0x07, 0x40, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b,
+  0xa2, 0x01, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff, 0xa2, 0x07, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00,
+  0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x07, 0x40, 0xe4, 0x90, 0x7f,
+  0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f}},
+ {0x0646, 64, { 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24,
+  0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4,
+  0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
+  0x01, 0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1e, 0x24, 0x02}},
+ {0x0686, 64, { 0x60, 0x03, 0x02, 0x07, 0x40, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x06, 0x12, 0x0d, 0xf9, 0x02, 0x07,
+  0x40, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x07, 0x40, 0x90, 0x7f, 0xea, 0xe0, 0x70,
+  0x38, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07,
+  0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90}},
+ {0x06c6, 64, { 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90,
+  0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x60, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0,
+  0x80, 0x57, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x24, 0x02, 0x70, 0x4b, 0x90, 0x7f,
+  0xea, 0xe0, 0xb4, 0x01, 0x05, 0x12, 0x0d, 0xf6, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44}},
+ {0x0706, 64, { 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80,
+  0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4,
+  0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0,
+  0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02}},
+ {0x0746, 64, { 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0x90, 0x7f, 0x96, 0x74,
+  0x20, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x10, 0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xde,
+  0xf0, 0xe4, 0xf5, 0x08, 0x7f, 0x01, 0x7b, 0x00, 0x74, 0x08, 0x2f, 0xf9, 0xe4, 0x34, 0x00}},
+ {0x0786, 64, { 0xfa, 0xe4, 0x12, 0x0a, 0x97, 0x0f, 0xbf, 0x09, 0xee, 0x75, 0x13, 0x01, 0xe4, 0xf5, 0x12, 0xf5, 0x30,
+  0xf5, 0x11, 0xc2, 0x0f, 0xc2, 0x13, 0xc2, 0x0e, 0xc2, 0x0b, 0xc2, 0x10, 0xc2, 0x04, 0x90, 0x7f,
+  0x98, 0x74, 0x13, 0xf0, 0x75, 0x19, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4,
+  0xfd, 0x12, 0x0c, 0xda, 0x7f, 0x10, 0x8f, 0x18, 0x12, 0x0c, 0x68, 0x90, 0x7f, 0x98, 0x74}},
+ {0x07c6, 64, { 0x12, 0xf0, 0x7f, 0x01, 0x8f, 0x17, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x0f, 0xe4, 0xfd, 0x12,
+  0x0c, 0xda, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x16, 0x12, 0x0c, 0xda, 0x90, 0x7f, 0x98,
+  0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x0c, 0xda, 0x7f,
+  0x01, 0x12, 0x0d, 0x6a, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x0c, 0xda, 0xe4, 0xff, 0xe5, 0x16}},
+ {0x0806, 64, { 0x54, 0x7f, 0xfd, 0x12, 0x0c, 0xda, 0x12, 0x0e, 0x0f, 0x8f, 0x15, 0xe4, 0xff, 0xe5, 0x16, 0x44, 0x80,
+  0xfd, 0x12, 0x0c, 0xda, 0xe5, 0x15, 0x30, 0xe7, 0x04, 0xc2, 0x08, 0x80, 0x02, 0xd2, 0x08, 0x90,
+  0x7f, 0x98, 0x74, 0x14, 0xf0, 0x75, 0x1a, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0xd2, 0x03,
+  0x22, 0xd2, 0x15, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02, 0xf0, 0x12, 0x0d, 0xf9, 0xd2, 0xe8}},
+ {0x0846, 64, { 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74,
+  0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xaf,
+  0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0x74, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2, 0x16, 0x12, 0x0d,
+  0x24, 0xc2, 0x02, 0xe4, 0xf5, 0x28, 0xf5, 0x30, 0xc2, 0x09, 0xf5, 0x23, 0xc2, 0x03, 0x90}},
+ {0x0886, 64, { 0x7f, 0xa1, 0x04, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x34, 0x60, 0x48, 0x30, 0x03, 0x05, 0xd2, 0x16,
+  0x12, 0x00, 0x46, 0xe5, 0x0f, 0x60, 0x22, 0xe5, 0x26, 0x60, 0x16, 0x15, 0x26, 0x90, 0x7f, 0xd8,
+  0xe0, 0x30, 0xe6, 0x04, 0x7f, 0x20, 0x80, 0x02, 0x7f, 0x30, 0x90, 0x7f, 0x96, 0xef, 0xf0, 0x80,
+  0x1a, 0x90, 0x7f, 0x96, 0x74, 0x30, 0xf0, 0x80, 0x12, 0x90, 0x7f, 0xd9, 0xe0, 0x30, 0xe2}},
+ {0x08c6, 64, { 0x04, 0x7f, 0x30, 0x80, 0x02, 0x7f, 0x20, 0x90, 0x7f, 0x96, 0xef, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0xf5,
+  0x34, 0x80, 0x20, 0x30, 0x03, 0x07, 0xc2, 0x16, 0x12, 0x00, 0x46, 0x80, 0x16, 0xe5, 0x0f, 0x70,
+  0x12, 0x90, 0x7f, 0xd9, 0xe0, 0x30, 0xe2, 0x04, 0x7f, 0x30, 0x80, 0x02, 0x7f, 0x20, 0x90, 0x7f,
+  0x96, 0xef, 0xf0, 0x30, 0x02, 0x07, 0xc2, 0x02, 0x12, 0x05, 0x2a, 0x80, 0x86, 0x30, 0x0a}},
+ {0x0906, 64, { 0x83, 0xc2, 0x0a, 0x12, 0x0b, 0x5d, 0x02, 0x08, 0x8a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf,
+  0x24, 0xe5, 0x2a, 0xf5, 0x82, 0xe5, 0x29, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00,
+  0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f,
+  0x98, 0x74, 0x10, 0xf0, 0xaf, 0x24, 0xe5, 0x2a, 0xf5, 0x82, 0xe5, 0x29, 0xf5, 0x83, 0xc2}},
+ {0x0946, 64, { 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86,
+  0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x24, 0xe5, 0x2a, 0xf5, 0x82, 0xe5,
+  0x29, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86,
+  0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf}},
+ {0x0986, 64, { 0x24, 0xe5, 0x2a, 0xf5, 0x82, 0xe5, 0x29, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0,
+  0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x74, 0x00, 0xf5,
+  0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f,
+  0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x78}},
+ {0x09c6, 64, { 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x39, 0x02, 0x0a, 0x0c, 0x02, 0x08, 0x38, 0xe4, 0x93, 0xa3,
+  0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4,
+  0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8,
+  0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02}},
+ {0x0a06, 64, { 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x0d, 0x8b, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff,
+  0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54,
+  0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4,
+  0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82}},
+ {0x0a46, 64, { 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a,
+  0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83,
+  0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83,
+  0xe0, 0x22, 0x50, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25}},
+ {0x0a86, 64, { 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22,
+  0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01,
+  0xf3, 0x22, 0xd0, 0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d,
+  0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02}},
+ {0x0ac6, 64, { 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80, 0xdf, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c,
+  0x74, 0x20, 0xf0, 0x30, 0x01, 0x03, 0xff, 0x80, 0x02, 0x7f, 0x00, 0x90, 0x7f, 0x96, 0xef, 0xf0,
+  0xe4, 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0,
+  0x30, 0x08, 0x11, 0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0xff, 0xf0, 0x90, 0x7f}},
+ {0x0b06, 64, { 0x98, 0x74, 0x20, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0xdf, 0xf0, 0xe4,
+  0x90, 0x7f, 0x98, 0xf0, 0x22, 0x8f, 0x35, 0xe4, 0xf5, 0x36, 0x75, 0x37, 0xff, 0x75, 0x38, 0x19,
+  0x75, 0x39, 0x86, 0xab, 0x37, 0xaa, 0x38, 0xa9, 0x39, 0x90, 0x00, 0x01, 0x12, 0x0a, 0x6a, 0xb4,
+  0x03, 0x1d, 0xaf, 0x36, 0x05, 0x36, 0xef, 0xb5, 0x35, 0x01, 0x22, 0x12, 0x0a, 0x51, 0x7e}},
+ {0x0b46, 64, { 0x00, 0x29, 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x37, 0xff, 0xf5, 0x38, 0x89, 0x39, 0x80, 0xd4, 0x7b,
+  0x00, 0x7a, 0x00, 0x79, 0x00, 0x22, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x35, 0x12, 0x0a, 0xcf, 0x20,
+  0x08, 0x07, 0x90, 0x7f, 0x92, 0xe0, 0x54, 0xfd, 0xf0, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0,
+  0x12, 0x09, 0xb5, 0x90, 0x7f, 0xd6, 0xe0, 0x30, 0xe7, 0x0e, 0x30, 0x01, 0x05, 0x12, 0x0d}},
+ {0x0b86, 64, { 0xbc, 0x80, 0x06, 0x12, 0x0d, 0x49, 0xef, 0x60, 0xe1, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02, 0xf0, 0x12,
+  0x07, 0x48, 0x22, 0x05, 0x2a, 0xe5, 0x2a, 0xae, 0x29, 0x70, 0x02, 0x05, 0x29, 0x14, 0xf5, 0x82,
+  0x8e, 0x83, 0xe5, 0x11, 0xf0, 0x12, 0x00, 0x36, 0x05, 0x2a, 0xe5, 0x2a, 0xac, 0x29, 0x70, 0x02,
+  0x05, 0x29, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x24, 0xe5, 0x24, 0x60, 0x07}},
+ {0x0bc6, 64, { 0x12, 0x0e, 0x1b, 0x8f, 0x11, 0x80, 0xcd, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0,
+  0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x02, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01,
+  0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0,
+  0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x0a}},
+ {0x0c06, 64, { 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82,
+  0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf,
+  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74,
+  0x13, 0xf0, 0xe5, 0x19, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74}},
+ {0x0c46, 64, { 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00,
+  0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x19, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
+  0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98,
+  0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5}},
+ {0x0c86, 64, { 0x19, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00,
+  0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x13, 0xf0, 0xe5, 0x19, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98,
+  0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0}},
+ {0x0cc6, 64, { 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x19, 0x54, 0x7f, 0x90, 0xc0,
+  0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x19, 0x54, 0x7f, 0x90, 0xc0, 0x00,
+  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74,
+  0x15, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x0d, 0xea, 0x8f, 0x37, 0x12, 0x0d}},
+ {0x0d06, 64, { 0xea, 0x8f, 0x38, 0xe5, 0x37, 0x65, 0x38, 0x60, 0x12, 0x12, 0x0d, 0xea, 0x8f, 0x37, 0xe5, 0x37, 0x65,
+  0x38, 0x60, 0x07, 0x12, 0x0d, 0xea, 0x8f, 0x38, 0x80, 0xe8, 0xaf, 0x37, 0x22, 0x90, 0x7f, 0xd6,
+  0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x16, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f,
+  0xf4, 0x7e, 0x01, 0x12, 0x0d, 0xa5, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44}},
+ {0x0d46, 64, { 0x04, 0xf0, 0x22, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x36, 0x12, 0x07, 0x48, 0x12, 0x0e, 0x27, 0xef, 0x30,
+  0xe6, 0x0b, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x36, 0x60, 0xf1, 0x7f, 0x01, 0x22, 0x12, 0x0a, 0xcf,
+  0x7f, 0x00, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x16, 0x54, 0x7f, 0xfd, 0x12, 0x0c, 0xda, 0x90,
+  0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x16, 0x44, 0x80}},
+ {0x0d86, 64, { 0xfd, 0x12, 0x0c, 0xda, 0x22, 0x05, 0x2b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x31, 0x03, 0x00, 0x00,
+  0xc1, 0x86, 0xc1, 0x02, 0xc1, 0x0a, 0xc1, 0x01, 0xc1, 0x07, 0x01, 0x27, 0x00, 0x00, 0x8e, 0x36,
+  0x8f, 0x37, 0xe5, 0x37, 0x15, 0x37, 0xae, 0x36, 0x70, 0x02, 0x15, 0x36, 0x4e, 0x60, 0x05, 0x12,
+  0x09, 0xa4, 0x80, 0xee, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x01, 0xf0, 0x7f, 0x0d, 0x7e}},
+ {0x0dc6, 64, { 0x00, 0x12, 0x0d, 0xa5, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfe, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x11,
+  0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00,
+  0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0xd2,
+  0x01, 0x22, 0xc2, 0x01, 0x22, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0b, 0xce, 0x00, 0x02, 0x0e}},
+ {0x0e06, 64, { 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x02, 0x0b, 0xf5, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x0e46, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x0e86, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x0ec6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x0f06, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x0f46, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x0f86, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x0fc6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1006, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1046, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1086, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x10c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1106, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1146, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1186, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x11c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1206, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1246, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1286, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x12c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1306, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1346, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1386, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x13c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1406, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1446, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1486, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x14c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1506, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1546, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1586, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x15c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1606, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1646, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1686, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x16c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1706, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1746, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1786, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x17c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1806, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1846, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1886, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x18c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00}},
+ {0x1906, 64, { 0x00, 0x40, 0xcd, 0x06, 0x19, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x02, 0x09, 0x02, 0x74, 0x00, 0x01,
+  0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00, 0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01,
+  0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40,
+  0x00, 0x00, 0x07, 0x05, 0x04, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x05, 0x02, 0x40, 0x00}},
+ {0x1946, 64, { 0x00, 0x07, 0x05, 0x06, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x07, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05,
+  0x81, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x83, 0x02,
+  0x40, 0x00, 0x01, 0x07, 0x05, 0x84, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x85, 0x02, 0x40, 0x00,
+  0x01, 0x07, 0x05, 0x86, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x87, 0x02, 0x40, 0x00, 0x01}},
+ {0x1986, 64, { 0x04, 0x03, 0x09, 0x04, 0x48, 0x03, 0x4b, 0x00, 0x65, 0x00, 0x79, 0x00, 0x73, 0x00, 0x70, 0x00, 0x61,
+  0x00, 0x6e, 0x00, 0x2c, 0x00, 0x20, 0x00, 0x61, 0x00, 0x20, 0x00, 0x64, 0x00, 0x69, 0x00, 0x76,
+  0x00, 0x69, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x20, 0x00, 0x6f, 0x00, 0x66,
+  0x00, 0x20, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x6e, 0x00, 0x6f, 0x00, 0x53, 0x00, 0x79, 0x00}},
+ {0x19c6, 64, { 0x73, 0x00, 0x20, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x36, 0x03, 0x4b, 0x00, 0x65,
+  0x00, 0x79, 0x00, 0x73, 0x00, 0x70, 0x00, 0x61, 0x00, 0x6e, 0x00, 0x20, 0x00, 0x55, 0x00, 0x53,
+  0x00, 0x42, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x69, 0x00, 0x61, 0x00, 0x6c,
+  0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00, 0x70, 0x00, 0x74, 0x00, 0x65, 0x00}},
+ {0x1a06,  4, { 0x72, 0x00, 0x00, 0x00}},
+ {0xffff, 0,	{0x00}}
+};
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa19w_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa19w_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa19w_fw.h	Wed Oct 10 00:15:02 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa19w_fw.h	Mon Nov 25 12:27:09 2002
@@ -1,108 +1,112 @@
 /* keyspan_usa19w_fw.h
-  
-   Generated from Keyspan firmware image usa17code.h Sat Oct  6 12:13:03 EST 2001
-   This firmware is for the Keyspan USA-19W Serial Adaptor
 
-   "The firmware contained herein as keyspan_usa19w_fw.h is
-   Copyright (C) 1999-2001 Keyspan, A division of InnoSys Incorporated
-   ("Keyspan"), as an unpublished work.  This notice does not imply
-   unrestricted or public access to this firmware which is a trade secret of
-   Keyspan, and which may not be reproduced, used, sold or transferred to any
-   third party without Keyspan's prior written consent.  All Rights Reserved.
+	The firmware contained herein as keyspan_usa19w_fw.h is
 
-   This firmware may not be modified and may only be used with the Keyspan 
-   USA-19W Serial Adapter.  Distribution and/or Modification of the
-   keyspan.c driver which includes this firmware, in whole or in part,
-   requires the inclusion of this statement."
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
 
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
+
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
 */
 
 static const struct ezusb_hex_record keyspan_usa19w_firmware[] = {
- {0x0033,  3, { 0x02, 0x0d, 0x6c}},
+ {0x0033,  3, { 0x02, 0x0d, 0x5c}},
  {0x0003, 16, { 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0}},
  {0x0013, 16, { 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x90}},
  {0x0023, 15, { 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x17, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x22}},
- {0x0046, 16, { 0x30, 0x0f, 0x18, 0x12, 0x0d, 0x48, 0xef, 0xc3, 0x95, 0x14, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
+ {0x0046, 16, { 0x30, 0x0f, 0x18, 0x12, 0x0d, 0x38, 0xef, 0xc3, 0x95, 0x14, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
  {0x0056, 16, { 0x7f, 0xbf, 0x74, 0x01, 0xf0, 0xc2, 0x0f, 0xc2, 0x0a, 0x80, 0x77, 0x30, 0x0c, 0x3b, 0x90, 0x7f}},
- {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x0d, 0x48, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
+ {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x0d, 0x38, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
  {0x0076, 16, { 0x40, 0xe0, 0x13, 0x92, 0x0f, 0x90, 0x7f, 0xc7, 0xe0, 0x14, 0xf5, 0x1c, 0x20, 0x0a, 0x11, 0x60}},
- {0x0086, 16, { 0x0f, 0xf5, 0x23, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x27, 0x7e, 0x75, 0x28, 0x41, 0x12, 0x08, 0x05}},
+ {0x0086, 16, { 0x0f, 0xf5, 0x23, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x27, 0x7e, 0x75, 0x28, 0x41, 0x12, 0x08, 0x01}},
  {0x0096, 16, { 0xc2, 0x0c, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0x80, 0x39, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x32}},
- {0x00a6, 16, { 0x12, 0x0d, 0x48, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x0f}},
+ {0x00a6, 16, { 0x12, 0x0d, 0x38, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x0f}},
  {0x00b6, 16, { 0x90, 0x7f, 0xc9, 0xe0, 0x14, 0xf5, 0x1c, 0x20, 0x0a, 0x11, 0x60, 0x0f, 0xf5, 0x23, 0x7e, 0x7d}},
- {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x27, 0x7d, 0x75, 0x28, 0xc1, 0x12, 0x08, 0x05, 0xd2, 0x0c, 0xe4, 0x90, 0x7f}},
- {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x60, 0x53, 0x11, 0x80, 0x12}},
- {0x00e6, 16, { 0x0d, 0x54, 0xef, 0x42, 0x11, 0x12, 0x0c, 0x51, 0x8f, 0x1c, 0xef, 0xc3, 0x95, 0x13, 0x50, 0x0f}},
- {0x00f6, 16, { 0x12, 0x0d, 0x30, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x11, 0x20, 0xe7, 0x03, 0x30, 0x12, 0x5b, 0xc2}},
+ {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x27, 0x7d, 0x75, 0x28, 0xc1, 0x12, 0x08, 0x01, 0xd2, 0x0c, 0xe4, 0x90, 0x7f}},
+ {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x5e, 0x12, 0x0c, 0x41, 0x8f}},
+ {0x00e6, 16, { 0x1c, 0x12, 0x0d, 0x44, 0x8f, 0x11, 0xe5, 0x1c, 0xc3, 0x95, 0x13, 0x50, 0x0f, 0x12, 0x0d, 0x20}},
+ {0x00f6, 16, { 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x11, 0x20, 0xe7, 0x03, 0x30, 0x12, 0x5c, 0xc2, 0x12, 0xe5, 0x1c}},
  {0x0036, 12, { 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22}},
  {0x0043,  3, { 0x02, 0x0e, 0x00}},
- {0x0000,  3, { 0x02, 0x08, 0xba}},
- {0x0106, 64, { 0x12, 0xe5, 0x1c, 0x70, 0x04, 0xf5, 0x11, 0x80, 0x51, 0xe5, 0x11, 0x30, 0xe7, 0x26, 0xe5, 0x1c, 0xd3,
-  0x94, 0x20, 0x40, 0x03, 0x75, 0x1c, 0x20, 0x85, 0x1c, 0x23, 0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x27,
-  0x7e, 0x75, 0x28, 0x80, 0xaf, 0x11, 0x12, 0x0a, 0x8a, 0xe5, 0x1c, 0x25, 0xe0, 0x90, 0x7f, 0xb7,
-  0xf0, 0x80, 0x26, 0xe5, 0x1c, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x1c, 0x3f, 0x85, 0x1c}},
- {0x0146, 64, { 0x23, 0xe4, 0x90, 0x7e, 0x80, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75, 0x27, 0x7e, 0x75, 0x28, 0x81, 0x12,
-  0x08, 0x2a, 0xe5, 0x1c, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90, 0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06,
-  0x20, 0x0d, 0x03, 0x02, 0x03, 0xba, 0xe4, 0xf5, 0x1b, 0x74, 0x40, 0x25, 0x1b, 0xf5, 0x82, 0xe4,
-  0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x1b, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79}},
- {0x0186, 64, { 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0a, 0x11, 0x05, 0x1b, 0xe5, 0x1b, 0xb4,
-  0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x6e, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0, 0xfd, 0x12,
-  0x0c, 0x2c, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12, 0x0b, 0x6e, 0x90, 0x7e, 0x02, 0xe0, 0xff, 0x12,
-  0x0b, 0x94, 0xd2, 0x10, 0xd2, 0x11, 0x75, 0x1c, 0x04, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x05}},
- {0x01c6, 64, { 0xc2, 0x11, 0x43, 0x1c, 0xc0, 0x90, 0x7e, 0x04, 0xe0, 0xb4, 0x01, 0x07, 0xc2, 0x11, 0x43, 0x1c, 0x0b,
-  0x80, 0x10, 0x90, 0x7e, 0x04, 0xe0, 0x60, 0x07, 0xc2, 0x10, 0x43, 0x1c, 0x09, 0x80, 0x03, 0x43,
-  0x1c, 0x02, 0x7f, 0x03, 0xad, 0x1c, 0x12, 0x0c, 0x2c, 0x43, 0x19, 0x80, 0x90, 0x7f, 0x98, 0x74,
-  0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x19, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5}},
- {0x0206, 64, { 0x16, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x05, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f,
-  0xf5, 0x18, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x18, 0xf0, 0x90, 0x7e,
-  0x07, 0xe0, 0x60, 0x42, 0x90, 0x7e, 0x13, 0xe0, 0x60, 0x05, 0x43, 0x15, 0x04, 0x80, 0x03, 0x53,
-  0x15, 0xfb, 0xe4, 0xff, 0xad, 0x15, 0x12, 0x0c, 0x2c, 0x90, 0x7e, 0x08, 0xe0, 0x60, 0x05}},
- {0x0246, 64, { 0x43, 0x17, 0x80, 0x80, 0x03, 0x53, 0x17, 0x7f, 0x53, 0x17, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11,
-  0x43, 0x17, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x0b, 0xe0, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x0c,
-  0x06, 0xaf, 0x17, 0x12, 0x0b, 0xba, 0x90, 0x7e, 0x0e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05,
-  0x43, 0x19, 0x01, 0x80, 0x03, 0x53, 0x19, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90}},
- {0x0286, 64, { 0xc0, 0x00, 0xe5, 0x19, 0xf0, 0x90, 0x7e, 0x0c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x19,
-  0x02, 0x80, 0x03, 0x53, 0x19, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5,
-  0x19, 0xf0, 0x90, 0x7e, 0x12, 0xe0, 0xf5, 0x13, 0xa3, 0xe0, 0x13, 0x92, 0x13, 0xa3, 0xe0, 0xf5,
-  0x14, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x19, 0x10, 0x80, 0x03, 0x53, 0x19, 0xef, 0x90, 0x7f}},
- {0x02c6, 64, { 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x19, 0xf0, 0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53,
-  0x18, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
-  0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x12, 0x0d, 0x24, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0,
-  0x53, 0x15, 0xfd, 0xe4, 0xff, 0xad, 0x15, 0x12, 0x0c, 0x2c, 0xe4, 0xf5, 0x0e, 0xf5, 0x0d}},
- {0x0306, 64, { 0xd2, 0x0e, 0x90, 0x7e, 0x17, 0xe0, 0x60, 0x0f, 0x43, 0x15, 0x02, 0xe4, 0xff, 0xad, 0x15, 0x12, 0x0c,
-  0x2c, 0x75, 0x0d, 0x01, 0xd2, 0x0e, 0x90, 0x7e, 0x18, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74,
-  0x12, 0xf0, 0xe5, 0x16, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x0a, 0x90, 0x7e, 0x19, 0xe0,
-  0x60, 0x11, 0x43, 0x18, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f}},
- {0x0346, 64, { 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f, 0x53, 0x15, 0xfe, 0xe4, 0xff, 0xad, 0x15,
-  0x12, 0x0c, 0x2c, 0x75, 0x0f, 0x01, 0xd2, 0x0e, 0x90, 0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x15,
-  0x01, 0xe4, 0xff, 0xad, 0x15, 0x12, 0x0c, 0x2c, 0xe4, 0xf5, 0x0f, 0xd2, 0x0e, 0x90, 0x7e, 0x1c,
-  0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x16, 0x44, 0x02, 0x90, 0xc0}},
- {0x0386, 64, { 0x00, 0xf0, 0x90, 0x7e, 0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x12, 0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75,
-  0x10, 0x01, 0xe4, 0xf5, 0x12, 0xd2, 0x0e, 0x90, 0x7e, 0x1f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7,
-  0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0, 0x74, 0x35, 0xf0, 0xc2, 0x0d, 0xe4, 0x90,
+ {0x0000,  3, { 0x02, 0x08, 0xb6}},
+ {0x0106, 64, { 0x60, 0x56, 0xb4, 0x80, 0x03, 0x43, 0x11, 0x02, 0xe5, 0x11, 0x30, 0xe7, 0x24, 0xe5, 0x1c, 0xd3, 0x94,
+  0x20, 0x40, 0x03, 0x75, 0x1c, 0x20, 0x85, 0x1c, 0x23, 0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x27, 0x7e,
+  0x75, 0x28, 0x80, 0x12, 0x0a, 0x86, 0xe5, 0x1c, 0x25, 0x1c, 0x90, 0x7f, 0xb7, 0xf0, 0x80, 0x27,
+  0xe5, 0x1c, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x1c, 0x3f, 0x85, 0x1c, 0x23, 0x90, 0x7e}},
+ {0x0146, 64, { 0x80, 0xe5, 0x11, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75, 0x27, 0x7e, 0x75, 0x28, 0x81, 0x12, 0x08, 0x26,
+  0xe5, 0x1c, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90, 0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x0d,
+  0x03, 0x02, 0x03, 0xba, 0xe4, 0xf5, 0x1b, 0x74, 0x40, 0x25, 0x1b, 0xf5, 0x82, 0xe4, 0x34, 0x7c,
+  0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x1b, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x00, 0x24}},
+ {0x0186, 64, { 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0a, 0x0d, 0x05, 0x1b, 0xe5, 0x1b, 0xb4, 0x20, 0xd7,
+  0x90, 0x7e, 0x00, 0xe0, 0x60, 0x6e, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0, 0xfd, 0x12, 0x0c, 0x1c,
+  0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12, 0x0b, 0x5e, 0x90, 0x7e, 0x02, 0xe0, 0xff, 0x12, 0x0b, 0x84,
+  0xd2, 0x10, 0xd2, 0x11, 0x75, 0x1c, 0x04, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x05, 0xc2, 0x11}},
+ {0x01c6, 64, { 0x43, 0x1c, 0xc0, 0x90, 0x7e, 0x04, 0xe0, 0xb4, 0x01, 0x07, 0xc2, 0x11, 0x43, 0x1c, 0x0b, 0x80, 0x10,
+  0x90, 0x7e, 0x04, 0xe0, 0x60, 0x07, 0xc2, 0x10, 0x43, 0x1c, 0x09, 0x80, 0x03, 0x43, 0x1c, 0x02,
+  0x7f, 0x03, 0xad, 0x1c, 0x12, 0x0c, 0x1c, 0x43, 0x19, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0,
+  0x90, 0xc0, 0x00, 0xe5, 0x19, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x16, 0x44}},
+ {0x0206, 64, { 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x05, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x18,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x18, 0xf0, 0x90, 0x7e, 0x07, 0xe0,
+  0x60, 0x42, 0x90, 0x7e, 0x13, 0xe0, 0x60, 0x05, 0x43, 0x15, 0x04, 0x80, 0x03, 0x53, 0x15, 0xfb,
+  0xe4, 0xff, 0xad, 0x15, 0x12, 0x0c, 0x1c, 0x90, 0x7e, 0x08, 0xe0, 0x60, 0x05, 0x43, 0x17}},
+ {0x0246, 64, { 0x80, 0x80, 0x03, 0x53, 0x17, 0x7f, 0x53, 0x17, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43, 0x17,
+  0x02, 0xa3, 0xe0, 0xff, 0x12, 0x0b, 0xd0, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x0b, 0xf6, 0xaf,
+  0x17, 0x12, 0x0b, 0xaa, 0x90, 0x7e, 0x0e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x19,
+  0x01, 0x80, 0x03, 0x53, 0x19, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00}},
+ {0x0286, 64, { 0xe5, 0x19, 0xf0, 0x90, 0x7e, 0x0c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x19, 0x02, 0x80,
+  0x03, 0x53, 0x19, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x19, 0xf0,
+  0x90, 0x7e, 0x12, 0xe0, 0xf5, 0x13, 0xa3, 0xe0, 0x13, 0x92, 0x13, 0xa3, 0xe0, 0xf5, 0x14, 0xa3,
+  0xe0, 0x60, 0x05, 0x43, 0x19, 0x10, 0x80, 0x03, 0x53, 0x19, 0xef, 0x90, 0x7f, 0x98, 0x74}},
+ {0x02c6, 64, { 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x19, 0xf0, 0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x18, 0xbf,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x11, 0xf0, 0x12, 0x0d, 0x14, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x15,
+  0xfd, 0xe4, 0xff, 0xad, 0x15, 0x12, 0x0c, 0x1c, 0xe4, 0xf5, 0x0e, 0xf5, 0x0d, 0xd2, 0x0e}},
+ {0x0306, 64, { 0x90, 0x7e, 0x17, 0xe0, 0x60, 0x0f, 0x43, 0x15, 0x02, 0xe4, 0xff, 0xad, 0x15, 0x12, 0x0c, 0x1c, 0x75,
+  0x0d, 0x01, 0xd2, 0x0e, 0x90, 0x7e, 0x18, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0,
+  0xe5, 0x16, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x0a, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11,
+  0x43, 0x18, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0}},
+ {0x0346, 64, { 0x00, 0xf0, 0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f, 0x53, 0x15, 0xfe, 0xe4, 0xff, 0xad, 0x15, 0x12, 0x0c,
+  0x1c, 0x75, 0x0f, 0x01, 0xd2, 0x0e, 0x90, 0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x15, 0x01, 0xe4,
+  0xff, 0xad, 0x15, 0x12, 0x0c, 0x1c, 0xe4, 0xf5, 0x0f, 0xd2, 0x0e, 0x90, 0x7e, 0x1c, 0xe0, 0x60,
+  0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x16, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0}},
+ {0x0386, 64, { 0x90, 0x7e, 0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x12, 0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x10, 0x01,
+  0xe4, 0xf5, 0x12, 0xd2, 0x0e, 0x90, 0x7e, 0x1f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x11,
+  0xf0, 0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0, 0x74, 0x35, 0xf0, 0xd2, 0x0c, 0xc2, 0x0d, 0xe4, 0x90,
   0x7f, 0xcf, 0xf0, 0x30, 0x15, 0x71, 0xe5, 0x12, 0x60, 0x02, 0x15, 0x12, 0xe5, 0x2e, 0xd3}},
- {0x03c6, 64, { 0x94, 0x00, 0x40, 0x04, 0x15, 0x2e, 0x80, 0x60, 0x75, 0x2e, 0x0a, 0x12, 0x0d, 0x24, 0xef, 0x54, 0x01,
-  0xf5, 0x1c, 0x65, 0x0e, 0x60, 0x07, 0x85, 0x1c, 0x0e, 0xd2, 0x0e, 0x80, 0x11, 0x12, 0x0d, 0x60,
+ {0x03c6, 64, { 0x94, 0x00, 0x40, 0x04, 0x15, 0x2e, 0x80, 0x60, 0x75, 0x2e, 0x0a, 0x12, 0x0d, 0x14, 0xef, 0x54, 0x01,
+  0xf5, 0x1c, 0x65, 0x0e, 0x60, 0x07, 0x85, 0x1c, 0x0e, 0xd2, 0x0e, 0x80, 0x11, 0x12, 0x0d, 0x50,
   0xef, 0x54, 0x10, 0xf5, 0x1c, 0x65, 0x09, 0x60, 0x05, 0x85, 0x1c, 0x09, 0xd2, 0x0e, 0x12, 0x0d,
-  0x60, 0xef, 0x54, 0x80, 0xf5, 0x1c, 0x65, 0x0a, 0x60, 0x05, 0x85, 0x1c, 0x0a, 0xd2, 0x0e}},
- {0x0406, 64, { 0x12, 0x0d, 0x60, 0xef, 0x54, 0x20, 0xf5, 0x1c, 0x65, 0x0b, 0x60, 0x08, 0x85, 0x1c, 0x0b, 0x30, 0x10,
-  0x02, 0xd2, 0x0e, 0x12, 0x0d, 0x60, 0xef, 0x54, 0x40, 0xf5, 0x1c, 0x65, 0x0c, 0x60, 0x08, 0x85,
+  0x50, 0xef, 0x54, 0x80, 0xf5, 0x1c, 0x65, 0x0a, 0x60, 0x05, 0x85, 0x1c, 0x0a, 0xd2, 0x0e}},
+ {0x0406, 64, { 0x12, 0x0d, 0x50, 0xef, 0x54, 0x20, 0xf5, 0x1c, 0x65, 0x0b, 0x60, 0x08, 0x85, 0x1c, 0x0b, 0x30, 0x10,
+  0x02, 0xd2, 0x0e, 0x12, 0x0d, 0x50, 0xef, 0x54, 0x40, 0xf5, 0x1c, 0x65, 0x0c, 0x60, 0x08, 0x85,
   0x1c, 0x0c, 0x30, 0x11, 0x02, 0xd2, 0x0e, 0x30, 0x15, 0x2a, 0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1,
   0x23, 0x90, 0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5, 0x30, 0x90, 0x7b, 0x42, 0xe0, 0xf5}},
  {0x0446, 64, { 0x31, 0x90, 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4,
   0x90, 0x7f, 0xd3, 0xf0, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x05, 0x1f, 0xe5, 0x25,
   0x70, 0x40, 0x30, 0x0e, 0x39, 0xe5, 0x12, 0x70, 0x35, 0xc2, 0x0e, 0xf5, 0x1b, 0x7e, 0x00, 0x7b,
-  0x00, 0x74, 0x08, 0x25, 0x1b, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x09, 0xcb, 0xff, 0x74}},
+  0x00, 0x74, 0x08, 0x25, 0x1b, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x09, 0xc7, 0xff, 0x74}},
  {0x0486, 64, { 0x80, 0x25, 0x1b, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x1b, 0xe5, 0x1b, 0xb4,
   0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x12, 0x10, 0xe4, 0xf5, 0x10, 0x75, 0x25,
   0x02, 0x22, 0xe5, 0x25, 0x64, 0x02, 0x70, 0x36, 0x30, 0x05, 0x2f, 0xc2, 0x05, 0xf5, 0x1b, 0x7e,
-  0x00, 0x7b, 0x00, 0x74, 0x29, 0x25, 0x1b, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x09, 0xcb}},
+  0x00, 0x7b, 0x00, 0x74, 0x29, 0x25, 0x1b, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x09, 0xc7}},
  {0x04c6, 64, { 0xff, 0x74, 0x80, 0x25, 0x1b, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x1b, 0xe5,
   0x1b, 0xb4, 0x05, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x05, 0xf0, 0x75, 0x25, 0x03, 0x22, 0xe5, 0x30,
   0x60, 0x33, 0x75, 0x2f, 0x03, 0x15, 0x30, 0xe4, 0xf5, 0x1b, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2f,
-  0x25, 0x1b, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x09, 0xcb, 0xff, 0x74, 0x80, 0x25, 0x1b}},
+  0x25, 0x1b, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x09, 0xc7, 0xff, 0x74, 0x80, 0x25, 0x1b}},
  {0x0506, 64, { 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x1b, 0xe5, 0x1b, 0xb4, 0x03, 0xdb, 0x90,
-  0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x25, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0a, 0x23,
+  0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x25, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0a, 0x1f,
   0x05, 0xf6, 0x00, 0x06, 0x6a, 0x01, 0x06, 0xd7, 0x03, 0x05, 0x43, 0x06, 0x05, 0xe9, 0x08, 0x05,
   0xe3, 0x09, 0x05, 0xcb, 0x0a, 0x05, 0xda, 0x0b, 0x00, 0x00, 0x07, 0x27, 0x90, 0x7f, 0xeb}},
  {0x0546, 64, { 0xe0, 0x24, 0xfe, 0x60, 0x16, 0x14, 0x60, 0x50, 0x24, 0x02, 0x70, 0x6f, 0x74, 0x19, 0x90, 0x7f, 0xd4,
@@ -110,7 +114,7 @@
   0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03, 0x75, 0x82, 0x82, 0x75, 0x83, 0x19, 0xef, 0xf0, 0x75, 0x82,
   0x74, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f, 0xea}},
  {0x0586, 64, { 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83, 0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x12,
-  0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x07, 0x2e, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0a, 0x49, 0xea,
+  0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x07, 0x2e, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0a, 0x45, 0xea,
   0x49, 0x60, 0x0d, 0xea, 0x90, 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x07, 0x2e,
   0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x07, 0x2e, 0x90, 0x7f, 0xb4, 0xe0, 0x44}},
  {0x05c6, 64, { 0x01, 0xf0, 0x02, 0x07, 0x2e, 0x90, 0x7f, 0x00, 0xe5, 0x24, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0,
@@ -124,14 +128,14 @@
  {0x0646, 64, { 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0,
   0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x07, 0x2e, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0,
   0x02, 0x07, 0x2e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1e, 0x24, 0x02, 0x60, 0x03, 0x02,
-  0x07, 0x2e, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x06, 0x12, 0x0d, 0x73, 0x02, 0x07, 0x2e}},
+  0x07, 0x2e, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x06, 0x12, 0x0d, 0x63, 0x02, 0x07, 0x2e}},
  {0x0686, 64, { 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x07, 0x2e, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38, 0x90,
   0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25,
   0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0,
   0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f}},
  {0x06c6, 64, { 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x60, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x57,
   0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x24, 0x02, 0x70, 0x4b, 0x90, 0x7f, 0xea, 0xe0,
-  0xb4, 0x01, 0x05, 0x12, 0x0d, 0x70, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80,
+  0xb4, 0x01, 0x05, 0x12, 0x0d, 0x60, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80,
   0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff}},
  {0x0706, 64, { 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f,
   0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07,
@@ -140,102 +144,102 @@
  {0x0746, 64, { 0x90, 0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x18,
   0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xe4, 0xf5,
   0x08, 0x7f, 0x01, 0x7b, 0x00, 0x74, 0x08, 0x2f, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0a,
-  0x11, 0x0f, 0xbf, 0x09, 0xee, 0x75, 0x13, 0x01, 0xe4, 0xf5, 0x12, 0xf5, 0x2e, 0xf5, 0x11}},
- {0x0786, 64, { 0xc2, 0x0e, 0xc2, 0x12, 0xc2, 0x0d, 0xc2, 0x0a, 0xc2, 0x0f, 0xc2, 0x04, 0xd2, 0x0c, 0xd2, 0x0b, 0x90,
-  0x7f, 0x98, 0x74, 0x13, 0xf0, 0x75, 0x18, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f, 0x0c,
-  0xe4, 0xfd, 0x12, 0x0c, 0x2c, 0x7f, 0x10, 0x8f, 0x17, 0x12, 0x0b, 0xba, 0x90, 0x7f, 0x98, 0x74,
-  0x12, 0xf0, 0x7f, 0x01, 0x8f, 0x16, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f}},
- {0x07c6, 64, { 0x98, 0x74, 0x14, 0xf0, 0x75, 0x19, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12,
-  0x0c, 0x2c, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x15, 0x12, 0x0c, 0x2c, 0x90, 0x7f, 0x98,
-  0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x0c, 0x2c, 0x7f,
-  0x01, 0x12, 0x0c, 0xbc, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x0c, 0x2c, 0xd2, 0x03, 0x22, 0x90}},
- {0x0806, 64, { 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x23, 0xe5, 0x28, 0xf5, 0x82, 0xe5, 0x27, 0xf5, 0x83, 0xc2, 0xaf,
-  0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7,
-  0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x23, 0xe5, 0x28, 0xf5, 0x82, 0xe5,
-  0x27, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3}},
- {0x0846, 64, { 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x23,
-  0xe5, 0x28, 0xf5, 0x82, 0xe5, 0x27, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05,
-  0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x08, 0xf0, 0xaf, 0x23, 0xe5, 0x28, 0xf5, 0x82, 0xe5, 0x27, 0xf5, 0x83, 0xc2, 0xaf}},
- {0x0886, 64, { 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2,
-  0xaf, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83,
-  0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x31, 0x02, 0x09, 0x01}},
- {0x08c6, 64, { 0x02, 0x09, 0x46, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08,
-  0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4,
-  0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4,
-  0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x0c, 0xdd, 0xe4, 0x7e}},
- {0x0906, 64, { 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3,
-  0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa,
-  0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0,
-  0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe}},
- {0x0946, 64, { 0xd2, 0x14, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02, 0xf0, 0x12, 0x0d, 0x73, 0xd2, 0xe8, 0x43, 0xd8, 0x20,
-  0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0,
-  0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xaf, 0xe0, 0x44,
-  0x01, 0xf0, 0x90, 0x7f, 0xae, 0x74, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2, 0x15, 0x12, 0x0c, 0x76}},
- {0x0986, 64, { 0xc2, 0x02, 0xe4, 0xf5, 0x26, 0xf5, 0x2e, 0xc2, 0x08, 0xc2, 0x03, 0x90, 0x7f, 0xa1, 0x04, 0xf0, 0x90,
-  0x7f, 0xd8, 0xe0, 0x65, 0x1a, 0x60, 0x10, 0x30, 0x03, 0x05, 0xd2, 0x15, 0x12, 0x00, 0x46, 0x90,
-  0x7f, 0xd8, 0xe0, 0xf5, 0x1a, 0x80, 0x08, 0x30, 0x03, 0x05, 0xc2, 0x15, 0x12, 0x00, 0x46, 0x30,
-  0x02, 0x07, 0xc2, 0x02, 0x12, 0x05, 0x20, 0x80, 0xd6, 0x30, 0x09, 0xd3, 0xc2, 0x09, 0x12}},
- {0x09c6, 64, { 0x0a, 0xf1, 0x80, 0xcc, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7,
-  0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c,
-  0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 0x25,
-  0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82}},
- {0x0a06, 64, { 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a,
-  0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0, 0x82,
-  0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01,
-  0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3}},
- {0x0a46, 64, { 0xa3, 0x80, 0xdf, 0x8f, 0x1b, 0xe4, 0xf5, 0x1c, 0x75, 0x1d, 0xff, 0x75, 0x1e, 0x19, 0x75, 0x1f, 0x86,
-  0xab, 0x1d, 0xaa, 0x1e, 0xa9, 0x1f, 0x90, 0x00, 0x01, 0x12, 0x09, 0xe4, 0xb4, 0x03, 0x1d, 0xaf,
-  0x1c, 0x05, 0x1c, 0xef, 0xb5, 0x1b, 0x01, 0x22, 0x12, 0x09, 0xcb, 0x7e, 0x00, 0x29, 0xff, 0xee,
-  0x3a, 0xa9, 0x07, 0x75, 0x1d, 0xff, 0xf5, 0x1e, 0x89, 0x1f, 0x80, 0xd4, 0x7b, 0x00, 0x7a}},
- {0x0a86, 64, { 0x00, 0x79, 0x00, 0x22, 0x8f, 0x1d, 0x05, 0x28, 0xe5, 0x28, 0xae, 0x27, 0x70, 0x02, 0x05, 0x27, 0x14,
-  0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1d, 0xf0, 0x12, 0x00, 0x36, 0x05, 0x28, 0xe5, 0x28, 0xac, 0x27,
-  0x70, 0x02, 0x05, 0x27, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x23, 0xe5, 0x23, 0x60,
-  0x0a, 0x12, 0x0d, 0x54, 0x8f, 0x1d, 0xef, 0x42, 0x11, 0x80, 0xca, 0x22, 0xc0, 0xe0, 0xc0}},
- {0x0ac6, 64, { 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x30, 0x06, 0x04, 0xc2, 0x06,
-  0x80, 0x02, 0xd2, 0x09, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0,
-  0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x1b,
-  0x12, 0x00, 0x03, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x08, 0xaa, 0x90, 0x7f}},
- {0x0b06, 64, { 0xd6, 0xe0, 0x30, 0xe7, 0x0e, 0x30, 0x01, 0x05, 0x12, 0x0d, 0x0e, 0x80, 0x06, 0x12, 0x0c, 0x9b, 0xef,
-  0x60, 0xe1, 0x12, 0x07, 0x36, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84,
-  0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab,
-  0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0}},
- {0x0b46, 64, { 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2,
-  0x02, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85,
+  0x0d, 0x0f, 0xbf, 0x09, 0xee, 0x75, 0x13, 0x01, 0xe4, 0xf5, 0x12, 0xf5, 0x2e, 0xf5, 0x11}},
+ {0x0786, 64, { 0xc2, 0x0e, 0xc2, 0x12, 0xc2, 0x0d, 0xc2, 0x0a, 0xc2, 0x0f, 0xc2, 0x04, 0x90, 0x7f, 0x98, 0x74, 0x13,
+  0xf0, 0x75, 0x18, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x0c,
+  0x1c, 0x7f, 0x10, 0x8f, 0x17, 0x12, 0x0b, 0xaa, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x7f, 0x01,
+  0x8f, 0x16, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x0c, 0x1c}},
+ {0x07c6, 64, { 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x15, 0x12, 0x0c, 0x1c, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0,
+  0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x0c, 0x1c, 0x7f, 0x01, 0x12, 0x0c,
+  0xac, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x0c, 0x1c, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x75, 0x19,
+  0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0xd2, 0x03, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10}},
+ {0x0806, 64, { 0xf0, 0xaf, 0x23, 0xe5, 0x28, 0xf5, 0x82, 0xe5, 0x27, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0,
+  0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90,
+  0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x23, 0xe5, 0x28, 0xf5, 0x82, 0xe5, 0x27, 0xf5, 0x83, 0xc2,
+  0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7}},
+ {0x0846, 64, { 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x23, 0xe5, 0x28, 0xf5, 0x82,
+  0xe5, 0x27, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05,
+  0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf,
+  0x23, 0xe5, 0x28, 0xf5, 0x82, 0xe5, 0x27, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0}},
+ {0x0886, 64, { 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x74, 0x00,
+  0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90,
+  0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x78,
+  0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x31, 0x02, 0x08, 0xfd, 0x02, 0x09, 0x42, 0xe4}},
+ {0x08c6, 64, { 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29,
+  0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20,
+  0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02,
+  0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x0c, 0xcd, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc}},
+ {0x0906, 64, { 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf,
+  0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8,
+  0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82,
+  0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xd2, 0x14, 0x90, 0x7f}},
+ {0x0946, 64, { 0x92, 0xe0, 0x44, 0x02, 0xf0, 0x12, 0x0d, 0x63, 0xd2, 0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74,
+  0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0,
+  0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f,
+  0xae, 0x74, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2, 0x15, 0x12, 0x0c, 0x66, 0xc2, 0x02, 0xe4, 0xf5}},
+ {0x0986, 64, { 0x26, 0xf5, 0x2e, 0xc2, 0x08, 0xc2, 0x03, 0x90, 0x7f, 0xa1, 0x04, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65,
+  0x1a, 0x60, 0x10, 0x30, 0x03, 0x05, 0xd2, 0x15, 0x12, 0x00, 0x46, 0x90, 0x7f, 0xd8, 0xe0, 0xf5,
+  0x1a, 0x80, 0x08, 0x30, 0x03, 0x05, 0xc2, 0x15, 0x12, 0x00, 0x46, 0x30, 0x02, 0x07, 0xc2, 0x02,
+  0x12, 0x05, 0x20, 0x80, 0xd6, 0x30, 0x09, 0xd3, 0xc2, 0x09, 0x12, 0x0a, 0xba, 0x80, 0xcc}},
+ {0x09c6, 64, { 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02,
+  0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c, 0xe5, 0x82, 0x29, 0xf5,
+  0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe6, 0x22,
+  0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5}},
+ {0x0a06, 64, { 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50,
+  0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70,
+  0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88,
+  0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80, 0xdf, 0x8f}},
+ {0x0a46, 64, { 0x1b, 0xe4, 0xf5, 0x1c, 0x75, 0x1d, 0xff, 0x75, 0x1e, 0x19, 0x75, 0x1f, 0x86, 0xab, 0x1d, 0xaa, 0x1e,
+  0xa9, 0x1f, 0x90, 0x00, 0x01, 0x12, 0x09, 0xe0, 0xb4, 0x03, 0x1d, 0xaf, 0x1c, 0x05, 0x1c, 0xef,
+  0xb5, 0x1b, 0x01, 0x22, 0x12, 0x09, 0xc7, 0x7e, 0x00, 0x29, 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75,
+  0x1d, 0xff, 0xf5, 0x1e, 0x89, 0x1f, 0x80, 0xd4, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x00, 0x22}},
+ {0x0a86, 64, { 0x05, 0x28, 0xe5, 0x28, 0xae, 0x27, 0x70, 0x02, 0x05, 0x27, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x11,
+  0xf0, 0x12, 0x00, 0x36, 0x05, 0x28, 0xe5, 0x28, 0xac, 0x27, 0x70, 0x02, 0x05, 0x27, 0x14, 0xf5,
+  0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x23, 0xe5, 0x23, 0x60, 0x07, 0x12, 0x0d, 0x44, 0x8f, 0x11,
+  0x80, 0xcd, 0x22, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x1b, 0x12, 0x00, 0x03, 0x90, 0x7f, 0xd6}},
+ {0x0ac6, 64, { 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x08, 0xa6, 0x90, 0x7f, 0xd6, 0xe0, 0x30, 0xe7, 0x0e, 0x30, 0x01, 0x05,
+  0x12, 0x0c, 0xfe, 0x80, 0x06, 0x12, 0x0c, 0x8b, 0xef, 0x60, 0xe1, 0x12, 0x07, 0x36, 0x22, 0xc0,
+  0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f,
+  0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0}},
+ {0x0b06, 64, { 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0,
+  0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x02, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab,
+  0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32,
+  0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00}},
+ {0x0b46, 64, { 0xd2, 0x09, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85,
   0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00,
-  0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90}},
- {0x0b86, 64, { 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90,
+  0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f}},
+ {0x0b86, 64, { 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90,
   0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0,
-  0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0}},
- {0x0bc6, 64, { 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0,
-  0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90,
+  0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90,
+  0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13}},
+ {0x0bc6, 64, { 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90,
   0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0,
-  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22}},
- {0x0c06, 64, { 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16,
-  0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90,
+  0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74}},
+ {0x0c06, 64, { 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f,
   0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x18, 0x54, 0x7f, 0x90,
-  0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90}},
- {0x0c46, 64, { 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x0d, 0x3c, 0x8f, 0x1d, 0x12,
-  0x0d, 0x3c, 0x8f, 0x1e, 0xe5, 0x1d, 0x65, 0x1e, 0x60, 0x12, 0x12, 0x0d, 0x3c, 0x8f, 0x1d, 0xe5,
-  0x1d, 0x65, 0x1e, 0x60, 0x07, 0x12, 0x0d, 0x3c, 0x8f, 0x1e, 0x80, 0xe8, 0xaf, 0x1d, 0x22, 0x90,
-  0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x15, 0x04, 0xe0, 0x44}},
- {0x0c86, 64, { 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x0c, 0xf7, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0,
-  0x44, 0x04, 0xf0, 0x22, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x1c, 0x12, 0x07, 0x36, 0x12, 0x0d, 0x60,
+  0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x0d, 0x2c, 0x8f, 0x1d}},
+ {0x0c46, 64, { 0x12, 0x0d, 0x2c, 0x8f, 0x1e, 0xe5, 0x1d, 0x65, 0x1e, 0x60, 0x12, 0x12, 0x0d, 0x2c, 0x8f, 0x1d, 0xe5,
+  0x1d, 0x65, 0x1e, 0x60, 0x07, 0x12, 0x0d, 0x2c, 0x8f, 0x1e, 0x80, 0xe8, 0xaf, 0x1d, 0x22, 0x90,
+  0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x15, 0x04, 0xe0, 0x44, 0x02,
+  0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x0c, 0xe7, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0}},
+ {0x0c86, 64, { 0xe0, 0x44, 0x04, 0xf0, 0x22, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x1c, 0x12, 0x07, 0x36, 0x12, 0x0d, 0x50,
   0xef, 0x30, 0xe6, 0x0b, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x1c, 0x60, 0xf1, 0x7f, 0x01, 0x22, 0x12,
-  0x00, 0x03, 0x7f, 0x00, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x15, 0x54, 0x7f, 0xfd, 0x12}},
- {0x0cc6, 64, { 0x0c, 0x2c, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x15, 0x44,
-  0x80, 0xfd, 0x12, 0x0c, 0x2c, 0x22, 0x05, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x03,
+  0x00, 0x03, 0x7f, 0x00, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x15, 0x54, 0x7f, 0xfd, 0x12, 0x0c,
+  0x1c, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x15}},
+ {0x0cc6, 64, { 0x44, 0x80, 0xfd, 0x12, 0x0c, 0x1c, 0x22, 0x05, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x03,
   0x00, 0x00, 0xc1, 0x86, 0xc1, 0x02, 0xc1, 0x09, 0xc1, 0x01, 0xc1, 0x07, 0x01, 0x25, 0x00, 0x00,
-  0x8e, 0x1c, 0x8f, 0x1d, 0xe5, 0x1d, 0x15, 0x1d, 0xae, 0x1c, 0x70, 0x02, 0x15, 0x1c, 0x4e}},
- {0x0d06, 64, { 0x60, 0x05, 0x12, 0x08, 0x99, 0x80, 0xee, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x01, 0xf0, 0x7f, 0x0d,
-  0x7e, 0x00, 0x12, 0x0c, 0xf7, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfe, 0xf0, 0x22, 0x90, 0x7f, 0x98,
+  0x8e, 0x1c, 0x8f, 0x1d, 0xe5, 0x1d, 0x15, 0x1d, 0xae, 0x1c, 0x70, 0x02, 0x15, 0x1c, 0x4e, 0x60,
+  0x05, 0x12, 0x08, 0x95, 0x80, 0xee, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x01, 0xf0, 0x7f}},
+ {0x0d06, 64, { 0x0d, 0x7e, 0x00, 0x12, 0x0c, 0xe7, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfe, 0xf0, 0x22, 0x90, 0x7f, 0x98,
   0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90,
-  0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0}},
- {0x0d46, 64, { 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90,
+  0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff,
+  0x22, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f}},
+ {0x0d46, 64, { 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90,
   0xc0, 0x00, 0xe0, 0xff, 0x22, 0x53, 0xd8, 0xef, 0x32, 0xd2, 0x01, 0x22, 0xc2, 0x01, 0x22, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
  {0x0d86, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -244,8 +248,8 @@
  {0x0dc6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0b, 0x47, 0x00, 0x02, 0x0e}},
- {0x0e06, 64, { 0x04, 0x00, 0x02, 0x0b, 0x1d, 0x00, 0x02, 0x0a, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0b, 0x10, 0x00, 0x02, 0x0e}},
+ {0x0e06, 64, { 0x04, 0x00, 0x02, 0x0a, 0xe6, 0x00, 0x02, 0x0b, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
@@ -420,15 +424,15 @@
  {0x18c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x00, 0x01, 0xff, 0x00}},
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00}},
  {0x1906, 64, { 0x00, 0x40, 0xcd, 0x06, 0x08, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x02, 0x09, 0x02, 0x74, 0x00, 0x01,
   0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00, 0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01,
   0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40,
   0x00, 0x00, 0x07, 0x05, 0x04, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x05, 0x02, 0x40, 0x00}},
  {0x1946, 64, { 0x00, 0x07, 0x05, 0x06, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x07, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05,
-  0x81, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x83, 0x02,
-  0x40, 0x00, 0x00, 0x07, 0x05, 0x84, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x85, 0x02, 0x40, 0x00,
-  0x01, 0x07, 0x05, 0x86, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x87, 0x02, 0x40, 0x00, 0x01}},
+  0x81, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x83, 0x02,
+  0x40, 0x00, 0x01, 0x07, 0x05, 0x84, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x85, 0x02, 0x40, 0x00,
+  0x01, 0x07, 0x05, 0x86, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x87, 0x02, 0x40, 0x00, 0x01}},
  {0x1986, 64, { 0x04, 0x03, 0x09, 0x04, 0x48, 0x03, 0x4b, 0x00, 0x65, 0x00, 0x79, 0x00, 0x73, 0x00, 0x70, 0x00, 0x61,
   0x00, 0x6e, 0x00, 0x2c, 0x00, 0x20, 0x00, 0x61, 0x00, 0x20, 0x00, 0x64, 0x00, 0x69, 0x00, 0x76,
   0x00, 0x69, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x20, 0x00, 0x6f, 0x00, 0x66,
@@ -438,5 +442,5 @@
   0x00, 0x42, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x69, 0x00, 0x61, 0x00, 0x6c,
   0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00, 0x70, 0x00, 0x74, 0x00, 0x65, 0x00}},
  {0x1a06,  4, { 0x72, 0x00, 0x00, 0x00}},
-{ 0xffff,	0,	{0x00} }
+ {0xffff,	0,	{0x00} }
 };
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa26msg.h linux-2.4.19/drivers/usb/serial/keyspan_usa26msg.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa26msg.h	Wed Oct 10 00:15:02 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa26msg.h	Mon Nov 25 12:27:09 2002
@@ -44,7 +44,7 @@
 	Buffer formats for RX/TX data messages are not defined by
 	a structure, but are described here:
 
-	USB OUT (host -> USA26, transmit) messages contain a 
+	USB OUT (host -> USAxx, transmit) messages contain a 
 	REQUEST_ACK indicator (set to 0xff to request an ACK at the 
 	completion of transmit; 0x00 otherwise), followed by data:
 
@@ -52,25 +52,48 @@
 
 	with a total data length of 63.
 
-	USB IN (USA26 -> host, receive) messages contain either a zero
-	flag (indicating no error in any data bytes):
+	USB IN (USAxx -> host, receive) messages begin with a status
+	byte in which the 0x80 bit is either:
 
-		00 DAT DAT DAT ...
+		(a)	0x80 bit clear
+			indicates that the bytes following it are all data
+			bytes:
 
-	for a total of 63 data bytes, or a non-zero status flag (indicating 
-	that all data bytes will be preceded by status flag):
+				STAT DATA DATA DATA DATA DATA ...
 
-		STAT DAT STAT DAT STAT DAT ...
+			for a total of up to 63 DATA bytes,
 
-	for a total of 32 data bytes.  The valid bits in the STAT bytes are:
+	or:
+
+		(b)	0x80 bit set
+			indiates that the bytes following alternate data and
+			status bytes:
+
+				STAT DATA STAT DATA STAT DATA STAT DATA ...
+
+			for a total of up to 32 DATA bytes.
+
+	The valid bits in the STAT bytes are:
 
 		OVERRUN	0x02
 		PARITY	0x04
 		FRAMING	0x08
 		BREAK	0x10
 
-	Note: a "no status" RX data message (first byte zero) can serve as
-	a "break off" indicator.
+	Notes:
+
+	(1) The OVERRUN bit can appear in either (a) or (b) format
+		messages, but the but the PARITY/FRAMING/BREAK bits
+		only appear in (b) format messages.
+	(2) For the host to determine the exact point at which the
+		overrun occurred (to identify the point in the data
+		stream at which the data was lost), it needs to count
+		128 characters, starting at the first character of the
+		message in which OVERRUN was reported; the lost character(s)
+		would have been received between the 128th and 129th
+		characters.
+	(3)	An RX data message in which the first byte has 0x80 clear
+		serves as a "break off" indicator.
 
 	revision history:
 
@@ -80,6 +103,7 @@
 	1999apr14	add resetDataToggle to control message
 	2000jan04	merge with usa17msg.h
 	2000jun01	add extended BSD-style copyright text
+	2001jul05	change message format to improve OVERRUN case
 
 	Note on shared names:
 
@@ -93,7 +117,7 @@
 #define	__USA26MSG__
 
 
-typedef struct keyspan_usa26_portControlMessage
+struct keyspan_usa26_portControlMessage
 {
 	/*
 		there are three types of "commands" sent in the control message:
@@ -164,7 +188,7 @@
 		returnStatus,	// BOTH: return current status (even if it hasn't changed)
 		resetDataToggle;// BOTH: reset data toggle state to DATA0
 	
-} keyspan_usa26_portControlMessage;
+};
 
 // defines for bits in lcr
 #define	USA_DATABITS_5		0x00
@@ -182,7 +206,7 @@
 
 // all things called "StatusMessage" are sent on the status endpoint
 
-typedef struct keyspan_usa26_portStatusMessage	// one for each port
+struct keyspan_usa26_portStatusMessage	// one for each port
 {
 	u8	port,			// BOTH: 0=first, 1=second, other=see below
 		hskia_cts,		// USA26: reports HSKIA pin
@@ -195,7 +219,7 @@
 		_txXoff,		// port is in XOFF state (either host or RX XOFF)
 		rxEnabled,		// as configured by rxOn/rxOff 1=on, 0=off
 		controlResponse;// 1=a control message has been processed
-} keyspan_usa26_portStatusMessage;
+};
 
 // bits in RX data message when STAT byte is included
 #define	RXERROR_OVERRUN	0x02
@@ -203,28 +227,28 @@
 #define	RXERROR_FRAMING	0x08
 #define	RXERROR_BREAK	0x10
 
-typedef struct keyspan_usa26_globalControlMessage
+struct keyspan_usa26_globalControlMessage
 {
 	u8	sendGlobalStatus,	// 2=request for two status responses
 		resetStatusToggle,	// 1=reset global status toggle
 		resetStatusCount;	// a cycling value
-} keyspan_usa26_globalControlMessage;
+};
 
-typedef struct keyspan_usa26_globalStatusMessage
+struct keyspan_usa26_globalStatusMessage
 {
 	u8	port,				// 3
 		sendGlobalStatus,	// from request, decremented
 		resetStatusCount;	// as in request
-} keyspan_usa26_globalStatusMessage;
+};
 
-typedef struct keyspan_usa26_globalDebugMessage
+struct keyspan_usa26_globalDebugMessage
 {
 	u8	port,				// 2
 		a,
 		b,
 		c,
 		d;
-} keyspan_usa26_globalDebugMessage;
+};
 
 // ie: the maximum length of an EZUSB endpoint buffer
 #define	MAX_DATA_LEN			64
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa28_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa28_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa28_fw.h	Wed Oct 10 00:15:02 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa28_fw.h	Mon Nov 25 12:27:09 2002
@@ -1,28 +1,33 @@
 /* keyspan_usa28_fw.h
-  
-   Generated from Keyspan firmware image usa28code.h Sat Oct  6 12:11:26 EST 2001
-   This firmware is for the Keyspan USA-28 Serial Adaptor
 
-   "The firmware contained herein as keyspan_usa28_fw.h is
-   Copyright (C) 1999-2001 Keyspan, A division of InnoSys Incorporated
-   ("Keyspan"), as an unpublished work.  This notice does not imply
-   unrestricted or public access to this firmware which is a trade secret of
-   Keyspan, and which may not be reproduced, used, sold or transferred to any
-   third party without Keyspan's prior written consent.  All Rights Reserved.
+	The firmware contained herein as keyspan_usa28_fw.h is
 
-   This firmware may not be modified and may only be used with the Keyspan 
-   USA-28 Serial Adapter.  Distribution and/or Modification of the
-   keyspan.c driver which includes this firmware, in whole or in part,
-   requires the inclusion of this statement."
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
+
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
+
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
 
 */
 
 static const struct ezusb_hex_record keyspan_usa28_firmware[] = {
- {0x0026, 10, { 0x12, 0x18, 0x09, 0x12, 0x18, 0xbc, 0x12, 0x14, 0xbb, 0x22}},
+ {0x0026, 10, { 0x12, 0x17, 0xdb, 0x12, 0x18, 0xb5, 0x12, 0x14, 0xc3, 0x22}},
  {0x0033,  3, { 0x02, 0x00, 0x1d}},
  {0x001d,  4, { 0x53, 0xd8, 0xef, 0x32}},
  {0x0006, 16, { 0x8e, 0x12, 0x8f, 0x13, 0xe5, 0x13, 0x15, 0x13, 0xae, 0x12, 0x70, 0x02, 0x15, 0x12, 0x4e, 0x60}},
- {0x0016,  7, { 0x05, 0x12, 0x18, 0xab, 0x80, 0xee, 0x22}},
+ {0x0016,  7, { 0x05, 0x12, 0x18, 0xa4, 0x80, 0xee, 0x22}},
  {0x0003,  3, { 0x02, 0x00, 0x46}},
  {0x0046, 16, { 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xc0, 0xd0, 0x75, 0xd0, 0x08}},
  {0x0056, 16, { 0x30, 0x99, 0x0e, 0x30, 0x11, 0x07, 0xa2, 0x17, 0x92, 0x9b, 0x85, 0x46, 0x99, 0xc2, 0x99, 0xd2}},
@@ -192,7 +197,7 @@
   0x40, 0x15, 0x15, 0x49, 0x15, 0x49, 0x05, 0x39, 0xd2, 0x0e, 0x80, 0x0b, 0x90, 0x7f, 0xbd, 0xe5,
   0x49, 0xf0, 0x75, 0x49, 0x00, 0xd2, 0x02, 0xd2, 0x25, 0x30, 0x25, 0x05, 0xc2, 0x25, 0x02, 0x00,
   0x56, 0xd0, 0xd0, 0xd0, 0x86, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0xce}},
- {0x0a86, 64, { 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x0b, 0xa1, 0xe4, 0xf5, 0x12, 0x74, 0x40, 0x25, 0x12, 0xf5, 0x82, 0xe4,
+ {0x0a86, 64, { 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x0b, 0xa5, 0xe4, 0xf5, 0x12, 0x74, 0x40, 0x25, 0x12, 0xf5, 0x82, 0xe4,
   0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x12, 0x7c, 0x00, 0x7b, 0x00, 0x24, 0x4c, 0xf9, 0xec,
   0x34, 0x00, 0xfa, 0xef, 0x12, 0x15, 0xcd, 0x05, 0x12, 0xe5, 0x12, 0xb4, 0x18, 0xdb, 0xe5, 0x4c,
   0x60, 0x0c, 0x75, 0xc9, 0x20, 0x75, 0xc8, 0x36, 0x85, 0x4d, 0xca, 0x85, 0x4e, 0xcb, 0xe5}},
@@ -207,166 +212,166 @@
  {0x0b46, 64, { 0x02, 0xf0, 0x90, 0x7f, 0x98, 0xe0, 0x54, 0xfd, 0xf0, 0xe5, 0x5e, 0x60, 0x0a, 0xd2, 0x9c, 0xc2, 0x98,
   0x75, 0x2e, 0x01, 0x75, 0x40, 0x28, 0xe5, 0x5f, 0x60, 0x07, 0xc2, 0x9c, 0xe4, 0xf5, 0x48, 0xf5,
   0x2e, 0xe5, 0x60, 0x60, 0x03, 0xe4, 0xf5, 0x48, 0xe5, 0x61, 0x60, 0x02, 0xd2, 0x07, 0xe5, 0x62,
-  0x60, 0x08, 0xe5, 0x5e, 0x70, 0x02, 0xf5, 0x40, 0xd2, 0x0c, 0xe5, 0x63, 0x60, 0x15, 0x90}},
+  0x60, 0x08, 0xe5, 0x5e, 0x70, 0x02, 0xf5, 0x40, 0xd2, 0x0c, 0xe5, 0x63, 0x60, 0x19, 0x90}},
  {0x0b86, 64, { 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74, 0x12, 0xf0, 0x74, 0x32, 0xf0, 0x74, 0x15, 0xf0,
-  0x74, 0x35, 0xf0, 0xd2, 0x09, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0xa2, 0x13, 0xe4, 0x33, 0xff, 0x65,
-  0x2b, 0x60, 0x04, 0x8f, 0x2b, 0xd2, 0x0c, 0xa2, 0x0b, 0xe4, 0x33, 0xff, 0x65, 0x2c, 0x60, 0x04,
-  0x8f, 0x2c, 0xd2, 0x0c, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x08, 0x65, 0x27, 0x60, 0x07, 0xe0}},
- {0x0bc6, 64, { 0x54, 0x08, 0xf5, 0x27, 0xd2, 0x0c, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x40, 0xb5, 0x29, 0x09, 0xe0, 0x54,
-  0x40, 0x64, 0x40, 0xf5, 0x29, 0xd2, 0x0c, 0x30, 0x07, 0x35, 0xc2, 0xaf, 0x30, 0x01, 0x18, 0x90,
-  0x7f, 0xb8, 0xe0, 0x20, 0xe1, 0x27, 0xe5, 0x48, 0x60, 0x09, 0x90, 0x7f, 0xb7, 0xf0, 0xe4, 0xf5,
-  0x48, 0xc2, 0x01, 0xc2, 0x07, 0x80, 0x16, 0x90, 0x7f, 0xb6, 0xe0, 0x20, 0xe1, 0x0f, 0xe5}},
- {0x0c06, 64, { 0x48, 0x60, 0x09, 0x90, 0x7f, 0xb9, 0xf0, 0xe4, 0xf5, 0x48, 0xd2, 0x01, 0xc2, 0x07, 0xd2, 0xaf, 0x20,
-  0x05, 0x37, 0x30, 0x03, 0x1b, 0x90, 0x7f, 0xc6, 0xe0, 0x20, 0xe1, 0x2d, 0x90, 0x7e, 0x40, 0xe0,
-  0x13, 0x92, 0x15, 0x75, 0x4a, 0x01, 0x90, 0x7f, 0xc7, 0xe0, 0xf5, 0x7c, 0xd2, 0x05, 0x80, 0x19,
-  0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x12, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x15, 0x75}},
- {0x0c46, 64, { 0x4a, 0x01, 0x90, 0x7f, 0xc9, 0xe0, 0xf5, 0x7c, 0xd2, 0x05, 0x20, 0x21, 0x33, 0x20, 0x00, 0x06, 0xe5,
-  0x4a, 0x65, 0x7c, 0x70, 0x2a, 0x30, 0x05, 0x1a, 0x30, 0x03, 0x09, 0xe4, 0x90, 0x7f, 0xc7, 0xf0,
-  0xc2, 0x03, 0x80, 0x07, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x03, 0xc2, 0x05, 0xe4, 0xf5, 0x7c,
-  0xf5, 0x4a, 0x30, 0x15, 0x0a, 0xc2, 0x15, 0xc2, 0x00, 0x90, 0x7f, 0xbf, 0x74, 0x01, 0xf0}},
- {0x0c86, 64, { 0x30, 0x21, 0x03, 0x02, 0x0d, 0x90, 0x20, 0x05, 0x03, 0x02, 0x0d, 0x90, 0x30, 0x1c, 0x0a, 0x90, 0x7f,
-  0x9b, 0xe0, 0x20, 0xe3, 0x03, 0x02, 0x0d, 0x90, 0x30, 0x0b, 0x03, 0x02, 0x0d, 0x90, 0x30, 0x13,
-  0x03, 0x02, 0x0d, 0x90, 0x30, 0x03, 0x62, 0x30, 0x1b, 0x12, 0xaf, 0x4a, 0x05, 0x4a, 0x74, 0x40,
-  0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x2d, 0xaf, 0x4a, 0x05}},
- {0x0cc6, 64, { 0x4a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x13, 0xe5, 0x4a, 0xc3,
-  0x95, 0x7c, 0x50, 0x2a, 0x30, 0x1b, 0x12, 0xaf, 0x4a, 0x05, 0x4a, 0x74, 0x40, 0x2f, 0xf5, 0x82,
-  0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x17, 0xaf, 0x4a, 0x05, 0x4a, 0x74, 0x40, 0x2f,
-  0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x46, 0xd2, 0x11, 0x80, 0x6b, 0xc2}},
- {0x0d06, 64, { 0x11, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0xc2, 0x03, 0x80, 0x60, 0x30, 0x1b, 0x12, 0xaf, 0x4a, 0x05, 0x4a,
-  0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x2d, 0xaf, 0x4a,
-  0x05, 0x4a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x13, 0xe5,
-  0x4a, 0xc3, 0x95, 0x7c, 0x50, 0x2a, 0x30, 0x1b, 0x12, 0xaf, 0x4a, 0x05, 0x4a, 0x74, 0xc0}},
- {0x0d46, 64, { 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x17, 0xaf, 0x4a, 0x05, 0x4a, 0x74,
-  0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x46, 0xd2, 0x11, 0x80, 0x09,
-  0xc2, 0x11, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x03, 0x30, 0x1b, 0x04, 0xa2, 0x2d, 0x92, 0x9b,
-  0xd2, 0x21, 0xc2, 0xaf, 0x85, 0x13, 0x99, 0x20, 0x11, 0x0d, 0x30, 0x15, 0x0a, 0xc2, 0x15}},
- {0x0d86, 64, { 0xc2, 0x00, 0x90, 0x7f, 0xbf, 0x74, 0x01, 0xf0, 0xd2, 0xaf, 0x90, 0x7f, 0xd0, 0xe0, 0x30, 0xe1, 0x03,
-  0x02, 0x0e, 0xad, 0xe4, 0xf5, 0x12, 0x74, 0xc0, 0x25, 0x12, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5,
-  0x83, 0xe0, 0xff, 0xe5, 0x12, 0x7c, 0x00, 0x7b, 0x00, 0x24, 0x64, 0xf9, 0xec, 0x34, 0x00, 0xfa,
-  0xef, 0x12, 0x15, 0xcd, 0x05, 0x12, 0xe5, 0x12, 0xb4, 0x18, 0xdb, 0xe5, 0x64, 0x60, 0x0b}},
- {0x0dc6, 64, { 0x75, 0x89, 0x60, 0x75, 0x88, 0x40, 0xd2, 0xdf, 0x85, 0x65, 0x8d, 0xe5, 0x67, 0x13, 0x92, 0x1d, 0x92,
-  0xc7, 0xe5, 0x68, 0x13, 0x92, 0x1e, 0xe5, 0x69, 0x13, 0x92, 0x24, 0xe5, 0x6a, 0x60, 0x09, 0x90,
-  0x7f, 0x97, 0xe0, 0x54, 0xef, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0x97, 0xe0, 0x44, 0x10, 0xf0, 0xe5,
-  0x6b, 0x60, 0x09, 0x90, 0x7f, 0x97, 0xe0, 0x54, 0x7f, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0x97}},
- {0x0e06, 64, { 0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x71, 0x60, 0x0b, 0xc2, 0x14, 0xc2, 0x0d, 0x90, 0x7f, 0x94, 0xe0, 0x44,
-  0x08, 0xf0, 0xe5, 0x72, 0x60, 0x0b, 0xd2, 0x0d, 0xd2, 0x0e, 0x90, 0x7f, 0x94, 0xe0, 0x44, 0x08,
-  0xf0, 0xe5, 0x73, 0x60, 0x0d, 0xc2, 0xaf, 0xc2, 0x12, 0xd2, 0x00, 0xe4, 0xf5, 0x7d, 0xf5, 0x4b,
-  0xd2, 0xaf, 0xe5, 0x74, 0x60, 0x05, 0x30, 0x24, 0x02, 0xd2, 0x0d, 0xe5, 0x75, 0x60, 0x15}},
- {0x0e46, 64, { 0x90, 0x7f, 0x94, 0xe0, 0x54, 0xf7, 0xf0, 0x90, 0x7f, 0x9d, 0xe0, 0x44, 0x08, 0xf0, 0x90, 0x7f, 0x97,
-  0xe0, 0x54, 0xf7, 0xf0, 0xe5, 0x76, 0x60, 0x0a, 0xd2, 0xc4, 0xc2, 0xc0, 0x75, 0x3a, 0x01, 0x75,
-  0x41, 0x28, 0xe5, 0x77, 0x60, 0x07, 0xc2, 0xc4, 0xe4, 0xf5, 0x49, 0xf5, 0x3a, 0xe5, 0x78, 0x60,
-  0x03, 0xe4, 0xf5, 0x49, 0xe5, 0x79, 0x60, 0x02, 0xd2, 0x08, 0xe5, 0x7a, 0x60, 0x08, 0xe5}},
- {0x0e86, 64, { 0x76, 0x70, 0x02, 0xf5, 0x41, 0xd2, 0x0e, 0xe5, 0x7b, 0x60, 0x15, 0x90, 0x7f, 0xd7, 0x74, 0x13, 0xf0,
-  0x74, 0x33, 0xf0, 0x74, 0x14, 0xf0, 0x74, 0x34, 0xf0, 0x74, 0x16, 0xf0, 0x74, 0x36, 0xf0, 0xd2,
-  0x0a, 0xe4, 0x90, 0x7f, 0xd1, 0xf0, 0xa2, 0x14, 0xe4, 0x33, 0xff, 0x65, 0x37, 0x60, 0x04, 0x8f,
-  0x37, 0xd2, 0x0e, 0xa2, 0x0d, 0xe4, 0x33, 0xff, 0x65, 0x38, 0x60, 0x04, 0x8f, 0x38, 0xd2}},
- {0x0ec6, 64, { 0x0e, 0x90, 0x7f, 0x9a, 0xe0, 0x54, 0x20, 0x65, 0x33, 0x60, 0x07, 0xe0, 0x54, 0x20, 0xf5, 0x33, 0xd2,
-  0x0e, 0x90, 0x7f, 0x9a, 0xe0, 0x54, 0x40, 0xb5, 0x35, 0x09, 0xe0, 0x54, 0x40, 0x64, 0x40, 0xf5,
-  0x35, 0xd2, 0x0e, 0x30, 0x08, 0x35, 0xc2, 0xaf, 0x30, 0x02, 0x18, 0x90, 0x7f, 0xbc, 0xe0, 0x20,
-  0xe1, 0x27, 0xe5, 0x49, 0x60, 0x09, 0x90, 0x7f, 0xbb, 0xf0, 0xe4, 0xf5, 0x49, 0xc2, 0x02}},
- {0x0f06, 64, { 0xc2, 0x08, 0x80, 0x16, 0x90, 0x7f, 0xba, 0xe0, 0x20, 0xe1, 0x0f, 0xe5, 0x49, 0x60, 0x09, 0x90, 0x7f,
-  0xbd, 0xf0, 0xe4, 0xf5, 0x49, 0xd2, 0x02, 0xc2, 0x08, 0xd2, 0xaf, 0x20, 0x06, 0x37, 0x30, 0x04,
-  0x1b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x2d, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x16, 0x75,
-  0x4b, 0x01, 0x90, 0x7f, 0xcb, 0xe0, 0xf5, 0x7d, 0xd2, 0x06, 0x80, 0x19, 0x90, 0x7f, 0xcc}},
- {0x0f46, 64, { 0xe0, 0x20, 0xe1, 0x12, 0x90, 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x16, 0x75, 0x4b, 0x01, 0x90, 0x7f, 0xcd,
-  0xe0, 0xf5, 0x7d, 0xd2, 0x06, 0x20, 0x22, 0x33, 0x20, 0x00, 0x06, 0xe5, 0x4b, 0x65, 0x7d, 0x70,
-  0x2a, 0x30, 0x06, 0x1a, 0x30, 0x04, 0x09, 0xe4, 0x90, 0x7f, 0xcb, 0xf0, 0xc2, 0x04, 0x80, 0x07,
-  0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0xd2, 0x04, 0xc2, 0x06, 0xe4, 0xf5, 0x7d, 0xf5, 0x4b, 0x30}},
- {0x0f86, 64, { 0x16, 0x0a, 0xc2, 0x16, 0xc2, 0x00, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0x30, 0x22, 0x03, 0x02, 0x10,
-  0x9c, 0x20, 0x06, 0x03, 0x02, 0x10, 0x9c, 0x30, 0x1e, 0x0a, 0x90, 0x7f, 0x9a, 0xe0, 0x20, 0xe5,
-  0x03, 0x02, 0x10, 0x9c, 0x30, 0x0d, 0x03, 0x02, 0x10, 0x9c, 0x30, 0x14, 0x03, 0x02, 0x10, 0x9c,
-  0x30, 0x04, 0x62, 0x30, 0x1d, 0x12, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0x40, 0x2f, 0xf5, 0x82}},
- {0x0fc6, 64, { 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x2d, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0x40, 0x2f, 0xf5,
-  0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x13, 0xe5, 0x4b, 0xc3, 0x95, 0x7d, 0x50, 0x2a,
-  0x30, 0x1d, 0x12, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5,
-  0x83, 0xe0, 0x13, 0x92, 0x18, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4}},
- {0x1006, 64, { 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x47, 0xd2, 0x12, 0x80, 0x6b, 0xc2, 0x12, 0xe4, 0x90, 0x7f, 0xcb,
-  0xf0, 0xc2, 0x04, 0x80, 0x60, 0x30, 0x1d, 0x12, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0xc0, 0x2f, 0xf5,
-  0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x2d, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0xc0,
-  0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xf5, 0x13, 0xe5, 0x4b, 0xc3, 0x95}},
- {0x1046, 64, { 0x7d, 0x50, 0x2a, 0x30, 0x1d, 0x12, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34,
-  0x7c, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x18, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0xc0, 0x2f, 0xf5, 0x82,
-  0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xf5, 0x47, 0xd2, 0x12, 0x80, 0x09, 0xc2, 0x12, 0xe4, 0x90,
-  0x7f, 0xcd, 0xf0, 0xd2, 0x04, 0x30, 0x1d, 0x04, 0xa2, 0x2d, 0x92, 0xc3, 0xd2, 0x22, 0xc2}},
- {0x1086, 64, { 0xaf, 0x85, 0x13, 0xc1, 0x20, 0x12, 0x0d, 0x30, 0x16, 0x0a, 0xc2, 0x16, 0xc2, 0x00, 0x90, 0x7f, 0xc1,
-  0x74, 0x01, 0xf0, 0xd2, 0xaf, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x11, 0x72, 0xe5,
-  0x1a, 0x70, 0x46, 0x30, 0x0c, 0x3f, 0xe5, 0x40, 0x70, 0x3b, 0xa2, 0x09, 0x33, 0xf5, 0x31, 0xc2,
-  0x09, 0xc2, 0x0c, 0xe4, 0xf5, 0x12, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x26, 0x25, 0x12, 0xf9}},
- {0x10c6, 64, { 0xee, 0x34, 0x00, 0xfa, 0x12, 0x15, 0x87, 0xff, 0x74, 0x80, 0x25, 0x12, 0xf5, 0x82, 0xe4, 0x34, 0x7b,
-  0xf5, 0x83, 0xef, 0xf0, 0x05, 0x12, 0xe5, 0x12, 0xb4, 0x0c, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x0c,
-  0xf0, 0x75, 0x40, 0x10, 0x22, 0x75, 0x1a, 0x01, 0x22, 0xe5, 0x1a, 0x64, 0x01, 0x70, 0x45, 0x30,
-  0x0e, 0x3e, 0xe5, 0x41, 0x70, 0x3a, 0xa2, 0x0a, 0x33, 0xf5, 0x3d, 0xc2, 0x0a, 0xc2, 0x0e}},
- {0x1106, 64, { 0xe4, 0xf5, 0x12, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x32, 0x25, 0x12, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12,
-  0x15, 0x87, 0xff, 0x74, 0x80, 0x25, 0x12, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0,
-  0x05, 0x12, 0xe5, 0x12, 0xb4, 0x0c, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x0c, 0xf0, 0x75, 0x41, 0x10,
-  0x75, 0x1a, 0x02, 0x22, 0xe5, 0x1c, 0x60, 0x30, 0x15, 0x1c, 0xe4, 0xf5, 0x12, 0x7e, 0x00}},
- {0x1146, 64, { 0x7b, 0x00, 0x74, 0x1b, 0x25, 0x12, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x15, 0x87, 0xff, 0x74, 0x80,
-  0x25, 0x12, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x12, 0xe5, 0x12, 0xb4,
-  0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x1a, 0x22, 0x90, 0x7f, 0xe9, 0xe0,
-  0x12, 0x16, 0x17, 0x12, 0x38, 0x00, 0x12, 0xac, 0x01, 0x13, 0x18, 0x03, 0x11, 0x96, 0x06}},
- {0x1186, 64, { 0x12, 0x2b, 0x08, 0x12, 0x25, 0x09, 0x12, 0x18, 0x0a, 0x13, 0x6e, 0x0b, 0x00, 0x00, 0x13, 0x67, 0x90,
-  0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x16, 0x14, 0x60, 0x40, 0x24, 0x02, 0x70, 0x69, 0x74, 0x19,
-  0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0xea,
-  0xe0, 0xff, 0x12, 0x17, 0x4b, 0x8b, 0x12, 0x8a, 0x13, 0x89, 0x14, 0xea, 0x49, 0x60, 0x11}},
- {0x11c6, 64, { 0xae, 0x02, 0xee, 0x90, 0x7f, 0xd4, 0xf0, 0xaf, 0x01, 0xef, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x13, 0x6e,
-  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12,
-  0x17, 0x9a, 0x8b, 0x12, 0x8a, 0x13, 0x89, 0x14, 0xea, 0x49, 0x60, 0x11, 0xae, 0x02, 0xee, 0x90,
-  0x7f, 0xd4, 0xf0, 0xaf, 0x01, 0xef, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x13, 0x6e, 0x90, 0x7f}},
- {0x1206, 64, { 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x13,
-  0x6e, 0x90, 0x7f, 0x00, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02, 0x13, 0x6e, 0x12, 0x14,
-  0xbb, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0x00, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02, 0x13,
-  0x6e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70}},
- {0x1246, 64, { 0x5b, 0xa2, 0x26, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff, 0xa2, 0x2b, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00,
-  0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x13, 0x6e, 0xe4, 0x90, 0x7f,
-  0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0xec,
-  0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0}},
- {0x1286, 64, { 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4,
-  0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
-  0x01, 0xf0, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02, 0x60,
-  0x03, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x05, 0xc2, 0x26, 0x02, 0x13}},
- {0x12c6, 64, { 0x6e, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x13, 0x6e, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38,
-  0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f,
-  0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec,
-  0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90}},
- {0x1306, 64, { 0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80,
-  0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea,
-  0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x26, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80,
-  0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff}},
- {0x1346, 64, { 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f,
-  0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07,
-  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0x20,
-  0x28, 0x03, 0x02, 0x14, 0xba, 0xe5, 0x40, 0x60, 0x02, 0x15, 0x40, 0xe5, 0x48, 0x60, 0x4f}},
- {0x1386, 64, { 0x65, 0x44, 0x70, 0x45, 0xe5, 0x42, 0xf4, 0x60, 0x02, 0x05, 0x42, 0xe5, 0x42, 0xc3, 0x95, 0x55, 0x40,
-  0x3d, 0xc2, 0xaf, 0x30, 0x01, 0x18, 0x90, 0x7f, 0xb8, 0xe0, 0x20, 0xe1, 0x27, 0x90, 0x7f, 0xb7,
-  0xe5, 0x48, 0xf0, 0xc2, 0x01, 0xe4, 0xf5, 0x48, 0xf5, 0x42, 0xf5, 0x44, 0x80, 0x16, 0x90, 0x7f,
-  0xb6, 0xe0, 0x20, 0xe1, 0x0f, 0x90, 0x7f, 0xb9, 0xe5, 0x48, 0xf0, 0xd2, 0x01, 0xe4, 0xf5}},
- {0x13c6, 64, { 0x48, 0xf5, 0x42, 0xf5, 0x44, 0xd2, 0xaf, 0x80, 0x06, 0x85, 0x48, 0x44, 0xe4, 0xf5, 0x42, 0xe5, 0x2e,
-  0x60, 0x2d, 0x20, 0x19, 0x07, 0x90, 0x7f, 0x9b, 0xe0, 0x30, 0xe0, 0x0e, 0xe5, 0x2f, 0x60, 0x05,
-  0xe4, 0xf5, 0x2f, 0xd2, 0x0c, 0xe4, 0xf5, 0x3e, 0x80, 0x13, 0xe5, 0x3e, 0xd3, 0x95, 0x56, 0x50,
-  0x0c, 0xe5, 0x3e, 0xb5, 0x56, 0x05, 0x75, 0x2f, 0x01, 0xd2, 0x0c, 0x05, 0x3e, 0xc2, 0x19}},
- {0x1406, 64, { 0xe5, 0x41, 0x60, 0x02, 0x15, 0x41, 0xe5, 0x49, 0x60, 0x4f, 0x65, 0x45, 0x70, 0x45, 0xe5, 0x43, 0xf4,
-  0x60, 0x02, 0x05, 0x43, 0xe5, 0x43, 0xc3, 0x95, 0x6d, 0x40, 0x3d, 0xc2, 0xaf, 0x30, 0x02, 0x18,
-  0x90, 0x7f, 0xbc, 0xe0, 0x20, 0xe1, 0x27, 0x90, 0x7f, 0xbb, 0xe5, 0x49, 0xf0, 0xc2, 0x02, 0xe4,
-  0xf5, 0x49, 0xf5, 0x43, 0xf5, 0x45, 0x80, 0x16, 0x90, 0x7f, 0xba, 0xe0, 0x20, 0xe1, 0x0f}},
- {0x1446, 64, { 0x90, 0x7f, 0xbd, 0xe5, 0x49, 0xf0, 0xd2, 0x02, 0xe4, 0xf5, 0x49, 0xf5, 0x43, 0xf5, 0x45, 0xd2, 0xaf,
-  0x80, 0x06, 0x85, 0x49, 0x45, 0xe4, 0xf5, 0x43, 0xe5, 0x3a, 0x60, 0x2d, 0x20, 0x1a, 0x07, 0x90,
-  0x7f, 0x9a, 0xe0, 0x30, 0xe2, 0x0e, 0xe5, 0x3b, 0x60, 0x05, 0xe4, 0xf5, 0x3b, 0xd2, 0x0e, 0xe4,
-  0xf5, 0x3f, 0x80, 0x13, 0xe5, 0x3f, 0xd3, 0x95, 0x6e, 0x50, 0x0c, 0xe5, 0x3f, 0xb5, 0x6e}},
- {0x1486, 64, { 0x05, 0x75, 0x3b, 0x01, 0xd2, 0x0e, 0x05, 0x3f, 0xc2, 0x1a, 0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23,
-  0x90, 0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5, 0x1c, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x1d, 0x90,
-  0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90,
-  0x7f, 0xd3, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0}},
- {0x14c6, 64, { 0x90, 0x7f, 0x96, 0xe0, 0x44, 0x10, 0xf0, 0x90, 0x7f, 0x94, 0x74, 0x0d, 0xf0, 0x90, 0x7f, 0x9d, 0x74,
-  0x9a, 0xf0, 0x90, 0x7f, 0x97, 0xe0, 0x54, 0xfd, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0x23, 0xf0, 0x90,
-  0x7f, 0x9e, 0x74, 0x84, 0xf0, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0x90, 0x7f, 0xc9, 0xf0, 0x90, 0x7f,
-  0xcf, 0xf0, 0x75, 0x98, 0x40, 0x43, 0xa8, 0x10, 0xc2, 0x1b, 0xc2, 0x05, 0xc2, 0x21, 0xc2}},
- {0x1506, 64, { 0x0b, 0xc2, 0x13, 0xf5, 0x7c, 0xf5, 0x4a, 0xc2, 0x11, 0xc2, 0x15, 0xf5, 0x42, 0xc2, 0x19, 0xf5, 0x44,
-  0xf5, 0x48, 0xc2, 0x23, 0xc2, 0x1c, 0xf5, 0x2d, 0xf5, 0x2f, 0xc2, 0x07, 0xc2, 0x00, 0xc2, 0x1f,
-  0xf5, 0x3e, 0xc2, 0x09, 0xd2, 0x01, 0xd2, 0x03, 0xd2, 0x0c, 0xf5, 0x26, 0x90, 0x7f, 0xcb, 0xf0,
-  0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xd1, 0xf0, 0x75, 0xc0, 0x40, 0x43, 0xa8, 0x40, 0xc2}},
- {0x1546, 64, { 0x1d, 0xc2, 0x06, 0xc2, 0x22, 0xc2, 0x0d, 0xc2, 0x14, 0xf5, 0x7d, 0xf5, 0x4b, 0xc2, 0x12, 0xc2, 0x16,
-  0xf5, 0x43, 0xc2, 0x1a, 0xf5, 0x45, 0xf5, 0x49, 0xc2, 0x24, 0xc2, 0x1e, 0xf5, 0x39, 0xf5, 0x3b,
-  0xc2, 0x08, 0xc2, 0x00, 0xc2, 0x20, 0xf5, 0x3f, 0xc2, 0x0a, 0xd2, 0x02, 0xd2, 0x04, 0xd2, 0x0e,
+  0x74, 0x35, 0xf0, 0xd2, 0x03, 0xd2, 0x01, 0xd2, 0x09, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0xa2, 0x13,
+  0xe4, 0x33, 0xff, 0x65, 0x2b, 0x60, 0x04, 0x8f, 0x2b, 0xd2, 0x0c, 0xa2, 0x0b, 0xe4, 0x33, 0xff,
+  0x65, 0x2c, 0x60, 0x04, 0x8f, 0x2c, 0xd2, 0x0c, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x08, 0x65}},
+ {0x0bc6, 64, { 0x27, 0x60, 0x07, 0xe0, 0x54, 0x08, 0xf5, 0x27, 0xd2, 0x0c, 0x90, 0x7f, 0x9b, 0xe0, 0x54, 0x40, 0xb5,
+  0x29, 0x09, 0xe0, 0x54, 0x40, 0x64, 0x40, 0xf5, 0x29, 0xd2, 0x0c, 0x30, 0x07, 0x35, 0xc2, 0xaf,
+  0x30, 0x01, 0x18, 0x90, 0x7f, 0xb8, 0xe0, 0x20, 0xe1, 0x27, 0xe5, 0x48, 0x60, 0x09, 0x90, 0x7f,
+  0xb7, 0xf0, 0xe4, 0xf5, 0x48, 0xc2, 0x01, 0xc2, 0x07, 0x80, 0x16, 0x90, 0x7f, 0xb6, 0xe0}},
+ {0x0c06, 64, { 0x20, 0xe1, 0x0f, 0xe5, 0x48, 0x60, 0x09, 0x90, 0x7f, 0xb9, 0xf0, 0xe4, 0xf5, 0x48, 0xd2, 0x01, 0xc2,
+  0x07, 0xd2, 0xaf, 0x20, 0x05, 0x37, 0x30, 0x03, 0x1b, 0x90, 0x7f, 0xc6, 0xe0, 0x20, 0xe1, 0x2d,
+  0x90, 0x7e, 0x40, 0xe0, 0x13, 0x92, 0x15, 0x75, 0x4a, 0x01, 0x90, 0x7f, 0xc7, 0xe0, 0xf5, 0x7c,
+  0xd2, 0x05, 0x80, 0x19, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x12, 0x90, 0x7d, 0xc0, 0xe0}},
+ {0x0c46, 64, { 0x13, 0x92, 0x15, 0x75, 0x4a, 0x01, 0x90, 0x7f, 0xc9, 0xe0, 0xf5, 0x7c, 0xd2, 0x05, 0x20, 0x21, 0x33,
+  0x20, 0x00, 0x06, 0xe5, 0x4a, 0x65, 0x7c, 0x70, 0x2a, 0x30, 0x05, 0x1a, 0x30, 0x03, 0x09, 0xe4,
+  0x90, 0x7f, 0xc7, 0xf0, 0xc2, 0x03, 0x80, 0x07, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x03, 0xc2,
+  0x05, 0xe4, 0xf5, 0x7c, 0xf5, 0x4a, 0x30, 0x15, 0x0a, 0xc2, 0x15, 0xc2, 0x00, 0x90, 0x7f}},
+ {0x0c86, 64, { 0xbf, 0x74, 0x01, 0xf0, 0x30, 0x21, 0x03, 0x02, 0x0d, 0x94, 0x20, 0x05, 0x03, 0x02, 0x0d, 0x94, 0x30,
+  0x1c, 0x0a, 0x90, 0x7f, 0x9b, 0xe0, 0x20, 0xe3, 0x03, 0x02, 0x0d, 0x94, 0x30, 0x0b, 0x03, 0x02,
+  0x0d, 0x94, 0x30, 0x13, 0x03, 0x02, 0x0d, 0x94, 0x30, 0x03, 0x62, 0x30, 0x1b, 0x12, 0xaf, 0x4a,
+  0x05, 0x4a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92}},
+ {0x0cc6, 64, { 0x2d, 0xaf, 0x4a, 0x05, 0x4a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5,
+  0x13, 0xe5, 0x4a, 0xc3, 0x95, 0x7c, 0x50, 0x2a, 0x30, 0x1b, 0x12, 0xaf, 0x4a, 0x05, 0x4a, 0x74,
+  0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x17, 0xaf, 0x4a, 0x05,
+  0x4a, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7e, 0xf5, 0x83, 0xe0, 0xf5, 0x46, 0xd2}},
+ {0x0d06, 64, { 0x11, 0x80, 0x6b, 0xc2, 0x11, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0xc2, 0x03, 0x80, 0x60, 0x30, 0x1b, 0x12,
+  0xaf, 0x4a, 0x05, 0x4a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13,
+  0x92, 0x2d, 0xaf, 0x4a, 0x05, 0x4a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83,
+  0xe0, 0xf5, 0x13, 0xe5, 0x4a, 0xc3, 0x95, 0x7c, 0x50, 0x2a, 0x30, 0x1b, 0x12, 0xaf, 0x4a}},
+ {0x0d46, 64, { 0x05, 0x4a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x17, 0xaf,
+  0x4a, 0x05, 0x4a, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x46,
+  0xd2, 0x11, 0x80, 0x09, 0xc2, 0x11, 0xe4, 0x90, 0x7f, 0xc9, 0xf0, 0xd2, 0x03, 0x30, 0x1b, 0x04,
+  0xa2, 0x2d, 0x92, 0x9b, 0xd2, 0x21, 0xc2, 0xaf, 0x85, 0x13, 0x99, 0x20, 0x11, 0x0d, 0x30}},
+ {0x0d86, 64, { 0x15, 0x0a, 0xc2, 0x15, 0xc2, 0x00, 0x90, 0x7f, 0xbf, 0x74, 0x01, 0xf0, 0xd2, 0xaf, 0x90, 0x7f, 0xd0,
+  0xe0, 0x30, 0xe1, 0x03, 0x02, 0x0e, 0xb5, 0xe4, 0xf5, 0x12, 0x74, 0xc0, 0x25, 0x12, 0xf5, 0x82,
+  0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x12, 0x7c, 0x00, 0x7b, 0x00, 0x24, 0x64, 0xf9,
+  0xec, 0x34, 0x00, 0xfa, 0xef, 0x12, 0x15, 0xcd, 0x05, 0x12, 0xe5, 0x12, 0xb4, 0x18, 0xdb}},
+ {0x0dc6, 64, { 0xe5, 0x64, 0x60, 0x0b, 0x75, 0x89, 0x60, 0x75, 0x88, 0x40, 0xd2, 0xdf, 0x85, 0x65, 0x8d, 0xe5, 0x67,
+  0x13, 0x92, 0x1d, 0x92, 0xc7, 0xe5, 0x68, 0x13, 0x92, 0x1e, 0xe5, 0x69, 0x13, 0x92, 0x24, 0xe5,
+  0x6a, 0x60, 0x09, 0x90, 0x7f, 0x97, 0xe0, 0x54, 0xef, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0x97, 0xe0,
+  0x44, 0x10, 0xf0, 0xe5, 0x6b, 0x60, 0x09, 0x90, 0x7f, 0x97, 0xe0, 0x54, 0x7f, 0xf0, 0x80}},
+ {0x0e06, 64, { 0x07, 0x90, 0x7f, 0x97, 0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x71, 0x60, 0x0b, 0xc2, 0x14, 0xc2, 0x0d, 0x90,
+  0x7f, 0x94, 0xe0, 0x44, 0x08, 0xf0, 0xe5, 0x72, 0x60, 0x0b, 0xd2, 0x0d, 0xd2, 0x0e, 0x90, 0x7f,
+  0x94, 0xe0, 0x44, 0x08, 0xf0, 0xe5, 0x73, 0x60, 0x0d, 0xc2, 0xaf, 0xc2, 0x12, 0xd2, 0x00, 0xe4,
+  0xf5, 0x7d, 0xf5, 0x4b, 0xd2, 0xaf, 0xe5, 0x74, 0x60, 0x05, 0x30, 0x24, 0x02, 0xd2, 0x0d}},
+ {0x0e46, 64, { 0xe5, 0x75, 0x60, 0x15, 0x90, 0x7f, 0x94, 0xe0, 0x54, 0xf7, 0xf0, 0x90, 0x7f, 0x9d, 0xe0, 0x44, 0x08,
+  0xf0, 0x90, 0x7f, 0x97, 0xe0, 0x54, 0xf7, 0xf0, 0xe5, 0x76, 0x60, 0x0a, 0xd2, 0xc4, 0xc2, 0xc0,
+  0x75, 0x3a, 0x01, 0x75, 0x41, 0x28, 0xe5, 0x77, 0x60, 0x07, 0xc2, 0xc4, 0xe4, 0xf5, 0x49, 0xf5,
+  0x3a, 0xe5, 0x78, 0x60, 0x03, 0xe4, 0xf5, 0x49, 0xe5, 0x79, 0x60, 0x02, 0xd2, 0x08, 0xe5}},
+ {0x0e86, 64, { 0x7a, 0x60, 0x08, 0xe5, 0x76, 0x70, 0x02, 0xf5, 0x41, 0xd2, 0x0e, 0xe5, 0x7b, 0x60, 0x19, 0x90, 0x7f,
+  0xd7, 0x74, 0x13, 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x14, 0xf0, 0x74, 0x34, 0xf0, 0x74, 0x16, 0xf0,
+  0x74, 0x36, 0xf0, 0xd2, 0x04, 0xd2, 0x02, 0xd2, 0x0a, 0xe4, 0x90, 0x7f, 0xd1, 0xf0, 0xa2, 0x14,
+  0xe4, 0x33, 0xff, 0x65, 0x37, 0x60, 0x04, 0x8f, 0x37, 0xd2, 0x0e, 0xa2, 0x0d, 0xe4, 0x33}},
+ {0x0ec6, 64, { 0xff, 0x65, 0x38, 0x60, 0x04, 0x8f, 0x38, 0xd2, 0x0e, 0x90, 0x7f, 0x9a, 0xe0, 0x54, 0x20, 0x65, 0x33,
+  0x60, 0x07, 0xe0, 0x54, 0x20, 0xf5, 0x33, 0xd2, 0x0e, 0x90, 0x7f, 0x9a, 0xe0, 0x54, 0x40, 0xb5,
+  0x35, 0x09, 0xe0, 0x54, 0x40, 0x64, 0x40, 0xf5, 0x35, 0xd2, 0x0e, 0x30, 0x08, 0x35, 0xc2, 0xaf,
+  0x30, 0x02, 0x18, 0x90, 0x7f, 0xbc, 0xe0, 0x20, 0xe1, 0x27, 0xe5, 0x49, 0x60, 0x09, 0x90}},
+ {0x0f06, 64, { 0x7f, 0xbb, 0xf0, 0xe4, 0xf5, 0x49, 0xc2, 0x02, 0xc2, 0x08, 0x80, 0x16, 0x90, 0x7f, 0xba, 0xe0, 0x20,
+  0xe1, 0x0f, 0xe5, 0x49, 0x60, 0x09, 0x90, 0x7f, 0xbd, 0xf0, 0xe4, 0xf5, 0x49, 0xd2, 0x02, 0xc2,
+  0x08, 0xd2, 0xaf, 0x20, 0x06, 0x37, 0x30, 0x04, 0x1b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x2d,
+  0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x16, 0x75, 0x4b, 0x01, 0x90, 0x7f, 0xcb, 0xe0, 0xf5}},
+ {0x0f46, 64, { 0x7d, 0xd2, 0x06, 0x80, 0x19, 0x90, 0x7f, 0xcc, 0xe0, 0x20, 0xe1, 0x12, 0x90, 0x7c, 0xc0, 0xe0, 0x13,
+  0x92, 0x16, 0x75, 0x4b, 0x01, 0x90, 0x7f, 0xcd, 0xe0, 0xf5, 0x7d, 0xd2, 0x06, 0x20, 0x22, 0x33,
+  0x20, 0x00, 0x06, 0xe5, 0x4b, 0x65, 0x7d, 0x70, 0x2a, 0x30, 0x06, 0x1a, 0x30, 0x04, 0x09, 0xe4,
+  0x90, 0x7f, 0xcb, 0xf0, 0xc2, 0x04, 0x80, 0x07, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0xd2, 0x04}},
+ {0x0f86, 64, { 0xc2, 0x06, 0xe4, 0xf5, 0x7d, 0xf5, 0x4b, 0x30, 0x16, 0x0a, 0xc2, 0x16, 0xc2, 0x00, 0x90, 0x7f, 0xc1,
+  0x74, 0x01, 0xf0, 0x30, 0x22, 0x03, 0x02, 0x10, 0xa4, 0x20, 0x06, 0x03, 0x02, 0x10, 0xa4, 0x30,
+  0x1e, 0x0a, 0x90, 0x7f, 0x9a, 0xe0, 0x20, 0xe5, 0x03, 0x02, 0x10, 0xa4, 0x30, 0x0d, 0x03, 0x02,
+  0x10, 0xa4, 0x30, 0x14, 0x03, 0x02, 0x10, 0xa4, 0x30, 0x04, 0x62, 0x30, 0x1d, 0x12, 0xaf}},
+ {0x0fc6, 64, { 0x4b, 0x05, 0x4b, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x2d,
+  0xaf, 0x4b, 0x05, 0x4b, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5,
+  0x13, 0xe5, 0x4b, 0xc3, 0x95, 0x7d, 0x50, 0x2a, 0x30, 0x1d, 0x12, 0xaf, 0x4b, 0x05, 0x4b, 0x74,
+  0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x18, 0xaf, 0x4b}},
+ {0x1006, 64, { 0x05, 0x4b, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7d, 0xf5, 0x83, 0xe0, 0xf5, 0x47, 0xd2, 0x12,
+  0x80, 0x6b, 0xc2, 0x12, 0xe4, 0x90, 0x7f, 0xcb, 0xf0, 0xc2, 0x04, 0x80, 0x60, 0x30, 0x1d, 0x12,
+  0xaf, 0x4b, 0x05, 0x4b, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0x13,
+  0x92, 0x2d, 0xaf, 0x4b, 0x05, 0x4b, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5}},
+ {0x1046, 64, { 0x83, 0xe0, 0xf5, 0x13, 0xe5, 0x4b, 0xc3, 0x95, 0x7d, 0x50, 0x2a, 0x30, 0x1d, 0x12, 0xaf, 0x4b, 0x05,
+  0x4b, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0x13, 0x92, 0x18, 0xaf,
+  0x4b, 0x05, 0x4b, 0x74, 0xc0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xf5, 0x47,
+  0xd2, 0x12, 0x80, 0x09, 0xc2, 0x12, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0xd2, 0x04, 0x30, 0x1d}},
+ {0x1086, 64, { 0x04, 0xa2, 0x2d, 0x92, 0xc3, 0xd2, 0x22, 0xc2, 0xaf, 0x85, 0x13, 0xc1, 0x20, 0x12, 0x0d, 0x30, 0x16,
+  0x0a, 0xc2, 0x16, 0xc2, 0x00, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0xd2, 0xaf, 0x90, 0x7f, 0xc2,
+  0xe0, 0x30, 0xe1, 0x03, 0x02, 0x11, 0x7a, 0xe5, 0x1a, 0x70, 0x46, 0x30, 0x0c, 0x3f, 0xe5, 0x40,
+  0x70, 0x3b, 0xa2, 0x09, 0x33, 0xf5, 0x31, 0xc2, 0x09, 0xc2, 0x0c, 0xe4, 0xf5, 0x12, 0x7e}},
+ {0x10c6, 64, { 0x00, 0x7b, 0x00, 0x74, 0x26, 0x25, 0x12, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x15, 0x87, 0xff, 0x74,
+  0x80, 0x25, 0x12, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x12, 0xe5, 0x12,
+  0xb4, 0x0c, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x0c, 0xf0, 0x75, 0x40, 0x10, 0x22, 0x75, 0x1a, 0x01,
+  0x22, 0xe5, 0x1a, 0x64, 0x01, 0x70, 0x45, 0x30, 0x0e, 0x3e, 0xe5, 0x41, 0x70, 0x3a, 0xa2}},
+ {0x1106, 64, { 0x0a, 0x33, 0xf5, 0x3d, 0xc2, 0x0a, 0xc2, 0x0e, 0xe4, 0xf5, 0x12, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x32,
+  0x25, 0x12, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x15, 0x87, 0xff, 0x74, 0x80, 0x25, 0x12, 0xf5,
+  0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x12, 0xe5, 0x12, 0xb4, 0x0c, 0xdb, 0x90,
+  0x7f, 0xc3, 0x74, 0x0c, 0xf0, 0x75, 0x41, 0x10, 0x75, 0x1a, 0x02, 0x22, 0xe5, 0x1c, 0x60}},
+ {0x1146, 64, { 0x30, 0x15, 0x1c, 0xe4, 0xf5, 0x12, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x1b, 0x25, 0x12, 0xf9, 0xee, 0x34,
+  0x00, 0xfa, 0x12, 0x15, 0x87, 0xff, 0x74, 0x80, 0x25, 0x12, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5,
+  0x83, 0xef, 0xf0, 0x05, 0x12, 0xe5, 0x12, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0,
+  0xe4, 0xf5, 0x1a, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x16, 0x17, 0x12, 0x40, 0x00, 0x12}},
+ {0x1186, 64, { 0xb4, 0x01, 0x13, 0x20, 0x03, 0x11, 0x9e, 0x06, 0x12, 0x33, 0x08, 0x12, 0x2d, 0x09, 0x12, 0x20, 0x0a,
+  0x13, 0x76, 0x0b, 0x00, 0x00, 0x13, 0x6f, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x16, 0x14,
+  0x60, 0x40, 0x24, 0x02, 0x70, 0x69, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90, 0x7f,
+  0xd5, 0xf0, 0x02, 0x13, 0x76, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x17, 0x4b, 0x8b, 0x12}},
+ {0x11c6, 64, { 0x8a, 0x13, 0x89, 0x14, 0xea, 0x49, 0x60, 0x11, 0xae, 0x02, 0xee, 0x90, 0x7f, 0xd4, 0xf0, 0xaf, 0x01,
+  0xef, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x13, 0x76, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02,
+  0x13, 0x76, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x17, 0x9a, 0x8b, 0x12, 0x8a, 0x13, 0x89, 0x14,
+  0xea, 0x49, 0x60, 0x11, 0xae, 0x02, 0xee, 0x90, 0x7f, 0xd4, 0xf0, 0xaf, 0x01, 0xef, 0x90}},
+ {0x1206, 64, { 0x7f, 0xd5, 0xf0, 0x02, 0x13, 0x76, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x13, 0x76, 0x90,
+  0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x13, 0x76, 0x90, 0x7f, 0x00, 0x74, 0x01, 0xf0, 0x90,
+  0x7f, 0xb5, 0xf0, 0x02, 0x13, 0x76, 0x12, 0x14, 0xc3, 0x02, 0x13, 0x76, 0x90, 0x7f, 0x00, 0x74,
+  0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02, 0x13, 0x76, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f}},
+ {0x1246, 64, { 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b, 0xa2, 0x26, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff,
+  0xa2, 0x2b, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74,
+  0x02, 0xf0, 0x02, 0x13, 0x76, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74,
+  0x02, 0xf0, 0x02, 0x13, 0x76, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54}},
+ {0x1286, 64, { 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83,
+  0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0,
+  0x02, 0x13, 0x76, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x13, 0x76, 0x90, 0x7f, 0xe8,
+  0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02, 0x60, 0x03, 0x02, 0x13, 0x76, 0x90, 0x7f, 0xea}},
+ {0x12c6, 64, { 0xe0, 0xb4, 0x01, 0x05, 0xc2, 0x26, 0x02, 0x13, 0x76, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02,
+  0x13, 0x76, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff,
+  0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34,
+  0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13}},
+ {0x1306, 64, { 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60,
+  0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x26, 0x80, 0x3f,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20}},
+ {0x1346, 64, { 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25,
+  0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90,
+  0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90,
+  0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0x20, 0x28, 0x03, 0x02, 0x14, 0xc2, 0xe5, 0x40}},
+ {0x1386, 64, { 0x60, 0x02, 0x15, 0x40, 0xe5, 0x48, 0x60, 0x4f, 0x65, 0x44, 0x70, 0x45, 0xe5, 0x42, 0xf4, 0x60, 0x02,
+  0x05, 0x42, 0xe5, 0x42, 0xc3, 0x95, 0x55, 0x40, 0x3d, 0xc2, 0xaf, 0x30, 0x01, 0x18, 0x90, 0x7f,
+  0xb8, 0xe0, 0x20, 0xe1, 0x27, 0x90, 0x7f, 0xb7, 0xe5, 0x48, 0xf0, 0xc2, 0x01, 0xe4, 0xf5, 0x48,
+  0xf5, 0x42, 0xf5, 0x44, 0x80, 0x16, 0x90, 0x7f, 0xb6, 0xe0, 0x20, 0xe1, 0x0f, 0x90, 0x7f}},
+ {0x13c6, 64, { 0xb9, 0xe5, 0x48, 0xf0, 0xd2, 0x01, 0xe4, 0xf5, 0x48, 0xf5, 0x42, 0xf5, 0x44, 0xd2, 0xaf, 0x80, 0x06,
+  0x85, 0x48, 0x44, 0xe4, 0xf5, 0x42, 0xe5, 0x2e, 0x60, 0x2d, 0x20, 0x19, 0x07, 0x90, 0x7f, 0x9b,
+  0xe0, 0x30, 0xe0, 0x0e, 0xe5, 0x2f, 0x60, 0x05, 0xe4, 0xf5, 0x2f, 0xd2, 0x0c, 0xe4, 0xf5, 0x3e,
+  0x80, 0x13, 0xe5, 0x3e, 0xd3, 0x95, 0x56, 0x50, 0x0c, 0xe5, 0x3e, 0xb5, 0x56, 0x05, 0x75}},
+ {0x1406, 64, { 0x2f, 0x01, 0xd2, 0x0c, 0x05, 0x3e, 0xc2, 0x19, 0xe5, 0x41, 0x60, 0x02, 0x15, 0x41, 0xe5, 0x49, 0x60,
+  0x4f, 0x65, 0x45, 0x70, 0x45, 0xe5, 0x43, 0xf4, 0x60, 0x02, 0x05, 0x43, 0xe5, 0x43, 0xc3, 0x95,
+  0x6d, 0x40, 0x3d, 0xc2, 0xaf, 0x30, 0x02, 0x18, 0x90, 0x7f, 0xbc, 0xe0, 0x20, 0xe1, 0x27, 0x90,
+  0x7f, 0xbb, 0xe5, 0x49, 0xf0, 0xc2, 0x02, 0xe4, 0xf5, 0x49, 0xf5, 0x43, 0xf5, 0x45, 0x80}},
+ {0x1446, 64, { 0x16, 0x90, 0x7f, 0xba, 0xe0, 0x20, 0xe1, 0x0f, 0x90, 0x7f, 0xbd, 0xe5, 0x49, 0xf0, 0xd2, 0x02, 0xe4,
+  0xf5, 0x49, 0xf5, 0x43, 0xf5, 0x45, 0xd2, 0xaf, 0x80, 0x06, 0x85, 0x49, 0x45, 0xe4, 0xf5, 0x43,
+  0xe5, 0x3a, 0x60, 0x2d, 0x20, 0x1a, 0x07, 0x90, 0x7f, 0x9a, 0xe0, 0x30, 0xe2, 0x0e, 0xe5, 0x3b,
+  0x60, 0x05, 0xe4, 0xf5, 0x3b, 0xd2, 0x0e, 0xe4, 0xf5, 0x3f, 0x80, 0x13, 0xe5, 0x3f, 0xd3}},
+ {0x1486, 64, { 0x95, 0x6e, 0x50, 0x0c, 0xe5, 0x3f, 0xb5, 0x6e, 0x05, 0x75, 0x3b, 0x01, 0xd2, 0x0e, 0x05, 0x3f, 0xc2,
+  0x1a, 0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90, 0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5,
+  0x1c, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x1d, 0x90, 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7,
+  0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f, 0xd3, 0xf0, 0x22, 0xe4, 0x90, 0x7f}},
+ {0x14c6, 64, { 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0x90, 0x7f, 0x96, 0xe0, 0x44, 0x10, 0xf0, 0x90, 0x7f,
+  0x94, 0x74, 0x0d, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0x9a, 0xf0, 0x90, 0x7f, 0x97, 0xe0, 0x54, 0xfd,
+  0xf0, 0x90, 0x7f, 0x95, 0x74, 0x23, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x84, 0xf0, 0xe4, 0x90, 0x7f,
+  0xc7, 0xf0, 0x90, 0x7f, 0xc9, 0xf0, 0x90, 0x7f, 0xcf, 0xf0, 0x75, 0x98, 0x40, 0x43, 0xa8}},
+ {0x1506, 64, { 0x10, 0xc2, 0x1b, 0xc2, 0x05, 0xc2, 0x21, 0xc2, 0x0b, 0xc2, 0x13, 0xf5, 0x7c, 0xf5, 0x4a, 0xc2, 0x11,
+  0xc2, 0x15, 0xf5, 0x42, 0xc2, 0x19, 0xf5, 0x44, 0xf5, 0x48, 0xc2, 0x23, 0xc2, 0x1c, 0xf5, 0x2d,
+  0xf5, 0x2f, 0xc2, 0x07, 0xc2, 0x00, 0xc2, 0x1f, 0xf5, 0x3e, 0xc2, 0x09, 0xd2, 0x0c, 0xf5, 0x26,
+  0x90, 0x7f, 0xcb, 0xf0, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xd1, 0xf0, 0x75, 0xc0, 0x40}},
+ {0x1546, 64, { 0x43, 0xa8, 0x40, 0xc2, 0x1d, 0xc2, 0x06, 0xc2, 0x22, 0xc2, 0x0d, 0xc2, 0x14, 0xf5, 0x7d, 0xf5, 0x4b,
+  0xc2, 0x12, 0xc2, 0x16, 0xf5, 0x43, 0xc2, 0x1a, 0xf5, 0x45, 0xf5, 0x49, 0xc2, 0x24, 0xc2, 0x1e,
+  0xf5, 0x39, 0xf5, 0x3b, 0xc2, 0x08, 0xc2, 0x00, 0xc2, 0x20, 0xf5, 0x3f, 0xc2, 0x0a, 0xd2, 0x0e,
   0x75, 0x32, 0x01, 0x90, 0x7f, 0xdf, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xd2, 0x28}},
  {0x1586, 64, { 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02,
   0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c, 0xe5, 0x82, 0x29, 0xf5,
@@ -384,7 +389,7 @@
   0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8,
   0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46,
   0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18}},
- {0x1686, 64, { 0xcc, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe,
+ {0x1686, 64, { 0xc5, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe,
   0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4,
   0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5,
   0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde}},
@@ -393,9 +398,9 @@
   0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0, 0x90,
   0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xaf, 0xe0, 0x44}},
  {0x1706, 64, { 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2, 0xbc, 0xd2, 0xbe, 0xd2, 0x2d,
-  0x12, 0x18, 0x86, 0xc2, 0x27, 0xc2, 0x25, 0xc2, 0x28, 0x30, 0x28, 0x03, 0x12, 0x0a, 0x83, 0x90,
-  0x7f, 0xd8, 0xe0, 0x65, 0x10, 0x60, 0x08, 0xe0, 0xf5, 0x10, 0x12, 0x13, 0x76, 0x80, 0xea, 0x30,
-  0x27, 0x07, 0xc2, 0x27, 0x12, 0x11, 0x73, 0x80, 0xe0, 0x30, 0x2c, 0xdd, 0xc2, 0x2c, 0x12}},
+  0x12, 0x18, 0x7f, 0xc2, 0x27, 0xc2, 0x25, 0xc2, 0x28, 0x30, 0x28, 0x03, 0x12, 0x0a, 0x83, 0x90,
+  0x7f, 0xd8, 0xe0, 0x65, 0x10, 0x60, 0x08, 0xe0, 0xf5, 0x10, 0x12, 0x13, 0x7e, 0x80, 0xea, 0x30,
+  0x27, 0x07, 0xc2, 0x27, 0x12, 0x11, 0x7b, 0x80, 0xe0, 0x30, 0x2c, 0xdd, 0xc2, 0x2c, 0x12}},
  {0x1746, 64, { 0x00, 0x26, 0x80, 0xd6, 0x22, 0xe4, 0xfe, 0x75, 0x17, 0xff, 0x75, 0x18, 0x19, 0x75, 0x19, 0x12, 0xab,
   0x17, 0xaa, 0x18, 0xa9, 0x19, 0x90, 0x00, 0x01, 0x12, 0x15, 0xa0, 0x64, 0x02, 0x70, 0x2d, 0xad,
   0x06, 0x0e, 0xed, 0xb5, 0x07, 0x01, 0x22, 0x90, 0x00, 0x02, 0x12, 0x15, 0xdf, 0x85, 0xf0, 0x15,
@@ -405,33 +410,33 @@
   0x86, 0xab, 0x17, 0xaa, 0x18, 0xa9, 0x19, 0x90, 0x00, 0x01, 0x12, 0x15, 0xa0, 0xb4, 0x03, 0x1d,
   0xaf, 0x16, 0x05, 0x16, 0xef, 0xb5, 0x15, 0x01, 0x22, 0x12, 0x15, 0x87, 0x7e, 0x00, 0x29}},
  {0x17c6, 64, { 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x17, 0xff, 0xf5, 0x18, 0x89, 0x19, 0x80, 0xd4, 0x7b, 0x00, 0x7a,
-  0x00, 0x79, 0x00, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86,
-  0x75, 0x86, 0x00, 0x30, 0x2a, 0x04, 0xc2, 0x2a, 0x80, 0x02, 0xd2, 0x2c, 0x53, 0x91, 0xef, 0x90,
-  0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83}},
- {0x1806, 64, { 0xd0, 0xe0, 0x32, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0xf0, 0x90, 0x7f, 0x94, 0xf0, 0x90,
-  0x7f, 0x9d, 0x74, 0x02, 0xf0, 0x90, 0x7f, 0x97, 0xf0, 0xe4, 0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f,
-  0x9e, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x90, 0x7f, 0x9d, 0xf0, 0x22, 0xc0, 0xe0,
-  0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f}},
- {0x1846, 64, { 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0,
-  0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85,
-  0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x27, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74,
-  0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32}},
- {0x1886, 64, { 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x2d, 0x04, 0xe0, 0x44, 0x02,
-  0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x00, 0x06, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0,
-  0x44, 0x04, 0xf0, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5, 0x82,
-  0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01}},
- {0x18c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xc1, 0xaa, 0x01, 0x1a, 0x00, 0x03, 0x1b, 0x03, 0x00, 0x00, 0xc1,
-  0x27, 0xc1, 0x2c, 0xc1, 0x26, 0xc1, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x79, 0x00, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0xf0, 0x90, 0x7f, 0x94,
+  0xf0, 0x90, 0x7f, 0x9d, 0x74, 0x02, 0xf0, 0x90, 0x7f, 0x97, 0xf0, 0xe4, 0x90, 0x7f, 0x95, 0xf0,
+  0x90, 0x7f, 0x9e, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x90, 0x7f, 0x9d, 0xf0}},
+ {0x1806, 64, { 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90,
+  0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0,
+  0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82,
+  0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x27, 0x53, 0x91, 0xef, 0x90}},
+ {0x1846, 64, { 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0,
+  0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00,
+  0xd2, 0x2c, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0,
+  0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0}},
+ {0x1886, 64, { 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x2d, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x00,
+  0x06, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44, 0x04, 0xf0, 0x22, 0x74, 0x00, 0xf5,
+  0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f,
+  0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xc1}},
+ {0x18c6, 64, { 0xaa, 0x01, 0x1a, 0x00, 0x03, 0x1b, 0x03, 0x00, 0x00, 0xc1, 0x27, 0xc1, 0x2c, 0xc1, 0x26, 0xc1, 0x2b,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x00, 0x01, 0xff, 0x00}},
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00}},
  {0x1906, 64, { 0x00, 0x40, 0xcd, 0x06, 0x0f, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x01, 0x09, 0x02, 0x74, 0x00, 0x01,
   0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00, 0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01,
   0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40,
   0x00, 0x00, 0x07, 0x05, 0x04, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x05, 0x02, 0x40, 0x00}},
  {0x1946, 64, { 0x00, 0x07, 0x05, 0x06, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x07, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05,
-  0x81, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x83, 0x02,
-  0x40, 0x00, 0x00, 0x07, 0x05, 0x84, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x85, 0x02, 0x40, 0x00,
-  0x00, 0x07, 0x05, 0x86, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x87, 0x02, 0x40, 0x00, 0x00}},
+  0x81, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x83, 0x02,
+  0x40, 0x00, 0x01, 0x07, 0x05, 0x84, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x85, 0x02, 0x40, 0x00,
+  0x01, 0x07, 0x05, 0x86, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x87, 0x02, 0x40, 0x00, 0x01}},
  {0x1986, 64, { 0x04, 0x03, 0x09, 0x04, 0x48, 0x03, 0x4b, 0x00, 0x65, 0x00, 0x79, 0x00, 0x73, 0x00, 0x70, 0x00, 0x61,
   0x00, 0x6e, 0x00, 0x2c, 0x00, 0x20, 0x00, 0x61, 0x00, 0x20, 0x00, 0x64, 0x00, 0x69, 0x00, 0x76,
   0x00, 0x69, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x20, 0x00, 0x6f, 0x00, 0x66,
@@ -455,7 +460,7 @@
  {0x1ac6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x18, 0x5f, 0x00, 0x02, 0x1b}},
- {0x1b06,  9, { 0x04, 0x00, 0x02, 0x18, 0x35, 0x00, 0x02, 0x17, 0xdb}},
-{ 0xffff,	0,	{0x00} }
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x18, 0x31, 0x00, 0x02, 0x1b}},
+ {0x1b06,  9, { 0x04, 0x00, 0x02, 0x18, 0x07, 0x00, 0x02, 0x18, 0x58}},
+ {0xffff,  0, {0x00}}
 };
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa28msg.h linux-2.4.19/drivers/usb/serial/keyspan_usa28msg.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa28msg.h	Wed Oct 10 00:15:02 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa28msg.h	Mon Nov 25 12:27:09 2002
@@ -95,7 +95,7 @@
 #define	__USA28MSG__
 
 
-typedef struct keyspan_usa28_portControlMessage
+struct keyspan_usa28_portControlMessage
 {
 	/*
 		there are four types of "commands" sent in the control message:
@@ -146,9 +146,9 @@
 		returnStatus,	// return current status n times (1 or 2)
 		resetDataToggle;// reset data toggle state to DATA0
 	
-} keyspan_usa28_portControlMessage;
+};
 
-typedef struct keyspan_usa28_portStatusMessage
+struct keyspan_usa28_portStatusMessage
 {
 	u8	port,			// 0=first, 1=second, 2=global (see below)
 		cts,
@@ -164,32 +164,32 @@
 		rxBreak,		// 1=we're in break state
 		rs232invalid,	// 1=no valid signals on rs-232 inputs
 		controlResponse;// 1=a control messages has been processed
-} keyspan_usa28_portStatusMessage;
+};
 
 // bit defines in txState
 #define	TX_OFF			0x01	// requested by host txOff command
 #define	TX_XOFF			0x02	// either real, or simulated by host
 
-typedef struct keyspan_usa28_globalControlMessage
+struct keyspan_usa28_globalControlMessage
 {
 	u8	sendGlobalStatus,	// 2=request for two status responses
 		resetStatusToggle,	// 1=reset global status toggle
 		resetStatusCount;	// a cycling value
-} keyspan_usa28_globalControlMessage;
+};
 
-typedef struct keyspan_usa28_globalStatusMessage
+struct keyspan_usa28_globalStatusMessage
 {
 	u8	port,				// 3
 		sendGlobalStatus,	// from request, decremented
 		resetStatusCount;	// as in request
-} keyspan_usa28_globalStatusMessage;
+};
 
-typedef struct keyspan_usa28_globalDebugMessage
+struct keyspan_usa28_globalDebugMessage
 {
 	u8	port,				// 2
 		n,					// typically a count/status byte
 		b;					// typically a data byte
-} keyspan_usa28_globalDebugMessage;
+};
 
 // ie: the maximum length of an EZUSB endpoint buffer
 #define	MAX_DATA_LEN			64
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa28x_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa28x_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa28x_fw.h	Wed Oct 10 00:15:02 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa28x_fw.h	Mon Nov 25 12:27:09 2002
@@ -1,341 +1,346 @@
 /* keyspan_usa28x_fw.h
-  
-   Generated from Keyspan firmware image usa26code.h Sat Oct  6 12:08:55 EST 2001
-   This firmware is for the Keyspan USA-28X Serial Adaptor
 
-   "The firmware contained herein as keyspan_usa28x_fw.h is
-   Copyright (C) 1999-2001 Keyspan, A division of InnoSys Incorporated
-   ("Keyspan"), as an unpublished work.  This notice does not imply
-   unrestricted or public access to this firmware which is a trade secret of
-   Keyspan, and which may not be reproduced, used, sold or transferred to any
-   third party without Keyspan's prior written consent.  All Rights Reserved.
+	The firmware contained herein as keyspan_usa28x_fw.h is
 
-   This firmware may not be modified and may only be used with the Keyspan 
-   USA-28X Serial Adapter.  Distribution and/or Modification of the
-   keyspan.c driver which includes this firmware, in whole or in part,
-   requires the inclusion of this statement."
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
+
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
+
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
 
 */
 
 static const struct ezusb_hex_record keyspan_usa28x_firmware[] = {
- {0x0033,  3, { 0x02, 0x13, 0xab}},
+ {0x0033,  3, { 0x02, 0x12, 0xf7}},
  {0x0003, 16, { 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0}},
  {0x0013, 16, { 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x90}},
  {0x0023, 15, { 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x07, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x22}},
- {0x0046, 16, { 0x30, 0x09, 0x18, 0x12, 0x13, 0x33, 0xef, 0xc3, 0x95, 0x3c, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
+ {0x0046, 16, { 0x30, 0x09, 0x18, 0x12, 0x13, 0x1b, 0xef, 0xc3, 0x95, 0x3c, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
  {0x0056, 16, { 0x7f, 0xbf, 0x74, 0x01, 0xf0, 0xc2, 0x09, 0xc2, 0x00, 0x80, 0x77, 0x30, 0x03, 0x3b, 0x90, 0x7f}},
- {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x33, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
+ {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x1b, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
  {0x0076, 16, { 0x40, 0xe0, 0x13, 0x92, 0x09, 0x90, 0x7f, 0xc7, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60}},
- {0x0086, 16, { 0x0f, 0xf5, 0x08, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x41, 0x12, 0x0c, 0xca}},
+ {0x0086, 16, { 0x0f, 0xf5, 0x08, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x41, 0x12, 0x0c, 0xba}},
  {0x0096, 16, { 0xc2, 0x03, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0x80, 0x39, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x32}},
- {0x00a6, 16, { 0x12, 0x13, 0x33, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x09}},
+ {0x00a6, 16, { 0x12, 0x13, 0x1b, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x09}},
  {0x00b6, 16, { 0x90, 0x7f, 0xc9, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d}},
- {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0xc1, 0x12, 0x0c, 0xca, 0xd2, 0x03, 0xe4, 0x90, 0x7f}},
- {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x66, 0x53, 0x36, 0x80, 0x12}},
- {0x00e6, 16, { 0x13, 0x3f, 0xef, 0x42, 0x36, 0x12, 0x11, 0xed, 0x8f, 0x19, 0xef, 0xc3, 0x95, 0x3a, 0x50, 0x0f}},
- {0x00f6, 16, { 0x12, 0x13, 0x1b, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x36, 0x20, 0xe7, 0x03, 0x30, 0x0b, 0x61, 0xc2}},
+ {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0xc1, 0x12, 0x0c, 0xba, 0xd2, 0x03, 0xe4, 0x90, 0x7f}},
+ {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x60, 0x12, 0x11, 0xd6, 0x8f}},
+ {0x00e6, 16, { 0x19, 0x12, 0x13, 0x27, 0x8f, 0x36, 0xe5, 0x19, 0xc3, 0x95, 0x3a, 0x50, 0x0f, 0x12, 0x12, 0xeb}},
+ {0x00f6, 16, { 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x36, 0x20, 0xe7, 0x03, 0x30, 0x0b, 0x5e, 0xc2, 0x0b, 0xe5, 0x19}},
  {0x0036, 12, { 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22}},
  {0x0043,  3, { 0x02, 0x13, 0x00}},
- {0x0000,  3, { 0x02, 0x0e, 0x10}},
- {0x0106, 64, { 0x0b, 0xe5, 0x19, 0x70, 0x04, 0xf5, 0x36, 0x80, 0x57, 0x12, 0x13, 0x3f, 0xef, 0x42, 0x36, 0xe5, 0x36,
-  0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08,
-  0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x80, 0xaf, 0x36, 0x12, 0x0f, 0x5b, 0xe5,
-  0x19, 0x25, 0xe0, 0x90, 0x7f, 0xb7, 0xf0, 0x80, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40}},
- {0x0146, 64, { 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08, 0xe4, 0x90, 0x7e, 0x80, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75,
-  0x0c, 0x7e, 0x75, 0x0d, 0x81, 0x12, 0x0c, 0xef, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90,
-  0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x05, 0x03, 0x02, 0x03, 0xc5, 0xc2, 0x05, 0xe4, 0xf5,
-  0x18, 0x74, 0x40, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5}},
- {0x0186, 64, { 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef,
-  0x12, 0x0e, 0xe2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x68,
-  0x90, 0x7e, 0x03, 0xe0, 0x60, 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xc8, 0x7f, 0x03, 0x7d,
-  0xcd, 0x12, 0x11, 0xc8, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0}},
- {0x01c6, 64, { 0x00, 0xe5, 0x46, 0xf0, 0xe4, 0x90, 0x7e, 0x13, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12,
-  0x10, 0x4c, 0x90, 0x7e, 0x02, 0xe0, 0xff, 0x12, 0x10, 0x72, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0,
-  0xfd, 0x12, 0x11, 0xc8, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xc8, 0x43, 0x46, 0x80, 0x90, 0x7f,
-  0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12}},
- {0x0206, 64, { 0xf0, 0xe5, 0x40, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x03, 0xe0, 0x70, 0x06, 0x90, 0x7e,
-  0x13, 0xe0, 0x70, 0x08, 0xe4, 0x90, 0x7e, 0x13, 0xf0, 0x75, 0x25, 0xff, 0x90, 0x7e, 0x05, 0xe0,
-  0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x44, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0,
-  0x00, 0xe5, 0x44, 0xf0, 0x90, 0x7e, 0x07, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43}},
- {0x0246, 64, { 0x42, 0x80, 0x80, 0x03, 0x53, 0x42, 0x7f, 0x53, 0x42, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43,
-  0x42, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x10, 0xbe, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x10, 0xe4,
-  0xaf, 0x42, 0x12, 0x10, 0x98, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x08, 0x53, 0x42, 0x7f, 0xaf, 0x42,
-  0x12, 0x10, 0x98, 0x90, 0x7e, 0x0c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46}},
- {0x0286, 64, { 0x02, 0x80, 0x03, 0x53, 0x46, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46,
-  0xf0, 0x90, 0x7e, 0x0e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x01, 0x80, 0x03,
-  0x53, 0x46, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90,
-  0x7e, 0x12, 0xe0, 0xf5, 0x3a, 0xa3, 0xe0, 0x13, 0x92, 0x0d, 0xa3, 0xe0, 0xf5, 0x3c, 0xa3}},
- {0x02c6, 64, { 0xe0, 0x60, 0x05, 0x43, 0x46, 0x10, 0x80, 0x03, 0x53, 0x46, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0,
-  0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x44, 0xbf, 0x90,
-  0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x11, 0xf0, 0x12, 0x13, 0x0f, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3e}},
- {0x0306, 64, { 0xfd, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xc8, 0xe4, 0xf5, 0x2a, 0xf5, 0x29, 0xd2, 0x07, 0x90, 0x7e,
-  0x17, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x02, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xc8, 0x75, 0x29,
-  0x01, 0xd2, 0x07, 0x90, 0x7e, 0x18, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5,
-  0x40, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11}},
- {0x0346, 64, { 0x43, 0x44, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
-  0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f, 0x53, 0x3e, 0xfe, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xc8,
-  0x75, 0x2b, 0x01, 0xd2, 0x07, 0x90, 0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x01, 0xe4, 0xff,
-  0xad, 0x3e, 0x12, 0x11, 0xc8, 0xe4, 0xf5, 0x2b, 0xd2, 0x07, 0x90, 0x7e, 0x1c, 0xe0, 0x60}},
- {0x0386, 64, { 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
-  0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x0b, 0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x2c, 0x01, 0xe4,
-  0xf5, 0x38, 0xd2, 0x07, 0x90, 0x7e, 0x1f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0,
-  0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0, 0x74, 0x35, 0xf0, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30}},
- {0x03c6, 64, { 0x1a, 0x52, 0xe5, 0x38, 0x60, 0x02, 0x15, 0x38, 0x20, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40,
-  0x04, 0x15, 0x13, 0x80, 0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xd2, 0x13, 0x12, 0x13, 0x0f,
-  0xef, 0x54, 0x01, 0xf5, 0x19, 0x65, 0x2a, 0x60, 0x05, 0x85, 0x19, 0x2a, 0xd2, 0x07, 0x12, 0x13,
-  0x4b, 0xef, 0x54, 0x80, 0xf5, 0x19, 0x65, 0x26, 0x60, 0x05, 0x85, 0x19, 0x26, 0xd2, 0x07}},
- {0x0406, 64, { 0x30, 0x0d, 0x11, 0x12, 0x13, 0x4b, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x25, 0x60, 0x05, 0x85, 0x19,
-  0x25, 0xd2, 0x07, 0x20, 0x1b, 0x03, 0x02, 0x07, 0xf4, 0x30, 0x0a, 0x18, 0x12, 0x13, 0x87, 0xef,
-  0xc3, 0x95, 0x3d, 0x40, 0x03, 0x02, 0x04, 0xb2, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0xc2, 0x0a,
-  0xc2, 0x00, 0x80, 0x77, 0x30, 0x04, 0x3b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x6d, 0x12}},
- {0x0446, 64, { 0x13, 0x87, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f,
-  0xcb, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d, 0x7f, 0x41,
-  0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x41, 0x12, 0x0d, 0x14, 0xc2, 0x04, 0xe4, 0x90, 0x7f, 0xcb, 0xf0,
-  0x80, 0x39, 0x90, 0x7f, 0xcc, 0xe0, 0x20, 0xe1, 0x32, 0x12, 0x13, 0x87, 0xef, 0xc3, 0x94}},
- {0x0486, 64, { 0x40, 0x50, 0x29, 0x90, 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcd, 0xe0, 0x14, 0xf5, 0x19,
-  0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7c, 0x7f, 0xc1, 0x75, 0x0c, 0x7c, 0x75, 0x0d,
-  0xc1, 0x12, 0x0d, 0x14, 0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xba, 0xe0, 0x30,
-  0xe1, 0x03, 0x02, 0x05, 0x40, 0x53, 0x37, 0x80, 0x12, 0x13, 0x93, 0xef, 0x42, 0x37, 0x12}},
- {0x04c6, 64, { 0x12, 0x37, 0x8f, 0x19, 0xef, 0xc3, 0x95, 0x3b, 0x50, 0x0f, 0x12, 0x13, 0x6f, 0xef, 0x30, 0xe0, 0x08,
-  0xe5, 0x37, 0x20, 0xe7, 0x03, 0x30, 0x0c, 0x61, 0xc2, 0x0c, 0xe5, 0x19, 0x70, 0x04, 0xf5, 0x37,
-  0x80, 0x57, 0x12, 0x13, 0x93, 0xef, 0x42, 0x37, 0xe5, 0x37, 0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3,
-  0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e, 0x7d, 0x7f, 0x80, 0x75}},
- {0x0506, 64, { 0x0c, 0x7d, 0x75, 0x0d, 0x80, 0xaf, 0x37, 0x12, 0x0f, 0x94, 0xe5, 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xbb,
-  0xf0, 0x80, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08,
-  0xe4, 0x90, 0x7d, 0x80, 0xf0, 0x7e, 0x7d, 0x7f, 0x81, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x81, 0x12,
-  0x0d, 0x39, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xbb, 0xf0, 0x90, 0x7f, 0xd0, 0xe0, 0x30, 0xe1}},
- {0x0546, 64, { 0x06, 0x20, 0x06, 0x03, 0x02, 0x07, 0x9f, 0xc2, 0x06, 0xe4, 0xf5, 0x18, 0x74, 0xc0, 0x25, 0x18, 0xf5,
-  0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e,
-  0x79, 0x20, 0x24, 0x20, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e, 0xe2, 0x05, 0x18, 0xe5,
-  0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x20, 0xe0, 0x60, 0x68, 0x90, 0x7e, 0x23, 0xe0, 0x60}},
- {0x0586, 64, { 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x12, 0x12, 0x7f, 0x03, 0x7d, 0xcd, 0x12, 0x12, 0x12, 0x43, 0x47,
-  0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0xe4, 0x90, 0x7e,
-  0x33, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x21, 0xe0, 0xff, 0x12, 0x11, 0x30, 0x90, 0x7e, 0x22, 0xe0,
-  0xff, 0x12, 0x11, 0x56, 0x7f, 0x01, 0x90, 0x7e, 0x31, 0xe0, 0xfd, 0x12, 0x12, 0x12, 0x7f}},
- {0x05c6, 64, { 0x03, 0x7d, 0x07, 0x12, 0x12, 0x12, 0x43, 0x47, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0,
-  0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x06, 0x90, 0xc0,
-  0x00, 0xf0, 0x90, 0x7e, 0x23, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x33, 0xe0, 0x70, 0x08, 0xe4, 0x90,
-  0x7e, 0x33, 0xf0, 0x75, 0x2e, 0xff, 0x90, 0x7e, 0x25, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54}},
- {0x0606, 64, { 0x3f, 0xf5, 0x45, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x45, 0xf0, 0x90, 0x7e,
-  0x27, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x43, 0x80, 0x80, 0x03, 0x53, 0x43, 0x7f,
-  0x53, 0x43, 0xfc, 0x90, 0x7e, 0x29, 0xe0, 0x60, 0x11, 0x43, 0x43, 0x02, 0xa3, 0xe0, 0xff, 0x12,
-  0x11, 0x7c, 0x90, 0x7e, 0x2b, 0xe0, 0xff, 0x12, 0x11, 0xa2, 0xaf, 0x43, 0x12, 0x11, 0x0a}},
- {0x0646, 64, { 0x90, 0x7e, 0x23, 0xe0, 0x60, 0x08, 0x53, 0x43, 0x7f, 0xaf, 0x43, 0x12, 0x11, 0x0a, 0x90, 0x7e, 0x2c,
-  0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x02, 0x80, 0x03, 0x53, 0x47, 0xfd, 0x90,
-  0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x2e, 0xe0, 0x60,
-  0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x01, 0x80, 0x03, 0x53, 0x47, 0xfe, 0x90, 0x7f}},
- {0x0686, 64, { 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x32, 0xe0, 0xf5, 0x3b, 0xa3,
-  0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x10, 0x80,
-  0x03, 0x53, 0x47, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0,
-  0x90, 0x7e, 0x36, 0xe0, 0x60, 0x32, 0x53, 0x45, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0}},
- {0x06c6, 64, { 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x12, 0x13, 0x63,
-  0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3f, 0xfd, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12,
-  0x12, 0xe4, 0xf5, 0x33, 0xf5, 0x32, 0xd2, 0x08, 0x90, 0x7e, 0x37, 0xe0, 0x60, 0x0f, 0x43, 0x3f,
-  0x02, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x12, 0x75, 0x32, 0x01, 0xd2, 0x08, 0x90, 0x7e}},
- {0x0706, 64, { 0x38, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x04, 0x90, 0xc0, 0x00,
-  0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x39, 0xe0, 0x60, 0x11, 0x43, 0x45, 0x40, 0x90, 0x7f, 0x98, 0x74,
-  0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x3a, 0xe0, 0x60, 0x0f,
-  0x53, 0x3f, 0xfe, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x12, 0x75, 0x34, 0x01, 0xd2, 0x08}},
- {0x0746, 64, { 0x90, 0x7e, 0x3b, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x01, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x12, 0xe4,
-  0xf5, 0x34, 0xd2, 0x08, 0x90, 0x7e, 0x3c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
-  0xe5, 0x41, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x3d, 0xe0, 0x60, 0x02, 0xd2, 0x0c,
-  0x90, 0x7e, 0x3e, 0xe0, 0x60, 0x08, 0x75, 0x35, 0x01, 0xe4, 0xf5, 0x39, 0xd2, 0x08, 0x90}},
- {0x0786, 64, { 0x7e, 0x3f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7, 0x74, 0x13, 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x16, 0xf0,
-  0x74, 0x36, 0xf0, 0xe4, 0x90, 0x7f, 0xd1, 0xf0, 0x30, 0x1a, 0x52, 0xe5, 0x39, 0x60, 0x02, 0x15,
-  0x39, 0x30, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80, 0x3e, 0x75,
-  0x13, 0x0a, 0x30, 0x1b, 0x02, 0xc2, 0x13, 0x12, 0x13, 0x63, 0xef, 0x54, 0x01, 0xf5, 0x19}},
- {0x07c6, 64, { 0x65, 0x33, 0x60, 0x05, 0x85, 0x19, 0x33, 0xd2, 0x08, 0x12, 0x13, 0x9f, 0xef, 0x54, 0x80, 0xf5, 0x19,
-  0x65, 0x2f, 0x60, 0x05, 0x85, 0x19, 0x2f, 0xd2, 0x08, 0x30, 0x0e, 0x11, 0x12, 0x13, 0x9f, 0xef,
-  0x54, 0x10, 0xf5, 0x19, 0x65, 0x2e, 0x60, 0x05, 0x85, 0x19, 0x2e, 0xd2, 0x08, 0x30, 0x1a, 0x2a,
-  0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90, 0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5}},
- {0x0806, 64, { 0x15, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x16, 0x90, 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74,
-  0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f, 0xd3, 0xf0, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1,
-  0x03, 0x02, 0x09, 0x28, 0xe5, 0x0a, 0x70, 0x40, 0x30, 0x07, 0x39, 0xe5, 0x38, 0x70, 0x35, 0xc2,
-  0x07, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
- {0x0846, 64, { 0xfa, 0x12, 0x0e, 0x9c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
-  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x38,
-  0x10, 0xe4, 0xf5, 0x2c, 0x75, 0x0a, 0x01, 0x22, 0xe5, 0x0a, 0x64, 0x01, 0x70, 0x40, 0x30, 0x08,
-  0x39, 0xe5, 0x39, 0x70, 0x35, 0xc2, 0x08, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2d}},
- {0x0886, 64, { 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82,
-  0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f,
-  0xc3, 0x74, 0x09, 0xf0, 0x75, 0x39, 0x10, 0xe4, 0xf5, 0x35, 0x75, 0x0a, 0x02, 0x22, 0xe5, 0x0a,
-  0x64, 0x02, 0x70, 0x36, 0x30, 0x14, 0x2f, 0xc2, 0x14, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00}},
- {0x08c6, 64, { 0x74, 0x0e, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9c, 0xff, 0x74, 0x80, 0x25, 0x18,
-  0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x05, 0xdb,
-  0x90, 0x7f, 0xc3, 0x74, 0x05, 0xf0, 0x75, 0x0a, 0x03, 0x22, 0xe5, 0x15, 0x60, 0x30, 0x15, 0x15,
-  0xe4, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x14, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
- {0x0906, 64, { 0xfa, 0x12, 0x0e, 0x9c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
-  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5,
-  0x0a, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0e, 0xf4, 0x0a, 0x10, 0x00, 0x0a, 0x84, 0x01, 0x0a,
-  0xf0, 0x03, 0x09, 0x4c, 0x06, 0x0a, 0x03, 0x08, 0x09, 0xfd, 0x09, 0x09, 0xe5, 0x0a, 0x09}},
- {0x0946, 64, { 0xf4, 0x0b, 0x00, 0x00, 0x0b, 0x3f, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x14, 0x60, 0x61,
-  0x24, 0x02, 0x60, 0x03, 0x02, 0x09, 0xdb, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90,
-  0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02,
-  0x7f, 0x03, 0x75, 0x82, 0x82, 0x75, 0x83, 0x19, 0xef, 0xf0, 0x75, 0x82, 0x7b, 0x75, 0x83}},
- {0x0986, 64, { 0x19, 0xf0, 0x75, 0x82, 0x74, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x66, 0x75, 0x83, 0x19, 0xf0, 0x75,
-  0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f, 0xea, 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83,
-  0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x12, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b,
-  0x46, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0f, 0x1a, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90}},
- {0x09c6, 64, { 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01,
-  0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f,
-  0x00, 0xe5, 0x09, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea,
-  0xe0, 0xf5, 0x09, 0x02, 0x0b, 0x46, 0x12, 0x0b, 0x4e, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0x00}},
- {0x0a06, 64, { 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60,
-  0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b, 0xa2, 0x10, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff,
-  0xa2, 0x16, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74,
-  0x02, 0xf0, 0x02, 0x0b, 0x46, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5}},
- {0x0a46, 64, { 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f,
-  0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83,
-  0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0,
-  0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f}},
- {0x0a86, 64, { 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0,
-  0xb4, 0x01, 0x05, 0xc2, 0x10, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02,
-  0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff,
-  0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4}},
- {0x0ac6, 64, { 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54,
-  0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f,
-  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60,
-  0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x10, 0x80}},
- {0x0b06, 64, { 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90,
-  0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25,
-  0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90,
-  0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0}},
- {0x0b46, 64, { 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74,
-  0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e,
-  0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x18, 0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74,
-  0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xe4, 0xf5, 0x24, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74}},
- {0x0b86, 64, { 0x24, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xe2, 0x05, 0x18, 0xe5, 0x18, 0xb4,
-  0x09, 0xea, 0x75, 0x3a, 0x01, 0xe4, 0xf5, 0x38, 0xf5, 0x13, 0xf5, 0x36, 0xc2, 0x07, 0xc2, 0x0b,
-  0xc2, 0x05, 0xc2, 0x00, 0xc2, 0x09, 0xc2, 0x13, 0xd2, 0x03, 0xd2, 0x01, 0x90, 0x7f, 0x98, 0x74,
-  0x13, 0xf0, 0x75, 0x44, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd}},
- {0x0bc6, 64, { 0x12, 0x11, 0xc8, 0x7f, 0x10, 0x8f, 0x42, 0x12, 0x10, 0x98, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x7f,
-  0x01, 0x8f, 0x40, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0,
-  0x75, 0x46, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x11, 0xc8, 0xe4,
-  0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3e, 0x12, 0x11, 0xc8, 0x90, 0x7f, 0x98, 0x74, 0x11}},
- {0x0c06, 64, { 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x11, 0xc8, 0x7f, 0x01, 0x12, 0x12,
-  0x81, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xc8, 0x20, 0x1b, 0x03, 0x02, 0x0c, 0xc7, 0x75, 0x2d,
-  0x01, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4,
-  0x12, 0x0e, 0xe2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3b, 0x01, 0xe4, 0xf5}},
- {0x0c46, 64, { 0x39, 0xf5, 0x13, 0xf5, 0x37, 0xc2, 0x08, 0xc2, 0x0c, 0xc2, 0x06, 0xc2, 0x00, 0xc2, 0x0a, 0xc2, 0x13,
-  0xd2, 0x04, 0xd2, 0x02, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x75, 0x45, 0x03, 0x90, 0xc0, 0x00,
-  0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x12, 0x12, 0x7f, 0x10, 0x8f, 0x43, 0x12, 0x11,
-  0x0a, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x7f, 0x01, 0x8f, 0x41, 0xef, 0x44, 0x06, 0x90}},
- {0x0c86, 64, { 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x75, 0x47, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80,
-  0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x12, 0x12, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3f, 0x12,
-  0x12, 0x12, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d,
-  0x7f, 0x12, 0x12, 0x12, 0x7f, 0x01, 0x12, 0x12, 0xa2, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x12}},
- {0x0cc6, 64, { 0x12, 0xd2, 0x12, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5,
-  0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86,
+ {0x0000,  3, { 0x02, 0x0e, 0x00}},
+ {0x0106, 64, { 0x60, 0x58, 0xb4, 0x80, 0x03, 0x43, 0x36, 0x02, 0xe5, 0x36, 0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94,
+  0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x0c, 0x7e,
+  0x75, 0x0d, 0x80, 0xaf, 0x36, 0x12, 0x0f, 0x4b, 0xe5, 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xb7, 0xf0,
+  0x80, 0x27, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08}},
+ {0x0146, 64, { 0x90, 0x7e, 0x80, 0xe5, 0x36, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x81, 0x12,
+  0x0c, 0xdf, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90, 0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06,
+  0x20, 0x05, 0x03, 0x02, 0x03, 0xc1, 0xc2, 0x05, 0xe4, 0xf5, 0x18, 0x74, 0x40, 0x25, 0x18, 0xf5,
+  0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a}},
+ {0x0186, 64, { 0x7e, 0x79, 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e, 0xd2, 0x05, 0x18, 0xe5,
+  0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x68, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x24,
+  0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xb1, 0x7f, 0x03, 0x7d, 0xcd, 0x12, 0x11, 0xb1, 0x43, 0x46,
+  0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0xe4, 0x90}},
+ {0x01c6, 64, { 0x7e, 0x13, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12, 0x10, 0x35, 0x90, 0x7e, 0x02, 0xe0,
+  0xff, 0x12, 0x10, 0x5b, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0, 0xfd, 0x12, 0x11, 0xb1, 0x7f, 0x03,
+  0x7d, 0x07, 0x12, 0x11, 0xb1, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0,
+  0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x06, 0x90}},
+ {0x0206, 64, { 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x03, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x13, 0xe0, 0x70, 0x08, 0xe4, 0x90,
+  0x7e, 0x13, 0xf0, 0x75, 0x25, 0xff, 0x90, 0x7e, 0x05, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f,
+  0xf5, 0x44, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x44, 0xf0, 0x90, 0x7e,
+  0x07, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x42, 0x80, 0x80, 0x03, 0x53, 0x42}},
+ {0x0246, 64, { 0x7f, 0x53, 0x42, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43, 0x42, 0x02, 0xa3, 0xe0, 0xff, 0x12,
+  0x10, 0xa7, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x10, 0xcd, 0xaf, 0x42, 0x12, 0x10, 0x81, 0x90,
+  0x7e, 0x03, 0xe0, 0x60, 0x08, 0x53, 0x42, 0x7f, 0xaf, 0x42, 0x12, 0x10, 0x81, 0x90, 0x7e, 0x0c,
+  0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x02, 0x80, 0x03, 0x53, 0x46, 0xfd}},
+ {0x0286, 64, { 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x0e, 0xe0, 0x60,
+  0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x01, 0x80, 0x03, 0x53, 0x46, 0xfe, 0x90, 0x7f, 0x98,
+  0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x12, 0xe0, 0xf5, 0x3a, 0xa3,
+  0xe0, 0x13, 0x92, 0x0d, 0xa3, 0xe0, 0xf5, 0x3c, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x10}},
+ {0x02c6, 64, { 0x80, 0x03, 0x53, 0x46, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0,
+  0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x44, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5,
+  0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x12, 0x12, 0xdf,
+  0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3e, 0xfd, 0xe4, 0xff, 0xad, 0x3e, 0x12}},
+ {0x0306, 64, { 0x11, 0xb1, 0xe4, 0xf5, 0x2a, 0xf5, 0x29, 0xd2, 0x07, 0x90, 0x7e, 0x17, 0xe0, 0x60, 0x0f, 0x43, 0x3e,
+  0x02, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xb1, 0x75, 0x29, 0x01, 0xd2, 0x07, 0x90, 0x7e, 0x18,
+  0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x04, 0x90, 0xc0, 0x00,
+  0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11, 0x43, 0x44, 0x40, 0x90, 0x7f, 0x98}},
+ {0x0346, 64, { 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f,
+  0x53, 0x3e, 0xfe, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xb1, 0x75, 0x2b, 0x01, 0xd2, 0x07, 0x90,
+  0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x01, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xb1, 0xe4,
+  0xf5, 0x2b, 0xd2, 0x07, 0x90, 0x7e, 0x1c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12}},
+ {0x0386, 64, { 0xf0, 0xe5, 0x40, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x0b,
+  0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x2c, 0x01, 0xe4, 0xf5, 0x38, 0xd2, 0x07, 0x90, 0x7e,
+  0x1f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0,
+  0x74, 0x35, 0xf0, 0xd2, 0x03, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30, 0x1a, 0x52, 0xe5, 0x38}},
+ {0x03c6, 64, { 0x60, 0x02, 0x15, 0x38, 0x20, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80,
+  0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xd2, 0x13, 0x12, 0x12, 0xdf, 0xef, 0x54, 0x01, 0xf5,
+  0x19, 0x65, 0x2a, 0x60, 0x05, 0x85, 0x19, 0x2a, 0xd2, 0x07, 0x12, 0x13, 0x33, 0xef, 0x54, 0x80,
+  0xf5, 0x19, 0x65, 0x26, 0x60, 0x05, 0x85, 0x19, 0x26, 0xd2, 0x07, 0x30, 0x0d, 0x11, 0x12}},
+ {0x0406, 64, { 0x13, 0x33, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x25, 0x60, 0x05, 0x85, 0x19, 0x25, 0xd2, 0x07, 0x20,
+  0x1b, 0x03, 0x02, 0x07, 0xec, 0x30, 0x0a, 0x18, 0x12, 0x13, 0x6f, 0xef, 0xc3, 0x95, 0x3d, 0x40,
+  0x03, 0x02, 0x04, 0xae, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0xc2, 0x0a, 0xc2, 0x00, 0x80, 0x77,
+  0x30, 0x04, 0x3b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x6f, 0xef, 0xc3}},
+ {0x0446, 64, { 0x94, 0x40, 0x50, 0x64, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcb, 0xe0, 0x14, 0xf5,
+  0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d, 0x7f, 0x41, 0x75, 0x0c, 0x7d, 0x75,
+  0x0d, 0x41, 0x12, 0x0d, 0x04, 0xc2, 0x04, 0xe4, 0x90, 0x7f, 0xcb, 0xf0, 0x80, 0x39, 0x90, 0x7f,
+  0xcc, 0xe0, 0x20, 0xe1, 0x32, 0x12, 0x13, 0x6f, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90}},
+ {0x0486, 64, { 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcd, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60,
+  0x0f, 0xf5, 0x08, 0x7e, 0x7c, 0x7f, 0xc1, 0x75, 0x0c, 0x7c, 0x75, 0x0d, 0xc1, 0x12, 0x0d, 0x04,
+  0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xba, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x05,
+  0x36, 0x12, 0x12, 0x20, 0x8f, 0x19, 0x12, 0x13, 0x7b, 0x8f, 0x37, 0xe5, 0x19, 0xc3, 0x95}},
+ {0x04c6, 64, { 0x3b, 0x50, 0x0f, 0x12, 0x13, 0x57, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x37, 0x20, 0xe7, 0x03, 0x30, 0x0c,
+  0x5e, 0xc2, 0x0c, 0xe5, 0x19, 0x60, 0x58, 0xb4, 0x80, 0x03, 0x43, 0x37, 0x02, 0xe5, 0x37, 0x30,
+  0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e,
+  0x7d, 0x7f, 0x80, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x80, 0xaf, 0x37, 0x12, 0x0f, 0x84, 0xe5}},
+ {0x0506, 64, { 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xbb, 0xf0, 0x80, 0x27, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75,
+  0x19, 0x3f, 0x85, 0x19, 0x08, 0x90, 0x7d, 0x80, 0xe5, 0x37, 0xf0, 0x7e, 0x7d, 0x7f, 0x81, 0x75,
+  0x0c, 0x7d, 0x75, 0x0d, 0x81, 0x12, 0x0d, 0x29, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xbb, 0xf0, 0x90,
+  0x7f, 0xd0, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x06, 0x03, 0x02, 0x07, 0x97, 0xc2, 0x06, 0xe4}},
+ {0x0546, 64, { 0xf5, 0x18, 0x74, 0xc0, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18,
+  0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x20, 0x24, 0x20, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef,
+  0x12, 0x0e, 0xd2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x20, 0xe0, 0x60, 0x68,
+  0x90, 0x7e, 0x23, 0xe0, 0x60, 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xfb, 0x7f, 0x03}},
+ {0x0586, 64, { 0x7d, 0xcd, 0x12, 0x11, 0xfb, 0x43, 0x47, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00,
+  0xe5, 0x47, 0xf0, 0xe4, 0x90, 0x7e, 0x33, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x21, 0xe0, 0xff, 0x12,
+  0x11, 0x19, 0x90, 0x7e, 0x22, 0xe0, 0xff, 0x12, 0x11, 0x3f, 0x7f, 0x01, 0x90, 0x7e, 0x31, 0xe0,
+  0xfd, 0x12, 0x11, 0xfb, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xfb, 0x43, 0x47, 0x80, 0x90}},
+ {0x05c6, 64, { 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
+  0xe5, 0x41, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x23, 0xe0, 0x70, 0x06, 0x90, 0x7e,
+  0x33, 0xe0, 0x70, 0x08, 0xe4, 0x90, 0x7e, 0x33, 0xf0, 0x75, 0x2e, 0xff, 0x90, 0x7e, 0x25, 0xe0,
+  0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x45, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90}},
+ {0x0606, 64, { 0xc0, 0x00, 0xe5, 0x45, 0xf0, 0x90, 0x7e, 0x27, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x43,
+  0x80, 0x80, 0x03, 0x53, 0x43, 0x7f, 0x53, 0x43, 0xfc, 0x90, 0x7e, 0x29, 0xe0, 0x60, 0x11, 0x43,
+  0x43, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x11, 0x65, 0x90, 0x7e, 0x2b, 0xe0, 0xff, 0x12, 0x11, 0x8b,
+  0xaf, 0x43, 0x12, 0x10, 0xf3, 0x90, 0x7e, 0x23, 0xe0, 0x60, 0x08, 0x53, 0x43, 0x7f, 0xaf}},
+ {0x0646, 64, { 0x43, 0x12, 0x10, 0xf3, 0x90, 0x7e, 0x2c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x02,
+  0x80, 0x03, 0x53, 0x47, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47,
+  0xf0, 0x90, 0x7e, 0x2e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x01, 0x80, 0x03,
+  0x53, 0x47, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0}},
+ {0x0686, 64, { 0x90, 0x7e, 0x32, 0xe0, 0xf5, 0x3b, 0xa3, 0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0,
+  0x60, 0x05, 0x43, 0x47, 0x10, 0x80, 0x03, 0x53, 0x47, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0,
+  0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x36, 0xe0, 0x60, 0x32, 0x53, 0x45, 0xbf, 0x90,
+  0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f}},
+ {0x06c6, 64, { 0x98, 0x74, 0x09, 0xf0, 0x12, 0x13, 0x4b, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3f, 0xfd,
+  0xe4, 0xff, 0xad, 0x3f, 0x12, 0x11, 0xfb, 0xe4, 0xf5, 0x33, 0xf5, 0x32, 0xd2, 0x08, 0x90, 0x7e,
+  0x37, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x02, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x11, 0xfb, 0x75, 0x32,
+  0x01, 0xd2, 0x08, 0x90, 0x7e, 0x38, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0}},
+ {0x0706, 64, { 0xe5, 0x41, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x39, 0xe0, 0x60, 0x11, 0x43,
+  0x45, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
+  0x90, 0x7e, 0x3a, 0xe0, 0x60, 0x0f, 0x53, 0x3f, 0xfe, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x11, 0xfb,
+  0x75, 0x34, 0x01, 0xd2, 0x08, 0x90, 0x7e, 0x3b, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x01, 0xe4}},
+ {0x0746, 64, { 0xff, 0xad, 0x3f, 0x12, 0x11, 0xfb, 0xe4, 0xf5, 0x34, 0xd2, 0x08, 0x90, 0x7e, 0x3c, 0xe0, 0x60, 0x0e,
+  0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
+  0x3d, 0xe0, 0x60, 0x02, 0xd2, 0x0c, 0x90, 0x7e, 0x3e, 0xe0, 0x60, 0x08, 0x75, 0x35, 0x01, 0xe4,
+  0xf5, 0x39, 0xd2, 0x08, 0x90, 0x7e, 0x3f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x13}},
+ {0x0786, 64, { 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x16, 0xf0, 0x74, 0x36, 0xf0, 0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xd1, 0xf0,
+  0x30, 0x1a, 0x52, 0xe5, 0x39, 0x60, 0x02, 0x15, 0x39, 0x30, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94,
+  0x00, 0x40, 0x04, 0x15, 0x13, 0x80, 0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xc2, 0x13, 0x12,
+  0x13, 0x4b, 0xef, 0x54, 0x01, 0xf5, 0x19, 0x65, 0x33, 0x60, 0x05, 0x85, 0x19, 0x33, 0xd2}},
+ {0x07c6, 64, { 0x08, 0x12, 0x13, 0x87, 0xef, 0x54, 0x80, 0xf5, 0x19, 0x65, 0x2f, 0x60, 0x05, 0x85, 0x19, 0x2f, 0xd2,
+  0x08, 0x30, 0x0e, 0x11, 0x12, 0x13, 0x87, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x2e, 0x60, 0x05,
+  0x85, 0x19, 0x2e, 0xd2, 0x08, 0x30, 0x1a, 0x2a, 0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90,
+  0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5, 0x15, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x16, 0x90}},
+ {0x0806, 64, { 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f,
+  0xd3, 0xf0, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x09, 0x20, 0xe5, 0x0a, 0x70, 0x40,
+  0x30, 0x07, 0x39, 0xe5, 0x38, 0x70, 0x35, 0xc2, 0x07, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74,
+  0x24, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x8c, 0xff, 0x74, 0x80, 0x25}},
+ {0x0846, 64, { 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb,
+  0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x38, 0x10, 0xe4, 0xf5, 0x2c, 0x75, 0x0a, 0x01, 0x22,
+  0xe5, 0x0a, 0x64, 0x01, 0x70, 0x40, 0x30, 0x08, 0x39, 0xe5, 0x39, 0x70, 0x35, 0xc2, 0x08, 0xf5,
+  0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12}},
+ {0x0886, 64, { 0x0e, 0x8c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05,
+  0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x39, 0x10, 0xe4,
+  0xf5, 0x35, 0x75, 0x0a, 0x02, 0x22, 0xe5, 0x0a, 0x64, 0x02, 0x70, 0x36, 0x30, 0x14, 0x2f, 0xc2,
+  0x14, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x0e, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
+ {0x08c6, 64, { 0xfa, 0x12, 0x0e, 0x8c, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
+  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x05, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x05, 0xf0, 0x75, 0x0a,
+  0x03, 0x22, 0xe5, 0x15, 0x60, 0x30, 0x15, 0x15, 0xe4, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74,
+  0x14, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x8c, 0xff, 0x74, 0x80, 0x25}},
+ {0x0906, 64, { 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x03, 0xdb,
+  0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x0a, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0e,
+  0xe4, 0x0a, 0x08, 0x00, 0x0a, 0x7c, 0x01, 0x0a, 0xe8, 0x03, 0x09, 0x44, 0x06, 0x09, 0xfb, 0x08,
+  0x09, 0xf5, 0x09, 0x09, 0xdd, 0x0a, 0x09, 0xec, 0x0b, 0x00, 0x00, 0x0b, 0x37, 0x90, 0x7f}},
+ {0x0946, 64, { 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x14, 0x60, 0x61, 0x24, 0x02, 0x60, 0x03, 0x02, 0x09, 0xd3, 0x74,
+  0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f,
+  0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03, 0x75, 0x82, 0x82, 0x75, 0x83, 0x19,
+  0xef, 0xf0, 0x75, 0x82, 0x7b, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x74, 0x75, 0x83, 0x19}},
+ {0x0986, 64, { 0xf0, 0x75, 0x82, 0x66, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f,
+  0xea, 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83, 0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0,
+  0x74, 0x12, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0f,
+  0x0a, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90, 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0}},
+ {0x09c6, 64, { 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0,
+  0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0x00, 0xe5, 0x09, 0xf0, 0x90, 0x7f, 0xb5, 0x74,
+  0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x09, 0x02, 0x0b, 0x3e, 0x12, 0x0b,
+  0x46, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0x00, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02}},
+ {0x0a06, 64, { 0x0b, 0x3e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b,
+  0xa2, 0x10, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff, 0xa2, 0x16, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00,
+  0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0xe4, 0x90, 0x7f,
+  0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f}},
+ {0x0a46, 64, { 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24,
+  0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4,
+  0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
+  0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02}},
+ {0x0a86, 64, { 0x60, 0x03, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x05, 0xc2, 0x10, 0x02, 0x0b, 0x3e,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38,
+  0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f,
+  0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f}},
+ {0x0ac6, 64, { 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f,
+  0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80,
+  0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea,
+  0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x10, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0}},
+ {0x0b06, 64, { 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4,
+  0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f,
+  0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22}},
+ {0x0b46, 64, { 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90,
+  0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x18,
+  0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xe4, 0xf5,
+  0x24, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa}},
+ {0x0b86, 64, { 0xe4, 0x12, 0x0e, 0xd2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3a, 0x01, 0xe4, 0xf5, 0x38,
+  0xf5, 0x13, 0xf5, 0x36, 0xc2, 0x07, 0xc2, 0x0b, 0xc2, 0x05, 0xc2, 0x00, 0xc2, 0x09, 0xc2, 0x13,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x75, 0x44, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f,
+  0x0c, 0xe4, 0xfd, 0x12, 0x11, 0xb1, 0x7f, 0x10, 0x8f, 0x42, 0x12, 0x10, 0x81, 0x90, 0x7f}},
+ {0x0bc6, 64, { 0x98, 0x74, 0x12, 0xf0, 0x7f, 0x01, 0x8f, 0x40, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x14, 0xf0, 0x75, 0x46, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd,
+  0x12, 0x11, 0xb1, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3e, 0x12, 0x11, 0xb1, 0x90, 0x7f,
+  0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x11}},
+ {0x0c06, 64, { 0xb1, 0x7f, 0x01, 0x12, 0x12, 0x6a, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xb1, 0x20, 0x1b, 0x03, 0x02,
+  0x0c, 0xb7, 0x75, 0x2d, 0x01, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xe4,
+  0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xd2, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3b,
+  0x01, 0xe4, 0xf5, 0x39, 0xf5, 0x13, 0xf5, 0x37, 0xc2, 0x08, 0xc2, 0x0c, 0xc2, 0x06, 0xc2}},
+ {0x0c46, 64, { 0x00, 0xc2, 0x0a, 0xc2, 0x13, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x75, 0x45, 0x03, 0x90, 0xc0, 0x00,
+  0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x11, 0xfb, 0x7f, 0x10, 0x8f, 0x43, 0x12, 0x10,
+  0xf3, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x7f, 0x01, 0x8f, 0x41, 0xef, 0x44, 0x06, 0x90, 0xc0,
+  0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x75, 0x47, 0x80, 0x90, 0xc0, 0x00, 0x74}},
+ {0x0c86, 64, { 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x11, 0xfb, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3f, 0x12,
+  0x11, 0xfb, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d,
+  0x7f, 0x12, 0x11, 0xfb, 0x7f, 0x01, 0x12, 0x12, 0x8b, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xfb,
+  0xd2, 0x12, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82}},
+ {0x0cc6, 64, { 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86,
   0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08,
-  0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00}},
- {0x0d06, 64, { 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05,
+  0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0,
+  0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90, 0x7f}},
+ {0x0d06, 64, { 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05,
   0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2,
-  0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5}},
- {0x0d46, 64, { 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86,
-  0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05,
+  0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c,
+  0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05}},
+ {0x0d46, 64, { 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05,
   0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43,
-  0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xd2, 0x19, 0x90, 0x7f, 0x92, 0xe0, 0x44}},
- {0x0d86, 64, { 0x02, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x10, 0xe4, 0x33, 0xfe, 0xef, 0x4e, 0xf0, 0xd2,
-  0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f,
+  0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xd2, 0x19, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02,
+  0xf0, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x10, 0xe4, 0x33, 0xfe, 0xef, 0x4e, 0xf0}},
+ {0x0d86, 64, { 0xd2, 0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f,
   0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90,
-  0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0, 0xd2, 0xaf}},
- {0x0dc6, 64, { 0xd2, 0x1a, 0x12, 0x12, 0x5c, 0xc2, 0x11, 0xe4, 0xf5, 0x0b, 0xf5, 0x13, 0xc2, 0x17, 0xc2, 0x12, 0x90,
-  0x7f, 0xa1, 0x04, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x17, 0x60, 0x10, 0x30, 0x12, 0x05, 0xd2,
+  0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2,
+  0x1a, 0x12, 0x12, 0x45, 0xc2, 0x11, 0xe4, 0xf5, 0x0b, 0xf5, 0x13, 0xc2, 0x17, 0xc2, 0x12}},
+ {0x0dc6, 64, { 0x90, 0x7f, 0xa1, 0x04, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x17, 0x60, 0x10, 0x30, 0x12, 0x05, 0xd2,
   0x1a, 0x12, 0x00, 0x46, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x17, 0x80, 0x08, 0x30, 0x12, 0x05, 0xc2,
-  0x1a, 0x12, 0x00, 0x46, 0x30, 0x11, 0x07, 0xc2, 0x11, 0x12, 0x09, 0x29, 0x80, 0xd6, 0x30}},
- {0x0e06, 64, { 0x18, 0xd3, 0xc2, 0x18, 0x12, 0x12, 0xf6, 0x80, 0xcc, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75,
-  0x81, 0x47, 0x02, 0x0e, 0x57, 0x02, 0x0d, 0x7f, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40,
+  0x1a, 0x12, 0x00, 0x46, 0x30, 0x11, 0x07, 0xc2, 0x11, 0x12, 0x09, 0x21, 0x80, 0xd6, 0x30, 0x18,
+  0xd3, 0xc2, 0x18, 0x12, 0x13, 0x93, 0x80, 0xcc, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd}},
+ {0x0e06, 64, { 0x75, 0x81, 0x47, 0x02, 0x0e, 0x47, 0x02, 0x0d, 0x6f, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40,
   0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07,
-  0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4}},
- {0x0e46, 64, { 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
-  0x90, 0x12, 0xc3, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09,
+  0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56,
+  0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40}},
+ {0x0e46, 64, { 0x80, 0x90, 0x12, 0xac, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09,
   0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8,
-  0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5}},
- {0x0e86, 64, { 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf,
-  0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02,
+  0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82,
+  0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca}},
+ {0x0e86, 64, { 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02,
   0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01,
-  0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06}},
- {0x0ec6, 64, { 0xe9, 0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82,
-  0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82,
+  0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9,
+  0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5}},
+ {0x0ec6, 64, { 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82,
   0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0,
-  0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8}},
- {0x0f06, 64, { 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3,
-  0xa3, 0x80, 0xdf, 0x8f, 0x18, 0xe4, 0xf5, 0x19, 0x75, 0x1a, 0xff, 0x75, 0x1b, 0x19, 0x75, 0x1c,
-  0x86, 0xab, 0x1a, 0xaa, 0x1b, 0xa9, 0x1c, 0x90, 0x00, 0x01, 0x12, 0x0e, 0xb5, 0xb4, 0x03, 0x1d,
-  0xaf, 0x19, 0x05, 0x19, 0xef, 0xb5, 0x18, 0x01, 0x22, 0x12, 0x0e, 0x9c, 0x7e, 0x00, 0x29}},
- {0x0f46, 64, { 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x1a, 0xff, 0xf5, 0x1b, 0x89, 0x1c, 0x80, 0xd4, 0x7b, 0x00, 0x7a,
-  0x00, 0x79, 0x00, 0x22, 0x8f, 0x1a, 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c,
+  0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74,
+  0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3}},
+ {0x0f06, 64, { 0xa3, 0xa3, 0x80, 0xdf, 0x8f, 0x18, 0xe4, 0xf5, 0x19, 0x75, 0x1a, 0xff, 0x75, 0x1b, 0x19, 0x75, 0x1c,
+  0x86, 0xab, 0x1a, 0xaa, 0x1b, 0xa9, 0x1c, 0x90, 0x00, 0x01, 0x12, 0x0e, 0xa5, 0xb4, 0x03, 0x1d,
+  0xaf, 0x19, 0x05, 0x19, 0xef, 0xb5, 0x18, 0x01, 0x22, 0x12, 0x0e, 0x8c, 0x7e, 0x00, 0x29, 0xff,
+  0xee, 0x3a, 0xa9, 0x07, 0x75, 0x1a, 0xff, 0xf5, 0x1b, 0x89, 0x1c, 0x80, 0xd4, 0x7b, 0x00}},
+ {0x0f46, 64, { 0x7a, 0x00, 0x79, 0x00, 0x22, 0x8f, 0x1a, 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c,
   0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12, 0x00, 0x36, 0x05, 0x0d, 0xe5, 0x0d, 0xac,
-  0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5}},
- {0x0f86, 64, { 0x08, 0x60, 0x0a, 0x12, 0x13, 0x3f, 0x8f, 0x1a, 0xef, 0x42, 0x36, 0x80, 0xca, 0x22, 0x8f, 0x1a, 0x05,
-  0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a,
-  0xf0, 0x12, 0x13, 0x57, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5,
-  0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x93, 0x8f}},
- {0x0fc6, 64, { 0x1a, 0xef, 0x42, 0x37, 0x80, 0xca, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84,
-  0xc0, 0x86, 0x75, 0x86, 0x00, 0x30, 0x15, 0x04, 0xc2, 0x15, 0x80, 0x02, 0xd2, 0x18, 0x53, 0x91,
-  0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0,
-  0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0}},
- {0x1006, 64, { 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04,
-  0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0,
-  0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x11, 0x53,
-  0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0}},
- {0x1046, 64, { 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf,
-  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74,
-  0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13,
-  0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0}},
- {0x1086, 64, { 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
-  0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44,
-  0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0}},
- {0x10c6, 64, { 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f,
-  0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90,
-  0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90}},
- {0x1106, 64, { 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90,
-  0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0,
-  0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90,
-  0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xef}},
- {0x1146, 64, { 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90,
-  0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09,
-  0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f,
-  0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74}},
- {0x1186, 64, { 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74,
-  0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b,
-  0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00,
-  0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00}},
- {0x11c6, 64, { 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90,
-  0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0,
-  0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x27, 0x8f, 0x1a, 0x12, 0x13, 0x27, 0x8f, 0x1b,
-  0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x27, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b}},
- {0x1206, 64, { 0x60, 0x07, 0x12, 0x13, 0x27, 0x8f, 0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b,
-  0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0f, 0xf0, 0x90,
-  0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22,
-  0x12, 0x13, 0x7b, 0x8f, 0x1a, 0x12, 0x13, 0x7b, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60}},
- {0x1246, 64, { 0x12, 0x12, 0x13, 0x7b, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x7b, 0x8f, 0x1b,
-  0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0,
-  0x30, 0x1a, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x12, 0xdf, 0x90, 0x7f,
-  0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44, 0x04, 0xf0, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5}},
- {0x1286, 64, { 0x3e, 0x54, 0x7f, 0xfd, 0x12, 0x11, 0xc8, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee,
-  0xf0, 0xe4, 0xe5, 0x3e, 0x44, 0x80, 0xfd, 0x12, 0x11, 0xc8, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5,
-  0x3f, 0x54, 0x7f, 0xfd, 0x12, 0x12, 0x12, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00,
-  0xee, 0xf0, 0xe4, 0xe5, 0x3f, 0x44, 0x80, 0xfd, 0x12, 0x12, 0x12, 0x22, 0x05, 0x0e, 0x02}},
- {0x12c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x03, 0x14, 0x03, 0x00, 0x00, 0xc1, 0x11, 0xc1, 0x18, 0xc1, 0x95, 0xc1, 0x10,
-  0xc1, 0x16, 0x01, 0x0a, 0x00, 0xc1, 0x9b, 0x00, 0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19,
-  0xae, 0x18, 0x70, 0x02, 0x15, 0x18, 0x4e, 0x60, 0x05, 0x12, 0x0d, 0x5e, 0x80, 0xee, 0x22, 0x12,
-  0x00, 0x03, 0x12, 0x0d, 0x6f, 0x12, 0x0b, 0x4e, 0x22, 0x02, 0x10, 0x25, 0x00, 0x02, 0x13}},
- {0x1306, 64, { 0x04, 0x00, 0x02, 0x0f, 0xfb, 0x00, 0x02, 0x0f, 0xcd, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0,
+  0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08,
+  0x60, 0x0a, 0x12, 0x13, 0x27, 0x8f, 0x1a, 0xef, 0x42, 0x36, 0x80, 0xca, 0x22, 0x8f, 0x1a}},
+ {0x0f86, 64, { 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a,
+  0xf0, 0x12, 0x13, 0x3f, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5,
+  0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x7b, 0x8f, 0x1a,
+  0xef, 0x42, 0x37, 0x80, 0xca, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0}},
+ {0x0fc6, 64, { 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab,
+  0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32,
+  0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2,
+  0x11, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0}},
+ {0x1006, 64, { 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0,
+  0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08,
+  0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f,
+  0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10}},
+ {0x1046, 64, { 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90,
+  0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0,
+  0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13,
+  0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13}},
+ {0x1086, 64, { 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef,
+  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74,
+  0x14, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44}},
+ {0x10c6, 64, { 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74,
+  0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98,
+  0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90}},
+ {0x1106, 64, { 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00,
+  0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5,
+  0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90}},
+ {0x1146, 64, { 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90,
+  0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f,
+  0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0,
+  0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f}},
+ {0x1186, 64, { 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0,
+  0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b,
+  0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0,
+  0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90}},
+ {0x11c6, 64, { 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12,
+  0x13, 0x0f, 0x8f, 0x1a, 0x12, 0x13, 0x0f, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12,
+  0x13, 0x0f, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x0f, 0x8f, 0x1b, 0x80,
+  0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90}},
+ {0x1206, 64, { 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0f, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98,
+  0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x63, 0x8f, 0x1a, 0x12, 0x13,
+  0x63, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x63, 0x8f, 0x1a, 0xe5, 0x1a,
+  0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x63, 0x8f, 0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90}},
+ {0x1246, 64, { 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x1a, 0x04, 0xe0, 0x44, 0x02, 0xf0,
+  0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x12, 0xc8, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44,
+  0x04, 0xf0, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3e, 0x54, 0x7f, 0xfd, 0x12, 0x11, 0xb1, 0x90,
+  0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3e, 0x44, 0x80}},
+ {0x1286, 64, { 0xfd, 0x12, 0x11, 0xb1, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3f, 0x54, 0x7f, 0xfd, 0x12, 0x11, 0xfb,
+  0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3f, 0x44, 0x80,
+  0xfd, 0x12, 0x11, 0xfb, 0x22, 0x05, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x14, 0x03, 0x00,
+  0x00, 0xc1, 0x11, 0xc1, 0x18, 0xc1, 0x95, 0xc1, 0x10, 0xc1, 0x16, 0x01, 0x0a, 0x00, 0xc1}},
+ {0x12c6, 64, { 0x9b, 0x00, 0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19, 0xae, 0x18, 0x70, 0x02, 0x15, 0x18, 0x4e,
+  0x60, 0x05, 0x12, 0x0d, 0x4e, 0x80, 0xee, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0,
   0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
-  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
-  0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90}},
- {0x1346, 64, { 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
-  0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
-  0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0,
-  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff}},
- {0x1386, 64, { 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
-  0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0,
-  0x00, 0xe0, 0xff, 0x22, 0x53, 0xd8, 0xef, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x53, 0xd8, 0xef, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0f, 0xe7, 0x00, 0x02, 0x13}},
+ {0x1306, 64, { 0x04, 0x00, 0x02, 0x0f, 0xbd, 0x00, 0x02, 0x10, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x16, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90}},
+ {0x1346, 64, { 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff}},
+ {0x1386, 64, { 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x12, 0x00, 0x03, 0x12,
+  0x0d, 0x5f, 0x12, 0x0b, 0x46, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
  {0x13c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -420,7 +425,7 @@
  {0x18c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x00, 0x01, 0xff, 0x00}},
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00}},
  {0x1906, 64, { 0x00, 0x40, 0xcd, 0x06, 0x10, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x02, 0x09, 0x02, 0x74, 0x00, 0x01,
   0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00, 0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01,
   0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40,
@@ -438,5 +443,5 @@
   0x00, 0x42, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x69, 0x00, 0x61, 0x00, 0x6c,
   0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00, 0x70, 0x00, 0x74, 0x00, 0x65, 0x00}},
  {0x1a06,  4, { 0x72, 0x00, 0x00, 0x00}},
-{ 0xffff,	0,	{0x00} }
+ {0xffff,  0,  {0x00}}
 };
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa28xa_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa28xa_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa28xa_fw.h	Wed Oct 10 00:15:03 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa28xa_fw.h	Mon Nov 25 12:27:09 2002
@@ -1,351 +1,354 @@
 /* keyspan_usa28xa_fw.h
 
-   Generated from Keyspan firmware image usa44code.h Sat Oct  6 12:08:02 EST 2001
-   This firmware is for the Keyspan USA-28XA Serial Adaptor
+	The firmware contained herein as keyspan_usa28xa.h is
 
-   "The firmware contained herein as keyspan_usa28xa_fw.h is
-   Copyright (C) 1999-2001 Keyspan, A division of InnoSys Incorporated
-   ("Keyspan"), as an unpublished work.  This notice does not imply
-   unrestricted or public access to this firmware which is a trade secret of
-   Keyspan, and which may not be reproduced, used, sold or transferred to any
-   third party without Keyspan's prior written consent.  All Rights Reserved.
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
+
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
+
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
 
-   Permission is hereby granted for the distribution of this firmware image
-   as part of a Linux or other Open Source operating system kernel in 
-   text or binary form as required.
 
-   This firmware may not be modified and may only be used with the Keyspan 
-   USA-28XA Serial Adapter.  Distribution and/or Modification of the
-   keyspan.c driver which includes this firmware, in whole or in part,
-   requires the inclusion of this statement."
 
 */
 
 static const struct ezusb_hex_record keyspan_usa28xa_firmware[] = {
- {0x0033,  3, { 0x02, 0x13, 0xaa}},
+ {0x0033,  3, { 0x02, 0x12, 0xf9}},
  {0x0003, 16, { 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0}},
  {0x0013, 16, { 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x90}},
  {0x0023, 15, { 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x07, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x22}},
- {0x0046, 16, { 0x30, 0x09, 0x18, 0x12, 0x13, 0x28, 0xef, 0xc3, 0x95, 0x3c, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
+ {0x0046, 16, { 0x30, 0x09, 0x18, 0x12, 0x13, 0x27, 0xef, 0xc3, 0x95, 0x3c, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
  {0x0056, 16, { 0x7f, 0xbf, 0x74, 0x01, 0xf0, 0xc2, 0x09, 0xc2, 0x00, 0x80, 0x77, 0x30, 0x03, 0x3b, 0x90, 0x7f}},
- {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x28, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
+ {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x27, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
  {0x0076, 16, { 0x40, 0xe0, 0x13, 0x92, 0x09, 0x90, 0x7f, 0xc7, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60}},
- {0x0086, 16, { 0x0f, 0xf5, 0x08, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x41, 0x12, 0x0c, 0xd8}},
+ {0x0086, 16, { 0x0f, 0xf5, 0x08, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x41, 0x12, 0x0c, 0xc8}},
  {0x0096, 16, { 0xc2, 0x03, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0x80, 0x39, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x32}},
- {0x00a6, 16, { 0x12, 0x13, 0x28, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x09}},
+ {0x00a6, 16, { 0x12, 0x13, 0x27, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x09}},
  {0x00b6, 16, { 0x90, 0x7f, 0xc9, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d}},
- {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0xc1, 0x12, 0x0c, 0xd8, 0xd2, 0x03, 0xe4, 0x90, 0x7f}},
- {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x66, 0x53, 0x36, 0x80, 0x12}},
- {0x00e6, 16, { 0x13, 0x34, 0xef, 0x42, 0x36, 0x12, 0x11, 0xfb, 0x8f, 0x19, 0xef, 0xc3, 0x95, 0x3a, 0x50, 0x0f}},
- {0x00f6, 16, { 0x12, 0x13, 0x10, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x36, 0x20, 0xe7, 0x03, 0x30, 0x0b, 0x61, 0xc2}},
+ {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0xc1, 0x12, 0x0c, 0xc8, 0xd2, 0x03, 0xe4, 0x90, 0x7f}},
+ {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x60, 0x12, 0x11, 0xe4, 0x8f}},
+ {0x00e6, 16, { 0x19, 0x12, 0x13, 0x33, 0x8f, 0x36, 0xe5, 0x19, 0xc3, 0x95, 0x3a, 0x50, 0x0f, 0x12, 0x13, 0x0f}},
+ {0x00f6, 16, { 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x36, 0x20, 0xe7, 0x03, 0x30, 0x0b, 0x5e, 0xc2, 0x0b, 0xe5, 0x19}},
  {0x0036, 12, { 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22}},
- {0x0043,  3, { 0x02, 0x14, 0x00}},
- {0x0000,  3, { 0x02, 0x0e, 0x1e}},
- {0x0106, 64, { 0x0b, 0xe5, 0x19, 0x70, 0x04, 0xf5, 0x36, 0x80, 0x57, 0x12, 0x13, 0x34, 0xef, 0x42, 0x36, 0xe5, 0x36,
-  0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08,
-  0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x80, 0xaf, 0x36, 0x12, 0x0f, 0x69, 0xe5,
-  0x19, 0x25, 0xe0, 0x90, 0x7f, 0xb7, 0xf0, 0x80, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40}},
- {0x0146, 64, { 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08, 0xe4, 0x90, 0x7e, 0x80, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75,
-  0x0c, 0x7e, 0x75, 0x0d, 0x81, 0x12, 0x0c, 0xfd, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90,
-  0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x05, 0x03, 0x02, 0x03, 0xc5, 0xc2, 0x05, 0xe4, 0xf5,
-  0x18, 0x74, 0x40, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5}},
- {0x0186, 64, { 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef,
-  0x12, 0x0e, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x68,
-  0x90, 0x7e, 0x03, 0xe0, 0x60, 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xd6, 0x7f, 0x03, 0x7d,
-  0xcd, 0x12, 0x11, 0xd6, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0}},
- {0x01c6, 64, { 0x00, 0xe5, 0x46, 0xf0, 0xe4, 0x90, 0x7e, 0x13, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12,
-  0x10, 0x5a, 0x90, 0x7e, 0x02, 0xe0, 0xff, 0x12, 0x10, 0x80, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0,
-  0xfd, 0x12, 0x11, 0xd6, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xd6, 0x43, 0x46, 0x80, 0x90, 0x7f,
-  0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12}},
- {0x0206, 64, { 0xf0, 0xe5, 0x40, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x03, 0xe0, 0x70, 0x06, 0x90, 0x7e,
-  0x13, 0xe0, 0x70, 0x08, 0xe4, 0x90, 0x7e, 0x13, 0xf0, 0x75, 0x25, 0xff, 0x90, 0x7e, 0x05, 0xe0,
-  0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x44, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0,
-  0x00, 0xe5, 0x44, 0xf0, 0x90, 0x7e, 0x07, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43}},
- {0x0246, 64, { 0x42, 0x80, 0x80, 0x03, 0x53, 0x42, 0x7f, 0x53, 0x42, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43,
-  0x42, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x10, 0xcc, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x10, 0xf2,
-  0xaf, 0x42, 0x12, 0x10, 0xa6, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x08, 0x53, 0x42, 0x7f, 0xaf, 0x42,
-  0x12, 0x10, 0xa6, 0x90, 0x7e, 0x0c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46}},
- {0x0286, 64, { 0x02, 0x80, 0x03, 0x53, 0x46, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46,
-  0xf0, 0x90, 0x7e, 0x0e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x01, 0x80, 0x03,
-  0x53, 0x46, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90,
-  0x7e, 0x12, 0xe0, 0xf5, 0x3a, 0xa3, 0xe0, 0x13, 0x92, 0x0d, 0xa3, 0xe0, 0xf5, 0x3c, 0xa3}},
- {0x02c6, 64, { 0xe0, 0x60, 0x05, 0x43, 0x46, 0x10, 0x80, 0x03, 0x53, 0x46, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0,
-  0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x44, 0xbf, 0x90,
-  0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x11, 0xf0, 0x12, 0x13, 0x04, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3e}},
- {0x0306, 64, { 0xfd, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xd6, 0xe4, 0xf5, 0x2a, 0xf5, 0x29, 0xd2, 0x07, 0x90, 0x7e,
-  0x17, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x02, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xd6, 0x75, 0x29,
-  0x01, 0xd2, 0x07, 0x90, 0x7e, 0x18, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5,
-  0x40, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11}},
- {0x0346, 64, { 0x43, 0x44, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
-  0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f, 0x53, 0x3e, 0xfe, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xd6,
-  0x75, 0x2b, 0x01, 0xd2, 0x07, 0x90, 0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x01, 0xe4, 0xff,
-  0xad, 0x3e, 0x12, 0x11, 0xd6, 0xe4, 0xf5, 0x2b, 0xd2, 0x07, 0x90, 0x7e, 0x1c, 0xe0, 0x60}},
- {0x0386, 64, { 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
-  0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x0b, 0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x2c, 0x01, 0xe4,
-  0xf5, 0x38, 0xd2, 0x07, 0x90, 0x7e, 0x1f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0,
-  0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0, 0x74, 0x35, 0xf0, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30}},
- {0x03c6, 64, { 0x1a, 0x52, 0xe5, 0x38, 0x60, 0x02, 0x15, 0x38, 0x20, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40,
-  0x04, 0x15, 0x13, 0x80, 0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xd2, 0x13, 0x12, 0x13, 0x04,
-  0xef, 0x54, 0x01, 0xf5, 0x19, 0x65, 0x2a, 0x60, 0x05, 0x85, 0x19, 0x2a, 0xd2, 0x07, 0x12, 0x13,
-  0x40, 0xef, 0x54, 0x80, 0xf5, 0x19, 0x65, 0x26, 0x60, 0x05, 0x85, 0x19, 0x26, 0xd2, 0x07}},
- {0x0406, 64, { 0x30, 0x0d, 0x11, 0x12, 0x13, 0x40, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x25, 0x60, 0x05, 0x85, 0x19,
-  0x25, 0xd2, 0x07, 0x20, 0x1b, 0x03, 0x02, 0x07, 0xf4, 0x30, 0x0a, 0x18, 0x12, 0x13, 0x7c, 0xef,
-  0xc3, 0x95, 0x3d, 0x40, 0x03, 0x02, 0x04, 0xb2, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0xc2, 0x0a,
-  0xc2, 0x00, 0x80, 0x77, 0x30, 0x04, 0x3b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x6d, 0x12}},
- {0x0446, 64, { 0x13, 0x7c, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f,
-  0xcb, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d, 0x7f, 0x41,
-  0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x41, 0x12, 0x0d, 0x22, 0xc2, 0x04, 0xe4, 0x90, 0x7f, 0xcb, 0xf0,
-  0x80, 0x39, 0x90, 0x7f, 0xcc, 0xe0, 0x20, 0xe1, 0x32, 0x12, 0x13, 0x7c, 0xef, 0xc3, 0x94}},
- {0x0486, 64, { 0x40, 0x50, 0x29, 0x90, 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcd, 0xe0, 0x14, 0xf5, 0x19,
-  0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7c, 0x7f, 0xc1, 0x75, 0x0c, 0x7c, 0x75, 0x0d,
-  0xc1, 0x12, 0x0d, 0x22, 0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xba, 0xe0, 0x30,
-  0xe1, 0x03, 0x02, 0x05, 0x40, 0x53, 0x37, 0x80, 0x12, 0x13, 0x88, 0xef, 0x42, 0x37, 0x12}},
- {0x04c6, 64, { 0x12, 0x45, 0x8f, 0x19, 0xef, 0xc3, 0x95, 0x3b, 0x50, 0x0f, 0x12, 0x13, 0x64, 0xef, 0x30, 0xe0, 0x08,
-  0xe5, 0x37, 0x20, 0xe7, 0x03, 0x30, 0x0c, 0x61, 0xc2, 0x0c, 0xe5, 0x19, 0x70, 0x04, 0xf5, 0x37,
-  0x80, 0x57, 0x12, 0x13, 0x88, 0xef, 0x42, 0x37, 0xe5, 0x37, 0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3,
-  0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e, 0x7d, 0x7f, 0x80, 0x75}},
- {0x0506, 64, { 0x0c, 0x7d, 0x75, 0x0d, 0x80, 0xaf, 0x37, 0x12, 0x0f, 0xa2, 0xe5, 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xbb,
-  0xf0, 0x80, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08,
-  0xe4, 0x90, 0x7d, 0x80, 0xf0, 0x7e, 0x7d, 0x7f, 0x81, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x81, 0x12,
-  0x0d, 0x47, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xbb, 0xf0, 0x90, 0x7f, 0xd0, 0xe0, 0x30, 0xe1}},
- {0x0546, 64, { 0x06, 0x20, 0x06, 0x03, 0x02, 0x07, 0x9f, 0xc2, 0x06, 0xe4, 0xf5, 0x18, 0x74, 0xc0, 0x25, 0x18, 0xf5,
-  0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e,
-  0x79, 0x20, 0x24, 0x20, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e, 0xf0, 0x05, 0x18, 0xe5,
-  0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x20, 0xe0, 0x60, 0x68, 0x90, 0x7e, 0x23, 0xe0, 0x60}},
- {0x0586, 64, { 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x12, 0x20, 0x7f, 0x03, 0x7d, 0xcd, 0x12, 0x12, 0x20, 0x43, 0x47,
-  0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0xe4, 0x90, 0x7e,
-  0x33, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x21, 0xe0, 0xff, 0x12, 0x11, 0x3e, 0x90, 0x7e, 0x22, 0xe0,
-  0xff, 0x12, 0x11, 0x64, 0x7f, 0x01, 0x90, 0x7e, 0x31, 0xe0, 0xfd, 0x12, 0x12, 0x20, 0x7f}},
- {0x05c6, 64, { 0x03, 0x7d, 0x07, 0x12, 0x12, 0x20, 0x43, 0x47, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0,
-  0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x06, 0x90, 0xc0,
-  0x00, 0xf0, 0x90, 0x7e, 0x23, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x33, 0xe0, 0x70, 0x08, 0xe4, 0x90,
-  0x7e, 0x33, 0xf0, 0x75, 0x2e, 0xff, 0x90, 0x7e, 0x25, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54}},
- {0x0606, 64, { 0x3f, 0xf5, 0x45, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x45, 0xf0, 0x90, 0x7e,
-  0x27, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x43, 0x80, 0x80, 0x03, 0x53, 0x43, 0x7f,
-  0x53, 0x43, 0xfc, 0x90, 0x7e, 0x29, 0xe0, 0x60, 0x11, 0x43, 0x43, 0x02, 0xa3, 0xe0, 0xff, 0x12,
-  0x11, 0x8a, 0x90, 0x7e, 0x2b, 0xe0, 0xff, 0x12, 0x11, 0xb0, 0xaf, 0x43, 0x12, 0x11, 0x18}},
- {0x0646, 64, { 0x90, 0x7e, 0x23, 0xe0, 0x60, 0x08, 0x53, 0x43, 0x7f, 0xaf, 0x43, 0x12, 0x11, 0x18, 0x90, 0x7e, 0x2c,
-  0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x02, 0x80, 0x03, 0x53, 0x47, 0xfd, 0x90,
-  0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x2e, 0xe0, 0x60,
-  0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x01, 0x80, 0x03, 0x53, 0x47, 0xfe, 0x90, 0x7f}},
- {0x0686, 64, { 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x32, 0xe0, 0xf5, 0x3b, 0xa3,
-  0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x10, 0x80,
-  0x03, 0x53, 0x47, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0,
-  0x90, 0x7e, 0x36, 0xe0, 0x60, 0x32, 0x53, 0x45, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0}},
- {0x06c6, 64, { 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x12, 0x13, 0x58,
-  0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3f, 0xfd, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12,
-  0x20, 0xe4, 0xf5, 0x33, 0xf5, 0x32, 0xd2, 0x08, 0x90, 0x7e, 0x37, 0xe0, 0x60, 0x0f, 0x43, 0x3f,
-  0x02, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x20, 0x75, 0x32, 0x01, 0xd2, 0x08, 0x90, 0x7e}},
- {0x0706, 64, { 0x38, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x04, 0x90, 0xc0, 0x00,
-  0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x39, 0xe0, 0x60, 0x11, 0x43, 0x45, 0x40, 0x90, 0x7f, 0x98, 0x74,
-  0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x3a, 0xe0, 0x60, 0x0f,
-  0x53, 0x3f, 0xfe, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x20, 0x75, 0x34, 0x01, 0xd2, 0x08}},
- {0x0746, 64, { 0x90, 0x7e, 0x3b, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x01, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x20, 0xe4,
-  0xf5, 0x34, 0xd2, 0x08, 0x90, 0x7e, 0x3c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
-  0xe5, 0x41, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x3d, 0xe0, 0x60, 0x02, 0xd2, 0x0c,
-  0x90, 0x7e, 0x3e, 0xe0, 0x60, 0x08, 0x75, 0x35, 0x01, 0xe4, 0xf5, 0x39, 0xd2, 0x08, 0x90}},
- {0x0786, 64, { 0x7e, 0x3f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7, 0x74, 0x13, 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x16, 0xf0,
-  0x74, 0x36, 0xf0, 0xe4, 0x90, 0x7f, 0xd1, 0xf0, 0x30, 0x1a, 0x52, 0xe5, 0x39, 0x60, 0x02, 0x15,
-  0x39, 0x30, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80, 0x3e, 0x75,
-  0x13, 0x0a, 0x30, 0x1b, 0x02, 0xc2, 0x13, 0x12, 0x13, 0x58, 0xef, 0x54, 0x01, 0xf5, 0x19}},
- {0x07c6, 64, { 0x65, 0x33, 0x60, 0x05, 0x85, 0x19, 0x33, 0xd2, 0x08, 0x12, 0x13, 0x94, 0xef, 0x54, 0x80, 0xf5, 0x19,
-  0x65, 0x2f, 0x60, 0x05, 0x85, 0x19, 0x2f, 0xd2, 0x08, 0x30, 0x0e, 0x11, 0x12, 0x13, 0x94, 0xef,
-  0x54, 0x10, 0xf5, 0x19, 0x65, 0x2e, 0x60, 0x05, 0x85, 0x19, 0x2e, 0xd2, 0x08, 0x30, 0x1a, 0x2a,
-  0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90, 0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5}},
- {0x0806, 64, { 0x15, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x16, 0x90, 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74,
-  0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f, 0xd3, 0xf0, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1,
-  0x03, 0x02, 0x09, 0x28, 0xe5, 0x0a, 0x70, 0x40, 0x30, 0x07, 0x39, 0xe5, 0x38, 0x70, 0x35, 0xc2,
-  0x07, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
- {0x0846, 64, { 0xfa, 0x12, 0x0e, 0xaa, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
-  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x38,
-  0x10, 0xe4, 0xf5, 0x2c, 0x75, 0x0a, 0x01, 0x22, 0xe5, 0x0a, 0x64, 0x01, 0x70, 0x40, 0x30, 0x08,
-  0x39, 0xe5, 0x39, 0x70, 0x35, 0xc2, 0x08, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2d}},
- {0x0886, 64, { 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0xaa, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82,
-  0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f,
-  0xc3, 0x74, 0x09, 0xf0, 0x75, 0x39, 0x10, 0xe4, 0xf5, 0x35, 0x75, 0x0a, 0x02, 0x22, 0xe5, 0x0a,
-  0x64, 0x02, 0x70, 0x36, 0x30, 0x14, 0x2f, 0xc2, 0x14, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00}},
- {0x08c6, 64, { 0x74, 0x0e, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0xaa, 0xff, 0x74, 0x80, 0x25, 0x18,
-  0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x05, 0xdb,
-  0x90, 0x7f, 0xc3, 0x74, 0x05, 0xf0, 0x75, 0x0a, 0x03, 0x22, 0xe5, 0x15, 0x60, 0x30, 0x15, 0x15,
-  0xe4, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x14, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
- {0x0906, 64, { 0xfa, 0x12, 0x0e, 0xaa, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
-  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5,
-  0x0a, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0f, 0x02, 0x0a, 0x10, 0x00, 0x0a, 0x84, 0x01, 0x0a,
-  0xf0, 0x03, 0x09, 0x4c, 0x06, 0x0a, 0x03, 0x08, 0x09, 0xfd, 0x09, 0x09, 0xe5, 0x0a, 0x09}},
- {0x0946, 64, { 0xf4, 0x0b, 0x00, 0x00, 0x0b, 0x3f, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x14, 0x60, 0x61,
-  0x24, 0x02, 0x60, 0x03, 0x02, 0x09, 0xdb, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90,
-  0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02,
-  0x7f, 0x03, 0x75, 0x82, 0x82, 0x75, 0x83, 0x19, 0xef, 0xf0, 0x75, 0x82, 0x7b, 0x75, 0x83}},
- {0x0986, 64, { 0x19, 0xf0, 0x75, 0x82, 0x74, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x66, 0x75, 0x83, 0x19, 0xf0, 0x75,
-  0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f, 0xea, 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83,
-  0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x12, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b,
-  0x46, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0f, 0x28, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90}},
- {0x09c6, 64, { 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01,
-  0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f,
-  0x00, 0xe5, 0x09, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea,
-  0xe0, 0xf5, 0x09, 0x02, 0x0b, 0x46, 0x12, 0x0b, 0x4e, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0x00}},
- {0x0a06, 64, { 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60,
-  0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b, 0xa2, 0x10, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff,
-  0xa2, 0x16, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74,
-  0x02, 0xf0, 0x02, 0x0b, 0x46, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5}},
- {0x0a46, 64, { 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f,
-  0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83,
-  0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0,
-  0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x46, 0x90, 0x7f}},
- {0x0a86, 64, { 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0,
-  0xb4, 0x01, 0x05, 0xc2, 0x10, 0x02, 0x0b, 0x46, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02,
-  0x0b, 0x46, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff,
-  0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4}},
- {0x0ac6, 64, { 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54,
-  0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f,
-  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60,
-  0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x10, 0x80}},
- {0x0b06, 64, { 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90,
-  0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25,
-  0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90,
-  0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0}},
- {0x0b46, 64, { 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74,
-  0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e,
-  0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x18, 0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74,
-  0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xe4, 0xf5, 0x24, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74}},
- {0x0b86, 64, { 0x24, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4,
-  0x09, 0xea, 0x75, 0x3a, 0x01, 0xe4, 0xf5, 0x38, 0xf5, 0x13, 0xf5, 0x36, 0xc2, 0x07, 0xc2, 0x0b,
-  0xc2, 0x05, 0xc2, 0x00, 0xc2, 0x09, 0xc2, 0x13, 0xd2, 0x03, 0xd2, 0x01, 0x90, 0x7f, 0x98, 0x74,
-  0x13, 0xf0, 0x75, 0x44, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd}},
- {0x0bc6, 64, { 0x12, 0x11, 0xd6, 0x7f, 0x10, 0x8f, 0x42, 0x12, 0x10, 0xa6, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x7f,
-  0x01, 0x8f, 0x40, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0,
-  0x75, 0x46, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x11, 0xd6, 0xe4,
-  0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3e, 0x12, 0x11, 0xd6, 0x90, 0x7f, 0x98, 0x74, 0x11}},
- {0x0c06, 64, { 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x11, 0xd6, 0x7f, 0x01, 0x12, 0x12,
-  0x8f, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xd6, 0x7f, 0x13, 0x7d, 0x01, 0x12, 0x11, 0xd6, 0x20,
-  0x1b, 0x03, 0x02, 0x0c, 0xd5, 0x75, 0x2d, 0x01, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x2d, 0x25,
-  0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4}},
- {0x0c46, 64, { 0x09, 0xea, 0x75, 0x3b, 0x01, 0xe4, 0xf5, 0x39, 0xf5, 0x13, 0xf5, 0x37, 0xc2, 0x08, 0xc2, 0x0c, 0xc2,
-  0x06, 0xc2, 0x00, 0xc2, 0x0a, 0xc2, 0x13, 0xd2, 0x04, 0xd2, 0x02, 0x90, 0x7f, 0x98, 0x74, 0x0b,
+ {0x0043,  3, { 0x02, 0x13, 0x00}},
+ {0x0000,  3, { 0x02, 0x0e, 0x0e}},
+ {0x0106, 64, { 0x60, 0x58, 0xb4, 0x80, 0x03, 0x43, 0x36, 0x02, 0xe5, 0x36, 0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94,
+  0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x0c, 0x7e,
+  0x75, 0x0d, 0x80, 0xaf, 0x36, 0x12, 0x0f, 0x59, 0xe5, 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xb7, 0xf0,
+  0x80, 0x27, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08}},
+ {0x0146, 64, { 0x90, 0x7e, 0x80, 0xe5, 0x36, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x81, 0x12,
+  0x0c, 0xed, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90, 0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06,
+  0x20, 0x05, 0x03, 0x02, 0x03, 0xc1, 0xc2, 0x05, 0xe4, 0xf5, 0x18, 0x74, 0x40, 0x25, 0x18, 0xf5,
+  0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a}},
+ {0x0186, 64, { 0x7e, 0x79, 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e, 0xe0, 0x05, 0x18, 0xe5,
+  0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x68, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x24,
+  0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xbf, 0x7f, 0x03, 0x7d, 0xcd, 0x12, 0x11, 0xbf, 0x43, 0x46,
+  0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0xe4, 0x90}},
+ {0x01c6, 64, { 0x7e, 0x13, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12, 0x10, 0x43, 0x90, 0x7e, 0x02, 0xe0,
+  0xff, 0x12, 0x10, 0x69, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0, 0xfd, 0x12, 0x11, 0xbf, 0x7f, 0x03,
+  0x7d, 0x07, 0x12, 0x11, 0xbf, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0,
+  0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x06, 0x90}},
+ {0x0206, 64, { 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x03, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x13, 0xe0, 0x70, 0x08, 0xe4, 0x90,
+  0x7e, 0x13, 0xf0, 0x75, 0x25, 0xff, 0x90, 0x7e, 0x05, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f,
+  0xf5, 0x44, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x44, 0xf0, 0x90, 0x7e,
+  0x07, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x42, 0x80, 0x80, 0x03, 0x53, 0x42}},
+ {0x0246, 64, { 0x7f, 0x53, 0x42, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43, 0x42, 0x02, 0xa3, 0xe0, 0xff, 0x12,
+  0x10, 0xb5, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x10, 0xdb, 0xaf, 0x42, 0x12, 0x10, 0x8f, 0x90,
+  0x7e, 0x03, 0xe0, 0x60, 0x08, 0x53, 0x42, 0x7f, 0xaf, 0x42, 0x12, 0x10, 0x8f, 0x90, 0x7e, 0x0c,
+  0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x02, 0x80, 0x03, 0x53, 0x46, 0xfd}},
+ {0x0286, 64, { 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x0e, 0xe0, 0x60,
+  0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x01, 0x80, 0x03, 0x53, 0x46, 0xfe, 0x90, 0x7f, 0x98,
+  0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x12, 0xe0, 0xf5, 0x3a, 0xa3,
+  0xe0, 0x13, 0x92, 0x0d, 0xa3, 0xe0, 0xf5, 0x3c, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x10}},
+ {0x02c6, 64, { 0x80, 0x03, 0x53, 0x46, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0,
+  0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x44, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5,
+  0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x12, 0x12, 0xed,
+  0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3e, 0xfd, 0xe4, 0xff, 0xad, 0x3e, 0x12}},
+ {0x0306, 64, { 0x11, 0xbf, 0xe4, 0xf5, 0x2a, 0xf5, 0x29, 0xd2, 0x07, 0x90, 0x7e, 0x17, 0xe0, 0x60, 0x0f, 0x43, 0x3e,
+  0x02, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xbf, 0x75, 0x29, 0x01, 0xd2, 0x07, 0x90, 0x7e, 0x18,
+  0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x04, 0x90, 0xc0, 0x00,
+  0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11, 0x43, 0x44, 0x40, 0x90, 0x7f, 0x98}},
+ {0x0346, 64, { 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f,
+  0x53, 0x3e, 0xfe, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xbf, 0x75, 0x2b, 0x01, 0xd2, 0x07, 0x90,
+  0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x01, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xbf, 0xe4,
+  0xf5, 0x2b, 0xd2, 0x07, 0x90, 0x7e, 0x1c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12}},
+ {0x0386, 64, { 0xf0, 0xe5, 0x40, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x0b,
+  0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x2c, 0x01, 0xe4, 0xf5, 0x38, 0xd2, 0x07, 0x90, 0x7e,
+  0x1f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0,
+  0x74, 0x35, 0xf0, 0xd2, 0x03, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30, 0x1a, 0x52, 0xe5, 0x38}},
+ {0x03c6, 64, { 0x60, 0x02, 0x15, 0x38, 0x20, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80,
+  0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xd2, 0x13, 0x12, 0x12, 0xed, 0xef, 0x54, 0x01, 0xf5,
+  0x19, 0x65, 0x2a, 0x60, 0x05, 0x85, 0x19, 0x2a, 0xd2, 0x07, 0x12, 0x13, 0x3f, 0xef, 0x54, 0x80,
+  0xf5, 0x19, 0x65, 0x26, 0x60, 0x05, 0x85, 0x19, 0x26, 0xd2, 0x07, 0x30, 0x0d, 0x11, 0x12}},
+ {0x0406, 64, { 0x13, 0x3f, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x25, 0x60, 0x05, 0x85, 0x19, 0x25, 0xd2, 0x07, 0x20,
+  0x1b, 0x03, 0x02, 0x07, 0xec, 0x30, 0x0a, 0x18, 0x12, 0x13, 0x7b, 0xef, 0xc3, 0x95, 0x3d, 0x40,
+  0x03, 0x02, 0x04, 0xae, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0xc2, 0x0a, 0xc2, 0x00, 0x80, 0x77,
+  0x30, 0x04, 0x3b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x7b, 0xef, 0xc3}},
+ {0x0446, 64, { 0x94, 0x40, 0x50, 0x64, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcb, 0xe0, 0x14, 0xf5,
+  0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d, 0x7f, 0x41, 0x75, 0x0c, 0x7d, 0x75,
+  0x0d, 0x41, 0x12, 0x0d, 0x12, 0xc2, 0x04, 0xe4, 0x90, 0x7f, 0xcb, 0xf0, 0x80, 0x39, 0x90, 0x7f,
+  0xcc, 0xe0, 0x20, 0xe1, 0x32, 0x12, 0x13, 0x7b, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90}},
+ {0x0486, 64, { 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcd, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60,
+  0x0f, 0xf5, 0x08, 0x7e, 0x7c, 0x7f, 0xc1, 0x75, 0x0c, 0x7c, 0x75, 0x0d, 0xc1, 0x12, 0x0d, 0x12,
+  0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xba, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x05,
+  0x36, 0x12, 0x12, 0x2e, 0x8f, 0x19, 0x12, 0x13, 0x87, 0x8f, 0x37, 0xe5, 0x19, 0xc3, 0x95}},
+ {0x04c6, 64, { 0x3b, 0x50, 0x0f, 0x12, 0x13, 0x63, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x37, 0x20, 0xe7, 0x03, 0x30, 0x0c,
+  0x5e, 0xc2, 0x0c, 0xe5, 0x19, 0x60, 0x58, 0xb4, 0x80, 0x03, 0x43, 0x37, 0x02, 0xe5, 0x37, 0x30,
+  0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e,
+  0x7d, 0x7f, 0x80, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x80, 0xaf, 0x37, 0x12, 0x0f, 0x92, 0xe5}},
+ {0x0506, 64, { 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xbb, 0xf0, 0x80, 0x27, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75,
+  0x19, 0x3f, 0x85, 0x19, 0x08, 0x90, 0x7d, 0x80, 0xe5, 0x37, 0xf0, 0x7e, 0x7d, 0x7f, 0x81, 0x75,
+  0x0c, 0x7d, 0x75, 0x0d, 0x81, 0x12, 0x0d, 0x37, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xbb, 0xf0, 0x90,
+  0x7f, 0xd0, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x06, 0x03, 0x02, 0x07, 0x97, 0xc2, 0x06, 0xe4}},
+ {0x0546, 64, { 0xf5, 0x18, 0x74, 0xc0, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18,
+  0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x20, 0x24, 0x20, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef,
+  0x12, 0x0e, 0xe0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x20, 0xe0, 0x60, 0x68,
+  0x90, 0x7e, 0x23, 0xe0, 0x60, 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x12, 0x09, 0x7f, 0x03}},
+ {0x0586, 64, { 0x7d, 0xcd, 0x12, 0x12, 0x09, 0x43, 0x47, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00,
+  0xe5, 0x47, 0xf0, 0xe4, 0x90, 0x7e, 0x33, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x21, 0xe0, 0xff, 0x12,
+  0x11, 0x27, 0x90, 0x7e, 0x22, 0xe0, 0xff, 0x12, 0x11, 0x4d, 0x7f, 0x01, 0x90, 0x7e, 0x31, 0xe0,
+  0xfd, 0x12, 0x12, 0x09, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x12, 0x09, 0x43, 0x47, 0x80, 0x90}},
+ {0x05c6, 64, { 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
+  0xe5, 0x41, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x23, 0xe0, 0x70, 0x06, 0x90, 0x7e,
+  0x33, 0xe0, 0x70, 0x08, 0xe4, 0x90, 0x7e, 0x33, 0xf0, 0x75, 0x2e, 0xff, 0x90, 0x7e, 0x25, 0xe0,
+  0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x45, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90}},
+ {0x0606, 64, { 0xc0, 0x00, 0xe5, 0x45, 0xf0, 0x90, 0x7e, 0x27, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x43,
+  0x80, 0x80, 0x03, 0x53, 0x43, 0x7f, 0x53, 0x43, 0xfc, 0x90, 0x7e, 0x29, 0xe0, 0x60, 0x11, 0x43,
+  0x43, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x11, 0x73, 0x90, 0x7e, 0x2b, 0xe0, 0xff, 0x12, 0x11, 0x99,
+  0xaf, 0x43, 0x12, 0x11, 0x01, 0x90, 0x7e, 0x23, 0xe0, 0x60, 0x08, 0x53, 0x43, 0x7f, 0xaf}},
+ {0x0646, 64, { 0x43, 0x12, 0x11, 0x01, 0x90, 0x7e, 0x2c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x02,
+  0x80, 0x03, 0x53, 0x47, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47,
+  0xf0, 0x90, 0x7e, 0x2e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x01, 0x80, 0x03,
+  0x53, 0x47, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0}},
+ {0x0686, 64, { 0x90, 0x7e, 0x32, 0xe0, 0xf5, 0x3b, 0xa3, 0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0,
+  0x60, 0x05, 0x43, 0x47, 0x10, 0x80, 0x03, 0x53, 0x47, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0,
+  0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x36, 0xe0, 0x60, 0x32, 0x53, 0x45, 0xbf, 0x90,
+  0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f}},
+ {0x06c6, 64, { 0x98, 0x74, 0x09, 0xf0, 0x12, 0x13, 0x57, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3f, 0xfd,
+  0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x09, 0xe4, 0xf5, 0x33, 0xf5, 0x32, 0xd2, 0x08, 0x90, 0x7e,
+  0x37, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x02, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x09, 0x75, 0x32,
+  0x01, 0xd2, 0x08, 0x90, 0x7e, 0x38, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0}},
+ {0x0706, 64, { 0xe5, 0x41, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x39, 0xe0, 0x60, 0x11, 0x43,
+  0x45, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
+  0x90, 0x7e, 0x3a, 0xe0, 0x60, 0x0f, 0x53, 0x3f, 0xfe, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x09,
+  0x75, 0x34, 0x01, 0xd2, 0x08, 0x90, 0x7e, 0x3b, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x01, 0xe4}},
+ {0x0746, 64, { 0xff, 0xad, 0x3f, 0x12, 0x12, 0x09, 0xe4, 0xf5, 0x34, 0xd2, 0x08, 0x90, 0x7e, 0x3c, 0xe0, 0x60, 0x0e,
+  0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
+  0x3d, 0xe0, 0x60, 0x02, 0xd2, 0x0c, 0x90, 0x7e, 0x3e, 0xe0, 0x60, 0x08, 0x75, 0x35, 0x01, 0xe4,
+  0xf5, 0x39, 0xd2, 0x08, 0x90, 0x7e, 0x3f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x13}},
+ {0x0786, 64, { 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x16, 0xf0, 0x74, 0x36, 0xf0, 0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xd1, 0xf0,
+  0x30, 0x1a, 0x52, 0xe5, 0x39, 0x60, 0x02, 0x15, 0x39, 0x30, 0x13, 0x49, 0xe5, 0x13, 0xd3, 0x94,
+  0x00, 0x40, 0x04, 0x15, 0x13, 0x80, 0x3e, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xc2, 0x13, 0x12,
+  0x13, 0x57, 0xef, 0x54, 0x01, 0xf5, 0x19, 0x65, 0x33, 0x60, 0x05, 0x85, 0x19, 0x33, 0xd2}},
+ {0x07c6, 64, { 0x08, 0x12, 0x13, 0x93, 0xef, 0x54, 0x80, 0xf5, 0x19, 0x65, 0x2f, 0x60, 0x05, 0x85, 0x19, 0x2f, 0xd2,
+  0x08, 0x30, 0x0e, 0x11, 0x12, 0x13, 0x93, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x2e, 0x60, 0x05,
+  0x85, 0x19, 0x2e, 0xd2, 0x08, 0x30, 0x1a, 0x2a, 0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90,
+  0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5, 0x15, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x16, 0x90}},
+ {0x0806, 64, { 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f,
+  0xd3, 0xf0, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x09, 0x20, 0xe5, 0x0a, 0x70, 0x40,
+  0x30, 0x07, 0x39, 0xe5, 0x38, 0x70, 0x35, 0xc2, 0x07, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74,
+  0x24, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9a, 0xff, 0x74, 0x80, 0x25}},
+ {0x0846, 64, { 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb,
+  0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x38, 0x10, 0xe4, 0xf5, 0x2c, 0x75, 0x0a, 0x01, 0x22,
+  0xe5, 0x0a, 0x64, 0x01, 0x70, 0x40, 0x30, 0x08, 0x39, 0xe5, 0x39, 0x70, 0x35, 0xc2, 0x08, 0xf5,
+  0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12}},
+ {0x0886, 64, { 0x0e, 0x9a, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05,
+  0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x39, 0x10, 0xe4,
+  0xf5, 0x35, 0x75, 0x0a, 0x02, 0x22, 0xe5, 0x0a, 0x64, 0x02, 0x70, 0x36, 0x30, 0x14, 0x2f, 0xc2,
+  0x14, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x0e, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00}},
+ {0x08c6, 64, { 0xfa, 0x12, 0x0e, 0x9a, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef,
+  0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x05, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x05, 0xf0, 0x75, 0x0a,
+  0x03, 0x22, 0xe5, 0x15, 0x60, 0x30, 0x15, 0x15, 0xe4, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74,
+  0x14, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9a, 0xff, 0x74, 0x80, 0x25}},
+ {0x0906, 64, { 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x03, 0xdb,
+  0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x0a, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0e,
+  0xf2, 0x0a, 0x08, 0x00, 0x0a, 0x7c, 0x01, 0x0a, 0xe8, 0x03, 0x09, 0x44, 0x06, 0x09, 0xfb, 0x08,
+  0x09, 0xf5, 0x09, 0x09, 0xdd, 0x0a, 0x09, 0xec, 0x0b, 0x00, 0x00, 0x0b, 0x37, 0x90, 0x7f}},
+ {0x0946, 64, { 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x14, 0x60, 0x61, 0x24, 0x02, 0x60, 0x03, 0x02, 0x09, 0xd3, 0x74,
+  0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f,
+  0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03, 0x75, 0x82, 0x82, 0x75, 0x83, 0x19,
+  0xef, 0xf0, 0x75, 0x82, 0x7b, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x74, 0x75, 0x83, 0x19}},
+ {0x0986, 64, { 0xf0, 0x75, 0x82, 0x66, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f,
+  0xea, 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83, 0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0,
+  0x74, 0x12, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0f,
+  0x18, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90, 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0}},
+ {0x09c6, 64, { 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0,
+  0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0x00, 0xe5, 0x09, 0xf0, 0x90, 0x7f, 0xb5, 0x74,
+  0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x09, 0x02, 0x0b, 0x3e, 0x12, 0x0b,
+  0x46, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0x00, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02}},
+ {0x0a06, 64, { 0x0b, 0x3e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b,
+  0xa2, 0x10, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff, 0xa2, 0x16, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00,
+  0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0xe4, 0x90, 0x7f,
+  0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f}},
+ {0x0a46, 64, { 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24,
+  0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4,
+  0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
+  0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02}},
+ {0x0a86, 64, { 0x60, 0x03, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x05, 0xc2, 0x10, 0x02, 0x0b, 0x3e,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x3e, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38,
+  0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f,
+  0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f}},
+ {0x0ac6, 64, { 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f,
+  0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80,
+  0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea,
+  0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x10, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0}},
+ {0x0b06, 64, { 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4,
+  0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f,
+  0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22}},
+ {0x0b46, 64, { 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90,
+  0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x18,
+  0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xe4, 0xf5,
+  0x24, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa}},
+ {0x0b86, 64, { 0xe4, 0x12, 0x0e, 0xe0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3a, 0x01, 0xe4, 0xf5, 0x38,
+  0xf5, 0x13, 0xf5, 0x36, 0xc2, 0x07, 0xc2, 0x0b, 0xc2, 0x05, 0xc2, 0x00, 0xc2, 0x09, 0xc2, 0x13,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x75, 0x44, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f,
+  0x0c, 0xe4, 0xfd, 0x12, 0x11, 0xbf, 0x7f, 0x10, 0x8f, 0x42, 0x12, 0x10, 0x8f, 0x90, 0x7f}},
+ {0x0bc6, 64, { 0x98, 0x74, 0x12, 0xf0, 0x7f, 0x01, 0x8f, 0x40, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x14, 0xf0, 0x75, 0x46, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd,
+  0x12, 0x11, 0xbf, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3e, 0x12, 0x11, 0xbf, 0x90, 0x7f,
+  0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x11}},
+ {0x0c06, 64, { 0xbf, 0x7f, 0x01, 0x12, 0x12, 0x78, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xbf, 0x7f, 0x13, 0x7d, 0x01,
+  0x12, 0x11, 0xbf, 0x20, 0x1b, 0x03, 0x02, 0x0c, 0xc5, 0x75, 0x2d, 0x01, 0x75, 0x18, 0x01, 0x7b,
+  0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xe0, 0x05, 0x18,
+  0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3b, 0x01, 0xe4, 0xf5, 0x39, 0xf5, 0x13, 0xf5, 0x37}},
+ {0x0c46, 64, { 0xc2, 0x08, 0xc2, 0x0c, 0xc2, 0x06, 0xc2, 0x00, 0xc2, 0x0a, 0xc2, 0x13, 0x90, 0x7f, 0x98, 0x74, 0x0b,
   0xf0, 0x75, 0x45, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x12,
-  0x20, 0x7f, 0x10, 0x8f, 0x43, 0x12, 0x11, 0x18, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x7f}},
- {0x0c86, 64, { 0x01, 0x8f, 0x41, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x75,
-  0x47, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x12, 0x20, 0xe4, 0xff,
-  0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3f, 0x12, 0x12, 0x20, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90,
-  0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x12, 0x20, 0x7f, 0x01, 0x12, 0x12}},
- {0x0cc6, 64, { 0xb0, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x12, 0x20, 0x7f, 0x13, 0x7d, 0x01, 0x12, 0x12, 0x20, 0xd2, 0x12,
-  0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5,
+  0x09, 0x7f, 0x10, 0x8f, 0x43, 0x12, 0x11, 0x01, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x7f, 0x01,
+  0x8f, 0x41, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0}},
+ {0x0c86, 64, { 0x75, 0x47, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x12, 0x09, 0xe4, 0xff,
+  0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3f, 0x12, 0x12, 0x09, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90,
+  0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x12, 0x09, 0x7f, 0x01, 0x12, 0x12, 0x99,
+  0x7f, 0x03, 0x7d, 0x07, 0x12, 0x12, 0x09, 0x7f, 0x13, 0x7d, 0x01, 0x12, 0x12, 0x09, 0xd2}},
+ {0x0cc6, 64, { 0x12, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5,
   0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05,
-  0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5}},
- {0x0d06, 64, { 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86,
-  0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08,
+  0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d,
+  0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05}},
+ {0x0d06, 64, { 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08,
   0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90,
-  0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf}},
- {0x0d46, 64, { 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83,
-  0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7,
+  0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5}},
+ {0x0d46, 64, { 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7,
   0x05, 0x86, 0xd2, 0xaf, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5,
-  0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87}},
- {0x0d86, 64, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xd2, 0x19, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02, 0xf0, 0x90,
-  0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x10, 0xe4, 0x33, 0xfe, 0xef, 0x4e, 0xf0, 0xd2, 0xe8, 0x43,
+  0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xd2, 0x19, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02, 0xf0}},
+ {0x0d86, 64, { 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x10, 0xe4, 0x33, 0xfe, 0xef, 0x4e, 0xf0, 0xd2, 0xe8, 0x43,
   0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74,
-  0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f}},
- {0x0dc6, 64, { 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2, 0x1a, 0x12,
-  0x12, 0x6a, 0xc2, 0x11, 0xe4, 0xf5, 0x0b, 0xf5, 0x13, 0xc2, 0x17, 0xc2, 0x12, 0x90, 0x7f, 0xa1,
+  0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xaf,
+  0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2, 0x1a}},
+ {0x0dc6, 64, { 0x12, 0x12, 0x53, 0xc2, 0x11, 0xe4, 0xf5, 0x0b, 0xf5, 0x13, 0xc2, 0x17, 0xc2, 0x12, 0x90, 0x7f, 0xa1,
   0x04, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x17, 0x60, 0x10, 0x30, 0x12, 0x05, 0xd2, 0x1a, 0x12,
-  0x00, 0x46, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x17, 0x80, 0x08, 0x30, 0x12, 0x05, 0xc2, 0x1a}},
- {0x0e06, 64, { 0x12, 0x00, 0x46, 0x30, 0x11, 0x07, 0xc2, 0x11, 0x12, 0x09, 0x29, 0x80, 0xd6, 0x30, 0x18, 0xd3, 0xc2,
-  0x18, 0x12, 0x13, 0xa0, 0x80, 0xcc, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x47,
-  0x02, 0x0e, 0x65, 0x02, 0x0d, 0x8d, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6,
-  0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24}},
- {0x0e46, 64, { 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01,
-  0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x12,
-  0xd1, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f,
-  0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40}},
- {0x0e86, 64, { 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca,
-  0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde,
+  0x00, 0x46, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x17, 0x80, 0x08, 0x30, 0x12, 0x05, 0xc2, 0x1a, 0x12,
+  0x00, 0x46, 0x30, 0x11, 0x07, 0xc2, 0x11, 0x12, 0x09, 0x21, 0x80, 0xd6, 0x30, 0x18, 0xd3}},
+ {0x0e06, 64, { 0xc2, 0x18, 0x12, 0x13, 0x9f, 0x80, 0xcc, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x47,
+  0x02, 0x0e, 0x55, 0x02, 0x0d, 0x7d, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6,
+  0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c,
+  0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80}},
+ {0x0e46, 64, { 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x12,
+  0xba, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f,
+  0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8,
+  0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8}},
+ {0x0e86, 64, { 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde,
   0xe7, 0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22,
-  0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c}},
- {0x0ec6, 64, { 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 0x25, 0x82,
-  0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 0x29, 0xf5,
+  0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c, 0xe5,
+  0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 0x25}},
+ {0x0ec6, 64, { 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 0x29, 0xf5,
   0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83,
-  0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0, 0x82}},
- {0x0f06, 64, { 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01, 0x93,
-  0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80,
+  0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0, 0x82, 0xf8,
+  0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01}},
+ {0x0f06, 64, { 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80,
   0xdf, 0x8f, 0x18, 0xe4, 0xf5, 0x19, 0x75, 0x1a, 0xff, 0x75, 0x1b, 0x19, 0x75, 0x1c, 0x86, 0xab,
-  0x1a, 0xaa, 0x1b, 0xa9, 0x1c, 0x90, 0x00, 0x01, 0x12, 0x0e, 0xc3, 0xb4, 0x03, 0x1d, 0xaf}},
- {0x0f46, 64, { 0x19, 0x05, 0x19, 0xef, 0xb5, 0x18, 0x01, 0x22, 0x12, 0x0e, 0xaa, 0x7e, 0x00, 0x29, 0xff, 0xee, 0x3a,
-  0xa9, 0x07, 0x75, 0x1a, 0xff, 0xf5, 0x1b, 0x89, 0x1c, 0x80, 0xd4, 0x7b, 0x00, 0x7a, 0x00, 0x79,
+  0x1a, 0xaa, 0x1b, 0xa9, 0x1c, 0x90, 0x00, 0x01, 0x12, 0x0e, 0xb3, 0xb4, 0x03, 0x1d, 0xaf, 0x19,
+  0x05, 0x19, 0xef, 0xb5, 0x18, 0x01, 0x22, 0x12, 0x0e, 0x9a, 0x7e, 0x00, 0x29, 0xff, 0xee}},
+ {0x0f46, 64, { 0x3a, 0xa9, 0x07, 0x75, 0x1a, 0xff, 0xf5, 0x1b, 0x89, 0x1c, 0x80, 0xd4, 0x7b, 0x00, 0x7a, 0x00, 0x79,
   0x00, 0x22, 0x8f, 0x1a, 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5,
-  0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12, 0x00, 0x36, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c}},
- {0x0f86, 64, { 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a,
-  0x12, 0x13, 0x34, 0x8f, 0x1a, 0xef, 0x42, 0x36, 0x80, 0xca, 0x22, 0x8f, 0x1a, 0x05, 0x0d, 0xe5,
+  0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12, 0x00, 0x36, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70,
+  0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60}},
+ {0x0f86, 64, { 0x0a, 0x12, 0x13, 0x33, 0x8f, 0x1a, 0xef, 0x42, 0x36, 0x80, 0xca, 0x22, 0x8f, 0x1a, 0x05, 0x0d, 0xe5,
   0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12,
-  0x13, 0x4c, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82}},
- {0x0fc6, 64, { 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x88, 0x8f, 0x1a, 0xef, 0x42,
-  0x37, 0x80, 0xca, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86,
-  0x75, 0x86, 0x00, 0x30, 0x15, 0x04, 0xc2, 0x15, 0x80, 0x02, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90,
-  0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83}},
- {0x1006, 64, { 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86,
-  0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0,
-  0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83,
-  0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x11, 0x53, 0x91}},
- {0x1046, 64, { 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83,
-  0xd0, 0xe0, 0x32, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90,
-  0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0,
-  0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0}},
- {0x1086, 64, { 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0,
-  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90,
-  0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12,
-  0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54}},
- {0x10c6, 64, { 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf,
-  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74,
-  0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13,
-  0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0}},
- {0x1106, 64, { 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
-  0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x0a, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45,
-  0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0}},
- {0x1146, 64, { 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f,
-  0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90,
-  0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90}},
- {0x1186, 64, { 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90,
-  0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0,
-  0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90,
-  0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xef}},
- {0x11c6, 64, { 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90,
-  0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x17, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0,
-  0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x1c, 0x8f, 0x1a, 0x12, 0x13, 0x1c, 0x8f, 0x1b, 0xe5}},
- {0x1206, 64, { 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x1c, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12,
-  0x13, 0x1c, 0x8f, 0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5,
-  0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0f, 0xf0, 0x90, 0xc0, 0x00,
-  0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12}},
- {0x1246, 64, { 0x13, 0x70, 0x8f, 0x1a, 0x12, 0x13, 0x70, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13,
-  0x70, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x70, 0x8f, 0x1b, 0x80, 0xe8,
-  0xaf, 0x1a, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x1a,
-  0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x12, 0xed, 0x90, 0x7f, 0xd6}},
- {0x1286, 64, { 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44, 0x04, 0xf0, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3e, 0x54, 0x7f,
-  0xfd, 0x12, 0x11, 0xd6, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4,
-  0xe5, 0x3e, 0x44, 0x80, 0xfd, 0x12, 0x11, 0xd6, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3f, 0x54,
-  0x7f, 0xfd, 0x12, 0x12, 0x20, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xee}},
- {0x12c6, 64, { 0xf0, 0xe4, 0xe5, 0x3f, 0x44, 0x80, 0xfd, 0x12, 0x12, 0x20, 0x22, 0x05, 0x0e, 0x02, 0x00, 0x00, 0x00,
-  0x00, 0x03, 0x14, 0x03, 0x00, 0x00, 0xc1, 0x11, 0xc1, 0x18, 0xc1, 0x95, 0xc1, 0x10, 0xc1, 0x16,
-  0x01, 0x0a, 0x00, 0xc1, 0x9b, 0x00, 0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19, 0xae, 0x18,
-  0x70, 0x02, 0x15, 0x18, 0x4e, 0x60, 0x05, 0x12, 0x0d, 0x6c, 0x80, 0xee, 0x22, 0x90, 0x7f}},
- {0x1306, 64, { 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90,
-  0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff,
-  0x22, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0}},
- {0x1346, 64, { 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff,
-  0x22, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x0a, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90,
-  0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe0}},
- {0x1386, 64, { 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98,
-  0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x12, 0x00, 0x03, 0x12, 0x0d, 0x7d, 0x12,
-  0x0b, 0x4e, 0x22, 0x53, 0xd8, 0xef, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x13, 0x4b, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c,
+  0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x87, 0x8f, 0x1a, 0xef}},
+ {0x0fc6, 64, { 0x42, 0x37, 0x80, 0xca, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86,
+  0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04,
+  0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0,
+  0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x11}},
+ {0x1006, 64, { 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82,
+  0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0,
+  0x86, 0x75, 0x86, 0x00, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0,
+  0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0x98}},
+ {0x1046, 64, { 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0,
+  0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00,
+  0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0}},
+ {0x1086, 64, { 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0,
+  0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90,
+  0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f,
+  0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14}},
+ {0x10c6, 64, { 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90,
+  0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0,
+  0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13,
+  0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b}},
+ {0x1106, 64, { 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0, 0x00, 0xef,
+  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74,
+  0x08, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45}},
+ {0x1146, 64, { 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74,
+  0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98,
+  0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90}},
+ {0x1186, 64, { 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00,
+  0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5,
+  0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5}},
+ {0x11c6, 64, { 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90, 0xc0, 0x00, 0xef,
+  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x1b,
+  0x8f, 0x1a, 0x12, 0x13, 0x1b, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x1b,
+  0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x1b, 0x8f, 0x1b, 0x80, 0xe8}},
+ {0x1206, 64, { 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
+  0x90, 0x7f, 0x98, 0x74, 0x0f, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0d,
+  0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x6f, 0x8f, 0x1a, 0x12, 0x13, 0x6f, 0x8f,
+  0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x6f, 0x8f, 0x1a, 0xe5, 0x1a, 0x65}},
+ {0x1246, 64, { 0x1b, 0x60, 0x07, 0x12, 0x13, 0x6f, 0x8f, 0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0xd6, 0xe0,
+  0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x1a, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f, 0xf4,
+  0x7e, 0x01, 0x12, 0x12, 0xd6, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44, 0x04, 0xf0,
+  0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3e, 0x54, 0x7f, 0xfd, 0x12, 0x11, 0xbf, 0x90, 0x7f}},
+ {0x1286, 64, { 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3e, 0x44, 0x80, 0xfd, 0x12, 0x11,
+  0xbf, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3f, 0x54, 0x7f, 0xfd, 0x12, 0x12, 0x09, 0x90, 0x7f,
+  0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3f, 0x44, 0x80, 0xfd, 0x12,
+  0x12, 0x09, 0x22, 0x05, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x14, 0x03, 0x00, 0x00}},
+ {0x12c6, 64, { 0xc1, 0x11, 0xc1, 0x18, 0xc1, 0x95, 0xc1, 0x10, 0xc1, 0x16, 0x01, 0x0a, 0x00, 0xc1, 0x9b, 0x00, 0x8e,
+  0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19, 0xae, 0x18, 0x70, 0x02, 0x15, 0x18, 0x4e, 0x60, 0x05,
+  0x12, 0x0d, 0x5c, 0x80, 0xee, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe0,
+  0xff, 0x22, 0x53, 0xd8, 0xef, 0x32, 0x00, 0x00, 0x00, 0x02, 0x0f, 0xf5, 0x00, 0x02, 0x13}},
+ {0x1306, 64, { 0x04, 0x00, 0x02, 0x0f, 0xcb, 0x00, 0x02, 0x10, 0x1c, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x15, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90}},
+ {0x1346, 64, { 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x0a, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff}},
+ {0x1386, 64, { 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x12, 0x00, 0x03, 0x12, 0x0d, 0x6d, 0x12, 0x0b,
+  0x46, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
  {0x13c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x33, 0x00, 0x02, 0x14}},
- {0x1406, 64, { 0x04, 0x00, 0x02, 0x10, 0x09, 0x00, 0x02, 0x0f, 0xdb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1406, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
@@ -424,13 +427,13 @@
  {0x18c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x00, 0x01, 0xff, 0x00}},
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00}},
  {0x1906, 64, { 0x00, 0x40, 0xcd, 0x06, 0x15, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x02, 0x09, 0x02, 0x74, 0x00, 0x01,
   0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00, 0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01,
   0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40,
   0x00, 0x00, 0x07, 0x05, 0x04, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x05, 0x02, 0x40, 0x00}},
  {0x1946, 64, { 0x00, 0x07, 0x05, 0x06, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x07, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05,
-  0x81, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x83, 0x02,
+  0x81, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x83, 0x02,
   0x40, 0x00, 0x01, 0x07, 0x05, 0x84, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x85, 0x02, 0x40, 0x00,
   0x01, 0x07, 0x05, 0x86, 0x02, 0x40, 0x00, 0x01, 0x07, 0x05, 0x87, 0x02, 0x40, 0x00, 0x01}},
  {0x1986, 64, { 0x04, 0x03, 0x09, 0x04, 0x48, 0x03, 0x4b, 0x00, 0x65, 0x00, 0x79, 0x00, 0x73, 0x00, 0x70, 0x00, 0x61,
@@ -442,5 +445,5 @@
   0x00, 0x42, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x69, 0x00, 0x61, 0x00, 0x6c,
   0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00, 0x70, 0x00, 0x74, 0x00, 0x65, 0x00}},
  {0x1a06,  4, { 0x72, 0x00, 0x00, 0x00}},
- { 0xffff,	0,	{0x00} }
+ {0xffff,  0, {0x00}}
 };
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa28xb_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa28xb_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa28xb_fw.h	Wed Oct 10 00:15:03 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa28xb_fw.h	Mon Nov 25 12:27:09 2002
@@ -1,352 +1,353 @@
 /* keyspan_usa28xb_fw.h
 
-   Generated from Keyspan firmware image usacode36.h Sat Oct  6 12:07:38 EST 2001
-   This firmware is for the Keyspan USA-28XA Serial Adaptor
+	The firmware contained herein as keyspan_usa29xb_fw.h is
 
-   "The firmware contained herein as keyspan_usa28xb_fw.h is
-   Copyright (C) 1999-2001 Keyspan, A division of InnoSys Incorporated
-   ("Keyspan"), as an unpublished work.  This notice does not imply
-   unrestricted or public access to the source code from which this 
-   firmware image is derived.  Except as noted below this firmware image
-   may not be reproduced, used, sold or transferred to any third party
-   without Keyspan's prior written consent.  All Rights Reserved.
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
 
-   Permission is hereby granted for the distribution of this firmware image
-   as part of a Linux or other Open Source operating system kernel in 
-   text or binary form as required.
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
 
-   This firmware may not be modified and may only be used with the Keyspan 
-   USA-28 Serial Adapter.  Distribution and/or Modification of the
-   keyspan.c driver which includes this firmware, in whole or in part,
-   requires the inclusion of this statement."
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
 
 */
 
 static const struct ezusb_hex_record keyspan_usa28xb_firmware[] = {
- {0x0033,  3, { 0x02, 0x13, 0xb7}},
- {0x0046, 16, { 0x30, 0x09, 0x18, 0x12, 0x13, 0x35, 0xef, 0xc3, 0x95, 0x3c, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
+ {0x0033,  3, { 0x02, 0x00, 0x2d}},
+ {0x002d,  4, { 0x53, 0xd8, 0xef, 0x32}},
+ {0x0046, 16, { 0x30, 0x09, 0x18, 0x12, 0x13, 0x33, 0xef, 0xc3, 0x95, 0x3c, 0x40, 0x03, 0x02, 0x00, 0xd8, 0x90}},
  {0x0056, 16, { 0x7f, 0xbf, 0x74, 0x01, 0xf0, 0xc2, 0x09, 0xc2, 0x00, 0x80, 0x77, 0x30, 0x03, 0x3b, 0x90, 0x7f}},
- {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x35, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
+ {0x0066, 16, { 0xc6, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x33, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7e}},
  {0x0076, 16, { 0x40, 0xe0, 0x13, 0x92, 0x09, 0x90, 0x7f, 0xc7, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60}},
- {0x0086, 16, { 0x0f, 0xf5, 0x08, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x41, 0x12, 0x0c, 0xdc}},
+ {0x0086, 16, { 0x0f, 0xf5, 0x08, 0x7e, 0x7e, 0x7f, 0x41, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x41, 0x12, 0x0c, 0xcc}},
  {0x0096, 16, { 0xc2, 0x03, 0xe4, 0x90, 0x7f, 0xc7, 0xf0, 0x80, 0x39, 0x90, 0x7f, 0xc8, 0xe0, 0x20, 0xe1, 0x32}},
- {0x00a6, 16, { 0x12, 0x13, 0x35, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x09}},
+ {0x00a6, 16, { 0x12, 0x13, 0x33, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7d, 0xc0, 0xe0, 0x13, 0x92, 0x09}},
  {0x00b6, 16, { 0x90, 0x7f, 0xc9, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d}},
- {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0xc1, 0x12, 0x0c, 0xdc, 0xd2, 0x03, 0xe4, 0x90, 0x7f}},
- {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x66, 0x53, 0x36, 0x80, 0x12}},
- {0x00e6, 16, { 0x13, 0x41, 0xef, 0x42, 0x36, 0x12, 0x12, 0x08, 0x8f, 0x19, 0xef, 0xc3, 0x95, 0x3a, 0x50, 0x0f}},
- {0x00f6, 16, { 0x12, 0x13, 0x1d, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x36, 0x20, 0xe7, 0x03, 0x30, 0x0b, 0x61, 0xc2}},
+ {0x00c6, 16, { 0x7f, 0xc1, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0xc1, 0x12, 0x0c, 0xcc, 0xd2, 0x03, 0xe4, 0x90, 0x7f}},
+ {0x00d6, 16, { 0xc9, 0xf0, 0x90, 0x7f, 0xb6, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x01, 0x60, 0x12, 0x11, 0xf5, 0x8f}},
+ {0x00e6, 16, { 0x19, 0x12, 0x13, 0x3f, 0x8f, 0x36, 0xe5, 0x19, 0xc3, 0x95, 0x3a, 0x50, 0x0f, 0x12, 0x13, 0x1b}},
+ {0x00f6, 16, { 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x36, 0x20, 0xe7, 0x03, 0x30, 0x0b, 0x5e, 0xc2, 0x0b, 0xe5, 0x19}},
  {0x0036, 12, { 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22}},
- {0x0043,  3, { 0x02, 0x14, 0x00}},
- {0x0003, 16, { 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x30}},
- {0x0013, 16, { 0x15, 0x04, 0xc2, 0x15, 0x80, 0x02, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08}},
- {0x0023, 14, { 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32}},
- {0x0000,  3, { 0x02, 0x0e, 0x22}},
- {0x0106, 64, { 0x0b, 0xe5, 0x19, 0x70, 0x04, 0xf5, 0x36, 0x80, 0x57, 0x12, 0x13, 0x41, 0xef, 0x42, 0x36, 0xe5, 0x36,
-  0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08,
-  0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x80, 0xaf, 0x36, 0x12, 0x0f, 0x6d, 0xe5,
-  0x19, 0x25, 0xe0, 0x90, 0x7f, 0xb7, 0xf0, 0x80, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40}},
- {0x0146, 64, { 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08, 0xe4, 0x90, 0x7e, 0x80, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75,
-  0x0c, 0x7e, 0x75, 0x0d, 0x81, 0x12, 0x0d, 0x01, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90,
-  0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x05, 0x03, 0x02, 0x03, 0xc5, 0xe4, 0xf5, 0x18, 0x74,
-  0x40, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c}},
- {0x0186, 64, { 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e,
-  0xf4, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x68, 0x90, 0x7e,
-  0x03, 0xe0, 0x60, 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x11, 0xe3, 0x7f, 0x03, 0x7d, 0xcd, 0x12,
-  0x11, 0xe3, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5}},
- {0x01c6, 64, { 0x46, 0xf0, 0xe4, 0x90, 0x7e, 0x13, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12, 0x10, 0x67,
-  0x90, 0x7e, 0x02, 0xe0, 0xff, 0x12, 0x10, 0x8d, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0, 0xfd, 0x12,
-  0x11, 0xe3, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xe3, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74,
-  0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5}},
- {0x0206, 64, { 0x40, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x03, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x13, 0xe0,
-  0x70, 0x08, 0xe4, 0x90, 0x7e, 0x13, 0xf0, 0x75, 0x25, 0xff, 0x90, 0x7e, 0x05, 0xe0, 0x60, 0x12,
-  0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x44, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe5,
-  0x44, 0xf0, 0x90, 0x7e, 0x07, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x42, 0x80}},
- {0x0246, 64, { 0x80, 0x03, 0x53, 0x42, 0x7f, 0x53, 0x42, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43, 0x42, 0x02,
-  0xa3, 0xe0, 0xff, 0x12, 0x10, 0xd9, 0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x10, 0xff, 0xaf, 0x42,
-  0x12, 0x10, 0xb3, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x08, 0x53, 0x42, 0x7f, 0xaf, 0x42, 0x12, 0x10,
-  0xb3, 0x90, 0x7e, 0x0c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x02, 0x80}},
- {0x0286, 64, { 0x03, 0x53, 0x46, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90,
-  0x7e, 0x0e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x01, 0x80, 0x03, 0x53, 0x46,
-  0xfe, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x12,
-  0xe0, 0xf5, 0x3a, 0xa3, 0xe0, 0x13, 0x92, 0x0d, 0xa3, 0xe0, 0xf5, 0x3c, 0xa3, 0xe0, 0x60}},
- {0x02c6, 64, { 0x05, 0x43, 0x46, 0x10, 0x80, 0x03, 0x53, 0x46, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0,
-  0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x16, 0xe0, 0x60, 0x32, 0x53, 0x44, 0xbf, 0x90, 0x7f, 0x98,
-  0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11,
-  0xf0, 0x12, 0x13, 0x11, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3e, 0xfd, 0xe4}},
- {0x0306, 64, { 0xff, 0xad, 0x3e, 0x12, 0x11, 0xe3, 0xe4, 0xf5, 0x2a, 0xf5, 0x29, 0xd2, 0x07, 0x90, 0x7e, 0x17, 0xe0,
-  0x60, 0x0f, 0x43, 0x3e, 0x02, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xe3, 0x75, 0x29, 0x01, 0xd2,
-  0x07, 0x90, 0x7e, 0x18, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44,
-  0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11, 0x43, 0x44}},
- {0x0346, 64, { 0x40, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
-  0x1a, 0xe0, 0x60, 0x0f, 0x53, 0x3e, 0xfe, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xe3, 0x75, 0x2b,
-  0x01, 0xd2, 0x07, 0x90, 0x7e, 0x1b, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x01, 0xe4, 0xff, 0xad, 0x3e,
-  0x12, 0x11, 0xe3, 0xe4, 0xf5, 0x2b, 0xd2, 0x07, 0x90, 0x7e, 0x1c, 0xe0, 0x60, 0x0e, 0x90}},
- {0x0386, 64, { 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1d, 0xe0,
-  0x60, 0x02, 0xd2, 0x0b, 0x90, 0x7e, 0x1e, 0xe0, 0x60, 0x08, 0x75, 0x2c, 0x01, 0xe4, 0xf5, 0x38,
-  0xd2, 0x07, 0x90, 0x7e, 0x1f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31,
-  0xf0, 0x74, 0x15, 0xf0, 0x74, 0x35, 0xf0, 0xc2, 0x05, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30}},
- {0x03c6, 64, { 0x1a, 0x54, 0xe5, 0x38, 0x60, 0x02, 0x15, 0x38, 0x20, 0x13, 0x4b, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40,
-  0x04, 0x15, 0x13, 0x80, 0x40, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xd2, 0x13, 0x12, 0x13, 0x11,
-  0xef, 0x54, 0x01, 0xf5, 0x19, 0x65, 0x2a, 0x60, 0x05, 0x85, 0x19, 0x2a, 0xd2, 0x07, 0x12, 0x13,
-  0x4d, 0xef, 0x54, 0x80, 0x64, 0x80, 0xf5, 0x19, 0x65, 0x26, 0x60, 0x05, 0x85, 0x19, 0x26}},
- {0x0406, 64, { 0xd2, 0x07, 0x30, 0x0d, 0x11, 0x12, 0x13, 0x4d, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x25, 0x60, 0x05,
-  0x85, 0x19, 0x25, 0xd2, 0x07, 0x20, 0x1b, 0x03, 0x02, 0x07, 0xf8, 0x30, 0x0a, 0x18, 0x12, 0x13,
-  0x89, 0xef, 0xc3, 0x95, 0x3d, 0x40, 0x03, 0x02, 0x04, 0xb4, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0,
-  0xc2, 0x0a, 0xc2, 0x00, 0x80, 0x77, 0x30, 0x04, 0x3b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1}},
- {0x0446, 64, { 0x6d, 0x12, 0x13, 0x89, 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x0a,
-  0x90, 0x7f, 0xcb, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d,
-  0x7f, 0x41, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x41, 0x12, 0x0d, 0x26, 0xc2, 0x04, 0xe4, 0x90, 0x7f,
-  0xcb, 0xf0, 0x80, 0x39, 0x90, 0x7f, 0xcc, 0xe0, 0x20, 0xe1, 0x32, 0x12, 0x13, 0x89, 0xef}},
- {0x0486, 64, { 0xc3, 0x94, 0x40, 0x50, 0x29, 0x90, 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcd, 0xe0, 0x14,
-  0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7c, 0x7f, 0xc1, 0x75, 0x0c, 0x7c,
-  0x75, 0x0d, 0xc1, 0x12, 0x0d, 0x26, 0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xba,
-  0xe0, 0x30, 0xe1, 0x03, 0x02, 0x05, 0x42, 0x53, 0x37, 0x80, 0x12, 0x13, 0x95, 0xef, 0x42}},
- {0x04c6, 64, { 0x37, 0x12, 0x12, 0x52, 0x8f, 0x19, 0xef, 0xc3, 0x95, 0x3b, 0x50, 0x0f, 0x12, 0x13, 0x71, 0xef, 0x30,
-  0xe0, 0x08, 0xe5, 0x37, 0x20, 0xe7, 0x03, 0x30, 0x0c, 0x61, 0xc2, 0x0c, 0xe5, 0x19, 0x70, 0x04,
-  0xf5, 0x37, 0x80, 0x57, 0x12, 0x13, 0x95, 0xef, 0x42, 0x37, 0xe5, 0x37, 0x30, 0xe7, 0x26, 0xe5,
-  0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e, 0x7d, 0x7f}},
- {0x0506, 64, { 0x80, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x80, 0xaf, 0x37, 0x12, 0x0f, 0xa6, 0xe5, 0x19, 0x25, 0xe0, 0x90,
-  0x7f, 0xbb, 0xf0, 0x80, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f, 0x85,
-  0x19, 0x08, 0xe4, 0x90, 0x7d, 0x80, 0xf0, 0x7e, 0x7d, 0x7f, 0x81, 0x75, 0x0c, 0x7d, 0x75, 0x0d,
-  0x81, 0x12, 0x0d, 0x4b, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xbb, 0xf0, 0x90, 0x7f, 0xd0, 0xe0}},
- {0x0546, 64, { 0x30, 0xe1, 0x06, 0x20, 0x06, 0x03, 0x02, 0x07, 0xa1, 0xe4, 0xf5, 0x18, 0x74, 0xc0, 0x25, 0x18, 0xf5,
-  0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e,
-  0x79, 0x20, 0x24, 0x20, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e, 0xf4, 0x05, 0x18, 0xe5,
-  0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x20, 0xe0, 0x60, 0x68, 0x90, 0x7e, 0x23, 0xe0, 0x60}},
- {0x0586, 64, { 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x12, 0x2d, 0x7f, 0x03, 0x7d, 0xcd, 0x12, 0x12, 0x2d, 0x43, 0x47,
-  0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0xe4, 0x90, 0x7e,
-  0x33, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x21, 0xe0, 0xff, 0x12, 0x11, 0x4b, 0x90, 0x7e, 0x22, 0xe0,
-  0xff, 0x12, 0x11, 0x71, 0x7f, 0x01, 0x90, 0x7e, 0x31, 0xe0, 0xfd, 0x12, 0x12, 0x2d, 0x7f}},
- {0x05c6, 64, { 0x03, 0x7d, 0x07, 0x12, 0x12, 0x2d, 0x43, 0x47, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0,
-  0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x06, 0x90, 0xc0,
-  0x00, 0xf0, 0x90, 0x7e, 0x23, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x33, 0xe0, 0x70, 0x08, 0xe4, 0x90,
-  0x7e, 0x33, 0xf0, 0x75, 0x2e, 0xff, 0x90, 0x7e, 0x25, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54}},
- {0x0606, 64, { 0x3f, 0xf5, 0x45, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x45, 0xf0, 0x90, 0x7e,
-  0x27, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x43, 0x80, 0x80, 0x03, 0x53, 0x43, 0x7f,
-  0x53, 0x43, 0xfc, 0x90, 0x7e, 0x29, 0xe0, 0x60, 0x11, 0x43, 0x43, 0x02, 0xa3, 0xe0, 0xff, 0x12,
-  0x11, 0x97, 0x90, 0x7e, 0x2b, 0xe0, 0xff, 0x12, 0x11, 0xbd, 0xaf, 0x43, 0x12, 0x11, 0x25}},
- {0x0646, 64, { 0x90, 0x7e, 0x23, 0xe0, 0x60, 0x08, 0x53, 0x43, 0x7f, 0xaf, 0x43, 0x12, 0x11, 0x25, 0x90, 0x7e, 0x2c,
-  0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x02, 0x80, 0x03, 0x53, 0x47, 0xfd, 0x90,
-  0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x2e, 0xe0, 0x60,
-  0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x01, 0x80, 0x03, 0x53, 0x47, 0xfe, 0x90, 0x7f}},
- {0x0686, 64, { 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x32, 0xe0, 0xf5, 0x3b, 0xa3,
-  0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x10, 0x80,
-  0x03, 0x53, 0x47, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0,
-  0x90, 0x7e, 0x36, 0xe0, 0x60, 0x32, 0x53, 0x45, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0}},
- {0x06c6, 64, { 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x12, 0x13, 0x65,
-  0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3f, 0xfd, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12,
-  0x2d, 0xe4, 0xf5, 0x33, 0xf5, 0x32, 0xd2, 0x08, 0x90, 0x7e, 0x37, 0xe0, 0x60, 0x0f, 0x43, 0x3f,
-  0x02, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x2d, 0x75, 0x32, 0x01, 0xd2, 0x08, 0x90, 0x7e}},
- {0x0706, 64, { 0x38, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x04, 0x90, 0xc0, 0x00,
-  0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x39, 0xe0, 0x60, 0x11, 0x43, 0x45, 0x40, 0x90, 0x7f, 0x98, 0x74,
-  0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x3a, 0xe0, 0x60, 0x0f,
-  0x53, 0x3f, 0xfe, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x2d, 0x75, 0x34, 0x01, 0xd2, 0x08}},
- {0x0746, 64, { 0x90, 0x7e, 0x3b, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x01, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x2d, 0xe4,
-  0xf5, 0x34, 0xd2, 0x08, 0x90, 0x7e, 0x3c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
-  0xe5, 0x41, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x3d, 0xe0, 0x60, 0x02, 0xd2, 0x0c,
-  0x90, 0x7e, 0x3e, 0xe0, 0x60, 0x08, 0x75, 0x35, 0x01, 0xe4, 0xf5, 0x39, 0xd2, 0x08, 0x90}},
- {0x0786, 64, { 0x7e, 0x3f, 0xe0, 0x60, 0x0f, 0x90, 0x7f, 0xd7, 0x74, 0x13, 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x16, 0xf0,
-  0x74, 0x36, 0xf0, 0xc2, 0x06, 0xe4, 0x90, 0x7f, 0xd1, 0xf0, 0x30, 0x1a, 0x54, 0xe5, 0x39, 0x60,
-  0x02, 0x15, 0x39, 0x30, 0x13, 0x4b, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80,
-  0x40, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xc2, 0x13, 0x12, 0x13, 0x65, 0xef, 0x54, 0x01}},
- {0x07c6, 64, { 0xf5, 0x19, 0x65, 0x33, 0x60, 0x05, 0x85, 0x19, 0x33, 0xd2, 0x08, 0x12, 0x13, 0xa1, 0xef, 0x54, 0x80,
-  0x64, 0x80, 0xf5, 0x19, 0x65, 0x2f, 0x60, 0x05, 0x85, 0x19, 0x2f, 0xd2, 0x08, 0x30, 0x0e, 0x11,
-  0x12, 0x13, 0xa1, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x2e, 0x60, 0x05, 0x85, 0x19, 0x2e, 0xd2,
-  0x08, 0x30, 0x1a, 0x2a, 0x90, 0x7f, 0xd2, 0xe0, 0x20, 0xe1, 0x23, 0x90, 0x7b, 0x40, 0xe0}},
- {0x0806, 64, { 0x60, 0x09, 0xe0, 0xf5, 0x15, 0x90, 0x7b, 0x42, 0xe0, 0xf5, 0x16, 0x90, 0x7b, 0x41, 0xe0, 0x60, 0x09,
-  0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0xe4, 0x90, 0x7f, 0xd3, 0xf0, 0x90, 0x7f,
-  0xc2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x09, 0x2c, 0xe5, 0x0a, 0x70, 0x40, 0x30, 0x07, 0x39, 0xe5,
-  0x38, 0x70, 0x35, 0xc2, 0x07, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18}},
- {0x0846, 64, { 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0xae, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34,
-  0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74,
-  0x09, 0xf0, 0x75, 0x38, 0x10, 0xe4, 0xf5, 0x2c, 0x75, 0x0a, 0x01, 0x22, 0xe5, 0x0a, 0x64, 0x01,
-  0x70, 0x40, 0x30, 0x08, 0x39, 0xe5, 0x39, 0x70, 0x35, 0xc2, 0x08, 0xf5, 0x18, 0x7e, 0x00}},
- {0x0886, 64, { 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0xae, 0xff, 0x74, 0x80,
-  0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4,
-  0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x39, 0x10, 0xe4, 0xf5, 0x35, 0x75, 0x0a,
-  0x02, 0x22, 0xe5, 0x0a, 0x64, 0x02, 0x70, 0x36, 0x30, 0x14, 0x2f, 0xc2, 0x14, 0xf5, 0x18}},
- {0x08c6, 64, { 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x0e, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0xae, 0xff,
-  0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5,
-  0x18, 0xb4, 0x05, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x05, 0xf0, 0x75, 0x0a, 0x03, 0x22, 0xe5, 0x15,
-  0x60, 0x30, 0x15, 0x15, 0xe4, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x14, 0x25, 0x18}},
- {0x0906, 64, { 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0xae, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34,
-  0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74,
-  0x03, 0xf0, 0xe4, 0xf5, 0x0a, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x0f, 0x06, 0x0a, 0x14, 0x00,
-  0x0a, 0x88, 0x01, 0x0a, 0xf4, 0x03, 0x09, 0x50, 0x06, 0x0a, 0x07, 0x08, 0x0a, 0x01, 0x09}},
- {0x0946, 64, { 0x09, 0xe9, 0x0a, 0x09, 0xf8, 0x0b, 0x00, 0x00, 0x0b, 0x43, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60,
-  0x19, 0x14, 0x60, 0x61, 0x24, 0x02, 0x60, 0x03, 0x02, 0x09, 0xdf, 0x74, 0x19, 0x90, 0x7f, 0xd4,
-  0xf0, 0x74, 0x00, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04,
-  0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03, 0x75, 0x82, 0x82, 0x75, 0x83, 0x19, 0xef, 0xf0, 0x75}},
- {0x0986, 64, { 0x82, 0x7b, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x74, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x66, 0x75,
-  0x83, 0x19, 0xf0, 0x75, 0x82, 0x58, 0x75, 0x83, 0x19, 0xf0, 0x90, 0x7f, 0xea, 0xe0, 0x04, 0x75,
-  0x82, 0x17, 0x75, 0x83, 0x19, 0xf0, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x12, 0x90, 0x7f,
-  0xd5, 0xf0, 0x02, 0x0b, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x0f, 0x2c, 0xea, 0x49}},
- {0x09c6, 64, { 0x60, 0x0d, 0xea, 0x90, 0x7f, 0xd4, 0xf0, 0xe9, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x4a, 0x90, 0x7f,
-  0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x4a, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02,
-  0x0b, 0x4a, 0x90, 0x7f, 0x00, 0xe5, 0x09, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b,
-  0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x09, 0x02, 0x0b, 0x4a, 0x12, 0x0b, 0x52, 0x02, 0x0b}},
- {0x0a06, 64, { 0x4a, 0x90, 0x7f, 0x00, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xf0, 0x02, 0x0b, 0x4a, 0x90, 0x7f, 0xe8,
-  0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b, 0xa2, 0x10, 0xe4, 0x33,
-  0xff, 0x25, 0xe0, 0xff, 0xa2, 0x16, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0,
-  0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x4a, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3}},
- {0x0a46, 64, { 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x4a, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80,
-  0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4,
-  0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f,
-  0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x4a, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02}},
- {0x0a86, 64, { 0x0b, 0x4a, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x1d, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x4a,
-  0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x05, 0xc2, 0x10, 0x02, 0x0b, 0x4a, 0x90, 0x7f, 0xb4, 0xe0,
-  0x44, 0x01, 0xf0, 0x02, 0x0b, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x38, 0x90, 0x7f, 0xec, 0xe0,
-  0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24}},
- {0x0ac6, 64, { 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff,
-  0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44,
-  0x20, 0xf0, 0x80, 0x5f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x56, 0x90, 0x7f, 0xe8,
-  0xe0, 0x24, 0xfe, 0x60, 0x18, 0x24, 0x02, 0x70, 0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01}},
- {0x0b06, 64, { 0x04, 0xd2, 0x10, 0x80, 0x3f, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea,
-  0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0,
-  0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01,
-  0xf0, 0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4}},
- {0x0b46, 64, { 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0,
-  0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0xc0,
-  0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x18, 0xf0, 0xe4, 0xf5, 0x8e,
-  0x90, 0x7f, 0xdf, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0xe4, 0xf5, 0x24, 0x75, 0x18}},
- {0x0b86, 64, { 0x01, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xf4, 0x05,
-  0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3a, 0x01, 0xe4, 0xf5, 0x38, 0xf5, 0x13, 0xf5, 0x36,
-  0xc2, 0x07, 0xc2, 0x0b, 0xc2, 0x05, 0xc2, 0x00, 0xc2, 0x09, 0xc2, 0x13, 0xd2, 0x03, 0xd2, 0x01,
-  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x75, 0x44, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0}},
- {0x0bc6, 64, { 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x11, 0xe3, 0x7f, 0x10, 0x8f, 0x42, 0x12, 0x10, 0xb3, 0x90, 0x7f, 0x98,
-  0x74, 0x12, 0xf0, 0x7f, 0x01, 0x8f, 0x40, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f,
-  0x98, 0x74, 0x14, 0xf0, 0x75, 0x46, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd,
-  0x12, 0x11, 0xe3, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3e, 0x12, 0x11, 0xe3, 0x90}},
- {0x0c06, 64, { 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x11, 0xe3,
-  0x7f, 0x01, 0x12, 0x12, 0x9c, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xe3, 0x7f, 0x13, 0x7d, 0x09,
-  0x12, 0x11, 0xe3, 0x20, 0x1b, 0x03, 0x02, 0x0c, 0xd9, 0x75, 0x2d, 0x01, 0x75, 0x18, 0x01, 0x7b,
-  0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xf4, 0x05}},
- {0x0c46, 64, { 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3b, 0x01, 0xe4, 0xf5, 0x39, 0xf5, 0x13, 0xf5, 0x37, 0xc2,
-  0x08, 0xc2, 0x0c, 0xc2, 0x06, 0xc2, 0x00, 0xc2, 0x0a, 0xc2, 0x13, 0xd2, 0x04, 0xd2, 0x02, 0x90,
+ {0x0043,  3, { 0x02, 0x13, 0x00}},
+ {0x0003, 16, { 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90}},
+ {0x0013, 16, { 0x7f, 0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0}},
+ {0x0023, 10, { 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32}},
+ {0x0000,  3, { 0x02, 0x0e, 0x12}},
+ {0x0106, 64, { 0x60, 0x58, 0xb4, 0x80, 0x03, 0x43, 0x36, 0x02, 0xe5, 0x36, 0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94,
+  0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x08, 0x7e, 0x7e, 0x7f, 0x80, 0x75, 0x0c, 0x7e,
+  0x75, 0x0d, 0x80, 0xaf, 0x36, 0x12, 0x0f, 0x5d, 0xe5, 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xb7, 0xf0,
+  0x80, 0x27, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08}},
+ {0x0146, 64, { 0x90, 0x7e, 0x80, 0xe5, 0x36, 0xf0, 0x7e, 0x7e, 0x7f, 0x81, 0x75, 0x0c, 0x7e, 0x75, 0x0d, 0x81, 0x12,
+  0x0c, 0xf1, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xb7, 0xf0, 0x90, 0x7f, 0xce, 0xe0, 0x30, 0xe1, 0x06,
+  0x20, 0x05, 0x03, 0x02, 0x03, 0xc1, 0xe4, 0xf5, 0x18, 0x74, 0x40, 0x25, 0x18, 0xf5, 0x82, 0xe4,
+  0x34, 0x7c, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18, 0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79}},
+ {0x0186, 64, { 0x00, 0x24, 0x00, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef, 0x12, 0x0e, 0xe4, 0x05, 0x18, 0xe5, 0x18, 0xb4,
+  0x20, 0xd7, 0x90, 0x7e, 0x00, 0xe0, 0x60, 0x68, 0x90, 0x7e, 0x03, 0xe0, 0x60, 0x24, 0x7f, 0x01,
+  0xe4, 0xfd, 0x12, 0x11, 0xd0, 0x7f, 0x03, 0x7d, 0xcd, 0x12, 0x11, 0xd0, 0x43, 0x46, 0x80, 0x90,
+  0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0xe4, 0x90, 0x7e, 0x13}},
+ {0x01c6, 64, { 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x01, 0xe0, 0xff, 0x12, 0x10, 0x54, 0x90, 0x7e, 0x02, 0xe0, 0xff, 0x12,
+  0x10, 0x7a, 0x7f, 0x01, 0x90, 0x7e, 0x11, 0xe0, 0xfd, 0x12, 0x11, 0xd0, 0x7f, 0x03, 0x7d, 0x07,
+  0x12, 0x11, 0xd0, 0x43, 0x46, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5,
+  0x46, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x06, 0x90, 0xc0, 0x00}},
+ {0x0206, 64, { 0xf0, 0x90, 0x7e, 0x03, 0xe0, 0x70, 0x06, 0x90, 0x7e, 0x13, 0xe0, 0x70, 0x08, 0xe4, 0x90, 0x7e, 0x13,
+  0xf0, 0x75, 0x25, 0xff, 0x90, 0x7e, 0x05, 0xe0, 0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x44,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x44, 0xf0, 0x90, 0x7e, 0x07, 0xe0,
+  0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x42, 0x80, 0x80, 0x03, 0x53, 0x42, 0x7f, 0x53}},
+ {0x0246, 64, { 0x42, 0xfc, 0x90, 0x7e, 0x09, 0xe0, 0x60, 0x11, 0x43, 0x42, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x10, 0xc6,
+  0x90, 0x7e, 0x0b, 0xe0, 0xff, 0x12, 0x10, 0xec, 0xaf, 0x42, 0x12, 0x10, 0xa0, 0x90, 0x7e, 0x03,
+  0xe0, 0x60, 0x08, 0x53, 0x42, 0x7f, 0xaf, 0x42, 0x12, 0x10, 0xa0, 0x90, 0x7e, 0x0c, 0xe0, 0x60,
+  0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x02, 0x80, 0x03, 0x53, 0x46, 0xfd, 0x90, 0x7f}},
+ {0x0286, 64, { 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x0e, 0xe0, 0x60, 0x18, 0xa3,
+  0xe0, 0x60, 0x05, 0x43, 0x46, 0x01, 0x80, 0x03, 0x53, 0x46, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x14,
+  0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e, 0x12, 0xe0, 0xf5, 0x3a, 0xa3, 0xe0, 0x13,
+  0x92, 0x0d, 0xa3, 0xe0, 0xf5, 0x3c, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x46, 0x10, 0x80, 0x03}},
+ {0x02c6, 64, { 0x53, 0x46, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x46, 0xf0, 0x90, 0x7e,
+  0x16, 0xe0, 0x60, 0x32, 0x53, 0x44, 0xbf, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54,
+  0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x12, 0x13, 0x0f, 0xef, 0x54,
+  0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3e, 0xfd, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xd0}},
+ {0x0306, 64, { 0xe4, 0xf5, 0x2a, 0xf5, 0x29, 0xd2, 0x07, 0x90, 0x7e, 0x17, 0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x02, 0xe4,
+  0xff, 0xad, 0x3e, 0x12, 0x11, 0xd0, 0x75, 0x29, 0x01, 0xd2, 0x07, 0x90, 0x7e, 0x18, 0xe0, 0x60,
+  0x10, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5, 0x40, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2,
+  0x00, 0x90, 0x7e, 0x19, 0xe0, 0x60, 0x11, 0x43, 0x44, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x13}},
+ {0x0346, 64, { 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1a, 0xe0, 0x60, 0x0f, 0x53, 0x3e,
+  0xfe, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xd0, 0x75, 0x2b, 0x01, 0xd2, 0x07, 0x90, 0x7e, 0x1b,
+  0xe0, 0x60, 0x0f, 0x43, 0x3e, 0x01, 0xe4, 0xff, 0xad, 0x3e, 0x12, 0x11, 0xd0, 0xe4, 0xf5, 0x2b,
+  0xd2, 0x07, 0x90, 0x7e, 0x1c, 0xe0, 0x60, 0x0e, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0xe5}},
+ {0x0386, 64, { 0x40, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x1d, 0xe0, 0x60, 0x02, 0xd2, 0x0b, 0x90, 0x7e,
+  0x1e, 0xe0, 0x60, 0x08, 0x75, 0x2c, 0x01, 0xe4, 0xf5, 0x38, 0xd2, 0x07, 0x90, 0x7e, 0x1f, 0xe0,
+  0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x11, 0xf0, 0x74, 0x31, 0xf0, 0x74, 0x15, 0xf0, 0x74, 0x35,
+  0xf0, 0xd2, 0x03, 0xc2, 0x05, 0xe4, 0x90, 0x7f, 0xcf, 0xf0, 0x30, 0x1a, 0x54, 0xe5, 0x38}},
+ {0x03c6, 64, { 0x60, 0x02, 0x15, 0x38, 0x20, 0x13, 0x4b, 0xe5, 0x13, 0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80,
+  0x40, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xd2, 0x13, 0x12, 0x13, 0x0f, 0xef, 0x54, 0x01, 0xf5,
+  0x19, 0x65, 0x2a, 0x60, 0x05, 0x85, 0x19, 0x2a, 0xd2, 0x07, 0x12, 0x13, 0x4b, 0xef, 0x54, 0x80,
+  0x64, 0x80, 0xf5, 0x19, 0x65, 0x26, 0x60, 0x05, 0x85, 0x19, 0x26, 0xd2, 0x07, 0x30, 0x0d}},
+ {0x0406, 64, { 0x11, 0x12, 0x13, 0x4b, 0xef, 0x54, 0x10, 0xf5, 0x19, 0x65, 0x25, 0x60, 0x05, 0x85, 0x19, 0x25, 0xd2,
+  0x07, 0x20, 0x1b, 0x03, 0x02, 0x07, 0xf0, 0x30, 0x0a, 0x18, 0x12, 0x13, 0x87, 0xef, 0xc3, 0x95,
+  0x3d, 0x40, 0x03, 0x02, 0x04, 0xb0, 0x90, 0x7f, 0xc1, 0x74, 0x01, 0xf0, 0xc2, 0x0a, 0xc2, 0x00,
+  0x80, 0x77, 0x30, 0x04, 0x3b, 0x90, 0x7f, 0xca, 0xe0, 0x20, 0xe1, 0x6d, 0x12, 0x13, 0x87}},
+ {0x0446, 64, { 0xef, 0xc3, 0x94, 0x40, 0x50, 0x64, 0x90, 0x7d, 0x40, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcb, 0xe0,
+  0x14, 0xf5, 0x19, 0x20, 0x00, 0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7d, 0x7f, 0x41, 0x75, 0x0c,
+  0x7d, 0x75, 0x0d, 0x41, 0x12, 0x0d, 0x16, 0xc2, 0x04, 0xe4, 0x90, 0x7f, 0xcb, 0xf0, 0x80, 0x39,
+  0x90, 0x7f, 0xcc, 0xe0, 0x20, 0xe1, 0x32, 0x12, 0x13, 0x87, 0xef, 0xc3, 0x94, 0x40, 0x50}},
+ {0x0486, 64, { 0x29, 0x90, 0x7c, 0xc0, 0xe0, 0x13, 0x92, 0x0a, 0x90, 0x7f, 0xcd, 0xe0, 0x14, 0xf5, 0x19, 0x20, 0x00,
+  0x11, 0x60, 0x0f, 0xf5, 0x08, 0x7e, 0x7c, 0x7f, 0xc1, 0x75, 0x0c, 0x7c, 0x75, 0x0d, 0xc1, 0x12,
+  0x0d, 0x16, 0xd2, 0x04, 0xe4, 0x90, 0x7f, 0xcd, 0xf0, 0x90, 0x7f, 0xba, 0xe0, 0x30, 0xe1, 0x03,
+  0x02, 0x05, 0x38, 0x12, 0x12, 0x3f, 0x8f, 0x19, 0x12, 0x13, 0x93, 0x8f, 0x37, 0xe5, 0x19}},
+ {0x04c6, 64, { 0xc3, 0x95, 0x3b, 0x50, 0x0f, 0x12, 0x13, 0x6f, 0xef, 0x30, 0xe0, 0x08, 0xe5, 0x37, 0x20, 0xe7, 0x03,
+  0x30, 0x0c, 0x5e, 0xc2, 0x0c, 0xe5, 0x19, 0x60, 0x58, 0xb4, 0x80, 0x03, 0x43, 0x37, 0x02, 0xe5,
+  0x37, 0x30, 0xe7, 0x26, 0xe5, 0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19,
+  0x08, 0x7e, 0x7d, 0x7f, 0x80, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x80, 0xaf, 0x37, 0x12, 0x0f}},
+ {0x0506, 64, { 0x96, 0xe5, 0x19, 0x25, 0xe0, 0x90, 0x7f, 0xbb, 0xf0, 0x80, 0x27, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40,
+  0x03, 0x75, 0x19, 0x3f, 0x85, 0x19, 0x08, 0x90, 0x7d, 0x80, 0xe5, 0x37, 0xf0, 0x7e, 0x7d, 0x7f,
+  0x81, 0x75, 0x0c, 0x7d, 0x75, 0x0d, 0x81, 0x12, 0x0d, 0x3b, 0xe5, 0x19, 0x04, 0x90, 0x7f, 0xbb,
+  0xf0, 0x90, 0x7f, 0xd0, 0xe0, 0x30, 0xe1, 0x06, 0x20, 0x06, 0x03, 0x02, 0x07, 0x99, 0xe4}},
+ {0x0546, 64, { 0xf5, 0x18, 0x74, 0xc0, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x18,
+  0x7c, 0x00, 0x7b, 0x01, 0x7a, 0x7e, 0x79, 0x20, 0x24, 0x20, 0xf9, 0xec, 0x34, 0x7e, 0xfa, 0xef,
+  0x12, 0x0e, 0xe4, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x20, 0xd7, 0x90, 0x7e, 0x20, 0xe0, 0x60, 0x68,
+  0x90, 0x7e, 0x23, 0xe0, 0x60, 0x24, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x12, 0x1a, 0x7f, 0x03}},
+ {0x0586, 64, { 0x7d, 0xcd, 0x12, 0x12, 0x1a, 0x43, 0x47, 0x80, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00,
+  0xe5, 0x47, 0xf0, 0xe4, 0x90, 0x7e, 0x33, 0xf0, 0x80, 0x30, 0x90, 0x7e, 0x21, 0xe0, 0xff, 0x12,
+  0x11, 0x38, 0x90, 0x7e, 0x22, 0xe0, 0xff, 0x12, 0x11, 0x5e, 0x7f, 0x01, 0x90, 0x7e, 0x31, 0xe0,
+  0xfd, 0x12, 0x12, 0x1a, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x12, 0x1a, 0x43, 0x47, 0x80, 0x90}},
+ {0x05c6, 64, { 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
+  0xe5, 0x41, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e, 0x23, 0xe0, 0x70, 0x06, 0x90, 0x7e,
+  0x33, 0xe0, 0x70, 0x08, 0xe4, 0x90, 0x7e, 0x33, 0xf0, 0x75, 0x2e, 0xff, 0x90, 0x7e, 0x25, 0xe0,
+  0x60, 0x12, 0xa3, 0xe0, 0x54, 0x3f, 0xf5, 0x45, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90}},
+ {0x0606, 64, { 0xc0, 0x00, 0xe5, 0x45, 0xf0, 0x90, 0x7e, 0x27, 0xe0, 0x60, 0x2b, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x43,
+  0x80, 0x80, 0x03, 0x53, 0x43, 0x7f, 0x53, 0x43, 0xfc, 0x90, 0x7e, 0x29, 0xe0, 0x60, 0x11, 0x43,
+  0x43, 0x02, 0xa3, 0xe0, 0xff, 0x12, 0x11, 0x84, 0x90, 0x7e, 0x2b, 0xe0, 0xff, 0x12, 0x11, 0xaa,
+  0xaf, 0x43, 0x12, 0x11, 0x12, 0x90, 0x7e, 0x23, 0xe0, 0x60, 0x08, 0x53, 0x43, 0x7f, 0xaf}},
+ {0x0646, 64, { 0x43, 0x12, 0x11, 0x12, 0x90, 0x7e, 0x2c, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x02,
+  0x80, 0x03, 0x53, 0x47, 0xfd, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47,
+  0xf0, 0x90, 0x7e, 0x2e, 0xe0, 0x60, 0x18, 0xa3, 0xe0, 0x60, 0x05, 0x43, 0x47, 0x01, 0x80, 0x03,
+  0x53, 0x47, 0xfe, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0}},
+ {0x0686, 64, { 0x90, 0x7e, 0x32, 0xe0, 0xf5, 0x3b, 0xa3, 0xe0, 0x13, 0x92, 0x0e, 0xa3, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0,
+  0x60, 0x05, 0x43, 0x47, 0x10, 0x80, 0x03, 0x53, 0x47, 0xef, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0,
+  0x90, 0xc0, 0x00, 0xe5, 0x47, 0xf0, 0x90, 0x7e, 0x36, 0xe0, 0x60, 0x32, 0x53, 0x45, 0xbf, 0x90,
+  0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f}},
+ {0x06c6, 64, { 0x98, 0x74, 0x09, 0xf0, 0x12, 0x13, 0x63, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0x53, 0x3f, 0xfd,
+  0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x1a, 0xe4, 0xf5, 0x33, 0xf5, 0x32, 0xd2, 0x08, 0x90, 0x7e,
+  0x37, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x02, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x1a, 0x75, 0x32,
+  0x01, 0xd2, 0x08, 0x90, 0x7e, 0x38, 0xe0, 0x60, 0x10, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0}},
+ {0x0706, 64, { 0xe5, 0x41, 0x44, 0x04, 0x90, 0xc0, 0x00, 0xf0, 0xd2, 0x00, 0x90, 0x7e, 0x39, 0xe0, 0x60, 0x11, 0x43,
+  0x45, 0x40, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
+  0x90, 0x7e, 0x3a, 0xe0, 0x60, 0x0f, 0x53, 0x3f, 0xfe, 0xe4, 0xff, 0xad, 0x3f, 0x12, 0x12, 0x1a,
+  0x75, 0x34, 0x01, 0xd2, 0x08, 0x90, 0x7e, 0x3b, 0xe0, 0x60, 0x0f, 0x43, 0x3f, 0x01, 0xe4}},
+ {0x0746, 64, { 0xff, 0xad, 0x3f, 0x12, 0x12, 0x1a, 0xe4, 0xf5, 0x34, 0xd2, 0x08, 0x90, 0x7e, 0x3c, 0xe0, 0x60, 0x0e,
+  0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0xe5, 0x41, 0x44, 0x02, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7e,
+  0x3d, 0xe0, 0x60, 0x02, 0xd2, 0x0c, 0x90, 0x7e, 0x3e, 0xe0, 0x60, 0x08, 0x75, 0x35, 0x01, 0xe4,
+  0xf5, 0x39, 0xd2, 0x08, 0x90, 0x7e, 0x3f, 0xe0, 0x60, 0x11, 0x90, 0x7f, 0xd7, 0x74, 0x13}},
+ {0x0786, 64, { 0xf0, 0x74, 0x33, 0xf0, 0x74, 0x16, 0xf0, 0x74, 0x36, 0xf0, 0xd2, 0x04, 0xc2, 0x06, 0xe4, 0x90, 0x7f,
+  0xd1, 0xf0, 0x30, 0x1a, 0x54, 0xe5, 0x39, 0x60, 0x02, 0x15, 0x39, 0x30, 0x13, 0x4b, 0xe5, 0x13,
+  0xd3, 0x94, 0x00, 0x40, 0x04, 0x15, 0x13, 0x80, 0x40, 0x75, 0x13, 0x0a, 0x30, 0x1b, 0x02, 0xc2,
+  0x13, 0x12, 0x13, 0x63, 0xef, 0x54, 0x01, 0xf5, 0x19, 0x65, 0x33, 0x60, 0x05, 0x85, 0x19}},
+ {0x07c6, 64, { 0x33, 0xd2, 0x08, 0x12, 0x13, 0x9f, 0xef, 0x54, 0x80, 0x64, 0x80, 0xf5, 0x19, 0x65, 0x2f, 0x60, 0x05,
+  0x85, 0x19, 0x2f, 0xd2, 0x08, 0x30, 0x0e, 0x11, 0x12, 0x13, 0x9f, 0xef, 0x54, 0x10, 0xf5, 0x19,
+  0x65, 0x2e, 0x60, 0x05, 0x85, 0x19, 0x2e, 0xd2, 0x08, 0x30, 0x1a, 0x2a, 0x90, 0x7f, 0xd2, 0xe0,
+  0x20, 0xe1, 0x23, 0x90, 0x7b, 0x40, 0xe0, 0x60, 0x09, 0xe0, 0xf5, 0x15, 0x90, 0x7b, 0x42}},
+ {0x0806, 64, { 0xe0, 0xf5, 0x16, 0x90, 0x7b, 0x41, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37,
+  0xf0, 0xe4, 0x90, 0x7f, 0xd3, 0xf0, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x09, 0x24,
+  0xe5, 0x0a, 0x70, 0x40, 0x30, 0x07, 0x39, 0xe5, 0x38, 0x70, 0x35, 0xc2, 0x07, 0xf5, 0x18, 0x7e,
+  0x00, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9e}},
+ {0x0846, 64, { 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5,
+  0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0, 0x75, 0x38, 0x10, 0xe4, 0xf5, 0x2c,
+  0x75, 0x0a, 0x01, 0x22, 0xe5, 0x0a, 0x64, 0x01, 0x70, 0x40, 0x30, 0x08, 0x39, 0xe5, 0x39, 0x70,
+  0x35, 0xc2, 0x08, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xee}},
+ {0x0886, 64, { 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9e, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5,
+  0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x09, 0xf0,
+  0x75, 0x39, 0x10, 0xe4, 0xf5, 0x35, 0x75, 0x0a, 0x02, 0x22, 0xe5, 0x0a, 0x64, 0x02, 0x70, 0x36,
+  0x30, 0x14, 0x2f, 0xc2, 0x14, 0xf5, 0x18, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x0e, 0x25, 0x18}},
+ {0x08c6, 64, { 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9e, 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34,
+  0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x05, 0xdb, 0x90, 0x7f, 0xc3, 0x74,
+  0x05, 0xf0, 0x75, 0x0a, 0x03, 0x22, 0xe5, 0x15, 0x60, 0x30, 0x15, 0x15, 0xe4, 0xf5, 0x18, 0x7e,
+  0x00, 0x7b, 0x00, 0x74, 0x14, 0x25, 0x18, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x0e, 0x9e}},
+ {0x0906, 64, { 0xff, 0x74, 0x80, 0x25, 0x18, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x18, 0xe5,
+  0x18, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x0a, 0x22, 0x90, 0x7f,
+  0xe9, 0xe0, 0x12, 0x0e, 0xf6, 0x0a, 0x0c, 0x00, 0x0a, 0x80, 0x01, 0x0a, 0xec, 0x03, 0x09, 0x48,
+  0x06, 0x09, 0xff, 0x08, 0x09, 0xf9, 0x09, 0x09, 0xe1, 0x0a, 0x09, 0xf0, 0x0b, 0x00, 0x00}},
+ {0x0946, 64, { 0x0b, 0x3b, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x19, 0x14, 0x60, 0x61, 0x24, 0x02, 0x60, 0x03,
+  0x02, 0x09, 0xd7, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x00, 0x90, 0x7f, 0xd5, 0xf0, 0x02,
+  0x0b, 0x42, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x04, 0x7f, 0x02, 0x80, 0x02, 0x7f, 0x03, 0x75, 0x82,
+  0x82, 0x75, 0x83, 0x19, 0xef, 0xf0, 0x75, 0x82, 0x7b, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82}},
+ {0x0986, 64, { 0x74, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x66, 0x75, 0x83, 0x19, 0xf0, 0x75, 0x82, 0x58, 0x75, 0x83,
+  0x19, 0xf0, 0x90, 0x7f, 0xea, 0xe0, 0x04, 0x75, 0x82, 0x17, 0x75, 0x83, 0x19, 0xf0, 0x74, 0x19,
+  0x90, 0x7f, 0xd4, 0xf0, 0x74, 0x12, 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0xea,
+  0xe0, 0xff, 0x12, 0x0f, 0x1c, 0xea, 0x49, 0x60, 0x0d, 0xea, 0x90, 0x7f, 0xd4, 0xf0, 0xe9}},
+ {0x09c6, 64, { 0x90, 0x7f, 0xd5, 0xf0, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x42,
+  0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0x00, 0xe5, 0x09, 0xf0,
+  0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x09, 0x02,
+  0x0b, 0x42, 0x12, 0x0b, 0x4a, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0x00, 0x74, 0x01, 0xf0, 0x90}},
+ {0x0a06, 64, { 0x7f, 0xb5, 0xf0, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31,
+  0x24, 0x02, 0x70, 0x5b, 0xa2, 0x10, 0xe4, 0x33, 0xff, 0x25, 0xe0, 0xff, 0xa2, 0x16, 0xe4, 0x33,
+  0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b,
+  0x42, 0xe4, 0x90, 0x7f, 0x00, 0xf0, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02}},
+ {0x0a46, 64, { 0x0b, 0x42, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07,
+  0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0x90,
+  0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x02, 0xf0, 0x02, 0x0b, 0x42, 0x90,
+  0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe}},
+ {0x0a86, 64, { 0x60, 0x1d, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x05, 0xc2,
+  0x10, 0x02, 0x0b, 0x42, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x0b, 0x42, 0x90, 0x7f,
+  0xea, 0xe0, 0x70, 0x38, 0x90, 0x7f, 0xec, 0xe0, 0xf4, 0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff,
+  0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83}},
+ {0x0ac6, 64, { 0xe4, 0xf0, 0x90, 0x7f, 0xec, 0xe0, 0x54, 0x80, 0xff, 0x13, 0x13, 0x13, 0x54, 0x1f, 0xff, 0xe0, 0x54,
+  0x07, 0x2f, 0x90, 0x7f, 0xd7, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x5f, 0x90, 0x7f, 0xb4, 0xe0,
+  0x44, 0x01, 0xf0, 0x80, 0x56, 0x90, 0x7f, 0xe8, 0xe0, 0x24, 0xfe, 0x60, 0x18, 0x24, 0x02, 0x70,
+  0x4a, 0x90, 0x7f, 0xea, 0xe0, 0xb4, 0x01, 0x04, 0xd2, 0x10, 0x80, 0x3f, 0x90, 0x7f, 0xb4}},
+ {0x0b06, 64, { 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x36, 0x90, 0x7f, 0xea, 0xe0, 0x70, 0x20, 0x90, 0x7f, 0xec, 0xe0, 0xf4,
+  0x54, 0x80, 0xff, 0xc4, 0x54, 0x0f, 0xff, 0xe0, 0x54, 0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5,
+  0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
+  0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0}},
+ {0x0b46, 64, { 0x44, 0x02, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0x30, 0xf0, 0xe4, 0x90,
+  0x7f, 0x96, 0xf0, 0x90, 0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90,
+  0x7f, 0x98, 0x74, 0x18, 0xf0, 0xe4, 0xf5, 0x8e, 0x90, 0x7f, 0xdf, 0x74, 0xff, 0xf0, 0x90, 0x7f,
+  0xde, 0xf0, 0xe4, 0xf5, 0x24, 0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x24, 0x25, 0x18, 0xf9}},
+ {0x0b86, 64, { 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12, 0x0e, 0xe4, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3a,
+  0x01, 0xe4, 0xf5, 0x38, 0xf5, 0x13, 0xf5, 0x36, 0xc2, 0x07, 0xc2, 0x0b, 0xc2, 0x05, 0xc2, 0x00,
+  0xc2, 0x09, 0xc2, 0x13, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x75, 0x44, 0x03, 0x90, 0xc0, 0x00,
+  0x74, 0x03, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x11, 0xd0, 0x7f, 0x10, 0x8f, 0x42, 0x12}},
+ {0x0bc6, 64, { 0x10, 0xa0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x7f, 0x01, 0x8f, 0x40, 0xef, 0x44, 0x06, 0x90, 0xc0,
+  0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14, 0xf0, 0x75, 0x46, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80,
+  0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x11, 0xd0, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3e, 0x12,
+  0x11, 0xd0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05}},
+ {0x0c06, 64, { 0x7d, 0x7f, 0x12, 0x11, 0xd0, 0x7f, 0x01, 0x12, 0x12, 0x89, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x11, 0xd0,
+  0x7f, 0x13, 0x7d, 0x09, 0x12, 0x11, 0xd0, 0x20, 0x1b, 0x03, 0x02, 0x0c, 0xc9, 0x75, 0x2d, 0x01,
+  0x75, 0x18, 0x01, 0x7b, 0x00, 0x74, 0x2d, 0x25, 0x18, 0xf9, 0xe4, 0x34, 0x00, 0xfa, 0xe4, 0x12,
+  0x0e, 0xe4, 0x05, 0x18, 0xe5, 0x18, 0xb4, 0x09, 0xea, 0x75, 0x3b, 0x01, 0xe4, 0xf5, 0x39}},
+ {0x0c46, 64, { 0xf5, 0x13, 0xf5, 0x37, 0xc2, 0x08, 0xc2, 0x0c, 0xc2, 0x06, 0xc2, 0x00, 0xc2, 0x0a, 0xc2, 0x13, 0x90,
   0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x75, 0x45, 0x03, 0x90, 0xc0, 0x00, 0x74, 0x03, 0xf0, 0x7f, 0x0c,
-  0xe4, 0xfd, 0x12, 0x12, 0x2d, 0x7f, 0x10, 0x8f, 0x43, 0x12, 0x11, 0x25, 0x90, 0x7f, 0x98}},
- {0x0c86, 64, { 0x74, 0x0a, 0xf0, 0x7f, 0x01, 0x8f, 0x41, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x0c, 0xf0, 0x75, 0x47, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12,
-  0x12, 0x2d, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3f, 0x12, 0x12, 0x2d, 0x90, 0x7f, 0x98,
-  0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x12, 0x2d}},
- {0x0cc6, 64, { 0x7f, 0x01, 0x12, 0x12, 0xbd, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x12, 0x2d, 0x7f, 0x13, 0x7d, 0x09, 0x12,
-  0x12, 0x2d, 0xd2, 0x12, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5,
+  0xe4, 0xfd, 0x12, 0x12, 0x1a, 0x7f, 0x10, 0x8f, 0x43, 0x12, 0x11, 0x12, 0x90, 0x7f, 0x98, 0x74,
+  0x0a, 0xf0, 0x7f, 0x01, 0x8f, 0x41, 0xef, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f}},
+ {0x0c86, 64, { 0x98, 0x74, 0x0c, 0xf0, 0x75, 0x47, 0x80, 0x90, 0xc0, 0x00, 0x74, 0x80, 0xf0, 0x0f, 0xe4, 0xfd, 0x12,
+  0x12, 0x1a, 0xe4, 0xff, 0x7e, 0xa3, 0xad, 0x06, 0x8d, 0x3f, 0x12, 0x12, 0x1a, 0x90, 0x7f, 0x98,
+  0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x12, 0x1a, 0x7f,
+  0x01, 0x12, 0x12, 0xaa, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x12, 0x1a, 0x7f, 0x13, 0x7d, 0x09}},
+ {0x0cc6, 64, { 0x12, 0x12, 0x1a, 0xd2, 0x12, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5,
   0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3,
-  0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10}},
- {0x0d06, 64, { 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0,
-  0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90,
+  0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0,
+  0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90}},
+ {0x0d06, 64, { 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3, 0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x90,
   0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2,
-  0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86}},
- {0x0d46, 64, { 0xdf, 0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5, 0x82,
-  0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3,
+  0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0x05, 0x86, 0xe0, 0xa3, 0x05, 0x86, 0xf0, 0x05, 0x86, 0xdf,
+  0xf7, 0xd2, 0xaf, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0xaf, 0x08, 0xe5, 0x0d, 0xf5}},
+ {0x0d46, 64, { 0x82, 0xe5, 0x0c, 0xf5, 0x83, 0xc2, 0xaf, 0x05, 0x86, 0x90, 0xc0, 0x00, 0xe0, 0x05, 0x86, 0xf0, 0xa3,
   0x05, 0x86, 0xdf, 0xf7, 0x05, 0x86, 0xd2, 0xaf, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5,
-  0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44}},
- {0x0d86, 64, { 0x80, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xd2, 0x19, 0x90, 0x7f, 0x92, 0xe0,
-  0x44, 0x02, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x10, 0xe4, 0x33, 0xfe, 0xef, 0x4e,
+  0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80,
+  0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xd2, 0x19, 0x90, 0x7f, 0x92}},
+ {0x0d86, 64, { 0xe0, 0x44, 0x02, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x10, 0xe4, 0x33, 0xfe, 0xef, 0x4e,
   0xf0, 0xd2, 0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0,
-  0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53}},
- {0x0dc6, 64, { 0x91, 0xef, 0x90, 0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0, 0xd2,
-  0xaf, 0xd2, 0x1a, 0x12, 0x12, 0x77, 0xc2, 0x11, 0xe4, 0xf5, 0x0b, 0xf5, 0x13, 0xc2, 0x17, 0xc2,
+  0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91,
+  0xef, 0x90, 0x7f, 0xaf, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0xe0, 0x44, 0x0d, 0xf0}},
+ {0x0dc6, 64, { 0xd2, 0xaf, 0xd2, 0x1a, 0x12, 0x12, 0x64, 0xc2, 0x11, 0xe4, 0xf5, 0x0b, 0xf5, 0x13, 0xc2, 0x17, 0xc2,
   0x12, 0x90, 0x7f, 0xa1, 0x04, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x17, 0x60, 0x10, 0x30, 0x12,
-  0x05, 0xd2, 0x1a, 0x12, 0x00, 0x46, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x17, 0x80, 0x08, 0x30}},
- {0x0e06, 64, { 0x12, 0x05, 0xc2, 0x1a, 0x12, 0x00, 0x46, 0x30, 0x11, 0x07, 0xc2, 0x11, 0x12, 0x09, 0x2d, 0x80, 0xd6,
-  0x30, 0x18, 0xd3, 0xc2, 0x18, 0x12, 0x13, 0xad, 0x80, 0xcc, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8,
-  0xfd, 0x75, 0x81, 0x47, 0x02, 0x0e, 0x69, 0x02, 0x0d, 0x91, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93,
-  0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3}},
- {0x0e46, 64, { 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04,
-  0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
-  0x40, 0x80, 0x90, 0x12, 0xde, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30,
-  0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25}},
- {0x0e86, 64, { 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8,
-  0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83,
+  0x05, 0xd2, 0x1a, 0x12, 0x00, 0x46, 0x90, 0x7f, 0xd8, 0xe0, 0xf5, 0x17, 0x80, 0x08, 0x30, 0x12,
+  0x05, 0xc2, 0x1a, 0x12, 0x00, 0x46, 0x30, 0x11, 0x07, 0xc2, 0x11, 0x12, 0x09, 0x25, 0x80}},
+ {0x0e06, 64, { 0xd6, 0x30, 0x18, 0xd3, 0xc2, 0x18, 0x12, 0x13, 0xab, 0x80, 0xcc, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8,
+  0xfd, 0x75, 0x81, 0x47, 0x02, 0x0e, 0x59, 0x02, 0x0d, 0x81, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93,
+  0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8,
+  0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40}},
+ {0x0e46, 64, { 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
+  0x40, 0x80, 0x90, 0x12, 0xcb, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30,
+  0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0,
+  0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3}},
+ {0x0e86, 64, { 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83,
   0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22,
-  0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93}},
- {0x0ec6, 64, { 0x22, 0xbb, 0x01, 0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50,
-  0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22,
+  0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22,
+  0xbb, 0x01, 0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22}},
+ {0x0ec6, 64, { 0x50, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22,
   0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06,
-  0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22}},
- {0x0f06, 64, { 0xd0, 0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93,
-  0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef,
+  0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0,
+  0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3}},
+ {0x0f06, 64, { 0x93, 0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef,
   0xa3, 0xa3, 0xa3, 0x80, 0xdf, 0x8f, 0x18, 0xe4, 0xf5, 0x19, 0x75, 0x1a, 0xff, 0x75, 0x1b, 0x19,
-  0x75, 0x1c, 0x86, 0xab, 0x1a, 0xaa, 0x1b, 0xa9, 0x1c, 0x90, 0x00, 0x01, 0x12, 0x0e, 0xc7}},
- {0x0f46, 64, { 0xb4, 0x03, 0x1d, 0xaf, 0x19, 0x05, 0x19, 0xef, 0xb5, 0x18, 0x01, 0x22, 0x12, 0x0e, 0xae, 0x7e, 0x00,
-  0x29, 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x1a, 0xff, 0xf5, 0x1b, 0x89, 0x1c, 0x80, 0xd4, 0x7b,
+  0x75, 0x1c, 0x86, 0xab, 0x1a, 0xaa, 0x1b, 0xa9, 0x1c, 0x90, 0x00, 0x01, 0x12, 0x0e, 0xb7, 0xb4,
+  0x03, 0x1d, 0xaf, 0x19, 0x05, 0x19, 0xef, 0xb5, 0x18, 0x01, 0x22, 0x12, 0x0e, 0x9e, 0x7e}},
+ {0x0f46, 64, { 0x00, 0x29, 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x1a, 0xff, 0xf5, 0x1b, 0x89, 0x1c, 0x80, 0xd4, 0x7b,
   0x00, 0x7a, 0x00, 0x79, 0x00, 0x22, 0x8f, 0x1a, 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02,
-  0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12, 0x00, 0x36, 0x05, 0x0d}},
- {0x0f86, 64, { 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08,
-  0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x41, 0x8f, 0x1a, 0xef, 0x42, 0x36, 0x80, 0xca, 0x22, 0x8f,
+  0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12, 0x00, 0x36, 0x05, 0x0d, 0xe5,
+  0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15}},
+ {0x0f86, 64, { 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x3f, 0x8f, 0x1a, 0xef, 0x42, 0x36, 0x80, 0xca, 0x22, 0x8f,
   0x1a, 0x05, 0x0d, 0xe5, 0x0d, 0xae, 0x0c, 0x70, 0x02, 0x05, 0x0c, 0x14, 0xf5, 0x82, 0x8e, 0x83,
-  0xe5, 0x1a, 0xf0, 0x12, 0x13, 0x59, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05}},
- {0x0fc6, 64, { 0x0c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13, 0x95,
-  0x8f, 0x1a, 0xef, 0x42, 0x37, 0x80, 0xca, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c,
+  0xe5, 0x1a, 0xf0, 0x12, 0x13, 0x57, 0x05, 0x0d, 0xe5, 0x0d, 0xac, 0x0c, 0x70, 0x02, 0x05, 0x0c,
+  0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x08, 0xe5, 0x08, 0x60, 0x0a, 0x12, 0x13}},
+ {0x0fc6, 64, { 0x93, 0x8f, 0x1a, 0xef, 0x42, 0x37, 0x80, 0xca, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c,
   0x74, 0x30, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74,
-  0x27, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x20, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x07, 0xf0, 0xe4}},
- {0x1006, 64, { 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x22, 0xc0,
-  0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f,
-  0xc4, 0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84,
-  0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82}},
- {0x1046, 64, { 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x11, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab,
-  0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32,
-  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74,
-  0x10, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44}},
- {0x1086, 64, { 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74,
-  0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74,
-  0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90}},
- {0x10c6, 64, { 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00,
-  0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f,
-  0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5,
-  0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90}},
- {0x1106, 64, { 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90,
-  0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f,
-  0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
-  0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f}},
- {0x1146, 64, { 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0,
-  0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b,
-  0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0,
-  0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00}},
- {0x1186, 64, { 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22,
-  0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74,
-  0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54,
-  0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00}},
- {0x11c6, 64, { 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74,
-  0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x17, 0xf0,
-  0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xed}},
- {0x1206, 64, { 0xf0, 0x22, 0x12, 0x13, 0x29, 0x8f, 0x1a, 0x12, 0x13, 0x29, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60,
-  0x12, 0x12, 0x13, 0x29, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x29, 0x8f,
-  0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f,
-  0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0f, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0}},
- {0x1246, 64, { 0x90, 0x7f, 0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x7d, 0x8f, 0x1a,
-  0x12, 0x13, 0x7d, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x7d, 0x8f, 0x1a,
-  0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x7d, 0x8f, 0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22,
-  0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x1a, 0x04, 0xe0}},
- {0x1286, 64, { 0x44, 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12, 0x12, 0xfa, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0,
-  0xe0, 0x44, 0x04, 0xf0, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3e, 0x54, 0x7f, 0xfd, 0x12, 0x11,
-  0xe3, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3e, 0x44,
-  0x80, 0xfd, 0x12, 0x11, 0xe3, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3f, 0x54, 0x7f, 0xfd}},
- {0x12c6, 64, { 0x12, 0x12, 0x2d, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3f,
-  0x44, 0x80, 0xfd, 0x12, 0x12, 0x2d, 0x22, 0x05, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x14,
-  0x03, 0x00, 0x00, 0xc1, 0x11, 0xc1, 0x18, 0xc1, 0x95, 0xc1, 0x10, 0xc1, 0x16, 0x01, 0x0a, 0x00,
-  0xc1, 0x9b, 0x00, 0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19, 0xae, 0x18, 0x70, 0x02}},
- {0x1306, 64, { 0x15, 0x18, 0x4e, 0x60, 0x05, 0x12, 0x0d, 0x70, 0x80, 0xee, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0,
-  0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xe0,
-  0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f,
-  0x98, 0x74, 0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x15}},
- {0x1346, 64, { 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xe0,
-  0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f,
-  0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0,
-  0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00}},
- {0x1386, 64, { 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f,
-  0x98, 0x74, 0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0,
-  0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x12, 0x0f, 0xdf, 0x12, 0x0d, 0x81, 0x12, 0x0b, 0x52, 0x22,
-  0x53, 0xd8, 0xef, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+  0x27, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x20, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x07, 0xf0, 0xe4, 0x90,
+  0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x22}},
+ {0x1006, 64, { 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x11,
+  0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0,
+  0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84,
+  0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x18, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08}},
+ {0x1046, 64, { 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7f, 0x98,
+  0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x10, 0xf0, 0x90,
+  0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0,
+  0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0}},
+ {0x1086, 64, { 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0,
+  0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90,
+  0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22}},
+ {0x10c6, 64, { 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x14,
+  0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f,
+  0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf,
+  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98}},
+ {0x1106, 64, { 0x74, 0x13, 0xf0, 0xe5, 0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b,
+  0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0, 0x00,
+  0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0,
+  0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f}},
+ {0x1146, 64, { 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45,
+  0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00,
+  0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f,
+  0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f}},
+ {0x1186, 64, { 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90,
+  0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0,
+  0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90,
+  0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0b}},
+ {0x11c6, 64, { 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0xe5,
+  0x44, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x17, 0xf0, 0x90, 0xc0, 0x00,
+  0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13,
+  0x27, 0x8f, 0x1a, 0x12, 0x13, 0x27, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12}},
+ {0x1206, 64, { 0x13, 0x27, 0x8f, 0x1a, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x07, 0x12, 0x13, 0x27, 0x8f, 0x1b, 0x80, 0xe8,
+  0xaf, 0x1a, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0xe5, 0x45, 0x54, 0x7f, 0x90, 0xc0, 0x00,
+  0xf0, 0x90, 0x7f, 0x98, 0x74, 0x0f, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x7f, 0x98, 0x74,
+  0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x12, 0x13, 0x7b, 0x8f, 0x1a, 0x12, 0x13}},
+ {0x1246, 64, { 0x7b, 0x8f, 0x1b, 0xe5, 0x1a, 0x65, 0x1b, 0x60, 0x12, 0x12, 0x13, 0x7b, 0x8f, 0x1a, 0xe5, 0x1a, 0x65,
+  0x1b, 0x60, 0x07, 0x12, 0x13, 0x7b, 0x8f, 0x1b, 0x80, 0xe8, 0xaf, 0x1a, 0x22, 0x90, 0x7f, 0xd6,
+  0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x1a, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f,
+  0xf4, 0x7e, 0x01, 0x12, 0x12, 0xe7, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44}},
+ {0x1286, 64, { 0x04, 0xf0, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3e, 0x54, 0x7f, 0xfd, 0x12, 0x11, 0xd0, 0x90, 0x7f,
+  0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3e, 0x44, 0x80, 0xfd, 0x12,
+  0x11, 0xd0, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x3f, 0x54, 0x7f, 0xfd, 0x12, 0x12, 0x1a, 0x90,
+  0x7f, 0x98, 0x74, 0x09, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x3f, 0x44, 0x80}},
+ {0x12c6, 64, { 0xfd, 0x12, 0x12, 0x1a, 0x22, 0x05, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x14, 0x03, 0x00, 0x00,
+  0xc1, 0x11, 0xc1, 0x18, 0xc1, 0x95, 0xc1, 0x10, 0xc1, 0x16, 0x01, 0x0a, 0x00, 0xc1, 0x9b, 0x00,
+  0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19, 0xae, 0x18, 0x70, 0x02, 0x15, 0x18, 0x4e, 0x60,
+  0x05, 0x12, 0x0d, 0x60, 0x80, 0xee, 0x22, 0x00, 0x00, 0x02, 0x10, 0x06, 0x00, 0x02, 0x13}},
+ {0x1306, 64, { 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x02, 0x10, 0x2d, 0x90, 0x7f, 0x98, 0x74, 0x11, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x12, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x13, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x14, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x15, 0xf0, 0x90}},
+ {0x1346, 64, { 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x16, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0x98, 0x74, 0x08, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x09, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0a, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0b, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff}},
+ {0x1386, 64, { 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0c, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74,
+  0x0d, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0x98, 0x74, 0x0e, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x12, 0x0f, 0xcf, 0x12, 0x0d, 0x71, 0x12, 0x0b, 0x4a, 0x22, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
  {0x13c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x40, 0x00, 0x02, 0x14}},
- {0x1406, 64, { 0x04, 0x00, 0x02, 0x10, 0x16, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+ {0x1406, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
@@ -425,7 +426,7 @@
  {0x18c6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x00, 0x01, 0xff, 0x00}},
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00}},
  {0x1906, 64, { 0x00, 0x40, 0xcd, 0x06, 0x10, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x02, 0x09, 0x02, 0x74, 0x00, 0x01,
   0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00, 0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01,
   0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40,
@@ -443,5 +444,5 @@
   0x00, 0x42, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x69, 0x00, 0x61, 0x00, 0x6c,
   0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00, 0x70, 0x00, 0x74, 0x00, 0x65, 0x00}},
  {0x1a06,  4, { 0x72, 0x00, 0x00, 0x00}},
- {0xffff,	0,	{0x00} }
+ {0xffff,  0, {0x00}}
 };
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa49msg.h linux-2.4.19/drivers/usb/serial/keyspan_usa49msg.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa49msg.h	Wed Oct 10 00:15:03 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa49msg.h	Mon Nov 25 12:27:09 2002
@@ -41,14 +41,10 @@
 
 	4th revision: USA49W version
 
-	See usa26msg.h for description of message formats
-
-	Third revision: USA28X version (aka USA26)
-
 	Buffer formats for RX/TX data messages are not defined by
 	a structure, but are described here:
 
-	USB OUT (host -> USA26, transmit) messages contain a 
+	USB OUT (host -> USAxx, transmit) messages contain a 
 	REQUEST_ACK indicator (set to 0xff to request an ACK at the 
 	completion of transmit; 0x00 otherwise), followed by data:
 
@@ -56,17 +52,28 @@
 
 	with a total data length of 63.
 
-	USB IN (USA26 -> host, receive) messages contain either a zero
-	flag (indicating no error in any data bytes):
+	USB IN (USAxx -> host, receive) messages begin with a status
+	byte in which the 0x80 bit is either:
+				   	
+		(a)	0x80 bit clear
+			indicates that the bytes following it are all data
+			bytes:
+
+				STAT DATA DATA DATA DATA DATA ...
+
+			for a total of up to 63 DATA bytes,
+
+	or:
 
-		00 DAT DAT DAT ...
+		(b)	0x80 bit set
+			indiates that the bytes following alternate data and
+			status bytes:
 
-	for a total of 63 data bytes, or a non-zero status flag (indicating 
-	that all data bytes will be preceded by status flag):
+				STAT DATA STAT DATA STAT DATA STAT DATA ...
 
-		STAT DAT STAT DAT STAT DAT ...
+			for a total of up to 32 DATA bytes.
 
-	for a total of 32 data bytes.  The valid bits in the STAT bytes are:
+	The valid bits in the STAT bytes are:
 
 		OVERRUN	0x02
 		PARITY	0x04
@@ -75,9 +82,19 @@
 
 	Notes:
 	
-	1.	a "no status" RX data message (first byte zero) can serve as
-		a "break off" indicator.
-	2.	a control message specifying disablePort will be answered
+	(1) The OVERRUN bit can appear in either (a) or (b) format
+		messages, but the but the PARITY/FRAMING/BREAK bits
+		only appear in (b) format messages.
+	(2) For the host to determine the exact point at which the
+		overrun occurred (to identify the point in the data
+		stream at which the data was lost), it needs to count
+		128 characters, starting at the first character of the
+		message in which OVERRUN was reported; the lost character(s)
+		would have been received between the 128th and 129th
+		characters.
+	(3)	An RX data message in which the first byte has 0x80 clear
+		serves as a "break off" indicator.
+	(4)	a control message specifying disablePort will be answered
 		with a status message, but no further status will be sent
 		until a control messages with enablePort is sent
 
@@ -92,6 +109,7 @@
 	2000mar09	change to support 4 ports
 	2000may03	change external clocking to match USA-49W hardware
 	2000jun01	add extended BSD-style copyright text
+	2001jul05	change message format to improve OVERRUN case
 */
 
 #ifndef	__USA49MSG__
@@ -107,7 +125,7 @@
 	0x80		globalControlMessage
 */
 
-typedef struct keyspan_usa49_portControlMessage
+struct keyspan_usa49_portControlMessage
 {
 	/*
 		0.	0/1/2/3 	port control message follows
@@ -173,7 +191,7 @@
 		enablePort,		// start servicing port (move data, check status)
 		disablePort;	// stop servicing port (does implicit tx/rx flush/off)
 	
-} keyspan_usa49_portControlMessage;
+};
 
 // defines for bits in lcr
 #define	USA_DATABITS_5		0x00
@@ -201,7 +219,7 @@
 	sends any control message (either global or port-specific).
 */
 
-typedef struct keyspan_usa49_globalControlMessage
+struct keyspan_usa49_globalControlMessage
 {
 	u8	portNumber,			// 0x80
 		sendGlobalStatus,	// 1/2=number of status responses requested
@@ -209,7 +227,7 @@
 		resetStatusCount,	// a cycling value
 		remoteWakeupEnable,		// 0x10=P1, 0x20=P2, 0x40=P3, 0x80=P4
 		disableStatusMessages;	// 1=send no status until host talks
-} keyspan_usa49_globalControlMessage;
+};
 
 /*
 	Device->host messages send on the global status endpoint
@@ -221,7 +239,7 @@
 	0x81				globalDebugMessage
 */
 
-typedef struct keyspan_usa49_portStatusMessage	// one for each port
+struct keyspan_usa49_portStatusMessage	// one for each port
 {
 	u8	portNumber,		// 0,1,2,3
 		cts,			// reports CTS pin
@@ -234,7 +252,7 @@
 		controlResponse,// 1=a control message has been processed
 		txAck,			// ACK (data TX complete)
 		rs232valid;		// RS-232 signal valid
-} keyspan_usa49_portStatusMessage;
+};
 
 // bits in RX data message when STAT byte is included
 #define	RXERROR_OVERRUN	0x02
@@ -242,19 +260,19 @@
 #define	RXERROR_FRAMING	0x08
 #define	RXERROR_BREAK	0x10
 
-typedef struct keyspan_usa49_globalStatusMessage
+struct keyspan_usa49_globalStatusMessage
 {
 	u8	portNumber,			// 0x80=globalStatusMessage
 		sendGlobalStatus,	// from request, decremented
 		resetStatusCount;	// as in request
-} keyspan_usa49_globalStatusMessage;
+};
 
-typedef struct keyspan_usa49_globalDebugMessage
+struct keyspan_usa49_globalDebugMessage
 {
 	u8	portNumber,			// 0x81=globalDebugMessage
 		n,					// typically a count/status byte
 		b;					// typically a data byte
-} keyspan_usa49_globalDebugMessage;
+};
 
 // ie: the maximum length of an EZUSB endpoint buffer
 #define	MAX_DATA_LEN			64
diff -Nur linux-2.4.19.old/drivers/usb/serial/keyspan_usa49w_fw.h linux-2.4.19/drivers/usb/serial/keyspan_usa49w_fw.h
--- linux-2.4.19.old/drivers/usb/serial/keyspan_usa49w_fw.h	Wed Oct 10 00:15:03 2001
+++ linux-2.4.19/drivers/usb/serial/keyspan_usa49w_fw.h	Mon Nov 25 12:27:09 2002
@@ -1,43 +1,47 @@
 /* keyspan_usa49w_fw.h
-  
-   Generated from Keyspan firmware image usa49code.h Sat Oct  6 12:06:59 EST 2001
-   This firmware is for the Keyspan USA-49W Serial Adaptor
 
-   "The firmware contained herein as keyspan_usa49w_fw.h is
-   Copyright (C) 1999-2001 Keyspan, A division of InnoSys Incorporated
-   ("Keyspan"), as an unpublished work.  This notice does not imply
-   unrestricted or public access to this firmware which is a trade secret of
-   Keyspan, and which may not be reproduced, used, sold or transferred to any
-   third party without Keyspan's prior written consent.  All Rights Reserved.
+	The firmware contained herein as keyspan_usa49w_fw.h is
 
-   This firmware may not be modified and may only be used with the Keyspan 
-   USA-49W Serial Adapter.  Distribution and/or Modification of the
-   keyspan.c driver which includes this firmware, in whole or in part,
-   requires the inclusion of this statement."
+		Copyright (C) 1999-2001
+		Keyspan, A division of InnoSys Incorporated ("Keyspan")
+		
+	as an unpublished work. This notice does not imply unrestricted or
+	public access to the source code from which this firmware image is
+	derived.  Except as noted below this firmware image may not be 
+	reproduced, used, sold or transferred to any third party without 
+	Keyspan's prior written consent.  All Rights Reserved.
+
+	Permission is hereby granted for the distribution of this firmware 
+	image as part of a Linux or other Open Source operating system kernel 
+	in text or binary form as required. 
+
+	This firmware may not be modified and may only be used with  
+	Keyspan hardware.  Distribution and/or Modification of the 
+	keyspan.c driver which includes this firmware, in whole or in 
+	part, requires the inclusion of this statement."
 
 */
 
 static const struct ezusb_hex_record keyspan_usa49w_firmware[] = {
- {0x7f92,  1, { 0x01}},
- {0x0033,  3, { 0x02, 0x18, 0xfc}},
+ {0x0033,  3, { 0x02, 0x18, 0xfb}},
  {0x0036, 12, { 0x90, 0x78, 0x41, 0x74, 0x01, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22}},
  {0x0046, 16, { 0xe4, 0xff, 0x74, 0x40, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xe0, 0xfe, 0xe5, 0x15}},
  {0x0056, 16, { 0x24, 0x04, 0xfd, 0xe4, 0x35, 0x14, 0xfa, 0xa9, 0x05, 0x7b, 0x01, 0xef, 0x7c, 0x00, 0x29, 0xf9}},
- {0x0066, 16, { 0xec, 0x3a, 0xfa, 0xee, 0x12, 0x11, 0xf6, 0x0f, 0xbf, 0x22, 0xd7, 0xe5, 0x15, 0x24, 0x05, 0xf5}},
+ {0x0066, 16, { 0xec, 0x3a, 0xfa, 0xee, 0x12, 0x11, 0xf1, 0x0f, 0xbf, 0x22, 0xd7, 0xe5, 0x15, 0x24, 0x05, 0xf5}},
  {0x0076, 16, { 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x70, 0x03, 0x02, 0x01, 0x34, 0xe5, 0x15, 0x24, 0x09}},
  {0x0086, 16, { 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x70, 0x0e, 0xe5, 0x15, 0x24, 0x0a, 0xf5, 0x82}},
- {0x0096, 16, { 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x18, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x16, 0x4c, 0xe5}},
+ {0x0096, 16, { 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x18, 0x7f, 0x01, 0xe4, 0xfd, 0x12, 0x16, 0x47, 0xe5}},
  {0x00a6, 16, { 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0xcf, 0xf0, 0x80, 0x41}},
- {0x00b6, 16, { 0xe5, 0x15, 0x24, 0x06, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x16, 0x7b}},
+ {0x00b6, 16, { 0xe5, 0x15, 0x24, 0x06, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x16, 0x76}},
  {0x00c6, 16, { 0xe5, 0x15, 0x24, 0x07, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x00, 0x03}},
  {0x00d6, 16, { 0x7f, 0x01, 0xe5, 0x15, 0x24, 0x08, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xfd, 0x12}},
- {0x00e6, 16, { 0x16, 0x4c, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x30}},
+ {0x00e6, 16, { 0x16, 0x47, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x30}},
  {0x00f6, 16, { 0xf0, 0xe5, 0x15, 0x24, 0x39, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x80, 0xf0}},
  {0x0003, 16, { 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x78, 0x41, 0x74}},
  {0x0013, 16, { 0x01, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24}},
  {0x0023, 16, { 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22}},
  {0x0043,  3, { 0x02, 0x1b, 0x00}},
- {0x0000,  3, { 0x02, 0x10, 0x9a}},
+ {0x0000,  3, { 0x02, 0x10, 0x95}},
  {0x0106, 64, { 0x90, 0x78, 0x41, 0x74, 0x04, 0xf0, 0xe5, 0x15, 0x24, 0x39, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83,
   0xe0, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x02, 0xf0, 0xe5, 0x15, 0x24, 0x36, 0xf5,
   0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0xe5, 0x15, 0x24,
@@ -49,16 +53,16 @@
  {0x0186, 64, { 0x15, 0x24, 0x17, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x11, 0xe5, 0x15, 0x24, 0x32,
   0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x04, 0xf0, 0x80, 0x0f, 0xe5, 0x15, 0x24,
   0x32, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0xfb, 0xf0, 0xe4, 0xff, 0xe5, 0x15,
-  0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xfd, 0x12, 0x16, 0x4c, 0xe5}},
+  0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xfd, 0x12, 0x16, 0x47, 0xe5}},
  {0x01c6, 64, { 0x15, 0x24, 0x0e, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x11, 0xe5, 0x15, 0x24, 0x33,
   0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x80, 0xf0, 0x80, 0x0f, 0xe5, 0x15, 0x24,
   0x33, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0xf0, 0xe5, 0x15, 0x24, 0x33,
   0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0xfc, 0xf0, 0xe5, 0x15, 0x24, 0x0f}},
  {0x0206, 64, { 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x2f, 0xe5, 0x15, 0x24, 0x33, 0xf5, 0x82, 0xe4,
   0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x02, 0xf0, 0xe5, 0x15, 0x24, 0x10, 0xf5, 0x82, 0xe4, 0x35,
-  0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x15, 0xec, 0xe5, 0x15, 0x24, 0x11, 0xf5, 0x82, 0xe4, 0x35,
-  0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x16, 0x1c, 0xe5, 0x15, 0x24, 0x33, 0xf5, 0x82, 0xe4}},
- {0x0246, 64, { 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x15, 0xbc, 0xe5, 0x15, 0x24, 0x14, 0xf5, 0x82, 0xe4, 0x35,
+  0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x15, 0xe7, 0xe5, 0x15, 0x24, 0x11, 0xf5, 0x82, 0xe4, 0x35,
+  0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x16, 0x17, 0xe5, 0x15, 0x24, 0x33, 0xf5, 0x82, 0xe4}},
+ {0x0246, 64, { 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0x12, 0x15, 0xb7, 0xe5, 0x15, 0x24, 0x14, 0xf5, 0x82, 0xe4, 0x35,
   0x14, 0xf5, 0x83, 0xe0, 0x60, 0x44, 0xe5, 0x15, 0x24, 0x15, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5,
   0x83, 0xe0, 0x60, 0x11, 0xe5, 0x15, 0x24, 0x39, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0,
   0x44, 0x01, 0xf0, 0x80, 0x0f, 0xe5, 0x15, 0x24, 0x39, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5}},
@@ -84,12 +88,12 @@
   0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14}},
  {0x03c6, 64, { 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x01, 0xf0, 0x12, 0x00,
   0x36, 0xef, 0x54, 0xfe, 0x90, 0xc0, 0x00, 0xf0, 0xe5, 0x15, 0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35,
-  0x14, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0xff, 0xf0, 0xfd, 0xe4, 0xff, 0x12, 0x16, 0x4c, 0xe5, 0x15,
+  0x14, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0xff, 0xf0, 0xfd, 0xe4, 0xff, 0x12, 0x16, 0x47, 0xe5, 0x15,
   0x24, 0x2c, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0, 0xe5, 0x15, 0x24, 0x2b}},
  {0x0406, 64, { 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0, 0xe5, 0x16, 0x42, 0x13, 0xe5, 0x15, 0x24, 0x1b,
   0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x70, 0x0e, 0xe5, 0x15, 0x24, 0x25, 0xf5, 0x82,
   0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x28, 0xe5, 0x15, 0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35,
-  0x14, 0xf5, 0x83, 0xe0, 0x44, 0x02, 0xff, 0xf0, 0xfd, 0xe4, 0xff, 0x12, 0x16, 0x4c, 0xe5}},
+  0x14, 0xf5, 0x83, 0xe0, 0x44, 0x02, 0xff, 0xf0, 0xfd, 0xe4, 0xff, 0x12, 0x16, 0x47, 0xe5}},
  {0x0446, 64, { 0x15, 0x24, 0x2b, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0xe5, 0x16, 0x42, 0x13,
   0xe5, 0x15, 0x24, 0x1c, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0x70, 0x0e, 0xe5,
   0x15, 0x24, 0x25, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x2a, 0x90, 0x78, 0x41,
@@ -100,12 +104,12 @@
   0xe0, 0x44, 0x40, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5}},
  {0x04c6, 64, { 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0xe5, 0x15, 0x24, 0x1e,
   0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x28, 0xe5, 0x15, 0x24, 0x32, 0xf5, 0x82,
-  0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0xfe, 0xff, 0xf0, 0xfd, 0xe4, 0xff, 0x12, 0x16, 0x4c,
+  0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0xfe, 0xff, 0xf0, 0xfd, 0xe4, 0xff, 0x12, 0x16, 0x47,
   0xe5, 0x15, 0x24, 0x2d, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0xe5}},
  {0x0506, 64, { 0x16, 0x42, 0x13, 0xe5, 0x15, 0x24, 0x1f, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x70, 0x0e,
   0xe5, 0x15, 0x24, 0x25, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x27, 0xe5, 0x15,
   0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x01, 0xff, 0xf0, 0xfd, 0xe4,
-  0xff, 0x12, 0x16, 0x4c, 0xe5, 0x15, 0x24, 0x2d, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83}},
+  0xff, 0x12, 0x16, 0x47, 0xe5, 0x15, 0x24, 0x2d, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83}},
  {0x0546, 64, { 0xe4, 0xf0, 0xe5, 0x16, 0x42, 0x13, 0xe5, 0x15, 0x24, 0x20, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83,
   0xe0, 0x70, 0x0e, 0xe5, 0x15, 0x24, 0x25, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60,
   0x18, 0x90, 0x78, 0x41, 0x74, 0x02, 0xf0, 0xe5, 0x15, 0x24, 0x36, 0xf5, 0x82, 0xe4, 0x35, 0x14,
@@ -115,12 +119,12 @@
   0x83, 0xe0, 0x60, 0x1f, 0xe5, 0x15, 0x24, 0x2e, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74,
   0x01, 0xf0, 0xe5, 0x15, 0x24, 0x3a, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0}},
  {0x05c6, 64, { 0xe5, 0x16, 0x42, 0x13, 0xe5, 0x15, 0x24, 0x23, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60,
-  0x03, 0x12, 0x18, 0x91, 0xe5, 0x15, 0x24, 0x24, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0,
+  0x03, 0x12, 0x18, 0x85, 0xe5, 0x15, 0x24, 0x24, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0,
   0x60, 0x1b, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x08,
   0xf0, 0x90, 0x7f, 0x98, 0xe0, 0xff, 0xe5, 0x16, 0xf4, 0xfe, 0xef, 0x5e, 0xf0, 0xe5, 0x15}},
  {0x0606, 64, { 0x24, 0x25, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x16, 0xe5, 0x15, 0x24, 0x31, 0xf5,
   0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0xf7, 0xf0, 0x90, 0x7f, 0x98, 0xe0, 0x45, 0x16,
-  0xf0, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x12, 0x08, 0x07, 0x83, 0x00, 0x07, 0xf7, 0x01, 0x08,
+  0xf0, 0x22, 0x90, 0x7f, 0xe9, 0xe0, 0x12, 0x12, 0x03, 0x07, 0x83, 0x00, 0x07, 0xf7, 0x01, 0x08,
   0x63, 0x03, 0x06, 0x4c, 0x06, 0x07, 0x74, 0x08, 0x07, 0x68, 0x09, 0x07, 0x50, 0x0a, 0x07}},
  {0x0646, 64, { 0x5f, 0x0b, 0x00, 0x00, 0x08, 0xb2, 0x90, 0x7f, 0xeb, 0xe0, 0x24, 0xfe, 0x60, 0x1c, 0x14, 0x70, 0x03,
   0x02, 0x06, 0xfe, 0x24, 0x02, 0x60, 0x03, 0x02, 0x07, 0x46, 0x74, 0x19, 0x90, 0x7f, 0xd4, 0xf0,
@@ -133,14 +137,14 @@
  {0x06c6, 64, { 0xfe, 0x90, 0x7f, 0xee, 0xe0, 0x7c, 0x00, 0x24, 0x00, 0xf5, 0x19, 0xec, 0x3e, 0xf5, 0x18, 0x75, 0x33,
   0x19, 0x75, 0x34, 0x12, 0x75, 0x82, 0x14, 0x75, 0x83, 0x19, 0xe0, 0x75, 0x27, 0x00, 0xf5, 0x28,
   0xd3, 0xe5, 0x28, 0x95, 0x19, 0xe5, 0x27, 0x95, 0x18, 0x40, 0x06, 0x85, 0x18, 0x27, 0x85, 0x19,
-  0x28, 0x12, 0x13, 0x17, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x14, 0x30}},
+  0x28, 0x12, 0x13, 0x12, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0xea, 0xe0, 0xff, 0x12, 0x14, 0x2b}},
  {0x0706, 64, { 0xea, 0x49, 0x60, 0x32, 0x90, 0x7f, 0xee, 0xe0, 0x75, 0x18, 0x00, 0xf5, 0x19, 0xae, 0x02, 0xaf, 0x01,
   0x8e, 0x33, 0x8f, 0x34, 0x8f, 0x82, 0x8e, 0x83, 0xe0, 0xfe, 0xa3, 0xe0, 0x8e, 0x27, 0xf5, 0x28,
   0xd3, 0x95, 0x19, 0xe5, 0x27, 0x95, 0x18, 0x40, 0x06, 0x85, 0x18, 0x27, 0x85, 0x19, 0x28, 0x12,
-  0x13, 0x17, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x08, 0xb9}},
+  0x13, 0x12, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x08, 0xb9}},
  {0x0746, 64, { 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0x00, 0xe5, 0x25, 0xf0, 0x90,
   0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x25, 0x02, 0x08,
-  0xb9, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x22, 0x12, 0x0a, 0xbd, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0x00,
+  0xb9, 0x90, 0x7f, 0xea, 0xe0, 0xf5, 0x22, 0x12, 0x0a, 0xb8, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0x00,
   0xe5, 0x22, 0xf0, 0x90, 0x7f, 0xb5, 0x74, 0x01, 0xf0, 0x02, 0x08, 0xb9, 0x90, 0x7f, 0xe8}},
  {0x0786, 64, { 0xe0, 0x24, 0x7f, 0x60, 0x24, 0x14, 0x60, 0x31, 0x24, 0x02, 0x70, 0x5b, 0xa2, 0x00, 0xe4, 0x33, 0xff,
   0x25, 0xe0, 0xff, 0xa2, 0x06, 0xe4, 0x33, 0x4f, 0x90, 0x7f, 0x00, 0xf0, 0xe4, 0xa3, 0xf0, 0x90,
@@ -162,266 +166,266 @@
   0x07, 0x2f, 0x25, 0xe0, 0x24, 0xb4, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0x74, 0x01, 0xf0,
   0x80, 0x10, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x07, 0x90, 0x7f, 0xb4, 0xe0, 0x44,
   0x01, 0xf0, 0x90, 0x7f, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x22, 0xe5, 0x11, 0x54, 0x0f, 0x70}},
- {0x08c6, 64, { 0x03, 0x02, 0x09, 0xb2, 0x12, 0x16, 0xaa, 0xef, 0x20, 0xe1, 0x75, 0x12, 0x17, 0x08, 0xef, 0x14, 0xf5,
-  0x19, 0x12, 0x18, 0xd8, 0xef, 0x25, 0x19, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x80, 0xee,
+ {0x08c6, 64, { 0x03, 0x02, 0x09, 0xb2, 0x12, 0x16, 0xa5, 0xef, 0x20, 0xe1, 0x75, 0x12, 0x17, 0x03, 0xef, 0x14, 0xf5,
+  0x19, 0x12, 0x18, 0xcc, 0xef, 0x25, 0x19, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x80, 0xee,
   0x64, 0x80, 0x94, 0x80, 0x50, 0x59, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xe0, 0xfe, 0xa3, 0xe0,
   0xff, 0xf5, 0x82, 0x8e, 0x83, 0xe0, 0x30, 0xe0, 0x11, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82}},
  {0x0906, 64, { 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x80, 0xf0, 0x80, 0x0f, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82,
   0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0xf0, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4,
   0x35, 0x14, 0xf5, 0x83, 0xe0, 0x20, 0xe2, 0x12, 0xe5, 0x19, 0x60, 0x0e, 0xf5, 0x23, 0xef, 0x24,
-  0x01, 0xf5, 0x2d, 0xe4, 0x3e, 0xf5, 0x2c, 0x12, 0x14, 0xb2, 0xe4, 0xff, 0x12, 0x14, 0xe8}},
+  0x01, 0xf5, 0x2d, 0xe4, 0x3e, 0xf5, 0x2c, 0x12, 0x14, 0xad, 0xe4, 0xff, 0x12, 0x14, 0xe3}},
  {0x0946, 64, { 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x30, 0xe7, 0x5d, 0x12, 0x18,
-  0xd8, 0xe5, 0x15, 0x24, 0x3b, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xfe, 0xef, 0xc3,
+  0xcc, 0xe5, 0x15, 0x24, 0x3b, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xfe, 0xef, 0xc3,
   0x9e, 0x50, 0x48, 0xe5, 0x15, 0x24, 0x2f, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x01,
   0xf0, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7b}},
  {0x0986, 64, { 0xf0, 0xe5, 0x15, 0x24, 0x3a, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0, 0xe5, 0x16, 0x42,
   0x13, 0x90, 0x7f, 0xc2, 0xe0, 0x30, 0xe1, 0x10, 0xe5, 0x15, 0x24, 0x26, 0xf5, 0x82, 0xe4, 0x35,
-  0x14, 0xf5, 0x83, 0xe0, 0xf5, 0x24, 0x80, 0x03, 0x12, 0x12, 0xa6, 0x12, 0x16, 0xd9, 0xef, 0x30,
-  0xe1, 0x03, 0x02, 0x0a, 0xbc, 0xe5, 0x15, 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5}},
- {0x09c6, 64, { 0x83, 0xe0, 0x54, 0x80, 0xf0, 0xe5, 0x15, 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xc0,
-  0x83, 0xc0, 0x82, 0xe0, 0xfe, 0x12, 0x18, 0xe4, 0xee, 0x4f, 0xd0, 0x82, 0xd0, 0x83, 0xf0, 0x12,
-  0x17, 0xde, 0x8f, 0x19, 0xe5, 0x15, 0x24, 0x35, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0,
-  0xfe, 0xef, 0xc3, 0x9e, 0x50, 0x28, 0x12, 0x18, 0xc0, 0xef, 0x30, 0xe0, 0x21, 0xe5, 0x15}},
- {0x0a06, 64, { 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x20, 0xe7, 0x12, 0xe5, 0x15, 0x24, 0x31,
-  0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x20, 0xe1, 0x03, 0x02, 0x0a, 0xbc, 0xe5, 0x15,
-  0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0xfd, 0xf0, 0xe5, 0x19, 0x70,
-  0x0e, 0xe5, 0x15, 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0, 0x22}},
- {0x0a46, 64, { 0xe5, 0x15, 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0x30, 0xe7, 0x29, 0xe5,
-  0x19, 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x23, 0x85, 0x15, 0x82, 0x85,
-  0x14, 0x83, 0xa3, 0xa3, 0xe0, 0xfc, 0xa3, 0xe0, 0x8c, 0x2c, 0xf5, 0x2d, 0x12, 0x13, 0xe2, 0xe5,
-  0x19, 0x25, 0xe0, 0xff, 0x12, 0x15, 0x1e, 0x22, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03}},
- {0x0a86, 64, { 0x75, 0x19, 0x3f, 0x85, 0x19, 0x23, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0xe0, 0xfe, 0xa3,
-  0xe0, 0xf5, 0x82, 0x8e, 0x83, 0xe4, 0xf0, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0xe0,
-  0xfe, 0xa3, 0xe0, 0x24, 0x01, 0xf5, 0x2d, 0xe4, 0x3e, 0xf5, 0x2c, 0x12, 0x14, 0x71, 0xe5, 0x19,
-  0x04, 0xff, 0x12, 0x15, 0x1e, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74}},
- {0x0ac6, 64, { 0xf0, 0xf0, 0x90, 0x7f, 0x96, 0xf0, 0xe4, 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x78, 0x4a, 0x04, 0xf0, 0xf5,
-  0x8e, 0x90, 0x7f, 0x95, 0x74, 0xc0, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98,
-  0x74, 0x1f, 0xf0, 0x90, 0x78, 0x43, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x78, 0x41, 0xf0, 0x90, 0x7f,
-  0xdf, 0x74, 0x9f, 0xf0, 0x90, 0x7f, 0xde, 0xf0, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02, 0xf0}},
- {0x0b06, 64, { 0x7e, 0x7b, 0x7f, 0xc0, 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0, 0x75,
-  0x16, 0x01, 0x12, 0x0f, 0x17, 0x7e, 0x7b, 0x7f, 0xc0, 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90,
-  0x7f, 0x96, 0x74, 0xef, 0xf0, 0x75, 0x16, 0x01, 0xe5, 0x15, 0x24, 0x26, 0xf5, 0x82, 0xe4, 0x35,
-  0x14, 0xf5, 0x83, 0xe4, 0xf0, 0x7e, 0x7e, 0x7f, 0x40, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83}},
- {0x0b46, 64, { 0x74, 0x7e, 0xf0, 0xa3, 0x74, 0x40, 0xf0, 0x7e, 0x7e, 0x7f, 0x80, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83,
-  0xa3, 0xa3, 0x74, 0x7e, 0xf0, 0xa3, 0x74, 0x80, 0xf0, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c,
-  0x75, 0x15, 0x00, 0x90, 0x7f, 0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0x12, 0x0f, 0x17, 0x7e,
-  0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x00, 0x90, 0x7f, 0x96, 0x74, 0xdf, 0xf0}},
- {0x0b86, 64, { 0x75, 0x16, 0x02, 0xe5, 0x15, 0x24, 0x26, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x01, 0xf0,
-  0x7e, 0x7d, 0x7f, 0xc0, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0x74, 0x7d, 0xf0, 0xa3, 0x74, 0xc0,
-  0xf0, 0x7e, 0x7e, 0x7f, 0x00, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0x74, 0x7e, 0xf0,
-  0xa3, 0x74, 0x00, 0xf0, 0x7e, 0x7c, 0x7f, 0x40, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x40, 0x90}},
- {0x0bc6, 64, { 0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75, 0x16, 0x04, 0x12, 0x0f, 0x17, 0x7e, 0x7c, 0x7f, 0x40, 0x75, 0x14,
-  0x7c, 0x75, 0x15, 0x40, 0x90, 0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75, 0x16, 0x04, 0xe5, 0x15, 0x24,
-  0x26, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x02, 0xf0, 0x7e, 0x7d, 0x7f, 0x40, 0x85,
-  0x15, 0x82, 0x85, 0x14, 0x83, 0x74, 0x7d, 0xf0, 0xa3, 0x74, 0x40, 0xf0, 0x7e, 0x7d, 0x7f}},
- {0x0c06, 64, { 0x80, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0x74, 0x7d, 0xf0, 0xa3, 0x74, 0x80, 0xf0, 0x7e,
-  0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x80, 0x90, 0x7f, 0x96, 0x74, 0x7f, 0xf0, 0x75,
-  0x16, 0x08, 0x12, 0x0f, 0x17, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x80, 0x90,
-  0x7f, 0x96, 0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0xe5, 0x15, 0x24, 0x26, 0xf5, 0x82, 0xe4}},
- {0x0c46, 64, { 0x35, 0x14, 0xf5, 0x83, 0x74, 0x03, 0xf0, 0x7e, 0x7c, 0x7f, 0xc0, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83,
-  0x74, 0x7c, 0xf0, 0xa3, 0x74, 0xc0, 0xf0, 0x7e, 0x7d, 0x7f, 0x00, 0x85, 0x15, 0x82, 0x85, 0x14,
-  0x83, 0xa3, 0xa3, 0x74, 0x7d, 0xf0, 0xa3, 0x74, 0x00, 0xf0, 0xc2, 0x0a, 0xc2, 0x09, 0xd2, 0x02,
-  0x22, 0xe5, 0x10, 0x04, 0x54, 0x03, 0xf5, 0x10, 0x14, 0x60, 0x1f, 0x14, 0x60, 0x31, 0x14}},
- {0x0c86, 64, { 0x60, 0x43, 0x24, 0x03, 0x70, 0x52, 0x7e, 0x7b, 0x7f, 0xc0, 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90,
-  0x7f, 0x96, 0x74, 0xef, 0xf0, 0x75, 0x16, 0x01, 0x80, 0x3d, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14,
-  0x7c, 0x75, 0x15, 0x00, 0x90, 0x7f, 0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0x80, 0x28, 0x7e,
+  0x14, 0xf5, 0x83, 0xe0, 0xf5, 0x24, 0x80, 0x03, 0x12, 0x12, 0xa1, 0x12, 0x16, 0xd4, 0xef, 0x30,
+  0xe1, 0x03, 0x02, 0x0a, 0xb7, 0x12, 0x17, 0xd2, 0x8f, 0x19, 0x12, 0x18, 0xd8, 0xe5, 0x15}},
+ {0x09c6, 64, { 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xef, 0xf0, 0xe5, 0x15, 0x24, 0x35, 0xf5, 0x82,
+  0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x19, 0xc3, 0x9f, 0x50, 0x28, 0x12, 0x18, 0xb4,
+  0xef, 0x30, 0xe0, 0x21, 0xe5, 0x15, 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0,
+  0x20, 0xe7, 0x12, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0}},
+ {0x0a06, 64, { 0x20, 0xe1, 0x03, 0x02, 0x0a, 0xb7, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83,
+  0xe0, 0x54, 0xfd, 0xf0, 0xe5, 0x19, 0x70, 0x03, 0x02, 0x0a, 0xb7, 0xb4, 0x80, 0x0f, 0xe5, 0x15,
+  0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x02, 0xf0, 0xe5, 0x15, 0x24,
+  0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0x30, 0xe7, 0x29, 0xe5, 0x19}},
+ {0x0a46, 64, { 0xd3, 0x94, 0x20, 0x40, 0x03, 0x75, 0x19, 0x20, 0x85, 0x19, 0x23, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83,
+  0xa3, 0xa3, 0xe0, 0xfc, 0xa3, 0xe0, 0x8c, 0x2c, 0xf5, 0x2d, 0x12, 0x13, 0xdd, 0xe5, 0x19, 0x25,
+  0xe0, 0xff, 0x12, 0x15, 0x19, 0x22, 0xe5, 0x19, 0xd3, 0x94, 0x3f, 0x40, 0x03, 0x75, 0x19, 0x3f,
+  0x85, 0x19, 0x23, 0xe5, 0x15, 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0}},
+ {0x0a86, 64, { 0xff, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0xe0, 0xfc, 0xa3, 0xe0, 0xf5, 0x82, 0x8c, 0x83,
+  0xef, 0xf0, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0xe0, 0xfe, 0xa3, 0xe0, 0x24, 0x01,
+  0xf5, 0x2d, 0xe4, 0x3e, 0xf5, 0x2c, 0x12, 0x14, 0x6c, 0xe5, 0x19, 0x04, 0xff, 0x12, 0x15, 0x19,
+  0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0xf0, 0xf0, 0x90, 0x7f, 0x96}},
+ {0x0ac6, 64, { 0xf0, 0xe4, 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x78, 0x4a, 0x04, 0xf0, 0xf5, 0x8e, 0x90, 0x7f, 0x95, 0x74,
+  0xc0, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0x3f, 0xf0, 0x90, 0x7f, 0x98, 0x74, 0x1f, 0xf0, 0x90, 0x78,
+  0x43, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x78, 0x41, 0xf0, 0x90, 0x7f, 0xdf, 0x74, 0x9f, 0xf0, 0x90,
+  0x7f, 0xde, 0xf0, 0x90, 0x7f, 0x92, 0xe0, 0x44, 0x02, 0xf0, 0x7e, 0x7b, 0x7f, 0xc0, 0x75}},
+ {0x0b06, 64, { 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0, 0x75, 0x16, 0x01, 0x12, 0x0f, 0x12,
+  0x7e, 0x7b, 0x7f, 0xc0, 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0,
+  0x75, 0x16, 0x01, 0xe5, 0x15, 0x24, 0x26, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0,
+  0x7e, 0x7e, 0x7f, 0x40, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0x74, 0x7e, 0xf0, 0xa3, 0x74}},
+ {0x0b46, 64, { 0x40, 0xf0, 0x7e, 0x7e, 0x7f, 0x80, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0x74, 0x7e, 0xf0,
+  0xa3, 0x74, 0x80, 0xf0, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x00, 0x90, 0x7f,
+  0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0x12, 0x0f, 0x12, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14,
+  0x7c, 0x75, 0x15, 0x00, 0x90, 0x7f, 0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0xe5, 0x15}},
+ {0x0b86, 64, { 0x24, 0x26, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x7e, 0x7d, 0x7f, 0xc0, 0x85,
+  0x15, 0x82, 0x85, 0x14, 0x83, 0x74, 0x7d, 0xf0, 0xa3, 0x74, 0xc0, 0xf0, 0x7e, 0x7e, 0x7f, 0x00,
+  0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0x74, 0x7e, 0xf0, 0xa3, 0x74, 0x00, 0xf0, 0x7e,
   0x7c, 0x7f, 0x40, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x40, 0x90, 0x7f, 0x96, 0x74, 0xbf, 0xf0}},
- {0x0cc6, 64, { 0x75, 0x16, 0x04, 0x80, 0x13, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x80, 0x90, 0x7f,
-  0x96, 0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0xe5, 0x32, 0x55, 0x16, 0x70, 0x03, 0x02, 0x0e, 0x16,
-  0xe5, 0x16, 0xf4, 0xff, 0x52, 0x32, 0xe5, 0x26, 0x54, 0x7f, 0xfe, 0x70, 0x0f, 0xe5, 0x2a, 0x55,
-  0x16, 0x60, 0x24, 0x90, 0x7f, 0x98, 0xe0, 0x45, 0x16, 0xf0, 0x80, 0x1b, 0xbe, 0x20, 0x18}},
- {0x0d06, 64, { 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x30, 0xe3, 0x09, 0xe4, 0xf5,
-  0x2a, 0x90, 0x7f, 0x98, 0xe0, 0x5f, 0xf0, 0xe5, 0x15, 0x24, 0x3a, 0xf5, 0x82, 0xe4, 0x35, 0x14,
-  0xf5, 0x83, 0xe0, 0x60, 0x03, 0xe0, 0x14, 0xf0, 0xe5, 0x15, 0x24, 0x34, 0xf5, 0x82, 0xe4, 0x35,
-  0x14, 0xf5, 0x83, 0xe0, 0x60, 0x03, 0xe0, 0x14, 0xf0, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0x16}},
- {0x0d46, 64, { 0x74, 0x0a, 0xf0, 0x12, 0x00, 0x36, 0xef, 0x54, 0x01, 0xff, 0xf5, 0x19, 0xe5, 0x15, 0x24, 0x2c, 0xf5,
-  0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x6f, 0x60, 0x07, 0xe5, 0x19, 0xf0, 0xe5, 0x16, 0x42,
-  0x13, 0x12, 0x18, 0xf0, 0x8f, 0x19, 0xe5, 0x15, 0x24, 0x27, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5,
-  0x83, 0xe0, 0xff, 0xe5, 0x19, 0x54, 0x10, 0xfe, 0x6f, 0x60, 0x06, 0xee, 0xf0, 0xe5, 0x16}},
- {0x0d86, 64, { 0x42, 0x13, 0xe5, 0x15, 0x24, 0x28, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x19,
-  0x54, 0x80, 0xfe, 0x6f, 0x60, 0x06, 0xee, 0xf0, 0xe5, 0x16, 0x42, 0x13, 0xe5, 0x15, 0x24, 0x29,
-  0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x19, 0x54, 0x20, 0xfe, 0x6f, 0x60,
-  0x15, 0xee, 0xf0, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0}},
- {0x0dc6, 64, { 0x30, 0xe4, 0x04, 0xe5, 0x16, 0x42, 0x13, 0xe5, 0x12, 0x55, 0x16, 0xff, 0xf5, 0x19, 0xe5, 0x15, 0x24,
-  0x2a, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x6f, 0x60, 0x16, 0xe5, 0x19, 0xf0, 0xe5,
-  0x15, 0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x30, 0xe5, 0x04, 0xe5, 0x16,
-  0x42, 0x13, 0xe5, 0x17, 0x55, 0x16, 0xff, 0xf5, 0x19, 0xe5, 0x15, 0x24, 0x30, 0xf5, 0x82}},
- {0x0e06, 64, { 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x6f, 0x60, 0x07, 0xe5, 0x19, 0xf0, 0xe5, 0x16, 0x42, 0x13, 0x22,
-  0x30, 0x09, 0x03, 0x02, 0x0f, 0x16, 0xe5, 0x24, 0x14, 0x60, 0x2a, 0x14, 0x60, 0x41, 0x14, 0x60,
-  0x58, 0x14, 0x60, 0x6f, 0x24, 0x04, 0x60, 0x03, 0x02, 0x0e, 0xd4, 0x7e, 0x7b, 0x7f, 0xc0, 0x75,
-  0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0, 0x75, 0x16, 0x01, 0x12}},
- {0x0e46, 64, { 0x12, 0xa6, 0x75, 0x24, 0x01, 0x22, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x00, 0x90,
-  0x7f, 0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0x12, 0x12, 0xa6, 0x75, 0x24, 0x02, 0x22, 0x7e,
-  0x7c, 0x7f, 0x40, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x40, 0x90, 0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75,
-  0x16, 0x04, 0x12, 0x12, 0xa6, 0x75, 0x24, 0x03, 0x22, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14}},
- {0x0e86, 64, { 0x7c, 0x75, 0x15, 0x80, 0x90, 0x7f, 0x96, 0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0x12, 0x12, 0xa6, 0x75,
-  0x24, 0x04, 0x22, 0x30, 0x04, 0x33, 0xc2, 0x04, 0x53, 0x13, 0xdf, 0xe4, 0xf5, 0x19, 0x7e, 0x00,
-  0x7b, 0x00, 0x74, 0x2e, 0x25, 0x19, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x11, 0xb0, 0xff, 0x74,
-  0x80, 0x25, 0x19, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x19, 0xe5}},
- {0x0ec6, 64, { 0x19, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0x75, 0x24, 0x05, 0x22, 0xe5, 0x36, 0x60,
-  0x3b, 0xd5, 0x36, 0x0a, 0x53, 0x13, 0xef, 0x30, 0x0a, 0x04, 0xd2, 0x09, 0xc2, 0x0a, 0xe4, 0xf5,
-  0x19, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x35, 0x25, 0x19, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x11,
-  0xb0, 0xff, 0x74, 0x80, 0x25, 0x19, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0}},
- {0x0f06, 64, { 0x05, 0x19, 0xe5, 0x19, 0xb4, 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x24, 0x22,
-  0xe4, 0xf5, 0x1a, 0x7e, 0x00, 0x7b, 0x01, 0xe5, 0x15, 0x25, 0x1a, 0xf9, 0xee, 0x35, 0x14, 0xfa,
-  0xe4, 0x12, 0x11, 0xf6, 0x05, 0x1a, 0xe5, 0x1a, 0xb4, 0x3c, 0xe8, 0xe5, 0x15, 0x24, 0x35, 0xf5,
-  0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x01, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0}},
- {0x0f46, 64, { 0xe5, 0x15, 0x24, 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00,
-  0xf0, 0x7f, 0x0c, 0xe4, 0xfd, 0x12, 0x16, 0x4c, 0x7f, 0x10, 0xe5, 0x15, 0x24, 0x33, 0xf5, 0x82,
-  0xe4, 0x35, 0x14, 0xf5, 0x83, 0xef, 0xf0, 0x12, 0x15, 0xbc, 0x90, 0x78, 0x41, 0x74, 0x02, 0xf0,
-  0x7f, 0x01, 0xe5, 0x15, 0x24, 0x36, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xef, 0xf0}},
- {0x0f86, 64, { 0x44, 0x06, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x04, 0xf0, 0xe5, 0x15, 0x24, 0x39, 0xf5,
-  0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x80, 0xf0, 0x90, 0xc0, 0x00, 0xf0, 0x0f, 0xe4, 0xfd,
-  0x12, 0x16, 0x4c, 0xe4, 0xff, 0x7e, 0xa3, 0xe5, 0x15, 0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35, 0x14,
-  0xf5, 0x83, 0xee, 0xf0, 0xfd, 0x12, 0x16, 0x4c, 0x90, 0x78, 0x41, 0x74, 0x01, 0xf0, 0x90}},
- {0x0fc6, 64, { 0xc0, 0x00, 0xe4, 0xf0, 0x7f, 0x05, 0x7d, 0x7f, 0x12, 0x16, 0x4c, 0x7f, 0x01, 0x12, 0x15, 0x54, 0x7f,
-  0x03, 0x7d, 0x07, 0x12, 0x16, 0x4c, 0x22, 0x53, 0x13, 0x3f, 0x90, 0x7b, 0xf1, 0xe0, 0x30, 0xe3,
-  0x16, 0x7e, 0x7b, 0x7f, 0xc0, 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef,
-  0xf0, 0x75, 0x16, 0x01, 0x12, 0x08, 0xc1, 0x90, 0x7c, 0x31, 0xe0, 0x30, 0xe3, 0x16, 0x7e}},
- {0x1006, 64, { 0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x00, 0x90, 0x7f, 0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16,
-  0x02, 0x12, 0x08, 0xc1, 0x90, 0x7c, 0x71, 0xe0, 0x30, 0xe3, 0x16, 0x7e, 0x7c, 0x7f, 0x40, 0x75,
-  0x14, 0x7c, 0x75, 0x15, 0x40, 0x90, 0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75, 0x16, 0x04, 0x12, 0x08,
-  0xc1, 0x90, 0x7c, 0xb1, 0xe0, 0x30, 0xe3, 0x16, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c}},
- {0x1046, 64, { 0x75, 0x15, 0x80, 0x90, 0x7f, 0x96, 0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0x12, 0x08, 0xc1, 0x05, 0x11,
-  0xe5, 0x11, 0x54, 0x0f, 0xf5, 0x18, 0x70, 0x1f, 0x90, 0x78, 0x41, 0xe0, 0x54, 0xf7, 0xf0, 0x90,
-  0x7f, 0x99, 0xe0, 0xf5, 0x17, 0x90, 0x78, 0x41, 0xe0, 0x44, 0x08, 0xf0, 0x90, 0x7f, 0x99, 0xe0,
-  0xf4, 0xf5, 0x12, 0x12, 0x11, 0x26, 0x22, 0xe5, 0x18, 0xb4, 0x01, 0x04, 0x12, 0x0c, 0x78}},
- {0x1086, 64, { 0x22, 0x90, 0x7f, 0xc2, 0xe0, 0x20, 0xe1, 0x08, 0xe5, 0x13, 0x60, 0x04, 0x12, 0x0e, 0x17, 0x22, 0x12,
-  0x0c, 0x78, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x37, 0x02, 0x10, 0xe1, 0x02,
-  0x12, 0x2e, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08,
-  0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33}},
- {0x10c6, 64, { 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4,
-  0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x5c, 0xe4, 0x7e, 0x01,
-  0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3,
-  0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3}},
- {0x1106, 64, { 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0,
-  0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0x90,
-  0x7f, 0xd2, 0xe0, 0x30, 0xe1, 0x03, 0x02, 0x11, 0xaf, 0xc2, 0x09, 0x90, 0x7b, 0x40, 0xe0, 0x14,
-  0x60, 0x26, 0x14, 0x60, 0x3b, 0x14, 0x60, 0x50, 0x24, 0x83, 0x60, 0x64, 0x24, 0x80, 0x70}},
- {0x1146, 64, { 0x63, 0x7e, 0x7b, 0x7f, 0xc0, 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0,
-  0x75, 0x16, 0x01, 0x12, 0x00, 0x46, 0x80, 0x4b, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c, 0x75,
-  0x15, 0x00, 0x90, 0x7f, 0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0x12, 0x00, 0x46, 0x80, 0x33,
-  0x7e, 0x7c, 0x7f, 0x40, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x40, 0x90, 0x7f, 0x96, 0x74, 0xbf}},
- {0x1186, 64, { 0xf0, 0x75, 0x16, 0x04, 0x12, 0x00, 0x46, 0x80, 0x1b, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75,
-  0x15, 0x80, 0x90, 0x7f, 0x96, 0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0x12, 0x00, 0x46, 0x80, 0x03,
-  0x12, 0x17, 0x8f, 0xe4, 0x90, 0x7f, 0xd3, 0xf0, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83,
-  0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83}},
- {0x11c6, 64, { 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0,
-  0x22, 0x50, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8,
-  0xe2, 0x22, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb,
-  0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01}},
- {0x1206, 64, { 0xf3, 0x22, 0xd0, 0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3,
-  0xa3, 0x93, 0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68,
-  0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80, 0xdf, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x00, 0xe4,
-  0x33, 0xfe, 0xef, 0x4e, 0xf0, 0xd2, 0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01}},
- {0x1246, 64, { 0xf0, 0x90, 0x7f, 0xdf, 0xf0, 0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f,
-  0xaa, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xaf, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0x74, 0x0d,
-  0xf0, 0xd2, 0xaf, 0xd2, 0x0b, 0x12, 0x18, 0x20, 0xc2, 0x01, 0xe4, 0xf5, 0x2b, 0xf5, 0x31, 0xc2,
-  0x07, 0xc2, 0x02, 0x75, 0x29, 0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x26, 0x60, 0x06, 0x75}},
- {0x1286, 64, { 0x32, 0x0f, 0xe0, 0xf5, 0x26, 0x30, 0x02, 0x03, 0x12, 0x0f, 0xde, 0x30, 0x01, 0x07, 0xc2, 0x01, 0x12,
-  0x06, 0x29, 0x80, 0xe2, 0x30, 0x08, 0xdf, 0xc2, 0x08, 0x12, 0x18, 0x41, 0x80, 0xd8, 0x22, 0xe5,
-  0x13, 0x55, 0x16, 0x60, 0x6a, 0xe5, 0x15, 0x24, 0x3a, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83,
-  0xe0, 0x70, 0x5c, 0xe5, 0x16, 0xf4, 0x52, 0x13, 0xe5, 0x15, 0x24, 0x26, 0xff, 0xe4, 0x35}},
- {0x12c6, 64, { 0x14, 0xfe, 0xe4, 0xfd, 0x0f, 0xef, 0xaa, 0x06, 0x70, 0x01, 0x0e, 0x14, 0xf5, 0x82, 0x8a, 0x83, 0xe0,
-  0xfc, 0x74, 0x80, 0x2d, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xec, 0xf0, 0x0d, 0xbd, 0x0b,
-  0xe2, 0x90, 0x7f, 0xc3, 0x74, 0x0b, 0xf0, 0xe5, 0x15, 0x24, 0x3a, 0xf5, 0x82, 0xe4, 0x35, 0x14,
-  0xf5, 0x83, 0x74, 0x10, 0xf0, 0xe5, 0x15, 0x24, 0x2e, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5}},
- {0x1306, 64, { 0x83, 0xe4, 0xf0, 0xe5, 0x15, 0x24, 0x2f, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0, 0x22,
-  0xe5, 0x28, 0x45, 0x27, 0x60, 0x57, 0xae, 0x27, 0xaf, 0x28, 0xd3, 0xef, 0x94, 0x40, 0xee, 0x94,
-  0x00, 0x40, 0x04, 0x7e, 0x00, 0x7f, 0x40, 0xc3, 0xe5, 0x28, 0x9f, 0xf5, 0x28, 0xe5, 0x27, 0x9e,
-  0xf5, 0x27, 0xe4, 0xfd, 0xed, 0xc3, 0x9f, 0xe4, 0x9e, 0x50, 0x1f, 0x85, 0x34, 0x82, 0x85}},
- {0x1346, 64, { 0x33, 0x83, 0xe0, 0xfc, 0x74, 0x00, 0x2d, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xec, 0xf0, 0x0d,
-  0x05, 0x34, 0xe5, 0x34, 0x70, 0x02, 0x05, 0x33, 0x80, 0xda, 0x90, 0x7f, 0xa9, 0x74, 0x01, 0xf0,
-  0x90, 0x7f, 0xac, 0xe0, 0x44, 0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xef, 0xf0, 0x22, 0x90, 0x7f, 0xac,
-  0xe0, 0x54, 0xfe, 0xf0, 0xe4, 0x90, 0x7f, 0xb5, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0}},
- {0x1386, 64, { 0x90, 0x7f, 0x9c, 0x74, 0xf0, 0xf0, 0x90, 0x7f, 0x96, 0xf0, 0xe4, 0x90, 0x78, 0x4a, 0xf0, 0x90, 0x7f,
-  0x94, 0xf0, 0x90, 0x7f, 0x9d, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x30, 0x00, 0x07,
-  0xe5, 0x29, 0x54, 0xf0, 0xff, 0x80, 0x02, 0x7f, 0x00, 0xef, 0x44, 0x08, 0x90, 0x78, 0x41, 0xf0,
-  0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0xff, 0xf0}},
- {0x13c6, 64, { 0xe4, 0x90, 0x7f, 0x98, 0xf0, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0xf0, 0xf0, 0xe4, 0x90,
-  0x7f, 0x96, 0xf0, 0x90, 0x7f, 0x92, 0xe0, 0x54, 0xfd, 0xf0, 0x22, 0x8f, 0x1a, 0x05, 0x2d, 0xe5,
-  0x2d, 0xae, 0x2c, 0x70, 0x02, 0x05, 0x2c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12,
-  0x1a, 0x08, 0x05, 0x2d, 0xe5, 0x2d, 0xac, 0x2c, 0x70, 0x02, 0x05, 0x2c, 0x14, 0xf5, 0x82}},
- {0x1406, 64, { 0x8c, 0x83, 0xef, 0xf0, 0x15, 0x23, 0xe5, 0x23, 0x60, 0x1f, 0xe5, 0x15, 0x24, 0x38, 0xf5, 0x82, 0xe4,
-  0x35, 0x14, 0xf5, 0x83, 0xc0, 0x83, 0xc0, 0x82, 0xe0, 0xfe, 0x12, 0x18, 0xe4, 0x8f, 0x1a, 0xee,
-  0x4f, 0xd0, 0x82, 0xd0, 0x83, 0xf0, 0x80, 0xb5, 0x22, 0x8f, 0x1a, 0xe4, 0xf5, 0x1b, 0x75, 0x1c,
-  0xff, 0x75, 0x1d, 0x19, 0x75, 0x1e, 0x86, 0xab, 0x1c, 0xaa, 0x1d, 0xa9, 0x1e, 0x90, 0x00}},
- {0x1446, 64, { 0x01, 0x12, 0x11, 0xc9, 0xb4, 0x03, 0x1d, 0xaf, 0x1b, 0x05, 0x1b, 0xef, 0xb5, 0x1a, 0x01, 0x22, 0x12,
-  0x11, 0xb0, 0x7e, 0x00, 0x29, 0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x1c, 0xff, 0xf5, 0x1d, 0x89,
-  0x1e, 0x80, 0xd4, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x00, 0x22, 0xe4, 0x90, 0x78, 0x41, 0xf0, 0x90,
-  0x78, 0x4f, 0x74, 0xc0, 0xf0, 0xe4, 0x90, 0x78, 0x50, 0xf0, 0xe5, 0x2c, 0x90, 0x78, 0x51}},
- {0x1486, 64, { 0xf0, 0xae, 0x2c, 0xe5, 0x2d, 0x90, 0x78, 0x52, 0xf0, 0x90, 0x78, 0x54, 0xe5, 0x23, 0xf0, 0x90, 0x78,
-  0x57, 0x74, 0x04, 0xf0, 0x90, 0x7f, 0xe2, 0xe0, 0x44, 0x10, 0xf0, 0xe0, 0x54, 0xf7, 0xf0, 0xe4,
-  0x90, 0x78, 0x55, 0xf0, 0x90, 0x78, 0x55, 0xe0, 0x60, 0xfa, 0x22, 0xe4, 0x90, 0x78, 0x41, 0xf0,
-  0xe5, 0x2c, 0x90, 0x78, 0x4f, 0xf0, 0xae, 0x2c, 0xe5, 0x2d, 0x90, 0x78, 0x50, 0xf0, 0x90}},
- {0x14c6, 64, { 0x78, 0x51, 0x74, 0xc0, 0xf0, 0xe4, 0x90, 0x78, 0x52, 0xf0, 0x90, 0x78, 0x54, 0xe5, 0x23, 0xf0, 0x90,
-  0x78, 0x57, 0x74, 0x04, 0xf0, 0xe4, 0x90, 0x78, 0x55, 0xf0, 0x90, 0x78, 0x55, 0xe0, 0x60, 0xfa,
-  0x22, 0xe5, 0x15, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14, 0x60, 0x0f,
-  0x14, 0x60, 0x13, 0x14, 0x60, 0x17, 0x80, 0x00, 0x90, 0x7f, 0xc7, 0xef, 0xf0, 0x80, 0x13}},
- {0x1506, 64, { 0x90, 0x7f, 0xc9, 0xef, 0xf0, 0x80, 0x0c, 0x90, 0x7f, 0xcb, 0xef, 0xf0, 0x80, 0x05, 0x90, 0x7f, 0xcd,
-  0xef, 0xf0, 0xe5, 0x16, 0x42, 0x2a, 0x22, 0xe5, 0x15, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14,
-  0xf5, 0x83, 0xe0, 0x14, 0x60, 0x0f, 0x14, 0x60, 0x13, 0x14, 0x60, 0x17, 0x80, 0x00, 0x90, 0x7f,
-  0xb7, 0xef, 0xf0, 0x80, 0x13, 0x90, 0x7f, 0xb9, 0xef, 0xf0, 0x80, 0x0c, 0x90, 0x7f, 0xbb}},
- {0x1546, 64, { 0xef, 0xf0, 0x80, 0x05, 0x90, 0x7f, 0xbd, 0xef, 0xf0, 0xe5, 0x16, 0x42, 0x2a, 0x22, 0xae, 0x07, 0xe4,
-  0xff, 0xe5, 0x15, 0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0xfd,
-  0x12, 0x16, 0x4c, 0x90, 0x78, 0x41, 0x74, 0x01, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5,
-  0x15, 0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x80, 0xfd, 0x12}},
- {0x1586, 64, { 0x16, 0x4c, 0x22, 0xc0, 0xe0, 0xc0, 0xf0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86,
-  0x75, 0x86, 0x00, 0xc0, 0xd0, 0x75, 0xd0, 0x08, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xa9, 0x74, 0x01,
-  0xf0, 0x12, 0x13, 0x17, 0xd0, 0xd0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83,
-  0xd0, 0xf0, 0xd0, 0xe0, 0x32, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74}},
- {0x15c6, 64, { 0xbf, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x02, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74,
-  0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f,
-  0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf,
-  0xf0, 0x90, 0x78, 0x41, 0x74, 0x04, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41}},
- {0x1606, 64, { 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f,
-  0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf,
-  0xf0, 0x90, 0x78, 0x41, 0x74, 0x06, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74,
-  0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54}},
- {0x1646, 64, { 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5,
-  0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x78, 0x41,
-  0x74, 0x07, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x05, 0xf0, 0x90, 0xc0,
-  0x00, 0xed, 0xf0, 0x22, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf}},
- {0x1686, 64, { 0xf0, 0xe4, 0x90, 0x78, 0x41, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0,
-  0xe5, 0x15, 0x24, 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0,
-  0x00, 0xf0, 0x22, 0xe5, 0x15, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14,
-  0x60, 0x0e, 0x14, 0x60, 0x11, 0x14, 0x60, 0x14, 0x80, 0x00, 0x90, 0x7f, 0xc6, 0xe0, 0xff}},
- {0x16c6, 64, { 0x22, 0x90, 0x7f, 0xc8, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xca, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xcc, 0xe0,
-  0xff, 0x22, 0xe5, 0x15, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14, 0x60,
-  0x0e, 0x14, 0x60, 0x11, 0x14, 0x60, 0x14, 0x80, 0x00, 0x90, 0x7f, 0xb6, 0xe0, 0xff, 0x22, 0x90,
-  0x7f, 0xb8, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xba, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xbc, 0xe0}},
- {0x1706, 64, { 0xff, 0x22, 0xe5, 0x15, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14, 0x60, 0x0e,
-  0x14, 0x60, 0x11, 0x14, 0x60, 0x14, 0x80, 0x00, 0x90, 0x7f, 0xc7, 0xe0, 0xff, 0x22, 0x90, 0x7f,
-  0xc9, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xcb, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xcd, 0xe0, 0xff, 0x22,
-  0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00}},
- {0x1746, 64, { 0x30, 0x05, 0x04, 0xc2, 0x05, 0x80, 0x02, 0xd2, 0x08, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08,
-  0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0,
-  0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4,
-  0xe4, 0xf0, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84}},
- {0x1786, 64, { 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7b, 0x41, 0xe0, 0xf5, 0x36, 0x43, 0x13,
-  0x10, 0xa3, 0xe0, 0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0x90, 0x7b,
-  0x43, 0xe0, 0xf5, 0x37, 0xa3, 0xe0, 0x54, 0xf0, 0xf5, 0x29, 0xe0, 0x60, 0x02, 0xd2, 0x0a, 0x22,
-  0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00}},
- {0x17c6, 64, { 0xd2, 0x01, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85,
-  0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x12, 0x18, 0xcc, 0xae, 0x07, 0x12, 0x18, 0xcc, 0xad,
-  0x07, 0xee, 0x6d, 0x60, 0x10, 0x12, 0x18, 0xcc, 0xae, 0x07, 0xee, 0x6d, 0x60, 0x07, 0x12, 0x18,
-  0xcc, 0xad, 0x07, 0x80, 0xec, 0xaf, 0x06, 0x22, 0x74, 0x00, 0xf5, 0x86, 0x90, 0xfd, 0xa5}},
- {0x1806, 64, { 0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x80, 0xf0,
-  0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x04, 0xf0,
-  0xe0, 0x44, 0x08, 0xf0, 0x30, 0x0b, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f, 0xf4, 0x7e, 0x01, 0x12,
-  0x18, 0x77, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0x22, 0x12, 0x13, 0x81, 0x12, 0x18}},
- {0x1846, 64, { 0x10, 0x90, 0x7f, 0xd6, 0xe0, 0x30, 0xe7, 0x0a, 0x7f, 0x05, 0x7e, 0x00, 0x12, 0x18, 0x77, 0x12, 0x18,
-  0xaa, 0x12, 0x0a, 0xbd, 0x22, 0x03, 0x35, 0x80, 0x00, 0x00, 0x03, 0x2e, 0x81, 0x00, 0x00, 0xc1,
-  0x85, 0xc1, 0x81, 0xc1, 0x08, 0xc1, 0x00, 0xc1, 0x06, 0x01, 0x22, 0x00, 0x01, 0x24, 0x00, 0x00,
-  0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19, 0xae, 0x18, 0x70, 0x02, 0x15, 0x18, 0x4e}},
- {0x1886, 64, { 0x60, 0x08, 0x12, 0x17, 0xff, 0x12, 0x17, 0xff, 0x80, 0xeb, 0x22, 0xe5, 0x15, 0x24, 0x04, 0xf5, 0x82,
-  0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x04, 0xff, 0x44, 0x10, 0x90, 0x7f, 0xd7, 0xf0, 0xef, 0x44,
-  0x30, 0xf0, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x01, 0xf0, 0x7f, 0x0d, 0x7e, 0x00, 0x12, 0x18,
-  0x77, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfe, 0xf0, 0x22, 0x90, 0x78, 0x41, 0x74, 0x02, 0xf0}},
- {0x18c6, 64, { 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff,
-  0x22, 0x90, 0x78, 0x41, 0x74, 0x04, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x78, 0x41,
-  0x74, 0x05, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x78, 0x41, 0x74, 0x06, 0xf0, 0x90,
-  0xc0, 0x00, 0xe0, 0xff, 0x22, 0x53, 0xd8, 0xef, 0x32, 0x12, 0x01, 0x00, 0x01, 0xff, 0x00}},
+ {0x0bc6, 64, { 0x75, 0x16, 0x04, 0x12, 0x0f, 0x12, 0x7e, 0x7c, 0x7f, 0x40, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x40, 0x90,
+  0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75, 0x16, 0x04, 0xe5, 0x15, 0x24, 0x26, 0xf5, 0x82, 0xe4, 0x35,
+  0x14, 0xf5, 0x83, 0x74, 0x02, 0xf0, 0x7e, 0x7d, 0x7f, 0x40, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83,
+  0x74, 0x7d, 0xf0, 0xa3, 0x74, 0x40, 0xf0, 0x7e, 0x7d, 0x7f, 0x80, 0x85, 0x15, 0x82, 0x85}},
+ {0x0c06, 64, { 0x14, 0x83, 0xa3, 0xa3, 0x74, 0x7d, 0xf0, 0xa3, 0x74, 0x80, 0xf0, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14,
+  0x7c, 0x75, 0x15, 0x80, 0x90, 0x7f, 0x96, 0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0x12, 0x0f, 0x12,
+  0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x80, 0x90, 0x7f, 0x96, 0x74, 0x7f, 0xf0,
+  0x75, 0x16, 0x08, 0xe5, 0x15, 0x24, 0x26, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74}},
+ {0x0c46, 64, { 0x03, 0xf0, 0x7e, 0x7c, 0x7f, 0xc0, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0x74, 0x7c, 0xf0, 0xa3, 0x74,
+  0xc0, 0xf0, 0x7e, 0x7d, 0x7f, 0x00, 0x85, 0x15, 0x82, 0x85, 0x14, 0x83, 0xa3, 0xa3, 0x74, 0x7d,
+  0xf0, 0xa3, 0x74, 0x00, 0xf0, 0xc2, 0x0a, 0xc2, 0x09, 0xd2, 0x02, 0x22, 0xe5, 0x10, 0x04, 0x54,
+  0x03, 0xf5, 0x10, 0x14, 0x60, 0x1f, 0x14, 0x60, 0x31, 0x14, 0x60, 0x43, 0x24, 0x03, 0x70}},
+ {0x0c86, 64, { 0x52, 0x7e, 0x7b, 0x7f, 0xc0, 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0,
+  0x75, 0x16, 0x01, 0x80, 0x3d, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x00, 0x90,
+  0x7f, 0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0x80, 0x28, 0x7e, 0x7c, 0x7f, 0x40, 0x75, 0x14,
+  0x7c, 0x75, 0x15, 0x40, 0x90, 0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75, 0x16, 0x04, 0x80, 0x13}},
+ {0x0cc6, 64, { 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x80, 0x90, 0x7f, 0x96, 0x74, 0x7f, 0xf0, 0x75,
+  0x16, 0x08, 0xe5, 0x32, 0x55, 0x16, 0x70, 0x03, 0x02, 0x0e, 0x11, 0xe5, 0x16, 0xf4, 0xff, 0x52,
+  0x32, 0xe5, 0x26, 0x54, 0x7f, 0xfe, 0x70, 0x0f, 0xe5, 0x2a, 0x55, 0x16, 0x60, 0x24, 0x90, 0x7f,
+  0x98, 0xe0, 0x45, 0x16, 0xf0, 0x80, 0x1b, 0xbe, 0x20, 0x18, 0xe5, 0x15, 0x24, 0x31, 0xf5}},
+ {0x0d06, 64, { 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x30, 0xe3, 0x09, 0xe4, 0xf5, 0x2a, 0x90, 0x7f, 0x98, 0xe0,
+  0x5f, 0xf0, 0xe5, 0x15, 0x24, 0x3a, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60, 0x03,
+  0xe0, 0x14, 0xf0, 0xe5, 0x15, 0x24, 0x34, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x60,
+  0x03, 0xe0, 0x14, 0xf0, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0x11, 0x74, 0x0a, 0xf0, 0x12, 0x00}},
+ {0x0d46, 64, { 0x36, 0xef, 0x54, 0x01, 0xff, 0xf5, 0x19, 0xe5, 0x15, 0x24, 0x2c, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5,
+  0x83, 0xe0, 0x6f, 0x60, 0x07, 0xe5, 0x19, 0xf0, 0xe5, 0x16, 0x42, 0x13, 0x12, 0x18, 0xe4, 0x8f,
+  0x19, 0xe5, 0x15, 0x24, 0x27, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x19,
+  0x54, 0x10, 0xfe, 0x6f, 0x60, 0x06, 0xee, 0xf0, 0xe5, 0x16, 0x42, 0x13, 0xe5, 0x15, 0x24}},
+ {0x0d86, 64, { 0x28, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x19, 0x54, 0x80, 0xfe, 0x6f, 0x60,
+  0x06, 0xee, 0xf0, 0xe5, 0x16, 0x42, 0x13, 0xe5, 0x15, 0x24, 0x29, 0xf5, 0x82, 0xe4, 0x35, 0x14,
+  0xf5, 0x83, 0xe0, 0xff, 0xe5, 0x19, 0x54, 0x20, 0xfe, 0x6f, 0x60, 0x15, 0xee, 0xf0, 0xe5, 0x15,
+  0x24, 0x31, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x30, 0xe4, 0x04, 0xe5, 0x16}},
+ {0x0dc6, 64, { 0x42, 0x13, 0xe5, 0x12, 0x55, 0x16, 0xff, 0xf5, 0x19, 0xe5, 0x15, 0x24, 0x2a, 0xf5, 0x82, 0xe4, 0x35,
+  0x14, 0xf5, 0x83, 0xe0, 0x6f, 0x60, 0x16, 0xe5, 0x19, 0xf0, 0xe5, 0x15, 0x24, 0x31, 0xf5, 0x82,
+  0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x30, 0xe5, 0x04, 0xe5, 0x16, 0x42, 0x13, 0xe5, 0x17, 0x55,
+  0x16, 0xff, 0xf5, 0x19, 0xe5, 0x15, 0x24, 0x30, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83}},
+ {0x0e06, 64, { 0xe0, 0x6f, 0x60, 0x07, 0xe5, 0x19, 0xf0, 0xe5, 0x16, 0x42, 0x13, 0x22, 0x30, 0x09, 0x03, 0x02, 0x0f,
+  0x11, 0xe5, 0x24, 0x14, 0x60, 0x2a, 0x14, 0x60, 0x41, 0x14, 0x60, 0x58, 0x14, 0x60, 0x6f, 0x24,
+  0x04, 0x60, 0x03, 0x02, 0x0e, 0xcf, 0x7e, 0x7b, 0x7f, 0xc0, 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0,
+  0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0, 0x75, 0x16, 0x01, 0x12, 0x12, 0xa1, 0x75, 0x24, 0x01}},
+ {0x0e46, 64, { 0x22, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x00, 0x90, 0x7f, 0x96, 0x74, 0xdf, 0xf0,
+  0x75, 0x16, 0x02, 0x12, 0x12, 0xa1, 0x75, 0x24, 0x02, 0x22, 0x7e, 0x7c, 0x7f, 0x40, 0x75, 0x14,
+  0x7c, 0x75, 0x15, 0x40, 0x90, 0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75, 0x16, 0x04, 0x12, 0x12, 0xa1,
+  0x75, 0x24, 0x03, 0x22, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x80, 0x90}},
+ {0x0e86, 64, { 0x7f, 0x96, 0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0x12, 0x12, 0xa1, 0x75, 0x24, 0x04, 0x22, 0x30, 0x04,
+  0x33, 0xc2, 0x04, 0x53, 0x13, 0xdf, 0xe4, 0xf5, 0x19, 0x7e, 0x00, 0x7b, 0x00, 0x74, 0x2e, 0x25,
+  0x19, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x11, 0xab, 0xff, 0x74, 0x80, 0x25, 0x19, 0xf5, 0x82,
+  0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x19, 0xe5, 0x19, 0xb4, 0x03, 0xdb, 0x90}},
+ {0x0ec6, 64, { 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0x75, 0x24, 0x05, 0x22, 0xe5, 0x36, 0x60, 0x3b, 0xd5, 0x36, 0x0a, 0x53,
+  0x13, 0xef, 0x30, 0x0a, 0x04, 0xd2, 0x09, 0xc2, 0x0a, 0xe4, 0xf5, 0x19, 0x7e, 0x00, 0x7b, 0x00,
+  0x74, 0x35, 0x25, 0x19, 0xf9, 0xee, 0x34, 0x00, 0xfa, 0x12, 0x11, 0xab, 0xff, 0x74, 0x80, 0x25,
+  0x19, 0xf5, 0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xef, 0xf0, 0x05, 0x19, 0xe5, 0x19, 0xb4}},
+ {0x0f06, 64, { 0x03, 0xdb, 0x90, 0x7f, 0xc3, 0x74, 0x03, 0xf0, 0xe4, 0xf5, 0x24, 0x22, 0xe4, 0xf5, 0x1a, 0x7e, 0x00,
+  0x7b, 0x01, 0xe5, 0x15, 0x25, 0x1a, 0xf9, 0xee, 0x35, 0x14, 0xfa, 0xe4, 0x12, 0x11, 0xf1, 0x05,
+  0x1a, 0xe5, 0x1a, 0xb4, 0x3c, 0xe8, 0xe5, 0x15, 0x24, 0x35, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5,
+  0x83, 0x74, 0x01, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5}},
+ {0x0f46, 64, { 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0xf0, 0x7f, 0x0c, 0xe4, 0xfd,
+  0x12, 0x16, 0x47, 0x7f, 0x10, 0xe5, 0x15, 0x24, 0x33, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83,
+  0xef, 0xf0, 0x12, 0x15, 0xb7, 0x90, 0x78, 0x41, 0x74, 0x02, 0xf0, 0x7f, 0x01, 0xe5, 0x15, 0x24,
+  0x36, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xef, 0xf0, 0x44, 0x06, 0x90, 0xc0, 0x00}},
+ {0x0f86, 64, { 0xf0, 0x90, 0x78, 0x41, 0x74, 0x04, 0xf0, 0xe5, 0x15, 0x24, 0x39, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5,
+  0x83, 0x74, 0x80, 0xf0, 0x90, 0xc0, 0x00, 0xf0, 0x0f, 0xe4, 0xfd, 0x12, 0x16, 0x47, 0xe4, 0xff,
+  0x7e, 0xa3, 0xe5, 0x15, 0x24, 0x32, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xee, 0xf0, 0xfd,
+  0x12, 0x16, 0x47, 0x90, 0x78, 0x41, 0x74, 0x01, 0xf0, 0x90, 0xc0, 0x00, 0xe4, 0xf0, 0x7f}},
+ {0x0fc6, 64, { 0x05, 0x7d, 0x7f, 0x12, 0x16, 0x47, 0x7f, 0x01, 0x12, 0x15, 0x4f, 0x7f, 0x03, 0x7d, 0x07, 0x12, 0x16,
+  0x47, 0x22, 0x53, 0x13, 0x3f, 0x90, 0x7b, 0xf1, 0xe0, 0x30, 0xe3, 0x16, 0x7e, 0x7b, 0x7f, 0xc0,
+  0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0, 0x75, 0x16, 0x01, 0x12,
+  0x08, 0xc1, 0x90, 0x7c, 0x31, 0xe0, 0x30, 0xe3, 0x16, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14}},
+ {0x1006, 64, { 0x7c, 0x75, 0x15, 0x00, 0x90, 0x7f, 0x96, 0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0x12, 0x08, 0xc1, 0x90,
+  0x7c, 0x71, 0xe0, 0x30, 0xe3, 0x16, 0x7e, 0x7c, 0x7f, 0x40, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x40,
+  0x90, 0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75, 0x16, 0x04, 0x12, 0x08, 0xc1, 0x90, 0x7c, 0xb1, 0xe0,
+  0x30, 0xe3, 0x16, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x80, 0x90, 0x7f}},
+ {0x1046, 64, { 0x96, 0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0x12, 0x08, 0xc1, 0x05, 0x11, 0xe5, 0x11, 0x54, 0x0f, 0xf5,
+  0x18, 0x70, 0x1f, 0x90, 0x78, 0x41, 0xe0, 0x54, 0xf7, 0xf0, 0x90, 0x7f, 0x99, 0xe0, 0xf5, 0x17,
+  0x90, 0x78, 0x41, 0xe0, 0x44, 0x08, 0xf0, 0x90, 0x7f, 0x99, 0xe0, 0xf4, 0xf5, 0x12, 0x12, 0x11,
+  0x21, 0x22, 0xe5, 0x18, 0xb4, 0x01, 0x04, 0x12, 0x0c, 0x73, 0x22, 0x90, 0x7f, 0xc2, 0xe0}},
+ {0x1086, 64, { 0x20, 0xe1, 0x08, 0xe5, 0x13, 0x60, 0x04, 0x12, 0x0e, 0x12, 0x22, 0x12, 0x0c, 0x73, 0x22, 0x78, 0x7f,
+  0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x37, 0x02, 0x10, 0xdc, 0x02, 0x12, 0x29, 0xe4, 0x93, 0xa3,
+  0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4,
+  0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20}},
+ {0x10c6, 64, { 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04,
+  0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x50, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff,
+  0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54,
+  0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8}},
+ {0x1106, 64, { 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8,
+  0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0x90, 0x7f, 0xd2, 0xe0, 0x30, 0xe1,
+  0x03, 0x02, 0x11, 0xaa, 0xc2, 0x09, 0x90, 0x7b, 0x40, 0xe0, 0x14, 0x60, 0x26, 0x14, 0x60, 0x3b,
+  0x14, 0x60, 0x50, 0x24, 0x83, 0x60, 0x64, 0x24, 0x80, 0x70, 0x63, 0x7e, 0x7b, 0x7f, 0xc0}},
+ {0x1146, 64, { 0x75, 0x14, 0x7b, 0x75, 0x15, 0xc0, 0x90, 0x7f, 0x96, 0x74, 0xef, 0xf0, 0x75, 0x16, 0x01, 0x12, 0x00,
+  0x46, 0x80, 0x4b, 0x7e, 0x7c, 0x7f, 0x00, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x00, 0x90, 0x7f, 0x96,
+  0x74, 0xdf, 0xf0, 0x75, 0x16, 0x02, 0x12, 0x00, 0x46, 0x80, 0x33, 0x7e, 0x7c, 0x7f, 0x40, 0x75,
+  0x14, 0x7c, 0x75, 0x15, 0x40, 0x90, 0x7f, 0x96, 0x74, 0xbf, 0xf0, 0x75, 0x16, 0x04, 0x12}},
+ {0x1186, 64, { 0x00, 0x46, 0x80, 0x1b, 0x7e, 0x7c, 0x7f, 0x80, 0x75, 0x14, 0x7c, 0x75, 0x15, 0x80, 0x90, 0x7f, 0x96,
+  0x74, 0x7f, 0xf0, 0x75, 0x16, 0x08, 0x12, 0x00, 0x46, 0x80, 0x03, 0x12, 0x17, 0x5c, 0xe4, 0x90,
+  0x7f, 0xd3, 0xf0, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7,
+  0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01}},
+ {0x11c6, 64, { 0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 0x25,
+  0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 0x29,
+  0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a,
+  0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xd0, 0x83, 0xd0}},
+ {0x1206, 64, { 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01,
+  0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3, 0xa3,
+  0x80, 0xdf, 0x90, 0x7f, 0xae, 0xe0, 0xff, 0xd3, 0x92, 0x00, 0xe4, 0x33, 0xfe, 0xef, 0x4e, 0xf0,
+  0xd2, 0xe8, 0x43, 0xd8, 0x20, 0x90, 0x7f, 0xde, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xdf, 0xf0}},
+ {0x1246, 64, { 0x90, 0x7f, 0xab, 0x74, 0xff, 0xf0, 0x90, 0x7f, 0xa9, 0xf0, 0x90, 0x7f, 0xaa, 0xf0, 0x53, 0x91, 0xef,
+  0x90, 0x7f, 0xaf, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xae, 0x74, 0x0d, 0xf0, 0xd2, 0xaf, 0xd2, 0x0b,
+  0x12, 0x18, 0x14, 0xc2, 0x01, 0xe4, 0xf5, 0x2b, 0xf5, 0x31, 0xc2, 0x07, 0xc2, 0x02, 0x75, 0x29,
+  0xf0, 0x90, 0x7f, 0xd8, 0xe0, 0x65, 0x26, 0x60, 0x06, 0x75, 0x32, 0x0f, 0xe0, 0xf5, 0x26}},
+ {0x1286, 64, { 0x30, 0x02, 0x03, 0x12, 0x0f, 0xd9, 0x30, 0x01, 0x07, 0xc2, 0x01, 0x12, 0x06, 0x29, 0x80, 0xe2, 0x30,
+  0x08, 0xdf, 0xc2, 0x08, 0x12, 0x18, 0x35, 0x80, 0xd8, 0x22, 0xe5, 0x13, 0x55, 0x16, 0x60, 0x6a,
+  0xe5, 0x15, 0x24, 0x3a, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x70, 0x5c, 0xe5, 0x16,
+  0xf4, 0x52, 0x13, 0xe5, 0x15, 0x24, 0x26, 0xff, 0xe4, 0x35, 0x14, 0xfe, 0xe4, 0xfd, 0x0f}},
+ {0x12c6, 64, { 0xef, 0xaa, 0x06, 0x70, 0x01, 0x0e, 0x14, 0xf5, 0x82, 0x8a, 0x83, 0xe0, 0xfc, 0x74, 0x80, 0x2d, 0xf5,
+  0x82, 0xe4, 0x34, 0x7b, 0xf5, 0x83, 0xec, 0xf0, 0x0d, 0xbd, 0x0b, 0xe2, 0x90, 0x7f, 0xc3, 0x74,
+  0x0b, 0xf0, 0xe5, 0x15, 0x24, 0x3a, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0x74, 0x10, 0xf0,
+  0xe5, 0x15, 0x24, 0x2e, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0, 0xe5, 0x15}},
+ {0x1306, 64, { 0x24, 0x2f, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe4, 0xf0, 0x22, 0xe5, 0x28, 0x45, 0x27, 0x60,
+  0x57, 0xae, 0x27, 0xaf, 0x28, 0xd3, 0xef, 0x94, 0x40, 0xee, 0x94, 0x00, 0x40, 0x04, 0x7e, 0x00,
+  0x7f, 0x40, 0xc3, 0xe5, 0x28, 0x9f, 0xf5, 0x28, 0xe5, 0x27, 0x9e, 0xf5, 0x27, 0xe4, 0xfd, 0xed,
+  0xc3, 0x9f, 0xe4, 0x9e, 0x50, 0x1f, 0x85, 0x34, 0x82, 0x85, 0x33, 0x83, 0xe0, 0xfc, 0x74}},
+ {0x1346, 64, { 0x00, 0x2d, 0xf5, 0x82, 0xe4, 0x34, 0x7f, 0xf5, 0x83, 0xec, 0xf0, 0x0d, 0x05, 0x34, 0xe5, 0x34, 0x70,
+  0x02, 0x05, 0x33, 0x80, 0xda, 0x90, 0x7f, 0xa9, 0x74, 0x01, 0xf0, 0x90, 0x7f, 0xac, 0xe0, 0x44,
+  0x01, 0xf0, 0x90, 0x7f, 0xb5, 0xef, 0xf0, 0x22, 0x90, 0x7f, 0xac, 0xe0, 0x54, 0xfe, 0xf0, 0xe4,
+  0x90, 0x7f, 0xb5, 0xf0, 0x22, 0xe4, 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0xf0}},
+ {0x1386, 64, { 0xf0, 0x90, 0x7f, 0x96, 0xf0, 0xe4, 0x90, 0x78, 0x4a, 0xf0, 0x90, 0x7f, 0x94, 0xf0, 0x90, 0x7f, 0x9d,
+  0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x97, 0xf0, 0x30, 0x00, 0x07, 0xe5, 0x29, 0x54, 0xf0, 0xff,
+  0x80, 0x02, 0x7f, 0x00, 0xef, 0x44, 0x08, 0x90, 0x78, 0x41, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0,
+  0x90, 0x7f, 0x95, 0xf0, 0x90, 0x7f, 0x9e, 0x74, 0xff, 0xf0, 0xe4, 0x90, 0x7f, 0x98, 0xf0}},
+ {0x13c6, 64, { 0x90, 0x7f, 0x93, 0xf0, 0x90, 0x7f, 0x9c, 0x74, 0xf0, 0xf0, 0xe4, 0x90, 0x7f, 0x96, 0xf0, 0x90, 0x7f,
+  0x92, 0xe0, 0x54, 0xfd, 0xf0, 0x22, 0x8f, 0x1a, 0x05, 0x2d, 0xe5, 0x2d, 0xae, 0x2c, 0x70, 0x02,
+  0x05, 0x2c, 0x14, 0xf5, 0x82, 0x8e, 0x83, 0xe5, 0x1a, 0xf0, 0x12, 0x18, 0xf0, 0x05, 0x2d, 0xe5,
+  0x2d, 0xac, 0x2c, 0x70, 0x02, 0x05, 0x2c, 0x14, 0xf5, 0x82, 0x8c, 0x83, 0xef, 0xf0, 0x15}},
+ {0x1406, 64, { 0x23, 0xe5, 0x23, 0x60, 0x1f, 0xe5, 0x15, 0x24, 0x38, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xc0,
+  0x83, 0xc0, 0x82, 0xe0, 0xfe, 0x12, 0x18, 0xd8, 0x8f, 0x1a, 0xee, 0x4f, 0xd0, 0x82, 0xd0, 0x83,
+  0xf0, 0x80, 0xb5, 0x22, 0x8f, 0x1a, 0xe4, 0xf5, 0x1b, 0x75, 0x1c, 0xff, 0x75, 0x1d, 0x19, 0x75,
+  0x1e, 0x86, 0xab, 0x1c, 0xaa, 0x1d, 0xa9, 0x1e, 0x90, 0x00, 0x01, 0x12, 0x11, 0xc4, 0xb4}},
+ {0x1446, 64, { 0x03, 0x1d, 0xaf, 0x1b, 0x05, 0x1b, 0xef, 0xb5, 0x1a, 0x01, 0x22, 0x12, 0x11, 0xab, 0x7e, 0x00, 0x29,
+  0xff, 0xee, 0x3a, 0xa9, 0x07, 0x75, 0x1c, 0xff, 0xf5, 0x1d, 0x89, 0x1e, 0x80, 0xd4, 0x7b, 0x00,
+  0x7a, 0x00, 0x79, 0x00, 0x22, 0xe4, 0x90, 0x78, 0x41, 0xf0, 0x90, 0x78, 0x4f, 0x74, 0xc0, 0xf0,
+  0xe4, 0x90, 0x78, 0x50, 0xf0, 0xe5, 0x2c, 0x90, 0x78, 0x51, 0xf0, 0xae, 0x2c, 0xe5, 0x2d}},
+ {0x1486, 64, { 0x90, 0x78, 0x52, 0xf0, 0x90, 0x78, 0x54, 0xe5, 0x23, 0xf0, 0x90, 0x78, 0x57, 0x74, 0x04, 0xf0, 0x90,
+  0x7f, 0xe2, 0xe0, 0x44, 0x10, 0xf0, 0xe0, 0x54, 0xf7, 0xf0, 0xe4, 0x90, 0x78, 0x55, 0xf0, 0x90,
+  0x78, 0x55, 0xe0, 0x60, 0xfa, 0x22, 0xe4, 0x90, 0x78, 0x41, 0xf0, 0xe5, 0x2c, 0x90, 0x78, 0x4f,
+  0xf0, 0xae, 0x2c, 0xe5, 0x2d, 0x90, 0x78, 0x50, 0xf0, 0x90, 0x78, 0x51, 0x74, 0xc0, 0xf0}},
+ {0x14c6, 64, { 0xe4, 0x90, 0x78, 0x52, 0xf0, 0x90, 0x78, 0x54, 0xe5, 0x23, 0xf0, 0x90, 0x78, 0x57, 0x74, 0x04, 0xf0,
+  0xe4, 0x90, 0x78, 0x55, 0xf0, 0x90, 0x78, 0x55, 0xe0, 0x60, 0xfa, 0x22, 0xe5, 0x15, 0x24, 0x04,
+  0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14, 0x60, 0x0f, 0x14, 0x60, 0x13, 0x14, 0x60,
+  0x17, 0x80, 0x00, 0x90, 0x7f, 0xc7, 0xef, 0xf0, 0x80, 0x13, 0x90, 0x7f, 0xc9, 0xef, 0xf0}},
+ {0x1506, 64, { 0x80, 0x0c, 0x90, 0x7f, 0xcb, 0xef, 0xf0, 0x80, 0x05, 0x90, 0x7f, 0xcd, 0xef, 0xf0, 0xe5, 0x16, 0x42,
+  0x2a, 0x22, 0xe5, 0x15, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14, 0x60,
+  0x0f, 0x14, 0x60, 0x13, 0x14, 0x60, 0x17, 0x80, 0x00, 0x90, 0x7f, 0xb7, 0xef, 0xf0, 0x80, 0x13,
+  0x90, 0x7f, 0xb9, 0xef, 0xf0, 0x80, 0x0c, 0x90, 0x7f, 0xbb, 0xef, 0xf0, 0x80, 0x05, 0x90}},
+ {0x1546, 64, { 0x7f, 0xbd, 0xef, 0xf0, 0xe5, 0x16, 0x42, 0x2a, 0x22, 0xae, 0x07, 0xe4, 0xff, 0xe5, 0x15, 0x24, 0x32,
+  0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0xfd, 0x12, 0x16, 0x47, 0x90, 0x78,
+  0x41, 0x74, 0x01, 0xf0, 0x90, 0xc0, 0x00, 0xee, 0xf0, 0xe4, 0xe5, 0x15, 0x24, 0x32, 0xf5, 0x82,
+  0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x44, 0x80, 0xfd, 0x12, 0x16, 0x47, 0x22, 0xc0, 0xe0}},
+ {0x1586, 64, { 0xc0, 0xf0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xc0, 0xd0,
+  0x75, 0xd0, 0x08, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xa9, 0x74, 0x01, 0xf0, 0x12, 0x13, 0x12, 0xd0,
+  0xd0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xf0, 0xd0, 0xe0, 0x32,
+  0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x78, 0x41}},
+ {0x15c6, 64, { 0x74, 0x02, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24,
+  0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22,
+  0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x78, 0x41, 0x74,
+  0x04, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15}},
+ {0x1606, 64, { 0x24, 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22,
+  0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0x90, 0x78, 0x41, 0x74,
+  0x06, 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24,
+  0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0}},
+ {0x1646, 64, { 0x22, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5,
+  0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x07, 0xf0, 0x90, 0xc0,
+  0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x05, 0xf0, 0x90, 0xc0, 0x00, 0xed, 0xf0, 0x22, 0x90,
+  0x78, 0x41, 0x74, 0x03, 0xf0, 0x90, 0xc0, 0x00, 0x74, 0xbf, 0xf0, 0xe4, 0x90, 0x78, 0x41}},
+ {0x1686, 64, { 0xf0, 0x90, 0xc0, 0x00, 0xef, 0xf0, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0, 0xe5, 0x15, 0x24, 0x37, 0xf5,
+  0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x54, 0x7f, 0x90, 0xc0, 0x00, 0xf0, 0x22, 0xe5, 0x15,
+  0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14, 0x60, 0x0e, 0x14, 0x60, 0x11,
+  0x14, 0x60, 0x14, 0x80, 0x00, 0x90, 0x7f, 0xc6, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xc8, 0xe0}},
+ {0x16c6, 64, { 0xff, 0x22, 0x90, 0x7f, 0xca, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xcc, 0xe0, 0xff, 0x22, 0xe5, 0x15, 0x24,
+  0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14, 0x60, 0x0e, 0x14, 0x60, 0x11, 0x14,
+  0x60, 0x14, 0x80, 0x00, 0x90, 0x7f, 0xb6, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xb8, 0xe0, 0xff, 0x22,
+  0x90, 0x7f, 0xba, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xbc, 0xe0, 0xff, 0x22, 0xe5, 0x15, 0x24}},
+ {0x1706, 64, { 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x14, 0x60, 0x0e, 0x14, 0x60, 0x11, 0x14, 0x60,
+  0x14, 0x80, 0x00, 0x90, 0x7f, 0xc7, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xc9, 0xe0, 0xff, 0x22, 0x90,
+  0x7f, 0xcb, 0xe0, 0xff, 0x22, 0x90, 0x7f, 0xcd, 0xe0, 0xff, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0,
+  0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0x90, 0x7f, 0xc4, 0xe4, 0xf0}},
+ {0x1746, 64, { 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x04, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82,
+  0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x7b, 0x41, 0xe0, 0xf5, 0x36, 0x43, 0x13, 0x10, 0xa3, 0xe0,
+  0x60, 0x09, 0x90, 0x7f, 0xd7, 0x74, 0x17, 0xf0, 0x74, 0x37, 0xf0, 0x90, 0x7b, 0x43, 0xe0, 0xf5,
+  0x37, 0xa3, 0xe0, 0x54, 0xf0, 0xf5, 0x29, 0xe0, 0x60, 0x02, 0xd2, 0x0a, 0x22, 0xc0, 0xe0}},
+ {0x1786, 64, { 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86, 0x75, 0x86, 0x00, 0xd2, 0x01, 0x53, 0x91,
+  0xef, 0x90, 0x7f, 0xab, 0x74, 0x01, 0xf0, 0xd0, 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0,
+  0x83, 0xd0, 0xe0, 0x32, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0x85, 0xc0, 0x84, 0xc0, 0x86,
+  0x75, 0x86, 0x00, 0xd2, 0x08, 0x53, 0x91, 0xef, 0x90, 0x7f, 0xab, 0x74, 0x08, 0xf0, 0xd0}},
+ {0x17c6, 64, { 0x86, 0xd0, 0x84, 0xd0, 0x85, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x12, 0x18, 0xc0, 0xae, 0x07,
+  0x12, 0x18, 0xc0, 0xad, 0x07, 0xee, 0x6d, 0x60, 0x10, 0x12, 0x18, 0xc0, 0xae, 0x07, 0xee, 0x6d,
+  0x60, 0x07, 0x12, 0x18, 0xc0, 0xad, 0x07, 0x80, 0xec, 0xaf, 0x06, 0x22, 0x74, 0x00, 0xf5, 0x86,
+  0x90, 0xfd, 0xa5, 0x7c, 0x05, 0xa3, 0xe5, 0x82, 0x45, 0x83, 0x70, 0xf9, 0x22, 0x90, 0x7f}},
+ {0x1806, 64, { 0xd6, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x90, 0x7f, 0xd6,
+  0xe0, 0x44, 0x04, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x30, 0x0b, 0x04, 0xe0, 0x44, 0x02, 0xf0, 0x7f,
+  0xf4, 0x7e, 0x01, 0x12, 0x18, 0x6b, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xf7, 0xf0, 0x22, 0x12, 0x13,
+  0x7c, 0x12, 0x18, 0x04, 0x90, 0x7f, 0xd6, 0xe0, 0x30, 0xe7, 0x0a, 0x7f, 0x05, 0x7e, 0x00}},
+ {0x1846, 64, { 0x12, 0x18, 0x6b, 0x12, 0x18, 0x9e, 0x12, 0x0a, 0xb8, 0x22, 0x03, 0x35, 0x80, 0x00, 0x00, 0x03, 0x2e,
+  0x81, 0x00, 0x00, 0xc1, 0x85, 0xc1, 0x81, 0xc1, 0x08, 0xc1, 0x00, 0xc1, 0x06, 0x01, 0x22, 0x00,
+  0x01, 0x24, 0x00, 0x00, 0x8e, 0x18, 0x8f, 0x19, 0xe5, 0x19, 0x15, 0x19, 0xae, 0x18, 0x70, 0x02,
+  0x15, 0x18, 0x4e, 0x60, 0x08, 0x12, 0x17, 0xf3, 0x12, 0x17, 0xf3, 0x80, 0xeb, 0x22, 0xe5}},
+ {0x1886, 64, { 0x15, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x14, 0xf5, 0x83, 0xe0, 0x04, 0xff, 0x44, 0x10, 0x90, 0x7f,
+  0xd7, 0xf0, 0xef, 0x44, 0x30, 0xf0, 0x22, 0x90, 0x7f, 0xd6, 0xe0, 0x44, 0x01, 0xf0, 0x7f, 0x0d,
+  0x7e, 0x00, 0x12, 0x18, 0x6b, 0x90, 0x7f, 0xd6, 0xe0, 0x54, 0xfe, 0xf0, 0x22, 0x90, 0x78, 0x41,
+  0x74, 0x02, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x78, 0x41, 0x74, 0x03, 0xf0}},
+ {0x18c6, 64, { 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x78, 0x41, 0x74, 0x04, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff,
+  0x22, 0x90, 0x78, 0x41, 0x74, 0x05, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x90, 0x78, 0x41,
+  0x74, 0x06, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0xe4, 0x90, 0x78, 0x41, 0xf0, 0x90, 0xc0,
+  0x00, 0xe0, 0xff, 0x22, 0x53, 0xd8, 0xef, 0x32, 0x00, 0x12, 0x01, 0x10, 0x01, 0xff, 0x00}},
  {0x1906, 64, { 0x00, 0x40, 0xcd, 0x06, 0x0a, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x04, 0x09, 0x02, 0x74, 0x00, 0x01,
   0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00, 0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01,
   0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x03, 0x02, 0x40,
@@ -438,7 +442,7 @@
   0x00, 0x42, 0x00, 0x20, 0x00, 0x34, 0x00, 0x2d, 0x00, 0x70, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x74,
   0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x69, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x20,
   0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00, 0x70, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00}},
- {0x1a06, 64, { 0x00, 0x00, 0xe4, 0x90, 0x78, 0x41, 0xf0, 0x90, 0xc0, 0x00, 0xe0, 0xff, 0x22, 0x00, 0x00, 0x00, 0x00,
+ {0x1a06, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
@@ -453,8 +457,8 @@
  {0x1ac6, 64, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x17, 0xb7, 0x00, 0x02, 0x1b}},
- {0x1b06, 21, { 0x04, 0x00, 0x02, 0x17, 0x65, 0x00, 0x02, 0x17, 0x37, 0x00, 0x02, 0x1b, 0x10, 0x00, 0x02, 0x1b, 0x14,
-  0x00, 0x02, 0x15, 0x89}},
-{ 0xffff,	0,	{0x00} }
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x17, 0x84, 0x00, 0x02, 0x1b}},
+ {0x1b06, 21, { 0x04, 0x00, 0x02, 0x17, 0x32, 0x00, 0x02, 0x17, 0xab, 0x00, 0x02, 0x1b, 0x10, 0x00, 0x02, 0x1b, 0x14,
+  0x00, 0x02, 0x15, 0x84}},
+ {0xffff, 0, {0x00}}
 };
diff -Nur linux-2.4.19.old/drivers/usb/serial/kl5kusb105.c linux-2.4.19/drivers/usb/serial/kl5kusb105.c
--- linux-2.4.19.old/drivers/usb/serial/kl5kusb105.c	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/serial/kl5kusb105.c	Mon Nov 25 12:27:09 2002
@@ -47,18 +47,14 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-/*#include <linux/fcntl.h>*/
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
-/*#include <linux/spinlock.h>*/
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -111,81 +107,41 @@
  */
 
 /*
- * All of the device info needed for the MCT USB-RS232 converter.
+ * All of the device info needed for the KLSI converters.
  */
-static __devinitdata struct usb_device_id id_table_combined [] = {
+static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PALMCONNECT_VID, PALMCONNECT_PID) },
 	{ USB_DEVICE(KLSI_VID, KLSI_KL5KUSB105D_PID) },
 	{ }		/* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id palmconnect_table [] = {
-        { USB_DEVICE(PALMCONNECT_VID, PALMCONNECT_PID) },
-        { }                        /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id kl5kusb105d_table [] = {
-        { USB_DEVICE(KLSI_VID, KLSI_KL5KUSB105D_PID) },
-        { }                        /* Terminating entry */
-};
-
+MODULE_DEVICE_TABLE (usb, id_table);
 
-MODULE_DEVICE_TABLE (usb, id_table_combined);
-
-
-static struct usb_serial_device_type palmconnect_device = {
-	name:		     "PalmConnect USB Serial",
-	id_table:	     palmconnect_table,
-	needs_interrupt_in:  MUST_HAVE,	  /* 1 interrupt-in endpoints */
-	needs_bulk_in:	     MUST_HAVE,   /* 1 bulk-in endpoint */
-	needs_bulk_out:	     MUST_HAVE,	  /* 1 bulk-out endpoint */
-	num_interrupt_in:    1,
-	num_bulk_in:	     1,
-	num_bulk_out:	     1,
-	num_ports:	     1,
-	open:		     klsi_105_open,
-	close:		     klsi_105_close,
-	write:		     klsi_105_write,
-	write_bulk_callback: klsi_105_write_bulk_callback,
-	chars_in_buffer:     klsi_105_chars_in_buffer,
-	write_room:          klsi_105_write_room,
-	read_bulk_callback:  klsi_105_read_bulk_callback,
-	ioctl:		     klsi_105_ioctl,
-	set_termios:	     klsi_105_set_termios,
-	/*break_ctl:	     klsi_105_break_ctl,*/
-	startup:	     klsi_105_startup,
-	shutdown:	     klsi_105_shutdown,
-	throttle:	     klsi_105_throttle,
-	unthrottle:	     klsi_105_unthrottle,
-};
 
 static struct usb_serial_device_type kl5kusb105d_device = {
-	name:		     "generic KL5KUSB105D USB->Serial",
-	id_table:	     kl5kusb105d_table,
-	needs_interrupt_in:  MUST_HAVE,	 /* 1 interrupt-in endpoints */
-	needs_bulk_in:	     MUST_HAVE,  /* 1 bulk-in endpoint */
-	needs_bulk_out:	     MUST_HAVE,	 /* 1 bulk-out endpoint */
-	num_interrupt_in:    1,
-	num_bulk_in:	     1,
-	num_bulk_out:	     1,
-	num_ports:	     1,
-	open:		     klsi_105_open,
-	close:		     klsi_105_close,
-	write:		     klsi_105_write,
-	write_bulk_callback: klsi_105_write_bulk_callback,
-	chars_in_buffer:     klsi_105_chars_in_buffer,
-	write_room:          klsi_105_write_room,
-	read_bulk_callback:  klsi_105_read_bulk_callback,
-	ioctl:		     klsi_105_ioctl,
-	set_termios:	     klsi_105_set_termios,
-	/*break_ctl:	     klsi_105_break_ctl,*/
-	startup:	     klsi_105_startup,
-	shutdown:	     klsi_105_shutdown,
-	throttle:	     klsi_105_throttle,
-	unthrottle:	     klsi_105_unthrottle,
+	.owner =             THIS_MODULE,
+	.name =		     "KL5KUSB105D / PalmConnect",
+	.id_table =	     id_table,
+	.num_interrupt_in =  1,
+	.num_bulk_in =	     1,
+	.num_bulk_out =	     1,
+	.num_ports =	     1,
+	.open =		     klsi_105_open,
+	.close =	     klsi_105_close,
+	.write =	     klsi_105_write,
+	.write_bulk_callback = klsi_105_write_bulk_callback,
+	.chars_in_buffer =   klsi_105_chars_in_buffer,
+	.write_room =        klsi_105_write_room,
+	.read_bulk_callback =klsi_105_read_bulk_callback,
+	.ioctl =	     klsi_105_ioctl,
+	.set_termios =	     klsi_105_set_termios,
+	/*.break_ctl =	     klsi_105_break_ctl,*/
+	.startup =	     klsi_105_startup,
+	.shutdown =	     klsi_105_shutdown,
+	.throttle =	     klsi_105_throttle,
+	.unthrottle =	     klsi_105_unthrottle,
 };
 
-
 struct klsi_105_port_settings {
 	__u8	pktlen;		/* always 5, it seems */
 	__u8	baudrate;
@@ -231,7 +187,8 @@
 			     KLSI_TIMEOUT);
 	if (rc < 0)
 		err("Change port settings failed (error = %d)", rc);
-	info(__FUNCTION__ " - %d byte block, baudrate %x, databits %d, u1 %d, u2 %d",
+	info("%s - %d byte block, baudrate %x, databits %d, u1 %d, u2 %d",
+	    __FUNCTION__,
 	    settings->pktlen,
 	    settings->baudrate, settings->databits,
 	    settings->unknown1, settings->unknown2);
@@ -262,7 +219,7 @@
 	__u8 status_buf[KLSI_STATUSBUF_LEN] = { -1,-1};
 	__u16 status;
 
-	info(__FUNCTION__ " - sending SIO Poll request");
+	info("%s - sending SIO Poll request", __FUNCTION__);
         rc = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			     KL5KUSB105A_SIO_POLL,
                              USB_TYPE_VENDOR | USB_DIR_IN,
@@ -276,7 +233,7 @@
 	else {
 		status = status_buf[0] + (status_buf[1]<<8);
 
-		info(__FUNCTION__ " - read status %x %x",
+		info("%s - read status %x %x", __FUNCTION__,
 		     status_buf[0], status_buf[1]);
 
 		*line_state_p = klsi_105_status2linestate(status);
@@ -304,7 +261,7 @@
 		serial->port[i].private = kmalloc(sizeof(struct klsi_105_private),
 						   GFP_KERNEL);
 		if (!serial->port[i].private) {
-			dbg(__FUNCTION__ "kmalloc for klsi_105_private failed.");
+			dbg("%skmalloc for klsi_105_private failed.", __FUNCTION__);
 			return (-1); /* error */
 		}
 		priv = (struct klsi_105_private *)serial->port[i].private;
@@ -334,8 +291,7 @@
 			urb->transfer_buffer = kmalloc (URB_TRANSFER_BUFFER_SIZE,
 							GFP_KERNEL);
 			if (!urb->transfer_buffer) {
-				err (__FUNCTION__ 
-				     " - out of memory for urb buffers.");
+				err("%s - out of memory for urb buffers.", __FUNCTION__);
 				continue;
 			}
 		}
@@ -352,16 +308,13 @@
 {
 	int i;
 	
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	/* stop reads and writes on all ports */
 	for (i=0; i < serial->num_ports; ++i) {
 		struct klsi_105_private *priv = 
 			(struct klsi_105_private*) serial->port[i].private;
 		unsigned long flags;
-		while (serial->port[i].open_count > 0) {
-			klsi_105_close (&serial->port[i], NULL);
-		}
 
 		if (priv) {
 			/* kill our write urb pool */
@@ -397,92 +350,79 @@
 	struct usb_serial *serial = port->serial;
 	struct klsi_105_private *priv = (struct klsi_105_private *)port->private;
 	int retval = 0;
+	int rc;
+	int i;
+	unsigned long line_state;
 
-	dbg(__FUNCTION__" port %d", port->number);
+	dbg("%s port %d", __FUNCTION__, port->number);
 
-	down (&port->sem);
+	/* force low_latency on so that our tty_push actually forces
+	 * the data through
+	 * port->tty->low_latency = 1; */
+
+	/* Do a defined restart:
+	 * Set up sane default baud rate and send the 'READ_ON'
+	 * vendor command. 
+	 * FIXME: set modem line control (how?)
+	 * Then read the modem line control and store values in
+	 * priv->line_state.
+	 */
+	priv->cfg.pktlen   = 5;
+	priv->cfg.baudrate = kl5kusb105a_sio_b9600;
+	priv->cfg.databits = kl5kusb105a_dtb_8;
+	priv->cfg.unknown1 = 0;
+	priv->cfg.unknown2 = 1;
+	klsi_105_chg_port_settings(serial, &(priv->cfg));
 	
-	++port->open_count;
-	MOD_INC_USE_COUNT;
+	/* set up termios structure */
+	priv->termios.c_iflag = port->tty->termios->c_iflag;
+	priv->termios.c_oflag = port->tty->termios->c_oflag;
+	priv->termios.c_cflag = port->tty->termios->c_cflag;
+	priv->termios.c_lflag = port->tty->termios->c_lflag;
+	for (i=0; i<NCCS; i++)
+		priv->termios.c_cc[i] = port->tty->termios->c_cc[i];
 
-	if (!port->active) {
-		int rc;
-		int i;
-		unsigned long line_state;
-		port->active = 1;
-
-		/* force low_latency on so that our tty_push actually forces
-		 * the data through
-		 * port->tty->low_latency = 1; */
-
-		/* Do a defined restart:
-		 * Set up sane default baud rate and send the 'READ_ON'
-		 * vendor command. 
-		 * FIXME: set modem line control (how?)
-		 * Then read the modem line control and store values in
-		 * priv->line_state.
-		 */
-		priv->cfg.pktlen   = 5;
-		priv->cfg.baudrate = kl5kusb105a_sio_b9600;
-		priv->cfg.databits = kl5kusb105a_dtb_8;
-		priv->cfg.unknown1 = 0;
-		priv->cfg.unknown2 = 1;
-		klsi_105_chg_port_settings(serial, &(priv->cfg));
-		
-		/* set up termios structure */
-		priv->termios.c_iflag = port->tty->termios->c_iflag;
-		priv->termios.c_oflag = port->tty->termios->c_oflag;
-		priv->termios.c_cflag = port->tty->termios->c_cflag;
-		priv->termios.c_lflag = port->tty->termios->c_lflag;
-		for (i=0; i<NCCS; i++)
-			priv->termios.c_cc[i] = port->tty->termios->c_cc[i];
-
-
-		/* READ_ON and urb submission */
-		FILL_BULK_URB(port->read_urb, serial->dev, 
-			      usb_rcvbulkpipe(serial->dev,
-					      port->bulk_in_endpointAddress),
-			      port->read_urb->transfer_buffer,
-			      port->read_urb->transfer_buffer_length,
-			      klsi_105_read_bulk_callback,
-			      port);
-		port->read_urb->transfer_flags |= USB_QUEUE_BULK;
-
-		rc = usb_submit_urb(port->read_urb);
-		if (rc) {
-			err(__FUNCTION__ 
-			    " - failed submitting read urb, error %d", rc);
-			retval = rc;
-			goto exit;
-		}
 
-		rc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev,0),
-				     KL5KUSB105A_SIO_CONFIGURE,
-				     USB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,
-				     KL5KUSB105A_SIO_CONFIGURE_READ_ON,
-				     0, /* index */
-				     NULL,
-				     0,
-				     KLSI_TIMEOUT);
-		if (rc < 0) {
-			err("Enabling read failed (error = %d)", rc);
-			retval = rc;
-		} else 
-			dbg(__FUNCTION__ " - enabled reading");
+	/* READ_ON and urb submission */
+	FILL_BULK_URB(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev,
+				      port->bulk_in_endpointAddress),
+		      port->read_urb->transfer_buffer,
+		      port->read_urb->transfer_buffer_length,
+		      klsi_105_read_bulk_callback,
+		      port);
+	port->read_urb->transfer_flags |= USB_QUEUE_BULK;
 
-		rc = klsi_105_get_line_state(serial, &line_state);
-		if (rc >= 0) {
-			priv->line_state = line_state;
-			dbg(__FUNCTION__ 
-			    " - read line state 0x%lx", line_state);
-			retval = 0;
-		} else
-			retval = rc;
+	rc = usb_submit_urb(port->read_urb);
+	if (rc) {
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, rc);
+		retval = rc;
+		goto exit;
 	}
 
+	rc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev,0),
+			     KL5KUSB105A_SIO_CONFIGURE,
+			     USB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,
+			     KL5KUSB105A_SIO_CONFIGURE_READ_ON,
+			     0, /* index */
+			     NULL,
+			     0,
+			     KLSI_TIMEOUT);
+	if (rc < 0) {
+		err("Enabling read failed (error = %d)", rc);
+		retval = rc;
+	} else 
+		dbg("%s - enabled reading", __FUNCTION__);
+
+	rc = klsi_105_get_line_state(serial, &line_state);
+	if (rc >= 0) {
+		priv->line_state = line_state;
+		dbg("%s - read line state 0x%lx", __FUNCTION__, line_state);
+		retval = 0;
+	} else
+		retval = rc;
+
 exit:
-	up (&port->sem);
-	
 	return retval;
 } /* klsi_105_open */
 
@@ -492,43 +432,35 @@
 	struct usb_serial *serial;
 	struct klsi_105_private *priv 
 		= (struct klsi_105_private *)port->private;
-	dbg(__FUNCTION__" port %d", port->number);
+	int rc;
+
+	dbg("%s port %d", __FUNCTION__, port->number);
 
 	serial = get_usb_serial (port, __FUNCTION__);
 
 	if(!serial)
 		return;
 
-	down (&port->sem);
-
-	--port->open_count;
+	/* send READ_OFF */
+	rc = usb_control_msg (serial->dev,
+			      usb_sndctrlpipe(serial->dev, 0),
+			      KL5KUSB105A_SIO_CONFIGURE,
+			      USB_TYPE_VENDOR | USB_DIR_OUT,
+			      KL5KUSB105A_SIO_CONFIGURE_READ_OFF,
+			      0, /* index */
+			      NULL, 0,
+			      KLSI_TIMEOUT);
+	if (rc < 0)
+		    err("Disabling read failed (error = %d)", rc);
 
-	if (port->open_count <= 0) {
-		/* send READ_OFF */
-		int rc = usb_control_msg(serial->dev,
-					 usb_sndctrlpipe(serial->dev, 0),
-					 KL5KUSB105A_SIO_CONFIGURE,
-					 USB_TYPE_VENDOR | USB_DIR_OUT,
-					 KL5KUSB105A_SIO_CONFIGURE_READ_OFF,
-					 0, /* index */
-					 NULL, 0,
-					 KLSI_TIMEOUT);
-		if (rc < 0)
-			    err("Disabling read failed (error = %d)", rc);
-
-		/* shutdown our bulk reads and writes */
-		usb_unlink_urb (port->write_urb);
-		usb_unlink_urb (port->read_urb);
-		/* unlink our write pool */
-		/* FIXME */
-		/* wgg - do I need this? I think so. */
-		usb_unlink_urb (port->interrupt_in_urb);
-		port->active = 0;
-		info("kl5kusb105 port stats: %ld bytes in, %ld bytes out", priv->bytes_in, priv->bytes_out);
-	}
-	
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
+	/* shutdown our bulk reads and writes */
+	usb_unlink_urb (port->write_urb);
+	usb_unlink_urb (port->read_urb);
+	/* unlink our write pool */
+	/* FIXME */
+	/* wgg - do I need this? I think so. */
+	usb_unlink_urb (port->interrupt_in_urb);
+	info("kl5kusb105 port stats: %ld bytes in, %ld bytes out", priv->bytes_in, priv->bytes_out);
 } /* klsi_105_close */
 
 
@@ -538,6 +470,7 @@
  */
 #define KLSI_105_DATA_OFFSET	2   /* in the bulk urb data block */
 
+
 static int klsi_105_write (struct usb_serial_port *port, int from_user,
 			   const unsigned char *buf, int count)
 {
@@ -547,10 +480,7 @@
 	int result, size;
 	int bytes_sent=0;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);	/* to lock against someone else trying to
-				   take an URB we just selected from the pool */
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	while (count > 0) {
 		/* try to find a free urb (write 0 bytes if none) */
@@ -562,21 +492,21 @@
 		for (i=0; i<NUM_URBS; i++) {
 			if (priv->write_urb_pool[i]->status != -EINPROGRESS) {
 				urb = priv->write_urb_pool[i];
-				dbg(__FUNCTION__ " - using pool URB %d", i);
+				dbg("%s - using pool URB %d", __FUNCTION__, i);
 				break;
 			}
 		}
 		spin_unlock_irqrestore (&priv->write_urb_pool_lock, flags);
 
 		if (urb==NULL) {
-			dbg (__FUNCTION__ " - no more free urbs");
+			dbg("%s - no more free urbs", __FUNCTION__);
 			goto exit;
 		}
 
 		if (urb->transfer_buffer == NULL) {
 			urb->transfer_buffer = kmalloc (URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);
 			if (urb->transfer_buffer == NULL) {
-				err(__FUNCTION__ " - no more kernel memory...");
+				err("%s - no more kernel memory...", __FUNCTION__);
 				goto exit;
 			}
 		}
@@ -587,7 +517,6 @@
 		if (from_user) {
 			if (copy_from_user(urb->transfer_buffer
 					   + KLSI_105_DATA_OFFSET, buf, size)) {
-				up (&port->sem);
 				return -EFAULT;
 			}
 		} else {
@@ -613,8 +542,7 @@
 		/* send the data out the bulk port */
 		result = usb_submit_urb(urb);
 		if (result) {
-			err(__FUNCTION__
-			    " - failed submitting write urb, error %d", result);
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 			goto exit;
 		}
 		buf += size;
@@ -622,7 +550,6 @@
 		count -= size;
 	}
 exit:
-	up (&port->sem);
 	priv->bytes_out+=bytes_sent;
 
 	return bytes_sent;	/* that's how much we wrote */
@@ -633,15 +560,15 @@
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct usb_serial *serial = port->serial;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero write bulk status received: %d",
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__,
 		    urb->status);
 		return;
 	}
@@ -673,7 +600,7 @@
 
 	spin_unlock_irqrestore (&priv->write_urb_pool_lock, flags);
 
-	dbg (__FUNCTION__ " - returns %d", chars);
+	dbg("%s - returns %d", __FUNCTION__, chars);
 	return (chars);
 }
 
@@ -694,7 +621,7 @@
 
 	spin_unlock_irqrestore (&priv->write_urb_pool_lock, flags);
 
-	dbg(__FUNCTION__ " - returns %d", room);
+	dbg("%s - returns %d", __FUNCTION__, room);
 	return (room);
 }
 
@@ -710,16 +637,16 @@
 	unsigned char *data = urb->transfer_buffer;
 	int rc;
 
-        dbg(__FUNCTION__ " - port %d", port->number);
+        dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* The urb might have been killed. */
         if (urb->status) {
-                dbg(__FUNCTION__ " - nonzero read bulk status received: %d",
+                dbg("%s - nonzero read bulk status received: %d", __FUNCTION__,
 		    urb->status);
                 return;
         }
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 	
@@ -728,10 +655,10 @@
 	 */
 	if (urb->actual_length == 0) {
 		/* empty urbs seem to happen, we ignore them */
-		/* dbg(__FUNCTION__ " - emtpy URB"); */
+		/* dbg("%s - emtpy URB", __FUNCTION__); */
 	       ;
 	} else if (urb->actual_length <= 2) {
-		dbg(__FUNCTION__ " - size %d URB not understood",
+		dbg("%s - size %d URB not understood", __FUNCTION__,
 		    urb->actual_length);
 		usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 	} else {
@@ -749,9 +676,8 @@
 				       urb->actual_length, data);
 
 		if (bytes_sent + 2 > urb->actual_length) {
-			dbg(__FUNCTION__ 
-			    " - trying to read more data than available"
-			    " (%d vs. %d)",
+			dbg("%s - trying to read more data than available"
+			    " (%d vs. %d)", __FUNCTION__,
 			    bytes_sent+2, urb->actual_length);
 			/* cap at implied limit */
 			bytes_sent = urb->actual_length - 2;
@@ -780,8 +706,7 @@
 		      port);
 	rc = usb_submit_urb(port->read_urb);
 	if (rc)
-		err(__FUNCTION__ 
-		    " - failed resubmitting read urb, error %d", rc);
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, rc);
 } /* klsi_105_read_bulk_callback */
 
 
@@ -801,7 +726,7 @@
 	if( (cflag & CBAUD) != (old_cflag & CBAUD) ) {
 	        /* reassert DTR and (maybe) RTS on transition from B0 */
 		if( (old_cflag & CBAUD) == B0 ) {
-			dbg(__FUNCTION__ ": baud was B0");
+			dbg("%s: baud was B0", __FUNCTION__);
 #if 0
 			priv->control_state |= TIOCM_DTR;
 			/* don't set RTS if using hardware flow control */
@@ -839,7 +764,7 @@
 			break;
 		}
 		if ((cflag & CBAUD) == B0 ) {
-			dbg(__FUNCTION__ ": baud is B0");
+			dbg("%s: baud is B0", __FUNCTION__);
 			/* Drop RTS and DTR */
 			/* maybe this should be simulated by sending read
 			 * disable and read enable messages?
@@ -856,10 +781,10 @@
 		/* set the number of data bits */
 		switch (cflag & CSIZE) {
 		case CS5:
-			dbg(__FUNCTION__ " - 5 bits/byte not supported");
+			dbg("%s - 5 bits/byte not supported", __FUNCTION__);
 			return ;
 		case CS6:
-			dbg(__FUNCTION__ " - 6 bits/byte not supported");
+			dbg("%s - 6 bits/byte not supported", __FUNCTION__);
 			return ;
 		case CS7:
 			priv->cfg.databits = kl5kusb105a_dtb_7;
@@ -930,7 +855,7 @@
 	struct mct_u232_private *priv = (struct mct_u232_private *)port->private;
 	unsigned char lcr = priv->last_lcr;
 
-	dbg (__FUNCTION__ "state=%d", break_state);
+	dbg("%sstate=%d", __FUNCTION__, break_state);
 
 	if (break_state)
 		lcr |= MCT_U232_SET_BREAK;
@@ -946,14 +871,14 @@
 	struct klsi_105_private *priv = (struct klsi_105_private *)port->private;
 	int mask;
 	
-	dbg (__FUNCTION__ "cmd=0x%x", cmd);
+	dbg("%scmd=0x%x", __FUNCTION__, cmd);
 
 	/* Based on code from acm.c and others */
 	switch (cmd) {
 	case TIOCMGET: {
 		int rc;
 		unsigned long line_state;
-		dbg (__FUNCTION__ " - TIOCMGET request, just guessing");
+		dbg("%s - TIOCMGET request, just guessing", __FUNCTION__);
 
 		rc = klsi_105_get_line_state(serial, &line_state);
 		if (rc < 0) {
@@ -962,7 +887,7 @@
 			return -ENOIOCTLCMD;
 		} else {
 			priv->line_state = line_state;
-			dbg(__FUNCTION__ " - read line state 0x%lx", line_state);
+			dbg("%s - read line state 0x%lx", __FUNCTION__, line_state);
 		}
 		return put_user(priv->line_state, (unsigned long *) arg); 
 	       };
@@ -977,10 +902,10 @@
 			/* RTS needs set */
 			if( ((cmd == TIOCMSET) && (mask & TIOCM_RTS)) ||
 			    (cmd == TIOCMBIS) )
-				dbg (__FUNCTION__ " - set RTS not handled");
+				dbg("%s - set RTS not handled", __FUNCTION__);
 				/* priv->control_state |=  TIOCM_RTS; */
 			else
-				dbg (__FUNCTION__ " - clear RTS not handled");
+				dbg("%s - clear RTS not handled", __FUNCTION__);
 				/* priv->control_state &= ~TIOCM_RTS; */
 		}
 
@@ -988,10 +913,10 @@
 			/* DTR needs set */
 			if( ((cmd == TIOCMSET) && (mask & TIOCM_DTR)) ||
 			    (cmd == TIOCMBIS) )
-				dbg (__FUNCTION__ " - set DTR not handled");
+				dbg("%s - set DTR not handled", __FUNCTION__);
 			/*	priv->control_state |=  TIOCM_DTR; */
 			else
-				dbg (__FUNCTION__ " - clear DTR not handled");
+				dbg("%s - clear DTR not handled", __FUNCTION__);
 				/* priv->control_state &= ~TIOCM_DTR; */
 		}
 		/*
@@ -1002,19 +927,19 @@
 	case TIOCMIWAIT:
 		/* wait for any of the 4 modem inputs (DCD,RI,DSR,CTS)*/
 		/* TODO */
-		dbg (__FUNCTION__ " - TIOCMIWAIT not handled");
+		dbg("%s - TIOCMIWAIT not handled", __FUNCTION__);
 		return -ENOIOCTLCMD;
 
 	case TIOCGICOUNT:
 		/* return count of modemline transitions */
 		/* TODO */
-		dbg (__FUNCTION__ " - TIOCGICOUNT not handled");
+		dbg("%s - TIOCGICOUNT not handled", __FUNCTION__);
 		return -ENOIOCTLCMD;
 	case TCGETS: {
 	     /* return current info to caller */
 	     int retval;
 
-	     dbg (__FUNCTION__ " - TCGETS data faked/incomplete");
+	     dbg("%s - TCGETS data faked/incomplete", __FUNCTION__);
 
 	     retval = verify_area(VERIFY_WRITE, (void *)arg,
 				  sizeof(struct termios));
@@ -1030,7 +955,7 @@
 		/* set port termios to the one given by the user */
 		int retval;
 
-		dbg (__FUNCTION__ " - TCSETS not handled");
+		dbg("%s - TCSETS not handled", __FUNCTION__);
 
 		retval = verify_area(VERIFY_READ, (void *)arg,
 				     sizeof(struct termios));
@@ -1056,7 +981,7 @@
 		return -ENOIOCTLCMD;
 		      }
 	default:
-		dbg(__FUNCTION__ ": arg not supported - 0x%04x",cmd);
+		dbg("%s: arg not supported - 0x%04x", __FUNCTION__,cmd);
 		return(-ENOIOCTLCMD);
 		break;
 	}
@@ -1065,41 +990,27 @@
 
 static void klsi_105_throttle (struct usb_serial_port *port)
 {
-
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
-
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	usb_unlink_urb (port->read_urb);
-
-	up (&port->sem);
-
-	return;
 }
+
 static void klsi_105_unthrottle (struct usb_serial_port *port)
 {
 	int result;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	port->read_urb->dev = port->serial->dev;
 	result = usb_submit_urb(port->read_urb);
 	if (result)
-		err(__FUNCTION__ " - failed submitting read urb, error %d",
+		err("%s - failed submitting read urb, error %d", __FUNCTION__,
 		    result);
-
-	up (&port->sem);
-
-	return;
 }
 
 
 
 static int __init klsi_105_init (void)
 {
-	usb_serial_register (&palmconnect_device);
 	usb_serial_register (&kl5kusb105d_device);
 
 	info(DRIVER_DESC " " DRIVER_VERSION);
@@ -1109,7 +1020,6 @@
 
 static void __exit klsi_105_exit (void)
 {
-	usb_serial_deregister (&palmconnect_device);
 	usb_serial_deregister (&kl5kusb105d_device);
 }
 
diff -Nur linux-2.4.19.old/drivers/usb/serial/kl5kusb105.h linux-2.4.19/drivers/usb/serial/kl5kusb105.h
--- linux-2.4.19.old/drivers/usb/serial/kl5kusb105.h	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/serial/kl5kusb105.h	Mon Nov 25 12:27:09 2002
@@ -16,7 +16,7 @@
 
 /* baud rates */
 
-typedef enum {
+enum {
   kl5kusb105a_sio_b115200 = 0,
   kl5kusb105a_sio_b57600  = 1,
   kl5kusb105a_sio_b38400  = 2,
@@ -27,7 +27,7 @@
   kl5kusb105a_sio_b2400   = 9,   /* unchecked */
   kl5kusb105a_sio_b1200   = 0xa,  /* unchecked */
   kl5kusb105a_sio_b600    = 0xb   /* unchecked */
-} KL5KUSB105A_SIO_baudrate_t;
+};
 
 /* data bits */
 #define kl5kusb105a_dtb_7   7
diff -Nur linux-2.4.19.old/drivers/usb/serial/mct_u232.c linux-2.4.19/drivers/usb/serial/mct_u232.c
--- linux-2.4.19.old/drivers/usb/serial/mct_u232.c	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/serial/mct_u232.c	Mon Nov 25 12:27:09 2002
@@ -61,18 +61,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -132,7 +129,7 @@
 /*
  * All of the device info needed for the MCT USB-RS232 converter.
  */
-static __devinitdata struct usb_device_id id_table_combined [] = {
+static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(MCT_U232_VID, MCT_U232_PID) },
 	{ USB_DEVICE(MCT_U232_VID, MCT_U232_SITECOM_PID) },
 	{ USB_DEVICE(MCT_U232_VID, MCT_U232_DU_H3SP_PID) },
@@ -140,99 +137,31 @@
 	{ }		/* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id mct_u232_table [] = {
-        { USB_DEVICE(MCT_U232_VID, MCT_U232_PID) },
-	{ USB_DEVICE(MCT_U232_BELKIN_F5U109_VID, MCT_U232_BELKIN_F5U109_PID) },
-        { }                        /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id mct_u232_sitecom_table [] = {
-        { USB_DEVICE(MCT_U232_VID, MCT_U232_SITECOM_PID) },
-        { }                        /* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id mct_u232_du_h3sp_table [] = {
-        { USB_DEVICE(MCT_U232_VID, MCT_U232_DU_H3SP_PID) },
-        { }                        /* Terminating entry */
-};
-
 MODULE_DEVICE_TABLE (usb, id_table_combined);
 
 
 static struct usb_serial_device_type mct_u232_device = {
-	name:		     "Magic Control Technology USB-RS232",
-	id_table:	     mct_u232_table,
-	needs_interrupt_in:  MUST_HAVE,	 /* 2 interrupt-in endpoints */
-	needs_bulk_in:	     MUST_HAVE_NOT,   /* no bulk-in endpoint */
-	needs_bulk_out:	     MUST_HAVE,	      /* 1 bulk-out endpoint */
-	num_interrupt_in:    2,
-	num_bulk_in:	     0,
-	num_bulk_out:	     1,
-	num_ports:	     1,
-	open:		     mct_u232_open,
-	close:		     mct_u232_close,
+	.owner =	     THIS_MODULE,
+	.name =		     "Magic Control Technology USB-RS232",
+	.id_table =	     id_table_combined,
+	.num_interrupt_in =  2,
+	.num_bulk_in =	     0,
+	.num_bulk_out =	     1,
+	.num_ports =	     1,
+	.open =		     mct_u232_open,
+	.close =	     mct_u232_close,
 #ifdef FIX_WRITE_RETURN_CODE_PROBLEM
-	write:		     mct_u232_write,
-	write_bulk_callback: mct_u232_write_bulk_callback,
+	.write =	     mct_u232_write,
+	.write_bulk_callback = mct_u232_write_bulk_callback,
 #endif
-	read_int_callback:   mct_u232_read_int_callback,
-	ioctl:		     mct_u232_ioctl,
-	set_termios:	     mct_u232_set_termios,
-	break_ctl:	     mct_u232_break_ctl,
-	startup:	     mct_u232_startup,
-	shutdown:	     mct_u232_shutdown,
+	.read_int_callback = mct_u232_read_int_callback,
+	.ioctl =	     mct_u232_ioctl,
+	.set_termios =	     mct_u232_set_termios,
+	.break_ctl =	     mct_u232_break_ctl,
+	.startup =	     mct_u232_startup,
+	.shutdown =	     mct_u232_shutdown,
 };
 
-static struct usb_serial_device_type mct_u232_sitecom_device = {
-	name:		     "MCT/Sitecom USB-RS232",
-	id_table:	     mct_u232_sitecom_table,
-	needs_interrupt_in:  MUST_HAVE,	 /* 2 interrupt-in endpoints */
-	needs_bulk_in:	     MUST_HAVE_NOT,   /* no bulk-in endpoint */
-	needs_bulk_out:	     MUST_HAVE,	      /* 1 bulk-out endpoint */
-	num_interrupt_in:    2,
-	num_bulk_in:	     0,
-	num_bulk_out:	     1,
-	num_ports:	     1,
-	open:		     mct_u232_open,
-	close:		     mct_u232_close,
-#ifdef FIX_WRITE_RETURN_CODE_PROBLEM
-	write:		     mct_u232_write,
-	write_bulk_callback: mct_u232_write_bulk_callback,
-#endif
-	read_int_callback:   mct_u232_read_int_callback,
-	ioctl:		     mct_u232_ioctl,
-	set_termios:	     mct_u232_set_termios,
-	break_ctl:	     mct_u232_break_ctl,
-	startup:	     mct_u232_startup,
-	shutdown:	     mct_u232_shutdown,
-};
-
-static struct usb_serial_device_type mct_u232_du_h3sp_device = {
-        name:                "MCT/D-Link DU-H3SP USB BAY",
-        id_table:            mct_u232_du_h3sp_table,
-        needs_interrupt_in:  MUST_HAVE,  /* 2 interrupt-in endpoints */
-        needs_bulk_in:       MUST_HAVE_NOT,   /* no bulk-in endpoint */
-        needs_bulk_out:      MUST_HAVE,       /* 1 bulk-out endpoint */
-        num_interrupt_in:    2,
-        num_bulk_in:         0,
-        num_bulk_out:        1,
-        num_ports:           1,
-        open:                mct_u232_open,
-        close:               mct_u232_close,
-#ifdef FIX_WRITE_RETURN_CODE_PROBLEM
-        write:               mct_u232_write,
-        write_bulk_callback: mct_u232_write_bulk_callback,
-#endif
-        read_int_callback:   mct_u232_read_int_callback,
-        ioctl:               mct_u232_ioctl,
-        set_termios:         mct_u232_set_termios,
-        break_ctl:           mct_u232_break_ctl,
-        startup:             mct_u232_startup,
-        shutdown:            mct_u232_shutdown,
-};
-
-
-
 
 struct mct_u232_private {
 	unsigned long	     control_state; /* Modem Line Setting (TIOCM) */
@@ -388,13 +317,10 @@
 {
 	int i;
 	
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	/* stop reads and writes on all ports */
 	for (i=0; i < serial->num_ports; ++i) {
-		while (serial->port[i].open_count > 0) {
-			mct_u232_close (&serial->port[i], NULL);
-		}
 		/* My special items, the standard routines free my urbs */
 		if (serial->port[i].private)
 			kfree(serial->port[i].private);
@@ -407,94 +333,72 @@
 	struct mct_u232_private *priv = (struct mct_u232_private *)port->private;
 	int retval = 0;
 
-	dbg(__FUNCTION__" port %d", port->number);
+	dbg("%s port %d", __FUNCTION__, port->number);
 
-	down (&port->sem);
-	
-	++port->open_count;
-	MOD_INC_USE_COUNT;
+	/* Compensate for a hardware bug: although the Sitecom U232-P25
+	 * device reports a maximum output packet size of 32 bytes,
+	 * it seems to be able to accept only 16 bytes (and that's what
+	 * SniffUSB says too...)
+	 */
+	if (serial->dev->descriptor.idProduct == MCT_U232_SITECOM_PID)
+		port->bulk_out_size = 16;
 
-	if (!port->active) {
-		port->active = 1;
-
-		/* Compensate for a hardware bug: although the Sitecom U232-P25
-		 * device reports a maximum output packet size of 32 bytes,
-		 * it seems to be able to accept only 16 bytes (and that's what
-		 * SniffUSB says too...)
-		 */
-		if (serial->dev->descriptor.idProduct == MCT_U232_SITECOM_PID)
-			port->bulk_out_size = 16;
-
-		/* Do a defined restart: the normal serial device seems to 
-		 * always turn on DTR and RTS here, so do the same. I'm not
-		 * sure if this is really necessary. But it should not harm
-		 * either.
-		 */
-		if (port->tty->termios->c_cflag & CBAUD)
-			priv->control_state = TIOCM_DTR | TIOCM_RTS;
-		else
-			priv->control_state = 0;
-		mct_u232_set_modem_ctrl(serial, priv->control_state);
-		
-		priv->last_lcr = (MCT_U232_DATA_BITS_8 | 
-				  MCT_U232_PARITY_NONE |
-				  MCT_U232_STOP_BITS_1);
-		mct_u232_set_line_ctrl(serial, priv->last_lcr);
+	/* Do a defined restart: the normal serial device seems to 
+	 * always turn on DTR and RTS here, so do the same. I'm not
+	 * sure if this is really necessary. But it should not harm
+	 * either.
+	 */
+	if (port->tty->termios->c_cflag & CBAUD)
+		priv->control_state = TIOCM_DTR | TIOCM_RTS;
+	else
+		priv->control_state = 0;
+	mct_u232_set_modem_ctrl(serial, priv->control_state);
+	
+	priv->last_lcr = (MCT_U232_DATA_BITS_8 | 
+			  MCT_U232_PARITY_NONE |
+			  MCT_U232_STOP_BITS_1);
+	mct_u232_set_line_ctrl(serial, priv->last_lcr);
 
-		/* Read modem status and update control state */
-		mct_u232_get_modem_stat(serial, &priv->last_msr);
-		mct_u232_msr_to_state(&priv->control_state, priv->last_msr);
-
-		{
-			/* Puh, that's dirty */
-			struct usb_serial_port *rport;	
-			rport = &serial->port[1];
-			rport->tty = port->tty;
-			rport->private = port->private;
-			port->read_urb = rport->interrupt_in_urb;
-		}
-
-		port->read_urb->dev = port->serial->dev;
-		retval = usb_submit_urb(port->read_urb);
-		if (retval) {
-			err("usb_submit_urb(read bulk) failed");
-			goto exit;
-		}
-
-		port->interrupt_in_urb->dev = port->serial->dev;
-		retval = usb_submit_urb(port->interrupt_in_urb);
-		if (retval)
-			err(" usb_submit_urb(read int) failed");
+	/* Read modem status and update control state */
+	mct_u232_get_modem_stat(serial, &priv->last_msr);
+	mct_u232_msr_to_state(&priv->control_state, priv->last_msr);
 
-	}
+	{
+		/* Puh, that's dirty */
+		struct usb_serial_port *rport;	
+		rport = &serial->port[1];
+		rport->tty = port->tty;
+		rport->private = port->private;
+		port->read_urb = rport->interrupt_in_urb;
+	}
+
+	port->read_urb->dev = port->serial->dev;
+	retval = usb_submit_urb(port->read_urb);
+	if (retval) {
+		err("usb_submit_urb(read bulk) failed");
+		goto exit;
+	}
+
+	port->interrupt_in_urb->dev = port->serial->dev;
+	retval = usb_submit_urb(port->interrupt_in_urb);
+	if (retval)
+		err(" usb_submit_urb(read int) failed");
 
 exit:
-	up (&port->sem);
-	
 	return 0;
 } /* mct_u232_open */
 
 
 static void mct_u232_close (struct usb_serial_port *port, struct file *filp)
 {
-	dbg(__FUNCTION__" port %d", port->number);
-
-	down (&port->sem);
+	dbg("%s port %d", __FUNCTION__, port->number);
 
-	--port->open_count;
-
-	if (port->open_count <= 0) {
-		if (port->serial->dev) {
-			/* shutdown our urbs */
-			usb_unlink_urb (port->write_urb);
-			usb_unlink_urb (port->read_urb);
-			usb_unlink_urb (port->interrupt_in_urb);
-		}
-		port->active = 0;
+	if (port->serial->dev) {
+		/* shutdown our urbs */
+		usb_unlink_urb (port->write_urb);
+		usb_unlink_urb (port->read_urb);
+		usb_unlink_urb (port->interrupt_in_urb);
 	}
-	
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
 } /* mct_u232_close */
 
 
@@ -507,10 +411,10 @@
 	struct usb_serial *serial = port->serial;
 	int result, bytes_sent, size;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (count == 0) {
-		dbg(__FUNCTION__ " - write request of 0 bytes");
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
 		return (0);
 	}
 
@@ -520,22 +424,18 @@
 	
 	/* another write is still pending? */
 	if (port->write_urb->status == -EINPROGRESS) {
-		dbg (__FUNCTION__ " - already writing");
+		dbg("%s - already writing", __FUNCTION__);
 		return (0);
 	}
 		
 	bytes_sent = 0;
 	while (count > 0) {
-		
-		down (&port->sem);
-		
 		size = (count > port->bulk_out_size) ? port->bulk_out_size : count;
 		
 		usb_serial_debug_data (__FILE__, __FUNCTION__, size, buf);
 		
 		if (from_user) {
 			if (copy_from_user(port->write_urb->transfer_buffer, buf, size)) {
-				up (&port->sem);
 				return -EFAULT;
 			}
 		}
@@ -556,14 +456,10 @@
 		/* send the data out the bulk port */
 		result = usb_submit_urb(port->write_urb);
 		if (result) {
-			err(__FUNCTION__
-			    " - failed submitting write urb, error %d", result);
-			up (&port->sem);
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 			return result;
 		}
 
-		up (&port->sem);
-
 		bytes_sent += size;
 		if (write_blocking)
 			interruptible_sleep_on(&port->write_wait);
@@ -583,15 +479,15 @@
 	struct usb_serial *serial = port->serial;
        	struct tty_struct *tty = port->tty;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero write bulk status received: %d",
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__,
 		    urb->status);
 		return;
 	}
@@ -621,16 +517,16 @@
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
 
-        dbg(__FUNCTION__ " - port %d", port->number);
+        dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* The urb might have been killed. */
         if (urb->status) {
-                dbg(__FUNCTION__ " - nonzero read bulk status received: %d",
+                dbg("%s - nonzero read bulk status received: %d", __FUNCTION__,
 		    urb->status);
                 return;
         }
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 	
@@ -707,7 +603,7 @@
 	if( (cflag & CBAUD) != (old_cflag & CBAUD) ) {
 	        /* reassert DTR and (maybe) RTS on transition from B0 */
 		if( (old_cflag & CBAUD) == B0 ) {
-			dbg(__FUNCTION__ ": baud was B0");
+			dbg("%s: baud was B0", __FUNCTION__);
 			priv->control_state |= TIOCM_DTR;
 			/* don't set RTS if using hardware flow control */
 			if (!(old_cflag & CRTSCTS)) {
@@ -743,7 +639,7 @@
 			mct_u232_set_baud_rate(serial, 9600); break;
 		}
 		if ((cflag & CBAUD) == B0 ) {
-			dbg(__FUNCTION__ ": baud is B0");
+			dbg("%s: baud is B0", __FUNCTION__);
 			/* Drop RTS and DTR */
 			priv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);
         		mct_u232_set_modem_ctrl(serial, priv->control_state);
@@ -814,7 +710,7 @@
 	struct mct_u232_private *priv = (struct mct_u232_private *)port->private;
 	unsigned char lcr = priv->last_lcr;
 
-	dbg (__FUNCTION__ "state=%d", break_state);
+	dbg("%sstate=%d", __FUNCTION__, break_state);
 
 	if (break_state)
 		lcr |= MCT_U232_SET_BREAK;
@@ -830,7 +726,7 @@
 	struct mct_u232_private *priv = (struct mct_u232_private *)port->private;
 	int mask;
 	
-	dbg (__FUNCTION__ "cmd=0x%x", cmd);
+	dbg("%scmd=0x%x", __FUNCTION__, cmd);
 
 	/* Based on code from acm.c and others */
 	switch (cmd) {
@@ -875,7 +771,7 @@
 		return 0;
 
 	default:
-		dbg(__FUNCTION__ ": arg not supported - 0x%04x",cmd);
+		dbg("%s: arg not supported - 0x%04x", __FUNCTION__,cmd);
 		return(-ENOIOCTLCMD);
 		break;
 	}
@@ -886,9 +782,7 @@
 static int __init mct_u232_init (void)
 {
 	usb_serial_register (&mct_u232_device);
-	usb_serial_register (&mct_u232_sitecom_device);
-	usb_serial_register (&mct_u232_du_h3sp_device);
-	info(DRIVER_VERSION ":" DRIVER_DESC);
+	info(DRIVER_DESC " " DRIVER_VERSION);
 	return 0;
 }
 
@@ -896,8 +790,6 @@
 static void __exit mct_u232_exit (void)
 {
 	usb_serial_deregister (&mct_u232_device);
-	usb_serial_deregister (&mct_u232_sitecom_device);
-	usb_serial_deregister (&mct_u232_du_h3sp_device);
 }
 
 
diff -Nur linux-2.4.19.old/drivers/usb/serial/omninet.c linux-2.4.19/drivers/usb/serial/omninet.c
--- linux-2.4.19.old/drivers/usb/serial/omninet.c	Fri Dec 21 18:41:55 2001
+++ linux-2.4.19/drivers/usb/serial/omninet.c	Mon Nov 25 12:27:11 2002
@@ -37,18 +37,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -79,7 +76,7 @@
 static int  omninet_write_room		(struct usb_serial_port *port);
 static void omninet_shutdown		(struct usb_serial *serial);
 
-static __devinitdata struct usb_device_id id_table [] = {
+static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(ZYXEL_VENDOR_ID, ZYXEL_OMNINET_ID) },
 	{ }						/* Terminating entry */
 };
@@ -88,22 +85,20 @@
 
 
 static struct usb_serial_device_type zyxel_omninet_device = {
-	name:			"ZyXEL - omni.net lcd plus usb",
-	id_table:		id_table,
-	needs_interrupt_in:	MUST_HAVE,
-	needs_bulk_in:		MUST_HAVE,
-	needs_bulk_out:		MUST_HAVE,
-	num_interrupt_in:	1,
-	num_bulk_in:		1,
-	num_bulk_out:		2,
-	num_ports:		1,
-	open:			omninet_open,
-	close:			omninet_close,
-	write:			omninet_write,
-	write_room:		omninet_write_room,
-	read_bulk_callback:	omninet_read_bulk_callback,
-	write_bulk_callback:	omninet_write_bulk_callback,
-	shutdown:		omninet_shutdown,
+	.owner =		THIS_MODULE,
+	.name =			"ZyXEL - omni.net lcd plus usb",
+	.id_table =		id_table,
+	.num_interrupt_in =	1,
+	.num_bulk_in =		1,
+	.num_bulk_out =		2,
+	.num_ports =		1,
+	.open =			omninet_open,
+	.close =		omninet_close,
+	.write =		omninet_write,
+	.write_room =		omninet_write_room,
+	.read_bulk_callback =	omninet_read_bulk_callback,
+	.write_bulk_callback =	omninet_write_bulk_callback,
+	.shutdown =		omninet_shutdown,
 };
 
 
@@ -153,45 +148,30 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return -ENODEV;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	serial = get_usb_serial (port, __FUNCTION__);
 	if (!serial)
 		return -ENODEV;
 
-	down (&port->sem);
-
-	MOD_INC_USE_COUNT;
-	++port->open_count;
-
-	if (!port->active) {
-		port->active = 1;
-
-		od = kmalloc( sizeof(struct omninet_data), GFP_KERNEL );
-		if( !od ) {
-			err(__FUNCTION__"- kmalloc(%Zd) failed.", sizeof(struct omninet_data));
-			--port->open_count;
-			port->active = 0;
-			up (&port->sem);
-			MOD_DEC_USE_COUNT;
-			return -ENOMEM;
-		}
-
-		port->private = od;
-		wport = &serial->port[1];
-		wport->tty = port->tty;
-
-		/* Start reading from the device */
-		FILL_BULK_URB(port->read_urb, serial->dev, 
-			      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-			      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-			      omninet_read_bulk_callback, port);
-		result = usb_submit_urb(port->read_urb);
-		if (result)
-			err(__FUNCTION__ " - failed submitting read urb, error %d", result);
+	od = kmalloc( sizeof(struct omninet_data), GFP_KERNEL );
+	if( !od ) {
+		err("%s- kmalloc(%Zd) failed.", __FUNCTION__, sizeof(struct omninet_data));
+		return -ENOMEM;
 	}
 
-	up (&port->sem);
+	port->private = od;
+	wport = &serial->port[1];
+	wport->tty = port->tty;
+
+	/* Start reading from the device */
+	FILL_BULK_URB(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
+		      omninet_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb);
+	if (result)
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
 
 	return result;
 }
@@ -205,32 +185,21 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	serial = get_usb_serial (port, __FUNCTION__);
 	if (!serial)
 		return;
 
-	down (&port->sem);
-
-	--port->open_count;
-
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			wport = &serial->port[1];
-			usb_unlink_urb (wport->write_urb);
-			usb_unlink_urb (port->read_urb);
-		}
-
-		port->active = 0;
-		port->open_count = 0;
-		od = (struct omninet_data *)port->private;
-		if (od)
-			kfree(od);
+	if (serial->dev) {
+		wport = &serial->port[1];
+		usb_unlink_urb (wport->write_urb);
+		usb_unlink_urb (port->read_urb);
 	}
 
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
+	od = (struct omninet_data *)port->private;
+	if (od)
+		kfree(od);
 }
 
 
@@ -252,12 +221,12 @@
 //	dbg("omninet_read_bulk_callback");
 
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -285,7 +254,7 @@
 		      omninet_read_bulk_callback, port);
 	result = usb_submit_urb(urb);
 	if (result)
-		err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 
 	return;
 }
@@ -303,11 +272,11 @@
 //	dbg("omninet_write port %d", port->number);
 
 	if (count == 0) {
-		dbg(__FUNCTION__" - write request of 0 bytes");
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
 		return (0);
 	}
 	if (wport->write_urb->status == -EINPROGRESS) {
-		dbg (__FUNCTION__" - already writing");
+		dbg("%s - already writing", __FUNCTION__);
 		return (0);
 	}
 
@@ -336,7 +305,7 @@
 	wport->write_urb->dev = serial->dev;
 	result = usb_submit_urb(wport->write_urb);
 	if (result)
-		err(__FUNCTION__ " - failed submitting write urb, error %d", result);
+		err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 	else
 		result = count;
 
@@ -379,7 +348,7 @@
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__" - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
@@ -394,11 +363,7 @@
 
 static void omninet_shutdown (struct usb_serial *serial)
 {
-	dbg (__FUNCTION__);
-
-	while (serial->port[0].open_count > 0) {
-		omninet_close (&serial->port[0], NULL);
-	}
+	dbg ("%s", __FUNCTION__);
 }
 
 
diff -Nur linux-2.4.19.old/drivers/usb/serial/pl2303.c linux-2.4.19/drivers/usb/serial/pl2303.c
--- linux-2.4.19.old/drivers/usb/serial/pl2303.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/pl2303.c	Mon Nov 25 12:27:11 2002
@@ -1,7 +1,7 @@
 /*
  * Prolific PL2303 USB to serial adaptor driver
  *
- * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001-2002 Greg Kroah-Hartman (greg@kroah.com)
  *
  * Original driver for 2.2.x by anonymous
  *
@@ -32,19 +32,16 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/serial.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -64,11 +61,14 @@
 
 
 
-static __devinitdata struct usb_device_id id_table [] = {
+static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },
+	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },
+	{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID) },
+	{ USB_DEVICE(MA620_VENDOR_ID, MA620_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 
@@ -116,26 +116,24 @@
 
 /* All of the device info needed for the PL2303 SIO serial converter */
 static struct usb_serial_device_type pl2303_device = {
-	name:			"PL-2303",
-	id_table:		id_table,
-	needs_interrupt_in:	DONT_CARE,		/* this device must have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,		/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,		/* this device must have a bulk out endpoint */
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			pl2303_open,
-	close:			pl2303_close,
-	write:			pl2303_write,
-	ioctl:			pl2303_ioctl,
-	break_ctl:		pl2303_break_ctl,
-	set_termios:		pl2303_set_termios,
-	read_bulk_callback:	pl2303_read_bulk_callback,
-	read_int_callback:	pl2303_read_int_callback,
-	write_bulk_callback:	pl2303_write_bulk_callback,
-	startup:		pl2303_startup,
-	shutdown:		pl2303_shutdown,
+	.owner =		THIS_MODULE,
+	.name =			"PL-2303",
+	.id_table =		id_table,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			pl2303_open,
+	.close =		pl2303_close,
+	.write =		pl2303_write,
+	.ioctl =		pl2303_ioctl,
+	.break_ctl =		pl2303_break_ctl,
+	.set_termios =		pl2303_set_termios,
+	.read_bulk_callback =	pl2303_read_bulk_callback,
+	.read_int_callback =	pl2303_read_int_callback,
+	.write_bulk_callback =	pl2303_write_bulk_callback,
+	.startup =		pl2303_startup,
+	.shutdown =		pl2303_shutdown,
 };
 
 struct pl2303_private { 
@@ -166,7 +164,7 @@
 	retval = usb_control_msg (dev, usb_sndctrlpipe (dev, 0),
 				  SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
 				  value, 0, NULL, 0, 100);
-	dbg (__FUNCTION__" - value = %d, retval = %d", value, retval);
+	dbg("%s - value = %d, retval = %d", __FUNCTION__, value, retval);
 	return retval;
 }
 
@@ -174,15 +172,10 @@
 {
 	int result;
 
-	dbg (__FUNCTION__ " - port %d, %d bytes", port->number, count);
-
-	if (!port->tty) {
-		err (__FUNCTION__ " - no tty???");
-		return 0;
-	}
+	dbg("%s - port %d, %d bytes", __FUNCTION__, port->number, count);
 
 	if (port->write_urb->status == -EINPROGRESS) {
-		dbg (__FUNCTION__ " - already writing");
+		dbg("%s - already writing", __FUNCTION__);
 		return 0;
 	}
 
@@ -200,7 +193,7 @@
 	port->write_urb->dev = port->serial->dev;
 	result = usb_submit_urb (port->write_urb);
 	if (result)
-		err(__FUNCTION__ " - failed submitting write urb, error %d", result);
+		err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 	else
 		result = count;
 
@@ -218,15 +211,15 @@
 	int baud;
 	int i;
 
-	dbg (__FUNCTION__ " -  port %d, initialized = %d", port->number, 
+	dbg("%s -  port %d, initialized = %d", __FUNCTION__, port->number, 
 	     ((struct pl2303_private *) port->private)->termios_initialized);
 
 	if ((!port->tty) || (!port->tty->termios)) {
-		dbg(__FUNCTION__" - no tty structures");
+		dbg("%s - no tty structures", __FUNCTION__);
 		return;
 	}
 
-	if (!(((struct pl2303_private *)port->private)->termios_initialized)) {
+	if (!(((struct pl2303_private *) port->private)->termios_initialized)) {
 		*(port->tty->termios) = tty_std_termios;
 		port->tty->termios->c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 		((struct pl2303_private *) port->private)->termios_initialized = 1;
@@ -236,14 +229,14 @@
 	if (old_termios) {
 		if ((cflag == old_termios->c_cflag) &&
 		    (RELEVANT_IFLAG(port->tty->termios->c_iflag) == RELEVANT_IFLAG(old_termios->c_iflag))) {
-		    dbg(__FUNCTION__ " - nothing to change...");
+		    dbg("%s - nothing to change...", __FUNCTION__);
 		    return;
 		}
 	}
 
 	buf = kmalloc (7, GFP_KERNEL);
 	if (!buf) {
-		err(__FUNCTION__ " - out of memory.");
+		err("%s - out of memory.", __FUNCTION__);
 		return;
 	}
 	memset (buf, 0x00, 0x07);
@@ -269,7 +262,7 @@
 			default:
 			case CS8:	buf[6] = 8;	break;
 		}
-		dbg (__FUNCTION__ " - data bits = %d", buf[6]);
+		dbg("%s - data bits = %d", __FUNCTION__, buf[6]);
 	}
 
 	baud = 0;
@@ -294,7 +287,7 @@
 			err ("pl2303 driver does not support the baudrate requested (fix it)");
 			break;
 	}
-	dbg (__FUNCTION__ " - baud = %d", baud);
+	dbg("%s - baud = %d", __FUNCTION__, baud);
 	if (baud) {
 		buf[0] = baud & 0xff;
 		buf[1] = (baud >> 8) & 0xff;
@@ -307,10 +300,10 @@
 	/* For reference buf[4]=2 is 2 stop bits */
 	if (cflag & CSTOPB) {
 		buf[4] = 2;
-		dbg(__FUNCTION__ " - stop bits = 2");
+		dbg("%s - stop bits = 2", __FUNCTION__);
 	} else {
 		buf[4] = 0;
-		dbg(__FUNCTION__ " - stop bits = 1");
+		dbg("%s - stop bits = 1", __FUNCTION__);
 	}
 
 	if (cflag & PARENB) {
@@ -321,14 +314,14 @@
 		/* For reference buf[5]=4 is space parity */
 		if (cflag & PARODD) {
 			buf[5] = 1;
-			dbg(__FUNCTION__ " - parity = odd");
+			dbg("%s - parity = odd", __FUNCTION__);
 		} else {
 			buf[5] = 2;
-			dbg(__FUNCTION__ " - parity = even");
+			dbg("%s - parity = even", __FUNCTION__);
 		}
 	} else {
 		buf[5] = 0;
-		dbg(__FUNCTION__ " - parity = none");
+		dbg("%s - parity = none", __FUNCTION__);
 	}
 
 	i = usb_control_msg (serial->dev, usb_sndctrlpipe (serial->dev, 0),
@@ -355,7 +348,7 @@
 
 	if (cflag & CRTSCTS) {
 		i = usb_control_msg (serial->dev, usb_sndctrlpipe (serial->dev, 0),
-				     VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST_TYPE,
+				     VENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,
 				     0x0, 0x41, NULL, 0, 100);
 		dbg ("0x40:0x1:0x0:0x41  %d", i);
 	}
@@ -374,64 +367,54 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return -ENODEV;
 		
-	dbg (__FUNCTION__ " -  port %d", port->number);
+	dbg("%s -  port %d", __FUNCTION__, port->number);
 
-	down (&port->sem);
+#define FISH(a,b,c,d)								\
+	result=usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev,0),	\
+			       b, a, c, d, buf, 1, 100);			\
+	dbg("0x%x:0x%x:0x%x:0x%x  %d - %x",a,b,c,d,result,buf[0]);
+
+#define SOUP(a,b,c,d)								\
+	result=usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev,0),	\
+			       b, a, c, d, NULL, 0, 100);			\
+	dbg("0x%x:0x%x:0x%x:0x%x  %d",a,b,c,d,result);
+
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 0);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 1);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0, 1);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 1, 0xc0);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 2, 4);
 
-	++port->open_count;
-	MOD_INC_USE_COUNT;
-
-	if (!port->active) {
-		port->active = 1;
-
-#define FISH(a,b,c,d)									\
-		result=usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev,0),	\
-				       b, a, c, d, buf, 1, 100);			\
-		dbg("0x%x:0x%x:0x%x:0x%x  %d - %x",a,b,c,d,result,buf[0]);
-
-#define SOUP(a,b,c,d)									\
-		result=usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev,0),	\
-				       b, a, c, d, NULL, 0, 100);			\
-		dbg("0x%x:0x%x:0x%x:0x%x  %d",a,b,c,d,result);
-
-		FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 0);
-		FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
-		FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
-		FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 1);
-		FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
-		FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0, 1);
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 1, 0xc0);
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 2, 4);
-
-		/* Setup termios */
+	/* Setup termios */
+	if (port->tty) {
 		pl2303_set_termios (port, &tmp_termios);
+	}
 
-		//FIXME: need to assert RTS and DTR if CRTSCTS off
-
-		dbg (__FUNCTION__ " - submitting read urb");
-		port->read_urb->dev = serial->dev;
-		result = usb_submit_urb (port->read_urb);
-		if (result) {
-			err(__FUNCTION__ " - failed submitting read urb, error %d", result);
-			up (&port->sem);
-			pl2303_close (port, NULL);
-			return -EPROTO;
-		}
+	//FIXME: need to assert RTS and DTR if CRTSCTS off
 
-		dbg (__FUNCTION__ " - submitting interrupt urb");
-		port->interrupt_in_urb->dev = serial->dev;
-		result = usb_submit_urb (port->interrupt_in_urb);
-		if (result) {
-			err(__FUNCTION__ " - failed submitting interrupt urb, error %d", result);
-			up (&port->sem);
-			pl2303_close (port, NULL);
-			return -EPROTO;
-		}
+	dbg("%s - submitting read urb", __FUNCTION__);
+	port->read_urb->dev = serial->dev;
+	result = usb_submit_urb (port->read_urb);
+	if (result) {
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+		pl2303_close (port, NULL);
+		return -EPROTO;
+	}
+
+	dbg("%s - submitting interrupt urb", __FUNCTION__);
+	port->interrupt_in_urb->dev = serial->dev;
+	result = usb_submit_urb (port->interrupt_in_urb);
+	if (result) {
+		err("%s - failed submitting interrupt urb, error %d", __FUNCTION__, result);
+		pl2303_close (port, NULL);
+		return -EPROTO;
 	}
-	up (&port->sem);
 	return 0;
 }
 
@@ -449,13 +432,10 @@
 	if (!serial)
 		return;
 	
-	dbg (__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	down (&port->sem);
-
-	--port->open_count;
-	if (port->open_count <= 0) {
-		if (serial->dev) {
+	if (serial->dev) {
+		if (port->tty) {
 			c_cflag = port->tty->termios->c_cflag;
 			if (c_cflag & HUPCL) {
 				/* drop DTR and RTS */
@@ -464,34 +444,28 @@
 				set_control_lines (port->serial->dev,
 						   priv->line_control);
 			}
+		}
 
-			/* shutdown our urbs */
-			dbg (__FUNCTION__ " - shutting down urbs");
-			result = usb_unlink_urb (port->write_urb);
-			if (result)
-				dbg (__FUNCTION__ " - usb_unlink_urb "
-				     "(write_urb) failed with reason: %d",
-				     result);
-
-			result = usb_unlink_urb (port->read_urb);
-			if (result)
-				dbg (__FUNCTION__ " - usb_unlink_urb "
-				     "(read_urb) failed with reason: %d",
-				     result);
+		/* shutdown our urbs */
+		dbg("%s - shutting down urbs", __FUNCTION__);
+		result = usb_unlink_urb (port->write_urb);
+		if (result)
+			dbg("%s - usb_unlink_urb (write_urb)"
+			    " failed with reason: %d", __FUNCTION__,
+			     result);
 
-			result = usb_unlink_urb (port->interrupt_in_urb);
-			if (result)
-				dbg (__FUNCTION__ " - usb_unlink_urb "
-				     "(interrupt_in_urb) failed with reason: %d",
-				     result);
-		}
+		result = usb_unlink_urb (port->read_urb);
+		if (result)
+			dbg("%s - usb_unlink_urb (read_urb) "
+			    "failed with reason: %d", __FUNCTION__,
+			     result);
 
-		port->active = 0;
-		port->open_count = 0;
+		result = usb_unlink_urb (port->interrupt_in_urb);
+		if (result)
+			dbg("%s - usb_unlink_urb (interrupt_in_urb)"
+			    " failed with reason: %d", __FUNCTION__,
+			     result);
 	}
-
-	up (&port->sem);
-	MOD_DEC_USE_COUNT;
 }
 
 static int set_modem_info (struct usb_serial_port *port, unsigned int cmd, unsigned int *value)
@@ -538,7 +512,7 @@
 	result = ((mcr & CONTROL_DTR)		? TIOCM_DTR : 0)
 		  | ((mcr & CONTROL_RTS)	? TIOCM_RTS : 0);
 
-	dbg (__FUNCTION__ " - result = %x", result);
+	dbg("%s - result = %x", __FUNCTION__, result);
 
 	if (copy_to_user(value, &result, sizeof(int)))
 		return -EFAULT;
@@ -547,22 +521,22 @@
 
 static int pl2303_ioctl (struct usb_serial_port *port, struct file *file, unsigned int cmd, unsigned long arg)
 {
-	dbg (__FUNCTION__" (%d) cmd = 0x%04x", port->number, cmd);
+	dbg("%s (%d) cmd = 0x%04x", __FUNCTION__, port->number, cmd);
 
 	switch (cmd) {
 		
 		case TIOCMGET:
-			dbg (__FUNCTION__" (%d) TIOCMGET", port->number);
+			dbg("%s (%d) TIOCMGET", __FUNCTION__, port->number);
 			return get_modem_info (port, (unsigned int *)arg);
 
 		case TIOCMBIS:
 		case TIOCMBIC:
 		case TIOCMSET:
-			dbg(__FUNCTION__" (%d) TIOCMSET/TIOCMBIC/TIOCMSET",  port->number);
+			dbg("%s (%d) TIOCMSET/TIOCMBIC/TIOCMSET", __FUNCTION__,  port->number);
 			return set_modem_info(port, cmd, (unsigned int *) arg);
 
 		default:
-			dbg (__FUNCTION__" not supported = 0x%04x", cmd);
+			dbg("%s not supported = 0x%04x", __FUNCTION__, cmd);
 			break;
 	}
 
@@ -576,19 +550,19 @@
 	u16 state;
 	int result;
 
-	dbg (__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (break_state == 0)
 		state = BREAK_OFF;
 	else
 		state = BREAK_ON;
-	dbg (__FUNCTION__" - turning break %s", state==BREAK_OFF ? "off" : "on");
+	dbg("%s - turning break %s", state==BREAK_OFF ? "off" : "on", __FUNCTION__);
 
 	result = usb_control_msg (serial->dev, usb_rcvctrlpipe (serial->dev, 0),
 				  BREAK_REQUEST, BREAK_REQUEST_TYPE, state, 
 				  0, NULL, 0, 100);
 	if (result)
-		dbg (__FUNCTION__" - error sending break = %d", result);
+		dbg("%s - error sending break = %d", __FUNCTION__, result);
 }
 
 
@@ -596,14 +570,10 @@
 {
 	int i;
 
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	/* stop everything on all ports */
 	for (i = 0; i < serial->num_ports; ++i)
-		while (serial->port[i].open_count > 0) {
-			pl2303_close (&serial->port[i], NULL);
-			kfree (serial->port[i].private);
-		}
+		kfree (serial->port[i].private);
 }
 
 
@@ -646,37 +616,37 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg (__FUNCTION__ " - urb->status = %d", urb->status);
-		if (!port->active) {
-			dbg (__FUNCTION__ " - port is closed, exiting.");
+		dbg("%s - urb->status = %d", __FUNCTION__, urb->status);
+		if (!port->open_count) {
+			dbg("%s - port is closed, exiting.", __FUNCTION__);
 			return;
 		}
 		if (urb->status == -EPROTO) {
 			/* PL2303 mysteriously fails with -EPROTO reschedule the read */
-			dbg (__FUNCTION__ " - caught -EPROTO, resubmitting the urb");
+			dbg("%s - caught -EPROTO, resubmitting the urb", __FUNCTION__);
 			urb->status = 0;
 			urb->dev = serial->dev;
 			result = usb_submit_urb(urb);
 			if (result)
-				err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+				err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 			return;
 		}
-		dbg (__FUNCTION__ " - unable to handle the error, exiting.");
+		dbg("%s - unable to handle the error, exiting.", __FUNCTION__);
 		return;
 	}
 
 	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	tty = port->tty;
-	if (urb->actual_length) {
+	if (tty && urb->actual_length) {
 		for (i = 0; i < urb->actual_length; ++i) {
 			if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
 				tty_flip_buffer_push(tty);
@@ -687,11 +657,11 @@
 	}
 
 	/* Schedule the next read _if_ we are still open */
-	if (port->active) {
+	if (port->open_count) {
 		urb->dev = serial->dev;
 		result = usb_submit_urb(urb);
 		if (result)
-			err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+			err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 	}
 
 	return;
@@ -707,20 +677,20 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (urb->status) {
 		/* error in the urb, so we have to resubmit it */
 		if (serial_paranoia_check (port->serial, __FUNCTION__)) {
 			return;
 		}
-		dbg (__FUNCTION__ " - Overflow in write");
-		dbg (__FUNCTION__ " - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - Overflow in write", __FUNCTION__);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		port->write_urb->transfer_buffer_length = 1;
 		port->write_urb->dev = port->serial->dev;
 		result = usb_submit_urb (port->write_urb);
 		if (result)
-			err(__FUNCTION__ " - failed resubmitting write urb, error %d", result);
+			err("%s - failed resubmitting write urb, error %d", __FUNCTION__, result);
 
 		return;
 	}
diff -Nur linux-2.4.19.old/drivers/usb/serial/pl2303.h linux-2.4.19/drivers/usb/serial/pl2303.h
--- linux-2.4.19.old/drivers/usb/serial/pl2303.h	Wed Oct 10 00:15:02 2001
+++ linux-2.4.19/drivers/usb/serial/pl2303.h	Mon Nov 25 12:27:11 2002
@@ -16,3 +16,12 @@
 
 #define IODATA_VENDOR_ID	0x04bb
 #define IODATA_PRODUCT_ID	0x0a03
+
+#define ELCOM_VENDOR_ID		0x056e
+#define ELCOM_PRODUCT_ID	0x5003
+
+#define ITEGNO_VENDOR_ID	0x0eba
+#define ITEGNO_PRODUCT_ID	0x1080
+
+#define MA620_VENDOR_ID		0x0df7
+#define MA620_PRODUCT_ID	0x0620
diff -Nur linux-2.4.19.old/drivers/usb/serial/usb-serial.h linux-2.4.19/drivers/usb/serial/usb-serial.h
--- linux-2.4.19.old/drivers/usb/serial/usb-serial.h	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/serial/usb-serial.h	Mon Nov 25 12:27:12 2002
@@ -1,7 +1,7 @@
 /*
  * USB Serial Converter driver
  *
- *	Copyright (C) 1999 - 2001
+ *	Copyright (C) 1999 - 2002
  *	    Greg Kroah-Hartman (greg@kroah.com)
  *
  *	This program is free software; you can redistribute it and/or modify
@@ -11,6 +11,10 @@
  *
  * See Documentation/usb/usb-serial.txt for more information on using this driver
  *
+ * (12/03/2001) gkh
+ *	removed active from the port structure.
+ *	added documentation to the usb_serial_device_type structure
+ *
  * (10/10/2001) gkh
  *	added vendor and product to serial structure.  Needed to determine device
  *	owner when the device is disconnected.
@@ -59,13 +63,41 @@
 /* parity check flag */
 #define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
 
-
+/**
+ * usb_serial_port: structure for the specific ports of a device.
+ * @magic: magic number for internal validity of this pointer.
+ * @serial: pointer back to the struct usb_serial owner of this port.
+ * @tty: pointer to the coresponding tty for this port.
+ * @number: the number of the port (the minor number).
+ * @interrupt_in_buffer: pointer to the interrupt in buffer for this port.
+ * @interrupt_in_urb: pointer to the interrupt in struct urb for this port.
+ * @interrupt_in_endpointAddress: endpoint address for the interrupt in pipe
+ *	for this port.
+ * @bulk_in_buffer: pointer to the bulk in buffer for this port.
+ * @read_urb: pointer to the bulk in struct urb for this port.
+ * @bulk_in_endpointAddress: endpoint address for the bulk in pipe for this
+ *	port.
+ * @bulk_out_buffer: pointer to the bulk out buffer for this port.
+ * @bulk_out_size: the size of the bulk_out_buffer, in bytes.
+ * @write_urb: pointer to the bulk out struct urb for this port.
+ * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this
+ *	port.
+ * @write_wait: a wait_queue_head_t used by the port.
+ * @tqueue: task queue for the line discipline waking up.
+ * @open_count: number of times this port has been opened.
+ * @sem: struct semaphore used to lock this structure.
+ * @private: place to put any driver specific information that is needed.  The
+ *	usb-serial driver is required to manage this data, the usb-serial core
+ *	will not touch this.
+ *
+ * This structure is used by the usb-serial core and drivers for the specific
+ * ports of a device.
+ */
 struct usb_serial_port {
 	int			magic;
-	struct usb_serial	*serial;	/* pointer back to the owner of this port */
-	struct tty_struct *	tty;		/* the coresponding tty for this port */
+	struct usb_serial	*serial;
+	struct tty_struct *	tty;
 	unsigned char		number;
-	char			active;		/* someone has this device open */
 
 	unsigned char *		interrupt_in_buffer;
 	struct urb *		interrupt_in_urb;
@@ -81,63 +113,92 @@
 	__u8			bulk_out_endpointAddress;
 
 	wait_queue_head_t	write_wait;
-
-	struct tq_struct	tqueue;		/* task queue for line discipline waking up */
-	int			open_count;	/* number of times this port has been opened */
-	struct semaphore	sem;		/* locks this structure */
-	
-	void *			private;	/* data private to the specific port */
+	struct tq_struct	tqueue;
+	int			open_count;
+	struct semaphore	sem;
+	void *			private;
 };
 
+/**
+ * usb_serial - structure used by the usb-serial core for a device
+ * @magic: magic number for internal validity of this pointer.
+ * @dev: pointer to the struct usb_device for this device
+ * @type: pointer to the struct usb_serial_device_type for this device
+ * @interface: pointer to the struct usb_interface for this device
+ * @minor: the starting minor number for this device
+ * @num_ports: the number of ports this device has
+ * @num_interrupt_in: number of interrupt in endpoints we have
+ * @num_bulk_in: number of bulk in endpoints we have
+ * @num_bulk_out: number of bulk out endpoints we have
+ * @vendor: vendor id of this device
+ * @product: product id of this device
+ * @port: array of struct usb_serial_port structures for the different ports.
+ * @private: place to put any driver specific information that is needed.  The
+ *	usb-serial driver is required to manage this data, the usb-serial core
+ *	will not touch this.
+ */
 struct usb_serial {
 	int				magic;
 	struct usb_device *		dev;
-	struct usb_serial_device_type *	type;			/* the type of usb serial device this is */
-	struct usb_interface *		interface;		/* the interface for this device */
-	struct tty_driver *		tty_driver;		/* the tty_driver for this device */
-	unsigned char			minor;			/* the starting minor number for this device */
-	unsigned char			num_ports;		/* the number of ports this device has */
-	char				num_interrupt_in;	/* number of interrupt in endpoints we have */
-	char				num_bulk_in;		/* number of bulk in endpoints we have */
-	char				num_bulk_out;		/* number of bulk out endpoints we have */
-	__u16				vendor;			/* vendor id of this device */
-	__u16				product;		/* product id of this device */
+	struct usb_serial_device_type *	type;
+	struct usb_interface *		interface;
+	unsigned char			minor;
+	unsigned char			num_ports;
+	char				num_interrupt_in;
+	char				num_bulk_in;
+	char				num_bulk_out;
+	__u16				vendor;
+	__u16				product;
 	struct usb_serial_port		port[MAX_NUM_PORTS];
-
-	void *			private;		/* data private to the specific driver */
+	void *				private;
 };
 
 
-#define MUST_HAVE_NOT	0x01
-#define MUST_HAVE	0x02
-#define DONT_CARE	0x03
-
-#define	HAS		0x02
-#define HAS_NOT		0x01
-
 #define NUM_DONT_CARE	(-1)
 
 
-/* This structure defines the individual serial converter. */
+/**
+ * usb_serial_device_type - a structure that defines a usb serial device
+ * @owner: pointer to the module that owns this device.
+ * @name: pointer to a string that describes this device.  This string used
+ *	in the syslog messages when a device is inserted or removed.
+ * @id_table: pointer to a list of usb_device_id structures that define all
+ *	of the devices this structure can support.
+ * @num_interrupt_in: the number of interrupt in endpoints this device will
+ *	have.
+ * @num_bulk_in: the number of bulk in endpoints this device will have.
+ * @num_bulk_out: the number of bulk out endpoints this device will have.
+ * @num_ports: the number of different ports this device will have.
+ * @calc_num_ports: pointer to a function to determine how many ports this
+ *	device has dynamically.  It will be called after the probe()
+ *	callback is called, but before attach()
+ * @startup: pointer to the driver's startup function.
+ *	This will be called when the device is inserted into the system,
+ *	but before the device has been fully initialized by the usb_serial
+ *	subsystem.  Use this function to download any firmware to the device,
+ *	or any other early initialization that might be needed.
+ *	Return 0 to continue on with the initialization sequence.  Anything 
+ *	else will abort it.
+ * @shutdown: pointer to the driver's shutdown function.  This will be
+ *	called when the device is removed from the system.
+ *
+ * This structure is defines a USB Serial device.  It provides all of
+ * the information that the USB serial core code needs.  If the function
+ * pointers are defined, then the USB serial core code will call them when
+ * the corresponding tty port functions are called.  If they are not
+ * called, the generic serial function will be used instead.
+ */
 struct usb_serial_device_type {
+	struct module *owner;
 	char	*name;
 	const struct usb_device_id *id_table;
-	char	needs_interrupt_in;
-	char	needs_bulk_in;
-	char	needs_bulk_out;
 	char	num_interrupt_in;
 	char	num_bulk_in;
 	char	num_bulk_out;
-	char	num_ports;		/* number of serial ports this device has */
+	char	num_ports;
 
 	struct list_head	driver_list;
 	
-	/* function call to make before accepting driver
-	 * return 0 to continue initialization,
-	 * < 0 aborts startup,
-	 * > 0 does not set up anything else and is useful for devices that have
-	 * downloaded firmware, and will reset themselves shortly.
-	 */
 	int (*startup) (struct usb_serial *serial);
 	
 	void (*shutdown) (struct usb_serial *serial);
diff -Nur linux-2.4.19.old/drivers/usb/serial/usbserial.c linux-2.4.19/drivers/usb/serial/usbserial.c
--- linux-2.4.19.old/drivers/usb/serial/usbserial.c	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/serial/usbserial.c	Mon Nov 25 12:27:12 2002
@@ -1,14 +1,13 @@
 /*
  * USB Serial Converter driver
  *
- * Copyright (C) 1999 - 2001 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 1999 - 2002 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (c) 2000 Peter Berger (pberger@brimson.com)
  * Copyright (c) 2000 Al Borchers (borchers@steinerpoint.com)
  *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License version
+ *	2 as published by the Free Software Foundation.
  *
  * This driver was originally based on the ACM driver by Armin Fuerst (which was 
  * based on a driver by Brad Keryan)
@@ -337,24 +336,15 @@
 
 /* All of the device info needed for the Generic Serial Converter */
 static struct usb_serial_device_type generic_device = {
-	name:			"Generic",
-	id_table:		generic_device_ids,
-	needs_interrupt_in:	DONT_CARE,		/* don't have to have an interrupt in endpoint */
-	needs_bulk_in:		DONT_CARE,		/* don't have to have a bulk in endpoint */
-	needs_bulk_out:		DONT_CARE,		/* don't have to have a bulk out endpoint */
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		1,
-	shutdown:		generic_shutdown,
+	.owner =		THIS_MODULE,
+	.name =			"Generic",
+	.id_table =		generic_device_ids,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		NUM_DONT_CARE,
+	.num_bulk_out =		NUM_DONT_CARE,
+	.num_ports =		1,
+	.shutdown =		generic_shutdown,
 };
-
-#define if_generic_do(x)			\
-	if ((serial->vendor == vendor) &&	\
-	    (serial->product == product))	\
-	                x
-#else
-#define if_generic_do(x)
 #endif
 
 
@@ -375,10 +365,10 @@
 static void usb_serial_disconnect(struct usb_device *dev, void *ptr);
 
 static struct usb_driver usb_serial_driver = {
-	name:		"serial",
-	probe:		usb_serial_probe,
-	disconnect:	usb_serial_disconnect,
-	id_table:	NULL, 			/* check all devices */
+	.name =		"serial",
+	.probe =	usb_serial_probe,
+	.disconnect =	usb_serial_disconnect,
+	.id_table =	NULL, 			/* check all devices */
 };
 
 /* There is no MODULE_DEVICE_TABLE for usbserial.c.  Instead
@@ -387,7 +377,7 @@
    via modprobe, and modprobe will load usbserial because the serial
    drivers depend on it.
 */
-   
+
 
 static int			serial_refcount;
 static struct tty_driver	serial_tty_driver;
@@ -400,7 +390,7 @@
 static LIST_HEAD(usb_serial_driver_list);
 
 
-static struct usb_serial *get_serial_by_minor (int minor)
+static struct usb_serial *get_serial_by_minor (unsigned int minor)
 {
 	return serial_table[minor];
 }
@@ -412,7 +402,7 @@
 	int i, j;
 	int good_spot;
 
-	dbg(__FUNCTION__ " %d", num_ports);
+	dbg("%s %d", __FUNCTION__, num_ports);
 
 	*minor = 0;
 	for (i = 0; i < SERIAL_TTY_MINORS; ++i) {
@@ -427,14 +417,14 @@
 			continue;
 			
 		if (!(serial = kmalloc(sizeof(struct usb_serial), GFP_KERNEL))) {
-			err(__FUNCTION__ " - Out of memory");
+			err("%s - Out of memory", __FUNCTION__);
 			return NULL;
 		}
 		memset(serial, 0, sizeof(struct usb_serial));
 		serial->magic = USB_SERIAL_MAGIC;
 		serial_table[i] = serial;
 		*minor = i;
-		dbg(__FUNCTION__ " - minor base = %d", *minor);
+		dbg("%s - minor base = %d", __FUNCTION__, *minor);
 		for (i = *minor+1; (i < (*minor + num_ports)) && (i < SERIAL_TTY_MINORS); ++i)
 			serial_table[i] = serial;
 		return serial;
@@ -442,12 +432,11 @@
 	return NULL;
 }
 
-
 static void return_serial (struct usb_serial *serial)
 {
 	int i;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (serial == NULL)
 		return;
@@ -459,7 +448,6 @@
 	return;
 }
 
-
 #ifdef USES_EZUSB_FUNCTIONS
 /* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */
 #define CPUCS_REG    0x7F92
@@ -471,36 +459,34 @@
 
 	/* dbg("ezusb_writememory %x, %d", address, length); */
 	if (!serial->dev) {
-		dbg(__FUNCTION__ " - no physical device present, failing.");
+		dbg("%s - no physical device present, failing.", __FUNCTION__);
 		return -ENODEV;
 	}
 
 	transfer_buffer =  kmalloc (length, GFP_KERNEL);
 	if (!transfer_buffer) {
-		err(__FUNCTION__ " - kmalloc(%d) failed.", length);
+		err("%s - kmalloc(%d) failed.", __FUNCTION__, length);
 		return -ENOMEM;
 	}
 	memcpy (transfer_buffer, data, length);
-	result = usb_control_msg (serial->dev, usb_sndctrlpipe(serial->dev, 0), bRequest, 0x40, address, 0, transfer_buffer, length, 300);
+	result = usb_control_msg (serial->dev, usb_sndctrlpipe(serial->dev, 0), bRequest, 0x40, address, 0, transfer_buffer, length, 3*HZ);
 	kfree (transfer_buffer);
 	return result;
 }
 
-
 int ezusb_set_reset (struct usb_serial *serial, unsigned char reset_bit)
 {
 	int	response;
-	dbg(__FUNCTION__ " - %d", reset_bit);
+	dbg("%s - %d", __FUNCTION__, reset_bit);
 	response = ezusb_writememory (serial, CPUCS_REG, &reset_bit, 1, 0xa0);
 	if (response < 0) {
-		err(__FUNCTION__ "- %d failed", reset_bit);
+		err("%s- %d failed", __FUNCTION__, reset_bit);
 	}
 	return response;
 }
 
 #endif	/* USES_EZUSB_FUNCTIONS */
 
-
 /*****************************************************************************
  * Driver tty interface functions
  *****************************************************************************/
@@ -508,9 +494,10 @@
 {
 	struct usb_serial *serial;
 	struct usb_serial_port *port;
-	int portNumber;
+	unsigned int portNumber;
+	int retval = 0;
 	
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	/* initialize the pointer incase something fails */
 	tty->driver_data = NULL;
@@ -518,257 +505,350 @@
 	/* get the serial object associated with this tty pointer */
 	serial = get_serial_by_minor (MINOR(tty->device));
 
-	if (serial_paranoia_check (serial, __FUNCTION__)) {
+	if (serial_paranoia_check (serial, __FUNCTION__))
 		return -ENODEV;
-	}
 
 	/* set up our port structure making the tty driver remember our port object, and us it */
 	portNumber = MINOR(tty->device) - serial->minor;
 	port = &serial->port[portNumber];
 	tty->driver_data = port;
+
+	down (&port->sem);
 	port->tty = tty;
 	 
-	/* pass on to the driver specific version of this function if it is available */
-	if (serial->type->open) {
-		return (serial->type->open(port, filp));
-	} else {
-		return (generic_open(port, filp));
+	/* lock this module before we call it */
+	if (serial->type->owner)
+		__MOD_INC_USE_COUNT(serial->type->owner);
+
+	++port->open_count;
+	if (port->open_count == 1) {
+		/* only call the device specific open if this 
+		 * is the first time the port is opened */
+		if (serial->type->open)
+			retval = serial->type->open(port, filp);
+		else
+			retval = generic_open(port, filp);
 	}
+
+	if (retval) {
+		port->open_count = 0;
+		if (serial->type->owner)
+			__MOD_DEC_USE_COUNT(serial->type->owner);
+	}
+
+	up (&port->sem);
+	return retval;
 }
 
+static void __serial_close(struct usb_serial_port *port, struct file *filp)
+{
+	if (!port->open_count) {
+		dbg ("%s - port not opened", __FUNCTION__);
+		return;
+	}
+
+	--port->open_count;
+	if (port->open_count <= 0) {
+		/* only call the device specific close if this 
+		 * port is being closed by the last owner */
+		if (port->serial->type->close)
+			port->serial->type->close(port, filp);
+		else
+			generic_close(port, filp);
+		port->open_count = 0;
+	}
+
+	if (port->serial->type->owner)
+		__MOD_DEC_USE_COUNT(port->serial->type->owner);
+}
 
 static void serial_close(struct tty_struct *tty, struct file * filp)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
-	if (!serial) {
+	if (!serial)
 		return;
-	}
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-	
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not opened");
-		return;
-	}
+	down (&port->sem);
 
-	/* pass on to the driver specific version of this function if it is available */
-	if (serial->type->close) {
-		serial->type->close(port, filp);
-	} else {
-		generic_close(port, filp);
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	/* if disconnect beat us to the punch here, there's nothing to do */
+	if (tty->driver_data) {
+		__serial_close(port, filp);
 	}
-}	
 
+	up (&port->sem);
+}
 
 static int serial_write (struct tty_struct * tty, int from_user, const unsigned char *buf, int count)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
-	
-	if (!serial) {
+	int retval = -EINVAL;
+
+	if (!serial)
 		return -ENODEV;
-	}
-	
-	dbg(__FUNCTION__ " - port %d, %d byte(s)", port->number, count);
 
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not opened");
-		return -EINVAL;
+	down (&port->sem);
+
+	dbg("%s - port %d, %d byte(s)", __FUNCTION__, port->number, count);
+
+	if (!port->open_count) {
+		dbg("%s - port not opened", __FUNCTION__);
+		goto exit;
 	}
-	
+
 	/* pass on to the driver specific version of this function if it is available */
-	if (serial->type->write) {
-		return (serial->type->write(port, from_user, buf, count));
-	} else {
-		return (generic_write(port, from_user, buf, count));
-	}
-}
+	if (serial->type->write)
+		retval = serial->type->write(port, from_user, buf, count);
+	else
+		retval = generic_write(port, from_user, buf, count);
 
+exit:
+	up (&port->sem);
+	return retval;
+}
 
 static int serial_write_room (struct tty_struct *tty) 
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+	int retval = -EINVAL;
 
-	if (!serial) {
+	if (!serial)
 		return -ENODEV;
-	}
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-	
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not open");
-		return -EINVAL;
+	down (&port->sem);
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (!port->open_count) {
+		dbg("%s - port not open", __FUNCTION__);
+		goto exit;
 	}
 
 	/* pass on to the driver specific version of this function if it is available */
-	if (serial->type->write_room) {
-		return (serial->type->write_room(port));
-	} else {
-		return (generic_write_room(port));
-	}
-}
+	if (serial->type->write_room)
+		retval = serial->type->write_room(port);
+	else
+		retval = generic_write_room(port);
 
+exit:
+	up (&port->sem);
+	return retval;
+}
 
 static int serial_chars_in_buffer (struct tty_struct *tty) 
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+	int retval = -EINVAL;
 
-	if (!serial) {
+	if (!serial)
 		return -ENODEV;
-	}
 
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not open");
-		return -EINVAL;
+	down (&port->sem);
+
+	dbg("%s = port %d", __FUNCTION__, port->number);
+
+	if (!port->open_count) {
+		dbg("%s - port not open", __FUNCTION__);
+		goto exit;
 	}
 
 	/* pass on to the driver specific version of this function if it is available */
-	if (serial->type->chars_in_buffer) {
-		return (serial->type->chars_in_buffer(port));
-	} else {
-		return (generic_chars_in_buffer(port));
-	}
-}
+	if (serial->type->chars_in_buffer)
+		retval = serial->type->chars_in_buffer(port);
+	else
+		retval = generic_chars_in_buffer(port);
 
+exit:
+	up (&port->sem);
+	return retval;
+}
 
 static void serial_throttle (struct tty_struct * tty)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
-	if (!serial) {
+	if (!serial)
 		return;
-	}
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	down (&port->sem);
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not open");
-		return;
+	if (!port->open_count) {
+		dbg ("%s - port not open", __FUNCTION__);
+		goto exit;
 	}
 
 	/* pass on to the driver specific version of this function */
-	if (serial->type->throttle) {
+	if (serial->type->throttle)
 		serial->type->throttle(port);
-	}
 
-	return;
+exit:
+	up (&port->sem);
 }
 
-
 static void serial_unthrottle (struct tty_struct * tty)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
-	if (!serial) {
+	if (!serial)
 		return;
-	}
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	down (&port->sem);
 
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not open");
-		return;
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (!port->open_count) {
+		dbg("%s - port not open", __FUNCTION__);
+		goto exit;
 	}
 
 	/* pass on to the driver specific version of this function */
-	if (serial->type->unthrottle) {
+	if (serial->type->unthrottle)
 		serial->type->unthrottle(port);
-	}
 
-	return;
+exit:
+	up (&port->sem);
 }
 
-
 static int serial_ioctl (struct tty_struct *tty, struct file * file, unsigned int cmd, unsigned long arg)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+	int retval = -ENODEV;
 
-	if (!serial) {
+	if (!serial)
 		return -ENODEV;
-	}
 
-	dbg(__FUNCTION__ " - port %d, cmd 0x%.4x", port->number, cmd);
+	down (&port->sem);
 
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not open");
-		return -ENODEV;
+	dbg("%s - port %d, cmd 0x%.4x", __FUNCTION__, port->number, cmd);
+
+	if (!port->open_count) {
+		dbg ("%s - port not open", __FUNCTION__);
+		goto exit;
 	}
 
 	/* pass on to the driver specific version of this function if it is available */
-	if (serial->type->ioctl) {
-		return (serial->type->ioctl(port, file, cmd, arg));
-	} else {
-		return -ENOIOCTLCMD;
-	}
-}
+	if (serial->type->ioctl)
+		retval = serial->type->ioctl(port, file, cmd, arg);
+	else
+		retval = -ENOIOCTLCMD;
 
+exit:
+	up (&port->sem);
+	return retval;
+}
 
 static void serial_set_termios (struct tty_struct *tty, struct termios * old)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
-	if (!serial) {
+	if (!serial)
 		return;
-	}
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	down (&port->sem);
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not open");
-		return;
+	if (!port->open_count) {
+		dbg("%s - port not open", __FUNCTION__);
+		goto exit;
 	}
 
 	/* pass on to the driver specific version of this function if it is available */
-	if (serial->type->set_termios) {
+	if (serial->type->set_termios)
 		serial->type->set_termios(port, old);
-	}
-	
-	return;
-}
 
+exit:
+	up (&port->sem);
+}
 
 static void serial_break (struct tty_struct *tty, int break_state)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
-	if (!serial) {
+	if (!serial)
 		return;
-	}
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	down (&port->sem);
 
-	if (!port->active) {
-		dbg (__FUNCTION__ " - port not open");
-		return;
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (!port->open_count) {
+		dbg("%s - port not open", __FUNCTION__);
+		goto exit;
 	}
 
-	/* pass on to the driver specific version of this function if it is
-           available */
-	if (serial->type->break_ctl) {
+	/* pass on to the driver specific version of this function if it is available */
+	if (serial->type->break_ctl)
 		serial->type->break_ctl(port, break_state);
-	}
-}
 
+exit:
+	up (&port->sem);
+}
 
 static void serial_shutdown (struct usb_serial *serial)
 {
-	if (serial->type->shutdown) {
+	dbg ("%s", __FUNCTION__);
+
+	if (serial->type->shutdown)
 		serial->type->shutdown(serial);
-	} else {
+	else
 		generic_shutdown(serial);
-	}
 }
 
+static int serial_read_proc (char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	struct usb_serial *serial;
+	int length = 0;
+	int i;
+	off_t begin = 0;
+	char tmp[40];
+
+	dbg("%s", __FUNCTION__);
+	length += sprintf (page, "usbserinfo:1.0 driver:%s\n", DRIVER_VERSION);
+	for (i = 0; i < SERIAL_TTY_MINORS && length < PAGE_SIZE; ++i) {
+		serial = get_serial_by_minor(i);
+		if (serial == NULL)
+			continue;
 
+		length += sprintf (page+length, "%d:", i);
+		if (serial->type->owner)
+			length += sprintf (page+length, " module:%s", serial->type->owner->name);
+		length += sprintf (page+length, " name:\"%s\"", serial->type->name);
+		length += sprintf (page+length, " vendor:%04x product:%04x", serial->vendor, serial->product);
+		length += sprintf (page+length, " num_ports:%d", serial->num_ports);
+		length += sprintf (page+length, " port:%d", i - serial->minor + 1);
+
+		usb_make_path(serial->dev, tmp, sizeof(tmp));
+		length += sprintf (page+length, " path:%s", tmp);
+			
+		length += sprintf (page+length, "\n");
+		if ((length + begin) > (off + count))
+			goto done;
+		if ((length + begin) < off) {
+			begin += length;
+			length = 0;
+		}
+	}
+	*eof = 1;
+done:
+	if (off >= (length + begin))
+		return 0;
+	*start = page + (off-begin);
+	return ((count < begin+length-off) ? count : begin+length-off);
+}
 
 /*****************************************************************************
  * generic devices specific driver functions
@@ -781,91 +861,70 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return -ENODEV;
 
-	/* only increment our usage count, if this device is _really_ a generic device */
-	if_generic_do(MOD_INC_USE_COUNT);
-
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
-	
-	++port->open_count;
-	
-	if (!port->active) {
-		port->active = 1;
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-		/* force low_latency on so that our tty_push actually forces the data through, 
-		   otherwise it is scheduled, and with high data rates (like with OHCI) data
-		   can get lost. */
+	/* force low_latency on so that our tty_push actually forces the data through, 
+	   otherwise it is scheduled, and with high data rates (like with OHCI) data
+	   can get lost. */
+	if (port->tty)
 		port->tty->low_latency = 1;
-		
-		/* if we have a bulk interrupt, start reading from it */
-		if (serial->num_bulk_in) {
-			/* Start reading from the device */
-			FILL_BULK_URB(port->read_urb, serial->dev, 
-				      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-				      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-				      ((serial->type->read_bulk_callback) ?
-				       serial->type->read_bulk_callback :
-				       generic_read_bulk_callback), 
-				      port);
-			result = usb_submit_urb(port->read_urb);
-			if (result)
-				err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
-		}
+
+	/* if we have a bulk interrupt, start reading from it */
+	if (serial->num_bulk_in) {
+		/* Start reading from the device */
+		usb_fill_bulk_urb (port->read_urb, serial->dev,
+				   usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+				   port->read_urb->transfer_buffer,
+				   port->read_urb->transfer_buffer_length,
+				   ((serial->type->read_bulk_callback) ?
+				     serial->type->read_bulk_callback :
+				     generic_read_bulk_callback),
+				   port);
+		result = usb_submit_urb(port->read_urb);
+		if (result)
+			err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 	}
-	
-	up (&port->sem);
-	
+
 	return result;
 }
 
-
-static void generic_close (struct usb_serial_port *port, struct file * filp)
+static void generic_cleanup (struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port->serial;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
-
-	--port->open_count;
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			/* shutdown any bulk reads that might be going on */
-			if (serial->num_bulk_out)
-				usb_unlink_urb (port->write_urb);
-			if (serial->num_bulk_in)
-				usb_unlink_urb (port->read_urb);
-		}
-		
-		port->active = 0;
-		port->open_count = 0;
+	if (serial->dev) {
+		/* shutdown any bulk reads that might be going on */
+		if (serial->num_bulk_out)
+			usb_unlink_urb (port->write_urb);
+		if (serial->num_bulk_in)
+			usb_unlink_urb (port->read_urb);
 	}
-
-	up (&port->sem);
-
-	/* only decrement our usage count, if this device is _really_ a generic device */
-	if_generic_do(MOD_DEC_USE_COUNT);
 }
 
+static void generic_close (struct usb_serial_port *port, struct file * filp)
+{
+	dbg("%s - port %d", __FUNCTION__, port->number);
+	generic_cleanup (port);
+}
 
 static int generic_write (struct usb_serial_port *port, int from_user, const unsigned char *buf, int count)
 {
 	struct usb_serial *serial = port->serial;
 	int result;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (count == 0) {
-		dbg(__FUNCTION__ " - write request of 0 bytes");
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
 		return (0);
 	}
 
 	/* only do something if we have a bulk out endpoint */
 	if (serial->num_bulk_out) {
 		if (port->write_urb->status == -EINPROGRESS) {
-			dbg (__FUNCTION__ " - already writing");
+			dbg("%s - already writing", __FUNCTION__);
 			return (0);
 		}
 
@@ -877,68 +936,65 @@
 		}
 		else {
 			memcpy (port->write_urb->transfer_buffer, buf, count);
-		}  
+		}
 
 		usb_serial_debug_data (__FILE__, __FUNCTION__, count, port->write_urb->transfer_buffer);
 
 		/* set up our urb */
-		FILL_BULK_URB(port->write_urb, serial->dev, 
-			      usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress),
-			      port->write_urb->transfer_buffer, count,
-			      ((serial->type->write_bulk_callback) ? 
-			       serial->type->write_bulk_callback : 
-			       generic_write_bulk_callback), 
-			      port);
+		usb_fill_bulk_urb (port->write_urb, serial->dev,
+				   usb_sndbulkpipe (serial->dev,
+						    port->bulk_out_endpointAddress),
+				   port->write_urb->transfer_buffer, count,
+				   ((serial->type->write_bulk_callback) ? 
+				     serial->type->write_bulk_callback :
+				     generic_write_bulk_callback), port);
 
 		/* send the data out the bulk port */
 		result = usb_submit_urb(port->write_urb);
 		if (result)
-			err(__FUNCTION__ " - failed submitting write urb, error %d", result);
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 		else
 			result = count;
 
 		return result;
 	}
-	
+
 	/* no bulk out, so return 0 bytes written */
 	return (0);
-} 
-
+}
 
 static int generic_write_room (struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port->serial;
 	int room = 0;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (serial->num_bulk_out) {
 		if (port->write_urb->status != -EINPROGRESS)
 			room = port->bulk_out_size;
 	}
-	
-	dbg(__FUNCTION__ " - returns %d", room);
+
+	dbg("%s - returns %d", __FUNCTION__, room);
 	return (room);
 }
 
-
 static int generic_chars_in_buffer (struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port->serial;
 	int chars = 0;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-	
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
 	if (serial->num_bulk_out) {
 		if (port->write_urb->status == -EINPROGRESS)
 			chars = port->write_urb->transfer_buffer_length;
 	}
 
-	dbg (__FUNCTION__ " - returns %d", chars);
+	dbg("%s - returns %d", __FUNCTION__, chars);
 	return (chars);
 }
 
-
 static void generic_read_bulk_callback (struct urb *urb)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
@@ -948,22 +1004,22 @@
 	int i;
 	int result;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-	
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
 	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	tty = port->tty;
-	if (urb->actual_length) {
+	if (tty && urb->actual_length) {
 		for (i = 0; i < urb->actual_length ; ++i) {
 			/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
 			if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
@@ -976,73 +1032,71 @@
 	}
 
 	/* Continue trying to always read  */
-	FILL_BULK_URB(port->read_urb, serial->dev, 
-		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-		      ((serial->type->read_bulk_callback) ?
-		       serial->type->read_bulk_callback :
-		       generic_read_bulk_callback), 
-		      port);
+	usb_fill_bulk_urb (port->read_urb, serial->dev,
+			   usb_rcvbulkpipe (serial->dev,
+				   	    port->bulk_in_endpointAddress),
+			   port->read_urb->transfer_buffer,
+			   port->read_urb->transfer_buffer_length,
+			   ((serial->type->read_bulk_callback) ? 
+			     serial->type->read_bulk_callback : 
+			     generic_read_bulk_callback), port);
 	result = usb_submit_urb(port->read_urb);
 	if (result)
-		err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 }
 
-
 static void generic_write_bulk_callback (struct urb *urb)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-	
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
 	queue_task(&port->tqueue, &tq_immediate);
 	mark_bh(IMMEDIATE_BH);
-	
+
 	return;
 }
 
-
 static void generic_shutdown (struct usb_serial *serial)
 {
 	int i;
 
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	/* stop reads and writes on all ports */
 	for (i=0; i < serial->num_ports; ++i) {
-		while (serial->port[i].open_count > 0) {
-			generic_close (&serial->port[i], NULL);
-		}
+		generic_cleanup (&serial->port[i]);
 	}
 }
 
-
 static void port_softint(void *private)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)private;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct *tty;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
-	if (!serial) {
+	if (!serial)
 		return;
-	}
- 	
+
 	tty = port->tty;
+	if (!tty)
+		return;
+
 	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
-		dbg(__FUNCTION__ " - write wakeup call.");
+		dbg("%s - write wakeup call.", __FUNCTION__);
 		(tty->ldisc.write_wakeup)(tty);
 	}
 
@@ -1068,9 +1122,6 @@
 	int minor;
 	int buffer_size;
 	int i;
-	char interrupt_pipe;
-	char bulk_in_pipe;
-	char bulk_out_pipe;
 	int num_interrupt_in = 0;
 	int num_bulk_in = 0;
 	int num_bulk_out = 0;
@@ -1078,7 +1129,6 @@
 	int max_endpoints;
 	const struct usb_device_id *id_pattern = NULL;
 
-	
 	/* loop through our list of known serial converters, and see if this
 	   device matches. */
 	found = 0;
@@ -1099,8 +1149,6 @@
 	}
 	
 	/* descriptor matches, let's find the endpoints needed */
-	interrupt_pipe = bulk_in_pipe = bulk_out_pipe = HAS_NOT;
-			
 	/* check out the endpoints */
 	iface_desc = &interface->altsetting[0];
 	for (i = 0; i < iface_desc->bNumEndpoints; ++i) {
@@ -1110,7 +1158,6 @@
 		    ((endpoint->bmAttributes & 3) == 0x02)) {
 			/* we found a bulk in endpoint */
 			dbg("found bulk in");
-			bulk_in_pipe = HAS;
 			bulk_in_endpoint[num_bulk_in] = endpoint;
 			++num_bulk_in;
 		}
@@ -1119,7 +1166,6 @@
 		    ((endpoint->bmAttributes & 3) == 0x02)) {
 			/* we found a bulk out endpoint */
 			dbg("found bulk out");
-			bulk_out_pipe = HAS;
 			bulk_out_endpoint[num_bulk_out] = endpoint;
 			++num_bulk_out;
 		}
@@ -1128,20 +1174,19 @@
 		    ((endpoint->bmAttributes & 3) == 0x03)) {
 			/* we found a interrupt in endpoint */
 			dbg("found interrupt in");
-			interrupt_pipe = HAS;
 			interrupt_in_endpoint[num_interrupt_in] = endpoint;
 			++num_interrupt_in;
 		}
 	}
-	
+
 #if defined(CONFIG_USB_SERIAL_PL2303) || defined(CONFIG_USB_SERIAL_PL2303_MODULE)
 	/* BEGIN HORRIBLE HACK FOR PL2303 */ 
 	/* this is needed due to the looney way its endpoints are set up */
-	if (ifnum == 1) {
-		if (((dev->descriptor.idVendor == PL2303_VENDOR_ID) &&
-		     (dev->descriptor.idProduct == PL2303_PRODUCT_ID)) ||
-		    ((dev->descriptor.idVendor == ATEN_VENDOR_ID) &&
-		     (dev->descriptor.idProduct == ATEN_PRODUCT_ID))) {
+	if (((dev->descriptor.idVendor == PL2303_VENDOR_ID) &&
+	     (dev->descriptor.idProduct == PL2303_PRODUCT_ID)) ||
+	    ((dev->descriptor.idVendor == ATEN_VENDOR_ID) &&
+	     (dev->descriptor.idProduct == ATEN_PRODUCT_ID))) {
+		if (ifnum == 1) {
 			/* check out the endpoints of the other interface*/
 			interface = &dev->actconfig->interface[ifnum ^ 1];
 			iface_desc = &interface->altsetting[0];
@@ -1151,24 +1196,23 @@
 				    ((endpoint->bmAttributes & 3) == 0x03)) {
 					/* we found a interrupt in endpoint */
 					dbg("found interrupt in for Prolific device on separate interface");
-					interrupt_pipe = HAS;
 					interrupt_in_endpoint[num_interrupt_in] = endpoint;
 					++num_interrupt_in;
 				}
 			}
 		}
+
+		/* Now make sure the PL-2303 is configured correctly.
+		 * If not, give up now and hope this hack will work
+		 * properly during a later invocation of usb_serial_probe
+		 */
+		if (num_bulk_in == 0 || num_bulk_out == 0) {
+			info("PL-2303 hack: descriptors matched but endpoints did not");
+			return NULL;
+		}
 	}
 	/* END HORRIBLE HACK FOR PL2303 */
 #endif
-	
-	/* verify that we found all of the endpoints that we need */
-	if (!((interrupt_pipe & type->needs_interrupt_in) &&
-	      (bulk_in_pipe & type->needs_bulk_in) &&
-	      (bulk_out_pipe & type->needs_bulk_out))) {
-		/* nope, they don't match what we expected */
-		info("descriptors matched, but endpoints did not");
-		return NULL;
-	}
 
 	/* found all that we need */
 	info("%s converter detected", type->name);
@@ -1189,7 +1233,7 @@
 		err("No more free serial devices");
 		return NULL;
 	}
-	
+
 	serial->dev = dev;
 	serial->type = type;
 	serial->interface = interface;
@@ -1201,15 +1245,6 @@
 	serial->vendor = dev->descriptor.idVendor;
 	serial->product = dev->descriptor.idProduct;
 
-	/* if this device type has a startup function, call it */
-	if (type->startup) {
-		i = type->startup (serial);
-		if (i < 0)
-			goto probe_error;
-		if (i > 0)
-			return serial;
-	}
-
 	/* set up the endpoint information */
 	for (i = 0; i < num_bulk_in; ++i) {
 		endpoint = bulk_in_endpoint[i];
@@ -1226,13 +1261,14 @@
 			err("Couldn't allocate bulk_in_buffer");
 			goto probe_error;
 		}
-		FILL_BULK_URB(port->read_urb, dev, 
-			      usb_rcvbulkpipe(dev, endpoint->bEndpointAddress),
-			      port->bulk_in_buffer, buffer_size, 
-			      ((serial->type->read_bulk_callback) ?
-			       serial->type->read_bulk_callback :
-			       generic_read_bulk_callback), 
-			      port);
+		usb_fill_bulk_urb (port->read_urb, dev,
+				   usb_rcvbulkpipe (dev,
+					   	    endpoint->bEndpointAddress),
+				   port->bulk_in_buffer, buffer_size,
+				   ((serial->type->read_bulk_callback) ? 
+				     serial->type->read_bulk_callback : 
+				     generic_read_bulk_callback),
+				   port);
 	}
 
 	for (i = 0; i < num_bulk_out; ++i) {
@@ -1251,13 +1287,14 @@
 			err("Couldn't allocate bulk_out_buffer");
 			goto probe_error;
 		}
-		FILL_BULK_URB(port->write_urb, dev, 
-			      usb_sndbulkpipe(dev, endpoint->bEndpointAddress),
-			      port->bulk_out_buffer, buffer_size,
-			      ((serial->type->write_bulk_callback) ? 
-			       serial->type->write_bulk_callback : 
-			       generic_write_bulk_callback), 
-			      port);
+		usb_fill_bulk_urb (port->write_urb, dev,
+				   usb_sndbulkpipe (dev,
+						    endpoint->bEndpointAddress),
+				   port->bulk_out_buffer, buffer_size, 
+				   ((serial->type->write_bulk_callback) ? 
+				     serial->type->write_bulk_callback : 
+				     generic_write_bulk_callback),
+				   port);
 	}
 
 	for (i = 0; i < num_interrupt_in; ++i) {
@@ -1275,12 +1312,12 @@
 			err("Couldn't allocate interrupt_in_buffer");
 			goto probe_error;
 		}
-		FILL_INT_URB(port->interrupt_in_urb, dev, 
-			     usb_rcvintpipe(dev, endpoint->bEndpointAddress),
-			     port->interrupt_in_buffer, buffer_size, 
-			     serial->type->read_int_callback,
-			     port, 
-			     endpoint->bInterval);
+		usb_fill_int_urb (port->interrupt_in_urb, dev, 
+				  usb_rcvintpipe (dev,
+						  endpoint->bEndpointAddress),
+				  port->interrupt_in_buffer, buffer_size, 
+				  serial->type->read_int_callback, port, 
+				  endpoint->bInterval);
 	}
 
 	/* initialize some parts of the port structures */
@@ -1288,7 +1325,7 @@
 	max_endpoints = max(num_bulk_in, num_bulk_out);
 	max_endpoints = max(max_endpoints, num_interrupt_in);
 	max_endpoints = max(max_endpoints, (int)serial->num_ports);
-	dbg (__FUNCTION__ " - setting up %d port structures for this device", max_endpoints);
+	dbg("%s - setting up %d port structures for this device", __FUNCTION__, max_endpoints);
 	for (i = 0; i < max_endpoints; ++i) {
 		port = &serial->port[i];
 		port->number = i + serial->minor;
@@ -1298,14 +1335,23 @@
 		port->tqueue.data = port;
 		init_MUTEX (&port->sem);
 	}
-	
+
+	/* if this device type has a startup function, call it */
+	if (type->startup) {
+		i = type->startup (serial);
+		if (i < 0)
+			goto probe_error;
+		if (i > 0)
+			return serial;
+	}
+
 	/* initialize the devfs nodes for this device and let the user know what ports we are bound to */
 	for (i = 0; i < serial->num_ports; ++i) {
 		tty_register_devfs (&serial_tty_driver, 0, serial->port[i].number);
 		info("%s converter now attached to ttyUSB%d (or usb/tts/%d for devfs)", 
 		     type->name, serial->port[i].number, serial->port[i].number);
 	}
-	
+
 	return serial; /* success */
 
 
@@ -1331,7 +1377,7 @@
 		if (port->interrupt_in_buffer)
 			kfree (port->interrupt_in_buffer);
 	}
-		
+
 	/* return the minor range that this device had */
 	return_serial (serial);
 
@@ -1340,25 +1386,32 @@
 	return NULL;
 }
 
-
 static void usb_serial_disconnect(struct usb_device *dev, void *ptr)
 {
 	struct usb_serial *serial = (struct usb_serial *) ptr;
 	struct usb_serial_port *port;
 	int i;
 
+	dbg ("%s", __FUNCTION__);
 	if (serial) {
 		/* fail all future close/read/write/ioctl/etc calls */
 		for (i = 0; i < serial->num_ports; ++i) {
-			if (serial->port[i].tty != NULL)
-				serial->port[i].tty->driver_data = NULL;
+			port = &serial->port[i];
+			down (&port->sem);
+			if (port->tty != NULL) {
+				while (port->open_count > 0) {
+					__serial_close(port, NULL);
+				}
+				port->tty->driver_data = NULL;
+			}
+			up (&port->sem);
 		}
 
 		serial->dev = NULL;
 		serial_shutdown (serial);
 
 		for (i = 0; i < serial->num_ports; ++i)
-			serial->port[i].active = 0;
+			serial->port[i].open_count = 0;
 
 		for (i = 0; i < serial->num_bulk_in; ++i) {
 			port = &serial->port[i];
@@ -1402,36 +1455,41 @@
 	} else {
 		info("device disconnected");
 	}
-	
+
 }
 
 
 static struct tty_driver serial_tty_driver = {
-	magic:			TTY_DRIVER_MAGIC,
-	driver_name:		"usb-serial",
-	name:			"usb/tts/%d",
-	major:			SERIAL_TTY_MAJOR,
-	minor_start:		0,
-	num:			SERIAL_TTY_MINORS,
-	type:			TTY_DRIVER_TYPE_SERIAL,
-	subtype:		SERIAL_TYPE_NORMAL,
-	flags:			TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
-	
-	refcount:		&serial_refcount,
-	table:			serial_tty,
-	termios:		serial_termios,
-	termios_locked:		serial_termios_locked,
-	
-	open:			serial_open,
-	close:			serial_close,
-	write:			serial_write,
-	write_room:		serial_write_room,
-	ioctl:			serial_ioctl,
-	set_termios:		serial_set_termios,
-	throttle:		serial_throttle,
-	unthrottle:		serial_unthrottle,
-	break_ctl:		serial_break,
-	chars_in_buffer:	serial_chars_in_buffer,
+	.magic =		TTY_DRIVER_MAGIC,
+	.driver_name =		"usb-serial",
+#ifndef CONFIG_DEVFS_FS
+	.name =			"ttyUSB",
+#else
+	.name =			"usb/tts/%d",
+#endif
+	.major =		SERIAL_TTY_MAJOR,
+	.minor_start =		0,
+	.num =			SERIAL_TTY_MINORS,
+	.type =			TTY_DRIVER_TYPE_SERIAL,
+	.subtype =		SERIAL_TYPE_NORMAL,
+	.flags =		TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
+
+	.refcount =		&serial_refcount,
+	.table =		serial_tty,
+	.termios =		serial_termios,
+	.termios_locked =	serial_termios_locked,
+
+	.open =			serial_open,
+	.close =		serial_close,
+	.write =		serial_write,
+	.write_room =		serial_write_room,
+	.ioctl =		serial_ioctl,
+	.set_termios =		serial_set_termios,
+	.throttle =		serial_throttle,
+	.unthrottle =		serial_unthrottle,
+	.break_ctl =		serial_break,
+	.chars_in_buffer =	serial_chars_in_buffer,
+	.read_proc =		serial_read_proc,
 };
 
 
@@ -1449,7 +1507,7 @@
 	serial_tty_driver.init_termios          = tty_std_termios;
 	serial_tty_driver.init_termios.c_cflag  = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	if (tty_register_driver (&serial_tty_driver)) {
-		err(__FUNCTION__ " - failed to register tty driver");
+		err("%s - failed to register tty driver", __FUNCTION__);
 		return -1;
 	}
 
@@ -1526,7 +1584,7 @@
 
 
 
-/* If the usb-serial core is build into the core, the usb-serial drivers
+/* If the usb-serial core is built into the core, the usb-serial drivers
    need these symbols to load properly as modules. */
 EXPORT_SYMBOL(usb_serial_register);
 EXPORT_SYMBOL(usb_serial_deregister);
diff -Nur linux-2.4.19.old/drivers/usb/serial/visor.c linux-2.4.19/drivers/usb/serial/visor.c
--- linux-2.4.19.old/drivers/usb/serial/visor.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/visor.c	Mon Nov 25 12:27:12 2002
@@ -123,18 +123,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -149,7 +146,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.5"
+#define DRIVER_VERSION "v1.6"
 #define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>"
 #define DRIVER_DESC "USB HandSpring Visor, Palm m50x, Sony Clié driver"
 
@@ -170,41 +167,35 @@
 static int  clie_3_5_startup	(struct usb_serial *serial);
 
 
-static __devinitdata struct usb_device_id visor_id_table [] = {
-	{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID) },
-	{ }					/* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id palm_4_0_id_table [] = {
+static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M500_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M505_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M515_ID) },
+	{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M125_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID) },
-	{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID) },
+	{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID) },
+	{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID) },
+	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID) },
+	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID) },
+	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID) },
 	{ }					/* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id clie_id_3_5_table [] = {
+static struct usb_device_id clie_id_3_5_table [] = {
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },
 	{ }					/* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id clie_id_4_0_table [] = {
-	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID) },
-	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID) },
-	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID) },
-	{ }					/* Terminating entry */
-};
-
-static __devinitdata struct usb_device_id id_table [] = {
+static __devinitdata struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M500_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M505_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M515_ID) },
+	{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M125_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID) },
-	{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID) },
+	{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID) },
@@ -212,113 +203,57 @@
 	{ }					/* Terminating entry */
 };
 
-MODULE_DEVICE_TABLE (usb, id_table);
+MODULE_DEVICE_TABLE (usb, id_table_combined);
 
 
 
-/* All of the device info needed for the Handspring Visor */
+/* All of the device info needed for the Handspring Visor, and Palm 4.0 devices */
 static struct usb_serial_device_type handspring_device = {
-	name:			"Handspring Visor",
-	id_table:		visor_id_table,
-	needs_interrupt_in:	MUST_HAVE_NOT,		/* this device must not have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,		/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,		/* this device must have a bulk out endpoint */
-	num_interrupt_in:	0,
-	num_bulk_in:		2,
-	num_bulk_out:		2,
-	num_ports:		2,
-	open:			visor_open,
-	close:			visor_close,
-	throttle:		visor_throttle,
-	unthrottle:		visor_unthrottle,
-	startup:		visor_startup,
-	shutdown:		visor_shutdown,
-	ioctl:			visor_ioctl,
-	set_termios:		visor_set_termios,
-	write:			visor_write,
-	write_room:		visor_write_room,
-	chars_in_buffer:	visor_chars_in_buffer,
-	write_bulk_callback:	visor_write_bulk_callback,
-	read_bulk_callback:	visor_read_bulk_callback,
+	.owner =		THIS_MODULE,
+	.name =			"Handspring Visor / Palm 4.0 / Clié 4.x",
+	.id_table =		id_table,
+	.num_interrupt_in =	0,
+	.num_bulk_in =		2,
+	.num_bulk_out =		2,
+	.num_ports =		2,
+	.open =			visor_open,
+	.close =		visor_close,
+	.throttle =		visor_throttle,
+	.unthrottle =		visor_unthrottle,
+	.startup =		visor_startup,
+	.shutdown =		visor_shutdown,
+	.ioctl =		visor_ioctl,
+	.set_termios =		visor_set_termios,
+	.write =		visor_write,
+	.write_room =		visor_write_room,
+	.chars_in_buffer =	visor_chars_in_buffer,
+	.write_bulk_callback =	visor_write_bulk_callback,
+	.read_bulk_callback =	visor_read_bulk_callback,
 };
 
-/* device info for the Palm 4.0 devices */
-static struct usb_serial_device_type palm_4_0_device = {
-	name:			"Palm 4.0",
-	id_table:		palm_4_0_id_table,
-	needs_interrupt_in:	MUST_HAVE_NOT,		/* this device must not have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,		/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,		/* this device must have a bulk out endpoint */
-	num_interrupt_in:	0,
-	num_bulk_in:		2,
-	num_bulk_out:		2,
-	num_ports:		2,
-	open:			visor_open,
-	close:			visor_close,
-	throttle:		visor_throttle,
-	unthrottle:		visor_unthrottle,
-	startup:		visor_startup,
-	shutdown:		visor_shutdown,
-	ioctl:			visor_ioctl,
-	set_termios:		visor_set_termios,
-	write:			visor_write,
-	write_room:		visor_write_room,
-	chars_in_buffer:	visor_chars_in_buffer,
-	write_bulk_callback:	visor_write_bulk_callback,
-	read_bulk_callback:	visor_read_bulk_callback,
-};
-
-
 /* device info for the Sony Clie OS version 3.5 */
 static struct usb_serial_device_type clie_3_5_device = {
-	name:			"Sony Clié 3.5",
-	id_table:		clie_id_3_5_table,
-	needs_interrupt_in:	MUST_HAVE_NOT,		/* this device must not have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,		/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,		/* this device must have a bulk out endpoint */
-	num_interrupt_in:	0,
-	num_bulk_in:		1,
-	num_bulk_out:		1,
-	num_ports:		1,
-	open:			visor_open,
-	close:			visor_close,
-	throttle:		visor_throttle,
-	unthrottle:		visor_unthrottle,
-	startup:		clie_3_5_startup,
-	ioctl:			visor_ioctl,
-	set_termios:		visor_set_termios,
-	write:			visor_write,
-	write_room:		visor_write_room,
-	chars_in_buffer:	visor_chars_in_buffer,
-	write_bulk_callback:	visor_write_bulk_callback,
-	read_bulk_callback:	visor_read_bulk_callback,
+	.owner =		THIS_MODULE,
+	.name =			"Sony Clié 3.5",
+	.id_table =		clie_id_3_5_table,
+	.num_interrupt_in =	0,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			visor_open,
+	.close =		visor_close,
+	.throttle =		visor_throttle,
+	.unthrottle =		visor_unthrottle,
+	.startup =		clie_3_5_startup,
+	.ioctl =		visor_ioctl,
+	.set_termios =		visor_set_termios,
+	.write =		visor_write,
+	.write_room =		visor_write_room,
+	.chars_in_buffer =	visor_chars_in_buffer,
+	.write_bulk_callback =	visor_write_bulk_callback,
+	.read_bulk_callback =	visor_read_bulk_callback,
 };
 
-/* device info for the Sony Clie OS version 4.0 */
-static struct usb_serial_device_type clie_4_0_device = {
-	name:			"Sony Clié 4.x",
-	id_table:		clie_id_4_0_table,
-	needs_interrupt_in:	MUST_HAVE_NOT,		/* this device must not have an interrupt in endpoint */
-	needs_bulk_in:		MUST_HAVE,		/* this device must have a bulk in endpoint */
-	needs_bulk_out:		MUST_HAVE,		/* this device must have a bulk out endpoint */
-	num_interrupt_in:	0,
-	num_bulk_in:		2,
-	num_bulk_out:		2,
-	num_ports:		2,
-	open:			visor_open,
-	close:			visor_close,
-	throttle:		visor_throttle,
-	unthrottle:		visor_unthrottle,
-	startup:		visor_startup,
-	shutdown:		visor_shutdown,
-	ioctl:			visor_ioctl,
-	set_termios:		visor_set_termios,
-	write:			visor_write,
-	write_room:		visor_write_room,
-	chars_in_buffer:	visor_chars_in_buffer,
-	write_bulk_callback:	visor_write_bulk_callback,
-	read_bulk_callback:	visor_read_bulk_callback,
-};
 
 #define NUM_URBS			24
 #define URB_TRANSFER_BUFFER_SIZE	768
@@ -339,39 +274,35 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return -ENODEV;
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (!port->read_urb) {
+		/* this is needed for some brain dead Sony devices */
 		err ("Device lied about number of ports, please use a lower one.");
 		return -ENODEV;
 	}
 
-	down (&port->sem);
-	
-	++port->open_count;
-	MOD_INC_USE_COUNT;
-	
-	if (!port->active) {
-		port->active = 1;
-		bytes_in = 0;
-		bytes_out = 0;
-
-		/* force low_latency on so that our tty_push actually forces the data through, 
-		   otherwise it is scheduled, and with high data rates (like with OHCI) data
-		   can get lost. */
+	bytes_in = 0;
+	bytes_out = 0;
+
+	/*
+	 * Force low_latency on so that our tty_push actually forces the data
+	 * through, otherwise it is scheduled, and with high data rates (like
+	 * with OHCI) data can get lost.
+	 */
+	if (port->tty)
 		port->tty->low_latency = 1;
-		
-		/* Start reading from the device */
-		FILL_BULK_URB(port->read_urb, serial->dev, 
-			      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-			      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-			      visor_read_bulk_callback, port);
-		result = usb_submit_urb(port->read_urb);
-		if (result)
-			err(__FUNCTION__ " - failed submitting read urb, error %d", result);
-	}
-	
-	up (&port->sem);
+
+	/* Start reading from the device */
+	usb_fill_bulk_urb (port->read_urb, serial->dev,
+			   usb_rcvbulkpipe (serial->dev, 
+					    port->bulk_in_endpointAddress),
+			   port->read_urb->transfer_buffer,
+			   port->read_urb->transfer_buffer_length,
+			   visor_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb);
+	if (result)
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
 	
 	return result;
 }
@@ -385,44 +316,32 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 			 
 	serial = get_usb_serial (port, __FUNCTION__);
 	if (!serial)
 		return;
 	
-	down (&port->sem);
-
-	--port->open_count;
-
-	if (port->open_count <= 0) {
-		if (serial->dev) {
-			/* only send a shutdown message if the 
-			 * device is still here */
-			transfer_buffer =  kmalloc (0x12, GFP_KERNEL);
-			if (!transfer_buffer) {
-				err(__FUNCTION__ " - kmalloc(%d) failed.", 0x12);
-			} else {
-				/* send a shutdown message to the device */
-				usb_control_msg (serial->dev,
-						 usb_rcvctrlpipe(serial->dev, 0),
-						 VISOR_CLOSE_NOTIFICATION, 0xc2,
-						 0x0000, 0x0000, 
-						 transfer_buffer, 0x12, 300);
-				kfree (transfer_buffer);
-			}
-			/* shutdown our bulk read */
-			usb_unlink_urb (port->read_urb);
+	if (serial->dev) {
+		/* only send a shutdown message if the 
+		 * device is still here */
+		transfer_buffer =  kmalloc (0x12, GFP_KERNEL);
+		if (!transfer_buffer) {
+			err("%s - kmalloc(%d) failed.", __FUNCTION__, 0x12);
+		} else {
+			/* send a shutdown message to the device */
+			usb_control_msg (serial->dev,
+					 usb_rcvctrlpipe(serial->dev, 0),
+					 VISOR_CLOSE_NOTIFICATION, 0xc2,
+					 0x0000, 0x0000, 
+					 transfer_buffer, 0x12, 300);
+			kfree (transfer_buffer);
 		}
-		port->active = 0;
-		port->open_count = 0;
+		/* shutdown our bulk read */
+		usb_unlink_urb (port->read_urb);
 	}
-	up (&port->sem);
-
 	/* Uncomment the following line if you want to see some statistics in your syslog */
 	/* info ("Bytes In = %d  Bytes Out = %d", bytes_in, bytes_out); */
-
-	MOD_DEC_USE_COUNT;
 }
 
 
@@ -437,7 +356,7 @@
 	int bytes_sent = 0;
 	int transfer_size;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	while (count > 0) {
 		/* try to find a free urb in our list of them */
@@ -451,13 +370,13 @@
 		}
 		spin_unlock_irqrestore (&write_urb_pool_lock, flags);
 		if (urb == NULL) {
-			dbg (__FUNCTION__ " - no more free urbs");
+			dbg("%s - no more free urbs", __FUNCTION__);
 			goto exit;
 		}
 		if (urb->transfer_buffer == NULL) {
 			urb->transfer_buffer = kmalloc (URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);
 			if (urb->transfer_buffer == NULL) {
-				err(__FUNCTION__" no more kernel memory...");
+				err("%s no more kernel memory...", __FUNCTION__);
 				goto exit;
 			}
 		}
@@ -482,7 +401,7 @@
 		/* send it down the pipe */
 		status = usb_submit_urb(urb);
 		if (status) {
-			err(__FUNCTION__ " - usb_submit_urb(write bulk) failed with status = %d", status);
+			err("%s - usb_submit_urb(write bulk) failed with status = %d", __FUNCTION__, status);
 			bytes_sent = status;
 			break;
 		}
@@ -504,7 +423,7 @@
 	int i;
 	int room = 0;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	spin_lock_irqsave (&write_urb_pool_lock, flags);
 
@@ -516,7 +435,7 @@
 	
 	spin_unlock_irqrestore (&write_urb_pool_lock, flags);
 	
-	dbg(__FUNCTION__ " - returns %d", room);
+	dbg("%s - returns %d", __FUNCTION__, room);
 	return (room);
 }
 
@@ -527,7 +446,7 @@
 	int i;
 	int chars = 0;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	spin_lock_irqsave (&write_urb_pool_lock, flags);
 
@@ -539,7 +458,7 @@
 	
 	spin_unlock_irqrestore (&write_urb_pool_lock, flags);
 
-	dbg (__FUNCTION__ " - returns %d", chars);
+	dbg("%s - returns %d", __FUNCTION__, chars);
 	return (chars);
 }
 
@@ -551,16 +470,16 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero write bulk status received: %d", urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
 	queue_task(&port->tqueue, &tq_immediate);
 	mark_bh(IMMEDIATE_BH);
-	
+
 	return;
 }
 
@@ -577,22 +496,22 @@
 	if (port_paranoia_check (port, __FUNCTION__))
 		return;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 
 	if (urb->status) {
-		dbg(__FUNCTION__ " - nonzero read bulk status received: %d", urb->status);
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
 	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	tty = port->tty;
-	if (urb->actual_length) {
+	if (tty && urb->actual_length) {
 		for (i = 0; i < urb->actual_length ; ++i) {
 			/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
 			if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
@@ -606,29 +525,23 @@
 	}
 
 	/* Continue trying to always read  */
-	FILL_BULK_URB(port->read_urb, serial->dev, 
-		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-		      visor_read_bulk_callback, port);
+	usb_fill_bulk_urb (port->read_urb, serial->dev,
+			   usb_rcvbulkpipe (serial->dev,
+					    port->bulk_in_endpointAddress),
+			   port->read_urb->transfer_buffer,
+			   port->read_urb->transfer_buffer_length,
+			   visor_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb);
 	if (result)
-		err(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 	return;
 }
 
 
 static void visor_throttle (struct usb_serial_port *port)
 {
-
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
-
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	usb_unlink_urb (port->read_urb);
-
-	up (&port->sem);
-
-	return;
 }
 
 
@@ -636,42 +549,35 @@
 {
 	int result;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
-
-	down (&port->sem);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	port->read_urb->dev = port->serial->dev;
 	result = usb_submit_urb(port->read_urb);
 	if (result)
-		err(__FUNCTION__ " - failed submitting read urb, error %d", result);
-
-	up (&port->sem);
-
-	return;
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
 }
 
-
-static int  visor_startup (struct usb_serial *serial)
+static int visor_startup (struct usb_serial *serial)
 {
 	int response;
 	int i;
 	unsigned char *transfer_buffer =  kmalloc (256, GFP_KERNEL);
 
 	if (!transfer_buffer) {
-		err(__FUNCTION__ " - kmalloc(%d) failed.", 256);
+		err("%s - kmalloc(%d) failed.", __FUNCTION__, 256);
 		return -ENOMEM;
 	}
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
-	dbg(__FUNCTION__ " - Set config to 1");
+	dbg("%s - Set config to 1", __FUNCTION__);
 	usb_set_configuration (serial->dev, 1);
 
 	/* send a get connection info request */
 	response = usb_control_msg (serial->dev, usb_rcvctrlpipe(serial->dev, 0), VISOR_GET_CONNECTION_INFORMATION,
 					0xc2, 0x0000, 0x0000, transfer_buffer, 0x12, 300);
 	if (response < 0) {
-		err(__FUNCTION__ " - error getting connection information");
+		err("%s - error getting connection information", __FUNCTION__);
 	} else {
 		struct visor_connection_info *connection_info = (struct visor_connection_info *)transfer_buffer;
 		char *string;
@@ -699,7 +605,8 @@
 					string = "unknown";
 					break;	
 			}
-			info("%s: port %d, is for %s use and is bound to ttyUSB%d", serial->type->name, connection_info->connections[i].port, string, serial->minor + i);
+			info("%s: port %d, is for %s use and is bound to ttyUSB%d", serial->type->name,
+			     connection_info->connections[i].port, string, serial->minor + i);
 		}
 	}
 
@@ -712,7 +619,7 @@
 					    0xc2, 0x0000, 0x0000, transfer_buffer, 
 					    0x14, 300);
 		if (response < 0) {
-			err(__FUNCTION__ " - error getting first unknown palm command");
+			err("%s - error getting first unknown palm command", __FUNCTION__);
 		} else {
 			usb_serial_debug_data (__FILE__, __FUNCTION__, 0x14, transfer_buffer);
 		}
@@ -721,7 +628,7 @@
 					    0xc2, 0x0000, 0x0000, transfer_buffer, 
 					    0x14, 300);
 		if (response < 0) {
-			err(__FUNCTION__ " - error getting second unknown palm command");
+			err("%s - error getting second unknown palm command", __FUNCTION__);
 		} else {
 			usb_serial_debug_data (__FILE__, __FUNCTION__, 0x14, transfer_buffer);
 		}
@@ -731,7 +638,7 @@
 	response = usb_control_msg (serial->dev, usb_rcvctrlpipe(serial->dev, 0), VISOR_REQUEST_BYTES_AVAILABLE,
 					0xc2, 0x0000, 0x0005, transfer_buffer, 0x02, 300);
 	if (response < 0) {
-		err(__FUNCTION__ " - error getting bytes available request");
+		err("%s - error getting bytes available request", __FUNCTION__);
 	}
 
 	kfree (transfer_buffer);
@@ -745,7 +652,7 @@
 	int result;
 	u8 data;
 
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	/*
 	 * Note that PEG-300 series devices expect the following two calls.
@@ -756,11 +663,11 @@
 				  USB_REQ_GET_CONFIGURATION, USB_DIR_IN,
 				  0, 0, &data, 1, HZ * 3);
 	if (result < 0) {
-		err(__FUNCTION__ ": get config number failed: %d", result);
+		err("%s: get config number failed: %d", __FUNCTION__, result);
 		return result;
 	}
 	if (result != 1) {
-		err(__FUNCTION__ ": get config number bad return length: %d", result);
+		err("%s: get config number bad return length: %d", __FUNCTION__, result);
 		return -EIO;
 	}
 
@@ -770,11 +677,11 @@
 				  USB_DIR_IN | USB_DT_DEVICE,
 				  0, 0, &data, 1, HZ * 3);
 	if (result < 0) {
-		err(__FUNCTION__ ": get interface number failed: %d", result);
+		err("%s: get interface number failed: %d", __FUNCTION__, result);
 		return result;
 	}
 	if (result != 1) {
-		err(__FUNCTION__ ": get interface number bad return length: %d", result);
+		err("%s: get interface number bad return length: %d", __FUNCTION__, result);
 		return -EIO;
 	}
 
@@ -783,21 +690,12 @@
 
 static void visor_shutdown (struct usb_serial *serial)
 {
-	int i;
-
-	dbg (__FUNCTION__);
-
-	/* stop reads and writes on all ports */
-	for (i=0; i < serial->num_ports; ++i) {
-		serial->port[i].active = 0;
-		serial->port[i].open_count = 0;
-	}
+	dbg("%s", __FUNCTION__);
 }
 
-
 static int visor_ioctl (struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg)
 {
-	dbg(__FUNCTION__ " - port %d, cmd 0x%.4x", port->number, cmd);
+	dbg("%s - port %d, cmd 0x%.4x", __FUNCTION__, port->number, cmd);
 
 	return -ENOIOCTLCMD;
 }
@@ -808,10 +706,10 @@
 {
 	unsigned int cflag;
 
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if ((!port->tty) || (!port->tty->termios)) {
-		dbg(__FUNCTION__" - no tty structures");
+		dbg("%s - no tty structures", __FUNCTION__);
 		return;
 	}
 
@@ -820,50 +718,51 @@
 	if (old_termios) {
 		if ((cflag == old_termios->c_cflag) &&
 		    (RELEVANT_IFLAG(port->tty->termios->c_iflag) == RELEVANT_IFLAG(old_termios->c_iflag))) {
-			dbg(__FUNCTION__ " - nothing to change...");
+			dbg("%s - nothing to change...", __FUNCTION__);
 			return;
 		}
 	}
 
 	/* get the byte size */
 	switch (cflag & CSIZE) {
-		case CS5:	dbg(__FUNCTION__ " - data bits = 5");   break;
-		case CS6:	dbg(__FUNCTION__ " - data bits = 6");   break;
-		case CS7:	dbg(__FUNCTION__ " - data bits = 7");   break;
+		case CS5:	dbg("%s - data bits = 5", __FUNCTION__);   break;
+		case CS6:	dbg("%s - data bits = 6", __FUNCTION__);   break;
+		case CS7:	dbg("%s - data bits = 7", __FUNCTION__);   break;
 		default:
-		case CS8:	dbg(__FUNCTION__ " - data bits = 8");   break;
+		case CS8:	dbg("%s - data bits = 8", __FUNCTION__);   break;
 	}
 	
 	/* determine the parity */
 	if (cflag & PARENB)
 		if (cflag & PARODD)
-			dbg(__FUNCTION__ " - parity = odd");
+			dbg("%s - parity = odd", __FUNCTION__);
 		else
-			dbg(__FUNCTION__ " - parity = even");
+			dbg("%s - parity = even", __FUNCTION__);
 	else
-		dbg(__FUNCTION__ " - parity = none");
+		dbg("%s - parity = none", __FUNCTION__);
 
 	/* figure out the stop bits requested */
 	if (cflag & CSTOPB)
-		dbg(__FUNCTION__ " - stop bits = 2");
+		dbg("%s - stop bits = 2", __FUNCTION__);
 	else
-		dbg(__FUNCTION__ " - stop bits = 1");
+		dbg("%s - stop bits = 1", __FUNCTION__);
 
 	
 	/* figure out the flow control settings */
 	if (cflag & CRTSCTS)
-		dbg(__FUNCTION__ " - RTS/CTS is enabled");
+		dbg("%s - RTS/CTS is enabled", __FUNCTION__);
 	else
-		dbg(__FUNCTION__ " - RTS/CTS is disabled");
+		dbg("%s - RTS/CTS is disabled", __FUNCTION__);
 	
 	/* determine software flow control */
 	if (I_IXOFF(port->tty))
-		dbg(__FUNCTION__ " - XON/XOFF is enabled, XON = %2x, XOFF = %2x", START_CHAR(port->tty), STOP_CHAR(port->tty));
+		dbg("%s - XON/XOFF is enabled, XON = %2x, XOFF = %2x",
+		    __FUNCTION__, START_CHAR(port->tty), STOP_CHAR(port->tty));
 	else
-		dbg(__FUNCTION__ " - XON/XOFF is disabled");
+		dbg("%s - XON/XOFF is disabled", __FUNCTION__);
 
 	/* get the baud rate wanted */
-	dbg(__FUNCTION__ " - baud rate = %d", tty_get_baud_rate(port->tty));
+	dbg("%s - baud rate = %d", __FUNCTION__, tty_get_baud_rate(port->tty));
 
 	return;
 }
@@ -875,9 +774,7 @@
 	int i;
 
 	usb_serial_register (&handspring_device);
-	usb_serial_register (&palm_4_0_device);
 	usb_serial_register (&clie_3_5_device);
-	usb_serial_register (&clie_4_0_device);
 	
 	/* create our write urb pool and transfer buffers */ 
 	spin_lock_init (&write_urb_pool_lock);
@@ -892,7 +789,7 @@
 		urb->transfer_buffer = NULL;
 		urb->transfer_buffer = kmalloc (URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);
 		if (!urb->transfer_buffer) {
-			err (__FUNCTION__ " - out of memory for urb buffers.");
+			err("%s - out of memory for urb buffers.", __FUNCTION__);
 			continue;
 		}
 	}
@@ -909,9 +806,7 @@
 	unsigned long flags;
 
 	usb_serial_deregister (&handspring_device);
-	usb_serial_deregister (&palm_4_0_device);
 	usb_serial_deregister (&clie_3_5_device);
-	usb_serial_deregister (&clie_4_0_device);
 
 	spin_lock_irqsave (&write_urb_pool_lock, flags);
 
diff -Nur linux-2.4.19.old/drivers/usb/serial/visor.h linux-2.4.19/drivers/usb/serial/visor.h
--- linux-2.4.19.old/drivers/usb/serial/visor.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/visor.h	Mon Nov 25 12:27:12 2002
@@ -27,6 +27,7 @@
 #define PALM_I705_ID			0x0020
 #define PALM_M125_ID			0x0040
 #define PALM_M130_ID			0x0050
+#define PALM_ZIRE_ID			0x0070
 
 #define SONY_VENDOR_ID			0x054C
 #define SONY_CLIE_3_5_ID		0x0038
diff -Nur linux-2.4.19.old/drivers/usb/serial/whiteheat.c linux-2.4.19/drivers/usb/serial/whiteheat.c
--- linux-2.4.19.old/drivers/usb/serial/whiteheat.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/serial/whiteheat.c	Mon Nov 25 12:27:12 2002
@@ -61,18 +61,15 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
 #include <linux/errno.h>
-#include <linux/poll.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/fcntl.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <asm/uaccess.h>
 #include <linux/usb.h>
 
 #ifdef CONFIG_USB_SERIAL_DEBUG
@@ -103,12 +100,12 @@
    separate ID tables, and then a third table that combines them
    just for the purpose of exporting the autoloading information.
 */
-static __devinitdata struct usb_device_id id_table_std [] = {
+static struct usb_device_id id_table_std [] = {
 	{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },
 	{ }						/* Terminating entry */
 };
 
-static __devinitdata struct usb_device_id id_table_prerenumeration [] = {
+static struct usb_device_id id_table_prerenumeration [] = {
 	{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },
 	{ }						/* Terminating entry */
 };
@@ -133,36 +130,32 @@
 static void whiteheat_real_shutdown	(struct usb_serial *serial);
 
 static struct usb_serial_device_type whiteheat_fake_device = {
-	name:			"Connect Tech - WhiteHEAT - (prerenumeration)",
-	id_table:		id_table_prerenumeration,
-	needs_interrupt_in:	DONT_CARE,				/* don't have to have an interrupt in endpoint */
-	needs_bulk_in:		DONT_CARE,				/* don't have to have a bulk in endpoint */
-	needs_bulk_out:		DONT_CARE,				/* don't have to have a bulk out endpoint */
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		1,
-	startup:		whiteheat_fake_startup,
+	.owner =		THIS_MODULE,
+	.name =			"Connect Tech - WhiteHEAT - (prerenumeration)",
+	.id_table =		id_table_prerenumeration,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		NUM_DONT_CARE,
+	.num_bulk_out =		NUM_DONT_CARE,
+	.num_ports =		1,
+	.startup =		whiteheat_fake_startup,
 };
 
 static struct usb_serial_device_type whiteheat_device = {
-	name:			"Connect Tech - WhiteHEAT",
-	id_table:		id_table_std,
-	needs_interrupt_in:	DONT_CARE,				/* don't have to have an interrupt in endpoint */
-	needs_bulk_in:		DONT_CARE,				/* don't have to have a bulk in endpoint */
-	needs_bulk_out:		DONT_CARE,				/* don't have to have a bulk out endpoint */
-	num_interrupt_in:	NUM_DONT_CARE,
-	num_bulk_in:		NUM_DONT_CARE,
-	num_bulk_out:		NUM_DONT_CARE,
-	num_ports:		4,
-	open:			whiteheat_open,
-	close:			whiteheat_close,
-	throttle:		whiteheat_throttle,
-	unthrottle:		whiteheat_unthrottle,
-	ioctl:			whiteheat_ioctl,
-	set_termios:		whiteheat_set_termios,
-	startup:		whiteheat_real_startup,
-	shutdown:		whiteheat_real_shutdown,
+	.owner =		THIS_MODULE,
+	.name =			"Connect Tech - WhiteHEAT",
+	.id_table =		id_table_std,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		NUM_DONT_CARE,
+	.num_bulk_out =		NUM_DONT_CARE,
+	.num_ports =		4,
+	.open =			whiteheat_open,
+	.close =		whiteheat_close,
+	.throttle =		whiteheat_throttle,
+	.unthrottle =		whiteheat_unthrottle,
+	.ioctl =		whiteheat_ioctl,
+	.set_termios =		whiteheat_set_termios,
+	.startup =		whiteheat_real_startup,
+	.shutdown =		whiteheat_real_shutdown,
 };
 
 struct whiteheat_private {
@@ -186,7 +179,7 @@
  *****************************************************************************/
 static void command_port_write_callback (struct urb *urb)
 {
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (urb->status) {
 		dbg ("nonzero urb status: %d", urb->status);
@@ -207,15 +200,15 @@
 	unsigned char *data = urb->transfer_buffer;
 	int result;
 
-	dbg (__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 
 	if (urb->status) {
-		dbg (__FUNCTION__ " - nonzero urb status: %d", urb->status);
+		dbg("%s - nonzero urb status: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
 	if (!serial) {
-		dbg(__FUNCTION__ " - bad serial pointer, exiting");
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
 		return;
 	}
 	
@@ -223,7 +216,7 @@
 
 	info = (struct whiteheat_private *)port->private;
 	if (!info) {
-		dbg (__FUNCTION__ " - info is NULL, exiting.");
+		dbg("%s - info is NULL, exiting.", __FUNCTION__);
 		return;
 	}
 
@@ -246,7 +239,7 @@
 		      command_port_read_callback, port);
 	result = usb_submit_urb(port->read_urb);
 	if (result)
-		dbg(__FUNCTION__ " - failed resubmitting read urb, error %d", result);
+		dbg("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 }
 
 
@@ -258,7 +251,7 @@
 	__u8 *transfer_buffer;
 	int retval = 0;
 
-	dbg(__FUNCTION__" - command %d", command);
+	dbg("%s - command %d", __FUNCTION__, command);
 
 	port = &serial->port[COMMAND_PORT];
 	info = (struct whiteheat_private *)port->private;
@@ -271,7 +264,7 @@
 	port->write_urb->dev = serial->dev;
 	retval = usb_submit_urb (port->write_urb);
 	if (retval) {
-		dbg (__FUNCTION__" - submit urb failed");
+		dbg("%s - submit urb failed", __FUNCTION__);
 		goto exit;
 	}
 
@@ -282,19 +275,19 @@
 	}
 
 	if (info->command_finished == FALSE) {
-		dbg (__FUNCTION__ " - command timed out.");
+		dbg("%s - command timed out.", __FUNCTION__);
 		retval = -ETIMEDOUT;
 		goto exit;
 	}
 
 	if (info->command_finished == WHITEHEAT_CMD_FAILURE) {
-		dbg (__FUNCTION__ " - command failed.");
+		dbg("%s - command failed.", __FUNCTION__);
 		retval = -EIO;
 		goto exit;
 	}
 
 	if (info->command_finished == WHITEHEAT_CMD_COMPLETE)
-		dbg (__FUNCTION__ " - command completed.");
+		dbg("%s - command completed.", __FUNCTION__);
 
 exit:
 	return retval;
@@ -308,70 +301,51 @@
 	struct whiteheat_private	*info;
 	int				retval = 0;
 
-	dbg(__FUNCTION__" - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	down (&port->sem);
-
-	++port->open_count;
-	MOD_INC_USE_COUNT;
-	
-	if (!port->active) {
-		port->active = 1;
-
-		/* set up some stuff for our command port */
-		command_port = &port->serial->port[COMMAND_PORT];
-		if (command_port->private == NULL) {
-			info = (struct whiteheat_private *)kmalloc (sizeof(struct whiteheat_private), GFP_KERNEL);
-			if (info == NULL) {
-				err(__FUNCTION__ " - out of memory");
-				retval = -ENOMEM;
-				goto error_exit;
-			}
-			
-			init_waitqueue_head(&info->wait_command);
-			command_port->private = info;
-			command_port->write_urb->complete = command_port_write_callback;
-			command_port->read_urb->complete = command_port_read_callback;
-			command_port->read_urb->dev = port->serial->dev;
-			command_port->tty = port->tty;		/* need this to "fake" our our sanity check macros */
-			retval = usb_submit_urb (command_port->read_urb);
-			if (retval) {
-				err(__FUNCTION__ " - failed submitting read urb, error %d", retval);
-				goto error_exit;
-			}
+	/* set up some stuff for our command port */
+	command_port = &port->serial->port[COMMAND_PORT];
+	if (command_port->private == NULL) {
+		info = (struct whiteheat_private *)kmalloc (sizeof(struct whiteheat_private), GFP_KERNEL);
+		if (info == NULL) {
+			err("%s - out of memory", __FUNCTION__);
+			retval = -ENOMEM;
+			goto exit;
 		}
 		
-		/* Start reading from the device */
-		port->read_urb->dev = port->serial->dev;
-		retval = usb_submit_urb(port->read_urb);
+		init_waitqueue_head(&info->wait_command);
+		command_port->private = info;
+		command_port->write_urb->complete = command_port_write_callback;
+		command_port->read_urb->complete = command_port_read_callback;
+		command_port->read_urb->dev = port->serial->dev;
+		command_port->tty = port->tty;		/* need this to "fake" our our sanity check macros */
+		retval = usb_submit_urb (command_port->read_urb);
 		if (retval) {
-			err(__FUNCTION__ " - failed submitting read urb, error %d", retval);
-			goto error_exit;
+			err("%s - failed submitting read urb, error %d", __FUNCTION__, retval);
+			goto exit;
 		}
+	}
 	
-		/* send an open port command */
-		/* firmware uses 1 based port numbering */
-		open_command.port = port->number - port->serial->minor + 1;
-		retval = whiteheat_send_cmd (port->serial, WHITEHEAT_OPEN, (__u8 *)&open_command, sizeof(open_command));
-		if (retval)
-			goto error_exit;
-	
-		/* Need to do device specific setup here (control lines, baud rate, etc.) */
-		/* FIXME!!! */
+	/* Start reading from the device */
+	port->read_urb->dev = port->serial->dev;
+	retval = usb_submit_urb(port->read_urb);
+	if (retval) {
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, retval);
+		goto exit;
 	}
 
-	dbg(__FUNCTION__ " - exit");
-	up (&port->sem);
-	
-	return retval;
+	/* send an open port command */
+	/* firmware uses 1 based port numbering */
+	open_command.port = port->number - port->serial->minor + 1;
+	retval = whiteheat_send_cmd (port->serial, WHITEHEAT_OPEN, (__u8 *)&open_command, sizeof(open_command));
+	if (retval)
+		goto exit;
 
-error_exit:
-	--port->open_count;
-	MOD_DEC_USE_COUNT;
+	/* Need to do device specific setup here (control lines, baud rate, etc.) */
+	/* FIXME!!! */
 
-	dbg(__FUNCTION__ " - error_exit");
-	up (&port->sem);
-	
+exit:
+	dbg("%s - exit, retval = %d", __FUNCTION__, retval);
 	return retval;
 }
 
@@ -380,33 +354,25 @@
 {
 	struct whiteheat_min_set	close_command;
 	
-	dbg(__FUNCTION__ " - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 	
-	down (&port->sem);
-	--port->open_count;
+	/* send a close command to the port */
+	/* firmware uses 1 based port numbering */
+	close_command.port = port->number - port->serial->minor + 1;
+	whiteheat_send_cmd (port->serial, WHITEHEAT_CLOSE, (__u8 *)&close_command, sizeof(close_command));
 
-	if (port->open_count <= 0) {
-		/* send a close command to the port */
-		/* firmware uses 1 based port numbering */
-		close_command.port = port->number - port->serial->minor + 1;
-		whiteheat_send_cmd (port->serial, WHITEHEAT_CLOSE, (__u8 *)&close_command, sizeof(close_command));
+	/* Need to change the control lines here */
+	/* FIXME */
 	
-		/* Need to change the control lines here */
-		/* FIXME */
-		
-		/* shutdown our bulk reads and writes */
-		usb_unlink_urb (port->write_urb);
-		usb_unlink_urb (port->read_urb);
-		port->active = 0;
-	}
-	MOD_DEC_USE_COUNT;
-	up (&port->sem);
+	/* shutdown our bulk reads and writes */
+	usb_unlink_urb (port->write_urb);
+	usb_unlink_urb (port->read_urb);
 }
 
 
 static int whiteheat_ioctl (struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg)
 {
-	dbg(__FUNCTION__ " - port %d, cmd 0x%.4x", port->number, cmd);
+	dbg("%s - port %d, cmd 0x%.4x", __FUNCTION__, port->number, cmd);
 
 	return -ENOIOCTLCMD;
 }
@@ -417,12 +383,10 @@
 	unsigned int cflag;
 	struct whiteheat_port_settings port_settings;
 
-	dbg(__FUNCTION__ " -port %d", port->number);
-
-	down (&port->sem);
+	dbg("%s -port %d", __FUNCTION__, port->number);
 
 	if ((!port->tty) || (!port->tty->termios)) {
-		dbg(__FUNCTION__" - no tty structures");
+		dbg("%s - no tty structures", __FUNCTION__);
 		goto exit;
 	}
 	
@@ -431,7 +395,7 @@
 	if (old_termios) {
 		if ((cflag == old_termios->c_cflag) &&
 		    (RELEVANT_IFLAG(port->tty->termios->c_iflag) == RELEVANT_IFLAG(old_termios->c_iflag))) {
-			dbg(__FUNCTION__ " - nothing to change...");
+			dbg("%s - nothing to change...", __FUNCTION__);
 			goto exit;
 		}
 	}
@@ -448,7 +412,7 @@
 		default:
 		case CS8:	port_settings.bits = 8;   break;
 	}
-	dbg(__FUNCTION__ " - data bits = %d", port_settings.bits);
+	dbg("%s - data bits = %d", __FUNCTION__, port_settings.bits);
 	
 	/* determine the parity */
 	if (cflag & PARENB)
@@ -458,14 +422,14 @@
 			port_settings.parity = 'e';
 	else
 		port_settings.parity = 'n';
-	dbg(__FUNCTION__ " - parity = %c", port_settings.parity);
+	dbg("%s - parity = %c", __FUNCTION__, port_settings.parity);
 
 	/* figure out the stop bits requested */
 	if (cflag & CSTOPB)
 		port_settings.stop = 2;
 	else
 		port_settings.stop = 1;
-	dbg(__FUNCTION__ " - stop bits = %d", port_settings.stop);
+	dbg("%s - stop bits = %d", __FUNCTION__, port_settings.stop);
 
 	
 	/* figure out the flow control settings */
@@ -473,7 +437,7 @@
 		port_settings.hflow = (WHITEHEAT_CTS_FLOW | WHITEHEAT_RTS_FLOW);
 	else
 		port_settings.hflow = 0;
-	dbg(__FUNCTION__ " - hardware flow control = %s %s %s %s",
+	dbg("%s - hardware flow control = %s %s %s %s", __FUNCTION__,
 	    (port_settings.hflow & WHITEHEAT_CTS_FLOW) ? "CTS" : "",
 	    (port_settings.hflow & WHITEHEAT_RTS_FLOW) ? "RTS" : "",
 	    (port_settings.hflow & WHITEHEAT_DSR_FLOW) ? "DSR" : "",
@@ -484,15 +448,15 @@
 		port_settings.sflow = 'b';
 	else
 		port_settings.sflow = 'n';
-	dbg(__FUNCTION__ " - software flow control = %c", port_settings.sflow);
+	dbg("%s - software flow control = %c", __FUNCTION__, port_settings.sflow);
 	
 	port_settings.xon = START_CHAR(port->tty);
 	port_settings.xoff = STOP_CHAR(port->tty);
-	dbg(__FUNCTION__ " - XON = %2x, XOFF = %2x", port_settings.xon, port_settings.xoff);
+	dbg("%s - XON = %2x, XOFF = %2x", __FUNCTION__, port_settings.xon, port_settings.xoff);
 
 	/* get the baud rate wanted */
 	port_settings.baud = tty_get_baud_rate(port->tty);
-	dbg(__FUNCTION__ " - baud rate = %d", port_settings.baud);
+	dbg("%s - baud rate = %d", __FUNCTION__, port_settings.baud);
 
 	/* handle any settings that aren't specified in the tty structure */
 	port_settings.lloop = 0;
@@ -501,14 +465,13 @@
 	whiteheat_send_cmd (port->serial, WHITEHEAT_SETUP_PORT, (__u8 *)&port_settings, sizeof(port_settings));
 	
 exit:
-	up (&port->sem);
 	return;
 }
 
 
 static void whiteheat_throttle (struct usb_serial_port *port)
 {
-	dbg(__FUNCTION__" - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* Change the control signals */
 	/* FIXME!!! */
@@ -519,7 +482,7 @@
 
 static void whiteheat_unthrottle (struct usb_serial_port *port)
 {
-	dbg(__FUNCTION__" - port %d", port->number);
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* Change the control signals */
 	/* FIXME!!! */
@@ -541,12 +504,12 @@
  - device renumerated itself and comes up as new device id with all
    firmware download completed.
 */
-static int  whiteheat_fake_startup (struct usb_serial *serial)
+static int whiteheat_fake_startup (struct usb_serial *serial)
 {
 	int response;
 	const struct whiteheat_hex_record *record;
 	
-	dbg(__FUNCTION__);
+	dbg("%s", __FUNCTION__);
 	
 	response = ezusb_set_reset (serial, 1);
 
@@ -555,8 +518,8 @@
 		response = ezusb_writememory (serial, record->address, 
 				(unsigned char *)record->data, record->data_size, 0xa0);
 		if (response < 0) {
-			err(__FUNCTION__ " - ezusb_writememory failed for loader (%d %04X %p %d)", 
-				response, record->address, record->data, record->data_size);
+			err("%s - ezusb_writememory failed for loader (%d %04X %p %d)",
+				__FUNCTION__, response, record->address, record->data, record->data_size);
 			break;
 		}
 		++record;
@@ -572,8 +535,8 @@
 		response = ezusb_writememory (serial, record->address, 
 				(unsigned char *)record->data, record->data_size, 0xa3);
 		if (response < 0) {
-			err(__FUNCTION__ " - ezusb_writememory failed for first firmware step (%d %04X %p %d)", 
-				response, record->address, record->data, record->data_size);
+			err("%s - ezusb_writememory failed for first firmware step (%d %04X %p %d)", 
+				__FUNCTION__, response, record->address, record->data, record->data_size);
 			break;
 		}
 		++record;
@@ -586,8 +549,8 @@
 		response = ezusb_writememory (serial, record->address, 
 				(unsigned char *)record->data, record->data_size, 0xa0);
 		if (response < 0) {
-			err(__FUNCTION__" - ezusb_writememory failed for second firmware step (%d %04X %p %d)", 
-				response, record->address, record->data, record->data_size);
+			err("%s - ezusb_writememory failed for second firmware step (%d %04X %p %d)", 
+				__FUNCTION__, response, record->address, record->data, record->data_size);
 			break;
 		}
 		++record;
@@ -662,16 +625,8 @@
 static void whiteheat_real_shutdown (struct usb_serial *serial)
 {
 	struct usb_serial_port *command_port;
-	int i;
-
-	dbg(__FUNCTION__);
 
-	/* stop reads and writes on all ports */
-	for (i=0; i < serial->num_ports; ++i) {
-		while (serial->port[i].open_count > 0) {
-			whiteheat_close (&serial->port[i], NULL);
-		}
-	}
+	dbg("%s", __FUNCTION__);
 
 	/* free up our private data for our command port */
 	command_port = &serial->port[COMMAND_PORT];
diff -Nur linux-2.4.19.old/drivers/usb/storage/Makefile linux-2.4.19/drivers/usb/storage/Makefile
--- linux-2.4.19.old/drivers/usb/storage/Makefile	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/storage/Makefile	Mon Nov 25 12:27:12 2002
@@ -15,6 +15,7 @@
 usb-storage-obj-$(CONFIG_USB_STORAGE_DEBUG)	+= debug.o
 usb-storage-obj-$(CONFIG_USB_STORAGE_HP8200e)	+= shuttle_usbat.o
 usb-storage-obj-$(CONFIG_USB_STORAGE_SDDR09)	+= sddr09.o
+usb-storage-obj-$(CONFIG_USB_STORAGE_SDDR55)	+= sddr55.o
 usb-storage-obj-$(CONFIG_USB_STORAGE_FREECOM)	+= freecom.o
 usb-storage-obj-$(CONFIG_USB_STORAGE_DPCM)	+= dpcm.o
 usb-storage-obj-$(CONFIG_USB_STORAGE_ISD200)	+= isd200.o
diff -Nur linux-2.4.19.old/drivers/usb/storage/freecom.c linux-2.4.19/drivers/usb/storage/freecom.c
--- linux-2.4.19.old/drivers/usb/storage/freecom.c	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/storage/freecom.c	Mon Nov 25 12:27:12 2002
@@ -34,7 +34,7 @@
 #include "usb.h"
 #include "debug.h"
 #include "freecom.h"
-#include "linux/hdreg.h"
+#include <linux/hdreg.h>
 
 #ifdef CONFIG_USB_STORAGE_DEBUG
 static void pdump (void *, int);
diff -Nur linux-2.4.19.old/drivers/usb/storage/scsiglue.c linux-2.4.19/drivers/usb/storage/scsiglue.c
--- linux-2.4.19.old/drivers/usb/storage/scsiglue.c	Sun Nov 11 19:01:32 2001
+++ linux-2.4.19/drivers/usb/storage/scsiglue.c	Mon Nov 25 12:27:12 2002
@@ -190,7 +190,7 @@
 	}
 
 	/* if we have an urb pending, let's wake the control thread up */
-	if (us->current_urb->status == -EINPROGRESS) {
+	if (!us->current_done.done) {
 		/* cancel the URB -- this will automatically wake the thread */
 		usb_unlink_urb(us->current_urb);
 
diff -Nur linux-2.4.19.old/drivers/usb/storage/sddr55.c linux-2.4.19/drivers/usb/storage/sddr55.c
--- linux-2.4.19.old/drivers/usb/storage/sddr55.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/storage/sddr55.c	Mon Nov 25 12:27:12 2002
@@ -0,0 +1,1134 @@
+/* Driver for SanDisk SDDR-55 SmartMedia reader
+ *
+ * $Id$
+ *
+ * SDDR55 driver v0.1:
+ *
+ * First release
+ *
+ * Current development and maintenance by:
+ *   (c) 2002 Simon Munton
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "transport.h"
+#include "protocol.h"
+#include "usb.h"
+#include "debug.h"
+#include "sddr55.h"
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
+#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))<<8 ) )
+#define LSB_of(s) ((s)&0xFF)
+#define MSB_of(s) ((s)>>8)
+#define PAGESIZE  512
+
+#define set_sense_info(sk, asc, ascq)	\
+    do {				\
+	info->sense_data[2] = sk;	\
+	info->sense_data[12] = asc;	\
+	info->sense_data[13] = ascq;	\
+	} while (0)
+
+
+struct sddr55_card_info {
+	unsigned long	capacity;	/* Size of card in bytes */
+	int		max_log_blks;	/* maximum number of logical blocks */
+	int		pageshift;	/* log2 of pagesize */
+	int		smallpageshift;	/* 1 if pagesize == 256 */
+	int		blocksize;	/* Size of block in pages */
+	int		blockshift;	/* log2 of blocksize */
+	int		blockmask;	/* 2^blockshift - 1 */
+	int		read_only;	/* non zero if card is write protected */
+	int		force_read_only;	/* non zero if we find a map error*/
+	int		*lba_to_pba;	/* logical to physical map */
+	int		*pba_to_lba;	/* physical to logical map */
+	int		fatal_error;	/* set if we detect something nasty */
+	unsigned long 	last_access;	/* number of jiffies since we last talked to device */
+	unsigned char   sense_data[18];
+};
+
+
+#define NOT_ALLOCATED		0xffffffff
+#define BAD_BLOCK		0xffff
+#define CIS_BLOCK		0x400
+#define UNUSED_BLOCK		0x3ff
+
+
+
+static int sddr55_raw_bulk(struct us_data *us, 
+		int direction,
+		unsigned char *data,
+		unsigned int len) {
+
+	int result;
+	int act_len;
+	int pipe;
+
+	if (direction == SCSI_DATA_READ)
+		pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
+	else
+		pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
+
+	result = usb_stor_bulk_msg(us, data, pipe, len, &act_len);
+
+	/* if we stall, we need to clear it before we go on */
+	if (result == -EPIPE) {
+		US_DEBUGP("EPIPE: clearing endpoint halt for"
+			" pipe 0x%x, stalled at %d bytes\n",
+			pipe, act_len);
+		usb_clear_halt(us->pusb_dev, pipe);
+	}
+
+	if (result) {
+
+		/* NAK - that means we've retried a few times already */
+		if (result == -ETIMEDOUT) {
+			US_DEBUGP("usbat_raw_bulk():"
+				" device NAKed\n");
+
+			return US_BULK_TRANSFER_FAILED;
+		}
+
+		/* -ENOENT -- we canceled this transfer */
+		if (result == -ENOENT) {
+			US_DEBUGP("usbat_raw_bulk():"
+				" transfer aborted\n");
+			return US_BULK_TRANSFER_ABORTED;
+		}
+
+		if (result == -EPIPE) {
+			US_DEBUGP("usbat_raw_bulk():"
+				" output pipe stalled\n");
+			return US_BULK_TRANSFER_FAILED;
+		}
+
+		/* the catch-all case */
+		US_DEBUGP("us_transfer_partial(): unknown error\n");
+		return US_BULK_TRANSFER_FAILED;
+	}
+
+	if (act_len != len) {
+		US_DEBUGP("Warning: Transferred only %d bytes\n",
+			act_len);
+		return US_BULK_TRANSFER_SHORT;
+	}
+
+	US_DEBUGP("Transferred %d of %d bytes\n", act_len, len);
+
+	return US_BULK_TRANSFER_GOOD;
+}
+
+/*
+ * Note: direction must be set if command_len == 0.
+ */
+
+static int sddr55_bulk_transport(struct us_data *us,
+			  int direction,
+			  unsigned char *data,
+			  unsigned int len) {
+
+	int result = USB_STOR_TRANSPORT_GOOD;
+	struct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;
+
+	if (len==0)
+		return USB_STOR_TRANSPORT_GOOD;
+
+	info->last_access = jiffies;
+
+#ifdef CONFIG_USB_STORAGE_DEBUG
+	if (direction == SCSI_DATA_WRITE) {
+		int i;
+		char string[64];
+
+		/* Debug-print the first 48 bytes of the write transfer */
+
+		strcpy(string, "wr: ");
+		for (i=0; i<len && i<48; i++) {
+			sprintf(string+strlen(string), "%02X ",
+			  data[i]);
+			if ((i%16)==15) {
+				US_DEBUGP("%s\n", string);
+				strcpy(string, "wr: ");
+			}
+		}
+		if ((i%16)!=0)
+			US_DEBUGP("%s\n", string);
+	}
+#endif
+
+	/* transfer the data */
+
+	US_DEBUGP("SCM data %s transfer %d\n",
+		  ( direction==SCSI_DATA_READ ? "in" : "out"),
+		  len);
+
+	result = sddr55_raw_bulk(us, direction, data, len);
+
+#ifdef CONFIG_USB_STORAGE_DEBUG
+	if (direction == SCSI_DATA_READ) {
+		int i;
+		char string[64];
+
+		/* Debug-print the first 48 bytes of the read transfer */
+
+		strcpy(string, "rd: ");
+		for (i=0; i<len && i<48; i++) {
+			sprintf(string+strlen(string), "%02X ",
+			  data[i]);
+			if ((i%16)==15) {
+				US_DEBUGP("%s\n", string);
+				strcpy(string, "rd: ");
+			}
+		}
+		if ((i%16)!=0)
+			US_DEBUGP("%s\n", string);
+	}
+#endif
+
+	return result;
+}
+
+
+/* check if card inserted, if there is, update read_only status
+ * return non zero if no card
+ */
+
+static int sddr55_status(struct us_data *us)
+{
+	int result;
+	unsigned char command[8] = {
+		0, 0, 0, 0, 0, 0xb0, 0, 0x80
+	};
+	unsigned char status[8];
+	struct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;
+
+	/* send command */
+	result = sddr55_bulk_transport(us,
+		SCSI_DATA_WRITE, command, 8);
+
+	US_DEBUGP("Result for send_command in status %d\n",
+		result);
+
+	if (result != US_BULK_TRANSFER_GOOD) {
+		set_sense_info (4, 0, 0);	/* hardware error */
+		return result;
+	}
+
+	result = sddr55_bulk_transport(us,
+		SCSI_DATA_READ, status,	4);
+
+	/* expect to get short transfer if no card fitted */
+	if (result == US_BULK_TRANSFER_SHORT) {
+		/* had a short transfer, no card inserted, free map memory */
+		if (info->lba_to_pba)
+			kfree(info->lba_to_pba);
+		if (info->pba_to_lba)
+			kfree(info->pba_to_lba);
+		info->lba_to_pba = NULL;
+		info->pba_to_lba = NULL;
+
+		info->fatal_error = 0;
+		info->force_read_only = 0;
+
+		set_sense_info (2, 0x3a, 0);	/* not ready, medium not present */
+		return result;
+	}
+
+	if (result != US_BULK_TRANSFER_GOOD) {
+		set_sense_info (4, 0, 0);	/* hardware error */
+		return result;
+	}
+	
+	/* check write protect status */
+	info->read_only = (status[0] & 0x20);
+
+	/* now read status */
+	result = sddr55_bulk_transport(us,
+		SCSI_DATA_READ, status,	2);
+
+	if (result != US_BULK_TRANSFER_GOOD) {
+		set_sense_info (4, 0, 0);	/* hardware error */
+	}
+
+	return result;
+}
+
+
+static int sddr55_read_data(struct us_data *us,
+		unsigned int lba,
+		unsigned int page,
+		unsigned short sectors,
+		unsigned char *content,
+		int use_sg) {
+
+	int result;
+	unsigned char command[8] = {
+		0, 0, 0, 0, 0, 0xb0, 0, 0x85
+	};
+	unsigned char status[8];
+	struct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;
+
+	unsigned int pba;
+	unsigned long address;
+
+	unsigned short pages;
+	unsigned char *buffer = NULL;
+	unsigned char *ptr;
+	struct scatterlist *sg = NULL;
+	int i;
+	int len;
+	int transferred;
+
+	// If we're using scatter-gather, we have to create a new
+	// buffer to read all of the data in first, since a
+	// scatter-gather buffer could in theory start in the middle
+	// of a page, which would be bad. A developer who wants a
+	// challenge might want to write a limited-buffer
+	// version of this code.
+
+	len = sectors * PAGESIZE;
+
+	if (use_sg) {
+		sg = (struct scatterlist *)content;
+		buffer = kmalloc(len, GFP_NOIO);
+		if (buffer == NULL)
+			return USB_STOR_TRANSPORT_ERROR;
+		ptr = buffer;
+	} else
+		ptr = content;
+
+	// This could be made much more efficient by checking for
+	// contiguous LBA's. Another exercise left to the student.
+
+	while (sectors>0) {
+
+		/* have we got to end? */
+		if (lba >= info->max_log_blks)
+			break;
+
+		pba = info->lba_to_pba[lba];
+
+		// Read as many sectors as possible in this block
+
+		pages = info->blocksize - page;
+		if (pages > (sectors << info->smallpageshift))
+			pages = (sectors << info->smallpageshift);
+
+		US_DEBUGP("Read %02X pages, from PBA %04X"
+			" (LBA %04X) page %02X\n",
+			pages, pba, lba, page);
+
+		if (pba == NOT_ALLOCATED) {
+			/* no pba for this lba, fill with zeroes */
+			memset (ptr, 0, pages << info->pageshift);
+		} else {
+
+			address = (pba << info->blockshift) + page;
+
+			command[1] = LSB_of(address>>16);
+			command[2] = LSB_of(address>>8);
+			command[3] = LSB_of(address);
+
+			command[6] = LSB_of(pages << (1 - info->smallpageshift));
+
+			/* send command */
+			result = sddr55_bulk_transport(us,
+				SCSI_DATA_WRITE, command, 8);
+
+			US_DEBUGP("Result for send_command in read_data %d\n",
+				result);
+
+			if (result != US_BULK_TRANSFER_GOOD) {
+				if (use_sg)
+					kfree(buffer);
+				return result;
+			}
+
+			/* read data */
+			result = sddr55_bulk_transport(us,
+				SCSI_DATA_READ, ptr,
+				pages<<info->pageshift);
+
+			if (result != US_BULK_TRANSFER_GOOD) {
+				if (use_sg)
+					kfree(buffer);
+				return result;
+			}
+
+			/* now read status */
+			result = sddr55_bulk_transport(us,
+				SCSI_DATA_READ, status, 2);
+
+			if (result != US_BULK_TRANSFER_GOOD) {
+				if (use_sg)
+					kfree(buffer);
+				return result;
+			}
+
+			/* check status for error */
+			if (status[0] == 0xff && status[1] == 0x4) {
+				set_sense_info (3, 0x11, 0);
+				if (use_sg)
+					kfree(buffer);
+
+				return USB_STOR_TRANSPORT_FAILED;
+			}
+
+		}
+
+		page = 0;
+		lba++;
+		sectors -= pages >> info->smallpageshift;
+		ptr += (pages << info->pageshift);
+	}
+
+	if (use_sg) {
+		transferred = 0;
+		for (i=0; i<use_sg && transferred<len; i++) {
+			memcpy(sg[i].address, buffer+transferred,
+				len-transferred > sg[i].length ?
+					sg[i].length : len-transferred);
+			transferred += sg[i].length;
+		}
+		kfree(buffer);
+	}
+
+	return USB_STOR_TRANSPORT_GOOD;
+}
+
+static int sddr55_write_data(struct us_data *us,
+		unsigned int lba,
+		unsigned int page,
+		unsigned short sectors,
+		unsigned char *content,
+		int use_sg) {
+
+	int result;
+	unsigned char command[8] = {
+		0, 0, 0, 0, 0, 0xb0, 0, 0x86
+	};
+	unsigned char status[8];
+	struct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;
+
+	unsigned int pba;
+	unsigned int new_pba;
+	unsigned long address;
+
+	unsigned short pages;
+	unsigned char *buffer = NULL;
+	unsigned char *ptr;
+	struct scatterlist *sg = NULL;
+	int i;
+	int len;
+	int transferred;
+
+	/* check if we are allowed to write */
+	if (info->read_only || info->force_read_only) {
+		set_sense_info (7, 0x27, 0);	/* read only */
+		return USB_STOR_TRANSPORT_FAILED;
+	}
+
+	// If we're using scatter-gather, we have to create a new
+	// buffer to write all of the data in first, since a
+	// scatter-gather buffer could in theory start in the middle
+	// of a page, which would be bad. A developer who wants a
+	// challenge might want to write a limited-buffer
+	// version of this code.
+
+	len = sectors * PAGESIZE;
+
+	if (use_sg) {
+		sg = (struct scatterlist *)content;
+		buffer = kmalloc(len, GFP_NOIO);
+		if (buffer == NULL)
+			return USB_STOR_TRANSPORT_ERROR;
+
+		transferred = 0;
+		for (i=0; i<use_sg && transferred<len; i++) {
+			memcpy(buffer+transferred, sg[i].address,
+				len-transferred > sg[i].length ?
+					sg[i].length : len-transferred);
+			transferred += sg[i].length;
+		}
+
+		ptr = buffer;
+	} else
+		ptr = content;
+
+	while (sectors > 0) {
+
+		/* have we got to end? */
+		if (lba >= info->max_log_blks)
+			break;
+
+		pba = info->lba_to_pba[lba];
+
+		// Write as many sectors as possible in this block
+
+		pages = info->blocksize - page;
+		if (pages > (sectors << info->smallpageshift))
+			pages = (sectors << info->smallpageshift);
+
+		US_DEBUGP("Write %02X pages, to PBA %04X"
+			" (LBA %04X) page %02X\n",
+			pages, pba, lba, page);
+			
+		command[4] = 0;
+
+		if (pba == NOT_ALLOCATED) {
+			/* no pba allocated for this lba, find a free pba to use */
+
+			int max_pba = (info->max_log_blks / 250 ) * 256;
+			int found_count = 0;
+			int found_pba = -1;
+
+			/* set pba to first block in zone lba is in */
+			pba = (lba / 1000) * 1024;
+
+			US_DEBUGP("No PBA for LBA %04X\n",lba);
+
+			if (max_pba > 1024)
+				max_pba = 1024;
+
+			/* scan through the map lookiong for an unused block
+			 * leave 16 unused blocks at start (or as many as possible)
+			 * since the sddr55 seems to reuse a used block when it shouldn't
+			 * if we don't leave space */
+			for (i = 0; i < max_pba; i++, pba++) {
+				if (info->pba_to_lba[pba] == UNUSED_BLOCK) {
+					found_pba = pba;
+					if (found_count++ > 16)
+						break;
+				}
+			}
+
+			pba = found_pba;
+
+			if (pba == -1) {
+				/* oh dear, couldn't find an unallocated block */
+				US_DEBUGP("Couldn't find unallocated block\n");
+
+				set_sense_info (3, 0x31, 0);	/* medium error */
+
+				if (use_sg)
+					kfree(buffer);
+
+				return USB_STOR_TRANSPORT_FAILED;
+			}
+
+			US_DEBUGP("Allocating PBA %04X for LBA %04X\n", pba, lba);
+
+			/* set writing to unallocated block flag */
+			command[4] = 0x40;
+		}
+
+		address = (pba << info->blockshift) + page;
+
+		command[1] = LSB_of(address>>16);
+		command[2] = LSB_of(address>>8); 
+		command[3] = LSB_of(address);
+
+		/* set the lba into the command, modulo 1000 */
+		command[0] = LSB_of(lba % 1000);
+		command[6] = MSB_of(lba % 1000);
+
+		command[4] |= LSB_of(pages >> info->smallpageshift);
+
+		/* send command */
+		result = sddr55_bulk_transport(us,
+			SCSI_DATA_WRITE, command, 8);
+
+		if (result != US_BULK_TRANSFER_GOOD) {
+			US_DEBUGP("Result for send_command in write_data %d\n",
+			result);
+
+			set_sense_info (3, 0x3, 0);	/* peripheral write error */
+			
+			if (use_sg)
+				kfree(buffer);
+			return result;
+		}
+
+		/* send the data */
+		result = sddr55_bulk_transport(us,
+			SCSI_DATA_WRITE, ptr,
+			pages<<info->pageshift);
+
+		if (result != US_BULK_TRANSFER_GOOD) {
+			US_DEBUGP("Result for send_data in write_data %d\n",
+			result);
+
+			set_sense_info (3, 0x3, 0);	/* peripheral write error */
+
+			if (use_sg)
+				kfree(buffer);
+			return result;
+		}
+
+		/* now read status */
+		result = sddr55_bulk_transport(us,
+			SCSI_DATA_READ, status,	6);
+
+		if (result != US_BULK_TRANSFER_GOOD) {
+			US_DEBUGP("Result for get_status in write_data %d\n",
+			result);
+
+			set_sense_info (3, 0x3, 0);	/* peripheral write error */
+
+			if (use_sg)
+				kfree(buffer);
+			return result;
+		}
+
+		new_pba = (status[3] + (status[4] << 8) + (status[5] << 16)) >> info->blockshift;
+
+		/* check status for error */
+		if (status[0] == 0xff && status[1] == 0x4) {
+			set_sense_info (3, 0x0c, 0);
+			if (use_sg)
+				kfree(buffer);
+
+			info->pba_to_lba[new_pba] = BAD_BLOCK;
+
+			return USB_STOR_TRANSPORT_FAILED;
+		}
+
+		US_DEBUGP("Updating maps for LBA %04X: old PBA %04X, new PBA %04X\n",
+			lba, pba, new_pba);
+
+		/* update the lba<->pba maps, note new_pba might be the same as pba */
+		info->lba_to_pba[lba] = new_pba;
+		info->pba_to_lba[pba] = UNUSED_BLOCK;
+
+		/* check that new_pba wasn't already being used */
+		if (info->pba_to_lba[new_pba] != UNUSED_BLOCK) {
+			printk(KERN_ERR "sddr55 error: new PBA %04X already in use for LBA %04X\n",
+				new_pba, info->pba_to_lba[new_pba]);
+			info->fatal_error = 1;
+			set_sense_info (3, 0x31, 0);
+			if (use_sg)
+				kfree(buffer);
+
+			return USB_STOR_TRANSPORT_FAILED;
+		}
+
+		/* update the pba<->lba maps for new_pba */
+		info->pba_to_lba[new_pba] = lba % 1000;
+
+		page = 0;
+		lba++;
+		sectors -= pages >> info->smallpageshift;
+		ptr += (pages << info->pageshift);
+	}
+
+	if (use_sg) {
+		kfree(buffer);
+	}
+
+	return USB_STOR_TRANSPORT_GOOD;
+}
+
+static int sddr55_read_deviceID(struct us_data *us,
+		unsigned char *manufacturerID,
+		unsigned char *deviceID) {
+
+	int result;
+	unsigned char command[8] = {
+		0, 0, 0, 0, 0, 0xb0, 0, 0x84
+	};
+	unsigned char content[64];
+
+	result = sddr55_bulk_transport(us, SCSI_DATA_WRITE, command, 8);
+
+	US_DEBUGP("Result of send_control for device ID is %d\n",
+		result);
+
+	if (result != US_BULK_TRANSFER_GOOD)
+		return result;
+
+	result = sddr55_bulk_transport(us,
+		SCSI_DATA_READ, content, 4);
+
+	if (result != US_BULK_TRANSFER_GOOD)
+		return result;
+
+	*manufacturerID = content[0];
+	*deviceID = content[1];
+
+	if (content[0] != 0xff)	{
+    		result = sddr55_bulk_transport(us,
+			SCSI_DATA_READ, content, 2);
+	}
+
+	return result;
+}
+
+
+int sddr55_reset(struct us_data *us) {
+	return 0;
+}
+
+
+static unsigned long sddr55_get_capacity(struct us_data *us) {
+
+	unsigned char manufacturerID;
+	unsigned char deviceID;
+	int result;
+	struct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;
+
+	US_DEBUGP("Reading capacity...\n");
+
+	result = sddr55_read_deviceID(us,
+		&manufacturerID,
+		&deviceID);
+
+	US_DEBUGP("Result of read_deviceID is %d\n",
+		result);
+
+	if (result != US_BULK_TRANSFER_GOOD)
+		return 0;
+
+	US_DEBUGP("Device ID = %02X\n", deviceID);
+	US_DEBUGP("Manuf  ID = %02X\n", manufacturerID);
+
+	info->pageshift = 9;
+	info->smallpageshift = 0;
+	info->blocksize = 16;
+	info->blockshift = 4;
+	info->blockmask = 15;
+
+	switch (deviceID) {
+
+	case 0x6e: // 1MB
+	case 0xe8:
+	case 0xec:
+		info->pageshift = 8;
+		info->smallpageshift = 1;
+		return 0x00100000;
+
+	case 0xea: // 2MB
+	case 0x64:
+		info->pageshift = 8;
+		info->smallpageshift = 1;
+	case 0x5d: // 5d is a ROM card with pagesize 512.
+		return 0x00200000;
+
+	case 0xe3: // 4MB
+	case 0xe5:
+	case 0x6b:
+	case 0xd5:
+		return 0x00400000;
+
+	case 0xe6: // 8MB
+	case 0xd6:
+		return 0x00800000;
+
+	case 0x73: // 16MB
+		info->blocksize = 32;
+		info->blockshift = 5;
+		info->blockmask = 31;
+		return 0x01000000;
+
+	case 0x75: // 32MB
+		info->blocksize = 32;
+		info->blockshift = 5;
+		info->blockmask = 31;
+		return 0x02000000;
+
+	case 0x76: // 64MB
+		info->blocksize = 32;
+		info->blockshift = 5;
+		info->blockmask = 31;
+		return 0x04000000;
+
+	case 0x79: // 128MB
+		info->blocksize = 32;
+		info->blockshift = 5;
+		info->blockmask = 31;
+		return 0x08000000;
+
+	default: // unknown
+		return 0;
+
+	}
+}
+
+static int sddr55_read_map(struct us_data *us) {
+
+	struct sddr55_card_info *info = (struct sddr55_card_info *)(us->extra);
+	int numblocks;
+	unsigned char *buffer;
+	unsigned char command[8] = { 0, 0, 0, 0, 0, 0xb0, 0, 0x8a};	
+	int i;
+	unsigned short lba;
+	unsigned short max_lba;
+	int result;
+
+	if (!info->capacity)
+		return -1;
+
+	numblocks = info->capacity >> (info->blockshift + info->pageshift);
+	
+	buffer = kmalloc( numblocks * 2, GFP_NOIO );
+	
+	if (!buffer)
+		return -1;
+
+	command[6] = numblocks * 2 / 256;
+
+	result = sddr55_bulk_transport(us, SCSI_DATA_WRITE, command, 8);
+
+	if ( result != US_BULK_TRANSFER_GOOD) {
+		kfree (buffer);
+		return -1;
+	}
+
+	result = sddr55_bulk_transport(us, SCSI_DATA_READ, buffer, numblocks * 2);
+
+	if ( result != US_BULK_TRANSFER_GOOD) {
+		kfree (buffer);
+		return -1;
+	}
+
+	result = sddr55_bulk_transport(us, SCSI_DATA_READ, command, 2);
+
+	if ( result != US_BULK_TRANSFER_GOOD) {
+		kfree (buffer);
+		return -1;
+	}
+
+	if (info->lba_to_pba)
+		kfree(info->lba_to_pba);
+	if (info->pba_to_lba)
+		kfree(info->pba_to_lba);
+	info->lba_to_pba = kmalloc(numblocks*sizeof(int), GFP_NOIO);
+	info->pba_to_lba = kmalloc(numblocks*sizeof(int), GFP_NOIO);
+
+	if (info->lba_to_pba == NULL || info->pba_to_lba == NULL) {
+		if (info->lba_to_pba != NULL)
+			kfree(info->lba_to_pba);
+		if (info->pba_to_lba != NULL)
+			kfree(info->pba_to_lba);
+		info->lba_to_pba = NULL;
+		info->pba_to_lba = NULL;
+		kfree(buffer);
+		return -1;
+	}
+
+	memset(info->lba_to_pba, 0xff, numblocks*sizeof(int));
+	memset(info->pba_to_lba, 0xff, numblocks*sizeof(int));
+
+	/* set maximum lba */
+	max_lba = info->max_log_blks;
+	if (max_lba > 1000)
+		max_lba = 1000;
+
+	// Each block is 64 bytes of control data, so block i is located in
+	// scatterlist block i*64/128k = i*(2^6)*(2^-17) = i*(2^-11)
+
+	for (i=0; i<numblocks; i++) {
+		int zone = i / 1024;
+
+		lba = short_pack(buffer[i * 2], buffer[i * 2 + 1]);
+
+			/* Every 1024 physical blocks ("zone"), the LBA numbers
+			 * go back to zero, but are within a higher
+			 * block of LBA's. Also, there is a maximum of
+			 * 1000 LBA's per zone. In other words, in PBA
+			 * 1024-2047 you will find LBA 0-999 which are
+			 * really LBA 1000-1999. Yes, this wastes 24
+			 * physical blocks per zone. Go figure. 
+			 * These devices can have blocks go bad, so there
+			 * are 24 spare blocks to use when blocks do go bad.
+			 */
+
+			/* SDDR55 returns 0xffff for a bad block, and 0x400 for the 
+			 * CIS block. (Is this true for cards 8MB or less??)
+			 * Record these in the physical to logical map
+			 */ 
+
+		info->pba_to_lba[i] = lba;
+
+		if (lba >= max_lba) {
+			continue;
+		}
+		
+		if (info->lba_to_pba[lba + zone * 1000] != NOT_ALLOCATED &&
+		    !info->force_read_only) {
+			printk("sddr55: map inconsistency at LBA %04X\n", lba + zone * 1000);
+			info->force_read_only = 1;
+		}
+
+		if (lba<0x10 || (lba>=0x3E0 && lba<0x3EF))
+			US_DEBUGP("LBA %04X <-> PBA %04X\n", lba, i);
+
+		info->lba_to_pba[lba + zone * 1000] = i;
+	}
+
+	kfree(buffer);
+	return 0;
+}
+
+
+static void sddr55_card_info_destructor(void *extra) {
+	struct sddr55_card_info *info = (struct sddr55_card_info *)extra;
+
+	if (!extra)
+		return;
+
+	if (info->lba_to_pba)
+		kfree(info->lba_to_pba);
+	if (info->pba_to_lba)
+		kfree(info->pba_to_lba);
+}
+
+
+/*
+ * Transport for the Sandisk SDDR-55
+ */
+int sddr55_transport(Scsi_Cmnd *srb, struct us_data *us)
+{
+	int result;
+	int i;
+	unsigned char inquiry_response[36] = {
+		0x00, 0x80, 0x00, 0x02, 0x1F, 0x00, 0x00, 0x00
+	};
+	unsigned char mode_page_01[16] = { // write-protected for now
+		0x03, 0x00, 0x80, 0x00,
+		0x01, 0x0A,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	unsigned char *ptr;
+	unsigned long capacity;
+	unsigned int lba;
+	unsigned int pba;
+	unsigned int page;
+	unsigned short pages;
+	struct sddr55_card_info *info;
+
+	if (!us->extra) {
+		us->extra = kmalloc(
+			sizeof(struct sddr55_card_info), GFP_NOIO);
+		if (!us->extra)
+			return USB_STOR_TRANSPORT_ERROR;
+		memset(us->extra, 0, sizeof(struct sddr55_card_info));
+		us->extra_destructor = sddr55_card_info_destructor;
+	}
+
+	info = (struct sddr55_card_info *)(us->extra);
+
+	ptr = (unsigned char *)srb->request_buffer;
+
+	if (srb->cmnd[0] == REQUEST_SENSE) {
+		i = srb->cmnd[4];
+
+		if (i > sizeof info->sense_data)
+			i = sizeof info->sense_data;
+
+
+		US_DEBUGP("SDDR55: request sense %02x/%02x/%02x\n", info->sense_data[2], info->sense_data[12], info->sense_data[13]);
+
+		info->sense_data[0] = 0x70;
+		info->sense_data[7] = 10;
+
+		memcpy (ptr, info->sense_data, i);
+		memset (info->sense_data, 0, sizeof info->sense_data);
+
+		return USB_STOR_TRANSPORT_GOOD;
+	}
+
+	memset (info->sense_data, 0, sizeof info->sense_data);
+
+	/* Dummy up a response for INQUIRY since SDDR55 doesn't
+	   respond to INQUIRY commands */
+
+	if (srb->cmnd[0] == INQUIRY) {
+		memset(inquiry_response+8, 0, 28);
+		fill_inquiry_response(us, inquiry_response, 36);
+		return USB_STOR_TRANSPORT_GOOD;
+	}
+
+	/* only check card status if the map isn't allocated, ie no card seen yet
+	 * or if it's been over half a second since we last accessed it
+	 */
+	if (info->lba_to_pba == NULL || time_after(jiffies, info->last_access + HZ/2)) {
+
+		/* check to see if a card is fitted */
+		result = sddr55_status (us);
+		if (result) {
+			result = sddr55_status (us);
+			if (!result) {
+			set_sense_info (6, 0x28, 0);	/* new media, set unit attention, not ready to ready */
+			}
+			return USB_STOR_TRANSPORT_FAILED;
+		}
+	}
+
+	/* if we detected a problem with the map when writing, don't allow any more access */
+	if (info->fatal_error) {
+
+		set_sense_info (3, 0x31, 0);
+		return USB_STOR_TRANSPORT_FAILED;
+	}
+
+	if (srb->cmnd[0] == READ_CAPACITY) {
+
+		capacity = sddr55_get_capacity(us);
+
+		if (!capacity) {
+			set_sense_info (3, 0x30, 0);	/* incompatible medium */
+			return USB_STOR_TRANSPORT_FAILED;
+		}
+
+		info->capacity = capacity;
+
+                /* figure out the maximum logical block number, allowing for the fact
+                 * that only 250 out of every 256 are used */
+		info->max_log_blks = ((info->capacity >> (info->pageshift + info->blockshift)) / 256) * 250;
+
+		/* Last page in the card, adjust as we only use 250 out of every 256 pages */
+		capacity = (capacity / 256) * 250;
+
+		capacity /= PAGESIZE;
+		capacity--;
+
+		ptr[0] = MSB_of(capacity>>16);
+		ptr[1] = LSB_of(capacity>>16);
+		ptr[2] = MSB_of(capacity&0xFFFF);
+		ptr[3] = LSB_of(capacity&0xFFFF);
+
+		// The page size
+
+		ptr[4] = MSB_of(PAGESIZE>>16);
+		ptr[5] = LSB_of(PAGESIZE>>16);
+		ptr[6] = MSB_of(PAGESIZE&0xFFFF);
+		ptr[7] = LSB_of(PAGESIZE&0xFFFF);
+
+		sddr55_read_map(us);
+
+		return USB_STOR_TRANSPORT_GOOD;
+	}
+
+	if (srb->cmnd[0] == MODE_SENSE) {
+
+		mode_page_01[2] = (info->read_only || info->force_read_only) ? 0x80 : 0;
+
+		if ( (srb->cmnd[2] & 0x3F) == 0x01 ) {
+
+			US_DEBUGP(
+			  "SDDR55: Dummy up request for mode page 1\n");
+
+			if (ptr==NULL || 
+			  srb->request_bufflen<sizeof(mode_page_01)) {
+				set_sense_info (5, 0x24, 0);	/* invalid field in command */
+				return USB_STOR_TRANSPORT_FAILED;
+			}
+
+			memcpy(ptr, mode_page_01, sizeof(mode_page_01));
+			return USB_STOR_TRANSPORT_GOOD;
+
+		} else if ( (srb->cmnd[2] & 0x3F) == 0x3F ) {
+
+			US_DEBUGP(
+			  "SDDR55: Dummy up request for all mode pages\n");
+
+			if (ptr==NULL || 
+			  srb->request_bufflen<sizeof(mode_page_01)) {
+				set_sense_info (5, 0x24, 0);	/* invalid field in command */
+				return USB_STOR_TRANSPORT_FAILED;
+			}
+
+			memcpy(ptr, mode_page_01, sizeof(mode_page_01));
+			return USB_STOR_TRANSPORT_GOOD;
+		}
+
+		set_sense_info (5, 0x24, 0);	/* invalid field in command */
+
+		return USB_STOR_TRANSPORT_FAILED;
+	}
+
+	if (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {
+
+		US_DEBUGP(
+		  "SDDR55: %s medium removal. Not that I can do"
+		  " anything about it...\n",
+		  (srb->cmnd[4]&0x03) ? "Prevent" : "Allow");
+
+		return USB_STOR_TRANSPORT_GOOD;
+
+	}
+
+	if (srb->cmnd[0] == READ_10 || srb->cmnd[0] == WRITE_10) {
+
+		page = short_pack(srb->cmnd[3], srb->cmnd[2]);
+		page <<= 16;
+		page |= short_pack(srb->cmnd[5], srb->cmnd[4]);
+		pages = short_pack(srb->cmnd[8], srb->cmnd[7]);
+
+		page <<= info->smallpageshift;
+
+		// convert page to block and page-within-block
+
+		lba = page >> info->blockshift;
+		page = page & info->blockmask;
+
+		// locate physical block corresponding to logical block
+
+		if (lba >= info->max_log_blks) {
+
+			US_DEBUGP("Error: Requested LBA %04X exceeds maximum "
+			  "block %04X\n", lba, info->max_log_blks-1);
+
+			set_sense_info (5, 0x24, 0);	/* invalid field in command */
+
+			return USB_STOR_TRANSPORT_FAILED;
+		}
+
+		pba = info->lba_to_pba[lba];
+
+		if (srb->cmnd[0] == WRITE_10) {
+			US_DEBUGP("WRITE_10: write block %04X (LBA %04X) page %01X"
+			        " pages %d\n",
+			        pba, lba, page, pages);
+
+			return sddr55_write_data(us, lba, page, pages, ptr, srb->use_sg);
+		} else {
+			US_DEBUGP("READ_10: read block %04X (LBA %04X) page %01X"
+			        " pages %d\n",
+			        pba, lba, page, pages);
+
+			return sddr55_read_data(us, lba, page, pages, ptr, srb->use_sg);
+		}
+	}
+
+
+	if (srb->cmnd[0] == TEST_UNIT_READY) {
+		return USB_STOR_TRANSPORT_GOOD;
+	}
+
+	if (srb->cmnd[0] == START_STOP) {
+		return USB_STOR_TRANSPORT_GOOD;
+	}
+
+	set_sense_info (5, 0x20, 0);	/* illegal command */
+
+	return USB_STOR_TRANSPORT_FAILED; // FIXME: sense buffer?
+}
+
diff -Nur linux-2.4.19.old/drivers/usb/storage/sddr55.h linux-2.4.19/drivers/usb/storage/sddr55.h
--- linux-2.4.19.old/drivers/usb/storage/sddr55.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/storage/sddr55.h	Mon Nov 25 12:27:12 2002
@@ -0,0 +1,34 @@
+/* Driver for SanDisk SDDR-55 SmartMedia reader
+ * Header File
+ *
+ * $Id$
+ *
+ * Current development and maintenance by:
+ *   (c) 2002 Simon Munton
+ *
+ * See sddr55.c for more explanation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _USB_SHUTTLE_EUSB_SDDR55_H
+#define _USB_SHUTTLE_EUSB_SDDR55_H
+
+/* Sandisk SDDR-55 stuff */
+
+extern int sddr55_transport(Scsi_Cmnd *srb, struct us_data *us);
+extern int sddr55_reset(struct us_data *us);
+
+#endif
diff -Nur linux-2.4.19.old/drivers/usb/storage/transport.c linux-2.4.19/drivers/usb/storage/transport.c
--- linux-2.4.19.old/drivers/usb/storage/transport.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/storage/transport.c	Mon Nov 25 12:27:12 2002
@@ -346,7 +346,7 @@
 /* This is the completion handler which will wake us up when an URB
  * completes.
  */
-static void usb_stor_blocking_completion(urb_t *urb)
+static void usb_stor_blocking_completion(struct urb *urb)
 {
 	struct completion *urb_done_ptr = (struct completion *)urb->context;
 
@@ -360,24 +360,23 @@
 			 u8 request, u8 requesttype, u16 value, u16 index, 
 			 void *data, u16 size)
 {
-	struct completion urb_done;
 	int status;
-	devrequest *dr;
+	struct usb_ctrlrequest *dr;
 
 	/* allocate the device request structure */
-	dr = kmalloc(sizeof(devrequest), GFP_NOIO);
+	dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);
 	if (!dr)
 		return -ENOMEM;
 
 	/* fill in the structure */
-	dr->requesttype = requesttype;
-	dr->request = request;
-	dr->value = cpu_to_le16(value);
-	dr->index = cpu_to_le16(index);
-	dr->length = cpu_to_le16(size);
+	dr->bRequestType = requesttype;
+	dr->bRequest = request;
+	dr->wValue = cpu_to_le16(value);
+	dr->wIndex = cpu_to_le16(index);
+	dr->wLength = cpu_to_le16(size);
 
 	/* set up data structures for the wakeup system */
-	init_completion(&urb_done);
+	init_completion(&us->current_done);
 
 	/* lock the URB */
 	down(&(us->current_urb_sem));
@@ -385,7 +384,7 @@
 	/* fill the URB */
 	FILL_CONTROL_URB(us->current_urb, us->pusb_dev, pipe, 
 			 (unsigned char*) dr, data, size, 
-			 usb_stor_blocking_completion, &urb_done);
+			 usb_stor_blocking_completion, &us->current_done);
 	us->current_urb->actual_length = 0;
 	us->current_urb->error_count = 0;
 	us->current_urb->transfer_flags = USB_ASYNC_UNLINK;
@@ -401,7 +400,7 @@
 
 	/* wait for the completion of the URB */
 	up(&(us->current_urb_sem));
-	wait_for_completion(&urb_done);
+	wait_for_completion(&us->current_done);
 	down(&(us->current_urb_sem));
 
 	/* return the actual length of the data transferred if no error*/
@@ -421,18 +420,17 @@
 int usb_stor_bulk_msg(struct us_data *us, void *data, int pipe,
 		      unsigned int len, unsigned int *act_len)
 {
-	struct completion urb_done;
 	int status;
 
 	/* set up data structures for the wakeup system */
-	init_completion(&urb_done);
+	init_completion(&us->current_done);
 
 	/* lock the URB */
 	down(&(us->current_urb_sem));
 
 	/* fill the URB */
 	FILL_BULK_URB(us->current_urb, us->pusb_dev, pipe, data, len,
-		      usb_stor_blocking_completion, &urb_done);
+		      usb_stor_blocking_completion, &us->current_done);
 	us->current_urb->actual_length = 0;
 	us->current_urb->error_count = 0;
 	us->current_urb->transfer_flags = USB_ASYNC_UNLINK;
@@ -447,7 +445,7 @@
 
 	/* wait for the completion of the URB */
 	up(&(us->current_urb_sem));
-	wait_for_completion(&urb_done);
+	wait_for_completion(&us->current_done);
 	down(&(us->current_urb_sem));
 
 	/* return the actual length of the data transferred */
@@ -1040,10 +1038,15 @@
 /* Determine what the maximum LUN supported is */
 int usb_stor_Bulk_max_lun(struct us_data *us)
 {
-	unsigned char data;
+	unsigned char *data;
 	int result;
 	int pipe;
 
+	data = kmalloc(sizeof *data, GFP_KERNEL);
+	if (!data) {
+		return 0;
+	}
+
 	/* issue the command -- use usb_control_msg() because
 	 *  the state machine is not yet alive */
 	pipe = usb_rcvctrlpipe(us->pusb_dev, 0);
@@ -1051,14 +1054,19 @@
 				 US_BULK_GET_MAX_LUN, 
 				 USB_DIR_IN | USB_TYPE_CLASS | 
 				 USB_RECIP_INTERFACE,
-				 0, us->ifnum, &data, sizeof(data), HZ);
+				 0, us->ifnum, data, sizeof(data), HZ);
 
 	US_DEBUGP("GetMaxLUN command result is %d, data is %d\n", 
-		  result, data);
+		  result, *data);
 
 	/* if we have a successful request, return the result */
-	if (result == 1)
-		return data;
+	if (result == 1) {
+		result = *data;
+		kfree(data);
+		return result;
+	} else {
+		kfree(data);
+	}
 
 	/* if we get a STALL, clear the stall */
 	if (result == -EPIPE) {
@@ -1077,41 +1085,54 @@
 
 int usb_stor_Bulk_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
-	struct bulk_cb_wrap bcb;
-	struct bulk_cs_wrap bcs;
+	struct bulk_cb_wrap *bcb;
+	struct bulk_cs_wrap *bcs;
 	int result;
 	int pipe;
 	int partial;
+	int ret = USB_STOR_TRANSPORT_ERROR;
+
+	bcb = kmalloc(sizeof *bcb, in_interrupt() ? GFP_ATOMIC : GFP_NOIO);
+	if (!bcb) {
+		return USB_STOR_TRANSPORT_ERROR;
+	}
+	bcs = kmalloc(sizeof *bcs, in_interrupt() ? GFP_ATOMIC : GFP_NOIO);
+	if (!bcs) {
+		kfree(bcb);
+		return USB_STOR_TRANSPORT_ERROR;
+	}
 
 	/* set up the command wrapper */
-	bcb.Signature = cpu_to_le32(US_BULK_CB_SIGN);
-	bcb.DataTransferLength = cpu_to_le32(usb_stor_transfer_length(srb));
-	bcb.Flags = srb->sc_data_direction == SCSI_DATA_READ ? 1 << 7 : 0;
-	bcb.Tag = srb->serial_number;
-	bcb.Lun = srb->cmnd[1] >> 5;
+	bcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);
+	bcb->DataTransferLength = cpu_to_le32(usb_stor_transfer_length(srb));
+	bcb->Flags = srb->sc_data_direction == SCSI_DATA_READ ? 1 << 7 : 0;
+	bcb->Tag = srb->serial_number;
+	bcb->Lun = srb->cmnd[1] >> 5;
 	if (us->flags & US_FL_SCM_MULT_TARG)
-		bcb.Lun |= srb->target << 4;
-	bcb.Length = srb->cmd_len;
+		bcb->Lun |= srb->target << 4;
+	bcb->Length = srb->cmd_len;
 
 	/* construct the pipe handle */
 	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
 
 	/* copy the command payload */
-	memset(bcb.CDB, 0, sizeof(bcb.CDB));
-	memcpy(bcb.CDB, srb->cmnd, bcb.Length);
+	memset(bcb->CDB, 0, sizeof(bcb->CDB));
+	memcpy(bcb->CDB, srb->cmnd, bcb->Length);
 
 	/* send it to out endpoint */
 	US_DEBUGP("Bulk command S 0x%x T 0x%x Trg %d LUN %d L %d F %d CL %d\n",
-		  le32_to_cpu(bcb.Signature), bcb.Tag,
-		  (bcb.Lun >> 4), (bcb.Lun & 0x0F), 
-		  bcb.DataTransferLength, bcb.Flags, bcb.Length);
-	result = usb_stor_bulk_msg(us, &bcb, pipe, US_BULK_CB_WRAP_LEN, 
+		  le32_to_cpu(bcb->Signature), bcb->Tag,
+		  (bcb->Lun >> 4), (bcb->Lun & 0x0F), 
+		  bcb->DataTransferLength, bcb->Flags, bcb->Length);
+	result = usb_stor_bulk_msg(us, bcb, pipe, US_BULK_CB_WRAP_LEN, 
 				   &partial);
 	US_DEBUGP("Bulk command transfer result=%d\n", result);
 
 	/* if the command was aborted, indicate that */
-	if (result == -ENOENT)
-		return USB_STOR_TRANSPORT_ABORTED;
+	if (result == -ENOENT) {
+		ret = USB_STOR_TRANSPORT_ABORTED;
+		goto out;
+	}
 
 	/* if we stall, we need to clear it before we go on */
 	if (result == -EPIPE) {
@@ -1119,25 +1140,30 @@
 		result = usb_stor_clear_halt(us, pipe);
 
 		/* if the command was aborted, indicate that */
-		if (result == -ENOENT)
-			return USB_STOR_TRANSPORT_ABORTED;
+		if (result == -ENOENT) {
+			ret = USB_STOR_TRANSPORT_ABORTED;
+			goto out;
+		}
 		result = -EPIPE;
 	} else if (result) {
 		/* unknown error -- we've got a problem */
-		return USB_STOR_TRANSPORT_ERROR;
+		ret = USB_STOR_TRANSPORT_ERROR;
+		goto out;
 	}
 
 	/* if the command transfered well, then we go to the data stage */
 	if (result == 0) {
 		/* send/receive data payload, if there is any */
-		if (bcb.DataTransferLength) {
+		if (bcb->DataTransferLength) {
 			usb_stor_transfer(srb, us);
 			result = srb->result;
 			US_DEBUGP("Bulk data transfer result 0x%x\n", result);
 
 			/* if it was aborted, we need to indicate that */
-			if (result == US_BULK_TRANSFER_ABORTED)
-				return USB_STOR_TRANSPORT_ABORTED;
+			if (result == US_BULK_TRANSFER_ABORTED) {
+				ret = USB_STOR_TRANSPORT_ABORTED;
+				goto out;
+			}
 		}
 	}
 
@@ -1150,12 +1176,14 @@
 
 	/* get CSW for device status */
 	US_DEBUGP("Attempting to get CSW...\n");
-	result = usb_stor_bulk_msg(us, &bcs, pipe, US_BULK_CS_WRAP_LEN, 
+	result = usb_stor_bulk_msg(us, bcs, pipe, US_BULK_CS_WRAP_LEN, 
 				   &partial);
 
 	/* if the command was aborted, indicate that */
-	if (result == -ENOENT)
-		return USB_STOR_TRANSPORT_ABORTED;
+	if (result == -ENOENT) {
+		ret = USB_STOR_TRANSPORT_ABORTED;
+		goto out;
+	}
 
 	/* did the attempt to read the CSW fail? */
 	if (result == -EPIPE) {
@@ -1163,17 +1191,21 @@
 		result = usb_stor_clear_halt(us, pipe);
 
 		/* if the command was aborted, indicate that */
-		if (result == -ENOENT)
-			return USB_STOR_TRANSPORT_ABORTED;
+		if (result == -ENOENT) {
+			ret = USB_STOR_TRANSPORT_ABORTED;
+			goto out;
+		}
 
 		/* get the status again */
 		US_DEBUGP("Attempting to get CSW (2nd try)...\n");
-		result = usb_stor_bulk_msg(us, &bcs, pipe,
+		result = usb_stor_bulk_msg(us, bcs, pipe,
 					   US_BULK_CS_WRAP_LEN, &partial);
 
 		/* if the command was aborted, indicate that */
-		if (result == -ENOENT)
-			return USB_STOR_TRANSPORT_ABORTED;
+		if (result == -ENOENT) {
+			ret = USB_STOR_TRANSPORT_ABORTED;
+			goto out;
+		}
 
 		/* if it fails again, we need a reset and return an error*/
 		if (result == -EPIPE) {
@@ -1181,48 +1213,60 @@
 			result = usb_stor_clear_halt(us, pipe);
 
 			/* if the command was aborted, indicate that */
-			if (result == -ENOENT)
-				return USB_STOR_TRANSPORT_ABORTED;
-			return USB_STOR_TRANSPORT_ERROR;
+			if (result == -ENOENT) {
+				ret = USB_STOR_TRANSPORT_ABORTED;
+			} else {
+				ret = USB_STOR_TRANSPORT_ERROR;
+			}
+			goto out;
 		}
 	}
 
 	/* if we still have a failure at this point, we're in trouble */
 	US_DEBUGP("Bulk status result = %d\n", result);
 	if (result) {
-		return USB_STOR_TRANSPORT_ERROR;
+		ret = USB_STOR_TRANSPORT_ERROR;
+		goto out;
 	}
 
 	/* check bulk status */
 	US_DEBUGP("Bulk status Sig 0x%x T 0x%x R %d Stat 0x%x\n",
-		  le32_to_cpu(bcs.Signature), bcs.Tag, 
-		  bcs.Residue, bcs.Status);
-	if (bcs.Signature != cpu_to_le32(US_BULK_CS_SIGN) || 
-	    bcs.Tag != bcb.Tag || 
-	    bcs.Status > US_BULK_STAT_PHASE || partial != 13) {
+		  le32_to_cpu(bcs->Signature), bcs->Tag, 
+		  bcs->Residue, bcs->Status);
+	if (bcs->Signature != cpu_to_le32(US_BULK_CS_SIGN) || 
+	    bcs->Tag != bcb->Tag || 
+	    bcs->Status > US_BULK_STAT_PHASE || partial != 13) {
 		US_DEBUGP("Bulk logical error\n");
-		return USB_STOR_TRANSPORT_ERROR;
+		ret = USB_STOR_TRANSPORT_ERROR;
+		goto out;
 	}
 
 	/* based on the status code, we report good or bad */
-	switch (bcs.Status) {
+	switch (bcs->Status) {
 		case US_BULK_STAT_OK:
 			/* command good -- note that data could be short */
-			return USB_STOR_TRANSPORT_GOOD;
+			ret = USB_STOR_TRANSPORT_GOOD;
+			goto out;
 
 		case US_BULK_STAT_FAIL:
 			/* command failed */
-			return USB_STOR_TRANSPORT_FAILED;
+			ret = USB_STOR_TRANSPORT_FAILED;
+			goto out;
 
 		case US_BULK_STAT_PHASE:
 			/* phase error -- note that a transport reset will be
 			 * invoked by the invoke_transport() function
 			 */
-			return USB_STOR_TRANSPORT_ERROR;
+			ret = USB_STOR_TRANSPORT_ERROR;
+			goto out;
 	}
 
 	/* we should never get here, but if we do, we're in trouble */
-	return USB_STOR_TRANSPORT_ERROR;
+
+ out:
+	kfree(bcb);
+	kfree(bcs);
+	return ret;
 }
 
 /***********************************************************************
diff -Nur linux-2.4.19.old/drivers/usb/storage/transport.h linux-2.4.19/drivers/usb/storage/transport.h
--- linux-2.4.19.old/drivers/usb/storage/transport.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/storage/transport.h	Mon Nov 25 12:27:12 2002
@@ -58,6 +58,9 @@
 #define US_PR_EUSB_SDDR09	0x81	/* SCM-SCSI bridge for
 						SDDR-09 */
 #endif
+#ifdef CONFIG_USB_STORAGE_SDDR55
+#define US_PR_SDDR55	0x82		/* SDDR-55 (made up) */
+#endif
 #define US_PR_DPCM_USB  0xf0		/* Combination CB/SDDR09 */
 
 #ifdef CONFIG_USB_STORAGE_FREECOM
diff -Nur linux-2.4.19.old/drivers/usb/storage/unusual_devs.h linux-2.4.19/drivers/usb/storage/unusual_devs.h
--- linux-2.4.19.old/drivers/usb/storage/unusual_devs.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/storage/unusual_devs.h	Mon Nov 25 12:27:12 2002
@@ -65,6 +65,17 @@
 		US_SC_8070, US_PR_SCM_ATAPI, init_8200e, 0), 
 #endif
 
+/* Deduced by Jonathan Woithe <jwoithe@physics.adelaide.edu.au>
+ * Entry needed for flags: US_FL_FIX_INQUIRY because initial inquiry message
+ * always fails and confuses drive; without US_FL_START_STOP, drive accesses
+ * (read or write) all fail.
+ */
+UNUSUAL_DEV(  0x0411, 0x001c, 0x0113, 0x0113,
+		"Buffalo",
+		"DUB-P40G HDD",
+		US_SC_SCSI, US_PR_BULK, NULL,
+		US_FL_FIX_INQUIRY | US_FL_START_STOP),
+
 #ifdef CONFIG_USB_STORAGE_DPCM
 UNUSUAL_DEV(  0x0436, 0x0005, 0x0100, 0x0100,
 		"Microtech",
@@ -292,6 +303,13 @@
 		US_FL_MODE_XLATE ),
 #endif
 
+/* Reported by Blake Matheny <bmatheny@purdue.edu> */
+UNUSUAL_DEV(  0x05dc, 0xb002, 0x0000, 0x0113,
+		"Lexar",
+		"USB CF Reader",
+		US_SC_SCSI, US_PR_BULK, NULL,
+		US_FL_FIX_INQUIRY ),
+
 /* Reported by Carlos Villegas <cav@uniscope.co.jp>
  * This device needs an INQUIRY of exactly 36-bytes to function.
  * That is the only reason this entry is needed.
@@ -306,8 +324,10 @@
  * Like the SIIG unit above, this unit needs an INQUIRY to ask for exactly
  * 36 bytes of data.  No more, no less. That is the only reason this entry
  * is needed.
- */
-UNUSUAL_DEV(  0x05e3, 0x0702, 0x0000, 0xffff,
+ *
+ * ST818 slim drives (rev 0.02) don't need special care.
+*/
+UNUSUAL_DEV(  0x05e3, 0x0702, 0x0000, 0x0001,
 		"EagleTec",
 		"External Hard Disk",
 		US_SC_SCSI, US_PR_BULK, NULL,
@@ -342,6 +362,12 @@
                 US_SC_SCSI, US_PR_BULK, NULL,
                 US_FL_START_STOP ),
 
+UNUSUAL_DEV( 0x0686, 0x400b, 0x0001, 0x0001, 
+		"Minolta", 
+		"Dimage 7i", 
+		US_SC_SCSI, US_PR_BULK, NULL, 
+		US_FL_START_STOP ),
+
 UNUSUAL_DEV(  0x0693, 0x0002, 0x0100, 0x0100, 
 		"Hagiwara",
 		"FlashGate SmartMedia",
@@ -488,17 +514,22 @@
                 0 ),
 #endif
 
-/* Submitted by Brian Hall <brihall@bigfoot.com>
+/* Submitted by Brian Hall <brihall@pcisys.net>
  * Needed for START_STOP flag */
 UNUSUAL_DEV(  0x0c76, 0x0003, 0x0100, 0x0100,
 		"JMTek",
 		"USBDrive",
 		US_SC_SCSI, US_PR_BULK, NULL,
 		US_FL_START_STOP ),
+UNUSUAL_DEV(  0x0c76, 0x0005, 0x0100, 0x0100,
+		"JMTek",
+		"USBDrive",
+		US_SC_SCSI, US_PR_BULK, NULL,
+		US_FL_START_STOP ),
 
 /* Reported by Dan Pilone <pilone@slac.com>
  * The device needs the flags only.
- * Also reported by Brian Hall <brihall@bigfoot.com>, again for flags.
+ * Also reported by Brian Hall <brihall@pcisys.net>, again for flags.
  * I also suspect this device may have a broken serial number.
  */
 UNUSUAL_DEV(  0x1065, 0x2136, 0x0000, 0x9999,
@@ -506,3 +537,11 @@
 		"EasyDisk Portable Device",
 		US_SC_SCSI, US_PR_BULK, NULL,
 		US_FL_MODE_XLATE | US_FL_START_STOP),
+
+#ifdef CONFIG_USB_STORAGE_SDDR55
+UNUSUAL_DEV(  0x55aa, 0xa103, 0x0000, 0x9999, 
+		"Sandisk",
+		"ImageMate SDDR55",
+		US_SC_SCSI, US_PR_SDDR55, NULL,
+		US_FL_SINGLE_LUN),
+#endif
diff -Nur linux-2.4.19.old/drivers/usb/storage/usb.c linux-2.4.19/drivers/usb/storage/usb.c
--- linux-2.4.19.old/drivers/usb/storage/usb.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/storage/usb.c	Mon Nov 25 12:27:12 2002
@@ -60,6 +60,9 @@
 #ifdef CONFIG_USB_STORAGE_SDDR09
 #include "sddr09.h"
 #endif
+#ifdef CONFIG_USB_STORAGE_SDDR55
+#include "sddr55.h"
+#endif
 #ifdef CONFIG_USB_STORAGE_DPCM
 #include "dpcm.h"
 #endif
@@ -863,6 +866,15 @@
 			ss->max_lun = 0;
 			break;
 #endif
+
+#ifdef CONFIG_USB_STORAGE_SDDR55
+		case US_PR_SDDR55:
+			ss->transport_name = "SDDR55";
+			ss->transport = sddr55_transport;
+			ss->transport_reset = sddr55_reset;
+			ss->max_lun = 0;
+			break;
+#endif
 
 #ifdef CONFIG_USB_STORAGE_DPCM
 		case US_PR_DPCM_USB:
diff -Nur linux-2.4.19.old/drivers/usb/storage/usb.h linux-2.4.19/drivers/usb/storage/usb.h
--- linux-2.4.19.old/drivers/usb/storage/usb.h	Thu Nov 22 20:49:34 2001
+++ linux-2.4.19/drivers/usb/storage/usb.h	Mon Nov 25 12:27:12 2002
@@ -166,6 +166,7 @@
 	/* control and bulk communications data */
 	struct semaphore	current_urb_sem; /* to protect irq_urb	 */
 	struct urb		*current_urb;	 /* non-int USB requests */
+	struct completion	current_done;	 /* the done flag        */
 
 	/* the semaphore for sleeping the control thread */
 	struct semaphore	sema;		 /* to sleep thread on   */
diff -Nur linux-2.4.19.old/drivers/usb/stv680.c linux-2.4.19/drivers/usb/stv680.c
--- linux-2.4.19.old/drivers/usb/stv680.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/stv680.c	Mon Nov 25 12:27:12 2002
@@ -86,7 +86,7 @@
 #define PDEBUG(level, fmt, args...) \
 	do { \
 	if (debug >= level)	\
-		info("[" __PRETTY_FUNCTION__ ":%d] " fmt, __LINE__ , ## args);	\
+		info("[%s:%d] " fmt, __PRETTY_FUNCTION__, __LINE__ , ## args);	\
 	} while (0)
 
 
@@ -111,67 +111,27 @@
  *
  * Memory management
  *
- * This is a shameless copy from the USB-cpia driver (linux kernel
- * version 2.3.29 or so, I have no idea what this code actually does ;).
- * Actually it seems to be a copy of a shameless copy of the bttv-driver.
- * Or that is a copy of a shameless copy of ... (To the powers: is there
- * no generic kernel-function to do this sort of stuff?)
- *
- * Yes, it was a shameless copy from the bttv-driver. IIRC, Alan says
- * there will be one, but apparentely not yet -jerdfelt
- *
- * So I copied it again for the ov511 driver -claudio
- *
- * Same for the se401 driver -Jeroen
- *
- * And the STV0680 driver - Kevin
  ********************************************************************/
 
-/* Given PGD from the address space's page table, return the kernel
- * virtual mapping of the physical memory mapped at ADR.
- */
-static inline unsigned long uvirt_to_kva (pgd_t * pgd, unsigned long adr)
-{
-	unsigned long ret = 0UL;
-	pmd_t *pmd;
-	pte_t *ptep, pte;
-
-	if (!pgd_none (*pgd)) {
-		pmd = pmd_offset (pgd, adr);
-		if (!pmd_none (*pmd)) {
-			ptep = pte_offset (pmd, adr);
-			pte = *ptep;
-			if (pte_present (pte)) {
-				ret = (unsigned long) page_address (pte_page (pte));
-				ret |= (adr & (PAGE_SIZE - 1));
-			}
-		}
-	}
-	return ret;
-}
-
-/* Here we want the physical address of the memory. This is used when 
- * initializing the contents of the area and marking the pages as reserved.
+/* Here we want the physical address of the memory.
+ * This is used when initializing the contents of the area.
  */
 static inline unsigned long kvirt_to_pa (unsigned long adr)
 {
-	unsigned long va, kva, ret;
+	unsigned long kva, ret;
 
-	va = VMALLOC_VMADDR (adr);
-	kva = uvirt_to_kva (pgd_offset_k (va), va);
-	ret = __pa (kva);
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
+	ret = __pa(kva);
 	return ret;
 }
 
 static void *rvmalloc (unsigned long size)
 {
 	void *mem;
-	unsigned long adr, page;
-
-	/* Round it off to PAGE_SIZE */
-	size += (PAGE_SIZE - 1);
-	size &= ~(PAGE_SIZE - 1);
+	unsigned long adr;
 
+	size = PAGE_ALIGN(size);
 	mem = vmalloc_32 (size);
 	if (!mem)
 		return NULL;
@@ -179,36 +139,25 @@
 	memset (mem, 0, size);	/* Clear the ram out, no junk to the user */
 	adr = (unsigned long) mem;
 	while (size > 0) {
-		page = kvirt_to_pa (adr);
-		mem_map_reserve (virt_to_page (__va (page)));
+		mem_map_reserve(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
-		if (size > PAGE_SIZE)
-			size -= PAGE_SIZE;
-		else
-			size = 0;
+		size -= PAGE_SIZE;
 	}
 	return mem;
 }
 
 static void rvfree (void *mem, unsigned long size)
 {
-	unsigned long adr, page;
+	unsigned long adr;
 
 	if (!mem)
 		return;
 
-	size += (PAGE_SIZE - 1);
-	size &= ~(PAGE_SIZE - 1);
-
 	adr = (unsigned long) mem;
-	while (size > 0) {
-		page = kvirt_to_pa (adr);
-		mem_map_unreserve (virt_to_page (__va (page)));
+	while ((long) size > 0) {
+		mem_map_unreserve(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
-		if (size > PAGE_SIZE)
-			size -= PAGE_SIZE;
-		else
-			size = 0;
+		size -= PAGE_SIZE;
 	}
 	vfree (mem);
 }
@@ -772,7 +721,7 @@
 
 static int stv680_start_stream (struct usb_stv *stv680)
 {
-	urb_t *urb;
+	struct urb *urb;
 	int err = 0, i;
 
 	stv680->streaming = 1;
@@ -1123,6 +1072,9 @@
 			errors++;
 		}
 		wait_event_interruptible (stv680->wq, (stv680->scratch[stv680->scratch_use].state == BUFFER_READY));
+		
+		if (stv680->removed)
+			return -ENODEV;
 
 		if (stv680->nullpackets > STV680_MAX_NULLPACKETS) {
 			stv680->nullpackets = 0;
@@ -1191,10 +1143,10 @@
 
 	for (i = 0; i < STV680_NUMFRAMES; i++)
 		stv680->frame[i].grabstate = FRAME_UNUSED;
-	if (stv680->streaming)
+	if (stv680->streaming && !stv680->removed)
 		stv680_stop_stream (stv680);
 
-	if ((i = stv_stop_video (stv680)) < 0)
+	if ((!stv680->removed) && (i = stv_stop_video (stv680)) < 0)
 		PDEBUG (1, "STV(e): stop_video failed in stv_close");
 
 	rvfree (stv680->fbuf, stv680->maxframesize * STV680_NUMFRAMES);
@@ -1220,6 +1172,9 @@
 
 	if (!stv680->udev)
 		return -EIO;
+		
+	if (stv680->removed)
+		return -ENODEV;
 
 	switch (cmd) {
 	case VIDIOCGCAP:{
@@ -1545,7 +1500,7 @@
 	initialize:	stv_init_done,
 };
 
-static void *__devinit stv680_probe (struct usb_device *dev, unsigned int ifnum, const struct usb_device_id *id)
+static void *stv680_probe (struct usb_device *dev, unsigned int ifnum, const struct usb_device_id *id)
 {
 	struct usb_interface_descriptor *interface;
 	struct usb_stv *stv680;
@@ -1629,6 +1584,7 @@
 static void stv680_disconnect (struct usb_device *dev, void *ptr)
 {
 	struct usb_stv *stv680 = (struct usb_stv *) ptr;
+	int i;
 
 	lock_kernel ();
 	/* We don't want people trying to open up the device */
@@ -1637,6 +1593,9 @@
 		usb_stv680_remove_disconnected (stv680);
 	} else {
 		stv680->removed = 1;
+		for( i = 0; i < STV680_NUMSBUF; i++)
+			usb_unlink_urb(stv680->urb[i]);
+		wake_up_interruptible (&stv680->wq);
 	}
 	unlock_kernel ();
 }
diff -Nur linux-2.4.19.old/drivers/usb/stv680.h linux-2.4.19/drivers/usb/stv680.h
--- linux-2.4.19.old/drivers/usb/stv680.h	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/stv680.h	Mon Nov 25 12:27:12 2002
@@ -45,7 +45,7 @@
 /* fmt 4 */
 #define STV_VIDEO_PALETTE       VIDEO_PALETTE_RGB24
 
-static __devinitdata struct usb_device_id device_table[] = {
+static struct usb_device_id device_table[] = {
 	{USB_DEVICE (USB_PENCAM_VENDOR_ID, USB_PENCAM_PRODUCT_ID)},
 	{}
 };
@@ -118,7 +118,7 @@
 	int removed;		/* device disconnected */
 	int streaming;		/* Are we streaming video? */
 	char *fbuf;		/* Videodev buffer area */
-	urb_t *urb[STV680_NUMSBUF];	/* # of queued bulk transfers */
+	struct urb *urb[STV680_NUMSBUF];	/* # of queued bulk transfers */
 	int curframe;		/* Current receiving frame */
 	struct stv680_frame frame[STV680_NUMFRAMES];	/* # frames supported by v4l part */
 	int readcount;
diff -Nur linux-2.4.19.old/drivers/usb/tiglusb.c linux-2.4.19/drivers/usb/tiglusb.c
--- linux-2.4.19.old/drivers/usb/tiglusb.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/tiglusb.c	Mon Nov 25 12:27:12 2002
@@ -0,0 +1,514 @@
+/* Hey EMACS -*- linux-c -*-
+ *
+ * tiglusb -- Texas Instruments' USB GraphLink (aka SilverLink) driver.
+ * Target: Texas Instruments graphing calculators (http://lpg.ticalc.org).
+ *
+ * Copyright (C) 2001-2002:
+ *   Romain Lievin <roms@lpg.ticalc.org>
+ *   Julien BLACHE <jb@technologeek.org>
+ * under the terms of the GNU General Public License.
+ *
+ * Based on dabusb.c, printer.c & scanner.c
+ *
+ * Please see the file: linux/Documentation/usb/SilverLink.txt
+ * and the website at:  http://lpg.ticalc.org/prj_usb/
+ * for more info.
+ *
+ * History :
+ *  16/07/2002 : v1.04 -- Julien BLACHE <jb@jblache.org>
+ *    + removed useless usblp_cleanup()
+ *    + removed {un,}lock_kernel() as suggested on lkml
+ *    + inlined clear_pipes() (used once)
+ *    + inlined clear_device() (small, used twice)
+ *    + removed tiglusb_find_struct() (used once, simple code)
+ *    + replaced down() with down_interruptible() wherever possible
+ *    + fixed double unregistering wrt devfs, causing devfs
+ *      to force an oops when the device is deconnected
+ *    + removed unused fields from struct tiglusb_t
+ */
+
+#include <linux/module.h>
+#include <linux/socket.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/smp_lock.h>
+#include <linux/devfs_fs_kernel.h>
+
+#include <linux/ticable.h>
+#include "tiglusb.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION "1.04"
+#define DRIVER_AUTHOR  "Romain Lievin <roms@lpg.ticalc.org> & Julien Blache <jb@jblache.org>"
+#define DRIVER_DESC    "TI-GRAPH LINK USB (aka SilverLink) driver"
+#define DRIVER_LICENSE "GPL"
+
+/* ----- global variables --------------------------------------------- */
+
+static tiglusb_t tiglusb[MAXTIGL];
+static int timeout = TIMAXTIME;	/* timeout in tenth of seconds     */
+
+static devfs_handle_t devfs_handle;
+
+/*---------- misc functions ------------------------------------------- */
+
+/*
+ * Re-initialize device
+ */
+static inline int
+clear_device (struct usb_device *dev)
+{
+	if (usb_set_configuration (dev, dev->config[0].bConfigurationValue) < 0) {
+		err ("clear_device failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+/* 
+ * Clear input & output pipes (endpoints)
+ */
+static inline int
+clear_pipes (struct usb_device *dev)
+{
+	unsigned int pipe;
+
+	pipe = usb_sndbulkpipe (dev, 1);
+	if (usb_clear_halt (dev, usb_pipeendpoint (pipe))) {
+		err ("clear_pipe (r), request failed");
+		return -1;
+	}
+
+	pipe = usb_sndbulkpipe (dev, 2);
+	if (usb_clear_halt (dev, usb_pipeendpoint (pipe))) {
+		err ("clear_pipe (w), request failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+/* ----- file operations functions--------------------------------------- */
+
+static int
+tiglusb_open (struct inode *inode, struct file *filp)
+{
+	int devnum = minor (inode->i_rdev);
+	ptiglusb_t s;
+
+	if (devnum < TIUSB_MINOR || devnum >= (TIUSB_MINOR + MAXTIGL))
+		return -EIO;
+
+	s = &tiglusb[devnum - TIUSB_MINOR];
+
+	if (down_interruptible (&s->mutex)) {
+		return -ERESTARTSYS;
+	}
+
+	while (!s->dev || s->opened) {
+		up (&s->mutex);
+
+		if (filp->f_flags & O_NONBLOCK) {
+			return -EBUSY;
+		}
+
+		schedule_timeout (HZ / 2);
+
+		if (signal_pending (current)) {
+			return -EAGAIN;
+		}
+
+		if (down_interruptible (&s->mutex)) {
+			return -ERESTARTSYS;
+		}
+	}
+
+	s->opened = 1;
+	up (&s->mutex);
+
+	filp->f_pos = 0;
+	filp->private_data = s;
+
+	return 0;
+}
+
+static int
+tiglusb_release (struct inode *inode, struct file *filp)
+{
+	ptiglusb_t s = (ptiglusb_t) filp->private_data;
+
+	if (down_interruptible (&s->mutex)) {
+		return -ERESTARTSYS;
+	}
+
+	s->state = _stopped;
+	up (&s->mutex);
+
+	if (!s->remove_pending)
+		clear_device (s->dev);
+	else
+		wake_up (&s->remove_ok);
+
+	s->opened = 0;
+
+	return 0;
+}
+
+static ssize_t
+tiglusb_read (struct file *filp, char *buf, size_t count, loff_t * f_pos)
+{
+	ptiglusb_t s = (ptiglusb_t) filp->private_data;
+	ssize_t ret = 0;
+	int bytes_to_read = 0;
+	int bytes_read = 0;
+	int result = 0;
+	char buffer[BULK_RCV_MAX];
+	unsigned int pipe;
+
+	if (*f_pos)
+		return -ESPIPE;
+
+	if (s->remove_pending)
+		return -EIO;
+
+	if (!s->dev)
+		return -EIO;
+
+	bytes_to_read = (count >= BULK_RCV_MAX) ? BULK_RCV_MAX : count;
+
+	pipe = usb_rcvbulkpipe (s->dev, 1);
+	result = usb_bulk_msg (s->dev, pipe, buffer, bytes_to_read,
+			       &bytes_read, HZ / (timeout / 10));
+	if (result == -ETIMEDOUT) {	/* NAK */
+		ret = result;
+		if (!bytes_read) {
+			dbg ("quirk !");
+		}
+		warn ("tiglusb_read, NAK received.");
+		goto out;
+	} else if (result == -EPIPE) {	/* STALL -- shouldn't happen */
+		warn ("clear_halt request to remove STALL condition.");
+		if (usb_clear_halt (s->dev, usb_pipeendpoint (pipe)))
+			err ("clear_halt, request failed");
+		clear_device (s->dev);
+		ret = result;
+		goto out;
+	} else if (result < 0) {	/* We should not get any I/O errors */
+		err ("funky result: %d. Please notify maintainer.", result);
+		ret = -EIO;
+		goto out;
+	}
+
+	if (copy_to_user (buf, buffer, bytes_read)) {
+		ret = -EFAULT;
+	}
+
+      out:
+	return ret ? ret : bytes_read;
+}
+
+static ssize_t
+tiglusb_write (struct file *filp, const char *buf, size_t count, loff_t * f_pos)
+{
+	ptiglusb_t s = (ptiglusb_t) filp->private_data;
+	ssize_t ret = 0;
+	int bytes_to_write = 0;
+	int bytes_written = 0;
+	int result = 0;
+	char buffer[BULK_SND_MAX];
+	unsigned int pipe;
+
+	if (*f_pos)
+		return -ESPIPE;
+
+	if (s->remove_pending)
+		return -EIO;
+
+	if (!s->dev)
+		return -EIO;
+
+	bytes_to_write = (count >= BULK_SND_MAX) ? BULK_SND_MAX : count;
+	if (copy_from_user (buffer, buf, bytes_to_write)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	pipe = usb_sndbulkpipe (s->dev, 2);
+	result = usb_bulk_msg (s->dev, pipe, buffer, bytes_to_write,
+			       &bytes_written, HZ / (timeout / 10));
+
+	if (result == -ETIMEDOUT) {	/* NAK */
+		warn ("tiglusb_write, NAK received.");
+		ret = result;
+		goto out;
+	} else if (result == -EPIPE) {	/* STALL -- shouldn't happen */
+		warn ("clear_halt request to remove STALL condition.");
+		if (usb_clear_halt (s->dev, usb_pipeendpoint (pipe)))
+			err ("clear_halt, request failed");
+		clear_device (s->dev);
+		ret = result;
+		goto out;
+	} else if (result < 0) {	/* We should not get any I/O errors */
+		warn ("funky result: %d. Please notify maintainer.", result);
+		ret = -EIO;
+		goto out;
+	}
+
+	if (bytes_written != bytes_to_write) {
+		ret = -EIO;
+	}
+
+      out:
+	return ret ? ret : bytes_written;
+}
+
+static int
+tiglusb_ioctl (struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
+{
+	ptiglusb_t s = (ptiglusb_t) filp->private_data;
+	int ret = 0;
+
+	if (s->remove_pending)
+		return -EIO;
+
+	if (down_interruptible (&s->mutex)) {
+		return -ERESTARTSYS;
+	}
+
+	if (!s->dev) {
+		up (&s->mutex);
+		return -EIO;
+	}
+
+	switch (cmd) {
+	case IOCTL_TIUSB_TIMEOUT:
+		timeout = arg;	// timeout value in tenth of seconds
+		break;
+	case IOCTL_TIUSB_RESET_DEVICE:
+		dbg ("IOCTL_TIGLUSB_RESET_DEVICE");
+		if (clear_device (s->dev))
+			ret = -EIO;
+		break;
+	case IOCTL_TIUSB_RESET_PIPES:
+		dbg ("IOCTL_TIGLUSB_RESET_PIPES");
+		if (clear_pipes (s->dev))
+			ret = -EIO;
+		break;
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	up (&s->mutex);
+
+	return ret;
+}
+
+/* ----- kernel module registering ------------------------------------ */
+
+static struct file_operations tiglusb_fops = {
+	.llseek =	no_llseek,
+	.read =		tiglusb_read,
+	.write =	tiglusb_write,
+	.ioctl =	tiglusb_ioctl,
+	.open =		tiglusb_open,
+	.release =	tiglusb_release,
+};
+
+/* --- initialisation code ------------------------------------- */
+
+static void *
+tiglusb_probe (struct usb_device *dev, unsigned int ifnum,
+	       const struct usb_device_id *id)
+{
+	int minor = -1;
+	int i;
+	ptiglusb_t s;
+	char name[8];
+
+	dbg ("probing vendor id 0x%x, device id 0x%x ifnum:%d",
+	     dev->descriptor.idVendor, dev->descriptor.idProduct, ifnum);
+
+	/*
+	 * We don't handle multiple configurations. As of version 0x0103 of
+	 * the TIGL hardware, there's only 1 configuration.
+	 */
+
+	if (dev->descriptor.bNumConfigurations != 1)
+		return NULL;
+
+	if ((dev->descriptor.idProduct != 0xe001)
+	    && (dev->descriptor.idVendor != 0x451))
+		return NULL;
+
+	if (usb_set_configuration (dev, dev->config[0].bConfigurationValue) < 0) {
+		err ("tiglusb_probe: set_configuration failed");
+		return NULL;
+	}
+
+	/*
+	 * Find a tiglusb struct
+	 */
+	for (i = 0; i < MAXTIGL; i++) {
+		ptiglusb_t s = &tiglusb[i];
+		if (!s->dev) {
+			minor = i;
+			break;
+		}
+	}
+
+	if (minor == -1)
+		return NULL;
+
+	s = &tiglusb[minor];
+
+	down (&s->mutex);
+	s->remove_pending = 0;
+	s->dev = dev;
+	up (&s->mutex);
+	dbg ("bound to interface: %d", ifnum);
+
+	sprintf (name, "%d", s->minor);
+	dbg ("registering to devfs : major = %d, minor = %d, node = %s",
+	     TIUSB_MAJOR, (TIUSB_MINOR + s->minor), name);
+	s->devfs =
+	    devfs_register (devfs_handle, name, DEVFS_FL_DEFAULT, TIUSB_MAJOR,
+			    TIUSB_MINOR + s->minor, S_IFCHR | S_IRUGO | S_IWUGO,
+			    &tiglusb_fops, NULL);
+
+	/* Display firmware version */
+	info ("link cable version %i.%02x",
+		dev->descriptor.bcdDevice >> 8,
+		dev->descriptor.bcdDevice & 0xff);
+
+	return s;
+}
+
+static void
+tiglusb_disconnect (struct usb_device *dev, void *drv_context)
+{
+	ptiglusb_t s = (ptiglusb_t) drv_context;
+
+	if (!s || !s->dev)
+		info ("bogus disconnect");
+
+	s->remove_pending = 1;
+	wake_up (&s->wait);
+	if (s->state == _started)
+		sleep_on (&s->remove_ok);
+	down (&s->mutex);
+	s->dev = NULL;
+	s->opened = 0;
+
+	devfs_unregister (s->devfs);
+	s->devfs = NULL;
+
+	info ("device %d removed", s->minor);
+
+	up (&s->mutex);
+}
+
+static struct usb_device_id tiglusb_ids[] = {
+	{USB_DEVICE (0x0451, 0xe001)},
+	{}
+};
+
+MODULE_DEVICE_TABLE (usb, tiglusb_ids);
+
+static struct usb_driver tiglusb_driver = {
+	.name =		"tiglusb",
+	.probe =	tiglusb_probe,
+	.disconnect =	tiglusb_disconnect,
+	.id_table =	tiglusb_ids,
+};
+
+/* --- initialisation code ------------------------------------- */
+
+#ifndef MODULE
+/*
+ * You can use 'tiusb=timeout'
+ */
+static int __init
+tiglusb_setup (char *str)
+{
+	int ints[2];
+
+	str = get_options (str, ARRAY_SIZE (ints), ints);
+
+	if (ints[0] > 0) {
+		timeout = ints[1];
+	}
+
+	return 1;
+}
+#endif
+
+static int __init
+tiglusb_init (void)
+{
+	unsigned u;
+	int result;
+
+	/* initialize struct */
+	for (u = 0; u < MAXTIGL; u++) {
+		ptiglusb_t s = &tiglusb[u];
+		memset (s, 0, sizeof (tiglusb_t));
+		init_MUTEX (&s->mutex);
+		s->dev = NULL;
+		s->minor = u;
+		s->opened = 0;
+		init_waitqueue_head (&s->wait);
+		init_waitqueue_head (&s->remove_ok);
+	}
+
+	/* register device */
+	if (devfs_register_chrdev (TIUSB_MAJOR, "tiglusb", &tiglusb_fops)) {
+		err ("unable to get major %d", TIUSB_MAJOR);
+		return -EIO;
+	}
+
+	/* Use devfs, tree: /dev/ticables/usb/[0..3] */
+	devfs_handle = devfs_mk_dir (NULL, "ticables/usb", NULL);
+
+	/* register USB module */
+	result = usb_register (&tiglusb_driver);
+	if (result < 0) {
+		devfs_unregister_chrdev (TIUSB_MAJOR, "tiglusb");
+		return -1;
+	}
+
+	info (DRIVER_DESC ", " DRIVER_VERSION);
+
+	return 0;
+}
+
+static void __exit
+tiglusb_cleanup (void)
+{
+	usb_deregister (&tiglusb_driver);
+	devfs_unregister (devfs_handle);
+	devfs_unregister_chrdev (TIUSB_MAJOR, "tiglusb");
+}
+
+/* --------------------------------------------------------------------- */
+
+__setup ("tiusb=", tiglusb_setup);
+module_init (tiglusb_init);
+module_exit (tiglusb_cleanup);
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION (DRIVER_DESC);
+MODULE_LICENSE (DRIVER_LICENSE);
+
+MODULE_PARM (timeout, "i");
+MODULE_PARM_DESC (timeout, "Timeout (default=1.5 seconds)");
+
+/* --------------------------------------------------------------------- */
diff -Nur linux-2.4.19.old/drivers/usb/tiglusb.h linux-2.4.19/drivers/usb/tiglusb.h
--- linux-2.4.19.old/drivers/usb/tiglusb.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/tiglusb.h	Mon Nov 25 12:27:12 2002
@@ -0,0 +1,48 @@
+/* Hey EMACS -*- linux-c -*-
+ *
+ * tiglusb - low level driver for SilverLink cable
+ *
+ * Copyright (C) 2000-2002, Romain Lievin <roms@lpg.ticalc.org>
+ * under the terms of the GNU General Public License.
+ *
+ * Redistribution of this file is permitted under the terms of the GNU
+ * Public License (GPL)
+ */
+
+#ifndef _TIGLUSB_H
+#define _TIGLUSB_H
+
+/*
+ * Max. number of devices supported
+ */
+#define MAXTIGL		16
+
+/*
+ * Max. packetsize for IN and OUT pipes
+ */
+#define BULK_RCV_MAX	32
+#define BULK_SND_MAX	32
+
+/*
+ * The driver context...
+ */
+
+typedef enum { _stopped=0, _started } driver_state_t;
+
+typedef struct
+{
+	struct usb_device	*dev;		/* USB device handle */
+	struct semaphore	mutex;		/* locks this struct */
+
+	wait_queue_head_t	wait;		/* for timed waits */
+	wait_queue_head_t	remove_ok;
+
+	int		minor;			/* which minor dev #? */
+	devfs_handle_t	devfs;			/* devfs device */
+
+	driver_state_t	state;			/* started/stopped */
+	int		opened;			/* tru if open */
+	int	remove_pending;
+} tiglusb_t, *ptiglusb_t;
+
+#endif
diff -Nur linux-2.4.19.old/drivers/usb/uhci.c linux-2.4.19/drivers/usb/uhci.c
--- linux-2.4.19.old/drivers/usb/uhci.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/uhci.c	Mon Nov 25 12:27:12 2002
@@ -57,6 +57,8 @@
 
 #include <linux/pm.h>
 
+#include "hcd.h"
+
 /*
  * Version Information
  */
@@ -100,6 +102,11 @@
 #define IDLE_TIMEOUT	(HZ / 20)	/* 50 ms */
 #define FSBR_DELAY	(HZ / 20)	/* 50 ms */
 
+/* When we timeout an idle transfer for FSBR, we'll switch it over to */
+/* depth first traversal. We'll do it in groups of this number of TD's */
+/* to make sure it doesn't hog all of the bandwidth */
+#define DEPTH_INTERVAL	5
+
 #define MAX_URB_LOOP	2048		/* Maximum number of linked URB's */
 
 /*
@@ -115,12 +122,20 @@
 	return 0;
 }
 
+/*
+ * Technically, updating td->status here is a race, but it's not really a
+ * problem. The worst that can happen is that we set the IOC bit again
+ * generating a spurios interrupt. We could fix this by creating another
+ * QH and leaving the IOC bit always set, but then we would have to play
+ * games with the FSBR code to make sure we get the correct order in all
+ * the cases. I don't think it's worth the effort
+ */
 static inline void uhci_set_next_interrupt(struct uhci *uhci)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&uhci->frame_list_lock, flags);
-	set_bit(TD_CTRL_IOC_BIT, &uhci->skel_term_td->status);
+	uhci->skel_term_td->status |= TD_CTRL_IOC;
 	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
@@ -129,7 +144,7 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&uhci->frame_list_lock, flags);
-	clear_bit(TD_CTRL_IOC_BIT, &uhci->skel_term_td->status);
+	uhci->skel_term_td->status &= ~TD_CTRL_IOC;
 	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
@@ -474,9 +489,9 @@
 		tmp = tmp->next;
 
 		if (toggle)
-			set_bit(TD_TOKEN_TOGGLE, &td->info);
+			td->info |= TD_TOKEN_TOGGLE;
 		else
-			clear_bit(TD_TOKEN_TOGGLE, &td->info);
+			td->info &= ~TD_TOKEN_TOGGLE;
 
 		toggle ^= 1;
 	}
@@ -649,7 +664,7 @@
 
 		if (usb_pipetype(urb->pipe) == PIPE_CONTROL && urb->setup_packet) {
 			urbp->setup_packet_dma_handle = pci_map_single(uhci->dev,
-				urb->setup_packet, sizeof(devrequest),
+				urb->setup_packet, sizeof(struct usb_ctrlrequest),
 				PCI_DMA_TODEVICE);
 			if (!urbp->setup_packet_dma_handle)
 				return NULL;
@@ -724,7 +739,7 @@
 
 	if (urbp->setup_packet_dma_handle) {
 		pci_unmap_single(uhci->dev, urbp->setup_packet_dma_handle,
-			sizeof(devrequest), PCI_DMA_TODEVICE);
+			sizeof(struct usb_ctrlrequest), PCI_DMA_TODEVICE);
 		urbp->setup_packet_dma_handle = 0;
 	}
 
@@ -857,7 +872,7 @@
 			return -ENOMEM;
 
 		/* Alternate Data0/1 (start with Data1) */
-		destination ^= 1 << TD_TOKEN_TOGGLE;
+		destination ^= TD_TOKEN_TOGGLE;
 	
 		uhci_add_td_to_urb(urb, td);
 		uhci_fill_td(td, status, destination | ((pktsze - 1) << 21),
@@ -884,7 +899,7 @@
 	else
 		destination |= USB_PID_OUT;
 
-	destination |= 1 << TD_TOKEN_TOGGLE;		/* End in Data1 */
+	destination |= TD_TOKEN_TOGGLE;		/* End in Data1 */
 
 	status &= ~TD_CTRL_SPD;
 
@@ -953,14 +968,6 @@
 
 		tmp = tmp->next;
 
-		if (urbp->fsbr_timeout && (td->status & TD_CTRL_IOC) &&
-		    !(td->status & TD_CTRL_ACTIVE)) {
-			uhci_inc_fsbr(urb->dev->bus->hcpriv, urb);
-			urbp->fsbr_timeout = 0;
-			urbp->fsbrtime = jiffies;
-			clear_bit(TD_CTRL_IOC_BIT, &td->status);
-		}
-
 		status = uhci_status_bits(td->status);
 		if (status & TD_CTRL_ACTIVE)
 			return -EINPROGRESS;
@@ -1097,7 +1104,7 @@
 	if (!td)
 		return -ENOMEM;
 
-	destination |= (usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe)) << TD_TOKEN_TOGGLE);
+	destination |= (usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe)) << TD_TOKEN_TOGGLE_SHIFT);
 	destination |= ((urb->transfer_buffer_length - 1) << 21);
 
 	usb_dotoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe));
@@ -1127,14 +1134,6 @@
 
 		tmp = tmp->next;
 
-		if (urbp->fsbr_timeout && (td->status & TD_CTRL_IOC) &&
-		    !(td->status & TD_CTRL_ACTIVE)) {
-			uhci_inc_fsbr(urb->dev->bus->hcpriv, urb);
-			urbp->fsbr_timeout = 0;
-			urbp->fsbrtime = jiffies;
-			clear_bit(TD_CTRL_IOC_BIT, &td->status);
-		}
-
 		status = uhci_status_bits(td->status);
 		if (status & TD_CTRL_ACTIVE)
 			return -EINPROGRESS;
@@ -1198,8 +1197,8 @@
 	td = list_entry(urbp->td_list.next, struct uhci_td, list);
 
 	td->status = (td->status & 0x2F000000) | TD_CTRL_ACTIVE | TD_CTRL_IOC;
-	td->info &= ~(1 << TD_TOKEN_TOGGLE);
-	td->info |= (usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe)) << TD_TOKEN_TOGGLE);
+	td->info &= ~TD_TOKEN_TOGGLE;
+	td->info |= (usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe)) << TD_TOKEN_TOGGLE_SHIFT);
 	usb_dotoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe));
 
 out:
@@ -1255,7 +1254,7 @@
 		uhci_fill_td(td, status, destination |
 			(((pktsze - 1) & UHCI_NULL_DATA_SIZE) << 21) |
 			(usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),
-			 usb_pipeout(urb->pipe)) << TD_TOKEN_TOGGLE),
+			 usb_pipeout(urb->pipe)) << TD_TOKEN_TOGGLE_SHIFT),
 			data);
 
 		data += pktsze;
@@ -1283,7 +1282,7 @@
 		uhci_fill_td(td, status, destination |
 			(UHCI_NULL_DATA_SIZE << 21) |
 			(usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),
-			 usb_pipeout(urb->pipe)) << TD_TOKEN_TOGGLE),
+			 usb_pipeout(urb->pipe)) << TD_TOKEN_TOGGLE_SHIFT),
 			data);
 
 		usb_dotoggle(urb->dev, usb_pipeendpoint(urb->pipe),
@@ -1830,11 +1829,18 @@
 {
 	struct urb_priv *urbp = (struct urb_priv *)urb->hcpriv;
 	struct list_head *head, *tmp;
+	int count = 0;
 
 	uhci_dec_fsbr(uhci, urb);
 
 	urbp->fsbr_timeout = 1;
 
+	/*
+	 * Ideally we would want to fix qh->element as well, but it's
+	 * read/write by the HC, so that can introduce a race. It's not
+	 * really worth the hassle
+	 */
+
 	head = &urbp->td_list;
 	tmp = head->next;
 	while (tmp != head) {
@@ -1842,10 +1848,15 @@
 
 		tmp = tmp->next;
 
-		if (td->status & TD_CTRL_ACTIVE) {
-			set_bit(TD_CTRL_IOC_BIT, &td->status);
-			break;
-		}
+		/*
+		 * Make sure we don't do the last one (since it'll have the
+		 * TERM bit set) as well as we skip every so many TD's to
+		 * make sure it doesn't hog the bandwidth
+		 */
+		if (tmp != head && (count % DEPTH_INTERVAL) == (DEPTH_INTERVAL - 1))
+			td->link |= UHCI_PTR_DEPTH;
+
+		count++;
 	}
 
 	return 0;
@@ -2073,7 +2084,7 @@
 {
 	struct uhci *uhci = (struct uhci *)urb->dev->bus->hcpriv;
 	unsigned int pipe = urb->pipe;
-	devrequest *cmd = (devrequest *)urb->setup_packet;
+	struct usb_ctrlrequest *cmd = (struct usb_ctrlrequest *)urb->setup_packet;
 	void *data = urb->transfer_buffer;
 	int leni = urb->transfer_buffer_length;
 	int len = 0;
@@ -2096,10 +2107,10 @@
 		return -EINPROGRESS;
 	}
 
-	bmRType_bReq = cmd->requesttype | cmd->request << 8;
-	wValue = le16_to_cpu(cmd->value);
-	wIndex = le16_to_cpu(cmd->index);
-	wLength = le16_to_cpu(cmd->length);
+	bmRType_bReq = cmd->bRequestType | cmd->bRequest << 8;
+	wValue = le16_to_cpu(cmd->wValue);
+	wIndex = le16_to_cpu(cmd->wIndex);
+	wLength = le16_to_cpu(cmd->wLength);
 
 	for (i = 0; i < 8; i++)
 		uhci->rh.c_p_r[i] = 0;
@@ -2340,7 +2351,7 @@
 
 	if (urbp->setup_packet_dma_handle)
 		pci_dma_sync_single(uhci->dev, urbp->setup_packet_dma_handle,
-			sizeof(devrequest), PCI_DMA_TODEVICE);
+			sizeof(struct usb_ctrlrequest), PCI_DMA_TODEVICE);
 
 	status = urbp->status;
 	if (!resubmit_interrupt || killed)
@@ -2788,6 +2799,7 @@
 	}
 
 	uhci->bus = bus;
+	bus->bus_name = dev->slot_name;
 	bus->hcpriv = uhci;
 
 	usb_register_bus(uhci->bus);
diff -Nur linux-2.4.19.old/drivers/usb/uhci.h linux-2.4.19/drivers/usb/uhci.h
--- linux-2.4.19.old/drivers/usb/uhci.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/uhci.h	Mon Nov 25 12:27:12 2002
@@ -100,7 +100,6 @@
 #define TD_CTRL_C_ERR_SHIFT	27
 #define TD_CTRL_LS		(1 << 26)	/* Low Speed Device */
 #define TD_CTRL_IOS		(1 << 25)	/* Isochronous Select */
-#define TD_CTRL_IOC_BIT		24
 #define TD_CTRL_IOC		(1 << 24)	/* Interrupt on Complete */
 #define TD_CTRL_ACTIVE		(1 << 23)	/* TD Active */
 #define TD_CTRL_STALLED		(1 << 22)	/* TD Stalled */
@@ -120,13 +119,14 @@
 /*
  * for TD <info>: (a.k.a. Token)
  */
-#define TD_TOKEN_TOGGLE		19
+#define TD_TOKEN_TOGGLE_SHIFT	19
+#define TD_TOKEN_TOGGLE		(1 << 19)
 #define TD_TOKEN_PID_MASK	0xFF
 #define TD_TOKEN_EXPLEN_MASK	0x7FF		/* expected length, encoded as n - 1 */
 
 #define uhci_maxlen(token)	((token) >> 21)
 #define uhci_expected_length(info) (((info >> 21) + 1) & TD_TOKEN_EXPLEN_MASK) /* 1-based */
-#define uhci_toggle(token)	(((token) >> TD_TOKEN_TOGGLE) & 1)
+#define uhci_toggle(token)	(((token) >> TD_TOKEN_TOGGLE_SHIFT) & 1)
 #define uhci_endpoint(token)	(((token) >> 15) & 0xf)
 #define uhci_devaddr(token)	(((token) >> 8) & 0x7f)
 #define uhci_devep(token)	(((token) >> 8) & 0x7ff)
diff -Nur linux-2.4.19.old/drivers/usb/usb-debug.c linux-2.4.19/drivers/usb/usb-debug.c
--- linux-2.4.19.old/drivers/usb/usb-debug.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.19/drivers/usb/usb-debug.c	Mon Nov 25 12:27:12 2002
@@ -181,23 +181,23 @@
 	kfree(buf);
 }
 
-void usb_dump_urb (purb_t purb)
+void usb_dump_urb (struct urb *urb)
 {
-	printk ("urb                   :%p\n", purb);
-	printk ("next                  :%p\n", purb->next);
-	printk ("dev                   :%p\n", purb->dev);
-	printk ("pipe                  :%08X\n", purb->pipe);
-	printk ("status                :%d\n", purb->status);
-	printk ("transfer_flags        :%08X\n", purb->transfer_flags);
-	printk ("transfer_buffer       :%p\n", purb->transfer_buffer);
-	printk ("transfer_buffer_length:%d\n", purb->transfer_buffer_length);
-	printk ("actual_length         :%d\n", purb->actual_length);
-	printk ("setup_packet          :%p\n", purb->setup_packet);
-	printk ("start_frame           :%d\n", purb->start_frame);
-	printk ("number_of_packets     :%d\n", purb->number_of_packets);
-	printk ("interval              :%d\n", purb->interval);
-	printk ("error_count           :%d\n", purb->error_count);
-	printk ("context               :%p\n", purb->context);
-	printk ("complete              :%p\n", purb->complete);
+	printk ("urb                   :%p\n", urb);
+	printk ("next                  :%p\n", urb->next);
+	printk ("dev                   :%p\n", urb->dev);
+	printk ("pipe                  :%08X\n", urb->pipe);
+	printk ("status                :%d\n", urb->status);
+	printk ("transfer_flags        :%08X\n", urb->transfer_flags);
+	printk ("transfer_buffer       :%p\n", urb->transfer_buffer);
+	printk ("transfer_buffer_length:%d\n", urb->transfer_buffer_length);
+	printk ("actual_length         :%d\n", urb->actual_length);
+	printk ("setup_packet          :%p\n", urb->setup_packet);
+	printk ("start_frame           :%d\n", urb->start_frame);
+	printk ("number_of_packets     :%d\n", urb->number_of_packets);
+	printk ("interval              :%d\n", urb->interval);
+	printk ("error_count           :%d\n", urb->error_count);
+	printk ("context               :%p\n", urb->context);
+	printk ("complete              :%p\n", urb->complete);
 }
 
diff -Nur linux-2.4.19.old/drivers/usb/usb-midi.c linux-2.4.19/drivers/usb/usb-midi.c
--- linux-2.4.19.old/drivers/usb/usb-midi.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/usb-midi.c	Mon Nov 25 12:27:12 2002
@@ -0,0 +1,2228 @@
+/*
+  usb-midi.c  --  USB-MIDI driver
+
+  Copyright (C) 2001 
+      NAGANO Daisuke <breeze.nagano@nifty.ne.jp>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2, or (at your option)
+  any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+  This driver is based on:
+    - 'Universal Serial Bus Device Class Definition for MIDI Device'
+    - linux/drivers/sound/es1371.c, linux/drivers/usb/audio.c
+    - alsa/lowlevel/pci/cs64xx.c
+    - umidi.c for NetBSD
+ */
+
+/* ------------------------------------------------------------------------- */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/wrapper.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/sound.h>
+#include <linux/init.h>
+#include <asm/semaphore.h>
+
+/** This declaration is missing from linux/usb.h **/
+extern int usb_get_string(struct usb_device *dev, unsigned short langid, unsigned char index, void *buf, int size);
+
+#include "usb-midi.h"
+
+/* ------------------------------------------------------------------------- */
+
+/* More verbose on syslog */
+#undef MIDI_DEBUG
+
+#define MIDI_IN_BUFSIZ 1024
+
+#define HAVE_SUPPORT_USB_MIDI_CLASS
+
+#undef HAVE_SUPPORT_ALSA
+
+#undef MOD_INC_EACH_PROBE
+
+/* ------------------------------------------------------------------------- */
+
+static int singlebyte = 0;
+MODULE_PARM(singlebyte,"i");
+MODULE_PARM_DESC(singlebyte,"Enable sending MIDI messages with single message packet");
+
+static int maxdevices = 4;
+MODULE_PARM(maxdevices,"i");
+MODULE_PARM_DESC(maxdevices,"Max number of allocatable MIDI device");
+
+static int uvendor     = -1;
+MODULE_PARM(uvendor,"i");
+MODULE_PARM_DESC(uvendor, "The USB Vendor ID of a semi-compliant interface");
+
+static int uproduct    = -1;
+MODULE_PARM(uproduct,"i");
+MODULE_PARM_DESC(uproduct, "The USB Product ID of a semi-compliant interface");
+
+static int uinterface  = -1;
+MODULE_PARM(uinterface,"i");
+MODULE_PARM_DESC(uinterface, "The Interface number of a semi-compliant interface");
+
+static int ualt        = -1;
+MODULE_PARM(ualt,"i");
+MODULE_PARM_DESC(ualt, "The optional alternative setting of a semi-compliant interface");
+
+static int umin        = -1;
+MODULE_PARM(umin,"i");
+MODULE_PARM_DESC(umin, "The input endpoint of a semi-compliant interface");
+
+static int umout       = -1;
+MODULE_PARM(umout,"i");
+MODULE_PARM_DESC(umout, "The output endpoint of a semi-compliant interface");
+
+static int ucable      = -1;
+MODULE_PARM(ucable,"i");
+MODULE_PARM_DESC(ucable, "The cable number used for a semi-compliant interface");
+
+/** Note -- the usb_string() returns only Latin-1 characters.
+ * (unicode chars <= 255). To support Japanese, a unicode16LE-to-EUC or
+ * unicode16LE-to-JIS routine is needed to wrap around usb_get_string().
+ **/
+static unsigned short ulangid      = 0x0409; /** 0x0411 for Japanese **/
+MODULE_PARM(ulangid,"h");
+MODULE_PARM_DESC(ulangid, "The optional preferred USB Language ID for all devices");
+
+MODULE_AUTHOR("NAGANO Daisuke <breeze.nagano@nifty.ne.jp>");
+MODULE_DESCRIPTION("USB-MIDI driver");
+#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,4,14)
+MODULE_LICENSE("GPL");
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+/** MIDIStreaming Class-Specific Interface Descriptor Subtypes **/
+
+#define MS_DESCRIPTOR_UNDEFINED	0
+#define MS_HEADER		1
+#define MIDI_IN_JACK		2
+#define MIDI_OUT_JACK		3
+/* Spec reads: ELEMENT */
+#define ELEMENT_DESCRIPTOR   	4
+
+#define MS_HEADER_LENGTH	7
+
+/** MIDIStreaming Class-Specific Endpoint Descriptor Subtypes **/
+
+#define DESCRIPTOR_UNDEFINED	0
+/* Spec reads: MS_GENERAL */
+#define MS_GENERAL_ENDPOINT	1
+
+/** MIDIStreaming MIDI IN and OUT Jack Types **/
+
+#define JACK_TYPE_UNDEFINED	0
+/* Spec reads: EMBEDDED */
+#define EMBEDDED_JACK		1
+/* Spec reads: EXTERNAL */
+#define EXTERNAL_JACK		2
+
+
+/* structure summary
+  
+      usb_midi_state     usb_device
+       |         |
+      *|        *|       per ep
+     in_ep     out_ep
+       |         |
+      *|        *|       per cable
+      min       mout
+       |         |       (cable to device pairing magic)
+       |         |
+       usb_midi_dev      dev_id (major,minor) == file->private_data
+
+*/
+
+/* usb_midi_state: corresponds to a USB-MIDI module */
+struct usb_midi_state {
+	struct list_head   mididev;
+	
+	struct usb_device *usbdev;
+	
+	struct list_head   midiDevList;
+	struct list_head   inEndpointList;
+	struct list_head   outEndpointList;
+	
+	spinlock_t         lock;
+	
+	unsigned int       count; /* usage counter */
+};
+
+/* midi_out_endpoint: corresponds to an output endpoint */
+struct midi_out_endpoint {
+	struct list_head  list;
+	
+	struct usb_device *usbdev;
+	int                endpoint;
+	spinlock_t         lock;
+	wait_queue_head_t  wait;
+	
+	unsigned char     *buf;
+	int                bufWrPtr;
+	int                bufSize;
+	
+	struct urb       *urb;
+};
+
+/* midi_in_endpoint: corresponds to an input endpoint */
+struct midi_in_endpoint {
+	struct list_head   list;
+
+	struct usb_device *usbdev;
+	int                endpoint;
+	spinlock_t         lock;
+	wait_queue_head_t  wait;
+
+	struct usb_mididev *cables[16];	// cables open for read
+	int                 readers;	// number of cables open for read
+
+	struct urb        *urb;
+	unsigned char     *recvBuf;
+	int                recvBufSize;
+	int                urbSubmitted;	//FIXME: == readers > 0
+};
+
+/* usb_mididev: corresponds to a logical device */
+struct usb_mididev {
+	struct list_head       list;
+
+	struct usb_midi_state *midi;
+	int                    dev_midi;
+	mode_t                 open_mode;
+
+	struct {
+		struct midi_in_endpoint *ep;
+		int              cableId;
+		
+// as we are pushing data from usb_bulk_read to usb_midi_read,
+// we need a larger, cyclic buffer here.
+		unsigned char    buf[MIDI_IN_BUFSIZ];
+		int              bufRdPtr;
+		int              bufWrPtr;
+		int              bufRemains;
+	} min;
+
+	struct {
+		struct midi_out_endpoint *ep;
+		int              cableId;
+		
+		unsigned char    buf[3];
+		int              bufPtr;
+		int              bufRemains;
+		
+		int              isInExclusive;
+		unsigned char    lastEvent;
+	} mout;
+
+	int singlebyte;
+};
+
+/** Map the high nybble of MIDI voice messages to number of Message bytes.
+ * High nyble ranges from 0x8 to 0xe
+ */
+
+static int remains_80e0[] = {
+	3,	/** 0x8X Note Off **/
+	3,	/** 0x9X Note On **/
+	3,	/** 0xAX Poly-key pressure **/
+	3,	/** 0xBX Control Change **/
+	2,	/** 0xCX Program Change **/
+	2,	/** 0xDX Channel pressure **/
+	3 	/** 0xEX PitchBend Change **/
+};
+
+/** Map the messages to a number of Message bytes.
+ *
+ **/
+static int remains_f0f6[] = {
+	0,	/** 0xF0 **/
+	2,	/** 0XF1 **/
+	3,	/** 0XF2 **/
+	2,	/** 0XF3 **/
+	2,	/** 0XF4 (Undefined by MIDI Spec, and subject to change) **/
+	2,	/** 0XF5 (Undefined by MIDI Spec, and subject to change) **/
+	1	/** 0XF6 **/
+};
+
+/** Map the messages to a CIN (Code Index Number).
+ *
+ **/
+static int cin_f0ff[] = {
+	4,	/** 0xF0 System Exclusive Message Start (special cases may be 6 or 7) */
+	2,	/** 0xF1 **/
+	3,	/** 0xF2 **/
+	2,	/** 0xF3 **/
+	2,	/** 0xF4 **/
+	2,	/** 0xF5 **/
+	5,	/** 0xF6 **/
+	5,	/** 0xF7 End of System Exclusive Message (May be 6 or 7) **/
+	5,	/** 0xF8 **/
+	5,	/** 0xF9 **/
+	5,	/** 0xFA **/
+	5,	/** 0xFB **/
+	5,	/** 0xFC **/
+	5,	/** 0xFD **/
+	5,	/** 0xFE **/
+	5	/** 0xFF **/
+};
+
+/** Map MIDIStreaming Event packet Code Index Number (low nybble of byte 0)
+ * to the number of bytes of valid MIDI data.
+ *
+ * CIN of 0 and 1 are NOT USED in MIDIStreaming 1.0.
+ *
+ **/
+static int cin_to_len[] = {
+	0, 0, 2, 3,
+	3, 1, 2, 3,
+	3, 3, 3, 3,
+	2, 2, 3, 1
+};
+
+
+/* ------------------------------------------------------------------------- */
+
+static struct list_head mididevs = LIST_HEAD_INIT(mididevs);
+
+static DECLARE_MUTEX(open_sem);
+static DECLARE_WAIT_QUEUE_HEAD(open_wait);
+
+
+/* ------------------------------------------------------------------------- */
+
+static void usb_write_callback(struct urb *urb)
+{
+	struct midi_out_endpoint *ep = (struct midi_out_endpoint *)urb->context;
+
+	if ( waitqueue_active( &ep->wait ) )
+		wake_up_interruptible( &ep->wait );
+}
+
+
+static int usb_write( struct midi_out_endpoint *ep, unsigned char *buf, int len )
+{
+	struct usb_device *d;
+	int pipe;
+	int ret = 0;
+	int status;
+	int maxretry = 50;
+	
+	DECLARE_WAITQUEUE(wait,current);
+	init_waitqueue_head(&ep->wait);
+
+	d = ep->usbdev;
+	pipe = usb_sndbulkpipe(d, ep->endpoint);
+	FILL_BULK_URB( ep->urb, d, pipe, (unsigned char*)buf, len,
+		       (usb_complete_t)usb_write_callback, ep );
+
+	status = usb_submit_urb(ep->urb);
+    
+	if (status) {
+		printk(KERN_ERR "usbmidi: Cannot submit urb (%d)\n",status);
+		ret = -EFAULT;
+	}
+
+	add_wait_queue( &ep->wait, &wait );
+	set_current_state( TASK_INTERRUPTIBLE );
+
+	while( ep->urb->status == -EINPROGRESS ) {
+		if ( maxretry-- < 0 ) {
+			printk(KERN_ERR "usbmidi: usb_bulk_msg timed out\n");
+			ret = -ETIME;
+			break;
+		}
+		interruptible_sleep_on_timeout( &ep->wait, 10 );
+	}
+	set_current_state( TASK_RUNNING );
+	remove_wait_queue( &ep->wait, &wait );
+
+	return ret;
+}
+
+
+/** Copy data from URB to In endpoint buf.
+ * Discard if CIN == 0 or CIN = 1.
+ *
+ *
+ **/
+
+static void usb_bulk_read(struct urb *urb)
+{
+	struct midi_in_endpoint *ep = (struct midi_in_endpoint *)(urb->context);
+	unsigned char *data = urb->transfer_buffer;
+	int i, l, wake;
+	unsigned long int flags;
+
+	if ( !ep->urbSubmitted ) {
+		return;
+	}
+
+	if ( (urb->status == 0) && (urb->actual_length > 0) ) {
+		wake = 0;
+		spin_lock_irqsave( &ep->lock, flags );
+
+		for(l = 0; l < urb->actual_length; l += 4) {
+			int cin = (data[l]>>0)&0xf;
+			int cab = (data[l]>>4)&0xf;
+			struct usb_mididev *cable = ep->cables[cab];
+			if ( cable ) {
+				int len = cin_to_len[cin]; /** length of MIDI data **/
+				for (i = 0; i < len; i++) {
+					cable->min.buf[cable->min.bufWrPtr] = data[1+i];
+					cable->min.bufWrPtr = (cable->min.bufWrPtr+1)%MIDI_IN_BUFSIZ;
+					if (cable->min.bufRemains < MIDI_IN_BUFSIZ)
+						cable->min.bufRemains += 1;
+					else /** need to drop data **/
+						cable->min.bufRdPtr += (cable->min.bufRdPtr+1)%MIDI_IN_BUFSIZ;
+					wake = 1;
+				}
+			}
+		}
+
+		spin_unlock_irqrestore( &ep->lock, flags );
+		if ( wake ) {
+			wake_up( &ep->wait );
+		}
+	}
+
+	/* urb->dev must be reinitialized on 2.4.x kernels */
+	urb->dev = ep->usbdev;
+
+	urb->actual_length = 0;
+	usb_submit_urb(urb);
+}
+
+
+
+/* ------------------------------------------------------------------------- */
+
+/* This routine must be called with spin_lock */
+
+/** Wrapper around usb_write().
+ *  This routine must be called with spin_lock held on ep.
+ *  Called by midiWrite(), putOneMidiEvent(), and  usb_midi_write();
+ **/
+static int flush_midi_buffer( struct midi_out_endpoint *ep )
+{
+	int ret=0;
+
+	if ( ep->bufWrPtr > 0 ) {
+		ret = usb_write( ep, ep->buf, ep->bufWrPtr );
+		ep->bufWrPtr = 0;
+	}
+
+	return ret;
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/** Given a MIDI Event, determine size of data to be attached to 
+ * USB-MIDI packet.
+ * Returns 1, 2 or 3.
+ * Called by midiWrite();
+ * Uses remains_80e0 and remains_f0f6;
+ **/
+static int get_remains(int event)
+{
+	int ret;
+
+	if ( event  < 0x80 ) {
+		ret = 1;
+	} else if ( event < 0xf0 ) {
+		ret = remains_80e0[((event-0x80)>>4)&0x0f];
+	} else if ( event < 0xf7 ) {
+		ret = remains_f0f6[event-0xf0];
+	} else {
+		ret = 1;
+	}
+
+	return ret;
+}
+
+/** Given the output MIDI data in the output buffer, computes a reasonable 
+ * CIN.
+ * Called by putOneMidiEvent().
+ **/
+static int get_CIN( struct usb_mididev *m )
+{
+	int cin;
+
+	if ( m->mout.buf[0] == 0xf7 ) {
+		cin = 5;
+	}
+	else if ( m->mout.buf[1] == 0xf7 ) {
+		cin = 6;
+	}
+	else if ( m->mout.buf[2] == 0xf7 ) {
+		cin = 7;
+	}
+	else {
+		if ( m->mout.isInExclusive == 1 ) {
+			cin = 4;
+		} else if ( m->mout.buf[0] < 0x80 ) {
+			/** One byte that we know nothing about. **/
+			cin = 0xF; 
+		} else if ( m->mout.buf[0] < 0xf0 ) {
+			/** MIDI Voice messages 0x8X to 0xEX map to cin 0x8 to 0xE. **/
+			cin = (m->mout.buf[0]>>4)&0x0f; 
+		}
+		else {
+			/** Special lookup table exists for real-time events. **/
+			cin = cin_f0ff[m->mout.buf[0]-0xf0];
+		}
+	}
+
+	return cin;
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+
+
+/** Move data to USB endpoint buffer.
+ *
+ **/
+static int put_one_midi_event(struct usb_mididev *m)
+{
+	int cin;
+	unsigned long flags;
+	struct midi_out_endpoint *ep = m->mout.ep;
+	int ret=0;
+
+	cin = get_CIN( m );
+	if ( cin > 0x0f || cin < 0 ) {
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave( &ep->lock, flags );
+	ep->buf[ep->bufWrPtr++] = (m->mout.cableId<<4) | cin;
+	ep->buf[ep->bufWrPtr++] = m->mout.buf[0];
+	ep->buf[ep->bufWrPtr++] = m->mout.buf[1];
+	ep->buf[ep->bufWrPtr++] = m->mout.buf[2];
+	if ( ep->bufWrPtr >= ep->bufSize ) {
+		ret = flush_midi_buffer( ep );
+	}
+	spin_unlock_irqrestore( &ep->lock, flags);
+
+	m->mout.buf[0] = m->mout.buf[1] = m->mout.buf[2] = 0;
+	m->mout.bufPtr = 0;
+
+	return ret;
+}
+
+/** Write the MIDI message v on the midi device.
+ *  Called by usb_midi_write();
+ *  Responsible for packaging a MIDI data stream into USB-MIDI packets.
+ **/
+
+static int midi_write( struct usb_mididev *m, int v )
+{
+	unsigned long flags;
+	struct midi_out_endpoint *ep = m->mout.ep;
+	int ret=0;
+	unsigned char c = (unsigned char)v;
+	unsigned char sysrt_buf[4];
+
+	if ( m->singlebyte != 0 ) {
+		/** Simple code to handle the single-byte USB-MIDI protocol. */
+		spin_lock_irqsave( &ep->lock, flags );
+		if ( ep->bufWrPtr+4 > ep->bufSize ) {
+			ret = flush_midi_buffer( ep );
+			if ( !ret ) {
+				spin_unlock_irqrestore( &ep->lock, flags );
+				return ret;
+			}
+		}
+		ep->buf[ep->bufWrPtr++] = (m->mout.cableId<<4) |  0x0f; /* single byte */
+		ep->buf[ep->bufWrPtr++] = c;
+		ep->buf[ep->bufWrPtr++] = 0;
+		ep->buf[ep->bufWrPtr++] = 0;
+		if ( ep->bufWrPtr >= ep->bufSize ) {
+			ret = flush_midi_buffer( ep );
+		}
+		spin_unlock_irqrestore( &ep->lock, flags );
+
+		return ret;
+	}
+	/** Normal USB-MIDI protocol begins here. */
+
+	if ( c > 0xf7 ) {	/* system: Realtime messages */
+		/** Realtime messages are written IMMEDIATELY. */
+		sysrt_buf[0] = (m->mout.cableId<<4) | 0x0f;
+		sysrt_buf[1] = c;
+		sysrt_buf[2] = 0;
+		sysrt_buf[3] = 0;
+		spin_lock_irqsave( &ep->lock, flags );
+		ret = usb_write( ep, sysrt_buf, 4 );
+		spin_unlock_irqrestore( &ep->lock, flags );
+		/* m->mout.lastEvent = 0; */
+
+		return ret;
+	}
+
+	if ( c >= 0x80 ) {
+		if ( c < 0xf0 ) {
+			m->mout.lastEvent = c;
+			m->mout.isInExclusive = 0;
+			m->mout.bufRemains = get_remains(c);
+		} else if ( c == 0xf0 ) {
+			/* m->mout.lastEvent = 0; */
+			m->mout.isInExclusive = 1;
+			m->mout.bufRemains = get_remains(c);
+		} else if ( c == 0xf7 && m->mout.isInExclusive == 1 ) {
+			/* m->mout.lastEvent = 0; */
+			m->mout.isInExclusive = 0;
+			m->mout.bufRemains = 1;
+		} else if ( c > 0xf0 ) {
+			/* m->mout.lastEvent = 0; */
+			m->mout.isInExclusive = 0;
+			m->mout.bufRemains = get_remains(c);
+		}
+    
+	} else if ( m->mout.bufRemains == 0 && m->mout.isInExclusive == 0 ) {
+		if ( m->mout.lastEvent == 0 ) {
+			return 0; /* discard, waiting for the first event */
+		}
+		/** track status **/
+		m->mout.buf[0] = m->mout.lastEvent;
+		m->mout.bufPtr = 1;
+		m->mout.bufRemains = get_remains(m->mout.lastEvent)-1;
+	}
+  
+	m->mout.buf[m->mout.bufPtr++] = c;
+	m->mout.bufRemains--;
+	if ( m->mout.bufRemains == 0 || m->mout.bufPtr >= 3) {
+		ret = put_one_midi_event(m);
+	}
+
+	return ret;
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+/** Basic operation on /dev/midiXX as registered through struct file_operations.
+ *
+ *  Basic contract: Used to change the current read/write position in a file.
+ *  On success, the non-negative position is reported.
+ *  On failure, the negative of an error code is reported.
+ *
+ *  Because a MIDIStream is not a file, all seek operations are doomed to fail.
+ *
+ **/
+static loff_t usb_midi_llseek(struct file *file, loff_t offset, int origin)
+{
+	/** Tell user you cannot seek on a PIPE-like device. **/
+	return -ESPIPE;
+}
+
+
+/** Basic operation on /dev/midiXX as registered through struct file_operations.
+ *
+ * Basic contract: Block until count bytes have been read or an error occurs.
+ *
+ **/
+
+static ssize_t usb_midi_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	struct usb_mididev *m = (struct usb_mididev *)file->private_data;
+	struct midi_in_endpoint *ep = m->min.ep;
+	ssize_t ret;
+	DECLARE_WAITQUEUE(wait, current);
+
+	if ( ppos != &file->f_pos ) {
+		return -ESPIPE;
+	}
+	if ( !access_ok(VERIFY_READ, buffer, count) ) {
+		return -EFAULT;
+	}
+	if ( count == 0 ) {
+		return 0;
+	}
+
+	add_wait_queue( &ep->wait, &wait );
+	ret = 0;
+	while( count > 0 ) {
+		int cnt;
+		int d = (int)count;
+
+		cnt = m->min.bufRemains;
+		if ( cnt > d ) {
+			cnt = d;
+		}
+
+		if ( cnt <= 0 ) {
+			if ( file->f_flags & O_NONBLOCK ) {
+				if (!ret) 
+					ret = -EAGAIN;
+				break;
+			}
+			__set_current_state(TASK_INTERRUPTIBLE);
+			schedule();
+			if (signal_pending(current)) {
+				if(!ret)
+					ret=-ERESTARTSYS;
+				break;
+			}
+			continue;
+		}
+
+		{
+			int i;
+			unsigned long flags; /* used to synchronize access to the endpoint */
+			spin_lock_irqsave( &ep->lock, flags );
+			for (i = 0; i < cnt; i++) {
+				if ( copy_to_user( buffer+i, m->min.buf+m->min.bufRdPtr, 1 ) ) {
+					if ( !ret )
+						ret = -EFAULT;
+					break;
+				}
+				m->min.bufRdPtr = (m->min.bufRdPtr+1)%MIDI_IN_BUFSIZ;
+				m->min.bufRemains -= 1;
+			}
+			spin_unlock_irqrestore( &ep->lock, flags );
+		}
+
+		count-=cnt;
+		buffer+=cnt;
+		ret+=cnt;
+
+		break;
+	}
+
+	remove_wait_queue( &ep->wait, &wait );
+	set_current_state(TASK_RUNNING);
+
+	return ret;
+}
+
+
+/** Basic operation on /dev/midiXX as registered through struct file_operations.
+ *
+ *  Basic Contract: Take MIDI data byte-by-byte and pass it to
+ *  writeMidi() which packages MIDI data into USB-MIDI stream.
+ *  Then flushMidiData() is called to ensure all bytes have been written
+ *  in a timely fashion.
+ *
+ **/
+
+static ssize_t usb_midi_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)
+{
+	struct usb_mididev *m = (struct usb_mididev *)file->private_data;
+	ssize_t ret;
+	unsigned long int flags;
+
+	if ( ppos != &file->f_pos ) {
+		return -ESPIPE;
+	}
+	if ( !access_ok(VERIFY_READ, buffer, count) ) {
+		return -EFAULT;
+	}
+	if ( count == 0 ) {
+		return 0;
+	}
+
+	ret = 0;
+	while( count > 0 ) {
+		unsigned char c;
+
+		if (copy_from_user((unsigned char *)&c, buffer, 1)) {
+			if ( ret == 0 )
+				ret = -EFAULT;
+			break;
+		}
+		if( midi_write(m, (int)c) ) {
+			if ( ret == 0 )
+				ret = -EFAULT;
+			break;
+		}
+		count--;
+		buffer++;
+		ret++;
+	}
+
+	spin_lock_irqsave( &m->mout.ep->lock, flags );
+	if ( flush_midi_buffer(m->mout.ep) < 0 ) {
+		ret = -EFAULT;
+	}
+	spin_unlock_irqrestore( &m->mout.ep->lock, flags );
+
+	return ret;
+}
+
+/** Basic operation on /dev/midiXX as registered through struct file_operations.
+ *
+ * Basic contract:  Wait (spin) until ready to read or write on the file.
+ *
+ **/
+static unsigned int usb_midi_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct usb_mididev *m = (struct usb_mididev *)file->private_data;
+	struct midi_in_endpoint *iep = m->min.ep;
+	struct midi_out_endpoint *oep = m->mout.ep;
+	unsigned long flags;
+	unsigned int mask = 0;
+  
+	if ( file->f_mode & FMODE_READ ) {
+		poll_wait( file, &iep->wait, wait );
+		spin_lock_irqsave( &iep->lock, flags );
+		if ( m->min.bufRemains > 0 )
+			mask |= POLLIN | POLLRDNORM;
+		spin_unlock_irqrestore( &iep->lock, flags );
+	}
+
+	if ( file->f_mode & FMODE_WRITE ) {
+		poll_wait( file, &oep->wait, wait );
+		spin_lock_irqsave( &oep->lock, flags );
+		if ( oep->bufWrPtr < oep->bufSize )
+			mask |= POLLOUT | POLLWRNORM;
+		spin_unlock_irqrestore( &oep->lock, flags );
+	}
+
+	return mask;
+}
+
+
+/** Basic operation on /dev/midiXX as registered through struct file_operations.
+ *
+ * Basic contract: This is always the first operation performed on the
+ * device node. If no method is defined, the open succeeds without any
+ * notification given to the module.
+ *
+ **/
+
+static int usb_midi_open(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+	DECLARE_WAITQUEUE(wait, current);
+	struct list_head      *devs, *mdevs;
+	struct usb_midi_state *s;
+	struct usb_mididev    *m;
+	int flags;
+	int succeed = 0;
+
+#if 0
+	printk(KERN_INFO "usb-midi: Open minor= %d.\n", minor);
+#endif
+
+	for(;;) {
+		down(&open_sem);
+		for (devs = mididevs.next; devs != &mididevs; devs = devs->next) {
+			s = list_entry(devs, struct usb_midi_state, mididev);
+			for (mdevs = s->midiDevList.next; mdevs != &s->midiDevList; mdevs = mdevs->next) {
+				m = list_entry(mdevs, struct usb_mididev, list);
+				if ( !((m->dev_midi ^ minor) & ~0xf) )
+					goto device_found;
+			}
+		}
+		up(&open_sem);
+		return -ENODEV;
+
+	device_found:
+		if ( !s->usbdev ) {
+			up(&open_sem);
+			return -EIO;
+		}
+		if ( !(m->open_mode & file->f_mode) ) {
+			break;
+		}
+		if ( file->f_flags & O_NONBLOCK ) {
+			up(&open_sem);
+			return -EBUSY;
+		}
+		__set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue( &open_wait, &wait );
+		up(&open_sem);
+		schedule();
+		__set_current_state(TASK_RUNNING);
+		remove_wait_queue( &open_wait, &wait );
+		if ( signal_pending(current) ) {
+			return -ERESTARTSYS;
+		}
+	}
+
+	file->private_data = m;
+	spin_lock_irqsave( &s->lock, flags );
+
+	if ( !(m->open_mode & (FMODE_READ | FMODE_WRITE)) ) {
+		//FIXME: intented semantics unclear here
+		m->min.bufRdPtr       = 0;
+		m->min.bufWrPtr       = 0;
+		m->min.bufRemains     = 0;
+		spin_lock_init(&m->min.ep->lock);
+
+		m->mout.bufPtr        = 0;
+		m->mout.bufRemains    = 0;
+		m->mout.isInExclusive = 0;
+		m->mout.lastEvent     = 0;
+		spin_lock_init(&m->mout.ep->lock);
+	}
+
+	if ( (file->f_mode & FMODE_READ) && m->min.ep != NULL ) {
+		unsigned long int flagsep;
+		spin_lock_irqsave( &m->min.ep->lock, flagsep );
+		m->min.ep->cables[m->min.cableId] = m;
+		m->min.ep->readers += 1;
+		m->min.bufRdPtr       = 0;
+		m->min.bufWrPtr       = 0;
+		m->min.bufRemains     = 0;
+		spin_unlock_irqrestore( &m->min.ep->lock, flagsep );
+
+		if ( !(m->min.ep->urbSubmitted)) {
+
+			/* urb->dev must be reinitialized on 2.4.x kernels */
+			m->min.ep->urb->dev = m->min.ep->usbdev;
+
+			if ( usb_submit_urb(m->min.ep->urb) ) {
+				printk(KERN_ERR "usbmidi: Cannot submit urb for MIDI-IN\n");
+			}
+			m->min.ep->urbSubmitted = 1;
+		}
+		m->open_mode |= FMODE_READ;
+		succeed = 1;
+	}
+
+	if ( (file->f_mode & FMODE_WRITE) && m->mout.ep != NULL ) {
+		m->mout.bufPtr        = 0;
+		m->mout.bufRemains    = 0;
+		m->mout.isInExclusive = 0;
+		m->mout.lastEvent     = 0;
+		m->open_mode |= FMODE_WRITE;
+		succeed = 1;
+	}
+
+	spin_unlock_irqrestore( &s->lock, flags );
+
+	s->count++;
+	up(&open_sem);
+
+	/** Changed to prevent extra increments to USE_COUNT. **/
+	if (!succeed) {
+		return -EBUSY;
+	}
+
+#if 0
+	printk(KERN_INFO "usb-midi: Open Succeeded. minor= %d.\n", minor);
+#endif
+
+	/** Side-effect: module cannot be removed until USE_COUNT is 0. **/
+#ifndef MOD_INC_EACH_PROBE
+	MOD_INC_USE_COUNT;
+#endif
+
+	return 0; /** Success. **/
+}
+
+
+/** Basic operation on /dev/midiXX as registered through struct file_operations.
+ *
+ *  Basic contract: Close an opened file and deallocate anything we allocated.
+ *  Like open(), this can be missing. If open set file->private_data,
+ *  release() must clear it.
+ *
+ **/
+
+static int usb_midi_release(struct inode *inode, struct file *file)
+{
+	struct usb_mididev *m = (struct usb_mididev *)file->private_data;
+	struct usb_midi_state *s = (struct usb_midi_state *)m->midi;
+
+#if 0
+	printk(KERN_INFO "usb-midi: Close.\n");
+#endif
+
+	down(&open_sem);
+
+	if ( m->open_mode & FMODE_WRITE ) {
+		m->open_mode &= ~FMODE_WRITE;
+		usb_unlink_urb( m->mout.ep->urb );
+	}
+
+	if ( m->open_mode & FMODE_READ ) {
+	        unsigned long int flagsep;
+	        spin_lock_irqsave( &m->min.ep->lock, flagsep );
+                m->min.ep->cables[m->min.cableId] = 0; // discard cable
+                m->min.ep->readers -= 1;
+		m->open_mode &= ~FMODE_READ;
+		if ( m->min.ep->readers == 0 &&
+                     m->min.ep->urbSubmitted ) {
+			m->min.ep->urbSubmitted = 0;
+			usb_unlink_urb(m->min.ep->urb);
+		}
+	        spin_unlock_irqrestore( &m->min.ep->lock, flagsep );
+	}
+
+	s->count--;
+
+	up(&open_sem);
+	wake_up(&open_wait);
+
+	file->private_data = 0;
+	/** Sideeffect: Module cannot be removed until usecount is 0. */
+#ifndef MOD_INC_EACH_PROBE
+	MOD_DEC_USE_COUNT;
+#endif
+
+	return 0;
+}
+
+static struct file_operations usb_midi_fops = {
+	llseek:		usb_midi_llseek,
+	read:		usb_midi_read,
+	write:		usb_midi_write,
+	poll:		usb_midi_poll,
+	open:		usb_midi_open,
+	release:	usb_midi_release,
+};
+
+/* ------------------------------------------------------------------------- */
+
+/** Returns filled midi_in_endpoint structure or null on failure.
+ *
+ * Parameters:
+ *	d        - a usb_device
+ *	endPoint - An usb endpoint in the range 0 to 15.
+ * Called by allocUsbMidiDev();
+ *
+ **/
+
+static struct midi_in_endpoint *alloc_midi_in_endpoint( struct usb_device *d, int endPoint )
+{
+	struct midi_in_endpoint *ep;
+	int bufSize;
+	int pipe;
+
+	endPoint &= 0x0f; /* Silently force endPoint to lie in range 0 to 15. */
+
+	pipe =  usb_rcvbulkpipe( d, endPoint );
+	bufSize = usb_maxpacket( d, pipe, usb_pipein(pipe) );
+	/* usb_pipein() = ! usb_pipeout() = true for an in Endpoint */
+
+	ep = (struct midi_in_endpoint *)kmalloc(sizeof(struct midi_in_endpoint), GFP_KERNEL);
+	if ( !ep ) {
+		printk(KERN_ERR "usbmidi: no memory for midi in-endpoint\n");
+		return NULL;
+	}
+	memset( ep, 0, sizeof(struct midi_in_endpoint) );
+//      this sets cables[] and readers to 0, too.
+//      for (i=0; i<16; i++) ep->cables[i] = 0; // discard cable
+//      ep->readers = 0;
+
+	ep->endpoint = endPoint;
+
+	ep->recvBuf = (unsigned char *)kmalloc(sizeof(unsigned char)*(bufSize), GFP_KERNEL);
+	if ( !ep->recvBuf ) {
+		printk(KERN_ERR "usbmidi: no memory for midi in-endpoint buffer\n");
+		kfree(ep);
+		return NULL;
+	}
+
+	ep->urb = usb_alloc_urb(0); /* no ISO */
+	if ( !ep->urb ) {
+		printk(KERN_ERR "usbmidi: no memory for midi in-endpoint urb\n");
+		kfree(ep->recvBuf);
+		kfree(ep);
+		return NULL;
+	}
+	FILL_BULK_URB( ep->urb, d, 
+		       usb_rcvbulkpipe(d, endPoint),
+		       (unsigned char *)ep->recvBuf, bufSize,
+		       (usb_complete_t)usb_bulk_read, ep );
+
+	/* ep->bufRdPtr     = 0; */
+	/* ep->bufWrPtr     = 0; */
+	/* ep->bufRemains   = 0; */
+	/* ep->urbSubmitted = 0; */
+	ep->recvBufSize  = bufSize;
+
+	init_waitqueue_head(&ep->wait);
+
+	return ep;
+}
+
+static int remove_midi_in_endpoint( struct midi_in_endpoint *min )
+{
+	usb_unlink_urb( min->urb );
+	usb_free_urb( min->urb );
+	kfree( min->recvBuf );
+	kfree( min );
+
+	return 0;
+}
+
+/** Returns filled midi_out_endpoint structure or null on failure.
+ *
+ * Parameters:
+ *	d        - a usb_device
+ *	endPoint - An usb endpoint in the range 0 to 15.
+ * Called by allocUsbMidiDev();
+ *
+ **/
+static struct midi_out_endpoint *alloc_midi_out_endpoint( struct usb_device *d, int endPoint )
+{
+	struct midi_out_endpoint *ep = NULL;
+	int pipe;
+	int bufSize;
+
+	endPoint &= 0x0f;
+	pipe =  usb_sndbulkpipe( d, endPoint );
+	bufSize = usb_maxpacket( d, pipe, usb_pipeout(pipe) );
+
+	ep = (struct midi_out_endpoint *)kmalloc(sizeof(struct midi_out_endpoint), GFP_KERNEL);
+	if ( !ep ) {
+		printk(KERN_ERR "usbmidi: no memory for midi out-endpoint\n");
+		return NULL;
+	}
+	memset( ep, 0, sizeof(struct midi_out_endpoint) );
+
+	ep->endpoint = endPoint;
+	ep->buf = (unsigned char *)kmalloc(sizeof(unsigned char)*bufSize, GFP_KERNEL);
+	if ( !ep->buf ) {
+		printk(KERN_ERR "usbmidi: no memory for midi out-endpoint buffer\n");
+		kfree(ep);
+		return NULL;
+	}
+
+	ep->urb = usb_alloc_urb(0); /* no ISO */
+	if ( !ep->urb ) {
+		printk(KERN_ERR "usbmidi: no memory for midi out-endpoint urb\n");
+		kfree(ep->buf);
+		kfree(ep);
+		return NULL;
+	}
+
+	ep->bufSize       = bufSize;
+	/* ep->bufWrPtr      = 0; */
+
+	init_waitqueue_head(&ep->wait);
+
+	return ep;
+}
+
+
+static int remove_midi_out_endpoint( struct midi_out_endpoint *mout )
+{
+	usb_unlink_urb( mout->urb );
+	usb_free_urb( mout->urb );
+	kfree( mout->buf );
+	kfree( mout );
+
+	return 0;
+}
+
+
+/** Returns a filled usb_mididev structure, registered as a Linux MIDI device.
+ *
+ * Returns null if memory is not available or the device cannot be registered.
+ * Called by allocUsbMidiDev();
+ *
+ **/
+static struct usb_mididev *allocMidiDev(
+	struct usb_midi_state *s,
+	struct midi_in_endpoint *min,
+	struct midi_out_endpoint *mout,
+	int inCableId,
+	int outCableId )
+{
+	struct usb_mididev *m;
+
+	m = (struct usb_mididev *)kmalloc(sizeof(struct usb_mididev), GFP_KERNEL);
+	if (!m) {
+		printk(KERN_ERR "usbmidi: no memory for midi device\n");
+		return NULL;
+	}
+
+	memset(m, 0, sizeof(struct usb_mididev));
+
+	if ((m->dev_midi = register_sound_midi(&usb_midi_fops, -1)) < 0) {
+		printk(KERN_ERR "usbmidi: cannot register midi device\n");
+		kfree(m);
+		return NULL;
+	}
+
+	m->midi               = s;
+	/* m->open_mode          = 0; */
+
+	if ( min ) {
+		m->min.ep             = min;
+		m->min.ep->usbdev     = s->usbdev;
+		m->min.cableId        = inCableId;
+	}
+	/* m->min.bufPtr         = 0; */
+	/* m->min.bufRemains     = 0; */
+
+	if ( mout ) {
+		m->mout.ep            = mout;
+		m->mout.ep->usbdev    = s->usbdev;
+		m->mout.cableId       = outCableId;
+	}
+	/* m->mout.bufPtr        = 0; */
+	/* m->mout.bufRemains    = 0; */
+	/* m->mout.isInExclusive = 0; */
+	/* m->mout.lastEvent     = 0; */
+
+	m->singlebyte         = singlebyte;
+
+	return m;
+}
+
+
+static void release_midi_device( struct usb_midi_state *s )
+{
+	struct usb_mididev *m;
+	struct midi_in_endpoint *min;
+	struct midi_out_endpoint *mout;
+
+	if ( s->count > 0 ) {
+		up(&open_sem);
+		return;
+	}
+	up( &open_sem );
+	wake_up( &open_wait );
+
+	while(!list_empty(&s->inEndpointList)) {
+		min = list_entry(s->inEndpointList.next, struct midi_in_endpoint, list);
+		list_del(&min->list);
+		remove_midi_in_endpoint(min);
+	}
+
+	while(!list_empty(&s->outEndpointList)) {
+		mout = list_entry(s->outEndpointList.next, struct midi_out_endpoint, list);
+		list_del(&mout->list);
+		remove_midi_out_endpoint(mout);
+	}
+
+	while(!list_empty(&s->midiDevList)) {
+		m = list_entry(s->midiDevList.next, struct usb_mididev, list);
+		list_del(&m->list);
+		kfree(m);
+	}
+
+	kfree(s);
+
+	return;
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+/** Utility routine to find a descriptor in a dump of many descriptors.
+ * Returns start of descriptor or NULL if not found. 
+ * descStart pointer to list of interfaces.
+ * descLength length (in bytes) of dump
+ * after (ignored if NULL) this routine returns only descriptors after "after"
+ * dtype (mandatory) The descriptor type.
+ * iface (ignored if -1) returns descriptor at/following given interface
+ * altSetting (ignored if -1) returns descriptor at/following given altSetting
+ *
+ *
+ *  Called by parseDescriptor(), find_csinterface_descriptor();
+ *
+ */
+static void *find_descriptor( void *descStart, unsigned int descLength, void *after, unsigned char dtype, int iface, int altSetting )
+{
+	unsigned char *p, *end, *next;
+	int interfaceNumber = -1, altSet = -1;
+
+	p = descStart;
+	end = p + descLength;
+	for( ; p < end; ) {
+		if ( p[0] < 2 )
+			return NULL;
+		next = p + p[0];
+		if ( next > end )
+			return NULL;
+		if ( p[1] == USB_DT_INTERFACE ) {
+			if ( p[0] < USB_DT_INTERFACE_SIZE )
+				return NULL;
+			interfaceNumber = p[2];
+			altSet = p[3];
+		}
+		if ( p[1] == dtype &&
+		     ( !after || ( p > (unsigned char *)after) ) &&
+		     ( ( iface == -1) || (iface == interfaceNumber) ) &&
+		     ( (altSetting == -1) || (altSetting == altSet) )) {
+			return p;
+		}
+		p = next;
+	}
+	return NULL;
+}
+
+/** Utility to find a class-specfic interface descriptor.
+ *  dsubtype is a descriptor subtype
+ *  Called by parseDescriptor();
+ **/
+static void *find_csinterface_descriptor(void *descStart, unsigned int descLength, void *after, u8 dsubtype, int iface, int altSetting)
+{
+	unsigned char *p;
+  
+	p = find_descriptor( descStart, descLength, after, USB_DT_CS_INTERFACE, iface, altSetting );
+	while ( p ) {
+		if ( p[0] >= 3 && p[2] == dsubtype )
+			return p;
+		p = find_descriptor( descStart, descLength, p, USB_DT_CS_INTERFACE, 
+				     iface, altSetting );
+	}
+	return NULL;
+}
+
+
+/** The magic of making a new usb_midi_device from config happens here.
+ *
+ * The caller is responsible for free-ing this return value (if not NULL).
+ *
+ **/
+static struct usb_midi_device *parse_descriptor( struct usb_device *d, unsigned char *buffer, int bufSize, unsigned int ifnum , unsigned int altSetting, int quirks)
+{
+	struct usb_midi_device *u;
+	unsigned char *p1;
+	unsigned char *p2;
+	unsigned char *next;
+	int iep, oep;
+	int length;
+	unsigned long longBits;
+	int pins, nbytes, offset, shift, jack;
+#ifdef HAVE_JACK_STRINGS
+	/** Jacks can have associated names.  **/
+	unsigned char jack2string[256];
+#endif
+
+	u = 0;
+	/* find audiocontrol interface */
+	p1 = find_csinterface_descriptor( buffer, bufSize, NULL,
+					  MS_HEADER, ifnum, altSetting);
+
+	if ( !p1 ) {
+		goto error_end;
+	}
+
+	if ( p1[0] < MS_HEADER_LENGTH ) {
+		goto error_end;
+	}
+
+	/* Assume success. Since the device corresponds to USB-MIDI spec, we assume
+	   that the rest of the USB 2.0 spec is obeyed. */
+
+	u = (struct usb_midi_device *)kmalloc( sizeof(struct usb_midi_device), GFP_KERNEL );
+	if ( !u ) {
+		return NULL;
+	}
+	u->deviceName = 0;
+	u->idVendor = d->descriptor.idVendor;
+	u->idProduct = d->descriptor.idProduct;
+	u->interface = ifnum;
+	u->altSetting = altSetting;
+	u->in[0].endpoint = -1;
+	u->in[0].cableId = -1;
+	u->out[0].endpoint = -1;
+	u->out[0].cableId = -1;
+
+
+	printk(KERN_INFO "usb-midi: Found MIDIStreaming device corresponding to Release %d.%02d of spec.\n",
+	       (p1[4] >> 4) * 10 + (p1[4] & 0x0f ),
+	       (p1[3] >> 4) * 10 + (p1[3] & 0x0f )
+		);
+
+	length = p1[5] | (p1[6] << 8);
+
+#ifdef HAVE_JACK_STRINGS
+	memset(jack2string, 0, sizeof(unsigned char) * 256);
+#endif
+
+	length -= p1[0];
+	for (p2 = p1 + p1[0]; length > 0; p2 = next) {
+		next = p2 + p2[0];
+		length -= p2[0];
+
+		if (p2[0] < 2 ) break;
+		if (p2[1] != USB_DT_CS_INTERFACE) break;
+		if (p2[2] == MIDI_IN_JACK && p2[0] >= 6 ) {
+			jack = p2[4];
+#ifdef HAVE_JACK_STRINGS
+			jack2string[jack] = p2[5];
+#endif
+			printk(KERN_INFO "usb-midi: Found IN Jack 0x%02x %s\n",
+			       jack, (p2[3] == EMBEDDED_JACK)?"EMBEDDED":"EXTERNAL" );
+		} else if ( p2[2] == MIDI_OUT_JACK && p2[0] >= 6) {
+			pins = p2[5];
+			if ( p2[0] < (6 + 2 * pins) ) continue;
+			jack = p2[4];
+#ifdef HAVE_JACK_STRINGS
+			jack2string[jack] = p2[5 + 2 * pins];
+#endif
+			printk(KERN_INFO "usb-midi: Found OUT Jack 0x%02x %s, %d pins\n",
+			       jack, (p2[3] == EMBEDDED_JACK)?"EMBEDDED":"EXTERNAL", pins );
+		} else if ( p2[2] == ELEMENT_DESCRIPTOR  && p2[0]  >= 10) {
+			pins = p2[4];
+			if ( p2[0] < (9 + 2 * pins ) ) continue;
+			nbytes = p2[8 + 2 * pins ];
+			if ( p2[0] < (10 + 2 * pins + nbytes) ) continue;
+			longBits = 0L;
+			for ( offset = 0, shift = 0; offset < nbytes && offset < 8; offset ++, shift += 8) {
+				longBits |= ((long)(p2[9 + 2 * pins + offset])) << shift;
+			}
+			jack = p2[3];
+#ifdef HAVE_JACK_STRINGS
+			jack2string[jack] = p2[9 + 2 * pins + nbytes];
+#endif
+			printk(KERN_INFO "usb-midi: Found ELEMENT 0x%02x, %d/%d pins in/out, bits: 0x%016lx\n",
+			       jack, pins, (int)(p2[5 + 2 * pins]), (long)longBits );
+		} else {
+		}
+	}
+
+	iep=0;
+	oep=0;
+
+	if (quirks==0) {
+		/* MIDISTREAM */
+		p2 = 0;
+		for (p1 = find_descriptor(buffer, bufSize, NULL, USB_DT_ENDPOINT,
+					  ifnum, altSetting ); p1; p1 = next ) {
+			next = find_descriptor(buffer, bufSize, p1, USB_DT_ENDPOINT,
+					       ifnum, altSetting ); 
+			p2 = find_descriptor(buffer, bufSize, p1, USB_DT_CS_ENDPOINT,
+					     ifnum, altSetting ); 
+
+			if ( p2 && next && ( p2 > next ) )
+				p2 = 0;
+
+			if ( p1[0] < 9 || !p2 || p2[0] < 4 ) continue;
+
+			if ( (p1[2] & 0x80) == 0x80 ) {
+				if ( iep < 15 ) {
+					pins = p2[3]; /* not pins -- actually "cables" */
+					if ( pins > 16 )
+						pins = 16;
+					u->in[iep].endpoint = p1[2];
+					u->in[iep].cableId = ( 1 << pins ) - 1;
+					if ( u->in[iep].cableId ) iep ++;
+					if ( iep < 15 ) {
+						u->in[iep].endpoint = -1;
+						u->in[iep].cableId = -1;
+					}
+				}
+			} else {
+				if ( oep < 15 ) {
+					pins = p2[3]; /* not pins -- actually "cables" */
+					if ( pins > 16 )
+						pins = 16;
+					u->out[oep].endpoint = p1[2];
+					u->out[oep].cableId = ( 1 << pins ) - 1;
+					if ( u->out[oep].cableId ) oep ++;
+					if ( oep < 15 ) {
+						u->out[oep].endpoint = -1;
+						u->out[oep].cableId = -1;
+					}
+				}
+			}
+	
+		}
+	} else if (quirks==1) {
+		/* YAMAHA quirks */
+		for (p1 = find_descriptor(buffer, bufSize, NULL, USB_DT_ENDPOINT,
+					  ifnum, altSetting ); p1; p1 = next ) {
+			next = find_descriptor(buffer, bufSize, p1, USB_DT_ENDPOINT,
+					       ifnum, altSetting ); 
+	
+			if ( p1[0] < 7 ) continue;
+
+			if ( (p1[2] & 0x80) == 0x80 ) {
+				if ( iep < 15 ) {
+					pins = iep+1;
+					if ( pins > 16 )
+						pins = 16;
+					u->in[iep].endpoint = p1[2];
+					u->in[iep].cableId = ( 1 << pins ) - 1;
+					if ( u->in[iep].cableId ) iep ++;
+					if ( iep < 15 ) {
+						u->in[iep].endpoint = -1;
+						u->in[iep].cableId = -1;
+					}
+				}
+			} else {
+				if ( oep < 15 ) {
+					pins = oep+1;
+					if ( pins > 16 )
+						pins = 16;
+					u->out[oep].endpoint = p1[2];
+					u->out[oep].cableId = ( 1 << pins ) - 1;
+					if ( u->out[oep].cableId ) oep ++;
+					if ( oep < 15 ) {
+						u->out[oep].endpoint = -1;
+						u->out[oep].cableId = -1;
+					}
+				}
+			}
+	
+		}
+	}
+
+	if ( !iep && ! oep ) {
+		goto error_end;
+	}
+
+	return u;
+
+error_end:
+	if ( u ) kfree(u);
+	return NULL;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/** Returns number between 0 and 16.
+ *
+ **/
+static int on_bits( unsigned short v )
+{
+	int i;
+	int ret=0;
+
+	for ( i=0 ; i<16 ; i++ ) {
+		if ( v & (1<<i) ) ret++;
+	}
+
+	return ret;
+}
+
+
+/** USB-device will be interrogated for altSetting.
+ *
+ * Returns negative on error.
+ * Called by allocUsbMidiDev();
+ *
+ **/
+
+static int get_alt_setting( struct usb_device *d, int ifnum )
+{
+	int alts, alt=0;
+	struct usb_interface_descriptor *interface;
+	struct usb_endpoint_descriptor *ep;
+	int epin, epout;
+	int i;
+
+	alts = d->actconfig->interface[ifnum].num_altsetting;
+
+	for ( alt=0 ; alt<alts ; alt++ ) {
+		interface = &d->actconfig->interface[ifnum].altsetting[alt];
+		epin = -1;
+		epout = -1;
+
+		for ( i=0 ; i<interface->bNumEndpoints ; i++ ) {
+			ep = &interface->endpoint[i];
+			if ( (ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_BULK ) {
+				continue;
+			}
+			if ( (ep->bEndpointAddress & USB_DIR_IN) && epin < 0 ) {
+				epin = i;
+			} else if ( epout < 0 ) {
+				epout = i;
+			}
+			if ( epin >= 0 && epout >= 0 ) {
+				return alt;
+			}
+		}
+	}
+
+	return -ENODEV;
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/** Returns 0 if successful in allocating and registering internal structures.
+ * Returns negative on failure.
+ * Calls allocMidiDev which additionally registers /dev/midiXX devices.
+ * Writes messages on success to indicate which /dev/midiXX is which physical
+ * endpoint.
+ *
+ **/
+static int alloc_usb_midi_device( struct usb_device *d, struct usb_midi_state *s, struct usb_midi_device *u )
+{
+	struct usb_mididev **mdevs=NULL;
+	struct midi_in_endpoint *mins[15], *min;
+	struct midi_out_endpoint *mouts[15], *mout;
+	int inDevs=0, outDevs=0;
+	int inEndpoints=0, outEndpoints=0;
+	int inEndpoint, outEndpoint;
+	int inCableId, outCableId;
+	int i;
+	int devices = 0;
+	int alt = 0;
+
+	/* Obtain altSetting or die.. */
+	alt = u->altSetting;
+	if ( alt < 0 ) {
+		alt = get_alt_setting( d, u->interface );
+	}
+	if ( alt < 0 ) { return -ENXIO; }
+
+	/* Configure interface */
+	if ( usb_set_interface( d, u->interface, alt ) < 0 ) {
+		return -ENXIO;
+	}
+
+	for ( i = 0 ; i < 15 ; i++ ) {
+		mins[i] = NULL;
+		mouts[i] = NULL;
+	}
+
+	/* Begin Allocation */
+	while( inEndpoints < 15
+	       && inDevs < maxdevices
+	       && u->in[inEndpoints].cableId >= 0 ) {
+		inDevs += on_bits((unsigned short)u->in[inEndpoints].cableId);
+		mins[inEndpoints] = alloc_midi_in_endpoint( d, u->in[inEndpoints].endpoint );
+		if ( mins[inEndpoints] == NULL ) { goto error_end; }
+		inEndpoints++;
+	}
+
+	while( outEndpoints < 15
+	       && outDevs < maxdevices
+	       && u->out[outEndpoints].cableId >= 0 ) {
+		outDevs += on_bits((unsigned short)u->out[outEndpoints].cableId);
+		mouts[outEndpoints] = alloc_midi_out_endpoint( d, u->out[outEndpoints].endpoint );
+		if ( mouts[outEndpoints] == NULL ) { goto error_end; }
+		outEndpoints++;
+	}
+
+	devices = inDevs > outDevs ? inDevs : outDevs;
+	devices = maxdevices > devices ? devices : maxdevices;
+
+	/* obtain space for device name (iProduct) if not known. */
+	if ( ! u->deviceName ) {
+		mdevs = (struct usb_mididev **)
+			kmalloc(sizeof(struct usb_mididevs *)*devices
+				+ sizeof(char) * 256, GFP_KERNEL);
+	} else {
+		mdevs = (struct usb_mididev **)
+			kmalloc(sizeof(struct usb_mididevs *)*devices, GFP_KERNEL);
+	}
+
+	if ( !mdevs ) {
+		/* devices = 0; */
+		/* mdevs = NULL; */
+		goto error_end;
+	}
+	for ( i=0 ; i<devices ; i++ ) {
+		mdevs[i] = NULL;
+	}
+
+	/* obtain device name (iProduct) if not known. */
+	if ( ! u->deviceName ) {
+		u->deviceName = (char *) (mdevs + devices);
+		if ( ! d->have_langid && d->descriptor.iProduct) {
+			alt = usb_get_string(d, 0, 0, u->deviceName, 250);
+			if (alt < 0) {
+				printk(KERN_INFO "error getting string descriptor 0 (error=%d)\n", alt);
+			} else if (u->deviceName[0] < 4) {
+				printk(KERN_INFO "string descriptor 0 too short (length = %d)\n", alt);
+			} else {
+				printk(KERN_INFO "string descriptor 0 found (length = %d)\n", alt);
+				for(; alt >= 4; alt -= 2) {
+					i = u->deviceName[alt-2] | (u->deviceName[alt-1]<< 8);
+					printk(KERN_INFO "usb-midi: langid(%d) 0x%04x\n",
+					       (alt-4) >> 1, i);
+					if ( ( ( i ^ ulangid ) & 0xff ) == 0 ) {
+						d->have_langid = 1;
+						d->string_langid = i;
+						printk(KERN_INFO "usb-midi: langid(match) 0x%04x\n", i);
+						if ( i == ulangid )
+							break;
+					}
+				}
+			}
+		}
+		u->deviceName[0] = (char) 0;
+		if (d->descriptor.iProduct) {
+			printk(KERN_INFO "usb-midi: fetchString(%d)\n", d->descriptor.iProduct);
+			alt = usb_string(d, d->descriptor.iProduct, u->deviceName, 255);
+			if( alt < 0 ) {
+				u->deviceName[0] = (char) 0;
+			}
+			printk(KERN_INFO "usb-midi: fetchString = %d\n", alt);
+		} 
+		/* Failsafe */
+		if ( !u->deviceName[0] ) {
+			if ( d->descriptor.idVendor == USB_VENDOR_ID_ROLAND ) {
+				strcpy(u->deviceName, "Unknown Roland");
+			} else if ( d->descriptor.idVendor == USB_VENDOR_ID_STEINBERG  ) {
+				strcpy(u->deviceName, "Unknown Steinberg");
+			} else if ( d->descriptor.idVendor == USB_VENDOR_ID_YAMAHA ) {
+				strcpy(u->deviceName, "Unknown Yamaha");
+			} else {
+				strcpy(u->deviceName, "Unknown");
+			}
+		}
+	}
+
+	inEndpoint  = 0; inCableId  = -1;
+	outEndpoint = 0; outCableId = -1;
+
+	for ( i=0 ; i<devices ; i++ ) {
+		for ( inCableId ++ ;
+		      inEndpoint <15
+			      && mins[inEndpoint] 
+			      && !(u->in[inEndpoint].cableId & (1<<inCableId)) ;
+		      inCableId++ ) {
+			if ( inCableId >= 16 ) {
+				inEndpoint  ++;
+				inCableId  = 0;
+			}
+		}
+		min  = mins[inEndpoint];
+		for ( outCableId ++ ;
+		      outEndpoint <15
+			      && mouts[outEndpoint] 
+			      && !(u->out[outEndpoint].cableId & (1<<outCableId)) ;
+		      outCableId++ ) {
+			if ( outCableId >= 16 ) {
+				outEndpoint  ++;
+				outCableId  = 0;
+			}
+		}
+		mout = mouts[outEndpoint];
+
+		mdevs[i] = allocMidiDev( s, min, mout, inCableId, outCableId );
+		if ( mdevs[i] == NULL ) { goto error_end; }
+
+	}
+
+	/* Success! */
+	for ( i=0 ; i<devices ; i++ ) {
+		list_add_tail( &mdevs[i]->list, &s->midiDevList );
+	}
+	for ( i=0 ; i<inEndpoints ; i++ ) {
+		list_add_tail( &mins[i]->list, &s->inEndpointList );
+	}
+	for ( i=0 ; i<outEndpoints ; i++ ) {
+		list_add_tail( &mouts[i]->list, &s->outEndpointList );
+	}
+
+	printk(KERN_INFO "usbmidi: found [ %s ] (0x%04x:0x%04x), attached:\n", u->deviceName, u->idVendor, u->idProduct );
+	for ( i=0 ; i<devices ; i++ ) {
+		int dm = (mdevs[i]->dev_midi-2)>>4;
+		if ( mdevs[i]->mout.ep != NULL && mdevs[i]->min.ep != NULL ) {
+			printk(KERN_INFO "usbmidi: /dev/midi%02d: in (ep:%02x cid:%2d bufsiz:%2d) out (ep:%02x cid:%2d bufsiz:%2d)\n", 
+			       dm,
+			       mdevs[i]->min.ep->endpoint|USB_DIR_IN, mdevs[i]->min.cableId, mdevs[i]->min.ep->recvBufSize,
+			       mdevs[i]->mout.ep->endpoint, mdevs[i]->mout.cableId, mdevs[i]->mout.ep->bufSize);
+		} else if ( mdevs[i]->min.ep != NULL ) {
+			printk(KERN_INFO "usbmidi: /dev/midi%02d: in (ep:%02x cid:%2d bufsiz:%02d)\n", 
+			       dm,
+			       mdevs[i]->min.ep->endpoint|USB_DIR_IN, mdevs[i]->min.cableId, mdevs[i]->min.ep->recvBufSize);
+		} else if ( mdevs[i]->mout.ep != NULL ) {
+			printk(KERN_INFO "usbmidi: /dev/midi%02d: out (ep:%02x cid:%2d bufsiz:%02d)\n", 
+			       dm,
+			       mdevs[i]->mout.ep->endpoint, mdevs[i]->mout.cableId, mdevs[i]->mout.ep->bufSize);
+		}
+	}
+
+	kfree(mdevs);
+	return 0;
+
+ error_end:
+	if ( mdevs != NULL && devices > 0 ) {
+		for ( i=0 ; i<devices ; i++ ) {
+			if ( mdevs[i] != NULL ) {
+				unregister_sound_midi( mdevs[i]->dev_midi );
+				kfree(mdevs[i]);
+			}
+		}
+		kfree(mdevs);
+	}
+
+	for ( i=0 ; i<15 ; i++ ) {
+		if ( mins[i] != NULL ) {
+			remove_midi_in_endpoint( mins[i] );
+		}
+		if ( mouts[i] != NULL ) {
+			remove_midi_out_endpoint( mouts[i] );
+		}
+	}
+
+	return -ENOMEM;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/** Attempt to scan YAMAHA's device descriptor and detect correct values of
+ *  them.
+ *  Return 0 on succes, negative on failure.
+ *  Called by usb_midi_probe();
+ **/
+
+static int detect_yamaha_device( struct usb_device *d, unsigned int ifnum, struct usb_midi_state *s)
+{
+	struct usb_config_descriptor    *c = d->actconfig;
+	struct usb_interface_descriptor *interface;
+	struct usb_midi_device *u;
+	unsigned char buf[USB_DT_CONFIG_SIZE], *buffer;
+	int bufSize;
+	int i;
+	int alts=-1;
+	int ret;
+
+	if (d->descriptor.idVendor != USB_VENDOR_ID_YAMAHA) {
+		return -EINVAL;
+	}
+
+	for ( i=0 ; i < c->interface[ifnum].num_altsetting; i++ ) {
+		interface = c->interface[ifnum].altsetting + i;
+
+		if ( interface->bInterfaceClass != 255 ||
+		     interface->bInterfaceSubClass != 0 )
+			continue;
+		alts = i;
+	}
+	if ( alts == -1 ) {
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "usb-midi: Found YAMAHA USB-MIDI device on dev %04x:%04x, iface %d\n",
+	       d->descriptor.idVendor, d->descriptor.idProduct, ifnum);
+
+	for ( i=0 ; i < d->descriptor.bNumConfigurations ; i++ ) {
+		if ( d->config+i == c ) goto configfound;
+	}
+
+	printk(KERN_INFO "usb-midi: Config not found.\n");
+
+	return -EINVAL;
+
+ configfound:
+
+	/* this may not be necessary. */
+	if ( usb_set_configuration( d, c->bConfigurationValue ) < 0 ) {
+		printk(KERN_INFO "usb-midi: Could not set config.\n");
+		return -EINVAL;
+	}
+
+	ret = usb_get_descriptor( d, USB_DT_CONFIG, i, buf, USB_DT_CONFIG_SIZE );
+	if ( ret < 0 ) {
+		printk(KERN_INFO "usb-midi: Could not get config (error=%d).\n", ret);
+		return -EINVAL;
+	}
+	if ( buf[1] != USB_DT_CONFIG || buf[0] < USB_DT_CONFIG_SIZE ) {
+		printk(KERN_INFO "usb-midi: config not as expected.\n");
+		return -EINVAL;
+	}
+	bufSize = buf[2] | buf[3]<<8;
+	buffer = (unsigned char *)kmalloc(sizeof(unsigned char)*bufSize, GFP_KERNEL);
+	if ( !buffer ) {
+		printk(KERN_INFO "usb-midi: Could not allocate memory.\n");
+		return -EINVAL;
+	}
+	ret = usb_get_descriptor( d, USB_DT_CONFIG, i, buffer, bufSize );
+	if ( ret < 0 ) {
+		printk(KERN_INFO "usb-midi: Could not get full config (error=%d).\n", ret);
+		kfree(buffer);
+		return -EINVAL;
+	}
+
+	u = parse_descriptor( d, buffer, bufSize, ifnum, alts, 1);
+	kfree(buffer);
+	if ( u == NULL ) {
+		return -EINVAL;
+	}
+
+	ret = alloc_usb_midi_device( d, s, u );
+
+	kfree(u);
+
+	return ret;
+}
+
+
+/** Scan table of known devices which are only partially compliant with 
+ * the MIDIStreaming specification.
+ * Called by usb_midi_probe();
+ *
+ **/
+
+static int detect_vendor_specific_device( struct usb_device *d, unsigned int ifnum, struct usb_midi_state *s )
+{
+	struct usb_midi_device *u;
+	int i;
+	int ret = -ENXIO;
+
+	for ( i=0; i<VENDOR_SPECIFIC_USB_MIDI_DEVICES ; i++ ) {
+		u=&(usb_midi_devices[i]);
+    
+		if ( d->descriptor.idVendor != u->idVendor ||
+		     d->descriptor.idProduct != u->idProduct ||
+		     ifnum != u->interface )
+			continue;
+
+		ret = alloc_usb_midi_device( d, s, u );
+		break;
+	}
+
+	return ret;
+}
+
+
+/** Attempt to match any config of an interface to a MIDISTREAMING interface.
+ *  Returns 0 on success, negative on failure.
+ * Called by usb_midi_probe();
+ **/
+static int detect_midi_subclass(struct usb_device *d, unsigned int ifnum, struct usb_midi_state *s)
+{
+	struct usb_config_descriptor    *c = d->actconfig;
+	struct usb_interface_descriptor *interface;
+	struct usb_midi_device *u;
+	unsigned char buf[USB_DT_CONFIG_SIZE], *buffer;
+	int bufSize;
+	int i;
+	int alts=-1;
+	int ret;
+
+	for ( i=0 ; i < c->interface[ifnum].num_altsetting; i++ ) {
+		interface = c->interface[ifnum].altsetting + i;
+
+		if ( interface->bInterfaceClass != USB_CLASS_AUDIO ||
+		     interface->bInterfaceSubClass != USB_SUBCLASS_MIDISTREAMING )
+			continue;
+		alts = i;
+	}
+	if ( alts == -1 ) {
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "usb-midi: Found MIDISTREAMING on dev %04x:%04x, iface %d\n",
+	       d->descriptor.idVendor, d->descriptor.idProduct, ifnum);
+
+	for ( i=0 ; i < d->descriptor.bNumConfigurations ; i++ ) {
+		if ( d->config+i == c ) goto configfound;
+	}
+
+	printk(KERN_INFO "usb-midi: Config not found.\n");
+
+	return -EINVAL;
+
+ configfound:
+
+	/* this may not be necessary. */
+	if ( usb_set_configuration( d, c->bConfigurationValue ) < 0 ) {
+		printk(KERN_INFO "usb-midi: Could not set config.\n");
+		return -EINVAL;
+	}
+
+	/* From USB Spec v2.0, Section 9.5.
+	   If the class or vendor specific descriptors use the same format
+	   as standard descriptors (e.g., start with a length byte and
+	   followed by a type byte), they must be returned interleaved with
+	   standard descriptors in the configuration information returned by
+	   a GetDescriptor(Configuration) request. In this case, the class
+	   or vendor-specific descriptors must follow a related standard
+	   descriptor they modify or extend.
+	*/
+
+	ret = usb_get_descriptor( d, USB_DT_CONFIG, i, buf, USB_DT_CONFIG_SIZE );
+	if ( ret < 0 ) {
+		printk(KERN_INFO "usb-midi: Could not get config (error=%d).\n", ret);
+		return -EINVAL;
+	}
+	if ( buf[1] != USB_DT_CONFIG || buf[0] < USB_DT_CONFIG_SIZE ) {
+		printk(KERN_INFO "usb-midi: config not as expected.\n");
+		return -EINVAL;
+	}
+	bufSize = buf[2] | buf[3]<<8;
+	buffer = (unsigned char *)kmalloc(sizeof(unsigned char)*bufSize, GFP_KERNEL);
+	if ( !buffer ) {
+		printk(KERN_INFO "usb-midi: Could not allocate memory.\n");
+		return -EINVAL;
+	}
+	ret = usb_get_descriptor( d, USB_DT_CONFIG, i, buffer, bufSize );
+	if ( ret < 0 ) {
+		printk(KERN_INFO "usb-midi: Could not get full config (error=%d).\n", ret);
+		kfree(buffer);
+		return -EINVAL;
+	}
+
+	u = parse_descriptor( d, buffer, bufSize, ifnum, alts, 0);
+	kfree(buffer);
+	if ( u == NULL ) {
+		return -EINVAL;
+	}
+
+	ret = alloc_usb_midi_device( d, s, u );
+
+	kfree(u);
+
+	return ret;
+}
+
+
+/** When user has requested a specific device, match it exactly.
+ *
+ * Uses uvendor, uproduct, uinterface, ualt, umin, umout and ucable.
+ * Called by usb_midi_probe();
+ *
+ **/
+static int detect_by_hand(struct usb_device *d, unsigned int ifnum, struct usb_midi_state *s)
+{
+	struct usb_midi_device u;
+
+	if ( d->descriptor.idVendor != uvendor ||
+	     d->descriptor.idProduct != uproduct ||
+	     ifnum != uinterface ) {
+		return -EINVAL;
+	}
+
+	if ( ualt < 0 ) { ualt = -1; }
+
+	if ( umin   < 0 || umin   > 15 ) { umin   = 0x01 | USB_DIR_IN; }
+	if ( umout  < 0 || umout  > 15 ) { umout  = 0x01; }
+	if ( ucable < 0 || ucable > 15 ) { ucable = 0; }
+
+	u.deviceName = 0; /* A flag for alloc_usb_midi_device to get device name
+			     from device. */
+	u.idVendor   = uvendor;
+	u.idProduct  = uproduct;
+	u.interface  = uinterface;
+	u.altSetting = ualt;
+
+	u.in[0].endpoint    = umin;
+	u.in[0].cableId     = (1<<ucable);
+
+	u.out[0].endpoint   = umout;
+	u.out[0].cableId    = (1<<ucable);
+
+	return alloc_usb_midi_device( d, s, &u );
+}
+
+
+
+/* ------------------------------------------------------------------------- */
+
+static void *usb_midi_probe(struct usb_device *dev, unsigned int ifnum,
+			    const struct usb_device_id *id)
+{
+	struct usb_midi_state *s;
+
+	s = (struct usb_midi_state *)kmalloc(sizeof(struct usb_midi_state), GFP_KERNEL);
+	if ( !s ) { return NULL; }
+
+	memset( s, 0, sizeof(struct usb_midi_state) );
+	INIT_LIST_HEAD(&s->midiDevList);
+	INIT_LIST_HEAD(&s->inEndpointList);
+	INIT_LIST_HEAD(&s->outEndpointList);
+	s->usbdev = dev;
+	s->count  = 0;
+	spin_lock_init(&s->lock);
+
+	if (
+		detect_by_hand( dev, ifnum, s ) &&
+		detect_midi_subclass( dev, ifnum, s ) &&
+		detect_vendor_specific_device( dev, ifnum, s ) &&
+		detect_yamaha_device( dev, ifnum, s) ) {
+		kfree(s);
+		return NULL;
+	}
+
+	down(&open_sem);
+	list_add_tail(&s->mididev, &mididevs);
+	up(&open_sem);
+
+#ifdef MOD_INC_EACH_PROBE
+	MOD_INC_USE_COUNT;
+#endif
+
+	return s;
+}
+
+
+static void usb_midi_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct usb_midi_state *s = (struct usb_midi_state *)ptr;
+	struct list_head      *list;
+	struct usb_mididev    *m;
+
+	if ( s == (struct usb_midi_state *)-1 ) {
+		return;
+	}
+	if ( !s->usbdev ) {
+		return;
+	}
+	down(&open_sem);
+	list_del(&s->mididev);
+	INIT_LIST_HEAD(&s->mididev);
+	s->usbdev = NULL;
+
+	for ( list = s->midiDevList.next; list != &s->midiDevList; list = list->next ) {
+		m = list_entry(list, struct usb_mididev, list);
+		wake_up(&(m->min.ep->wait));
+		wake_up(&(m->mout.ep->wait));
+		if ( m->dev_midi >= 0 ) {
+			unregister_sound_midi(m->dev_midi);
+		}
+		m->dev_midi = -1;
+	}
+	release_midi_device(s);
+	wake_up(&open_wait);
+#ifdef MOD_INC_EACH_PROBE
+	MOD_DEC_USE_COUNT;
+#endif
+
+	return;
+}
+
+
+
+static struct usb_driver usb_midi_driver = {
+	name: "midi",
+	probe: usb_midi_probe,
+	disconnect: usb_midi_disconnect,
+	id_table:	NULL, 			/* check all devices */
+	driver_list: LIST_HEAD_INIT(usb_midi_driver.driver_list)
+};
+
+/* ------------------------------------------------------------------------- */
+
+int __init usb_midi_init(void)
+{
+	if ( usb_register(&usb_midi_driver) < 0 )
+		return -1;
+
+	return 0;
+
+}
+
+void __exit usb_midi_exit(void)
+{
+	usb_deregister(&usb_midi_driver);
+}
+
+module_init(usb_midi_init) ;
+module_exit(usb_midi_exit) ;
+
+#ifdef HAVE_ALSA_SUPPORT
+#define SNDRV_MAIN_OBJECT_FILE
+#include "../../include/driver.h"
+#include "../../include/control.h"
+#include "../../include/info.h"
+#include "../../include/cs46xx.h"
+
+/* ------------------------------------------------------------------------- */
+
+static int snd_usbmidi_input_close(snd_rawmidi_substream_t * substream)
+{
+	return 0;
+}
+
+static int snd_usbmidi_input_open(snd_rawmidi_substream_t * substream )
+{
+	return 0;
+}
+
+static void snd_usbmidi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	return 0;
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+static int snd_usbmidi_output_close(snd_rawmidi_substream_t * substream)
+{
+	return 0;
+}
+
+static int snd_usbmidi_output_open(snd_rawmidi_substream_t * substream)
+{
+	return 0;
+}
+
+static void snd_usb_midi_output_trigger(snd_rawmidi_substream_t * substream,
+					int up)
+{
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static snd_rawmidi_ops_t snd_usbmidi_output =
+{
+        open:           snd_usbmidi_output_open,
+        close:          snd_usbmidi_output_close,
+        trigger:        snd_usbmidi_output_trigger,
+};
+static snd_rawmidi_ops_t snd_usbmidi_input =
+{
+        open:           snd_usbmidi_input_open,
+        close:          snd_usbmidi_input_close,
+        trigger:        snd_usbmidi_input_trigger,
+};
+
+int snd_usbmidi_midi(cs46xx_t *chip, int device, snd_rawmidi_t **rrawmidi)
+{
+	snd_rawmidi_t *rmidi;
+	int err;
+
+	if (rrawmidi)
+		*rrawmidi = NULL;
+	if ((err = snd_rawmidi_new(chip->card, "USB-MIDI", device, 1, 1, &rmidi)) < 0)
+		return err;
+	strcpy(rmidi->name, "USB-MIDI");
+
+	snd_rawmidi_set_ops( rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_usbmidi_output );
+	snd_rawmidi_set_ops( rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_usbmidi_input );
+
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;
+
+	rmidi->private_data = chip;
+	chip->rmidi = rmidi;
+	if (rrawmidi)
+		*rrawmidi = NULL;
+
+	return 0;
+}
+
+int snd_usbmidi_create( snd_card_t * card,
+			struct pci_dev * pci,
+			usbmidi_t ** rchip )
+{
+	usbmidi_t *chip;
+	int err, idx;
+	snd_region_t *region;
+	static snd_device_opt_t ops = {
+		dev_free: snd_usbmidi_dev_free,
+	};
+
+	*rchip = NULL;
+	chip = snd_magic_kcalloc( usbmidi_t, 0, GFP_KERNEL );
+	if ( chip == NULL )
+		return -ENOMEM;
+}
+
+EXPORT_SYMBOL(snd_usbmidi_create);
+EXPORT_SYMBOL(snd_usbmidi_midi);
+#endif /* HAVE_ALSA_SUPPORT */
+
diff -Nur linux-2.4.19.old/drivers/usb/usb-midi.h linux-2.4.19/drivers/usb/usb-midi.h
--- linux-2.4.19.old/drivers/usb/usb-midi.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/usb-midi.h	Mon Nov 25 12:27:12 2002
@@ -0,0 +1,143 @@
+/*
+  usb-midi.h  --  USB-MIDI driver
+
+  Copyright (C) 2001
+      NAGANO Daisuke <breeze.nagano@nifty.ne.jp>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2, or (at your option)
+  any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* ------------------------------------------------------------------------- */
+
+#ifndef _USB_MIDI_H_
+#define _USB_MIDI_H_
+
+#ifndef USB_SUBCLASS_MIDISTREAMING
+#define USB_SUBCLASS_MIDISTREAMING	3
+#endif
+
+#define USB_DT_CS_DEVICE		0x21
+#define USB_DT_CS_CONFIG		0x22
+#define USB_DT_CS_STRING		0x23
+#define USB_DT_CS_INTERFACE		0x24
+#define USB_DT_CS_ENDPOINT		0x25
+
+/* ------------------------------------------------------------------------- */
+/* Roland MIDI Devices */
+
+#define USB_VENDOR_ID_ROLAND		0x0582
+#define USBMIDI_ROLAND_UA100G		0x0000
+#define USBMIDI_ROLAND_MPU64		0x0002
+#define USBMIDI_ROLAND_SC8850		0x0003
+#define USBMIDI_ROLAND_UM2		0x0005
+#define USBMIDI_ROLAND_UM1		0x0009
+#define USBMIDI_ROLAND_PC300		0x0008
+
+/* YAMAHA MIDI Devices */
+#define USB_VENDOR_ID_YAMAHA		0x0499
+#define USBMIDI_YAMAHA_MU1000		0x1001
+
+/* Steinberg MIDI Devices */
+#define USB_VENDOR_ID_STEINBERG		0x0763
+#define USBMIDI_STEINBERG_USB2MIDI	0x1001
+
+/* ------------------------------------------------------------------------- */
+/* Supported devices */
+
+struct usb_midi_endpoint {
+	int  endpoint;
+	int  cableId; /* if bit-n == 1 then cableId-n is enabled (n: 0 - 15) */
+};
+
+struct usb_midi_device {
+	char  *deviceName;
+
+	int    idVendor;
+	int    idProduct;
+	int    interface;
+	int    altSetting; /* -1: auto detect */
+
+	struct usb_midi_endpoint in[15];
+	struct usb_midi_endpoint out[15];
+};
+
+static struct usb_midi_device usb_midi_devices[] = {
+  { /* Roland UM-1 */
+    "Roland UM-1",
+    USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_UM1, 2, -1,
+    { { 0x81, 1 }, {-1, -1} },
+    { { 0x01, 1,}, {-1, -1} },
+  },
+
+  { /* Roland UM-2 */
+    "Roland UM-2" ,
+    USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_UM2, 2, -1,
+    { { 0x81, 3 }, {-1, -1} },
+    { { 0x01, 3,}, {-1, -1} },
+  },
+
+/** Next entry courtesy research by Michael Minn <michael@michaelminn.com> **/
+  { /* Roland UA-100 */
+    "Roland UA-100",
+    USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_UA100G, 2, -1,
+    { { 0x82, 7 }, {-1, -1} }, /** cables 0,1 and 2 for SYSEX **/
+    { { 0x02, 7 }, {-1, -1} },
+  },
+
+/** Next entry courtesy research by Michael Minn <michael@michaelminn.com> **/
+  { /* Roland SC8850 */
+    "Roland SC8850",
+    USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_SC8850, 2, -1,
+    { { 0x81, 15 }, {-1, -1} }, /** cables 0,1,2, and 3 **/
+    { { 0x01, 15 }, {-1, -1} },
+  },
+
+  { /* YAMAHA MU1000 */
+    "YAMAHA MU1000",
+    USB_VENDOR_ID_YAMAHA, USBMIDI_YAMAHA_MU1000, 0, -1, 
+    { { 0x81, 1 }, {-1, -1} },
+    { { 0x01, 15 }, {-1, -1} },
+  },
+  { /* Roland PC-300 */
+    "Roland PC-300",
+    USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_PC300, 2, -1, 
+    { { 0x81, 1 }, {-1, -1} },
+    { { 0x01, 1 }, {-1, -1} },
+  }
+};
+
+#define VENDOR_SPECIFIC_USB_MIDI_DEVICES (sizeof(usb_midi_devices)/sizeof(struct usb_midi_device))
+
+/* for Hot-Plugging */
+
+static struct usb_device_id usb_midi_ids [] = {
+	{ match_flags: (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),
+	  bInterfaceClass: USB_CLASS_AUDIO, bInterfaceSubClass: USB_SUBCLASS_MIDISTREAMING},
+	{ USB_DEVICE( USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_UM1    ) },
+	{ USB_DEVICE( USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_UM2    ) },
+	{ USB_DEVICE( USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_UA100G ) },
+	{ USB_DEVICE( USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_PC300 ) },
+	{ USB_DEVICE( USB_VENDOR_ID_ROLAND, USBMIDI_ROLAND_SC8850 ) },
+	{ USB_DEVICE( USB_VENDOR_ID_YAMAHA, USBMIDI_YAMAHA_MU1000 ) },
+/*	{ USB_DEVICE( USB_VENDOR_ID_STEINBERG, USBMIDI_STEINBERG_USB2MIDI ) },*/
+	{ } /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, usb_midi_ids);
+
+/* ------------------------------------------------------------------------- */
+#endif /* _USB_MIDI_H_ */
+
+
diff -Nur linux-2.4.19.old/drivers/usb/usb-ohci.c linux-2.4.19/drivers/usb/usb-ohci.c
--- linux-2.4.19.old/drivers/usb/usb-ohci.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/usb-ohci.c	Mon Nov 25 12:27:12 2002
@@ -78,6 +78,7 @@
 
 #include "usb-ohci.h"
 
+#include "hcd.h"
 
 #ifdef CONFIG_PMAC_PBOOK
 #include <asm/machdep.h>
@@ -178,7 +179,7 @@
 	kfree (urb_priv);
 }
  
-static void urb_rm_priv_locked (urb_t * urb) 
+static void urb_rm_priv_locked (struct urb * urb) 
 {
 	urb_priv_t * urb_priv = urb->hcpriv;
 	
@@ -212,7 +213,7 @@
 	}
 }
 
-static void urb_rm_priv (urb_t * urb)
+static void urb_rm_priv (struct urb * urb)
 {
 	unsigned long flags;
 
@@ -229,7 +230,7 @@
 /* debug| print the main components of an URB     
  * small: 0) header + data packets 1) just header */
  
-static void urb_print (urb_t * urb, char * str, int small)
+static void urb_print (struct urb * urb, char * str, int small)
 {
 	unsigned int pipe= urb->pipe;
 	
@@ -384,6 +385,8 @@
 	__u32			temp, ndp, i;
 
 	temp = roothub_a (controller);
+	if (temp == ~(u32)0)
+		return;
 	ndp = (temp & RH_A_NDP);
 
 	if (verbose) {
@@ -458,10 +461,10 @@
 
 /* return a request to the completion handler */
  
-static int sohci_return_urb (struct ohci *hc, urb_t * urb)
+static int sohci_return_urb (struct ohci *hc, struct urb * urb)
 {
 	urb_priv_t * urb_priv = urb->hcpriv;
-	urb_t * urbt;
+	struct urb * urbt;
 	unsigned long flags;
 	int i;
 	
@@ -536,7 +539,7 @@
 
 /* get a transfer request */
  
-static int sohci_submit_urb (urb_t * urb)
+static int sohci_submit_urb (struct urb * urb)
 {
 	ohci_t * ohci;
 	ed_t * ed;
@@ -720,7 +723,7 @@
 /* deactivate all TDs and remove the private part of the URB */
 /* interrupt callers must use async unlink mode */
 
-static int sohci_unlink_urb (urb_t * urb)
+static int sohci_unlink_urb (struct urb * urb)
 {
 	unsigned long flags;
 	ohci_t * ohci;
@@ -1295,7 +1298,7 @@
 static void
 td_fill (ohci_t * ohci, unsigned int info,
 	dma_addr_t data, int len,
-	urb_t * urb, int index)
+	struct urb * urb, int index)
 {
 	volatile td_t  * td, * td_pt;
 	urb_priv_t * urb_priv = urb->hcpriv;
@@ -1344,7 +1347,7 @@
  
 /* prepare all TDs of a transfer */
 
-static void td_submit_urb (urb_t * urb)
+static void td_submit_urb (struct urb * urb)
 { 
 	urb_priv_t * urb_priv = urb->hcpriv;
 	ohci_t * ohci = (ohci_t *) urb->dev->bus->hcpriv;
@@ -1457,7 +1460,7 @@
 {
 	__u32 tdINFO, tdBE, tdCBP;
  	__u16 tdPSW;
- 	urb_t * urb = td->urb;
+ 	struct urb * urb = td->urb;
  	urb_priv_t * urb_priv = urb->hcpriv;
 	int dlen = 0;
 	int cc = 0;
@@ -1498,7 +1501,7 @@
 
 /* handle an urb that is being unlinked */
 
-static void dl_del_urb (urb_t * urb)
+static void dl_del_urb (struct urb * urb)
 {
 	wait_queue_head_t * wait_head = ((urb_priv_t *)(urb->hcpriv))->wait;
 
@@ -1510,6 +1513,8 @@
 			urb->complete (urb);
 	} else {
 		urb->status = -ENOENT;
+		if (urb->complete)
+			urb->complete (urb);
 
 		/* unblock sohci_unlink_urb */
 		if (wait_head)
@@ -1587,7 +1592,7 @@
 		td_p = &ed->hwHeadP;
 
 		for (td = tdHeadP; td != tdTailP; td = td_next) { 
-			urb_t * urb = td->urb;
+			struct urb * urb = td->urb;
 			urb_priv_t * urb_priv = td->urb->hcpriv;
 			
 			td_next = dma_to_td (ohci, le32_to_cpup (&td->hwNextTD) & 0xfffffff0);
@@ -1626,11 +1631,6 @@
 			if (tdHeadP == tdTailP) {
 				if (ed->state == ED_OPER)
 					ep_unlink(ohci, ed);
-				td_free (ohci, tdTailP);
-				ed->hwINFO = cpu_to_le32 (OHCI_ED_SKIP);
-				ed->state = ED_NEW;
-				hash_free_ed(ohci, ed);
-				--(usb_to_ohci (ohci->dev[edINFO & 0x7F]))->ed_cnt;
 			} else
    	 			ed->hwINFO &= ~cpu_to_le32 (OHCI_ED_SKIP);
    	 	}
@@ -1675,7 +1675,7 @@
   	td_t * td_list_next = NULL;
 	ed_t * ed;
 	int cc = 0;
-	urb_t * urb;
+	struct urb * urb;
 	urb_priv_t * urb_priv;
  	__u32 tdINFO, edHeadP, edTailP;
  	
@@ -1851,7 +1851,7 @@
 {
 	int len; 
 
-	urb_t * urb = (urb_t *) ptr;
+	struct urb * urb = (struct urb *) ptr;
 	ohci_t * ohci = urb->dev->bus->hcpriv;
 
 	if (ohci->disabled)
@@ -1880,7 +1880,7 @@
 
 /* Root Hub INTs are polled by this timer */
 
-static int rh_init_int_timer (urb_t * urb) 
+static int rh_init_int_timer (struct urb * urb) 
 {
 	ohci_t * ohci = urb->dev->bus->hcpriv;
 
@@ -1905,12 +1905,12 @@
 
 /* request to virtual root hub */
 
-static int rh_submit_urb (urb_t * urb)
+static int rh_submit_urb (struct urb * urb)
 {
 	struct usb_device * usb_dev = urb->dev;
 	ohci_t * ohci = usb_dev->bus->hcpriv;
 	unsigned int pipe = urb->pipe;
-	devrequest * cmd = (devrequest *) urb->setup_packet;
+	struct usb_ctrlrequest * cmd = (struct usb_ctrlrequest *) urb->setup_packet;
 	void * data = urb->transfer_buffer;
 	int leni = urb->transfer_buffer_length;
 	int len = 0;
@@ -1934,10 +1934,10 @@
 		return 0;
 	}
 
-	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
-	wValue        = le16_to_cpu (cmd->value);
-	wIndex        = le16_to_cpu (cmd->index);
-	wLength       = le16_to_cpu (cmd->length);
+	bmRType_bReq  = cmd->bRequestType | (cmd->bRequest << 8);
+	wValue        = le16_to_cpu (cmd->wValue);
+	wIndex        = le16_to_cpu (cmd->wIndex);
+	wLength       = le16_to_cpu (cmd->wLength);
 
 	switch (bmRType_bReq) {
 	/* Request Destination:
@@ -2111,7 +2111,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-static int rh_unlink_urb (urb_t * urb)
+static int rh_unlink_urb (struct urb * urb)
 {
 	ohci_t * ohci = urb->dev->bus->hcpriv;
  
@@ -2144,6 +2144,8 @@
 	int timeout = 30;
 	int smm_timeout = 50; /* 0,5 sec */
 	 	
+#ifndef __hppa__
+	/* PA-RISC doesn't have SMM, but PDC might leave IR set */
 	if (readl (&ohci->regs->control) & OHCI_CTRL_IR) { /* SMM owns the HC */
 		writel (OHCI_OCR, &ohci->regs->cmdstatus); /* request ownership */
 		dbg("USB HC TakeOver from SMM");
@@ -2154,7 +2156,8 @@
 				return -1;
 			}
 		}
-	}	
+	}
+#endif	
 		
 	/* Disable HC interrupts */
 	writel (OHCI_INTR_MIE, &ohci->regs->intrdisable);
@@ -2218,9 +2221,19 @@
 	writel (mask, &ohci->regs->intrstatus);
 
 #ifdef	OHCI_USE_NPS
-	/* required for AMD-756 and some Mac platforms */
-	writel ((roothub_a (ohci) | RH_A_NPS) & ~RH_A_PSM,
-		&ohci->regs->roothub.a);
+	if(ohci->flags & OHCI_QUIRK_SUCKYIO)
+	{
+		/* NSC 87560 at least requires different setup .. */
+		writel ((roothub_a (ohci) | RH_A_NOCP) &
+			~(RH_A_OCPM | RH_A_POTPGT | RH_A_PSM | RH_A_NPS),
+			&ohci->regs->roothub.a);
+	}
+	else
+	{
+		/* required for AMD-756 and some Mac platforms */
+		writel ((roothub_a (ohci) | RH_A_NPS) & ~RH_A_PSM,
+			&ohci->regs->roothub.a);
+	}
 	writel (RH_HS_LPSC, &ohci->regs->roothub.status);
 #endif	/* OHCI_USE_NPS */
 
@@ -2288,9 +2301,19 @@
 	struct ohci_regs * regs = ohci->regs;
  	int ints; 
 
-	if ((ohci->hcca->done_head != 0) && !(le32_to_cpup (&ohci->hcca->done_head) & 0x01)) {
+	/* avoid (slow) readl if only WDH happened */
+	if ((ohci->hcca->done_head != 0)
+			&& !(le32_to_cpup (&ohci->hcca->done_head) & 0x01)) {
 		ints =  OHCI_INTR_WDH;
-	} else if ((ints = (readl (&regs->intrstatus) & readl (&regs->intrenable))) == 0) {
+
+	/* cardbus/... hardware gone before remove() */
+	} else if ((ints = readl (&regs->intrstatus)) == ~(u32)0) {
+		ohci->disabled++;
+		err ("%s device removed!", ohci->ohci_dev->slot_name);
+		return;
+
+	/* interrupt for some other device? */
+	} else if ((ints &= readl (&regs->intrenable)) == 0) {
 		return;
 	} 
 
@@ -2391,6 +2414,7 @@
 		kfree (ohci);
 		return NULL;
 	}
+	ohci->bus->bus_name = dev->slot_name;
 	ohci->bus->hcpriv = (void *) ohci;
 
 	return ohci;
@@ -2418,8 +2442,9 @@
 	}
 	pci_set_drvdata(ohci->ohci_dev, NULL);
 	if (ohci->bus) {
-		if (ohci->bus->busnum)
+		if (ohci->bus->busnum != -1)
 			usb_deregister_bus (ohci->bus);
+
 		usb_free_bus (ohci->bus);
 	}
 
@@ -2448,7 +2473,6 @@
 	void *mem_base, const struct pci_device_id *id)
 {
 	ohci_t * ohci;
-	u8 latency, limit;
 	char buf[8], *bufp = buf;
 	int ret;
 
@@ -2470,23 +2494,24 @@
 		return ret;
 	}
 	ohci->flags = id->driver_data;
+	
+	/* Check for NSC87560. We have to look at the bridge (fn1) to identify
+	   the USB (fn2). This quirk might apply to more or even all NSC stuff
+	   I don't know.. */
+	   
+	if(dev->vendor == PCI_VENDOR_ID_NS)
+	{
+		struct pci_dev *fn1  = pci_find_slot(dev->bus->number, PCI_DEVFN(PCI_SLOT(dev->devfn), 1));
+		if(fn1 && fn1->vendor == PCI_VENDOR_ID_NS && fn1->device == PCI_DEVICE_ID_NS_87560_LIO)
+			ohci->flags |= OHCI_QUIRK_SUCKYIO;
+		
+	}
+	
+	if (ohci->flags & OHCI_QUIRK_SUCKYIO)
+		printk (KERN_INFO __FILE__ ": Using NSC SuperIO setup\n");
 	if (ohci->flags & OHCI_QUIRK_AMD756)
 		printk (KERN_INFO __FILE__ ": AMD756 erratum 4 workaround\n");
 
-	/* bad pci latencies can contribute to overruns */ 
-	pci_read_config_byte (dev, PCI_LATENCY_TIMER, &latency);
-	if (latency) {
-		pci_read_config_byte (dev, PCI_MAX_LAT, &limit);
-		if (limit && limit < latency) {
-			dbg ("PCI latency reduced to max %d", limit);
-			pci_write_config_byte (dev, PCI_LATENCY_TIMER, limit);
-			ohci->pci_latency = limit;
-		} else {
-			/* it might already have been reduced */
-			ohci->pci_latency = latency;
-		}
-	}
-
 	if (hc_reset (ohci) < 0) {
 		hc_release_ohci (ohci);
 		return -ENODEV;
diff -Nur linux-2.4.19.old/drivers/usb/usb-ohci.h linux-2.4.19/drivers/usb/usb-ohci.h
--- linux-2.4.19.old/drivers/usb/usb-ohci.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/usb-ohci.h	Mon Nov 25 12:27:12 2002
@@ -111,7 +111,7 @@
   	__u8 index;
   	struct ed * ed;
   	struct td * next_dl_td;
-  	urb_t * urb;
+  	struct urb * urb;
 
 	dma_addr_t td_dma;
 	dma_addr_t data_dma;
@@ -381,6 +381,7 @@
 	atomic_t resume_count;		/* defending against multiple resumes */
 	unsigned long flags;		/* for HC bugs */
 #define	OHCI_QUIRK_AMD756	0x01		/* erratum #4 */
+#define OHCI_QUIRK_SUCKYIO	0x02		/* NSC superio */
 
 	struct ohci_regs * regs;	/* OHCI controller's memory */
 	struct list_head ohci_hcd_list;	/* list of all ohci_hcd */
@@ -430,12 +431,12 @@
 static ed_t * ep_add_ed(struct usb_device * usb_dev, unsigned int pipe, int interval, int load, int mem_flags);
 static void ep_rm_ed(struct usb_device * usb_dev, ed_t * ed);
 /* td */
-static void td_fill(ohci_t * ohci, unsigned int info, dma_addr_t data, int len, urb_t * urb, int index);
-static void td_submit_urb(urb_t * urb);
+static void td_fill(ohci_t * ohci, unsigned int info, dma_addr_t data, int len, struct urb * urb, int index);
+static void td_submit_urb(struct urb * urb);
 /* root hub */
-static int rh_submit_urb(urb_t * urb);
-static int rh_unlink_urb(urb_t * urb);
-static int rh_init_int_timer(urb_t * urb);
+static int rh_submit_urb(struct urb * urb);
+static int rh_unlink_urb(struct urb * urb);
+static int rh_init_int_timer(struct urb * urb);
 
 /*-------------------------------------------------------------------------*/
 
diff -Nur linux-2.4.19.old/drivers/usb/usb-uhci.c linux-2.4.19/drivers/usb/usb-uhci.c
--- linux-2.4.19.old/drivers/usb/usb-uhci.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/usb-uhci.c	Mon Nov 25 12:27:12 2002
@@ -59,6 +59,8 @@
 #include "usb-uhci.h"
 #include "usb-uhci-debug.h"
 
+#include "hcd.h"
+
 /*
  * Version Information
  */
@@ -117,12 +119,12 @@
 // Suppress HC interrupt error messages for 5s
 #define ERROR_SUPPRESSION_TIME (HZ*5)
 
-_static int rh_submit_urb (urb_t *urb);
-_static int rh_unlink_urb (urb_t *urb);
+_static int rh_submit_urb (struct urb *urb);
+_static int rh_unlink_urb (struct urb *urb);
 _static int delete_qh (uhci_t *s, uhci_desc_t *qh);
-_static int process_transfer (uhci_t *s, urb_t *urb, int mode);
-_static int process_interrupt (uhci_t *s, urb_t *urb);
-_static int process_iso (uhci_t *s, urb_t *urb, int force);
+_static int process_transfer (uhci_t *s, struct urb *urb, int mode);
+_static int process_interrupt (uhci_t *s, struct urb *urb);
+_static int process_iso (uhci_t *s, struct urb *urb, int force);
 
 // How much URBs with ->next are walked
 #define MAX_NEXT_COUNT 2048
@@ -168,7 +170,7 @@
 }
 /*-------------------------------------------------------------------*/
 #ifdef CONFIG_USB_UHCI_HIGH_BANDWIDTH
-_static void enable_desc_loop(uhci_t *s, urb_t *urb)
+_static void enable_desc_loop(uhci_t *s, struct urb *urb)
 {
 	unsigned long flags;
 
@@ -183,7 +185,7 @@
 	spin_unlock_irqrestore (&s->qh_lock, flags);
 }
 /*-------------------------------------------------------------------*/
-_static void disable_desc_loop(uhci_t *s, urb_t *urb)
+_static void disable_desc_loop(uhci_t *s, struct urb *urb)
 {
 	unsigned long flags;
 
@@ -204,7 +206,7 @@
 }
 #endif
 /*-------------------------------------------------------------------*/
-_static void queue_urb_unlocked (uhci_t *s, urb_t *urb)
+_static void queue_urb_unlocked (uhci_t *s, struct urb *urb)
 {
 	struct list_head *p=&urb->urb_list;
 #ifdef CONFIG_USB_UHCI_HIGH_BANDWIDTH
@@ -224,7 +226,7 @@
 	uhci_switch_timer_int(s);
 }
 /*-------------------------------------------------------------------*/
-_static void queue_urb (uhci_t *s, urb_t *urb)
+_static void queue_urb (uhci_t *s, struct urb *urb)
 {
 	unsigned long flags=0;
 
@@ -233,7 +235,7 @@
 	spin_unlock_irqrestore (&s->urb_list_lock, flags);
 }
 /*-------------------------------------------------------------------*/
-_static void dequeue_urb (uhci_t *s, urb_t *urb)
+_static void dequeue_urb (uhci_t *s, struct urb *urb)
 {
 #ifdef CONFIG_USB_UHCI_HIGH_BANDWIDTH
 	int type;
@@ -698,7 +700,7 @@
 //                         LOW LEVEL STUFF
 //          assembles QHs und TDs for control, bulk and iso
 /*-------------------------------------------------------------------*/
-_static int uhci_submit_control_urb (urb_t *urb)
+_static int uhci_submit_control_urb (struct urb *urb)
 {
 	uhci_desc_t *qh, *td;
 	uhci_t *s = (uhci_t*) urb->dev->bus->hcpriv;
@@ -815,7 +817,7 @@
 // For queued bulk transfers, two additional QH helpers are allocated (nqh, bqh)
 // Due to the linking with other bulk urbs, it has to be locked with urb_list_lock!
 
-_static int uhci_submit_bulk_urb (urb_t *urb, urb_t *bulk_urb)
+_static int uhci_submit_bulk_urb (struct urb *urb, struct urb *bulk_urb)
 {
 	uhci_t *s = (uhci_t*) urb->dev->bus->hcpriv;
 	urb_priv_t *urb_priv = urb->hcpriv, *upriv, *bpriv=NULL;
@@ -977,7 +979,7 @@
  looks a bit complicated because of all the bulk queueing goodies
 */
 
-_static void uhci_clean_transfer (uhci_t *s, urb_t *urb, uhci_desc_t *qh, int mode)
+_static void uhci_clean_transfer (uhci_t *s, struct urb *urb, uhci_desc_t *qh, int mode)
 {
 	uhci_desc_t *bqh, *nqh, *prevqh, *prevtd;
 	int now;
@@ -1031,7 +1033,7 @@
 		       urb, priv->prev_queued_urb,  priv->next_queued_urb, qh, bqh, priv->next_qh);	
        	
 		if (mode != CLEAN_TRANSFER_DELETION_MARK) {	// no work for cleanup at unlink-completion
-			urb_t *nurb;
+			struct urb *nurb;
 			unsigned long flags;
 
 			nurb = priv->next_queued_urb;
@@ -1069,7 +1071,7 @@
 }
 /*-------------------------------------------------------------------*/
 // Release bandwidth for Interrupt or Isoc. transfers 
-_static void uhci_release_bandwidth(urb_t *urb)
+_static void uhci_release_bandwidth(struct urb *urb)
 {       
 	if (urb->bandwidth) {
 		switch (usb_pipetype(urb->pipe)) {
@@ -1085,11 +1087,11 @@
 	}	
 }
 
-_static void uhci_urb_dma_sync(uhci_t *s, urb_t *urb, urb_priv_t *urb_priv)
+_static void uhci_urb_dma_sync(uhci_t *s, struct urb *urb, urb_priv_t *urb_priv)
 {
 	if (urb_priv->setup_packet_dma)
 		pci_dma_sync_single(s->uhci_pci, urb_priv->setup_packet_dma,
-				    sizeof(devrequest), PCI_DMA_TODEVICE);
+				    sizeof(struct usb_ctrlrequest), PCI_DMA_TODEVICE);
 
 	if (urb_priv->transfer_buffer_dma)
 		pci_dma_sync_single(s->uhci_pci, urb_priv->transfer_buffer_dma,
@@ -1099,11 +1101,11 @@
 				    PCI_DMA_TODEVICE);
 }
 
-_static void uhci_urb_dma_unmap(uhci_t *s, urb_t *urb, urb_priv_t *urb_priv)
+_static void uhci_urb_dma_unmap(uhci_t *s, struct urb *urb, urb_priv_t *urb_priv)
 {
 	if (urb_priv->setup_packet_dma) {
 		pci_unmap_single(s->uhci_pci, urb_priv->setup_packet_dma,
-				 sizeof(devrequest), PCI_DMA_TODEVICE);
+				 sizeof(struct usb_ctrlrequest), PCI_DMA_TODEVICE);
 		urb_priv->setup_packet_dma = 0;
 	}
 	if (urb_priv->transfer_buffer_dma) {
@@ -1120,7 +1122,7 @@
    mode: UNLINK_ASYNC_STORE_URB: unlink and move URB into unlinked list
          UNLINK_ASYNC_DONT_STORE: unlink, don't move URB into unlinked list
 */
-_static int uhci_unlink_urb_async (uhci_t *s,urb_t *urb, int mode)
+_static int uhci_unlink_urb_async (uhci_t *s,struct urb *urb, int mode)
 {
 	uhci_desc_t *qh;
 	urb_priv_t *urb_priv;
@@ -1165,7 +1167,7 @@
 }
 /*-------------------------------------------------------------------*/
 // kills an urb by unlinking descriptors and waiting for at least one frame
-_static int uhci_unlink_urb_sync (uhci_t *s, urb_t *urb)
+_static int uhci_unlink_urb_sync (uhci_t *s, struct urb *urb)
 {
 	uhci_desc_t *qh;
 	urb_priv_t *urb_priv;
@@ -1176,7 +1178,7 @@
 
 	if (urb->status == -EINPROGRESS) {
 
-		// move descriptors out the the running chains, dequeue urb
+		// move descriptors out of the running chains, dequeue urb
 		uhci_unlink_urb_async(s, urb, UNLINK_ASYNC_DONT_STORE);
 
 		urb_priv = urb->hcpriv;
@@ -1229,7 +1231,7 @@
 _static void uhci_cleanup_unlink(uhci_t *s, int force)
 {
 	struct list_head *q;
-	urb_t *urb;
+	struct urb *urb;
 	struct usb_device *dev;
 	int now, type;
 	urb_priv_t *urb_priv;
@@ -1239,7 +1241,7 @@
 
 	while (q != &s->urb_unlinked) {
 
-		urb = list_entry (q, urb_t, urb_list);
+		urb = list_entry (q, struct urb, urb_list);
 
 		urb_priv = (urb_priv_t*)urb->hcpriv;
 		q = urb->urb_list.next;
@@ -1308,7 +1310,7 @@
 }
  
 /*-------------------------------------------------------------------*/
-_static int uhci_unlink_urb (urb_t *urb)
+_static int uhci_unlink_urb (struct urb *urb)
 {
 	uhci_t *s;
 	unsigned long flags=0;
@@ -1341,9 +1343,9 @@
 // In case of ASAP iso transfer, search the URB-list for already queued URBs
 // for this EP and calculate the earliest start frame for the new
 // URB (easy seamless URB continuation!)
-_static int find_iso_limits (urb_t *urb, unsigned int *start, unsigned int *end)
+_static int find_iso_limits (struct urb *urb, unsigned int *start, unsigned int *end)
 {
-	urb_t *u, *last_urb = NULL;
+	struct urb *u, *last_urb = NULL;
 	uhci_t *s = (uhci_t*) urb->dev->bus->hcpriv;
 	struct list_head *p;
 	int ret=-1;
@@ -1353,7 +1355,7 @@
 	p=s->urb_list.prev;
 
 	for (; p != &s->urb_list; p = p->prev) {
-		u = list_entry (p, urb_t, urb_list);
+		u = list_entry (p, struct urb, urb_list);
 		// look for pending URBs with identical pipe handle
 		// works only because iso doesn't toggle the data bit!
 		if ((urb->pipe == u->pipe) && (urb->dev == u->dev) && (u->status == -EINPROGRESS)) {
@@ -1375,7 +1377,7 @@
 /*-------------------------------------------------------------------*/
 // adjust start_frame according to scheduling constraints (ASAP etc)
 
-_static int iso_find_start (urb_t *urb)
+_static int iso_find_start (struct urb *urb)
 {
 	uhci_t *s = (uhci_t*) urb->dev->bus->hcpriv;
 	unsigned int now;
@@ -1433,7 +1435,7 @@
 // ASAP-flag set implicitely
 // if period==0, the transfer is only done once
 
-_static int uhci_submit_int_urb (urb_t *urb)
+_static int uhci_submit_int_urb (struct urb *urb)
 {
 	uhci_t *s = (uhci_t*) urb->dev->bus->hcpriv;
 	urb_priv_t *urb_priv = urb->hcpriv;
@@ -1493,7 +1495,7 @@
 	return 0;
 }
 /*-------------------------------------------------------------------*/
-_static int uhci_submit_iso_urb (urb_t *urb)
+_static int uhci_submit_iso_urb (struct urb *urb)
 {
 	uhci_t *s = (uhci_t*) urb->dev->bus->hcpriv;
 	urb_priv_t *urb_priv = urb->hcpriv;
@@ -1586,10 +1588,10 @@
 /*-------------------------------------------------------------------*/
 // returns: 0 (no transfer queued), urb* (this urb already queued)
  
-_static urb_t* search_dev_ep (uhci_t *s, urb_t *urb)
+_static struct urb* search_dev_ep (uhci_t *s, struct urb *urb)
 {
 	struct list_head *p;
-	urb_t *tmp;
+	struct urb *tmp;
 	unsigned int mask = usb_pipecontrol(urb->pipe) ? (~USB_DIR_IN) : (~0);
 
 	dbg("search_dev_ep:");
@@ -1597,7 +1599,7 @@
 	p=s->urb_list.next;
 
 	for (; p != &s->urb_list; p = p->next) {
-		tmp = list_entry (p, urb_t, urb_list);
+		tmp = list_entry (p, struct urb, urb_list);
 		dbg("urb: %p", tmp);
 		// we can accept this urb if it is not queued at this time 
 		// or if non-iso transfer requests should be scheduled for the same device and pipe
@@ -1610,13 +1612,13 @@
 	return 0;
 }
 /*-------------------------------------------------------------------*/
-_static int uhci_submit_urb (urb_t *urb)
+_static int uhci_submit_urb (struct urb *urb)
 {
 	uhci_t *s;
 	urb_priv_t *urb_priv;
 	int ret = 0, type;
 	unsigned long flags;
-	urb_t *queued_urb=NULL;
+	struct urb *queued_urb=NULL;
 	int bustime;
 		
 	if (!urb->dev || !urb->dev->bus)
@@ -1683,7 +1685,7 @@
 	
 	if (type == PIPE_CONTROL)
 		urb_priv->setup_packet_dma = pci_map_single(s->uhci_pci, urb->setup_packet,
-							    sizeof(devrequest), PCI_DMA_TODEVICE);
+							    sizeof(struct usb_ctrlrequest), PCI_DMA_TODEVICE);
 
 	if (urb->transfer_buffer_length)
 		urb_priv->transfer_buffer_dma = pci_map_single(s->uhci_pci,
@@ -1770,7 +1772,7 @@
 _static void uhci_check_timeouts(uhci_t *s)
 {
 	struct list_head *p,*p2;
-	urb_t *urb;
+	struct urb *urb;
 	int type;	
 
 	p = s->urb_list.prev;	
@@ -1780,7 +1782,7 @@
 
 		p2 = p;
 		p = p->prev;
-		urb = list_entry (p2, urb_t, urb_list);
+		urb = list_entry (p2, struct urb, urb_list);
 		type = usb_pipetype (urb->pipe);
 
 		hcpriv = (urb_priv_t*)urb->hcpriv;
@@ -1878,7 +1880,7 @@
 
 /*-------------------------------------------------------------------------*/
 /* prepare Interrupt pipe transaction data; HUB INTERRUPT ENDPOINT */
-_static int rh_send_irq (urb_t *urb)
+_static int rh_send_irq (struct urb *urb)
 {
 	int len = 1;
 	int i;
@@ -1905,12 +1907,12 @@
 
 /*-------------------------------------------------------------------------*/
 /* Virtual Root Hub INTs are polled by this timer every "intervall" ms */
-_static int rh_init_int_timer (urb_t *urb);
+_static int rh_init_int_timer (struct urb *urb);
 
 _static void rh_int_timer_do (unsigned long ptr)
 {
 	int len;
-	urb_t *urb = (urb_t*) ptr;
+	struct urb *urb = (struct urb*) ptr;
 	uhci_t *uhci = urb->dev->bus->hcpriv;
 
 	if (uhci->rh.send) {
@@ -1927,7 +1929,7 @@
 /*-------------------------------------------------------------------------*/
 /* Root Hub INTs are polled by this timer, polling interval 20ms */
 
-_static int rh_init_int_timer (urb_t *urb)
+_static int rh_init_int_timer (struct urb *urb)
 {
 	uhci_t *uhci = urb->dev->bus->hcpriv;
 
@@ -1961,12 +1963,12 @@
  *************************/
 
 
-_static int rh_submit_urb (urb_t *urb)
+_static int rh_submit_urb (struct urb *urb)
 {
 	struct usb_device *usb_dev = urb->dev;
 	uhci_t *uhci = usb_dev->bus->hcpriv;
 	unsigned int pipe = urb->pipe;
-	devrequest *cmd = (devrequest *) urb->setup_packet;
+	struct usb_ctrlrequest *cmd = (struct usb_ctrlrequest *) urb->setup_packet;
 	void *data = urb->transfer_buffer;
 	int leni = urb->transfer_buffer_length;
 	int len = 0;
@@ -1992,10 +1994,10 @@
 	}
 
 
-	bmRType_bReq = cmd->requesttype | cmd->request << 8;
-	wValue = le16_to_cpu (cmd->value);
-	wIndex = le16_to_cpu (cmd->index);
-	wLength = le16_to_cpu (cmd->length);
+	bmRType_bReq = cmd->bRequestType | cmd->bRequest << 8;
+	wValue = le16_to_cpu (cmd->wValue);
+	wIndex = le16_to_cpu (cmd->wIndex);
+	wLength = le16_to_cpu (cmd->wLength);
 
 	for (i = 0; i < 8; i++)
 		uhci->rh.c_p_r[i] = 0;
@@ -2162,7 +2164,7 @@
 }
 /*-------------------------------------------------------------------------*/
 
-_static int rh_unlink_urb (urb_t *urb)
+_static int rh_unlink_urb (struct urb *urb)
 {
 	uhci_t *uhci = urb->dev->bus->hcpriv;
 
@@ -2220,14 +2222,14 @@
 	unsigned long flags;
 	struct list_head *p;
 	struct list_head *p2;
-	urb_t *urb;
+	struct urb *urb;
 
 	spin_lock_irqsave (&s->urb_list_lock, flags);
 	p = s->urb_list.prev;	
 	while (p != &s->urb_list) {
 		p2 = p;
 		p = p->prev ;
-		urb = list_entry (p2, urb_t, urb_list);
+		urb = list_entry (p2, struct urb, urb_list);
 		dbg("urb: %p, dev %p, %p", urb, usb_dev,urb->dev);
 		
 		//urb->transfer_flags |=USB_ASYNC_UNLINK; 
@@ -2277,7 +2279,7 @@
 	uhci_unlink_urb
 };
 
-_static void correct_data_toggles(urb_t *urb)
+_static void correct_data_toggles(struct urb *urb)
 {
 	usb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe), usb_pipeout (urb->pipe), 
 		       !usb_gettoggle (urb->dev, usb_pipeendpoint (urb->pipe), usb_pipeout (urb->pipe)));
@@ -2307,7 +2309,7 @@
  *       PROCESS_TRANSFER_DONT_UNLINK: QHs already unlinked (for async unlink_urb)
  */
 
-_static int process_transfer (uhci_t *s, urb_t *urb, int mode)
+_static int process_transfer (uhci_t *s, struct urb *urb, int mode)
 {
 	int ret = 0;
 	urb_priv_t *urb_priv = urb->hcpriv;
@@ -2395,7 +2397,7 @@
 	if (usb_pipetype (urb->pipe) == PIPE_BULK ) {  /* toggle correction for short bulk transfers (nonqueued/queued) */
 
 		urb_priv_t *priv=(urb_priv_t*)urb->hcpriv;
-		urb_t *next_queued_urb=priv->next_queued_urb;
+		struct urb *next_queued_urb=priv->next_queued_urb;
 
 		if (next_queued_urb) {
 			urb_priv_t *next_priv=(urb_priv_t*)next_queued_urb->hcpriv;
@@ -2426,7 +2428,7 @@
 	return ret;
 }
 
-_static int process_interrupt (uhci_t *s, urb_t *urb)
+_static int process_interrupt (uhci_t *s, struct urb *urb)
 {
 	int i, ret = -EINPROGRESS;
 	urb_priv_t *urb_priv = urb->hcpriv;
@@ -2525,7 +2527,7 @@
 // mode: PROCESS_ISO_REGULAR: processing only for done TDs, unlink TDs
 // mode: PROCESS_ISO_FORCE: force processing, don't unlink TDs (already unlinked)
 
-_static int process_iso (uhci_t *s, urb_t *urb, int mode)
+_static int process_iso (uhci_t *s, struct urb *urb, int mode)
 {
 	int i;
 	int ret = 0;
@@ -2594,9 +2596,9 @@
 _static int process_urb (uhci_t *s, struct list_head *p)
 {
 	int ret = 0;
-	urb_t *urb;
+	struct urb *urb;
 
-	urb=list_entry (p, urb_t, urb_list);
+	urb=list_entry (p, struct urb, urb_list);
 	//dbg("process_urb: found queued urb: %p", urb);
 
 	switch (usb_pipetype (urb->pipe)) {
@@ -2645,7 +2647,7 @@
 #endif
 
 		if ((usb_pipetype (urb->pipe) != PIPE_INTERRUPT)) {  // process_interrupt does completion on its own		
-			urb_t *next_urb = urb->next;
+			struct urb *next_urb = urb->next;
 			int is_ring = 0;
 			int contains_killed = 0;
 			int loop_count=0;
@@ -2952,6 +2954,7 @@
 	}
 
 	s->bus = bus;
+	bus->bus_name = dev->slot_name;
 	bus->hcpriv = s;
 
 	/* UHCI specs says devices must have 2 ports, but goes on to say */
diff -Nur linux-2.4.19.old/drivers/usb/usb-uhci.h linux-2.4.19/drivers/usb/usb-uhci.h
--- linux-2.4.19.old/drivers/usb/usb-uhci.h	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/usb-uhci.h	Mon Nov 25 12:27:12 2002
@@ -158,8 +158,8 @@
 	dma_addr_t setup_packet_dma;
 	dma_addr_t transfer_buffer_dma;
 	unsigned long started;
-	urb_t *next_queued_urb;         // next queued urb for this EP
-	urb_t *prev_queued_urb;
+	struct urb *next_queued_urb;	// next queued urb for this EP
+	struct urb *prev_queued_urb;
 	uhci_desc_t *bottom_qh;
 	uhci_desc_t *next_qh;       	// next helper QH
 	char use_loop;
diff -Nur linux-2.4.19.old/drivers/usb/usb.c linux-2.4.19/drivers/usb/usb.c
--- linux-2.4.19.old/drivers/usb/usb.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/usb.c	Mon Nov 25 12:27:12 2002
@@ -38,6 +38,8 @@
 #endif
 #include <linux/usb.h>
 
+#include "hcd.h"
+
 static const int usb_bandwidth_option =
 #ifdef CONFIG_USB_BANDWIDTH
 				1;
@@ -218,42 +220,51 @@
 }
 
 /*
- * usb_calc_bus_time:
- *
- * returns (approximate) USB bus time in nanoseconds for a USB transaction.
+ * usb_calc_bus_time - approximate periodic transaction time in nanoseconds
+ * @speed: from dev->speed; USB_SPEED_{LOW,FULL,HIGH}
+ * @is_input: true iff the transaction sends data to the host
+ * @isoc: true for isochronous transactions, false for interrupt ones
+ * @bytecount: how many bytes in the transaction.
+ *
+ * Returns approximate bus time in nanoseconds for a periodic transaction.
+ * See USB 2.0 spec section 5.11.3; only periodic transfers need to be
+ * scheduled in software, this function is only used for such scheduling.
  */
-static long usb_calc_bus_time (int low_speed, int input_dir, int isoc, int bytecount)
+long usb_calc_bus_time (int speed, int is_input, int isoc, int bytecount)
 {
 	unsigned long	tmp;
 
-	if (low_speed)		/* no isoc. here */
-	{
-		if (input_dir)
-		{
+	switch (speed) {
+	case USB_SPEED_LOW: 	/* INTR only */
+		if (is_input) {
 			tmp = (67667L * (31L + 10L * BitTime (bytecount))) / 1000L;
 			return (64060L + (2 * BW_HUB_LS_SETUP) + BW_HOST_DELAY + tmp);
-		}
-		else
-		{
+		} else {
 			tmp = (66700L * (31L + 10L * BitTime (bytecount))) / 1000L;
 			return (64107L + (2 * BW_HUB_LS_SETUP) + BW_HOST_DELAY + tmp);
 		}
+	case USB_SPEED_FULL:	/* ISOC or INTR */
+		if (isoc) {
+			tmp = (8354L * (31L + 10L * BitTime (bytecount))) / 1000L;
+			return (((is_input) ? 7268L : 6265L) + BW_HOST_DELAY + tmp);
+		} else {
+			tmp = (8354L * (31L + 10L * BitTime (bytecount))) / 1000L;
+			return (9107L + BW_HOST_DELAY + tmp);
+		}
+	case USB_SPEED_HIGH:	/* ISOC or INTR */
+		// FIXME adjust for input vs output
+		if (isoc)
+			tmp = HS_USECS (bytecount);
+		else
+			tmp = HS_USECS_ISO (bytecount);
+		return tmp;
+	default:
+		dbg ("bogus device speed!");
+		return -1;
 	}
-
-	/* for full-speed: */
-
-	if (!isoc)		/* Input or Output */
-	{
-		tmp = (8354L * (31L + 10L * BitTime (bytecount))) / 1000L;
-		return (9107L + BW_HOST_DELAY + tmp);
-	} /* end not Isoc */
-
-	/* for isoc: */
-
-	tmp = (8354L * (31L + 10L * BitTime (bytecount))) / 1000L;
-	return (((input_dir) ? 7268L : 6265L) + BW_HOST_DELAY + tmp);
 }
 
+
 /*
  * usb_check_bandwidth():
  *
@@ -285,7 +296,7 @@
 	unsigned int	pipe = urb->pipe;
 	long		bustime;
 
-	bustime = usb_calc_bus_time (usb_pipeslow(pipe), usb_pipein(pipe),
+	bustime = usb_calc_bus_time (dev->speed, usb_pipein(pipe),
 			usb_pipeisoc(pipe), usb_maxpacket(dev, pipe, usb_pipeout(pipe)));
 	if (usb_pipeisoc(pipe))
 		bustime = NS_TO_US(bustime) / urb->number_of_packets;
@@ -457,12 +468,11 @@
 	 */
 	down (&usb_bus_list_lock);
 	list_del(&bus->bus_list);
+	clear_bit(bus->busnum, busmap.busmap);
 	up (&usb_bus_list_lock);
 
 	usbdevfs_remove_bus(bus);
 
-	clear_bit(bus->busnum, busmap.busmap);
-
 	usb_bus_put(bus);
 }
 
@@ -939,6 +949,9 @@
 
 	usb_bus_get(bus);
 
+	if (!parent)
+		dev->devpath [0] = '0';
+
 	dev->bus = bus;
 	dev->parent = parent;
 	atomic_set(&dev->refcnt, 1);
@@ -985,11 +998,11 @@
  *
  *	The driver should call usb_free_urb() when it is finished with the urb.
  */
-urb_t *usb_alloc_urb(int iso_packets)
+struct urb *usb_alloc_urb(int iso_packets)
 {
-	urb_t *urb;
+	struct urb *urb;
 
-	urb = (urb_t *)kmalloc(sizeof(urb_t) + iso_packets * sizeof(iso_packet_descriptor_t),
+	urb = (struct urb *)kmalloc(sizeof(struct urb) + iso_packets * sizeof(struct iso_packet_descriptor),
 	      in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
 	if (!urb) {
 		err("alloc_urb: kmalloc failed");
@@ -1011,13 +1024,13 @@
  *	cleaned up with a call to usb_free_urb() when the driver is finished
  *	with it.
  */
-void usb_free_urb(urb_t* urb)
+void usb_free_urb(struct urb* urb)
 {
 	if (urb)
 		kfree(urb);
 }
 /*-------------------------------------------------------------------*/
-int usb_submit_urb(urb_t *urb)
+int usb_submit_urb(struct urb *urb)
 {
 	if (urb && urb->dev && urb->dev->bus && urb->dev->bus->op)
 		return urb->dev->bus->op->submit_urb(urb);
@@ -1026,7 +1039,7 @@
 }
 
 /*-------------------------------------------------------------------*/
-int usb_unlink_urb(urb_t *urb)
+int usb_unlink_urb(struct urb *urb)
 {
 	if (urb && urb->dev && urb->dev->bus && urb->dev->bus->op)
 		return urb->dev->bus->op->unlink_urb(urb);
@@ -1040,7 +1053,7 @@
 /*-------------------------------------------------------------------*
  * completion handler for compatibility wrappers (sync control/bulk) *
  *-------------------------------------------------------------------*/
-static void usb_api_blocking_completion(urb_t *urb)
+static void usb_api_blocking_completion(struct urb *urb)
 {
 	struct usb_api_data *awd = (struct usb_api_data *)urb->context;
 
@@ -1054,7 +1067,7 @@
  *-------------------------------------------------------------------*/
 
 // Starts urb and waits for completion or timeout
-static int usb_start_wait_urb(urb_t *urb, int timeout, int* actual_length)
+static int usb_start_wait_urb(struct urb *urb, int timeout, int* actual_length)
 { 
 	DECLARE_WAITQUEUE(wait, current);
 	struct usb_api_data awd;
@@ -1110,9 +1123,9 @@
 /*-------------------------------------------------------------------*/
 // returns status (negative) or length (positive)
 int usb_internal_control_msg(struct usb_device *usb_dev, unsigned int pipe, 
-			    devrequest *cmd,  void *data, int len, int timeout)
+			    struct usb_ctrlrequest *cmd,  void *data, int len, int timeout)
 {
-	urb_t *urb;
+	struct urb *urb;
 	int retv;
 	int length;
 
@@ -1145,7 +1158,8 @@
  *	This function sends a simple control message to a specified endpoint
  *	and waits for the message to complete, or timeout.
  *	
- *	If successful, it returns 0, othwise a negative error number.
+ *	If successful, it returns the number of bytes transferred; 
+ *	otherwise, it returns a negative error number.
  *
  *	Don't use this function from within an interrupt context, like a
  *	bottom half handler.  If you need a asyncronous message, or need to send
@@ -1154,17 +1168,17 @@
 int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype,
 			 __u16 value, __u16 index, void *data, __u16 size, int timeout)
 {
-	devrequest *dr = kmalloc(sizeof(devrequest), GFP_KERNEL);
+	struct usb_ctrlrequest *dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);
 	int ret;
 	
 	if (!dr)
 		return -ENOMEM;
 
-	dr->requesttype = requesttype;
-	dr->request = request;
-	dr->value = cpu_to_le16p(&value);
-	dr->index = cpu_to_le16p(&index);
-	dr->length = cpu_to_le16p(&size);
+	dr->bRequestType = requesttype;
+	dr->bRequest = request;
+	dr->wValue = cpu_to_le16p(&value);
+	dr->wIndex = cpu_to_le16p(&index);
+	dr->wLength = cpu_to_le16p(&size);
 
 	//dbg("usb_control_msg");	
 
@@ -1188,9 +1202,9 @@
  *	This function sends a simple bulk message to a specified endpoint
  *	and waits for the message to complete, or timeout.
  *	
- *	If successful, it returns 0, othwise a negative error number.
- *	The number of actual bytes transferred will be plaed in the 
- *	actual_timeout paramater.
+ *	If successful, it returns 0, otherwise a negative error number.
+ *	The number of actual bytes transferred will be stored in the 
+ *	actual_length paramater.
  *
  *	Don't use this function from within an interrupt context, like a
  *	bottom half handler.  If you need a asyncronous message, or need to
@@ -1199,7 +1213,7 @@
 int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe, 
 			void *data, int len, int *actual_length, int timeout)
 {
-	urb_t *urb;
+	struct urb *urb;
 
 	if (len < 0)
 		return -EINVAL;
@@ -1698,7 +1712,8 @@
 
 	*pdev = NULL;
 
-	info("USB disconnect on device %d", dev->devnum);
+	info("USB disconnect on device %s-%s address %d",
+			dev->bus->bus_name, dev->devpath, dev->devnum);
 
 	if (dev->actconfig) {
 		for (i = 0; i < dev->actconfig->bNumInterfaces; i++) {
@@ -2392,6 +2407,7 @@
 EXPORT_SYMBOL(usb_connect);
 EXPORT_SYMBOL(usb_disconnect);
 
+EXPORT_SYMBOL(usb_calc_bus_time);
 EXPORT_SYMBOL(usb_check_bandwidth);
 EXPORT_SYMBOL(usb_claim_bandwidth);
 EXPORT_SYMBOL(usb_release_bandwidth);
diff -Nur linux-2.4.19.old/drivers/usb/usbkbd.c linux-2.4.19/drivers/usb/usbkbd.c
--- linux-2.4.19.old/drivers/usb/usbkbd.c	Fri Sep 14 23:04:07 2001
+++ linux-2.4.19/drivers/usb/usbkbd.c	Mon Nov 25 12:27:12 2002
@@ -71,7 +71,7 @@
 	unsigned char new[8];
 	unsigned char old[8];
 	struct urb irq, led;
-	devrequest dr;
+	struct usb_ctrlrequest dr;
 	unsigned char leds, newleds;
 	char name[128];
 	int open;
@@ -215,11 +215,11 @@
 	FILL_INT_URB(&kbd->irq, dev, pipe, kbd->new, maxp > 8 ? 8 : maxp,
 		usb_kbd_irq, kbd, endpoint->bInterval);
 
-	kbd->dr.requesttype = USB_TYPE_CLASS | USB_RECIP_INTERFACE;
-	kbd->dr.request = USB_REQ_SET_REPORT;
-	kbd->dr.value = 0x200;
-	kbd->dr.index = interface->bInterfaceNumber;
-	kbd->dr.length = 1;
+	kbd->dr.bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE;
+	kbd->dr.bRequest = USB_REQ_SET_REPORT;
+	kbd->dr.wValue = 0x200;
+	kbd->dr.wIndex = interface->bInterfaceNumber;
+	kbd->dr.wLength = 1;
 
 	kbd->dev.name = kbd->name;
 	kbd->dev.idbus = BUS_USB;
diff -Nur linux-2.4.19.old/drivers/usb/usblcd.c linux-2.4.19/drivers/usb/usblcd.c
--- linux-2.4.19.old/drivers/usb/usblcd.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.19/drivers/usb/usblcd.c	Mon Nov 25 12:27:12 2002
@@ -0,0 +1,347 @@
+/***************************************************************************** 
+ *                          USBLCD Kernel Driver                             *
+ *        See http://www.usblcd.de for Hardware and Documentation.           *
+ *                            Version 1.03                                   *
+ *             (C) 2002 Adams IT Services <info@usblcd.de>                   *
+ *                                                                           *
+ *     This file is licensed under the GPL. See COPYING in the package.      *
+ * Based on rio500.c by Cesar Miquel (miquel@df.uba.ar) which is based on    *
+ * hp_scanner.c by David E. Nelson (dnelson@jump.net)                        *
+ *                                                                           *
+ * 23.7.02 RA changed minor device number to the official assigned one       *
+ * 18.9.02 RA Vendor ID change, longer timeouts                              *
+ *****************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+
+#define DRIVER_VERSION "USBLCD Driver Version 1.03"
+
+#define USBLCD_MINOR		144
+
+#define IOCTL_GET_HARD_VERSION	1
+#define IOCTL_GET_DRV_VERSION	2
+
+/* stall/wait timeout for USBLCD */
+#define NAK_TIMEOUT	(10*HZ)
+
+#define IBUF_SIZE	0x1000
+#define OBUF_SIZE	0x10000
+
+struct lcd_usb_data {
+	struct usb_device *lcd_dev;	/* init: probe_lcd */
+	unsigned int ifnum;		/* Interface number of the USB device */
+	int isopen;			/* nz if open */
+	int present;			/* Device is present on the bus */
+	char *obuf, *ibuf;		/* transfer buffers */
+	char bulk_in_ep, bulk_out_ep;	/* Endpoint assignments */
+	wait_queue_head_t wait_q;	/* for timeouts */
+};
+
+static struct lcd_usb_data lcd_instance;
+
+static int open_lcd(struct inode *inode, struct file *file)
+{
+	struct lcd_usb_data *lcd = &lcd_instance;
+
+	if (lcd->isopen || !lcd->present) {
+		return -EBUSY;
+	}
+	lcd->isopen = 1;
+
+	init_waitqueue_head(&lcd->wait_q);
+
+	info("USBLCD opened.");
+
+	return 0;
+}
+
+static int close_lcd(struct inode *inode, struct file *file)
+{
+	struct lcd_usb_data *lcd = &lcd_instance;
+
+	lcd->isopen = 0;
+
+	info("USBLCD closed.");
+	return 0;
+}
+
+static int
+ioctl_lcd(struct inode *inode, struct file *file, unsigned int cmd,
+	  unsigned long arg)
+{
+	struct lcd_usb_data *lcd = &lcd_instance;
+	int i;
+	char buf[30];
+
+	/* Sanity check to make sure lcd is connected, powered, etc */
+	if (lcd == NULL ||
+	    lcd->present == 0 ||
+	    lcd->lcd_dev == NULL)
+		return -1;
+
+	switch (cmd) {
+	case IOCTL_GET_HARD_VERSION:
+		i = (lcd->lcd_dev)->descriptor.bcdDevice;
+		sprintf(buf,"%1d%1d.%1d%1d",(i & 0xF000)>>12,(i & 0xF00)>>8,
+			(i & 0xF0)>>4,(i & 0xF));
+		if (copy_to_user((void *)arg,buf,strlen(buf))!=0)
+			return -EFAULT;
+		break;
+	case IOCTL_GET_DRV_VERSION:
+		sprintf(buf,DRIVER_VERSION);
+		if (copy_to_user((void *)arg,buf,strlen(buf))!=0)
+			return -EFAULT;
+		break;
+	default:
+		return -ENOIOCTLCMD;
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t
+write_lcd(struct file *file, const char *buffer,
+	  size_t count, loff_t * ppos)
+{
+	struct lcd_usb_data *lcd = &lcd_instance;
+
+	unsigned long copy_size;
+	unsigned long bytes_written = 0;
+	unsigned int partial;
+
+	int result = 0;
+	int maxretry;
+
+	/* Sanity check to make sure lcd is connected, powered, etc */
+	if (lcd == NULL ||
+	    lcd->present == 0 ||
+	    lcd->lcd_dev == NULL)
+		return -1;
+
+	do {
+		unsigned long thistime;
+		char *obuf = lcd->obuf;
+
+		thistime = copy_size =
+		    (count >= OBUF_SIZE) ? OBUF_SIZE : count;
+		if (copy_from_user(lcd->obuf, buffer, copy_size))
+			return -EFAULT;
+		maxretry = 5;
+		while (thistime) {
+			if (!lcd->lcd_dev)
+				return -ENODEV;
+			if (signal_pending(current)) {
+				return bytes_written ? bytes_written : -EINTR;
+			}
+
+			result = usb_bulk_msg(lcd->lcd_dev,
+					 usb_sndbulkpipe(lcd->lcd_dev, 1),
+					 obuf, thistime, &partial, 10 * HZ);
+
+			dbg("write stats: result:%d thistime:%lu partial:%u",
+			     result, thistime, partial);
+
+			if (result == USB_ST_TIMEOUT) {	/* NAK - so hold for a while */
+				if (!maxretry--) {
+					return -ETIME;
+				}
+				interruptible_sleep_on_timeout(&lcd-> wait_q, NAK_TIMEOUT);
+				continue;
+			} else if (!result & partial) {
+				obuf += partial;
+				thistime -= partial;
+			} else
+				break;
+		};
+		if (result) {
+			err("Write Whoops - %x", result);
+			return -EIO;
+		}
+		bytes_written += copy_size;
+		count -= copy_size;
+		buffer += copy_size;
+	} while (count > 0);
+
+	return bytes_written ? bytes_written : -EIO;
+}
+
+static ssize_t
+read_lcd(struct file *file, char *buffer, size_t count, loff_t * ppos)
+{
+	struct lcd_usb_data *lcd = &lcd_instance;
+	ssize_t read_count;
+	unsigned int partial;
+	int this_read;
+	int result;
+	int maxretry = 10;
+	char *ibuf = lcd->ibuf;
+
+	/* Sanity check to make sure lcd is connected, powered, etc */
+	if (lcd == NULL ||
+	    lcd->present == 0 ||
+	    lcd->lcd_dev == NULL)
+		return -1;
+
+	read_count = 0;
+
+	while (count > 0) {
+		if (signal_pending(current)) {
+			return read_count ? read_count : -EINTR;
+		}
+		if (!lcd->lcd_dev)
+			return -ENODEV;
+		this_read = (count >= IBUF_SIZE) ? IBUF_SIZE : count;
+
+		result = usb_bulk_msg(lcd->lcd_dev,
+				      usb_rcvbulkpipe(lcd->lcd_dev, 0),
+				      ibuf, this_read, &partial,
+				      (int) (HZ * 8));
+
+		dbg(KERN_DEBUG "read stats: result:%d this_read:%u partial:%u",
+		       result, this_read, partial);
+
+		if (partial) {
+			count = this_read = partial;
+		} else if (result == USB_ST_TIMEOUT || result == 15) {	/* FIXME: 15 ??? */
+			if (!maxretry--) {
+				err("read_lcd: maxretry timeout");
+				return -ETIME;
+			}
+			interruptible_sleep_on_timeout(&lcd->wait_q,
+						       NAK_TIMEOUT);
+			continue;
+		} else if (result != USB_ST_DATAUNDERRUN) {
+			err("Read Whoops - result:%u partial:%u this_read:%u",
+			     result, partial, this_read);
+			return -EIO;
+		} else {
+			return (0);
+		}
+
+		if (this_read) {
+			if (copy_to_user(buffer, ibuf, this_read))
+				return -EFAULT;
+			count -= this_read;
+			read_count += this_read;
+			buffer += this_read;
+		}
+	}
+	return read_count;
+}
+
+static void *probe_lcd(struct usb_device *dev, unsigned int ifnum)
+{
+	struct lcd_usb_data *lcd = &lcd_instance;
+	int i;
+	
+	if (dev->descriptor.idProduct != 0x0001  ) {
+		warn(KERN_INFO "USBLCD model not supported.");
+		return NULL;
+	}
+
+	if (lcd->present == 1) {
+		warn(KERN_INFO "Multiple USBLCDs are not supported!");
+		return NULL;
+	}
+
+	i = dev->descriptor.bcdDevice;
+
+	info("USBLCD Version %1d%1d.%1d%1d found at address %d",
+		(i & 0xF000)>>12,(i & 0xF00)>>8,(i & 0xF0)>>4,(i & 0xF),
+		dev->devnum);
+
+	lcd->present = 1;
+	lcd->lcd_dev = dev;
+
+	if (!(lcd->obuf = (char *) kmalloc(OBUF_SIZE, GFP_KERNEL))) {
+		err("probe_lcd: Not enough memory for the output buffer");
+		return NULL;
+	}
+	dbg("probe_lcd: obuf address:%p", lcd->obuf);
+
+	if (!(lcd->ibuf = (char *) kmalloc(IBUF_SIZE, GFP_KERNEL))) {
+		err("probe_lcd: Not enough memory for the input buffer");
+		kfree(lcd->obuf);
+		return NULL;
+	}
+	dbg("probe_lcd: ibuf address:%p", lcd->ibuf);
+
+	return lcd;
+}
+
+static void disconnect_lcd(struct usb_device *dev, void *ptr)
+{
+	struct lcd_usb_data *lcd = (struct lcd_usb_data *) ptr;
+
+	if (lcd->isopen) {
+		lcd->isopen = 0;
+		/* better let it finish - the release will do whats needed */
+		lcd->lcd_dev = NULL;
+		return;
+	}
+	kfree(lcd->ibuf);
+	kfree(lcd->obuf);
+
+	info("USBLCD disconnected.");
+
+	lcd->present = 0;
+}
+
+static struct usb_device_id id_table [] = {
+	{ .idVendor = 0x10D2, .match_flags = USB_DEVICE_ID_MATCH_VENDOR, },
+	{},
+};
+
+MODULE_DEVICE_TABLE (usb, id_table);
+
+static struct
+file_operations usb_lcd_fops = {
+	.owner =	THIS_MODULE,
+	.read =		read_lcd,
+	.write =	write_lcd,
+	.ioctl =	ioctl_lcd,
+	.open =		open_lcd,
+	.release =	close_lcd,
+};
+
+static struct
+usb_driver lcd_driver = {
+	.name =		"usblcd",
+	.probe =	(void *)probe_lcd,
+	.disconnect =	disconnect_lcd,
+	.id_table =	id_table,
+	.fops =		&usb_lcd_fops,
+	.minor =	USBLCD_MINOR,
+};
+
+int usb_lcd_init(void)
+{
+	if (usb_register(&lcd_driver) < 0)
+		return -1;
+
+	info("%s (C) Adams IT Services http://www.usblcd.de", DRIVER_VERSION);
+	info("USBLCD support registered.");
+	return 0;
+}
+
+
+void usb_lcd_cleanup(void)
+{
+	struct lcd_usb_data *lcd = &lcd_instance;
+
+	lcd->present = 0;
+	usb_deregister(&lcd_driver);
+}
+
+module_init(usb_lcd_init);
+module_exit(usb_lcd_cleanup);
+
+MODULE_AUTHOR("Adams IT Services <info@usblcd.de>");
+MODULE_DESCRIPTION(DRIVER_VERSION);
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.19.old/drivers/usb/usbnet.c linux-2.4.19/drivers/usb/usbnet.c
--- linux-2.4.19.old/drivers/usb/usbnet.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/usbnet.c	Mon Nov 25 12:27:12 2002
@@ -1,6 +1,6 @@
 /*
  * USB Host-to-Host Links
- * Copyright (C) 2000-2001 by David Brownell <dbrownell@users.sourceforge.net>
+ * Copyright (C) 2000-2002 by David Brownell <dbrownell@users.sourceforge.net>
  */
 
 /*
@@ -16,6 +16,7 @@
  *
  *	- AnchorChip 2720
  *	- Belkin, eTEK (interops with Win32 drivers)
+ *	- EPSON USB clients
  *	- GeneSys GL620USB-A
  *	- "Linux Devices" (like iPaq and similar SA-1100 based PDAs)
  *	- NetChip 1080 (interoperates with NetChip Win32 drivers)
@@ -23,33 +24,41 @@
  *
  * USB devices can implement their side of this protocol at the cost
  * of two bulk endpoints; it's not restricted to "cable" applications.
- * See the LINUXDEV support.
+ * See the LINUXDEV or EPSON device/client support.
  *
  * 
- * TODO:
+ * Status:
  *
- * This needs to be retested for bulk queuing problems ... earlier versions
- * seemed to find different types of problems in each HCD.  Once they're fixed,
- * re-enable queues to get higher bandwidth utilization (without needing
- * to tweak MTU for larger packets).
- *
- * Add support for more "network cable" chips; interop with their Win32
- * drivers may be a good thing.  Test the AnchorChip 2720 support..
- * Figure out the initialization protocol used by the Prolific chips,
- * for better robustness ... there's some powerup/reset handshake that's
- * needed when only one end reboots.
- *
- * Use interrupt on PL230x to detect peer connect/disconnect, and call
- * netif_carrier_{on,off} (?) appropriately.  For Net1080, detect peer
- * connect/disconnect with async control messages.
- *
- * Find some way to report "peer connected" network hotplug events; it'll
- * likely mean updating the networking layer.  (This has been discussed
- * on the netdev list...)
+ * - AN2720 ... not widely available, but reportedly works well
  *
- * Craft smarter hotplug policy scripts ... ones that know how to arrange
+ * - Belkin/eTEK ... no known issues
+ *
+ * - Both GeneSys and PL-230x use interrupt transfers for driver-to-driver
+ *   handshaking; it'd be worth implementing those as "carrier detect".
+ *   Prefer generic hooks, not minidriver-specific hacks.
+ *
+ * - Linux devices ... the www.handhelds.org SA-1100 support works nicely,
+ *   but the Sharp Zaurus uses an incompatible protocol (extra checksums).
+ *   No reason not to merge the Zaurus protocol here too (got patch? :)
+ *
+ * - For Netchip, should use keventd to poll via control requests to detect
+ *   hardware level "carrier detect". 
+ *
+ * - PL-230x ... the initialization protocol doesn't seem to match chip data
+ *   sheets, sometimes it's not needed and sometimes it hangs.  Prolific has
+ *   not responded to repeated support/information requests.
+ *
+ * Interop with more Win32 drivers may be a good thing.
+ *
+ * Seems like reporting "peer connected" (carrier present) events may end
+ * up going through the netlink event system, not hotplug ... that may be
+ * awkward in terms of automatic configuration though.
+ *
+ * There are reports that bridging gives lower-than-usual throughput.
+ *
+ * Need smarter hotplug policy scripts ... ones that know how to arrange
  * bridging with "brctl", and can handle static and dynamic ("pump") setups.
- * Use those "peer connected" events.
+ * Use those eventual "peer connected" events, and zeroconf.
  *
  *
  * CHANGELOG:
@@ -62,6 +71,7 @@
  * 18-dec-2000	(db) tx watchdog, "net1080" renaming to "usbnet", device_info
  *		and prolific support, isolate net1080-specific bits, cleanup.
  *		fix unlink_urbs oops in D3 PM resume code path.
+ *
  * 02-feb-2001	(db) fix tx skb sharing, packet length, match_flags, ...
  * 08-feb-2001	stubbed in "linuxdev", maybe the SA-1100 folk can use it;
  *		AnchorChips 2720 support (from spec) for testing;
@@ -83,6 +93,14 @@
  *		tie mostly to (sub)driver info.  Workaround some PL-2302
  *		chips that seem to reject SET_INTERFACE requests.
  *
+ * 06-apr-2002	Added ethtool support, based on a patch from Brad Hards.
+ *		Level of diagnostics is more configurable; they use device
+ *		location (usb_device->devpath) instead of address (2.5).
+ *		For tx_fixup, memflags can't be NOIO.
+ * 07-may-2002	Generalize/cleanup keventd support, handling rx stalls (mostly
+ *		for USB 2.0 TTs) and memory shortages (potential) too. (db)
+ *		Use "locally assigned" IEEE802 address space. (Brad Hards)
+ *
  *-------------------------------------------------------------------------*/
 
 #include <linux/config.h>
@@ -93,6 +111,9 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/random.h>
+#include <linux/ethtool.h>
+#include <linux/tqueue.h>
+#include <asm/uaccess.h>
 #include <asm/unaligned.h>
 
 // #define	DEBUG			// error path messages, extra info
@@ -104,15 +125,27 @@
 #endif
 #include <linux/usb.h>
 
+/* in 2.5 these standard usb ops take mem_flags */
+#define ALLOC_URB(n,flags)	usb_alloc_urb(n)
+#define SUBMIT_URB(u,flags)	usb_submit_urb(u)
+
+/* and these got renamed (may move to usb.h) */
+#define usb_get_dev		usb_inc_dev_use
+#define usb_put_dev		usb_dec_dev_use
 
+
+/* minidrivers _could_ be individually configured */
 #define	CONFIG_USB_AN2720
 #define	CONFIG_USB_BELKIN
+#define	CONFIG_USB_EPSON2888
 #define	CONFIG_USB_GENESYS
 #define	CONFIG_USB_LINUXDEV
 #define	CONFIG_USB_NET1080
 #define	CONFIG_USB_PL2301
 
 
+#define DRIVER_VERSION		"17-Jul-2002"
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -164,6 +197,7 @@
 	// protocol/interface state
 	struct net_device	net;
 	struct net_device_stats	stats;
+	int			msg_level;
 
 #ifdef CONFIG_USB_NET1080
 	u16			packet_id;
@@ -174,7 +208,12 @@
 	struct sk_buff_head	txq;
 	struct sk_buff_head	done;
 	struct tasklet_struct	bh;
-	struct tq_struct	ctrl_task;
+
+	struct tq_struct	kevent;
+	unsigned long		flags;
+#		define EVENT_TX_HALT	0
+#		define EVENT_RX_HALT	1
+#		define EVENT_RX_MEMORY	2
 };
 
 // device-specific info used by the driver
@@ -224,6 +263,13 @@
 	size_t			length;
 };
 
+static const char driver_name [] = "usbnet";
+
+/* use ethtool to change the level for any given device */
+static int msg_level = 1;
+MODULE_PARM (msg_level, "i");
+MODULE_PARM_DESC (msg_level, "Initial message level (default = 1)");
+
 
 #define	mutex_lock(x)	down(x)
 #define	mutex_unlock(x)	up(x)
@@ -241,7 +287,9 @@
 #endif
 
 #define devinfo(usbnet, fmt, arg...) \
-	printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net.name, ## arg)
+	do { if ((usbnet)->msg_level >= 1) \
+	printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net.name, ## arg); \
+	} while (0)
 
 
 #ifdef	CONFIG_USB_AN2720
@@ -258,12 +306,12 @@
  *-------------------------------------------------------------------------*/
 
 static const struct driver_info	an2720_info = {
-	description:	"AnchorChips/Cypress 2720",
+	.description =	"AnchorChips/Cypress 2720",
 	// no reset available!
 	// no check_connect available!
 
-	in: 2, out: 2,		// direction distinguishes these
-	epsize:	64,
+	.in = 2, .out = 2,		// direction distinguishes these
+	.epsize =64,
 };
 
 #endif	/* CONFIG_USB_AN2720 */
@@ -281,16 +329,39 @@
  *-------------------------------------------------------------------------*/
 
 static const struct driver_info	belkin_info = {
-	description:	"Belkin, eTEK, or compatible",
+	.description =	"Belkin, eTEK, or compatible",
 
-	in: 1, out: 1,		// direction distinguishes these
-	epsize:	64,
+	.in = 1, .out = 1,		// direction distinguishes these
+	.epsize =64,
 };
 
 #endif	/* CONFIG_USB_BELKIN */
 
 
 
+#ifdef	CONFIG_USB_EPSON2888
+
+/*-------------------------------------------------------------------------
+ *
+ * EPSON USB clients
+ *
+ * This is the same idea as "linuxdev" (below) except the firmware in the
+ * device might not be Tux-powered.  Epson provides reference firmware that
+ * implements this interface.  Product developers can reuse or modify that
+ * code, such as by using their own product and vendor codes.
+ *
+ *-------------------------------------------------------------------------*/
+
+static const struct driver_info	epson2888_info = {
+	.description =	"Epson USB Device",
+
+	.in = 4, .out = 3,
+	.epsize = 64,
+};
+
+#endif	/* CONFIG_USB_EPSON2888 */
+
+
 #ifdef CONFIG_USB_GENESYS
 
 /*-------------------------------------------------------------------------
@@ -300,6 +371,15 @@
  * ... should partially interop with the Win32 driver for this hardware
  * The GeneSys docs imply there's some NDIS issue motivating this framing.
  *
+ * Some info from GeneSys:
+ *  - GL620USB-A is full duplex; GL620USB is only half duplex for bulk.
+ *    (Some cables, like the BAFO-100c, use the half duplex version.)
+ *  - For the full duplex model, the low bit of the version code says
+ *    which side is which ("left/right").
+ *  - For the half duplex type, a control/interrupt handshake settles
+ *    the transfer direction.  (That's disabled here, partially coded.)
+ *    A control URB would block until other side writes an interrupt.
+ *
  *-------------------------------------------------------------------------*/
 
 // control msg write command
@@ -373,7 +453,7 @@
 	// issue usb interrupt read
 	if (priv && priv->irq_urb) {
 		// submit urb
-		if ((retval = usb_submit_urb (priv->irq_urb)) != 0)
+		if ((retval = SUBMIT_URB (priv->irq_urb, GFP_KERNEL)) != 0)
 			dbg ("gl_interrupt_read: submit fail - %X...", retval);
 		else
 			dbg ("gl_interrupt_read: submit success...");
@@ -420,7 +500,7 @@
 	}
 
 	// allocate irq urb
-	if ((priv->irq_urb = usb_alloc_urb (0)) == 0) {
+	if ((priv->irq_urb = ALLOC_URB (0, GFP_KERNEL)) == 0) {
 		dbg ("%s: cannot allocate private irq urb per device",
 			dev->net.name);
 		kfree (priv);
@@ -464,23 +544,8 @@
 	return 0;
 }
 
-#else
-
-static int genelink_check_connect (struct usbnet *dev)
-{
-	dbg ("%s: assuming peer is connected", dev->net.name);
-	return 0;
-}
-
 #endif
 
-// reset the device status
-static int genelink_reset (struct usbnet *dev)
-{
-	// we don't need to reset, just return 0
-	return 0;
-}
-
 static int genelink_rx_fixup (struct usbnet *dev, struct sk_buff *skb)
 {
 	struct gl_header	*header;
@@ -600,15 +665,17 @@
 }
 
 static const struct driver_info	genelink_info = {
-	description:	"Genesys GeneLink",
-	flags:		FLAG_FRAMING_GL | FLAG_NO_SETINT,
-	reset:		genelink_reset,
-	check_connect:	genelink_check_connect,
-	rx_fixup:	genelink_rx_fixup,
-	tx_fixup:	genelink_tx_fixup,
+	.description =	"Genesys GeneLink",
+	.flags =	FLAG_FRAMING_GL | FLAG_NO_SETINT,
+	.rx_fixup =	genelink_rx_fixup,
+	.tx_fixup =	genelink_tx_fixup,
+
+	.in = 1, .out = 2,
+	.epsize =64,
 
-	in: 1, out: 2,
-	epsize:	64,
+#ifdef	GENELINK_ACK
+	.check_connect =genelink_check_connect,
+#endif
 };
 
 #endif /* CONFIG_USB_GENESYS */
@@ -629,21 +696,19 @@
  *
  * One example is Intel's SA-1100 chip, which integrates basic USB
  * support (arch/arm/sa1100/usb-eth.c); it's used in the iPaq PDA.
+ * And others too, like the Yopy.
  *
  *-------------------------------------------------------------------------*/
 
-
 static const struct driver_info	linuxdev_info = {
-	description:	"Linux Device",
-	// no reset defined (yet?)
-	// no check_connect needed!
-	in: 2, out: 1,
-	epsize:	64,
+	.description =	"Linux Device",
+
+	.in = 2, .out = 1,
+	.epsize = 64,
 };
 
 #endif	/* CONFIG_USB_LINUXDEV */
 
-
 
 #ifdef	CONFIG_USB_NET1080
 
@@ -814,10 +879,10 @@
 static inline void nc_dump_usbctl (struct usbnet *dev, u16 usbctl)
 {
 #ifdef DEBUG
-	devdbg (dev, "net1080 %03d/%03d usbctl 0x%x:%s%s%s%s%s;"
+	devdbg (dev, "net1080 %s-%s usbctl 0x%x:%s%s%s%s%s;"
 			" this%s%s;"
 			" other%s%s; r/o 0x%x",
-		dev->udev->bus->busnum, dev->udev->devnum,
+		dev->udev->bus->bus_name, dev->udev->devpath,
 		usbctl,
 		(usbctl & USBCTL_ENABLE_LANG) ? " lang" : "",
 		(usbctl & USBCTL_ENABLE_MFGR) ? " mfgr" : "",
@@ -859,10 +924,10 @@
 static inline void nc_dump_status (struct usbnet *dev, u16 status)
 {
 #ifdef DEBUG
-	devdbg (dev, "net1080 %03d/%03d status 0x%x:"
+	devdbg (dev, "net1080 %s-%s status 0x%x:"
 			" this (%c) PKT=%d%s%s%s;"
 			" other PKT=%d%s%s%s; unspec 0x%x",
-		dev->udev->bus->busnum, dev->udev->devnum,
+		dev->udev->bus->bus_name, dev->udev->devpath,
 		status,
 
 		// XXX the packet counts don't seem right
@@ -897,8 +962,8 @@
 static inline void nc_dump_ttl (struct usbnet *dev, u16 ttl)
 {
 #ifdef DEBUG
-	devdbg (dev, "net1080 %03d/%03d ttl 0x%x this = %d, other = %d",
-		dev->udev->bus->busnum, dev->udev->devnum,
+	devdbg (dev, "net1080 %s-%s ttl 0x%x this = %d, other = %d",
+		dev->udev->bus->bus_name, dev->udev->devpath,
 		ttl,
 
 		TTL_THIS (ttl),
@@ -921,7 +986,8 @@
 	// nc_dump_registers (dev);
 
 	if ((retval = nc_register_read (dev, REG_STATUS, vp)) < 0) {
-		dbg ("can't read dev %d status: %d", dev->udev->devnum, retval);
+		dbg ("can't read %s-%s status: %d",
+			dev->udev->bus->bus_name, dev->udev->devpath, retval);
 		goto done;
 	}
 	status = *vp;
@@ -948,10 +1014,11 @@
 			MK_TTL (NC_READ_TTL_MS, TTL_OTHER (ttl)) );
 	dbg ("%s: assigned TTL, %d ms", dev->net.name, NC_READ_TTL_MS);
 
-	devdbg (dev, "port %c, peer %sconnected",
-		(status & STATUS_PORT_A) ? 'A' : 'B',
-		(status & STATUS_CONN_OTHER) ? "" : "dis"
-		);
+	if (dev->msg_level >= 2)
+		devinfo (dev, "port %c, peer %sconnected",
+			(status & STATUS_PORT_A) ? 'A' : 'B',
+			(status & STATUS_CONN_OTHER) ? "" : "dis"
+			);
 	retval = 0;
 
 done:
@@ -1079,15 +1146,15 @@
 }
 
 static const struct driver_info	net1080_info = {
-	description:	"NetChip TurboCONNECT",
-	flags:		FLAG_FRAMING_NC,
-	reset:		net1080_reset,
-	check_connect:	net1080_check_connect,
-	rx_fixup:	net1080_rx_fixup,
-	tx_fixup:	net1080_tx_fixup,
+	.description =	"NetChip TurboCONNECT",
+	.flags =	FLAG_FRAMING_NC,
+	.reset =	net1080_reset,
+	.check_connect =net1080_check_connect,
+	.rx_fixup =	net1080_rx_fixup,
+	.tx_fixup =	net1080_tx_fixup,
 
-	in: 1, out: 1,		// direction distinguishes these
-	epsize:	64,
+	.in = 1, .out = 1,		// direction distinguishes these
+	.epsize =64,
 };
 
 #endif /* CONFIG_USB_NET1080 */
@@ -1147,24 +1214,14 @@
 		PL_S_EN|PL_RESET_OUT|PL_RESET_IN|PL_PEER_E);
 }
 
-static int pl_check_connect (struct usbnet *dev)
-{
-	// FIXME test interrupt data PL_PEER_E bit
-	// plus, there's some handshake done by
-	// the prolific win32 driver... 
-	dbg ("%s: assuming peer is connected", dev->net.name);
-	return 0;
-}
-
 static const struct driver_info	prolific_info = {
-	description:	"Prolific PL-2301/PL-2302",
-	flags:		FLAG_NO_SETINT,
+	.description =	"Prolific PL-2301/PL-2302",
+	.flags =	FLAG_NO_SETINT,
 		/* some PL-2302 versions seem to fail usb_set_interface() */
-	reset:		pl_reset,
-	check_connect:	pl_check_connect,
+	.reset =	pl_reset,
 
-	in: 3, out: 2,
-	epsize:	64,
+	.in = 3, .out = 2,
+	.epsize =64,
 };
 
 #endif /* CONFIG_USB_PL2301 */
@@ -1227,6 +1284,21 @@
 	spin_unlock_irqrestore (&dev->done.lock, flags);
 }
 
+/* some work can't be done in tasklets, so we use keventd
+ *
+ * NOTE:  annoying asymmetry:  if it's active, schedule_task() fails,
+ * but tasklet_schedule() doesn't.  hope the failure is rare.
+ */
+static void defer_kevent (struct usbnet *dev, int work)
+{
+	set_bit (work, &dev->flags);
+	if (!schedule_task (&dev->kevent))
+		err ("%s: kevent %d may have been dropped",
+			dev->net.name, work);
+	else
+		dbg ("%s: kevent %d scheduled", dev->net.name, work);
+}
+
 /*-------------------------------------------------------------------------*/
 
 static void rx_complete (struct urb *urb);
@@ -1253,7 +1325,7 @@
 
 	if ((skb = alloc_skb (size, flags)) == 0) {
 		dbg ("no rx skb");
-		tasklet_schedule (&dev->bh);
+		defer_kevent (dev, EVENT_RX_MEMORY);
 		usb_free_urb (urb);
 		return;
 	}
@@ -1268,9 +1340,6 @@
 		usb_rcvbulkpipe (dev->udev, dev->driver_info->in),
 		skb->data, size, rx_complete, skb);
 	urb->transfer_flags |= USB_ASYNC_UNLINK;
-#ifdef	REALLY_QUEUE
-	urb->transfer_flags |= USB_QUEUE_BULK;
-#endif
 #if 0
 	// Idle-but-posted reads with UHCI really chew up
 	// PCI bandwidth unless FSBR is disabled
@@ -1279,11 +1348,20 @@
 
 	spin_lock_irqsave (&dev->rxq.lock, lockflags);
 
-	if (netif_running (&dev->net)) {
-		if ((retval = usb_submit_urb (urb)) != 0) {
+	if (netif_running (&dev->net)
+			&& !test_bit (EVENT_RX_HALT, &dev->flags)) {
+		switch (retval = SUBMIT_URB (urb, GFP_ATOMIC)){ 
+		case -EPIPE:
+			defer_kevent (dev, EVENT_RX_HALT);
+			break;
+		case -ENOMEM:
+			defer_kevent (dev, EVENT_RX_MEMORY);
+			break;
+		default:
 			dbg ("%s rx submit, %d", dev->net.name, retval);
 			tasklet_schedule (&dev->bh);
-		} else {
+			break;
+		case 0:
 			__skb_queue_tail (&dev->rxq, skb);
 		}
 	} else {
@@ -1357,12 +1435,20 @@
 		}
 		break;
 
+	    // stalls need manual reset. this is rare ... except that
+	    // when going through USB 2.0 TTs, unplug appears this way.
+	    // we avoid the highspeed version of the ETIMEOUT/EILSEQ
+	    // storm, recovering as needed.
+	    case -EPIPE:
+		defer_kevent (dev, EVENT_RX_HALT);
+		// FALLTHROUGH
+
 	    // software-driven interface shutdown
-	    case -ECONNRESET:		// usb-ohci, usb-uhci
-	    case -ECONNABORTED:		// uhci ... for usb-uhci, INTR
-		dbg ("%s shutdown, code %d", dev->net.name, urb_status);
+	    case -ECONNRESET:		// according to API spec
+	    case -ECONNABORTED:		// some (now fixed?) UHCI bugs
+		dbg ("%s rx shutdown, code %d", dev->net.name, urb_status);
 		entry->state = rx_cleanup;
-		// do urb frees only in the tasklet
+		// do urb frees only in the tasklet (UHCI has oopsed ...)
 		entry->urb = urb;
 		urb = 0;
 		break;
@@ -1373,8 +1459,9 @@
 		// FALLTHROUGH
 	    
 	    default:
-		// on unplug we'll get a burst of ETIMEDOUT/EILSEQ
-		// till the khubd gets and handles its interrupt.
+		// on unplug we get ETIMEDOUT (ohci) or EILSEQ (uhci)
+		// until khubd sees its interrupt and disconnects us.
+		// that can easily be hundreds of passes through here.
 		entry->state = rx_cleanup;
 		dev->stats.rx_errors++;
 		dbg ("%s rx: status %d", dev->net.name, urb_status);
@@ -1384,10 +1471,12 @@
 	defer_bh (dev, skb);
 
 	if (urb) {
-		if (netif_running (&dev->net)) {
+		if (netif_running (&dev->net)
+				&& !test_bit (EVENT_RX_HALT, &dev->flags)) {
 			rx_submit (dev, urb, GFP_ATOMIC);
 			return;
 		}
+		usb_free_urb (urb);
 	}
 #ifdef	VERBOSE
 	dbg ("no read resubmitted");
@@ -1417,7 +1506,7 @@
 		// during some PM-driven resume scenarios,
 		// these (async) unlinks complete immediately
 		retval = usb_unlink_urb (urb);
-		if (retval < 0)
+		if (retval != -EINPROGRESS && retval != 0)
 			dbg ("unlink urb err, %d", retval);
 		else
 			count++;
@@ -1441,10 +1530,11 @@
 	mutex_lock (&dev->mutex);
 	netif_stop_queue (net);
 
-	devdbg (dev, "stop stats: rx/tx %ld/%ld, errs %ld/%ld",
-		dev->stats.rx_packets, dev->stats.tx_packets, 
-		dev->stats.rx_errors, dev->stats.tx_errors
-		);
+	if (dev->msg_level >= 2)
+		devinfo (dev, "stop stats: rx/tx %ld/%ld, errs %ld/%ld",
+			dev->stats.rx_packets, dev->stats.tx_packets, 
+			dev->stats.rx_errors, dev->stats.tx_errors
+			);
 
 	// ensure there are no more active urbs
 	add_wait_queue (&unlink_wakeup, &wait);
@@ -1482,9 +1572,9 @@
 
 	// put into "known safe" state
 	if (info->reset && (retval = info->reset (dev)) < 0) {
-		devinfo (dev, "open reset fail (%d) usbnet %03d/%03d, %s",
+		devinfo (dev, "open reset fail (%d) usbnet usb-%s-%s, %s",
 			retval,
-			dev->udev->bus->busnum, dev->udev->devnum,
+			dev->udev->bus->bus_name, dev->udev->devpath,
 			info->description);
 		goto done;
 	}
@@ -1496,14 +1586,16 @@
 	}
 
 	netif_start_queue (net);
-	devdbg (dev, "open: enable queueing (rx %d, tx %d) mtu %d %s framing",
-		RX_QLEN, TX_QLEN, dev->net.mtu,
-		(info->flags & (FLAG_FRAMING_NC | FLAG_FRAMING_GL))
-		    ? ((info->flags & FLAG_FRAMING_NC)
-			? "NetChip"
-			: "GeneSys")
-		    : "raw"
-		);
+	if (dev->msg_level >= 2)
+		devinfo (dev, "open: enable queueing "
+				"(rx %d, tx %d) mtu %d %s framing",
+			RX_QLEN, TX_QLEN, dev->net.mtu,
+			(info->flags & (FLAG_FRAMING_NC | FLAG_FRAMING_GL))
+			    ? ((info->flags & FLAG_FRAMING_NC)
+				? "NetChip"
+				: "GeneSys")
+			    : "raw"
+			);
 
 	// delay posting reads until we're fully open
 	tasklet_schedule (&dev->bh);
@@ -1514,16 +1606,134 @@
 
 /*-------------------------------------------------------------------------*/
 
-/* usb_clear_halt cannot be called in interrupt context */
+static int usbnet_ethtool_ioctl (struct net_device *net, void *useraddr)
+{
+	struct usbnet	*dev = (struct usbnet *) net->priv;
+	u32		cmd;
+
+	if (get_user (cmd, (u32 *)useraddr))
+		return -EFAULT;
+	switch (cmd) {
+
+	case ETHTOOL_GDRVINFO: {	/* get driver info */
+		struct ethtool_drvinfo		info;
+
+		memset (&info, 0, sizeof info);
+		info.cmd = ETHTOOL_GDRVINFO;
+		strncpy (info.driver, driver_name, sizeof info.driver);
+		strncpy (info.version, DRIVER_VERSION, sizeof info.version);
+		strncpy (info.fw_version, dev->driver_info->description,
+			sizeof info.fw_version);
+		usb_make_path (dev->udev, info.bus_info, sizeof info.bus_info);
+		if (copy_to_user (useraddr, &info, sizeof (info)))
+			return -EFAULT;
+		return 0;
+		}
+
+	case ETHTOOL_GLINK: 		/* get link status */
+		if (dev->driver_info->check_connect) {
+			struct ethtool_value	edata = { ETHTOOL_GLINK };
+
+			edata.data = dev->driver_info->check_connect (dev) == 0;
+			if (copy_to_user (useraddr, &edata, sizeof (edata)))
+				return -EFAULT;
+			return 0;
+		}
+		break;
 
+	case ETHTOOL_GMSGLVL: {		/* get message-level */
+		struct ethtool_value	edata = {ETHTOOL_GMSGLVL};
+
+		edata.data = dev->msg_level;
+		if (copy_to_user (useraddr, &edata, sizeof (edata)))
+			return -EFAULT;
+		return 0;
+		}
+
+	case ETHTOOL_SMSGLVL: {		/* set message-level */
+		struct ethtool_value	edata;
+
+		if (copy_from_user (&edata, useraddr, sizeof (edata)))
+			return -EFAULT;
+		dev->msg_level = edata.data;
+		return 0;
+		}
+	
+	/* could also map RINGPARAM to RX/TX QLEN */
+
+	}
+        /* Note that the ethtool user space code requires EOPNOTSUPP */
+	return -EOPNOTSUPP;
+}
+
+static int usbnet_ioctl (struct net_device *net, struct ifreq *rq, int cmd)
+{
+	switch (cmd) {
+	case SIOCETHTOOL:
+		return usbnet_ethtool_ioctl (net, (void *)rq->ifr_data);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* work that cannot be done in interrupt context uses keventd.
+ *
+ * NOTE:  "uhci" and "usb-uhci" may have trouble with this since they don't
+ * queue control transfers to individual devices, and other threads could
+ * trigger control requests concurrently.  hope that's rare.
+ */
 static void
-tx_clear_halt (void *data)
+kevent (void *data)
 {
 	struct usbnet		*dev = data;
+	int			status;
 
-	usb_clear_halt (dev->udev,
-		usb_sndbulkpipe (dev->udev, dev->driver_info->out));
-	netif_wake_queue (&dev->net);
+	/* usb_clear_halt() needs a thread context */
+	if (test_bit (EVENT_TX_HALT, &dev->flags)) {
+		unlink_urbs (&dev->txq);
+		status = usb_clear_halt (dev->udev,
+			usb_sndbulkpipe (dev->udev, dev->driver_info->out));
+		if (status < 0)
+			err ("%s: can't clear tx halt, status %d",
+				dev->net.name, status);
+		else {
+			clear_bit (EVENT_TX_HALT, &dev->flags);
+			netif_wake_queue (&dev->net);
+		}
+	}
+	if (test_bit (EVENT_RX_HALT, &dev->flags)) {
+		unlink_urbs (&dev->rxq);
+		status = usb_clear_halt (dev->udev,
+			usb_rcvbulkpipe (dev->udev, dev->driver_info->in));
+		if (status < 0)
+			err ("%s: can't clear rx halt, status %d",
+				dev->net.name, status);
+		else {
+			clear_bit (EVENT_RX_HALT, &dev->flags);
+			tasklet_schedule (&dev->bh);
+		}
+	}
+
+	/* tasklet could resubmit itself forever if memory is tight */
+	if (test_bit (EVENT_RX_MEMORY, &dev->flags)) {
+		struct urb	*urb = 0;
+
+		if (netif_running (&dev->net))
+			urb = ALLOC_URB (0, GFP_KERNEL);
+		else
+			clear_bit (EVENT_RX_MEMORY, &dev->flags);
+		if (urb != 0) {
+			clear_bit (EVENT_RX_MEMORY, &dev->flags);
+			rx_submit (dev, urb, GFP_KERNEL);
+			tasklet_schedule (&dev->bh);
+		}
+	}
+
+	if (dev->flags)
+		dbg ("%s: kevent done, flags = 0x%lx",
+			dev->net.name, dev->flags);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1534,15 +1744,8 @@
 	struct skb_data		*entry = (struct skb_data *) skb->cb;
 	struct usbnet		*dev = entry->dev;
 
-	if (urb->status == USB_ST_STALL) {
-		if (dev->ctrl_task.sync == 0) {
-			dev->ctrl_task.routine = tx_clear_halt;
-			dev->ctrl_task.data = dev;
-			schedule_task (&dev->ctrl_task);
-		} else {
-			dbg ("Cannot clear TX stall");
-		}
-	}
+	if (urb->status == -EPIPE)
+		defer_kevent (dev, EVENT_TX_HALT);
 	urb->dev = 0;
 	entry->state = tx_done;
 	defer_bh (dev, skb);
@@ -1576,19 +1779,17 @@
 	struct nc_trailer	*trailer = 0;
 #endif	/* CONFIG_USB_NET1080 */
 
-	flags = in_interrupt () ? GFP_ATOMIC : GFP_NOIO; /* might be used for nfs */
-
 	// some devices want funky USB-level framing, for
 	// win32 driver (usually) and/or hardware quirks
 	if (info->tx_fixup) {
-		skb = info->tx_fixup (dev, skb, flags);
+		skb = info->tx_fixup (dev, skb, GFP_ATOMIC);
 		if (!skb) {
 			dbg ("can't tx_fixup skb");
 			goto drop;
 		}
 	}
 
-	if (!(urb = usb_alloc_urb (0))) {
+	if (!(urb = ALLOC_URB (0, GFP_ATOMIC))) {
 		dbg ("no urb");
 		goto drop;
 	}
@@ -1621,9 +1822,6 @@
 			usb_sndbulkpipe (dev->udev, info->out),
 			skb->data, skb->len, tx_complete, skb);
 	urb->transfer_flags |= USB_ASYNC_UNLINK;
-#ifdef	REALLY_QUEUE
-	urb->transfer_flags |= USB_QUEUE_BULK;
-#endif
 	// FIXME urb->timeout = ... jiffies ... ;
 
 	spin_lock_irqsave (&dev->txq.lock, flags);
@@ -1640,15 +1838,19 @@
 	}
 #endif	/* CONFIG_USB_NET1080 */
 
-	netif_stop_queue (net);
-	if ((retval = usb_submit_urb (urb)) != 0) {
-		netif_start_queue (net);
+	switch ((retval = SUBMIT_URB (urb, GFP_ATOMIC))) {
+	case -EPIPE:
+		netif_stop_queue (net);
+		defer_kevent (dev, EVENT_TX_HALT);
+		break;
+	default:
 		dbg ("%s tx: submit urb err %d", net->name, retval);
-	} else {
+		break;
+	case 0:
 		net->trans_start = jiffies;
 		__skb_queue_tail (&dev->txq, skb);
-		if (dev->txq.qlen < TX_QLEN)
-			netif_start_queue (net);
+		if (dev->txq.qlen >= TX_QLEN)
+			netif_stop_queue (net);
 	}
 	spin_unlock_irqrestore (&dev->txq.lock, flags);
 
@@ -1715,14 +1917,15 @@
 		}
 
 	// or are we maybe short a few urbs?
-	} else if (netif_running (&dev->net)) {
+	} else if (netif_running (&dev->net)
+			&& !test_bit (EVENT_RX_HALT, &dev->flags)) {
 		int	temp = dev->rxq.qlen;
 
 		if (temp < RX_QLEN) {
 			struct urb	*urb;
 			int		i;
 			for (i = 0; i < 3 && dev->rxq.qlen < RX_QLEN; i++) {
-				if ((urb = usb_alloc_urb (0)) != 0)
+				if ((urb = ALLOC_URB (0, GFP_ATOMIC)) != 0)
 					rx_submit (dev, urb, GFP_ATOMIC);
 			}
 			if (temp != dev->rxq.qlen)
@@ -1750,8 +1953,8 @@
 {
 	struct usbnet	*dev = (struct usbnet *) ptr;
 
-	devinfo (dev, "unregister usbnet %03d/%03d, %s",
-		udev->bus->busnum, udev->devnum,
+	devinfo (dev, "unregister usbnet usb-%s-%s, %s",
+		udev->bus->bus_name, udev->devpath,
 		dev->driver_info->description);
 	
 	unregister_netdev (&dev->net);
@@ -1761,8 +1964,11 @@
 	list_del (&dev->dev_list);
 	mutex_unlock (&usbnet_mutex);
 
+	// assuming we used keventd, it must quiesce too
+	flush_scheduled_tasks ();
+
 	kfree (dev);
-	usb_dec_dev_use (udev);
+	usb_put_dev (udev);
 }
 
 
@@ -1808,15 +2014,17 @@
 	memset (dev, 0, sizeof *dev);
 
 	init_MUTEX_LOCKED (&dev->mutex);
-	usb_inc_dev_use (udev);
+	usb_get_dev (udev);
 	dev->udev = udev;
 	dev->driver_info = info;
+	dev->msg_level = msg_level;
 	INIT_LIST_HEAD (&dev->dev_list);
 	skb_queue_head_init (&dev->rxq);
 	skb_queue_head_init (&dev->txq);
 	skb_queue_head_init (&dev->done);
 	dev->bh.func = usbnet_bh;
 	dev->bh.data = (unsigned long) dev;
+	INIT_TQUEUE (&dev->kevent, kevent, dev);
 
 	// set up network interface records
 	net = &dev->net;
@@ -1836,10 +2044,11 @@
 	net->stop = usbnet_stop;
 	net->watchdog_timeo = TX_TIMEOUT_JIFFIES;
 	net->tx_timeout = usbnet_tx_timeout;
+	net->do_ioctl = usbnet_ioctl;
 
 	register_netdev (&dev->net);
-	devinfo (dev, "register usbnet %03d/%03d, %s",
-		udev->bus->busnum, udev->devnum,
+	devinfo (dev, "register usbnet usb-%s-%s, %s",
+		udev->bus->bus_name, udev->devpath,
 		dev->driver_info->description);
 
 	// ok, it's ready to go.
@@ -1867,33 +2076,41 @@
 #ifdef	CONFIG_USB_AN2720
 {
 	USB_DEVICE (0x0547, 0x2720),	// AnchorChips defaults
-	driver_info:	(unsigned long) &an2720_info,
-},
-
-{
+	.driver_info =	(unsigned long) &an2720_info,
+}, {
 	USB_DEVICE (0x0547, 0x2727),	// Xircom PGUNET
-	driver_info:	(unsigned long) &an2720_info,
+	.driver_info =	(unsigned long) &an2720_info,
 },
 #endif
 
 #ifdef	CONFIG_USB_BELKIN
 {
 	USB_DEVICE (0x050d, 0x0004),	// Belkin
-	driver_info:	(unsigned long) &belkin_info,
+	.driver_info =	(unsigned long) &belkin_info,
 }, {
 	USB_DEVICE (0x056c, 0x8100),	// eTEK
-	driver_info:	(unsigned long) &belkin_info,
+	.driver_info =	(unsigned long) &belkin_info,
 }, {
 	USB_DEVICE (0x0525, 0x9901),	// Advance USBNET (eTEK)
-	driver_info:	(unsigned long) &belkin_info,
+	.driver_info =	(unsigned long) &belkin_info,
+},
+#endif
+
+#ifdef	CONFIG_USB_EPSON2888
+{
+	USB_DEVICE (0x0525, 0x2888),	// EPSON USB client
+	driver_info:	(unsigned long) &epson2888_info,
 },
 #endif
 
 #ifdef	CONFIG_USB_GENESYS
 {
 	USB_DEVICE (0x05e3, 0x0502),	// GL620USB-A
-	driver_info:	(unsigned long) &genelink_info,
+	.driver_info =	(unsigned long) &genelink_info,
 },
+	/* NOT: USB_DEVICE (0x05e3, 0x0501),	// GL620USB
+	 * that's half duplex, not currently supported
+	 */
 #endif
 
 #ifdef	CONFIG_USB_LINUXDEV
@@ -1904,28 +2121,32 @@
 {
 	// 1183 = 0x049F, both used as hex values?
 	USB_DEVICE (0x049F, 0x505A),	// Compaq "Itsy"
-	driver_info:	(unsigned long) &linuxdev_info,
+	.driver_info =	(unsigned long) &linuxdev_info,
+}, {
+	USB_DEVICE (0x0E7E, 0x1001),	// G.Mate "Yopy"
+	.driver_info =	(unsigned long) &linuxdev_info,
 },
+	// NOTE:  the Sharp Zaurus uses a modified version of
+	// this driver, which is not interoperable with this.
 #endif
 
 #ifdef	CONFIG_USB_NET1080
 {
 	USB_DEVICE (0x0525, 0x1080),	// NetChip ref design
-	driver_info:	(unsigned long) &net1080_info,
-},
-{
+	.driver_info =	(unsigned long) &net1080_info,
+}, {
 	USB_DEVICE (0x06D0, 0x0622),	// Laplink Gold
-	driver_info:	(unsigned long) &net1080_info,
+	.driver_info =	(unsigned long) &net1080_info,
 },
 #endif
 
 #ifdef CONFIG_USB_PL2301
 {
 	USB_DEVICE (0x067b, 0x0000),	// PL-2301
-	driver_info:	(unsigned long) &prolific_info,
+	.driver_info =	(unsigned long) &prolific_info,
 }, {
 	USB_DEVICE (0x067b, 0x0001),	// PL-2302
-	driver_info:	(unsigned long) &prolific_info,
+	.driver_info =	(unsigned long) &prolific_info,
 },
 #endif
 
@@ -1936,10 +2157,10 @@
 MODULE_DEVICE_TABLE (usb, products);
 
 static struct usb_driver usbnet_driver = {
-	name:		"usbnet",
-	id_table:	products,
-	probe:		usbnet_probe,
-	disconnect:	usbnet_disconnect,
+	.name =		driver_name,
+	.id_table =	products,
+	.probe =	usbnet_probe,
+	.disconnect =	usbnet_disconnect,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -1952,6 +2173,7 @@
 
 	get_random_bytes (node_id, sizeof node_id);
 	node_id [0] &= 0xfe;	// clear multicast bit
+	node_id [0] |= 0x02;    // set local assignment bit (IEEE802)
 
  	if (usb_register (&usbnet_driver) < 0)
  		return -1;
diff -Nur linux-2.4.19.old/drivers/usb/usbvideo.c linux-2.4.19/drivers/usb/usbvideo.c
--- linux-2.4.19.old/drivers/usb/usbvideo.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/usbvideo.c	Mon Nov 25 12:27:13 2002
@@ -58,57 +58,26 @@
 /* Memory management functions */
 /*******************************/
 
-#define MDEBUG(x)	do { } while(0)		/* Debug memory management */
-
-/* Given PGD from the address space's page table, return the kernel
- * virtual mapping of the physical memory mapped at ADR.
- */
-unsigned long usbvideo_uvirt_to_kva(pgd_t *pgd, unsigned long adr)
-{
-	unsigned long ret = 0UL;
-	pmd_t *pmd;
-	pte_t *ptep, pte;
-
-	if (!pgd_none(*pgd)) {
-		pmd = pmd_offset(pgd, adr);
-		if (!pmd_none(*pmd)) {
-			ptep = pte_offset(pmd, adr);
-			pte = *ptep;
-			if (pte_present(pte)) {
-				ret = (unsigned long) page_address(pte_page(pte));
-				ret |= (adr & (PAGE_SIZE-1));
-			}
-		}
-	}
-	MDEBUG(printk("uv2kva(%lx-->%lx)", adr, ret));
-	return ret;
-}
-
 /*
  * Here we want the physical address of the memory.
- * This is used when initializing the contents of the
- * area and marking the pages as reserved.
+ * This is used when initializing the contents of the area.
  */
 unsigned long usbvideo_kvirt_to_pa(unsigned long adr)
 {
-	unsigned long va, kva, ret;
+	unsigned long kva, ret;
 
-	va = VMALLOC_VMADDR(adr);
-	kva = usbvideo_uvirt_to_kva(pgd_offset_k(va), va);
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
 	ret = __pa(kva);
-	MDEBUG(printk("kv2pa(%lx-->%lx)", adr, ret));
 	return ret;
 }
 
 void *usbvideo_rvmalloc(unsigned long size)
 {
 	void *mem;
-	unsigned long adr, page;
-
-	/* Round it off to PAGE_SIZE */
-	size += (PAGE_SIZE - 1);
-	size &= ~(PAGE_SIZE - 1);
+	unsigned long adr;
 
+	size = PAGE_ALIGN(size);
 	mem = vmalloc_32(size);
 	if (!mem)
 		return NULL;
@@ -116,13 +85,9 @@
 	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
 	adr = (unsigned long) mem;
 	while (size > 0) {
-		page = usbvideo_kvirt_to_pa(adr);
-		mem_map_reserve(virt_to_page(__va(page)));
+		mem_map_reserve(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
-		if (size > PAGE_SIZE)
-			size -= PAGE_SIZE;
-		else
-			size = 0;
+		size -= PAGE_SIZE;
 	}
 
 	return mem;
@@ -130,23 +95,16 @@
 
 void usbvideo_rvfree(void *mem, unsigned long size)
 {
-	unsigned long adr, page;
+	unsigned long adr;
 
 	if (!mem)
 		return;
 
-	size += (PAGE_SIZE - 1);
-	size &= ~(PAGE_SIZE - 1);
-
-	adr=(unsigned long) mem;
-	while (size > 0) {
-		page = usbvideo_kvirt_to_pa(adr);
-		mem_map_unreserve(virt_to_page(__va(page)));
+	adr = (unsigned long) mem;
+	while ((long) size > 0) {
+		mem_map_unreserve(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
-		if (size > PAGE_SIZE)
-			size -= PAGE_SIZE;
-		else
-			size = 0;
+		size -= PAGE_SIZE;
 	}
 	vfree(mem);
 }
@@ -1782,7 +1740,7 @@
 /*
  * Make all of the blocks of data contiguous
  */
-static int usbvideo_CompressIsochronous(uvd_t *uvd, urb_t *urb)
+static int usbvideo_CompressIsochronous(uvd_t *uvd, struct urb *urb)
 {
 	char *cdata;
 	int i, totlen = 0;
@@ -1897,7 +1855,7 @@
 	/* We double buffer the Iso lists */
 	for (i=0; i < USBVIDEO_NUMSBUF; i++) {
 		int j, k;
-		urb_t *urb = uvd->sbuf[i].urb;
+		struct urb *urb = uvd->sbuf[i].urb;
 		urb->dev = dev;
 		urb->context = uvd;
 		urb->pipe = usb_rcvisocpipe(dev, uvd->video_endp);
diff -Nur linux-2.4.19.old/drivers/usb/usbvideo.h linux-2.4.19/drivers/usb/usbvideo.h
--- linux-2.4.19.old/drivers/usb/usbvideo.h	Thu Oct 11 08:42:46 2001
+++ linux-2.4.19/drivers/usb/usbvideo.h	Mon Nov 25 12:27:13 2002
@@ -165,7 +165,7 @@
 /* This structure represents one Isoc request - URB and buffer */
 typedef struct {
 	char *data;
-	urb_t *urb;
+	struct urb *urb;
 } usbvideo_sbuf_t;
 
 typedef struct {
diff -Nur linux-2.4.19.old/drivers/usb/vicam.c linux-2.4.19/drivers/usb/vicam.c
--- linux-2.4.19.old/drivers/usb/vicam.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/vicam.c	Mon Nov 25 12:27:13 2002
@@ -91,80 +91,25 @@
  *
  ******************************************************************************/
 
-/* [DaveM] I've recoded most of this so that:
- * 1) It's easier to tell what is happening
- * 2) It's more portable, especially for translating things
- *    out of vmalloc mapped areas in the kernel.
- * 3) Less unnecessary translations happen.
- *
- * The code used to assume that the kernel vmalloc mappings
- * existed in the page tables of every process, this is simply
- * not guarenteed.  We now use pgd_offset_k which is the
- * defined way to get at the kernel page tables.
- */
-
-/* Given PGD from the address space's page table, return the kernel
- * virtual mapping of the physical memory mapped at ADR.
- */
-static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
-{
-	unsigned long ret = 0UL;
-	pmd_t *pmd;
-	pte_t *ptep, pte;
-
-	if (!pgd_none(*pgd)) {
-		pmd = pmd_offset(pgd, adr);
-		if (!pmd_none(*pmd)) {
-			ptep = pte_offset(pmd, adr);
-			pte = *ptep;
-			if(pte_present(pte)) {
-				ret  = (unsigned long) page_address(pte_page(pte));
-				ret |= (adr & (PAGE_SIZE - 1));
-
-			}
-		}
-	}
-	return ret;
-}
-
-static inline unsigned long uvirt_to_bus(unsigned long adr)
-{
-	unsigned long kva, ret;
-
-	kva = uvirt_to_kva(pgd_offset(current->mm, adr), adr);
-	ret = virt_to_bus((void *)kva);
-	return ret;
-}
-
-static inline unsigned long kvirt_to_bus(unsigned long adr)
-{
-	unsigned long va, kva, ret;
-
-	va = VMALLOC_VMADDR(adr);
-	kva = uvirt_to_kva(pgd_offset_k(va), va);
-	ret = virt_to_bus((void *)kva);
-	return ret;
-}
-
 /* Here we want the physical address of the memory.
- * This is used when initializing the contents of the
- * area and marking the pages as reserved.
+ * This is used when initializing the contents of the area.
  */
 static inline unsigned long kvirt_to_pa(unsigned long adr)
 {
-	unsigned long va, kva, ret;
+	unsigned long kva, ret;
 
-	va = VMALLOC_VMADDR(adr);
-	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
 	ret = __pa(kva);
 	return ret;
 }
 
-static void * rvmalloc(signed long size)
+static void * rvmalloc(unsigned long size)
 {
 	void * mem;
-	unsigned long adr, page;
+	unsigned long adr;
 
+	size=PAGE_ALIGN(size);
 	mem=vmalloc_32(size);
 	if (mem)
 	{
@@ -172,8 +117,7 @@
 		adr=(unsigned long) mem;
 		while (size > 0)
 		{
-			page = kvirt_to_pa(adr);
-			mem_map_reserve(virt_to_page(__va(page)));
+			mem_map_reserve(vmalloc_to_page((void *)adr));
 			adr+=PAGE_SIZE;
 			size-=PAGE_SIZE;
 		}
@@ -181,17 +125,16 @@
 	return mem;
 }
 
-static void rvfree(void * mem, signed long size)
+static void rvfree(void * mem, unsigned long size)
 {
-	unsigned long adr, page;
+	unsigned long adr;
 
 	if (mem)
 	{
 		adr=(unsigned long) mem;
-		while (size > 0)
+		while ((long) size > 0)
 		{
-			page = kvirt_to_pa(adr);
-			mem_map_unreserve(virt_to_page(__va(page)));
+			mem_map_unreserve(vmalloc_to_page((void *)adr));
 			adr+=PAGE_SIZE;
 			size-=PAGE_SIZE;
 		}
@@ -532,7 +475,9 @@
 
 	if (!vdev || !buf)
 		return -EFAULT;
-
+	
+	if(buflen > 0x1e480)
+		buflen = 0x1e480;
 	if (copy_to_user(user_buf, buf2, buflen))
 		return -EFAULT;
 	return buflen;
@@ -866,7 +811,7 @@
 	return 1;
 }
 
-static void * __devinit vicam_probe(struct usb_device *udev, unsigned int ifnum,
+static void * vicam_probe(struct usb_device *udev, unsigned int ifnum,
 	const struct usb_device_id *id)
 {
 	struct usb_vicam *vicam;
diff -Nur linux-2.4.19.old/drivers/usb/vicam.h linux-2.4.19/drivers/usb/vicam.h
--- linux-2.4.19.old/drivers/usb/vicam.h	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/vicam.h	Mon Nov 25 12:27:13 2002
@@ -68,7 +68,7 @@
 	/* v4l stuff */
 	char *camera_name;
 	char *fbuf;
-	urb_t *urb[VICAM_NUMSBUF];
+	struct urb *urb[VICAM_NUMSBUF];
 	int sizes;
 	int *width;
 	int *height;
diff -Nur linux-2.4.19.old/drivers/usb/vicamurbs.h linux-2.4.19/drivers/usb/vicamurbs.h
--- linux-2.4.19.old/drivers/usb/vicamurbs.h	Mon Feb 25 20:38:07 2002
+++ linux-2.4.19/drivers/usb/vicamurbs.h	Mon Nov 25 12:27:13 2002
@@ -17,12 +17,6 @@
 
 /* Request 0x51 Image Setup */
 
-/* 128x98 ? 0x3180 size */
-static unsigned char s128x98bw[] = {
-  0,    0x34, 0xC4, 0x00, 0x00, 0x00, 0,    0,
-  0x18, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00
-};
-
 /* 128x122 3D80 size */
 static unsigned char s128x122bw[] = {
   0,    0x34, 0xF4, 0x00, 0x00, 0x00, 0,    0,
diff -Nur linux-2.4.19.old/drivers/usb/wacom.c linux-2.4.19/drivers/usb/wacom.c
--- linux-2.4.19.old/drivers/usb/wacom.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.19/drivers/usb/wacom.c	Mon Nov 25 12:27:13 2002
@@ -111,7 +111,6 @@
 	struct wacom_features *features;
 	int tool[2];
 	int open;
-	int x, y;
 	__u32 serial[2];
 };
 
@@ -209,16 +208,16 @@
 			input_report_abs(dev, ABS_DISTANCE, data[7]);
 			input_report_rel(dev, REL_WHEEL, (signed char) data[6]);
 
-			input_report_abs(dev, ABS_X, wacom->x = x);
-			input_report_abs(dev, ABS_Y, wacom->y = y);
+			input_report_abs(dev, ABS_X, x);
+			input_report_abs(dev, ABS_Y, y);
 
 			input_event(dev, EV_MSC, MSC_SERIAL, data[1] & 0x01);
 			return;
 	}
 
 	if (data[1] & 0x80) {
-		input_report_abs(dev, ABS_X, wacom->x = x);
-		input_report_abs(dev, ABS_Y, wacom->y = y);
+		input_report_abs(dev, ABS_X, x);
+		input_report_abs(dev, ABS_Y, y);
 	}
 
 	input_report_abs(dev, ABS_PRESSURE, data[6] | ((__u32)data[7] << 8));
@@ -236,7 +235,6 @@
 	struct input_dev *dev = &wacom->dev;
 	unsigned int t;
 	int idx;
-	int x, y; 
 
 	if (urb->status) return;
 
@@ -285,11 +283,8 @@
 		return;
 	}
 
-	x = ((__u32)data[2] << 8) | data[3];
-	y = ((__u32)data[4] << 8) | data[5];
-	
-	input_report_abs(dev, ABS_X, wacom->x);
-	input_report_abs(dev, ABS_Y, wacom->y);
+	input_report_abs(dev, ABS_X, ((__u32)data[2] << 8) | data[3]);
+	input_report_abs(dev, ABS_Y, ((__u32)data[4] << 8) | data[5]);
 	input_report_abs(dev, ABS_DISTANCE, data[9] >> 4);
 	
 	if ((data[1] & 0xb8) == 0xa0) {						/* general pen packet */
--- linux-2.4.19.old/include/linux/usb.h	Sat Aug  3 02:39:46 2002
+++ linux-2.4.19/include/linux/usb.h	Mon Nov 25 12:27:33 2002
@@ -16,8 +16,8 @@
 #define USB_CLASS_MASS_STORAGE		8
 #define USB_CLASS_HUB			9
 #define USB_CLASS_CDC_DATA		0x0a
-#define USB_CLASS_CSCID		0x0b /* chip+ smart card */
-#define USB_CLASS_CONTENT_SEC		0x0d /* content security */
+#define USB_CLASS_CSCID			0x0b	/* chip+ smart card */
+#define USB_CLASS_CONTENT_SEC		0x0d	/* content security */
 #define USB_CLASS_APP_SPEC		0xfe
 #define USB_CLASS_VENDOR_SPEC		0xff
 
@@ -42,8 +42,8 @@
 /*
  * USB directions
  */
-#define USB_DIR_OUT			0
-#define USB_DIR_IN			0x80
+#define USB_DIR_OUT			0		/* to device */
+#define USB_DIR_IN			0x80		/* to host */
 
 /*
  * Descriptor types
@@ -85,23 +85,23 @@
 /*
  * USB Packet IDs (PIDs)
  */
-#define USB_PID_UNDEF_0                        0xf0
-#define USB_PID_OUT                            0xe1
-#define USB_PID_ACK                            0xd2
-#define USB_PID_DATA0                          0xc3
-#define USB_PID_PING                           0xb4	/* USB 2.0 */
-#define USB_PID_SOF                            0xa5
-#define USB_PID_NYET                           0x96	/* USB 2.0 */
-#define USB_PID_DATA2                          0x87	/* USB 2.0 */
-#define USB_PID_SPLIT                          0x78	/* USB 2.0 */
-#define USB_PID_IN                             0x69
-#define USB_PID_NAK                            0x5a
-#define USB_PID_DATA1                          0x4b
-#define USB_PID_PREAMBLE                       0x3c	/* Token mode */
-#define USB_PID_ERR                            0x3c	/* USB 2.0: handshake mode */
-#define USB_PID_SETUP                          0x2d
-#define USB_PID_STALL                          0x1e
-#define USB_PID_MDATA                          0x0f	/* USB 2.0 */
+#define USB_PID_UNDEF_0			0xf0
+#define USB_PID_OUT			0xe1
+#define USB_PID_ACK			0xd2
+#define USB_PID_DATA0			0xc3
+#define USB_PID_PING			0xb4	/* USB 2.0 */
+#define USB_PID_SOF			0xa5
+#define USB_PID_NYET			0x96	/* USB 2.0 */
+#define USB_PID_DATA2			0x87	/* USB 2.0 */
+#define USB_PID_SPLIT			0x78	/* USB 2.0 */
+#define USB_PID_IN			0x69
+#define USB_PID_NAK			0x5a
+#define USB_PID_DATA1			0x4b
+#define USB_PID_PREAMBLE		0x3c	/* Token mode */
+#define USB_PID_ERR			0x3c	/* USB 2.0: handshake mode */
+#define USB_PID_SETUP			0x2d
+#define USB_PID_STALL			0x1e
+#define USB_PID_MDATA			0x0f	/* USB 2.0 */
 
 /*
  * Standard requests
@@ -152,13 +152,26 @@
 		mdelay(ms);
 }
 
-typedef struct {
-	__u8 requesttype;
-	__u8 request;
-	__u16 value;
-	__u16 index;
-	__u16 length;
-} devrequest __attribute__ ((packed));
+/**
+ * struct usb_ctrlrequest - structure used to make USB device control requests easier to create and decode
+ * @bRequestType: matches the USB bmRequestType field
+ * @bRequest: matches the USB bRequest field
+ * @wValue: matches the USB wValue field
+ * @wIndex: matches the USB wIndex field
+ * @wLength: matches the USB wLength field
+ *
+ * This structure is used to send control requests to a USB device.  It matches
+ * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
+ * USB spec for a fuller description of the different fields, and what they are
+ * used for.
+ */
+struct usb_ctrlrequest {
+	__u8 bRequestType;
+	__u8 bRequest;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+} __attribute__ ((packed));
 
 /*
  * USB-status codes:
@@ -174,10 +187,10 @@
 #define USB_ST_BUFFEROVERRUN	(-ECOMM)
 #define USB_ST_BUFFERUNDERRUN	(-ENOSR)
 #define USB_ST_INTERNALERROR	(-EPROTO) 			/* unknown error */
-#define USB_ST_SHORT_PACKET    	(-EREMOTEIO)
-#define USB_ST_PARTIAL_ERROR  	(-EXDEV)			/* ISO transfer only partially completed */
-#define USB_ST_URB_KILLED     	(-ENOENT)			/* URB canceled by user */
-#define USB_ST_URB_PENDING       (-EINPROGRESS)
+#define USB_ST_SHORT_PACKET	(-EREMOTEIO)
+#define USB_ST_PARTIAL_ERROR	(-EXDEV)			/* ISO transfer only partially completed */
+#define USB_ST_URB_KILLED	(-ENOENT)			/* URB canceled by user */
+#define USB_ST_URB_PENDING	(-EINPROGRESS)
 #define USB_ST_REMOVED		(-ENODEV) 			/* device not existing or removed */
 #define USB_ST_TIMEOUT		(-ETIMEDOUT)			/* communication timed out, also in urb->status**/
 #define USB_ST_NOTSUPPORTED	(-ENOSYS)			
@@ -385,7 +398,53 @@
 	unsigned long	driver_info;
 };
 
+/**
+ * struct usb_driver - identifies USB driver to usbcore
+ * @owner: Pointer to the module owner of this driver; initialize
+ *      it using THIS_MODULE.
+ * @name: The driver name should be unique among USB drivers,
+ *      and should normally be the same as the module name.
+ * @probe: Called to see if the driver is willing to manage a particular
+ *      interface on a device.  The probe routine returns a handle that 
+ *      will later be provided to disconnect(), or a null pointer to
+ *      indicate that the driver will not handle the interface.
+ *      The handle is normally a pointer to driver-specific data.
+ *      If the probe() routine needs to access the interface
+ *      structure itself, use usb_ifnum_to_if() to make sure it's using
+ *      the right one.
+ * @disconnect: Called when the interface is no longer accessible, usually
+ *      because its device has been (or is being) disconnected.  The
+ *      handle passed is what was returned by probe(), or was provided
+ *      to usb_driver_claim_interface().
+ * @ioctl: Used for drivers that want to talk to userspace through
+ *      the "usbfs" filesystem.  This lets devices provide ways to
+ *      expose information to user space regardless of where they
+ *      do (or don't) show up otherwise in the filesystem.
+ * @fops: pointer to a fops structure if the driver wants to use the USB
+ *	major number.
+ * @minor: the starting minor number for this driver, if the fops
+ *	pointer is set.
+ * @id_table: USB drivers use ID table to support hotplugging.
+ *      Export this with MODULE_DEVICE_TABLE(usb,...), or use NULL to
+ *      say that probe() should be called for any unclaimed interface.
+ *
+ * USB drivers must provide a name, probe() and disconnect() methods,
+ * and an id_table.  Other driver fields are optional.
+ *
+ * The id_table is used in hotplugging.  It holds a set of descriptors,
+ * and specialized data may be associated with each entry.  That table
+ * is used by both user and kernel mode hotplugging support.
+ * The probe() and disconnect() methods are called in a context where
+ * they can sleep, but they should avoid abusing the privilege.  Most
+ * work to connect to a device should be done when the device is opened,
+ * and undone at the last close.  The disconnect code needs to address
+ * concurrency issues with respect to open() and close() methods, as
+ * well as forcing all pending I/O requests to complete (by unlinking
+ * them as necessary, and blocking until the unlinks complete).
+ */
 struct usb_driver {
+	struct module *owner;
+
 	const char *name;
 
 	void *(*probe)(
@@ -402,18 +461,9 @@
 
 	struct semaphore serialize;
 
-	/* ioctl -- userspace apps can talk to drivers through usbdevfs */
 	int (*ioctl)(struct usb_device *dev, unsigned int code, void *buf);
 
-	/* support for "new-style" USB hotplugging
-	 * binding policy can be driven from user mode too
-	 */
 	const struct usb_device_id *id_table;
-
-	/* suspend before the bus suspends;
-	 * disconnect or resume when the bus resumes */
-	// void (*suspend)(struct usb_device *dev);
-	// void (*resume)(struct usb_device *dev);
 };
 	
 /*----------------------------------------------------------------------------* 
@@ -423,28 +473,31 @@
 /*
  * urb->transfer_flags:
  */
-#define USB_DISABLE_SPD         0x0001
-#define USB_ISO_ASAP            0x0002
-#define USB_ASYNC_UNLINK        0x0008
-#define USB_QUEUE_BULK          0x0010
+#define USB_DISABLE_SPD		0x0001
+#define URB_SHORT_NOT_OK	USB_DISABLE_SPD
+#define USB_ISO_ASAP		0x0002
+#define USB_ASYNC_UNLINK	0x0008
+#define USB_QUEUE_BULK		0x0010
 #define USB_NO_FSBR		0x0020
-#define USB_ZERO_PACKET         0x0040  // Finish bulk OUTs always with zero length packet
+#define USB_ZERO_PACKET		0x0040  // Finish bulk OUTs always with zero length packet
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
 					/* ... less overhead for QUEUE_BULK */
 #define USB_TIMEOUT_KILLED	0x1000	// only set by HCD!
 
-typedef struct
+struct iso_packet_descriptor
 {
 	unsigned int offset;
 	unsigned int length;		// expected length
 	unsigned int actual_length;
 	unsigned int status;
-} iso_packet_descriptor_t, *piso_packet_descriptor_t;
+};
+
+#define usb_iso_packet_descriptor	iso_packet_descriptor
 
 struct urb;
 typedef void (*usb_complete_t)(struct urb *);
 
-typedef struct urb
+struct urb
 {
 	spinlock_t lock;		// lock for the URB
 	void *hcpriv;			// private data for host controller
@@ -455,10 +508,12 @@
 	int status;			// returned status
 	unsigned int transfer_flags;	// USB_DISABLE_SPD | USB_ISO_ASAP | etc.
 	void *transfer_buffer;		// associated data buffer
+	dma_addr_t transfer_dma;	// dma addr for transfer_buffer
 	int transfer_buffer_length;	// data buffer length
 	int actual_length;              // actual data buffer length	
 	int bandwidth;			// bandwidth for this transfer request (INT or ISO)
 	unsigned char *setup_packet;	// setup packet (control only)
+	dma_addr_t setup_dma;		// dma addr for setup_packet
 	//
 	int start_frame;		// start frame (iso/irq only)
 	int number_of_packets;		// number of packets in this request (iso)
@@ -469,8 +524,8 @@
 	void *context;			// context for completion routine
 	usb_complete_t complete;	// pointer to completion routine
 	//
-	iso_packet_descriptor_t iso_frame_desc[0];
-} urb_t, *purb_t;
+	struct iso_packet_descriptor iso_frame_desc[0];
+};
 
 /**
  * FILL_CONTROL_URB - macro to help initialize a control urb
@@ -675,11 +730,11 @@
 	urb->start_frame = -1;
 }
 
-purb_t usb_alloc_urb(int iso_packets);
-void usb_free_urb (purb_t purb);
-int usb_submit_urb(purb_t purb);
-int usb_unlink_urb(purb_t purb);
-int usb_internal_control_msg(struct usb_device *usb_dev, unsigned int pipe, devrequest *cmd,  void *data, int len, int timeout);
+struct urb *usb_alloc_urb(int iso_packets);
+void usb_free_urb (struct urb *urb);
+int usb_submit_urb(struct urb *urb);
+int usb_unlink_urb(struct urb *urb);
+int usb_internal_control_msg(struct usb_device *usb_dev, unsigned int pipe, struct usb_ctrlrequest *cmd,  void *data, int len, int timeout);
 int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe, void *data, int len, int *actual_length, int timeout);
 
 /*-------------------------------------------------------------------*
@@ -710,6 +765,7 @@
  */
 struct usb_bus {
 	int busnum;			/* Bus number (in order of reg) */
+	char *bus_name;			/* stable id (PCI slot_name etc) */
 
 #ifdef DEVNUM_ROUND_ROBIN
 	int devnum_next;                /* Next open device number in round-robin allocation */
@@ -758,7 +814,8 @@
 #define USB_MAXCHILDREN		(16)
 
 struct usb_device {
-	int devnum;			/* Device number on USB bus */
+	int		devnum;		/* Address on USB bus */
+	char		devpath [16];	/* Use in messages: /port/port/... */
 
 	enum {
 		USB_SPEED_UNKNOWN = 0,			/* enumerating */
@@ -833,10 +890,6 @@
 extern void usb_inc_dev_use(struct usb_device *);
 #define usb_dec_dev_use usb_free_dev
 
-extern int usb_check_bandwidth (struct usb_device *dev, struct urb *urb);
-extern void usb_claim_bandwidth (struct usb_device *dev, struct urb *urb, int bustime, int isoc);
-extern void usb_release_bandwidth(struct usb_device *dev, struct urb *urb, int isoc);
-
 extern int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype, __u16 value, __u16 index, void *data, __u16 size, int timeout);
 
 extern int usb_root_hub_string(int id, int serial, char *type, __u8 *data, int len);
@@ -847,6 +900,42 @@
 
 int usb_get_current_frame_number (struct usb_device *usb_dev);
 
+
+/**
+ * usb_make_path - returns stable device path in the usb tree
+ * @dev: the device whose path is being constructed
+ * @buf: where to put the string
+ * @size: how big is "buf"?
+ *
+ * Returns length of the string (> 0) or negative if size was too small.
+ *
+ * This identifier is intended to be "stable", reflecting physical paths in
+ * hardware such as physical bus addresses for host controllers or ports on
+ * USB hubs.  That makes it stay the same until systems are physically
+ * reconfigured, by re-cabling a tree of USB devices or by moving USB host
+ * controllers.  Adding and removing devices, including virtual root hubs
+ * in host controller driver modules, does not change these path identifers;
+ * neither does rebooting or re-enumerating.  These are more useful identifiers
+ * than changeable ("unstable") ones like bus numbers or device addresses.
+ * (The stability of the id depends on stability of the bus_name associated
+ * with the bus the device uses; that is normally stable.)
+ *
+ * With a partial exception for devices connected to USB 2.0 root hubs, these
+ * identifiers are also predictable.  So long as the device tree isn't changed,
+ * plugging any USB device into a given hub port always gives it the same path.
+ * Because of the use of "companion" controllers, devices connected to ports on
+ * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
+ * high speed, and a different one if they are full or low speed.
+ */
+static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
+{
+	int actual;
+	actual = snprintf (buf, size, "usb-%s-%s",
+		dev->bus->bus_name, dev->devpath);
+	return (actual >= size) ? -1 : actual;
+}
+
+
 /*
  * Calling this entity a "pipe" is glorifying it. A USB pipe
  * is something embarrassingly simple: it basically consists
@@ -973,26 +1062,6 @@
 	__usb_get_extra_descriptor((ifpoint)->extra,(ifpoint)->extralen,type,(void**)ptr)
 
 /*
- * Some USB bandwidth allocation constants.
- */
-#define BW_HOST_DELAY	1000L		/* nanoseconds */
-#define BW_HUB_LS_SETUP	333L		/* nanoseconds */
-                        /* 4 full-speed bit times (est.) */
-
-#define FRAME_TIME_BITS         12000L		/* frame = 1 millisecond */
-#define FRAME_TIME_MAX_BITS_ALLOC	(90L * FRAME_TIME_BITS / 100L)
-#define FRAME_TIME_USECS	1000L
-#define FRAME_TIME_MAX_USECS_ALLOC	(90L * FRAME_TIME_USECS / 100L)
-
-#define BitTime(bytecount)  (7 * 8 * bytecount / 6)  /* with integer truncation */
-		/* Trying not to use worst-case bit-stuffing
-                   of (7/6 * 8 * bytecount) = 9.33 * bytecount */
-		/* bytecount = data payload byte count */
-
-#define NS_TO_US(ns)	((ns + 500L) / 1000L)
-			/* convert & round nanoseconds to microseconds */
-
-/*
  * Debugging helpers..
  */
 void usb_show_device_descriptor(struct usb_device_descriptor *);
