diff -aur --new-file linux-2.2.18-pre2-clean/Documentation/Configure.help linux-2.2.18-pre2-beos/Documentation/Configure.help
--- linux-2.2.18-pre2-clean/Documentation/Configure.help	Thu Aug 24 01:54:28 2000
+++ linux-2.2.18-pre2-beos/Documentation/Configure.help	Sat Sep  2 12:54:02 2000
@@ -7674,6 +7674,24 @@
 CONFIG_QNX4FS_RW
   Say Y if you want to test write support for QNX4 filesystems.
 
+BeOS filesystem support (EXPERIMENTAL)
+CONFIG_BEOS_FS
+  This is the filesystem used by the BeOS operating system. Say Y if
+  you want to get read access to file on BeOS partitions of your hard
+  drive or floppy disk.  
+
+  This filesystem support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module is called beos.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. 
+
+  If unsure, say N.
+
+Other platform BeOS fs support
+CONFIG_BEOS_CONV
+  Say Y if you want to use other platform BeOS (i.e. mount BeOS(ppc) on
+  Intel box).
+
 Kernel automounter support
 CONFIG_AUTOFS_FS
   The automounter is a tool to automatically mount remote filesystems
diff -aur --new-file linux-2.2.18-pre2-clean/fs/Config.in linux-2.2.18-pre2-beos/fs/Config.in
--- linux-2.2.18-pre2-clean/fs/Config.in	Thu Aug 24 01:54:28 2000
+++ linux-2.2.18-pre2-beos/fs/Config.in	Sat Sep  2 12:51:25 2000
@@ -47,6 +47,12 @@
     bool '   QNX4FS write support (DANGEROUS)' CONFIG_QNX4FS_RW
   fi    
 fi
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+  tristate 'BeOS filesystem support (read only) (EXPERIMENTAL)' CONFIG_BEOS_FS
+  if [ "$CONFIG_BEOS_FS" != "n" ]; then
+    bool '   BeOS other platform support' CONFIG_BEOS_CONV
+  fi    
+fi
 tristate 'ROM filesystem support' CONFIG_ROMFS_FS
 tristate 'Second extended fs support' CONFIG_EXT2_FS
 tristate 'System V and Coherent filesystem support' CONFIG_SYSV_FS
diff -aur --new-file linux-2.2.18-pre2-clean/fs/Makefile linux-2.2.18-pre2-beos/fs/Makefile
--- linux-2.2.18-pre2-clean/fs/Makefile	Thu Aug 24 01:54:28 2000
+++ linux-2.2.18-pre2-beos/fs/Makefile	Sat Sep  2 12:51:47 2000
@@ -18,7 +18,7 @@
 MOD_LIST_NAME := FS_MODULES
 ALL_SUB_DIRS = coda minix ext2 fat msdos vfat proc isofs nfs umsdos ntfs \
 		hpfs sysv smbfs ncpfs ufs affs romfs autofs hfs lockd \
-		nfsd nls devpts adfs qnx4 efs
+		nfsd nls devpts adfs qnx4 efs beos
 
 ifeq ($(CONFIG_QUOTA),y)
 O_OBJS += dquot.o
@@ -212,6 +212,14 @@
 else
   ifeq ($(CONFIG_QNX4FS_FS),m)
   MOD_SUB_DIRS += qnx4
+  endif
+endif
+
+ifeq ($(CONFIG_BEOS_FS),y)
+SUB_DIRS += beos
+else
+  ifeq ($(CONFIG_BEOS_FS),m)
+  MOD_SUB_DIRS += beos
   endif
 endif
 
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/COPYING linux-2.2.18-pre2-beos/fs/beos/COPYING
--- linux-2.2.18-pre2-clean/fs/beos/COPYING	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/COPYING	Thu May 20 05:41:55 1999
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                          675 Mass Ave, Cambridge, MA 02139, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/ChangeLog linux-2.2.18-pre2-beos/fs/beos/ChangeLog
--- linux-2.2.18-pre2-clean/fs/beos/ChangeLog	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/ChangeLog	Sat Sep  2 12:57:10 2000
@@ -0,0 +1,29 @@
+2000-09-02
+==========
+o Fixed nls conversion routines and changed type of lookup function to
+  dentry
+
+2000-08-16
+==========
+o Modified all to be called beos instead of bfs for future use with 2.4
+  kernels.
+o Mods to compile/work with 2.2.18-pre2 by Miles Lott <milos@insync.net>
+
+1999-05-25
+==========
+o Added BEOS(ppc) support.
+o Added LinuxPPC support.
+o Added nls (native language support).
+o Fixed using blocksize other than 1024 bytes.
+o Fixed memory leaks.
+o Fixed many bugs.
+
+1999-02-21
+==========
+o Added mount option "uid" and "gid".
+o Added symbolic link support.
+o Fixed many bugs.
+
+1999-02-14
+==========
+o Release first alpha version.
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/Makefile linux-2.2.18-pre2-beos/fs/beos/Makefile
--- linux-2.2.18-pre2-clean/fs/beos/Makefile	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/Makefile	Thu Aug 24 10:45:24 2000
@@ -0,0 +1,15 @@
+#
+# Makefile for the linux BEOS-filesystem routines.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile...
+
+O_TARGET := beos.o
+O_OBJS   := dir.o file.o inode.o namei.o super.o index.o debug.o symlink.o \
+            util.o
+M_OBJS   := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/README linux-2.2.18-pre2-beos/fs/beos/README
--- linux-2.2.18-pre2-clean/fs/beos/README	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/README	Thu Aug 24 10:45:24 2000
@@ -0,0 +1,87 @@
+BEOS filesystem for Linux  1999-05-28
+
+
+WARNING
+=======
+Make sure you understand that this is alpha software.  This means that the
+implementation is neither complete nor well-tested.  So using this driver,
+by own risk.
+
+
+WHAT'S THIS DRIVER
+==================
+This module is BEOS(filesystem of BeOS operating system) driver for Linux
+2.2.x / 2.3.x.  Current version supports BEOS(x86) and BEOS(ppc).
+
+
+HOW TO INSTALL
+==============
+step 1.  Install sources code to source code tree of linux.
+
+  i.e.
+    cd /usr/src/linux
+    tar ~/beos-YYYYMMDD.tar.gz
+    patch -p1 < linux-2.2.x.patch
+
+step 2.  Configuretion & make kernel
+
+  i.e. 
+    make config
+    make dep; make clean
+    make bzImage
+    make modules
+
+  Note that at 'BEOS Filesystem support', you should answer y(es) ori
+  m(odule).  If you want to use other platform BEOS, you should answer
+  y(es) aginst 'Other platform BEOS support'.
+
+step 3.  Install
+
+  i.e.
+    cp /usr/src/arch/i386/boot/zImage /vmlinuz
+    make modules_install
+
+
+USING BEOS
+=========
+To use the BEOS filesystem, use filesystem type 'beos'.
+
+ex)
+    mount -t beos -o type=x86,iocharset=iso8859-1 /dev/fd0 /beos
+
+
+MOUNT OPTIONS
+=============
+uid=nnn             All files in the partition will be owned by user id nnn.
+gid=nnn	            All files in the partition will be in group nnn.
+type=nnn            Set filesystem type.  nnn is x86 or ppc. Default value is
+                    platform depends (linux-x86 is x86, linux-ppc is ppc).
+iocharset=nnn       charactor-set. But not support DBCS.  
+
+
+KNOWLEDGE ISSUE
+===============
+o Current implement supports read-only.
+
+
+HOW TO GET LASTEST VERSION
+==========================
+The source and more information can be found in
+
+  http://hp.vector.co.jp/authors/VA008030/beos/
+
+
+SPECIAL THANKS
+==============
+Dominic Giampalo ... writing "Practical file system design with Be file
+                     system"
+Hiroyuki Yamada  ... testing LinuxPPC.
+
+
+AUTHOR
+======
+Makoto Kato <m_kato@ga2.so-net.ne.jp>
+
+MAINTAINER
+==========
+Miles Lott <milos@insync.net>
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/debug.c linux-2.2.18-pre2-beos/fs/beos/debug.c
--- linux-2.2.18-pre2-clean/fs/beos/debug.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/debug.c	Sat Aug 26 09:53:07 2000
@@ -0,0 +1,177 @@
+/*
+ *  linux/fs/beos/debug.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ * debug functions
+ */
+
+#include <stdarg.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+//#include <linux/beos_fs.h>
+
+#ifdef BEOS_DEBUG
+
+
+void beos_dump_inode (beos_inode * inode)
+{
+	int i, j;
+
+	printk (" beos_inode infomation\n");
+
+	for (i = 0; i < sizeof(beos_inode); i += 16) {
+		printk ("  %04x:", i);
+		for (j = 0; j < 16; j++) {
+			printk (" %02x", *(((char*) inode) + i + j) & 0xff);
+		}
+		printk ("\n");
+	}
+
+	printk ("  magic1 %08x\n", inode->magic1);
+	printk ("  inode_num %lu, %u %u\n", inode->inode_num.allocation_group,
+		inode->inode_num.start, inode->inode_num.len); 
+	printk ("  uid %lu\n", inode->uid);
+	printk ("  gid %lu\n", inode->gid);
+	printk ("  mode %08x\n", inode->mode);
+	printk ("  flags %08x\n", inode->flags);
+	printk ("  create_time %u\n", inode->create_time >> 8);
+	printk ("  last_modified_time %u\n", inode->last_modified_time >> 8);
+	printk ("  parent %lu, %u, %u\n", inode->parent.allocation_group,
+		inode->parent.start, inode->parent.len);
+	printk ("  attributes %lu, %u, %u\n",
+		inode->attributes.allocation_group,
+		inode->attributes.start, inode->attributes.len);
+	printk ("  type %08x\n", inode->type);
+	printk ("  inode_size %lu\n", inode->inode_size);
+
+	if (S_ISLNK(inode->mode)) {
+
+		/*
+		 * This is symbolic link.
+		 */
+
+		printk ("  Symbolic link [%s]\n", inode->data.symlink);
+	} else {
+		int i;
+
+		for (i = 0; i < BEOS_NUM_DIRECT_BLOCKS; i++) {
+			printk ("  direct %d [%lu, %u, %u]\n",
+				inode->data.datastream.direct[i].allocation_group,
+				inode->data.datastream.direct[i].start,
+				inode->data.datastream.direct[i].len);
+		}
+		printk ("  max_direct_range %Lu\n",
+			inode->data.datastream.max_direct_range);
+		printk ("  indirect [%lu, %u, %u]\n",
+			inode->data.datastream.indirect.allocation_group,
+			inode->data.datastream.indirect.start,
+			inode->data.datastream.indirect.len);
+		printk ("  max_indirect_range %016X\n",
+			inode->data.datastream.max_indirect_range);
+		printk ("  double indirect [%lu, %u, %u]\n",
+			inode->data.datastream.double_indirect.allocation_group,
+			inode->data.datastream.double_indirect.start,
+			inode->data.datastream.double_indirect.len);
+		printk ("  max_double_indirect_range %016X\n",
+			inode->data.datastream.max_double_indirect_range);
+		printk ("  size %016X\n",
+			inode->data.datastream.size);
+	}
+}
+
+
+/*
+ * Display super block structure for debug.
+ */
+
+void beos_dump_super_block (beos_super_block * bs)
+{
+	int i, j;
+
+	printk (" beos_super_block information\n");
+
+	for (i = 0; i < sizeof(beos_super_block); i += 16) {
+		printk ("  %04x:", i);
+		for (j = 0; j < 16; j++) {
+			printk (" %02x", *(((char*) bs) + i + j) & 0xff);
+		}
+		printk ("\n");
+	}
+
+	printk ("  name %s\n", bs->name);
+	printk ("  magic1 %08x\n", bs->magic1);
+	printk ("  fs_byte_order %08x\n", bs->fs_byte_order);
+
+	printk ("  block_size %lu\n", bs->block_size);
+	printk ("  block_shift %lu\n", bs->block_shift);
+
+	printk ("  num_blocks %016X\n", bs->num_blocks);
+	for (i = 0; i < sizeof(beos_off_t); i++) {
+		printk( " %02x", *(((char*) &bs->num_blocks) + i) & 0xff);
+	}
+	printk ("\n  used_blocks %016X\n", bs->used_blocks);
+
+	printk ("  magic2 %08x\n", bs->magic2);
+	printk ("  blocks_per_ag %lu\n", bs->blocks_per_ag);
+	printk ("  ag_shift %lu\n", bs->ag_shift);
+	printk ("  num_ags %lu\n", bs->num_ags);
+
+	printk ("  flags %08x\n", bs->flags);
+
+	printk ("  log_blocks %lu, %u, %u\n",
+		bs->log_blocks.allocation_group,
+		bs->log_blocks.start, bs->log_blocks.len);
+	printk ("  log_start %Ld\n", bs->log_start);
+	printk ("  log_end %Ld\n", bs->log_end);
+
+	printk ("  magic3 %08x\n", bs->magic3);
+	printk ("  root_dir %lu, %u, %u\n",
+		bs->root_dir.allocation_group, bs->root_dir.start,
+		bs->root_dir.len);
+	printk ("  indices %lu, %u, %u\n",
+		bs->indices.allocation_group, bs->indices.start,
+		bs->indices.len);
+}
+
+
+
+void beos_dump_small_data (beos_small_data * sd)
+{
+}
+
+
+
+void beos_dump_inode_addr (beos_inode_addr iaddr)
+{
+	printk (" inode addr [%lu, %u, %u]\n",
+		iaddr.allocation_group, iaddr.start, iaddr.len);
+}
+
+
+
+void beos_dump_index_entry (beos_index_entry * entry)
+{
+	printk (" index entry structure\n");
+	printk ("  magic %08x\n", entry->magic);
+	printk ("  node_size %lu\n", entry->node_size);
+	printk ("  max_number_of_levels %08x\n",
+		entry->max_number_of_levels);
+	printk ("  data_type %08x\n", entry->data_type);
+	printk ("  root_node_pointer %016X\n", entry->root_node_pointer);
+	printk ("  free_node_pointer %016X\n", entry->free_node_pointer);
+	printk ("  maximum size %016X\n", entry->maximum_size);
+}
+
+
+void beos_dump_index_node (beos_index_node * node)
+{
+	printk (" inode of index node structure\n");
+	printk ("  left %016X\n", node->left);
+	printk ("  right %016X\n", node->right);
+	printk ("  overflow %016X\n", node->overflow);
+	printk ("  all_key_count %u\n", node->all_key_count);
+	printk ("  all_key_length %u\n", node->all_key_length);
+}
+
+#endif
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/dir.c linux-2.2.18-pre2-beos/fs/beos/dir.c
--- linux-2.2.18-pre2-clean/fs/beos/dir.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/dir.c	Sat Sep  2 12:29:12 2000
@@ -0,0 +1,222 @@
+/*
+ *  linux/fs/beos/dir.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ *  from
+ *
+ *  linux/fs/minix/dir.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <asm/uaccess.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/mm.h>
+#include <linux/nls.h>
+
+
+static ssize_t beos_dir_read (struct file * filp, char * buf, size_t count,
+	loff_t *ppos)
+{
+	return -EISDIR;
+}
+
+
+static int beos_readdir(struct file *, void *, filldir_t);
+
+static struct file_operations beos_dir_operations = {
+	NULL,		/* lseek - default */
+	beos_dir_read,
+	NULL,		/* write - bad */
+	beos_readdir,
+	NULL,		/* poll - default */
+	NULL,		/* ioctl */
+	NULL,		/* mmap */
+	NULL,		/* no special open code */
+	NULL,		/* flush */
+	NULL,		/* no special release code */
+	file_fsync,
+	NULL,		/* fasync */
+	NULL,		/* check_media_change */
+	NULL		/* revalidate */
+};
+
+
+/*
+ * directories can handle most operations...
+ */
+
+struct inode_operations beos_dir_inode_operations = {
+	&beos_dir_operations,	/* default directory file-ops */
+	NULL,			/* create */
+	&beos_lookup,		/* lookup */
+	NULL,			/* link */
+	NULL,			/* unlink */
+	NULL,			/* symlink */
+	NULL,			/* mkdir */
+	NULL,			/* rmdir */
+	NULL,			/* mknod */
+	NULL,			/* rename */
+	NULL,			/* readlink */
+	NULL,			/* follow_link */
+	NULL,			/* readpage */
+	NULL,			/* writepage */
+	NULL,			/* bmap */
+	NULL,			/* truncate */
+	NULL,			/* permission */
+	NULL			/* smap */
+};
+
+
+/*
+ * description:
+ *  A directory structure of BEOS became index structure.
+ *
+ *  struct beos_index_node
+ *  {
+ *   off_t  left_link;
+ *   off_t  right_link;
+ *   off_t  overflow_link;
+ *   short  all_node_count;
+ *   short  all_key_length
+ *   byte   key_data[all_key_length]
+ *   short  key_index_count[all_node_count - 1]
+ *   off_t  values[all_node_count]
+ *  }
+ *
+ *  directry have above key.
+ *  [.] [..] [file and directry] ...
+ */
+
+static int beos_readdir(struct file * filp, void * dirent, filldir_t filldir)
+{
+	struct inode *       inode = filp->f_dentry->d_inode;
+	struct super_block * sb = inode->i_sb;
+	beos_inode_addr       iaddr;
+	char *               tmpname;
+	int                  error;
+	int                  count = 0;
+	int                  len;
+	beos_data_stream *    ds;
+	int                  pos = 0;
+
+	BEOS_OUTPUT (("---> beos_readdir() "
+		"inode %ld filp->f_pos %lu\n",
+		inode->i_ino, filp->f_pos));
+
+	if (!inode || !S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))
+		return -EBADF;
+
+	tmpname = (char *) __getname();
+	if (!tmpname)
+		return -ENOMEM;
+
+	ds = &inode->u.beos_i.i_data.ds;
+
+	while (pos >= 0) {
+
+		struct buffer_head * bh;
+		beos_index_node *     bn;
+		beos_off_t            value;
+		int                  flags;
+		int                  k;
+		beos_off_t            offset;
+		char *               tmpname2;
+		int                  len_dist;
+		
+		if (pos)
+			flags = 1;
+		else
+			flags = 0;
+
+		iaddr = beos_read_data_stream (sb, ds, &pos);
+		if (!pos || BEOS_IS_EMPTY_IADDR(&iaddr))
+			break;
+
+		/*
+		 * read index node
+		 */
+
+		bh = beos_read_index_node (iaddr, sb, flags, &offset);
+		if (!bh) {
+
+			BEOS_OUTPUT (("<--- beos_readdir() "
+				"cannot read index node\n"));
+			return -EBADF;
+
+		}
+
+		bn = (beos_index_node *) (bh->b_data + offset);
+		BEOS_DUMP_INDEX_NODE (bn);
+
+		/*
+		 * Is there no directry key in this index node?
+		 */
+
+		if (bn->all_key_count + count <= filp->f_pos) {
+
+			/*
+			 * Not exist
+			 */
+
+			BEOS_OUTPUT (("key not exist. next...\n"));
+			count += bn->all_key_count;
+			brelse (bh);
+			continue;
+
+		}
+
+		k = filp->f_pos - count;
+
+		/*
+		 * search key
+		 */
+
+		if (!beos_get_key_from_index_node (bn, &k,
+			sb->u.beos_sb.mount_opts.beos_type, tmpname, &len,
+			&value)) {
+
+			putname (tmpname);
+			brelse (bh);
+
+			return -EBADF;
+		}
+
+		/*
+		 * Convert UTF-8 to nls charset
+		 */
+
+		if (!beos_utf2nls (tmpname, len, &tmpname2, &len_dist, sb)) {
+			putname (tmpname);
+			brelse (bh);
+
+			return -ENOMEM;
+		}
+		error = filldir (dirent, tmpname2, len_dist, filp->f_pos,
+			(ino_t) value);
+		putname (tmpname2);
+
+		if (error)
+			filp->f_pos = 0;
+		else
+			filp->f_pos++;
+
+		brelse (bh);
+
+		goto finish;
+	}
+
+	filp->f_pos = 0;
+finish:
+	putname (tmpname);
+
+	BEOS_OUTPUT (("<--- beos_readdir() filp->f_pos %d\n",
+		filp->f_pos));
+
+	return 0;
+}
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/file.c linux-2.2.18-pre2-beos/fs/beos/file.c
--- linux-2.2.18-pre2-clean/fs/beos/file.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/file.c	Thu Aug 24 10:45:24 2000
@@ -0,0 +1,452 @@
+/*
+ *  linux/fs/beos/file.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ *  from
+ *
+ *  linux/fs/minix/file.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/beos_fs.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/locks.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+
+
+ssize_t beos_file_read (struct file *, char *,  size_t, loff_t *);
+static beos_inode_addr beos_startpos_from_ds (struct super_block *,
+	beos_data_stream *, off_t);
+static int beos_read_indirect_block (struct super_block *, const beos_inode_addr,
+	const int, beos_inode_addr *);
+static int beos_read_double_indirect_block (struct super_block *,
+	const beos_inode_addr, const int, beos_inode_addr *);
+static ssize_t beos_file_write (struct file *, const char *, size_t, loff_t *);
+
+
+static struct file_operations beos_file_ops =
+{
+	NULL,			/* lseek */
+	beos_file_read,
+#ifdef CONFIG_BEOS_FS_RW
+	beos_file_write,
+#else
+	NULL,
+#endif
+	NULL,			/* readdir - bad */
+	NULL,			/* poll - default */
+	NULL,			/* ioctl - default */
+	generic_file_mmap,
+	NULL,
+	NULL,			/* flush */
+	NULL,			/* release */
+	file_fsync,
+};
+
+struct inode_operations beos_file_inode_operations =
+{
+	&beos_file_ops,		/* default file operations */
+	NULL,					/* create */
+	NULL,					/* lookup */
+	NULL,					/* link */
+	NULL,					/* unlink */
+	NULL,					/* symlink */
+	NULL,					/* mkdir */
+	NULL,					/* rmdir */
+	NULL,					/* mknod */
+	NULL,					/* rename */
+	NULL,					/* readlink */
+	NULL,					/* follow_link */
+	generic_readpage,	/* readpage */
+	NULL,					/* writepage */
+	&beos_bmap,		/* bmap */
+	NULL,					/* truncate */
+	NULL,					/* permission */
+	NULL					/* smap */
+};
+
+
+ssize_t beos_file_read(struct file *filp, char *buf,  size_t count, loff_t *ppos)
+{
+	struct inode *       inode = filp->f_dentry->d_inode;
+	struct super_block * sb = inode->i_sb;
+	beos_data_stream *    ds = &inode->u.beos_i.i_data.ds;
+	beos_inode_addr       iaddr;
+	beos_inode_addr       iaddr2;
+	off_t                pos = *ppos;
+	off_t                sum = 0;
+	int                  i;
+	int                  j;
+	off_t                read_count;
+	off_t                offset;
+
+	BEOS_OUTPUT (("---> beos_file_read() "
+		"inode %lu count %lu ppos %Lu\n",
+		inode->i_ino, (__u32) count, *ppos));
+
+	/*
+	 * Get start position
+	 */
+
+	for (i = 0; ;) {
+		iaddr = beos_read_data_stream (sb, ds, &i);
+		if (BEOS_IS_EMPTY_IADDR(&iaddr)) {
+			BEOS_OUTPUT ((" end data_stream\n"));
+			break;
+		}
+
+		if ((pos >= sum)
+			&& (pos < sum + iaddr.len * sb->u.beos_sb.block_size)) {
+
+			iaddr.start += (pos - sum) / sb->u.beos_sb.block_size;
+			iaddr.len -= (pos - sum) / sb->u.beos_sb.block_size;
+			break;
+		}
+		sum += iaddr.len * sb->u.beos_sb.block_size;
+	}
+
+	read_count = 0;
+	offset = (pos - sum) % sb->u.beos_sb.block_size;
+	iaddr2 = iaddr;
+
+	count = inode->i_size > pos + count ? count : inode->i_size - pos;
+
+	for ( j = 0; j < iaddr.len; j++) {
+
+		struct buffer_head * bh;
+
+		bh = beos_bread2 (sb, iaddr2);
+		if (!bh)
+			return -EBADF;
+
+		BEOS_OUTPUT ((" read_count %Ld offset %Ld\n",
+			read_count, offset));
+
+		if (count > sb->u.beos_sb.block_size) {
+
+			memcpy (buf + read_count, bh->b_data + offset,
+				sb->u.beos_sb.block_size - offset);
+
+			*ppos += sb->u.beos_sb.block_size - offset;
+			count -= sb->u.beos_sb.block_size - offset;
+			read_count += sb->u.beos_sb.block_size - offset;
+			offset = 0;
+
+			iaddr2.start += 1;
+
+			brelse (bh);
+
+		} else {
+
+			memcpy (buf + read_count, bh->b_data + offset, count);
+
+			*ppos += count;
+			read_count += count;
+	
+			brelse (bh);
+			break;
+		}
+	}
+
+	ppos += read_count;
+
+	BEOS_OUTPUT (("<--- beos_file_read() "
+		"return value %d, ppos %Ld\n", read_count, *ppos));
+
+	return read_count;
+}
+
+/*
+ * Read indirect block
+ */
+
+static int beos_read_indirect_block (struct super_block * sb,
+	const beos_inode_addr indirect, const int pos, 
+	beos_inode_addr * iaddr)
+{
+	beos_inode_addr *     array;
+	struct buffer_head * bh;
+	beos_inode_addr       addr = indirect;
+	int                  p = pos;
+
+	BEOS_OUTPUT (("---> beos_read_indirect_block()\n"));
+
+	/*
+	 * explore nessealy block
+	 */
+
+	addr.start += p / BEOS_BLOCK_PER_INODE(sb);
+	addr.len -= p / BEOS_BLOCK_PER_INODE(sb);
+
+	if (addr.len < 1) {
+		goto error;
+	}
+
+	p = p % BEOS_BLOCK_PER_INODE(sb);
+
+	bh = beos_bread2 (sb, addr);
+	if (!bh) {
+		goto error;
+	}
+
+	array = (beos_inode_addr *) bh->b_data;
+
+	/*
+	 * Is this block inode address??
+	 */
+
+	if (!BEOS_IS_EMPTY_IADDR(&array[p % BEOS_BLOCK_PER_INODE(sb)])) {
+		*iaddr = array[p % BEOS_BLOCK_PER_INODE(sb)];
+	} else {
+		brelse (bh);
+		goto error;
+	}
+
+	brelse (bh);
+
+	BEOS_OUTPUT (("<--- beos_read_indirect_block()\n"));
+
+	return 0;
+
+error:
+	printk ("BEOS: cannot read indirect block\n");
+	return -EBADF;
+}
+
+/*
+ * beos_read_double_indirect_block
+ *
+ * description:
+ *  Read double-indirect block
+ *
+ * parameter:
+ *  sb              ... super block
+ *  double_indirect ... inode address of double-indirect block
+ *  pos             ... position of double-indirect block
+ *                       (*pos - max_direct_block - max_indirect_block)
+ *
+ * return value:
+ *  0 ... sucess
+ */
+
+static int beos_read_double_indirect_block (struct super_block * sb,
+        const beos_inode_addr double_indirect, const int pos,
+	beos_inode_addr * iaddr)
+{
+        struct buffer_head *  bh_indirect;
+        int                   p = pos;
+        beos_inode_addr *      indirects;
+	beos_inode_addr        addr = double_indirect;
+	int                   i;
+
+	BEOS_OUTPUT (("---> beos_read_double_indirect_block() \n"));
+
+        while (addr.len) {
+                bh_indirect = beos_bread2 (sb, addr);
+
+                if (!bh_indirect) {
+                        BEOS_OUTPUT (("cannot read double-indirect block "
+                                "[%lu, %u, %u]\n",
+                                double_indirect.allocation_group,
+                                double_indirect.start, double_indirect.len));
+                        return -EBADF;
+                }
+
+                addr.start++;
+                addr.len--;
+
+                indirects = (beos_inode_addr *) bh_indirect->b_data;
+
+                for (i = 0; i < BEOS_BLOCK_PER_INODE(sb); i++) {
+
+                        if (p < indirects[i].len * BEOS_BLOCK_PER_INODE(sb)) {
+
+                                /*
+                                 * find block!
+                                 */
+
+				int err;
+
+				err = beos_read_indirect_block (sb,
+					indirects[i], p, iaddr);
+				brelse (bh_indirect);
+
+				return err;
+                        }
+
+                        p -= indirects[i].len * BEOS_BLOCK_PER_INODE(sb);
+                }
+
+                brelse(bh_indirect);
+        }
+
+        /*
+         * cannot find block...
+         */
+
+        BEOS_OUTPUT (("cannot find block...\n"));
+
+        return -EIO;
+}
+
+
+beos_inode_addr beos_read_data_stream (struct super_block * sb,
+	beos_data_stream * ds, int * pos)
+{
+        beos_inode_addr       iaddr = {0, 0, 0};
+
+	BEOS_OUTPUT (("---> beos_read_data_stream() "
+		"pos %d\n", *pos));
+
+        if( *pos < 0 )
+                return iaddr;
+
+        if (*pos < ds->max_direct_range) {
+
+		/*
+		 * This position is in direct block.
+		 */
+
+		BEOS_OUTPUT ((" read in direct block [%lu, %u, %u]\n",
+			ds->direct[*pos].allocation_group,
+			ds->direct[*pos].start, ds->direct[*pos].len));
+
+		/*
+		 * Is this block inode address??
+		 */
+
+                if (!BEOS_IS_EMPTY_IADDR(&ds->direct[*pos])) {
+			iaddr = ds->direct[(*pos)++];
+		}
+        } else if (*pos < ds->max_indirect_range + ds->max_direct_range) {
+
+		/*
+		 * This position is in in-direct block.
+		 */
+
+		int  p = *pos - ds->max_direct_range;
+		
+		BEOS_OUTPUT ((" read in indirect block [%lu, %u, %u]\n",
+			ds->indirect.allocation_group, ds->indirect.start,
+			ds->indirect.len));
+
+		if (!beos_read_indirect_block (sb, ds->indirect, p, &iaddr)) {
+			(*pos)++;
+		} 
+        } else if (*pos < ds->max_double_indirect_range
+		+ ds->max_direct_range + ds->max_indirect_range) {
+
+		/*
+		 * This position is in double-in-direct block.
+		 */
+
+		int  p = *pos - ds->max_direct_range - ds->max_indirect_range;
+
+		BEOS_OUTPUT ((" read in double indirect block\n"));
+
+		if (!beos_read_double_indirect_block (sb, ds->double_indirect,
+			p, &iaddr)) {
+
+			(*pos)++;
+		} 
+        } else {
+		/*
+		 * out of range block
+		 */
+	}
+
+	if (BEOS_IS_EMPTY_IADDR(&iaddr))
+		*pos = 0;
+
+        return iaddr;
+}
+
+/*
+ * Get inode address of start position form data stream
+ */
+
+static beos_inode_addr beos_startpos_from_ds (struct super_block * sb,
+					beos_data_stream * ds, off_t pos)
+{
+	beos_inode_addr iaddr;
+	off_t          sum = 0;
+	int            i = 0;
+
+	BEOS_OUTPUT (("---> beos_startpos_from_ds()\n"));
+
+	/*
+	 * Get start position
+	 */
+
+	while(1) {
+		iaddr = beos_read_data_stream (sb, ds, &i);
+		if (BEOS_IS_EMPTY_IADDR(&iaddr)) {
+			BEOS_OUTPUT ((" end data_stream\n"));
+			break;
+		}
+
+		if ((pos >= sum)
+			&& (pos < sum + iaddr.len * sb->u.beos_sb.block_size)) {
+			iaddr.start += (pos - sum) / sb->u.beos_sb.block_size;
+			iaddr.len -= (pos - sum) / sb->u.beos_sb.block_size;
+			break;
+		}
+		sum += iaddr.len * sb->u.beos_sb.block_size;
+	}
+
+	BEOS_OUTPUT (("<--- beos_startpos_from_ds()\n"));
+
+	return iaddr;
+}
+
+#ifdef CONFIG_BEOS_RW 
+static ssize_t beos_file_write (struct file * filp, const char * buf,
+                                size_t count, loff_t *ppos)
+{
+	struct inode *       inode = filp->f_dentry->d_inode;
+	struct super_block * sb;
+//	struct buffer_head * bh;
+	beos_data_stream *    ds;
+	beos_inode_addr       iaddr;
+	loff_t               pos;
+	ssize_t              written;
+
+	if (!inode) {
+		return -EINVAL;
+	}
+
+	if (!S_ISREG(inode->i_mode)) {
+		return -EINVAL;
+	}
+
+	sb = inode->i_sb;
+	ds = &inode->u.beos_i.i_data.ds;
+
+	if (filp->f_flags & O_APPEND)
+		pos = inode->i_size;
+	else
+		pos = *ppos;
+
+	iaddr = beos_startpos_from_ds (sb, ds, pos);
+	written = 0;
+
+	if (pos > inode->i_size)
+		inode->i_size = pos;
+
+	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	*ppos = pos;
+	mark_inode_dirty(inode);
+
+	return written;
+}
+#endif
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/index.c linux-2.2.18-pre2-beos/fs/beos/index.c
--- linux-2.2.18-pre2-clean/fs/beos/index.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/index.c	Mon Aug 28 18:20:44 2000
@@ -0,0 +1,321 @@
+/*
+ *  linux/beos/fs/index.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ *
+ *  Index functions for BEOS.
+ */
+
+#include <asm/uaccess.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+
+
+static void beos_convert_index_entry (int, beos_index_entry *, beos_index_entry *);
+static void beos_convert_index_node (int, beos_index_node *, beos_index_node *);
+
+/*
+ * Convert little-edian and big-edian.
+ */
+
+static void beos_convert_index_entry (int fstype, beos_index_entry * entry,
+	beos_index_entry * out)
+{
+	switch (fstype)
+	{
+	case BEOS_X86:
+		out->magic = le32_to_cpu(entry->magic);
+		out->node_size = le32_to_cpu(entry->node_size);
+		out->max_number_of_levels =
+			le32_to_cpu(entry->max_number_of_levels);
+		out->data_type = le32_to_cpu(entry->data_type);
+		out->root_node_pointer =
+			le64_to_cpu(entry->root_node_pointer);
+		out->free_node_pointer =
+			le64_to_cpu(entry->free_node_pointer);
+		out->maximum_size = le64_to_cpu(entry->maximum_size);
+		break;
+
+	case BEOS_PPC:
+		out->magic = be32_to_cpu(entry->magic);
+		out->node_size = be32_to_cpu(entry->node_size);
+		out->max_number_of_levels =
+			be32_to_cpu(entry->max_number_of_levels);
+		out->data_type = be32_to_cpu(entry->data_type);
+		out->root_node_pointer =
+			be64_to_cpu(entry->root_node_pointer);
+		out->free_node_pointer =
+			be64_to_cpu(entry->free_node_pointer);
+		out->maximum_size = be64_to_cpu(entry->maximum_size);
+		break;
+	}
+}
+
+
+static void beos_convert_index_node (int fstype, beos_index_node * node,
+	beos_index_node * out)
+{
+	switch (fstype)
+	{
+	case BEOS_X86:
+		out->left = le64_to_cpu (node->left);
+		out->right = le64_to_cpu (node->right);
+		out->overflow = le64_to_cpu (node->overflow);
+		out->all_key_count = le16_to_cpu (node->all_key_count);
+		out->all_key_length = le16_to_cpu (node->all_key_length);
+		break;
+
+	case BEOS_PPC:
+		out->left = be64_to_cpu (node->left);
+		out->right = be64_to_cpu (node->right);
+		out->overflow = be64_to_cpu (node->overflow);
+		out->all_key_count = be16_to_cpu (node->all_key_count);
+		out->all_key_length = be16_to_cpu (node->all_key_length);
+		break;
+	}
+}
+
+
+/*
+ * beos_read_index_node
+ *
+ * description:
+ *  read index node from inode.
+ *
+ * parameter:
+ *  inode  ... address of index node
+ *  sb     ... super block
+ *  flags  ... 0 ... inode is index entry
+ *             1 ... inode is index node
+ *  offset ... offset into index address
+ */
+
+struct buffer_head * beos_read_index_node (beos_inode_addr inode,
+	struct super_block * sb, int flags, beos_off_t * offset)
+{
+	struct buffer_head * bh;
+	beos_inode_addr       iaddr;
+	beos_index_entry *    entry;
+
+	BEOS_OUTPUT (("---> beos_read_index_node() "
+		"index [%lu, %u, %u]\n",
+		inode.allocation_group, inode.start, inode.len));
+
+	if (!flags) {
+
+		/*
+		 * read index entry
+		 */
+
+		bh = beos_bread2 (sb, inode);
+		if (!bh) {
+			printk (KERN_ERR "BEOS: cannot read index entry.\n");
+			return NULL;
+		}
+#ifndef CONFIG_BEOS_CONV
+		entry = (beos_index_entry *) bh->b_data;
+#else
+		entry = (beos_index_entry *) __getname();;
+		if (!entry) {
+			printk (KERN_ERR "BEOS: cannot allocate memory\n");
+			return NULL;
+		}
+
+		/*
+		 * Convert little-edian and big-edian.
+		 */
+
+		beos_convert_index_entry (sb->u.beos_sb.mount_opts.beos_type,
+			(beos_index_entry *) bh->b_data, entry);
+#endif
+		BEOS_DUMP_INDEX_ENTRY (entry);
+
+		/*
+		 * check magic header
+		 */
+
+		if (entry->magic != BEOS_INDEX_MAGIC) {
+
+			/*
+			 * bad magic header
+			 */
+
+			printk (KERN_ERR "BEOS: "
+				"magic header of index entry is bad value.\n");
+#ifdef CONFIG_BEOS_CONV
+			putname (entry);
+#endif
+			brelse(bh);
+
+			return NULL;
+		}
+
+		/*
+		 * set index entry postion
+		 */
+
+		*offset = 0;
+		iaddr = inode;
+		if (entry->node_size < sb->u.beos_sb.block_size) {
+
+			/*
+			 * exist index node into index entry's block
+			 */
+
+			*offset = entry->node_size;
+
+		} else {
+
+			iaddr.start += entry->node_size / sb->u.beos_sb.block_size;
+			iaddr.len -= entry->node_size / sb->u.beos_sb.block_size;
+			*offset = entry->node_size % sb->u.beos_sb.block_size;
+
+		}
+
+#ifdef CONFIG_BEOS_CONV
+		putname (entry);
+#endif
+		brelse(bh);
+
+	} else {
+		BEOS_OUTPUT ((" skip index node\n"));
+		iaddr = inode;
+	}
+
+	BEOS_OUTPUT ((" inode of index node\n"));
+	BEOS_DUMP_INODE_ADDR (iaddr);
+
+	bh = beos_bread2 (sb, iaddr);
+	if (!bh) {
+		return NULL;
+	}
+
+	BEOS_OUTPUT (("<--- beos_read_index_node() offset = %016x\n", *offset));
+
+	return bh;
+}
+
+
+/*
+ * beos_get_key_from_index_node
+ *
+ * description:
+ *  Get key form index node
+ *
+ *  parameter:
+ *   bn     ... index node structure
+ *   pos    ... key position
+ *   fstype ... filesystem type
+ *   name   ... keyname return
+ *   len    ... length of keyname return.
+ *   iaddr  ... key valude return.
+ */
+
+char * beos_get_key_from_index_node (beos_index_node * node, int *pos, int fstype,
+	char * name, int * len, beos_off_t * iaddr)
+{
+	char *           key;
+	__u16 *          key_array;
+	beos_off_t *      key_value;
+	int              key_offset;
+	char *           namep = NULL;
+	beos_index_node * bn;
+
+	BEOS_OUTPUT (("---> beos_get_key_from_index_node() "
+		"pos %d\n", *pos));
+
+	/*
+	 * Convert little-edian and big-edian.
+	 */
+#ifndef CONFIG_BEOS_CONV
+	bn = node;
+#else
+	bn = (beos_index_node *) __getname();
+	beos_convert_index_node (fstype, node, bn);
+#endif
+
+	if (*pos < 0 || bn->all_key_count <= *pos) {
+		*pos = -1;
+		return NULL;
+	}
+
+	/*
+	 * Only key_array, byte is 8byte...
+	 */
+
+	key = (char*) node + sizeof(beos_index_node);
+	key_offset = (bn->all_key_length + sizeof(beos_index_node)) % 8;
+	key_array = (__u16 *) (key + bn->all_key_length
+		+ (!key_offset ? 0 : 8 - key_offset));
+	key_value = (beos_inode_addr *) (((char *) key_array) + sizeof(__u16)
+		* bn->all_key_count);
+#ifdef BEOS_DEBUG
+	{
+		int j;
+		char key_test[4096];
+
+		memcpy (key_test, key, bn->all_key_length);
+		key_test[bn->all_key_length] = '\0';
+
+		BEOS_OUTPUT ((" key %08x key_array %08x key_value %08x\n",
+			(long) key, (long) key_array, (long) key_value));
+
+		BEOS_OUTPUT ((" key content %s\n", key_test));
+
+		for (j = 0; j < *pos; j++) {
+			BEOS_OUTPUT ((" key_array[%d] = %Ld  ",
+				j, key_array[j]));
+			BEOS_OUTPUT (("key_value[%d] = %Ld\n", j, key_value[j]));
+		}
+	}
+#endif
+	switch (fstype)
+	{
+	case BEOS_X86:
+		if (*pos == 0) {
+			namep = key;
+			*len = le16_to_cpu(key_array[*pos]);
+		} else {
+			namep = key + le16_to_cpu(key_array[*pos - 1]);
+			*len = le16_to_cpu(key_array[*pos])
+				- le16_to_cpu(key_array[*pos - 1]);
+		}
+		*iaddr = le64_to_cpu(key_value[*pos]);
+		break;
+
+	case BEOS_PPC:
+		if (*pos == 0) {
+			namep = key;
+			*len = be16_to_cpu(key_array[*pos]);
+		} else {
+			namep = key + be16_to_cpu(key_array[*pos - 1]);
+			*len = be16_to_cpu(key_array[*pos])
+				- be16_to_cpu(key_array[*pos - 1]);
+		}
+		*iaddr = be64_to_cpu(key_value[*pos]);
+		break;
+	}
+
+	/*
+	 * copy from namep to name
+	 */
+
+	memcpy (name, namep, *len);
+	name[*len] = '\0';
+	(*pos)++;
+
+#ifdef CONFIG_BEOS_CONV
+	putname (bn);
+#endif
+
+	BEOS_OUTPUT (("<--- beos_get_key_from_index_node() "
+		"result key [%s], value %Lu\n", name, *iaddr));
+
+	return name;
+}
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/inode.c linux-2.2.18-pre2-beos/fs/beos/inode.c
--- linux-2.2.18-pre2-clean/fs/beos/inode.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/inode.c	Sun Aug 27 21:36:39 2000
@@ -0,0 +1,464 @@
+/*
+ *  linux/fs/beos/inode.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ *  from
+ *
+ *  linux/fs/minix/inode.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+//#include <linux/beos_fs.h>
+#include <linux/beos_fs_sb.h>
+#include <linux/beos_fs_i.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/locks.h>
+#include <linux/mm.h>
+
+
+//static int beos_update_inode(struct inode *, int);
+
+/*
+ * return blocknumber
+ */
+
+int beos_bmap (struct inode * inode, int block)
+{
+	struct beos_sb_info    bs = inode->i_sb->u.beos_sb;
+	struct beos_inode_info bi = inode->u.beos_i;
+
+	BEOS_OUTPUT (("---> Enter beos_bmap\n"));
+
+	BEOS_OUTPUT (("<--- Enter beos_bmap\n"));
+
+	return  (bi.i_inode_num.allocation_group << bs.ag_shift)
+		+ bi.i_inode_num.start;
+}
+
+
+/*
+ * beos_bread function
+ *
+ *  get buffer_header for inode.
+ */
+
+struct buffer_head * beos_bread (struct inode * inode)
+{
+	beos_off_t             offset;
+	struct super_block *  sb = inode->i_sb;
+	dev_t                 dev = sb->s_dev;
+
+	BEOS_OUTPUT (("---> Enter beos_read "
+		"[%lu, %u, %u]\n",
+		inode->u.beos_i.i_inode_num.allocation_group,
+		inode->u.beos_i.i_inode_num.start,
+		inode->u.beos_i.i_inode_num.len));
+
+	offset = (inode->u.beos_i.i_inode_num.allocation_group
+		<< sb->u.beos_sb.ag_shift) + inode->u.beos_i.i_inode_num.start;
+
+	BEOS_OUTPUT (("<--- Enter beos_read\n"));
+
+	return bread (dev, offset, sb->s_blocksize);
+}
+
+
+struct buffer_head * beos_bread2 (struct super_block * sb, beos_inode_addr inode)
+{
+	dev_t     dev = sb->s_dev;
+	beos_off_t offset;
+
+	BEOS_OUTPUT (("---> Enter beos_read2 "
+		"[%lu, %u, %u]\n",
+		inode.allocation_group, inode.start, inode.len));
+
+	offset = (inode.allocation_group << sb->u.beos_sb.ag_shift)
+		+ inode.start;
+	
+	BEOS_OUTPUT (("<--- Enter beos_read2\n"));
+
+	return bread (dev, offset, sb->s_blocksize);
+}
+
+
+/*
+ * Convert little-endian and big-endian
+ */
+
+void beos_convert_inodeaddr (int fstype, beos_inode_addr * iaddr,
+	beos_inode_addr * out)
+{
+	switch (fstype)
+	{
+	case BEOS_X86:
+		out->allocation_group = le32_to_cpu(iaddr->allocation_group);
+		out->start = le16_to_cpu(iaddr->start);
+		out->len = le16_to_cpu(iaddr->len);
+		break;
+
+	case BEOS_PPC:
+		out->allocation_group = be32_to_cpu(iaddr->allocation_group);
+		out->start = be16_to_cpu(iaddr->start);
+		out->len = be16_to_cpu(iaddr->len);
+		break;
+	}
+}
+
+static void beos_convert_inode (int fstype, beos_inode *inode, beos_inode * out)
+{
+	int i;
+
+	/*
+	 * Convert data stream.
+	 */
+
+	switch (fstype)
+	{
+	case BEOS_X86:
+		out->magic1 = le32_to_cpu(inode->magic1);
+		beos_convert_inodeaddr (fstype, &inode->inode_num,
+			&out->inode_num);
+		out->uid = le32_to_cpu(inode->uid);
+		out->gid = le32_to_cpu(inode->gid);
+		out->mode = le32_to_cpu(inode->mode);
+		out->flags = le32_to_cpu(inode->flags);
+		out->create_time = le64_to_cpu(inode->create_time);
+		out->last_modified_time =
+			le64_to_cpu(inode->last_modified_time);
+		inode->type = le32_to_cpu(inode->type);
+		beos_convert_inodeaddr (fstype, &inode->parent, &out->parent);
+		beos_convert_inodeaddr (fstype, &inode->attributes, &out->attributes);
+		out->inode_size = le32_to_cpu(inode->inode_size);
+
+		if (!S_ISLNK((umode_t) out->mode)) {
+			/*
+			 * Convert data stream.
+			 */
+
+			for ( i = 0; i < BEOS_NUM_DIRECT_BLOCKS; i++) {
+				beos_convert_inodeaddr (fstype,
+					&inode->data.datastream.direct[i],
+					&out->data.datastream.direct[i]);
+			}
+			beos_convert_inodeaddr (fstype,
+				&inode->data.datastream.indirect,
+				&out->data.datastream.indirect);
+			beos_convert_inodeaddr (fstype,
+				&inode->data.datastream.double_indirect,
+				&out->data.datastream.double_indirect);
+	
+			out->data.datastream.max_direct_range =
+				le64_to_cpu(inode->data.datastream.max_direct_range);
+			out->data.datastream.max_indirect_range =
+				le64_to_cpu(inode->data.datastream.max_indirect_range);
+			out->data.datastream.max_double_indirect_range =
+				le64_to_cpu(inode->data.datastream.max_double_indirect_range);
+			out->data.datastream.size =
+				le64_to_cpu(inode->data.datastream.size);
+		}
+		break;
+
+	case BEOS_PPC:
+		out->magic1 = be32_to_cpu(inode->magic1);
+		beos_convert_inodeaddr (fstype, &inode->inode_num, &out->inode_num);
+		out->uid = be32_to_cpu(inode->uid);
+		out->gid = be32_to_cpu(inode->gid);
+		out->mode = be32_to_cpu(inode->mode);
+		out->flags = be32_to_cpu(inode->flags);
+		out->create_time = be64_to_cpu(inode->create_time);
+		out->last_modified_time =
+			be64_to_cpu(inode->last_modified_time);
+		out->type = be32_to_cpu(inode->type);
+		beos_convert_inodeaddr (fstype, &inode->parent, &out->parent);
+		beos_convert_inodeaddr (fstype, &inode->attributes, &out->attributes);
+		out->inode_size = be32_to_cpu(inode->inode_size);
+
+		if (!S_ISLNK((umode_t) out->mode)) {
+
+			/*
+			 * Convert data stream.
+			 */
+
+			for ( i = 0; i < BEOS_NUM_DIRECT_BLOCKS; i++) {
+				beos_convert_inodeaddr (fstype,
+					&inode->data.datastream.direct[i],
+					&out->data.datastream.direct[i]);
+			}
+			beos_convert_inodeaddr (fstype,
+				&inode->data.datastream.indirect,
+				&out->data.datastream.indirect);
+			beos_convert_inodeaddr (fstype,
+				&inode->data.datastream.double_indirect,
+				&out->data.datastream.double_indirect);
+	
+			out->data.datastream.max_direct_range =
+				be64_to_cpu(inode->data.datastream.max_direct_range);
+			out->data.datastream.max_indirect_range =
+				be64_to_cpu(inode->data.datastream.max_indirect_range);
+			out->data.datastream.max_double_indirect_range =
+				be64_to_cpu(inode->data.datastream.max_double_indirect_range);
+			out->data.datastream.size =
+				be64_to_cpu(inode->data.datastream.size);
+		}
+		break;
+	}
+}
+
+
+void beos_read_inode (struct inode * inode)
+{
+	struct buffer_head * bh = NULL;
+	beos_inode *          raw_inode = NULL;
+	beos_inode *          disk_inode;
+	
+	int event = 0;
+	
+	BEOS_OUTPUT (("---> beos_read_inode() "
+		"inode = %lu[%lu, %u, %u]\n",
+		inode->i_ino,
+		inode->u.beos_i.i_inode_num.allocation_group,
+		inode->u.beos_i.i_inode_num.start,
+		inode->u.beos_i.i_inode_num.len));
+
+	/*
+	 * convert from vfs's inode number to beos's inode number
+	 */
+
+	if (inode->i_ino != BEOS_INODE2INO(inode))
+	{
+		inode->u.beos_i.i_inode_num.allocation_group =
+			inode->i_ino >> inode->i_sb->u.beos_sb.ag_shift;
+		inode->u.beos_i.i_inode_num.start = inode->i_ino
+				& ((2 << inode->i_sb->u.beos_sb.ag_shift) - 1);
+		inode->u.beos_i.i_inode_num.len = 1; /* dummy */
+
+		BEOS_OUTPUT (("  real inode number [%lu, %u, %u]\n",
+			inode->u.beos_i.i_inode_num.allocation_group,
+			inode->u.beos_i.i_inode_num.start,
+			inode->u.beos_i.i_inode_num.len));
+	}
+
+	bh = beos_bread (inode);
+	if (!bh) {
+		printk (KERN_ERR "BEOS: unable to read inode block - inode = %lu",
+			inode->i_ino);
+		goto bad_inode;
+	}
+
+	disk_inode = (beos_inode *) bh->b_data;
+
+	/*
+	 * Convert little-endian or big-endian from beos type.
+	 */
+#ifdef CONFIG_BEOS_CONV
+	raw_inode = (beos_inode *) __getname();
+	if (!raw_inode) {
+		printk (KERN_ERR "BEOS: not allocate memory - inode = %lu",
+			inode->i_ino);
+		goto bad_inode;
+	}
+	beos_convert_inode (inode->i_sb->u.beos_sb.mount_opts.beos_type,
+		disk_inode, raw_inode);
+#else
+	raw_inode = disk_inode;
+#endif
+
+	BEOS_DUMP_INODE (raw_inode);
+
+	/*
+	 * inode is current?
+	 */
+	if (raw_inode->magic1 != BEOS_INODE_MAGIC1) {
+		printk (KERN_ERR
+			"BEOS: this inode is bad magic header - inode = %lu\n",
+			inode->i_ino);
+		goto bad_inode;
+	}
+#if 0
+	if (raw_inode->inode_num != inode->u.beos_i.i_inode_num) {
+		printk ("BEOS: huum... there is no inode.\n");
+		goto bad_inode;
+	}
+#endif
+
+	/*
+	 * check flag
+	 */
+
+	if (!(raw_inode->flags & BEOS_INODE_IN_USE)) {
+		printk (KERN_ERR "BEOS: inode is not used.\n");
+		goto bad_inode;
+	}
+
+	inode->i_mode = (umode_t) raw_inode->mode;
+
+	/*
+	 * set uid and gid.  But since current BeOS is single user OS, so
+	 * you can change by "uid" or "gid" options.
+	 */
+
+	inode->i_uid = inode->i_sb->u.beos_sb.mount_opts.uid ?
+		inode->i_sb->u.beos_sb.mount_opts.uid : (uid_t) raw_inode->uid;
+	inode->i_gid = inode->i_sb->u.beos_sb.mount_opts.gid ?
+		inode->i_sb->u.beos_sb.mount_opts.gid : (gid_t) raw_inode->gid;
+
+	inode->i_nlink = 1;
+
+	/*
+	 * BEOS don't have access time.  So use last modified time.
+	 */
+
+	inode->i_atime = (time_t) (raw_inode->last_modified_time >> 16);
+
+	/*
+	 * BEOS's time is 64 bits, but current VFS is 32 bits...
+	 */
+
+	inode->i_ctime = (time_t) (raw_inode->create_time >> 16);
+	inode->i_mtime = (time_t) (raw_inode->last_modified_time >> 16);
+
+	inode->i_blksize = raw_inode->inode_size;
+
+	inode->i_blocks = raw_inode->inode_size / inode->i_sb->s_blocksize;
+	inode->i_version = ++event;
+	inode->u.beos_i.i_inode_num = (beos_inode_addr) raw_inode->inode_num;
+	inode->u.beos_i.i_mode = raw_inode->mode;
+	inode->u.beos_i.i_flags = raw_inode->flags;
+	inode->u.beos_i.i_create_time = raw_inode->create_time;
+	inode->u.beos_i.i_last_modified_time = raw_inode->last_modified_time;
+
+	inode->u.beos_i.i_parent = (beos_inode_addr) raw_inode->parent;
+	inode->u.beos_i.i_attribute = (beos_inode_addr) raw_inode->attributes;
+
+	/*
+	 * Symbolic link have no data stream.
+	 * This position is original filename.
+	 */
+
+	if (!S_ISLNK(inode->i_mode)) {
+		inode->i_size = raw_inode->data.datastream.size;
+		inode->u.beos_i.i_data.ds = raw_inode->data.datastream;
+	} else {
+		inode->i_size = 0;
+		memcpy (inode->u.beos_i.i_data.symlink, disk_inode->data.symlink,
+			BEOS_SYMLINK_LEN);
+	}
+
+	if (S_ISREG(inode->i_mode))
+		inode->i_op = &beos_file_inode_operations;
+	else if (S_ISDIR(inode->i_mode))
+		inode->i_op = &beos_dir_inode_operations;
+	else if (S_ISLNK(inode->i_mode))
+		inode->i_op = &beos_symlink_inode_operations;
+	else if (S_ISCHR(inode->i_mode))
+		inode->i_op = &chrdev_inode_operations;
+	else if (S_ISBLK(inode->i_mode))
+		inode->i_op = &blkdev_inode_operations;
+	else if (S_ISFIFO(inode->i_mode))
+		init_fifo(inode);
+
+#ifdef CONFIG_BEOS_CONV
+	putname (raw_inode);
+#endif
+	brelse(bh);
+
+	return;
+
+bad_inode:
+	make_bad_inode(inode);
+#ifdef CONFIG_BEOS_CONV
+	if (raw_inode) {
+		putname (raw_inode);
+	}
+#endif
+	if (bh) {
+		brelse(bh);
+	}
+
+	return;
+}
+
+#ifdef CONFIG_BEOS_RW
+static int beos_update_inode(struct inode * inode, int do_sync)
+{
+	struct buffer_head *  bh;
+	beos_inode *           raw_inode;
+	int                   err = 0;
+
+	bh = beos_bread (inode);
+	if (!bh) {
+		printk(KERN_ERR "BEOS: "
+			"bad inode number on dev %s: %ld is out of range\n",
+			bdevname(inode->i_dev), inode->i_ino);
+		return -EIO;
+	}
+
+	raw_inode = (beos_inode *) bh->b_data;
+
+	/*
+	 * fill raw_inode
+	 */
+
+	raw_inode->magic1 = BEOS_INODE_MAGIC1;
+	raw_inode->inode_num = !IS_EMPTY_IADDR(&inode->u.beos_i.i_inode_num)
+		? inode->u.beos_i.i_inode_num : 0;
+
+	raw_inode->uid = BEOS_DEFAULT_UID;
+	raw_inode->gid = BEOS_DEFAULT_GID;
+
+	raw_inode->mode = inode->i_mode;
+	raw_inode->flags = inode->u.beos_i.i_flags;
+
+	raw_inode->create_time = ((__u64) inode->i_ctime) << 16;
+	raw_inode->last_modified_time = ((__u64) inode->i_mtime) << 16;
+
+	raw_inode->parent = inode->u.beos_i.i_parent;
+	raw_inode->attributes = inode->u.beos_i.i_attribute;
+
+	raw_inode->type = inode->u.beos_i.i_type;
+
+	raw_inode->inode_size = inode->i_blksize;
+
+	if (!S_ISLNK(inode->i_mode))
+		raw_inode->data.datastream = inode->u.beos_i.i_data.ds;
+	else
+		memcpy (raw_inode->data.symlink, inode->u.beos_i.i_data.symlink,
+			BEOS_SYMLINK_LEN);
+
+	mark_buffer_dirty (bh, 1);
+
+	if (do_sync) {
+		ll_rw_block (WRITE, 1, &bh);
+		wait_on_buffer (bh);
+		if (buffer_req (bh) && !buffer_uptodate (bh)) {
+			printk (KERN_ERR "BEOS: "
+				"IO error syncing inode [%s: %08lx]\n",
+				bdevname(inode->i_dev), inode->i_ino);
+			err = -EIO;
+		}
+	}
+	brelse (bh);
+
+	return err;
+}
+
+
+void beos_write_inode (struct inode * inode)
+{
+	beos_update_inode (inode, 0);
+}
+
+int beos_sync_inode (struct inode *inode)
+{
+	return beos_update_inode (inode, 1);
+}
+#endif
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/namei.c linux-2.2.18-pre2-beos/fs/beos/namei.c
--- linux-2.2.18-pre2-clean/fs/beos/namei.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/namei.c	Sat Sep  2 12:26:55 2000
@@ -0,0 +1,301 @@
+/*
+ *  linux/fs/beos/namei.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ *  from
+ *
+ *  linux/fs/minix/namei.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <asm/uaccess.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/locks.h>
+#include <linux/quotaops.h>
+
+
+/*
+ * beos_find_entry
+ *
+ * description:
+ *  find file or directory entry
+ *
+ * parameter:
+ *  dir     ... parent's inode
+ *  name    ... file or directry name
+ *  namelen ... length of name
+ */
+
+static beos_off_t beos_find_entry (struct inode * dir, const char * const name,
+	int namelen)
+{
+	struct buffer_head *    bh;
+	beos_index_node *	bn;
+	struct super_block *	sb = dir->i_sb;
+	int			sd_pos = 0;
+	int			key_pos;
+	char			key[BEOS_NAME_LEN + 1];
+	int			key_len;
+	beos_off_t		value;
+
+	// BEOS_OUTPUT (
+	printk("BEOS ---> beos_find_entry()\n");
+
+	while (sd_pos >= 0)
+	{
+		beos_data_stream *	ds = &dir->u.beos_i.i_data.ds;
+		beos_inode_addr		iaddr;
+		int			flags;
+		beos_off_t		offset;
+
+		/*
+		 * get index node from small_data.
+		 *
+		 * First data stream has index entry, but other than it,
+		 * doesn't have it.  
+		 */
+
+		if (sd_pos)
+			flags = 1;
+		else
+			flags = 0;
+
+		iaddr = beos_read_data_stream (sb, ds, &sd_pos);
+		if (sd_pos <= 0)
+		{
+			/*
+			 * cannot read next data stream
+			 */
+
+			//BEOS_OUTPUT (
+			printk(
+			"BEOS <--- beos_find_entry() cannot read next data stream\n");
+			return 0;
+		}
+
+		bh = beos_read_index_node (iaddr, sb, flags, &offset);
+		if (!bh)
+		{
+			/*
+			 * cannot read index node
+			 */
+
+			//BEOS_OUTPUT (
+			printk(
+			"BEOS <--- beos_find_entry() cannot read index node\n");
+			return 0;
+		}
+
+		bn = (beos_index_node *) (bh->b_data + offset);
+
+		/*
+		 * explore in this block
+		 */
+
+		key_pos = 0;
+		while (key_pos >= 0)
+		{
+			beos_get_key_from_index_node (bn, &key_pos,
+				sb->u.beos_sb.mount_opts.beos_type, key,
+				&key_len, &value);
+			if (key_pos < 0)
+			{
+				//BEOS_OUTPUT (
+				printk("BEOS: key not exist in this block\n");
+				break;
+			}
+
+			if (!strcmp (key, name))
+			{
+				brelse (bh);
+				//BEOS_OUTPUT (
+				printk(
+				"BEOS <--- beos_find_entry() value = %Lu\n", value);
+				return value;
+			}
+		}
+
+		brelse (bh);
+	}
+
+	//BEOS_OUTPUT (
+	printk("BEOS <--- beos_find_entry() not found\n");
+	return 0;
+}
+
+
+#if 0
+struct dentry *beos_lookup(struct inode * dir, struct dentry *dentry)
+{
+	struct inode *		inode = NULL;
+	beos_off_t		offset;
+	unsigned int		len = dentry->d_name.len;
+	int			olen;
+	const unsigned char *	tmpname = dentry->d_name.name;
+	//char			tmpname2;
+	char *			tmpname2;
+	struct super_block *	sb = dir->i_sb;
+
+	//BEOS_OUTPUT (
+	printk(
+	"BEOS ---> beos_lookup() name '%s' index inode '%ld'\n", tmpname, dir->i_ino);
+
+	/*
+	 * Convert to UTF-8
+	 */
+	// char * beos_nls2utf (unsigned char * src, int srclen, char ** dist,
+	// int * len, struct super_block * sb)
+
+	if (!beos_nls2utf (*tmpname, len, &tmpname2, &olen, sb))
+	{
+		printk(
+		KERN_ERR "BEOS beos_lookup() unable to allocate memory\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	if (olen > BEOS_NAME_LEN)
+	{
+		printk(
+		KERN_ERR "BEOS beos_lookup() name too long: '\"%s\"'",tmpname2);
+		putname (tmpname2);
+		return ERR_PTR(-ENAMETOOLONG);
+	}
+
+	offset = beos_find_entry (dir, tmpname2, olen);
+	putname (tmpname2);
+
+	if (offset)
+	{
+		inode = iget (sb, (ino_t) offset);
+		if (!inode)
+		{
+			return ERR_PTR(-EACCES);
+		}
+	}
+
+	d_add (dentry, inode);
+
+	//BEOS_OUTPUT (
+	printk("BEOS <--- beos_lookup()\n");
+
+	return;
+}
+#endif
+
+
+struct dentry *beos_lookup (struct inode * dir, struct dentry *dentry)
+{
+	struct inode *		inode = NULL;
+	beos_off_t		offset;
+	unsigned int		len = dentry->d_name.len;
+	int			olen;
+	//const unsigned char *	tmpname = dentry->d_name.name;
+	char *			tmpname = dentry->d_name.name;
+	char *			tmpname2;
+	struct super_block *	sb = dir->i_sb;
+
+	//BEOS_OUTPUT (
+	printk(
+	"BEOS ---> beos_lookup() name '%s' index inode '%ld'\n", tmpname, dir->i_ino);
+
+	/*
+	 * Convert to UTF-8
+	 */
+
+	if (!beos_nls2utf (tmpname, len, &tmpname2, &olen, sb))
+	{
+		return ERR_PTR(-ENOMEM);
+	}
+
+	if (olen > BEOS_NAME_LEN)
+	{
+		printk("BEOS beos_lookup() name too long: '\"%s\"'",tmpname2);
+		putname (tmpname2);
+		return ERR_PTR(-ENAMETOOLONG);
+	}
+
+	printk("BEOS beos_lookup() name len %i\n",olen);
+
+	offset = beos_find_entry (dir, tmpname2, olen);
+	putname (tmpname2);
+
+	if (offset)
+	{
+		inode = iget (sb, (ino_t) offset);
+		if (!inode)
+		{
+			return ERR_PTR(-EACCES);
+		}
+	}
+
+	d_add (dentry, inode);
+
+	//BEOS_OUTPUT (
+	printk("BEOS <--- beos_lookup()\n");
+
+	return NULL;
+}
+
+
+#if 0
+int beos_lookup (struct inode * dir, struct dentry *dentry)
+{
+	struct inode *		inode = NULL;
+	beos_off_t		offset;
+	unsigned int		len = dentry->d_name.len;
+	int			olen;
+	//const unsigned char *	tmpname = dentry->d_name.name;
+	char *			tmpname = dentry->d_name.name;
+	char *			tmpname2;
+	struct super_block *	sb = dir->i_sb;
+
+	//BEOS_OUTPUT (
+	printk(
+	"BEOS ---> beos_lookup() name '%s' index inode '%ld'\n", tmpname, dir->i_ino);
+
+	/*
+	 * Convert to UTF-8
+	 */
+
+	if (!beos_nls2utf (tmpname, len, &tmpname2, &olen, sb))
+	{
+		return -ENOMEM;
+	}
+
+	if (olen > BEOS_NAME_LEN)
+	{
+		printk("BEOS beos_lookup() name too long: '\"%s\"'",tmpname2);
+		putname (tmpname2);
+		return -ENAMETOOLONG;
+	}
+
+	printk("BEOS beos_lookup() name len %i\n",olen);
+
+	offset = beos_find_entry (dir, tmpname2, olen);
+	putname (tmpname2);
+
+	if (offset)
+	{
+		inode = iget (sb, (ino_t) offset);
+		if (!inode)
+		{
+			return -EACCES;
+		}
+	}
+
+	d_add (dentry, inode);
+
+	//BEOS_OUTPUT (
+	printk("BEOS <--- beos_lookup()\n");
+
+	return 0;
+}
+#endif
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/super.c linux-2.2.18-pre2-beos/fs/beos/super.c
--- linux-2.2.18-pre2-clean/fs/beos/super.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/super.c	Mon Aug 28 18:02:08 2000
@@ -0,0 +1,474 @@
+/*
+ * linux/fs/beos/super.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ *  from
+ *
+ *  linux/fs/minix/inode.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <linux/module.h>
+
+#include <stdarg.h>
+
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+//#include <linux/beos_fs.h>
+#include <linux/malloc.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/locks.h>
+#include <linux/blkdev.h>
+#include <linux/init.h>
+#include <linux/nls.h>
+
+
+void beos_put_super (struct super_block * sb)
+{
+	if (sb->u.beos_sb.mount_opts.iocharset) {
+		kfree (sb->u.beos_sb.mount_opts.iocharset);
+		sb->u.beos_sb.mount_opts.iocharset = NULL;
+	}
+
+	if (sb->u.beos_sb.nls) {
+		unload_nls (sb->u.beos_sb.nls);
+		sb->u.beos_sb.nls = NULL;
+	}
+
+	MOD_DEC_USE_COUNT;
+	return;
+}
+
+
+static const struct super_operations beos_sops =
+{
+	beos_read_inode,
+#ifdef CONFIG_BEOS_FS_RW
+	beos_write_inode,
+#else
+	NULL,
+#endif
+	NULL,	/* put */
+	NULL,	/* delete */
+	NULL,	/* notify */
+	beos_put_super,	/* put_super */
+#ifdef CONFIG_BEOS_FS_RW
+	NULL,	/* write_super */
+#else
+	NULL,
+#endif
+	beos_statfs,	/* stat_fs */
+	beos_remount	/* remount_fs */
+};
+
+
+static int parse_options (char *, beos_mount_options *);
+static void beos_convert_super_block (int, beos_super_block *, beos_super_block *);
+
+static int parse_options (char *options, beos_mount_options * opts)
+{
+	char * this_char;
+	char * value;
+	int    ret = 1;
+
+	/*
+	 * Initialize option.
+	 */
+	opts->uid = 0;
+	opts->gid = 0;
+#ifdef CONFIG_PPC
+	opts->beos_type = BEOS_PPC;
+#else
+	opts->beos_type = BEOS_X86;
+#endif
+
+	if (!options)
+		return ret;
+
+	for (this_char = strtok (options, ","); this_char != NULL;
+		this_char = strtok (NULL, ",")) {
+
+		if ((value = strchr (this_char, '=')) != NULL)
+			*value++ = 0;
+
+		if (!strcmp (this_char, "uid")) {
+			if (!value || !*value) {
+				ret = 0;
+			} else {
+				opts->uid = simple_strtoul (value, &value, 0);
+				if (*value) {
+					printk (KERN_ERR "BEOS: Invalid uid option: "
+						"%s\n", value);
+					ret = 0;
+				}
+			}
+		} else if (!strcmp (this_char, "gid")) {
+			if (!value || !*value)
+				ret= 0;
+			else {
+				opts->gid = simple_strtoul(value, &value, 0);
+				if (*value) {
+					printk (KERN_ERR
+						"BEOS: Invalid gid option: "
+						"%s\n", value);
+					ret = 0;
+				}
+			}
+#ifdef CONFIG_BEOS_CONV
+		} else if (!strcmp (this_char, "type")) {
+			if (!value || !*value)
+				return 0;
+			else {
+				if (!strcmp (value, "x86")) {
+					opts->beos_type = BEOS_X86;
+				} else if (!strcmp (value, "ppc")) {
+					opts->beos_type = BEOS_PPC;
+				} else {
+					printk (KERN_ERR
+						"BEOS: unknown filesystem"
+						" type: %s\n", value);
+					ret = 0;
+				}
+			}
+#endif
+		} else if (!strcmp (this_char,"iocharset") && value) {
+			char * p = value;
+			int    len;
+
+			while (*value && *value != ',')
+				value++;
+			len = value - p;
+			if (len) { 
+				char * buffer = kmalloc (len+1, GFP_KERNEL);
+				if (buffer) {
+					opts->iocharset = buffer;
+					memcpy (buffer, p, len);
+					buffer[len] = 0;
+
+					printk (KERN_INFO
+						"BEOS: IO charset %s\n", buffer);
+				} else {
+					printk (KERN_ERR
+						"BEOS: cannot allocate memory\n");
+					ret = 0;
+				}
+			}
+		}
+	}
+
+	return ret;
+}
+
+
+/*
+ * Convert big-endian <-> little-endian
+ */
+
+static void beos_convert_super_block (int fstype, beos_super_block * bs,
+	beos_super_block * out)
+{
+	switch (fstype)
+	{
+	case BEOS_X86:
+		out->magic1 = le32_to_cpu(bs->magic1);
+		out->block_size = le32_to_cpu(bs->block_size);
+		out->block_shift = le32_to_cpu(bs->block_shift);
+		out->num_blocks = le64_to_cpu(bs->num_blocks);
+		out->used_blocks = le64_to_cpu(bs->used_blocks);
+		out->inode_size = le32_to_cpu(bs->inode_size);
+		out->magic2 = le32_to_cpu(bs->magic2);
+		out->blocks_per_ag = le32_to_cpu(bs->blocks_per_ag);
+		out->ag_shift = le32_to_cpu(bs->ag_shift);
+		out->num_ags = le32_to_cpu(bs->num_ags);
+		out->flags = le32_to_cpu(bs->flags);
+		beos_convert_inodeaddr (fstype, &(bs->log_blocks),
+			&(out->log_blocks));
+		out->log_start = le64_to_cpu(bs->log_start);
+		out->log_end = le64_to_cpu(bs->log_end);
+		out->magic3 = le32_to_cpu(bs->magic3);
+		beos_convert_inodeaddr (fstype, &(bs->root_dir),
+			&(out->root_dir));
+		beos_convert_inodeaddr (fstype, &(bs->indices),
+			&(out->indices));
+		break;
+
+	case BEOS_PPC:
+		out->magic1 = be32_to_cpu(bs->magic1);
+		out->block_size = be32_to_cpu(bs->block_size);
+		out->block_shift = be32_to_cpu(bs->block_shift);
+		out->num_blocks = be64_to_cpu(bs->num_blocks);
+		out->used_blocks = be64_to_cpu(bs->used_blocks);
+		out->inode_size = be32_to_cpu(bs->inode_size);
+		out->magic2 = be32_to_cpu(bs->magic2);
+		out->blocks_per_ag = be32_to_cpu(bs->blocks_per_ag);
+		out->ag_shift = be32_to_cpu(bs->ag_shift);
+		out->num_ags = be32_to_cpu(bs->num_ags);
+		out->flags = be32_to_cpu(bs->flags);
+		beos_convert_inodeaddr (fstype, &(bs->log_blocks),
+			&(out->log_blocks));
+		out->log_start = be64_to_cpu(bs->log_start);
+		out->log_end = be64_to_cpu(bs->log_end);
+		out->magic3 = be32_to_cpu(bs->magic3);
+		beos_convert_inodeaddr (fstype, &(bs->root_dir),
+			&(out->root_dir));
+		beos_convert_inodeaddr (fstype, &(bs->indices),
+			&(out->indices));
+		break;
+	}
+}
+
+
+struct super_block * beos_read_super (struct super_block *sb, void *data,
+	int silent )
+{
+	beos_super_block *	bs = NULL;
+	kdev_t			dev = sb->s_dev;
+	int			blocksize;
+	unsigned long		logic_sb_block;
+	struct buffer_head *	bh;
+
+	BEOS_OUTPUT (("---> beos_read_super()\n"));
+
+	/*
+	 * Parse options
+	 */
+
+	if (!parse_options ((char*) data, &sb->u.beos_sb.mount_opts)) {
+		printk (KERN_ERR "BEOS: cannot parse mount options\n");
+		return NULL;
+	}
+
+	/*
+	 * Set dummy blocksize to read super block.
+	 */
+
+	switch (BEOS_TYPE(sb))
+	{
+	case BEOS_X86:
+		blocksize = 512;
+		logic_sb_block = 1;
+		break;
+
+	case BEOS_PPC:
+		blocksize = 1024;
+		logic_sb_block = 0;
+		break;
+
+	default:
+		printk (KERN_ERR "BEOS: cannot parse filesystem type\n");
+		return NULL;	
+	}
+
+	MOD_INC_USE_COUNT;
+	lock_super (sb);
+	set_blocksize (dev, blocksize);
+
+	/*
+	 * Get BEOS super block.
+	 */
+
+	if (!(bh = bread (dev, logic_sb_block, blocksize))) {
+		printk (KERN_ERR "BEOS: unable to read superblock\n");
+		goto bad_beos_read_super;
+	}
+
+	bs = (beos_super_block *) bh->b_data;
+
+#ifdef CONFIG_BEOS_CONV
+	/*
+	 * Convert byte order
+	 */
+
+	bs = (beos_super_block *) __getname();
+	if (!bs) {
+		brelse(bh);
+		goto bad_beos_read_super;
+	}
+	beos_convert_super_block (BEOS_TYPE(sb),
+		(beos_super_block *) bh->b_data, bs);	
+#endif
+	BEOS_DUMP_SUPER_BLOCK (bs);
+
+	/*
+	 * Check magic headers of super block
+	 */
+
+	if ((bs->magic1 != BEOS_SUPER_BLOCK_MAGIC1)
+		|| (bs->magic2 != BEOS_SUPER_BLOCK_MAGIC2)
+		|| (bs->magic3 != BEOS_SUPER_BLOCK_MAGIC3)) {
+
+		brelse (bh);
+		printk (KERN_ERR "BEOS: different magic header\n");
+		goto bad_beos_read_super;
+	}
+
+	/*
+	 * Check blocksize of BEOS.
+	 *
+	 * Blocksize of BEOS is 1024, 2048, 4096 or 8192.
+	 */
+
+	if( (bs->block_size != 1024)
+		&& (bs->block_size != 2048)
+		&& (bs->block_size != 4096)
+		&& (bs->block_size != 8192)) {
+
+		brelse (bh);
+		printk (KERN_ERR "BEOS: different blocksize\n");
+		goto bad_beos_read_super;
+	}
+
+	set_blocksize (dev, (int) bs->block_size);
+
+	/*
+	 * fill in standard stuff
+	 */
+
+	sb->s_magic = BEOS_SUPER_MAGIC;
+	sb->s_blocksize = (int) bs->block_size;
+
+	sb->u.beos_sb.block_size = bs->block_size;
+	sb->u.beos_sb.block_shift = bs->block_shift;
+	sb->u.beos_sb.num_blocks = bs->num_blocks;
+	sb->u.beos_sb.used_blocks = bs->used_blocks;
+	sb->u.beos_sb.inode_size = bs->inode_size;
+
+	sb->u.beos_sb.blocks_per_ag = bs->blocks_per_ag;
+	sb->u.beos_sb.ag_shift = bs->ag_shift;
+	sb->u.beos_sb.num_ags = bs->num_ags;
+
+	sb->u.beos_sb.log_blocks = bs->log_blocks;
+	sb->u.beos_sb.log_start = bs->log_start;
+	sb->u.beos_sb.log_end = bs->log_end;
+
+	sb->u.beos_sb.root_dir = bs->root_dir;
+	sb->u.beos_sb.indices = bs->indices;
+
+	unlock_super (sb);
+
+	/*
+	 * set up enough so that it can read an inode
+	 */
+
+	sb->s_dev = dev;
+	sb->s_op = (struct super_operations *) &beos_sops;
+	sb->s_root = d_alloc_root (iget (sb,
+		BEOS_IADDR2INO(&(bs->root_dir),bs)), NULL);
+
+	if (!sb->s_root) {
+		sb->s_dev = 0;
+		brelse (bh);
+		printk (KERN_ERR "BEOS: get root inode failed\n");
+
+		goto uninit_last_beos_read_super;
+	}
+
+	/*
+	 * load nls library
+	 */
+
+	if (sb->u.beos_sb.mount_opts.iocharset) {
+		sb->u.beos_sb.nls =
+			load_nls (sb->u.beos_sb.mount_opts.iocharset);
+		if (!sb->u.beos_sb.nls) {
+			printk (KERN_WARNING "BEOS: cannot load nls/iocharset '%s.' Loading default nls\n",sb->u.beos_sb.mount_opts.iocharset);
+			sb->u.beos_sb.nls = load_nls_default ();
+		}
+		else
+		{
+			printk (KERN_INFO "BEOS: loaded nls/iocharset '%s'\n",
+				sb->u.beos_sb.mount_opts.iocharset);
+		}
+	}
+	//else {
+	//}
+
+	brelse (bh);
+#ifdef CONFIG_BEOS_CONV
+	putname (bs);
+#endif
+
+	return sb;
+
+bad_beos_read_super:
+	sb->s_dev = 0;
+	unlock_super (sb);
+
+uninit_last_beos_read_super:
+#ifdef CONFIG_BEOS_CONV
+	if (bs)
+		putname (bs);
+#endif
+	MOD_DEC_USE_COUNT;
+
+	return NULL;
+}
+
+
+int beos_remount (struct super_block * sb, int * flags, char * data)
+{
+	if (!(*flags & MS_RDONLY))
+		return -EINVAL;
+	return 0;
+}
+
+
+static struct file_system_type beos_fs_type = {
+	"beos", 
+	FS_REQUIRES_DEV,
+	beos_read_super, 
+	NULL
+};
+
+
+__initfunc(int init_beos_fs(void))
+{
+	return register_filesystem(&beos_fs_type);
+}
+
+#ifdef MODULE
+MODULE_AUTHOR ("Miles Lott, milos@insync.net");
+MODULE_DESCRIPTION ("BeOS FS Driver for Linux (c)2000");
+EXPORT_NO_SYMBOLS;
+
+int init_module(void)
+{
+	printk(KERN_INFO "BEOS: BeOS FS support - http://milosch.net/beos\n");
+	return init_beos_fs();
+}
+
+
+void cleanup_module(void)
+{
+	unregister_filesystem(&beos_fs_type);
+	printk(KERN_INFO "BEOS: BeOS FS support unregistered\n");
+}
+
+#endif
+
+
+int beos_statfs (struct super_block * sb, struct statfs * buf, int bufsiz)
+{
+	struct statfs tmp;
+
+	BEOS_OUTPUT (("---> beos_statfs()\n"));
+
+	tmp.f_type = BEOS_SUPER_MAGIC;
+	tmp.f_bsize = sb->s_blocksize;
+	tmp.f_blocks = sb->u.beos_sb.num_blocks;
+	tmp.f_bfree = sb->u.beos_sb.num_blocks - sb->u.beos_sb.used_blocks;
+	tmp.f_bavail = sb->u.beos_sb.num_blocks - sb->u.beos_sb.used_blocks;
+	tmp.f_files = 0;
+	tmp.f_ffree = 0;
+	tmp.f_namelen = BEOS_NAME_LEN;
+	
+	return copy_to_user (buf, &tmp, bufsiz) ? -EFAULT : 0;
+}
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/symlink.c linux-2.2.18-pre2-beos/fs/beos/symlink.c
--- linux-2.2.18-pre2-clean/fs/beos/symlink.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/symlink.c	Sun Aug 27 08:49:32 2000
@@ -0,0 +1,95 @@
+/*
+ *  linux/fs/beos/symlink.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ *  from
+ *
+ *  linux/fs/minix/symlink.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <asm/uaccess.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/beos_fs.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/stat.h>
+
+static int beos_readlink (struct dentry *, char *, int);
+static struct dentry * beos_follow_link(struct dentry *, struct dentry *,
+	unsigned int);
+
+/*
+ * symlinks can't do much...
+ */
+struct inode_operations beos_symlink_inode_operations = {
+        NULL,                   /* no file-operations */
+        NULL,                   /* create */
+        NULL,                   /* lookup */
+        NULL,                   /* link */
+        NULL,                   /* unlink */
+        NULL,                   /* symlink */
+        NULL,                   /* mkdir */
+        NULL,                   /* rmdir */
+        NULL,                   /* mknod */
+	NULL,			/* rename */
+	beos_readlink,		/* readlink */
+        beos_follow_link,       /* follow_link */
+        NULL,                   /* readpage */
+        NULL,                   /* writepage */
+        NULL,                   /* bmap */
+        NULL,                   /* truncate */
+        NULL,                   /* permission */
+        NULL                    /* smap */
+};
+
+
+/*
+ * The inode of symbolic link is different to data stream.
+ * The data stream become link name.
+ */
+static struct dentry * beos_follow_link(struct dentry * dentry,
+	struct dentry * base, unsigned int follow)
+{
+        struct inode * inode = dentry->d_inode;
+        char *         link = inode->u.beos_i.i_data.symlink;
+
+        UPDATE_ATIME(inode);
+
+        base = lookup_dentry (link, base, follow);
+
+        return base;
+}
+
+
+static int beos_readlink (struct dentry * dentry, char * buffer, int buflen)
+{
+        struct inode * inode = dentry->d_inode;
+        char *         link = inode->u.beos_i.i_data.symlink;
+        int            len = 0;
+        int            len_dist;
+	char *         tmpname;
+
+        if (buflen > BEOS_SYMLINK_LEN)
+                buflen = BEOS_SYMLINK_LEN;
+
+        while (len < buflen && link[len])
+                len++;
+
+	if (!beos_utf2nls (link, len, &tmpname, &len_dist, inode->i_sb)) {
+		return -ENOMEM;
+	}
+
+        if (copy_to_user(buffer, tmpname, len_dist))
+                len = -EFAULT;
+
+	putname (tmpname);
+
+        UPDATE_ATIME(inode);
+
+        return len;
+}
diff -aur --new-file linux-2.2.18-pre2-clean/fs/beos/util.c linux-2.2.18-pre2-beos/fs/beos/util.c
--- linux-2.2.18-pre2-clean/fs/beos/util.c	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/fs/beos/util.c	Sat Sep  2 12:37:55 2000
@@ -0,0 +1,162 @@
+/*
+ *  linux/fs/beos/util.c
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ */
+
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/nls.h>
+
+#define BEOS_UNKNOWN_CHAR '?'
+
+
+/*
+ * UTF-8 to NLS charset  convert routine
+ */
+char * beos_utf2nls (char * src, int srclen, char ** dist,
+		int * len, struct super_block * sb)
+{
+	char *           	out;
+	struct nls_table * 	nls = sb->u.beos_sb.nls;
+	char *			orig = src;
+	int			olen = 0;
+
+	BEOS_OUTPUT (("---> utf2nls()\n"));
+
+	*dist = out = (char *) __getname();
+	
+	if (!out)
+	{
+		printk(KERN_ERR "BEOS utf2nls: cannot allocate memory\n");
+		return NULL;
+	}
+
+	if (!nls)
+	{
+		printk(KERN_INFO "BEOS utf2nls: '%s' not nls\n", src);
+		while (*src && srclen-- > 0) { *out++ = *src++; }
+	}
+	else
+	{
+		printk(KERN_INFO "BEOS utf2nls: processing nls\n");
+		while (*src && srclen > 0)
+		{
+			int n;
+			unsigned char		page;
+			__u16			w;
+
+			/*
+			 *  convert from UTF-8 to Unicode
+			 */
+			// int utf8_mbtowc(__u16 *, const __u8 *, int)
+			n = utf8_mbtowc(&w, src, srclen);
+			if (n <= 0)
+			{
+				/*
+				 * cannot convert from UTF-8 to unicode
+				 */
+				*out++ = BEOS_UNKNOWN_CHAR;
+				src++;
+				srclen--;
+				continue;
+			}
+			//else
+			//{
+			//	printk(KERN_INFO "BEOS utf8_mbtowc: %d\n",w);
+			//}
+			src += n;
+			srclen -= n;
+
+		//	printk(KERN_INFO "BEOS uni2char: working on %d\n",w);
+			nls->uni2char(0x00, w, &page, 20, &olen);
+		//	printk(KERN_INFO "BEOS uni2char: returned %d\n",page);
+
+			if (!page)
+				*out++ = BEOS_UNKNOWN_CHAR;
+			else
+				//*out++ = page[w & 0xff];
+				*out++ = page;
+		}
+	}
+	*out = '\0';
+	*len = out - (*dist);
+
+	BEOS_OUTPUT (("<--- utf2nls()\n"));
+	if (nls)
+	{
+		printk(KERN_INFO "BEOS utf2nls in '%s'\tout '%s' length '%d'\n", orig, *dist, *len);
+	}
+	return *dist;
+}
+
+
+char * beos_nls2utf (unsigned char * src, int srclen, char ** dist,
+		int * len, struct super_block * sb)
+{
+	char *			out;
+	struct nls_table *	nls = sb->u.beos_sb.nls;
+	char *			orig = src;
+
+	//BEOS_OUTPUT (
+	printk(KERN_INFO "BEOS ---> nls2utf()\n");
+
+	*dist = out = (char *) __getname();
+	if (!out)
+	{
+		//BEOS_OUTPUT (
+		printk(KERN_WARNING "BEOS: cannot allocate memory\n");
+		return NULL;
+	}
+
+	if (!nls)
+	{
+		printk(KERN_INFO "BEOS nls2utf: not nls\n");
+		while (*src && srclen-- > 0) { *out++ = *src++; }
+	}
+	else
+	{
+		printk(KERN_INFO "BEOS nls2utf: processing nls\n");
+		while (*src && srclen > 0)
+		{
+			int 		n,offset=0;
+			__u16		w=0;
+			__u8		wl,wh;
+
+			/*
+			 * convert from nls to unicode
+			 */
+		//	printk(KERN_INFO "BEOS char2uni: working on %d\n",*src);
+			nls->char2uni(src, &offset, &wh, &wl);
+		//	printk(KERN_INFO "BEOS char2uni: returned %d\n",wh);
+
+			src++;
+			srclen--;
+			//w = wh >> 8 << wl;
+			w = wh;
+			//printk(KERN_INFO "BEOS char2uni: %d\n",w);
+			/*
+			 * convert from unicode to UTF-8
+			 */
+			n = utf8_wctomb(out, w, 6);
+			if (n <= 0)
+			{
+				*out++ = BEOS_UNKNOWN_CHAR;
+				continue;
+			}
+			out += n;
+		}
+	}
+
+	*out = '\0';
+	*len = out - (*dist);
+
+	//BEOS_OUTPUT (
+	printk(KERN_INFO "BEOS <--- nls2utf()\n");
+	if (nls)
+	{
+		printk(
+		KERN_INFO "BEOS nls2utf in '%s'\tout '%s' length '%d'\n", orig, *dist,*len);
+	}
+	return *dist;
+}
diff -aur --new-file linux-2.2.18-pre2-clean/fs/filesystems.c linux-2.2.18-pre2-beos/fs/filesystems.c
--- linux-2.2.18-pre2-clean/fs/filesystems.c	Thu Aug 24 01:54:28 2000
+++ linux-2.2.18-pre2-beos/fs/filesystems.c	Sat Sep  2 12:52:02 2000
@@ -59,6 +59,10 @@
 	init_minix_fs();
 #endif
 
+#ifdef CONFIG_BEOS_FS
+	init_beos_fs();
+#endif
+	
 #ifdef CONFIG_ROMFS_FS
 	init_romfs_fs();
 #endif
diff -aur --new-file linux-2.2.18-pre2-clean/include/linux/beos_fs.h linux-2.2.18-pre2-beos/include/linux/beos_fs.h
--- linux-2.2.18-pre2-clean/include/linux/beos_fs.h	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/include/linux/beos_fs.h	Sat Sep  2 12:26:25 2000
@@ -0,0 +1,305 @@
+/*
+ * linux/include/linux/beos_fs.h
+ *
+ * Copyright (C) 1999 Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ */
+
+#ifndef _LINUX_BEOS_FS
+#define _LINUX_BEOS_FS
+
+#include <linux/types.h>
+//#include <linux/fs.h>
+
+/*
+ * for debug
+ */
+/* #define BEOS_DEBUG */
+
+#ifdef BEOS_DEBUG
+#define BEOS_OUTPUT(x)        printk x
+#define BEOS_DUMP_SUPER_BLOCK beos_dump_super_block
+#define BEOS_DUMP_INODE       beos_dump_inode
+#define BEOS_DUMP_INDEX_ENTRY beos_dump_index_entry
+#define BEOS_DUMP_INDEX_NODE  beos_dump_index_node
+#define BEOS_DUMP_INODE_ADDR  beos_dump_inode_addr
+#else
+#define BEOS_OUTPUT(x)
+#define BEOS_DUMP_SUPER_BLOCK(x)
+#define BEOS_DUMP_INODE(x)
+#define BEOS_DUMP_INDEX_ENTRY(x)
+#define BEOS_DUMP_INDEX_NODE(x)
+#define BEOS_DUMP_INODE_ADDR(x)
+#endif
+
+
+/*
+ * Flags of superblock
+ */
+
+#define BEOS_CLEAN 0x434c454e
+#define BEOS_DIRTY 0x44495254
+
+/*
+ * Max name length of BEOS
+ */
+
+#define BEOS_NAME_LEN 255
+#define BEOS_SYMLINK_LEN 160
+
+/*
+ * Magic headers of BEOS's superblock, inode and index
+ */
+
+#define BEOS_SUPER_BLOCK_MAGIC1 0x42465331 /* BEOS1 */
+#define BEOS_SUPER_BLOCK_MAGIC2 0xdd121031
+#define BEOS_SUPER_BLOCK_MAGIC3 0x15b6830e
+
+#define BEOS_INODE_MAGIC1 0x3bbe0ad9
+
+#define BEOS_INDEX_MAGIC 0x69f6c2e8
+
+#define BEOS_SUPER_MAGIC BEOS_SUPER_BLOCK_MAGIC1
+
+
+#define BEOS_NUM_DIRECT_BLOCKS 12
+#define BEOS_NAME_LENGTH 32
+
+/*
+ * BEOS filesystem type
+ */
+
+#define BEOS_PPC 1
+#define BEOS_X86 2
+
+/*
+ * default gid and uid
+ */
+
+#define BEOS_DEFAULT_GID 0
+#define BEOS_DEFAULT_UID 0
+
+/*
+ * Flags of inode
+ */
+
+#define BEOS_INODE_IN_USE      0x00000001
+#define BEOS_ATTR_INODE        0x00000004
+#define BEOS_INODE_LOGGED      0x00000008
+#define BEOS_INODE_DELETED     0x00000010
+
+#define BEOS_PERMANENT_FLAG    0x0000ffff
+
+#define BEOS_INODE_NO_CREATE   0x00010000
+#define BEOS_INODE_WAS_WRITTEN 0x00020000
+#define BEOS_NO_TRANSACTION    0x00040000
+
+
+#define BEOS_IADDR2INO(iaddr,sb) \
+	(((iaddr)->allocation_group << (sb)->ag_shift) + (iaddr)->start)
+#define BEOS_INODE2INO(inode) \
+	(((inode)->u.beos_i.i_inode_num.allocation_group << \
+		(inode)->i_sb->u.beos_sb.ag_shift) \
+	+ (inode)->u.beos_i.i_inode_num.start)
+
+#define BEOS_BLOCK_PER_INODE(sb) \
+	((sb)->u.beos_sb.block_size / sizeof(beos_inode_addr))
+
+#define BEOS_IS_EMPTY_IADDR(iaddr) \
+	((!(iaddr)->allocation_group) && (!(iaddr)->start) && (!(iaddr)->len))
+
+#define BEOS_TYPE(sb) \
+	((sb)->u.beos_sb.mount_opts.beos_type)
+
+/* 
+ * special type of BEOS
+ */
+
+typedef long long	beos_off_t;
+typedef long long	beos_bigtime_t;
+typedef void		beos_binode_etc;
+
+
+/* Block runs */
+typedef struct _beos_block_run {
+	__u32	allocation_group;
+	__u16	start;
+	__u16	len;
+} beos_block_run;
+
+
+typedef beos_block_run	beos_inode_addr;
+
+
+/*
+ * The Superblock Structure
+ */
+
+typedef struct _beos_super_block {
+	char	name[BEOS_NAME_LENGTH];
+	__u32	magic1;
+	__u32	fs_byte_order;
+
+	__u32	block_size;
+	__u32	block_shift;
+
+	beos_off_t  num_blocks;
+	beos_off_t  used_blocks;
+
+	__u32          inode_size;
+
+	__u32          magic2;
+	__u32          blocks_per_ag;
+	__u32          ag_shift;
+	__u32          num_ags;
+
+	__u32          flags;
+
+	beos_block_run  log_blocks;
+	beos_off_t      log_start;
+	beos_off_t      log_end;
+
+	__u32          magic3;
+	beos_inode_addr root_dir;
+	beos_inode_addr indices;
+
+	__u32          pad[8];
+} __attribute__ ((packed)) beos_super_block;
+
+
+typedef struct _beos_data_stream {
+	beos_block_run	direct[BEOS_NUM_DIRECT_BLOCKS];
+	beos_off_t	max_direct_range;
+	beos_block_run	indirect;
+	beos_off_t	max_indirect_range;
+	beos_block_run	double_indirect;
+	beos_off_t	max_double_indirect_range;
+	beos_off_t	size;
+} __attribute__ ((packed)) beos_data_stream;
+
+
+/* Attribute */
+typedef struct _beos_small_data {
+	__u32	type;
+	__u16	name_size;
+	__u16	data_size;
+	char	name[1];
+} __attribute__ ((packed)) beos_small_data;
+
+
+/* Inode structure */
+typedef struct _beos_inode {
+	__u32           magic1;
+	beos_inode_addr  inode_num;
+	__u32           uid;
+	__u32           gid;
+	__u32           mode;
+	__u32           flags;
+	beos_bigtime_t   create_time;
+	beos_bigtime_t   last_modified_time;
+	beos_inode_addr  parent;
+	beos_inode_addr  attributes;
+	__u32           type;
+
+	__u32           inode_size;
+	__u32           etc; /* not use */
+
+	union {
+		beos_data_stream	 datastream;
+		char             symlink[BEOS_SYMLINK_LEN];
+	} data;
+	__u32            pad[4]; /* not use */
+} __attribute__ ((packed)) beos_inode;
+
+
+typedef struct _beos_index_entry {
+	__u32      magic;
+	__u32      node_size;
+	__u32      max_number_of_levels;
+	__u32      data_type;
+	beos_off_t  root_node_pointer;
+	beos_off_t  free_node_pointer;
+	beos_off_t  maximum_size;
+} __attribute__ ((packed)) beos_index_entry;
+	
+
+typedef struct _beos_index_node {
+	beos_off_t left;
+	beos_off_t right;
+	beos_off_t overflow;
+	__u16     all_key_count;
+	__u16     all_key_length;
+} __attribute__ ((packed)) beos_index_node;
+
+
+typedef struct _beos_mount_options {
+	gid_t	gid;
+	uid_t	uid;
+	int	beos_type;
+	char *  iocharset;
+} beos_mount_options;
+
+
+#ifdef __KERNEL__
+/*
+ * Function prototypes
+ */
+
+/* file.c */
+extern int beos_read (struct inode *, struct file *, char *, int);
+extern beos_inode_addr beos_read_data_stream (struct super_block *,
+	beos_data_stream *, int *);
+
+/* inode.c */
+extern int beos_bmap (struct inode *, int);
+extern void beos_read_inode (struct inode *);
+extern struct buffer_head * beos_bread (struct inode *);
+extern struct buffer_head * beos_bread2 (struct super_block *, beos_inode_addr);
+extern void beos_write_inode (struct inode *);
+extern int beos_sync_inode (struct inode *);
+extern void beos_convert_inodeaddr (
+		int fstype, beos_inode_addr * iaddr, beos_inode_addr * out);
+
+/* namei.c */
+extern void beos_release (struct inode *, struct file *);
+//extern int beos_lookup (struct inode *, struct dentry *);
+extern struct dentry * beos_lookup (struct inode *, struct dentry *);
+
+/* super.c */
+extern void beos_put_super (struct super_block *);
+extern int beos_remount (struct super_block *, int *, char *);
+extern struct super_block * beos_read_super (struct super_block *,void *,int);
+extern int init_beos_fs(void);
+extern int beos_statfs (struct super_block *, struct statfs *, int);
+
+/* index.c */
+extern char * beos_get_key_from_index_node (beos_index_node *, int *, int,
+	char *, int *, beos_off_t *);
+extern struct buffer_head * beos_read_index_node (beos_inode_addr,
+	struct super_block *, int, beos_off_t *);
+
+/* debug.c */
+extern void beos_dump_super_block (beos_super_block *);
+extern void beos_dump_inode (beos_inode *);
+extern void beos_dump_index_entry (beos_index_entry *);
+extern void beos_dump_index_node (beos_index_node *);
+
+/* util.c */
+extern char * beos_utf2nls (char *, int, char **, int *, struct super_block *);
+extern char * beos_nls2utf (unsigned char *, int, char **, int *, struct super_block *);
+
+/*
+ * Inodes and files operations
+ */
+
+/* dir.c */
+extern struct inode_operations beos_dir_inode_operations;
+
+/* file.c */
+extern struct inode_operations beos_file_inode_operations;
+
+/* symlink.c */
+extern struct inode_operations beos_symlink_inode_operations;
+
+#endif  /* __KERNEL__ */
+
+#endif
diff -aur --new-file linux-2.2.18-pre2-clean/include/linux/beos_fs_i.h linux-2.2.18-pre2-beos/include/linux/beos_fs_i.h
--- linux-2.2.18-pre2-clean/include/linux/beos_fs_i.h	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/include/linux/beos_fs_i.h	Sat Sep  2 12:26:30 2000
@@ -0,0 +1,37 @@
+/*
+ *  linux/include/linux/beos_fs_i.h
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ *
+ *  from
+ *
+ *  linux/include/linux/ex2_fs_i.h
+ */
+
+#ifndef _LINUX_BEOS_FS_I_
+#define _LINUX_BEOS_FS_I_
+
+#include <linux/beos_fs.h>
+
+struct beos_inode_info {
+	beos_inode_addr	i_inode_num;
+	__u32	i_uid;
+	__u32	i_gid;
+	__u32	i_mode;
+	__u32	i_flags;
+
+	beos_bigtime_t	i_create_time;
+	beos_bigtime_t	i_last_modified_time;
+
+	beos_inode_addr	i_parent;
+	beos_inode_addr	i_attribute;
+
+	__u32	i_type;
+
+	union {
+		beos_data_stream ds;
+		char            symlink[BEOS_SYMLINK_LEN];
+	} i_data;
+};
+
+#endif /* _LINUX_BEOS_FS_I_ */
diff -aur --new-file linux-2.2.18-pre2-clean/include/linux/beos_fs_sb.h linux-2.2.18-pre2-beos/include/linux/beos_fs_sb.h
--- linux-2.2.18-pre2-clean/include/linux/beos_fs_sb.h	Wed Dec 31 18:00:00 1969
+++ linux-2.2.18-pre2-beos/include/linux/beos_fs_sb.h	Sat Sep  2 12:26:30 2000
@@ -0,0 +1,44 @@
+/*
+ *  linux/include/linux/beos_fs_sb.h
+ *
+ * Copyright (C) 1999  Makoto Kato (m_kato@ga2.so-net.ne.jp)
+ */
+
+#ifndef _LINUX_BEOS_FS_SB
+#define _LINUX_BEOS_FS_SB
+
+#include <linux/types.h>
+#include <linux/beos_fs.h>
+
+
+struct beos_sb_info {
+	__u32		block_size;
+	__u32		block_shift;
+	beos_off_t	num_blocks;
+	beos_off_t	used_blocks;
+	__u32		inode_size;
+
+	/*
+	 * Allocation group information
+	 */
+
+	__u32	blocks_per_ag;
+	__u32	ag_shift;
+	__u32	num_ags;
+
+	/*
+	 * jornal log entry
+	 */
+
+	beos_block_run log_blocks;
+	beos_off_t log_start;
+	beos_off_t log_end;
+
+	beos_inode_addr root_dir;
+	beos_inode_addr indices;
+
+	beos_mount_options mount_opts;
+
+	struct nls_table * nls;
+};
+#endif
diff -aur --new-file linux-2.2.18-pre2-clean/include/linux/fs.h linux-2.2.18-pre2-beos/include/linux/fs.h
--- linux-2.2.18-pre2-clean/include/linux/fs.h.orig	Mon Sep  4 20:57:21 2000
+++ linux-2.2.18-pre2-clean/include/linux/fs.h	Mon Sep  4 21:01:43 2000
@@ -280,6 +280,7 @@
 #include <linux/adfs_fs_i.h>
 #include <linux/qnx4_fs_i.h>
 #include <linux/usbdev_fs_i.h>
+#include <linux/beos_fs_i.h>
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what
@@ -395,6 +396,7 @@
 		struct qnx4_inode_info		qnx4_i;
 		struct usbdev_inode_info	usbdev_i;
 		struct socket			socket_i;
+		struct beos_inode_info		beos_i;
 		void				*generic_ip;
 	} u;
 };
@@ -517,6 +519,7 @@
 #include <linux/adfs_fs_sb.h>
 #include <linux/qnx4_fs_sb.h>
 #include <linux/usbdev_fs_sb.h>
+#include <linux/beos_fs_sb.h>
 
 extern struct list_head super_blocks;
 
@@ -561,6 +564,7 @@
 		struct adfs_sb_info	adfs_sb;
 		struct qnx4_sb_info	qnx4_sb;	   
 		struct usbdev_sb_info	usbdevfs_sb;
+		struct beos_sb_info	beos_sb;
 		void			*generic_sbp;
 	} u;
 	/*
