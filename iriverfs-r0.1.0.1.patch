diff -uprN -X ../dontdiff linux-2.6.9/COPYING.iriverfs linux-2.6.9-iriverfs-stable/COPYING.iriverfs
--- linux-2.6.9/COPYING.iriverfs	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/COPYING.iriverfs	2004-10-23 11:42:21.000000000 -0400
@@ -0,0 +1,341 @@
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -uprN -X ../dontdiff linux-2.6.9/Documentation/filesystems/iriver.txt linux-2.6.9-iriverfs-stable/Documentation/filesystems/iriver.txt
--- linux-2.6.9/Documentation/filesystems/iriver.txt	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/Documentation/filesystems/iriver.txt	2004-10-23 12:15:50.000000000 -0400
@@ -0,0 +1,488 @@
+-------
+License
+-------
+
+Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+
+This driver is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; only version 2 of the License.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License in the files
+"COPYING" or "COPYING.iriverfs"; if not, write to the Free Software Foundation,
+Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+--------------------------
+Release notes for iRiverFS
+--------------------------
+
+Oct 23, 2004 (version 0.1.0.1)
+	-fixed support for older and newer kernels (pre and post 2.6.8.1) 
+	-made 'delta' more flexible in the data it accepts.  (Backpatched
+	from the 'dev' branch.)
+	-more documentation of the USB timing bug.  (See the developing
+	branch for more information.)
+
+Oct  6, 2004 (version 0.1.0.0)
+	(no changes)
+
+Oct  4, 2004 (version 0.1.0.0pre7)
+	-port to linux-2.6.9pre3
+
+Sep 30, 2004 (version 0.1.0.0pre6)
+	-gcc-2.95 preprocessor bug fix didn't make it into pre5. (Fixed)
+	-added support for renaming directories
+	-fixed a file renaming bug.  (Involved moving files to or from '\')
+	-changed the public api for renaming files/directories
+
+Sep 27, 2004 (version 0.1.0.0pre5)
+	-mount now returns 'busy' when the device fails startup test.  (Of all
+	the error messages mount(5) returns, this one seems the best fitting.)
+	-fixed static linking (ie, non-module) the driver.
+	-fixed gcc-2.95 preprocessor bug
+	-added security options
+	-disabled directory renaming (Because it doesn't work.)
+
+	-documented konqueror's chopy behaviour during file uploads
+
+	(Footnote: there were several different patches in circulation
+	with the name 'pre5'.  "pre5" and "pre5c" were private releases,
+	while "pre5b" was the official release.)
+
+Sep 21, 2004 (version 0.1.0.0pre4)
+	-hot-unplugging is now handled gracefully.  (Well, more graceful than segfaulting.)
+	-no longer attempts usb_reset() if the device is busy.
+	-"halted endpoints" are now checked for and handled.
+	-fixed 'du' problem
+
+Sep 18, 2004 (version 0.1.0.0pre3)
+	-fixed segfault-on-insmod that existed in pre1 and pre2.  (I left the
+	memory allocation debugging flag on, which doesn't play nicely with
+	kernels that aren't configured to support it.  My bad.)
+
+	-added kconfig dependency on 'experimental' and 'usb'.
+
+Sep 14, 2004 (version 0.1.0.0pre2)
+
+	-fixed bug in iriver_lookup: there was a problem when looking up
+	non-existant entries in unloaded directories.  Test case: mkdir
+	/mnt/a/debug/d1/d5 (where d5 didn't exist before).
+
+	-applied a temporary work-around that deals with usb_control_msg
+	returning '-EPIPE'.  (See BUGS)
+
+Sep 3, 2004 (Forth public release; first SourceForge release; version 0.1.0.0pre1)
+
+	The biggest news is I've joined the ifp-driver project and this project
+	has become a package of ifp-driver.  I owe a big thanks to Jun and the
+	ifp-driver mailing list for making it this far.
+
+	From here, I hope to stabilize the codebase within a few releases and
+	fork the first 'stable' branch: ifp-linux-filesystem-0.1.0.0
+
+	----------
+	change log
+	----------
+
+	-"find bug" squished
+	-"konqueror bug" and stability problems are gone
+	-data corruption -- missing; hopefully squished
+	-improved self-testing on mount
+	-new info I've code-named "delta" is printed on mount.  (On my ifp5xx,
+	delta is always 1.8.6.22.  I'm curious what other devices return.)
+	-more stack abuse eliminated
+	-more ifp-specific code removed from inode.c
+	-inode/dentry refrence counting fixed
+
+	This release was tested with linux-2.6.8.1
+
+Aug 2, 2004 (Third public release)
+
+	----------
+	change log
+	----------
+
+	-[new!] File rename support.  (Directory renaming is untested.)
+
+	-reading mp3 files on old device is now possible if you rename
+	them.  (In the future, the driver could do this automatically.)
+
+	-improvements in stability and memory management.
+
+	----------------
+	outstanding bugs
+	----------------
+	[For more details, see the 'bugs' section below.]
+
+	-Using Konqueror locks up the system. [still]
+
+	-Data corruption bug.  (Rare, and relatively harmless for music.)
+
+July 23, 2004 (Second public release)
+
+	----------
+	change log
+	----------
+
+	-Support for ifp7xx/8xx devices has been added.  (Thanks to David for
+	pointing out this was missing, and then helping me fix it!)
+
+	-"It seems there's a matter with df." [fixed]  Thanks to Boris for
+	brining this to my attention.
+
+	-Bug fixed that prevented a new directory from being created inside
+	another new directory. [found by David and Jim]
+
+	-Stack abuse [using the kernel call stack to allocate large buffers] is
+	gone. [found by segfault]
+
+	-CPU abuse fixed--driver now sleeps while waiting for flush() to
+	complete.
+
+	-interal refactoring--I'm slowly separating kernel-specific code from
+	iFP-specific code.  In the future, it might be possible for ifp-line
+	and this driver to share some source code.
+
+July 14, 2004 (First public release)
+
+	-------
+	summary
+	-------
+
+	This driver mounts iRiver "iFP" mp3 players as filesystems.  It is
+	intended as a replacement for iRiver's "Manager" software available for
+	other platforms.
+	
+	This project his reached "dogfood" status for me, so I'm releasing it
+	for public comment and [dis]approval.  I haven't tested it with any
+	other computer or player, so I'd very much appreciate feedback from
+	others.
+
+	I hope you find this useful,
+
+	Geoff Oakham <oakhamg@users.sourceforge.net>
+
+Requirements:
+
+	-linux 2.6.x
+	-kernel sourcecode [enough to compile modules]
+	-development tools (gcc, etc.)
+	-iRiver flash player (aka "iFP")
+	-virtual memory, enough to temporarily hold entire files*
+
+	This driver has been reported to work with iFP3xx, 5xx, 7xx and 8xx models.
+
+* modern desktops shouldn't have a problem with memory use.  This warning is
+  for people attempting to use this on a 486: you will need a swap partition..
+  if not two.
+
+BUGs & other unresolved problems:
+
+	Konqueror's progress metre:
+		Currently, when Konqueror uploads files to the device, its
+		progress metre "jumps" after writing each file.  The jerky
+		behaviour confuses Konqueror and prevents it from esitmating
+		the total transfer time.  (Instead is displays "stalled"..
+		which is disconcerting to the user.)
+
+		This is a quirk of the current implementation.  It would be
+		possible (and relatively easy) to fix if someone discovered how
+		to append to exisiting files.  (This would allow uploads to
+		happen in several steps, instead of all at once.  That would
+		also mean the device wouldn't have to lock up during uploads.)
+
+		[no intention of fixing.. see above discussion.]
+
+	usb protocol stall:
+		It appears during large downloads on a moderately loaded system,
+		my ifp device does a "usb protocol stall".  (This only happens
+		with my uhci host--my ohci host hasn't done this yet.)
+
+		Details:
+			-when sending the 'DOWNLOAD' control message, the system
+			returns EPIPE, which in this context means "protocol stall"
+			(according to the USB spec, and I've verified with code
+			it isn't a functional staff.. aka 'halt').
+
+			-sleep()ing for a few cycles and re-issuing the control
+			code seems to work around the problem 90% of the time.
+			(At most.)
+
+			-The other 10% of the time, we reach EOF one block ahead
+			of schedual.  (To me, this means that one of those
+			control messages I presumed failed, succeeded eventually.)
+
+			-According to the USB spec, 'protocol stall' is
+			supposed be returned when the command we sent isn't
+			valid.  (Either the command or its parameters.)
+
+		Thoughts:
+			I haven't seen a way for the device to tell us "wait,
+			I'm not ready to send you more data"; however, that's
+			supposed to be built-in to the usb protocol itself.
+			(On the other hand, they didn't appear to use this
+			feature for uploading.. but they might be buffering
+			data in RAM.  *shrug*)
+
+			A potential short-term solution is to pace requests for
+			data.  (Ie cap our bandwidth usage.)
+
+		[update oct 3, 2004]
+			Doesn't seem to be related to usb changes mentioned
+			below.
+
+		[update oct 6, 2004]
+			In a discussion on linux-usb-devel, we suspect this
+			is a timing issue.  Here's a quick test I ran:
+
+			wall time | speed Bps | EPIPEs | changes
+			------------------------------ low load, no limit
+			37.628157 | 544772    | 0
+			37.797504 | 541835    | 1
+			37.613491 | 544984    | 0
+			37.807000 | 542195    | 0
+			------------------------------ low load, ohcl host
+			51.061969 | 401449    | 0
+			50.537478 | 405615    | 0
+			50.677527 | 404494    | 0
+			50.502911 | 405893    | 0
+			------------------------------ no load, schedule()
+			37.810688 | 542142    | 0
+			37.868029 | 541321    | 0
+			37.958808 | 540026    | 1
+			37.770085 | 542725    | 0
+			------------------------------ high load, no limit
+			45.54988  | 450029    | 1
+			56.863098 | 360493    | 1
+			83.509111 | 245467    | 1
+			82.827214 | 247488    | 0
+			------------------------------ high load, sleep(50ms)
+			100.767380| 203427    | 0
+			100.870890| 203218    | 0
+			100.739756| 203482    | 0
+			------------------------------ high load, sleep(10ms)
+			50.597539 | 405134    | 0
+			50.372042 | 406947    | 0
+			50.594270 | 405160    | 0
+			------------------------------ high load, sleep(5ms)
+			44.373462 | 461960    | 0
+			44.576646 | 459854    | 0
+			44.452869 | 461135    | 0
+			------------------------------ high load, schedule()
+			78.141574 | 262328    | 0
+			76.179661 | 269084    | 0
+			79.868304 | 256657    | 0
+			84.962858 | 241267    | 0
+
+	doesn't compile with 2.6.9pre3:
+		The issues are:
+			1. missing 'usb_endpoint_halted'
+			2. warning about incompatible pointers for __le16_to_cpup
+
+		Changelog of linux-2.6.9pre1:
+			<stern@rowland.harvard.edu>
+			[PATCH] USB: Don't track endpoint halts in usbcore
+
+			This patch is a repeat of as331 as described in
+
+			http://marc.theaimsgroup.com/?l=linux-usb-devel&m=108811725219677&w=2
+
+			It has been updated slightly to match the current
+			source.  It should be non-controversial; it has nothing
+			to do with hubs or locking.  Please apply.
+
+			Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
+			Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
+
+		[the above mentioned bug report]
+			
+			List:       linux-usb-devel
+			Subject:    [linux-usb-devel] PATCH: (as331) Don't track endpoint halts in usbcore
+			From:       Alan Stern <stern () rowland ! harvard ! edu>
+			Date:       2004-06-24 20:51:04
+			Message-ID: <Pine.LNX.4.44L0.0406241644360.634-100000 () ida ! rowland ! org>
+
+			The current mechanism for keeping track of which
+			endpoints in a device are halted is both flawed and
+			unnecessary.  It's flawed because devices are free to
+			change the endpoint status whenever they want without
+			telling us, and it's unnecessary because an URB
+			submitted for a halted endpoint will quickly receive an
+			error indication.
+
+			This patch removes the code associated with tracking
+			halts: the halted[] member of usb_device, the
+			usb_endpoint_halt, usb_endpoint_halted, and
+			usb_endpoint_running macros, all the places where they
+			are used or checked, and the places in the host
+			controller drivers where they get set.
+
+			This is part of my ongoing program for cleaning up
+			usbcore.  Please apply.
+
+			Alan Stern
+
+
+	missing blocks:
+		The space used reported by df and du is off by a fair bit (10%
+		of capacity on my device).  Since we don't know the internal
+		filesystem iRiver uses, some difference is expected.. but not
+		that much.  This could be an indication of a problem.  A minor
+		problem, I hope.
+
+		tought: I believe this has something to do with the reported
+		blocksize.  in userland 'stat' always reports the blocksize as
+		'512' no matter what I set it to.  I don't know if that's
+		enough to throw the used space off by that much, but it's
+		probably a good place to start looking.
+
+	requires GCC 3.0+:
+		This needs to be fixed because Linux 2.6 cites 2.95.3 as the minimum
+		version.
+
+		[fixed: I didn't have a space between "__FUNCTION__" and ","]
+
+	Filemode details:
+		-new mp3 files aren't made non-readable the way existing files are.
+
+		[low priority]
+
+	Security:
+		-default owner/group (0/0) is not configurable
+		-default umask (0777) is not configurable
+		-normal users can chmod files [unconfirmed]
+
+		[fixed]
+
+	Device left in bad state:
+		If you unmount iriverfs immediately after uploading a file,
+		the device is left in a bad state.  Temporary solution
+		involves disconnecting and reconnecting device.
+
+		thought: ifp-line issues a reset() on exit.  Perhaps we should
+		do the same?
+
+	Filename length:
+		no known issues.. but this must be tested at some point.
+
+        	[needs testing]
+
+	Directory renaming:
+        	[disabled]
+
+	Data corruption:
+		Occationally during upload, four bytes of a file are changed to
+		"02 00 00 00"---otherwise known as ((int)2).  (It always seems
+		to be a single-digit integer.)  
+
+        	[appears to be fixed]
+
+	Stability:
+		Stability no longer appears to be a major issue.  (This is a good
+		thing, but I'm leaving this bug "open" for the time being.)
+
+		[appears to be fixed]
+
+
+Unimplemented features:
+
+	- renaming directories
+	- mp3 file reading [work around: rename it first]
+	- modification of existing files
+	- support for multiple devices
+	- Konqueror's progress metre/device lockup on file close()
+
+Instructions:
+
+	1. patch your kernel
+	2. run 'make [menu|x]config' to enable 'file systems'=>'iRiverFS' as a module.
+	3. make modules; make modules install; insmod /lib/modules/.../fs/iriver/iriver.ko
+	4. mount -t iriver none /mnt/somewhere
+	5. ls /mnt/somewhere
+
+	You can also compile the driver directly into the kernel.
+
+	MOUNT OPTIONS
+
+	dmask=###	-- The permission mask for directories.
+	fmask=###	-- The permission mask for files.
+	uid=# gid=#	-- The owner and group of the files.  (Default
+			values are the user that mounted the filesystem.)
+
+Troubleshooting:
+
+	- take a look at the kernel log files.  (`dmesg` or /var/log/kern.log)
+	- reset the device or unplug it & try again.  (If mount reports the
+	  device is "busy" and you aren't using it elsewhere, try this.)
+
+	If you still can't get it working, please email me with your
+		-kernel messages [relavent ones]
+		-kernel version
+		-the patch version
+		-iFP model number
+		-iFP firmware version
+		-your favourite colour
+	
+	In particular, please email me these lines from the kernel messages:
+
+		iRiverFS: detected a iFP-0xx series device.
+		iRiverFS: model IFP-007T, firmware 1.14, battery =[####], delta 1.8.4.42
+
+Credits:
+
+	Special thanks to Boris and Jim who were the first brave souls to try
+	the driver.  Thanks to David who took the time to debug iFP8xx support
+	and to the folks on #kernelnewbies who made helpful suggestions when I
+	was stuck.  Everyone has been encouraging and helpful with their
+	feedback, and is much appreciated.
+
+	Lastly, thanks to Jordan who bought me the mp3 player.  You know how
+	kids often enjoy playing with the box more than the toy inside?  Well,
+	writing the driver has been a neat learning experience.. and the
+	packaging came with top-grade bubblewrap. :)
+
+Bibliography:
+    -ifp-driver by Pavel Kriz and Yamashiro, Jun
+    -ramfs driver by Linus Torvalds and David Gibson
+    -Discussion on the ifp-driver mailing list.
+    -"understanding the linux kernel"
+    
+Thoughts:
+
+This was my main concern when I started writing this driver.  I don't believe
+this is much of an issue anymore, but I'd like to keep the notes around until
+they've been ruled out.
+
+/*
+ * Notes about iRiver's hardware:
+ *
+ * I've found the hardware frequently goes 'out to lunch' at which point it is
+ * mostly useless until it is reset().  (Unfortunately, reset() doesn't always
+ * fix the problem.)
+ *
+ * 'Out to lunch' behaviour has included:
+ *
+ *      -directory listings return garbage strings as filenames
+ *      -directory listings return the filenames for a previous
+ *       listing.
+ *      -uploaded files are renamed or moved.  Eg:
+ *              requested: '\overtures\6.Mozart-Marriage_of_Figaro.ogg'
+ *              actual:    '\f_Figaro.ogg'
+ *      -uploaded files don't.  Zero-byte files are created instead.
+ *       The user might notice the transfer was faster than normal.
+ *
+ * To cope with this, the driver keeps all inodes and dentries in memory to
+ * minimize interaction with the hardware.  Future development could use the
+ * cache to detect 'out to lunch' behaviour.
+ *
+ * Note that the device can silently go 'out to lunch', particularily during a
+ * file transfer.  I think the best way of copeing is to detect this early and
+ * alert the user so they don't waste time using a device they believe to be
+ * functional.
+ *
+ */
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/Kconfig linux-2.6.9-iriverfs-stable/fs/Kconfig
--- linux-2.6.9/fs/Kconfig	2004-10-18 17:54:32.000000000 -0400
+++ linux-2.6.9-iriverfs-stable/fs/Kconfig	2004-10-23 11:42:21.000000000 -0400
@@ -402,6 +402,67 @@ config ROMFS_FS
 	  If you don't know whether you need it, then you don't need it:
 	  answer N.
 
+config IRIVER_FS
+	tristate "iRiver IFP 'Manager' interface (EXPERIMENTAL)"
+	depends on NLS && USB && EXPERIMENTAL
+	default m
+	---help---
+	  There are two kinds of firmware available for iRiver's iFP (flash
+	  based) mp3 players: UMS and 'Manager'.  The former causes the device
+	  to act as a mass storage device, while the latter needs special
+	  support.  This driver allows you to mount those devices as
+	  filesystems.
+	  
+	  Please note: if you use 'UMS' firmware, you will not need this
+	  driver--the USB mass storage drivers should suffice.
+	  
+	  To compile this as a module, choose M here: the module will be called
+	  iriver.
+
+config IRIVER_FS_RENAME
+	bool "iRiver rename/move support (EXPERIMENTALer)"
+	depends on IRIVER_FS
+	default y
+	help
+	  File and directory renaming appears to be working, and the few bugs
+	  that have been found (and fixed) haven't caused serrious damage (if
+	  any) to the directory structure.  However, because there's the
+	  potential to corrupt the fs meta, I thought you should be warned.
+	  
+	  It's mostly safe to say Y here.
+
+config IRIVER_FS_DEBUG_USB
+	bool "iRiver debugging"
+	depends on IRIVER_FS
+	default n
+	help
+	  Enables low-level logging, which records communication between the
+	  device and this driver.  If you are experiencing any problems, it
+	  would be helpful to say Y here but submit the log with the bug
+	  report.
+
+	  Unless something's wrong, say N.
+
+config IRIVER_FS_DEBUG_VFS
+	bool "iRiver log VFS context"
+	depends on IRIVER_FS_DEBUG_USB
+	default n
+	help
+	  Logs most filesystem calls.  This is usually used to give some
+	  context to the above device log.
+
+	  Unless something's wrong, say N.
+
+config IRIVER_FS_DEBUG_USB_RAW
+	bool "iRiver log raw data packets"
+	depends on IRIVER_FS_DEBUG_USB
+	default n
+	help
+	  Logs all data transfers with the device.  This will generate a large
+	  ammount of data.. especially if files are transfered.
+
+	  Unless something's wrong, say N.
+
 config QUOTA
 	bool "Quota support"
 	help
diff -uprN -X ../dontdiff linux-2.6.9/fs/Makefile linux-2.6.9-iriverfs-stable/fs/Makefile
--- linux-2.6.9/fs/Makefile	2004-10-18 17:54:32.000000000 -0400
+++ linux-2.6.9-iriverfs-stable/fs/Makefile	2004-10-23 11:42:21.000000000 -0400
@@ -51,6 +51,7 @@ obj-$(CONFIG_JBD)		+= jbd/
 obj-$(CONFIG_EXT2_FS)		+= ext2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
 obj-$(CONFIG_RAMFS)		+= ramfs/
+obj-$(CONFIG_IRIVER_FS)		+= iriver/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
 obj-$(CONFIG_MINIX_FS)		+= minix/
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/Makefile linux-2.6.9-iriverfs-stable/fs/iriver/Makefile
--- linux-2.6.9/fs/iriver/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/Makefile	2004-09-12 15:22:01.000000000 -0400
@@ -0,0 +1,9 @@
+# IRiver ifp filesystem driver for Linux
+# Revision: $Id$
+#
+# Copyright (C) 2004 Geoff Oakham <oakhamg@users.sourceforge.net>
+
+obj-$(CONFIG_IRIVER_FS) += iriver.o
+
+iriver-objs := inode.o ifp_prim.o ifp_comp.o ifp_readwrite.o ifp_os_linux.o \
+	ifp_dentry.o
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp.h linux-2.6.9-iriverfs-stable/fs/iriver/ifp.h
--- linux-2.6.9/fs/iriver/ifp.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp.h	2004-10-04 10:23:17.000000000 -0400
@@ -0,0 +1,185 @@
+/*
+ * Interface for accessing iRiver's IFP devices
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ *
+ * This driver is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free
+ * Software Foundation; only version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License in the
+ * files "COPYING" or "COPYING.iriverfs"; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef IFP_H
+#define IFP_H 1
+
+#include "ifp_os.h"
+
+//These can all be enabled from the "make menuconfig" interface now
+//#define IFP_DEBUG_SYSCALL 1
+//#define IFP_DEBUG_USB_SNOOPING	1
+//#define IFP_DEBUG_USB_RAWDATA	1
+
+#define IFP_BULK_MAXPATHLEN	0x400 //ie, utf16
+#define IFP_MAXPATHLEN		0x200 //ie, utf8
+#define IFP_BUFFER_SIZE		IFP_BULK_MAXPATHLEN
+
+#define IFP_BULK_BUFF_BITS 14
+#define IFP_BULK_BUFF_SIZE 0x4000
+
+//Members of this structure are considered private (ie for internal use only).
+//A future version may replace this definition with a forward declaration.
+struct ifp_device {
+	int bulk_to;
+	int bulk_from;
+	int model; //decimal: eg 100, 300, 500, 700, 800
+	//do we need access to the firmware version as well?
+	
+	//These buffers are use for servicing individual function calls.  Contents
+	//are not preserved between calls.
+	
+	//b1 is used by:
+	//	push_unicode
+	//	pop_unicode
+	//	ifp_dir_next_debug
+	//	ifp_set_fat_page
+	ifp_u8 b1[IFP_BUFFER_SIZE];
+
+	//b2 is used by:
+	//	swap_fat_entries	(ifp_rename* helper)
+	//	_ifp_list_dirs_debug	(ifp_rename* helper)
+	//	_ifp_list_dirs		(ifp_list_dirs helper)
+	//	ifp_device_info
+	ifp_u8 b2[IFP_BUFFER_SIZE];
+
+	//b3 is used by:
+	//	swap_fat_entries	(ifp_rename* helper)
+	//	swap_filenames		(ifp_rename* helper)
+	//	get_file_size		(_ifp_list_dirs helper)
+	ifp_u8 b3[IFP_BUFFER_SIZE];
+
+	//The following data is state that persists between library calls.
+	int last_buffer_size;
+
+	#define IFP_MODE_NONE (0)
+	#define IFP_MODE_READING (1)
+	#define IFP_MODE_WRITING (2)
+
+	//data buffer.  Contains the last block read, or part of the block
+	//being written.  The current position (for reading or writing) is
+	//current_offset % IFP_BULK_BUFF_SIZE.
+	ifp_u8 iobuff[IFP_BULK_BUFF_SIZE];
+
+	int mode;
+	loff_t current_offset;
+	loff_t filesize;
+	ifp_u8 dirname[IFP_BUFFER_SIZE];
+	ifp_u8 filename[IFP_BUFFER_SIZE];
+
+	//sanity counters
+	int readcount;
+	int alt_readcount;
+
+	//usb device handle (system-specific)
+	void * private;
+};
+
+#define IFP_FILE                1
+#define IFP_DIR                 2
+
+int ifp_init(struct ifp_device * dev, void * dev_handle);
+int ifp_finalize(struct ifp_device * dev);
+
+int ifp_selftest(struct ifp_device * dev);
+
+//status and misc
+int ifp_device_info(struct ifp_device * dev, char * s, int n);
+int ifp_battery(struct ifp_device * dev);
+int ifp_capacity(struct ifp_device * dev);
+int ifp_freespace(struct ifp_device * dev); //better name?
+int ifp_model(struct ifp_device * dev, char * s, int n);
+int ifp_delta(struct ifp_device * dev, int * values);  //int values[4]
+//returns a raw bcd value.  For human consumption, I suggest ("%x.%02x", r/0x100, r%0x100).
+int ifp_firmware_version(struct ifp_device * dev);
+
+// reading files
+int ifp_read_open(struct ifp_device * dev, char * f, int n);
+int ifp_read_close(struct ifp_device * dev);
+int ifp_read_seek(struct ifp_device * dev, int abs_position);
+	//returns the actual number of bytes read
+int ifp_read_data(struct ifp_device * dev, void * buff, int bytes);
+int ifp_read_eof(struct ifp_device * dev);
+
+// writing files
+int ifp_write_open(struct ifp_device * dev, char * f, int n, int fsize);
+int ifp_write_close(struct ifp_device * dev);
+int ifp_write_data(struct ifp_device * dev, void * buff, int bytes);
+
+// rename
+// API TOUGHT: would it be better for the library to detect if the
+// remote thing is a file/dir and call the appropriate method?  The
+// advantage to this solution, is we don't have to issue a test if
+// the caller knows ahead of time what they are doing.
+//
+// 	-decide if this works for files and directories or just files.
+int ifp_rename_file(struct ifp_device * dev,
+	char * old_file, char * new_file, int maxlength);
+int ifp_rename_dir(struct ifp_device * dev,
+	char * old_file, char * new_file, int maxlength);
+
+// metadata (file & directory) manipulation
+int ifp_delete(struct ifp_device * dev, char * f, int n);
+int ifp_mkdir(struct ifp_device * dev, char * f, int n);
+int ifp_rmdir(struct ifp_device * dev, char * f, int n);
+
+//The callback should return 0 on succes or 1 to stop without error.
+//(Any other value will be interpreted as an error.)  The parameters are:
+//	int callbk(void * context, int type, char * name, int n, int filesize)
+//'type' is either IFP_FILE or IFP_DIR
+//'filesize' is undefined for directories,
+//'name' is the file or directory name *without* its path
+//'context' can be NULL.
+//
+//API THOUGHT: consider passing in the full path
+int ifp_list_dirs(struct ifp_device * dev, char * dirname, int n,
+	int(*callbk)(void *, int, char *, int, int),
+	void * context);
+
+#ifdef IFP_FUTURE
+//boolean tests
+int ifp_is_file(struct ifp_device * dev, char * f, int n);
+int ifp_is_dir (struct ifp_device * dev, char * f, int n);
+//returns IFP_FILE, IFP_DIR, 0 (none), or <0 (error)
+int ifp_exists (struct ifp_device * dev, char * f, int n);
+
+int ifp_file_size(struct ifp_device * dev, char * f, int n);
+
+int ifp_read_filesize(struct ifp_device * dev);
+int ifp_read_pos(struct ifp_device * dev);
+
+//missing functionality:
+int ifp_format(struct ifp_device * dev);
+//int ifp_update_firmware(struct ifp_device * dev);
+
+#ifndef __KERNEL__
+//userland-only convience functions
+int ifp_read_file(struct ifp_device * dev, FILE * dst, char * path, int n);
+int ifp_write_file(struct ifp_device * dev, char * path, int n, FILE * src);
+
+//for user feedback
+int ifp_read_file_progress(struct ifp_device * dev, FILE * dst, char * path,
+	int n,      int(*progress)(void *, int), void * context);
+int ifp_write_file_progress(struct ifp_device * dev, char * path, int n,
+	FILE * src, int(*progress)(void *, int), void * context);
+#endif
+#endif
+#endif // IFP_H
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp_comp.c linux-2.6.9-iriverfs-stable/fs/iriver/ifp_comp.c
--- linux-2.6.9/fs/iriver/ifp_comp.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp_comp.c	2004-10-04 10:23:17.000000000 -0400
@@ -0,0 +1,554 @@
+/*
+ * ifp supporting functions.. "compound" ones
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#include "ifp.h"
+#include "ifp_os.h"
+#include "ifp_prim.h"
+
+//quick hack
+#define IFP_ENOENT 2
+#define IFP_EIO    5
+
+static char * battery_status_art [] = {
+    "=[    ]",
+    "=[#   ]",
+    "=[##  ]",
+    "=[### ]",
+    "=[####]",
+};
+
+int ifp_device_info(struct ifp_device * dev, char * s, int n) {
+    char * p = dev->b2;
+    char * battery_info = NULL;
+    int i = 0;
+    int version, battery;
+    int deltas[4];
+
+    i = ifp_model(dev, p, IFP_BUFFER_SIZE);
+    if (i) {
+        ifp_err_i(i, "error getting model number.");
+        p[0] = '-';
+        p[1] = '\0';
+    }
+
+    version = ifp_firmware_version(dev);
+    if (version < 0) {
+        ifp_err_i(version, "error getting firmware version.");
+        i = version;
+    }
+
+    battery = ifp_battery(dev);
+    if (battery < 0) {
+        ifp_err_i(battery, "error getting firmware version.");
+        battery_info = "=[fubr]";
+        i = battery;
+    } else if (battery > 4) {
+        battery_info = "=[????]";
+    } else {
+        battery_info = battery_status_art[battery];
+    }
+
+    i = ifp_delta(dev, deltas);
+    if (i) {
+        ifp_wrn("problem getting delta value (error code %d).", i);
+        //experimental feature, don't return the error
+        i = 0;
+    }
+
+    snprintf(s, n, "model %s, firmware %x.%02x, battery %s"
+            ", delta %d.%d.%d.%d"
+            , p, version/0x100, version % 0x100, battery_info
+            , deltas[0], deltas[1], deltas[2], deltas[3]
+            );
+
+    return i;
+}
+
+static int noop_dir_callbk(void * p, int t, char * s, int n, int fs)
+{
+    int * pn = p;
+    if (*pn == 5) {
+        //return early--save time.
+        return 1;
+    }
+    (*pn)++;
+    return 0;
+}
+
+int ifp_selftest(struct ifp_device * dev) {
+    int i = 0;
+    int n = 0;
+
+    i = ifp_firmware_version(dev);
+    if (i < 0) {
+        ifp_err_i(i, "couldn't get firmware version.");
+        return i;
+    }
+
+    i = ifp_battery(dev);
+    if (i < 0) {
+        ifp_err_i(i, "couldn't get battery status.");
+        return i;
+    }
+
+    i = ifp_list_dirs(dev, "\\", 1, noop_dir_callbk, &n);
+    if (i) {
+        ifp_err_i(i, "couldn't get basic directory listing.");
+        return i;
+    }
+
+    if (n < 3) {
+        ifp_wrn("only %d items could be found in the root directory.  Either there's a problem, or the device is empty.", n);
+    }
+
+    return i;
+}
+
+static int touch(struct ifp_device * dev, char * dir, char * file, int n)
+{
+	int i = 0;
+
+	//ifp_dbg("[ifp touch] touching %s\n", (char *)file);
+	//ifp_dbg("[ifp touch] in %s\n", (char *)dir);
+
+	i = ifp_dir_open(dev, dir, n);
+        ifp_err_jump(i, out, "couldn't open dir.");
+	i = ifp_file_open_new(dev, file, n, 0);
+        ifp_err_jump(i, out, "couldn't create file.");
+	i = ifp_file_close(dev);
+        ifp_err_jump(i, out, "couldn't close file.");
+	i = ifp_dir_close(dev);
+        ifp_err_jump(i, out, "couldn't close dir.");
+
+out:
+	return i;
+}
+
+int _ifp_list_dirs_debug(
+	struct ifp_device * dev,
+	char * name, int n,
+	int(*callbk)(void *, int, char *, int, int, int, int),
+	void * context)
+{
+	//unsigned char utf8_buf[IFP_BULK_MAXPATHLEN];
+	ifp_u8 * utf8_buf = dev->b2;
+	int i = 0;
+
+	i = ifp_dir_open(dev, name, n);
+	ifp_err_jump(i, out, "dir.open failed.");
+
+	while(1) {
+		int dir, page, offset, chipmunk;
+		int ret;
+		ret = ifp_dir_next_debug(dev, utf8_buf, IFP_BUFFER_SIZE,
+			IFP_FILE|IFP_DIR, &dir, &page, &offset, &chipmunk);
+		if (ret < 0) {
+			ifp_err_i(ret, "error sending dir.next.");
+			i = ret; goto out;
+		} else if (ret == 0) {
+			//ifp_dbg("Done.");
+			break;
+		} else {
+			i = callbk(context, ret, utf8_buf,
+				strnlen(utf8_buf, IFP_BUFFER_SIZE),
+				dir, page, offset);
+			if (i < 0) {
+				ifp_err_i(i, "callback returned error.");
+				break;
+			} else if (i == 1) {
+				//ifp_dbg("callback requested early break.");
+				break;
+			} else if (i != 0) {
+				ifp_err_i(i, "callback returned a wierd value.");
+				i = -1;
+				goto out;
+			} else {
+				//ifp_dbg("callback returned %d for '%s'.",
+				//	i, utf8_buf);
+			}
+		}
+	}
+
+	i = ifp_dir_close(dev);
+	ifp_err_jump(i, out, "dir.close failed.");
+
+	i = 0;
+out:
+	return i;
+}
+
+static int get_id_callback(void * context, int type, char * name, int n,
+	int dir, int page, int offset)
+{
+	void ** pp = (void **) context;
+	char * target = pp[0];
+	int * target_width = pp[1];
+	int * pdir = pp[2];
+	int * ppage = pp[3];
+	int * poffset = pp[4];
+	int * found = pp[5];
+
+	//ifp_dbg("dir=%#x page=%#x, offset=%#x, name='%s'", dir, page, offset, name);
+	if ( *target_width == n) {
+		if (strncmp(target, name, n)==0)
+		{
+			//printk("[get_id_callback] '%s' matches '%s'.\n",
+			//	target, name);
+			*pdir = dir;
+			*ppage = page;
+			*poffset = offset;
+			*found = 1;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int get_file_id(struct ifp_device * dev, char * dir, char * file, int n,
+	int * id_dir, int * id_page, int * id_off)
+{
+	int i = 0;
+	int filelen;
+	int dirlen;
+	int found = 0;
+	void ** context[6] = {(void*)file, (void*)&filelen, (void*)id_dir,
+		(void*)id_page, (void*)id_off, (void*)&found};
+	dirlen = strnlen(dir, n);
+	//one extra for the path separator
+	filelen = strnlen(file, n) - dirlen;
+	file += dirlen;
+	if (dirlen > 1) {
+		filelen--;
+		file++;
+	}
+	//ifp_dbg("file='%s', filelen=%d, dir='%s', dirlen=%d", file, filelen,
+	//	dir, dirlen);
+	if (filelen < 0) {
+		ifp_err_i(i, "bailing");
+		return -1;
+	}
+	IFP_BUG_ON(filelen < 0);
+	context[0] = (void *)(file);
+
+	//FIXME: return an error on not finding a matching entry.
+	i = _ifp_list_dirs_debug(dev, dir, n, get_id_callback, (void *)context);
+	ifp_err_jump(i, out, "list failed.");
+	if (found == 0) {
+		ifp_err("entry not found for dir='%s' file='%s'", dir, file);
+		i = -1;
+	}
+	//ifp_dbg("returning dir=%#x, page=%#x, off=%#x", *id_dir, *id_page, *id_off);
+
+out:
+	return i;
+}
+
+static inline int calc_fat_address(
+	int base_page,
+	int slot_number,
+	int record_offset,
+	int * page,
+	int * offset
+	)
+{
+	const int page_size  = 0x0200;
+	const int slot_width = 0x0020;
+	IFP_BUG_ON(page == NULL);
+	IFP_BUG_ON(offset == NULL);
+
+	*page = base_page;
+	*offset = slot_width * slot_number + record_offset;
+
+	if (*offset >= page_size) {
+		(*page) += *offset / page_size;
+		(*offset) %= page_size;
+	}
+	return 0;
+}
+
+
+static int swap_fat_entries(struct ifp_device * dev,
+	int id_dirA, int id_pageA, int id_offA,
+	int id_dirB, int id_pageB, int id_offB)
+{
+	const int data_ptr_size = 8;
+	const int page_size  = 0x0200;
+	ifp_u8 tmp[data_ptr_size];
+
+	ifp_u8 * _buffA = dev->b2, * _buffB = dev->b3;
+	ifp_u8 * buffA = _buffA, * buffB = _buffB;
+
+	int i = 0;
+
+	i = calc_fat_address(id_pageA, id_offA, 0x040 - data_ptr_size,
+		&id_pageA, &id_offA);
+	ifp_err_jump(i, out, "cal failed. (a)");
+
+	i = calc_fat_address(id_pageB, id_offB, 0x040 - data_ptr_size,
+		&id_pageB, &id_offB);
+	ifp_err_jump(i, out, "cal failed. (b)");
+
+	i = ifp_get_fat_page(dev, id_dirA, id_pageA, _buffA, page_size);
+	ifp_err_jump(i, out, "read failed for page=%#x, dir=%#x (a)",
+		id_pageA, id_dirA);
+
+	if (id_dirA == id_dirB && id_pageA == id_pageB) {
+		//ifp_dbg("same page number, using same buffers.");
+		buffB = _buffA;
+	} else {
+		i = ifp_get_fat_page(dev, id_dirB, id_pageB, _buffB, page_size);
+		ifp_err_jump(i, out, "read failed for page=%#x, dir=%#x (b)",
+			id_pageB, id_dirB);
+	}
+
+	buffA += id_offA;
+	buffB += id_offB;
+
+	memcpy(tmp,   buffA, data_ptr_size);
+	memcpy(buffA, buffB, data_ptr_size);
+	memcpy(buffB, tmp,   data_ptr_size);
+
+	i = ifp_set_fat_page(dev, id_dirA, id_pageA, _buffA, page_size);
+	ifp_err_jump(i, out, "write failed. (a)");
+
+	if (id_dirA != id_dirB || id_pageA != id_pageB) {
+		i = ifp_set_fat_page(dev, id_dirB, id_pageB, _buffB, page_size);
+		ifp_err_jump(i, out, "write failed. (b)");
+	}
+
+out:
+
+	return i;
+}
+
+static int swap_filenames(struct ifp_device * dev,
+	char * oldpath, char * newpath, int max_string)
+{
+	int id_dirA, id_dirB, id_pageA, id_pageB, id_offA, id_offB;
+	int i;
+	char * b = dev->b3;
+
+	i = ifp_copy_parent_string(b, oldpath, max_string);
+	ifp_err_jump(i, out, "getting parent directory of %s failed.",oldpath);
+	i = get_file_id(dev, b, oldpath, max_string,
+		&id_dirA, &id_pageA, &id_offA);
+	ifp_err_jump(i, out, "file_id failed. (a)");
+
+	i = ifp_copy_parent_string(b, newpath, max_string);
+	ifp_err_jump(i, out, "getting parent directory of %s failed.",newpath);
+	i = get_file_id(dev, b, newpath, max_string,
+		&id_dirB, &id_pageB, &id_offB);
+	ifp_err_jump(i, out, "file_id failed. (b)");
+
+	//uses b1,b2,b3.
+	i = swap_fat_entries(dev, id_dirA, id_pageA, id_offA,
+				id_dirB, id_pageB, id_offB);
+	ifp_err_jump(i, out, "swap failed. "
+		"dirA=%#x, pageA=%#x, offA=%#x, dirB=%#x, pageB=%#x, offB=%#x",
+		id_dirA, id_pageA, id_offA, id_dirB, id_pageB, id_offB);
+
+out:
+	return i;
+}
+
+int ifp_rename_file(struct ifp_device * dev,
+	char * old_file, char * new_file, int max_string)
+{
+	int i;
+	char * b = dev->b3;
+
+	i = ifp_copy_parent_string(b, new_file, max_string);
+	ifp_err_jump(i, out, "getting parent directory of %s failed.",new_file);
+	i = touch(dev, b, new_file, max_string);
+	ifp_err_jump(i, out, "Touch failed.");
+
+	i = swap_filenames(dev, old_file, new_file, max_string);
+	ifp_err_jump(i, out, "filename swap failed.");
+
+	i = ifp_delete(dev, old_file, max_string);
+	ifp_err_jump(i, out, "delete failed.");
+
+out:
+	return i;
+}
+
+int ifp_rename_dir(struct ifp_device * dev,
+	char * old_dir, char * new_dir, int max_string)
+{
+	int i;
+
+	i = ifp_mkdir(dev, new_dir, max_string);
+	ifp_err_jump(i, out, "mkdir failed.");
+
+	i = swap_filenames(dev, old_dir, new_dir, max_string);
+	ifp_err_jump(i, out, "filename swap failed.");
+
+	i = ifp_rmdir(dev, old_dir, max_string);
+	ifp_err_jump(i, out, "rmdir failed.");
+
+out:
+	return i;
+}
+
+static int get_file_size(struct ifp_device * dev,
+	char * dir, int dsize,
+	char * f, int fsize)
+{
+	int size = 0;
+	int i;
+	ifp_u8 * buf = dev->b3;
+	ifp_u8 * p = buf;
+	int dlen, flen;
+
+	dlen = strnlen(dir, dsize);
+	flen = strnlen(f, fsize);
+	IFP_BUG_ON(dlen + flen + 2 >= IFP_BULK_MAXPATHLEN);
+	memcpy(p, dir, dlen); p += dlen;
+	if (dlen > 1) {
+		//if dir ls simply \ we don't want to make it \\.
+		*p = '\\'; p++;
+	}
+	memcpy(p, f, flen); p += flen;
+	*p = 0; p++;
+
+
+	i = ifp_file_open(dev, buf, IFP_BULK_MAXPATHLEN);
+	if (i == 1) {
+        	ifp_err("The file '%s' doesn't exist!", buf);
+		return -IFP_ENOENT;
+	} else if (i) {
+        	ifp_err_i(i, "Error opening file '%s'.", buf);
+		return i < 0 ? i : -IFP_EIO;
+	}
+
+	size = ifp_file_size(dev);
+	if (size < 0) {
+        	ifp_err_i(size, "Error getting size of '%s'.", buf);
+		//fallthrough
+	}
+	i = ifp_file_close(dev);
+	if (i) {
+        	ifp_err_i(i, "Error closing file '%s'.", buf);
+		return i < 0 ? i : -IFP_EIO;
+	}
+
+	return size;
+}
+
+int _ifp_list_dirs(
+	struct ifp_device * dev,
+	char * dirname, int dsize,
+	int type,
+	int(*callbk)(void *, int, char *, int, int),
+	void * context)
+{
+	ifp_u8 * utf8_buf = dev->b2;
+	int i = 0;
+
+	IFP_BUG_ON(sizeof(dev->b2) < IFP_BULK_MAXPATHLEN);
+
+	while(1) {
+		int ret;
+		ret = ifp_dir_next(dev, utf8_buf, IFP_BULK_MAXPATHLEN, type);
+		//IFP_FILE|IFP_DIR)
+		if (ret < 0) {
+        		ifp_err_i(ret, "Error sending control message dir.next.");
+			i = ret;
+			return i;
+		} else if (ret == 0) {
+			//ifp_dbg("Done.");
+			break;
+		} else {
+			int filesize = 0;
+			if (ret == IFP_FILE) {
+				filesize = get_file_size(dev,
+					dirname, dsize, utf8_buf,
+					IFP_BULK_MAXPATHLEN);
+			}
+			if (filesize < 0) {
+        			ifp_err_i(filesize, "Error getting filesize.");
+				return filesize;
+			}
+
+			i = callbk(context, ret, utf8_buf, strlen(utf8_buf),
+				filesize);
+			if (i < 0) {
+        			ifp_err_i(i, "Callback returned error.");
+				return i;
+			} else if (i == 1) {
+				//ifp_dbg("[_ifp_list_dirs] callback requested early break.\n");
+				break;
+			} else if (i != 0) {
+        			ifp_err_i(i, "Callback returned a wierd value.");
+				return -IFP_EIO;
+			}
+		}
+	}
+
+	i = 0;
+	return i;
+}
+
+int ifp_list_dirs(
+	struct ifp_device * dev,
+	char * filename, int n,
+	int(*callbk)(void *, int, char *, int, int),
+	void * context)
+{
+	int i = 0;
+
+	i = ifp_dir_open(dev, filename, n);
+	ifp_err_jump(i, out, "dir.open failed.");
+
+	i = _ifp_list_dirs(dev, filename, n, IFP_FILE|IFP_DIR, callbk, context);
+	ifp_err_jump(i, out, "_list_dirs failed.");
+
+	i = ifp_dir_close(dev);
+	ifp_err_jump(i, out, "dir.close failed.");
+
+out:
+	return i;
+}
+
+static int _subdir_counter(void * context, int type, char * name, int n, int size)
+{
+	int * pn = context;
+	(*pn) += 1;
+
+	return 0;
+}
+
+int ifp_count_subdirs(struct ifp_device * dev, char * dirname, int sn)
+{
+	int i = 0;
+	int n = 0;
+
+	i = ifp_dir_open(dev, dirname, sn);
+	if (i) {
+		ifp_err_i(i, "dir_open failed");
+		return i;
+	}
+
+	i = _ifp_list_dirs(dev, dirname, sn, IFP_DIR, _subdir_counter, &n);
+	if (i) {
+		ifp_err_i(i, "ifp_list_dirs failed");
+		return i;
+	} else {
+		IFP_BUG_ON(n < 0);
+	}
+
+	i = ifp_dir_close(dev);
+	if (i) {
+		ifp_err_i(i, "dir_close failed");
+		return i;
+	}
+
+	return n;
+}
+
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp_dentry.c linux-2.6.9-iriverfs-stable/fs/iriver/ifp_dentry.c
--- linux-2.6.9/fs/iriver/ifp_dentry.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp_dentry.c	2004-09-29 20:24:27.000000000 -0400
@@ -0,0 +1,234 @@
+/*
+ * Kernel-friendly wrappers for many public ifp function.
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/statfs.h>
+#include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
+#include <linux/usb.h>
+#include <linux/nls.h>
+#include <linux/writeback.h>
+#include <linux/mpage.h>
+#include <linux/ctype.h>
+
+#include <asm/uaccess.h>
+
+#include "iriverfs.h"
+#include "ifp.h"
+#include "ifp_os.h"
+#include "ifp_prim.h"
+
+#if defined(__KERNEL__)
+
+int make_path_string(struct dentry * target, struct dentry * root, char separator,
+		char * out, int maxlen)
+{
+	if (target == root) {
+		out[0] = separator;
+		out[1] = '\0';
+		return sizeof(separator);
+	} else {
+		struct dentry * d;
+		char * pos;
+		int len = 0;
+
+		for (d = target; d && d != root; d = d->d_parent) {
+			//for the path separator
+			len += sizeof(separator);
+			len += d->d_name.len;
+		}
+		if (len + 1 > maxlen) {
+			printk("make_path_string: buffer (%d) too small for path (%d)\n", maxlen, len);
+			return -1;
+		}
+
+		pos = out + len;
+		*pos = '\0';
+		for (d = target; d && d != root; d = d->d_parent) {
+			pos -= d->d_name.len;
+			memcpy(pos, d->d_name.name, d->d_name.len);
+
+			pos -= sizeof(separator);
+			*pos = separator;
+		}
+
+		BUG_ON(pos != out);
+		return len;
+	}
+}
+
+//The convience methods..
+static inline int call_dentry_as_utf8(
+	struct ifp_device * dev, struct dentry * d,
+	int(* fn)(struct ifp_device * dev, char *, int n)
+	)
+{
+	//u8 buf[IFP_BUFFER_SIZE];
+	u8 * buf = get_iriver_buffer();
+	int i, tsize;
+
+	tsize = make_path_string(d, d->d_sb->s_root, '\\', buf, IFP_BUFFER_SIZE);
+	if (tsize < 0) {
+		printk("[call_dentry_as_utf8]: error creating pathname for %ld, err %d\n",
+			d->d_inode->i_ino, tsize);
+		i = tsize;
+		goto out;
+	}
+	i = fn(dev, buf, IFP_BUFFER_SIZE);
+	if (i < 0) {
+		make_path_string(d, d->d_sb->s_root, '/', buf, IFP_BUFFER_SIZE);
+		printk("[call_dentry_as_utf8] fn failed on ifp:/%s, err %d\n", buf, i);
+	}
+
+out:
+	put_iriver_buffer(buf); buf = NULL;
+	return i;
+}
+
+int ifp_file_open_new_d(struct ifp_device * dev, struct dentry * d, int filesize)
+{
+	//u8 buf[IFP_BUFFER_SIZE];
+	u8 * buf = get_iriver_buffer();
+	int i, tsize;
+
+	tsize = make_path_string(d, d->d_sb->s_root, '\\', buf, IFP_BUFFER_SIZE);
+	if (tsize < 0) {
+		printk("[call_dentry_as_utf8]: error creating pathname for %ld, err %d\n",
+			d->d_inode->i_ino, tsize);
+		i = tsize;
+		goto out;
+	}
+
+	i = ifp_file_open_new(dev, buf, IFP_BUFFER_SIZE, filesize);
+	if (i) {
+		make_path_string(d, d->d_sb->s_root, '/', buf, IFP_BUFFER_SIZE);
+		printk("[ifp_file_open_new_d] failed to create 'ifp:/%s', err %d\n", buf, i);
+	}
+out:
+	put_iriver_buffer(buf); buf = NULL;
+	return i;
+}
+
+int ifp_file_open_d(struct ifp_device * dev, struct dentry * d)
+{ return call_dentry_as_utf8(dev, d, ifp_file_open); }
+
+int ifp_dir_open_d(struct ifp_device * dev, struct dentry * d)
+{ return call_dentry_as_utf8(dev, d, ifp_dir_open); }
+
+int ifp_delete_d(struct ifp_device * dev, struct dentry * d)
+{ return call_dentry_as_utf8(dev, d, ifp_delete); }
+
+int ifp_mkdir_d(struct ifp_device * dev, struct dentry * d)
+{ return call_dentry_as_utf8(dev, d, ifp_mkdir); }
+
+int ifp_rmdir_d(struct ifp_device * dev, struct dentry * d)
+{ return call_dentry_as_utf8(dev, d, ifp_rmdir); }
+
+int ifp_read_open_d(struct ifp_device * dev, struct dentry * d)
+{ return call_dentry_as_utf8(dev, d, ifp_read_open); }
+
+int ifp_rename_d(struct ifp_device * dev,
+        struct dentry * old, struct dentry * new)
+{
+        int i;
+        struct super_block * sb = old->d_sb;
+        struct dentry * root = sb->s_root;
+
+        char * old_file = get_iriver_buffer();
+        char * new_file = get_iriver_buffer();
+
+        i = make_path_string(old          , root, '\\', old_file,
+                        IFP_BUFFER_SIZE);
+        if (i<0){printk("[rename_d] old file string, err %d.\n", i); goto out;}
+        i = make_path_string(new          , root, '\\', new_file,
+                        IFP_BUFFER_SIZE);
+        if (i<0){printk("[rename_d] new file string, err %d.\n", i); goto out;}
+
+	if (S_ISDIR(old->d_inode->i_mode)) {
+		i = ifp_rename_dir(dev, old_file, new_file, IFP_BULK_MAXPATHLEN);
+	} else {
+		i = ifp_rename_file(dev, old_file, new_file, IFP_BULK_MAXPATHLEN);
+	}
+
+out:
+        put_iriver_buffer(old_file);
+        put_iriver_buffer(new_file);
+        return i;
+}
+
+int ifp_list_dirs_d(
+        struct ifp_device * dev,
+        struct dentry * dentry,
+        int(*callbk)(void *, int, char *, int, int),
+        void * context)
+{
+        int i = 0;
+        u8 * dir = get_iriver_buffer();
+
+        i = make_path_string(dentry, dentry->d_sb->s_root, '\\', dir,
+                IFP_BULK_MAXPATHLEN);
+        if (i < 0) {
+                printk("[ifp_list_dirs_d] mkpath returned %d.\n", i);
+                goto out;
+        }
+
+        i = ifp_list_dirs(dev, dir, IFP_BULK_MAXPATHLEN, callbk, context);
+        if (i) {
+                printk("[ifp_list_dirs_d] ifp_list_dirs failed with err %d.\n", i);
+                goto out;
+        }
+
+out:
+        put_iriver_buffer(dir); dir = NULL;
+        return i;
+}
+
+int ifp_count_subdirs_d(struct ifp_device * dev, struct dentry * dentry)
+{
+        int i = 0;
+        u8 * s = get_iriver_buffer();
+        i = make_path_string(dentry, dentry->d_sb->s_root, '\\', s,
+                IFP_BULK_MAXPATHLEN);
+        if (i < 0) {
+                printk("[ifp_list_dirs_d] mkpath returned %d.\n", i);
+                goto out;
+        }
+        i = ifp_count_subdirs(dev, s, IFP_BULK_MAXPATHLEN);
+        if (i < 0) {
+                ifp_err_i(i, "ifp_count_subdirs failed.");
+        }
+out:
+        return i;
+}
+
+int ifp_write_open_d(struct ifp_device * dev, struct dentry * d, int filesize)
+{
+	int i = 0;
+	struct dentry * root = NULL;
+	char * file  = get_iriver_buffer();
+
+	root = d->d_sb->s_root;
+	i = make_path_string(d, root, '\\', file, IFP_BUFFER_SIZE);
+	if (i<0){printk("[ifp_write_open_d] file string, err %d.\n", i); goto out;}
+	i = ifp_write_open(dev, file, IFP_BUFFER_SIZE, filesize);
+	if (i) {
+		printk("[ifp_write_open_d] ifp_write_open failed, err %d\n", i);
+		goto out;
+	}
+
+out:
+	put_iriver_buffer(file); file = NULL;
+	return i;
+}
+
+#endif // __KERNEL__
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp_dentry.h linux-2.6.9-iriverfs-stable/fs/iriver/ifp_dentry.h
--- linux-2.6.9/fs/iriver/ifp_dentry.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp_dentry.h	2004-09-27 14:01:03.000000000 -0400
@@ -0,0 +1,41 @@
+/*
+ * Wrappers to part of the ifp API that take kernel-friendly args.
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#ifndef IFP_DENTRY_H
+#define IFP_DENTRY_H 1
+
+//Convience functions  -- these should form an ifp API for the kernel.
+//wrappers for the ifp-primatives.  Eventually, these could be replaced
+//with task-oriented functions.
+int ifp_file_open_d(struct ifp_device * dev, struct dentry * d);
+int ifp_file_open_new_d(struct ifp_device * dev, struct dentry * d, int filesize);
+int ifp_dir_open_d(struct ifp_device * dev, struct dentry * d);
+
+//utility -- to be removed later.
+int make_path_string(struct dentry * target, struct dentry * root,
+	char separator, char * out, int maxlen);
+
+//wrappers around stand-alone primatives.  By "stand-alone" I mean they're
+//atomic in that they don't create special states that have to be cleaned up.
+int ifp_delete_d(struct ifp_device * dev, struct dentry * d);
+int ifp_mkdir_d(struct ifp_device * dev, struct dentry * d);
+int ifp_rmdir_d(struct ifp_device * dev, struct dentry * d);
+
+int ifp_read_open_d(struct ifp_device * dev, struct dentry * d);
+int ifp_write_open_d(struct ifp_device * dev, struct dentry * d, int fsize);
+
+int ifp_rename_d(struct ifp_device * dev,
+	struct dentry * old_file, struct dentry * new_file);
+
+int ifp_list_dirs_d(struct ifp_device * dev, struct dentry * dentry,
+	int(*callbk)(void *, int, char *, int, int),
+	void * context);
+
+int ifp_count_subdirs_d(struct ifp_device * dev, struct dentry * dentry);
+
+#endif // IFP_DENTRY_H
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp_os.h linux-2.6.9-iriverfs-stable/fs/iriver/ifp_os.h
--- linux-2.6.9/fs/iriver/ifp_os.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp_os.h	2004-10-23 12:36:10.000000000 -0400
@@ -0,0 +1,158 @@
+/*
+ * linux-kernel specific functions
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#ifndef IFP_OS_H
+#define IFP_OS_H 1
+
+#ifdef __KERNEL__
+	#include <linux/autoconf.h>
+	#include <linux/version.h>
+//	#include <linux/byteorder/generic.h>
+	#include <linux/string.h>
+	#include <linux/kernel.h>
+	#include <linux/types.h>
+	#include <linux/nls.h>
+#else
+	#include <inttypes.h>
+	#include <stdio.h>
+	#include <sys/types.h>
+	#include <wchar.h>
+	#include <string.h>
+#endif
+
+struct ifp_device;
+
+int ifp_os_control_send(struct ifp_device * dev, int command,
+	int arg1, int arg2, int * r1, int * r2);
+
+int ifp_os_push(struct ifp_device * dev, void * p, int n);
+int ifp_os_pop(struct ifp_device * dev, void * p, int n);
+
+int ifp_os_init(struct ifp_device * dev, void * osdev);
+int ifp_os_finalize(struct ifp_device * dev);
+
+void * ifp_os_find_device(void);
+int ifp_os_release_device(void *);
+
+//int ifp_os_check_device(void *);
+
+//'ms' is time in milli-seconds (1/1000ths of a second)
+int ifp_os_sleep(int ms);
+
+#ifdef __KERNEL__
+
+#define ifp_os_err(fmt, arg...) printk(KERN_ERR fmt, ##arg)
+#define ifp_os_wrn(fmt, arg...) printk(KERN_WARNING fmt, ##arg)
+#define ifp_os_dbg(fmt, arg...) printk(KERN_DEBUG fmt, ##arg)
+#define ifp_os_info(fmt, arg...) printk(fmt, ##arg)
+#define ifp_os_print(fmt, arg...) printk(fmt, ##arg)
+
+#define IFP_BUG_ON BUG_ON
+
+#ifdef CONFIG_IRIVER_FS_RENAME
+#define IFP_RENAME
+#endif
+
+#ifdef CONFIG_IRIVER_FS_DEBUG_VFS
+#define IFP_DEBUG_SYSCALL 1
+#endif
+
+#ifdef CONFIG_IRIVER_FS_DEBUG_USB
+#define IFP_DEBUG_USB_SNOOPING 1
+	#ifdef CONFIG_IRIVER_FS_DEBUG_USB_RAW
+	#define IFP_DEBUG_USB_RAWDATA 1
+	#endif
+#endif
+
+#else //not __KERNEL__
+
+#define ifp_os_err(fmt, arg...) fprintf(stderr, "err:  " fmt, ##arg)
+#define ifp_os_wrn(fmt, arg...) fprintf(stderr, "wrn:  " fmt, ##arg)
+#define ifp_os_dbg(fmt, arg...) fprintf(stderr, "dbg:  " fmt, ##arg)
+#define ifp_os_info(fmt, arg...) fprintf(stderr, "info: " fmt, ##arg)
+#define ifp_os_print(fmt, arg...) fprintf(stderr, fmt, ##arg)
+
+#define IFP_BUG_ON(b) \
+	if (b) { ifp_os_print("bug assertion tripped in %s() at %s:%d", \
+		__FUNCTION__ , __FILE__ , __LINE__ ); }
+
+//stolen from linux/kernel.h
+#ifndef   min
+#  define min(x,y) ({ \
+	typeof(x) _x = (x);     \
+	typeof(y) _y = (y);     \
+	(void) (&_x == &_y);    \
+	_x < _y ? _x : _y; })
+#endif
+#ifndef   max
+#  define max(x,y) ({ \
+	typeof(x) _x = (x);     \
+	typeof(y) _y = (y);     \
+	(void) (&_x == &_y);    \
+	_x > _y ? _x : _y; })
+#endif
+
+#endif //__KERNEL__
+
+//I would like this moved into ifp.h because it's so useful our callers
+//might want to use it.
+#define ifp_err(fmt, arg...) ifp_os_err("[%s] " fmt "\n", __FUNCTION__ , ##arg)
+#define ifp_wrn(fmt, arg...) ifp_os_wrn("[%s] " fmt "\n", __FUNCTION__ , ##arg)
+#define ifp_dbg(fmt, arg...) ifp_os_dbg("[%s] " fmt "\n", __FUNCTION__ , ##arg)
+#define ifp_info(fmt, arg...) ifp_os_info(fmt "\n", ##arg)
+#define ifp_print(fmt, arg...) ifp_os_print(fmt, ##arg)
+
+#define ifp_err_i(i, fmt, arg...) ifp_err("err=%d. " fmt, i, ##arg)
+#define ifp_err_jump(i, label, fmt, arg...) \
+	if (i) { ifp_err_i(i, fmt, ##arg); goto label; }
+
+#define ifp_wrn_on(b, fmt, arg...) \
+	if (b) { ifp_wrn("warning: " fmt, ##arg); }
+
+int ifp_utf8_to_utf16(wchar_t * o, int max_o, char * i, int max_i);
+int ifp_utf16_to_utf8(char * o, int max_o, wchar_t * i, int max_i);
+
+/*  I truely wish this section didn't exist.. mostly because this is neither
+ *  the first nor last time I've written something like it.  Ideally, someone
+ *  like ANSI, ISO or even GCC would put their foot down and define standard
+ *  macros for handling portable data.
+ */
+
+//ripped from POSIX
+typedef uint8_t  ifp_u8;
+typedef uint16_t ifp_u16;
+typedef uint32_t ifp_u32;
+
+#if defined(__KERNEL__)
+
+#define ifp_os_cpu_to_le32  cpu_to_le32
+#define ifp_os_cpu_to_le16  cpu_to_le16
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+	#define ifp_os_le32_to_cpup le32_to_cpup
+	#define ifp_os_le16_to_cpup le16_to_cpup
+#else
+	//2.6.9+.. this needs to be cleaned up.
+	#define ifp_os_le32_to_cpup(x) (*(__force ifp_u32*)(x))
+	#define ifp_os_le16_to_cpup(x) (*(__force ifp_u16*)(x))
+#endif
+
+#else //kernel
+
+#if defined(i386)
+	//Little endian
+	#define ifp_os_cpu_to_le32(x) ((ifp_u32)(x))
+	#define ifp_os_cpu_to_le16(x) ((ifp_u16)(x))
+	#define ifp_os_le32_to_cpup(x) (*(ifp_u32*)(x))
+	#define ifp_os_le16_to_cpup(x) (*(ifp_u16*)(x))
+#else
+	//big endian
+	#error "big-endian processor supported unimplemented"
+#endif //endian
+#endif //kernel
+
+#endif // IFP_OS_H
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp_os_linux.c linux-2.6.9-iriverfs-stable/fs/iriver/ifp_os_linux.c
--- linux-2.6.9/fs/iriver/ifp_os_linux.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp_os_linux.c	2004-10-23 12:36:10.000000000 -0400
@@ -0,0 +1,294 @@
+/*
+ * linux-kernel specific functions
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#include <linux/usb.h>
+
+#include "ifp.h"
+#include "ifp_os.h"
+#include "ifp_prim.h"
+
+int ifp_utf8_to_utf16(wchar_t * ob, int max_o, char * ib, int max_i)
+{
+	int i = 0;
+
+	//Warning about possible buffer overrun: here 'n' is the
+	//size of the buffer 's', but we have no way of preventing
+	//'buf' from being overrun.  (We can tell afterwards, but by
+	//then it's too late.)
+
+	i = utf8_mbstowcs(ob, ib, max_i);
+	BUG_ON(i > max_o);
+
+	return i;
+
+}
+int ifp_utf16_to_utf8(char * ob, int max_o, wchar_t * ib, int max_i)
+{
+	int i = 0;
+
+	i = utf8_wcstombs(ob, ib, max_o);
+	BUG_ON(i >= max_o);
+
+	return i;
+}
+
+int ifp_os_sleep(int ms) {
+	int i;
+
+	//what about this:
+	//interruptible_sleep_on_timeout(wait_queue_head_t *q,long timeout);
+	//
+	//sleep for 1/1000 seconds
+	int timeout = (int)((long)HZ*(long)ms/(long)1000);
+	current->state = TASK_INTERRUPTIBLE;
+	timeout = schedule_timeout(timeout);
+	if (timeout) {
+		ifp_err("interuptted while waiting for flush.");
+		i = -EINTR;
+		return i;
+	}
+	return 0;
+
+}
+
+int ifp_os_control_send(struct ifp_device * dev, int command, int arg1, int arg2,
+	int * r1, int * r2)
+{
+	struct usb_device * usbdev = dev->private;
+	int pipe;
+	u8 ctl[8];
+	int c_size;
+	int i;
+	int loops_left = 20;
+
+	BUG_ON(r1 == NULL);
+	c_size = r2 ? 8 : 4;
+
+	pipe = usb_rcvctrlpipe(dev->private,0);
+
+	do {
+#if 0
+		if (i == -EPIPE) {
+			i = usb_clear_halt(dev->private, pipe);
+			if (i == -EPIPE) {
+				//loop?
+				ifp_err_i(i, "failed to clear halt");
+			} else if (i) {
+				ifp_err_jump(i, out,
+					"error attempting to clear halt");
+			}
+		}
+#endif
+#if 0
+		if (command == 0x07) {
+			//ifp_os_sleep(5);
+			schedule();
+		}
+#endif
+		i = usb_control_msg(usbdev, pipe, command, IFP_REQ_TYPE,
+			arg1, arg2, ctl, c_size, IFP_TIMEOUT);
+
+		//This is a big hack.  I actually have no clue why EPIPE
+		//is occasionally returned here, nor how to correctly handle it.
+		//
+		//When this happens, I find that reissuing the control message
+		//once is usually sufficient.  However, the device occasionally
+		//behaves as if it successfully received an extra request.
+		//
+		//In other words, one of the requests that returned EPIPE
+		//succeeded.  (But most of them didn't.)  If I could detect
+		//which request succeeded, I could work around this.  However,
+		//none of the return values tell me.. I've checked:
+		//'endpoint_halted', 'i', r1 and r2.
+
+		if (i == -EPIPE) {
+			int rr1, rr2 = 0;
+			if (r2) {
+				rr2 = ifp_os_le32_to_cpup(ctl + 4);
+			}
+			rr1 = ifp_os_le32_to_cpup(ctl);
+
+			ifp_dbg("You've encountered the USB timing/reading bug.  This is just an early warning.. but if you see the message \"error reading block.. I expected x bytes but got less\" there's a corruption or a read error.  (So remount the filesystem and download it again.)  What USB chipset are you using anyways?  Mail geoff please!");
+			//ifp_dbg("got epipe; loop=%d (r1=%d, r2=%d)",
+			//	loops_left, rr1, rr2
+			//	);
+			if (loops_left == 15) {
+				ifp_dbg("waiting for device to be available");
+			}
+
+			//ifp_dbg("sleeping for a bit");
+			ifp_os_sleep(200);
+			loops_left--;
+		}
+		if (!loops_left) {
+			ifp_err_i(i, "timeout attempting to %s ifp control code "
+				"the command %0x (%d, %d). ctl[%d]  Returned %d.",
+				"sending", command, arg1, arg2, c_size, i);
+			return i;
+		}
+	} while (i == -EPIPE);
+	if (i < 0) {
+		ifp_err_i(i, "error %s ifp control code the command %0x (%d, %d)."
+			" ctl[%d]  Returned %d.",
+			"sending", command, arg1, arg2, c_size, i);
+		return i;
+	} else if (i != c_size) {
+		if (command == IFP_FILE_DOWNLOAD) { dev->alt_readcount++; }
+		ifp_err_i(i, "warning: unexpected error value.. I expected %d.",
+			c_size);
+	} else {
+		if (command == IFP_FILE_DOWNLOAD) { dev->alt_readcount++; }
+		i = 0;
+	}
+
+	if (r2) {
+		*r2 = ifp_os_le32_to_cpup(ctl + 4);
+	}
+	*r1 = ifp_os_le32_to_cpup(ctl);
+
+	return i;
+}
+
+int ifp_os_push(struct ifp_device * dev, void * p, int n)
+{
+	int i = 0, actual;
+	int pipe;
+
+	pipe = usb_sndbulkpipe(dev->private,(dev->bulk_to & 0x7f));
+
+	i = usb_bulk_msg(dev->private, pipe, p, n, &actual, IFP_TIMEOUT);
+
+	if (i == -EPIPE) {
+		ifp_dbg("EPIPE status received");
+
+		i = usb_clear_halt(dev->private, pipe);
+		ifp_err_jump(i, out, "failed to clear halt");
+
+		i = usb_bulk_msg(dev->private, pipe, p, n, &actual,IFP_TIMEOUT);
+		ifp_err_jump(i, out, "failed to reissue xfer");
+	} else if (i < 0) {
+		ifp_err_i(i, "usb_bulk_msg failed");
+		return i;
+	} else if (actual != n) {
+		ifp_dbg("usb_bulk_msg could only send %d of %d bytes",
+			actual, n);
+	}
+out:
+
+	return i;
+}
+
+int ifp_os_pop(struct ifp_device * dev, void * p, int n)
+{
+	int i = 0, actual;
+	int pipe;
+	memset(p, 0, n);
+
+	pipe = usb_rcvbulkpipe(dev->private,(dev->bulk_from & 0x7f));
+
+	i = usb_bulk_msg(dev->private, pipe, p, n, &actual, IFP_TIMEOUT);
+
+	if (i == -EPIPE) {
+		ifp_dbg("EPIPE status received");
+
+		i = usb_clear_halt(dev->private, pipe);
+		ifp_err_jump(i, out, "failed to clear halt");
+
+		i = usb_bulk_msg(dev->private, pipe, p, n, &actual,IFP_TIMEOUT);
+		ifp_err_jump(i, out, "failed to reissue xfer");
+	} else if (i < 0) {
+		ifp_err_i(i, "usb_bulk_msg failed");
+		return i;
+	} else {
+		if (i) {
+			ifp_dbg("(warning) i=%d is positive",i);
+		}
+		if (actual != n) {
+			ifp_dbg("(warning) usb_bulk_msg only received %d of %d bytes",
+				actual, n);
+			return actual ? actual : -1;
+		}
+	}
+out:
+
+	return i;
+}
+
+int ifp_os_init(struct ifp_device * dev, void * device_handle)
+{
+	int i = 0;
+	struct usb_device * ldev = device_handle;
+	struct usb_host_interface * interface;
+	int address0, address1;
+
+	dev->model = ldev->descriptor.idProduct;
+	dev->private = device_handle;
+
+	interface = &ldev->actconfig->interface[0]->altsetting[0];
+	address0 = interface->endpoint[0].desc.bEndpointAddress;
+	address1 = interface->endpoint[1].desc.bEndpointAddress;
+	if (address0 & 0x0080) {
+		BUG_ON(address1 & 0x0080);
+		dev->bulk_from = address0;
+		dev->bulk_to = address1;
+	} else {
+		BUG_ON((address1 & 0x0080)==0);
+		dev->bulk_from = address1;
+		dev->bulk_to = address0;
+	}
+
+	return i;
+}
+int ifp_os_finalize(struct ifp_device * dev)
+{
+	//release happens somewhere else
+	dev->private = NULL;
+	return 0;
+}
+
+void * ifp_os_find_device(void) {
+        int i;
+        struct usb_device * dev = NULL;
+	const int iRiver_Vendor = 0x4102;
+
+	//search for working devices first.
+	for (i = 0; i != IFP_PRODUCT_IDs; i++) {
+                dev = usb_find_device(iRiver_Vendor, ifp_product_ids[i]);
+                if (dev) {
+                        ifp_info("iRiverFS: detected a %s series device.",
+				ifp_product_strings[i]);
+                        return dev;
+                }
+        }
+
+	//We haven't found a compatible device with the 'manager' firmware.
+	//To be helpful to the user, let's check if there are any devices
+	//using the alternative 'ums' firmware--the firmware that emulates
+	//a USB mass storage device.
+	for (i = 0; i != IFP_PRODUCT_IDs; i++) {
+                dev = usb_find_device(iRiver_Vendor,
+			ifp_product_ids[i] | ifp_product_ums_bit);
+                if (dev) {
+                        ifp_info("iRiverFS: skipping the %s device with 'UMS' "
+				"firmware because the USB mass storage driver "
+				"will work better with it.\n",
+				ifp_product_strings[i]);
+                        return NULL;
+                }
+        }
+        return NULL;
+}
+
+int ifp_os_release_device(void * dev) {
+	usb_put_dev(dev);
+	return 0;
+}
+
+#if !defined (__KERNEL__)
+# error "makefile error"
+#endif // __KERNEL__
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp_prim.c linux-2.6.9-iriverfs-stable/fs/iriver/ifp_prim.c
--- linux-2.6.9/fs/iriver/ifp_prim.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp_prim.c	2004-10-23 12:36:10.000000000 -0400
@@ -0,0 +1,1104 @@
+/*
+ * IRiver ifp supporting functions, a basic (primative) API.
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#define IFP_ENOENT 2
+#define IFP_EIO    5
+
+#include "ifp.h"
+#include "ifp_os.h"
+#include "ifp_prim.h"
+
+//Constants needed for autodetection.  (Platform-indendent, I might add.)
+
+//This list is a guestimate.  I have good reason to believe it works for
+//iFP-1xx through iFP-8xx though.
+int ifp_product_ids[IFP_PRODUCT_IDs] = {
+	0x1001,
+	0x1003,
+	0x1005,
+	0x1007,
+	0x1008,
+	0x1010
+};
+char * ifp_product_strings[IFP_PRODUCT_IDs] = {
+	"iFP-1xx",
+	"iFP-3xx",
+	"iFP-5xx",
+	"iFP-7xx",
+	"iFP-8xx",
+	"iFP-10xx"
+};
+
+#ifdef IFP_DEBUG_USB_SNOOPING
+static char const * ifp_human_commands[] = {
+	"ping", //0x00
+	"0x01", //0x01
+	"02_command", //0x02
+	"0x03", //0x03
+	"0x04", //0x04
+	"f.open", //0x05
+	"f.new", //0x06
+	"download", //0x07
+	"upload", //0x08
+	"0x09", //0x09
+	"0x0a", //0x0a
+	"f.size", //0x0b
+	"0x0c", //0x0c
+	"f.close", //0x0d
+	"delete", //0x0e
+	"d.open", //0x0f
+	"d.next", //0x10
+	"d.close", //0x11
+	"mkdir", //0x12
+	"rmdir", //0x13
+	"capacity", //0x14
+	"availa", //0x15
+	"format", //0x16
+	"firmware update", //0x17
+	"buffsz", //0x18
+	"0x19", //0x19
+	"getFAT page", //0x1a
+	"d.next_debug", //0x1b
+	"setFAT page", //0x1c
+	"getRadio stations", //0x1d
+	"setRadio stations", //0x1e
+	"0x1f", //0x1f
+};
+
+static char const * ifp_human_02_commands[] = {
+	"string", //0x00
+	"02_01", //0x01
+	"02_02", //0x02
+	"firmwr", //0x03
+	"delta", //0x04
+	"02_05", //0x05
+	"flush", //0x06
+	"02_07", //0x07
+	"battery", //0x08
+};
+
+static int _ifp_control_debug(struct ifp_device * dev,
+	int command, int arg1, int arg2, int r1, int * pr2,
+	int ivalue
+	)
+{
+	int i = 0;
+	int r2 = -1;
+	char const * s_command = NULL;
+
+
+	if (pr2) {
+		r2 = *pr2;
+	}
+
+	if (command == 0x02 && arg2 >= 0 && arg2 <= 0x08) {
+		s_command = ifp_human_02_commands[arg2];
+	} else if (command >= 0 && command <= 0x1f) {
+		s_command = ifp_human_commands[command];
+	} else {
+		s_command = "";
+	}
+
+	ifp_print("ifp: %-6.6s c0%02x %04x %04x | %04x",
+		s_command, command, arg1, arg2, r1);
+
+	if (pr2) {
+		ifp_print(" %04x", r2);
+	}
+
+	if (ivalue) {
+		ifp_print(" i=%d", ivalue);
+	}
+
+	ifp_print("\n");
+	return i;
+}
+
+static inline int ifp_control_debug_info(struct ifp_device * dev,
+	int command, int arg1, int arg2, int r1, int * pr2,
+	int ivalue
+	)
+{
+	return _ifp_control_debug(dev, command, arg1, arg2, r1, pr2, ivalue);
+}
+#else //IFP_DEBUG_USB_SNOOPING
+static inline int ifp_control_debug_info(struct ifp_device * dev,
+	int command, int arg1, int arg2, int r1, int * pr2, int ivalue)
+{
+	return 0;
+}
+#endif //IFP_DEBUG_USB_SNOOPING
+
+int ifp_control_send(struct ifp_device * dev, int command,
+	int arg1, int arg2, int * pr2)
+{
+	int i, r1;
+	i = ifp_os_control_send(dev, command, arg1, arg2, &r1, pr2);
+	ifp_control_debug_info(dev, command, arg1, arg2, r1, pr2, i);
+	if (i < 0) {
+		ifp_err_i(i, "error sending control value");
+	} else if (i) {
+		//caller allready warned about unexpected value.
+		i = 0;
+	}
+
+	if (i == 0) {
+		i = r1;
+	}
+
+	return i;
+}
+
+//Convience method to convert ifp's "success" return value to 0
+int ifp_control_send_bool(struct ifp_device * dev, int command, int arg1, int arg2,
+	int * ret)
+{
+	int i = ifp_control_send(dev, command, arg1, arg2, ret);
+	if (i == 0) {
+		//FIXME: change to i = 1;
+		//i = -1;
+		i = 1;
+	} else if (i == 1) {
+		i = 0;
+	}
+	return i;
+}
+
+
+#ifdef IFP_DEBUG_USB_RAWDATA
+static int hexdump_line(void * pp, int n, int lw)
+{
+	ifp_u8 * p = pp;
+	int j, c;
+
+	for (j=0; j!=lw; j++) {
+		if (j >= n) {
+			printk("  ");
+		} else {
+			printk("%02x", (int)(p[j]));
+		}
+		if (j % 4 == 3) {
+			printk(" ");
+		}
+	}
+
+	for (j=0; j!=lw; j++) {
+		if (j >= n) {
+			break;
+			//printk(" ");
+		} else {
+			c = (int)p[j];
+			if (isprint(c)) {
+				printk("%c", c);
+			} else {
+				printk(".");
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int hexdump(char * prefix, void * pp, int n)
+{
+	ifp_u8 * p = pp;
+	int const lw = 32;
+	int zeros = 0;
+	int j = n;
+	int total = n;
+
+	while (p[j-1] == 0) {
+		j--;
+	}
+	if (n-j > 3) {
+		zeros = n - j;
+		n = j;
+	}
+	
+	while (n > 0) {
+		printk("%s", prefix);
+		hexdump_line(p, n, lw);
+		n -= lw;
+		if (n > 0) {
+			p += lw;
+		} else {
+			if (zeros > 0) {
+				printk(" [%d]", total);
+			}
+		}
+		printk("\n");
+	}
+	return 0;
+}
+#endif
+
+
+//
+// primatives
+//
+
+//Returns a negative number on error, 0 on success, and the number of
+//bytes written (if the whole block wasn't written).
+static inline int _ifp_push(struct ifp_device * dev, void * p, int n)
+{
+	int i = 0;
+
+	i = ifp_os_push(dev, p, n);
+
+#ifdef IFP_DEBUG_USB_RAWDATA
+	hexdump("<--dn  ", p, n);
+#endif
+
+	return i;
+}
+
+/* Note that 'n' must be a power of 2. */
+static inline int _ifp_pop(struct ifp_device * dev, void * p, int n)
+{
+	int i = 0;
+
+	i = ifp_os_pop(dev, p, n);
+
+#ifdef IFP_DEBUG_USB_RAWDATA
+	hexdump("-->up  ", p, n);
+#endif
+
+	return i;
+}
+
+static inline int _ifp_push_unicode(struct ifp_device * dev, char * s, int n,
+		int blocksize)
+{
+	int i;
+	ifp_u8 * buf = dev->b1;
+
+	memset(buf, 0, IFP_BUFFER_SIZE);
+
+	//Warning about possible buffer overrun: here 'n' is the
+	//size of the buffer 's', but we have no way of preventing
+	//'buf' from being overrun.  (We can tell afterwards, but by
+	//then it's too late.)
+	
+	i = ifp_utf8_to_utf16((wchar_t *)buf, IFP_BUFFER_SIZE/sizeof(wchar_t), s, n);
+	//i = utf8_mbstowcs((wchar_t *) buf, s, n);
+	//BUG_ON(i > IFP_BUFFER_SIZE);
+	if (i < 0) {
+		ifp_err_i(i, "error conversion from utf8 to utf16.  n=%d.\n", n);
+		return i;
+	}
+	i = ifp_os_push(dev, buf, blocksize);
+
+#ifdef IFP_DEBUG_USB_SNOOPING
+	printk("<--dn '%s'[unicode]\n", s);
+#endif // IFP_DEBUG_USB_SNOOPING
+	return i;
+}
+
+static inline int _ifp_pop_unicode(struct ifp_device * dev, char * s, int n,
+		int blocksize)
+{
+	int i;
+	ifp_u8 * buf = dev->b1;
+
+	memset(buf, 0, IFP_BUFFER_SIZE);
+	i = ifp_os_pop(dev, buf, blocksize);
+	if (i) {
+		//Either an error occured, or fewer bytes than 'n' was read.
+		if (i < 0) {
+			ifp_err_i(i, "pop error.");
+		} else {
+			ifp_err("pop read only %d bytes.", i);
+		}
+		return i;
+	}
+	i = ifp_utf16_to_utf8(s, n, (wchar_t *)buf, IFP_BUFFER_SIZE/sizeof(wchar_t));
+	//i = utf8_wcstombs(s, (wchar_t *)buf, n);
+	//BUG_ON(i >= n);
+	((char *)s)[i] = '\0';
+#ifdef IFP_DEBUG_USB_SNOOPING
+	printk("-->up '%s'[unicode]\n", s);
+#endif // IFP_DEBUG_USB_SNOOPING
+
+	return 0;
+}
+
+#if 0
+//Returns a negative number on error, 0 on success, and the number of
+//bytes written (if the whole block wasn't written).
+static inline int _ifp_set_buffer_size(struct ifp_device * dev, int n,
+	int force)
+{
+	int i = 0, allowed;
+	if (dev->last_buffer_size != n || force) {
+		i = ifp_control_send(dev, IFP_SET_BUFFER, n, 0, &allowed);
+		if (allowed >= 0) {
+			dev->last_buffer_size = allowed;
+		}
+		if (i == 1 && allowed == n) {
+			return 0;
+		}
+	}
+	//return 0;
+	return i ? i : 0;
+}
+#endif
+
+static inline int _ifp_file_open(struct ifp_device * dev, int type)
+{
+	int i = ifp_control_send(dev, IFP_FILE_OPEN, type, 0, NULL);
+	if (i == 0) {
+		//doesn't exist
+		i = 1;
+	} else if (i == 1) {
+		//exists, ok
+		i = 0;
+	} else if (i > 1) {
+		//wtf
+		ifp_err_i(i, "unexpected return code for f.open.");
+		i = -1;
+	}
+	return i;
+}
+
+static inline int _ifp_file_open_new(struct ifp_device * dev, int size)
+{ return ifp_control_send_bool(dev, IFP_FILE_OPEN_NEW, size, 0, NULL); }
+
+static inline int _ifp_file_close(struct ifp_device * dev)
+{ return ifp_control_send_bool(dev, IFP_FILE_CLOSE, 0, 0, NULL); }
+
+static inline int _ifp_file_size(struct ifp_device * dev)
+{
+	int i, n;
+	i = ifp_control_send_bool(dev, IFP_FILE_SIZE, 0, 0, &n);
+	if (i) {
+		return i;
+	}
+	return n;
+}
+
+#if 0
+/* returns 0 on success, 1 on "device not ready!" and negative on error. */
+static inline int _ifp_file_download(struct ifp_device * dev, int bytes, int * actual)
+{
+	int i;
+	i = ifp_control_send(dev, IFP_FILE_DOWNLOAD, bytes, 0, NULL);
+	if (actual) {
+		*actual = i;
+	}
+	if (i < 0) {
+		ifp_err_i(i, "error sending code to download block.");
+		return i;
+	} else if (i == bytes) {
+		return 0;
+	} else if (i > bytes) {
+		ifp_err_i(i, "Something's wierd.  The return value is larger than %d", bytes);
+		return -1;
+	} else if (i == 0) {
+		ifp_wrn("warning: return value is 0 instead of %d, which is often a sign of corruption.", bytes);
+		return 1;
+	} else {
+		//ifp_wrn("[_ifp_file_download] warning: got %d instead of %d.\n", i, bytes);
+		return 0;
+	}
+}
+#endif
+
+static inline int _ifp_dir_open(struct ifp_device * dev)
+{ return ifp_control_send(dev, IFP_LS_OPEN, 0, 0, NULL); }
+
+static inline int _ifp_dir_next(struct ifp_device * dev, int mode)
+{ return ifp_control_send(dev, IFP_LS_NEXT, mode, 0, NULL); }
+
+static inline int _ifp_dir_close(struct ifp_device * dev)
+{ return ifp_control_send_bool(dev, IFP_LS_CLOSE, 0, 0, NULL); }
+
+
+//Returns a negative number on error, 0 on success, and the number of
+//bytes written (if the whole block wasn't written).
+static inline int _ifp_file_upload(struct ifp_device * dev, int bytes)
+{
+	int i;
+	i = ifp_control_send(dev, IFP_FILE_UPLOAD, bytes, 0, NULL);
+	if (i >= 0 && i == bytes) {
+		return 0;
+	}
+	return i < 0 ? i : -1;
+}
+
+static inline int _ifp_file_flush(struct ifp_device * dev)
+{
+	int n;
+	return ifp_control_send_bool(dev, IFP_02_COMMAND, 0, IFP_02_UPLOAD_FLUSH, &n);
+	//printk("[_ifp_file_flush] info, n=%d\n", n);
+}
+
+static inline int _ifp_delete(struct ifp_device * dev)
+{ return ifp_control_send_bool(dev, IFP_FILE_DELETE, 0, 0, NULL); }
+
+static inline int _ifp_mkdir(struct ifp_device * dev)
+{ return ifp_control_send_bool(dev, IFP_DIR_CREATE, 0, 0, NULL); }
+
+static inline int _ifp_rmdir(struct ifp_device * dev)
+{ return ifp_control_send_bool(dev, IFP_DIR_DELETE, 0, 0, NULL); }
+
+//return 1 on success, 0 on 'done', and negative on error
+static inline int _ifp_dir_next_debug(struct ifp_device * dev, int mode)
+{ return ifp_control_send(dev, IFP_LS_NEXT_DEBUG, mode, 0, NULL); }
+
+static inline int _ifp_get_fat_page(struct ifp_device * dev, int dir, int page)
+{ return ifp_control_send_bool(dev, IFP_GET_FAT_PAGE, dir, page, NULL); }
+
+static inline int _ifp_set_fat_page(struct ifp_device * dev)
+{ return ifp_control_send_bool(dev, IFP_SET_FAT_PAGE, 0, 0, NULL); }
+
+static inline int get_control_value(struct ifp_device * dev,
+	int cmd, int arg1, int arg2)
+{
+	int i,n;
+	i = ifp_control_send_bool(dev, cmd, arg1, arg2, &n);
+	if (i < 0) {
+		return i;
+	}
+	return n;
+}
+
+static inline int _ifp_ping(struct ifp_device * dev)
+{ return get_control_value(dev, IFP_PING, 0, 0); }
+
+static inline int _ifp_battery(struct ifp_device * dev)
+{ return get_control_value(dev, IFP_02_COMMAND, 0, IFP_02_BATTERY); }
+
+static inline int _ifp_capacity(struct ifp_device * dev)
+{ return get_control_value(dev, IFP_GET_CAPACITY, 0, 0); }
+
+static inline int _ifp_freespace(struct ifp_device * dev)
+{ return get_control_value(dev, IFP_GET_FREE, 0, 0); }
+
+static inline int _ifp_model(struct ifp_device * dev)
+{ return get_control_value(dev, IFP_02_COMMAND, 0, IFP_02_STRING); }
+
+static inline int _ifp_firmware_version(struct ifp_device * dev)
+{ return get_control_value(dev, IFP_02_COMMAND, 0, IFP_02_FIRMWARE); }
+
+static inline int _ifp_delta(struct ifp_device * dev)
+{ return get_control_value(dev, IFP_02_COMMAND, 0, IFP_02_DELTA); }
+
+//
+//public functions (to this module)
+//
+
+int ifp_init(struct ifp_device * dev, void * device_handle) {
+	int i = 0;
+
+	if (device_handle == NULL) {
+		ifp_err("device handle is NULL.");
+		i = -1;
+		goto out;
+	}
+
+	i = ifp_os_init(dev, device_handle);
+	ifp_err_jump(i, out, "ifp_os_init error.");
+
+	dev->last_buffer_size = 0;
+	dev->mode = IFP_MODE_NONE;
+
+	i = ifp_selftest(dev);
+	ifp_err_jump(i, out_err, "self test failed.");
+
+	return 0;
+
+out_err:
+	ifp_os_finalize(dev);
+out:
+	return i;
+}
+
+int ifp_finalize(struct ifp_device * dev) {
+	int i = 0;
+	
+	i = ifp_os_finalize(dev);
+	ifp_err_jump(i, out, "ifp_os_finalize returned an error.");
+
+out:
+	return i;
+}
+
+int ifp_file_open(struct ifp_device * dev, char * s, int n)
+{
+	int i;
+	//i = _ifp_set_buffer_size(dev, n, 1);
+	i = _ifp_set_buffer_size(dev, IFP_PATH_XFER_SIZE, 1);
+	ifp_err_jump(i, out, "set buffer failed");
+	i = _ifp_push_unicode(dev, s, n, IFP_PATH_XFER_SIZE);
+	ifp_err_jump(i, out, "push failed");
+	i = _ifp_file_open(dev, IFP_FILE);
+	if (i != 0 && i != 1) { ifp_err_i(i, "open directive failed"); return i; }
+
+out:
+	return i;
+}
+
+int ifp_file_open_new(struct ifp_device * dev, char * s, int n, int filesize)
+{
+	int i;
+	//i = _ifp_set_buffer_size(dev, n, 1);
+	i = _ifp_set_buffer_size(dev, IFP_PATH_XFER_SIZE, 0);
+	if (i) { ifp_err_i(i, "set buffer failed"); return i; }
+	i = _ifp_push_unicode(dev, s, n, IFP_PATH_XFER_SIZE);
+	if (i) { ifp_err_i(i, "push failed"); return i; }
+	i = _ifp_file_open_new(dev, filesize);
+	if (i) { ifp_err_i(i, "open_new directive failed"); return i; }
+
+	return i;
+}
+
+int ifp_file_close(struct ifp_device * dev)
+{
+	return _ifp_file_close(dev);
+}
+
+int ifp_file_size(struct ifp_device * dev)
+{
+	return _ifp_file_size(dev);
+}
+
+//I'd like to move this out of this file, eventually
+int ifp_read_seek_forward(struct ifp_device * dev, int count, int blocksize)
+{
+	int i, j, actual;
+	i = _ifp_set_buffer_size(dev, blocksize, 1);
+	if (i) {
+		ifp_err_i(i, "set buffer failed");
+		return i > 0 ? -IFP_EIO : i;
+	}
+	for (j=0; j != count; j++) {
+		i = _ifp_file_download(dev, blocksize, &actual);
+		if (i) {
+			ifp_err_i(i, "download control message failed");
+			return i;
+		}
+		if (actual != blocksize) {
+			i = -IFP_EIO;
+			ifp_err("seek failed,  I can't handle "
+				"getting %d bytes instead of %d\n", i, blocksize
+			);
+			return -IFP_EIO;
+		}
+	}
+	return 0;
+}
+
+
+//returns the number of bytes received, or a negative number on error.
+int ifp_file_download(struct ifp_device * dev, void * p, int n)
+{
+	int i;
+	int actual;
+
+	if (n == 0) {
+		ifp_err("refusing to download 0 bytes.");
+		return -1;
+	}
+
+	i = _ifp_set_buffer_size(dev, n, 1);
+	if (i) {
+		ifp_err_i(i, "set buffer failed");
+		return i > 0 ? -IFP_EIO : i;
+	}
+	i = _ifp_file_download(dev, n, &actual);
+	if (i) {
+		ifp_err_i(i, "download control code failed");
+		return i;
+	}
+
+	if (actual == 0) {
+		ifp_wrn("warning: zero bytes available for download.");
+		return 0;
+	}
+	//printk("[ifp_file_download] download returned %d\n",i);
+	n = actual;
+
+	i = _ifp_pop(dev, p, n);
+	if (i) {
+		//Either an error occured, or fewer bytes than 'n' was read.
+		if (i < 0) {
+			ifp_err_i(i, "pop failed");
+		} else {
+			ifp_err_i(i, "pop returned an unexpected value (fewer bytes read than expected.)");
+			i = -1;
+		}
+		return i;
+	}
+
+	return n;
+}
+
+int ifp_file_upload(struct ifp_device * dev, void * p, int n)
+{
+	int i;
+	if (n == 0) {
+		ifp_err("refusing to upload 0 bytes.");
+		return -1;
+	}
+	i = _ifp_set_buffer_size(dev, n, 1);
+	ifp_err_jump(i, out, "set buffer failed");
+	i = _ifp_push(dev, p, n);
+	ifp_err_jump(i, out, "push failed");
+	i = _ifp_file_upload(dev, n);
+	ifp_err_jump(i, out, "upload control code failed");
+
+out:
+	return i;
+}
+
+int ifp_file_flush(struct ifp_device * dev)
+{
+	unsigned char buf[4];
+	int i;
+	int status;
+	int n = 0;
+	int const obsene_limit = 1000;
+
+	do {
+		//Sleep even on the first loop.. it's good for soul.. call it "kerma"
+		i = ifp_os_sleep(100);
+		ifp_err_jump(i, out, "trouble falling asleep, loading Dickens..");
+
+		i = _ifp_file_flush(dev);
+		ifp_err_jump(i, out, "error issuing 'flush' command");
+
+		i = _ifp_pop(dev, buf, sizeof(buf));
+		ifp_err_jump(i, out, "pop failed");
+
+		//flush returns 1 when it's ready to continue, but 2 when
+		//it's still writing to flash.
+		status = ifp_os_le32_to_cpup(buf);
+		if (status == 1) {
+			//done
+			return 0;
+		}
+		if (n == 5) {
+			ifp_wrn("[ifp_file_flush] waiting for device 'ready'.");
+			ifp_wrn("[ifp_file_flush] (normally it doesn't take this long).");
+		}
+
+		//infinite loop plug
+		n++;
+		if (n == obsene_limit) {
+			ifp_err("timeout: hit obscene limit");
+			i = -1; goto out;
+		}
+	} while(status == 2);
+
+	ifp_err("unrecognized return value %d.",i);
+	i = -1;
+out:
+	return i;
+}
+
+int ifp_ping(struct ifp_device * dev)
+{
+	return _ifp_ping(dev);
+}
+
+//Returns the battery's charge as an integer--typcially between 0 and 4.
+int ifp_battery(struct ifp_device * dev)
+{
+	ifp_u8 buf[4];
+	int n, i = 0;
+	n = _ifp_battery(dev);
+	if (n < 0) {
+		ifp_err_i(n, "error reading battery");
+		return n;
+	}
+	IFP_BUG_ON(n != sizeof(buf));
+	i = _ifp_pop(dev, buf, sizeof(buf));
+	ifp_err_jump(i, out, "pop failed");
+
+	n = ifp_os_le32_to_cpup(buf);
+
+	return n;
+out:
+	return i;
+}
+
+int ifp_dir_open(struct ifp_device * dev, char * s, int n)
+{
+	int i;
+	//i = _ifp_set_buffer_size(dev, IFP_BUFFER_SIZE, 1);
+	i = _ifp_set_buffer_size(dev, IFP_PATH_XFER_SIZE, 1);
+	ifp_err_jump(i, out, "set buffer failed");
+	i = _ifp_push_unicode(dev, s, n, IFP_PATH_XFER_SIZE);
+	ifp_err_jump(i, out, "push failed");
+	i = _ifp_dir_open(dev);
+	if (i < 0) {
+		ifp_err_i(i, "open directive failed");
+	} else if (i == 0) {
+		//dir doesn't exist, so it wasn't opened.  This isn't
+		//an error, so don't print any messages to the user.
+		i = 1;
+	} else if (i == 1) {
+		//dir found.. open succeeded.
+		i = 0;
+	} else {
+		ifp_err_i(i, "unexpected return value");
+		i = -1;
+	}
+
+out:
+	return i;
+}
+
+int ifp_dir_next(struct ifp_device * dev, void * s, int n, int mode)
+{
+	int i;
+	//printk("[ifp_dir_next] buffer is %#03x, n=%#03x.\n", sizeof(buf), n);
+	//i = _ifp_set_buffer_size(dev, IFP_BUFFER_SIZE, 1);
+	
+	//FIXME: IFP_MAXLSLEN   0x80
+	//use it for 'n' in here.  Or check that n is 0x80
+	i = _ifp_dir_next(dev, mode);
+	if (i < 0) {
+		ifp_err_i(i, "error requesting next filename");
+		return i;
+	} else if (i == 0) {
+		//no more files to return.  Just to be nice,
+		//we're putting a null terminator on s.
+		if (n > 0) {
+			*((char *)s) = 0;
+		}
+		return i;
+	}
+	mode = i;
+
+	i = _ifp_pop_unicode(dev, s, n, IFP_PATH_XFER_SIZE);
+	if (i) {
+		ifp_err_i(i, "pop failed");
+		return i > 0 ? -1 : i;
+	}
+	return mode;
+}
+
+int ifp_dir_close(struct ifp_device * dev)
+{
+	return _ifp_dir_close(dev);
+}
+
+int ifp_delete(struct ifp_device * dev, char * s, int n)
+{
+	int i = 0;
+	i = _ifp_set_buffer_size(dev, IFP_PATH_XFER_SIZE, 1);
+	ifp_err_jump(i, out, "set buffer failed");
+	i = _ifp_push_unicode(dev, s, n, IFP_PATH_XFER_SIZE);
+	ifp_err_jump(i, out, "push failed");
+	i = _ifp_delete(dev);
+	if (i < 0) {
+		ifp_err_i(i, "open request failed");
+		return i;
+	} else if (i == 1) {
+		ifp_err("file not found");
+		return -IFP_ENOENT;
+	}
+	i = 0;
+
+out:
+	return i;
+}
+
+int ifp_mkdir(struct ifp_device * dev, char * s, int n)
+{
+	int i;
+	i = _ifp_set_buffer_size(dev, IFP_PATH_XFER_SIZE, 1);
+	ifp_err_jump(i, out, "set buffer failed");
+	i = _ifp_push_unicode(dev, s, n, IFP_PATH_XFER_SIZE);
+	ifp_err_jump(i, out, "push failed");
+	i = _ifp_mkdir(dev);
+	if (i < 0) {
+		ifp_err_i(i, "open failed");
+		return i;
+	} else if (i == 1) {
+		ifp_err("no such directory");
+		return -IFP_ENOENT;
+	}
+
+	i = 0;
+out:
+	return i;
+}
+
+int ifp_rmdir(struct ifp_device * dev, char * s, int n)
+{
+	int i;
+	i = _ifp_set_buffer_size(dev, IFP_PATH_XFER_SIZE, 1);
+	ifp_err_jump(i, out, "set buffer failed");
+	i = _ifp_push_unicode(dev, s, n, IFP_PATH_XFER_SIZE);
+	ifp_err_jump(i, out, "push failed");
+	i = _ifp_rmdir(dev);
+	if (i < 0) {
+		ifp_err_i(i, "open failed");
+		return i;
+	} else if (i == 1) {
+		ifp_err("no such directory");
+		return -IFP_ENOENT;
+	}
+
+	i = 0;
+out:
+	return i;
+}
+
+int ifp_capacity(struct ifp_device * dev)
+{ return _ifp_capacity(dev); }
+int ifp_freespace(struct ifp_device * dev)
+{ return _ifp_freespace(dev); }
+
+int ifp_delta(struct ifp_device * dev, int * values)
+{
+	ifp_u8 buf[8];
+	int i = 0;
+	int bytes;
+	int nn;
+
+	bytes = _ifp_delta(dev);
+	if (bytes < 0) {
+		i = bytes;
+		ifp_err_jump(i, out, "error sending control code");
+	} else if (bytes > 8) {
+		i = -1;
+		ifp_err("unexpected buffer size of %d instead of %d",
+			bytes, (int)sizeof(buf));
+		goto out;
+	}
+	if (bytes != 8 && bytes != 4) {
+		ifp_wrn("interesting, %d bytes are being sent", bytes);
+
+	}
+
+	i = _ifp_pop(dev, buf, bytes);
+	ifp_err_jump(i, out, "pop failed");
+
+	values[0] = buf[0];
+	values[1] = buf[1];
+	values[2] = buf[2];
+	values[3] = buf[3];
+
+	if (bytes > 4) {
+		nn = ifp_os_le32_to_cpup(buf + 4);
+		if ( nn != 0xffffffff ) {
+			ifp_wrn("interesting, the last 4 bytes are %08x.", nn);
+		}
+	}
+
+out:
+	return i;
+}
+
+int ifp_model(struct ifp_device * dev, char * s, int size)
+{
+	int n, i = 0;
+	n = _ifp_model(dev);
+	if (n < 0) {
+		ifp_err_i(n, "error reading device model string");
+		return n;
+	}
+	if (n >= size) {
+		ifp_wrn("warning: the buffer is too small for the model string.  Truncating.  (%d instead of %d.)", n, size);
+		n = size - 1;
+	}
+	i = _ifp_pop(dev, s, n);
+	ifp_err_jump(i, out, "pop failed");
+
+	s[n] = '\0';
+
+out:
+	return i;
+}
+
+/*Returns a BCD value.*/
+int ifp_firmware_version(struct ifp_device * dev)
+{
+	ifp_u8 * s = dev->b1;
+	const int transfer_size = 64;
+	int n, i;
+
+	n = _ifp_firmware_version(dev);
+	if (n < 0) {
+		ifp_err_i(n, "error reading device model string");
+		return n;
+	}
+	//printk("[ifp_firmware_version] info, asking for %d bytes.\n", n);
+	if (n >= transfer_size) {
+		ifp_wrn("warning: the buffer is too small for the firmware string.  Truncating.  (%d instead of %d.)", n, transfer_size);
+		n = transfer_size - 1;
+	}
+	i = _ifp_pop(dev, s, n);
+	if (i) {
+		ifp_err_i(i, "pop failed");
+		return i >= 0 ? -1 : i;
+	}
+	//s[n] = '\0';
+	
+	return ifp_os_le32_to_cpup(s);
+}
+
+// 0x0100 >= sizeof(raw) >= 0x0010
+int ifp_dir_next_debug(struct ifp_device * dev, char * s, int n, int mode,
+	int * dir, int * page, int * offset, int * chipmunk)
+{
+	ifp_u8 * spec_buff = dev->b1;
+
+	int i;
+	if (dev == NULL) {
+		ifp_err("dev is NULL..");
+	}
+
+	//mode = 0;
+	i = _ifp_dir_next_debug(dev, mode);
+	if (i == 0) {
+		//no more files to return.  Just to be nice,
+		//we're putting a null terminator on s.
+		if (n > 0) {
+			*((char *)s) = 0;
+		}
+		return 0;
+	} else if (i < 0 || i != 1) {
+		ifp_err_i(i, "error getting next file");
+		return i < 0 ? i : -1;
+	}
+
+	i = _ifp_pop_unicode(dev, s, n, IFP_PATH_XFER_SIZE);
+	if (i) {
+		//Either an error occured, or fewer bytes than 'n' was read.
+		if (i < 0) {
+			ifp_err_i(i, "pop error");
+		} else {
+			ifp_err_i(i, "unexpected pop return value");
+		}
+		return i;
+	}
+
+	i = _ifp_dir_next_debug(dev, mode);
+	if (i != 1) {
+		ifp_err_i(i, "error requesting file debug info for %s", s);
+		return i < 0 ? i : -1;
+	}
+	//buffer is actually IFP_BUFFER_SIZE
+	i = _ifp_pop(dev, spec_buff, 0x0100);
+	if (i) {
+		ifp_err_i(i, "error getting file debug info for %s", s);
+		return i < 0 ? i : -1;
+	}
+	if (dir) {
+		*dir = ifp_os_le16_to_cpup(spec_buff);
+
+		if (*dir != ifp_os_le16_to_cpup(spec_buff + 2)) {
+			ifp_wrn("warning %d != %d [2]",
+				*dir, ifp_os_le16_to_cpup(spec_buff + 2));
+		}
+		if (*dir != ifp_os_le16_to_cpup(spec_buff + 4)) {
+			ifp_wrn("warning %d != %d [4]",
+				*dir, ifp_os_le16_to_cpup(spec_buff + 4));
+		}
+		//BUG_ON(*dir != ifp_os_le16_to_cpup(spec_buff + 2));
+		//BUG_ON(*dir != ifp_os_le16_to_cpup(spec_buff + 4));
+	}
+
+	if (chipmunk) {
+		*chipmunk = ifp_os_le16_to_cpup(spec_buff + 6);
+	}
+
+	//Combined with the directory number, this is effectively an 'inode number'.
+	i = ifp_os_le16_to_cpup(spec_buff + 8);
+	if (i <= 2) {
+		//'1' and '2' appear to be reserved for "VOICE" and "RECORD" respectively.
+		//I don't think you can manipulate them.  (Not sure why you'd want to anyways.)
+		if (page)
+			*page = -1;
+		if (offset)
+			*offset = i;
+	} else {
+		i -= 2;
+		if (page)
+			*page = (i)/16;
+		if (offset)
+			*offset = (i)%16;
+	}
+
+	i = ifp_os_le16_to_cpup(spec_buff + 10);
+	if (i != 0x0100) {
+		ifp_wrn("warning: the field at +10 is %04x instead of 0x0100."
+			"  (For %s)", i, s);
+	}
+
+	mode = ifp_os_le16_to_cpup(spec_buff + 12);
+
+	if (mode == 0) {
+		ifp_err_i(mode, "more error (on %s)", s);
+		return -1;
+	}
+
+	return mode;
+}
+
+int ifp_get_fat_page(struct ifp_device * dev, int dir, int page,
+	void * p, int n)
+{
+	const int DOWNLOAD_PAGE_SIZE = 0x0100;
+	int i = 0;
+
+	IFP_BUG_ON(n < DOWNLOAD_PAGE_SIZE*2);
+	i = _ifp_get_fat_page(dev, dir, page);
+	ifp_err_jump(i, out,
+		"error requesting chuck #1 of (%#x, %#x)\n", dir, page);
+
+	i = _ifp_pop(dev, p, DOWNLOAD_PAGE_SIZE);
+	ifp_err_jump(i, out,
+		"error downloading chuck #1 of (%#x, %#x)\n", dir, page);
+
+	i = _ifp_get_fat_page(dev, dir, page);
+	ifp_err_jump(i, out,
+		"error requesting chuck #2 of (%#x, %#x)\n", dir, page);
+
+	i = _ifp_pop(dev, (ifp_u8 *)p + DOWNLOAD_PAGE_SIZE, DOWNLOAD_PAGE_SIZE);
+	ifp_err_jump(i, out,
+		"error downloading chuck #2 of (%#x, %#x)\n", dir, page);
+
+out:
+	return i;
+}
+int ifp_set_fat_page(struct ifp_device * dev, int dir, int page,
+	void * p, int n)
+{
+	const int HEADER = 0x0010;
+	const int DN_PAGE_SIZE = 0x0200;
+	//ifp_u8 buf[DN_PAGE_SIZE + HEADER];
+	ifp_u8 * buf = dev->b1;
+	int i = 0;
+
+	IFP_BUG_ON(n < DN_PAGE_SIZE);
+
+	//Create the upload payload.
+	memset(buf, 0, HEADER);
+	memcpy(buf + HEADER, p, DN_PAGE_SIZE);
+	((ifp_u16 *)(buf))[0] = ifp_os_cpu_to_le16(dir);
+	((ifp_u16 *)(buf))[1] = ifp_os_cpu_to_le16(page);
+
+	i = _ifp_set_buffer_size(dev, DN_PAGE_SIZE + HEADER, 1);
+	ifp_err_jump(i, out, "error setting buffer size");
+
+	i = _ifp_push(dev, buf, DN_PAGE_SIZE + HEADER);
+	ifp_err_jump(i, out, "error pushing data for (%d, %d)",
+		dir, page);
+
+	i = _ifp_set_fat_page(dev);
+	ifp_err_jump(i, out, "error setting FAT page (%d, %d)", dir, page);
+
+out:
+	return i;
+}
+
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp_prim.h linux-2.6.9-iriverfs-stable/fs/iriver/ifp_prim.h
--- linux-2.6.9/fs/iriver/ifp_prim.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp_prim.h	2004-09-29 20:24:27.000000000 -0400
@@ -0,0 +1,164 @@
+/*
+ * Interface for accessing iRiver's IFP devices
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#ifndef IFP_PRIM_H
+#define IFP_PRIM_H 1
+
+//WARNING: this is a dumping ground for everything that doesn't have a home
+//.. it used to be 'ifp.h'
+
+#define IFP_REQ_TYPE            0xc0 //192
+//#define TIMEOUT                 1000
+//#define TIMEOUT                 5000
+#define IFP_TIMEOUT             5000
+
+#define IFP_FAT_PAGE_SIZE       0x0200 //512
+#define IFP_FAT_HEADER          0x0010 //16
+#define IFP_FAT_ENTRY_SIZE      0x0080 //128
+#define IFP_PATH_XFER_SIZE      0x0100 //256
+
+//request values
+#define IFP_02_COMMAND          0x02
+
+#define IFP_PING                0x00 //no idea.  PING/ACK, reset?
+#define IFP_FILE_OPEN           0x05 //file open
+#define IFP_FILE_OPEN_NEW       0x06 //'file_info' for uploading
+#define IFP_FILE_DOWNLOAD       0x07 //requests next data block
+#define IFP_FILE_UPLOAD         0x08 //accepts one data block
+#define IFP_UNKNOWN_1           0x09 //? segfaults my test program
+#define IFP_UNKNOWN_2           0x0a
+#define IFP_FILE_SIZE           0x0b //context 'file_info'
+#define IFP_UNKNOWN_3           0x0c
+#define IFP_FILE_CLOSE          0x0d //file close for 'info' 'upload' and 'download ' (?)
+#define IFP_FILE_DELETE         0x0e
+#define IFP_LS_OPEN             0x0f //15
+#define IFP_LS_NEXT             0x10 //16
+#define IFP_LS_CLOSE            0x11 //17
+#define IFP_DIR_CREATE          0x12 //18
+#define IFP_DIR_DELETE          0x13 //19
+#define IFP_GET_CAPACITY        0x14 //20
+#define IFP_GET_FREE            0x15 //21
+#define IFP_FORMAT              0x16 //22
+#define IFP_FIRMWARE_UPDATE     0x17 //23
+#define IFP_SET_BUFFER          0x18 //24 I believe it sets the buffer size
+#define IFP_UNKNOWN_4           0x19 //25
+#define IFP_GET_FAT_PAGE        0x1a //26 "alpha"
+#define IFP_LS_NEXT_DEBUG       0x1b //27 "bravo"
+#define IFP_SET_FAT_PAGE        0x1c //28 "charlie"
+#define IFP_GET_PRESET          0x1d //29
+#define IFP_SET_PRESET          0x1e //30
+
+//when request is '02_COMMAND', index is one of these:
+#define IFP_02_STRING           0x00
+#define IFP_02_FIRMWARE         0x03
+#define IFP_02_DELTA            0x04 //I always get "0108 0616 ffff ffff"
+#define IFP_02_UPLOAD_FLUSH     0x06
+#define IFP_02_BATTERY          0x08
+
+struct ifp_device;
+
+int ifp_control_send(struct ifp_device * dev, int command, int arg1, int arg2, int * r2);
+int ifp_control_send_bool(struct ifp_device * dev, int command, int arg1, int arg2, int * r2);
+
+//Logical primatives
+//
+//Parameter of type "char *" are either string or filename (named s and f
+//respectively) and are utf8 strings.  "void *" buffers will be treated as
+//binary data and will not be modified.
+//
+//The parameter "n" immediately following string and data buffers is the
+//buffer size.
+
+
+//returns 0 on success, and 1 on failure because file doesn't exist.
+int ifp_file_open(struct ifp_device * dev, char * f, int n);
+int ifp_file_open_new(struct ifp_device * dev, char * f, int n, int filesize);
+int ifp_file_close(struct ifp_device * dev);
+int ifp_file_size(struct ifp_device * dev);
+int ifp_file_download(struct ifp_device * dev, void * p, int n);
+int ifp_file_upload(struct ifp_device * dev, void * p, int n);
+int ifp_file_flush(struct ifp_device * dev);
+
+//returns 0 on success, 1 on failure because the dir doesn't exist.
+int ifp_dir_open(struct ifp_device * dev, char * f, int n);
+int ifp_dir_next(struct ifp_device * dev, void * f, int n, int mode);
+int ifp_dir_close(struct ifp_device * dev);
+
+int ifp_ping(struct ifp_device * dev);
+
+//returns a raw bcd value.  For human consumption, I suggest ("%x.%02x", r/0x100, r%0x100).
+
+// 'debug' here refers to the hardware--I believe this wasn't intended for use
+// in the production firmware.
+int ifp_dir_next_debug(struct ifp_device * dev, char * s, int n, int mode,
+	int * dir, int * page, int * offset, int * chipmunk);
+//sizeof(p) == 512 bytes (0x0100)
+int ifp_get_fat_page(struct ifp_device * dev, int dir, int page,
+	void * p, int n);
+int ifp_set_fat_page(struct ifp_device * dev, int dir, int page,
+	void * p, int n);
+
+
+//"compound" or task-oriented functions.
+
+int ifp_count_subdirs(struct ifp_device * dev, char * dirname, int n);
+
+int ifp_copy_parent_string(char * p, char * f, int n);
+
+static const int ifp_product_ums_bit = 0x0100;
+//static const int IFP_PRODUCT_IDs = 6;
+#define IFP_PRODUCT_IDs 6
+
+extern int ifp_product_ids[IFP_PRODUCT_IDs];
+extern char * ifp_product_strings[IFP_PRODUCT_IDs];
+
+
+//Returns a negative number on error, 0 on success, and the number of
+//bytes written (if the whole block wasn't written).
+static inline int _ifp_set_buffer_size(struct ifp_device * dev, int n,
+        int force)
+{
+        int i = 0, allowed;
+        if (dev->last_buffer_size != n || force) {
+                i = ifp_control_send(dev, IFP_SET_BUFFER, n, 0, &allowed);
+                if (allowed >= 0) {
+                        dev->last_buffer_size = allowed;
+                }
+                if (i == 1 && allowed == n) {
+                        return 0;
+                }
+	}
+	return i ? i : 0;
+}
+
+static inline int _ifp_file_download(struct ifp_device * dev,
+	int bytes, int * actual)
+{
+        int i;
+        i = ifp_control_send(dev, IFP_FILE_DOWNLOAD, bytes, 0, NULL);
+        if (actual) {
+                *actual = i;
+        }
+        if (i < 0) {
+                ifp_err_i(i, "error sending code to download block.");
+                return i;
+        } else if (i == bytes) {
+                return 0;
+        } else if (i > bytes) {
+                ifp_err_i(i, "Something's wierd.  The return value is larger than %d", bytes);
+                return -1;
+        } else if (i == 0) {
+                ifp_wrn("warning: return value is 0 instead of %d, which is often a sign of corruption.", bytes);
+                return 1;
+        } else {
+		//ifp_wrn("[_ifp_file_download] warning: got %d instead of %d.\n", i, bytes);
+		return 0;
+        }
+}
+
+#endif // IFP_PRIM_H
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/ifp_readwrite.c linux-2.6.9-iriverfs-stable/fs/iriver/ifp_readwrite.c
--- linux-2.6.9/fs/iriver/ifp_readwrite.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/ifp_readwrite.c	2004-09-29 20:24:27.000000000 -0400
@@ -0,0 +1,452 @@
+/*
+ * IRiver ifp supporting functions
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#include "ifp.h"
+#include "ifp_os.h"
+#include "ifp_prim.h"
+
+#define IFP_EIO  5
+#define IFP_ENOSPC 28
+
+//This needs a home.  (Currently declared in ifp_prim.h)
+int ifp_copy_parent_string(char * p, char * f, int n) {
+	int i = 0;
+	char * c;
+	c = strrchr(f, '\\');
+	if (c == NULL) {
+		ifp_err("apparently '%s' doesn't contain a '\\'\n", f);
+		i = -1;
+		goto out;
+	}
+	if (c == f) {
+		//special case
+		p[0] = '\\';
+		p[1] = '\0';
+	} else {
+		memcpy(p, f, (c-f));
+		p[c-f] = '\0';
+	}
+
+out:
+	return i;
+}
+
+int ifp_read_open(struct ifp_device * dev, char * f, int n)
+{
+	int i = 0;
+	if (dev->mode != IFP_MODE_NONE) {
+		ifp_err("device has been left for %sing.",
+			dev->mode == IFP_MODE_READING ? "read" : "writ");
+		i = -1;
+		goto out;
+	}
+	IFP_BUG_ON(n > IFP_BUFFER_SIZE);
+	memcpy(dev->filename, f, n);
+	i = ifp_copy_parent_string(dev->dirname, f, n);
+	ifp_err_jump(i, out, "error copying directory name");
+
+	i = ifp_dir_open(dev, dev->dirname, n);
+	ifp_err_jump(i, out, "error opening directory '%s'.", dev->dirname);
+
+	i = ifp_file_open(dev, dev->filename, n);
+	ifp_err_jump(i, out, "error opening file '%s'.", dev->filename);
+
+	IFP_BUG_ON(n > IFP_BUFFER_SIZE);
+	n = n <= IFP_BUFFER_SIZE ? n : IFP_BUFFER_SIZE;
+	dev->mode = IFP_MODE_READING;
+	dev->current_offset = 0;
+	dev->filesize = ifp_file_size(dev);;
+	if (dev->filesize < 0) {
+		ifp_err_i((int)(dev->filesize), "error reading filesize of '%s'.", f);
+		goto out;
+	}
+	dev->readcount = 0;
+	dev->alt_readcount = 0;
+
+	//ifp_dbg("opened %s successfully, returning %d", f, i);
+
+out:
+	return i;
+}
+int ifp_read_close(struct ifp_device * dev)
+{
+	int i = 0;
+
+	if (dev->alt_readcount != dev->readcount) {
+		ifp_err("readcounts don't match.  readcount=%d, alt_readcount=%d",
+			dev->readcount, dev->alt_readcount);
+	}
+
+	i = ifp_file_close(dev);
+	if (i) {
+		ifp_err_i(i, "file close failed");
+	}
+	i = ifp_dir_close(dev);
+	if (i) {
+		ifp_err_i(i, "dir close failed");
+	}
+	dev->mode = IFP_MODE_NONE;
+	//ifp_dbg("closing %s, returning %d", dev->filename, i);
+
+	return i;
+}
+
+//Reads next block.  'bytes' should be IFP_BULK_BUFF_SIZE unless
+//it's the last block--in which case 'bytes' is the number of bytes
+//we believe are left to download.
+static int read_next_block(struct ifp_device * dev, int bytes) {
+	int i;
+	IFP_BUG_ON(bytes > IFP_BULK_BUFF_SIZE);
+	if (dev->readcount * IFP_BULK_BUFF_SIZE + bytes > dev->filesize) {
+		ifp_err("Sanity check failed.  We've read %d x 16384 bytes, and"
+			" are about to read %d more from a %d byte file.",
+			dev->readcount, bytes, (int)dev->filesize);
+	}
+	i = ifp_file_download(dev, dev->iobuff, IFP_BULK_BUFF_SIZE);
+	if (i < 0) {
+		ifp_err_i(i, "error reading block at %s+%#lx",
+			dev->filename, (long)dev->current_offset);
+		goto out;
+	} else if (i != bytes) {
+		dev->readcount++;
+		if (dev->alt_readcount != dev->readcount) {
+			ifp_err("readcount=%d, alt_readcount=%d",
+				dev->readcount, dev->alt_readcount);
+		}
+		ifp_err_i(i, "error reading block.. I expected %d bytes but got less; readcount is %d",
+			bytes, dev->readcount);
+		i = -IFP_EIO;
+		goto out;
+	} 
+	dev->readcount++;
+	IFP_BUG_ON(i > bytes);
+	i = 0;
+
+	//not strickly necessary..
+	if (bytes < IFP_BULK_BUFF_SIZE) {
+		memset(dev->iobuff + bytes, 0, IFP_BULK_BUFF_SIZE - bytes);
+	}
+
+out:
+	return i;
+}
+
+//return the number of bytes read.
+int ifp_read_data(struct ifp_device * dev, void * buff, int bytes)
+{
+	int bytes_requested = bytes;
+	int bytes_read = 0;
+	int n;
+	int i = 0;
+	int block_off;
+	int available;
+	ifp_u8 * o = buff;
+
+	bytes = min(bytes, (int)(dev->filesize - dev->current_offset));
+	while (bytes > 0) {
+		block_off = dev->current_offset % IFP_BULK_BUFF_SIZE;
+		if (block_off == 0) {
+			//read next block
+			available = min(IFP_BULK_BUFF_SIZE,
+				(int)(dev->filesize - dev->current_offset));
+
+			i = read_next_block(dev, available);
+			ifp_err_jump(i, out, "error reading next block"
+				" filesize=%d position=%d", (int)dev->filesize,
+				(int)dev->current_offset);
+		} else {
+			available = IFP_BULK_BUFF_SIZE - block_off;
+		}
+		n = min(bytes, available);
+		IFP_BUG_ON(n <= 0);
+
+		memcpy(o, dev->iobuff + block_off, n);
+		o += n;
+		dev->current_offset += n;
+		bytes -= n;
+		bytes_read += n;
+	}
+	IFP_BUG_ON(bytes < 0);
+	IFP_BUG_ON(bytes != 0);
+
+	if (bytes_read != bytes_requested && dev->current_offset != dev->filesize) {
+		ifp_dbg("returning %d instead of %d (but not EOF)", bytes_read, bytes_requested);
+	}
+	IFP_BUG_ON(bytes_read != bytes_requested && dev->current_offset != dev->filesize);
+
+	return bytes_read;
+out:
+	return i;
+}
+
+int ifp_read_eof(struct ifp_device * dev) {
+	return dev->current_offset == dev->filesize;
+}
+
+static int fake_block_reads(struct ifp_device * dev, int n) {
+	int actual, j,i = 0;
+	const int blocksize = IFP_BULK_BUFF_SIZE;
+	ifp_dbg("here -- sanity check");
+	i = _ifp_set_buffer_size(dev, blocksize, 1);
+	if (i) {
+		ifp_err_i(i, "set buffer failed");
+		return i > 0 ? -IFP_EIO : i;
+	}
+        for (j=0; j < n; j++) {
+                i = _ifp_file_download(dev, (int)blocksize, &actual);
+		ifp_err_jump(i, out, "download control message failed");
+		dev->readcount++;
+
+                if (actual != blocksize) {
+                        i = -IFP_EIO;
+                        ifp_err("fake read failed,  I can't handle "
+                                "getting %d bytes instead of %d\n",
+				actual, (int)blocksize);
+			goto out;
+                }
+        }
+
+out:
+	return i;
+}
+
+int ifp_read_seek(struct ifp_device * dev, int bytes)
+{
+        int i = 0;
+	int available = 0;
+
+        const int blocksize = IFP_BULK_BUFF_SIZE;
+        //int bitsize   = IFP_BULK_BUFF_BITS;
+        loff_t tar_offset = dev->current_offset + bytes;
+        loff_t cur_offset = dev->current_offset;
+        int cur_block =  cur_offset == 0 ? -1 : (int)(cur_offset-1) / blocksize;
+        int tar_block =  tar_offset == 0 ? -1 : (int)(tar_offset-1) / blocksize;
+        int count     = tar_block - cur_block;
+
+	if (tar_block != -1) {
+		ifp_dbg("seeking forward %d blocks from %ld to %ld (%d:%d to %d:%d)",
+			count, (long)cur_offset, (long)tar_offset,
+			cur_block, (int)cur_offset % blocksize,
+			tar_block, (int)tar_offset % blocksize);
+	}
+	//ifp_dbg("seeking forward %d blocks from %ld to %ld (%d:%d to %d:%d)",
+	//	count,
+	//	(long)cur_offset, (long)tar_offset,
+	//	cur_block, (int)cur_offset % blocksize,
+	//	tar_block, (int)tar_offset % blocksize);
+	IFP_BUG_ON(count < 0);
+
+	//cases:
+	//	count == 0	update current_offset and return
+	//	count == 1	download next block, update current_offset
+	//	count >= 2	several fake downloads, ...
+	switch (count > 1 ? 2 : count) {
+	case 2:
+		//ifp_dbg("doing fake reads");
+		i = fake_block_reads(dev, count - 1);
+		ifp_err_jump(i, out, "fake block reads failed");
+		//fallthrough
+	case 1:
+		//ifp_dbg("doing real read");
+		available = (int)(dev->filesize - (tar_block*blocksize));
+        if (available > blocksize) {
+            available = blocksize;
+        }
+		i = read_next_block(dev, available);
+		//ifp_err("filesize=%d, current_pos=%d; bytes=%d; available=%d",
+		//	(int)dev->filesize, (int)dev->current_offset,
+		//	bytes, available);
+		ifp_err_jump(i, out, "error reading destination block of %d bytes",
+			available);
+		//fallthrough
+	case 0:
+		//ifp_dbg("adjusting 'current_offset' by %d", bytes);
+        	dev->current_offset += bytes;
+		break;
+	default:
+		IFP_BUG_ON(1);
+	}
+	//ifp_dbg("done");
+	if (i) {
+		ifp_dbg("returning %d", i);
+	}
+out:
+        return i;
+}
+
+/*This code is borrowed from ifp-line and appears to work fine.  The original
+ *driver behaves slightly differently:
+ *
+ * on open
+ *	ifp_dir_open(d)
+ *	ifp_file_open(f)
+ *		fails because file doesn't exist yet.  Good.
+ *	ifp_dir_close()
+ *
+ *	ifp_dir_open(d)
+ *	ifp_file_open_new(d)
+ *
+ * on close
+ *	ifp_file_close()
+ *	ifp_dir_close()
+ *
+ *	ifp_freespace()
+ *
+ *	ls, I think.
+ */
+int ifp_write_open(struct ifp_device * dev, char * f, int n, int filesize)
+{
+	int i;
+
+	IFP_BUG_ON(n > IFP_BUFFER_SIZE);
+	memcpy(dev->filename, f, n);
+	//memcpy(dev->dirname, d, n);
+
+	i = ifp_copy_parent_string(dev->dirname, f, n);
+	ifp_err_jump(i, out, "error copying directory name");
+
+	i = ifp_dir_open(dev, dev->dirname, n);
+	ifp_err_jump(i, out, "open_dir request failed.");
+
+	i = ifp_freespace(dev);
+	if (i < 0) {
+		ifp_err_jump(i, out, "free space request failed");
+	} else if (i < filesize) {
+		i = -IFP_ENOSPC;
+		ifp_err_jump(i, out, "not enough free space on the device");
+	}
+
+	i = ifp_file_open_new(dev, dev->filename, n, filesize);
+	ifp_err_jump(i, out, "file create failed");
+
+	IFP_BUG_ON(n > IFP_BUFFER_SIZE);
+	n = n <= IFP_BUFFER_SIZE ? n : IFP_BUFFER_SIZE;
+	dev->mode = IFP_MODE_WRITING;
+	dev->current_offset = 0;
+	dev->filesize = filesize;
+	dev->readcount = 0;
+
+out:
+	return i;
+}
+
+static int quick_write_verify(struct ifp_device * dev) {
+	int i = 0;
+	int size;
+
+	i = ifp_dir_open(dev, dev->dirname, IFP_BUFFER_SIZE);
+	ifp_err_jump(i, out, "open dir failed");
+
+	i = ifp_file_open(dev, dev->filename, IFP_BUFFER_SIZE);
+	ifp_err_jump(i, out, "open file failed");
+
+	size = ifp_file_size(dev);
+	if (size < 0) {
+		ifp_err_i(size, "file size query failed");
+		goto out;
+	}
+
+	i = ifp_file_close(dev);
+	ifp_err_jump(i, out, "close file failed");
+
+	i = ifp_dir_close(dev);
+	ifp_err_jump(i, out, "close dir failed");
+
+	if (size != dev->filesize) {
+		ifp_err("reported file size is %d instead of %d.. upload failed",
+			size, (int)dev->filesize);
+		i = IFP_EIO;
+	}
+
+out:
+	return i;
+}
+
+int ifp_write_close(struct ifp_device * dev)
+{
+	int i = 0;
+	int e = 0;
+	int remainder = dev->current_offset % IFP_BULK_BUFF_SIZE;
+	if (remainder != 0) {
+		i = ifp_file_upload(dev, dev->iobuff, remainder);
+		if (i) {
+			ifp_err_i(i, "problem uploading last %d bytes.  "
+			"Attempting to close file anyways.", remainder);
+			e=e?e:i;
+			//no jump
+		}
+	}
+	
+	ifp_wrn_on(dev->current_offset != dev->filesize,
+		"received %d fewer bytes than expected",
+		(int)(dev->filesize - dev->current_offset));
+
+	//ifp_dbg("new write code finishing for %s.. all good, apparently.",
+	//	dev->filename);
+
+	i = ifp_file_flush(dev);
+	if (i) {
+		ifp_err_i(i, "flush failed, closing anyways.");
+		e=e?e:i;
+		//no jump
+	}
+
+	i = ifp_file_close(dev);
+	if (i) {
+		ifp_err_i(i, "file close failed, closing dir anyways.");
+		e=e?e:i;
+		//no jump
+	}
+	i = ifp_dir_close(dev);
+	if (i) {
+		ifp_err_i(i, "dir close failed.");
+		e=e?e:i;
+	}
+
+	if (e == 0) {
+		i = quick_write_verify(dev);
+		if (i) {
+			ifp_err_i(i, "quick-verify failed--upload may have failed.");
+		}
+	}
+	dev->mode = IFP_MODE_NONE;
+
+	return i?i:e;
+}
+
+int ifp_write_data(struct ifp_device * dev, void * buff, int bytes)
+{
+	int e = 0;
+	ifp_u8 * i = buff;
+	ifp_u8 * o = dev->iobuff;
+	int n;
+	const int bs = IFP_BULK_BUFF_SIZE;
+	int block_off = dev->current_offset % bs;
+	while (bytes > 0) {
+		n = bs - block_off;
+        if (n > bytes) {
+            n = bytes;
+        }
+		memcpy(o + block_off, i, n);
+
+		i += n;
+		block_off += n;
+		bytes -= n;
+		dev->current_offset += n;
+
+		if (block_off == bs) {
+			//At the end of the file, we have to write a partial block
+			e = ifp_file_upload(dev, o, block_off);
+			ifp_err_jump(e, out, "upload of %d bytes failed",
+				block_off);
+			block_off = 0;
+		}
+	}
+out:
+	return e;
+}
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/inode.c linux-2.6.9-iriverfs-stable/fs/iriver/inode.c
--- linux-2.6.9/fs/iriver/inode.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/inode.c	2004-09-29 20:24:27.000000000 -0400
@@ -0,0 +1,1761 @@
+/* 
+ * IRiver ifp filesystem driver for Linux
+ * Revision : $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/statfs.h>
+#include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
+#include <linux/usb.h>
+#include <linux/nls.h>
+#include <linux/writeback.h>
+#include <linux/mpage.h>
+#include <linux/parser.h>
+
+#include <asm/uaccess.h>
+
+#include "iriverfs.h"
+#include "ifp.h"
+#include "ifp_dentry.h"
+#include "ifp_os.h"
+#include "ifp_prim.h"
+
+/* some random numbers */
+#define IRIVERFS_MAGIC	0x63880F53
+
+
+#if 1
+//I don't know why, but blocksize appears to be locked at 512.  I'd very
+//much like to set it to 16384, but until I can get userland 'stat' to see
+//this, I'm going to stick with 512.
+#define IFP_BLOCK_SIZE_FAKE     512
+#define IFP_BLOCK_BITS_FAKE     9
+#else
+#define IFP_BLOCK_SIZE_FAKE     16384
+#define IFP_BLOCK_BITS_FAKE     14
+#endif
+
+static struct super_operations iriver_ops;
+//static struct address_space_operations iriver_aops;
+static struct file_operations iriver_file_operations;
+static struct file_operations iriver_dir_operations;
+static struct inode_operations iriver_file_inode_operations;
+static struct inode_operations iriver_dir_inode_operations;
+
+static int iriver_readpage(struct file *file, struct page * page);
+
+static int put_ifp_device(struct ifp_device * dev, int disconnected);
+//static int iriver_dbg_writepages(struct address_space *mapping, struct writeback_control *wbc) ;
+
+static int readpage_error(struct file *file, struct page * page);
+
+//romfs version
+static struct address_space_operations aops_restricted = {
+	.readpage	= readpage_error,
+};
+
+static struct address_space_operations aops_cache = {
+	.readpage	= iriver_readpage,
+};
+
+//used in ramfs
+static struct address_space_operations aops_ram = {
+	.readpage	= simple_readpage,
+	.prepare_write	= simple_prepare_write,
+	.commit_write	= simple_commit_write
+};
+
+
+//The various states an inode can be in.  These reflect 
+#define IFP_I_NORMAL 	0
+#define IFP_I_NEW	1
+#define IFP_I_DIRTY	2 /* potentially dirty.. check individual pages */
+struct iriver_inode_info {
+	int loaded; //[dir only] true if the directory has been read into dcache
+	int state; //[file only] true when a file doesn't yet exist on disk
+
+	struct inode vfs_inode;
+};
+static inline struct iriver_inode_info *IRIVER_I(struct inode *inode) {
+	return list_entry(inode, struct iriver_inode_info, vfs_inode);
+}
+
+#define PAGES_PER_BUFFER (IFP_BULK_BUFF_SIZE/PAGE_CACHE_SIZE)
+#if IFP_BULK_BUFF_SIZE < PAGE_CACHE_SIZE || IFP_BULK_BUFF_SIZE % PAGE_CACHE_SIZE
+	//This is an assumption that makes the driver easier to write.  I know
+	//it won't necessarily hold for all platforms, so the best practice
+	//seems to be nice: abort at compile time when the assumption fails.
+	#error "This driver doesn't support this system's page size."
+#endif
+
+struct iriver_readstate {
+	struct dentry * dentry;
+	struct inode * inode;
+	long currentpage;
+};
+
+struct iriver_mount_options {
+	uid_t uid;
+	gid_t gid;
+	unsigned short fmask;
+	unsigned short dmask;
+};
+
+struct iriver_sb_info {
+	struct ifp_device * dev;
+	struct semaphore lock;
+
+	struct iriver_mount_options options;
+
+	//"Lazy cleanup" values that allow the device to be left in unusual
+	//states, so long as the cu^H^Hfunction leaves a 'cleanup()'
+	//function here.
+	//
+	//Cleanup happens (if necessary) when the lock is aquired.
+	void (*cleanup)(struct super_block *, void * state);
+	void * cleanup_state;
+
+	struct iriver_readstate readstate;
+	
+	//True normally, false during mount, unmount or disconnect.
+	int active;
+};
+static inline struct iriver_sb_info *IRIVER_S(struct super_block *sb) {
+	return sb ? (struct iriver_sb_info *)sb->s_fs_info : NULL;
+}
+
+//Used in RAMFS
+static struct backing_dev_info iriver_backing_dev_info = {
+	.ra_pages	= 0,	/* No readahead */
+	.memory_backed	= 1,	/* Does not contribute to dirty memory */
+};
+
+static inline void cleanup(struct super_block *sb) {
+	if (IRIVER_S(sb)->cleanup) {
+		IRIVER_S(sb)->cleanup(sb, IRIVER_S(sb)->cleanup_state);
+		IRIVER_S(sb)->cleanup = IRIVER_S(sb)->cleanup_state = NULL;
+	}
+}
+
+static inline int _ifp_lock(struct super_block *sb) {
+	down(&IRIVER_S(sb)->lock);
+	if (IRIVER_S(sb)->dev == NULL) {
+		printk("[ifp_lock] device disconnected, apparently.\n");
+		up(&IRIVER_S(sb)->lock);
+		return -EPIPE;
+	}
+	BUG_ON(IRIVER_S(sb)->active == 0);
+	//BUG_ON(IRIVER_S(sb)->dev == NULL);
+	cleanup(sb);
+	return 0;
+}
+
+#define ifp_lock(a) if(_ifp_lock(a)) { \
+	printk("[%s] returning\n", __FUNCTION__); return -EPIPE;}
+
+static inline void ifp_unlock(struct super_block *sb) {
+	up(&IRIVER_S(sb)->lock);
+}
+
+static inline int _ifp_debug_msg(char const * fn,
+		struct super_block * sb,
+		struct dentry * dentry,
+		char * message)
+{
+	int i = 0;
+	struct dentry * root = sb->s_root;
+
+	char * z = get_iriver_buffer();
+	if (z == NULL) {
+		printk("[_ifp_debug_msg] z is NULL\n");
+		put_iriver_buffer(z); z = NULL;
+		return -ENOMEM;
+	}
+	if (root == NULL) {
+		printk("[_ifp_debug_msg] root is NULL\n");
+		put_iriver_buffer(z); z = NULL;
+		return -1;
+	}
+	i = make_path_string(dentry, root, '/', z, IFP_BUFFER_SIZE);
+	if (i < 0) {
+		printk("[_ifp_debug_msg] i is %d\n", i);
+	}
+	printk("[%20.20s] ifp:/%s %s\n", fn, z, message);
+	put_iriver_buffer(z); z = NULL;
+
+	return i;
+}
+
+#ifdef IFP_DEBUG_SYSCALL
+#define ifp_debug_msg(s, d, msg) _ifp_debug_msg(__FUNCTION__, s, d, msg)
+#else
+#define ifp_debug_msg(s, d, msg) 
+#endif
+
+
+//-------------------------------------------------------------------------
+//inode and dcache manipulation
+
+static struct inode *iriver_get_inode(struct super_block *sb, int mode, dev_t dev)
+{
+	struct inode * inode = new_inode(sb);
+
+	if (inode) {
+		inode->i_mode = mode;
+		inode->i_uid = IRIVER_S(sb)->options.uid;
+		inode->i_gid = IRIVER_S(sb)->options.gid;
+		inode->i_blkbits = IFP_BLOCK_BITS_FAKE;
+		inode->i_blksize = IFP_BLOCK_SIZE_FAKE;
+		inode->i_blocks = 0;
+		inode->i_mapping->a_ops = &aops_cache;
+		inode->i_mapping->backing_dev_info = &iriver_backing_dev_info;
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		inode->i_flags |= S_NOATIME; //S_APPEND
+		switch (mode & S_IFMT) {
+		default:
+			init_special_inode(inode, mode, dev);
+			break;
+		case S_IFREG:
+			inode->i_op = &iriver_file_inode_operations;
+			inode->i_fop = &iriver_file_operations;
+			break;
+		case S_IFDIR:
+			inode->i_size = IFP_BLOCK_SIZE_FAKE;
+			inode->i_blocks = 1;
+			inode->i_op = &iriver_dir_inode_operations;
+			inode->i_fop = &iriver_dir_operations;
+
+			/* directory inodes start off with i_nlink == 2 (for "." entry) */
+			inode->i_nlink++;
+			break;
+		case S_IFLNK:
+			inode->i_op = &page_symlink_inode_operations;
+			break;
+		}
+	}
+	return inode;
+}
+
+static int
+iriver_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	struct inode * inode = iriver_get_inode(dir->i_sb, mode, dev);
+	int error = -ENOSPC;
+
+	if (inode) {
+		//Problem: calling the two lines labled "suspect" causes crashes
+		//on the first flushd after writing a file.  However, leaving
+		//them out causes newly created directories to not appear.
+        
+		//insert_inode_hash(inode); //suspect
+		if (dir->i_mode & S_ISGID) {
+			inode->i_gid = dir->i_gid;
+			if (S_ISDIR(mode))
+				inode->i_mode |= S_ISGID;
+		}
+		d_instantiate(dentry, inode);
+		//d_rehash(dentry); //suspect
+		dget(dentry);	/* Extra count - pin the dentry in core */
+		error = 0;
+	}
+	return error;
+}
+
+static int iriver_mkdir(struct inode * dir, struct dentry * dentry, int mode)
+{
+	int retval;
+
+	ifp_debug_msg(dir->i_sb, dentry, "");
+	
+	ifp_lock(dir->i_sb);
+	retval = ifp_mkdir_d(IRIVER_S(dir->i_sb)->dev, dentry);
+	if (retval) {
+		printk("[iriver_mkdir] error %d.\n", retval);
+		if (retval < 0) {
+			ifp_unlock(dir->i_sb);
+			return retval;
+		} else {
+			ifp_unlock(dir->i_sb);
+			return -EIO;
+		}
+	}
+
+	//override 'mode'
+	mode = (S_IRWXUGO & ~IRIVER_S(dir->i_sb)->options.dmask);
+	retval = iriver_mknod(dir, dentry, mode | S_IFDIR, 0);
+	if (retval) {
+		printk("[iriver_mkdir] mknod return an error, %d.\n", retval);
+	}
+	//printk("[iriver_mkdir] nlink was %d, ", dir->i_nlink);
+	if (!retval) {
+		//new directories are empty
+		IRIVER_I(dentry->d_inode)->loaded = 1;
+		dir->i_nlink++;
+	}
+	//printk("now %d\n", dir->i_nlink);
+
+	ifp_unlock(dir->i_sb);
+	return retval;
+}
+
+static int create_new_file(struct inode *dir, struct dentry *dentry, int mode,
+	struct nameidata *nd)
+{
+	int e;
+	ifp_debug_msg(dir->i_sb, dentry, "");
+	ifp_lock(dir->i_sb);
+
+	//override 'mode'
+	mode = (S_IRWXUGO & ~IRIVER_S(dir->i_sb)->options.dmask);
+	e = iriver_mknod(dir, dentry, mode | S_IFREG, 0);
+	if (!e) {
+		IRIVER_I(dentry->d_inode)->state = IFP_I_NEW;
+		
+		dentry->d_inode->i_mapping->a_ops = &aops_ram;
+
+		//inode->i_mapping->aops =  &aops_cache
+		//dentry->d_inode->i_mapping->backing_dev_info = &iriver_backing_dev_info;
+		//dentry->d_inode->i_mapping->backing_dev_info = NULL;
+		//dentry->d_inode->i_mapping->a_ops = &aops_cache;
+	}
+	ifp_unlock(dir->i_sb);
+	return e;
+}
+
+struct fill_dir_simple_context {
+	struct dentry * parent;
+
+	//option 1
+	//Can be NULL
+	struct dentry * requested;
+	struct inode *  found;
+};
+
+static struct dentry * create_normal_dentry(
+	struct fill_dir_simple_context * context,
+	char * filename,
+	int n,
+	int mode,
+	int restricted,
+	struct inode ** pinode
+	)
+{
+	struct qstr s;
+	struct dentry * d = NULL;
+	//struct inode * inode;
+
+	s.name = filename;
+	s.len = n;
+	s.hash = full_name_hash(s.name, s.len);
+
+	*pinode = iriver_get_inode(context->parent->d_sb, mode, 0);
+	if (*pinode == NULL) {
+		printk("[create_normal_dentry] iriver_get_inode failed.\n");
+		return NULL;
+	}
+
+	if (context->requested
+		&& s.len == context->requested->d_name.len
+		&& 0 == memcmp(context->requested->d_name.name, s.name, s.len))
+	{
+		//printk("[create_normal_dentry] matched '%s'!\n", s.name);
+		d = context->requested;
+		context->found = *pinode;
+	} else {
+		d = d_alloc(context->parent, &s);
+		if (d == NULL) {
+			//FIXME: free 'inode', if we allocated it.  (Is that possible?)
+			printk("[create_normal_dentry] d_alloc failed.\n");
+			return NULL;
+		}
+		insert_inode_hash(*pinode);
+		d_add(d, *pinode);  // == d_instantiate + d_rehash
+	}
+
+	if (restricted) {
+		(*pinode)->i_mapping->a_ops = &aops_restricted;
+	}
+
+	return d;
+}
+
+static int iriver_symlink(struct inode * dir, struct dentry *dentry,
+	const char * symname)
+{
+	ifp_debug_msg(dir->i_sb, dentry, "");
+	printk("iRiverFS: links (symbolic or otherwise) are not supported.\n");
+	return -EPERM;
+}
+
+static int init_inode_regular(struct ifp_device * dev, struct super_block * sb,
+	struct inode * inode, struct dentry * d, int filesize)
+{
+	inode->i_size = filesize;
+
+	inode->i_blksize = IFP_BLOCK_SIZE_FAKE;
+	inode->i_blkbits = IFP_BLOCK_BITS_FAKE;
+	//inode->i_blocks = 1 + filesize/(inode->i_blksize);
+	inode->i_blocks = filesize >> inode->i_blkbits;
+
+	return 0;
+}
+
+int iriver_revalidate(struct dentry * d, struct nameidata * nameidata);
+
+static struct dentry_operations dop_validate = {
+	.d_revalidate = iriver_revalidate,
+};
+
+static int fill_dir_simple(void * state, int type, char * filename, int n,
+	int filesize)
+{
+	int i = 0;
+	int mode;
+	struct dentry * d = NULL;
+	struct inode * inode = NULL;
+
+	struct fill_dir_simple_context * context = state;
+	struct dentry * parent = context->parent;
+	struct super_block * sb = context->parent->d_sb;
+
+	struct ifp_device * dev = IRIVER_S(sb)->dev;
+	int restricted = 0;
+
+	if (type == IFP_FILE) {
+		int mask = IRIVER_S(sb)->options.fmask;
+		//later models to not have restricted file downloads.
+		if (dev->model <= 0x1005 && n > 4) {
+			//This limitation of the hardware; all attempts
+			//to read 'restricted files' return junk.
+			//If you know of a work-around, please let
+			//me know!
+			char * sz = filename + n - 4;
+			if (strnicmp(sz, ".mp3", 4) == 0
+				|| strnicmp(sz, ".wma", 4) == 0
+				|| strnicmp(sz, ".asf", 4) == 0)
+			{
+				restricted = 1;
+				mask |= S_IRUGO;
+				//This is probably more for ethstetics
+				//mask |= S_IWUGO;
+			}
+		}
+		//until the driver supports file modification, this seems like
+		//the sensible thing.  Unfortunately some shells prompt the
+		//user before deleting non-writable files.. so perhaps this
+		//isn't the best of ideas.
+		//mask |= S_IWUGO;
+
+		mode = (S_IRWXUGO & ~mask) | S_IFREG;
+	} else if (type == IFP_DIR) {
+		mode = (S_IRWXUGO & ~IRIVER_S(sb)->options.dmask) | S_IFDIR;
+	} else {
+		printk("[fill_dir_simple] I don't know what to do with type = %d, stopping\n", type);
+		return -EIO;
+	}
+
+	d = create_normal_dentry(context, filename, n, mode, restricted,
+		&inode);
+	//inode = d->d_inode;
+
+	if (type == IFP_FILE) {
+		//printk("file [ino=%ld]: len=%d '%s'\n", inode->i_ino, len,
+		//	utf8_buf);
+		i = init_inode_regular(IRIVER_S(sb)->dev, sb, inode, d,
+			filesize);
+		if (i) {
+			printk("[callbk] read_inode_regular(ino=%ld, '%s') returned error %d, bailing\n", inode->i_ino, "" /*s.name*/, i);
+			return i;
+		}
+		IRIVER_I(inode)->state = IFP_I_NORMAL;
+	} else if (type == IFP_DIR) {
+		//printk("dir  [ino=%ld]: len=%d '%s'\n", inode->i_ino, len,
+		//	utf8_buf);
+		parent->d_inode->i_nlink++;
+		d->d_op = &dop_validate;
+	}
+
+	return i;
+}
+
+static int preload_directory(struct ifp_device * dev, struct dentry * d,
+	struct dentry * d_request, struct inode ** pinode_return)
+{
+	int i = 0;
+	struct fill_dir_simple_context context;
+	context.parent = d;
+	context.requested = d_request;
+	context.found = NULL;
+
+	if (IRIVER_I(d->d_inode)->loaded != 0) {
+		printk("[preload_directory] attempting to preload something that's allready preloaded.. loaded=%d\n",
+			IRIVER_I(d->d_inode)->loaded);
+	}
+	ifp_debug_msg(d->d_sb, d, "loading");
+	i = ifp_list_dirs_d(dev, d, fill_dir_simple, &context);
+	if (i) {
+		printk("[preload_directory] err %d\n",i);
+		return i;
+	}
+	if (d_request && pinode_return) {
+		*pinode_return = context.found;
+	}
+
+	IRIVER_I(d->d_inode)->loaded = 1;
+	d->d_op = &dop_validate;
+
+	return i;
+}
+
+static int load_directory(struct ifp_device * dev, struct dentry * d,
+	struct dentry * d_request, struct inode ** pinode_return)
+{
+	int i = 0;
+	if (IRIVER_I(d->d_inode)->loaded == 0) {
+		i = preload_directory(IRIVER_S(d->d_sb)->dev, d, d_request,
+			pinode_return);
+		if (i) {
+			printk("[iriver_readdir] preload error, i=%d.\n",i);
+			goto out;
+		}
+	} else {
+		//printk("[load_directory] doing nothing because loaded=%d\n",
+		//	IRIVER_I(d->d_inode)->loaded);
+	}
+
+out:
+	return i;
+}
+
+int iriver_revalidate(struct dentry * d, struct nameidata * nameidata)
+{
+//	int i = 0;
+	if (d && d->d_inode) {
+		//struct super_block * sb = d->d_sb;
+#if 1
+		ifp_debug_msg(d->d_sb, d, "doing nothing");
+#else
+		ifp_debug_msg(sb, d, "");
+
+		i = load_directory(IRIVER_S(sb)->dev, d, NULL, NULL);
+		if (i) {
+			printk("[iriver_revalidate] error loading directory, err = %d.\n",i);
+			return i>0 ? -1 : i;
+		}
+#endif
+		//stop ourselfs from being called--this inode should now be
+		//fully loaded.
+		d->d_op = NULL;
+	} else {
+		printk("[iriver_revalidate] here but something's null.\n");
+	}
+
+	return 1;
+}
+
+static int iriver_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	int i = 0;
+	struct dentry *dentry = filp->f_dentry;
+	struct super_block * sb = dentry->d_sb;
+	struct inode *inode;
+
+	ifp_lock(sb);
+
+	inode = dentry->d_inode;
+
+#if 0
+	if (IRIVER_I(dentry->d_inode)->loaded != 1) {
+		ifp_debug_msg(sb, dentry, "");
+	}
+#endif
+	ifp_debug_msg(sb, dentry, "");
+	i = load_directory(IRIVER_S(sb)->dev, dentry, NULL, NULL);
+	if (i) {
+		printk("[iriver_readdir] load directory failed, i = %d.\n",i);
+		if (i > 0) {
+			i = -1;
+		}
+		goto out;
+	}
+
+	i = dcache_readdir(filp, dirent, filldir);
+out:
+	ifp_unlock(sb);
+	return i;
+}
+
+static struct dentry * iriver_lookup(struct inode * i_parent,
+	struct dentry * dentry, struct nameidata * namei)
+{
+	struct super_block * sb = i_parent->i_sb;
+	struct dentry * dreturn;
+	struct ifp_device * dev = IRIVER_S(sb)->dev;
+	int i = 0;
+
+	if (_ifp_lock(sb)) {
+		printk("[%s] returning 'cause I couldn't get a lock\n", __FUNCTION__);
+		d_add(dentry, NULL);
+		return ERR_PTR(-EPIPE); 
+	}
+
+	if (IRIVER_I(i_parent)->loaded != 1) {
+		struct inode * found_inode = NULL;
+		ifp_debug_msg(i_parent->i_sb, dentry, "");
+		i = load_directory(dev, dentry->d_parent, dentry,
+			&found_inode);
+		if (i) {
+			printk("[iriver_lookup] load directory failed,i=%d.\n",
+				i);
+			goto out_novalue;
+		}
+		if (found_inode) {
+			struct dentry * dd = NULL;
+			dreturn = d_splice_alias(found_inode, dentry);
+			if (dreturn) {
+				dd = dreturn;
+			} else {
+				dd = dentry;
+			}
+
+			atomic_inc(&dd->d_count);
+			goto out;
+		} else {
+			d_add(dentry, NULL);
+		}
+	} else {
+		ifp_debug_msg(i_parent->i_sb, dentry, "...none");
+		if (dentry->d_name.len > NAME_MAX) {
+			return ERR_PTR(-ENAMETOOLONG);
+		}
+		d_add(dentry, NULL);
+		i = 0;
+	}
+
+out_novalue:
+	dreturn = ERR_PTR(i);
+out:
+	ifp_unlock(sb);
+
+	return dreturn;
+}
+
+//-------------------------------------------------------------------------
+//misc operations (df, rmdir, unlink, rename.. etc)
+static int iriver_statfs(struct super_block * sb, struct kstatfs * buf)
+{
+	int r;
+	unsigned int capacity, free;
+
+#ifdef IFP_DEBUG_SYSCALL
+	printk("[iriver_statfs] here\n");
+#endif
+	ifp_lock(sb);
+
+	r = simple_statfs(sb, buf);
+	BUG_ON(r);
+
+	capacity = ifp_capacity(IRIVER_S(sb)->dev);
+	if (capacity < 0) { printk("iriver_statfs: error requesting capactity, err %d\n",
+			capacity);
+		ifp_unlock(sb);
+		return -EIO;
+	}
+	free = ifp_freespace(IRIVER_S(sb)->dev);
+	if (free < 0) {
+		printk("iriver_statfs: error requesting ammount free, err %d\n",
+			free);
+		ifp_unlock(sb);
+		return -EIO;
+	}
+	ifp_unlock(sb);
+
+	buf->f_bsize = IFP_BLOCK_SIZE_FAKE;
+	buf->f_namelen = IFP_BULK_MAXPATHLEN;
+
+	buf->f_blocks = capacity/buf->f_bsize; /* ok ? */
+	buf->f_bfree = free/buf->f_bsize; /* not right */
+
+	buf->f_bavail = buf->f_bfree;
+
+	return 0;
+}
+
+int iriver_dir_getattr(struct vfsmount *mnt, struct dentry *d,
+	struct kstat *stat)
+{
+	int i;
+	ifp_lock(d->d_sb);
+
+	ifp_debug_msg(d->d_sb, d, "");
+	if (IRIVER_I(d->d_inode)->loaded == 0) {
+		i = preload_directory(IRIVER_S(d->d_sb)->dev, d, NULL, NULL);
+		if (i) {
+			printk("[iriver_getattr] preload error, i=%d.\n",i);
+			goto out;
+		}
+	}
+
+	i = simple_getattr(mnt, d, stat);
+
+out:
+	ifp_unlock(d->d_sb);
+	return i;
+}
+
+int iriver_file_getattr(struct vfsmount *mnt, struct dentry *d,
+	struct kstat *stat)
+{
+	int i;
+	ifp_lock(d->d_sb);
+
+	i = simple_getattr(mnt, d, stat);
+
+	ifp_debug_msg(d->d_sb, d, "");
+	stat->blksize = IFP_BLOCK_SIZE_FAKE;
+	stat->blocks = 1 + (stat->size >> IFP_BLOCK_BITS_FAKE);
+	//ifp_dbg("setting as %d blocks of %d, for %d bytes total",
+	//	(int)stat->blocks, (int)stat->blksize, (int)stat->size);
+
+	ifp_unlock(d->d_sb);
+	return i;
+}
+
+int iriver_setattr(struct dentry * d, struct iattr * attr)
+{
+	int i = 0;
+	struct inode * inode = d->d_inode;
+	struct super_block * sb = inode->i_sb;
+
+	ifp_debug_msg(d->d_sb, d, "");
+	lock_kernel();
+
+	//I can't handle truncation or expansion
+	if (attr->ia_valid & ATTR_SIZE) {
+		i = -EPERM;
+		goto out;
+	}
+
+	i = inode_change_ok(inode, attr);
+	if (i)
+		goto out;
+
+	if (((attr->ia_valid & ATTR_UID) &&
+		 (attr->ia_uid != IRIVER_S(sb)->options.uid)) ||
+		((attr->ia_valid & ATTR_GID) &&
+		 (attr->ia_gid != IRIVER_S(sb)->options.gid)) ||
+		 (attr->ia_valid & ATTR_MODE) ||
+		 (attr->ia_valid & ATTR_ATIME_SET) ||
+		 (attr->ia_valid & ATTR_MTIME_SET)
+		 )
+	{
+		 //i = -EPERM;
+		 i = 0;
+		 goto out;
+	}
+
+	//does this step do anything?
+	i = inode_setattr(inode, attr);
+	if (i) 
+		goto out;
+out:
+	unlock_kernel();
+	return i;
+}
+
+static struct file_operations iriver_dir_operations = {
+	.open           = dcache_dir_open,
+	.release        = dcache_dir_close,
+	.llseek         = dcache_dir_lseek,
+	.read		= generic_read_dir,
+
+	.readdir        = iriver_readdir,
+};
+
+static struct inode_operations iriver_file_inode_operations = {
+	//should probably write my own.
+	.getattr	= iriver_file_getattr,
+	.setattr	= iriver_setattr,
+};
+
+
+static int iriver_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
+{
+	printk("iRiverFS: hard links are not supported.\n");
+	return -EPERM;
+}
+
+static int iriver_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int i;
+	ifp_debug_msg(dir->i_sb, dentry, "");
+	ifp_lock(dir->i_sb);
+	i = ifp_delete_d(IRIVER_S(dir->i_sb)->dev, dentry);
+	if (i) {
+		printk("[iriver_unlink] error %d.\n", i);
+		if (i > 0) {
+			i = -EIO;
+		}
+		goto out;
+	}
+
+	i = simple_unlink(dir, dentry);
+out:
+	ifp_unlock(dir->i_sb);
+	return i;
+}
+
+static int iriver_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int i;
+	ifp_debug_msg(dir->i_sb, dentry, "");
+	ifp_lock(dir->i_sb);
+	i = ifp_rmdir_d(IRIVER_S(dir->i_sb)->dev, dentry);
+	ifp_unlock(dir->i_sb);
+	if (i) {
+		printk("[iriver_rmdir] error %d.\n", i);
+		if (i > 0) {
+			i = -EIO;
+		}
+		goto out;
+	}
+	i = simple_rmdir(dir, dentry);
+out:
+	//ifp_unlock(dir->i_sb);
+	return i;
+}
+
+static int iriver_rename(struct inode *old_dir, struct dentry *old_dentry,
+	struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct ifp_device * dev = IRIVER_S(old_dir->i_sb)->dev;
+	int i = 0;
+	ifp_debug_msg(old_dir->i_sb, old_dentry, "");
+	//printk("iRiverFS warning: renaming files is experimental.\n");
+
+#ifdef IFP_RENAME
+	if (S_ISDIR(old_dentry->d_inode->i_mode)) {
+		printk("iRiverFS warning: moving directories is relatively new.\n");
+	}
+#if 0
+	if (old_dir != new_dir) {
+		printk("iRiverFS warning: moving files to different directories is even more experimental.\n");
+	}
+#endif
+	ifp_lock(old_dir->i_sb);
+	i = ifp_rename_d(dev, old_dentry, new_dentry);
+	ifp_unlock(old_dir->i_sb);
+
+	if (i) {
+		printk("[iriver_rename] rename failed, err %d\n", i);
+		i = -EIO;
+		goto out;
+	}
+out:
+#else
+	printk("iRiverFS error: renaming support is disabled.\n");
+	i = -EPERM;
+#endif
+	return i;
+}
+
+static int
+iriver_mknod_EIO(struct inode *dir, struct dentry *dentry, int mode, dev_t dev) {
+	printk("iRiverFS: special devices are not supported.\n");
+	return -EPERM;
+}
+
+//-------------------------------------------------------------------------
+//uploading files
+static int iriver_open(struct inode * inode, struct file * f)
+{
+	int i = 0;
+	ifp_debug_msg(inode->i_sb, f->f_dentry, "");
+	ifp_lock(inode->i_sb);
+
+	//If the state's allready NEW or DIRTY, leave it.
+	if (IRIVER_I(inode)->state == IFP_I_NORMAL) {
+		if ((f->f_mode & FMODE_WRITE) == O_RDONLY) {
+			//printk("[iriver_open] Opening read-only...\n");
+			if (inode->i_mapping->a_ops == &aops_restricted) {
+				printk("iRiverFS: warning, access to some files is restricted by firmware.\n");
+				i = -EPERM;
+				goto out;
+			}
+		} else {
+			printk("iRiverFS warning: editing files is currently not supported.\n");
+			i = -EPERM;
+			goto out;
+#if 0
+			IRIVER_I(inode)->state = IFP_I_DIRTY;
+			inode->i_mapping->a_ops = &aops_ram;
+			inode->i_mapping->backing_dev_info = &iriver_backing_dev_info;
+			printk("[iriver_open] Opening for writing...\n");
+#endif
+		}
+	} else if (IRIVER_I(inode)->state == IFP_I_NEW) {
+		//printk("[iriver_open] Opening a new file...\n");
+	} else {
+		printk("[iriver_open] unknown state %d.\n", IRIVER_I(inode)->state);
+		i = -EIO;
+	}
+
+out:
+	ifp_unlock(inode->i_sb);
+	return i;
+}
+
+static int iriver_write_new_file(struct inode * inode, struct file * f)
+{
+	struct ifp_device * dev = IRIVER_S(inode->i_sb)->dev;
+	long bytes = i_size_read(inode);
+	struct page * page = NULL;
+	void * pgdata = NULL;
+	int pagenum;
+	int i = 0, e = 0;
+
+	i = ifp_write_open_d(dev, f->f_dentry, inode->i_size);
+	if (i) {
+		printk("[iriver_write_new_file] start failed, err %d\n",i);
+		return i;
+	}
+
+	pagenum = 0;
+	while (bytes > 0)
+	{
+		int n = (bytes < PAGE_CACHE_SIZE) ? bytes : PAGE_CACHE_SIZE;
+
+		page = find_lock_page(inode->i_mapping, pagenum++);
+		pgdata = kmap(page);
+		BUG_ON(page == NULL);
+		BUG_ON(pgdata == NULL);
+
+		i = ifp_write_data(dev, pgdata, n);
+
+		flush_dcache_page(page);
+		kunmap(page);
+		unlock_page(page);
+		page_cache_release(page);
+		page = NULL;
+
+		if (i) {
+			ifp_err_i(i, "error writing page of data");
+			e = e?e:i;
+			break;
+		}
+
+		bytes -= n;
+	}
+	BUG_ON(bytes != 0);
+
+	i = ifp_write_close(dev);
+	if (i) {
+		printk("[iriver_write_new_file] end failed, err %d\n",i);
+	}
+
+	return e?e:i;
+}
+
+
+static int write_file(struct inode * inode, struct file * f) {
+	int i;
+	
+	//FIXME: if this fails, either try again or nuke the inode & dentry.
+	i = iriver_write_new_file(inode, f);
+	if (i) {
+		printk("[write_file] failed..\n");
+		return i;
+	}
+
+	//printk("[write_file] File upload sucessful.\n");
+	IRIVER_I(inode)->state = IFP_I_NORMAL; 
+	inode->i_mapping->a_ops =  &aops_cache;
+
+	return i;
+}
+
+static int iriver_release(struct inode * inode, struct file * f) {
+	int i = 0;
+	ifp_lock(inode->i_sb);
+	if (IRIVER_I(inode)->state == IFP_I_NEW) {
+		//printk("[iriver_release] Creating file.  (Blocking while we upload).\n");
+
+		ifp_debug_msg(inode->i_sb, f->f_dentry, "writing file (blocking).");
+		i = write_file(inode, f);
+		if (i) {
+			printk("[iriver_release] file write failed.\n");
+			goto out;
+		}
+	} else if (IRIVER_I(inode)->state == IFP_I_DIRTY) {
+		ifp_debug_msg(inode->i_sb, f->f_dentry, "");
+		printk("[iriver_release] Existing file that might need updating.\n");
+	}
+out:
+	ifp_unlock(inode->i_sb);
+	return i;
+}
+
+//IMPROVEMENT IDEA: make two versions of this, one for new
+//files and one for existing files.  This eliminates the need 
+//for 'state' flags.
+static struct file_operations iriver_file_operations = {
+	.read		= generic_file_read,
+	.write		= generic_file_write,
+	.mmap		= generic_file_mmap,
+	.fsync		= simple_sync_file,
+	.sendfile	= generic_file_sendfile,
+	.llseek		= generic_file_llseek,
+
+	.open		= iriver_open,
+	.release	= iriver_release,
+};
+
+
+//-------------------------------------------------------------------------
+//downloading files
+
+//cheating_page
+static void ifp_download_cleanup(struct super_block * sb,
+	void * vp)
+{
+	int i;
+	struct iriver_readstate * p = vp;
+
+	if (IRIVER_S(sb) == NULL || IRIVER_S(sb)->dev == NULL) {
+		printk("[ifp_download_cleanup] one of them is NULL.\n");
+	}
+
+	//ifp_debug_msg needs access to dentrys that might allready be
+	//free().  But, we don't actually need those dentries to cleanup
+	//the ifp's device state.. so this is the comprimise.
+	if (IRIVER_S(sb)->active) {
+		//ifp_debug_msg(sb, p->dentry, "");
+	} else {
+		printk("[ifp_download_cleanup] here..\n");
+	}
+	i = ifp_read_close(IRIVER_S(sb)->dev);
+	if (i) {
+		printk("[ifp_download_cleanup] file leave control message failed (err %d).\n", i);
+	}
+
+	p->currentpage = 0;
+	p->inode = NULL;
+	p->dentry = NULL;
+}
+
+static int
+readpage_error(struct file *file, struct page * page)
+{
+	ifp_debug_msg(page->mapping->host->i_sb, file->f_dentry, "");
+	printk("iRiverFS: warning, access to some files is restricted by firmware.\n");
+	SetPageError(page);
+	unlock_page(page);
+	return -EPERM;
+}
+
+static int
+iriver_readpage(struct file *file, struct page * page)
+{
+	struct inode * inode = page->mapping->host;
+	u32 maxblock, bytes_filled;
+	void * pgdata;
+	int i = 0;
+	struct ifp_device * dev = IRIVER_S(inode->i_sb)->dev;
+	struct super_block *sb = inode->i_sb;
+
+	maxblock = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+	bytes_filled = 0;
+	//ifp_debug_msg(sb, file->f_dentry, "reading page");
+	//ifp_dbg("reading page %d", (int)page->index);
+
+	if (page->index < maxblock) {
+		down(&IRIVER_S(sb)->lock);
+		if (IRIVER_S(sb)->dev == NULL) {
+			printk("[iriver_readpage] device disconnected");
+			i = -EPIPE;
+			goto err_2;
+		}
+		//printk("[iriver_readpage] starting for page %d (size=%d, maxp=%d)\n",
+		//	(int)page->index, (int)inode->i_size, (int)maxblock);
+
+		if (IRIVER_S(sb)->cleanup == ifp_download_cleanup
+			&& IRIVER_S(sb)->cleanup_state == 
+				(void*)&(IRIVER_S(sb)->readstate)
+
+			&& IRIVER_S(sb)->readstate.currentpage == page->index)
+		{
+			IRIVER_S(sb)->cleanup = NULL;
+			IRIVER_S(sb)->cleanup_state = NULL;
+		} else {
+			if (IRIVER_S(sb)->cleanup) {
+				IRIVER_S(sb)->cleanup(sb, IRIVER_S(sb)->cleanup_state);
+				IRIVER_S(sb)->cleanup
+					= IRIVER_S(sb)->cleanup_state
+					= NULL;
+				IRIVER_S(sb)->readstate.currentpage = 0;
+			}
+
+			i = ifp_read_open_d(dev, file->f_dentry);
+			if (i) {
+				printk("[iriver_readpage] ifp_read_open_d %d.\n", i);
+				i = -EIO;
+				goto err_2;
+
+			}
+
+			//printk("[iriver_readpage] seeking to %d\n",
+			//	(int)page->index);
+			i = ifp_read_seek(dev, PAGE_CACHE_SIZE*page->index);
+			if (i) {
+				printk("[iriver_readpage] ifp_read_seek returned %d.\n", i);
+				IRIVER_S(sb)->cleanup = ifp_download_cleanup;
+				IRIVER_S(sb)->cleanup_state = &IRIVER_S(sb)->readstate;
+				i = -EIO;
+				goto err_1;
+			}
+		}
+
+		ClearPageUptodate(page);
+		pgdata = kmap(page);
+		i = ifp_read_data(dev, pgdata, PAGE_CACHE_SIZE);
+		if (i < 0) {
+			printk("[iriver_readpage] read_fileblock failed with err %d.\n", i);
+			IRIVER_S(sb)->cleanup = ifp_download_cleanup;
+			IRIVER_S(sb)->cleanup_state = &IRIVER_S(sb)->readstate;
+			kunmap(page);
+			goto err_1;
+		} else if (i < PAGE_CACHE_SIZE) {
+			//printk("[iriver_readpage] got %d instead of %d.\n", i, (int)PAGE_CACHE_SIZE);
+			memset(pgdata + i, 0, PAGE_CACHE_SIZE-i);
+			i = 0;
+		} else {
+			i = 0;
+		}
+
+		flush_dcache_page(page);
+		SetPageUptodate(page);
+
+		IRIVER_S(sb)->readstate.dentry = file->f_dentry;
+		IRIVER_S(sb)->readstate.inode = inode;
+		IRIVER_S(sb)->readstate.currentpage = page->index + 1;
+
+		IRIVER_S(sb)->cleanup = ifp_download_cleanup;
+		IRIVER_S(sb)->cleanup_state = &IRIVER_S(sb)->readstate;
+		up(&IRIVER_S(sb)->lock);
+	} else {
+		//printk("[iriver_readpage] empty page over here.. page %d\n",
+		//	(int)page->index);
+		pgdata = kmap(page);
+		memset(pgdata, 0, PAGE_CACHE_SIZE);
+		SetPageUptodate(page);
+	}
+
+	unlock_page(page);
+	kunmap(page);
+
+	return 0;
+	
+err_1:
+	ifp_download_cleanup(sb, IRIVER_S(sb)->cleanup_state);
+	IRIVER_S(sb)->cleanup = IRIVER_S(sb)->cleanup_state
+		= NULL;
+err_2:
+	up(&IRIVER_S(sb)->lock);
+	SetPageError(page);
+	if (i) {
+		ifp_err_i(i, "returning error for page %d", (int)page->index);
+	} else {
+		ifp_err("*not* returning error for page %d.. wierd", (int)page->index);
+	}
+	unlock_page(page);
+
+	return i;
+}
+
+
+static struct inode_operations iriver_dir_inode_operations = {
+	.create		= create_new_file,
+	.lookup		= iriver_lookup,
+	.link		= iriver_link, //simple_link,
+	.unlink		= iriver_unlink, //simple_unlink,
+	.symlink	= iriver_symlink,
+	.mkdir		= iriver_mkdir,
+	.rmdir		= iriver_rmdir, //simple_rmdir,
+	.mknod		= iriver_mknod_EIO,
+	.rename		= iriver_rename, //simple_rename,
+	.getattr	= iriver_dir_getattr,
+	.setattr	= iriver_setattr,
+};
+
+//-------------------------------------------------------------------------
+//setup, initialization and cleanup
+static int driver_probe (struct usb_interface *intf,
+	const struct usb_device_id *id)
+{
+        return -ENODEV;
+}
+
+static void driver_disconnect(struct usb_interface *intf)
+{
+	struct super_block * sb = (struct super_block *)usb_get_intfdata(intf);
+	if (sb == NULL) {
+		printk("[driver_disconnect] sb is NULL.  returning.\n");
+        return;
+	}
+	if (sb->s_fs_info == NULL) {
+		printk("[driver_disconnect] sb->s_fs_info is NULL.  returning.\n");
+		return;
+	}
+	if (IRIVER_S(sb)->active) {
+		int i = 0;
+		struct usb_device * device_handle = IRIVER_S(sb)->dev->private;
+
+		printk("[driver_disconnect] unplugged!\n");
+
+		//The hope is when a device is unplugged, the thread currently
+		//holding the lock will get an IO error (because the device
+		//has disconnected) and return the lock fairly promptly.
+		down(&IRIVER_S(sb)->lock);
+		printk("[driver_disconnect] got lock.\n");
+		IRIVER_S(sb)->active = 0;
+
+		//The device has suddenly been unplugged.
+		//IRIVER_S(sb)->dev = NULL;
+
+		i = ifp_finalize(IRIVER_S(sb)->dev);
+		if (i) {
+			printk("[driver_disconnect] ifp_finalized returned %d.\n", i);
+		}
+		kfree(IRIVER_S(sb)->dev);
+		IRIVER_S(sb)->dev = NULL;
+		
+		ifp_os_release_device(device_handle);
+		device_handle = NULL;
+
+		up(&IRIVER_S(sb)->lock);
+	} else {
+		//Normal unmount
+		//printk("[driver_disconnect] shutting down normally.\n");
+	}
+
+	//printk("[driver_disconnect] closing usb interface..\n");
+
+	return;
+}
+
+struct usb_driver iriver_usb_driver = {
+	.owner =        THIS_MODULE,
+	.name =         "iRiverManagerFS",
+        .probe =        driver_probe,
+	.disconnect =   driver_disconnect,
+};
+
+void iriver_put_super(struct super_block * sb) {
+	struct iriver_sb_info * sbi;
+	sbi = (struct iriver_sb_info *)sb->s_fs_info;
+
+	if (sbi->active) {
+		sbi->active = 0;
+		cleanup(sb);
+	}
+	
+	//printk("[iriver_put_super] start\n");
+	if (IRIVER_S(sb)->dev == NULL) {
+		printk("[iriver_put_super] device disconnected.. skipping dev\n");
+	} else {
+		put_ifp_device(IRIVER_S(sb)->dev, 0);
+		IRIVER_S(sb)->dev = NULL;
+	}
+
+	kfree(sbi);
+	sbi = sb->s_fs_info = NULL;
+}
+
+static void iriver_read_inode(struct inode *i) {
+	printk("iriver_read_inode: start\n");
+	printk("iriver_read_inode is ");
+	if (i) {
+		printk("%d\n", (int)i->i_ino);
+	} else {
+		printk("null\n");
+	}
+	return ;
+}
+
+static kmem_cache_t * iriver_inode_cachep;
+kmem_cache_t * iriver_buffer_cachep;
+
+static struct inode * iriver_alloc_inode(struct super_block *sb) {
+	struct iriver_inode_info *ii = NULL;
+
+	//printk("In iriver_alloc_inode\n");
+	ii = (struct iriver_inode_info *)kmem_cache_alloc(iriver_inode_cachep,
+		SLAB_KERNEL);
+	if (ii == NULL) {
+		return NULL;
+	}
+	ii->loaded = 0;
+	ii->state = IFP_I_NORMAL;
+	return &ii->vfs_inode;
+}
+static void iriver_destroy_inode(struct inode * inode) {
+	kmem_cache_free(iriver_inode_cachep, IRIVER_I(inode));
+	return ;
+}
+
+static struct super_operations iriver_ops = {
+	.alloc_inode    = iriver_alloc_inode,
+	.destroy_inode  = iriver_destroy_inode,
+	.read_inode     = iriver_read_inode,
+	.statfs		= iriver_statfs,
+	.drop_inode	= generic_delete_inode,
+	.put_super	= iriver_put_super,
+};
+
+//---Device detection and initialization.---//
+
+//sleep in 1/10 of a second
+static int geoff_sleep(int ds) {
+	int i = 0;
+	int timeout = ds*HZ/10;
+	current->state = TASK_INTERRUPTIBLE;
+	timeout = schedule_timeout(timeout);
+	if (timeout) {
+		i = -EINTR;
+		//return i;
+	}
+	return i;
+}
+
+/*
+ * Sanity check.  If the device is absent or completely FUBAR, simple actions
+ * such as getting the model string, verison number and battery will likely
+ * fail.
+ *
+ * While we're at it, let's print out that information so users have something
+ * to email when they run into trouble.
+ */
+static int make_device_string(struct ifp_device * dev)
+{
+	int i;
+	char * s = get_iriver_buffer();
+	if (s == NULL) {
+		return -ENOMEM;
+	}
+
+	i = ifp_device_info(dev, s, IFP_BUFFER_SIZE);
+	if (i) {
+		printk("[make_device_string] device info failed. err %d\n", i);
+		goto out_0;
+	}
+	printk("iRiverFS: %s\n", s);
+
+out_0:
+	put_iriver_buffer(s);
+	s = NULL;
+
+	return i;
+}
+
+static int init_ifp_device(struct ifp_device * idev, struct usb_device * udev,
+	void * context_for_interface) 
+{
+	int i = 0;
+
+	if (udev == NULL || udev->actconfig == NULL
+		|| udev->actconfig->interface == NULL
+		|| udev->actconfig->interface[0] == NULL)
+	{
+		printk("iRiverFS: sorry, I couldn't claim the device's interface.  (Another driver might be using it.)\n");
+		
+		return -ENXIO;
+	}
+
+	//FIXME: find a more appropriate lock for this section.
+	//from usb/core.c: "Callers must own the driver model's usb bus writelock."
+	lock_kernel();
+	i = usb_driver_claim_interface(&iriver_usb_driver,
+		udev->actconfig->interface[0], context_for_interface);
+	unlock_kernel();
+	if (i) {
+		printk("iRiverFS: sorry, I couldn't claim the device's interface.  (Another driver might be using it.)\n");
+		i = -EBUSY;
+		goto out_err0;
+	}
+
+	i = ifp_init(idev, udev);
+	if (i) {
+		printk("[get_ifp_device] initialization failed.. err %d\n",i);
+		goto out_err1;
+	}
+	return i;
+
+out_err1:
+	lock_kernel();
+	usb_driver_release_interface(&iriver_usb_driver,
+		udev->actconfig->interface[0]);
+	unlock_kernel();
+out_err0:
+	return i;
+
+}
+
+static int get_ifp_device(struct ifp_device ** pdev, void * context_for_interface) 
+{
+	struct ifp_device * dev;
+	struct usb_device * device_handle;
+	int i;
+
+	dev = kmalloc(sizeof(struct ifp_device), GFP_KERNEL);
+	*pdev = dev;
+	if (!dev) {
+		i = -ENOMEM;
+		goto out_0;
+	}
+
+	device_handle = ifp_os_find_device();
+	if (!device_handle) {
+		printk("iRiverFS: sorry, I couldn't find a compatible iFP device.\n");
+		i = -ENODEV;
+		goto out_1;
+	}
+
+	i = init_ifp_device(dev, device_handle, context_for_interface);
+
+	//don't attempt resets if the device was busy
+	if (i == -ENXIO || i == -EBUSY) {
+		goto out_2;
+	}
+	if (i) {
+		printk("iRiverFS: device not responding, attempting software reset.\n");
+		i = usb_reset_device(device_handle);
+		if (i) { printk("error resetting device, err %d\n",i);}
+		geoff_sleep(3);
+		i = init_ifp_device(dev, device_handle, context_for_interface);
+		if (i == 0) {
+			printk("SUCCESSFUL RESET!!!! [first try] please tell geoff about this!\n");
+		}
+	}
+	if (i) {
+		printk("iRiverFS: device still not responding, attempting another reset.\n");
+		i = usb_reset_device(device_handle);
+		if (i) { printk("error resetting device, err %d\n",i);}
+		geoff_sleep(12);
+		i = init_ifp_device(dev, device_handle, context_for_interface);
+		if (i == 0) {
+			printk("SUCCESSFUL RESET!!!! [second try] please tell geoff about this!\n");
+		}
+	}
+	if (i) {
+		printk("iRiverFS: device not responding, giving up.\n");
+		goto out_2;
+	}
+
+	return 0;
+
+out_2:
+	ifp_os_release_device(device_handle);
+	//usb_put_dev(device_handle);
+out_1:
+	kfree(dev);
+	*pdev = dev = NULL;
+out_0:
+	return i;
+}
+
+static int put_ifp_device(struct ifp_device * dev, int disconnected)
+{
+	int i = 0;
+	struct usb_device * device_handle = dev->private;
+
+	i = ifp_finalize(dev);
+	if (i) {
+		printk("[put_ifp_device] got %d from ifp_finalize.\n", i);
+	}
+	kfree(dev);
+	dev = NULL;
+
+	if (!disconnected) {
+		lock_kernel();
+		usb_driver_release_interface(&iriver_usb_driver,
+			device_handle->actconfig->interface[0]);
+		unlock_kernel();
+	}
+	
+	ifp_os_release_device(device_handle);
+	//usb_put_dev(device_handle);
+
+	return 0;
+}
+
+enum {
+	Opt_uid, Opt_gid,
+	Opt_dmask, Opt_fmask,
+	Opt_err,
+};
+
+static match_table_t  iriver_tokens = {
+	{Opt_uid,   "uid=%u"},
+	{Opt_gid,   "gid=%u"},
+	{Opt_dmask, "dmask=%o"},
+	{Opt_fmask, "fmask=%o"},
+	{Opt_err,   NULL}
+};
+
+static int parse_options(char *options, struct iriver_mount_options * opts)
+{
+	int i = 0;
+
+	char *p;
+	substring_t args[MAX_OPT_ARGS];
+	int option;
+
+	if (!options) {
+		return 0;
+	}
+
+	while ((p = strsep(&options, ",")) != NULL) {
+		int token;
+		if (!*p)
+			continue;
+
+		token = match_token(p, iriver_tokens, args);
+		switch (token) {
+		case Opt_uid:
+			if (match_int(&args[0], &option))
+				return 0;
+			opts->uid = option;
+			break;
+		case Opt_gid:
+			if (match_int(&args[0], &option))
+				return 0;
+			opts->gid = option;
+			break;
+		case Opt_dmask:
+			if (match_octal(&args[0], &option))
+				return 0;
+			opts->dmask = option;
+			break;
+		case Opt_fmask:
+			if (match_octal(&args[0], &option))
+				return 0;
+			opts->fmask = option;
+			break;
+		default:
+			printk(KERN_ERR "unrecognized mount option %s or missing value\n", p);
+			return -EINVAL;
+		}
+	}
+
+
+	return i;
+}
+
+static int iriver_fill_super(struct super_block * sb, void * data, int silent)
+{
+	struct inode * inode;
+	struct dentry * root;
+	struct ifp_device * dev;
+	int i = 0;
+
+	sb->s_magic = IRIVERFS_MAGIC;
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+	sb->s_blocksize = IFP_BLOCK_SIZE_FAKE;
+	sb->s_blocksize_bits = IFP_BLOCK_BITS_FAKE;
+	sb->s_fs_info = kmalloc(sizeof(struct iriver_sb_info), GFP_KERNEL);
+	if (!sb->s_fs_info) {
+		i = -ENOMEM;
+		goto out_0;
+	}
+	sema_init(&IRIVER_S(sb)->lock, 0);
+	IRIVER_S(sb)->active        = 0;
+	IRIVER_S(sb)->options.uid   = current->fsuid;
+	IRIVER_S(sb)->options.gid   = current->fsgid;
+
+	//if the user wants executable files, (s)he can always set the umask
+	//manually.
+	IRIVER_S(sb)->options.fmask = 0111 | current->fs->umask;
+	IRIVER_S(sb)->options.dmask = 0000 | current->fs->umask;
+
+	i = parse_options(data, &IRIVER_S(sb)->options);
+	if (i) {
+		goto out_1;
+	}
+
+	i = get_ifp_device(&(IRIVER_S(sb)->dev), sb);
+	dev = IRIVER_S(sb)->dev;
+	if (i) {
+		if (i != -EBUSY) {
+		    printk("[iriver_fill_super] error allocating device. i=%d\n",i);
+		    if (i != -ENODEV) {
+			printk("iRiverFS: the device isn't responding.  "
+				"Try jiggling the handle.\n");
+			//set the error code to EBUSY.. it makes more sense than
+			//"fs not supported by kernel"
+			i = -EBUSY;
+		    }
+		}
+		goto out_1;
+	}
+	IRIVER_S(sb)->active = 1;
+	IRIVER_S(sb)->cleanup = NULL;
+
+	i = make_device_string(dev);
+	if (i) {
+		printk("[iriver_fill_super] error assembling the device string.\n");
+		goto out_2;
+	}
+
+	sb->s_op = &iriver_ops;
+	inode = iriver_get_inode(sb, S_IFDIR
+		| (S_IRWXUGO & ~IRIVER_S(sb)->options.dmask), 0);
+	if (!inode) {
+		i = -ENOMEM;
+		goto out_2;
+	}
+	IRIVER_I(inode)->loaded = 0;
+	IRIVER_I(inode)->state = IFP_I_NORMAL;
+
+	root = d_alloc_root(inode);
+	if (!root) {
+		i = -ENOMEM;
+		goto out_3;
+	}
+	sb->s_root = root;
+
+	//preloading inode/dentry info here would be too costly if someone put
+	//this in their fstab.  What would be better is if we could fork a
+	//child thread to do this in the background.
+
+	up(&IRIVER_S(sb)->lock);
+	return 0;
+
+//	d_delete(root);
+//	sb->s_root = root = NULL;
+out_3:
+	iput(inode);
+	inode = NULL;
+out_2:
+	IRIVER_S(sb)->active = 0;
+	put_ifp_device(IRIVER_S(sb)->dev, 0);
+	IRIVER_S(sb)->dev = NULL;
+out_1:
+	//spin_unlock(&IRIVER_S(sb)->lock);
+	up(&IRIVER_S(sb)->lock);
+	kfree(sb->s_fs_info);
+	sb->s_fs_info = NULL;
+out_0:
+	return i < 0 ? i : -EINVAL;
+}
+
+static struct super_block *iriver_get_sb(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data)
+{
+	return get_sb_nodev(fs_type, flags, data, iriver_fill_super);
+}
+
+static struct file_system_type iriver_fs_type = {
+	.name		= "iriver",
+	.get_sb		= iriver_get_sb,
+	.kill_sb	= kill_litter_super,
+};
+
+static void init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct iriver_inode_info *ei = (struct iriver_inode_info *) foo;
+
+	//printk("[init_once] %p\n", foo);
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+	    SLAB_CTOR_CONSTRUCTOR)
+	inode_init_once(&ei->vfs_inode);
+}
+static void destroy_twice(void * foo, kmem_cache_t * cachep, unsigned long flags)
+{
+	//printk("[destroy_twice] %p\n", foo);
+}
+static int init_inode_cache(void)
+{
+	iriver_inode_cachep = kmem_cache_create("iriver_inode_cachep",
+		sizeof(struct iriver_inode_info), 0,
+		SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once, destroy_twice);
+
+	iriver_buffer_cachep = kmem_cache_create("iriver_buffer_cachep",
+		0x0400, 0,
+		SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, NULL, NULL);
+
+	if (iriver_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+static void destroy_inode_cache(void)
+{
+	if (kmem_cache_destroy(iriver_inode_cachep)) {
+		printk(KERN_INFO "iriver_inode_cache: not all structures were freed\n");
+	}
+	iriver_inode_cachep = NULL;
+
+	if (kmem_cache_destroy(iriver_buffer_cachep)) {
+		printk(KERN_INFO "iriver_buffer_cache: not all structures were freed\n");
+	}
+	iriver_buffer_cachep = NULL;
+}
+
+static int __init init_iriver_fs(void)
+{
+	int i;
+
+	i = init_inode_cache();
+	if (i) {
+		printk("gfs.init_iriver_fs: error creating inode cache.\n");
+		goto out1;
+	}
+
+	i = usb_register(&iriver_usb_driver);
+	if (i) {
+		printk("gfs.init_iriver_fs: error registering usb driver. (%d)\n",i);
+		goto out_cache;
+	}
+
+	i = register_filesystem(&iriver_fs_type);
+	if (i)  {
+		printk("gfs.init_iriver_fs: error registering file system.\n");
+		goto out_usb;
+	}
+	printk("iRiverFS: successfully registered and initialized.\n");
+
+	return 0;
+
+out_usb:
+	printk("[init_iriver_fs] error, cleaning up usb.\n");
+	usb_deregister(&iriver_usb_driver);
+out_cache:
+	printk("[init_iriver_fs] error, cleaning up cache.\n");
+	destroy_inode_cache();
+out1:
+	printk("[init_iriver_fs] error somewhere.\n");
+	return i;
+}
+
+static void __exit exit_iriver_fs(void)
+{
+	unregister_filesystem(&iriver_fs_type);
+	usb_deregister(&iriver_usb_driver);
+	destroy_inode_cache();
+}
+
+module_init(init_iriver_fs)
+module_exit(exit_iriver_fs)
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("iRiver iFP Manager, linux vfs edition");
+MODULE_AUTHOR("Geoff Oakham");
+
diff -uprN -X ../dontdiff linux-2.6.9/fs/iriver/iriverfs.h linux-2.6.9-iriverfs-stable/fs/iriver/iriverfs.h
--- linux-2.6.9/fs/iriver/iriverfs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.9-iriverfs-stable/fs/iriver/iriverfs.h	2004-09-27 14:01:06.000000000 -0400
@@ -0,0 +1,21 @@
+/*
+ * data and functions global to the iriverFS driver.
+ * $Id$
+ *
+ * Copyright (C) Geoff Oakham, 2004; <oakhamg@users.sourceforge.net>
+ */
+
+#ifndef IRIVERFS_H
+#define IRIVERFS_H 1
+
+extern kmem_cache_t * iriver_buffer_cachep;
+
+static inline void * get_iriver_buffer(void) {
+	return kmem_cache_alloc(iriver_buffer_cachep, SLAB_KERNEL);
+}
+static inline void put_iriver_buffer(void * p) {
+	kmem_cache_free(iriver_buffer_cachep, p);
+}
+ 
+#endif //IRIVERFS_H
+
